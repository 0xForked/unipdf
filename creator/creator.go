//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

//
// Package creator is used for quickly generating pages and content with a simple interface.
// It is built on top of the model package to provide access to the most common
// operations such as creating text and image reports and manipulating existing pages.
//
package creator ;import (_ab "bytes";_ag "encoding/xml";_c "errors";_fe "fmt";_gb "github.com/gorilla/i18n/linebreak";_b "github.com/unidoc/unichart/render";_de "github.com/unidoc/unipdf/v3/common";_da "github.com/unidoc/unipdf/v3/contentstream";_bc "github.com/unidoc/unipdf/v3/contentstream/draw";
_gg "github.com/unidoc/unipdf/v3/core";_fa "github.com/unidoc/unipdf/v3/internal/graphic2d/svg";_ce "github.com/unidoc/unipdf/v3/internal/integrations/unichart";_cg "github.com/unidoc/unipdf/v3/internal/license";_ebg "github.com/unidoc/unipdf/v3/internal/transform";
_ed "github.com/unidoc/unipdf/v3/model";_eb "golang.org/x/text/unicode/bidi";_cd "image";_e "io";_gd "math";_cf "os";_d "regexp";_f "sort";_df "strconv";_ae "strings";_g "text/template";_ac "unicode";);

// Angle returns the block rotation angle in degrees.
func (_gc *Block )Angle ()float64 {return _gc ._bfa };

// SetExtends specifies whether to extend the shading beyond the starting and ending points.
//
// Text extends is set to `[]bool{false, false}` by default.
func (_ebag *shading )SetExtends (start bool ,end bool ){_ebag ._bbfa =[]bool {start ,end }};

// SetBorderWidth sets the border width.
func (_bcdb *PolyBezierCurve )SetBorderWidth (borderWidth float64 ){_bcdb ._adac .BorderWidth =borderWidth ;};

// GeneratePageBlocks generates the page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages. Implements the Drawable interface.
func (_dbbgb *StyledParagraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dfbfc :=ctx ;var _aacda []*Block ;_agafd :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _dbbgb ._cade .IsRelative (){ctx .X +=_dbbgb ._bgac .Left ;ctx .Y +=_dbbgb ._bgac .Top ;
ctx .Width -=_dbbgb ._bgac .Left +_dbbgb ._bgac .Right ;ctx .Height -=_dbbgb ._bgac .Top ;_dbbgb .SetWidth (ctx .Width );}else {if int (_dbbgb ._egeg )<=0{_dbbgb .SetWidth (_dbbgb .getTextWidth ()/1000.0);};ctx .X =_dbbgb ._dffgf ;ctx .Y =_dbbgb ._bccgg ;
};if _dbbgb ._dggcf !=nil {_dbbgb ._dggcf (_dbbgb ,ctx );};if _gdgcf :=_dbbgb .wrapText ();_gdgcf !=nil {return nil ,ctx ,_gdgcf ;};_ececb :=_dbbgb ._fgbg ;for {_bbab ,_cgbde ,_cecf :=_gageb (_agafd ,_dbbgb ,_ececb ,ctx );if _cecf !=nil {_de .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_cecf );
return nil ,ctx ,_cecf ;};ctx =_bbab ;_aacda =append (_aacda ,_agafd );if _ececb =_cgbde ;len (_cgbde )==0{break ;};_agafd =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_bbab =ctx ;_bbab .Y =ctx .Margins .Top ;_bbab .X =ctx .Margins .Left +_dbbgb ._bgac .Left ;
_bbab .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom ;_bbab .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_dbbgb ._bgac .Left -_dbbgb ._bgac .Right ;ctx =_bbab ;};if _dbbgb ._cade .IsRelative (){ctx .Y +=_dbbgb ._bgac .Bottom ;
ctx .Height -=_dbbgb ._bgac .Bottom ;if !ctx .Inline {ctx .X =_dfbfc .X ;ctx .Width =_dfbfc .Width ;};return _aacda ,ctx ,nil ;};return _aacda ,_dfbfc ,nil ;};

// AddLine adds a new line with the provided style to the table of contents.
func (_bbcff *TOC )AddLine (line *TOCLine )*TOCLine {if line ==nil {return nil ;};_bbcff ._gacd =append (_bbcff ._gacd ,line );return line ;};

// CellBorderSide defines the table cell's border side.
type CellBorderSide int ;

// SetTextVerticalAlignment sets the vertical alignment of the text within the
// bounds of the styled paragraph.
func (_aabe *StyledParagraph )SetTextVerticalAlignment (align TextVerticalAlignment ){_aabe ._ebdgb =align ;};

// SetOptimizer sets the optimizer to optimize PDF before writing.
func (_bfb *Creator )SetOptimizer (optimizer _ed .Optimizer ){_bfb ._cfad =optimizer };func (_cbfg *Creator )newPage ()*_ed .PdfPage {_dba :=_ed .NewPdfPage ();_cagf :=_cbfg ._cfc [0];_bgbb :=_cbfg ._cfc [1];_fbag :=_ed .PdfRectangle {Llx :0,Lly :0,Urx :_cagf ,Ury :_bgbb };
_dba .MediaBox =&_fbag ;_cbfg ._dea =_cagf ;_cbfg ._bgfe =_bgbb ;_cbfg .initContext ();return _dba ;};

// SetAngle would set the angle at which the gradient is rendered.
//
// The default angle would be 0 where the gradient would be rendered from left to right side.
func (_cbced *LinearShading )SetAngle (angle float64 ){_cbced ._gbcee =angle };

// PageFinalizeFunctionArgs holds the input arguments provided to the page
// finalize callback function which can be set using Creator.PageFinalize.
type PageFinalizeFunctionArgs struct{PageNum int ;PageWidth float64 ;PageHeight float64 ;TOCPages int ;TotalPages int ;};type containerDrawable interface{Drawable ;

// ContainerComponent checks if the component is allowed to be added into provided 'container' and returns
// preprocessed copy of itself. If the component is not changed it is allowed to return itself in a callback way.
// If the component is not compatible with provided container this method should return an error.
ContainerComponent (_fgdd Drawable )(Drawable ,error );};

// Context returns the current drawing context.
func (_egeb *Creator )Context ()DrawContext {return _egeb ._fafg };

// Width returns the width of the rectangle.
// NOTE: the returned value does not include the border width of the rectangle.
func (_gbae *Rectangle )Width ()float64 {return _gbae ._egbf };

// NewImage create a new image from a unidoc image (model.Image).
func (_gfgg *Creator )NewImage (img *_ed .Image )(*Image ,error ){return _acgaf (img )};

// SetAntiAlias enables anti alias config.
//
// Anti alias is disabled by default.
func (_defb *shading )SetAntiAlias (enable bool ){_defb ._ccaa =enable };

// SetMaxLines sets the maximum number of lines before the paragraph
// text is truncated.
func (_gefg *Paragraph )SetMaxLines (maxLines int ){_gefg ._adgd =maxLines ;_gefg .wrapText ()};

// GeneratePageBlocks generates the page blocks for the Division component.
// Multiple blocks are generated if the contents wrap over multiple pages.
func (_cadb *Division )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var (_ccc []*Block ;_ebgc bool ;_gbaaa error ;_abga =_cadb ._bbgd .IsRelative ();_gbgc =_cadb ._ccad .Top ;);if _abga &&!_cadb ._ceab &&!_cadb ._fbaa {_cbccca :=_cadb .ctxHeight (ctx .Width );
if _cbccca > ctx .Height -_cadb ._ccad .Top &&_cbccca <=ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom {if _ccc ,ctx ,_gbaaa =_afbg ().GeneratePageBlocks (ctx );_gbaaa !=nil {return nil ,ctx ,_gbaaa ;};_ebgc =true ;_gbgc =0;};};_ffad :=ctx ;_gcfb :=ctx ;
if _abga {ctx .X +=_cadb ._ccad .Left ;ctx .Y +=_gbgc ;ctx .Width -=_cadb ._ccad .Left +_cadb ._ccad .Right ;ctx .Height -=_gbgc ;_gcfb =ctx ;ctx .X +=_cadb ._cacc .Left ;ctx .Y +=_cadb ._cacc .Top ;ctx .Width -=_cadb ._cacc .Left +_cadb ._cacc .Right ;
ctx .Height -=_cadb ._cacc .Top ;ctx .Margins .Top +=_cadb ._cacc .Top ;ctx .Margins .Bottom +=_cadb ._cacc .Bottom ;ctx .Margins .Left +=_cadb ._ccad .Left +_cadb ._cacc .Left ;ctx .Margins .Right +=_cadb ._ccad .Right +_cadb ._cacc .Right ;};ctx .Inline =_cadb ._fbaa ;
_dfdbb :=ctx ;_ceaf :=ctx ;var _fbbe float64 ;for _ ,_fbed :=range _cadb ._cfadf {if ctx .Inline {if (ctx .X -_dfdbb .X )+_fbed .Width ()<=ctx .Width {ctx .Y =_ceaf .Y ;ctx .Height =_ceaf .Height ;}else {ctx .X =_dfdbb .X ;ctx .Width =_dfdbb .Width ;_ceaf .Y +=_fbbe ;
_ceaf .Height -=_fbbe ;_fbbe =0;};};_bbadf ,_feeb ,_abbf :=_fbed .GeneratePageBlocks (ctx );if _abbf !=nil {_de .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0069\u006eg\u0020p\u0061\u0067\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073\u003a\u0020\u0025\u0076",_abbf );
return nil ,ctx ,_abbf ;};if len (_bbadf )< 1{continue ;};if len (_ccc )> 0{_ccc [len (_ccc )-1].mergeBlocks (_bbadf [0]);_ccc =append (_ccc ,_bbadf [1:]...);}else {if _dfge :=_bbadf [0]._eg ;_dfge ==nil ||len (*_dfge )==0{_ebgc =true ;};_ccc =append (_ccc ,_bbadf [0:]...);
};if ctx .Inline {if ctx .Page !=_feeb .Page {_dfdbb .Y =ctx .Margins .Top ;_dfdbb .Height =ctx .PageHeight -ctx .Margins .Top ;_ceaf .Y =_dfdbb .Y ;_ceaf .Height =_dfdbb .Height ;_fbbe =_feeb .Height -_dfdbb .Height ;}else {if _cab :=ctx .Height -_feeb .Height ;
_cab > _fbbe {_fbbe =_cab ;};};}else {_feeb .X =ctx .X ;};ctx =_feeb ;};ctx .Inline =_ffad .Inline ;ctx .Margins =_ffad .Margins ;if _abga {ctx .X =_ffad .X ;ctx .Width =_ffad .Width ;ctx .Y +=_cadb ._cacc .Bottom ;ctx .Height -=_cadb ._cacc .Bottom ;};
if _cadb ._dbce !=nil {_ccc ,_gbaaa =_cadb .drawBackground (_ccc ,_gcfb ,ctx ,_ebgc );if _gbaaa !=nil {return nil ,ctx ,_gbaaa ;};};if _cadb ._bbgd .IsAbsolute (){return _ccc ,_ffad ,nil ;};ctx .Y +=_cadb ._ccad .Bottom ;ctx .Height -=_cadb ._ccad .Bottom ;
return _ccc ,ctx ,nil ;};

// Height returns the height of the ellipse.
func (_fcdb *Ellipse )Height ()float64 {return _fcdb ._bddb };func _cddc (_cgbf ,_dcee ,_agda ,_bcd float64 )*border {_fdb :=&border {};_fdb ._ddg =_cgbf ;_fdb ._bdgg =_dcee ;_fdb ._ebd =_agda ;_fdb ._eccb =_bcd ;_fdb ._ecbc =ColorBlack ;_fdb ._agd =ColorBlack ;
_fdb ._cbb =ColorBlack ;_fdb ._bbbg =ColorBlack ;_fdb ._ecg =0;_fdb ._aed =0;_fdb ._dbf =0;_fdb ._dfdb =0;_fdb .LineStyle =_bc .LineStyleSolid ;return _fdb ;};

// ToPdfShadingPattern generates a new model.PdfShadingPatternType3 object.
func (_fgge *RadialShading )ToPdfShadingPattern ()*_ed .PdfShadingPatternType3 {_addeb ,_abbba ,_addg :=_fgge ._baadc ._cddd .ToRGB ();_bdbc :=_fgge .shadingModel ();_bdbc .PdfShading .Background =_gg .MakeArrayFromFloats ([]float64 {_addeb ,_abbba ,_addg });
_fdbbg :=_ed .NewPdfShadingPatternType3 ();_fdbbg .Shading =_bdbc ;return _fdbbg ;};func (_caaefa *templateProcessor )parseLineStyleAttr (_bddd ,_bagd string )_bc .LineStyle {_de .Log .Debug ("\u0050\u0061\u0072\u0073\u0069n\u0067\u0020\u006c\u0069\u006e\u0065\u0020\u0073\u0074\u0079\u006c\u0065\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_bddd ,_bagd );
_ffee :=map[string ]_bc .LineStyle {"\u0073\u006f\u006ci\u0064":_bc .LineStyleSolid ,"\u0064\u0061\u0073\u0068\u0065\u0064":_bc .LineStyleDashed }[_bagd ];return _ffee ;};

// Color returns the color of the line.
func (_cega *Line )Color ()Color {return _cega ._ecge };

// IsAbsolute checks if the positioning is absolute.
func (_gfa Positioning )IsAbsolute ()bool {return _gfa ==PositionAbsolute };

// SetColorRight sets border color for right.
func (_gbgg *border )SetColorRight (col Color ){_gbgg ._bbbg =col };func (_gfegf *Paragraph )getMaxLineWidth ()float64 {if _gfegf ._babaa ==nil ||len (_gfegf ._babaa )==0{_gfegf .wrapText ();};var _fgded float64 ;for _ ,_eabcc :=range _gfegf ._babaa {_dggg :=_gfegf .getTextLineWidth (_eabcc );
if _dggg > _fgded {_fgded =_dggg ;};};return _fgded ;};

// GeneratePageBlocks draws the filled curve on page blocks.
func (_cfgc *FilledCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fgga :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_effd ,_ ,_adfa :=_cfgc .draw (_fgga ,"");if _adfa !=nil {return nil ,ctx ,_adfa ;};_adfa =_fgga .addContentsByString (string (_effd ));
if _adfa !=nil {return nil ,ctx ,_adfa ;};return []*Block {_fgga },ctx ,nil ;};func (_ea *Block )duplicate ()*Block {_bg :=&Block {};*_bg =*_ea ;_cfg :=_da .ContentStreamOperations {};_cfg =append (_cfg ,*_ea ._eg ...);_bg ._eg =&_cfg ;return _bg ;};

// Invoice represents a configurable invoice template.
type Invoice struct{_gad string ;_abfe *Image ;_eeaf *InvoiceAddress ;_ecefd *InvoiceAddress ;_gfcdb string ;_gbgcb [2]*InvoiceCell ;_gfce [2]*InvoiceCell ;_facg [2]*InvoiceCell ;_fgfg [][2]*InvoiceCell ;_deabd []*InvoiceCell ;_caca [][]*InvoiceCell ;_egfeg [2]*InvoiceCell ;
_ddeab [2]*InvoiceCell ;_aad [][2]*InvoiceCell ;_gbf [2]string ;_dgcce [2]string ;_gddb [][2]string ;_geb TextStyle ;_gdfc TextStyle ;_cace TextStyle ;_abee TextStyle ;_dcd TextStyle ;_fddc TextStyle ;_fadff TextStyle ;_bbeg InvoiceCellProps ;_dadd InvoiceCellProps ;
_caaef InvoiceCellProps ;_badgg InvoiceCellProps ;_dfec Positioning ;};

// GeneratePageBlocks draws the polyline on a new block representing the page.
// Implements the Drawable interface.
func (_agff *Polyline )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dcgeg :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_agfcf ,_ddgc :=_dcgeg .setOpacity (_agff ._eacac ,_agff ._eacac );if _ddgc !=nil {return nil ,ctx ,_ddgc ;
};_effcd :=_agff ._afgc .Points ;for _bebg :=range _effcd {_fgbfa :=&_effcd [_bebg ];_fgbfa .Y =ctx .PageHeight -_fgbfa .Y ;};_edba ,_ ,_ddgc :=_agff ._afgc .Draw (_agfcf );if _ddgc !=nil {return nil ,ctx ,_ddgc ;};if _ddgc =_dcgeg .addContentsByString (string (_edba ));
_ddgc !=nil {return nil ,ctx ,_ddgc ;};return []*Block {_dcgeg },ctx ,nil ;};

// SetStyleLeft sets border style for left side.
func (_edbe *border )SetStyleLeft (style CellBorderStyle ){_edbe ._agdc =style };

// SetFillOpacity sets the fill opacity of the ellipse.
func (_febe *Ellipse )SetFillOpacity (opacity float64 ){_febe ._bbcdd =opacity };

// MoveY moves the drawing context to absolute position y.
func (_cbdcf *Creator )MoveY (y float64 ){_cbdcf ._fafg .Y =y };

// SetBackgroundColor set background color of the shading area.
//
// By default the background color is set to white.
func (_gdeg *RadialShading )SetBackgroundColor (backgroundColor Color ){_gdeg ._baadc .SetBackgroundColor (backgroundColor );};

// Width returns the width of the Paragraph.
func (_aafa *Paragraph )Width ()float64 {if _aafa ._caba &&int (_aafa ._gbgcd )> 0{return _aafa ._gbgcd ;};return _aafa .getTextWidth ()/1000.0;};

// Margins represents page margins or margins around an element.
type Margins struct{Left float64 ;Right float64 ;Top float64 ;Bottom float64 ;};

// Add adds a new line with the default style to the table of contents.
func (_dffgg *TOC )Add (number ,title ,page string ,level uint )*TOCLine {_ebab :=_dffgg .AddLine (_bbce (TextChunk {Text :number ,Style :_dffgg ._acbdf },TextChunk {Text :title ,Style :_dffgg ._gacdf },TextChunk {Text :page ,Style :_dffgg ._gdbbc },level ,_dffgg ._ffcbf ));
if _ebab ==nil {return nil ;};_cfaed :=&_dffgg ._gfabb ;_ebab .SetMargins (_cfaed .Left ,_cfaed .Right ,_cfaed .Top ,_cfaed .Bottom );_ebab .SetLevelOffset (_dffgg ._dbdbe );_ebab .Separator .Text =_dffgg ._fbcdb ;_ebab .Separator .Style =_dffgg ._dgeff ;
return _ebab ;};type listItem struct{_ecde VectorDrawable ;_cgff TextChunk ;};

// PageFinalize sets a function to be called for each page before finalization
// (i.e. the last stage of page processing before they get written out).
// The callback function allows final touch-ups for each page, and it
// provides information that might not be known at other stages of designing
// the document (e.g. the total number of pages). Unlike the header/footer
// functions, which are limited to the top/bottom margins of the page, the
// finalize function can be used draw components anywhere on the current page.
func (_dbdc *Creator )PageFinalize (pageFinalizeFunc func (_fea PageFinalizeFunctionArgs )error ){_dbdc ._fbbf =pageFinalizeFunc ;};

// Height returns the height of the list.
func (_effa *List )Height ()float64 {var _bfdf float64 ;for _ ,_dggc :=range _effa ._dbgfa {_bfdf +=_dggc ._ecde .Height ();};return _bfdf ;};

// Total returns the invoice total description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_gecb *Invoice )Total ()(*InvoiceCell ,*InvoiceCell ){return _gecb ._ddeab [0],_gecb ._ddeab [1]};

// SetPos sets the position of the graphic svg to the specified coordinates.
// This method sets the graphic svg to use absolute positioning.
func (_agfb *GraphicSVG )SetPos (x ,y float64 ){_agfb ._fgdgc =PositionAbsolute ;_agfb ._gab =x ;_agfb ._eebf =y ;};func (_ecca *shading )generatePdfFunctions ()[]_ed .PdfFunction {if len (_ecca ._cdga )==0{return nil ;}else if len (_ecca ._cdga )<=2{_efed ,_caaf ,_gdef :=_ecca ._cdga [0]._gaed .ToRGB ();
_eegac ,_dddg ,_cgfea :=_ecca ._cdga [len (_ecca ._cdga )-1]._gaed .ToRGB ();return []_ed .PdfFunction {&_ed .PdfFunctionType2 {Domain :[]float64 {0.0,1.0},Range :[]float64 {0.0,1.0,0.0,1.0,0.0,1.0},N :1,C0 :[]float64 {_efed ,_caaf ,_gdef },C1 :[]float64 {_eegac ,_dddg ,_cgfea }}};
}else {_gagc :=[]_ed .PdfFunction {};_agfgg :=[]float64 {};for _aeee :=0;_aeee < len (_ecca ._cdga )-1;_aeee ++{_gabf ,_cceb ,_ffff :=_ecca ._cdga [_aeee ]._gaed .ToRGB ();_cgaf ,_dgdb ,_gbdc :=_ecca ._cdga [_aeee +1]._gaed .ToRGB ();_faac :=&_ed .PdfFunctionType2 {Domain :[]float64 {0.0,1.0},Range :[]float64 {0.0,1.0,0.0,1.0,0.0,1.0},N :1,C0 :[]float64 {_gabf ,_cceb ,_ffff },C1 :[]float64 {_cgaf ,_dgdb ,_gbdc }};
_gagc =append (_gagc ,_faac );if _aeee > 0{_agfgg =append (_agfgg ,_ecca ._cdga [_aeee ]._adcc );};};_agcae :=[]float64 {};for range _gagc {_agcae =append (_agcae ,[]float64 {0.0,1.0}...);};return []_ed .PdfFunction {&_ed .PdfFunctionType3 {Domain :[]float64 {0.0,1.0},Range :[]float64 {0.0,1.0,0.0,1.0,0.0,1.0},Functions :_gagc ,Bounds :_agfgg ,Encode :_agcae }};
};};func _effc (_agad [][]_bc .Point )*Polygon {return &Polygon {_gaecf :&_bc .Polygon {Points :_agad },_fegg :1.0,_daaf :1.0};};func (_bccf *StyledParagraph )wrapChunks (_dagd bool )error {if !_bccf ._ebeda ||int (_bccf ._egeg )<=0{_bccf ._fgbg =[][]*TextChunk {_bccf ._dfdf };
return nil ;};if _bccf ._egbc {_bccf .wrapWordChunks ();};_bccf ._fgbg =[][]*TextChunk {};var _ceddd []*TextChunk ;var _fgcdf float64 ;_ecaa :=_ac .IsSpace ;if !_dagd {_ecaa =func (rune )bool {return false };};_afbe :=_aggb (_bccf ._egeg *1000.0,0.000001);
for _ ,_efaf :=range _bccf ._dfdf {_bdbcc :=_efaf .Style ;_fdabc :=_efaf ._abcgd ;var (_gddg []rune ;_dbdeg []float64 ;);_dagaa :=_ggdbb (_efaf .Text );for _ ,_aebf :=range _efaf .Text {if _aebf =='\u000A'{if !_dagd {_gddg =append (_gddg ,_aebf );};_ceddd =append (_ceddd ,&TextChunk {Text :_ae .TrimRightFunc (string (_gddg ),_ecaa ),Style :_bdbcc ,_abcgd :_egbcf (_fdabc )});
_bccf ._fgbg =append (_bccf ._fgbg ,_ceddd );_ceddd =nil ;_fgcdf =0;_gddg =nil ;_dbdeg =nil ;continue ;};_eafd :=_aebf ==' ';_gaca ,_gfee :=_bdbcc .Font .GetRuneMetrics (_aebf );if !_gfee {_de .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_aebf );
return _c .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");};_bfgc :=_bdbcc .FontSize *_gaca .Wx *_bdbcc .horizontalScale ();_cbgf :=_bfgc ;if !_eafd {_cbgf =_bfgc +_bdbcc .CharSpacing *1000.0;
};if _fgcdf +_bfgc > _afbe {if _bccf ._egbc {if len (_ceddd )> 0{_bccf ._fgbg =append (_bccf ._fgbg ,_ceddd );_ceddd =[]*TextChunk {};};_gddg =append (_gddg ,_aebf );_dbdeg =append (_dbdeg ,_cbgf );_effge :=-1;if !_eafd {for _ebcb :=len (_gddg )-1;_ebcb >=0;
_ebcb --{if _gddg [_ebcb ]==' '{_effge =_ebcb ;break ;};};};if _effge >=0{_gddg =_gddg [_effge +1:];_dbdeg =_dbdeg [_effge +1:];};_fgcdf =0;for _ ,_abbd :=range _dbdeg {_fgcdf +=_abbd ;};continue ;};_fdfgg :=-1;if !_eafd {for _cgcc :=len (_gddg )-1;_cgcc >=0;
_cgcc --{if _gddg [_cgcc ]==' '{_fdfgg =_cgcc ;break ;};};};_ddfea :=string (_gddg );if _fdfgg >=0{_ddfea =string (_gddg [0:_fdfgg +1]);_gddg =_gddg [_fdfgg +1:];_gddg =append (_gddg ,_aebf );_dbdeg =_dbdeg [_fdfgg +1:];_dbdeg =append (_dbdeg ,_cbgf );
_fgcdf =0;for _ ,_eage :=range _dbdeg {_fgcdf +=_eage ;};}else {if _eafd {_fgcdf =0;_gddg =[]rune {};_dbdeg =[]float64 {};}else {_fgcdf =_cbgf ;_gddg =[]rune {_aebf };_dbdeg =[]float64 {_cbgf };};};_ddfea =_adfde (_ddfea ,_dagaa );if !_dagd &&_eafd {_ddfea +="\u0020";
};_ceddd =append (_ceddd ,&TextChunk {Text :_ae .TrimRightFunc (_ddfea ,_ecaa ),Style :_bdbcc ,_abcgd :_egbcf (_fdabc )});_bccf ._fgbg =append (_bccf ._fgbg ,_ceddd );_ceddd =[]*TextChunk {};}else {_fgcdf +=_cbgf ;_gddg =append (_gddg ,_aebf );_dbdeg =append (_dbdeg ,_cbgf );
};};if len (_gddg )> 0{_begce :=_adfde (string (_gddg ),_dagaa );_ceddd =append (_ceddd ,&TextChunk {Text :_begce ,Style :_bdbcc ,_abcgd :_egbcf (_fdabc )});};};if len (_ceddd )> 0{_bccf ._fgbg =append (_bccf ._fgbg ,_ceddd );};return nil ;};

// WriteToFile writes the Creator output to file specified by path.
func (_adde *Creator )WriteToFile (outputPath string )error {_cbccc ,_gbeb :=_cf .Create (outputPath );if _gbeb !=nil {return _gbeb ;};defer _cbccc .Close ();return _adde .Write (_cbccc );};

// ColorRGBFrom8bit creates a Color from 8-bit (0-255) r,g,b values.
// Example:
//   red := ColorRGBFrom8Bit(255, 0, 0)
func ColorRGBFrom8bit (r ,g ,b byte )Color {return rgbColor {_fbba :float64 (r )/255.0,_dbd :float64 (g )/255.0,_fdc :float64 (b )/255.0};};

// FitMode defines resizing options of an object inside a container.
type FitMode int ;

// RotateDeg rotates the current active page by angle degrees.  An error is returned on failure,
// which can be if there is no currently active page, or the angleDeg is not a multiple of 90 degrees.
func (_bgfb *Creator )RotateDeg (angleDeg int64 )error {_cgf :=_bgfb .getActivePage ();if _cgf ==nil {_de .Log .Debug ("F\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0065\u003a\u0020\u006e\u006f\u0020p\u0061\u0067\u0065\u0020\u0063\u0075\u0072\u0072\u0065\u006etl\u0079\u0020\u0061c\u0074i\u0076\u0065");
return _c .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};if angleDeg %90!=0{_de .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0050\u0061\u0067e\u0020\u0072\u006f\u0074\u0061\u0074\u0069on\u0020\u0061\u006e\u0067l\u0065\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006dul\u0074\u0069p\u006c\u0065\u0020\u006f\u0066\u0020\u0039\u0030");
return _c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};var _bbf int64 ;if _cgf .Rotate !=nil {_bbf =*(_cgf .Rotate );};_bbf +=angleDeg ;_cgf .Rotate =&_bbf ;return nil ;};

// SetStyleTop sets border style for top side.
func (_cdda *border )SetStyleTop (style CellBorderStyle ){_cdda ._cfe =style };

// ScaleToWidth scale Image to a specified width w, maintaining the aspect ratio.
func (_dbdgc *Image )ScaleToWidth (w float64 ){_dagbb :=_dbdgc ._fedbd /_dbdgc ._deac ;_dbdgc ._deac =w ;_dbdgc ._fedbd =w *_dagbb ;};func _befgg (_fgefg *templateProcessor ,_aaacge *templateNode )(interface{},error ){return _fgefg .parseChapter (_aaacge );
};

// SetTOC sets the table of content component of the creator.
// This method should be used when building a custom table of contents.
func (_bcfe *Creator )SetTOC (toc *TOC ){if toc ==nil {return ;};_bcfe ._cgec =toc ;};

// SetMargins sets the margins of the chart component.
func (_eaee *Chart )SetMargins (left ,right ,top ,bottom float64 ){_eaee ._bgff .Left =left ;_eaee ._bgff .Right =right ;_eaee ._bgff .Top =top ;_eaee ._bgff .Bottom =bottom ;};

// Height returns the height of the Paragraph. The height is calculated based on the input text and
// how it is wrapped within the container. Does not include Margins.
func (_abcfg *Paragraph )Height ()float64 {_abcfg .wrapText ();return float64 (len (_abcfg ._babaa ))*_abcfg ._ccef *_abcfg ._aee ;};

// SetTotal sets the total of the invoice.
func (_fda *Invoice )SetTotal (value string ){_fda ._ddeab [1].Value =value };

// TotalLines returns all the rows in the invoice totals table as
// description-value cell pairs.
func (_gdba *Invoice )TotalLines ()[][2]*InvoiceCell {_eegd :=[][2]*InvoiceCell {_gdba ._egfeg };_eegd =append (_eegd ,_gdba ._aad ...);return append (_eegd ,_gdba ._ddeab );};func _aebab (_fada ,_becb TextStyle )*Invoice {_bdfd :=&Invoice {_gad :"\u0049N\u0056\u004f\u0049\u0043\u0045",_gfcdb :"\u002c\u0020",_geb :_fada ,_gdfc :_becb };
_bdfd ._ecefd =&InvoiceAddress {Separator :_bdfd ._gfcdb };_bdfd ._eeaf =&InvoiceAddress {Heading :"\u0042i\u006c\u006c\u0020\u0074\u006f",Separator :_bdfd ._gfcdb };_ebgb :=ColorRGBFrom8bit (245,245,245);_aade :=ColorRGBFrom8bit (155,155,155);_bdfd ._cace =_becb ;
_bdfd ._cace .Color =_aade ;_bdfd ._cace .FontSize =20;_bdfd ._abee =_fada ;_bdfd ._dcd =_becb ;_bdfd ._fddc =_fada ;_bdfd ._fadff =_becb ;_bdfd ._bbeg =_bdfd .NewCellProps ();_bdfd ._bbeg .BackgroundColor =_ebgb ;_bdfd ._bbeg .TextStyle =_becb ;_bdfd ._dadd =_bdfd .NewCellProps ();
_bdfd ._dadd .TextStyle =_becb ;_bdfd ._dadd .BackgroundColor =_ebgb ;_bdfd ._dadd .BorderColor =_ebgb ;_bdfd ._caaef =_bdfd .NewCellProps ();_bdfd ._caaef .BorderColor =_ebgb ;_bdfd ._caaef .BorderSides =[]CellBorderSide {CellBorderSideBottom };_bdfd ._caaef .Alignment =CellHorizontalAlignmentRight ;
_bdfd ._badgg =_bdfd .NewCellProps ();_bdfd ._badgg .Alignment =CellHorizontalAlignmentRight ;_bdfd ._gbgcb =[2]*InvoiceCell {_bdfd .newCell ("\u0049\u006e\u0076\u006f\u0069\u0063\u0065\u0020\u006eu\u006d\u0062\u0065\u0072",_bdfd ._bbeg ),_bdfd .newCell ("",_bdfd ._bbeg )};
_bdfd ._gfce =[2]*InvoiceCell {_bdfd .newCell ("\u0044\u0061\u0074\u0065",_bdfd ._bbeg ),_bdfd .newCell ("",_bdfd ._bbeg )};_bdfd ._facg =[2]*InvoiceCell {_bdfd .newCell ("\u0044\u0075\u0065\u0020\u0044\u0061\u0074\u0065",_bdfd ._bbeg ),_bdfd .newCell ("",_bdfd ._bbeg )};
_bdfd ._egfeg =[2]*InvoiceCell {_bdfd .newCell ("\u0053\u0075\u0062\u0074\u006f\u0074\u0061\u006c",_bdfd ._badgg ),_bdfd .newCell ("",_bdfd ._badgg )};_ggdd :=_bdfd ._badgg ;_ggdd .TextStyle =_becb ;_ggdd .BackgroundColor =_ebgb ;_ggdd .BorderColor =_ebgb ;
_bdfd ._ddeab =[2]*InvoiceCell {_bdfd .newCell ("\u0054\u006f\u0074a\u006c",_ggdd ),_bdfd .newCell ("",_ggdd )};_bdfd ._gbf =[2]string {"\u004e\u006f\u0074e\u0073",""};_bdfd ._dgcce =[2]string {"T\u0065r\u006d\u0073\u0020\u0061\u006e\u0064\u0020\u0063o\u006e\u0064\u0069\u0074io\u006e\u0073",""};
_bdfd ._deabd =[]*InvoiceCell {_bdfd .newColumn ("D\u0065\u0073\u0063\u0072\u0069\u0070\u0074\u0069\u006f\u006e",CellHorizontalAlignmentLeft ),_bdfd .newColumn ("\u0051\u0075\u0061\u006e\u0074\u0069\u0074\u0079",CellHorizontalAlignmentRight ),_bdfd .newColumn ("\u0055\u006e\u0069\u0074\u0020\u0070\u0072\u0069\u0063\u0065",CellHorizontalAlignmentRight ),_bdfd .newColumn ("\u0041\u006d\u006f\u0075\u006e\u0074",CellHorizontalAlignmentRight )};
return _bdfd ;};

// SetBorderColor sets the cell's border color.
func (_aaacg *TableCell )SetBorderColor (col Color ){_aaacg ._ggab =col ;_aaacg ._ebdf =col ;_aaacg ._efgfc =col ;_aaacg ._bgdb =col ;};

// SetMargins sets the margins of the ellipse.
// NOTE: ellipse margins are only applied if relative positioning is used.
func (_afda *Ellipse )SetMargins (left ,right ,top ,bottom float64 ){_afda ._ccac .Left =left ;_afda ._ccac .Right =right ;_afda ._ccac .Top =top ;_afda ._ccac .Bottom =bottom ;};

// ColorCMYKFromArithmetic creates a Color from arithmetic color values (0-1).
// Example:
//   green := ColorCMYKFromArithmetic(1.0, 0.0, 1.0, 0.0)
func ColorCMYKFromArithmetic (c ,m ,y ,k float64 )Color {return cmykColor {_bca :_gd .Max (_gd .Min (c ,1.0),0.0),_cdgdd :_gd .Max (_gd .Min (m ,1.0),0.0),_cebb :_gd .Max (_gd .Min (y ,1.0),0.0),_dfbe :_gd .Max (_gd .Min (k ,1.0),0.0)};};

// BorderOpacity returns the border opacity of the rectangle (0-1).
func (_dbeb *Rectangle )BorderOpacity ()float64 {return _dbeb ._bedf };func _fbbaf (_afbea *Creator ,_cgdde []byte ,_ebceg *TemplateOptions ,_eefac componentRenderer )*templateProcessor {if _ebceg ==nil {_ebceg =&TemplateOptions {};};_ebceg .init ();if _eefac ==nil {_eefac =_afbea ;
};return &templateProcessor {creator :_afbea ,_afbd :_cgdde ,_afgab :_ebceg ,_bddg :_eefac };};

// CellHorizontalAlignment defines the table cell's horizontal alignment.
type CellHorizontalAlignment int ;

// DrawContext defines the drawing context. The DrawContext is continuously used and updated when
// drawing the page contents in relative mode.  Keeps track of current X, Y position, available
// height as well as other page parameters such as margins and dimensions.
type DrawContext struct{

// Current page number.
Page int ;

// Current position.  In a relative positioning mode, a drawable will be placed at these coordinates.
X ,Y float64 ;

// Context dimensions.  Available width and height (on current page).
Width ,Height float64 ;

// Page Margins.
Margins Margins ;

// Absolute Page size, widths and height.
PageWidth float64 ;PageHeight float64 ;

// Controls whether the components are stacked horizontally
Inline bool ;_dgccf rune ;_ddeg []error ;};

// Inline returns whether the inline mode of the division is active.
func (_aeca *Division )Inline ()bool {return _aeca ._fbaa };

// Opacity returns the opacity of the line.
func (_dccfa *Line )Opacity ()float64 {return _dccfa ._edaf };

// TextVerticalAlignment controls the vertical position of the text
// in a styled paragraph.
type TextVerticalAlignment int ;

// SetColorBottom sets border color for bottom.
func (_edce *border )SetColorBottom (col Color ){_edce ._agd =col };func (_adgc *Image )applyFitMode (_eedd float64 ){_eedd -=_adgc ._baaa .Left +_adgc ._baaa .Right ;switch _adgc ._fdgd {case FitModeFillWidth :_adgc .ScaleToWidth (_eedd );};};func (_adga *Ellipse )applyFitMode (_geeg float64 ){_geeg -=_adga ._ccac .Left +_adga ._ccac .Right ;
switch _adga ._cfef {case FitModeFillWidth :_adga .ScaleToWidth (_geeg );};};

// NewBlockFromPage creates a Block from a PDF Page.  Useful for loading template pages as blocks
// from a PDF document and additional content with the creator.
func NewBlockFromPage (page *_ed .PdfPage )(*Block ,error ){_dc :=&Block {};_fd ,_fg :=page .GetAllContentStreams ();if _fg !=nil {return nil ,_fg ;};_dd :=_da .NewContentStreamParser (_fd );_cef ,_fg :=_dd .Parse ();if _fg !=nil {return nil ,_fg ;};_cef .WrapIfNeeded ();
_dc ._eg =_cef ;if page .Resources !=nil {_dc ._bf =page .Resources ;}else {_dc ._bf =_ed .NewPdfPageResources ();};_abg ,_fg :=page .GetMediaBox ();if _fg !=nil {return nil ,_fg ;};if _abg .Llx !=0||_abg .Lly !=0{_dc .translate (-_abg .Llx ,_abg .Lly );
};_dc ._beg =_abg .Urx -_abg .Llx ;_dc ._fc =_abg .Ury -_abg .Lly ;if page .Rotate !=nil {_dc ._bfa =-float64 (*page .Rotate );};return _dc ,nil ;};

// NewGraphicSVGFromString creates a graphic SVG from a SVG string.
func NewGraphicSVGFromString (svgStr string )(*GraphicSVG ,error ){return _ead (svgStr )};

// RadialShading holds information that will be used to render a radial shading.
type RadialShading struct{_baadc *shading ;_bgga *_ed .PdfRectangle ;_aedf AnchorPoint ;_bgfad float64 ;_cgaea float64 ;_efad float64 ;_bede float64 ;};

// SetBorderWidth sets the border width of the rectangle.
func (_ccce *Rectangle )SetBorderWidth (bw float64 ){_ccce ._gaffd =bw };

// FillOpacity returns the fill opacity of the rectangle (0-1).
func (_faff *Rectangle )FillOpacity ()float64 {return _faff ._eeed };

// NewGraphicSVGFromFile creates a graphic SVG from a file.
func NewGraphicSVGFromFile (path string )(*GraphicSVG ,error ){return _bcce (path )};

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_dcdc *Paragraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _dcdc ._bcbe .Left ,_dcdc ._bcbe .Right ,_dcdc ._bcbe .Top ,_dcdc ._bcbe .Bottom ;};

// SetPos sets absolute positioning with specified coordinates.
func (_cdbda *Paragraph )SetPos (x ,y float64 ){_cdbda ._gbfg =PositionAbsolute ;_cdbda ._fgef =x ;_cdbda ._cbcaf =y ;};func _ead (_efdg string )(*GraphicSVG ,error ){_eceg ,_ged :=_fa .ParseFromString (_efdg );if _ged !=nil {return nil ,_ged ;};return _cggg (_eceg );
};

// Width returns the width of the chart. In relative positioning mode,
// all the available context width is used at render time.
func (_efba *Chart )Width ()float64 {return float64 (_efba ._caa .Width ())};func _ffe (_fbb ,_abef *_ed .PdfPageResources )error {_faf ,_ :=_fbb .GetColorspaces ();if _faf !=nil &&len (_faf .Colorspaces )> 0{for _bgf ,_eaf :=range _faf .Colorspaces {_cad :=*_gg .MakeName (_bgf );
if _abef .HasColorspaceByName (_cad ){continue ;};_fcd :=_abef .SetColorspaceByName (_cad ,_eaf );if _fcd !=nil {return _fcd ;};};};return nil ;};const (PositionRelative Positioning =iota ;PositionAbsolute ;);

// SetBackground sets the background properties of the component.
func (_acgac *Division )SetBackground (background *Background ){_acgac ._dbce =background };const (CellHorizontalAlignmentLeft CellHorizontalAlignment =iota ;CellHorizontalAlignmentCenter ;CellHorizontalAlignmentRight ;);

// Width returns the width of the line.
// NOTE: Depending on the fit mode the line is set to use, its width may be
// calculated at runtime (e.g. when using FitModeFillWidth).
func (_febga *Line )Width ()float64 {return _gd .Abs (_febga ._bfba -_febga ._ecfe )};

// Terms returns the terms and conditions section of the invoice as a
// title-content pair.
func (_dcea *Invoice )Terms ()(string ,string ){return _dcea ._dgcce [0],_dcea ._dgcce [1]};

// SetWidth sets line width.
func (_gbad *Curve )SetWidth (width float64 ){_gbad ._feba =width };

// NewRadialGradientColor creates a radial gradient color that could act as a color in other componenents.
// Note: The innerRadius must be smaller than outerRadius for the circle to render properly.
func (_aef *Creator )NewRadialGradientColor (x float64 ,y float64 ,innerRadius float64 ,outerRadius float64 ,colorPoints []*ColorPoint )*RadialShading {return _cafd (x ,y ,innerRadius ,outerRadius ,colorPoints );};

// Height returns the Block's height.
func (_bd *Block )Height ()float64 {return _bd ._fc };

// NewLinearGradientColor creates a linear gradient color that could act as a color in other components.
func (_ffd *Creator )NewLinearGradientColor (colorPoints []*ColorPoint )*LinearShading {return _fefea (colorPoints ,true );};func (_efecb *Line )computeCoords (_fbeg DrawContext )(_acgab ,_bcgcb ,_cccd ,_bgfg float64 ){_acgab =_fbeg .X ;_cccd =_acgab +_efecb ._bfba -_efecb ._ecfe ;
_ecee :=_efecb ._cdbc ;if _efecb ._ecfe ==_efecb ._bfba {_ecee /=2;};if _efecb ._ecec < _efecb ._gbbeb {_bcgcb =_fbeg .PageHeight -_fbeg .Y -_ecee ;_bgfg =_bcgcb -_efecb ._gbbeb +_efecb ._ecec ;}else {_bgfg =_fbeg .PageHeight -_fbeg .Y -_ecee ;_bcgcb =_bgfg -_efecb ._ecec +_efecb ._gbbeb ;
};switch _efecb ._facce {case FitModeFillWidth :_cccd =_acgab +_fbeg .Width ;};return _acgab ,_bcgcb ,_cccd ,_bgfg ;};func (_gf *Block )setOpacity (_cga float64 ,_dcb float64 )(string ,error ){if (_cga < 0||_cga >=1.0)&&(_dcb < 0||_dcb >=1.0){return "",nil ;
};_cda :=0;_ceg :=_fe .Sprintf ("\u0047\u0053\u0025\u0064",_cda );for _gf ._bf .HasExtGState (_gg .PdfObjectName (_ceg )){_cda ++;_ceg =_fe .Sprintf ("\u0047\u0053\u0025\u0064",_cda );};_bac :=_gg .MakeDict ();if _cga >=0&&_cga < 1.0{_bac .Set ("\u0063\u0061",_gg .MakeFloat (_cga ));
};if _dcb >=0&&_dcb < 1.0{_bac .Set ("\u0043\u0041",_gg .MakeFloat (_dcb ));};_def :=_gf ._bf .AddExtGState (_gg .PdfObjectName (_ceg ),_bac );if _def !=nil {return "",_def ;};return _ceg ,nil ;};

// SetPageSize sets the Creator's page size.  Pages that are added after this will be created with
// this Page size.
// Does not affect pages already created.
//
// Common page sizes are defined as constants.
// Examples:
// 1. c.SetPageSize(creator.PageSizeA4)
// 2. c.SetPageSize(creator.PageSizeA3)
// 3. c.SetPageSize(creator.PageSizeLegal)
// 4. c.SetPageSize(creator.PageSizeLetter)
//
// For custom sizes: Use the PPMM (points per mm) and PPI (points per inch) when defining those based on
// physical page sizes:
//
// Examples:
// 1. 10x15 sq. mm: SetPageSize(PageSize{10*creator.PPMM, 15*creator.PPMM}) where PPMM is points per mm.
// 2. 3x2 sq. inches: SetPageSize(PageSize{3*creator.PPI, 2*creator.PPI}) where PPI is points per inch.
func (_beag *Creator )SetPageSize (size PageSize ){_beag ._cfc =size ;_beag ._dea =size [0];_beag ._bgfe =size [1];_gcg :=0.1*_beag ._dea ;_beag ._bffb .Left =_gcg ;_beag ._bffb .Right =_gcg ;_beag ._bffb .Top =_gcg ;_beag ._bffb .Bottom =_gcg ;};

// ScaleToHeight scales the Block to a specified height, maintaining the same aspect ratio.
func (_cgab *Block )ScaleToHeight (h float64 ){_dbc :=h /_cgab ._fc ;_cgab .Scale (_dbc ,_dbc )};

// SetBackgroundColor sets the cell's background color.
func (_cdbdg *TableCell )SetBackgroundColor (col Color ){_cdbdg ._ebgbd =col };

// NewTable create a new Table with a specified number of columns.
func (_gcda *Creator )NewTable (cols int )*Table {return _bcfa (cols )};func (_cbc *Block )translate (_bee ,_deg float64 ){_dag :=_da .NewContentCreator ().Translate (_bee ,-_deg ).Operations ();*_cbc ._eg =append (*_dag ,*_cbc ._eg ...);_cbc ._eg .WrapIfNeeded ();
};

// NewStyledParagraph creates a new styled paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_gefc *Creator )NewStyledParagraph ()*StyledParagraph {return _fecf (_gefc .NewTextStyle ())};

// SetBorderLineStyle sets border style (currently dashed or plain).
func (_fggbg *TableCell )SetBorderLineStyle (style _bc .LineStyle ){_fggbg ._eacgd =style };func _afbg ()*PageBreak {return &PageBreak {}};

// VectorDrawable is a Drawable with a specified width and height.
type VectorDrawable interface{Drawable ;

// Width returns the width of the Drawable.
Width ()float64 ;

// Height returns the height of the Drawable.
Height ()float64 ;};func (_ddcef *Invoice )generateHeaderBlocks (_aeagg DrawContext )([]*Block ,DrawContext ,error ){_bgfdf :=_fecf (_ddcef ._cace );_bgfdf .SetEnableWrap (true );_bgfdf .Append (_ddcef ._gad );_ccccg :=_bcfa (2);if _ddcef ._abfe !=nil {_gabd :=_ccccg .NewCell ();
_gabd .SetHorizontalAlignment (CellHorizontalAlignmentLeft );_gabd .SetVerticalAlignment (CellVerticalAlignmentMiddle );_gabd .SetIndent (0);_gabd .SetContent (_ddcef ._abfe );_ddcef ._abfe .ScaleToHeight (_bgfdf .Height ()+20);}else {_ccccg .SkipCells (1);
};_cedb :=_ccccg .NewCell ();_cedb .SetHorizontalAlignment (CellHorizontalAlignmentRight );_cedb .SetVerticalAlignment (CellVerticalAlignmentMiddle );_cedb .SetContent (_bgfdf );return _ccccg .GeneratePageBlocks (_aeagg );};

// SetInline sets the inline mode of the division.
func (_fade *Division )SetInline (inline bool ){_fade ._fbaa =inline };func _fecf (_gagd TextStyle )*StyledParagraph {return &StyledParagraph {_dfdf :[]*TextChunk {},_fega :_gagd ,_feada :_dgegf (_gagd .Font ),_gcba :1.0,_fbgd :TextAlignmentLeft ,_ebeda :true ,_ccafg :true ,_egbc :false ,_caag :0,_adgag :1,_begg :1,_cade :PositionRelative };
};const (FitModeNone FitMode =iota ;FitModeFillWidth ;);func (_fggd *templateProcessor )parseStyledParagraph (_agffg *templateNode )(interface{},error ){_ecdf :=_fggd .creator .NewStyledParagraph ();for _ ,_facgc :=range _agffg ._fcdbfb .Attr {_addd :=_facgc .Value ;
switch _cbeg :=_facgc .Name .Local ;_cbeg {case "\u0074\u0065\u0078\u0074\u002d\u0061\u006c\u0069\u0067\u006e":_ecdf .SetTextAlignment (_fggd .parseTextAlignmentAttr (_cbeg ,_addd ));case "\u0076\u0065\u0072\u0074ic\u0061\u006c\u002d\u0074\u0065\u0078\u0074\u002d\u0061\u006c\u0069\u0067\u006e":_ecdf .SetTextVerticalAlignment (_fggd .parseTextVerticalAlignmentAttr (_cbeg ,_addd ));
case "l\u0069\u006e\u0065\u002d\u0068\u0065\u0069\u0067\u0068\u0074":_ecdf .SetLineHeight (_fggd .parseFloatAttr (_cbeg ,_addd ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_ddggf :=_fggd .parseMarginAttr (_cbeg ,_addd );_ecdf .SetMargins (_ddggf .Left ,_ddggf .Right ,_ddggf .Top ,_ddggf .Bottom );
case "e\u006e\u0061\u0062\u006c\u0065\u002d\u0077\u0072\u0061\u0070":_ecdf .SetEnableWrap (_fggd .parseBoolAttr (_cbeg ,_addd ));case "\u0065\u006ea\u0062\u006c\u0065-\u0077\u006f\u0072\u0064\u002d\u0077\u0072\u0061\u0070":_ecdf .EnableWordWrap (_fggd .parseBoolAttr (_cbeg ,_addd ));
case "\u0074\u0065\u0078\u0074\u002d\u006f\u0076\u0065\u0072\u0066\u006c\u006f\u0077":_ecdf .SetTextOverflow (_fggd .parseTextOverflowAttr (_cbeg ,_addd ));case "\u0078":_ecdf .SetPos (_fggd .parseFloatAttr (_cbeg ,_addd ),_ecdf ._bccgg );case "\u0079":_ecdf .SetPos (_ecdf ._dffgf ,_fggd .parseFloatAttr (_cbeg ,_addd ));
case "\u0061\u006e\u0067l\u0065":_ecdf .SetAngle (_fggd .parseFloatAttr (_cbeg ,_addd ));default:_de .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0073\u0074\u0079l\u0065\u0064 \u0070\u0061\u0072\u0061\u0067\u0072a\u0070h \u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_cbeg );
};};return _ecdf ,nil ;};

// SetLineNumberStyle sets the style for the numbers part of all new lines
// of the table of contents.
func (_gcbgd *TOC )SetLineNumberStyle (style TextStyle ){_gcbgd ._acbdf =style };func _bcea (_eeef *Table ,_aabb DrawContext )([]*Block ,DrawContext ,error ){var _eefe []*Block ;_ccgcg :=NewBlock (_aabb .PageWidth ,_aabb .PageHeight );_eeef .updateRowHeights (_aabb .Width -_eeef ._effe .Left -_eeef ._effe .Right );
_dbdfd :=_eeef ._effe .Top ;if _eeef ._fbcdg .IsRelative ()&&!_eeef ._geega {_ccfeg :=_eeef .Height ();if _ccfeg > _aabb .Height -_eeef ._effe .Top &&_ccfeg <=_aabb .PageHeight -_aabb .Margins .Top -_aabb .Margins .Bottom {_eefe =[]*Block {NewBlock (_aabb .PageWidth ,_aabb .PageHeight -_aabb .Y )};
var _fadb error ;if _ ,_aabb ,_fadb =_afbg ().GeneratePageBlocks (_aabb );_fadb !=nil {return nil ,_aabb ,_fadb ;};_dbdfd =0;};};_geddc :=_aabb ;if _eeef ._fbcdg .IsAbsolute (){_aabb .X =_eeef ._bgacf ;_aabb .Y =_eeef ._gdcc ;}else {_aabb .X +=_eeef ._effe .Left ;
_aabb .Y +=_dbdfd ;_aabb .Width -=_eeef ._effe .Left +_eeef ._effe .Right ;_aabb .Height -=_dbdfd ;};_gbed :=_aabb .Width ;_age :=_aabb .X ;_edfef :=_aabb .Y ;_fbfe :=_aabb .Height ;_bfadg :=0;_fagcb ,_ebeg :=-1,-1;if _eeef ._decbc {for _gcdc ,_dfgfb :=range _eeef ._ddbf {if _dfgfb ._dgad < _eeef ._edbcf {continue ;
};if _dfgfb ._dgad > _eeef ._bgab {break ;};if _fagcb < 0{_fagcb =_gcdc ;};_ebeg =_gcdc ;};};if _gbfa :=_eeef .wrapContent (_aabb );_gbfa !=nil {return nil ,_aabb ,_gbfa ;};_eeef .updateRowHeights (_aabb .Width -_eeef ._effe .Left -_eeef ._effe .Right );
var (_faacc bool ;_aedg int ;_dedeb int ;_badgfd bool ;_fdac int ;_efbdb error ;);for _gbggf :=0;_gbggf < len (_eeef ._ddbf );_gbggf ++{_eaba :=_eeef ._ddbf [_gbggf ];_fcdbf :=_eaba .width (_eeef ._gcfd ,_gbed );_fgdae :=float64 (0.0);for _cccee :=0;_cccee < _eaba ._abdgb -1;
_cccee ++{_fgdae +=_eeef ._gcfd [_cccee ]*_gbed ;};_fegaa :=float64 (0.0);for _acaeb :=_bfadg ;_acaeb < _eaba ._dgad -1;_acaeb ++{_fegaa +=_eeef ._accga [_acaeb ];};_aabb .Height =_fbfe -_fegaa ;_abca :=float64 (0.0);for _gcfad :=0;_gcfad < _eaba ._efdb ;
_gcfad ++{_abca +=_eeef ._accga [_eaba ._dgad +_gcfad -1];};_gegee :=_badgfd &&_eaba ._dgad !=_fdac ;_fdac =_eaba ._dgad ;if _gegee ||_abca > _aabb .Height {if _eeef ._egbga &&!_badgfd {_badgfd ,_efbdb =_eeef .wrapRow (_gbggf ,_aabb ,_gbed ,_fbfe );if _efbdb !=nil {return nil ,_aabb ,_efbdb ;
};if _badgfd {_gbggf --;continue ;};};_eefe =append (_eefe ,_ccgcg );_ccgcg =NewBlock (_aabb .PageWidth ,_aabb .PageHeight );_age =_aabb .Margins .Left +_eeef ._effe .Left ;_edfef =_aabb .Margins .Top ;_aabb .Height =_aabb .PageHeight -_aabb .Margins .Top -_aabb .Margins .Bottom ;
_aabb .Page ++;_fbfe =_aabb .Height ;_bfadg =_eaba ._dgad -1;_fegaa =0;_badgfd =false ;if _eeef ._decbc &&_fagcb >=0{_aedg =_gbggf ;_gbggf =_fagcb -1;_dedeb =_bfadg ;_bfadg =_eeef ._edbcf -1;_faacc =true ;if _eaba ._efdb > (_eeef ._bebea -_fdac )||(_eaba ._efdb > 1&&_gbggf < 0){_de .Log .Debug ("\u0054a\u0062\u006ce\u0020\u0068\u0065a\u0064\u0065\u0072\u0020\u0072\u006f\u0077s\u0070\u0061\u006e\u0020\u0065\u0078c\u0065\u0065\u0064\u0073\u0020\u0061\u0076\u0061\u0069\u006c\u0061b\u006c\u0065\u0020\u0073\u0070\u0061\u0063\u0065\u002e");
_faacc =false ;_fagcb ,_ebeg =-1,-1;};continue ;};if _gegee {_gbggf --;continue ;};};_aabb .Width =_fcdbf ;_aabb .X =_age +_fgdae ;_aabb .Y =_edfef +_fegaa ;_bafa :=_cddc (_aabb .X ,_aabb .Y ,_fcdbf ,_abca );if _eaba ._ebgbd !=nil {_bafa .SetFillColor (_eaba ._ebgbd );
};_bafa .LineStyle =_eaba ._eacgd ;_bafa ._agdc =_eaba ._afcc ;_bafa ._dfde =_eaba ._gdbg ;_bafa ._cfe =_eaba ._acgb ;_bafa ._bde =_eaba ._ccbfd ;if _eaba ._ggab !=nil {_bafa .SetColorLeft (_eaba ._ggab );};if _eaba ._ebdf !=nil {_bafa .SetColorBottom (_eaba ._ebdf );
};if _eaba ._efgfc !=nil {_bafa .SetColorRight (_eaba ._efgfc );};if _eaba ._bgdb !=nil {_bafa .SetColorTop (_eaba ._bgdb );};_bafa .SetWidthBottom (_eaba ._ecgbf );_bafa .SetWidthLeft (_eaba ._cfdac );_bafa .SetWidthRight (_eaba ._efbec );_bafa .SetWidthTop (_eaba ._aedea );
_bacc :=_ccgcg .Draw (_bafa );if _bacc !=nil {_de .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_bacc );};if _eaba ._dafd !=nil {_gbee :=_eaba ._dafd .Width ();_agab :=_eaba ._dafd .Height ();_aefg :=0.0;switch _gbaec :=_eaba ._dafd .(type ){case *Paragraph :if _gbaec ._caba {_gbee =_gbaec .getMaxLineWidth ()/1000.0;
};_gbee +=_gbaec ._bcbe .Left +_gbaec ._bcbe .Right ;_agab +=_gbaec ._bcbe .Top +_gbaec ._bcbe .Bottom ;case *StyledParagraph :if _gbaec ._ebeda {_gbee =_gbaec .getMaxLineWidth ()/1000.0;};_bdeca ,_bebd ,_agdbg :=_gbaec .getLineMetrics (0);_fffcg ,_fcaga :=_bdeca *_gbaec ._gcba ,_bebd *_gbaec ._gcba ;
if _gbaec ._ebdgb ==TextVerticalAlignmentCenter {_aefg =_fcaga -(_bebd +(_bdeca +_agdbg -_bebd )/2+(_fcaga -_bebd )/2);};if len (_gbaec ._fgbg )==1{_agab =_fffcg ;}else {_agab =_agab -_fcaga +_fffcg ;};_aefg +=_fffcg -_fcaga ;switch _eaba ._dbbf {case CellVerticalAlignmentTop :_aefg +=_fffcg *0.5;
case CellVerticalAlignmentBottom :_aefg -=_fffcg *0.5;};_gbee +=_gbaec ._bgac .Left +_gbaec ._bgac .Right ;_agab +=_gbaec ._bgac .Top +_gbaec ._bgac .Bottom ;case *Table :_gbee =_fcdbf ;case *List :_gbee =_fcdbf ;case *Division :_gbee =_fcdbf ;case *Chart :_gbee =_fcdbf ;
case *Line :_agab +=_gbaec ._fgddg .Top +_gbaec ._fgddg .Bottom ;_aefg -=_gbaec .Height ()/2;};switch _eaba ._eedf {case CellHorizontalAlignmentLeft :_aabb .X +=_eaba ._cgfb ;_aabb .Width -=_eaba ._cgfb ;case CellHorizontalAlignmentCenter :if _dfcdd :=_fcdbf -_gbee ;
_dfcdd > 0{_aabb .X +=_dfcdd /2;_aabb .Width -=_dfcdd /2;};case CellHorizontalAlignmentRight :if _fcdbf > _gbee {_aabb .X =_aabb .X +_fcdbf -_gbee -_eaba ._cgfb ;_aabb .Width -=_eaba ._cgfb ;};};_bfeb :=_aabb .Y ;_bgcc :=_aabb .Height ;_aabb .Y +=_aefg ;
switch _eaba ._dbbf {case CellVerticalAlignmentTop :case CellVerticalAlignmentMiddle :if _cdddc :=_abca -_agab ;_cdddc > 0{_aabb .Y +=_cdddc /2;_aabb .Height -=_cdddc /2;};case CellVerticalAlignmentBottom :if _abca > _agab {_aabb .Y =_aabb .Y +_abca -_agab ;
_aabb .Height =_abca ;};};_fbga :=_ccgcg .DrawWithContext (_eaba ._dafd ,_aabb );if _fbga !=nil {_de .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_fbga );};_aabb .Y =_bfeb ;_aabb .Height =_bgcc ;};_aabb .Y +=_abca ;_aabb .Height -=_abca ;
if _faacc &&_gbggf +1> _ebeg {_edfef +=_fegaa +_abca ;_fbfe -=_abca +_fegaa ;_bfadg =_dedeb ;_gbggf =_aedg -1;_faacc =false ;};};_eefe =append (_eefe ,_ccgcg );if _eeef ._fbcdg .IsAbsolute (){return _eefe ,_geddc ,nil ;};_aabb .X =_geddc .X ;_aabb .Width =_geddc .Width ;
_aabb .Y +=_eeef ._effe .Bottom ;_aabb .Height -=_eeef ._effe .Bottom ;return _eefe ,_aabb ,nil ;};

// Drawable is a widget that can be used to draw with the Creator.
type Drawable interface{

// GeneratePageBlocks draw onto blocks representing Page contents. As the content can wrap over many pages, multiple
// templates are returned, one per Page.  The function also takes a draw context containing information
// where to draw (if relative positioning) and the available height to draw on accounting for Margins etc.
GeneratePageBlocks (_beb DrawContext )([]*Block ,DrawContext ,error );};

// FitMode returns the fit mode of the rectangle.
func (_afag *Rectangle )FitMode ()FitMode {return _afag ._cegf };func (_cddaf *pageTransformations )applyFlip (_fgc *_ed .PdfPage )error {_ggce ,_bffbg :=_cddaf ._ffea ,_cddaf ._cdge ;if !_ggce &&!_bffbg {return nil ;};if _fgc ==nil {return _c .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");
};_eca ,_beda :=_fgc .GetMediaBox ();if _beda !=nil {return _beda ;};_fedf ,_acdb :=_eca .Width (),_eca .Height ();_dfgcd ,_beda :=_fgc .GetRotate ();if _beda !=nil {_de .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0025\u0073\u0020\u002d\u0020\u0069\u0067\u006e\u006f\u0072\u0069\u006e\u0067\u0020\u0061\u006e\u0064\u0020\u0061\u0073\u0073\u0075\u006d\u0069\u006e\u0067\u0020\u006e\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u000a",_beda .Error ());
};if _fgb :=_dfgcd %360!=0&&_dfgcd %90==0;_fgb {if _becd :=(360+_dfgcd %360)%360;_becd ==90||_becd ==270{_ggce ,_bffbg =_bffbg ,_ggce ;};};_dgbc ,_gff :=1.0,0.0;if _ggce {_dgbc ,_gff =-1.0,-_fedf ;};_bdaf ,_edcb :=1.0,0.0;if _bffbg {_bdaf ,_edcb =-1.0,-_acdb ;
};_bgc :=_da .NewContentCreator ().Scale (_dgbc ,_bdaf ).Translate (_gff ,_edcb );_eaec ,_beda :=_gg .MakeStream (_bgc .Bytes (),_gg .NewFlateEncoder ());if _beda !=nil {return _beda ;};_fccd :=_gg .MakeArray (_eaec );_fccd .Append (_fgc .GetContentStreamObjs ()...);
_fgc .Contents =_fccd ;return nil ;};const (TextOverflowVisible TextOverflow =iota ;TextOverflowHidden ;);func _abfb (_bgfa *Block ,_aafg _ed .PdfColor ,_abbfa Color ,_aada func ()Rectangle )error {switch _afgbe :=_aafg .(type ){case *_ed .PdfColorPatternType2 :_afeb ,_cdfg :=_abbfa .(*LinearShading );
if !_cdfg {return _fe .Errorf ("\u0043\u006f\u006c\u006f\u0072\u0020\u0069\u0073\u0020\u006e\u006ft\u0020\u004c\u0069\u006e\u0065\u0061\u0072\u0053\u0068\u0061d\u0069\u006e\u0067");};_ccfg :=_aada ();_afeb .SetBoundingBox (_ccfg ._eadb ,_ccfg ._accbb ,_ccfg ._egbf ,_ccfg ._agadf );
_ggbg ,_edbbc :=_afeb .AddPatternResource (_bgfa );if _edbbc !=nil {return _fe .Errorf ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0064\u0064\u0069\u006e\u0067\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e\u0020\u0074\u006f \u0072\u0065\u0073\u006f\u0075r\u0063\u0065s\u003a\u0020\u0025\u0076",_edbbc );
};_afgbe .PatternName =_ggbg ;case *_ed .PdfColorPatternType3 :_afba ,_fffc :=_abbfa .(*RadialShading );if !_fffc {return _fe .Errorf ("\u0043\u006f\u006c\u006f\u0072\u0020\u0069\u0073\u0020\u006e\u006ft\u0020\u0052\u0061\u0064\u0069\u0061\u006c\u0053\u0068\u0061d\u0069\u006e\u0067");
};_eefbd :=_aada ();_afba .SetBoundingBox (_eefbd ._eadb ,_eefbd ._accbb ,_eefbd ._egbf ,_eefbd ._agadf );_bgad ,_beac :=_afba .AddPatternResource (_bgfa );if _beac !=nil {return _fe .Errorf ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0064\u0064\u0069\u006e\u0067\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e\u0020\u0074\u006f \u0072\u0065\u0073\u006f\u0075r\u0063\u0065s\u003a\u0020\u0025\u0076",_beac );
};_afgbe .PatternName =_bgad ;};return nil ;};func _cadg (_beff *Block ,_gaea *Image ,_fdec DrawContext )(DrawContext ,error ){_dcbc :=_fdec ;_fdfge :=1;_gaff :=_gg .PdfObjectName (_fe .Sprintf ("\u0049\u006d\u0067%\u0064",_fdfge ));for _beff ._bf .HasXObjectByName (_gaff ){_fdfge ++;
_gaff =_gg .PdfObjectName (_fe .Sprintf ("\u0049\u006d\u0067%\u0064",_fdfge ));};_dfgf :=_beff ._bf .SetXObjectImageByName (_gaff ,_gaea ._gecf );if _dfgf !=nil {return _fdec ,_dfgf ;};_adbc :=0;_gfbaa :=_gg .PdfObjectName (_fe .Sprintf ("\u0047\u0053\u0025\u0064",_adbc ));
for _beff ._bf .HasExtGState (_gfbaa ){_adbc ++;_gfbaa =_gg .PdfObjectName (_fe .Sprintf ("\u0047\u0053\u0025\u0064",_adbc ));};_fbbff :=_gg .MakeDict ();_fbbff .Set ("\u0042\u004d",_gg .MakeName ("\u004e\u006f\u0072\u006d\u0061\u006c"));if _gaea ._adba < 1.0{_fbbff .Set ("\u0043\u0041",_gg .MakeFloat (_gaea ._adba ));
_fbbff .Set ("\u0063\u0061",_gg .MakeFloat (_gaea ._adba ));};_dfgf =_beff ._bf .AddExtGState (_gfbaa ,_gg .MakeIndirectObject (_fbbff ));if _dfgf !=nil {return _fdec ,_dfgf ;};_ebbg :=_gaea .Width ();_decb :=_gaea .Height ();_ ,_ebce :=_gaea .rotatedSize ();
_dfef :=_fdec .X ;_bgegbb :=_fdec .PageHeight -_fdec .Y -_decb ;if _gaea ._aeae .IsRelative (){_bgegbb -=(_ebce -_decb )/2;switch _gaea ._ecfa {case HorizontalAlignmentCenter :_dfef +=(_fdec .Width -_ebbg )/2;case HorizontalAlignmentRight :_dfef =_fdec .PageWidth -_fdec .Margins .Right -_gaea ._baaa .Right -_ebbg ;
};};_cded :=_gaea ._fbfb ;_gged :=_da .NewContentCreator ();_gged .Add_gs (_gfbaa );_gged .Translate (_dfef ,_bgegbb );if _cded !=0{_gged .Translate (_ebbg /2,_decb /2);_gged .RotateDeg (_cded );_gged .Translate (-_ebbg /2,-_decb /2);};_gged .Scale (_ebbg ,_decb ).Add_Do (_gaff );
_beca :=_gged .Operations ();_beca .WrapIfNeeded ();_beff .addContents (_beca );if _gaea ._aeae .IsRelative (){_fdec .Y +=_ebce ;_fdec .Height -=_ebce ;return _fdec ,nil ;};return _dcbc ,nil ;};

// Width is not used. Not used as a Table element is designed to fill into
// available width depending on the context. Returns 0.
func (_befg *Table )Width ()float64 {return 0};func (_dagf *TableCell )cloneProps (_cede VectorDrawable )*TableCell {_cdeb :=*_dagf ;_cdeb ._dafd =_cede ;return &_cdeb ;};

// Columns returns all the columns in the invoice line items table.
func (_acce *Invoice )Columns ()[]*InvoiceCell {return _acce ._deabd };

// SetDashPattern sets the dash pattern of the line.
// NOTE: the dash pattern is taken into account only if the style of the
// line is set to dashed.
func (_cgcgb *Line )SetDashPattern (dashArray []int64 ,dashPhase int64 ){_cgcgb ._ffaa =dashArray ;_cgcgb ._fabfc =dashPhase ;};

// DrawFooter sets a function to draw a footer on created output pages.
func (_ccff *Creator )DrawFooter (drawFooterFunc func (_eaga *Block ,_dddb FooterFunctionArgs )){_ccff ._eagb =drawFooterFunc ;};

// SetLineTitleStyle sets the style for the title part of all new lines
// of the table of contents.
func (_edgc *TOC )SetLineTitleStyle (style TextStyle ){_edgc ._gacdf =style };

// CurCol returns the currently active cell's column number.
func (_afcgg *Table )CurCol ()int {_gbebg :=(_afcgg ._cbae -1)%(_afcgg ._efefg )+1;return _gbebg };func (_eaca *Invoice )generateLineBlocks (_dege DrawContext )([]*Block ,DrawContext ,error ){_baf :=_bcfa (len (_eaca ._deabd ));_baf .SetMargins (0,0,25,0);
for _ ,_gcaa :=range _eaca ._deabd {_abfg :=_fecf (_gcaa .TextStyle );_abfg .SetMargins (0,0,1,0);_abfg .Append (_gcaa .Value );_gbbee :=_baf .NewCell ();_gbbee .SetHorizontalAlignment (_gcaa .Alignment );_gbbee .SetBackgroundColor (_gcaa .BackgroundColor );
_eaca .setCellBorder (_gbbee ,_gcaa );_gbbee .SetContent (_abfg );};for _ ,_fcad :=range _eaca ._caca {for _ ,_ebgbb :=range _fcad {_faea :=_fecf (_ebgbb .TextStyle );_faea .SetMargins (0,0,3,2);_faea .Append (_ebgbb .Value );_dfga :=_baf .NewCell ();_dfga .SetHorizontalAlignment (_ebgbb .Alignment );
_dfga .SetBackgroundColor (_ebgbb .BackgroundColor );_eaca .setCellBorder (_dfga ,_ebgbb );_dfga .SetContent (_faea );};};return _baf .GeneratePageBlocks (_dege );};

// SetText replaces all the text of the paragraph with the specified one.
func (_ecdc *StyledParagraph )SetText (text string )*TextChunk {_ecdc .Reset ();return _ecdc .Append (text );};

// GetHorizontalAlignment returns the horizontal alignment of the image.
func (_ffef *Image )GetHorizontalAlignment ()HorizontalAlignment {return _ffef ._ecfa };

// PageBreak represents a page break for a chapter.
type PageBreak struct{};

// SetPos sets the Block's positioning to absolute mode with the specified coordinates.
func (_eea *Block )SetPos (x ,y float64 ){_eea ._edb =PositionAbsolute ;_eea ._ga =x ;_eea ._cc =y };

// SetIncludeInTOC sets a flag to indicate whether or not to include in tOC.
func (_bce *Chapter )SetIncludeInTOC (includeInTOC bool ){_bce ._efgd =includeInTOC };

// CurvePolygon represents a curve polygon shape.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type CurvePolygon struct{_fdfe *_bc .CurvePolygon ;_bfeg float64 ;_cdgc float64 ;_gdffc Color ;};

// SetFontSize sets the font size in document units (points).
func (_caeeb *Paragraph )SetFontSize (fontSize float64 ){_caeeb ._aee =fontSize };

// CreateFrontPage sets a function to generate a front Page.
func (_ddeb *Creator )CreateFrontPage (genFrontPageFunc func (_gfeg FrontpageFunctionArgs )){_ddeb ._aeaf =genFrontPageFunc ;};

// SetMargins sets the margins of the rectangle.
// NOTE: rectangle margins are only applied if relative positioning is used.
func (_bfgg *Rectangle )SetMargins (left ,right ,top ,bottom float64 ){_bfgg ._efbdg .Left =left ;_bfgg ._efbdg .Right =right ;_bfgg ._efbdg .Top =top ;_bfgg ._efbdg .Bottom =bottom ;};const (CellVerticalAlignmentTop CellVerticalAlignment =iota ;CellVerticalAlignmentMiddle ;
CellVerticalAlignmentBottom ;);

// NewTextChunk returns a new text chunk instance.
func NewTextChunk (text string ,style TextStyle )*TextChunk {return &TextChunk {Text :text ,Style :style };};

// Lines returns all the rows of the invoice line items table.
func (_aeda *Invoice )Lines ()[][]*InvoiceCell {return _aeda ._caca };

// AppendColumn appends a column to the line items table.
func (_fdbfd *Invoice )AppendColumn (description string )*InvoiceCell {_cggac :=_fdbfd .NewColumn (description );_fdbfd ._deabd =append (_fdbfd ._deabd ,_cggac );return _cggac ;};

// SetFillColor sets background color for border.
func (_ccg *border )SetFillColor (col Color ){_ccg ._ddc =col };

// Height returns the total height of all rows.
func (_adgf *Table )Height ()float64 {_baadd :=float64 (0.0);for _ ,_egbdb :=range _adgf ._accga {_baadd +=_egbdb ;};return _baadd ;};

// Scale scales the ellipse dimensions by the specified factors.
func (_ecfg *Ellipse )Scale (xFactor ,yFactor float64 ){_ecfg ._dcg =xFactor *_ecfg ._dcg ;_ecfg ._bddb =yFactor *_ecfg ._bddb ;};

// ScaleToWidth scales the rectangle to the specified width. The height of
// the rectangle is scaled so that the aspect ratio is maintained.
func (_cceae *Rectangle )ScaleToWidth (w float64 ){_abdb :=_cceae ._agadf /_cceae ._egbf ;_cceae ._egbf =w ;_cceae ._agadf =w *_abdb ;};const (HorizontalAlignmentLeft HorizontalAlignment =iota ;HorizontalAlignmentCenter ;HorizontalAlignmentRight ;);

// Write output of creator to io.Writer interface.
func (_ebe *Creator )Write (ws _e .Writer )error {if _abcg :=_ebe .Finalize ();_abcg !=nil {return _abcg ;};_ffab :=_ed .NewPdfWriter ();_ffab .SetOptimizer (_ebe ._cfad );if _ebe ._cadd !=nil {_egbd :=_ffab .SetForms (_ebe ._cadd );if _egbd !=nil {_de .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_egbd );
return _egbd ;};};if _ebe ._gdfe !=nil {_ffab .AddOutlineTree (_ebe ._gdfe );}else if _ebe ._cac !=nil &&_ebe .AddOutlines {_ffab .AddOutlineTree (&_ebe ._cac .ToPdfOutline ().PdfOutlineTreeNode );};if _ebe ._efbd !=nil {if _efecc :=_ffab .SetPageLabels (_ebe ._efbd );
_efecc !=nil {_de .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020C\u006f\u0075\u006c\u0064 no\u0074 s\u0065\u0074\u0020\u0070\u0061\u0067\u0065 l\u0061\u0062\u0065\u006c\u0073\u003a\u0020%\u0076",_efecc );return _efecc ;};};if _ebe ._gfe !=nil {for _ ,_acfd :=range _ebe ._gfe {_bgcb :=_acfd .SubsetRegistered ();
if _bgcb !=nil {_de .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0043\u006f\u0075\u006c\u0064\u0020\u006e\u006ft\u0020s\u0075\u0062\u0073\u0065\u0074\u0020\u0066\u006f\u006e\u0074\u003a\u0020\u0025\u0076",_bgcb );return _bgcb ;};};};if _ebe ._eeb !=nil {_ddbg :=_ebe ._eeb (&_ffab );
if _ddbg !=nil {_de .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_ddbg );return _ddbg ;};};for _ ,_facd :=range _ebe ._fae {_adec :=_ffab .AddPage (_facd );if _adec !=nil {_de .Log .Error ("\u0046\u0061\u0069\u006ced\u0020\u0074\u006f\u0020\u0061\u0064\u0064\u0020\u0050\u0061\u0067\u0065\u003a\u0020%\u0076",_adec );
return _adec ;};};_ggbf :=_ffab .Write (ws );if _ggbf !=nil {return _ggbf ;};return nil ;};

// SetFitMode sets the fit mode of the line.
// NOTE: The fit mode is only applied if relative positioning is used.
func (_cebfb *Line )SetFitMode (fitMode FitMode ){_cebfb ._facce =fitMode };

// GraphicSVG represents a drawable graphic SVG.
// It is used to render the graphic SVG components using a creator instance.
type GraphicSVG struct{_ebgg *_fa .GraphicSVG ;_fgdgc Positioning ;_gab float64 ;_eebf float64 ;_eaeg Margins ;};

// AddShadingResource adds shading dictionary inside the resources dictionary.
func (_degaa *LinearShading )AddShadingResource (block *Block )(_afga _gg .PdfObjectName ,_dgca error ){_egfgd :=1;_afga =_gg .PdfObjectName ("\u0053\u0068"+_df .Itoa (_egfgd ));for block ._bf .HasShadingByName (_afga ){_egfgd ++;_afga =_gg .PdfObjectName ("\u0053\u0068"+_df .Itoa (_egfgd ));
};if _effg :=block ._bf .SetShadingByName (_afga ,_degaa .shadingModel ().ToPdfObject ());_effg !=nil {return "",_effg ;};return _afga ,nil ;};

// SetBackgroundColor set background color of the shading area.
//
// By default the background color is set to white.
func (_gggg *shading )SetBackgroundColor (backgroundColor Color ){_gggg ._cddd =backgroundColor };

// GetMargins returns the margins of the rectangle: left, right, top, bottom.
func (_bgbab *Rectangle )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _bgbab ._efbdg .Left ,_bgbab ._efbdg .Right ,_bgbab ._efbdg .Top ,_bgbab ._efbdg .Bottom ;};var (ColorBlack =ColorRGBFromArithmetic (0,0,0);ColorWhite =ColorRGBFromArithmetic (1,1,1);
ColorRed =ColorRGBFromArithmetic (1,0,0);ColorGreen =ColorRGBFromArithmetic (0,1,0);ColorBlue =ColorRGBFromArithmetic (0,0,1);ColorYellow =ColorRGBFromArithmetic (1,1,0););

// GetMargins returns the margins of the line: left, right, top, bottom.
func (_cgdd *Line )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _cgdd ._fgddg .Left ,_cgdd ._fgddg .Right ,_cgdd ._fgddg .Top ,_cgdd ._fgddg .Bottom ;};

// SetColor sets the line color.
func (_gbeba *Curve )SetColor (col Color ){_gbeba ._fgaf =col };

// SetStyleBottom sets border style for bottom side.
func (_gggb *border )SetStyleBottom (style CellBorderStyle ){_gggb ._bde =style };

// SetAddressStyle sets the style properties used to render the content of
// the invoice address sections.
func (_ffgff *Invoice )SetAddressStyle (style TextStyle ){_ffgff ._abee =style };

// AddShadingResource adds shading dictionary inside the resources dictionary.
func (_acad *RadialShading )AddShadingResource (block *Block )(_ecgge _gg .PdfObjectName ,_geaa error ){_befe :=1;_ecgge =_gg .PdfObjectName ("\u0053\u0068"+_df .Itoa (_befe ));for block ._bf .HasShadingByName (_ecgge ){_befe ++;_ecgge =_gg .PdfObjectName ("\u0053\u0068"+_df .Itoa (_befe ));
};if _cgfa :=block ._bf .SetShadingByName (_ecgge ,_acad .shadingModel ().ToPdfObject ());_cgfa !=nil {return "",_cgfa ;};return _ecgge ,nil ;};func _eegb (_bdecac *templateProcessor ,_gfef *templateNode )(interface{},error ){return _bdecac .parseChart (_gfef );
};

// DashPattern returns the dash pattern of the line.
func (_abgb *Line )DashPattern ()(_ecad []int64 ,_fgadg int64 ){return _abgb ._ffaa ,_abgb ._fabfc };

// SetBorderWidth sets the border width.
func (_aag *CurvePolygon )SetBorderWidth (borderWidth float64 ){_aag ._fdfe .BorderWidth =borderWidth };func (_cgcbc *TOCLine )prepareParagraph (_afge *StyledParagraph ,_badae DrawContext ){_dcga :=_cgcbc .Title .Text ;if _cgcbc .Number .Text !=""{_dcga ="\u0020"+_dcga ;
};_dcga +="\u0020";_bdbbb :=_cgcbc .Page .Text ;if _bdbbb !=""{_bdbbb ="\u0020"+_bdbbb ;};_afge ._dfdf =[]*TextChunk {{Text :_cgcbc .Number .Text ,Style :_cgcbc .Number .Style ,_abcgd :_cgcbc .getLineLink ()},{Text :_dcga ,Style :_cgcbc .Title .Style ,_abcgd :_cgcbc .getLineLink ()},{Text :_bdbbb ,Style :_cgcbc .Page .Style ,_abcgd :_cgcbc .getLineLink ()}};
_afge .wrapText ();_eaff :=len (_afge ._fgbg );if _eaff ==0{return ;};_gace :=_badae .Width *1000-_afge .getTextLineWidth (_afge ._fgbg [_eaff -1]);_cafaa :=_afge .getTextLineWidth ([]*TextChunk {&_cgcbc .Separator });_gdeff :=int (_gace /_cafaa );_aegdb :=_ae .Repeat (_cgcbc .Separator .Text ,_gdeff );
_eedae :=_cgcbc .Separator .Style ;_dbfe :=_afge .Insert (2,_aegdb );_dbfe .Style =_eedae ;_dbfe ._abcgd =_cgcbc .getLineLink ();_gace =_gace -float64 (_gdeff )*_cafaa ;if _gace > 500{_bdee ,_acgaad :=_eedae .Font .GetRuneMetrics (' ');if _acgaad &&_gace > _bdee .Wx {_gcedg :=int (_gace /_bdee .Wx );
if _gcedg > 0{_faaa :=_eedae ;_faaa .FontSize =1;_dbfe =_afge .Insert (2,_ae .Repeat ("\u0020",_gcedg ));_dbfe .Style =_faaa ;_dbfe ._abcgd =_cgcbc .getLineLink ();};};};};func (_fggb *Invoice )drawInformation ()*Table {_ccbf :=_bcfa (2);_dedf :=append ([][2]*InvoiceCell {_fggb ._gbgcb ,_fggb ._gfce ,_fggb ._facg },_fggb ._fgfg ...);
for _ ,_cdba :=range _dedf {_acgad ,_cfaf :=_cdba [0],_cdba [1];if _cfaf .Value ==""{continue ;};_dga :=_ccbf .NewCell ();_dga .SetBackgroundColor (_acgad .BackgroundColor );_fggb .setCellBorder (_dga ,_acgad );_egcg :=_fecf (_acgad .TextStyle );_egcg .Append (_acgad .Value );
_egcg .SetMargins (0,0,2,1);_dga .SetContent (_egcg );_dga =_ccbf .NewCell ();_dga .SetBackgroundColor (_cfaf .BackgroundColor );_fggb .setCellBorder (_dga ,_cfaf );_egcg =_fecf (_cfaf .TextStyle );_egcg .Append (_cfaf .Value );_egcg .SetMargins (0,0,2,1);
_dga .SetContent (_egcg );};return _ccbf ;};

// GeneratePageBlocks generate the Page blocks. Draws the Image on a block, implementing the Drawable interface.
func (_fdgf *Image )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){if _fdgf ._gecf ==nil {if _dcgd :=_fdgf .makeXObject ();_dcgd !=nil {return nil ,ctx ,_dcgd ;};};var _abbaa []*Block ;_gabe :=ctx ;_dbdg :=NewBlock (ctx .PageWidth ,ctx .PageHeight );
if _fdgf ._aeae .IsRelative (){_fdgf .applyFitMode (ctx .Width );ctx .X +=_fdgf ._baaa .Left ;ctx .Y +=_fdgf ._baaa .Top ;ctx .Width -=_fdgf ._baaa .Left +_fdgf ._baaa .Right ;ctx .Height -=_fdgf ._baaa .Top +_fdgf ._baaa .Bottom ;if _fdgf ._fedbd > ctx .Height {_abbaa =append (_abbaa ,_dbdg );
_dbdg =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_daf :=ctx ;_daf .Y =ctx .Margins .Top +_fdgf ._baaa .Top ;_daf .X =ctx .Margins .Left +_fdgf ._baaa .Left ;_daf .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_fdgf ._baaa .Top -_fdgf ._baaa .Bottom ;
_daf .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_fdgf ._baaa .Left -_fdgf ._baaa .Right ;ctx =_daf ;};}else {ctx .X =_fdgf ._gcdg ;ctx .Y =_fdgf ._fgff ;};ctx ,_bfgfb :=_cadg (_dbdg ,_fdgf ,ctx );if _bfgfb !=nil {return nil ,ctx ,_bfgfb ;
};_abbaa =append (_abbaa ,_dbdg );if _fdgf ._aeae .IsAbsolute (){ctx =_gabe ;}else {ctx .X =_gabe .X ;ctx .Width =_gabe .Width ;ctx .Y +=_fdgf ._baaa .Bottom ;};return _abbaa ,ctx ,nil ;};

// SetFillColor sets the fill color of the ellipse.
func (_gcdaf *Ellipse )SetFillColor (col Color ){_gcdaf ._eged =col };

// NewCurve returns new instance of Curve between points (x1,y1) and (x2, y2) with control point (cx,cy).
func (_begf *Creator )NewCurve (x1 ,y1 ,cx ,cy ,x2 ,y2 float64 )*Curve {return _eefa (x1 ,y1 ,cx ,cy ,x2 ,y2 );};func _dbff (_ebed _cd .Image )(*Image ,error ){_bfae ,_ffba :=_ed .ImageHandling .NewImageFromGoImage (_ebed );if _ffba !=nil {return nil ,_ffba ;
};return _acgaf (_bfae );};

// CellBorderStyle defines the table cell's border style.
type CellBorderStyle int ;func (_ffbba *templateProcessor )parsePositioningAttr (_gegca ,_faaef string )Positioning {_de .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e\u0069\u006e\u0067\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060%\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_gegca ,_faaef );
_gcdcg :=map[string ]Positioning {"\u0072\u0065\u006c\u0061\u0074\u0069\u0076\u0065":PositionRelative ,"\u0061\u0062\u0073\u006f\u006c\u0075\u0074\u0065":PositionAbsolute }[_faaef ];return _gcdcg ;};func _bcfa (_cgeda int )*Table {_bdaa :=&Table {_efefg :_cgeda ,_ebdcc :10.0,_gcfd :[]float64 {},_accga :[]float64 {},_ddbf :[]*TableCell {},_bage :make ([]int ,_cgeda ),_geega :true };
_bdaa .resetColumnWidths ();return _bdaa ;};func (_bfbdf *Table )resetColumnWidths (){_bfbdf ._gcfd =[]float64 {};_ffbc :=float64 (1.0)/float64 (_bfbdf ._efefg );for _ffgdd :=0;_ffgdd < _bfbdf ._efefg ;_ffgdd ++{_bfbdf ._gcfd =append (_bfbdf ._gcfd ,_ffbc );
};};

// SetHeading sets the text and the style of the heading of the TOC component.
func (_ggcg *TOC )SetHeading (text string ,style TextStyle ){_cabgf :=_ggcg .Heading ();_cabgf .Reset ();_cdaa :=_cabgf .Append (text );_cdaa .Style =style ;};func _bbee (_gdddd string ,_agfgc ,_egcag TextStyle )*TOC {_faege :=_egcag ;_faege .FontSize =14;
_efecf :=_fecf (_faege );_efecf .SetEnableWrap (true );_efecf .SetTextAlignment (TextAlignmentLeft );_efecf .SetMargins (0,0,0,5);_acgbg :=_efecf .Append (_gdddd );_acgbg .Style =_faege ;return &TOC {_daedg :_efecf ,_gacd :[]*TOCLine {},_acbdf :_agfgc ,_gacdf :_agfgc ,_dgeff :_agfgc ,_gdbbc :_agfgc ,_fbcdb :"\u002e",_dbdbe :10,_gfabb :Margins {0,0,2,2},_fadfe :PositionRelative ,_ffcbf :_agfgc ,_afec :true };
};func _bcdc (_abag *templateProcessor ,_gecga *templateNode )(interface{},error ){return _abag .parseTextChunk (_gecga );};

// SetMargins sets the margins for the Image (in relative mode): left, right, top, bottom.
func (_abba *Image )SetMargins (left ,right ,top ,bottom float64 ){_abba ._baaa .Left =left ;_abba ._baaa .Right =right ;_abba ._baaa .Top =top ;_abba ._baaa .Bottom =bottom ;};func _eefa (_bedae ,_gbgfc ,_agfd ,_dfbc ,_bcbd ,_gfcd float64 )*Curve {_cebf :=&Curve {};
_cebf ._ccaf =_bedae ;_cebf ._gegd =_gbgfc ;_cebf ._ecae =_agfd ;_cebf ._bdf =_dfbc ;_cebf ._acaf =_bcbd ;_cebf ._ebee =_gfcd ;_cebf ._fgaf =ColorBlack ;_cebf ._feba =1.0;return _cebf ;};func (_edfda *templateProcessor )parseMarginAttr (_cgdbe ,_aabae string )Margins {_de .Log .Debug ("\u0050\u0061r\u0073\u0069\u006e\u0067 \u006d\u0061r\u0067\u0069\u006e\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c \u0025\u0073\u0029\u002e",_cgdbe ,_aabae );
_fded :=Margins {};switch _eadbf :=_ae .Fields (_aabae );len (_eadbf ){case 1:_fded .Top ,_ =_df .ParseFloat (_eadbf [0],64);_fded .Bottom =_fded .Top ;_fded .Left =_fded .Top ;_fded .Right =_fded .Top ;case 2:_fded .Top ,_ =_df .ParseFloat (_eadbf [0],64);
_fded .Bottom =_fded .Top ;_fded .Left ,_ =_df .ParseFloat (_eadbf [1],64);_fded .Right =_fded .Left ;case 3:_fded .Top ,_ =_df .ParseFloat (_eadbf [0],64);_fded .Left ,_ =_df .ParseFloat (_eadbf [1],64);_fded .Right =_fded .Left ;_fded .Bottom ,_ =_df .ParseFloat (_eadbf [2],64);
case 4:_fded .Top ,_ =_df .ParseFloat (_eadbf [0],64);_fded .Right ,_ =_df .ParseFloat (_eadbf [1],64);_fded .Bottom ,_ =_df .ParseFloat (_eadbf [2],64);_fded .Left ,_ =_df .ParseFloat (_eadbf [3],64);};return _fded ;};

// ScaleToHeight scales the ellipse to the specified height. The width of
// the ellipse is scaled so that the aspect ratio is maintained.
func (_cged *Ellipse )ScaleToHeight (h float64 ){_fcac :=_cged ._dcg /_cged ._bddb ;_cged ._bddb =h ;_cged ._dcg =h *_fcac ;};

// BorderColor returns the border color of the rectangle.
func (_cgcag *Rectangle )BorderColor ()Color {return _cgcag ._dca };

// SetMargins sets the margins of the graphic svg component.
func (_gcbe *GraphicSVG )SetMargins (left ,right ,top ,bottom float64 ){_gcbe ._eaeg .Left =left ;_gcbe ._eaeg .Right =right ;_gcbe ._eaeg .Top =top ;_gcbe ._eaeg .Bottom =bottom ;};func (_ccead *templateProcessor )parseBoolAttr (_abfcg ,_gedeb string )bool {_de .Log .Debug ("P\u0061\u0072\u0073\u0069\u006e\u0067 \u0062\u006f\u006f\u006c\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065:\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_abfcg ,_gedeb );
_bcfd ,_ :=_df .ParseBool (_gedeb );return _gedeb ==""||_bcfd ;};

// ColorRGBFromHex converts color hex code to rgb color for using with creator.
// NOTE: If there is a problem interpreting the string, then will use black color and log a debug message.
// Example hex code: #ffffff -> (1,1,1) white.
func ColorRGBFromHex (hexStr string )Color {_gdb :=rgbColor {};if (len (hexStr )!=4&&len (hexStr )!=7)||hexStr [0]!='#'{_de .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _gdb ;
};var _dab ,_geg ,_egfe int ;if len (hexStr )==4{var _eff ,_efc ,_ebf int ;_agf ,_fad :=_fe .Sscanf (hexStr ,"\u0023\u0025\u0031\u0078\u0025\u0031\u0078\u0025\u0031\u0078",&_eff ,&_efc ,&_ebf );if _fad !=nil {_de .Log .Debug ("\u0049\u006e\u0076a\u006c\u0069\u0064\u0020h\u0065\u0078\u0020\u0063\u006f\u0064\u0065:\u0020\u0025\u0073\u002c\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076",hexStr ,_fad );
return _gdb ;};if _agf !=3{_de .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _gdb ;};_dab =_eff *16+_eff ;_geg =_efc *16+_efc ;_egfe =_ebf *16+_ebf ;}else {_edfb ,_bfca :=_fe .Sscanf (hexStr ,"\u0023\u0025\u0032\u0078\u0025\u0032\u0078\u0025\u0032\u0078",&_dab ,&_geg ,&_egfe );
if _bfca !=nil {_de .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _gdb ;};if _edfb !=3{_de .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0063\u006f\u0064\u0065\u003a\u0020\u0025\u0073,\u0020\u006e\u0020\u0021\u003d\u0020\u0033 \u0028\u0025\u0064\u0029",hexStr ,_edfb );
return _gdb ;};};_dede :=float64 (_dab )/255.0;_becf :=float64 (_geg )/255.0;_dgcc :=float64 (_egfe )/255.0;_gdb ._fbba =_dede ;_gdb ._dbd =_becf ;_gdb ._fdc =_dgcc ;return _gdb ;};func _aebad (_cfbe ,_bbge ,_gegb string ,_baeg uint ,_gcbd TextStyle )*TOCLine {return _bbce (TextChunk {Text :_cfbe ,Style :_gcbd },TextChunk {Text :_bbge ,Style :_gcbd },TextChunk {Text :_gegb ,Style :_gcbd },_baeg ,_gcbd );
};func _edadc (_bbbd string ,_gfag TextStyle )*Paragraph {_gdgc :=&Paragraph {_cffc :_bbbd ,_agae :_gfag .Font ,_aee :_gfag .FontSize ,_ccef :1.0,_caba :true ,_dbccd :true ,_ccgc :TextAlignmentLeft ,_efcgfb :0,_afbb :1,_eegf :1,_gbfg :PositionRelative };
_gdgc .SetColor (_gfag .Color );return _gdgc ;};func (_ggcd *Paragraph )getTextLineWidth (_ebfc string )float64 {var _abdgd float64 ;for _ ,_bgdc :=range _ebfc {if _bgdc =='\u000A'{continue ;};_ebgf ,_edbf :=_ggcd ._agae .GetRuneMetrics (_bgdc );if !_edbf {_de .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_bgdc ,_bgdc );
return -1;};_abdgd +=_ggcd ._aee *_ebgf .Wx ;};return _abdgd ;};func (_abaf *Creator )setActivePage (_afd *_ed .PdfPage ){_abaf ._gbc =_afd };func (_fcgbf *templateProcessor )parseBorderRadiusAttr (_gffag ,_ecdb string )(_accfc ,_cbeb ,_ccgbc ,_befga float64 ){_de .Log .Debug ("\u0050a\u0072\u0073i\u006e\u0067\u0020\u0062o\u0072\u0064\u0065r\u0020\u0072\u0061\u0064\u0069\u0075\u0073\u0020\u0061tt\u0072\u0069\u0062u\u0074\u0065:\u0020\u0028\u0060\u0025\u0073\u0060,\u0020\u0025s\u0029\u002e",_gffag ,_ecdb );
switch _gfdf :=_ae .Fields (_ecdb );len (_gfdf ){case 1:_accfc ,_ =_df .ParseFloat (_gfdf [0],64);_cbeb =_accfc ;_ccgbc =_accfc ;_befga =_accfc ;case 2:_accfc ,_ =_df .ParseFloat (_gfdf [0],64);_ccgbc =_accfc ;_cbeb ,_ =_df .ParseFloat (_gfdf [1],64);_befga =_cbeb ;
case 3:_accfc ,_ =_df .ParseFloat (_gfdf [0],64);_cbeb ,_ =_df .ParseFloat (_gfdf [1],64);_befga =_cbeb ;_ccgbc ,_ =_df .ParseFloat (_gfdf [2],64);case 4:_accfc ,_ =_df .ParseFloat (_gfdf [0],64);_cbeb ,_ =_df .ParseFloat (_gfdf [1],64);_ccgbc ,_ =_df .ParseFloat (_gfdf [2],64);
_befga ,_ =_df .ParseFloat (_gfdf [3],64);};return _accfc ,_cbeb ,_ccgbc ,_befga ;};

// AddTextItem appends a new item with the specified text to the list.
// The method creates a styled paragraph with the specified text and returns
// it so that the item style can be customized.
// The method also returns the marker used for the newly added item.
// The marker object can be used to change the text and style of the marker
// for the current item.
func (_aadf *List )AddTextItem (text string )(*StyledParagraph ,*TextChunk ,error ){_bfgb :=_fecf (_aadf ._cgge );_bfgb .Append (text );_eccd ,_afb :=_aadf .Add (_bfgb );return _bfgb ,_eccd ,_afb ;};

// GeneratePageBlocks draws the ellipse on a new block representing the page.
func (_ddfeb *Ellipse )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var (_dfag []*Block ;_acae =NewBlock (ctx .PageWidth ,ctx .PageHeight );_edge =ctx ;);_ceefe :=_ddfeb ._cdgf .IsRelative ();if _ceefe {_ddfeb .applyFitMode (ctx .Width );
ctx .X +=_ddfeb ._ccac .Left ;ctx .Y +=_ddfeb ._ccac .Top ;ctx .Width -=_ddfeb ._ccac .Left +_ddfeb ._ccac .Right ;ctx .Height -=_ddfeb ._ccac .Top +_ddfeb ._ccac .Bottom ;if _ddfeb ._bddb > ctx .Height {_dfag =append (_dfag ,_acae );_acae =NewBlock (ctx .PageWidth ,ctx .PageHeight );
ctx .Page ++;_degae :=ctx ;_degae .Y =ctx .Margins .Top +_ddfeb ._ccac .Top ;_degae .X =ctx .Margins .Left +_ddfeb ._ccac .Left ;_degae .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_ddfeb ._ccac .Top -_ddfeb ._ccac .Bottom ;_degae .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_ddfeb ._ccac .Left -_ddfeb ._ccac .Right ;
ctx =_degae ;};}else {ctx .X =_ddfeb ._ggceg -_ddfeb ._dcg /2;ctx .Y =_ddfeb ._ecd -_ddfeb ._bddb /2;};_febd :=_bc .Circle {X :ctx .X ,Y :ctx .PageHeight -ctx .Y -_ddfeb ._bddb ,Width :_ddfeb ._dcg ,Height :_ddfeb ._bddb ,BorderWidth :_ddfeb ._fffa ,Opacity :1.0};
if _ddfeb ._eged !=nil {_febd .FillEnabled =true ;_bbag :=_ccfb (_ddfeb ._eged );_bfgd :=_abfb (_acae ,_bbag ,_ddfeb ._eged ,func ()Rectangle {return Rectangle {_eadb :_febd .X ,_accbb :_febd .Y ,_egbf :_febd .Width ,_agadf :_febd .Height };});if _bfgd !=nil {return nil ,ctx ,_bfgd ;
};_febd .FillColor =_bbag ;};if _ddfeb ._facc !=nil {_febd .BorderEnabled =false ;if _ddfeb ._fffa > 0{_febd .BorderEnabled =true ;};_febd .BorderColor =_ccfb (_ddfeb ._facc );_febd .BorderWidth =_ddfeb ._fffa ;};_bcbdd ,_gfggf :=_acae .setOpacity (_ddfeb ._bbcdd ,_ddfeb ._eega );
if _gfggf !=nil {return nil ,ctx ,_gfggf ;};_gdga ,_ ,_gfggf :=_febd .Draw (_bcbdd );if _gfggf !=nil {return nil ,ctx ,_gfggf ;};_gfggf =_acae .addContentsByString (string (_gdga ));if _gfggf !=nil {return nil ,ctx ,_gfggf ;};if _ceefe {ctx .X =_edge .X ;
ctx .Width =_edge .Width ;ctx .Y +=_ddfeb ._bddb +_ddfeb ._ccac .Bottom ;ctx .Height -=_ddfeb ._bddb ;}else {ctx =_edge ;};_dfag =append (_dfag ,_acae );return _dfag ,ctx ,nil ;};

// GetMargins returns the margins of the ellipse: left, right, top, bottom.
func (_dfdg *Ellipse )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _dfdg ._ccac .Left ,_dfdg ._ccac .Right ,_dfdg ._ccac .Top ,_dfdg ._ccac .Bottom ;};

// TextDecorationLineStyle represents the style of lines used to decorate
// a text chunk (e.g. underline).
type TextDecorationLineStyle struct{

// Color represents the color of the line (default: the color of the text).
Color Color ;

// Offset represents the vertical offset of the line (default: 1).
Offset float64 ;

// Thickness represents the thickness of the line (default: 1).
Thickness float64 ;};

// SetMargins sets the Table's left, right, top, bottom margins.
func (_egdb *Table )SetMargins (left ,right ,top ,bottom float64 ){_egdb ._effe .Left =left ;_egdb ._effe .Right =right ;_egdb ._effe .Top =top ;_egdb ._effe .Bottom =bottom ;};

// Length calculates and returns the length of the line.
func (_dfcd *Line )Length ()float64 {return _gd .Sqrt (_gd .Pow (_dfcd ._bfba -_dfcd ._ecfe ,2.0)+_gd .Pow (_dfcd ._gbbeb -_dfcd ._ecec ,2.0));};func _degd (_ggfe *templateProcessor ,_cgeac *templateNode )(interface{},error ){return _ggfe .parseImage (_cgeac );
};

// Table allows organizing content in an rows X columns matrix, which can spawn across multiple pages.
type Table struct{_bebea int ;_efefg int ;_cbae int ;_gcfd []float64 ;_accga []float64 ;_ebdcc float64 ;_ddbf []*TableCell ;_bage []int ;_fbcdg Positioning ;_bgacf ,_gdcc float64 ;_effe Margins ;_decbc bool ;_edbcf int ;_bgab int ;_egbga bool ;_geega bool ;
};

// TitleStyle returns the style properties used to render the invoice title.
func (_ggced *Invoice )TitleStyle ()TextStyle {return _ggced ._cace };func (_fcaf *Image )rotatedSize ()(float64 ,float64 ){_eebc :=_fcaf ._deac ;_ggbc :=_fcaf ._fedbd ;_fdbb :=_fcaf ._fbfb ;if _fdbb ==0{return _eebc ,_ggbc ;};_dadg :=_bc .Path {Points :[]_bc .Point {_bc .NewPoint (0,0).Rotate (_fdbb ),_bc .NewPoint (_eebc ,0).Rotate (_fdbb ),_bc .NewPoint (0,_ggbc ).Rotate (_fdbb ),_bc .NewPoint (_eebc ,_ggbc ).Rotate (_fdbb )}}.GetBoundingBox ();
return _dadg .Width ,_dadg .Height ;};func (_fdd *Chapter )headingText ()string {_ece :=_fdd ._aae ;if _eefb :=_fdd .headingNumber ();_eefb !=""{_ece =_fe .Sprintf ("\u0025\u0073\u0020%\u0073",_eefb ,_ece );};return _ece ;};func (_cdgdf *InvoiceAddress )fmtLine (_abaa ,_agag string ,_eecg bool )string {if _eecg {_agag ="";
};return _fe .Sprintf ("\u0025\u0073\u0025s\u000a",_agag ,_abaa );};func _cafb (_fabdc *templateProcessor ,_begdc *templateNode )(interface{},error ){return _fabdc .parseChapterHeading (_begdc );};var (_bafc =_d .MustCompile ("\u0028[\u005cw\u002d\u005d\u002b\u0029\u005c(\u0027\u0028.\u002b\u0029\u0027\u005c\u0029");
_ecggc =_c .New ("\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0074\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u0063\u0072\u0065a\u0074\u006f\u0072\u0020\u0069\u006e\u0073t\u0061\u006e\u0063\u0065");_daggc =_c .New ("\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0074\u0065\u006d\u0070\u006c\u0061\u0074e\u0020p\u0061\u0072\u0065\u006e\u0074\u0020\u006eo\u0064\u0065");
_aafgd =_c .New ("i\u006e\u0076\u0061\u006c\u0069\u0064 \u0074\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020c\u0068\u0069\u006cd\u0020n\u006f\u0064\u0065");_fdcb =_c .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0074\u0065\u006d\u0070l\u0061t\u0065 \u0072\u0065\u0073\u006f\u0075\u0072\u0063e");
);type componentRenderer interface{Draw (_dacde Drawable )error ;};

// TextChunk represents a chunk of text along with a particular style.
type TextChunk struct{

// The text that is being rendered in the PDF.
Text string ;

// The style of the text being rendered.
Style TextStyle ;_abcgd *_ed .PdfAnnotation ;_dbae bool ;};func (_fcbb *Image )makeXObject ()error {_bcgc :=_fcbb ._agdcd ;if _bcgc ==nil {_bcgc =_gg .NewFlateEncoder ();};_gbadc ,_dcbgc :=_ed .NewXObjectImageFromImage (_fcbb ._cce ,nil ,_bcgc );if _dcbgc !=nil {_de .Log .Error ("\u0046\u0061\u0069le\u0064\u0020\u0074\u006f\u0020\u0063\u0072\u0065\u0061t\u0065 \u0078o\u0062j\u0065\u0063\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_dcbgc );
return _dcbgc ;};_fcbb ._gecf =_gbadc ;return nil ;};

// Color interface represents colors in the PDF creator.
type Color interface{ToRGB ()(float64 ,float64 ,float64 );};func (_gfggfa *templateProcessor )parseAttrPropList (_cccb string )map[string ]string {_beggc :=_ae .Fields (_cccb );if len (_beggc )==0{return nil ;};_beacde :=map[string ]string {};for _ ,_aacae :=range _beggc {_gdafc :=_bafc .FindStringSubmatch (_aacae );
if len (_gdafc )< 3{continue ;};_dcce ,_eaae :=_ae .TrimSpace (_gdafc [1]),_gdafc [2];if _dcce ==""{continue ;};_beacde [_dcce ]=_eaae ;};return _beacde ;};func (_cgd *pageTransformations )transformPage (_dbb *_ed .PdfPage )error {if _aaee :=_cgd .applyFlip (_dbb );
_aaee !=nil {return _aaee ;};return nil ;};func (_fgcd *Paragraph )getTextWidth ()float64 {_cedda :=0.0;for _ ,_ceca :=range _fgcd ._cffc {if _ceca =='\u000A'{continue ;};_aede ,_dcbgb :=_fgcd ._agae .GetRuneMetrics (_ceca );if !_dcbgb {_de .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_ceca ,_ceca );
return -1;};_cedda +=_fgcd ._aee *_aede .Wx ;};return _cedda ;};

// SetEnableWrap sets the line wrapping enabled flag.
func (_fgebg *Paragraph )SetEnableWrap (enableWrap bool ){_fgebg ._caba =enableWrap ;_fgebg ._dbccd =false ;};

// SetShowLinks sets visibility of links for the TOC lines.
func (_befec *TOC )SetShowLinks (showLinks bool ){_befec ._afec =showLinks };func _acgaf (_ccea *_ed .Image )(*Image ,error ){_abge :=float64 (_ccea .Width );_fbeb :=float64 (_ccea .Height );return &Image {_cce :_ccea ,_ecef :_abge ,_aceg :_fbeb ,_deac :_abge ,_fedbd :_fbeb ,_fbfb :0,_adba :1.0,_aeae :PositionRelative },nil ;
};type cmykColor struct{_bca ,_cdgdd ,_cebb ,_dfbe float64 };

// Heading returns the heading component of the table of contents.
func (_adcbdc *TOC )Heading ()*StyledParagraph {return _adcbdc ._daedg };

// SetBoundingBox set gradient color bounding box where the gradient would be rendered.
func (_eacg *RadialShading )SetBoundingBox (x ,y ,width ,height float64 ){_eacg ._bgga =&_ed .PdfRectangle {Llx :x ,Lly :y ,Urx :x +width ,Ury :y +height };};

// NewStyledTOCLine creates a new table of contents line with the provided style.
func (_cbdb *Creator )NewStyledTOCLine (number ,title ,page TextChunk ,level uint ,style TextStyle )*TOCLine {return _bbce (number ,title ,page ,level ,style );};

// FitMode returns the fit mode of the ellipse.
func (_ebgeg *Ellipse )FitMode ()FitMode {return _ebgeg ._cfef };

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_gaaab *Invoice )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_eecgc :=ctx ;_aafc :=[]func (_dcdgg DrawContext )([]*Block ,DrawContext ,error ){_gaaab .generateHeaderBlocks ,_gaaab .generateInformationBlocks ,_gaaab .generateLineBlocks ,_gaaab .generateTotalBlocks ,_gaaab .generateNoteBlocks };
var _eeecf []*Block ;for _ ,_edad :=range _aafc {_dfeg ,_aaeec ,_acgaa :=_edad (ctx );if _acgaa !=nil {return _eeecf ,ctx ,_acgaa ;};if len (_eeecf )==0{_eeecf =_dfeg ;}else if len (_dfeg )> 0{_eeecf [len (_eeecf )-1].mergeBlocks (_dfeg [0]);_eeecf =append (_eeecf ,_dfeg [1:]...);
};ctx =_aaeec ;};if _gaaab ._dfec .IsRelative (){ctx .X =_eecgc .X ;};if _gaaab ._dfec .IsAbsolute (){return _eeecf ,_eecgc ,nil ;};return _eeecf ,ctx ,nil ;};

// GeneratePageBlocks draws the block contents on a template Page block.
// Implements the Drawable interface.
func (_fgg *Block )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_ec :=_da .NewContentCreator ();_bb ,_ee :=_fgg .Width (),_fgg .Height ();if _fgg ._edb .IsRelative (){_ec .Translate (ctx .X ,ctx .PageHeight -ctx .Y -_ee );}else {_ec .Translate (_fgg ._ga ,ctx .PageHeight -_fgg ._cc -_ee );
};_dfc :=_ee ;if _fgg ._bfa !=0{_ec .Translate (_bb /2,_ee /2);_ec .RotateDeg (_fgg ._bfa );_ec .Translate (-_bb /2,-_ee /2);_ ,_dfc =_fgg .RotatedSize ();};if _fgg ._edb .IsRelative (){ctx .Y +=_dfc ;};_abe :=_fgg .duplicate ();_cgb :=append (*_ec .Operations (),*_abe ._eg ...);
_cgb .WrapIfNeeded ();_abe ._eg =&_cgb ;return []*Block {_abe },ctx ,nil ;};

// SetBorderOpacity sets the border opacity.
func (_dggf *PolyBezierCurve )SetBorderOpacity (opacity float64 ){_dggf ._cbac =opacity };func _faeb (_efdcb *templateProcessor ,_bddbd *templateNode )(interface{},error ){return _efdcb .parseDivision (_bddbd );};

// SetNotes sets the notes section of the invoice.
func (_efee *Invoice )SetNotes (title ,content string ){_efee ._gbf =[2]string {title ,content }};

// SetEnableWrap sets the line wrapping enabled flag.
func (_edbcb *StyledParagraph )SetEnableWrap (enableWrap bool ){_edbcb ._ebeda =enableWrap ;_edbcb ._ccafg =false ;};

// Wrap wraps the text of the chunk into lines based on its style and the
// specified width.
func (_aegf *TextChunk )Wrap (width float64 )([]string ,error ){if int (width )<=0{return []string {_aegf .Text },nil ;};var _ddgbf []string ;var _fedc []rune ;var _cfea float64 ;var _ffgb []float64 ;_fege :=_aegf .Style ;_gfcg :=_ggdbb (_aegf .Text );
for _ ,_fegc :=range _aegf .Text {if _fegc =='\u000A'{_aecbe :=_adfde (string (_fedc ),_gfcg );_ddgbf =append (_ddgbf ,_ae .TrimRightFunc (_aecbe ,_ac .IsSpace )+string (_fegc ));_fedc =nil ;_cfea =0;_ffgb =nil ;continue ;};_acdbg :=_fegc ==' ';_aaaab ,_ccgff :=_fege .Font .GetRuneMetrics (_fegc );
if !_ccgff {_de .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006det\u0072i\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064!\u0020\u0072\u0075\u006e\u0065\u003d\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0066o\u006e\u0074\u003d\u0025\u0073\u0020\u0025\u0023\u0071",_fegc ,_fegc ,_fege .Font .BaseFont (),_fege .Font .Subtype ());
_de .Log .Trace ("\u0046o\u006e\u0074\u003a\u0020\u0025\u0023v",_fege .Font );_de .Log .Trace ("\u0045\u006e\u0063o\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076",_fege .Font .Encoder ());return nil ,_c .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");
};_bcac :=_fege .FontSize *_aaaab .Wx ;_cebdc :=_bcac ;if !_acdbg {_cebdc =_bcac +_fege .CharSpacing *1000.0;};if _cfea +_bcac > width *1000.0{_fcbcg :=-1;if !_acdbg {for _gcdfg :=len (_fedc )-1;_gcdfg >=0;_gcdfg --{if _fedc [_gcdfg ]==' '{_fcbcg =_gcdfg ;
break ;};};};_cacd :=string (_fedc );if _fcbcg > 0{_cacd =string (_fedc [0:_fcbcg +1]);_fedc =append (_fedc [_fcbcg +1:],_fegc );_ffgb =append (_ffgb [_fcbcg +1:],_cebdc );_cfea =0;for _ ,_gbdce :=range _ffgb {_cfea +=_gbdce ;};}else {if _acdbg {_fedc =[]rune {};
_ffgb =[]float64 {};_cfea =0;}else {_fedc =[]rune {_fegc };_ffgb =[]float64 {_cebdc };_cfea =_cebdc ;};};_cacd =_adfde (_cacd ,_gfcg );_ddgbf =append (_ddgbf ,_ae .TrimRightFunc (_cacd ,_ac .IsSpace ));}else {_fedc =append (_fedc ,_fegc );_cfea +=_cebdc ;
_ffgb =append (_ffgb ,_cebdc );};};if len (_fedc )> 0{_dcaf :=string (_fedc );_dcaf =_adfde (_dcaf ,_gfcg );_ddgbf =append (_ddgbf ,_dcaf );};return _ddgbf ,nil ;};func (_bdef *templateProcessor )parseInt64Attr (_befcd ,_bcag string )int64 {_de .Log .Debug ("\u0050\u0061rs\u0069\u006e\u0067 \u0069\u006e\u0074\u00364 a\u0074tr\u0069\u0062\u0075\u0074\u0065\u003a\u0020(`\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_befcd ,_bcag );
_efbaf ,_ :=_df .ParseInt (_bcag ,10,64);return _efbaf ;};

// GetMargins returns the left, right, top, bottom Margins.
func (_dfgd *Table )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _dfgd ._effe .Left ,_dfgd ._effe .Right ,_dfgd ._effe .Top ,_dfgd ._effe .Bottom ;};func (_dgdce *TextStyle )horizontalScale ()float64 {return _dgdce .HorizontalScaling /100};


// GeneratePageBlocks draws the polygon on a new block representing the page.
// Implements the Drawable interface.
func (_adcb *Polygon )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_acec :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_ggbaa ,_fafa :=_acec .setOpacity (_adcb ._fegg ,_adcb ._daaf );if _fafa !=nil {return nil ,ctx ,_fafa ;};_gfgd :=_adcb ._gaecf ;
_gfgd .FillEnabled =_gfgd .FillColor !=nil ;_gfgd .BorderEnabled =_gfgd .BorderColor !=nil &&_gfgd .BorderWidth > 0;_gfga :=_gfgd .Points ;_gcga :=_ed .PdfRectangle {};_bfad :=false ;for _afgb :=range _gfga {for _efbcd :=range _gfga [_afgb ]{_bdfa :=&_gfga [_afgb ][_efbcd ];
_bdfa .Y =ctx .PageHeight -_bdfa .Y ;if !_bfad {_gcga .Llx =_bdfa .X ;_gcga .Lly =_bdfa .Y ;_gcga .Urx =_bdfa .X ;_gcga .Ury =_bdfa .Y ;_bfad =true ;}else {_gcga .Llx =_gd .Min (_gcga .Llx ,_bdfa .X );_gcga .Lly =_gd .Min (_gcga .Lly ,_bdfa .Y );_gcga .Urx =_gd .Max (_gcga .Urx ,_bdfa .X );
_gcga .Ury =_gd .Max (_gcga .Ury ,_bdfa .Y );};};};if _gfgd .FillEnabled {_addae :=_abfb (_acec ,_adcb ._gaecf .FillColor ,_adcb ._bedd ,func ()Rectangle {return Rectangle {_eadb :_gcga .Llx ,_accbb :_gcga .Lly ,_egbf :_gcga .Width (),_agadf :_gcga .Height ()};
});if _addae !=nil {return nil ,ctx ,_addae ;};};_bdbag ,_ ,_fafa :=_gfgd .Draw (_ggbaa );if _fafa !=nil {return nil ,ctx ,_fafa ;};if _fafa =_acec .addContentsByString (string (_bdbag ));_fafa !=nil {return nil ,ctx ,_fafa ;};return []*Block {_acec },ctx ,nil ;
};

// AddPage adds the specified page to the creator.
// NOTE: If the page has a Rotate flag, the creator will take care of
// transforming the contents to maintain the correct orientation.
func (_bgg *Creator )AddPage (page *_ed .PdfPage )error {_caee ,_ggeb :=page .GetMediaBox ();if _ggeb !=nil {_de .Log .Debug ("\u0046\u0061\u0069l\u0065\u0064\u0020\u0074o\u0020\u0067\u0065\u0074\u0020\u0070\u0061g\u0065\u0020\u006d\u0065\u0064\u0069\u0061\u0062\u006f\u0078\u003a\u0020\u0025\u0076",_ggeb );
return _ggeb ;};_caee .Normalize ();_gcae ,_eefbb :=_caee .Llx ,_caee .Lly ;_agaf :=_caee ;if _gba :=page .CropBox ;_gba !=nil &&*_gba !=*_caee {_gba .Normalize ();_gcae ,_eefbb =_gba .Llx ,_gba .Lly ;_agaf =_gba ;};_dgda :=_ebg .IdentityMatrix ();_aeage ,_ggeb :=page .GetRotate ();
if _ggeb !=nil {_de .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0025\u0073\u0020\u002d\u0020\u0069\u0067\u006e\u006f\u0072\u0069\u006e\u0067\u0020\u0061\u006e\u0064\u0020\u0061\u0073\u0073\u0075\u006d\u0069\u006e\u0067\u0020\u006e\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u000a",_ggeb .Error ());
};_fbf :=_aeage %360!=0&&_aeage %90==0;if _fbf {_adfcb :=float64 ((360+_aeage %360)%360);if _adfcb ==90{_dgda =_dgda .Translate (_agaf .Width (),0);}else if _adfcb ==180{_dgda =_dgda .Translate (_agaf .Width (),_agaf .Height ());}else if _adfcb ==270{_dgda =_dgda .Translate (0,_agaf .Height ());
};_dgda =_dgda .Mult (_ebg .RotationMatrix (_adfcb *_gd .Pi /180));_dgda =_dgda .Round (0.000001);_bfef :=_aeaec (_agaf ,_dgda );_agaf =_bfef ;_agaf .Normalize ();};if _gcae !=0||_eefbb !=0{_dgda =_ebg .TranslationMatrix (_gcae ,_eefbb ).Mult (_dgda );
};if !_dgda .Identity (){_dgda =_dgda .Round (0.000001);_bgg ._abcf [page ]=&pageTransformations {_ddf :&_dgda };};_bgg ._dea =_agaf .Width ();_bgg ._bgfe =_agaf .Height ();_bgg .initContext ();_bgg ._fae =append (_bgg ._fae ,page );_bgg ._fafg .Page ++;
return nil ;};

// ToPdfShadingPattern generates a new model.PdfShadingPatternType2 object.
func (_dafe *LinearShading )ToPdfShadingPattern ()*_ed .PdfShadingPatternType2 {_dfefe ,_ggdf ,_accee :=_dafe ._cecc ._cddd .ToRGB ();_cadf :=_dafe .shadingModel ();_cadf .PdfShading .Background =_gg .MakeArrayFromFloats ([]float64 {_dfefe ,_ggdf ,_accee });
_deee :=_ed .NewPdfShadingPatternType2 ();_deee .Shading =_cadf ;return _deee ;};

// Positioning returns the type of positioning the rectangle is set to use.
func (_dfbf *Rectangle )Positioning ()Positioning {return _dfbf ._dded };func _ebgd (_afdb []byte )(*Image ,error ){_eab :=_ab .NewReader (_afdb );_ecfd ,_caef :=_ed .ImageHandling .Read (_eab );if _caef !=nil {_de .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_caef );
return nil ,_caef ;};return _acgaf (_ecfd );};

// SetFillOpacity sets the fill opacity.
func (_gcfbe *PolyBezierCurve )SetFillOpacity (opacity float64 ){_gcfbe ._gefcb =opacity };

// NewCell makes a new cell and inserts it into the table at the current position.
func (_bbec *Table )NewCell ()*TableCell {return _bbec .MultiCell (1,1)};

// SetHeaderRows turns the selected table rows into headers that are repeated
// for every page the table spans. startRow and endRow are inclusive.
func (_eccc *Table )SetHeaderRows (startRow ,endRow int )error {if startRow <=0{return _c .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020r\u006f\u0077\u0020\u006d\u0075\u0073t\u0020\u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");
};if endRow <=0{return _c .New ("\u0068\u0065a\u0064\u0065\u0072\u0020e\u006e\u0064 \u0072\u006f\u0077\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");};if startRow > endRow {return _c .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020\u0072\u006f\u0077\u0020\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061\u006e\u0020\u006f\u0072\u0020\u0065\u0071\u0075\u0061\u006c\u0020\u0074\u006f\u0020\u0074\u0068\u0065 \u0065\u006e\u0064\u0020\u0072o\u0077");
};_eccc ._decbc =true ;_eccc ._edbcf =startRow ;_eccc ._bgab =endRow ;return nil ;};

// Curve represents a cubic Bezier curve with a control point.
type Curve struct{_ccaf float64 ;_gegd float64 ;_ecae float64 ;_bdf float64 ;_acaf float64 ;_ebee float64 ;_fgaf Color ;_feba float64 ;};func (_eadd *Invoice )generateInformationBlocks (_agb DrawContext )([]*Block ,DrawContext ,error ){_acgd :=_fecf (_eadd ._geb );
_acgd .SetMargins (0,0,0,20);_bacf :=_eadd .drawAddress (_eadd ._ecefd );_bacf =append (_bacf ,_acgd );_bacf =append (_bacf ,_eadd .drawAddress (_eadd ._eeaf )...);_adece :=_daa ();for _ ,_gcdb :=range _bacf {_adece .Add (_gcdb );};_ggdca :=_eadd .drawInformation ();
_gdgb :=_bcfa (2);_gdgb .SetMargins (0,0,25,0);_afffd :=_gdgb .NewCell ();_afffd .SetIndent (0);_afffd .SetContent (_adece );_afffd =_gdgb .NewCell ();_afffd .SetContent (_ggdca );return _gdgb .GeneratePageBlocks (_agb );};

// SetColor sets the color of the Paragraph text.
//
// Example:
//
//  1. p := NewParagraph("Red paragraph")
//     // Set to red color with a hex code:
//     p.SetColor(creator.ColorRGBFromHex("#ff0000"))
//
//  2. Make Paragraph green with 8-bit rgb values (0-255 each component)
//     p.SetColor(creator.ColorRGBFrom8bit(0, 255, 0)
//
//  3. Make Paragraph blue with arithmetic (0-1) rgb components.
//     p.SetColor(creator.ColorRGBFromArithmetic(0, 0, 1.0)
func (_beeee *Paragraph )SetColor (col Color ){_beeee ._cece =col };

// HeaderFunctionArgs holds the input arguments to a header drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type HeaderFunctionArgs struct{PageNum int ;TotalPages int ;};

// SetFitMode sets the fit mode of the ellipse.
// NOTE: The fit mode is only applied if relative positioning is used.
func (_bcde *Ellipse )SetFitMode (fitMode FitMode ){_bcde ._cfef =fitMode };

// NewParagraph creates a new text paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_aafd *Creator )NewParagraph (text string )*Paragraph {return _edadc (text ,_aafd .NewTextStyle ())};

// DrawWithContext draws the Block using the specified drawing context.
func (_caf *Block )DrawWithContext (d Drawable ,ctx DrawContext )error {_gcf ,_ ,_dad :=d .GeneratePageBlocks (ctx );if _dad !=nil {return _dad ;};if len (_gcf )!=1{return _c .New ("\u0074\u006f\u006f\u0020ma\u006e\u0079\u0020\u006f\u0075\u0074\u0070\u0075\u0074\u0020\u0062\u006c\u006f\u0063k\u0073");
};for _ ,_fab :=range _gcf {if _abff :=_caf .mergeBlocks (_fab );_abff !=nil {return _abff ;};};return nil ;};type pageTransformations struct{_ddf *_ebg .Matrix ;_ffea bool ;_cdge bool ;};

// AppendCurve appends a Bezier curve to the filled curve.
func (_cdgdc *FilledCurve )AppendCurve (curve _bc .CubicBezierCurve )*FilledCurve {_cdgdc ._bgegb =append (_cdgdc ._bgegb ,curve );return _cdgdc ;};

// EnablePageWrap controls whether the division is wrapped across pages.
// If disabled, the division is moved in its entirety on a new page, if it
// does not fit in the available height. By default, page wrapping is enabled.
// If the height of the division is larger than an entire page, wrapping is
// enabled automatically in order to avoid unwanted behavior.
// Currently, page wrapping can only be disabled for vertical divisions.
func (_accg *Division )EnablePageWrap (enable bool ){_accg ._ceab =enable };func (_dccf *Division )ctxHeight (_ebaa float64 )float64 {_ebaa -=_dccf ._ccad .Left +_dccf ._ccad .Right +_dccf ._cacc .Left +_dccf ._cacc .Right ;var _fadf float64 ;for _ ,_acfde :=range _dccf ._cfadf {_fadf +=_abda (_acfde ,_ebaa );
};return _fadf ;};

// NewRectangle creates a new rectangle with the left corner at (`x`, `y`),
// having the specified width and height.
// NOTE: In relative positioning mode, `x` and `y` are calculated using the
// current context. Furthermore, when the fit mode is set to fill the available
// space, the rectangle is scaled so that it occupies the entire context width
// while maintaining the original aspect ratio.
func (_gbaa *Creator )NewRectangle (x ,y ,width ,height float64 )*Rectangle {return _cfab (x ,y ,width ,height );};

// SetLogo sets the logo of the invoice.
func (_eabc *Invoice )SetLogo (logo *Image ){_eabc ._abfe =logo };

// SetLineWidth sets the line width.
func (_gdbe *Polyline )SetLineWidth (lineWidth float64 ){_gdbe ._afgc .LineWidth =lineWidth };func _efbb (_ebcc Color ,_cfabd float64 )*ColorPoint {return &ColorPoint {_gaed :_ebcc ,_adcc :_cfabd }};func (_bbba cmykColor )ToRGB ()(float64 ,float64 ,float64 ){_cge :=_bbba ._dfbe ;
return 1-(_bbba ._bca *(1-_cge )+_cge ),1-(_bbba ._cdgdd *(1-_cge )+_cge ),1-(_bbba ._cebb *(1-_cge )+_cge );};func (_edg *Chapter )headingNumber ()string {var _gdac string ;if _edg ._gae {if _edg ._gaaa !=0{_gdac =_df .Itoa (_edg ._gaaa )+"\u002e";};if _edg ._cdgd !=nil {_acg :=_edg ._cdgd .headingNumber ();
if _acg !=""{_gdac =_acg +_gdac ;};};};return _gdac ;};

// Width returns the Block's width.
func (_ca *Block )Width ()float64 {return _ca ._beg };

// Draw processes the specified Drawable widget and generates blocks that can
// be rendered to the output document. The generated blocks can span over one
// or more pages. Additional pages are added if the contents go over the current
// page. Each generated block is assigned to the creator page it will be
// rendered to. In order to render the generated blocks to the creator pages,
// call Finalize, Write or WriteToFile.
func (_fca *Creator )Draw (d Drawable )error {if _fca .getActivePage ()==nil {_fca .NewPage ();};_ccgd ,_efcgf ,_bfce :=d .GeneratePageBlocks (_fca ._fafg );if _bfce !=nil {return _bfce ;};if len (_efcgf ._ddeg )> 0{_fca .Errors =append (_fca .Errors ,_efcgf ._ddeg ...);
};for _gafa ,_gbb :=range _ccgd {if _gafa > 0{_fca .NewPage ();};_dgfc :=_fca .getActivePage ();if _eefd ,_aded :=_fca ._ffgd [_dgfc ];_aded {if _ceaa :=_eefd .mergeBlocks (_gbb );_ceaa !=nil {return _ceaa ;};if _fdga :=_ffe (_gbb ._bf ,_eefd ._bf );_fdga !=nil {return _fdga ;
};}else {_fca ._ffgd [_dgfc ]=_gbb ;};};_fca ._fafg .X =_efcgf .X ;_fca ._fafg .Y =_efcgf .Y ;_fca ._fafg .Height =_efcgf .PageHeight -_efcgf .Y -_efcgf .Margins .Bottom ;return nil ;};

// Height returns the current page height.
func (_eebd *Creator )Height ()float64 {return _eebd ._bgfe };type templateProcessor struct{creator *Creator ;_afbd []byte ;_afgab *TemplateOptions ;_bddg componentRenderer ;};

// GetHeading returns the chapter heading paragraph. Used to give access to address style: font, sizing etc.
func (_fcbg *Chapter )GetHeading ()*Paragraph {return _fcbg ._cff };

// NewInvoice returns an instance of an empty invoice.
func (_gdbf *Creator )NewInvoice ()*Invoice {_fbc :=_gdbf .NewTextStyle ();_fbc .Font =_gdbf ._dcef ;return _aebab (_gdbf .NewTextStyle (),_fbc );};

// SetRowHeight sets the height for a specified row.
func (_cgba *Table )SetRowHeight (row int ,h float64 )error {if row < 1||row > len (_cgba ._accga ){return _c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_cgba ._accga [row -1]=h ;return nil ;
};

// SetMargins sets the Chapter margins: left, right, top, bottom.
// Typically not needed as the creator's page margins are used.
func (_cbcf *Chapter )SetMargins (left ,right ,top ,bottom float64 ){_cbcf ._eeeg .Left =left ;_cbcf ._eeeg .Right =right ;_cbcf ._eeeg .Top =top ;_cbcf ._eeeg .Bottom =bottom ;};

// SetMargins sets the margins of the component. The margins are applied
// around the division.
func (_dceb *Division )SetMargins (left ,right ,top ,bottom float64 ){_dceb ._ccad .Left =left ;_dceb ._ccad .Right =right ;_dceb ._ccad .Top =top ;_dceb ._ccad .Bottom =bottom ;};

// SetBorder sets the cell's border style.
func (_agfab *TableCell )SetBorder (side CellBorderSide ,style CellBorderStyle ,width float64 ){if style ==CellBorderStyleSingle &&side ==CellBorderSideAll {_agfab ._afcc =CellBorderStyleSingle ;_agfab ._cfdac =width ;_agfab ._ccbfd =CellBorderStyleSingle ;
_agfab ._ecgbf =width ;_agfab ._gdbg =CellBorderStyleSingle ;_agfab ._efbec =width ;_agfab ._acgb =CellBorderStyleSingle ;_agfab ._aedea =width ;}else if style ==CellBorderStyleDouble &&side ==CellBorderSideAll {_agfab ._afcc =CellBorderStyleDouble ;_agfab ._cfdac =width ;
_agfab ._ccbfd =CellBorderStyleDouble ;_agfab ._ecgbf =width ;_agfab ._gdbg =CellBorderStyleDouble ;_agfab ._efbec =width ;_agfab ._acgb =CellBorderStyleDouble ;_agfab ._aedea =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideLeft {_agfab ._afcc =style ;
_agfab ._cfdac =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideBottom {_agfab ._ccbfd =style ;_agfab ._ecgbf =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideRight {_agfab ._gdbg =style ;
_agfab ._efbec =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideTop {_agfab ._acgb =style ;_agfab ._aedea =width ;};};

// FillColor returns the fill color of the ellipse.
func (_cdcf *Ellipse )FillColor ()Color {return _cdcf ._eged };

// HorizontalAlignment represents the horizontal alignment of components
// within a page.
type HorizontalAlignment int ;func (_dada *RadialShading )shadingModel ()*_ed .PdfShadingType3 {_fgdee ,_cafdg ,_fggac :=_dada ._baadc ._cddd .ToRGB ();var _ccca _bc .Point ;switch _dada ._aedf {case AnchorBottomLeft :_ccca =_bc .Point {X :_dada ._bgga .Llx ,Y :_dada ._bgga .Lly };
case AnchorBottomRight :_ccca =_bc .Point {X :_dada ._bgga .Urx ,Y :_dada ._bgga .Ury -_dada ._bgga .Height ()};case AnchorTopLeft :_ccca =_bc .Point {X :_dada ._bgga .Llx ,Y :_dada ._bgga .Lly +_dada ._bgga .Height ()};case AnchorTopRight :_ccca =_bc .Point {X :_dada ._bgga .Urx ,Y :_dada ._bgga .Ury };
case AnchorLeft :_ccca =_bc .Point {X :_dada ._bgga .Llx ,Y :_dada ._bgga .Lly +_dada ._bgga .Height ()/2};case AnchorTop :_ccca =_bc .Point {X :_dada ._bgga .Llx +_dada ._bgga .Width ()/2,Y :_dada ._bgga .Ury };case AnchorRight :_ccca =_bc .Point {X :_dada ._bgga .Urx ,Y :_dada ._bgga .Lly +_dada ._bgga .Height ()/2};
case AnchorBottom :_ccca =_bc .Point {X :_dada ._bgga .Urx +_dada ._bgga .Width ()/2,Y :_dada ._bgga .Lly };default:_ccca =_bc .NewPoint (_dada ._bgga .Llx +_dada ._bgga .Width ()/2,_dada ._bgga .Lly +_dada ._bgga .Height ()/2);};_fecaf :=_dada ._efad ;
_ggbca :=_dada ._bede ;_abad :=_ccca .X +_dada ._bgfad ;_gecbg :=_ccca .Y +_dada ._cgaea ;if _fecaf ==-1.0{_fecaf =0.0;};if _ggbca ==-1.0{var _cgaec []float64 ;_dgae :=_gd .Pow (_abad -_dada ._bgga .Llx ,2)+_gd .Pow (_gecbg -_dada ._bgga .Lly ,2);_cgaec =append (_cgaec ,_gd .Abs (_dgae ));
_ebeee :=_gd .Pow (_abad -_dada ._bgga .Llx ,2)+_gd .Pow (_dada ._bgga .Lly +_dada ._bgga .Height ()-_gecbg ,2);_cgaec =append (_cgaec ,_gd .Abs (_ebeee ));_fcgga :=_gd .Pow (_dada ._bgga .Urx -_abad ,2)+_gd .Pow (_gecbg -_dada ._bgga .Ury -_dada ._bgga .Height (),2);
_cgaec =append (_cgaec ,_gd .Abs (_fcgga ));_adbf :=_gd .Pow (_dada ._bgga .Urx -_abad ,2)+_gd .Pow (_dada ._bgga .Ury -_gecbg ,2);_cgaec =append (_cgaec ,_gd .Abs (_adbf ));_f .Slice (_cgaec ,func (_cbbdg ,_ddee int )bool {return _cbbdg > _ddee });_ggbca =_gd .Sqrt (_cgaec [0]);
};_gdgg :=&_ed .PdfRectangle {Llx :_abad -_ggbca ,Lly :_gecbg -_ggbca ,Urx :_abad +_ggbca ,Ury :_gecbg +_ggbca };_gebc :=_ed .NewPdfShadingType3 ();_gebc .PdfShading .ShadingType =_gg .MakeInteger (3);_gebc .PdfShading .ColorSpace =_ed .NewPdfColorspaceDeviceRGB ();
_gebc .PdfShading .Background =_gg .MakeArrayFromFloats ([]float64 {_fgdee ,_cafdg ,_fggac });_gebc .PdfShading .BBox =_gdgg ;_gebc .PdfShading .AntiAlias =_gg .MakeBool (_dada ._baadc ._ccaa );_gebc .Coords =_gg .MakeArrayFromFloats ([]float64 {_abad ,_gecbg ,_fecaf ,_abad ,_gecbg ,_ggbca });
_gebc .Domain =_gg .MakeArrayFromFloats ([]float64 {0.0,1.0});_gebc .Extend =_gg .MakeArray (_gg .MakeBool (_dada ._baadc ._bbfa [0]),_gg .MakeBool (_dada ._baadc ._bbfa [1]));_gebc .Function =_dada ._baadc .generatePdfFunctions ();return _gebc ;};

// SetMargins sets the Paragraph's margins.
func (_dbge *Paragraph )SetMargins (left ,right ,top ,bottom float64 ){_dbge ._bcbe .Left =left ;_dbge ._bcbe .Right =right ;_dbge ._bcbe .Top =top ;_dbge ._bcbe .Bottom =bottom ;};

// SetNoteStyle sets the style properties used to render the content of the
// invoice note sections.
func (_gfed *Invoice )SetNoteStyle (style TextStyle ){_gfed ._fddc =style };

// NewBlock creates a new Block with specified width and height.
func NewBlock (width float64 ,height float64 )*Block {_ba :=&Block {};_ba ._eg =&_da .ContentStreamOperations {};_ba ._bf =_ed .NewPdfPageResources ();_ba ._beg =width ;_ba ._fc =height ;return _ba ;};func (_edcebc *templateProcessor )parseBackground (_efda *templateNode )(interface{},error ){_fcbcd :=&Background {};
for _ ,_aead :=range _efda ._fcdbfb .Attr {_cgeb :=_aead .Value ;switch _bggae :=_aead .Name .Local ;_bggae {case "\u0066\u0069\u006c\u006c\u002d\u0063\u006f\u006c\u006f\u0072":_fcbcd .FillColor =_edcebc .parseColorAttr (_bggae ,_cgeb );case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072":_fcbcd .BorderColor =_edcebc .parseColorAttr (_bggae ,_cgeb );
case "b\u006f\u0072\u0064\u0065\u0072\u002d\u0073\u0069\u007a\u0065":_fcbcd .BorderSize =_edcebc .parseFloatAttr (_bggae ,_cgeb );case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0072\u0061\u0064\u0069\u0075\u0073":_gecd ,_cfbca ,_eabbg ,_gfea :=_edcebc .parseBorderRadiusAttr (_bggae ,_cgeb );
_fcbcd .SetBorderRadius (_gecd ,_cfbca ,_gfea ,_eabbg );case "\u0062\u006f\u0072\u0064er\u002d\u0074\u006f\u0070\u002d\u006c\u0065\u0066\u0074\u002d\u0072\u0061\u0064\u0069u\u0073":_fcbcd .BorderRadiusTopLeft =_edcebc .parseFloatAttr (_bggae ,_cgeb );case "\u0062\u006f\u0072de\u0072\u002d\u0074\u006f\u0070\u002d\u0072\u0069\u0067\u0068\u0074\u002d\u0072\u0061\u0064\u0069\u0075\u0073":_fcbcd .BorderRadiusTopRight =_edcebc .parseFloatAttr (_bggae ,_cgeb );
case "\u0062o\u0072\u0064\u0065\u0072-\u0062\u006f\u0074\u0074\u006fm\u002dl\u0065f\u0074\u002d\u0072\u0061\u0064\u0069\u0075s":_fcbcd .BorderRadiusBottomLeft =_edcebc .parseFloatAttr (_bggae ,_cgeb );case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0062\u006f\u0074\u0074o\u006d\u002d\u0072\u0069\u0067\u0068\u0074\u002d\u0072\u0061d\u0069\u0075\u0073":_fcbcd .BorderRadiusBottomRight =_edcebc .parseFloatAttr (_bggae ,_cgeb );
default:_de .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0062\u0061\u0063\u006b\u0067\u0072\u006f\u0075\u006e\u0064\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006bi\u0070p\u0069\u006e\u0067\u002e",_bggae );
};};return _fcbcd ,nil ;};

// GetRowHeight returns the height of the specified row.
func (_cagbe *Table )GetRowHeight (row int )(float64 ,error ){if row < 1||row > len (_cagbe ._accga ){return 0,_c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};return _cagbe ._accga [row -1],nil ;
};func (_caac *templateProcessor )parseTable (_ggecc *templateNode )(interface{},error ){var _dafg int64 ;for _ ,_cdcgf :=range _ggecc ._fcdbfb .Attr {_bgceg :=_cdcgf .Value ;switch _gccff :=_cdcgf .Name .Local ;_gccff {case "\u0063o\u006c\u0075\u006d\u006e\u0073":_dafg =_caac .parseInt64Attr (_gccff ,_bgceg );
};};if _dafg <=0{_de .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006eu\u006d\u0062e\u0072\u0020\u006f\u0066\u0020\u0074\u0061\u0062\u006ce\u0020\u0063\u006f\u006cu\u006d\u006e\u0073\u003a\u0020\u0025\u0064\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0031\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0020m\u0061\u0079\u0020b\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u002e",_dafg );
_dafg =1;};_egede :=_caac .creator .NewTable (int (_dafg ));for _ ,_faaed :=range _ggecc ._fcdbfb .Attr {_dacdd :=_faaed .Value ;switch _ccfdb :=_faaed .Name .Local ;_ccfdb {case "\u0063\u006f\u006c\u0075\u006d\u006e\u002d\u0077\u0069\u0064\u0074\u0068\u0073":_egede .SetColumnWidths (_caac .parseFloatArray (_ccfdb ,_dacdd )...);
case "\u006d\u0061\u0072\u0067\u0069\u006e":_aacb :=_caac .parseMarginAttr (_ccfdb ,_dacdd );_egede .SetMargins (_aacb .Left ,_aacb .Right ,_aacb .Top ,_aacb .Bottom );case "\u0078":_egede .SetPos (_caac .parseFloatAttr (_ccfdb ,_dacdd ),_egede ._gdcc );
case "\u0079":_egede .SetPos (_egede ._bgacf ,_caac .parseFloatAttr (_ccfdb ,_dacdd ));case "\u0068\u0065a\u0064\u0065\u0072-\u0073\u0074\u0061\u0072\u0074\u002d\u0072\u006f\u0077":_egede ._edbcf =int (_caac .parseInt64Attr (_ccfdb ,_dacdd ));case "\u0068\u0065\u0061\u0064\u0065\u0072\u002d\u0065\u006ed\u002d\u0072\u006f\u0077":_egede ._bgab =int (_caac .parseInt64Attr (_ccfdb ,_dacdd ));
case "\u0065n\u0061b\u006c\u0065\u002d\u0072\u006f\u0077\u002d\u0077\u0072\u0061\u0070":_egede .EnableRowWrap (_caac .parseBoolAttr (_ccfdb ,_dacdd ));case "\u0065\u006ea\u0062\u006c\u0065-\u0070\u0061\u0067\u0065\u002d\u0077\u0072\u0061\u0070":_egede .EnablePageWrap (_caac .parseBoolAttr (_ccfdb ,_dacdd ));
case "\u0063o\u006c\u0075\u006d\u006e\u0073":break ;default:_de .Log .Debug ("\u0055n\u0073\u0075p\u0070\u006f\u0072\u0074e\u0064\u0020\u0074a\u0062\u006c\u0065\u0020\u0061\u0074\u0074\u0072\u0069bu\u0074\u0065\u003a \u0060\u0025s\u0060\u002e\u0020\u0053\u006b\u0069p\u0070\u0069n\u0067\u002e",_ccfdb );
};};if _egede ._edbcf !=0&&_egede ._bgab !=0{_cdfc :=_egede .SetHeaderRows (_egede ._edbcf ,_egede ._bgab );if _cdfc !=nil {_de .Log .Debug ("\u0043\u006ful\u0064\u0020\u006eo\u0074\u0020\u0073\u0065t t\u0061bl\u0065\u0020\u0068\u0065\u0061\u0064\u0065r \u0072\u006f\u0077\u0073\u003a\u0020\u0025v\u002e",_cdfc );
};}else {_egede ._edbcf =0;_egede ._bgab =0;};return _egede ,nil ;};

// NewDivision returns a new Division container component.
func (_fag *Creator )NewDivision ()*Division {return _daa ()};

// Polygon represents a polygon shape.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Polygon struct{_gaecf *_bc .Polygon ;_fegg float64 ;_daaf float64 ;_bedd Color ;};

// SetAngle sets the rotation angle of the text.
func (_agaff *StyledParagraph )SetAngle (angle float64 ){_agaff ._caag =angle };

// NewColumn returns a new column for the line items invoice table.
func (_cfda *Invoice )NewColumn (description string )*InvoiceCell {return _cfda .newColumn (description ,CellHorizontalAlignmentLeft );};

// FillColor returns the fill color of the rectangle.
func (_dfecd *Rectangle )FillColor ()Color {return _dfecd ._bbaf };

// SetBorderOpacity sets the border opacity of the ellipse.
func (_gaee *Ellipse )SetBorderOpacity (opacity float64 ){_gaee ._eega =opacity };

// BorderColor returns the border color of the ellipse.
func (_eeec *Ellipse )BorderColor ()Color {return _eeec ._facc };func (_dccg *Division )split (_bccc DrawContext )(_bgcg ,_dbef *Division ){var (_gbag float64 ;_bcbb ,_dagg []VectorDrawable ;);_fgad :=_bccc .Width -_dccg ._ccad .Left -_dccg ._ccad .Right -_dccg ._cacc .Left -_dccg ._cacc .Right ;
for _gdacd ,_dgbcf :=range _dccg ._cfadf {_gbag +=_abda (_dgbcf ,_fgad );if _gbag < _bccc .Height {_bcbb =append (_bcbb ,_dgbcf );}else {_dagg =_dccg ._cfadf [_gdacd :];break ;};};if len (_bcbb )> 0{_bgcg =_daa ();*_bgcg =*_dccg ;_bgcg ._cfadf =_bcbb ;
if _dccg ._dbce !=nil {_bgcg ._dbce =&Background {};*_bgcg ._dbce =*_dccg ._dbce ;};};if len (_dagg )> 0{_dbef =_daa ();*_dbef =*_dccg ;_dbef ._cfadf =_dagg ;if _dccg ._dbce !=nil {_dbef ._dbce =&Background {};*_dbef ._dbce =*_dccg ._dbce ;};};return _bgcg ,_dbef ;
};

// Add appends a new item to the list.
// The supported components are: *Paragraph, *StyledParagraph and *List.
// Returns the marker used for the newly added item. The returned marker
// object can be used to change the text and style of the marker for the
// current item.
func (_bdc *List )Add (item VectorDrawable )(*TextChunk ,error ){_bgge :=&listItem {_ecde :item ,_cgff :_bdc ._cbbd };switch _fadcd :=item .(type ){case *Paragraph :case *StyledParagraph :case *List :if _fadcd ._gcfc {_fadcd ._decc =15;};default:return nil ,_c .New ("\u0074\u0068i\u0073\u0020\u0074\u0079\u0070\u0065\u0020\u006f\u0066\u0020\u0064\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0069\u006e\u0020\u006c\u0069\u0073\u0074");
};_bdc ._dbgfa =append (_bdc ._dbgfa ,_bgge );return &_bgge ._cgff ,nil ;};

// Width returns the width of the ellipse.
func (_fadc *Ellipse )Width ()float64 {return _fadc ._dcg };func _cfdge (_eccbg ...interface{})(map[string ]interface{},error ){_bdfc :=len (_eccbg );if _bdfc %2!=0{_de .Log .Error ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u006f\u0066\u0020p\u0061\u0072\u0061\u006d\u0065\u0074\u0065r\u0073\u0020\u0066\u006f\u0072\u0020\u0063\u0072\u0065\u0061\u0074i\u006e\u0067\u0020\u006d\u0061\u0070\u003a\u0020\u0025\u0064\u002e",_bdfc );
return nil ,_gg .ErrRangeError ;};_eafg :=map[string ]interface{}{};for _accgc :=0;_accgc < _bdfc ;_accgc +=2{_dabe ,_becg :=_eccbg [_accgc ].(string );if !_becg {_de .Log .Error ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064 \u006d\u0061\u0070 \u006b\u0065\u0079\u0020t\u0079\u0070\u0065\u0020\u0028\u0025\u0054\u0029\u002e\u0020\u0045\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u002e",_eccbg [_accgc ]);
return nil ,_gg .ErrTypeError ;};_eafg [_dabe ]=_eccbg [_accgc +1];};return _eafg ,nil ;};

// SetTitleStyle sets the style properties of the invoice title.
func (_abac *Invoice )SetTitleStyle (style TextStyle ){_abac ._cace =style };func (_cfcc *Invoice )setCellBorder (_gbce *TableCell ,_dbec *InvoiceCell ){for _ ,_cage :=range _dbec .BorderSides {_gbce .SetBorder (_cage ,CellBorderStyleSingle ,_dbec .BorderWidth );
};_gbce .SetBorderColor (_dbec .BorderColor );};

// GeneratePageBlocks draws the rectangle on a new block representing the page. Implements the Drawable interface.
func (_effaa *Rectangle )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var (_bbgfd []*Block ;_bcaa =NewBlock (ctx .PageWidth ,ctx .PageHeight );_fagcc =ctx ;_feef =_effaa ._gaffd /2;);_gdaa :=_effaa ._dded .IsRelative ();if _gdaa {_effaa .applyFitMode (ctx .Width );
ctx .X +=_effaa ._efbdg .Left +_feef ;ctx .Y +=_effaa ._efbdg .Top +_feef ;ctx .Width -=_effaa ._efbdg .Left +_effaa ._efbdg .Right ;ctx .Height -=_effaa ._efbdg .Top +_effaa ._efbdg .Bottom ;if _effaa ._agadf > ctx .Height {_bbgfd =append (_bbgfd ,_bcaa );
_bcaa =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_dadb :=ctx ;_dadb .Y =ctx .Margins .Top +_effaa ._efbdg .Top +_feef ;_dadb .X =ctx .Margins .Left +_effaa ._efbdg .Left +_feef ;_dadb .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_effaa ._efbdg .Top -_effaa ._efbdg .Bottom ;
_dadb .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_effaa ._efbdg .Left -_effaa ._efbdg .Right ;ctx =_dadb ;};}else {ctx .X =_effaa ._eadb ;ctx .Y =_effaa ._accbb ;};_afeg :=_bc .Rectangle {X :ctx .X ,Y :ctx .PageHeight -ctx .Y -_effaa ._agadf ,Width :_effaa ._egbf ,Height :_effaa ._agadf ,BorderRadiusTopLeft :_effaa ._eaad ,BorderRadiusTopRight :_effaa ._dbegg ,BorderRadiusBottomLeft :_effaa ._eeffc ,BorderRadiusBottomRight :_effaa ._cdad ,Opacity :1.0};
if _effaa ._bbaf !=nil {_afeg .FillEnabled =true ;_fgcgf :=_ccfb (_effaa ._bbaf );_eabb :=_abfb (_bcaa ,_fgcgf ,_effaa ._bbaf ,func ()Rectangle {return Rectangle {_eadb :_afeg .X ,_accbb :_afeg .Y ,_egbf :_afeg .Width ,_agadf :_afeg .Height };});if _eabb !=nil {return nil ,ctx ,_eabb ;
};_afeg .FillColor =_fgcgf ;};if _effaa ._dca !=nil &&_effaa ._gaffd > 0{_afeg .BorderEnabled =true ;_afeg .BorderColor =_ccfb (_effaa ._dca );_afeg .BorderWidth =_effaa ._gaffd ;};_aecb ,_ecdd :=_bcaa .setOpacity (_effaa ._eeed ,_effaa ._bedf );if _ecdd !=nil {return nil ,ctx ,_ecdd ;
};_eddd ,_ ,_ecdd :=_afeg .Draw (_aecb );if _ecdd !=nil {return nil ,ctx ,_ecdd ;};if _ecdd =_bcaa .addContentsByString (string (_eddd ));_ecdd !=nil {return nil ,ctx ,_ecdd ;};if _gdaa {ctx .X =_fagcc .X ;ctx .Width =_fagcc .Width ;_cdcg :=_effaa ._agadf +_feef ;
ctx .Y +=_cdcg +_effaa ._efbdg .Bottom ;ctx .Height -=_cdcg ;}else {ctx =_fagcc ;};_bbgfd =append (_bbgfd ,_bcaa );return _bbgfd ,ctx ,nil ;};

// Style returns the style of the line.
func (_ddcb *Line )Style ()_bc .LineStyle {return _ddcb ._dcge };func (_aebfg *templateProcessor )parseChapter (_eaaa *templateNode )(interface{},error ){_gedef :=_aebfg .creator .NewChapter ;if _eaaa ._abgba !=nil {if _baabe ,_ccda :=_eaaa ._abgba ._defd .(*Chapter );
_ccda {_gedef =_baabe .NewSubchapter ;};};_ebgedf :=_gedef ("");for _ ,_eace :=range _eaaa ._fcdbfb .Attr {_agcfc :=_eace .Value ;switch _aabbc :=_eace .Name .Local ;_aabbc {case "\u0073\u0068\u006f\u0077\u002d\u006e\u0075\u006d\u0062e\u0072\u0069\u006e\u0067":_ebgedf .SetShowNumbering (_aebfg .parseBoolAttr (_aabbc ,_agcfc ));
case "\u0069\u006e\u0063\u006c\u0075\u0064\u0065\u002d\u0069n\u002d\u0074\u006f\u0063":_ebgedf .SetIncludeInTOC (_aebfg .parseBoolAttr (_aabbc ,_agcfc ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_gdfd :=_aebfg .parseMarginAttr (_aabbc ,_agcfc );_ebgedf .SetMargins (_gdfd .Left ,_gdfd .Right ,_gdfd .Top ,_gdfd .Bottom );
default:_de .Log .Debug ("\u0055\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0063\u0068\u0061\u0070\u0074\u0065\u0072\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_aabbc );
};};return _ebgedf ,nil ;};func (_fba rgbColor )ToRGB ()(float64 ,float64 ,float64 ){return _fba ._fbba ,_fba ._dbd ,_fba ._fdc };

// SetLineSeparator sets the separator for all new lines of the table of contents.
func (_bggc *TOC )SetLineSeparator (separator string ){_bggc ._fbcdb =separator };func (_acabd *templateProcessor )parseTableCell (_cgaca *templateNode )(interface{},error ){if _cgaca ._abgba ==nil {_de .Log .Error ("\u0054\u0061\u0062\u006c\u0065\u0020\u0063\u0065\u006c\u006c\u0020\u0070\u0061\u0072\u0065n\u0074 \u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e");
return nil ,_daggc ;};_gafaeg ,_bbbf :=_cgaca ._abgba ._defd .(*Table );if !_bbbf {_de .Log .Error ("\u0054\u0061\u0062\u006c\u0065\u0020\u0063\u0065\u006c\u006c\u0020\u0070\u0061\u0072\u0065\u006e\u0074\u0020\u0028\u0025\u0054\u0029\u0020\u0069s\u0020\u006e\u006f\u0074\u0020a\u0020\u0074a\u0062\u006c\u0065\u002e",_cgaca ._abgba ._defd );
return nil ,_daggc ;};var _dcfc ,_gfbed int64 ;for _ ,_ggbeg :=range _cgaca ._fcdbfb .Attr {_bgda :=_ggbeg .Value ;switch _dfbaf :=_ggbeg .Name .Local ;_dfbaf {case "\u0063o\u006c\u0073\u0070\u0061\u006e":_dcfc =_acabd .parseInt64Attr (_dfbaf ,_bgda );
case "\u0072o\u0077\u0073\u0070\u0061\u006e":_gfbed =_acabd .parseInt64Attr (_dfbaf ,_bgda );};};if _dcfc <=0{_dcfc =1;};if _gfbed <=0{_gfbed =1;};_ggbde :=_gafaeg .MultiCell (int (_gfbed ),int (_dcfc ));for _ ,_agdde :=range _cgaca ._fcdbfb .Attr {_cgcfa :=_agdde .Value ;
switch _ecbee :=_agdde .Name .Local ;_ecbee {case "\u0069\u006e\u0064\u0065\u006e\u0074":_ggbde .SetIndent (_acabd .parseFloatAttr (_ecbee ,_cgcfa ));case "\u0061\u006c\u0069g\u006e":_ggbde .SetHorizontalAlignment (_acabd .parseCellAlignmentAttr (_ecbee ,_cgcfa ));
case "\u0076\u0065\u0072\u0074\u0069\u0063\u0061\u006c\u002da\u006c\u0069\u0067\u006e":_ggbde .SetVerticalAlignment (_acabd .parseCellVerticalAlignmentAttr (_ecbee ,_cgcfa ));case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0073\u0074\u0079\u006c\u0065":_ggbde .SetSideBorderStyle (CellBorderSideAll ,_acabd .parseCellBorderStyleAttr (_ecbee ,_cgcfa ));
case "\u0062\u006fr\u0064\u0065\u0072-\u0073\u0074\u0079\u006c\u0065\u002d\u0074\u006f\u0070":_ggbde .SetSideBorderStyle (CellBorderSideTop ,_acabd .parseCellBorderStyleAttr (_ecbee ,_cgcfa ));case "\u0062\u006f\u0072\u0064er\u002d\u0073\u0074\u0079\u006c\u0065\u002d\u0062\u006f\u0074\u0074\u006f\u006d":_ggbde .SetSideBorderStyle (CellBorderSideBottom ,_acabd .parseCellBorderStyleAttr (_ecbee ,_cgcfa ));
case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0073\u0074\u0079\u006c\u0065-\u006c\u0065\u0066\u0074":_ggbde .SetSideBorderStyle (CellBorderSideLeft ,_acabd .parseCellBorderStyleAttr (_ecbee ,_cgcfa ));case "\u0062o\u0072d\u0065\u0072\u002d\u0073\u0074y\u006c\u0065-\u0072\u0069\u0067\u0068\u0074":_ggbde .SetSideBorderStyle (CellBorderSideRight ,_acabd .parseCellBorderStyleAttr (_ecbee ,_cgcfa ));
case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0077\u0069\u0064\u0074\u0068":_ggbde .SetSideBorderWidth (CellBorderSideAll ,_acabd .parseFloatAttr (_ecbee ,_cgcfa ));case "\u0062\u006fr\u0064\u0065\u0072-\u0077\u0069\u0064\u0074\u0068\u002d\u0074\u006f\u0070":_ggbde .SetSideBorderWidth (CellBorderSideTop ,_acabd .parseFloatAttr (_ecbee ,_cgcfa ));
case "\u0062\u006f\u0072\u0064er\u002d\u0077\u0069\u0064\u0074\u0068\u002d\u0062\u006f\u0074\u0074\u006f\u006d":_ggbde .SetSideBorderWidth (CellBorderSideBottom ,_acabd .parseFloatAttr (_ecbee ,_cgcfa ));case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0077\u0069\u0064\u0074\u0068-\u006c\u0065\u0066\u0074":_ggbde .SetSideBorderWidth (CellBorderSideLeft ,_acabd .parseFloatAttr (_ecbee ,_cgcfa ));
case "\u0062o\u0072d\u0065\u0072\u002d\u0077\u0069d\u0074\u0068-\u0072\u0069\u0067\u0068\u0074":_ggbde .SetSideBorderWidth (CellBorderSideRight ,_acabd .parseFloatAttr (_ecbee ,_cgcfa ));case "\u0062\u006f\u0072d\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072":_ggbde .SetSideBorderColor (CellBorderSideAll ,_acabd .parseColorAttr (_ecbee ,_cgcfa ));
case "\u0062\u006fr\u0064\u0065\u0072-\u0063\u006f\u006c\u006f\u0072\u002d\u0074\u006f\u0070":_ggbde .SetSideBorderColor (CellBorderSideTop ,_acabd .parseColorAttr (_ecbee ,_cgcfa ));case "\u0062\u006f\u0072\u0064er\u002d\u0063\u006f\u006c\u006f\u0072\u002d\u0062\u006f\u0074\u0074\u006f\u006d":_ggbde .SetSideBorderColor (CellBorderSideBottom ,_acabd .parseColorAttr (_ecbee ,_cgcfa ));
case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u0063\u006f\u006c\u006f\u0072-\u006c\u0065\u0066\u0074":_ggbde .SetSideBorderColor (CellBorderSideLeft ,_acabd .parseColorAttr (_ecbee ,_cgcfa ));case "\u0062o\u0072d\u0065\u0072\u002d\u0063\u006fl\u006f\u0072-\u0072\u0069\u0067\u0068\u0074":_ggbde .SetSideBorderColor (CellBorderSideRight ,_acabd .parseColorAttr (_ecbee ,_cgcfa ));
case "\u0062\u006f\u0072\u0064\u0065\u0072\u002d\u006c\u0069\u006e\u0065\u002ds\u0074\u0079\u006c\u0065":_ggbde .SetBorderLineStyle (_acabd .parseLineStyleAttr (_ecbee ,_cgcfa ));case "\u0062\u0061c\u006b\u0067\u0072o\u0075\u006e\u0064\u002d\u0063\u006f\u006c\u006f\u0072":_ggbde .SetBackgroundColor (_acabd .parseColorAttr (_ecbee ,_cgcfa ));
case "\u0063o\u006c\u0073\u0070\u0061\u006e","\u0072o\u0077\u0073\u0070\u0061\u006e":break ;default:_de .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0063\u0065\u006c\u006c\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006bi\u0070p\u0069\u006e\u0067\u002e",_ecbee );
};};return _ggbde ,nil ;};

// SetLineLevelOffset sets the amount of space an indentation level occupies
// for all new lines of the table of contents.
func (_abec *TOC )SetLineLevelOffset (levelOffset float64 ){_abec ._dbdbe =levelOffset };

// SetWidthBottom sets border width for bottom.
func (_dfb *border )SetWidthBottom (bw float64 ){_dfb ._aed =bw };

// AddColorStop add color stop info for rendering gradient color.
func (_ddgg *RadialShading )AddColorStop (color Color ,point float64 ){_ddgg ._baadc .AddColorStop (color ,point );};

// BuyerAddress returns the buyer address used in the invoice template.
func (_babdd *Invoice )BuyerAddress ()*InvoiceAddress {return _babdd ._eeaf };func (_fec *Creator )initContext (){_fec ._fafg .X =_fec ._bffb .Left ;_fec ._fafg .Y =_fec ._bffb .Top ;_fec ._fafg .Width =_fec ._dea -_fec ._bffb .Right -_fec ._bffb .Left ;
_fec ._fafg .Height =_fec ._bgfe -_fec ._bffb .Bottom -_fec ._bffb .Top ;_fec ._fafg .PageHeight =_fec ._bgfe ;_fec ._fafg .PageWidth =_fec ._dea ;_fec ._fafg .Margins =_fec ._bffb ;_fec ._fafg ._dgccf =_fec .UnsupportedCharacterReplacement ;};

// InvoiceCellProps holds all style properties for an invoice cell.
type InvoiceCellProps struct{TextStyle TextStyle ;Alignment CellHorizontalAlignment ;BackgroundColor Color ;BorderColor Color ;BorderWidth float64 ;BorderSides []CellBorderSide ;};const (DefaultHorizontalScaling =100;);

// AddAnnotation adds an annotation to the current block.
// The annotation will be added to the page the block will be rendered on.
func (_edc *Block )AddAnnotation (annotation *_ed .PdfAnnotation ){for _ ,_bfc :=range _edc ._cgg {if _bfc ==annotation {return ;};};_edc ._cgg =append (_edc ._cgg ,annotation );};

// NewImageFromGoImage creates an Image from a go image.Image data structure.
func (_faa *Creator )NewImageFromGoImage (goimg _cd .Image )(*Image ,error ){return _dbff (goimg )};

// SetBackgroundColor set background color of the shading area.
//
// By default the background color is set to white.
func (_gfab *LinearShading )SetBackgroundColor (backgroundColor Color ){_gfab ._cecc .SetBackgroundColor (backgroundColor );};

// SetCoords sets the upper left corner coordinates of the rectangle.
func (_ddba *Rectangle )SetCoords (x ,y float64 ){_ddba ._eadb =x ;_ddba ._accbb =y };

// SetWidth sets the the Paragraph width. This is essentially the wrapping width, i.e. the width the
// text can extend to prior to wrapping over to next line.
func (_feec *Paragraph )SetWidth (width float64 ){_feec ._gbgcd =width ;_feec .wrapText ()};

// MultiCell makes a new cell with the specified row span and col span
// and inserts it into the table at the current position.
func (_deabg *Table )MultiCell (rowspan ,colspan int )*TableCell {_deabg ._cbae ++;_afagf :=(_deabg .moveToNextAvailableCell ()-1)%(_deabg ._efefg )+1;_bfdfe :=(_deabg ._cbae -1)/_deabg ._efefg +1;for _bfdfe > _deabg ._bebea {_deabg ._bebea ++;_deabg ._accga =append (_deabg ._accga ,_deabg ._ebdcc );
};_afaf :=&TableCell {};_afaf ._dgad =_bfdfe ;_afaf ._abdgb =_afagf ;_afaf ._cgfb =5;_afaf ._afcc =CellBorderStyleNone ;_afaf ._eacgd =_bc .LineStyleSolid ;_afaf ._eedf =CellHorizontalAlignmentLeft ;_afaf ._dbbf =CellVerticalAlignmentTop ;_afaf ._cfdac =0;
_afaf ._ecgbf =0;_afaf ._efbec =0;_afaf ._aedea =0;_dcgc :=ColorBlack ;_afaf ._ggab =_dcgc ;_afaf ._ebdf =_dcgc ;_afaf ._efgfc =_dcgc ;_afaf ._bgdb =_dcgc ;if rowspan < 1{_de .Log .Debug ("\u0054\u0061\u0062\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0072\u006f\u0077\u0073\u0070a\u006e\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061t\u0020\u0031\u0020\u0028\u0025\u0064\u0029\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063e\u006c\u006c\u0020\u0072\u006f\u0077s\u0070\u0061n\u0020\u0074o\u00201\u002e",rowspan );
rowspan =1;};_agacc :=_deabg ._bebea -(_afaf ._dgad -1);if rowspan > _agacc {_de .Log .Debug ("\u0054\u0061b\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0072\u006f\u0077\u0073\u0070\u0061\u006e\u0020\u0028\u0025d\u0029\u0020\u0065\u0078\u0063\u0065e\u0064\u0073\u0020\u0072\u0065\u006d\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0072o\u0077\u0073 \u0028\u0025\u0064\u0029.\u0020\u0041\u0064\u0064\u0069n\u0067\u0020\u0072\u006f\u0077\u0073\u002e",rowspan ,_agacc );
_deabg ._bebea +=rowspan -1;for _dbdff :=0;_dbdff <=rowspan -_agacc ;_dbdff ++{_deabg ._accga =append (_deabg ._accga ,_deabg ._ebdcc );};};for _edbfa :=0;_edbfa < colspan &&_afagf +_edbfa -1< len (_deabg ._bage );_edbfa ++{_deabg ._bage [_afagf +_edbfa -1]=rowspan -1;
};_afaf ._efdb =rowspan ;if colspan < 1{_de .Log .Debug ("\u0054\u0061\u0062\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0063\u006f\u006c\u0073\u0070a\u006e\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061n\u0020\u0031\u0020\u0028\u0025\u0064\u0029\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006cs\u0070\u0061n\u0020\u0074o\u00201\u002e",colspan );
colspan =1;};_acbf :=_deabg ._efefg -(_afaf ._abdgb -1);if colspan > _acbf {_de .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0065\u006c\u006c\u0020\u0063o\u006c\u0073\u0070\u0061\u006e\u0020\u0028\u0025\u0064\u0029\u0020\u0065\u0078\u0063\u0065\u0065\u0064\u0073\u0020\u0072\u0065\u006d\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0072\u006f\u0077\u0020\u0063\u006f\u006c\u0073\u0020\u0028\u0025d\u0029\u002e\u0020\u0041\u0064\u006a\u0075\u0073\u0074\u0069\u006e\u0067 \u0063\u006f\u006c\u0073\u0070\u0061n\u002e",colspan ,_acbf );
colspan =_acbf ;};_afaf ._bfeec =colspan ;_deabg ._cbae +=colspan -1;_deabg ._ddbf =append (_deabg ._ddbf ,_afaf );_afaf ._dedc =_deabg ;return _afaf ;};

// Lines returns all the lines the table of contents has.
func (_eagea *TOC )Lines ()[]*TOCLine {return _eagea ._gacd };

// SetLineWidth sets the line width.
func (_bfee *Line )SetLineWidth (width float64 ){_bfee ._cdbc =width };func _fgeb (_bfab ,_cfee ,_geag ,_eeab float64 )*Ellipse {return &Ellipse {_ggceg :_bfab ,_ecd :_cfee ,_dcg :_geag ,_bddb :_eeab ,_cdgf :PositionAbsolute ,_bbcdd :1.0,_facc :ColorBlack ,_fffa :1.0,_eega :1.0};
};type marginDrawable interface{VectorDrawable ;GetMargins ()(float64 ,float64 ,float64 ,float64 );};

// SetLineMargins sets the margins for all new lines of the table of contents.
func (_bbbgg *TOC )SetLineMargins (left ,right ,top ,bottom float64 ){_ecccg :=&_bbbgg ._gfabb ;_ecccg .Left =left ;_ecccg .Right =right ;_ecccg .Top =top ;_ecccg .Bottom =bottom ;};

// SetAnchor set gradient position anchor.
// Default to center.
func (_ecgb *RadialShading )SetAnchor (anchor AnchorPoint ){_ecgb ._aedf =anchor };

// SetOpacity sets the opacity of the line (0-1).
func (_cefeb *Line )SetOpacity (opacity float64 ){_cefeb ._edaf =opacity };

// SetMargins sets the margins TOC line.
func (_ebgaba *TOCLine )SetMargins (left ,right ,top ,bottom float64 ){_ebgaba ._egee =left ;_gfbcg :=&_ebgaba ._ddaf ._bgac ;_gfbcg .Left =_ebgaba ._egee +float64 (_ebgaba ._ggbcf -1)*_ebgaba ._gfggfd ;_gfbcg .Right =right ;_gfbcg .Top =top ;_gfbcg .Bottom =bottom ;
};

// New creates a new instance of the PDF Creator.
func New ()*Creator {const _gdbc ="c\u0072\u0065\u0061\u0074\u006f\u0072\u002e\u004e\u0065\u0077";_cbaa :=&Creator {};_cbaa ._fae =[]*_ed .PdfPage {};_cbaa ._ffgd =map[*_ed .PdfPage ]*Block {};_cbaa ._abcf =map[*_ed .PdfPage ]*pageTransformations {};_cbaa .SetPageSize (PageSizeLetter );
_ebdc :=0.1*_cbaa ._dea ;_cbaa ._bffb .Left =_ebdc ;_cbaa ._bffb .Right =_ebdc ;_cbaa ._bffb .Top =_ebdc ;_cbaa ._bffb .Bottom =_ebdc ;var _ceef error ;_cbaa ._efa ,_ceef =_ed .NewStandard14Font (_ed .HelveticaName );if _ceef !=nil {_cbaa ._efa =_ed .DefaultFont ();
};_cbaa ._dcef ,_ceef =_ed .NewStandard14Font (_ed .HelveticaBoldName );if _ceef !=nil {_cbaa ._efa =_ed .DefaultFont ();};_cbaa ._cgec =_cbaa .NewTOC ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073");
_cbaa .AddOutlines =true ;_cbaa ._cac =_ed .NewOutline ();_cg .TrackUse (_gdbc );return _cbaa ;};

// Notes returns the notes section of the invoice as a title-content pair.
func (_eefba *Invoice )Notes ()(string ,string ){return _eefba ._gbf [0],_eefba ._gbf [1]};

// SetDueDate sets the due date of the invoice.
func (_fgfb *Invoice )SetDueDate (dueDate string )(*InvoiceCell ,*InvoiceCell ){_fgfb ._facg [1].Value =dueDate ;return _fgfb ._facg [0],_fgfb ._facg [1];};func _ggdbb (_adbfe string )bool {_gbgeg :=func (_bcefg rune )bool {return _bcefg =='\u000A'};_bcgcg :=_ae .TrimFunc (_adbfe ,_gbgeg );
_adfd :=_eb .Paragraph {};_ ,_fabed :=_adfd .SetString (_bcgcg );if _fabed !=nil {return true ;};_fffbd ,_fabed :=_adfd .Order ();if _fabed !=nil {return true ;};if _fffbd .NumRuns ()< 1{return true ;};return _adfd .IsLeftToRight ();};func (_adfeg *TableCell )width (_agbcb []float64 ,_ebfb float64 )float64 {_dbfd :=float64 (0.0);
for _gfeea :=0;_gfeea < _adfeg ._bfeec ;_gfeea ++{_dbfd +=_agbcb [_adfeg ._abdgb +_gfeea -1];};return _dbfd *_ebfb ;};

// SetNumber sets the number of the invoice.
func (_fbdd *Invoice )SetNumber (number string )(*InvoiceCell ,*InvoiceCell ){_fbdd ._gbgcb [1].Value =number ;return _fbdd ._gbgcb [0],_fbdd ._gbgcb [1];};

// SetExtends specifies whether ot extend the shading beyond the starting and ending points.
//
// Text extends is set to `[]bool{false, false}` by default.
func (_eaeeg *RadialShading )SetExtends (start bool ,end bool ){_eaeeg ._baadc .SetExtends (start ,end )};const (CellBorderStyleNone CellBorderStyle =iota ;CellBorderStyleSingle ;CellBorderStyleDouble ;);

// Width returns the current page width.
func (_ege *Creator )Width ()float64 {return _ege ._dea };func (_eaea *templateProcessor )renderNode (_gdbcc *templateNode )error {_edcf :=_gdbcc ._defd ;if _edcf ==nil {return nil ;};_eacf :=_gdbcc ._fcdbfb .Name .Local ;_eeeab ,_eceb :=_bagba [_eacf ];
if !_eceb {_de .Log .Debug ("\u0049\u006e\u0076\u0061l\u0069\u0064\u0020\u0074\u0061\u0067\u003a\u0020\u0060\u0025s\u0060.\u0020\u0053\u006b\u0069\u0070\u0070\u0069n\u0067\u002e",_eacf );return nil ;};var _acde interface{};if _gdbcc ._abgba !=nil &&_gdbcc ._abgba ._defd !=nil {_efdfb :=_gdbcc ._abgba ._fcdbfb .Name .Local ;
if _ ,_eceb =_eeeab ._bceg [_efdfb ];!_eceb {_de .Log .Debug ("\u0060%\u0073\u0060 \u0069\u0073\u0020n\u006f\u0074\u0020\u0061\u0020\u0076\u0061l\u0069\u0064\u0020\u0070\u0061\u0072e\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074\u0068\u0065\u0020`\u0025\u0073\u0060\u0020\u006e\u006f\u0064\u0065\u002e",_efdfb ,_eacf );
return _daggc ;};_acde =_gdbcc ._abgba ._defd ;}else {_fggab :="\u0063r\u0065\u0061\u0074\u006f\u0072";switch _eaea ._bddg .(type ){case *Block :_fggab ="\u0062\u006c\u006fc\u006b";};if _ ,_eceb =_eeeab ._bceg [_fggab ];!_eceb {_de .Log .Debug ("\u0060%\u0073\u0060 \u0069\u0073\u0020n\u006f\u0074\u0020\u0061\u0020\u0076\u0061l\u0069\u0064\u0020\u0070\u0061\u0072e\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074\u0068\u0065\u0020`\u0025\u0073\u0060\u0020\u006e\u006f\u0064\u0065\u002e",_fggab ,_eacf );
return _daggc ;};_acde =_eaea ._bddg ;};switch _aafff :=_acde .(type ){case componentRenderer :_aeadd ,_daag :=_edcf .(Drawable );if !_daag {_de .Log .Error ("\u0043\u006f\u006d\u0070\u006f\u006ee\u006e\u0074\u0020\u0028\u0025\u0054\u0029\u0020\u0069\u0073\u0020\u006e\u006ft\u0020\u0061\u0020\u0064\u0072\u0061\u0077a\u0062\u006c\u0065\u002e",_edcf );
return _aafgd ;};return _aafff .Draw (_aeadd );case *Division :switch _agbag :=_edcf .(type ){case *Background :_aafff .SetBackground (_agbag );case VectorDrawable :return _aafff .Add (_agbag );};case *TableCell :_dgeca ,_ebcg :=_edcf .(VectorDrawable );
if !_ebcg {_de .Log .Error ("C\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u0028\u0025\u0054\u0029\u0020\u0069\u0073\u0020\u006eo\u0074\u0020\u0061\u0020\u0076\u0065\u0063\u0074\u006f\u0072 d\u0072\u0061\u0077a\u0062l\u0065\u002e",_edcf );return _aafgd ;
};return _aafff .SetContent (_dgeca );case *StyledParagraph :_dafc ,_dedd :=_edcf .(*TextChunk );if !_dedd {_de .Log .Error ("C\u006f\u006d\u0070\u006f\u006e\u0065n\u0074\u0020\u0028\u0025\u0054\u0029 \u0069\u0073\u0020\u006e\u006f\u0074\u0020a\u0020\u0074\u0065\u0078\u0074\u0020\u0063\u0068\u0075\u006ek\u002e",_edcf );
return _aafgd ;};_aafff .appendChunk (_dafc );case *Chapter :switch _dbgg :=_edcf .(type ){case *Chapter :return nil ;case *Paragraph :if _gdbcc ._fcdbfb .Name .Local =="\u0063h\u0061p\u0074\u0065\u0072\u002d\u0068\u0065\u0061\u0064\u0069\u006e\u0067"{return nil ;
};return _aafff .Add (_dbgg );case Drawable :return _aafff .Add (_dbgg );};};return nil ;};

// SetFillOpacity sets the fill opacity.
func (_ffce *CurvePolygon )SetFillOpacity (opacity float64 ){_ffce ._bfeg =opacity };

// SetForms adds an Acroform to a PDF file.  Sets the specified form for writing.
func (_fbbfc *Creator )SetForms (form *_ed .PdfAcroForm )error {_fbbfc ._cadd =form ;return nil };

// Draw draws the drawable d on the block.
// Note that the drawable must not wrap, i.e. only return one block. Otherwise an error is returned.
func (_abf *Block )Draw (d Drawable )error {_cfa :=DrawContext {};_cfa .Width =_abf ._beg ;_cfa .Height =_abf ._fc ;_cfa .PageWidth =_abf ._beg ;_cfa .PageHeight =_abf ._fc ;_cfa .X =0;_cfa .Y =0;_cdc ,_ ,_ebga :=d .GeneratePageBlocks (_cfa );if _ebga !=nil {return _ebga ;
};if len (_cdc )!=1{return _c .New ("\u0074\u006f\u006f\u0020ma\u006e\u0079\u0020\u006f\u0075\u0074\u0070\u0075\u0074\u0020\u0062\u006c\u006f\u0063k\u0073");};for _ ,_bbca :=range _cdc {if _aca :=_abf .mergeBlocks (_bbca );_aca !=nil {return _aca ;};};
return nil ;};func _ddecb (_fgee ,_bbgf ,_dgeg ,_eacb float64 )*Line {return &Line {_ecfe :_fgee ,_ecec :_bbgf ,_bfba :_dgeg ,_gbbeb :_eacb ,_ecge :ColorBlack ,_edaf :1.0,_cdbc :1.0,_ffaa :[]int64 {1,1},_efef :PositionAbsolute };};

// SetShowNumbering sets a flag to indicate whether or not to show chapter numbers as part of title.
func (_dagb *Chapter )SetShowNumbering (show bool ){_dagb ._gae =show ;_dagb ._cff .SetText (_dagb .headingText ());};

// Link returns link information for this line.
func (_dgcgb *TOCLine )Link ()(_dceed int64 ,_fdecb ,_gfge float64 ){return _dgcgb ._cfcb ,_dgcgb ._dfcb ,_dgcgb ._bdgff ;};

// SetMargins sets the margins of the paragraph.
func (_cabf *List )SetMargins (left ,right ,top ,bottom float64 ){_cabf ._aaag .Left =left ;_cabf ._aaag .Right =right ;_cabf ._aaag .Top =top ;_cabf ._aaag .Bottom =bottom ;};

// Height returns Image's document height.
func (_aacd *Image )Height ()float64 {return _aacd ._fedbd };func (_dbee *templateProcessor )parseFitModeAttr (_caddf ,_cebec string )FitMode {_de .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0066\u0069\u0074\u0020\u006do\u0064\u0065\u0020\u0061\u0074\u0074r\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c \u0025\u0073\u0029\u002e",_caddf ,_cebec );
_bcfbd :=map[string ]FitMode {"\u006e\u006f\u006e\u0065":FitModeNone ,"\u0066\u0069\u006c\u006c\u002d\u0077\u0069\u0064\u0074\u0068":FitModeFillWidth }[_cebec ];return _bcfbd ;};

// FrontpageFunctionArgs holds the input arguments to a front page drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FrontpageFunctionArgs struct{PageNum int ;TotalPages int ;};

// NewPageBreak create a new page break.
func (_aedb *Creator )NewPageBreak ()*PageBreak {return _afbg ()};

// Height returns the height of the line.
func (_agfa *Line )Height ()float64 {_cbge :=_agfa ._cdbc ;if _agfa ._ecfe ==_agfa ._bfba {_cbge /=2;};return _gd .Abs (_agfa ._gbbeb -_agfa ._ecec )+_cbge ;};

// SetHeight sets the height of the rectangle.
func (_ceadf *Rectangle )SetHeight (height float64 ){_ceadf ._agadf =height };

// NewChapter creates a new chapter with the specified title as the heading.
func (_efea *Creator )NewChapter (title string )*Chapter {_efea ._bbcd ++;_efca :=_efea .NewTextStyle ();_efca .FontSize =16;return _bdba (nil ,_efea ._cgec ,_efea ._cac ,title ,_efea ._bbcd ,_efca );};

// ColorPoint is a pair of Color and a relative point where the color
// would be rendered.
type ColorPoint struct{_gaed Color ;_adcc float64 ;};

// TableCell defines a table cell which can contain a Drawable as content.
type TableCell struct{_ebgbd Color ;_eacgd _bc .LineStyle ;_afcc CellBorderStyle ;_ggab Color ;_cfdac float64 ;_ccbfd CellBorderStyle ;_ebdf Color ;_ecgbf float64 ;_gdbg CellBorderStyle ;_efgfc Color ;_efbec float64 ;_acgb CellBorderStyle ;_bgdb Color ;
_aedea float64 ;_dgad ,_abdgb int ;_efdb int ;_bfeec int ;_dafd VectorDrawable ;_eedf CellHorizontalAlignment ;_dbbf CellVerticalAlignment ;_cgfb float64 ;_dedc *Table ;};

// NewChart creates a new creator drawable based on the provided
// unichart chart component.
func NewChart (chart _b .ChartRenderable )*Chart {return _ddea (chart )};

// Level returns the indentation level of the TOC line.
func (_becc *TOCLine )Level ()uint {return _becc ._ggbcf };func (_adfcd *StyledParagraph )getTextHeight ()float64 {var _gccf float64 ;for _ ,_ebad :=range _adfcd ._dfdf {_bbfffe :=_ebad .Style .FontSize *_adfcd ._gcba ;if _bbfffe > _gccf {_gccf =_bbfffe ;
};};return _gccf ;};

// AddressHeadingStyle returns the style properties used to render the
// heading of the invoice address sections.
func (_faed *Invoice )AddressHeadingStyle ()TextStyle {return _faed ._gdfc };

// Width returns the width of the Paragraph.
func (_ecdcf *StyledParagraph )Width ()float64 {if _ecdcf ._ebeda &&int (_ecdcf ._egeg )> 0{return _ecdcf ._egeg ;};return _ecdcf .getTextWidth ()/1000.0;};

// Insert adds a new text chunk at the specified position in the paragraph.
func (_edbfd *StyledParagraph )Insert (index uint ,text string )*TextChunk {_adbcd :=uint (len (_edbfd ._dfdf ));if index > _adbcd {index =_adbcd ;};_fdde :=NewTextChunk (text ,_edbfd ._fega );_edbfd ._dfdf =append (_edbfd ._dfdf [:index ],append ([]*TextChunk {_fdde },_edbfd ._dfdf [index :]...)...);
_edbfd .wrapText ();return _fdde ;};

// Width is not used as the division component is designed to fill all the
// available space, depending on the context. Returns 0.
func (_fgbfg *Division )Width ()float64 {return 0};

// The Image type is used to draw an image onto PDF.
type Image struct{_gecf *_ed .XObjectImage ;_cce *_ed .Image ;_fbfb float64 ;_deac ,_fedbd float64 ;_ecef ,_aceg float64 ;_aeae Positioning ;_ecfa HorizontalAlignment ;_gcdg float64 ;_fgff float64 ;_adba float64 ;_baaa Margins ;_fefa ,_fgda float64 ;_agdcd _gg .StreamEncoder ;
_fdgd FitMode ;};

// SetLineStyle sets the style for all the line components: number, title,
// separator, page. The style is applied only for new lines added to the
// TOC component.
func (_baaefb *TOC )SetLineStyle (style TextStyle ){_baaefb .SetLineNumberStyle (style );_baaefb .SetLineTitleStyle (style );_baaefb .SetLineSeparatorStyle (style );_baaefb .SetLinePageStyle (style );};

// MoveX moves the drawing context to absolute position x.
func (_ggba *Creator )MoveX (x float64 ){_ggba ._fafg .X =x };

// SetColorLeft sets border color for left.
func (_cba *border )SetColorLeft (col Color ){_cba ._cbb =col };func _edbb (_bcfc [][]_bc .CubicBezierCurve )*CurvePolygon {return &CurvePolygon {_fdfe :&_bc .CurvePolygon {Rings :_bcfc },_bfeg :1.0,_cdgc :1.0};};

// Append adds a new text chunk to the paragraph.
func (_gafae *StyledParagraph )Append (text string )*TextChunk {_ebbe :=NewTextChunk (text ,_gafae ._fega );return _gafae .appendChunk (_ebbe );};

// SetExtends specifies whether ot extend the shading beyond the starting and ending points.
//
// Text extends is set to `[]bool{false, false}` by default.
func (_aafb *LinearShading )SetExtends (start bool ,end bool ){_aafb ._cecc .SetExtends (start ,end )};

// SetTerms sets the terms and conditions section of the invoice.
func (_eagaa *Invoice )SetTerms (title ,content string ){_eagaa ._dgcce =[2]string {title ,content }};func _ccfb (_cefb Color )_ed .PdfColor {if _cefb ==nil {_cefb =ColorBlack ;};switch _ddgb :=_cefb .(type ){case cmykColor :return _ed .NewPdfColorDeviceCMYK (_ddgb ._bca ,_ddgb ._cdgdd ,_ddgb ._cebb ,_ddgb ._dfbe );
case *LinearShading :return _ed .NewPdfColorPatternType2 ();case *RadialShading :return _ed .NewPdfColorPatternType3 ();};return _ed .NewPdfColorDeviceRGB (_cefb .ToRGB ());};

// SetSubtotal sets the subtotal of the invoice.
func (_abbaf *Invoice )SetSubtotal (value string ){_abbaf ._egfeg [1].Value =value };func _cgac (_ebaaa *Block ,_bcdeb *Paragraph ,_cfcg DrawContext )(DrawContext ,error ){_dgaa :=1;_cgage :=_gg .PdfObjectName ("\u0046\u006f\u006e\u0074"+_df .Itoa (_dgaa ));
for _ebaaa ._bf .HasFontByName (_cgage ){_dgaa ++;_cgage =_gg .PdfObjectName ("\u0046\u006f\u006e\u0074"+_df .Itoa (_dgaa ));};_agdd :=_ebaaa ._bf .SetFontByName (_cgage ,_bcdeb ._agae .ToPdfObject ());if _agdd !=nil {return _cfcg ,_agdd ;};_bcdeb .wrapText ();
_feda :=_da .NewContentCreator ();_feda .Add_q ();_adag :=_cfcg .PageHeight -_cfcg .Y -_bcdeb ._aee *_bcdeb ._ccef ;_feda .Translate (_cfcg .X ,_adag );if _bcdeb ._efcgfb !=0{_feda .RotateDeg (_bcdeb ._efcgfb );};_cbce :=_ccfb (_bcdeb ._cece );_agdd =_abfb (_ebaaa ,_cbce ,_bcdeb ._cece ,func ()Rectangle {return Rectangle {_eadb :_cfcg .X ,_accbb :_adag ,_egbf :_bcdeb .getMaxLineWidth ()/1000.0,_agadf :_bcdeb .Height ()};
});if _agdd !=nil {return _cfcg ,_agdd ;};_feda .Add_BT ().SetNonStrokingColor (_cbce ).Add_Tf (_cgage ,_bcdeb ._aee ).Add_TL (_bcdeb ._aee *_bcdeb ._ccef );for _ebeb ,_bbdgc :=range _bcdeb ._babaa {if _ebeb !=0{_feda .Add_Tstar ();};_cdfd :=[]rune (_bbdgc );
_efcf :=0.0;_dgcg :=0;for _ffaae ,_dgggc :=range _cdfd {if _dgggc ==' '{_dgcg ++;continue ;};if _dgggc =='\u000A'{continue ;};_fgca ,_eccg :=_bcdeb ._agae .GetRuneMetrics (_dgggc );if !_eccg {_de .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006e\u0065\u0020\u0069=\u0025\u0064\u0020\u0072\u0075\u006e\u0065=\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0069n\u0020\u0066\u006f\u006e\u0074\u0020\u0025\u0073\u0020\u0025\u0073",_ffaae ,_dgggc ,_dgggc ,_bcdeb ._agae .BaseFont (),_bcdeb ._agae .Subtype ());
return _cfcg ,_c .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");};_efcf +=_bcdeb ._aee *_fgca .Wx ;};var _fffaf []_gg .PdfObject ;_fcae ,_eabccc :=_bcdeb ._agae .GetRuneMetrics (' ');
if !_eabccc {return _cfcg ,_c .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};_agaa :=_fcae .Wx ;switch _bcdeb ._ccgc {case TextAlignmentJustify :if _dgcg > 0&&_ebeb < len (_bcdeb ._babaa )-1{_agaa =(_bcdeb ._gbgcd *1000.0-_efcf )/float64 (_dgcg )/_bcdeb ._aee ;
};case TextAlignmentCenter :_edgb :=_efcf +float64 (_dgcg )*_agaa *_bcdeb ._aee ;_fgdgg :=(_bcdeb ._gbgcd *1000.0-_edgb )/2/_bcdeb ._aee ;_fffaf =append (_fffaf ,_gg .MakeFloat (-_fgdgg ));case TextAlignmentRight :_fddb :=_efcf +float64 (_dgcg )*_agaa *_bcdeb ._aee ;
_cbe :=(_bcdeb ._gbgcd *1000.0-_fddb )/_bcdeb ._aee ;_fffaf =append (_fffaf ,_gg .MakeFloat (-_cbe ));};_gedb :=_bcdeb ._agae .Encoder ();var _cfacg []byte ;for _ ,_gffde :=range _cdfd {if _gffde =='\u000A'{continue ;};if _gffde ==' '{if len (_cfacg )> 0{_fffaf =append (_fffaf ,_gg .MakeStringFromBytes (_cfacg ));
_cfacg =nil ;};_fffaf =append (_fffaf ,_gg .MakeFloat (-_agaa ));}else {if _ ,_fafc :=_gedb .RuneToCharcode (_gffde );!_fafc {_agdd =UnsupportedRuneError {Message :_fe .Sprintf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_gffde ,_gffde ),Rune :_gffde };
_cfcg ._ddeg =append (_cfcg ._ddeg ,_agdd );_de .Log .Debug (_agdd .Error ());if _cfcg ._dgccf <=0{continue ;};_gffde =_cfcg ._dgccf ;};_cfacg =append (_cfacg ,_gedb .Encode (string (_gffde ))...);};};if len (_cfacg )> 0{_fffaf =append (_fffaf ,_gg .MakeStringFromBytes (_cfacg ));
};_feda .Add_TJ (_fffaf ...);};_feda .Add_ET ();_feda .Add_Q ();_acbd :=_feda .Operations ();_acbd .WrapIfNeeded ();_ebaaa .addContents (_acbd );if _bcdeb ._gbfg .IsRelative (){_fcef :=_bcdeb .Height ();_cfcg .Y +=_fcef ;_cfcg .Height -=_fcef ;if _cfcg .Inline {_cfcg .X +=_bcdeb .Width ()+_bcdeb ._bcbe .Right ;
};};return _cfcg ,nil ;};func _bbce (_dcbf ,_cfbge ,_cbabb TextChunk ,_ecfga uint ,_dgaab TextStyle )*TOCLine {_gaeee :=_fecf (_dgaab );_gaeee .SetEnableWrap (true );_gaeee .SetTextAlignment (TextAlignmentLeft );_gaeee .SetMargins (0,0,2,2);_ebgdf :=&TOCLine {_ddaf :_gaeee ,Number :_dcbf ,Title :_cfbge ,Page :_cbabb ,Separator :TextChunk {Text :"\u002e",Style :_dgaab },_egee :0,_ggbcf :_ecfga ,_gfggfd :10,_gdace :PositionRelative };
_gaeee ._bgac .Left =_ebgdf ._egee +float64 (_ebgdf ._ggbcf -1)*_ebgdf ._gfggfd ;_gaeee ._dggcf =_ebgdf .prepareParagraph ;return _ebgdf ;};

// ConvertToBinary converts current image data into binary (Bi-level image) format.
// If provided image is RGB or GrayScale the function converts it into binary image
// using histogram auto threshold method.
func (_deca *Image )ConvertToBinary ()error {return _deca ._cce .ConvertToBinary ()};

// SetLevelOffset sets the amount of space an indentation level occupies.
func (_acccf *TOCLine )SetLevelOffset (levelOffset float64 ){_acccf ._gfggfd =levelOffset ;_acccf ._ddaf ._bgac .Left =_acccf ._egee +float64 (_acccf ._ggbcf -1)*_acccf ._gfggfd ;};

// Positioning returns the type of positioning the line is set to use.
func (_adcg *Line )Positioning ()Positioning {return _adcg ._efef };

// SetHorizontalAlignment sets the horizontal alignment of the image.
func (_cddg *Image )SetHorizontalAlignment (alignment HorizontalAlignment ){_cddg ._ecfa =alignment };func (_aadb *Invoice )generateNoteBlocks (_acba DrawContext )([]*Block ,DrawContext ,error ){_cdcd :=_daa ();_dgdf :=append ([][2]string {_aadb ._gbf ,_aadb ._dgcce },_aadb ._gddb ...);
for _ ,_acfe :=range _dgdf {if _acfe [1]!=""{_abbb :=_aadb .drawSection (_acfe [0],_acfe [1]);for _ ,_cdbd :=range _abbb {_cdcd .Add (_cdbd );};_edfa :=_fecf (_aadb ._geb );_edfa .SetMargins (0,0,10,0);_cdcd .Add (_edfa );};};return _cdcd .GeneratePageBlocks (_acba );
};

// SetBorderWidth sets the border width of the ellipse.
func (_dbbb *Ellipse )SetBorderWidth (bw float64 ){_dbbb ._fffa =bw };

// Number returns the invoice number description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_bcae *Invoice )Number ()(*InvoiceCell ,*InvoiceCell ){return _bcae ._gbgcb [0],_bcae ._gbgcb [1]};func _daa ()*Division {return &Division {_ceab :true }};func (_ggeba *Table )updateRowHeights (_agcc float64 ){for _ ,_bdec :=range _ggeba ._ddbf {_gefbd :=_bdec .width (_ggeba ._gcfd ,_agcc );
_fcefe :=_ggeba ._accga [_bdec ._dgad +_bdec ._efdb -2];if _gggf :=_bdec .height (_gefbd );_gggf > _fcefe {_adfe :=_gggf /float64 (_bdec ._efdb );for _eeabd :=1;_eeabd <=_bdec ._efdb ;_eeabd ++{if _adfe > _ggeba ._accga [_bdec ._dgad +_eeabd -2]{_ggeba ._accga [_bdec ._dgad +_eeabd -2]=_adfe ;
};};};};};func _ccbb (_gfbd *Creator ,_ddcc _e .Reader ,_aeed interface{},_eagfd *TemplateOptions ,_cbgd componentRenderer )error {if _gfbd ==nil {_de .Log .Error ("\u0043\u0072\u0065a\u0074\u006f\u0072\u0020i\u006e\u0073\u0074\u0061\u006e\u0063\u0065 \u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0069\u006c\u002e");
return _ecggc ;};_eedb :=_ab .NewBuffer (nil );if _ ,_abbae :=_e .Copy (_eedb ,_ddcc );_abbae !=nil {return _abbae ;};_aaea :=_g .FuncMap {"\u0064\u0069\u0063\u0074":_cfdge };if _eagfd !=nil &&_eagfd .HelperFuncMap !=nil {for _gbdf ,_defa :=range _eagfd .HelperFuncMap {if _ ,_ebbd :=_aaea [_gbdf ];
_ebbd {_de .Log .Debug ("\u0043\u0061\u006e\u006e\u006f\u0074 \u006f\u0076\u0065r\u0072\u0069\u0064e\u0020\u0062\u0075\u0069\u006c\u0074\u002d\u0069\u006e\u0020`\u0025\u0073\u0060\u0020\u0068el\u0070\u0065\u0072\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_gbdf );
continue ;};_aaea [_gbdf ]=_defa ;};};_gbgfe ,_cabab :=_g .New ("").Funcs (_aaea ).Parse (_eedb .String ());if _cabab !=nil {return _cabab ;};_eedb .Reset ();if _fcea :=_gbgfe .Execute (_eedb ,_aeed );_fcea !=nil {return _fcea ;};return _fbbaf (_gfbd ,_eedb .Bytes (),_eagfd ,_cbgd ).run ();
};

// FitMode returns the fit mode of the line.
func (_fdfc *Line )FitMode ()FitMode {return _fdfc ._facce };

// SetIndent sets the left offset of the list when nested into another list.
func (_gaec *List )SetIndent (indent float64 ){_gaec ._decc =indent ;_gaec ._gcfc =false };func _cggg (_ffcc *_fa .GraphicSVG )(*GraphicSVG ,error ){return &GraphicSVG {_ebgg :_ffcc ,_fgdgc :PositionRelative ,_eaeg :Margins {Top :10,Bottom :10}},nil ;};


// GetMargins returns the Image's margins: left, right, top, bottom.
func (_cgag *Image )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _cgag ._baaa .Left ,_cgag ._baaa .Right ,_cgag ._baaa .Top ,_cgag ._baaa .Bottom ;};

// AddLine appends a new line to the invoice line items table.
func (_ebcec *Invoice )AddLine (values ...string )[]*InvoiceCell {_accgg :=len (_ebcec ._deabd );var _febg []*InvoiceCell ;for _dcfe ,_daef :=range values {_cbca :=_ebcec .newCell (_daef ,_ebcec ._caaef );if _dcfe < _accgg {_cbca .Alignment =_ebcec ._deabd [_dcfe ].Alignment ;
};_febg =append (_febg ,_cbca );};_ebcec ._caca =append (_ebcec ._caca ,_febg );return _febg ;};

// TextOverflow determines the behavior of paragraph text which does
// not fit in the available space.
type TextOverflow int ;

// SellerAddress returns the seller address used in the invoice template.
func (_cgcf *Invoice )SellerAddress ()*InvoiceAddress {return _cgcf ._ecefd };

// NewPage adds a new Page to the Creator and sets as the active Page.
func (_abab *Creator )NewPage ()*_ed .PdfPage {_eeae :=_abab .newPage ();_abab ._fae =append (_abab ._fae ,_eeae );_abab ._fafg .Page ++;return _eeae ;};

// Rectangle defines a rectangle with upper left corner at (x,y) and a specified width and height.  The rectangle
// can have a colored fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Rectangle struct{_eadb float64 ;_accbb float64 ;_egbf float64 ;_agadf float64 ;_dded Positioning ;_bbaf Color ;_eeed float64 ;_dca Color ;_gaffd float64 ;_bedf float64 ;_eaad float64 ;_dbegg float64 ;_eeffc float64 ;_cdad float64 ;_efbdg Margins ;
_cegf FitMode ;};

// Height returns the height of the Paragraph. The height is calculated based on the input text and how it is wrapped
// within the container. Does not include Margins.
func (_edeba *StyledParagraph )Height ()float64 {_edeba .wrapText ();var _egfec float64 ;for _ ,_gede :=range _edeba ._fgbg {var _fffaa float64 ;for _ ,_gebg :=range _gede {_ceaga :=_edeba ._gcba *_gebg .Style .FontSize ;if _ceaga > _fffaa {_fffaa =_ceaga ;
};};_egfec +=_fffaa ;};return _egfec ;};func _fagb (_eefdg *_ed .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,0),Font :_eefdg ,FontSize :10,OutlineSize :1,HorizontalScaling :DefaultHorizontalScaling ,UnderlineStyle :TextDecorationLineStyle {Offset :1,Thickness :1}};
};

// GeneratePageBlocks generates the table page blocks. Multiple blocks are
// generated if the contents wrap over multiple pages.
// Implements the Drawable interface.
func (_bfcf *Table )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dfab :=_bfcf ;if _bfcf ._egbga {_dfab =_bfcf .clone ();};return _bcea (_dfab ,ctx );};

// SetBorderOpacity sets the border opacity of the rectangle.
func (_eeca *Rectangle )SetBorderOpacity (opacity float64 ){_eeca ._bedf =opacity };

// SetSellerAddress sets the seller address of the invoice.
func (_fabe *Invoice )SetSellerAddress (address *InvoiceAddress ){_fabe ._ecefd =address };func (_effb *Invoice )drawAddress (_adda *InvoiceAddress )[]*StyledParagraph {var _beea []*StyledParagraph ;if _adda .Heading !=""{_agg :=_fecf (_effb ._dcd );_agg .SetMargins (0,0,0,7);
_agg .Append (_adda .Heading );_beea =append (_beea ,_agg );};_bbed :=_fecf (_effb ._abee );_bbed .SetLineHeight (1.2);_egda :=_adda .Separator ;if _egda ==""{_egda =_effb ._gfcdb ;};_gdbd :=_adda .City ;if _adda .State !=""{if _gdbd !=""{_gdbd +=_egda ;
};_gdbd +=_adda .State ;};if _adda .Zip !=""{if _gdbd !=""{_gdbd +=_egda ;};_gdbd +=_adda .Zip ;};if _adda .Name !=""{_bbed .Append (_adda .Name +"\u000a");};if _adda .Street !=""{_bbed .Append (_adda .Street +"\u000a");};if _adda .Street2 !=""{_bbed .Append (_adda .Street2 +"\u000a");
};if _gdbd !=""{_bbed .Append (_gdbd +"\u000a");};if _adda .Country !=""{_bbed .Append (_adda .Country +"\u000a");};_bffe :=_fecf (_effb ._abee );_bffe .SetLineHeight (1.2);_bffe .SetMargins (0,0,7,0);if _adda .Phone !=""{_bffe .Append (_adda .fmtLine (_adda .Phone ,"\u0050h\u006f\u006e\u0065\u003a\u0020",_adda .HidePhoneLabel ));
};if _adda .Email !=""{_bffe .Append (_adda .fmtLine (_adda .Email ,"\u0045m\u0061\u0069\u006c\u003a\u0020",_adda .HideEmailLabel ));};_beea =append (_beea ,_bbed ,_bffe );return _beea ;};func (_efe *Block )transform (_dfe _ebg .Matrix ){_ecb :=_da .NewContentCreator ().Add_cm (_dfe [0],_dfe [1],_dfe [3],_dfe [4],_dfe [6],_dfe [7]).Operations ();
*_efe ._eg =append (*_ecb ,*_efe ._eg ...);_efe ._eg .WrapIfNeeded ();};

// SetBorderRadius sets the radius of the background corners.
func (_be *Background )SetBorderRadius (topLeft ,topRight ,bottomLeft ,bottomRight float64 ){_be .BorderRadiusTopLeft =topLeft ;_be .BorderRadiusTopRight =topRight ;_be .BorderRadiusBottomLeft =bottomLeft ;_be .BorderRadiusBottomRight =bottomRight ;};func (_gcfbf *Invoice )newCell (_befd string ,_cccc InvoiceCellProps )*InvoiceCell {return &InvoiceCell {_cccc ,_befd };
};

// NewLine creates a new line between (x1, y1) to (x2, y2),
// using default attributes.
// NOTE: In relative positioning mode, `x1` and `y1` are calculated using the
// current context and `x2`, `y2` are used only to calculate the position of
// the second point in relation to the first one (used just as a measurement
// of size). Furthermore, when the fit mode is set to fill the context width,
// `x2` is set to the right edge coordinate of the context.
func (_edag *Creator )NewLine (x1 ,y1 ,x2 ,y2 float64 )*Line {return _ddecb (x1 ,y1 ,x2 ,y2 )};

// SetLineHeight sets the line height (1.0 default).
func (_cefd *StyledParagraph )SetLineHeight (lineheight float64 ){_cefd ._gcba =lineheight };

// NewImageFromData creates an Image from image data.
func (_cbbad *Creator )NewImageFromData (data []byte )(*Image ,error ){return _ebgd (data )};

// SetBorderOpacity sets the border opacity.
func (_caea *Polygon )SetBorderOpacity (opacity float64 ){_caea ._daaf =opacity };

// SetStyle sets the style of the line (solid or dashed).
func (_ccgb *Line )SetStyle (style _bc .LineStyle ){_ccgb ._dcge =style };

// SetHeight sets the Image's document height to specified h.
func (_ebea *Image )SetHeight (h float64 ){_ebea ._fedbd =h };func (_ebdcb *templateProcessor )parseTextRenderingModeAttr (_eaaf ,_ffga string )TextRenderingMode {_de .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0074\u0065\u0078\u0074\u0020\u0072\u0065\u006e\u0064\u0065r\u0069\u006e\u0067\u0020\u006d\u006f\u0064e\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a \u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_eaaf ,_ffga );
_gacge :=map[string ]TextRenderingMode {"\u0066\u0069\u006c\u006c":TextRenderingModeFill ,"\u0073\u0074\u0072\u006f\u006b\u0065":TextRenderingModeStroke ,"f\u0069\u006c\u006c\u002d\u0073\u0074\u0072\u006f\u006b\u0065":TextRenderingModeFillStroke ,"\u0069n\u0076\u0069\u0073\u0069\u0062\u006ce":TextRenderingModeInvisible ,"\u0066i\u006c\u006c\u002d\u0063\u006c\u0069p":TextRenderingModeFillClip ,"s\u0074\u0072\u006f\u006b\u0065\u002d\u0063\u006c\u0069\u0070":TextRenderingModeStrokeClip ,"\u0066\u0069l\u006c\u002d\u0073t\u0072\u006f\u006b\u0065\u002d\u0063\u006c\u0069\u0070":TextRenderingModeFillStrokeClip ,"\u0063\u006c\u0069\u0070":TextRenderingModeClip }[_ffga ];
return _gacge ;};

// LevelOffset returns the amount of space an indentation level occupies.
func (_baced *TOCLine )LevelOffset ()float64 {return _baced ._gfggfd };func (_feacb *templateProcessor )loadImageFromSrc (_bfade string )(*Image ,error ){if _bfade ==""{_de .Log .Error ("\u0049\u006d\u0061\u0067\u0065\u0020\u0060\u0073\u0072\u0063\u0060\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0063\u0061n\u006e\u006f\u0074\u0020\u0062e\u0020\u0065m\u0070\u0074\u0079\u002e");
return nil ,_fdcb ;};_aedc :=_ae .Split (_bfade ,"\u002c");for _ ,_cdae :=range _aedc {_cdae =_ae .TrimSpace (_cdae );if _cdae ==""{continue ;};_bfacf ,_egca :=_feacb ._afgab .ImageMap [_cdae ];if _egca {return _acgaf (_bfacf );};if _ddfd :=_feacb .parseAttrPropList (_cdae );
len (_ddfd )> 0{if _fabfg ,_bfcad :=_ddfd ["\u0070\u0061\u0074\u0068"];_bfcad {if _bfgcc ,_cafab :=_adeg (_fabfg );_cafab !=nil {_de .Log .Debug ("\u0043\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020l\u006f\u0061\u0064\u0020\u0069\u006d\u0061g\u0065\u0020\u0060\u0025\u0073\u0060\u003a\u0020\u0025\u0076\u002e",_fabfg ,_cafab );
}else {return _bfgcc ,nil ;};};};};_de .Log .Error ("\u0043\u006ful\u0064\u0020\u006eo\u0074\u0020\u0066\u0069nd \u0069ma\u0067\u0065\u0020\u0072\u0065\u0073\u006fur\u0063\u0065\u003a\u0020\u0060\u0025\u0073`\u002e",_bfade );return nil ,_fdcb ;};

// AddPatternResource adds pattern dictionary inside the resources dictionary.
func (_dbbg *LinearShading )AddPatternResource (block *Block )(_ffbe _gg .PdfObjectName ,_becda error ){_cdfb :=1;_ceddf :=_gg .PdfObjectName ("\u0050"+_df .Itoa (_cdfb ));for block ._bf .HasPatternByName (_ceddf ){_cdfb ++;_ceddf =_gg .PdfObjectName ("\u0050"+_df .Itoa (_cdfb ));
};if _ffdc :=block ._bf .SetPatternByName (_ceddf ,_dbbg .ToPdfShadingPattern ().ToPdfObject ());_ffdc !=nil {return "",_ffdc ;};return _ceddf ,nil ;};func _ddea (_fbe _b .ChartRenderable )*Chart {return &Chart {_caa :_fbe ,_cfacf :PositionRelative ,_bgff :Margins {Top :10,Bottom :10}};
};

// SetFillColor sets the fill color.
func (_faga *PolyBezierCurve )SetFillColor (color Color ){_faga ._ebebe =color ;_faga ._adac .FillColor =_ccfb (color );};func (_gbcg *templateProcessor )parseCellVerticalAlignmentAttr (_gbbca ,_aaacd string )CellVerticalAlignment {_de .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0063\u0065\u006c\u006c\u0020\u0076\u0065r\u0074\u0069\u0063\u0061\u006c\u0020\u0061\u006c\u0069\u0067\u006e\u006d\u0065n\u0074\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a (\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_gbbca ,_aaacd );
_faada :=map[string ]CellVerticalAlignment {"\u0074\u006f\u0070":CellVerticalAlignmentTop ,"\u006d\u0069\u0064\u0064\u006c\u0065":CellVerticalAlignmentMiddle ,"\u0062\u006f\u0074\u0074\u006f\u006d":CellVerticalAlignmentBottom }[_aaacd ];return _faada ;
};

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_gcea *Paragraph )SetTextAlignment (align TextAlignment ){_gcea ._ccgc =align };func (_dedba *FilledCurve )draw (_febaa *Block ,_fage string )([]byte ,*_ed .PdfRectangle ,error ){_fdfg :=_bc .NewCubicBezierPath ();for _ ,_fecg :=range _dedba ._bgegb {_fdfg =_fdfg .AppendCurve (_fecg );
};creator :=_da .NewContentCreator ();creator .Add_q ();if _dedba .FillEnabled &&_dedba ._dec !=nil {_cbbg :=_ccfb (_dedba ._dec );_aacf :=_abfb (_febaa ,_cbbg ,_dedba ._dec ,func ()Rectangle {_bacd :=_bc .NewCubicBezierPath ();for _ ,_ffbd :=range _dedba ._bgegb {_bacd =_bacd .AppendCurve (_ffbd );
};_agced :=_bacd .GetBoundingBox ();if _dedba .BorderEnabled {_agced .Height +=_dedba .BorderWidth ;_agced .Width +=_dedba .BorderWidth ;_agced .X -=_dedba .BorderWidth /2;_agced .Y -=_dedba .BorderWidth /2;};return Rectangle {_eadb :_agced .X ,_accbb :_agced .Y ,_egbf :_agced .Width ,_agadf :_agced .Height };
});if _aacf !=nil {return nil ,nil ,_aacf ;};creator .SetNonStrokingColor (_cbbg );};if _dedba .BorderEnabled {if _dedba ._ceff !=nil {creator .SetStrokingColor (_ccfb (_dedba ._ceff ));};creator .Add_w (_dedba .BorderWidth );};if len (_fage )> 1{creator .Add_gs (_gg .PdfObjectName (_fage ));
};_bc .DrawBezierPathWithCreator (_fdfg ,creator );creator .Add_h ();if _dedba .FillEnabled &&_dedba .BorderEnabled {creator .Add_B ();}else if _dedba .FillEnabled {creator .Add_f ();}else if _dedba .BorderEnabled {creator .Add_S ();};creator .Add_Q ();
_fcag :=_fdfg .GetBoundingBox ();if _dedba .BorderEnabled {_fcag .Height +=_dedba .BorderWidth ;_fcag .Width +=_dedba .BorderWidth ;_fcag .X -=_dedba .BorderWidth /2;_fcag .Y -=_dedba .BorderWidth /2;};_bfgda :=&_ed .PdfRectangle {};_bfgda .Llx =_fcag .X ;
_bfgda .Lly =_fcag .Y ;_bfgda .Urx =_fcag .X +_fcag .Width ;_bfgda .Ury =_fcag .Y +_fcag .Height ;return creator .Bytes (),_bfgda ,nil ;};

// SetPos sets the Table's positioning to absolute mode and specifies the upper-left corner
// coordinates as (x,y).
// Note that this is only sensible to use when the table does not wrap over multiple pages.
// TODO: Should be able to set width too (not just based on context/relative positioning mode).
func (_befce *Table )SetPos (x ,y float64 ){_befce ._fbcdg =PositionAbsolute ;_befce ._bgacf =x ;_befce ._gdcc =y ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_egeba *TOC )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dgce :=ctx ;_dcbcc ,ctx ,_ebedag :=_egeba ._daedg .GeneratePageBlocks (ctx );if _ebedag !=nil {return _dcbcc ,ctx ,_ebedag ;};for _ ,_ddgdf :=range _egeba ._gacd {_cgfc :=_ddgdf ._cfcb ;
if !_egeba ._afec {_ddgdf ._cfcb =0;};_cdab ,_abfcdf ,_dbdge :=_ddgdf .GeneratePageBlocks (ctx );_ddgdf ._cfcb =_cgfc ;if _dbdge !=nil {return _dcbcc ,ctx ,_dbdge ;};if len (_cdab )< 1{continue ;};_dcbcc [len (_dcbcc )-1].mergeBlocks (_cdab [0]);_dcbcc =append (_dcbcc ,_cdab [1:]...);
ctx =_abfcdf ;};if _egeba ._fadfe .IsRelative (){ctx .X =_dgce .X ;};if _egeba ._fadfe .IsAbsolute (){return _dcbcc ,_dgce ,nil ;};return _dcbcc ,ctx ,nil ;};func (_bafb *templateProcessor )parseChart (_fbda *templateNode )(interface{},error ){var _bfebf string ;
for _ ,_fgba :=range _fbda ._fcdbfb .Attr {_gcdge :=_fgba .Value ;switch _fbcg :=_fgba .Name .Local ;_fbcg {case "\u0073\u0072\u0063":_bfebf =_gcdge ;};};if _bfebf ==""{_de .Log .Error ("\u0043\u0068\u0061\u0072\u0074\u0020\u0060\u0073\u0072\u0063\u0060\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u0020\u0063\u0061n\u006e\u006f\u0074\u0020\u0062e\u0020\u0065m\u0070\u0074\u0079\u002e");
return nil ,_fdcb ;};_bada ,_bggea :=_bafb ._afgab .ChartMap [_bfebf ];if !_bggea {_de .Log .Error ("\u0043\u006ful\u0064\u0020\u006eo\u0074\u0020\u0066\u0069nd \u0063ha\u0072\u0074\u0020\u0072\u0065\u0073\u006fur\u0063\u0065\u003a\u0020\u0060\u0025\u0073`\u002e",_bfebf );
return nil ,_fdcb ;};_adbca :=NewChart (_bada );for _ ,_bcgd :=range _fbda ._fcdbfb .Attr {_decagb :=_bcgd .Value ;switch _fbfdc :=_bcgd .Name .Local ;_fbfdc {case "\u0078":_adbca .SetPos (_bafb .parseFloatAttr (_fbfdc ,_decagb ),_adbca ._edebb );case "\u0079":_adbca .SetPos (_adbca ._eac ,_bafb .parseFloatAttr (_fbfdc ,_decagb ));
case "\u006d\u0061\u0072\u0067\u0069\u006e":_fcbbd :=_bafb .parseMarginAttr (_fbfdc ,_decagb );_adbca .SetMargins (_fcbbd .Left ,_fcbbd .Right ,_fcbbd .Top ,_fcbbd .Bottom );case "\u0077\u0069\u0064t\u0068":_adbca ._caa .SetWidth (int (_bafb .parseFloatAttr (_fbfdc ,_decagb )));
case "\u0068\u0065\u0069\u0067\u0068\u0074":_adbca ._caa .SetHeight (int (_bafb .parseFloatAttr (_fbfdc ,_decagb )));case "\u0073\u0072\u0063":break ;default:_de .Log .Debug ("\u0055n\u0073\u0075p\u0070\u006f\u0072\u0074e\u0064\u0020\u0063h\u0061\u0072\u0074\u0020\u0061\u0074\u0074\u0072\u0069bu\u0074\u0065\u003a \u0060\u0025s\u0060\u002e\u0020\u0053\u006b\u0069p\u0070\u0069n\u0067\u002e",_fbfdc );
};};return _adbca ,nil ;};

// NewTextStyle creates a new text style object which can be used to style
// chunks of text.
// Default attributes:
// Font: Helvetica
// Font size: 10
// Encoding: WinAnsiEncoding
// Text color: black
func (_cdce *Creator )NewTextStyle ()TextStyle {return _fagb (_cdce ._efa )};func _cafd (_dddd float64 ,_eaed float64 ,_fcbc float64 ,_bbcdb float64 ,_dade []*ColorPoint )*RadialShading {return &RadialShading {_baadc :&shading {_cddd :ColorWhite ,_ccaa :false ,_bbfa :[]bool {false ,false },_cdga :_dade },_bgfad :_dddd ,_cgaea :_eaed ,_efad :_fcbc ,_bede :_bbcdb ,_aedf :AnchorCenter };
};func (_ccfba *StyledParagraph )getLineMetrics (_deef int )(_cebda ,_gbeg ,_agga float64 ){if _ccfba ._fgbg ==nil ||len (_ccfba ._fgbg )==0{_ccfba .wrapText ();};if _deef < 0||_deef > len (_ccfba ._fgbg )-1{_de .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020p\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u0020\u006c\u0069\u006e\u0065 \u0069\u006e\u0064\u0065\u0078\u0020\u0025\u0064\u002e\u0020\u0052\u0065tu\u0072\u006e\u0069\u006e\u0067\u0020\u0030\u002c\u0020\u0030",_deef );
return 0,0,0;};_ecbec :=_ccfba ._fgbg [_deef ];for _ ,_dfcf :=range _ecbec {_gage ,_dfeca :=_dfcf .Style .Font .GetFontDescriptor ();if _dfeca !=nil {_de .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020U\u006e\u0061\u0062\u006ce t\u006f g\u0065\u0074\u0020\u0066\u006f\u006e\u0074 d\u0065\u0073\u0063\u0072\u0069\u0070\u0074o\u0072");
};var _ebbb ,_bfga float64 ;if _gage !=nil {if _ebbb ,_dfeca =_gage .GetCapHeight ();_dfeca !=nil {_de .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0067\u0065\u0074 \u0066\u006f\u006e\u0074\u0020\u0043\u0061\u0070\u0048\u0065\u0069\u0067\u0068t\u003a\u0020\u0025\u0076",_dfeca );
};if _bfga ,_dfeca =_gage .GetDescent ();_dfeca !=nil {_de .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020U\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0067\u0065t\u0020\u0066\u006f\u006e\u0074\u0020\u0044\u0065\u0073\u0063\u0065\u006et\u003a\u0020\u0025\u0076",_dfeca );
};};if int (_ebbb )<=0{_de .Log .Debug ("\u0057\u0041\u0052\u004e\u003a\u0020\u0043\u0061p\u0020\u0048\u0065ig\u0068\u0074\u0020\u006e\u006f\u0074 \u0061\u0076\u0061\u0069\u006c\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0073\u0065\u0074t\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u00310\u0030\u0030");
_ebbb =1000;};if _gbcc :=_ebbb /1000.0*_dfcf .Style .FontSize ;_gbcc > _cebda {_cebda =_gbcc ;};if _dacd :=_bfga /1000.0*_dfcf .Style .FontSize ;_dacd < _agga {_agga =_dacd ;};if _bagb :=_dfcf .Style .FontSize ;_bagb > _gbeg {_gbeg =_bagb ;};};return _cebda ,_gbeg ,_agga ;
};func (_adegcb *templateProcessor )parseTextOverflowAttr (_aegd ,_cdgb string )TextOverflow {_de .Log .Debug ("\u0050a\u0072\u0073i\u006e\u0067\u0020\u0074e\u0078\u0074\u0020o\u0076\u0065\u0072\u0066\u006c\u006f\u0077\u0020\u0061tt\u0072\u0069\u0062u\u0074\u0065:\u0020\u0028\u0060\u0025\u0073\u0060,\u0020\u0025s\u0029\u002e",_aegd ,_cdgb );
_bbgcg :=map[string ]TextOverflow {"\u0076i\u0073\u0069\u0062\u006c\u0065":TextOverflowVisible ,"\u0068\u0069\u0064\u0064\u0065\u006e":TextOverflowHidden }[_cdgb ];return _bbgcg ;};

// SetIndent sets the cell's left indent.
func (_affc *TableCell )SetIndent (indent float64 ){_affc ._cgfb =indent };

// SetFitMode sets the fit mode of the rectangle.
// NOTE: The fit mode is only applied if relative positioning is used.
func (_gefe *Rectangle )SetFitMode (fitMode FitMode ){_gefe ._cegf =fitMode };

// AddColorStop add color stop information for rendering gradient.
func (_dgaf *shading )AddColorStop (color Color ,point float64 ){_dgaf ._cdga =append (_dgaf ._cdga ,_efbb (color ,point ));};

// GeneratePageBlocks draws the composite curve polygon on a new block
// representing the page. Implements the Drawable interface.
func (_gfdc *CurvePolygon )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_acc :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_cagfd ,_fabcc :=_acc .setOpacity (_gfdc ._bfeg ,_gfdc ._cdgc );if _fabcc !=nil {return nil ,ctx ,_fabcc ;
};_adce :=_gfdc ._fdfe ;_adce .FillEnabled =_adce .FillColor !=nil ;_adce .BorderEnabled =_adce .BorderColor !=nil &&_adce .BorderWidth > 0;var (_gccc =ctx .PageHeight ;_caae =_adce .Rings ;_bag =make ([][]_bc .CubicBezierCurve ,0,len (_adce .Rings ));
);_eefag :=_ed .PdfRectangle {};if len (_caae )> 0&&len (_caae [0])> 0{_cgga :=_caae [0][0];_cgga .P0 .Y =_gccc -_cgga .P0 .Y ;_cgga .P1 .Y =_gccc -_cgga .P1 .Y ;_cgga .P2 .Y =_gccc -_cgga .P2 .Y ;_cgga .P3 .Y =_gccc -_cgga .P3 .Y ;_eefag =_cgga .GetBounds ();
};for _ ,_aeba :=range _caae {_eeff :=make ([]_bc .CubicBezierCurve ,0,len (_aeba ));for _ ,_edef :=range _aeba {_cbbf :=_edef ;_cbbf .P0 .Y =_gccc -_cbbf .P0 .Y ;_cbbf .P1 .Y =_gccc -_cbbf .P1 .Y ;_cbbf .P2 .Y =_gccc -_cbbf .P2 .Y ;_cbbf .P3 .Y =_gccc -_cbbf .P3 .Y ;
_eeff =append (_eeff ,_cbbf );_adb :=_cbbf .GetBounds ();_eefag .Llx =_gd .Min (_eefag .Llx ,_adb .Llx );_eefag .Lly =_gd .Min (_eefag .Lly ,_adb .Lly );_eefag .Urx =_gd .Max (_eefag .Urx ,_adb .Urx );_eefag .Ury =_gd .Max (_eefag .Ury ,_adb .Ury );};_bag =append (_bag ,_eeff );
};_adce .Rings =_bag ;defer func (){_adce .Rings =_caae }();if _adce .FillEnabled {_acda :=_abfb (_acc ,_gfdc ._fdfe .FillColor ,_gfdc ._gdffc ,func ()Rectangle {return Rectangle {_eadb :_eefag .Llx ,_accbb :_eefag .Lly ,_egbf :_eefag .Width (),_agadf :_eefag .Height ()};
});if _acda !=nil {return nil ,ctx ,_acda ;};};_cfdf ,_ ,_fabcc :=_adce .Draw (_cagfd );if _fabcc !=nil {return nil ,ctx ,_fabcc ;};if _fabcc =_acc .addContentsByString (string (_cfdf ));_fabcc !=nil {return nil ,ctx ,_fabcc ;};return []*Block {_acc },ctx ,nil ;
};

// Date returns the invoice date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_bgdec *Invoice )Date ()(*InvoiceCell ,*InvoiceCell ){return _bgdec ._gfce [0],_bgdec ._gfce [1]};

// PolyBezierCurve represents a composite curve that is the result of joining
// multiple cubic Bezier curves.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type PolyBezierCurve struct{_adac *_bc .PolyBezierCurve ;_gefcb float64 ;_cbac float64 ;_ebebe Color ;};func (_fdag *TableCell )height (_aaffc float64 )float64 {var _bbef float64 ;switch _geegaa :=_fdag ._dafd .(type ){case *Paragraph :if _geegaa ._caba {_geegaa .SetWidth (_aaffc -_fdag ._cgfb -_geegaa ._bcbe .Left -_geegaa ._bcbe .Right );
};_bbef =_geegaa .Height ()+_geegaa ._bcbe .Top +_geegaa ._bcbe .Bottom +0.5*_geegaa ._aee *_geegaa ._ccef ;case *StyledParagraph :if _geegaa ._ebeda {_geegaa .SetWidth (_aaffc -_fdag ._cgfb -_geegaa ._bgac .Left -_geegaa ._bgac .Right );};_bbef =_geegaa .Height ()+_geegaa ._bgac .Top +_geegaa ._bgac .Bottom +0.5*_geegaa .getTextHeight ();
case *Image :_geegaa .applyFitMode (_aaffc -_fdag ._cgfb );_bbef =_geegaa .Height ()+_geegaa ._baaa .Top +_geegaa ._baaa .Bottom ;case *Table :_geegaa .updateRowHeights (_aaffc -_fdag ._cgfb -_geegaa ._effe .Left -_geegaa ._effe .Right );_bbef =_geegaa .Height ()+_geegaa ._effe .Top +_geegaa ._effe .Bottom ;
case *List :_bbef =_geegaa .tableHeight (_aaffc -_fdag ._cgfb )+_geegaa ._aaag .Top +_geegaa ._aaag .Bottom ;case *Division :_bbef =_geegaa .ctxHeight (_aaffc -_fdag ._cgfb )+_geegaa ._ccad .Top +_geegaa ._ccad .Bottom +_geegaa ._cacc .Top +_geegaa ._cacc .Bottom ;
case *Chart :_bbef =_geegaa .Height ()+_geegaa ._bgff .Top +_geegaa ._bgff .Bottom ;case *Rectangle :_geegaa .applyFitMode (_aaffc -_fdag ._cgfb );_bbef =_geegaa .Height ()+_geegaa ._efbdg .Top +_geegaa ._efbdg .Bottom +_geegaa ._gaffd ;case *Ellipse :_geegaa .applyFitMode (_aaffc -_fdag ._cgfb );
_bbef =_geegaa .Height ()+_geegaa ._ccac .Top +_geegaa ._ccac .Bottom ;case *Line :_bbef =_geegaa .Height ()+_geegaa ._fgddg .Top +_geegaa ._fgddg .Bottom ;};return _bbef ;};func _fdef (_afce []_bc .CubicBezierCurve )*PolyBezierCurve {return &PolyBezierCurve {_adac :&_bc .PolyBezierCurve {Curves :_afce ,BorderColor :_ed .NewPdfColorDeviceRGB (0,0,0),BorderWidth :1.0},_gefcb :1.0,_cbac :1.0};
};

// SetWidthLeft sets border width for left.
func (_fdfb *border )SetWidthLeft (bw float64 ){_fdfb ._dbf =bw };func _ccgee (_fffaac *templateProcessor ,_bgfeg *templateNode )(interface{},error ){return _fffaac .parseTable (_bgfeg );};

// SetLineColor sets the line color.
func (_fcacd *Polyline )SetLineColor (color Color ){_fcacd ._afgc .LineColor =_ccfb (color )};

// SetAntiAlias enables anti alias config.
//
// Anti alias is disabled by default.
func (_egfg *LinearShading )SetAntiAlias (enable bool ){_egfg ._cecc .SetAntiAlias (enable )};func _aeaec (_ffeada *_ed .PdfRectangle ,_fbab _ebg .Matrix )*_ed .PdfRectangle {var _dcbfd _ed .PdfRectangle ;_dcbfd .Llx ,_dcbfd .Lly =_fbab .Transform (_ffeada .Llx ,_ffeada .Lly );
_dcbfd .Urx ,_dcbfd .Ury =_fbab .Transform (_ffeada .Urx ,_ffeada .Ury );_dcbfd .Normalize ();return &_dcbfd ;};

// SetStyleRight sets border style for right side.
func (_ddef *border )SetStyleRight (style CellBorderStyle ){_ddef ._dfde =style };const (AnchorBottomLeft AnchorPoint =iota ;AnchorBottomRight ;AnchorTopLeft ;AnchorTopRight ;AnchorCenter ;AnchorLeft ;AnchorRight ;AnchorTop ;AnchorBottom ;);

// ToRBG implements interface Color.
// Note: It's not directly used since shading color works differently than regular color.
func (_begff *LinearShading )ToRGB ()(float64 ,float64 ,float64 ){return 0,0,0};

// Background contains properties related to the background of a component.
type Background struct{FillColor Color ;BorderColor Color ;BorderSize float64 ;BorderRadiusTopLeft float64 ;BorderRadiusTopRight float64 ;BorderRadiusBottomLeft float64 ;BorderRadiusBottomRight float64 ;};type templateNode struct{_defd interface{};_fcdbfb _ag .StartElement ;
_abgba *templateNode ;};type templateTag struct{_bceg map[string ]struct{};_accc func (*templateProcessor ,*templateNode )(interface{},error );};

// Scale scales Image by a constant factor, both width and height.
func (_cfbg *Image )Scale (xFactor ,yFactor float64 ){_cfbg ._deac =xFactor *_cfbg ._deac ;_cfbg ._fedbd =yFactor *_cfbg ._fedbd ;};

// FooterFunctionArgs holds the input arguments to a footer drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FooterFunctionArgs struct{PageNum int ;TotalPages int ;};

// Height returns the height of the division, assuming all components are
// stacked on top of each other.
func (_gdg *Division )Height ()float64 {var _faab float64 ;for _ ,_ddgd :=range _gdg ._cfadf {switch _egacd :=_ddgd .(type ){case marginDrawable :_ ,_ ,_gce ,_cefe :=_egacd .GetMargins ();_faab +=_egacd .Height ()+_gce +_cefe ;default:_faab +=_egacd .Height ();
};};return _faab ;};const (CellBorderSideLeft CellBorderSide =iota ;CellBorderSideRight ;CellBorderSideTop ;CellBorderSideBottom ;CellBorderSideAll ;);

// SetDate sets the date of the invoice.
func (_aaac *Invoice )SetDate (date string )(*InvoiceCell ,*InvoiceCell ){_aaac ._gfce [1].Value =date ;return _aaac ._gfce [0],_aaac ._gfce [1];};

// SetLinePageStyle sets the style for the page part of all new lines
// of the table of contents.
func (_cefg *TOC )SetLinePageStyle (style TextStyle ){_cefg ._gdbbc =style };

// ScaleToHeight sets the graphic svg scaling factor with the given height.
func (_fabcb *GraphicSVG )ScaleToHeight (h float64 ){_fgde :=_fabcb ._ebgg .Width /_fabcb ._ebgg .Height ;_fabcb ._ebgg .Height =h ;_fabcb ._ebgg .Width =h *_fgde ;_fabcb ._ebgg .SetScaling (_fgde ,_fgde );};func (_eefbf *LinearShading )shadingModel ()*_ed .PdfShadingType2 {_addbe :=_bc .NewPoint (_eefbf ._dfagf .Llx +_eefbf ._dfagf .Width ()/2,_eefbf ._dfagf .Lly +_eefbf ._dfagf .Height ()/2);
_cddgc :=_bc .NewPoint (_eefbf ._dfagf .Llx ,_eefbf ._dfagf .Lly +_eefbf ._dfagf .Height ()/2).Add (-_addbe .X ,-_addbe .Y ).Rotate (_eefbf ._gbcee ).Add (_addbe .X ,_addbe .Y );_cddgc =_bc .NewPoint (_gd .Max (_gd .Min (_cddgc .X ,_eefbf ._dfagf .Urx ),_eefbf ._dfagf .Llx ),_gd .Max (_gd .Min (_cddgc .Y ,_eefbf ._dfagf .Ury ),_eefbf ._dfagf .Lly ));
_dcae :=_bc .NewPoint (_eefbf ._dfagf .Urx ,_eefbf ._dfagf .Lly +_eefbf ._dfagf .Height ()/2).Add (-_addbe .X ,-_addbe .Y ).Rotate (_eefbf ._gbcee ).Add (_addbe .X ,_addbe .Y );_dcae =_bc .NewPoint (_gd .Min (_gd .Max (_dcae .X ,_eefbf ._dfagf .Llx ),_eefbf ._dfagf .Urx ),_gd .Min (_gd .Max (_dcae .Y ,_eefbf ._dfagf .Lly ),_eefbf ._dfagf .Ury ));
_aaaa :=_ed .NewPdfShadingType2 ();_aaaa .PdfShading .ShadingType =_gg .MakeInteger (2);_aaaa .PdfShading .ColorSpace =_ed .NewPdfColorspaceDeviceRGB ();_aaaa .PdfShading .AntiAlias =_gg .MakeBool (_eefbf ._cecc ._ccaa );_aaaa .Coords =_gg .MakeArrayFromFloats ([]float64 {_cddgc .X ,_cddgc .Y ,_dcae .X ,_dcae .Y });
_aaaa .Extend =_gg .MakeArray (_gg .MakeBool (_eefbf ._cecc ._bbfa [0]),_gg .MakeBool (_eefbf ._cecc ._bbfa [1]));_aaaa .Function =_eefbf ._cecc .generatePdfFunctions ();return _aaaa ;};

// GetCoords returns the upper left corner coordinates of the rectangle (`x`, `y`).
func (_feacg *Rectangle )GetCoords ()(float64 ,float64 ){return _feacg ._eadb ,_feacg ._accbb };

// Title returns the title of the invoice.
func (_dfff *Invoice )Title ()string {return _dfff ._gad };

// GetIndent get the cell's left indent.
func (_aaaf *TableCell )GetIndent ()float64 {return _aaaf ._cgfb };func _bcce (_efeaa string )(*GraphicSVG ,error ){_bbgb ,_fedb :=_fa .ParseFromFile (_efeaa );if _fedb !=nil {return nil ,_fedb ;};return _cggg (_bbgb );};type shading struct{_cddd Color ;
_ccaa bool ;_bbfa []bool ;_cdga []*ColorPoint ;};func _adeg (_baae string )(*Image ,error ){_ffde ,_cgabd :=_cf .Open (_baae );if _cgabd !=nil {return nil ,_cgabd ;};defer _ffde .Close ();_dgfcb ,_cgabd :=_ed .ImageHandling .Read (_ffde );if _cgabd !=nil {_de .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_cgabd );
return nil ,_cgabd ;};return _acgaf (_dgfcb );};func _bdba (_gdaf *Chapter ,_baac *TOC ,_gbgdb *_ed .Outline ,_fceb string ,_cde int ,_fefdd TextStyle )*Chapter {var _ffbg uint =1;if _gdaf !=nil {_ffbg =_gdaf ._ceec +1;};_ddce :=&Chapter {_gaaa :_cde ,_aae :_fceb ,_gae :true ,_efgd :true ,_cdgd :_gdaf ,_afg :_baac ,_dae :_gbgdb ,_eded :[]Drawable {},_ceec :_ffbg };
_ggb :=_edadc (_ddce .headingText (),_fefdd );_ggb .SetFont (_fefdd .Font );_ggb .SetFontSize (_fefdd .FontSize );_ddce ._cff =_ggb ;return _ddce ;};

// NewColorPoint creates a new color and point object for use in the gradient rendering process.
func NewColorPoint (color Color ,point float64 )*ColorPoint {return _efbb (color ,point )};func (_egea *Invoice )newColumn (_dfed string ,_eaccg CellHorizontalAlignment )*InvoiceCell {_adca :=&InvoiceCell {_egea ._dadd ,_dfed };_adca .Alignment =_eaccg ;
return _adca ;};func (_gdafd *StyledParagraph )split (_faba DrawContext )(_ceeg ,_dabb *StyledParagraph ,_ceddfg error ){if _ceddfg =_gdafd .wrapChunks (false );_ceddfg !=nil {return nil ,nil ,_ceddfg ;};_afae :=func (_bdfb []*TextChunk ,_bcga []*TextChunk )[]*TextChunk {if len (_bcga )==0{return _bdfb ;
};_edcd :=len (_bdfb );if _edcd ==0{return append (_bdfb ,_bcga ...);};if _bdfb [_edcd -1].Style ==_bcga [0].Style {_bdfb [_edcd -1].Text +=_bcga [0].Text ;}else {_bdfb =append (_bdfb ,_bcga [0]);};return append (_bdfb ,_bcga [1:]...);};_bfaa :=func (_dgec *StyledParagraph ,_fddea []*TextChunk )*StyledParagraph {if len (_fddea )==0{return nil ;
};_dccga :=*_dgec ;_dccga ._dfdf =_fddea ;return &_dccga ;};var (_ggedg float64 ;_fbad []*TextChunk ;_dgdcb []*TextChunk ;);for _ ,_cggc :=range _gdafd ._fgbg {var _bfggg float64 ;_affff :=make ([]*TextChunk ,0,len (_cggc ));for _ ,_eccdc :=range _cggc {if _ecaf :=_eccdc .Style .FontSize ;
_ecaf > _bfggg {_bfggg =_ecaf ;};_affff =append (_affff ,_eccdc .clone ());};_bfggg *=_gdafd ._gcba ;if _gdafd ._cade .IsRelative (){if _ggedg +_bfggg > _faba .Height {_dgdcb =_afae (_dgdcb ,_affff );}else {_fbad =_afae (_fbad ,_affff );};};_ggedg +=_bfggg ;
};_gdafd ._fgbg =nil ;if len (_dgdcb )==0{return _gdafd ,nil ,nil ;};return _bfaa (_gdafd ,_fbad ),_bfaa (_gdafd ,_dgdcb ),nil ;};

// InfoLines returns all the rows in the invoice information table as
// description-value cell pairs.
func (_cddcd *Invoice )InfoLines ()[][2]*InvoiceCell {_dgdc :=[][2]*InvoiceCell {_cddcd ._gbgcb ,_cddcd ._gfce ,_cddcd ._facg };return append (_dgdc ,_cddcd ._fgfg ...);};

// EnableWordWrap sets the paragraph word wrap flag.
func (_bfgbc *StyledParagraph )EnableWordWrap (val bool ){_bfgbc ._egbc =val };

// SetAngle sets the rotation angle in degrees.
func (_ff *Block )SetAngle (angleDeg float64 ){_ff ._bfa =angleDeg };

// RotatedSize returns the width and height of the rotated block.
func (_db *Block )RotatedSize ()(float64 ,float64 ){_ ,_ ,_cgae ,_ad :=_bege (_db ._beg ,_db ._fc ,_db ._bfa );return _cgae ,_ad ;};

// NewFilledCurve returns a instance of filled curve.
func (_fgdgd *Creator )NewFilledCurve ()*FilledCurve {return _ffcb ()};

// SetPositioning sets the positioning of the line (absolute or relative).
func (_dbdf *Line )SetPositioning (positioning Positioning ){_dbdf ._efef =positioning };

// SetPageMargins sets the page margins: left, right, top, bottom.
// The default page margins are 10% of document width.
func (_dgbdc *Creator )SetPageMargins (left ,right ,top ,bottom float64 ){_dgbdc ._bffb .Left =left ;_dgbdc ._bffb .Right =right ;_dgbdc ._bffb .Top =top ;_dgbdc ._bffb .Bottom =bottom ;};

// TOC returns the table of contents component of the creator.
func (_deff *Creator )TOC ()*TOC {return _deff ._cgec };func (_bebc *templateProcessor )parseInt64Array (_dgdd ,_ddgda string )[]int64 {_de .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020\u0069\u006e\u0074\u0036\u0034\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060%\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_dgdd ,_ddgda );
_bfde :=_ae .Fields (_ddgda );_acfc :=make ([]int64 ,0,len (_bfde ));for _ ,_gbea :=range _bfde {_facaa ,_ :=_df .ParseInt (_gbea ,10,64);_acfc =append (_acfc ,_facaa );};return _acfc ;};

// NoteHeadingStyle returns the style properties used to render the heading of
// the invoice note sections.
func (_eeee *Invoice )NoteHeadingStyle ()TextStyle {return _eeee ._fadff };

// AddTotalLine adds a new line in the invoice totals table.
func (_cffg *Invoice )AddTotalLine (desc ,value string )(*InvoiceCell ,*InvoiceCell ){_ecgg :=&InvoiceCell {_cffg ._badgg ,desc };_fagc :=&InvoiceCell {_cffg ._badgg ,value };_cffg ._aad =append (_cffg ._aad ,[2]*InvoiceCell {_ecgg ,_fagc });return _ecgg ,_fagc ;
};func (_ebegc *TOCLine )getLineLink ()*_ed .PdfAnnotation {if _ebegc ._cfcb <=0{return nil ;};return _cbed (_ebegc ._cfcb -1,_ebegc ._dfcb ,_ebegc ._bdgff ,0);};

// TemplateOptions contains options and resources to use when rendering
// a template with a Creator instance.
// All the resources in the map fields can be referenced by their
// name/key in the template which is rendered using the options instance.
type TemplateOptions struct{

// Helper functions map.
HelperFuncMap _g .FuncMap ;

// Named resource maps.
FontMap map[string ]*_ed .PdfFont ;ImageMap map[string ]*_ed .Image ;ColorMap map[string ]Color ;ChartMap map[string ]_b .ChartRenderable ;};var (PageSizeA3 =PageSize {297*PPMM ,420*PPMM };PageSizeA4 =PageSize {210*PPMM ,297*PPMM };PageSizeA5 =PageSize {148*PPMM ,210*PPMM };
PageSizeLetter =PageSize {8.5*PPI ,11*PPI };PageSizeLegal =PageSize {8.5*PPI ,14*PPI };);

// GeneratePageBlocks draws the line on a new block representing the page.
// Implements the Drawable interface.
func (_ccfd *Line )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var (_egfc []*Block ;_dffg =NewBlock (ctx .PageWidth ,ctx .PageHeight );_cgca =ctx ;_efeef ,_dfaf =_ccfd ._ecfe ,ctx .PageHeight -_ccfd ._ecec ;_eeea ,_afedb =_ccfd ._bfba ,ctx .PageHeight -_ccfd ._gbbeb ;
);_fcba :=_ccfd ._efef .IsRelative ();if _fcba {ctx .X +=_ccfd ._fgddg .Left ;ctx .Y +=_ccfd ._fgddg .Top ;ctx .Width -=_ccfd ._fgddg .Left +_ccfd ._fgddg .Right ;ctx .Height -=_ccfd ._fgddg .Top +_ccfd ._fgddg .Bottom ;_efeef ,_dfaf ,_eeea ,_afedb =_ccfd .computeCoords (ctx );
if _ccfd .Height ()> ctx .Height {_egfc =append (_egfc ,_dffg );_dffg =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_eddb :=ctx ;_eddb .Y =ctx .Margins .Top +_ccfd ._fgddg .Top ;_eddb .X =ctx .Margins .Left +_ccfd ._fgddg .Left ;_eddb .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_ccfd ._fgddg .Top -_ccfd ._fgddg .Bottom ;
_eddb .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_ccfd ._fgddg .Left -_ccfd ._fgddg .Right ;ctx =_eddb ;_efeef ,_dfaf ,_eeea ,_afedb =_ccfd .computeCoords (ctx );};};_gde :=_bc .BasicLine {X1 :_efeef ,Y1 :_dfaf ,X2 :_eeea ,Y2 :_afedb ,LineColor :_ccfb (_ccfd ._ecge ),Opacity :_ccfd ._edaf ,LineWidth :_ccfd ._cdbc ,LineStyle :_ccfd ._dcge ,DashArray :_ccfd ._ffaa ,DashPhase :_ccfd ._fabfc };
_cagb ,_dddc :=_dffg .setOpacity (1.0,_ccfd ._edaf );if _dddc !=nil {return nil ,ctx ,_dddc ;};_abgee ,_ ,_dddc :=_gde .Draw (_cagb );if _dddc !=nil {return nil ,ctx ,_dddc ;};if _dddc =_dffg .addContentsByString (string (_abgee ));_dddc !=nil {return nil ,ctx ,_dddc ;
};if _fcba {ctx .X =_cgca .X ;ctx .Width =_cgca .Width ;_feca :=_ccfd .Height ();ctx .Y +=_feca +_ccfd ._fgddg .Bottom ;ctx .Height -=_feca ;}else {ctx =_cgca ;};_egfc =append (_egfc ,_dffg );return _egfc ,ctx ,nil ;};func (_fccc *TextChunk )clone ()*TextChunk {_cdgde :=*_fccc ;
_cdgde ._abcgd =_egbcf (_fccc ._abcgd );return &_cdgde ;};

// Cols returns the total number of columns the table has.
func (_badgf *Table )Cols ()int {return _badgf ._efefg };func (_bbggb *templateProcessor )parseTextAlignmentAttr (_aedba ,_dbgfd string )TextAlignment {_de .Log .Debug ("\u0050a\u0072\u0073i\u006e\u0067\u0020t\u0065\u0078\u0074\u0020\u0061\u006c\u0069g\u006e\u006d\u0065\u006e\u0074\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028`\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_aedba ,_dbgfd );
_accag :=map[string ]TextAlignment {"\u006c\u0065\u0066\u0074":TextAlignmentLeft ,"\u0072\u0069\u0067h\u0074":TextAlignmentRight ,"\u0063\u0065\u006e\u0074\u0065\u0072":TextAlignmentCenter ,"\u006au\u0073\u0074\u0069\u0066\u0079":TextAlignmentJustify }[_dbgfd ];
return _accag ;};

// ScaleToWidth sets the graphic svg scaling factor with the given width.
func (_dbbc *GraphicSVG )ScaleToWidth (w float64 ){_aega :=_dbbc ._ebgg .Height /_dbbc ._ebgg .Width ;_dbbc ._ebgg .Width =w ;_dbbc ._ebgg .Height =w *_aega ;_dbbc ._ebgg .SetScaling (_aega ,_aega );};

// MoveDown moves the drawing context down by relative displacement dy (negative goes up).
func (_ffgfg *Creator )MoveDown (dy float64 ){_ffgfg ._fafg .Y +=dy };func (_dcff *StyledParagraph )getTextWidth ()float64 {var _acgg float64 ;_gbbc :=len (_dcff ._dfdf );for _dcdf ,_baaef :=range _dcff ._dfdf {_agcacc :=&_baaef .Style ;_aaff :=len (_baaef .Text );
for _dgdea ,_bdde :=range _baaef .Text {if _bdde =='\u000A'{continue ;};_eecaa ,_abbg :=_agcacc .Font .GetRuneMetrics (_bdde );if !_abbg {_de .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_bdde );
return -1;};_acgg +=_agcacc .FontSize *_eecaa .Wx *_agcacc .horizontalScale ();if _bdde !=' '&&(_dcdf !=_gbbc -1||_dgdea !=_aaff -1){_acgg +=_agcacc .CharSpacing *1000.0;};};};return _acgg ;};

// DrawTemplate renders the template provided through the specified reader,
// using the specified `data` and `options`.
// Creator templates are first executed as text/template *Template instances,
// so the specified `data` is inserted within the template.
// The second phase of processing is actually parsing the template, translating
// it into creator components and rendering them using the provided options.
// Both the `data` and `options` parameters can be nil.
func (_degg *Block )DrawTemplate (c *Creator ,r _e .Reader ,data interface{},options *TemplateOptions )error {return _ccbb (c ,r ,data ,options ,_degg );};

// SkipCells skips over a specified number of cells in the table.
func (_aedga *Table )SkipCells (num int ){if num < 0{_de .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};_aedga ._cbae +=num ;};

// Padding returns the padding of the component.
func (_eecd *Division )Padding ()(_eddf ,_gbadd ,_bgeg ,_bcbc float64 ){return _eecd ._cacc .Left ,_eecd ._cacc .Right ,_eecd ._cacc .Top ,_eecd ._cacc .Bottom ;};

// SetBorderColor sets the border color.
func (_bfbd *CurvePolygon )SetBorderColor (color Color ){_bfbd ._fdfe .BorderColor =_ccfb (color )};

// AddInternalLink adds a new internal link to the paragraph.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
// The zoom of the destination page is controlled with the zoom
// parameter. Pass in 0 to keep the current zoom value.
func (_bbgg *StyledParagraph )AddInternalLink (text string ,page int64 ,x ,y ,zoom float64 )*TextChunk {_gadd :=NewTextChunk (text ,_bbgg ._feada );_gadd ._abcgd =_cbed (page -1,x ,y ,zoom );return _bbgg .appendChunk (_gadd );};

// SetFillColor sets the fill color of the rectangle.
func (_cdbaa *Rectangle )SetFillColor (col Color ){_cdbaa ._bbaf =col };

// GetMargins returns the Chapter's margin: left, right, top, bottom.
func (_bef *Chapter )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _bef ._eeeg .Left ,_bef ._eeeg .Right ,_bef ._eeeg .Top ,_bef ._eeeg .Bottom ;};

// SetAntiAlias enables anti alias config.
//
// Anti alias is disabled by default.
func (_fefg *RadialShading )SetAntiAlias (enable bool ){_fefg ._baadc .SetAntiAlias (enable )};

// AddInfo is used to append a piece of invoice information in the template
// information table.
func (_dcebb *Invoice )AddInfo (description ,value string )(*InvoiceCell ,*InvoiceCell ){_bccd :=[2]*InvoiceCell {_dcebb .newCell (description ,_dcebb ._bbeg ),_dcebb .newCell (value ,_dcebb ._bbeg )};_dcebb ._fgfg =append (_dcebb ._fgfg ,_bccd );return _bccd [0],_bccd [1];
};

// Block contains a portion of PDF Page contents. It has a width and a position and can
// be placed anywhere on a Page.  It can even contain a whole Page, and is used in the creator
// where each Drawable object can output one or more blocks, each representing content for separate pages
// (typically needed when Page breaks occur).
type Block struct{_eg *_da .ContentStreamOperations ;_bf *_ed .PdfPageResources ;_edb Positioning ;_ga ,_cc float64 ;_beg float64 ;_fc float64 ;_bfa float64 ;_dg Margins ;_cgg []*_ed .PdfAnnotation ;};

// ScaleToHeight scales the rectangle to the specified height. The width of
// the rectangle is scaled so that the aspect ratio is maintained.
func (_agdce *Rectangle )ScaleToHeight (h float64 ){_bfeag :=_agdce ._egbf /_agdce ._agadf ;_agdce ._agadf =h ;_agdce ._egbf =h *_bfeag ;};

// Margins returns the margins of the component.
func (_deag *Division )Margins ()(_fde ,_egbg ,_bdbac ,_fabd float64 ){return _deag ._ccad .Left ,_deag ._ccad .Right ,_deag ._ccad .Top ,_deag ._ccad .Bottom ;};func (_ge *Block )addContentsByString (_cdb string )error {_gbd :=_da .NewContentStreamParser (_cdb );
_ebb ,_dac :=_gbd .Parse ();if _dac !=nil {return _dac ;};_ge ._eg .WrapIfNeeded ();_ebb .WrapIfNeeded ();*_ge ._eg =append (*_ge ._eg ,*_ebb ...);return nil ;};

// NewEllipse creates a new ellipse with the center at (`xc`, `yc`),
// having the specified width and height.
// NOTE: In relative positioning mode, `xc` and `yc` are calculated using the
// current context. Furthermore, when the fit mode is set to fill the available
// space, the ellipse is scaled so that it occupies the entire context width
// while maintaining the original aspect ratio.
func (_afef *Creator )NewEllipse (xc ,yc ,width ,height float64 )*Ellipse {return _fgeb (xc ,yc ,width ,height );};

// GetCoords returns coordinates of border.
func (_bfac *border )GetCoords ()(float64 ,float64 ){return _bfac ._ddg ,_bfac ._bdgg };

// Margins returns the margins of the list: left, right, top, bottom.
func (_fffg *List )Margins ()(float64 ,float64 ,float64 ,float64 ){return _fffg ._aaag .Left ,_fffg ._aaag .Right ,_fffg ._aaag .Top ,_fffg ._aaag .Bottom ;};

// SetNoteHeadingStyle sets the style properties used to render the heading
// of the invoice note sections.
func (_effdb *Invoice )SetNoteHeadingStyle (style TextStyle ){_effdb ._fadff =style };func _aggb (_dfgcc float64 ,_efdga float64 )float64 {return _gd .Round (_dfgcc /_efdga )*_efdga };

// TOC represents a table of contents component.
// It consists of a paragraph heading and a collection of
// table of contents lines.
// The representation of a table of contents line is as follows:
//       [number] [title]      [separator] [page]
// e.g.: Chapter1 Introduction ........... 1
type TOC struct{_daedg *StyledParagraph ;_gacd []*TOCLine ;_acbdf TextStyle ;_gacdf TextStyle ;_dgeff TextStyle ;_gdbbc TextStyle ;_fbcdb string ;_dbdbe float64 ;_gfabb Margins ;_fadfe Positioning ;_ffcbf TextStyle ;_afec bool ;};func _edfdd (_ffed string )([]string ,error ){var (_ddag []string ;
_cdgeg []rune ;);for _ ,_beggf :=range _ffed {if _beggf =='\u000A'{if len (_cdgeg )> 0{_ddag =append (_ddag ,string (_cdgeg ));};_ddag =append (_ddag ,string (_beggf ));_cdgeg =nil ;continue ;};_cdgeg =append (_cdgeg ,_beggf );};if len (_cdgeg )> 0{_ddag =append (_ddag ,string (_cdgeg ));
};var _fggge []string ;for _ ,_cgdea :=range _ddag {_gbcb :=[]rune (_cgdea );_dcead :=_gb .NewScanner (_gbcb );var _bbbac []rune ;for _bfdb :=0;_bfdb < len (_gbcb );_bfdb ++{_ ,_bfbge ,_fgaeb :=_dcead .Next ();if _fgaeb !=nil {return nil ,_fgaeb ;};if _bfbge ==_gb .BreakProhibited ||_ac .IsSpace (_gbcb [_bfdb ]){_bbbac =append (_bbbac ,_gbcb [_bfdb ]);
if _ac .IsSpace (_gbcb [_bfdb ]){_fggge =append (_fggge ,string (_bbbac ));_bbbac =[]rune {};};continue ;}else {if len (_bbbac )> 0{_fggge =append (_fggge ,string (_bbbac ));};_bbbac =[]rune {_gbcb [_bfdb ]};};};if len (_bbbac )> 0{_fggge =append (_fggge ,string (_bbbac ));
};};return _fggge ,nil ;};

// FilledCurve represents a closed path of Bezier curves with a border and fill.
type FilledCurve struct{_bgegb []_bc .CubicBezierCurve ;FillEnabled bool ;_dec Color ;BorderEnabled bool ;BorderWidth float64 ;_ceff Color ;};

// SetPdfWriterAccessFunc sets a PdfWriter access function/hook.
// Exposes the PdfWriter just prior to writing the PDF.  Can be used to encrypt the output PDF, etc.
//
// Example of encrypting with a user/owner password "password"
// Prior to calling c.WriteFile():
//
//	c.SetPdfWriterAccessFunc(func(w *model.PdfWriter) error {
//		userPass := []byte("password")
//		ownerPass := []byte("password")
//		err := w.Encrypt(userPass, ownerPass, nil)
//		return err
//	})
func (_gcgd *Creator )SetPdfWriterAccessFunc (pdfWriterAccessFunc func (_fgdf *_ed .PdfWriter )error ){_gcgd ._eeb =pdfWriterAccessFunc ;};func _fefea (_bae []*ColorPoint ,_fdab bool )*LinearShading {return &LinearShading {_cecc :&shading {_cddd :ColorWhite ,_ccaa :false ,_bbfa :[]bool {false ,false },_cdga :_bae },_dfagf :&_ed .PdfRectangle {},_dee :_fdab };
};

// SetPadding sets the padding of the component. The padding represents
// inner margins which are applied around the contents of the division.
// The background of the component is not affected by its padding.
func (_gdd *Division )SetPadding (left ,right ,top ,bottom float64 ){_gdd ._cacc .Left =left ;_gdd ._cacc .Right =right ;_gdd ._cacc .Top =top ;_gdd ._cacc .Bottom =bottom ;};

// GetMargins returns the margins of the chart (left, right, top, bottom).
func (_agcac *Chart )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _agcac ._bgff .Left ,_agcac ._bgff .Right ,_agcac ._bgff .Top ,_agcac ._bgff .Bottom ;};func _ecaee (_bfacd TextStyle )*List {return &List {_cbbd :TextChunk {Text :"\u2022\u0020",Style :_bfacd },_decc :0,_gcfc :true ,_dgba :PositionRelative ,_cgge :_bfacd };
};

// Ellipse defines an ellipse with a center at (xc,yc) and a specified width and height.  The ellipse can have a colored
// fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Ellipse struct{_ggceg float64 ;_ecd float64 ;_dcg float64 ;_bddb float64 ;_cdgf Positioning ;_eged Color ;_bbcdd float64 ;_facc Color ;_fffa float64 ;_eega float64 ;_ccac Margins ;_cfef FitMode ;};

// SetColorTop sets border color for top.
func (_cbbc *border )SetColorTop (col Color ){_cbbc ._ecbc =col };func _cfab (_feee ,_aeac ,_afgd ,_edee float64 )*Rectangle {return &Rectangle {_eadb :_feee ,_accbb :_aeac ,_egbf :_afgd ,_agadf :_edee ,_dded :PositionAbsolute ,_eeed :1.0,_dca :ColorBlack ,_gaffd :1.0,_bedf :1.0};
};

// GetMargins returns the margins of the graphic svg (left, right, top, bottom).
func (_dfbd *GraphicSVG )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _dfbd ._eaeg .Left ,_dfbd ._eaeg .Right ,_dfbd ._eaeg .Top ,_dfbd ._eaeg .Bottom ;};

// SetBorderColor sets the border color for the path.
func (_begc *FilledCurve )SetBorderColor (color Color ){_begc ._ceff =color };

// SetEncoder sets the encoding/compression mechanism for the image.
func (_dbeff *Image )SetEncoder (encoder _gg .StreamEncoder ){_dbeff ._agdcd =encoder };

// ToRBG implements interface Color.
// Note: It's not directly used since shading color works differently than regular color.
func (_cfbc *RadialShading )ToRGB ()(float64 ,float64 ,float64 ){return 0,0,0};

// BorderWidth returns the border width of the ellipse.
func (_fgcg *Ellipse )BorderWidth ()float64 {return _fgcg ._fffa };

// Height returns the height of the rectangle.
// NOTE: the returned value does not include the border width of the rectangle.
func (_eabf *Rectangle )Height ()float64 {return _eabf ._agadf };

// Reset removes all the text chunks the paragraph contains.
func (_agbc *StyledParagraph )Reset (){_agbc ._dfdf =[]*TextChunk {}};var _bagba =map[string ]*templateTag {"\u0070a\u0072\u0061\u0067\u0072\u0061\u0070h":&templateTag {_bceg :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_accc :_ggad },"\u0074\u0065\u0078\u0074\u002d\u0063\u0068\u0075\u006e\u006b":&templateTag {_bceg :map[string ]struct{}{"\u0070a\u0072\u0061\u0067\u0072\u0061\u0070h":struct{}{}},_accc :_bcdc },"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":&templateTag {_bceg :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_accc :_faeb },"\u0074\u0061\u0062l\u0065":&templateTag {_bceg :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_accc :_ccgee },"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":&templateTag {_bceg :map[string ]struct{}{"\u0074\u0061\u0062l\u0065":struct{}{}},_accc :_cggcf },"\u006c\u0069\u006e\u0065":&templateTag {_bceg :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_accc :_ceddc },"\u0069\u006d\u0061g\u0065":&templateTag {_bceg :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_accc :_degd },"\u0063h\u0061\u0070\u0074\u0065\u0072":&templateTag {_bceg :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_accc :_befgg },"\u0063h\u0061p\u0074\u0065\u0072\u002d\u0068\u0065\u0061\u0064\u0069\u006e\u0067":&templateTag {_bceg :map[string ]struct{}{"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_accc :_cafb },"\u0063\u0068\u0061r\u0074":&templateTag {_bceg :map[string ]struct{}{"\u0063r\u0065\u0061\u0074\u006f\u0072":struct{}{},"\u0062\u006c\u006fc\u006b":struct{}{},"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{},"\u0074\u0061\u0062\u006c\u0065\u002d\u0063\u0065\u006c\u006c":struct{}{},"\u0063h\u0061\u0070\u0074\u0065\u0072":struct{}{}},_accc :_eegb },"\u0062\u0061\u0063\u006b\u0067\u0072\u006f\u0075\u006e\u0064":&templateTag {_bceg :map[string ]struct{}{"\u0064\u0069\u0076\u0069\u0073\u0069\u006f\u006e":struct{}{}},_accc :_afadc }};


// ScaleToWidth scales the Block to a specified width, maintaining the same aspect ratio.
func (_gdab *Block )ScaleToWidth (w float64 ){_ef :=w /_gdab ._beg ;_gdab .Scale (_ef ,_ef )};func (_efgb *StyledParagraph )appendChunk (_dbde *TextChunk )*TextChunk {_efgb ._dfdf =append (_efgb ._dfdf ,_dbde );_efgb .wrapText ();return _dbde ;};

// CellVerticalAlignment defines the table cell's vertical alignment.
type CellVerticalAlignment int ;

// GeneratePageBlocks generates the page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages. Implements the Drawable interface.
func (_gcfa *Paragraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_abde :=ctx ;var _afgg []*Block ;_dbaa :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _gcfa ._gbfg .IsRelative (){ctx .X +=_gcfa ._bcbe .Left ;ctx .Y +=_gcfa ._bcbe .Top ;
ctx .Width -=_gcfa ._bcbe .Left +_gcfa ._bcbe .Right ;ctx .Height -=_gcfa ._bcbe .Top ;_gcfa .SetWidth (ctx .Width );if _gcfa .Height ()> ctx .Height {_afgg =append (_afgg ,_dbaa );_dbaa =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_dece :=ctx ;
_dece .Y =ctx .Margins .Top ;_dece .X =ctx .Margins .Left +_gcfa ._bcbe .Left ;_dece .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom ;_dece .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_gcfa ._bcbe .Left -_gcfa ._bcbe .Right ;
ctx =_dece ;};}else {if int (_gcfa ._gbgcd )<=0{_gcfa .SetWidth (_gcfa .getTextWidth ());};ctx .X =_gcfa ._fgef ;ctx .Y =_gcfa ._cbcaf ;};ctx ,_ccgbf :=_cgac (_dbaa ,_gcfa ,ctx );if _ccgbf !=nil {_de .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_ccgbf );
return nil ,ctx ,_ccgbf ;};_afgg =append (_afgg ,_dbaa );if _gcfa ._gbfg .IsRelative (){ctx .Y +=_gcfa ._bcbe .Bottom ;ctx .Height -=_gcfa ._bcbe .Bottom ;if !ctx .Inline {ctx .X =_abde .X ;ctx .Width =_abde .Width ;};return _afgg ,ctx ,nil ;};return _afgg ,_abde ,nil ;
};

// Logo returns the logo of the invoice.
func (_gacf *Invoice )Logo ()*Image {return _gacf ._abfe };const (TextAlignmentLeft TextAlignment =iota ;TextAlignmentRight ;TextAlignmentCenter ;TextAlignmentJustify ;);

// Add adds a VectorDrawable to the Division container.
// Currently supported VectorDrawables:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
// - *Rectangle
// - *Ellipse
// - *Line
func (_ecea *Division )Add (d VectorDrawable )error {switch _afcg :=d .(type ){case *Paragraph ,*StyledParagraph ,*Image ,*Chart ,*Rectangle ,*Ellipse ,*Line ,*Table ,*Division :case containerDrawable :_baceg ,_agcb :=_afcg .ContainerComponent (_ecea );
if _agcb !=nil {return _agcb ;};_ggdc ,_edd :=_baceg .(VectorDrawable );if !_edd {return _fe .Errorf ("\u0072\u0065\u0073\u0075\u006ct\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0061\u0069\u006e\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u002d\u0020\u0025\u0054\u0020\u0064\u006f\u0065\u0073\u006e\u0027\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u0056\u0065c\u0074\u006f\u0072\u0044\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u0020i\u006e\u0074\u0065\u0072\u0066\u0061c\u0065",_baceg );
};d =_ggdc ;default:return _c .New ("\u0075\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070e\u0020i\u006e\u0020\u0044\u0069\u0076\u0069\u0073i\u006f\u006e");};_ecea ._cfadf =append (_ecea ._cfadf ,d );return nil ;};

// SetLineHeight sets the line height (1.0 default).
func (_dbcee *Paragraph )SetLineHeight (lineheight float64 ){_dbcee ._ccef =lineheight };func _bfbg (_dfefb *_cf .File )([]*_ed .PdfPage ,error ){_eedfc ,_bedga :=_ed .NewPdfReader (_dfefb );if _bedga !=nil {return nil ,_bedga ;};_fgfe ,_bedga :=_eedfc .GetNumPages ();
if _bedga !=nil {return nil ,_bedga ;};var _cgdbf []*_ed .PdfPage ;for _bbede :=0;_bbede < _fgfe ;_bbede ++{_cgaed ,_ggdb :=_eedfc .GetPage (_bbede +1);if _ggdb !=nil {return nil ,_ggdb ;};_cgdbf =append (_cgdbf ,_cgaed );};return _cgdbf ,nil ;};func (_dddgc *templateProcessor )parseColorAttr (_abcd ,_fdbc string )Color {_de .Log .Debug ("\u0050\u0061rs\u0069\u006e\u0067 \u0063\u006f\u006c\u006fr a\u0074tr\u0069\u0062\u0075\u0074\u0065\u003a\u0020(`\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_abcd ,_fdbc );
_eedcc :=ColorBlack ;if _fdbc ==""{return _eedcc ;};_afcf ,_efcfb :=_dddgc ._afgab .ColorMap [_fdbc ];if _efcfb {return _afcf ;};if _fdbc [0]=='#'{return ColorRGBFromHex (_fdbc );};return _eedcc ;};var PPMM =float64 (72*1.0/25.4);

// TOCLine represents a line in a table of contents.
// The component can be used both in the context of a
// table of contents component and as a standalone component.
// The representation of a table of contents line is as follows:
/*
         [number] [title]      [separator] [page]
   e.g.: Chapter1 Introduction ........... 1
*/
type TOCLine struct{_ddaf *StyledParagraph ;

// Holds the text and style of the number part of the TOC line.
Number TextChunk ;

// Holds the text and style of the title part of the TOC line.
Title TextChunk ;

// Holds the text and style of the separator part of the TOC line.
Separator TextChunk ;

// Holds the text and style of the page part of the TOC line.
Page TextChunk ;_egee float64 ;_ggbcf uint ;_gfggfd float64 ;_gdace Positioning ;_dfcb float64 ;_bdgff float64 ;_cfcb int64 ;};

// SetLineSeparatorStyle sets the style for the separator part of all new
// lines of the table of contents.
func (_egag *TOC )SetLineSeparatorStyle (style TextStyle ){_egag ._dgeff =style };func _abda (_ddec VectorDrawable ,_bdbb float64 )float64 {switch _abdg :=_ddec .(type ){case *Paragraph :if _abdg ._caba {_abdg .SetWidth (_bdbb -_abdg ._bcbe .Left -_abdg ._bcbe .Right );
};return _abdg .Height ()+_abdg ._bcbe .Top +_abdg ._bcbe .Bottom ;case *StyledParagraph :if _abdg ._ebeda {_abdg .SetWidth (_bdbb -_abdg ._bgac .Left -_abdg ._bgac .Right );};return _abdg .Height ()+_abdg ._bgac .Top +_abdg ._bgac .Bottom ;case *Image :_abdg .applyFitMode (_bdbb );
return _abdg .Height ()+_abdg ._baaa .Top +_abdg ._baaa .Bottom ;case *Rectangle :_abdg .applyFitMode (_bdbb );return _abdg .Height ()+_abdg ._efbdg .Top +_abdg ._efbdg .Bottom +_abdg ._gaffd ;case *Ellipse :_abdg .applyFitMode (_bdbb );return _abdg .Height ()+_abdg ._ccac .Top +_abdg ._ccac .Bottom ;
case *Division :return _abdg .ctxHeight (_bdbb )+_abdg ._ccad .Top +_abdg ._ccad .Bottom +_abdg ._cacc .Top +_abdg ._cacc .Bottom ;case *Table :_abdg .updateRowHeights (_bdbb -_abdg ._effe .Left -_abdg ._effe .Right );return _abdg .Height ()+_abdg ._effe .Top +_abdg ._effe .Bottom ;
case marginDrawable :_ ,_ ,_fcfb ,_bbffb :=_abdg .GetMargins ();return _abdg .Height ()+_fcfb +_bbffb ;default:return _abdg .Height ();};};

// SetSideBorderStyle sets the cell's side border style.
func (_dddef *TableCell )SetSideBorderStyle (side CellBorderSide ,style CellBorderStyle ){switch side {case CellBorderSideAll :_dddef ._acgb =style ;_dddef ._ccbfd =style ;_dddef ._afcc =style ;_dddef ._gdbg =style ;case CellBorderSideTop :_dddef ._acgb =style ;
case CellBorderSideBottom :_dddef ._ccbfd =style ;case CellBorderSideLeft :_dddef ._afcc =style ;case CellBorderSideRight :_dddef ._gdbg =style ;};};func _afadc (_dbac *templateProcessor ,_cgcaa *templateNode )(interface{},error ){return _dbac .parseBackground (_cgcaa );
};

// IsRelative checks if the positioning is relative.
func (_bbgc Positioning )IsRelative ()bool {return _bbgc ==PositionRelative };

// NewPolyBezierCurve creates a new composite Bezier (polybezier) curve.
func (_acgf *Creator )NewPolyBezierCurve (curves []_bc .CubicBezierCurve )*PolyBezierCurve {return _fdef (curves );};func (_fbbb *Invoice )generateTotalBlocks (_eebg DrawContext )([]*Block ,DrawContext ,error ){_cedd :=_bcfa (4);_cedd .SetMargins (0,0,10,10);
_gefb :=[][2]*InvoiceCell {_fbbb ._egfeg };_gefb =append (_gefb ,_fbbb ._aad ...);_gefb =append (_gefb ,_fbbb ._ddeab );for _ ,_adgad :=range _gefb {_ccadd ,_bgfd :=_adgad [0],_adgad [1];if _bgfd .Value ==""{continue ;};_cedd .SkipCells (2);_cfec :=_cedd .NewCell ();
_cfec .SetBackgroundColor (_ccadd .BackgroundColor );_cfec .SetHorizontalAlignment (_bgfd .Alignment );_fbbb .setCellBorder (_cfec ,_ccadd );_faeg :=_fecf (_ccadd .TextStyle );_faeg .SetMargins (0,0,2,1);_faeg .Append (_ccadd .Value );_cfec .SetContent (_faeg );
_cfec =_cedd .NewCell ();_cfec .SetBackgroundColor (_bgfd .BackgroundColor );_cfec .SetHorizontalAlignment (_bgfd .Alignment );_fbbb .setCellBorder (_cfec ,_ccadd );_faeg =_fecf (_bgfd .TextStyle );_faeg .SetMargins (0,0,2,1);_faeg .Append (_bgfd .Value );
_cfec .SetContent (_faeg );};return _cedd .GeneratePageBlocks (_eebg );};

// SetPositioning sets the positioning of the ellipse (absolute or relative).
func (_cdgdb *Ellipse )SetPositioning (position Positioning ){_cdgdb ._cdgf =position };

// NewPolyline creates a new polyline.
func (_cgbg *Creator )NewPolyline (points []_bc .Point )*Polyline {return _dgcgf (points )};

// NoteStyle returns the style properties used to render the content of the
// invoice note sections.
func (_cafa *Invoice )NoteStyle ()TextStyle {return _cafa ._fddc };

// SetAngle sets Image rotation angle in degrees.
func (_ecgaf *Image )SetAngle (angle float64 ){_ecgaf ._fbfb =angle };

// ColorRGBFromArithmetic creates a Color from arithmetic color values (0-1).
// Example:
//   green := ColorRGBFromArithmetic(0.0, 1.0, 0.0)
func ColorRGBFromArithmetic (r ,g ,b float64 )Color {return rgbColor {_fbba :_gd .Max (_gd .Min (r ,1.0),0.0),_dbd :_gd .Max (_gd .Min (g ,1.0),0.0),_fdc :_gd .Max (_gd .Min (b ,1.0),0.0)};};

// GeneratePageBlocks draw graphic svg into block.
func (_gcab *GraphicSVG )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dgbdg :=ctx ;_cgcdg :=_gcab ._fgdgc .IsRelative ();var _ccfa []*Block ;if _cgcdg {_accb :=1.0;_fead :=_gcab ._eaeg .Top ;if _gcab ._ebgg .Height > ctx .Height -_gcab ._eaeg .Top {_ccfa =[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y )};
var _ebde error ;if _ ,ctx ,_ebde =_afbg ().GeneratePageBlocks (ctx );_ebde !=nil {return nil ,ctx ,_ebde ;};_fead =0;};ctx .X +=_gcab ._eaeg .Left +_accb ;ctx .Y +=_fead ;ctx .Width -=_gcab ._eaeg .Left +_gcab ._eaeg .Right +2*_accb ;ctx .Height -=_fead ;
}else {ctx .X =_gcab ._gab ;ctx .Y =_gcab ._eebf ;};_ggeg :=_da .NewContentCreator ();_ggeg .Translate (0,ctx .PageHeight );_ggeg .Scale (1,-1);_ggeg .Translate (ctx .X ,ctx .Y );_gcab ._ebgg .ToContentCreator (_ggeg );_cegb :=NewBlock (ctx .PageWidth ,ctx .PageHeight );
if _fadeb :=_cegb .addContentsByString (_ggeg .String ());_fadeb !=nil {return nil ,ctx ,_fadeb ;};if _cgcdg {_facb :=_gcab .Height ()+_gcab ._eaeg .Bottom ;ctx .Y +=_facb ;ctx .Height -=_facb ;}else {ctx =_dgbdg ;};_ccfa =append (_ccfa ,_cegb );return _ccfa ,ctx ,nil ;
};

// NewSubchapter creates a new child chapter with the specified title.
func (_abeb *Chapter )NewSubchapter (title string )*Chapter {_aaf :=_fagb (_abeb ._cff ._agae );_aaf .FontSize =14;_abeb ._dega ++;_eecf :=_bdba (_abeb ,_abeb ._afg ,_abeb ._dae ,title ,_abeb ._dega ,_aaf );_abeb .Add (_eecf );return _eecf ;};

// MultiRowCell makes a new cell with the specified row span and inserts it
// into the table at the current position.
func (_gddd *Table )MultiRowCell (rowspan int )*TableCell {return _gddd .MultiCell (rowspan ,1)};func (_aeef *Table )wrapContent (_aceb DrawContext )error {if _aeef ._egbga {return nil ;};_cacb :=func (_ffae *TableCell ,_baccf int ,_bgcf int ,_egdc int )(_decag int ){if _egdc < 1{return -1;
};_dabc :=0;for _ecgc :=_bgcf +1;_ecgc < len (_aeef ._ddbf )-1;_ecgc ++{_ecade :=_aeef ._ddbf [_ecgc ];if _ecade ._dgad ==_egdc {_dabc =_ecgc ;if (_ecade ._abdgb < _ffae ._abdgb &&_aeef ._efefg > _ecade ._abdgb )||_ffae ._abdgb < _aeef ._efefg {continue ;
};break ;};};_dcbcd :=float64 (0.0);for _daac :=0;_daac < _ffae ._efdb ;_daac ++{_dcbcd +=_aeef ._accga [_ffae ._dgad +_daac -1];};_abfgc :=float64 (0.0);for _cebe :=0;_cebe < _ffae ._bfeec ;_cebe ++{_abfgc +=_aeef ._gcfd [_ffae ._abdgb +_cebe -1];};var (_fgab VectorDrawable ;
_aefce =false ;);switch _cbdca :=_ffae ._dafd .(type ){case *StyledParagraph :_cdgad :=_aceb ;_cdgad .Height =_gd .Floor (_dcbcd -_cbdca ._bgac .Top -_cbdca ._bgac .Bottom -0.5*_cbdca .getTextHeight ());_cdgad .Width =_abfgc ;_bggb ,_efeca ,_dcaeb :=_cbdca .split (_cdgad );
if _dcaeb !=nil {_de .Log .Error ("\u0045\u0072\u0072o\u0072\u0020\u0077\u0072a\u0070\u0020\u0073\u0074\u0079\u006c\u0065d\u0020\u0070\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u003a\u0020\u0025\u0076",_dcaeb .Error ());};if _bggb !=nil &&_efeca !=nil {_aeef ._ddbf [_bgcf ]._dafd =_bggb ;
_fgab =_efeca ;_aefce =true ;};};_aeef ._ddbf [_bgcf ]._efdb =_ffae ._efdb ;_aceb .Height =_aceb .PageHeight -_aceb .Margins .Top -_aceb .Margins .Bottom ;_faega :=_ffae .cloneProps (nil );if _aefce {_faega ._dafd =_fgab ;};_faega ._efdb =_baccf -1;_faega ._dgad =_egdc +1;
_faega ._abdgb =_ffae ._abdgb ;_aeef ._ddbf =append (_aeef ._ddbf [:_dabc +1],append ([]*TableCell {_faega },_aeef ._ddbf [_dabc +1:]...)...);return _dabc +1;};_cabg :=float64 (0.0);_gaddb :=0;_eagc :=-1;for _dgbae ,_bdda :=range _aeef ._ddbf {if _eagc ==_dgbae {_gaddb =_bdda ._dgad ;
_cabg =0.0;};if _bdda ._efdb < 2{if _gaddb < _bdda ._dgad &&_dgbae > _eagc &&_cabg < _aceb .Height {_cabg +=_aeef ._accga [_bdda ._dgad -1];};_gaddb =_bdda ._dgad ;continue ;};_acfee :=float64 (0.0);_befb :=-1;_cafcd :=-1;_bgcbg :=0;for _fdeca :=0;_fdeca < _bdda ._efdb ;
_fdeca ++{if (_acfee +_aeef ._accga [_bdda ._dgad +_fdeca -1])> (_aceb .Height -_cabg ){_bgcbg --;break ;};_acfee +=_aeef ._accga [_bdda ._dgad +_fdeca -1];_cafcd =_bdda ._dgad +_fdeca -1;_befb =_bdda ._efdb -_fdeca +1;_bgcbg ++;};if _befb > 0&&_bdda ._efdb > _bgcbg {_bdda ._efdb =_bgcbg ;
_eagc =_cacb (_bdda ,_befb ,_dgbae ,_cafcd );_gaddb =_cafcd ;};};return nil ;};

// UnsupportedRuneError is an error that occurs when there is unsupported glyph being used.
type UnsupportedRuneError struct{Message string ;Rune rune ;};

// NewCell returns a new invoice table cell.
func (_cfaea *Invoice )NewCell (value string )*InvoiceCell {return _cfaea .newCell (value ,_cfaea .NewCellProps ());};

// AddSubtable copies the cells of the subtable in the table, starting with the
// specified position. The table row and column indices are 1-based, which
// makes the position of the first cell of the first row of the table 1,1.
// The table is automatically extended if the subtable exceeds its columns.
// This can happen when the subtable has more columns than the table or when
// one or more columns of the subtable starting from the specified position
// exceed the last column of the table.
func (_eeda *Table )AddSubtable (row ,col int ,subtable *Table ){for _ ,_agccd :=range subtable ._ddbf {_ebged :=&TableCell {};*_ebged =*_agccd ;_ebged ._dedc =_eeda ;_ebged ._abdgb +=col -1;if _gfdg :=_eeda ._efefg -(_ebged ._abdgb -1);_gfdg < _ebged ._bfeec {_eeda ._efefg +=_ebged ._bfeec -_gfdg ;
_eeda .resetColumnWidths ();_de .Log .Debug ("\u0054a\u0062l\u0065\u003a\u0020\u0073\u0075\u0062\u0074\u0061\u0062\u006c\u0065 \u0065\u0078\u0063\u0065e\u0064\u0073\u0020\u0064\u0065s\u0074\u0069\u006e\u0061\u0074\u0069\u006f\u006e\u0020\u0074\u0061\u0062\u006c\u0065\u002e\u0020\u0045\u0078\u0070\u0061\u006e\u0064\u0069\u006e\u0067\u0020\u0074\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0025\u0064\u0020\u0063\u006fl\u0075\u006d\u006e\u0073\u002e",_eeda ._efefg );
};_ebged ._dgad +=row -1;_edadg :=subtable ._accga [_agccd ._dgad -1];if _ebged ._dgad > _eeda ._bebea {for _ebged ._dgad > _eeda ._bebea {_eeda ._bebea ++;_eeda ._accga =append (_eeda ._accga ,_eeda ._ebdcc );};_eeda ._accga [_ebged ._dgad -1]=_edadg ;
}else {_eeda ._accga [_ebged ._dgad -1]=_gd .Max (_eeda ._accga [_ebged ._dgad -1],_edadg );};_eeda ._ddbf =append (_eeda ._ddbf ,_ebged );};_f .Slice (_eeda ._ddbf ,func (_dedfa ,_dbeba int )bool {_bdfg :=_eeda ._ddbf [_dedfa ]._dgad ;_abade :=_eeda ._ddbf [_dbeba ]._dgad ;
if _bdfg < _abade {return true ;};if _bdfg > _abade {return false ;};return _eeda ._ddbf [_dedfa ]._abdgb < _eeda ._ddbf [_dbeba ]._abdgb ;});};

// SetBorderColor sets the border color.
func (_cedba *Polygon )SetBorderColor (color Color ){_cedba ._gaecf .BorderColor =_ccfb (color )};

// NewTOCLine creates a new table of contents line with the default style.
func (_ffge *Creator )NewTOCLine (number ,title ,page string ,level uint )*TOCLine {return _aebad (number ,title ,page ,level ,_ffge .NewTextStyle ());};

// SetColumns overwrites any columns in the line items table. This should be
// called before AddLine.
func (_dfgg *Invoice )SetColumns (cols []*InvoiceCell ){_dfgg ._deabd =cols };func (_gda *Block )addContents (_bfd *_da .ContentStreamOperations ){_gda ._eg .WrapIfNeeded ();_bfd .WrapIfNeeded ();*_gda ._eg =append (*_gda ._eg ,*_bfd ...);};

// SetWidthRight sets border width for right.
func (_fcf *border )SetWidthRight (bw float64 ){_fcf ._dfdb =bw };

// SetTitle sets the title of the invoice.
func (_fbce *Invoice )SetTitle (title string ){_fbce ._gad =title };

// SkipRows skips over a specified number of rows in the table.
func (_bffa *Table )SkipRows (num int ){_ebgae :=num *_bffa ._efefg -1;if _ebgae < 0{_de .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};_bffa ._cbae +=_ebgae ;};

// SetVerticalAlignment set the cell's vertical alignment of content.
// Can be one of:
// - CellHorizontalAlignmentTop
// - CellHorizontalAlignmentMiddle
// - CellHorizontalAlignmentBottom
func (_ddfa *TableCell )SetVerticalAlignment (valign CellVerticalAlignment ){_ddfa ._dbbf =valign };

// SetBorderRadius sets the radius of the rectangle corners.
func (_fdgg *Rectangle )SetBorderRadius (topLeft ,topRight ,bottomLeft ,bottomRight float64 ){_fdgg ._eaad =topLeft ;_fdgg ._dbegg =topRight ;_fdgg ._eeffc =bottomLeft ;_fdgg ._cdad =bottomRight ;};func (_afaa *templateProcessor )parseImage (_bbdfa *templateNode )(interface{},error ){var _acabg string ;
for _ ,_aafcc :=range _bbdfa ._fcdbfb .Attr {_gaeg :=_aafcc .Value ;switch _degc :=_aafcc .Name .Local ;_degc {case "\u0073\u0072\u0063":_acabg =_gaeg ;};};_dfbag ,_dfgaf :=_afaa .loadImageFromSrc (_acabg );if _dfgaf !=nil {return nil ,_dfgaf ;};for _ ,_fgbfb :=range _bbdfa ._fcdbfb .Attr {_febb :=_fgbfb .Value ;
switch _caced :=_fgbfb .Name .Local ;_caced {case "\u0061\u006c\u0069g\u006e":_dfbag .SetHorizontalAlignment (_afaa .parseHorizontalAlignmentAttr (_caced ,_febb ));case "\u006fp\u0061\u0063\u0069\u0074\u0079":_dfbag .SetOpacity (_afaa .parseFloatAttr (_caced ,_febb ));
case "\u006d\u0061\u0072\u0067\u0069\u006e":_dcgec :=_afaa .parseMarginAttr (_caced ,_febb );_dfbag .SetMargins (_dcgec .Left ,_dcgec .Right ,_dcgec .Top ,_dcgec .Bottom );case "\u0066\u0069\u0074\u002d\u006d\u006f\u0064\u0065":_dfbag .SetFitMode (_afaa .parseFitModeAttr (_caced ,_febb ));
case "\u0078":_dfbag .SetPos (_afaa .parseFloatAttr (_caced ,_febb ),_dfbag ._fgff );case "\u0079":_dfbag .SetPos (_dfbag ._gcdg ,_afaa .parseFloatAttr (_caced ,_febb ));case "\u0077\u0069\u0064t\u0068":_dfbag .SetWidth (_afaa .parseFloatAttr (_caced ,_febb ));
case "\u0068\u0065\u0069\u0067\u0068\u0074":_dfbag .SetHeight (_afaa .parseFloatAttr (_caced ,_febb ));case "\u0061\u006e\u0067l\u0065":_dfbag .SetAngle (_afaa .parseFloatAttr (_caced ,_febb ));case "\u0073\u0072\u0063":break ;default:_de .Log .Debug ("\u0055n\u0073\u0075p\u0070\u006f\u0072\u0074e\u0064\u0020\u0069m\u0061\u0067\u0065\u0020\u0061\u0074\u0074\u0072\u0069bu\u0074\u0065\u003a \u0060\u0025s\u0060\u002e\u0020\u0053\u006b\u0069p\u0070\u0069n\u0067\u002e",_caced );
};};return _dfbag ,nil ;};

// Line defines a line between point 1 (X1, Y1) and point 2 (X2, Y2).
// The line width, color, style (solid or dashed) and opacity can be
// configured. Implements the Drawable interface.
type Line struct{_ecfe float64 ;_ecec float64 ;_bfba float64 ;_gbbeb float64 ;_ecge Color ;_dcge _bc .LineStyle ;_edaf float64 ;_ffaa []int64 ;_fabfc int64 ;_cdbc float64 ;_efef Positioning ;_facce FitMode ;_fgddg Margins ;};

// Sections returns the custom content sections of the invoice as
// title-content pairs.
func (_eade *Invoice )Sections ()[][2]string {return _eade ._gddb };

// BorderWidth returns the border width of the rectangle.
func (_gcde *Rectangle )BorderWidth ()float64 {return _gcde ._gaffd };func _cbed (_acbee int64 ,_dabd ,_adgcf ,_adbce float64 )*_ed .PdfAnnotation {_gbbcc :=_ed .NewPdfAnnotationLink ();_defff :=_ed .NewBorderStyle ();_defff .SetBorderWidth (0);_gbbcc .BS =_defff .ToPdfObject ();
if _acbee < 0{_acbee =0;};_gbbcc .Dest =_gg .MakeArray (_gg .MakeInteger (_acbee ),_gg .MakeName ("\u0058\u0059\u005a"),_gg .MakeFloat (_dabd ),_gg .MakeFloat (_adgcf ),_gg .MakeFloat (_adbce ));return _gbbcc .PdfAnnotation ;};

// TextAlignment options for paragraph.
type TextAlignment int ;

// SetHorizontalAlignment sets the cell's horizontal alignment of content.
// Can be one of:
// - CellHorizontalAlignmentLeft
// - CellHorizontalAlignmentCenter
// - CellHorizontalAlignmentRight
func (_bfggd *TableCell )SetHorizontalAlignment (halign CellHorizontalAlignment ){_bfggd ._eedf =halign ;};

// GetMargins returns the margins of the TOC line: left, right, top, bottom.
func (_fdefa *TOCLine )GetMargins ()(float64 ,float64 ,float64 ,float64 ){_afcb :=&_fdefa ._ddaf ._bgac ;return _fdefa ._egee ,_afcb .Right ,_afcb .Top ,_afcb .Bottom ;};

// SetLineOpacity sets the line opacity.
func (_bbdgd *Polyline )SetLineOpacity (opacity float64 ){_bbdgd ._eacac =opacity };

// CreateTableOfContents sets a function to generate table of contents.
func (_dgef *Creator )CreateTableOfContents (genTOCFunc func (_ddfe *TOC )error ){_dgef ._ceba =genTOCFunc ;};

// MultiColCell makes a new cell with the specified column span and inserts it
// into the table at the current position.
func (_eccga *Table )MultiColCell (colspan int )*TableCell {return _eccga .MultiCell (1,colspan )};

// SetOutlineTree adds the specified outline tree to the PDF file generated
// by the creator. Adding an external outline tree disables the automatic
// generation of outlines done by the creator for the relevant components.
func (_acga *Creator )SetOutlineTree (outlineTree *_ed .PdfOutlineTreeNode ){_acga ._gdfe =outlineTree };func _bege (_bbcc ,_cgabc ,_gaef float64 )(_cbdf ,_bdga ,_cgad ,_gade float64 ){if _gaef ==0{return 0,0,_bbcc ,_cgabc ;};_bfbe :=_bc .Path {Points :[]_bc .Point {_bc .NewPoint (0,0).Rotate (_gaef ),_bc .NewPoint (_bbcc ,0).Rotate (_gaef ),_bc .NewPoint (0,_cgabc ).Rotate (_gaef ),_bc .NewPoint (_bbcc ,_cgabc ).Rotate (_gaef )}}.GetBoundingBox ();
return _bfbe .X ,_bfbe .Y ,_bfbe .Width ,_bfbe .Height ;};func (_gbgcf *templateProcessor )parseChapterHeading (_aeefb *templateNode )(interface{},error ){if _aeefb ._abgba ==nil {_de .Log .Error ("\u0043\u0068a\u0070\u0074\u0065\u0072 \u0068\u0065a\u0064\u0069\u006e\u0067\u0020\u0070\u0061\u0072e\u006e\u0074\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c\u002e");
return nil ,_daggc ;};_egeac ,_fcfa :=_aeefb ._abgba ._defd .(*Chapter );if !_fcfa {_de .Log .Error ("\u0043h\u0061\u0070t\u0065\u0072\u0020h\u0065\u0061\u0064\u0069\u006e\u0067\u0020p\u0061\u0072\u0065\u006e\u0074\u0020(\u0025\u0054\u0029\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020a\u0020\u0063\u0068\u0061\u0070\u0074\u0065\u0072\u002e",_aeefb ._abgba ._defd );
return nil ,_daggc ;};_cdca :=_egeac .GetHeading ();if _ ,_beacd :=_gbgcf .parseParagraph (_aeefb ,_cdca );_beacd !=nil {return nil ,_beacd ;};return _cdca ,nil ;};

// GeneratePageBlocks implements drawable interface.
func (_bbd *border )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dgde :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_gge :=_bbd ._ddg ;_edeb :=ctx .PageHeight -_bbd ._bdgg ;if _bbd ._ddc !=nil {_fed :=_bc .Rectangle {Opacity :1.0,X :_bbd ._ddg ,Y :ctx .PageHeight -_bbd ._bdgg -_bbd ._eccb ,Height :_bbd ._eccb ,Width :_bbd ._ebd };
_fed .FillEnabled =true ;_gcb :=_ccfb (_bbd ._ddc );_gee :=_abfb (_dgde ,_gcb ,_bbd ._ddc ,func ()Rectangle {return Rectangle {_eadb :_fed .X ,_accbb :_fed .Y ,_egbf :_fed .Width ,_agadf :_fed .Height };});if _gee !=nil {return nil ,ctx ,_gee ;};_fed .FillColor =_gcb ;
_fed .BorderEnabled =false ;_gfba ,_ ,_gee :=_fed .Draw ("");if _gee !=nil {return nil ,ctx ,_gee ;};_gee =_dgde .addContentsByString (string (_gfba ));if _gee !=nil {return nil ,ctx ,_gee ;};};_bdb :=_bbd ._ecg ;_gec :=_bbd ._aed ;_bbg :=_bbd ._dbf ;_fdbg :=_bbd ._dfdb ;
_ffc :=_bbd ._ecg ;if _bbd ._cfe ==CellBorderStyleDouble {_ffc +=2*_bdb ;};_abfc :=_bbd ._aed ;if _bbd ._bde ==CellBorderStyleDouble {_abfc +=2*_gec ;};_cgcg :=_bbd ._dbf ;if _bbd ._agdc ==CellBorderStyleDouble {_cgcg +=2*_bbg ;};_efd :=_bbd ._dfdb ;if _bbd ._dfde ==CellBorderStyleDouble {_efd +=2*_fdbg ;
};_egfa :=(_ffc -_cgcg )/2;_fabc :=(_ffc -_efd )/2;_afe :=(_abfc -_cgcg )/2;_cee :=(_abfc -_efd )/2;if _bbd ._ecg !=0{_bad :=_gge ;_bda :=_edeb ;if _bbd ._cfe ==CellBorderStyleDouble {_bda -=_bdb ;_ccge :=_bc .BasicLine {LineColor :_ccfb (_bbd ._ecbc ),Opacity :1.0,LineWidth :_bbd ._ecg ,LineStyle :_bbd .LineStyle ,X1 :_bad -_ffc /2+_egfa ,Y1 :_bda +2*_bdb ,X2 :_bad +_ffc /2-_fabc +_bbd ._ebd ,Y2 :_bda +2*_bdb };
_bfg ,_ ,_cbba :=_ccge .Draw ("");if _cbba !=nil {return nil ,ctx ,_cbba ;};_cbba =_dgde .addContentsByString (string (_bfg ));if _cbba !=nil {return nil ,ctx ,_cbba ;};};_cbf :=_bc .BasicLine {LineWidth :_bbd ._ecg ,Opacity :1.0,LineColor :_ccfb (_bbd ._ecbc ),LineStyle :_bbd .LineStyle ,X1 :_bad -_ffc /2+_egfa +(_cgcg -_bbd ._dbf ),Y1 :_bda ,X2 :_bad +_ffc /2-_fabc +_bbd ._ebd -(_efd -_bbd ._dfdb ),Y2 :_bda };
_acdg ,_ ,_cfb :=_cbf .Draw ("");if _cfb !=nil {return nil ,ctx ,_cfb ;};_cfb =_dgde .addContentsByString (string (_acdg ));if _cfb !=nil {return nil ,ctx ,_cfb ;};};if _bbd ._aed !=0{_dgbb :=_gge ;_dbe :=_edeb -_bbd ._eccb ;if _bbd ._bde ==CellBorderStyleDouble {_dbe +=_gec ;
_ceac :=_bc .BasicLine {LineWidth :_bbd ._aed ,Opacity :1.0,LineColor :_ccfb (_bbd ._agd ),LineStyle :_bbd .LineStyle ,X1 :_dgbb -_abfc /2+_afe ,Y1 :_dbe -2*_gec ,X2 :_dgbb +_abfc /2-_cee +_bbd ._ebd ,Y2 :_dbe -2*_gec };_eee ,_ ,_cead :=_ceac .Draw ("");
if _cead !=nil {return nil ,ctx ,_cead ;};_cead =_dgde .addContentsByString (string (_eee ));if _cead !=nil {return nil ,ctx ,_cead ;};};_fefd :=_bc .BasicLine {LineWidth :_bbd ._aed ,Opacity :1.0,LineColor :_ccfb (_bbd ._agd ),LineStyle :_bbd .LineStyle ,X1 :_dgbb -_abfc /2+_afe +(_cgcg -_bbd ._dbf ),Y1 :_dbe ,X2 :_dgbb +_abfc /2-_cee +_bbd ._ebd -(_efd -_bbd ._dfdb ),Y2 :_dbe };
_ggd ,_ ,_ecbb :=_fefd .Draw ("");if _ecbb !=nil {return nil ,ctx ,_ecbb ;};_ecbb =_dgde .addContentsByString (string (_ggd ));if _ecbb !=nil {return nil ,ctx ,_ecbb ;};};if _bbd ._dbf !=0{_bed :=_gge ;_dfgc :=_edeb ;if _bbd ._agdc ==CellBorderStyleDouble {_bed +=_bbg ;
_add :=_bc .BasicLine {LineWidth :_bbd ._dbf ,Opacity :1.0,LineColor :_ccfb (_bbd ._cbb ),LineStyle :_bbd .LineStyle ,X1 :_bed -2*_bbg ,Y1 :_dfgc +_cgcg /2+_egfa ,X2 :_bed -2*_bbg ,Y2 :_dfgc -_cgcg /2-_afe -_bbd ._eccb };_afc ,_ ,_cdg :=_add .Draw ("");
if _cdg !=nil {return nil ,ctx ,_cdg ;};_cdg =_dgde .addContentsByString (string (_afc ));if _cdg !=nil {return nil ,ctx ,_cdg ;};};_fbg :=_bc .BasicLine {LineWidth :_bbd ._dbf ,Opacity :1.0,LineColor :_ccfb (_bbd ._cbb ),LineStyle :_bbd .LineStyle ,X1 :_bed ,Y1 :_dfgc +_cgcg /2+_egfa -(_ffc -_bbd ._ecg ),X2 :_bed ,Y2 :_dfgc -_cgcg /2-_afe -_bbd ._eccb +(_abfc -_bbd ._aed )};
_adfc ,_ ,_gfcb :=_fbg .Draw ("");if _gfcb !=nil {return nil ,ctx ,_gfcb ;};_gfcb =_dgde .addContentsByString (string (_adfc ));if _gfcb !=nil {return nil ,ctx ,_gfcb ;};};if _bbd ._dfdb !=0{_eef :=_gge +_bbd ._ebd ;_adc :=_edeb ;if _bbd ._dfde ==CellBorderStyleDouble {_eef -=_fdbg ;
_gbgd :=_bc .BasicLine {LineWidth :_bbd ._dfdb ,Opacity :1.0,LineColor :_ccfb (_bbd ._bbbg ),LineStyle :_bbd .LineStyle ,X1 :_eef +2*_fdbg ,Y1 :_adc +_efd /2+_fabc ,X2 :_eef +2*_fdbg ,Y2 :_adc -_efd /2-_cee -_bbd ._eccb };_ecga ,_ ,_bdeg :=_gbgd .Draw ("");
if _bdeg !=nil {return nil ,ctx ,_bdeg ;};_bdeg =_dgde .addContentsByString (string (_ecga ));if _bdeg !=nil {return nil ,ctx ,_bdeg ;};};_efec :=_bc .BasicLine {LineWidth :_bbd ._dfdb ,Opacity :1.0,LineColor :_ccfb (_bbd ._bbbg ),LineStyle :_bbd .LineStyle ,X1 :_eef ,Y1 :_adc +_efd /2+_fabc -(_ffc -_bbd ._ecg ),X2 :_eef ,Y2 :_adc -_efd /2-_cee -_bbd ._eccb +(_abfc -_bbd ._aed )};
_eba ,_ ,_fdg :=_efec .Draw ("");if _fdg !=nil {return nil ,ctx ,_fdg ;};_fdg =_dgde .addContentsByString (string (_eba ));if _fdg !=nil {return nil ,ctx ,_fdg ;};};return []*Block {_dgde },ctx ,nil ;};

// SetFillColor sets the fill color.
func (_bdbg *CurvePolygon )SetFillColor (color Color ){_bdbg ._gdffc =color ;_bdbg ._fdfe .FillColor =_ccfb (color );};

// Scale scales the rectangle dimensions by the specified factors.
func (_bffd *Rectangle )Scale (xFactor ,yFactor float64 ){_bffd ._egbf =xFactor *_bffd ._egbf ;_bffd ._agadf =yFactor *_bffd ._agadf ;};func (_ccfe *pageTransformations )transformBlock (_daeb *Block ){if _ccfe ._ddf !=nil {_daeb .transform (*_ccfe ._ddf );
};};

// AddressStyle returns the style properties used to render the content of
// the invoice address sections.
func (_cfae *Invoice )AddressStyle ()TextStyle {return _cfae ._abee };

// List represents a list of items.
// The representation of a list item is as follows:
//       [marker] [content]
// e.g.:        • This is the content of the item.
// The supported components to add content to list items are:
// - Paragraph
// - StyledParagraph
// - List
type List struct{_dbgfa []*listItem ;_aaag Margins ;_cbbd TextChunk ;_decc float64 ;_gcfc bool ;_dgba Positioning ;_cgge TextStyle ;};

// SetOpacity sets opacity for Image.
func (_gcdf *Image )SetOpacity (opacity float64 ){_gcdf ._adba =opacity };

// EnableRowWrap controls whether rows are wrapped across pages.
// NOTE: Currently, row wrapping is supported for rows using StyledParagraphs.
func (_dbgec *Table )EnableRowWrap (enable bool ){_dbgec ._egbga =enable };

// SetFillOpacity sets the fill opacity of the rectangle.
func (_ebdg *Rectangle )SetFillOpacity (opacity float64 ){_ebdg ._eeed =opacity };

// SetWidth sets the width of the rectangle.
func (_gffe *Rectangle )SetWidth (width float64 ){_gffe ._egbf =width };

// MoveRight moves the drawing context right by relative displacement dx (negative goes left).
func (_efgc *Creator )MoveRight (dx float64 ){_efgc ._fafg .X +=dx };

// EnableFontSubsetting enables font subsetting for `font` when the creator output is written to file.
// Embeds only the subset of the runes/glyphs that are actually used to display the file.
// Subsetting can reduce the size of fonts significantly.
func (_addb *Creator )EnableFontSubsetting (font *_ed .PdfFont ){_addb ._gfe =append (_addb ._gfe ,font )};

// MoveTo moves the drawing context to absolute coordinates (x, y).
func (_bbff *Creator )MoveTo (x ,y float64 ){_bbff ._fafg .X =x ;_bbff ._fafg .Y =y };

// SetFillColor sets the fill color.
func (_gdafe *Polygon )SetFillColor (color Color ){_gdafe ._bedd =color ;_gdafe ._gaecf .FillColor =_ccfb (color );};

// SetFitMode sets the fit mode of the image.
// NOTE: The fit mode is only applied if relative positioning is used.
func (_ggaf *Image )SetFitMode (fitMode FitMode ){_ggaf ._fdgd =fitMode };

// SetTextOverflow controls the behavior of paragraph text which
// does not fit in the available space.
func (_abae *StyledParagraph )SetTextOverflow (textOverflow TextOverflow ){_abae ._fdbbfa =textOverflow ;};func _gageb (_gaffb *Block ,_ebagf *StyledParagraph ,_cddf [][]*TextChunk ,_gccfe DrawContext )(DrawContext ,[][]*TextChunk ,error ){_fdfcd :=1;_gedg :=_gg .PdfObjectName (_fe .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_fdfcd ));
for _gaffb ._bf .HasFontByName (_gedg ){_fdfcd ++;_gedg =_gg .PdfObjectName (_fe .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_fdfcd ));};_gbdb :=_gaffb ._bf .SetFontByName (_gedg ,_ebagf ._fega .Font .ToPdfObject ());if _gbdb !=nil {return _gccfe ,nil ,_gbdb ;
};_fdfcd ++;_gfbad :=_gedg ;_bffeg :=_ebagf ._fega .FontSize ;_cgea :=_ebagf ._cade .IsRelative ();var _bbeb [][]_gg .PdfObjectName ;var _aegb [][]*TextChunk ;var _dedg float64 ;for _added ,_dbaf :=range _cddf {var _fcbgg []_gg .PdfObjectName ;var _fgfa float64 ;
if len (_dbaf )> 0{_fgfa =_dbaf [0].Style .FontSize ;};for _ ,_gecc :=range _dbaf {_becfa :=_gecc .Style ;if _gecc .Text !=""&&_becfa .FontSize > _fgfa {_fgfa =_becfa .FontSize ;};_gedg =_gg .PdfObjectName (_fe .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_fdfcd ));
_dfcc :=_gaffb ._bf .SetFontByName (_gedg ,_becfa .Font .ToPdfObject ());if _dfcc !=nil {return _gccfe ,nil ,_dfcc ;};_fcbgg =append (_fcbgg ,_gedg );_fdfcd ++;};_fgfa *=_ebagf ._gcba ;if _cgea &&_dedg +_fgfa > _gccfe .Height {_aegb =_cddf [_added :];_cddf =_cddf [:_added ];
break ;};_dedg +=_fgfa ;_bbeb =append (_bbeb ,_fcbgg );};_agfbg ,_cfff ,_ggcdc :=_ebagf .getLineMetrics (0);_ggcde ,_fbfd :=_agfbg *_ebagf ._gcba ,_cfff *_ebagf ._gcba ;if len (_cddf )==0{return _gccfe ,_aegb ,nil ;};_eeffg :=_da .NewContentCreator ();
_eeffg .Add_q ();_fgcae :=_fbfd ;if _ebagf ._ebdgb ==TextVerticalAlignmentCenter {_fgcae =_cfff +(_agfbg +_ggcdc -_cfff )/2+(_fbfd -_cfff )/2;};_cdbg :=_gccfe .PageHeight -_gccfe .Y -_fgcae ;_eeffg .Translate (_gccfe .X ,_cdbg );_efbe :=_cdbg ;if _ebagf ._caag !=0{_eeffg .RotateDeg (_ebagf ._caag );
};if _ebagf ._fdbbfa ==TextOverflowHidden {_eeffg .Add_re (0,-_dedg +_ggcde +1,_ebagf ._egeg ,_dedg ).Add_W ().Add_n ();};_eeffg .Add_BT ();var _bfff []*_bc .BasicLine ;for _bafg ,_dgbbg :=range _cddf {_afefg :=_gccfe .X ;var _bded float64 ;if len (_dgbbg )> 0{_bded =_dgbbg [0].Style .FontSize ;
};_agfbg ,_ ,_ggcdc =_ebagf .getLineMetrics (_bafg );_fbfd =(_agfbg +_ggcdc );for _ ,_dceec :=range _dgbbg {_caagc :=&_dceec .Style ;if _dceec .Text !=""&&_caagc .FontSize > _bded {_bded =_caagc .FontSize ;};if _fbfd > _bded {_bded =_fbfd ;};};if _bafg !=0{_eeffg .Add_TD (0,-_bded *_ebagf ._gcba );
_efbe -=_bded *_ebagf ._gcba ;};_aeeb :=_bafg ==len (_cddf )-1;var (_bdgb float64 ;_beef float64 ;_deefd float64 ;_dddbf uint ;);var _faad []float64 ;for _ ,_acade :=range _dgbbg {_agac :=&_acade .Style ;if _agac .FontSize > _beef {_beef =_agac .FontSize ;
};if _fbfd > _beef {_beef =_fbfd ;};_fbfbc ,_cfbf :=_agac .Font .GetRuneMetrics (' ');if !_cfbf {return _gccfe ,nil ,_c .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");
};var _gaac uint ;var _bfafa float64 ;_cafda :=len (_acade .Text );for _dfcgc ,_egedf :=range _acade .Text {if _egedf ==' '{_gaac ++;continue ;};if _egedf =='\u000A'{continue ;};_gecff ,_ddgf :=_agac .Font .GetRuneMetrics (_egedf );if !_ddgf {_de .Log .Debug ("\u0055\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006ee\u0020%\u0076\u0020\u0069\u006e\u0020\u0066\u006fn\u0074\u000a",_egedf );
return _gccfe ,nil ,_c .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");};_bfafa +=_agac .FontSize *_gecff .Wx *_agac .horizontalScale ();if _dfcgc !=_cafda -1{_bfafa +=_agac .CharSpacing *1000.0;
};};_faad =append (_faad ,_bfafa );_bdgb +=_bfafa ;_deefd +=float64 (_gaac )*_fbfbc .Wx *_agac .FontSize *_agac .horizontalScale ();_dddbf +=_gaac ;};_beef *=_ebagf ._gcba ;var _aage []_gg .PdfObject ;_eggd :=_ebagf ._egeg *1000.0;if _ebagf ._fbgd ==TextAlignmentJustify {if _dddbf > 0&&!_aeeb {_deefd =(_eggd -_bdgb )/float64 (_dddbf )/_bffeg ;
};}else if _ebagf ._fbgd ==TextAlignmentCenter {_aaca :=(_eggd -_bdgb -_deefd )/2;_gedd :=_aaca /_bffeg ;_aage =append (_aage ,_gg .MakeFloat (-_gedd ));_afefg +=_aaca /1000.0;}else if _ebagf ._fbgd ==TextAlignmentRight {_gaacc :=(_eggd -_bdgb -_deefd );
_gegc :=_gaacc /_bffeg ;_aage =append (_aage ,_gg .MakeFloat (-_gegc ));_afefg +=_gaacc /1000.0;};if len (_aage )> 0{_eeffg .Add_Tf (_gfbad ,_bffeg ).Add_TL (_bffeg *_ebagf ._gcba ).Add_TJ (_aage ...);};for _adagf ,_gbff :=range _dgbbg {_bece :=&_gbff .Style ;
_dggd :=_gfbad ;_gafe :=_bffeg ;_bbagb :=_bece .OutlineColor !=nil ;_bedag :=_bece .HorizontalScaling !=DefaultHorizontalScaling ;_cafc :=_bece .OutlineSize !=1;if _cafc {_eeffg .Add_w (_bece .OutlineSize );};_dfcff :=_bece .RenderingMode !=TextRenderingModeFill ;
if _dfcff {_eeffg .Add_Tr (int64 (_bece .RenderingMode ));};_affbd :=_bece .CharSpacing !=0;if _affbd {_eeffg .Add_Tc (_bece .CharSpacing );};_dacc :=_bece .TextRise !=0;if _dacc {_eeffg .Add_Ts (_bece .TextRise );};if _ebagf ._fbgd !=TextAlignmentJustify ||_aeeb {_faae ,_geee :=_bece .Font .GetRuneMetrics (' ');
if !_geee {return _gccfe ,nil ,_c .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};_dggd =_bbeb [_bafg ][_adagf ];_gafe =_bece .FontSize ;
_deefd =_faae .Wx *_bece .horizontalScale ();};_bffee :=_bece .Font .Encoder ();var _efafb []byte ;for _ ,_acfec :=range _gbff .Text {if _acfec =='\u000A'{continue ;};if _acfec ==' '{if len (_efafb )> 0{if _bbagb {_eeffg .SetStrokingColor (_ccfb (_bece .OutlineColor ));
};if _bedag {_eeffg .Add_Tz (_bece .HorizontalScaling );};_eeffg .SetNonStrokingColor (_ccfb (_bece .Color )).Add_Tf (_bbeb [_bafg ][_adagf ],_bece .FontSize ).Add_TJ ([]_gg .PdfObject {_gg .MakeStringFromBytes (_efafb )}...);_efafb =nil ;};if _bedag {_eeffg .Add_Tz (DefaultHorizontalScaling );
};_eeffg .Add_Tf (_dggd ,_gafe ).Add_TJ ([]_gg .PdfObject {_gg .MakeFloat (-_deefd )}...);_faad [_adagf ]+=_deefd *_gafe ;}else {if _ ,_bebe :=_bffee .RuneToCharcode (_acfec );!_bebe {_gbdb =UnsupportedRuneError {Message :_fe .Sprintf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_acfec ,_acfec ),Rune :_acfec };
_gccfe ._ddeg =append (_gccfe ._ddeg ,_gbdb );_de .Log .Debug (_gbdb .Error ());if _gccfe ._dgccf <=0{continue ;};_acfec =_gccfe ._dgccf ;};_efafb =append (_efafb ,_bffee .Encode (string (_acfec ))...);};};if len (_efafb )> 0{if _bbagb {_eeffg .SetStrokingColor (_ccfb (_bece .OutlineColor ));
};if _bedag {_eeffg .Add_Tz (_bece .HorizontalScaling );};_eeffg .SetNonStrokingColor (_ccfb (_bece .Color )).Add_Tf (_bbeb [_bafg ][_adagf ],_bece .FontSize ).Add_TJ ([]_gg .PdfObject {_gg .MakeStringFromBytes (_efafb )}...);};_gfbe :=_faad [_adagf ]/1000.0;
if _bece .Underline {_fgfbf :=_bece .UnderlineStyle .Color ;if _fgfbf ==nil {_fgfbf =_gbff .Style .Color ;};_afad ,_ggbe ,_aabc :=_fgfbf .ToRGB ();_daec :=_afefg -_gccfe .X ;_dfbcg :=_efbe -_cdbg +_bece .TextRise -_bece .UnderlineStyle .Offset ;_bfff =append (_bfff ,&_bc .BasicLine {X1 :_daec ,Y1 :_dfbcg ,X2 :_daec +_gfbe ,Y2 :_dfbcg ,LineWidth :_gbff .Style .UnderlineStyle .Thickness ,LineColor :_ed .NewPdfColorDeviceRGB (_afad ,_ggbe ,_aabc )});
};if _gbff ._abcgd !=nil {var _aacdg *_gg .PdfObjectArray ;if !_gbff ._dbae {switch _dgea :=_gbff ._abcgd .GetContext ().(type ){case *_ed .PdfAnnotationLink :_aacdg =_gg .MakeArray ();_dgea .Rect =_aacdg ;_ddaa ,_efde :=_dgea .Dest .(*_gg .PdfObjectArray );
if _efde &&_ddaa .Len ()==5{_edefc ,_cgdb :=_ddaa .Get (1).(*_gg .PdfObjectName );if _cgdb &&_edefc .String ()=="\u0058\u0059\u005a"{_bacdd ,_cgda :=_gg .GetNumberAsFloat (_ddaa .Get (3));if _cgda ==nil {_ddaa .Set (3,_gg .MakeFloat (_gccfe .PageHeight -_bacdd ));
};};};};_gbff ._dbae =true ;};if _aacdg !=nil {_cacg :=_bc .NewPoint (_afefg -_gccfe .X ,_efbe +_bece .TextRise -_cdbg ).Rotate (_ebagf ._caag );_cacg .X +=_gccfe .X ;_cacg .Y +=_cdbg ;_ebgef ,_dfaag ,_dcfdd ,_fabg :=_bege (_gfbe ,_beef ,_ebagf ._caag );
_cacg .X +=_ebgef ;_cacg .Y +=_dfaag ;_aacdg .Clear ();_aacdg .Append (_gg .MakeFloat (_cacg .X ));_aacdg .Append (_gg .MakeFloat (_cacg .Y ));_aacdg .Append (_gg .MakeFloat (_cacg .X +_dcfdd ));_aacdg .Append (_gg .MakeFloat (_cacg .Y +_fabg ));};_gaffb .AddAnnotation (_gbff ._abcgd );
};_afefg +=_gfbe ;if _cafc {_eeffg .Add_w (1.0);};if _bbagb {_eeffg .Add_RG (0.0,0.0,0.0);};if _dfcff {_eeffg .Add_Tr (int64 (TextRenderingModeFill ));};if _affbd {_eeffg .Add_Tc (0);};if _dacc {_eeffg .Add_Ts (0);};if _bedag {_eeffg .Add_Tz (DefaultHorizontalScaling );
};};};_eeffg .Add_ET ();for _ ,_adgdd :=range _bfff {_eeffg .SetStrokingColor (_adgdd .LineColor ).Add_w (_adgdd .LineWidth ).Add_m (_adgdd .X1 ,_adgdd .Y1 ).Add_l (_adgdd .X2 ,_adgdd .Y2 ).Add_s ();};_eeffg .Add_Q ();_bgdg :=_eeffg .Operations ();_bgdg .WrapIfNeeded ();
_gaffb .addContents (_bgdg );if _cgea {_fgbga :=_dedg ;_gccfe .Y +=_fgbga ;_gccfe .Height -=_fgbga ;if _gccfe .Inline {_gccfe .X +=_ebagf .Width ()+_ebagf ._bgac .Right ;};};return _gccfe ,_aegb ,nil ;};

// Fit fits the chunk into the specified bounding box, cropping off the
// remainder in a new chunk, if it exceeds the specified dimensions.
// NOTE: The method assumes a line height of 1.0. In order to account for other
// line height values, the passed in height must be divided by the line height:
// height = height / lineHeight
func (_ebef *TextChunk )Fit (width ,height float64 )(*TextChunk ,error ){_fabcba ,_cebfg :=_ebef .Wrap (width );if _cebfg !=nil {return nil ,_cebfg ;};_egad :=int (height /_ebef .Style .FontSize );if _egad >=len (_fabcba ){return nil ,nil ;};_eegc :="\u000a";
_ebef .Text =_ae .Replace (_ae .Join (_fabcba [:_egad ],"\u0020"),_eegc +"\u0020",_eegc ,-1);_ceggg :=_ae .Replace (_ae .Join (_fabcba [_egad :],"\u0020"),_eegc +"\u0020",_eegc ,-1);return NewTextChunk (_ceggg ,_ebef .Style ),nil ;};

// NewPolygon creates a new polygon.
func (_dcc *Creator )NewPolygon (points [][]_bc .Point )*Polygon {return _effc (points )};

// Flip flips the active page on the specified axes.
// If `flipH` is true, the page is flipped horizontally. Similarly, if `flipV`
// is true, the page is flipped vertically. If both are true, the page is
// flipped both horizontally and vertically.
// NOTE: the flip transformations are applied when the creator is finalized,
// which is at write time in most cases.
func (_edcee *Creator )Flip (flipH ,flipV bool )error {_aec :=_edcee .getActivePage ();if _aec ==nil {return _c .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};_ccag ,_befc :=_edcee ._abcf [_aec ];if !_befc {_ccag =&pageTransformations {};
_edcee ._abcf [_aec ]=_ccag ;};_ccag ._ffea =flipH ;_ccag ._cdge =flipV ;return nil ;};const (TextVerticalAlignmentBaseline TextVerticalAlignment =iota ;TextVerticalAlignmentCenter ;);

// Width returns the cell's width based on the input draw context.
func (_adgfg *TableCell )Width (ctx DrawContext )float64 {_bgbbc :=float64 (0.0);for _fceg :=0;_fceg < _adgfg ._bfeec ;_fceg ++{_bgbbc +=_adgfg ._dedc ._gcfd [_adgfg ._abdgb +_fceg -1];};_acedg :=ctx .Width *_bgbbc ;return _acedg ;};

// SetCoords sets the center coordinates of the ellipse.
func (_gcbg *Ellipse )SetCoords (xc ,yc float64 ){_gcbg ._ggceg =xc ;_gcbg ._ecd =yc };

// Text sets the text content of the Paragraph.
func (_eeabb *Paragraph )Text ()string {return _eeabb ._cffc };func (_cffa *templateProcessor )parseFontAttr (_cageb ,_gdfg string )*_ed .PdfFont {_de .Log .Debug ("P\u0061\u0072\u0073\u0069\u006e\u0067 \u0066\u006f\u006e\u0074\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065:\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_cageb ,_gdfg );
_ddedb :=_cffa .creator ._efa ;if _gdfg ==""{return _ddedb ;};_gcbb :=_ae .Split (_gdfg ,"\u002c");for _ ,_dafcc :=range _gcbb {_dafcc =_ae .TrimSpace (_dafcc );if _dafcc ==""{continue ;};_eeebe ,_ffaaa :=_cffa ._afgab .FontMap [_gdfg ];if _ffaaa {return _eeebe ;
};_bdegf ,_ffaaa :=map[string ]_ed .StdFontName {"\u0063o\u0075\u0072\u0069\u0065\u0072":_ed .CourierName ,"\u0063\u006f\u0075r\u0069\u0065\u0072\u002d\u0062\u006f\u006c\u0064":_ed .CourierBoldName ,"\u0063o\u0075r\u0069\u0065\u0072\u002d\u006f\u0062\u006c\u0069\u0071\u0075\u0065":_ed .CourierObliqueName ,"c\u006fu\u0072\u0069\u0065\u0072\u002d\u0062\u006f\u006cd\u002d\u006f\u0062\u006ciq\u0075\u0065":_ed .CourierBoldObliqueName ,"\u0068e\u006c\u0076\u0065\u0074\u0069\u0063a":_ed .HelveticaName ,"\u0068\u0065\u006c\u0076\u0065\u0074\u0069\u0063\u0061-\u0062\u006f\u006c\u0064":_ed .HelveticaBoldName ,"\u0068\u0065\u006c\u0076\u0065\u0074\u0069\u0063\u0061\u002d\u006f\u0062l\u0069\u0071\u0075\u0065":_ed .HelveticaObliqueName ,"\u0068\u0065\u006c\u0076et\u0069\u0063\u0061\u002d\u0062\u006f\u006c\u0064\u002d\u006f\u0062\u006c\u0069\u0071u\u0065":_ed .HelveticaBoldObliqueName ,"\u0073\u0079\u006d\u0062\u006f\u006c":_ed .SymbolName ,"\u007a\u0061\u0070\u0066\u002d\u0064\u0069\u006e\u0067\u0062\u0061\u0074\u0073":_ed .ZapfDingbatsName ,"\u0074\u0069\u006de\u0073":_ed .TimesRomanName ,"\u0074\u0069\u006d\u0065\u0073\u002d\u0062\u006f\u006c\u0064":_ed .TimesBoldName ,"\u0074\u0069\u006de\u0073\u002d\u0069\u0074\u0061\u006c\u0069\u0063":_ed .TimesItalicName ,"\u0074\u0069\u006d\u0065\u0073\u002d\u0062\u006f\u006c\u0064\u002d\u0069t\u0061\u006c\u0069\u0063":_ed .TimesBoldItalicName }[_gdfg ];
if _ffaaa {if _ffcea ,_bacegg :=_ed .NewStandard14Font (_bdegf );_bacegg ==nil {return _ffcea ;};};if _gecg :=_cffa .parseAttrPropList (_dafcc );len (_gecg )> 0{if _eeefa ,_bacce :=_gecg ["\u0070\u0061\u0074\u0068"];_bacce {_acef :=_ed .NewPdfFontFromTTFFile ;
if _efae ,_efbf :=_gecg ["\u0074\u0079\u0070\u0065"];_efbf &&_efae =="\u0063o\u006d\u0070\u006f\u0073\u0069\u0074e"{_acef =_ed .NewCompositePdfFontFromTTFFile ;};if _eefae ,_gedeg :=_acef (_eeefa );_gedeg !=nil {_de .Log .Debug ("\u0043\u006fu\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u006c\u006f\u0061\u0064\u0020\u0066\u006f\u006e\u0074\u0020\u0060\u0025\u0073\u0060\u003a %\u0076\u002e",_eeefa ,_gedeg );
}else {return _eefae ;};};};};return _ddedb ;};func _cfeeb (_dageg *_ed .PdfAnnotationLink )*_ed .PdfAnnotationLink {if _dageg ==nil {return nil ;};_dafedf :=_ed .NewPdfAnnotationLink ();_dafedf .BS =_dageg .BS ;_dafedf .A =_dageg .A ;if _fbdg ,_fdfbg :=_dageg .GetAction ();
_fdfbg ==nil &&_fbdg !=nil {_dafedf .SetAction (_fbdg );};if _afdc ,_dedce :=_dageg .Dest .(*_gg .PdfObjectArray );_dedce {_dafedf .Dest =_gg .MakeArray (_afdc .Elements ()...);};return _dafedf ;};func (_gdaae *Table )moveToNextAvailableCell ()int {_gegg :=(_gdaae ._cbae -1)%(_gdaae ._efefg )+1;
for {if _gegg -1>=len (_gdaae ._bage ){return _gegg ;}else if _gdaae ._bage [_gegg -1]==0{return _gegg ;}else {_gdaae ._cbae ++;_gdaae ._bage [_gegg -1]--;};_gegg ++;};};func (_edbca *Creator )getActivePage ()*_ed .PdfPage {if _edbca ._gbc ==nil {if len (_edbca ._fae )==0{return nil ;
};return _edbca ._fae [len (_edbca ._fae )-1];};return _edbca ._gbc ;};

// SetMargins sets the Block's left, right, top, bottom, margins.
func (_cb *Block )SetMargins (left ,right ,top ,bottom float64 ){_cb ._dg .Left =left ;_cb ._dg .Right =right ;_cb ._dg .Top =top ;_cb ._dg .Bottom =bottom ;};func (_faef *templateProcessor )run ()error {_dafed :=_ag .NewDecoder (_ab .NewReader (_faef ._afbd ));
var _ffead *templateNode ;for {_dedegf ,_aadbf :=_dafed .Token ();if _aadbf !=nil {if _aadbf ==_e .EOF {return nil ;};return _aadbf ;};if _dedegf ==nil {break ;};switch _cbacd :=_dedegf .(type ){case _ag .StartElement :_de .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006eg\u0020\u0074\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u0073\u0074\u0061r\u0074\u0020\u0074\u0061\u0067\u003a\u0020`\u0025\u0073\u0060\u002e",_cbacd .Name .Local );
_cdac ,_cedcc :=_bagba [_cbacd .Name .Local ];if !_cedcc {_de .Log .Debug ("\u0055\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u006d\u0070\u006c\u0061\u0074\u0065\u0020\u0074a\u0067\u003a\u0020\u0060\u0025\u0073`\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e\u0020\u004f\u0075t\u0070\u0075t\u0020\u006d\u0061\u0079 \u0062\u0065\u0020\u0069\u006ec\u006f\u0072\u0072\u0065\u0063\u0074\u002e",_cbacd .Name .Local );
continue ;};_ffead =&templateNode {_fcdbfb :_cbacd ,_abgba :_ffead };if _ceccg :=_cdac ._accc ;_ceccg !=nil {_ffead ._defd ,_aadbf =_ceccg (_faef ,_ffead );if _aadbf !=nil {return _aadbf ;};};case _ag .EndElement :_de .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020t\u0065\u006d\u0070\u006c\u0061\u0074\u0065 \u0065\u006e\u0064\u0020\u0074\u0061\u0067\u003a\u0020\u0060\u0025\u0073\u0060\u002e",_cbacd .Name .Local );
if _ffead !=nil {if _ffead ._defd !=nil {if _gggbg :=_faef .renderNode (_ffead );_gggbg !=nil {return _gggbg ;};};_ffead =_ffead ._abgba ;};case _ag .CharData :if _ffead !=nil &&_ffead ._defd !=nil {if _afgga :=_faef .addNodeText (_ffead ,string (_cbacd ));
_afgga !=nil {return _afgga ;};};case _ag .Comment :_de .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020t\u0065\u006d\u0070\u006c\u0061\u0074\u0065 \u0063\u006f\u006d\u006d\u0065\u006e\u0074\u003a\u0020\u0060\u0025\u0073\u0060\u002e",string (_cbacd ));
};};return nil ;};func (_cddb *templateProcessor )parseParagraph (_dgcae *templateNode ,_gbegf *Paragraph )(interface{},error ){if _gbegf ==nil {_gbegf =_cddb .creator .NewParagraph ("");};for _ ,_ccdb :=range _dgcae ._fcdbfb .Attr {_edbea :=_ccdb .Value ;
switch _eefbc :=_ccdb .Name .Local ;_eefbc {case "\u0066\u006f\u006e\u0074":_gbegf .SetFont (_cddb .parseFontAttr (_eefbc ,_edbea ));case "\u0066o\u006e\u0074\u002d\u0073\u0069\u007ae":_gbegf .SetFontSize (_cddb .parseFloatAttr (_eefbc ,_edbea ));case "\u0074\u0065\u0078\u0074\u002d\u0061\u006c\u0069\u0067\u006e":_gbegf .SetTextAlignment (_cddb .parseTextAlignmentAttr (_eefbc ,_edbea ));
case "l\u0069\u006e\u0065\u002d\u0068\u0065\u0069\u0067\u0068\u0074":_gbegf .SetLineHeight (_cddb .parseFloatAttr (_eefbc ,_edbea ));case "e\u006e\u0061\u0062\u006c\u0065\u002d\u0077\u0072\u0061\u0070":_gbegf .SetEnableWrap (_cddb .parseBoolAttr (_eefbc ,_edbea ));
case "\u0063\u006f\u006co\u0072":_gbegf .SetColor (_cddb .parseColorAttr (_eefbc ,_edbea ));case "\u0078":_gbegf .SetPos (_cddb .parseFloatAttr (_eefbc ,_edbea ),_gbegf ._cbcaf );case "\u0079":_gbegf .SetPos (_gbegf ._fgef ,_cddb .parseFloatAttr (_eefbc ,_edbea ));
case "\u0061\u006e\u0067l\u0065":_gbegf .SetAngle (_cddb .parseFloatAttr (_eefbc ,_edbea ));case "\u006d\u0061\u0072\u0067\u0069\u006e":_dcab :=_cddb .parseMarginAttr (_eefbc ,_edbea );_gbegf .SetMargins (_dcab .Left ,_dcab .Right ,_dcab .Top ,_dcab .Bottom );
case "\u006da\u0078\u002d\u006c\u0069\u006e\u0065s":_gbegf .SetMaxLines (int (_cddb .parseInt64Attr (_eefbc ,_edbea )));default:_de .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072t\u0065\u0064\u0020pa\u0072\u0061\u0067\u0072\u0061\u0070h\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073`\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069n\u0067\u002e",_eefbc );
};};return _gbegf ,nil ;};

// Width is not used. The list component is designed to fill into the available
// width depending on the context. Returns 0.
func (_ccbe *List )Width ()float64 {return 0};

// GeneratePageBlocks generates a page break block.
func (_gdbb *PageBreak )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_abdgc :=[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y ),NewBlock (ctx .PageWidth ,ctx .PageHeight )};ctx .Page ++;_daba :=ctx ;_daba .Y =ctx .Margins .Top ;
_daba .X =ctx .Margins .Left ;_daba .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom ;_daba .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right ;ctx =_daba ;return _abdgc ,ctx ,nil ;};

// SetBorderColor sets the border color of the ellipse.
func (_fefe *Ellipse )SetBorderColor (col Color ){_fefe ._facc =col };

// InvoiceCell represents any cell belonging to a table from the invoice
// template. The main tables are the invoice information table, the line
// items table and totals table. Contains the text value of the cell and
// the style properties of the cell.
type InvoiceCell struct{InvoiceCellProps ;Value string ;};

// SkipOver skips over a specified number of rows and cols.
func (_cfecf *Table )SkipOver (rows ,cols int ){_fddcg :=rows *_cfecf ._efefg +cols -1;if _fddcg < 0{_de .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};_cfecf ._cbae +=_fddcg ;};

// SetAddressHeadingStyle sets the style properties used to render the
// heading of the invoice address sections.
func (_aegg *Invoice )SetAddressHeadingStyle (style TextStyle ){_aegg ._dcd =style };

// SetLink makes the line an internal link.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
func (_gdca *TOCLine )SetLink (page int64 ,x ,y float64 ){_gdca ._dfcb =x ;_gdca ._bdgff =y ;_gdca ._cfcb =page ;_aagc :=_gdca ._ddaf ._feada .Color ;_gdca .Number .Style .Color =_aagc ;_gdca .Title .Style .Color =_aagc ;_gdca .Separator .Style .Color =_aagc ;
_gdca .Page .Style .Color =_aagc ;};func _dcfa (_gac *_da .ContentStreamOperations ,_cbg *_ed .PdfPageResources ,_ffg *_da .ContentStreamOperations ,_dgd *_ed .PdfPageResources )error {_bgd :=map[_gg .PdfObjectName ]_gg .PdfObjectName {};_cag :=map[_gg .PdfObjectName ]_gg .PdfObjectName {};
_defg :=map[_gg .PdfObjectName ]_gg .PdfObjectName {};_acd :=map[_gg .PdfObjectName ]_gg .PdfObjectName {};_bab :=map[_gg .PdfObjectName ]_gg .PdfObjectName {};_ada :=map[_gg .PdfObjectName ]_gg .PdfObjectName {};for _ ,_gfd :=range *_ffg {switch _gfd .Operand {case "\u0044\u006f":if len (_gfd .Params )==1{if _cfac ,_dgc :=_gfd .Params [0].(*_gg .PdfObjectName );
_dgc {if _ ,_aea :=_bgd [*_cfac ];!_aea {var _ecf _gg .PdfObjectName ;_ffb ,_ :=_dgd .GetXObjectByName (*_cfac );if _ffb !=nil {_ecf =*_cfac ;for {_fff ,_ :=_cbg .GetXObjectByName (_ecf );if _fff ==nil ||_fff ==_ffb {break ;};_ecf =_ecf +"\u0030";};};_cbg .SetXObjectByName (_ecf ,_ffb );
_bgd [*_cfac ]=_ecf ;};_eda :=_bgd [*_cfac ];_gfd .Params [0]=&_eda ;};};case "\u0054\u0066":if len (_gfd .Params )==2{if _cbd ,_cafg :=_gfd .Params [0].(*_gg .PdfObjectName );_cafg {if _ ,_cdf :=_cag [*_cbd ];!_cdf {_dfa ,_aa :=_dgd .GetFontByName (*_cbd );
_dcfd :=*_cbd ;if _aa &&_dfa !=nil {_dcfd =_bba (_cbd .String (),_dfa ,_cbg );};_cbg .SetFontByName (_dcfd ,_dfa );_cag [*_cbd ]=_dcfd ;};_bbb :=_cag [*_cbd ];_gfd .Params [0]=&_bbb ;};};case "\u0043\u0053","\u0063\u0073":if len (_gfd .Params )==1{if _gbg ,_ebc :=_gfd .Params [0].(*_gg .PdfObjectName );
_ebc {if _ ,_bge :=_defg [*_gbg ];!_bge {var _gga _gg .PdfObjectName ;_bec ,_babd :=_dgd .GetColorspaceByName (*_gbg );if _babd {_gga =*_gbg ;for {_cgc ,_dfd :=_cbg .GetColorspaceByName (_gga );if !_dfd ||_bec ==_cgc {break ;};_gga =_gga +"\u0030";};_cbg .SetColorspaceByName (_gga ,_bec );
_defg [*_gbg ]=_gga ;}else {_de .Log .Debug ("C\u006fl\u006f\u0072\u0073\u0070\u0061\u0063\u0065\u0020n\u006f\u0074\u0020\u0066ou\u006e\u0064");};};if _edaa ,_ddd :=_defg [*_gbg ];_ddd {_gfd .Params [0]=&_edaa ;}else {_de .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0043\u006f\u006co\u0072\u0073\u0070\u0061\u0063\u0065\u0020%\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064",*_gbg );
};};};case "\u0053\u0043\u004e","\u0073\u0063\u006e":if len (_gfd .Params )==1{if _edac ,_egf :=_gfd .Params [0].(*_gg .PdfObjectName );_egf {if _ ,_gaab :=_acd [*_edac ];!_gaab {var _acf _gg .PdfObjectName ;_fcg ,_ccf :=_dgd .GetPatternByName (*_edac );
if _ccf {_acf =*_edac ;for {_dedb ,_agc :=_cbg .GetPatternByName (_acf );if !_agc ||_dedb ==_fcg {break ;};_acf =_acf +"\u0030";};_fce :=_cbg .SetPatternByName (_acf ,_fcg .ToPdfObject ());if _fce !=nil {return _fce ;};_acd [*_edac ]=_acf ;};};if _ffgf ,_cae :=_acd [*_edac ];
_cae {_gfd .Params [0]=&_ffgf ;};};};case "\u0073\u0068":if len (_gfd .Params )==1{if _gaf ,_aga :=_gfd .Params [0].(*_gg .PdfObjectName );_aga {if _ ,_eec :=_bab [*_gaf ];!_eec {var _cgbd _gg .PdfObjectName ;_ede ,_fge :=_dgd .GetShadingByName (*_gaf );
if _fge {_cgbd =*_gaf ;for {_eeg ,_gfb :=_cbg .GetShadingByName (_cgbd );if !_gfb ||_ede ==_eeg {break ;};_cgbd =_cgbd +"\u0030";};_fef :=_cbg .SetShadingByName (_cgbd ,_ede .ToPdfObject ());if _fef !=nil {_de .Log .Debug ("E\u0052\u0052\u004f\u0052 S\u0065t\u0020\u0073\u0068\u0061\u0064i\u006e\u0067\u003a\u0020\u0025\u0076",_fef );
return _fef ;};_bab [*_gaf ]=_cgbd ;}else {_de .Log .Debug ("\u0053\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};};if _agca ,_fac :=_bab [*_gaf ];_fac {_gfd .Params [0]=&_agca ;}else {_de .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020S\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u0025\u0073 \u006e\u006f\u0074 \u0066o\u0075\u006e\u0064",*_gaf );
};};};case "\u0067\u0073":if len (_gfd .Params )==1{if _fcb ,_dbcc :=_gfd .Params [0].(*_gg .PdfObjectName );_dbcc {if _ ,_dfg :=_ada [*_fcb ];!_dfg {var _eae _gg .PdfObjectName ;_eed ,_aba :=_dgd .GetExtGState (*_fcb );if _aba {_eae =*_fcb ;_fcc :=1;for {_ccd ,_bdg :=_cbg .GetExtGState (_eae );
if !_bdg ||_eed ==_ccd {break ;};_eae =_gg .PdfObjectName (_fe .Sprintf ("\u0047\u0053\u0025\u0064",_fcc ));_fcc ++;};};_cbg .AddExtGState (_eae ,_eed );_ada [*_fcb ]=_eae ;};_dgb :=_ada [*_fcb ];_gfd .Params [0]=&_dgb ;};};};*_gac =append (*_gac ,_gfd );
};return nil ;};

// LinearShading holds data for rendering a linear shading gradient.
type LinearShading struct{_cecc *shading ;_dfagf *_ed .PdfRectangle ;_gbcee float64 ;_dee bool ;};

// GetMargins returns the Block's margins: left, right, top, bottom.
func (_dce *Block )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _dce ._dg .Left ,_dce ._dg .Right ,_dce ._dg .Top ,_dce ._dg .Bottom ;};func (_accf *StyledParagraph )getMaxLineWidth ()float64 {if _accf ._fgbg ==nil ||len (_accf ._fgbg )==0{_accf .wrapText ();
};var _edfed float64 ;for _ ,_fbbd :=range _accf ._fgbg {_geegg :=_accf .getTextLineWidth (_fbbd );if _geegg > _edfed {_edfed =_geegg ;};};return _edfed ;};

// Scale sets the scale ratio with `X` factor and `Y` factor for the graphic svg.
func (_bcgf *GraphicSVG )Scale (xFactor ,yFactor float64 ){_bcgf ._ebgg .Width =xFactor *_bcgf ._ebgg .Width ;_bcgf ._ebgg .Height =yFactor *_bcgf ._ebgg .Height ;_bcgf ._ebgg .SetScaling (xFactor ,yFactor );};

// Chapter is used to arrange multiple drawables (paragraphs, images, etc) into a single section.
// The concept is the same as a book or a report chapter.
type Chapter struct{_gaaa int ;_aae string ;_cff *Paragraph ;_eded []Drawable ;_dega int ;_gae bool ;_efgd bool ;_ceag Positioning ;_adg ,_feg float64 ;_eeeg Margins ;_cdgd *Chapter ;_afg *TOC ;_dae *_ed .Outline ;_ggff *_ed .OutlineItem ;_ceec uint ;};


// DueDate returns the invoice due date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_bgec *Invoice )DueDate ()(*InvoiceCell ,*InvoiceCell ){return _bgec ._facg [0],_bgec ._facg [1]};

// AddPatternResource adds pattern dictionary inside the resources dictionary.
func (_bgcbc *RadialShading )AddPatternResource (block *Block )(_efdc _gg .PdfObjectName ,_dffca error ){_bcbg :=1;_gcgf :=_gg .PdfObjectName ("\u0050"+_df .Itoa (_bcbg ));for block ._bf .HasPatternByName (_gcgf ){_bcbg ++;_gcgf =_gg .PdfObjectName ("\u0050"+_df .Itoa (_bcbg ));
};if _feaa :=block ._bf .SetPatternByName (_gcgf ,_bgcbc .ToPdfShadingPattern ().ToPdfObject ());_feaa !=nil {return "",_feaa ;};return _gcgf ,nil ;};

// ColorCMYKFrom8bit creates a Color from c,m,y,k values (0-100).
// Example:
//   red := ColorCMYKFrom8Bit(0, 100, 100, 0)
func ColorCMYKFrom8bit (c ,m ,y ,k byte )Color {return cmykColor {_bca :_gd .Min (float64 (c ),100)/100.0,_cdgdd :_gd .Min (float64 (m ),100)/100.0,_cebb :_gd .Min (float64 (y ),100)/100.0,_dfbe :_gd .Min (float64 (k ),100)/100.0};};

// SetBorderColor sets border color of the rectangle.
func (_caaed *Rectangle )SetBorderColor (col Color ){_caaed ._dca =col };

// Division is a container component which can wrap across multiple pages.
// Currently supported drawable components:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
//
// The component stacking behavior is vertical, where the drawables are drawn
// on top of each other.
type Division struct{_cfadf []VectorDrawable ;_bbgd Positioning ;_ccad Margins ;_cacc Margins ;_fbaa bool ;_ceab bool ;_dbce *Background ;};

// AddSection adds a new content section at the end of the invoice.
func (_befcb *Invoice )AddSection (title ,content string ){_befcb ._gddb =append (_befcb ._gddb ,[2]string {title ,content });};

// CurRow returns the currently active cell's row number.
func (_dgdag *Table )CurRow ()int {_aegbd :=(_dgdag ._cbae -1)/_dgdag ._efefg +1;return _aegbd };

// SetSideBorderWidth sets the cell's side border width.
func (_egbdf *TableCell )SetSideBorderWidth (side CellBorderSide ,width float64 ){switch side {case CellBorderSideAll :_egbdf ._aedea =width ;_egbdf ._ecgbf =width ;_egbdf ._cfdac =width ;_egbdf ._efbec =width ;case CellBorderSideTop :_egbdf ._aedea =width ;
case CellBorderSideBottom :_egbdf ._ecgbf =width ;case CellBorderSideLeft :_egbdf ._cfdac =width ;case CellBorderSideRight :_egbdf ._efbec =width ;};};

// Creator is a wrapper around functionality for creating PDF reports and/or adding new
// content onto imported PDF pages, etc.
type Creator struct{

// Errors keeps error messages that should not interrupt pdf processing and to be checked later.
Errors []error ;

// UnsupportedCharacterReplacement is character that will be used to replace unsupported glyph.
// The value will be passed to drawing context.
UnsupportedCharacterReplacement rune ;_fae []*_ed .PdfPage ;_ffgd map[*_ed .PdfPage ]*Block ;_abcf map[*_ed .PdfPage ]*pageTransformations ;_gbc *_ed .PdfPage ;_cfc PageSize ;_fafg DrawContext ;_bffb Margins ;_dea ,_bgfe float64 ;_bbcd int ;_aeaf func (_cgeg FrontpageFunctionArgs );
_ceba func (_faca *TOC )error ;_baab func (_bcg *Block ,_ecbe HeaderFunctionArgs );_eagb func (_bbad *Block ,_agfc FooterFunctionArgs );_fbbf func (_ddb PageFinalizeFunctionArgs )error ;_eeb func (_agce *_ed .PdfWriter )error ;_adgb bool ;

// Controls whether a table of contents will be generated.
AddTOC bool ;

// CustomTOC specifies if the TOC is rendered by the user.
// When the `CustomTOC` field is set to `true`, the default TOC component is not rendered.
// Instead the TOC is drawn by the user, in the callback provided to
// the `Creator.CreateTableOfContents` method.
// If `CustomTOC` is set to `false`, the callback provided to
// `Creator.CreateTableOfContents` customizes the style of the automatically generated TOC component.
CustomTOC bool ;_cgec *TOC ;

// Controls whether outlines will be generated.
AddOutlines bool ;_cac *_ed .Outline ;_gdfe *_ed .PdfOutlineTreeNode ;_cadd *_ed .PdfAcroForm ;_efbd _gg .PdfObject ;_cfad _ed .Optimizer ;_gfe []*_ed .PdfFont ;_efa *_ed .PdfFont ;_dcef *_ed .PdfFont ;};

// FitMode returns the fit mode of the image.
func (_ebgda *Image )FitMode ()FitMode {return _ebgda ._fdgd };

// GetCoords returns the center coordinates of ellipse (`xc`, `yc`).
func (_cbab *Ellipse )GetCoords ()(float64 ,float64 ){return _cbab ._ggceg ,_cbab ._ecd };

// SetPositioning sets the positioning of the rectangle (absolute or relative).
func (_agcg *Rectangle )SetPositioning (position Positioning ){_agcg ._dded =position };

// NewCurvePolygon creates a new curve polygon.
func (_acab *Creator )NewCurvePolygon (rings [][]_bc .CubicBezierCurve )*CurvePolygon {return _edbb (rings );};

// Width returns the width of the graphic svg.
func (_acdac *GraphicSVG )Width ()float64 {return _acdac ._ebgg .Width };func (_bdegc *TemplateOptions )init (){if _bdegc .FontMap ==nil {_bdegc .FontMap =map[string ]*_ed .PdfFont {};};if _bdegc .ImageMap ==nil {_bdegc .ImageMap =map[string ]*_ed .Image {};
};if _bdegc .ColorMap ==nil {_bdegc .ColorMap =map[string ]Color {};};if _bdegc .ChartMap ==nil {_bdegc .ChartMap =map[string ]_b .ChartRenderable {};};};

// SetWidth set the Image's document width to specified w. This does not change the raw image data, i.e.
// no actual scaling of data is performed. That is handled by the PDF viewer.
func (_ggegb *Image )SetWidth (w float64 ){_ggegb ._deac =w };

// GetOptimizer returns current PDF optimizer.
func (_gfgc *Creator )GetOptimizer ()_ed .Optimizer {return _gfgc ._cfad };const (TextRenderingModeFill TextRenderingMode =iota ;TextRenderingModeStroke ;TextRenderingModeFillStroke ;TextRenderingModeInvisible ;TextRenderingModeFillClip ;TextRenderingModeStrokeClip ;
TextRenderingModeFillStrokeClip ;TextRenderingModeClip ;);

// SetMargins sets the margins of the line.
// NOTE: line margins are only applied if relative positioning is used.
func (_fgdeb *Line )SetMargins (left ,right ,top ,bottom float64 ){_fgdeb ._fgddg .Left =left ;_fgdeb ._fgddg .Right =right ;_fgdeb ._fgddg .Top =top ;_fgdeb ._fgddg .Bottom =bottom ;};

// BorderOpacity returns the border opacity of the ellipse (0-1).
func (_dgga *Ellipse )BorderOpacity ()float64 {return _dgga ._eega };

// GeneratePageBlocks draws the composite Bezier curve on a new block
// representing the page. Implements the Drawable interface.
func (_bbbc *PolyBezierCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_gcgcf :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_baaab ,_aecc :=_gcgcf .setOpacity (_bbbc ._gefcb ,_bbbc ._cbac );if _aecc !=nil {return nil ,ctx ,_aecc ;
};_fgdge :=_bbbc ._adac ;_fgdge .FillEnabled =_fgdge .FillColor !=nil ;var (_geab =ctx .PageHeight ;_ebcd =_fgdge .Curves ;_ggca =make ([]_bc .CubicBezierCurve ,0,len (_fgdge .Curves )););_egcf :=_ed .PdfRectangle {};for _egfb :=range _fgdge .Curves {_begd :=_ebcd [_egfb ];
_begd .P0 .Y =_geab -_begd .P0 .Y ;_begd .P1 .Y =_geab -_begd .P1 .Y ;_begd .P2 .Y =_geab -_begd .P2 .Y ;_begd .P3 .Y =_geab -_begd .P3 .Y ;_ggca =append (_ggca ,_begd );_abed :=_begd .GetBounds ();if _egfb ==0{_egcf =_abed ;}else {_egcf .Llx =_gd .Min (_egcf .Llx ,_abed .Llx );
_egcf .Lly =_gd .Min (_egcf .Lly ,_abed .Lly );_egcf .Urx =_gd .Max (_egcf .Urx ,_abed .Urx );_egcf .Ury =_gd .Max (_egcf .Ury ,_abed .Ury );};};_fgdge .Curves =_ggca ;defer func (){_fgdge .Curves =_ebcd }();if _fgdge .FillEnabled {_gabea :=_abfb (_gcgcf ,_bbbc ._adac .FillColor ,_bbbc ._ebebe ,func ()Rectangle {return Rectangle {_eadb :_egcf .Llx ,_accbb :_egcf .Lly ,_egbf :_egcf .Width (),_agadf :_egcf .Height ()};
});if _gabea !=nil {return nil ,ctx ,_gabea ;};};_bdca ,_ ,_aecc :=_fgdge .Draw (_baaab );if _aecc !=nil {return nil ,ctx ,_aecc ;};if _aecc =_gcgcf .addContentsByString (string (_bdca ));_aecc !=nil {return nil ,ctx ,_aecc ;};return []*Block {_gcgcf },ctx ,nil ;
};

// Width returns Image's document width.
func (_dbdb *Image )Width ()float64 {return _dbdb ._deac };

// Polyline represents a slice of points that are connected as straight lines.
// Implements the Drawable interface and can be rendered using the Creator.
type Polyline struct{_afgc *_bc .Polyline ;_eacac float64 ;};

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_ecce *StyledParagraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _ecce ._bgac .Left ,_ecce ._bgac .Right ,_ecce ._bgac .Top ,_ecce ._bgac .Bottom ;};

// LineWidth returns the width of the line.
func (_ecfc *Line )LineWidth ()float64 {return _ecfc ._cdbc };

// Finalize renders all blocks to the creator pages. In addition, it takes care
// of adding headers and footers, as well as generating the front page,
// table of contents and outlines.
// Finalize is automatically called before writing the document out. Calling the
// method manually can be useful when adding external pages to the creator,
// using the AddPage method, as it renders all creator blocks to the added
// pages, without having to write the document out.
// NOTE: TOC and outlines are generated only if the AddTOC and AddOutlines
// fields of the creator are set to true (enabled by default). Furthermore, TOCs
// and outlines without content are skipped. TOC and outline content is
// added automatically when using the chapter component. TOCs and outlines can
// also be set externally, using the SetTOC and SetOutlineTree methods.
// Finalize should only be called once, after all draw calls have taken place,
// as it will return immediately if the creator instance has been finalized.
func (_bcc *Creator )Finalize ()error {if _bcc ._adgb {return nil ;};_cbdc :=len (_bcc ._fae );_gfca :=0;if _bcc ._aeaf !=nil {_aaa :=*_bcc ;_bcc ._fae =nil ;_bcc ._gbc =nil ;_bcc .initContext ();_fgbc :=FrontpageFunctionArgs {PageNum :1,TotalPages :_cbdc };
_bcc ._aeaf (_fgbc );_gfca +=len (_bcc ._fae );_bcc ._fae =_aaa ._fae ;_bcc ._gbc =_aaa ._gbc ;};if _bcc .AddTOC {_bcc .initContext ();_bcc ._fafg .Page =_gfca +1;if _bcc .CustomTOC &&_bcc ._ceba !=nil {_gag :=*_bcc ;_bcc ._fae =nil ;_bcc ._gbc =nil ;if _agfg :=_bcc ._ceba (_bcc ._cgec );
_agfg !=nil {return _agfg ;};_gfca +=len (_bcc ._fae );_bcc ._fae =_gag ._fae ;_bcc ._gbc =_gag ._gbc ;}else {if _bcc ._ceba !=nil {if _egff :=_bcc ._ceba (_bcc ._cgec );_egff !=nil {return _egff ;};};_bdafg ,_ ,_edgd :=_bcc ._cgec .GeneratePageBlocks (_bcc ._fafg );
if _edgd !=nil {_de .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073: \u0025\u0076",_edgd );return _edgd ;};_gfca +=len (_bdafg );};_gbe :=_bcc ._cgec .Lines ();
for _ ,_gaabf :=range _gbe {_deab ,_ffbb :=_df .Atoi (_gaabf .Page .Text );if _ffbb !=nil {continue ;};_gaabf .Page .Text =_df .Itoa (_deab +_gfca );_gaabf ._cfcb +=int64 (_gfca );};};_ebge :=false ;var _fedg []*_ed .PdfPage ;if _bcc ._aeaf !=nil {_fged :=*_bcc ;
_bcc ._fae =nil ;_bcc ._gbc =nil ;_gacg :=FrontpageFunctionArgs {PageNum :1,TotalPages :_cbdc };_bcc ._aeaf (_gacg );_cbdc +=len (_bcc ._fae );_fedg =_bcc ._fae ;_bcc ._fae =append (_bcc ._fae ,_fged ._fae ...);_bcc ._gbc =_fged ._gbc ;_ebge =true ;};var _ggbb []*_ed .PdfPage ;
if _bcc .AddTOC {_bcc .initContext ();if _bcc .CustomTOC &&_bcc ._ceba !=nil {_dgf :=*_bcc ;_bcc ._fae =nil ;_bcc ._gbc =nil ;if _efab :=_bcc ._ceba (_bcc ._cgec );_efab !=nil {_de .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074i\u006e\u0067\u0020\u0054\u004f\u0043\u003a\u0020\u0025\u0076",_efab );
return _efab ;};_ggbb =_bcc ._fae ;_cbdc +=len (_ggbb );_bcc ._fae =_dgf ._fae ;_bcc ._gbc =_dgf ._gbc ;}else {if _bcc ._ceba !=nil {if _ddcf :=_bcc ._ceba (_bcc ._cgec );_ddcf !=nil {_de .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074i\u006e\u0067\u0020\u0054\u004f\u0043\u003a\u0020\u0025\u0076",_ddcf );
return _ddcf ;};};_ggffe ,_ ,_ :=_bcc ._cgec .GeneratePageBlocks (_bcc ._fafg );for _ ,_fgdg :=range _ggffe {_fgdg .SetPos (0,0);_cbdc ++;_bfea :=_bcc .newPage ();_ggbb =append (_ggbb ,_bfea );_bcc .setActivePage (_bfea );_bcc .Draw (_fgdg );};};if _ebge {_gbge :=_fedg ;
_cfdg :=_bcc ._fae [len (_fedg ):];_bcc ._fae =append ([]*_ed .PdfPage {},_gbge ...);_bcc ._fae =append (_bcc ._fae ,_ggbb ...);_bcc ._fae =append (_bcc ._fae ,_cfdg ...);}else {_bcc ._fae =append (_ggbb ,_bcc ._fae ...);};};if _bcc ._cac !=nil &&_bcc .AddOutlines {var _egac func (_gef *_ed .OutlineItem );
_egac =func (_bfaf *_ed .OutlineItem ){_bfaf .Dest .Page +=int64 (_gfca );if _adfb :=int (_bfaf .Dest .Page );_adfb >=0&&_adfb < len (_bcc ._fae ){_bfaf .Dest .PageObj =_bcc ._fae [_adfb ].GetPageAsIndirectObject ();}else {_de .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_adfb );
};_bfaf .Dest .Y =_bcc ._bgfe -_bfaf .Dest .Y ;_dfaa :=_bfaf .Items ();for _ ,_bgde :=range _dfaa {_egac (_bgde );};};_dff :=_bcc ._cac .Items ();for _ ,_bfefd :=range _dff {_egac (_bfefd );};if _bcc .AddTOC {var _ccb int ;if _ebge {_ccb =len (_fedg );
};_aff :=_ed .NewOutlineDest (int64 (_ccb ),0,_bcc ._bgfe );if _ccb >=0&&_ccb < len (_bcc ._fae ){_aff .PageObj =_bcc ._fae [_ccb ].GetPageAsIndirectObject ();}else {_de .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_ccb );
};_bcc ._cac .Insert (0,_ed .NewOutlineItem ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073",_aff ));};};for _fgbf ,_fee :=range _bcc ._fae {_bcc .setActivePage (_fee );if _bcc ._fbbf !=nil {_gcfg ,_cec ,_bgca :=_fee .Size ();
if _bgca !=nil {return _bgca ;};_fafe :=PageFinalizeFunctionArgs {PageNum :_fgbf +1,PageWidth :_gcfg ,PageHeight :_cec ,TOCPages :len (_ggbb ),TotalPages :_cbdc };if _bdbf :=_bcc ._fbbf (_fafe );_bdbf !=nil {_de .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0070\u0061\u0067\u0065\u0020\u0066\u0069\u006e\u0061\u006c\u0069\u007a\u0065 \u0063\u0061\u006c\u006c\u0062\u0061\u0063k\u003a\u0020\u0025\u0076",_bdbf );
return _bdbf ;};};if _bcc ._baab !=nil {_fga :=NewBlock (_bcc ._dea ,_bcc ._bffb .Top );_gcc :=HeaderFunctionArgs {PageNum :_fgbf +1,TotalPages :_cbdc };_bcc ._baab (_fga ,_gcc );_fga .SetPos (0,0);if _ace :=_bcc .Draw (_fga );_ace !=nil {_de .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0068e\u0061\u0064\u0065\u0072\u003a\u0020\u0025v",_ace );
return _ace ;};};if _bcc ._eagb !=nil {_bfbb :=NewBlock (_bcc ._dea ,_bcc ._bffb .Bottom );_dfeb :=FooterFunctionArgs {PageNum :_fgbf +1,TotalPages :_cbdc };_bcc ._eagb (_bfbb ,_dfeb );_bfbb .SetPos (0,_bcc ._bgfe -_bfbb ._fc );if _eacc :=_bcc .Draw (_bfbb );
_eacc !=nil {_de .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0066o\u006f\u0074\u0065\u0072\u003a\u0020\u0025v",_eacc );return _eacc ;};};_gcac ,_acbe :=_bcc ._abcf [_fee ];if _afff ,_aeb :=_bcc ._ffgd [_fee ];_aeb {if _acbe {_gcac .transformBlock (_afff );
};if _fabf :=_afff .drawToPage (_fee );_fabf !=nil {_de .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069\u006e\u0067\u0020\u0070\u0061\u0067\u0065\u0020%\u0064\u0020\u0062\u006c\u006f\u0063\u006bs\u003a\u0020\u0025\u0076",_fgbf +1,_fabf );
return _fabf ;};};if _acbe {if _dbgf :=_gcac .transformPage (_fee );_dbgf !=nil {_de .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020c\u006f\u0075\u006c\u0064\u0020\u006eo\u0074\u0020\u0074\u0072\u0061\u006e\u0073f\u006f\u0072\u006d\u0020\u0070\u0061\u0067\u0065\u003a\u0020%\u0076",_dbgf );
return _dbgf ;};};};_bcc ._adgb =true ;return nil ;};func (_fbgae *templateProcessor )parseLine (_afcd *templateNode )(interface{},error ){_fafca :=_fbgae .creator .NewLine (0,0,0,0);for _ ,_ccdf :=range _afcd ._fcdbfb .Attr {_gbegg :=_ccdf .Value ;switch _cgcb :=_ccdf .Name .Local ;
_cgcb {case "\u0078\u0031":_fafca ._ecfe =_fbgae .parseFloatAttr (_cgcb ,_gbegg );case "\u0079\u0031":_fafca ._ecec =_fbgae .parseFloatAttr (_cgcb ,_gbegg );case "\u0078\u0032":_fafca ._bfba =_fbgae .parseFloatAttr (_cgcb ,_gbegg );case "\u0079\u0032":_fafca ._gbbeb =_fbgae .parseFloatAttr (_cgcb ,_gbegg );
case "\u0074h\u0069\u0063\u006b\u006e\u0065\u0073s":_fafca .SetLineWidth (_fbgae .parseFloatAttr (_cgcb ,_gbegg ));case "\u0063\u006f\u006co\u0072":_fafca .SetColor (_fbgae .parseColorAttr (_cgcb ,_gbegg ));case "\u0073\u0074\u0079l\u0065":_fafca .SetStyle (_fbgae .parseLineStyleAttr (_cgcb ,_gbegg ));
case "\u0064\u0061\u0073\u0068\u002d\u0061\u0072\u0072\u0061\u0079":_fafca .SetDashPattern (_fbgae .parseInt64Array (_cgcb ,_gbegg ),_fafca ._fabfc );case "\u0064\u0061\u0073\u0068\u002d\u0070\u0068\u0061\u0073\u0065":_fafca .SetDashPattern (_fafca ._ffaa ,_fbgae .parseInt64Attr (_cgcb ,_gbegg ));
case "\u006fp\u0061\u0063\u0069\u0074\u0079":_fafca .SetOpacity (_fbgae .parseFloatAttr (_cgcb ,_gbegg ));case "\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e":_fafca .SetPositioning (_fbgae .parsePositioningAttr (_cgcb ,_gbegg ));case "\u0066\u0069\u0074\u002d\u006d\u006f\u0064\u0065":_fafca .SetFitMode (_fbgae .parseFitModeAttr (_cgcb ,_gbegg ));
case "\u006d\u0061\u0072\u0067\u0069\u006e":_bbdf :=_fbgae .parseMarginAttr (_cgcb ,_gbegg );_fafca .SetMargins (_bbdf .Left ,_bbdf .Right ,_bbdf .Top ,_bbdf .Bottom );default:_de .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u006c\u0069\u006e\u0065 \u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_cgcb );
};};return _fafca ,nil ;};func (_ebae *StyledParagraph )wrapWordChunks (){if !_ebae ._egbc {return ;};var _gadb []*TextChunk ;for _ ,_dagbg :=range _ebae ._dfdf {_aafgb :=[]rune (_dagbg .Text );if len (_gadb )> 0{if len (_aafgb )==1&&_ac .IsPunct (_aafgb [0]){_ggbd :=[]rune (_gadb [len (_gadb )-1].Text );
_gadb [len (_gadb )-1].Text =string (append (_ggbd ,_aafgb [0]));continue ;}else {_ ,_eddcc :=_df .Atoi (_dagbg .Text );if _eddcc ==nil {_ggec :=[]rune (_gadb [len (_gadb )-1].Text );_gafg :=len (_ggec );if _gafg >=2{_ ,_ebfca :=_df .Atoi (string (_ggec [_gafg -2]));
if _ebfca ==nil &&_ac .IsPunct (_ggec [_gafg -1]){_gadb [len (_gadb )-1].Text =string (append (_ggec ,_aafgb ...));continue ;};};};};};_acca ,_bced :=_edfdd (_dagbg .Text );if _bced !=nil {_de .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0062\u0072\u0065\u0061\u006b\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0074\u006f\u0020w\u006f\u0072\u0064\u0073\u003a\u0020\u0025\u0076",_bced );
_acca =[]string {_dagbg .Text };};for _ ,_fgedd :=range _acca {_abfcd :=NewTextChunk (_fgedd ,_dagbg .Style );_gadb =append (_gadb ,_abfcd );};};if len (_gadb )> 0{_ebae ._dfdf =_gadb ;};};

// SetWidth sets the the Paragraph width. This is essentially the wrapping width,
// i.e. the width the text can extend to prior to wrapping over to next line.
func (_agddb *StyledParagraph )SetWidth (width float64 ){_agddb ._egeg =width ;_agddb .wrapText ()};func (_aecf *templateProcessor )parseHorizontalAlignmentAttr (_gcdff ,_cddbc string )HorizontalAlignment {_de .Log .Debug ("\u0050\u0061\u0072\u0073\u0069n\u0067\u0020\u0068\u006f\u0072\u0069\u007a\u006f\u006e\u0074\u0061\u006c\u0020a\u006c\u0069\u0067\u006e\u006d\u0065\u006e\u0074\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029.",_gcdff ,_cddbc );
_acegg :=map[string ]HorizontalAlignment {"\u006c\u0065\u0066\u0074":HorizontalAlignmentLeft ,"\u0063\u0065\u006e\u0074\u0065\u0072":HorizontalAlignmentCenter ,"\u0072\u0069\u0067h\u0074":HorizontalAlignmentRight }[_cddbc ];return _acegg ;};func (_ddcg *templateProcessor )addNodeText (_cbfd *templateNode ,_dgdg string )error {_cbbgg :=_cbfd ._defd ;
if _cbbgg ==nil {return nil ;};switch _dgefb :=_cbbgg .(type ){case *TextChunk :_dgefb .Text =_dgdg ;case *Paragraph :switch _cbfd ._fcdbfb .Name .Local {case "\u0063h\u0061p\u0074\u0065\u0072\u002d\u0068\u0065\u0061\u0064\u0069\u006e\u0067":if _cbfd ._abgba !=nil {if _ceffc ,_gabb :=_cbfd ._abgba ._defd .(*Chapter );
_gabb {_ceffc ._aae =_dgdg ;_dgefb .SetText (_ceffc .headingText ());};};default:_dgefb .SetText (_dgdg );};};return nil ;};type border struct{_ddg float64 ;_bdgg float64 ;_ebd float64 ;_eccb float64 ;_ddc Color ;_cbb Color ;_dbf float64 ;_agd Color ;_aed float64 ;
_bbbg Color ;_dfdb float64 ;_ecbc Color ;_ecg float64 ;LineStyle _bc .LineStyle ;_agdc CellBorderStyle ;_dfde CellBorderStyle ;_cfe CellBorderStyle ;_bde CellBorderStyle ;};func (_gggd *List )tableHeight (_aaed float64 )float64 {var _cebfe float64 ;for _ ,_edfab :=range _gggd ._dbgfa {switch _gecab :=_edfab ._ecde .(type ){case *Paragraph :_dage :=_gecab ;
if _dage ._caba {_dage .SetWidth (_aaed );};_cebfe +=_dage .Height ()+_dage ._bcbe .Bottom +_dage ._bcbe .Bottom ;_cebfe +=0.5*_dage ._aee *_dage ._ccef ;case *StyledParagraph :_bgba :=_gecab ;if _bgba ._ebeda {_bgba .SetWidth (_aaed );};_cebfe +=_bgba .Height ()+_bgba ._bgac .Top +_bgba ._bgac .Bottom ;
_cebfe +=0.5*_bgba .getTextHeight ();default:_cebfe +=_edfab ._ecde .Height ();};};return _cebfe ;};

// Add adds a new Drawable to the chapter.
// Currently supported Drawables:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
// - *Table
// - *Division
// - *List
// - *Rectangle
// - *Ellipse
// - *Line
// - *Block,
// - *PageBreak
// - *Chapter
func (_dgbd *Chapter )Add (d Drawable )error {if Drawable (_dgbd )==d {_de .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0043\u0061\u006e\u006e\u006f\u0074 \u0061\u0064\u0064\u0020\u0069\u0074\u0073\u0065\u006c\u0066");return _c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");
};switch _ddefe :=d .(type ){case *Paragraph ,*StyledParagraph ,*Image ,*Chart ,*Table ,*Division ,*List ,*Rectangle ,*Ellipse ,*Line ,*Block ,*PageBreak ,*Chapter :_dgbd ._eded =append (_dgbd ._eded ,d );case containerDrawable :_bbde ,_bfe :=_ddefe .ContainerComponent (_dgbd );
if _bfe !=nil {return _bfe ;};_dgbd ._eded =append (_dgbd ._eded ,_bbde );default:_de .Log .Debug ("\u0055n\u0073u\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u003a\u0020\u0025\u0054",d );return _c .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");
};return nil ;};

// AnchorPoint defines anchor point where the center position of the radial gradient would be calculated.
type AnchorPoint int ;func (_af *Block )mergeBlocks (_abc *Block )error {_fdf :=_dcfa (_af ._eg ,_af ._bf ,_abc ._eg ,_abc ._bf );if _fdf !=nil {return _fdf ;};for _ ,_fgf :=range _abc ._cgg {_af .AddAnnotation (_fgf );};return nil ;};

// DrawHeader sets a function to draw a header on created output pages.
func (_dfcg *Creator )DrawHeader (drawHeaderFunc func (_egb *Block ,_bfgf HeaderFunctionArgs )){_dfcg ._baab =drawHeaderFunc ;};

// Paragraph represents text drawn with a specified font and can wrap across lines and pages.
// By default it occupies the available width in the drawing context.
type Paragraph struct{_cffc string ;_agae *_ed .PdfFont ;_aee float64 ;_ccef float64 ;_cece Color ;_ccgc TextAlignment ;_caba bool ;_gbgcd float64 ;_adgd int ;_dbccd bool ;_efcgfb float64 ;_bcbe Margins ;_gbfg Positioning ;_fgef float64 ;_cbcaf float64 ;
_afbb ,_eegf float64 ;_babaa []string ;};

// Height returns the height of the graphic svg.
func (_cgcd *GraphicSVG )Height ()float64 {return _cgcd ._ebgg .Height };func _cggcf (_fgdb *templateProcessor ,_eaac *templateNode )(interface{},error ){return _fgdb .parseTableCell (_eaac );};

// SetFillColor sets the fill color for the path.
func (_gfeb *FilledCurve )SetFillColor (color Color ){_gfeb ._dec =color };

// SetPageLabels adds the specified page labels to the PDF file generated
// by the creator. See section 12.4.2 "Page Labels" (p. 382 PDF32000_2008).
// NOTE: for existing PDF files, the page label ranges object can be obtained
// using the model.PDFReader's GetPageLabels method.
func (_efcg *Creator )SetPageLabels (pageLabels _gg .PdfObject ){_efcg ._efbd =pageLabels };func (_bff *Block )drawToPage (_dbcf *_ed .PdfPage )error {_cca :=&_da .ContentStreamOperations {};if _dbcf .Resources ==nil {_dbcf .Resources =_ed .NewPdfPageResources ();
};_fgd :=_dcfa (_cca ,_dbcf .Resources ,_bff ._eg ,_bff ._bf );if _fgd !=nil {return _fgd ;};if _fgd =_ffe (_bff ._bf ,_dbcf .Resources );_fgd !=nil {return _fgd ;};if _fgd =_dbcf .AppendContentBytes (_cca .Bytes (),true );_fgd !=nil {return _fgd ;};for _ ,_bace :=range _bff ._cgg {_dbcf .AddAnnotation (_bace );
};return nil ;};

// SetBoundingBox set gradient color bounding box where the gradient would be rendered.
func (_ggfae *LinearShading )SetBoundingBox (x ,y ,width ,height float64 ){_ggfae ._dfagf =&_ed .PdfRectangle {Llx :x ,Lly :y ,Urx :x +width ,Ury :y +height };};

// SetWidthTop sets border width for top.
func (_edf *border )SetWidthTop (bw float64 ){_edf ._ecg =bw };func (_cafac *templateProcessor )parseCellBorderStyleAttr (_debf ,_fecfe string )CellBorderStyle {_de .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020c\u0065\u006c\u006c b\u006f\u0072\u0064\u0065\u0072\u0020s\u0074\u0079\u006c\u0065\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a \u0028\u0060\u0025\u0073\u0060\u002c\u0020\u0025s\u0029\u002e",_debf ,_fecfe );
_geff :=map[string ]CellBorderStyle {"\u006e\u006f\u006e\u0065":CellBorderStyleNone ,"\u0073\u0069\u006e\u0067\u006c\u0065":CellBorderStyleSingle ,"\u0064\u006f\u0075\u0062\u006c\u0065":CellBorderStyleDouble }[_fecfe ];return _geff ;};

// SetContent sets the cell's content.  The content is a VectorDrawable, i.e.
// a Drawable with a known height and width.
// Currently supported VectorDrawables:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
// - *Table
// - *Division
// - *List
// - *Rectangle
// - *Ellipse
// - *Line
func (_deccf *TableCell )SetContent (vd VectorDrawable )error {switch _dbdgd :=vd .(type ){case *Paragraph :if _dbdgd ._dbccd {_dbdgd ._caba =true ;};_deccf ._dafd =vd ;case *StyledParagraph :if _dbdgd ._ccafg {_dbdgd ._ebeda =true ;};_deccf ._dafd =vd ;
case *Image ,*Chart ,*Table ,*Division ,*List ,*Rectangle ,*Ellipse ,*Line :_deccf ._dafd =vd ;default:_de .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020\u0074\u0079p\u0065\u0020\u0025\u0054",vd );
return _gg .ErrTypeError ;};return nil ;};

// SetColor sets the line color. Use ColorRGBFromHex, ColorRGBFrom8bit or
// ColorRGBFromArithmetic to create the color object.
func (_acff *Line )SetColor (color Color ){_acff ._ecge =color };

// NewImageFromFile creates an Image from a file.
func (_afa *Creator )NewImageFromFile (path string )(*Image ,error ){return _adeg (path )};

// InsertColumn inserts a column in the line items table at the specified index.
func (_fdca *Invoice )InsertColumn (index uint ,description string )*InvoiceCell {_ffbac :=uint (len (_fdca ._deabd ));if index > _ffbac {index =_ffbac ;};_baba :=_fdca .NewColumn (description );_fdca ._deabd =append (_fdca ._deabd [:index ],append ([]*InvoiceCell {_baba },_fdca ._deabd [index :]...)...);
return _baba ;};

// SetAnnotation sets a annotation on a TextChunk.
func (_abebc *TextChunk )SetAnnotation (annotation *_ed .PdfAnnotation ){_abebc ._abcgd =annotation };

// SetAngle sets the rotation angle of the text.
func (_ceabe *Paragraph )SetAngle (angle float64 ){_ceabe ._efcgfb =angle };func (_ecda *Paragraph )wrapText ()error {if !_ecda ._caba ||int (_ecda ._gbgcd )<=0{_ecda ._babaa =[]string {_ecda ._cffc };return nil ;};_adcac :=NewTextChunk (_ecda ._cffc ,TextStyle {Font :_ecda ._agae ,FontSize :_ecda ._aee });
_fabda ,_ccadda :=_adcac .Wrap (_ecda ._gbgcd );if _ccadda !=nil {return _ccadda ;};if _ecda ._adgd > 0&&len (_fabda )> _ecda ._adgd {_fabda =_fabda [:_ecda ._adgd ];};_ecda ._babaa =_fabda ;return nil ;};

// GeneratePageBlocks draws the chart onto a block.
func (_ade *Chart )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dgbe :=ctx ;_ffa :=_ade ._cfacf .IsRelative ();var _bffg []*Block ;if _ffa {_dcbg :=1.0;_eagf :=_ade ._bgff .Top ;if float64 (_ade ._caa .Height ())> ctx .Height -_ade ._bgff .Top {_bffg =[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y )};
var _edbc error ;if _ ,ctx ,_edbc =_afbg ().GeneratePageBlocks (ctx );_edbc !=nil {return nil ,ctx ,_edbc ;};_eagf =0;};ctx .X +=_ade ._bgff .Left +_dcbg ;ctx .Y +=_eagf ;ctx .Width -=_ade ._bgff .Left +_ade ._bgff .Right +2*_dcbg ;ctx .Height -=_eagf ;
_ade ._caa .SetWidth (int (ctx .Width ));}else {ctx .X =_ade ._eac ;ctx .Y =_ade ._edebb ;};_bgea :=_da .NewContentCreator ();_bgea .Translate (0,ctx .PageHeight );_bgea .Scale (1,-1);_bgea .Translate (ctx .X ,ctx .Y );_daga :=NewBlock (ctx .PageWidth ,ctx .PageHeight );
_ade ._caa .Render (_ce .NewRenderer (_bgea ,_daga ._bf ),nil );if _caec :=_daga .addContentsByString (_bgea .String ());_caec !=nil {return nil ,ctx ,_caec ;};if _ffa {_adee :=_ade .Height ()+_ade ._bgff .Bottom ;ctx .Y +=_adee ;ctx .Height -=_adee ;}else {ctx =_dgbe ;
};_bffg =append (_bffg ,_daga );return _bffg ,ctx ,nil ;};func _ceddc (_cacec *templateProcessor ,_gafgb *templateNode )(interface{},error ){return _cacec .parseLine (_gafgb );};

// Scale block by specified factors in the x and y directions.
func (_ceb *Block )Scale (sx ,sy float64 ){_cdd :=_da .NewContentCreator ().Scale (sx ,sy ).Operations ();*_ceb ._eg =append (*_cdd ,*_ceb ._eg ...);_ceb ._eg .WrapIfNeeded ();_ceb ._beg *=sx ;_ceb ._fc *=sy ;};

// SetLevel sets the indentation level of the TOC line.
func (_bcbddc *TOCLine )SetLevel (level uint ){_bcbddc ._ggbcf =level ;_bcbddc ._ddaf ._bgac .Left =_bcbddc ._egee +float64 (_bcbddc ._ggbcf -1)*_bcbddc ._gfggfd ;};

// SetBorderOpacity sets the border opacity.
func (_fddg *CurvePolygon )SetBorderOpacity (opacity float64 ){_fddg ._cdgc =opacity };

// TextRenderingMode determines whether showing text shall cause glyph
// outlines to be stroked, filled, used as a clipping boundary, or some
// combination of the three.
// See section 9.3 "Text State Parameters and Operators" and
// Table 106 (pp. 254-255 PDF32000_2008).
type TextRenderingMode int ;func (_egae *Invoice )drawSection (_gffa ,_gcgc string )[]*StyledParagraph {var _bfcc []*StyledParagraph ;if _gffa !=""{_ced :=_fecf (_egae ._fadff );_ced .SetMargins (0,0,0,5);_ced .Append (_gffa );_bfcc =append (_bfcc ,_ced );
};if _gcgc !=""{_cagc :=_fecf (_egae ._fddc );_cagc .Append (_gcgc );_bfcc =append (_bfcc ,_cagc );};return _bfcc ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_gbbb *TOCLine )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_adcea :=ctx ;_dggcd ,ctx ,_gegef :=_gbbb ._ddaf .GeneratePageBlocks (ctx );if _gegef !=nil {return _dggcd ,ctx ,_gegef ;};if _gbbb ._gdace .IsRelative (){ctx .X =_adcea .X ;
};if _gbbb ._gdace .IsAbsolute (){return _dggcd ,_adcea ,nil ;};return _dggcd ,ctx ,nil ;};

// SetSideBorderColor sets the cell's side border color.
func (_egga *TableCell )SetSideBorderColor (side CellBorderSide ,col Color ){switch side {case CellBorderSideAll :_egga ._bgdb =col ;_egga ._ebdf =col ;_egga ._ggab =col ;_egga ._efgfc =col ;case CellBorderSideTop :_egga ._bgdb =col ;case CellBorderSideBottom :_egga ._ebdf =col ;
case CellBorderSideLeft :_egga ._ggab =col ;case CellBorderSideRight :_egga ._efgfc =col ;};};var PPI float64 =72;

// SetHeight sets the height of the ellipse.
func (_geca *Ellipse )SetHeight (height float64 ){_geca ._bddb =height };func _dgcgf (_bga []_bc .Point )*Polyline {return &Polyline {_afgc :&_bc .Polyline {Points :_bga ,LineColor :_ed .NewPdfColorDeviceRGB (0,0,0),LineWidth :1.0},_eacac :1.0};};func (_bfefb *Table )clone ()*Table {_bfbc :=*_bfefb ;
_bfbc ._accga =make ([]float64 ,len (_bfefb ._accga ));copy (_bfbc ._accga ,_bfefb ._accga );_bfbc ._gcfd =make ([]float64 ,len (_bfefb ._gcfd ));copy (_bfbc ._gcfd ,_bfefb ._gcfd );_bfbc ._ddbf =make ([]*TableCell ,0,len (_bfefb ._ddbf ));for _ ,_fgae :=range _bfefb ._ddbf {_beba :=*_fgae ;
_beba ._dedc =&_bfbc ;_bfbc ._ddbf =append (_bfbc ._ddbf ,&_beba );};return &_bfbc ;};

// Indent returns the left offset of the list when nested into another list.
func (_dgfa *List )Indent ()float64 {return _dgfa ._decc };func _bba (_cbcb string ,_cea _gg .PdfObject ,_ggf *_ed .PdfPageResources )_gg .PdfObjectName {_gfg :=_ae .TrimRightFunc (_ae .TrimSpace (_cbcb ),func (_cebd rune )bool {return _ac .IsNumber (_cebd )});
if _gfg ==""{_gfg ="\u0046\u006f\u006e\u0074";};_gbgf :=0;_beeea :=_gg .PdfObjectName (_cbcb );for {_bacef ,_dge :=_ggf .GetFontByName (_beeea );if !_dge ||_bacef ==_cea {break ;};_gbgf ++;_beeea =_gg .PdfObjectName (_fe .Sprintf ("\u0025\u0073\u0025\u0064",_gfg ,_gbgf ));
};return _beeea ;};func _ffcb ()*FilledCurve {_eddc :=FilledCurve {};_eddc ._bgegb =[]_bc .CubicBezierCurve {};return &_eddc ;};func (_bgce *Division )drawBackground (_affb []*Block ,_efgf ,_aeg DrawContext ,_ccgf bool )([]*Block ,error ){_baad :=len (_affb );
if _baad ==0||_bgce ._dbce ==nil {return _affb ,nil ;};_gcffb :=make ([]*Block ,0,len (_affb ));for _gbbe ,_gege :=range _affb {var (_cfadd =_bgce ._dbce .BorderRadiusTopLeft ;_dedbd =_bgce ._dbce .BorderRadiusTopRight ;_cfed =_bgce ._dbce .BorderRadiusBottomLeft ;
_abd =_bgce ._dbce .BorderRadiusBottomRight ;);_bdac :=_efgf ;_bdac .Page +=_gbbe ;if _gbbe ==0{if _ccgf {_gcffb =append (_gcffb ,_gege );continue ;};if _baad ==1{_bdac .Height =_aeg .Y -_efgf .Y ;};}else {_bdac .X =_bdac .Margins .Left +_bgce ._ccad .Left ;
_bdac .Y =_bdac .Margins .Top ;_bdac .Width =_bdac .PageWidth -_bdac .Margins .Left -_bdac .Margins .Right -_bgce ._ccad .Left -_bgce ._ccad .Right ;if _gbbe ==_baad -1{_bdac .Height =_aeg .Y -_bdac .Margins .Top -_bgce ._ccad .Top ;}else {_bdac .Height =_bdac .PageHeight -_bdac .Margins .Top -_bdac .Margins .Bottom ;
};if !_ccgf {_cfadd =0;_dedbd =0;};};if _baad > 1&&_gbbe !=_baad -1{_cfed =0;_abd =0;};_baace :=_cfab (_bdac .X ,_bdac .Y ,_bdac .Width ,_bdac .Height );_baace .SetFillColor (_bgce ._dbce .FillColor );_baace .SetBorderColor (_bgce ._dbce .BorderColor );
_baace .SetBorderWidth (_bgce ._dbce .BorderSize );_baace .SetBorderRadius (_cfadd ,_dedbd ,_cfed ,_abd );_gece ,_ ,_agcf :=_baace .GeneratePageBlocks (_bdac );if _agcf !=nil {return nil ,_agcf ;};if len (_gece )==0{continue ;};_afed :=_gece [0];if _agcf =_afed .mergeBlocks (_gege );
_agcf !=nil {return nil ,_agcf ;};_gcffb =append (_gcffb ,_afed );};return _gcffb ,nil ;};

// TextStyle is a collection of properties that can be assigned to a text chunk.
type TextStyle struct{

// Color represents the color of the text.
Color Color ;

// OutlineColor represents the color of the text outline.
OutlineColor Color ;

// Font represents the font the text will use.
Font *_ed .PdfFont ;

// FontSize represents the size of the font.
FontSize float64 ;

// OutlineSize represents the thickness of the text outline.
OutlineSize float64 ;

// CharSpacing represents the character spacing.
CharSpacing float64 ;

// HorizontalScaling represents the percentage to horizontally scale
// characters by (default: 100). Values less than 100 will result in
// narrower text while values greater than 100 will result in wider text.
HorizontalScaling float64 ;

// RenderingMode represents the rendering mode.
RenderingMode TextRenderingMode ;

// Underline specifies if the text chunk is underlined.
Underline bool ;

// UnderlineStyle represents the style of the line used to underline text.
UnderlineStyle TextDecorationLineStyle ;

// TextRise specifies a vertical adjustment for text. It is useful for
// drawing subscripts/superscripts. A positive text rise value will
// produce superscript text, while a negative one will result in
// subscript text.
TextRise float64 ;};

// SetPos sets the position of the chart to the specified coordinates.
// This method sets the chart to use absolute positioning.
func (_eafc *Chart )SetPos (x ,y float64 ){_eafc ._cfacf =PositionAbsolute ;_eafc ._eac =x ;_eafc ._edebb =y ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_gcdd *List )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var _fcdbg float64 ;var _ggga []*StyledParagraph ;for _ ,_dgee :=range _gcdd ._dbgfa {_efbc :=_fecf (_gcdd ._cgge );_efbc .SetEnableWrap (false );_efbc .SetTextAlignment (TextAlignmentRight );
_efbc .Append (_dgee ._cgff .Text ).Style =_dgee ._cgff .Style ;_abfee :=_efbc .getTextWidth ()/1000.0/ctx .Width ;if _fcdbg < _abfee {_fcdbg =_abfee ;};_ggga =append (_ggga ,_efbc );};_daed :=_bcfa (2);_daed .SetColumnWidths (_fcdbg ,1-_fcdbg );_daed .SetMargins (_gcdd ._decc ,0,0,0);
for _cgce ,_aggf :=range _gcdd ._dbgfa {_aefc :=_daed .NewCell ();_aefc .SetIndent (0);_aefc .SetContent (_ggga [_cgce ]);_aefc =_daed .NewCell ();_aefc .SetIndent (0);_aefc .SetContent (_aggf ._ecde );};return _daed .GeneratePageBlocks (ctx );};

// SetPos sets absolute positioning with specified coordinates.
func (_eeaa *StyledParagraph )SetPos (x ,y float64 ){_eeaa ._cade =PositionAbsolute ;_eeaa ._dffgf =x ;_eeaa ._bccgg =y ;};

// SetBorderColor sets the border color.
func (_fgce *PolyBezierCurve )SetBorderColor (color Color ){_fgce ._adac .BorderColor =_ccfb (color )};func _egbcf (_bcfcc *_ed .PdfAnnotation )*_ed .PdfAnnotation {if _bcfcc ==nil {return nil ;};var _fagcce *_ed .PdfAnnotation ;switch _bcff :=_bcfcc .GetContext ().(type ){case *_ed .PdfAnnotationLink :if _gddc :=_cfeeb (_bcff );
_gddc !=nil {_fagcce =_gddc .PdfAnnotation ;};};return _fagcce ;};

// SetBorderWidth sets the border width.
func (_gagg *Polygon )SetBorderWidth (borderWidth float64 ){_gagg ._gaecf .BorderWidth =borderWidth };

// NewList creates a new list.
func (_feac *Creator )NewList ()*List {return _ecaee (_feac .NewTextStyle ())};

// Marker returns the marker used for the list items.
// The marker instance can be used the change the text and the style
// of newly added list items.
func (_gabg *List )Marker ()*TextChunk {return &_gabg ._cbbd };

// InvoiceAddress contains contact information that can be displayed
// in an invoice. It is used for the seller and buyer information in the
// invoice template.
type InvoiceAddress struct{Heading string ;Name string ;Street string ;Street2 string ;Zip string ;City string ;State string ;Country string ;Phone string ;Email string ;

// Separator defines the separator between different address components,
// such as the city, state and zip code. It defaults to ", " when the
// field is an empty string.
Separator string ;

// If enabled, the Phone field label (`Phone: `) is not displayed.
HidePhoneLabel bool ;

// If enabled, the Email field label (`Email: `) is not displayed.
HideEmailLabel bool ;};

// GetCoords returns the (x1, y1), (x2, y2) points defining the Line.
func (_dfggg *Line )GetCoords ()(float64 ,float64 ,float64 ,float64 ){return _dfggg ._ecfe ,_dfggg ._ecec ,_dfggg ._bfba ,_dfggg ._gbbeb ;};

// StyledParagraph represents text drawn with a specified font and can wrap across lines and pages.
// By default occupies the available width in the drawing context.
type StyledParagraph struct{_dfdf []*TextChunk ;_fega TextStyle ;_feada TextStyle ;_fbgd TextAlignment ;_ebdgb TextVerticalAlignment ;_gcba float64 ;_ebeda bool ;_egeg float64 ;_egbc bool ;_ccafg bool ;_fdbbfa TextOverflow ;_caag float64 ;_bgac Margins ;
_cade Positioning ;_dffgf float64 ;_bccgg float64 ;_adgag float64 ;_begg float64 ;_fgbg [][]*TextChunk ;_dggcf func (_eedc *StyledParagraph ,_dgccg DrawContext );};

// AddExternalLink adds a new external link to the paragraph.
// The text parameter represents the text that is displayed and the url
// parameter sets the destionation of the link.
func (_feefc *StyledParagraph )AddExternalLink (text ,url string )*TextChunk {_gdfeb :=NewTextChunk (text ,_feefc ._feada );_gdfeb ._abcgd =_afebf (url );return _feefc .appendChunk (_gdfeb );};

// ScaleToWidth scales the ellipse to the specified width. The height of
// the ellipse is scaled so that the aspect ratio is maintained.
func (_cfge *Ellipse )ScaleToWidth (w float64 ){_aced :=_cfge ._bddb /_cfge ._dcg ;_cfge ._dcg =w ;_cfge ._bddb =w *_aced ;};

// Rows returns the total number of rows the table has.
func (_bdeb *Table )Rows ()int {return _bdeb ._bebea };

// PageSize represents the page size as a 2 element array representing the width and height in PDF document units (points).
type PageSize [2]float64 ;

// String implements error interface.
func (_dccd UnsupportedRuneError )Error ()string {return _dccd .Message };

// SetFont sets the Paragraph's font.
func (_fdfcg *Paragraph )SetFont (font *_ed .PdfFont ){_fdfcg ._agae =font };

// Positioning returns the type of positioning the ellipse is set to use.
func (_bbe *Ellipse )Positioning ()Positioning {return _bbe ._cdgf };func _ggad (_baade *templateProcessor ,_afbed *templateNode )(interface{},error ){return _baade .parseStyledParagraph (_afbed );};func _dgegf (_edbec *_ed .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,238),Font :_edbec ,FontSize :10,OutlineSize :1,HorizontalScaling :DefaultHorizontalScaling ,UnderlineStyle :TextDecorationLineStyle {Offset :1,Thickness :1}};
};

// GeneratePageBlocks draws the curve onto page blocks.
func (_dbeg *Curve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_efdf :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_gbga :=_da .NewContentCreator ();_gbga .Add_q ().Add_w (_dbeg ._feba ).SetStrokingColor (_ccfb (_dbeg ._fgaf )).Add_m (_dbeg ._ccaf ,ctx .PageHeight -_dbeg ._gegd ).Add_v (_dbeg ._ecae ,ctx .PageHeight -_dbeg ._bdf ,_dbeg ._acaf ,ctx .PageHeight -_dbeg ._ebee ).Add_S ().Add_Q ();
_fcgg :=_efdf .addContentsByString (_gbga .String ());if _fcgg !=nil {return nil ,ctx ,_fcgg ;};return []*Block {_efdf },ctx ,nil ;};

// SetBuyerAddress sets the buyer address of the invoice.
func (_bbfff *Invoice )SetBuyerAddress (address *InvoiceAddress ){_bbfff ._eeaf =address };

// DrawTemplate renders the template provided through the specified reader,
// using the specified `data` and `options`.
// Creator templates are first executed as text/template *Template instances,
// so the specified `data` is inserted within the template.
// The second phase of processing is actually parsing the template, translating
// it into creator components and rendering them using the provided options.
// Both the `data` and `options` parameters can be nil.
func (_aac *Creator )DrawTemplate (r _e .Reader ,data interface{},options *TemplateOptions )error {return _ccbb (_aac ,r ,data ,options ,_aac );};

// Positioning represents the positioning type for drawing creator components (relative/absolute).
type Positioning int ;

// SetFillOpacity sets the fill opacity.
func (_fegb *Polygon )SetFillOpacity (opacity float64 ){_fegb ._fegg =opacity };func (_ecdag *Rectangle )applyFitMode (_cedc float64 ){_cedc -=_ecdag ._efbdg .Left +_ecdag ._efbdg .Right +_ecdag ._gaffd ;switch _ecdag ._cegf {case FitModeFillWidth :_ecdag .ScaleToWidth (_cedc );
};};

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_fbcd *StyledParagraph )SetTextAlignment (align TextAlignment ){_fbcd ._fbgd =align };

// NewCellProps returns the default properties of an invoice cell.
func (_dcdg *Invoice )NewCellProps ()InvoiceCellProps {_adegd :=ColorRGBFrom8bit (255,255,255);return InvoiceCellProps {TextStyle :_dcdg ._geb ,Alignment :CellHorizontalAlignmentLeft ,BackgroundColor :_adegd ,BorderColor :_adegd ,BorderWidth :1,BorderSides :[]CellBorderSide {CellBorderSideAll }};
};

// SetStyle sets the style for all the line components: number, title,
// separator, page.
func (_dgac *TOCLine )SetStyle (style TextStyle ){_dgac .Number .Style =style ;_dgac .Title .Style =style ;_dgac .Separator .Style =style ;_dgac .Page .Style =style ;};

// ScaleToHeight scale Image to a specified height h, maintaining the aspect ratio.
func (_dcca *Image )ScaleToHeight (h float64 ){_abgec :=_dcca ._deac /_dcca ._fedbd ;_dcca ._fedbd =h ;_dcca ._deac =h *_abgec ;};

// AddColorStop add color stop info for rendering gradient color.
func (_bbage *LinearShading )AddColorStop (color Color ,point float64 ){_bbage ._cecc .AddColorStop (color ,point );};func (_ddbc *StyledParagraph )getTextLineWidth (_dcec []*TextChunk )float64 {var _ddedd float64 ;_fegae :=len (_dcec );for _gafc ,_afefe :=range _dcec {_cgdg :=&_afefe .Style ;
_cgdf :=len (_afefe .Text );for _facag ,_cege :=range _afefe .Text {if _cege =='\u000A'{continue ;};_eada ,_ccfdd :=_cgdg .Font .GetRuneMetrics (_cege );if !_ccfdd {_de .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_cege );
return -1;};_ddedd +=_cgdg .FontSize *_eada .Wx *_cgdg .horizontalScale ();if _cege !=' '&&(_gafc !=_fegae -1||_facag !=_cgdf -1){_ddedd +=_cgdg .CharSpacing *1000.0;};};};return _ddedd ;};

// NewTOC creates a new table of contents.
func (_bfec *Creator )NewTOC (title string )*TOC {_ccde :=_bfec .NewTextStyle ();_ccde .Font =_bfec ._dcef ;return _bbee (title ,_bfec .NewTextStyle (),_ccde );};func (_dcebbf *templateProcessor )parseFloatArray (_ceafd ,_ccba string )[]float64 {_de .Log .Debug ("\u0050\u0061\u0072s\u0069\u006e\u0067\u0020\u0066\u006c\u006f\u0061\u0074\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028\u0060%\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_ceafd ,_ccba );
_babf :=_ae .Fields (_ccba );_ceda :=make ([]float64 ,0,len (_babf ));for _ ,_bcdd :=range _babf {_cdff ,_ :=_df .ParseFloat (_bcdd ,64);_ceda =append (_ceda ,_cdff );};return _ceda ;};

// FillOpacity returns the fill opacity of the ellipse (0-1).
func (_eeeb *Ellipse )FillOpacity ()float64 {return _eeeb ._bbcdd };

// SetText sets the text content of the Paragraph.
func (_gbdd *Paragraph )SetText (text string ){_gbdd ._cffc =text };

// SetPos sets the absolute position. Changes object positioning to absolute.
func (_bccg *Image )SetPos (x ,y float64 ){_bccg ._aeae =PositionAbsolute ;_bccg ._gcdg =x ;_bccg ._fgff =y ;};

// SetWidth sets the width of the ellipse.
func (_cbcbb *Ellipse )SetWidth (width float64 ){_cbcbb ._dcg =width };func (_fbgaf *templateProcessor )parseTextVerticalAlignmentAttr (_edebg ,_dbffa string )TextVerticalAlignment {_de .Log .Debug ("\u0050\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0074\u0065\u0078\u0074\u0020\u0076\u0065r\u0074\u0069\u0063\u0061\u006c\u0020\u0061\u006c\u0069\u0067\u006e\u006d\u0065n\u0074\u0020\u0061\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a (\u0060\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_edebg ,_dbffa );
_eceba :=map[string ]TextVerticalAlignment {"\u0062\u0061\u0073\u0065\u006c\u0069\u006e\u0065":TextVerticalAlignmentBaseline ,"\u0063\u0065\u006e\u0074\u0065\u0072":TextVerticalAlignmentCenter }[_dbffa ];return _eceba ;};func (_eagbfd *Table )wrapRow (_bgcab int ,_bfceb DrawContext ,_bdae float64 ,_eecdd float64 )(bool ,error ){if !_eagbfd ._egbga {return false ,nil ;
};var (_acfb =_eagbfd ._ddbf [_bgcab ];_bedg =-1;_gbdg []*TableCell ;_fdfbd float64 ;_efgce bool ;_eafb =make ([]float64 ,0,len (_eagbfd ._gcfd )););_edceb :=func (_gedc *TableCell ,_dddgg VectorDrawable ,_gdgf bool )*TableCell {_dcbb :=*_gedc ;_dcbb ._dafd =_dddgg ;
if _gdgf {_dcbb ._dgad ++;};return &_dcbb ;};_bcef :=func (_gebge int ,_dcfg VectorDrawable ){var _cgbfe float64 =-1;if _dcfg ==nil {if _ccdg :=_eafb [_gebge -_bgcab ];_ccdg > _bfceb .Height {_dcfg =_eagbfd ._ddbf [_gebge ]._dafd ;_eagbfd ._ddbf [_gebge ]._dafd =nil ;
_eafb [_gebge -_bgcab ]=0;_cgbfe =_ccdg ;};};_bccdd :=_edceb (_eagbfd ._ddbf [_gebge ],_dcfg ,true );_gbdg =append (_gbdg ,_bccdd );if _cgbfe < 0{_cgbfe =_bccdd .height (_bfceb .Width );};if _cgbfe > _fdfbd {_fdfbd =_cgbfe ;};};for _feeee :=_bgcab ;_feeee < len (_eagbfd ._ddbf );
_feeee ++{_addbf :=_eagbfd ._ddbf [_feeee ];if _acfb ._dgad !=_addbf ._dgad {_bedg =_feeee ;break ;};_bfceb .Width =_addbf .width (_eagbfd ._gcfd ,_bdae );var _babe VectorDrawable ;switch _cefbg :=_addbf ._dafd .(type ){case *StyledParagraph :if _ffag :=_addbf .height (_bfceb .Width );
_ffag > _bfceb .Height {_gbca :=_bfceb ;_gbca .Height =_gd .Floor (_bfceb .Height -_cefbg ._bgac .Top -_cefbg ._bgac .Bottom -0.5*_cefbg .getTextHeight ());_cbaeb ,_gfde ,_eacd :=_cefbg .split (_gbca );if _eacd !=nil {return false ,_eacd ;};if _cbaeb !=nil {_cefbg =_cbaeb ;
_addbf =_edceb (_addbf ,_cbaeb ,false );_eagbfd ._ddbf [_feeee ]=_addbf ;};if _gfde !=nil {_babe =_gfde ;_efgce =true ;};};case *Division :if _ebced :=_addbf .height (_bfceb .Width );_ebced > _bfceb .Height {_cdadb :=_bfceb ;_cdadb .Height =_gd .Floor (_bfceb .Height -_cefbg ._ccad .Top -_cefbg ._ccad .Bottom );
_adcbd ,_dced :=_cefbg .split (_cdadb );if _adcbd !=nil &&_dced !=nil {_cefbg =_adcbd ;_addbf =_edceb (_addbf ,_adcbd ,false );_eagbfd ._ddbf [_feeee ]=_addbf ;_babe =_dced ;_efgce =true ;if _adcbd ._dbce !=nil {_adcbd ._dbce .BorderRadiusBottomLeft =0;
_adcbd ._dbce .BorderRadiusBottomRight =0;};if _dced ._dbce !=nil {_dced ._dbce .BorderRadiusTopLeft =0;_dced ._dbce .BorderRadiusTopRight =0;};};};};_eafb =append (_eafb ,_addbf .height (_bfceb .Width ));if _efgce {if _gbdg ==nil {_gbdg =make ([]*TableCell ,0,len (_eagbfd ._gcfd ));
for _dcbgba :=_bgcab ;_dcbgba < _feeee ;_dcbgba ++{_bcef (_dcbgba ,nil );};};_bcef (_feeee ,_babe );};};var _fdfbf float64 ;for _ ,_dadgc :=range _eafb {if _dadgc > _fdfbf {_fdfbf =_dadgc ;};};if _efgce {if _bedg < 0{_bedg =len (_eagbfd ._ddbf );};_fffag :=_eagbfd ._ddbf [_bedg -1]._dgad +_eagbfd ._ddbf [_bedg -1]._efdb -1;
if _fdfbf <=_bfceb .Height {for _cdeg :=_bedg ;_cdeg < len (_eagbfd ._ddbf );_cdeg ++{_eagbfd ._ddbf [_cdeg ]._dgad ++;};_eagbfd ._ddbf =append (_eagbfd ._ddbf [:_bedg ],append (_gbdg ,_eagbfd ._ddbf [_bedg :]...)...);_eagbfd ._accga =append (_eagbfd ._accga [:_fffag ],append ([]float64 {_fdfbd },_eagbfd ._accga [_fffag :]...)...);
_eagbfd ._accga [_acfb ._dgad +_acfb ._efdb -2]=_fdfbf ;}else if _fdfbf > _eecdd {_bfceb .Height =_eecdd ;_eagbfd ._ddbf =append (_eagbfd ._ddbf [:_bedg -1],append (_gbdg ,_eagbfd ._ddbf [_bedg :]...)...);_eagbfd ._accga =append (_eagbfd ._accga [:_fffag -1],append ([]float64 {_fdfbd },_eagbfd ._accga [_fffag -1:]...)...);
var _affd error ;_efgce ,_affd =_eagbfd .wrapRow (_bgcab ,_bfceb ,_bdae ,_eecdd );if _affd !=nil {return false ,_affd ;};};};return _efgce ,nil ;};

// Chart represents a chart drawable.
// It is used to render unichart chart components using a creator instance.
type Chart struct{_caa _b .ChartRenderable ;_cfacf Positioning ;_eac float64 ;_edebb float64 ;_bgff Margins ;};func (_dgaae *StyledParagraph )wrapText ()error {return _dgaae .wrapChunks (true )};func _afebf (_fgbaf string )*_ed .PdfAnnotation {_edfba :=_ed .NewPdfAnnotationLink ();
_dagfd :=_ed .NewBorderStyle ();_dagfd .SetBorderWidth (0);_edfba .BS =_dagfd .ToPdfObject ();_fgffd :=_ed .NewPdfActionURI ();_fgffd .URI =_gg .MakeString (_fgbaf );_edfba .SetAction (_fgffd .PdfAction );return _edfba .PdfAnnotation ;};func (_gdfae *templateProcessor )parseDivision (_efefb *templateNode )(interface{},error ){_fcce :=_gdfae .creator .NewDivision ();
for _ ,_fbbfa :=range _efefb ._fcdbfb .Attr {_cgfd :=_fbbfa .Value ;switch _eccbf :=_fbbfa .Name .Local ;_eccbf {case "\u0065\u006ea\u0062\u006c\u0065-\u0070\u0061\u0067\u0065\u002d\u0077\u0072\u0061\u0070":_fcce .EnablePageWrap (_gdfae .parseBoolAttr (_eccbf ,_cgfd ));
case "\u006d\u0061\u0072\u0067\u0069\u006e":_ebadg :=_gdfae .parseMarginAttr (_eccbf ,_cgfd );_fcce .SetMargins (_ebadg .Left ,_ebadg .Right ,_ebadg .Top ,_ebadg .Bottom );case "\u0070a\u0064\u0064\u0069\u006e\u0067":_bdggb :=_gdfae .parseMarginAttr (_eccbf ,_cgfd );
_fcce .SetPadding (_bdggb .Left ,_bdggb .Right ,_bdggb .Top ,_bdggb .Bottom );default:_de .Log .Debug ("U\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0064\u0069\u0076\u0069\u0073\u0069on\u0020\u0061\u0074\u0074r\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025s`\u002e\u0020S\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e",_eccbf );
};};return _fcce ,nil ;};func (_ceadfe *templateProcessor )parseFloatAttr (_gbceg ,_bbgff string )float64 {_de .Log .Debug ("\u0050\u0061rs\u0069\u006e\u0067 \u0066\u006c\u006f\u0061t a\u0074tr\u0069\u0062\u0075\u0074\u0065\u003a\u0020(`\u0025\u0073\u0060\u002c\u0020\u0025\u0073)\u002e",_gbceg ,_bbgff );
_ebgab ,_ :=_df .ParseFloat (_bbgff ,64);return _ebgab ;};func (_cabag *templateProcessor )parseCellAlignmentAttr (_bfffd ,_faaedc string )CellHorizontalAlignment {_de .Log .Debug ("\u0050a\u0072\u0073i\u006e\u0067\u0020c\u0065\u006c\u006c\u0020\u0061\u006c\u0069g\u006e\u006d\u0065\u006e\u0074\u0020a\u0074\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0028`\u0025\u0073\u0060\u002c\u0020\u0025\u0073\u0029\u002e",_bfffd ,_faaedc );
_cfdga :=map[string ]CellHorizontalAlignment {"\u006c\u0065\u0066\u0074":CellHorizontalAlignmentLeft ,"\u0063\u0065\u006e\u0074\u0065\u0072":CellHorizontalAlignmentCenter ,"\u0072\u0069\u0067h\u0074":CellHorizontalAlignmentRight }[_faaedc ];return _cfdga ;
};func _adfde (_bebdb string ,_aefdc bool )string {_gaeff :=_bebdb ;if _gaeff ==""{return "";};_cccg :=_eb .Paragraph {};_ ,_dfbde :=_cccg .SetString (_bebdb );if _dfbde !=nil {return _gaeff ;};_efdd ,_dfbde :=_cccg .Order ();if _dfbde !=nil {return _gaeff ;
};_fbcda :=_efdd .NumRuns ();_acaa :=make ([]string ,_fbcda );for _ffaeg :=0;_ffaeg < _efdd .NumRuns ();_ffaeg ++{_ebedb :=_efdd .Run (_ffaeg );_cbaf :=_ebedb .String ();if _ebedb .Direction ()==_eb .RightToLeft {_cbaf =_eb .ReverseString (_cbaf );};if _aefdc {_acaa [_ffaeg ]=_cbaf ;
}else {_acaa [_fbcda -1]=_cbaf ;};_fbcda --;};if len (_acaa )!=_efdd .NumRuns (){return _bebdb ;};_gaeff =_ae .Join (_acaa ,"");return _gaeff ;};

// Subtotal returns the invoice subtotal description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_bdgf *Invoice )Subtotal ()(*InvoiceCell ,*InvoiceCell ){return _bdgf ._egfeg [0],_bdgf ._egfeg [1];};func (_cgcce *templateProcessor )parseTextChunk (_agba *templateNode )(interface{},error ){_agfbf :=NewTextChunk ("",_cgcce .creator .NewTextStyle ());
for _ ,_faaf :=range _agba ._fcdbfb .Attr {_cbdg :=_faaf .Value ;switch _gbffd :=_faaf .Name .Local ;_gbffd {case "\u0063\u006f\u006co\u0072":_agfbf .Style .Color =_cgcce .parseColorAttr (_gbffd ,_cbdg );case "\u006f\u0075\u0074\u006c\u0069\u006e\u0065\u002d\u0063\u006f\u006c\u006f\u0072":_agfbf .Style .OutlineColor =_cgcce .parseColorAttr (_gbffd ,_cbdg );
case "\u0066\u006f\u006e\u0074":_agfbf .Style .Font =_cgcce .parseFontAttr (_gbffd ,_cbdg );case "\u0066o\u006e\u0074\u002d\u0073\u0069\u007ae":_agfbf .Style .FontSize =_cgcce .parseFloatAttr (_gbffd ,_cbdg );case "\u006f\u0075\u0074l\u0069\u006e\u0065\u002d\u0073\u0069\u007a\u0065":_agfbf .Style .OutlineSize =_cgcce .parseFloatAttr (_gbffd ,_cbdg );
case "\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u002d\u0073\u0070a\u0063\u0069\u006e\u0067":_agfbf .Style .CharSpacing =_cgcce .parseFloatAttr (_gbffd ,_cbdg );case "\u0068o\u0072i\u007a\u006f\u006e\u0074\u0061l\u002d\u0073c\u0061\u006c\u0069\u006e\u0067":_agfbf .Style .HorizontalScaling =_cgcce .parseFloatAttr (_gbffd ,_cbdg );
case "\u0072\u0065\u006e\u0064\u0065\u0072\u0069\u006e\u0067-\u006d\u006f\u0064\u0065":_agfbf .Style .RenderingMode =_cgcce .parseTextRenderingModeAttr (_gbffd ,_cbdg );case "\u0075n\u0064\u0065\u0072\u006c\u0069\u006ee":_agfbf .Style .Underline =_cgcce .parseBoolAttr (_gbffd ,_cbdg );
case "\u0075n\u0064e\u0072\u006c\u0069\u006e\u0065\u002d\u0063\u006f\u006c\u006f\u0072":_agfbf .Style .UnderlineStyle .Color =_cgcce .parseColorAttr (_gbffd ,_cbdg );case "\u0075\u006ed\u0065\u0072\u006ci\u006e\u0065\u002d\u006f\u0066\u0066\u0073\u0065\u0074":_agfbf .Style .UnderlineStyle .Offset =_cgcce .parseFloatAttr (_gbffd ,_cbdg );
case "\u0075\u006e\u0064\u0065rl\u0069\u006e\u0065\u002d\u0074\u0068\u0069\u0063\u006b\u006e\u0065\u0073\u0073":_agfbf .Style .UnderlineStyle .Thickness =_cgcce .parseFloatAttr (_gbffd ,_cbdg );case "\u0074e\u0078\u0074\u002d\u0072\u0069\u0073e":_agfbf .Style .TextRise =_cgcce .parseFloatAttr (_gbffd ,_cbdg );
default:_de .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0063\u0068\u0075\u006e\u006b\u0020\u0061\u0074\u0074\u0072i\u0062\u0075\u0074\u0065\u003a\u0020\u0060\u0025\u0073\u0060\u002e\u0020\u0053\u006bi\u0070p\u0069\u006e\u0067\u002e",_gbffd );
};};return _agfbf ,nil ;};

// SetMargins sets the Paragraph's margins.
func (_gefeg *StyledParagraph )SetMargins (left ,right ,top ,bottom float64 ){_gefeg ._bgac .Left =left ;_gefeg ._bgac .Right =right ;_gefeg ._bgac .Top =top ;_gefeg ._bgac .Bottom =bottom ;};

// GeneratePageBlocks generate the Page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages.
func (_edfe *Chapter )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bgb :=ctx ;if _edfe ._ceag .IsRelative (){ctx .X +=_edfe ._eeeg .Left ;ctx .Y +=_edfe ._eeeg .Top ;ctx .Width -=_edfe ._eeeg .Left +_edfe ._eeeg .Right ;ctx .Height -=_edfe ._eeeg .Top ;
};_acb ,_cfd ,_adge :=_edfe ._cff .GeneratePageBlocks (ctx );if _adge !=nil {return _acb ,ctx ,_adge ;};ctx =_cfd ;_edebe :=ctx .X ;_aeag :=ctx .Y -_edfe ._cff .Height ();_fffb :=int64 (ctx .Page );_adaa :=_edfe .headingNumber ();_fdbf :=_edfe .headingText ();
if _edfe ._efgd {_ggag :=_edfe ._afg .Add (_adaa ,_edfe ._aae ,_df .FormatInt (_fffb ,10),_edfe ._ceec );if _edfe ._afg ._afec {_ggag .SetLink (_fffb ,_edebe ,_aeag );};};if _edfe ._ggff ==nil {_edfe ._ggff =_ed .NewOutlineItem (_fdbf ,_ed .NewOutlineDest (_fffb -1,_edebe ,_aeag ));
if _edfe ._cdgd !=nil {_edfe ._cdgd ._ggff .Add (_edfe ._ggff );}else {_edfe ._dae .Add (_edfe ._ggff );};}else {_abgc :=&_edfe ._ggff .Dest ;_abgc .Page =_fffb -1;_abgc .X =_edebe ;_abgc .Y =_aeag ;};for _ ,_ega :=range _edfe ._eded {_gca ,_bbdg ,_ceee :=_ega .GeneratePageBlocks (ctx );
if _ceee !=nil {return _acb ,ctx ,_ceee ;};if len (_gca )< 1{continue ;};_acb [len (_acb )-1].mergeBlocks (_gca [0]);_acb =append (_acb ,_gca [1:]...);ctx =_bbdg ;};if _edfe ._ceag .IsRelative (){ctx .X =_bgb .X ;};if _edfe ._ceag .IsAbsolute (){return _acb ,_bgb ,nil ;
};return _acb ,ctx ,nil ;};

// Height returns the height of the chart.
func (_aab *Chart )Height ()float64 {return float64 (_aab ._caa .Height ())};type rgbColor struct{_fbba ,_dbd ,_fdc float64 };

// EnablePageWrap controls whether the table is wrapped across pages.
// If disabled, the table is moved in its entirety on a new page, if it
// does not fit in the available height. By default, page wrapping is enabled.
// If the height of the table is larger than an entire page, wrapping is
// enabled automatically in order to avoid unwanted behavior.
func (_ebaf *Table )EnablePageWrap (enable bool ){_ebaf ._geega =enable };

// SetColumnWidths sets the fractional column widths.
// Each width should be in the range 0-1 and is a fraction of the table width.
// The number of width inputs must match number of columns, otherwise an error is returned.
func (_bfeeg *Table )SetColumnWidths (widths ...float64 )error {if len (widths )!=_bfeeg ._efefg {_de .Log .Debug ("M\u0069\u0073\u006d\u0061\u0074\u0063\u0068\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020o\u0066\u0020\u0077\u0069\u0064\u0074\u0068\u0073\u0020\u0061nd\u0020\u0063\u006fl\u0075m\u006e\u0073");
return _c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_bfeeg ._gcfd =widths ;return nil ;};