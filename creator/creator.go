//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

//
// Package creator is used for quickly generating pages and content with a simple interface.
// It is built on top of the model package to provide access to the most common
// operations such as creating text and image reports and manipulating existing pages.
//
package creator ;import (_gb "bytes";_a "errors";_ec "fmt";_ff "github.com/unidoc/unipdf/v3/common";_da "github.com/unidoc/unipdf/v3/contentstream";_fd "github.com/unidoc/unipdf/v3/contentstream/draw";_c "github.com/unidoc/unipdf/v3/core";_afa "github.com/unidoc/unipdf/v3/internal/license";
_ab "github.com/unidoc/unipdf/v3/internal/transform";_afd "github.com/unidoc/unipdf/v3/model";_ac "image";_af "io";_aa "math";_f "os";_g "sort";_e "strconv";_fg "strings";_dg "unicode";);

// SetHeaderRows turns the selected table rows into headers that are repeated
// for every page the table spans. startRow and endRow are inclusive.
func (_edede *Table )SetHeaderRows (startRow ,endRow int )error {if startRow <=0{return _a .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020r\u006f\u0077\u0020\u006d\u0075\u0073t\u0020\u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");
};if endRow <=0{return _a .New ("\u0068\u0065a\u0064\u0065\u0072\u0020e\u006e\u0064 \u0072\u006f\u0077\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");};if startRow > endRow {return _a .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020\u0072\u006f\u0077\u0020\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061\u006e\u0020\u006f\u0072\u0020\u0065\u0071\u0075\u0061\u006c\u0020\u0074\u006f\u0020\u0074\u0068\u0065 \u0065\u006e\u0064\u0020\u0072o\u0077");
};_edede ._ebf =true ;_edede ._bead =startRow ;_edede ._fcefe =endRow ;return nil ;};type cmykColor struct{_fdgea ,_gebe ,_ggb ,_dagd float64 };func (_aac cmykColor )ToRGB ()(float64 ,float64 ,float64 ){_efgc :=_aac ._dagd ;return 1-(_aac ._fdgea *(1-_efgc )+_efgc ),1-(_aac ._gebe *(1-_efgc )+_efgc ),1-(_aac ._ggb *(1-_efgc )+_efgc );
};func (_ebba *Image )makeXObject ()error {_aeedb :=_ebba ._cgdee ;if _aeedb ==nil {_aeedb =_c .NewFlateEncoder ();};_cgdd ,_cbbd :=_afd .NewXObjectImageFromImage (_ebba ._cfaa ,nil ,_aeedb );if _cbbd !=nil {_ff .Log .Error ("\u0046\u0061\u0069le\u0064\u0020\u0074\u006f\u0020\u0063\u0072\u0065\u0061t\u0065 \u0078o\u0062j\u0065\u0063\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_cbbd );
return _cbbd ;};_ebba ._adbe =_cgdd ;return nil ;};func (_fef *Creator )setActivePage (_edad *_afd .PdfPage ){_fef ._bagd =_edad };

// NewDivision returns a new Division container component.
func (_agaa *Creator )NewDivision ()*Division {return _gbec ()};

// MultiColCell makes a new cell with the specified column span and inserts it
// into the table at the current position.
func (_dfedd *Table )MultiColCell (colspan int )*TableCell {return _dfedd .newCell (colspan )};

// DrawWithContext draws the Block using the specified drawing context.
func (_fe *Block )DrawWithContext (d Drawable ,ctx DrawContext )error {_bef ,_ ,_abe :=d .GeneratePageBlocks (ctx );if _abe !=nil {return _abe ;};if len (_bef )!=1{return _a .New ("\u0074\u006f\u006f\u0020ma\u006e\u0079\u0020\u006f\u0075\u0074\u0070\u0075\u0074\u0020\u0062\u006c\u006f\u0063k\u0073");
};for _ ,_fee :=range _bef {if _fgd :=_fe .mergeBlocks (_fee );_fgd !=nil {return _fgd ;};};return nil ;};

// SetOptimizer sets the optimizer to optimize PDF before writing.
func (_bcdc *Creator )SetOptimizer (optimizer _afd .Optimizer ){_bcdc ._dagf =optimizer };

// Add adds a new Drawable to the chapter.
func (_cddae *Chapter )Add (d Drawable )error {if Drawable (_cddae )==d {_ff .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0043\u0061\u006e\u006e\u006f\u0074 \u0061\u0064\u0064\u0020\u0069\u0074\u0073\u0065\u006c\u0066");return _a .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");
};switch _edbd :=d .(type ){case *Paragraph ,*StyledParagraph ,*Image ,*Block ,*Table ,*PageBreak ,*Chapter :_cddae ._fdce =append (_cddae ._fdce ,d );case containerDrawable :_gfa ,_fec :=_edbd .ContainerComponent (_cddae );if _fec !=nil {return _fec ;
};_cddae ._fdce =append (_cddae ._fdce ,_gfa );default:_ff .Log .Debug ("\u0055n\u0073u\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u003a\u0020\u0025\u0054",d );return _a .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");
};return nil ;};

// SetMargins sets the Block's left, right, top, bottom, margins.
func (_dba *Block )SetMargins (left ,right ,top ,bottom float64 ){_dba ._b .Left =left ;_dba ._b .Right =right ;_dba ._b .Top =top ;_dba ._b .Bottom =bottom ;};

// SetShowNumbering sets a flag to indicate whether or not to show chapter numbers as part of title.
func (_feb *Chapter )SetShowNumbering (show bool ){_feb ._bcce =show ;_feb ._aff .SetText (_feb .headingText ());};

// SetText replaces all the text of the paragraph with the specified one.
func (_dadb *StyledParagraph )SetText (text string )*TextChunk {_dadb .Reset ();return _dadb .Append (text );};

// ColorRGBFromArithmetic creates a Color from arithmetic color values (0-1).
// Example:
//   green := ColorRGBFromArithmetic(0.0, 1.0, 0.0)
func ColorRGBFromArithmetic (r ,g ,b float64 )Color {return rgbColor {_faca :_aa .Max (_aa .Min (r ,1.0),0.0),_bec :_aa .Max (_aa .Min (g ,1.0),0.0),_abca :_aa .Max (_aa .Min (b ,1.0),0.0)};};func (_egdea *Invoice )drawAddress (_deab *InvoiceAddress )[]*StyledParagraph {var _gcga []*StyledParagraph ;
if _deab .Heading !=""{_dffaf :=_addb (_egdea ._egfed );_dffaf .SetMargins (0,0,0,7);_dffaf .Append (_deab .Heading );_gcga =append (_gcga ,_dffaf );};_addgg :=_addb (_egdea ._cedb );_addgg .SetLineHeight (1.2);_cfed :=_deab .Separator ;if _cfed ==""{_cfed =_egdea ._cbgc ;
};_ggac :=_deab .City ;if _deab .State !=""{if _ggac !=""{_ggac +=_cfed ;};_ggac +=_deab .State ;};if _deab .Zip !=""{if _ggac !=""{_ggac +=_cfed ;};_ggac +=_deab .Zip ;};if _deab .Name !=""{_addgg .Append (_deab .Name +"\u000a");};if _deab .Street !=""{_addgg .Append (_deab .Street +"\u000a");
};if _deab .Street2 !=""{_addgg .Append (_deab .Street2 +"\u000a");};if _ggac !=""{_addgg .Append (_ggac +"\u000a");};if _deab .Country !=""{_addgg .Append (_deab .Country +"\u000a");};_dagff :=_addb (_egdea ._cedb );_dagff .SetLineHeight (1.2);_dagff .SetMargins (0,0,7,0);
if _deab .Phone !=""{_dagff .Append (_deab .fmtLine (_deab .Phone ,"\u0050h\u006f\u006e\u0065\u003a\u0020",_deab .HidePhoneLabel ));};if _deab .Email !=""{_dagff .Append (_deab .fmtLine (_deab .Email ,"\u0045m\u0061\u0069\u006c\u003a\u0020",_deab .HideEmailLabel ));
};_gcga =append (_gcga ,_addgg ,_dagff );return _gcga ;};func _baee (_ffgb *_afd .PdfRectangle ,_gebda _ab .Matrix )*_afd .PdfRectangle {var _bbff _afd .PdfRectangle ;_bbff .Llx ,_bbff .Lly =_gebda .Transform (_ffgb .Llx ,_ffgb .Lly );_bbff .Urx ,_bbff .Ury =_gebda .Transform (_ffgb .Urx ,_ffgb .Ury );
_bbff .Normalize ();return &_bbff ;};func (_cgdg *StyledParagraph )getTextLineWidth (_fdbe []*TextChunk )float64 {var _dcaa float64 ;_gede :=len (_fdbe );for _afge ,_fffb :=range _fdbe {_fefd :=&_fffb .Style ;_gffbc :=len (_fffb .Text );for _adcc ,_ecdd :=range _fffb .Text {if _ecdd =='\u000A'{continue ;
};_gfgd ,_afbbf :=_fefd .Font .GetRuneMetrics (_ecdd );if !_afbbf {_ff .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_ecdd );
return -1;};_dcaa +=_fefd .FontSize *_gfgd .Wx ;if _ecdd !=' '&&(_afge !=_gede -1||_adcc !=_gffbc -1){_dcaa +=_fefd .CharSpacing *1000.0;};};};return _dcaa ;};const (CellHorizontalAlignmentLeft CellHorizontalAlignment =iota ;CellHorizontalAlignmentCenter ;
CellHorizontalAlignmentRight ;);func _adff (_cfd ,_edcb TextStyle )*Invoice {_geef :=&Invoice {_cdec :"\u0049N\u0056\u004f\u0049\u0043\u0045",_cbgc :"\u002c\u0020",_ccfe :_cfd ,_aag :_edcb };_geef ._dbab =&InvoiceAddress {Separator :_geef ._cbgc };_geef ._cgad =&InvoiceAddress {Heading :"\u0042i\u006c\u006c\u0020\u0074\u006f",Separator :_geef ._cbgc };
_eeca :=ColorRGBFrom8bit (245,245,245);_ccgd :=ColorRGBFrom8bit (155,155,155);_geef ._gdd =_edcb ;_geef ._gdd .Color =_ccgd ;_geef ._gdd .FontSize =20;_geef ._cedb =_cfd ;_geef ._egfed =_edcb ;_geef ._daff =_cfd ;_geef ._ggdd =_edcb ;_geef ._cbag =_geef .NewCellProps ();
_geef ._cbag .BackgroundColor =_eeca ;_geef ._cbag .TextStyle =_edcb ;_geef ._ffad =_geef .NewCellProps ();_geef ._ffad .TextStyle =_edcb ;_geef ._ffad .BackgroundColor =_eeca ;_geef ._ffad .BorderColor =_eeca ;_geef ._fgef =_geef .NewCellProps ();_geef ._fgef .BorderColor =_eeca ;
_geef ._fgef .BorderSides =[]CellBorderSide {CellBorderSideBottom };_geef ._fgef .Alignment =CellHorizontalAlignmentRight ;_geef ._gbcd =_geef .NewCellProps ();_geef ._gbcd .Alignment =CellHorizontalAlignmentRight ;_geef ._fdbg =[2]*InvoiceCell {_geef .newCell ("\u0049\u006e\u0076\u006f\u0069\u0063\u0065\u0020\u006eu\u006d\u0062\u0065\u0072",_geef ._cbag ),_geef .newCell ("",_geef ._cbag )};
_geef ._aacb =[2]*InvoiceCell {_geef .newCell ("\u0044\u0061\u0074\u0065",_geef ._cbag ),_geef .newCell ("",_geef ._cbag )};_geef ._cbad =[2]*InvoiceCell {_geef .newCell ("\u0044\u0075\u0065\u0020\u0044\u0061\u0074\u0065",_geef ._cbag ),_geef .newCell ("",_geef ._cbag )};
_geef ._cagd =[2]*InvoiceCell {_geef .newCell ("\u0053\u0075\u0062\u0074\u006f\u0074\u0061\u006c",_geef ._gbcd ),_geef .newCell ("",_geef ._gbcd )};_eaff :=_geef ._gbcd ;_eaff .TextStyle =_edcb ;_eaff .BackgroundColor =_eeca ;_eaff .BorderColor =_eeca ;
_geef ._abd =[2]*InvoiceCell {_geef .newCell ("\u0054\u006f\u0074a\u006c",_eaff ),_geef .newCell ("",_eaff )};_geef ._dbdc =[2]string {"\u004e\u006f\u0074e\u0073",""};_geef ._ccf =[2]string {"T\u0065r\u006d\u0073\u0020\u0061\u006e\u0064\u0020\u0063o\u006e\u0064\u0069\u0074io\u006e\u0073",""};
_geef ._ccec =[]*InvoiceCell {_geef .newColumn ("D\u0065\u0073\u0063\u0072\u0069\u0070\u0074\u0069\u006f\u006e",CellHorizontalAlignmentLeft ),_geef .newColumn ("\u0051\u0075\u0061\u006e\u0074\u0069\u0074\u0079",CellHorizontalAlignmentRight ),_geef .newColumn ("\u0055\u006e\u0069\u0074\u0020\u0070\u0072\u0069\u0063\u0065",CellHorizontalAlignmentRight ),_geef .newColumn ("\u0041\u006d\u006f\u0075\u006e\u0074",CellHorizontalAlignmentRight )};
return _geef ;};

// SetStyleTop sets border style for top side.
func (_ebdf *border )SetStyleTop (style CellBorderStyle ){_ebdf ._adgb =style };

// Height returns the Block's height.
func (_aad *Block )Height ()float64 {return _aad ._gg };

// GeneratePageBlocks draws the filled curve on page blocks.
func (_caef *FilledCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_ffgg :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_dfeab ,_ ,_bdffd :=_caef .draw ("");if _bdffd !=nil {return nil ,ctx ,_bdffd ;};_bdffd =_ffgg .addContentsByString (string (_dfeab ));
if _bdffd !=nil {return nil ,ctx ,_bdffd ;};return []*Block {_ffgg },ctx ,nil ;};

// SetBorderLineStyle sets border style (currently dashed or plain).
func (_gcad *TableCell )SetBorderLineStyle (style _fd .LineStyle ){_gcad ._becdfa =style };

// FrontpageFunctionArgs holds the input arguments to a front page drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FrontpageFunctionArgs struct{PageNum int ;TotalPages int ;};

// AddLine appends a new line to the invoice line items table.
func (_dgfgd *Invoice )AddLine (values ...string )[]*InvoiceCell {_agfe :=len (_dgfgd ._ccec );var _caf []*InvoiceCell ;for _bbeg ,_bdeb :=range values {_edbgb :=_dgfgd .newCell (_bdeb ,_dgfgd ._fgef );if _bbeg < _agfe {_edbgb .Alignment =_dgfgd ._ccec [_bbeg ].Alignment ;
};_caf =append (_caf ,_edbgb );};_dgfgd ._geac =append (_dgfgd ._geac ,_caf );return _caf ;};

// Write output of creator to io.Writer interface.
func (_ega *Creator )Write (ws _af .Writer )error {if _gagb :=_ega .Finalize ();_gagb !=nil {return _gagb ;};_abac :=_afd .NewPdfWriter ();_abac .SetOptimizer (_ega ._dagf );if _ega ._gbd !=nil {_aeaf :=_abac .SetForms (_ega ._gbd );if _aeaf !=nil {_ff .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_aeaf );
return _aeaf ;};};if _ega ._ddd !=nil {_abac .AddOutlineTree (_ega ._ddd );}else if _ega ._gbed !=nil &&_ega .AddOutlines {_abac .AddOutlineTree (&_ega ._gbed .ToPdfOutline ().PdfOutlineTreeNode );};if _ega ._efcg !=nil {if _cdb :=_abac .SetPageLabels (_ega ._efcg );
_cdb !=nil {_ff .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020C\u006f\u0075\u006c\u0064 no\u0074 s\u0065\u0074\u0020\u0070\u0061\u0067\u0065 l\u0061\u0062\u0065\u006c\u0073\u003a\u0020%\u0076",_cdb );return _cdb ;};};if _ega ._bdb !=nil {for _ ,_cfa :=range _ega ._bdb {_bcee :=_cfa .SubsetRegistered ();
if _bcee !=nil {_ff .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0043\u006f\u0075\u006c\u0064\u0020\u006e\u006ft\u0020s\u0075\u0062\u0073\u0065\u0074\u0020\u0066\u006f\u006e\u0074\u003a\u0020\u0025\u0076",_bcee );return _bcee ;};};};if _ega ._bgda !=nil {_bbfb :=_ega ._bgda (&_abac );
if _bbfb !=nil {_ff .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_bbfb );return _bbfb ;};};for _ ,_gdcc :=range _ega ._gef {_fcfgc :=_abac .AddPage (_gdcc );if _fcfgc !=nil {_ff .Log .Error ("\u0046\u0061\u0069\u006ced\u0020\u0074\u006f\u0020\u0061\u0064\u0064\u0020\u0050\u0061\u0067\u0065\u003a\u0020%\u0076",_fcfgc );
return _fcfgc ;};};_gcb :=_abac .Write (ws );if _gcb !=nil {return _gcb ;};return nil ;};

// SetNumber sets the number of the invoice.
func (_gbef *Invoice )SetNumber (number string )(*InvoiceCell ,*InvoiceCell ){_gbef ._fdbg [1].Value =number ;return _gbef ._fdbg [0],_gbef ._fdbg [1];};func _bbb (_cga *Chapter ,_bdff *TOC ,_eae *_afd .Outline ,_ceg string ,_ffb int ,_dfdd TextStyle )*Chapter {var _aeeg uint =1;
if _cga !=nil {_aeeg =_cga ._bcb +1;};_ddbe :=&Chapter {_dadd :_ffb ,_eagb :_ceg ,_bcce :true ,_abebg :true ,_cgd :_cga ,_dgaa :_bdff ,_cee :_eae ,_fdce :[]Drawable {},_bcb :_aeeg };_fgae :=_gecb (_ddbe .headingText (),_dfdd );_fgae .SetFont (_dfdd .Font );
_fgae .SetFontSize (_dfdd .FontSize );_ddbe ._aff =_fgae ;return _ddbe ;};func (_def *Block )mergeBlocks (_gbg *Block )error {_dff :=_ca (_def ._de ,_def ._cf ,_gbg ._de ,_gbg ._cf );if _dff !=nil {return _dff ;};for _ ,_eef :=range _gbg ._ad {_def .AddAnnotation (_eef );
};return nil ;};var (ColorBlack =ColorRGBFromArithmetic (0,0,0);ColorWhite =ColorRGBFromArithmetic (1,1,1);ColorRed =ColorRGBFromArithmetic (1,0,0);ColorGreen =ColorRGBFromArithmetic (0,1,0);ColorBlue =ColorRGBFromArithmetic (0,0,1);ColorYellow =ColorRGBFromArithmetic (1,1,0);
);type rgbColor struct{_faca ,_bec ,_abca float64 };

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_egeg *StyledParagraph )SetTextAlignment (align TextAlignment ){_egeg ._aeea =align };

// SetBorderWidth sets the border width.
func (_acag *Ellipse )SetBorderWidth (bw float64 ){_acag ._bffe =bw };

// AppendCurve appends a Bezier curve to the filled curve.
func (_eab *FilledCurve )AppendCurve (curve _fd .CubicBezierCurve )*FilledCurve {_eab ._cefb =append (_eab ._cefb ,curve );return _eab ;};

// Block contains a portion of PDF Page contents. It has a width and a position and can
// be placed anywhere on a Page.  It can even contain a whole Page, and is used in the creator
// where each Drawable object can output one or more blocks, each representing content for separate pages
// (typically needed when Page breaks occur).
type Block struct{_de *_da .ContentStreamOperations ;_cf *_afd .PdfPageResources ;_cd Positioning ;_cg ,_fc float64 ;_dag float64 ;_gg float64 ;_fgb float64 ;_b Margins ;_ad []*_afd .PdfAnnotation ;};

// AddressStyle returns the style properties used to render the content of
// the invoice address sections.
func (_bbbd *Invoice )AddressStyle ()TextStyle {return _bbbd ._cedb };

// Chapter is used to arrange multiple drawables (paragraphs, images, etc) into a single section.
// The concept is the same as a book or a report chapter.
type Chapter struct{_dadd int ;_eagb string ;_aff *Paragraph ;_fdce []Drawable ;_ecba int ;_bcce bool ;_abebg bool ;_fcgc Positioning ;_fdfbe ,_efe float64 ;_caaa Margins ;_cgd *Chapter ;_dgaa *TOC ;_cee *_afd .Outline ;_ddg *_afd .OutlineItem ;_bcb uint ;
};func (_agf *Block )addContentsByString (_age string )error {_ged :=_da .NewContentStreamParser (_age );_gdb ,_ef :=_ged .Parse ();if _ef !=nil {return _ef ;};_agf ._de .WrapIfNeeded ();_gdb .WrapIfNeeded ();*_agf ._de =append (*_agf ._de ,*_gdb ...);
return nil ;};

// SetFillColor sets the fill color.
func (_bbaf *Polygon )SetFillColor (color Color ){_bbaf ._aaff .FillColor =_bff (color )};

// TOC represents a table of contents component.
// It consists of a paragraph heading and a collection of
// table of contents lines.
// The representation of a table of contents line is as follows:
//       [number] [title]      [separator] [page]
// e.g.: Chapter1 Introduction ........... 1
type TOC struct{_bcge *StyledParagraph ;_bgeda []*TOCLine ;_bcbdg TextStyle ;_fcdb TextStyle ;_bddde TextStyle ;_adef TextStyle ;_fcbf string ;_acbcb float64 ;_ffcd Margins ;_bccd Positioning ;_bbgb TextStyle ;_gega bool ;};

// NewFilledCurve returns a instance of filled curve.
func (_gggca *Creator )NewFilledCurve ()*FilledCurve {return _bfde ()};

// SetMargins sets the Paragraph's margins.
func (_fcaaa *StyledParagraph )SetMargins (left ,right ,top ,bottom float64 ){_fcaaa ._ggdg .Left =left ;_fcaaa ._ggdg .Right =right ;_fcaaa ._ggdg .Top =top ;_fcaaa ._ggdg .Bottom =bottom ;};

// NewCurve returns new instance of Curve between points (x1,y1) and (x2, y2) with control point (cx,cy).
func (_bfga *Creator )NewCurve (x1 ,y1 ,cx ,cy ,x2 ,y2 float64 )*Curve {return _cggd (x1 ,y1 ,cx ,cy ,x2 ,y2 );};

// Height returns the height of the Paragraph. The height is calculated based on the input text and
// how it is wrapped within the container. Does not include Margins.
func (_efee *Paragraph )Height ()float64 {_efee .wrapText ();return float64 (len (_efee ._eedde ))*_efee ._ffdf *_efee ._afec ;};

// LevelOffset returns the amount of space an indentation level occupies.
func (_ggcb *TOCLine )LevelOffset ()float64 {return _ggcb ._gdfd };func _dbbd (_bbec *_afd .Image )(*Image ,error ){_adcf :=float64 (_bbec .Width );_daeg :=float64 (_bbec .Height );return &Image {_cfaa :_bbec ,_beagd :_adcf ,_cbfde :_daeg ,_fdbad :_adcf ,_fcae :_daeg ,_aegda :0,_bfdfe :1.0,_fcb :PositionRelative },nil ;
};

// SetLevel sets the indentation level of the TOC line.
func (_dgdf *TOCLine )SetLevel (level uint ){_dgdf ._dbgca =level ;_dgdf ._dfec ._ggdg .Left =_dgdf ._gada +float64 (_dgdf ._dbgca -1)*_dgdf ._gdfd ;};

// Positioning represents the positioning type for drawing creator components (relative/absolute).
type Positioning int ;func _bfcb (_dccf ,_dagc ,_dbee ,_cdeab float64 )*Rectangle {return &Rectangle {_fcaf :_dccf ,_dbba :_dagc ,_dgag :_dbee ,_gacd :_cdeab ,_adgba :ColorBlack ,_bafe :1.0,_cbcd :1.0,_fbae :1.0};};

// CreateFrontPage sets a function to generate a front Page.
func (_gggc *Creator )CreateFrontPage (genFrontPageFunc func (_fag FrontpageFunctionArgs )){_gggc ._dfb =genFrontPageFunc ;};func (_bbed *StyledParagraph )wrapText ()error {return _bbed .wrapChunks (true )};

// Polygon represents a polygon shape.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Polygon struct{_aaff *_fd .Polygon ;_aceae float64 ;_gafa float64 ;};

// RotateDeg rotates the current active page by angle degrees.  An error is returned on failure,
// which can be if there is no currently active page, or the angleDeg is not a multiple of 90 degrees.
func (_egg *Creator )RotateDeg (angleDeg int64 )error {_cdc :=_egg .getActivePage ();if _cdc ==nil {_ff .Log .Debug ("F\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0065\u003a\u0020\u006e\u006f\u0020p\u0061\u0067\u0065\u0020\u0063\u0075\u0072\u0072\u0065\u006etl\u0079\u0020\u0061c\u0074i\u0076\u0065");
return _a .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};if angleDeg %90!=0{_ff .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0050\u0061\u0067e\u0020\u0072\u006f\u0074\u0061\u0074\u0069on\u0020\u0061\u006e\u0067l\u0065\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006dul\u0074\u0069p\u006c\u0065\u0020\u006f\u0066\u0020\u0039\u0030");
return _a .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};var _gfef int64 ;if _cdc .Rotate !=nil {_gfef =*(_cdc .Rotate );};_gfef +=angleDeg ;_cdc .Rotate =&_gfef ;return nil ;};

// NewTable create a new Table with a specified number of columns.
func (_fae *Creator )NewTable (cols int )*Table {return _gggcg (cols )};

// MoveRight moves the drawing context right by relative displacement dx (negative goes left).
func (_eecff *Creator )MoveRight (dx float64 ){_eecff ._gbgd .X +=dx };

// SetMargins sets the Chapter margins: left, right, top, bottom.
// Typically not needed as the creator's page margins are used.
func (_aeff *Chapter )SetMargins (left ,right ,top ,bottom float64 ){_aeff ._caaa .Left =left ;_aeff ._caaa .Right =right ;_aeff ._caaa .Top =top ;_aeff ._caaa .Bottom =bottom ;};

// GetOptimizer returns current PDF optimizer.
func (_bgcc *Creator )GetOptimizer ()_afd .Optimizer {return _bgcc ._dagf };

// SetPos sets the absolute position. Changes object positioning to absolute.
func (_gbcab *Image )SetPos (x ,y float64 ){_gbcab ._fcb =PositionAbsolute ;_gbcab ._dbbb =x ;_gbcab ._ebdd =y ;};func (_bda *Block )transform (_gf _ab .Matrix ){_fbd :=_da .NewContentCreator ().Add_cm (_gf [0],_gf [1],_gf [3],_gf [4],_gf [6],_gf [7]).Operations ();
*_bda ._de =append (*_fbd ,*_bda ._de ...);_bda ._de .WrapIfNeeded ();};

// Number returns the invoice number description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_adafe *Invoice )Number ()(*InvoiceCell ,*InvoiceCell ){return _adafe ._fdbg [0],_adafe ._fdbg [1]};

// GetRowHeight returns the height of the specified row.
func (_deag *Table )GetRowHeight (row int )(float64 ,error ){if row < 1||row > len (_deag ._aedeb ){return 0,_a .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};return _deag ._aedeb [row -1],nil ;
};

// SetInline sets the inline mode of the division.
func (_cfcb *Division )SetInline (inline bool ){_cfcb ._gbag =inline };

// SetEnableWrap sets the line wrapping enabled flag.
func (_dafd *Paragraph )SetEnableWrap (enableWrap bool ){_dafd ._fceb =enableWrap ;_dafd ._beee =false };

// SetEncoder sets the encoding/compression mechanism for the image.
func (_gebc *Image )SetEncoder (encoder _c .StreamEncoder ){_gebc ._cgdee =encoder };

// SetBorderColor sets the border color.
func (_bgba *Ellipse )SetBorderColor (col Color ){_bgba ._dgeg =col };

// Width is not used. Not used as a Division element is designed to fill into available width depending on
// context.  Returns 0.
func (_febg *Division )Width ()float64 {return 0};

// Polyline represents a slice of points that are connected as straight lines.
// Implements the Drawable interface and can be rendered using the Creator.
type Polyline struct{_gbcb *_fd .Polyline ;_afae float64 ;};

// SetWidthLeft sets border width for left.
func (_efg *border )SetWidthLeft (bw float64 ){_efg ._eec =bw };func _eaa (_fce ,_eded *_afd .PdfPageResources )error {_fbeg ,_ :=_fce .GetColorspaces ();if _fbeg !=nil &&len (_fbeg .Colorspaces )> 0{for _aef ,_cfc :=range _fbeg .Colorspaces {_eee :=*_c .MakeName (_aef );
if _eded .HasColorspaceByName (_eee ){continue ;};_fcee :=_eded .SetColorspaceByName (_eee ,_cfc );if _fcee !=nil {return _fcee ;};};};return nil ;};

// NewImage create a new image from a unidoc image (model.Image).
func (_adf *Creator )NewImage (img *_afd .Image )(*Image ,error ){return _dbbd (img )};

// WriteToFile writes the Creator output to file specified by path.
func (_dafad *Creator )WriteToFile (outputPath string )error {_daee ,_dagb :=_f .Create (outputPath );if _dagb !=nil {return _dagb ;};defer _daee .Close ();return _dafad .Write (_daee );};

// SetLineNumberStyle sets the style for the numbers part of all new lines
// of the table of contents.
func (_badec *TOC )SetLineNumberStyle (style TextStyle ){_badec ._bcbdg =style };func _cggd (_bfa ,_bgbd ,_cbbe ,_bac ,_agec ,_dfea float64 )*Curve {_aeffg :=&Curve {};_aeffg ._efcd =_bfa ;_aeffg ._eggc =_bgbd ;_aeffg ._faec =_cbbe ;_aeffg ._cba =_bac ;
_aeffg ._eceg =_agec ;_aeffg ._bbfbe =_dfea ;_aeffg ._cbaa =ColorBlack ;_aeffg ._bcdg =1.0;return _aeffg ;};

// GetCoords returns the (x1, y1), (x2, y2) points defining the Line.
func (_gffa *Line )GetCoords ()(float64 ,float64 ,float64 ,float64 ){return _gffa ._bfge ,_gffa ._afbb ,_gffa ._eddf ,_gffa ._caee ;};

// SetLink makes the line an internal link.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
func (_cgacg *TOCLine )SetLink (page int64 ,x ,y float64 ){_cgacg ._afaee =x ;_cgacg ._ecdg =y ;_cgacg ._eeddeg =page ;_ggaa :=_cgacg ._dfec ._eggec .Color ;_cgacg .Number .Style .Color =_ggaa ;_cgacg .Title .Style .Color =_ggaa ;_cgacg .Separator .Style .Color =_ggaa ;
_cgacg .Page .Style .Color =_ggaa ;};

// SetWidthTop sets border width for top.
func (_ecgf *border )SetWidthTop (bw float64 ){_ecgf ._efa =bw };

// Width returns the width of the Paragraph.
func (_afac *StyledParagraph )Width ()float64 {if _afac ._beab &&int (_afac ._cdcee )> 0{return _afac ._cdcee ;};return _afac .getTextWidth ()/1000.0;};

// SetBorderColor sets the cell's border color.
func (_ffaga *TableCell )SetBorderColor (col Color ){_ffaga ._ggef =col ;_ffaga ._fdcc =col ;_ffaga ._bfca =col ;_ffaga ._aeae =col ;};

// AddTextItem appends a new item with the specified text to the list.
// The method creates a styled paragraph with the specified text and returns
// it so that the item style can be customized.
// The method also returns the marker used for the newly added item.
// The marker object can be used to change the text and style of the marker
// for the current item.
func (_dgge *List )AddTextItem (text string )(*StyledParagraph ,*TextChunk ,error ){_aagg :=_addb (_dgge ._egdee );_aagg .Append (text );_befg ,_gebf :=_dgge .Add (_aagg );return _aagg ,_befg ,_gebf ;};

// Date returns the invoice date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_bcbab *Invoice )Date ()(*InvoiceCell ,*InvoiceCell ){return _bcbab ._aacb [0],_bcbab ._aacb [1]};

// SetLineTitleStyle sets the style for the title part of all new lines
// of the table of contents.
func (_fgeag *TOC )SetLineTitleStyle (style TextStyle ){_fgeag ._fcdb =style };

// NewEllipse creates a new ellipse centered at (xc,yc) with a width and height specified.
func (_afe *Creator )NewEllipse (xc ,yc ,width ,height float64 )*Ellipse {return _egfc (xc ,yc ,width ,height );};func _defd (_cbfg _ac .Image )(*Image ,error ){_dfacg ,_gcef :=_afd .ImageHandling .NewImageFromGoImage (_cbfg );if _gcef !=nil {return nil ,_gcef ;
};return _dbbd (_dfacg );};

// SetTitle sets the title of the invoice.
func (_bdgd *Invoice )SetTitle (title string ){_bdgd ._cdec =title };

// SetBorderOpacity sets the border opacity.
func (_dddb *Rectangle )SetBorderOpacity (opacity float64 ){_dddb ._fbae =opacity };

// Fit fits the chunk into the specified bounding box, cropping off the
// remainder in a new chunk, if it exceeds the specified dimensions.
// NOTE: The method assumes a line height of 1.0. In order to account for other
// line height values, the passed in height must be divided by the line height:
// height = height / lineHeight
func (_dcde *TextChunk )Fit (width ,height float64 )(*TextChunk ,error ){_fcfee ,_bcaag :=_dcde .Wrap (width );if _bcaag !=nil {return nil ,_bcaag ;};_fbfb :=int (height /_dcde .Style .FontSize );if _fbfb >=len (_fcfee ){return nil ,nil ;};_afgcg :="\u000a";
_dcde .Text =_fg .Replace (_fg .Join (_fcfee [:_fbfb ],"\u0020"),_afgcg +"\u0020",_afgcg ,-1);_bfea :=_fg .Replace (_fg .Join (_fcfee [_fbfb :],"\u0020"),_afgcg +"\u0020",_afgcg ,-1);return NewTextChunk (_bfea ,_dcde .Style ),nil ;};

// NewTOC creates a new table of contents.
func (_eeba *Creator )NewTOC (title string )*TOC {_bdaa :=_eeba .NewTextStyle ();_bdaa .Font =_eeba ._aeeb ;return _gaeg (title ,_eeba .NewTextStyle (),_bdaa );};func (_ecfed *TextChunk )clone ()*TextChunk {_fece :=*_ecfed ;_fece ._fbdcc =_aedef (_ecfed ._fbdcc );
return &_fece ;};

// ColorCMYKFromArithmetic creates a Color from arithmetic color values (0-1).
// Example:
//   green := ColorCMYKFromArithmetic(1.0, 0.0, 1.0, 0.0)
func ColorCMYKFromArithmetic (c ,m ,y ,k float64 )Color {return cmykColor {_fdgea :_aa .Max (_aa .Min (c ,1.0),0.0),_gebe :_aa .Max (_aa .Min (m ,1.0),0.0),_ggb :_aa .Max (_aa .Min (y ,1.0),0.0),_dagd :_aa .Max (_aa .Min (k ,1.0),0.0)};};

// MoveY moves the drawing context to absolute position y.
func (_adgd *Creator )MoveY (y float64 ){_adgd ._gbgd .Y =y };

// SkipOver skips over a specified number of rows and cols.
func (_cbaf *Table )SkipOver (rows ,cols int ){_dcge :=rows *_cbaf ._fceeb +cols -1;if _dcge < 0{_ff .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};_cbaf ._bgeb +=_dcge ;};

// Width returns the width of the Paragraph.
func (_gbdb *Paragraph )Width ()float64 {if _gbdb ._fceb &&int (_gbdb ._efbd )> 0{return _gbdb ._efbd ;};return _gbdb .getTextWidth ()/1000.0;};

// Rectangle defines a rectangle with upper left corner at (x,y) and a specified width and height.  The rectangle
// can have a colored fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Rectangle struct{_fcaf float64 ;_dbba float64 ;_dgag float64 ;_gacd float64 ;_fgagc Color ;_cbcd float64 ;_adgba Color ;_bafe float64 ;_fbae float64 ;};

// Height returns the current page height.
func (_fbff *Creator )Height ()float64 {return _fbff ._eadf };func (_beeab *Table )newCell (_gcgd int )*TableCell {_beeab ._bgeb ++;_ecbeb :=(_beeab ._bgeb -1)/_beeab ._fceeb +1;for _ecbeb > _beeab ._bace {_beeab ._bace ++;_beeab ._aedeb =append (_beeab ._aedeb ,_beeab ._bbee );
};_ggeae :=(_beeab ._bgeb -1)%(_beeab ._fceeb )+1;_cfdd :=&TableCell {};_cfdd ._dfda =_ecbeb ;_cfdd ._ccegd =_ggeae ;_cfdd ._fdab =1;_cfdd ._dcgf =5;_cfdd ._gcce =CellBorderStyleNone ;_cfdd ._becdfa =_fd .LineStyleSolid ;_cfdd ._gaef =CellHorizontalAlignmentLeft ;
_cfdd ._bbag =CellVerticalAlignmentTop ;_cfdd ._dggfd =0;_cfdd ._edg =0;_cfdd ._debe =0;_cfdd ._edcbb =0;_gfbf :=ColorBlack ;_cfdd ._ggef =_gfbf ;_cfdd ._fdcc =_gfbf ;_cfdd ._bfca =_gfbf ;_cfdd ._aeae =_gfbf ;if _gcgd < 1{_ff .Log .Debug ("\u0054\u0061\u0062\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0063\u006f\u006c\u0073\u0070a\u006e\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061n\u0020\u0031\u0020\u0028\u0025\u0064\u0029\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006cs\u0070\u0061n\u0020\u0074o\u00201\u002e",_gcgd );
_gcgd =1;};_gcfdf :=_beeab ._fceeb -(_cfdd ._ccegd -1);if _gcgd > _gcfdf {_ff .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0065\u006c\u006c\u0020\u0063o\u006c\u0073\u0070\u0061\u006e\u0020\u0028\u0025\u0064\u0029\u0020\u0065\u0078\u0063\u0065\u0065\u0064\u0073\u0020\u0072\u0065\u006d\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0072\u006f\u0077\u0020\u0063\u006f\u006c\u0073\u0020\u0028\u0025d\u0029\u002e\u0020\u0041\u0064\u006a\u0075\u0073\u0074\u0069\u006e\u0067 \u0063\u006f\u006c\u0073\u0070\u0061n\u002e",_gcgd ,_gcfdf );
_gcgd =_gcfdf ;};_cfdd ._agdd =_gcgd ;_beeab ._bgeb +=_gcgd -1;_beeab ._efgd =append (_beeab ._efgd ,_cfdd );_cfdd ._ffdff =_beeab ;return _cfdd ;};

// SetTerms sets the terms and conditions section of the invoice.
func (_cbfc *Invoice )SetTerms (title ,content string ){_cbfc ._ccf =[2]string {title ,content }};const (CellBorderSideLeft CellBorderSide =iota ;CellBorderSideRight ;CellBorderSideTop ;CellBorderSideBottom ;CellBorderSideAll ;);

// PageBreak represents a page break for a chapter.
type PageBreak struct{};

// SetAngle sets Image rotation angle in degrees.
func (_fgag *Image )SetAngle (angle float64 ){_fgag ._aegda =angle };

// Division is a container component which can wrap across multiple pages (unlike Block).
// It can contain multiple Drawable components (currently supporting Paragraph and Image).
//
// The component stacking behavior is vertical, where the Drawables are drawn on top of each other.
// Also supports horizontal stacking by activating the inline mode.
type Division struct{_bdcb []VectorDrawable ;_egb Positioning ;_agab Margins ;_gbag bool ;};

// Draw processes the specified Drawable widget and generates blocks that can
// be rendered to the output document. The generated blocks can span over one
// or more pages. Additional pages are added if the contents go over the current
// page. Each generated block is assigned to the creator page it will be
// rendered to. In order to render the generated blocks to the creator pages,
// call Finalize, Write or WriteToFile.
func (_cdeec *Creator )Draw (d Drawable )error {if _cdeec .getActivePage ()==nil {_cdeec .NewPage ();};_efbe ,_edfe ,_cdg :=d .GeneratePageBlocks (_cdeec ._gbgd );if _cdg !=nil {return _cdg ;};for _fgba ,_aecag :=range _efbe {if _fgba > 0{_cdeec .NewPage ();
};_add :=_cdeec .getActivePage ();if _ffdg ,_abf :=_cdeec ._bffa [_add ];_abf {if _gcfg :=_ffdg .mergeBlocks (_aecag );_gcfg !=nil {return _gcfg ;};if _abcc :=_eaa (_aecag ._cf ,_ffdg ._cf );_abcc !=nil {return _abcc ;};}else {_cdeec ._bffa [_add ]=_aecag ;
};};_cdeec ._gbgd .X =_edfe .X ;_cdeec ._gbgd .Y =_edfe .Y ;_cdeec ._gbgd .Height =_edfe .PageHeight -_edfe .Y -_edfe .Margins .Bottom ;return nil ;};

// GeneratePageBlocks draws the polyline on a new block representing the page.
// Implements the Drawable interface.
func (_bcaa *Polyline )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fccd :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_adeaa ,_fgdc :=_fccd .setOpacity (_bcaa ._afae ,_bcaa ._afae );if _fgdc !=nil {return nil ,ctx ,_fgdc ;};_cfgf :=_bcaa ._gbcb .Points ;
for _cbff :=range _cfgf {_aede :=&_cfgf [_cbff ];_aede .Y =ctx .PageHeight -_aede .Y ;};_bddb ,_ ,_fgdc :=_bcaa ._gbcb .Draw (_adeaa );if _fgdc !=nil {return nil ,ctx ,_fgdc ;};if _fgdc =_fccd .addContentsByString (string (_bddb ));_fgdc !=nil {return nil ,ctx ,_fgdc ;
};return []*Block {_fccd },ctx ,nil ;};

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_ccfc *Paragraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _ccfc ._fegc .Left ,_ccfc ._fegc .Right ,_ccfc ._fegc .Top ,_ccfc ._fegc .Bottom ;};

// ScaleToHeight scales the Block to a specified height, maintaining the same aspect ratio.
func (_egf *Block )ScaleToHeight (h float64 ){_ee :=h /_egf ._gg ;_egf .Scale (_ee ,_ee )};

// SkipCells skips over a specified number of cells in the table.
func (_gcag *Table )SkipCells (num int ){if num < 0{_ff .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};_gcag ._bgeb +=num ;};

// GeneratePageBlocks generate the Page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages.
func (_fdd *Chapter )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cbb :=ctx ;if _fdd ._fcgc .IsRelative (){ctx .X +=_fdd ._caaa .Left ;ctx .Y +=_fdd ._caaa .Top ;ctx .Width -=_fdd ._caaa .Left +_fdd ._caaa .Right ;ctx .Height -=_fdd ._caaa .Top ;
};_abgf ,_acce ,_abcg :=_fdd ._aff .GeneratePageBlocks (ctx );if _abcg !=nil {return _abgf ,ctx ,_abcg ;};ctx =_acce ;_eed :=ctx .X ;_fcff :=ctx .Y -_fdd ._aff .Height ();_gbgc :=int64 (ctx .Page );_gga :=_fdd .headingNumber ();_dgg :=_fdd .headingText ();
if _fdd ._abebg {_gead :=_fdd ._dgaa .Add (_gga ,_fdd ._eagb ,_e .FormatInt (_gbgc ,10),_fdd ._bcb );if _fdd ._dgaa ._gega {_gead .SetLink (_gbgc ,_eed ,_fcff );};};if _fdd ._ddg ==nil {_fdd ._ddg =_afd .NewOutlineItem (_dgg ,_afd .NewOutlineDest (_gbgc -1,_eed ,_fcff ));
if _fdd ._cgd !=nil {_fdd ._cgd ._ddg .Add (_fdd ._ddg );}else {_fdd ._cee .Add (_fdd ._ddg );};}else {_dfg :=&_fdd ._ddg .Dest ;_dfg .Page =_gbgc -1;_dfg .X =_eed ;_dfg .Y =_fcff ;};for _ ,_dbfe :=range _fdd ._fdce {_fbfe ,_agef ,_gca :=_dbfe .GeneratePageBlocks (ctx );
if _gca !=nil {return _abgf ,ctx ,_gca ;};if len (_fbfe )< 1{continue ;};_abgf [len (_abgf )-1].mergeBlocks (_fbfe [0]);_abgf =append (_abgf ,_fbfe [1:]...);ctx =_agef ;};if _fdd ._fcgc .IsRelative (){ctx .X =_cbb .X ;};if _fdd ._fcgc .IsAbsolute (){return _abgf ,_cbb ,nil ;
};return _abgf ,ctx ,nil ;};

// Wrap wraps the text of the chunk into lines based on its style and the
// specified width.
func (_abec *TextChunk )Wrap (width float64 )([]string ,error ){if int (width )<=0{return []string {_abec .Text },nil ;};var _bdba []string ;var _ecebc []rune ;var _dffc float64 ;var _bccgf []float64 ;_bgaef :=_abec .Style ;for _ ,_bbafb :=range _abec .Text {if _bbafb =='\u000A'{_bdba =append (_bdba ,_fg .TrimRightFunc (string (_ecebc ),_dg .IsSpace )+string (_bbafb ));
_ecebc =nil ;_dffc =0;_bccgf =nil ;continue ;};_cefbc :=_bbafb ==' ';_gebd ,_bdcd :=_bgaef .Font .GetRuneMetrics (_bbafb );if !_bdcd {_ff .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006det\u0072i\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064!\u0020\u0072\u0075\u006e\u0065\u003d\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0066o\u006e\u0074\u003d\u0025\u0073\u0020\u0025\u0023\u0071",_bbafb ,_bbafb ,_bgaef .Font .BaseFont (),_bgaef .Font .Subtype ());
_ff .Log .Trace ("\u0046o\u006e\u0074\u003a\u0020\u0025\u0023v",_bgaef .Font );_ff .Log .Trace ("\u0045\u006e\u0063o\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076",_bgaef .Font .Encoder ());return nil ,_a .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");
};_gfda :=_bgaef .FontSize *_gebd .Wx ;_abdcb :=_gfda ;if !_cefbc {_abdcb =_gfda +_bgaef .CharSpacing *1000.0;};if _dffc +_gfda > width *1000.0{_cfga :=-1;if !_cefbc {for _abgba :=len (_ecebc )-1;_abgba >=0;_abgba --{if _ecebc [_abgba ]==' '{_cfga =_abgba ;
break ;};};};_dgbf :=string (_ecebc );if _cfga > 0{_dgbf =string (_ecebc [0:_cfga +1]);_ecebc =append (_ecebc [_cfga +1:],_bbafb );_bccgf =append (_bccgf [_cfga +1:],_abdcb );_dffc =0;for _ ,_bggda :=range _bccgf {_dffc +=_bggda ;};}else {if _cefbc {_ecebc =[]rune {};
_bccgf =[]float64 {};_dffc =0;}else {_ecebc =[]rune {_bbafb };_bccgf =[]float64 {_abdcb };_dffc =_abdcb ;};};_bdba =append (_bdba ,_fg .TrimRightFunc (_dgbf ,_dg .IsSpace ));}else {_ecebc =append (_ecebc ,_bbafb );_dffc +=_abdcb ;_bccgf =append (_bccgf ,_abdcb );
};};if len (_ecebc )> 0{_bdba =append (_bdba ,string (_ecebc ));};return _bdba ,nil ;};

// Angle returns the block rotation angle in degrees.
func (_aec *Block )Angle ()float64 {return _aec ._fgb };

// GeneratePageBlocks draws the composite curve polygon on a new block
// representing the page. Implements the Drawable interface.
func (_dabe *CurvePolygon )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_addg :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_egdg ,_ebae :=_addg .setOpacity (_dabe ._gfdeg ,_dabe ._fabg );if _ebae !=nil {return nil ,ctx ,_ebae ;
};_fbda :=_dabe ._aeed ;_fbda .FillEnabled =_fbda .FillColor !=nil ;_fbda .BorderEnabled =_fbda .BorderColor !=nil &&_fbda .BorderWidth > 0;var (_ceff =ctx .PageHeight ;_gfba =_fbda .Rings ;_cca =make ([][]_fd .CubicBezierCurve ,0,len (_fbda .Rings ));
);for _ ,_bfdc :=range _gfba {_bca :=make ([]_fd .CubicBezierCurve ,0,len (_bfdc ));for _ ,_dbag :=range _bfdc {_fdga :=_dbag ;_fdga .P0 .Y =_ceff -_fdga .P0 .Y ;_fdga .P1 .Y =_ceff -_fdga .P1 .Y ;_fdga .P2 .Y =_ceff -_fdga .P2 .Y ;_fdga .P3 .Y =_ceff -_fdga .P3 .Y ;
_bca =append (_bca ,_fdga );};_cca =append (_cca ,_bca );};_fbda .Rings =_cca ;defer func (){_fbda .Rings =_gfba }();_edff ,_ ,_ebae :=_fbda .Draw (_egdg );if _ebae !=nil {return nil ,ctx ,_ebae ;};if _ebae =_addg .addContentsByString (string (_edff ));
_ebae !=nil {return nil ,ctx ,_ebae ;};return []*Block {_addg },ctx ,nil ;};

// NewTOCLine creates a new table of contents line with the default style.
func (_dedf *Creator )NewTOCLine (number ,title ,page string ,level uint )*TOCLine {return _cade (number ,title ,page ,level ,_dedf .NewTextStyle ());};

// SetTotal sets the total of the invoice.
func (_gfeed *Invoice )SetTotal (value string ){_gfeed ._abd [1].Value =value };

// SetPos sets absolute positioning with specified coordinates.
func (_gfcb *Paragraph )SetPos (x ,y float64 ){_gfcb ._becd =PositionAbsolute ;_gfcb ._bbdg =x ;_gfcb ._fagg =y ;};

// GetCoords returns coordinates of border.
func (_bad *border )GetCoords ()(float64 ,float64 ){return _bad ._dae ,_bad ._dgaf };

// NewPage adds a new Page to the Creator and sets as the active Page.
func (_ffd *Creator )NewPage ()*_afd .PdfPage {_fadb :=_ffd .newPage ();_ffd ._gef =append (_ffd ._gef ,_fadb );_ffd ._gbgd .Page ++;return _fadb ;};

// NewColumn returns a new column for the line items invoice table.
func (_ggebe *Invoice )NewColumn (description string )*InvoiceCell {return _ggebe .newColumn (description ,CellHorizontalAlignmentLeft );};

// ConvertToBinary converts current image data into binary (Bi-level image) format.
// If provided image is RGB or GrayScale the function converts it into binary image
// using histogram auto threshold method.
func (_gfcf *Image )ConvertToBinary ()error {return _gfcf ._cfaa .ConvertToBinary ()};

// VectorDrawable is a Drawable with a specified width and height.
type VectorDrawable interface{Drawable ;

// Width returns the width of the Drawable.
Width ()float64 ;

// Height returns the height of the Drawable.
Height ()float64 ;};

// Draw draws the drawable d on the block.
// Note that the drawable must not wrap, i.e. only return one block. Otherwise an error is returned.
func (_dd *Block )Draw (d Drawable )error {_cgg :=DrawContext {};_cgg .Width =_dd ._dag ;_cgg .Height =_dd ._gg ;_cgg .PageWidth =_dd ._dag ;_cgg .PageHeight =_dd ._gg ;_cgg .X =0;_cgg .Y =0;_dga ,_ ,_dca :=d .GeneratePageBlocks (_cgg );if _dca !=nil {return _dca ;
};if len (_dga )!=1{return _a .New ("\u0074\u006f\u006f\u0020ma\u006e\u0079\u0020\u006f\u0075\u0074\u0070\u0075\u0074\u0020\u0062\u006c\u006f\u0063k\u0073");};for _ ,_ecgb :=range _dga {if _ba :=_dd .mergeBlocks (_ecgb );_ba !=nil {return _ba ;};};return nil ;
};

// SetAngle sets the rotation angle in degrees.
func (_acg *Block )SetAngle (angleDeg float64 ){_acg ._fgb =angleDeg };

// Subtotal returns the invoice subtotal description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_dcec *Invoice )Subtotal ()(*InvoiceCell ,*InvoiceCell ){return _dcec ._cagd [0],_dcec ._cagd [1]};

// SetNoteStyle sets the style properties used to render the content of the
// invoice note sections.
func (_ddge *Invoice )SetNoteStyle (style TextStyle ){_ddge ._daff =style };

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_cedba *Paragraph )SetTextAlignment (align TextAlignment ){_cedba ._bdcc =align };

// GetMargins returns the margins of the TOC line: left, right, top, bottom.
func (_aaba *TOCLine )GetMargins ()(float64 ,float64 ,float64 ,float64 ){_bbbcg :=&_aaba ._dfec ._ggdg ;return _aaba ._gada ,_bbbcg .Right ,_bbbcg .Top ,_bbbcg .Bottom ;};

// NewCell returns a new invoice table cell.
func (_bfaeb *Invoice )NewCell (value string )*InvoiceCell {return _bfaeb .newCell (value ,_bfaeb .NewCellProps ());};

// FilledCurve represents a closed path of Bezier curves with a border and fill.
type FilledCurve struct{_cefb []_fd .CubicBezierCurve ;FillEnabled bool ;_cdcb Color ;BorderEnabled bool ;BorderWidth float64 ;_cdcd Color ;};

// CreateTableOfContents sets a function to generate table of contents.
func (_feca *Creator )CreateTableOfContents (genTOCFunc func (_fgda *TOC )error ){_feca ._cgf =genTOCFunc ;};

// SetFillOpacity sets the fill opacity.
func (_gecd *Polygon )SetFillOpacity (opacity float64 ){_gecd ._aceae =opacity };

// RotatedSize returns the width and height of the rotated block.
func (_abc *Block )RotatedSize ()(float64 ,float64 ){_ ,_ ,_fdg ,_gee :=_agdcd (_abc ._dag ,_abc ._gg ,_abc ._fgb );return _fdg ,_gee ;};

// NewSubchapter creates a new child chapter with the specified title.
func (_acf *Chapter )NewSubchapter (title string )*Chapter {_gaf :=_eced (_acf ._aff ._gbfc );_gaf .FontSize =14;_acf ._ecba ++;_ddef :=_bbb (_acf ,_acf ._dgaa ,_acf ._cee ,title ,_acf ._ecba ,_gaf );_acf .Add (_ddef );return _ddef ;};

// Lines returns all the rows of the invoice line items table.
func (_dedc *Invoice )Lines ()[][]*InvoiceCell {return _dedc ._geac };type border struct{_dae float64 ;_dgaf float64 ;_acea float64 ;_bcc float64 ;_gcd Color ;_cdd Color ;_eec float64 ;_fbc Color ;_deb float64 ;_dcbg Color ;_beb float64 ;_dcg Color ;_efa float64 ;
LineStyle _fd .LineStyle ;_ggce CellBorderStyle ;_bf CellBorderStyle ;_adgb CellBorderStyle ;_fdgef CellBorderStyle ;};

// SetIncludeInTOC sets a flag to indicate whether or not to include in tOC.
func (_fdgb *Chapter )SetIncludeInTOC (includeInTOC bool ){_fdgb ._abebg =includeInTOC };

// SetWidth set the Image's document width to specified w. This does not change the raw image data, i.e.
// no actual scaling of data is performed. That is handled by the PDF viewer.
func (_fgeb *Image )SetWidth (w float64 ){_fgeb ._fdbad =w };func (_ggf *Image )rotatedSize ()(float64 ,float64 ){_dgca :=_ggf ._fdbad ;_fcdg :=_ggf ._fcae ;_afbd :=_ggf ._aegda ;if _afbd ==0{return _dgca ,_fcdg ;};_abcb :=_fd .Path {Points :[]_fd .Point {_fd .NewPoint (0,0).Rotate (_afbd ),_fd .NewPoint (_dgca ,0).Rotate (_afbd ),_fd .NewPoint (0,_fcdg ).Rotate (_afbd ),_fd .NewPoint (_dgca ,_fcdg ).Rotate (_afbd )}}.GetBoundingBox ();
return _abcb .Width ,_abcb .Height ;};

// CellBorderSide defines the table cell's border side.
type CellBorderSide int ;

// SetDate sets the date of the invoice.
func (_fgaeb *Invoice )SetDate (date string )(*InvoiceCell ,*InvoiceCell ){_fgaeb ._aacb [1].Value =date ;return _fgaeb ._aacb [0],_fgaeb ._aacb [1];};

// Margins.  Can be page Margins, or Margins around an element.
type Margins struct{Left float64 ;Right float64 ;Top float64 ;Bottom float64 ;};func _gbec ()*Division {return &Division {_bdcb :[]VectorDrawable {}}};

// NewImageFromData creates an Image from image data.
func (_dcaga *Creator )NewImageFromData (data []byte )(*Image ,error ){return _gbcg (data )};

// SetContent sets the cell's content.  The content is a VectorDrawable, i.e. a Drawable with a known height and width.
// The currently supported VectorDrawable is: *Paragraph, *StyledParagraph.
func (_bbbae *TableCell )SetContent (vd VectorDrawable )error {switch _eggcf :=vd .(type ){case *Paragraph :if _eggcf ._beee {_eggcf ._fceb =true ;};_bbbae ._fcgd =vd ;case *StyledParagraph :if _eggcf ._edaa {_eggcf ._beab =true ;};_bbbae ._fcgd =vd ;case *Image :_bbbae ._fcgd =vd ;
case *Table :_bbbae ._fcgd =vd ;case *List :_bbbae ._fcgd =vd ;case *Division :_bbbae ._fcgd =vd ;default:_ff .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020\u0074\u0079p\u0065\u0020\u0025\u0054",vd );
return _c .ErrTypeError ;};return nil ;};

// SetAddressHeadingStyle sets the style properties used to render the
// heading of the invoice address sections.
func (_dfgg *Invoice )SetAddressHeadingStyle (style TextStyle ){_dfgg ._egfed =style };func (_cfbc *StyledParagraph )split (_cecce DrawContext )(_cabd ,_ebaf *StyledParagraph ,_bbde error ){if _bbde =_cfbc .wrapChunks (false );_bbde !=nil {return nil ,nil ,_bbde ;
};_gbecd :=func (_badg []*TextChunk ,_bfec []*TextChunk )[]*TextChunk {if len (_bfec )==0{return _badg ;};_fedb :=len (_badg );if _fedb ==0{return append (_badg ,_bfec ...);};_badg [_fedb -1].Text +=_bfec [0].Text ;return append (_badg ,_bfec [1:]...);
};_eccb :=func (_adbec *StyledParagraph ,_fcecd []*TextChunk )*StyledParagraph {if len (_fcecd )==0{return nil ;};_baede :=*_adbec ;_baede ._ggfd =_fcecd ;return &_baede ;};var (_ccgge float64 ;_effe []*TextChunk ;_aaea []*TextChunk ;);for _ ,_fddc :=range _cfbc ._faaf {var _beed float64 ;
_abdg :=make ([]*TextChunk ,0,len (_fddc ));for _ ,_cdge :=range _fddc {if _gfdc :=_cdge .Style .FontSize ;_gfdc > _beed {_beed =_gfdc ;};_abdg =append (_abdg ,_cdge .clone ());};_beed *=_cfbc ._baega ;if _cfbc ._cdcbf .IsRelative (){if _ccgge +_beed > _cecce .Height {_aaea =_gbecd (_aaea ,_abdg );
}else {_effe =_gbecd (_effe ,_abdg );};};_ccgge +=_beed ;};_cfbc ._faaf =nil ;if len (_aaea )==0{return _cfbc ,nil ,nil ;};return _eccb (_cfbc ,_effe ),_eccb (_cfbc ,_aaea ),nil ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_abgfc *Invoice )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_ddeea :=ctx ;_eeg :=[]func (_bcag DrawContext )([]*Block ,DrawContext ,error ){_abgfc .generateHeaderBlocks ,_abgfc .generateInformationBlocks ,_abgfc .generateLineBlocks ,_abgfc .generateTotalBlocks ,_abgfc .generateNoteBlocks };
var _acad []*Block ;for _ ,_fgaec :=range _eeg {_cgcd ,_edcd ,_eaad :=_fgaec (ctx );if _eaad !=nil {return _acad ,ctx ,_eaad ;};if len (_acad )==0{_acad =_cgcd ;}else if len (_cgcd )> 0{_acad [len (_acad )-1].mergeBlocks (_cgcd [0]);_acad =append (_acad ,_cgcd [1:]...);
};ctx =_edcd ;};if _abgfc ._cfac .IsRelative (){ctx .X =_ddeea .X ;};if _abgfc ._cfac .IsAbsolute (){return _acad ,_ddeea ,nil ;};return _acad ,ctx ,nil ;};

// SetBorderColor sets the border color for the path.
func (_cdedf *FilledCurve )SetBorderColor (color Color ){_cdedf ._cdcd =color };

// SetColumnWidths sets the fractional column widths.
// Each width should be in the range 0-1 and is a fraction of the table width.
// The number of width inputs must match number of columns, otherwise an error is returned.
func (_eedga *Table )SetColumnWidths (widths ...float64 )error {if len (widths )!=_eedga ._fceeb {_ff .Log .Debug ("M\u0069\u0073\u006d\u0061\u0074\u0063\u0068\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020o\u0066\u0020\u0077\u0069\u0064\u0074\u0068\u0073\u0020\u0061nd\u0020\u0063\u006fl\u0075m\u006e\u0073");
return _a .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_eedga ._eabc =widths ;return nil ;};

// Notes returns the notes section of the invoice as a title-content pair.
func (_bgedb *Invoice )Notes ()(string ,string ){return _bgedb ._dbdc [0],_bgedb ._dbdc [1]};

// SetColorRight sets border color for right.
func (_cdda *border )SetColorRight (col Color ){_cdda ._dcbg =col };

// Reset removes all the text chunks the paragraph contains.
func (_efd *StyledParagraph )Reset (){_efd ._ggfd =[]*TextChunk {}};

// TOC returns the table of contents component of the creator.
func (_efb *Creator )TOC ()*TOC {return _efb ._feg };

// Line defines a line between point 1 (X1,Y1) and point 2 (X2,Y2).  The line ending styles can be none (regular line),
// or arrows at either end.  The line also has a specified width, color and opacity.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Line struct{_bfge float64 ;_afbb float64 ;_eddf float64 ;_caee float64 ;_dbgda Color ;_bddd float64 ;};

// NewBlockFromPage creates a Block from a PDF Page.  Useful for loading template pages as blocks
// from a PDF document and additional content with the creator.
func NewBlockFromPage (page *_afd .PdfPage )(*Block ,error ){_gc :=&Block {};_fdf ,_ffc :=page .GetAllContentStreams ();if _ffc !=nil {return nil ,_ffc ;};_ae :=_da .NewContentStreamParser (_fdf );_ag ,_ffc :=_ae .Parse ();if _ffc !=nil {return nil ,_ffc ;
};_ag .WrapIfNeeded ();_gc ._de =_ag ;if page .Resources !=nil {_gc ._cf =page .Resources ;}else {_gc ._cf =_afd .NewPdfPageResources ();};_afg ,_ffc :=page .GetMediaBox ();if _ffc !=nil {return nil ,_ffc ;};if _afg .Llx !=0||_afg .Lly !=0{_gc .translate (-_afg .Llx ,_afg .Lly );
};_gc ._dag =_afg .Urx -_afg .Llx ;_gc ._gg =_afg .Ury -_afg .Lly ;if page .Rotate !=nil {_gc ._fgb =-float64 (*page .Rotate );};return _gc ,nil ;};

// SetStyleLeft sets border style for left side.
func (_fa *border )SetStyleLeft (style CellBorderStyle ){_fa ._ggce =style };

// MoveDown moves the drawing context down by relative displacement dy (negative goes up).
func (_ade *Creator )MoveDown (dy float64 ){_ade ._gbgd .Y +=dy };

// SetBuyerAddress sets the buyer address of the invoice.
func (_cbef *Invoice )SetBuyerAddress (address *InvoiceAddress ){_cbef ._cgad =address };

// GetCoords returns the coordinates of the Ellipse's center (xc,yc).
func (_gdg *Ellipse )GetCoords ()(float64 ,float64 ){return _gdg ._beag ,_gdg ._cgde };

// ScaleToWidth scale Image to a specified width w, maintaining the aspect ratio.
func (_fcef *Image )ScaleToWidth (w float64 ){_bbbg :=_fcef ._fcae /_fcef ._fdbad ;_fcef ._fdbad =w ;_fcef ._fcae =w *_bbbg ;};

// SetPageSize sets the Creator's page size.  Pages that are added after this will be created with
// this Page size.
// Does not affect pages already created.
//
// Common page sizes are defined as constants.
// Examples:
// 1. c.SetPageSize(creator.PageSizeA4)
// 2. c.SetPageSize(creator.PageSizeA3)
// 3. c.SetPageSize(creator.PageSizeLegal)
// 4. c.SetPageSize(creator.PageSizeLetter)
//
// For custom sizes: Use the PPMM (points per mm) and PPI (points per inch) when defining those based on
// physical page sizes:
//
// Examples:
// 1. 10x15 sq. mm: SetPageSize(PageSize{10*creator.PPMM, 15*creator.PPMM}) where PPMM is points per mm.
// 2. 3x2 sq. inches: SetPageSize(PageSize{3*creator.PPI, 2*creator.PPI}) where PPI is points per inch.
//
func (_fegg *Creator )SetPageSize (size PageSize ){_fegg ._dbb =size ;_fegg ._aeg =size [0];_fegg ._eadf =size [1];_ced :=0.1*_fegg ._aeg ;_fegg ._cce .Left =_ced ;_fegg ._cce .Right =_ced ;_fegg ._cce .Top =_ced ;_fegg ._cce .Bottom =_ced ;};

// AddSubtable copies the cells of the subtable in the table, starting with the
// specified position. The table row and column indices are 1-based, which
// makes the position of the first cell of the first row of the table 1,1.
// The table is automatically extended if the subtable exceeds its columns.
// This can happen when the subtable has more columns than the table or when
// one or more columns of the subtable starting from the specified position
// exceed the last column of the table.
func (_dbebf *Table )AddSubtable (row ,col int ,subtable *Table ){for _ ,_acbc :=range subtable ._efgd {_gbce :=&TableCell {};*_gbce =*_acbc ;_gbce ._ffdff =_dbebf ;_gbce ._ccegd +=col -1;if _fbbc :=_dbebf ._fceeb -(_gbce ._ccegd -1);_fbbc < _gbce ._agdd {_dbebf ._fceeb +=_gbce ._agdd -_fbbc ;
_dbebf .resetColumnWidths ();_ff .Log .Debug ("\u0054a\u0062l\u0065\u003a\u0020\u0073\u0075\u0062\u0074\u0061\u0062\u006c\u0065 \u0065\u0078\u0063\u0065e\u0064\u0073\u0020\u0064\u0065s\u0074\u0069\u006e\u0061\u0074\u0069\u006f\u006e\u0020\u0074\u0061\u0062\u006c\u0065\u002e\u0020\u0045\u0078\u0070\u0061\u006e\u0064\u0069\u006e\u0067\u0020\u0074\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0025\u0064\u0020\u0063\u006fl\u0075\u006d\u006e\u0073\u002e",_dbebf ._fceeb );
};_gbce ._dfda +=row -1;_fade :=subtable ._aedeb [_acbc ._dfda -1];if _gbce ._dfda > _dbebf ._bace {for _gbce ._dfda > _dbebf ._bace {_dbebf ._bace ++;_dbebf ._aedeb =append (_dbebf ._aedeb ,_dbebf ._bbee );};_dbebf ._aedeb [_gbce ._dfda -1]=_fade ;}else {_dbebf ._aedeb [_gbce ._dfda -1]=_aa .Max (_dbebf ._aedeb [_gbce ._dfda -1],_fade );
};_dbebf ._efgd =append (_dbebf ._efgd ,_gbce );};_g .Slice (_dbebf ._efgd ,func (_bdbe ,_gagf int )bool {_ceb :=_dbebf ._efgd [_bdbe ]._dfda ;_bbdd :=_dbebf ._efgd [_gagf ]._dfda ;if _ceb < _bbdd {return true ;};if _ceb > _bbdd {return false ;};return _dbebf ._efgd [_bdbe ]._ccegd < _dbebf ._efgd [_gagf ]._ccegd ;
});};

// Text sets the text content of the Paragraph.
func (_gffb *Paragraph )Text ()string {return _gffb ._ddcg };

// TableCell defines a table cell which can contain a Drawable as content.
type TableCell struct{_dffg Color ;_becdfa _fd .LineStyle ;_gcce CellBorderStyle ;_ggef Color ;_dggfd float64 ;_efda CellBorderStyle ;_fdcc Color ;_edg float64 ;_abgee CellBorderStyle ;_bfca Color ;_debe float64 ;_ecgcf CellBorderStyle ;_aeae Color ;_edcbb float64 ;
_dfda ,_ccegd int ;_fdab int ;_agdd int ;_fcgd VectorDrawable ;_gaef CellHorizontalAlignment ;_bbag CellVerticalAlignment ;_dcgf float64 ;_ffdff *Table ;};

// NewCellProps returns the default properties of an invoice cell.
func (_adgde *Invoice )NewCellProps ()InvoiceCellProps {_fcba :=ColorRGBFrom8bit (255,255,255);return InvoiceCellProps {TextStyle :_adgde ._ccfe ,Alignment :CellHorizontalAlignmentLeft ,BackgroundColor :_fcba ,BorderColor :_fcba ,BorderWidth :1,BorderSides :[]CellBorderSide {CellBorderSideAll }};
};

// CellBorderStyle defines the table cell's border style.
type CellBorderStyle int ;

// AddInternalLink adds a new internal link to the paragraph.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
// The zoom of the destination page is controlled with the zoom
// parameter. Pass in 0 to keep the current zoom value.
func (_cbfb *StyledParagraph )AddInternalLink (text string ,page int64 ,x ,y ,zoom float64 )*TextChunk {_eecdb :=NewTextChunk (text ,_cbfb ._eggec );_eecdb ._fbdcc =_cdegg (page -1,x ,y ,zoom );return _cbfb .appendChunk (_eecdb );};

// MoveX moves the drawing context to absolute position x.
func (_gfea *Creator )MoveX (x float64 ){_gfea ._gbgd .X =x };

// SetOpacity sets opacity for Image.
func (_aeddd *Image )SetOpacity (opacity float64 ){_aeddd ._bfdfe =opacity };

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_fbdb *List )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var _afaa float64 ;var _ffabd []*StyledParagraph ;for _ ,_gcee :=range _fbdb ._bage {_aedb :=_addb (_fbdb ._egdee );_aedb .SetEnableWrap (false );_aedb .SetTextAlignment (TextAlignmentRight );
_aedb .Append (_gcee ._ecdef .Text ).Style =_gcee ._ecdef .Style ;_dbe :=_aedb .getTextWidth ()/1000.0/ctx .Width ;if _afaa < _dbe {_afaa =_dbe ;};_ffabd =append (_ffabd ,_aedb );};_cdbg :=_gggcg (2);_cdbg .SetColumnWidths (_afaa ,1-_afaa );_cdbg .SetMargins (_fbdb ._fgcge ,0,0,0);
for _gdadf ,_ggeg :=range _fbdb ._bage {_befeb :=_cdbg .NewCell ();_befeb .SetIndent (0);_befeb .SetContent (_ffabd [_gdadf ]);_befeb =_cdbg .NewCell ();_befeb .SetIndent (0);_befeb .SetContent (_ggeg ._cffg );};return _cdbg .GeneratePageBlocks (ctx );
};

// SetBorderColor sets border color.
func (_gagd *Rectangle )SetBorderColor (col Color ){_gagd ._adgba =col };

// SetMargins sets the Paragraph's margins.
func (_eafa *Paragraph )SetMargins (left ,right ,top ,bottom float64 ){_eafa ._fegc .Left =left ;_eafa ._fegc .Right =right ;_eafa ._fegc .Top =top ;_eafa ._fegc .Bottom =bottom ;};

// SetFillOpacity sets the fill opacity.
func (_aadb *Rectangle )SetFillOpacity (opacity float64 ){_aadb ._cbcd =opacity };

// Height returns the height of the Paragraph. The height is calculated based on the input text and how it is wrapped
// within the container. Does not include Margins.
func (_ccfeb *StyledParagraph )Height ()float64 {_ccfeb .wrapText ();var _gaae float64 ;for _ ,_baegg :=range _ccfeb ._faaf {var _aggd float64 ;for _ ,_gffc :=range _baegg {_eebb :=_ccfeb ._baega *_gffc .Style .FontSize ;if _eebb > _aggd {_aggd =_eebb ;
};};_gaae +=_aggd ;};return _gaae ;};

// ColorRGBFrom8bit creates a Color from 8-bit (0-255) r,g,b values.
// Example:
//   red := ColorRGBFrom8Bit(255, 0, 0)
func ColorRGBFrom8bit (r ,g ,b byte )Color {return rgbColor {_faca :float64 (r )/255.0,_bec :float64 (g )/255.0,_abca :float64 (b )/255.0};};

// NewParagraph creates a new text paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_gaca *Creator )NewParagraph (text string )*Paragraph {return _gecb (text ,_gaca .NewTextStyle ())};

// SetHorizontalAlignment sets the horizontal alignment of the image.
func (_cfb *Image )SetHorizontalAlignment (alignment HorizontalAlignment ){_cfb ._ebag =alignment };

// CellVerticalAlignment defines the table cell's vertical alignment.
type CellVerticalAlignment int ;func _abed (_bbeb *_f .File )([]*_afd .PdfPage ,error ){_ecea ,_cbbdd :=_afd .NewPdfReader (_bbeb );if _cbbdd !=nil {return nil ,_cbbdd ;};_cfba ,_cbbdd :=_ecea .GetNumPages ();if _cbbdd !=nil {return nil ,_cbbdd ;};var _adcg []*_afd .PdfPage ;
for _adcdg :=0;_adcdg < _cfba ;_adcdg ++{_gbdg ,_bagg :=_ecea .GetPage (_adcdg +1);if _bagg !=nil {return nil ,_bagg ;};_adcg =append (_adcg ,_gbdg );};return _adcg ,nil ;};

// TOCLine represents a line in a table of contents.
// The component can be used both in the context of a
// table of contents component and as a standalone component.
// The representation of a table of contents line is as follows:
//       [number] [title]      [separator] [page]
// e.g.: Chapter1 Introduction ........... 1
type TOCLine struct{_dfec *StyledParagraph ;

// Holds the text and style of the number part of the TOC line.
Number TextChunk ;

// Holds the text and style of the title part of the TOC line.
Title TextChunk ;

// Holds the text and style of the separator part of the TOC line.
Separator TextChunk ;

// Holds the text and style of the page part of the TOC line.
Page TextChunk ;_gada float64 ;_dbgca uint ;_gdfd float64 ;_fecg Positioning ;_afaee float64 ;_ecdg float64 ;_eeddeg int64 ;};

// AddLine adds a new line with the provided style to the table of contents.
func (_fggd *TOC )AddLine (line *TOCLine )*TOCLine {if line ==nil {return nil ;};_fggd ._bgeda =append (_fggd ._bgeda ,line );return line ;};

// Color interface represents colors in the PDF creator.
type Color interface{ToRGB ()(float64 ,float64 ,float64 );};

// Table allows organizing content in an rows X columns matrix, which can spawn across multiple pages.
type Table struct{_bace int ;_fceeb int ;_bgeb int ;_eabc []float64 ;_aedeb []float64 ;_bbee float64 ;_efgd []*TableCell ;_eadc Positioning ;_cgcbe ,_cggg float64 ;_badde Margins ;_ebf bool ;_bead int ;_fcefe int ;_fefe bool ;};func _eced (_dfba *_afd .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,0),Font :_dfba ,FontSize :10,OutlineSize :1,UnderlineStyle :TextDecorationLineStyle {Offset :1,Thickness :1}};
};

// SetLineLevelOffset sets the amount of space an indentation level occupies
// for all new lines of the table of contents.
func (_bcdd *TOC )SetLineLevelOffset (levelOffset float64 ){_bcdd ._acbcb =levelOffset };

// Marker returns the marker used for the list items.
// The marker instance can be used the change the text and the style
// of newly added list items.
func (_ecgd *List )Marker ()*TextChunk {return &_ecgd ._faac };

// HeaderFunctionArgs holds the input arguments to a header drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type HeaderFunctionArgs struct{PageNum int ;TotalPages int ;};func (_fbf *Chapter )headingNumber ()string {var _aae string ;if _fbf ._bcce {if _fbf ._dadd !=0{_aae =_e .Itoa (_fbf ._dadd )+"\u002e";};if _fbf ._cgd !=nil {_dgab :=_fbf ._cgd .headingNumber ();
if _dgab !=""{_aae =_dgab +_aae ;};};};return _aae ;};

// SetMaxLines sets the maximum number of lines before the paragraph
// text is truncated.
func (_aedc *Paragraph )SetMaxLines (maxLines int ){_aedc ._begg =maxLines ;_aedc .wrapText ()};

// SetShowLinks sets visibility of links for the TOC lines.
func (_aada *TOC )SetShowLinks (showLinks bool ){_aada ._gega =showLinks };func (_ffag *Invoice )generateNoteBlocks (_bdca DrawContext )([]*Block ,DrawContext ,error ){_cdce :=_gbec ();_fdfbc :=append ([][2]string {_ffag ._dbdc ,_ffag ._ccf },_ffag ._dcf ...);
for _ ,_ddee :=range _fdfbc {if _ddee [1]!=""{_bgcg :=_ffag .drawSection (_ddee [0],_ddee [1]);for _ ,_dgad :=range _bgcg {_cdce .Add (_dgad );};_abdc :=_addb (_ffag ._ccfe );_abdc .SetMargins (0,0,10,0);_cdce .Add (_abdc );};};return _cdce .GeneratePageBlocks (_bdca );
};

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_dgfgdg *StyledParagraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _dgfgdg ._ggdg .Left ,_dgfgdg ._ggdg .Right ,_dgfgdg ._ggdg .Top ,_dgfgdg ._ggdg .Bottom ;};

// MoveTo moves the drawing context to absolute coordinates (x, y).
func (_bfd *Creator )MoveTo (x ,y float64 ){_bfd ._gbgd .X =x ;_bfd ._gbgd .Y =y };func _aedef (_bbgg *_afd .PdfAnnotation )*_afd .PdfAnnotation {if _bbgg ==nil {return nil ;};var _ggbaf *_afd .PdfAnnotation ;switch _fbdbe :=_bbgg .GetContext ().(type ){case *_afd .PdfAnnotationLink :if _fcgee :=_ebde (_fbdbe );
_fcgee !=nil {_ggbaf =_fcgee .PdfAnnotation ;};};return _ggbaf ;};

// TextRenderingMode determines whether showing text shall cause glyph
// outlines to be stroked, filled, used as a clipping boundary, or some
// combination of the three.
// See section 9.3 "Text State Parameters and Operators" and
// Table 106 (pp. 254-255 PDF32000_2008).
type TextRenderingMode int ;

// SetIndent sets the left offset of the list when nested into another list.
func (_abgb *List )SetIndent (indent float64 ){_abgb ._fgcge =indent ;_abgb ._agg =false };

// Add adds a new line with the default style to the table of contents.
func (_bbad *TOC )Add (number ,title ,page string ,level uint )*TOCLine {_edga :=_bbad .AddLine (_ebbc (TextChunk {Text :number ,Style :_bbad ._bcbdg },TextChunk {Text :title ,Style :_bbad ._fcdb },TextChunk {Text :page ,Style :_bbad ._adef },level ,_bbad ._bbgb ));
if _edga ==nil {return nil ;};_dbgg :=&_bbad ._ffcd ;_edga .SetMargins (_dbgg .Left ,_dbgg .Right ,_dbgg .Top ,_dbgg .Bottom );_edga .SetLevelOffset (_bbad ._acbcb );_edga .Separator .Text =_bbad ._fcbf ;_edga .Separator .Style =_bbad ._bddde ;return _edga ;
};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_fbge *TOCLine )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bbacf :=ctx ;_fccb ,ctx ,_fefc :=_fbge ._dfec .GeneratePageBlocks (ctx );if _fefc !=nil {return _fccb ,ctx ,_fefc ;};if _fbge ._fecg .IsRelative (){ctx .X =_bbacf .X ;
};if _fbge ._fecg .IsAbsolute (){return _fccb ,_bbacf ,nil ;};return _fccb ,ctx ,nil ;};

// SetColumns overwrites any columns in the line items table. This should be
// called before AddLine.
func (_gbgaf *Invoice )SetColumns (cols []*InvoiceCell ){_gbgaf ._ccec =cols };

// SetPos sets the Block's positioning to absolute mode with the specified coordinates.
func (_edf *Block )SetPos (x ,y float64 ){_edf ._cd =PositionAbsolute ;_edf ._cg =x ;_edf ._fc =y };

// ColorRGBFromHex converts color hex code to rgb color for using with creator.
// NOTE: If there is a problem interpreting the string, then will use black color and log a debug message.
// Example hex code: #ffffff -> (1,1,1) white.
func ColorRGBFromHex (hexStr string )Color {_gcec :=rgbColor {};if (len (hexStr )!=4&&len (hexStr )!=7)||hexStr [0]!='#'{_ff .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _gcec ;
};var _bdcf ,_gece ,_gag int ;if len (hexStr )==4{var _gcf ,_bdg ,_ffbb int ;_befc ,_gegd :=_ec .Sscanf (hexStr ,"\u0023\u0025\u0031\u0078\u0025\u0031\u0078\u0025\u0031\u0078",&_gcf ,&_bdg ,&_ffbb );if _gegd !=nil {_ff .Log .Debug ("\u0049\u006e\u0076a\u006c\u0069\u0064\u0020h\u0065\u0078\u0020\u0063\u006f\u0064\u0065:\u0020\u0025\u0073\u002c\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076",hexStr ,_gegd );
return _gcec ;};if _befc !=3{_ff .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _gcec ;};_bdcf =_gcf *16+_gcf ;_gece =_bdg *16+_bdg ;_gag =_ffbb *16+_ffbb ;}else {_ddf ,_ggbf :=_ec .Sscanf (hexStr ,"\u0023\u0025\u0032\u0078\u0025\u0032\u0078\u0025\u0032\u0078",&_bdcf ,&_gece ,&_gag );
if _ggbf !=nil {_ff .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _gcec ;};if _ddf !=3{_ff .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0063\u006f\u0064\u0065\u003a\u0020\u0025\u0073,\u0020\u006e\u0020\u0021\u003d\u0020\u0033 \u0028\u0025\u0064\u0029",hexStr ,_ddf );
return _gcec ;};};_eba :=float64 (_bdcf )/255.0;_gdec :=float64 (_gece )/255.0;_cea :=float64 (_gag )/255.0;_gcec ._faca =_eba ;_gcec ._bec =_gdec ;_gcec ._abca =_cea ;return _gcec ;};

// SetAddressStyle sets the style properties used to render the content of
// the invoice address sections.
func (_beca *Invoice )SetAddressStyle (style TextStyle ){_beca ._cedb =style };func (_fba *Paragraph )wrapText ()error {if !_fba ._fceb ||int (_fba ._efbd )<=0{_fba ._eedde =[]string {_fba ._ddcg };return nil ;};_abge :=NewTextChunk (_fba ._ddcg ,TextStyle {Font :_fba ._gbfc ,FontSize :_fba ._afec });
_cdea ,_cdf :=_abge .Wrap (_fba ._efbd );if _cdf !=nil {return _cdf ;};if _fba ._begg > 0&&len (_cdea )> _fba ._begg {_cdea =_cdea [:_fba ._begg ];};_fba ._eedde =_cdea ;return nil ;};

// SellerAddress returns the seller address used in the invoice template.
func (_cagb *Invoice )SellerAddress ()*InvoiceAddress {return _cagb ._dbab };

// SetFillColor sets the fill color.
func (_adcd *Rectangle )SetFillColor (col Color ){_adcd ._fgagc =col };func (_ggdeg *Creator )initContext (){_ggdeg ._gbgd .X =_ggdeg ._cce .Left ;_ggdeg ._gbgd .Y =_ggdeg ._cce .Top ;_ggdeg ._gbgd .Width =_ggdeg ._aeg -_ggdeg ._cce .Right -_ggdeg ._cce .Left ;
_ggdeg ._gbgd .Height =_ggdeg ._eadf -_ggdeg ._cce .Bottom -_ggdeg ._cce .Top ;_ggdeg ._gbgd .PageHeight =_ggdeg ._eadf ;_ggdeg ._gbgd .PageWidth =_ggdeg ._aeg ;_ggdeg ._gbgd .Margins =_ggdeg ._cce ;};const (CellVerticalAlignmentTop CellVerticalAlignment =iota ;
CellVerticalAlignmentMiddle ;CellVerticalAlignmentBottom ;);func _gggcg (_ccgf int )*Table {_gfgg :=&Table {_fceeb :_ccgf ,_bbee :10.0,_eabc :[]float64 {},_aedeb :[]float64 {},_efgd :[]*TableCell {}};_gfgg .resetColumnWidths ();return _gfgg ;};

// Margins returns the margins of the list: left, right, top, bottom.
func (_becb *List )Margins ()(float64 ,float64 ,float64 ,float64 ){return _becb ._bded .Left ,_becb ._bded .Right ,_becb ._bded .Top ,_becb ._bded .Bottom ;};

// NewPolyBezierCurve creates a new composite Bezier (polybezier) curve.
func (_fadad *Creator )NewPolyBezierCurve (curves []_fd .CubicBezierCurve )*PolyBezierCurve {return _deeac (curves );};

// Height returns the height of the list.
func (_ddfe *List )Height ()float64 {var _bdgb float64 ;for _ ,_ggdb :=range _ddfe ._bage {_bdgb +=_ggdb ._cffg .Height ();};return _bdgb ;};func _dfef (_ddeb *Block ,_gfbg *Paragraph ,_dgb DrawContext )(DrawContext ,error ){_deda :=1;_eaee :=_c .PdfObjectName ("\u0046\u006f\u006e\u0074"+_e .Itoa (_deda ));
for _ddeb ._cf .HasFontByName (_eaee ){_deda ++;_eaee =_c .PdfObjectName ("\u0046\u006f\u006e\u0074"+_e .Itoa (_deda ));};_bfdb :=_ddeb ._cf .SetFontByName (_eaee ,_gfbg ._gbfc .ToPdfObject ());if _bfdb !=nil {return _dgb ,_bfdb ;};_gfbg .wrapText ();_afbf :=_da .NewContentCreator ();
_afbf .Add_q ();_efce :=_dgb .PageHeight -_dgb .Y -_gfbg ._afec *_gfbg ._ffdf ;_afbf .Translate (_dgb .X ,_efce );if _gfbg ._bcad !=0{_afbf .RotateDeg (_gfbg ._bcad );};_afbf .Add_BT ().SetNonStrokingColor (_bff (_gfbg ._eedd )).Add_Tf (_eaee ,_gfbg ._afec ).Add_TL (_gfbg ._afec *_gfbg ._ffdf );
for _cdba ,_gbfec :=range _gfbg ._eedde {if _cdba !=0{_afbf .Add_Tstar ();};_agcb :=[]rune (_gbfec );_fcfe :=0.0;_dgef :=0;for _bbac ,_baedg :=range _agcb {if _baedg ==' '{_dgef ++;continue ;};if _baedg =='\u000A'{continue ;};_gfcg ,_gddc :=_gfbg ._gbfc .GetRuneMetrics (_baedg );
if !_gddc {_ff .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006e\u0065\u0020\u0069=\u0025\u0064\u0020\u0072\u0075\u006e\u0065=\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0069n\u0020\u0066\u006f\u006e\u0074\u0020\u0025\u0073\u0020\u0025\u0073",_bbac ,_baedg ,_baedg ,_gfbg ._gbfc .BaseFont (),_gfbg ._gbfc .Subtype ());
return _dgb ,_a .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");};_fcfe +=_gfbg ._afec *_gfcg .Wx ;};var _agdc []_c .PdfObject ;_abcgg ,_dggf :=_gfbg ._gbfc .GetRuneMetrics (' ');
if !_dggf {return _dgb ,_a .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};_cegb :=_abcgg .Wx ;switch _gfbg ._bdcc {case TextAlignmentJustify :if _dgef > 0&&_cdba < len (_gfbg ._eedde )-1{_cegb =(_gfbg ._efbd *1000.0-_fcfe )/float64 (_dgef )/_gfbg ._afec ;
};case TextAlignmentCenter :_baab :=_fcfe +float64 (_dgef )*_cegb *_gfbg ._afec ;_cdeaf :=(_gfbg ._efbd *1000.0-_baab )/2/_gfbg ._afec ;_agdc =append (_agdc ,_c .MakeFloat (-_cdeaf ));case TextAlignmentRight :_aaga :=_fcfe +float64 (_dgef )*_cegb *_gfbg ._afec ;
_gefa :=(_gfbg ._efbd *1000.0-_aaga )/_gfbg ._afec ;_agdc =append (_agdc ,_c .MakeFloat (-_gefa ));};_dbfee :=_gfbg ._gbfc .Encoder ();var _gdfeb []byte ;for _ ,_ffae :=range _agcb {if _ffae =='\u000A'{continue ;};if _ffae ==' '{if len (_gdfeb )> 0{_agdc =append (_agdc ,_c .MakeStringFromBytes (_gdfeb ));
_gdfeb =nil ;};_agdc =append (_agdc ,_c .MakeFloat (-_cegb ));}else {if _ ,_fceed :=_dbfee .RuneToCharcode (_ffae );!_fceed {_ff .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_ffae ,_ffae );
continue ;};_gdfeb =append (_gdfeb ,_dbfee .Encode (string (_ffae ))...);};};if len (_gdfeb )> 0{_agdc =append (_agdc ,_c .MakeStringFromBytes (_gdfeb ));};_afbf .Add_TJ (_agdc ...);};_afbf .Add_ET ();_afbf .Add_Q ();_dcbf :=_afbf .Operations ();_dcbf .WrapIfNeeded ();
_ddeb .addContents (_dcbf );if _gfbg ._becd .IsRelative (){_faef :=_gfbg .Height ()+_gfbg ._fegc .Bottom ;_dgb .Y +=_faef ;_dgb .Height -=_faef ;if _dgb .Inline {_dgb .X +=_gfbg .Width ()+_gfbg ._fegc .Right ;};};return _dgb ,nil ;};

// Indent returns the left offset of the list when nested into another list.
func (_bdbf *List )Indent ()float64 {return _bdbf ._fgcge };

// GeneratePageBlocks generates a page break block.
func (_defdc *PageBreak )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fdaa :=[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y ),NewBlock (ctx .PageWidth ,ctx .PageHeight )};ctx .Page ++;_dfff :=ctx ;_dfff .Y =ctx .Margins .Top ;
_dfff .X =ctx .Margins .Left ;_dfff .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom ;_dfff .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right ;ctx =_dfff ;return _fdaa ,ctx ,nil ;};

// SetAngle sets the rotation angle of the text.
func (_gae *Paragraph )SetAngle (angle float64 ){_gae ._bcad =angle };

// SetFillColor sets the fill color for the path.
func (_ggdac *FilledCurve )SetFillColor (color Color ){_ggdac ._cdcb =color };func _cdegg (_gdee int64 ,_ffee ,_fbde ,_fdeb float64 )*_afd .PdfAnnotation {_ddfg :=_afd .NewPdfAnnotationLink ();_fbdg :=_afd .NewBorderStyle ();_fbdg .SetBorderWidth (0);_ddfg .BS =_fbdg .ToPdfObject ();
if _gdee < 0{_gdee =0;};_ddfg .Dest =_c .MakeArray (_c .MakeInteger (_gdee ),_c .MakeName ("\u0058\u0059\u005a"),_c .MakeFloat (_ffee ),_c .MakeFloat (_fbde ),_c .MakeFloat (_fdeb ));return _ddfg .PdfAnnotation ;};

// AppendColumn appends a column to the line items table.
func (_gage *Invoice )AppendColumn (description string )*InvoiceCell {_agad :=_gage .NewColumn (description );_gage ._ccec =append (_gage ._ccec ,_agad );return _agad ;};func (_facf *StyledParagraph )wrapChunks (_baeda bool )error {if !_facf ._beab ||int (_facf ._cdcee )<=0{_facf ._faaf =[][]*TextChunk {_facf ._ggfd };
return nil ;};_facf ._faaf =[][]*TextChunk {};var _cfdb []*TextChunk ;var _cegd float64 ;_dfc :=_dg .IsSpace ;if !_baeda {_dfc =func (rune )bool {return false };};for _ ,_fabc :=range _facf ._ggfd {_gfbgd :=_fabc .Style ;_cbdec :=_fabc ._fbdcc ;var (_gafee []rune ;
_efbeg []float64 ;);for _ ,_bfgf :=range _fabc .Text {if _bfgf =='\u000A'{if !_baeda {_gafee =append (_gafee ,_bfgf );};_cfdb =append (_cfdb ,&TextChunk {Text :_fg .TrimRightFunc (string (_gafee ),_dfc ),Style :_gfbgd ,_fbdcc :_aedef (_cbdec )});_facf ._faaf =append (_facf ._faaf ,_cfdb );
_cfdb =nil ;_cegd =0;_gafee =nil ;_efbeg =nil ;continue ;};_eccd :=_bfgf ==' ';_fgee ,_bgfa :=_gfbgd .Font .GetRuneMetrics (_bfgf );if !_bgfa {_ff .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_bfgf );
return _a .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");};_ccge :=_gfbgd .FontSize *_fgee .Wx ;_ddbg :=_ccge ;if !_eccd {_ddbg =_ccge +_gfbgd .CharSpacing *1000.0;
};if _cegd +_ccge > _facf ._cdcee *1000.0{_beea :=-1;if !_eccd {for _cbbfc :=len (_gafee )-1;_cbbfc >=0;_cbbfc --{if _gafee [_cbbfc ]==' '{_beea =_cbbfc ;break ;};};};_becbc :=string (_gafee );if _beea >=0{_becbc =string (_gafee [0:_beea +1]);_gafee =_gafee [_beea +1:];
_gafee =append (_gafee ,_bfgf );_efbeg =_efbeg [_beea +1:];_efbeg =append (_efbeg ,_ddbg );_cegd =0;for _ ,_ffaa :=range _efbeg {_cegd +=_ffaa ;};}else {if _eccd {_cegd =0;_gafee =[]rune {};_efbeg =[]float64 {};}else {_cegd =_ddbg ;_gafee =[]rune {_bfgf };
_efbeg =[]float64 {_ddbg };};};if !_baeda &&_eccd {_becbc +="\u0020";};_cfdb =append (_cfdb ,&TextChunk {Text :_fg .TrimRightFunc (_becbc ,_dfc ),Style :_gfbgd ,_fbdcc :_aedef (_cbdec )});_facf ._faaf =append (_facf ._faaf ,_cfdb );_cfdb =[]*TextChunk {};
}else {_cegd +=_ddbg ;_gafee =append (_gafee ,_bfgf );_efbeg =append (_efbeg ,_ddbg );};};if len (_gafee )> 0{_cfdb =append (_cfdb ,&TextChunk {Text :string (_gafee ),Style :_gfbgd ,_fbdcc :_aedef (_cbdec )});};};if len (_cfdb )> 0{_facf ._faaf =append (_facf ._faaf ,_cfdb );
};return nil ;};

// Invoice represents a configurable invoice template.
type Invoice struct{_cdec string ;_aded *Image ;_cgad *InvoiceAddress ;_dbab *InvoiceAddress ;_cbgc string ;_fdbg [2]*InvoiceCell ;_aacb [2]*InvoiceCell ;_cbad [2]*InvoiceCell ;_bcafe [][2]*InvoiceCell ;_ccec []*InvoiceCell ;_geac [][]*InvoiceCell ;_cagd [2]*InvoiceCell ;
_abd [2]*InvoiceCell ;_gdff [][2]*InvoiceCell ;_dbdc [2]string ;_ccf [2]string ;_dcf [][2]string ;_ccfe TextStyle ;_aag TextStyle ;_gdd TextStyle ;_cedb TextStyle ;_egfed TextStyle ;_daff TextStyle ;_ggdd TextStyle ;_cbag InvoiceCellProps ;_ffad InvoiceCellProps ;
_fgef InvoiceCellProps ;_gbcd InvoiceCellProps ;_cfac Positioning ;};

// ColorCMYKFrom8bit creates a Color from c,m,y,k values (0-100).
// Example:
//   red := ColorCMYKFrom8Bit(0, 100, 100, 0)
func ColorCMYKFrom8bit (c ,m ,y ,k byte )Color {return cmykColor {_fdgea :_aa .Min (float64 (c ),100)/100.0,_gebe :_aa .Min (float64 (m ),100)/100.0,_ggb :_aa .Min (float64 (y ),100)/100.0,_dagd :_aa .Min (float64 (k ),100)/100.0};};

// TextAlignment options for paragraph.
type TextAlignment int ;

// GeneratePageBlocks draws the block contents on a template Page block.
// Implements the Drawable interface.
func (_ed *Block )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_ge :=_da .NewContentCreator ();_df ,_ede :=_ed .Width (),_ed .Height ();if _ed ._cd .IsRelative (){_ge .Translate (ctx .X ,ctx .PageHeight -ctx .Y -_ede );}else {_ge .Translate (_ed ._cg ,ctx .PageHeight -_ed ._fc -_ede );
};_bb :=_ede ;if _ed ._fgb !=0{_ge .Translate (_df /2,_ede /2);_ge .RotateDeg (_ed ._fgb );_ge .Translate (-_df /2,-_ede /2);_ ,_bb =_ed .RotatedSize ();};if _ed ._cd .IsRelative (){ctx .Y +=_bb ;};_ggc :=_ed .duplicate ();_gd :=append (*_ge .Operations (),*_ggc ._de ...);
_gd .WrapIfNeeded ();_ggc ._de =&_gd ;return []*Block {_ggc },ctx ,nil ;};

// PageSize represents the page size as a 2 element array representing the width and height in PDF document units (points).
type PageSize [2]float64 ;

// InsertColumn inserts a column in the line items table at the specified index.
func (_ebg *Invoice )InsertColumn (index uint ,description string )*InvoiceCell {_afad :=uint (len (_ebg ._ccec ));if index > _afad {index =_afad ;};_dffd :=_ebg .NewColumn (description );_ebg ._ccec =append (_ebg ._ccec [:index ],append ([]*InvoiceCell {_dffd },_ebg ._ccec [index :]...)...);
return _dffd ;};func (_fgeg *StyledParagraph )getLineHeight (_cfcf int )(_dgae ,_bafeg float64 ){if _fgeg ._faaf ==nil ||len (_fgeg ._faaf )==0{_fgeg .wrapText ();};if _cfcf < 0||_cfcf > len (_fgeg ._faaf )-1{_ff .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020p\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u0020\u006c\u0069\u006e\u0065 \u0069\u006e\u0064\u0065\u0078\u0020\u0025\u0064\u002e\u0020\u0052\u0065tu\u0072\u006e\u0069\u006e\u0067\u0020\u0030\u002c\u0020\u0030",_cfcf );
return 0,0;};_ecaa :=_fgeg ._faaf [_cfcf ];for _ ,_aadg :=range _ecaa {_acbd ,_acdb :=_aadg .Style .Font .GetFontDescriptor ();if _acdb !=nil {_ff .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020U\u006e\u0061\u0062\u006ce t\u006f g\u0065\u0074\u0020\u0066\u006f\u006e\u0074 d\u0065\u0073\u0063\u0072\u0069\u0070\u0074o\u0072");
};var _eccf float64 ;if _acbd !=nil {if _eccf ,_acdb =_acbd .GetCapHeight ();_acdb !=nil {_ff .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0067\u0065\u0074 \u0066\u006f\u006e\u0074\u0020\u0043\u0061\u0070\u0048\u0065\u0069\u0067\u0068t\u003a\u0020\u0025\u0076",_acdb );
};};if int (_eccf )<=0{_ff .Log .Debug ("W\u0041\u0052\u004e\u003a\u0020\u0043\u0061\u0070\u0048e\u0069\u0067\u0068\u0074\u0020\u006e\u006ft \u0061\u0076\u0061\u0069l\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0073\u0065tt\u0069\u006eg\u0020\u0074\u006f\u0020\u0031\u0030\u0030\u0030");
_eccf =1000;};_edcg :=_eccf /1000.0*_aadg .Style .FontSize *_fgeg ._baega ;if _edcg > _dgae {_dgae =_edcg ;};_edcg =_fgeg ._baega *_aadg .Style .FontSize ;if _edcg > _bafeg {_bafeg =_edcg ;};};return _dgae ,_bafeg ;};

// SetBorderColor sets the border color.
func (_cfagb *Polygon )SetBorderColor (color Color ){_cfagb ._aaff .BorderColor =_bff (color )};

// SetLineHeight sets the line height (1.0 default).
func (_fbbd *Paragraph )SetLineHeight (lineheight float64 ){_fbbd ._ffdf =lineheight };

// CurvePolygon represents a curve polygon shape.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type CurvePolygon struct{_aeed *_fd .CurvePolygon ;_gfdeg float64 ;_fabg float64 ;};

// SetBorderOpacity sets the border opacity.
func (_ege *PolyBezierCurve )SetBorderOpacity (opacity float64 ){_ege ._cecc =opacity };

// SetStyleBottom sets border style for bottom side.
func (_adc *border )SetStyleBottom (style CellBorderStyle ){_adc ._fdgef =style };func (_gfec *Invoice )generateHeaderBlocks (_dfed DrawContext )([]*Block ,DrawContext ,error ){_gfaf :=_addb (_gfec ._gdd );_gfaf .SetEnableWrap (true );_gfaf .Append (_gfec ._cdec );
_fdfe :=_gggcg (2);if _gfec ._aded !=nil {_geafa :=_fdfe .NewCell ();_geafa .SetHorizontalAlignment (CellHorizontalAlignmentLeft );_geafa .SetVerticalAlignment (CellVerticalAlignmentMiddle );_geafa .SetIndent (0);_geafa .SetContent (_gfec ._aded );_gfec ._aded .ScaleToHeight (_gfaf .Height ()+20);
}else {_fdfe .SkipCells (1);};_acfaa :=_fdfe .NewCell ();_acfaa .SetHorizontalAlignment (CellHorizontalAlignmentRight );_acfaa .SetVerticalAlignment (CellVerticalAlignmentMiddle );_acfaa .SetContent (_gfaf );return _fdfe .GeneratePageBlocks (_dfed );};
func (_ccdc *Invoice )generateInformationBlocks (_fceec DrawContext )([]*Block ,DrawContext ,error ){_fecf :=_addb (_ccdc ._ccfe );_fecf .SetMargins (0,0,0,20);_badfb :=_ccdc .drawAddress (_ccdc ._dbab );_badfb =append (_badfb ,_fecf );_badfb =append (_badfb ,_ccdc .drawAddress (_ccdc ._cgad )...);
_cdeg :=_gbec ();for _ ,_bbg :=range _badfb {_cdeg .Add (_bbg );};_cfdg :=_ccdc .drawInformation ();_eccge :=_gggcg (2);_eccge .SetMargins (0,0,25,0);_egcb :=_eccge .NewCell ();_egcb .SetIndent (0);_egcb .SetContent (_cdeg );_egcb =_eccge .NewCell ();_egcb .SetContent (_cfdg );
return _eccge .GeneratePageBlocks (_fceec );};

// Terms returns the terms and conditions section of the invoice as a
// title-content pair.
func (_dbcd *Invoice )Terms ()(string ,string ){return _dbcd ._ccf [0],_dbcd ._ccf [1]};func (_bdebf *Invoice )newCell (_dccb string ,_adfd InvoiceCellProps )*InvoiceCell {return &InvoiceCell {_adfd ,_dccb };};

// SetLineHeight sets the line height (1.0 default).
func (_cbdga *StyledParagraph )SetLineHeight (lineheight float64 ){_cbdga ._baega =lineheight };

// Width is not used. Not used as a Table element is designed to fill into
// available width depending on the context. Returns 0.
func (_fbbf *Table )Width ()float64 {return 0};

// NewLine creates a new Line with default parameters between (x1,y1) to (x2,y2).
func (_fed *Creator )NewLine (x1 ,y1 ,x2 ,y2 float64 )*Line {return _gdeb (x1 ,y1 ,x2 ,y2 )};

// CurRow returns the currently active cell's row number.
func (_cbbc *Table )CurRow ()int {_adgbb :=(_cbbc ._bgeb -1)/_cbbc ._fceeb +1;return _adgbb };

// New creates a new instance of the PDF Creator.
func New ()*Creator {const _ggde ="c\u0072\u0065\u0061\u0074\u006f\u0072\u002e\u004e\u0065\u0077";_agc :=&Creator {};_agc ._gef =[]*_afd .PdfPage {};_agc ._bffa =map[*_afd .PdfPage ]*Block {};_agc .SetPageSize (PageSizeLetter );_fdcb :=0.1*_agc ._aeg ;
_agc ._cce .Left =_fdcb ;_agc ._cce .Right =_fdcb ;_agc ._cce .Top =_fdcb ;_agc ._cce .Bottom =_fdcb ;var _bga error ;_agc ._dabc ,_bga =_afd .NewStandard14Font (_afd .HelveticaName );if _bga !=nil {_agc ._dabc =_afd .DefaultFont ();};_agc ._aeeb ,_bga =_afd .NewStandard14Font (_afd .HelveticaBoldName );
if _bga !=nil {_agc ._dabc =_afd .DefaultFont ();};_agc ._feg =_agc .NewTOC ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073");_agc .AddOutlines =true ;_agc ._gbed =_afd .NewOutline ();_afa .TrackUse (_ggde );
return _agc ;};func (_ddac *Division )ctxHeight (_cedff float64 )float64 {var _adbbb float64 ;for _ ,_bea :=range _ddac ._bdcb {switch _bdd :=_bea .(type ){case *Paragraph :if _bdd ._fceb {_bdd .SetWidth (_cedff );};_adbbb +=_bdd .Height ()+_bdd ._fegc .Top +_bdd ._fegc .Bottom ;
case *StyledParagraph :if _bdd ._beab {_bdd .SetWidth (_cedff );};_adbbb +=_bdd .Height ()+_bdd ._ggdg .Top +_bdd ._ggdg .Bottom ;default:_adbbb +=_bdd .Height ();};};return _adbbb ;};

// NewPolyline creates a new polyline.
func (_ffaf *Creator )NewPolyline (points []_fd .Point )*Polyline {return _dgcc (points )};

// SetOutlineTree adds the specified outline tree to the PDF file generated
// by the creator. Adding an external outline tree disables the automatic
// generation of outlines done by the creator for the relevant components.
func (_fgace *Creator )SetOutlineTree (outlineTree *_afd .PdfOutlineTreeNode ){_fgace ._ddd =outlineTree ;};

// Height returns Image's document height.
func (_gfaa *Image )Height ()float64 {return _gfaa ._fcae };

// GeneratePageBlocks generate the Page blocks. Draws the Image on a block, implementing the Drawable interface.
func (_agfa *Image )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){if _agfa ._adbe ==nil {if _bgbc :=_agfa .makeXObject ();_bgbc !=nil {return nil ,ctx ,_bgbc ;};};var _cab []*Block ;_ccgg :=ctx ;_cbdd :=NewBlock (ctx .PageWidth ,ctx .PageHeight );
if _agfa ._fcb .IsRelative (){ctx .X +=_agfa ._acfb .Left ;ctx .Y +=_agfa ._acfb .Top ;ctx .Width -=_agfa ._acfb .Left +_agfa ._acfb .Right ;ctx .Height -=_agfa ._acfb .Top +_agfa ._acfb .Bottom ;if _agfa ._fcae > ctx .Height {_cab =append (_cab ,_cbdd );
_cbdd =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_cgfg :=ctx ;_cgfg .Y =ctx .Margins .Top +_agfa ._acfb .Top ;_cgfg .X =ctx .Margins .Left +_agfa ._acfb .Left ;_cgfg .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_agfa ._acfb .Top -_agfa ._acfb .Bottom ;
_cgfg .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_agfa ._acfb .Left -_agfa ._acfb .Right ;ctx =_cgfg ;_ccgg .X =ctx .Margins .Left ;_ccgg .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right ;};}else {ctx .X =_agfa ._dbbb ;
ctx .Y =_agfa ._ebdd ;};ctx ,_fecab :=_fda (_cbdd ,_agfa ,ctx );if _fecab !=nil {return nil ,ctx ,_fecab ;};_cab =append (_cab ,_cbdd );if _agfa ._fcb .IsAbsolute (){ctx =_ccgg ;}else {ctx .X =_ccgg .X ;ctx .Y +=_agfa ._acfb .Bottom ;ctx .Width =_ccgg .Width ;
};return _cab ,ctx ,nil ;};

// Insert adds a new text chunk at the specified position in the paragraph.
func (_aacd *StyledParagraph )Insert (index uint ,text string )*TextChunk {_eceb :=uint (len (_aacd ._ggfd ));if index > _eceb {index =_eceb ;};_cbbf :=NewTextChunk (text ,_aacd ._eaba );_aacd ._ggfd =append (_aacd ._ggfd [:index ],append ([]*TextChunk {_cbbf },_aacd ._ggfd [index :]...)...);
_aacd .wrapText ();return _cbbf ;};

// AddTotalLine adds a new line in the invoice totals table.
func (_aecg *Invoice )AddTotalLine (desc ,value string )(*InvoiceCell ,*InvoiceCell ){_ccff :=&InvoiceCell {_aecg ._gbcd ,desc };_dbce :=&InvoiceCell {_aecg ._gbcd ,value };_aecg ._gdff =append (_aecg ._gdff ,[2]*InvoiceCell {_ccff ,_dbce });return _ccff ,_dbce ;
};

// Height returns the height of the division, assuming all components are
// stacked on top of each other.
func (_fdec *Division )Height ()float64 {var _fddd float64 ;for _ ,_edbg :=range _fdec ._bdcb {switch _acgd :=_edbg .(type ){case *Paragraph :_fddd +=_acgd .Height ()+_acgd ._fegc .Top +_acgd ._fegc .Bottom ;case *StyledParagraph :_fddd +=_acgd .Height ()+_acgd ._ggdg .Top +_acgd ._ggdg .Bottom ;
default:_fddd +=_acgd .Height ();};};return _fddd ;};func _gabg (_edeb *Table ,_fcge DrawContext )([]*Block ,DrawContext ,error ){var _cbccg []*Block ;_acaba :=NewBlock (_fcge .PageWidth ,_fcge .PageHeight );_daed :=_fcge ;if _edeb ._eadc .IsAbsolute (){_fcge .X =_edeb ._cgcbe ;
_fcge .Y =_edeb ._cggg ;}else {_fcge .X +=_edeb ._badde .Left ;_fcge .Y +=_edeb ._badde .Top ;_fcge .Width -=_edeb ._badde .Left +_edeb ._badde .Right ;_fcge .Height -=_edeb ._badde .Bottom +_edeb ._badde .Top ;};_eggbd :=_fcge .Width ;_cfgb :=_fcge .X ;
_fdfd :=_fcge .Y ;_fcge .Height =_fcge .PageHeight -_fcge .Y -_fcge .Margins .Bottom ;_cbbcd :=_fcge .Height ;_ecfe :=0;_bfdg ,_fbeec :=-1,-1;for _gabd ,_baea :=range _edeb ._efgd {_feed :=_baea .width (_edeb ._eabc ,_eggbd );if _edeb ._ebf {if _baea ._dfda >=_edeb ._bead &&_baea ._dfda <=_edeb ._fcefe {if _bfdg < 0{_bfdg =_gabd ;
};_fbeec =_gabd ;};};_afgb :=_edeb ._aedeb [_baea ._dfda +_baea ._fdab -2];if _efafe :=_baea .height (_feed );_efafe > _afgb {_edeb ._aedeb [_baea ._dfda +_baea ._fdab -2]=_efafe ;};};var (_febc bool ;_gbae int ;_aegb int ;_bdgf bool ;_afeb int ;_cefd error ;
);for _bade :=0;_bade < len (_edeb ._efgd );_bade ++{_ffdd :=_edeb ._efgd [_bade ];_dabb :=_ffdd .width (_edeb ._eabc ,_eggbd );_efbdd :=float64 (0.0);for _gdccb :=0;_gdccb < _ffdd ._ccegd -1;_gdccb ++{_efbdd +=_edeb ._eabc [_gdccb ]*_eggbd ;};_beeba :=float64 (0.0);
for _bccb :=_ecfe ;_bccb < _ffdd ._dfda -1;_bccb ++{_beeba +=_edeb ._aedeb [_bccb ];};_fcge .Height =_cbbcd -_beeba ;_ddab :=float64 (0.0);for _fagee :=0;_fagee < _ffdd ._fdab ;_fagee ++{_ddab +=_edeb ._aedeb [_ffdd ._dfda +_fagee -1];};_afed :=_bdgf &&_ffdd ._dfda !=_afeb ;
_afeb =_ffdd ._dfda ;if _afed ||_ddab > _fcge .Height {if _edeb ._fefe &&!_bdgf {_bdgf ,_cefd =_edeb .wrapRow (_bade ,_fcge ,_eggbd );if _cefd !=nil {return nil ,_fcge ,_cefd ;};if _bdgf {_bade --;continue ;};};_cbccg =append (_cbccg ,_acaba );_acaba =NewBlock (_fcge .PageWidth ,_fcge .PageHeight );
_cfgb =_fcge .Margins .Left ;_fdfd =_fcge .Margins .Top ;_fcge .Height =_fcge .PageHeight -_fcge .Margins .Top -_fcge .Margins .Bottom ;_fcge .Page ++;_cbbcd =_fcge .Height ;_ecfe =_ffdd ._dfda -1;_beeba =0;_bdgf =false ;if _edeb ._ebf &&_bfdg >=0{_gbae =_bade ;
_bade =_bfdg -1;_aegb =_ecfe ;_ecfe =_edeb ._bead -1;_febc =true ;continue ;};if _afed {_bade --;continue ;};};_fcge .Width =_dabb ;_fcge .X =_cfgb +_efbdd ;_fcge .Y =_fdfd +_beeba ;_egae :=_dbg (_fcge .X ,_fcge .Y ,_dabb ,_ddab );if _ffdd ._dffg !=nil {_egae .SetFillColor (_ffdd ._dffg );
};_egae .LineStyle =_ffdd ._becdfa ;_egae ._ggce =_ffdd ._gcce ;_egae ._bf =_ffdd ._abgee ;_egae ._adgb =_ffdd ._ecgcf ;_egae ._fdgef =_ffdd ._efda ;if _ffdd ._ggef !=nil {_egae .SetColorLeft (_ffdd ._ggef );};if _ffdd ._fdcc !=nil {_egae .SetColorBottom (_ffdd ._fdcc );
};if _ffdd ._bfca !=nil {_egae .SetColorRight (_ffdd ._bfca );};if _ffdd ._aeae !=nil {_egae .SetColorTop (_ffdd ._aeae );};_egae .SetWidthBottom (_ffdd ._edg );_egae .SetWidthLeft (_ffdd ._dggfd );_egae .SetWidthRight (_ffdd ._debe );_egae .SetWidthTop (_ffdd ._edcbb );
_bbfg :=_acaba .Draw (_egae );if _bbfg !=nil {_ff .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_bbfg );};if _ffdd ._fcgd !=nil {_adedd :=_ffdd ._fcgd .Width ();_edcf :=_ffdd ._fcgd .Height ();_afcbg :=0.0;switch _cffaf :=_ffdd ._fcgd .(type ){case *Paragraph :if _cffaf ._fceb {_adedd =_cffaf .getMaxLineWidth ()/1000.0;
};_adedd +=_cffaf ._fegc .Left +_cffaf ._fegc .Right ;_edcf +=_cffaf ._fegc .Top +_cffaf ._fegc .Bottom ;case *StyledParagraph :if _cffaf ._beab {_adedd =_cffaf .getMaxLineWidth ()/1000.0;};_gbdda ,_beda :=_cffaf .getLineHeight (0);if len (_cffaf ._faaf )==1{_edcf =_gbdda ;
}else {_edcf =_edcf -_beda +_gbdda ;};_afcbg =_gbdda -_beda ;switch _ffdd ._bbag {case CellVerticalAlignmentTop :_afcbg +=_gbdda *0.5;case CellVerticalAlignmentBottom :_afcbg -=_gbdda *0.5;};_adedd +=_cffaf ._ggdg .Left +_cffaf ._ggdg .Right ;_edcf +=_cffaf ._ggdg .Top +_cffaf ._ggdg .Bottom ;
case *Table :_adedd =_dabb ;case *List :_adedd =_dabb ;};switch _ffdd ._gaef {case CellHorizontalAlignmentLeft :_fcge .X +=_ffdd ._dcgf ;_fcge .Width -=_ffdd ._dcgf ;case CellHorizontalAlignmentCenter :if _bggd :=_dabb -_adedd ;_bggd > 0{_fcge .X +=_bggd /2;
_fcge .Width -=_bggd /2;};case CellHorizontalAlignmentRight :if _dabb > _adedd {_fcge .X =_fcge .X +_dabb -_adedd -_ffdd ._dcgf ;_fcge .Width -=_ffdd ._dcgf ;};};_fcge .Y +=_afcbg ;switch _ffdd ._bbag {case CellVerticalAlignmentTop :case CellVerticalAlignmentMiddle :if _fbga :=_ddab -_edcf ;
_fbga > 0{_fcge .Y +=_fbga /2;_fcge .Height -=_fbga /2;};case CellVerticalAlignmentBottom :if _ddab > _edcf {_fcge .Y =_fcge .Y +_ddab -_edcf ;_fcge .Height =_ddab ;};};_acbe :=_acaba .DrawWithContext (_ffdd ._fcgd ,_fcge );if _acbe !=nil {_ff .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_acbe );
};_fcge .Y -=_afcbg ;};_fcge .Y +=_ddab ;_fcge .Height -=_ddab ;if _febc &&_bade +1> _fbeec {_fdfd +=_beeba +_ddab ;_cbbcd -=_ddab +_beeba ;_ecfe =_aegb ;_bade =_gbae -1;_febc =false ;};};_cbccg =append (_cbccg ,_acaba );if _edeb ._eadc .IsAbsolute (){return _cbccg ,_daed ,nil ;
};_fcge .X =_daed .X ;_fcge .Width =_daed .Width ;_fcge .Y +=_edeb ._badde .Bottom ;_fcge .Height -=_edeb ._badde .Bottom ;return _cbccg ,_fcge ,nil ;};

// NewBlock creates a new Block with specified width and height.
func NewBlock (width float64 ,height float64 )*Block {_cb :=&Block {};_cb ._de =&_da .ContentStreamOperations {};_cb ._cf =_afd .NewPdfPageResources ();_cb ._dag =width ;_cb ._gg =height ;return _cb ;};

// SetFont sets the Paragraph's font.
func (_gdbc *Paragraph )SetFont (font *_afd .PdfFont ){_gdbc ._gbfc =font };

// Width is not used. The list component is designed to fill into the available
// width depending on the context. Returns 0.
func (_cbcc *List )Width ()float64 {return 0};

// SetWidthRight sets border width for right.
func (_gfbe *border )SetWidthRight (bw float64 ){_gfbe ._beb =bw };

// SetNoteHeadingStyle sets the style properties used to render the heading
// of the invoice note sections.
func (_ccc *Invoice )SetNoteHeadingStyle (style TextStyle ){_ccc ._ggdd =style };

// GeneratePageBlocks implements drawable interface.
func (_fac *border )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_adaa :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_geaf :=_fac ._dae ;_gfe :=ctx .PageHeight -_fac ._dgaf ;if _fac ._gcd !=nil {_fga :=_fd .Rectangle {Opacity :1.0,X :_fac ._dae ,Y :ctx .PageHeight -_fac ._dgaf -_fac ._bcc ,Height :_fac ._bcc ,Width :_fac ._acea };
_fga .FillEnabled =true ;_fga .FillColor =_bff (_fac ._gcd );_fga .BorderEnabled =false ;_efaf ,_ ,_cagcg :=_fga .Draw ("");if _cagcg !=nil {return nil ,ctx ,_cagcg ;};_cagcg =_adaa .addContentsByString (string (_efaf ));if _cagcg !=nil {return nil ,ctx ,_cagcg ;
};};_cfe :=_fac ._efa ;_fcg :=_fac ._deb ;_aba :=_fac ._eec ;_fab :=_fac ._beb ;_bgde :=_fac ._efa ;if _fac ._adgb ==CellBorderStyleDouble {_bgde +=2*_cfe ;};_gggb :=_fac ._deb ;if _fac ._fdgef ==CellBorderStyleDouble {_gggb +=2*_fcg ;};_bfe :=_fac ._eec ;
if _fac ._ggce ==CellBorderStyleDouble {_bfe +=2*_aba ;};_fdba :=_fac ._beb ;if _fac ._bf ==CellBorderStyleDouble {_fdba +=2*_fab ;};if _fac ._efa !=0{_fdc :=_geaf ;_ffa :=_gfe ;if _fac ._adgb ==CellBorderStyleDouble {_ffa -=_cfe ;_fgbe :=_fd .BasicLine {};
_fgbe .X1 =_fdc -_bgde /2;_fgbe .Y1 =_ffa +2*_cfe ;_fgbe .X2 =_fdc +_fac ._acea +_bgde /2;_fgbe .Y2 =_ffa +2*_cfe ;_fgbe .LineColor =_bff (_fac ._dcg );_fgbe .LineWidth =_fac ._efa ;_fgbe .LineStyle =_fac .LineStyle ;_dcad ,_ ,_adaae :=_fgbe .Draw ("");
if _adaae !=nil {return nil ,ctx ,_adaae ;};_adaae =_adaa .addContentsByString (string (_dcad ));if _adaae !=nil {return nil ,ctx ,_adaae ;};};_ecde :=_fd .BasicLine {LineWidth :_fac ._efa ,Opacity :1.0,LineColor :_bff (_fac ._dcg ),X1 :_fdc -_bgde /2+(_bfe -_fac ._eec ),Y1 :_ffa ,X2 :_fdc +_fac ._acea +_bgde /2-(_fdba -_fac ._beb ),Y2 :_ffa ,LineStyle :_fac .LineStyle };
_ffg ,_ ,_dcc :=_ecde .Draw ("");if _dcc !=nil {return nil ,ctx ,_dcc ;};_dcc =_adaa .addContentsByString (string (_ffg ));if _dcc !=nil {return nil ,ctx ,_dcc ;};};if _fac ._deb !=0{_gde :=_geaf ;_baf :=_gfe -_fac ._bcc ;if _fac ._fdgef ==CellBorderStyleDouble {_baf +=_fcg ;
_aed :=_fd .BasicLine {LineWidth :_fac ._deb ,Opacity :1.0,LineColor :_bff (_fac ._fbc ),X1 :_gde -_gggb /2,Y1 :_baf -2*_fcg ,X2 :_gde +_fac ._acea +_gggb /2,Y2 :_baf -2*_fcg ,LineStyle :_fac .LineStyle };_adca ,_ ,_bfg :=_aed .Draw ("");if _bfg !=nil {return nil ,ctx ,_bfg ;
};_bfg =_adaa .addContentsByString (string (_adca ));if _bfg !=nil {return nil ,ctx ,_bfg ;};};_debg :=_fd .BasicLine {LineWidth :_fac ._deb ,Opacity :1.0,LineColor :_bff (_fac ._fbc ),X1 :_gde -_gggb /2+(_bfe -_fac ._eec ),Y1 :_baf ,X2 :_gde +_fac ._acea +_gggb /2-(_fdba -_fac ._beb ),Y2 :_baf ,LineStyle :_fac .LineStyle };
_daa ,_ ,_gcg :=_debg .Draw ("");if _gcg !=nil {return nil ,ctx ,_gcg ;};_gcg =_adaa .addContentsByString (string (_daa ));if _gcg !=nil {return nil ,ctx ,_gcg ;};};if _fac ._eec !=0{_bdc :=_geaf ;_abbe :=_gfe ;if _fac ._ggce ==CellBorderStyleDouble {_bdc +=_aba ;
_gad :=_fd .BasicLine {LineWidth :_fac ._eec ,Opacity :1.0,LineColor :_bff (_fac ._cdd ),X1 :_bdc -2*_aba ,Y1 :_abbe +_bfe /2,X2 :_bdc -2*_aba ,Y2 :_abbe -_fac ._bcc -_bfe /2,LineStyle :_fac .LineStyle };_ded ,_ ,_fgc :=_gad .Draw ("");if _fgc !=nil {return nil ,ctx ,_fgc ;
};_fgc =_adaa .addContentsByString (string (_ded ));if _fgc !=nil {return nil ,ctx ,_fgc ;};};_gfdb :=_fd .BasicLine {LineWidth :_fac ._eec ,Opacity :1.0,LineColor :_bff (_fac ._cdd ),X1 :_bdc ,Y1 :_abbe +_bfe /2-(_bgde -_fac ._efa ),X2 :_bdc ,Y2 :_abbe -_fac ._bcc -_bfe /2+(_gggb -_fac ._deb ),LineStyle :_fac .LineStyle };
_dcag ,_ ,_gbga :=_gfdb .Draw ("");if _gbga !=nil {return nil ,ctx ,_gbga ;};_gbga =_adaa .addContentsByString (string (_dcag ));if _gbga !=nil {return nil ,ctx ,_gbga ;};};if _fac ._beb !=0{_ddce :=_geaf +_fac ._acea ;_gdbb :=_gfe ;if _fac ._bf ==CellBorderStyleDouble {_ddce -=_fab ;
_fgf :=_fd .BasicLine {LineWidth :_fac ._beb ,Opacity :1.0,LineColor :_bff (_fac ._dcbg ),X1 :_ddce +2*_fab ,Y1 :_gdbb +_fdba /2,X2 :_ddce +2*_fab ,Y2 :_gdbb -_fac ._bcc -_fdba /2,LineStyle :_fac .LineStyle };_afb ,_ ,_cgge :=_fgf .Draw ("");if _cgge !=nil {return nil ,ctx ,_cgge ;
};_cgge =_adaa .addContentsByString (string (_afb ));if _cgge !=nil {return nil ,ctx ,_cgge ;};};_badf :=_fd .BasicLine {LineWidth :_fac ._beb ,Opacity :1.0,LineColor :_bff (_fac ._dcbg ),X1 :_ddce ,Y1 :_gdbb +_fdba /2-(_bgde -_fac ._efa ),X2 :_ddce ,Y2 :_gdbb -_fac ._bcc -_fdba /2+(_gggb -_fac ._deb ),LineStyle :_fac .LineStyle };
_abg ,_ ,_gfc :=_badf .Draw ("");if _gfc !=nil {return nil ,ctx ,_gfc ;};_gfc =_adaa .addContentsByString (string (_abg ));if _gfc !=nil {return nil ,ctx ,_gfc ;};};return []*Block {_adaa },ctx ,nil ;};

// GetMargins returns the Image's margins: left, right, top, bottom.
func (_aaa *Image )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _aaa ._acfb .Left ,_aaa ._acfb .Right ,_aaa ._acfb .Top ,_aaa ._acfb .Bottom ;};func _ebbc (_bcfa ,_bebc ,_dfbaf TextChunk ,_fbaee uint ,_ccbd TextStyle )*TOCLine {_dfdbc :=_addb (_ccbd );
_dfdbc .SetEnableWrap (true );_dfdbc .SetTextAlignment (TextAlignmentLeft );_dfdbc .SetMargins (0,0,2,2);_cafa :=&TOCLine {_dfec :_dfdbc ,Number :_bcfa ,Title :_bebc ,Page :_dfbaf ,Separator :TextChunk {Text :"\u002e",Style :_ccbd },_gada :0,_dbgca :_fbaee ,_gdfd :10,_fecg :PositionRelative };
_dfdbc ._ggdg .Left =_cafa ._gada +float64 (_cafa ._dbgca -1)*_cafa ._gdfd ;_dfdbc ._adfc =_cafa .prepareParagraph ;return _cafa ;};

// SetEnableWrap sets the line wrapping enabled flag.
func (_fagc *StyledParagraph )SetEnableWrap (enableWrap bool ){_fagc ._beab =enableWrap ;_fagc ._edaa =false ;};

// SetWidth sets the the Paragraph width. This is essentially the wrapping width, i.e. the width the
// text can extend to prior to wrapping over to next line.
func (_accec *Paragraph )SetWidth (width float64 ){_accec ._efbd =width ;_accec .wrapText ()};

// SetMargins sets the Table's left, right, top, bottom margins.
func (_bgbbab *Table )SetMargins (left ,right ,top ,bottom float64 ){_bgbbab ._badde .Left =left ;_bgbbab ._badde .Right =right ;_bgbbab ._badde .Top =top ;_bgbbab ._badde .Bottom =bottom ;};

// SetText sets the text content of the Paragraph.
func (_dfag *Paragraph )SetText (text string ){_dfag ._ddcg =text };

// DrawHeader sets a function to draw a header on created output pages.
func (_bgded *Creator )DrawHeader (drawHeaderFunc func (_fea *Block ,_eac HeaderFunctionArgs )){_bgded ._egde =drawHeaderFunc ;};

// SetBorderOpacity sets the border opacity.
func (_eecd *Polygon )SetBorderOpacity (opacity float64 ){_eecd ._gafa =opacity };const (CellBorderStyleNone CellBorderStyle =iota ;CellBorderStyleSingle ;CellBorderStyleDouble ;);

// TextDecorationLineStyle represents the style of lines used to decorate
// a text chunk (e.g. underline).
type TextDecorationLineStyle struct{

// Color represents the color of the line (default: the color of the text).
Color Color ;

// Offset represents the vertical offset of the line (default: 1).
Offset float64 ;

// Thickness represents the thickness of the line (default: 1).
Thickness float64 ;};

// NewTextChunk returns a new text chunk instance.
func NewTextChunk (text string ,style TextStyle )*TextChunk {return &TextChunk {Text :text ,Style :style };};type containerDrawable interface{Drawable ;

// ContainerComponent checks if the component is allowed to be added into provided 'container' and returns
// preprocessed copy of itself. If the component is not changed it is allowed to return itself in a callback way.
// If the component is not compatible with provided container this method should return an error.
ContainerComponent (_bfb Drawable )(Drawable ,error );};func _egge (_ffab TextStyle )*List {return &List {_faac :TextChunk {Text :"\u2022\u0020",Style :_ffab },_fgcge :0,_agg :true ,_aecf :PositionRelative ,_egdee :_ffab };};

// SetTitleStyle sets the style properties of the invoice title.
func (_dfgf *Invoice )SetTitleStyle (style TextStyle ){_dfgf ._gdd =style };

// SetWidthBottom sets border width for bottom.
func (_eeec *border )SetWidthBottom (bw float64 ){_eeec ._deb =bw };

// GeneratePageBlocks generates the table page blocks. Multiple blocks are
// generated if the contents wrap over multiple pages.
// Implements the Drawable interface.
func (_gbfcf *Table )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fcaae :=_gbfcf ;if _gbfcf ._fefe {_fcaae =_gbfcf .clone ();};return _gabg (_fcaae ,ctx );};func (_eecf *Creator )newPage ()*_afd .PdfPage {_cbfd :=_afd .NewPdfPage ();
_fff :=_eecf ._dbb [0];_acfa :=_eecf ._dbb [1];_ece :=_afd .PdfRectangle {Llx :0,Lly :0,Urx :_fff ,Ury :_acfa };_cbfd .MediaBox =&_ece ;_eecf ._aeg =_fff ;_eecf ._eadf =_acfa ;_eecf .initContext ();return _cbfd ;};func (_ecbab *Table )clone ()*Table {_deagc :=*_ecbab ;
_deagc ._aedeb =make ([]float64 ,len (_ecbab ._aedeb ));copy (_deagc ._aedeb ,_ecbab ._aedeb );_deagc ._eabc =make ([]float64 ,len (_ecbab ._eabc ));copy (_deagc ._eabc ,_ecbab ._eabc );_deagc ._efgd =make ([]*TableCell ,0,len (_ecbab ._efgd ));for _ ,_ggba :=range _ecbab ._efgd {_efeg :=*_ggba ;
_efeg ._ffdff =&_deagc ;_deagc ._efgd =append (_deagc ._efgd ,&_efeg );};return &_deagc ;};

// SetRowHeight sets the height for a specified row.
func (_ebce *Table )SetRowHeight (row int ,h float64 )error {if row < 1||row > len (_ebce ._aedeb ){return _a .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_ebce ._aedeb [row -1]=h ;return nil ;
};

// SetMargins sets the margins of the paragraph.
func (_ffea *List )SetMargins (left ,right ,top ,bottom float64 ){_ffea ._bded .Left =left ;_ffea ._bded .Right =right ;_ffea ._bded .Top =top ;_ffea ._bded .Bottom =bottom ;};func (_ddad *Invoice )generateTotalBlocks (_bgae DrawContext )([]*Block ,DrawContext ,error ){_acgbc :=_gggcg (4);
_acgbc .SetMargins (0,0,10,10);_edae :=[][2]*InvoiceCell {_ddad ._cagd };_edae =append (_edae ,_ddad ._gdff ...);_edae =append (_edae ,_ddad ._abd );for _ ,_babb :=range _edae {_fdcd ,_aab :=_babb [0],_babb [1];if _aab .Value ==""{continue ;};_acgbc .SkipCells (2);
_gdef :=_acgbc .NewCell ();_gdef .SetBackgroundColor (_fdcd .BackgroundColor );_gdef .SetHorizontalAlignment (_aab .Alignment );_ddad .setCellBorder (_gdef ,_fdcd );_bgedf :=_addb (_fdcd .TextStyle );_bgedf .SetMargins (0,0,2,1);_bgedf .Append (_fdcd .Value );
_gdef .SetContent (_bgedf );_gdef =_acgbc .NewCell ();_gdef .SetBackgroundColor (_aab .BackgroundColor );_gdef .SetHorizontalAlignment (_aab .Alignment );_ddad .setCellBorder (_gdef ,_fdcd );_bgedf =_addb (_aab .TextStyle );_bgedf .SetMargins (0,0,2,1);
_bgedf .Append (_aab .Value );_gdef .SetContent (_bgedf );};return _acgbc .GeneratePageBlocks (_bgae );};

// SetLevelOffset sets the amount of space an indentation level occupies.
func (_efgcc *TOCLine )SetLevelOffset (levelOffset float64 ){_efgcc ._gdfd =levelOffset ;_efgcc ._dfec ._ggdg .Left =_efgcc ._gada +float64 (_efgcc ._dbgca -1)*_efgcc ._gdfd ;};

// NewCurvePolygon creates a new curve polygon.
func (_effg *Creator )NewCurvePolygon (rings [][]_fd .CubicBezierCurve )*CurvePolygon {return _ggbec (rings );};

// SetLineStyle sets the style for all the line components: number, title,
// separator, page. The style is applied only for new lines added to the
// TOC component.
func (_fedbd *TOC )SetLineStyle (style TextStyle ){_fedbd .SetLineNumberStyle (style );_fedbd .SetLineTitleStyle (style );_fedbd .SetLineSeparatorStyle (style );_fedbd .SetLinePageStyle (style );};func (_fbfa *TableCell )width (_eedb []float64 ,_baec float64 )float64 {_fffcf :=float64 (0.0);
for _bfcc :=0;_bfcc < _fbfa ._agdd ;_bfcc ++{_fffcf +=_eedb [_fbfa ._ccegd +_bfcc -1];};return _fffcf *_baec ;};

// AddInfo is used to append a piece of invoice information in the template
// information table.
func (_cgafd *Invoice )AddInfo (description ,value string )(*InvoiceCell ,*InvoiceCell ){_cad :=[2]*InvoiceCell {_cgafd .newCell (description ,_cgafd ._cbag ),_cgafd .newCell (value ,_cgafd ._cbag )};_cgafd ._bcafe =append (_cgafd ._bcafe ,_cad );return _cad [0],_cad [1];
};

// PolyBezierCurve represents a composite curve that is the result of joining
// multiple cubic Bezier curves.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type PolyBezierCurve struct{_ggbff *_fd .PolyBezierCurve ;_afece float64 ;_cecc float64 ;};

// Paragraph represents text drawn with a specified font and can wrap across lines and pages.
// By default it occupies the available width in the drawing context.
type Paragraph struct{_ddcg string ;_gbfc *_afd .PdfFont ;_afec float64 ;_ffdf float64 ;_eedd Color ;_bdcc TextAlignment ;_fceb bool ;_efbd float64 ;_begg int ;_beee bool ;_bcad float64 ;_fegc Margins ;_becd Positioning ;_bbdg float64 ;_fagg float64 ;_ddaa ,_eeee float64 ;
_eedde []string ;};var (PageSizeA3 =PageSize {297*PPMM ,420*PPMM };PageSizeA4 =PageSize {210*PPMM ,297*PPMM };PageSizeA5 =PageSize {148*PPMM ,210*PPMM };PageSizeLetter =PageSize {8.5*PPI ,11*PPI };PageSizeLegal =PageSize {8.5*PPI ,14*PPI };);

// SetBorderOpacity sets the border opacity.
func (_ecegb *CurvePolygon )SetBorderOpacity (opacity float64 ){_ecegb ._fabg =opacity };func (_eb *Block )setOpacity (_ggg float64 ,_ce float64 )(string ,error ){if (_ggg < 0||_ggg >=1.0)&&(_ce < 0||_ce >=1.0){return "",nil ;};_eg :=0;_dac :=_ec .Sprintf ("\u0047\u0053\u0025\u0064",_eg );
for _eb ._cf .HasExtGState (_c .PdfObjectName (_dac )){_eg ++;_dac =_ec .Sprintf ("\u0047\u0053\u0025\u0064",_eg );};_db :=_c .MakeDict ();if _ggg >=0&&_ggg < 1.0{_db .Set ("\u0063\u0061",_c .MakeFloat (_ggg ));};if _ce >=0&&_ce < 1.0{_db .Set ("\u0043\u0041",_c .MakeFloat (_ce ));
};_fca :=_eb ._cf .AddExtGState (_c .PdfObjectName (_dac ),_db );if _fca !=nil {return "",_fca ;};return _dac ,nil ;};

// NewPolygon creates a new polygon.
func (_bbbc *Creator )NewPolygon (points [][]_fd .Point )*Polygon {return _dbdb (points )};

// SetBorder sets the cell's border style.
func (_cddc *TableCell )SetBorder (side CellBorderSide ,style CellBorderStyle ,width float64 ){if style ==CellBorderStyleSingle &&side ==CellBorderSideAll {_cddc ._gcce =CellBorderStyleSingle ;_cddc ._dggfd =width ;_cddc ._efda =CellBorderStyleSingle ;
_cddc ._edg =width ;_cddc ._abgee =CellBorderStyleSingle ;_cddc ._debe =width ;_cddc ._ecgcf =CellBorderStyleSingle ;_cddc ._edcbb =width ;}else if style ==CellBorderStyleDouble &&side ==CellBorderSideAll {_cddc ._gcce =CellBorderStyleDouble ;_cddc ._dggfd =width ;
_cddc ._efda =CellBorderStyleDouble ;_cddc ._edg =width ;_cddc ._abgee =CellBorderStyleDouble ;_cddc ._debe =width ;_cddc ._ecgcf =CellBorderStyleDouble ;_cddc ._edcbb =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideLeft {_cddc ._gcce =style ;
_cddc ._dggfd =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideBottom {_cddc ._efda =style ;_cddc ._edg =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideRight {_cddc ._abgee =style ;
_cddc ._debe =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideTop {_cddc ._ecgcf =style ;_cddc ._edcbb =width ;};};func _edac (_bcgc string )*_afd .PdfAnnotation {_gefb :=_afd .NewPdfAnnotationLink ();
_eecac :=_afd .NewBorderStyle ();_eecac .SetBorderWidth (0);_gefb .BS =_eecac .ToPdfObject ();_gdga :=_afd .NewPdfActionURI ();_gdga .URI =_c .MakeString (_bcgc );_gefb .SetAction (_gdga .PdfAction );return _gefb .PdfAnnotation ;};func (_daca *StyledParagraph )appendChunk (_agda *TextChunk )*TextChunk {_daca ._ggfd =append (_daca ._ggfd ,_agda );
_daca .wrapText ();return _agda ;};

// SetFillOpacity sets the fill opacity.
func (_bedd *CurvePolygon )SetFillOpacity (opacity float64 ){_bedd ._gfdeg =opacity };

// ScaleToHeight scale Image to a specified height h, maintaining the aspect ratio.
func (_fbdce *Image )ScaleToHeight (h float64 ){_bbc :=_fbdce ._fdbad /_fbdce ._fcae ;_fbdce ._fcae =h ;_fbdce ._fdbad =h *_bbc ;};

// Add adds a VectorDrawable to the Division container.
// Currently supported VectorDrawables: *Paragraph, *StyledParagraph, *Image.
func (_dded *Division )Add (d VectorDrawable )error {switch _bfc :=d .(type ){case *Paragraph ,*StyledParagraph ,*Image :case containerDrawable :_ffde ,_eaf :=_bfc .ContainerComponent (_dded );if _eaf !=nil {return _eaf ;};_ffff ,_gbca :=_ffde .(VectorDrawable );
if !_gbca {return _ec .Errorf ("\u0072\u0065\u0073\u0075\u006ct\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0061\u0069\u006e\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u002d\u0020\u0025\u0054\u0020\u0064\u006f\u0065\u0073\u006e\u0027\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u0056\u0065c\u0074\u006f\u0072\u0044\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u0020i\u006e\u0074\u0065\u0072\u0066\u0061c\u0065",_ffde );
};d =_ffff ;default:return _a .New ("\u0075\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070e\u0020i\u006e\u0020\u0044\u0069\u0076\u0069\u0073i\u006f\u006e");};_dded ._bdcb =append (_dded ._bdcb ,d );return nil ;};

// Heading returns the heading component of the table of contents.
func (_eabfe *TOC )Heading ()*StyledParagraph {return _eabfe ._bcge };

// SetPos sets the Table's positioning to absolute mode and specifies the upper-left corner
// coordinates as (x,y).
// Note that this is only sensible to use when the table does not wrap over multiple pages.
// TODO: Should be able to set width too (not just based on context/relative positioning mode).
func (_cgda *Table )SetPos (x ,y float64 ){_cgda ._eadc =PositionAbsolute ;_cgda ._cgcbe =x ;_cgda ._cggg =y ;};

// IsRelative checks if the positioning is relative.
func (_cddac Positioning )IsRelative ()bool {return _cddac ==PositionRelative };

// GetMargins returns the Block's margins: left, right, top, bottom.
func (_gge *Block )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _gge ._b .Left ,_gge ._b .Right ,_gge ._b .Top ,_gge ._b .Bottom ;};func (_gdae *Paragraph )getTextWidth ()float64 {_cdcg :=0.0;for _ ,_gffda :=range _gdae ._ddcg {if _gffda =='\u000A'{continue ;
};_bgbba ,_ecdc :=_gdae ._gbfc .GetRuneMetrics (_gffda );if !_ecdc {_ff .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_gffda ,_gffda );
return -1;};_cdcg +=_gdae ._afec *_bgbba .Wx ;};return _cdcg ;};func _egfc (_accd ,_abba ,_dfac ,_fbgb float64 )*Ellipse {_cff :=&Ellipse {};_cff ._beag =_accd ;_cff ._cgde =_abba ;_cff ._adea =_dfac ;_cff ._bde =_fbgb ;_cff ._dgeg =ColorBlack ;_cff ._bffe =1.0;
return _cff ;};

// SetFillColor sets the fill color.
func (_dggd *Ellipse )SetFillColor (col Color ){_dggd ._gdfe =col };

// SetLineWidth sets the line width.
func (_effga *Polyline )SetLineWidth (lineWidth float64 ){_effga ._gbcb .LineWidth =lineWidth };

// DueDate returns the invoice due date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_feee *Invoice )DueDate ()(*InvoiceCell ,*InvoiceCell ){return _feee ._cbad [0],_feee ._cbad [1]};

// NewTextStyle creates a new text style object which can be used to style
// chunks of text.
// Default attributes:
// Font: Helvetica
// Font size: 10
// Encoding: WinAnsiEncoding
// Text color: black
func (_cbde *Creator )NewTextStyle ()TextStyle {return _eced (_cbde ._dabc )};

// InvoiceCell represents any cell belonging to a table from the invoice
// template. The main tables are the invoice information table, the line
// items table and totals table. Contains the text value of the cell and
// the style properties of the cell.
type InvoiceCell struct{InvoiceCellProps ;Value string ;};

// SetStyle sets the style for all the line components: number, title,
// separator, page.
func (_ecag *TOCLine )SetStyle (style TextStyle ){_ecag .Number .Style =style ;_ecag .Title .Style =style ;_ecag .Separator .Style =style ;_ecag .Page .Style =style ;};

// InvoiceCellProps holds all style properties for an invoice cell.
type InvoiceCellProps struct{TextStyle TextStyle ;Alignment CellHorizontalAlignment ;BackgroundColor Color ;BorderColor Color ;BorderWidth float64 ;BorderSides []CellBorderSide ;};

// SetBorderWidth sets the border width.
func (_edef *PolyBezierCurve )SetBorderWidth (borderWidth float64 ){_edef ._ggbff .BorderWidth =borderWidth ;};

// SetFillOpacity sets the fill opacity.
func (_gcdg *PolyBezierCurve )SetFillOpacity (opacity float64 ){_gcdg ._afece =opacity };

// SetColor sets the line color.
// Use ColorRGBFromHex, ColorRGBFrom8bit or ColorRGBFromArithmetic to make the color object.
func (_cgac *Line )SetColor (col Color ){_cgac ._dbgda =col };

// GeneratePageBlocks generates the page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages. Implements the Drawable interface.
func (_fbfca *StyledParagraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_edefe :=ctx ;var _bddg []*Block ;_defc :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _fbfca ._cdcbf .IsRelative (){ctx .X +=_fbfca ._ggdg .Left ;ctx .Y +=_fbfca ._ggdg .Top ;
ctx .Width -=_fbfca ._ggdg .Left +_fbfca ._ggdg .Right ;ctx .Height -=_fbfca ._ggdg .Top +_fbfca ._ggdg .Bottom ;_fbfca .SetWidth (ctx .Width );}else {if int (_fbfca ._cdcee )<=0{_fbfca .SetWidth (_fbfca .getTextWidth ());};ctx .X =_fbfca ._bdfd ;ctx .Y =_fbfca ._gaba ;
};if _fbfca ._adfc !=nil {_fbfca ._adfc (_fbfca ,ctx );};if _gdbac :=_fbfca .wrapText ();_gdbac !=nil {return nil ,ctx ,_gdbac ;};_cdab :=_fbfca ._faaf ;for {_dbeb ,_dbfg ,_gdafa :=_efea (_defc ,_fbfca ,_cdab ,ctx );if _gdafa !=nil {_ff .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_gdafa );
return nil ,ctx ,_gdafa ;};ctx =_dbeb ;_bddg =append (_bddg ,_defc );if _cdab =_dbfg ;len (_dbfg )==0{break ;};_defc =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_dbeb =ctx ;_dbeb .Y =ctx .Margins .Top ;_dbeb .X =ctx .Margins .Left +_fbfca ._ggdg .Left ;
_dbeb .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_fbfca ._ggdg .Bottom ;_dbeb .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_fbfca ._ggdg .Left -_fbfca ._ggdg .Right ;ctx =_dbeb ;};if _fbfca ._cdcbf .IsRelative (){ctx .X -=_fbfca ._ggdg .Left ;
ctx .Width =_edefe .Width ;return _bddg ,ctx ,nil ;};return _bddg ,_edefe ,nil ;};

// SetColorBottom sets border color for bottom.
func (_gaa *border )SetColorBottom (col Color ){_gaa ._fbc =col };func _dbdb (_dcadb [][]_fd .Point )*Polygon {return &Polygon {_aaff :&_fd .Polygon {Points :_dcadb },_aceae :1.0,_gafa :1.0};};

// NewStyledParagraph creates a new styled paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_cbc *Creator )NewStyledParagraph ()*StyledParagraph {return _addb (_cbc .NewTextStyle ())};var PPMM =float64 (72*1.0/25.4);func (_abgbg *TOCLine )prepareParagraph (_cdef *StyledParagraph ,_fega DrawContext ){_gfae :=_abgbg .Title .Text ;if _abgbg .Number .Text !=""{_gfae ="\u0020"+_gfae ;
};_gfae +="\u0020";_edgd :=_abgbg .Page .Text ;if _edgd !=""{_edgd ="\u0020"+_edgd ;};_cdef ._ggfd =[]*TextChunk {{Text :_abgbg .Number .Text ,Style :_abgbg .Number .Style ,_fbdcc :_abgbg .getLineLink ()},{Text :_gfae ,Style :_abgbg .Title .Style ,_fbdcc :_abgbg .getLineLink ()},{Text :_edgd ,Style :_abgbg .Page .Style ,_fbdcc :_abgbg .getLineLink ()}};
_cdef .wrapText ();_fgdcd :=len (_cdef ._faaf );if _fgdcd ==0{return ;};_egdd :=_fega .Width *1000-_cdef .getTextLineWidth (_cdef ._faaf [_fgdcd -1]);_adcda :=_cdef .getTextLineWidth ([]*TextChunk {&_abgbg .Separator });_bgacg :=int (_egdd /_adcda );_gacdc :=_fg .Repeat (_abgbg .Separator .Text ,_bgacg );
_dbffg :=_abgbg .Separator .Style ;_bfcd :=_cdef .Insert (2,_gacdc );_bfcd .Style =_dbffg ;_bfcd ._fbdcc =_abgbg .getLineLink ();_egdd =_egdd -float64 (_bgacg )*_adcda ;if _egdd > 500{_befdc ,_cgfa :=_dbffg .Font .GetRuneMetrics (' ');if _cgfa &&_egdd > _befdc .Wx {_ggfa :=int (_egdd /_befdc .Wx );
if _ggfa > 0{_fedf :=_dbffg ;_fedf .FontSize =1;_bfcd =_cdef .Insert (2,_fg .Repeat ("\u0020",_ggfa ));_bfcd .Style =_fedf ;_bfcd ._fbdcc =_abgbg .getLineLink ();};};};};

// Length calculates and returns the line length.
func (_gdgg *Line )Length ()float64 {return _aa .Sqrt (_aa .Pow (_gdgg ._eddf -_gdgg ._bfge ,2.0)+_aa .Pow (_gdgg ._caee -_gdgg ._afbb ,2.0));};

// SetVerticalAlignment set the cell's vertical alignment of content.
// Can be one of:
// - CellHorizontalAlignmentTop
// - CellHorizontalAlignmentMiddle
// - CellHorizontalAlignmentBottom
func (_babe *TableCell )SetVerticalAlignment (valign CellVerticalAlignment ){_babe ._bbag =valign };

// GetMargins returns the Chapter's margin: left, right, top, bottom.
func (_cbg *Chapter )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _cbg ._caaa .Left ,_cbg ._caaa .Right ,_cbg ._caaa .Top ,_cbg ._caaa .Bottom ;};

// IsAbsolute checks if the positioning is absolute.
func (_ccb Positioning )IsAbsolute ()bool {return _ccb ==PositionAbsolute };

// Width returns the current page width.
func (_cggea *Creator )Width ()float64 {return _cggea ._aeg };

// SetLineOpacity sets the line opacity.
func (_eagbd *Polyline )SetLineOpacity (opacity float64 ){_eagbd ._afae =opacity };func _ca (_acc *_da .ContentStreamOperations ,_fdfb *_afd .PdfPageResources ,_geg *_da .ContentStreamOperations ,_gbe *_afd .PdfPageResources )error {_ace :=map[_c .PdfObjectName ]_c .PdfObjectName {};
_fgdd :=map[_c .PdfObjectName ]_c .PdfObjectName {};_gda :=map[_c .PdfObjectName ]_c .PdfObjectName {};_dce :=map[_c .PdfObjectName ]_c .PdfObjectName {};_abeb :=map[_c .PdfObjectName ]_c .PdfObjectName {};_cde :=map[_c .PdfObjectName ]_c .PdfObjectName {};
for _ ,_fbe :=range *_geg {switch _fbe .Operand {case "\u0044\u006f":if len (_fbe .Params )==1{if _dda ,_cag :=_fbe .Params [0].(*_c .PdfObjectName );_cag {if _ ,_bce :=_ace [*_dda ];!_bce {var _adaf _c .PdfObjectName ;_bdf ,_ :=_gbe .GetXObjectByName (*_dda );
if _bdf !=nil {_adaf =*_dda ;for {_afgd ,_ :=_fdfb .GetXObjectByName (_adaf );if _afgd ==nil ||_afgd ==_bdf {break ;};_adaf =_adaf +"\u0030";};};_fdfb .SetXObjectByName (_adaf ,_bdf );_ace [*_dda ]=_adaf ;};_adg :=_ace [*_dda ];_fbe .Params [0]=&_adg ;
};};case "\u0054\u0066":if len (_fbe .Params )==2{if _ecc ,_fdge :=_fbe .Params [0].(*_c .PdfObjectName );_fdge {if _ ,_cef :=_fgdd [*_ecc ];!_cef {_eda ,_dec :=_gbe .GetFontByName (*_ecc );_cge :=*_ecc ;if _dec &&_eda !=nil {_cge =_dde (_ecc .String (),_eda ,_fdfb );
};_fdfb .SetFontByName (_cge ,_eda );_fgdd [*_ecc ]=_cge ;};_cded :=_fgdd [*_ecc ];_fbe .Params [0]=&_cded ;};};case "\u0043\u0053","\u0063\u0073":if len (_fbe .Params )==1{if _gdaf ,_bab :=_fbe .Params [0].(*_c .PdfObjectName );_bab {if _ ,_ddb :=_gda [*_gdaf ];
!_ddb {var _ecf _c .PdfObjectName ;_adb ,_bgc :=_gbe .GetColorspaceByName (*_gdaf );if _bgc {_ecf =*_gdaf ;for {_ggda ,_cagc :=_fdfb .GetColorspaceByName (_ecf );if !_cagc ||_adb ==_ggda {break ;};_ecf =_ecf +"\u0030";};_fdfb .SetColorspaceByName (_ecf ,_adb );
_gda [*_gdaf ]=_ecf ;}else {_ff .Log .Debug ("C\u006fl\u006f\u0072\u0073\u0070\u0061\u0063\u0065\u0020n\u006f\u0074\u0020\u0066ou\u006e\u0064");};};if _egfad ,_fcf :=_gda [*_gdaf ];_fcf {_fbe .Params [0]=&_egfad ;}else {_ff .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0043\u006f\u006co\u0072\u0073\u0070\u0061\u0063\u0065\u0020%\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064",*_gdaf );
};};};case "\u0053\u0043\u004e","\u0073\u0063\u006e":if len (_fbe .Params )==1{if _gccd ,_cbf :=_fbe .Params [0].(*_c .PdfObjectName );_cbf {if _ ,_gbfe :=_dce [*_gccd ];!_gbfe {var _dbf _c .PdfObjectName ;_bbf ,_aee :=_gbe .GetPatternByName (*_gccd );
if _aee {_dbf =*_gccd ;for {_dee ,_gab :=_fdfb .GetPatternByName (_dbf );if !_gab ||_dee ==_bbf {break ;};_dbf =_dbf +"\u0030";};_abb :=_fdfb .SetPatternByName (_dbf ,_bbf .ToPdfObject ());if _abb !=nil {return _abb ;};_dce [*_gccd ]=_dbf ;};};if _bgd ,_gabf :=_dce [*_gccd ];
_gabf {_fbe .Params [0]=&_bgd ;};};};case "\u0073\u0068":if len (_fbe .Params )==1{if _ecd ,_beff :=_fbe .Params [0].(*_c .PdfObjectName );_beff {if _ ,_aecd :=_abeb [*_ecd ];!_aecd {var _gbeg _c .PdfObjectName ;_eag ,_gfb :=_gbe .GetShadingByName (*_ecd );
if _gfb {_gbeg =*_ecd ;for {_deea ,_egd :=_fdfb .GetShadingByName (_gbeg );if !_egd ||_eag ==_deea {break ;};_gbeg =_gbeg +"\u0030";};_bcf :=_fdfb .SetShadingByName (_gbeg ,_eag .ToPdfObject ());if _bcf !=nil {_ff .Log .Debug ("E\u0052\u0052\u004f\u0052 S\u0065t\u0020\u0073\u0068\u0061\u0064i\u006e\u0067\u003a\u0020\u0025\u0076",_bcf );
return _bcf ;};_abeb [*_ecd ]=_gbeg ;}else {_ff .Log .Debug ("\u0053\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};};if _gbc ,_ddbf :=_abeb [*_ecd ];_ddbf {_fbe .Params [0]=&_gbc ;}else {_ff .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020S\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u0025\u0073 \u006e\u006f\u0074 \u0066o\u0075\u006e\u0064",*_ecd );
};};};case "\u0067\u0073":if len (_fbe .Params )==1{if _gfbb ,_bba :=_fbe .Params [0].(*_c .PdfObjectName );_bba {if _ ,_adbb :=_cde [*_gfbb ];!_adbb {var _befd _c .PdfObjectName ;_gff ,_ddc :=_gbe .GetExtGState (*_gfbb );if _ddc {_befd =*_gfbb ;_dab :=1;
for {_bag ,_gea :=_fdfb .GetExtGState (_befd );if !_gea ||_gff ==_bag {break ;};_befd =_c .PdfObjectName (_ec .Sprintf ("\u0047\u0053\u0025\u0064",_dab ));_dab ++;};};_fdfb .AddExtGState (_befd ,_gff );_cde [*_gfbb ]=_befd ;};_cgc :=_cde [*_gfbb ];_fbe .Params [0]=&_cgc ;
};};};*_acc =append (*_acc ,_fbe );};return nil ;};func (_ebeb *List )tableHeight (_aabb float64 )float64 {var _ffef float64 ;for _ ,_fedd :=range _ebeb ._bage {switch _bafc :=_fedd ._cffg .(type ){case *Paragraph :_abab :=_bafc ;if _abab ._fceb {_abab .SetWidth (_aabb );
};_ffef +=_abab .Height ()+_abab ._fegc .Bottom +_abab ._fegc .Bottom ;_ffef +=0.5*_abab ._afec *_abab ._ffdf ;case *StyledParagraph :_ggga :=_bafc ;if _ggga ._beab {_ggga .SetWidth (_aabb );};_ffef +=_ggga .Height ()+_ggga ._ggdg .Top +_ggga ._ggdg .Bottom ;
_ffef +=0.5*_ggga .getTextHeight ();default:_ffef +=_fedd ._cffg .Height ();};};return _ffef ;};const (HorizontalAlignmentLeft HorizontalAlignment =iota ;HorizontalAlignmentCenter ;HorizontalAlignmentRight ;);

// Context returns the current drawing context.
func (_ggbe *Creator )Context ()DrawContext {return _ggbe ._gbgd };

// SetColorLeft sets border color for left.
func (_caa *border )SetColorLeft (col Color ){_caa ._cdd =col };

// Height returns the total height of all rows.
func (_egda *Table )Height ()float64 {_cffd :=float64 (0.0);for _ ,_ggag :=range _egda ._aedeb {_cffd +=_ggag ;};return _cffd ;};func (_bbda *StyledParagraph )getTextHeight ()float64 {var _eebg float64 ;for _ ,_gebcc :=range _bbda ._ggfd {_efbdf :=_gebcc .Style .FontSize *_bbda ._baega ;
if _efbdf > _eebg {_eebg =_efbdf ;};};return _eebg ;};func (_afc *InvoiceAddress )fmtLine (_dbbg ,_gebg string ,_gacc bool )string {if _gacc {_gebg ="";};return _ec .Sprintf ("\u0025\u0073\u0025s\u000a",_gebg ,_dbbg );};

// StyledParagraph represents text drawn with a specified font and can wrap across lines and pages.
// By default occupies the available width in the drawing context.
type StyledParagraph struct{_ggfd []*TextChunk ;_eaba TextStyle ;_eggec TextStyle ;_aeea TextAlignment ;_baega float64 ;_beab bool ;_cdcee float64 ;_edaa bool ;_geba float64 ;_ggdg Margins ;_cdcbf Positioning ;_bdfd float64 ;_gaba float64 ;_fgbf float64 ;
_acdc float64 ;_faaf [][]*TextChunk ;_adfc func (_fecd *StyledParagraph ,_dage DrawContext );};

// SetColor sets the line color.
func (_fgddd *Curve )SetColor (col Color ){_fgddd ._cbaa =col };

// SetBorderWidth sets the border width.
func (_ffgec *Polygon )SetBorderWidth (borderWidth float64 ){_ffgec ._aaff .BorderWidth =borderWidth };

// GeneratePageBlocks draws the curve onto page blocks.
func (_ecgc *Curve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fcab :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_agdf :=_da .NewContentCreator ();_agdf .Add_q ().Add_w (_ecgc ._bcdg ).SetStrokingColor (_bff (_ecgc ._cbaa )).Add_m (_ecgc ._efcd ,ctx .PageHeight -_ecgc ._eggc ).Add_v (_ecgc ._faec ,ctx .PageHeight -_ecgc ._cba ,_ecgc ._eceg ,ctx .PageHeight -_ecgc ._bbfbe ).Add_S ().Add_Q ();
_debf :=_fcab .addContentsByString (_agdf .String ());if _debf !=nil {return nil ,ctx ,_debf ;};return []*Block {_fcab },ctx ,nil ;};

// AddAnnotation adds an annotation to the current block.
// The annotation will be added to the page the block will be rendered on.
func (_be *Block )AddAnnotation (annotation *_afd .PdfAnnotation ){for _ ,_dc :=range _be ._ad {if _dc ==annotation {return ;};};_be ._ad =append (_be ._ad ,annotation );};

// NewImageFromFile creates an Image from a file.
func (_eadd *Creator )NewImageFromFile (path string )(*Image ,error ){return _acced (path )};

// NewStyledTOCLine creates a new table of contents line with the provided style.
func (_bgg *Creator )NewStyledTOCLine (number ,title ,page TextChunk ,level uint ,style TextStyle )*TOCLine {return _ebbc (number ,title ,page ,level ,style );};

// SetColorTop sets border color for top.
func (_gdf *border )SetColorTop (col Color ){_gdf ._dcg =col };func _efea (_dagef *Block ,_dgfe *StyledParagraph ,_edaab [][]*TextChunk ,_bfdfea DrawContext )(DrawContext ,[][]*TextChunk ,error ){_gcfd :=1;_bgac :=_c .PdfObjectName (_ec .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_gcfd ));
for _dagef ._cf .HasFontByName (_bgac ){_gcfd ++;_bgac =_c .PdfObjectName (_ec .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_gcfd ));};_gfbc :=_dagef ._cf .SetFontByName (_bgac ,_dgfe ._eaba .Font .ToPdfObject ());if _gfbc !=nil {return _bfdfea ,nil ,_gfbc ;
};_gcfd ++;_afcb :=_bgac ;_fage :=_dgfe ._eaba .FontSize ;_eddfc :=_dgfe ._cdcbf .IsRelative ();var _gcfb [][]_c .PdfObjectName ;var _degd float64 ;var _ebbe [][]*TextChunk ;var _edda float64 ;for _ggcc ,_gagec :=range _edaab {var _bcbfb []_c .PdfObjectName ;
var _dbae float64 ;for _ ,_ebbea :=range _gagec {_bbcd :=_ebbea .Style ;if _ggcc ==0&&_bbcd .FontSize > _degd {_degd =_bbcd .FontSize ;};if _bbcd .FontSize > _dbae {_dbae =_bbcd .FontSize ;};_bgac =_c .PdfObjectName (_ec .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_gcfd ));
_eebbd :=_dagef ._cf .SetFontByName (_bgac ,_bbcd .Font .ToPdfObject ());if _eebbd !=nil {return _bfdfea ,nil ,_eebbd ;};_bcbfb =append (_bcbfb ,_bgac );_gcfd ++;};_dbae *=_dgfe ._baega ;if _eddfc &&_edda +_dbae > _bfdfea .Height {_ebbe =_edaab [_ggcc :];
_edaab =_edaab [:_ggcc ];break ;};_edda +=_dbae ;_gcfb =append (_gcfb ,_bcbfb );};_ddfa :=_da .NewContentCreator ();_ddfa .Add_q ();_bdad :=_bfdfea .PageHeight -_bfdfea .Y -_degd *_dgfe ._baega ;_ddfa .Translate (_bfdfea .X ,_bdad );_eecfa :=_bdad ;if _dgfe ._geba !=0{_ddfa .RotateDeg (_dgfe ._geba );
};_ddfa .Add_BT ();var _gbaa []*_fd .BasicLine ;for _fdbaf ,_bece :=range _edaab {_bbdbf :=_bfdfea .X ;if _fdbaf !=0{_ddfa .Add_Tstar ();};_ggcea :=_fdbaf ==len (_edaab )-1;var (_fbab float64 ;_cfbe float64 ;_affgb float64 ;_aeeba uint ;);var _baga []float64 ;
for _ ,_cbgff :=range _bece {_aagd :=&_cbgff .Style ;if _aagd .FontSize > _cfbe {_cfbe =_aagd .FontSize ;};_aeag ,_ccae :=_aagd .Font .GetRuneMetrics (' ');if !_ccae {return _bfdfea ,nil ,_a .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");
};var _gfefc uint ;var _gacde float64 ;_fdbb :=len (_cbgff .Text );for _adgdg ,_acfdb :=range _cbgff .Text {if _acfdb ==' '{_gfefc ++;continue ;};if _acfdb =='\u000A'{continue ;};_adde ,_fgff :=_aagd .Font .GetRuneMetrics (_acfdb );if !_fgff {_ff .Log .Debug ("\u0055\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006ee\u0020%\u0076\u0020\u0069\u006e\u0020\u0066\u006fn\u0074\u000a",_acfdb );
return _bfdfea ,nil ,_a .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");};_gacde +=_aagd .FontSize *_adde .Wx ;if _adgdg !=_fdbb -1{_gacde +=_aagd .CharSpacing *1000.0;};};_baga =append (_baga ,_gacde );
_fbab +=_gacde ;_affgb +=float64 (_gfefc )*_aeag .Wx *_aagd .FontSize ;_aeeba +=_gfefc ;};_cfbe *=_dgfe ._baega ;var _dcfd []_c .PdfObject ;_fffa :=_dgfe ._cdcee *1000.0;if _dgfe ._aeea ==TextAlignmentJustify {if _aeeba > 0&&!_ggcea {_affgb =(_fffa -_fbab )/float64 (_aeeba )/_fage ;
};}else if _dgfe ._aeea ==TextAlignmentCenter {_daag :=(_fffa -_fbab -_affgb )/2;_caaca :=_daag /_fage ;_dcfd =append (_dcfd ,_c .MakeFloat (-_caaca ));_bbdbf +=_daag /1000.0;}else if _dgfe ._aeea ==TextAlignmentRight {_cega :=(_fffa -_fbab -_affgb );_eage :=_cega /_fage ;
_dcfd =append (_dcfd ,_c .MakeFloat (-_eage ));_bbdbf +=_cega /1000.0;};if len (_dcfd )> 0{_ddfa .Add_Tf (_afcb ,_fage ).Add_TL (_fage *_dgfe ._baega ).Add_TJ (_dcfd ...);};var _ccbf float64 ;for _eeecf ,_gffdb :=range _bece {_eega :=&_gffdb .Style ;if _eega .FontSize > _ccbf {_ccbf =_eega .FontSize ;
};_geaca :=_afcb ;_bcg :=_fage ;_bfdfb :=_eega .OutlineColor !=nil ;_ggfda :=_eega .OutlineSize !=1;if _ggfda {_ddfa .Add_w (_eega .OutlineSize );};_decc :=_eega .RenderingMode !=TextRenderingModeFill ;if _decc {_ddfa .Add_Tr (int64 (_eega .RenderingMode ));
};_edeg :=_eega .CharSpacing !=0;if _edeg {_ddfa .Add_Tc (_eega .CharSpacing );};_agbd :=_eega .TextRise !=0;if _agbd {_ddfa .Add_Ts (_eega .TextRise );};if _dgfe ._aeea !=TextAlignmentJustify ||_ggcea {_fgea ,_dgabc :=_eega .Font .GetRuneMetrics (' ');
if !_dgabc {return _bfdfea ,nil ,_a .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};_geaca =_gcfb [_fdbaf ][_eeecf ];_bcg =_eega .FontSize ;
_affgb =_fgea .Wx ;};_fefb :=_eega .Font .Encoder ();var _faad []byte ;for _ ,_bgfb :=range _gffdb .Text {if _bgfb =='\u000A'{continue ;};if _bgfb ==' '{if len (_faad )> 0{if _bfdfb {_ddfa .SetStrokingColor (_bff (_eega .OutlineColor ));};_ddfa .SetNonStrokingColor (_bff (_eega .Color )).Add_Tf (_gcfb [_fdbaf ][_eeecf ],_eega .FontSize ).Add_TJ ([]_c .PdfObject {_c .MakeStringFromBytes (_faad )}...);
_faad =nil ;};_ddfa .Add_Tf (_geaca ,_bcg ).Add_TJ ([]_c .PdfObject {_c .MakeFloat (-_affgb )}...);_baga [_eeecf ]+=_affgb *_bcg ;}else {if _ ,_fcbe :=_fefb .RuneToCharcode (_bgfb );!_fcbe {_ff .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_bgfb ,_bgfb );
continue ;};_faad =append (_faad ,_fefb .Encode (string (_bgfb ))...);};};if len (_faad )> 0{if _bfdfb {_ddfa .SetStrokingColor (_bff (_eega .OutlineColor ));};_ddfa .SetNonStrokingColor (_bff (_eega .Color )).Add_Tf (_gcfb [_fdbaf ][_eeecf ],_eega .FontSize ).Add_TJ ([]_c .PdfObject {_c .MakeStringFromBytes (_faad )}...);
};_bdebfg :=_baga [_eeecf ]/1000.0;if _eega .Underline {_beeb :=_eega .UnderlineStyle .Color ;if _beeb ==nil {_beeb =_gffdb .Style .Color ;};_aagaf ,_cafc ,_gfcbg :=_beeb .ToRGB ();_beac :=_bbdbf -_bfdfea .X ;_eagdc :=_eecfa -_bdad +_eega .TextRise -_eega .UnderlineStyle .Offset ;
_gbaa =append (_gbaa ,&_fd .BasicLine {X1 :_beac ,Y1 :_eagdc ,X2 :_beac +_bdebfg ,Y2 :_eagdc ,LineWidth :_gffdb .Style .UnderlineStyle .Thickness ,LineColor :_afd .NewPdfColorDeviceRGB (_aagaf ,_cafc ,_gfcbg )});};if _gffdb ._fbdcc !=nil {var _eaac *_c .PdfObjectArray ;
if !_gffdb ._gegc {switch _bggg :=_gffdb ._fbdcc .GetContext ().(type ){case *_afd .PdfAnnotationLink :_eaac =_c .MakeArray ();_bggg .Rect =_eaac ;_dfdb ,_gcbc :=_bggg .Dest .(*_c .PdfObjectArray );if _gcbc &&_dfdb .Len ()==5{_ebcb ,_geeg :=_dfdb .Get (1).(*_c .PdfObjectName );
if _geeg &&_ebcb .String ()=="\u0058\u0059\u005a"{_efca ,_adbd :=_c .GetNumberAsFloat (_dfdb .Get (3));if _adbd ==nil {_dfdb .Set (3,_c .MakeFloat (_bfdfea .PageHeight -_efca ));};};};};_gffdb ._gegc =true ;};if _eaac !=nil {_ebdb :=_fd .NewPoint (_bbdbf -_bfdfea .X ,_eecfa +_eega .TextRise -_bdad ).Rotate (_dgfe ._geba );
_ebdb .X +=_bfdfea .X ;_ebdb .Y +=_bdad ;_efeac ,_gbac ,_becdfe ,_abgbd :=_agdcd (_bdebfg ,_cfbe ,_dgfe ._geba );_ebdb .X +=_efeac ;_ebdb .Y +=_gbac ;_eaac .Clear ();_eaac .Append (_c .MakeFloat (_ebdb .X ));_eaac .Append (_c .MakeFloat (_ebdb .Y ));_eaac .Append (_c .MakeFloat (_ebdb .X +_becdfe ));
_eaac .Append (_c .MakeFloat (_ebdb .Y +_abgbd ));};_dagef .AddAnnotation (_gffdb ._fbdcc );};_bbdbf +=_bdebfg ;if _ggfda {_ddfa .Add_w (1.0);};if _bfdfb {_ddfa .Add_RG (0.0,0.0,0.0);};if _decc {_ddfa .Add_Tr (int64 (TextRenderingModeFill ));};if _edeg {_ddfa .Add_Tc (0);
};if _agbd {_ddfa .Add_Ts (0);};};_ddfa .Add_TL (_ccbf *_dgfe ._baega );_eecfa -=_cfbe ;};_ddfa .Add_ET ();for _ ,_aaca :=range _gbaa {_ddfa .SetStrokingColor (_aaca .LineColor ).Add_w (_aaca .LineWidth ).Add_m (_aaca .X1 ,_aaca .Y1 ).Add_l (_aaca .X2 ,_aaca .Y2 ).Add_s ();
};_ddfa .Add_Q ();_defcg :=_ddfa .Operations ();_defcg .WrapIfNeeded ();_dagef .addContents (_defcg );if _eddfc {_eacc :=_edda +_dgfe ._ggdg .Bottom ;_bfdfea .Y +=_eacc ;_bfdfea .Height -=_eacc ;if _bfdfea .Inline {_bfdfea .X +=_dgfe .Width ()+_dgfe ._ggdg .Right ;
};};return _bfdfea ,_ebbe ,nil ;};

// Finalize renders all blocks to the creator pages. In addition, it takes care
// of adding headers and footers, as well as generating the front page,
// table of contents and outlines.
// Finalize is automatically called before writing the document out. Calling the
// method manually can be useful when adding external pages to the creator,
// using the AddPage method, as it renders all creator blocks to the added
// pages, without having to write the document out.
// NOTE: TOC and outlines are generated only if the AddTOC and AddOutlines
// fields of the creator are set to true (enabled by default). Furthermore, TOCs
// and outlines without content are skipped. TOC and outline content is
// added automatically when using the chapter component. TOCs and outlines can
// also be set externally, using the SetTOC and SetOutlineTree methods.
// Finalize should only be called once, after all draw calls have taken place,
// as it will return immediately if the creator instance has been finalized.
func (_cdac *Creator )Finalize ()error {if _cdac ._ggeb {return nil ;};_gbge :=len (_cdac ._gef );_ddae :=0;if _cdac ._dfb !=nil {_ddae ++;};if _cdac .AddTOC {_cdac .initContext ();_cdac ._gbgd .Page =_ddae +1;if _cdac ._cgf !=nil {if _ddea :=_cdac ._cgf (_cdac ._feg );
_ddea !=nil {return _ddea ;};};_bafg ,_ ,_dafa :=_cdac ._feg .GeneratePageBlocks (_cdac ._gbgd );if _dafa !=nil {_ff .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073: \u0025\u0076",_dafa );
return _dafa ;};_ddae +=len (_bafg );_dge :=_cdac ._feg .Lines ();for _ ,_egfe :=range _dge {_cfcd ,_ecda :=_e .Atoi (_egfe .Page .Text );if _ecda !=nil {continue ;};_egfe .Page .Text =_e .Itoa (_cfcd +_ddae );};};_fbfc :=false ;if _cdac ._dfb !=nil {_gbge ++;
_eeea :=_cdac .newPage ();_cdac ._gef =append ([]*_afd .PdfPage {_eeea },_cdac ._gef ...);_cdac .setActivePage (_eeea );_fgec :=FrontpageFunctionArgs {PageNum :1,TotalPages :_gbge };_cdac ._dfb (_fgec );_fbfc =true ;};if _cdac .AddTOC {_cdac .initContext ();
if _cdac ._cgf !=nil {if _gfca :=_cdac ._cgf (_cdac ._feg );_gfca !=nil {_ff .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074i\u006e\u0067\u0020\u0054\u004f\u0043\u003a\u0020\u0025\u0076",_gfca );return _gfca ;};};
_dggg :=_cdac ._feg .Lines ();for _ ,_dgdc :=range _dggg {_dgdc ._eeddeg +=int64 (_ddae );};var _gegdf []*_afd .PdfPage ;_dcdf ,_ ,_ :=_cdac ._feg .GeneratePageBlocks (_cdac ._gbgd );for _ ,_abag :=range _dcdf {_abag .SetPos (0,0);_gbge ++;_cac :=_cdac .newPage ();
_gegdf =append (_gegdf ,_cac );_cdac .setActivePage (_cac );_cdac .Draw (_abag );};if _fbfc {_badd :=_cdac ._gef [0];_fdfc :=_cdac ._gef [1:];_cdac ._gef =append ([]*_afd .PdfPage {_badd },_gegdf ...);_cdac ._gef =append (_cdac ._gef ,_fdfc ...);}else {_cdac ._gef =append (_gegdf ,_cdac ._gef ...);
};};if _cdac ._gbed !=nil &&_cdac .AddOutlines {var _baff func (_bgcd *_afd .OutlineItem );_baff =func (_dacb *_afd .OutlineItem ){_dacb .Dest .Page +=int64 (_ddae );if _bcbb :=int (_dacb .Dest .Page );_bcbb >=0&&_bcbb < len (_cdac ._gef ){_dacb .Dest .PageObj =_cdac ._gef [_bcbb ].GetPageAsIndirectObject ();
}else {_ff .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_bcbb );
};_dacb .Dest .Y =_cdac ._eadf -_dacb .Dest .Y ;_baa :=_dacb .Items ();for _ ,_fgfg :=range _baa {_baff (_fgfg );};};_aaf :=_cdac ._gbed .Items ();for _ ,_caac :=range _aaf {_baff (_caac );};if _cdac .AddTOC {var _agd int ;if _fbfc {_agd =1;};_bbd :=_afd .NewOutlineDest (int64 (_agd ),0,_cdac ._eadf );
if _agd >=0&&_agd < len (_cdac ._gef ){_bbd .PageObj =_cdac ._gef [_agd ].GetPageAsIndirectObject ();}else {_ff .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_agd );
};_cdac ._gbed .Insert (0,_afd .NewOutlineItem ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073",_bbd ));};};for _aaece ,_ecdb :=range _cdac ._gef {_cdac .setActivePage (_ecdb );if _cdac ._egde !=nil {_caca :=NewBlock (_cdac ._aeg ,_cdac ._cce .Top );
_fada :=HeaderFunctionArgs {PageNum :_aaece +1,TotalPages :_gbge };_cdac ._egde (_caca ,_fada );_caca .SetPos (0,0);if _bae :=_cdac .Draw (_caca );_bae !=nil {_ff .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0068e\u0061\u0064\u0065\u0072\u003a\u0020\u0025v",_bae );
return _bae ;};};if _cdac ._fad !=nil {_afdc :=NewBlock (_cdac ._aeg ,_cdac ._cce .Bottom );_daae :=FooterFunctionArgs {PageNum :_aaece +1,TotalPages :_gbge };_cdac ._fad (_afdc ,_daae );_afdc .SetPos (0,_cdac ._eadf -_afdc ._gg );if _cdee :=_cdac .Draw (_afdc );
_cdee !=nil {_ff .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0066o\u006f\u0074\u0065\u0072\u003a\u0020\u0025v",_cdee );return _cdee ;};};_cedf ,_cbdg :=_cdac ._bffa [_ecdb ];if !_cbdg {continue ;};if _cgca ,_eea :=_cdac ._gcgg [_ecdb ];
_eea {_cedf .transform (_cgca );};if _cged :=_cedf .drawToPage (_ecdb );_cged !=nil {_ff .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069\u006e\u0067\u0020\u0070\u0061\u0067\u0065\u0020%\u0064\u0020\u0062\u006c\u006f\u0063\u006bs\u003a\u0020\u0025\u0076",_aaece +1,_cged );
return _cged ;};};_cdac ._ggeb =true ;return nil ;};func (_dcbd *Paragraph )getMaxLineWidth ()float64 {if _dcbd ._eedde ==nil ||len (_dcbd ._eedde )==0{_dcbd .wrapText ();};var _bdgdc float64 ;for _ ,_dedcc :=range _dcbd ._eedde {_gcdd :=_dcbd .getTextLineWidth (_dedcc );
if _gcdd > _bdgdc {_bdgdc =_gcdd ;};};return _bdgdc ;};func _bff (_gafc Color )_afd .PdfColor {if _gafc ==nil {_gafc =ColorBlack ;};switch _efaff :=_gafc .(type ){case cmykColor :return _afd .NewPdfColorDeviceCMYK (_efaff ._fdgea ,_efaff ._gebe ,_efaff ._ggb ,_efaff ._dagd );
};return _afd .NewPdfColorDeviceRGB (_gafc .ToRGB ());};

// NewCell makes a new cell and inserts it into the table at the current position.
func (_ebff *Table )NewCell ()*TableCell {return _ebff .newCell (1)};

// SetBorderWidth sets the border width.
func (_becbb *Rectangle )SetBorderWidth (bw float64 ){_becbb ._bafe =bw };func _dbg (_eeef ,_edb ,_fcc ,_fdb float64 )*border {_dad :=&border {};_dad ._dae =_eeef ;_dad ._dgaf =_edb ;_dad ._acea =_fcc ;_dad ._bcc =_fdb ;_dad ._dcg =ColorBlack ;_dad ._fbc =ColorBlack ;
_dad ._cdd =ColorBlack ;_dad ._dcbg =ColorBlack ;_dad ._efa =0;_dad ._deb =0;_dad ._eec =0;_dad ._beb =0;_dad .LineStyle =_fd .LineStyleSolid ;return _dad ;};func _gaeg (_fgg string ,_efdbg ,_fbgg TextStyle )*TOC {_beeaf :=_fbgg ;_beeaf .FontSize =14;_cfdad :=_addb (_beeaf );
_cfdad .SetEnableWrap (true );_cfdad .SetTextAlignment (TextAlignmentLeft );_cfdad .SetMargins (0,0,0,5);_adga :=_cfdad .Append (_fgg );_adga .Style =_beeaf ;return &TOC {_bcge :_cfdad ,_bgeda :[]*TOCLine {},_bcbdg :_efdbg ,_fcdb :_efdbg ,_bddde :_efdbg ,_adef :_efdbg ,_fcbf :"\u002e",_acbcb :10,_ffcd :Margins {0,0,2,2},_bccd :PositionRelative ,_bbgb :_efdbg ,_gega :true };
};

// SetLogo sets the logo of the invoice.
func (_abebf *Invoice )SetLogo (logo *Image ){_abebf ._aded =logo };func (_fafc *Table )resetColumnWidths (){_fafc ._eabc =[]float64 {};_aeac :=float64 (1.0)/float64 (_fafc ._fceeb );for _efdb :=0;_efdb < _fafc ._fceeb ;_efdb ++{_fafc ._eabc =append (_fafc ._eabc ,_aeac );
};};

// AddPage adds the specified page to the creator.
// NOTE: If the page has a Rotate flag, the creator will take care of
// transforming the contents to maintain the correct orientation.
func (_bged *Creator )AddPage (page *_afd .PdfPage )error {_dgdg ,_eeb :=page .GetMediaBox ();if _eeb !=nil {_ff .Log .Debug ("\u0046\u0061\u0069l\u0065\u0064\u0020\u0074o\u0020\u0067\u0065\u0074\u0020\u0070\u0061g\u0065\u0020\u006d\u0065\u0064\u0069\u0061\u0062\u006f\u0078\u003a\u0020\u0025\u0076",_eeb );
return _eeb ;};_dgdg .Normalize ();_eff ,_cae :=_dgdg .Llx ,_dgdg .Lly ;_afgdb :=_ab .IdentityMatrix ();_ddeg :=page .Rotate ;_ccda :=_ddeg !=nil &&*_ddeg %360!=0&&*_ddeg %90==0;if _ccda {_aca :=float64 ((360+*page .Rotate %360)%360);if _aca ==90{_afgdb =_afgdb .Translate (_dgdg .Width (),0);
}else if _aca ==180{_afgdb =_afgdb .Translate (_dgdg .Width (),_dgdg .Height ());}else if _aca ==270{_afgdb =_afgdb .Translate (0,_dgdg .Height ());};_afgdb =_afgdb .Mult (_ab .RotationMatrix (_aca *_aa .Pi /180));_afgdb =_afgdb .Round (0.000001);_gfde :=_baee (_dgdg ,_afgdb );
_dgdg =_gfde ;_dgdg .Normalize ();};if _eff !=0||_cae !=0{_afgdb =_ab .TranslationMatrix (_eff ,_cae ).Mult (_afgdb );};if !_afgdb .Identity (){if _bged ._gcgg ==nil {_bged ._gcgg =map[*_afd .PdfPage ]_ab .Matrix {};};_afgdb =_afgdb .Round (0.000001);_bged ._gcgg [page ]=_afgdb ;
};_bged ._aeg =_dgdg .Width ();_bged ._eadf =_dgdg .Height ();_bged .initContext ();_bged ._gef =append (_bged ._gef ,page );_bged ._gbgd .Page ++;return nil ;};func (_ccdca *Invoice )generateLineBlocks (_fcaea DrawContext )([]*Block ,DrawContext ,error ){_dggb :=_gggcg (len (_ccdca ._ccec ));
_dggb .SetMargins (0,0,25,0);for _ ,_efad :=range _ccdca ._ccec {_ffgaf :=_addb (_efad .TextStyle );_ffgaf .SetMargins (0,0,1,0);_ffgaf .Append (_efad .Value );_addgge :=_dggb .NewCell ();_addgge .SetHorizontalAlignment (_efad .Alignment );_addgge .SetBackgroundColor (_efad .BackgroundColor );
_ccdca .setCellBorder (_addgge ,_efad );_addgge .SetContent (_ffgaf );};for _ ,_ebdc :=range _ccdca ._geac {for _ ,_eaea :=range _ebdc {_gagbb :=_addb (_eaea .TextStyle );_gagbb .SetMargins (0,0,3,2);_gagbb .Append (_eaea .Value );_accef :=_dggb .NewCell ();
_accef .SetHorizontalAlignment (_eaea .Alignment );_accef .SetBackgroundColor (_eaea .BackgroundColor );_ccdca .setCellBorder (_accef ,_eaea );_accef .SetContent (_gagbb );};};return _dggb .GeneratePageBlocks (_fcaea );};

// SetLineWidth sets the line width.
func (_gfdff *Line )SetLineWidth (lw float64 ){_gfdff ._bddd =lw };func (_bbeec *Table )wrapRow (_defcc int ,_dabca DrawContext ,_gdce float64 )(bool ,error ){if !_bbeec ._fefe {return false ,nil ;};var (_afce =_bbeec ._efgd [_defcc ];_gbee =-1;_dbagc []*TableCell ;
_efbda float64 ;_feff bool ;_gceg =make ([]float64 ,0,len (_bbeec ._eabc )););_edab :=func (_fbbg *TableCell ,_cdbd VectorDrawable ,_ddfec bool )*TableCell {_bfbaa :=*_fbbg ;_bfbaa ._fcgd =_cdbd ;if _ddfec {_bfbaa ._dfda ++;};return &_bfbaa ;};_dcdb :=func (_cefed int ,_ebbg VectorDrawable ){var _ggccc float64 =-1;
if _ebbg ==nil {if _acfdd :=_gceg [_cefed -_defcc ];_acfdd > _dabca .Height {_ebbg =_bbeec ._efgd [_cefed ]._fcgd ;_bbeec ._efgd [_cefed ]._fcgd =nil ;_gceg [_cefed -_defcc ]=0;_ggccc =_acfdd ;};};_effab :=_edab (_bbeec ._efgd [_cefed ],_ebbg ,true );_dbagc =append (_dbagc ,_effab );
if _ggccc < 0{_ggccc =_effab .height (_dabca .Width );};if _ggccc > _efbda {_efbda =_ggccc ;};};for _adffc :=_defcc ;_adffc < len (_bbeec ._efgd );_adffc ++{_aceb :=_bbeec ._efgd [_adffc ];if _afce ._dfda !=_aceb ._dfda {_gbee =_adffc ;break ;};_dabca .Width =_aceb .width (_bbeec ._eabc ,_gdce );
var _cbed VectorDrawable ;switch _acdeb :=_aceb ._fcgd .(type ){case *StyledParagraph :if _gafac :=_aceb .height (_dabca .Width );_gafac > _dabca .Height {_fdbga :=_dabca ;_fdbga .Height =_aa .Floor (_dabca .Height -_acdeb ._ggdg .Top -_acdeb ._ggdg .Bottom -0.5*_acdeb .getTextHeight ());
_fbega ,_agbc ,_cabf :=_acdeb .split (_fdbga );if _cabf !=nil {return false ,_cabf ;};if _fbega !=nil &&_agbc !=nil {_acdeb =_fbega ;_aceb =_edab (_aceb ,_fbega ,false );_bbeec ._efgd [_adffc ]=_aceb ;_cbed =_agbc ;_feff =true ;};};};_gceg =append (_gceg ,_aceb .height (_dabca .Width ));
if _feff {if _dbagc ==nil {_dbagc =make ([]*TableCell ,0,len (_bbeec ._eabc ));for _adae :=_defcc ;_adae < _adffc ;_adae ++{_dcdb (_adae ,nil );};};_dcdb (_adffc ,_cbed );};};var _abef float64 ;for _ ,_gadb :=range _gceg {if _gadb > _abef {_abef =_gadb ;
};};if _feff &&_abef < _dabca .Height {if _gbee < 0{_gbee =len (_bbeec ._efgd );};_fcccc :=_bbeec ._efgd [_gbee -1]._dfda +_bbeec ._efgd [_gbee -1]._fdab -1;for _ddebb :=_gbee ;_ddebb < len (_bbeec ._efgd );_ddebb ++{_bbeec ._efgd [_ddebb ]._dfda ++;};
_bbeec ._efgd =append (_bbeec ._efgd [:_gbee ],append (_dbagc ,_bbeec ._efgd [_gbee :]...)...);_bbeec ._aedeb =append (_bbeec ._aedeb [:_fcccc ],append ([]float64 {_efbda },_bbeec ._aedeb [_fcccc :]...)...);_bbeec ._aedeb [_afce ._dfda +_afce ._fdab -2]=_abef ;
};return _feff ,nil ;};

// GeneratePageBlocks generates the page blocks for the Division component.
// Multiple blocks are generated if the contents wrap over multiple pages.
func (_ddcb *Division )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var _ebb []*Block ;_gafe :=ctx ;if _ddcb ._egb .IsRelative (){ctx .X +=_ddcb ._agab .Left ;ctx .Y +=_ddcb ._agab .Top ;ctx .Width -=_ddcb ._agab .Left +_ddcb ._agab .Right ;
ctx .Height -=_ddcb ._agab .Top +_ddcb ._agab .Bottom ;};ctx .Inline =_ddcb ._gbag ;_geda :=ctx ;_gggcb :=ctx ;var _gfee float64 ;for _ ,_eccg :=range _ddcb ._bdcb {if ctx .Inline {if (ctx .X -_geda .X )+_eccg .Width ()<=ctx .Width {ctx .Y =_gggcb .Y ;
ctx .Height =_gggcb .Height ;}else {ctx .X =_geda .X ;ctx .Width =_geda .Width ;_gggcb .Y +=_gfee ;_gggcb .Height -=_gfee ;_gfee =0;};};_bgef ,_dbc ,_daad :=_eccg .GeneratePageBlocks (ctx );if _daad !=nil {_ff .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0069\u006eg\u0020p\u0061\u0067\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073\u003a\u0020\u0025\u0076",_daad );
return nil ,ctx ,_daad ;};if len (_bgef )< 1{continue ;};if len (_ebb )> 0{_ebb [len (_ebb )-1].mergeBlocks (_bgef [0]);_ebb =append (_ebb ,_bgef [1:]...);}else {_ebb =append (_ebb ,_bgef [0:]...);};if ctx .Inline {if ctx .Page !=_dbc .Page {_geda .Y =ctx .Margins .Top ;
_geda .Height =ctx .PageHeight -ctx .Margins .Top ;_gggcb .Y =_geda .Y ;_gggcb .Height =_geda .Height ;_gfee =_dbc .Height -_geda .Height ;}else {if _ddced :=ctx .Height -_dbc .Height ;_ddced > _gfee {_gfee =_ddced ;};};}else {_dbc .X =ctx .X ;};ctx =_dbc ;
};ctx .Inline =_gafe .Inline ;if _ddcb ._egb .IsRelative (){ctx .X =_gafe .X ;};if _ddcb ._egb .IsAbsolute (){return _ebb ,_gafe ,nil ;};return _ebb ,ctx ,nil ;};

// Width returns the cell's width based on the input draw context.
func (_dbbac *TableCell )Width (ctx DrawContext )float64 {_bgbaa :=float64 (0.0);for _agfb :=0;_agfb < _dbbac ._agdd ;_agfb ++{_bgbaa +=_dbbac ._ffdff ._eabc [_dbbac ._ccegd +_agfb -1];};_daeae :=ctx .Width *_bgbaa ;return _daeae ;};

// SetPos sets absolute positioning with specified coordinates.
func (_bcfg *StyledParagraph )SetPos (x ,y float64 ){_bcfg ._cdcbf =PositionAbsolute ;_bcfg ._bdfd =x ;_bcfg ._gaba =y ;};

// GeneratePageBlocks draws the composite Bezier curve on a new block
// representing the page. Implements the Drawable interface.
func (_cfff *PolyBezierCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_acab :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_fcec ,_baeg :=_acab .setOpacity (_cfff ._afece ,_cfff ._cecc );if _baeg !=nil {return nil ,ctx ,_baeg ;
};_eeefb :=_cfff ._ggbff ;_eeefb .FillEnabled =_eeefb .FillColor !=nil ;var (_abgff =ctx .PageHeight ;_fdcec =_eeefb .Curves ;_dgbd =make ([]_fd .CubicBezierCurve ,0,len (_eeefb .Curves )););for _bcac :=range _eeefb .Curves {_adab :=_fdcec [_bcac ];_adab .P0 .Y =_abgff -_adab .P0 .Y ;
_adab .P1 .Y =_abgff -_adab .P1 .Y ;_adab .P2 .Y =_abgff -_adab .P2 .Y ;_adab .P3 .Y =_abgff -_adab .P3 .Y ;_dgbd =append (_dgbd ,_adab );};_eeefb .Curves =_dgbd ;defer func (){_eeefb .Curves =_fdcec }();_fbee ,_ ,_baeg :=_eeefb .Draw (_fcec );if _baeg !=nil {return nil ,ctx ,_baeg ;
};if _baeg =_acab .addContentsByString (string (_fbee ));_baeg !=nil {return nil ,ctx ,_baeg ;};return []*Block {_acab },ctx ,nil ;};

// Logo returns the logo of the invoice.
func (_ebagf *Invoice )Logo ()*Image {return _ebagf ._aded };

// SetLineSeparatorStyle sets the style for the separator part of all new
// lines of the table of contents.
func (_aefg *TOC )SetLineSeparatorStyle (style TextStyle ){_aefg ._bddde =style };

// GeneratePageBlocks draws the polygon on a new block representing the page.
// Implements the Drawable interface.
func (_cccaf *Polygon )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fdca :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_eaaa ,_ffac :=_fdca .setOpacity (_cccaf ._aceae ,_cccaf ._gafa );if _ffac !=nil {return nil ,ctx ,_ffac ;};
_fedc :=_cccaf ._aaff ;_fedc .FillEnabled =_fedc .FillColor !=nil ;_fedc .BorderEnabled =_fedc .BorderColor !=nil &&_fedc .BorderWidth > 0;_acee :=_fedc .Points ;for _cefg :=range _acee {for _gafea :=range _acee [_cefg ]{_ecbe :=&_acee [_cefg ][_gafea ];
_ecbe .Y =ctx .PageHeight -_ecbe .Y ;};};_fdgbe ,_ ,_ffac :=_fedc .Draw (_eaaa );if _ffac !=nil {return nil ,ctx ,_ffac ;};if _ffac =_fdca .addContentsByString (string (_fdgbe ));_ffac !=nil {return nil ,ctx ,_ffac ;};return []*Block {_fdca },ctx ,nil ;
};

// TitleStyle returns the style properties used to render the invoice title.
func (_acb *Invoice )TitleStyle ()TextStyle {return _acb ._gdd };

// AddSection adds a new content section at the end of the invoice.
func (_ddegc *Invoice )AddSection (title ,content string ){_ddegc ._dcf =append (_ddegc ._dcf ,[2]string {title ,content });};var PPI float64 =72;func _dde (_dfd string ,_geb _c .PdfObject ,_fbg *_afd .PdfPageResources )_c .PdfObjectName {_dgc :=_fg .TrimRightFunc (_fg .TrimSpace (_dfd ),func (_bbfe rune )bool {return _dg .IsNumber (_bbfe )});
if _dgc ==""{_dgc ="\u0046\u006f\u006e\u0074";};_gdc :=0;_gfd :=_c .PdfObjectName (_dfd );for {_fcd ,_dbd :=_fbg .GetFontByName (_gfd );if !_dbd ||_fcd ==_geb {break ;};_gdc ++;_gfd =_c .PdfObjectName (_ec .Sprintf ("\u0025\u0073\u0025\u0064",_dgc ,_gdc ));
};return _gfd ;};func (_ffba *Paragraph )getTextLineWidth (_gbbd string )float64 {var _degaa float64 ;for _ ,_dbceb :=range _gbbd {if _dbceb =='\u000A'{continue ;};_gfab ,_afgc :=_ffba ._gbfc .GetRuneMetrics (_dbceb );if !_afgc {_ff .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_dbceb ,_dbceb );
return -1;};_degaa +=_ffba ._afec *_gfab .Wx ;};return _degaa ;};

// NewList creates a new list.
func (_ffbg *Creator )NewList ()*List {return _egge (_ffbg .NewTextStyle ())};

// SkipRows skips over a specified number of rows in the table.
func (_eadg *Table )SkipRows (num int ){_fegf :=num *_eadg ._fceeb -1;if _fegf < 0{_ff .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};_eadg ._bgeb +=_fegf ;};

// NewInvoice returns an instance of an empty invoice.
func (_gdcb *Creator )NewInvoice ()*Invoice {_bbdb :=_gdcb .NewTextStyle ();_bbdb .Font =_gdcb ._aeeb ;return _adff (_gdcb .NewTextStyle (),_bbdb );};

// SetAngle sets the rotation angle of the text.
func (_dgccc *StyledParagraph )SetAngle (angle float64 ){_dgccc ._geba =angle };func _addb (_ggbd TextStyle )*StyledParagraph {return &StyledParagraph {_ggfd :[]*TextChunk {},_eaba :_ggbd ,_eggec :_aebd (_ggbd .Font ),_baega :1.0,_aeea :TextAlignmentLeft ,_beab :true ,_edaa :true ,_geba :0,_fgbf :1,_acdc :1,_cdcbf :PositionRelative };
};

// TextStyle is a collection of properties that can be assigned to a text chunk.
type TextStyle struct{

// Color represents the color of the text.
Color Color ;

// OutlineColor represents the color of the text outline.
OutlineColor Color ;

// Font represents the font the text will use.
Font *_afd .PdfFont ;

// FontSize represents the size of the font.
FontSize float64 ;

// OutlineSize represents the thickness of the text outline.
OutlineSize float64 ;

// CharSpacing represents the character spacing.
CharSpacing float64 ;

// RenderingMode represents the rendering mode.
RenderingMode TextRenderingMode ;

// Underline specifies if the text chunk is underlined.
Underline bool ;

// UnderlineStyle represents the style of the line used to underline text.
UnderlineStyle TextDecorationLineStyle ;

// TextRise specifies a vertical adjustment for text. It is useful for
// drawing subscripts/superscripts. A positive text rise value will
// produce superscript text, while a negative one will result in
// subscript text.
TextRise float64 ;};

// Scale scales Image by a constant factor, both width and height.
func (_bcaf *Image )Scale (xFactor ,yFactor float64 ){_bcaf ._fdbad =xFactor *_bcaf ._fdbad ;_bcaf ._fcae =yFactor *_bcaf ._fcae ;};

// CellHorizontalAlignment defines the table cell's horizontal alignment.
type CellHorizontalAlignment int ;

// Columns returns all the columns in the invoice line items table.
func (_bcbd *Invoice )Columns ()[]*InvoiceCell {return _bcbd ._ccec };

// SetStyleRight sets border style for right side.
func (_efc *border )SetStyleRight (style CellBorderStyle ){_efc ._bf =style };func (_effa *StyledParagraph )getTextWidth ()float64 {var _dadc float64 ;_dcfe :=len (_effa ._ggfd );for _ebaga ,_fccc :=range _effa ._ggfd {_ccdb :=&_fccc .Style ;_bgf :=len (_fccc .Text );
for _cfda ,_cgb :=range _fccc .Text {if _cgb =='\u000A'{continue ;};_cffa ,_faf :=_ccdb .Font .GetRuneMetrics (_cgb );if !_faf {_ff .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_cgb );
return -1;};_dadc +=_ccdb .FontSize *_cffa .Wx ;if _cgb !=' '&&(_ebaga !=_dcfe -1||_cfda !=_bgf -1){_dadc +=_ccdb .CharSpacing *1000.0;};};};return _dadc ;};func _fda (_caec *Block ,_abfg *Image ,_faa DrawContext )(DrawContext ,error ){_ceab :=_faa ;_bccg :=1;
_decf :=_c .PdfObjectName (_ec .Sprintf ("\u0049\u006d\u0067%\u0064",_bccg ));for _caec ._cf .HasXObjectByName (_decf ){_bccg ++;_decf =_c .PdfObjectName (_ec .Sprintf ("\u0049\u006d\u0067%\u0064",_bccg ));};_bfaa :=_caec ._cf .SetXObjectImageByName (_decf ,_abfg ._adbe );
if _bfaa !=nil {return _faa ,_bfaa ;};_ffge :=0;_ddgd :=_c .PdfObjectName (_ec .Sprintf ("\u0047\u0053\u0025\u0064",_ffge ));for _caec ._cf .HasExtGState (_ddgd ){_ffge ++;_ddgd =_c .PdfObjectName (_ec .Sprintf ("\u0047\u0053\u0025\u0064",_ffge ));};_fgcg :=_c .MakeDict ();
_fgcg .Set ("\u0042\u004d",_c .MakeName ("\u004e\u006f\u0072\u006d\u0061\u006c"));if _abfg ._bfdfe < 1.0{_fgcg .Set ("\u0043\u0041",_c .MakeFloat (_abfg ._bfdfe ));_fgcg .Set ("\u0063\u0061",_c .MakeFloat (_abfg ._bfdfe ));};_bfaa =_caec ._cf .AddExtGState (_ddgd ,_c .MakeIndirectObject (_fgcg ));
if _bfaa !=nil {return _faa ,_bfaa ;};_bbecd :=_abfg .Width ();_faba :=_abfg .Height ();_ ,_deg :=_abfg .rotatedSize ();_dffa :=_faa .X ;_bfcf :=_faa .PageHeight -_faa .Y -_faba ;if _abfg ._fcb .IsRelative (){_bfcf -=(_deg -_faba )/2;switch _abfg ._ebag {case HorizontalAlignmentCenter :_dffa +=(_faa .Width -_bbecd )/2;
case HorizontalAlignmentRight :_dffa =_faa .PageWidth -_faa .Margins .Right -_abfg ._acfb .Right -_bbecd ;};};_gfg :=_abfg ._aegda ;_cbdf :=_da .NewContentCreator ();_cbdf .Add_gs (_ddgd );_cbdf .Translate (_dffa ,_bfcf );if _gfg !=0{_cbdf .Translate (_bbecd /2,_faba /2);
_cbdf .RotateDeg (_gfg );_cbdf .Translate (-_bbecd /2,-_faba /2);};_cbdf .Scale (_bbecd ,_faba ).Add_Do (_decf );_efbee :=_cbdf .Operations ();_efbee .WrapIfNeeded ();_caec .addContents (_efbee );if _abfg ._fcb .IsRelative (){_faa .Y +=_deg ;_faa .Height -=_deg ;
return _faa ,nil ;};return _ceab ,nil ;};func _aebd (_ecaf *_afd .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,238),Font :_ecaf ,FontSize :10,UnderlineStyle :TextDecorationLineStyle {Offset :1,Thickness :1}};};

// SetPdfWriterAccessFunc sets a PdfWriter access function/hook.
// Exposes the PdfWriter just prior to writing the PDF.  Can be used to encrypt the output PDF, etc.
//
// Example of encrypting with a user/owner password "password"
// Prior to calling c.WriteFile():
//
// c.SetPdfWriterAccessFunc(func(w *model.PdfWriter) error {
//	userPass := []byte("password")
//	ownerPass := []byte("password")
//	err := w.Encrypt(userPass, ownerPass, nil)
//	return err
// })
//
func (_egc *Creator )SetPdfWriterAccessFunc (pdfWriterAccessFunc func (_fged *_afd .PdfWriter )error ){_egc ._bgda =pdfWriterAccessFunc ;};

// Sections returns the custom content sections of the invoice as
// title-content pairs.
func (_gbea *Invoice )Sections ()[][2]string {return _gbea ._dcf };

// Lines returns all the lines the table of contents has.
func (_becg *TOC )Lines ()[]*TOCLine {return _becg ._bgeda };

// Ellipse defines an ellipse with a center at (xc,yc) and a specified width and height.  The ellipse can have a colored
// fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Ellipse struct{_beag float64 ;_cgde float64 ;_adea float64 ;_bde float64 ;_gdfe Color ;_dgeg Color ;_bffe float64 ;};

// SetForms adds an Acroform to a PDF file.  Sets the specified form for writing.
func (_dfa *Creator )SetForms (form *_afd .PdfAcroForm )error {_dfa ._gbd =form ;return nil };

// SetFillColor sets the fill color.
func (_aaee *CurvePolygon )SetFillColor (color Color ){_aaee ._aeed .FillColor =_bff (color )};

// SetMargins sets the margins for the Image (in relative mode): left, right, top, bottom.
func (_affc *Image )SetMargins (left ,right ,top ,bottom float64 ){_affc ._acfb .Left =left ;_affc ._acfb .Right =right ;_affc ._acfb .Top =top ;_affc ._acfb .Bottom =bottom ;};

// SetMargins sets the margins TOC line.
func (_fbaa *TOCLine )SetMargins (left ,right ,top ,bottom float64 ){_fbaa ._gada =left ;_dcfbb :=&_fbaa ._dfec ._ggdg ;_dcfbb .Left =_fbaa ._gada +float64 (_fbaa ._dbgca -1)*_fbaa ._gdfd ;_dcfbb .Right =right ;_dcfbb .Top =top ;_dcfbb .Bottom =bottom ;
};

// SetFillColor sets the fill color.
func (_cbce *PolyBezierCurve )SetFillColor (color Color ){_cbce ._ggbff .FillColor =_bff (color )};

// SetLineColor sets the line color.
func (_gdaa *Polyline )SetLineColor (color Color ){_gdaa ._gbcb .LineColor =_bff (color )};

// GeneratePageBlocks generates the page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages. Implements the Drawable interface.
func (_febf *Paragraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cffe :=ctx ;var _eaef []*Block ;_ccdf :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _febf ._becd .IsRelative (){ctx .X +=_febf ._fegc .Left ;ctx .Y +=_febf ._fegc .Top ;
ctx .Width -=_febf ._fegc .Left +_febf ._fegc .Right ;ctx .Height -=_febf ._fegc .Top +_febf ._fegc .Bottom ;_febf .SetWidth (ctx .Width );if _febf .Height ()> ctx .Height {_eaef =append (_eaef ,_ccdf );_ccdf =NewBlock (ctx .PageWidth ,ctx .PageHeight );
ctx .Page ++;_geae :=ctx ;_geae .Y =ctx .Margins .Top ;_geae .X =ctx .Margins .Left +_febf ._fegc .Left ;_geae .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_febf ._fegc .Bottom ;_geae .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_febf ._fegc .Left -_febf ._fegc .Right ;
ctx =_geae ;};}else {if int (_febf ._efbd )<=0{_febf .SetWidth (_febf .getTextWidth ());};ctx .X =_febf ._bbdg ;ctx .Y =_febf ._fagg ;};ctx ,_fcdd :=_dfef (_ccdf ,_febf ,ctx );if _fcdd !=nil {_ff .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_fcdd );
return nil ,ctx ,_fcdd ;};_eaef =append (_eaef ,_ccdf );if _febf ._becd .IsRelative (){ctx .X -=_febf ._fegc .Left ;ctx .Width =_cffe .Width ;return _eaef ,ctx ,nil ;};return _eaef ,_cffe ,nil ;};func (_bcbg *TOCLine )getLineLink ()*_afd .PdfAnnotation {if _bcbg ._eeddeg <=0{return nil ;
};return _cdegg (_bcbg ._eeddeg -1,_bcbg ._afaee ,_bcbg ._ecdg ,0);};

// EnableRowWrap enables/disables row wrapping across pages.
// NOTE: Currently, row wrapping is supported for rows using StyledParagraphs.
func (_aadgg *Table )EnableRowWrap (enable bool ){_aadgg ._fefe =enable };const (TextAlignmentLeft TextAlignment =iota ;TextAlignmentRight ;TextAlignmentCenter ;TextAlignmentJustify ;);

// SetBorderColor sets the border color.
func (_cddd *PolyBezierCurve )SetBorderColor (color Color ){_cddd ._ggbff .BorderColor =_bff (color )};

// Creator is a wrapper around functionality for creating PDF reports and/or adding new
// content onto imported PDF pages, etc.
type Creator struct{_gef []*_afd .PdfPage ;_bffa map[*_afd .PdfPage ]*Block ;_gcgg map[*_afd .PdfPage ]_ab .Matrix ;_bagd *_afd .PdfPage ;_dbb PageSize ;_gbgd DrawContext ;_cce Margins ;_aeg ,_eadf float64 ;_aged int ;_dfb func (_cbe FrontpageFunctionArgs );
_cgf func (_fcfg *TOC )error ;_egde func (_aga *Block ,_bffb HeaderFunctionArgs );_fad func (_dcee *Block ,_edd FooterFunctionArgs );_bgda func (_aegg *_afd .PdfWriter )error ;_ggeb bool ;

// Controls whether a table of contents will be generated.
AddTOC bool ;_feg *TOC ;

// Controls whether outlines will be generated.
AddOutlines bool ;_gbed *_afd .Outline ;_ddd *_afd .PdfOutlineTreeNode ;_gbd *_afd .PdfAcroForm ;_efcg _c .PdfObject ;_dagf _afd .Optimizer ;_bdb []*_afd .PdfFont ;_dabc *_afd .PdfFont ;_aeeb *_afd .PdfFont ;};const (PositionRelative Positioning =iota ;
PositionAbsolute ;);func (_ada *Block )duplicate ()*Block {_bd :=&Block {};*_bd =*_ada ;_ffe :=_da .ContentStreamOperations {};_ffe =append (_ffe ,*_ada ._de ...);_bd ._de =&_ffe ;return _bd ;};

// SetHorizontalAlignment sets the cell's horizontal alignment of content.
// Can be one of:
// - CellHorizontalAlignmentLeft
// - CellHorizontalAlignmentCenter
// - CellHorizontalAlignmentRight
func (_dgccg *TableCell )SetHorizontalAlignment (halign CellHorizontalAlignment ){_dgccg ._gaef =halign ;};func _dgcc (_dagdf []_fd .Point )*Polyline {return &Polyline {_gbcb :&_fd .Polyline {Points :_dagdf ,LineColor :_afd .NewPdfColorDeviceRGB (0,0,0),LineWidth :1.0},_afae :1.0};
};

// Width returns Image's document width.
func (_edaf *Image )Width ()float64 {return _edaf ._fdbad };

// DrawFooter sets a function to draw a footer on created output pages.
func (_cbd *Creator )DrawFooter (drawFooterFunc func (_aaec *Block ,_aedd FooterFunctionArgs )){_cbd ._fad =drawFooterFunc ;};

// GetCoords returns coordinates of the Rectangle's upper left corner (x,y).
func (_dgcd *Rectangle )GetCoords ()(float64 ,float64 ){return _dgcd ._fcaf ,_dgcd ._dbba };func (_aafc *FilledCurve )draw (_gcge string )([]byte ,*_afd .PdfRectangle ,error ){_ebe :=_fd .NewCubicBezierPath ();for _ ,_daea :=range _aafc ._cefb {_ebe =_ebe .AppendCurve (_daea );
};creator :=_da .NewContentCreator ();creator .Add_q ();if _aafc .FillEnabled &&_aafc ._cdcb !=nil {creator .SetNonStrokingColor (_bff (_aafc ._cdcb ));};if _aafc .BorderEnabled {if _aafc ._cdcd !=nil {creator .SetStrokingColor (_bff (_aafc ._cdcd ));};
creator .Add_w (_aafc .BorderWidth );};if len (_gcge )> 1{creator .Add_gs (_c .PdfObjectName (_gcge ));};_fd .DrawBezierPathWithCreator (_ebe ,creator );creator .Add_h ();if _aafc .FillEnabled &&_aafc .BorderEnabled {creator .Add_B ();}else if _aafc .FillEnabled {creator .Add_f ();
}else if _aafc .BorderEnabled {creator .Add_S ();};creator .Add_Q ();_gffd :=_ebe .GetBoundingBox ();if _aafc .BorderEnabled {_gffd .Height +=_aafc .BorderWidth ;_gffd .Width +=_aafc .BorderWidth ;_gffd .X -=_aafc .BorderWidth /2;_gffd .Y -=_aafc .BorderWidth /2;
};_cdacb :=&_afd .PdfRectangle {};_cdacb .Llx =_gffd .X ;_cdacb .Lly =_gffd .Y ;_cdacb .Urx =_gffd .X +_gffd .Width ;_cdacb .Ury =_gffd .Y +_gffd .Height ;return creator .Bytes (),_cdacb ,nil ;};func (_ebdfa rgbColor )ToRGB ()(float64 ,float64 ,float64 ){return _ebdfa ._faca ,_ebdfa ._bec ,_ebdfa ._abca ;
};

// GetHorizontalAlignment returns the horizontal alignment of the image.
func (_acdf *Image )GetHorizontalAlignment ()HorizontalAlignment {return _acdf ._ebag };func _agdcd (_bccf ,_dfaa ,_aced float64 )(_ddgeb ,_cbae ,_bafgd ,_efdd float64 ){if _aced ==0{return 0,0,_bccf ,_dfaa ;};_aecdf :=_fd .Path {Points :[]_fd .Point {_fd .NewPoint (0,0).Rotate (_aced ),_fd .NewPoint (_bccf ,0).Rotate (_aced ),_fd .NewPoint (0,_dfaa ).Rotate (_aced ),_fd .NewPoint (_bccf ,_dfaa ).Rotate (_aced )}}.GetBoundingBox ();
return _aecdf .X ,_aecdf .Y ,_aecdf .Width ,_aecdf .Height ;};

// SetBackgroundColor sets the cell's background color.
func (_ccbc *TableCell )SetBackgroundColor (col Color ){_ccbc ._dffg =col };

// BuyerAddress returns the buyer address used in the invoice template.
func (_dgfg *Invoice )BuyerAddress ()*InvoiceAddress {return _dgfg ._cgad };

// SetBorderColor sets the border color.
func (_fgfga *CurvePolygon )SetBorderColor (color Color ){_fgfga ._aeed .BorderColor =_bff (color )};

// SetTOC sets the table of content component of the creator.
// This method should be used when building a custom table of contents.
func (_ccd *Creator )SetTOC (toc *TOC ){if toc ==nil {return ;};_ccd ._feg =toc ;};

// SetFontSize sets the font size in document units (points).
func (_afab *Paragraph )SetFontSize (fontSize float64 ){_afab ._afec =fontSize };

// CurCol returns the currently active cell's column number.
func (_bcde *Table )CurCol ()int {_ddcc :=(_bcde ._bgeb -1)%(_bcde ._fceeb )+1;return _ddcc };func _bfde ()*FilledCurve {_dbfc :=FilledCurve {};_dbfc ._cefb =[]_fd .CubicBezierCurve {};return &_dbfc ;};

// Scale block by specified factors in the x and y directions.
func (_gac *Block )Scale (sx ,sy float64 ){_bed :=_da .NewContentCreator ().Scale (sx ,sy ).Operations ();*_gac ._de =append (*_bed ,*_gac ._de ...);_gac ._de .WrapIfNeeded ();_gac ._dag *=sx ;_gac ._gg *=sy ;};func (_ea *Block )drawToPage (_bc *_afd .PdfPage )error {_ggd :=&_da .ContentStreamOperations {};
if _bc .Resources ==nil {_bc .Resources =_afd .NewPdfPageResources ();};_dfe :=_ca (_ggd ,_bc .Resources ,_ea ._de ,_ea ._cf );if _dfe !=nil {return _dfe ;};if _dfe =_eaa (_ea ._cf ,_bc .Resources );_dfe !=nil {return _dfe ;};if _dfe =_bc .AppendContentBytes (_ggd .Bytes (),true );
_dfe !=nil {return _dfe ;};for _ ,_fbdc :=range _ea ._ad {_bc .AddAnnotation (_fbdc );};return nil ;};func (_gbf *Block )addContents (_ga *_da .ContentStreamOperations ){_gbf ._de .WrapIfNeeded ();_ga .WrapIfNeeded ();*_gbf ._de =append (*_gbf ._de ,*_ga ...);
};

// SetIndent sets the cell's left indent.
func (_ggfc *TableCell )SetIndent (indent float64 ){_ggfc ._dcgf =indent };

// Append adds a new text chunk to the paragraph.
func (_bbae *StyledParagraph )Append (text string )*TextChunk {_gdgf :=NewTextChunk (text ,_bbae ._eaba );return _bbae .appendChunk (_gdgf );};

// InfoLines returns all the rows in the invoice information table as
// description-value cell pairs.
func (_cbgf *Invoice )InfoLines ()[][2]*InvoiceCell {_cceg :=[][2]*InvoiceCell {_cbgf ._fdbg ,_cbgf ._aacb ,_cbgf ._cbad };return append (_cceg ,_cbgf ._bcafe ...);};

// FooterFunctionArgs holds the input arguments to a footer drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FooterFunctionArgs struct{PageNum int ;TotalPages int ;};

// DrawContext defines the drawing context. The DrawContext is continuously used and updated when
// drawing the page contents in relative mode.  Keeps track of current X, Y position, available
// height as well as other page parameters such as margins and dimensions.
type DrawContext struct{

// Current page number.
Page int ;

// Current position.  In a relative positioning mode, a drawable will be placed at these coordinates.
X ,Y float64 ;

// Context dimensions.  Available width and height (on current page).
Width ,Height float64 ;

// Page Margins.
Margins Margins ;

// Absolute Page size, widths and height.
PageWidth float64 ;PageHeight float64 ;

// Controls whether the components are stacked horizontally
Inline bool ;};

// SetPageLabels adds the specified page labels to the PDF file generated
// by the creator. See section 12.4.2 "Page Labels" (p. 382 PDF32000_2008).
// NOTE: for existing PDF files, the page label ranges object can be obtained
// using the model.PDFReader's GetPageLabels method.
func (_ddca *Creator )SetPageLabels (pageLabels _c .PdfObject ){_ddca ._efcg =pageLabels };

// SetSubtotal sets the subtotal of the invoice.
func (_cfg *Invoice )SetSubtotal (value string ){_cfg ._cagd [1].Value =value };

// NewPageBreak create a new page break.
func (_eaae *Creator )NewPageBreak ()*PageBreak {return _cfeb ()};

// Title returns the title of the invoice.
func (_dbgc *Invoice )Title ()string {return _dbgc ._cdec };type listItem struct{_cffg VectorDrawable ;_ecdef TextChunk ;};

// Drawable is a widget that can be used to draw with the Creator.
type Drawable interface{

// GeneratePageBlocks draw onto blocks representing Page contents. As the content can wrap over many pages, multiple
// templates are returned, one per Page.  The function also takes a draw context containing information
// where to draw (if relative positioning) and the available height to draw on accounting for Margins etc.
GeneratePageBlocks (_ggbfd DrawContext )([]*Block ,DrawContext ,error );};

// Total returns the invoice total description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_baed *Invoice )Total ()(*InvoiceCell ,*InvoiceCell ){return _baed ._abd [0],_baed ._abd [1]};

// Add appends a new item to the list.
// The supported components are: *Paragraph, *StyledParagraph and *List.
// Returns the marker used for the newly added item. The returned marker
// object can be used to change the text and style of the marker for the
// current item.
func (_ffbf *List )Add (item VectorDrawable )(*TextChunk ,error ){_acec :=&listItem {_cffg :item ,_ecdef :_ffbf ._faac };switch _dbfb :=item .(type ){case *Paragraph :case *StyledParagraph :case *List :if _dbfb ._agg {_dbfb ._fgcge =15;};default:return nil ,_a .New ("\u0074\u0068i\u0073\u0020\u0074\u0079\u0070\u0065\u0020\u006f\u0066\u0020\u0064\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0069\u006e\u0020\u006c\u0069\u0073\u0074");
};_ffbf ._bage =append (_ffbf ._bage ,_acec );return &_acec ._ecdef ,nil ;};

// ScaleToWidth scales the Block to a specified width, maintaining the same aspect ratio.
func (_bg *Block )ScaleToWidth (w float64 ){_daf :=w /_bg ._dag ;_bg .Scale (_daf ,_daf )};

// GetMargins returns the left, right, top, bottom Margins.
func (_dgea *Table )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _dgea ._badde .Left ,_dgea ._badde .Right ,_dgea ._badde .Top ,_dgea ._badde .Bottom ;};func (_ebfa *TableCell )height (_aedf float64 )float64 {var _gfcc float64 ;switch _ddfd :=_ebfa ._fcgd .(type ){case *Paragraph :if _ddfd ._fceb {_ddfd .SetWidth (_aedf -_ebfa ._dcgf -_ddfd ._fegc .Left -_ddfd ._fegc .Right );
};_gfcc =_ddfd .Height ()+_ddfd ._fegc .Top +_ddfd ._fegc .Bottom +0.5*_ddfd ._afec *_ddfd ._ffdf ;case *StyledParagraph :if _ddfd ._beab {_ddfd .SetWidth (_aedf -_ebfa ._dcgf -_ddfd ._ggdg .Left -_ddfd ._ggdg .Right );};_gfcc =_ddfd .Height ()+_ddfd ._ggdg .Top +_ddfd ._ggdg .Bottom +0.5*_ddfd .getTextHeight ();
case *Image :_gfcc =_ddfd .Height ()+_ddfd ._acfb .Top +_ddfd ._acfb .Bottom ;case *Table :_gfcc =_ddfd .Height ()+_ddfd ._badde .Top +_ddfd ._badde .Bottom ;case *List :_gfcc =_ddfd .tableHeight (_aedf -_ebfa ._dcgf )+_ddfd ._bded .Top +_ddfd ._bded .Bottom ;
case *Division :_gfcc =_ddfd .ctxHeight (_aedf -_ebfa ._dcgf )+_ddfd ._agab .Top +_ddfd ._agab .Bottom ;};return _gfcc ;};

// NoteStyle returns the style properties used to render the content of the
// invoice note sections.
func (_bbdf *Invoice )NoteStyle ()TextStyle {return _bbdf ._daff };

// The Image type is used to draw an image onto PDF.
type Image struct{_adbe *_afd .XObjectImage ;_cfaa *_afd .Image ;_aegda float64 ;_fdbad ,_fcae float64 ;_beagd ,_cbfde float64 ;_fcb Positioning ;_ebag HorizontalAlignment ;_dbbb float64 ;_ebdd float64 ;_bfdfe float64 ;_acfb Margins ;_eeeb ,_bbe float64 ;
_cgdee _c .StreamEncoder ;};func _ggbec (_gfdf [][]_fd .CubicBezierCurve )*CurvePolygon {return &CurvePolygon {_aeed :&_fd .CurvePolygon {Rings :_gfdf },_gfdeg :1.0,_fabg :1.0};};func (_gbbe *Invoice )setCellBorder (_degg *TableCell ,_gbegd *InvoiceCell ){for _ ,_baae :=range _gbegd .BorderSides {_degg .SetBorder (_baae ,CellBorderStyleSingle ,_gbegd .BorderWidth );
};_degg .SetBorderColor (_gbegd .BorderColor );};

// NewChapter creates a new chapter with the specified title as the heading.
func (_aegd *Creator )NewChapter (title string )*Chapter {_aegd ._aged ++;_fecc :=_aegd .NewTextStyle ();_fecc .FontSize =16;return _bbb (nil ,_aegd ._feg ,_aegd ._gbed ,title ,_aegd ._aged ,_fecc );};

// NewRectangle creates a new Rectangle with default parameters
// with left corner at (x,y) and width, height as specified.
func (_eacf *Creator )NewRectangle (x ,y ,width ,height float64 )*Rectangle {return _bfcb (x ,y ,width ,height );};

// SetColor sets the color of the Paragraph text.
//
// Example:
// 1.   p := NewParagraph("Red paragraph")
//      // Set to red color with a hex code:
//      p.SetColor(creator.ColorRGBFromHex("#ff0000"))
//
// 2. Make Paragraph green with 8-bit rgb values (0-255 each component)
//      p.SetColor(creator.ColorRGBFrom8bit(0, 255, 0)
//
// 3. Make Paragraph blue with arithmetic (0-1) rgb components.
//      p.SetColor(creator.ColorRGBFromArithmetic(0, 0, 1.0)
//
func (_fagf *Paragraph )SetColor (col Color ){_fagf ._eedd =col };func (_dddf *Invoice )newColumn (_efafc string ,_cabe CellHorizontalAlignment )*InvoiceCell {_dbgd :=&InvoiceCell {_dddf ._ffad ,_efafc };_dbgd .Alignment =_cabe ;return _dbgd ;};func (_eabf *Invoice )drawSection (_bgdg ,_gbcdf string )[]*StyledParagraph {var _ccca []*StyledParagraph ;
if _bgdg !=""{_fded :=_addb (_eabf ._ggdd );_fded .SetMargins (0,0,0,5);_fded .Append (_bgdg );_ccca =append (_ccca ,_fded );};if _gbcdf !=""{_eagd :=_addb (_eabf ._daff );_eagd .Append (_gbcdf );_ccca =append (_ccca ,_eagd );};return _ccca ;};

// SetLinePageStyle sets the style for the page part of all new lines
// of the table of contents.
func (_fgdaf *TOC )SetLinePageStyle (style TextStyle ){_fgdaf ._adef =style };

// SetHeading sets the text and the style of the heading of the TOC component.
func (_dcfb *TOC )SetHeading (text string ,style TextStyle ){_eegd :=_dcfb .Heading ();_eegd .Reset ();_gdfbg :=_eegd .Append (text );_gdfbg .Style =style ;};

// Rows returns the total number of rows the table has.
func (_fffc *Table )Rows ()int {return _fffc ._bace };

// SetWidth sets line width.
func (_cgaf *Curve )SetWidth (width float64 ){_cgaf ._bcdg =width };func (_egfb *Block )translate (_ggca ,_fge float64 ){_bee :=_da .NewContentCreator ().Translate (_ggca ,-_fge ).Operations ();*_egfb ._de =append (*_bee ,*_egfb ._de ...);_egfb ._de .WrapIfNeeded ();
};

// TextChunk represents a chunk of text along with a particular style.
type TextChunk struct{

// The text that is being rendered in the PDF.
Text string ;

// The style of the text being rendered.
Style TextStyle ;_fbdcc *_afd .PdfAnnotation ;_gegc bool ;};

// SetHeight sets the Image's document height to specified h.
func (_agb *Image )SetHeight (h float64 ){_agb ._fcae =h };

// SetNotes sets the notes section of the invoice.
func (_aeebd *Invoice )SetNotes (title ,content string ){_aeebd ._dbdc =[2]string {title ,content }};func _cade (_aecac ,_dbagca ,_ebab string ,_bdgc uint ,_fffd TextStyle )*TOCLine {return _ebbc (TextChunk {Text :_aecac ,Style :_fffd },TextChunk {Text :_dbagca ,Style :_fffd },TextChunk {Text :_ebab ,Style :_fffd },_bdgc ,_fffd );
};func (_fgac *Chapter )headingText ()string {_gce :=_fgac ._eagb ;if _dbff :=_fgac .headingNumber ();_dbff !=""{_gce =_ec .Sprintf ("\u0025\u0073\u0020%\u0073",_dbff ,_gce );};return _gce ;};

// SetLineSeparator sets the separator for all new lines of the table of contents.
func (_acaf *TOC )SetLineSeparator (separator string ){_acaf ._fcbf =separator };

// SetFillColor sets background color for border.
func (_fcaa *border )SetFillColor (col Color ){_fcaa ._gcd =col };

// GeneratePageBlocks draws the rectangle on a new block representing the page.
func (_cfcdc *Ellipse )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bfdf :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_bfae :=_fd .Circle {X :_cfcdc ._beag -_cfcdc ._adea /2,Y :ctx .PageHeight -_cfcdc ._cgde -_cfcdc ._bde /2,Width :_cfcdc ._adea ,Height :_cfcdc ._bde ,Opacity :1.0,BorderWidth :_cfcdc ._bffe };
if _cfcdc ._gdfe !=nil {_bfae .FillEnabled =true ;_bfae .FillColor =_bff (_cfcdc ._gdfe );};if _cfcdc ._dgeg !=nil {_bfae .BorderEnabled =true ;_bfae .BorderColor =_bff (_cfcdc ._dgeg );_bfae .BorderWidth =_cfcdc ._bffe ;};_dgf ,_ ,_ebbd :=_bfae .Draw ("");
if _ebbd !=nil {return nil ,ctx ,_ebbd ;};_ebbd =_bfdf .addContentsByString (string (_dgf ));if _ebbd !=nil {return nil ,ctx ,_ebbd ;};return []*Block {_bfdf },ctx ,nil ;};

// SetLineMargins sets the margins for all new lines of the table of contents.
func (_edegg *TOC )SetLineMargins (left ,right ,top ,bottom float64 ){_ceccea :=&_edegg ._ffcd ;_ceccea .Left =left ;_ceccea .Right =right ;_ceccea .Top =top ;_ceccea .Bottom =bottom ;};

// NewImageFromGoImage creates an Image from a go image.Image data structure.
func (_acfd *Creator )NewImageFromGoImage (goimg _ac .Image )(*Image ,error ){return _defd (goimg )};

// SetBorderWidth sets the border width.
func (_dea *CurvePolygon )SetBorderWidth (borderWidth float64 ){_dea ._aeed .BorderWidth =borderWidth };

// NoteHeadingStyle returns the style properties used to render the heading of
// the invoice note sections.
func (_cdgc *Invoice )NoteHeadingStyle ()TextStyle {return _cdgc ._ggdd };

// TotalLines returns all the rows in the invoice totals table as
// description-value cell pairs.
func (_ecec *Invoice )TotalLines ()[][2]*InvoiceCell {_affg :=[][2]*InvoiceCell {_ecec ._cagd };_affg =append (_affg ,_ecec ._gdff ...);return append (_affg ,_ecec ._abd );};func _ebde (_bfgc *_afd .PdfAnnotationLink )*_afd .PdfAnnotationLink {if _bfgc ==nil {return nil ;
};_adec :=_afd .NewPdfAnnotationLink ();_adec .BS =_bfgc .BS ;_adec .A =_bfgc .A ;if _dfedb ,_bbaee :=_bfgc .GetAction ();_bbaee ==nil &&_dfedb !=nil {_adec .SetAction (_dfedb );};if _cgefg ,_fedce :=_bfgc .Dest .(*_c .PdfObjectArray );_fedce {_adec .Dest =_c .MakeArray (_cgefg .Elements ()...);
};return _adec ;};

// List represents a list of items.
// The representation of a list item is as follows:
//       [marker] [content]
// e.g.:        • This is the content of the item.
// The supported components to add content to list items are:
// - Paragraph
// - StyledParagraph
// - List
type List struct{_bage []*listItem ;_bded Margins ;_faac TextChunk ;_fgcge float64 ;_agg bool ;_aecf Positioning ;_egdee TextStyle ;};func (_cgaa *Invoice )drawInformation ()*Table {_cgaff :=_gggcg (2);_dgabe :=append ([][2]*InvoiceCell {_cgaa ._fdbg ,_cgaa ._aacb ,_cgaa ._cbad },_cgaa ._bcafe ...);
for _ ,_cefe :=range _dgabe {_ecbf ,_cgcac :=_cefe [0],_cefe [1];if _cgcac .Value ==""{continue ;};_acdg :=_cgaff .NewCell ();_acdg .SetBackgroundColor (_ecbf .BackgroundColor );_cgaa .setCellBorder (_acdg ,_ecbf );_fdged :=_addb (_ecbf .TextStyle );_fdged .Append (_ecbf .Value );
_fdged .SetMargins (0,0,2,1);_acdg .SetContent (_fdged );_acdg =_cgaff .NewCell ();_acdg .SetBackgroundColor (_cgcac .BackgroundColor );_cgaa .setCellBorder (_acdg ,_cgcac );_fdged =_addb (_cgcac .TextStyle );_fdged .Append (_cgcac .Value );_fdged .SetMargins (0,0,2,1);
_acdg .SetContent (_fdged );};return _cgaff ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_cdfc *TOC )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_debb :=ctx ;_gedb ,ctx ,_dddd :=_cdfc ._bcge .GeneratePageBlocks (ctx );if _dddd !=nil {return _gedb ,ctx ,_dddd ;};for _ ,_cbbg :=range _cdfc ._bgeda {_dedccc :=_cbbg ._eeddeg ;
if !_cdfc ._gega {_cbbg ._eeddeg =0;};_ddfb ,_gege ,_cdbc :=_cbbg .GeneratePageBlocks (ctx );_cbbg ._eeddeg =_dedccc ;if _cdbc !=nil {return _gedb ,ctx ,_cdbc ;};if len (_ddfb )< 1{continue ;};_gedb [len (_gedb )-1].mergeBlocks (_ddfb [0]);_gedb =append (_gedb ,_ddfb [1:]...);
ctx =_gege ;};if _cdfc ._bccd .IsRelative (){ctx .X =_debb .X ;};if _cdfc ._bccd .IsAbsolute (){return _gedb ,_debb ,nil ;};return _gedb ,ctx ,nil ;};

// SetSideBorderColor sets the cell's side border color.
func (_cddace *TableCell )SetSideBorderColor (side CellBorderSide ,col Color ){switch side {case CellBorderSideTop :_cddace ._aeae =col ;case CellBorderSideBottom :_cddace ._fdcc =col ;case CellBorderSideLeft :_cddace ._ggef =col ;case CellBorderSideRight :_cddace ._bfca =col ;
};};

// GeneratePageBlocks draws the line on a new block representing the page. Implements the Drawable interface.
func (_ecdaf *Line )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_afdg :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_cbec :=_fd .Line {LineWidth :_ecdaf ._bddd ,Opacity :1.0,LineColor :_bff (_ecdaf ._dbgda ),LineEndingStyle1 :_fd .LineEndingStyleNone ,LineEndingStyle2 :_fd .LineEndingStyleNone ,X1 :_ecdaf ._bfge ,Y1 :ctx .PageHeight -_ecdaf ._afbb ,X2 :_ecdaf ._eddf ,Y2 :ctx .PageHeight -_ecdaf ._caee };
_ecgcd ,_ ,_ebaeg :=_cbec .Draw ("");if _ebaeg !=nil {return nil ,ctx ,_ebaeg ;};_ebaeg =_afdg .addContentsByString (string (_ecgcd ));if _ebaeg !=nil {return nil ,ctx ,_ebaeg ;};return []*Block {_afdg },ctx ,nil ;};func _acced (_ebc string )(*Image ,error ){_acae ,_bgaf :=_f .Open (_ebc );
if _bgaf !=nil {return nil ,_bgaf ;};defer _acae .Close ();_dgegd ,_bgaf :=_afd .ImageHandling .Read (_acae );if _bgaf !=nil {_ff .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_bgaf );
return nil ,_bgaf ;};return _dbbd (_dgegd );};

// SetWidth sets the the Paragraph width. This is essentially the wrapping width,
// i.e. the width the text can extend to prior to wrapping over to next line.
func (_egbg *StyledParagraph )SetWidth (width float64 ){_egbg ._cdcee =width ;_egbg .wrapText ()};func (_ecca *StyledParagraph )getMaxLineWidth ()float64 {if _ecca ._faaf ==nil ||len (_ecca ._faaf )==0{_ecca .wrapText ();};var _gbdd float64 ;for _ ,_fbeed :=range _ecca ._faaf {_bfaeg :=_ecca .getTextLineWidth (_fbeed );
if _bfaeg > _gbdd {_gbdd =_bfaeg ;};};return _gbdd ;};func _cfeb ()*PageBreak {return &PageBreak {}};

// GeneratePageBlocks draws the rectangle on a new block representing the page. Implements the Drawable interface.
func (_beage *Rectangle )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_facg :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_bfba :=_fd .Rectangle {Opacity :1.0,X :_beage ._fcaf ,Y :ctx .PageHeight -_beage ._dbba -_beage ._gacd ,Height :_beage ._gacd ,Width :_beage ._dgag };
if _beage ._fgagc !=nil {_bfba .FillEnabled =true ;_bfba .FillColor =_bff (_beage ._fgagc );};if _beage ._adgba !=nil &&_beage ._bafe > 0{_bfba .BorderEnabled =true ;_bfba .BorderColor =_bff (_beage ._adgba );_bfba .BorderWidth =_beage ._bafe ;};_fagd ,_dbcebf :=_facg .setOpacity (_beage ._cbcd ,_beage ._fbae );
if _dbcebf !=nil {return nil ,ctx ,_dbcebf ;};_bcbf ,_ ,_dbcebf :=_bfba .Draw (_fagd );if _dbcebf !=nil {return nil ,ctx ,_dbcebf ;};if _dbcebf =_facg .addContentsByString (string (_bcbf ));_dbcebf !=nil {return nil ,ctx ,_dbcebf ;};return []*Block {_facg },ctx ,nil ;
};

// GetHeading returns the chapter heading paragraph. Used to give access to address style: font, sizing etc.
func (_cda *Chapter )GetHeading ()*Paragraph {return _cda ._aff };

// EnableFontSubsetting enables font subsetting for `font` when the creator output is written to file.
// Embeds only the subset of the runes/glyphs that are actually used to display the file.
// Subsetting can reduce the size of fonts significantly.
func (_gdab *Creator )EnableFontSubsetting (font *_afd .PdfFont ){_gdab ._bdb =append (_gdab ._bdb ,font )};

// SetPageMargins sets the page margins: left, right, top, bottom.
// The default page margins are 10% of document width.
func (_cgdf *Creator )SetPageMargins (left ,right ,top ,bottom float64 ){_cgdf ._cce .Left =left ;_cgdf ._cce .Right =right ;_cgdf ._cce .Top =top ;_cgdf ._cce .Bottom =bottom ;};

// AddExternalLink adds a new external link to the paragraph.
// The text parameter represents the text that is displayed and the url
// parameter sets the destionation of the link.
func (_bgede *StyledParagraph )AddExternalLink (text ,url string )*TextChunk {_ffcf :=NewTextChunk (text ,_bgede ._eggec );_ffcf ._fbdcc =_edac (url );return _bgede .appendChunk (_ffcf );};

// SetSellerAddress sets the seller address of the invoice.
func (_egcg *Invoice )SetSellerAddress (address *InvoiceAddress ){_egcg ._dbab =address };

// Level returns the indentation level of the TOC line.
func (_dbfba *TOCLine )Level ()uint {return _dbfba ._dbgca };func _gdeb (_caacf ,_bbfbc ,_bbfeb ,_gaac float64 )*Line {_ceec :=&Line {};_ceec ._bfge =_caacf ;_ceec ._afbb =_bbfbc ;_ceec ._eddf =_bbfeb ;_ceec ._caee =_gaac ;_ceec ._dbgda =ColorBlack ;_ceec ._bddd =1.0;
return _ceec ;};func _deeac (_gabb []_fd .CubicBezierCurve )*PolyBezierCurve {return &PolyBezierCurve {_ggbff :&_fd .PolyBezierCurve {Curves :_gabb ,BorderColor :_afd .NewPdfColorDeviceRGB (0,0,0),BorderWidth :1.0},_afece :1.0,_cecc :1.0};};

// HorizontalAlignment represents the horizontal alignment of components
// within a page.
type HorizontalAlignment int ;

// InvoiceAddress contains contact information that can be displayed
// in an invoice. It is used for the seller and buyer information in the
// invoice template.
type InvoiceAddress struct{Heading string ;Name string ;Street string ;Street2 string ;Zip string ;City string ;State string ;Country string ;Phone string ;Email string ;

// Separator defines the separator between different address components,
// such as the city, state and zip code. It defaults to ", " when the
// field is an empty string.
Separator string ;

// If enabled, the Phone field label (`Phone: `) is not displayed.
HidePhoneLabel bool ;

// If enabled, the Email field label (`Email: `) is not displayed.
HideEmailLabel bool ;};

// SetAnnotation sets a annotation on a TextChunk.
func (_cbge *TextChunk )SetAnnotation (annotation *_afd .PdfAnnotation ){_cbge ._fbdcc =annotation };func _gecb (_acecc string ,_dgde TextStyle )*Paragraph {_bgee :=&Paragraph {_ddcg :_acecc ,_gbfc :_dgde .Font ,_afec :_dgde .FontSize ,_ffdf :1.0,_fceb :true ,_beee :true ,_bdcc :TextAlignmentLeft ,_bcad :0,_ddaa :1,_eeee :1,_becd :PositionRelative };
_bgee .SetColor (_dgde .Color );return _bgee ;};

// Cols returns the total number of columns the table has.
func (_bfgaa *Table )Cols ()int {return _bfgaa ._fceeb };func (_beg *Creator )getActivePage ()*_afd .PdfPage {if _beg ._bagd ==nil {if len (_beg ._gef )==0{return nil ;};return _beg ._gef [len (_beg ._gef )-1];};return _beg ._bagd ;};

// Curve represents a cubic Bezier curve with a control point.
type Curve struct{_efcd float64 ;_eggc float64 ;_faec float64 ;_cba float64 ;_eceg float64 ;_bbfbe float64 ;_cbaa Color ;_bcdg float64 ;};

// AddressHeadingStyle returns the style properties used to render the
// heading of the invoice address sections.
func (_bdebb *Invoice )AddressHeadingStyle ()TextStyle {return _bdebb ._aag };

// Inline returns whether the inline mode of the division is active.
func (_ggea *Division )Inline ()bool {return _ggea ._gbag };

// SetDueDate sets the due date of the invoice.
func (_dedb *Invoice )SetDueDate (dueDate string )(*InvoiceCell ,*InvoiceCell ){_dedb ._cbad [1].Value =dueDate ;return _dedb ._cbad [0],_dedb ._cbad [1];};

// Width returns the Block's width.
func (_ebd *Block )Width ()float64 {return _ebd ._dag };func _gbcg (_ccg []byte )(*Image ,error ){_befe :=_gb .NewReader (_ccg );_bcba ,_geff :=_afd .ImageHandling .Read (_befe );if _geff !=nil {_ff .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_geff );
return nil ,_geff ;};return _dbbd (_bcba );};const (TextRenderingModeFill TextRenderingMode =iota ;TextRenderingModeStroke ;TextRenderingModeFillStroke ;TextRenderingModeInvisible ;TextRenderingModeFillClip ;TextRenderingModeStrokeClip ;TextRenderingModeFillStrokeClip ;
TextRenderingModeClip ;);