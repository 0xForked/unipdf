//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

//
// Package creator is used for quickly generating pages and content with a simple interface.
// It is built on top of the model package to provide access to the most common
// operations such as creating text and image reports and manipulating existing pages.
//
package creator ;import (_b "bytes";_c "errors";_gg "fmt";_dc "github.com/gorilla/i18n/linebreak";_gc "github.com/unidoc/unichart/render";_bg "github.com/unidoc/unipdf/v3/common";_af "github.com/unidoc/unipdf/v3/contentstream";_f "github.com/unidoc/unipdf/v3/contentstream/draw";
_eg "github.com/unidoc/unipdf/v3/core";_fe "github.com/unidoc/unipdf/v3/internal/integrations/unichart";_cd "github.com/unidoc/unipdf/v3/internal/license";_fb "github.com/unidoc/unipdf/v3/internal/transform";_fd "github.com/unidoc/unipdf/v3/model";_ac "golang.org/x/text/unicode/bidi";
_be "image";_e "io";_da "math";_a "os";_dd "sort";_g "strconv";_ad "strings";_ga "unicode";);

// NewColumn returns a new column for the line items invoice table.
func (_degfb *Invoice )NewColumn (description string )*InvoiceCell {return _degfb .newColumn (description ,CellHorizontalAlignmentLeft );};func (_bdfad *Division )split (_gffc DrawContext )(_bgfcc ,_gadc *Division ){var (_ecdd float64 ;_gdea ,_feea []VectorDrawable ;
);_fff :=_gffc .Width -_bdfad ._cfe .Left -_bdfad ._cfe .Right -_bdfad ._gbaa .Left -_bdfad ._gbaa .Right ;for _gaab ,_abbg :=range _bdfad ._bcfe {_ecdd +=_dfbdg (_abbg ,_fff );if _ecdd < _gffc .Height {_gdea =append (_gdea ,_abbg );}else {_feea =_bdfad ._bcfe [_gaab :];
break ;};};if len (_gdea )> 0{_bgfcc =_bfdc ();*_bgfcc =*_bdfad ;_bgfcc ._bcfe =_gdea ;if _bdfad ._fefg !=nil {_bgfcc ._fefg =&Background {};*_bgfcc ._fefg =*_bdfad ._fefg ;};};if len (_feea )> 0{_gadc =_bfdc ();*_gadc =*_bdfad ;_gadc ._bcfe =_feea ;if _bdfad ._fefg !=nil {_gadc ._fefg =&Background {};
*_gadc ._fefg =*_bdfad ._fefg ;};};return _bgfcc ,_gadc ;};func (_gagd *Block )translate (_efa ,_df float64 ){_fddg :=_af .NewContentCreator ().Translate (_efa ,-_df ).Operations ();*_gagd ._ba =append (*_fddg ,*_gagd ._ba ...);_gagd ._ba .WrapIfNeeded ();
};

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_dbeg *StyledParagraph )SetTextAlignment (align TextAlignment ){_dbeg ._faf =align };

// Marker returns the marker used for the list items.
// The marker instance can be used the change the text and the style
// of newly added list items.
func (_dggd *List )Marker ()*TextChunk {return &_dggd ._ebfga };func (_gabdg *Invoice )setCellBorder (_gdgab *TableCell ,_cbda *InvoiceCell ){for _ ,_dcdad :=range _cbda .BorderSides {_gdgab .SetBorder (_dcdad ,CellBorderStyleSingle ,_cbda .BorderWidth );
};_gdgab .SetBorderColor (_cbda .BorderColor );};

// AddLine adds a new line with the provided style to the table of contents.
func (_eabaa *TOC )AddLine (line *TOCLine )*TOCLine {if line ==nil {return nil ;};_eabaa ._bgbaf =append (_eabaa ._bgbaf ,line );return line ;};

// SetInline sets the inline mode of the division.
func (_aagbe *Division )SetInline (inline bool ){_aagbe ._acea =inline };

// DrawHeader sets a function to draw a header on created output pages.
func (_bgga *Creator )DrawHeader (drawHeaderFunc func (_dcda *Block ,_acdg HeaderFunctionArgs )){_bgga ._agg =drawHeaderFunc ;};

// SetNotes sets the notes section of the invoice.
func (_aabge *Invoice )SetNotes (title ,content string ){_aabge ._ecbb =[2]string {title ,content }};

// NewBlock creates a new Block with specified width and height.
func NewBlock (width float64 ,height float64 )*Block {_bge :=&Block {};_bge ._ba =&_af .ContentStreamOperations {};_bge ._dab =_fd .NewPdfPageResources ();_bge ._bd =width ;_bge ._ef =height ;return _bge ;};func (_bcdb *StyledParagraph )getTextWidth ()float64 {var _ccacab float64 ;
_bbbb :=len (_bcdb ._aacee );for _ddbb ,_ecfc :=range _bcdb ._aacee {_geda :=&_ecfc .Style ;_cfda :=len (_ecfc .Text );for _bffd ,_gaafe :=range _ecfc .Text {if _gaafe =='\u000A'{continue ;};_dcagb ,_dfea :=_geda .Font .GetRuneMetrics (_gaafe );if !_dfea {_bg .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_gaafe );
return -1;};_ccacab +=_geda .FontSize *_dcagb .Wx *_geda .horizontalScale ();if _gaafe !=' '&&(_ddbb !=_bbbb -1||_bffd !=_cfda -1){_ccacab +=_geda .CharSpacing *1000.0;};};};return _ccacab ;};func _acabf (_gdcd *_a .File )([]*_fd .PdfPage ,error ){_addg ,_gcffa :=_fd .NewPdfReader (_gdcd );
if _gcffa !=nil {return nil ,_gcffa ;};_dgeab ,_gcffa :=_addg .GetNumPages ();if _gcffa !=nil {return nil ,_gcffa ;};var _dbfce []*_fd .PdfPage ;for _dbad :=0;_dbad < _dgeab ;_dbad ++{_ebeb ,_ffcbc :=_addg .GetPage (_dbad +1);if _ffcbc !=nil {return nil ,_ffcbc ;
};_dbfce =append (_dbfce ,_ebeb );};return _dbfce ,nil ;};

// LevelOffset returns the amount of space an indentation level occupies.
func (_gdgae *TOCLine )LevelOffset ()float64 {return _gdgae ._aageb };

// GeneratePageBlocks generates the table page blocks. Multiple blocks are
// generated if the contents wrap over multiple pages.
// Implements the Drawable interface.
func (_dagg *Table )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cccg :=_dagg ;if _dagg ._gbfbcd {_cccg =_dagg .clone ();};return _gfbc (_cccg ,ctx );};

// InvoiceCell represents any cell belonging to a table from the invoice
// template. The main tables are the invoice information table, the line
// items table and totals table. Contains the text value of the cell and
// the style properties of the cell.
type InvoiceCell struct{InvoiceCellProps ;Value string ;};

// SetContent sets the cell's content.  The content is a VectorDrawable, i.e.
// a Drawable with a known height and width.
// Currently supported VectorDrawables:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
// - *Table
// - *Division
// - *List
// - *Rectangle
// - *Ellipse
// - *Line
func (_fcacd *TableCell )SetContent (vd VectorDrawable )error {switch _gdabg :=vd .(type ){case *Paragraph :if _gdabg ._dcbb {_gdabg ._bbde =true ;};_fcacd ._edcdf =vd ;case *StyledParagraph :if _gdabg ._bcgg {_gdabg ._gffg =true ;};_fcacd ._edcdf =vd ;
case *Image ,*Chart ,*Table ,*Division ,*List ,*Rectangle ,*Ellipse ,*Line :_fcacd ._edcdf =vd ;default:_bg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020\u0074\u0079p\u0065\u0020\u0025\u0054",vd );
return _eg .ErrTypeError ;};return nil ;};

// NewPage adds a new Page to the Creator and sets as the active Page.
func (_bdfa *Creator )NewPage ()*_fd .PdfPage {_ggbg :=_bdfa .newPage ();_bdfa ._bfba =append (_bdfa ._bfba ,_ggbg );_bdfa ._acda .Page ++;return _ggbg ;};func (_gadbb *Invoice )generateNoteBlocks (_cbeba DrawContext )([]*Block ,DrawContext ,error ){_debg :=_bfdc ();
_acag :=append ([][2]string {_gadbb ._ecbb ,_gadbb ._eceg },_gadbb ._eafgd ...);for _ ,_fega :=range _acag {if _fega [1]!=""{_eceb :=_gadbb .drawSection (_fega [0],_fega [1]);for _ ,_fddd :=range _eceb {_debg .Add (_fddd );};_edfba :=_ebda (_gadbb ._fbadd );
_edfba .SetMargins (0,0,10,0);_debg .Add (_edfba );};};return _debg .GeneratePageBlocks (_cbeba );};

// FilledCurve represents a closed path of Bezier curves with a border and fill.
type FilledCurve struct{_gaae []_f .CubicBezierCurve ;FillEnabled bool ;_fdgaf Color ;BorderEnabled bool ;BorderWidth float64 ;_aacg Color ;};const (CellBorderSideLeft CellBorderSide =iota ;CellBorderSideRight ;CellBorderSideTop ;CellBorderSideBottom ;
CellBorderSideAll ;);

// GeneratePageBlocks draws the line on a new block representing the page.
// Implements the Drawable interface.
func (_acdag *Line )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var (_baaa []*Block ;_bgbd =NewBlock (ctx .PageWidth ,ctx .PageHeight );_ageg =ctx ;_degd ,_cbdb =_acdag ._gdee ,ctx .PageHeight -_acdag ._dbcb ;_dfag ,_cggg =_acdag ._fdba ,ctx .PageHeight -_acdag ._gfcfb ;
);_fbfeb :=_acdag ._ddfd .IsRelative ();if _fbfeb {ctx .X +=_acdag ._eebc .Left ;ctx .Y +=_acdag ._eebc .Top ;ctx .Width -=_acdag ._eebc .Left +_acdag ._eebc .Right ;ctx .Height -=_acdag ._eebc .Top +_acdag ._eebc .Bottom ;_degd ,_cbdb ,_dfag ,_cggg =_acdag .computeCoords (ctx );
if _acdag .Height ()> ctx .Height {_baaa =append (_baaa ,_bgbd );_bgbd =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_baeg :=ctx ;_baeg .Y =ctx .Margins .Top +_acdag ._eebc .Top ;_baeg .X =ctx .Margins .Left +_acdag ._eebc .Left ;_baeg .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_acdag ._eebc .Top -_acdag ._eebc .Bottom ;
_baeg .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_acdag ._eebc .Left -_acdag ._eebc .Right ;ctx =_baeg ;_degd ,_cbdb ,_dfag ,_cggg =_acdag .computeCoords (ctx );};};_agfe :=_f .BasicLine {X1 :_degd ,Y1 :_cbdb ,X2 :_dfag ,Y2 :_cggg ,LineColor :_ecb (_acdag ._dbge ),Opacity :_acdag ._fdff ,LineWidth :_acdag ._gbff ,LineStyle :_acdag ._gbafg ,DashArray :_acdag ._abgaf ,DashPhase :_acdag ._fdgafa };
_aeab ,_bgdc :=_bgbd .setOpacity (1.0,_acdag ._fdff );if _bgdc !=nil {return nil ,ctx ,_bgdc ;};_bagf ,_ ,_bgdc :=_agfe .Draw (_aeab );if _bgdc !=nil {return nil ,ctx ,_bgdc ;};if _bgdc =_bgbd .addContentsByString (string (_bagf ));_bgdc !=nil {return nil ,ctx ,_bgdc ;
};if _fbfeb {ctx .X =_ageg .X ;ctx .Width =_ageg .Width ;_fecff :=_acdag .Height ();ctx .Y +=_fecff +_acdag ._eebc .Bottom ;ctx .Height -=_fecff ;}else {ctx =_ageg ;};_baaa =append (_baaa ,_bgbd );return _baaa ,ctx ,nil ;};

// FrontpageFunctionArgs holds the input arguments to a front page drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FrontpageFunctionArgs struct{PageNum int ;TotalPages int ;};

// TextVerticalAlignment controls the vertical position of the text
// in a styled paragraph.
type TextVerticalAlignment int ;

// SetOptimizer sets the optimizer to optimize PDF before writing.
func (_fcdd *Creator )SetOptimizer (optimizer _fd .Optimizer ){_fcdd ._fda =optimizer };

// SetBorderRadius sets the radius of the background corners.
func (_dag *Background )SetBorderRadius (topLeft ,topRight ,bottomLeft ,bottomRight float64 ){_dag .BorderRadiusTopLeft =topLeft ;_dag .BorderRadiusTopRight =topRight ;_dag .BorderRadiusBottomLeft =bottomLeft ;_dag .BorderRadiusBottomRight =bottomRight ;
};

// SetText sets the text content of the Paragraph.
func (_febg *Paragraph )SetText (text string ){_febg ._eefd =text };

// DrawWithContext draws the Block using the specified drawing context.
func (_fgeg *Block )DrawWithContext (d Drawable ,ctx DrawContext )error {_gfd ,_ ,_deb :=d .GeneratePageBlocks (ctx );if _deb !=nil {return _deb ;};if len (_gfd )!=1{return _c .New ("\u0074\u006f\u006f\u0020ma\u006e\u0079\u0020\u006f\u0075\u0074\u0070\u0075\u0074\u0020\u0062\u006c\u006f\u0063k\u0073");
};for _ ,_geg :=range _gfd {if _gac :=_fgeg .mergeBlocks (_geg );_gac !=nil {return _gac ;};};return nil ;};func (_fcb *Invoice )generateHeaderBlocks (_dafa DrawContext )([]*Block ,DrawContext ,error ){_daag :=_ebda (_fcb ._bfcc );_daag .SetEnableWrap (true );
_daag .Append (_fcb ._gaddb );_gdbb :=_fbcc (2);if _fcb ._ffbf !=nil {_fcgb :=_gdbb .NewCell ();_fcgb .SetHorizontalAlignment (CellHorizontalAlignmentLeft );_fcgb .SetVerticalAlignment (CellVerticalAlignmentMiddle );_fcgb .SetIndent (0);_fcgb .SetContent (_fcb ._ffbf );
_fcb ._ffbf .ScaleToHeight (_daag .Height ()+20);}else {_gdbb .SkipCells (1);};_fbda :=_gdbb .NewCell ();_fbda .SetHorizontalAlignment (CellHorizontalAlignmentRight );_fbda .SetVerticalAlignment (CellVerticalAlignmentMiddle );_fbda .SetContent (_daag );
return _gdbb .GeneratePageBlocks (_dafa );};

// Insert adds a new text chunk at the specified position in the paragraph.
func (_dcag *StyledParagraph )Insert (index uint ,text string )*TextChunk {_cegb :=uint (len (_dcag ._aacee ));if index > _cegb {index =_cegb ;};_decc :=NewTextChunk (text ,_dcag ._defe );_dcag ._aacee =append (_dcag ._aacee [:index ],append ([]*TextChunk {_decc },_dcag ._aacee [index :]...)...);
_dcag .wrapText ();return _decc ;};

// SetDashPattern sets the dash pattern of the line.
// NOTE: the dash pattern is taken into account only if the style of the
// line is set to dashed.
func (_deeg *Line )SetDashPattern (dashArray []int64 ,dashPhase int64 ){_deeg ._abgaf =dashArray ;_deeg ._fdgafa =dashPhase ;};

// SetMargins sets the Table's left, right, top, bottom margins.
func (_faca *Table )SetMargins (left ,right ,top ,bottom float64 ){_faca ._ddedc .Left =left ;_faca ._ddedc .Right =right ;_faca ._ddedc .Top =top ;_faca ._ddedc .Bottom =bottom ;};

// NewCell makes a new cell and inserts it into the table at the current position.
func (_gfdgb *Table )NewCell ()*TableCell {return _gfdgb .MultiCell (1,1)};

// SetFillOpacity sets the fill opacity.
func (_cbgb *CurvePolygon )SetFillOpacity (opacity float64 ){_cbgb ._eccc =opacity };

// SetMargins sets the margins TOC line.
func (_bcgfg *TOCLine )SetMargins (left ,right ,top ,bottom float64 ){_bcgfg ._gcdc =left ;_gcccf :=&_bcgfg ._cfbag ._ddaff ;_gcccf .Left =_bcgfg ._gcdc +float64 (_bcgfg ._cfbg -1)*_bcgfg ._aageb ;_gcccf .Right =right ;_gcccf .Top =top ;_gcccf .Bottom =bottom ;
};

// SetFillColor sets the fill color for the path.
func (_feb *FilledCurve )SetFillColor (color Color ){_feb ._fdgaf =color };func _dfdfb (_dbga []_f .Point )*Polyline {return &Polyline {_eadfd :&_f .Polyline {Points :_dbga ,LineColor :_fd .NewPdfColorDeviceRGB (0,0,0),LineWidth :1.0},_cfff :1.0};};

// GeneratePageBlocks draws the chart onto a block.
func (_cbgd *Chart )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fgfa :=ctx ;_bff :=_cbgd ._ebe .IsRelative ();var _abf []*Block ;if _bff {_aeg :=1.0;_gdg :=_cbgd ._gecd .Top ;if float64 (_cbgd ._gebc .Height ())> ctx .Height -_cbgd ._gecd .Top {_abf =[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y )};
var _aedcb error ;if _ ,ctx ,_aedcb =_ebaa ().GeneratePageBlocks (ctx );_aedcb !=nil {return nil ,ctx ,_aedcb ;};_gdg =0;};ctx .X +=_cbgd ._gecd .Left +_aeg ;ctx .Y +=_gdg ;ctx .Width -=_cbgd ._gecd .Left +_cbgd ._gecd .Right +2*_aeg ;ctx .Height -=_gdg ;
_cbgd ._gebc .SetWidth (int (ctx .Width ));}else {ctx .X =_cbgd ._eccaa ;ctx .Y =_cbgd ._eed ;};_fdcc :=_af .NewContentCreator ();_fdcc .Translate (0,ctx .PageHeight );_fdcc .Scale (1,-1);_fdcc .Translate (ctx .X ,ctx .Y );_edc :=NewBlock (ctx .PageWidth ,ctx .PageHeight );
_cbgd ._gebc .Render (_fe .NewRenderer (_fdcc ,_edc ._dab ),nil );if _fbe :=_edc .addContentsByString (_fdcc .String ());_fbe !=nil {return nil ,ctx ,_fbe ;};if _bff {_dbec :=_cbgd .Height ()+_cbgd ._gecd .Bottom ;ctx .Y +=_dbec ;ctx .Height -=_dbec ;}else {ctx =_fgfa ;
};_abf =append (_abf ,_edc );return _abf ,ctx ,nil ;};func _gfbc (_cgbed *Table ,_fccgf DrawContext )([]*Block ,DrawContext ,error ){var _baefe []*Block ;_fbeaf :=NewBlock (_fccgf .PageWidth ,_fccgf .PageHeight );_cgbed .updateRowHeights (_fccgf .Width -_cgbed ._ddedc .Left -_cgbed ._ddedc .Right );
_bfbeg :=_cgbed ._ddedc .Top ;if _cgbed ._aacdb .IsRelative ()&&!_cgbed ._bfddd {_aafga :=_cgbed .Height ();if _aafga > _fccgf .Height -_cgbed ._ddedc .Top &&_aafga <=_fccgf .PageHeight -_fccgf .Margins .Top -_fccgf .Margins .Bottom {_baefe =[]*Block {NewBlock (_fccgf .PageWidth ,_fccgf .PageHeight -_fccgf .Y )};
var _fggc error ;if _ ,_fccgf ,_fggc =_ebaa ().GeneratePageBlocks (_fccgf );_fggc !=nil {return nil ,_fccgf ,_fggc ;};_bfbeg =0;};};_ffcg :=_fccgf ;if _cgbed ._aacdb .IsAbsolute (){_fccgf .X =_cgbed ._dfaff ;_fccgf .Y =_cgbed ._dgcd ;}else {_fccgf .X +=_cgbed ._ddedc .Left ;
_fccgf .Y +=_bfbeg ;_fccgf .Width -=_cgbed ._ddedc .Left +_cgbed ._ddedc .Right ;_fccgf .Height -=_bfbeg ;};_dceg :=_fccgf .Width ;_fdag :=_fccgf .X ;_fbaf :=_fccgf .Y ;_efbb :=_fccgf .Height ;_dgca :=0;_cecg ,_cfdbb :=-1,-1;if _cgbed ._gfbff {for _deba ,_effgef :=range _cgbed ._abgf {if _effgef ._egdb < _cgbed ._egcg {continue ;
};if _effgef ._egdb > _cgbed ._ffefb {break ;};if _cecg < 0{_cecg =_deba ;};_cfdbb =_deba ;};};var (_agef bool ;_ceda int ;_fdcfg int ;_ceagc bool ;_fgbg int ;_eabbgf error ;);for _abbfb :=0;_abbfb < len (_cgbed ._abgf );_abbfb ++{_cfef :=_cgbed ._abgf [_abbfb ];
_gbcbd :=_cfef .width (_cgbed ._geefa ,_dceg );_cdfe :=float64 (0.0);for _gdaag :=0;_gdaag < _cfef ._gbgc -1;_gdaag ++{_cdfe +=_cgbed ._geefa [_gdaag ]*_dceg ;};_cedg :=float64 (0.0);for _cfaf :=_dgca ;_cfaf < _cfef ._egdb -1;_cfaf ++{_cedg +=_cgbed ._ecgdb [_cfaf ];
};_fccgf .Height =_efbb -_cedg ;_adbbe :=float64 (0.0);for _febb :=0;_febb < _cfef ._fdbd ;_febb ++{_adbbe +=_cgbed ._ecgdb [_cfef ._egdb +_febb -1];};_fbcef :=_ceagc &&_cfef ._egdb !=_fgbg ;_fgbg =_cfef ._egdb ;if _fbcef ||_adbbe > _fccgf .Height {if _cgbed ._gbfbcd &&!_ceagc {_ceagc ,_eabbgf =_cgbed .wrapRow (_abbfb ,_fccgf ,_dceg );
if _eabbgf !=nil {return nil ,_fccgf ,_eabbgf ;};if _ceagc {_abbfb --;continue ;};};_baefe =append (_baefe ,_fbeaf );_fbeaf =NewBlock (_fccgf .PageWidth ,_fccgf .PageHeight );_fdag =_fccgf .Margins .Left +_cgbed ._ddedc .Left ;_fbaf =_fccgf .Margins .Top ;
_fccgf .Height =_fccgf .PageHeight -_fccgf .Margins .Top -_fccgf .Margins .Bottom ;_fccgf .Page ++;_efbb =_fccgf .Height ;_dgca =_cfef ._egdb -1;_cedg =0;_ceagc =false ;if _cgbed ._gfbff &&_cecg >=0{_ceda =_abbfb ;_abbfb =_cecg -1;_fdcfg =_dgca ;_dgca =_cgbed ._egcg -1;
_agef =true ;continue ;};if _fbcef {_abbfb --;continue ;};};_fccgf .Width =_gbcbd ;_fccgf .X =_fdag +_cdfe ;_fccgf .Y =_fbaf +_cedg ;_fgfc :=_ddaf (_fccgf .X ,_fccgf .Y ,_gbcbd ,_adbbe );if _cfef ._dacbb !=nil {_fgfc .SetFillColor (_cfef ._dacbb );};_fgfc .LineStyle =_cfef ._gcgge ;
_fgfc ._cdbb =_cfef ._bdfae ;_fgfc ._ded =_cfef ._feaad ;_fgfc ._acaa =_cfef ._gfde ;_fgfc ._agcc =_cfef ._acbf ;if _cfef ._beac !=nil {_fgfc .SetColorLeft (_cfef ._beac );};if _cfef ._fceg !=nil {_fgfc .SetColorBottom (_cfef ._fceg );};if _cfef ._aece !=nil {_fgfc .SetColorRight (_cfef ._aece );
};if _cfef ._babc !=nil {_fgfc .SetColorTop (_cfef ._babc );};_fgfc .SetWidthBottom (_cfef ._aefg );_fgfc .SetWidthLeft (_cfef ._fbcg );_fgfc .SetWidthRight (_cfef ._aaee );_fgfc .SetWidthTop (_cfef ._dfacc );_gbfd :=_fbeaf .Draw (_fgfc );if _gbfd !=nil {_bg .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_gbfd );
};if _cfef ._edcdf !=nil {_aabb :=_cfef ._edcdf .Width ();_aaeab :=_cfef ._edcdf .Height ();_gcbaf :=0.0;switch _aefc :=_cfef ._edcdf .(type ){case *Paragraph :if _aefc ._bbde {_aabb =_aefc .getMaxLineWidth ()/1000.0;};_aabb +=_aefc ._gadg .Left +_aefc ._gadg .Right ;
_aaeab +=_aefc ._gadg .Top +_aefc ._gadg .Bottom ;case *StyledParagraph :if _aefc ._gffg {_aabb =_aefc .getMaxLineWidth ()/1000.0;};_gacef ,_eaga ,_ebfac :=_aefc .getLineMetrics (0);_agegd ,_gagb :=_gacef *_aefc ._beea ,_eaga *_aefc ._beea ;if _aefc ._ccgf ==TextVerticalAlignmentCenter {_gcbaf =_gagb -(_eaga +(_gacef +_ebfac -_eaga )/2+(_gagb -_eaga )/2);
};if len (_aefc ._cdeae )==1{_aaeab =_agegd ;}else {_aaeab =_aaeab -_gagb +_agegd ;};_gcbaf +=_agegd -_gagb ;switch _cfef ._dagd {case CellVerticalAlignmentTop :_gcbaf +=_agegd *0.5;case CellVerticalAlignmentBottom :_gcbaf -=_agegd *0.5;};_aabb +=_aefc ._ddaff .Left +_aefc ._ddaff .Right ;
_aaeab +=_aefc ._ddaff .Top +_aefc ._ddaff .Bottom ;case *Table :_aabb =_gbcbd ;case *List :_aabb =_gbcbd ;case *Division :_aabb =_gbcbd ;case *Chart :_aabb =_gbcbd ;case *Line :_aaeab +=_aefc ._eebc .Top +_aefc ._eebc .Bottom ;_gcbaf -=_aefc .Height ()/2;
};switch _cfef ._egde {case CellHorizontalAlignmentLeft :_fccgf .X +=_cfef ._bgbg ;_fccgf .Width -=_cfef ._bgbg ;case CellHorizontalAlignmentCenter :if _fffb :=_gbcbd -_aabb ;_fffb > 0{_fccgf .X +=_fffb /2;_fccgf .Width -=_fffb /2;};case CellHorizontalAlignmentRight :if _gbcbd > _aabb {_fccgf .X =_fccgf .X +_gbcbd -_aabb -_cfef ._bgbg ;
_fccgf .Width -=_cfef ._bgbg ;};};_dcdea :=_fccgf .Y ;_bccg :=_fccgf .Height ;_fccgf .Y +=_gcbaf ;switch _cfef ._dagd {case CellVerticalAlignmentTop :case CellVerticalAlignmentMiddle :if _cfbd :=_adbbe -_aaeab ;_cfbd > 0{_fccgf .Y +=_cfbd /2;_fccgf .Height -=_cfbd /2;
};case CellVerticalAlignmentBottom :if _adbbe > _aaeab {_fccgf .Y =_fccgf .Y +_adbbe -_aaeab ;_fccgf .Height =_adbbe ;};};_dgegg :=_fbeaf .DrawWithContext (_cfef ._edcdf ,_fccgf );if _dgegg !=nil {_bg .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_dgegg );
};_fccgf .Y =_dcdea ;_fccgf .Height =_bccg ;};_fccgf .Y +=_adbbe ;_fccgf .Height -=_adbbe ;if _agef &&_abbfb +1> _cfdbb {_fbaf +=_cedg +_adbbe ;_efbb -=_adbbe +_cedg ;_dgca =_fdcfg ;_abbfb =_ceda -1;_agef =false ;};};_baefe =append (_baefe ,_fbeaf );if _cgbed ._aacdb .IsAbsolute (){return _baefe ,_ffcg ,nil ;
};_fccgf .X =_ffcg .X ;_fccgf .Width =_ffcg .Width ;_fccgf .Y +=_cgbed ._ddedc .Bottom ;_fccgf .Height -=_cgbed ._ddedc .Bottom ;return _baefe ,_fccgf ,nil ;};func (_gcfad *Image )applyFitMode (_caad float64 ){_caad -=_gcfad ._cdda .Left +_gcfad ._cdda .Right ;
switch _gcfad ._dffa {case FitModeFillWidth :_gcfad .ScaleToWidth (_caad );};};

// ColorCMYKFromArithmetic creates a Color from arithmetic color values (0-1).
// Example:
//   green := ColorCMYKFromArithmetic(1.0, 0.0, 1.0, 0.0)
func ColorCMYKFromArithmetic (c ,m ,y ,k float64 )Color {return cmykColor {_fdga :_da .Max (_da .Min (c ,1.0),0.0),_gaa :_da .Max (_da .Min (m ,1.0),0.0),_fdgef :_da .Max (_da .Min (y ,1.0),0.0),_dac :_da .Max (_da .Min (k ,1.0),0.0)};};

// Division is a container component which can wrap across multiple pages.
// Currently supported drawable components:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
//
// The component stacking behavior is vertical, where the drawables are drawn
// on top of each other.
type Division struct{_bcfe []VectorDrawable ;_abbfg Positioning ;_cfe Margins ;_gbaa Margins ;_acea bool ;_egac bool ;_fefg *Background ;};

// Terms returns the terms and conditions section of the invoice as a
// title-content pair.
func (_cagcf *Invoice )Terms ()(string ,string ){return _cagcf ._eceg [0],_cagcf ._eceg [1]};var PPI float64 =72;

// Height returns the height of the line.
func (_gebg *Line )Height ()float64 {_gaff :=_gebg ._gbff ;if _gebg ._gdee ==_gebg ._fdba {_gaff /=2;};return _da .Abs (_gebg ._gfcfb -_gebg ._dbcb )+_gaff ;};

// SetBorder sets the cell's border style.
func (_dbed *TableCell )SetBorder (side CellBorderSide ,style CellBorderStyle ,width float64 ){if style ==CellBorderStyleSingle &&side ==CellBorderSideAll {_dbed ._bdfae =CellBorderStyleSingle ;_dbed ._fbcg =width ;_dbed ._acbf =CellBorderStyleSingle ;
_dbed ._aefg =width ;_dbed ._feaad =CellBorderStyleSingle ;_dbed ._aaee =width ;_dbed ._gfde =CellBorderStyleSingle ;_dbed ._dfacc =width ;}else if style ==CellBorderStyleDouble &&side ==CellBorderSideAll {_dbed ._bdfae =CellBorderStyleDouble ;_dbed ._fbcg =width ;
_dbed ._acbf =CellBorderStyleDouble ;_dbed ._aefg =width ;_dbed ._feaad =CellBorderStyleDouble ;_dbed ._aaee =width ;_dbed ._gfde =CellBorderStyleDouble ;_dbed ._dfacc =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideLeft {_dbed ._bdfae =style ;
_dbed ._fbcg =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideBottom {_dbed ._acbf =style ;_dbed ._aefg =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideRight {_dbed ._feaad =style ;
_dbed ._aaee =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideTop {_dbed ._gfde =style ;_dbed ._dfacc =width ;};};

// SetStyleTop sets border style for top side.
func (_efb *border )SetStyleTop (style CellBorderStyle ){_efb ._acaa =style };const (TextVerticalAlignmentBaseline TextVerticalAlignment =iota ;TextVerticalAlignmentCenter ;);

// ColorRGBFromHex converts color hex code to rgb color for using with creator.
// NOTE: If there is a problem interpreting the string, then will use black color and log a debug message.
// Example hex code: #ffffff -> (1,1,1) white.
func ColorRGBFromHex (hexStr string )Color {_dage :=rgbColor {};if (len (hexStr )!=4&&len (hexStr )!=7)||hexStr [0]!='#'{_bg .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _dage ;
};var _gfcf ,_dfb ,_eacd int ;if len (hexStr )==4{var _eggg ,_bfc ,_bcf int ;_aeb ,_effg :=_gg .Sscanf (hexStr ,"\u0023\u0025\u0031\u0078\u0025\u0031\u0078\u0025\u0031\u0078",&_eggg ,&_bfc ,&_bcf );if _effg !=nil {_bg .Log .Debug ("\u0049\u006e\u0076a\u006c\u0069\u0064\u0020h\u0065\u0078\u0020\u0063\u006f\u0064\u0065:\u0020\u0025\u0073\u002c\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076",hexStr ,_effg );
return _dage ;};if _aeb !=3{_bg .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _dage ;};_gfcf =_eggg *16+_eggg ;_dfb =_bfc *16+_bfc ;_eacd =_bcf *16+_bcf ;}else {_bcb ,_aaed :=_gg .Sscanf (hexStr ,"\u0023\u0025\u0032\u0078\u0025\u0032\u0078\u0025\u0032\u0078",&_gfcf ,&_dfb ,&_eacd );
if _aaed !=nil {_bg .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _dage ;};if _bcb !=3{_bg .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0063\u006f\u0064\u0065\u003a\u0020\u0025\u0073,\u0020\u006e\u0020\u0021\u003d\u0020\u0033 \u0028\u0025\u0064\u0029",hexStr ,_bcb );
return _dage ;};};_agbd :=float64 (_gfcf )/255.0;_egbd :=float64 (_dfb )/255.0;_bgae :=float64 (_eacd )/255.0;_dage ._edcf =_agbd ;_dage ._ebcg =_egbd ;_dage ._abd =_bgae ;return _dage ;};

// IsAbsolute checks if the positioning is absolute.
func (_edfb Positioning )IsAbsolute ()bool {return _edfb ==PositionAbsolute };

// SetStyle sets the style of the line (solid or dashed).
func (_ddea *Line )SetStyle (style _f .LineStyle ){_ddea ._gbafg =style };

// PageBreak represents a page break for a chapter.
type PageBreak struct{};

// AddAnnotation adds an annotation to the current block.
// The annotation will be added to the page the block will be rendered on.
func (_ggf *Block )AddAnnotation (annotation *_fd .PdfAnnotation ){for _ ,_ca :=range _ggf ._ag {if _ca ==annotation {return ;};};_ggf ._ag =append (_ggf ._ag ,annotation );};

// RotateDeg rotates the current active page by angle degrees.  An error is returned on failure,
// which can be if there is no currently active page, or the angleDeg is not a multiple of 90 degrees.
func (_egca *Creator )RotateDeg (angleDeg int64 )error {_abda :=_egca .getActivePage ();if _abda ==nil {_bg .Log .Debug ("F\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0065\u003a\u0020\u006e\u006f\u0020p\u0061\u0067\u0065\u0020\u0063\u0075\u0072\u0072\u0065\u006etl\u0079\u0020\u0061c\u0074i\u0076\u0065");
return _c .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};if angleDeg %90!=0{_bg .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0050\u0061\u0067e\u0020\u0072\u006f\u0074\u0061\u0074\u0069on\u0020\u0061\u006e\u0067l\u0065\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006dul\u0074\u0069p\u006c\u0065\u0020\u006f\u0066\u0020\u0039\u0030");
return _c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};var _dad int64 ;if _abda .Rotate !=nil {_dad =*(_abda .Rotate );};_dad +=angleDeg ;_abda .Rotate =&_dad ;return nil ;};func (_bddef *Invoice )drawInformation ()*Table {_gdgc :=_fbcc (2);
_eeebd :=append ([][2]*InvoiceCell {_bddef ._daf ,_bddef ._agbag ,_bddef ._aagg },_bddef ._fegc ...);for _ ,_dbdgd :=range _eeebd {_eegg ,_cafd :=_dbdgd [0],_dbdgd [1];if _cafd .Value ==""{continue ;};_dace :=_gdgc .NewCell ();_dace .SetBackgroundColor (_eegg .BackgroundColor );
_bddef .setCellBorder (_dace ,_eegg );_geaad :=_ebda (_eegg .TextStyle );_geaad .Append (_eegg .Value );_geaad .SetMargins (0,0,2,1);_dace .SetContent (_geaad );_dace =_gdgc .NewCell ();_dace .SetBackgroundColor (_cafd .BackgroundColor );_bddef .setCellBorder (_dace ,_cafd );
_geaad =_ebda (_cafd .TextStyle );_geaad .Append (_cafd .Value );_geaad .SetMargins (0,0,2,1);_dace .SetContent (_geaad );};return _gdgc ;};func _afdag (_aacd TextStyle )*List {return &List {_ebfga :TextChunk {Text :"\u2022\u0020",Style :_aacd },_ffdc :0,_cdcd :true ,_aebe :PositionRelative ,_cffbd :_aacd };
};

// SetFillOpacity sets the fill opacity.
func (_adbb *Polygon )SetFillOpacity (opacity float64 ){_adbb ._gfac =opacity };

// SetAnnotation sets a annotation on a TextChunk.
func (_gdfc *TextChunk )SetAnnotation (annotation *_fd .PdfAnnotation ){_gdfc ._cgaf =annotation };

// Scale scales Image by a constant factor, both width and height.
func (_ebbg *Image )Scale (xFactor ,yFactor float64 ){_ebbg ._ffab =xFactor *_ebbg ._ffab ;_ebbg ._dbffg =yFactor *_ebbg ._dbffg ;};

// SetTotal sets the total of the invoice.
func (_bfga *Invoice )SetTotal (value string ){_bfga ._gcbg [1].Value =value };

// IsRelative checks if the positioning is relative.
func (_ceed Positioning )IsRelative ()bool {return _ceed ==PositionRelative };

// SetSideBorderColor sets the cell's side border color.
func (_cedfbe *TableCell )SetSideBorderColor (side CellBorderSide ,col Color ){switch side {case CellBorderSideTop :_cedfbe ._babc =col ;case CellBorderSideBottom :_cedfbe ._fceg =col ;case CellBorderSideLeft :_cedfbe ._beac =col ;case CellBorderSideRight :_cedfbe ._aece =col ;
};};

// AppendCurve appends a Bezier curve to the filled curve.
func (_aaff *FilledCurve )AppendCurve (curve _f .CubicBezierCurve )*FilledCurve {_aaff ._gaae =append (_aaff ._gaae ,curve );return _aaff ;};var PPMM =float64 (72*1.0/25.4);

// SetPdfWriterAccessFunc sets a PdfWriter access function/hook.
// Exposes the PdfWriter just prior to writing the PDF.  Can be used to encrypt the output PDF, etc.
//
// Example of encrypting with a user/owner password "password"
// Prior to calling c.WriteFile():
//
// c.SetPdfWriterAccessFunc(func(w *model.PdfWriter) error {
//	userPass := []byte("password")
//	ownerPass := []byte("password")
//	err := w.Encrypt(userPass, ownerPass, nil)
//	return err
// })
//
func (_edea *Creator )SetPdfWriterAccessFunc (pdfWriterAccessFunc func (_eaefg *_fd .PdfWriter )error ){_edea ._aggb =pdfWriterAccessFunc ;};

// SetOutlineTree adds the specified outline tree to the PDF file generated
// by the creator. Adding an external outline tree disables the automatic
// generation of outlines done by the creator for the relevant components.
func (_dbef *Creator )SetOutlineTree (outlineTree *_fd .PdfOutlineTreeNode ){_dbef ._ccdd =outlineTree };

// GeneratePageBlocks generate the Page blocks. Draws the Image on a block, implementing the Drawable interface.
func (_gafgc *Image )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){if _gafgc ._cbec ==nil {if _efcc :=_gafgc .makeXObject ();_efcc !=nil {return nil ,ctx ,_efcc ;};};var _adac []*Block ;_ebcgg :=ctx ;_edg :=NewBlock (ctx .PageWidth ,ctx .PageHeight );
if _gafgc ._feaaf .IsRelative (){_gafgc .applyFitMode (ctx .Width );ctx .X +=_gafgc ._cdda .Left ;ctx .Y +=_gafgc ._cdda .Top ;ctx .Width -=_gafgc ._cdda .Left +_gafgc ._cdda .Right ;ctx .Height -=_gafgc ._cdda .Top +_gafgc ._cdda .Bottom ;if _gafgc ._dbffg > ctx .Height {_adac =append (_adac ,_edg );
_edg =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_egacf :=ctx ;_egacf .Y =ctx .Margins .Top +_gafgc ._cdda .Top ;_egacf .X =ctx .Margins .Left +_gafgc ._cdda .Left ;_egacf .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_gafgc ._cdda .Top -_gafgc ._cdda .Bottom ;
_egacf .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_gafgc ._cdda .Left -_gafgc ._cdda .Right ;ctx =_egacf ;};}else {ctx .X =_gafgc ._cgbe ;ctx .Y =_gafgc ._ead ;};ctx ,_gbfbc :=_cgfg (_edg ,_gafgc ,ctx );if _gbfbc !=nil {return nil ,ctx ,_gbfbc ;
};_adac =append (_adac ,_edg );if _gafgc ._feaaf .IsAbsolute (){ctx =_ebcgg ;}else {ctx .X =_ebcgg .X ;ctx .Width =_ebcgg .Width ;ctx .Y +=_gafgc ._cdda .Bottom ;};return _adac ,ctx ,nil ;};

// TOC returns the table of contents component of the creator.
func (_gfcb *Creator )TOC ()*TOC {return _gfcb ._gcd };

// AppendColumn appends a column to the line items table.
func (_fegg *Invoice )AppendColumn (description string )*InvoiceCell {_gbba :=_fegg .NewColumn (description );_fegg ._dfa =append (_fegg ._dfa ,_gbba );return _gbba ;};const (PositionRelative Positioning =iota ;PositionAbsolute ;);

// AddTextItem appends a new item with the specified text to the list.
// The method creates a styled paragraph with the specified text and returns
// it so that the item style can be customized.
// The method also returns the marker used for the newly added item.
// The marker object can be used to change the text and style of the marker
// for the current item.
func (_dfaa *List )AddTextItem (text string )(*StyledParagraph ,*TextChunk ,error ){_dcfa :=_ebda (_dfaa ._cffbd );_dcfa .Append (text );_acf ,_gaeda :=_dfaa .Add (_dcfa );return _dcfa ,_acf ,_gaeda ;};

// Flip flips the active page on the specified axes.
// If `flipH` is true, the page is flipped horizontally. Similarly, if `flipV`
// is true, the page is flipped vertically. If both are true, the page is
// flipped both horizontally and vertically.
// NOTE: the flip transformations are applied when the creator is finalized,
// which is at write time in most cases.
func (_efc *Creator )Flip (flipH ,flipV bool )error {_afd :=_efc .getActivePage ();if _afd ==nil {return _c .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};_gabfb ,_daga :=_efc ._abfd [_afd ];if !_daga {_gabfb =&pageTransformations {};
_efc ._abfd [_afd ]=_gabfb ;};_gabfb ._ddd =flipH ;_gabfb ._efdc =flipV ;return nil ;};func (_bggdc *TableCell )width (_gfafg []float64 ,_egefb float64 )float64 {_efcgd :=float64 (0.0);for _gfcee :=0;_gfcee < _bggdc ._fafc ;_gfcee ++{_efcgd +=_gfafg [_bggdc ._gbgc +_gfcee -1];
};return _efcgd *_egefb ;};

// InsertColumn inserts a column in the line items table at the specified index.
func (_dacg *Invoice )InsertColumn (index uint ,description string )*InvoiceCell {_dagf :=uint (len (_dacg ._dfa ));if index > _dagf {index =_dagf ;};_dcfg :=_dacg .NewColumn (description );_dacg ._dfa =append (_dacg ._dfa [:index ],append ([]*InvoiceCell {_dcfg },_dacg ._dfa [index :]...)...);
return _dcfg ;};func (_cbgf *Image )makeXObject ()error {_dbdb :=_cbgf ._cceb ;if _dbdb ==nil {_dbdb =_eg .NewFlateEncoder ();};_efdg ,_ecgef :=_fd .NewXObjectImageFromImage (_cbgf ._eaaf ,nil ,_dbdb );if _ecgef !=nil {_bg .Log .Error ("\u0046\u0061\u0069le\u0064\u0020\u0074\u006f\u0020\u0063\u0072\u0065\u0061t\u0065 \u0078o\u0062j\u0065\u0063\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_ecgef );
return _ecgef ;};_cbgf ._cbec =_efdg ;return nil ;};

// HeaderFunctionArgs holds the input arguments to a header drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type HeaderFunctionArgs struct{PageNum int ;TotalPages int ;};

// ColorRGBFrom8bit creates a Color from 8-bit (0-255) r,g,b values.
// Example:
//   red := ColorRGBFrom8Bit(255, 0, 0)
func ColorRGBFrom8bit (r ,g ,b byte )Color {return rgbColor {_edcf :float64 (r )/255.0,_ebcg :float64 (g )/255.0,_abd :float64 (b )/255.0};};const (HorizontalAlignmentLeft HorizontalAlignment =iota ;HorizontalAlignmentCenter ;HorizontalAlignmentRight ;
);

// SetColumns overwrites any columns in the line items table. This should be
// called before AddLine.
func (_bcacf *Invoice )SetColumns (cols []*InvoiceCell ){_bcacf ._dfa =cols };func _edab (_fgegc *Block ,_befa *Paragraph ,_efaea DrawContext )(DrawContext ,error ){_ccbbc :=1;_gabef :=_eg .PdfObjectName ("\u0046\u006f\u006e\u0074"+_g .Itoa (_ccbbc ));
for _fgegc ._dab .HasFontByName (_gabef ){_ccbbc ++;_gabef =_eg .PdfObjectName ("\u0046\u006f\u006e\u0074"+_g .Itoa (_ccbbc ));};_aace :=_fgegc ._dab .SetFontByName (_gabef ,_befa ._geef .ToPdfObject ());if _aace !=nil {return _efaea ,_aace ;};_befa .wrapText ();
_feaf :=_af .NewContentCreator ();_feaf .Add_q ();_ggaf :=_efaea .PageHeight -_efaea .Y -_befa ._bec *_befa ._eabag ;_feaf .Translate (_efaea .X ,_ggaf );if _befa ._bdeb !=0{_feaf .RotateDeg (_befa ._bdeb );};_feaf .Add_BT ().SetNonStrokingColor (_ecb (_befa ._efeg )).Add_Tf (_gabef ,_befa ._bec ).Add_TL (_befa ._bec *_befa ._eabag );
for _acga ,_babd :=range _befa ._gacac {if _acga !=0{_feaf .Add_Tstar ();};_degga :=[]rune (_babd );_dacb :=0.0;_gcec :=0;for _fcea ,_ggad :=range _degga {if _ggad ==' '{_gcec ++;continue ;};if _ggad =='\u000A'{continue ;};_fcddd ,_bcbe :=_befa ._geef .GetRuneMetrics (_ggad );
if !_bcbe {_bg .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006e\u0065\u0020\u0069=\u0025\u0064\u0020\u0072\u0075\u006e\u0065=\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0069n\u0020\u0066\u006f\u006e\u0074\u0020\u0025\u0073\u0020\u0025\u0073",_fcea ,_ggad ,_ggad ,_befa ._geef .BaseFont (),_befa ._geef .Subtype ());
return _efaea ,_c .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");};_dacb +=_befa ._bec *_fcddd .Wx ;};var _gcde []_eg .PdfObject ;_efcee ,_ccaa :=_befa ._geef .GetRuneMetrics (' ');
if !_ccaa {return _efaea ,_c .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};_aaae :=_efcee .Wx ;switch _befa ._adfg {case TextAlignmentJustify :if _gcec > 0&&_acga < len (_befa ._gacac )-1{_aaae =(_befa ._abcd *1000.0-_dacb )/float64 (_gcec )/_befa ._bec ;
};case TextAlignmentCenter :_abdaa :=_dacb +float64 (_gcec )*_aaae *_befa ._bec ;_fgbff :=(_befa ._abcd *1000.0-_abdaa )/2/_befa ._bec ;_gcde =append (_gcde ,_eg .MakeFloat (-_fgbff ));case TextAlignmentRight :_bacd :=_dacb +float64 (_gcec )*_aaae *_befa ._bec ;
_ggba :=(_befa ._abcd *1000.0-_bacd )/_befa ._bec ;_gcde =append (_gcde ,_eg .MakeFloat (-_ggba ));};_eeeeg :=_befa ._geef .Encoder ();var _gddee []byte ;for _ ,_febc :=range _degga {if _febc =='\u000A'{continue ;};if _febc ==' '{if len (_gddee )> 0{_gcde =append (_gcde ,_eg .MakeStringFromBytes (_gddee ));
_gddee =nil ;};_gcde =append (_gcde ,_eg .MakeFloat (-_aaae ));}else {if _ ,_gfcba :=_eeeeg .RuneToCharcode (_febc );!_gfcba {_aace =UnsupportedRuneError {Message :_gg .Sprintf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_febc ,_febc ),Rune :_febc };
_efaea ._fefc =append (_efaea ._fefc ,_aace );_bg .Log .Debug (_aace .Error ());if _efaea ._gfce <=0{continue ;};_febc =_efaea ._gfce ;};_gddee =append (_gddee ,_eeeeg .Encode (string (_febc ))...);};};if len (_gddee )> 0{_gcde =append (_gcde ,_eg .MakeStringFromBytes (_gddee ));
};_feaf .Add_TJ (_gcde ...);};_feaf .Add_ET ();_feaf .Add_Q ();_dgb :=_feaf .Operations ();_dgb .WrapIfNeeded ();_fgegc .addContents (_dgb );if _befa ._gfbe .IsRelative (){_agea :=_befa .Height ();_efaea .Y +=_agea ;_efaea .Height -=_agea ;if _efaea .Inline {_efaea .X +=_befa .Width ()+_befa ._gadg .Right ;
};};return _efaea ,nil ;};

// SetTOC sets the table of content component of the creator.
// This method should be used when building a custom table of contents.
func (_gefe *Creator )SetTOC (toc *TOC ){if toc ==nil {return ;};_gefe ._gcd =toc ;};

// ColorRGBFromArithmetic creates a Color from arithmetic color values (0-1).
// Example:
//   green := ColorRGBFromArithmetic(0.0, 1.0, 0.0)
func ColorRGBFromArithmetic (r ,g ,b float64 )Color {return rgbColor {_edcf :_da .Max (_da .Min (r ,1.0),0.0),_ebcg :_da .Max (_da .Min (g ,1.0),0.0),_abd :_da .Max (_da .Min (b ,1.0),0.0)};};

// SetIndent sets the left offset of the list when nested into another list.
func (_gfgd *List )SetIndent (indent float64 ){_gfgd ._ffdc =indent ;_gfgd ._cdcd =false };

// SetPositioning sets Ellipse's position attribute.
func (_cdef *Ellipse )SetPositioning (position Positioning ){_cdef ._dgad =position };

// Width returns the width of the Paragraph.
func (_bcagd *StyledParagraph )Width ()float64 {if _bcagd ._gffg &&int (_bcagd ._ccf )> 0{return _bcagd ._ccf ;};return _bcagd .getTextWidth ()/1000.0;};

// Add adds a VectorDrawable to the Division container.
// Currently supported VectorDrawables:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
// - *Rectangle
// - *Ellipse
// - *Line
func (_egec *Division )Add (d VectorDrawable )error {switch _fbae :=d .(type ){case *Paragraph ,*StyledParagraph ,*Image ,*Chart ,*Rectangle ,*Ellipse ,*Line ,*Table ,*Division :case containerDrawable :_ggag ,_agaa :=_fbae .ContainerComponent (_egec );
if _agaa !=nil {return _agaa ;};_faaca ,_ecba :=_ggag .(VectorDrawable );if !_ecba {return _gg .Errorf ("\u0072\u0065\u0073\u0075\u006ct\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0061\u0069\u006e\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u002d\u0020\u0025\u0054\u0020\u0064\u006f\u0065\u0073\u006e\u0027\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u0056\u0065c\u0074\u006f\u0072\u0044\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u0020i\u006e\u0074\u0065\u0072\u0066\u0061c\u0065",_ggag );
};d =_faaca ;default:return _c .New ("\u0075\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070e\u0020i\u006e\u0020\u0044\u0069\u0076\u0069\u0073i\u006f\u006e");};_egec ._bcfe =append (_egec ._bcfe ,d );return nil ;};

// AddExternalLink adds a new external link to the paragraph.
// The text parameter represents the text that is displayed and the url
// parameter sets the destionation of the link.
func (_degdb *StyledParagraph )AddExternalLink (text ,url string )*TextChunk {_egbb :=NewTextChunk (text ,_degdb ._edcb );_egbb ._cgaf =_aeegb (url );return _degdb .appendChunk (_egbb );};

// GeneratePageBlocks draws the rectangle on a new block representing the page. Implements the Drawable interface.
func (_bcce *Rectangle )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cedfb :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_ccaaa :=_f .Rectangle {Opacity :1.0,X :_bcce ._acge ,Y :ctx .PageHeight -_bcce ._aedba -_bcce ._efab ,Height :_bcce ._efab ,Width :_bcce ._ddfc ,BorderRadiusTopLeft :_bcce ._dffeg ,BorderRadiusTopRight :_bcce ._acceb ,BorderRadiusBottomLeft :_bcce ._gbbg ,BorderRadiusBottomRight :_bcce ._afba };
if _bcce ._eeedg ==PositionRelative {_ccaaa .X =ctx .X ;_ccaaa .Y =ctx .PageHeight -ctx .Y -_bcce ._efab ;};if _bcce ._gbdd !=nil {_ccaaa .FillEnabled =true ;_ccaaa .FillColor =_ecb (_bcce ._gbdd );};if _bcce ._aabc !=nil &&_bcce ._bcdg > 0{_ccaaa .BorderEnabled =true ;
_ccaaa .BorderColor =_ecb (_bcce ._aabc );_ccaaa .BorderWidth =_bcce ._bcdg ;};_febf ,_dfaf :=_cedfb .setOpacity (_bcce ._abeed ,_bcce ._fbea );if _dfaf !=nil {return nil ,ctx ,_dfaf ;};_ddadd ,_ ,_dfaf :=_ccaaa .Draw (_febf );if _dfaf !=nil {return nil ,ctx ,_dfaf ;
};if _dfaf =_cedfb .addContentsByString (string (_ddadd ));_dfaf !=nil {return nil ,ctx ,_dfaf ;};return []*Block {_cedfb },ctx ,nil ;};

// GeneratePageBlocks draws the curve onto page blocks.
func (_gfdf *Curve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_egef :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_feec :=_af .NewContentCreator ();_feec .Add_q ().Add_w (_gfdf ._dec ).SetStrokingColor (_ecb (_gfdf ._dcaa )).Add_m (_gfdf ._dabe ,ctx .PageHeight -_gfdf ._afb ).Add_v (_gfdf ._gced ,ctx .PageHeight -_gfdf ._fdgf ,_gfdf ._fbad ,ctx .PageHeight -_gfdf ._afbg ).Add_S ().Add_Q ();
_dageg :=_egef .addContentsByString (_feec .String ());if _dageg !=nil {return nil ,ctx ,_dageg ;};return []*Block {_egef },ctx ,nil ;};const (TextOverflowVisible TextOverflow =iota ;TextOverflowHidden ;);func (_dedc *StyledParagraph )getLineMetrics (_dfbdgg int )(_ceb ,_efaa ,_ffg float64 ){if _dedc ._cdeae ==nil ||len (_dedc ._cdeae )==0{_dedc .wrapText ();
};if _dfbdgg < 0||_dfbdgg > len (_dedc ._cdeae )-1{_bg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020p\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u0020\u006c\u0069\u006e\u0065 \u0069\u006e\u0064\u0065\u0078\u0020\u0025\u0064\u002e\u0020\u0052\u0065tu\u0072\u006e\u0069\u006e\u0067\u0020\u0030\u002c\u0020\u0030",_dfbdgg );
return 0,0,0;};_bedg :=_dedc ._cdeae [_dfbdgg ];for _ ,_dgdf :=range _bedg {_dfce ,_geec :=_dgdf .Style .Font .GetFontDescriptor ();if _geec !=nil {_bg .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020U\u006e\u0061\u0062\u006ce t\u006f g\u0065\u0074\u0020\u0066\u006f\u006e\u0074 d\u0065\u0073\u0063\u0072\u0069\u0070\u0074o\u0072");
};var _adcbe ,_cbde float64 ;if _dfce !=nil {if _adcbe ,_geec =_dfce .GetCapHeight ();_geec !=nil {_bg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0067\u0065\u0074 \u0066\u006f\u006e\u0074\u0020\u0043\u0061\u0070\u0048\u0065\u0069\u0067\u0068t\u003a\u0020\u0025\u0076",_geec );
};if _cbde ,_geec =_dfce .GetDescent ();_geec !=nil {_bg .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020U\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0067\u0065t\u0020\u0066\u006f\u006e\u0074\u0020\u0044\u0065\u0073\u0063\u0065\u006et\u003a\u0020\u0025\u0076",_geec );
};};if int (_adcbe )<=0{_bg .Log .Debug ("\u0057\u0041\u0052\u004e\u003a\u0020\u0043\u0061p\u0020\u0048\u0065ig\u0068\u0074\u0020\u006e\u006f\u0074 \u0061\u0076\u0061\u0069\u006c\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0073\u0065\u0074t\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u00310\u0030\u0030");
_adcbe =1000;};if _agca :=_adcbe /1000.0*_dgdf .Style .FontSize ;_agca > _ceb {_ceb =_agca ;};if _eacg :=_cbde /1000.0*_dgdf .Style .FontSize ;_eacg < _ffg {_ffg =_eacg ;};if _aacb :=_dgdf .Style .FontSize ;_aacb > _efaa {_efaa =_aacb ;};};return _ceb ,_efaa ,_ffg ;
};

// SetTitle sets the title of the invoice.
func (_gggd *Invoice )SetTitle (title string ){_gggd ._gaddb =title };

// GeneratePageBlocks draws the rectangle on a new block representing the page.
func (_fcaa *Ellipse )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_ebcf :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_bagae :=_f .Circle {X :_fcaa ._dgedf -_fcaa ._gcf /2,Y :ctx .PageHeight -_fcaa ._ggffb -_fcaa ._ccbf /2,Width :_fcaa ._gcf ,Height :_fcaa ._ccbf ,Opacity :1.0,BorderWidth :_fcaa ._eeec };
if _fcaa ._dgad ==PositionRelative {_bagae .X =ctx .X ;_bagae .Y =ctx .PageHeight -ctx .Y -_fcaa ._ccbf ;};if _fcaa ._fgcg !=nil {_bagae .FillEnabled =true ;_bagae .FillColor =_ecb (_fcaa ._fgcg );};if _fcaa ._bedc !=nil {_bagae .BorderEnabled =false ;
if _fcaa ._eeec > 0{_bagae .BorderEnabled =true ;};_bagae .BorderColor =_ecb (_fcaa ._bedc );_bagae .BorderWidth =_fcaa ._eeec ;};_agba ,_ ,_fffc :=_bagae .Draw ("");if _fffc !=nil {return nil ,ctx ,_fffc ;};_fffc =_ebcf .addContentsByString (string (_agba ));
if _fffc !=nil {return nil ,ctx ,_fffc ;};return []*Block {_ebcf },ctx ,nil ;};

// Lines returns all the lines the table of contents has.
func (_fabd *TOC )Lines ()[]*TOCLine {return _fabd ._bgbaf };

// EnableFontSubsetting enables font subsetting for `font` when the creator output is written to file.
// Embeds only the subset of the runes/glyphs that are actually used to display the file.
// Subsetting can reduce the size of fonts significantly.
func (_cbba *Creator )EnableFontSubsetting (font *_fd .PdfFont ){_cbba ._gbfa =append (_cbba ._gbfa ,font );};

// SetFitMode sets the fit mode of the line.
// NOTE: The fit mode is only applied if relative positioning is used.
func (_bfagb *Line )SetFitMode (fitMode FitMode ){_bfagb ._edbbc =fitMode };

// TextRenderingMode determines whether showing text shall cause glyph
// outlines to be stroked, filled, used as a clipping boundary, or some
// combination of the three.
// See section 9.3 "Text State Parameters and Operators" and
// Table 106 (pp. 254-255 PDF32000_2008).
type TextRenderingMode int ;

// NewTOC creates a new table of contents.
func (_gcbe *Creator )NewTOC (title string )*TOC {_agbf :=_gcbe .NewTextStyle ();_agbf .Font =_gcbe ._egce ;return _bfeg (title ,_gcbe .NewTextStyle (),_agbf );};

// AddLine appends a new line to the invoice line items table.
func (_abegg *Invoice )AddLine (values ...string )[]*InvoiceCell {_dbdc :=len (_abegg ._dfa );var _ebgd []*InvoiceCell ;for _accf ,_cbgda :=range values {_cdcbg :=_abegg .newCell (_cbgda ,_abegg ._dddg );if _accf < _dbdc {_cdcbg .Alignment =_abegg ._dfa [_accf ].Alignment ;
};_ebgd =append (_ebgd ,_cdcbg );};_abegg ._deff =append (_abegg ._deff ,_ebgd );return _ebgd ;};

// Drawable is a widget that can be used to draw with the Creator.
type Drawable interface{

// GeneratePageBlocks draw onto blocks representing Page contents. As the content can wrap over many pages, multiple
// templates are returned, one per Page.  The function also takes a draw context containing information
// where to draw (if relative positioning) and the available height to draw on accounting for Margins etc.
GeneratePageBlocks (_aggbg DrawContext )([]*Block ,DrawContext ,error );};

// InvoiceCellProps holds all style properties for an invoice cell.
type InvoiceCellProps struct{TextStyle TextStyle ;Alignment CellHorizontalAlignment ;BackgroundColor Color ;BorderColor Color ;BorderWidth float64 ;BorderSides []CellBorderSide ;};

// Width is not used as the division component is designed to fill all the
// available space, depending on the context. Returns 0.
func (_bafa *Division )Width ()float64 {return 0};

// SetSellerAddress sets the seller address of the invoice.
func (_fagc *Invoice )SetSellerAddress (address *InvoiceAddress ){_fagc ._bdde =address };func _abdde (_beee string )([]string ,error ){_fabe :=[]rune (_beee );_ffba :=_dc .NewScanner (_fabe );var (_efee []string ;_cfebb []rune ;);for _acecd :=0;_acecd < len (_fabe );
_acecd ++{_ ,_bbeg ,_adegfc :=_ffba .Next ();if _adegfc !=nil {return nil ,_adegfc ;};if _bbeg ==_dc .BreakProhibited ||_ga .IsSpace (_fabe [_acecd ]){_cfebb =append (_cfebb ,_fabe [_acecd ]);if _ga .IsSpace (_fabe [_acecd ]){_efee =append (_efee ,string (_cfebb ));
_cfebb =[]rune {};};continue ;}else {if len (_cfebb )> 0{_efee =append (_efee ,string (_cfebb ));};_cfebb =[]rune {_fabe [_acecd ]};};};if len (_cfebb )> 0{_efee =append (_efee ,string (_cfebb ));};return _efee ,nil ;};

// AddressHeadingStyle returns the style properties used to render the
// heading of the invoice address sections.
func (_dcbd *Invoice )AddressHeadingStyle ()TextStyle {return _dcbd ._ebac };

// Margins returns the margins of the list: left, right, top, bottom.
func (_ccac *List )Margins ()(float64 ,float64 ,float64 ,float64 ){return _ccac ._edgd .Left ,_ccac ._edgd .Right ,_ccac ._edgd .Top ,_ccac ._edgd .Bottom ;};

// GeneratePageBlocks generates the page blocks for the Division component.
// Multiple blocks are generated if the contents wrap over multiple pages.
func (_cdea *Division )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var (_ggdd []*Block ;_eaba bool ;_dedg error ;_cbca =_cdea ._abbfg .IsRelative ();_ecgc =_cdea ._cfe .Top ;);if _cbca &&!_cdea ._egac &&!_cdea ._acea {_fceb :=_cdea .ctxHeight (ctx .Width );
if _fceb > ctx .Height -_cdea ._cfe .Top &&_fceb <=ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom {if _ggdd ,ctx ,_dedg =_ebaa ().GeneratePageBlocks (ctx );_dedg !=nil {return nil ,ctx ,_dedg ;};_eaba =true ;_ecgc =0;};};_ecgee :=ctx ;_afab :=ctx ;
if _cbca {ctx .X +=_cdea ._cfe .Left ;ctx .Y +=_ecgc ;ctx .Width -=_cdea ._cfe .Left +_cdea ._cfe .Right ;ctx .Height -=_ecgc ;_afab =ctx ;ctx .X +=_cdea ._gbaa .Left ;ctx .Y +=_cdea ._gbaa .Top ;ctx .Width -=_cdea ._gbaa .Left +_cdea ._gbaa .Right ;ctx .Height -=_cdea ._gbaa .Top ;
ctx .Margins .Top +=_cdea ._gbaa .Top ;ctx .Margins .Bottom +=_cdea ._gbaa .Bottom ;ctx .Margins .Left +=_cdea ._cfe .Left +_cdea ._gbaa .Left ;ctx .Margins .Right +=_cdea ._cfe .Right +_cdea ._gbaa .Right ;};ctx .Inline =_cdea ._acea ;_gde :=ctx ;_gaed :=ctx ;
var _acce float64 ;for _ ,_adegf :=range _cdea ._bcfe {if ctx .Inline {if (ctx .X -_gde .X )+_adegf .Width ()<=ctx .Width {ctx .Y =_gaed .Y ;ctx .Height =_gaed .Height ;}else {ctx .X =_gde .X ;ctx .Width =_gde .Width ;_gaed .Y +=_acce ;_gaed .Height -=_acce ;
_acce =0;};};_ceedf ,_abfb ,_cfcg :=_adegf .GeneratePageBlocks (ctx );if _cfcg !=nil {_bg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0069\u006eg\u0020p\u0061\u0067\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073\u003a\u0020\u0025\u0076",_cfcg );
return nil ,ctx ,_cfcg ;};if len (_ceedf )< 1{continue ;};if len (_ggdd )> 0{_ggdd [len (_ggdd )-1].mergeBlocks (_ceedf [0]);_ggdd =append (_ggdd ,_ceedf [1:]...);}else {if _dgef :=_ceedf [0]._ba ;_dgef ==nil ||len (*_dgef )==0{_eaba =true ;};_ggdd =append (_ggdd ,_ceedf [0:]...);
};if ctx .Inline {if ctx .Page !=_abfb .Page {_gde .Y =ctx .Margins .Top ;_gde .Height =ctx .PageHeight -ctx .Margins .Top ;_gaed .Y =_gde .Y ;_gaed .Height =_gde .Height ;_acce =_abfb .Height -_gde .Height ;}else {if _gcbd :=ctx .Height -_abfb .Height ;
_gcbd > _acce {_acce =_gcbd ;};};}else {_abfb .X =ctx .X ;};ctx =_abfb ;};ctx .Inline =_ecgee .Inline ;ctx .Margins =_ecgee .Margins ;if _cbca {ctx .X =_ecgee .X ;ctx .Width =_ecgee .Width ;ctx .Y +=_cdea ._gbaa .Bottom ;ctx .Height -=_cdea ._gbaa .Bottom ;
};if _cdea ._fefg !=nil {_ggdd ,_dedg =_cdea .drawBackground (_ggdd ,_afab ,ctx ,_eaba );if _dedg !=nil {return nil ,ctx ,_dedg ;};};if _cdea ._abbfg .IsAbsolute (){return _ggdd ,_ecgee ,nil ;};ctx .Y +=_cdea ._cfe .Bottom ;ctx .Height -=_cdea ._cfe .Bottom ;
return _ggdd ,ctx ,nil ;};type border struct{_fgbb float64 ;_bcg float64 ;_bef float64 ;_fef float64 ;_cfa Color ;_abe Color ;_agf float64 ;_fea Color ;_gea float64 ;_dce Color ;_fdeg float64 ;_ebb Color ;_bfb float64 ;LineStyle _f .LineStyle ;_cdbb CellBorderStyle ;
_ded CellBorderStyle ;_acaa CellBorderStyle ;_agcc CellBorderStyle ;};

// Height returns Rectangle's document height.
func (_acdab *Rectangle )Height ()float64 {return _acdab ._efab };

// SetPageMargins sets the page margins: left, right, top, bottom.
// The default page margins are 10% of document width.
func (_aaga *Creator )SetPageMargins (left ,right ,top ,bottom float64 ){_aaga ._bdbc .Left =left ;_aaga ._bdbc .Right =right ;_aaga ._bdbc .Top =top ;_aaga ._bdbc .Bottom =bottom ;};

// SetWidth sets the the Paragraph width. This is essentially the wrapping width,
// i.e. the width the text can extend to prior to wrapping over to next line.
func (_cfge *StyledParagraph )SetWidth (width float64 ){_cfge ._ccf =width ;_cfge .wrapText ()};func (_cceag *Invoice )generateLineBlocks (_aafg DrawContext )([]*Block ,DrawContext ,error ){_bbgdc :=_fbcc (len (_cceag ._dfa ));_bbgdc .SetMargins (0,0,25,0);
for _ ,_efce :=range _cceag ._dfa {_eagg :=_ebda (_efce .TextStyle );_eagg .SetMargins (0,0,1,0);_eagg .Append (_efce .Value );_dffg :=_bbgdc .NewCell ();_dffg .SetHorizontalAlignment (_efce .Alignment );_dffg .SetBackgroundColor (_efce .BackgroundColor );
_cceag .setCellBorder (_dffg ,_efce );_dffg .SetContent (_eagg );};for _ ,_ebfa :=range _cceag ._deff {for _ ,_aceb :=range _ebfa {_cbaee :=_ebda (_aceb .TextStyle );_cbaee .SetMargins (0,0,3,2);_cbaee .Append (_aceb .Value );_cgbf :=_bbgdc .NewCell ();
_cgbf .SetHorizontalAlignment (_aceb .Alignment );_cgbf .SetBackgroundColor (_aceb .BackgroundColor );_cceag .setCellBorder (_cgbf ,_aceb );_cgbf .SetContent (_cbaee );};};return _bbgdc .GeneratePageBlocks (_aafg );};

// Curve represents a cubic Bezier curve with a control point.
type Curve struct{_dabe float64 ;_afb float64 ;_gced float64 ;_fdgf float64 ;_fbad float64 ;_afbg float64 ;_dcaa Color ;_dec float64 ;};

// NewCellProps returns the default properties of an invoice cell.
func (_fedg *Invoice )NewCellProps ()InvoiceCellProps {_dgg :=ColorRGBFrom8bit (255,255,255);return InvoiceCellProps {TextStyle :_fedg ._fbadd ,Alignment :CellHorizontalAlignmentLeft ,BackgroundColor :_dgg ,BorderColor :_dgg ,BorderWidth :1,BorderSides :[]CellBorderSide {CellBorderSideAll }};
};

// SetLineMargins sets the margins for all new lines of the table of contents.
func (_eecba *TOC )SetLineMargins (left ,right ,top ,bottom float64 ){_aafgd :=&_eecba ._ceeac ;_aafgd .Left =left ;_aafgd .Right =right ;_aafgd .Top =top ;_aafgd .Bottom =bottom ;};

// GetCoords returns the (x1, y1), (x2, y2) points defining the Line.
func (_adgb *Line )GetCoords ()(float64 ,float64 ,float64 ,float64 ){return _adgb ._gdee ,_adgb ._dbcb ,_adgb ._fdba ,_adgb ._gfcfb ;};

// NewImage create a new image from a unidoc image (model.Image).
func (_bafc *Creator )NewImage (img *_fd .Image )(*Image ,error ){return _ebcdc (img )};

// SetEnableWrap sets the line wrapping enabled flag.
func (_eaea *StyledParagraph )SetEnableWrap (enableWrap bool ){_eaea ._gffg =enableWrap ;_eaea ._bcgg =false ;};

// DrawFooter sets a function to draw a footer on created output pages.
func (_bfad *Creator )DrawFooter (drawFooterFunc func (_bfcb *Block ,_ddad FooterFunctionArgs )){_bfad ._gca =drawFooterFunc ;};

// NewPolyline creates a new polyline.
func (_bgb *Creator )NewPolyline (points []_f .Point )*Polyline {return _dfdfb (points )};

// SetRowHeight sets the height for a specified row.
func (_egebc *Table )SetRowHeight (row int ,h float64 )error {if row < 1||row > len (_egebc ._ecgdb ){return _c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_egebc ._ecgdb [row -1]=h ;return nil ;
};

// ScaleToWidth scale Image to a specified width w, maintaining the aspect ratio.
func (_dcfd *Image )ScaleToWidth (w float64 ){_gffb :=_dcfd ._dbffg /_dcfd ._ffab ;_dcfd ._ffab =w ;_dcfd ._dbffg =w *_gffb ;};const (CellHorizontalAlignmentLeft CellHorizontalAlignment =iota ;CellHorizontalAlignmentCenter ;CellHorizontalAlignmentRight ;
);

// SetWidth sets the the Paragraph width. This is essentially the wrapping width, i.e. the width the
// text can extend to prior to wrapping over to next line.
func (_gfdg *Paragraph )SetWidth (width float64 ){_gfdg ._abcd =width ;_gfdg .wrapText ()};func _cgfc (_fgbf [][]_f .CubicBezierCurve )*CurvePolygon {return &CurvePolygon {_abff :&_f .CurvePolygon {Rings :_fgbf },_eccc :1.0,_gcac :1.0};};func (_fdd *Block )duplicate ()*Block {_gag :=&Block {};
*_gag =*_fdd ;_gcb :=_af .ContentStreamOperations {};_gcb =append (_gcb ,*_fdd ._ba ...);_gag ._ba =&_gcb ;return _gag ;};

// AddInfo is used to append a piece of invoice information in the template
// information table.
func (_dacf *Invoice )AddInfo (description ,value string )(*InvoiceCell ,*InvoiceCell ){_ebffc :=[2]*InvoiceCell {_dacf .newCell (description ,_dacf ._ecga ),_dacf .newCell (value ,_dacf ._ecga )};_dacf ._fegc =append (_dacf ._fegc ,_ebffc );return _ebffc [0],_ebffc [1];
};func (_edcg *Line )computeCoords (_fbba DrawContext )(_badd ,_eea ,_acebd ,_dgcb float64 ){_badd =_fbba .X ;_acebd =_badd +_edcg ._fdba -_edcg ._gdee ;_beaf :=_edcg ._gbff ;if _edcg ._gdee ==_edcg ._fdba {_beaf /=2;};if _edcg ._dbcb < _edcg ._gfcfb {_eea =_fbba .PageHeight -_fbba .Y -_beaf ;
_dgcb =_eea -_edcg ._gfcfb +_edcg ._dbcb ;}else {_dgcb =_fbba .PageHeight -_fbba .Y -_beaf ;_eea =_dgcb -_edcg ._dbcb +_edcg ._gfcfb ;};switch _edcg ._edbbc {case FitModeFillWidth :_acebd =_badd +_fbba .Width ;};return _badd ,_eea ,_acebd ,_dgcb ;};

// FitMode defines resizing options of an object inside a container.
type FitMode int ;

// SetTitleStyle sets the style properties of the invoice title.
func (_gfg *Invoice )SetTitleStyle (style TextStyle ){_gfg ._bfcc =style };

// SetColor sets the line color.
func (_facee *Curve )SetColor (col Color ){_facee ._dcaa =col };

// SetColorTop sets border color for top.
func (_aaf *border )SetColorTop (col Color ){_aaf ._ebb =col };

// SetMargins sets the Block's left, right, top, bottom, margins.
func (_db *Block )SetMargins (left ,right ,top ,bottom float64 ){_db ._ff .Left =left ;_db ._ff .Right =right ;_db ._ff .Top =top ;_db ._ff .Bottom =bottom ;};var (ColorBlack =ColorRGBFromArithmetic (0,0,0);ColorWhite =ColorRGBFromArithmetic (1,1,1);ColorRed =ColorRGBFromArithmetic (1,0,0);
ColorGreen =ColorRGBFromArithmetic (0,1,0);ColorBlue =ColorRGBFromArithmetic (0,0,1);ColorYellow =ColorRGBFromArithmetic (1,1,0););

// ColorCMYKFrom8bit creates a Color from c,m,y,k values (0-100).
// Example:
//   red := ColorCMYKFrom8Bit(0, 100, 100, 0)
func ColorCMYKFrom8bit (c ,m ,y ,k byte )Color {return cmykColor {_fdga :_da .Min (float64 (c ),100)/100.0,_gaa :_da .Min (float64 (m ),100)/100.0,_fdgef :_da .Min (float64 (y ),100)/100.0,_dac :_da .Min (float64 (k ),100)/100.0};};

// SetColorLeft sets border color for left.
func (_fgegg *border )SetColorLeft (col Color ){_fgegg ._abe =col };

// VectorDrawable is a Drawable with a specified width and height.
type VectorDrawable interface{Drawable ;

// Width returns the width of the Drawable.
Width ()float64 ;

// Height returns the height of the Drawable.
Height ()float64 ;};func _dfda ()*FilledCurve {_afbc :=FilledCurve {};_afbc ._gaae =[]_f .CubicBezierCurve {};return &_afbc ;};

// GetMargins returns the Chapter's margin: left, right, top, bottom.
func (_cacf *Chapter )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _cacf ._dcf .Left ,_cacf ._dcf .Right ,_cacf ._dcf .Top ,_cacf ._dcf .Bottom ;};func _efgc (_bbgd ,_gbaf TextStyle )*Invoice {_gabe :=&Invoice {_gaddb :"\u0049N\u0056\u004f\u0049\u0043\u0045",_cddf :"\u002c\u0020",_fbadd :_bbgd ,_ebac :_gbaf };
_gabe ._bdde =&InvoiceAddress {Separator :_gabe ._cddf };_gabe ._ebcb =&InvoiceAddress {Heading :"\u0042i\u006c\u006c\u0020\u0074\u006f",Separator :_gabe ._cddf };_cdcb :=ColorRGBFrom8bit (245,245,245);_fgeb :=ColorRGBFrom8bit (155,155,155);_gabe ._bfcc =_gbaf ;
_gabe ._bfcc .Color =_fgeb ;_gabe ._bfcc .FontSize =20;_gabe ._bfced =_bbgd ;_gabe ._ebca =_gbaf ;_gabe ._bad =_bbgd ;_gabe ._cgff =_gbaf ;_gabe ._ecga =_gabe .NewCellProps ();_gabe ._ecga .BackgroundColor =_cdcb ;_gabe ._ecga .TextStyle =_gbaf ;_gabe ._eebd =_gabe .NewCellProps ();
_gabe ._eebd .TextStyle =_gbaf ;_gabe ._eebd .BackgroundColor =_cdcb ;_gabe ._eebd .BorderColor =_cdcb ;_gabe ._dddg =_gabe .NewCellProps ();_gabe ._dddg .BorderColor =_cdcb ;_gabe ._dddg .BorderSides =[]CellBorderSide {CellBorderSideBottom };_gabe ._dddg .Alignment =CellHorizontalAlignmentRight ;
_gabe ._cabc =_gabe .NewCellProps ();_gabe ._cabc .Alignment =CellHorizontalAlignmentRight ;_gabe ._daf =[2]*InvoiceCell {_gabe .newCell ("\u0049\u006e\u0076\u006f\u0069\u0063\u0065\u0020\u006eu\u006d\u0062\u0065\u0072",_gabe ._ecga ),_gabe .newCell ("",_gabe ._ecga )};
_gabe ._agbag =[2]*InvoiceCell {_gabe .newCell ("\u0044\u0061\u0074\u0065",_gabe ._ecga ),_gabe .newCell ("",_gabe ._ecga )};_gabe ._aagg =[2]*InvoiceCell {_gabe .newCell ("\u0044\u0075\u0065\u0020\u0044\u0061\u0074\u0065",_gabe ._ecga ),_gabe .newCell ("",_gabe ._ecga )};
_gabe ._ceefd =[2]*InvoiceCell {_gabe .newCell ("\u0053\u0075\u0062\u0074\u006f\u0074\u0061\u006c",_gabe ._cabc ),_gabe .newCell ("",_gabe ._cabc )};_bgba :=_gabe ._cabc ;_bgba .TextStyle =_gbaf ;_bgba .BackgroundColor =_cdcb ;_bgba .BorderColor =_cdcb ;
_gabe ._gcbg =[2]*InvoiceCell {_gabe .newCell ("\u0054\u006f\u0074a\u006c",_bgba ),_gabe .newCell ("",_bgba )};_gabe ._ecbb =[2]string {"\u004e\u006f\u0074e\u0073",""};_gabe ._eceg =[2]string {"T\u0065r\u006d\u0073\u0020\u0061\u006e\u0064\u0020\u0063o\u006e\u0064\u0069\u0074io\u006e\u0073",""};
_gabe ._dfa =[]*InvoiceCell {_gabe .newColumn ("D\u0065\u0073\u0063\u0072\u0069\u0070\u0074\u0069\u006f\u006e",CellHorizontalAlignmentLeft ),_gabe .newColumn ("\u0051\u0075\u0061\u006e\u0074\u0069\u0074\u0079",CellHorizontalAlignmentRight ),_gabe .newColumn ("\u0055\u006e\u0069\u0074\u0020\u0070\u0072\u0069\u0063\u0065",CellHorizontalAlignmentRight ),_gabe .newColumn ("\u0041\u006d\u006f\u0075\u006e\u0074",CellHorizontalAlignmentRight )};
return _gabe ;};

// StyledParagraph represents text drawn with a specified font and can wrap across lines and pages.
// By default occupies the available width in the drawing context.
type StyledParagraph struct{_aacee []*TextChunk ;_defe TextStyle ;_edcb TextStyle ;_faf TextAlignment ;_ccgf TextVerticalAlignment ;_beea float64 ;_gffg bool ;_ccf float64 ;_gbda bool ;_bcgg bool ;_ecbea TextOverflow ;_ccaca float64 ;_ddaff Margins ;_bgdg Positioning ;
_fbbag float64 ;_affa float64 ;_bfge float64 ;_ddga float64 ;_cdeae [][]*TextChunk ;_aceea func (_aaba *StyledParagraph ,_cabf DrawContext );};

// SetNoteHeadingStyle sets the style properties used to render the heading
// of the invoice note sections.
func (_cfag *Invoice )SetNoteHeadingStyle (style TextStyle ){_cfag ._cgff =style };

// SetPos sets absolute positioning with specified coordinates.
func (_ccbc *StyledParagraph )SetPos (x ,y float64 ){_ccbc ._bgdg =PositionAbsolute ;_ccbc ._fbbag =x ;_ccbc ._affa =y ;};

// SetNoteStyle sets the style properties used to render the content of the
// invoice note sections.
func (_caee *Invoice )SetNoteStyle (style TextStyle ){_caee ._bad =style };

// SetBorderOpacity sets the border opacity.
func (_cdbgf *Polygon )SetBorderOpacity (opacity float64 ){_cdbgf ._geag =opacity };func (_gaba *Paragraph )getMaxLineWidth ()float64 {if _gaba ._gacac ==nil ||len (_gaba ._gacac )==0{_gaba .wrapText ();};var _cfg float64 ;for _ ,_egag :=range _gaba ._gacac {_cfgf :=_gaba .getTextLineWidth (_egag );
if _cfgf > _cfg {_cfg =_cfgf ;};};return _cfg ;};

// Width returns Rectangle's document width.
func (_facd *Rectangle )Width ()float64 {return _facd ._ddfc };

// Invoice represents a configurable invoice template.
type Invoice struct{_gaddb string ;_ffbf *Image ;_ebcb *InvoiceAddress ;_bdde *InvoiceAddress ;_cddf string ;_daf [2]*InvoiceCell ;_agbag [2]*InvoiceCell ;_aagg [2]*InvoiceCell ;_fegc [][2]*InvoiceCell ;_dfa []*InvoiceCell ;_deff [][]*InvoiceCell ;_ceefd [2]*InvoiceCell ;
_gcbg [2]*InvoiceCell ;_efdce [][2]*InvoiceCell ;_ecbb [2]string ;_eceg [2]string ;_eafgd [][2]string ;_fbadd TextStyle ;_ebac TextStyle ;_bfcc TextStyle ;_bfced TextStyle ;_ebca TextStyle ;_bad TextStyle ;_cgff TextStyle ;_ecga InvoiceCellProps ;_eebd InvoiceCellProps ;
_dddg InvoiceCellProps ;_cabc InvoiceCellProps ;_geea Positioning ;};

// SetLineOpacity sets the line opacity.
func (_fdeb *Polyline )SetLineOpacity (opacity float64 ){_fdeb ._cfff =opacity };

// SetPos sets the absolute position. Changes object positioning to absolute.
func (_ddgc *Image )SetPos (x ,y float64 ){_ddgc ._feaaf =PositionAbsolute ;_ddgc ._cgbe =x ;_ddgc ._ead =y ;};

// NewLine creates a new line between (x1, y1) to (x2, y2),
// using default attributes.
// NOTE: In relative positioning mode, `x1` and `y1` are calculated using the
// current context and `x2`, `y2` are used only to calculate the position of
// the second point in relation to the first one (used just as a measurement
// of size). Furthermore, when the fit mode is set to fill the context width,
// `x2` is set to the right edge coordinate of the context.
func (_aabg *Creator )NewLine (x1 ,y1 ,x2 ,y2 float64 )*Line {return _aeef (x1 ,y1 ,x2 ,y2 )};

// SetWidth sets line width.
func (_fbade *Curve )SetWidth (width float64 ){_fbade ._dec =width };

// NewStyledParagraph creates a new styled paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_aad *Creator )NewStyledParagraph ()*StyledParagraph {return _ebda (_aad .NewTextStyle ())};

// Block contains a portion of PDF Page contents. It has a width and a position and can
// be placed anywhere on a Page.  It can even contain a whole Page, and is used in the creator
// where each Drawable object can output one or more blocks, each representing content for separate pages
// (typically needed when Page breaks occur).
type Block struct{_ba *_af .ContentStreamOperations ;_dab *_fd .PdfPageResources ;_ggb Positioning ;_fg ,_aca float64 ;_bd float64 ;_ef float64 ;_dg float64 ;_ff Margins ;_ag []*_fd .PdfAnnotation ;};func _ddaf (_caa ,_geeb ,_cdbd ,_eccab float64 )*border {_bfbc :=&border {};
_bfbc ._fgbb =_caa ;_bfbc ._bcg =_geeb ;_bfbc ._bef =_cdbd ;_bfbc ._fef =_eccab ;_bfbc ._ebb =ColorBlack ;_bfbc ._fea =ColorBlack ;_bfbc ._abe =ColorBlack ;_bfbc ._dce =ColorBlack ;_bfbc ._bfb =0;_bfbc ._gea =0;_bfbc ._agf =0;_bfbc ._fdeg =0;_bfbc .LineStyle =_f .LineStyleSolid ;
return _bfbc ;};

// GeneratePageBlocks draws the filled curve on page blocks.
func (_geff *FilledCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fcab :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_dead ,_ ,_egea :=_geff .draw ("");if _egea !=nil {return nil ,ctx ,_egea ;};_egea =_fcab .addContentsByString (string (_dead ));
if _egea !=nil {return nil ,ctx ,_egea ;};return []*Block {_fcab },ctx ,nil ;};

// SetWidthRight sets border width for right.
func (_gbbd *border )SetWidthRight (bw float64 ){_gbbd ._fdeg =bw };

// Chapter is used to arrange multiple drawables (paragraphs, images, etc) into a single section.
// The concept is the same as a book or a report chapter.
type Chapter struct{_eeb int ;_gec string ;_babb *Paragraph ;_gebf []Drawable ;_gge int ;_cffb bool ;_dbg bool ;_feg Positioning ;_cgdg ,_cbb float64 ;_dcf Margins ;_cfc *Chapter ;_ccd *TOC ;_ecd *_fd .Outline ;_ggbc *_fd .OutlineItem ;_acd uint ;};func _caac (_gcfdg *_fd .PdfAnnotation )*_fd .PdfAnnotation {if _gcfdg ==nil {return nil ;
};var _befd *_fd .PdfAnnotation ;switch _acba :=_gcfdg .GetContext ().(type ){case *_fd .PdfAnnotationLink :if _dbdgg :=_dfdfg (_acba );_dbdgg !=nil {_befd =_dbdgg .PdfAnnotation ;};};return _befd ;};

// GeneratePageBlocks generates the page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages. Implements the Drawable interface.
func (_ddce *StyledParagraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dcee :=ctx ;var _gdeac []*Block ;_cfbf :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _ddce ._bgdg .IsRelative (){ctx .X +=_ddce ._ddaff .Left ;ctx .Y +=_ddce ._ddaff .Top ;
ctx .Width -=_ddce ._ddaff .Left +_ddce ._ddaff .Right ;ctx .Height -=_ddce ._ddaff .Top ;_ddce .SetWidth (ctx .Width );}else {if int (_ddce ._ccf )<=0{_ddce .SetWidth (_ddce .getTextWidth ()/1000.0);};ctx .X =_ddce ._fbbag ;ctx .Y =_ddce ._affa ;};if _ddce ._aceea !=nil {_ddce ._aceea (_ddce ,ctx );
};if _fccg :=_ddce .wrapText ();_fccg !=nil {return nil ,ctx ,_fccg ;};_fgfb :=_ddce ._cdeae ;for {_egbdg ,_badg ,_gdaga :=_edeeb (_cfbf ,_ddce ,_fgfb ,ctx );if _gdaga !=nil {_bg .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_gdaga );return nil ,ctx ,_gdaga ;
};ctx =_egbdg ;_gdeac =append (_gdeac ,_cfbf );if _fgfb =_badg ;len (_badg )==0{break ;};_cfbf =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_egbdg =ctx ;_egbdg .Y =ctx .Margins .Top ;_egbdg .X =ctx .Margins .Left +_ddce ._ddaff .Left ;_egbdg .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom ;
_egbdg .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_ddce ._ddaff .Left -_ddce ._ddaff .Right ;ctx =_egbdg ;};if _ddce ._bgdg .IsRelative (){ctx .Y +=_ddce ._ddaff .Bottom ;ctx .Height -=_ddce ._ddaff .Bottom ;if !ctx .Inline {ctx .X =_dcee .X ;
ctx .Width =_dcee .Width ;};return _gdeac ,ctx ,nil ;};return _gdeac ,_dcee ,nil ;};

// SkipOver skips over a specified number of rows and cols.
func (_ebfe *Table )SkipOver (rows ,cols int ){_fcce :=rows *_ebfe ._ecdg +cols -1;if _fcce < 0{_bg .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};_ebfe ._ddbf +=_fcce ;};func (_eaedd *StyledParagraph )getTextHeight ()float64 {var _dggad float64 ;for _ ,_cdee :=range _eaedd ._aacee {_gcba :=_cdee .Style .FontSize *_eaedd ._beea ;if _gcba > _dggad {_dggad =_gcba ;};};return _dggad ;};

// Creator is a wrapper around functionality for creating PDF reports and/or adding new
// content onto imported PDF pages, etc.
type Creator struct{

// Errors keeps error messages that should not interrupt pdf processing and to be checked later.
Errors []error ;

// UnsupportedCharacterReplacement is character that will be used to replace unsupported glyph.
// The value will be passed to drawing context.
UnsupportedCharacterReplacement rune ;_bfba []*_fd .PdfPage ;_bffe map[*_fd .PdfPage ]*Block ;_abfd map[*_fd .PdfPage ]*pageTransformations ;_gdd *_fd .PdfPage ;_adde PageSize ;_acda DrawContext ;_bdbc Margins ;_bfg ,_degf float64 ;_bffg int ;_gaeg func (_ebbe FrontpageFunctionArgs );
_cgef func (_cggc *TOC )error ;_agg func (_dbfff *Block ,_egdc HeaderFunctionArgs );_gca func (_bdf *Block ,_gcgd FooterFunctionArgs );_aded func (_eegd PageFinalizeFunctionArgs )error ;_aggb func (_gda *_fd .PdfWriter )error ;_egbe bool ;

// Controls whether a table of contents will be generated.
AddTOC bool ;_gcd *TOC ;

// Controls whether outlines will be generated.
AddOutlines bool ;_baec *_fd .Outline ;_ccdd *_fd .PdfOutlineTreeNode ;_fgef *_fd .PdfAcroForm ;_aaa _eg .PdfObject ;_fda _fd .Optimizer ;_gbfa []*_fd .PdfFont ;_daaf *_fd .PdfFont ;_egce *_fd .PdfFont ;};

// Width returns the width of the Paragraph.
func (_dbdcd *Paragraph )Width ()float64 {if _dbdcd ._bbde &&int (_dbdcd ._abcd )> 0{return _dbdcd ._abcd ;};return _dbdcd .getTextWidth ()/1000.0;};

// CurRow returns the currently active cell's row number.
func (_ggfd *Table )CurRow ()int {_gbbf :=(_ggfd ._ddbf -1)/_ggfd ._ecdg +1;return _gbbf };

// MultiRowCell makes a new cell with the specified row span and inserts it
// into the table at the current position.
func (_eaae *Table )MultiRowCell (rowspan int )*TableCell {return _eaae .MultiCell (rowspan ,1)};

// AddSection adds a new content section at the end of the invoice.
func (_cfcgbc *Invoice )AddSection (title ,content string ){_cfcgbc ._eafgd =append (_cfcgbc ._eafgd ,[2]string {title ,content });};

// Context returns the current drawing context.
func (_fdfd *Creator )Context ()DrawContext {return _fdfd ._acda };

// TextChunk represents a chunk of text along with a particular style.
type TextChunk struct{

// The text that is being rendered in the PDF.
Text string ;

// The style of the text being rendered.
Style TextStyle ;_cgaf *_fd .PdfAnnotation ;_gbafd bool ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_edee *List )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var _cdce float64 ;var _cefa []*StyledParagraph ;for _ ,_baecf :=range _edee ._eadc {_edda :=_ebda (_edee ._cffbd );_edda .SetEnableWrap (false );_edda .SetTextAlignment (TextAlignmentRight );
_edda .Append (_baecf ._cacc .Text ).Style =_baecf ._cacc .Style ;_cdecb :=_edda .getTextWidth ()/1000.0/ctx .Width ;if _cdce < _cdecb {_cdce =_cdecb ;};_cefa =append (_cefa ,_edda );};_cbeae :=_fbcc (2);_cbeae .SetColumnWidths (_cdce ,1-_cdce );_cbeae .SetMargins (_edee ._ffdc ,0,0,0);
for _feece ,_afgc :=range _edee ._eadc {_fagbd :=_cbeae .NewCell ();_fagbd .SetIndent (0);_fagbd .SetContent (_cefa [_feece ]);_fagbd =_cbeae .NewCell ();_fagbd .SetIndent (0);_fagbd .SetContent (_afgc ._bfdd );};return _cbeae .GeneratePageBlocks (ctx );
};

// SetLineTitleStyle sets the style for the title part of all new lines
// of the table of contents.
func (_adbg *TOC )SetLineTitleStyle (style TextStyle ){_adbg ._gbdae =style };func (_fcf *Creator )initContext (){_fcf ._acda .X =_fcf ._bdbc .Left ;_fcf ._acda .Y =_fcf ._bdbc .Top ;_fcf ._acda .Width =_fcf ._bfg -_fcf ._bdbc .Right -_fcf ._bdbc .Left ;
_fcf ._acda .Height =_fcf ._degf -_fcf ._bdbc .Bottom -_fcf ._bdbc .Top ;_fcf ._acda .PageHeight =_fcf ._degf ;_fcf ._acda .PageWidth =_fcf ._bfg ;_fcf ._acda .Margins =_fcf ._bdbc ;_fcf ._acda ._gfce =_fcf .UnsupportedCharacterReplacement ;};

// Rows returns the total number of rows the table has.
func (_eggd *Table )Rows ()int {return _eggd ._ecea };

// SetVerticalAlignment set the cell's vertical alignment of content.
// Can be one of:
// - CellHorizontalAlignmentTop
// - CellHorizontalAlignmentMiddle
// - CellHorizontalAlignmentBottom
func (_ebfd *TableCell )SetVerticalAlignment (valign CellVerticalAlignment ){_ebfd ._dagd =valign };

// SetBorderColor sets the border color for the path.
func (_aedb *FilledCurve )SetBorderColor (color Color ){_aedb ._aacg =color };

// SetBorderWidth sets the border width.
func (_abc *Ellipse )SetBorderWidth (bw float64 ){_abc ._eeec =bw };

// ScaleToHeight scale Image to a specified height h, maintaining the aspect ratio.
func (_beaae *Image )ScaleToHeight (h float64 ){_dbecb :=_beaae ._ffab /_beaae ._dbffg ;_beaae ._dbffg =h ;_beaae ._ffab =h *_dbecb ;};func (_ebcba *Invoice )newColumn (_efgd string ,_egeb CellHorizontalAlignment )*InvoiceCell {_gbea :=&InvoiceCell {_ebcba ._eebd ,_efgd };
_gbea .Alignment =_egeb ;return _gbea ;};

// PolyBezierCurve represents a composite curve that is the result of joining
// multiple cubic Bezier curves.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type PolyBezierCurve struct{_aecc *_f .PolyBezierCurve ;_aagaa float64 ;_aebea float64 ;};func (_dfae *Invoice )generateTotalBlocks (_abcb DrawContext )([]*Block ,DrawContext ,error ){_cbfa :=_fbcc (4);_cbfa .SetMargins (0,0,10,10);_bafce :=[][2]*InvoiceCell {_dfae ._ceefd };
_bafce =append (_bafce ,_dfae ._efdce ...);_bafce =append (_bafce ,_dfae ._gcbg );for _ ,_bdffc :=range _bafce {_fgbce ,_dagef :=_bdffc [0],_bdffc [1];if _dagef .Value ==""{continue ;};_cbfa .SkipCells (2);_ccaec :=_cbfa .NewCell ();_ccaec .SetBackgroundColor (_fgbce .BackgroundColor );
_ccaec .SetHorizontalAlignment (_dagef .Alignment );_dfae .setCellBorder (_ccaec ,_fgbce );_dbae :=_ebda (_fgbce .TextStyle );_dbae .SetMargins (0,0,2,1);_dbae .Append (_fgbce .Value );_ccaec .SetContent (_dbae );_ccaec =_cbfa .NewCell ();_ccaec .SetBackgroundColor (_dagef .BackgroundColor );
_ccaec .SetHorizontalAlignment (_dagef .Alignment );_dfae .setCellBorder (_ccaec ,_fgbce );_dbae =_ebda (_dagef .TextStyle );_dbae .SetMargins (0,0,2,1);_dbae .Append (_dagef .Value );_ccaec .SetContent (_dbae );};return _cbfa .GeneratePageBlocks (_abcb );
};

// NewImageFromGoImage creates an Image from a go image.Image data structure.
func (_bcc *Creator )NewImageFromGoImage (goimg _be .Image )(*Image ,error ){return _eeece (goimg )};

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_dacee *Paragraph )SetTextAlignment (align TextAlignment ){_dacee ._adfg =align };

// CellBorderSide defines the table cell's border side.
type CellBorderSide int ;

// AddTotalLine adds a new line in the invoice totals table.
func (_ffef *Invoice )AddTotalLine (desc ,value string )(*InvoiceCell ,*InvoiceCell ){_bdae :=&InvoiceCell {_ffef ._cabc ,desc };_ceaa :=&InvoiceCell {_ffef ._cabc ,value };_ffef ._efdce =append (_ffef ._efdce ,[2]*InvoiceCell {_bdae ,_ceaa });return _bdae ,_ceaa ;
};

// SetBorderColor sets the border color.
func (_eaec *PolyBezierCurve )SetBorderColor (color Color ){_eaec ._aecc .BorderColor =_ecb (color )};

// GetMargins returns the margins of the line: left, right, top, bottom.
func (_eaad *Line )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _eaad ._eebc .Left ,_eaad ._eebc .Right ,_eaad ._eebc .Top ,_eaad ._eebc .Bottom ;};

// SetLineWidth sets the line width.
func (_aggba *Line )SetLineWidth (width float64 ){_aggba ._gbff =width };func (_bgfca *InvoiceAddress )fmtLine (_accd ,_ccca string ,_ggfe bool )string {if _ggfe {_ccca ="";};return _gg .Sprintf ("\u0025\u0073\u0025s\u000a",_ccca ,_accd );};func _fbcc (_cbagf int )*Table {_aaca :=&Table {_ecdg :_cbagf ,_gddd :10.0,_geefa :[]float64 {},_ecgdb :[]float64 {},_abgf :[]*TableCell {},_dgea :make ([]int ,_cbagf ),_bfddd :true };
_aaca .resetColumnWidths ();return _aaca ;};

// Width returns the Block's width.
func (_ggc *Block )Width ()float64 {return _ggc ._bd };

// TextStyle is a collection of properties that can be assigned to a text chunk.
type TextStyle struct{

// Color represents the color of the text.
Color Color ;

// OutlineColor represents the color of the text outline.
OutlineColor Color ;

// Font represents the font the text will use.
Font *_fd .PdfFont ;

// FontSize represents the size of the font.
FontSize float64 ;

// OutlineSize represents the thickness of the text outline.
OutlineSize float64 ;

// CharSpacing represents the character spacing.
CharSpacing float64 ;

// HorizontalScaling represents the percentage to horizontally scale
// characters by (default: 100). Values less than 100 will result in
// narrower text while values greater than 100 will result in wider text.
HorizontalScaling float64 ;

// RenderingMode represents the rendering mode.
RenderingMode TextRenderingMode ;

// Underline specifies if the text chunk is underlined.
Underline bool ;

// UnderlineStyle represents the style of the line used to underline text.
UnderlineStyle TextDecorationLineStyle ;

// TextRise specifies a vertical adjustment for text. It is useful for
// drawing subscripts/superscripts. A positive text rise value will
// produce superscript text, while a negative one will result in
// subscript text.
TextRise float64 ;};

// Width returns Image's document width.
func (_aeggb *Image )Width ()float64 {return _aeggb ._ffab };

// SetEncoder sets the encoding/compression mechanism for the image.
func (_bbdaf *Image )SetEncoder (encoder _eg .StreamEncoder ){_bbdaf ._cceb =encoder };

// GeneratePageBlocks draws the composite Bezier curve on a new block
// representing the page. Implements the Drawable interface.
func (_dbcf *PolyBezierCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bdfff :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_efbd ,_bagdd :=_bdfff .setOpacity (_dbcf ._aagaa ,_dbcf ._aebea );if _bagdd !=nil {return nil ,ctx ,_bagdd ;
};_defc :=_dbcf ._aecc ;_defc .FillEnabled =_defc .FillColor !=nil ;var (_dcgd =ctx .PageHeight ;_bee =_defc .Curves ;_gadbc =make ([]_f .CubicBezierCurve ,0,len (_defc .Curves )););for _gcgb :=range _defc .Curves {_bdec :=_bee [_gcgb ];_bdec .P0 .Y =_dcgd -_bdec .P0 .Y ;
_bdec .P1 .Y =_dcgd -_bdec .P1 .Y ;_bdec .P2 .Y =_dcgd -_bdec .P2 .Y ;_bdec .P3 .Y =_dcgd -_bdec .P3 .Y ;_gadbc =append (_gadbc ,_bdec );};_defc .Curves =_gadbc ;defer func (){_defc .Curves =_bee }();_gbcg ,_ ,_bagdd :=_defc .Draw (_efbd );if _bagdd !=nil {return nil ,ctx ,_bagdd ;
};if _bagdd =_bdfff .addContentsByString (string (_gbcg ));_bagdd !=nil {return nil ,ctx ,_bagdd ;};return []*Block {_bdfff },ctx ,nil ;};

// MoveY moves the drawing context to absolute position y.
func (_gabfbd *Creator )MoveY (y float64 ){_gabfbd ._acda .Y =y };

// Height returns the height of the chart.
func (_eef *Chart )Height ()float64 {return float64 (_eef ._gebc .Height ())};

// CurvePolygon represents a curve polygon shape.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type CurvePolygon struct{_abff *_f .CurvePolygon ;_eccc float64 ;_gcac float64 ;};func _cbc (_bgf string ,_ceg _eg .PdfObject ,_fgbc *_fd .PdfPageResources )_eg .PdfObjectName {_cca :=_ad .TrimRightFunc (_ad .TrimSpace (_bgf ),func (_gab rune )bool {return _ga .IsNumber (_gab )});
if _cca ==""{_cca ="\u0046\u006f\u006e\u0074";};_adc :=0;_aed :=_eg .PdfObjectName (_bgf );for {_fga ,_cea :=_fgbc .GetFontByName (_aed );if !_cea ||_fga ==_ceg {break ;};_adc ++;_aed =_eg .PdfObjectName (_gg .Sprintf ("\u0025\u0073\u0025\u0064",_cca ,_adc ));
};return _aed ;};

// Background contains properties related to the background of a component.
type Background struct{FillColor Color ;BorderColor Color ;BorderSize float64 ;BorderRadiusTopLeft float64 ;BorderRadiusTopRight float64 ;BorderRadiusBottomLeft float64 ;BorderRadiusBottomRight float64 ;};

// NewCell returns a new invoice table cell.
func (_dbgdg *Invoice )NewCell (value string )*InvoiceCell {return _dbgdg .newCell (value ,_dbgdg .NewCellProps ());};

// FitMode returns the fit mode of the image.
func (_ecbe *Image )FitMode ()FitMode {return _ecbe ._dffa };

// SetWidthTop sets border width for top.
func (_gfbf *border )SetWidthTop (bw float64 ){_gfbf ._bfb =bw };

// NewList creates a new list.
func (_bdd *Creator )NewList ()*List {return _afdag (_bdd .NewTextStyle ())};

// SetWidthLeft sets border width for left.
func (_daad *border )SetWidthLeft (bw float64 ){_daad ._agf =bw };

// SetBorderColor sets the border color.
func (_bcba *Polygon )SetBorderColor (color Color ){_bcba ._egdcc .BorderColor =_ecb (color )};func _gagce (_gafc ,_gegcc ,_bedb ,_bbg ,_ddcb ,_cbbf float64 )*Curve {_dgee :=&Curve {};_dgee ._dabe =_gafc ;_dgee ._afb =_gegcc ;_dgee ._gced =_bedb ;_dgee ._fdgf =_bbg ;
_dgee ._fbad =_ddcb ;_dgee ._afbg =_cbbf ;_dgee ._dcaa =ColorBlack ;_dgee ._dec =1.0;return _dgee ;};

// LineWidth returns the width of the line.
func (_cdbc *Line )LineWidth ()float64 {return _cdbc ._gbff };func _eabc (_edfbe *_fd .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,0),Font :_edfbe ,FontSize :10,OutlineSize :1,HorizontalScaling :DefaultHorizontalScaling ,UnderlineStyle :TextDecorationLineStyle {Offset :1,Thickness :1}};
};

// SetWidth set the Image's document width to specified w. This does not change the raw image data, i.e.
// no actual scaling of data is performed. That is handled by the PDF viewer.
func (_ecgb *Image )SetWidth (w float64 ){_ecgb ._ffab =w };func _cff (_dcb ,_dcc *_fd .PdfPageResources )error {_ceee ,_ :=_dcb .GetColorspaces ();if _ceee !=nil &&len (_ceee .Colorspaces )> 0{for _ceef ,_ddg :=range _ceee .Colorspaces {_eac :=*_eg .MakeName (_ceef );
if _dcc .HasColorspaceByName (_eac ){continue ;};_fce :=_dcc .SetColorspaceByName (_eac ,_ddg );if _fce !=nil {return _fce ;};};};return nil ;};func _ecb (_eede Color )_fd .PdfColor {if _eede ==nil {_eede =ColorBlack ;};switch _ggbb :=_eede .(type ){case cmykColor :return _fd .NewPdfColorDeviceCMYK (_ggbb ._fdga ,_ggbb ._gaa ,_ggbb ._fdgef ,_ggbb ._dac );
};return _fd .NewPdfColorDeviceRGB (_eede .ToRGB ());};

// SetLineStyle sets the style for all the line components: number, title,
// separator, page. The style is applied only for new lines added to the
// TOC component.
func (_fcegc *TOC )SetLineStyle (style TextStyle ){_fcegc .SetLineNumberStyle (style );_fcegc .SetLineTitleStyle (style );_fcegc .SetLineSeparatorStyle (style );_fcegc .SetLinePageStyle (style );};

// Date returns the invoice date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_gdc *Invoice )Date ()(*InvoiceCell ,*InvoiceCell ){return _gdc ._agbag [0],_gdc ._agbag [1]};func (_adea *Table )wrapRow (_afae int ,_abgd DrawContext ,_ebgf float64 )(bool ,error ){if !_adea ._gbfbcd {return false ,nil ;};var (_bgbe =_adea ._abgf [_afae ];
_caab =-1;_bcgf []*TableCell ;_eaeg float64 ;_dbfcf bool ;_bbddd =make ([]float64 ,0,len (_adea ._geefa )););_abfdd :=func (_abdd *TableCell ,_aeaba VectorDrawable ,_dddf bool )*TableCell {_aaec :=*_abdd ;_aaec ._edcdf =_aeaba ;if _dddf {_aaec ._egdb ++;
};return &_aaec ;};_afcg :=func (_bbdca int ,_fgdb VectorDrawable ){var _debc float64 =-1;if _fgdb ==nil {if _ebacd :=_bbddd [_bbdca -_afae ];_ebacd > _abgd .Height {_fgdb =_adea ._abgf [_bbdca ]._edcdf ;_adea ._abgf [_bbdca ]._edcdf =nil ;_bbddd [_bbdca -_afae ]=0;
_debc =_ebacd ;};};_ddacc :=_abfdd (_adea ._abgf [_bbdca ],_fgdb ,true );_bcgf =append (_bcgf ,_ddacc );if _debc < 0{_debc =_ddacc .height (_abgd .Width );};if _debc > _eaeg {_eaeg =_debc ;};};for _ddggg :=_afae ;_ddggg < len (_adea ._abgf );_ddggg ++{_bafg :=_adea ._abgf [_ddggg ];
if _bgbe ._egdb !=_bafg ._egdb {_caab =_ddggg ;break ;};_abgd .Width =_bafg .width (_adea ._geefa ,_ebgf );var _dbea VectorDrawable ;switch _accb :=_bafg ._edcdf .(type ){case *StyledParagraph :if _fcec :=_bafg .height (_abgd .Width );_fcec > _abgd .Height {_ceba :=_abgd ;
_ceba .Height =_da .Floor (_abgd .Height -_accb ._ddaff .Top -_accb ._ddaff .Bottom -0.5*_accb .getTextHeight ());_bcef ,_bgdee ,_cgbd :=_accb .split (_ceba );if _cgbd !=nil {return false ,_cgbd ;};if _bcef !=nil &&_bgdee !=nil {_accb =_bcef ;_bafg =_abfdd (_bafg ,_bcef ,false );
_adea ._abgf [_ddggg ]=_bafg ;_dbea =_bgdee ;_dbfcf =true ;};};case *Division :if _cgffb :=_bafg .height (_abgd .Width );_cgffb > _abgd .Height {_dbgaa :=_abgd ;_dbgaa .Height =_da .Floor (_abgd .Height -_accb ._cfe .Top -_accb ._cfe .Bottom );_cbgeg ,_gefb :=_accb .split (_dbgaa );
if _cbgeg !=nil &&_gefb !=nil {_accb =_cbgeg ;_bafg =_abfdd (_bafg ,_cbgeg ,false );_adea ._abgf [_ddggg ]=_bafg ;_dbea =_gefb ;_dbfcf =true ;if _cbgeg ._fefg !=nil {_cbgeg ._fefg .BorderRadiusBottomLeft =0;_cbgeg ._fefg .BorderRadiusBottomRight =0;};if _gefb ._fefg !=nil {_gefb ._fefg .BorderRadiusTopLeft =0;
_gefb ._fefg .BorderRadiusTopRight =0;};};};};_bbddd =append (_bbddd ,_bafg .height (_abgd .Width ));if _dbfcf {if _bcgf ==nil {_bcgf =make ([]*TableCell ,0,len (_adea ._geefa ));for _aebf :=_afae ;_aebf < _ddggg ;_aebf ++{_afcg (_aebf ,nil );};};_afcg (_ddggg ,_dbea );
};};var _bbce float64 ;for _ ,_acfc :=range _bbddd {if _acfc > _bbce {_bbce =_acfc ;};};if _dbfcf &&_bbce < _abgd .Height {if _caab < 0{_caab =len (_adea ._abgf );};_gbfae :=_adea ._abgf [_caab -1]._egdb +_adea ._abgf [_caab -1]._fdbd -1;for _cface :=_caab ;
_cface < len (_adea ._abgf );_cface ++{_adea ._abgf [_cface ]._egdb ++;};_adea ._abgf =append (_adea ._abgf [:_caab ],append (_bcgf ,_adea ._abgf [_caab :]...)...);_adea ._ecgdb =append (_adea ._ecgdb [:_gbfae ],append ([]float64 {_eaeg },_adea ._ecgdb [_gbfae :]...)...);
_adea ._ecgdb [_bgbe ._egdb +_bgbe ._fdbd -2]=_bbce ;};return _dbfcf ,nil ;};

// GetMargins returns the margins of the chart (left, right, top, bottom).
func (_eced *Chart )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _eced ._gecd .Left ,_eced ._gecd .Right ,_eced ._gecd .Top ,_eced ._gecd .Bottom ;};

// Number returns the invoice number description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_cdag *Invoice )Number ()(*InvoiceCell ,*InvoiceCell ){return _cdag ._daf [0],_cdag ._daf [1]};

// Width is not used. Not used as a Table element is designed to fill into
// available width depending on the context. Returns 0.
func (_baadg *Table )Width ()float64 {return 0};

// SetDate sets the date of the invoice.
func (_bagde *Invoice )SetDate (date string )(*InvoiceCell ,*InvoiceCell ){_bagde ._agbag [1].Value =date ;return _bagde ._agbag [0],_bagde ._agbag [1];};

// ScaleToWidth scales the Block to a specified width, maintaining the same aspect ratio.
func (_fge *Block )ScaleToWidth (w float64 ){_cf :=w /_fge ._bd ;_fge .Scale (_cf ,_cf )};

// SetColumnWidths sets the fractional column widths.
// Each width should be in the range 0-1 and is a fraction of the table width.
// The number of width inputs must match number of columns, otherwise an error is returned.
func (_feddg *Table )SetColumnWidths (widths ...float64 )error {if len (widths )!=_feddg ._ecdg {_bg .Log .Debug ("M\u0069\u0073\u006d\u0061\u0074\u0063\u0068\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020o\u0066\u0020\u0077\u0069\u0064\u0074\u0068\u0073\u0020\u0061nd\u0020\u0063\u006fl\u0075m\u006e\u0073");
return _c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_feddg ._geefa =widths ;return nil ;};

// SetLineHeight sets the line height (1.0 default).
func (_adff *StyledParagraph )SetLineHeight (lineheight float64 ){_adff ._beea =lineheight };

// NewTOCLine creates a new table of contents line with the default style.
func (_adeg *Creator )NewTOCLine (number ,title ,page string ,level uint )*TOCLine {return _fcge (number ,title ,page ,level ,_adeg .NewTextStyle ());};

// GetCoords returns coordinates of the Rectangle's upper left corner (x,y).
func (_fgeggf *Rectangle )GetCoords ()(float64 ,float64 ){return _fgeggf ._acge ,_fgeggf ._aedba };

// SetBorderOpacity sets the border opacity.
func (_gddf *PolyBezierCurve )SetBorderOpacity (opacity float64 ){_gddf ._aebea =opacity };func (_cbffd *StyledParagraph )wrapText ()error {return _cbffd .wrapChunks (true )};const (TextRenderingModeFill TextRenderingMode =iota ;TextRenderingModeStroke ;
TextRenderingModeFillStroke ;TextRenderingModeInvisible ;TextRenderingModeFillClip ;TextRenderingModeStrokeClip ;TextRenderingModeFillStrokeClip ;TextRenderingModeClip ;);type listItem struct{_bfdd VectorDrawable ;_cacc TextChunk ;};

// SetPos sets the position of the chart to the specified coordinates.
// This method sets the chart to use absolute positioning.
func (_deab *Chart )SetPos (x ,y float64 ){_deab ._ebe =PositionAbsolute ;_deab ._eccaa =x ;_deab ._eed =y ;};

// SetPos sets the Table's positioning to absolute mode and specifies the upper-left corner
// coordinates as (x,y).
// Note that this is only sensible to use when the table does not wrap over multiple pages.
// TODO: Should be able to set width too (not just based on context/relative positioning mode).
func (_ecdc *Table )SetPos (x ,y float64 ){_ecdc ._aacdb =PositionAbsolute ;_ecdc ._dfaff =x ;_ecdc ._dgcd =y ;};func (_ffb *Chapter )headingText ()string {_bag :=_ffb ._gec ;if _bfab :=_ffb .headingNumber ();_bfab !=""{_bag =_gg .Sprintf ("\u0025\u0073\u0020%\u0073",_bfab ,_bag );
};return _bag ;};func _fcdg (_ffea ,_efae ,_dccg ,_ccc float64 )*Ellipse {_eafa :=&Ellipse {};_eafa ._dgedf =_ffea ;_eafa ._ggffb =_efae ;_eafa ._gcf =_dccg ;_eafa ._ccbf =_ccc ;_eafa ._dgad =PositionAbsolute ;_eafa ._bedc =ColorBlack ;_eafa ._eeec =1.0;
return _eafa ;};

// SetMargins sets the margins of the chart component.
func (_fae *Chart )SetMargins (left ,right ,top ,bottom float64 ){_fae ._gecd .Left =left ;_fae ._gecd .Right =right ;_fae ._gecd .Top =top ;_fae ._gecd .Bottom =bottom ;};func _dbb (_effa _gc .ChartRenderable )*Chart {return &Chart {_gebc :_effa ,_ebe :PositionRelative ,_gecd :Margins {Top :10,Bottom :10}};
};

// NewStyledTOCLine creates a new table of contents line with the provided style.
func (_ecad *Creator )NewStyledTOCLine (number ,title ,page TextChunk ,level uint ,style TextStyle )*TOCLine {return _dfcg (number ,title ,page ,level ,style );};

// NewImageFromData creates an Image from image data.
func (_gafgg *Creator )NewImageFromData (data []byte )(*Image ,error ){return _gfaf (data )};

// InfoLines returns all the rows in the invoice information table as
// description-value cell pairs.
func (_cfcgb *Invoice )InfoLines ()[][2]*InvoiceCell {_fffcd :=[][2]*InvoiceCell {_cfcgb ._daf ,_cfcgb ._agbag ,_cfcgb ._aagg };return append (_fffcd ,_cfcgb ._fegc ...);};func (_ceacc *Table )updateRowHeights (_adae float64 ){for _ ,_gcff :=range _ceacc ._abgf {_fcabf :=_gcff .width (_ceacc ._geefa ,_adae );
_baae :=_ceacc ._ecgdb [_gcff ._egdb +_gcff ._fdbd -2];if _ggcb :=_gcff .height (_fcabf );_ggcb > _baae {_cffec :=_ggcb /float64 (_gcff ._fdbd );for _cddad :=1;_cddad <=_gcff ._fdbd ;_cddad ++{if _cffec > _ceacc ._ecgdb [_gcff ._egdb +_cddad -2]{_ceacc ._ecgdb [_gcff ._egdb +_cddad -2]=_cffec ;
};};};};};

// Wrap wraps the text of the chunk into lines based on its style and the
// specified width.
func (_cdac *TextChunk )Wrap (width float64 )([]string ,error ){if int (width )<=0{return []string {_cdac .Text },nil ;};var _cgega []string ;var _acec []rune ;var _bgca float64 ;var _agbdf []float64 ;_bagg :=_cdac .Style ;_adgbf :=_fdef (_cdac .Text );
for _ ,_bgee :=range _cdac .Text {if _bgee =='\u000A'{_cgega =append (_cgega ,_ad .TrimRightFunc (string (_acec ),_ga .IsSpace )+string (_bgee ));_acec =nil ;_bgca =0;_agbdf =nil ;continue ;};_gdge :=_bgee ==' ';_aadg ,_gbee :=_bagg .Font .GetRuneMetrics (_bgee );
if !_gbee {_bg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006det\u0072i\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064!\u0020\u0072\u0075\u006e\u0065\u003d\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0066o\u006e\u0074\u003d\u0025\u0073\u0020\u0025\u0023\u0071",_bgee ,_bgee ,_bagg .Font .BaseFont (),_bagg .Font .Subtype ());
_bg .Log .Trace ("\u0046o\u006e\u0074\u003a\u0020\u0025\u0023v",_bagg .Font );_bg .Log .Trace ("\u0045\u006e\u0063o\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076",_bagg .Font .Encoder ());return nil ,_c .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");
};_cdage :=_bagg .FontSize *_aadg .Wx ;_dgbc :=_cdage ;if !_gdge {_dgbc =_cdage +_bagg .CharSpacing *1000.0;};if _bgca +_cdage > width *1000.0{_eada :=-1;if !_gdge {for _fcag :=len (_acec )-1;_fcag >=0;_fcag --{if _acec [_fcag ]==' '{_eada =_fcag ;break ;
};};};_cbaeeg :=string (_acec );if _eada > 0{_cbaeeg =string (_acec [0:_eada +1]);_acec =append (_acec [_eada +1:],_bgee );_agbdf =append (_agbdf [_eada +1:],_dgbc );_bgca =0;for _ ,_bdga :=range _agbdf {_bgca +=_bdga ;};}else {if _gdge {_acec =[]rune {};
_agbdf =[]float64 {};_bgca =0;}else {_acec =[]rune {_bgee };_agbdf =[]float64 {_dgbc };_bgca =_dgbc ;};};_cbaeeg =_fccc (_cbaeeg ,_adgbf );_cgega =append (_cgega ,_ad .TrimRightFunc (_cbaeeg ,_ga .IsSpace ));}else {_acec =append (_acec ,_bgee );_bgca +=_dgbc ;
_agbdf =append (_agbdf ,_dgbc );};};if len (_acec )> 0{_fgfd :=string (_acec );_fgfd =_fccc (_fgfd ,_adgbf );_cgega =append (_cgega ,_fgfd );};return _cgega ,nil ;};

// SetFillColor sets background color for border.
func (_bfe *border )SetFillColor (col Color ){_bfe ._cfa =col };

// Height returns the height of the Paragraph. The height is calculated based on the input text and how it is wrapped
// within the container. Does not include Margins.
func (_gaaf *StyledParagraph )Height ()float64 {_gaaf .wrapText ();var _bgcb float64 ;for _ ,_gdfb :=range _gaaf ._cdeae {var _abfe float64 ;for _ ,_feff :=range _gdfb {_dbca :=_gaaf ._beea *_feff .Style .FontSize ;if _dbca > _abfe {_abfe =_dbca ;};};_bgcb +=_abfe ;
};return _bgcb ;};

// CreateFrontPage sets a function to generate a front Page.
func (_baca *Creator )CreateFrontPage (genFrontPageFunc func (_dbdd FrontpageFunctionArgs )){_baca ._gaeg =genFrontPageFunc ;};func _gedde (_deadf *_fd .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,238),Font :_deadf ,FontSize :10,OutlineSize :1,HorizontalScaling :DefaultHorizontalScaling ,UnderlineStyle :TextDecorationLineStyle {Offset :1,Thickness :1}};
};

// Height returns the current page height.
func (_cbegg *Creator )Height ()float64 {return _cbegg ._degf };func _ebaa ()*PageBreak {return &PageBreak {}};

// SkipCells skips over a specified number of cells in the table.
func (_dbbgc *Table )SkipCells (num int ){if num < 0{_bg .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};_dbbgc ._ddbf +=num ;};

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_dgcg *StyledParagraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _dgcg ._ddaff .Left ,_dgcg ._ddaff .Right ,_dgcg ._ddaff .Top ,_dgcg ._ddaff .Bottom ;};

// SetPadding sets the padding of the component. The padding represents
// inner margins which are applied around the contents of the division.
// The background of the component is not affected by its padding.
func (_bgcd *Division )SetPadding (left ,right ,top ,bottom float64 ){_bgcd ._gbaa .Left =left ;_bgcd ._gbaa .Right =right ;_bgcd ._gbaa .Top =top ;_bgcd ._gbaa .Bottom =bottom ;};

// Columns returns all the columns in the invoice line items table.
func (_cedf *Invoice )Columns ()[]*InvoiceCell {return _cedf ._dfa };

// SetOpacity sets the opacity of the line (0-1).
func (_ecbed *Line )SetOpacity (opacity float64 ){_ecbed ._fdff =opacity };type marginDrawable interface{VectorDrawable ;GetMargins ()(float64 ,float64 ,float64 ,float64 );};

// SetBorderWidth sets the border width.
func (_bgfc *CurvePolygon )SetBorderWidth (borderWidth float64 ){_bgfc ._abff .BorderWidth =borderWidth };

// SetFillOpacity sets the fill opacity.
func (_egba *Rectangle )SetFillOpacity (opacity float64 ){_egba ._abeed =opacity };func _fcge (_fcebb ,_cabe ,_caaac string ,_caabb uint ,_bace TextStyle )*TOCLine {return _dfcg (TextChunk {Text :_fcebb ,Style :_bace },TextChunk {Text :_cabe ,Style :_bace },TextChunk {Text :_caaac ,Style :_bace },_caabb ,_bace );
};func (_cddd *List )tableHeight (_ebacf float64 )float64 {var _ddac float64 ;for _ ,_ffcd :=range _cddd ._eadc {switch _aebc :=_ffcd ._bfdd .(type ){case *Paragraph :_efda :=_aebc ;if _efda ._bbde {_efda .SetWidth (_ebacf );};_ddac +=_efda .Height ()+_efda ._gadg .Bottom +_efda ._gadg .Bottom ;
_ddac +=0.5*_efda ._bec *_efda ._eabag ;case *StyledParagraph :_acac :=_aebc ;if _acac ._gffg {_acac .SetWidth (_ebacf );};_ddac +=_acac .Height ()+_acac ._ddaff .Top +_acac ._ddaff .Bottom ;_ddac +=0.5*_acac .getTextHeight ();default:_ddac +=_ffcd ._bfdd .Height ();
};};return _ddac ;};

// GetRowHeight returns the height of the specified row.
func (_fcbdg *Table )GetRowHeight (row int )(float64 ,error ){if row < 1||row > len (_fcbdg ._ecgdb ){return 0,_c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};return _fcbdg ._ecgdb [row -1],nil ;
};

// Level returns the indentation level of the TOC line.
func (_ceage *TOCLine )Level ()uint {return _ceage ._cfbg };

// SetLineSeparatorStyle sets the style for the separator part of all new
// lines of the table of contents.
func (_bcgfb *TOC )SetLineSeparatorStyle (style TextStyle ){_bcgfb ._edge =style };func _dfdfg (_afdc *_fd .PdfAnnotationLink )*_fd .PdfAnnotationLink {if _afdc ==nil {return nil ;};_ccegc :=_fd .NewPdfAnnotationLink ();_ccegc .BS =_afdc .BS ;_ccegc .A =_afdc .A ;
if _ccef ,_gefee :=_afdc .GetAction ();_gefee ==nil &&_ccef !=nil {_ccegc .SetAction (_ccef );};if _ggbbb ,_egbgf :=_afdc .Dest .(*_eg .PdfObjectArray );_egbgf {_ccegc .Dest =_eg .MakeArray (_ggbbb .Elements ()...);};return _ccegc ;};func (_eabb rgbColor )ToRGB ()(float64 ,float64 ,float64 ){return _eabb ._edcf ,_eabb ._ebcg ,_eabb ._abd ;
};

// TitleStyle returns the style properties used to render the invoice title.
func (_fbfb *Invoice )TitleStyle ()TextStyle {return _fbfb ._bfcc };

// SetColorRight sets border color for right.
func (_beff *border )SetColorRight (col Color ){_beff ._dce =col };

// SetNumber sets the number of the invoice.
func (_ffagb *Invoice )SetNumber (number string )(*InvoiceCell ,*InvoiceCell ){_ffagb ._daf [1].Value =number ;return _ffagb ._daf [0],_ffagb ._daf [1];};func (_dfbd *Creator )getActivePage ()*_fd .PdfPage {if _dfbd ._gdd ==nil {if len (_dfbd ._bfba )==0{return nil ;
};return _dfbd ._bfba [len (_dfbd ._bfba )-1];};return _dfbd ._gdd ;};

// SetBackgroundColor sets the cell's background color.
func (_abbgc *TableCell )SetBackgroundColor (col Color ){_abbgc ._dacbb =col };func (_fgcd *Invoice )generateInformationBlocks (_fgfae DrawContext )([]*Block ,DrawContext ,error ){_caged :=_ebda (_fgcd ._fbadd );_caged .SetMargins (0,0,0,20);_gbeb :=_fgcd .drawAddress (_fgcd ._bdde );
_gbeb =append (_gbeb ,_caged );_gbeb =append (_gbeb ,_fgcd .drawAddress (_fgcd ._ebcb )...);_defa :=_bfdc ();for _ ,_cadd :=range _gbeb {_defa .Add (_cadd );};_ddcg :=_fgcd .drawInformation ();_bcfb :=_fbcc (2);_bcfb .SetMargins (0,0,25,0);_afdb :=_bcfb .NewCell ();
_afdb .SetIndent (0);_afdb .SetContent (_defa );_afdb =_bcfb .NewCell ();_afdb .SetContent (_ddcg );return _bcfb .GeneratePageBlocks (_fgfae );};

// SetBackground sets the background properties of the component.
func (_degg *Division )SetBackground (background *Background ){_degg ._fefg =background };

// Title returns the title of the invoice.
func (_eeee *Invoice )Title ()string {return _eeee ._gaddb };

// NewFilledCurve returns a instance of filled curve.
func (_gbab *Creator )NewFilledCurve ()*FilledCurve {return _dfda ()};

// The Image type is used to draw an image onto PDF.
type Image struct{_cbec *_fd .XObjectImage ;_eaaf *_fd .Image ;_dffda float64 ;_ffab ,_dbffg float64 ;_dbgd ,_gfad float64 ;_feaaf Positioning ;_cage HorizontalAlignment ;_cgbe float64 ;_ead float64 ;_fgg float64 ;_cdda Margins ;_dacc ,_ebga float64 ;_cceb _eg .StreamEncoder ;
_dffa FitMode ;};

// AddInternalLink adds a new internal link to the paragraph.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
// The zoom of the destination page is controlled with the zoom
// parameter. Pass in 0 to keep the current zoom value.
func (_aecf *StyledParagraph )AddInternalLink (text string ,page int64 ,x ,y ,zoom float64 )*TextChunk {_fcdef :=NewTextChunk (text ,_aecf ._edcb );_fcdef ._cgaf =_cggcf (page -1,x ,y ,zoom );return _aecf .appendChunk (_fcdef );};

// Draw processes the specified Drawable widget and generates blocks that can
// be rendered to the output document. The generated blocks can span over one
// or more pages. Additional pages are added if the contents go over the current
// page. Each generated block is assigned to the creator page it will be
// rendered to. In order to render the generated blocks to the creator pages,
// call Finalize, Write or WriteToFile.
func (_efe *Creator )Draw (d Drawable )error {if _efe .getActivePage ()==nil {_efe .NewPage ();};_ebg ,_cbfb ,_gcgg :=d .GeneratePageBlocks (_efe ._acda );if _gcgg !=nil {return _gcgg ;};if len (_cbfb ._fefc )> 0{_efe .Errors =append (_efe .Errors ,_cbfb ._fefc ...);
};for _cgegb ,_cgdga :=range _ebg {if _cgegb > 0{_efe .NewPage ();};_ecge :=_efe .getActivePage ();if _cbcge ,_ecfb :=_efe ._bffe [_ecge ];_ecfb {if _ccae :=_cbcge .mergeBlocks (_cgdga );_ccae !=nil {return _ccae ;};if _dagag :=_cff (_cgdga ._dab ,_cbcge ._dab );
_dagag !=nil {return _dagag ;};}else {_efe ._bffe [_ecge ]=_cgdga ;};};_efe ._acda .X =_cbfb .X ;_efe ._acda .Y =_cbfb .Y ;_efe ._acda .Height =_cbfb .PageHeight -_cbfb .Y -_cbfb .Margins .Bottom ;return nil ;};func (_eefc *Creator )newPage ()*_fd .PdfPage {_eaef :=_fd .NewPdfPage ();
_fdgeg :=_eefc ._adde [0];_ceff :=_eefc ._adde [1];_bfce :=_fd .PdfRectangle {Llx :0,Lly :0,Urx :_fdgeg ,Ury :_ceff };_eaef .MediaBox =&_bfce ;_eefc ._bfg =_fdgeg ;_eefc ._degf =_ceff ;_eefc .initContext ();return _eaef ;};

// Table allows organizing content in an rows X columns matrix, which can spawn across multiple pages.
type Table struct{_ecea int ;_ecdg int ;_ddbf int ;_geefa []float64 ;_ecgdb []float64 ;_gddd float64 ;_abgf []*TableCell ;_dgea []int ;_aacdb Positioning ;_dfaff ,_dgcd float64 ;_ddedc Margins ;_gfbff bool ;_egcg int ;_ffefb int ;_gbfbcd bool ;_bfddd bool ;
};const (DefaultHorizontalScaling =100;);

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_dfaag *TOC )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_begd :=ctx ;_eabbf ,ctx ,_dfbc :=_dfaag ._cffgc .GeneratePageBlocks (ctx );if _dfbc !=nil {return _eabbf ,ctx ,_dfbc ;};for _ ,_agfdb :=range _dfaag ._bgbaf {_ddcgc :=_agfdb ._geba ;
if !_dfaag ._debd {_agfdb ._geba =0;};_badc ,_ddag ,_agcbf :=_agfdb .GeneratePageBlocks (ctx );_agfdb ._geba =_ddcgc ;if _agcbf !=nil {return _eabbf ,ctx ,_agcbf ;};if len (_badc )< 1{continue ;};_eabbf [len (_eabbf )-1].mergeBlocks (_badc [0]);_eabbf =append (_eabbf ,_badc [1:]...);
ctx =_ddag ;};if _dfaag ._eebdg .IsRelative (){ctx .X =_begd .X ;};if _dfaag ._eebdg .IsAbsolute (){return _eabbf ,_begd ,nil ;};return _eabbf ,ctx ,nil ;};func (_cc *Block )mergeBlocks (_ffc *Block )error {_eba :=_fab (_cc ._ba ,_cc ._dab ,_ffc ._ba ,_ffc ._dab );
if _eba !=nil {return _eba ;};for _ ,_eag :=range _ffc ._ag {_cc .AddAnnotation (_eag );};return nil ;};

// TextDecorationLineStyle represents the style of lines used to decorate
// a text chunk (e.g. underline).
type TextDecorationLineStyle struct{

// Color represents the color of the line (default: the color of the text).
Color Color ;

// Offset represents the vertical offset of the line (default: 1).
Offset float64 ;

// Thickness represents the thickness of the line (default: 1).
Thickness float64 ;};

// SetPageLabels adds the specified page labels to the PDF file generated
// by the creator. See section 12.4.2 "Page Labels" (p. 382 PDF32000_2008).
// NOTE: for existing PDF files, the page label ranges object can be obtained
// using the model.PDFReader's GetPageLabels method.
func (_cffbc *Creator )SetPageLabels (pageLabels _eg .PdfObject ){_cffbc ._aaa =pageLabels };

// Cols returns the total number of columns the table has.
func (_gcge *Table )Cols ()int {return _gcge ._ecdg };

// GetMargins returns the margins of the TOC line: left, right, top, bottom.
func (_gdff *TOCLine )GetMargins ()(float64 ,float64 ,float64 ,float64 ){_bffc :=&_gdff ._cfbag ._ddaff ;return _gdff ._gcdc ,_bffc .Right ,_bffc .Top ,_bffc .Bottom ;};const (TextAlignmentLeft TextAlignment =iota ;TextAlignmentRight ;TextAlignmentCenter ;
TextAlignmentJustify ;);func _fdef (_gfcca string )bool {_dafe :=func (_bccdb rune )bool {return _bccdb =='\u000A'};_gabaa :=_ad .TrimFunc (_gfcca ,_dafe );_eadd :=_ac .Paragraph {};_ ,_cbbb :=_eadd .SetString (_gabaa );if _cbbb !=nil {return true ;};_ecda ,_cbbb :=_eadd .Order ();
if _cbbb !=nil {return true ;};if _ecda .NumRuns ()< 1{return true ;};return _eadd .IsLeftToRight ();};

// Opacity returns the opacity of the line.
func (_edeg *Line )Opacity ()float64 {return _edeg ._fdff };

// GeneratePageBlocks draws the polyline on a new block representing the page.
// Implements the Drawable interface.
func (_efadg *Polyline )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_dfggb :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_abggb ,_gafd :=_dfggb .setOpacity (_efadg ._cfff ,_efadg ._cfff );if _gafd !=nil {return nil ,ctx ,_gafd ;
};_gadgb :=_efadg ._eadfd .Points ;for _bcacc :=range _gadgb {_ebcfa :=&_gadgb [_bcacc ];_ebcfa .Y =ctx .PageHeight -_ebcfa .Y ;};_gfe ,_ ,_gafd :=_efadg ._eadfd .Draw (_abggb );if _gafd !=nil {return nil ,ctx ,_gafd ;};if _gafd =_dfggb .addContentsByString (string (_gfe ));
_gafd !=nil {return nil ,ctx ,_gafd ;};return []*Block {_dfggb },ctx ,nil ;};

// NewParagraph creates a new text paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_egcaf *Creator )NewParagraph (text string )*Paragraph {return _ggfec (text ,_egcaf .NewTextStyle ());};

// Text sets the text content of the Paragraph.
func (_fcddg *Paragraph )Text ()string {return _fcddg ._eefd };

// SetAddressStyle sets the style properties used to render the content of
// the invoice address sections.
func (_egaa *Invoice )SetAddressStyle (style TextStyle ){_egaa ._bfced =style };func (_adfb *StyledParagraph )wrapWordChunks (){if !_adfb ._gbda {return ;};var _eedf []*TextChunk ;for _ ,_fagbg :=range _adfb ._aacee {_dcbg ,_cceg :=_abdde (_fagbg .Text );
if _cceg !=nil {_bg .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0062\u0072\u0065\u0061\u006b\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0074\u006f\u0020w\u006f\u0072\u0064\u0073\u003a\u0020\u0025\u0076",_cceg );
_dcbg =[]string {_fagbg .Text };};for _ ,_bgde :=range _dcbg {_eeef :=NewTextChunk (_bgde ,_fagbg .Style );_eedf =append (_eedf ,_eeef );};};if len (_eedf )> 0{_adfb ._aacee =_eedf ;};};

// SkipRows skips over a specified number of rows in the table.
func (_gaaa *Table )SkipRows (num int ){_adacfg :=num *_gaaa ._ecdg -1;if _adacfg < 0{_bg .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};_gaaa ._ddbf +=_adacfg ;};

// NewCurve returns new instance of Curve between points (x1,y1) and (x2, y2) with control point (cx,cy).
func (_aafa *Creator )NewCurve (x1 ,y1 ,cx ,cy ,x2 ,y2 float64 )*Curve {return _gagce (x1 ,y1 ,cx ,cy ,x2 ,y2 );};

// NewDivision returns a new Division container component.
func (_dcde *Creator )NewDivision ()*Division {return _bfdc ()};

// SetMargins sets the margins of the component. The margins are applied
// around the division.
func (_cead *Division )SetMargins (left ,right ,top ,bottom float64 ){_cead ._cfe .Left =left ;_cead ._cfe .Right =right ;_cead ._cfe .Top =top ;_cead ._cfe .Bottom =bottom ;};func _gfaf (_beaaf []byte )(*Image ,error ){_bggag :=_b .NewReader (_beaaf );
_ffca ,_fgcc :=_fd .ImageHandling .Read (_bggag );if _fgcc !=nil {_bg .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_fgcc );return nil ,_fgcc ;};return _ebcdc (_ffca );
};

// SetMargins sets the margins of the paragraph.
func (_eabe *List )SetMargins (left ,right ,top ,bottom float64 ){_eabe ._edgd .Left =left ;_eabe ._edgd .Right =right ;_eabe ._edgd .Top =top ;_eabe ._edgd .Bottom =bottom ;};

// SetAngle sets the rotation angle of the text.
func (_geedg *StyledParagraph )SetAngle (angle float64 ){_geedg ._ccaca =angle };func _gagfgf (_fdgfb ,_bfbf ,_cbgdc float64 )(_bccc ,_ffbb ,_eccdf ,_gece float64 ){if _cbgdc ==0{return 0,0,_fdgfb ,_bfbf ;};_fggd :=_f .Path {Points :[]_f .Point {_f .NewPoint (0,0).Rotate (_cbgdc ),_f .NewPoint (_fdgfb ,0).Rotate (_cbgdc ),_f .NewPoint (0,_bfbf ).Rotate (_cbgdc ),_f .NewPoint (_fdgfb ,_bfbf ).Rotate (_cbgdc )}}.GetBoundingBox ();
return _fggd .X ,_fggd .Y ,_fggd .Width ,_fggd .Height ;};func _cgfg (_eage *Block ,_beadc *Image ,_aff DrawContext )(DrawContext ,error ){_abga :=_aff ;_cdad :=1;_ebba :=_eg .PdfObjectName (_gg .Sprintf ("\u0049\u006d\u0067%\u0064",_cdad ));for _eage ._dab .HasXObjectByName (_ebba ){_cdad ++;
_ebba =_eg .PdfObjectName (_gg .Sprintf ("\u0049\u006d\u0067%\u0064",_cdad ));};_cfeb :=_eage ._dab .SetXObjectImageByName (_ebba ,_beadc ._cbec );if _cfeb !=nil {return _aff ,_cfeb ;};_bfbag :=0;_cdde :=_eg .PdfObjectName (_gg .Sprintf ("\u0047\u0053\u0025\u0064",_bfbag ));
for _eage ._dab .HasExtGState (_cdde ){_bfbag ++;_cdde =_eg .PdfObjectName (_gg .Sprintf ("\u0047\u0053\u0025\u0064",_bfbag ));};_gegdg :=_eg .MakeDict ();_gegdg .Set ("\u0042\u004d",_eg .MakeName ("\u004e\u006f\u0072\u006d\u0061\u006c"));if _beadc ._fgg < 1.0{_gegdg .Set ("\u0043\u0041",_eg .MakeFloat (_beadc ._fgg ));
_gegdg .Set ("\u0063\u0061",_eg .MakeFloat (_beadc ._fgg ));};_cfeb =_eage ._dab .AddExtGState (_cdde ,_eg .MakeIndirectObject (_gegdg ));if _cfeb !=nil {return _aff ,_cfeb ;};_cbdd :=_beadc .Width ();_cagg :=_beadc .Height ();_ ,_gcfd :=_beadc .rotatedSize ();
_egecd :=_aff .X ;_cgbeb :=_aff .PageHeight -_aff .Y -_cagg ;if _beadc ._feaaf .IsRelative (){_cgbeb -=(_gcfd -_cagg )/2;switch _beadc ._cage {case HorizontalAlignmentCenter :_egecd +=(_aff .Width -_cbdd )/2;case HorizontalAlignmentRight :_egecd =_aff .PageWidth -_aff .Margins .Right -_beadc ._cdda .Right -_cbdd ;
};};_aec :=_beadc ._dffda ;_gdga :=_af .NewContentCreator ();_gdga .Add_gs (_cdde );_gdga .Translate (_egecd ,_cgbeb );if _aec !=0{_gdga .Translate (_cbdd /2,_cagg /2);_gdga .RotateDeg (_aec );_gdga .Translate (-_cbdd /2,-_cagg /2);};_gdga .Scale (_cbdd ,_cagg ).Add_Do (_ebba );
_gaebf :=_gdga .Operations ();_gaebf .WrapIfNeeded ();_eage .addContents (_gaebf );if _beadc ._feaaf .IsRelative (){_aff .Y +=_gcfd ;_aff .Height -=_gcfd ;return _aff ,nil ;};return _abga ,nil ;};func (_ddae *StyledParagraph )split (_egbg DrawContext )(_aadb ,_dbbf *StyledParagraph ,_fdac error ){if _fdac =_ddae .wrapChunks (false );
_fdac !=nil {return nil ,nil ,_fdac ;};_gffgb :=func (_adbbd []*TextChunk ,_bgec []*TextChunk )[]*TextChunk {if len (_bgec )==0{return _adbbd ;};_caga :=len (_adbbd );if _caga ==0{return append (_adbbd ,_bgec ...);};_adbbd [_caga -1].Text +=_bgec [0].Text ;
return append (_adbbd ,_bgec [1:]...);};_cbfab :=func (_aceg *StyledParagraph ,_gaegf []*TextChunk )*StyledParagraph {if len (_gaegf )==0{return nil ;};_gbdgg :=*_aceg ;_gbdgg ._aacee =_gaegf ;return &_gbdgg ;};var (_abfff float64 ;_cecb []*TextChunk ;
_aceab []*TextChunk ;);for _ ,_fdad :=range _ddae ._cdeae {var _bbbf float64 ;_ffbfe :=make ([]*TextChunk ,0,len (_fdad ));for _ ,_dcdd :=range _fdad {if _adggf :=_dcdd .Style .FontSize ;_adggf > _bbbf {_bbbf =_adggf ;};_ffbfe =append (_ffbfe ,_dcdd .clone ());
};_bbbf *=_ddae ._beea ;if _ddae ._bgdg .IsRelative (){if _abfff +_bbbf > _egbg .Height {_aceab =_gffgb (_aceab ,_ffbfe );}else {_cecb =_gffgb (_cecb ,_ffbfe );};};_abfff +=_bbbf ;};_ddae ._cdeae =nil ;if len (_aceab )==0{return _ddae ,nil ,nil ;};return _cbfab (_ddae ,_cecb ),_cbfab (_ddae ,_aceab ),nil ;
};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_defg *TOCLine )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fdbe :=ctx ;_gbfc ,ctx ,_gcgfc :=_defg ._cfbag .GeneratePageBlocks (ctx );if _gcgfc !=nil {return _gbfc ,ctx ,_gcgfc ;};if _defg ._afce .IsRelative (){ctx .X =_fdbe .X ;
};if _defg ._afce .IsAbsolute (){return _gbfc ,_fdbe ,nil ;};return _gbfc ,ctx ,nil ;};func _aeegb (_fabge string )*_fd .PdfAnnotation {_gbcaa :=_fd .NewPdfAnnotationLink ();_fgdf :=_fd .NewBorderStyle ();_fgdf .SetBorderWidth (0);_gbcaa .BS =_fgdf .ToPdfObject ();
_bgdef :=_fd .NewPdfActionURI ();_bgdef .URI =_eg .MakeString (_fabge );_gbcaa .SetAction (_bgdef .PdfAction );return _gbcaa .PdfAnnotation ;};var (PageSizeA3 =PageSize {297*PPMM ,420*PPMM };PageSizeA4 =PageSize {210*PPMM ,297*PPMM };PageSizeA5 =PageSize {148*PPMM ,210*PPMM };
PageSizeLetter =PageSize {8.5*PPI ,11*PPI };PageSizeLegal =PageSize {8.5*PPI ,14*PPI };);

// AddressStyle returns the style properties used to render the content of
// the invoice address sections.
func (_eaed *Invoice )AddressStyle ()TextStyle {return _eaed ._bfced };

// SetAngle sets the rotation angle of the text.
func (_ggeb *Paragraph )SetAngle (angle float64 ){_ggeb ._bdeb =angle };

// PageFinalize sets a function to be called for each page before finalization
// (i.e. the last stage of page processing before they get written out).
// The callback function allows final touch-ups for each page, and it
// provides information that might not be known at other stages of designing
// the document (e.g. the total number of pages). Unlike the header/footer
// functions, which are limited to the top/bottom margins of the page, the
// finalize function can be used draw components anywhere on the current page.
func (_abac *Creator )PageFinalize (pageFinalizeFunc func (_bbab PageFinalizeFunctionArgs )error ){_abac ._aded =pageFinalizeFunc ;};

// SetBorderWidth sets the border width.
func (_cdbg *Polygon )SetBorderWidth (borderWidth float64 ){_cdbg ._egdcc .BorderWidth =borderWidth };

// SetFillColor sets the fill color.
func (_cacde *Ellipse )SetFillColor (col Color ){_cacde ._fgcg =col };

// SetLineSeparator sets the separator for all new lines of the table of contents.
func (_dgff *TOC )SetLineSeparator (separator string ){_dgff ._eadg =separator };func (_afca *StyledParagraph )getTextLineWidth (_aedf []*TextChunk )float64 {var _gbcb float64 ;_cfbc :=len (_aedf );for _bfcce ,_cdecd :=range _aedf {_ceca :=&_cdecd .Style ;
_aegd :=len (_cdecd .Text );for _ccbbf ,_bfbb :=range _cdecd .Text {if _bfbb =='\u000A'{continue ;};_eegda ,_gaabf :=_ceca .Font .GetRuneMetrics (_bfbb );if !_gaabf {_bg .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_bfbb );
return -1;};_gbcb +=_ceca .FontSize *_eegda .Wx *_ceca .horizontalScale ();if _bfbb !=' '&&(_bfcce !=_cfbc -1||_ccbbf !=_aegd -1){_gbcb +=_ceca .CharSpacing *1000.0;};};};return _gbcb ;};

// SetLinePageStyle sets the style for the page part of all new lines
// of the table of contents.
func (_cbfbc *TOC )SetLinePageStyle (style TextStyle ){_cbfbc ._ebdec =style };

// GetOptimizer returns current PDF optimizer.
func (_fcee *Creator )GetOptimizer ()_fd .Optimizer {return _fcee ._fda };

// Angle returns the block rotation angle in degrees.
func (_gcg *Block )Angle ()float64 {return _gcg ._dg };

// Color returns the color of the line.
func (_beab *Line )Color ()Color {return _beab ._dbge };func _fab (_ebc *_af .ContentStreamOperations ,_bgg *_fd .PdfPageResources ,_gbc *_af .ContentStreamOperations ,_edf *_fd .PdfPageResources )error {_dbf :=map[_eg .PdfObjectName ]_eg .PdfObjectName {};
_ecc :=map[_eg .PdfObjectName ]_eg .PdfObjectName {};_fcd :=map[_eg .PdfObjectName ]_eg .PdfObjectName {};_bfa :=map[_eg .PdfObjectName ]_eg .PdfObjectName {};_gbd :=map[_eg .PdfObjectName ]_eg .PdfObjectName {};_agc :=map[_eg .PdfObjectName ]_eg .PdfObjectName {};
for _ ,_gegc :=range *_gbc {switch _gegc .Operand {case "\u0044\u006f":if len (_gegc .Params )==1{if _add ,_gbe :=_gegc .Params [0].(*_eg .PdfObjectName );_gbe {if _ ,_fbfe :=_dbf [*_add ];!_fbfe {var _cdfc _eg .PdfObjectName ;_gad ,_ :=_edf .GetXObjectByName (*_add );
if _gad !=nil {_cdfc =*_add ;for {_ega ,_ :=_bgg .GetXObjectByName (_cdfc );if _ega ==nil ||_ega ==_gad {break ;};_cdfc =_cdfc +"\u0030";};};_bgg .SetXObjectByName (_cdfc ,_gad );_dbf [*_add ]=_cdfc ;};_eab :=_dbf [*_add ];_gegc .Params [0]=&_eab ;};};
case "\u0054\u0066":if len (_gegc .Params )==2{if _bc ,_bgeg :=_gegc .Params [0].(*_eg .PdfObjectName );_bgeg {if _ ,_fdg :=_ecc [*_bc ];!_fdg {_ddc ,_gee :=_edf .GetFontByName (*_bc );_gga :=*_bc ;if _gee &&_ddc !=nil {_gga =_cbc (_bc .String (),_ddc ,_bgg );
};_bgg .SetFontByName (_gga ,_ddc );_ecc [*_bc ]=_gga ;};_cad :=_ecc [*_bc ];_gegc .Params [0]=&_cad ;};};case "\u0043\u0053","\u0063\u0073":if len (_gegc .Params )==1{if _faa ,_gae :=_gegc .Params [0].(*_eg .PdfObjectName );_gae {if _ ,_gagc :=_fcd [*_faa ];
!_gagc {var _fbbg _eg .PdfObjectName ;_bb ,_dga :=_edf .GetColorspaceByName (*_faa );if _dga {_fbbg =*_faa ;for {_gbb ,_aag :=_bgg .GetColorspaceByName (_fbbg );if !_aag ||_bb ==_gbb {break ;};_fbbg =_fbbg +"\u0030";};_bgg .SetColorspaceByName (_fbbg ,_bb );
_fcd [*_faa ]=_fbbg ;}else {_bg .Log .Debug ("C\u006fl\u006f\u0072\u0073\u0070\u0061\u0063\u0065\u0020n\u006f\u0074\u0020\u0066ou\u006e\u0064");};};if _gfc ,_ffe :=_fcd [*_faa ];_ffe {_gegc .Params [0]=&_gfc ;}else {_bg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0043\u006f\u006co\u0072\u0073\u0070\u0061\u0063\u0065\u0020%\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064",*_faa );
};};};case "\u0053\u0043\u004e","\u0073\u0063\u006e":if len (_gegc .Params )==1{if _ee ,_dgc :=_gegc .Params [0].(*_eg .PdfObjectName );_dgc {if _ ,_fbbf :=_bfa [*_ee ];!_fbbf {var _ddb _eg .PdfObjectName ;_egb ,_daaa :=_edf .GetPatternByName (*_ee );if _daaa {_ddb =*_ee ;
for {_dba ,_ecca :=_bgg .GetPatternByName (_ddb );if !_ecca ||_dba ==_egb {break ;};_ddb =_ddb +"\u0030";};_gage :=_bgg .SetPatternByName (_ddb ,_egb .ToPdfObject ());if _gage !=nil {return _gage ;};_bfa [*_ee ]=_ddb ;};};if _geb ,_bcd :=_bfa [*_ee ];_bcd {_gegc .Params [0]=&_geb ;
};};};case "\u0073\u0068":if len (_gegc .Params )==1{if _fcc ,_cde :=_gegc .Params [0].(*_eg .PdfObjectName );_cde {if _ ,_dfcf :=_gbd [*_fcc ];!_dfcf {var _gbde _eg .PdfObjectName ;_adf ,_abb :=_edf .GetShadingByName (*_fcc );if _abb {_gbde =*_fcc ;for {_acbc ,_ebcd :=_bgg .GetShadingByName (_gbde );
if !_ebcd ||_adf ==_acbc {break ;};_gbde =_gbde +"\u0030";};_bfd :=_bgg .SetShadingByName (_gbde ,_adf .ToPdfObject ());if _bfd !=nil {_bg .Log .Debug ("E\u0052\u0052\u004f\u0052 S\u0065t\u0020\u0073\u0068\u0061\u0064i\u006e\u0067\u003a\u0020\u0025\u0076",_bfd );
return _bfd ;};_gbd [*_fcc ]=_gbde ;}else {_bg .Log .Debug ("\u0053\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};};if _ffa ,_fecd :=_gbd [*_fcc ];_fecd {_gegc .Params [0]=&_ffa ;}else {_bg .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020S\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u0025\u0073 \u006e\u006f\u0074 \u0066o\u0075\u006e\u0064",*_fcc );
};};};case "\u0067\u0073":if len (_gegc .Params )==1{if _cba ,_cec :=_gegc .Params [0].(*_eg .PdfObjectName );_cec {if _ ,_cgd :=_agc [*_cba ];!_cgd {var _egad _eg .PdfObjectName ;_aee ,_dda :=_edf .GetExtGState (*_cba );if _dda {_egad =*_cba ;_cbaa :=1;
for {_ece ,_fgf :=_bgg .GetExtGState (_egad );if !_fgf ||_aee ==_ece {break ;};_egad =_eg .PdfObjectName (_gg .Sprintf ("\u0047\u0053\u0025\u0064",_cbaa ));_cbaa ++;};};_bgg .AddExtGState (_egad ,_aee );_agc [*_cba ]=_egad ;};_eaf :=_agc [*_cba ];_gegc .Params [0]=&_eaf ;
};};};*_ebc =append (*_ebc ,_gegc );};return nil ;};

// SetBorderColor sets border color.
func (_ecgeee *Rectangle )SetBorderColor (col Color ){_ecgeee ._aabc =col };

// EnableRowWrap controls whether rows are wrapped across pages.
// NOTE: Currently, row wrapping is supported for rows using StyledParagraphs.
func (_geeg *Table )EnableRowWrap (enable bool ){_geeg ._gbfbcd =enable };

// NewTextChunk returns a new text chunk instance.
func NewTextChunk (text string ,style TextStyle )*TextChunk {return &TextChunk {Text :text ,Style :style };};

// SetPositioning sets Rectangle's position attribute.
func (_cbecf *Rectangle )SetPositioning (position Positioning ){_cbecf ._eeedg =position };

// SetAngle sets Image rotation angle in degrees.
func (_fcfd *Image )SetAngle (angle float64 ){_fcfd ._dffda =angle };

// SetFillColor sets the fill color.
func (_dbbe *Polygon )SetFillColor (color Color ){_dbbe ._egdcc .FillColor =_ecb (color )};

// SetBorderOpacity sets the border opacity.
func (_egab *CurvePolygon )SetBorderOpacity (opacity float64 ){_egab ._gcac =opacity };func (_efde *Table )moveToNextAvailableCell ()int {_dgfb :=(_efde ._ddbf -1)%(_efde ._ecdg )+1;for {if _dgfb -1>=len (_efde ._dgea ){return _dgfb ;}else if _efde ._dgea [_dgfb -1]==0{return _dgfb ;
}else {_efde ._ddbf ++;_efde ._dgea [_dgfb -1]--;};_dgfb ++;};};func _dfbdg (_bbc VectorDrawable ,_cdcc float64 )float64 {switch _gdaae :=_bbc .(type ){case *Paragraph :if _gdaae ._bbde {_gdaae .SetWidth (_cdcc -_gdaae ._gadg .Left -_gdaae ._gadg .Right );
};return _gdaae .Height ()+_gdaae ._gadg .Top +_gdaae ._gadg .Bottom ;case *StyledParagraph :if _gdaae ._gffg {_gdaae .SetWidth (_cdcc -_gdaae ._ddaff .Left -_gdaae ._ddaff .Right );};return _gdaae .Height ()+_gdaae ._ddaff .Top +_gdaae ._ddaff .Bottom ;
case *Image :_gdaae .applyFitMode (_cdcc );return _gdaae .Height ()+_gdaae ._cdda .Top +_gdaae ._cdda .Bottom ;case marginDrawable :_ ,_ ,_fbga ,_fdbc :=_gdaae .GetMargins ();return _gdaae .Height ()+_fbga +_fdbc ;default:return _gdaae .Height ();};};

// Color interface represents colors in the PDF creator.
type Color interface{ToRGB ()(float64 ,float64 ,float64 );};

// GetCoords returns coordinates of border.
func (_fbfa *border )GetCoords ()(float64 ,float64 ){return _fbfa ._fgbb ,_fbfa ._bcg };

// GeneratePageBlocks generates a page break block.
func (_dfac *PageBreak )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cfdd :=[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y ),NewBlock (ctx .PageWidth ,ctx .PageHeight )};ctx .Page ++;_afgcd :=ctx ;_afgcd .Y =ctx .Margins .Top ;
_afgcd .X =ctx .Margins .Left ;_afgcd .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom ;_afgcd .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right ;ctx =_afgcd ;return _cfdd ,ctx ,nil ;};

// Width returns Ellipse's document width.
func (_fefcd *Ellipse )Width ()float64 {return _fefcd ._gcf };

// SetBuyerAddress sets the buyer address of the invoice.
func (_adcb *Invoice )SetBuyerAddress (address *InvoiceAddress ){_adcb ._ebcb =address };

// Height returns the Block's height.
func (_eff *Block )Height ()float64 {return _eff ._ef };

// NewSubchapter creates a new child chapter with the specified title.
func (_ecf *Chapter )NewSubchapter (title string )*Chapter {_ffcb :=_eabc (_ecf ._babb ._geef );_ffcb .FontSize =14;_ecf ._gge ++;_ggg :=_ggfc (_ecf ,_ecf ._ccd ,_ecf ._ecd ,title ,_ecf ._gge ,_ffcb );_ecf .Add (_ggg );return _ggg ;};

// SetMargins sets the Paragraph's margins.
func (_gcdf *Paragraph )SetMargins (left ,right ,top ,bottom float64 ){_gcdf ._gadg .Left =left ;_gcdf ._gadg .Right =right ;_gcdf ._gadg .Top =top ;_gcdf ._gadg .Bottom =bottom ;};func _ggfec (_cgbea string ,_gbecf TextStyle )*Paragraph {_fcad :=&Paragraph {_eefd :_cgbea ,_geef :_gbecf .Font ,_bec :_gbecf .FontSize ,_eabag :1.0,_bbde :true ,_dcbb :true ,_adfg :TextAlignmentLeft ,_bdeb :0,_cga :1,_bccdf :1,_gfbe :PositionRelative };
_fcad .SetColor (_gbecf .Color );return _fcad ;};

// NewPolyBezierCurve creates a new composite Bezier (polybezier) curve.
func (_gcdg *Creator )NewPolyBezierCurve (curves []_f .CubicBezierCurve )*PolyBezierCurve {return _cfdbc (curves );};

// SetLink makes the line an internal link.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
func (_abbff *TOCLine )SetLink (page int64 ,x ,y float64 ){_abbff ._aacdc =x ;_abbff ._cddff =y ;_abbff ._geba =page ;_acegf :=_abbff ._cfbag ._edcb .Color ;_abbff .Number .Style .Color =_acegf ;_abbff .Title .Style .Color =_acegf ;_abbff .Separator .Style .Color =_acegf ;
_abbff .Page .Style .Color =_acegf ;};

// Width is not used. The list component is designed to fill into the available
// width depending on the context. Returns 0.
func (_fece *List )Width ()float64 {return 0};

// EnablePageWrap controls whether the table is wrapped across pages.
// If disabled, the table is moved in its entirety on a new page, if it
// does not fit in the available height. By default, page wrapping is enabled.
// If the height of the table is larger than an entire page, wrapping is
// enabled automatically in order to avoid unwanted behavior.
func (_cffg *Table )EnablePageWrap (enable bool ){_cffg ._bfddd =enable };

// SetMaxLines sets the maximum number of lines before the paragraph
// text is truncated.
func (_bbdd *Paragraph )SetMaxLines (maxLines int ){_bbdd ._adacf =maxLines ;_bbdd .wrapText ()};

// Height returns the height of the division, assuming all components are
// stacked on top of each other.
func (_ebgc *Division )Height ()float64 {var _acdc float64 ;for _ ,_efef :=range _ebgc ._bcfe {switch _eda :=_efef .(type ){case marginDrawable :_ ,_ ,_edb ,_abg :=_eda .GetMargins ();_acdc +=_eda .Height ()+_edb +_abg ;default:_acdc +=_eda .Height ();
};};return _acdc ;};

// SetLineColor sets the line color.
func (_edgg *Polyline )SetLineColor (color Color ){_edgg ._eadfd .LineColor =_ecb (color )};

// SetFillColor sets the fill color.
func (_ccebg *Rectangle )SetFillColor (col Color ){_ccebg ._gbdd =col };

// Height returns the height of the Paragraph. The height is calculated based on the input text and
// how it is wrapped within the container. Does not include Margins.
func (_aceba *Paragraph )Height ()float64 {_aceba .wrapText ();return float64 (len (_aceba ._gacac ))*_aceba ._eabag *_aceba ._bec ;};func _cggcf (_ageff int64 ,_agff ,_fgcf ,_bafcf float64 )*_fd .PdfAnnotation {_gdaf :=_fd .NewPdfAnnotationLink ();_ddeae :=_fd .NewBorderStyle ();
_ddeae .SetBorderWidth (0);_gdaf .BS =_ddeae .ToPdfObject ();if _ageff < 0{_ageff =0;};_gdaf .Dest =_eg .MakeArray (_eg .MakeInteger (_ageff ),_eg .MakeName ("\u0058\u0059\u005a"),_eg .MakeFloat (_agff ),_eg .MakeFloat (_fgcf ),_eg .MakeFloat (_bafcf ));
return _gdaf .PdfAnnotation ;};func _ebda (_gccb TextStyle )*StyledParagraph {return &StyledParagraph {_aacee :[]*TextChunk {},_defe :_gccb ,_edcb :_gedde (_gccb .Font ),_beea :1.0,_faf :TextAlignmentLeft ,_gffg :true ,_bcgg :true ,_gbda :false ,_ccaca :0,_bfge :1,_ddga :1,_bgdg :PositionRelative };
};func _ggfc (_eeg *Chapter ,_fdc *TOC ,_cgfa *_fd .Outline ,_bae string ,_ebfb int ,_dea TextStyle )*Chapter {var _dfg uint =1;if _eeg !=nil {_dfg =_eeg ._acd +1;};_effb :=&Chapter {_eeb :_ebfb ,_gec :_bae ,_cffb :true ,_dbg :true ,_cfc :_eeg ,_ccd :_fdc ,_ecd :_cgfa ,_gebf :[]Drawable {},_acd :_dfg };
_befc :=_ggfec (_effb .headingText (),_dea );_befc .SetFont (_dea .Font );_befc .SetFontSize (_dea .FontSize );_effb ._babb =_befc ;return _effb ;};

// NewEllipse creates a new ellipse centered at (xc,yc) with a width and height specified.
func (_bdbe *Creator )NewEllipse (xc ,yc ,width ,height float64 )*Ellipse {return _fcdg (xc ,yc ,width ,height );};

// SetWidthBottom sets border width for bottom.
func (_bgeb *border )SetWidthBottom (bw float64 ){_bgeb ._gea =bw };

// CellBorderStyle defines the table cell's border style.
type CellBorderStyle int ;

// UnsupportedRuneError is an error that occurs when there is unsupported glyph being used.
type UnsupportedRuneError struct{Message string ;Rune rune ;};func _egdd (_adgg [][]_f .Point )*Polygon {return &Polygon {_egdcc :&_f .Polygon {Points :_adgg },_gfac :1.0,_geag :1.0};};

// NewCurvePolygon creates a new curve polygon.
func (_def *Creator )NewCurvePolygon (rings [][]_f .CubicBezierCurve )*CurvePolygon {return _cgfc (rings );};

// Fit fits the chunk into the specified bounding box, cropping off the
// remainder in a new chunk, if it exceeds the specified dimensions.
// NOTE: The method assumes a line height of 1.0. In order to account for other
// line height values, the passed in height must be divided by the line height:
// height = height / lineHeight
func (_gedf *TextChunk )Fit (width ,height float64 )(*TextChunk ,error ){_eafgdf ,_abaeg :=_gedf .Wrap (width );if _abaeg !=nil {return nil ,_abaeg ;};_bdgb :=int (height /_gedf .Style .FontSize );if _bdgb >=len (_eafgdf ){return nil ,nil ;};_cdeeb :="\u000a";
_gedf .Text =_ad .Replace (_ad .Join (_eafgdf [:_bdgb ],"\u0020"),_cdeeb +"\u0020",_cdeeb ,-1);_fdcg :=_ad .Replace (_ad .Join (_eafgdf [_bdgb :],"\u0020"),_cdeeb +"\u0020",_cdeeb ,-1);return NewTextChunk (_fdcg ,_gedf .Style ),nil ;};

// SetShowLinks sets visibility of links for the TOC lines.
func (_ffgf *TOC )SetShowLinks (showLinks bool ){_ffgf ._debd =showLinks };

// DashPattern returns the dash pattern of the line.
func (_ccg *Line )DashPattern ()(_fcbd []int64 ,_eccd int64 ){return _ccg ._abgaf ,_ccg ._fdgafa };

// SetMargins sets the Chapter margins: left, right, top, bottom.
// Typically not needed as the creator's page margins are used.
func (_fca *Chapter )SetMargins (left ,right ,top ,bottom float64 ){_fca ._dcf .Left =left ;_fca ._dcf .Right =right ;_fca ._dcf .Top =top ;_fca ._dcf .Bottom =bottom ;};

// New creates a new instance of the PDF Creator.
func New ()*Creator {const _bba ="c\u0072\u0065\u0061\u0074\u006f\u0072\u002e\u004e\u0065\u0077";_abfg :=&Creator {};_abfg ._bfba =[]*_fd .PdfPage {};_abfg ._bffe =map[*_fd .PdfPage ]*Block {};_abfg ._abfd =map[*_fd .PdfPage ]*pageTransformations {};_abfg .SetPageSize (PageSizeLetter );
_geed :=0.1*_abfg ._bfg ;_abfg ._bdbc .Left =_geed ;_abfg ._bdbc .Right =_geed ;_abfg ._bdbc .Top =_geed ;_abfg ._bdbc .Bottom =_geed ;var _abbc error ;_abfg ._daaf ,_abbc =_fd .NewStandard14Font (_fd .HelveticaName );if _abbc !=nil {_abfg ._daaf =_fd .DefaultFont ();
};_abfg ._egce ,_abbc =_fd .NewStandard14Font (_fd .HelveticaBoldName );if _abbc !=nil {_abfg ._daaf =_fd .DefaultFont ();};_abfg ._gcd =_abfg .NewTOC ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073");
_abfg .AddOutlines =true ;_abfg ._baec =_fd .NewOutline ();_cd .TrackUse (_bba );return _abfg ;};func _fccc (_fbccd string ,_babbg bool )string {_bgag :=_fbccd ;if _bgag ==""{return "";};_bdfe :=_ac .Paragraph {};_ ,_dcaae :=_bdfe .SetString (_fbccd );
if _dcaae !=nil {return _bgag ;};_agcg ,_dcaae :=_bdfe .Order ();if _dcaae !=nil {return _bgag ;};_cadcc :=_agcg .NumRuns ();_dfbcc :=make ([]string ,_cadcc );for _bbed :=0;_bbed < _agcg .NumRuns ();_bbed ++{_fcba :=_agcg .Run (_bbed );_eddc :=_fcba .String ();
if _fcba .Direction ()==_ac .RightToLeft {_eddc =_ac .ReverseString (_eddc );};if _babbg {_dfbcc [_bbed ]=_eddc ;}else {_dfbcc [_cadcc -1]=_eddc ;};_cadcc --;};if len (_dfbcc )!=_agcg .NumRuns (){return _fbccd ;};_bgag =_ad .Join (_dfbcc ,"");return _bgag ;
};

// Subtotal returns the invoice subtotal description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_bgdb *Invoice )Subtotal ()(*InvoiceCell ,*InvoiceCell ){return _bgdb ._ceefd [0],_bgdb ._ceefd [1];};

// SetEnableWrap sets the line wrapping enabled flag.
func (_caccg *Paragraph )SetEnableWrap (enableWrap bool ){_caccg ._bbde =enableWrap ;_caccg ._dcbb =false ;};func _edeeb (_abdf *Block ,_dgf *StyledParagraph ,_ddda [][]*TextChunk ,_cadf DrawContext )(DrawContext ,[][]*TextChunk ,error ){_bdee :=1;_dcea :=_eg .PdfObjectName (_gg .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_bdee ));
for _abdf ._dab .HasFontByName (_dcea ){_bdee ++;_dcea =_eg .PdfObjectName (_gg .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_bdee ));};_gcea :=_abdf ._dab .SetFontByName (_dcea ,_dgf ._defe .Font .ToPdfObject ());if _gcea !=nil {return _cadf ,nil ,_gcea ;
};_bdee ++;_edae :=_dcea ;_efgg :=_dgf ._defe .FontSize ;_ebffa :=_dgf ._bgdg .IsRelative ();var _adgbc [][]_eg .PdfObjectName ;var _cfad [][]*TextChunk ;var _dcdeb float64 ;for _cafa ,_aacbd :=range _ddda {var _gfbbd []_eg .PdfObjectName ;var _gebgg float64 ;
if len (_aacbd )> 0{_gebgg =_aacbd [0].Style .FontSize ;};for _ ,_gbgf :=range _aacbd {_ceac :=_gbgf .Style ;if _gbgf .Text !=""&&_ceac .FontSize > _gebgg {_gebgg =_ceac .FontSize ;};_dcea =_eg .PdfObjectName (_gg .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_bdee ));
_gcbc :=_abdf ._dab .SetFontByName (_dcea ,_ceac .Font .ToPdfObject ());if _gcbc !=nil {return _cadf ,nil ,_gcbc ;};_gfbbd =append (_gfbbd ,_dcea );_bdee ++;};_gebgg *=_dgf ._beea ;if _ebffa &&_dcdeb +_gebgg > _cadf .Height {_cfad =_ddda [_cafa :];_ddda =_ddda [:_cafa ];
break ;};_dcdeb +=_gebgg ;_adgbc =append (_adgbc ,_gfbbd );};_dcbf ,_fffg ,_eadb :=_dgf .getLineMetrics (0);_ecbg ,_cefcd :=_dcbf *_dgf ._beea ,_fffg *_dgf ._beea ;if len (_ddda )==0{return _cadf ,_cfad ,nil ;};_bce :=_af .NewContentCreator ();_bce .Add_q ();
_egcd :=_cefcd ;if _dgf ._ccgf ==TextVerticalAlignmentCenter {_egcd =_fffg +(_dcbf +_eadb -_fffg )/2+(_cefcd -_fffg )/2;};_gbbe :=_cadf .PageHeight -_cadf .Y -_egcd ;_bce .Translate (_cadf .X ,_gbbe );_ceeeg :=_gbbe ;if _dgf ._ccaca !=0{_bce .RotateDeg (_dgf ._ccaca );
};if _dgf ._ecbea ==TextOverflowHidden {_bce .Add_re (0,-_dcdeb +_ecbg +1,_dgf ._ccf ,_dcdeb ).Add_W ().Add_n ();};_bce .Add_BT ();var _eebde []*_f .BasicLine ;for _caae ,_baef :=range _ddda {_gecg :=_cadf .X ;var _bfabc float64 ;if len (_baef )> 0{_bfabc =_baef [0].Style .FontSize ;
};_dcbf ,_ ,_eadb =_dgf .getLineMetrics (_caae );_cefcd =(_dcbf +_eadb );for _ ,_eaeda :=range _baef {_adaca :=&_eaeda .Style ;if _eaeda .Text !=""&&_adaca .FontSize > _bfabc {_bfabc =_adaca .FontSize ;};if _cefcd > _bfabc {_bfabc =_cefcd ;};};if _caae !=0{_bce .Add_TD (0,-_bfabc *_dgf ._beea );
_ceeeg -=_bfabc *_dgf ._beea ;};_aaegg :=_caae ==len (_ddda )-1;var (_bedd float64 ;_fggf float64 ;_fdadg float64 ;_edff uint ;);var _ddgg []float64 ;for _ ,_dagc :=range _baef {_fbgc :=&_dagc .Style ;if _fbgc .FontSize > _fggf {_fggf =_fbgc .FontSize ;
};if _cefcd > _fggf {_fggf =_cefcd ;};_gdbe ,_bdgg :=_fbgc .Font .GetRuneMetrics (' ');if !_bdgg {return _cadf ,nil ,_c .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");
};var _abea uint ;var _agbg float64 ;_ebgg :=len (_dagc .Text );for _aeae ,_edaf :=range _dagc .Text {if _edaf ==' '{_abea ++;continue ;};if _edaf =='\u000A'{continue ;};_efdga ,_gabb :=_fbgc .Font .GetRuneMetrics (_edaf );if !_gabb {_bg .Log .Debug ("\u0055\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006ee\u0020%\u0076\u0020\u0069\u006e\u0020\u0066\u006fn\u0074\u000a",_edaf );
return _cadf ,nil ,_c .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");};_agbg +=_fbgc .FontSize *_efdga .Wx *_fbgc .horizontalScale ();if _aeae !=_ebgg -1{_agbg +=_fbgc .CharSpacing *1000.0;
};};_ddgg =append (_ddgg ,_agbg );_bedd +=_agbg ;_fdadg +=float64 (_abea )*_gdbe .Wx *_fbgc .FontSize *_fbgc .horizontalScale ();_edff +=_abea ;};_fggf *=_dgf ._beea ;var _bafcef []_eg .PdfObject ;_afaa :=_dgf ._ccf *1000.0;if _dgf ._faf ==TextAlignmentJustify {if _edff > 0&&!_aaegg {_fdadg =(_afaa -_bedd )/float64 (_edff )/_efgg ;
};}else if _dgf ._faf ==TextAlignmentCenter {_egggf :=(_afaa -_bedd -_fdadg )/2;_efag :=_egggf /_efgg ;_bafcef =append (_bafcef ,_eg .MakeFloat (-_efag ));_gecg +=_egggf /1000.0;}else if _dgf ._faf ==TextAlignmentRight {_fbfbe :=(_afaa -_bedd -_fdadg );
_babde :=_fbfbe /_efgg ;_bafcef =append (_bafcef ,_eg .MakeFloat (-_babde ));_gecg +=_fbfbe /1000.0;};if len (_bafcef )> 0{_bce .Add_Tf (_edae ,_efgg ).Add_TL (_efgg *_dgf ._beea ).Add_TJ (_bafcef ...);};for _ecgd ,_dcdaa :=range _baef {_bafcb :=&_dcdaa .Style ;
_aceeaf :=_edae ;_bacaf :=_efgg ;_dbbg :=_bafcb .OutlineColor !=nil ;_gafdc :=_bafcb .HorizontalScaling !=DefaultHorizontalScaling ;_efaf :=_bafcb .OutlineSize !=1;if _efaf {_bce .Add_w (_bafcb .OutlineSize );};_afbcd :=_bafcb .RenderingMode !=TextRenderingModeFill ;
if _afbcd {_bce .Add_Tr (int64 (_bafcb .RenderingMode ));};_ccfc :=_bafcb .CharSpacing !=0;if _ccfc {_bce .Add_Tc (_bafcb .CharSpacing );};_ggfa :=_bafcb .TextRise !=0;if _ggfa {_bce .Add_Ts (_bafcb .TextRise );};if _dgf ._faf !=TextAlignmentJustify ||_aaegg {_fgab ,_adcbb :=_bafcb .Font .GetRuneMetrics (' ');
if !_adcbb {return _cadf ,nil ,_c .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};_aceeaf =_adgbc [_caae ][_ecgd ];_bacaf =_bafcb .FontSize ;
_fdadg =_fgab .Wx *_bafcb .horizontalScale ();};_fgdd :=_bafcb .Font .Encoder ();var _gacb []byte ;for _ ,_bfgb :=range _dcdaa .Text {if _bfgb =='\u000A'{continue ;};if _bfgb ==' '{if len (_gacb )> 0{if _dbbg {_bce .SetStrokingColor (_ecb (_bafcb .OutlineColor ));
};if _gafdc {_bce .Add_Tz (_bafcb .HorizontalScaling );};_bce .SetNonStrokingColor (_ecb (_bafcb .Color )).Add_Tf (_adgbc [_caae ][_ecgd ],_bafcb .FontSize ).Add_TJ ([]_eg .PdfObject {_eg .MakeStringFromBytes (_gacb )}...);_gacb =nil ;};if _gafdc {_bce .Add_Tz (DefaultHorizontalScaling );
};_bce .Add_Tf (_aceeaf ,_bacaf ).Add_TJ ([]_eg .PdfObject {_eg .MakeFloat (-_fdadg )}...);_ddgg [_ecgd ]+=_fdadg *_bacaf ;}else {if _ ,_gdgag :=_fgdd .RuneToCharcode (_bfgb );!_gdgag {_gcea =UnsupportedRuneError {Message :_gg .Sprintf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_bfgb ,_bfgb ),Rune :_bfgb };
_cadf ._fefc =append (_cadf ._fefc ,_gcea );_bg .Log .Debug (_gcea .Error ());if _cadf ._gfce <=0{continue ;};_bfgb =_cadf ._gfce ;};_gacb =append (_gacb ,_fgdd .Encode (string (_bfgb ))...);};};if len (_gacb )> 0{if _dbbg {_bce .SetStrokingColor (_ecb (_bafcb .OutlineColor ));
};if _gafdc {_bce .Add_Tz (_bafcb .HorizontalScaling );};_bce .SetNonStrokingColor (_ecb (_bafcb .Color )).Add_Tf (_adgbc [_caae ][_ecgd ],_bafcb .FontSize ).Add_TJ ([]_eg .PdfObject {_eg .MakeStringFromBytes (_gacb )}...);};_bcdd :=_ddgg [_ecgd ]/1000.0;
if _bafcb .Underline {_fgeac :=_bafcb .UnderlineStyle .Color ;if _fgeac ==nil {_fgeac =_dcdaa .Style .Color ;};_gebfc ,_gedc ,_aef :=_fgeac .ToRGB ();_abbfc :=_gecg -_cadf .X ;_gaddbe :=_ceeeg -_gbbe +_bafcb .TextRise -_bafcb .UnderlineStyle .Offset ;_eebde =append (_eebde ,&_f .BasicLine {X1 :_abbfc ,Y1 :_gaddbe ,X2 :_abbfc +_bcdd ,Y2 :_gaddbe ,LineWidth :_dcdaa .Style .UnderlineStyle .Thickness ,LineColor :_fd .NewPdfColorDeviceRGB (_gebfc ,_gedc ,_aef )});
};if _dcdaa ._cgaf !=nil {var _aaggb *_eg .PdfObjectArray ;if !_dcdaa ._gbafd {switch _abead :=_dcdaa ._cgaf .GetContext ().(type ){case *_fd .PdfAnnotationLink :_aaggb =_eg .MakeArray ();_abead .Rect =_aaggb ;_cbdae ,_cdfdg :=_abead .Dest .(*_eg .PdfObjectArray );
if _cdfdg &&_cbdae .Len ()==5{_aeaea ,_gedd :=_cbdae .Get (1).(*_eg .PdfObjectName );if _gedd &&_aeaea .String ()=="\u0058\u0059\u005a"{_fefd ,_gcbeg :=_eg .GetNumberAsFloat (_cbdae .Get (3));if _gcbeg ==nil {_cbdae .Set (3,_eg .MakeFloat (_cadf .PageHeight -_fefd ));
};};};};_dcdaa ._gbafd =true ;};if _aaggb !=nil {_efgcb :=_f .NewPoint (_gecg -_cadf .X ,_ceeeg +_bafcb .TextRise -_gbbe ).Rotate (_dgf ._ccaca );_efgcb .X +=_cadf .X ;_efgcb .Y +=_gbbe ;_debed ,_daec ,_ggcg ,_fdcf :=_gagfgf (_bcdd ,_fggf ,_dgf ._ccaca );
_efgcb .X +=_debed ;_efgcb .Y +=_daec ;_aaggb .Clear ();_aaggb .Append (_eg .MakeFloat (_efgcb .X ));_aaggb .Append (_eg .MakeFloat (_efgcb .Y ));_aaggb .Append (_eg .MakeFloat (_efgcb .X +_ggcg ));_aaggb .Append (_eg .MakeFloat (_efgcb .Y +_fdcf ));};
_abdf .AddAnnotation (_dcdaa ._cgaf );};_gecg +=_bcdd ;if _efaf {_bce .Add_w (1.0);};if _dbbg {_bce .Add_RG (0.0,0.0,0.0);};if _afbcd {_bce .Add_Tr (int64 (TextRenderingModeFill ));};if _ccfc {_bce .Add_Tc (0);};if _ggfa {_bce .Add_Ts (0);};if _gafdc {_bce .Add_Tz (DefaultHorizontalScaling );
};};};_bce .Add_ET ();for _ ,_fbfee :=range _eebde {_bce .SetStrokingColor (_fbfee .LineColor ).Add_w (_fbfee .LineWidth ).Add_m (_fbfee .X1 ,_fbfee .Y1 ).Add_l (_fbfee .X2 ,_fbfee .Y2 ).Add_s ();};_bce .Add_Q ();_gegce :=_bce .Operations ();_gegce .WrapIfNeeded ();
_abdf .addContents (_gegce );if _ebffa {_bbdc :=_dcdeb ;_cadf .Y +=_bbdc ;_cadf .Height -=_bbdc ;if _cadf .Inline {_cadf .X +=_dgf .Width ()+_dgf ._ddaff .Right ;};};return _cadf ,_cfad ,nil ;};

// MoveDown moves the drawing context down by relative displacement dy (negative goes up).
func (_bdag *Creator )MoveDown (dy float64 ){_bdag ._acda .Y +=dy };

// Length calculates and returns the length of the line.
func (_eabac *Line )Length ()float64 {return _da .Sqrt (_da .Pow (_eabac ._fdba -_eabac ._gdee ,2.0)+_da .Pow (_eabac ._gfcfb -_eabac ._dbcb ,2.0));};

// HorizontalAlignment represents the horizontal alignment of components
// within a page.
type HorizontalAlignment int ;

// Append adds a new text chunk to the paragraph.
func (_cccb *StyledParagraph )Append (text string )*TextChunk {_gafggc :=NewTextChunk (text ,_cccb ._defe );return _cccb .appendChunk (_gafggc );};

// Scale block by specified factors in the x and y directions.
func (_ec *Block )Scale (sx ,sy float64 ){_cda :=_af .NewContentCreator ().Scale (sx ,sy ).Operations ();*_ec ._ba =append (*_cda ,*_ec ._ba ...);_ec ._ba .WrapIfNeeded ();_ec ._bd *=sx ;_ec ._ef *=sy ;};

// GetHeading returns the chapter heading paragraph. Used to give access to address style: font, sizing etc.
func (_gada *Chapter )GetHeading ()*Paragraph {return _gada ._babb };func (_adbe *Paragraph )getTextLineWidth (_fcfc string )float64 {var _bagff float64 ;for _ ,_baad :=range _fcfc {if _baad =='\u000A'{continue ;};_faaf ,_beadcg :=_adbe ._geef .GetRuneMetrics (_baad );
if !_beadcg {_bg .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_baad ,_baad );
return -1;};_bagff +=_adbe ._bec *_faaf .Wx ;};return _bagff ;};

// Paragraph represents text drawn with a specified font and can wrap across lines and pages.
// By default it occupies the available width in the drawing context.
type Paragraph struct{_eefd string ;_geef *_fd .PdfFont ;_bec float64 ;_eabag float64 ;_efeg Color ;_adfg TextAlignment ;_bbde bool ;_abcd float64 ;_adacf int ;_dcbb bool ;_bdeb float64 ;_gadg Margins ;_gfbe Positioning ;_egbdcc float64 ;_babbe float64 ;
_cga ,_bccdf float64 ;_gacac []string ;};

// SetIndent sets the cell's left indent.
func (_gbddc *TableCell )SetIndent (indent float64 ){_gbddc ._bgbg =indent };

// SetStyleBottom sets border style for bottom side.
func (_gabf *border )SetStyleBottom (style CellBorderStyle ){_gabf ._agcc =style };

// Polyline represents a slice of points that are connected as straight lines.
// Implements the Drawable interface and can be rendered using the Creator.
type Polyline struct{_eadfd *_f .Polyline ;_cfff float64 ;};

// NewTextStyle creates a new text style object which can be used to style
// chunks of text.
// Default attributes:
// Font: Helvetica
// Font size: 10
// Encoding: WinAnsiEncoding
// Text color: black
func (_cace *Creator )NewTextStyle ()TextStyle {return _eabc (_cace ._daaf )};type containerDrawable interface{Drawable ;

// ContainerComponent checks if the component is allowed to be added into provided 'container' and returns
// preprocessed copy of itself. If the component is not changed it is allowed to return itself in a callback way.
// If the component is not compatible with provided container this method should return an error.
ContainerComponent (_dgeg Drawable )(Drawable ,error );};

// SetAngle sets the rotation angle in degrees.
func (_gcc *Block )SetAngle (angleDeg float64 ){_gcc ._dg =angleDeg };

// SetTextVerticalAlignment sets the vertical alignment of the text within the
// bounds of the styled paragraph.
func (_gagee *StyledParagraph )SetTextVerticalAlignment (align TextVerticalAlignment ){_gagee ._ccgf =align ;};

// CreateTableOfContents sets a function to generate table of contents.
func (_bgef *Creator )CreateTableOfContents (genTOCFunc func (_cbce *TOC )error ){_bgef ._cgef =genTOCFunc ;};

// SetForms adds an Acroform to a PDF file.  Sets the specified form for writing.
func (_fdgae *Creator )SetForms (form *_fd .PdfAcroForm )error {_fdgae ._fgef =form ;return nil };

// WriteToFile writes the Creator output to file specified by path.
func (_dbfffg *Creator )WriteToFile (outputPath string )error {_dfff ,_gaf :=_a .Create (outputPath );if _gaf !=nil {return _gaf ;};defer _dfff .Close ();return _dbfffg .Write (_dfff );};func (_gadfe *pageTransformations )transformBlock (_adfd *Block ){if _gadfe ._gbfaf !=nil {_adfd .transform (*_gadfe ._gbfaf );
};};

// NewRectangle creates a new Rectangle with default parameters
// with left corner at (x,y) and width, height as specified.
func (_gbfaa *Creator )NewRectangle (x ,y ,width ,height float64 )*Rectangle {return _acgg (x ,y ,width ,height );};

// Width returns the cell's width based on the input draw context.
func (_adeb *TableCell )Width (ctx DrawContext )float64 {_geca :=float64 (0.0);for _cfbad :=0;_cfbad < _adeb ._fafc ;_cfbad ++{_geca +=_adeb ._bgabd ._geefa [_adeb ._gbgc +_cfbad -1];};_ebbgd :=ctx .Width *_geca ;return _ebbgd ;};func (_ggagd *Paragraph )getTextWidth ()float64 {_edebf :=0.0;
for _ ,_aaedd :=range _ggagd ._eefd {if _aaedd =='\u000A'{continue ;};_ebde ,_gefg :=_ggagd ._geef .GetRuneMetrics (_aaedd );if !_gefg {_bg .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_aaedd ,_aaedd );
return -1;};_edebf +=_ggagd ._bec *_ebde .Wx ;};return _edebf ;};

// Chart represents a chart drawable.
// It is used to render unichart chart components using a creator instance.
type Chart struct{_gebc _gc .ChartRenderable ;_ebe Positioning ;_eccaa float64 ;_eed float64 ;_gecd Margins ;};const (CellVerticalAlignmentTop CellVerticalAlignment =iota ;CellVerticalAlignmentMiddle ;CellVerticalAlignmentBottom ;);

// FooterFunctionArgs holds the input arguments to a footer drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FooterFunctionArgs struct{PageNum int ;TotalPages int ;};func (_gbad *Table )clone ()*Table {_beabe :=*_gbad ;_beabe ._ecgdb =make ([]float64 ,len (_gbad ._ecgdb ));copy (_beabe ._ecgdb ,_gbad ._ecgdb );_beabe ._geefa =make ([]float64 ,len (_gbad ._geefa ));
copy (_beabe ._geefa ,_gbad ._geefa );_beabe ._abgf =make ([]*TableCell ,0,len (_gbad ._abgf ));for _ ,_ffaba :=range _gbad ._abgf {_adgef :=*_ffaba ;_adgef ._bgabd =&_beabe ;_beabe ._abgf =append (_beabe ._abgf ,&_adgef );};return &_beabe ;};

// Sections returns the custom content sections of the invoice as
// title-content pairs.
func (_ceae *Invoice )Sections ()[][2]string {return _ceae ._eafgd };

// SetFontSize sets the font size in document units (points).
func (_cfcc *Paragraph )SetFontSize (fontSize float64 ){_cfcc ._bec =fontSize };

// MoveX moves the drawing context to absolute position x.
func (_geaa *Creator )MoveX (x float64 ){_geaa ._acda .X =x };

// SetHeaderRows turns the selected table rows into headers that are repeated
// for every page the table spans. startRow and endRow are inclusive.
func (_ddfg *Table )SetHeaderRows (startRow ,endRow int )error {if startRow <=0{return _c .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020r\u006f\u0077\u0020\u006d\u0075\u0073t\u0020\u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");
};if endRow <=0{return _c .New ("\u0068\u0065a\u0064\u0065\u0072\u0020e\u006e\u0064 \u0072\u006f\u0077\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");};if startRow > endRow {return _c .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020\u0072\u006f\u0077\u0020\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061\u006e\u0020\u006f\u0072\u0020\u0065\u0071\u0075\u0061\u006c\u0020\u0074\u006f\u0020\u0074\u0068\u0065 \u0065\u006e\u0064\u0020\u0072o\u0077");
};_ddfg ._gfbff =true ;_ddfg ._egcg =startRow ;_ddfg ._ffefb =endRow ;return nil ;};

// Style returns the style of the line.
func (_fgd *Line )Style ()_f .LineStyle {return _fgd ._gbafg };

// NewPageBreak create a new page break.
func (_baf *Creator )NewPageBreak ()*PageBreak {return _ebaa ()};func (_cb *Block )drawToPage (_fdda *_fd .PdfPage )error {_fa :=&_af .ContentStreamOperations {};if _fdda .Resources ==nil {_fdda .Resources =_fd .NewPdfPageResources ();};_fbb :=_fab (_fa ,_fdda .Resources ,_cb ._ba ,_cb ._dab );
if _fbb !=nil {return _fbb ;};if _fbb =_cff (_cb ._dab ,_fdda .Resources );_fbb !=nil {return _fbb ;};if _fbb =_fdda .AppendContentBytes (_fa .Bytes (),true );_fbb !=nil {return _fbb ;};for _ ,_edd :=range _cb ._ag {_fdda .AddAnnotation (_edd );};return nil ;
};

// TextOverflow determines the behavior of paragraph text which does
// not fit in the available space.
type TextOverflow int ;

// SetAddressHeadingStyle sets the style properties used to render the
// heading of the invoice address sections.
func (_cffef *Invoice )SetAddressHeadingStyle (style TextStyle ){_cffef ._ebca =style };type pageTransformations struct{_gbfaf *_fb .Matrix ;_ddd bool ;_efdc bool ;};func (_gbca *pageTransformations )applyFlip (_fdab *_fd .PdfPage )error {_gead ,_cbea :=_gbca ._ddd ,_gbca ._efdc ;
if !_gead &&!_cbea {return nil ;};if _fdab ==nil {return _c .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};_cbcd ,_ggdbb :=_fdab .GetMediaBox ();if _ggdbb !=nil {return _ggdbb ;};_gbbc ,_dgd :=_cbcd .Width (),_cbcd .Height ();
_dcad ,_ggdbb :=_fdab .GetRotate ();if _ggdbb !=nil {_bg .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0025\u0073\u0020\u002d\u0020\u0069\u0067\u006e\u006f\u0072\u0069\u006e\u0067\u0020\u0061\u006e\u0064\u0020\u0061\u0073\u0073\u0075\u006d\u0069\u006e\u0067\u0020\u006e\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u000a",_ggdbb .Error ());
};if _abbf :=_dcad %360!=0&&_dcad %90==0;_abbf {if _eae :=(360+_dcad %360)%360;_eae ==90||_eae ==270{_gead ,_cbea =_cbea ,_gead ;};};_edcd ,_fgc :=1.0,0.0;if _gead {_edcd ,_fgc =-1.0,-_gbbc ;};_gdda ,_gcgc :=1.0,0.0;if _cbea {_gdda ,_gcgc =-1.0,-_dgd ;
};_cffe :=_af .NewContentCreator ().Scale (_edcd ,_gdda ).Translate (_fgc ,_gcgc );_cdfd ,_ggdbb :=_eg .MakeStream (_cffe .Bytes (),_eg .NewFlateEncoder ());if _ggdbb !=nil {return _ggdbb ;};_acbd :=_eg .MakeArray (_cdfd );_acbd .Append (_fdab .GetContentStreamObjs ()...);
_fdab .Contents =_acbd ;return nil ;};

// NoteStyle returns the style properties used to render the content of the
// invoice note sections.
func (_bbcg *Invoice )NoteStyle ()TextStyle {return _bbcg ._bad };

// AddSubtable copies the cells of the subtable in the table, starting with the
// specified position. The table row and column indices are 1-based, which
// makes the position of the first cell of the first row of the table 1,1.
// The table is automatically extended if the subtable exceeds its columns.
// This can happen when the subtable has more columns than the table or when
// one or more columns of the subtable starting from the specified position
// exceed the last column of the table.
func (_deee *Table )AddSubtable (row ,col int ,subtable *Table ){for _ ,_ceeb :=range subtable ._abgf {_abdff :=&TableCell {};*_abdff =*_ceeb ;_abdff ._bgabd =_deee ;_abdff ._gbgc +=col -1;if _adace :=_deee ._ecdg -(_abdff ._gbgc -1);_adace < _abdff ._fafc {_deee ._ecdg +=_abdff ._fafc -_adace ;
_deee .resetColumnWidths ();_bg .Log .Debug ("\u0054a\u0062l\u0065\u003a\u0020\u0073\u0075\u0062\u0074\u0061\u0062\u006c\u0065 \u0065\u0078\u0063\u0065e\u0064\u0073\u0020\u0064\u0065s\u0074\u0069\u006e\u0061\u0074\u0069\u006f\u006e\u0020\u0074\u0061\u0062\u006c\u0065\u002e\u0020\u0045\u0078\u0070\u0061\u006e\u0064\u0069\u006e\u0067\u0020\u0074\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0025\u0064\u0020\u0063\u006fl\u0075\u006d\u006e\u0073\u002e",_deee ._ecdg );
};_abdff ._egdb +=row -1;_dfec :=subtable ._ecgdb [_ceeb ._egdb -1];if _abdff ._egdb > _deee ._ecea {for _abdff ._egdb > _deee ._ecea {_deee ._ecea ++;_deee ._ecgdb =append (_deee ._ecgdb ,_deee ._gddd );};_deee ._ecgdb [_abdff ._egdb -1]=_dfec ;}else {_deee ._ecgdb [_abdff ._egdb -1]=_da .Max (_deee ._ecgdb [_abdff ._egdb -1],_dfec );
};_deee ._abgf =append (_deee ._abgf ,_abdff );};_dd .Slice (_deee ._abgf ,func (_agfae ,_fceeg int )bool {_dfbb :=_deee ._abgf [_agfae ]._egdb ;_cebe :=_deee ._abgf [_fceeg ]._egdb ;if _dfbb < _cebe {return true ;};if _dfbb > _cebe {return false ;};return _deee ._abgf [_agfae ]._gbgc < _deee ._abgf [_fceeg ]._gbgc ;
});};func _cfdbc (_bbb []_f .CubicBezierCurve )*PolyBezierCurve {return &PolyBezierCurve {_aecc :&_f .PolyBezierCurve {Curves :_bbb ,BorderColor :_fd .NewPdfColorDeviceRGB (0,0,0),BorderWidth :1.0},_aagaa :1.0,_aebea :1.0};};

// Heading returns the heading component of the table of contents.
func (_gege *TOC )Heading ()*StyledParagraph {return _gege ._cffgc };

// NewBlockFromPage creates a Block from a PDF Page.  Useful for loading template pages as blocks
// from a PDF document and additional content with the creator.
func NewBlockFromPage (page *_fd .PdfPage )(*Block ,error ){_cdd :=&Block {};_cdf ,_cg :=page .GetAllContentStreams ();if _cg !=nil {return nil ,_cg ;};_ace :=_af .NewContentStreamParser (_cdf );_ab ,_cg :=_ace .Parse ();if _cg !=nil {return nil ,_cg ;
};_ab .WrapIfNeeded ();_cdd ._ba =_ab ;if page .Resources !=nil {_cdd ._dab =page .Resources ;}else {_cdd ._dab =_fd .NewPdfPageResources ();};_ce ,_cg :=page .GetMediaBox ();if _cg !=nil {return nil ,_cg ;};if _ce .Llx !=0||_ce .Lly !=0{_cdd .translate (-_ce .Llx ,_ce .Lly );
};_cdd ._bd =_ce .Urx -_ce .Llx ;_cdd ._ef =_ce .Ury -_ce .Lly ;if page .Rotate !=nil {_cdd ._dg =-float64 (*page .Rotate );};return _cdd ,nil ;};

// SetFillColor sets the fill color.
func (_fcac *PolyBezierCurve )SetFillColor (color Color ){_fcac ._aecc .FillColor =_ecb (color )};

// SetLineNumberStyle sets the style for the numbers part of all new lines
// of the table of contents.
func (_ggee *TOC )SetLineNumberStyle (style TextStyle ){_ggee ._acecb =style };func (_dbgg *TOCLine )getLineLink ()*_fd .PdfAnnotation {if _dbgg ._geba <=0{return nil ;};return _cggcf (_dbgg ._geba -1,_dbgg ._aacdc ,_dbgg ._cddff ,0);};

// List represents a list of items.
// The representation of a list item is as follows:
//       [marker] [content]
// e.g.:        • This is the content of the item.
// The supported components to add content to list items are:
// - Paragraph
// - StyledParagraph
// - List
type List struct{_eadc []*listItem ;_edgd Margins ;_ebfga TextChunk ;_ffdc float64 ;_cdcd bool ;_aebe Positioning ;_cffbd TextStyle ;};

// Finalize renders all blocks to the creator pages. In addition, it takes care
// of adding headers and footers, as well as generating the front page,
// table of contents and outlines.
// Finalize is automatically called before writing the document out. Calling the
// method manually can be useful when adding external pages to the creator,
// using the AddPage method, as it renders all creator blocks to the added
// pages, without having to write the document out.
// NOTE: TOC and outlines are generated only if the AddTOC and AddOutlines
// fields of the creator are set to true (enabled by default). Furthermore, TOCs
// and outlines without content are skipped. TOC and outline content is
// added automatically when using the chapter component. TOCs and outlines can
// also be set externally, using the SetTOC and SetOutlineTree methods.
// Finalize should only be called once, after all draw calls have taken place,
// as it will return immediately if the creator instance has been finalized.
func (_cfd *Creator )Finalize ()error {if _cfd ._egbe {return nil ;};_beg :=len (_cfd ._bfba );_acee :=0;if _cfd ._gaeg !=nil {_bdba :=*_cfd ;_cfd ._bfba =nil ;_cfd ._gdd =nil ;_cfd .initContext ();_fbfac :=FrontpageFunctionArgs {PageNum :1,TotalPages :_beg };
_cfd ._gaeg (_fbfac );_acee +=len (_cfd ._bfba );_cfd ._bfba =_bdba ._bfba ;_cfd ._gdd =_bdba ._gdd ;};if _cfd .AddTOC {_cfd .initContext ();_cfd ._acda .Page =_acee +1;if _cfd ._cgef !=nil {if _bffb :=_cfd ._cgef (_cfd ._gcd );_bffb !=nil {return _bffb ;
};};_cacd ,_ ,_dbdg :=_cfd ._gcd .GeneratePageBlocks (_cfd ._acda );if _dbdg !=nil {_bg .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073: \u0025\u0076",_dbdg );
return _dbdg ;};_acee +=len (_cacd );_cfca :=_cfd ._gcd .Lines ();for _ ,_aab :=range _cfca {_bdfaf ,_fdgec :=_g .Atoi (_aab .Page .Text );if _fdgec !=nil {continue ;};_aab .Page .Text =_g .Itoa (_bdfaf +_acee );};};_dfbf :=false ;var _begf []*_fd .PdfPage ;
if _cfd ._gaeg !=nil {_adg :=*_cfd ;_cfd ._bfba =nil ;_cfd ._gdd =nil ;_cce :=FrontpageFunctionArgs {PageNum :1,TotalPages :_beg };_cfd ._gaeg (_cce );_beg +=len (_cfd ._bfba );_begf =_cfd ._bfba ;_cfd ._bfba =append (_cfd ._bfba ,_adg ._bfba ...);_cfd ._gdd =_adg ._gdd ;
_dfbf =true ;};var _efg []*_fd .PdfPage ;if _cfd .AddTOC {_cfd .initContext ();if _cfd ._cgef !=nil {if _gabd :=_cfd ._cgef (_cfd ._gcd );_gabd !=nil {_bg .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074i\u006e\u0067\u0020\u0054\u004f\u0043\u003a\u0020\u0025\u0076",_gabd );
return _gabd ;};};_fba :=_cfd ._gcd .Lines ();for _ ,_fcde :=range _fba {_fcde ._geba +=int64 (_acee );};_ecg ,_ ,_ :=_cfd ._gcd .GeneratePageBlocks (_cfd ._acda );for _ ,_bdcb :=range _ecg {_bdcb .SetPos (0,0);_beg ++;_cdcf :=_cfd .newPage ();_efg =append (_efg ,_cdcf );
_cfd .setActivePage (_cdcf );_cfd .Draw (_bdcb );};if _dfbf {_bfag :=_begf ;_dged :=_cfd ._bfba [len (_begf ):];_cfd ._bfba =append ([]*_fd .PdfPage {},_bfag ...);_cfd ._bfba =append (_cfd ._bfba ,_efg ...);_cfd ._bfba =append (_cfd ._bfba ,_dged ...);
}else {_cfd ._bfba =append (_efg ,_cfd ._bfba ...);};};if _cfd ._baec !=nil &&_cfd .AddOutlines {var _cbfc func (_cbd *_fd .OutlineItem );_cbfc =func (_cefc *_fd .OutlineItem ){_cefc .Dest .Page +=int64 (_acee );if _gdaa :=int (_cefc .Dest .Page );_gdaa >=0&&_gdaa < len (_cfd ._bfba ){_cefc .Dest .PageObj =_cfd ._bfba [_gdaa ].GetPageAsIndirectObject ();
}else {_bg .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_gdaa );
};_cefc .Dest .Y =_cfd ._degf -_cefc .Dest .Y ;_daca :=_cefc .Items ();for _ ,_bda :=range _daca {_cbfc (_bda );};};_eefb :=_cfd ._baec .Items ();for _ ,_dbc :=range _eefb {_cbfc (_dbc );};if _cfd .AddTOC {var _aagb int ;if _dfbf {_aagb =len (_begf );};
_bggd :=_fd .NewOutlineDest (int64 (_aagb ),0,_cfd ._degf );if _aagb >=0&&_aagb < len (_cfd ._bfba ){_bggd .PageObj =_cfd ._bfba [_aagb ].GetPageAsIndirectObject ();}else {_bg .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_aagb );
};_cfd ._baec .Insert (0,_fd .NewOutlineItem ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073",_bggd ));};};for _cbge ,_bbfc :=range _cfd ._bfba {_cfd .setActivePage (_bbfc );if _cfd ._aded !=nil {_dgaa ,_cgeff ,_afg :=_bbfc .Size ();
if _afg !=nil {return _afg ;};_gegd :=PageFinalizeFunctionArgs {PageNum :_cbge +1,PageWidth :_dgaa ,PageHeight :_cgeff ,TOCPages :len (_efg ),TotalPages :_beg };if _aede :=_cfd ._aded (_gegd );_aede !=nil {_bg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0070\u0061\u0067\u0065\u0020\u0066\u0069\u006e\u0061\u006c\u0069\u007a\u0065 \u0063\u0061\u006c\u006c\u0062\u0061\u0063k\u003a\u0020\u0025\u0076",_aede );
return _aede ;};};if _cfd ._agg !=nil {_abee :=NewBlock (_cfd ._bfg ,_cfd ._bdbc .Top );_eeeg :=HeaderFunctionArgs {PageNum :_cbge +1,TotalPages :_beg };_cfd ._agg (_abee ,_eeeg );_abee .SetPos (0,0);if _geab :=_cfd .Draw (_abee );_geab !=nil {_bg .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0068e\u0061\u0064\u0065\u0072\u003a\u0020\u0025v",_geab );
return _geab ;};};if _cfd ._gca !=nil {_gdb :=NewBlock (_cfd ._bfg ,_cfd ._bdbc .Bottom );_gddg :=FooterFunctionArgs {PageNum :_cbge +1,TotalPages :_beg };_cfd ._gca (_gdb ,_gddg );_gdb .SetPos (0,_cfd ._degf -_gdb ._ef );if _aaab :=_cfd .Draw (_gdb );
_aaab !=nil {_bg .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0066o\u006f\u0074\u0065\u0072\u003a\u0020\u0025v",_aaab );return _aaab ;};};_gbdf ,_afda :=_cfd ._abfd [_bbfc ];if _fbde ,_dded :=_cfd ._bffe [_bbfc ];
_dded {if _afda {_gbdf .transformBlock (_fbde );};if _abeg :=_fbde .drawToPage (_bbfc );_abeg !=nil {_bg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069\u006e\u0067\u0020\u0070\u0061\u0067\u0065\u0020%\u0064\u0020\u0062\u006c\u006f\u0063\u006bs\u003a\u0020\u0025\u0076",_cbge +1,_abeg );
return _abeg ;};};if _afda {if _ebad :=_gbdf .transformPage (_bbfc );_ebad !=nil {_bg .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020c\u006f\u0075\u006c\u0064\u0020\u006eo\u0074\u0020\u0074\u0072\u0061\u006e\u0073f\u006f\u0072\u006d\u0020\u0070\u0061\u0067\u0065\u003a\u0020%\u0076",_ebad );
return _ebad ;};};};_cfd ._egbe =true ;return nil ;};

// Inline returns whether the inline mode of the division is active.
func (_afgd *Division )Inline ()bool {return _afgd ._acea };

// GeneratePageBlocks draws the block contents on a template Page block.
// Implements the Drawable interface.
func (_cgf *Block )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_ge :=_af .NewContentCreator ();_ggd ,_ae :=_cgf .Width (),_cgf .Height ();if _cgf ._ggb .IsRelative (){_ge .Translate (ctx .X ,ctx .PageHeight -ctx .Y -_ae );}else {_ge .Translate (_cgf ._fg ,ctx .PageHeight -_cgf ._aca -_ae );
};_eb :=_ae ;if _cgf ._dg !=0{_ge .Translate (_ggd /2,_ae /2);_ge .RotateDeg (_cgf ._dg );_ge .Translate (-_ggd /2,-_ae /2);_ ,_eb =_cgf .RotatedSize ();};if _cgf ._ggb .IsRelative (){ctx .Y +=_eb ;};_fec :=_cgf .duplicate ();_cge :=append (*_ge .Operations (),*_fec ._ba ...);
_cge .WrapIfNeeded ();_fec ._ba =&_cge ;return []*Block {_fec },ctx ,nil ;};func (_affaa *StyledParagraph )getMaxLineWidth ()float64 {if _affaa ._cdeae ==nil ||len (_affaa ._cdeae )==0{_affaa .wrapText ();};var _dfba float64 ;for _ ,_cdddd :=range _affaa ._cdeae {_debe :=_affaa .getTextLineWidth (_cdddd );
if _debe > _dfba {_dfba =_debe ;};};return _dfba ;};

// CurCol returns the currently active cell's column number.
func (_acdcf *Table )CurCol ()int {_dfbfg :=(_acdcf ._ddbf -1)%(_acdcf ._ecdg )+1;return _dfbfg };

// GetCoords returns the coordinates of the Ellipse's center (xc,yc).
func (_fed *Ellipse )GetCoords ()(float64 ,float64 ){return _fed ._dgedf ,_fed ._ggffb };

// SetTerms sets the terms and conditions section of the invoice.
func (_agde *Invoice )SetTerms (title ,content string ){_agde ._eceg =[2]string {title ,content }};func (_gef *Block )addContentsByString (_afe string )error {_aa :=_af .NewContentStreamParser (_afe );_fbf ,_dcd :=_aa .Parse ();if _dcd !=nil {return _dcd ;
};_gef ._ba .WrapIfNeeded ();_fbf .WrapIfNeeded ();*_gef ._ba =append (*_gef ._ba ,*_fbf ...);return nil ;};

// Width returns the width of the line.
// NOTE: Depending on the fit mode the line is set to use, its width may be
// calculated at runtime (e.g. when using FitModeFillWidth).
func (_dfgg *Line )Width ()float64 {return _da .Abs (_dfgg ._fdba -_dfgg ._gdee )};

// TOC represents a table of contents component.
// It consists of a paragraph heading and a collection of
// table of contents lines.
// The representation of a table of contents line is as follows:
//       [number] [title]      [separator] [page]
// e.g.: Chapter1 Introduction ........... 1
type TOC struct{_cffgc *StyledParagraph ;_bgbaf []*TOCLine ;_acecb TextStyle ;_gbdae TextStyle ;_edge TextStyle ;_ebdec TextStyle ;_eadg string ;_aafab float64 ;_ceeac Margins ;_eebdg Positioning ;_fdacc TextStyle ;_debd bool ;};

// Height returns the height of the list.
func (_eccdg *List )Height ()float64 {var _eadf float64 ;for _ ,_gccd :=range _eccdg ._eadc {_eadf +=_gccd ._bfdd .Height ();};return _eadf ;};

// DrawContext defines the drawing context. The DrawContext is continuously used and updated when
// drawing the page contents in relative mode.  Keeps track of current X, Y position, available
// height as well as other page parameters such as margins and dimensions.
type DrawContext struct{

// Current page number.
Page int ;

// Current position.  In a relative positioning mode, a drawable will be placed at these coordinates.
X ,Y float64 ;

// Context dimensions.  Available width and height (on current page).
Width ,Height float64 ;

// Page Margins.
Margins Margins ;

// Absolute Page size, widths and height.
PageWidth float64 ;PageHeight float64 ;

// Controls whether the components are stacked horizontally
Inline bool ;_gfce rune ;_fefc []error ;};

// CellHorizontalAlignment defines the table cell's horizontal alignment.
type CellHorizontalAlignment int ;

// SetBorderRadius sets the radius of the rectangle corners.
func (_cbaf *Rectangle )SetBorderRadius (topLeft ,topRight ,bottomLeft ,bottomRight float64 ){_cbaf ._dffeg =topLeft ;_cbaf ._acceb =topRight ;_cbaf ._gbbg =bottomLeft ;_cbaf ._afba =bottomRight ;};

// BuyerAddress returns the buyer address used in the invoice template.
func (_cgge *Invoice )BuyerAddress ()*InvoiceAddress {return _cgge ._ebcb };func _eeece (_ffag _be .Image )(*Image ,error ){_fgae ,_ggca :=_fd .ImageHandling .NewImageFromGoImage (_ffag );if _ggca !=nil {return nil ,_ggca ;};return _ebcdc (_fgae );};func (_gacg *Division )drawBackground (_cdec []*Block ,_cagc ,_ecag DrawContext ,_fdec bool )([]*Block ,error ){_cbee :=len (_cdec );
if _cbee ==0||_gacg ._fefg ==nil {return _cdec ,nil ;};_feaa :=make ([]*Block ,0,len (_cdec ));for _bfdg ,_aea :=range _cdec {var (_adba =_gacg ._fefg .BorderRadiusTopLeft ;_edde =_gacg ._fefg .BorderRadiusTopRight ;_decb =_gacg ._fefg .BorderRadiusBottomLeft ;
_ddca =_gacg ._fefg .BorderRadiusBottomRight ;);_bbe :=_cagc ;_bbe .Page +=_bfdg ;if _bfdg ==0{if _fdec {_feaa =append (_feaa ,_aea );continue ;};if _cbee ==1{_bbe .Height =_ecag .Y -_cagc .Y ;};}else {_bbe .X =_bbe .Margins .Left +_gacg ._cfe .Left ;_bbe .Y =_bbe .Margins .Top ;
_bbe .Width =_bbe .PageWidth -_bbe .Margins .Left -_bbe .Margins .Right -_gacg ._cfe .Left -_gacg ._cfe .Right ;if _bfdg ==_cbee -1{_bbe .Height =_ecag .Y -_bbe .Margins .Top -_gacg ._cfe .Top ;}else {_bbe .Height =_bbe .PageHeight -_bbe .Margins .Top -_bbe .Margins .Bottom ;
};if !_fdec {_adba =0;_edde =0;};};if _cbee > 1&&_bfdg !=_cbee -1{_decb =0;_ddca =0;};_feae :=_acgg (_bbe .X ,_bbe .Y ,_bbe .Width ,_bbe .Height );_feae .SetFillColor (_gacg ._fefg .FillColor );_feae .SetBorderColor (_gacg ._fefg .BorderColor );_feae .SetBorderWidth (_gacg ._fefg .BorderSize );
_feae .SetBorderRadius (_adba ,_edde ,_decb ,_ddca );_edbb ,_ ,_ebcdd :=_feae .GeneratePageBlocks (_bbe );if _ebcdd !=nil {return nil ,_ebcdd ;};if len (_edbb )==0{continue ;};_bdad :=_edbb [0];if _ebcdd =_bdad .mergeBlocks (_aea );_ebcdd !=nil {return nil ,_ebcdd ;
};_feaa =append (_feaa ,_bdad );};return _feaa ,nil ;};func (_agec *Chapter )headingNumber ()string {var _gagf string ;if _agec ._cffb {if _agec ._eeb !=0{_gagf =_g .Itoa (_agec ._eeb )+"\u002e";};if _agec ._cfc !=nil {_faac :=_agec ._cfc .headingNumber ();
if _faac !=""{_gagf =_faac +_gagf ;};};};return _gagf ;};

// SetText replaces all the text of the paragraph with the specified one.
func (_gfgbf *StyledParagraph )SetText (text string )*TextChunk {_gfgbf .Reset ();return _gfgbf .Append (text );};

// SetLineLevelOffset sets the amount of space an indentation level occupies
// for all new lines of the table of contents.
func (_caeec *TOC )SetLineLevelOffset (levelOffset float64 ){_caeec ._aafab =levelOffset };

// SetTextOverflow controls the behavior of paragraph text which
// does not fit in the available space.
func (_begg *StyledParagraph )SetTextOverflow (textOverflow TextOverflow ){_begg ._ecbea =textOverflow };

// SetOpacity sets opacity for Image.
func (_gfcbe *Image )SetOpacity (opacity float64 ){_gfcbe ._fgg =opacity };func (_acg *Creator )setActivePage (_dfgb *_fd .PdfPage ){_acg ._gdd =_dfgb };

// NoteHeadingStyle returns the style properties used to render the heading of
// the invoice note sections.
func (_gefa *Invoice )NoteHeadingStyle ()TextStyle {return _gefa ._cgff };

// SetColor sets the line color. Use ColorRGBFromHex, ColorRGBFrom8bit or
// ColorRGBFromArithmetic to create the color object.
func (_dgga *Line )SetColor (color Color ){_dgga ._dbge =color };

// SetColor sets the color of the Paragraph text.
//
// Example:
// 1.   p := NewParagraph("Red paragraph")
//      // Set to red color with a hex code:
//      p.SetColor(creator.ColorRGBFromHex("#ff0000"))
//
// 2. Make Paragraph green with 8-bit rgb values (0-255 each component)
//      p.SetColor(creator.ColorRGBFrom8bit(0, 255, 0)
//
// 3. Make Paragraph blue with arithmetic (0-1) rgb components.
//      p.SetColor(creator.ColorRGBFromArithmetic(0, 0, 1.0)
//
func (_agbde *Paragraph )SetColor (col Color ){_agbde ._efeg =col };

// SetHorizontalAlignment sets the horizontal alignment of the image.
func (_eccaf *Image )SetHorizontalAlignment (alignment HorizontalAlignment ){_eccaf ._cage =alignment };

// SetBorderColor sets the cell's border color.
func (_gbgbg *TableCell )SetBorderColor (col Color ){_gbgbg ._beac =col ;_gbgbg ._fceg =col ;_gbgbg ._aece =col ;_gbgbg ._babc =col ;};

// SetHorizontalAlignment sets the cell's horizontal alignment of content.
// Can be one of:
// - CellHorizontalAlignmentLeft
// - CellHorizontalAlignmentCenter
// - CellHorizontalAlignmentRight
func (_dedgc *TableCell )SetHorizontalAlignment (halign CellHorizontalAlignment ){_dedgc ._egde =halign ;};

// CellVerticalAlignment defines the table cell's vertical alignment.
type CellVerticalAlignment int ;

// NewInvoice returns an instance of an empty invoice.
func (_cgdb *Creator )NewInvoice ()*Invoice {_afad :=_cgdb .NewTextStyle ();_afad .Font =_cgdb ._egce ;return _efgc (_cgdb .NewTextStyle (),_afad );};

// SetFont sets the Paragraph's font.
func (_acbde *Paragraph )SetFont (font *_fd .PdfFont ){_acbde ._geef =font };

// SetHeight sets the Image's document height to specified h.
func (_dceb *Image )SetHeight (h float64 ){_dceb ._dbffg =h };

// GetMargins returns the left, right, top, bottom Margins.
func (_gfdb *Table )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _gfdb ._ddedc .Left ,_gfdb ._ddedc .Right ,_gfdb ._ddedc .Top ,_gfdb ._ddedc .Bottom ;};

// NewChapter creates a new chapter with the specified title as the heading.
func (_gafg *Creator )NewChapter (title string )*Chapter {_gafg ._bffg ++;_eabbg :=_gafg .NewTextStyle ();_eabbg .FontSize =16;return _ggfc (nil ,_gafg ._gcd ,_gafg ._baec ,title ,_gafg ._bffg ,_eabbg );};

// SetPos sets the Block's positioning to absolute mode with the specified coordinates.
func (_bab *Block )SetPos (x ,y float64 ){_bab ._ggb =PositionAbsolute ;_bab ._fg =x ;_bab ._aca =y };

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_acbe *Invoice )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bcgc :=ctx ;_cgba :=[]func (_bcfc DrawContext )([]*Block ,DrawContext ,error ){_acbe .generateHeaderBlocks ,_acbe .generateInformationBlocks ,_acbe .generateLineBlocks ,_acbe .generateTotalBlocks ,_acbe .generateNoteBlocks };
var _cfdg []*Block ;for _ ,_aggbdb :=range _cgba {_bgbb ,_gbae ,_dffe :=_aggbdb (ctx );if _dffe !=nil {return _cfdg ,ctx ,_dffe ;};if len (_cfdg )==0{_cfdg =_bgbb ;}else if len (_bgbb )> 0{_cfdg [len (_cfdg )-1].mergeBlocks (_bgbb [0]);_cfdg =append (_cfdg ,_bgbb [1:]...);
};ctx =_gbae ;};if _acbe ._geea .IsRelative (){ctx .X =_bcgc .X ;};if _acbe ._geea .IsAbsolute (){return _cfdg ,_bcgc ,nil ;};return _cfdg ,ctx ,nil ;};

// Margins represents page margins or margins around an element.
type Margins struct{Left float64 ;Right float64 ;Top float64 ;Bottom float64 ;};

// MoveTo moves the drawing context to absolute coordinates (x, y).
func (_fbfc *Creator )MoveTo (x ,y float64 ){_fbfc ._acda .X =x ;_fbfc ._acda .Y =y };func (_ebd cmykColor )ToRGB ()(float64 ,float64 ,float64 ){_bac :=_ebd ._dac ;return 1-(_ebd ._fdga *(1-_bac )+_bac ),1-(_ebd ._gaa *(1-_bac )+_bac ),1-(_ebd ._fdgef *(1-_bac )+_bac );
};

// SetLevelOffset sets the amount of space an indentation level occupies.
func (_bfbca *TOCLine )SetLevelOffset (levelOffset float64 ){_bfbca ._aageb =levelOffset ;_bfbca ._cfbag ._ddaff .Left =_bfbca ._gcdc +float64 (_bfbca ._cfbg -1)*_bfbca ._aageb ;};func _aeef (_dcbe ,_egbdc ,_bbec ,_bcag float64 )*Line {return &Line {_gdee :_dcbe ,_dbcb :_egbdc ,_fdba :_bbec ,_gfcfb :_bcag ,_dbge :ColorBlack ,_fdff :1.0,_gbff :1.0,_abgaf :[]int64 {1,1},_ddfd :PositionAbsolute };
};

// SetMargins sets the margins for the Image (in relative mode): left, right, top, bottom.
func (_ggbe *Image )SetMargins (left ,right ,top ,bottom float64 ){_ggbe ._cdda .Left =left ;_ggbe ._cdda .Right =right ;_ggbe ._cdda .Top =top ;_ggbe ._cdda .Bottom =bottom ;};

// TOCLine represents a line in a table of contents.
// The component can be used both in the context of a
// table of contents component and as a standalone component.
// The representation of a table of contents line is as follows:
//       [number] [title]      [separator] [page]
// e.g.: Chapter1 Introduction ........... 1
type TOCLine struct{_cfbag *StyledParagraph ;

// Holds the text and style of the number part of the TOC line.
Number TextChunk ;

// Holds the text and style of the title part of the TOC line.
Title TextChunk ;

// Holds the text and style of the separator part of the TOC line.
Separator TextChunk ;

// Holds the text and style of the page part of the TOC line.
Page TextChunk ;_gcdc float64 ;_cfbg uint ;_aageb float64 ;_afce Positioning ;_aacdc float64 ;_cddff float64 ;_geba int64 ;};

// SetBorderOpacity sets the border opacity.
func (_cbdg *Rectangle )SetBorderOpacity (opacity float64 ){_cbdg ._fbea =opacity };

// RotatedSize returns the width and height of the rotated block.
func (_egg *Block )RotatedSize ()(float64 ,float64 ){_ ,_ ,_bf ,_ede :=_gagfgf (_egg ._bd ,_egg ._ef ,_egg ._dg );return _bf ,_ede ;};func _adfbb (_edaa float64 ,_degff float64 )float64 {return _da .Round (_edaa /_degff )*_degff };

// SetPos sets absolute positioning with specified coordinates.
func (_begfe *Paragraph )SetPos (x ,y float64 ){_begfe ._gfbe =PositionAbsolute ;_begfe ._egbdcc =x ;_begfe ._babbe =y ;};

// Width returns the width of the chart. In relative positioning mode,
// all the available context width is used at render time.
func (_baa *Chart )Width ()float64 {return float64 (_baa ._gebc .Width ())};

// Notes returns the notes section of the invoice as a title-content pair.
func (_fgea *Invoice )Notes ()(string ,string ){return _fgea ._ecbb [0],_fgea ._ecbb [1]};

// EnablePageWrap controls whether the division is wrapped across pages.
// If disabled, the division is moved in its entirety on a new page, if it
// does not fit in the available height. By default, page wrapping is enabled.
// If the height of the division is larger than an entire page, wrapping is
// enabled automatically in order to avoid unwanted behavior.
// Currently, page wrapping can only be disabled for vertical divisions.
func (_dfdf *Division )EnablePageWrap (enable bool ){_dfdf ._egac =enable };

// SetLineWidth sets the line width.
func (_dbaa *Polyline )SetLineWidth (lineWidth float64 ){_dbaa ._eadfd .LineWidth =lineWidth };func (_fdb *Block )setOpacity (_cef float64 ,_fbc float64 )(string ,error ){if (_cef < 0||_cef >=1.0)&&(_fbc < 0||_fbc >=1.0){return "",nil ;};_acb :=0;_fdf :=_gg .Sprintf ("\u0047\u0053\u0025\u0064",_acb );
for _fdb ._dab .HasExtGState (_eg .PdfObjectName (_fdf )){_acb ++;_fdf =_gg .Sprintf ("\u0047\u0053\u0025\u0064",_acb );};_gb :=_eg .MakeDict ();if _cef >=0&&_cef < 1.0{_gb .Set ("\u0063\u0061",_eg .MakeFloat (_cef ));};if _fbc >=0&&_fbc < 1.0{_gb .Set ("\u0043\u0041",_eg .MakeFloat (_fbc ));
};_fgb :=_fdb ._dab .AddExtGState (_eg .PdfObjectName (_fdf ),_gb );if _fgb !=nil {return "",_fgb ;};return _fdf ,nil ;};

// SetDueDate sets the due date of the invoice.
func (_ddfae *Invoice )SetDueDate (dueDate string )(*InvoiceCell ,*InvoiceCell ){_ddfae ._aagg [1].Value =dueDate ;return _ddfae ._aagg [0],_ddfae ._aagg [1];};

// TextAlignment options for paragraph.
type TextAlignment int ;func (_bafcg *TextStyle )horizontalScale ()float64 {return _bafcg .HorizontalScaling /100};

// DueDate returns the invoice due date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_eeeb *Invoice )DueDate ()(*InvoiceCell ,*InvoiceCell ){return _eeeb ._aagg [0],_eeeb ._aagg [1]};func (_adeae *TOCLine )prepareParagraph (_fcef *StyledParagraph ,_ggce DrawContext ){_gddc :=_adeae .Title .Text ;if _adeae .Number .Text !=""{_gddc ="\u0020"+_gddc ;
};_gddc +="\u0020";_fdafc :=_adeae .Page .Text ;if _fdafc !=""{_fdafc ="\u0020"+_fdafc ;};_fcef ._aacee =[]*TextChunk {{Text :_adeae .Number .Text ,Style :_adeae .Number .Style ,_cgaf :_adeae .getLineLink ()},{Text :_gddc ,Style :_adeae .Title .Style ,_cgaf :_adeae .getLineLink ()},{Text :_fdafc ,Style :_adeae .Page .Style ,_cgaf :_adeae .getLineLink ()}};
_fcef .wrapText ();_abeb :=len (_fcef ._cdeae );if _abeb ==0{return ;};_dbce :=_ggce .Width *1000-_fcef .getTextLineWidth (_fcef ._cdeae [_abeb -1]);_acgga :=_fcef .getTextLineWidth ([]*TextChunk {&_adeae .Separator });_gcgf :=int (_dbce /_acgga );_agabc :=_ad .Repeat (_adeae .Separator .Text ,_gcgf );
_fcfe :=_adeae .Separator .Style ;_fcded :=_fcef .Insert (2,_agabc );_fcded .Style =_fcfe ;_fcded ._cgaf =_adeae .getLineLink ();_dbce =_dbce -float64 (_gcgf )*_acgga ;if _dbce > 500{_abaa ,_cfae :=_fcfe .Font .GetRuneMetrics (' ');if _cfae &&_dbce > _abaa .Wx {_gadff :=int (_dbce /_abaa .Wx );
if _gadff > 0{_fade :=_fcfe ;_fade .FontSize =1;_fcded =_fcef .Insert (2,_ad .Repeat ("\u0020",_gadff ));_fcded .Style =_fade ;_fcded ._cgaf =_adeae .getLineLink ();};};};};

// Height returns Ellipse's document height.
func (_bdade *Ellipse )Height ()float64 {return _bdade ._ccbf };

// EnableWordWrap sets the paragraph word wrap flag.
func (_agdd *StyledParagraph )EnableWordWrap (val bool ){_agdd ._gbda =val };func (_eece *Invoice )newCell (_efbe string ,_fbee InvoiceCellProps )*InvoiceCell {return &InvoiceCell {_fbee ,_efbe };};const (CellBorderStyleNone CellBorderStyle =iota ;CellBorderStyleSingle ;
CellBorderStyleDouble ;);func _bfeg (_fagf string ,_bgce ,_eeda TextStyle )*TOC {_gcccg :=_eeda ;_gcccg .FontSize =14;_badgf :=_ebda (_gcccg );_badgf .SetEnableWrap (true );_badgf .SetTextAlignment (TextAlignmentLeft );_badgf .SetMargins (0,0,0,5);_cbac :=_badgf .Append (_fagf );
_cbac .Style =_gcccg ;return &TOC {_cffgc :_badgf ,_bgbaf :[]*TOCLine {},_acecb :_bgce ,_gbdae :_bgce ,_edge :_bgce ,_ebdec :_bgce ,_eadg :"\u002e",_aafab :10,_ceeac :Margins {0,0,2,2},_eebdg :PositionRelative ,_fdacc :_bgce ,_debd :true };};

// NewPolygon creates a new polygon.
func (_beaa *Creator )NewPolygon (points [][]_f .Point )*Polygon {return _egdd (points )};

// Height returns the total height of all rows.
func (_ecab *Table )Height ()float64 {_gabg :=float64 (0.0);for _ ,_bgaa :=range _ecab ._ecgdb {_gabg +=_bgaa ;};return _gabg ;};

// SetStyleRight sets border style for right side.
func (_bbf *border )SetStyleRight (style CellBorderStyle ){_bbf ._ded =style };

// Reset removes all the text chunks the paragraph contains.
func (_bgfg *StyledParagraph )Reset (){_bgfg ._aacee =[]*TextChunk {}};

// Logo returns the logo of the invoice.
func (_cbed *Invoice )Logo ()*Image {return _cbed ._ffbf };func (_adge *Division )ctxHeight (_gdab float64 )float64 {_gdab -=_adge ._cfe .Left +_adge ._cfe .Right +_adge ._gbaa .Left +_adge ._gbaa .Right ;var _ged float64 ;for _ ,_egcf :=range _adge ._bcfe {_ged +=_dfbdg (_egcf ,_gdab );
};return _ged ;};

// Total returns the invoice total description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_gaee *Invoice )Total ()(*InvoiceCell ,*InvoiceCell ){return _gaee ._gcbg [0],_gaee ._gcbg [1]};

// SetPageSize sets the Creator's page size.  Pages that are added after this will be created with
// this Page size.
// Does not affect pages already created.
//
// Common page sizes are defined as constants.
// Examples:
// 1. c.SetPageSize(creator.PageSizeA4)
// 2. c.SetPageSize(creator.PageSizeA3)
// 3. c.SetPageSize(creator.PageSizeLegal)
// 4. c.SetPageSize(creator.PageSizeLetter)
//
// For custom sizes: Use the PPMM (points per mm) and PPI (points per inch) when defining those based on
// physical page sizes:
//
// Examples:
// 1. 10x15 sq. mm: SetPageSize(PageSize{10*creator.PPMM, 15*creator.PPMM}) where PPMM is points per mm.
// 2. 3x2 sq. inches: SetPageSize(PageSize{3*creator.PPI, 2*creator.PPI}) where PPI is points per inch.
//
func (_ecfe *Creator )SetPageSize (size PageSize ){_ecfe ._adde =size ;_ecfe ._bfg =size [0];_ecfe ._degf =size [1];_ggcf :=0.1*_ecfe ._bfg ;_ecfe ._bdbc .Left =_ggcf ;_ecfe ._bdbc .Right =_ggcf ;_ecfe ._bdbc .Top =_ggcf ;_ecfe ._bdbc .Bottom =_ggcf ;};


// GeneratePageBlocks draws the polygon on a new block representing the page.
// Implements the Drawable interface.
func (_efcce *Polygon )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_gdaba :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_dagaa ,_gagfa :=_gdaba .setOpacity (_efcce ._gfac ,_efcce ._geag );if _gagfa !=nil {return nil ,ctx ,_gagfa ;
};_aecb :=_efcce ._egdcc ;_aecb .FillEnabled =_aecb .FillColor !=nil ;_aecb .BorderEnabled =_aecb .BorderColor !=nil &&_aecb .BorderWidth > 0;_bcace :=_aecb .Points ;for _gace :=range _bcace {for _eeag :=range _bcace [_gace ]{_dadc :=&_bcace [_gace ][_eeag ];
_dadc .Y =ctx .PageHeight -_dadc .Y ;};};_gfcfa ,_ ,_gagfa :=_aecb .Draw (_dagaa );if _gagfa !=nil {return nil ,ctx ,_gagfa ;};if _gagfa =_gdaba .addContentsByString (string (_gfcfa ));_gagfa !=nil {return nil ,ctx ,_gagfa ;};return []*Block {_gdaba },ctx ,nil ;
};

// FitMode returns the fit mode of the line.
func (_fdbf *Line )FitMode ()FitMode {return _fdbf ._edbbc };

// Ellipse defines an ellipse with a center at (xc,yc) and a specified width and height.  The ellipse can have a colored
// fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Ellipse struct{_dgedf float64 ;_ggffb float64 ;_gcf float64 ;_ccbf float64 ;_dgad Positioning ;_fgcg Color ;_bedc Color ;_eeec float64 ;};

// NewChart creates a new creator drawable based on the provided
// unichart chart component.
func NewChart (chart _gc .ChartRenderable )*Chart {return _dbb (chart )};

// Polygon represents a polygon shape.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Polygon struct{_egdcc *_f .Polygon ;_gfac float64 ;_geag float64 ;};

// TableCell defines a table cell which can contain a Drawable as content.
type TableCell struct{_dacbb Color ;_gcgge _f .LineStyle ;_bdfae CellBorderStyle ;_beac Color ;_fbcg float64 ;_acbf CellBorderStyle ;_fceg Color ;_aefg float64 ;_feaad CellBorderStyle ;_aece Color ;_aaee float64 ;_gfde CellBorderStyle ;_babc Color ;_dfacc float64 ;
_egdb ,_gbgc int ;_fdbd int ;_fafc int ;_edcdf VectorDrawable ;_egde CellHorizontalAlignment ;_dagd CellVerticalAlignment ;_bgbg float64 ;_bgabd *Table ;};

// PageFinalizeFunctionArgs holds the input arguments provided to the page
// finalize callback function which can be set using Creator.PageFinalize.
type PageFinalizeFunctionArgs struct{PageNum int ;PageWidth float64 ;PageHeight float64 ;TOCPages int ;TotalPages int ;};

// ConvertToBinary converts current image data into binary (Bi-level image) format.
// If provided image is RGB or GrayScale the function converts it into binary image
// using histogram auto threshold method.
func (_eaff *Image )ConvertToBinary ()error {return _eaff ._eaaf .ConvertToBinary ()};func (_efd *Block )addContents (_de *_af .ContentStreamOperations ){_efd ._ba .WrapIfNeeded ();_de .WrapIfNeeded ();*_efd ._ba =append (*_efd ._ba ,*_de ...);};

// Padding returns the padding of the component.
func (_caec *Division )Padding ()(_bfaf ,_bccd ,_aaeg ,_cfac float64 ){return _caec ._gbaa .Left ,_caec ._gbaa .Right ,_caec ._gbaa .Top ,_caec ._gbaa .Bottom ;};func (_bgfd *Invoice )drawSection (_fdecf ,_gbce string )[]*StyledParagraph {var _gdag []*StyledParagraph ;
if _fdecf !=""{_ceaeg :=_ebda (_bgfd ._cgff );_ceaeg .SetMargins (0,0,0,5);_ceaeg .Append (_fdecf );_gdag =append (_gdag ,_ceaeg );};if _gbce !=""{_bffa :=_ebda (_bgfd ._bad );_bffa .Append (_gbce );_gdag =append (_gdag ,_bffa );};return _gdag ;};

// Positioning represents the positioning type for drawing creator components (relative/absolute).
type Positioning int ;func (_dceac *TextChunk )clone ()*TextChunk {_accg :=*_dceac ;_accg ._cgaf =_caac (_dceac ._cgaf );return &_accg ;};

// SetFillOpacity sets the fill opacity.
func (_fedgf *PolyBezierCurve )SetFillOpacity (opacity float64 ){_fedgf ._aagaa =opacity };

// SetColorBottom sets border color for bottom.
func (_aba *border )SetColorBottom (col Color ){_aba ._fea =col };

// SetStyleLeft sets border style for left side.
func (_aeeg *border )SetStyleLeft (style CellBorderStyle ){_aeeg ._cdbb =style };const (FitModeNone FitMode =iota ;FitModeFillWidth ;);func _gafga (_aebg string )(*Image ,error ){_aagbb ,_ccebc :=_a .Open (_aebg );if _ccebc !=nil {return nil ,_ccebc ;};
defer _aagbb .Close ();_gcfa ,_ccebc :=_fd .ImageHandling .Read (_aagbb );if _ccebc !=nil {_bg .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_ccebc );return nil ,_ccebc ;
};return _ebcdc (_gcfa );};

// Positioning returns the type of positioning the line is set to use.
func (_fagb *Line )Positioning ()Positioning {return _fagb ._ddfd };func (_efad *pageTransformations )transformPage (_aggbd *_fd .PdfPage )error {if _bcbg :=_efad .applyFlip (_aggbd );_bcbg !=nil {return _bcbg ;};return nil ;};

// Indent returns the left offset of the list when nested into another list.
func (_agcb *List )Indent ()float64 {return _agcb ._ffdc };func (_dfad *TableCell )height (_fdbfa float64 )float64 {var _cdfcb float64 ;switch _acbee :=_dfad ._edcdf .(type ){case *Paragraph :if _acbee ._bbde {_acbee .SetWidth (_fdbfa -_dfad ._bgbg -_acbee ._gadg .Left -_acbee ._gadg .Right );
};_cdfcb =_acbee .Height ()+_acbee ._gadg .Top +_acbee ._gadg .Bottom +0.5*_acbee ._bec *_acbee ._eabag ;case *StyledParagraph :if _acbee ._gffg {_acbee .SetWidth (_fdbfa -_dfad ._bgbg -_acbee ._ddaff .Left -_acbee ._ddaff .Right );};_cdfcb =_acbee .Height ()+_acbee ._ddaff .Top +_acbee ._ddaff .Bottom +0.5*_acbee .getTextHeight ();
case *Image :_acbee .applyFitMode (_fdbfa -_dfad ._bgbg );_cdfcb =_acbee .Height ()+_acbee ._cdda .Top +_acbee ._cdda .Bottom ;case *Table :_acbee .updateRowHeights (_fdbfa -_dfad ._bgbg -_acbee ._ddedc .Left -_acbee ._ddedc .Right );_cdfcb =_acbee .Height ()+_acbee ._ddedc .Top +_acbee ._ddedc .Bottom ;
case *List :_cdfcb =_acbee .tableHeight (_fdbfa -_dfad ._bgbg )+_acbee ._edgd .Top +_acbee ._edgd .Bottom ;case *Division :_cdfcb =_acbee .ctxHeight (_fdbfa -_dfad ._bgbg )+_acbee ._cfe .Top +_acbee ._cfe .Bottom ;case *Chart :_cdfcb =_acbee .Height ()+_acbee ._gecd .Top +_acbee ._gecd .Bottom ;
case *Rectangle :_cdfcb =_acbee .Height ();case *Ellipse :_cdfcb =_acbee .Height ();case *Line :_cdfcb =_acbee .Height ()+_acbee ._eebc .Top +_acbee ._eebc .Bottom ;};return _cdfcb ;};

// SetLineHeight sets the line height (1.0 default).
func (_bbae *Paragraph )SetLineHeight (lineheight float64 ){_bbae ._eabag =lineheight };

// Add adds a new line with the default style to the table of contents.
func (_eeebf *TOC )Add (number ,title ,page string ,level uint )*TOCLine {_gagfg :=_eeebf .AddLine (_dfcg (TextChunk {Text :number ,Style :_eeebf ._acecb },TextChunk {Text :title ,Style :_eeebf ._gbdae },TextChunk {Text :page ,Style :_eeebf ._ebdec },level ,_eeebf ._fdacc ));
if _gagfg ==nil {return nil ;};_adgbca :=&_eeebf ._ceeac ;_gagfg .SetMargins (_adgbca .Left ,_adgbca .Right ,_adgbca .Top ,_adgbca .Bottom );_gagfg .SetLevelOffset (_eeebf ._aafab );_gagfg .Separator .Text =_eeebf ._eadg ;_gagfg .Separator .Style =_eeebf ._edge ;
return _gagfg ;};type cmykColor struct{_fdga ,_gaa ,_fdgef ,_dac float64 };

// String implements error interface.
func (_caaa UnsupportedRuneError )Error ()string {return _caaa .Message };

// SetBorderWidth sets the border width.
func (_aade *PolyBezierCurve )SetBorderWidth (borderWidth float64 ){_aade ._aecc .BorderWidth =borderWidth ;};

// SetMargins sets the Paragraph's margins.
func (_cdbca *StyledParagraph )SetMargins (left ,right ,top ,bottom float64 ){_cdbca ._ddaff .Left =left ;_cdbca ._ddaff .Right =right ;_cdbca ._ddaff .Top =top ;_cdbca ._ddaff .Bottom =bottom ;};

// Rectangle defines a rectangle with upper left corner at (x,y) and a specified width and height.  The rectangle
// can have a colored fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Rectangle struct{_acge float64 ;_aedba float64 ;_ddfc float64 ;_efab float64 ;_eeedg Positioning ;_gbdd Color ;_abeed float64 ;_aabc Color ;_bcdg float64 ;_fbea float64 ;_dffeg float64 ;_acceb float64 ;_gbbg float64 ;_afba float64 ;};func _dfcg (_gfff ,_effgb ,_eabd TextChunk ,_bgabb uint ,_cgdc TextStyle )*TOCLine {_cfbfa :=_ebda (_cgdc );
_cfbfa .SetEnableWrap (true );_cfbfa .SetTextAlignment (TextAlignmentLeft );_cfbfa .SetMargins (0,0,2,2);_gfdd :=&TOCLine {_cfbag :_cfbfa ,Number :_gfff ,Title :_effgb ,Page :_eabd ,Separator :TextChunk {Text :"\u002e",Style :_cgdc },_gcdc :0,_cfbg :_bgabb ,_aageb :10,_afce :PositionRelative };
_cfbfa ._ddaff .Left =_gfdd ._gcdc +float64 (_gfdd ._cfbg -1)*_gfdd ._aageb ;_cfbfa ._aceea =_gfdd .prepareParagraph ;return _gfdd ;};func (_fcg *Image )rotatedSize ()(float64 ,float64 ){_gbed :=_fcg ._ffab ;_ggfg :=_fcg ._dbffg ;_efdgb :=_fcg ._dffda ;
if _efdgb ==0{return _gbed ,_ggfg ;};_beadb :=_f .Path {Points :[]_f .Point {_f .NewPoint (0,0).Rotate (_efdgb ),_f .NewPoint (_gbed ,0).Rotate (_efdgb ),_f .NewPoint (0,_ggfg ).Rotate (_efdgb ),_f .NewPoint (_gbed ,_ggfg ).Rotate (_efdgb )}}.GetBoundingBox ();
return _beadb .Width ,_beadb .Height ;};

// SetBorderLineStyle sets border style (currently dashed or plain).
func (_adgd *TableCell )SetBorderLineStyle (style _f .LineStyle ){_adgd ._gcgge =style };

// SetHeading sets the text and the style of the heading of the TOC component.
func (_dfdc *TOC )SetHeading (text string ,style TextStyle ){_ggdf :=_dfdc .Heading ();_ggdf .Reset ();_dcegf :=_ggdf .Append (text );_dcegf .Style =style ;};

// SellerAddress returns the seller address used in the invoice template.
func (_ddgd *Invoice )SellerAddress ()*InvoiceAddress {return _ddgd ._bdde };

// Add adds a new Drawable to the chapter.
func (_ggga *Chapter )Add (d Drawable )error {if Drawable (_ggga )==d {_bg .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0043\u0061\u006e\u006e\u006f\u0074 \u0061\u0064\u0064\u0020\u0069\u0074\u0073\u0065\u006c\u0066");return _c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");
};switch _cece :=d .(type ){case *Paragraph ,*StyledParagraph ,*Image ,*Block ,*Table ,*PageBreak ,*Chapter :_ggga ._gebf =append (_ggga ._gebf ,d );case containerDrawable :_dbd ,_cbeb :=_cece .ContainerComponent (_ggga );if _cbeb !=nil {return _cbeb ;
};_ggga ._gebf =append (_ggga ._gebf ,_dbd );default:_bg .Log .Debug ("\u0055n\u0073u\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u003a\u0020\u0025\u0054",d );return _c .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");
};return nil ;};

// GeneratePageBlocks draws the composite curve polygon on a new block
// representing the page. Implements the Drawable interface.
func (_baag *CurvePolygon )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_agd :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_bagd ,_bfcg :=_agd .setOpacity (_baag ._eccc ,_baag ._gcac );if _bfcg !=nil {return nil ,ctx ,_bfcg ;};_ebdf :=_baag ._abff ;
_ebdf .FillEnabled =_ebdf .FillColor !=nil ;_ebdf .BorderEnabled =_ebdf .BorderColor !=nil &&_ebdf .BorderWidth > 0;var (_dbfg =ctx .PageHeight ;_fdaa =_ebdf .Rings ;_ebdc =make ([][]_f .CubicBezierCurve ,0,len (_ebdf .Rings )););for _ ,_cgfaf :=range _fdaa {_dgdb :=make ([]_f .CubicBezierCurve ,0,len (_cgfaf ));
for _ ,_cgbb :=range _cgfaf {_ebbbe :=_cgbb ;_ebbbe .P0 .Y =_dbfg -_ebbbe .P0 .Y ;_ebbbe .P1 .Y =_dbfg -_ebbbe .P1 .Y ;_ebbbe .P2 .Y =_dbfg -_ebbbe .P2 .Y ;_ebbbe .P3 .Y =_dbfg -_ebbbe .P3 .Y ;_dgdb =append (_dgdb ,_ebbbe );};_ebdc =append (_ebdc ,_dgdb );
};_ebdf .Rings =_ebdc ;defer func (){_ebdf .Rings =_fdaa }();_dbfc ,_ ,_bfcg :=_ebdf .Draw (_bagd );if _bfcg !=nil {return nil ,ctx ,_bfcg ;};if _bfcg =_agd .addContentsByString (string (_dbfc ));_bfcg !=nil {return nil ,ctx ,_bfcg ;};return []*Block {_agd },ctx ,nil ;
};

// SetSubtotal sets the subtotal of the invoice.
func (_ccbb *Invoice )SetSubtotal (value string ){_ccbb ._ceefd [1].Value =value };

// SetLogo sets the logo of the invoice.
func (_eeed *Invoice )SetLogo (logo *Image ){_eeed ._ffbf =logo };

// GeneratePageBlocks generate the Page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages.
func (_eged *Chapter )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_ffbd :=ctx ;if _eged ._feg .IsRelative (){ctx .X +=_eged ._dcf .Left ;ctx .Y +=_eged ._dcf .Top ;ctx .Width -=_eged ._dcf .Left +_eged ._dcf .Right ;ctx .Height -=_eged ._dcf .Top ;
};_aeec ,_gbeg ,_fbce :=_eged ._babb .GeneratePageBlocks (ctx );if _fbce !=nil {return _aeec ,ctx ,_fbce ;};ctx =_gbeg ;_dfe :=ctx .X ;_bde :=ctx .Y -_eged ._babb .Height ();_fad :=int64 (ctx .Page );_aac :=_eged .headingNumber ();_aaea :=_eged .headingText ();
if _eged ._dbg {_bga :=_eged ._ccd .Add (_aac ,_eged ._gec ,_g .FormatInt (_fad ,10),_eged ._acd );if _eged ._ccd ._debd {_bga .SetLink (_fad ,_dfe ,_bde );};};if _eged ._ggbc ==nil {_eged ._ggbc =_fd .NewOutlineItem (_aaea ,_fd .NewOutlineDest (_fad -1,_dfe ,_bde ));
if _eged ._cfc !=nil {_eged ._cfc ._ggbc .Add (_eged ._ggbc );}else {_eged ._ecd .Add (_eged ._ggbc );};}else {_dbe :=&_eged ._ggbc .Dest ;_dbe .Page =_fad -1;_dbe .X =_dfe ;_dbe .Y =_bde ;};for _ ,_ggff :=range _eged ._gebf {_bdb ,_cbcg ,_gfcc :=_ggff .GeneratePageBlocks (ctx );
if _gfcc !=nil {return _aeec ,ctx ,_gfcc ;};if len (_bdb )< 1{continue ;};_aeec [len (_aeec )-1].mergeBlocks (_bdb [0]);_aeec =append (_aeec ,_bdb [1:]...);ctx =_cbcg ;};if _eged ._feg .IsRelative (){ctx .X =_ffbd .X ;};if _eged ._feg .IsAbsolute (){return _aeec ,_ffbd ,nil ;
};return _aeec ,ctx ,nil ;};

// ScaleToHeight scales the Block to a specified height, maintaining the same aspect ratio.
func (_egd *Block )ScaleToHeight (h float64 ){_bgc :=h /_egd ._ef ;_egd .Scale (_bgc ,_bgc )};

// NewTable create a new Table with a specified number of columns.
func (_ada *Creator )NewTable (cols int )*Table {return _fbcc (cols )};

// GetHorizontalAlignment returns the horizontal alignment of the image.
func (_ffd *Image )GetHorizontalAlignment ()HorizontalAlignment {return _ffd ._cage };

// Write output of creator to io.Writer interface.
func (_gfa *Creator )Write (ws _e .Writer )error {if _adb :=_gfa .Finalize ();_adb !=nil {return _adb ;};_cgde :=_fd .NewPdfWriter ();_cgde .SetOptimizer (_gfa ._fda );if _gfa ._fgef !=nil {_eecd :=_cgde .SetForms (_gfa ._fgef );if _eecd !=nil {_bg .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_eecd );
return _eecd ;};};if _gfa ._ccdd !=nil {_cgde .AddOutlineTree (_gfa ._ccdd );}else if _gfa ._baec !=nil &&_gfa .AddOutlines {_cgde .AddOutlineTree (&_gfa ._baec .ToPdfOutline ().PdfOutlineTreeNode );};if _gfa ._aaa !=nil {if _bbdg :=_cgde .SetPageLabels (_gfa ._aaa );
_bbdg !=nil {_bg .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020C\u006f\u0075\u006c\u0064 no\u0074 s\u0065\u0074\u0020\u0070\u0061\u0067\u0065 l\u0061\u0062\u0065\u006c\u0073\u003a\u0020%\u0076",_bbdg );return _bbdg ;};};if _gfa ._gbfa !=nil {for _ ,_ggef :=range _gfa ._gbfa {_dbcd :=_ggef .SubsetRegistered ();
if _dbcd !=nil {_bg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0043\u006f\u0075\u006c\u0064\u0020\u006e\u006ft\u0020s\u0075\u0062\u0073\u0065\u0074\u0020\u0066\u006f\u006e\u0074\u003a\u0020\u0025\u0076",_dbcd );return _dbcd ;};};};if _gfa ._aggb !=nil {_bfbd :=_gfa ._aggb (&_cgde );
if _bfbd !=nil {_bg .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_bfbd );return _bfbd ;};};for _ ,_dae :=range _gfa ._bfba {_ccba :=_cgde .AddPage (_dae );if _ccba !=nil {_bg .Log .Error ("\u0046\u0061\u0069\u006ced\u0020\u0074\u006f\u0020\u0061\u0064\u0064\u0020\u0050\u0061\u0067\u0065\u003a\u0020%\u0076",_ccba );
return _ccba ;};};_cfdb :=_cgde .Write (ws );if _cfdb !=nil {return _cfdb ;};return nil ;};func (_cee *Block )transform (_cdc _fb .Matrix ){_gf :=_af .NewContentCreator ().Add_cm (_cdc [0],_cdc [1],_cdc [3],_cdc [4],_cdc [6],_cdc [7]).Operations ();*_cee ._ba =append (*_gf ,*_cee ._ba ...);
_cee ._ba .WrapIfNeeded ();};func (_fdaf *Paragraph )wrapText ()error {if !_fdaf ._bbde ||int (_fdaf ._abcd )<=0{_fdaf ._gacac =[]string {_fdaf ._eefd };return nil ;};_ggfgd :=NewTextChunk (_fdaf ._eefd ,TextStyle {Font :_fdaf ._geef ,FontSize :_fdaf ._bec });
_edfbd ,_eege :=_ggfgd .Wrap (_fdaf ._abcd );if _eege !=nil {return _eege ;};if _fdaf ._adacf > 0&&len (_edfbd )> _fdaf ._adacf {_edfbd =_edfbd [:_fdaf ._adacf ];};_fdaf ._gacac =_edfbd ;return nil ;};

// NewImageFromFile creates an Image from a file.
func (_gbdg *Creator )NewImageFromFile (path string )(*Image ,error ){return _gafga (path )};

// SetFillColor sets the fill color.
func (_gbgg *CurvePolygon )SetFillColor (color Color ){_gbgg ._abff .FillColor =_ecb (color )};

// MoveRight moves the drawing context right by relative displacement dx (negative goes left).
func (_gccg *Creator )MoveRight (dx float64 ){_gccg ._acda .X +=dx };

// SetFitMode sets the fit mode of the image.
// NOTE: The fit mode is only applied if relative positioning is used.
func (_abbb *Image )SetFitMode (fitMode FitMode ){_abbb ._dffa =fitMode };

// Line defines a line between point 1 (X1, Y1) and point 2 (X2, Y2).
// The line width, color, style (solid or dashed) and opacity can be
// configured. Implements the Drawable interface.
type Line struct{_gdee float64 ;_dbcb float64 ;_fdba float64 ;_gfcfb float64 ;_dbge Color ;_gbafg _f .LineStyle ;_fdff float64 ;_abgaf []int64 ;_fdgafa int64 ;_gbff float64 ;_ddfd Positioning ;_edbbc FitMode ;_eebc Margins ;};func _acgg (_dagfb ,_ffdcd ,_egfg ,_ebdb float64 )*Rectangle {return &Rectangle {_acge :_dagfb ,_aedba :_ffdcd ,_ddfc :_egfg ,_efab :_ebdb ,_aabc :ColorBlack ,_bcdg :1.0,_abeed :1.0,_fbea :1.0,_eeedg :PositionAbsolute };
};type rgbColor struct{_edcf ,_ebcg ,_abd float64 };

// Draw draws the drawable d on the block.
// Note that the drawable must not wrap, i.e. only return one block. Otherwise an error is returned.
func (_aae *Block )Draw (d Drawable )error {_fac :=DrawContext {};_fac .Width =_aae ._bd ;_fac .Height =_aae ._ef ;_fac .PageWidth =_aae ._bd ;_fac .PageHeight =_aae ._ef ;_fac .X =0;_fac .Y =0;_gba ,_ ,_dfc :=d .GeneratePageBlocks (_fac );if _dfc !=nil {return _dfc ;
};if len (_gba )!=1{return _c .New ("\u0074\u006f\u006f\u0020ma\u006e\u0079\u0020\u006f\u0075\u0074\u0070\u0075\u0074\u0020\u0062\u006c\u006f\u0063k\u0073");};for _ ,_cab :=range _gba {if _gce :=_aae .mergeBlocks (_cab );_gce !=nil {return _gce ;};};return nil ;
};

// SetBorderColor sets the border color.
func (_bead *CurvePolygon )SetBorderColor (color Color ){_bead ._abff .BorderColor =_ecb (color )};

// SetLevel sets the indentation level of the TOC line.
func (_eaaa *TOCLine )SetLevel (level uint ){_eaaa ._cfbg =level ;_eaaa ._cfbag ._ddaff .Left =_eaaa ._gcdc +float64 (_eaaa ._cfbg -1)*_eaaa ._aageb ;};

// SetIncludeInTOC sets a flag to indicate whether or not to include in tOC.
func (_deg *Chapter )SetIncludeInTOC (includeInTOC bool ){_deg ._dbg =includeInTOC };func (_affe *StyledParagraph )appendChunk (_fded *TextChunk )*TextChunk {_affe ._aacee =append (_affe ._aacee ,_fded );_affe .wrapText ();return _fded ;};

// Height returns Image's document height.
func (_bdce *Image )Height ()float64 {return _bdce ._dbffg };

// GetMargins returns the Block's margins: left, right, top, bottom.
func (_daa *Block )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _daa ._ff .Left ,_daa ._ff .Right ,_daa ._ff .Top ,_daa ._ff .Bottom ;};

// SetStyle sets the style for all the line components: number, title,
// separator, page.
func (_gffcb *TOCLine )SetStyle (style TextStyle ){_gffcb .Number .Style =style ;_gffcb .Title .Style =style ;_gffcb .Separator .Style =style ;_gffcb .Page .Style =style ;};

// GeneratePageBlocks generates the page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages. Implements the Drawable interface.
func (_bdca *Paragraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cadc :=ctx ;var _bfbaf []*Block ;_fcbc :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _bdca ._gfbe .IsRelative (){ctx .X +=_bdca ._gadg .Left ;ctx .Y +=_bdca ._gadg .Top ;
ctx .Width -=_bdca ._gadg .Left +_bdca ._gadg .Right ;ctx .Height -=_bdca ._gadg .Top ;_bdca .SetWidth (ctx .Width );if _bdca .Height ()> ctx .Height {_bfbaf =append (_bfbaf ,_fcbc );_fcbc =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_gccc :=ctx ;
_gccc .Y =ctx .Margins .Top ;_gccc .X =ctx .Margins .Left +_bdca ._gadg .Left ;_gccc .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom ;_gccc .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_bdca ._gadg .Left -_bdca ._gadg .Right ;
ctx =_gccc ;};}else {if int (_bdca ._abcd )<=0{_bdca .SetWidth (_bdca .getTextWidth ());};ctx .X =_bdca ._egbdcc ;ctx .Y =_bdca ._babbe ;};ctx ,_beffg :=_edab (_fcbc ,_bdca ,ctx );if _beffg !=nil {_bg .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_beffg );
return nil ,ctx ,_beffg ;};_bfbaf =append (_bfbaf ,_fcbc );if _bdca ._gfbe .IsRelative (){ctx .Y +=_bdca ._gadg .Bottom ;ctx .Height -=_bdca ._gadg .Bottom ;if !ctx .Inline {ctx .X =_cadc .X ;ctx .Width =_cadc .Width ;};return _bfbaf ,ctx ,nil ;};return _bfbaf ,_cadc ,nil ;
};

// MultiCell makes a new cell with the specified row span and col span
// and inserts it into the table at the current position.
func (_dagb *Table )MultiCell (rowspan ,colspan int )*TableCell {_dagb ._ddbf ++;_cfdbd :=(_dagb .moveToNextAvailableCell ()-1)%(_dagb ._ecdg )+1;_feggc :=(_dagb ._ddbf -1)/_dagb ._ecdg +1;for _feggc > _dagb ._ecea {_dagb ._ecea ++;_dagb ._ecgdb =append (_dagb ._ecgdb ,_dagb ._gddd );
};_gegfb :=&TableCell {};_gegfb ._egdb =_feggc ;_gegfb ._gbgc =_cfdbd ;_gegfb ._bgbg =5;_gegfb ._bdfae =CellBorderStyleNone ;_gegfb ._gcgge =_f .LineStyleSolid ;_gegfb ._egde =CellHorizontalAlignmentLeft ;_gegfb ._dagd =CellVerticalAlignmentTop ;_gegfb ._fbcg =0;
_gegfb ._aefg =0;_gegfb ._aaee =0;_gegfb ._dfacc =0;_gbgb :=ColorBlack ;_gegfb ._beac =_gbgb ;_gegfb ._fceg =_gbgb ;_gegfb ._aece =_gbgb ;_gegfb ._babc =_gbgb ;if rowspan < 1{_bg .Log .Debug ("\u0054\u0061\u0062\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0072\u006f\u0077\u0073\u0070a\u006e\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061t\u0020\u0031\u0020\u0028\u0025\u0064\u0029\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063e\u006c\u006c\u0020\u0072\u006f\u0077s\u0070\u0061n\u0020\u0074o\u00201\u002e",rowspan );
rowspan =1;};_cfaced :=_dagb ._ecea -(_gegfb ._egdb -1);if rowspan > _cfaced {_bg .Log .Debug ("\u0054\u0061b\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0072\u006f\u0077\u0073\u0070\u0061\u006e\u0020\u0028\u0025d\u0029\u0020\u0065\u0078\u0063\u0065e\u0064\u0073\u0020\u0072\u0065\u006d\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0072o\u0077\u0073 \u0028\u0025\u0064\u0029.\u0020\u0041\u0064\u0064\u0069n\u0067\u0020\u0072\u006f\u0077\u0073\u002e",rowspan ,_cfaced );
_dagb ._ecea +=rowspan -1;for _agab :=0;_agab <=rowspan -_cfaced ;_agab ++{_dagb ._ecgdb =append (_dagb ._ecgdb ,_dagb ._gddd );};};for _bagc :=0;_bagc < colspan &&_cfdbd +_bagc -1< len (_dagb ._dgea );_bagc ++{_dagb ._dgea [_cfdbd +_bagc -1]=rowspan -1;
};_gegfb ._fdbd =rowspan ;if colspan < 1{_bg .Log .Debug ("\u0054\u0061\u0062\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0063\u006f\u006c\u0073\u0070a\u006e\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061n\u0020\u0031\u0020\u0028\u0025\u0064\u0029\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006cs\u0070\u0061n\u0020\u0074o\u00201\u002e",colspan );
colspan =1;};_cgbfc :=_dagb ._ecdg -(_gegfb ._gbgc -1);if colspan > _cgbfc {_bg .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0065\u006c\u006c\u0020\u0063o\u006c\u0073\u0070\u0061\u006e\u0020\u0028\u0025\u0064\u0029\u0020\u0065\u0078\u0063\u0065\u0065\u0064\u0073\u0020\u0072\u0065\u006d\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0072\u006f\u0077\u0020\u0063\u006f\u006c\u0073\u0020\u0028\u0025d\u0029\u002e\u0020\u0041\u0064\u006a\u0075\u0073\u0074\u0069\u006e\u0067 \u0063\u006f\u006c\u0073\u0070\u0061n\u002e",colspan ,_cgbfc );
colspan =_cgbfc ;};_gegfb ._fafc =colspan ;_dagb ._ddbf +=colspan -1;_dagb ._abgf =append (_dagb ._abgf ,_gegfb );_gegfb ._bgabd =_dagb ;return _gegfb ;};func (_gdddf *Table )resetColumnWidths (){_gdddf ._geefa =[]float64 {};_fagcf :=float64 (1.0)/float64 (_gdddf ._ecdg );
for _dcgc :=0;_dcgc < _gdddf ._ecdg ;_dcgc ++{_gdddf ._geefa =append (_gdddf ._geefa ,_fagcf );};};

// SetBorderWidth sets the border width.
func (_gafb *Rectangle )SetBorderWidth (bw float64 ){_gafb ._bcdg =bw };

// InvoiceAddress contains contact information that can be displayed
// in an invoice. It is used for the seller and buyer information in the
// invoice template.
type InvoiceAddress struct{Heading string ;Name string ;Street string ;Street2 string ;Zip string ;City string ;State string ;Country string ;Phone string ;Email string ;

// Separator defines the separator between different address components,
// such as the city, state and zip code. It defaults to ", " when the
// field is an empty string.
Separator string ;

// If enabled, the Phone field label (`Phone: `) is not displayed.
HidePhoneLabel bool ;

// If enabled, the Email field label (`Email: `) is not displayed.
HideEmailLabel bool ;};

// TotalLines returns all the rows in the invoice totals table as
// description-value cell pairs.
func (_aage *Invoice )TotalLines ()[][2]*InvoiceCell {_ceeg :=[][2]*InvoiceCell {_aage ._ceefd };_ceeg =append (_ceeg ,_aage ._efdce ...);return append (_ceeg ,_aage ._gcbg );};func _bfdc ()*Division {return &Division {_egac :true }};

// Add appends a new item to the list.
// The supported components are: *Paragraph, *StyledParagraph and *List.
// Returns the marker used for the newly added item. The returned marker
// object can be used to change the text and style of the marker for the
// current item.
func (_eecdd *List )Add (item VectorDrawable )(*TextChunk ,error ){_bgbdf :=&listItem {_bfdd :item ,_cacc :_eecdd ._ebfga };switch _facb :=item .(type ){case *Paragraph :case *StyledParagraph :case *List :if _facb ._cdcd {_facb ._ffdc =15;};default:return nil ,_c .New ("\u0074\u0068i\u0073\u0020\u0074\u0079\u0070\u0065\u0020\u006f\u0066\u0020\u0064\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0069\u006e\u0020\u006c\u0069\u0073\u0074");
};_eecdd ._eadc =append (_eecdd ._eadc ,_bgbdf );return &_bgbdf ._cacc ,nil ;};func (_dffd *FilledCurve )draw (_ccdg string )([]byte ,*_fd .PdfRectangle ,error ){_agda :=_f .NewCubicBezierPath ();for _ ,_ggbf :=range _dffd ._gaae {_agda =_agda .AppendCurve (_ggbf );
};creator :=_af .NewContentCreator ();creator .Add_q ();if _dffd .FillEnabled &&_dffd ._fdgaf !=nil {creator .SetNonStrokingColor (_ecb (_dffd ._fdgaf ));};if _dffd .BorderEnabled {if _dffd ._aacg !=nil {creator .SetStrokingColor (_ecb (_dffd ._aacg ));
};creator .Add_w (_dffd .BorderWidth );};if len (_ccdg )> 1{creator .Add_gs (_eg .PdfObjectName (_ccdg ));};_f .DrawBezierPathWithCreator (_agda ,creator );creator .Add_h ();if _dffd .FillEnabled &&_dffd .BorderEnabled {creator .Add_B ();}else if _dffd .FillEnabled {creator .Add_f ();
}else if _dffd .BorderEnabled {creator .Add_S ();};creator .Add_Q ();_babe :=_agda .GetBoundingBox ();if _dffd .BorderEnabled {_babe .Height +=_dffd .BorderWidth ;_babe .Width +=_dffd .BorderWidth ;_babe .X -=_dffd .BorderWidth /2;_babe .Y -=_dffd .BorderWidth /2;
};_dabb :=&_fd .PdfRectangle {};_dabb .Llx =_babe .X ;_dabb .Lly =_babe .Y ;_dabb .Urx =_babe .X +_babe .Width ;_dabb .Ury =_babe .Y +_babe .Height ;return creator .Bytes (),_dabb ,nil ;};func _ebcdc (_gdeg *_fd .Image )(*Image ,error ){_fffe :=float64 (_gdeg .Width );
_fabc :=float64 (_gdeg .Height );return &Image {_eaaf :_gdeg ,_dbgd :_fffe ,_gfad :_fabc ,_ffab :_fffe ,_dbffg :_fabc ,_dffda :0,_fgg :1.0,_feaaf :PositionRelative },nil ;};func _degge (_gcefg *_fd .PdfRectangle ,_bceff _fb .Matrix )*_fd .PdfRectangle {var _cdfg _fd .PdfRectangle ;
_cdfg .Llx ,_cdfg .Lly =_bceff .Transform (_gcefg .Llx ,_gcefg .Lly );_cdfg .Urx ,_cdfg .Ury =_bceff .Transform (_gcefg .Urx ,_gcefg .Ury );_cdfg .Normalize ();return &_cdfg ;};

// Width returns the current page width.
func (_bbfa *Creator )Width ()float64 {return _bbfa ._bfg };

// SetBorderColor sets the border color.
func (_cgc *Ellipse )SetBorderColor (col Color ){_cgc ._bedc =col };

// SetShowNumbering sets a flag to indicate whether or not to show chapter numbers as part of title.
func (_gaca *Chapter )SetShowNumbering (show bool ){_gaca ._cffb =show ;_gaca ._babb .SetText (_gaca .headingText ());};func (_bdfb *StyledParagraph )wrapChunks (_agdb bool )error {if !_bdfb ._gffg ||int (_bdfb ._ccf )<=0{_bdfb ._cdeae =[][]*TextChunk {_bdfb ._aacee };
return nil ;};if _bdfb ._gbda {_bdfb .wrapWordChunks ();};_bdfb ._cdeae =[][]*TextChunk {};var _eafb []*TextChunk ;var _acgf float64 ;_bbbc :=_ga .IsSpace ;if !_agdb {_bbbc =func (rune )bool {return false };};_bdbg :=_adfbb (_bdfb ._ccf *1000.0,0.000001);
for _ ,_dacga :=range _bdfb ._aacee {_gecf :=_dacga .Style ;_dbffgc :=_dacga ._cgaf ;var (_ddbbc []rune ;_dfcff []float64 ;);_bgda :=_fdef (_dacga .Text );for _ ,_dbgad :=range _dacga .Text {if _dbgad =='\u000A'{if !_agdb {_ddbbc =append (_ddbbc ,_dbgad );
};_eafb =append (_eafb ,&TextChunk {Text :_ad .TrimRightFunc (string (_ddbbc ),_bbbc ),Style :_gecf ,_cgaf :_caac (_dbffgc )});_bdfb ._cdeae =append (_bdfb ._cdeae ,_eafb );_eafb =nil ;_acgf =0;_ddbbc =nil ;_dfcff =nil ;continue ;};_facf :=_dbgad ==' ';
_ceag ,_baaac :=_gecf .Font .GetRuneMetrics (_dbgad );if !_baaac {_bg .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_dbgad );
return _c .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");};_cffd :=_gecf .FontSize *_ceag .Wx *_gecf .horizontalScale ();_fced :=_cffd ;if !_facf {_fced =_cffd +_gecf .CharSpacing *1000.0;
};if _acgf +_cffd > _bdbg {if _bdfb ._gbda {if len (_eafb )> 0{_bdfb ._cdeae =append (_bdfb ._cdeae ,_eafb );_eafb =[]*TextChunk {};};_ddbbc =append (_ddbbc ,_dbgad );_dfcff =append (_dfcff ,_fced );_fcgg :=-1;if !_facf {for _gbbca :=len (_ddbbc )-1;_gbbca >=0;
_gbbca --{if _ddbbc [_gbbca ]==' '{_fcgg =_gbbca ;break ;};};};if _fcgg >=0{_ddbbc =_ddbbc [_fcgg +1:];_dfcff =_dfcff [_fcgg +1:];};_acgf =0;for _ ,_eecb :=range _dfcff {_acgf +=_eecb ;};continue ;};_bbfac :=-1;if !_facf {for _fdbad :=len (_ddbbc )-1;_fdbad >=0;
_fdbad --{if _ddbbc [_fdbad ]==' '{_bbfac =_fdbad ;break ;};};};_cceagb :=string (_ddbbc );if _bbfac >=0{_cceagb =string (_ddbbc [0:_bbfac +1]);_ddbbc =_ddbbc [_bbfac +1:];_ddbbc =append (_ddbbc ,_dbgad );_dfcff =_dfcff [_bbfac +1:];_dfcff =append (_dfcff ,_fced );
_acgf =0;for _ ,_dabeb :=range _dfcff {_acgf +=_dabeb ;};}else {if _facf {_acgf =0;_ddbbc =[]rune {};_dfcff =[]float64 {};}else {_acgf =_fced ;_ddbbc =[]rune {_dbgad };_dfcff =[]float64 {_fced };};};_cceagb =_fccc (_cceagb ,_bgda );if !_agdb &&_facf {_cceagb +="\u0020";
};_eafb =append (_eafb ,&TextChunk {Text :_ad .TrimRightFunc (_cceagb ,_bbbc ),Style :_gecf ,_cgaf :_caac (_dbffgc )});_bdfb ._cdeae =append (_bdfb ._cdeae ,_eafb );_eafb =[]*TextChunk {};}else {_acgf +=_fced ;_ddbbc =append (_ddbbc ,_dbgad );_dfcff =append (_dfcff ,_fced );
};};if len (_ddbbc )> 0{_caag :=_fccc (string (_ddbbc ),_bgda );_eafb =append (_eafb ,&TextChunk {Text :_caag ,Style :_gecf ,_cgaf :_caac (_dbffgc )});};};if len (_eafb )> 0{_bdfb ._cdeae =append (_bdfb ._cdeae ,_eafb );};return nil ;};

// Lines returns all the rows of the invoice line items table.
func (_fdbb *Invoice )Lines ()[][]*InvoiceCell {return _fdbb ._deff };

// Margins returns the margins of the component.
func (_ddfa *Division )Margins ()(_aegg ,_cbfe ,_abbd ,_bgcg float64 ){return _ddfa ._cfe .Left ,_ddfa ._cfe .Right ,_ddfa ._cfe .Top ,_ddfa ._cfe .Bottom ;};

// GetMargins returns the Image's margins: left, right, top, bottom.
func (_gfbg *Image )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _gfbg ._cdda .Left ,_gfbg ._cdda .Right ,_gfbg ._cdda .Top ,_gfbg ._cdda .Bottom ;};

// SetPositioning sets the positioning of the line (absolute or relative).
func (_dfeb *Line )SetPositioning (positioning Positioning ){_dfeb ._ddfd =positioning };

// MultiColCell makes a new cell with the specified column span and inserts it
// into the table at the current position.
func (_ccdb *Table )MultiColCell (colspan int )*TableCell {return _ccdb .MultiCell (1,colspan )};func (_cgfff *Invoice )drawAddress (_caggd *InvoiceAddress )[]*StyledParagraph {var _afbge []*StyledParagraph ;if _caggd .Heading !=""{_fgaf :=_ebda (_cgfff ._ebca );
_fgaf .SetMargins (0,0,0,7);_fgaf .Append (_caggd .Heading );_afbge =append (_afbge ,_fgaf );};_dgag :=_ebda (_cgfff ._bfced );_dgag .SetLineHeight (1.2);_abgg :=_caggd .Separator ;if _abgg ==""{_abgg =_cgfff ._cddf ;};_dbcc :=_caggd .City ;if _caggd .State !=""{if _dbcc !=""{_dbcc +=_abgg ;
};_dbcc +=_caggd .State ;};if _caggd .Zip !=""{if _dbcc !=""{_dbcc +=_abgg ;};_dbcc +=_caggd .Zip ;};if _caggd .Name !=""{_dgag .Append (_caggd .Name +"\u000a");};if _caggd .Street !=""{_dgag .Append (_caggd .Street +"\u000a");};if _caggd .Street2 !=""{_dgag .Append (_caggd .Street2 +"\u000a");
};if _dbcc !=""{_dgag .Append (_dbcc +"\u000a");};if _caggd .Country !=""{_dgag .Append (_caggd .Country +"\u000a");};_ffdf :=_ebda (_cgfff ._bfced );_ffdf .SetLineHeight (1.2);_ffdf .SetMargins (0,0,7,0);if _caggd .Phone !=""{_ffdf .Append (_caggd .fmtLine (_caggd .Phone ,"\u0050h\u006f\u006e\u0065\u003a\u0020",_caggd .HidePhoneLabel ));
};if _caggd .Email !=""{_ffdf .Append (_caggd .fmtLine (_caggd .Email ,"\u0045m\u0061\u0069\u006c\u003a\u0020",_caggd .HideEmailLabel ));};_afbge =append (_afbge ,_dgag ,_ffdf );return _afbge ;};

// SetMargins sets the margins of the line.
// NOTE: line margins are only applied if relative positioning is used.
func (_gfgb *Line )SetMargins (left ,right ,top ,bottom float64 ){_gfgb ._eebc .Left =left ;_gfgb ._eebc .Right =right ;_gfgb ._eebc .Top =top ;_gfgb ._eebc .Bottom =bottom ;};

// GeneratePageBlocks implements drawable interface.
func (_egc *border )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_caf :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_eafg :=_egc ._fgbb ;_bdc :=ctx .PageHeight -_egc ._bcg ;if _egc ._cfa !=nil {_cbg :=_f .Rectangle {Opacity :1.0,X :_egc ._fgbb ,Y :ctx .PageHeight -_egc ._bcg -_egc ._fef ,Height :_egc ._fef ,Width :_egc ._bef };
_cbg .FillEnabled =true ;_cbg .FillColor =_ecb (_egc ._cfa );_cbg .BorderEnabled =false ;_ege ,_ ,_ebf :=_cbg .Draw ("");if _ebf !=nil {return nil ,ctx ,_ebf ;};_ebf =_caf .addContentsByString (string (_ege ));if _ebf !=nil {return nil ,ctx ,_ebf ;};};
_dcef :=_egc ._bfb ;_afea :=_egc ._gea ;_bgd :=_egc ._agf ;_bca :=_egc ._fdeg ;_aedc :=_egc ._bfb ;if _egc ._acaa ==CellBorderStyleDouble {_aedc +=2*_dcef ;};_ggdb :=_egc ._gea ;if _egc ._agcc ==CellBorderStyleDouble {_ggdb +=2*_afea ;};_fged :=_egc ._agf ;
if _egc ._cdbb ==CellBorderStyleDouble {_fged +=2*_bgd ;};_gfbb :=_egc ._fdeg ;if _egc ._ded ==CellBorderStyleDouble {_gfbb +=2*_bca ;};_ceea :=(_aedc -_fged )/2;_gaeb :=(_aedc -_gfbb )/2;_ebff :=(_ggdb -_fged )/2;_gbg :=(_ggdb -_gfbb )/2;if _egc ._bfb !=0{_ced :=_eafg ;
_egee :=_bdc ;if _egc ._acaa ==CellBorderStyleDouble {_egee -=_dcef ;_cdeg :=_f .BasicLine {LineColor :_ecb (_egc ._ebb ),Opacity :1.0,LineWidth :_egc ._bfb ,LineStyle :_egc .LineStyle ,X1 :_ced -_aedc /2+_ceea ,Y1 :_egee +2*_dcef ,X2 :_ced +_aedc /2-_gaeb +_egc ._bef ,Y2 :_egee +2*_dcef };
_agb ,_ ,_dde :=_cdeg .Draw ("");if _dde !=nil {return nil ,ctx ,_dde ;};_dde =_caf .addContentsByString (string (_agb ));if _dde !=nil {return nil ,ctx ,_dde ;};};_cbe :=_f .BasicLine {LineWidth :_egc ._bfb ,Opacity :1.0,LineColor :_ecb (_egc ._ebb ),LineStyle :_egc .LineStyle ,X1 :_ced -_aedc /2+_ceea +(_fged -_egc ._agf ),Y1 :_egee ,X2 :_ced +_aedc /2-_gaeb +_egc ._bef -(_gfbb -_egc ._fdeg ),Y2 :_egee };
_eee ,_ ,_gbfb :=_cbe .Draw ("");if _gbfb !=nil {return nil ,ctx ,_gbfb ;};_gbfb =_caf .addContentsByString (string (_eee ));if _gbfb !=nil {return nil ,ctx ,_gbfb ;};};if _egc ._gea !=0{_ddf :=_eafg ;_afa :=_bdc -_egc ._fef ;if _egc ._agcc ==CellBorderStyleDouble {_afa +=_afea ;
_cbf :=_f .BasicLine {LineWidth :_egc ._gea ,Opacity :1.0,LineColor :_ecb (_egc ._fea ),LineStyle :_egc .LineStyle ,X1 :_ddf -_ggdb /2+_ebff ,Y1 :_afa -2*_afea ,X2 :_ddf +_ggdb /2-_gbg +_egc ._bef ,Y2 :_afa -2*_afea };_egf ,_ ,_cbeg :=_cbf .Draw ("");if _cbeg !=nil {return nil ,ctx ,_cbeg ;
};_cbeg =_caf .addContentsByString (string (_egf ));if _cbeg !=nil {return nil ,ctx ,_cbeg ;};};_cgfd :=_f .BasicLine {LineWidth :_egc ._gea ,Opacity :1.0,LineColor :_ecb (_egc ._fea ),LineStyle :_egc .LineStyle ,X1 :_ddf -_ggdb /2+_ebff +(_fged -_egc ._agf ),Y1 :_afa ,X2 :_ddf +_ggdb /2-_gbg +_egc ._bef -(_gfbb -_egc ._fdeg ),Y2 :_afa };
_cgeg ,_ ,_cbag :=_cgfd .Draw ("");if _cbag !=nil {return nil ,ctx ,_cbag ;};_cbag =_caf .addContentsByString (string (_cgeg ));if _cbag !=nil {return nil ,ctx ,_cbag ;};};if _egc ._agf !=0{_cbff :=_eafg ;_fdge :=_bdc ;if _egc ._cdbb ==CellBorderStyleDouble {_cbff +=_bgd ;
_fbbc :=_f .BasicLine {LineWidth :_egc ._agf ,Opacity :1.0,LineColor :_ecb (_egc ._abe ),LineStyle :_egc .LineStyle ,X1 :_cbff -2*_bgd ,Y1 :_fdge +_fged /2+_ceea ,X2 :_cbff -2*_bgd ,Y2 :_fdge -_fged /2-_ebff -_egc ._fef };_fbg ,_ ,_dee :=_fbbc .Draw ("");
if _dee !=nil {return nil ,ctx ,_dee ;};_dee =_caf .addContentsByString (string (_fbg ));if _dee !=nil {return nil ,ctx ,_dee ;};};_fbgb :=_f .BasicLine {LineWidth :_egc ._agf ,Opacity :1.0,LineColor :_ecb (_egc ._abe ),LineStyle :_egc .LineStyle ,X1 :_cbff ,Y1 :_fdge +_fged /2+_ceea -(_aedc -_egc ._bfb ),X2 :_cbff ,Y2 :_fdge -_fged /2-_ebff -_egc ._fef +(_ggdb -_egc ._gea )};
_effe ,_ ,_ade :=_fbgb .Draw ("");if _ade !=nil {return nil ,ctx ,_ade ;};_ade =_caf .addContentsByString (string (_effe ));if _ade !=nil {return nil ,ctx ,_ade ;};};if _egc ._fdeg !=0{_gefd :=_eafg +_egc ._bef ;_cae :=_bdc ;if _egc ._ded ==CellBorderStyleDouble {_gefd -=_bca ;
_gadf :=_f .BasicLine {LineWidth :_egc ._fdeg ,Opacity :1.0,LineColor :_ecb (_egc ._dce ),LineStyle :_egc .LineStyle ,X1 :_gefd +2*_bca ,Y1 :_cae +_gfbb /2+_gaeb ,X2 :_gefd +2*_bca ,Y2 :_cae -_gfbb /2-_gbg -_egc ._fef };_bed ,_ ,_agfa :=_gadf .Draw ("");
if _agfa !=nil {return nil ,ctx ,_agfa ;};_agfa =_caf .addContentsByString (string (_bed ));if _agfa !=nil {return nil ,ctx ,_agfa ;};};_dge :=_f .BasicLine {LineWidth :_egc ._fdeg ,Opacity :1.0,LineColor :_ecb (_egc ._dce ),LineStyle :_egc .LineStyle ,X1 :_gefd ,Y1 :_cae +_gfbb /2+_gaeb -(_aedc -_egc ._bfb ),X2 :_gefd ,Y2 :_cae -_gfbb /2-_gbg -_egc ._fef +(_ggdb -_egc ._gea )};
_eaa ,_ ,_gbec :=_dge .Draw ("");if _gbec !=nil {return nil ,ctx ,_gbec ;};_gbec =_caf .addContentsByString (string (_eaa ));if _gbec !=nil {return nil ,ctx ,_gbec ;};};return []*Block {_caf },ctx ,nil ;};

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_daaga *Paragraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _daaga ._gadg .Left ,_daaga ._gadg .Right ,_daaga ._gadg .Top ,_daaga ._gadg .Bottom ;};

// PageSize represents the page size as a 2 element array representing the width and height in PDF document units (points).
type PageSize [2]float64 ;

// AddPage adds the specified page to the creator.
// NOTE: If the page has a Rotate flag, the creator will take care of
// transforming the contents to maintain the correct orientation.
func (_bbd *Creator )AddPage (page *_fd .PdfPage )error {_bcff ,_ccb :=page .GetMediaBox ();if _ccb !=nil {_bg .Log .Debug ("\u0046\u0061\u0069l\u0065\u0064\u0020\u0074o\u0020\u0067\u0065\u0074\u0020\u0070\u0061g\u0065\u0020\u006d\u0065\u0064\u0069\u0061\u0062\u006f\u0078\u003a\u0020\u0025\u0076",_ccb );
return _ccb ;};_bcff .Normalize ();_acc ,_bea :=_bcff .Llx ,_bcff .Lly ;_gdde :=_fb .IdentityMatrix ();_gadb ,_ccb :=page .GetRotate ();if _ccb !=nil {_bg .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0025\u0073\u0020\u002d\u0020\u0069\u0067\u006e\u006f\u0072\u0069\u006e\u0067\u0020\u0061\u006e\u0064\u0020\u0061\u0073\u0073\u0075\u006d\u0069\u006e\u0067\u0020\u006e\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u000a",_ccb .Error ());
};_bdff :=_gadb %360!=0&&_gadb %90==0;if _bdff {_eca :=float64 ((360+_gadb %360)%360);if _eca ==90{_gdde =_gdde .Translate (_bcff .Width (),0);}else if _eca ==180{_gdde =_gdde .Translate (_bcff .Width (),_bcff .Height ());}else if _eca ==270{_gdde =_gdde .Translate (0,_bcff .Height ());
};_gdde =_gdde .Mult (_fb .RotationMatrix (_eca *_da .Pi /180));_gdde =_gdde .Round (0.000001);_fag :=_degge (_bcff ,_gdde );_bcff =_fag ;_bcff .Normalize ();};if _acc !=0||_bea !=0{_gdde =_fb .TranslationMatrix (_acc ,_bea ).Mult (_gdde );};if !_gdde .Identity (){_gdde =_gdde .Round (0.000001);
_bbd ._abfd [page ]=&pageTransformations {_gbfaf :&_gdde };};_bbd ._bfg =_bcff .Width ();_bbd ._degf =_bcff .Height ();_bbd .initContext ();_bbd ._bfba =append (_bbd ._bfba ,page );_bbd ._acda .Page ++;return nil ;};