//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

//
// Package creator is used for quickly generating pages and content with a simple interface.
// It is built on top of the model package to provide access to the most common
// operations such as creating text and image reports and manipulating existing pages.
//
package creator ;import (_a "bytes";_c "errors";_cba "fmt";_bb "github.com/gorilla/i18n/linebreak";_g "github.com/unidoc/unichart/render";_db "github.com/unidoc/unipdf/v3/common";_acc "github.com/unidoc/unipdf/v3/contentstream";_ee "github.com/unidoc/unipdf/v3/contentstream/draw";
_bc "github.com/unidoc/unipdf/v3/core";_fe "github.com/unidoc/unipdf/v3/internal/integrations/unichart";_gc "github.com/unidoc/unipdf/v3/internal/license";_gd "github.com/unidoc/unipdf/v3/internal/transform";_ca "github.com/unidoc/unipdf/v3/model";_f "image";
_de "io";_cb "math";_d "os";_cf "sort";_dea "strconv";_ac "strings";_e "unicode";);func (_ef *Block )addContents (_df *_acc .ContentStreamOperations ){_ef ._gg .WrapIfNeeded ();_df .WrapIfNeeded ();*_ef ._gg =append (*_ef ._gg ,*_df ...);};

// TextRenderingMode determines whether showing text shall cause glyph
// outlines to be stroked, filled, used as a clipping boundary, or some
// combination of the three.
// See section 9.3 "Text State Parameters and Operators" and
// Table 106 (pp. 254-255 PDF32000_2008).
type TextRenderingMode int ;func (_ffb *StyledParagraph )getTextWidth ()float64 {var _bcdc float64 ;_cfbd :=len (_ffb ._gagd );for _gacf ,_addb :=range _ffb ._gagd {_afgc :=&_addb .Style ;_bgce :=len (_addb .Text );for _gfeg ,_cefca :=range _addb .Text {if _cefca =='\u000A'{continue ;
};_adedf ,_gbba :=_afgc .Font .GetRuneMetrics (_cefca );if !_gbba {_db .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_cefca );
return -1;};_bcdc +=_afgc .FontSize *_adedf .Wx *_afgc .horizontalScale ();if _cefca !=' '&&(_gacf !=_cfbd -1||_gfeg !=_bgce -1){_bcdc +=_afgc .CharSpacing *1000.0;};};};return _bcdc ;};func (_bcca *Invoice )drawSection (_gdfe ,_gcef string )[]*StyledParagraph {var _bddb []*StyledParagraph ;
if _gdfe !=""{_bcbc :=_fedb (_bcca ._aebd );_bcbc .SetMargins (0,0,0,5);_bcbc .Append (_gdfe );_bddb =append (_bddb ,_bcbc );};if _gcef !=""{_adee :=_fedb (_bcca ._cfga );_adee .Append (_gcef );_bddb =append (_bddb ,_adee );};return _bddb ;};

// SetPageSize sets the Creator's page size.  Pages that are added after this will be created with
// this Page size.
// Does not affect pages already created.
//
// Common page sizes are defined as constants.
// Examples:
// 1. c.SetPageSize(creator.PageSizeA4)
// 2. c.SetPageSize(creator.PageSizeA3)
// 3. c.SetPageSize(creator.PageSizeLegal)
// 4. c.SetPageSize(creator.PageSizeLetter)
//
// For custom sizes: Use the PPMM (points per mm) and PPI (points per inch) when defining those based on
// physical page sizes:
//
// Examples:
// 1. 10x15 sq. mm: SetPageSize(PageSize{10*creator.PPMM, 15*creator.PPMM}) where PPMM is points per mm.
// 2. 3x2 sq. inches: SetPageSize(PageSize{3*creator.PPI, 2*creator.PPI}) where PPI is points per inch.
//
func (_afac *Creator )SetPageSize (size PageSize ){_afac ._bbga =size ;_afac ._fdga =size [0];_afac ._fcdb =size [1];_cbgg :=0.1*_afac ._fdga ;_afac ._bddf .Left =_cbgg ;_afac ._bddf .Right =_cbgg ;_afac ._bddf .Top =_cbgg ;_afac ._bddf .Bottom =_cbgg ;
};const (HorizontalAlignmentLeft HorizontalAlignment =iota ;HorizontalAlignmentCenter ;HorizontalAlignmentRight ;);

// AddSection adds a new content section at the end of the invoice.
func (_gaef *Invoice )AddSection (title ,content string ){_gaef ._edae =append (_gaef ._edae ,[2]string {title ,content });};func (_dggd *TOCLine )prepareParagraph (_ddafe *StyledParagraph ,_cdba DrawContext ){_geccf :=_dggd .Title .Text ;if _dggd .Number .Text !=""{_geccf ="\u0020"+_geccf ;
};_geccf +="\u0020";_effb :=_dggd .Page .Text ;if _effb !=""{_effb ="\u0020"+_effb ;};_ddafe ._gagd =[]*TextChunk {{Text :_dggd .Number .Text ,Style :_dggd .Number .Style ,_cgbd :_dggd .getLineLink ()},{Text :_geccf ,Style :_dggd .Title .Style ,_cgbd :_dggd .getLineLink ()},{Text :_effb ,Style :_dggd .Page .Style ,_cgbd :_dggd .getLineLink ()}};
_ddafe .wrapText ();_cdeb :=len (_ddafe ._bcdd );if _cdeb ==0{return ;};_afgb :=_cdba .Width *1000-_ddafe .getTextLineWidth (_ddafe ._bcdd [_cdeb -1]);_cdddf :=_ddafe .getTextLineWidth ([]*TextChunk {&_dggd .Separator });_bfbb :=int (_afgb /_cdddf );_cgcfd :=_ac .Repeat (_dggd .Separator .Text ,_bfbb );
_aefcf :=_dggd .Separator .Style ;_ffbc :=_ddafe .Insert (2,_cgcfd );_ffbc .Style =_aefcf ;_ffbc ._cgbd =_dggd .getLineLink ();_afgb =_afgb -float64 (_bfbb )*_cdddf ;if _afgb > 500{_eaef ,_gbfd :=_aefcf .Font .GetRuneMetrics (' ');if _gbfd &&_afgb > _eaef .Wx {_aaceb :=int (_afgb /_eaef .Wx );
if _aaceb > 0{_bdcbc :=_aefcf ;_bdcbc .FontSize =1;_ffbc =_ddafe .Insert (2,_ac .Repeat ("\u0020",_aaceb ));_ffbc .Style =_bdcbc ;_ffbc ._cgbd =_dggd .getLineLink ();};};};};

// NewPageBreak create a new page break.
func (_dfad *Creator )NewPageBreak ()*PageBreak {return _geag ()};

// SetFillColor sets background color for border.
func (_fgf *border )SetFillColor (col Color ){_fgf ._fcff =col };

// SetAngle sets the rotation angle of the text.
func (_fgddf *StyledParagraph )SetAngle (angle float64 ){_fgddf ._bffda =angle };

// AddTotalLine adds a new line in the invoice totals table.
func (_bgdce *Invoice )AddTotalLine (desc ,value string )(*InvoiceCell ,*InvoiceCell ){_cdbe :=&InvoiceCell {_bgdce ._acace ,desc };_ggca :=&InvoiceCell {_bgdce ._acace ,value };_bgdce ._aea =append (_bgdce ._aea ,[2]*InvoiceCell {_cdbe ,_ggca });return _cdbe ,_ggca ;
};

// Add adds a new Drawable to the chapter.
func (_gddf *Chapter )Add (d Drawable )error {if Drawable (_gddf )==d {_db .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0043\u0061\u006e\u006e\u006f\u0074 \u0061\u0064\u0064\u0020\u0069\u0074\u0073\u0065\u006c\u0066");return _c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");
};switch _caab :=d .(type ){case *Paragraph ,*StyledParagraph ,*Image ,*Block ,*Table ,*PageBreak ,*Chapter :_gddf ._cge =append (_gddf ._cge ,d );case containerDrawable :_ggbf ,_eegd :=_caab .ContainerComponent (_gddf );if _eegd !=nil {return _eegd ;};
_gddf ._cge =append (_gddf ._cge ,_ggbf );default:_db .Log .Debug ("\u0055n\u0073u\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u003a\u0020\u0025\u0054",d );return _c .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");
};return nil ;};func _gfdbdc (_bgecf *_ca .PdfRectangle ,_bdcfa _gd .Matrix )*_ca .PdfRectangle {var _ecab _ca .PdfRectangle ;_ecab .Llx ,_ecab .Lly =_bdcfa .Transform (_bgecf .Llx ,_bgecf .Lly );_ecab .Urx ,_ecab .Ury =_bdcfa .Transform (_bgecf .Urx ,_bgecf .Ury );
_ecab .Normalize ();return &_ecab ;};

// GeneratePageBlocks draws the composite Bezier curve on a new block
// representing the page. Implements the Drawable interface.
func (_eagda *PolyBezierCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bcfd :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_cdbb ,_decb :=_bcfd .setOpacity (_eagda ._dceg ,_eagda ._cacg );if _decb !=nil {return nil ,ctx ,_decb ;
};_bgda :=_eagda ._gggb ;_bgda .FillEnabled =_bgda .FillColor !=nil ;var (_gbgb =ctx .PageHeight ;_badd =_bgda .Curves ;_dbaa =make ([]_ee .CubicBezierCurve ,0,len (_bgda .Curves )););for _cbba :=range _bgda .Curves {_ccbc :=_badd [_cbba ];_ccbc .P0 .Y =_gbgb -_ccbc .P0 .Y ;
_ccbc .P1 .Y =_gbgb -_ccbc .P1 .Y ;_ccbc .P2 .Y =_gbgb -_ccbc .P2 .Y ;_ccbc .P3 .Y =_gbgb -_ccbc .P3 .Y ;_dbaa =append (_dbaa ,_ccbc );};_bgda .Curves =_dbaa ;defer func (){_bgda .Curves =_badd }();_dfcf ,_ ,_decb :=_bgda .Draw (_cdbb );if _decb !=nil {return nil ,ctx ,_decb ;
};if _decb =_bcfd .addContentsByString (string (_dfcf ));_decb !=nil {return nil ,ctx ,_decb ;};return []*Block {_bcfd },ctx ,nil ;};

// SetMargins sets the Paragraph's margins.
func (_abcgb *StyledParagraph )SetMargins (left ,right ,top ,bottom float64 ){_abcgb ._dfcc .Left =left ;_abcgb ._dfcc .Right =right ;_abcgb ._dfcc .Top =top ;_abcgb ._dfcc .Bottom =bottom ;};

// SetTerms sets the terms and conditions section of the invoice.
func (_eada *Invoice )SetTerms (title ,content string ){_eada ._egde =[2]string {title ,content }};

// SetLink makes the line an internal link.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
func (_becg *TOCLine )SetLink (page int64 ,x ,y float64 ){_becg ._fcbef =x ;_becg ._ffgca =y ;_becg ._cgge =page ;_fdffb :=_becg ._ddca ._ffdf .Color ;_becg .Number .Style .Color =_fdffb ;_becg .Title .Style .Color =_fdffb ;_becg .Separator .Style .Color =_fdffb ;
_becg .Page .Style .Color =_fdffb ;};func (_bbda *pageTransformations )transformPage (_bfd *_ca .PdfPage )error {if _adgc :=_bbda .applyFlip (_bfd );_adgc !=nil {return _adgc ;};return nil ;};var PPI float64 =72;

// NewPolygon creates a new polygon.
func (_feed *Creator )NewPolygon (points [][]_ee .Point )*Polygon {return _eaaec (points )};

// Width returns the width of the chart. In relative positioning mode,
// all the available context width is used at render time.
func (_cbabg *Chart )Width ()float64 {return float64 (_cbabg ._fdc .Width ())};

// GeneratePageBlocks draws the composite curve polygon on a new block
// representing the page. Implements the Drawable interface.
func (_bbed *CurvePolygon )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_ecfd :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_cfdbf ,_cbce :=_ecfd .setOpacity (_bbed ._cad ,_bbed ._bbfb );if _cbce !=nil {return nil ,ctx ,_cbce ;};
_ddc :=_bbed ._fdbbd ;_ddc .FillEnabled =_ddc .FillColor !=nil ;_ddc .BorderEnabled =_ddc .BorderColor !=nil &&_ddc .BorderWidth > 0;var (_dfda =ctx .PageHeight ;_dcaf =_ddc .Rings ;_gaee =make ([][]_ee .CubicBezierCurve ,0,len (_ddc .Rings )););for _ ,_ebac :=range _dcaf {_cgdb :=make ([]_ee .CubicBezierCurve ,0,len (_ebac ));
for _ ,_gdeb :=range _ebac {_bdda :=_gdeb ;_bdda .P0 .Y =_dfda -_bdda .P0 .Y ;_bdda .P1 .Y =_dfda -_bdda .P1 .Y ;_bdda .P2 .Y =_dfda -_bdda .P2 .Y ;_bdda .P3 .Y =_dfda -_bdda .P3 .Y ;_cgdb =append (_cgdb ,_bdda );};_gaee =append (_gaee ,_cgdb );};_ddc .Rings =_gaee ;
defer func (){_ddc .Rings =_dcaf }();_fefd ,_ ,_cbce :=_ddc .Draw (_cfdbf );if _cbce !=nil {return nil ,ctx ,_cbce ;};if _cbce =_ecfd .addContentsByString (string (_fefd ));_cbce !=nil {return nil ,ctx ,_cbce ;};return []*Block {_ecfd },ctx ,nil ;};func (_eb *Block )duplicate ()*Block {_bfb :=&Block {};
*_bfb =*_eb ;_gda :=_acc .ContentStreamOperations {};_gda =append (_gda ,*_eb ._gg ...);_bfb ._gg =&_gda ;return _bfb ;};const (TextOverflowVisible TextOverflow =iota ;TextOverflowHidden ;);

// NewSubchapter creates a new child chapter with the specified title.
func (_bbe *Chapter )NewSubchapter (title string )*Chapter {_affa :=_fbgaa (_bbe ._cbd ._eecf );_affa .FontSize =14;_bbe ._fgac ++;_bca :=_fbf (_bbe ,_bbe ._aafeb ,_bbe ._aba ,title ,_bbe ._fgac ,_affa );_bbe .Add (_bca );return _bca ;};

// SetColorRight sets border color for right.
func (_cgd *border )SetColorRight (col Color ){_cgd ._dcea =col };

// SetForms adds an Acroform to a PDF file.  Sets the specified form for writing.
func (_bcba *Creator )SetForms (form *_ca .PdfAcroForm )error {_bcba ._gadd =form ;return nil };

// GetCoords returns the coordinates of the Ellipse's center (xc,yc).
func (_gdaf *Ellipse )GetCoords ()(float64 ,float64 ){return _gdaf ._aed ,_gdaf ._gefa };

// SetLineWidth sets the line width.
func (_daeda *Line )SetLineWidth (lw float64 ){_daeda ._efbd =lw };func _dbc (_ced ,_abfa TextStyle )*Invoice {_gffc :=&Invoice {_dacff :"\u0049N\u0056\u004f\u0049\u0043\u0045",_aaaed :"\u002c\u0020",_bcbe :_ced ,_bcbaa :_abfa };_gffc ._bged =&InvoiceAddress {Separator :_gffc ._aaaed };
_gffc ._cded =&InvoiceAddress {Heading :"\u0042i\u006c\u006c\u0020\u0074\u006f",Separator :_gffc ._aaaed };_fbfcb :=ColorRGBFrom8bit (245,245,245);_fgcba :=ColorRGBFrom8bit (155,155,155);_gffc ._ageb =_abfa ;_gffc ._ageb .Color =_fgcba ;_gffc ._ageb .FontSize =20;
_gffc ._affe =_ced ;_gffc ._fabd =_abfa ;_gffc ._cfga =_ced ;_gffc ._aebd =_abfa ;_gffc ._dbgg =_gffc .NewCellProps ();_gffc ._dbgg .BackgroundColor =_fbfcb ;_gffc ._dbgg .TextStyle =_abfa ;_gffc ._dcgbb =_gffc .NewCellProps ();_gffc ._dcgbb .TextStyle =_abfa ;
_gffc ._dcgbb .BackgroundColor =_fbfcb ;_gffc ._dcgbb .BorderColor =_fbfcb ;_gffc ._aede =_gffc .NewCellProps ();_gffc ._aede .BorderColor =_fbfcb ;_gffc ._aede .BorderSides =[]CellBorderSide {CellBorderSideBottom };_gffc ._aede .Alignment =CellHorizontalAlignmentRight ;
_gffc ._acace =_gffc .NewCellProps ();_gffc ._acace .Alignment =CellHorizontalAlignmentRight ;_gffc ._bdgaa =[2]*InvoiceCell {_gffc .newCell ("\u0049\u006e\u0076\u006f\u0069\u0063\u0065\u0020\u006eu\u006d\u0062\u0065\u0072",_gffc ._dbgg ),_gffc .newCell ("",_gffc ._dbgg )};
_gffc ._geff =[2]*InvoiceCell {_gffc .newCell ("\u0044\u0061\u0074\u0065",_gffc ._dbgg ),_gffc .newCell ("",_gffc ._dbgg )};_gffc ._gaad =[2]*InvoiceCell {_gffc .newCell ("\u0044\u0075\u0065\u0020\u0044\u0061\u0074\u0065",_gffc ._dbgg ),_gffc .newCell ("",_gffc ._dbgg )};
_gffc ._dbedcc =[2]*InvoiceCell {_gffc .newCell ("\u0053\u0075\u0062\u0074\u006f\u0074\u0061\u006c",_gffc ._acace ),_gffc .newCell ("",_gffc ._acace )};_dgcb :=_gffc ._acace ;_dgcb .TextStyle =_abfa ;_dgcb .BackgroundColor =_fbfcb ;_dgcb .BorderColor =_fbfcb ;
_gffc ._fdefa =[2]*InvoiceCell {_gffc .newCell ("\u0054\u006f\u0074a\u006c",_dgcb ),_gffc .newCell ("",_dgcb )};_gffc ._fae =[2]string {"\u004e\u006f\u0074e\u0073",""};_gffc ._egde =[2]string {"T\u0065r\u006d\u0073\u0020\u0061\u006e\u0064\u0020\u0063o\u006e\u0064\u0069\u0074io\u006e\u0073",""};
_gffc ._bfda =[]*InvoiceCell {_gffc .newColumn ("D\u0065\u0073\u0063\u0072\u0069\u0070\u0074\u0069\u006f\u006e",CellHorizontalAlignmentLeft ),_gffc .newColumn ("\u0051\u0075\u0061\u006e\u0074\u0069\u0074\u0079",CellHorizontalAlignmentRight ),_gffc .newColumn ("\u0055\u006e\u0069\u0074\u0020\u0070\u0072\u0069\u0063\u0065",CellHorizontalAlignmentRight ),_gffc .newColumn ("\u0041\u006d\u006f\u0075\u006e\u0074",CellHorizontalAlignmentRight )};
return _gffc ;};

// MultiColCell makes a new cell with the specified column span and inserts it
// into the table at the current position.
func (_edfeb *Table )MultiColCell (colspan int )*TableCell {return _edfeb .MultiCell (1,colspan )};

// Height returns the height of the chart.
func (_fgca *Chart )Height ()float64 {return float64 (_fgca ._fdc .Height ())};

// SetColor sets the line color.
// Use ColorRGBFromHex, ColorRGBFrom8bit or ColorRGBFromArithmetic to make the color object.
func (_edaa *Line )SetColor (col Color ){_edaa ._aaad =col };

// PolyBezierCurve represents a composite curve that is the result of joining
// multiple cubic Bezier curves.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type PolyBezierCurve struct{_gggb *_ee .PolyBezierCurve ;_dceg float64 ;_cacg float64 ;};

// SetBorderWidth sets the border width.
func (_fcfee *Rectangle )SetBorderWidth (bw float64 ){_fcfee ._bbgbf =bw };

// MultiRowCell makes a new cell with the specified row span and inserts it
// into the table at the current position.
func (_eefaac *Table )MultiRowCell (rowspan int )*TableCell {return _eefaac .MultiCell (rowspan ,1)};func _gcac (_cabfc *_ca .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,238),Font :_cabfc ,FontSize :10,OutlineSize :1,HorizontalScaling :DefaultHorizontalScaling ,UnderlineStyle :TextDecorationLineStyle {Offset :1,Thickness :1}};
};

// Finalize renders all blocks to the creator pages. In addition, it takes care
// of adding headers and footers, as well as generating the front page,
// table of contents and outlines.
// Finalize is automatically called before writing the document out. Calling the
// method manually can be useful when adding external pages to the creator,
// using the AddPage method, as it renders all creator blocks to the added
// pages, without having to write the document out.
// NOTE: TOC and outlines are generated only if the AddTOC and AddOutlines
// fields of the creator are set to true (enabled by default). Furthermore, TOCs
// and outlines without content are skipped. TOC and outline content is
// added automatically when using the chapter component. TOCs and outlines can
// also be set externally, using the SetTOC and SetOutlineTree methods.
// Finalize should only be called once, after all draw calls have taken place,
// as it will return immediately if the creator instance has been finalized.
func (_fgbe *Creator )Finalize ()error {if _fgbe ._fff {return nil ;};_bac :=len (_fgbe ._fbcf );_ded :=0;if _fgbe ._gcc !=nil {_cbec :=*_fgbe ;_fgbe ._fbcf =nil ;_fgbe ._dfde =nil ;_fgbe .initContext ();_fedc :=FrontpageFunctionArgs {PageNum :1,TotalPages :_bac };
_fgbe ._gcc (_fedc );_ded +=len (_fgbe ._fbcf );_fgbe ._fbcf =_cbec ._fbcf ;_fgbe ._dfde =_cbec ._dfde ;};if _fgbe .AddTOC {_fgbe .initContext ();_fgbe ._bgfa .Page =_ded +1;if _fgbe ._ccg !=nil {if _dfa :=_fgbe ._ccg (_fgbe ._dadcd );_dfa !=nil {return _dfa ;
};};_ebfd ,_ ,_dae :=_fgbe ._dadcd .GeneratePageBlocks (_fgbe ._bgfa );if _dae !=nil {_db .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073: \u0025\u0076",_dae );
return _dae ;};_ded +=len (_ebfd );_fdab :=_fgbe ._dadcd .Lines ();for _ ,_agcb :=range _fdab {_eabd ,_aeef :=_dea .Atoi (_agcb .Page .Text );if _aeef !=nil {continue ;};_agcb .Page .Text =_dea .Itoa (_eabd +_ded );};};_bgg :=false ;var _efea []*_ca .PdfPage ;
if _fgbe ._gcc !=nil {_cfc :=*_fgbe ;_fgbe ._fbcf =nil ;_fgbe ._dfde =nil ;_ggbe :=FrontpageFunctionArgs {PageNum :1,TotalPages :_bac };_fgbe ._gcc (_ggbe );_bac +=len (_fgbe ._fbcf );_efea =_fgbe ._fbcf ;_fgbe ._fbcf =append (_fgbe ._fbcf ,_cfc ._fbcf ...);
_fgbe ._dfde =_cfc ._dfde ;_bgg =true ;};var _dcgc []*_ca .PdfPage ;if _fgbe .AddTOC {_fgbe .initContext ();if _fgbe ._ccg !=nil {if _fea :=_fgbe ._ccg (_fgbe ._dadcd );_fea !=nil {_db .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074i\u006e\u0067\u0020\u0054\u004f\u0043\u003a\u0020\u0025\u0076",_fea );
return _fea ;};};_gedd :=_fgbe ._dadcd .Lines ();for _ ,_bbbd :=range _gedd {_bbbd ._cgge +=int64 (_ded );};_dcd ,_ ,_ :=_fgbe ._dadcd .GeneratePageBlocks (_fgbe ._bgfa );for _ ,_ccb :=range _dcd {_ccb .SetPos (0,0);_bac ++;_gdc :=_fgbe .newPage ();_dcgc =append (_dcgc ,_gdc );
_fgbe .setActivePage (_gdc );_fgbe .Draw (_ccb );};if _bgg {_gaeg :=_efea ;_ega :=_fgbe ._fbcf [len (_efea ):];_fgbe ._fbcf =append ([]*_ca .PdfPage {},_gaeg ...);_fgbe ._fbcf =append (_fgbe ._fbcf ,_dcgc ...);_fgbe ._fbcf =append (_fgbe ._fbcf ,_ega ...);
}else {_fgbe ._fbcf =append (_dcgc ,_fgbe ._fbcf ...);};};if _fgbe ._cbgc !=nil &&_fgbe .AddOutlines {var _bab func (_gadge *_ca .OutlineItem );_bab =func (_bcbb *_ca .OutlineItem ){_bcbb .Dest .Page +=int64 (_ded );if _efc :=int (_bcbb .Dest .Page );_efc >=0&&_efc < len (_fgbe ._fbcf ){_bcbb .Dest .PageObj =_fgbe ._fbcf [_efc ].GetPageAsIndirectObject ();
}else {_db .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_efc );
};_bcbb .Dest .Y =_fgbe ._fcdb -_bcbb .Dest .Y ;_bfdd :=_bcbb .Items ();for _ ,_gcb :=range _bfdd {_bab (_gcb );};};_eff :=_fgbe ._cbgc .Items ();for _ ,_dbef :=range _eff {_bab (_dbef );};if _fgbe .AddTOC {var _edcca int ;if _bgg {_edcca =len (_efea );
};_ccbf :=_ca .NewOutlineDest (int64 (_edcca ),0,_fgbe ._fcdb );if _edcca >=0&&_edcca < len (_fgbe ._fbcf ){_ccbf .PageObj =_fgbe ._fbcf [_edcca ].GetPageAsIndirectObject ();}else {_db .Log .Debug ("\u0057\u0041R\u004e\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0070\u0061\u0067\u0065\u0020\u0025\u0064",_edcca );
};_fgbe ._cbgc .Insert (0,_ca .NewOutlineItem ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073",_ccbf ));};};for _bbdgf ,_eaae :=range _fgbe ._fbcf {_fgbe .setActivePage (_eaae );if _fgbe ._caga !=nil {_degc ,_dgdc ,_eag :=_eaae .Size ();
if _eag !=nil {return _eag ;};_cgcd :=PageFinalizeFunctionArgs {PageNum :_bbdgf +1,PageWidth :_degc ,PageHeight :_dgdc ,TOCPages :len (_dcgc ),TotalPages :_bac };if _bcea :=_fgbe ._caga (_cgcd );_bcea !=nil {_db .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0070\u0061\u0067\u0065\u0020\u0066\u0069\u006e\u0061\u006c\u0069\u007a\u0065 \u0063\u0061\u006c\u006c\u0062\u0061\u0063k\u003a\u0020\u0025\u0076",_bcea );
return _bcea ;};};if _fgbe ._cfdb !=nil {_gagf :=NewBlock (_fgbe ._fdga ,_fgbe ._bddf .Top );_agf :=HeaderFunctionArgs {PageNum :_bbdgf +1,TotalPages :_bac };_fgbe ._cfdb (_gagf ,_agf );_gagf .SetPos (0,0);if _cbdg :=_fgbe .Draw (_gagf );_cbdg !=nil {_db .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0068e\u0061\u0064\u0065\u0072\u003a\u0020\u0025v",_cbdg );
return _cbdg ;};};if _fgbe ._fag !=nil {_afacg :=NewBlock (_fgbe ._fdga ,_fgbe ._bddf .Bottom );_ccge :=FooterFunctionArgs {PageNum :_bbdgf +1,TotalPages :_bac };_fgbe ._fag (_afacg ,_ccge );_afacg .SetPos (0,_fgbe ._fcdb -_afacg ._cac );if _cegd :=_fgbe .Draw (_afacg );
_cegd !=nil {_db .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069n\u0067 \u0066o\u006f\u0074\u0065\u0072\u003a\u0020\u0025v",_cegd );return _cegd ;};};_ece ,_cggd :=_fgbe ._aaed [_eaae ];if _bbgg ,_begb :=_fgbe ._acfg [_eaae ];
_begb {if _cggd {_ece .transformBlock (_bbgg );};if _acag :=_bbgg .drawToPage (_eaae );_acag !=nil {_db .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0064\u0072\u0061\u0077\u0069\u006e\u0067\u0020\u0070\u0061\u0067\u0065\u0020%\u0064\u0020\u0062\u006c\u006f\u0063\u006bs\u003a\u0020\u0025\u0076",_bbdgf +1,_acag );
return _acag ;};};if _cggd {if _gbf :=_ece .transformPage (_eaae );_gbf !=nil {_db .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020c\u006f\u0075\u006c\u0064\u0020\u006eo\u0074\u0020\u0074\u0072\u0061\u006e\u0073f\u006f\u0072\u006d\u0020\u0070\u0061\u0067\u0065\u003a\u0020%\u0076",_gbf );
return _gbf ;};};};_fgbe ._fff =true ;return nil ;};

// SetContent sets the cell's content.  The content is a VectorDrawable, i.e.
// a Drawable with a known height and width.
// Currently supported VectorDrawables:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Table
// - *List
// - *Division
// - *Chart
// - *Rectangle
// - *Ellipse
func (_afdef *TableCell )SetContent (vd VectorDrawable )error {switch _dbdeg :=vd .(type ){case *Paragraph :if _dbdeg ._ggdaf {_dbdeg ._cece =true ;};_afdef ._ebgg =vd ;case *StyledParagraph :if _dbdeg ._cbcc {_dbdeg ._debf =true ;};_afdef ._ebgg =vd ;
case *Image :_afdef ._ebgg =vd ;case *Table :_afdef ._ebgg =vd ;case *List :_afdef ._ebgg =vd ;case *Division :_afdef ._ebgg =vd ;case *Chart :_afdef ._ebgg =vd ;case *Ellipse :_afdef ._ebgg =vd ;case *Rectangle :_afdef ._ebgg =vd ;default:_db .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0020\u0074\u0079p\u0065\u0020\u0025\u0054",vd );
return _bc .ErrTypeError ;};return nil ;};func (_adbe *Division )ctxHeight (_abg float64 )float64 {_abg -=_adbe ._fdea .Left +_adbe ._fdea .Right +_adbe ._gddb .Left +_adbe ._gddb .Right ;var _fcab float64 ;for _ ,_eeefb :=range _adbe ._bdcb {_fcab +=_ffac (_eeefb ,_abg );
};return _fcab ;};func (_cgcc *Division )split (_gebfg DrawContext )(_gabg ,_ecfc *Division ){var (_gaddf float64 ;_egad ,_ggbd []VectorDrawable ;);_gcd :=_gebfg .Width -_cgcc ._fdea .Left -_cgcc ._fdea .Right -_cgcc ._gddb .Left -_cgcc ._gddb .Right ;
for _beeb ,_edbb :=range _cgcc ._bdcb {_gaddf +=_ffac (_edbb ,_gcd );if _gaddf < _gebfg .Height {_egad =append (_egad ,_edbb );}else {_ggbd =_cgcc ._bdcb [_beeb :];break ;};};if len (_egad )> 0{_gabg =_eedd ();*_gabg =*_cgcc ;_gabg ._bdcb =_egad ;if _cgcc ._eebc !=nil {_gabg ._eebc =&Background {};
*_gabg ._eebc =*_cgcc ._eebc ;};};if len (_ggbd )> 0{_ecfc =_eedd ();*_ecfc =*_cgcc ;_ecfc ._bdcb =_ggbd ;if _cgcc ._eebc !=nil {_ecfc ._eebc =&Background {};*_ecfc ._eebc =*_cgcc ._eebc ;};};return _gabg ,_ecfc ;};func _addc (_ddaa [][]_ee .CubicBezierCurve )*CurvePolygon {return &CurvePolygon {_fdbbd :&_ee .CurvePolygon {Rings :_ddaa },_cad :1.0,_bbfb :1.0};
};

// SetStyleTop sets border style for top side.
func (_ebb *border )SetStyleTop (style CellBorderStyle ){_ebb ._cbea =style };func (_bg *Block )setOpacity (_bdd float64 ,_ge float64 )(string ,error ){if (_bdd < 0||_bdd >=1.0)&&(_ge < 0||_ge >=1.0){return "",nil ;};_gbg :=0;_ade :=_cba .Sprintf ("\u0047\u0053\u0025\u0064",_gbg );
for _bg ._eee .HasExtGState (_bc .PdfObjectName (_ade )){_gbg ++;_ade =_cba .Sprintf ("\u0047\u0053\u0025\u0064",_gbg );};_ed :=_bc .MakeDict ();if _bdd >=0&&_bdd < 1.0{_ed .Set ("\u0063\u0061",_bc .MakeFloat (_bdd ));};if _ge >=0&&_ge < 1.0{_ed .Set ("\u0043\u0041",_bc .MakeFloat (_ge ));
};_adg :=_bg ._eee .AddExtGState (_bc .PdfObjectName (_ade ),_ed );if _adg !=nil {return "",_adg ;};return _ade ,nil ;};func (_bbfc *TOCLine )getLineLink ()*_ca .PdfAnnotation {if _bbfc ._cgge <=0{return nil ;};return _cfbf (_bbfc ._cgge -1,_bbfc ._fcbef ,_bbfc ._ffgca ,0);
};func _dgada (_dbgdc string )*_ca .PdfAnnotation {_bfgc :=_ca .NewPdfAnnotationLink ();_bbeag :=_ca .NewBorderStyle ();_bbeag .SetBorderWidth (0);_bfgc .BS =_bbeag .ToPdfObject ();_daad :=_ca .NewPdfActionURI ();_daad .URI =_bc .MakeString (_dbgdc );_bfgc .SetAction (_daad .PdfAction );
return _bfgc .PdfAnnotation ;};

// ColorCMYKFrom8bit creates a Color from c,m,y,k values (0-100).
// Example:
//   red := ColorCMYKFrom8Bit(0, 100, 100, 0)
func ColorCMYKFrom8bit (c ,m ,y ,k byte )Color {return cmykColor {_eedg :_cb .Min (float64 (c ),100)/100.0,_ggbfb :_cb .Min (float64 (m ),100)/100.0,_gaeb :_cb .Min (float64 (y ),100)/100.0,_eece :_cb .Min (float64 (k ),100)/100.0};};

// SetHeaderRows turns the selected table rows into headers that are repeated
// for every page the table spans. startRow and endRow are inclusive.
func (_caeaa *Table )SetHeaderRows (startRow ,endRow int )error {if startRow <=0{return _c .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020r\u006f\u0077\u0020\u006d\u0075\u0073t\u0020\u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");
};if endRow <=0{return _c .New ("\u0068\u0065a\u0064\u0065\u0072\u0020e\u006e\u0064 \u0072\u006f\u0077\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074h\u0061\u006e\u0020\u0030");};if startRow > endRow {return _c .New ("\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0020\u0072\u006f\u0077\u0020\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061\u006e\u0020\u006f\u0072\u0020\u0065\u0071\u0075\u0061\u006c\u0020\u0074\u006f\u0020\u0074\u0068\u0065 \u0065\u006e\u0064\u0020\u0072o\u0077");
};_caeaa ._eafb =true ;_caeaa ._gdagf =startRow ;_caeaa ._dccfg =endRow ;return nil ;};

// NewLine creates a new Line with default parameters between (x1,y1) to (x2,y2).
func (_dcgfb *Creator )NewLine (x1 ,y1 ,x2 ,y2 float64 )*Line {return _ceeef (x1 ,y1 ,x2 ,y2 )};

// GetMargins returns the Chapter's margin: left, right, top, bottom.
func (_abfd *Chapter )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _abfd ._ebg .Left ,_abfd ._ebg .Right ,_abfd ._ebg .Top ,_abfd ._ebg .Bottom ;};

// FilledCurve represents a closed path of Bezier curves with a border and fill.
type FilledCurve struct{_eagg []_ee .CubicBezierCurve ;FillEnabled bool ;_dfadb Color ;BorderEnabled bool ;BorderWidth float64 ;_gbdc Color ;};const (CellHorizontalAlignmentLeft CellHorizontalAlignment =iota ;CellHorizontalAlignmentCenter ;CellHorizontalAlignmentRight ;
);

// TitleStyle returns the style properties used to render the invoice title.
func (_fcbf *Invoice )TitleStyle ()TextStyle {return _fcbf ._ageb };func (_afbg *StyledParagraph )split (_ecbd DrawContext )(_fdac ,_gedg *StyledParagraph ,_ggbc error ){if _ggbc =_afbg .wrapChunks (false );_ggbc !=nil {return nil ,nil ,_ggbc ;};_cdaa :=func (_afbbg []*TextChunk ,_fbfce []*TextChunk )[]*TextChunk {if len (_fbfce )==0{return _afbbg ;
};_fadc :=len (_afbbg );if _fadc ==0{return append (_afbbg ,_fbfce ...);};_afbbg [_fadc -1].Text +=_fbfce [0].Text ;return append (_afbbg ,_fbfce [1:]...);};_cdacb :=func (_bgbb *StyledParagraph ,_accd []*TextChunk )*StyledParagraph {if len (_accd )==0{return nil ;
};_cfcc :=*_bgbb ;_cfcc ._gagd =_accd ;return &_cfcc ;};var (_degae float64 ;_cafdg []*TextChunk ;_bgadd []*TextChunk ;);for _ ,_bccaa :=range _afbg ._bcdd {var _gbeb float64 ;_afccc :=make ([]*TextChunk ,0,len (_bccaa ));for _ ,_afbgc :=range _bccaa {if _afde :=_afbgc .Style .FontSize ;
_afde > _gbeb {_gbeb =_afde ;};_afccc =append (_afccc ,_afbgc .clone ());};_gbeb *=_afbg ._bcfdf ;if _afbg ._dead .IsRelative (){if _degae +_gbeb > _ecbd .Height {_bgadd =_cdaa (_bgadd ,_afccc );}else {_cafdg =_cdaa (_cafdg ,_afccc );};};_degae +=_gbeb ;
};_afbg ._bcdd =nil ;if len (_bgadd )==0{return _afbg ,nil ,nil ;};return _cdacb (_afbg ,_cafdg ),_cdacb (_afbg ,_bgadd ),nil ;};func (_fceb *StyledParagraph )wrapChunks (_acae bool )error {if !_fceb ._debf ||int (_fceb ._ggcc )<=0{_fceb ._bcdd =[][]*TextChunk {_fceb ._gagd };
return nil ;};if _fceb ._gddfe {_fceb .wrapWordChunks ();};_fceb ._bcdd =[][]*TextChunk {};var _ebbfg []*TextChunk ;var _eegad float64 ;_decd :=_e .IsSpace ;if !_acae {_decd =func (rune )bool {return false };};_ddfc :=_bbbfb (_fceb ._ggcc *1000.0,0.000001);
for _ ,_baac :=range _fceb ._gagd {_gffg :=_baac .Style ;_bfdce :=_baac ._cgbd ;var (_agae []rune ;_bdab []float64 ;);for _ ,_abacd :=range _baac .Text {if _abacd =='\u000A'{if !_acae {_agae =append (_agae ,_abacd );};_ebbfg =append (_ebbfg ,&TextChunk {Text :_ac .TrimRightFunc (string (_agae ),_decd ),Style :_gffg ,_cgbd :_eebd (_bfdce )});
_fceb ._bcdd =append (_fceb ._bcdd ,_ebbfg );_ebbfg =nil ;_eegad =0;_agae =nil ;_bdab =nil ;continue ;};_cgdba :=_abacd ==' ';_ffeca ,_gdfc :=_gffg .Font .GetRuneMetrics (_abacd );if !_gdfc {_db .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_abacd );
return _c .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");};_baea :=_gffg .FontSize *_ffeca .Wx *_gffg .horizontalScale ();_dbbf :=_baea ;if !_cgdba {_dbbf =_baea +_gffg .CharSpacing *1000.0;
};if _eegad +_baea > _ddfc {if _fceb ._gddfe {if len (_ebbfg )> 0{_fceb ._bcdd =append (_fceb ._bcdd ,_ebbfg );_ebbfg =[]*TextChunk {};};_agae =append (_agae ,_abacd );_bdab =append (_bdab ,_dbbf );_degg :=-1;if !_cgdba {for _ggdad :=len (_agae )-1;_ggdad >=0;
_ggdad --{if _agae [_ggdad ]==' '{_degg =_ggdad ;break ;};};};if _degg >=0{_agae =_agae [_degg +1:];_bdab =_bdab [_degg +1:];};_eegad =0;for _ ,_adbebb :=range _bdab {_eegad +=_adbebb ;};continue ;};_cgae :=-1;if !_cgdba {for _fbcd :=len (_agae )-1;_fbcd >=0;
_fbcd --{if _agae [_fbcd ]==' '{_cgae =_fbcd ;break ;};};};_aeafg :=string (_agae );if _cgae >=0{_aeafg =string (_agae [0:_cgae +1]);_agae =_agae [_cgae +1:];_agae =append (_agae ,_abacd );_bdab =_bdab [_cgae +1:];_bdab =append (_bdab ,_dbbf );_eegad =0;
for _ ,_agdcf :=range _bdab {_eegad +=_agdcf ;};}else {if _cgdba {_eegad =0;_agae =[]rune {};_bdab =[]float64 {};}else {_eegad =_dbbf ;_agae =[]rune {_abacd };_bdab =[]float64 {_dbbf };};};if !_acae &&_cgdba {_aeafg +="\u0020";};_ebbfg =append (_ebbfg ,&TextChunk {Text :_ac .TrimRightFunc (_aeafg ,_decd ),Style :_gffg ,_cgbd :_eebd (_bfdce )});
_fceb ._bcdd =append (_fceb ._bcdd ,_ebbfg );_ebbfg =[]*TextChunk {};}else {_eegad +=_dbbf ;_agae =append (_agae ,_abacd );_bdab =append (_bdab ,_dbbf );};};if len (_agae )> 0{_ebbfg =append (_ebbfg ,&TextChunk {Text :string (_agae ),Style :_gffg ,_cgbd :_eebd (_bfdce )});
};};if len (_ebbfg )> 0{_fceb ._bcdd =append (_fceb ._bcdd ,_ebbfg );};return nil ;};

// Division is a container component which can wrap across multiple pages.
// Currently supported drawable components:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
//
// The component stacking behavior is vertical, where the drawables are drawn
// on top of each other.
type Division struct{_bdcb []VectorDrawable ;_eccc Positioning ;_fdea Margins ;_gddb Margins ;_aaca bool ;_gead bool ;_eebc *Background ;};

// SetFillOpacity sets the fill opacity.
func (_aafa *Polygon )SetFillOpacity (opacity float64 ){_aafa ._cdgfg =opacity };func _fgc (_ggcf ,_caca ,_bbb ,_gee float64 )*border {_fga :=&border {};_fga ._cgb =_ggcf ;_fga ._dce =_caca ;_fga ._fcce =_bbb ;_fga ._cgg =_gee ;_fga ._egg =ColorBlack ;
_fga ._fcbc =ColorBlack ;_fga ._ceb =ColorBlack ;_fga ._dcea =ColorBlack ;_fga ._dgd =0;_fga ._gdf =0;_fga ._acf =0;_fga ._age =0;_fga .LineStyle =_ee .LineStyleSolid ;return _fga ;};func _cega (_gbe ,_gbbe *_ca .PdfPageResources )error {_cabc ,_ :=_gbe .GetColorspaces ();
if _cabc !=nil &&len (_cabc .Colorspaces )> 0{for _afc ,_aafe :=range _cabc .Colorspaces {_bgf :=*_bc .MakeName (_afc );if _gbbe .HasColorspaceByName (_bgf ){continue ;};_dc :=_gbbe .SetColorspaceByName (_bgf ,_aafe );if _dc !=nil {return _dc ;};};};return nil ;
};

// SetNoteStyle sets the style properties used to render the content of the
// invoice note sections.
func (_bgfe *Invoice )SetNoteStyle (style TextStyle ){_bgfe ._cfga =style };

// SetTitleStyle sets the style properties of the invoice title.
func (_feff *Invoice )SetTitleStyle (style TextStyle ){_feff ._ageb =style };func (_afge *InvoiceAddress )fmtLine (_geda ,_gdgd string ,_fcfc bool )string {if _fcfc {_gdgd ="";};return _cba .Sprintf ("\u0025\u0073\u0025s\u000a",_gdgd ,_geda );};

// NewParagraph creates a new text paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_fdef *Creator )NewParagraph (text string )*Paragraph {return _cfaa (text ,_fdef .NewTextStyle ())};

// Subtotal returns the invoice subtotal description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_acee *Invoice )Subtotal ()(*InvoiceCell ,*InvoiceCell ){return _acee ._dbedcc [0],_acee ._dbedcc [1];};

// NewTable create a new Table with a specified number of columns.
func (_eddc *Creator )NewTable (cols int )*Table {return _aaaeg (cols )};

// SetHorizontalAlignment sets the cell's horizontal alignment of content.
// Can be one of:
// - CellHorizontalAlignmentLeft
// - CellHorizontalAlignmentCenter
// - CellHorizontalAlignmentRight
func (_dgde *TableCell )SetHorizontalAlignment (halign CellHorizontalAlignment ){_dgde ._agbb =halign };

// SetBorderWidth sets the border width.
func (_dgce *Polygon )SetBorderWidth (borderWidth float64 ){_dgce ._ecdf .BorderWidth =borderWidth };

// GeneratePageBlocks implements drawable interface.
func (_dfc *border )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_acad :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_cacd :=_dfc ._cgb ;_adad :=ctx .PageHeight -_dfc ._dce ;if _dfc ._fcff !=nil {_bec :=_ee .Rectangle {Opacity :1.0,X :_dfc ._cgb ,Y :ctx .PageHeight -_dfc ._dce -_dfc ._cgg ,Height :_dfc ._cgg ,Width :_dfc ._fcce };
_bec .FillEnabled =true ;_bec .FillColor =_geg (_dfc ._fcff );_bec .BorderEnabled =false ;_eggd ,_ ,_eeg :=_bec .Draw ("");if _eeg !=nil {return nil ,ctx ,_eeg ;};_eeg =_acad .addContentsByString (string (_eggd ));if _eeg !=nil {return nil ,ctx ,_eeg ;
};};_ggb :=_dfc ._dgd ;_egeb :=_dfc ._gdf ;_gced :=_dfc ._acf ;_aae :=_dfc ._age ;_bbdg :=_dfc ._dgd ;if _dfc ._cbea ==CellBorderStyleDouble {_bbdg +=2*_ggb ;};_ecf :=_dfc ._gdf ;if _dfc ._dbb ==CellBorderStyleDouble {_ecf +=2*_egeb ;};_edfb :=_dfc ._acf ;
if _dfc ._cea ==CellBorderStyleDouble {_edfb +=2*_gced ;};_bdde :=_dfc ._age ;if _dfc ._aee ==CellBorderStyleDouble {_bdde +=2*_aae ;};_gggc :=(_bbdg -_edfb )/2;_gad :=(_bbdg -_bdde )/2;_gab :=(_ecf -_edfb )/2;_gdd :=(_ecf -_bdde )/2;if _dfc ._dgd !=0{_cbc :=_cacd ;
_cabg :=_adad ;if _dfc ._cbea ==CellBorderStyleDouble {_cabg -=_ggb ;_dgdd :=_ee .BasicLine {LineColor :_geg (_dfc ._egg ),Opacity :1.0,LineWidth :_dfc ._dgd ,LineStyle :_dfc .LineStyle ,X1 :_cbc -_bbdg /2+_gggc ,Y1 :_cabg +2*_ggb ,X2 :_cbc +_bbdg /2-_gad +_dfc ._fcce ,Y2 :_cabg +2*_ggb };
_cgce ,_ ,_geb :=_dgdd .Draw ("");if _geb !=nil {return nil ,ctx ,_geb ;};_geb =_acad .addContentsByString (string (_cgce ));if _geb !=nil {return nil ,ctx ,_geb ;};};_edc :=_ee .BasicLine {LineWidth :_dfc ._dgd ,Opacity :1.0,LineColor :_geg (_dfc ._egg ),LineStyle :_dfc .LineStyle ,X1 :_cbc -_bbdg /2+_gggc +(_edfb -_dfc ._acf ),Y1 :_cabg ,X2 :_cbc +_bbdg /2-_gad +_dfc ._fcce -(_bdde -_dfc ._age ),Y2 :_cabg };
_dag ,_ ,_bgb :=_edc .Draw ("");if _bgb !=nil {return nil ,ctx ,_bgb ;};_bgb =_acad .addContentsByString (string (_dag ));if _bgb !=nil {return nil ,ctx ,_bgb ;};};if _dfc ._gdf !=0{_gbbc :=_cacd ;_fab :=_adad -_dfc ._cgg ;if _dfc ._dbb ==CellBorderStyleDouble {_fab +=_egeb ;
_agc :=_ee .BasicLine {LineWidth :_dfc ._gdf ,Opacity :1.0,LineColor :_geg (_dfc ._fcbc ),LineStyle :_dfc .LineStyle ,X1 :_gbbc -_ecf /2+_gab ,Y1 :_fab -2*_egeb ,X2 :_gbbc +_ecf /2-_gdd +_dfc ._fcce ,Y2 :_fab -2*_egeb };_gebg ,_ ,_adea :=_agc .Draw ("");
if _adea !=nil {return nil ,ctx ,_adea ;};_adea =_acad .addContentsByString (string (_gebg ));if _adea !=nil {return nil ,ctx ,_adea ;};};_cee :=_ee .BasicLine {LineWidth :_dfc ._gdf ,Opacity :1.0,LineColor :_geg (_dfc ._fcbc ),LineStyle :_dfc .LineStyle ,X1 :_gbbc -_ecf /2+_gab +(_edfb -_dfc ._acf ),Y1 :_fab ,X2 :_gbbc +_ecf /2-_gdd +_dfc ._fcce -(_bdde -_dfc ._age ),Y2 :_fab };
_ffec ,_ ,_gdag :=_cee .Draw ("");if _gdag !=nil {return nil ,ctx ,_gdag ;};_gdag =_acad .addContentsByString (string (_ffec ));if _gdag !=nil {return nil ,ctx ,_gdag ;};};if _dfc ._acf !=0{_afed :=_cacd ;_aec :=_adad ;if _dfc ._cea ==CellBorderStyleDouble {_afed +=_gced ;
_cgbe :=_ee .BasicLine {LineWidth :_dfc ._acf ,Opacity :1.0,LineColor :_geg (_dfc ._ceb ),LineStyle :_dfc .LineStyle ,X1 :_afed -2*_gced ,Y1 :_aec +_edfb /2+_gggc ,X2 :_afed -2*_gced ,Y2 :_aec -_edfb /2-_gab -_dfc ._cgg };_ggcfd ,_ ,_bced :=_cgbe .Draw ("");
if _bced !=nil {return nil ,ctx ,_bced ;};_bced =_acad .addContentsByString (string (_ggcfd ));if _bced !=nil {return nil ,ctx ,_bced ;};};_dbed :=_ee .BasicLine {LineWidth :_dfc ._acf ,Opacity :1.0,LineColor :_geg (_dfc ._ceb ),LineStyle :_dfc .LineStyle ,X1 :_afed ,Y1 :_aec +_edfb /2+_gggc -(_bbdg -_dfc ._dgd ),X2 :_afed ,Y2 :_aec -_edfb /2-_gab -_dfc ._cgg +(_ecf -_dfc ._gdf )};
_dadc ,_ ,_bgae :=_dbed .Draw ("");if _bgae !=nil {return nil ,ctx ,_bgae ;};_bgae =_acad .addContentsByString (string (_dadc ));if _bgae !=nil {return nil ,ctx ,_bgae ;};};if _dfc ._age !=0{_cce :=_cacd +_dfc ._fcce ;_fgcb :=_adad ;if _dfc ._aee ==CellBorderStyleDouble {_cce -=_aae ;
_ebc :=_ee .BasicLine {LineWidth :_dfc ._age ,Opacity :1.0,LineColor :_geg (_dfc ._dcea ),LineStyle :_dfc .LineStyle ,X1 :_cce +2*_aae ,Y1 :_fgcb +_bdde /2+_gad ,X2 :_cce +2*_aae ,Y2 :_fgcb -_bdde /2-_gdd -_dfc ._cgg };_fdb ,_ ,_ede :=_ebc .Draw ("");if _ede !=nil {return nil ,ctx ,_ede ;
};_ede =_acad .addContentsByString (string (_fdb ));if _ede !=nil {return nil ,ctx ,_ede ;};};_bbag :=_ee .BasicLine {LineWidth :_dfc ._age ,Opacity :1.0,LineColor :_geg (_dfc ._dcea ),LineStyle :_dfc .LineStyle ,X1 :_cce ,Y1 :_fgcb +_bdde /2+_gad -(_bbdg -_dfc ._dgd ),X2 :_cce ,Y2 :_fgcb -_bdde /2-_gdd -_dfc ._cgg +(_ecf -_dfc ._gdf )};
_cddcc ,_ ,_fcd :=_bbag .Draw ("");if _fcd !=nil {return nil ,ctx ,_fcd ;};_fcd =_acad .addContentsByString (string (_cddcc ));if _fcd !=nil {return nil ,ctx ,_fcd ;};};return []*Block {_acad },ctx ,nil ;};const (TextRenderingModeFill TextRenderingMode =iota ;
TextRenderingModeStroke ;TextRenderingModeFillStroke ;TextRenderingModeInvisible ;TextRenderingModeFillClip ;TextRenderingModeStrokeClip ;TextRenderingModeFillStrokeClip ;TextRenderingModeClip ;);

// SetTextOverflow controls the behavior of paragraph text which
// does not fit in the available space.
func (_gaffb *StyledParagraph )SetTextOverflow (textOverflow TextOverflow ){_gaffb ._gace =textOverflow ;};

// Width returns the width of the Paragraph.
func (_gaf *Paragraph )Width ()float64 {if _gaf ._cece &&int (_gaf ._deda )> 0{return _gaf ._deda ;};return _gaf .getTextWidth ()/1000.0;};

// SetOpacity sets opacity for Image.
func (_geea *Image )SetOpacity (opacity float64 ){_geea ._gede =opacity };func (_dcg *Chapter )headingNumber ()string {var _dgc string ;if _dcg ._aeb {if _dcg ._cda !=0{_dgc =_dea .Itoa (_dcg ._cda )+"\u002e";};if _dcg ._ebba !=nil {_acac :=_dcg ._ebba .headingNumber ();
if _acac !=""{_dgc =_acac +_dgc ;};};};return _dgc ;};

// SetIndent sets the left offset of the list when nested into another list.
func (_afgd *List )SetIndent (indent float64 ){_afgd ._abgd =indent ;_afgd ._gcad =false };

// Height returns the height of the Paragraph. The height is calculated based on the input text and how it is wrapped
// within the container. Does not include Margins.
func (_aadg *StyledParagraph )Height ()float64 {_aadg .wrapText ();var _fgge float64 ;for _ ,_befa :=range _aadg ._bcdd {var _eecd float64 ;for _ ,_dcbd :=range _befa {_fcbea :=_aadg ._bcfdf *_dcbd .Style .FontSize ;if _fcbea > _eecd {_eecd =_fcbea ;};
};_fgge +=_eecd ;};return _fgge ;};

// TotalLines returns all the rows in the invoice totals table as
// description-value cell pairs.
func (_edeg *Invoice )TotalLines ()[][2]*InvoiceCell {_efg :=[][2]*InvoiceCell {_edeg ._dbedcc };_efg =append (_efg ,_edeg ._aea ...);return append (_efg ,_edeg ._fdefa );};

// SetLevel sets the indentation level of the TOC line.
func (_begc *TOCLine )SetLevel (level uint ){_begc ._dcae =level ;_begc ._ddca ._dfcc .Left =_begc ._ebfc +float64 (_begc ._dcae -1)*_begc ._cggdd ;};

// NewBlockFromPage creates a Block from a PDF Page.  Useful for loading template pages as blocks
// from a PDF document and additional content with the creator.
func NewBlockFromPage (page *_ca .PdfPage )(*Block ,error ){_bd :=&Block {};_cfd ,_cc :=page .GetAllContentStreams ();if _cc !=nil {return nil ,_cc ;};_ad :=_acc .NewContentStreamParser (_cfd );_bf ,_cc :=_ad .Parse ();if _cc !=nil {return nil ,_cc ;};
_bf .WrapIfNeeded ();_bd ._gg =_bf ;if page .Resources !=nil {_bd ._eee =page .Resources ;}else {_bd ._eee =_ca .NewPdfPageResources ();};_bba ,_cc :=page .GetMediaBox ();if _cc !=nil {return nil ,_cc ;};if _bba .Llx !=0||_bba .Lly !=0{_bd .translate (-_bba .Llx ,_bba .Lly );
};_bd ._ce =_bba .Urx -_bba .Llx ;_bd ._cac =_bba .Ury -_bba .Lly ;if page .Rotate !=nil {_bd ._da =-float64 (*page .Rotate );};return _bd ,nil ;};

// Draw processes the specified Drawable widget and generates blocks that can
// be rendered to the output document. The generated blocks can span over one
// or more pages. Additional pages are added if the contents go over the current
// page. Each generated block is assigned to the creator page it will be
// rendered to. In order to render the generated blocks to the creator pages,
// call Finalize, Write or WriteToFile.
func (_ceee *Creator )Draw (d Drawable )error {if _ceee .getActivePage ()==nil {_ceee .NewPage ();};_dffe ,_bcbbe ,_cagg :=d .GeneratePageBlocks (_ceee ._bgfa );if _cagg !=nil {return _cagg ;};if len (_bcbbe ._cffe )> 0{_ceee .Errors =append (_ceee .Errors ,_bcbbe ._cffe ...);
};for _dccg ,_bdcf :=range _dffe {if _dccg > 0{_ceee .NewPage ();};_cfbe :=_ceee .getActivePage ();if _cebe ,_ggdd :=_ceee ._acfg [_cfbe ];_ggdd {if _ebed :=_cebe .mergeBlocks (_bdcf );_ebed !=nil {return _ebed ;};if _bcga :=_cega (_bdcf ._eee ,_cebe ._eee );
_bcga !=nil {return _bcga ;};}else {_ceee ._acfg [_cfbe ]=_bdcf ;};};_ceee ._bgfa .X =_bcbbe .X ;_ceee ._bgfa .Y =_bcbbe .Y ;_ceee ._bgfa .Height =_bcbbe .PageHeight -_bcbbe .Y -_bcbbe .Margins .Bottom ;return nil ;};

// SetTitle sets the title of the invoice.
func (_dade *Invoice )SetTitle (title string ){_dade ._dacff =title };func _caea (_bgd _g .ChartRenderable )*Chart {return &Chart {_fdc :_bgd ,_ffd :PositionRelative ,_cfbc :Margins {Top :10,Bottom :10}};};const (TextVerticalAlignmentBaseline TextVerticalAlignment =iota ;
TextVerticalAlignmentCenter ;);

// SetTotal sets the total of the invoice.
func (_bfcf *Invoice )SetTotal (value string ){_bfcf ._fdefa [1].Value =value };

// Marker returns the marker used for the list items.
// The marker instance can be used the change the text and the style
// of newly added list items.
func (_gffcc *List )Marker ()*TextChunk {return &_gffcc ._eeba };

// SetLogo sets the logo of the invoice.
func (_adae *Invoice )SetLogo (logo *Image ){_adae ._cafd =logo };

// SetDate sets the date of the invoice.
func (_ebedg *Invoice )SetDate (date string )(*InvoiceCell ,*InvoiceCell ){_ebedg ._geff [1].Value =date ;return _ebedg ._geff [0],_ebedg ._geff [1];};

// ScaleToHeight scale Image to a specified height h, maintaining the aspect ratio.
func (_bcfa *Image )ScaleToHeight (h float64 ){_caabf :=_bcfa ._dddg /_bcfa ._ffgf ;_bcfa ._ffgf =h ;_bcfa ._dddg =h *_caabf ;};

// SkipRows skips over a specified number of rows in the table.
func (_efaga *Table )SkipRows (num int ){_bgbce :=num *_efaga ._dcff -1;if _bgbce < 0{_db .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};_efaga ._ccgd +=_bgbce ;};

// SetBorderOpacity sets the border opacity.
func (_cfgfg *Polygon )SetBorderOpacity (opacity float64 ){_cfgfg ._debce =opacity };

// SetPadding sets the padding of the component. The padding represents
// inner margins which are applied around the contents of the division.
// The background of the component is not affected by its padding.
func (_dbfd *Division )SetPadding (left ,right ,top ,bottom float64 ){_dbfd ._gddb .Left =left ;_dbfd ._gddb .Right =right ;_dbfd ._gddb .Top =top ;_dbfd ._gddb .Bottom =bottom ;};

// TOC represents a table of contents component.
// It consists of a paragraph heading and a collection of
// table of contents lines.
// The representation of a table of contents line is as follows:
//       [number] [title]      [separator] [page]
// e.g.: Chapter1 Introduction ........... 1
type TOC struct{_ebcb *StyledParagraph ;_dbeba []*TOCLine ;_afca TextStyle ;_fgbc TextStyle ;_agecd TextStyle ;_fgbbf TextStyle ;_debcf string ;_febe float64 ;_adde Margins ;_degfea Positioning ;_dgee TextStyle ;_abba bool ;};

// SetFillOpacity sets the fill opacity.
func (_fggg *CurvePolygon )SetFillOpacity (opacity float64 ){_fggg ._cad =opacity };

// SetMargins sets the margins of the component. The margins are applied
// around the division.
func (_efa *Division )SetMargins (left ,right ,top ,bottom float64 ){_efa ._fdea .Left =left ;_efa ._fdea .Right =right ;_efa ._fdea .Top =top ;_efa ._fdea .Bottom =bottom ;};func _cfbf (_acadd int64 ,_bcgfe ,_ebfac ,_eeca float64 )*_ca .PdfAnnotation {_gfgbg :=_ca .NewPdfAnnotationLink ();
_cbcd :=_ca .NewBorderStyle ();_cbcd .SetBorderWidth (0);_gfgbg .BS =_cbcd .ToPdfObject ();if _acadd < 0{_acadd =0;};_gfgbg .Dest =_bc .MakeArray (_bc .MakeInteger (_acadd ),_bc .MakeName ("\u0058\u0059\u005a"),_bc .MakeFloat (_bcgfe ),_bc .MakeFloat (_ebfac ),_bc .MakeFloat (_eeca ));
return _gfgbg .PdfAnnotation ;};

// SetAngle sets the rotation angle of the text.
func (_gedf *Paragraph )SetAngle (angle float64 ){_gedf ._eac =angle };type rgbColor struct{_acgf ,_fcbcc ,_ebf float64 };func (_bccf *pageTransformations )transformBlock (_fcage *Block ){if _bccf ._acgb !=nil {_fcage .transform (*_bccf ._acgb );};};

// SetOptimizer sets the optimizer to optimize PDF before writing.
func (_cebg *Creator )SetOptimizer (optimizer _ca .Optimizer ){_cebg ._dcgf =optimizer };func _fbf (_cfef *Chapter ,_fcfb *TOC ,_gdg *_ca .Outline ,_daf string ,_efba int ,_aded TextStyle )*Chapter {var _beb uint =1;if _cfef !=nil {_beb =_cfef ._cefe +1;
};_bcge :=&Chapter {_cda :_efba ,_gfb :_daf ,_aeb :true ,_dab :true ,_ebba :_cfef ,_aafeb :_fcfb ,_aba :_gdg ,_cge :[]Drawable {},_cefe :_beb };_ba :=_cfaa (_bcge .headingText (),_aded );_ba .SetFont (_aded .Font );_ba .SetFontSize (_aded .FontSize );_bcge ._cbd =_ba ;
return _bcge ;};

// MoveDown moves the drawing context down by relative displacement dy (negative goes up).
func (_fgfe *Creator )MoveDown (dy float64 ){_fgfe ._bgfa .Y +=dy };

// SetOutlineTree adds the specified outline tree to the PDF file generated
// by the creator. Adding an external outline tree disables the automatic
// generation of outlines done by the creator for the relevant components.
func (_bcd *Creator )SetOutlineTree (outlineTree *_ca .PdfOutlineTreeNode ){_bcd ._bdbc =outlineTree };

// SetStyle sets the style for all the line components: number, title,
// separator, page.
func (_fbbf *TOCLine )SetStyle (style TextStyle ){_fbbf .Number .Style =style ;_fbbf .Title .Style =style ;_fbbf .Separator .Style =style ;_fbbf .Page .Style =style ;};

// DueDate returns the invoice due date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_gbcg *Invoice )DueDate ()(*InvoiceCell ,*InvoiceCell ){return _gbcg ._gaad [0],_gbcg ._gaad [1]};func (_ccebcg *Paragraph )getTextLineWidth (_fcfbg string )float64 {var _eega float64 ;for _ ,_cadg :=range _fcfbg {if _cadg =='\u000A'{continue ;};
_ffga ,_aeaf :=_ccebcg ._eecf .GetRuneMetrics (_cadg );if !_aeaf {_db .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_cadg ,_cadg );
return -1;};_eega +=_ccebcg ._fcbfd *_ffga .Wx ;};return _eega ;};func (_fdgc *Invoice )generateInformationBlocks (_defe DrawContext )([]*Block ,DrawContext ,error ){_gdda :=_fedb (_fdgc ._bcbe );_gdda .SetMargins (0,0,0,20);_babf :=_fdgc .drawAddress (_fdgc ._bged );
_babf =append (_babf ,_gdda );_babf =append (_babf ,_fdgc .drawAddress (_fdgc ._cded )...);_aeddc :=_eedd ();for _ ,_aegb :=range _babf {_aeddc .Add (_aegb );};_bafc :=_fdgc .drawInformation ();_dfgb :=_aaaeg (2);_dfgb .SetMargins (0,0,25,0);_bfgd :=_dfgb .NewCell ();
_bfgd .SetIndent (0);_bfgd .SetContent (_aeddc );_bfgd =_dfgb .NewCell ();_bfgd .SetContent (_bafc );return _dfgb .GeneratePageBlocks (_defe );};func (_cdca *StyledParagraph )wrapText ()error {return _cdca .wrapChunks (true )};

// FitMode returns the fit mode of the image.
func (_aadd *Image )FitMode ()FitMode {return _aadd ._cdcd };

// GeneratePageBlocks generates a page break block.
func (_cddd *PageBreak )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bfcb :=[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y ),NewBlock (ctx .PageWidth ,ctx .PageHeight )};ctx .Page ++;_bdgd :=ctx ;_bdgd .Y =ctx .Margins .Top ;
_bdgd .X =ctx .Margins .Left ;_bdgd .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom ;_bdgd .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right ;ctx =_bdgd ;return _bfcb ,ctx ,nil ;};

// NewCellProps returns the default properties of an invoice cell.
func (_ceda *Invoice )NewCellProps ()InvoiceCellProps {_dbda :=ColorRGBFrom8bit (255,255,255);return InvoiceCellProps {TextStyle :_ceda ._bcbe ,Alignment :CellHorizontalAlignmentLeft ,BackgroundColor :_dbda ,BorderColor :_dbda ,BorderWidth :1,BorderSides :[]CellBorderSide {CellBorderSideAll }};
};

// Angle returns the block rotation angle in degrees.
func (_cd *Block )Angle ()float64 {return _cd ._da };

// Margins represents page margins or margins around an element.
type Margins struct{Left float64 ;Right float64 ;Top float64 ;Bottom float64 ;};func (_dffag *FilledCurve )draw (_deaa string )([]byte ,*_ca .PdfRectangle ,error ){_fbdc :=_ee .NewCubicBezierPath ();for _ ,_eceg :=range _dffag ._eagg {_fbdc =_fbdc .AppendCurve (_eceg );
};creator :=_acc .NewContentCreator ();creator .Add_q ();if _dffag .FillEnabled &&_dffag ._dfadb !=nil {creator .SetNonStrokingColor (_geg (_dffag ._dfadb ));};if _dffag .BorderEnabled {if _dffag ._gbdc !=nil {creator .SetStrokingColor (_geg (_dffag ._gbdc ));
};creator .Add_w (_dffag .BorderWidth );};if len (_deaa )> 1{creator .Add_gs (_bc .PdfObjectName (_deaa ));};_ee .DrawBezierPathWithCreator (_fbdc ,creator );creator .Add_h ();if _dffag .FillEnabled &&_dffag .BorderEnabled {creator .Add_B ();}else if _dffag .FillEnabled {creator .Add_f ();
}else if _dffag .BorderEnabled {creator .Add_S ();};creator .Add_Q ();_cbda :=_fbdc .GetBoundingBox ();if _dffag .BorderEnabled {_cbda .Height +=_dffag .BorderWidth ;_cbda .Width +=_dffag .BorderWidth ;_cbda .X -=_dffag .BorderWidth /2;_cbda .Y -=_dffag .BorderWidth /2;
};_cdaf :=&_ca .PdfRectangle {};_cdaf .Llx =_cbda .X ;_cdaf .Lly =_cbda .Y ;_cdaf .Urx =_cbda .X +_cbda .Width ;_cdaf .Ury =_cbda .Y +_cbda .Height ;return creator .Bytes (),_cdaf ,nil ;};

// SetFillColor sets the fill color.
func (_daccg *Ellipse )SetFillColor (col Color ){_daccg ._cacc =col };

// SetMaxLines sets the maximum number of lines before the paragraph
// text is truncated.
func (_addfg *Paragraph )SetMaxLines (maxLines int ){_addfg ._dfdec =maxLines ;_addfg .wrapText ()};

// Height returns the total height of all rows.
func (_ceac *Table )Height ()float64 {_cdff :=float64 (0.0);for _ ,_afad :=range _ceac ._accdf {_cdff +=_afad ;};return _cdff ;};

// Append adds a new text chunk to the paragraph.
func (_cdbc *StyledParagraph )Append (text string )*TextChunk {_dbfg :=NewTextChunk (text ,_cdbc ._accc );return _cdbc .appendChunk (_dbfg );};func (_dbgd *Paragraph )wrapText ()error {if !_dbgd ._cece ||int (_dbgd ._deda )<=0{_dbgd ._bedb =[]string {_dbgd ._aafb };
return nil ;};_badb :=NewTextChunk (_dbgd ._aafb ,TextStyle {Font :_dbgd ._eecf ,FontSize :_dbgd ._fcbfd });_agec ,_afcde :=_badb .Wrap (_dbgd ._deda );if _afcde !=nil {return _afcde ;};if _dbgd ._dfdec > 0&&len (_agec )> _dbgd ._dfdec {_agec =_agec [:_dbgd ._dfdec ];
};_dbgd ._bedb =_agec ;return nil ;};

// SetBorderColor sets the border color.
func (_feg *Ellipse )SetBorderColor (col Color ){_feg ._gbgf =col };

// SetBorderWidth sets the border width.
func (_bdgg *CurvePolygon )SetBorderWidth (borderWidth float64 ){_bdgg ._fdbbd .BorderWidth =borderWidth ;};

// SetColorBottom sets border color for bottom.
func (_bff *border )SetColorBottom (col Color ){_bff ._fcbc =col };

// PageBreak represents a page break for a chapter.
type PageBreak struct{};

// SetDueDate sets the due date of the invoice.
func (_bddee *Invoice )SetDueDate (dueDate string )(*InvoiceCell ,*InvoiceCell ){_bddee ._gaad [1].Value =dueDate ;return _bddee ._gaad [0],_bddee ._gaad [1];};

// SetInline sets the inline mode of the division.
func (_bcae *Division )SetInline (inline bool ){_bcae ._aaca =inline };

// ScaleToWidth scale Image to a specified width w, maintaining the aspect ratio.
func (_adggc *Image )ScaleToWidth (w float64 ){_gdcc :=_adggc ._ffgf /_adggc ._dddg ;_adggc ._dddg =w ;_adggc ._ffgf =w *_gdcc ;};

// SkipCells skips over a specified number of cells in the table.
func (_adfad *Table )SkipCells (num int ){if num < 0{_db .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};_adfad ._ccgd +=num ;};

// SetStyleRight sets border style for right side.
func (_cca *border )SetStyleRight (style CellBorderStyle ){_cca ._aee =style };func _ceeef (_ceeb ,_ceeec ,_gbaf ,_bcef float64 )*Line {_ddadc :=&Line {};_ddadc ._dfgf =_ceeb ;_ddadc ._ddda =_ceeec ;_ddadc ._fceg =_gbaf ;_ddadc ._baee =_bcef ;_ddadc ._aaad =ColorBlack ;
_ddadc ._efbd =1.0;return _ddadc ;};func (_bbdf *Block )mergeBlocks (_dba *Block )error {_ecc :=_dg (_bbdf ._gg ,_bbdf ._eee ,_dba ._gg ,_dba ._eee );if _ecc !=nil {return _ecc ;};for _ ,_fde :=range _dba ._ab {_bbdf .AddAnnotation (_fde );};return nil ;
};

// SetBorderColor sets the border color.
func (_bffdg *PolyBezierCurve )SetBorderColor (color Color ){_bffdg ._gggb .BorderColor =_geg (color )};func (_cbgd *TextStyle )horizontalScale ()float64 {return _cbgd .HorizontalScaling /100};

// MultiCell makes a new cell with the specified row span and col span
// and inserts it into the table at the current position.
func (_ddgdc *Table )MultiCell (rowspan ,colspan int )*TableCell {_ddgdc ._ccgd ++;_dfaff :=(_ddgdc .moveToNextAvailableCell ()-1)%(_ddgdc ._dcff )+1;_cecdf :=(_ddgdc ._ccgd -1)/_ddgdc ._dcff +1;for _cecdf > _ddgdc ._ddaed {_ddgdc ._ddaed ++;_ddgdc ._accdf =append (_ddgdc ._accdf ,_ddgdc ._ddefb );
};_cabf :=&TableCell {};_cabf ._bcbfb =_cecdf ;_cabf ._abfg =_dfaff ;_cabf ._ggeb =5;_cabf ._fdgb =CellBorderStyleNone ;_cabf ._ggead =_ee .LineStyleSolid ;_cabf ._agbb =CellHorizontalAlignmentLeft ;_cabf ._bfaeb =CellVerticalAlignmentTop ;_cabf ._eegg =0;
_cabf ._ddee =0;_cabf ._cdcc =0;_cabf ._bfcba =0;_fbba :=ColorBlack ;_cabf ._ffcfc =_fbba ;_cabf ._edac =_fbba ;_cabf ._fcggd =_fbba ;_cabf ._cgeda =_fbba ;if rowspan < 1{_db .Log .Debug ("\u0054\u0061\u0062\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0072\u006f\u0077\u0073\u0070a\u006e\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061t\u0020\u0031\u0020\u0028\u0025\u0064\u0029\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063e\u006c\u006c\u0020\u0072\u006f\u0077s\u0070\u0061n\u0020\u0074o\u00201\u002e",rowspan );
rowspan =1;};_affea :=_ddgdc ._ddaed -(_cabf ._bcbfb -1);if rowspan > _affea {_db .Log .Debug ("\u0054\u0061b\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0072\u006f\u0077\u0073\u0070\u0061\u006e\u0020\u0028\u0025d\u0029\u0020\u0065\u0078\u0063\u0065e\u0064\u0073\u0020\u0072\u0065\u006d\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0072o\u0077\u0073 \u0028\u0025\u0064\u0029.\u0020\u0041\u0064\u0064\u0069n\u0067\u0020\u0072\u006f\u0077\u0073\u002e",rowspan ,_affea );
_ddgdc ._ddaed +=rowspan -1;for _bgbg :=0;_bgbg <=rowspan -_affea ;_bgbg ++{_ddgdc ._accdf =append (_ddgdc ._accdf ,_ddgdc ._ddefb );};};for _bcff :=0;_bcff < colspan &&_dfaff +_bcff -1< len (_ddgdc ._accf );_bcff ++{_ddgdc ._accf [_dfaff +_bcff -1]=rowspan -1;
};_cabf ._abdf =rowspan ;if colspan < 1{_db .Log .Debug ("\u0054\u0061\u0062\u006c\u0065\u003a\u0020\u0063\u0065\u006c\u006c\u0020\u0063\u006f\u006c\u0073\u0070a\u006e\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061n\u0020\u0031\u0020\u0028\u0025\u0064\u0029\u002e\u0020\u0053\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0063e\u006c\u006c\u0020\u0063\u006f\u006cs\u0070\u0061n\u0020\u0074o\u00201\u002e",colspan );
colspan =1;};_cacf :=_ddgdc ._dcff -(_cabf ._abfg -1);if colspan > _cacf {_db .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0065\u006c\u006c\u0020\u0063o\u006c\u0073\u0070\u0061\u006e\u0020\u0028\u0025\u0064\u0029\u0020\u0065\u0078\u0063\u0065\u0065\u0064\u0073\u0020\u0072\u0065\u006d\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0072\u006f\u0077\u0020\u0063\u006f\u006c\u0073\u0020\u0028\u0025d\u0029\u002e\u0020\u0041\u0064\u006a\u0075\u0073\u0074\u0069\u006e\u0067 \u0063\u006f\u006c\u0073\u0070\u0061n\u002e",colspan ,_cacf );
colspan =_cacf ;};_cabf ._bgcdf =colspan ;_ddgdc ._ccgd +=colspan -1;_ddgdc ._deag =append (_ddgdc ._deag ,_cabf );_cabf ._cgdbb =_ddgdc ;return _cabf ;};func (_bbggf *Paragraph )getTextWidth ()float64 {_becfe :=0.0;for _ ,_edca :=range _bbggf ._aafb {if _edca =='\u000A'{continue ;
};_gbgag ,_aegd :=_bbggf ._eecf .GetRuneMetrics (_edca );if !_aegd {_db .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0052u\u006e\u0065\u0020\u0063\u0068a\u0072\u0020\u006d\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0028\u0072\u0075\u006e\u0065\u0020\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0029",_edca ,_edca );
return -1;};_becfe +=_bbggf ._fcbfd *_gbgag .Wx ;};return _becfe ;};

// TextDecorationLineStyle represents the style of lines used to decorate
// a text chunk (e.g. underline).
type TextDecorationLineStyle struct{

// Color represents the color of the line (default: the color of the text).
Color Color ;

// Offset represents the vertical offset of the line (default: 1).
Offset float64 ;

// Thickness represents the thickness of the line (default: 1).
Thickness float64 ;};

// NewImageFromData creates an Image from image data.
func (_fbce *Creator )NewImageFromData (data []byte )(*Image ,error ){return _gbga (data )};func (_geceb *Image )rotatedSize ()(float64 ,float64 ){_fced :=_geceb ._dddg ;_abaf :=_geceb ._ffgf ;_cdgg :=_geceb ._fagd ;if _cdgg ==0{return _fced ,_abaf ;};
_dfgd :=_ee .Path {Points :[]_ee .Point {_ee .NewPoint (0,0).Rotate (_cdgg ),_ee .NewPoint (_fced ,0).Rotate (_cdgg ),_ee .NewPoint (0,_abaf ).Rotate (_cdgg ),_ee .NewPoint (_fced ,_abaf ).Rotate (_cdgg )}}.GetBoundingBox ();return _dfgd .Width ,_dfgd .Height ;
};func _bcab (_agbc *Block ,_aeeb *StyledParagraph ,_egge [][]*TextChunk ,_bedc DrawContext )(DrawContext ,[][]*TextChunk ,error ){_fbad :=1;_bbbf :=_bc .PdfObjectName (_cba .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_fbad ));for _agbc ._eee .HasFontByName (_bbbf ){_fbad ++;
_bbbf =_bc .PdfObjectName (_cba .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_fbad ));};_dgfda :=_agbc ._eee .SetFontByName (_bbbf ,_aeeb ._accc .Font .ToPdfObject ());if _dgfda !=nil {return _bedc ,nil ,_dgfda ;};_fbad ++;_fcfbc :=_bbbf ;_cbbf :=_aeeb ._accc .FontSize ;
_egebc :=_aeeb ._dead .IsRelative ();var _cbee [][]_bc .PdfObjectName ;var _bcbf [][]*TextChunk ;var _fcgaf float64 ;for _bgba ,_cggba :=range _egge {var _bgbf []_bc .PdfObjectName ;var _cbdgf float64 ;if len (_cggba )> 0{_cbdgf =_cggba [0].Style .FontSize ;
};for _ ,_bddea :=range _cggba {_bcbfc :=_bddea .Style ;if _bddea .Text !=""&&_bcbfc .FontSize > _cbdgf {_cbdgf =_bcbfc .FontSize ;};_bbbf =_bc .PdfObjectName (_cba .Sprintf ("\u0046\u006f\u006e\u0074\u0025\u0064",_fbad ));_gfdb :=_agbc ._eee .SetFontByName (_bbbf ,_bcbfc .Font .ToPdfObject ());
if _gfdb !=nil {return _bedc ,nil ,_gfdb ;};_bgbf =append (_bgbf ,_bbbf );_fbad ++;};_cbdgf *=_aeeb ._bcfdf ;if _egebc &&_fcgaf +_cbdgf > _bedc .Height {_bcbf =_egge [_bgba :];_egge =_egge [:_bgba ];break ;};_fcgaf +=_cbdgf ;_cbee =append (_cbee ,_bgbf );
};_gded ,_abeba ,_beeg :=_aeeb .getLineMetrics (0);_bbcf ,_aeea :=_gded *_aeeb ._bcfdf ,_abeba *_aeeb ._bcfdf ;if len (_egge )==0{return _bedc ,_bcbf ,nil ;};_fded :=_acc .NewContentCreator ();_fded .Add_q ();_addd :=_aeea ;if _aeeb ._aaac ==TextVerticalAlignmentCenter {_addd =_abeba +(_gded +_beeg -_abeba )/2+(_aeea -_abeba )/2;
};_cgeef :=_bedc .PageHeight -_bedc .Y -_addd ;_fded .Translate (_bedc .X ,_cgeef );_eaeb :=_cgeef ;if _aeeb ._bffda !=0{_fded .RotateDeg (_aeeb ._bffda );};if _aeeb ._gace ==TextOverflowHidden {_fded .Add_re (0,-_fcgaf +_bbcf +1,_aeeb ._ggcc ,_fcgaf ).Add_W ().Add_n ();
};_fded .Add_BT ();var _ecec []*_ee .BasicLine ;for _gebfc ,_fegdc :=range _egge {_gdgc :=_bedc .X ;var _cbccd float64 ;if len (_fegdc )> 0{_cbccd =_fegdc [0].Style .FontSize ;};for _ ,_cffca :=range _fegdc {_beea :=&_cffca .Style ;if _cffca .Text !=""&&_beea .FontSize > _cbccd {_cbccd =_beea .FontSize ;
};};if _gebfc !=0{_fded .Add_TD (0,-_cbccd *_aeeb ._bcfdf );_eaeb -=_cbccd *_aeeb ._bcfdf ;};_bbcg :=_gebfc ==len (_egge )-1;var (_bfca float64 ;_eeced float64 ;_ceaa float64 ;_bbcca uint ;);var _cfedg []float64 ;for _ ,_dfef :=range _fegdc {_aeffb :=&_dfef .Style ;
if _aeffb .FontSize > _eeced {_eeced =_aeffb .FontSize ;};_bgfc ,_cdce :=_aeffb .Font .GetRuneMetrics (' ');if !_cdce {return _bedc ,nil ,_c .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");
};var _dgba uint ;var _bdeff float64 ;_abce :=len (_dfef .Text );for _dbffa ,_gbacd :=range _dfef .Text {if _gbacd ==' '{_dgba ++;continue ;};if _gbacd =='\u000A'{continue ;};_gcdc ,_babb :=_aeffb .Font .GetRuneMetrics (_gbacd );if !_babb {_db .Log .Debug ("\u0055\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006ee\u0020%\u0076\u0020\u0069\u006e\u0020\u0066\u006fn\u0074\u000a",_gbacd );
return _bedc ,nil ,_c .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");};_bdeff +=_aeffb .FontSize *_gcdc .Wx *_aeffb .horizontalScale ();if _dbffa !=_abce -1{_bdeff +=_aeffb .CharSpacing *1000.0;
};};_cfedg =append (_cfedg ,_bdeff );_bfca +=_bdeff ;_ceaa +=float64 (_dgba )*_bgfc .Wx *_aeffb .FontSize *_aeffb .horizontalScale ();_bbcca +=_dgba ;};_eeced *=_aeeb ._bcfdf ;var _geeb []_bc .PdfObject ;_geffb :=_aeeb ._ggcc *1000.0;if _aeeb ._ecdg ==TextAlignmentJustify {if _bbcca > 0&&!_bbcg {_ceaa =(_geffb -_bfca )/float64 (_bbcca )/_cbbf ;
};}else if _aeeb ._ecdg ==TextAlignmentCenter {_fgfde :=(_geffb -_bfca -_ceaa )/2;_bgge :=_fgfde /_cbbf ;_geeb =append (_geeb ,_bc .MakeFloat (-_bgge ));_gdgc +=_fgfde /1000.0;}else if _aeeb ._ecdg ==TextAlignmentRight {_ecag :=(_geffb -_bfca -_ceaa );
_adge :=_ecag /_cbbf ;_geeb =append (_geeb ,_bc .MakeFloat (-_adge ));_gdgc +=_ecag /1000.0;};if len (_geeb )> 0{_fded .Add_Tf (_fcfbc ,_cbbf ).Add_TL (_cbbf *_aeeb ._bcfdf ).Add_TJ (_geeb ...);};for _febd ,_cege :=range _fegdc {_gaaa :=&_cege .Style ;
_gegd :=_fcfbc ;_cdee :=_cbbf ;_cfbgd :=_gaaa .OutlineColor !=nil ;_bgbe :=_gaaa .HorizontalScaling !=DefaultHorizontalScaling ;_abcc :=_gaaa .OutlineSize !=1;if _abcc {_fded .Add_w (_gaaa .OutlineSize );};_bdff :=_gaaa .RenderingMode !=TextRenderingModeFill ;
if _bdff {_fded .Add_Tr (int64 (_gaaa .RenderingMode ));};_fdgcc :=_gaaa .CharSpacing !=0;if _fdgcc {_fded .Add_Tc (_gaaa .CharSpacing );};_ceafc :=_gaaa .TextRise !=0;if _ceafc {_fded .Add_Ts (_gaaa .TextRise );};if _aeeb ._ecdg !=TextAlignmentJustify ||_bbcg {_caabe ,_bfeb :=_gaaa .Font .GetRuneMetrics (' ');
if !_bfeb {return _bedc ,nil ,_c .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};_gegd =_cbee [_gebfc ][_febd ];_cdee =_gaaa .FontSize ;
_ceaa =_caabe .Wx *_gaaa .horizontalScale ();};_febde :=_gaaa .Font .Encoder ();var _bbbga []byte ;for _ ,_bedda :=range _cege .Text {if _bedda =='\u000A'{continue ;};if _bedda ==' '{if len (_bbbga )> 0{if _cfbgd {_fded .SetStrokingColor (_geg (_gaaa .OutlineColor ));
};if _bgbe {_fded .Add_Tz (_gaaa .HorizontalScaling );};_fded .SetNonStrokingColor (_geg (_gaaa .Color )).Add_Tf (_cbee [_gebfc ][_febd ],_gaaa .FontSize ).Add_TJ ([]_bc .PdfObject {_bc .MakeStringFromBytes (_bbbga )}...);_bbbga =nil ;};if _bgbe {_fded .Add_Tz (DefaultHorizontalScaling );
};_fded .Add_Tf (_gegd ,_cdee ).Add_TJ ([]_bc .PdfObject {_bc .MakeFloat (-_ceaa )}...);_cfedg [_febd ]+=_ceaa *_cdee ;}else {if _ ,_adede :=_febde .RuneToCharcode (_bedda );!_adede {_dgfda =UnsupportedRuneError {Message :_cba .Sprintf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_bedda ,_bedda ),Rune :_bedda };
_bedc ._cffe =append (_bedc ._cffe ,_dgfda );_db .Log .Debug (_dgfda .Error ());if _bedc ._eadb <=0{continue ;};_bedda =_bedc ._eadb ;};_bbbga =append (_bbbga ,_febde .Encode (string (_bedda ))...);};};if len (_bbbga )> 0{if _cfbgd {_fded .SetStrokingColor (_geg (_gaaa .OutlineColor ));
};if _bgbe {_fded .Add_Tz (_gaaa .HorizontalScaling );};_fded .SetNonStrokingColor (_geg (_gaaa .Color )).Add_Tf (_cbee [_gebfc ][_febd ],_gaaa .FontSize ).Add_TJ ([]_bc .PdfObject {_bc .MakeStringFromBytes (_bbbga )}...);};_gbbg :=_cfedg [_febd ]/1000.0;
if _gaaa .Underline {_ddec :=_gaaa .UnderlineStyle .Color ;if _ddec ==nil {_ddec =_cege .Style .Color ;};_cbad ,_bade ,_gfcd :=_ddec .ToRGB ();_badf :=_gdgc -_bedc .X ;_bbbee :=_eaeb -_cgeef +_gaaa .TextRise -_gaaa .UnderlineStyle .Offset ;_ecec =append (_ecec ,&_ee .BasicLine {X1 :_badf ,Y1 :_bbbee ,X2 :_badf +_gbbg ,Y2 :_bbbee ,LineWidth :_cege .Style .UnderlineStyle .Thickness ,LineColor :_ca .NewPdfColorDeviceRGB (_cbad ,_bade ,_gfcd )});
};if _cege ._cgbd !=nil {var _geefc *_bc .PdfObjectArray ;if !_cege ._baacc {switch _bffb :=_cege ._cgbd .GetContext ().(type ){case *_ca .PdfAnnotationLink :_geefc =_bc .MakeArray ();_bffb .Rect =_geefc ;_adfaa ,_abbca :=_bffb .Dest .(*_bc .PdfObjectArray );
if _abbca &&_adfaa .Len ()==5{_bfcc ,_aaag :=_adfaa .Get (1).(*_bc .PdfObjectName );if _aaag &&_bfcc .String ()=="\u0058\u0059\u005a"{_effd ,_cefb :=_bc .GetNumberAsFloat (_adfaa .Get (3));if _cefb ==nil {_adfaa .Set (3,_bc .MakeFloat (_bedc .PageHeight -_effd ));
};};};};_cege ._baacc =true ;};if _geefc !=nil {_fecg :=_ee .NewPoint (_gdgc -_bedc .X ,_eaeb +_gaaa .TextRise -_cgeef ).Rotate (_aeeb ._bffda );_fecg .X +=_bedc .X ;_fecg .Y +=_cgeef ;_cafddd ,_gdebc ,_gbca ,_bbfg :=_dgfg (_gbbg ,_eeced ,_aeeb ._bffda );
_fecg .X +=_cafddd ;_fecg .Y +=_gdebc ;_geefc .Clear ();_geefc .Append (_bc .MakeFloat (_fecg .X ));_geefc .Append (_bc .MakeFloat (_fecg .Y ));_geefc .Append (_bc .MakeFloat (_fecg .X +_gbca ));_geefc .Append (_bc .MakeFloat (_fecg .Y +_bbfg ));};_agbc .AddAnnotation (_cege ._cgbd );
};_gdgc +=_gbbg ;if _abcc {_fded .Add_w (1.0);};if _cfbgd {_fded .Add_RG (0.0,0.0,0.0);};if _bdff {_fded .Add_Tr (int64 (TextRenderingModeFill ));};if _fdgcc {_fded .Add_Tc (0);};if _ceafc {_fded .Add_Ts (0);};if _bgbe {_fded .Add_Tz (DefaultHorizontalScaling );
};};};_fded .Add_ET ();for _ ,_dffc :=range _ecec {_fded .SetStrokingColor (_dffc .LineColor ).Add_w (_dffc .LineWidth ).Add_m (_dffc .X1 ,_dffc .Y1 ).Add_l (_dffc .X2 ,_dffc .Y2 ).Add_s ();};_fded .Add_Q ();_beega :=_fded .Operations ();_beega .WrapIfNeeded ();
_agbc .addContents (_beega );if _egebc {_ccbd :=_fcgaf ;_bedc .Y +=_ccbd ;_bedc .Height -=_ccbd ;if _bedc .Inline {_bedc .X +=_aeeb .Width ()+_aeeb ._dfcc .Right ;};};return _bedc ,_bcbf ,nil ;};

// TextAlignment options for paragraph.
type TextAlignment int ;func (_abeg *Block )drawToPage (_aa *_ca .PdfPage )error {_dfd :=&_acc .ContentStreamOperations {};if _aa .Resources ==nil {_aa .Resources =_ca .NewPdfPageResources ();};_dad :=_dg (_dfd ,_aa .Resources ,_abeg ._gg ,_abeg ._eee );
if _dad !=nil {return _dad ;};if _dad =_cega (_abeg ._eee ,_aa .Resources );_dad !=nil {return _dad ;};if _dad =_aa .AppendContentBytes (_dfd .Bytes (),true );_dad !=nil {return _dad ;};for _ ,_eeb :=range _abeg ._ab {_aa .AddAnnotation (_eeb );};return nil ;
};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_dcdd *List )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var _fbed float64 ;var _eefd []*StyledParagraph ;for _ ,_abcd :=range _dcdd ._dfcd {_afcd :=_fedb (_dcdd ._ddaaa );_afcd .SetEnableWrap (false );_afcd .SetTextAlignment (TextAlignmentRight );
_afcd .Append (_abcd ._dgadc .Text ).Style =_abcd ._dgadc .Style ;_dcaab :=_afcd .getTextWidth ()/1000.0/ctx .Width ;if _fbed < _dcaab {_fbed =_dcaab ;};_eefd =append (_eefd ,_afcd );};_aeff :=_aaaeg (2);_aeff .SetColumnWidths (_fbed ,1-_fbed );_aeff .SetMargins (_dcdd ._abgd ,0,0,0);
for _cagf ,_cecd :=range _dcdd ._dfcd {_cfdgf :=_aeff .NewCell ();_cfdgf .SetIndent (0);_cfdgf .SetContent (_eefd [_cagf ]);_cfdgf =_aeff .NewCell ();_cfdgf .SetIndent (0);_cfdgf .SetContent (_cecd ._fgdd );};return _aeff .GeneratePageBlocks (ctx );};func (_fge cmykColor )ToRGB ()(float64 ,float64 ,float64 ){_gbd :=_fge ._eece ;
return 1-(_fge ._eedg *(1-_gbd )+_gbd ),1-(_fge ._ggbfb *(1-_gbd )+_gbd ),1-(_fge ._gaeb *(1-_gbd )+_gbd );};

// Height returns Image's document height.
func (_bbadd *Image )Height ()float64 {return _bbadd ._ffgf };func (_dgad *Invoice )drawAddress (_geba *InvoiceAddress )[]*StyledParagraph {var _daaec []*StyledParagraph ;if _geba .Heading !=""{_degf :=_fedb (_dgad ._fabd );_degf .SetMargins (0,0,0,7);
_degf .Append (_geba .Heading );_daaec =append (_daaec ,_degf );};_cdab :=_fedb (_dgad ._affe );_cdab .SetLineHeight (1.2);_fafg :=_geba .Separator ;if _fafg ==""{_fafg =_dgad ._aaaed ;};_ddce :=_geba .City ;if _geba .State !=""{if _ddce !=""{_ddce +=_fafg ;
};_ddce +=_geba .State ;};if _geba .Zip !=""{if _ddce !=""{_ddce +=_fafg ;};_ddce +=_geba .Zip ;};if _geba .Name !=""{_cdab .Append (_geba .Name +"\u000a");};if _geba .Street !=""{_cdab .Append (_geba .Street +"\u000a");};if _geba .Street2 !=""{_cdab .Append (_geba .Street2 +"\u000a");
};if _ddce !=""{_cdab .Append (_ddce +"\u000a");};if _geba .Country !=""{_cdab .Append (_geba .Country +"\u000a");};_gcdf :=_fedb (_dgad ._affe );_gcdf .SetLineHeight (1.2);_gcdf .SetMargins (0,0,7,0);if _geba .Phone !=""{_gcdf .Append (_geba .fmtLine (_geba .Phone ,"\u0050h\u006f\u006e\u0065\u003a\u0020",_geba .HidePhoneLabel ));
};if _geba .Email !=""{_gcdf .Append (_geba .fmtLine (_geba .Email ,"\u0045m\u0061\u0069\u006c\u003a\u0020",_geba .HideEmailLabel ));};_daaec =append (_daaec ,_cdab ,_gcdf );return _daaec ;};

// StyledParagraph represents text drawn with a specified font and can wrap across lines and pages.
// By default occupies the available width in the drawing context.
type StyledParagraph struct{_gagd []*TextChunk ;_accc TextStyle ;_ffdf TextStyle ;_ecdg TextAlignment ;_aaac TextVerticalAlignment ;_bcfdf float64 ;_debf bool ;_ggcc float64 ;_gddfe bool ;_cbcc bool ;_gace TextOverflow ;_bffda float64 ;_dfcc Margins ;_dead Positioning ;
_bfdc float64 ;_gffa float64 ;_deaacc float64 ;_aaaaa float64 ;_bcdd [][]*TextChunk ;_efeab func (_aagbc *StyledParagraph ,_ffcaf DrawContext );};

// SetHorizontalAlignment sets the horizontal alignment of the image.
func (_abace *Image )SetHorizontalAlignment (alignment HorizontalAlignment ){_abace ._aadc =alignment };func (_ggfd *Invoice )generateHeaderBlocks (_dede DrawContext )([]*Block ,DrawContext ,error ){_dfbb :=_fedb (_ggfd ._ageb );_dfbb .SetEnableWrap (true );
_dfbb .Append (_ggfd ._dacff );_gecc :=_aaaeg (2);if _ggfd ._cafd !=nil {_fgbb :=_gecc .NewCell ();_fgbb .SetHorizontalAlignment (CellHorizontalAlignmentLeft );_fgbb .SetVerticalAlignment (CellVerticalAlignmentMiddle );_fgbb .SetIndent (0);_fgbb .SetContent (_ggfd ._cafd );
_ggfd ._cafd .ScaleToHeight (_dfbb .Height ()+20);}else {_gecc .SkipCells (1);};_gcdd :=_gecc .NewCell ();_gcdd .SetHorizontalAlignment (CellHorizontalAlignmentRight );_gcdd .SetVerticalAlignment (CellVerticalAlignmentMiddle );_gcdd .SetContent (_dfbb );
return _gecc .GeneratePageBlocks (_dede );};func _eabb (_baba *_ca .Image )(*Image ,error ){_gaeba :=float64 (_baba .Width );_daae :=float64 (_baba .Height );return &Image {_bbeg :_baba ,_ggbag :_gaeba ,_cfaea :_daae ,_dddg :_gaeba ,_ffgf :_daae ,_fagd :0,_gede :1.0,_fbga :PositionRelative },nil ;
};

// SetWidth sets line width.
func (_bge *Curve )SetWidth (width float64 ){_bge ._bcdb =width };

// RotateDeg rotates the current active page by angle degrees.  An error is returned on failure,
// which can be if there is no currently active page, or the angleDeg is not a multiple of 90 degrees.
func (_fccd *Creator )RotateDeg (angleDeg int64 )error {_adb :=_fccd .getActivePage ();if _adb ==nil {_db .Log .Debug ("F\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0065\u003a\u0020\u006e\u006f\u0020p\u0061\u0067\u0065\u0020\u0063\u0075\u0072\u0072\u0065\u006etl\u0079\u0020\u0061c\u0074i\u0076\u0065");
return _c .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};if angleDeg %90!=0{_db .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0050\u0061\u0067e\u0020\u0072\u006f\u0074\u0061\u0074\u0069on\u0020\u0061\u006e\u0067l\u0065\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006dul\u0074\u0069p\u006c\u0065\u0020\u006f\u0066\u0020\u0039\u0030");
return _c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};var _gece int64 ;if _adb .Rotate !=nil {_gece =*(_adb .Rotate );};_gece +=angleDeg ;_adb .Rotate =&_gece ;return nil ;};

// InvoiceCellProps holds all style properties for an invoice cell.
type InvoiceCellProps struct{TextStyle TextStyle ;Alignment CellHorizontalAlignment ;BackgroundColor Color ;BorderColor Color ;BorderWidth float64 ;BorderSides []CellBorderSide ;};

// Heading returns the heading component of the table of contents.
func (_cegg *TOC )Heading ()*StyledParagraph {return _cegg ._ebcb };

// CurvePolygon represents a curve polygon shape.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type CurvePolygon struct{_fdbbd *_ee .CurvePolygon ;_cad float64 ;_bbfb float64 ;};

// SetBorderColor sets the border color for the path.
func (_gdea *FilledCurve )SetBorderColor (color Color ){_gdea ._gbdc =color };

// AddressStyle returns the style properties used to render the content of
// the invoice address sections.
func (_ccad *Invoice )AddressStyle ()TextStyle {return _ccad ._affe };

// GeneratePageBlocks draws the rectangle on a new block representing the page.
func (_bccg *Ellipse )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_ggab :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_edfe :=_ee .Circle {X :_bccg ._aed -_bccg ._bdge /2,Y :ctx .PageHeight -_bccg ._gefa -_bccg ._efaa /2,Width :_bccg ._bdge ,Height :_bccg ._efaa ,Opacity :1.0,BorderWidth :_bccg ._afdfg };
if _bccg ._bdce ==PositionRelative {_edfe .X =ctx .X ;_edfe .Y =ctx .PageHeight -ctx .Y -_bccg ._efaa ;};if _bccg ._cacc !=nil {_edfe .FillEnabled =true ;_edfe .FillColor =_geg (_bccg ._cacc );};if _bccg ._gbgf !=nil {_edfe .BorderEnabled =false ;if _bccg ._afdfg > 0{_edfe .BorderEnabled =true ;
};_edfe .BorderColor =_geg (_bccg ._gbgf );_edfe .BorderWidth =_bccg ._afdfg ;};_defg ,_ ,_adedd :=_edfe .Draw ("");if _adedd !=nil {return nil ,ctx ,_adedd ;};_adedd =_ggab .addContentsByString (string (_defg ));if _adedd !=nil {return nil ,ctx ,_adedd ;
};return []*Block {_ggab },ctx ,nil ;};

// EnableRowWrap controls whether rows are wrapped across pages.
// NOTE: Currently, row wrapping is supported for rows using StyledParagraphs.
func (_ffgc *Table )EnableRowWrap (enable bool ){_ffgc ._cbbca =enable };func _ffac (_abbc VectorDrawable ,_afdff float64 )float64 {switch _dfecd :=_abbc .(type ){case *Paragraph :if _dfecd ._cece {_dfecd .SetWidth (_afdff -_dfecd ._cbcfd .Left -_dfecd ._cbcfd .Right );
};return _dfecd .Height ()+_dfecd ._cbcfd .Top +_dfecd ._cbcfd .Bottom ;case *StyledParagraph :if _dfecd ._debf {_dfecd .SetWidth (_afdff -_dfecd ._dfcc .Left -_dfecd ._dfcc .Right );};return _dfecd .Height ()+_dfecd ._dfcc .Top +_dfecd ._dfcc .Bottom ;
case *Image :_dfecd .applyFitMode (_afdff );return _dfecd .Height ()+_dfecd ._ebea .Top +_dfecd ._ebea .Bottom ;case marginDrawable :_ ,_ ,_dgg ,_adba :=_dfecd .GetMargins ();return _dfecd .Height ()+_dgg +_adba ;default:return _dfecd .Height ();};};

// IsAbsolute checks if the positioning is absolute.
func (_fef Positioning )IsAbsolute ()bool {return _fef ==PositionAbsolute };

// NewTOCLine creates a new table of contents line with the default style.
func (_dga *Creator )NewTOCLine (number ,title ,page string ,level uint )*TOCLine {return _ccbcb (number ,title ,page ,level ,_dga .NewTextStyle ());};

// SetFillColor sets the fill color.
func (_cfbg *PolyBezierCurve )SetFillColor (color Color ){_cfbg ._gggb .FillColor =_geg (color )};

// MoveTo moves the drawing context to absolute coordinates (x, y).
func (_eded *Creator )MoveTo (x ,y float64 ){_eded ._bgfa .X =x ;_eded ._bgfa .Y =y };func (_feedd *Table )wrapRow (_fead int ,_dfga DrawContext ,_fbde float64 )(bool ,error ){if !_feedd ._cbbca {return false ,nil ;};var (_cbfd =_feedd ._deag [_fead ];
_eacb =-1;_bdafc []*TableCell ;_efdac float64 ;_gabgf bool ;_bgdca =make ([]float64 ,0,len (_feedd ._dabge )););_bcgf :=func (_daede *TableCell ,_ggcb VectorDrawable ,_aaafc bool )*TableCell {_agab :=*_daede ;_agab ._ebgg =_ggcb ;if _aaafc {_agab ._bcbfb ++;
};return &_agab ;};_cace :=func (_gffag int ,_dabbg VectorDrawable ){var _eeceb float64 =-1;if _dabbg ==nil {if _ddaf :=_bgdca [_gffag -_fead ];_ddaf > _dfga .Height {_dabbg =_feedd ._deag [_gffag ]._ebgg ;_feedd ._deag [_gffag ]._ebgg =nil ;_bgdca [_gffag -_fead ]=0;
_eeceb =_ddaf ;};};_ceff :=_bcgf (_feedd ._deag [_gffag ],_dabbg ,true );_bdafc =append (_bdafc ,_ceff );if _eeceb < 0{_eeceb =_ceff .height (_dfga .Width );};if _eeceb > _efdac {_efdac =_eeceb ;};};for _gdaea :=_fead ;_gdaea < len (_feedd ._deag );_gdaea ++{_bedbd :=_feedd ._deag [_gdaea ];
if _cbfd ._bcbfb !=_bedbd ._bcbfb {_eacb =_gdaea ;break ;};_dfga .Width =_bedbd .width (_feedd ._dabge ,_fbde );var _ebbad VectorDrawable ;switch _fddg :=_bedbd ._ebgg .(type ){case *StyledParagraph :if _bggb :=_bedbd .height (_dfga .Width );_bggb > _dfga .Height {_ceced :=_dfga ;
_ceced .Height =_cb .Floor (_dfga .Height -_fddg ._dfcc .Top -_fddg ._dfcc .Bottom -0.5*_fddg .getTextHeight ());_bffdaf ,_gdbd ,_fgaa :=_fddg .split (_ceced );if _fgaa !=nil {return false ,_fgaa ;};if _bffdaf !=nil &&_gdbd !=nil {_fddg =_bffdaf ;_bedbd =_bcgf (_bedbd ,_bffdaf ,false );
_feedd ._deag [_gdaea ]=_bedbd ;_ebbad =_gdbd ;_gabgf =true ;};};case *Division :if _cfgg :=_bedbd .height (_dfga .Width );_cfgg > _dfga .Height {_eaggb :=_dfga ;_eaggb .Height =_cb .Floor (_dfga .Height -_fddg ._fdea .Top -_fddg ._fdea .Bottom );_aefb ,_bag :=_fddg .split (_eaggb );
if _aefb !=nil &&_bag !=nil {_fddg =_aefb ;_bedbd =_bcgf (_bedbd ,_aefb ,false );_feedd ._deag [_gdaea ]=_bedbd ;_ebbad =_bag ;_gabgf =true ;if _aefb ._eebc !=nil {_aefb ._eebc .BorderRadiusBottomLeft =0;_aefb ._eebc .BorderRadiusBottomRight =0;};if _bag ._eebc !=nil {_bag ._eebc .BorderRadiusTopLeft =0;
_bag ._eebc .BorderRadiusTopRight =0;};};};};_bgdca =append (_bgdca ,_bedbd .height (_dfga .Width ));if _gabgf {if _bdafc ==nil {_bdafc =make ([]*TableCell ,0,len (_feedd ._dabge ));for _febff :=_fead ;_febff < _gdaea ;_febff ++{_cace (_febff ,nil );};
};_cace (_gdaea ,_ebbad );};};var _bcfac float64 ;for _ ,_dcbbd :=range _bgdca {if _dcbbd > _bcfac {_bcfac =_dcbbd ;};};if _gabgf &&_bcfac < _dfga .Height {if _eacb < 0{_eacb =len (_feedd ._deag );};_gcdg :=_feedd ._deag [_eacb -1]._bcbfb +_feedd ._deag [_eacb -1]._abdf -1;
for _fedbc :=_eacb ;_fedbc < len (_feedd ._deag );_fedbc ++{_feedd ._deag [_fedbc ]._bcbfb ++;};_feedd ._deag =append (_feedd ._deag [:_eacb ],append (_bdafc ,_feedd ._deag [_eacb :]...)...);_feedd ._accdf =append (_feedd ._accdf [:_gcdg ],append ([]float64 {_efdac },_feedd ._accdf [_gcdg :]...)...);
_feedd ._accdf [_cbfd ._bcbfb +_cbfd ._abdf -2]=_bcfac ;};return _gabgf ,nil ;};

// Height returns the Block's height.
func (_afe *Block )Height ()float64 {return _afe ._cac };

// SetLineLevelOffset sets the amount of space an indentation level occupies
// for all new lines of the table of contents.
func (_degd *TOC )SetLineLevelOffset (levelOffset float64 ){_degd ._febe =levelOffset };

// GeneratePageBlocks draws the filled curve on page blocks.
func (_deaac *FilledCurve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_aged :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_fgdg ,_ ,_bfaed :=_deaac .draw ("");if _bfaed !=nil {return nil ,ctx ,_bfaed ;};_bfaed =_aged .addContentsByString (string (_fgdg ));
if _bfaed !=nil {return nil ,ctx ,_bfaed ;};return []*Block {_aged },ctx ,nil ;};

// SetAngle sets Image rotation angle in degrees.
func (_ebd *Image )SetAngle (angle float64 ){_ebd ._fagd =angle };

// GetCoords returns coordinates of the Rectangle's upper left corner (x,y).
func (_adggcc *Rectangle )GetCoords ()(float64 ,float64 ){return _adggcc ._fec ,_adggcc ._dgeg };

// SetMargins sets the margins TOC line.
func (_gdee *TOCLine )SetMargins (left ,right ,top ,bottom float64 ){_gdee ._ebfc =left ;_cdfe :=&_gdee ._ddca ._dfcc ;_cdfe .Left =_gdee ._ebfc +float64 (_gdee ._dcae -1)*_gdee ._cggdd ;_cdfe .Right =right ;_cdfe .Top =top ;_cdfe .Bottom =bottom ;};

// NewChart creates a new creator drawable based on the provided
// unichart chart component.
func NewChart (chart _g .ChartRenderable )*Chart {return _caea (chart )};

// GeneratePageBlocks draws the chart onto a block.
func (_aebe *Chart )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bbfe :=ctx ;_deb :=_aebe ._ffd .IsRelative ();var _efd []*Block ;if _deb {_bcedg :=1.0;_dcgb :=_aebe ._cfbc .Top ;if float64 (_aebe ._fdc .Height ())> ctx .Height -_aebe ._cfbc .Top {_efd =[]*Block {NewBlock (ctx .PageWidth ,ctx .PageHeight -ctx .Y )};
var _gff error ;if _ ,ctx ,_gff =_geag ().GeneratePageBlocks (ctx );_gff !=nil {return nil ,ctx ,_gff ;};_dcgb =0;};ctx .X +=_aebe ._cfbc .Left +_bcedg ;ctx .Y +=_dcgb ;ctx .Width -=_aebe ._cfbc .Left +_aebe ._cfbc .Right +2*_bcedg ;ctx .Height -=_dcgb ;
_aebe ._fdc .SetWidth (int (ctx .Width ));}else {ctx .X =_aebe ._cceg ;ctx .Y =_aebe ._daa ;};_dff :=_acc .NewContentCreator ();_dff .Translate (0,ctx .PageHeight );_dff .Scale (1,-1);_dff .Translate (ctx .X ,ctx .Y );_fce :=NewBlock (ctx .PageWidth ,ctx .PageHeight );
_aebe ._fdc .Render (_fe .NewRenderer (_dff ,_fce ._eee ),nil );if _bebf :=_fce .addContentsByString (_dff .String ());_bebf !=nil {return nil ,ctx ,_bebf ;};if _deb {_bde :=_aebe .Height ()+_aebe ._cfbc .Bottom ;ctx .Y +=_bde ;ctx .Height -=_bde ;}else {ctx =_bbfe ;
};_efd =append (_efd ,_fce );return _efd ,ctx ,nil ;};func _fegd (_cccb *Block ,_cagb *Image ,_ffcf DrawContext )(DrawContext ,error ){_bbdd :=_ffcf ;_adafd :=1;_ffad :=_bc .PdfObjectName (_cba .Sprintf ("\u0049\u006d\u0067%\u0064",_adafd ));for _cccb ._eee .HasXObjectByName (_ffad ){_adafd ++;
_ffad =_bc .PdfObjectName (_cba .Sprintf ("\u0049\u006d\u0067%\u0064",_adafd ));};_addf :=_cccb ._eee .SetXObjectImageByName (_ffad ,_cagb ._bea );if _addf !=nil {return _ffcf ,_addf ;};_agea :=0;_dfb :=_bc .PdfObjectName (_cba .Sprintf ("\u0047\u0053\u0025\u0064",_agea ));
for _cccb ._eee .HasExtGState (_dfb ){_agea ++;_dfb =_bc .PdfObjectName (_cba .Sprintf ("\u0047\u0053\u0025\u0064",_agea ));};_aefc :=_bc .MakeDict ();_aefc .Set ("\u0042\u004d",_bc .MakeName ("\u004e\u006f\u0072\u006d\u0061\u006c"));if _cagb ._gede < 1.0{_aefc .Set ("\u0043\u0041",_bc .MakeFloat (_cagb ._gede ));
_aefc .Set ("\u0063\u0061",_bc .MakeFloat (_cagb ._gede ));};_addf =_cccb ._eee .AddExtGState (_dfb ,_bc .MakeIndirectObject (_aefc ));if _addf !=nil {return _ffcf ,_addf ;};_cgegb :=_cagb .Width ();_eagd :=_cagb .Height ();_ ,_fcef :=_cagb .rotatedSize ();
_bfdef :=_ffcf .X ;_aagg :=_ffcf .PageHeight -_ffcf .Y -_eagd ;if _cagb ._fbga .IsRelative (){_aagg -=(_fcef -_eagd )/2;switch _cagb ._aadc {case HorizontalAlignmentCenter :_bfdef +=(_ffcf .Width -_cgegb )/2;case HorizontalAlignmentRight :_bfdef =_ffcf .PageWidth -_ffcf .Margins .Right -_cagb ._ebea .Right -_cgegb ;
};};_fad :=_cagb ._fagd ;_cbgcg :=_acc .NewContentCreator ();_cbgcg .Add_gs (_dfb );_cbgcg .Translate (_bfdef ,_aagg );if _fad !=0{_cbgcg .Translate (_cgegb /2,_eagd /2);_cbgcg .RotateDeg (_fad );_cbgcg .Translate (-_cgegb /2,-_eagd /2);};_cbgcg .Scale (_cgegb ,_eagd ).Add_Do (_ffad );
_ddge :=_cbgcg .Operations ();_ddge .WrapIfNeeded ();_cccb .addContents (_ddge );if _cagb ._fbga .IsRelative (){_ffcf .Y +=_fcef ;_ffcf .Height -=_fcef ;return _ffcf ,nil ;};return _bbdd ,nil ;};

// CurRow returns the currently active cell's row number.
func (_aecb *Table )CurRow ()int {_daef :=(_aecb ._ccgd -1)/_aecb ._dcff +1;return _daef };

// SetFillColor sets the fill color for the path.
func (_fbgde *FilledCurve )SetFillColor (color Color ){_fbgde ._dfadb =color };

// GetMargins returns the margins of the TOC line: left, right, top, bottom.
func (_ccfg *TOCLine )GetMargins ()(float64 ,float64 ,float64 ,float64 ){_bfee :=&_ccfg ._ddca ._dfcc ;return _ccfg ._ebfc ,_bfee .Right ,_bfee .Top ,_bfee .Bottom ;};

// AddTextItem appends a new item with the specified text to the list.
// The method creates a styled paragraph with the specified text and returns
// it so that the item style can be customized.
// The method also returns the marker used for the newly added item.
// The marker object can be used to change the text and style of the marker
// for the current item.
func (_dfaf *List )AddTextItem (text string )(*StyledParagraph ,*TextChunk ,error ){_bbbe :=_fedb (_dfaf ._ddaaa );_bbbe .Append (text );_ggdc ,_eedc :=_dfaf .Add (_bbbe );return _bbbe ,_ggdc ,_eedc ;};

// AddLine appends a new line to the invoice line items table.
func (_cdadb *Invoice )AddLine (values ...string )[]*InvoiceCell {_cdbg :=len (_cdadb ._bfda );var _gbgg []*InvoiceCell ;for _eebe ,_edccg :=range values {_aeae :=_cdadb .newCell (_edccg ,_cdadb ._aede );if _eebe < _cdbg {_aeae .Alignment =_cdadb ._bfda [_eebe ].Alignment ;
};_gbgg =append (_gbgg ,_aeae );};_cdadb ._ecff =append (_cdadb ._ecff ,_gbgg );return _gbgg ;};

// NewCell returns a new invoice table cell.
func (_aaaea *Invoice )NewCell (value string )*InvoiceCell {return _aaaea .newCell (value ,_aaaea .NewCellProps ());};

// SetText sets the text content of the Paragraph.
func (_affag *Paragraph )SetText (text string ){_affag ._aafb =text };

// SetColorLeft sets border color for left.
func (_afb *border )SetColorLeft (col Color ){_afb ._ceb =col };

// The Image type is used to draw an image onto PDF.
type Image struct{_bea *_ca .XObjectImage ;_bbeg *_ca .Image ;_fagd float64 ;_dddg ,_ffgf float64 ;_ggbag ,_cfaea float64 ;_fbga Positioning ;_aadc HorizontalAlignment ;_fcbd float64 ;_fffb float64 ;_gede float64 ;_ebea Margins ;_dgbc ,_abacf float64 ;
_fgggb _bc .StreamEncoder ;_cdcd FitMode ;};

// Width is not used. The list component is designed to fill into the available
// width depending on the context. Returns 0.
func (_eeda *List )Width ()float64 {return 0};

// Ellipse defines an ellipse with a center at (xc,yc) and a specified width and height.  The ellipse can have a colored
// fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Ellipse struct{_aed float64 ;_gefa float64 ;_bdge float64 ;_efaa float64 ;_bdce Positioning ;_cacc Color ;_gbgf Color ;_afdfg float64 ;};

// Inline returns whether the inline mode of the division is active.
func (_gcfe *Division )Inline ()bool {return _gcfe ._aaca };

// TOCLine represents a line in a table of contents.
// The component can be used both in the context of a
// table of contents component and as a standalone component.
// The representation of a table of contents line is as follows:
//       [number] [title]      [separator] [page]
// e.g.: Chapter1 Introduction ........... 1
type TOCLine struct{_ddca *StyledParagraph ;

// Holds the text and style of the number part of the TOC line.
Number TextChunk ;

// Holds the text and style of the title part of the TOC line.
Title TextChunk ;

// Holds the text and style of the separator part of the TOC line.
Separator TextChunk ;

// Holds the text and style of the page part of the TOC line.
Page TextChunk ;_ebfc float64 ;_dcae uint ;_cggdd float64 ;_bceda Positioning ;_fcbef float64 ;_ffgca float64 ;_cgge int64 ;};func _agbff (_ggba ,_feef ,_edbf ,_afbd ,_dcdb ,_ebag float64 )*Curve {_dbdb :=&Curve {};_dbdb ._fdbb =_ggba ;_dbdb ._fefc =_feef ;
_dbdb ._gaebg =_edbf ;_dbdb ._gef =_afbd ;_dbdb ._cegba =_dcdb ;_dbdb ._gfce =_ebag ;_dbdb ._feefb =ColorBlack ;_dbdb ._bcdb =1.0;return _dbdb ;};func (_dege *Creator )setActivePage (_fdee *_ca .PdfPage ){_dege ._dfde =_fdee };

// Width is not used as the division component is designed to fill all the
// available space, depending on the context. Returns 0.
func (_geee *Division )Width ()float64 {return 0};

// Drawable is a widget that can be used to draw with the Creator.
type Drawable interface{

// GeneratePageBlocks draw onto blocks representing Page contents. As the content can wrap over many pages, multiple
// templates are returned, one per Page.  The function also takes a draw context containing information
// where to draw (if relative positioning) and the available height to draw on accounting for Margins etc.
GeneratePageBlocks (_fdgaf DrawContext )([]*Block ,DrawContext ,error );};

// SetFitMode sets the fit mode of the image.
// NOTE: The fit mode is only applied if relative positioning is used.
func (_eabda *Image )SetFitMode (fitMode FitMode ){_eabda ._cdcd =fitMode };

// GeneratePageBlocks generates the page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages. Implements the Drawable interface.
func (_edgdc *Paragraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_ggbbg :=ctx ;var _gabga []*Block ;_cabca :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _edgdc ._dacd .IsRelative (){ctx .X +=_edgdc ._cbcfd .Left ;ctx .Y +=_edgdc ._cbcfd .Top ;
ctx .Width -=_edgdc ._cbcfd .Left +_edgdc ._cbcfd .Right ;ctx .Height -=_edgdc ._cbcfd .Top ;_edgdc .SetWidth (ctx .Width );if _edgdc .Height ()> ctx .Height {_gabga =append (_gabga ,_cabca );_cabca =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;
_bafd :=ctx ;_bafd .Y =ctx .Margins .Top ;_bafd .X =ctx .Margins .Left +_edgdc ._cbcfd .Left ;_bafd .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom ;_bafd .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_edgdc ._cbcfd .Left -_edgdc ._cbcfd .Right ;
ctx =_bafd ;};}else {if int (_edgdc ._deda )<=0{_edgdc .SetWidth (_edgdc .getTextWidth ());};ctx .X =_edgdc ._cdfg ;ctx .Y =_edgdc ._egb ;};ctx ,_gdage :=_cfag (_cabca ,_edgdc ,ctx );if _gdage !=nil {_db .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_gdage );
return nil ,ctx ,_gdage ;};_gabga =append (_gabga ,_cabca );if _edgdc ._dacd .IsRelative (){ctx .Y +=_edgdc ._cbcfd .Bottom ;ctx .Height -=_edgdc ._cbcfd .Bottom ;if !ctx .Inline {ctx .X =_ggbbg .X ;ctx .Width =_ggbbg .Width ;};return _gabga ,ctx ,nil ;
};return _gabga ,_ggbbg ,nil ;};

// AppendCurve appends a Bezier curve to the filled curve.
func (_ggbea *FilledCurve )AppendCurve (curve _ee .CubicBezierCurve )*FilledCurve {_ggbea ._eagg =append (_ggbea ._eagg ,curve );return _ggbea ;};func _fdeea (_ddef ,_gfcef ,_cbdb ,_bgad float64 )*Ellipse {_bfc :=&Ellipse {};_bfc ._aed =_ddef ;_bfc ._gefa =_gfcef ;
_bfc ._bdge =_cbdb ;_bfc ._efaa =_bgad ;_bfc ._bdce =PositionAbsolute ;_bfc ._gbgf =ColorBlack ;_bfc ._afdfg =1.0;return _bfc ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_abaca *Invoice )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_faaf :=ctx ;_cbfcg :=[]func (_bfcd DrawContext )([]*Block ,DrawContext ,error ){_abaca .generateHeaderBlocks ,_abaca .generateInformationBlocks ,_abaca .generateLineBlocks ,_abaca .generateTotalBlocks ,_abaca .generateNoteBlocks };
var _abgf []*Block ;for _ ,_cec :=range _cbfcg {_bdbe ,_ccac ,_fgea :=_cec (ctx );if _fgea !=nil {return _abgf ,ctx ,_fgea ;};if len (_abgf )==0{_abgf =_bdbe ;}else if len (_bdbe )> 0{_abgf [len (_abgf )-1].mergeBlocks (_bdbe [0]);_abgf =append (_abgf ,_bdbe [1:]...);
};ctx =_ccac ;};if _abaca ._eaddg .IsRelative (){ctx .X =_faaf .X ;};if _abaca ._eaddg .IsAbsolute (){return _abgf ,_faaf ,nil ;};return _abgf ,ctx ,nil ;};func (_dbf *Block )addContentsByString (_caf string )error {_deg :=_acc .NewContentStreamParser (_caf );
_dbg ,_gga :=_deg .Parse ();if _gga !=nil {return _gga ;};_dbf ._gg .WrapIfNeeded ();_dbg .WrapIfNeeded ();*_dbf ._gg =append (*_dbf ._gg ,*_dbg ...);return nil ;};

// TextOverflow determines the behavior of paragraph text which does
// not fit in the available space.
type TextOverflow int ;

// SetBackgroundColor sets the cell's background color.
func (_gfebb *TableCell )SetBackgroundColor (col Color ){_gfebb ._ccdb =col };

// Logo returns the logo of the invoice.
func (_ffacf *Invoice )Logo ()*Image {return _ffacf ._cafd };func (_cg *Block )translate (_fdg ,_fa float64 ){_ebe :=_acc .NewContentCreator ().Translate (_fdg ,-_fa ).Operations ();*_cg ._gg =append (*_ebe ,*_cg ._gg ...);_cg ._gg .WrapIfNeeded ();};

// Date returns the invoice date description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_daed *Invoice )Date ()(*InvoiceCell ,*InvoiceCell ){return _daed ._geff [0],_daed ._geff [1]};

// SetWidth sets the the Paragraph width. This is essentially the wrapping width,
// i.e. the width the text can extend to prior to wrapping over to next line.
func (_dcce *StyledParagraph )SetWidth (width float64 ){_dcce ._ggcc =width ;_dcce .wrapText ()};

// SetHeight sets the Image's document height to specified h.
func (_ddad *Image )SetHeight (h float64 ){_ddad ._ffgf =h };

// SetSellerAddress sets the seller address of the invoice.
func (_dgdb *Invoice )SetSellerAddress (address *InvoiceAddress ){_dgdb ._bged =address };

// GetMargins returns the Block's margins: left, right, top, bottom.
func (_gcg *Block )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _gcg ._gca .Left ,_gcg ._gca .Right ,_gcg ._gca .Top ,_gcg ._gca .Bottom ;};func _gbea (_eddcd _f .Image )(*Image ,error ){_acef ,_fbff :=_ca .ImageHandling .NewImageFromGoImage (_eddcd );
if _fbff !=nil {return nil ,_fbff ;};return _eabb (_acef );};

// SetWidthRight sets border width for right.
func (_cdf *border )SetWidthRight (bw float64 ){_cdf ._age =bw };func (_gebfa *Invoice )newCell (_aaaa string ,_gfeb InvoiceCellProps )*InvoiceCell {return &InvoiceCell {_gfeb ,_aaaa };};

// GeneratePageBlocks draws the polygon on a new block representing the page.
// Implements the Drawable interface.
func (_geae *Polygon )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fggf :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_ebdg ,_addg :=_fggf .setOpacity (_geae ._cdgfg ,_geae ._debce );if _addg !=nil {return nil ,ctx ,_addg ;};_cagae :=_geae ._ecdf ;
_cagae .FillEnabled =_cagae .FillColor !=nil ;_cagae .BorderEnabled =_cagae .BorderColor !=nil &&_cagae .BorderWidth > 0;_degfe :=_cagae .Points ;for _adbaa :=range _degfe {for _gegg :=range _degfe [_adbaa ]{_bfaef :=&_degfe [_adbaa ][_gegg ];_bfaef .Y =ctx .PageHeight -_bfaef .Y ;
};};_befd ,_ ,_addg :=_cagae .Draw (_ebdg );if _addg !=nil {return nil ,ctx ,_addg ;};if _addg =_fggf .addContentsByString (string (_befd ));_addg !=nil {return nil ,ctx ,_addg ;};return []*Block {_fggf },ctx ,nil ;};const (CellBorderStyleNone CellBorderStyle =iota ;
CellBorderStyleSingle ;CellBorderStyleDouble ;);

// GeneratePageBlocks draws the rectangle on a new block representing the page. Implements the Drawable interface.
func (_fcffg *Rectangle )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_faff :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_ccegc :=_ee .Rectangle {Opacity :1.0,X :_fcffg ._fec ,Y :ctx .PageHeight -_fcffg ._dgeg -_fcffg ._acbf ,Height :_fcffg ._acbf ,Width :_fcffg ._fdbbf ,BorderRadiusTopLeft :_fcffg ._gaddfd ,BorderRadiusTopRight :_fcffg ._gdbeg ,BorderRadiusBottomLeft :_fcffg ._gfbb ,BorderRadiusBottomRight :_fcffg ._cbbbd };
if _fcffg ._dbege ==PositionRelative {_ccegc .X =ctx .X ;_ccegc .Y =ctx .PageHeight -ctx .Y -_fcffg ._acbf ;};if _fcffg ._eadba !=nil {_ccegc .FillEnabled =true ;_ccegc .FillColor =_geg (_fcffg ._eadba );};if _fcffg ._gdad !=nil &&_fcffg ._bbgbf > 0{_ccegc .BorderEnabled =true ;
_ccegc .BorderColor =_geg (_fcffg ._gdad );_ccegc .BorderWidth =_fcffg ._bbgbf ;};_gadgbb ,_cggc :=_faff .setOpacity (_fcffg ._agcg ,_fcffg ._accg );if _cggc !=nil {return nil ,ctx ,_cggc ;};_bcgd ,_ ,_cggc :=_ccegc .Draw (_gadgbb );if _cggc !=nil {return nil ,ctx ,_cggc ;
};if _cggc =_faff .addContentsByString (string (_bcgd ));_cggc !=nil {return nil ,ctx ,_cggc ;};return []*Block {_faff },ctx ,nil ;};const (DefaultHorizontalScaling =100;);

// Positioning represents the positioning type for drawing creator components (relative/absolute).
type Positioning int ;

// GeneratePageBlocks generate the Page blocks.  Multiple blocks are generated if the contents wrap
// over multiple pages.
func (_dbbd *Chapter )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fcag :=ctx ;if _dbbd ._dbec .IsRelative (){ctx .X +=_dbbd ._ebg .Left ;ctx .Y +=_dbbd ._ebg .Top ;ctx .Width -=_dbbd ._ebg .Left +_dbbd ._ebg .Right ;ctx .Height -=_dbbd ._ebg .Top ;
};_dfe ,_edb ,_adfd :=_dbbd ._cbd .GeneratePageBlocks (ctx );if _adfd !=nil {return _dfe ,ctx ,_adfd ;};ctx =_edb ;_acg :=ctx .X ;_gadc :=ctx .Y -_dbbd ._cbd .Height ();_bgc :=int64 (ctx .Page );_dca :=_dbbd .headingNumber ();_gaa :=_dbbd .headingText ();
if _dbbd ._dab {_afcc :=_dbbd ._aafeb .Add (_dca ,_dbbd ._gfb ,_dea .FormatInt (_bgc ,10),_dbbd ._cefe );if _dbbd ._aafeb ._abba {_afcc .SetLink (_bgc ,_acg ,_gadc );};};if _dbbd ._agca ==nil {_dbbd ._agca =_ca .NewOutlineItem (_gaa ,_ca .NewOutlineDest (_bgc -1,_acg ,_gadc ));
if _dbbd ._ebba !=nil {_dbbd ._ebba ._agca .Add (_dbbd ._agca );}else {_dbbd ._aba .Add (_dbbd ._agca );};}else {_egee :=&_dbbd ._agca .Dest ;_egee .Page =_bgc -1;_egee .X =_acg ;_egee .Y =_gadc ;};for _ ,_dcbe :=range _dbbd ._cge {_aabd ,_cceb ,_cggf :=_dcbe .GeneratePageBlocks (ctx );
if _cggf !=nil {return _dfe ,ctx ,_cggf ;};if len (_aabd )< 1{continue ;};_dfe [len (_dfe )-1].mergeBlocks (_aabd [0]);_dfe =append (_dfe ,_aabd [1:]...);ctx =_cceb ;};if _dbbd ._dbec .IsRelative (){ctx .X =_fcag .X ;};if _dbbd ._dbec .IsAbsolute (){return _dfe ,_fcag ,nil ;
};return _dfe ,ctx ,nil ;};

// GeneratePageBlocks draws the polyline on a new block representing the page.
// Implements the Drawable interface.
func (_bbcb *Polyline )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_aeffg :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_afbb ,_aabf :=_aeffg .setOpacity (_bbcb ._faae ,_bbcb ._faae );if _aabf !=nil {return nil ,ctx ,_aabf ;};_dbdef :=_bbcb ._abfdb .Points ;
for _eafg :=range _dbdef {_gaff :=&_dbdef [_eafg ];_gaff .Y =ctx .PageHeight -_gaff .Y ;};_ddcg ,_ ,_aabf :=_bbcb ._abfdb .Draw (_afbb );if _aabf !=nil {return nil ,ctx ,_aabf ;};if _aabf =_aeffg .addContentsByString (string (_ddcg ));_aabf !=nil {return nil ,ctx ,_aabf ;
};return []*Block {_aeffg },ctx ,nil ;};

// NewDivision returns a new Division container component.
func (_bbgd *Creator )NewDivision ()*Division {return _eedd ()};

// SetBuyerAddress sets the buyer address of the invoice.
func (_gbagb *Invoice )SetBuyerAddress (address *InvoiceAddress ){_gbagb ._cded =address };

// TOC returns the table of contents component of the creator.
func (_dcead *Creator )TOC ()*TOC {return _dcead ._dadcd };

// SetColorTop sets border color for top.
func (_dbd *border )SetColorTop (col Color ){_dbd ._egg =col };

// SetEnableWrap sets the line wrapping enabled flag.
func (_fbgc *StyledParagraph )SetEnableWrap (enableWrap bool ){_fbgc ._debf =enableWrap ;_fbgc ._cbcc =false ;};

// SetPos sets absolute positioning with specified coordinates.
func (_gbfg *Paragraph )SetPos (x ,y float64 ){_gbfg ._dacd =PositionAbsolute ;_gbfg ._cdfg =x ;_gbfg ._egb =y ;};

// SetEnableWrap sets the line wrapping enabled flag.
func (_gddcf *Paragraph )SetEnableWrap (enableWrap bool ){_gddcf ._cece =enableWrap ;_gddcf ._ggdaf =false ;};

// SetFillColor sets the fill color.
func (_eefb *Polygon )SetFillColor (color Color ){_eefb ._ecdf .FillColor =_geg (color )};

// SetLineWidth sets the line width.
func (_ccaf *Polyline )SetLineWidth (lineWidth float64 ){_ccaf ._abfdb .LineWidth =lineWidth };func (_gdbe *Invoice )generateLineBlocks (_acgfd DrawContext )([]*Block ,DrawContext ,error ){_bdec :=_aaaeg (len (_gdbe ._bfda ));_bdec .SetMargins (0,0,25,0);
for _ ,_gagfg :=range _gdbe ._bfda {_efff :=_fedb (_gagfg .TextStyle );_efff .SetMargins (0,0,1,0);_efff .Append (_gagfg .Value );_bgcd :=_bdec .NewCell ();_bgcd .SetHorizontalAlignment (_gagfg .Alignment );_bgcd .SetBackgroundColor (_gagfg .BackgroundColor );
_gdbe .setCellBorder (_bgcd ,_gagfg );_bgcd .SetContent (_efff );};for _ ,_dbaf :=range _gdbe ._ecff {for _ ,_gdde :=range _dbaf {_ebgc :=_fedb (_gdde .TextStyle );_ebgc .SetMargins (0,0,3,2);_ebgc .Append (_gdde .Value );_efec :=_bdec .NewCell ();_efec .SetHorizontalAlignment (_gdde .Alignment );
_efec .SetBackgroundColor (_gdde .BackgroundColor );_gdbe .setCellBorder (_efec ,_gdde );_efec .SetContent (_ebgc );};};return _bdec .GeneratePageBlocks (_acgfd );};

// Context returns the current drawing context.
func (_afg *Creator )Context ()DrawContext {return _afg ._bgfa };

// TextVerticalAlignment controls the vertical position of the text
// in a styled paragraph.
type TextVerticalAlignment int ;

// Width returns the width of the Paragraph.
func (_fbdf *StyledParagraph )Width ()float64 {if _fbdf ._debf &&int (_fbdf ._ggcc )> 0{return _fbdf ._ggcc ;};return _fbdf .getTextWidth ()/1000.0;};type cmykColor struct{_eedg ,_ggbfb ,_gaeb ,_eece float64 };

// CellBorderStyle defines the table cell's border style.
type CellBorderStyle int ;

// SetColumns overwrites any columns in the line items table. This should be
// called before AddLine.
func (_eagbf *Invoice )SetColumns (cols []*InvoiceCell ){_eagbf ._bfda =cols };

// SetPdfWriterAccessFunc sets a PdfWriter access function/hook.
// Exposes the PdfWriter just prior to writing the PDF.  Can be used to encrypt the output PDF, etc.
//
// Example of encrypting with a user/owner password "password"
// Prior to calling c.WriteFile():
//
// c.SetPdfWriterAccessFunc(func(w *model.PdfWriter) error {
//	userPass := []byte("password")
//	ownerPass := []byte("password")
//	err := w.Encrypt(userPass, ownerPass, nil)
//	return err
// })
//
func (_aggd *Creator )SetPdfWriterAccessFunc (pdfWriterAccessFunc func (_faaa *_ca .PdfWriter )error ){_aggd ._ccc =pdfWriterAccessFunc ;};func _fbgaa (_cgfg *_ca .PdfFont )TextStyle {return TextStyle {Color :ColorRGBFrom8bit (0,0,0),Font :_cgfg ,FontSize :10,OutlineSize :1,HorizontalScaling :DefaultHorizontalScaling ,UnderlineStyle :TextDecorationLineStyle {Offset :1,Thickness :1}};
};

// AddPage adds the specified page to the creator.
// NOTE: If the page has a Rotate flag, the creator will take care of
// transforming the contents to maintain the correct orientation.
func (_aga *Creator )AddPage (page *_ca .PdfPage )error {_fbeg ,_dbff :=page .GetMediaBox ();if _dbff !=nil {_db .Log .Debug ("\u0046\u0061\u0069l\u0065\u0064\u0020\u0074o\u0020\u0067\u0065\u0074\u0020\u0070\u0061g\u0065\u0020\u006d\u0065\u0064\u0069\u0061\u0062\u006f\u0078\u003a\u0020\u0025\u0076",_dbff );
return _dbff ;};_fbeg .Normalize ();_agaf ,_fgef :=_fbeg .Llx ,_fbeg .Lly ;_cagd :=_gd .IdentityMatrix ();_bbeab ,_dbff :=page .GetRotate ();if _dbff !=nil {_db .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0025\u0073\u0020\u002d\u0020\u0069\u0067\u006e\u006f\u0072\u0069\u006e\u0067\u0020\u0061\u006e\u0064\u0020\u0061\u0073\u0073\u0075\u006d\u0069\u006e\u0067\u0020\u006e\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u000a",_dbff .Error ());
};_afaa :=_bbeab %360!=0&&_bbeab %90==0;if _afaa {_fdcf :=float64 ((360+_bbeab %360)%360);if _fdcf ==90{_cagd =_cagd .Translate (_fbeg .Width (),0);}else if _fdcf ==180{_cagd =_cagd .Translate (_fbeg .Width (),_fbeg .Height ());}else if _fdcf ==270{_cagd =_cagd .Translate (0,_fbeg .Height ());
};_cagd =_cagd .Mult (_gd .RotationMatrix (_fdcf *_cb .Pi /180));_cagd =_cagd .Round (0.000001);_dcc :=_gfdbdc (_fbeg ,_cagd );_fbeg =_dcc ;_fbeg .Normalize ();};if _agaf !=0||_fgef !=0{_cagd =_gd .TranslationMatrix (_agaf ,_fgef ).Mult (_cagd );};if !_cagd .Identity (){_cagd =_cagd .Round (0.000001);
_aga ._aaed [page ]=&pageTransformations {_acgb :&_cagd };};_aga ._fdga =_fbeg .Width ();_aga ._fcdb =_fbeg .Height ();_aga .initContext ();_aga ._fbcf =append (_aga ._fbcf ,page );_aga ._bgfa .Page ++;return nil ;};func (_dbac *Chapter )headingText ()string {_bffd :=_dbac ._gfb ;
if _bae :=_dbac .headingNumber ();_bae !=""{_bffd =_cba .Sprintf ("\u0025\u0073\u0020%\u0073",_bae ,_bffd );};return _bffd ;};

// NewPolyline creates a new polyline.
func (_ggaa *Creator )NewPolyline (points []_ee .Point )*Polyline {return _dgdcc (points )};func (_ebce *Invoice )generateNoteBlocks (_ffce DrawContext )([]*Block ,DrawContext ,error ){_adggg :=_eedd ();_bafee :=append ([][2]string {_ebce ._fae ,_ebce ._egde },_ebce ._edae ...);
for _ ,_adeb :=range _bafee {if _adeb [1]!=""{_gge :=_ebce .drawSection (_adeb [0],_adeb [1]);for _ ,_fcgg :=range _gge {_adggg .Add (_fcgg );};_fgff :=_fedb (_ebce ._bcbe );_fgff .SetMargins (0,0,10,0);_adggg .Add (_fgff );};};return _adggg .GeneratePageBlocks (_ffce );
};

// Terms returns the terms and conditions section of the invoice as a
// title-content pair.
func (_fgcg *Invoice )Terms ()(string ,string ){return _fgcg ._egde [0],_fgcg ._egde [1]};

// SetNumber sets the number of the invoice.
func (_gdbf *Invoice )SetNumber (number string )(*InvoiceCell ,*InvoiceCell ){_gdbf ._bdgaa [1].Value =number ;return _gdbf ._bdgaa [0],_gdbf ._bdgaa [1];};

// SetMargins sets the Table's left, right, top, bottom margins.
func (_abcdg *Table )SetMargins (left ,right ,top ,bottom float64 ){_abcdg ._ecffd .Left =left ;_abcdg ._ecffd .Right =right ;_abcdg ._ecffd .Top =top ;_abcdg ._ecffd .Bottom =bottom ;};

// DrawFooter sets a function to draw a footer on created output pages.
func (_gggcga *Creator )DrawFooter (drawFooterFunc func (_gea *Block ,_dcaa FooterFunctionArgs )){_gggcga ._fag =drawFooterFunc ;};

// Total returns the invoice total description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_daaed *Invoice )Total ()(*InvoiceCell ,*InvoiceCell ){return _daaed ._fdefa [0],_daaed ._fdefa [1];};

// Padding returns the padding of the component.
func (_gabe *Division )Padding ()(_adgg ,_dagf ,_ffg ,_cdgf float64 ){return _gabe ._gddb .Left ,_gabe ._gddb .Right ,_gabe ._gddb .Top ,_gabe ._gddb .Bottom ;};

// Title returns the title of the invoice.
func (_gecdb *Invoice )Title ()string {return _gecdb ._dacff };

// SetAddressStyle sets the style properties used to render the content of
// the invoice address sections.
func (_gdfd *Invoice )SetAddressStyle (style TextStyle ){_gdfd ._affe =style };

// NewCell makes a new cell and inserts it into the table at the current position.
func (_edffa *Table )NewCell ()*TableCell {return _edffa .MultiCell (1,1)};

// SetText replaces all the text of the paragraph with the specified one.
func (_feee *StyledParagraph )SetText (text string )*TextChunk {_feee .Reset ();return _feee .Append (text );};

// NoteStyle returns the style properties used to render the content of the
// invoice note sections.
func (_ddbe *Invoice )NoteStyle ()TextStyle {return _ddbe ._cfga };

// FitMode defines resizing options of an object inside a container.
type FitMode int ;

// Invoice represents a configurable invoice template.
type Invoice struct{_dacff string ;_cafd *Image ;_cded *InvoiceAddress ;_bged *InvoiceAddress ;_aaaed string ;_bdgaa [2]*InvoiceCell ;_geff [2]*InvoiceCell ;_gaad [2]*InvoiceCell ;_fabbc [][2]*InvoiceCell ;_bfda []*InvoiceCell ;_ecff [][]*InvoiceCell ;
_dbedcc [2]*InvoiceCell ;_fdefa [2]*InvoiceCell ;_aea [][2]*InvoiceCell ;_fae [2]string ;_egde [2]string ;_edae [][2]string ;_bcbe TextStyle ;_bcbaa TextStyle ;_ageb TextStyle ;_affe TextStyle ;_fabd TextStyle ;_cfga TextStyle ;_aebd TextStyle ;_dbgg InvoiceCellProps ;
_dcgbb InvoiceCellProps ;_aede InvoiceCellProps ;_acace InvoiceCellProps ;_eaddg Positioning ;};

// SetLineStyle sets the style for all the line components: number, title,
// separator, page. The style is applied only for new lines added to the
// TOC component.
func (_abbd *TOC )SetLineStyle (style TextStyle ){_abbd .SetLineNumberStyle (style );_abbd .SetLineTitleStyle (style );_abbd .SetLineSeparatorStyle (style );_abbd .SetLinePageStyle (style );};func _dgfg (_gfffc ,_aabg ,_eadfd float64 )(_cdade ,_caaab ,_dabea ,_dcced float64 ){if _eadfd ==0{return 0,0,_gfffc ,_aabg ;
};_efgf :=_ee .Path {Points :[]_ee .Point {_ee .NewPoint (0,0).Rotate (_eadfd ),_ee .NewPoint (_gfffc ,0).Rotate (_eadfd ),_ee .NewPoint (0,_aabg ).Rotate (_eadfd ),_ee .NewPoint (_gfffc ,_aabg ).Rotate (_eadfd )}}.GetBoundingBox ();return _efgf .X ,_efgf .Y ,_efgf .Width ,_efgf .Height ;
};

// GeneratePageBlocks generates the page blocks for the Division component.
// Multiple blocks are generated if the contents wrap over multiple pages.
func (_fage *Division )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){var (_fgdef []*Block ;_gdaa bool ;_fcbe error ;_ggda =_fage ._eccc .IsRelative ();_adaf =_fage ._fdea .Top ;);if _ggda &&!_fage ._gead &&!_fage ._aaca {_cgff :=_fage .ctxHeight (ctx .Width );
if _cgff > ctx .Height -_fage ._fdea .Top &&_cgff <=ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom {if _fgdef ,ctx ,_fcbe =_geag ().GeneratePageBlocks (ctx );_fcbe !=nil {return nil ,ctx ,_fcbe ;};_gdaa =true ;_adaf =0;};};_cfg :=ctx ;_bbee :=ctx ;
if _ggda {ctx .X +=_fage ._fdea .Left ;ctx .Y +=_adaf ;ctx .Width -=_fage ._fdea .Left +_fage ._fdea .Right ;ctx .Height -=_adaf ;_bbee =ctx ;ctx .X +=_fage ._gddb .Left ;ctx .Y +=_fage ._gddb .Top ;ctx .Width -=_fage ._gddb .Left +_fage ._gddb .Right ;
ctx .Height -=_fage ._gddb .Top ;ctx .Margins .Top +=_fage ._gddb .Top ;ctx .Margins .Bottom +=_fage ._gddb .Bottom ;ctx .Margins .Left +=_fage ._fdea .Left +_fage ._gddb .Left ;ctx .Margins .Right +=_fage ._fdea .Right +_fage ._gddb .Right ;};ctx .Inline =_fage ._aaca ;
_ceab :=ctx ;_fabb :=ctx ;var _geega float64 ;for _ ,_dgfb :=range _fage ._bdcb {if ctx .Inline {if (ctx .X -_ceab .X )+_dgfb .Width ()<=ctx .Width {ctx .Y =_fabb .Y ;ctx .Height =_fabb .Height ;}else {ctx .X =_ceab .X ;ctx .Width =_ceab .Width ;_fabb .Y +=_geega ;
_fabb .Height -=_geega ;_geega =0;};};_ccea ,_ffde ,_fabg :=_dgfb .GeneratePageBlocks (ctx );if _fabg !=nil {_db .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0067\u0065\u006e\u0065\u0072\u0061\u0074\u0069\u006eg\u0020p\u0061\u0067\u0065\u0020\u0062\u006c\u006f\u0063\u006b\u0073\u003a\u0020\u0025\u0076",_fabg );
return nil ,ctx ,_fabg ;};if len (_ccea )< 1{continue ;};if len (_fgdef )> 0{_fgdef [len (_fgdef )-1].mergeBlocks (_ccea [0]);_fgdef =append (_fgdef ,_ccea [1:]...);}else {if _afdb :=_ccea [0]._gg ;_afdb ==nil ||len (*_afdb )==0{_gdaa =true ;};_fgdef =append (_fgdef ,_ccea [0:]...);
};if ctx .Inline {if ctx .Page !=_ffde .Page {_ceab .Y =ctx .Margins .Top ;_ceab .Height =ctx .PageHeight -ctx .Margins .Top ;_fabb .Y =_ceab .Y ;_fabb .Height =_ceab .Height ;_geega =_ffde .Height -_ceab .Height ;}else {if _adgf :=ctx .Height -_ffde .Height ;
_adgf > _geega {_geega =_adgf ;};};}else {_ffde .X =ctx .X ;};ctx =_ffde ;};ctx .Inline =_cfg .Inline ;ctx .Margins =_cfg .Margins ;if _ggda {ctx .X =_cfg .X ;ctx .Width =_cfg .Width ;ctx .Y +=_fage ._gddb .Bottom ;ctx .Height -=_fage ._gddb .Bottom ;};
if _fage ._eebc !=nil {_fgdef ,_fcbe =_fage .drawBackground (_fgdef ,_bbee ,ctx ,_gdaa );if _fcbe !=nil {return nil ,ctx ,_fcbe ;};};if _fage ._eccc .IsAbsolute (){return _fgdef ,_cfg ,nil ;};ctx .Y +=_fage ._fdea .Bottom ;ctx .Height -=_fage ._fdea .Bottom ;
return _fgdef ,ctx ,nil ;};

// UnsupportedRuneError is an error that occurs when there is unsupported glyph being used.
type UnsupportedRuneError struct{Message string ;Rune rune ;};

// CellVerticalAlignment defines the table cell's vertical alignment.
type CellVerticalAlignment int ;

// Add appends a new item to the list.
// The supported components are: *Paragraph, *StyledParagraph and *List.
// Returns the marker used for the newly added item. The returned marker
// object can be used to change the text and style of the marker for the
// current item.
func (_cbeaa *List )Add (item VectorDrawable )(*TextChunk ,error ){_dcad :=&listItem {_fgdd :item ,_dgadc :_cbeaa ._eeba };switch _dagc :=item .(type ){case *Paragraph :case *StyledParagraph :case *List :if _dagc ._gcad {_dagc ._abgd =15;};default:return nil ,_c .New ("\u0074\u0068i\u0073\u0020\u0074\u0079\u0070\u0065\u0020\u006f\u0066\u0020\u0064\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0069\u006e\u0020\u006c\u0069\u0073\u0074");
};_cbeaa ._dfcd =append (_cbeaa ._dfcd ,_dcad );return &_dcad ._dgadc ,nil ;};

// ColorRGBFromArithmetic creates a Color from arithmetic color values (0-1).
// Example:
//   green := ColorRGBFromArithmetic(0.0, 1.0, 0.0)
func ColorRGBFromArithmetic (r ,g ,b float64 )Color {return rgbColor {_acgf :_cb .Max (_cb .Min (r ,1.0),0.0),_fcbcc :_cb .Max (_cb .Min (g ,1.0),0.0),_ebf :_cb .Max (_cb .Min (b ,1.0),0.0)};};

// TextStyle is a collection of properties that can be assigned to a text chunk.
type TextStyle struct{

// Color represents the color of the text.
Color Color ;

// OutlineColor represents the color of the text outline.
OutlineColor Color ;

// Font represents the font the text will use.
Font *_ca .PdfFont ;

// FontSize represents the size of the font.
FontSize float64 ;

// OutlineSize represents the thickness of the text outline.
OutlineSize float64 ;

// CharSpacing represents the character spacing.
CharSpacing float64 ;

// HorizontalScaling represents the percentage to horizontally scale
// characters by (default: 100). Values less than 100 will result in
// narrower text while values greater than 100 will result in wider text.
HorizontalScaling float64 ;

// RenderingMode represents the rendering mode.
RenderingMode TextRenderingMode ;

// Underline specifies if the text chunk is underlined.
Underline bool ;

// UnderlineStyle represents the style of the line used to underline text.
UnderlineStyle TextDecorationLineStyle ;

// TextRise specifies a vertical adjustment for text. It is useful for
// drawing subscripts/superscripts. A positive text rise value will
// produce superscript text, while a negative one will result in
// subscript text.
TextRise float64 ;};

// SetNotes sets the notes section of the invoice.
func (_cdgfc *Invoice )SetNotes (title ,content string ){_cdgfc ._fae =[2]string {title ,content }};

// NewInvoice returns an instance of an empty invoice.
func (_fgeb *Creator )NewInvoice ()*Invoice {_bad :=_fgeb .NewTextStyle ();_bad .Font =_fgeb ._gfd ;return _dbc (_fgeb .NewTextStyle (),_bad );};

// GetCoords returns coordinates of border.
func (_aeg *border )GetCoords ()(float64 ,float64 ){return _aeg ._cgb ,_aeg ._dce };

// SetRowHeight sets the height for a specified row.
func (_eabc *Table )SetRowHeight (row int ,h float64 )error {if row < 1||row > len (_eabc ._accdf ){return _c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_eabc ._accdf [row -1]=h ;return nil ;
};

// Margins returns the margins of the list: left, right, top, bottom.
func (_eggdb *List )Margins ()(float64 ,float64 ,float64 ,float64 ){return _eggdb ._cfdg .Left ,_eggdb ._cfdg .Right ,_eggdb ._cfdg .Top ,_eggdb ._cfdg .Bottom ;};func (_effff *StyledParagraph )getTextLineWidth (_ffdaf []*TextChunk )float64 {var _cggbd float64 ;
_ffdg :=len (_ffdaf );for _gggca ,_ecfe :=range _ffdaf {_fegb :=&_ecfe .Style ;_fcegc :=len (_ecfe .Text );for _beaf ,_fcga :=range _ecfe .Text {if _fcga =='\u000A'{continue ;};_aaaae ,_gbefg :=_fegb .Font .GetRuneMetrics (_fcga );if !_gbefg {_db .Log .Debug ("\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006d\u0065\u0074\u0072\u0069c\u0073 \u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021\u0020\u0025\u0076\u000a",_fcga );
return -1;};_cggbd +=_fegb .FontSize *_aaaae .Wx *_fegb .horizontalScale ();if _fcga !=' '&&(_gggca !=_ffdg -1||_beaf !=_fcegc -1){_cggbd +=_fegb .CharSpacing *1000.0;};};};return _cggbd ;};const (CellBorderSideLeft CellBorderSide =iota ;CellBorderSideRight ;
CellBorderSideTop ;CellBorderSideBottom ;CellBorderSideAll ;);func _dafa (_fbfe string )(*Image ,error ){_cgcf ,_gabce :=_d .Open (_fbfe );if _gabce !=nil {return nil ,_gabce ;};defer _cgcf .Close ();_ceef ,_gabce :=_ca .ImageHandling .Read (_cgcf );if _gabce !=nil {_db .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_gabce );
return nil ,_gabce ;};return _eabb (_ceef );};func _aggf (_dadf []_ee .CubicBezierCurve )*PolyBezierCurve {return &PolyBezierCurve {_gggb :&_ee .PolyBezierCurve {Curves :_dadf ,BorderColor :_ca .NewPdfColorDeviceRGB (0,0,0),BorderWidth :1.0},_dceg :1.0,_cacg :1.0};
};

// Width is not used. Not used as a Table element is designed to fill into
// available width depending on the context. Returns 0.
func (_afccf *Table )Width ()float64 {return 0};func _dfca (_efeed TextStyle )*List {return &List {_eeba :TextChunk {Text :"\u2022\u0020",Style :_efeed },_abgd :0,_gcad :true ,_cfgf :PositionRelative ,_ddaaa :_efeed };};

// Scale scales Image by a constant factor, both width and height.
func (_dbedc *Image )Scale (xFactor ,yFactor float64 ){_dbedc ._dddg =xFactor *_dbedc ._dddg ;_dbedc ._ffgf =yFactor *_dbedc ._ffgf ;};

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_beaa *Paragraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _beaa ._cbcfd .Left ,_beaa ._cbcfd .Right ,_beaa ._cbcfd .Top ,_beaa ._cbcfd .Bottom ;};

// SetAngle sets the rotation angle in degrees.
func (_af *Block )SetAngle (angleDeg float64 ){_af ._da =angleDeg };

// ScaleToWidth scales the Block to a specified width, maintaining the same aspect ratio.
func (_bbf *Block )ScaleToWidth (w float64 ){_agd :=w /_bbf ._ce ;_bbf .Scale (_agd ,_agd )};func (_ggac *Paragraph )getMaxLineWidth ()float64 {if _ggac ._bedb ==nil ||len (_ggac ._bedb )==0{_ggac .wrapText ();};var _fafge float64 ;for _ ,_cgag :=range _ggac ._bedb {_eadbb :=_ggac .getTextLineWidth (_cgag );
if _eadbb > _fafge {_fafge =_eadbb ;};};return _fafge ;};

// Background contains properties related to the background of a component.
type Background struct{FillColor Color ;BorderColor Color ;BorderSize float64 ;BorderRadiusTopLeft float64 ;BorderRadiusTopRight float64 ;BorderRadiusBottomLeft float64 ;BorderRadiusBottomRight float64 ;};func (_cgcea *StyledParagraph )getMaxLineWidth ()float64 {if _cgcea ._bcdd ==nil ||len (_cgcea ._bcdd )==0{_cgcea .wrapText ();
};var _cada float64 ;for _ ,_adfa :=range _cgcea ._bcdd {_becdg :=_cgcea .getTextLineWidth (_adfa );if _becdg > _cada {_cada =_becdg ;};};return _cada ;};

// AddLine adds a new line with the provided style to the table of contents.
func (_dffac *TOC )AddLine (line *TOCLine )*TOCLine {if line ==nil {return nil ;};_dffac ._dbeba =append (_dffac ._dbeba ,line );return line ;};

// List represents a list of items.
// The representation of a list item is as follows:
//       [marker] [content]
// e.g.:        • This is the content of the item.
// The supported components to add content to list items are:
// - Paragraph
// - StyledParagraph
// - List
type List struct{_dfcd []*listItem ;_cfdg Margins ;_eeba TextChunk ;_abgd float64 ;_gcad bool ;_cfgf Positioning ;_ddaaa TextStyle ;};const (CellVerticalAlignmentTop CellVerticalAlignment =iota ;CellVerticalAlignmentMiddle ;CellVerticalAlignmentBottom ;
);

// GeneratePageBlocks generate the Page blocks. Draws the Image on a block, implementing the Drawable interface.
func (_gecd *Image )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){if _gecd ._bea ==nil {if _bddg :=_gecd .makeXObject ();_bddg !=nil {return nil ,ctx ,_bddg ;};};var _egcg []*Block ;_eagb :=ctx ;_eabbf :=NewBlock (ctx .PageWidth ,ctx .PageHeight );
if _gecd ._fbga .IsRelative (){_gecd .applyFitMode (ctx .Width );ctx .X +=_gecd ._ebea .Left ;ctx .Y +=_gecd ._ebea .Top ;ctx .Width -=_gecd ._ebea .Left +_gecd ._ebea .Right ;ctx .Height -=_gecd ._ebea .Top +_gecd ._ebea .Bottom ;if _gecd ._ffgf > ctx .Height {_egcg =append (_egcg ,_eabbf );
_eabbf =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_edgc :=ctx ;_edgc .Y =ctx .Margins .Top +_gecd ._ebea .Top ;_edgc .X =ctx .Margins .Left +_gecd ._ebea .Left ;_edgc .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom -_gecd ._ebea .Top -_gecd ._ebea .Bottom ;
_edgc .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_gecd ._ebea .Left -_gecd ._ebea .Right ;ctx =_edgc ;};}else {ctx .X =_gecd ._fcbd ;ctx .Y =_gecd ._fffb ;};ctx ,_bda :=_fegd (_eabbf ,_gecd ,ctx );if _bda !=nil {return nil ,ctx ,_bda ;
};_egcg =append (_egcg ,_eabbf );if _gecd ._fbga .IsAbsolute (){ctx =_eagb ;}else {ctx .X =_eagb .X ;ctx .Width =_eagb .Width ;ctx .Y +=_gecd ._ebea .Bottom ;};return _egcg ,ctx ,nil ;};

// SetLineHeight sets the line height (1.0 default).
func (_efad *Paragraph )SetLineHeight (lineheight float64 ){_efad ._fdeec =lineheight };

// GeneratePageBlocks generates the table page blocks. Multiple blocks are
// generated if the contents wrap over multiple pages.
// Implements the Drawable interface.
func (_baec *Table )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_eeec :=_baec ;if _baec ._cbbca {_eeec =_baec .clone ();};return _gbbeg (_eeec ,ctx );};

// SetPos sets the Table's positioning to absolute mode and specifies the upper-left corner
// coordinates as (x,y).
// Note that this is only sensible to use when the table does not wrap over multiple pages.
// TODO: Should be able to set width too (not just based on context/relative positioning mode).
func (_daedf *Table )SetPos (x ,y float64 ){_daedf ._gffgd =PositionAbsolute ;_daedf ._eecef =x ;_daedf ._bead =y ;};func (_ggae *Invoice )newColumn (_bbcc string ,_ecbg CellHorizontalAlignment )*InvoiceCell {_eae :=&InvoiceCell {_ggae ._dcgbb ,_bbcc };
_eae .Alignment =_ecbg ;return _eae ;};

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_ggee *TOCLine )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_fdaf :=ctx ;_bgdf ,ctx ,_aaga :=_ggee ._ddca .GeneratePageBlocks (ctx );if _aaga !=nil {return _bgdf ,ctx ,_aaga ;};if _ggee ._bceda .IsRelative (){ctx .X =_fdaf .X ;
};if _ggee ._bceda .IsAbsolute (){return _bgdf ,_fdaf ,nil ;};return _bgdf ,ctx ,nil ;};

// GetMargins returns the margins of the chart (left, right, top, bottom).
func (_gae *Chart )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _gae ._cfbc .Left ,_gae ._cfbc .Right ,_gae ._cfbc .Top ,_gae ._cfbc .Bottom ;};

// SetFont sets the Paragraph's font.
func (_ffeb *Paragraph )SetFont (font *_ca .PdfFont ){_ffeb ._eecf =font };

// SetPageMargins sets the page margins: left, right, top, bottom.
// The default page margins are 10% of document width.
func (_cfda *Creator )SetPageMargins (left ,right ,top ,bottom float64 ){_cfda ._bddf .Left =left ;_cfda ._bddf .Right =right ;_cfda ._bddf .Top =top ;_cfda ._bddf .Bottom =bottom ;};

// SetPositioning sets Ellipse's position attribute.
func (_ecef *Ellipse )SetPositioning (position Positioning ){_ecef ._bdce =position };

// Number returns the invoice number description and value cells.
// The returned values can be used to customize the styles of the cells.
func (_dbgb *Invoice )Number ()(*InvoiceCell ,*InvoiceCell ){return _dbgb ._bdgaa [0],_dbgb ._bdgaa [1]};

// SetPos sets absolute positioning with specified coordinates.
func (_dfbbc *StyledParagraph )SetPos (x ,y float64 ){_dfbbc ._dead =PositionAbsolute ;_dfbbc ._bfdc =x ;_dfbbc ._gffa =y ;};

// ScaleToHeight scales the Block to a specified height, maintaining the same aspect ratio.
func (_egc *Block )ScaleToHeight (h float64 ){_fbb :=h /_egc ._cac ;_egc .Scale (_fbb ,_fbb )};

// Flip flips the active page on the specified axes.
// If `flipH` is true, the page is flipped horizontally. Similarly, if `flipV`
// is true, the page is flipped vertically. If both are true, the page is
// flipped both horizontally and vertically.
// NOTE: the flip transformations are applied when the creator is finalized,
// which is at write time in most cases.
func (_bdc *Creator )Flip (flipH ,flipV bool )error {_ffda :=_bdc .getActivePage ();if _ffda ==nil {return _c .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");};_afeb ,_cgf :=_bdc ._aaed [_ffda ];if !_cgf {_afeb =&pageTransformations {};
_bdc ._aaed [_ffda ]=_afeb ;};_afeb ._gggcg =flipH ;_afeb ._faf =flipV ;return nil ;};func (_ebfe *Table )updateRowHeights (_bafb float64 ){for _ ,_fgfff :=range _ebfe ._deag {_efda :=_fgfff .width (_ebfe ._dabge ,_bafb );_dabd :=_ebfe ._accdf [_fgfff ._bcbfb +_fgfff ._abdf -2];
if _egcc :=_fgfff .height (_efda );_egcc > _dabd {_ecbgg :=_egcc /float64 (_fgfff ._abdf );for _ddde :=1;_ddde <=_fgfff ._abdf ;_ddde ++{if _ecbgg > _ebfe ._accdf [_fgfff ._bcbfb +_ddde -2]{_ebfe ._accdf [_fgfff ._bcbfb +_ddde -2]=_ecbgg ;};};};};};

// SetMargins sets the margins of the paragraph.
func (_eaed *List )SetMargins (left ,right ,top ,bottom float64 ){_eaed ._cfdg .Left =left ;_eaed ._cfdg .Right =right ;_eaed ._cfdg .Top =top ;_eaed ._cfdg .Bottom =bottom ;};

// SetBorderColor sets the cell's border color.
func (_adce *TableCell )SetBorderColor (col Color ){_adce ._ffcfc =col ;_adce ._edac =col ;_adce ._fcggd =col ;_adce ._cgeda =col ;};

// AddSubtable copies the cells of the subtable in the table, starting with the
// specified position. The table row and column indices are 1-based, which
// makes the position of the first cell of the first row of the table 1,1.
// The table is automatically extended if the subtable exceeds its columns.
// This can happen when the subtable has more columns than the table or when
// one or more columns of the subtable starting from the specified position
// exceed the last column of the table.
func (_abcdb *Table )AddSubtable (row ,col int ,subtable *Table ){for _ ,_dabc :=range subtable ._deag {_fgged :=&TableCell {};*_fgged =*_dabc ;_fgged ._cgdbb =_abcdb ;_fgged ._abfg +=col -1;if _fffbe :=_abcdb ._dcff -(_fgged ._abfg -1);_fffbe < _fgged ._bgcdf {_abcdb ._dcff +=_fgged ._bgcdf -_fffbe ;
_abcdb .resetColumnWidths ();_db .Log .Debug ("\u0054a\u0062l\u0065\u003a\u0020\u0073\u0075\u0062\u0074\u0061\u0062\u006c\u0065 \u0065\u0078\u0063\u0065e\u0064\u0073\u0020\u0064\u0065s\u0074\u0069\u006e\u0061\u0074\u0069\u006f\u006e\u0020\u0074\u0061\u0062\u006c\u0065\u002e\u0020\u0045\u0078\u0070\u0061\u006e\u0064\u0069\u006e\u0067\u0020\u0074\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0025\u0064\u0020\u0063\u006fl\u0075\u006d\u006e\u0073\u002e",_abcdb ._dcff );
};_fgged ._bcbfb +=row -1;_beac :=subtable ._accdf [_dabc ._bcbfb -1];if _fgged ._bcbfb > _abcdb ._ddaed {for _fgged ._bcbfb > _abcdb ._ddaed {_abcdb ._ddaed ++;_abcdb ._accdf =append (_abcdb ._accdf ,_abcdb ._ddefb );};_abcdb ._accdf [_fgged ._bcbfb -1]=_beac ;
}else {_abcdb ._accdf [_fgged ._bcbfb -1]=_cb .Max (_abcdb ._accdf [_fgged ._bcbfb -1],_beac );};_abcdb ._deag =append (_abcdb ._deag ,_fgged );};_cf .Slice (_abcdb ._deag ,func (_bcda ,_fgbee int )bool {_cbcca :=_abcdb ._deag [_bcda ]._bcbfb ;_gcga :=_abcdb ._deag [_fgbee ]._bcbfb ;
if _cbcca < _gcga {return true ;};if _cbcca > _gcga {return false ;};return _abcdb ._deag [_bcda ]._abfg < _abcdb ._deag [_fgbee ]._abfg ;});};func _daggg (_aaeb *_d .File )([]*_ca .PdfPage ,error ){_cbdf ,_ggec :=_ca .NewPdfReader (_aaeb );if _ggec !=nil {return nil ,_ggec ;
};_bcabd ,_ggec :=_cbdf .GetNumPages ();if _ggec !=nil {return nil ,_ggec ;};var _gdbfe []*_ca .PdfPage ;for _ecae :=0;_ecae < _bcabd ;_ecae ++{_bfga ,_gaefg :=_cbdf .GetPage (_ecae +1);if _gaefg !=nil {return nil ,_gaefg ;};_gdbfe =append (_gdbfe ,_bfga );
};return _gdbfe ,nil ;};

// Curve represents a cubic Bezier curve with a control point.
type Curve struct{_fdbb float64 ;_fefc float64 ;_gaebg float64 ;_gef float64 ;_cegba float64 ;_gfce float64 ;_feefb Color ;_bcdb float64 ;};

// SetBorderOpacity sets the border opacity.
func (_cadc *PolyBezierCurve )SetBorderOpacity (opacity float64 ){_cadc ._cacg =opacity };

// SetPageLabels adds the specified page labels to the PDF file generated
// by the creator. See section 12.4.2 "Page Labels" (p. 382 PDF32000_2008).
// NOTE: for existing PDF files, the page label ranges object can be obtained
// using the model.PDFReader's GetPageLabels method.
func (_bdee *Creator )SetPageLabels (pageLabels _bc .PdfObject ){_bdee ._ecb =pageLabels };

// NoteHeadingStyle returns the style properties used to render the heading of
// the invoice note sections.
func (_agbd *Invoice )NoteHeadingStyle ()TextStyle {return _agbd ._aebd };

// SetLinePageStyle sets the style for the page part of all new lines
// of the table of contents.
func (_cdffg *TOC )SetLinePageStyle (style TextStyle ){_cdffg ._fgbbf =style };

// SetTOC sets the table of content component of the creator.
// This method should be used when building a custom table of contents.
func (_dbbc *Creator )SetTOC (toc *TOC ){if toc ==nil {return ;};_dbbc ._dadcd =toc ;};

// Width returns Rectangle's document width.
func (_gege *Rectangle )Width ()float64 {return _gege ._fdbbf };

// PageSize represents the page size as a 2 element array representing the width and height in PDF document units (points).
type PageSize [2]float64 ;func _aedd ()*FilledCurve {_ddae :=FilledCurve {};_ddae ._eagg =[]_ee .CubicBezierCurve {};return &_ddae ;};

// GetMargins returns the Paragraph's margins: left, right, top, bottom.
func (_cgdd *StyledParagraph )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _cgdd ._dfcc .Left ,_cgdd ._dfcc .Right ,_cgdd ._dfcc .Top ,_cgdd ._dfcc .Bottom ;};

// SetFillOpacity sets the fill opacity.
func (_bdggd *PolyBezierCurve )SetFillOpacity (opacity float64 ){_bdggd ._dceg =opacity };

// Columns returns all the columns in the invoice line items table.
func (_afag *Invoice )Columns ()[]*InvoiceCell {return _afag ._bfda };

// SetNoteHeadingStyle sets the style properties used to render the heading
// of the invoice note sections.
func (_cafdd *Invoice )SetNoteHeadingStyle (style TextStyle ){_cafdd ._aebd =style };

// Width returns the Block's width.
func (_ggd *Block )Width ()float64 {return _ggd ._ce };

// NewCurve returns new instance of Curve between points (x1,y1) and (x2, y2) with control point (cx,cy).
func (_fdcbe *Creator )NewCurve (x1 ,y1 ,cx ,cy ,x2 ,y2 float64 )*Curve {return _agbff (x1 ,y1 ,cx ,cy ,x2 ,y2 );};

// SetBorderColor sets border color.
func (_geaeg *Rectangle )SetBorderColor (col Color ){_geaeg ._gdad =col };

// NewColumn returns a new column for the line items invoice table.
func (_cddcb *Invoice )NewColumn (description string )*InvoiceCell {return _cddcb .newColumn (description ,CellHorizontalAlignmentLeft );};func (_ggge *StyledParagraph )getLineMetrics (_feca int )(_geaga ,_efbf ,_eagc float64 ){if _ggge ._bcdd ==nil ||len (_ggge ._bcdd )==0{_ggge .wrapText ();
};if _feca < 0||_feca > len (_ggge ._bcdd )-1{_db .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020p\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u0020\u006c\u0069\u006e\u0065 \u0069\u006e\u0064\u0065\u0078\u0020\u0025\u0064\u002e\u0020\u0052\u0065tu\u0072\u006e\u0069\u006e\u0067\u0020\u0030\u002c\u0020\u0030",_feca );
return 0,0,0;};_bffe :=_ggge ._bcdd [_feca ];for _ ,_bddd :=range _bffe {_dfdbc ,_egbe :=_bddd .Style .Font .GetFontDescriptor ();if _egbe !=nil {_db .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020U\u006e\u0061\u0062\u006ce t\u006f g\u0065\u0074\u0020\u0066\u006f\u006e\u0074 d\u0065\u0073\u0063\u0072\u0069\u0070\u0074o\u0072");
};var _gedfe ,_adda float64 ;if _dfdbc !=nil {if _gedfe ,_egbe =_dfdbc .GetCapHeight ();_egbe !=nil {_db .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0067\u0065\u0074 \u0066\u006f\u006e\u0074\u0020\u0043\u0061\u0070\u0048\u0065\u0069\u0067\u0068t\u003a\u0020\u0025\u0076",_egbe );
};if _adda ,_egbe =_dfdbc .GetDescent ();_egbe !=nil {_db .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020U\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0067\u0065t\u0020\u0066\u006f\u006e\u0074\u0020\u0044\u0065\u0073\u0063\u0065\u006et\u003a\u0020\u0025\u0076",_egbe );
};};if int (_gedfe )<=0{_db .Log .Debug ("W\u0041\u0052\u004e\u003a\u0020\u0043\u0061\u0070\u0048e\u0069\u0067\u0068\u0074\u0020\u006e\u006ft \u0061\u0076\u0061\u0069l\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0073\u0065tt\u0069\u006eg\u0020\u0074\u006f\u0020\u0031\u0030\u0030\u0030");
_gedfe =1000;};if _ggbbb :=_gedfe /1000.0*_bddd .Style .FontSize ;_ggbbb > _geaga {_geaga =_ggbbb ;};if _abbe :=_bddd .Style .FontSize ;_abbe > _efbf {_efbf =_abbe ;};if _daaecb :=_adda /1000.0*_bddd .Style .FontSize ;_daaecb < _eagc {_eagc =_daaecb ;};
};return _geaga ,_efbf ,_eagc ;};

// NewTextChunk returns a new text chunk instance.
func NewTextChunk (text string ,style TextStyle )*TextChunk {return &TextChunk {Text :text ,Style :style };};

// Height returns Rectangle's document height.
func (_dgag *Rectangle )Height ()float64 {return _dgag ._acbf };

// GeneratePageBlocks generates the page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages. Implements the Drawable interface.
func (_ebga *StyledParagraph )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_ccaa :=ctx ;var _gegc []*Block ;_fecf :=NewBlock (ctx .PageWidth ,ctx .PageHeight );if _ebga ._dead .IsRelative (){ctx .X +=_ebga ._dfcc .Left ;ctx .Y +=_ebga ._dfcc .Top ;
ctx .Width -=_ebga ._dfcc .Left +_ebga ._dfcc .Right ;ctx .Height -=_ebga ._dfcc .Top ;_ebga .SetWidth (ctx .Width );}else {if int (_ebga ._ggcc )<=0{_ebga .SetWidth (_ebga .getTextWidth ()/1000.0);};ctx .X =_ebga ._bfdc ;ctx .Y =_ebga ._gffa ;};if _ebga ._efeab !=nil {_ebga ._efeab (_ebga ,ctx );
};if _bcdbe :=_ebga .wrapText ();_bcdbe !=nil {return nil ,ctx ,_bcdbe ;};_gagdc :=_ebga ._bcdd ;for {_bgff ,_ddgea ,_daeb :=_bcab (_fecf ,_ebga ,_gagdc ,ctx );if _daeb !=nil {_db .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_daeb );return nil ,ctx ,_daeb ;
};ctx =_bgff ;_gegc =append (_gegc ,_fecf );if _gagdc =_ddgea ;len (_ddgea )==0{break ;};_fecf =NewBlock (ctx .PageWidth ,ctx .PageHeight );ctx .Page ++;_bgff =ctx ;_bgff .Y =ctx .Margins .Top ;_bgff .X =ctx .Margins .Left +_ebga ._dfcc .Left ;_bgff .Height =ctx .PageHeight -ctx .Margins .Top -ctx .Margins .Bottom ;
_bgff .Width =ctx .PageWidth -ctx .Margins .Left -ctx .Margins .Right -_ebga ._dfcc .Left -_ebga ._dfcc .Right ;ctx =_bgff ;};if _ebga ._dead .IsRelative (){ctx .Y +=_ebga ._dfcc .Bottom ;ctx .Height -=_ebga ._dfcc .Bottom ;if !ctx .Inline {ctx .X =_ccaa .X ;
ctx .Width =_ccaa .Width ;};return _gegc ,ctx ,nil ;};return _gegc ,_ccaa ,nil ;};

// Fit fits the chunk into the specified bounding box, cropping off the
// remainder in a new chunk, if it exceeds the specified dimensions.
// NOTE: The method assumes a line height of 1.0. In order to account for other
// line height values, the passed in height must be divided by the line height:
// height = height / lineHeight
func (_beae *TextChunk )Fit (width ,height float64 )(*TextChunk ,error ){_dbeee ,_gabcd :=_beae .Wrap (width );if _gabcd !=nil {return nil ,_gabcd ;};_bbff :=int (height /_beae .Style .FontSize );if _bbff >=len (_dbeee ){return nil ,nil ;};_gfcda :="\u000a";
_beae .Text =_ac .Replace (_ac .Join (_dbeee [:_bbff ],"\u0020"),_gfcda +"\u0020",_gfcda ,-1);_efdb :=_ac .Replace (_ac .Join (_dbeee [_bbff :],"\u0020"),_gfcda +"\u0020",_gfcda ,-1);return NewTextChunk (_efdb ,_beae .Style ),nil ;};

// NewCurvePolygon creates a new curve polygon.
func (_agdce *Creator )NewCurvePolygon (rings [][]_ee .CubicBezierCurve )*CurvePolygon {return _addc (rings );};var PPMM =float64 (72*1.0/25.4);

// GeneratePageBlocks generate the Page blocks. Multiple blocks are generated
// if the contents wrap over multiple pages.
func (_gbfa *TOC )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bafaa :=ctx ;_afbda ,ctx ,_bcgef :=_gbfa ._ebcb .GeneratePageBlocks (ctx );if _bcgef !=nil {return _afbda ,ctx ,_bcgef ;};for _ ,_ccee :=range _gbfa ._dbeba {_cgbb :=_ccee ._cgge ;
if !_gbfa ._abba {_ccee ._cgge =0;};_cfagg ,_fggff ,_eafd :=_ccee .GeneratePageBlocks (ctx );_ccee ._cgge =_cgbb ;if _eafd !=nil {return _afbda ,ctx ,_eafd ;};if len (_cfagg )< 1{continue ;};_afbda [len (_afbda )-1].mergeBlocks (_cfagg [0]);_afbda =append (_afbda ,_cfagg [1:]...);
ctx =_fggff ;};if _gbfa ._degfea .IsRelative (){ctx .X =_bafaa .X ;};if _gbfa ._degfea .IsAbsolute (){return _afbda ,_bafaa ,nil ;};return _afbda ,ctx ,nil ;};

// String implements error interface.
func (_ageeg UnsupportedRuneError )Error ()string {return _ageeg .Message };

// Scale block by specified factors in the x and y directions.
func (_fcb *Block )Scale (sx ,sy float64 ){_cbaa :=_acc .NewContentCreator ().Scale (sx ,sy ).Operations ();*_fcb ._gg =append (*_cbaa ,*_fcb ._gg ...);_fcb ._gg .WrapIfNeeded ();_fcb ._ce *=sx ;_fcb ._cac *=sy ;};

// Paragraph represents text drawn with a specified font and can wrap across lines and pages.
// By default it occupies the available width in the drawing context.
type Paragraph struct{_aafb string ;_eecf *_ca .PdfFont ;_fcbfd float64 ;_fdeec float64 ;_bceff Color ;_gddc TextAlignment ;_cece bool ;_deda float64 ;_dfdec int ;_ggdaf bool ;_eac float64 ;_cbcfd Margins ;_dacd Positioning ;_cdfg float64 ;_egb float64 ;
_bfbab ,_cebb float64 ;_bedb []string ;};

// SetPositioning sets Rectangle's position attribute.
func (_babff *Rectangle )SetPositioning (position Positioning ){_babff ._dbege =position };

// AddInfo is used to append a piece of invoice information in the template
// information table.
func (_cacaa *Invoice )AddInfo (description ,value string )(*InvoiceCell ,*InvoiceCell ){_dabg :=[2]*InvoiceCell {_cacaa .newCell (description ,_cacaa ._dbgg ),_cacaa .newCell (value ,_cacaa ._dbgg )};_cacaa ._fabbc =append (_cacaa ._fabbc ,_dabg );return _dabg [0],_dabg [1];
};

// PageFinalize sets a function to be called for each page before finalization
// (i.e. the last stage of page processing before they get written out).
// The callback function allows final touch-ups for each page, and it
// provides information that might not be known at other stages of designing
// the document (e.g. the total number of pages). Unlike the header/footer
// functions, which are limited to the top/bottom margins of the page, the
// finalize function can be used draw components anywhere on the current page.
func (_aac *Creator )PageFinalize (pageFinalizeFunc func (_fddb PageFinalizeFunctionArgs )error ){_aac ._caga =pageFinalizeFunc ;};

// MoveRight moves the drawing context right by relative displacement dx (negative goes left).
func (_bfdf *Creator )MoveRight (dx float64 ){_bfdf ._bgfa .X +=dx };

// Table allows organizing content in an rows X columns matrix, which can spawn across multiple pages.
type Table struct{_ddaed int ;_dcff int ;_ccgd int ;_dabge []float64 ;_accdf []float64 ;_ddefb float64 ;_deag []*TableCell ;_accf []int ;_gffgd Positioning ;_eecef ,_bead float64 ;_ecffd Margins ;_eafb bool ;_gdagf int ;_dccfg int ;_cbbca bool ;_acccg bool ;
};

// ConvertToBinary converts current image data into binary (Bi-level image) format.
// If provided image is RGB or GrayScale the function converts it into binary image
// using histogram auto threshold method.
func (_fcdbb *Image )ConvertToBinary ()error {return _fcdbb ._bbeg .ConvertToBinary ()};

// NewRectangle creates a new Rectangle with default parameters
// with left corner at (x,y) and width, height as specified.
func (_gebf *Creator )NewRectangle (x ,y ,width ,height float64 )*Rectangle {return _ffca (x ,y ,width ,height );};

// SetBorderColor sets the border color.
func (_gabc *CurvePolygon )SetBorderColor (color Color ){_gabc ._fdbbd .BorderColor =_geg (color )};func (_bdfa *Table )clone ()*Table {_dbcc :=*_bdfa ;_dbcc ._accdf =make ([]float64 ,len (_bdfa ._accdf ));copy (_dbcc ._accdf ,_bdfa ._accdf );_dbcc ._dabge =make ([]float64 ,len (_bdfa ._dabge ));
copy (_dbcc ._dabge ,_bdfa ._dabge );_dbcc ._deag =make ([]*TableCell ,0,len (_bdfa ._deag ));for _ ,_cbgcd :=range _bdfa ._deag {_eedaf :=*_cbgcd ;_eedaf ._cgdbb =&_dbcc ;_dbcc ._deag =append (_dbcc ._deag ,&_eedaf );};return &_dbcc ;};

// SetColor sets the line color.
func (_faba *Curve )SetColor (col Color ){_faba ._feefb =col };

// SetMargins sets the margins for the Image (in relative mode): left, right, top, bottom.
func (_cga *Image )SetMargins (left ,right ,top ,bottom float64 ){_cga ._ebea .Left =left ;_cga ._ebea .Right =right ;_cga ._ebea .Top =top ;_cga ._ebea .Bottom =bottom ;};var (ColorBlack =ColorRGBFromArithmetic (0,0,0);ColorWhite =ColorRGBFromArithmetic (1,1,1);
ColorRed =ColorRGBFromArithmetic (1,0,0);ColorGreen =ColorRGBFromArithmetic (0,1,0);ColorBlue =ColorRGBFromArithmetic (0,0,1);ColorYellow =ColorRGBFromArithmetic (1,1,0););type border struct{_cgb float64 ;_dce float64 ;_fcce float64 ;_cgg float64 ;_fcff Color ;
_ceb Color ;_acf float64 ;_fcbc Color ;_gdf float64 ;_dcea Color ;_age float64 ;_egg Color ;_dgd float64 ;LineStyle _ee .LineStyle ;_cea CellBorderStyle ;_aee CellBorderStyle ;_cbea CellBorderStyle ;_dbb CellBorderStyle ;};

// New creates a new instance of the PDF Creator.
func New ()*Creator {const _agee ="c\u0072\u0065\u0061\u0074\u006f\u0072\u002e\u004e\u0065\u0077";_fdcb :=&Creator {};_fdcb ._fbcf =[]*_ca .PdfPage {};_fdcb ._acfg =map[*_ca .PdfPage ]*Block {};_fdcb ._aaed =map[*_ca .PdfPage ]*pageTransformations {};_fdcb .SetPageSize (PageSizeLetter );
_daba :=0.1*_fdcb ._fdga ;_fdcb ._bddf .Left =_daba ;_fdcb ._bddf .Right =_daba ;_fdcb ._bddf .Top =_daba ;_fdcb ._bddf .Bottom =_daba ;var _dbag error ;_fdcb ._agdc ,_dbag =_ca .NewStandard14Font (_ca .HelveticaName );if _dbag !=nil {_fdcb ._agdc =_ca .DefaultFont ();
};_fdcb ._gfd ,_dbag =_ca .NewStandard14Font (_ca .HelveticaBoldName );if _dbag !=nil {_fdcb ._agdc =_ca .DefaultFont ();};_fdcb ._dadcd =_fdcb .NewTOC ("\u0054\u0061\u0062\u006c\u0065\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0065\u006e\u0074\u0073");
_fdcb .AddOutlines =true ;_fdcb ._cbgc =_ca .NewOutline ();_gc .TrackUse (_agee );return _fdcb ;};

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_fgcf *StyledParagraph )SetTextAlignment (align TextAlignment ){_fgcf ._ecdg =align };

// NewStyledTOCLine creates a new table of contents line with the provided style.
func (_fbbd *Creator )NewStyledTOCLine (number ,title ,page TextChunk ,level uint ,style TextStyle )*TOCLine {return _cgfc (number ,title ,page ,level ,style );};const (PositionRelative Positioning =iota ;PositionAbsolute ;);

// MoveY moves the drawing context to absolute position y.
func (_bcecb *Creator )MoveY (y float64 ){_bcecb ._bgfa .Y =y };

// GetMargins returns the left, right, top, bottom Margins.
func (_geadd *Table )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _geadd ._ecffd .Left ,_geadd ._ecffd .Right ,_geadd ._ecffd .Top ,_geadd ._ecffd .Bottom ;};func _geg (_eeff Color )_ca .PdfColor {if _eeff ==nil {_eeff =ColorBlack ;};switch _abb :=_eeff .(type ){case cmykColor :return _ca .NewPdfColorDeviceCMYK (_abb ._eedg ,_abb ._ggbfb ,_abb ._gaeb ,_abb ._eece );
};return _ca .NewPdfColorDeviceRGB (_eeff .ToRGB ());};func _eedd ()*Division {return &Division {_gead :true }};

// Draw draws the drawable d on the block.
// Note that the drawable must not wrap, i.e. only return one block. Otherwise an error is returned.
func (_bcb *Block )Draw (d Drawable )error {_cfe :=DrawContext {};_cfe .Width =_bcb ._ce ;_cfe .Height =_bcb ._cac ;_cfe .PageWidth =_bcb ._ce ;_cfe .PageHeight =_bcb ._cac ;_cfe .X =0;_cfe .Y =0;_aab ,_ ,_cbb :=d .GeneratePageBlocks (_cfe );if _cbb !=nil {return _cbb ;
};if len (_aab )!=1{return _c .New ("\u0074\u006f\u006f\u0020ma\u006e\u0079\u0020\u006f\u0075\u0074\u0070\u0075\u0074\u0020\u0062\u006c\u006f\u0063k\u0073");};for _ ,_ae :=range _aab {if _ggg :=_bcb .mergeBlocks (_ae );_ggg !=nil {return _ggg ;};};return nil ;
};

// SetColor sets the color of the Paragraph text.
//
// Example:
// 1.   p := NewParagraph("Red paragraph")
//      // Set to red color with a hex code:
//      p.SetColor(creator.ColorRGBFromHex("#ff0000"))
//
// 2. Make Paragraph green with 8-bit rgb values (0-255 each component)
//      p.SetColor(creator.ColorRGBFrom8bit(0, 255, 0)
//
// 3. Make Paragraph blue with arithmetic (0-1) rgb components.
//      p.SetColor(creator.ColorRGBFromArithmetic(0, 0, 1.0)
//
func (_fcdc *Paragraph )SetColor (col Color ){_fcdc ._bceff =col };

// SetMargins sets the Block's left, right, top, bottom, margins.
func (_be *Block )SetMargins (left ,right ,top ,bottom float64 ){_be ._gca .Left =left ;_be ._gca .Right =right ;_be ._gca .Top =top ;_be ._gca .Bottom =bottom ;};

// SetSideBorderColor sets the cell's side border color.
func (_ggde *TableCell )SetSideBorderColor (side CellBorderSide ,col Color ){switch side {case CellBorderSideTop :_ggde ._cgeda =col ;case CellBorderSideBottom :_ggde ._edac =col ;case CellBorderSideLeft :_ggde ._ffcfc =col ;case CellBorderSideRight :_ggde ._fcggd =col ;
};};

// SetLevelOffset sets the amount of space an indentation level occupies.
func (_egab *TOCLine )SetLevelOffset (levelOffset float64 ){_egab ._cggdd =levelOffset ;_egab ._ddca ._dfcc .Left =_egab ._ebfc +float64 (_egab ._dcae -1)*_egab ._cggdd ;};func _dccec (_fcbg *_ca .PdfAnnotationLink )*_ca .PdfAnnotationLink {if _fcbg ==nil {return nil ;
};_ccda :=_ca .NewPdfAnnotationLink ();_ccda .BS =_fcbg .BS ;_ccda .A =_fcbg .A ;if _deage ,_cffea :=_fcbg .GetAction ();_cffea ==nil &&_deage !=nil {_ccda .SetAction (_deage );};if _aedg ,_aacag :=_fcbg .Dest .(*_bc .PdfObjectArray );_aacag {_ccda .Dest =_bc .MakeArray (_aedg .Elements ()...);
};return _ccda ;};

// Rectangle defines a rectangle with upper left corner at (x,y) and a specified width and height.  The rectangle
// can have a colored fill and/or border with a specified width.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Rectangle struct{_fec float64 ;_dgeg float64 ;_fdbbf float64 ;_acbf float64 ;_dbege Positioning ;_eadba Color ;_agcg float64 ;_gdad Color ;_bbgbf float64 ;_accg float64 ;_gaddfd float64 ;_gdbeg float64 ;_gfbb float64 ;_cbbbd float64 ;};

// SetColumnWidths sets the fractional column widths.
// Each width should be in the range 0-1 and is a fraction of the table width.
// The number of width inputs must match number of columns, otherwise an error is returned.
func (_dcgcc *Table )SetColumnWidths (widths ...float64 )error {if len (widths )!=_dcgcc ._dcff {_db .Log .Debug ("M\u0069\u0073\u006d\u0061\u0074\u0063\u0068\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020o\u0066\u0020\u0077\u0069\u0064\u0074\u0068\u0073\u0020\u0061nd\u0020\u0063\u006fl\u0075m\u006e\u0073");
return _c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_dcgcc ._dabge =widths ;return nil ;};

// Text sets the text content of the Paragraph.
func (_ggbbe *Paragraph )Text ()string {return _ggbbe ._aafb };

// SetStyleLeft sets border style for left side.
func (_dfg *border )SetStyleLeft (style CellBorderStyle ){_dfg ._cea =style };

// SetLineHeight sets the line height (1.0 default).
func (_bbgde *StyledParagraph )SetLineHeight (lineheight float64 ){_bbgde ._bcfdf =lineheight };

// SetVerticalAlignment set the cell's vertical alignment of content.
// Can be one of:
// - CellHorizontalAlignmentTop
// - CellHorizontalAlignmentMiddle
// - CellHorizontalAlignmentBottom
func (_baacb *TableCell )SetVerticalAlignment (valign CellVerticalAlignment ){_baacb ._bfaeb =valign };func (_dgdca *TableCell )height (_ggdfe float64 )float64 {var _dbbdd float64 ;switch _bcee :=_dgdca ._ebgg .(type ){case *Paragraph :if _bcee ._cece {_bcee .SetWidth (_ggdfe -_dgdca ._ggeb -_bcee ._cbcfd .Left -_bcee ._cbcfd .Right );
};_dbbdd =_bcee .Height ()+_bcee ._cbcfd .Top +_bcee ._cbcfd .Bottom +0.5*_bcee ._fcbfd *_bcee ._fdeec ;case *StyledParagraph :if _bcee ._debf {_bcee .SetWidth (_ggdfe -_dgdca ._ggeb -_bcee ._dfcc .Left -_bcee ._dfcc .Right );};_dbbdd =_bcee .Height ()+_bcee ._dfcc .Top +_bcee ._dfcc .Bottom +0.5*_bcee .getTextHeight ();
case *Image :_bcee .applyFitMode (_ggdfe -_dgdca ._ggeb );_dbbdd =_bcee .Height ()+_bcee ._ebea .Top +_bcee ._ebea .Bottom ;case *Table :_bcee .updateRowHeights (_ggdfe -_dgdca ._ggeb -_bcee ._ecffd .Left -_bcee ._ecffd .Right );_dbbdd =_bcee .Height ()+_bcee ._ecffd .Top +_bcee ._ecffd .Bottom ;
case *List :_dbbdd =_bcee .tableHeight (_ggdfe -_dgdca ._ggeb )+_bcee ._cfdg .Top +_bcee ._cfdg .Bottom ;case *Division :_dbbdd =_bcee .ctxHeight (_ggdfe -_dgdca ._ggeb )+_bcee ._fdea .Top +_bcee ._fdea .Bottom ;case *Chart :_dbbdd =_bcee .Height ()+_bcee ._cfbc .Top +_bcee ._cfbc .Bottom ;
case *Rectangle :_dbbdd =_bcee .Height ();case *Ellipse :_dbbdd =_bcee .Height ();};return _dbbdd ;};func _ebeaa (_efdaca string ,_cffed ,_ebbb TextStyle )*TOC {_edcf :=_ebbb ;_edcf .FontSize =14;_caeb :=_fedb (_edcf );_caeb .SetEnableWrap (true );_caeb .SetTextAlignment (TextAlignmentLeft );
_caeb .SetMargins (0,0,0,5);_ggfg :=_caeb .Append (_efdaca );_ggfg .Style =_edcf ;return &TOC {_ebcb :_caeb ,_dbeba :[]*TOCLine {},_afca :_cffed ,_fgbc :_cffed ,_agecd :_cffed ,_fgbbf :_cffed ,_debcf :"\u002e",_febe :10,_adde :Margins {0,0,2,2},_degfea :PositionRelative ,_dgee :_cffed ,_abba :true };
};func (_dbee *List )tableHeight (_ecbc float64 )float64 {var _afagc float64 ;for _ ,_cbcb :=range _dbee ._dfcd {switch _fdgaa :=_cbcb ._fgdd .(type ){case *Paragraph :_ccdca :=_fdgaa ;if _ccdca ._cece {_ccdca .SetWidth (_ecbc );};_afagc +=_ccdca .Height ()+_ccdca ._cbcfd .Bottom +_ccdca ._cbcfd .Bottom ;
_afagc +=0.5*_ccdca ._fcbfd *_ccdca ._fdeec ;case *StyledParagraph :_edff :=_fdgaa ;if _edff ._debf {_edff .SetWidth (_ecbc );};_afagc +=_edff .Height ()+_edff ._dfcc .Top +_edff ._dfcc .Bottom ;_afagc +=0.5*_edff .getTextHeight ();default:_afagc +=_cbcb ._fgdd .Height ();
};};return _afagc ;};

// DrawWithContext draws the Block using the specified drawing context.
func (_aca *Block )DrawWithContext (d Drawable ,ctx DrawContext )error {_ged ,_ ,_gce :=d .GeneratePageBlocks (ctx );if _gce !=nil {return _gce ;};if len (_ged )!=1{return _c .New ("\u0074\u006f\u006f\u0020ma\u006e\u0079\u0020\u006f\u0075\u0074\u0070\u0075\u0074\u0020\u0062\u006c\u006f\u0063k\u0073");
};for _ ,_bcc :=range _ged {if _caa :=_aca .mergeBlocks (_bcc );_caa !=nil {return _caa ;};};return nil ;};

// Chart represents a chart drawable.
// It is used to render unichart chart components using a creator instance.
type Chart struct{_fdc _g .ChartRenderable ;_ffd Positioning ;_cceg float64 ;_daa float64 ;_cfbc Margins ;};

// SetLineColor sets the line color.
func (_fbbdg *Polyline )SetLineColor (color Color ){_fbbdg ._abfdb .LineColor =_geg (color )};

// MoveX moves the drawing context to absolute position x.
func (_ddd *Creator )MoveX (x float64 ){_ddd ._bgfa .X =x };

// FooterFunctionArgs holds the input arguments to a footer drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FooterFunctionArgs struct{PageNum int ;TotalPages int ;};

// SetShowLinks sets visibility of links for the TOC lines.
func (_dced *TOC )SetShowLinks (showLinks bool ){_dced ._abba =showLinks };

// SetTextAlignment sets the horizontal alignment of the text within the space provided.
func (_cgedf *Paragraph )SetTextAlignment (align TextAlignment ){_cgedf ._gddc =align };

// SetTextVerticalAlignment sets the vertical alignment of the text within the
// bounds of the styled paragraph.
func (_gcbc *StyledParagraph )SetTextVerticalAlignment (align TextVerticalAlignment ){_gcbc ._aaac =align ;};func _ffca (_adafc ,_dgbg ,_fac ,_aace float64 )*Rectangle {return &Rectangle {_fec :_adafc ,_dgeg :_dgbg ,_fdbbf :_fac ,_acbf :_aace ,_gdad :ColorBlack ,_bbgbf :1.0,_agcg :1.0,_accg :1.0,_dbege :PositionAbsolute };
};

// GetHeading returns the chapter heading paragraph. Used to give access to address style: font, sizing etc.
func (_cbbc *Chapter )GetHeading ()*Paragraph {return _cbbc ._cbd };

// SetEncoder sets the encoding/compression mechanism for the image.
func (_fdfa *Image )SetEncoder (encoder _bc .StreamEncoder ){_fdfa ._fgggb =encoder };

// NewTextStyle creates a new text style object which can be used to style
// chunks of text.
// Default attributes:
// Font: Helvetica
// Font size: 10
// Encoding: WinAnsiEncoding
// Text color: black
func (_eebb *Creator )NewTextStyle ()TextStyle {return _fbgaa (_eebb ._agdc )};

// Height returns Ellipse's document height.
func (_ffecc *Ellipse )Height ()float64 {return _ffecc ._efaa };

// Width returns the cell's width based on the input draw context.
func (_dcef *TableCell )Width (ctx DrawContext )float64 {_cbbaa :=float64 (0.0);for _febg :=0;_febg < _dcef ._bgcdf ;_febg ++{_cbbaa +=_dcef ._cgdbb ._dabge [_dcef ._abfg +_febg -1];};_eagdd :=ctx .Width *_cbbaa ;return _eagdd ;};func _cgfc (_eaee ,_abed ,_eagbd TextChunk ,_caba uint ,_dcac TextStyle )*TOCLine {_ffacb :=_fedb (_dcac );
_ffacb .SetEnableWrap (true );_ffacb .SetTextAlignment (TextAlignmentLeft );_ffacb .SetMargins (0,0,2,2);_cgfe :=&TOCLine {_ddca :_ffacb ,Number :_eaee ,Title :_abed ,Page :_eagbd ,Separator :TextChunk {Text :"\u002e",Style :_dcac },_ebfc :0,_dcae :_caba ,_cggdd :10,_bceda :PositionRelative };
_ffacb ._dfcc .Left =_cgfe ._ebfc +float64 (_cgfe ._dcae -1)*_cgfe ._cggdd ;_ffacb ._efeab =_cgfe .prepareParagraph ;return _cgfe ;};

// NewStyledParagraph creates a new styled paragraph.
// Default attributes:
// Font: Helvetica,
// Font size: 10
// Encoding: WinAnsiEncoding
// Wrap: enabled
// Text color: black
func (_aega *Creator )NewStyledParagraph ()*StyledParagraph {return _fedb (_aega .NewTextStyle ())};

// SetMargins sets the Chapter margins: left, right, top, bottom.
// Typically not needed as the creator's page margins are used.
func (_bebd *Chapter )SetMargins (left ,right ,top ,bottom float64 ){_bebd ._ebg .Left =left ;_bebd ._ebg .Right =right ;_bebd ._ebg .Top =top ;_bebd ._ebg .Bottom =bottom ;};type marginDrawable interface{VectorDrawable ;GetMargins ()(float64 ,float64 ,float64 ,float64 );
};

// SetAddressHeadingStyle sets the style properties used to render the
// heading of the invoice address sections.
func (_ggcd *Invoice )SetAddressHeadingStyle (style TextStyle ){_ggcd ._fabd =style };

// FrontpageFunctionArgs holds the input arguments to a front page drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type FrontpageFunctionArgs struct{PageNum int ;TotalPages int ;};

// AddInternalLink adds a new internal link to the paragraph.
// The text parameter represents the text that is displayed.
// The user is taken to the specified page, at the specified x and y
// coordinates. Position 0, 0 is at the top left of the page.
// The zoom of the destination page is controlled with the zoom
// parameter. Pass in 0 to keep the current zoom value.
func (_bdf *StyledParagraph )AddInternalLink (text string ,page int64 ,x ,y ,zoom float64 )*TextChunk {_cagc :=NewTextChunk (text ,_bdf ._ffdf );_cagc ._cgbd =_cfbf (page -1,x ,y ,zoom );return _bdf .appendChunk (_cagc );};

// TextChunk represents a chunk of text along with a particular style.
type TextChunk struct{

// The text that is being rendered in the PDF.
Text string ;

// The style of the text being rendered.
Style TextStyle ;_cgbd *_ca .PdfAnnotation ;_baacc bool ;};

// AddAnnotation adds an annotation to the current block.
// The annotation will be added to the page the block will be rendered on.
func (_ada *Block )AddAnnotation (annotation *_ca .PdfAnnotation ){for _ ,_abe :=range _ada ._ab {if _abe ==annotation {return ;};};_ada ._ab =append (_ada ._ab ,annotation );};

// Lines returns all the lines the table of contents has.
func (_dcdc *TOC )Lines ()[]*TOCLine {return _dcdc ._dbeba };

// InsertColumn inserts a column in the line items table at the specified index.
func (_bfbg *Invoice )InsertColumn (index uint ,description string )*InvoiceCell {_cgee :=uint (len (_bfbg ._bfda ));if index > _cgee {index =_cgee ;};_ddeb :=_bfbg .NewColumn (description );_bfbg ._bfda =append (_bfbg ._bfda [:index ],append ([]*InvoiceCell {_ddeb },_bfbg ._bfda [index :]...)...);
return _ddeb ;};

// GeneratePageBlocks draws the block contents on a template Page block.
// Implements the Drawable interface.
func (_gbc *Block )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_gec :=_acc .NewContentCreator ();_cbf ,_gbb :=_gbc .Width (),_gbc .Height ();if _gbc ._fbg .IsRelative (){_gec .Translate (ctx .X ,ctx .PageHeight -ctx .Y -_gbb );
}else {_gec .Translate (_gbc ._ace ,ctx .PageHeight -_gbc ._ag -_gbb );};_ggc :=_gbb ;if _gbc ._da !=0{_gec .Translate (_cbf /2,_gbb /2);_gec .RotateDeg (_gbc ._da );_gec .Translate (-_cbf /2,-_gbb /2);_ ,_ggc =_gbc .RotatedSize ();};if _gbc ._fbg .IsRelative (){ctx .Y +=_ggc ;
};_eg :=_gbc .duplicate ();_bbd :=append (*_gec .Operations (),*_eg ._gg ...);_bbd .WrapIfNeeded ();_eg ._gg =&_bbd ;return []*Block {_eg },ctx ,nil ;};

// ColorRGBFrom8bit creates a Color from 8-bit (0-255) r,g,b values.
// Example:
//   red := ColorRGBFrom8Bit(255, 0, 0)
func ColorRGBFrom8bit (r ,g ,b byte )Color {return rgbColor {_acgf :float64 (r )/255.0,_fcbcc :float64 (g )/255.0,_ebf :float64 (b )/255.0};};

// Height returns the current page height.
func (_gbag *Creator )Height ()float64 {return _gbag ._fcdb };func _gbga (_afce []byte )(*Image ,error ){_cfaf :=_a .NewReader (_afce );_cged ,_gdeac :=_ca .ImageHandling .Read (_cfaf );if _gdeac !=nil {_db .Log .Error ("\u0045\u0072\u0072or\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_gdeac );
return nil ,_gdeac ;};return _eabb (_cged );};func (_ga *Block )transform (_feb _gd .Matrix ){_ec :=_acc .NewContentCreator ().Add_cm (_feb [0],_feb [1],_feb [3],_feb [4],_feb [6],_feb [7]).Operations ();*_ga ._gg =append (*_ec ,*_ga ._gg ...);_ga ._gg .WrapIfNeeded ();
};func (_ggcce *TableCell )width (_ebfa []float64 ,_gacd float64 )float64 {_fccee :=float64 (0.0);for _dcab :=0;_dcab < _ggcce ._bgcdf ;_dcab ++{_fccee +=_ebfa [_ggcce ._abfg +_dcab -1];};return _fccee *_gacd ;};

// Polygon represents a polygon shape.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Polygon struct{_ecdf *_ee .Polygon ;_cdgfg float64 ;_debce float64 ;};

// Lines returns all the rows of the invoice line items table.
func (_egfe *Invoice )Lines ()[][]*InvoiceCell {return _egfe ._ecff };

// SetSubtotal sets the subtotal of the invoice.
func (_ccdcd *Invoice )SetSubtotal (value string ){_ccdcd ._dbedcc [1].Value =value };

// CreateFrontPage sets a function to generate a front Page.
func (_ccgg *Creator )CreateFrontPage (genFrontPageFunc func (_bef FrontpageFunctionArgs )){_ccgg ._gcc =genFrontPageFunc ;};

// NewImage create a new image from a unidoc image (model.Image).
func (_dbbde *Creator )NewImage (img *_ca .Image )(*Image ,error ){return _eabb (img )};

// SetStyleBottom sets border style for bottom side.
func (_beg *border )SetStyleBottom (style CellBorderStyle ){_beg ._dbb =style };

// Line defines a line between point 1 (X1,Y1) and point 2 (X2,Y2).  The line ending styles can be none (regular line),
// or arrows at either end.  The line also has a specified width, color and opacity.
// Implements the Drawable interface and can be drawn on PDF using the Creator.
type Line struct{_dfgf float64 ;_ddda float64 ;_fceg float64 ;_baee float64 ;_aaad Color ;_efbd float64 ;};

// NewBlock creates a new Block with specified width and height.
func NewBlock (width float64 ,height float64 )*Block {_gb :=&Block {};_gb ._gg =&_acc .ContentStreamOperations {};_gb ._eee =_ca .NewPdfPageResources ();_gb ._ce =width ;_gb ._cac =height ;return _gb ;};func _cfag (_cegdd *Block ,_bfe *Paragraph ,_fcagg DrawContext )(DrawContext ,error ){_cgea :=1;
_adbeb :=_bc .PdfObjectName ("\u0046\u006f\u006e\u0074"+_dea .Itoa (_cgea ));for _cegdd ._eee .HasFontByName (_adbeb ){_cgea ++;_adbeb =_bc .PdfObjectName ("\u0046\u006f\u006e\u0074"+_dea .Itoa (_cgea ));};_gfa :=_cegdd ._eee .SetFontByName (_adbeb ,_bfe ._eecf .ToPdfObject ());
if _gfa !=nil {return _fcagg ,_gfa ;};_bfe .wrapText ();_fba :=_acc .NewContentCreator ();_fba .Add_q ();_aegf :=_fcagg .PageHeight -_fcagg .Y -_bfe ._fcbfd *_bfe ._fdeec ;_fba .Translate (_fcagg .X ,_aegf );if _bfe ._eac !=0{_fba .RotateDeg (_bfe ._eac );
};_fba .Add_BT ().SetNonStrokingColor (_geg (_bfe ._bceff )).Add_Tf (_adbeb ,_bfe ._fcbfd ).Add_TL (_bfe ._fcbfd *_bfe ._fdeec );for _ggaca ,_efbg :=range _bfe ._bedb {if _ggaca !=0{_fba .Add_Tstar ();};_efed :=[]rune (_efbg );_afgef :=0.0;_deea :=0;for _acgd ,_gfdab :=range _efed {if _gfdab ==' '{_deea ++;
continue ;};if _gfdab =='\u000A'{continue ;};_acge ,_gcfa :=_bfe ._eecf .GetRuneMetrics (_gfdab );if !_gcfa {_db .Log .Debug ("\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0075\u006e\u0065\u0020\u0069=\u0025\u0064\u0020\u0072\u0075\u006e\u0065=\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0069n\u0020\u0066\u006f\u006e\u0074\u0020\u0025\u0073\u0020\u0025\u0073",_acgd ,_gfdab ,_gfdab ,_bfe ._eecf .BaseFont (),_bfe ._eecf .Subtype ());
return _fcagg ,_c .New ("\u0075\u006e\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0065\u0078\u0074\u0020\u0067\u006c\u0079p\u0068");};_afgef +=_bfe ._fcbfd *_acge .Wx ;};var _agdcb []_bc .PdfObject ;_eefaa ,_gbgd :=_bfe ._eecf .GetRuneMetrics (' ');
if !_gbgd {return _fcagg ,_c .New ("\u0074\u0068e \u0066\u006f\u006et\u0020\u0064\u006f\u0065s n\u006ft \u0068\u0061\u0076\u0065\u0020\u0061\u0020sp\u0061\u0063\u0065\u0020\u0067\u006c\u0079p\u0068");};_fgbec :=_eefaa .Wx ;switch _bfe ._gddc {case TextAlignmentJustify :if _deea > 0&&_ggaca < len (_bfe ._bedb )-1{_fgbec =(_bfe ._deda *1000.0-_afgef )/float64 (_deea )/_bfe ._fcbfd ;
};case TextAlignmentCenter :_edce :=_afgef +float64 (_deea )*_fgbec *_bfe ._fcbfd ;_gafg :=(_bfe ._deda *1000.0-_edce )/2/_bfe ._fcbfd ;_agdcb =append (_agdcb ,_bc .MakeFloat (-_gafg ));case TextAlignmentRight :_bcfb :=_afgef +float64 (_deea )*_fgbec *_bfe ._fcbfd ;
_ffgfb :=(_bfe ._deda *1000.0-_bcfb )/_bfe ._fcbfd ;_agdcb =append (_agdcb ,_bc .MakeFloat (-_ffgfb ));};_gfff :=_bfe ._eecf .Encoder ();var _cgdc []byte ;for _ ,_aacc :=range _efed {if _aacc =='\u000A'{continue ;};if _aacc ==' '{if len (_cgdc )> 0{_agdcb =append (_agdcb ,_bc .MakeStringFromBytes (_cgdc ));
_cgdc =nil ;};_agdcb =append (_agdcb ,_bc .MakeFloat (-_fgbec ));}else {if _ ,_egfa :=_gfff .RuneToCharcode (_aacc );!_egfa {_gfa =UnsupportedRuneError {Message :_cba .Sprintf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0075\u006e\u0065 \u0069\u006e\u0020\u0074\u0065\u0078\u0074\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u003a\u0020\u0025\u0023\u0078\u0020\u0028\u0025\u0063\u0029",_aacc ,_aacc ),Rune :_aacc };
_fcagg ._cffe =append (_fcagg ._cffe ,_gfa );_db .Log .Debug (_gfa .Error ());if _fcagg ._eadb <=0{continue ;};_aacc =_fcagg ._eadb ;};_cgdc =append (_cgdc ,_gfff .Encode (string (_aacc ))...);};};if len (_cgdc )> 0{_agdcb =append (_agdcb ,_bc .MakeStringFromBytes (_cgdc ));
};_fba .Add_TJ (_agdcb ...);};_fba .Add_ET ();_fba .Add_Q ();_ceaf :=_fba .Operations ();_ceaf .WrapIfNeeded ();_cegdd .addContents (_ceaf );if _bfe ._dacd .IsRelative (){_gbcc :=_bfe .Height ();_fcagg .Y +=_gbcc ;_fcagg .Height -=_gbcc ;if _fcagg .Inline {_fcagg .X +=_bfe .Width ()+_bfe ._cbcfd .Right ;
};};return _fcagg ,nil ;};func _fedb (_gccb TextStyle )*StyledParagraph {return &StyledParagraph {_gagd :[]*TextChunk {},_accc :_gccb ,_ffdf :_gcac (_gccb .Font ),_bcfdf :1.0,_ecdg :TextAlignmentLeft ,_debf :true ,_cbcc :true ,_gddfe :false ,_bffda :0,_deaacc :1,_aaaaa :1,_dead :PositionRelative };
};func (_gaab *Invoice )setCellBorder (_ccbe *TableCell ,_cdac *InvoiceCell ){for _ ,_ccegd :=range _cdac .BorderSides {_ccbe .SetBorder (_ccegd ,CellBorderStyleSingle ,_cdac .BorderWidth );};_ccbe .SetBorderColor (_cdac .BorderColor );};

// Margins returns the margins of the component.
func (_bfae *Division )Margins ()(_edag ,_fede ,_gac ,_bbef float64 ){return _bfae ._fdea .Left ,_bfae ._fdea .Right ,_bfae ._fdea .Top ,_bfae ._fdea .Bottom ;};func _aaaeg (_eaebe int )*Table {_gfdbd :=&Table {_dcff :_eaebe ,_ddefb :10.0,_dabge :[]float64 {},_accdf :[]float64 {},_deag :[]*TableCell {},_accf :make ([]int ,_eaebe ),_acccg :true };
_gfdbd .resetColumnWidths ();return _gfdbd ;};

// EnablePageWrap controls whether the division is wrapped across pages.
// If disabled, the division is moved in its entirety on a new page, if it
// does not fit in the available height. By default, page wrapping is enabled.
// If the height of the division is larger than an entire page, wrapping is
// enabled automatically in order to avoid unwanted behavior.
// Currently, page wrapping can only be disabled for vertical divisions.
func (_cced *Division )EnablePageWrap (enable bool ){_cced ._gead =enable };

// Height returns the height of the division, assuming all components are
// stacked on top of each other.
func (_acff *Division )Height ()float64 {var _gbdg float64 ;for _ ,_edfc :=range _acff ._bdcb {switch _bgfaa :=_edfc .(type ){case marginDrawable :_ ,_ ,_aefe ,_dfcb :=_bgfaa .GetMargins ();_gbdg +=_bgfaa .Height ()+_aefe +_dfcb ;default:_gbdg +=_bgfaa .Height ();
};};return _gbdg ;};

// GeneratePageBlocks draws the curve onto page blocks.
func (_dffa *Curve )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_bcad :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_egcb :=_acc .NewContentCreator ();_egcb .Add_q ().Add_w (_dffa ._bcdb ).SetStrokingColor (_geg (_dffa ._feefb )).Add_m (_dffa ._fdbb ,ctx .PageHeight -_dffa ._fefc ).Add_v (_dffa ._gaebg ,ctx .PageHeight -_dffa ._gef ,_dffa ._cegba ,ctx .PageHeight -_dffa ._gfce ).Add_S ().Add_Q ();
_ddgf :=_bcad .addContentsByString (_egcb .String ());if _ddgf !=nil {return nil ,ctx ,_ddgf ;};return []*Block {_bcad },ctx ,nil ;};

// Width returns the current page width.
func (_dagg *Creator )Width ()float64 {return _dagg ._fdga };

// DrawContext defines the drawing context. The DrawContext is continuously used and updated when
// drawing the page contents in relative mode.  Keeps track of current X, Y position, available
// height as well as other page parameters such as margins and dimensions.
type DrawContext struct{

// Current page number.
Page int ;

// Current position.  In a relative positioning mode, a drawable will be placed at these coordinates.
X ,Y float64 ;

// Context dimensions.  Available width and height (on current page).
Width ,Height float64 ;

// Page Margins.
Margins Margins ;

// Absolute Page size, widths and height.
PageWidth float64 ;PageHeight float64 ;

// Controls whether the components are stacked horizontally
Inline bool ;_eadb rune ;_cffe []error ;};

// Reset removes all the text chunks the paragraph contains.
func (_fgfd *StyledParagraph )Reset (){_fgfd ._gagd =[]*TextChunk {}};type listItem struct{_fgdd VectorDrawable ;_dgadc TextChunk ;};

// SetBackground sets the background properties of the component.
func (_afdf *Division )SetBackground (background *Background ){_afdf ._eebc =background };

// DrawHeader sets a function to draw a header on created output pages.
func (_bfba *Creator )DrawHeader (drawHeaderFunc func (_dda *Block ,_cdbf HeaderFunctionArgs )){_bfba ._cfdb =drawHeaderFunc ;};const (TextAlignmentLeft TextAlignment =iota ;TextAlignmentRight ;TextAlignmentCenter ;TextAlignmentJustify ;);

// SetLineNumberStyle sets the style for the numbers part of all new lines
// of the table of contents.
func (_fgda *TOC )SetLineNumberStyle (style TextStyle ){_fgda ._afca =style };

// SetBorder sets the cell's border style.
func (_fcebd *TableCell )SetBorder (side CellBorderSide ,style CellBorderStyle ,width float64 ){if style ==CellBorderStyleSingle &&side ==CellBorderSideAll {_fcebd ._fdgb =CellBorderStyleSingle ;_fcebd ._eegg =width ;_fcebd ._eege =CellBorderStyleSingle ;
_fcebd ._ddee =width ;_fcebd ._eaab =CellBorderStyleSingle ;_fcebd ._cdcc =width ;_fcebd ._cadgb =CellBorderStyleSingle ;_fcebd ._bfcba =width ;}else if style ==CellBorderStyleDouble &&side ==CellBorderSideAll {_fcebd ._fdgb =CellBorderStyleDouble ;_fcebd ._eegg =width ;
_fcebd ._eege =CellBorderStyleDouble ;_fcebd ._ddee =width ;_fcebd ._eaab =CellBorderStyleDouble ;_fcebd ._cdcc =width ;_fcebd ._cadgb =CellBorderStyleDouble ;_fcebd ._bfcba =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideLeft {_fcebd ._fdgb =style ;
_fcebd ._eegg =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideBottom {_fcebd ._eege =style ;_fcebd ._ddee =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideRight {_fcebd ._eaab =style ;
_fcebd ._cdcc =width ;}else if (style ==CellBorderStyleSingle ||style ==CellBorderStyleDouble )&&side ==CellBorderSideTop {_fcebd ._cadgb =style ;_fcebd ._bfcba =width ;};};

// SetLineOpacity sets the line opacity.
func (_dbeb *Polyline )SetLineOpacity (opacity float64 ){_dbeb ._faae =opacity };

// GetMargins returns the Image's margins: left, right, top, bottom.
func (_abd *Image )GetMargins ()(float64 ,float64 ,float64 ,float64 ){return _abd ._ebea .Left ,_abd ._ebea .Right ,_abd ._ebea .Top ,_abd ._ebea .Bottom ;};

// GetRowHeight returns the height of the specified row.
func (_fccb *Table )GetRowHeight (row int )(float64 ,error ){if row < 1||row > len (_fccb ._accdf ){return 0,_c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};return _fccb ._accdf [row -1],nil ;
};func _dgdcc (_agda []_ee .Point )*Polyline {return &Polyline {_abfdb :&_ee .Polyline {Points :_agda ,LineColor :_ca .NewPdfColorDeviceRGB (0,0,0),LineWidth :1.0},_faae :1.0};};

// NewChapter creates a new chapter with the specified title as the heading.
func (_abac *Creator )NewChapter (title string )*Chapter {_abac ._edgf ++;_aggdd :=_abac .NewTextStyle ();_aggdd .FontSize =16;return _fbf (nil ,_abac ._dadcd ,_abac ._cbgc ,title ,_abac ._edgf ,_aggdd );};

// SetFontSize sets the font size in document units (points).
func (_bbgaf *Paragraph )SetFontSize (fontSize float64 ){_bbgaf ._fcbfd =fontSize };

// NewFilledCurve returns a instance of filled curve.
func (_cbdga *Creator )NewFilledCurve ()*FilledCurve {return _aedd ()};

// SetBorderWidth sets the border width.
func (_baa *PolyBezierCurve )SetBorderWidth (borderWidth float64 ){_baa ._gggb .BorderWidth =borderWidth ;};

// RotatedSize returns the width and height of the rotated block.
func (_fd *Block )RotatedSize ()(float64 ,float64 ){_ ,_ ,_cdc ,_daca :=_dgfg (_fd ._ce ,_fd ._cac ,_fd ._da );return _cdc ,_daca ;};

// SetWidthLeft sets border width for left.
func (_dceag *border )SetWidthLeft (bw float64 ){_dceag ._acf =bw };

// Cols returns the total number of columns the table has.
func (_ccbb *Table )Cols ()int {return _ccbb ._dcff };

// WriteToFile writes the Creator output to file specified by path.
func (_ebcd *Creator )WriteToFile (outputPath string )error {_eefa ,_cfed :=_d .Create (outputPath );if _cfed !=nil {return _cfed ;};defer _eefa .Close ();return _ebcd .Write (_eefa );};

// SetLineMargins sets the margins for all new lines of the table of contents.
func (_efbc *TOC )SetLineMargins (left ,right ,top ,bottom float64 ){_eefde :=&_efbc ._adde ;_eefde .Left =left ;_eefde .Right =right ;_eefde .Top =top ;_eefde .Bottom =bottom ;};

// Indent returns the left offset of the list when nested into another list.
func (_ddfg *List )Indent ()float64 {return _ddfg ._abgd };func (_fegbf *TextChunk )clone ()*TextChunk {_eaea :=*_fegbf ;_eaea ._cgbd =_eebd (_fegbf ._cgbd );return &_eaea ;};

// SetFillOpacity sets the fill opacity.
func (_caed *Rectangle )SetFillOpacity (opacity float64 ){_caed ._agcg =opacity };

// Creator is a wrapper around functionality for creating PDF reports and/or adding new
// content onto imported PDF pages, etc.
type Creator struct{

// Errors keeps error messages that should not interrupt pdf processing and to be checked later.
Errors []error ;

// UnsupportedCharacterReplacement is character that will be used to replace unsupported glyph.
// The value will be passed to drawing context.
UnsupportedCharacterReplacement rune ;_fbcf []*_ca .PdfPage ;_acfg map[*_ca .PdfPage ]*Block ;_aaed map[*_ca .PdfPage ]*pageTransformations ;_dfde *_ca .PdfPage ;_bbga PageSize ;_bgfa DrawContext ;_bddf Margins ;_fdga ,_fcdb float64 ;_edgf int ;_gcc func (_dcf FrontpageFunctionArgs );
_ccg func (_caaa *TOC )error ;_cfdb func (_bbea *Block ,_bgbd HeaderFunctionArgs );_fag func (_dee *Block ,_dge FooterFunctionArgs );_caga func (_fagf PageFinalizeFunctionArgs )error ;_ccc func (_efe *_ca .PdfWriter )error ;_fff bool ;

// Controls whether a table of contents will be generated.
AddTOC bool ;_dadcd *TOC ;

// Controls whether outlines will be generated.
AddOutlines bool ;_cbgc *_ca .Outline ;_bdbc *_ca .PdfOutlineTreeNode ;_gadd *_ca .PdfAcroForm ;_ecb _bc .PdfObject ;_dcgf _ca .Optimizer ;_ddg []*_ca .PdfFont ;_agdc *_ca .PdfFont ;_gfd *_ca .PdfFont ;};func (_cafff *Table )resetColumnWidths (){_cafff ._dabge =[]float64 {};
_cfad :=float64 (1.0)/float64 (_cafff ._dcff );for _gafa :=0;_gafa < _cafff ._dcff ;_gafa ++{_cafff ._dabge =append (_cafff ._dabge ,_cfad );};};

// SetLineTitleStyle sets the style for the title part of all new lines
// of the table of contents.
func (_ffee *TOC )SetLineTitleStyle (style TextStyle ){_ffee ._fgbc =style };

// GetCoords returns the (x1, y1), (x2, y2) points defining the Line.
func (_fcffa *Line )GetCoords ()(float64 ,float64 ,float64 ,float64 ){return _fcffa ._dfgf ,_fcffa ._ddda ,_fcffa ._fceg ,_fcffa ._baee ;};

// SetWidthTop sets border width for top.
func (_adf *border )SetWidthTop (bw float64 ){_adf ._dgd =bw };

// EnableWordWrap sets the paragraph word wrap flag.
func (_bffdd *StyledParagraph )EnableWordWrap (val bool ){_bffdd ._gddfe =val };

// InvoiceCell represents any cell belonging to a table from the invoice
// template. The main tables are the invoice information table, the line
// items table and totals table. Contains the text value of the cell and
// the style properties of the cell.
type InvoiceCell struct{InvoiceCellProps ;Value string ;};

// SetWidth set the Image's document width to specified w. This does not change the raw image data, i.e.
// no actual scaling of data is performed. That is handled by the PDF viewer.
func (_efee *Image )SetWidth (w float64 ){_efee ._dddg =w };

// SetLineSeparator sets the separator for all new lines of the table of contents.
func (_fdaa *TOC )SetLineSeparator (separator string ){_fdaa ._debcf =separator };

// SetMargins sets the Paragraph's margins.
func (_ggcg *Paragraph )SetMargins (left ,right ,top ,bottom float64 ){_ggcg ._cbcfd .Left =left ;_ggcg ._cbcfd .Right =right ;_ggcg ._cbcfd .Top =top ;_ggcg ._cbcfd .Bottom =bottom ;};

// HeaderFunctionArgs holds the input arguments to a header drawing function.
// It is designed as a struct, so additional parameters can be added in the future with backwards
// compatibility.
type HeaderFunctionArgs struct{PageNum int ;TotalPages int ;};func _ccbcb (_cfafg ,_cbdaf ,_eead string ,_dfff uint ,_daeg TextStyle )*TOCLine {return _cgfc (TextChunk {Text :_cfafg ,Style :_daeg },TextChunk {Text :_cbdaf ,Style :_daeg },TextChunk {Text :_eead ,Style :_daeg },_dfff ,_daeg );
};func _dg (_edg *_acc .ContentStreamOperations ,_bce *_ca .PdfPageResources ,_aag *_acc .ContentStreamOperations ,_deaf *_ca .PdfPageResources )error {_dd :=map[_bc .PdfObjectName ]_bc .PdfObjectName {};_bbdc :=map[_bc .PdfObjectName ]_bc .PdfObjectName {};
_fgd :=map[_bc .PdfObjectName ]_bc .PdfObjectName {};_gggg :=map[_bc .PdfObjectName ]_bc .PdfObjectName {};_cgc :=map[_bc .PdfObjectName ]_bc .PdfObjectName {};_bfa :=map[_bc .PdfObjectName ]_bc .PdfObjectName {};for _ ,_ege :=range *_aag {switch _ege .Operand {case "\u0044\u006f":if len (_ege .Params )==1{if _ggf ,_cbe :=_ege .Params [0].(*_bc .PdfObjectName );
_cbe {if _ ,_efb :=_dd [*_ggf ];!_efb {var _ccf _bc .PdfObjectName ;_cdd ,_ :=_deaf .GetXObjectByName (*_ggf );if _cdd !=nil {_ccf =*_ggf ;for {_bbg ,_ :=_bce .GetXObjectByName (_ccf );if _bbg ==nil ||_bbg ==_cdd {break ;};_ccf =_ccf +"\u0030";};};_bce .SetXObjectByName (_ccf ,_cdd );
_dd [*_ggf ]=_ccf ;};_cfb :=_dd [*_ggf ];_ege .Params [0]=&_cfb ;};};case "\u0054\u0066":if len (_ege .Params )==2{if _cdb ,_ff :=_ege .Params [0].(*_bc .PdfObjectName );_ff {if _ ,_egf :=_bbdc [*_cdb ];!_egf {_cefc ,_agb :=_deaf .GetFontByName (*_cdb );
_dacf :=*_cdb ;if _agb &&_cefc !=nil {_dacf =_dgf (_cdb .String (),_cefc ,_bce );};_bce .SetFontByName (_dacf ,_cefc );_bbdc [*_cdb ]=_dacf ;};_gba :=_bbdc [*_cdb ];_ege .Params [0]=&_gba ;};};case "\u0043\u0053","\u0063\u0073":if len (_ege .Params )==1{if _cbab ,_fca :=_ege .Params [0].(*_bc .PdfObjectName );
_fca {if _ ,_fed :=_fgd [*_cbab ];!_fed {var _fcc _bc .PdfObjectName ;_fbc ,_abc :=_deaf .GetColorspaceByName (*_cbab );if _abc {_fcc =*_cbab ;for {_cbg ,_eec :=_bce .GetColorspaceByName (_fcc );if !_eec ||_fbc ==_cbg {break ;};_fcc =_fcc +"\u0030";};_bce .SetColorspaceByName (_fcc ,_fbc );
_fgd [*_cbab ]=_fcc ;}else {_db .Log .Debug ("C\u006fl\u006f\u0072\u0073\u0070\u0061\u0063\u0065\u0020n\u006f\u0074\u0020\u0066ou\u006e\u0064");};};if _cfde ,_aef :=_fgd [*_cbab ];_aef {_ege .Params [0]=&_cfde ;}else {_db .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0043\u006f\u006co\u0072\u0073\u0070\u0061\u0063\u0065\u0020%\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064",*_cbab );
};};};case "\u0053\u0043\u004e","\u0073\u0063\u006e":if len (_ege .Params )==1{if _bbad ,_ea :=_ege .Params [0].(*_bc .PdfObjectName );_ea {if _ ,_fgg :=_gggg [*_bbad ];!_fgg {var _dbe _bc .PdfObjectName ;_bcg ,_dega :=_deaf .GetPatternByName (*_bbad );
if _dega {_dbe =*_bbad ;for {_ceg ,_fcfe :=_bce .GetPatternByName (_dbe );if !_fcfe ||_ceg ==_bcg {break ;};_dbe =_dbe +"\u0030";};_cde :=_bce .SetPatternByName (_dbe ,_bcg .ToPdfObject ());if _cde !=nil {return _cde ;};_gggg [*_bbad ]=_dbe ;};};if _agg ,_fdd :=_gggg [*_bbad ];
_fdd {_ege .Params [0]=&_agg ;};};};case "\u0073\u0068":if len (_ege .Params )==1{if _ecg ,_ffe :=_ege .Params [0].(*_bc .PdfObjectName );_ffe {if _ ,_eed :=_cgc [*_ecg ];!_eed {var _fdf _bc .PdfObjectName ;_eefe ,_fda :=_deaf .GetShadingByName (*_ecg );
if _fda {_fdf =*_ecg ;for {_acb ,_bdb :=_bce .GetShadingByName (_fdf );if !_bdb ||_eefe ==_acb {break ;};_fdf =_fdf +"\u0030";};_cae :=_bce .SetShadingByName (_fdf ,_eefe .ToPdfObject ());if _cae !=nil {_db .Log .Debug ("E\u0052\u0052\u004f\u0052 S\u0065t\u0020\u0073\u0068\u0061\u0064i\u006e\u0067\u003a\u0020\u0025\u0076",_cae );
return _cae ;};_cgc [*_ecg ]=_fdf ;}else {_db .Log .Debug ("\u0053\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};};if _gf ,_fee :=_cgc [*_ecg ];_fee {_ege .Params [0]=&_gf ;}else {_db .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020S\u0068\u0061\u0064\u0069\u006e\u0067\u0020\u0025\u0073 \u006e\u006f\u0074 \u0066o\u0075\u006e\u0064",*_ecg );
};};};case "\u0067\u0073":if len (_ege .Params )==1{if _fdgf ,_eda :=_ege .Params [0].(*_bc .PdfObjectName );_eda {if _ ,_abf :=_bfa [*_fdgf ];!_abf {var _aaf _bc .PdfObjectName ;_ccfd ,_ead :=_deaf .GetExtGState (*_fdgf );if _ead {_aaf =*_fdgf ;_edf :=1;
for {_eddd ,_abfc :=_bce .GetExtGState (_aaf );if !_abfc ||_ccfd ==_eddd {break ;};_aaf =_bc .PdfObjectName (_cba .Sprintf ("\u0047\u0053\u0025\u0064",_edf ));_edf ++;};};_bce .AddExtGState (_aaf ,_ccfd );_bfa [*_fdgf ]=_aaf ;};_aff :=_bfa [*_fdgf ];_ege .Params [0]=&_aff ;
};};};*_edg =append (*_edg ,_ege );};return nil ;};

// SetIncludeInTOC sets a flag to indicate whether or not to include in tOC.
func (_caff *Chapter )SetIncludeInTOC (includeInTOC bool ){_caff ._dab =includeInTOC };

// Width returns Image's document width.
func (_baff *Image )Width ()float64 {return _baff ._dddg };type pageTransformations struct{_acgb *_gd .Matrix ;_gggcg bool ;_faf bool ;};func _eebd (_ccbg *_ca .PdfAnnotation )*_ca .PdfAnnotation {if _ccbg ==nil {return nil ;};var _fgcbc *_ca .PdfAnnotation ;
switch _eaaba :=_ccbg .GetContext ().(type ){case *_ca .PdfAnnotationLink :if _ecccg :=_dccec (_eaaba );_ecccg !=nil {_fgcbc =_ecccg .PdfAnnotation ;};};return _fgcbc ;};

// SetBorderColor sets the border color.
func (_eeefg *Polygon )SetBorderColor (color Color ){_eeefg ._ecdf .BorderColor =_geg (color )};

// SetPos sets the Block's positioning to absolute mode with the specified coordinates.
func (_edd *Block )SetPos (x ,y float64 ){_edd ._fbg =PositionAbsolute ;_edd ._ace =x ;_edd ._ag =y };

// Sections returns the custom content sections of the invoice as
// title-content pairs.
func (_aagbd *Invoice )Sections ()[][2]string {return _aagbd ._edae };

// NewPolyBezierCurve creates a new composite Bezier (polybezier) curve.
func (_afd *Creator )NewPolyBezierCurve (curves []_ee .CubicBezierCurve )*PolyBezierCurve {return _aggf (curves );};

// SkipOver skips over a specified number of rows and cols.
func (_eabgb *Table )SkipOver (rows ,cols int ){_abdb :=rows *_eabgb ._dcff +cols -1;if _abdb < 0{_db .Log .Debug ("\u0054\u0061\u0062\u006c\u0065:\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0073\u006b\u0069\u0070\u0020b\u0061\u0063\u006b\u0020\u0074\u006f\u0020\u0070\u0072\u0065\u0076\u0069\u006f\u0075\u0073\u0020\u0063\u0065\u006c\u006c\u0073");
return ;};_eabgb ._ccgd +=_abdb ;};func _eaaec (_ccdcb [][]_ee .Point )*Polygon {return &Polygon {_ecdf :&_ee .Polygon {Points :_ccdcb },_cdgfg :1.0,_debce :1.0};};

// VectorDrawable is a Drawable with a specified width and height.
type VectorDrawable interface{Drawable ;

// Width returns the width of the Drawable.
Width ()float64 ;

// Height returns the height of the Drawable.
Height ()float64 ;};

// EnablePageWrap controls whether the table is wrapped across pages.
// If disabled, the table is moved in its entirety on a new page, if it
// does not fit in the available height. By default, page wrapping is enabled.
// If the height of the table is larger than an entire page, wrapping is
// enabled automatically in order to avoid unwanted behavior.
func (_gaaf *Table )EnablePageWrap (enable bool ){_gaaf ._acccg =enable };func (_gcfba *Image )makeXObject ()error {_ggbb :=_gcfba ._fgggb ;if _ggbb ==nil {_ggbb =_bc .NewFlateEncoder ();};_egcd ,_ffc :=_ca .NewXObjectImageFromImage (_gcfba ._bbeg ,nil ,_ggbb );
if _ffc !=nil {_db .Log .Error ("\u0046\u0061\u0069le\u0064\u0020\u0074\u006f\u0020\u0063\u0072\u0065\u0061t\u0065 \u0078o\u0062j\u0065\u0063\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_ffc );return _ffc ;};_gcfba ._bea =_egcd ;
return nil ;};

// PageFinalizeFunctionArgs holds the input arguments provided to the page
// finalize callback function which can be set using Creator.PageFinalize.
type PageFinalizeFunctionArgs struct{PageNum int ;PageWidth float64 ;PageHeight float64 ;TOCPages int ;TotalPages int ;};

// SetHeading sets the text and the style of the heading of the TOC component.
func (_gfge *TOC )SetHeading (text string ,style TextStyle ){_ggdafc :=_gfge .Heading ();_ggdafc .Reset ();_fffc :=_ggdafc .Append (text );_fffc .Style =style ;};

// SellerAddress returns the seller address used in the invoice template.
func (_ddb *Invoice )SellerAddress ()*InvoiceAddress {return _ddb ._bged };

// SetBorderOpacity sets the border opacity.
func (_egd *CurvePolygon )SetBorderOpacity (opacity float64 ){_egd ._bbfb =opacity };

// TableCell defines a table cell which can contain a Drawable as content.
type TableCell struct{_ccdb Color ;_ggead _ee .LineStyle ;_fdgb CellBorderStyle ;_ffcfc Color ;_eegg float64 ;_eege CellBorderStyle ;_edac Color ;_ddee float64 ;_eaab CellBorderStyle ;_fcggd Color ;_cdcc float64 ;_cadgb CellBorderStyle ;_cgeda Color ;_bfcba float64 ;
_bcbfb ,_abfg int ;_abdf int ;_bgcdf int ;_ebgg VectorDrawable ;_agbb CellHorizontalAlignment ;_bfaeb CellVerticalAlignment ;_ggeb float64 ;_cgdbb *Table ;};

// GetOptimizer returns current PDF optimizer.
func (_gcfb *Creator )GetOptimizer ()_ca .Optimizer {return _gcfb ._dcgf };

// ColorRGBFromHex converts color hex code to rgb color for using with creator.
// NOTE: If there is a problem interpreting the string, then will use black color and log a debug message.
// Example hex code: #ffffff -> (1,1,1) white.
func ColorRGBFromHex (hexStr string )Color {_gde :=rgbColor {};if (len (hexStr )!=4&&len (hexStr )!=7)||hexStr [0]!='#'{_db .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _gde ;
};var _cfdc ,_cff ,_cgeg int ;if len (hexStr )==4{var _eca ,_dfec ,_bfg int ;_dcbb ,_dcbbb :=_cba .Sscanf (hexStr ,"\u0023\u0025\u0031\u0078\u0025\u0031\u0078\u0025\u0031\u0078",&_eca ,&_dfec ,&_bfg );if _dcbbb !=nil {_db .Log .Debug ("\u0049\u006e\u0076a\u006c\u0069\u0064\u0020h\u0065\u0078\u0020\u0063\u006f\u0064\u0065:\u0020\u0025\u0073\u002c\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076",hexStr ,_dcbbb );
return _gde ;};if _dcbb !=3{_db .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _gde ;};_cfdc =_eca *16+_eca ;_cff =_dfec *16+_dfec ;_cgeg =_bfg *16+_bfg ;}else {_fbe ,_dec :=_cba .Sscanf (hexStr ,"\u0023\u0025\u0032\u0078\u0025\u0032\u0078\u0025\u0032\u0078",&_cfdc ,&_cff ,&_cgeg );
if _dec !=nil {_db .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0068\u0065\u0078 \u0063\u006f\u0064\u0065: \u0025\u0073",hexStr );return _gde ;};if _fbe !=3{_db .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0063\u006f\u0064\u0065\u003a\u0020\u0025\u0073,\u0020\u006e\u0020\u0021\u003d\u0020\u0033 \u0028\u0025\u0064\u0029",hexStr ,_fbe );
return _gde ;};};_gbac :=float64 (_cfdc )/255.0;_ebgb :=float64 (_cff )/255.0;_aaa :=float64 (_cgeg )/255.0;_gde ._acgf =_gbac ;_gde ._fcbcc =_ebgb ;_gde ._ebf =_aaa ;return _gde ;};func (_egebd *Table )moveToNextAvailableCell ()int {_bffg :=(_egebd ._ccgd -1)%(_egebd ._dcff )+1;
for {if _bffg -1>=len (_egebd ._accf ){return _bffg ;}else if _egebd ._accf [_bffg -1]==0{return _bffg ;}else {_egebd ._ccgd ++;_egebd ._accf [_bffg -1]--;};_bffg ++;};};func (_bbba *StyledParagraph )appendChunk (_cgec *TextChunk )*TextChunk {_bbba ._gagd =append (_bbba ._gagd ,_cgec );
_bbba .wrapText ();return _cgec ;};

// InvoiceAddress contains contact information that can be displayed
// in an invoice. It is used for the seller and buyer information in the
// invoice template.
type InvoiceAddress struct{Heading string ;Name string ;Street string ;Street2 string ;Zip string ;City string ;State string ;Country string ;Phone string ;Email string ;

// Separator defines the separator between different address components,
// such as the city, state and zip code. It defaults to ", " when the
// field is an empty string.
Separator string ;

// If enabled, the Phone field label (`Phone: `) is not displayed.
HidePhoneLabel bool ;

// If enabled, the Email field label (`Email: `) is not displayed.
HideEmailLabel bool ;};

// SetBorderRadius sets the radius of the rectangle corners.
func (_ddfe *Rectangle )SetBorderRadius (topLeft ,topRight ,bottomLeft ,bottomRight float64 ){_ddfe ._gaddfd =topLeft ;_ddfe ._gdbeg =topRight ;_ddfe ._gfbb =bottomLeft ;_ddfe ._cbbbd =bottomRight ;};

// NewPage adds a new Page to the Creator and sets as the active Page.
func (_adfc *Creator )NewPage ()*_ca .PdfPage {_acbg :=_adfc .newPage ();_adfc ._fbcf =append (_adfc ._fbcf ,_acbg );_adfc ._bgfa .Page ++;return _acbg ;};

// SetBorderOpacity sets the border opacity.
func (_bdaf *Rectangle )SetBorderOpacity (opacity float64 ){_bdaf ._accg =opacity };

// SetPos sets the position of the chart to the specified coordinates.
// This method sets the chart to use absolute positioning.
func (_bgfg *Chart )SetPos (x ,y float64 ){_bgfg ._ffd =PositionAbsolute ;_bgfg ._cceg =x ;_bgfg ._daa =y ;};type containerDrawable interface{Drawable ;

// ContainerComponent checks if the component is allowed to be added into provided 'container' and returns
// preprocessed copy of itself. If the component is not changed it is allowed to return itself in a callback way.
// If the component is not compatible with provided container this method should return an error.
ContainerComponent (_adgga Drawable )(Drawable ,error );};

// NewImageFromFile creates an Image from a file.
func (_agef *Creator )NewImageFromFile (path string )(*Image ,error ){return _dafa (path )};func (_cffc *Creator )getActivePage ()*_ca .PdfPage {if _cffc ._dfde ==nil {if len (_cffc ._fbcf )==0{return nil ;};return _cffc ._fbcf [len (_cffc ._fbcf )-1];
};return _cffc ._dfde ;};func _gbbeg (_debb *Table ,_agbg DrawContext )([]*Block ,DrawContext ,error ){var _dggf []*Block ;_addca :=NewBlock (_agbg .PageWidth ,_agbg .PageHeight );_debb .updateRowHeights (_agbg .Width -_debb ._ecffd .Left -_debb ._ecffd .Right );
_geged :=_debb ._ecffd .Top ;if _debb ._gffgd .IsRelative ()&&!_debb ._acccg {_fbfg :=_debb .Height ();if _fbfg > _agbg .Height -_debb ._ecffd .Top &&_fbfg <=_agbg .PageHeight -_agbg .Margins .Top -_agbg .Margins .Bottom {_dggf =[]*Block {NewBlock (_agbg .PageWidth ,_agbg .PageHeight -_agbg .Y )};
var _fgcac error ;if _ ,_agbg ,_fgcac =_geag ().GeneratePageBlocks (_agbg );_fgcac !=nil {return nil ,_agbg ,_fgcac ;};_geged =0;};};_gfg :=_agbg ;if _debb ._gffgd .IsAbsolute (){_agbg .X =_debb ._eecef ;_agbg .Y =_debb ._bead ;}else {_agbg .X +=_debb ._ecffd .Left ;
_agbg .Y +=_geged ;_agbg .Width -=_debb ._ecffd .Left +_debb ._ecffd .Right ;_agbg .Height -=_geged ;};_gedea :=_agbg .Width ;_fbcde :=_agbg .X ;_bffeb :=_agbg .Y ;_gfgb :=_agbg .Height ;_eaca :=0;_cebf ,_adc :=-1,-1;if _debb ._eafb {for _efbdf ,_bcdcf :=range _debb ._deag {if _bcdcf ._bcbfb < _debb ._gdagf {continue ;
};if _bcdcf ._bcbfb > _debb ._dccfg {break ;};if _cebf < 0{_cebf =_efbdf ;};_adc =_efbdf ;};};var (_bbega bool ;_gcgg int ;_fdff int ;_agff bool ;_aaab int ;_fecc error ;);for _aeda :=0;_aeda < len (_debb ._deag );_aeda ++{_agcbf :=_debb ._deag [_aeda ];
_geca :=_agcbf .width (_debb ._dabge ,_gedea );_bgadde :=float64 (0.0);for _dbdec :=0;_dbdec < _agcbf ._abfg -1;_dbdec ++{_bgadde +=_debb ._dabge [_dbdec ]*_gedea ;};_beba :=float64 (0.0);for _agdd :=_eaca ;_agdd < _agcbf ._bcbfb -1;_agdd ++{_beba +=_debb ._accdf [_agdd ];
};_agbg .Height =_gfgb -_beba ;_fbdg :=float64 (0.0);for _cgcfg :=0;_cgcfg < _agcbf ._abdf ;_cgcfg ++{_fbdg +=_debb ._accdf [_agcbf ._bcbfb +_cgcfg -1];};_edgda :=_agff &&_agcbf ._bcbfb !=_aaab ;_aaab =_agcbf ._bcbfb ;if _edgda ||_fbdg > _agbg .Height {if _debb ._cbbca &&!_agff {_agff ,_fecc =_debb .wrapRow (_aeda ,_agbg ,_gedea );
if _fecc !=nil {return nil ,_agbg ,_fecc ;};if _agff {_aeda --;continue ;};};_dggf =append (_dggf ,_addca );_addca =NewBlock (_agbg .PageWidth ,_agbg .PageHeight );_fbcde =_agbg .Margins .Left +_debb ._ecffd .Left ;_bffeb =_agbg .Margins .Top ;_agbg .Height =_agbg .PageHeight -_agbg .Margins .Top -_agbg .Margins .Bottom ;
_agbg .Page ++;_gfgb =_agbg .Height ;_eaca =_agcbf ._bcbfb -1;_beba =0;_agff =false ;if _debb ._eafb &&_cebf >=0{_gcgg =_aeda ;_aeda =_cebf -1;_fdff =_eaca ;_eaca =_debb ._gdagf -1;_bbega =true ;continue ;};if _edgda {_aeda --;continue ;};};_agbg .Width =_geca ;
_agbg .X =_fbcde +_bgadde ;_agbg .Y =_bffeb +_beba ;_bbbdd :=_fgc (_agbg .X ,_agbg .Y ,_geca ,_fbdg );if _agcbf ._ccdb !=nil {_bbbdd .SetFillColor (_agcbf ._ccdb );};_bbbdd .LineStyle =_agcbf ._ggead ;_bbbdd ._cea =_agcbf ._fdgb ;_bbbdd ._aee =_agcbf ._eaab ;
_bbbdd ._cbea =_agcbf ._cadgb ;_bbbdd ._dbb =_agcbf ._eege ;if _agcbf ._ffcfc !=nil {_bbbdd .SetColorLeft (_agcbf ._ffcfc );};if _agcbf ._edac !=nil {_bbbdd .SetColorBottom (_agcbf ._edac );};if _agcbf ._fcggd !=nil {_bbbdd .SetColorRight (_agcbf ._fcggd );
};if _agcbf ._cgeda !=nil {_bbbdd .SetColorTop (_agcbf ._cgeda );};_bbbdd .SetWidthBottom (_agcbf ._ddee );_bbbdd .SetWidthLeft (_agcbf ._eegg );_bbbdd .SetWidthRight (_agcbf ._cdcc );_bbbdd .SetWidthTop (_agcbf ._bfcba );_fbec :=_addca .Draw (_bbbdd );
if _fbec !=nil {_db .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_fbec );};if _agcbf ._ebgg !=nil {_dbfcb :=_agcbf ._ebgg .Width ();_bfgg :=_agcbf ._ebgg .Height ();_fffbee :=0.0;switch _efcg :=_agcbf ._ebgg .(type ){case *Paragraph :if _efcg ._cece {_dbfcb =_efcg .getMaxLineWidth ()/1000.0;
};_dbfcb +=_efcg ._cbcfd .Left +_efcg ._cbcfd .Right ;_bfgg +=_efcg ._cbcfd .Top +_efcg ._cbcfd .Bottom ;case *StyledParagraph :if _efcg ._debf {_dbfcb =_efcg .getMaxLineWidth ()/1000.0;};_ggea ,_beebd ,_ageea :=_efcg .getLineMetrics (0);_dgab ,_ffff :=_ggea *_efcg ._bcfdf ,_beebd *_efcg ._bcfdf ;
if _efcg ._aaac ==TextVerticalAlignmentCenter {_fffbee =_ffff -(_beebd +(_ggea +_ageea -_beebd )/2+(_ffff -_beebd )/2);};if len (_efcg ._bcdd )==1{_bfgg =_dgab ;}else {_bfgg =_bfgg -_ffff +_dgab ;};_fffbee +=_dgab -_ffff ;switch _agcbf ._bfaeb {case CellVerticalAlignmentTop :_fffbee +=_dgab *0.5;
case CellVerticalAlignmentBottom :_fffbee -=_dgab *0.5;};_dbfcb +=_efcg ._dfcc .Left +_efcg ._dfcc .Right ;_bfgg +=_efcg ._dfcc .Top +_efcg ._dfcc .Bottom ;case *Table :_dbfcb =_geca ;case *List :_dbfcb =_geca ;case *Division :_dbfcb =_geca ;case *Chart :_dbfcb =_geca ;
};switch _agcbf ._agbb {case CellHorizontalAlignmentLeft :_agbg .X +=_agcbf ._ggeb ;_agbg .Width -=_agcbf ._ggeb ;case CellHorizontalAlignmentCenter :if _ggdf :=_geca -_dbfcb ;_ggdf > 0{_agbg .X +=_ggdf /2;_agbg .Width -=_ggdf /2;};case CellHorizontalAlignmentRight :if _geca > _dbfcb {_agbg .X =_agbg .X +_geca -_dbfcb -_agcbf ._ggeb ;
_agbg .Width -=_agcbf ._ggeb ;};};_bafa :=_agbg .Y ;_dbga :=_agbg .Height ;_agbg .Y +=_fffbee ;switch _agcbf ._bfaeb {case CellVerticalAlignmentTop :case CellVerticalAlignmentMiddle :if _fbfga :=_fbdg -_bfgg ;_fbfga > 0{_agbg .Y +=_fbfga /2;_agbg .Height -=_fbfga /2;
};case CellVerticalAlignmentBottom :if _fbdg > _bfgg {_agbg .Y =_agbg .Y +_fbdg -_bfgg ;_agbg .Height =_fbdg ;};};_cgbc :=_addca .DrawWithContext (_agcbf ._ebgg ,_agbg );if _cgbc !=nil {_db .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_cgbc );
};_agbg .Y =_bafa ;_agbg .Height =_dbga ;};_agbg .Y +=_fbdg ;_agbg .Height -=_fbdg ;if _bbega &&_aeda +1> _adc {_bffeb +=_beba +_fbdg ;_gfgb -=_fbdg +_beba ;_eaca =_fdff ;_aeda =_gcgg -1;_bbega =false ;};};_dggf =append (_dggf ,_addca );if _debb ._gffgd .IsAbsolute (){return _dggf ,_gfg ,nil ;
};_agbg .X =_gfg .X ;_agbg .Width =_gfg .Width ;_agbg .Y +=_debb ._ecffd .Bottom ;_agbg .Height -=_debb ._ecffd .Bottom ;return _dggf ,_agbg ,nil ;};

// SetWidth sets the the Paragraph width. This is essentially the wrapping width, i.e. the width the
// text can extend to prior to wrapping over to next line.
func (_dgfd *Paragraph )SetWidth (width float64 ){_dgfd ._deda =width ;_dgfd .wrapText ()};

// Add adds a VectorDrawable to the Division container.
// Currently supported VectorDrawables:
// - *Paragraph
// - *StyledParagraph
// - *Image
// - *Chart
// - *Rectangle
// - *Ellipse
func (_gcae *Division )Add (d VectorDrawable )error {switch _dbfa :=d .(type ){case *Paragraph ,*StyledParagraph ,*Image ,*Chart ,*Rectangle ,*Ellipse ,*Table ,*Division :case containerDrawable :_def ,_dfdb :=_dbfa .ContainerComponent (_gcae );if _dfdb !=nil {return _dfdb ;
};_ccebc ,_bbbg :=_def .(VectorDrawable );if !_bbbg {return _cba .Errorf ("\u0072\u0065\u0073\u0075\u006ct\u0020\u006f\u0066\u0020\u0043\u006f\u006et\u0061\u0069\u006e\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0020\u002d\u0020\u0025\u0054\u0020\u0064\u006f\u0065\u0073\u006e\u0027\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u0056\u0065c\u0074\u006f\u0072\u0044\u0072\u0061\u0077\u0061\u0062\u006c\u0065\u0020i\u006e\u0074\u0065\u0072\u0066\u0061c\u0065",_def );
};d =_ccebc ;default:return _c .New ("\u0075\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070e\u0020i\u006e\u0020\u0044\u0069\u0076\u0069\u0073i\u006f\u006e");};_gcae ._bdcb =append (_gcae ._bdcb ,d );return nil ;};

// AddExternalLink adds a new external link to the paragraph.
// The text parameter represents the text that is displayed and the url
// parameter sets the destionation of the link.
func (_ccdd *StyledParagraph )AddExternalLink (text ,url string )*TextChunk {_eabf :=NewTextChunk (text ,_ccdd ._ffdf );_eabf ._cgbd =_dgada (url );return _ccdd .appendChunk (_eabf );};

// Width returns Ellipse's document width.
func (_fcee *Ellipse )Width ()float64 {return _fcee ._bdge };func (_bdg *pageTransformations )applyFlip (_aaae *_ca .PdfPage )error {_abfdg ,_eaf :=_bdg ._gggcg ,_bdg ._faf ;if !_abfdg &&!_eaf {return nil ;};if _aaae ==nil {return _c .New ("\u006e\u006f\u0020\u0070\u0061\u0067\u0065\u0020\u0061c\u0074\u0069\u0076\u0065");
};_dbde ,_gdgf :=_aaae .GetMediaBox ();if _gdgf !=nil {return _gdgf ;};_bbgba ,_fcba :=_dbde .Width (),_dbde .Height ();_fbd ,_gdgf :=_aaae .GetRotate ();if _gdgf !=nil {_db .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0025\u0073\u0020\u002d\u0020\u0069\u0067\u006e\u006f\u0072\u0069\u006e\u0067\u0020\u0061\u006e\u0064\u0020\u0061\u0073\u0073\u0075\u006d\u0069\u006e\u0067\u0020\u006e\u006f\u0020\u0072\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u000a",_gdgf .Error ());
};if _gcf :=_fbd %360!=0&&_fbd %90==0;_gcf {if _edcg :=(360+_fbd %360)%360;_edcg ==90||_edcg ==270{_abfdg ,_eaf =_eaf ,_abfdg ;};};_ddgd ,_caeg :=1.0,0.0;if _abfdg {_ddgd ,_caeg =-1.0,-_bbgba ;};_eab ,_agbf :=1.0,0.0;if _eaf {_eab ,_agbf =-1.0,-_fcba ;
};_add :=_acc .NewContentCreator ().Scale (_ddgd ,_eab ).Translate (_caeg ,_agbf );_cfdeb ,_gdgf :=_bc .MakeStream (_add .Bytes (),_bc .NewFlateEncoder ());if _gdgf !=nil {return _gdgf ;};_ecaf :=_bc .MakeArray (_cfdeb );_ecaf .Append (_aaae .GetContentStreamObjs ()...);
_aaae .Contents =_ecaf ;return nil ;};

// NewList creates a new list.
func (_gffe *Creator )NewList ()*List {return _dfca (_gffe .NewTextStyle ())};

// LevelOffset returns the amount of space an indentation level occupies.
func (_ffdgg *TOCLine )LevelOffset ()float64 {return _ffdgg ._cggdd };

// SetBorderRadius sets the radius of the background corners.
func (_fb *Background )SetBorderRadius (topLeft ,topRight ,bottomLeft ,bottomRight float64 ){_fb .BorderRadiusTopLeft =topLeft ;_fb .BorderRadiusTopRight =topRight ;_fb .BorderRadiusBottomLeft =bottomLeft ;_fb .BorderRadiusBottomRight =bottomRight ;};

// Add adds a new line with the default style to the table of contents.
func (_fcbfa *TOC )Add (number ,title ,page string ,level uint )*TOCLine {_ggggg :=_fcbfa .AddLine (_cgfc (TextChunk {Text :number ,Style :_fcbfa ._afca },TextChunk {Text :title ,Style :_fcbfa ._fgbc },TextChunk {Text :page ,Style :_fcbfa ._fgbbf },level ,_fcbfa ._dgee ));
if _ggggg ==nil {return nil ;};_ddfbe :=&_fcbfa ._adde ;_ggggg .SetMargins (_ddfbe .Left ,_ddfbe .Right ,_ddfbe .Top ,_ddfbe .Bottom );_ggggg .SetLevelOffset (_fcbfa ._febe );_ggggg .Separator .Text =_fcbfa ._debcf ;_ggggg .Separator .Style =_fcbfa ._agecd ;
return _ggggg ;};

// SetBorderWidth sets the border width.
func (_adff *Ellipse )SetBorderWidth (bw float64 ){_adff ._afdfg =bw };

// IsRelative checks if the positioning is relative.
func (_dgb Positioning )IsRelative ()bool {return _dgb ==PositionRelative };func (_cccf *Creator )initContext (){_cccf ._bgfa .X =_cccf ._bddf .Left ;_cccf ._bgfa .Y =_cccf ._bddf .Top ;_cccf ._bgfa .Width =_cccf ._fdga -_cccf ._bddf .Right -_cccf ._bddf .Left ;
_cccf ._bgfa .Height =_cccf ._fcdb -_cccf ._bddf .Bottom -_cccf ._bddf .Top ;_cccf ._bgfa .PageHeight =_cccf ._fcdb ;_cccf ._bgfa .PageWidth =_cccf ._fdga ;_cccf ._bgfa .Margins =_cccf ._bddf ;_cccf ._bgfa ._eadb =_cccf .UnsupportedCharacterReplacement ;
};

// SetWidthBottom sets border width for bottom.
func (_ddf *border )SetWidthBottom (bw float64 ){_ddf ._gdf =bw };

// Height returns the height of the Paragraph. The height is calculated based on the input text and
// how it is wrapped within the container. Does not include Margins.
func (_gcec *Paragraph )Height ()float64 {_gcec .wrapText ();return float64 (len (_gcec ._bedb ))*_gcec ._fdeec *_gcec ._fcbfd ;};

// Notes returns the notes section of the invoice as a title-content pair.
func (_dabe *Invoice )Notes ()(string ,string ){return _dabe ._fae [0],_dabe ._fae [1]};

// SetBorderLineStyle sets border style (currently dashed or plain).
func (_bbccc *TableCell )SetBorderLineStyle (style _ee .LineStyle ){_bbccc ._ggead =style };func _ccbac (_aeeac string )([]string ,error ){_effc :=[]rune (_aeeac );_bcdbg :=_bb .NewScanner (_effc );var (_fcgf []string ;_gfcf []rune ;);for _deed :=0;_deed < len (_effc );
_deed ++{_ ,_fbcb ,_ecfcb :=_bcdbg .Next ();if _ecfcb !=nil {return nil ,_ecfcb ;};if _fbcb ==_bb .BreakProhibited ||_e .IsSpace (_effc [_deed ]){_gfcf =append (_gfcf ,_effc [_deed ]);if _e .IsSpace (_effc [_deed ]){_fcgf =append (_fcgf ,string (_gfcf ));
_gfcf =[]rune {};};continue ;}else {if len (_gfcf )> 0{_fcgf =append (_fcgf ,string (_gfcf ));};_gfcf =[]rune {_effc [_deed ]};};};if len (_gfcf )> 0{_fcgf =append (_fcgf ,string (_gfcf ));};return _fcgf ,nil ;};

// AddressHeadingStyle returns the style properties used to render the
// heading of the invoice address sections.
func (_ffdab *Invoice )AddressHeadingStyle ()TextStyle {return _ffdab ._bcbaa };func (_adffd *Image )applyFitMode (_afda float64 ){_afda -=_adffd ._ebea .Left +_adffd ._ebea .Right ;switch _adffd ._cdcd {case FitModeFillWidth :_adffd .ScaleToWidth (_afda );
};};

// Height returns the height of the list.
func (_dffaa *List )Height ()float64 {var _dfeb float64 ;for _ ,_feab :=range _dffaa ._dfcd {_dfeb +=_feab ._fgdd .Height ();};return _dfeb ;};

// Level returns the indentation level of the TOC line.
func (_aabee *TOCLine )Level ()uint {return _aabee ._dcae };

// Insert adds a new text chunk at the specified position in the paragraph.
func (_eadf *StyledParagraph )Insert (index uint ,text string )*TextChunk {_fbgg :=uint (len (_eadf ._gagd ));if index > _fbgg {index =_fbgg ;};_gbef :=NewTextChunk (text ,_eadf ._accc );_eadf ._gagd =append (_eadf ._gagd [:index ],append ([]*TextChunk {_gbef },_eadf ._gagd [index :]...)...);
_eadf .wrapText ();return _gbef ;};

// GetHorizontalAlignment returns the horizontal alignment of the image.
func (_adeg *Image )GetHorizontalAlignment ()HorizontalAlignment {return _adeg ._aadc };

// SetShowNumbering sets a flag to indicate whether or not to show chapter numbers as part of title.
func (_baf *Chapter )SetShowNumbering (show bool ){_baf ._aeb =show ;_baf ._cbd .SetText (_baf .headingText ());};func _dgf (_cegb string ,_fcg _bc .PdfObject ,_cfa *_ca .PdfPageResources )_bc .PdfObjectName {_bbgb :=_ac .TrimRightFunc (_ac .TrimSpace (_cegb ),func (_cddc rune )bool {return _e .IsNumber (_cddc )});
if _bbgb ==""{_bbgb ="\u0046\u006f\u006e\u0074";};_ccd :=0;_gfc :=_bc .PdfObjectName (_cegb );for {_gbad ,_eba :=_cfa .GetFontByName (_gfc );if !_eba ||_gbad ==_fcg {break ;};_ccd ++;_gfc =_bc .PdfObjectName (_cba .Sprintf ("\u0025\u0073\u0025\u0064",_bbgb ,_ccd ));
};return _gfc ;};

// Chapter is used to arrange multiple drawables (paragraphs, images, etc) into a single section.
// The concept is the same as a book or a report chapter.
type Chapter struct{_cda int ;_gfb string ;_cbd *Paragraph ;_cge []Drawable ;_fgac int ;_aeb bool ;_dab bool ;_dbec Positioning ;_becf ,_afa float64 ;_ebg Margins ;_ebba *Chapter ;_aafeb *TOC ;_aba *_ca .Outline ;_agca *_ca .OutlineItem ;_cefe uint ;};


// CurCol returns the currently active cell's column number.
func (_efag *Table )CurCol ()int {_fgeaf :=(_efag ._ccgd -1)%(_efag ._dcff )+1;return _fgeaf };

// Length calculates and returns the line length.
func (_dfced *Line )Length ()float64 {return _cb .Sqrt (_cb .Pow (_dfced ._fceg -_dfced ._dfgf ,2.0)+_cb .Pow (_dfced ._baee -_dfced ._ddda ,2.0));};

// SetFillColor sets the fill color.
func (_adafg *Rectangle )SetFillColor (col Color ){_adafg ._eadba =col };

// NewTOC creates a new table of contents.
func (_gfe *Creator )NewTOC (title string )*TOC {_dcfb :=_gfe .NewTextStyle ();_dcfb .Font =_gfe ._gfd ;return _ebeaa (title ,_gfe .NewTextStyle (),_dcfb );};

// SetAnnotation sets a annotation on a TextChunk.
func (_cbaag *TextChunk )SetAnnotation (annotation *_ca .PdfAnnotation ){_cbaag ._cgbd =annotation };

// CellBorderSide defines the table cell's border side.
type CellBorderSide int ;

// Color interface represents colors in the PDF creator.
type Color interface{ToRGB ()(float64 ,float64 ,float64 );};const (FitModeNone FitMode =iota ;FitModeFillWidth ;);

// InfoLines returns all the rows in the invoice information table as
// description-value cell pairs.
func (_dfdag *Invoice )InfoLines ()[][2]*InvoiceCell {_bgdd :=[][2]*InvoiceCell {_dfdag ._bdgaa ,_dfdag ._geff ,_dfdag ._gaad };return append (_bgdd ,_dfdag ._fabbc ...);};

// GeneratePageBlocks draws the line on a new block representing the page. Implements the Drawable interface.
func (_abfe *Line )GeneratePageBlocks (ctx DrawContext )([]*Block ,DrawContext ,error ){_cfea :=NewBlock (ctx .PageWidth ,ctx .PageHeight );_abef :=_ee .Line {LineWidth :_abfe ._efbd ,Opacity :1.0,LineColor :_geg (_abfe ._aaad ),LineEndingStyle1 :_ee .LineEndingStyleNone ,LineEndingStyle2 :_ee .LineEndingStyleNone ,X1 :_abfe ._dfgf ,Y1 :ctx .PageHeight -_abfe ._ddda ,X2 :_abfe ._fceg ,Y2 :ctx .PageHeight -_abfe ._baee };
_eaff ,_ ,_dadb :=_abef .Draw ("");if _dadb !=nil {return nil ,ctx ,_dadb ;};_dadb =_cfea .addContentsByString (string (_eaff ));if _dadb !=nil {return nil ,ctx ,_dadb ;};return []*Block {_cfea },ctx ,nil ;};

// BuyerAddress returns the buyer address used in the invoice template.
func (_gdae *Invoice )BuyerAddress ()*InvoiceAddress {return _gdae ._cded };func (_dbeg *Division )drawBackground (_bed []*Block ,_daee ,_egda DrawContext ,_fefde bool )([]*Block ,error ){_fbfc :=len (_bed );if _fbfc ==0||_dbeg ._eebc ==nil {return _bed ,nil ;
};_fdbg :=make ([]*Block ,0,len (_bed ));for _bdga ,_bcgg :=range _bed {var (_cffcf =_dbeg ._eebc .BorderRadiusTopLeft ;_fdcc =_dbeg ._eebc .BorderRadiusTopRight ;_dde =_dbeg ._eebc .BorderRadiusBottomLeft ;_fbcfa =_dbeg ._eebc .BorderRadiusBottomRight ;
);_ecgd :=_daee ;_ecgd .Page +=_bdga ;if _bdga ==0{if _fefde {_fdbg =append (_fdbg ,_bcgg );continue ;};if _fbfc ==1{_ecgd .Height =_egda .Y -_daee .Y ;};}else {_ecgd .X =_ecgd .Margins .Left +_dbeg ._fdea .Left ;_ecgd .Y =_ecgd .Margins .Top ;_ecgd .Width =_ecgd .PageWidth -_ecgd .Margins .Left -_ecgd .Margins .Right -_dbeg ._fdea .Left -_dbeg ._fdea .Right ;
if _bdga ==_fbfc -1{_ecgd .Height =_egda .Y -_ecgd .Margins .Top -_dbeg ._fdea .Top ;}else {_ecgd .Height =_ecgd .PageHeight -_ecgd .Margins .Top -_ecgd .Margins .Bottom ;};if !_fefde {_cffcf =0;_fdcc =0;};};if _fbfc > 1&&_bdga !=_fbfc -1{_dde =0;_fbcfa =0;
};_becd :=_ffca (_ecgd .X ,_ecgd .Y ,_ecgd .Width ,_ecgd .Height );_becd .SetFillColor (_dbeg ._eebc .FillColor );_becd .SetBorderColor (_dbeg ._eebc .BorderColor );_becd .SetBorderWidth (_dbeg ._eebc .BorderSize );_becd .SetBorderRadius (_cffcf ,_fdcc ,_dde ,_fbcfa );
_dfcgd ,_ ,_debc :=_becd .GeneratePageBlocks (_ecgd );if _debc !=nil {return nil ,_debc ;};if len (_dfcgd )==0{continue ;};_bafe :=_dfcgd [0];if _debc =_bafe .mergeBlocks (_bcgg );_debc !=nil {return nil ,_debc ;};_fdbg =append (_fdbg ,_bafe );};return _fdbg ,nil ;
};

// SetPos sets the absolute position. Changes object positioning to absolute.
func (_cffd *Image )SetPos (x ,y float64 ){_cffd ._fbga =PositionAbsolute ;_cffd ._fcbd =x ;_cffd ._fffb =y ;};func _cfaa (_dccfa string ,_dddf TextStyle )*Paragraph {_ddfb :=&Paragraph {_aafb :_dccfa ,_eecf :_dddf .Font ,_fcbfd :_dddf .FontSize ,_fdeec :1.0,_cece :true ,_ggdaf :true ,_gddc :TextAlignmentLeft ,_eac :0,_bfbab :1,_cebb :1,_dacd :PositionRelative };
_ddfb .SetColor (_dddf .Color );return _ddfb ;};

// Rows returns the total number of rows the table has.
func (_babbc *Table )Rows ()int {return _babbc ._ddaed };

// SetLineSeparatorStyle sets the style for the separator part of all new
// lines of the table of contents.
func (_gafga *TOC )SetLineSeparatorStyle (style TextStyle ){_gafga ._agecd =style };func _geag ()*PageBreak {return &PageBreak {}};func _bbbfb (_feae float64 ,_bfbba float64 )float64 {return _cb .Round (_feae /_bfbba )*_bfbba };func (_acba *StyledParagraph )getTextHeight ()float64 {var _ebedc float64 ;
for _ ,_bbfd :=range _acba ._gagd {_baeb :=_bbfd .Style .FontSize *_acba ._bcfdf ;if _baeb > _ebedc {_ebedc =_baeb ;};};return _ebedc ;};

// AppendColumn appends a column to the line items table.
func (_gfbf *Invoice )AppendColumn (description string )*InvoiceCell {_degb :=_gfbf .NewColumn (description );_gfbf ._bfda =append (_gfbf ._bfda ,_degb );return _degb ;};func (_eddcf *StyledParagraph )wrapWordChunks (){if !_eddcf ._gddfe {return ;};var _beee []*TextChunk ;
for _ ,_dgcc :=range _eddcf ._gagd {_ecgb ,_dece :=_ccbac (_dgcc .Text );if _dece !=nil {_db .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0062\u0072\u0065\u0061\u006b\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0074\u006f\u0020w\u006f\u0072\u0064\u0073\u003a\u0020\u0025\u0076",_dece );
_ecgb =[]string {_dgcc .Text };};for _ ,_febf :=range _ecgb {_dgfa :=NewTextChunk (_febf ,_dgcc .Style );_beee =append (_beee ,_dgfa );};};if len (_beee )> 0{_eddcf ._gagd =_beee ;};};

// Write output of creator to io.Writer interface.
func (_efbb *Creator )Write (ws _de .Writer )error {if _abca :=_efbb .Finalize ();_abca !=nil {return _abca ;};_cbcf :=_ca .NewPdfWriter ();_cbcf .SetOptimizer (_efbb ._dcgf );if _efbb ._gadd !=nil {_aagb :=_cbcf .SetForms (_efbb ._gadd );if _aagb !=nil {_db .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_aagb );
return _aagb ;};};if _efbb ._bdbc !=nil {_cbcf .AddOutlineTree (_efbb ._bdbc );}else if _efbb ._cbgc !=nil &&_efbb .AddOutlines {_cbcf .AddOutlineTree (&_efbb ._cbgc .ToPdfOutline ().PdfOutlineTreeNode );};if _efbb ._ecb !=nil {if _aad :=_cbcf .SetPageLabels (_efbb ._ecb );
_aad !=nil {_db .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020C\u006f\u0075\u006c\u0064 no\u0074 s\u0065\u0074\u0020\u0070\u0061\u0067\u0065 l\u0061\u0062\u0065\u006c\u0073\u003a\u0020%\u0076",_aad );return _aad ;};};if _efbb ._ddg !=nil {for _ ,_afab :=range _efbb ._ddg {_edgd :=_afab .SubsetRegistered ();
if _edgd !=nil {_db .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0043\u006f\u0075\u006c\u0064\u0020\u006e\u006ft\u0020s\u0075\u0062\u0073\u0065\u0074\u0020\u0066\u006f\u006e\u0074\u003a\u0020\u0025\u0076",_edgd );return _edgd ;};};};if _efbb ._ccc !=nil {_bebb :=_efbb ._ccc (&_cbcf );
if _bebb !=nil {_db .Log .Debug ("F\u0061\u0069\u006c\u0075\u0072\u0065\u003a\u0020\u0025\u0076",_bebb );return _bebb ;};};for _ ,_bee :=range _efbb ._fbcf {_efeaf :=_cbcf .AddPage (_bee );if _efeaf !=nil {_db .Log .Error ("\u0046\u0061\u0069\u006ced\u0020\u0074\u006f\u0020\u0061\u0064\u0064\u0020\u0050\u0061\u0067\u0065\u003a\u0020%\u0076",_efeaf );
return _efeaf ;};};_dfcg :=_cbcf .Write (ws );if _dfcg !=nil {return _dfcg ;};return nil ;};

// SetFillColor sets the fill color.
func (_eadd *CurvePolygon )SetFillColor (color Color ){_eadd ._fdbbd .FillColor =_geg (color )};func (_bgdc *Creator )newPage ()*_ca .PdfPage {_ecd :=_ca .NewPdfPage ();_gdfb :=_bgdc ._bbga [0];_edcc :=_bgdc ._bbga [1];_bcf :=_ca .PdfRectangle {Llx :0,Lly :0,Urx :_gdfb ,Ury :_edcc };
_ecd .MediaBox =&_bcf ;_bgdc ._fdga =_gdfb ;_bgdc ._fcdb =_edcc ;_bgdc .initContext ();return _ecd ;};

// Polyline represents a slice of points that are connected as straight lines.
// Implements the Drawable interface and can be rendered using the Creator.
type Polyline struct{_abfdb *_ee .Polyline ;_faae float64 ;};

// NewEllipse creates a new ellipse centered at (xc,yc) with a width and height specified.
func (_agfe *Creator )NewEllipse (xc ,yc ,width ,height float64 )*Ellipse {return _fdeea (xc ,yc ,width ,height );};

// CreateTableOfContents sets a function to generate table of contents.
func (_fgb *Creator )CreateTableOfContents (genTOCFunc func (_ebbf *TOC )error ){_fgb ._ccg =genTOCFunc };

// Wrap wraps the text of the chunk into lines based on its style and the
// specified width.
func (_ggce *TextChunk )Wrap (width float64 )([]string ,error ){if int (width )<=0{return []string {_ggce .Text },nil ;};var _debca []string ;var _ecaff []rune ;var _agbce float64 ;var _adbf []float64 ;_cdccb :=_ggce .Style ;for _ ,_gbgdd :=range _ggce .Text {if _gbgdd =='\u000A'{_debca =append (_debca ,_ac .TrimRightFunc (string (_ecaff ),_e .IsSpace )+string (_gbgdd ));
_ecaff =nil ;_agbce =0;_adbf =nil ;continue ;};_gegge :=_gbgdd ==' ';_fabab ,_ccfec :=_cdccb .Font .GetRuneMetrics (_gbgdd );if !_ccfec {_db .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0075\u006e\u0065\u0020\u0063\u0068\u0061\u0072\u0020\u006det\u0072i\u0063\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064!\u0020\u0072\u0075\u006e\u0065\u003d\u0030\u0078\u0025\u0030\u0034\u0078\u003d\u0025\u0063\u0020\u0066o\u006e\u0074\u003d\u0025\u0073\u0020\u0025\u0023\u0071",_gbgdd ,_gbgdd ,_cdccb .Font .BaseFont (),_cdccb .Font .Subtype ());
_db .Log .Trace ("\u0046o\u006e\u0074\u003a\u0020\u0025\u0023v",_cdccb .Font );_db .Log .Trace ("\u0045\u006e\u0063o\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076",_cdccb .Font .Encoder ());return nil ,_c .New ("\u0067\u006c\u0079\u0070\u0068\u0020\u0063\u0068\u0061\u0072\u0020m\u0065\u0074\u0072\u0069\u0063\u0073\u0020\u006d\u0069\u0073s\u0069\u006e\u0067");
};_ccba :=_cdccb .FontSize *_fabab .Wx ;_cgeb :=_ccba ;if !_gegge {_cgeb =_ccba +_cdccb .CharSpacing *1000.0;};if _agbce +_ccba > width *1000.0{_agcag :=-1;if !_gegge {for _cebbc :=len (_ecaff )-1;_cebbc >=0;_cebbc --{if _ecaff [_cebbc ]==' '{_agcag =_cebbc ;
break ;};};};_cdec :=string (_ecaff );if _agcag > 0{_cdec =string (_ecaff [0:_agcag +1]);_ecaff =append (_ecaff [_agcag +1:],_gbgdd );_adbf =append (_adbf [_agcag +1:],_cgeb );_agbce =0;for _ ,_cede :=range _adbf {_agbce +=_cede ;};}else {if _gegge {_ecaff =[]rune {};
_adbf =[]float64 {};_agbce =0;}else {_ecaff =[]rune {_gbgdd };_adbf =[]float64 {_cgeb };_agbce =_cgeb ;};};_debca =append (_debca ,_ac .TrimRightFunc (_cdec ,_e .IsSpace ));}else {_ecaff =append (_ecaff ,_gbgdd );_agbce +=_cgeb ;_adbf =append (_adbf ,_cgeb );
};};if len (_ecaff )> 0{_debca =append (_debca ,string (_ecaff ));};return _debca ,nil ;};var (PageSizeA3 =PageSize {297*PPMM ,420*PPMM };PageSizeA4 =PageSize {210*PPMM ,297*PPMM };PageSizeA5 =PageSize {148*PPMM ,210*PPMM };PageSizeLetter =PageSize {8.5*PPI ,11*PPI };
PageSizeLegal =PageSize {8.5*PPI ,14*PPI };);

// EnableFontSubsetting enables font subsetting for `font` when the creator output is written to file.
// Embeds only the subset of the runes/glyphs that are actually used to display the file.
// Subsetting can reduce the size of fonts significantly.
func (_fbgd *Creator )EnableFontSubsetting (font *_ca .PdfFont ){_fbgd ._ddg =append (_fbgd ._ddg ,font )};

// Block contains a portion of PDF Page contents. It has a width and a position and can
// be placed anywhere on a Page.  It can even contain a whole Page, and is used in the creator
// where each Drawable object can output one or more blocks, each representing content for separate pages
// (typically needed when Page breaks occur).
type Block struct{_gg *_acc .ContentStreamOperations ;_eee *_ca .PdfPageResources ;_fbg Positioning ;_ace ,_ag float64 ;_ce float64 ;_cac float64 ;_da float64 ;_gca Margins ;_ab []*_ca .PdfAnnotation ;};func (_dbgf rgbColor )ToRGB ()(float64 ,float64 ,float64 ){return _dbgf ._acgf ,_dbgf ._fcbcc ,_dbgf ._ebf ;
};

// HorizontalAlignment represents the horizontal alignment of components
// within a page.
type HorizontalAlignment int ;

// ColorCMYKFromArithmetic creates a Color from arithmetic color values (0-1).
// Example:
//   green := ColorCMYKFromArithmetic(1.0, 0.0, 1.0, 0.0)
func ColorCMYKFromArithmetic (c ,m ,y ,k float64 )Color {return cmykColor {_eedg :_cb .Max (_cb .Min (c ,1.0),0.0),_ggbfb :_cb .Max (_cb .Min (m ,1.0),0.0),_gaeb :_cb .Max (_cb .Min (y ,1.0),0.0),_eece :_cb .Max (_cb .Min (k ,1.0),0.0)};};func (_gecb *Invoice )generateTotalBlocks (_eabdd DrawContext )([]*Block ,DrawContext ,error ){_agcc :=_aaaeg (4);
_agcc .SetMargins (0,0,10,10);_gcfec :=[][2]*InvoiceCell {_gecb ._dbedcc };_gcfec =append (_gcfec ,_gecb ._aea ...);_gcfec =append (_gcfec ,_gecb ._fdefa );for _ ,_bdef :=range _gcfec {_ffacfg ,_cbbb :=_bdef [0],_bdef [1];if _cbbb .Value ==""{continue ;
};_agcc .SkipCells (2);_fbda :=_agcc .NewCell ();_fbda .SetBackgroundColor (_ffacfg .BackgroundColor );_fbda .SetHorizontalAlignment (_cbbb .Alignment );_gecb .setCellBorder (_fbda ,_ffacfg );_cbcef :=_fedb (_ffacfg .TextStyle );_cbcef .SetMargins (0,0,2,1);
_cbcef .Append (_ffacfg .Value );_fbda .SetContent (_cbcef );_fbda =_agcc .NewCell ();_fbda .SetBackgroundColor (_cbbb .BackgroundColor );_fbda .SetHorizontalAlignment (_cbbb .Alignment );_gecb .setCellBorder (_fbda ,_ffacfg );_cbcef =_fedb (_cbbb .TextStyle );
_cbcef .SetMargins (0,0,2,1);_cbcef .Append (_cbbb .Value );_fbda .SetContent (_cbcef );};return _agcc .GeneratePageBlocks (_eabdd );};

// SetMargins sets the margins of the chart component.
func (_cddb *Chart )SetMargins (left ,right ,top ,bottom float64 ){_cddb ._cfbc .Left =left ;_cddb ._cfbc .Right =right ;_cddb ._cfbc .Top =top ;_cddb ._cfbc .Bottom =bottom ;};

// NewImageFromGoImage creates an Image from a go image.Image data structure.
func (_bfde *Creator )NewImageFromGoImage (goimg _f .Image )(*Image ,error ){return _gbea (goimg )};

// SetIndent sets the cell's left indent.
func (_ffbf *TableCell )SetIndent (indent float64 ){_ffbf ._ggeb =indent };func (_dfce *Invoice )drawInformation ()*Table {_cefgg :=_aaaeg (2);_dfcea :=append ([][2]*InvoiceCell {_dfce ._bdgaa ,_dfce ._geff ,_dfce ._gaad },_dfce ._fabbc ...);for _ ,_ddaad :=range _dfcea {_ceec ,_abeb :=_ddaad [0],_ddaad [1];
if _abeb .Value ==""{continue ;};_abgc :=_cefgg .NewCell ();_abgc .SetBackgroundColor (_ceec .BackgroundColor );_dfce .setCellBorder (_abgc ,_ceec );_aaec :=_fedb (_ceec .TextStyle );_aaec .Append (_ceec .Value );_aaec .SetMargins (0,0,2,1);_abgc .SetContent (_aaec );
_abgc =_cefgg .NewCell ();_abgc .SetBackgroundColor (_abeb .BackgroundColor );_dfce .setCellBorder (_abgc ,_abeb );_aaec =_fedb (_abeb .TextStyle );_aaec .Append (_abeb .Value );_aaec .SetMargins (0,0,2,1);_abgc .SetContent (_aaec );};return _cefgg ;};


// CellHorizontalAlignment defines the table cell's horizontal alignment.
type CellHorizontalAlignment int ;