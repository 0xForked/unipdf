//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package context ;import (_c "errors";_db "github.com/golang/freetype/truetype";_de "github.com/unidoc/unipdf/v3/core";_ga "github.com/unidoc/unipdf/v3/internal/textencoding";_dd "github.com/unidoc/unipdf/v3/internal/transform";_ge "github.com/unidoc/unipdf/v3/model";
_ce "golang.org/x/image/font";_ca "image";_d "image/color";);func (_af *TextState )ProcTStar (){_af .ProcTd (0,-_af .Tl )};func (_ccf *TextState )Reset (){_ccf .Tm =_dd .IdentityMatrix ();_ccf .Tlm =_dd .IdentityMatrix ()};type LineCap int ;const (LineJoinRound LineJoin =iota ;
LineJoinBevel ;);func (_edb *TextFont )CharcodesToUnicode (charcodes []_ga .CharCode )[]rune {if _edb ._adc !=nil {return _edb ._adc .CharcodesToUnicode (charcodes );};return _edb .Font .CharcodesToUnicode (charcodes );};type Pattern interface{ColorAt (_dde ,_e int )_d .Color ;
};const (LineCapRound LineCap =iota ;LineCapButt ;LineCapSquare ;);func (_edg *TextFont )WithSize (size float64 ,originalFont *_ge .PdfFont )*TextFont {return &TextFont {Font :_edg .Font ,Size :size ,_eed :_edg ._eed ,_adc :originalFont };};func (_efe *TextState )ProcTm (a ,b ,c ,d ,e ,f float64 ){_efe .Tm =_dd .NewMatrix (a ,b ,c ,d ,e ,f );
_efe .Tlm =_efe .Tm .Clone ();};func (_bcg *TextFont )BytesToCharcodes (data []byte )[]_ga .CharCode {if _bcg ._adc !=nil {return _bcg ._adc .BytesToCharcodes (data );};return _bcg .Font .BytesToCharcodes (data );};func (_ddba *TextState )ProcTf (font *TextFont ){_ddba .Tf =font };
func (_deb *TextState )ProcTd (tx ,ty float64 ){_deb .Tlm .Concat (_dd .TranslationMatrix (tx ,ty ));_deb .Tm =_deb .Tlm .Clone ();};type TextRenderingMode int ;const (FillRuleWinding FillRule =iota ;FillRuleEvenOdd ;);func (_ggg *TextFont )GetRuneMetrics (r rune )(float64 ,float64 ,bool ){if _cde ,_dbd :=_ggg .Font .GetRuneMetrics (r );
_dbd &&_cde .Wx !=0{return _cde .Wx ,_cde .Wy ,_dbd ;};if _ggg ._adc ==nil {return 0,0,false ;};_caa ,_ab :=_ggg ._adc .GetRuneMetrics (r );return _caa .Wx ,_caa .Wy ,_ab &&_caa .Wx !=0;};type LineJoin int ;func (_bf *TextFont )GetCharMetrics (code _ga .CharCode )(float64 ,float64 ,bool ){if _adb ,_dg :=_bf .Font .GetCharMetrics (code );
_dg &&_adb .Wx !=0{return _adb .Wx ,_adb .Wy ,_dg ;};if _bf ._adc ==nil {return 0,0,false ;};_ccc ,_baeg :=_bf ._adc .GetCharMetrics (code );return _ccc .Wx ,_ccc .Wy ,_baeg &&_ccc .Wx !=0;};type TextState struct{Tc float64 ;Tw float64 ;Th float64 ;Tl float64 ;
Tf *TextFont ;Ts float64 ;Tm _dd .Matrix ;Tlm _dd .Matrix ;Tr TextRenderingMode ;GlobalScale float64 ;};func (_ada *TextState )ProcTj (data []byte ,ctx Context ){_bdd :=_ada .Tf .Size ;_bdf :=_ada .Th /100.0;_aad :=_ada .GlobalScale ;_dgf :=_dd .NewMatrix (_bdd *_bdf ,0,0,_bdd ,0,_ada .Ts );
_ecf :=ctx .Matrix ();_bgcc :=_ecf .Clone ().Mult (_ada .Tm .Clone ().Mult (_dgf )).ScalingFactorY ();_eceg :=_ada .Tf .NewFace (_bgcc );_eec :=_ada .Tf .BytesToCharcodes (data );_bbe :=_ada .Tf .CharcodesToUnicode (_eec );for _fac ,_aae :=range _bbe {if _aae =='\x00'{continue ;
};_ded :=_ecf .Clone ().Mult (_ada .Tm .Clone ().Mult (_dgf ));_aaa :=_ded .ScalingFactorY ();_ded =_ded .Scale (1/_aaa ,-1/_aaa );if _ada .Tr !=TextRenderingModeInvisible {ctx .SetMatrix (_ded );ctx .DrawString (string (_aae ),_eceg ,0,0);ctx .SetMatrix (_ecf );
};_cb :=0.0;if _aae ==' '{_cb =_ada .Tw ;};_fc ,_ ,_ddeg :=_ada .Tf .GetRuneMetrics (_aae );if !_ddeg &&_fac < len (_eec ){_fc ,_ ,_ddeg =_ada .Tf .GetCharMetrics (_eec [_fac ]);};if _ddeg {_fc =_fc *0.001*_bdd ;}else {_fc ,_ =ctx .MeasureString (string (_aae ),_eceg );
_fc =_fc /_aad ;};_abg :=(_fc +_ada .Tc +_cb )*_bdf ;_ada .Tm =_ada .Tm .Mult (_dd .TranslationMatrix (_abg ,0));};};const (TextRenderingModeFill TextRenderingMode =iota ;TextRenderingModeStroke ;TextRenderingModeFillStroke ;TextRenderingModeInvisible ;
TextRenderingModeFillClip ;TextRenderingModeStrokeClip ;TextRenderingModeFillStrokeClip ;TextRenderingModeClip ;);func (_cdd *TextState )ProcQ (data []byte ,ctx Context ){_cdd .ProcTStar ();_cdd .ProcTj (data ,ctx )};func (_baeb *TextState )ProcTD (tx ,ty float64 ){_baeb .Tl =-ty ;
_baeb .ProcTd (tx ,ty )};func (_fda *TextState )ProcDQ (data []byte ,aw ,ac float64 ,ctx Context ){_fda .Tw =aw ;_fda .Tc =ac ;_fda .ProcQ (data ,ctx );};func NewTextFont (font *_ge .PdfFont ,size float64 )(*TextFont ,error ){_gee :=font .FontDescriptor ();
if _gee ==nil {return nil ,_c .New ("\u0063\u006fu\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0066\u006f\u006e\u0074\u0020\u0064\u0065\u0073\u0063\u0072\u0069pt\u006f\u0072");};_eaf ,_cefg :=_de .GetStream (_gee .FontFile2 );if !_cefg {return nil ,_c .New ("\u006di\u0073\u0073\u0069\u006e\u0067\u0020\u0066\u006f\u006e\u0074\u0020f\u0069\u006c\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");
};_cg ,_cca :=_de .DecodeStream (_eaf );if _cca !=nil {return nil ,_cca ;};_ade ,_cca :=_db .Parse (_cg );if _cca !=nil {return nil ,_cca ;};return &TextFont {Font :font ,Size :size ,_eed :_ade },nil ;};type FillRule int ;func NewTextFontFromPath (filePath string ,size float64 )(*TextFont ,error ){_bec ,_eda :=_ge .NewPdfFontFromTTFFile (filePath );
if _eda !=nil {return nil ,_eda ;};return NewTextFont (_bec ,size );};func NewTextState ()TextState {return TextState {Th :100,Tm :_dd .IdentityMatrix (),Tlm :_dd .IdentityMatrix ()};};type Context interface{Push ();Pop ();Matrix ()_dd .Matrix ;SetMatrix (_ad _dd .Matrix );
Translate (_dc ,_b float64 );Scale (_ec ,_gef float64 );Rotate (_gc float64 );MoveTo (_bg ,_ece float64 );LineTo (_gf ,_bb float64 );CubicTo (_gce ,_bc ,_ced ,_f ,_ef ,_dda float64 );QuadraticTo (_ba ,_bga ,_gb ,_cee float64 );NewSubPath ();ClosePath ();
ClearPath ();Clip ();ClipPreserve ();ResetClip ();LineWidth ()float64 ;SetLineWidth (_ecef float64 );SetLineCap (_dba LineCap );SetLineJoin (_ea LineJoin );SetDash (_fg ...float64 );SetDashOffset (_be float64 );Fill ();FillPreserve ();Stroke ();StrokePreserve ();
SetRGBA (_ed ,_bgc ,_ddb ,_aa float64 );SetFillRGBA (_fa ,_ff ,_ee ,_fd float64 );SetFillStyle (_bd Pattern );SetFillRule (_cc FillRule );SetStrokeRGBA (_fge ,_efb ,_ffe ,_gfe float64 );SetStrokeStyle (_fb Pattern );FillPattern ()Pattern ;StrokePattern ()Pattern ;
TextState ()*TextState ;DrawString (_fe string ,_fad _ce .Face ,_fbc ,_bae float64 );MeasureString (_dcd string ,_dbab _ce .Face )(_cef ,_gd float64 );DrawRectangle (_gfa ,_cd ,_cec ,_eeb float64 );DrawImage (_feb _ca .Image ,_ddg ,_gg int );DrawImageAnchored (_fbcd _ca .Image ,_egf ,_febb int ,_fgg ,_cf float64 );
Height ()int ;Width ()int ;};func (_faa *TextState )Translate (tx ,ty float64 ){_faa .Tm =_faa .Tm .Mult (_dd .TranslationMatrix (tx ,ty ));};type Gradient interface{Pattern ;AddColorStop (_a float64 ,_eg _d .Color );};func (_bef *TextFont )NewFace (size float64 )_ce .Face {return _db .NewFace (_bef ._eed ,&_db .Options {Size :size });
};type TextFont struct{Font *_ge .PdfFont ;Size float64 ;_eed *_db .Font ;_adc *_ge .PdfFont ;};