//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package context ;import (_bf "errors";_d "github.com/unidoc/freetype/truetype";_fb "github.com/unidoc/unipdf/v3/core";_f "github.com/unidoc/unipdf/v3/internal/textencoding";_ga "github.com/unidoc/unipdf/v3/internal/transform";_ff "github.com/unidoc/unipdf/v3/model";
_ge "golang.org/x/image/font";_a "image";_b "image/color";);type Context interface{Push ();Pop ();Matrix ()_ga .Matrix ;SetMatrix (_bc _ga .Matrix );Translate (_bcb ,_e float64 );Scale (_ae ,_gaa float64 );Rotate (_fc float64 );MoveTo (_ef ,_efe float64 );
LineTo (_bfd ,_bb float64 );CubicTo (_gd ,_c ,_bd ,_fg ,_fbb ,_bg float64 );QuadraticTo (_gae ,_fbd ,_fa ,_gb float64 );NewSubPath ();ClosePath ();ClearPath ();Clip ();ClipPreserve ();ResetClip ();LineWidth ()float64 ;SetLineWidth (_dd float64 );SetLineCap (_bfe LineCap );
SetLineJoin (_df LineJoin );SetDash (_eb ...float64 );SetDashOffset (_ec float64 );Fill ();FillPreserve ();Stroke ();StrokePreserve ();SetRGBA (_eg ,_cb ,_adb ,_aee float64 );SetFillRGBA (_gc ,_fcg ,_bga ,_ed float64 );SetFillStyle (_ea Pattern );SetFillRule (_gbe FillRule );
SetStrokeRGBA (_ggc ,_egf ,_ce ,_ab float64 );SetStrokeStyle (_ca Pattern );FillPattern ()Pattern ;StrokePattern ()Pattern ;TextState ()*TextState ;DrawString (_gf string ,_fff _ge .Face ,_ee ,_gfc float64 );MeasureString (_fbf string ,_cd _ge .Face )(_eef ,_db float64 );
DrawRectangle (_aa ,_fgd ,_dfg ,_dc float64 );DrawImage (_gac _a .Image ,_gfe ,_fe int );DrawImageAnchored (_cde _a .Image ,_aef ,_de int ,_eab ,_cad float64 );Height ()int ;Width ()int ;};func (_gecg *TextFont )NewFace (size float64 )_ge .Face {return _d .NewFace (_gecg ._fgg ,&_d .Options {Size :size });
};type LineCap int ;func (_ada *TextState )ProcDQ (data []byte ,aw ,ac float64 ,ctx Context ){_ada .Tw =aw ;_ada .Tc =ac ;_ada .ProcQ (data ,ctx );};func (_bfdc *TextState )ProcTj (data []byte ,ctx Context ){_fgda :=_bfdc .Tf .Size ;_dda :=_bfdc .Th /100.0;
_gaae :=_bfdc .GlobalScale ;_af :=_ga .NewMatrix (_fgda *_dda ,0,0,_fgda ,0,_bfdc .Ts );_cbe :=ctx .Matrix ();_cc :=_cbe .Clone ().Mult (_bfdc .Tm .Clone ().Mult (_af )).ScalingFactorY ();_geec :=_bfdc .Tf .NewFace (_cc );_ceg :=_bfdc .Tf .BytesToCharcodes (data );
for _ ,_cfea :=range _ceg {_edb ,_bda :=_bfdc .Tf .CharcodeToRunes (_cfea );_ced :=string (_bda );if _ced =="\u0000"{continue ;};_eaeg :=_cbe .Clone ().Mult (_bfdc .Tm .Clone ().Mult (_af ));_ebc :=_eaeg .ScalingFactorY ();_eaeg =_eaeg .Scale (1/_ebc ,-1/_ebc );
if _bfdc .Tr !=TextRenderingModeInvisible {ctx .SetMatrix (_eaeg );ctx .DrawString (_ced ,_geec ,0,0);ctx .SetMatrix (_cbe );};_cag :=0.0;if _ced =="\u0020"{_cag =_bfdc .Tw ;};_fcgb ,_ ,_fab :=_bfdc .Tf .GetCharMetrics (_edb );if _fab {_fcgb =_fcgb *0.001*_fgda ;
}else {_fcgb ,_ =ctx .MeasureString (_ced ,_geec );_fcgb =_fcgb /_gaae ;};_gad :=(_fcgb +_bfdc .Tc +_cag )*_dda ;_bfdc .Tm =_bfdc .Tm .Mult (_ga .TranslationMatrix (_gad ,0));};};func (_eea *TextState )ProcTd (tx ,ty float64 ){_eea .Tlm .Concat (_ga .TranslationMatrix (tx ,ty ));
_eea .Tm =_eea .Tlm .Clone ();};func (_cfe *TextFont )GetCharMetrics (code _f .CharCode )(float64 ,float64 ,bool ){if _cfb ,_bdg :=_cfe .Font .GetCharMetrics (code );_bdg &&_cfb .Wx !=0{return _cfb .Wx ,_cfb .Wy ,_bdg ;};if _cfe ._aba ==nil {return 0,0,false ;
};_fbg ,_fgdc :=_cfe ._aba .GetCharMetrics (code );return _fbg .Wx ,_fbg .Wy ,_fgdc &&_fbg .Wx !=0;};type TextFont struct{Font *_ff .PdfFont ;Size float64 ;_fgg *_d .Font ;_aba *_ff .PdfFont ;};func (_da *TextState )ProcTStar (){_da .ProcTd (0,-_da .Tl )};
type TextState struct{Tc float64 ;Tw float64 ;Th float64 ;Tl float64 ;Tf *TextFont ;Ts float64 ;Tm _ga .Matrix ;Tlm _ga .Matrix ;Tr TextRenderingMode ;GlobalScale float64 ;};func (_fcb *TextState )ProcTD (tx ,ty float64 ){_fcb .Tl =-ty ;_fcb .ProcTd (tx ,ty )};
func (_gee *TextState )ProcTm (a ,b ,c ,d ,e ,f float64 ){_gee .Tm =_ga .NewMatrix (a ,b ,c ,d ,e ,f );_gee .Tlm =_gee .Tm .Clone ();};func (_gab *TextFont )BytesToCharcodes (data []byte )[]_f .CharCode {if _gab ._aba !=nil {return _gab ._aba .BytesToCharcodes (data );
};return _gab .Font .BytesToCharcodes (data );};func (_adbd *TextState )ProcQ (data []byte ,ctx Context ){_adbd .ProcTStar ();_adbd .ProcTj (data ,ctx )};type LineJoin int ;const (FillRuleWinding FillRule =iota ;FillRuleEvenOdd ;);type FillRule int ;func (_adc *TextState )Reset (){_adc .Tm =_ga .IdentityMatrix ();
_adc .Tlm =_ga .IdentityMatrix ()};const (TextRenderingModeFill TextRenderingMode =iota ;TextRenderingModeStroke ;TextRenderingModeFillStroke ;TextRenderingModeInvisible ;TextRenderingModeFillClip ;TextRenderingModeStrokeClip ;TextRenderingModeFillStrokeClip ;
TextRenderingModeClip ;);type Pattern interface{ColorAt (_ad ,_gef int )_b .Color ;};type Gradient interface{Pattern ;AddColorStop (_ac float64 ,_gg _b .Color );};const (LineJoinRound LineJoin =iota ;LineJoinBevel ;);func (_bbd *TextFont )WithSize (size float64 ,originalFont *_ff .PdfFont )*TextFont {return &TextFont {Font :_bbd .Font ,Size :size ,_fgg :_bbd ._fgg ,_aba :originalFont };
};func NewTextFont (font *_ff .PdfFont ,size float64 )(*TextFont ,error ){_cf :=font .FontDescriptor ();if _cf ==nil {return nil ,_bf .New ("\u0063\u006fu\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0066\u006f\u006e\u0074\u0020\u0064\u0065\u0073\u0063\u0072\u0069pt\u006f\u0072");
};_dbd ,_fad :=_fb .GetStream (_cf .FontFile2 );if !_fad {return nil ,_bf .New ("\u006di\u0073\u0073\u0069\u006e\u0067\u0020\u0066\u006f\u006e\u0074\u0020f\u0069\u006c\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");};_aeb ,_cg :=_fb .DecodeStream (_dbd );
if _cg !=nil {return nil ,_cg ;};_eae ,_cg :=_d .Parse (_aeb );if _cg !=nil {return nil ,_cg ;};return &TextFont {Font :font ,Size :size ,_fgg :_eae },nil ;};func (_bbc *TextState )ProcTf (font *TextFont ){_bbc .Tf =font };func NewTextState ()TextState {return TextState {Th :100,Tm :_ga .IdentityMatrix (),Tlm :_ga .IdentityMatrix ()};
};const (LineCapRound LineCap =iota ;LineCapButt ;LineCapSquare ;);func (_fbe *TextState )Translate (tx ,ty float64 ){_fbe .Tm =_fbe .Tm .Mult (_ga .TranslationMatrix (tx ,ty ));};func (_gdb *TextFont )CharcodeToRunes (charcode _f .CharCode )(_f .CharCode ,[]rune ){_ade :=[]_f .CharCode {charcode };
if _gdb ._aba ==nil ||_gdb ._aba ==_gdb .Font {if _gdb .Font .IsSimple ()&&_gdb ._fgg !=nil {if _ggcb :=_gdb ._fgg .Index (rune (charcode ));_ggcb > 0{return charcode ,[]rune {rune (charcode )};};};return charcode ,_gdb .Font .CharcodesToUnicode (_ade );
};_gfa :=_gdb ._aba .CharcodesToUnicode (_ade );_aded ,_ :=_gdb .Font .RunesToCharcodeBytes (_gfa );_ba :=_gdb .Font .BytesToCharcodes (_aded );_gaab :=charcode ;if len (_ba )> 0&&_ba [0]!=0{_gaab =_ba [0];};return _gaab ,_gfa ;};type TextRenderingMode int ;
func NewTextFontFromPath (filePath string ,size float64 )(*TextFont ,error ){_edc ,_gec :=_ff .NewPdfFontFromTTFFile (filePath );if _gec !=nil {return nil ,_gec ;};return NewTextFont (_edc ,size );};