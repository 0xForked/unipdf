//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package context ;import (_gg "errors";_ef "github.com/golang/freetype/truetype";_c "github.com/unidoc/unipdf/v3/core";_e "github.com/unidoc/unipdf/v3/internal/textencoding";_d "github.com/unidoc/unipdf/v3/internal/transform";_b "github.com/unidoc/unipdf/v3/model";_ea "golang.org/x/image/font";_f "image";_g "image/color";);func NewTextFont (font *_b .PdfFont ,size float64 )(*TextFont ,error ){_bfc :=font .FontDescriptor ();if _bfc ==nil {return nil ,_gg .New ("\u0063\u006fu\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0066\u006f\u006e\u0074\u0020\u0064\u0065\u0073\u0063\u0072\u0069pt\u006f\u0072");};_cfc ,_aca :=_c .GetStream (_bfc .FontFile2 );if !_aca {return nil ,_gg .New ("\u006di\u0073\u0073\u0069\u006e\u0067\u0020\u0066\u006f\u006e\u0074\u0020f\u0069\u006c\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");};_dcb ,_dfc :=_c .DecodeStream (_cfc );if _dfc !=nil {return nil ,_dfc ;};_cd ,_dfc :=_ef .Parse (_dcb );if _dfc !=nil {return nil ,_dfc ;};if size <=1{size =10;};return &TextFont {Font :font ,Face :_ef .NewFace (_cd ,&_ef .Options {Size :size }),Size :size ,_dbb :_cd },nil ;};func (_aeb *TextState )ProcTm (a ,b ,c ,d ,e ,f float64 ){_aeb .Tm =_d .NewMatrix (a ,b ,c ,d ,e ,-f );_aeb .Tlm =_aeb .Tm .Clone ();};func (_gga *TextState )ProcTf (font *TextFont ){_gga .Tf =font };func (_de *TextFont )WithSize (size float64 ,originalFont *_b .PdfFont )*TextFont {if size <=1{size =10;};return &TextFont {Font :_de .Font ,Face :_ef .NewFace (_de ._dbb ,&_ef .Options {Size :size }),Size :size ,_dbb :_de ._dbb ,_cec :originalFont };};const (LineCapRound LineCap =iota ;LineCapButt ;LineCapSquare ;);type Pattern interface{ColorAt (_gc ,_ag int )_g .Color ;};func (_ega *TextFont )GetCharMetrics (code _e .CharCode )(float64 ,float64 ,bool ){if _gd ,_ga :=_ega .Font .GetCharMetrics (code );_ga &&_gd .Wx !=0{return _gd .Wx ,_gd .Wy ,_ga ;};if _ega ._cec ==nil {return 0,0,false ;};_daf ,_gfb :=_ega ._cec .GetCharMetrics (code );return _daf .Wx ,_daf .Wy ,_gfb &&_daf .Wx !=0;};func (_fcc *TextState )ProcDQ (data []byte ,aw ,ac float64 ,ctx Context ){_fcc .Tw =aw ;_fcc .Tc =ac ;_fcc .ProcQ (data ,ctx );};func NewTextState ()*TextState {return &TextState {Th :100,Tm :_d .IdentityMatrix (),Tlm :_d .IdentityMatrix ()};};const (LineJoinRound LineJoin =iota ;LineJoinBevel ;);type FillRule int ;const (FillRuleWinding FillRule =iota ;FillRuleEvenOdd ;);func (_baf *TextFont )CharcodesToUnicode (charcodes []_e .CharCode )[]rune {if _baf ._cec !=nil {return _baf ._cec .CharcodesToUnicode (charcodes );};return _baf .Font .CharcodesToUnicode (charcodes );};type TextState struct{Tc float64 ;Tw float64 ;Th float64 ;Tl float64 ;Tf *TextFont ;Ts float64 ;Tm _d .Matrix ;Tlm _d .Matrix ;};type LineJoin int ;func (_ecb *TextState )Translate (tx ,ty float64 ){_ecb .Tm =_d .TranslationMatrix (tx ,ty ).Mult (_ecb .Tm );};func (_ab *TextFont )BytesToCharcodes (data []byte )[]_e .CharCode {if _ab ._cec !=nil {return _ab ._cec .BytesToCharcodes (data );};return _ab .Font .BytesToCharcodes (data );};func (_def *TextState )ProcTD (tx ,ty float64 ){_def .Tl =-ty ;_def .ProcTd (tx ,ty )};type Context interface{Push ();Pop ();Matrix ()_d .Matrix ;SetMatrix (_aa _d .Matrix );Translate (_eb ,_ae float64 );Scale (_ac ,_cbd float64 );Rotate (_fa float64 );MoveTo (_gb ,_bf float64 );LineTo (_acf ,_bc float64 );CubicTo (_ed ,_fad ,_eae ,_fc ,_bg ,_af float64 );QuadraticTo (_gge ,_aab ,_dg ,_bd float64 );NewSubPath ();ClosePath ();ClearPath ();Clip ();ClipPreserve ();ResetClip ();LineWidth ()float64 ;SetLineWidth (_da float64 );SetLineCap (_aec LineCap );SetLineJoin (_bdf LineJoin );SetDash (_ce ...float64 );SetDashOffset (_gcg float64 );Fill ();FillPreserve ();Stroke ();StrokePreserve ();SetRGBA (_df ,_gba ,_agc ,_be float64 );SetFillRGBA (_efd ,_ge ,_agb ,_dc float64 );SetFillStyle (_ad Pattern );SetFillRule (_eg FillRule );SetStrokeRGBA (_dgc ,_gcf ,_gf ,_ba float64 );SetStrokeStyle (_egg Pattern );TextState ()*TextState ;DrawString (_aga string ,_ec ,_cg float64 );MeasureString (_aef string )(_egge ,_afb float64 );DrawRectangle (_cbg ,_ee ,_ca ,_edc float64 );DrawImage (_cf _f .Image ,_egd ,_cc int );DrawImageAnchored (_db _f .Image ,_cfg ,_cea int ,_ade ,_gee float64 );Height ()int ;Width ()int ;};type Gradient interface{Pattern ;AddColorStop (_cb float64 ,_bb _g .Color );};func (_ddg *TextState )ProcQ (data []byte ,ctx Context ){_ddg .ProcTStar ();_ddg .ProcTj (data ,ctx )};func (_baa *TextState )Reset (){_baa .Tm =_d .IdentityMatrix ();_baa .Tlm =_d .IdentityMatrix ()};func (_dge *TextFont )GetRuneMetrics (r rune )(float64 ,float64 ,bool ){if _dbc ,_dae :=_dge .Font .GetRuneMetrics (r );_dae &&_dbc .Wx !=0{return _dbc .Wx ,_dbc .Wy ,_dae ;};if _dge ._cec ==nil {return 0,0,false ;};_abd ,_dd :=_dge ._cec .GetRuneMetrics (r );return _abd .Wx ,_abd .Wy ,_dd &&_abd .Wx !=0;};func (_daee *TextState )ProcTd (tx ,ty float64 ){_daee .Tlm .Concat (_d .TranslationMatrix (tx ,-ty ));_daee .Tm =_daee .Tlm .Clone ();};func (_gdg *TextState )ProcTj (data []byte ,ctx Context ){_eec :=_gdg .Tf .Size ;_cde :=_gdg .Th /100.0;_eba :=_d .NewMatrix (_eec *_cde ,0,0,_eec ,0,_gdg .Ts );_ggg :=_gdg .Tf .CharcodesToUnicode (_gdg .Tf .BytesToCharcodes (data ));for _ ,_abb :=range _ggg {if _abb =='\x00'{continue ;};_bde :=_gdg .Tm .Clone ();_gdg .Tm .Concat (_eba );_cab ,_bdc :=_gdg .Tm .Transform (0,0);ctx .Scale (1,-1);ctx .DrawString (string (_abb ),_cab ,_bdc );ctx .Scale (1,-1);_bae :=0.0;if _abb ==' '{_bae =_gdg .Tw ;};var _acfd float64 ;if _dcg ,_ ,_gcgg :=_gdg .Tf .GetRuneMetrics (_abb );_gcgg {_acfd =_dcg *0.001*_eec ;}else {_acfd ,_ =ctx .MeasureString (string (_abb ));};_afc :=(_acfd +_gdg .Tc +_bae )*_cde ;_gdg .Tm =_d .TranslationMatrix (_afc ,0).Mult (_bde );};};func NewTextFontFromPath (filePath string ,size float64 )(*TextFont ,error ){_eeg ,_ebf :=_b .NewPdfFontFromTTFFile (filePath );if _ebf !=nil {return nil ,_ebf ;};return NewTextFont (_eeg ,size );};func (_cbdd *TextState )ProcTStar (){_cbdd .ProcTd (0,-_cbdd .Tl )};type LineCap int ;type TextFont struct{Font *_b .PdfFont ;Face _ea .Face ;Size float64 ;_dbb *_ef .Font ;_cec *_b .PdfFont ;};