//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package context ;import (_b "errors";_cc "github.com/golang/freetype/truetype";_bc "github.com/unidoc/unipdf/v3/core";_c "github.com/unidoc/unipdf/v3/internal/textencoding";_f "github.com/unidoc/unipdf/v3/internal/transform";_eb "github.com/unidoc/unipdf/v3/model";
_e "golang.org/x/image/font";_g "image";_d "image/color";);type TextRenderingMode int ;func (_dcf *TextState )Translate (tx ,ty float64 ){_dcf .Tm =_dcf .Tm .Mult (_f .TranslationMatrix (tx ,ty ));};type Context interface{Push ();Pop ();Matrix ()_f .Matrix ;
SetMatrix (_ge _f .Matrix );Translate (_ff ,_gd float64 );Scale (_ag ,_da float64 );Rotate (_ffc float64 );MoveTo (_gdb ,_ec float64 );LineTo (_ad ,_ce float64 );CubicTo (_gdc ,_bdb ,_ccc ,_gf ,_aa ,_ccf float64 );QuadraticTo (_cf ,_eg ,_bg ,_ac float64 );
NewSubPath ();ClosePath ();ClearPath ();Clip ();ClipPreserve ();ResetClip ();LineWidth ()float64 ;SetLineWidth (_fg float64 );SetLineCap (_bgf LineCap );SetLineJoin (_bf LineJoin );SetDash (_fcf ...float64 );SetDashOffset (_dc float64 );Fill ();FillPreserve ();
Stroke ();StrokePreserve ();SetRGBA (_be ,_dg ,_fb ,_ffce float64 );SetFillRGBA (_gda ,_cfd ,_gfa ,_gec float64 );SetFillStyle (_ef Pattern );SetFillRule (_ba FillRule );SetStrokeRGBA (_fe ,_fbe ,_gdcg ,_cbc float64 );SetStrokeStyle (_db Pattern );FillPattern ()Pattern ;
StrokePattern ()Pattern ;TextState ()*TextState ;DrawString (_gc string ,_cfg _e .Face ,_bag ,_bcc float64 );MeasureString (_agc string ,_fcg _e .Face )(_bea ,_fce float64 );DrawRectangle (_gb ,_ab ,_ffd ,_aba float64 );DrawImage (_gcc _g .Image ,_fa ,_ceb int );
DrawImageAnchored (_cbg _g .Image ,_ga ,_ebd int ,_fbb ,_bcg float64 );Height ()int ;Width ()int ;};type LineCap int ;type Pattern interface{ColorAt (_fc ,_cb int )_d .Color ;};type TextFont struct{Font *_eb .PdfFont ;Size float64 ;_ca *_cc .Font ;_ade *_eb .PdfFont ;
};type Gradient interface{Pattern ;AddColorStop (_bd float64 ,_df _d .Color );};type TextState struct{Tc float64 ;Tw float64 ;Th float64 ;Tl float64 ;Tf *TextFont ;Ts float64 ;Tm _f .Matrix ;Tlm _f .Matrix ;Tr TextRenderingMode ;GlobalScale float64 ;};
type LineJoin int ;func (_eee *TextState )ProcDQ (data []byte ,aw ,ac float64 ,ctx Context ){_eee .Tw =aw ;_eee .Tc =ac ;_eee .ProcQ (data ,ctx );};func (_agg *TextState )ProcTd (tx ,ty float64 ){_agg .Tlm .Concat (_f .TranslationMatrix (tx ,ty ));_agg .Tm =_agg .Tlm .Clone ();
};func NewTextFont (font *_eb .PdfFont ,size float64 )(*TextFont ,error ){_bgc :=font .FontDescriptor ();if _bgc ==nil {return nil ,_b .New ("\u0063\u006fu\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0066\u006f\u006e\u0074\u0020\u0064\u0065\u0073\u0063\u0072\u0069pt\u006f\u0072");
};_dff ,_fd :=_bc .GetStream (_bgc .FontFile2 );if !_fd {return nil ,_b .New ("\u006di\u0073\u0073\u0069\u006e\u0067\u0020\u0066\u006f\u006e\u0074\u0020f\u0069\u006c\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");};_eca ,_cbb :=_bc .DecodeStream (_dff );
if _cbb !=nil {return nil ,_cbb ;};_ae ,_cbb :=_cc .Parse (_eca );if _cbb !=nil {return nil ,_cbb ;};return &TextFont {Font :font ,Size :size ,_ca :_ae },nil ;};func (_ebe *TextState )ProcQ (data []byte ,ctx Context ){_ebe .ProcTStar ();_ebe .ProcTj (data ,ctx )};
func (_ee *TextFont )NewFace (size float64 )_e .Face {return _cc .NewFace (_ee ._ca ,&_cc .Options {Size :size });};func (_gbeg *TextState )ProcTf (font *TextFont ){_gbeg .Tf =font };func (_dag *TextState )ProcTStar (){_dag .ProcTd (0,-_dag .Tl )};func (_fgg *TextFont )WithSize (size float64 ,originalFont *_eb .PdfFont )*TextFont {return &TextFont {Font :_fgg .Font ,Size :size ,_ca :_fgg ._ca ,_ade :originalFont };
};func (_bb *TextFont )GetRuneMetrics (r rune )(float64 ,float64 ,bool ){if _gbe ,_gdd :=_bb .Font .GetRuneMetrics (r );_gdd &&_gbe .Wx !=0{return _gbe .Wx ,_gbe .Wy ,_gdd ;};if _bb ._ade ==nil {return 0,0,false ;};_aaaf ,_dd :=_bb ._ade .GetRuneMetrics (r );
return _aaaf .Wx ,_aaaf .Wy ,_dd &&_aaaf .Wx !=0;};const (TextRenderingModeFill TextRenderingMode =iota ;TextRenderingModeStroke ;TextRenderingModeFillStroke ;TextRenderingModeInvisible ;TextRenderingModeFillClip ;TextRenderingModeStrokeClip ;TextRenderingModeFillStrokeClip ;
TextRenderingModeClip ;);const (LineJoinRound LineJoin =iota ;LineJoinBevel ;);func NewTextState ()TextState {return TextState {Th :100,Tm :_f .IdentityMatrix (),Tlm :_f .IdentityMatrix ()};};type FillRule int ;const (FillRuleWinding FillRule =iota ;FillRuleEvenOdd ;
);func (_dbb *TextState )ProcTD (tx ,ty float64 ){_dbb .Tl =-ty ;_dbb .ProcTd (tx ,ty )};func (_cfe *TextState )ProcTj (data []byte ,ctx Context ){_ecg :=_cfe .Tf .Size ;_cba :=_cfe .Th /100.0;_dage :=_cfe .GlobalScale ;_aad :=_f .NewMatrix (_ecg *_cba ,0,0,_ecg ,0,_cfe .Ts );
_efd :=ctx .Matrix ();_bfg :=_efd .Clone ().Mult (_cfe .Tm .Clone ().Mult (_aad )).ScalingFactorY ();_gag :=_cfe .Tf .NewFace (_bfg );_af :=_cfe .Tf .BytesToCharcodes (data );_beg :=_cfe .Tf .CharcodesToUnicode (_af );for _cd ,_gcd :=range _beg {if _gcd =='\x00'{continue ;
};_gg :=_efd .Clone ().Mult (_cfe .Tm .Clone ().Mult (_aad ));_adg :=_gg .ScalingFactorY ();_gg =_gg .Scale (1/_adg ,-1/_adg );if _cfe .Tr !=TextRenderingModeInvisible {ctx .SetMatrix (_gg );ctx .DrawString (string (_gcd ),_gag ,0,0);ctx .SetMatrix (_efd );
};_ea :=0.0;if _gcd ==' '{_ea =_cfe .Tw ;};_aff ,_ ,_cfae :=_cfe .Tf .GetRuneMetrics (_gcd );if !_cfae &&_cd < len (_af ){_aff ,_ ,_cfae =_cfe .Tf .GetCharMetrics (_af [_cd ]);};if _cfae {_aff =_aff *0.001*_ecg ;}else {_aff ,_ =ctx .MeasureString (string (_gcd ),_gag );
_aff =_aff /_dage ;};_fbfg :=(_aff +_cfe .Tc +_ea )*_cba ;_cfe .Tm =_cfe .Tm .Mult (_f .TranslationMatrix (_fbfg ,0));};};func (_bfd *TextFont )BytesToCharcodes (data []byte )[]_c .CharCode {if _bfd ._ade !=nil {return _bfd ._ade .BytesToCharcodes (data );
};return _bfd .Font .BytesToCharcodes (data );};func (_ccb *TextFont )CharcodesToUnicode (charcodes []_c .CharCode )[]rune {if _ccb ._ade !=nil {return _ccb ._ade .CharcodesToUnicode (charcodes );};return _ccb .Font .CharcodesToUnicode (charcodes );};func (_aaa *TextFont )GetCharMetrics (code _c .CharCode )(float64 ,float64 ,bool ){if _fgf ,_fdd :=_aaa .Font .GetCharMetrics (code );
_fdd &&_fgf .Wx !=0{return _fgf .Wx ,_fgf .Wy ,_fdd ;};if _aaa ._ade ==nil {return 0,0,false ;};_fed ,_dbe :=_aaa ._ade .GetCharMetrics (code );return _fed .Wx ,_fed .Wy ,_dbe &&_fed .Wx !=0;};func NewTextFontFromPath (filePath string ,size float64 )(*TextFont ,error ){_cfa ,_gfc :=_eb .NewPdfFontFromTTFFile (filePath );
if _gfc !=nil {return nil ,_gfc ;};return NewTextFont (_cfa ,size );};func (_cea *TextState )ProcTm (a ,b ,c ,d ,e ,f float64 ){_cea .Tm =_f .NewMatrix (a ,b ,c ,d ,e ,f );_cea .Tlm =_cea .Tm .Clone ();};func (_dgf *TextState )Reset (){_dgf .Tm =_f .IdentityMatrix ();
_dgf .Tlm =_f .IdentityMatrix ()};const (LineCapRound LineCap =iota ;LineCapButt ;LineCapSquare ;);