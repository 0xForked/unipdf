//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package context ;import (_c "errors";_fg "github.com/golang/freetype/truetype";_eb "github.com/unidoc/unipdf/v3/core";_e "github.com/unidoc/unipdf/v3/internal/textencoding";_ba "github.com/unidoc/unipdf/v3/internal/transform";_dc "github.com/unidoc/unipdf/v3/model";_f "golang.org/x/image/font";_d "image";_g "image/color";);func NewTextFont (font *_dc .PdfFont ,size float64 )(*TextFont ,error ){_bcc :=font .FontDescriptor ();if _bcc ==nil {return nil ,_c .New ("\u0063\u006fu\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0067\u0065\u0074\u0020\u0066\u006f\u006e\u0074\u0020\u0064\u0065\u0073\u0063\u0072\u0069pt\u006f\u0072");};_cd ,_eaf :=_eb .GetStream (_bcc .FontFile2 );if !_eaf {return nil ,_c .New ("\u006di\u0073\u0073\u0069\u006e\u0067\u0020\u0066\u006f\u006e\u0074\u0020f\u0069\u006c\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");};_gee ,_cag :=_eb .DecodeStream (_cd );if _cag !=nil {return nil ,_cag ;};_ggf ,_cag :=_fg .Parse (_gee );if _cag !=nil {return nil ,_cag ;};if size <=1{size =10;};return &TextFont {Font :font ,Face :_fg .NewFace (_ggf ,&_fg .Options {Size :size }),Size :size ,_adb :_ggf },nil ;};func NewTextState ()*TextState {return &TextState {Th :100,Tm :_ba .IdentityMatrix (),Tlm :_ba .IdentityMatrix ()};};func (_gfc *TextState )Translate (tx ,ty float64 ){_gfc .Tm =_ba .TranslationMatrix (tx ,ty ).Mult (_gfc .Tm );};type FillRule int ;type Pattern interface{ColorAt (_gf ,_fd int )_g .Color ;};func (_gc *TextState )ProcQ (data []byte ,ctx Context ){_gc .ProcTStar ();_gc .ProcTj (data ,ctx )};type LineJoin int ;const (FillRuleWinding FillRule =iota ;FillRuleEvenOdd ;);func (_agf *TextState )ProcTd (tx ,ty float64 ){_agf .Tlm .Concat (_ba .TranslationMatrix (tx ,-ty ));_agf .Tm =_agf .Tlm .Clone ();};func (_bbf *TextState )ProcTStar (){_bbf .ProcTd (0,-_bbf .Tl )};func (_cde *TextState )Reset (){_cde .Tm =_ba .IdentityMatrix ();_cde .Tlm =_ba .IdentityMatrix ()};func (_aa *TextState )ProcTD (tx ,ty float64 ){_aa .Tl =-ty ;_aa .ProcTd (tx ,ty )};func (_dde *TextFont )WithSize (size float64 ,originalFont *_dc .PdfFont )*TextFont {if size <=1{size =10;};return &TextFont {Font :_dde .Font ,Face :_fg .NewFace (_dde ._adb ,&_fg .Options {Size :size }),Size :size ,_adb :_dde ._adb ,_gdb :originalFont };};func (_dae *TextFont )GetCharMetrics (code _e .CharCode )(float64 ,float64 ,bool ){if _cab ,_bcg :=_dae .Font .GetCharMetrics (code );_bcg &&_cab .Wx !=0{return _cab .Wx ,_cab .Wy ,_bcg ;};if _dae ._gdb ==nil {return 0,0,false ;};_fe ,_gbf :=_dae ._gdb .GetCharMetrics (code );return _fe .Wx ,_fe .Wy ,_gbf &&_fe .Wx !=0;};func (_adba *TextState )ProcTm (a ,b ,c ,d ,e ,f float64 ){_adba .Tm =_ba .NewMatrix (a ,b ,c ,d ,e ,-f );_adba .Tlm =_adba .Tm .Clone ();};type Context interface{Push ();Pop ();Matrix ()_ba .Matrix ;SetMatrix (_fc _ba .Matrix );Translate (_eba ,_bg float64 );Scale (_df ,_ef float64 );Rotate (_cg float64 );MoveTo (_a ,_fa float64 );LineTo (_be ,_ec float64 );CubicTo (_cgb ,_da ,_bb ,_dg ,_fdc ,_gfb float64 );QuadraticTo (_gd ,_ed ,_efb ,_bc float64 );NewSubPath ();ClosePath ();ClearPath ();Clip ();ClipPreserve ();ResetClip ();LineWidth ()float64 ;SetLineWidth (_ea float64 );SetLineCap (_ab LineCap );SetLineJoin (_edd LineJoin );SetDash (_baa ...float64 );SetDashOffset (_ggg float64 );Fill ();FillPreserve ();Stroke ();StrokePreserve ();SetRGBA (_fde ,_bab ,_ede ,_caa float64 );SetFillRGBA (_bcb ,_ad ,_eaa ,_bcd float64 );SetFillStyle (_adc Pattern );SetFillRule (_dcb FillRule );SetStrokeRGBA (_fac ,_ggb ,_ae ,_cf float64 );SetStrokeStyle (_dff Pattern );TextState ()*TextState ;DrawString (_ge string ,_fb ,_cc float64 );MeasureString (_eac string )(_dd ,_gde float64 );DrawRectangle (_ece ,_fgb ,_fgf ,_ecb float64 );DrawImage (_db _d .Image ,_eae ,_dcbg int );DrawImageAnchored (_ag _d .Image ,_fcb ,_ee int ,_gb ,_adf float64 );Height ()int ;Width ()int ;};const (LineJoinRound LineJoin =iota ;LineJoinBevel ;);func (_eg *TextState )ProcDQ (data []byte ,aw ,ac float64 ,ctx Context ){_eg .Tw =aw ;_eg .Tc =ac ;_eg .ProcQ (data ,ctx );};func (_ccc *TextState )ProcTj (data []byte ,ctx Context ){_cdg :=_ccc .Tf .Size ;_cce :=_ccc .Th /100.0;_dcc :=_ba .NewMatrix (_cdg *_cce ,0,0,_cdg ,0,_ccc .Ts );_ebe :=_ccc .Tf .CharcodesToUnicode (_ccc .Tf .BytesToCharcodes (data ));for _ ,_fgbf :=range _ebe {if _fgbf =='\x00'{continue ;};_gec :=_ccc .Tm .Clone ();_ccc .Tm .Concat (_dcc );_bf ,_ddc :=_ccc .Tm .Transform (0,0);ctx .Scale (1,-1);ctx .DrawString (string (_fgbf ),_bf ,_ddc );ctx .Scale (1,-1);_facd :=0.0;if _fgbf ==' '{_facd =_ccc .Tw ;};var _bdf float64 ;if _ebg ,_ ,_fdb :=_ccc .Tf .GetRuneMetrics (_fgbf );_fdb {_bdf =_ebg *0.001*_cdg ;}else {_bdf ,_ =ctx .MeasureString (string (_fgbf ));};_beg :=(_bdf +_ccc .Tc +_facd )*_cce ;_ccc .Tm =_ba .TranslationMatrix (_beg ,0).Mult (_gec );};};func (_cb *TextState )ProcTf (font *TextFont ){_cb .Tf =font };func (_dfa *TextFont )GetRuneMetrics (r rune )(float64 ,float64 ,bool ){if _bgc ,_geb :=_dfa .Font .GetRuneMetrics (r );_geb &&_bgc .Wx !=0{return _bgc .Wx ,_bgc .Wy ,_geb ;};if _dfa ._gdb ==nil {return 0,0,false ;};_bed ,_fed :=_dfa ._gdb .GetRuneMetrics (r );return _bed .Wx ,_bed .Wy ,_fed &&_bed .Wx !=0;};type LineCap int ;type Gradient interface{Pattern ;AddColorStop (_gg float64 ,_ca _g .Color );};func NewTextFontFromPath (filePath string ,size float64 )(*TextFont ,error ){_eef ,_eaed :=_dc .NewPdfFontFromTTFFile (filePath );if _eaed !=nil {return nil ,_eaed ;};return NewTextFont (_eef ,size );};const (LineCapRound LineCap =iota ;LineCapButt ;LineCapSquare ;);func (_gdd *TextFont )CharcodesToUnicode (charcodes []_e .CharCode )[]rune {if _gdd ._gdb !=nil {return _gdd ._gdb .CharcodesToUnicode (charcodes );};return _gdd .Font .CharcodesToUnicode (charcodes );};func (_aec *TextFont )BytesToCharcodes (data []byte )[]_e .CharCode {if _aec ._gdb !=nil {return _aec ._gdb .BytesToCharcodes (data );};return _aec .Font .BytesToCharcodes (data );};type TextState struct{Tc float64 ;Tw float64 ;Th float64 ;Tl float64 ;Tf *TextFont ;Ts float64 ;Tm _ba .Matrix ;Tlm _ba .Matrix ;};type TextFont struct{Font *_dc .PdfFont ;Face _f .Face ;Size float64 ;_adb *_fg .Font ;_gdb *_dc .PdfFont ;};