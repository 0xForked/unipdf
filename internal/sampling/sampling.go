//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package sampling ;import (_e "github.com/unidoc/unipdf/v3/internal/bitwise";_f "github.com/unidoc/unipdf/v3/internal/imageutil";_b "io";);type Writer struct{_dbc _f .ImageBase ;_ea *_e .Writer ;_cdf ,_fda int ;_beg bool ;};func (_gf *Writer )WriteSample (sample uint32 )error {if _ ,_ead :=_gf ._ea .WriteBits (uint64 (sample ),_gf ._dbc .BitsPerComponent );_ead !=nil {return _ead ;};_gf ._fda --;if _gf ._fda ==0{_gf ._fda =_gf ._dbc .ColorComponents ;_gf ._cdf ++;};if _gf ._cdf ==_gf ._dbc .Width {if _gf ._beg {_gf ._ea .FinishByte ();};_gf ._cdf =0;};return nil ;};func (_fb *Reader )ReadSample ()(uint32 ,error ){if _fb ._cg ==_fb ._g .Height {return 0,_b .EOF ;};_af ,_fa :=_fb ._bg .ReadBits (byte (_fb ._g .BitsPerComponent ));if _fa !=nil {return 0,_fa ;};_fb ._bb --;if _fb ._bb ==0{_fb ._bb =_fb ._g .ColorComponents ;_fb ._be ++;};if _fb ._be ==_fb ._g .Width {if _fb ._gb {_fb ._bg .ConsumeRemainingBits ();};_fb ._be =0;_fb ._cg ++;};return uint32 (_af ),nil ;};type Reader struct{_g _f .ImageBase ;_bg *_e .Reader ;_be ,_cg ,_bb int ;_gb bool ;};func ResampleBytes (data []byte ,bitsPerSample int )[]uint32 {var _ce []uint32 ;_ad :=bitsPerSample ;var _fbf uint32 ;var _bd byte ;_eg :=0;_ge :=0;_cge :=0;for _cge < len (data ){if _eg > 0{_d :=_eg ;if _ad < _d {_d =_ad ;};_fbf =(_fbf <<uint (_d ))|uint32 (_bd >>uint (8-_d ));_eg -=_d ;if _eg > 0{_bd =_bd <<uint (_d );}else {_bd =0;};_ad -=_d ;if _ad ==0{_ce =append (_ce ,_fbf );_ad =bitsPerSample ;_fbf =0;_ge ++;};}else {_ed :=data [_cge ];_cge ++;_ff :=8;if _ad < _ff {_ff =_ad ;};_eg =8-_ff ;_fbf =(_fbf <<uint (_ff ))|uint32 (_ed >>uint (_eg ));if _ff < 8{_bd =_ed <<uint (_ff );};_ad -=_ff ;if _ad ==0{_ce =append (_ce ,_fbf );_ad =bitsPerSample ;_fbf =0;_ge ++;};};};for _eg >=bitsPerSample {_fab :=_eg ;if _ad < _fab {_fab =_ad ;};_fbf =(_fbf <<uint (_fab ))|uint32 (_bd >>uint (8-_fab ));_eg -=_fab ;if _eg > 0{_bd =_bd <<uint (_fab );}else {_bd =0;};_ad -=_fab ;if _ad ==0{_ce =append (_ce ,_fbf );_ad =bitsPerSample ;_fbf =0;_ge ++;};};return _ce ;};func (_fad *Reader )ReadSamples (samples []uint32 )(_ba error ){for _cd :=0;_cd < len (samples );_cd ++{samples [_cd ],_ba =_fad .ReadSample ();if _ba !=nil {return _ba ;};};return nil ;};func NewWriter (img _f .ImageBase )*Writer {return &Writer {_ea :_e .NewWriterMSB (img .Data ),_dbc :img ,_fda :img .ColorComponents ,_beg :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };};func NewReader (img _f .ImageBase )*Reader {return &Reader {_bg :_e .NewReader (img .Data ),_g :img ,_bb :img .ColorComponents ,_gb :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };};func ResampleUint32 (data []uint32 ,bitsPerInputSample int ,bitsPerOutputSample int )[]uint32 {var _de []uint32 ;_da :=bitsPerOutputSample ;var _bbf uint32 ;var _db uint32 ;_bgg :=0;_cgc :=0;_fd :=0;for _fd < len (data ){if _bgg > 0{_eda :=_bgg ;if _da < _eda {_eda =_da ;};_bbf =(_bbf <<uint (_eda ))|uint32 (_db >>uint (bitsPerInputSample -_eda ));_bgg -=_eda ;if _bgg > 0{_db =_db <<uint (_eda );}else {_db =0;};_da -=_eda ;if _da ==0{_de =append (_de ,_bbf );_da =bitsPerOutputSample ;_bbf =0;_cgc ++;};}else {_ffe :=data [_fd ];_fd ++;_ede :=bitsPerInputSample ;if _da < _ede {_ede =_da ;};_bgg =bitsPerInputSample -_ede ;_bbf =(_bbf <<uint (_ede ))|uint32 (_ffe >>uint (_bgg ));if _ede < bitsPerInputSample {_db =_ffe <<uint (_ede );};_da -=_ede ;if _da ==0{_de =append (_de ,_bbf );_da =bitsPerOutputSample ;_bbf =0;_cgc ++;};};};for _bgg >=bitsPerOutputSample {_ef :=_bgg ;if _da < _ef {_ef =_da ;};_bbf =(_bbf <<uint (_ef ))|uint32 (_db >>uint (bitsPerInputSample -_ef ));_bgg -=_ef ;if _bgg > 0{_db =_db <<uint (_ef );}else {_db =0;};_da -=_ef ;if _da ==0{_de =append (_de ,_bbf );_da =bitsPerOutputSample ;_bbf =0;_cgc ++;};};if _da > 0&&_da < bitsPerOutputSample {_bbf <<=uint (_da );_de =append (_de ,_bbf );};return _de ;};type SampleReader interface{ReadSample ()(uint32 ,error );ReadSamples (_c []uint32 )error ;};func (_cdg *Writer )WriteSamples (samples []uint32 )error {for _fg :=0;_fg < len (samples );_fg ++{if _cb :=_cdg .WriteSample (samples [_fg ]);_cb !=nil {return _cb ;};};return nil ;};type SampleWriter interface{WriteSample (_eff uint32 )error ;WriteSamples (_dbg []uint32 )error ;};