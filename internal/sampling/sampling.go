//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package sampling ;import (_d "github.com/unidoc/unipdf/v3/internal/bitwise";_f "github.com/unidoc/unipdf/v3/internal/imageutil";_b "io";);func (_fe *Reader )ReadSample ()(uint32 ,error ){if _fe ._c ==_fe ._bc .Height {return 0,_b .EOF ;};_cb ,_eb :=_fe ._e .ReadBits (byte (_fe ._bc .BitsPerComponent ));
if _eb !=nil {return 0,_eb ;};_fe ._eg --;if _fe ._eg ==0{_fe ._eg =_fe ._bc .ColorComponents ;_fe ._ga ++;};if _fe ._ga ==_fe ._bc .Width {if _fe ._ba {_fe ._e .ConsumeRemainingBits ();};_fe ._ga =0;_fe ._c ++;};return uint32 (_cb ),nil ;};func (_cad *Writer )WriteSample (sample uint32 )error {if _ ,_daa :=_cad ._cfd .WriteBits (uint64 (sample ),_cad ._fga .BitsPerComponent );
_daa !=nil {return _daa ;};_cad ._cg --;if _cad ._cg ==0{_cad ._cg =_cad ._fga .ColorComponents ;_cad ._cae ++;};if _cad ._cae ==_cad ._fga .Width {if _cad ._cgb {_cad ._cfd .FinishByte ();};_cad ._cae =0;};return nil ;};func (_a *Reader )ReadSamples (samples []uint32 )(_da error ){for _gag :=0;
_gag < len (samples );_gag ++{samples [_gag ],_da =_a .ReadSample ();if _da !=nil {return _da ;};};return nil ;};func ResampleUint32 (data []uint32 ,bitsPerInputSample int ,bitsPerOutputSample int )[]uint32 {var _ca []uint32 ;_ed :=bitsPerOutputSample ;
var _af uint32 ;var _gd uint32 ;_fg :=0;_dc :=0;_dcc :=0;for _dcc < len (data ){if _fg > 0{_cd :=_fg ;if _ed < _cd {_cd =_ed ;};_af =(_af <<uint (_cd ))|(_gd >>uint (bitsPerInputSample -_cd ));_fg -=_cd ;if _fg > 0{_gd =_gd <<uint (_cd );}else {_gd =0;
};_ed -=_cd ;if _ed ==0{_ca =append (_ca ,_af );_ed =bitsPerOutputSample ;_af =0;_dc ++;};}else {_bd :=data [_dcc ];_dcc ++;_gc :=bitsPerInputSample ;if _ed < _gc {_gc =_ed ;};_fg =bitsPerInputSample -_gc ;_af =(_af <<uint (_gc ))|(_bd >>uint (_fg ));if _gc < bitsPerInputSample {_gd =_bd <<uint (_gc );
};_ed -=_gc ;if _ed ==0{_ca =append (_ca ,_af );_ed =bitsPerOutputSample ;_af =0;_dc ++;};};};for _fg >=bitsPerOutputSample {_ce :=_fg ;if _ed < _ce {_ce =_ed ;};_af =(_af <<uint (_ce ))|(_gd >>uint (bitsPerInputSample -_ce ));_fg -=_ce ;if _fg > 0{_gd =_gd <<uint (_ce );
}else {_gd =0;};_ed -=_ce ;if _ed ==0{_ca =append (_ca ,_af );_ed =bitsPerOutputSample ;_af =0;_dc ++;};};if _ed > 0&&_ed < bitsPerOutputSample {_af <<=uint (_ed );_ca =append (_ca ,_af );};return _ca ;};type Writer struct{_fga _f .ImageBase ;_cfd *_d .Writer ;
_cae ,_cg int ;_cgb bool ;};func NewReader (img _f .ImageBase )*Reader {return &Reader {_e :_d .NewReader (img .Data ),_bc :img ,_eg :img .ColorComponents ,_ba :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };};type SampleWriter interface{WriteSample (_dg uint32 )error ;
WriteSamples (_cf []uint32 )error ;};type SampleReader interface{ReadSample ()(uint32 ,error );ReadSamples (_bf []uint32 )error ;};func NewWriter (img _f .ImageBase )*Writer {return &Writer {_cfd :_d .NewWriterMSB (img .Data ),_fga :img ,_cg :img .ColorComponents ,_cgb :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};type Reader struct{_bc _f .ImageBase ;_e *_d .Reader ;_ga ,_c ,_eg int ;_ba bool ;};func (_bbf *Writer )WriteSamples (samples []uint32 )error {for _fge :=0;_fge < len (samples );_fge ++{if _gaf :=_bbf .WriteSample (samples [_fge ]);_gaf !=nil {return _gaf ;
};};return nil ;};func ResampleBytes (data []byte ,bitsPerSample int )[]uint32 {var _bfe []uint32 ;_ef :=bitsPerSample ;var _ge uint32 ;var _bb byte ;_db :=0;_gb :=0;_fd :=0;for _fd < len (data ){if _db > 0{_fc :=_db ;if _ef < _fc {_fc =_ef ;};_ge =(_ge <<uint (_fc ))|uint32 (_bb >>uint (8-_fc ));
_db -=_fc ;if _db > 0{_bb =_bb <<uint (_fc );}else {_bb =0;};_ef -=_fc ;if _ef ==0{_bfe =append (_bfe ,_ge );_ef =bitsPerSample ;_ge =0;_gb ++;};}else {_gf :=data [_fd ];_fd ++;_gbb :=8;if _ef < _gbb {_gbb =_ef ;};_db =8-_gbb ;_ge =(_ge <<uint (_gbb ))|uint32 (_gf >>uint (_db ));
if _gbb < 8{_bb =_gf <<uint (_gbb );};_ef -=_gbb ;if _ef ==0{_bfe =append (_bfe ,_ge );_ef =bitsPerSample ;_ge =0;_gb ++;};};};for _db >=bitsPerSample {_gg :=_db ;if _ef < _gg {_gg =_ef ;};_ge =(_ge <<uint (_gg ))|uint32 (_bb >>uint (8-_gg ));_db -=_gg ;
if _db > 0{_bb =_bb <<uint (_gg );}else {_bb =0;};_ef -=_gg ;if _ef ==0{_bfe =append (_bfe ,_ge );_ef =bitsPerSample ;_ge =0;_gb ++;};};return _bfe ;};