//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package sampling ;import (_cc "github.com/unidoc/unipdf/v3/internal/bitwise";_a "github.com/unidoc/unipdf/v3/internal/imageutil";_g "io";);func NewWriter (img _a .ImageBase )*Writer {return &Writer {_cba :_cc .NewWriterMSB (img .Data ),_ea :img ,_bgf :img .ColorComponents ,_af :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};type SampleReader interface{ReadSample ()(uint32 ,error );ReadSamples (_gc []uint32 )error ;};type Writer struct{_ea _a .ImageBase ;_cba *_cc .Writer ;_bc ,_bgf int ;_af bool ;};func (_aba *Writer )WriteSample (sample uint32 )error {if _ ,_geg :=_aba ._cba .WriteBits (uint64 (sample ),_aba ._ea .BitsPerComponent );
_geg !=nil {return _geg ;};_aba ._bgf --;if _aba ._bgf ==0{_aba ._bgf =_aba ._ea .ColorComponents ;_aba ._bc ++;};if _aba ._bc ==_aba ._ea .Width {if _aba ._af {_aba ._cba .FinishByte ();};_aba ._bc =0;};return nil ;};func (_ba *Reader )ReadSample ()(uint32 ,error ){if _ba ._cf ==_ba ._f .Height {return 0,_g .EOF ;
};_ga ,_ge :=_ba ._b .ReadBits (byte (_ba ._f .BitsPerComponent ));if _ge !=nil {return 0,_ge ;};_ba ._cb --;if _ba ._cb ==0{_ba ._cb =_ba ._f .ColorComponents ;_ba ._bb ++;};if _ba ._bb ==_ba ._f .Width {if _ba ._e {_ba ._b .ConsumeRemainingBits ();};
_ba ._bb =0;_ba ._cf ++;};return uint32 (_ga ),nil ;};func NewReader (img _a .ImageBase )*Reader {return &Reader {_b :_cc .NewReader (img .Data ),_f :img ,_cb :img .ColorComponents ,_e :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};type Reader struct{_f _a .ImageBase ;_b *_cc .Reader ;_bb ,_cf ,_cb int ;_e bool ;};type SampleWriter interface{WriteSample (_fe uint32 )error ;WriteSamples (_gaa []uint32 )error ;};func (_de *Writer )WriteSamples (samples []uint32 )error {for _dc :=0;
_dc < len (samples );_dc ++{if _aag :=_de .WriteSample (samples [_dc ]);_aag !=nil {return _aag ;};};return nil ;};func ResampleUint32 (data []uint32 ,bitsPerInputSample int ,bitsPerOutputSample int )[]uint32 {var _gag []uint32 ;_ed :=bitsPerOutputSample ;
var _gb uint32 ;var _bef uint32 ;_gbc :=0;_aa :=0;_df :=0;for _df < len (data ){if _gbc > 0{_bfd :=_gbc ;if _ed < _bfd {_bfd =_ed ;};_gb =(_gb <<uint (_bfd ))|(_bef >>uint (bitsPerInputSample -_bfd ));_gbc -=_bfd ;if _gbc > 0{_bef =_bef <<uint (_bfd );
}else {_bef =0;};_ed -=_bfd ;if _ed ==0{_gag =append (_gag ,_gb );_ed =bitsPerOutputSample ;_gb =0;_aa ++;};}else {_ac :=data [_df ];_df ++;_adf :=bitsPerInputSample ;if _ed < _adf {_adf =_ed ;};_gbc =bitsPerInputSample -_adf ;_gb =(_gb <<uint (_adf ))|(_ac >>uint (_gbc ));
if _adf < bitsPerInputSample {_bef =_ac <<uint (_adf );};_ed -=_adf ;if _ed ==0{_gag =append (_gag ,_gb );_ed =bitsPerOutputSample ;_gb =0;_aa ++;};};};for _gbc >=bitsPerOutputSample {_gbd :=_gbc ;if _ed < _gbd {_gbd =_ed ;};_gb =(_gb <<uint (_gbd ))|(_bef >>uint (bitsPerInputSample -_gbd ));
_gbc -=_gbd ;if _gbc > 0{_bef =_bef <<uint (_gbd );}else {_bef =0;};_ed -=_gbd ;if _ed ==0{_gag =append (_gag ,_gb );_ed =bitsPerOutputSample ;_gb =0;_aa ++;};};if _ed > 0&&_ed < bitsPerOutputSample {_gb <<=uint (_ed );_gag =append (_gag ,_gb );};return _gag ;
};func ResampleBytes (data []byte ,bitsPerSample int )[]uint32 {var _eb []uint32 ;_agf :=bitsPerSample ;var _bd uint32 ;var _bf byte ;_bg :=0;_ebg :=0;_ee :=0;for _ee < len (data ){if _bg > 0{_d :=_bg ;if _agf < _d {_d =_agf ;};_bd =(_bd <<uint (_d ))|uint32 (_bf >>uint (8-_d ));
_bg -=_d ;if _bg > 0{_bf =_bf <<uint (_d );}else {_bf =0;};_agf -=_d ;if _agf ==0{_eb =append (_eb ,_bd );_agf =bitsPerSample ;_bd =0;_ebg ++;};}else {_dg :=data [_ee ];_ee ++;_ad :=8;if _agf < _ad {_ad =_agf ;};_bg =8-_ad ;_bd =(_bd <<uint (_ad ))|uint32 (_dg >>uint (_bg ));
if _ad < 8{_bf =_dg <<uint (_ad );};_agf -=_ad ;if _agf ==0{_eb =append (_eb ,_bd );_agf =bitsPerSample ;_bd =0;_ebg ++;};};};for _bg >=bitsPerSample {_ae :=_bg ;if _agf < _ae {_ae =_agf ;};_bd =(_bd <<uint (_ae ))|uint32 (_bf >>uint (8-_ae ));_bg -=_ae ;
if _bg > 0{_bf =_bf <<uint (_ae );}else {_bf =0;};_agf -=_ae ;if _agf ==0{_eb =append (_eb ,_bd );_agf =bitsPerSample ;_bd =0;_ebg ++;};};return _eb ;};func (_be *Reader )ReadSamples (samples []uint32 )(_ab error ){for _ag :=0;_ag < len (samples );_ag ++{samples [_ag ],_ab =_be .ReadSample ();
if _ab !=nil {return _ab ;};};return nil ;};