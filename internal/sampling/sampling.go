//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package sampling ;import (_g "github.com/unidoc/unipdf/v3/internal/bitwise";_df "github.com/unidoc/unipdf/v3/internal/imageutil";_e "io";);func ResampleBytes (data []byte ,bitsPerSample int )[]uint32 {var _cg []uint32 ;_fc :=bitsPerSample ;var _dc uint32 ;
var _aa byte ;_gf :=0;_ccb :=0;_ag :=0;for _ag < len (data ){if _gf > 0{_age :=_gf ;if _fc < _age {_age =_fc ;};_dc =(_dc <<uint (_age ))|uint32 (_aa >>uint (8-_age ));_gf -=_age ;if _gf > 0{_aa =_aa <<uint (_age );}else {_aa =0;};_fc -=_age ;if _fc ==0{_cg =append (_cg ,_dc );
_fc =bitsPerSample ;_dc =0;_ccb ++;};}else {_af :=data [_ag ];_ag ++;_ec :=8;if _fc < _ec {_ec =_fc ;};_gf =8-_ec ;_dc =(_dc <<uint (_ec ))|uint32 (_af >>uint (_gf ));if _ec < 8{_aa =_af <<uint (_ec );};_fc -=_ec ;if _fc ==0{_cg =append (_cg ,_dc );_fc =bitsPerSample ;
_dc =0;_ccb ++;};};};for _gf >=bitsPerSample {_dce :=_gf ;if _fc < _dce {_dce =_fc ;};_dc =(_dc <<uint (_dce ))|uint32 (_aa >>uint (8-_dce ));_gf -=_dce ;if _gf > 0{_aa =_aa <<uint (_dce );}else {_aa =0;};_fc -=_dce ;if _fc ==0{_cg =append (_cg ,_dc );
_fc =bitsPerSample ;_dc =0;_ccb ++;};};return _cg ;};func (_cc *Reader )ReadSample ()(uint32 ,error ){if _cc ._ad ==_cc ._ed .Height {return 0,_e .EOF ;};_eb ,_f :=_cc ._c .ReadBits (byte (_cc ._ed .BitsPerComponent ));if _f !=nil {return 0,_f ;};_cc ._bb --;
if _cc ._bb ==0{_cc ._bb =_cc ._ed .ColorComponents ;_cc ._b ++;};if _cc ._b ==_cc ._ed .Width {if _cc ._ce {_cc ._c .ConsumeRemainingBits ();};_cc ._b =0;_cc ._ad ++;};return uint32 (_eb ),nil ;};func (_bc *Reader )ReadSamples (samples []uint32 )(_bcf error ){for _bcfc :=0;
_bcfc < len (samples );_bcfc ++{samples [_bcfc ],_bcf =_bc .ReadSample ();if _bcf !=nil {return _bcf ;};};return nil ;};func NewReader (img _df .ImageBase )*Reader {return &Reader {_c :_g .NewReader (img .Data ),_ed :img ,_bb :img .ColorComponents ,_ce :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};type SampleReader interface{ReadSample ()(uint32 ,error );ReadSamples (_a []uint32 )error ;};type Writer struct{_dcg _df .ImageBase ;_ebd *_g .Writer ;_gd ,_fg int ;_fa bool ;};type SampleWriter interface{WriteSample (_cgf uint32 )error ;WriteSamples (_fd []uint32 )error ;
};func (_fb *Writer )WriteSamples (samples []uint32 )error {for _cead :=0;_cead < len (samples );_cead ++{if _edg :=_fb .WriteSample (samples [_cead ]);_edg !=nil {return _edg ;};};return nil ;};func (_ae *Writer )WriteSample (sample uint32 )error {if _ ,_cb :=_ae ._ebd .WriteBits (uint64 (sample ),_ae ._dcg .BitsPerComponent );
_cb !=nil {return _cb ;};_ae ._fg --;if _ae ._fg ==0{_ae ._fg =_ae ._dcg .ColorComponents ;_ae ._gd ++;};if _ae ._gd ==_ae ._dcg .Width {if _ae ._fa {_ae ._ebd .FinishByte ();};_ae ._gd =0;};return nil ;};type Reader struct{_ed _df .ImageBase ;_c *_g .Reader ;
_b ,_ad ,_bb int ;_ce bool ;};func NewWriter (img _df .ImageBase )*Writer {return &Writer {_ebd :_g .NewWriterMSB (img .Data ),_dcg :img ,_fg :img .ColorComponents ,_fa :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };};
func ResampleUint32 (data []uint32 ,bitsPerInputSample int ,bitsPerOutputSample int )[]uint32 {var _ge []uint32 ;_ef :=bitsPerOutputSample ;var _cea uint32 ;var _bg uint32 ;_eba :=0;_de :=0;_ca :=0;for _ca < len (data ){if _eba > 0{_cd :=_eba ;if _ef < _cd {_cd =_ef ;
};_cea =(_cea <<uint (_cd ))|(_bg >>uint (bitsPerInputSample -_cd ));_eba -=_cd ;if _eba > 0{_bg =_bg <<uint (_cd );}else {_bg =0;};_ef -=_cd ;if _ef ==0{_ge =append (_ge ,_cea );_ef =bitsPerOutputSample ;_cea =0;_de ++;};}else {_eda :=data [_ca ];_ca ++;
_ga :=bitsPerInputSample ;if _ef < _ga {_ga =_ef ;};_eba =bitsPerInputSample -_ga ;_cea =(_cea <<uint (_ga ))|(_eda >>uint (_eba ));if _ga < bitsPerInputSample {_bg =_eda <<uint (_ga );};_ef -=_ga ;if _ef ==0{_ge =append (_ge ,_cea );_ef =bitsPerOutputSample ;
_cea =0;_de ++;};};};for _eba >=bitsPerOutputSample {_efd :=_eba ;if _ef < _efd {_efd =_ef ;};_cea =(_cea <<uint (_efd ))|(_bg >>uint (bitsPerInputSample -_efd ));_eba -=_efd ;if _eba > 0{_bg =_bg <<uint (_efd );}else {_bg =0;};_ef -=_efd ;if _ef ==0{_ge =append (_ge ,_cea );
_ef =bitsPerOutputSample ;_cea =0;_de ++;};};if _ef > 0&&_ef < bitsPerOutputSample {_cea <<=uint (_ef );_ge =append (_ge ,_cea );};return _ge ;};