//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package sampling ;import (_e "github.com/unidoc/unipdf/v3/internal/bitwise";_d "github.com/unidoc/unipdf/v3/internal/imageutil";_aa "io";);func NewReader (img _d .ImageBase )*Reader {return &Reader {_aab :_e .NewReader (img .Data ),_dd :img ,_ad :img .ColorComponents ,_ac :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};func (_b *Reader )ReadSample ()(uint32 ,error ){if _b ._c ==_b ._dd .Height {return 0,_aa .EOF ;};_dfa ,_bb :=_b ._aab .ReadBits (byte (_b ._dd .BitsPerComponent ));if _bb !=nil {return 0,_bb ;};_b ._ad --;if _b ._ad ==0{_b ._ad =_b ._dd .ColorComponents ;
_b ._ed ++;};if _b ._ed ==_b ._dd .Width {if _b ._ac {_b ._aab .ConsumeRemainingBits ();};_b ._ed =0;_b ._c ++;};return uint32 (_dfa ),nil ;};type SampleReader interface{ReadSample ()(uint32 ,error );ReadSamples (_df []uint32 )error ;};type Reader struct{_dd _d .ImageBase ;
_aab *_e .Reader ;_ed ,_c ,_ad int ;_ac bool ;};func (_cg *Writer )WriteSample (sample uint32 )error {if _ ,_acb :=_cg ._fa .WriteBits (uint64 (sample ),_cg ._ae .BitsPerComponent );_acb !=nil {return _acb ;};_cg ._dcee --;if _cg ._dcee ==0{_cg ._dcee =_cg ._ae .ColorComponents ;
_cg ._eb ++;};if _cg ._eb ==_cg ._ae .Width {if _cg ._bbee {_cg ._fa .FinishByte ();};_cg ._eb =0;};return nil ;};func NewWriter (img _d .ImageBase )*Writer {return &Writer {_fa :_e .NewWriterMSB (img .Data ),_ae :img ,_dcee :img .ColorComponents ,_bbee :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};func ResampleUint32 (data []uint32 ,bitsPerInputSample int ,bitsPerOutputSample int )[]uint32 {var _bd []uint32 ;_dce :=bitsPerOutputSample ;var _gc uint32 ;var _ba uint32 ;_ea :=0;_bg :=0;_dag :=0;for _dag < len (data ){if _ea > 0{_ccg :=_ea ;if _dce < _ccg {_ccg =_dce ;
};_gc =(_gc <<uint (_ccg ))|(_ba >>uint (bitsPerInputSample -_ccg ));_ea -=_ccg ;if _ea > 0{_ba =_ba <<uint (_ccg );}else {_ba =0;};_dce -=_ccg ;if _dce ==0{_bd =append (_bd ,_gc );_dce =bitsPerOutputSample ;_gc =0;_bg ++;};}else {_bdc :=data [_dag ];_dag ++;
_aba :=bitsPerInputSample ;if _dce < _aba {_aba =_dce ;};_ea =bitsPerInputSample -_aba ;_gc =(_gc <<uint (_aba ))|(_bdc >>uint (_ea ));if _aba < bitsPerInputSample {_ba =_bdc <<uint (_aba );};_dce -=_aba ;if _dce ==0{_bd =append (_bd ,_gc );_dce =bitsPerOutputSample ;
_gc =0;_bg ++;};};};for _ea >=bitsPerOutputSample {_ddd :=_ea ;if _dce < _ddd {_ddd =_dce ;};_gc =(_gc <<uint (_ddd ))|(_ba >>uint (bitsPerInputSample -_ddd ));_ea -=_ddd ;if _ea > 0{_ba =_ba <<uint (_ddd );}else {_ba =0;};_dce -=_ddd ;if _dce ==0{_bd =append (_bd ,_gc );
_dce =bitsPerOutputSample ;_gc =0;_bg ++;};};if _dce > 0&&_dce < bitsPerOutputSample {_gc <<=uint (_dce );_bd =append (_bd ,_gc );};return _bd ;};func (_fc *Writer )WriteSamples (samples []uint32 )error {for _dcb :=0;_dcb < len (samples );_dcb ++{if _cga :=_fc .WriteSample (samples [_dcb ]);
_cga !=nil {return _cga ;};};return nil ;};func (_db *Reader )ReadSamples (samples []uint32 )(_cc error ){for _bbe :=0;_bbe < len (samples );_bbe ++{samples [_bbe ],_cc =_db .ReadSample ();if _cc !=nil {return _cc ;};};return nil ;};type SampleWriter interface{WriteSample (_bf uint32 )error ;
WriteSamples (_dad []uint32 )error ;};type Writer struct{_ae _d .ImageBase ;_fa *_e .Writer ;_eb ,_dcee int ;_bbee bool ;};func ResampleBytes (data []byte ,bitsPerSample int )[]uint32 {var _da []uint32 ;_g :=bitsPerSample ;var _gg uint32 ;var _dbd byte ;
_ec :=0;_ca :=0;_ce :=0;for _ce < len (data ){if _ec > 0{_ab :=_ec ;if _g < _ab {_ab =_g ;};_gg =(_gg <<uint (_ab ))|uint32 (_dbd >>uint (8-_ab ));_ec -=_ab ;if _ec > 0{_dbd =_dbd <<uint (_ab );}else {_dbd =0;};_g -=_ab ;if _g ==0{_da =append (_da ,_gg );
_g =bitsPerSample ;_gg =0;_ca ++;};}else {_gb :=data [_ce ];_ce ++;_dc :=8;if _g < _dc {_dc =_g ;};_ec =8-_dc ;_gg =(_gg <<uint (_dc ))|uint32 (_gb >>uint (_ec ));if _dc < 8{_dbd =_gb <<uint (_dc );};_g -=_dc ;if _g ==0{_da =append (_da ,_gg );_g =bitsPerSample ;
_gg =0;_ca ++;};};};for _ec >=bitsPerSample {_f :=_ec ;if _g < _f {_f =_g ;};_gg =(_gg <<uint (_f ))|uint32 (_dbd >>uint (8-_f ));_ec -=_f ;if _ec > 0{_dbd =_dbd <<uint (_f );}else {_dbd =0;};_g -=_f ;if _g ==0{_da =append (_da ,_gg );_g =bitsPerSample ;
_gg =0;_ca ++;};};return _da ;};