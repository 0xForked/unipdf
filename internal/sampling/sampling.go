//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package sampling ;import (_e "github.com/unidoc/unipdf/v3/internal/bitwise";_eb "github.com/unidoc/unipdf/v3/internal/imageutil";_b "io";);type SampleReader interface{ReadSample ()(uint32 ,error );ReadSamples (_c []uint32 )error ;};func (_cd *Reader )ReadSamples (samples []uint32 )(_gb error ){for _af :=0;
_af < len (samples );_af ++{samples [_af ],_gb =_cd .ReadSample ();if _gb !=nil {return _gb ;};};return nil ;};func NewReader (img _eb .ImageBase )*Reader {return &Reader {_a :_e .NewReader (img .Data ),_f :img ,_fe :img .ColorComponents ,_cc :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};func NewWriter (img _eb .ImageBase )*Writer {return &Writer {_ff :_e .NewWriterMSB (img .Data ),_eg :img ,_gg :img .ColorComponents ,_cac :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };};type Reader struct{_f _eb .ImageBase ;
_a *_e .Reader ;_bb ,_dg ,_fe int ;_cc bool ;};type Writer struct{_eg _eb .ImageBase ;_ff *_e .Writer ;_da ,_gg int ;_cac bool ;};func ResampleUint32 (data []uint32 ,bitsPerInputSample int ,bitsPerOutputSample int )[]uint32 {var _ef []uint32 ;_ce :=bitsPerOutputSample ;
var _fc uint32 ;var _cgb uint32 ;_ec :=0;_bfe :=0;_ea :=0;for _ea < len (data ){if _ec > 0{_fb :=_ec ;if _ce < _fb {_fb =_ce ;};_fc =(_fc <<uint (_fb ))|(_cgb >>uint (bitsPerInputSample -_fb ));_ec -=_fb ;if _ec > 0{_cgb =_cgb <<uint (_fb );}else {_cgb =0;
};_ce -=_fb ;if _ce ==0{_ef =append (_ef ,_fc );_ce =bitsPerOutputSample ;_fc =0;_bfe ++;};}else {_gd :=data [_ea ];_ea ++;_abf :=bitsPerInputSample ;if _ce < _abf {_abf =_ce ;};_ec =bitsPerInputSample -_abf ;_fc =(_fc <<uint (_abf ))|(_gd >>uint (_ec ));
if _abf < bitsPerInputSample {_cgb =_gd <<uint (_abf );};_ce -=_abf ;if _ce ==0{_ef =append (_ef ,_fc );_ce =bitsPerOutputSample ;_fc =0;_bfe ++;};};};for _ec >=bitsPerOutputSample {_bc :=_ec ;if _ce < _bc {_bc =_ce ;};_fc =(_fc <<uint (_bc ))|(_cgb >>uint (bitsPerInputSample -_bc ));
_ec -=_bc ;if _ec > 0{_cgb =_cgb <<uint (_bc );}else {_cgb =0;};_ce -=_bc ;if _ce ==0{_ef =append (_ef ,_fc );_ce =bitsPerOutputSample ;_fc =0;_bfe ++;};};if _ce > 0&&_ce < bitsPerOutputSample {_fc <<=uint (_ce );_ef =append (_ef ,_fc );};return _ef ;};
func (_fa *Writer )WriteSamples (samples []uint32 )error {for _aff :=0;_aff < len (samples );_aff ++{if _ebd :=_fa .WriteSample (samples [_aff ]);_ebd !=nil {return _ebd ;};};return nil ;};func (_bg *Writer )WriteSample (sample uint32 )error {if _ ,_eff :=_bg ._ff .WriteBits (uint64 (sample ),_bg ._eg .BitsPerComponent );
_eff !=nil {return _eff ;};_bg ._gg --;if _bg ._gg ==0{_bg ._gg =_bg ._eg .ColorComponents ;_bg ._da ++;};if _bg ._da ==_bg ._eg .Width {if _bg ._cac {_bg ._ff .FinishByte ();};_bg ._da =0;};return nil ;};func (_ca *Reader )ReadSample ()(uint32 ,error ){if _ca ._dg ==_ca ._f .Height {return 0,_b .EOF ;
};_g ,_ge :=_ca ._a .ReadBits (byte (_ca ._f .BitsPerComponent ));if _ge !=nil {return 0,_ge ;};_ca ._fe --;if _ca ._fe ==0{_ca ._fe =_ca ._f .ColorComponents ;_ca ._bb ++;};if _ca ._bb ==_ca ._f .Width {if _ca ._cc {_ca ._a .ConsumeRemainingBits ();};
_ca ._bb =0;_ca ._dg ++;};return uint32 (_g ),nil ;};func ResampleBytes (data []byte ,bitsPerSample int )[]uint32 {var _aa []uint32 ;_ba :=bitsPerSample ;var _cg uint32 ;var _bf byte ;_de :=0;_bad :=0;_df :=0;for _df < len (data ){if _de > 0{_gc :=_de ;
if _ba < _gc {_gc =_ba ;};_cg =(_cg <<uint (_gc ))|uint32 (_bf >>uint (8-_gc ));_de -=_gc ;if _de > 0{_bf =_bf <<uint (_gc );}else {_bf =0;};_ba -=_gc ;if _ba ==0{_aa =append (_aa ,_cg );_ba =bitsPerSample ;_cg =0;_bad ++;};}else {_ag :=data [_df ];_df ++;
_dd :=8;if _ba < _dd {_dd =_ba ;};_de =8-_dd ;_cg =(_cg <<uint (_dd ))|uint32 (_ag >>uint (_de ));if _dd < 8{_bf =_ag <<uint (_dd );};_ba -=_dd ;if _ba ==0{_aa =append (_aa ,_cg );_ba =bitsPerSample ;_cg =0;_bad ++;};};};for _de >=bitsPerSample {_ab :=_de ;
if _ba < _ab {_ab =_ba ;};_cg =(_cg <<uint (_ab ))|uint32 (_bf >>uint (8-_ab ));_de -=_ab ;if _de > 0{_bf =_bf <<uint (_ab );}else {_bf =0;};_ba -=_ab ;if _ba ==0{_aa =append (_aa ,_cg );_ba =bitsPerSample ;_cg =0;_bad ++;};};return _aa ;};type SampleWriter interface{WriteSample (_db uint32 )error ;
WriteSamples (_cb []uint32 )error ;};