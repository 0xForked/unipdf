//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package sampling ;import (_f "github.com/unidoc/unipdf/v3/internal/bitwise";_fa "github.com/unidoc/unipdf/v3/internal/imageutil";_c "io";);type Reader struct{_ge _fa .ImageBase ;_fg *_f .Reader ;_e ,_gb ,_d int ;_cf bool ;};func NewWriter (img _fa .ImageBase )*Writer {return &Writer {_bga :_f .NewWriterMSB (img .Data ),_bf :img ,_eda :img .ColorComponents ,_efe :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};func (_ee *Reader )ReadSamples (samples []uint32 )(_ca error ){for _gf :=0;_gf < len (samples );_gf ++{samples [_gf ],_ca =_ee .ReadSample ();if _ca !=nil {return _ca ;};};return nil ;};type SampleWriter interface{WriteSample (_dd uint32 )error ;WriteSamples (_ece []uint32 )error ;
};func (_fgd *Reader )ReadSample ()(uint32 ,error ){if _fgd ._gb ==_fgd ._ge .Height {return 0,_c .EOF ;};_ad ,_da :=_fgd ._fg .ReadBits (byte (_fgd ._ge .BitsPerComponent ));if _da !=nil {return 0,_da ;};_fgd ._d --;if _fgd ._d ==0{_fgd ._d =_fgd ._ge .ColorComponents ;
_fgd ._e ++;};if _fgd ._e ==_fgd ._ge .Width {if _fgd ._cf {_fgd ._fg .ConsumeRemainingBits ();};_fgd ._e =0;_fgd ._gb ++;};return uint32 (_ad ),nil ;};func ResampleBytes (data []byte ,bitsPerSample int )[]uint32 {var _dad []uint32 ;_b :=bitsPerSample ;
var _adg uint32 ;var _fd byte ;_bd :=0;_ba :=0;_ef :=0;for _ef < len (data ){if _bd > 0{_dg :=_bd ;if _b < _dg {_dg =_b ;};_adg =(_adg <<uint (_dg ))|uint32 (_fd >>uint (8-_dg ));_bd -=_dg ;if _bd > 0{_fd =_fd <<uint (_dg );}else {_fd =0;};_b -=_dg ;if _b ==0{_dad =append (_dad ,_adg );
_b =bitsPerSample ;_adg =0;_ba ++;};}else {_be :=data [_ef ];_ef ++;_ed :=8;if _b < _ed {_ed =_b ;};_bd =8-_ed ;_adg =(_adg <<uint (_ed ))|uint32 (_be >>uint (_bd ));if _ed < 8{_fd =_be <<uint (_ed );};_b -=_ed ;if _b ==0{_dad =append (_dad ,_adg );_b =bitsPerSample ;
_adg =0;_ba ++;};};};for _bd >=bitsPerSample {_bg :=_bd ;if _b < _bg {_bg =_b ;};_adg =(_adg <<uint (_bg ))|uint32 (_fd >>uint (8-_bg ));_bd -=_bg ;if _bd > 0{_fd =_fd <<uint (_bg );}else {_fd =0;};_b -=_bg ;if _b ==0{_dad =append (_dad ,_adg );_b =bitsPerSample ;
_adg =0;_ba ++;};};return _dad ;};type SampleReader interface{ReadSample ()(uint32 ,error );ReadSamples (_g []uint32 )error ;};func (_gc *Writer )WriteSample (sample uint32 )error {if _ ,_acg :=_gc ._bga .WriteBits (uint64 (sample ),_gc ._bf .BitsPerComponent );
_acg !=nil {return _acg ;};_gc ._eda --;if _gc ._eda ==0{_gc ._eda =_gc ._bf .ColorComponents ;_gc ._aa ++;};if _gc ._aa ==_gc ._bf .Width {if _gc ._efe {_gc ._bga .FinishByte ();};_gc ._aa =0;};return nil ;};func (_eedd *Writer )WriteSamples (samples []uint32 )error {for _df :=0;
_df < len (samples );_df ++{if _edf :=_eedd .WriteSample (samples [_df ]);_edf !=nil {return _edf ;};};return nil ;};type Writer struct{_bf _fa .ImageBase ;_bga *_f .Writer ;_aa ,_eda int ;_efe bool ;};func ResampleUint32 (data []uint32 ,bitsPerInputSample int ,bitsPerOutputSample int )[]uint32 {var _bb []uint32 ;
_cg :=bitsPerOutputSample ;var _ec uint32 ;var _baa uint32 ;_fb :=0;_eed :=0;_ac :=0;for _ac < len (data ){if _fb > 0{_cgg :=_fb ;if _cg < _cgg {_cgg =_cg ;};_ec =(_ec <<uint (_cgg ))|(_baa >>uint (bitsPerInputSample -_cgg ));_fb -=_cgg ;if _fb > 0{_baa =_baa <<uint (_cgg );
}else {_baa =0;};_cg -=_cgg ;if _cg ==0{_bb =append (_bb ,_ec );_cg =bitsPerOutputSample ;_ec =0;_eed ++;};}else {_ae :=data [_ac ];_ac ++;_ga :=bitsPerInputSample ;if _cg < _ga {_ga =_cg ;};_fb =bitsPerInputSample -_ga ;_ec =(_ec <<uint (_ga ))|(_ae >>uint (_fb ));
if _ga < bitsPerInputSample {_baa =_ae <<uint (_ga );};_cg -=_ga ;if _cg ==0{_bb =append (_bb ,_ec );_cg =bitsPerOutputSample ;_ec =0;_eed ++;};};};for _fb >=bitsPerOutputSample {_eeb :=_fb ;if _cg < _eeb {_eeb =_cg ;};_ec =(_ec <<uint (_eeb ))|(_baa >>uint (bitsPerInputSample -_eeb ));
_fb -=_eeb ;if _fb > 0{_baa =_baa <<uint (_eeb );}else {_baa =0;};_cg -=_eeb ;if _cg ==0{_bb =append (_bb ,_ec );_cg =bitsPerOutputSample ;_ec =0;_eed ++;};};if _cg > 0&&_cg < bitsPerOutputSample {_ec <<=uint (_cg );_bb =append (_bb ,_ec );};return _bb ;
};func NewReader (img _fa .ImageBase )*Reader {return &Reader {_fg :_f .NewReader (img .Data ),_ge :img ,_d :img .ColorComponents ,_cf :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };};