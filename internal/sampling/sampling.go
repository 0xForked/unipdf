//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package sampling ;import (_f "github.com/unidoc/unipdf/v3/internal/bitwise";_df "github.com/unidoc/unipdf/v3/internal/imageutil";_g "io";);type SampleWriter interface{WriteSample (_aa uint32 )error ;WriteSamples (_dd []uint32 )error ;};func ResampleBytes (data []byte ,bitsPerSample int )[]uint32 {var _af []uint32 ;
_fb :=bitsPerSample ;var _gd uint32 ;var _ea byte ;_de :=0;_cd :=0;_fbb :=0;for _fbb < len (data ){if _de > 0{_bb :=_de ;if _fb < _bb {_bb =_fb ;};_gd =(_gd <<uint (_bb ))|uint32 (_ea >>uint (8-_bb ));_de -=_bb ;if _de > 0{_ea =_ea <<uint (_bb );}else {_ea =0;
};_fb -=_bb ;if _fb ==0{_af =append (_af ,_gd );_fb =bitsPerSample ;_gd =0;_cd ++;};}else {_ad :=data [_fbb ];_fbb ++;_dc :=8;if _fb < _dc {_dc =_fb ;};_de =8-_dc ;_gd =(_gd <<uint (_dc ))|uint32 (_ad >>uint (_de ));if _dc < 8{_ea =_ad <<uint (_dc );};
_fb -=_dc ;if _fb ==0{_af =append (_af ,_gd );_fb =bitsPerSample ;_gd =0;_cd ++;};};};for _de >=bitsPerSample {_gaf :=_de ;if _fb < _gaf {_gaf =_fb ;};_gd =(_gd <<uint (_gaf ))|uint32 (_ea >>uint (8-_gaf ));_de -=_gaf ;if _de > 0{_ea =_ea <<uint (_gaf );
}else {_ea =0;};_fb -=_gaf ;if _fb ==0{_af =append (_af ,_gd );_fb =bitsPerSample ;_gd =0;_cd ++;};};return _af ;};func (_bd *Reader )ReadSample ()(uint32 ,error ){if _bd ._ce ==_bd ._c .Height {return 0,_g .EOF ;};_a ,_e :=_bd ._gf .ReadBits (byte (_bd ._c .BitsPerComponent ));
if _e !=nil {return 0,_e ;};_bd ._gfe --;if _bd ._gfe ==0{_bd ._gfe =_bd ._c .ColorComponents ;_bd ._b ++;};if _bd ._b ==_bd ._c .Width {if _bd ._cf {_bd ._gf .ConsumeRemainingBits ();};_bd ._b =0;_bd ._ce ++;};return uint32 (_a ),nil ;};func (_ga *Reader )ReadSamples (samples []uint32 )(_ff error ){for _ec :=0;
_ec < len (samples );_ec ++{samples [_ec ],_ff =_ga .ReadSample ();if _ff !=nil {return _ff ;};};return nil ;};func (_fbbb *Writer )WriteSample (sample uint32 )error {if _ ,_cfa :=_fbbb ._beg .WriteBits (uint64 (sample ),_fbbb ._dde .BitsPerComponent );
_cfa !=nil {return _cfa ;};_fbbb ._gdd --;if _fbbb ._gdd ==0{_fbbb ._gdd =_fbbb ._dde .ColorComponents ;_fbbb ._ac ++;};if _fbbb ._ac ==_fbbb ._dde .Width {if _fbbb ._bbb {_fbbb ._beg .FinishByte ();};_fbbb ._ac =0;};return nil ;};type SampleReader interface{ReadSample ()(uint32 ,error );
ReadSamples (_fc []uint32 )error ;};func ResampleUint32 (data []uint32 ,bitsPerInputSample int ,bitsPerOutputSample int )[]uint32 {var _afc []uint32 ;_gfc :=bitsPerOutputSample ;var _gfeg uint32 ;var _ae uint32 ;_cc :=0;_bg :=0;_ced :=0;for _ced < len (data ){if _cc > 0{_eag :=_cc ;
if _gfc < _eag {_eag =_gfc ;};_gfeg =(_gfeg <<uint (_eag ))|(_ae >>uint (bitsPerInputSample -_eag ));_cc -=_eag ;if _cc > 0{_ae =_ae <<uint (_eag );}else {_ae =0;};_gfc -=_eag ;if _gfc ==0{_afc =append (_afc ,_gfeg );_gfc =bitsPerOutputSample ;_gfeg =0;
_bg ++;};}else {_da :=data [_ced ];_ced ++;_be :=bitsPerInputSample ;if _gfc < _be {_be =_gfc ;};_cc =bitsPerInputSample -_be ;_gfeg =(_gfeg <<uint (_be ))|(_da >>uint (_cc ));if _be < bitsPerInputSample {_ae =_da <<uint (_be );};_gfc -=_be ;if _gfc ==0{_afc =append (_afc ,_gfeg );
_gfc =bitsPerOutputSample ;_gfeg =0;_bg ++;};};};for _cc >=bitsPerOutputSample {_ba :=_cc ;if _gfc < _ba {_ba =_gfc ;};_gfeg =(_gfeg <<uint (_ba ))|(_ae >>uint (bitsPerInputSample -_ba ));_cc -=_ba ;if _cc > 0{_ae =_ae <<uint (_ba );}else {_ae =0;};_gfc -=_ba ;
if _gfc ==0{_afc =append (_afc ,_gfeg );_gfc =bitsPerOutputSample ;_gfeg =0;_bg ++;};};if _gfc > 0&&_gfc < bitsPerOutputSample {_gfeg <<=uint (_gfc );_afc =append (_afc ,_gfeg );};return _afc ;};func NewWriter (img _df .ImageBase )*Writer {return &Writer {_beg :_f .NewWriterMSB (img .Data ),_dde :img ,_gdd :img .ColorComponents ,_bbb :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};type Reader struct{_c _df .ImageBase ;_gf *_f .Reader ;_b ,_ce ,_gfe int ;_cf bool ;};type Writer struct{_dde _df .ImageBase ;_beg *_f .Writer ;_ac ,_gdd int ;_bbb bool ;};func (_cg *Writer )WriteSamples (samples []uint32 )error {for _cgb :=0;_cgb < len (samples );
_cgb ++{if _bdf :=_cg .WriteSample (samples [_cgb ]);_bdf !=nil {return _bdf ;};};return nil ;};func NewReader (img _df .ImageBase )*Reader {return &Reader {_gf :_f .NewReader (img .Data ),_c :img ,_gfe :img .ColorComponents ,_cf :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};