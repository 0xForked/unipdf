//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package sampling ;import (_a "github.com/unidoc/unipdf/v3/internal/bitwise";_dc "github.com/unidoc/unipdf/v3/internal/imageutil";_f "io";);func ResampleUint32 (data []uint32 ,bitsPerInputSample int ,bitsPerOutputSample int )[]uint32 {var _bb []uint32 ;_ab :=bitsPerOutputSample ;var _gg uint32 ;var _df uint32 ;_fad :=0;_dbb :=0;_gc :=0;for _gc < len (data ){if _fad > 0{_dba :=_fad ;if _ab < _dba {_dba =_ab ;};_gg =(_gg <<uint (_dba ))|uint32 (_df >>uint (bitsPerInputSample -_dba ));_fad -=_dba ;if _fad > 0{_df =_df <<uint (_dba );}else {_df =0;};_ab -=_dba ;if _ab ==0{_bb =append (_bb ,_gg );_ab =bitsPerOutputSample ;_gg =0;_dbb ++;};}else {_bg :=data [_gc ];_gc ++;_fec :=bitsPerInputSample ;if _ab < _fec {_fec =_ab ;};_fad =bitsPerInputSample -_fec ;_gg =(_gg <<uint (_fec ))|uint32 (_bg >>uint (_fad ));if _fec < bitsPerInputSample {_df =_bg <<uint (_fec );};_ab -=_fec ;if _ab ==0{_bb =append (_bb ,_gg );_ab =bitsPerOutputSample ;_gg =0;_dbb ++;};};};for _fad >=bitsPerOutputSample {_ace :=_fad ;if _ab < _ace {_ace =_ab ;};_gg =(_gg <<uint (_ace ))|uint32 (_df >>uint (bitsPerInputSample -_ace ));_fad -=_ace ;if _fad > 0{_df =_df <<uint (_ace );}else {_df =0;};_ab -=_ace ;if _ab ==0{_bb =append (_bb ,_gg );_ab =bitsPerOutputSample ;_gg =0;_dbb ++;};};if _ab > 0&&_ab < bitsPerOutputSample {_gg <<=uint (_ab );_bb =append (_bb ,_gg );};return _bb ;};func (_bd *Writer )WriteSample (sample uint32 )error {if _ ,_bac :=_bd ._ca .WriteBits (uint64 (sample ),_bd ._gf .BitsPerComponent );_bac !=nil {return _bac ;};_bd ._bbg --;if _bd ._bbg ==0{_bd ._bbg =_bd ._gf .ColorComponents ;_bd ._ff ++;};if _bd ._ff ==_bd ._gf .Width {if _bd ._ef {_bd ._ca .FinishByte ();};_bd ._ff =0;};return nil ;};func NewReader (img _dc .ImageBase )*Reader {return &Reader {_fb :_a .NewReader (img .Data ),_c :img ,_fe :img .ColorComponents ,_cg :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };};func (_da *Writer )WriteSamples (samples []uint32 )error {for _bf :=0;_bf < len (samples );_bf ++{if _cf :=_da .WriteSample (samples [_bf ]);_cf !=nil {return _cf ;};};return nil ;};func ResampleBytes (data []byte ,bitsPerSample int )[]uint32 {var _ee []uint32 ;_eea :=bitsPerSample ;var _g uint32 ;var _ba byte ;_fa :=0;_ec :=0;_afb :=0;for _afb < len (data ){if _fa > 0{_fc :=_fa ;if _eea < _fc {_fc =_eea ;};_g =(_g <<uint (_fc ))|uint32 (_ba >>uint (8-_fc ));_fa -=_fc ;if _fa > 0{_ba =_ba <<uint (_fc );}else {_ba =0;};_eea -=_fc ;if _eea ==0{_ee =append (_ee ,_g );_eea =bitsPerSample ;_g =0;_ec ++;};}else {_fg :=data [_afb ];_afb ++;_bc :=8;if _eea < _bc {_bc =_eea ;};_fa =8-_bc ;_g =(_g <<uint (_bc ))|uint32 (_fg >>uint (_fa ));if _bc < 8{_ba =_fg <<uint (_bc );};_eea -=_bc ;if _eea ==0{_ee =append (_ee ,_g );_eea =bitsPerSample ;_g =0;_ec ++;};};};for _fa >=bitsPerSample {_aff :=_fa ;if _eea < _aff {_aff =_eea ;};_g =(_g <<uint (_aff ))|uint32 (_ba >>uint (8-_aff ));_fa -=_aff ;if _fa > 0{_ba =_ba <<uint (_aff );}else {_ba =0;};_eea -=_aff ;if _eea ==0{_ee =append (_ee ,_g );_eea =bitsPerSample ;_g =0;_ec ++;};};return _ee ;};type SampleWriter interface{WriteSample (_afbf uint32 )error ;WriteSamples (_afc []uint32 )error ;};type Reader struct{_c _dc .ImageBase ;_fb *_a .Reader ;_ac ,_cc ,_fe int ;_cg bool ;};func NewWriter (img _dc .ImageBase )*Writer {return &Writer {_ca :_a .NewWriterMSB (img .Data ),_gf :img ,_bbg :img .ColorComponents ,_ef :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };};type SampleReader interface{ReadSample ()(uint32 ,error );ReadSamples (_e []uint32 )error ;};type Writer struct{_gf _dc .ImageBase ;_ca *_a .Writer ;_ff ,_bbg int ;_ef bool ;};func (_b *Reader )ReadSample ()(uint32 ,error ){if _b ._cc ==_b ._c .Height {return 0,_f .EOF ;};_db ,_af :=_b ._fb .ReadBits (byte (_b ._c .BitsPerComponent ));if _af !=nil {return 0,_af ;};_b ._fe --;if _b ._fe ==0{_b ._fe =_b ._c .ColorComponents ;_b ._ac ++;};if _b ._ac ==_b ._c .Width {if _b ._cg {_b ._fb .ConsumeRemainingBits ();};_b ._ac =0;_b ._cc ++;};return uint32 (_db ),nil ;};func (_dg *Reader )ReadSamples (samples []uint32 )(_eg error ){for _de :=0;_de < len (samples );_de ++{samples [_de ],_eg =_dg .ReadSample ();if _eg !=nil {return _eg ;};};return nil ;};