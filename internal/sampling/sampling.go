//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package sampling ;import (_ca "github.com/unidoc/unipdf/v3/internal/bitwise";_cac "github.com/unidoc/unipdf/v3/internal/imageutil";_c "io";);func (_dff *Writer )WriteSample (sample uint32 )error {if _ ,_fd :=_dff ._cg .WriteBits (uint64 (sample ),_dff ._beb .BitsPerComponent );
_fd !=nil {return _fd ;};_dff ._gbf --;if _dff ._gbf ==0{_dff ._gbf =_dff ._beb .ColorComponents ;_dff ._dfd ++;};if _dff ._dfd ==_dff ._beb .Width {if _dff ._ff {_dff ._cg .FinishByte ();};_dff ._dfd =0;};return nil ;};func (_a *Reader )ReadSample ()(uint32 ,error ){if _a ._f ==_a ._eb .Height {return 0,_c .EOF ;
};_gb ,_cf :=_a ._cc .ReadBits (byte (_a ._eb .BitsPerComponent ));if _cf !=nil {return 0,_cf ;};_a ._caf --;if _a ._caf ==0{_a ._caf =_a ._eb .ColorComponents ;_a ._g ++;};if _a ._g ==_a ._eb .Width {if _a ._gg {_a ._cc .ConsumeRemainingBits ();};_a ._g =0;
_a ._f ++;};return uint32 (_gb ),nil ;};func (_fg *Reader )ReadSamples (samples []uint32 )(_bc error ){for _ba :=0;_ba < len (samples );_ba ++{samples [_ba ],_bc =_fg .ReadSample ();if _bc !=nil {return _bc ;};};return nil ;};type Writer struct{_beb _cac .ImageBase ;
_cg *_ca .Writer ;_dfd ,_gbf int ;_ff bool ;};type SampleWriter interface{WriteSample (_cfc uint32 )error ;WriteSamples (_efb []uint32 )error ;};func (_bg *Writer )WriteSamples (samples []uint32 )error {for _cec :=0;_cec < len (samples );_cec ++{if _cdb :=_bg .WriteSample (samples [_cec ]);
_cdb !=nil {return _cdb ;};};return nil ;};type Reader struct{_eb _cac .ImageBase ;_cc *_ca .Reader ;_g ,_f ,_caf int ;_gg bool ;};func ResampleUint32 (data []uint32 ,bitsPerInputSample int ,bitsPerOutputSample int )[]uint32 {var _gf []uint32 ;_bb :=bitsPerOutputSample ;
var _ce uint32 ;var _aa uint32 ;_gd :=0;_ad :=0;_dfe :=0;for _dfe < len (data ){if _gd > 0{_bcc :=_gd ;if _bb < _bcc {_bcc =_bb ;};_ce =(_ce <<uint (_bcc ))|(_aa >>uint (bitsPerInputSample -_bcc ));_gd -=_bcc ;if _gd > 0{_aa =_aa <<uint (_bcc );}else {_aa =0;
};_bb -=_bcc ;if _bb ==0{_gf =append (_gf ,_ce );_bb =bitsPerOutputSample ;_ce =0;_ad ++;};}else {_bfg :=data [_dfe ];_dfe ++;_fc :=bitsPerInputSample ;if _bb < _fc {_fc =_bb ;};_gd =bitsPerInputSample -_fc ;_ce =(_ce <<uint (_fc ))|(_bfg >>uint (_gd ));
if _fc < bitsPerInputSample {_aa =_bfg <<uint (_fc );};_bb -=_fc ;if _bb ==0{_gf =append (_gf ,_ce );_bb =bitsPerOutputSample ;_ce =0;_ad ++;};};};for _gd >=bitsPerOutputSample {_ef :=_gd ;if _bb < _ef {_ef =_bb ;};_ce =(_ce <<uint (_ef ))|(_aa >>uint (bitsPerInputSample -_ef ));
_gd -=_ef ;if _gd > 0{_aa =_aa <<uint (_ef );}else {_aa =0;};_bb -=_ef ;if _bb ==0{_gf =append (_gf ,_ce );_bb =bitsPerOutputSample ;_ce =0;_ad ++;};};if _bb > 0&&_bb < bitsPerOutputSample {_ce <<=uint (_bb );_gf =append (_gf ,_ce );};return _gf ;};func ResampleBytes (data []byte ,bitsPerSample int )[]uint32 {var _eg []uint32 ;
_cfb :=bitsPerSample ;var _be uint32 ;var _bf byte ;_d :=0;_bfd :=0;_cd :=0;for _cd < len (data ){if _d > 0{_ae :=_d ;if _cfb < _ae {_ae =_cfb ;};_be =(_be <<uint (_ae ))|uint32 (_bf >>uint (8-_ae ));_d -=_ae ;if _d > 0{_bf =_bf <<uint (_ae );}else {_bf =0;
};_cfb -=_ae ;if _cfb ==0{_eg =append (_eg ,_be );_cfb =bitsPerSample ;_be =0;_bfd ++;};}else {_bef :=data [_cd ];_cd ++;_df :=8;if _cfb < _df {_df =_cfb ;};_d =8-_df ;_be =(_be <<uint (_df ))|uint32 (_bef >>uint (_d ));if _df < 8{_bf =_bef <<uint (_df );
};_cfb -=_df ;if _cfb ==0{_eg =append (_eg ,_be );_cfb =bitsPerSample ;_be =0;_bfd ++;};};};for _d >=bitsPerSample {_fa :=_d ;if _cfb < _fa {_fa =_cfb ;};_be =(_be <<uint (_fa ))|uint32 (_bf >>uint (8-_fa ));_d -=_fa ;if _d > 0{_bf =_bf <<uint (_fa );}else {_bf =0;
};_cfb -=_fa ;if _cfb ==0{_eg =append (_eg ,_be );_cfb =bitsPerSample ;_be =0;_bfd ++;};};return _eg ;};type SampleReader interface{ReadSample ()(uint32 ,error );ReadSamples (_b []uint32 )error ;};func NewWriter (img _cac .ImageBase )*Writer {return &Writer {_cg :_ca .NewWriterMSB (img .Data ),_beb :img ,_gbf :img .ColorComponents ,_ff :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};func NewReader (img _cac .ImageBase )*Reader {return &Reader {_cc :_ca .NewReader (img .Data ),_eb :img ,_caf :img .ColorComponents ,_gg :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };};