//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package sampling ;import (_g "github.com/unidoc/unipdf/v3/internal/bitwise";_gg "github.com/unidoc/unipdf/v3/internal/imageutil";_a "io";);func ResampleBytes (data []byte ,bitsPerSample int )[]uint32 {var _gff []uint32 ;_ab :=bitsPerSample ;var _gac uint32 ;
var _ca byte ;_ad :=0;_af :=0;_aff :=0;for _aff < len (data ){if _ad > 0{_aa :=_ad ;if _ab < _aa {_aa =_ab ;};_gac =(_gac <<uint (_aa ))|uint32 (_ca >>uint (8-_aa ));_ad -=_aa ;if _ad > 0{_ca =_ca <<uint (_aa );}else {_ca =0;};_ab -=_aa ;if _ab ==0{_gff =append (_gff ,_gac );
_ab =bitsPerSample ;_gac =0;_af ++;};}else {_ed :=data [_aff ];_aff ++;_bf :=8;if _ab < _bf {_bf =_ab ;};_ad =8-_bf ;_gac =(_gac <<uint (_bf ))|uint32 (_ed >>uint (_ad ));if _bf < 8{_ca =_ed <<uint (_bf );};_ab -=_bf ;if _ab ==0{_gff =append (_gff ,_gac );
_ab =bitsPerSample ;_gac =0;_af ++;};};};for _ad >=bitsPerSample {_bg :=_ad ;if _ab < _bg {_bg =_ab ;};_gac =(_gac <<uint (_bg ))|uint32 (_ca >>uint (8-_bg ));_ad -=_bg ;if _ad > 0{_ca =_ca <<uint (_bg );}else {_ca =0;};_ab -=_bg ;if _ab ==0{_gff =append (_gff ,_gac );
_ab =bitsPerSample ;_gac =0;_af ++;};};return _gff ;};func NewReader (img _gg .ImageBase )*Reader {return &Reader {_bc :_g .NewReader (img .Data ),_gf :img ,_gd :img .ColorComponents ,_c :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};func ResampleUint32 (data []uint32 ,bitsPerInputSample int ,bitsPerOutputSample int )[]uint32 {var _afff []uint32 ;_adf :=bitsPerOutputSample ;var _ef uint32 ;var _dc uint32 ;_ggb :=0;_abb :=0;_de :=0;for _de < len (data ){if _ggb > 0{_gfe :=_ggb ;if _adf < _gfe {_gfe =_adf ;
};_ef =(_ef <<uint (_gfe ))|(_dc >>uint (bitsPerInputSample -_gfe ));_ggb -=_gfe ;if _ggb > 0{_dc =_dc <<uint (_gfe );}else {_dc =0;};_adf -=_gfe ;if _adf ==0{_afff =append (_afff ,_ef );_adf =bitsPerOutputSample ;_ef =0;_abb ++;};}else {_dee :=data [_de ];
_de ++;_ec :=bitsPerInputSample ;if _adf < _ec {_ec =_adf ;};_ggb =bitsPerInputSample -_ec ;_ef =(_ef <<uint (_ec ))|(_dee >>uint (_ggb ));if _ec < bitsPerInputSample {_dc =_dee <<uint (_ec );};_adf -=_ec ;if _adf ==0{_afff =append (_afff ,_ef );_adf =bitsPerOutputSample ;
_ef =0;_abb ++;};};};for _ggb >=bitsPerOutputSample {_abg :=_ggb ;if _adf < _abg {_abg =_adf ;};_ef =(_ef <<uint (_abg ))|(_dc >>uint (bitsPerInputSample -_abg ));_ggb -=_abg ;if _ggb > 0{_dc =_dc <<uint (_abg );}else {_dc =0;};_adf -=_abg ;if _adf ==0{_afff =append (_afff ,_ef );
_adf =bitsPerOutputSample ;_ef =0;_abb ++;};};if _adf > 0&&_adf < bitsPerOutputSample {_ef <<=uint (_adf );_afff =append (_afff ,_ef );};return _afff ;};func (_gga *Reader )ReadSample ()(uint32 ,error ){if _gga ._e ==_gga ._gf .Height {return 0,_a .EOF ;
};_bd ,_fb :=_gga ._bc .ReadBits (byte (_gga ._gf .BitsPerComponent ));if _fb !=nil {return 0,_fb ;};_gga ._gd --;if _gga ._gd ==0{_gga ._gd =_gga ._gf .ColorComponents ;_gga ._ggc ++;};if _gga ._ggc ==_gga ._gf .Width {if _gga ._c {_gga ._bc .ConsumeRemainingBits ();
};_gga ._ggc =0;_gga ._e ++;};return uint32 (_bd ),nil ;};type Writer struct{_afe _gg .ImageBase ;_fe *_g .Writer ;_cc ,_gb int ;_cd bool ;};type SampleReader interface{ReadSample ()(uint32 ,error );ReadSamples (_b []uint32 )error ;};type SampleWriter interface{WriteSample (_gfg uint32 )error ;
WriteSamples (_bge []uint32 )error ;};func (_db *Writer )WriteSamples (samples []uint32 )error {for _fbf :=0;_fbf < len (samples );_fbf ++{if _be :=_db .WriteSample (samples [_fbf ]);_be !=nil {return _be ;};};return nil ;};func (_ac *Reader )ReadSamples (samples []uint32 )(_ga error ){for _d :=0;
_d < len (samples );_d ++{samples [_d ],_ga =_ac .ReadSample ();if _ga !=nil {return _ga ;};};return nil ;};type Reader struct{_gf _gg .ImageBase ;_bc *_g .Reader ;_ggc ,_e ,_gd int ;_c bool ;};func (_ea *Writer )WriteSample (sample uint32 )error {if _ ,_ba :=_ea ._fe .WriteBits (uint64 (sample ),_ea ._afe .BitsPerComponent );
_ba !=nil {return _ba ;};_ea ._gb --;if _ea ._gb ==0{_ea ._gb =_ea ._afe .ColorComponents ;_ea ._cc ++;};if _ea ._cc ==_ea ._afe .Width {if _ea ._cd {_ea ._fe .FinishByte ();};_ea ._cc =0;};return nil ;};func NewWriter (img _gg .ImageBase )*Writer {return &Writer {_fe :_g .NewWriterMSB (img .Data ),_afe :img ,_gb :img .ColorComponents ,_cd :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};