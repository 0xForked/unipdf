//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package sampling ;import (_d "github.com/unidoc/unipdf/v3/internal/bitwise";_ca "github.com/unidoc/unipdf/v3/internal/imageutil";_e "io";);func NewWriter (img _ca .ImageBase )*Writer {return &Writer {_eed :_d .NewWriterMSB (img .Data ),_bca :img ,_gg :img .ColorComponents ,_fgc :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};func ResampleUint32 (data []uint32 ,bitsPerInputSample int ,bitsPerOutputSample int )[]uint32 {var _gb []uint32 ;_fa :=bitsPerOutputSample ;var _ag uint32 ;var _dd uint32 ;_fg :=0;_db :=0;_gf :=0;for _gf < len (data ){if _fg > 0{_gdg :=_fg ;if _fa < _gdg {_gdg =_fa ;
};_ag =(_ag <<uint (_gdg ))|(_dd >>uint (bitsPerInputSample -_gdg ));_fg -=_gdg ;if _fg > 0{_dd =_dd <<uint (_gdg );}else {_dd =0;};_fa -=_gdg ;if _fa ==0{_gb =append (_gb ,_ag );_fa =bitsPerOutputSample ;_ag =0;_db ++;};}else {_dbd :=data [_gf ];_gf ++;
_dbc :=bitsPerInputSample ;if _fa < _dbc {_dbc =_fa ;};_fg =bitsPerInputSample -_dbc ;_ag =(_ag <<uint (_dbc ))|(_dbd >>uint (_fg ));if _dbc < bitsPerInputSample {_dd =_dbd <<uint (_dbc );};_fa -=_dbc ;if _fa ==0{_gb =append (_gb ,_ag );_fa =bitsPerOutputSample ;
_ag =0;_db ++;};};};for _fg >=bitsPerOutputSample {_fe :=_fg ;if _fa < _fe {_fe =_fa ;};_ag =(_ag <<uint (_fe ))|(_dd >>uint (bitsPerInputSample -_fe ));_fg -=_fe ;if _fg > 0{_dd =_dd <<uint (_fe );}else {_dd =0;};_fa -=_fe ;if _fa ==0{_gb =append (_gb ,_ag );
_fa =bitsPerOutputSample ;_ag =0;_db ++;};};if _fa > 0&&_fa < bitsPerOutputSample {_ag <<=uint (_fa );_gb =append (_gb ,_ag );};return _gb ;};func NewReader (img _ca .ImageBase )*Reader {return &Reader {_eb :_d .NewReader (img .Data ),_cb :img ,_g :img .ColorComponents ,_b :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};func (_bb *Reader )ReadSample ()(uint32 ,error ){if _bb ._a ==_bb ._cb .Height {return 0,_e .EOF ;};_cc ,_dc :=_bb ._eb .ReadBits (byte (_bb ._cb .BitsPerComponent ));if _dc !=nil {return 0,_dc ;};_bb ._g --;if _bb ._g ==0{_bb ._g =_bb ._cb .ColorComponents ;
_bb ._da ++;};if _bb ._da ==_bb ._cb .Width {if _bb ._b {_bb ._eb .ConsumeRemainingBits ();};_bb ._da =0;_bb ._a ++;};return uint32 (_cc ),nil ;};type SampleReader interface{ReadSample ()(uint32 ,error );ReadSamples (_f []uint32 )error ;};type SampleWriter interface{WriteSample (_dcb uint32 )error ;
WriteSamples (_bc []uint32 )error ;};type Writer struct{_bca _ca .ImageBase ;_eed *_d .Writer ;_eg ,_gg int ;_fgc bool ;};func (_gbf *Writer )WriteSamples (samples []uint32 )error {for _bd :=0;_bd < len (samples );_bd ++{if _ec :=_gbf .WriteSample (samples [_bd ]);
_ec !=nil {return _ec ;};};return nil ;};type Reader struct{_cb _ca .ImageBase ;_eb *_d .Reader ;_da ,_a ,_g int ;_b bool ;};func (_cf *Writer )WriteSample (sample uint32 )error {if _ ,_afd :=_cf ._eed .WriteBits (uint64 (sample ),_cf ._bca .BitsPerComponent );
_afd !=nil {return _afd ;};_cf ._gg --;if _cf ._gg ==0{_cf ._gg =_cf ._bca .ColorComponents ;_cf ._eg ++;};if _cf ._eg ==_cf ._bca .Width {if _cf ._fgc {_cf ._eed .FinishByte ();};_cf ._eg =0;};return nil ;};func ResampleBytes (data []byte ,bitsPerSample int )[]uint32 {var _dag []uint32 ;
_gd :=bitsPerSample ;var _dab uint32 ;var _ab byte ;_ff :=0;_eeg :=0;_cgf :=0;for _cgf < len (data ){if _ff > 0{_ebf :=_ff ;if _gd < _ebf {_ebf =_gd ;};_dab =(_dab <<uint (_ebf ))|uint32 (_ab >>uint (8-_ebf ));_ff -=_ebf ;if _ff > 0{_ab =_ab <<uint (_ebf );
}else {_ab =0;};_gd -=_ebf ;if _gd ==0{_dag =append (_dag ,_dab );_gd =bitsPerSample ;_dab =0;_eeg ++;};}else {_fc :=data [_cgf ];_cgf ++;_fd :=8;if _gd < _fd {_fd =_gd ;};_ff =8-_fd ;_dab =(_dab <<uint (_fd ))|uint32 (_fc >>uint (_ff ));if _fd < 8{_ab =_fc <<uint (_fd );
};_gd -=_fd ;if _gd ==0{_dag =append (_dag ,_dab );_gd =bitsPerSample ;_dab =0;_eeg ++;};};};for _ff >=bitsPerSample {_af :=_ff ;if _gd < _af {_af =_gd ;};_dab =(_dab <<uint (_af ))|uint32 (_ab >>uint (8-_af ));_ff -=_af ;if _ff > 0{_ab =_ab <<uint (_af );
}else {_ab =0;};_gd -=_af ;if _gd ==0{_dag =append (_dag ,_dab );_gd =bitsPerSample ;_dab =0;_eeg ++;};};return _dag ;};func (_cg *Reader )ReadSamples (samples []uint32 )(_ee error ){for _ccf :=0;_ccf < len (samples );_ccf ++{samples [_ccf ],_ee =_cg .ReadSample ();
if _ee !=nil {return _ee ;};};return nil ;};