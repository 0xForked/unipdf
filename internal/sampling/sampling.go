//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package sampling ;import (_b "github.com/unidoc/unipdf/v3/internal/bitwise";_f "github.com/unidoc/unipdf/v3/internal/imageutil";_gg "io";);func (_fb *Reader )ReadSamples (samples []uint32 )(_dd error ){for _ec :=0;_ec < len (samples );_ec ++{samples [_ec ],_dd =_fb .ReadSample ();
if _dd !=nil {return _dd ;};};return nil ;};type SampleWriter interface{WriteSample (_edf uint32 )error ;WriteSamples (_cg []uint32 )error ;};func (_ggb *Reader )ReadSample ()(uint32 ,error ){if _ggb ._gf ==_ggb ._d .Height {return 0,_gg .EOF ;};_c ,_eb :=_ggb ._a .ReadBits (byte (_ggb ._d .BitsPerComponent ));
if _eb !=nil {return 0,_eb ;};_ggb ._e --;if _ggb ._e ==0{_ggb ._e =_ggb ._d .ColorComponents ;_ggb ._fe ++;};if _ggb ._fe ==_ggb ._d .Width {if _ggb ._dc {_ggb ._a .ConsumeRemainingBits ();};_ggb ._fe =0;_ggb ._gf ++;};return uint32 (_c ),nil ;};type Writer struct{_ecf _f .ImageBase ;
_ede *_b .Writer ;_fec ,_eeg int ;_ddd bool ;};func (_ca *Writer )WriteSample (sample uint32 )error {if _ ,_cdg :=_ca ._ede .WriteBits (uint64 (sample ),_ca ._ecf .BitsPerComponent );_cdg !=nil {return _cdg ;};_ca ._eeg --;if _ca ._eeg ==0{_ca ._eeg =_ca ._ecf .ColorComponents ;
_ca ._fec ++;};if _ca ._fec ==_ca ._ecf .Width {if _ca ._ddd {_ca ._ede .FinishByte ();};_ca ._fec =0;};return nil ;};type SampleReader interface{ReadSample ()(uint32 ,error );ReadSamples (_ge []uint32 )error ;};func NewWriter (img _f .ImageBase )*Writer {return &Writer {_ede :_b .NewWriterMSB (img .Data ),_ecf :img ,_eeg :img .ColorComponents ,_ddd :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};func (_gd *Writer )WriteSamples (samples []uint32 )error {for _fg :=0;_fg < len (samples );_fg ++{if _edg :=_gd .WriteSample (samples [_fg ]);_edg !=nil {return _edg ;};};return nil ;};func NewReader (img _f .ImageBase )*Reader {return &Reader {_a :_b .NewReader (img .Data ),_d :img ,_e :img .ColorComponents ,_dc :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};func ResampleUint32 (data []uint32 ,bitsPerInputSample int ,bitsPerOutputSample int )[]uint32 {var _be []uint32 ;_ab :=bitsPerOutputSample ;var _bb uint32 ;var _df uint32 ;_ea :=0;_ece :=0;_bd :=0;for _bd < len (data ){if _ea > 0{_aba :=_ea ;if _ab < _aba {_aba =_ab ;
};_bb =(_bb <<uint (_aba ))|(_df >>uint (bitsPerInputSample -_aba ));_ea -=_aba ;if _ea > 0{_df =_df <<uint (_aba );}else {_df =0;};_ab -=_aba ;if _ab ==0{_be =append (_be ,_bb );_ab =bitsPerOutputSample ;_bb =0;_ece ++;};}else {_ebc :=data [_bd ];_bd ++;
_geg :=bitsPerInputSample ;if _ab < _geg {_geg =_ab ;};_ea =bitsPerInputSample -_geg ;_bb =(_bb <<uint (_geg ))|(_ebc >>uint (_ea ));if _geg < bitsPerInputSample {_df =_ebc <<uint (_geg );};_ab -=_geg ;if _ab ==0{_be =append (_be ,_bb );_ab =bitsPerOutputSample ;
_bb =0;_ece ++;};};};for _ea >=bitsPerOutputSample {_ed :=_ea ;if _ab < _ed {_ed =_ab ;};_bb =(_bb <<uint (_ed ))|(_df >>uint (bitsPerInputSample -_ed ));_ea -=_ed ;if _ea > 0{_df =_df <<uint (_ed );}else {_df =0;};_ab -=_ed ;if _ab ==0{_be =append (_be ,_bb );
_ab =bitsPerOutputSample ;_bb =0;_ece ++;};};if _ab > 0&&_ab < bitsPerOutputSample {_bb <<=uint (_ab );_be =append (_be ,_bb );};return _be ;};type Reader struct{_d _f .ImageBase ;_a *_b .Reader ;_fe ,_gf ,_e int ;_dc bool ;};func ResampleBytes (data []byte ,bitsPerSample int )[]uint32 {var _de []uint32 ;
_ee :=bitsPerSample ;var _ddb uint32 ;var _bc byte ;_cd :=0;_fea :=0;_ae :=0;for _ae < len (data ){if _cd > 0{_dec :=_cd ;if _ee < _dec {_dec =_ee ;};_ddb =(_ddb <<uint (_dec ))|uint32 (_bc >>uint (8-_dec ));_cd -=_dec ;if _cd > 0{_bc =_bc <<uint (_dec );
}else {_bc =0;};_ee -=_dec ;if _ee ==0{_de =append (_de ,_ddb );_ee =bitsPerSample ;_ddb =0;_fea ++;};}else {_eg :=data [_ae ];_ae ++;_gc :=8;if _ee < _gc {_gc =_ee ;};_cd =8-_gc ;_ddb =(_ddb <<uint (_gc ))|uint32 (_eg >>uint (_cd ));if _gc < 8{_bc =_eg <<uint (_gc );
};_ee -=_gc ;if _ee ==0{_de =append (_de ,_ddb );_ee =bitsPerSample ;_ddb =0;_fea ++;};};};for _cd >=bitsPerSample {_ef :=_cd ;if _ee < _ef {_ef =_ee ;};_ddb =(_ddb <<uint (_ef ))|uint32 (_bc >>uint (8-_ef ));_cd -=_ef ;if _cd > 0{_bc =_bc <<uint (_ef );
}else {_bc =0;};_ee -=_ef ;if _ee ==0{_de =append (_de ,_ddb );_ee =bitsPerSample ;_ddb =0;_fea ++;};};return _de ;};