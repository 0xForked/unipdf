//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package sampling ;import (_cb "github.com/unidoc/unipdf/v3/internal/bitwise";_bb "github.com/unidoc/unipdf/v3/internal/imageutil";_c "io";);func ResampleUint32 (data []uint32 ,bitsPerInputSample int ,bitsPerOutputSample int )[]uint32 {var _ec []uint32 ;_bfg :=bitsPerOutputSample ;var _bg uint32 ;var _a uint32 ;_af :=0;_fdb :=0;_cef :=0;for _cef < len (data ){if _af > 0{_gfe :=_af ;if _bfg < _gfe {_gfe =_bfg ;};_bg =(_bg <<uint (_gfe ))|uint32 (_a >>uint (bitsPerInputSample -_gfe ));_af -=_gfe ;if _af > 0{_a =_a <<uint (_gfe );}else {_a =0;};_bfg -=_gfe ;if _bfg ==0{_ec =append (_ec ,_bg );_bfg =bitsPerOutputSample ;_bg =0;_fdb ++;};}else {_db :=data [_cef ];_cef ++;_ca :=bitsPerInputSample ;if _bfg < _ca {_ca =_bfg ;};_af =bitsPerInputSample -_ca ;_bg =(_bg <<uint (_ca ))|uint32 (_db >>uint (_af ));if _ca < bitsPerInputSample {_a =_db <<uint (_ca );};_bfg -=_ca ;if _bfg ==0{_ec =append (_ec ,_bg );_bfg =bitsPerOutputSample ;_bg =0;_fdb ++;};};};for _af >=bitsPerOutputSample {_ecd :=_af ;if _bfg < _ecd {_ecd =_bfg ;};_bg =(_bg <<uint (_ecd ))|uint32 (_a >>uint (bitsPerInputSample -_ecd ));_af -=_ecd ;if _af > 0{_a =_a <<uint (_ecd );}else {_a =0;};_bfg -=_ecd ;if _bfg ==0{_ec =append (_ec ,_bg );_bfg =bitsPerOutputSample ;_bg =0;_fdb ++;};};if _bfg > 0&&_bfg < bitsPerOutputSample {_bg <<=uint (_bfg );_ec =append (_ec ,_bg );};return _ec ;};func (_gcf *Reader )ReadSamples (samples []uint32 )(_cfe error ){for _bc :=0;_bc < len (samples );_bc ++{samples [_bc ],_cfe =_gcf .ReadSample ();if _cfe !=nil {return _cfe ;};};return nil ;};type SampleWriter interface{WriteSample (_ee uint32 )error ;WriteSamples (_ef []uint32 )error ;};func (_bbe *Writer )WriteSamples (samples []uint32 )error {for _bfe :=0;_bfe < len (samples );_bfe ++{if _fa :=_bbe .WriteSample (samples [_bfe ]);_fa !=nil {return _fa ;};};return nil ;};func (_bca *Writer )WriteSample (sample uint32 )error {if _ ,_bgb :=_bca ._fe .WriteBits (uint64 (sample ),_bca ._ac .BitsPerComponent );_bgb !=nil {return _bgb ;};_bca ._aa --;if _bca ._aa ==0{_bca ._aa =_bca ._ac .ColorComponents ;_bca ._ge ++;};if _bca ._ge ==_bca ._ac .Width {if _bca ._fg {_bca ._fe .FinishByte ();};_bca ._ge =0;};return nil ;};func NewReader (img _bb .ImageBase )*Reader {return &Reader {_da :_cb .NewReader (img .Data ),_d :img ,_gc :img .ColorComponents ,_be :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };};func (_f *Reader )ReadSample ()(uint32 ,error ){if _f ._g ==_f ._d .Height {return 0,_c .EOF ;};_ced ,_cf :=_f ._da .ReadBits (byte (_f ._d .BitsPerComponent ));if _cf !=nil {return 0,_cf ;};_f ._gc --;if _f ._gc ==0{_f ._gc =_f ._d .ColorComponents ;_f ._bf ++;};if _f ._bf ==_f ._d .Width {if _f ._be {_f ._da .ConsumeRemainingBits ();};_f ._bf =0;_f ._g ++;};return uint32 (_ced ),nil ;};type SampleReader interface{ReadSample ()(uint32 ,error );ReadSamples (_ce []uint32 )error ;};type Reader struct{_d _bb .ImageBase ;_da *_cb .Reader ;_bf ,_g ,_gc int ;_be bool ;};type Writer struct{_ac _bb .ImageBase ;_fe *_cb .Writer ;_ge ,_aa int ;_fg bool ;};func NewWriter (img _bb .ImageBase )*Writer {return &Writer {_fe :_cb .NewWriterMSB (img .Data ),_ac :img ,_aa :img .ColorComponents ,_fg :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };};func ResampleBytes (data []byte ,bitsPerSample int )[]uint32 {var _beg []uint32 ;_cg :=bitsPerSample ;var _gf uint32 ;var _fd byte ;_bff :=0;_daa :=0;_e :=0;for _e < len (data ){if _bff > 0{_eg :=_bff ;if _cg < _eg {_eg =_cg ;};_gf =(_gf <<uint (_eg ))|uint32 (_fd >>uint (8-_eg ));_bff -=_eg ;if _bff > 0{_fd =_fd <<uint (_eg );}else {_fd =0;};_cg -=_eg ;if _cg ==0{_beg =append (_beg ,_gf );_cg =bitsPerSample ;_gf =0;_daa ++;};}else {_gcg :=data [_e ];_e ++;_dac :=8;if _cg < _dac {_dac =_cg ;};_bff =8-_dac ;_gf =(_gf <<uint (_dac ))|uint32 (_gcg >>uint (_bff ));if _dac < 8{_fd =_gcg <<uint (_dac );};_cg -=_dac ;if _cg ==0{_beg =append (_beg ,_gf );_cg =bitsPerSample ;_gf =0;_daa ++;};};};for _bff >=bitsPerSample {_ceg :=_bff ;if _cg < _ceg {_ceg =_cg ;};_gf =(_gf <<uint (_ceg ))|uint32 (_fd >>uint (8-_ceg ));_bff -=_ceg ;if _bff > 0{_fd =_fd <<uint (_ceg );}else {_fd =0;};_cg -=_ceg ;if _cg ==0{_beg =append (_beg ,_gf );_cg =bitsPerSample ;_gf =0;_daa ++;};};return _beg ;};