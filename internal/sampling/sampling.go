//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package sampling ;import (_f "github.com/unidoc/unipdf/v3/internal/bitwise";_d "github.com/unidoc/unipdf/v3/internal/imageutil";_a "io";);func ResampleBytes (data []byte ,bitsPerSample int )[]uint32 {var _da []uint32 ;_cac :=bitsPerSample ;var _ad uint32 ;
var _eab byte ;_efa :=0;_dac :=0;_fe :=0;for _fe < len (data ){if _efa > 0{_eg :=_efa ;if _cac < _eg {_eg =_cac ;};_ad =(_ad <<uint (_eg ))|uint32 (_eab >>uint (8-_eg ));_efa -=_eg ;if _efa > 0{_eab =_eab <<uint (_eg );}else {_eab =0;};_cac -=_eg ;if _cac ==0{_da =append (_da ,_ad );
_cac =bitsPerSample ;_ad =0;_dac ++;};}else {_fee :=data [_fe ];_fe ++;_dc :=8;if _cac < _dc {_dc =_cac ;};_efa =8-_dc ;_ad =(_ad <<uint (_dc ))|uint32 (_fee >>uint (_efa ));if _dc < 8{_eab =_fee <<uint (_dc );};_cac -=_dc ;if _cac ==0{_da =append (_da ,_ad );
_cac =bitsPerSample ;_ad =0;_dac ++;};};};for _efa >=bitsPerSample {_ag :=_efa ;if _cac < _ag {_ag =_cac ;};_ad =(_ad <<uint (_ag ))|uint32 (_eab >>uint (8-_ag ));_efa -=_ag ;if _efa > 0{_eab =_eab <<uint (_ag );}else {_eab =0;};_cac -=_ag ;if _cac ==0{_da =append (_da ,_ad );
_cac =bitsPerSample ;_ad =0;_dac ++;};};return _da ;};func NewWriter (img _d .ImageBase )*Writer {return &Writer {_egd :_f .NewWriterMSB (img .Data ),_ac :img ,_gff :img .ColorComponents ,_ge :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};type Reader struct{_fb _d .ImageBase ;_g *_f .Reader ;_b ,_gd ,_ab int ;_bc bool ;};func NewReader (img _d .ImageBase )*Reader {return &Reader {_g :_f .NewReader (img .Data ),_fb :img ,_ab :img .ColorComponents ,_bc :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};func ResampleUint32 (data []uint32 ,bitsPerInputSample int ,bitsPerOutputSample int )[]uint32 {var _bcg []uint32 ;_bd :=bitsPerOutputSample ;var _gf uint32 ;var _af uint32 ;_fbb :=0;_dd :=0;_abb :=0;for _abb < len (data ){if _fbb > 0{_de :=_fbb ;if _bd < _de {_de =_bd ;
};_gf =(_gf <<uint (_de ))|(_af >>uint (bitsPerInputSample -_de ));_fbb -=_de ;if _fbb > 0{_af =_af <<uint (_de );}else {_af =0;};_bd -=_de ;if _bd ==0{_bcg =append (_bcg ,_gf );_bd =bitsPerOutputSample ;_gf =0;_dd ++;};}else {_fa :=data [_abb ];_abb ++;
_bf :=bitsPerInputSample ;if _bd < _bf {_bf =_bd ;};_fbb =bitsPerInputSample -_bf ;_gf =(_gf <<uint (_bf ))|(_fa >>uint (_fbb ));if _bf < bitsPerInputSample {_af =_fa <<uint (_bf );};_bd -=_bf ;if _bd ==0{_bcg =append (_bcg ,_gf );_bd =bitsPerOutputSample ;
_gf =0;_dd ++;};};};for _fbb >=bitsPerOutputSample {_cf :=_fbb ;if _bd < _cf {_cf =_bd ;};_gf =(_gf <<uint (_cf ))|(_af >>uint (bitsPerInputSample -_cf ));_fbb -=_cf ;if _fbb > 0{_af =_af <<uint (_cf );}else {_af =0;};_bd -=_cf ;if _bd ==0{_bcg =append (_bcg ,_gf );
_bd =bitsPerOutputSample ;_gf =0;_dd ++;};};if _bd > 0&&_bd < bitsPerOutputSample {_gf <<=uint (_bd );_bcg =append (_bcg ,_gf );};return _bcg ;};type Writer struct{_ac _d .ImageBase ;_egd *_f .Writer ;_bgb ,_gff int ;_ge bool ;};func (_ea *Reader )ReadSample ()(uint32 ,error ){if _ea ._gd ==_ea ._fb .Height {return 0,_a .EOF ;
};_abc ,_ae :=_ea ._g .ReadBits (byte (_ea ._fb .BitsPerComponent ));if _ae !=nil {return 0,_ae ;};_ea ._ab --;if _ea ._ab ==0{_ea ._ab =_ea ._fb .ColorComponents ;_ea ._b ++;};if _ea ._b ==_ea ._fb .Width {if _ea ._bc {_ea ._g .ConsumeRemainingBits ();
};_ea ._b =0;_ea ._gd ++;};return uint32 (_abc ),nil ;};func (_ef *Reader )ReadSamples (samples []uint32 )(_ca error ){for _ba :=0;_ba < len (samples );_ba ++{samples [_ba ],_ca =_ef .ReadSample ();if _ca !=nil {return _ca ;};};return nil ;};func (_bfb *Writer )WriteSamples (samples []uint32 )error {for _bb :=0;
_bb < len (samples );_bb ++{if _bcd :=_bfb .WriteSample (samples [_bb ]);_bcd !=nil {return _bcd ;};};return nil ;};type SampleWriter interface{WriteSample (_bg uint32 )error ;WriteSamples (_ddf []uint32 )error ;};type SampleReader interface{ReadSample ()(uint32 ,error );
ReadSamples (_c []uint32 )error ;};func (_dea *Writer )WriteSample (sample uint32 )error {if _ ,_adg :=_dea ._egd .WriteBits (uint64 (sample ),_dea ._ac .BitsPerComponent );_adg !=nil {return _adg ;};_dea ._gff --;if _dea ._gff ==0{_dea ._gff =_dea ._ac .ColorComponents ;
_dea ._bgb ++;};if _dea ._bgb ==_dea ._ac .Width {if _dea ._ge {_dea ._egd .FinishByte ();};_dea ._bgb =0;};return nil ;};