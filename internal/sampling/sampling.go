//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package sampling ;import (_gg "github.com/unidoc/unipdf/v3/internal/bitwise";_d "github.com/unidoc/unipdf/v3/internal/imageutil";_b "io";);type Reader struct{_gd _d .ImageBase ;_c *_gg .Reader ;_ca ,_bf ,_e int ;_f bool ;};type SampleReader interface{ReadSample ()(uint32 ,error );
ReadSamples (_ba []uint32 )error ;};func (_bd *Reader )ReadSamples (samples []uint32 )(_cc error ){for _cg :=0;_cg < len (samples );_cg ++{samples [_cg ],_cc =_bd .ReadSample ();if _cc !=nil {return _cc ;};};return nil ;};func ResampleBytes (data []byte ,bitsPerSample int )[]uint32 {var _fd []uint32 ;
_de :=bitsPerSample ;var _eg uint32 ;var _db byte ;_cf :=0;_ggf :=0;_ega :=0;for _ega < len (data ){if _cf > 0{_ea :=_cf ;if _de < _ea {_ea =_de ;};_eg =(_eg <<uint (_ea ))|uint32 (_db >>uint (8-_ea ));_cf -=_ea ;if _cf > 0{_db =_db <<uint (_ea );}else {_db =0;
};_de -=_ea ;if _de ==0{_fd =append (_fd ,_eg );_de =bitsPerSample ;_eg =0;_ggf ++;};}else {_aag :=data [_ega ];_ega ++;_ce :=8;if _de < _ce {_ce =_de ;};_cf =8-_ce ;_eg =(_eg <<uint (_ce ))|uint32 (_aag >>uint (_cf ));if _ce < 8{_db =_aag <<uint (_ce );
};_de -=_ce ;if _de ==0{_fd =append (_fd ,_eg );_de =bitsPerSample ;_eg =0;_ggf ++;};};};for _cf >=bitsPerSample {_cb :=_cf ;if _de < _cb {_cb =_de ;};_eg =(_eg <<uint (_cb ))|uint32 (_db >>uint (8-_cb ));_cf -=_cb ;if _cf > 0{_db =_db <<uint (_cb );}else {_db =0;
};_de -=_cb ;if _de ==0{_fd =append (_fd ,_eg );_de =bitsPerSample ;_eg =0;_ggf ++;};};return _fd ;};func (_cd *Writer )WriteSample (sample uint32 )error {if _ ,_ebc :=_cd ._ff .WriteBits (uint64 (sample ),_cd ._bfe .BitsPerComponent );_ebc !=nil {return _ebc ;
};_cd ._be --;if _cd ._be ==0{_cd ._be =_cd ._bfe .ColorComponents ;_cd ._eb ++;};if _cd ._eb ==_cd ._bfe .Width {if _cd ._gfd {_cd ._ff .FinishByte ();};_cd ._eb =0;};return nil ;};func ResampleUint32 (data []uint32 ,bitsPerInputSample int ,bitsPerOutputSample int )[]uint32 {var _ge []uint32 ;
_gf :=bitsPerOutputSample ;var _ggd uint32 ;var _ee uint32 ;_eec :=0;_aaa :=0;_dc :=0;for _dc < len (data ){if _eec > 0{_dce :=_eec ;if _gf < _dce {_dce =_gf ;};_ggd =(_ggd <<uint (_dce ))|(_ee >>uint (bitsPerInputSample -_dce ));_eec -=_dce ;if _eec > 0{_ee =_ee <<uint (_dce );
}else {_ee =0;};_gf -=_dce ;if _gf ==0{_ge =append (_ge ,_ggd );_gf =bitsPerOutputSample ;_ggd =0;_aaa ++;};}else {_gge :=data [_dc ];_dc ++;_dag :=bitsPerInputSample ;if _gf < _dag {_dag =_gf ;};_eec =bitsPerInputSample -_dag ;_ggd =(_ggd <<uint (_dag ))|(_gge >>uint (_eec ));
if _dag < bitsPerInputSample {_ee =_gge <<uint (_dag );};_gf -=_dag ;if _gf ==0{_ge =append (_ge ,_ggd );_gf =bitsPerOutputSample ;_ggd =0;_aaa ++;};};};for _eec >=bitsPerOutputSample {_bad :=_eec ;if _gf < _bad {_bad =_gf ;};_ggd =(_ggd <<uint (_bad ))|(_ee >>uint (bitsPerInputSample -_bad ));
_eec -=_bad ;if _eec > 0{_ee =_ee <<uint (_bad );}else {_ee =0;};_gf -=_bad ;if _gf ==0{_ge =append (_ge ,_ggd );_gf =bitsPerOutputSample ;_ggd =0;_aaa ++;};};if _gf > 0&&_gf < bitsPerOutputSample {_ggd <<=uint (_gf );_ge =append (_ge ,_ggd );};return _ge ;
};func NewWriter (img _d .ImageBase )*Writer {return &Writer {_ff :_gg .NewWriterMSB (img .Data ),_bfe :img ,_be :img .ColorComponents ,_gfd :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };};func (_a *Reader )ReadSample ()(uint32 ,error ){if _a ._bf ==_a ._gd .Height {return 0,_b .EOF ;
};_da ,_aa :=_a ._c .ReadBits (byte (_a ._gd .BitsPerComponent ));if _aa !=nil {return 0,_aa ;};_a ._e --;if _a ._e ==0{_a ._e =_a ._gd .ColorComponents ;_a ._ca ++;};if _a ._ca ==_a ._gd .Width {if _a ._f {_a ._c .ConsumeRemainingBits ();};_a ._ca =0;
_a ._bf ++;};return uint32 (_da ),nil ;};func (_ebb *Writer )WriteSamples (samples []uint32 )error {for _ebg :=0;_ebg < len (samples );_ebg ++{if _cff :=_ebb .WriteSample (samples [_ebg ]);_cff !=nil {return _cff ;};};return nil ;};func NewReader (img _d .ImageBase )*Reader {return &Reader {_c :_gg .NewReader (img .Data ),_gd :img ,_e :img .ColorComponents ,_f :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};type SampleWriter interface{WriteSample (_def uint32 )error ;WriteSamples (_dd []uint32 )error ;};type Writer struct{_bfe _d .ImageBase ;_ff *_gg .Writer ;_eb ,_be int ;_gfd bool ;};