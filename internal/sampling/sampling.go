//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package sampling ;import (_g "github.com/unidoc/unipdf/v3/internal/bitwise";_b "github.com/unidoc/unipdf/v3/internal/imageutil";_d "io";);func (_ae *Writer )WriteSample (sample uint32 )error {if _ ,_fab :=_ae ._fg .WriteBits (uint64 (sample ),_ae ._bdc .BitsPerComponent );
_fab !=nil {return _fab ;};_ae ._deg --;if _ae ._deg ==0{_ae ._deg =_ae ._bdc .ColorComponents ;_ae ._ba ++;};if _ae ._ba ==_ae ._bdc .Width {if _ae ._abg {_ae ._fg .FinishByte ();};_ae ._ba =0;};return nil ;};type SampleWriter interface{WriteSample (_ece uint32 )error ;
WriteSamples (_cge []uint32 )error ;};type Writer struct{_bdc _b .ImageBase ;_fg *_g .Writer ;_ba ,_deg int ;_abg bool ;};func (_gf *Reader )ReadSamples (samples []uint32 )(_af error ){for _ge :=0;_ge < len (samples );_ge ++{samples [_ge ],_af =_gf .ReadSample ();
if _af !=nil {return _af ;};};return nil ;};func (_ab *Reader )ReadSample ()(uint32 ,error ){if _ab ._bg ==_ab ._f .Height {return 0,_d .EOF ;};_bgb ,_c :=_ab ._bf .ReadBits (byte (_ab ._f .BitsPerComponent ));if _c !=nil {return 0,_c ;};_ab ._ga --;if _ab ._ga ==0{_ab ._ga =_ab ._f .ColorComponents ;
_ab ._bfc ++;};if _ab ._bfc ==_ab ._f .Width {if _ab ._bd {_ab ._bf .ConsumeRemainingBits ();};_ab ._bfc =0;_ab ._bg ++;};return uint32 (_bgb ),nil ;};func (_da *Writer )WriteSamples (samples []uint32 )error {for _dd :=0;_dd < len (samples );_dd ++{if _gb :=_da .WriteSample (samples [_dd ]);
_gb !=nil {return _gb ;};};return nil ;};type Reader struct{_f _b .ImageBase ;_bf *_g .Reader ;_bfc ,_bg ,_ga int ;_bd bool ;};type SampleReader interface{ReadSample ()(uint32 ,error );ReadSamples (_e []uint32 )error ;};func ResampleUint32 (data []uint32 ,bitsPerInputSample int ,bitsPerOutputSample int )[]uint32 {var _ea []uint32 ;
_ed :=bitsPerOutputSample ;var _cg uint32 ;var _gga uint32 ;_ecc :=0;_dc :=0;_abb :=0;for _abb < len (data ){if _ecc > 0{_db :=_ecc ;if _ed < _db {_db =_ed ;};_cg =(_cg <<uint (_db ))|(_gga >>uint (bitsPerInputSample -_db ));_ecc -=_db ;if _ecc > 0{_gga =_gga <<uint (_db );
}else {_gga =0;};_ed -=_db ;if _ed ==0{_ea =append (_ea ,_cg );_ed =bitsPerOutputSample ;_cg =0;_dc ++;};}else {_bfb :=data [_abb ];_abb ++;_gc :=bitsPerInputSample ;if _ed < _gc {_gc =_ed ;};_ecc =bitsPerInputSample -_gc ;_cg =(_cg <<uint (_gc ))|(_bfb >>uint (_ecc ));
if _gc < bitsPerInputSample {_gga =_bfb <<uint (_gc );};_ed -=_gc ;if _ed ==0{_ea =append (_ea ,_cg );_ed =bitsPerOutputSample ;_cg =0;_dc ++;};};};for _ecc >=bitsPerOutputSample {_fe :=_ecc ;if _ed < _fe {_fe =_ed ;};_cg =(_cg <<uint (_fe ))|(_gga >>uint (bitsPerInputSample -_fe ));
_ecc -=_fe ;if _ecc > 0{_gga =_gga <<uint (_fe );}else {_gga =0;};_ed -=_fe ;if _ed ==0{_ea =append (_ea ,_cg );_ed =bitsPerOutputSample ;_cg =0;_dc ++;};};if _ed > 0&&_ed < bitsPerOutputSample {_cg <<=uint (_ed );_ea =append (_ea ,_cg );};return _ea ;
};func NewReader (img _b .ImageBase )*Reader {return &Reader {_bf :_g .NewReader (img .Data ),_f :img ,_ga :img .ColorComponents ,_bd :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };};func NewWriter (img _b .ImageBase )*Writer {return &Writer {_fg :_g .NewWriterMSB (img .Data ),_bdc :img ,_deg :img .ColorComponents ,_abg :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};func ResampleBytes (data []byte ,bitsPerSample int )[]uint32 {var _bc []uint32 ;_ca :=bitsPerSample ;var _fa uint32 ;var _bdg byte ;_gg :=0;_cab :=0;_eb :=0;for _eb < len (data ){if _gg > 0{_de :=_gg ;if _ca < _de {_de =_ca ;};_fa =(_fa <<uint (_de ))|uint32 (_bdg >>uint (8-_de ));
_gg -=_de ;if _gg > 0{_bdg =_bdg <<uint (_de );}else {_bdg =0;};_ca -=_de ;if _ca ==0{_bc =append (_bc ,_fa );_ca =bitsPerSample ;_fa =0;_cab ++;};}else {_bgd :=data [_eb ];_eb ++;_cac :=8;if _ca < _cac {_cac =_ca ;};_gg =8-_cac ;_fa =(_fa <<uint (_cac ))|uint32 (_bgd >>uint (_gg ));
if _cac < 8{_bdg =_bgd <<uint (_cac );};_ca -=_cac ;if _ca ==0{_bc =append (_bc ,_fa );_ca =bitsPerSample ;_fa =0;_cab ++;};};};for _gg >=bitsPerSample {_ec :=_gg ;if _ca < _ec {_ec =_ca ;};_fa =(_fa <<uint (_ec ))|uint32 (_bdg >>uint (8-_ec ));_gg -=_ec ;
if _gg > 0{_bdg =_bdg <<uint (_ec );}else {_bdg =0;};_ca -=_ec ;if _ca ==0{_bc =append (_bc ,_fa );_ca =bitsPerSample ;_fa =0;_cab ++;};};return _bc ;};