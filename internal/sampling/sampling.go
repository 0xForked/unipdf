//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package sampling ;import (_e "github.com/unidoc/unipdf/v3/internal/bitwise";_g "github.com/unidoc/unipdf/v3/internal/imageutil";_f "io";);type SampleWriter interface{WriteSample (_fbf uint32 )error ;WriteSamples (_ef []uint32 )error ;};func (_ed *Reader )ReadSamples (samples []uint32 )(_fb error ){for _eg :=0;_eg < len (samples );_eg ++{samples [_eg ],_fb =_ed .ReadSample ();if _fb !=nil {return _fb ;};};return nil ;};func NewWriter (img _g .ImageBase )*Writer {return &Writer {_dgg :_e .NewWriterMSB (img .Data ),_dgf :img ,_df :img .ColorComponents ,_de :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };};func ResampleBytes (data []byte ,bitsPerSample int )[]uint32 {var _af []uint32 ;_gbb :=bitsPerSample ;var _b uint32 ;var _bf byte ;_gg :=0;_fa :=0;_cd :=0;for _cd < len (data ){if _gg > 0{_dd :=_gg ;if _gbb < _dd {_dd =_gbb ;};_b =(_b <<uint (_dd ))|uint32 (_bf >>uint (8-_dd ));_gg -=_dd ;if _gg > 0{_bf =_bf <<uint (_dd );}else {_bf =0;};_gbb -=_dd ;if _gbb ==0{_af =append (_af ,_b );_gbb =bitsPerSample ;_b =0;_fa ++;};}else {_gdf :=data [_cd ];_cd ++;_fc :=8;if _gbb < _fc {_fc =_gbb ;};_gg =8-_fc ;_b =(_b <<uint (_fc ))|uint32 (_gdf >>uint (_gg ));if _fc < 8{_bf =_gdf <<uint (_fc );};_gbb -=_fc ;if _gbb ==0{_af =append (_af ,_b );_gbb =bitsPerSample ;_b =0;_fa ++;};};};for _gg >=bitsPerSample {_edd :=_gg ;if _gbb < _edd {_edd =_gbb ;};_b =(_b <<uint (_edd ))|uint32 (_bf >>uint (8-_edd ));_gg -=_edd ;if _gg > 0{_bf =_bf <<uint (_edd );}else {_bf =0;};_gbb -=_edd ;if _gbb ==0{_af =append (_af ,_b );_gbb =bitsPerSample ;_b =0;_fa ++;};};return _af ;};func (_a *Reader )ReadSample ()(uint32 ,error ){if _a ._db ==_a ._dg .Height {return 0,_f .EOF ;};_cf ,_cc :=_a ._gd .ReadBits (byte (_a ._dg .BitsPerComponent ));if _cc !=nil {return 0,_cc ;};_a ._gb --;if _a ._gb ==0{_a ._gb =_a ._dg .ColorComponents ;_a ._ee ++;};if _a ._ee ==_a ._dg .Width {if _a ._ge {_a ._gd .ConsumeRemainingBits ();};_a ._ee =0;_a ._db ++;};return uint32 (_cf ),nil ;};func NewReader (img _g .ImageBase )*Reader {return &Reader {_gd :_e .NewReader (img .Data ),_dg :img ,_gb :img .ColorComponents ,_ge :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };};type Writer struct{_dgf _g .ImageBase ;_dgg *_e .Writer ;_cb ,_df int ;_de bool ;};func ResampleUint32 (data []uint32 ,bitsPerInputSample int ,bitsPerOutputSample int )[]uint32 {var _dgd []uint32 ;_bc :=bitsPerOutputSample ;var _fce uint32 ;var _fad uint32 ;_ab :=0;_abc :=0;_ag :=0;for _ag < len (data ){if _ab > 0{_ae :=_ab ;if _bc < _ae {_ae =_bc ;};_fce =(_fce <<uint (_ae ))|(_fad >>uint (bitsPerInputSample -_ae ));_ab -=_ae ;if _ab > 0{_fad =_fad <<uint (_ae );}else {_fad =0;};_bc -=_ae ;if _bc ==0{_dgd =append (_dgd ,_fce );_bc =bitsPerOutputSample ;_fce =0;_abc ++;};}else {_be :=data [_ag ];_ag ++;_eb :=bitsPerInputSample ;if _bc < _eb {_eb =_bc ;};_ab =bitsPerInputSample -_eb ;_fce =(_fce <<uint (_eb ))|(_be >>uint (_ab ));if _eb < bitsPerInputSample {_fad =_be <<uint (_eb );};_bc -=_eb ;if _bc ==0{_dgd =append (_dgd ,_fce );_bc =bitsPerOutputSample ;_fce =0;_abc ++;};};};for _ab >=bitsPerOutputSample {_ce :=_ab ;if _bc < _ce {_ce =_bc ;};_fce =(_fce <<uint (_ce ))|(_fad >>uint (bitsPerInputSample -_ce ));_ab -=_ce ;if _ab > 0{_fad =_fad <<uint (_ce );}else {_fad =0;};_bc -=_ce ;if _bc ==0{_dgd =append (_dgd ,_fce );_bc =bitsPerOutputSample ;_fce =0;_abc ++;};};if _bc > 0&&_bc < bitsPerOutputSample {_fce <<=uint (_bc );_dgd =append (_dgd ,_fce );};return _dgd ;};func (_gf *Writer )WriteSample (sample uint32 )error {if _ ,_fca :=_gf ._dgg .WriteBits (uint64 (sample ),_gf ._dgf .BitsPerComponent );_fca !=nil {return _fca ;};_gf ._df --;if _gf ._df ==0{_gf ._df =_gf ._dgf .ColorComponents ;_gf ._cb ++;};if _gf ._cb ==_gf ._dgf .Width {if _gf ._de {_gf ._dgg .FinishByte ();};_gf ._cb =0;};return nil ;};func (_eff *Writer )WriteSamples (samples []uint32 )error {for _efb :=0;_efb < len (samples );_efb ++{if _ec :=_eff .WriteSample (samples [_efb ]);_ec !=nil {return _ec ;};};return nil ;};type SampleReader interface{ReadSample ()(uint32 ,error );ReadSamples (_d []uint32 )error ;};type Reader struct{_dg _g .ImageBase ;_gd *_e .Reader ;_ee ,_db ,_gb int ;_ge bool ;};