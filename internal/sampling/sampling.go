//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package sampling ;import (_eb "github.com/unidoc/unipdf/v3/internal/bitwise";_b "github.com/unidoc/unipdf/v3/internal/imageutil";_e "io";);type Reader struct{_f _b .ImageBase ;_a *_eb .Reader ;_c ,_fd ,_ff int ;_ac bool ;};func (_gga *Writer )WriteSamples (samples []uint32 )error {for _dgc :=0;
_dgc < len (samples );_dgc ++{if _cbe :=_gga .WriteSample (samples [_dgc ]);_cbe !=nil {return _cbe ;};};return nil ;};func (_bb *Reader )ReadSamples (samples []uint32 )(_cef error ){for _gg :=0;_gg < len (samples );_gg ++{samples [_gg ],_cef =_bb .ReadSample ();
if _cef !=nil {return _cef ;};};return nil ;};func ResampleUint32 (data []uint32 ,bitsPerInputSample int ,bitsPerOutputSample int )[]uint32 {var _ef []uint32 ;_bg :=bitsPerOutputSample ;var _ceg uint32 ;var _ed uint32 ;_ec :=0;_acg :=0;_ga :=0;for _ga < len (data ){if _ec > 0{_ffbc :=_ec ;
if _bg < _ffbc {_ffbc =_bg ;};_ceg =(_ceg <<uint (_ffbc ))|(_ed >>uint (bitsPerInputSample -_ffbc ));_ec -=_ffbc ;if _ec > 0{_ed =_ed <<uint (_ffbc );}else {_ed =0;};_bg -=_ffbc ;if _bg ==0{_ef =append (_ef ,_ceg );_bg =bitsPerOutputSample ;_ceg =0;_acg ++;
};}else {_acd :=data [_ga ];_ga ++;_dg :=bitsPerInputSample ;if _bg < _dg {_dg =_bg ;};_ec =bitsPerInputSample -_dg ;_ceg =(_ceg <<uint (_dg ))|(_acd >>uint (_ec ));if _dg < bitsPerInputSample {_ed =_acd <<uint (_dg );};_bg -=_dg ;if _bg ==0{_ef =append (_ef ,_ceg );
_bg =bitsPerOutputSample ;_ceg =0;_acg ++;};};};for _ec >=bitsPerOutputSample {_bfa :=_ec ;if _bg < _bfa {_bfa =_bg ;};_ceg =(_ceg <<uint (_bfa ))|(_ed >>uint (bitsPerInputSample -_bfa ));_ec -=_bfa ;if _ec > 0{_ed =_ed <<uint (_bfa );}else {_ed =0;};_bg -=_bfa ;
if _bg ==0{_ef =append (_ef ,_ceg );_bg =bitsPerOutputSample ;_ceg =0;_acg ++;};};if _bg > 0&&_bg < bitsPerOutputSample {_ceg <<=uint (_bg );_ef =append (_ef ,_ceg );};return _ef ;};func (_ce *Reader )ReadSample ()(uint32 ,error ){if _ce ._fd ==_ce ._f .Height {return 0,_e .EOF ;
};_gf ,_gb :=_ce ._a .ReadBits (byte (_ce ._f .BitsPerComponent ));if _gb !=nil {return 0,_gb ;};_ce ._ff --;if _ce ._ff ==0{_ce ._ff =_ce ._f .ColorComponents ;_ce ._c ++;};if _ce ._c ==_ce ._f .Width {if _ce ._ac {_ce ._a .ConsumeRemainingBits ();};_ce ._c =0;
_ce ._fd ++;};return uint32 (_gf ),nil ;};func NewWriter (img _b .ImageBase )*Writer {return &Writer {_fdf :_eb .NewWriterMSB (img .Data ),_bd :img ,_cg :img .ColorComponents ,_ca :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};func ResampleBytes (data []byte ,bitsPerSample int )[]uint32 {var _bf []uint32 ;_dc :=bitsPerSample ;var _fb uint32 ;var _cd byte ;_ffb :=0;_af :=0;_cdf :=0;for _cdf < len (data ){if _ffb > 0{_ag :=_ffb ;if _dc < _ag {_ag =_dc ;};_fb =(_fb <<uint (_ag ))|uint32 (_cd >>uint (8-_ag ));
_ffb -=_ag ;if _ffb > 0{_cd =_cd <<uint (_ag );}else {_cd =0;};_dc -=_ag ;if _dc ==0{_bf =append (_bf ,_fb );_dc =bitsPerSample ;_fb =0;_af ++;};}else {_ad :=data [_cdf ];_cdf ++;_gfg :=8;if _dc < _gfg {_gfg =_dc ;};_ffb =8-_gfg ;_fb =(_fb <<uint (_gfg ))|uint32 (_ad >>uint (_ffb ));
if _gfg < 8{_cd =_ad <<uint (_gfg );};_dc -=_gfg ;if _dc ==0{_bf =append (_bf ,_fb );_dc =bitsPerSample ;_fb =0;_af ++;};};};for _ffb >=bitsPerSample {_cdc :=_ffb ;if _dc < _cdc {_cdc =_dc ;};_fb =(_fb <<uint (_cdc ))|uint32 (_cd >>uint (8-_cdc ));_ffb -=_cdc ;
if _ffb > 0{_cd =_cd <<uint (_cdc );}else {_cd =0;};_dc -=_cdc ;if _dc ==0{_bf =append (_bf ,_fb );_dc =bitsPerSample ;_fb =0;_af ++;};};return _bf ;};type SampleWriter interface{WriteSample (_cb uint32 )error ;WriteSamples (_ee []uint32 )error ;};func NewReader (img _b .ImageBase )*Reader {return &Reader {_a :_eb .NewReader (img .Data ),_f :img ,_ff :img .ColorComponents ,_ac :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};type Writer struct{_bd _b .ImageBase ;_fdf *_eb .Writer ;_bc ,_cg int ;_ca bool ;};func (_gbd *Writer )WriteSample (sample uint32 )error {if _ ,_gc :=_gbd ._fdf .WriteBits (uint64 (sample ),_gbd ._bd .BitsPerComponent );_gc !=nil {return _gc ;};_gbd ._cg --;
if _gbd ._cg ==0{_gbd ._cg =_gbd ._bd .ColorComponents ;_gbd ._bc ++;};if _gbd ._bc ==_gbd ._bd .Width {if _gbd ._ca {_gbd ._fdf .FinishByte ();};_gbd ._bc =0;};return nil ;};type SampleReader interface{ReadSample ()(uint32 ,error );ReadSamples (_g []uint32 )error ;
};