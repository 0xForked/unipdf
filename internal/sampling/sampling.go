//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package sampling ;import (_be "github.com/unidoc/unipdf/v3/internal/bitwise";_e "github.com/unidoc/unipdf/v3/internal/imageutil";_b "io";);func ResampleUint32 (data []uint32 ,bitsPerInputSample int ,bitsPerOutputSample int )[]uint32 {var _bf []uint32 ;
_ab :=bitsPerOutputSample ;var _dg uint32 ;var _ca uint32 ;_fa :=0;_ge :=0;_ef :=0;for _ef < len (data ){if _fa > 0{_ccb :=_fa ;if _ab < _ccb {_ccb =_ab ;};_dg =(_dg <<uint (_ccb ))|(_ca >>uint (bitsPerInputSample -_ccb ));_fa -=_ccb ;if _fa > 0{_ca =_ca <<uint (_ccb );
}else {_ca =0;};_ab -=_ccb ;if _ab ==0{_bf =append (_bf ,_dg );_ab =bitsPerOutputSample ;_dg =0;_ge ++;};}else {_gb :=data [_ef ];_ef ++;_bbb :=bitsPerInputSample ;if _ab < _bbb {_bbb =_ab ;};_fa =bitsPerInputSample -_bbb ;_dg =(_dg <<uint (_bbb ))|(_gb >>uint (_fa ));
if _bbb < bitsPerInputSample {_ca =_gb <<uint (_bbb );};_ab -=_bbb ;if _ab ==0{_bf =append (_bf ,_dg );_ab =bitsPerOutputSample ;_dg =0;_ge ++;};};};for _fa >=bitsPerOutputSample {_cef :=_fa ;if _ab < _cef {_cef =_ab ;};_dg =(_dg <<uint (_cef ))|(_ca >>uint (bitsPerInputSample -_cef ));
_fa -=_cef ;if _fa > 0{_ca =_ca <<uint (_cef );}else {_ca =0;};_ab -=_cef ;if _ab ==0{_bf =append (_bf ,_dg );_ab =bitsPerOutputSample ;_dg =0;_ge ++;};};if _ab > 0&&_ab < bitsPerOutputSample {_dg <<=uint (_ab );_bf =append (_bf ,_dg );};return _bf ;};
type SampleReader interface{ReadSample ()(uint32 ,error );ReadSamples (_d []uint32 )error ;};type Reader struct{_gc _e .ImageBase ;_da *_be .Reader ;_bg ,_gce ,_c int ;_f bool ;};type SampleWriter interface{WriteSample (_ba uint32 )error ;WriteSamples (_gd []uint32 )error ;
};func (_bd *Reader )ReadSamples (samples []uint32 )(_gca error ){for _ea :=0;_ea < len (samples );_ea ++{samples [_ea ],_gca =_bd .ReadSample ();if _gca !=nil {return _gca ;};};return nil ;};func NewReader (img _e .ImageBase )*Reader {return &Reader {_da :_be .NewReader (img .Data ),_gc :img ,_c :img .ColorComponents ,_f :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};func (_gea *Writer )WriteSamples (samples []uint32 )error {for _dd :=0;_dd < len (samples );_dd ++{if _bea :=_gea .WriteSample (samples [_dd ]);_bea !=nil {return _bea ;};};return nil ;};func NewWriter (img _e .ImageBase )*Writer {return &Writer {_eg :_be .NewWriterMSB (img .Data ),_abd :img ,_cf :img .ColorComponents ,_ccg :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};func (_a *Reader )ReadSample ()(uint32 ,error ){if _a ._gce ==_a ._gc .Height {return 0,_b .EOF ;};_bgf ,_ac :=_a ._da .ReadBits (byte (_a ._gc .BitsPerComponent ));if _ac !=nil {return 0,_ac ;};_a ._c --;if _a ._c ==0{_a ._c =_a ._gc .ColorComponents ;
_a ._bg ++;};if _a ._bg ==_a ._gc .Width {if _a ._f {_a ._da .ConsumeRemainingBits ();};_a ._bg =0;_a ._gce ++;};return uint32 (_bgf ),nil ;};type Writer struct{_abd _e .ImageBase ;_eg *_be .Writer ;_faf ,_cf int ;_ccg bool ;};func (_acd *Writer )WriteSample (sample uint32 )error {if _ ,_ec :=_acd ._eg .WriteBits (uint64 (sample ),_acd ._abd .BitsPerComponent );
_ec !=nil {return _ec ;};_acd ._cf --;if _acd ._cf ==0{_acd ._cf =_acd ._abd .ColorComponents ;_acd ._faf ++;};if _acd ._faf ==_acd ._abd .Width {if _acd ._ccg {_acd ._eg .FinishByte ();};_acd ._faf =0;};return nil ;};func ResampleBytes (data []byte ,bitsPerSample int )[]uint32 {var _bb []uint32 ;
_bec :=bitsPerSample ;var _ee uint32 ;var _eb byte ;_ga :=0;_fg :=0;_bef :=0;for _bef < len (data ){if _ga > 0{_ce :=_ga ;if _bec < _ce {_ce =_bec ;};_ee =(_ee <<uint (_ce ))|uint32 (_eb >>uint (8-_ce ));_ga -=_ce ;if _ga > 0{_eb =_eb <<uint (_ce );}else {_eb =0;
};_bec -=_ce ;if _bec ==0{_bb =append (_bb ,_ee );_bec =bitsPerSample ;_ee =0;_fg ++;};}else {_fe :=data [_bef ];_bef ++;_ag :=8;if _bec < _ag {_ag =_bec ;};_ga =8-_ag ;_ee =(_ee <<uint (_ag ))|uint32 (_fe >>uint (_ga ));if _ag < 8{_eb =_fe <<uint (_ag );
};_bec -=_ag ;if _bec ==0{_bb =append (_bb ,_ee );_bec =bitsPerSample ;_ee =0;_fg ++;};};};for _ga >=bitsPerSample {_cc :=_ga ;if _bec < _cc {_cc =_bec ;};_ee =(_ee <<uint (_cc ))|uint32 (_eb >>uint (8-_cc ));_ga -=_cc ;if _ga > 0{_eb =_eb <<uint (_cc );
}else {_eb =0;};_bec -=_cc ;if _bec ==0{_bb =append (_bb ,_ee );_bec =bitsPerSample ;_ee =0;_fg ++;};};return _bb ;};