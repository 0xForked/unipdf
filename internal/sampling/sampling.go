//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package sampling ;import (_gc "github.com/unidoc/unipdf/v3/internal/bitwise";_aa "github.com/unidoc/unipdf/v3/internal/imageutil";_a "io";);func NewReader (img _aa .ImageBase )*Reader {return &Reader {_dg :_gc .NewReader (img .Data ),_gf :img ,_e :img .ColorComponents ,_ba :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};func ResampleUint32 (data []uint32 ,bitsPerInputSample int ,bitsPerOutputSample int )[]uint32 {var _add []uint32 ;_ef :=bitsPerOutputSample ;var _dgd uint32 ;var _cb uint32 ;_af :=0;_fb :=0;_bcc :=0;for _bcc < len (data ){if _af > 0{_ga :=_af ;if _ef < _ga {_ga =_ef ;
};_dgd =(_dgd <<uint (_ga ))|(_cb >>uint (bitsPerInputSample -_ga ));_af -=_ga ;if _af > 0{_cb =_cb <<uint (_ga );}else {_cb =0;};_ef -=_ga ;if _ef ==0{_add =append (_add ,_dgd );_ef =bitsPerOutputSample ;_dgd =0;_fb ++;};}else {_ag :=data [_bcc ];_bcc ++;
_fg :=bitsPerInputSample ;if _ef < _fg {_fg =_ef ;};_af =bitsPerInputSample -_fg ;_dgd =(_dgd <<uint (_fg ))|(_ag >>uint (_af ));if _fg < bitsPerInputSample {_cb =_ag <<uint (_fg );};_ef -=_fg ;if _ef ==0{_add =append (_add ,_dgd );_ef =bitsPerOutputSample ;
_dgd =0;_fb ++;};};};for _af >=bitsPerOutputSample {_gfa :=_af ;if _ef < _gfa {_gfa =_ef ;};_dgd =(_dgd <<uint (_gfa ))|(_cb >>uint (bitsPerInputSample -_gfa ));_af -=_gfa ;if _af > 0{_cb =_cb <<uint (_gfa );}else {_cb =0;};_ef -=_gfa ;if _ef ==0{_add =append (_add ,_dgd );
_ef =bitsPerOutputSample ;_dgd =0;_fb ++;};};if _ef > 0&&_ef < bitsPerOutputSample {_dgd <<=uint (_ef );_add =append (_add ,_dgd );};return _add ;};func NewWriter (img _aa .ImageBase )*Writer {return &Writer {_ec :_gc .NewWriterMSB (img .Data ),_ca :img ,_caf :img .ColorComponents ,_agd :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};type SampleWriter interface{WriteSample (_aag uint32 )error ;WriteSamples (_gac []uint32 )error ;};type SampleReader interface{ReadSample ()(uint32 ,error );ReadSamples (_d []uint32 )error ;};func (_gec *Writer )WriteSample (sample uint32 )error {if _ ,_afb :=_gec ._ec .WriteBits (uint64 (sample ),_gec ._ca .BitsPerComponent );
_afb !=nil {return _afb ;};_gec ._caf --;if _gec ._caf ==0{_gec ._caf =_gec ._ca .ColorComponents ;_gec ._addb ++;};if _gec ._addb ==_gec ._ca .Width {if _gec ._agd {_gec ._ec .FinishByte ();};_gec ._addb =0;};return nil ;};func (_ad *Reader )ReadSample ()(uint32 ,error ){if _ad ._ge ==_ad ._gf .Height {return 0,_a .EOF ;
};_bc ,_dd :=_ad ._dg .ReadBits (byte (_ad ._gf .BitsPerComponent ));if _dd !=nil {return 0,_dd ;};_ad ._e --;if _ad ._e ==0{_ad ._e =_ad ._gf .ColorComponents ;_ad ._b ++;};if _ad ._b ==_ad ._gf .Width {if _ad ._ba {_ad ._dg .ConsumeRemainingBits ();};
_ad ._b =0;_ad ._ge ++;};return uint32 (_bc ),nil ;};type Writer struct{_ca _aa .ImageBase ;_ec *_gc .Writer ;_addb ,_caf int ;_agd bool ;};func ResampleBytes (data []byte ,bitsPerSample int )[]uint32 {var _dgg []uint32 ;_ea :=bitsPerSample ;var _dc uint32 ;
var _cf byte ;_dga :=0;_ed :=0;_ede :=0;for _ede < len (data ){if _dga > 0{_gfb :=_dga ;if _ea < _gfb {_gfb =_ea ;};_dc =(_dc <<uint (_gfb ))|uint32 (_cf >>uint (8-_gfb ));_dga -=_gfb ;if _dga > 0{_cf =_cf <<uint (_gfb );}else {_cf =0;};_ea -=_gfb ;if _ea ==0{_dgg =append (_dgg ,_dc );
_ea =bitsPerSample ;_dc =0;_ed ++;};}else {_f :=data [_ede ];_ede ++;_gg :=8;if _ea < _gg {_gg =_ea ;};_dga =8-_gg ;_dc =(_dc <<uint (_gg ))|uint32 (_f >>uint (_dga ));if _gg < 8{_cf =_f <<uint (_gg );};_ea -=_gg ;if _ea ==0{_dgg =append (_dgg ,_dc );_ea =bitsPerSample ;
_dc =0;_ed ++;};};};for _dga >=bitsPerSample {_ggd :=_dga ;if _ea < _ggd {_ggd =_ea ;};_dc =(_dc <<uint (_ggd ))|uint32 (_cf >>uint (8-_ggd ));_dga -=_ggd ;if _dga > 0{_cf =_cf <<uint (_ggd );}else {_cf =0;};_ea -=_ggd ;if _ea ==0{_dgg =append (_dgg ,_dc );
_ea =bitsPerSample ;_dc =0;_ed ++;};};return _dgg ;};func (_adb *Reader )ReadSamples (samples []uint32 )(_c error ){for _bd :=0;_bd < len (samples );_bd ++{samples [_bd ],_c =_adb .ReadSample ();if _c !=nil {return _c ;};};return nil ;};func (_be *Writer )WriteSamples (samples []uint32 )error {for _agdb :=0;
_agdb < len (samples );_agdb ++{if _cbf :=_be .WriteSample (samples [_agdb ]);_cbf !=nil {return _cbf ;};};return nil ;};type Reader struct{_gf _aa .ImageBase ;_dg *_gc .Reader ;_b ,_ge ,_e int ;_ba bool ;};