//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package sampling ;import (_d "github.com/unidoc/unipdf/v3/internal/bitwise";_b "github.com/unidoc/unipdf/v3/internal/imageutil";_e "io";);func ResampleUint32 (data []uint32 ,bitsPerInputSample int ,bitsPerOutputSample int )[]uint32 {var _ec []uint32 ;_dee :=bitsPerOutputSample ;var _ce uint32 ;var _af uint32 ;_fff :=0;_ab :=0;_dfc :=0;for _dfc < len (data ){if _fff > 0{_ed :=_fff ;if _dee < _ed {_ed =_dee ;};_ce =(_ce <<uint (_ed ))|uint32 (_af >>uint (bitsPerInputSample -_ed ));_fff -=_ed ;if _fff > 0{_af =_af <<uint (_ed );}else {_af =0;};_dee -=_ed ;if _dee ==0{_ec =append (_ec ,_ce );_dee =bitsPerOutputSample ;_ce =0;_ab ++;};}else {_gad :=data [_dfc ];_dfc ++;_fd :=bitsPerInputSample ;if _dee < _fd {_fd =_dee ;};_fff =bitsPerInputSample -_fd ;_ce =(_ce <<uint (_fd ))|uint32 (_gad >>uint (_fff ));if _fd < bitsPerInputSample {_af =_gad <<uint (_fd );};_dee -=_fd ;if _dee ==0{_ec =append (_ec ,_ce );_dee =bitsPerOutputSample ;_ce =0;_ab ++;};};};for _fff >=bitsPerOutputSample {_eb :=_fff ;if _dee < _eb {_eb =_dee ;};_ce =(_ce <<uint (_eb ))|uint32 (_af >>uint (bitsPerInputSample -_eb ));_fff -=_eb ;if _fff > 0{_af =_af <<uint (_eb );}else {_af =0;};_dee -=_eb ;if _dee ==0{_ec =append (_ec ,_ce );_dee =bitsPerOutputSample ;_ce =0;_ab ++;};};if _dee > 0&&_dee < bitsPerOutputSample {_ce <<=uint (_dee );_ec =append (_ec ,_ce );};return _ec ;};func NewWriter (img _b .ImageBase )*Writer {return &Writer {_eg :_d .NewWriterMSB (img .Data ),_aea :img ,_cd :img .ColorComponents ,_cg :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };};func ResampleBytes (data []byte ,bitsPerSample int )[]uint32 {var _gg []uint32 ;_gfd :=bitsPerSample ;var _dc uint32 ;var _bd byte ;_gff :=0;_dd :=0;_df :=0;for _df < len (data ){if _gff > 0{_ae :=_gff ;if _gfd < _ae {_ae =_gfd ;};_dc =(_dc <<uint (_ae ))|uint32 (_bd >>uint (8-_ae ));_gff -=_ae ;if _gff > 0{_bd =_bd <<uint (_ae );}else {_bd =0;};_gfd -=_ae ;if _gfd ==0{_gg =append (_gg ,_dc );_gfd =bitsPerSample ;_dc =0;_dd ++;};}else {_gcc :=data [_df ];_df ++;_gd :=8;if _gfd < _gd {_gd =_gfd ;};_gff =8-_gd ;_dc =(_dc <<uint (_gd ))|uint32 (_gcc >>uint (_gff ));if _gd < 8{_bd =_gcc <<uint (_gd );};_gfd -=_gd ;if _gfd ==0{_gg =append (_gg ,_dc );_gfd =bitsPerSample ;_dc =0;_dd ++;};};};for _gff >=bitsPerSample {_fa :=_gff ;if _gfd < _fa {_fa =_gfd ;};_dc =(_dc <<uint (_fa ))|uint32 (_bd >>uint (8-_fa ));_gff -=_fa ;if _gff > 0{_bd =_bd <<uint (_fa );}else {_bd =0;};_gfd -=_fa ;if _gfd ==0{_gg =append (_gg ,_dc );_gfd =bitsPerSample ;_dc =0;_dd ++;};};return _gg ;};func (_gcd *Writer )WriteSamples (samples []uint32 )error {for _cea :=0;_cea < len (samples );_cea ++{if _gab :=_gcd .WriteSample (samples [_cea ]);_gab !=nil {return _gab ;};};return nil ;};func (_ff *Reader )ReadSample ()(uint32 ,error ){if _ff ._eae ==_ff ._c .Height {return 0,_e .EOF ;};_ga ,_gb :=_ff ._g .ReadBits (byte (_ff ._c .BitsPerComponent ));if _gb !=nil {return 0,_gb ;};_ff ._gc --;if _ff ._gc ==0{_ff ._gc =_ff ._c .ColorComponents ;_ff ._gf ++;};if _ff ._gf ==_ff ._c .Width {if _ff ._de {_ff ._g .ConsumeRemainingBits ();};_ff ._gf =0;_ff ._eae ++;};return uint32 (_ga ),nil ;};type SampleReader interface{ReadSample ()(uint32 ,error );ReadSamples (_ea []uint32 )error ;};func (_bg *Writer )WriteSample (sample uint32 )error {if _ ,_cfa :=_bg ._eg .WriteBits (uint64 (sample ),_bg ._aea .BitsPerComponent );_cfa !=nil {return _cfa ;};_bg ._cd --;if _bg ._cd ==0{_bg ._cd =_bg ._aea .ColorComponents ;_bg ._ffg ++;};if _bg ._ffg ==_bg ._aea .Width {if _bg ._cg {_bg ._eg .FinishByte ();};_bg ._ffg =0;};return nil ;};type Writer struct{_aea _b .ImageBase ;_eg *_d .Writer ;_ffg ,_cd int ;_cg bool ;};type Reader struct{_c _b .ImageBase ;_g *_d .Reader ;_gf ,_eae ,_gc int ;_de bool ;};func (_ca *Reader )ReadSamples (samples []uint32 )(_a error ){for _db :=0;_db < len (samples );_db ++{samples [_db ],_a =_ca .ReadSample ();if _a !=nil {return _a ;};};return nil ;};func NewReader (img _b .ImageBase )*Reader {return &Reader {_g :_d .NewReader (img .Data ),_c :img ,_gc :img .ColorComponents ,_de :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };};type SampleWriter interface{WriteSample (_cf uint32 )error ;WriteSamples (_gffe []uint32 )error ;};