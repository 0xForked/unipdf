//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package sampling ;import (_e "github.com/unidoc/unipdf/v3/internal/bitwise";_g "github.com/unidoc/unipdf/v3/internal/imageutil";_f "io";);func ResampleBytes (data []byte ,bitsPerSample int )[]uint32 {var _c []uint32 ;_gd :=bitsPerSample ;var _gg uint32 ;
var _bb byte ;_bc :=0;_ga :=0;_ef :=0;for _ef < len (data ){if _bc > 0{_cg :=_bc ;if _gd < _cg {_cg =_gd ;};_gg =(_gg <<uint (_cg ))|uint32 (_bb >>uint (8-_cg ));_bc -=_cg ;if _bc > 0{_bb =_bb <<uint (_cg );}else {_bb =0;};_gd -=_cg ;if _gd ==0{_c =append (_c ,_gg );
_gd =bitsPerSample ;_gg =0;_ga ++;};}else {_eg :=data [_ef ];_ef ++;_bfc :=8;if _gd < _bfc {_bfc =_gd ;};_bc =8-_bfc ;_gg =(_gg <<uint (_bfc ))|uint32 (_eg >>uint (_bc ));if _bfc < 8{_bb =_eg <<uint (_bfc );};_gd -=_bfc ;if _gd ==0{_c =append (_c ,_gg );
_gd =bitsPerSample ;_gg =0;_ga ++;};};};for _bc >=bitsPerSample {_ee :=_bc ;if _gd < _ee {_ee =_gd ;};_gg =(_gg <<uint (_ee ))|uint32 (_bb >>uint (8-_ee ));_bc -=_ee ;if _bc > 0{_bb =_bb <<uint (_ee );}else {_bb =0;};_gd -=_ee ;if _gd ==0{_c =append (_c ,_gg );
_gd =bitsPerSample ;_gg =0;_ga ++;};};return _c ;};type Reader struct{_dd _g .ImageBase ;_a *_e .Reader ;_b ,_ed ,_af int ;_ff bool ;};type SampleWriter interface{WriteSample (_fg uint32 )error ;WriteSamples (_be []uint32 )error ;};func NewWriter (img _g .ImageBase )*Writer {return &Writer {_gae :_e .NewWriterMSB (img .Data ),_fbd :img ,_fd :img .ColorComponents ,_fdd :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};func NewReader (img _g .ImageBase )*Reader {return &Reader {_a :_e .NewReader (img .Data ),_dd :img ,_af :img .ColorComponents ,_ff :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };};func (_dc *Writer )WriteSample (sample uint32 )error {if _ ,_eb :=_dc ._gae .WriteBits (uint64 (sample ),_dc ._fbd .BitsPerComponent );
_eb !=nil {return _eb ;};_dc ._fd --;if _dc ._fd ==0{_dc ._fd =_dc ._fbd .ColorComponents ;_dc ._db ++;};if _dc ._db ==_dc ._fbd .Width {if _dc ._fdd {_dc ._gae .FinishByte ();};_dc ._db =0;};return nil ;};func (_afa *Reader )ReadSamples (samples []uint32 )(_afac error ){for _bf :=0;
_bf < len (samples );_bf ++{samples [_bf ],_afac =_afa .ReadSample ();if _afac !=nil {return _afac ;};};return nil ;};func (_fa *Reader )ReadSample ()(uint32 ,error ){if _fa ._ed ==_fa ._dd .Height {return 0,_f .EOF ;};_gb ,_fb :=_fa ._a .ReadBits (byte (_fa ._dd .BitsPerComponent ));
if _fb !=nil {return 0,_fb ;};_fa ._af --;if _fa ._af ==0{_fa ._af =_fa ._dd .ColorComponents ;_fa ._b ++;};if _fa ._b ==_fa ._dd .Width {if _fa ._ff {_fa ._a .ConsumeRemainingBits ();};_fa ._b =0;_fa ._ed ++;};return uint32 (_gb ),nil ;};type SampleReader interface{ReadSample ()(uint32 ,error );
ReadSamples (_fe []uint32 )error ;};type Writer struct{_fbd _g .ImageBase ;_gae *_e .Writer ;_db ,_fd int ;_fdd bool ;};func (_bee *Writer )WriteSamples (samples []uint32 )error {for _cd :=0;_cd < len (samples );_cd ++{if _ccc :=_bee .WriteSample (samples [_cd ]);
_ccc !=nil {return _ccc ;};};return nil ;};func ResampleUint32 (data []uint32 ,bitsPerInputSample int ,bitsPerOutputSample int )[]uint32 {var _ad []uint32 ;_cge :=bitsPerOutputSample ;var _bbe uint32 ;var _bd uint32 ;_fc :=0;_aa :=0;_bcb :=0;for _bcb < len (data ){if _fc > 0{_edg :=_fc ;
if _cge < _edg {_edg =_cge ;};_bbe =(_bbe <<uint (_edg ))|(_bd >>uint (bitsPerInputSample -_edg ));_fc -=_edg ;if _fc > 0{_bd =_bd <<uint (_edg );}else {_bd =0;};_cge -=_edg ;if _cge ==0{_ad =append (_ad ,_bbe );_cge =bitsPerOutputSample ;_bbe =0;_aa ++;
};}else {_fbc :=data [_bcb ];_bcb ++;_edb :=bitsPerInputSample ;if _cge < _edb {_edb =_cge ;};_fc =bitsPerInputSample -_edb ;_bbe =(_bbe <<uint (_edb ))|(_fbc >>uint (_fc ));if _edb < bitsPerInputSample {_bd =_fbc <<uint (_edb );};_cge -=_edb ;if _cge ==0{_ad =append (_ad ,_bbe );
_cge =bitsPerOutputSample ;_bbe =0;_aa ++;};};};for _fc >=bitsPerOutputSample {_cc :=_fc ;if _cge < _cc {_cc =_cge ;};_bbe =(_bbe <<uint (_cc ))|(_bd >>uint (bitsPerInputSample -_cc ));_fc -=_cc ;if _fc > 0{_bd =_bd <<uint (_cc );}else {_bd =0;};_cge -=_cc ;
if _cge ==0{_ad =append (_ad ,_bbe );_cge =bitsPerOutputSample ;_bbe =0;_aa ++;};};if _cge > 0&&_cge < bitsPerOutputSample {_bbe <<=uint (_cge );_ad =append (_ad ,_bbe );};return _ad ;};