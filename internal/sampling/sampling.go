//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package sampling ;import (_bf "github.com/unidoc/unipdf/v3/internal/bitwise";_c "github.com/unidoc/unipdf/v3/internal/imageutil";_b "io";);func NewWriter (img _c .ImageBase )*Writer {return &Writer {_fg :_bf .NewWriterMSB (img .Data ),_acgf :img ,_ced :img .ColorComponents ,_fbd :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };};func (_ebe *Reader )ReadSamples (samples []uint32 )(_ef error ){for _cdd :=0;_cdd < len (samples );_cdd ++{samples [_cdd ],_ef =_ebe .ReadSample ();if _ef !=nil {return _ef ;};};return nil ;};type Writer struct{_acgf _c .ImageBase ;_fg *_bf .Writer ;_fb ,_ced int ;_fbd bool ;};func NewReader (img _c .ImageBase )*Reader {return &Reader {_ce :_bf .NewReader (img .Data ),_e :img ,_a :img .ColorComponents ,_de :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };};func (_acf *Writer )WriteSamples (samples []uint32 )error {for _dee :=0;_dee < len (samples );_dee ++{if _aac :=_acf .WriteSample (samples [_dee ]);_aac !=nil {return _aac ;};};return nil ;};type SampleReader interface{ReadSample ()(uint32 ,error );ReadSamples (_d []uint32 )error ;};func (_ac *Reader )ReadSample ()(uint32 ,error ){if _ac ._bc ==_ac ._e .Height {return 0,_b .EOF ;};_cd ,_ea :=_ac ._ce .ReadBits (byte (_ac ._e .BitsPerComponent ));if _ea !=nil {return 0,_ea ;};_ac ._a --;if _ac ._a ==0{_ac ._a =_ac ._e .ColorComponents ;_ac ._eb ++;};if _ac ._eb ==_ac ._e .Width {if _ac ._de {_ac ._ce .ConsumeRemainingBits ();};_ac ._eb =0;_ac ._bc ++;};return uint32 (_cd ),nil ;};func ResampleUint32 (data []uint32 ,bitsPerInputSample int ,bitsPerOutputSample int )[]uint32 {var _gdb []uint32 ;_bd :=bitsPerOutputSample ;var _bca uint32 ;var _bff uint32 ;_eaf :=0;_ge :=0;_gf :=0;for _gf < len (data ){if _eaf > 0{_ed :=_eaf ;if _bd < _ed {_ed =_bd ;};_bca =(_bca <<uint (_ed ))|(_bff >>uint (bitsPerInputSample -_ed ));_eaf -=_ed ;if _eaf > 0{_bff =_bff <<uint (_ed );}else {_bff =0;};_bd -=_ed ;if _bd ==0{_gdb =append (_gdb ,_bca );_bd =bitsPerOutputSample ;_bca =0;_ge ++;};}else {_edg :=data [_gf ];_gf ++;_acg :=bitsPerInputSample ;if _bd < _acg {_acg =_bd ;};_eaf =bitsPerInputSample -_acg ;_bca =(_bca <<uint (_acg ))|(_edg >>uint (_eaf ));if _acg < bitsPerInputSample {_bff =_edg <<uint (_acg );};_bd -=_acg ;if _bd ==0{_gdb =append (_gdb ,_bca );_bd =bitsPerOutputSample ;_bca =0;_ge ++;};};};for _eaf >=bitsPerOutputSample {_bfg :=_eaf ;if _bd < _bfg {_bfg =_bd ;};_bca =(_bca <<uint (_bfg ))|(_bff >>uint (bitsPerInputSample -_bfg ));_eaf -=_bfg ;if _eaf > 0{_bff =_bff <<uint (_bfg );}else {_bff =0;};_bd -=_bfg ;if _bd ==0{_gdb =append (_gdb ,_bca );_bd =bitsPerOutputSample ;_bca =0;_ge ++;};};if _bd > 0&&_bd < bitsPerOutputSample {_bca <<=uint (_bd );_gdb =append (_gdb ,_bca );};return _gdb ;};type Reader struct{_e _c .ImageBase ;_ce *_bf .Reader ;_eb ,_bc ,_a int ;_de bool ;};func ResampleBytes (data []byte ,bitsPerSample int )[]uint32 {var _gc []uint32 ;_da :=bitsPerSample ;var _gd uint32 ;var _f byte ;_ec :=0;_cb :=0;_gcb :=0;for _gcb < len (data ){if _ec > 0{_cdde :=_ec ;if _da < _cdde {_cdde =_da ;};_gd =(_gd <<uint (_cdde ))|uint32 (_f >>uint (8-_cdde ));_ec -=_cdde ;if _ec > 0{_f =_f <<uint (_cdde );}else {_f =0;};_da -=_cdde ;if _da ==0{_gc =append (_gc ,_gd );_da =bitsPerSample ;_gd =0;_cb ++;};}else {_af :=data [_gcb ];_gcb ++;_dae :=8;if _da < _dae {_dae =_da ;};_ec =8-_dae ;_gd =(_gd <<uint (_dae ))|uint32 (_af >>uint (_ec ));if _dae < 8{_f =_af <<uint (_dae );};_da -=_dae ;if _da ==0{_gc =append (_gc ,_gd );_da =bitsPerSample ;_gd =0;_cb ++;};};};for _ec >=bitsPerSample {_aa :=_ec ;if _da < _aa {_aa =_da ;};_gd =(_gd <<uint (_aa ))|uint32 (_f >>uint (8-_aa ));_ec -=_aa ;if _ec > 0{_f =_f <<uint (_aa );}else {_f =0;};_da -=_aa ;if _da ==0{_gc =append (_gc ,_gd );_da =bitsPerSample ;_gd =0;_cb ++;};};return _gc ;};type SampleWriter interface{WriteSample (_ga uint32 )error ;WriteSamples (_fd []uint32 )error ;};func (_ecg *Writer )WriteSample (sample uint32 )error {if _ ,_afa :=_ecg ._fg .WriteBits (uint64 (sample ),_ecg ._acgf .BitsPerComponent );_afa !=nil {return _afa ;};_ecg ._ced --;if _ecg ._ced ==0{_ecg ._ced =_ecg ._acgf .ColorComponents ;_ecg ._fb ++;};if _ecg ._fb ==_ecg ._acgf .Width {if _ecg ._fbd {_ecg ._fg .FinishByte ();};_ecg ._fb =0;};return nil ;};