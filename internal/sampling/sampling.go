//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package sampling ;import (_b "github.com/unidoc/unipdf/v3/internal/bitwise";_bc "github.com/unidoc/unipdf/v3/internal/imageutil";_ad "io";);func ResampleBytes (data []byte ,bitsPerSample int )[]uint32 {var _ebf []uint32 ;_bg :=bitsPerSample ;var _be uint32 ;
var _dc byte ;_fc :=0;_ba :=0;_ebeb :=0;for _ebeb < len (data ){if _fc > 0{_ag :=_fc ;if _bg < _ag {_ag =_bg ;};_be =(_be <<uint (_ag ))|uint32 (_dc >>uint (8-_ag ));_fc -=_ag ;if _fc > 0{_dc =_dc <<uint (_ag );}else {_dc =0;};_bg -=_ag ;if _bg ==0{_ebf =append (_ebf ,_be );
_bg =bitsPerSample ;_be =0;_ba ++;};}else {_ebg :=data [_ebeb ];_ebeb ++;_cd :=8;if _bg < _cd {_cd =_bg ;};_fc =8-_cd ;_be =(_be <<uint (_cd ))|uint32 (_ebg >>uint (_fc ));if _cd < 8{_dc =_ebg <<uint (_cd );};_bg -=_cd ;if _bg ==0{_ebf =append (_ebf ,_be );
_bg =bitsPerSample ;_be =0;_ba ++;};};};for _fc >=bitsPerSample {_cg :=_fc ;if _bg < _cg {_cg =_bg ;};_be =(_be <<uint (_cg ))|uint32 (_dc >>uint (8-_cg ));_fc -=_cg ;if _fc > 0{_dc =_dc <<uint (_cg );}else {_dc =0;};_bg -=_cg ;if _bg ==0{_ebf =append (_ebf ,_be );
_bg =bitsPerSample ;_be =0;_ba ++;};};return _ebf ;};func NewReader (img _bc .ImageBase )*Reader {return &Reader {_g :_b .NewReader (img .Data ),_ac :img ,_eb :img .ColorComponents ,_ee :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};func (_agd *Writer )WriteSample (sample uint32 )error {if _ ,_gf :=_agd ._adc .WriteBits (uint64 (sample ),_agd ._fa .BitsPerComponent );_gf !=nil {return _gf ;};_agd ._ab --;if _agd ._ab ==0{_agd ._ab =_agd ._fa .ColorComponents ;_agd ._eba ++;};if _agd ._eba ==_agd ._fa .Width {if _agd ._ca {_agd ._adc .FinishByte ();
};_agd ._eba =0;};return nil ;};func (_ed *Reader )ReadSample ()(uint32 ,error ){if _ed ._e ==_ed ._ac .Height {return 0,_ad .EOF ;};_gc ,_f :=_ed ._g .ReadBits (byte (_ed ._ac .BitsPerComponent ));if _f !=nil {return 0,_f ;};_ed ._eb --;if _ed ._eb ==0{_ed ._eb =_ed ._ac .ColorComponents ;
_ed ._d ++;};if _ed ._d ==_ed ._ac .Width {if _ed ._ee {_ed ._g .ConsumeRemainingBits ();};_ed ._d =0;_ed ._e ++;};return uint32 (_gc ),nil ;};func (_de *Reader )ReadSamples (samples []uint32 )(_ebe error ){for _c :=0;_c < len (samples );_c ++{samples [_c ],_ebe =_de .ReadSample ();
if _ebe !=nil {return _ebe ;};};return nil ;};type Reader struct{_ac _bc .ImageBase ;_g *_b .Reader ;_d ,_e ,_eb int ;_ee bool ;};type SampleReader interface{ReadSample ()(uint32 ,error );ReadSamples (_bf []uint32 )error ;};type SampleWriter interface{WriteSample (_db uint32 )error ;
WriteSamples (_ef []uint32 )error ;};type Writer struct{_fa _bc .ImageBase ;_adc *_b .Writer ;_eba ,_ab int ;_ca bool ;};func ResampleUint32 (data []uint32 ,bitsPerInputSample int ,bitsPerOutputSample int )[]uint32 {var _bcg []uint32 ;_bae :=bitsPerOutputSample ;
var _fcg uint32 ;var _dg uint32 ;_fb :=0;_cc :=0;_ge :=0;for _ge < len (data ){if _fb > 0{_bce :=_fb ;if _bae < _bce {_bce =_bae ;};_fcg =(_fcg <<uint (_bce ))|(_dg >>uint (bitsPerInputSample -_bce ));_fb -=_bce ;if _fb > 0{_dg =_dg <<uint (_bce );}else {_dg =0;
};_bae -=_bce ;if _bae ==0{_bcg =append (_bcg ,_fcg );_bae =bitsPerOutputSample ;_fcg =0;_cc ++;};}else {_gca :=data [_ge ];_ge ++;_deg :=bitsPerInputSample ;if _bae < _deg {_deg =_bae ;};_fb =bitsPerInputSample -_deg ;_fcg =(_fcg <<uint (_deg ))|(_gca >>uint (_fb ));
if _deg < bitsPerInputSample {_dg =_gca <<uint (_deg );};_bae -=_deg ;if _bae ==0{_bcg =append (_bcg ,_fcg );_bae =bitsPerOutputSample ;_fcg =0;_cc ++;};};};for _fb >=bitsPerOutputSample {_fe :=_fb ;if _bae < _fe {_fe =_bae ;};_fcg =(_fcg <<uint (_fe ))|(_dg >>uint (bitsPerInputSample -_fe ));
_fb -=_fe ;if _fb > 0{_dg =_dg <<uint (_fe );}else {_dg =0;};_bae -=_fe ;if _bae ==0{_bcg =append (_bcg ,_fcg );_bae =bitsPerOutputSample ;_fcg =0;_cc ++;};};if _bae > 0&&_bae < bitsPerOutputSample {_fcg <<=uint (_bae );_bcg =append (_bcg ,_fcg );};return _bcg ;
};func NewWriter (img _bc .ImageBase )*Writer {return &Writer {_adc :_b .NewWriterMSB (img .Data ),_fa :img ,_ab :img .ColorComponents ,_ca :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };};func (_bb *Writer )WriteSamples (samples []uint32 )error {for _cb :=0;
_cb < len (samples );_cb ++{if _gb :=_bb .WriteSample (samples [_cb ]);_gb !=nil {return _gb ;};};return nil ;};