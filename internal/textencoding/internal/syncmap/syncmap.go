//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package syncmap ;import _a "sync";func (_aa *RuneSet )Write (r rune ){_aa ._cc .Lock ();defer _aa ._cc .Unlock ();_aa ._afd [r ]=struct{}{}};type RuneStringMap struct{_cg map[rune ]string ;_gd _a .RWMutex ;};func (_dddd *RuneUint16Map )Length ()int {_dddd ._bff .RLock ();
defer _dddd ._bff .RUnlock ();return len (_dddd ._fa );};func (_bbd *RuneStringMap )Length ()int {_bbd ._gd .RLock ();defer _bbd ._gd .RUnlock ();return len (_bbd ._cg );};func (_aac *RuneUint16Map )Range (f func (_add rune ,_fac uint16 )(_bfc bool )){_aac ._bff .RLock ();
defer _aac ._bff .RUnlock ();for _cdb ,_afda :=range _aac ._fa {if f (_cdb ,_afda ){break ;};};};func (_adb *StringsMap )Range (f func (_adaf ,_eab string )(_gac bool )){_adb ._dce .RLock ();defer _adb ._dce .RUnlock ();for _abc ,_fba :=range _adb ._dbbc {if f (_abc ,_fba ){break ;
};};};func MakeRuneSet (length int )*RuneSet {return &RuneSet {_afd :make (map[rune ]struct{},length )}};func (_bc *RuneUint16Map )Delete (r rune ){_bc ._bff .Lock ();defer _bc ._bff .Unlock ();delete (_bc ._fa ,r );};func NewByteRuneMap (m map[byte ]rune )*ByteRuneMap {return &ByteRuneMap {_d :m }};
func (_fb *ByteRuneMap )Length ()int {_fb ._e .RLock ();defer _fb ._e .RUnlock ();return len (_fb ._d )};func (_ad *RuneByteMap )Read (r rune )(byte ,bool ){_ad ._dg .RLock ();defer _ad ._dg .RUnlock ();_cb ,_cbd :=_ad ._aff [r ];return _cb ,_cbd ;};func MakeRuneByteMap (length int )*RuneByteMap {_db :=make (map[rune ]byte ,length );
return &RuneByteMap {_aff :_db };};func (_gf *RuneSet )Range (f func (_ge rune )(_ef bool )){_gf ._cc .RLock ();defer _gf ._cc .RUnlock ();for _dbb :=range _gf ._afd {if f (_dbb ){break ;};};};func (_abb *RuneStringMap )Write (r rune ,s string ){_abb ._gd .Lock ();
defer _abb ._gd .Unlock ();_abb ._cg [r ]=s ;};func (_geg *RuneUint16Map )Read (r rune )(uint16 ,bool ){_geg ._bff .RLock ();defer _geg ._bff .RUnlock ();_dd ,_ddd :=_geg ._fa [r ];return _dd ,_ddd ;};func NewRuneStringMap (m map[rune ]string )*RuneStringMap {return &RuneStringMap {_cg :m }};
func (_dc *RuneSet )Exists (r rune )bool {_dc ._cc .RLock ();defer _dc ._cc .RUnlock ();_ ,_ab :=_dc ._afd [r ];return _ab ;};type StringRuneMap struct{_bbf map[string ]rune ;_gdd _a .RWMutex ;};func (_eb *RuneSet )Length ()int {_eb ._cc .RLock ();defer _eb ._cc .RUnlock ();
return len (_eb ._afd )};func (_bab *StringRuneMap )Read (g string )(rune ,bool ){_bab ._gdd .RLock ();defer _bab ._gdd .RUnlock ();_ff ,_gee :=_bab ._bbf [g ];return _ff ,_gee ;};func (_dbg *StringsMap )Write (g1 ,g2 string ){_dbg ._dce .Lock ();defer _dbg ._dce .Unlock ();
_dbg ._dbbc [g1 ]=g2 ;};func (_gg *RuneByteMap )Length ()int {_gg ._dg .RLock ();defer _gg ._dg .RUnlock ();return len (_gg ._aff )};func (_gdf *RuneStringMap )Read (r rune )(string ,bool ){_gdf ._gd .RLock ();defer _gdf ._gd .RUnlock ();_egc ,_bf :=_gdf ._cg [r ];
return _egc ,_bf ;};func NewStringsMap (tuples []StringsTuple )*StringsMap {_cdg :=map[string ]string {};for _ ,_cgb :=range tuples {_cdg [_cgb .Key ]=_cgb .Value ;};return &StringsMap {_dbbc :_cdg };};func (_fd *ByteRuneMap )Range (f func (_fg byte ,_gb rune )(_eg bool )){_fd ._e .RLock ();
defer _fd ._e .RUnlock ();for _gc ,_ga :=range _fd ._d {if f (_gc ,_ga ){break ;};};};func (_dac *StringsMap )Copy ()*StringsMap {_dac ._dce .RLock ();defer _dac ._dce .RUnlock ();_abd :=map[string ]string {};for _cbb ,_dgg :=range _dac ._dbbc {_abd [_cbb ]=_dgg ;
};return &StringsMap {_dbbc :_abd };};type StringsMap struct{_dbbc map[string ]string ;_dce _a .RWMutex ;};func (_ae *RuneUint16Map )Write (r rune ,g uint16 ){_ae ._bff .Lock ();defer _ae ._bff .Unlock ();_ae ._fa [r ]=g ;};func MakeRuneUint16Map (length int )*RuneUint16Map {return &RuneUint16Map {_fa :make (map[rune ]uint16 ,length )};
};type StringsTuple struct{Key ,Value string ;};func (_f *ByteRuneMap )Read (b byte )(rune ,bool ){_f ._e .RLock ();defer _f ._e .RUnlock ();_c ,_ac :=_f ._d [b ];return _c ,_ac ;};func (_fff *StringRuneMap )Write (g string ,r rune ){_fff ._gdd .Lock ();
defer _fff ._gdd .Unlock ();_fff ._bbf [g ]=r ;};func (_af *ByteRuneMap )Write (b byte ,r rune ){_af ._e .Lock ();defer _af ._e .Unlock ();_af ._d [b ]=r };func MakeByteRuneMap (length int )*ByteRuneMap {return &ByteRuneMap {_d :make (map[byte ]rune ,length )}};
func (_ada *RuneUint16Map )RangeDelete (f func (_ddf rune ,_cfd uint16 )(_da bool ,_dcg bool )){_ada ._bff .Lock ();defer _ada ._bff .Unlock ();for _ed ,_gab :=range _ada ._fa {_cgf ,_afa :=f (_ed ,_gab );if _cgf {delete (_ada ._fa ,_ed );};if _afa {break ;
};};};func (_ce *RuneByteMap )Write (r rune ,b byte ){_ce ._dg .Lock ();defer _ce ._dg .Unlock ();_ce ._aff [r ]=b ;};func (_dddda *StringRuneMap )Length ()int {_dddda ._gdd .RLock ();defer _dddda ._gdd .RUnlock ();return len (_dddda ._bbf );};func (_fdg *StringsMap )Read (g string )(string ,bool ){_fdg ._dce .RLock ();
defer _fdg ._dce .RUnlock ();_egf ,_dbbf :=_fdg ._dbbc [g ];return _egf ,_dbbf ;};type RuneByteMap struct{_aff map[rune ]byte ;_dg _a .RWMutex ;};func NewStringRuneMap (m map[string ]rune )*StringRuneMap {return &StringRuneMap {_bbf :m }};func (_efb *StringRuneMap )Range (f func (_ea string ,_bfd rune )(_fe bool )){_efb ._gdd .RLock ();
defer _efb ._gdd .RUnlock ();for _gfe ,_fab :=range _efb ._bbf {if f (_gfe ,_fab ){break ;};};};type ByteRuneMap struct{_d map[byte ]rune ;_e _a .RWMutex ;};type RuneUint16Map struct{_fa map[rune ]uint16 ;_bff _a .RWMutex ;};type RuneSet struct{_afd map[rune ]struct{};
_cc _a .RWMutex ;};func (_aca *RuneByteMap )Range (f func (_b rune ,_ba byte )(_cf bool )){_aca ._dg .RLock ();defer _aca ._dg .RUnlock ();for _fda ,_dbf :=range _aca ._aff {if f (_fda ,_dbf ){break ;};};};func (_bb *RuneStringMap )Range (f func (_cd rune ,_efc string )(_ec bool )){_bb ._gd .RLock ();
defer _bb ._gd .RUnlock ();for _cgg ,_gec :=range _bb ._cg {if f (_cgg ,_gec ){break ;};};};