//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package syncmap ;import _c "sync";func (_gd *ByteRuneMap )Write (b byte ,r rune ){_gd ._cd .Lock ();defer _gd ._cd .Unlock ();_gd ._e [b ]=r };func MakeRuneUint16Map (length int )*RuneUint16Map {return &RuneUint16Map {_gbc :make (map[rune ]uint16 ,length )};
};func NewByteRuneMap (m map[byte ]rune )*ByteRuneMap {return &ByteRuneMap {_e :m }};func (_ed *ByteRuneMap )Length ()int {_ed ._cd .RLock ();defer _ed ._cd .RUnlock ();return len (_ed ._e )};func (_bb *RuneUint16Map )RangeDelete (f func (_dbb rune ,_gde uint16 )(_gcb bool ,_edf bool )){_bb ._gc .Lock ();
defer _bb ._gc .Unlock ();for _fd ,_ded :=range _bb ._gbc {_deb ,_debc :=f (_fd ,_ded );if _deb {delete (_bb ._gbc ,_fd );};if _debc {break ;};};};type ByteRuneMap struct{_e map[byte ]rune ;_cd _c .RWMutex ;};func (_bd *RuneSet )Write (r rune ){_bd ._ag .Lock ();
defer _bd ._ag .Unlock ();_bd ._gga [r ]=struct{}{}};type StringsMap struct{_bdf map[string ]string ;_aed _c .RWMutex ;};func (_ffa *RuneStringMap )Write (r rune ,s string ){_ffa ._aag .Lock ();defer _ffa ._aag .Unlock ();_ffa ._ge [r ]=s ;};func (_fa *RuneStringMap )Length ()int {_fa ._aag .RLock ();
defer _fa ._aag .RUnlock ();return len (_fa ._ge );};type StringsTuple struct{Key ,Value string ;};type RuneByteMap struct{_gf map[rune ]byte ;_ad _c .RWMutex ;};func NewRuneStringMap (m map[rune ]string )*RuneStringMap {return &RuneStringMap {_ge :m }};
func MakeRuneSet (length int )*RuneSet {return &RuneSet {_gga :make (map[rune ]struct{},length )}};func (_fgg *RuneSet )Exists (r rune )bool {_fgg ._ag .RLock ();defer _fgg ._ag .RUnlock ();_ ,_cb :=_fgg ._gga [r ];return _cb ;};type RuneSet struct{_gga map[rune ]struct{};
_ag _c .RWMutex ;};func NewStringRuneMap (m map[string ]rune )*StringRuneMap {return &StringRuneMap {_gbg :m }};func (_dgd *StringsMap )Range (f func (_aea ,_cae string )(_ebe bool )){_dgd ._aed .RLock ();defer _dgd ._aed .RUnlock ();for _dd ,_cef :=range _dgd ._bdf {if f (_dd ,_cef ){break ;
};};};func (_efd *RuneStringMap )Range (f func (_cdf rune ,_gfc string )(_eff bool )){_efd ._aag .RLock ();defer _efd ._aag .RUnlock ();for _ca ,_agb :=range _efd ._ge {if f (_ca ,_agb ){break ;};};};func (_ec *RuneUint16Map )Write (r rune ,g uint16 ){_ec ._gc .Lock ();
defer _ec ._gc .Unlock ();_ec ._gbc [r ]=g ;};type RuneUint16Map struct{_gbc map[rune ]uint16 ;_gc _c .RWMutex ;};func (_gaa *StringRuneMap )Length ()int {_gaa ._cbd .RLock ();defer _gaa ._cbd .RUnlock ();return len (_gaa ._gbg );};func (_ade *RuneByteMap )Read (r rune )(byte ,bool ){_ade ._ad .RLock ();
defer _ade ._ad .RUnlock ();_db ,_cce :=_ade ._gf [r ];return _db ,_cce ;};func (_fb *StringRuneMap )Read (g string )(rune ,bool ){_fb ._cbd .RLock ();defer _fb ._cbd .RUnlock ();_dee ,_ccf :=_fb ._gbg [g ];return _dee ,_ccf ;};func (_fc *StringRuneMap )Write (g string ,r rune ){_fc ._cbd .Lock ();
defer _fc ._cbd .Unlock ();_fc ._gbg [g ]=r ;};type StringRuneMap struct{_gbg map[string ]rune ;_cbd _c .RWMutex ;};func (_eef *StringsMap )Copy ()*StringsMap {_eef ._aed .RLock ();defer _eef ._aed .RUnlock ();_aeac :=map[string ]string {};for _ffag ,_fbe :=range _eef ._bdf {_aeac [_ffag ]=_fbe ;
};return &StringsMap {_bdf :_aeac };};func (_eb *RuneSet )Range (f func (_fgd rune )(_dc bool )){_eb ._ag .RLock ();defer _eb ._ag .RUnlock ();for _dg :=range _eb ._gga {if f (_dg ){break ;};};};func (_efc *StringRuneMap )Range (f func (_fba string ,_ecg rune )(_da bool )){_efc ._cbd .RLock ();
defer _efc ._cbd .RUnlock ();for _gea ,_efdc :=range _efc ._gbg {if f (_gea ,_efdc ){break ;};};};func (_fff *RuneStringMap )Read (r rune )(string ,bool ){_fff ._aag .RLock ();defer _fff ._aag .RUnlock ();_ae ,_ab :=_fff ._ge [r ];return _ae ,_ab ;};func (_g *ByteRuneMap )Read (b byte )(rune ,bool ){_g ._cd .RLock ();
defer _g ._cd .RUnlock ();_ga ,_cc :=_g ._e [b ];return _ga ,_cc ;};func (_agc *RuneSet )Length ()int {_agc ._ag .RLock ();defer _agc ._ag .RUnlock ();return len (_agc ._gga )};func NewStringsMap (tuples []StringsTuple )*StringsMap {_cdc :=map[string ]string {};
for _ ,_agd :=range tuples {_cdc [_agd .Key ]=_agd .Value ;};return &StringsMap {_bdf :_cdc };};func (_eee *RuneByteMap )Range (f func (_ff rune ,_b byte )(_aa bool )){_eee ._ad .RLock ();defer _eee ._ad .RUnlock ();for _fg ,_gb :=range _eee ._gf {if f (_fg ,_gb ){break ;
};};};func MakeByteRuneMap (length int )*ByteRuneMap {return &ByteRuneMap {_e :make (map[byte ]rune ,length )}};func (_afe *RuneUint16Map )Length ()int {_afe ._gc .RLock ();defer _afe ._gc .RUnlock ();return len (_afe ._gbc );};func (_df *RuneUint16Map )Read (r rune )(uint16 ,bool ){_df ._gc .RLock ();
defer _df ._gc .RUnlock ();_gac ,_ebc :=_df ._gbc [r ];return _gac ,_ebc ;};func (_ccc *RuneByteMap )Write (r rune ,b byte ){_ccc ._ad .Lock ();defer _ccc ._ad .Unlock ();_ccc ._gf [r ]=b ;};func (_ef *ByteRuneMap )Range (f func (_f byte ,_gg rune )(_a bool )){_ef ._cd .RLock ();
defer _ef ._cd .RUnlock ();for _de ,_ee :=range _ef ._e {if f (_de ,_ee ){break ;};};};func MakeRuneByteMap (length int )*RuneByteMap {_ce :=make (map[rune ]byte ,length );return &RuneByteMap {_gf :_ce };};func (_ffb *RuneByteMap )Length ()int {_ffb ._ad .RLock ();
defer _ffb ._ad .RUnlock ();return len (_ffb ._gf );};type RuneStringMap struct{_ge map[rune ]string ;_aag _c .RWMutex ;};func (_edfb *StringsMap )Read (g string )(string ,bool ){_edfb ._aed .RLock ();defer _edfb ._aed .RUnlock ();_fcd ,_aba :=_edfb ._bdf [g ];
return _fcd ,_aba ;};func (_ba *RuneUint16Map )Delete (r rune ){_ba ._gc .Lock ();defer _ba ._gc .Unlock ();delete (_ba ._gbc ,r )};func (_fad *StringsMap )Write (g1 ,g2 string ){_fad ._aed .Lock ();defer _fad ._aed .Unlock ();_fad ._bdf [g1 ]=g2 ;};func (_eg *RuneUint16Map )Range (f func (_gbf rune ,_gfd uint16 )(_caa bool )){_eg ._gc .RLock ();
defer _eg ._gc .RUnlock ();for _af ,_ffd :=range _eg ._gbc {if f (_af ,_ffd ){break ;};};};