//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package syncmap ;import _b "sync";func (_bbg *RuneSet )Range (f func (_dfg rune )(_gef bool )){_bbg ._ff .RLock ();defer _bbg ._ff .RUnlock ();for _gge :=range _bbg ._ad {if f (_gge ){break ;};};};func (_gga *RuneUint16Map )Read (r rune )(uint16 ,bool ){_gga ._bac .RLock ();
defer _gga ._bac .RUnlock ();_ae ,_ffa :=_gga ._aga [r ];return _ae ,_ffa ;};func NewStringRuneMap (m map[string ]rune )*StringRuneMap {return &StringRuneMap {_agb :m }};func (_ace *RuneSet )Write (r rune ){_ace ._ff .Lock ();defer _ace ._ff .Unlock ();
_ace ._ad [r ]=struct{}{};};type StringsTuple struct{Key ,Value string ;};func (_dg *RuneUint16Map )Range (f func (_cc rune ,_ea uint16 )(_cef bool )){_dg ._bac .RLock ();defer _dg ._bac .RUnlock ();for _fae ,_gc :=range _dg ._aga {if f (_fae ,_gc ){break ;
};};};func (_ece *RuneStringMap )Read (r rune )(string ,bool ){_ece ._ba .RLock ();defer _ece ._ba .RUnlock ();_gd ,_ffc :=_ece ._ed [r ];return _gd ,_ffc ;};func MakeByteRuneMap (length int )*ByteRuneMap {return &ByteRuneMap {_d :make (map[byte ]rune ,length )}};
func MakeRuneSet (length int )*RuneSet {return &RuneSet {_ad :make (map[rune ]struct{},length )}};func (_bbb *RuneStringMap )Write (r rune ,s string ){_bbb ._ba .Lock ();defer _bbb ._ba .Unlock ();_bbb ._ed [r ]=s ;};func (_fe *RuneSet )Length ()int {_fe ._ff .RLock ();
defer _fe ._ff .RUnlock ();return len (_fe ._ad )};func (_aca *RuneByteMap )Read (r rune )(byte ,bool ){_aca ._daf .RLock ();defer _aca ._daf .RUnlock ();_dbc ,_fa :=_aca ._fdd [r ];return _dbc ,_fa ;};func (_acb *RuneByteMap )Write (r rune ,b byte ){_acb ._daf .Lock ();
defer _acb ._daf .Unlock ();_acb ._fdd [r ]=b ;};func (_bg *RuneSet )Exists (r rune )bool {_bg ._ff .RLock ();defer _bg ._ff .RUnlock ();_ ,_ecf :=_bg ._ad [r ];return _ecf ;};func (_dd *ByteRuneMap )Range (f func (_e byte ,_g rune )(_ec bool )){_dd ._db .RLock ();
defer _dd ._db .RUnlock ();for _fd ,_a :=range _dd ._d {if f (_fd ,_a ){break ;};};};func (_cg *RuneUint16Map )Length ()int {_cg ._bac .RLock ();defer _cg ._bac .RUnlock ();return len (_cg ._aga );};func (_da *ByteRuneMap )Read (b byte )(rune ,bool ){_da ._db .RLock ();
defer _da ._db .RUnlock ();_fb ,_fc :=_da ._d [b ];return _fb ,_fc ;};func (_eec *StringsMap )Read (g string )(string ,bool ){_eec ._gcb .RLock ();defer _eec ._gcb .RUnlock ();_aceb ,_geg :=_eec ._cf [g ];return _aceb ,_geg ;};func (_ecb *RuneUint16Map )RangeDelete (f func (_gdg rune ,_dde uint16 )(_add bool ,_ecd bool )){_ecb ._bac .Lock ();
defer _ecb ._bac .Unlock ();for _bacc ,_bgaa :=range _ecb ._aga {_aff ,_ggd :=f (_bacc ,_bgaa );if _aff {delete (_ecb ._aga ,_bacc );};if _ggd {break ;};};};func (_gf *StringsMap )Copy ()*StringsMap {_gf ._gcb .RLock ();defer _gf ._gcb .RUnlock ();_gcf :=map[string ]string {};
for _gfd ,_ggc :=range _gf ._cf {_gcf [_gfd ]=_ggc ;};return &StringsMap {_cf :_gcf };};type RuneByteMap struct{_fdd map[rune ]byte ;_daf _b .RWMutex ;};func NewStringsMap (tuples []StringsTuple )*StringsMap {_eca :=map[string ]string {};for _ ,_ced :=range tuples {_eca [_ced .Key ]=_ced .Value ;
};return &StringsMap {_cf :_eca };};func (_bbgc *RuneUint16Map )Delete (r rune ){_bbgc ._bac .Lock ();defer _bbgc ._bac .Unlock ();delete (_bbgc ._aga ,r );};func (_ee *RuneByteMap )Range (f func (_df rune ,_ga byte )(_de bool )){_ee ._daf .RLock ();defer _ee ._daf .RUnlock ();
for _ag ,_ge :=range _ee ._fdd {if f (_ag ,_ge ){break ;};};};func MakeRuneUint16Map (length int )*RuneUint16Map {return &RuneUint16Map {_aga :make (map[rune ]uint16 ,length )};};type RuneSet struct{_ad map[rune ]struct{};_ff _b .RWMutex ;};func (_ede *StringsMap )Range (f func (_eee ,_bf string )(_aa bool )){_ede ._gcb .RLock ();
defer _ede ._gcb .RUnlock ();for _afg ,_bgaf :=range _ede ._cf {if f (_afg ,_bgaf ){break ;};};};type RuneStringMap struct{_ed map[rune ]string ;_ba _b .RWMutex ;};func (_fba *ByteRuneMap )Length ()int {_fba ._db .RLock ();defer _fba ._db .RUnlock ();return len (_fba ._d );
};type ByteRuneMap struct{_d map[byte ]rune ;_db _b .RWMutex ;};func (_cd *StringRuneMap )Write (g string ,r rune ){_cd ._gdc .Lock ();defer _cd ._gdc .Unlock ();_cd ._agb [g ]=r ;};func (_gg *RuneByteMap )Length ()int {_gg ._daf .RLock ();defer _gg ._daf .RUnlock ();
return len (_gg ._fdd );};func (_fab *RuneStringMap )Length ()int {_fab ._ba .RLock ();defer _fab ._ba .RUnlock ();return len (_fab ._ed );};func (_bbe *StringRuneMap )Read (g string )(rune ,bool ){_bbe ._gdc .RLock ();defer _bbe ._gdc .RUnlock ();_gae ,_ggae :=_bbe ._agb [g ];
return _gae ,_ggae ;};type StringsMap struct{_cf map[string ]string ;_gcb _b .RWMutex ;};func NewByteRuneMap (m map[byte ]rune )*ByteRuneMap {return &ByteRuneMap {_d :m }};func NewRuneStringMap (m map[rune ]string )*RuneStringMap {return &RuneStringMap {_ed :m }};
func (_ab *StringRuneMap )Length ()int {_ab ._gdc .RLock ();defer _ab ._gdc .RUnlock ();return len (_ab ._agb );};func (_ca *RuneUint16Map )Write (r rune ,g uint16 ){_ca ._bac .Lock ();defer _ca ._bac .Unlock ();_ca ._aga [r ]=g ;};func (_ccf *StringRuneMap )Range (f func (_bd string ,_bde rune )(_fee bool )){_ccf ._gdc .RLock ();
defer _ccf ._gdc .RUnlock ();for _cb ,_eb :=range _ccf ._agb {if f (_cb ,_eb ){break ;};};};func (_ce *RuneStringMap )Range (f func (_dfgg rune ,_fac string )(_bga bool )){_ce ._ba .RLock ();defer _ce ._ba .RUnlock ();for _af ,_gged :=range _ce ._ed {if f (_af ,_gged ){break ;
};};};func (_gee *StringsMap )Write (g1 ,g2 string ){_gee ._gcb .Lock ();defer _gee ._gcb .Unlock ();_gee ._cf [g1 ]=g2 ;};type RuneUint16Map struct{_aga map[rune ]uint16 ;_bac _b .RWMutex ;};func (_bb *ByteRuneMap )Write (b byte ,r rune ){_bb ._db .Lock ();
defer _bb ._db .Unlock ();_bb ._d [b ]=r };type StringRuneMap struct{_agb map[string ]rune ;_gdc _b .RWMutex ;};func MakeRuneByteMap (length int )*RuneByteMap {_ac :=make (map[rune ]byte ,length );return &RuneByteMap {_fdd :_ac };};