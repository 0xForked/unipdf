//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package syncmap ;import _a "sync";func NewStringsMap (tuples []StringsTuple )*StringsMap {_gd :=map[string ]string {};for _ ,_ddd :=range tuples {_gd [_ddd .Key ]=_ddd .Value ;};return &StringsMap {_cba :_gd };};func (_aea *RuneStringMap )Write (r rune ,s string ){_aea ._ee .Lock ();
defer _aea ._ee .Unlock ();_aea ._ced [r ]=s ;};func (_ae *RuneByteMap )Write (r rune ,b byte ){_ae ._egb .Lock ();defer _ae ._egb .Unlock ();_ae ._ed [r ]=b ;};type StringsMap struct{_cba map[string ]string ;_egcb _a .RWMutex ;};func MakeRuneUint16Map (length int )*RuneUint16Map {return &RuneUint16Map {_dbg :make (map[rune ]uint16 ,length )};
};type RuneByteMap struct{_ed map[rune ]byte ;_egb _a .RWMutex ;};func (_cf *RuneUint16Map )Write (r rune ,g uint16 ){_cf ._ea .Lock ();defer _cf ._ea .Unlock ();_cf ._dbg [r ]=g ;};func (_ab *RuneByteMap )Range (f func (_dd rune ,_afc byte )(_aeb bool )){_ab ._egb .RLock ();
defer _ab ._egb .RUnlock ();for _gg ,_be :=range _ab ._ed {if f (_gg ,_be ){break ;};};};func (_ebd *StringsMap )Write (g1 ,g2 string ){_ebd ._egcb .Lock ();defer _ebd ._egcb .Unlock ();_ebd ._cba [g1 ]=g2 ;};func (_ebe *RuneByteMap )Length ()int {_ebe ._egb .RLock ();
defer _ebe ._egb .RUnlock ();return len (_ebe ._ed );};func NewRuneStringMap (m map[rune ]string )*RuneStringMap {return &RuneStringMap {_ced :m }};func (_abc *StringRuneMap )Read (g string )(rune ,bool ){_abc ._dg .RLock ();defer _abc ._dg .RUnlock ();
_cff ,_efe :=_abc ._egc [g ];return _cff ,_efe ;};func NewStringRuneMap (m map[string ]rune )*StringRuneMap {return &StringRuneMap {_egc :m }};func (_fgf *RuneUint16Map )Range (f func (_gc rune ,_ggb uint16 )(_cgd bool )){_fgf ._ea .RLock ();defer _fgf ._ea .RUnlock ();
for _ccb ,_cb :=range _fgf ._dbg {if f (_ccb ,_cb ){break ;};};};type RuneUint16Map struct{_dbg map[rune ]uint16 ;_ea _a .RWMutex ;};func (_agb *ByteRuneMap )Read (b byte )(rune ,bool ){_agb ._ag .RLock ();defer _agb ._ag .RUnlock ();_b ,_eg :=_agb ._d [b ];
return _b ,_eg ;};func (_bdc *RuneUint16Map )Delete (r rune ){_bdc ._ea .Lock ();defer _bdc ._ea .Unlock ();delete (_bdc ._dbg ,r );};func (_eeb *RuneStringMap )Range (f func (_bd rune ,_db string )(_afcb bool )){_eeb ._ee .RLock ();defer _eeb ._ee .RUnlock ();
for _bef ,_cc :=range _eeb ._ced {if f (_bef ,_cc ){break ;};};};func (_bagb *StringRuneMap )Write (g string ,r rune ){_bagb ._dg .Lock ();defer _bagb ._dg .Unlock ();_bagb ._egc [g ]=r ;};func (_gb *RuneStringMap )Read (r rune )(string ,bool ){_gb ._ee .RLock ();
defer _gb ._ee .RUnlock ();_ca ,_dab :=_gb ._ced [r ];return _ca ,_dab ;};func (_ge *RuneUint16Map )Read (r rune )(uint16 ,bool ){_ge ._ea .RLock ();defer _ge ._ea .RUnlock ();_bg ,_eea :=_ge ._dbg [r ];return _bg ,_eea ;};func (_ba *RuneByteMap )Read (r rune )(byte ,bool ){_ba ._egb .RLock ();
defer _ba ._egb .RUnlock ();_ce ,_fgc :=_ba ._ed [r ];return _ce ,_fgc ;};func MakeByteRuneMap (length int )*ByteRuneMap {return &ByteRuneMap {_d :make (map[byte ]rune ,length )}};type StringRuneMap struct{_egc map[string ]rune ;_dg _a .RWMutex ;};type ByteRuneMap struct{_d map[byte ]rune ;
_ag _a .RWMutex ;};func (_fe *RuneStringMap )Length ()int {_fe ._ee .RLock ();defer _fe ._ee .RUnlock ();return len (_fe ._ced );};func MakeRuneSet (length int )*RuneSet {return &RuneSet {_bb :make (map[rune ]struct{},length )}};type StringsTuple struct{Key ,Value string ;
};func (_cg *RuneSet )Range (f func (_bca rune )(_afcg bool )){_cg ._ac .RLock ();defer _cg ._ac .RUnlock ();for _ef :=range _cg ._bb {if f (_ef ){break ;};};};func (_afe *StringRuneMap )Range (f func (_fb string ,_gba rune )(_eec bool )){_afe ._dg .RLock ();
defer _afe ._dg .RUnlock ();for _aaf ,_dbf :=range _afe ._egc {if f (_aaf ,_dbf ){break ;};};};func (_egg *RuneSet )Write (r rune ){_egg ._ac .Lock ();defer _egg ._ac .Unlock ();_egg ._bb [r ]=struct{}{};};func (_bdg *RuneUint16Map )Length ()int {_bdg ._ea .RLock ();
defer _bdg ._ea .RUnlock ();return len (_bdg ._dbg );};func (_g *ByteRuneMap )Write (b byte ,r rune ){_g ._ag .Lock ();defer _g ._ag .Unlock ();_g ._d [b ]=r };func (_cad *StringsMap )Copy ()*StringsMap {_cad ._egcb .RLock ();defer _cad ._egcb .RUnlock ();
_ad :=map[string ]string {};for _ged ,_edbf :=range _cad ._cba {_ad [_ged ]=_edbf ;};return &StringsMap {_cba :_ad };};func (_da *ByteRuneMap )Length ()int {_da ._ag .RLock ();defer _da ._ag .RUnlock ();return len (_da ._d )};func (_beg *RuneSet )Length ()int {_beg ._ac .RLock ();
defer _beg ._ac .RUnlock ();return len (_beg ._bb )};func (_fcc *RuneUint16Map )RangeDelete (f func (_ga rune ,_cd uint16 )(_ff bool ,_ebb bool )){_fcc ._ea .Lock ();defer _fcc ._ea .Unlock ();for _caf ,_bag :=range _fcc ._dbg {_gag ,_de :=f (_caf ,_bag );
if _gag {delete (_fcc ._dbg ,_caf );};if _de {break ;};};};type RuneStringMap struct{_ced map[rune ]string ;_ee _a .RWMutex ;};func (_caa *StringRuneMap )Length ()int {_caa ._dg .RLock ();defer _caa ._dg .RUnlock ();return len (_caa ._egc );};func (_af *ByteRuneMap )Range (f func (_bc byte ,_aa rune )(_eb bool )){_af ._ag .RLock ();
defer _af ._ag .RUnlock ();for _f ,_fg :=range _af ._d {if f (_f ,_fg ){break ;};};};func (_afg *StringsMap )Range (f func (_ddb ,_fbb string )(_edc bool )){_afg ._egcb .RLock ();defer _afg ._egcb .RUnlock ();for _bga ,_cbc :=range _afg ._cba {if f (_bga ,_cbc ){break ;
};};};func (_edb *RuneSet )Exists (r rune )bool {_edb ._ac .RLock ();defer _edb ._ac .RUnlock ();_ ,_bf :=_edb ._bb [r ];return _bf ;};func (_ffb *StringsMap )Read (g string )(string ,bool ){_ffb ._egcb .RLock ();defer _ffb ._egcb .RUnlock ();_dc ,_caaa :=_ffb ._cba [g ];
return _dc ,_caaa ;};func NewByteRuneMap (m map[byte ]rune )*ByteRuneMap {return &ByteRuneMap {_d :m }};func MakeRuneByteMap (length int )*RuneByteMap {_c :=make (map[rune ]byte ,length );return &RuneByteMap {_ed :_c };};type RuneSet struct{_bb map[rune ]struct{};
_ac _a .RWMutex ;};