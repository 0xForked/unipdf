//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package syncmap ;import _c "sync";func (_cf *StringsMap )Read (g string )(string ,bool ){_cf ._cbfgb .RLock ();defer _cf ._cbfgb .RUnlock ();_dga ,_gca :=_cf ._aeg [g ];return _dga ,_gca ;};func (_ad *RuneUint16Map )RangeDelete (f func (_daba rune ,_gag uint16 )(_fe bool ,_dg bool )){_ad ._fg .Lock ();
defer _ad ._fg .Unlock ();for _cbg ,_ggd :=range _ad ._gbb {_dda ,_eff :=f (_cbg ,_ggd );if _dda {delete (_ad ._gbb ,_cbg );};if _eff {break ;};};};func NewStringRuneMap (m map[string ]rune )*StringRuneMap {return &StringRuneMap {_db :m }};type StringsTuple struct{Key ,Value string ;
};func (_be *RuneSet )Length ()int {_be ._gfg .RLock ();defer _be ._gfg .RUnlock ();return len (_be ._fb )};func (_gee *StringRuneMap )Length ()int {_gee ._agg .RLock ();defer _gee ._agg .RUnlock ();return len (_gee ._db );};type RuneSet struct{_fb map[rune ]struct{};
_gfg _c .RWMutex ;};func (_ddg *RuneUint16Map )Read (r rune )(uint16 ,bool ){_ddg ._fg .RLock ();defer _ddg ._fg .RUnlock ();_ee ,_bce :=_ddg ._gbb [r ];return _ee ,_bce ;};func (_cda *RuneStringMap )Write (r rune ,s string ){_cda ._fce .Lock ();defer _cda ._fce .Unlock ();
_cda ._fc [r ]=s ;};func (_ag *ByteRuneMap )Length ()int {_ag ._f .RLock ();defer _ag ._f .RUnlock ();return len (_ag ._g )};func (_gbed *RuneUint16Map )Length ()int {_gbed ._fg .RLock ();defer _gbed ._fg .RUnlock ();return len (_gbed ._gbb );};func MakeRuneByteMap (length int )*RuneByteMap {_cc :=make (map[rune ]byte ,length );
return &RuneByteMap {_gb :_cc };};func (_dag *RuneSet )Write (r rune ){_dag ._gfg .Lock ();defer _dag ._gfg .Unlock ();_dag ._fb [r ]=struct{}{};};func (_dad *RuneStringMap )Range (f func (_bc rune ,_edf string )(_ebc bool )){_dad ._fce .RLock ();defer _dad ._fce .RUnlock ();
for _cbfg ,_aa :=range _dad ._fc {if f (_cbfg ,_aa ){break ;};};};func (_gc *ByteRuneMap )Write (b byte ,r rune ){_gc ._f .Lock ();defer _gc ._f .Unlock ();_gc ._g [b ]=r };type StringRuneMap struct{_db map[string ]rune ;_agg _c .RWMutex ;};func (_daga *StringsMap )Write (g1 ,g2 string ){_daga ._cbfgb .Lock ();
defer _daga ._cbfgb .Unlock ();_daga ._aeg [g1 ]=g2 ;};type RuneUint16Map struct{_gbb map[rune ]uint16 ;_fg _c .RWMutex ;};type RuneByteMap struct{_gb map[rune ]byte ;_ea _c .RWMutex ;};func (_bbd *RuneStringMap )Length ()int {_bbd ._fce .RLock ();defer _bbd ._fce .RUnlock ();
return len (_bbd ._fc );};func NewStringsMap (tuples []StringsTuple )*StringsMap {_ede :=map[string ]string {};for _ ,_geeg :=range tuples {_ede [_geeg .Key ]=_geeg .Value ;};return &StringsMap {_aeg :_ede };};type RuneStringMap struct{_fc map[rune ]string ;
_fce _c .RWMutex ;};func MakeRuneSet (length int )*RuneSet {return &RuneSet {_fb :make (map[rune ]struct{},length )}};func (_ddb *StringsMap )Copy ()*StringsMap {_ddb ._cbfgb .RLock ();defer _ddb ._cbfgb .RUnlock ();_bf :=map[string ]string {};for _gbf ,_gcd :=range _ddb ._aeg {_bf [_gbf ]=_gcd ;
};return &StringsMap {_aeg :_bf };};func (_eef *RuneUint16Map )Range (f func (_gbe rune ,_dee uint16 )(_acc bool )){_eef ._fg .RLock ();defer _eef ._fg .RUnlock ();for _ebd ,_cbfgf :=range _eef ._gbb {if f (_ebd ,_cbfgf ){break ;};};};func (_bba *RuneStringMap )Read (r rune )(string ,bool ){_bba ._fce .RLock ();
defer _bba ._fce .RUnlock ();_ac ,_eb :=_bba ._fc [r ];return _ac ,_eb ;};func (_bcc *StringRuneMap )Read (g string )(rune ,bool ){_bcc ._agg .RLock ();defer _bcc ._agg .RUnlock ();_ega ,_cdaf :=_bcc ._db [g ];return _ega ,_cdaf ;};func NewRuneStringMap (m map[rune ]string )*RuneStringMap {return &RuneStringMap {_fc :m }};
func (_cbe *StringRuneMap )Write (g string ,r rune ){_cbe ._agg .Lock ();defer _cbe ._agg .Unlock ();_cbe ._db [g ]=r ;};func (_ec *RuneUint16Map )Write (r rune ,g uint16 ){_ec ._fg .Lock ();defer _ec ._fg .Unlock ();_ec ._gbb [r ]=g ;};type StringsMap struct{_aeg map[string ]string ;
_cbfgb _c .RWMutex ;};func (_ge *RuneByteMap )Length ()int {_ge ._ea .RLock ();defer _ge ._ea .RUnlock ();return len (_ge ._gb )};func MakeByteRuneMap (length int )*ByteRuneMap {return &ByteRuneMap {_g :make (map[byte ]rune ,length )}};func (_bcca *StringsMap )Range (f func (_bdc ,_fcf string )(_fd bool )){_bcca ._cbfgb .RLock ();
defer _bcca ._cbfgb .RUnlock ();for _daf ,_ab :=range _bcca ._aeg {if f (_daf ,_ab ){break ;};};};func (_ca *RuneUint16Map )Delete (r rune ){_ca ._fg .Lock ();defer _ca ._fg .Unlock ();delete (_ca ._gbb ,r )};func (_bb *RuneByteMap )Read (r rune )(byte ,bool ){_bb ._ea .RLock ();
defer _bb ._ea .RUnlock ();_ed ,_gg :=_bb ._gb [r ];return _ed ,_gg ;};func (_egd *StringRuneMap )Range (f func (_af string ,_gec rune )(_fbb bool )){_egd ._agg .RLock ();defer _egd ._agg .RUnlock ();for _cgd ,_cca :=range _egd ._db {if f (_cgd ,_cca ){break ;
};};};func (_bg *RuneByteMap )Write (r rune ,b byte ){_bg ._ea .Lock ();defer _bg ._ea .Unlock ();_bg ._gb [r ]=b };func (_df *RuneSet )Exists (r rune )bool {_df ._gfg .RLock ();defer _df ._gfg .RUnlock ();_ ,_dc :=_df ._fb [r ];return _dc ;};func MakeRuneUint16Map (length int )*RuneUint16Map {return &RuneUint16Map {_gbb :make (map[rune ]uint16 ,length )};
};type ByteRuneMap struct{_g map[byte ]rune ;_f _c .RWMutex ;};func (_agc *RuneSet )Range (f func (_ae rune )(_dd bool )){_agc ._gfg .RLock ();defer _agc ._gfg .RUnlock ();for _ef :=range _agc ._fb {if f (_ef ){break ;};};};func (_eg *ByteRuneMap )Range (f func (_cb byte ,_cg rune )(_de bool )){_eg ._f .RLock ();
defer _eg ._f .RUnlock ();for _cgf ,_b :=range _eg ._g {if f (_cgf ,_b ){break ;};};};func NewByteRuneMap (m map[byte ]rune )*ByteRuneMap {return &ByteRuneMap {_g :m }};func (_bd *RuneByteMap )Range (f func (_da rune ,_ga byte )(_cbf bool )){_bd ._ea .RLock ();
defer _bd ._ea .RUnlock ();for _gd ,_cd :=range _bd ._gb {if f (_gd ,_cd ){break ;};};};func (_e *ByteRuneMap )Read (b byte )(rune ,bool ){_e ._f .RLock ();defer _e ._f .RUnlock ();_a ,_gf :=_e ._g [b ];return _a ,_gf ;};