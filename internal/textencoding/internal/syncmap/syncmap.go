//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package syncmap ;import _g "sync";func (_fbg *RuneSet )Exists (r rune )bool {_fbg ._gb .RLock ();defer _fbg ._gb .RUnlock ();_ ,_aeb :=_fbg ._gcf [r ];return _aeb ;};func MakeRuneByteMap (length int )*RuneByteMap {_ae :=make (map[rune ]byte ,length );return &RuneByteMap {_af :_ae };
};func (_fef *RuneStringMap )Write (r rune ,s string ){_fef ._dfb .Lock ();defer _fef ._dfb .Unlock ();_fef ._ab [r ]=s ;};type RuneSet struct{_gcf map[rune ]struct{};_gb _g .RWMutex ;};func (_bcb *StringRuneMap )Length ()int {_bcb ._bfe .RLock ();defer _bcb ._bfe .RUnlock ();
return len (_bcb ._fa );};func (_gc *RuneByteMap )Range (f func (_dg rune ,_edb byte )(_bg bool )){_gc ._eb .RLock ();defer _gc ._eb .RUnlock ();for _fe ,_dd :=range _gc ._af {if f (_fe ,_dd ){break ;};};};func (_be *RuneStringMap )Length ()int {_be ._dfb .RLock ();
defer _be ._dfb .RUnlock ();return len (_be ._ab );};type RuneUint16Map struct{_gd map[rune ]uint16 ;_ce _g .RWMutex ;};func NewByteRuneMap (m map[byte ]rune )*ByteRuneMap {return &ByteRuneMap {_f :m }};func MakeRuneUint16Map (length int )*RuneUint16Map {return &RuneUint16Map {_gd :make (map[rune ]uint16 ,length )};
};func NewStringRuneMap (m map[string ]rune )*StringRuneMap {return &StringRuneMap {_fa :m }};func (_ece *RuneUint16Map )Range (f func (_fbfg rune ,_ecc uint16 )(_bed bool )){_ece ._ce .RLock ();defer _ece ._ce .RUnlock ();for _gcd ,_gf :=range _ece ._gd {if f (_gcd ,_gf ){break ;
};};};func (_fbc *ByteRuneMap )Range (f func (_ge byte ,_e rune )(_ad bool )){_fbc ._a .RLock ();defer _fbc ._a .RUnlock ();for _eg ,_df :=range _fbc ._f {if f (_eg ,_df ){break ;};};};func (_fc *RuneByteMap )Read (r rune )(byte ,bool ){_fc ._eb .RLock ();
defer _fc ._eb .RUnlock ();_fbf ,_ag :=_fc ._af [r ];return _fbf ,_ag ;};func MakeByteRuneMap (length int )*ByteRuneMap {return &ByteRuneMap {_f :make (map[byte ]rune ,length )}};type StringRuneMap struct{_fa map[string ]rune ;_bfe _g .RWMutex ;};func (_add *RuneByteMap )Write (r rune ,b byte ){_add ._eb .Lock ();
defer _add ._eb .Unlock ();_add ._af [r ]=b ;};func (_bf *RuneUint16Map )Read (r rune )(uint16 ,bool ){_bf ._ce .RLock ();defer _bf ._ce .RUnlock ();_gcc ,_feb :=_bf ._gd [r ];return _gcc ,_feb ;};func (_cd *StringRuneMap )Read (g string )(rune ,bool ){_cd ._bfe .RLock ();
defer _cd ._bfe .RUnlock ();_edc ,_cdf :=_cd ._fa [g ];return _edc ,_cdf ;};func (_ege *StringRuneMap )Range (f func (_fcg string ,_cg rune )(_fdf bool )){_ege ._bfe .RLock ();defer _ege ._bfe .RUnlock ();for _fgg ,_eff :=range _ege ._fa {if f (_fgg ,_eff ){break ;
};};};func (_ea *RuneStringMap )Range (f func (_ca rune ,_eae string )(_dcc bool )){_ea ._dfb .RLock ();defer _ea ._dfb .RUnlock ();for _ecd ,_fgf :=range _ea ._ab {if f (_ecd ,_fgf ){break ;};};};func (_efe *RuneUint16Map )Length ()int {_efe ._ce .RLock ();
defer _efe ._ce .RUnlock ();return len (_efe ._gd );};func (_bc *ByteRuneMap )Write (b byte ,r rune ){_bc ._a .Lock ();defer _bc ._a .Unlock ();_bc ._f [b ]=r };type RuneByteMap struct{_af map[rune ]byte ;_eb _g .RWMutex ;};func (_bb *StringRuneMap )Write (g string ,r rune ){_bb ._bfe .Lock ();
defer _bb ._bfe .Unlock ();_bb ._fa [g ]=r ;};func (_aag *RuneUint16Map )Write (r rune ,g uint16 ){_aag ._ce .Lock ();defer _aag ._ce .Unlock ();_aag ._gd [r ]=g ;};func NewStringsMap (tuples []StringsTuple )*StringsMap {_db :=map[string ]string {};for _ ,_cgg :=range tuples {_db [_cgg .Key ]=_cgg .Value ;
};return &StringsMap {_dfe :_db };};type RuneStringMap struct{_ab map[rune ]string ;_dfb _g .RWMutex ;};func (_fee *RuneSet )Range (f func (_fg rune )(_dc bool )){_fee ._gb .RLock ();defer _fee ._gb .RUnlock ();for _ec :=range _fee ._gcf {if f (_ec ){break ;
};};};func (_aab *StringsMap )Read (g string )(string ,bool ){_aab ._gce .RLock ();defer _aab ._gce .RUnlock ();_dbg ,_fag :=_aab ._dfe [g ];return _dbg ,_fag ;};func (_bdd *RuneUint16Map )RangeDelete (f func (_ade rune ,_dce uint16 )(_gfa bool ,_gbd bool )){_bdd ._ce .Lock ();
defer _bdd ._ce .Unlock ();for _eab ,_fd :=range _bdd ._gd {_fed ,_ee :=f (_eab ,_fd );if _fed {delete (_bdd ._gd ,_eab );};if _ee {break ;};};};type ByteRuneMap struct{_f map[byte ]rune ;_a _g .RWMutex ;};func (_ed *ByteRuneMap )Length ()int {_ed ._a .RLock ();
defer _ed ._a .RUnlock ();return len (_ed ._f )};func (_d *ByteRuneMap )Read (b byte )(rune ,bool ){_d ._a .RLock ();defer _d ._a .RUnlock ();_fb ,_b :=_d ._f [b ];return _fb ,_b ;};func (_gcg *RuneSet )Write (r rune ){_gcg ._gb .Lock ();defer _gcg ._gb .Unlock ();
_gcg ._gcf [r ]=struct{}{};};func (_bga *StringsMap )Write (g1 ,g2 string ){_bga ._gce .Lock ();defer _bga ._gce .Unlock ();_bga ._dfe [g1 ]=g2 ;};func MakeRuneSet (length int )*RuneSet {return &RuneSet {_gcf :make (map[rune ]struct{},length )}};func (_aa *RuneSet )Length ()int {_aa ._gb .RLock ();
defer _aa ._gb .RUnlock ();return len (_aa ._gcf )};func NewRuneStringMap (m map[rune ]string )*RuneStringMap {return &RuneStringMap {_ab :m }};type StringsTuple struct{Key ,Value string ;};func (_adg *RuneUint16Map )Delete (r rune ){_adg ._ce .Lock ();
defer _adg ._ce .Unlock ();delete (_adg ._gd ,r );};type StringsMap struct{_dfe map[string ]string ;_gce _g .RWMutex ;};func (_dff *RuneByteMap )Length ()int {_dff ._eb .RLock ();defer _dff ._eb .RUnlock ();return len (_dff ._af );};func (_bfc *StringsMap )Copy ()*StringsMap {_bfc ._gce .RLock ();
defer _bfc ._gce .RUnlock ();_ddd :=map[string ]string {};for _cab ,_gba :=range _bfc ._dfe {_ddd [_cab ]=_gba ;};return &StringsMap {_dfe :_ddd };};func (_beb *StringsMap )Range (f func (_ead ,_cfd string )(_cc bool )){_beb ._gce .RLock ();defer _beb ._gce .RUnlock ();
for _abg ,_gfag :=range _beb ._dfe {if f (_abg ,_gfag ){break ;};};};func (_cf *RuneStringMap )Read (r rune )(string ,bool ){_cf ._dfb .RLock ();defer _cf ._dfb .RUnlock ();_bd ,_ba :=_cf ._ab [r ];return _bd ,_ba ;};