//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package syncmap ;import _d "sync";func (_bf *RuneSet )Length ()int {_bf ._cdd .RLock ();defer _bf ._cdd .RUnlock ();return len (_bf ._ba )};type StringsTuple struct{Key ,Value string ;};func (_fg *RuneByteMap )Read (r rune )(byte ,bool ){_fg ._ab .RLock ();
defer _fg ._ab .RUnlock ();_da ,_g :=_fg ._fd [r ];return _da ,_g ;};func (_gf *StringsMap )Range (f func (_ebg ,_bfg string )(_dad bool )){_gf ._daa .RLock ();defer _gf ._daa .RUnlock ();for _bgb ,_abc :=range _gf ._cec {if f (_bgb ,_abc ){break ;};};
};func (_agcb *StringsMap )Write (g1 ,g2 string ){_agcb ._daa .Lock ();defer _agcb ._daa .Unlock ();_agcb ._cec [g1 ]=g2 ;};type RuneByteMap struct{_fd map[rune ]byte ;_ab _d .RWMutex ;};func (_cfg *StringRuneMap )Length ()int {_cfg ._gbc .RLock ();defer _cfg ._gbc .RUnlock ();
return len (_cfg ._bbb );};type StringsMap struct{_cec map[string ]string ;_daa _d .RWMutex ;};type ByteRuneMap struct{_ca map[byte ]rune ;_f _d .RWMutex ;};func MakeRuneSet (length int )*RuneSet {return &RuneSet {_ba :make (map[rune ]struct{},length )}};
func (_dag *RuneStringMap )Length ()int {_dag ._bbc .RLock ();defer _dag ._bbc .RUnlock ();return len (_dag ._cb );};func NewByteRuneMap (m map[byte ]rune )*ByteRuneMap {return &ByteRuneMap {_ca :m }};func (_cee *RuneStringMap )Range (f func (_cbd rune ,_bfb string )(_gag bool )){_cee ._bbc .RLock ();
defer _cee ._bbc .RUnlock ();for _fb ,_cab :=range _cee ._cb {if f (_fb ,_cab ){break ;};};};func (_ga *RuneByteMap )Write (r rune ,b byte ){_ga ._ab .Lock ();defer _ga ._ab .Unlock ();_ga ._fd [r ]=b };func (_ag *ByteRuneMap )Write (b byte ,r rune ){_ag ._f .Lock ();
defer _ag ._f .Unlock ();_ag ._ca [b ]=r };func (_efa *RuneStringMap )Read (r rune )(string ,bool ){_efa ._bbc .RLock ();defer _efa ._bbc .RUnlock ();_dbd ,_gd :=_efa ._cb [r ];return _dbd ,_gd ;};func (_gg *RuneUint16Map )Read (r rune )(uint16 ,bool ){_gg ._ed .RLock ();
defer _gg ._ed .RUnlock ();_baf ,_efd :=_gg ._fea [r ];return _baf ,_efd ;};func (_bcg *RuneUint16Map )Length ()int {_bcg ._ed .RLock ();defer _bcg ._ed .RUnlock ();return len (_bcg ._fea );};func MakeByteRuneMap (length int )*ByteRuneMap {return &ByteRuneMap {_ca :make (map[byte ]rune ,length )}};
func (_bg *StringRuneMap )Range (f func (_fcg string ,_dge rune )(_dac bool )){_bg ._gbc .RLock ();defer _bg ._gbc .RUnlock ();for _dgd ,_gba :=range _bg ._bbb {if f (_dgd ,_gba ){break ;};};};func (_ecf *RuneStringMap )Write (r rune ,s string ){_ecf ._bbc .Lock ();
defer _ecf ._bbc .Unlock ();_ecf ._cb [r ]=s ;};func (_bce *RuneUint16Map )Range (f func (_afe rune ,_ae uint16 )(_eg bool )){_bce ._ed .RLock ();defer _bce ._ed .RUnlock ();for _gcd ,_agc :=range _bce ._fea {if f (_gcd ,_agc ){break ;};};};func MakeRuneByteMap (length int )*RuneByteMap {_cf :=make (map[rune ]byte ,length );
return &RuneByteMap {_fd :_cf };};func (_cdb *RuneSet )Range (f func (_ad rune )(_gc bool )){_cdb ._cdd .RLock ();defer _cdb ._cdd .RUnlock ();for _ec :=range _cdb ._ba {if f (_ec ){break ;};};};func (_cag *StringRuneMap )Write (g string ,r rune ){_cag ._gbc .Lock ();
defer _cag ._gbc .Unlock ();_cag ._bbb [g ]=r ;};func (_df *RuneUint16Map )Write (r rune ,g uint16 ){_df ._ed .Lock ();defer _df ._ed .Unlock ();_df ._fea [r ]=g ;};func (_ff *ByteRuneMap )Range (f func (_cd byte ,_age rune )(_e bool )){_ff ._f .RLock ();
defer _ff ._f .RUnlock ();for _ef ,_b :=range _ff ._ca {if f (_ef ,_b ){break ;};};};type StringRuneMap struct{_bbb map[string ]rune ;_gbc _d .RWMutex ;};func (_ce *RuneByteMap )Length ()int {_ce ._ab .RLock ();defer _ce ._ab .RUnlock ();return len (_ce ._fd )};
type RuneStringMap struct{_cb map[rune ]string ;_bbc _d .RWMutex ;};func NewRuneStringMap (m map[rune ]string )*RuneStringMap {return &RuneStringMap {_cb :m }};func NewStringsMap (tuples []StringsTuple )*StringsMap {_ega :=map[string ]string {};for _ ,_dfc :=range tuples {_ega [_dfc .Key ]=_dfc .Value ;
};return &StringsMap {_cec :_ega };};func (_fdb *RuneSet )Write (r rune ){_fdb ._cdd .Lock ();defer _fdb ._cdd .Unlock ();_fdb ._ba [r ]=struct{}{};};func (_deee *RuneUint16Map )RangeDelete (f func (_dg rune ,_gb uint16 )(_ee bool ,_bba bool )){_deee ._ed .Lock ();
defer _deee ._ed .Unlock ();for _cfa ,_fc :=range _deee ._fea {_gac ,_dgf :=f (_cfa ,_fc );if _gac {delete (_deee ._fea ,_cfa );};if _dgf {break ;};};};func NewStringRuneMap (m map[string ]rune )*StringRuneMap {return &StringRuneMap {_bbb :m }};type RuneSet struct{_ba map[rune ]struct{};
_cdd _d .RWMutex ;};func (_fe *ByteRuneMap )Length ()int {_fe ._f .RLock ();defer _fe ._f .RUnlock ();return len (_fe ._ca )};func (_eb *StringsMap )Read (g string )(string ,bool ){_eb ._daa .RLock ();defer _eb ._daa .RUnlock ();_fgf ,_add :=_eb ._cec [g ];
return _fgf ,_add ;};func MakeRuneUint16Map (length int )*RuneUint16Map {return &RuneUint16Map {_fea :make (map[rune ]uint16 ,length )};};type RuneUint16Map struct{_fea map[rune ]uint16 ;_ed _d .RWMutex ;};func (_ea *StringRuneMap )Read (g string )(rune ,bool ){_ea ._gbc .RLock ();
defer _ea ._gbc .RUnlock ();_dba ,_eae :=_ea ._bbb [g ];return _dba ,_eae ;};func (_ggg *RuneUint16Map )Delete (r rune ){_ggg ._ed .Lock ();defer _ggg ._ed .Unlock ();delete (_ggg ._fea ,r );};func (_gfd *StringsMap )Copy ()*StringsMap {_gfd ._daa .RLock ();
defer _gfd ._daa .RUnlock ();_fgbc :=map[string ]string {};for _gdf ,_cfd :=range _gfd ._cec {_fgbc [_gdf ]=_cfd ;};return &StringsMap {_cec :_fgbc };};func (_dee *RuneSet )Exists (r rune )bool {_dee ._cdd .RLock ();defer _dee ._cdd .RUnlock ();_ ,_bd :=_dee ._ba [r ];
return _bd ;};func (_db *ByteRuneMap )Read (b byte )(rune ,bool ){_db ._f .RLock ();defer _db ._f .RUnlock ();_a ,_de :=_db ._ca [b ];return _a ,_de ;};func (_fa *RuneByteMap )Range (f func (_aa rune ,_agb byte )(_af bool )){_fa ._ab .RLock ();defer _fa ._ab .RUnlock ();
for _bb ,_fgb :=range _fa ._fd {if f (_bb ,_fgb ){break ;};};};