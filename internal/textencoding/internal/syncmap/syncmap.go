//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package syncmap ;import _a "sync";func (_bdb *RuneUint16Map )Read (r rune )(uint16 ,bool ){_bdb ._cde .RLock ();defer _bdb ._cde .RUnlock ();_ebf ,_aea :=_bdb ._agg [r ];return _ebf ,_aea ;};func (_ag *RuneStringMap )Write (r rune ,s string ){_ag ._bd .Lock ();
defer _ag ._bd .Unlock ();_ag ._db [r ]=s ;};func (_beg *StringRuneMap )Read (g string )(rune ,bool ){_beg ._bda .RLock ();defer _beg ._bda .RUnlock ();_bbg ,_aee :=_beg ._efge [g ];return _bbg ,_aee ;};func (_bce *StringRuneMap )Write (g string ,r rune ){_bce ._bda .Lock ();
defer _bce ._bda .Unlock ();_bce ._efge [g ]=r ;};func (_fd *RuneByteMap )Range (f func (_be rune ,_ae byte )(_acf bool )){_fd ._g .RLock ();defer _fd ._g .RUnlock ();for _ebe ,_ad :=range _fd ._ef {if f (_ebe ,_ad ){break ;};};};type StringsTuple struct{Key ,Value string ;
};type ByteRuneMap struct{_e map[byte ]rune ;_b _a .RWMutex ;};func (_bbdb *StringsMap )Write (g1 ,g2 string ){_bbdb ._cee .Lock ();defer _bbdb ._cee .Unlock ();_bbdb ._cdde [g1 ]=g2 ;};func (_bdg *RuneUint16Map )Write (r rune ,g uint16 ){_bdg ._cde .Lock ();
defer _bdg ._cde .Unlock ();_bdg ._agg [r ]=g ;};func (_ac *ByteRuneMap )Read (b byte )(rune ,bool ){_ac ._b .RLock ();defer _ac ._b .RUnlock ();_acg ,_d :=_ac ._e [b ];return _acg ,_d ;};func (_gef *RuneUint16Map )Length ()int {_gef ._cde .RLock ();defer _gef ._cde .RUnlock ();
return len (_gef ._agg );};func (_bcc *RuneStringMap )Length ()int {_bcc ._bd .RLock ();defer _bcc ._bd .RUnlock ();return len (_bcc ._db );};type RuneStringMap struct{_db map[rune ]string ;_bd _a .RWMutex ;};func (_dd *ByteRuneMap )Write (b byte ,r rune ){_dd ._b .Lock ();
defer _dd ._b .Unlock ();_dd ._e [b ]=r };func NewRuneStringMap (m map[rune ]string )*RuneStringMap {return &RuneStringMap {_db :m }};func NewStringRuneMap (m map[string ]rune )*StringRuneMap {return &StringRuneMap {_efge :m }};func (_bc *RuneStringMap )Range (f func (_de rune ,_bgb string )(_df bool )){_bc ._bd .RLock ();
defer _bc ._bd .RUnlock ();for _ce ,_ee :=range _bc ._db {if f (_ce ,_ee ){break ;};};};func MakeByteRuneMap (length int )*ByteRuneMap {return &ByteRuneMap {_e :make (map[byte ]rune ,length )}};func MakeRuneByteMap (length int )*RuneByteMap {_cc :=make (map[rune ]byte ,length );
return &RuneByteMap {_ef :_cc };};func (_cg *ByteRuneMap )Range (f func (_ca byte ,_cd rune )(_eb bool )){_cg ._b .RLock ();defer _cg ._b .RUnlock ();for _f ,_bg :=range _cg ._e {if f (_f ,_bg ){break ;};};};type StringRuneMap struct{_efge map[string ]rune ;
_bda _a .RWMutex ;};func (_gga *RuneStringMap )Read (r rune )(string ,bool ){_gga ._bd .RLock ();defer _gga ._bd .RUnlock ();_bdd ,_aa :=_gga ._db [r ];return _bdd ,_aa ;};func (_cb *RuneByteMap )Write (r rune ,b byte ){_cb ._g .Lock ();defer _cb ._g .Unlock ();
_cb ._ef [r ]=b };func (_bge *RuneByteMap )Length ()int {_bge ._g .RLock ();defer _bge ._g .RUnlock ();return len (_bge ._ef )};func (_ge *RuneUint16Map )Range (f func (_ebd rune ,_bb uint16 )(_ace bool )){_ge ._cde .RLock ();defer _ge ._cde .RUnlock ();
for _deg ,_abb :=range _ge ._agg {if f (_deg ,_abb ){break ;};};};func (_eeg *StringsMap )Read (g string )(string ,bool ){_eeg ._cee .RLock ();defer _eeg ._cee .RUnlock ();_fc ,_eaa :=_eeg ._cdde [g ];return _fc ,_eaa ;};func (_efg *RuneUint16Map )RangeDelete (f func (_fb rune ,_cfd uint16 )(_dee bool ,_eab bool )){_efg ._cde .Lock ();
defer _efg ._cde .Unlock ();for _ec ,_ba :=range _efg ._agg {_acb ,_fdf :=f (_ec ,_ba );if _acb {delete (_efg ._agg ,_ec );};if _fdf {break ;};};};type RuneByteMap struct{_ef map[rune ]byte ;_g _a .RWMutex ;};func NewByteRuneMap (m map[byte ]rune )*ByteRuneMap {return &ByteRuneMap {_e :m }};
func NewStringsMap (tuples []StringsTuple )*StringsMap {_ebb :=map[string ]string {};for _ ,_cdd :=range tuples {_ebb [_cdd .Key ]=_cdd .Value ;};return &StringsMap {_cdde :_ebb };};func (_fg *ByteRuneMap )Length ()int {_fg ._b .RLock ();defer _fg ._b .RUnlock ();
return len (_fg ._e )};func (_cgf *RuneByteMap )Read (r rune )(byte ,bool ){_cgf ._g .RLock ();defer _cgf ._g .RUnlock ();_dda ,_caf :=_cgf ._ef [r ];return _dda ,_caf ;};func (_cf *RuneSet )Range (f func (_ea rune )(_gg bool )){_cf ._fa .RLock ();defer _cf ._fa .RUnlock ();
for _bgc :=range _cf ._ccd {if f (_bgc ){break ;};};};func (_cdc *StringsMap )Copy ()*StringsMap {_cdc ._cee .RLock ();defer _cdc ._cee .RUnlock ();_gf :=map[string ]string {};for _bab ,_agf :=range _cdc ._cdde {_gf [_bab ]=_agf ;};return &StringsMap {_cdde :_gf };
};type StringsMap struct{_cdde map[string ]string ;_cee _a .RWMutex ;};func MakeRuneSet (length int )*RuneSet {return &RuneSet {_ccd :make (map[rune ]struct{},length )}};func (_adb *RuneSet )Exists (r rune )bool {_adb ._fa .RLock ();defer _adb ._fa .RUnlock ();
_ ,_fgg :=_adb ._ccd [r ];return _fgg ;};func (_dc *StringRuneMap )Range (f func (_bbd string ,_fe rune )(_ega bool )){_dc ._bda .RLock ();defer _dc ._bda .RUnlock ();for _af ,_ecf :=range _dc ._efge {if f (_af ,_ecf ){break ;};};};func (_gb *RuneUint16Map )Delete (r rune ){_gb ._cde .Lock ();
defer _gb ._cde .Unlock ();delete (_gb ._agg ,r );};type RuneUint16Map struct{_agg map[rune ]uint16 ;_cde _a .RWMutex ;};func MakeRuneUint16Map (length int )*RuneUint16Map {return &RuneUint16Map {_agg :make (map[rune ]uint16 ,length )};};type RuneSet struct{_ccd map[rune ]struct{};
_fa _a .RWMutex ;};func (_aggc *StringsMap )Range (f func (_eac ,_dg string )(_cgd bool )){_aggc ._cee .RLock ();defer _aggc ._cee .RUnlock ();for _eba ,_cfa :=range _aggc ._cdde {if f (_eba ,_cfa ){break ;};};};func (_bea *RuneSet )Write (r rune ){_bea ._fa .Lock ();
defer _bea ._fa .Unlock ();_bea ._ccd [r ]=struct{}{};};func (_afc *StringRuneMap )Length ()int {_afc ._bda .RLock ();defer _afc ._bda .RUnlock ();return len (_afc ._efge );};func (_eg *RuneSet )Length ()int {_eg ._fa .RLock ();defer _eg ._fa .RUnlock ();
return len (_eg ._ccd )};