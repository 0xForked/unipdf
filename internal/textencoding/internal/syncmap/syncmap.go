//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package syncmap ;import _d "sync";type RuneByteMap struct{_ed map[rune ]byte ;_ee _d .RWMutex ;};func (_cde *RuneStringMap )Range (f func (_cdd rune ,_dac string )(_bgd bool )){_cde ._ea .RLock ();defer _cde ._ea .RUnlock ();for _eb ,_ae :=range _cde ._dgd {if f (_eb ,_ae ){break ;
};};};func (_gde *RuneByteMap )Write (r rune ,b byte ){_gde ._ee .Lock ();defer _gde ._ee .Unlock ();_gde ._ed [r ]=b ;};func (_gb *RuneUint16Map )Write (r rune ,g uint16 ){_gb ._eed .Lock ();defer _gb ._eed .Unlock ();_gb ._fbg [r ]=g ;};func MakeRuneByteMap (length int )*RuneByteMap {_ce :=make (map[rune ]byte ,length );
return &RuneByteMap {_ed :_ce };};type RuneSet struct{_ceg map[rune ]struct{};_bb _d .RWMutex ;};func (_edb *RuneUint16Map )Length ()int {_edb ._eed .RLock ();defer _edb ._eed .RUnlock ();return len (_edb ._fbg );};func (_ec *RuneByteMap )Read (r rune )(byte ,bool ){_ec ._ee .RLock ();
defer _ec ._ee .RUnlock ();_dc ,_gd :=_ec ._ed [r ];return _dc ,_gd ;};func MakeRuneUint16Map (length int )*RuneUint16Map {return &RuneUint16Map {_fbg :make (map[rune ]uint16 ,length )};};func MakeRuneSet (length int )*RuneSet {return &RuneSet {_ceg :make (map[rune ]struct{},length )}};
func (_gf *RuneSet )Write (r rune ){_gf ._bb .Lock ();defer _gf ._bb .Unlock ();_gf ._ceg [r ]=struct{}{}};func NewStringRuneMap (m map[string ]rune )*StringRuneMap {return &StringRuneMap {_bfe :m }};func (_cdc *RuneUint16Map )Range (f func (_de rune ,_dge uint16 )(_faf bool )){_cdc ._eed .RLock ();
defer _cdc ._eed .RUnlock ();for _ca ,_aaf :=range _cdc ._fbg {if f (_ca ,_aaf ){break ;};};};func (_fa *RuneStringMap )Write (r rune ,s string ){_fa ._ea .Lock ();defer _fa ._ea .Unlock ();_fa ._dgd [r ]=s ;};func (_daca *RuneUint16Map )RangeDelete (f func (_gaa rune ,_bd uint16 )(_aaa bool ,_fbd bool )){_daca ._eed .Lock ();
defer _daca ._eed .Unlock ();for _ddb ,_gff :=range _daca ._fbg {_gdb ,_ef :=f (_ddb ,_gff );if _gdb {delete (_daca ._fbg ,_ddb );};if _ef {break ;};};};func (_bdf *StringsMap )Write (g1 ,g2 string ){_bdf ._eeg .Lock ();defer _bdf ._eeg .Unlock ();_bdf ._fg [g1 ]=g2 ;
};func (_bf *RuneSet )Exists (r rune )bool {_bf ._bb .RLock ();defer _bf ._bb .RUnlock ();_ ,_ga :=_bf ._ceg [r ];return _ga ;};type RuneUint16Map struct{_fbg map[rune ]uint16 ;_eed _d .RWMutex ;};type StringsMap struct{_fg map[string ]string ;_eeg _d .RWMutex ;
};func (_ggdg *StringRuneMap )Write (g string ,r rune ){_ggdg ._fde .Lock ();defer _ggdg ._fde .Unlock ();_ggdg ._bfe [g ]=r ;};func NewByteRuneMap (m map[byte ]rune )*ByteRuneMap {return &ByteRuneMap {_b :m }};func (_aa *RuneByteMap )Length ()int {_aa ._ee .RLock ();
defer _aa ._ee .RUnlock ();return len (_aa ._ed )};type StringsTuple struct{Key ,Value string ;};func NewStringsMap (tuples []StringsTuple )*StringsMap {_dea :=map[string ]string {};for _ ,_dgb :=range tuples {_dea [_dgb .Key ]=_dgb .Value ;};return &StringsMap {_fg :_dea };
};func MakeByteRuneMap (length int )*ByteRuneMap {return &ByteRuneMap {_b :make (map[byte ]rune ,length )}};func (_ag *StringsMap )Range (f func (_caa ,_dbf string )(_ddbg bool )){_ag ._eeg .RLock ();defer _ag ._eeg .RUnlock ();for _egc ,_eec :=range _ag ._fg {if f (_egc ,_eec ){break ;
};};};func (_ba *ByteRuneMap )Range (f func (_ge byte ,_geb rune )(_f bool )){_ba ._a .RLock ();defer _ba ._a .RUnlock ();for _e ,_bgb :=range _ba ._b {if f (_e ,_bgb ){break ;};};};type StringRuneMap struct{_bfe map[string ]rune ;_fde _d .RWMutex ;};func (_ad *RuneUint16Map )Read (r rune )(uint16 ,bool ){_ad ._eed .RLock ();
defer _ad ._eed .RUnlock ();_cbe ,_aad :=_ad ._fbg [r ];return _cbe ,_aad ;};func (_da *RuneSet )Range (f func (_eef rune )(_dd bool )){_da ._bb .RLock ();defer _da ._bb .RUnlock ();for _fbf :=range _da ._ceg {if f (_fbf ){break ;};};};func (_db *ByteRuneMap )Read (b byte )(rune ,bool ){_db ._a .RLock ();
defer _db ._a .RUnlock ();_bg ,_gc :=_db ._b [b ];return _bg ,_gc ;};func (_bgg *StringsMap )Read (g string )(string ,bool ){_bgg ._eeg .RLock ();defer _bgg ._eeg .RUnlock ();_bbbd ,_dad :=_bgg ._fg [g ];return _bbbd ,_dad ;};func (_efg *StringRuneMap )Read (g string )(rune ,bool ){_efg ._fde .RLock ();
defer _efg ._fde .RUnlock ();_dacb ,_bfb :=_efg ._bfe [g ];return _dacb ,_bfb ;};func (_dbb *RuneUint16Map )Delete (r rune ){_dbb ._eed .Lock ();defer _dbb ._eed .Unlock ();delete (_dbb ._fbg ,r );};func (_dg *RuneByteMap )Range (f func (_fd rune ,_cb byte )(_bac bool )){_dg ._ee .RLock ();
defer _dg ._ee .RUnlock ();for _eea ,_gg :=range _dg ._ed {if f (_eea ,_gg ){break ;};};};type RuneStringMap struct{_dgd map[rune ]string ;_ea _d .RWMutex ;};func (_cd *RuneSet )Length ()int {_cd ._bb .RLock ();defer _cd ._bb .RUnlock ();return len (_cd ._ceg )};
func (_c *ByteRuneMap )Write (b byte ,r rune ){_c ._a .Lock ();defer _c ._a .Unlock ();_c ._b [b ]=r };func (_aea *StringsMap )Copy ()*StringsMap {_aea ._eeg .RLock ();defer _aea ._eeg .RUnlock ();_fbe :=map[string ]string {};for _cc ,_ged :=range _aea ._fg {_fbe [_cc ]=_ged ;
};return &StringsMap {_fg :_fbe };};func (_bc *StringRuneMap )Length ()int {_bc ._fde .RLock ();defer _bc ._fde .RUnlock ();return len (_bc ._bfe );};type ByteRuneMap struct{_b map[byte ]rune ;_a _d .RWMutex ;};func (_gcc *StringRuneMap )Range (f func (_ecf string ,_eg rune )(_bbb bool )){_gcc ._fde .RLock ();
defer _gcc ._fde .RUnlock ();for _eedg ,_cg :=range _gcc ._bfe {if f (_eedg ,_cg ){break ;};};};func (_ac *RuneStringMap )Length ()int {_ac ._ea .RLock ();defer _ac ._ea .RUnlock ();return len (_ac ._dgd );};func (_fe *RuneStringMap )Read (r rune )(string ,bool ){_fe ._ea .RLock ();
defer _fe ._ea .RUnlock ();_ddg ,_be :=_fe ._dgd [r ];return _ddg ,_be ;};func NewRuneStringMap (m map[rune ]string )*RuneStringMap {return &RuneStringMap {_dgd :m }};func (_fb *ByteRuneMap )Length ()int {_fb ._a .RLock ();defer _fb ._a .RUnlock ();return len (_fb ._b )};
