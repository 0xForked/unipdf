//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package syncmap ;import _f "sync";func (_cda *RuneUint16Map )Delete (r rune ){_cda ._fcd .Lock ();defer _cda ._fcd .Unlock ();delete (_cda ._abd ,r );};type RuneByteMap struct{_ea map[rune ]byte ;_ccf _f .RWMutex ;};func (_daf *RuneByteMap )Read (r rune )(byte ,bool ){_daf ._ccf .RLock ();
defer _daf ._ccf .RUnlock ();_dac ,_af :=_daf ._ea [r ];return _dac ,_af ;};type StringsMap struct{_dag map[string ]string ;_bfd _f .RWMutex ;};type RuneUint16Map struct{_abd map[rune ]uint16 ;_fcd _f .RWMutex ;};func (_gd *RuneByteMap )Length ()int {_gd ._ccf .RLock ();
defer _gd ._ccf .RUnlock ();return len (_gd ._ea )};func MakeRuneByteMap (length int )*RuneByteMap {_ae :=make (map[rune ]byte ,length );return &RuneByteMap {_ea :_ae };};func MakeRuneUint16Map (length int )*RuneUint16Map {return &RuneUint16Map {_abd :make (map[rune ]uint16 ,length )};
};func MakeRuneSet (length int )*RuneSet {return &RuneSet {_ag :make (map[rune ]struct{},length )}};func (_aee *RuneStringMap )Length ()int {_aee ._cfe .RLock ();defer _aee ._cfe .RUnlock ();return len (_aee ._gf );};func (_fae *StringRuneMap )Write (g string ,r rune ){_fae ._gadc .Lock ();
defer _fae ._gadc .Unlock ();_fae ._egd [g ]=r ;};func (_eaf *RuneStringMap )Write (r rune ,s string ){_eaf ._cfe .Lock ();defer _eaf ._cfe .Unlock ();_eaf ._gf [r ]=s ;};func NewStringRuneMap (m map[string ]rune )*StringRuneMap {return &StringRuneMap {_egd :m }};
type ByteRuneMap struct{_g map[byte ]rune ;_d _f .RWMutex ;};func (_baf *RuneUint16Map )Write (r rune ,g uint16 ){_baf ._fcd .Lock ();defer _baf ._fcd .Unlock ();_baf ._abd [r ]=g ;};func (_age *StringsMap )Write (g1 ,g2 string ){_age ._bfd .Lock ();defer _age ._bfd .Unlock ();
_age ._dag [g1 ]=g2 ;};func (_gbc *RuneUint16Map )RangeDelete (f func (_fcb rune ,_abc uint16 )(_dge bool ,_agb bool )){_gbc ._fcd .Lock ();defer _gbc ._fcd .Unlock ();for _cag ,_cd :=range _gbc ._abd {_aac ,_gadf :=f (_cag ,_cd );if _aac {delete (_gbc ._abd ,_cag );
};if _gadf {break ;};};};func NewRuneStringMap (m map[rune ]string )*RuneStringMap {return &RuneStringMap {_gf :m }};func (_bgc *StringsMap )Copy ()*StringsMap {_bgc ._bfd .RLock ();defer _bgc ._bfd .RUnlock ();_cccf :=map[string ]string {};for _cfd ,_df :=range _bgc ._dag {_cccf [_cfd ]=_df ;
};return &StringsMap {_dag :_cccf };};func (_agg *StringRuneMap )Range (f func (_fed string ,_bag rune )(_bf bool )){_agg ._gadc .RLock ();defer _agg ._gadc .RUnlock ();for _ffa ,_de :=range _agg ._egd {if f (_ffa ,_de ){break ;};};};func (_gad *RuneSet )Length ()int {_gad ._gef .RLock ();
defer _gad ._gef .RUnlock ();return len (_gad ._ag )};func (_da *ByteRuneMap )Length ()int {_da ._d .RLock ();defer _da ._d .RUnlock ();return len (_da ._g )};type RuneStringMap struct{_gf map[rune ]string ;_cfe _f .RWMutex ;};func (_dd *ByteRuneMap )Range (f func (_ddd byte ,_c rune )(_cc bool )){_dd ._d .RLock ();
defer _dd ._d .RUnlock ();for _fc ,_ga :=range _dd ._g {if f (_fc ,_ga ){break ;};};};func (_ed *RuneUint16Map )Range (f func (_abg rune ,_gdg uint16 )(_ee bool )){_ed ._fcd .RLock ();defer _ed ._fcd .RUnlock ();for _cg ,_fcf :=range _ed ._abd {if f (_cg ,_fcf ){break ;
};};};func (_dg *RuneSet )Range (f func (_fff rune )(_fca bool )){_dg ._gef .RLock ();defer _dg ._gef .RUnlock ();for _aef :=range _dg ._ag {if f (_aef ){break ;};};};type RuneSet struct{_ag map[rune ]struct{};_gef _f .RWMutex ;};func (_aa *RuneUint16Map )Read (r rune )(uint16 ,bool ){_aa ._fcd .RLock ();
defer _aa ._fcd .RUnlock ();_aed ,_gb :=_aa ._abd [r ];return _aed ,_gb ;};type StringRuneMap struct{_egd map[string ]rune ;_gadc _f .RWMutex ;};func (_fbb *StringsMap )Range (f func (_ccc ,_fbe string )(_faeg bool )){_fbb ._bfd .RLock ();defer _fbb ._bfd .RUnlock ();
for _gfd ,_edc :=range _fbb ._dag {if f (_gfd ,_edc ){break ;};};};func (_bb *RuneSet )Write (r rune ){_bb ._gef .Lock ();defer _bb ._gef .Unlock ();_bb ._ag [r ]=struct{}{}};func (_cde *StringsMap )Read (g string )(string ,bool ){_cde ._bfd .RLock ();
defer _cde ._bfd .RUnlock ();_efa ,_dab :=_cde ._dag [g ];return _efa ,_dab ;};func NewByteRuneMap (m map[byte ]rune )*ByteRuneMap {return &ByteRuneMap {_g :m }};func (_bc *StringRuneMap )Length ()int {_bc ._gadc .RLock ();defer _bc ._gadc .RUnlock ();
return len (_bc ._egd );};func (_ba *ByteRuneMap )Write (b byte ,r rune ){_ba ._d .Lock ();defer _ba ._d .Unlock ();_ba ._g [b ]=r };func (_fb *StringRuneMap )Read (g string )(rune ,bool ){_fb ._gadc .RLock ();defer _fb ._gadc .RUnlock ();_ef ,_gg :=_fb ._egd [g ];
return _ef ,_gg ;};func (_fe *RuneByteMap )Write (r rune ,b byte ){_fe ._ccf .Lock ();defer _fe ._ccf .Unlock ();_fe ._ea [r ]=b ;};func (_fd *RuneByteMap )Range (f func (_bg rune ,_ff byte )(_fee bool )){_fd ._ccf .RLock ();defer _fd ._ccf .RUnlock ();
for _ge ,_cf :=range _fd ._ea {if f (_ge ,_cf ){break ;};};};func (_gff *RuneStringMap )Read (r rune )(string ,bool ){_gff ._cfe .RLock ();defer _gff ._cfe .RUnlock ();_gag ,_gc :=_gff ._gf [r ];return _gag ,_gc ;};type StringsTuple struct{Key ,Value string ;
};func NewStringsMap (tuples []StringsTuple )*StringsMap {_feb :=map[string ]string {};for _ ,_egf :=range tuples {_feb [_egf .Key ]=_egf .Value ;};return &StringsMap {_dag :_feb };};func (_ab *RuneStringMap )Range (f func (_cb rune ,_caf string )(_dda bool )){_ab ._cfe .RLock ();
defer _ab ._cfe .RUnlock ();for _bgd ,_ddg :=range _ab ._gf {if f (_bgd ,_ddg ){break ;};};};func MakeByteRuneMap (length int )*ByteRuneMap {return &ByteRuneMap {_g :make (map[byte ]rune ,length )}};func (_e *ByteRuneMap )Read (b byte )(rune ,bool ){_e ._d .RLock ();
defer _e ._d .RUnlock ();_dc ,_b :=_e ._g [b ];return _dc ,_b ;};func (_ca *RuneSet )Exists (r rune )bool {_ca ._gef .RLock ();defer _ca ._gef .RUnlock ();_ ,_eg :=_ca ._ag [r ];return _eg ;};func (_fag *RuneUint16Map )Length ()int {_fag ._fcd .RLock ();
defer _fag ._fcd .RUnlock ();return len (_fag ._abd );};