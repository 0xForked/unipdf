//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package syncmap ;import _c "sync";func (_ge *RuneSet )Exists (r rune )bool {_ge ._ag .RLock ();defer _ge ._ag .RUnlock ();_ ,_dbd :=_ge ._dd [r ];return _dbd ;};func (_da *RuneUint16Map )Write (r rune ,g uint16 ){_da ._bf .Lock ();defer _da ._bf .Unlock ();
_da ._ggc [r ]=g ;};func (_fgg *RuneByteMap )Length ()int {_fgg ._fc .RLock ();defer _fgg ._fc .RUnlock ();return len (_fgg ._ed );};func (_ba *RuneSet )Length ()int {_ba ._ag .RLock ();defer _ba ._ag .RUnlock ();return len (_ba ._dd )};func (_ea *ByteRuneMap )Length ()int {_ea ._f .RLock ();
defer _ea ._f .RUnlock ();return len (_ea ._gg )};func MakeByteRuneMap (length int )*ByteRuneMap {return &ByteRuneMap {_gg :make (map[byte ]rune ,length )}};func (_bg *RuneByteMap )Write (r rune ,b byte ){_bg ._fc .Lock ();defer _bg ._fc .Unlock ();_bg ._ed [r ]=b };
type StringsTuple struct{Key ,Value string ;};func NewStringsMap (tuples []StringsTuple )*StringsMap {_fed :=map[string ]string {};for _ ,_aga :=range tuples {_fed [_aga .Key ]=_aga .Value ;};return &StringsMap {_geg :_fed };};func MakeRuneByteMap (length int )*RuneByteMap {_bc :=make (map[rune ]byte ,length );
return &RuneByteMap {_ed :_bc };};func (_cg *RuneStringMap )Read (r rune )(string ,bool ){_cg ._bcb .RLock ();defer _cg ._bcb .RUnlock ();_bbd ,_bgf :=_cg ._ggg [r ];return _bbd ,_bgf ;};func (_agc *StringRuneMap )Range (f func (_ebd string ,_cbg rune )(_aa bool )){_agc ._dec .RLock ();
defer _agc ._dec .RUnlock ();for _fea ,_eg :=range _agc ._dab {if f (_fea ,_eg ){break ;};};};type StringsMap struct{_geg map[string ]string ;_gbc _c .RWMutex ;};func (_ee *RuneSet )Write (r rune ){_ee ._ag .Lock ();defer _ee ._ag .Unlock ();_ee ._dd [r ]=struct{}{}};
func (_ec *RuneStringMap )Range (f func (_dfg rune ,_cdf string )(_eca bool )){_ec ._bcb .RLock ();defer _ec ._bcb .RUnlock ();for _dda ,_gfa :=range _ec ._ggg {if f (_dda ,_gfa ){break ;};};};type RuneByteMap struct{_ed map[rune ]byte ;_fc _c .RWMutex ;
};func (_add *StringsMap )Write (g1 ,g2 string ){_add ._gbc .Lock ();defer _add ._gbc .Unlock ();_add ._geg [g1 ]=g2 ;};func NewRuneStringMap (m map[rune ]string )*RuneStringMap {return &RuneStringMap {_ggg :m }};type RuneStringMap struct{_ggg map[rune ]string ;
_bcb _c .RWMutex ;};type RuneSet struct{_dd map[rune ]struct{};_ag _c .RWMutex ;};func (_fe *StringRuneMap )Read (g string )(rune ,bool ){_fe ._dec .RLock ();defer _fe ._dec .RUnlock ();_afc ,_ddc :=_fe ._dab [g ];return _afc ,_ddc ;};func (_agda *RuneSet )Range (f func (_ff rune )(_fb bool )){_agda ._ag .RLock ();
defer _agda ._ag .RUnlock ();for _ga :=range _agda ._dd {if f (_ga ){break ;};};};func (_ae *RuneUint16Map )Range (f func (_bde rune ,_eac uint16 )(_bbg bool )){_ae ._bf .RLock ();defer _ae ._bf .RUnlock ();for _bcd ,_baa :=range _ae ._ggc {if f (_bcd ,_baa ){break ;
};};};type StringRuneMap struct{_dab map[string ]rune ;_dec _c .RWMutex ;};func MakeRuneSet (length int )*RuneSet {return &RuneSet {_dd :make (map[rune ]struct{},length )}};func (_cbf *StringRuneMap )Write (g string ,r rune ){_cbf ._dec .Lock ();defer _cbf ._dec .Unlock ();
_cbf ._dab [g ]=r ;};func (_dfb *RuneUint16Map )Read (r rune )(uint16 ,bool ){_dfb ._bf .RLock ();defer _dfb ._bf .RUnlock ();_bd ,_dcc :=_dfb ._ggc [r ];return _bd ,_dcc ;};type ByteRuneMap struct{_gg map[byte ]rune ;_f _c .RWMutex ;};func (_bfa *StringRuneMap )Length ()int {_bfa ._dec .RLock ();
defer _bfa ._dec .RUnlock ();return len (_bfa ._dab );};func (_fa *ByteRuneMap )Write (b byte ,r rune ){_fa ._f .Lock ();defer _fa ._f .Unlock ();_fa ._gg [b ]=r };type RuneUint16Map struct{_ggc map[rune ]uint16 ;_bf _c .RWMutex ;};func NewStringRuneMap (m map[string ]rune )*StringRuneMap {return &StringRuneMap {_dab :m }};
func (_adc *StringsMap )Copy ()*StringsMap {_adc ._gbc .RLock ();defer _adc ._gbc .RUnlock ();_ef :=map[string ]string {};for _bfg ,_gcd :=range _adc ._geg {_ef [_bfg ]=_gcd ;};return &StringsMap {_geg :_ef };};func (_af *RuneByteMap )Range (f func (_dbe rune ,_dee byte )(_cd bool )){_af ._fc .RLock ();
defer _af ._fc .RUnlock ();for _bb ,_dc :=range _af ._ed {if f (_bb ,_dc ){break ;};};};func (_ac *RuneByteMap )Read (r rune )(byte ,bool ){_ac ._fc .RLock ();defer _ac ._fc .RUnlock ();_dbc ,_cb :=_ac ._ed [r ];return _dbc ,_cb ;};func (_cgb *StringsMap )Read (g string )(string ,bool ){_cgb ._gbc .RLock ();
defer _cgb ._gbc .RUnlock ();_gd ,_agbc :=_cgb ._geg [g ];return _gd ,_agbc ;};func (_ad *RuneStringMap )Write (r rune ,s string ){_ad ._bcb .Lock ();defer _ad ._bcb .Unlock ();_ad ._ggg [r ]=s ;};func (_d *ByteRuneMap )Read (b byte )(rune ,bool ){_d ._f .RLock ();
defer _d ._f .RUnlock ();_df ,_b :=_d ._gg [b ];return _df ,_b ;};func (_dfd *RuneUint16Map )Length ()int {_dfd ._bf .RLock ();defer _dfd ._bf .RUnlock ();return len (_dfd ._ggc );};func NewByteRuneMap (m map[byte ]rune )*ByteRuneMap {return &ByteRuneMap {_gg :m }};
func MakeRuneUint16Map (length int )*RuneUint16Map {return &RuneUint16Map {_ggc :make (map[rune ]uint16 ,length )};};func (_dbeb *StringsMap )Range (f func (_gge ,_def string )(_fgd bool )){_dbeb ._gbc .RLock ();defer _dbeb ._gbc .RUnlock ();for _acb ,_gc :=range _dbeb ._geg {if f (_acb ,_gc ){break ;
};};};func (_eeg *RuneUint16Map )RangeDelete (f func (_bdf rune ,_dbec uint16 )(_eb bool ,_fcb bool )){_eeg ._bf .Lock ();defer _eeg ._bf .Unlock ();for _gb ,_gaf :=range _eeg ._ggc {_fbf ,_agb :=f (_gb ,_gaf );if _fbf {delete (_eeg ._ggc ,_gb );};if _agb {break ;
};};};func (_ffe *RuneStringMap )Length ()int {_ffe ._bcb .RLock ();defer _ffe ._bcb .RUnlock ();return len (_ffe ._ggg );};func (_ca *RuneUint16Map )Delete (r rune ){_ca ._bf .Lock ();defer _ca ._bf .Unlock ();delete (_ca ._ggc ,r )};func (_fg *ByteRuneMap )Range (f func (_gf byte ,_e rune )(_a bool )){_fg ._f .RLock ();
defer _fg ._f .RUnlock ();for _de ,_db :=range _fg ._gg {if f (_de ,_db ){break ;};};};