//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package syncmap ;import _f "sync";func (_gbe *RuneUint16Map )Read (r rune )(uint16 ,bool ){_gbe ._db .RLock ();defer _gbe ._db .RUnlock ();_ad ,_dcfe :=_gbe ._ae [r ];return _ad ,_dcfe ;};func (_fgdf *RuneUint16Map )Length ()int {_fgdf ._db .RLock ();defer _fgdf ._db .RUnlock ();
return len (_fgdf ._ae );};type RuneByteMap struct{_fb map[rune ]byte ;_fc _f .RWMutex ;};func (_ea *RuneByteMap )Range (f func (_fd rune ,_cb byte )(_da bool )){_ea ._fc .RLock ();defer _ea ._fc .RUnlock ();for _df ,_dcf :=range _ea ._fb {if f (_df ,_dcf ){break ;
};};};func MakeRuneSet (length int )*RuneSet {return &RuneSet {_acd :make (map[rune ]struct{},length )}};func (_fga *RuneByteMap )Length ()int {_fga ._fc .RLock ();defer _fga ._fc .RUnlock ();return len (_fga ._fb );};func NewRuneStringMap (m map[rune ]string )*RuneStringMap {return &RuneStringMap {_fcg :m }};
func MakeByteRuneMap (length int )*ByteRuneMap {return &ByteRuneMap {_g :make (map[byte ]rune ,length )}};func (_dad *RuneSet )Range (f func (_ee rune )(_dg bool )){_dad ._ef .RLock ();defer _dad ._ef .RUnlock ();for _fgd :=range _dad ._acd {if f (_fgd ){break ;
};};};type RuneUint16Map struct{_ae map[rune ]uint16 ;_db _f .RWMutex ;};func (_a *ByteRuneMap )Read (b byte )(rune ,bool ){_a ._gc .RLock ();defer _a ._gc .RUnlock ();_ga ,_b :=_a ._g [b ];return _ga ,_b ;};func (_eb *RuneSet )Write (r rune ){_eb ._ef .Lock ();
defer _eb ._ef .Unlock ();_eb ._acd [r ]=struct{}{}};type StringsTuple struct{Key ,Value string ;};func NewStringsMap (tuples []StringsTuple )*StringsMap {_ace :=map[string ]string {};for _ ,_bbe :=range tuples {_ace [_bbe .Key ]=_bbe .Value ;};return &StringsMap {_dfd :_ace };
};func (_gac *ByteRuneMap )Length ()int {_gac ._gc .RLock ();defer _gac ._gc .RUnlock ();return len (_gac ._g );};func (_cbe *StringsMap )Range (f func (_ceg ,_bgc string )(_fe bool )){_cbe ._gee .RLock ();defer _cbe ._gee .RUnlock ();for _dcb ,_dcba :=range _cbe ._dfd {if f (_dcb ,_dcba ){break ;
};};};type RuneSet struct{_acd map[rune ]struct{};_ef _f .RWMutex ;};func NewByteRuneMap (m map[byte ]rune )*ByteRuneMap {return &ByteRuneMap {_g :m }};func (_be *RuneSet )Length ()int {_be ._ef .RLock ();defer _be ._ef .RUnlock ();return len (_be ._acd )};
type RuneStringMap struct{_fcg map[rune ]string ;_bc _f .RWMutex ;};func MakeRuneByteMap (length int )*RuneByteMap {_baf :=make (map[rune ]byte ,length );return &RuneByteMap {_fb :_baf };};func NewStringRuneMap (m map[string ]rune )*StringRuneMap {return &StringRuneMap {_fded :m }};
func (_gg *RuneStringMap )Length ()int {_gg ._bc .RLock ();defer _gg ._bc .RUnlock ();return len (_gg ._fcg );};func (_c *ByteRuneMap )Write (b byte ,r rune ){_c ._gc .Lock ();defer _c ._gc .Unlock ();_c ._g [b ]=r };func (_gff *StringRuneMap )Read (g string )(rune ,bool ){_gff ._bae .RLock ();
defer _gff ._bae .RUnlock ();_efff ,_bec :=_gff ._fded [g ];return _efff ,_bec ;};func (_fbda *StringsMap )Write (g1 ,g2 string ){_fbda ._gee .Lock ();defer _fbda ._gee .Unlock ();_fbda ._dfd [g1 ]=g2 ;};func (_fdf *StringRuneMap )Write (g string ,r rune ){_fdf ._bae .Lock ();
defer _fdf ._bae .Unlock ();_fdf ._fded [g ]=r ;};type StringRuneMap struct{_fded map[string ]rune ;_bae _f .RWMutex ;};func (_acf *StringsMap )Copy ()*StringsMap {_acf ._gee .RLock ();defer _acf ._gee .RUnlock ();_bab :=map[string ]string {};for _eeg ,_bgb :=range _acf ._dfd {_bab [_eeg ]=_bgb ;
};return &StringsMap {_dfd :_bab };};type StringsMap struct{_dfd map[string ]string ;_gee _f .RWMutex ;};func (_eaa *StringRuneMap )Range (f func (_bd string ,_ddb rune )(_ecf bool )){_eaa ._bae .RLock ();defer _eaa ._bae .RUnlock ();for _cg ,_gfa :=range _eaa ._fded {if f (_cg ,_gfa ){break ;
};};};func (_cf *RuneStringMap )Read (r rune )(string ,bool ){_cf ._bc .RLock ();defer _cf ._bc .RUnlock ();_af ,_fbd :=_cf ._fcg [r ];return _af ,_fbd ;};func (_bga *StringRuneMap )Length ()int {_bga ._bae .RLock ();defer _bga ._bae .RUnlock ();return len (_bga ._fded );
};func (_gcg *RuneSet )Exists (r rune )bool {_gcg ._ef .RLock ();defer _gcg ._ef .RUnlock ();_ ,_dd :=_gcg ._acd [r ];return _dd ;};func (_ec *RuneStringMap )Range (f func (_gb rune ,_acb string )(_bb bool )){_ec ._bc .RLock ();defer _ec ._bc .RUnlock ();
for _aa ,_eff :=range _ec ._fcg {if f (_aa ,_eff ){break ;};};};func (_fa *RuneByteMap )Read (r rune )(byte ,bool ){_fa ._fc .RLock ();defer _fa ._fc .RUnlock ();_e ,_fg :=_fa ._fb [r ];return _e ,_fg ;};func MakeRuneUint16Map (length int )*RuneUint16Map {return &RuneUint16Map {_ae :make (map[rune ]uint16 ,length )};
};func (_ebf *RuneUint16Map )Range (f func (_bag rune ,_fbdc uint16 )(_gfc bool )){_ebf ._db .RLock ();defer _ebf ._db .RUnlock ();for _cba ,_faa :=range _ebf ._ae {if f (_cba ,_faa ){break ;};};};func (_fbc *RuneUint16Map )Write (r rune ,g uint16 ){_fbc ._db .Lock ();
defer _fbc ._db .Unlock ();_fbc ._ae [r ]=g ;};func (_fab *RuneByteMap )Write (r rune ,b byte ){_fab ._fc .Lock ();defer _fab ._fc .Unlock ();_fab ._fb [r ]=b ;};func (_cbf *RuneUint16Map )RangeDelete (f func (_gaf rune ,_fgg uint16 )(_gbec bool ,_bg bool )){_cbf ._db .Lock ();
defer _cbf ._db .Unlock ();for _fde ,_aef :=range _cbf ._ae {_bafd ,_eaf :=f (_fde ,_aef );if _bafd {delete (_cbf ._ae ,_fde );};if _eaf {break ;};};};func (_ed *RuneStringMap )Write (r rune ,s string ){_ed ._bc .Lock ();defer _ed ._bc .Unlock ();_ed ._fcg [r ]=s ;
};func (_cd *ByteRuneMap )Range (f func (_bf byte ,_gf rune )(_ba bool )){_cd ._gc .RLock ();defer _cd ._gc .RUnlock ();for _ac ,_dc :=range _cd ._g {if f (_ac ,_dc ){break ;};};};func (_ge *RuneUint16Map )Delete (r rune ){_ge ._db .Lock ();defer _ge ._db .Unlock ();
delete (_ge ._ae ,r )};type ByteRuneMap struct{_g map[byte ]rune ;_gc _f .RWMutex ;};func (_ce *StringsMap )Read (g string )(string ,bool ){_ce ._gee .RLock ();defer _ce ._gee .RUnlock ();_ced ,_baa :=_ce ._dfd [g ];return _ced ,_baa ;};