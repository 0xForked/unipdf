//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package syncmap ;import _b "sync";func (_eb *RuneSet )Length ()int {_eb ._fg .RLock ();defer _eb ._fg .RUnlock ();return len (_eb ._da )};type RuneByteMap struct{_dge map[rune ]byte ;_cf _b .RWMutex ;};func NewStringRuneMap (m map[string ]rune )*StringRuneMap {return &StringRuneMap {_aag :m }};
func (_ge *RuneSet )Exists (r rune )bool {_ge ._fg .RLock ();defer _ge ._fg .RUnlock ();_ ,_fgc :=_ge ._da [r ];return _fgc ;};func (_eg *RuneUint16Map )Range (f func (_bd rune ,_bbc uint16 )(_cg bool )){_eg ._fc .RLock ();defer _eg ._fc .RUnlock ();for _aa ,_aee :=range _eg ._ec {if f (_aa ,_aee ){break ;
};};};func (_aeb *RuneUint16Map )RangeDelete (f func (_gbg rune ,_cag uint16 )(_ddb bool ,_ef bool )){_aeb ._fc .Lock ();defer _aeb ._fc .Unlock ();for _ccce ,_dec :=range _aeb ._ec {_fd ,_bfe :=f (_ccce ,_dec );if _fd {delete (_aeb ._ec ,_ccce );};if _bfe {break ;
};};};func (_bf *ByteRuneMap )Read (b byte )(rune ,bool ){_bf ._df .RLock ();defer _bf ._df .RUnlock ();_a ,_de :=_bf ._dc [b ];return _a ,_de ;};func (_ba *RuneByteMap )Range (f func (_e rune ,_dgd byte )(_acc bool )){_ba ._cf .RLock ();defer _ba ._cf .RUnlock ();
for _dcc ,_ca :=range _ba ._dge {if f (_dcc ,_ca ){break ;};};};func (_dd *RuneStringMap )Write (r rune ,s string ){_dd ._ggd .Lock ();defer _dd ._ggd .Unlock ();_dd ._db [r ]=s ;};func (_dedd *RuneByteMap )Length ()int {_dedd ._cf .RLock ();defer _dedd ._cf .RUnlock ();
return len (_dedd ._dge );};type StringRuneMap struct{_aag map[string ]rune ;_fa _b .RWMutex ;};func (_daf *RuneStringMap )Read (r rune )(string ,bool ){_daf ._ggd .RLock ();defer _daf ._ggd .RUnlock ();_cb ,_ed :=_daf ._db [r ];return _cb ,_ed ;};func (_eba *RuneUint16Map )Read (r rune )(uint16 ,bool ){_eba ._fc .RLock ();
defer _eba ._fc .RUnlock ();_bg ,_aeg :=_eba ._ec [r ];return _bg ,_aeg ;};func (_gd *RuneStringMap )Length ()int {_gd ._ggd .RLock ();defer _gd ._ggd .RUnlock ();return len (_gd ._db );};func MakeRuneSet (length int )*RuneSet {return &RuneSet {_da :make (map[rune ]struct{},length )}};
func MakeRuneByteMap (length int )*RuneByteMap {_ac :=make (map[rune ]byte ,length );return &RuneByteMap {_dge :_ac };};func (_fe *StringsMap )Copy ()*StringsMap {_fe ._aae .RLock ();defer _fe ._aae .RUnlock ();_afa :=map[string ]string {};for _ebae ,_gab :=range _fe ._gge {_afa [_ebae ]=_gab ;
};return &StringsMap {_gge :_afa };};func (_edg *StringRuneMap )Range (f func (_gbe string ,_fgb rune )(_edb bool )){_edg ._fa .RLock ();defer _edg ._fa .RUnlock ();for _fgf ,_bda :=range _edg ._aag {if f (_fgf ,_bda ){break ;};};};func NewByteRuneMap (m map[byte ]rune )*ByteRuneMap {return &ByteRuneMap {_dc :m }};
type RuneSet struct{_da map[rune ]struct{};_fg _b .RWMutex ;};func (_fdf *StringsMap )Write (g1 ,g2 string ){_fdf ._aae .Lock ();defer _fdf ._aae .Unlock ();_fdf ._gge [g1 ]=g2 ;};func (_ecc *StringRuneMap )Write (g string ,r rune ){_ecc ._fa .Lock ();
defer _ecc ._fa .Unlock ();_ecc ._aag [g ]=r ;};type RuneUint16Map struct{_ec map[rune ]uint16 ;_fc _b .RWMutex ;};func (_fdc *StringsMap )Range (f func (_bca ,_fb string )(_dbc bool )){_fdc ._aae .RLock ();defer _fdc ._aae .RUnlock ();for _cad ,_cga :=range _fdc ._gge {if f (_cad ,_cga ){break ;
};};};func MakeRuneUint16Map (length int )*RuneUint16Map {return &RuneUint16Map {_ec :make (map[rune ]uint16 ,length )};};func (_ab *StringsMap )Read (g string )(string ,bool ){_ab ._aae .RLock ();defer _ab ._aae .RUnlock ();_ada ,_gga :=_ab ._gge [g ];
return _ada ,_gga ;};func NewStringsMap (tuples []StringsTuple )*StringsMap {_cd :=map[string ]string {};for _ ,_cce :=range tuples {_cd [_cce .Key ]=_cce .Value ;};return &StringsMap {_gge :_cd };};func (_fga *RuneUint16Map )Length ()int {_fga ._fc .RLock ();
defer _fga ._fc .RUnlock ();return len (_fga ._ec );};func (_ege *StringRuneMap )Read (g string )(rune ,bool ){_ege ._fa .RLock ();defer _ege ._fa .RUnlock ();_afd ,_faa :=_ege ._aag [g ];return _afd ,_faa ;};func (_ff *RuneStringMap )Range (f func (_ccc rune ,_ggdg string )(_ae bool )){_ff ._ggd .RLock ();
defer _ff ._ggd .RUnlock ();for _cbg ,_ga :=range _ff ._db {if f (_cbg ,_ga ){break ;};};};func (_gb *ByteRuneMap )Length ()int {_gb ._df .RLock ();defer _gb ._df .RUnlock ();return len (_gb ._dc )};type ByteRuneMap struct{_dc map[byte ]rune ;_df _b .RWMutex ;
};type StringsTuple struct{Key ,Value string ;};func NewRuneStringMap (m map[rune ]string )*RuneStringMap {return &RuneStringMap {_db :m }};func (_dfe *StringRuneMap )Length ()int {_dfe ._fa .RLock ();defer _dfe ._fa .RUnlock ();return len (_dfe ._aag );
};func (_fcf *RuneUint16Map )Delete (r rune ){_fcf ._fc .Lock ();defer _fcf ._fc .Unlock ();delete (_fcf ._ec ,r );};func (_ggb *RuneSet )Range (f func (_ggc rune )(_af bool )){_ggb ._fg .RLock ();defer _ggb ._fg .RUnlock ();for _bac :=range _ggb ._da {if f (_bac ){break ;
};};};func (_ag *RuneSet )Write (r rune ){_ag ._fg .Lock ();defer _ag ._fg .Unlock ();_ag ._da [r ]=struct{}{}};type StringsMap struct{_gge map[string ]string ;_aae _b .RWMutex ;};type RuneStringMap struct{_db map[rune ]string ;_ggd _b .RWMutex ;};func (_dcg *RuneUint16Map )Write (r rune ,g uint16 ){_dcg ._fc .Lock ();
defer _dcg ._fc .Unlock ();_dcg ._ec [r ]=g ;};func (_g *ByteRuneMap )Write (b byte ,r rune ){_g ._df .Lock ();defer _g ._df .Unlock ();_g ._dc [b ]=r };func MakeByteRuneMap (length int )*ByteRuneMap {return &ByteRuneMap {_dc :make (map[byte ]rune ,length )}};
func (_be *ByteRuneMap )Range (f func (_bed byte ,_ad rune )(_c bool )){_be ._df .RLock ();defer _be ._df .RUnlock ();for _bc ,_dg :=range _be ._dc {if f (_bc ,_dg ){break ;};};};func (_f *RuneByteMap )Write (r rune ,b byte ){_f ._cf .Lock ();defer _f ._cf .Unlock ();
_f ._dge [r ]=b };func (_gg *RuneByteMap )Read (r rune )(byte ,bool ){_gg ._cf .RLock ();defer _gg ._cf .RUnlock ();_ded ,_bb :=_gg ._dge [r ];return _ded ,_bb ;};