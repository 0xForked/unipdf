//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package syncmap ;import _bb "sync";func (_ebb *StringsMap )Range (f func (_aae ,_bged string )(_ceb bool )){_ebb ._bce .RLock ();defer _ebb ._bce .RUnlock ();for _aeg ,_fabc :=range _ebb ._eec {if f (_aeg ,_fabc ){break ;};};};func (_ge *StringsMap )Copy ()*StringsMap {_ge ._bce .RLock ();
defer _ge ._bce .RUnlock ();_gfg :=map[string ]string {};for _gga ,_eac :=range _ge ._eec {_gfg [_gga ]=_eac ;};return &StringsMap {_eec :_gfg };};type StringsTuple struct{Key ,Value string ;};type RuneUint16Map struct{_afd map[rune ]uint16 ;_gf _bb .RWMutex ;
};func (_ddf *RuneUint16Map )Length ()int {_ddf ._gf .RLock ();defer _ddf ._gf .RUnlock ();return len (_ddf ._afd );};type RuneByteMap struct{_ec map[rune ]byte ;_fa _bb .RWMutex ;};func NewByteRuneMap (m map[byte ]rune )*ByteRuneMap {return &ByteRuneMap {_g :m }};
func (_ag *RuneStringMap )Read (r rune )(string ,bool ){_ag ._dga .RLock ();defer _ag ._dga .RUnlock ();_dgb ,_dfe :=_ag ._ggb [r ];return _dgb ,_dfe ;};func (_bdd *RuneUint16Map )Range (f func (_afa rune ,_fg uint16 )(_bdg bool )){_bdd ._gf .RLock ();
defer _bdd ._gf .RUnlock ();for _fcc ,_ecd :=range _bdd ._afd {if f (_fcc ,_ecd ){break ;};};};func (_aa *RuneByteMap )Write (r rune ,b byte ){_aa ._fa .Lock ();defer _aa ._fa .Unlock ();_aa ._ec [r ]=b };func NewRuneStringMap (m map[rune ]string )*RuneStringMap {return &RuneStringMap {_ggb :m }};
func (_eg *ByteRuneMap )Length ()int {_eg ._d .RLock ();defer _eg ._d .RUnlock ();return len (_eg ._g )};type StringRuneMap struct{_fec map[string ]rune ;_dge _bb .RWMutex ;};func (_gd *RuneByteMap )Read (r rune )(byte ,bool ){_gd ._fa .RLock ();defer _gd ._fa .RUnlock ();
_bd ,_ce :=_gd ._ec [r ];return _bd ,_ce ;};func MakeRuneByteMap (length int )*RuneByteMap {_fe :=make (map[rune ]byte ,length );return &RuneByteMap {_ec :_fe };};func (_fc *RuneStringMap )Write (r rune ,s string ){_fc ._dga .Lock ();defer _fc ._dga .Unlock ();
_fc ._ggb [r ]=s ;};func (_agg *StringsMap )Read (g string )(string ,bool ){_agg ._bce .RLock ();defer _agg ._bce .RUnlock ();_cee ,_ba :=_agg ._eec [g ];return _cee ,_ba ;};func (_edf *ByteRuneMap )Write (b byte ,r rune ){_edf ._d .Lock ();defer _edf ._d .Unlock ();
_edf ._g [b ]=r ;};func (_ea *RuneStringMap )Length ()int {_ea ._dga .RLock ();defer _ea ._dga .RUnlock ();return len (_ea ._ggb );};type ByteRuneMap struct{_g map[byte ]rune ;_d _bb .RWMutex ;};type RuneStringMap struct{_ggb map[rune ]string ;_dga _bb .RWMutex ;
};func (_fba *RuneSet )Range (f func (_eb rune )(_cece bool )){_fba ._ee .RLock ();defer _fba ._ee .RUnlock ();for _cc :=range _fba ._df {if f (_cc ){break ;};};};func (_gfc *RuneUint16Map )Delete (r rune ){_gfc ._gf .Lock ();defer _gfc ._gf .Unlock ();
delete (_gfc ._afd ,r );};func (_afde *StringRuneMap )Range (f func (_cad string ,_fab rune )(_cgb bool )){_afde ._dge .RLock ();defer _afde ._dge .RUnlock ();for _gcb ,_ff :=range _afde ._fec {if f (_gcb ,_ff ){break ;};};};func (_fae *RuneSet )Exists (r rune )bool {_fae ._ee .RLock ();
defer _fae ._ee .RUnlock ();_ ,_gc :=_fae ._df [r ];return _gc ;};func MakeRuneUint16Map (length int )*RuneUint16Map {return &RuneUint16Map {_afd :make (map[rune ]uint16 ,length )};};func (_c *ByteRuneMap )Range (f func (_f byte ,_fb rune )(_edd bool )){_c ._d .RLock ();
defer _c ._d .RUnlock ();for _ae ,_cb :=range _c ._g {if f (_ae ,_cb ){break ;};};};func (_bf *RuneByteMap )Length ()int {_bf ._fa .RLock ();defer _bf ._fa .RUnlock ();return len (_bf ._ec )};func (_gca *RuneSet )Write (r rune ){_gca ._ee .Lock ();defer _gca ._ee .Unlock ();
_gca ._df [r ]=struct{}{};};func NewStringRuneMap (m map[string ]rune )*StringRuneMap {return &StringRuneMap {_fec :m }};func (_dgg *StringRuneMap )Write (g string ,r rune ){_dgg ._dge .Lock ();defer _dgg ._dge .Unlock ();_dgg ._fec [g ]=r ;};func (_dea *RuneUint16Map )Write (r rune ,g uint16 ){_dea ._gf .Lock ();
defer _dea ._gf .Unlock ();_dea ._afd [r ]=g ;};func (_bdc *RuneUint16Map )Read (r rune )(uint16 ,bool ){_bdc ._gf .RLock ();defer _bdc ._gf .RUnlock ();_ebe ,_bfb :=_bdc ._afd [r ];return _ebe ,_bfb ;};func MakeByteRuneMap (length int )*ByteRuneMap {return &ByteRuneMap {_g :make (map[byte ]rune ,length )}};
func (_af *RuneStringMap )Range (f func (_bbc rune ,_bc string )(_dd bool )){_af ._dga .RLock ();defer _af ._dga .RUnlock ();for _bg ,_gb :=range _af ._ggb {if f (_bg ,_gb ){break ;};};};func (_ca *StringRuneMap )Read (g string )(rune ,bool ){_ca ._dge .RLock ();
defer _ca ._dge .RUnlock ();_fgf ,_ad :=_ca ._fec [g ];return _fgf ,_ad ;};type RuneSet struct{_df map[rune ]struct{};_ee _bb .RWMutex ;};func (_ecg *StringRuneMap )Length ()int {_ecg ._dge .RLock ();defer _ecg ._dge .RUnlock ();return len (_ecg ._fec );
};func (_e *ByteRuneMap )Read (b byte )(rune ,bool ){_e ._d .RLock ();defer _e ._d .RUnlock ();_a ,_ed :=_e ._g [b ];return _a ,_ed ;};func (_deg *StringsMap )Write (g1 ,g2 string ){_deg ._bce .Lock ();defer _deg ._bce .Unlock ();_deg ._eec [g1 ]=g2 ;};
func (_fd *RuneSet )Length ()int {_fd ._ee .RLock ();defer _fd ._ee .RUnlock ();return len (_fd ._df )};type StringsMap struct{_eec map[string ]string ;_bce _bb .RWMutex ;};func MakeRuneSet (length int )*RuneSet {return &RuneSet {_df :make (map[rune ]struct{},length )}};
func (_de *RuneByteMap )Range (f func (_dg rune ,_ac byte )(_cec bool )){_de ._fa .RLock ();defer _de ._fa .RUnlock ();for _ef ,_ceg :=range _de ._ec {if f (_ef ,_ceg ){break ;};};};func (_bbcc *RuneUint16Map )RangeDelete (f func (_cea rune ,_ddg uint16 )(_cg bool ,_bfg bool )){_bbcc ._gf .Lock ();
defer _bbcc ._gf .Unlock ();for _db ,_fdf :=range _bbcc ._afd {_bge ,_gfd :=f (_db ,_fdf );if _bge {delete (_bbcc ._afd ,_db );};if _gfd {break ;};};};func NewStringsMap (tuples []StringsTuple )*StringsMap {_cf :=map[string ]string {};for _ ,_cd :=range tuples {_cf [_cd .Key ]=_cd .Value ;
};return &StringsMap {_eec :_cf };};