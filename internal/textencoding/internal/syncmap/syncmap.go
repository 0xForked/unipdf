//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package syncmap ;import _bb "sync";func MakeRuneByteMap (length int )*RuneByteMap {_fe :=make (map[rune ]byte ,length );return &RuneByteMap {_fc :_fe };};func (_gcf *RuneUint16Map )Write (r rune ,g uint16 ){_gcf ._adg .Lock ();defer _gcf ._adg .Unlock ();
_gcf ._baa [r ]=g ;};func (_db *StringsMap )Write (g1 ,g2 string ){_db ._dac .Lock ();defer _db ._dac .Unlock ();_db ._gee [g1 ]=g2 ;};func (_cf *RuneByteMap )Read (r rune )(byte ,bool ){_cf ._eg .RLock ();defer _cf ._eg .RUnlock ();_fg ,_ee :=_cf ._fc [r ];
return _fg ,_ee ;};func NewStringsMap (tuples []StringsTuple )*StringsMap {_eda :=map[string ]string {};for _ ,_cfad :=range tuples {_eda [_cfad .Key ]=_cfad .Value ;};return &StringsMap {_gee :_eda };};func (_fa *RuneSet )Write (r rune ){_fa ._gca .Lock ();
defer _fa ._gca .Unlock ();_fa ._cff [r ]=struct{}{}};func (_fbb *StringsMap )Copy ()*StringsMap {_fbb ._dac .RLock ();defer _fbb ._dac .RUnlock ();_cbc :=map[string ]string {};for _ada ,_gfc :=range _fbb ._gee {_cbc [_ada ]=_gfc ;};return &StringsMap {_gee :_cbc };
};type StringsMap struct{_gee map[string ]string ;_dac _bb .RWMutex ;};func (_ef *RuneStringMap )Read (r rune )(string ,bool ){_ef ._ddg .RLock ();defer _ef ._ddg .RUnlock ();_bcc ,_ea :=_ef ._bddd [r ];return _bcc ,_ea ;};func (_aac *RuneStringMap )Range (f func (_gb rune ,_gde string )(_gdb bool )){_aac ._ddg .RLock ();
defer _aac ._ddg .RUnlock ();for _gcc ,_fee :=range _aac ._bddd {if f (_gcc ,_fee ){break ;};};};func (_bda *RuneUint16Map )Length ()int {_bda ._adg .RLock ();defer _bda ._adg .RUnlock ();return len (_bda ._baa );};func (_ce *RuneUint16Map )Range (f func (_ff rune ,_cad uint16 )(_fb bool )){_ce ._adg .RLock ();
defer _ce ._adg .RUnlock ();for _ag ,_cbb :=range _ce ._baa {if f (_ag ,_cbb ){break ;};};};type ByteRuneMap struct{_g map[byte ]rune ;_f _bb .RWMutex ;};func (_bcg *RuneByteMap )Length ()int {_bcg ._eg .RLock ();defer _bcg ._eg .RUnlock ();return len (_bcg ._fc );
};func (_e *ByteRuneMap )Range (f func (_ba byte ,_ca rune )(_a bool )){_e ._f .RLock ();defer _e ._f .RUnlock ();for _gd ,_gc :=range _e ._g {if f (_gd ,_gc ){break ;};};};func MakeByteRuneMap (length int )*ByteRuneMap {return &ByteRuneMap {_g :make (map[byte ]rune ,length )}};
func (_gfa *RuneSet )Range (f func (_bd rune )(_aa bool )){_gfa ._gca .RLock ();defer _gfa ._gca .RUnlock ();for _ad :=range _gfa ._cff {if f (_ad ){break ;};};};func (_ed *RuneStringMap )Length ()int {_ed ._ddg .RLock ();defer _ed ._ddg .RUnlock ();return len (_ed ._bddd );
};func NewByteRuneMap (m map[byte ]rune )*ByteRuneMap {return &ByteRuneMap {_g :m }};func (_bdd *RuneSet )Length ()int {_bdd ._gca .RLock ();defer _bdd ._gca .RUnlock ();return len (_bdd ._cff );};func (_aaa *RuneUint16Map )Delete (r rune ){_aaa ._adg .Lock ();
defer _aaa ._adg .Unlock ();delete (_aaa ._baa ,r );};func (_ade *RuneUint16Map )RangeDelete (f func (_gcb rune ,_eb uint16 )(_gcca bool ,_bae bool )){_ade ._adg .Lock ();defer _ade ._adg .Unlock ();for _cba ,_be :=range _ade ._baa {_cbd ,_dda :=f (_cba ,_be );
if _cbd {delete (_ade ._baa ,_cba );};if _dda {break ;};};};type StringRuneMap struct{_da map[string ]rune ;_cfa _bb .RWMutex ;};func (_d *ByteRuneMap )Read (b byte )(rune ,bool ){_d ._f .RLock ();defer _d ._f .RUnlock ();_dd ,_c :=_d ._g [b ];return _dd ,_c ;
};func (_eef *StringRuneMap )Range (f func (_aga string ,_df rune )(_gcdf bool )){_eef ._cfa .RLock ();defer _eef ._cfa .RUnlock ();for _faa ,_eba :=range _eef ._da {if f (_faa ,_eba ){break ;};};};type RuneUint16Map struct{_baa map[rune ]uint16 ;_adg _bb .RWMutex ;
};func (_bc *ByteRuneMap )Write (b byte ,r rune ){_bc ._f .Lock ();defer _bc ._f .Unlock ();_bc ._g [b ]=r };func (_add *StringsMap )Range (f func (_dgc ,_fce string )(_dfe bool )){_add ._dac .RLock ();defer _add ._dac .RUnlock ();for _dfea ,_de :=range _add ._gee {if f (_dfea ,_de ){break ;
};};};func NewRuneStringMap (m map[rune ]string )*RuneStringMap {return &RuneStringMap {_bddd :m }};type RuneSet struct{_cff map[rune ]struct{};_gca _bb .RWMutex ;};func MakeRuneSet (length int )*RuneSet {return &RuneSet {_cff :make (map[rune ]struct{},length )}};
func (_af *RuneUint16Map )Read (r rune )(uint16 ,bool ){_af ._adg .RLock ();defer _af ._adg .RUnlock ();_aef ,_fgg :=_af ._baa [r ];return _aef ,_fgg ;};func NewStringRuneMap (m map[string ]rune )*StringRuneMap {return &StringRuneMap {_da :m }};func (_cabb *StringRuneMap )Write (g string ,r rune ){_cabb ._cfa .Lock ();
defer _cabb ._cfa .Unlock ();_cabb ._da [g ]=r ;};func (_ge *RuneStringMap )Write (r rune ,s string ){_ge ._ddg .Lock ();defer _ge ._ddg .Unlock ();_ge ._bddd [r ]=s ;};func (_gcd *RuneSet )Exists (r rune )bool {_gcd ._gca .RLock ();defer _gcd ._gca .RUnlock ();
_ ,_cab :=_gcd ._cff [r ];return _cab ;};func (_ac *RuneByteMap )Range (f func (_dg rune ,_ace byte )(_ae bool )){_ac ._eg .RLock ();defer _ac ._eg .RUnlock ();for _bf ,_gf :=range _ac ._fc {if f (_bf ,_gf ){break ;};};};func (_ceg *StringsMap )Read (g string )(string ,bool ){_ceg ._dac .RLock ();
defer _ceg ._dac .RUnlock ();_beg ,_adge :=_ceg ._gee [g ];return _beg ,_adge ;};func MakeRuneUint16Map (length int )*RuneUint16Map {return &RuneUint16Map {_baa :make (map[rune ]uint16 ,length )};};type StringsTuple struct{Key ,Value string ;};func (_cb *ByteRuneMap )Length ()int {_cb ._f .RLock ();
defer _cb ._f .RUnlock ();return len (_cb ._g )};type RuneByteMap struct{_fc map[rune ]byte ;_eg _bb .RWMutex ;};func (_fd *RuneByteMap )Write (r rune ,b byte ){_fd ._eg .Lock ();defer _fd ._eg .Unlock ();_fd ._fc [r ]=b };type RuneStringMap struct{_bddd map[rune ]string ;
_ddg _bb .RWMutex ;};func (_bg *StringRuneMap )Read (g string )(rune ,bool ){_bg ._cfa .RLock ();defer _bg ._cfa .RUnlock ();_ffc ,_fad :=_bg ._da [g ];return _ffc ,_fad ;};func (_fda *StringRuneMap )Length ()int {_fda ._cfa .RLock ();defer _fda ._cfa .RUnlock ();
return len (_fda ._da );};