//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package syncmap ;import _c "sync";func (_daa *RuneUint16Map )Range (f func (_cag rune ,_gg uint16 )(_eeb bool )){_daa ._cb .RLock ();defer _daa ._cb .RUnlock ();for _bad ,_fc :=range _daa ._fad {if f (_bad ,_fc ){break ;};};};func (_fg *ByteRuneMap )Length ()int {_fg ._b .RLock ();
defer _fg ._b .RUnlock ();return len (_fg ._ca )};func (_fd *RuneByteMap )Range (f func (_eb rune ,_afe byte )(_ceb bool )){_fd ._cg .RLock ();defer _fd ._cg .RUnlock ();for _gb ,_bb :=range _fd ._gc {if f (_gb ,_bb ){break ;};};};func (_fa *RuneStringMap )Read (r rune )(string ,bool ){_fa ._gcb .RLock ();
defer _fa ._gcb .RUnlock ();_ccg ,_agc :=_fa ._ebce [r ];return _ccg ,_agc ;};func (_ccf *RuneStringMap )Range (f func (_ba rune ,_afec string )(_bfe bool )){_ccf ._gcb .RLock ();defer _ccf ._gcb .RUnlock ();for _eef ,_ffd :=range _ccf ._ebce {if f (_eef ,_ffd ){break ;
};};};func (_bcd *StringsMap )Copy ()*StringsMap {_bcd ._ga .RLock ();defer _bcd ._ga .RUnlock ();_gbdf :=map[string ]string {};for _bgf ,_caf :=range _bcd ._abff {_gbdf [_bgf ]=_caf ;};return &StringsMap {_abff :_gbdf };};func (_dd *StringRuneMap )Range (f func (_gd string ,_ddc rune )(_fff bool )){_dd ._bga .RLock ();
defer _dd ._bga .RUnlock ();for _baf ,_bfd :=range _dd ._eg {if f (_baf ,_bfd ){break ;};};};func NewStringsMap (tuples []StringsTuple )*StringsMap {_abf :=map[string ]string {};for _ ,_ccgc :=range tuples {_abf [_ccgc .Key ]=_ccgc .Value ;};return &StringsMap {_abff :_abf };
};func (_ff *RuneByteMap )Length ()int {_ff ._cg .RLock ();defer _ff ._cg .RUnlock ();return len (_ff ._gc )};func (_a *ByteRuneMap )Range (f func (_af byte ,_ea rune )(_db bool )){_a ._b .RLock ();defer _a ._b .RUnlock ();for _g ,_da :=range _a ._ca {if f (_g ,_da ){break ;
};};};func (_abc *StringsMap )Range (f func (_bgac ,_cfd string )(_bff bool )){_abc ._ga .RLock ();defer _abc ._ga .RUnlock ();for _abca ,_cge :=range _abc ._abff {if f (_abca ,_cge ){break ;};};};func (_gec *StringRuneMap )Read (g string )(rune ,bool ){_gec ._bga .RLock ();
defer _gec ._bga .RUnlock ();_dcb ,_fga :=_gec ._eg [g ];return _dcb ,_fga ;};func NewRuneStringMap (m map[rune ]string )*RuneStringMap {return &RuneStringMap {_ebce :m }};func (_bgb *StringsMap )Read (g string )(string ,bool ){_bgb ._ga .RLock ();defer _bgb ._ga .RUnlock ();
_fdc ,_fee :=_bgb ._abff [g ];return _fdc ,_fee ;};func MakeRuneUint16Map (length int )*RuneUint16Map {return &RuneUint16Map {_fad :make (map[rune ]uint16 ,length )};};func MakeByteRuneMap (length int )*ByteRuneMap {return &ByteRuneMap {_ca :make (map[byte ]rune ,length )}};
func (_bf *RuneByteMap )Read (r rune )(byte ,bool ){_bf ._cg .RLock ();defer _bf ._cg .RUnlock ();_bc ,_ag :=_bf ._gc [r ];return _bc ,_ag ;};type StringsTuple struct{Key ,Value string ;};func (_f *ByteRuneMap )Read (b byte )(rune ,bool ){_f ._b .RLock ();
defer _f ._b .RUnlock ();_d ,_cc :=_f ._ca [b ];return _d ,_cc ;};func (_fcc *RuneUint16Map )Length ()int {_fcc ._cb .RLock ();defer _fcc ._cb .RUnlock ();return len (_fcc ._fad );};func (_ce *ByteRuneMap )Write (b byte ,r rune ){_ce ._b .Lock ();defer _ce ._b .Unlock ();
_ce ._ca [b ]=r };type ByteRuneMap struct{_ca map[byte ]rune ;_b _c .RWMutex ;};func (_fb *StringRuneMap )Length ()int {_fb ._bga .RLock ();defer _fb ._bga .RUnlock ();return len (_fb ._eg );};func (_gbd *RuneUint16Map )Write (r rune ,g uint16 ){_gbd ._cb .Lock ();
defer _gbd ._cb .Unlock ();_gbd ._fad [r ]=g ;};func (_cec *RuneStringMap )Length ()int {_cec ._gcb .RLock ();defer _cec ._gcb .RUnlock ();return len (_cec ._ebce );};type RuneByteMap struct{_gc map[rune ]byte ;_cg _c .RWMutex ;};func (_dg *RuneUint16Map )Read (r rune )(uint16 ,bool ){_dg ._cb .RLock ();
defer _dg ._cb .RUnlock ();_bg ,_cf :=_dg ._fad [r ];return _bg ,_cf ;};type RuneStringMap struct{_ebce map[rune ]string ;_gcb _c .RWMutex ;};type StringRuneMap struct{_eg map[string ]rune ;_bga _c .RWMutex ;};func NewByteRuneMap (m map[byte ]rune )*ByteRuneMap {return &ByteRuneMap {_ca :m }};
func (_ge *RuneStringMap )Write (r rune ,s string ){_ge ._gcb .Lock ();defer _ge ._gcb .Unlock ();_ge ._ebce [r ]=s ;};func MakeRuneSet (length int )*RuneSet {return &RuneSet {_ed :make (map[rune ]struct{},length )}};func (_bbe *RuneUint16Map )RangeDelete (f func (_aa rune ,_bfa uint16 )(_fe bool ,_fadc bool )){_bbe ._cb .Lock ();
defer _bbe ._cb .Unlock ();for _bac ,_bbb :=range _bbe ._fad {_bab ,_ecb :=f (_bac ,_bbb );if _bab {delete (_bbe ._fad ,_bac );};if _ecb {break ;};};};func NewStringRuneMap (m map[string ]rune )*StringRuneMap {return &StringRuneMap {_eg :m }};func (_eefd *StringsMap )Write (g1 ,g2 string ){_eefd ._ga .Lock ();
defer _eefd ._ga .Unlock ();_eefd ._abff [g1 ]=g2 ;};type RuneUint16Map struct{_fad map[rune ]uint16 ;_cb _c .RWMutex ;};func (_ac *RuneSet )Range (f func (_ec rune )(_ab bool )){_ac ._ebc .RLock ();defer _ac ._ebc .RUnlock ();for _gbc :=range _ac ._ed {if f (_gbc ){break ;
};};};func (_ee *RuneByteMap )Write (r rune ,b byte ){_ee ._cg .Lock ();defer _ee ._cg .Unlock ();_ee ._gc [r ]=b };type StringsMap struct{_abff map[string ]string ;_ga _c .RWMutex ;};func MakeRuneByteMap (length int )*RuneByteMap {_be :=make (map[rune ]byte ,length );
return &RuneByteMap {_gc :_be };};func (_bd *RuneUint16Map )Delete (r rune ){_bd ._cb .Lock ();defer _bd ._cb .Unlock ();delete (_bd ._fad ,r )};func (_de *RuneSet )Length ()int {_de ._ebc .RLock ();defer _de ._ebc .RUnlock ();return len (_de ._ed )};func (_gf *RuneSet )Write (r rune ){_gf ._ebc .Lock ();
defer _gf ._ebc .Unlock ();_gf ._ed [r ]=struct{}{}};type RuneSet struct{_ed map[rune ]struct{};_ebc _c .RWMutex ;};func (_gcbe *StringRuneMap )Write (g string ,r rune ){_gcbe ._bga .Lock ();defer _gcbe ._bga .Unlock ();_gcbe ._eg [g ]=r ;};func (_dc *RuneSet )Exists (r rune )bool {_dc ._ebc .RLock ();
defer _dc ._ebc .RUnlock ();_ ,_dcc :=_dc ._ed [r ];return _dcc ;};