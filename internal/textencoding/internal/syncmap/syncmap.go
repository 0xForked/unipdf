//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package syncmap ;import _d "sync";type RuneSet struct{_ea map[rune ]struct{};_edd _d .RWMutex ;};func MakeRuneUint16Map (length int )*RuneUint16Map {return &RuneUint16Map {_ca :make (map[rune ]uint16 ,length )};};func (_fge *RuneByteMap )Length ()int {_fge ._bgb .RLock ();
defer _fge ._bgb .RUnlock ();return len (_fge ._bc );};type ByteRuneMap struct{_bg map[byte ]rune ;_f _d .RWMutex ;};func (_ba *StringsMap )Range (f func (_bcd ,_bfc string )(_faf bool )){_ba ._efc .RLock ();defer _ba ._efc .RUnlock ();for _daf ,_ecg :=range _ba ._egg {if f (_daf ,_ecg ){break ;
};};};func (_fb *RuneByteMap )Range (f func (_edf rune ,_ecd byte )(_bb bool )){_fb ._bgb .RLock ();defer _fb ._bgb .RUnlock ();for _ece ,_ccb :=range _fb ._bc {if f (_ece ,_ccb ){break ;};};};func (_bd *ByteRuneMap )Length ()int {_bd ._f .RLock ();defer _bd ._f .RUnlock ();
return len (_bd ._bg )};func (_gga *RuneStringMap )Length ()int {_gga ._fgc .RLock ();defer _gga ._fgc .RUnlock ();return len (_gga ._dd );};type StringsMap struct{_egg map[string ]string ;_efc _d .RWMutex ;};func NewStringRuneMap (m map[string ]rune )*StringRuneMap {return &StringRuneMap {_deg :m }};
func MakeRuneSet (length int )*RuneSet {return &RuneSet {_ea :make (map[rune ]struct{},length )}};func (_bgg *RuneSet )Exists (r rune )bool {_bgg ._edd .RLock ();defer _bgg ._edd .RUnlock ();_ ,_cd :=_bgg ._ea [r ];return _cd ;};func (_dc *StringRuneMap )Read (g string )(rune ,bool ){_dc ._fe .RLock ();
defer _dc ._fe .RUnlock ();_ge ,_cff :=_dc ._deg [g ];return _ge ,_cff ;};func (_de *ByteRuneMap )Read (b byte )(rune ,bool ){_de ._f .RLock ();defer _de ._f .RUnlock ();_e ,_ec :=_de ._bg [b ];return _e ,_ec ;};func (_eefb *StringRuneMap )Write (g string ,r rune ){_eefb ._fe .Lock ();
defer _eefb ._fe .Unlock ();_eefb ._deg [g ]=r ;};func (_gcb *RuneStringMap )Range (f func (_eef rune ,_ae string )(_ef bool )){_gcb ._fgc .RLock ();defer _gcb ._fgc .RUnlock ();for _ab ,_gb :=range _gcb ._dd {if f (_ab ,_gb ){break ;};};};func (_eg *ByteRuneMap )Range (f func (_da byte ,_df rune )(_c bool )){_eg ._f .RLock ();
defer _eg ._f .RUnlock ();for _cc ,_ed :=range _eg ._bg {if f (_cc ,_ed ){break ;};};};func (_fd *ByteRuneMap )Write (b byte ,r rune ){_fd ._f .Lock ();defer _fd ._f .Unlock ();_fd ._bg [b ]=r };func NewRuneStringMap (m map[rune ]string )*RuneStringMap {return &RuneStringMap {_dd :m }};
type StringRuneMap struct{_deg map[string ]rune ;_fe _d .RWMutex ;};func (_cfb *StringRuneMap )Range (f func (_dca string ,_ccc rune )(_deb bool )){_cfb ._fe .RLock ();defer _cfb ._fe .RUnlock ();for _be ,_bgf :=range _cfb ._deg {if f (_be ,_bgf ){break ;
};};};func MakeByteRuneMap (length int )*ByteRuneMap {return &ByteRuneMap {_bg :make (map[byte ]rune ,length )}};func (_gg *RuneStringMap )Write (r rune ,s string ){_gg ._fgc .Lock ();defer _gg ._fgc .Unlock ();_gg ._dd [r ]=s ;};func (_gc *RuneSet )Range (f func (_ag rune )(_af bool )){_gc ._edd .RLock ();
defer _gc ._edd .RUnlock ();for _cg :=range _gc ._ea {if f (_cg ){break ;};};};func (_agb *RuneUint16Map )Delete (r rune ){_agb ._efe .Lock ();defer _agb ._efe .Unlock ();delete (_agb ._ca ,r );};type RuneUint16Map struct{_ca map[rune ]uint16 ;_efe _d .RWMutex ;
};func (_aca *StringRuneMap )Length ()int {_aca ._fe .RLock ();defer _aca ._fe .RUnlock ();return len (_aca ._deg );};func (_eddf *RuneUint16Map )Length ()int {_eddf ._efe .RLock ();defer _eddf ._efe .RUnlock ();return len (_eddf ._ca );};func (_fbf *RuneSet )Length ()int {_fbf ._edd .RLock ();
defer _fbf ._edd .RUnlock ();return len (_fbf ._ea )};func (_eb *RuneUint16Map )RangeDelete (f func (_ac rune ,_fgcb uint16 )(_eac bool ,_egc bool )){_eb ._efe .Lock ();defer _eb ._efe .Unlock ();for _dgd ,_cdd :=range _eb ._ca {_cde ,_bba :=f (_dgd ,_cdd );
if _cde {delete (_eb ._ca ,_dgd );};if _bba {break ;};};};func (_fdg *StringsMap )Write (g1 ,g2 string ){_fdg ._efc .Lock ();defer _fdg ._efc .Unlock ();_fdg ._egg [g1 ]=g2 ;};func (_db *RuneUint16Map )Read (r rune )(uint16 ,bool ){_db ._efe .RLock ();
defer _db ._efe .RUnlock ();_dg ,_dbd :=_db ._ca [r ];return _dg ,_dbd ;};func (_dad *RuneUint16Map )Write (r rune ,g uint16 ){_dad ._efe .Lock ();defer _dad ._efe .Unlock ();_dad ._ca [r ]=g ;};type RuneStringMap struct{_dd map[rune ]string ;_fgc _d .RWMutex ;
};func NewStringsMap (tuples []StringsTuple )*StringsMap {_cb :=map[string ]string {};for _ ,_ace :=range tuples {_cb [_ace .Key ]=_ace .Value ;};return &StringsMap {_egg :_cb };};func (_a *RuneByteMap )Write (r rune ,b byte ){_a ._bgb .Lock ();defer _a ._bgb .Unlock ();
_a ._bc [r ]=b };type RuneByteMap struct{_bc map[rune ]byte ;_bgb _d .RWMutex ;};func (_afc *StringsMap )Copy ()*StringsMap {_afc ._efc .RLock ();defer _afc ._efc .RUnlock ();_ff :=map[string ]string {};for _abg ,_fgag :=range _afc ._egg {_ff [_abg ]=_fgag ;
};return &StringsMap {_egg :_ff };};func (_bf *RuneSet )Write (r rune ){_bf ._edd .Lock ();defer _bf ._edd .Unlock ();_bf ._ea [r ]=struct{}{}};type StringsTuple struct{Key ,Value string ;};func (_bbg *RuneUint16Map )Range (f func (_efa rune ,_fa uint16 )(_cf bool )){_bbg ._efe .RLock ();
defer _bbg ._efe .RUnlock ();for _fga ,_ggb :=range _bbg ._ca {if f (_fga ,_ggb ){break ;};};};func (_fg *RuneByteMap )Read (r rune )(byte ,bool ){_fg ._bgb .RLock ();defer _fg ._bgb .RUnlock ();_bdc ,_g :=_fg ._bc [r ];return _bdc ,_g ;};func (_ga *StringsMap )Read (g string )(string ,bool ){_ga ._efc .RLock ();
defer _ga ._efc .RUnlock ();_fgd ,_fgac :=_ga ._egg [g ];return _fgd ,_fgac ;};func NewByteRuneMap (m map[byte ]rune )*ByteRuneMap {return &ByteRuneMap {_bg :m }};func (_fgb *RuneStringMap )Read (r rune )(string ,bool ){_fgb ._fgc .RLock ();defer _fgb ._fgc .RUnlock ();
_ee ,_ddc :=_fgb ._dd [r ];return _ee ,_ddc ;};func MakeRuneByteMap (length int )*RuneByteMap {_dee :=make (map[rune ]byte ,length );return &RuneByteMap {_bc :_dee };};