//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package syncmap ;import _g "sync";func (_bag *StringsMap )Range (f func (_aea ,_ad string )(_bcb bool )){_bag ._ga .RLock ();defer _bag ._ga .RUnlock ();for _dca ,_fde :=range _bag ._edf {if f (_dca ,_fde ){break ;};};};type StringsTuple struct{Key ,Value string ;
};func (_db *RuneSet )Write (r rune ){_db ._aag .Lock ();defer _db ._aag .Unlock ();_db ._gc [r ]=struct{}{}};func (_bd *RuneSet )Exists (r rune )bool {_bd ._aag .RLock ();defer _bd ._aag .RUnlock ();_ ,_ffb :=_bd ._gc [r ];return _ffb ;};func (_ef *RuneByteMap )Write (r rune ,b byte ){_ef ._aa .Lock ();
defer _ef ._aa .Unlock ();_ef ._ee [r ]=b };type RuneUint16Map struct{_af map[rune ]uint16 ;_cb _g .RWMutex ;};func (_bed *StringsMap )Write (g1 ,g2 string ){_bed ._ga .Lock ();defer _bed ._ga .Unlock ();_bed ._edf [g1 ]=g2 ;};func (_e *ByteRuneMap )Range (f func (_ac byte ,_da rune )(_ce bool )){_e ._b .RLock ();
defer _e ._b .RUnlock ();for _cc ,_df :=range _e ._d {if f (_cc ,_df ){break ;};};};func MakeByteRuneMap (length int )*ByteRuneMap {return &ByteRuneMap {_d :make (map[byte ]rune ,length )}};type StringsMap struct{_edf map[string ]string ;_ga _g .RWMutex ;
};func (_fc *RuneStringMap )Length ()int {_fc ._bcd .RLock ();defer _fc ._bcd .RUnlock ();return len (_fc ._fa );};func (_fcf *RuneUint16Map )Length ()int {_fcf ._cb .RLock ();defer _fcf ._cb .RUnlock ();return len (_fcf ._af );};func (_dbb *StringRuneMap )Range (f func (_bg string ,_aed rune )(_abc bool )){_dbb ._gca .RLock ();
defer _dbb ._gca .RUnlock ();for _acd ,_cbf :=range _dbb ._be {if f (_acd ,_cbf ){break ;};};};func (_gg *RuneUint16Map )Range (f func (_ggb rune ,_gec uint16 )(_faa bool )){_gg ._cb .RLock ();defer _gg ._cb .RUnlock ();for _dc ,_ecf :=range _gg ._af {if f (_dc ,_ecf ){break ;
};};};func (_bce *RuneStringMap )Write (r rune ,s string ){_bce ._bcd .Lock ();defer _bce ._bcd .Unlock ();_bce ._fa [r ]=s ;};func (_ddc *StringRuneMap )Length ()int {_ddc ._gca .RLock ();defer _ddc ._gca .RUnlock ();return len (_ddc ._be );};type RuneSet struct{_gc map[rune ]struct{};
_aag _g .RWMutex ;};func (_ed *RuneStringMap )Read (r rune )(string ,bool ){_ed ._bcd .RLock ();defer _ed ._bcd .RUnlock ();_daa ,_acc :=_ed ._fa [r ];return _daa ,_acc ;};func (_fg *ByteRuneMap )Write (b byte ,r rune ){_fg ._b .Lock ();defer _fg ._b .Unlock ();
_fg ._d [b ]=r };func MakeRuneUint16Map (length int )*RuneUint16Map {return &RuneUint16Map {_af :make (map[rune ]uint16 ,length )};};func MakeRuneByteMap (length int )*RuneByteMap {_bf :=make (map[rune ]byte ,length );return &RuneByteMap {_ee :_bf };};
type RuneStringMap struct{_fa map[rune ]string ;_bcd _g .RWMutex ;};type RuneByteMap struct{_ee map[rune ]byte ;_aa _g .RWMutex ;};func MakeRuneSet (length int )*RuneSet {return &RuneSet {_gc :make (map[rune ]struct{},length )}};func (_feg *StringsMap )Copy ()*StringsMap {_feg ._ga .RLock ();
defer _feg ._ga .RUnlock ();_dcb :=map[string ]string {};for _fdc ,_bedd :=range _feg ._edf {_dcb [_fdc ]=_bedd ;};return &StringsMap {_edf :_dcb };};func (_ab *RuneUint16Map )RangeDelete (f func (_cbe rune ,_ggg uint16 )(_faae bool ,_ffd bool )){_ab ._cb .Lock ();
defer _ab ._cb .Unlock ();for _ebc ,_ffe :=range _ab ._af {_gdc ,_dab :=f (_ebc ,_ffe );if _gdc {delete (_ab ._af ,_ebc );};if _dab {break ;};};};type ByteRuneMap struct{_d map[byte ]rune ;_b _g .RWMutex ;};func NewByteRuneMap (m map[byte ]rune )*ByteRuneMap {return &ByteRuneMap {_d :m }};
func (_ec *ByteRuneMap )Length ()int {_ec ._b .RLock ();defer _ec ._b .RUnlock ();return len (_ec ._d )};func (_bfa *RuneSet )Length ()int {_bfa ._aag .RLock ();defer _bfa ._aag .RUnlock ();return len (_bfa ._gc )};func (_ff *RuneByteMap )Range (f func (_cg rune ,_fe byte )(_eef bool )){_ff ._aa .RLock ();
defer _ff ._aa .RUnlock ();for _bb ,_ge :=range _ff ._ee {if f (_bb ,_ge ){break ;};};};func (_fd *RuneUint16Map )Write (r rune ,g uint16 ){_fd ._cb .Lock ();defer _fd ._cb .Unlock ();_fd ._af [r ]=g ;};func (_gecf *StringRuneMap )Write (g string ,r rune ){_gecf ._gca .Lock ();
defer _gecf ._gca .Unlock ();_gecf ._be [g ]=r ;};func (_faf *RuneUint16Map )Delete (r rune ){_faf ._cb .Lock ();defer _faf ._cb .Unlock ();delete (_faf ._af ,r );};func NewRuneStringMap (m map[rune ]string )*RuneStringMap {return &RuneStringMap {_fa :m }};
func (_c *ByteRuneMap )Read (b byte )(rune ,bool ){_c ._b .RLock ();defer _c ._b .RUnlock ();_cd ,_a :=_c ._d [b ];return _cd ,_a ;};func (_dfd *RuneByteMap )Length ()int {_dfd ._aa .RLock ();defer _dfd ._aa .RUnlock ();return len (_dfd ._ee );};func (_ea *StringRuneMap )Read (g string )(rune ,bool ){_ea ._gca .RLock ();
defer _ea ._gca .RUnlock ();_feb ,_ecfb :=_ea ._be [g ];return _feb ,_ecfb ;};func (_dd *RuneByteMap )Read (r rune )(byte ,bool ){_dd ._aa .RLock ();defer _dd ._aa .RUnlock ();_bc ,_gb :=_dd ._ee [r ];return _bc ,_gb ;};func (_bff *RuneUint16Map )Read (r rune )(uint16 ,bool ){_bff ._cb .RLock ();
defer _bff ._cb .RUnlock ();_gda ,_eb :=_bff ._af [r ];return _gda ,_eb ;};func NewStringRuneMap (m map[string ]rune )*StringRuneMap {return &StringRuneMap {_be :m }};func (_gcc *StringsMap )Read (g string )(string ,bool ){_gcc ._ga .RLock ();defer _gcc ._ga .RUnlock ();
_bgb ,_eea :=_gcc ._edf [g ];return _bgb ,_eea ;};func NewStringsMap (tuples []StringsTuple )*StringsMap {_edg :=map[string ]string {};for _ ,_feba :=range tuples {_edg [_feba .Key ]=_feba .Value ;};return &StringsMap {_edf :_edg };};func (_gbf *RuneSet )Range (f func (_gd rune )(_de bool )){_gbf ._aag .RLock ();
defer _gbf ._aag .RUnlock ();for _ae :=range _gbf ._gc {if f (_ae ){break ;};};};type StringRuneMap struct{_be map[string ]rune ;_gca _g .RWMutex ;};func (_bfe *RuneStringMap )Range (f func (_ded rune ,_ca string )(_fgc bool )){_bfe ._bcd .RLock ();defer _bfe ._bcd .RUnlock ();
for _gcf ,_gbc :=range _bfe ._fa {if f (_gcf ,_gbc ){break ;};};};