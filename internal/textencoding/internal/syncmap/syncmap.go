//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package syncmap ;import _bf "sync";func (_bec *RuneSet )Exists (r rune )bool {_bec ._geb .RLock ();defer _bec ._geb .RUnlock ();_ ,_fgb :=_bec ._gb [r ];return _fgb ;};type RuneByteMap struct{_bc map[rune ]byte ;_g _bf .RWMutex ;};func (_ceg *StringRuneMap )Range (f func (_de string ,_ggb rune )(_gbe bool )){_ceg ._bea .RLock ();
defer _ceg ._bea .RUnlock ();for _eaf ,_faf :=range _ceg ._dfa {if f (_eaf ,_faf ){break ;};};};func (_ae *RuneStringMap )Range (f func (_dfcb rune ,_db string )(_ga bool )){_ae ._cd .RLock ();defer _ae ._cd .RUnlock ();for _agg ,_cbca :=range _ae ._bed {if f (_agg ,_cbca ){break ;
};};};func (_dfg *RuneStringMap )Read (r rune )(string ,bool ){_dfg ._cd .RLock ();defer _dfg ._cd .RUnlock ();_ecb ,_ged :=_dfg ._bed [r ];return _ecb ,_ged ;};type RuneSet struct{_gb map[rune ]struct{};_geb _bf .RWMutex ;};func (_cae *StringsMap )Write (g1 ,g2 string ){_cae ._fcb .Lock ();
defer _cae ._fcb .Unlock ();_cae ._cf [g1 ]=g2 ;};func (_a *ByteRuneMap )Write (b byte ,r rune ){_a ._dd .Lock ();defer _a ._dd .Unlock ();_a ._d [b ]=r };func MakeByteRuneMap (length int )*ByteRuneMap {return &ByteRuneMap {_d :make (map[byte ]rune ,length )}};
func (_ef *RuneSet )Write (r rune ){_ef ._geb .Lock ();defer _ef ._geb .Unlock ();_ef ._gb [r ]=struct{}{}};func (_dfb *StringsMap )Range (f func (_ced ,_daa string )(_fbb bool )){_dfb ._fcb .RLock ();defer _dfb ._fcb .RUnlock ();for _cad ,_gf :=range _dfb ._cf {if f (_cad ,_gf ){break ;
};};};func MakeRuneSet (length int )*RuneSet {return &RuneSet {_gb :make (map[rune ]struct{},length )}};func NewStringsMap (tuples []StringsTuple )*StringsMap {_faff :=map[string ]string {};for _ ,_dec :=range tuples {_faff [_dec .Key ]=_dec .Value ;};
return &StringsMap {_cf :_faff };};func (_bedc *RuneStringMap )Length ()int {_bedc ._cd .RLock ();defer _bedc ._cd .RUnlock ();return len (_bedc ._bed );};type StringsMap struct{_cf map[string ]string ;_fcb _bf .RWMutex ;};func NewByteRuneMap (m map[byte ]rune )*ByteRuneMap {return &ByteRuneMap {_d :m }};
func (_cbc *RuneSet )Length ()int {_cbc ._geb .RLock ();defer _cbc ._geb .RUnlock ();return len (_cbc ._gb )};func (_ag *RuneByteMap )Write (r rune ,b byte ){_ag ._g .Lock ();defer _ag ._g .Unlock ();_ag ._bc [r ]=b };func (_ff *RuneUint16Map )Read (r rune )(uint16 ,bool ){_ff ._cce .RLock ();
defer _ff ._cce .RUnlock ();_ea ,_fba :=_ff ._efg [r ];return _ea ,_fba ;};type RuneUint16Map struct{_efg map[rune ]uint16 ;_cce _bf .RWMutex ;};func (_dfd *RuneByteMap )Read (r rune )(byte ,bool ){_dfd ._g .RLock ();defer _dfd ._g .RUnlock ();_bb ,_ge :=_dfd ._bc [r ];
return _bb ,_ge ;};func MakeRuneByteMap (length int )*RuneByteMap {_e :=make (map[rune ]byte ,length );return &RuneByteMap {_bc :_e };};func (_dac *RuneSet )Range (f func (_eff rune )(_bg bool )){_dac ._geb .RLock ();defer _dac ._geb .RUnlock ();for _dfe :=range _dac ._gb {if f (_dfe ){break ;
};};};func (_fe *RuneByteMap )Range (f func (_ddd rune ,_ce byte )(_agf bool )){_fe ._g .RLock ();defer _fe ._g .RUnlock ();for _dfc ,_ec :=range _fe ._bc {if f (_dfc ,_ec ){break ;};};};func (_dde *RuneUint16Map )Write (r rune ,g uint16 ){_dde ._cce .Lock ();
defer _dde ._cce .Unlock ();_dde ._efg [r ]=g ;};func (_aee *StringsMap )Copy ()*StringsMap {_aee ._fcb .RLock ();defer _aee ._fcb .RUnlock ();_bda :=map[string ]string {};for _cfc ,_ee :=range _aee ._cf {_bda [_cfc ]=_ee ;};return &StringsMap {_cf :_bda };
};type StringRuneMap struct{_dfa map[string ]rune ;_bea _bf .RWMutex ;};func NewRuneStringMap (m map[rune ]string )*RuneStringMap {return &RuneStringMap {_bed :m }};func (_bfd *StringRuneMap )Read (g string )(rune ,bool ){_bfd ._bea .RLock ();defer _bfd ._bea .RUnlock ();
_fa ,_bgf :=_bfd ._dfa [g ];return _fa ,_bgf ;};func (_c *ByteRuneMap )Read (b byte )(rune ,bool ){_c ._dd .RLock ();defer _c ._dd .RUnlock ();_ba ,_bd :=_c ._d [b ];return _ba ,_bd ;};func (_cg *RuneUint16Map )Range (f func (_ca rune ,_fbf uint16 )(_fc bool )){_cg ._cce .RLock ();
defer _cg ._cce .RUnlock ();for _fdd ,_cgb :=range _cg ._efg {if f (_fdd ,_cgb ){break ;};};};func NewStringRuneMap (m map[string ]rune )*StringRuneMap {return &StringRuneMap {_dfa :m }};func (_gab *StringRuneMap )Length ()int {_gab ._bea .RLock ();defer _gab ._bea .RUnlock ();
return len (_gab ._dfa );};type RuneStringMap struct{_bed map[rune ]string ;_cd _bf .RWMutex ;};func (_eg *StringsMap )Read (g string )(string ,bool ){_eg ._fcb .RLock ();defer _eg ._fcb .RUnlock ();_ed ,_fdb :=_eg ._cf [g ];return _ed ,_fdb ;};func (_cac *RuneUint16Map )Length ()int {_cac ._cce .RLock ();
defer _cac ._cce .RUnlock ();return len (_cac ._efg );};func (_da *ByteRuneMap )Length ()int {_da ._dd .RLock ();defer _da ._dd .RUnlock ();return len (_da ._d )};func (_eab *RuneUint16Map )Delete (r rune ){_eab ._cce .Lock ();defer _eab ._cce .Unlock ();
delete (_eab ._efg ,r );};type StringsTuple struct{Key ,Value string ;};func (_cc *RuneStringMap )Write (r rune ,s string ){_cc ._cd .Lock ();defer _cc ._cd .Unlock ();_cc ._bed [r ]=s ;};func (_be *RuneByteMap )Length ()int {_be ._g .RLock ();defer _be ._g .RUnlock ();
return len (_be ._bc )};func (_cdc *RuneUint16Map )RangeDelete (f func (_eag rune ,_bbd uint16 )(_aa bool ,_gg bool )){_cdc ._cce .Lock ();defer _cdc ._cce .Unlock ();for _af ,_bba :=range _cdc ._efg {_cge ,_ddeb :=f (_af ,_bba );if _cge {delete (_cdc ._efg ,_af );
};if _ddeb {break ;};};};type ByteRuneMap struct{_d map[byte ]rune ;_dd _bf .RWMutex ;};func (_fed *StringRuneMap )Write (g string ,r rune ){_fed ._bea .Lock ();defer _fed ._bea .Unlock ();_fed ._dfa [g ]=r ;};func (_f *ByteRuneMap )Range (f func (_fg byte ,_bfc rune )(_df bool )){_f ._dd .RLock ();
defer _f ._dd .RUnlock ();for _cb ,_fd :=range _f ._d {if f (_cb ,_fd ){break ;};};};func MakeRuneUint16Map (length int )*RuneUint16Map {return &RuneUint16Map {_efg :make (map[rune ]uint16 ,length )};};