//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package syncmap ;import _c "sync";func (_ba *RuneUint16Map )RangeDelete (f func (_efg rune ,_gaa uint16 )(_gda bool ,_dd bool )){_ba ._db .Lock ();defer _ba ._db .Unlock ();for _fea ,_bgc :=range _ba ._aa {_eed ,_daf :=f (_fea ,_bgc );if _eed {delete (_ba ._aa ,_fea );
};if _daf {break ;};};};func (_ed *RuneSet )Exists (r rune )bool {_ed ._gab .RLock ();defer _ed ._gab .RUnlock ();_ ,_cd :=_ed ._dgg [r ];return _cd ;};func (_eb *RuneStringMap )Read (r rune )(string ,bool ){_eb ._gc .RLock ();defer _eb ._gc .RUnlock ();
_agd ,_fe :=_eb ._fb [r ];return _agd ,_fe ;};func NewStringsMap (tuples []StringsTuple )*StringsMap {_acd :=map[string ]string {};for _ ,_gb :=range tuples {_acd [_gb .Key ]=_gb .Value ;};return &StringsMap {_gdd :_acd };};func (_gfb *StringsMap )Read (g string )(string ,bool ){_gfb ._ca .RLock ();
defer _gfb ._ca .RUnlock ();_cg ,_ddd :=_gfb ._gdd [g ];return _cg ,_ddd ;};func (_bf *StringsMap )Copy ()*StringsMap {_bf ._ca .RLock ();defer _bf ._ca .RUnlock ();_geg :=map[string ]string {};for _aebc ,_ddg :=range _bf ._gdd {_geg [_aebc ]=_ddg ;};return &StringsMap {_gdd :_geg };
};func (_ebb *RuneStringMap )Range (f func (_egec rune ,_ad string )(_bbf bool )){_ebb ._gc .RLock ();defer _ebb ._gc .RUnlock ();for _de ,_gdg :=range _ebb ._fb {if f (_de ,_gdg ){break ;};};};func (_gga *RuneStringMap )Length ()int {_gga ._gc .RLock ();
defer _gga ._gc .RUnlock ();return len (_gga ._fb );};type RuneStringMap struct{_fb map[rune ]string ;_gc _c .RWMutex ;};func (_bdc *StringRuneMap )Read (g string )(rune ,bool ){_bdc ._dafc .RLock ();defer _bdc ._dafc .RUnlock ();_bac ,_ac :=_bdc ._ged [g ];
return _bac ,_ac ;};func MakeRuneSet (length int )*RuneSet {return &RuneSet {_dgg :make (map[rune ]struct{},length )}};type StringsMap struct{_gdd map[string ]string ;_ca _c .RWMutex ;};func (_bgg *RuneSet )Length ()int {_bgg ._gab .RLock ();defer _bgg ._gab .RUnlock ();
return len (_bgg ._dgg );};func MakeByteRuneMap (length int )*ByteRuneMap {return &ByteRuneMap {_f :make (map[byte ]rune ,length )}};func (_dda *StringRuneMap )Range (f func (_cbf string ,_fead rune )(_gag bool )){_dda ._dafc .RLock ();defer _dda ._dafc .RUnlock ();
for _eaf ,_efe :=range _dda ._ged {if f (_eaf ,_efe ){break ;};};};type StringRuneMap struct{_ged map[string ]rune ;_dafc _c .RWMutex ;};func (_gf *ByteRuneMap )Range (f func (_gd byte ,_ef rune )(_fd bool )){_gf ._d .RLock ();defer _gf ._d .RUnlock ();
for _fa ,_eg :=range _gf ._f {if f (_fa ,_eg ){break ;};};};func (_bd *ByteRuneMap )Length ()int {_bd ._d .RLock ();defer _bd ._d .RUnlock ();return len (_bd ._f )};func (_age *RuneSet )Write (r rune ){_age ._gab .Lock ();defer _age ._gab .Unlock ();_age ._dgg [r ]=struct{}{};
};func NewByteRuneMap (m map[byte ]rune )*ByteRuneMap {return &ByteRuneMap {_f :m }};func (_efgd *RuneUint16Map )Delete (r rune ){_efgd ._db .Lock ();defer _efgd ._db .Unlock ();delete (_efgd ._aa ,r );};func (_bda *RuneUint16Map )Write (r rune ,g uint16 ){_bda ._db .Lock ();
defer _bda ._db .Unlock ();_bda ._aa [r ]=g ;};func (_cb *RuneByteMap )Write (r rune ,b byte ){_cb ._gfe .Lock ();defer _cb ._gfe .Unlock ();_cb ._ce [r ]=b ;};type StringsTuple struct{Key ,Value string ;};func (_ee *RuneUint16Map )Range (f func (_cdg rune ,_cda uint16 )(_ff bool )){_ee ._db .RLock ();
defer _ee ._db .RUnlock ();for _ge ,_dc :=range _ee ._aa {if f (_ge ,_dc ){break ;};};};func (_ea *RuneByteMap )Read (r rune )(byte ,bool ){_ea ._gfe .RLock ();defer _ea ._gfe .RUnlock ();_ag ,_bb :=_ea ._ce [r ];return _ag ,_bb ;};type RuneSet struct{_dgg map[rune ]struct{};
_gab _c .RWMutex ;};func (_b *ByteRuneMap )Write (b byte ,r rune ){_b ._d .Lock ();defer _b ._d .Unlock ();_b ._f [b ]=r };func (_efc *RuneUint16Map )Length ()int {_efc ._db .RLock ();defer _efc ._db .RUnlock ();return len (_efc ._aa );};func (_a *ByteRuneMap )Read (b byte )(rune ,bool ){_a ._d .RLock ();
defer _a ._d .RUnlock ();_dg ,_g :=_a ._f [b ];return _dg ,_g ;};func MakeRuneUint16Map (length int )*RuneUint16Map {return &RuneUint16Map {_aa :make (map[rune ]uint16 ,length )};};type RuneByteMap struct{_ce map[rune ]byte ;_gfe _c .RWMutex ;};func (_fdf *StringRuneMap )Length ()int {_fdf ._dafc .RLock ();
defer _fdf ._dafc .RUnlock ();return len (_fdf ._ged );};type ByteRuneMap struct{_f map[byte ]rune ;_d _c .RWMutex ;};func (_af *RuneStringMap )Write (r rune ,s string ){_af ._gc .Lock ();defer _af ._gc .Unlock ();_af ._fb [r ]=s ;};func NewRuneStringMap (m map[rune ]string )*RuneStringMap {return &RuneStringMap {_fb :m }};
func (_gfd *RuneUint16Map )Read (r rune )(uint16 ,bool ){_gfd ._db .RLock ();defer _gfd ._db .RUnlock ();_aea ,_dae :=_gfd ._aa [r ];return _aea ,_dae ;};func (_ege *RuneByteMap )Range (f func (_fdg rune ,_aeb byte )(_bg bool )){_ege ._gfe .RLock ();defer _ege ._gfe .RUnlock ();
for _cc ,_gg :=range _ege ._ce {if f (_cc ,_gg ){break ;};};};func (_fda *StringsMap )Write (g1 ,g2 string ){_fda ._ca .Lock ();defer _fda ._ca .Unlock ();_fda ._gdd [g1 ]=g2 ;};func (_bae *StringsMap )Range (f func (_fed ,_ggaa string )(_dafa bool )){_bae ._ca .RLock ();
defer _bae ._ca .RUnlock ();for _df ,_add :=range _bae ._gdd {if f (_df ,_add ){break ;};};};func (_ga *RuneByteMap )Length ()int {_ga ._gfe .RLock ();defer _ga ._gfe .RUnlock ();return len (_ga ._ce )};type RuneUint16Map struct{_aa map[rune ]uint16 ;_db _c .RWMutex ;
};func (_be *RuneSet )Range (f func (_cbd rune )(_da bool )){_be ._gab .RLock ();defer _be ._gab .RUnlock ();for _gfa :=range _be ._dgg {if f (_gfa ){break ;};};};func NewStringRuneMap (m map[string ]rune )*StringRuneMap {return &StringRuneMap {_ged :m }};
func (_gdac *StringRuneMap )Write (g string ,r rune ){_gdac ._dafc .Lock ();defer _gdac ._dafc .Unlock ();_gdac ._ged [g ]=r ;};func MakeRuneByteMap (length int )*RuneByteMap {_ae :=make (map[rune ]byte ,length );return &RuneByteMap {_ce :_ae };};