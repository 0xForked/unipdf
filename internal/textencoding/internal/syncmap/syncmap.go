//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package syncmap ;import _gc "sync";func (_aagg *StringRuneMap )Length ()int {_aagg ._dgf .RLock ();defer _aagg ._dgf .RUnlock ();return len (_aagg ._dg );};func (_bb *RuneByteMap )Read (r rune )(byte ,bool ){_bb ._daf .RLock ();defer _bb ._daf .RUnlock ();
_aa ,_ge :=_bb ._dae [r ];return _aa ,_ge ;};func (_gd *ByteRuneMap )Range (f func (_a byte ,_gcd rune )(_da bool )){_gd ._d .RLock ();defer _gd ._d .RUnlock ();for _fg ,_bd :=range _gd ._c {if f (_fg ,_bd ){break ;};};};type RuneStringMap struct{_dcg map[rune ]string ;
_ace _gc .RWMutex ;};func MakeRuneByteMap (length int )*RuneByteMap {_cd :=make (map[rune ]byte ,length );return &RuneByteMap {_dae :_cd };};func (_fc *StringsMap )Read (g string )(string ,bool ){_fc ._cee .RLock ();defer _fc ._cee .RUnlock ();_fe ,_gdd :=_fc ._gbb [g ];
return _fe ,_gdd ;};func (_ae *RuneSet )Length ()int {_ae ._cf .RLock ();defer _ae ._cf .RUnlock ();return len (_ae ._gda )};func (_aac *RuneByteMap )Length ()int {_aac ._daf .RLock ();defer _aac ._daf .RUnlock ();return len (_aac ._dae );};func (_ad *RuneSet )Range (f func (_bc rune )(_ca bool )){_ad ._cf .RLock ();
defer _ad ._cf .RUnlock ();for _ed :=range _ad ._gda {if f (_ed ){break ;};};};type StringsMap struct{_gbb map[string ]string ;_cee _gc .RWMutex ;};func (_cc *ByteRuneMap )Write (b byte ,r rune ){_cc ._d .Lock ();defer _cc ._d .Unlock ();_cc ._c [b ]=r };
func (_ce *RuneStringMap )Range (f func (_cac rune ,_de string )(_db bool )){_ce ._ace .RLock ();defer _ce ._ace .RUnlock ();for _gacb ,_eg :=range _ce ._dcg {if f (_gacb ,_eg ){break ;};};};type StringRuneMap struct{_dg map[string ]rune ;_dgf _gc .RWMutex ;
};func (_df *RuneUint16Map )Read (r rune )(uint16 ,bool ){_df ._cbc .RLock ();defer _df ._cbc .RUnlock ();_deg ,_aef :=_df ._dcb [r ];return _deg ,_aef ;};func (_aeff *StringRuneMap )Read (g string )(rune ,bool ){_aeff ._dgf .RLock ();defer _aeff ._dgf .RUnlock ();
_bddb ,_bcf :=_aeff ._dg [g ];return _bddb ,_bcf ;};func (_gfc *StringRuneMap )Write (g string ,r rune ){_gfc ._dgf .Lock ();defer _gfc ._dgf .Unlock ();_gfc ._dg [g ]=r ;};func (_acec *RuneStringMap )Read (r rune )(string ,bool ){_acec ._ace .RLock ();
defer _acec ._ace .RUnlock ();_edd ,_eb :=_acec ._dcg [r ];return _edd ,_eb ;};func (_gf *RuneByteMap )Range (f func (_dc rune ,_ea byte )(_gcc bool )){_gf ._daf .RLock ();defer _gf ._daf .RUnlock ();for _gb ,_gac :=range _gf ._dae {if f (_gb ,_gac ){break ;
};};};func NewStringRuneMap (m map[string ]rune )*StringRuneMap {return &StringRuneMap {_dg :m }};type RuneUint16Map struct{_dcb map[rune ]uint16 ;_cbc _gc .RWMutex ;};type ByteRuneMap struct{_c map[byte ]rune ;_d _gc .RWMutex ;};func MakeRuneUint16Map (length int )*RuneUint16Map {return &RuneUint16Map {_dcb :make (map[rune ]uint16 ,length )};
};func MakeRuneSet (length int )*RuneSet {return &RuneSet {_gda :make (map[rune ]struct{},length )}};func (_cbf *RuneStringMap )Write (r rune ,s string ){_cbf ._ace .Lock ();defer _cbf ._ace .Unlock ();_cbf ._dcg [r ]=s ;};func (_ga *ByteRuneMap )Length ()int {_ga ._d .RLock ();
defer _ga ._d .RUnlock ();return len (_ga ._c )};func (_gab *RuneUint16Map )RangeDelete (f func (_aea rune ,_aag uint16 )(_aee bool ,_fd bool )){_gab ._cbc .Lock ();defer _gab ._cbc .Unlock ();for _fbf ,_dca :=range _gab ._dcb {_bec ,_dfa :=f (_fbf ,_dca );
if _bec {delete (_gab ._dcb ,_fbf );};if _dfa {break ;};};};func (_cae *RuneUint16Map )Write (r rune ,g uint16 ){_cae ._cbc .Lock ();defer _cae ._cbc .Unlock ();_cae ._dcb [r ]=g ;};func NewByteRuneMap (m map[byte ]rune )*ByteRuneMap {return &ByteRuneMap {_c :m }};
func (_dcd *RuneUint16Map )Range (f func (_bea rune ,_ag uint16 )(_gae bool )){_dcd ._cbc .RLock ();defer _dcd ._cbc .RUnlock ();for _caa ,_af :=range _dcd ._dcb {if f (_caa ,_af ){break ;};};};func NewStringsMap (tuples []StringsTuple )*StringsMap {_ef :=map[string ]string {};
for _ ,_ffb :=range tuples {_ef [_ffb .Key ]=_ffb .Value ;};return &StringsMap {_gbb :_ef };};func MakeByteRuneMap (length int )*ByteRuneMap {return &ByteRuneMap {_c :make (map[byte ]rune ,length )}};func (_fb *RuneStringMap )Length ()int {_fb ._ace .RLock ();
defer _fb ._ace .RUnlock ();return len (_fb ._dcg );};func (_dcc *RuneUint16Map )Length ()int {_dcc ._cbc .RLock ();defer _dcc ._cbc .RUnlock ();return len (_dcc ._dcb );};func (_cbd *StringsMap )Copy ()*StringsMap {_cbd ._cee .RLock ();defer _cbd ._cee .RUnlock ();
_bef :=map[string ]string {};for _aabg ,_caab :=range _cbd ._gbb {_bef [_aabg ]=_caab ;};return &StringsMap {_gbb :_bef };};func (_cb *RuneByteMap )Write (r rune ,b byte ){_cb ._daf .Lock ();defer _cb ._daf .Unlock ();_cb ._dae [r ]=b ;};func (_ab *StringRuneMap )Range (f func (_abd string ,_dd rune )(_gg bool )){_ab ._dgf .RLock ();
defer _ab ._dgf .RUnlock ();for _abg ,_ff :=range _ab ._dg {if f (_abg ,_ff ){break ;};};};func (_b *ByteRuneMap )Read (b byte )(rune ,bool ){_b ._d .RLock ();defer _b ._d .RUnlock ();_f ,_e :=_b ._c [b ];return _f ,_e ;};func (_fbg *RuneUint16Map )Delete (r rune ){_fbg ._cbc .Lock ();
defer _fbg ._cbc .Unlock ();delete (_fbg ._dcb ,r );};func (_be *RuneSet )Write (r rune ){_be ._cf .Lock ();defer _be ._cf .Unlock ();_be ._gda [r ]=struct{}{}};func (_cfe *StringsMap )Range (f func (_ee ,_ec string )(_ba bool )){_cfe ._cee .RLock ();defer _cfe ._cee .RUnlock ();
for _aab ,_aff :=range _cfe ._gbb {if f (_aab ,_aff ){break ;};};};type RuneSet struct{_gda map[rune ]struct{};_cf _gc .RWMutex ;};func NewRuneStringMap (m map[rune ]string )*RuneStringMap {return &RuneStringMap {_dcg :m }};type StringsTuple struct{Key ,Value string ;
};func (_fa *RuneSet )Exists (r rune )bool {_fa ._cf .RLock ();defer _fa ._cf .RUnlock ();_ ,_bdd :=_fa ._gda [r ];return _bdd ;};func (_ggd *StringsMap )Write (g1 ,g2 string ){_ggd ._cee .Lock ();defer _ggd ._cee .Unlock ();_ggd ._gbb [g1 ]=g2 ;};type RuneByteMap struct{_dae map[rune ]byte ;
_daf _gc .RWMutex ;};