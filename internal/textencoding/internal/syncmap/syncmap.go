//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package syncmap ;import _g "sync";func (_be *RuneByteMap )Length ()int {_be ._gd .RLock ();defer _be ._gd .RUnlock ();return len (_be ._dc )};func NewStringRuneMap (m map[string ]rune )*StringRuneMap {return &StringRuneMap {_eda :m }};type ByteRuneMap struct{_c map[byte ]rune ;
_d _g .RWMutex ;};func (_eff *RuneStringMap )Length ()int {_eff ._bfa .RLock ();defer _eff ._bfa .RUnlock ();return len (_eff ._cfcg );};func (_fgd *StringRuneMap )Write (g string ,r rune ){_fgd ._bb .Lock ();defer _fgd ._bb .Unlock ();_fgd ._eda [g ]=r ;
};type RuneStringMap struct{_cfcg map[rune ]string ;_bfa _g .RWMutex ;};type StringRuneMap struct{_eda map[string ]rune ;_bb _g .RWMutex ;};func (_ee *RuneStringMap )Read (r rune )(string ,bool ){_ee ._bfa .RLock ();defer _ee ._bfa .RUnlock ();_eg ,_bcg :=_ee ._cfcg [r ];
return _eg ,_bcg ;};type RuneUint16Map struct{_acd map[rune ]uint16 ;_ad _g .RWMutex ;};type StringsTuple struct{Key ,Value string ;};type StringsMap struct{_fff map[string ]string ;_fdd _g .RWMutex ;};func (_cf *RuneSet )Write (r rune ){_cf ._df .Lock ();
defer _cf ._df .Unlock ();_cf ._ef [r ]=struct{}{}};func (_bcd *RuneSet )Length ()int {_bcd ._df .RLock ();defer _bcd ._df .RUnlock ();return len (_bcd ._ef )};func (_fc *RuneByteMap )Read (r rune )(byte ,bool ){_fc ._gd .RLock ();defer _fc ._gd .RUnlock ();
_gc ,_ea :=_fc ._dc [r ];return _gc ,_ea ;};func (_ab *RuneUint16Map )RangeDelete (f func (_gcf rune ,_eca uint16 )(_eafa bool ,_fcgd bool )){_ab ._ad .Lock ();defer _ab ._ad .Unlock ();for _ag ,_fbf :=range _ab ._acd {_fd ,_gcd :=f (_ag ,_fbf );if _fd {delete (_ab ._acd ,_ag );
};if _gcd {break ;};};};func MakeByteRuneMap (length int )*ByteRuneMap {return &ByteRuneMap {_c :make (map[byte ]rune ,length )}};func (_ged *RuneByteMap )Write (r rune ,b byte ){_ged ._gd .Lock ();defer _ged ._gd .Unlock ();_ged ._dc [r ]=b ;};func (_bff *StringsMap )Write (g1 ,g2 string ){_bff ._fdd .Lock ();
defer _bff ._fdd .Unlock ();_bff ._fff [g1 ]=g2 ;};func (_ec *RuneUint16Map )Range (f func (_eedf rune ,_af uint16 )(_aaf bool )){_ec ._ad .RLock ();defer _ec ._ad .RUnlock ();for _dd ,_bgf :=range _ec ._acd {if f (_dd ,_bgf ){break ;};};};func (_dbd *StringsMap )Copy ()*StringsMap {_dbd ._fdd .RLock ();
defer _dbd ._fdd .RUnlock ();_dad :=map[string ]string {};for _ecac ,_fbfg :=range _dbd ._fff {_dad [_ecac ]=_fbfg ;};return &StringsMap {_fff :_dad };};func (_dcf *RuneUint16Map )Delete (r rune ){_dcf ._ad .Lock ();defer _dcf ._ad .Unlock ();delete (_dcf ._acd ,r );
};func (_f *ByteRuneMap )Range (f func (_ff byte ,_da rune )(_cb bool )){_f ._d .RLock ();defer _f ._d .RUnlock ();for _fb ,_ffg :=range _f ._c {if f (_fb ,_ffg ){break ;};};};type RuneSet struct{_ef map[rune ]struct{};_df _g .RWMutex ;};func (_dbg *RuneUint16Map )Length ()int {_dbg ._ad .RLock ();
defer _dbg ._ad .RUnlock ();return len (_dbg ._acd );};func (_fgg *StringRuneMap )Length ()int {_fgg ._bb .RLock ();defer _fgg ._bb .RUnlock ();return len (_fgg ._eda );};func MakeRuneUint16Map (length int )*RuneUint16Map {return &RuneUint16Map {_acd :make (map[rune ]uint16 ,length )};
};func (_cg *RuneSet )Exists (r rune )bool {_cg ._df .RLock ();defer _cg ._df .RUnlock ();_ ,_dcb :=_cg ._ef [r ];return _dcb ;};func (_bd *RuneByteMap )Range (f func (_fcg rune ,_ce byte )(_a bool )){_bd ._gd .RLock ();defer _bd ._gd .RUnlock ();for _gg ,_ed :=range _bd ._dc {if f (_gg ,_ed ){break ;
};};};func MakeRuneSet (length int )*RuneSet {return &RuneSet {_ef :make (map[rune ]struct{},length )}};func MakeRuneByteMap (length int )*RuneByteMap {_bg :=make (map[rune ]byte ,length );return &RuneByteMap {_dc :_bg };};func NewByteRuneMap (m map[byte ]rune )*ByteRuneMap {return &ByteRuneMap {_c :m }};
func (_e *ByteRuneMap )Write (b byte ,r rune ){_e ._d .Lock ();defer _e ._d .Unlock ();_e ._c [b ]=r };func (_dbe *RuneUint16Map )Read (r rune )(uint16 ,bool ){_dbe ._ad .RLock ();defer _dbe ._ad .RUnlock ();_efb ,_ga :=_dbe ._acd [r ];return _efb ,_ga ;
};func (_cbc *StringsMap )Range (f func (_adg ,_dfe string )(_dfc bool )){_cbc ._fdd .RLock ();defer _cbc ._fdd .RUnlock ();for _afe ,_cfg :=range _cbc ._fff {if f (_afe ,_cfg ){break ;};};};func (_dafe *RuneStringMap )Write (r rune ,s string ){_dafe ._bfa .Lock ();
defer _dafe ._bfa .Unlock ();_dafe ._cfcg [r ]=s ;};func (_cfc *RuneSet )Range (f func (_aa rune )(_daf bool )){_cfc ._df .RLock ();defer _cfc ._df .RUnlock ();for _cc :=range _cfc ._ef {if f (_cc ){break ;};};};func (_db *RuneStringMap )Range (f func (_fg rune ,_ac string )(_eed bool )){_db ._bfa .RLock ();
defer _db ._bfa .RUnlock ();for _edd ,_eaf :=range _db ._cfcg {if f (_edd ,_eaf ){break ;};};};func (_bfc *RuneUint16Map )Write (r rune ,g uint16 ){_bfc ._ad .Lock ();defer _bfc ._ad .Unlock ();_bfc ._acd [r ]=g ;};type RuneByteMap struct{_dc map[rune ]byte ;
_gd _g .RWMutex ;};func NewRuneStringMap (m map[rune ]string )*RuneStringMap {return &RuneStringMap {_cfcg :m }};func NewStringsMap (tuples []StringsTuple )*StringsMap {_egag :=map[string ]string {};for _ ,_gea :=range tuples {_egag [_gea .Key ]=_gea .Value ;
};return &StringsMap {_fff :_egag };};func (_beb *StringRuneMap )Read (g string )(rune ,bool ){_beb ._bb .RLock ();defer _beb ._bb .RUnlock ();_agd ,_bcde :=_beb ._eda [g ];return _agd ,_bcde ;};func (_aab *StringsMap )Read (g string )(string ,bool ){_aab ._fdd .RLock ();
defer _aab ._fdd .RUnlock ();_ede ,_dg :=_aab ._fff [g ];return _ede ,_dg ;};func (_ega *StringRuneMap )Range (f func (_age string ,_ecd rune )(_bdg bool )){_ega ._bb .RLock ();defer _ega ._bb .RUnlock ();for _cd ,_ddd :=range _ega ._eda {if f (_cd ,_ddd ){break ;
};};};func (_ba *ByteRuneMap )Length ()int {_ba ._d .RLock ();defer _ba ._d .RUnlock ();return len (_ba ._c )};func (_ge *ByteRuneMap )Read (b byte )(rune ,bool ){_ge ._d .RLock ();defer _ge ._d .RUnlock ();_bf ,_bc :=_ge ._c [b ];return _bf ,_bc ;};