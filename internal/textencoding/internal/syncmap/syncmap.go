//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package syncmap ;import _a "sync";func (_dbe *StringsMap )Write (g1 ,g2 string ){_dbe ._eae .Lock ();defer _dbe ._eae .Unlock ();_dbe ._gc [g1 ]=g2 ;};func (_c *RuneByteMap )Read (r rune )(byte ,bool ){_c ._geb .RLock ();defer _c ._geb .RUnlock ();_cg ,_bgg :=_c ._ge [r ];
return _cg ,_bgg ;};type RuneByteMap struct{_ge map[rune ]byte ;_geb _a .RWMutex ;};func NewRuneStringMap (m map[rune ]string )*RuneStringMap {return &RuneStringMap {_ag :m }};func (_gf *RuneByteMap )Range (f func (_fd rune ,_bc byte )(_gfg bool )){_gf ._geb .RLock ();
defer _gf ._geb .RUnlock ();for _dg ,_ef :=range _gf ._ge {if f (_dg ,_ef ){break ;};};};func (_fff *RuneSet )Exists (r rune )bool {_fff ._ad .RLock ();defer _fff ._ad .RUnlock ();_ ,_ffc :=_fff ._dgd [r ];return _ffc ;};func (_ff *ByteRuneMap )Write (b byte ,r rune ){_ff ._e .Lock ();
defer _ff ._e .Unlock ();_ff ._b [b ]=r };func (_fe *RuneUint16Map )Length ()int {_fe ._gfa .RLock ();defer _fe ._gfa .RUnlock ();return len (_fe ._ce );};type RuneStringMap struct{_ag map[rune ]string ;_fcg _a .RWMutex ;};type RuneUint16Map struct{_ce map[rune ]uint16 ;
_gfa _a .RWMutex ;};type StringRuneMap struct{_eaa map[string ]rune ;_gd _a .RWMutex ;};func (_ca *StringRuneMap )Range (f func (_bgde string ,_gec rune )(_baf bool )){_ca ._gd .RLock ();defer _ca ._gd .RUnlock ();for _gee ,_afd :=range _ca ._eaa {if f (_gee ,_afd ){break ;
};};};func (_afc *RuneUint16Map )Range (f func (_bd rune ,_de uint16 )(_gg bool )){_afc ._gfa .RLock ();defer _afc ._gfa .RUnlock ();for _fga ,_aa :=range _afc ._ce {if f (_fga ,_aa ){break ;};};};func (_cc *RuneByteMap )Length ()int {_cc ._geb .RLock ();
defer _cc ._geb .RUnlock ();return len (_cc ._ge )};func NewStringsMap (tuples []StringsTuple )*StringsMap {_ffg :=map[string ]string {};for _ ,_cfa :=range tuples {_ffg [_cfa .Key ]=_cfa .Value ;};return &StringsMap {_gc :_ffg };};func MakeRuneByteMap (length int )*RuneByteMap {_dc :=make (map[rune ]byte ,length );
return &RuneByteMap {_ge :_dc };};func (_ccb *RuneStringMap )Range (f func (_df rune ,_ea string )(_aeg bool )){_ccb ._fcg .RLock ();defer _ccb ._fcg .RUnlock ();for _ec ,_fdb :=range _ccb ._ag {if f (_ec ,_fdb ){break ;};};};func (_af *ByteRuneMap )Range (f func (_fa byte ,_bg rune )(_fc bool )){_af ._e .RLock ();
defer _af ._e .RUnlock ();for _bgd ,_g :=range _af ._b {if f (_bgd ,_g ){break ;};};};func (_fgg *StringRuneMap )Length ()int {_fgg ._gd .RLock ();defer _fgg ._gd .RUnlock ();return len (_fgg ._eaa );};func (_ae *RuneSet )Write (r rune ){_ae ._ad .Lock ();
defer _ae ._ad .Unlock ();_ae ._dgd [r ]=struct{}{}};func NewStringRuneMap (m map[string ]rune )*StringRuneMap {return &StringRuneMap {_eaa :m }};func (_aee *StringRuneMap )Read (g string )(rune ,bool ){_aee ._gd .RLock ();defer _aee ._gd .RUnlock ();_aag ,_gea :=_aee ._eaa [g ];
return _aag ,_gea ;};type RuneSet struct{_dgd map[rune ]struct{};_ad _a .RWMutex ;};func (_bbd *RuneUint16Map )Write (r rune ,g uint16 ){_bbd ._gfa .Lock ();defer _bbd ._gfa .Unlock ();_bbd ._ce [r ]=g ;};func MakeRuneUint16Map (length int )*RuneUint16Map {return &RuneUint16Map {_ce :make (map[rune ]uint16 ,length )};
};func (_cb *StringsMap )Copy ()*StringsMap {_cb ._eae .RLock ();defer _cb ._eae .RUnlock ();_cdg :=map[string ]string {};for _da ,_eea :=range _cb ._gc {_cdg [_da ]=_eea ;};return &StringsMap {_gc :_cdg };};func (_cd *RuneSet )Length ()int {_cd ._ad .RLock ();
defer _cd ._ad .RUnlock ();return len (_cd ._dgd )};func (_dga *RuneUint16Map )Delete (r rune ){_dga ._gfa .Lock ();defer _dga ._gfa .Unlock ();delete (_dga ._ce ,r );};func (_bgc *RuneStringMap )Length ()int {_bgc ._fcg .RLock ();defer _bgc ._fcg .RUnlock ();
return len (_bgc ._ag );};func MakeRuneSet (length int )*RuneSet {return &RuneSet {_dgd :make (map[rune ]struct{},length )}};type StringsMap struct{_gc map[string ]string ;_eae _a .RWMutex ;};func (_dd *RuneUint16Map )Read (r rune )(uint16 ,bool ){_dd ._gfa .RLock ();
defer _dd ._gfa .RUnlock ();_cec ,_fffd :=_dd ._ce [r ];return _cec ,_fffd ;};func NewByteRuneMap (m map[byte ]rune )*ByteRuneMap {return &ByteRuneMap {_b :m }};type StringsTuple struct{Key ,Value string ;};func (_bf *RuneByteMap )Write (r rune ,b byte ){_bf ._geb .Lock ();
defer _bf ._geb .Unlock ();_bf ._ge [r ]=b ;};type ByteRuneMap struct{_b map[byte ]rune ;_e _a .RWMutex ;};func (_gb *ByteRuneMap )Length ()int {_gb ._e .RLock ();defer _gb ._e .RUnlock ();return len (_gb ._b )};func (_gfd *RuneStringMap )Read (r rune )(string ,bool ){_gfd ._fcg .RLock ();
defer _gfd ._fcg .RUnlock ();_db ,_dba :=_gfd ._ag [r ];return _db ,_dba ;};func (_eef *StringsMap )Read (g string )(string ,bool ){_eef ._eae .RLock ();defer _eef ._eae .RUnlock ();_dde ,_bgf :=_eef ._gc [g ];return _dde ,_bgf ;};func (_bcc *RuneUint16Map )RangeDelete (f func (_bag rune ,_ddd uint16 )(_bcd bool ,_dfe bool )){_bcc ._gfa .Lock ();
defer _bcc ._gfa .Unlock ();for _ceb ,_bdb :=range _bcc ._ce {_cfb ,_afb :=f (_ceb ,_bdb );if _cfb {delete (_bcc ._ce ,_ceb );};if _afb {break ;};};};func MakeByteRuneMap (length int )*ByteRuneMap {return &ByteRuneMap {_b :make (map[byte ]rune ,length )}};
func (_cdd *StringsMap )Range (f func (_cgf ,_fdba string )(_gda bool )){_cdd ._eae .RLock ();defer _cdd ._eae .RUnlock ();for _efd ,_efg :=range _cdd ._gc {if f (_efd ,_efg ){break ;};};};func (_bb *RuneSet )Range (f func (_fg rune )(_bcb bool )){_bb ._ad .RLock ();
defer _bb ._ad .RUnlock ();for _ba :=range _bb ._dgd {if f (_ba ){break ;};};};func (_age *StringRuneMap )Write (g string ,r rune ){_age ._gd .Lock ();defer _age ._gd .Unlock ();_age ._eaa [g ]=r ;};func (_cf *RuneStringMap )Write (r rune ,s string ){_cf ._fcg .Lock ();
defer _cf ._fcg .Unlock ();_cf ._ag [r ]=s ;};func (_ee *ByteRuneMap )Read (b byte )(rune ,bool ){_ee ._e .RLock ();defer _ee ._e .RUnlock ();_be ,_d :=_ee ._b [b ];return _be ,_d ;};