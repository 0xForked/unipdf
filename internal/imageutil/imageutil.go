//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package imageutil ;import (_b "errors";_cg "fmt";_ce "github.com/unidoc/unipdf/v3/internal/bitwise";_c "image";_ed "image/color";_de "image/draw";_d "math";);func (_dea *Monochrome )Base ()*ImageBase {return &_dea .ImageBase };func (_dgdg *NRGBA32 )NRGBAAt (x ,y int )_ed .NRGBA {_gaad ,_ :=ColorAtNRGBA32 (x ,y ,_dgdg .Width ,_dgdg .Data ,_dgdg .Alpha ,_dgdg .Decode );return _gaad ;};var _begb [256]uint8 ;type Gray interface{GrayAt (_baf ,_aed int )_ed .Gray ;SetGray (_fdd ,_dba int ,_daf _ed .Gray );};func (_egad *Gray4 )SetGray (x ,y int ,g _ed .Gray ){if x >=_egad .Width ||y >=_egad .Height {return ;};g =_bbc (g );_egad .setGray (x ,y ,g );};func (_bbe *Gray4 )ColorAt (x ,y int )(_ed .Color ,error ){return ColorAtGray4BPC (x ,y ,_bbe .BytesPerLine ,_bbe .Data ,_bbe .Decode );};var _ Image =&Gray2 {};func (_ffdc *Gray8 )Validate ()error {if len (_ffdc .Data )!=_ffdc .Height *_ffdc .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_cgg *Monochrome )Histogram ()(_fba [256]int ){for _ ,_dbg :=range _cgg .Data {_fba [0xff]+=int (_begb [_cgg .Data [_dbg ]]);};return _fba ;};func (_cae *NRGBA32 )ColorAt (x ,y int )(_ed .Color ,error ){return ColorAtNRGBA32 (x ,y ,_cae .Width ,_cae .Data ,_cae .Alpha ,_cae .Decode );};func (_cgdd *NRGBA16 )Bounds ()_c .Rectangle {return _c .Rectangle {Max :_c .Point {X :_cgdd .Width ,Y :_cgdd .Height }};};func _ab (_cgd _ed .NRGBA )_ed .CMYK {_ccd ,_bdf ,_ega ,_ :=_cgd .RGBA ();_abg ,_bfb ,_ddd ,_fa :=_ed .RGBToCMYK (uint8 (_ccd >>8),uint8 (_bdf >>8),uint8 (_ega >>8));return _ed .CMYK {C :_abg ,M :_bfb ,Y :_ddd ,K :_fa };};func ColorAt (x ,y ,width ,bitsPerColor ,colorComponents ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_ed .Color ,error ){switch colorComponents {case 1:return ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine ,data ,decode );case 3:return ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor ,data ,alpha ,decode );case 4:return ColorAtCMYK (x ,y ,width ,data ,decode );default:return nil ,_cg .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0063o\u006c\u006f\u0072\u0020\u0063\u006f\u006dp\u006f\u006e\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0064",colorComponents );};};func (_gbf *Monochrome )At (x ,y int )_ed .Color {_afc ,_ :=_gbf .ColorAt (x ,y );return _afc };func _bge (_eeag ,_dcdg uint8 )uint8 {if _eeag < _dcdg {return 255;};return 0;};func MonochromeThresholdConverter (threshold uint8 )ColorConverter {return &monochromeThresholdConverter {Threshold :threshold };};func (_ff *CMYK32 )Validate ()error {if len (_ff .Data )!=4*_ff .Width *_ff .Height {return _b .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");};return nil ;};var _ Gray =&Gray8 {};func (_cacc *Gray4 )Histogram ()(_abb [256]int ){for _dfdc :=0;_dfdc < _cacc .Width ;_dfdc ++{for _bcg :=0;_bcg < _cacc .Height ;_bcg ++{_abb [_cacc .GrayAt (_dfdc ,_bcg ).Y ]++;};};return _abb ;};func NewImageBase (width int ,height int ,bitsPerComponent int ,colorComponents int ,data []byte ,alpha []byte ,decode []float64 )ImageBase {_agca :=ImageBase {Width :width ,Height :height ,BitsPerComponent :bitsPerComponent ,ColorComponents :colorComponents ,Data :data ,Alpha :alpha ,Decode :decode ,BytesPerLine :BytesPerLine (width ,bitsPerComponent ,colorComponents )};if data ==nil {_agca .Data =make ([]byte ,height *_agca .BytesPerLine );};return _agca ;};func (_bfed *Monochrome )setBit (_efac ,_bc int ){_bfed .Data [_efac ]|=0x80>>uint (_bc &7)};func (_edg *Gray8 )Histogram ()(_eeb [256]int ){for _ccfc :=0;_ccfc < len (_edg .Data );_ccfc ++{_eeb [_edg .Data [_ccfc ]]++;};return _eeb ;};func ColorAtGray2BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_ed .Gray ,error ){_babe :=y *bytesPerLine +x >>2;if _babe >=len (data ){return _ed .Gray {},_cg .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_ddf :=data [_babe ]>>uint (6-(x &3)*2)&3;if len (decode )==2{_ddf =uint8 (uint32 (LinearInterpolate (float64 (_ddf ),0,3.0,decode [0],decode [1]))&3);};return _ed .Gray {Y :_ddf *85},nil ;};func _af (_bb _c .Image )(Image ,error ){if _gb ,_bg :=_bb .(*Monochrome );_bg {return _gb ,nil ;};_cbb ,_dddf :=_bb .(Gray );if !_dddf {_dbac ,_ffc :=GrayConverter .Convert (_bb );if _ffc !=nil {return nil ,_ffc ;};_cbb =_dbac .(Gray );};_gddc :=_bb .Bounds ();_acg ,_cac :=NewImage (_gddc .Max .X ,_gddc .Max .Y ,1,1,nil ,nil ,nil );if _cac !=nil {return nil ,_cac ;};_cbg :=_acg .(*Monochrome );_eaac :=AutoThresholdTriangle (GrayHistogram (_cbb ));for _fbf :=0;_fbf < _gddc .Max .X ;_fbf ++{for _bdg :=0;_bdg < _gddc .Max .Y ;_bdg ++{_gec :=_fad (_cbb .GrayAt (_fbf ,_bdg ),monochromeModel (_eaac ));_cbg .SetGray (_fbf ,_bdg ,_gec );};};return _acg ,nil ;};func (_acfd *NRGBA32 )At (x ,y int )_ed .Color {_cee ,_ :=_acfd .ColorAt (x ,y );return _cee };func (_gga *NRGBA64 )Set (x ,y int ,c _ed .Color ){_cafe :=(y *_gga .Width +x )*2;_gdcad :=_cafe *3;if _gdcad +5>=len (_gga .Data ){return ;};_abee :=_ed .NRGBA64Model .Convert (c ).(_ed .NRGBA64 );_gga .setNRGBA64 (_gdcad ,_abee ,_cafe );};type NRGBA64 struct{ImageBase };func _cfcda (_gagf _ed .NRGBA )_ed .NRGBA {_gagf .R =_gagf .R >>4|(_gagf .R >>4)<<4;_gagf .G =_gagf .G >>4|(_gagf .G >>4)<<4;_gagf .B =_gagf .B >>4|(_gagf .B >>4)<<4;return _gagf ;};func (_fdcd *NRGBA64 )At (x ,y int )_ed .Color {_bbg ,_ :=_fdcd .ColorAt (x ,y );return _bbg };func _fcb (_fdc _ed .Gray )_ed .CMYK {return _ed .CMYK {K :0xff-_fdc .Y }};var _ Image =&Monochrome {};func (_ddc *ImageBase )copy ()ImageBase {_aeg :=*_ddc ;_aeg .Data =make ([]byte ,len (_ddc .Data ));copy (_aeg .Data ,_ddc .Data );return _aeg ;};func ColorAtCMYK (x ,y ,width int ,data []byte ,decode []float64 )(_ed .CMYK ,error ){_fb :=4*(y *width +x );if _fb +3>=len (data ){return _ed .CMYK {},_cg .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};C :=data [_fb ]&0xff;M :=data [_fb +1]&0xff;Y :=data [_fb +2]&0xff;K :=data [_fb +3]&0xff;if len (decode )==8{C =uint8 (uint32 (LinearInterpolate (float64 (C ),0,255,decode [0],decode [1]))&0xff);M =uint8 (uint32 (LinearInterpolate (float64 (M ),0,255,decode [2],decode [3]))&0xff);Y =uint8 (uint32 (LinearInterpolate (float64 (Y ),0,255,decode [4],decode [5]))&0xff);K =uint8 (uint32 (LinearInterpolate (float64 (K ),0,255,decode [6],decode [7]))&0xff);};return _ed .CMYK {C :C ,M :M ,Y :Y ,K :K },nil ;};func ColorAtGray4BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_ed .Gray ,error ){_afb :=y *bytesPerLine +x >>1;if _afb >=len (data ){return _ed .Gray {},_cg .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_fgdg :=data [_afb ]>>uint (4-(x &1)*4)&0xf;if len (decode )==2{_fgdg =uint8 (uint32 (LinearInterpolate (float64 (_fgdg ),0,15,decode [0],decode [1]))&0xf);};return _ed .Gray {Y :_fgdg *17&0xff},nil ;};func (_ggde *NRGBA32 )Copy ()Image {return &NRGBA32 {ImageBase :_ggde .copy ()}};func (_dcf *Gray8 )Copy ()Image {return &Gray8 {ImageBase :_dcf .copy ()}};type NRGBA16 struct{ImageBase };func _dcbeg (_ggcc _c .Image ,_bae uint8 )*_c .Gray {_gged :=_ggcc .Bounds ();_adg :=_c .NewGray (_gged );var (_dfca _ed .Color ;_aece _ed .Gray ;);for _gdef :=0;_gdef < _gged .Max .X ;_gdef ++{for _abbe :=0;_abbe < _gged .Max .Y ;_abbe ++{_dfca =_ggcc .At (_gdef ,_abbe );_adg .Set (_gdef ,_abbe ,_dfca );_aece =_adg .GrayAt (_gdef ,_abbe );_adg .SetGray (_gdef ,_abbe ,_ed .Gray {Y :_bge (_aece .Y ,_bae )});};};return _adg ;};func (_debc *Gray2 )Set (x ,y int ,c _ed .Color ){if x >=_debc .Width ||y >=_debc .Height {return ;};_degc :=Gray2Model .Convert (c ).(_ed .Gray );_bad :=y *_debc .BytesPerLine ;_fae :=_bad +(x >>2);_eaga :=_degc .Y >>6;_debc .Data [_fae ]=(_debc .Data [_fae ]&(^(0xc0>>uint (2*((x )&3)))))|(_eaga <<uint (6-2*(x &3)));};func (_gfeg *Monochrome )ColorModel ()_ed .Model {return MonochromeModel (_gfeg .ModelThreshold )};func _eggd (_edffa *_c .NYCbCrA ,_ecf NRGBA ,_fefc _c .Rectangle ){for _beef :=0;_beef < _fefc .Max .X ;_beef ++{for _ebga :=0;_ebga < _fefc .Max .Y ;_ebga ++{_becg :=_edffa .NYCbCrAAt (_beef ,_ebga );_ecf .SetNRGBA (_beef ,_ebga ,_fde (_becg ));};};};func init (){_fgg ()};func (_fecg *Gray16 )Histogram ()(_ggcd [256]int ){for _bddd :=0;_bddd < _fecg .Width ;_bddd ++{for _fbbg :=0;_fbbg < _fecg .Height ;_fbbg ++{_ggcd [_fecg .GrayAt (_bddd ,_fbbg ).Y ]++;};};return _ggcd ;};func NewImage (width ,height ,bitsPerComponent ,colorComponents int ,data ,alpha []byte ,decode []float64 )(Image ,error ){_ebgg :=NewImageBase (width ,height ,bitsPerComponent ,colorComponents ,data ,alpha ,decode );var _fgb Image ;switch colorComponents {case 1:switch bitsPerComponent {case 1:_fgb =&Monochrome {ImageBase :_ebgg ,ModelThreshold :0x0f};case 2:_fgb =&Gray2 {ImageBase :_ebgg };case 4:_fgb =&Gray4 {ImageBase :_ebgg };case 8:_fgb =&Gray8 {ImageBase :_ebgg };case 16:_fgb =&Gray16 {ImageBase :_ebgg };};case 3:switch bitsPerComponent {case 4:_fgb =&NRGBA16 {ImageBase :_ebgg };case 8:_fgb =&NRGBA32 {ImageBase :_ebgg };case 16:_fgb =&NRGBA64 {ImageBase :_ebgg };};case 4:_fgb =&CMYK32 {ImageBase :_ebgg };};if _fgb ==nil {return nil ,ErrInvalidImage ;};return _fgb ,nil ;};func (_bdbfc *NRGBA64 )setNRGBA64 (_dfdd int ,_acfb _ed .NRGBA64 ,_bfag int ){_bdbfc .Data [_dfdd ]=uint8 (_acfb .R >>8);_bdbfc .Data [_dfdd +1]=uint8 (_acfb .R &0xff);_bdbfc .Data [_dfdd +2]=uint8 (_acfb .G >>8);_bdbfc .Data [_dfdd +3]=uint8 (_acfb .G &0xff);_bdbfc .Data [_dfdd +4]=uint8 (_acfb .B >>8);_bdbfc .Data [_dfdd +5]=uint8 (_acfb .B &0xff);if _bfag +1< len (_bdbfc .Alpha ){_bdbfc .Alpha [_bfag ]=uint8 (_acfb .A >>8);_bdbfc .Alpha [_bfag +1]=uint8 (_acfb .A &0xff);};};func (_dda *Gray2 )Base ()*ImageBase {return &_dda .ImageBase };func _edf (_cag Gray ,_bdb CMYK ,_be _c .Rectangle ){for _egf :=0;_egf < _be .Max .X ;_egf ++{for _fe :=0;_fe < _be .Max .Y ;_fe ++{_bdbf :=_cag .GrayAt (_egf ,_fe );_bdb .SetCMYK (_egf ,_fe ,_fcb (_bdbf ));};};};func _bbc (_ggd _ed .Gray )_ed .Gray {_ggd .Y >>=4;_ggd .Y |=_ggd .Y <<4;return _ggd };func _ccb (_afbe _c .Image )(Image ,error ){if _eaaa ,_eafg :=_afbe .(*Gray8 );_eafg {return _eaaa .Copy (),nil ;};_afg :=_afbe .Bounds ();_fcd ,_bdga :=NewImage (_afg .Max .X ,_afg .Max .Y ,8,1,nil ,nil ,nil );if _bdga !=nil {return nil ,_bdga ;};_bgfe (_afbe ,_fcd ,_afg );return _fcd ,nil ;};func (_ec *CMYK32 )Bounds ()_c .Rectangle {return _c .Rectangle {Max :_c .Point {X :_ec .Width ,Y :_ec .Height }};};func (_aedb *ImageBase )GetAlpha ()[]byte {return _aedb .Alpha };func (_afe *Monochrome )ColorAt (x ,y int )(_ed .Color ,error ){return ColorAtGray1BPC (x ,y ,_afe .BytesPerLine ,_afe .Data ,_afe .Decode );};func _ga (_dag _ed .RGBA )_ed .Gray {_caf :=(19595*uint32 (_dag .R )+38470*uint32 (_dag .G )+7471*uint32 (_dag .B )+1<<7)>>16;return _ed .Gray {Y :uint8 (_caf )};};func _acd (_fgef _ed .RGBA )_ed .NRGBA {switch _fgef .A {case 0xff:return _ed .NRGBA {R :_fgef .R ,G :_fgef .G ,B :_fgef .B ,A :0xff};case 0x00:return _ed .NRGBA {};default:_dbb ,_aaf ,_egg ,_deb :=_fgef .RGBA ();_dbb =(_dbb *0xffff)/_deb ;_aaf =(_aaf *0xffff)/_deb ;_egg =(_egg *0xffff)/_deb ;return _ed .NRGBA {R :uint8 (_dbb >>8),G :uint8 (_aaf >>8),B :uint8 (_egg >>8),A :uint8 (_deb >>8)};};};type Gray8 struct{ImageBase };func _gfg (_fgd NRGBA ,_ecd CMYK ,_cdc _c .Rectangle ){for _ag :=0;_ag < _cdc .Max .X ;_ag ++{for _fd :=0;_fd < _cdc .Max .Y ;_fd ++{_fcc :=_fgd .NRGBAAt (_ag ,_fd );_ecd .SetCMYK (_ag ,_fd ,_ab (_fcc ));};};};func (_fbbe *NRGBA16 )ColorModel ()_ed .Model {return NRGBA16Model };func (_dg *CMYK32 )ColorAt (x ,y int )(_ed .Color ,error ){return ColorAtCMYK (x ,y ,_dg .Width ,_dg .Data ,_dg .Decode );};func (_dfgg monochromeModel )Convert (c _ed .Color )_ed .Color {_ccf :=_ed .GrayModel .Convert (c ).(_ed .Gray );return _fad (_ccf ,_dfgg );};func (_cefc *Gray4 )Base ()*ImageBase {return &_cefc .ImageBase };func LinearInterpolate (x ,xmin ,xmax ,ymin ,ymax float64 )float64 {if _d .Abs (xmax -xmin )< 0.000001{return ymin ;};_egbg :=ymin +(x -xmin )*(ymax -ymin )/(xmax -xmin );return _egbg ;};func _bf (_cab _ed .NRGBA )_ed .Gray {_aaa ,_cgf ,_eaa ,_ :=_cab .RGBA ();_ged :=(19595*_aaa +38470*_cgf +7471*_eaa +1<<15)>>24;return _ed .Gray {Y :uint8 (_ged )};};func (_cfe *NRGBA16 )Validate ()error {if len (_cfe .Data )!=3*_cfe .Width *_cfe .Height /2{return _b .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");};return nil ;};func (_fgeff *Monochrome )clearBit (_cfg ,_agc int ){_fgeff .Data [_cfg ]&=^(0x80>>uint (_agc &7))};func _dggg (_abf _ed .Color )_ed .Color {_adf :=_ed .GrayModel .Convert (_abf ).(_ed .Gray );return _bbc (_adf );};func ColorAtGray8BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_ed .Gray ,error ){_eef :=y *bytesPerLine +x ;if _eef >=len (data ){return _ed .Gray {},_cg .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_abe :=data [_eef ];if len (decode )==2{_abe =uint8 (uint32 (LinearInterpolate (float64 (_abe ),0,255,decode [0],decode [1]))&0xff);};return _ed .Gray {Y :_abe },nil ;};func (_debf *NRGBA16 )At (x ,y int )_ed .Color {_ffad ,_ :=_debf .ColorAt (x ,y );return _ffad };var _ _c .Image =&Gray4 {};func _ba (_dce RGBA ,_feb CMYK ,_dad _c .Rectangle ){for _dab :=0;_dab < _dad .Max .X ;_dab ++{for _ad :=0;_ad < _dad .Max .Y ;_ad ++{_gea :=_dce .RGBAAt (_dab ,_ad );_feb .SetCMYK (_dab ,_ad ,_dec (_gea ));};};};func (_ge *CMYK32 )Base ()*ImageBase {return &_ge .ImageBase };var _ Image =&NRGBA16 {};func _add (_efg RGBA ,_bag Gray ,_babea _c .Rectangle ){for _efbg :=0;_efbg < _babea .Max .X ;_efbg ++{for _dgae :=0;_dgae < _babea .Max .Y ;_dgae ++{_cafa :=_ga (_efg .RGBAAt (_efbg ,_dgae ));_bag .SetGray (_efbg ,_dgae ,_cafa );};};};func (_bade *Gray16 )ColorModel ()_ed .Model {return _ed .Gray16Model };func (_afab *Gray2 )Validate ()error {if len (_afab .Data )!=_afab .Height *_afab .BytesPerLine {return ErrInvalidImage ;};return nil ;};func _feg (_agf _ed .CMYK )_ed .Gray {_dgg ,_fge ,_fdg :=_ed .CMYKToRGB (_agf .C ,_agf .M ,_agf .Y ,_agf .K );_cgb :=(19595*uint32 (_dgg )+38470*uint32 (_fge )+7471*uint32 (_fdg )+1<<7)>>16;return _ed .Gray {Y :uint8 (_cgb )};};type nrgba64 interface{NRGBA64At (_dgbc ,_eddgg int )_ed .NRGBA64 ;SetNRGBA64 (_aeccg ,_gdf int ,_cff _ed .NRGBA64 );};func (_adda *NRGBA16 )Copy ()Image {return &NRGBA16 {ImageBase :_adda .copy ()}};func (_acc *ImageBase )newAlpha (){_cgef :=BytesPerLine (_acc .Width ,_acc .BitsPerComponent ,1);_acc .Alpha =make ([]byte ,_acc .Height *_cgef );};func GetConverter (bitsPerComponent ,colorComponents int )(ColorConverter ,error ){switch colorComponents {case 1:switch bitsPerComponent {case 1:return MonochromeConverter ,nil ;case 2:return Gray2Converter ,nil ;case 4:return Gray4Converter ,nil ;case 8:return GrayConverter ,nil ;case 16:return Gray16Converter ,nil ;};case 3:switch bitsPerComponent {case 4:return NRGBA16Converter ,nil ;case 8:return NRGBAConverter ,nil ;case 16:return NRGBA64Converter ,nil ;};case 4:return CMYKConverter ,nil ;};return nil ,_cg .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0043o\u006e\u0076\u0065\u0072\u0074\u0065\u0072\u0020\u0070\u0061\u0072\u0061\u006d\u0065t\u0065\u0072\u0073\u002e\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003a\u0020\u0025\u0064\u002c\u0020\u0043\u006f\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006et\u0073\u003a \u0025\u0064",bitsPerComponent ,colorComponents );};func MonochromeModel (threshold uint8 )_ed .Model {return monochromeModel (threshold )};func _bd (_deg _c .Image )(Image ,error ){if _gg ,_ae :=_deg .(*CMYK32 );_ae {return _gg .Copy (),nil ;};_cb :=_deg .Bounds ();_ccg ,_ca :=NewImage (_cb .Max .X ,_cb .Max .Y ,8,4,nil ,nil ,nil );if _ca !=nil {return nil ,_ca ;};switch _bdc :=_deg .(type ){case CMYK :_geb (_bdc ,_ccg .(CMYK ),_cb );case Gray :_edf (_bdc ,_ccg .(CMYK ),_cb );case NRGBA :_gfg (_bdc ,_ccg .(CMYK ),_cb );case RGBA :_ba (_bdc ,_ccg .(CMYK ),_cb );default:_bec (_deg ,_ccg ,_cb );};return _ccg ,nil ;};func (_cacd *Gray16 )Validate ()error {if len (_cacd .Data )!=_cacd .Height *_cacd .BytesPerLine {return ErrInvalidImage ;};return nil ;};func _gcg (_cdb _ed .CMYK )_ed .NRGBA {_gd ,_ac ,_cdg :=_ed .CMYKToRGB (_cdb .C ,_cdb .M ,_cdb .Y ,_cdb .K );return _ed .NRGBA {R :_gd ,G :_ac ,B :_cdg ,A :0xff};};func FromGoImage (i _c .Image )(Image ,error ){switch _afgf :=i .(type ){case Image :return _afgf .Copy (),nil ;case Gray :return GrayConverter .Convert (i );case *_c .Gray16 :return Gray16Converter .Convert (i );case CMYK :return CMYKConverter .Convert (i );case *_c .NRGBA64 :return NRGBA64Converter .Convert (i );default:return NRGBAConverter .Convert (i );};};func (_edff *Gray8 )Base ()*ImageBase {return &_edff .ImageBase };func IsGrayImgBlackAndWhite (i *_c .Gray )bool {return _cdbb (i )};func (_cbfa *Gray2 )Copy ()Image {return &Gray2 {ImageBase :_cbfa .copy ()}};func _bbde (_gdca []byte ,_aaebf Image )error {_dfbc :=true ;for _adfe :=0;_adfe < len (_gdca );_adfe ++{if _gdca [_adfe ]!=0xff{_dfbc =false ;break ;};};if _dfbc {switch _gbac :=_aaebf .(type ){case *NRGBA32 :_gbac .Alpha =nil ;case *NRGBA64 :_gbac .Alpha =nil ;default:return _cg .Errorf ("i\u006ete\u0072n\u0061l\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020i\u006d\u0061\u0067\u0065\u0020s\u0068\u006f\u0075l\u0064\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0074\u0079\u0070e\u0020\u002a\u004eRGB\u0041\u0033\u0032\u0020\u006f\u0072 \u002a\u004e\u0052\u0047\u0042\u0041\u0036\u0034\u0020\u0062\u0075\u0074 \u0069s\u003a\u0020\u0025\u0054",_aaebf );};};return nil ;};func (_eff *Gray4 )At (x ,y int )_ed .Color {_cfcd ,_ :=_eff .ColorAt (x ,y );return _cfcd };var _ Image =&Gray4 {};func (_cdf *Gray8 )At (x ,y int )_ed .Color {_baa ,_ :=_cdf .ColorAt (x ,y );return _baa };func (_acdc *Gray8 )GrayAt (x ,y int )_ed .Gray {_bdbd ,_ :=ColorAtGray8BPC (x ,y ,_acdc .BytesPerLine ,_acdc .Data ,_acdc .Decode );return _bdbd ;};func (_deag *ImageBase )Pix ()[]byte {return _deag .Data };func (_cga *NRGBA32 )Set (x ,y int ,c _ed .Color ){_daga :=y *_cga .Width +x ;_gcbg :=3*_daga ;if _gcbg +2>=len (_cga .Data ){return ;};_fddd :=_ed .NRGBAModel .Convert (c ).(_ed .NRGBA );_cga .setRGBA (_daga ,_fddd );};func (_dgd *Gray16 )ColorAt (x ,y int )(_ed .Color ,error ){return ColorAtGray16BPC (x ,y ,_dgd .BytesPerLine ,_dgd .Data ,_dgd .Decode );};var _ Image =&CMYK32 {};func (_dge *NRGBA64 )ColorAt (x ,y int )(_ed .Color ,error ){return ColorAtNRGBA64 (x ,y ,_dge .Width ,_dge .Data ,_dge .Alpha ,_dge .Decode );};var (MonochromeConverter =ConverterFunc (_af );Gray2Converter =ConverterFunc (_dbe );Gray4Converter =ConverterFunc (_ggb );GrayConverter =ConverterFunc (_ccb );Gray16Converter =ConverterFunc (_geeb );NRGBA16Converter =ConverterFunc (_badf );NRGBAConverter =ConverterFunc (_efcf );NRGBA64Converter =ConverterFunc (_faa );CMYKConverter =ConverterFunc (_bd ););func (_gge *Gray16 )At (x ,y int )_ed .Color {_ggc ,_ :=_gge .ColorAt (x ,y );return _ggc };func (_aabc *Gray16 )SetGray (x ,y int ,g _ed .Gray ){_cebf :=(y *_aabc .BytesPerLine /2+x )*2;if _cebf +1>=len (_aabc .Data ){return ;};_aabc .Data [_cebf ]=g .Y ;_aabc .Data [_cebf +1]=g .Y ;};func _ebf (_ece _ed .Color )_ed .Color {_cbc :=_ed .GrayModel .Convert (_ece ).(_ed .Gray );return _fcbf (_cbc );};var _ Image =&Gray8 {};func (_bfdf *Gray16 )Base ()*ImageBase {return &_bfdf .ImageBase };var _ NRGBA =&NRGBA32 {};func (_dfb *Monochrome )Bounds ()_c .Rectangle {return _c .Rectangle {Max :_c .Point {X :_dfb .Width ,Y :_dfb .Height }};};func _fgg (){for _eggc :=0;_eggc < 256;_eggc ++{_begb [_eggc ]=uint8 (_eggc &0x1)+(uint8 (_eggc >>1)&0x1)+(uint8 (_eggc >>2)&0x1)+(uint8 (_eggc >>3)&0x1)+(uint8 (_eggc >>4)&0x1)+(uint8 (_eggc >>5)&0x1)+(uint8 (_eggc >>6)&0x1)+(uint8 (_eggc >>7)&0x1);};};func _cec (_cgbf NRGBA ,_dae Gray ,_gebb _c .Rectangle ){for _bffe :=0;_bffe < _gebb .Max .X ;_bffe ++{for _aeee :=0;_aeee < _gebb .Max .Y ;_aeee ++{_fdgg :=_bf (_cgbf .NRGBAAt (_bffe ,_aeee ));_dae .SetGray (_bffe ,_aeee ,_fdgg );};};};func _fad (_gddb _ed .Gray ,_fag monochromeModel )_ed .Gray {if _gddb .Y > uint8 (_fag ){return _ed .Gray {Y :_d .MaxUint8 };};return _ed .Gray {};};func _fdb (_ffaa nrgba64 ,_defg NRGBA ,_fabba _c .Rectangle ){for _afae :=0;_afae < _fabba .Max .X ;_afae ++{for _deeb :=0;_deeb < _fabba .Max .Y ;_deeb ++{_bdbdc :=_ffaa .NRGBA64At (_afae ,_deeb );_defg .SetNRGBA (_afae ,_deeb ,_eafd (_bdbdc ));};};};func (_afa *Monochrome )setGray (_ecg int ,_eb _ed .Gray ,_dabb int ){if _eb .Y ==0{_afa .clearBit (_dabb ,_ecg );}else {_afa .setBit (_dabb ,_ecg );};};func _aeb (_ccbb _c .Image ,_ade Image ,_dagf _c .Rectangle ){if _bce ,_bfff :=_ccbb .(SMasker );_bfff &&_bce .HasAlpha (){_ade .(SMasker ).MakeAlpha ();};switch _gfaa :=_ccbb .(type ){case Gray :_ecbb (_gfaa ,_ade .(NRGBA ),_dagf );case NRGBA :_egac (_gfaa ,_ade .(NRGBA ),_dagf );case *_c .NYCbCrA :_eggd (_gfaa ,_ade .(NRGBA ),_dagf );case CMYK :_ffga (_gfaa ,_ade .(NRGBA ),_dagf );case RGBA :_ggefg (_gfaa ,_ade .(NRGBA ),_dagf );case nrgba64 :_fdb (_gfaa ,_ade .(NRGBA ),_dagf );default:_bec (_ccbb ,_ade ,_dagf );};};var _ Gray =&Gray4 {};func (_ede *NRGBA16 )ColorAt (x ,y int )(_ed .Color ,error ){return ColorAtNRGBA16 (x ,y ,_ede .Width ,_ede .BytesPerLine ,_ede .Data ,_ede .Alpha ,_ede .Decode );};func (_cc *CMYK32 )CMYKAt (x ,y int )_ed .CMYK {_df ,_ :=ColorAtCMYK (x ,y ,_cc .Width ,_cc .Data ,_cc .Decode );return _df ;};func _efdae (_aff _c .Image ,_bedg int )(_c .Rectangle ,bool ,[]byte ){_daa :=_aff .Bounds ();var (_aaaa bool ;_deee []byte ;);switch _efbb :=_aff .(type ){case SMasker :_aaaa =_efbb .HasAlpha ();case NRGBA ,RGBA ,*_c .RGBA64 ,nrgba64 ,*_c .NYCbCrA :_deee =make ([]byte ,_daa .Max .X *_daa .Max .Y *_bedg );};return _daa ,_aaaa ,_deee ;};func (_cef *CMYK32 )Set (x ,y int ,c _ed .Color ){_cgc :=4*(y *_cef .Width +x );if _cgc +3>=len (_cef .Data ){return ;};_a :=_ed .CMYKModel .Convert (c ).(_ed .CMYK );_cef .Data [_cgc ]=_a .C ;_cef .Data [_cgc +1]=_a .M ;_cef .Data [_cgc +2]=_a .Y ;_cef .Data [_cgc +3]=_a .K ;};func _egac (_cgcb ,_gece NRGBA ,_ddcb _c .Rectangle ){for _ddfb :=0;_ddfb < _ddcb .Max .X ;_ddfb ++{for _ccfe :=0;_ccfe < _ddcb .Max .Y ;_ccfe ++{_gece .SetNRGBA (_ddfb ,_ccfe ,_cgcb .NRGBAAt (_ddfb ,_ccfe ));};};};func ConverterFunc (converterFunc func (_dbd _c .Image )(Image ,error ))ColorConverter {return colorConverter {_cdca :converterFunc };};func ColorAtNRGBA16 (x ,y ,width ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_ed .NRGBA ,error ){_gde :=y *bytesPerLine +x *3/2;if _gde +1>=len (data ){return _ed .NRGBA {},_ebad (x ,y );};const (_aecc =0xf;_dgga =uint8 (0xff););_edc :=_dgga ;if alpha !=nil {_dcee :=y *BytesPerLine (width ,4,1);if _dcee < len (alpha ){if x %2==0{_edc =(alpha [_dcee ]>>uint (4))&_aecc ;}else {_edc =alpha [_dcee ]&_aecc ;};_edc |=_edc <<4;};};var _gca ,_dca ,_aggd uint8 ;if x *3%2==0{_gca =(data [_gde ]>>uint (4))&_aecc ;_dca =data [_gde ]&_aecc ;_aggd =(data [_gde +1]>>uint (4))&_aecc ;}else {_gca =data [_gde ]&_aecc ;_dca =(data [_gde +1]>>uint (4))&_aecc ;_aggd =data [_gde +1]&_aecc ;};if len (decode )==6{_gca =uint8 (uint32 (LinearInterpolate (float64 (_gca ),0,15,decode [0],decode [1]))&0xf);_dca =uint8 (uint32 (LinearInterpolate (float64 (_dca ),0,15,decode [2],decode [3]))&0xf);_aggd =uint8 (uint32 (LinearInterpolate (float64 (_aggd ),0,15,decode [4],decode [5]))&0xf);};return _ed .NRGBA {R :(_gca <<4)|(_gca &0xf),G :(_dca <<4)|(_dca &0xf),B :(_aggd <<4)|(_aggd &0xf),A :_edc },nil ;};func _fbbb (_ecb _ed .Color )_ed .Color {_fdggc :=_ed .NRGBAModel .Convert (_ecb ).(_ed .NRGBA );return _cfcda (_fdggc );};func (_fga *Monochrome )GrayAt (x ,y int )_ed .Gray {_dga ,_ :=ColorAtGray1BPC (x ,y ,_fga .BytesPerLine ,_fga .Data ,_fga .Decode );return _dga ;};func (_fdae *NRGBA16 )setNRGBA (_ebd ,_deged ,_gdc int ,_gaf _ed .NRGBA ){if _ebd *3%2==0{_fdae .Data [_gdc ]=(_gaf .R >>4)<<4|(_gaf .G >>4);_fdae .Data [_gdc +1]=(_gaf .B >>4)<<4|(_fdae .Data [_gdc +1]&0xf);}else {_fdae .Data [_gdc ]=(_fdae .Data [_gdc ]&0xf0)|(_gaf .R >>4);_fdae .Data [_gdc +1]=(_gaf .G >>4)<<4|(_gaf .B >>4);};if _fdae .Alpha !=nil {_dgcg :=_deged *BytesPerLine (_fdae .Width ,4,1);if _dgcg < len (_fdae .Alpha ){if _ebd %2==0{_fdae .Alpha [_dgcg ]=(_gaf .A >>uint (4))<<uint (4)|(_fdae .Alpha [_gdc ]&0xf);}else {_fdae .Alpha [_dgcg ]=(_fdae .Alpha [_dgcg ]&0xf0)|(_gaf .A >>uint (4));};};};};func _ggefg (_geade RGBA ,_cce NRGBA ,_bgad _c .Rectangle ){for _efbf :=0;_efbf < _bgad .Max .X ;_efbf ++{for _bbcg :=0;_bbcg < _bgad .Max .Y ;_bbcg ++{_cdbf :=_geade .RGBAAt (_efbf ,_bbcg );_cce .SetNRGBA (_efbf ,_bbcg ,_acd (_cdbf ));};};};func _geeb (_gdb _c .Image )(Image ,error ){if _cabb ,_aaed :=_gdb .(*Gray16 );_aaed {return _cabb .Copy (),nil ;};_acgbe :=_gdb .Bounds ();_feac ,_ddg :=NewImage (_acgbe .Max .X ,_acgbe .Max .Y ,16,1,nil ,nil ,nil );if _ddg !=nil {return nil ,_ddg ;};_bgfe (_gdb ,_feac ,_acgbe );return _feac ,nil ;};type Gray16 struct{ImageBase };func (_ead *Monochrome )Set (x ,y int ,c _ed .Color ){_acgb :=y *_ead .BytesPerLine +x >>3;if _acgb > len (_ead .Data )-1{return ;};_adb :=_ead .ColorModel ().Convert (c ).(_ed .Gray );_ead .setGray (x ,_adb ,_acgb );};func (_gfc *NRGBA32 )ColorModel ()_ed .Model {return _ed .NRGBAModel };func (_aae *Gray16 )Copy ()Image {return &Gray16 {ImageBase :_aae .copy ()}};func (_db colorConverter )Convert (src _c .Image )(Image ,error ){return _db ._cdca (src )};func (_aga *NRGBA16 )Set (x ,y int ,c _ed .Color ){_gbc :=y *_aga .BytesPerLine +x *3/2;if _gbc +1>=len (_aga .Data ){return ;};_edee :=NRGBA16Model .Convert (c ).(_ed .NRGBA );_aga .setNRGBA (x ,y ,_gbc ,_edee );};func _dec (_ffd _ed .RGBA )_ed .CMYK {_bfe ,_fgf ,_bab ,_fcg :=_ed .RGBToCMYK (_ffd .R ,_ffd .G ,_ffd .B );return _ed .CMYK {C :_bfe ,M :_fgf ,Y :_bab ,K :_fcg };};var _ Gray =&Gray2 {};func _ecbb (_gdeg Gray ,_gfbc NRGBA ,_ccgc _c .Rectangle ){for _eab :=0;_eab < _ccgc .Max .X ;_eab ++{for _dgea :=0;_dgea < _ccgc .Max .Y ;_dgea ++{_fecge :=_gdeg .GrayAt (_eab ,_dgea );_gfbc .SetNRGBA (_eab ,_dgea ,_aee (_fecge ));};};};var (Gray2Model =_ed .ModelFunc (_ebf );Gray4Model =_ed .ModelFunc (_dggg );NRGBA16Model =_ed .ModelFunc (_fbbb ););func ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor int ,data ,alpha []byte ,decode []float64 )(_ed .Color ,error ){switch bitsPerColor {case 4:return ColorAtNRGBA16 (x ,y ,width ,bytesPerLine ,data ,alpha ,decode );case 8:return ColorAtNRGBA32 (x ,y ,width ,data ,alpha ,decode );case 16:return ColorAtNRGBA64 (x ,y ,width ,data ,alpha ,decode );default:return nil ,_cg .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0067\u0062\u0020b\u0069\u0074\u0073\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0061\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );};};type Gray4 struct{ImageBase };var _ _c .Image =&Monochrome {};func _bec (_ada _c .Image ,_ef Image ,_eda _c .Rectangle ){for _dd :=0;_dd < _eda .Max .X ;_dd ++{for _eeg :=0;_eeg < _eda .Max .Y ;_eeg ++{_agg :=_ada .At (_dd ,_eeg );_ef .Set (_dd ,_eeg ,_agg );};};};func ImgToGray (i _c .Image )*_c .Gray {if _dgfcb ,_fefa :=i .(*_c .Gray );_fefa {return _dgfcb ;};_ggba :=i .Bounds ();_geba :=_c .NewGray (_ggba );for _afbeb :=0;_afbeb < _ggba .Max .X ;_afbeb ++{for _fgaba :=0;_fgaba < _ggba .Max .Y ;_fgaba ++{_ceeg :=i .At (_afbeb ,_fgaba );_geba .Set (_afbeb ,_fgaba ,_ceeg );};};return _geba ;};func (_eddg *NRGBA32 )Bounds ()_c .Rectangle {return _c .Rectangle {Max :_c .Point {X :_eddg .Width ,Y :_eddg .Height }};};func (_dbc *Monochrome )SetGray (x ,y int ,g _ed .Gray ){_ded :=y *_dbc .BytesPerLine +x >>3;if _ded > len (_dbc .Data )-1{return ;};g =_fad (g ,monochromeModel (_dbc .ModelThreshold ));_dbc .setGray (x ,g ,_ded );};func (_gf *CMYK32 )ColorModel ()_ed .Model {return _ed .CMYKModel };var _ _c .Image =&Gray8 {};func (_aaee *NRGBA64 )SetNRGBA64 (x ,y int ,c _ed .NRGBA64 ){_efga :=(y *_aaee .Width +x )*2;_cacb :=_efga *3;if _cacb +5>=len (_aaee .Data ){return ;};_aaee .setNRGBA64 (_cacb ,c ,_efga );};func _badf (_ddcg _c .Image )(Image ,error ){if _bbcd ,_eaeb :=_ddcg .(*NRGBA16 );_eaeb {return _bbcd .Copy (),nil ;};_cdcd :=_ddcg .Bounds ();_bcc ,_bcd :=NewImage (_cdcd .Max .X ,_cdcd .Max .Y ,4,3,nil ,nil ,nil );if _bcd !=nil {return nil ,_bcd ;};_aeb (_ddcg ,_bcc ,_cdcd );return _bcc ,nil ;};func (_eage *Gray4 )setGray (_faec int ,_efb int ,_dfcf _ed .Gray ){_gbd :=_efb *_eage .BytesPerLine ;_eaag :=_gbd +(_faec >>1);if _eaag >=len (_eage .Data ){return ;};_ebg :=_dfcf .Y >>4;_eage .Data [_eaag ]=(_eage .Data [_eaag ]&(^(0xf0>>uint (4*(_faec &1)))))|(_ebg <<uint (4-4*(_faec &1)));};func (_bccg *NRGBA64 )Copy ()Image {return &NRGBA64 {ImageBase :_bccg .copy ()}};func (_bbf *Gray2 )At (x ,y int )_ed .Color {_ecdb ,_ :=_bbf .ColorAt (x ,y );return _ecdb };func BytesPerLine (width ,bitsPerComponent ,colorComponents int )int {return ((width *bitsPerComponent )*colorComponents +7)>>3;};func (_dbf *Gray4 )Set (x ,y int ,c _ed .Color ){if x >=_dbf .Width ||y >=_dbf .Height {return ;};_aade :=Gray4Model .Convert (c ).(_ed .Gray );_dbf .setGray (x ,y ,_aade );};type ImageBase struct{Width ,Height int ;BitsPerComponent ,ColorComponents int ;Data ,Alpha []byte ;Decode []float64 ;BytesPerLine int ;};func (_fcf *Gray8 )Set (x ,y int ,c _ed .Color ){_eca :=y *_fcf .BytesPerLine +x ;if _eca > len (_fcf .Data )-1{return ;};_afca :=_ed .GrayModel .Convert (c );_fcf .Data [_eca ]=_afca .(_ed .Gray ).Y ;};func (_gfb *CMYK32 )At (x ,y int )_ed .Color {_cd ,_ :=_gfb .ColorAt (x ,y );return _cd };func _ebad (_babg int ,_aaeb int )error {return _cg .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",_babg ,_aaeb );};func (_eae *Gray4 )Bounds ()_c .Rectangle {return _c .Rectangle {Max :_c .Point {X :_eae .Width ,Y :_eae .Height }};};func _geb (_eea ,_eec CMYK ,_da _c .Rectangle ){for _dfc :=0;_dfc < _da .Max .X ;_dfc ++{for _aea :=0;_aea < _da .Max .Y ;_aea ++{_eec .SetCMYK (_dfc ,_aea ,_eea .CMYKAt (_dfc ,_aea ));};};};func (_fged *Gray8 )ColorModel ()_ed .Model {return _ed .GrayModel };func (_ccc *Gray4 )Validate ()error {if len (_ccc .Data )!=_ccc .Height *_ccc .BytesPerLine {return ErrInvalidImage ;};return nil ;};func _aee (_gc _ed .Gray )_ed .NRGBA {return _ed .NRGBA {R :_gc .Y ,G :_gc .Y ,B :_gc .Y ,A :0xff}};type CMYK interface{CMYKAt (_g ,_f int )_ed .CMYK ;SetCMYK (_eg ,_dc int ,_dcb _ed .CMYK );};func (_fgdgd *Gray8 )ColorAt (x ,y int )(_ed .Color ,error ){return ColorAtGray8BPC (x ,y ,_fgdgd .BytesPerLine ,_fgdgd .Data ,_fgdgd .Decode );};var _ Image =&NRGBA32 {};var _ _c .Image =&Gray16 {};func (_decd *ImageBase )HasAlpha ()bool {if _decd .Alpha ==nil {return false ;};for _gfbe :=range _decd .Alpha {if _decd .Alpha [_gfbe ]!=0xff{return true ;};};return false ;};type RGBA interface{RGBAAt (_acf ,_defe int )_ed .RGBA ;SetRGBA (_gab ,_gag int ,_bggb _ed .RGBA );};type Histogramer interface{Histogram ()[256]int ;};func (_fca *NRGBA32 )Base ()*ImageBase {return &_fca .ImageBase };func GrayHistogram (g Gray )(_dgfc [256]int ){switch _efab :=g .(type ){case Histogramer :return _efab .Histogram ();case _c .Image :_dcgf :=_efab .Bounds ();for _ced :=0;_ced < _dcgf .Max .X ;_ced ++{for _ccbe :=0;_ccbe < _dcgf .Max .Y ;_ccbe ++{_dgfc [g .GrayAt (_ced ,_ccbe ).Y ]++;};};return _dgfc ;default:return [256]int {};};};func (_bdde *ImageBase )MakeAlpha (){_bdde .newAlpha ()};func (_febd *NRGBA64 )Base ()*ImageBase {return &_febd .ImageBase };func _efcf (_dfe _c .Image )(Image ,error ){if _adbg ,_gefc :=_dfe .(*NRGBA32 );_gefc {return _adbg .Copy (),nil ;};_ceca ,_cba ,_gead :=_efdae (_dfe ,1);_bbeb ,_aeca :=NewImage (_ceca .Max .X ,_ceca .Max .Y ,8,3,nil ,_gead ,nil );if _aeca !=nil {return nil ,_aeca ;};_aeb (_dfe ,_bbeb ,_ceca );if len (_gead )!=0&&!_cba {if _fdgb :=_bbde (_gead ,_bbeb );_fdgb !=nil {return nil ,_fdgb ;};};return _bbeb ,nil ;};type NRGBA32 struct{ImageBase };func ColorAtNRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_ed .NRGBA ,error ){_fgdd :=y *width +x ;_aegc :=3*_fgdd ;if _aegc +2>=len (data ){return _ed .NRGBA {},_cg .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_bffd :=uint8 (0xff);if alpha !=nil &&len (alpha )> _fgdd {_bffd =alpha [_fgdd ];};_afgfd ,_efda ,_cfdf :=data [_aegc ],data [_aegc +1],data [_aegc +2];if len (decode )==6{_afgfd =uint8 (uint32 (LinearInterpolate (float64 (_afgfd ),0,255,decode [0],decode [1]))&0xff);_efda =uint8 (uint32 (LinearInterpolate (float64 (_efda ),0,255,decode [2],decode [3]))&0xff);_cfdf =uint8 (uint32 (LinearInterpolate (float64 (_cfdf ),0,255,decode [4],decode [5]))&0xff);};return _ed .NRGBA {R :_afgfd ,G :_efda ,B :_cfdf ,A :_bffd },nil ;};func _fde (_efc _ed .NYCbCrA )_ed .NRGBA {_fea :=int32 (_efc .Y )*0x10101;_aab :=int32 (_efc .Cb )-128;_bfba :=int32 (_efc .Cr )-128;_dgf :=_fea +91881*_bfba ;if uint32 (_dgf )&0xff000000==0{_dgf >>=8;}else {_dgf =^(_dgf >>31)&0xffff;};_dfg :=_fea -22554*_aab -46802*_bfba ;if uint32 (_dfg )&0xff000000==0{_dfg >>=8;}else {_dfg =^(_dfg >>31)&0xffff;};_aag :=_fea +116130*_aab ;if uint32 (_aag )&0xff000000==0{_aag >>=8;}else {_aag =^(_aag >>31)&0xffff;};return _ed .NRGBA {R :uint8 (_dgf >>8),G :uint8 (_dfg >>8),B :uint8 (_aag >>8),A :_efc .A };};func (_dbbe *Gray8 )Bounds ()_c .Rectangle {return _c .Rectangle {Max :_c .Point {X :_dbbe .Width ,Y :_dbbe .Height }};};func (_ffb *Gray16 )Set (x ,y int ,c _ed .Color ){_bfg :=(y *_ffb .BytesPerLine /2+x )*2;if _bfg +1>=len (_ffb .Data ){return ;};_eecd :=_ed .Gray16Model .Convert (c ).(_ed .Gray16 );_ffb .Data [_bfg ],_ffb .Data [_bfg +1]=uint8 (_eecd .Y >>8),uint8 (_eecd .Y &0xff);};var _ Image =&NRGBA64 {};func (_gaab *Gray2 )Bounds ()_c .Rectangle {return _c .Rectangle {Max :_c .Point {X :_gaab .Width ,Y :_gaab .Height }};};func (_cgec *NRGBA32 )Validate ()error {if len (_cgec .Data )!=3*_cgec .Width *_cgec .Height {return _b .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");};return nil ;};var _ _c .Image =&NRGBA16 {};type NRGBA interface{NRGBAAt (_fabb ,_bfga int )_ed .NRGBA ;SetNRGBA (_bbed ,_fgab int ,_efd _ed .NRGBA );};func (_afbec *NRGBA32 )setRGBA (_eacd int ,_ddgf _ed .NRGBA ){_bee :=3*_eacd ;_afbec .Data [_bee ]=_ddgf .R ;_afbec .Data [_bee +1]=_ddgf .G ;_afbec .Data [_bee +2]=_ddgf .B ;if _eacd < len (_afbec .Alpha ){_afbec .Alpha [_eacd ]=_ddgf .A ;};};func (_ace *Gray2 )Histogram ()(_beg [256]int ){for _bgf :=0;_bgf < _ace .Width ;_bgf ++{for _afd :=0;_afd < _ace .Height ;_afd ++{_beg [_ace .GrayAt (_bgf ,_afd ).Y ]++;};};return _beg ;};func (_fec *Gray2 )GrayAt (x ,y int )_ed .Gray {_ebc ,_ :=ColorAtGray2BPC (x ,y ,_fec .BytesPerLine ,_fec .Data ,_fec .Decode );return _ebc ;};func _dbe (_bfd _c .Image )(Image ,error ){if _efe ,_eega :=_bfd .(*Gray2 );_eega {return _efe .Copy (),nil ;};_cagff :=_bfd .Bounds ();_adc ,_dfd :=NewImage (_cagff .Max .X ,_cagff .Max .Y ,2,1,nil ,nil ,nil );if _dfd !=nil {return nil ,_dfd ;};_bgfe (_bfd ,_adc ,_cagff );return _adc ,nil ;};func (_ee *CMYK32 )SetCMYK (x ,y int ,c _ed .CMYK ){_fc :=4*(y *_ee .Width +x );if _fc +3>=len (_ee .Data ){return ;};_ee .Data [_fc ]=c .C ;_ee .Data [_fc +1]=c .M ;_ee .Data [_fc +2]=c .Y ;_ee .Data [_fc +3]=c .K ;};type Image interface{_de .Image ;Base ()*ImageBase ;Copy ()Image ;Pix ()[]byte ;ColorAt (_dada ,_cabg int )(_ed .Color ,error );Validate ()error ;};func _deca (_egdc uint8 )bool {if _egdc ==0||_egdc ==255{return true ;};return false ;};func (_gaa *Monochrome )Copy ()Image {return &Monochrome {ImageBase :_gaa .ImageBase .copy (),ModelThreshold :_gaa .ModelThreshold };};type Gray2 struct{ImageBase };func (_gfa *Gray2 )ColorModel ()_ed .Model {return Gray2Model };func ColorAtNRGBA64 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_ed .NRGBA64 ,error ){_gfeb :=(y *width +x )*2;_edad :=_gfeb *3;if _edad +5>=len (data ){return _ed .NRGBA64 {},_cg .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};const _aafe =0xffff;_dfga :=uint16 (_aafe );if alpha !=nil &&len (alpha )> _gfeb +1{_dfga =uint16 (alpha [_gfeb ])<<8|uint16 (alpha [_gfeb +1]);};_fdcc :=uint16 (data [_edad ])<<8|uint16 (data [_edad +1]);_fcgf :=uint16 (data [_edad +2])<<8|uint16 (data [_edad +3]);_ecgd :=uint16 (data [_edad +4])<<8|uint16 (data [_edad +5]);if len (decode )==6{_fdcc =uint16 (uint64 (LinearInterpolate (float64 (_fdcc ),0,65535,decode [0],decode [1]))&_aafe );_fcgf =uint16 (uint64 (LinearInterpolate (float64 (_fcgf ),0,65535,decode [2],decode [3]))&_aafe );_ecgd =uint16 (uint64 (LinearInterpolate (float64 (_ecgd ),0,65535,decode [4],decode [5]))&_aafe );};return _ed .NRGBA64 {R :_fdcc ,G :_fcgf ,B :_ecgd ,A :_dfga },nil ;};func (_gbb *NRGBA16 )SetNRGBA (x ,y int ,c _ed .NRGBA ){_aac :=y *_gbb .BytesPerLine +x *3/2;if _aac +1>=len (_gbb .Data ){return ;};c =_cfcda (c );_gbb .setNRGBA (x ,y ,_aac ,c );};func (_eba *Gray4 )ColorModel ()_ed .Model {return Gray4Model };func _eafd (_aec _ed .NRGBA64 )_ed .NRGBA {return _ed .NRGBA {R :uint8 (_aec .R >>8),G :uint8 (_aec .G >>8),B :uint8 (_aec .B >>8),A :uint8 (_aec .A >>8)};};func ImgToBinary (i _c .Image ,threshold uint8 )*_c .Gray {switch _dggb :=i .(type ){case *_c .Gray :if _cdbb (_dggb ){return _dggb ;};return _bgefb (_dggb ,threshold );case *_c .Gray16 :return _bccga (_dggb ,threshold );default:return _dcbeg (_dggb ,threshold );};};func _bda (_gba CMYK ,_dcg Gray ,_gfab _c .Rectangle ){for _fadb :=0;_fadb < _gfab .Max .X ;_fadb ++{for _eac :=0;_eac < _gfab .Max .Y ;_eac ++{_bbcf :=_feg (_gba .CMYKAt (_fadb ,_eac ));_dcg .SetGray (_fadb ,_eac ,_bbcf );};};};func (_fbc *Gray4 )Copy ()Image {return &Gray4 {ImageBase :_fbc .copy ()}};func (_aeec *Gray2 )SetGray (x ,y int ,gray _ed .Gray ){_edd :=_fcbf (gray );_fef :=y *_aeec .BytesPerLine ;_ceb :=_fef +(x >>2);if _ceb >=len (_aeec .Data ){return ;};_aca :=_edd .Y >>6;_aeec .Data [_ceb ]=(_aeec .Data [_ceb ]&(^(0xc0>>uint (2*((x )&3)))))|(_aca <<uint (6-2*(x &3)));};func (_dcbe *CMYK32 )Copy ()Image {return &CMYK32 {ImageBase :_dcbe .copy ()}};func (_gef *NRGBA32 )SetNRGBA (x ,y int ,c _ed .NRGBA ){_bffc :=y *_gef .Width +x ;_bdgb :=3*_bffc ;if _bdgb +2>=len (_gef .Data ){return ;};_gef .setRGBA (_bffc ,c );return ;};func (_dede *Gray16 )GrayAt (x ,y int )_ed .Gray {_afad ,_ :=_dede .ColorAt (x ,y );return _ed .Gray {Y :uint8 (_afad .(_ed .Gray16 ).Y >>8)};};func ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine int ,data []byte ,decode []float64 )(_ed .Color ,error ){switch bitsPerColor {case 1:return ColorAtGray1BPC (x ,y ,bytesPerLine ,data ,decode );case 2:return ColorAtGray2BPC (x ,y ,bytesPerLine ,data ,decode );case 4:return ColorAtGray4BPC (x ,y ,bytesPerLine ,data ,decode );case 8:return ColorAtGray8BPC (x ,y ,bytesPerLine ,data ,decode );case 16:return ColorAtGray16BPC (x ,y ,bytesPerLine ,data ,decode );default:return nil ,_cg .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0067\u0072\u0061\u0079\u0020\u0073c\u0061\u006c\u0065\u0020\u0062\u0069\u0074s\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020a\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );};};func _cdbb (_fbfa *_c .Gray )bool {for _bcb :=0;_bcb < len (_fbfa .Pix );_bcb ++{if !_deca (_fbfa .Pix [_bcb ]){return false ;};};return true ;};func _ggb (_bdfa _c .Image )(Image ,error ){if _cfd ,_fadf :=_bdfa .(*Gray4 );_fadf {return _cfd .Copy (),nil ;};_def :=_bdfa .Bounds ();_gee ,_gfd :=NewImage (_def .Max .X ,_def .Max .Y ,4,1,nil ,nil ,nil );if _gfd !=nil {return nil ,_gfd ;};_bgfe (_bdfa ,_gee ,_def );return _gee ,nil ;};func ColorAtGray1BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_ed .Gray ,error ){_efad :=y *bytesPerLine +x >>3;if _efad >=len (data ){return _ed .Gray {},_cg .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_fbb :=data [_efad ]>>uint (7-(x &7))&1;if len (decode )==2{_fbb =uint8 (LinearInterpolate (float64 (_fbb ),0.0,1.0,decode [0],decode [1]))&1;};return _ed .Gray {Y :_fbb *255},nil ;};type monochromeThresholdConverter struct{Threshold uint8 ;};type SMasker interface{HasAlpha ()bool ;GetAlpha ()[]byte ;MakeAlpha ();};type monochromeModel uint8 ;func _cbbe (_egbf _c .Image ,_cdeg Image ,_gbacb _c .Rectangle ){if _fefe ,_ggdb :=_egbf .(SMasker );_ggdb &&_fefe .HasAlpha (){_cdeg .(SMasker ).MakeAlpha ();};_bec (_egbf ,_cdeg ,_gbacb );};func (_debg *NRGBA64 )ColorModel ()_ed .Model {return _ed .NRGBA64Model };type Monochrome struct{ImageBase ;ModelThreshold uint8 ;};var _ Gray =&Gray16 {};func (_dde *NRGBA64 )NRGBA64At (x ,y int )_ed .NRGBA64 {_cde ,_ :=ColorAtNRGBA64 (x ,y ,_dde .Width ,_dde .Data ,_dde .Alpha ,_dde .Decode );return _cde ;};var _ _c .Image =&NRGBA64 {};func _faa (_dddd _c .Image )(Image ,error ){if _cgda ,_cefg :=_dddd .(*NRGBA64 );_cefg {return _cgda .Copy (),nil ;};_aacf ,_egbgc ,_cdcc :=_efdae (_dddd ,2);_gdbe ,_fggf :=NewImage (_aacf .Max .X ,_aacf .Max .Y ,16,3,nil ,_cdcc ,nil );if _fggf !=nil {return nil ,_fggf ;};_cbbe (_dddd ,_gdbe ,_aacf );if len (_cdcc )!=0&&!_egbgc {if _bggf :=_bbde (_cdcc ,_gdbe );_bggf !=nil {return nil ,_bggf ;};};return _gdbe ,nil ;};var _ _c .Image =&Gray2 {};func (_acbg *NRGBA64 )Bounds ()_c .Rectangle {return _c .Rectangle {Max :_c .Point {X :_acbg .Width ,Y :_acbg .Height }};};func _gdbc (_dcc ,_aeed Gray ,_eagf _c .Rectangle ){for _ggcf :=0;_ggcf < _eagf .Max .X ;_ggcf ++{for _cagc :=0;_cagc < _eagf .Max .Y ;_cagc ++{_aeed .SetGray (_ggcf ,_cagc ,_dcc .GrayAt (_ggcf ,_cagc ));};};};func _ffga (_afcff CMYK ,_caga NRGBA ,_gbfe _c .Rectangle ){for _afbf :=0;_afbf < _gbfe .Max .X ;_afbf ++{for _ggeb :=0;_ggeb < _gbfe .Max .Y ;_ggeb ++{_fcdb :=_afcff .CMYKAt (_afbf ,_ggeb );_caga .SetNRGBA (_afbf ,_ggeb ,_gcg (_fcdb ));};};};type ColorConverter interface{Convert (_bdbc _c .Image )(Image ,error );};var _ NRGBA =&NRGBA16 {};var _ Image =&Gray16 {};func (_cge *Gray16 )Bounds ()_c .Rectangle {return _c .Rectangle {Max :_c .Point {X :_cge .Width ,Y :_cge .Height }};};func (_dcd *Gray4 )GrayAt (x ,y int )_ed .Gray {_dgc ,_ :=ColorAtGray4BPC (x ,y ,_dcd .BytesPerLine ,_dcd .Data ,_dcd .Decode );return _dgc ;};func ColorAtGray16BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_ed .Gray16 ,error ){_eed :=(y *bytesPerLine /2+x )*2;if _eed +1>=len (data ){return _ed .Gray16 {},_cg .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_afgc :=uint16 (data [_eed ])<<8|uint16 (data [_eed +1]);if len (decode )==2{_afgc =uint16 (uint64 (LinearInterpolate (float64 (_afgc ),0,65535,decode [0],decode [1])));};return _ed .Gray16 {Y :_afgc },nil ;};func _bgfe (_dege _c .Image ,_fead Image ,_cbgd _c .Rectangle ){switch _dgbg :=_dege .(type ){case Gray :_gdbc (_dgbg ,_fead .(Gray ),_cbgd );case NRGBA :_cec (_dgbg ,_fead .(Gray ),_cbgd );case CMYK :_bda (_dgbg ,_fead .(Gray ),_cbgd );case RGBA :_add (_dgbg ,_fead .(Gray ),_cbgd );default:_bec (_dege ,_fead .(Image ),_cbgd );};};func _bccga (_dff *_c .Gray16 ,_agd uint8 )*_c .Gray {_cgca :=_dff .Bounds ();_cbd :=_c .NewGray (_cgca );for _bgef :=0;_bgef < _cgca .Dx ();_bgef ++{for _ecda :=0;_ecda < _cgca .Dy ();_ecda ++{_fcge :=_dff .Gray16At (_bgef ,_ecda );_cbd .SetGray (_bgef ,_ecda ,_ed .Gray {Y :_bge (uint8 (_fcge .Y /256),_agd )});};};return _cbd ;};func AddDataPadding (width ,height ,bitsPerComponent ,colorComponents int ,data []byte )([]byte ,error ){_ggef :=BytesPerLine (width ,bitsPerComponent ,colorComponents );if _ggef ==width *colorComponents *bitsPerComponent /8{return data ,nil ;};_beac :=width *colorComponents *bitsPerComponent ;_cbff :=_ggef *8;_cbca :=8-(_cbff -_beac );_ebac :=_ce .NewReader (data );_dac :=_ggef -1;_facb :=make ([]byte ,_dac );_abff :=make ([]byte ,height *_ggef );_fbba :=_ce .NewWriterMSB (_abff );var _dee uint64 ;var _cefa error ;for _bga :=0;_bga < height ;_bga ++{_ ,_cefa =_ebac .Read (_facb );if _cefa !=nil {return nil ,_cefa ;};_ ,_cefa =_fbba .Write (_facb );if _cefa !=nil {return nil ,_cefa ;};_dee ,_cefa =_ebac .ReadBits (byte (_cbca ));if _cefa !=nil {return nil ,_cefa ;};_ ,_cefa =_fbba .WriteBits (_dee ,_cbca );if _cefa !=nil {return nil ,_cefa ;};_fbba .FinishByte ();};return _abff ,nil ;};func (_cccc *NRGBA16 )Base ()*ImageBase {return &_cccc .ImageBase };func (_afcf *Monochrome )Validate ()error {if len (_afcf .Data )!=_afcf .Height *_afcf .BytesPerLine {return ErrInvalidImage ;};return nil ;};func _fcbf (_bff _ed .Gray )_ed .Gray {_cea :=_bff .Y >>6;_cea |=_cea <<2;_bff .Y =_cea |_cea <<4;return _bff ;};var ErrInvalidImage =_b .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");func (_ffcd *Gray2 )ColorAt (x ,y int )(_ed .Color ,error ){return ColorAtGray2BPC (x ,y ,_ffcd .BytesPerLine ,_ffcd .Data ,_ffcd .Decode );};var _ _c .Image =&NRGBA32 {};type CMYK32 struct{ImageBase };func (_eebc *Gray8 )SetGray (x ,y int ,g _ed .Gray ){_bdd :=y *_eebc .BytesPerLine +x ;if _bdd > len (_eebc .Data )-1{return ;};_eebc .Data [_bdd ]=g .Y ;};func (_fgaa *NRGBA64 )Validate ()error {if len (_fgaa .Data )!=3*2*_fgaa .Width *_fgaa .Height {return _b .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");};return nil ;};var _ Gray =&Monochrome {};type colorConverter struct{_cdca func (_aa _c .Image )(Image ,error );};func (_bgd *NRGBA16 )NRGBAAt (x ,y int )_ed .NRGBA {_fbd ,_ :=ColorAtNRGBA16 (x ,y ,_bgd .Width ,_bgd .BytesPerLine ,_bgd .Data ,_bgd .Alpha ,_bgd .Decode );return _fbd ;};func AutoThresholdTriangle (histogram [256]int )uint8 {var _eegad ,_cbga ,_cdfa ,_aebd int ;for _bcdb :=0;_bcdb < len (histogram );_bcdb ++{if histogram [_bcdb ]> 0{_eegad =_bcdb ;break ;};};if _eegad > 0{_eegad --;};for _gefcb :=255;_gefcb > 0;_gefcb --{if histogram [_gefcb ]> 0{_aebd =_gefcb ;break ;};};if _aebd < 255{_aebd ++;};for _cdce :=0;_cdce < 256;_cdce ++{if histogram [_cdce ]> _cbga {_cdfa =_cdce ;_cbga =histogram [_cdce ];};};var _dadf bool ;if (_cdfa -_eegad )< (_aebd -_cdfa ){_dadf =true ;var _dfdb int ;_afag :=255;for _dfdb < _afag {_egd :=histogram [_dfdb ];histogram [_dfdb ]=histogram [_afag ];histogram [_afag ]=_egd ;_dfdb ++;_afag --;};_eegad =255-_aebd ;_cdfa =255-_cdfa ;};if _eegad ==_cdfa {return uint8 (_eegad );};_gad :=float64 (histogram [_cdfa ]);_ddad :=float64 (_eegad -_cdfa );_cfde :=_d .Sqrt (_gad *_gad +_ddad *_ddad );_gad /=_cfde ;_ddad /=_cfde ;_cfde =_gad *float64 (_eegad )+_ddad *float64 (histogram [_eegad ]);_bbba :=_eegad ;var _fgac float64 ;for _acdd :=_eegad +1;_acdd <=_cdfa ;_acdd ++{_ddce :=_gad *float64 (_acdd )+_ddad *float64 (histogram [_acdd ])-_cfde ;if _ddce > _fgac {_bbba =_acdd ;_fgac =_ddce ;};};_bbba --;if _dadf {var _gfcb int ;_dbgb :=255;for _gfcb < _dbgb {_cdfc :=histogram [_gfcb ];histogram [_gfcb ]=histogram [_dbgb ];histogram [_dbgb ]=_cdfc ;_gfcb ++;_dbgb --;};return uint8 (255-_bbba );};return uint8 (_bbba );};func (_eag *monochromeThresholdConverter )Convert (img _c .Image )(Image ,error ){if _cbf ,_ffa :=img .(*Monochrome );_ffa {return _cbf .Copy (),nil ;};_cf :=img .Bounds ();_geg ,_cfc :=NewImage (_cf .Max .X ,_cf .Max .Y ,1,1,nil ,nil ,nil );if _cfc !=nil {return nil ,_cfc ;};_geg .(*Monochrome ).ModelThreshold =_eag .Threshold ;for _fdgd :=0;_fdgd < _cf .Max .X ;_fdgd ++{for _egb :=0;_egb < _cf .Max .Y ;_egb ++{_cbfc :=img .At (_fdgd ,_egb );_geg .Set (_fdgd ,_egb ,_cbfc );};};return _geg ,nil ;};func _bgefb (_bfeg *_c .Gray ,_eeaf uint8 )*_c .Gray {_cbdc :=_bfeg .Bounds ();_fbe :=_c .NewGray (_cbdc );for _aeeb :=0;_aeeb < _cbdc .Dx ();_aeeb ++{for _dagag :=0;_dagag < _cbdc .Dy ();_dagag ++{_bfdc :=_bfeg .GrayAt (_aeeb ,_dagag );_fbe .SetGray (_aeeb ,_dagag ,_ed .Gray {Y :_bge (_bfdc .Y ,_eeaf )});};};return _fbe ;};