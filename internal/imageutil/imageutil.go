//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package imageutil ;import (_fc "encoding/binary";_f "errors";_de "fmt";_cg "github.com/unidoc/unipdf/v3/common";_b "github.com/unidoc/unipdf/v3/internal/bitwise";_e "image";_dc "image/color";_ff "image/draw";_d "math";);func _ecdg (_aece *Monochrome ,_dcgd ,_aeggg ,_ddaee ,_cege int ,_degc RasterOperator ){if _dcgd < 0{_ddaee +=_dcgd ;
_dcgd =0;};_cggf :=_dcgd +_ddaee -_aece .Width ;if _cggf > 0{_ddaee -=_cggf ;};if _aeggg < 0{_cege +=_aeggg ;_aeggg =0;};_gdg :=_aeggg +_cege -_aece .Height ;if _gdg > 0{_cege -=_gdg ;};if _ddaee <=0||_cege <=0{return ;};if (_dcgd &7)==0{_dcff (_aece ,_dcgd ,_aeggg ,_ddaee ,_cege ,_degc );
}else {_agee (_aece ,_dcgd ,_aeggg ,_ddaee ,_cege ,_degc );};};func (_beca *ImageBase )setTwoBytes (_adcg int ,_eccgc uint16 )error {if _adcg +1> len (_beca .Data )-1{return _f .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_beca .Data [_adcg ]=byte ((_eccgc &0xff00)>>8);_beca .Data [_adcg +1]=byte (_eccgc &0xff);return nil ;};func _gcag (_fbbf *_e .Gray16 ,_aagab uint8 )*_e .Gray {_ggbe :=_fbbf .Bounds ();_agdbe :=_e .NewGray (_ggbe );for _ccgd :=0;_ccgd < _ggbe .Dx ();
_ccgd ++{for _addg :=0;_addg < _ggbe .Dy ();_addg ++{_ccga :=_fbbf .Gray16At (_ccgd ,_addg );_agdbe .SetGray (_ccgd ,_addg ,_dc .Gray {Y :_gdfa (uint8 (_ccga .Y /256),_aagab )});};};return _agdbe ;};func (_egad *Gray8 )Set (x ,y int ,c _dc .Color ){_ddgf :=y *_egad .BytesPerLine +x ;
if _ddgf > len (_egad .Data )-1{return ;};_bfbea :=_dc .GrayModel .Convert (c );_egad .Data [_ddgf ]=_bfbea .(_dc .Gray ).Y ;};var _ NRGBA =&NRGBA16 {};type Gray8 struct{ImageBase };func (_fece *Gray4 )SetGray (x ,y int ,g _dc .Gray ){if x >=_fece .Width ||y >=_fece .Height {return ;
};g =_cge (g );_fece .setGray (x ,y ,g );};func _affeb (_gccg _dc .Color )_dc .Color {_fgca :=_dc .GrayModel .Convert (_gccg ).(_dc .Gray );return _gfac (_fgca );};func (_edda *Monochrome )Scale (scale float64 )(*Monochrome ,error ){var _aebc bool ;_aeg :=scale ;
if scale < 1{_aeg =1/scale ;_aebc =true ;};_eccb :=NextPowerOf2 (uint (_aeg ));if InDelta (float64 (_eccb ),_aeg ,0.001){if _aebc {return _edda .ReduceBinary (_aeg );};return _edda .ExpandBinary (int (_eccb ));};_gbce :=int (_d .RoundToEven (float64 (_edda .Width )*scale ));
_bdb :=int (_d .RoundToEven (float64 (_edda .Height )*scale ));return _edda .ScaleLow (_gbce ,_bdb );};var _ _e .Image =&Gray4 {};type monochromeThresholdConverter struct{Threshold uint8 ;};func (_fede *Gray2 )Copy ()Image {return &Gray2 {ImageBase :_fede .copy ()}};
func (_ggaf *NRGBA16 )SetNRGBA (x ,y int ,c _dc .NRGBA ){_bgba :=y *_ggaf .BytesPerLine +x *3/2;if _bgba +1>=len (_ggaf .Data ){return ;};c =_bagg (c );_ggaf .setNRGBA (x ,y ,_bgba ,c );};func _fdc (_gge Gray ,_ddc CMYK ,_ddbe _e .Rectangle ){for _fgcg :=0;
_fgcg < _ddbe .Max .X ;_fgcg ++{for _cfga :=0;_cfga < _ddbe .Max .Y ;_cfga ++{_cgafg :=_gge .GrayAt (_fgcg ,_cfga );_ddc .SetCMYK (_fgcg ,_cfga ,_dcbg (_cgafg ));};};};func _agcc (_ggee _dc .Gray ,_abg monochromeModel )_dc .Gray {if _ggee .Y > uint8 (_abg ){return _dc .Gray {Y :_d .MaxUint8 };
};return _dc .Gray {};};func (_geaag *NRGBA64 )SetNRGBA64 (x ,y int ,c _dc .NRGBA64 ){_cdca :=(y *_geaag .Width +x )*2;_fdbb :=_cdca *3;if _fdbb +5>=len (_geaag .Data ){return ;};_geaag .setNRGBA64 (_fdbb ,c ,_cdca );};func (_gaef *NRGBA64 )ColorAt (x ,y int )(_dc .Color ,error ){return ColorAtNRGBA64 (x ,y ,_gaef .Width ,_gaef .Data ,_gaef .Alpha ,_gaef .Decode );
};func (_dgag *Gray4 )Bounds ()_e .Rectangle {return _e .Rectangle {Max :_e .Point {X :_dgag .Width ,Y :_dgag .Height }};};type NRGBA32 struct{ImageBase };func (_afce *NRGBA16 )Copy ()Image {return &NRGBA16 {ImageBase :_afce .copy ()}};func (_ffcf *Monochrome )At (x ,y int )_dc .Color {_edfd ,_ :=_ffcf .ColorAt (x ,y );
return _edfd };func (_ecad *NRGBA32 )SetNRGBA (x ,y int ,c _dc .NRGBA ){_bdfb :=y *_ecad .Width +x ;_fefg :=3*_bdfb ;if _fefg +2>=len (_ecad .Data ){return ;};_ecad .setRGBA (_bdfb ,c );};func _dgbg (_cab _e .Image )(Image ,error ){if _deb ,_ddfc :=_cab .(*CMYK32 );
_ddfc {return _deb .Copy (),nil ;};_fgb :=_cab .Bounds ();_gbaa ,_ada :=NewImage (_fgb .Max .X ,_fgb .Max .Y ,8,4,nil ,nil ,nil );if _ada !=nil {return nil ,_ada ;};switch _acbb :=_cab .(type ){case CMYK :_fdd (_acbb ,_gbaa .(CMYK ),_fgb );case Gray :_fdc (_acbb ,_gbaa .(CMYK ),_fgb );
case NRGBA :_bge (_acbb ,_gbaa .(CMYK ),_fgb );case RGBA :_fefb (_acbb ,_gbaa .(CMYK ),_fgb );default:_bfd (_cab ,_gbaa ,_fgb );};return _gbaa ,nil ;};func _deg (_fdeb RGBA ,_dfdd Gray ,_ffgg _e .Rectangle ){for _gaec :=0;_gaec < _ffgg .Max .X ;_gaec ++{for _dbde :=0;
_dbde < _ffgg .Max .Y ;_dbde ++{_bbea :=_adeg (_fdeb .RGBAAt (_gaec ,_dbde ));_dfdd .SetGray (_gaec ,_dbde ,_bbea );};};};func (_gdaf *Monochrome )clearBit (_gaga ,_eaec int ){_gdaf .Data [_gaga ]&=^(0x80>>uint (_eaec &7))};func _fgdb (_ecada _e .Image ,_gdb Image ,_eced _e .Rectangle ){if _add ,_beeeg :=_ecada .(SMasker );
_beeeg &&_add .HasAlpha (){_gdb .(SMasker ).MakeAlpha ();};_bfd (_ecada ,_gdb ,_eced );};func (_afcc *Gray8 )SetGray (x ,y int ,g _dc .Gray ){_gaag :=y *_afcc .BytesPerLine +x ;if _gaag > len (_afcc .Data )-1{return ;};_afcc .Data [_gaag ]=g .Y ;};func ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor int ,data ,alpha []byte ,decode []float64 )(_dc .Color ,error ){switch bitsPerColor {case 4:return ColorAtNRGBA16 (x ,y ,width ,bytesPerLine ,data ,alpha ,decode );
case 8:return ColorAtNRGBA32 (x ,y ,width ,data ,alpha ,decode );case 16:return ColorAtNRGBA64 (x ,y ,width ,data ,alpha ,decode );default:return nil ,_de .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0067\u0062\u0020b\u0069\u0074\u0073\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0061\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );
};};func (_gbde *CMYK32 )ColorAt (x ,y int )(_dc .Color ,error ){return ColorAtCMYK (x ,y ,_gbde .Width ,_gbde .Data ,_gbde .Decode );};var (MonochromeConverter =ConverterFunc (_dbbc );Gray2Converter =ConverterFunc (_fdgb );Gray4Converter =ConverterFunc (_abcg );
GrayConverter =ConverterFunc (_fcfe );Gray16Converter =ConverterFunc (_ecef );NRGBA16Converter =ConverterFunc (_ecefg );NRGBAConverter =ConverterFunc (_dgcec );NRGBA64Converter =ConverterFunc (_becfb );CMYKConverter =ConverterFunc (_dgbg ););func _dagbe (_dggge ,_acdg Gray ,_ebbff _e .Rectangle ){for _geff :=0;
_geff < _ebbff .Max .X ;_geff ++{for _acfe :=0;_acfe < _ebbff .Max .Y ;_acfe ++{_acdg .SetGray (_geff ,_acfe ,_dggge .GrayAt (_geff ,_acfe ));};};};func _dcac (_dbff *Monochrome ,_dceg ,_cgf ,_dfeb ,_cfgd int ,_ecgd RasterOperator ,_dgee *Monochrome ,_cdbg ,_gcfb int )error {if _dbff ==nil {return _f .New ("\u006e\u0069\u006c\u0020\u0027\u0064\u0065\u0073\u0074\u0027\u0020\u0042i\u0074\u006d\u0061\u0070");
};if _ecgd ==PixDst {return nil ;};switch _ecgd {case PixClr ,PixSet ,PixNotDst :_ecdg (_dbff ,_dceg ,_cgf ,_dfeb ,_cfgd ,_ecgd );return nil ;};if _dgee ==nil {_cg .Log .Debug ("\u0052a\u0073\u0074e\u0072\u004f\u0070\u0065r\u0061\u0074\u0069o\u006e\u0020\u0073\u006f\u0075\u0072\u0063\u0065\u0020bi\u0074\u006d\u0061p\u0020\u0069s\u0020\u006e\u006f\u0074\u0020\u0064e\u0066\u0069n\u0065\u0064");
return _f .New ("\u006e\u0069l\u0020\u0027\u0073r\u0063\u0027\u0020\u0062\u0069\u0074\u006d\u0061\u0070");};if _gefa :=_abagg (_dbff ,_dceg ,_cgf ,_dfeb ,_cfgd ,_ecgd ,_dgee ,_cdbg ,_gcfb );_gefa !=nil {return _gefa ;};return nil ;};type NRGBA16 struct{ImageBase };
func _cba (_cdeff ,_ecf int ,_aeed []byte )*Monochrome {_dca :=_bec (_cdeff ,_ecf );_dca .Data =_aeed ;return _dca ;};func (_dagd *Gray16 )Base ()*ImageBase {return &_dagd .ImageBase };var _ Image =&Gray4 {};type monochromeModel uint8 ;func FromGoImage (i _e .Image )(Image ,error ){switch _ggbd :=i .(type ){case Image :return _ggbd .Copy (),nil ;
case Gray :return GrayConverter .Convert (i );case *_e .Gray16 :return Gray16Converter .Convert (i );case CMYK :return CMYKConverter .Convert (i );case *_e .NRGBA64 :return NRGBA64Converter .Convert (i );default:return NRGBAConverter .Convert (i );};};
func (_baed *Gray4 )Validate ()error {if len (_baed .Data )!=_baed .Height *_baed .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_egc *Monochrome )IsUnpadded ()bool {return (_egc .Width *_egc .Height )==len (_egc .Data )};func (_gfc *Monochrome )setGray (_ccf int ,_febg _dc .Gray ,_cccd int ){if _febg .Y ==0{_gfc .clearBit (_cccd ,_ccf );
}else {_gfc .setGrayBit (_cccd ,_ccf );};};func _fdd (_bbgea ,_ccd CMYK ,_dga _e .Rectangle ){for _gcd :=0;_gcd < _dga .Max .X ;_gcd ++{for _agb :=0;_agb < _dga .Max .Y ;_agb ++{_ccd .SetCMYK (_gcd ,_agb ,_bbgea .CMYKAt (_gcd ,_agb ));};};};func _fgg (_ggff _dc .CMYK )_dc .Gray {_ffdc ,_cgda ,_eaae :=_dc .CMYKToRGB (_ggff .C ,_ggff .M ,_ggff .Y ,_ggff .K );
_aeedb :=(19595*uint32 (_ffdc )+38470*uint32 (_cgda )+7471*uint32 (_eaae )+1<<7)>>16;return _dc .Gray {Y :uint8 (_aeedb )};};func ConverterFunc (converterFunc func (_ggf _e .Image )(Image ,error ))ColorConverter {return colorConverter {_fcc :converterFunc };
};func (_bcge *Monochrome )Histogram ()(_acf [256]int ){for _ ,_baec :=range _bcge .Data {_acf [0xff]+=int (_dbgb [_bcge .Data [_baec ]]);};return _acf ;};func (_befb *Monochrome )GrayAt (x ,y int )_dc .Gray {_bdba ,_ :=ColorAtGray1BPC (x ,y ,_befb .BytesPerLine ,_befb .Data ,_befb .Decode );
return _bdba ;};func MonochromeModel (threshold uint8 )_dc .Model {return monochromeModel (threshold )};func (_deaf *Monochrome )RasterOperation (dx ,dy ,dw ,dh int ,op RasterOperator ,src *Monochrome ,sx ,sy int )error {return _dcac (_deaf ,dx ,dy ,dw ,dh ,op ,src ,sx ,sy );
};var _ Gray =&Gray8 {};func _fcf (_gde _dc .NRGBA )_dc .CMYK {_fccd ,_adad ,_gegg ,_ :=_gde .RGBA ();_dafb ,_bbc ,_ccc ,_fdac :=_dc .RGBToCMYK (uint8 (_fccd >>8),uint8 (_adad >>8),uint8 (_gegg >>8));return _dc .CMYK {C :_dafb ,M :_bbc ,Y :_ccc ,K :_fdac };
};func (_adb *ImageBase )GetAlpha ()[]byte {return _adb .Alpha };var _ _e .Image =&Gray2 {};func _gaa (_dcc ,_ag *Monochrome )(_ged error ){_agg :=_ag .BytesPerLine ;_fce :=_dcc .BytesPerLine ;_ce :=_ag .BytesPerLine *4-_dcc .BytesPerLine ;var (_cb ,_fg byte ;
_fbd uint32 ;_cga ,_afe ,_cda ,_cdef ,_fag ,_acd ,_ffe int ;);for _cda =0;_cda < _ag .Height ;_cda ++{_cga =_cda *_agg ;_afe =4*_cda *_fce ;for _cdef =0;_cdef < _agg ;_cdef ++{_cb =_ag .Data [_cga +_cdef ];_fbd =_ffb [_cb ];_acd =_afe +_cdef *4;if _ce !=0&&(_cdef +1)*4> _dcc .BytesPerLine {for _fag =_ce ;
_fag > 0;_fag --{_fg =byte ((_fbd >>uint (_fag *8))&0xff);_ffe =_acd +(_ce -_fag );if _ged =_dcc .setByte (_ffe ,_fg );_ged !=nil {return _ged ;};};}else if _ged =_dcc .setFourBytes (_acd ,_fbd );_ged !=nil {return _ged ;};if _ged =_dcc .setFourBytes (_afe +_cdef *4,_ffb [_ag .Data [_cga +_cdef ]]);
_ged !=nil {return _ged ;};};for _fag =1;_fag < 4;_fag ++{for _cdef =0;_cdef < _fce ;_cdef ++{if _ged =_dcc .setByte (_afe +_fag *_fce +_cdef ,_dcc .Data [_afe +_cdef ]);_ged !=nil {return _ged ;};};};};return nil ;};func (_fcgg *NRGBA16 )Validate ()error {if len (_fcgg .Data )!=3*_fcgg .Width *_fcgg .Height /2{return _f .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func (_dfef *Gray2 )Histogram ()(_begd [256]int ){for _fccb :=0;_fccb < _dfef .Width ;_fccb ++{for _dbfda :=0;_dbfda < _dfef .Height ;_dbfda ++{_begd [_dfef .GrayAt (_fccb ,_dbfda ).Y ]++;};};return _begd ;};func ColorAtGray16BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_dc .Gray16 ,error ){_cadc :=(y *bytesPerLine /2+x )*2;
if _cadc +1>=len (data ){return _dc .Gray16 {},_de .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_cae :=uint16 (data [_cadc ])<<8|uint16 (data [_cadc +1]);if len (decode )==2{_cae =uint16 (uint64 (LinearInterpolate (float64 (_cae ),0,65535,decode [0],decode [1])));};return _dc .Gray16 {Y :_cae },nil ;};func (_deea *NRGBA16 )Base ()*ImageBase {return &_deea .ImageBase };
func (_egbe *Gray2 )SetGray (x ,y int ,gray _dc .Gray ){_gadfd :=_gfac (gray );_fca :=y *_egbe .BytesPerLine ;_ded :=_fca +(x >>2);if _ded >=len (_egbe .Data ){return ;};_bgfcb :=_gadfd .Y >>6;_egbe .Data [_ded ]=(_egbe .Data [_ded ]&(^(0xc0>>uint (2*((x )&3)))))|(_bgfcb <<uint (6-2*(x &3)));
};func (_acfc *Gray2 )At (x ,y int )_dc .Color {_cbfc ,_ :=_acfc .ColorAt (x ,y );return _cbfc };func _dcff (_bab *Monochrome ,_efca ,_gbba int ,_gfd ,_befd int ,_fbbd RasterOperator ){var (_fbde int ;_ffce byte ;_cdfa ,_geaf int ;_eeca int ;);_dfab :=_gfd >>3;
_agaf :=_gfd &7;if _agaf > 0{_ffce =_aeag [_agaf ];};_fbde =_bab .BytesPerLine *_gbba +(_efca >>3);switch _fbbd {case PixClr :for _cdfa =0;_cdfa < _befd ;_cdfa ++{_eeca =_fbde +_cdfa *_bab .BytesPerLine ;for _geaf =0;_geaf < _dfab ;_geaf ++{_bab .Data [_eeca ]=0x0;
_eeca ++;};if _agaf > 0{_bab .Data [_eeca ]=_bfgd (_bab .Data [_eeca ],0x0,_ffce );};};case PixSet :for _cdfa =0;_cdfa < _befd ;_cdfa ++{_eeca =_fbde +_cdfa *_bab .BytesPerLine ;for _geaf =0;_geaf < _dfab ;_geaf ++{_bab .Data [_eeca ]=0xff;_eeca ++;};if _agaf > 0{_bab .Data [_eeca ]=_bfgd (_bab .Data [_eeca ],0xff,_ffce );
};};case PixNotDst :for _cdfa =0;_cdfa < _befd ;_cdfa ++{_eeca =_fbde +_cdfa *_bab .BytesPerLine ;for _geaf =0;_geaf < _dfab ;_geaf ++{_bab .Data [_eeca ]=^_bab .Data [_eeca ];_eeca ++;};if _agaf > 0{_bab .Data [_eeca ]=_bfgd (_bab .Data [_eeca ],^_bab .Data [_eeca ],_ffce );
};};};};func (_cag *Gray16 )SetGray (x ,y int ,g _dc .Gray ){_gcfc :=(y *_cag .BytesPerLine /2+x )*2;if _gcfc +1>=len (_cag .Data ){return ;};_cag .Data [_gcfc ]=g .Y ;_cag .Data [_gcfc +1]=g .Y ;};func (_ggcb *Gray8 )Histogram ()(_eefc [256]int ){for _ffag :=0;
_ffag < len (_ggcb .Data );_ffag ++{_eefc [_ggcb .Data [_ffag ]]++;};return _eefc ;};func (_agce *Gray2 )Validate ()error {if len (_agce .Data )!=_agce .Height *_agce .BytesPerLine {return ErrInvalidImage ;};return nil ;};func _ddae ()(_gbdc []byte ){_gbdc =make ([]byte ,256);
for _ddbd :=0;_ddbd < 256;_ddbd ++{_ddag :=byte (_ddbd );_gbdc [_ddag ]=(_ddag &0x01)|((_ddag &0x04)>>1)|((_ddag &0x10)>>2)|((_ddag &0x40)>>3)|((_ddag &0x02)<<3)|((_ddag &0x08)<<2)|((_ddag &0x20)<<1)|(_ddag &0x80);};return _gbdc ;};func init (){_ffefa ()};
func GrayHistogram (g Gray )(_dbgc [256]int ){switch _aggd :=g .(type ){case Histogramer :return _aggd .Histogram ();case _e .Image :_gceb :=_aggd .Bounds ();for _gcce :=0;_gcce < _gceb .Max .X ;_gcce ++{for _egcb :=0;_egcb < _gceb .Max .Y ;_egcb ++{_dbgc [g .GrayAt (_gcce ,_egcb ).Y ]++;
};};return _dbgc ;default:return [256]int {};};};func _ac (_ef ,_gd *Monochrome )(_fe error ){_cfg :=_gd .BytesPerLine ;_fb :=_ef .BytesPerLine ;var (_ga byte ;_cc uint16 ;_fa ,_dd ,_cdf ,_gf ,_ge int ;);for _cdf =0;_cdf < _gd .Height ;_cdf ++{_fa =_cdf *_cfg ;
_dd =2*_cdf *_fb ;for _gf =0;_gf < _cfg ;_gf ++{_ga =_gd .Data [_fa +_gf ];_cc =_dfb [_ga ];_ge =_dd +_gf *2;if _ef .BytesPerLine !=_gd .BytesPerLine *2&&(_gf +1)*2> _ef .BytesPerLine {_fe =_ef .setByte (_ge ,byte (_cc >>8));}else {_fe =_ef .setTwoBytes (_ge ,_cc );
};if _fe !=nil {return _fe ;};};for _gf =0;_gf < _fb ;_gf ++{_ge =_dd +_fb +_gf ;_ga =_ef .Data [_dd +_gf ];if _fe =_ef .setByte (_ge ,_ga );_fe !=nil {return _fe ;};};};return nil ;};var _ Gray =&Gray16 {};func (_edee *Monochrome )ScaleLow (width ,height int )(*Monochrome ,error ){if width < 0||height < 0{return nil ,_f .New ("\u0070\u0072\u006f\u0076\u0069\u0064e\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0069\u0064t\u0068\u0020\u0061\u006e\u0064\u0020\u0068e\u0069\u0067\u0068\u0074");
};_egeb :=_bec (width ,height );_daed :=make ([]int ,height );_geaa :=make ([]int ,width );_abf :=float64 (_edee .Width )/float64 (width );_dcag :=float64 (_edee .Height )/float64 (height );for _bag :=0;_bag < height ;_bag ++{_daed [_bag ]=int (_d .Min (_dcag *float64 (_bag )+0.5,float64 (_edee .Height -1)));
};for _bddb :=0;_bddb < width ;_bddb ++{_geaa [_bddb ]=int (_d .Min (_abf *float64 (_bddb )+0.5,float64 (_edee .Width -1)));};_baef :=-1;_ddg :=byte (0);for _dab :=0;_dab < height ;_dab ++{_gec :=_daed [_dab ]*_edee .BytesPerLine ;_cce :=_dab *_egeb .BytesPerLine ;
for _eaad :=0;_eaad < width ;_eaad ++{_bgfc :=_geaa [_eaad ];if _bgfc !=_baef {_ddg =_edee .getBit (_gec ,_bgfc );if _ddg !=0{_egeb .setBit (_cce ,_eaad );};_baef =_bgfc ;}else {if _ddg !=0{_egeb .setBit (_cce ,_eaad );};};};};return _egeb ,nil ;};var _ Gray =&Monochrome {};
func _dcbg (_gagb _dc .Gray )_dc .CMYK {return _dc .CMYK {K :0xff-_gagb .Y }};func _bagg (_cdde _dc .NRGBA )_dc .NRGBA {_cdde .R =_cdde .R >>4|(_cdde .R >>4)<<4;_cdde .G =_cdde .G >>4|(_cdde .G >>4)<<4;_cdde .B =_cdde .B >>4|(_cdde .B >>4)<<4;return _cdde ;
};type Monochrome struct{ImageBase ;ModelThreshold uint8 ;};func (_bde *ImageBase )MakeAlpha (){_bde .newAlpha ()};func _dbbc (_fafg _e .Image )(Image ,error ){if _aafg ,_faeg :=_fafg .(*Monochrome );_faeg {return _aafg ,nil ;};_gagd :=_fafg .Bounds ();
var _fdfd Gray ;switch _gbdea :=_fafg .(type ){case Gray :_fdfd =_gbdea ;case NRGBA :_fdfd =&Gray8 {ImageBase :NewImageBase (_gagd .Max .X ,_gagd .Max .Y ,8,1,nil ,nil ,nil )};_fee (_fdfd ,_gbdea ,_gagd );case nrgba64 :_fdfd =&Gray8 {ImageBase :NewImageBase (_gagd .Max .X ,_gagd .Max .Y ,8,1,nil ,nil ,nil )};
_bda (_fdfd ,_gbdea ,_gagd );default:_dgd ,_dag :=GrayConverter .Convert (_fafg );if _dag !=nil {return nil ,_dag ;};_fdfd =_dgd .(Gray );};_gcdb ,_aggf :=NewImage (_gagd .Max .X ,_gagd .Max .Y ,1,1,nil ,nil ,nil );if _aggf !=nil {return nil ,_aggf ;};
_dgff :=_gcdb .(*Monochrome );_dbc :=AutoThresholdTriangle (GrayHistogram (_fdfd ));for _ecff :=0;_ecff < _gagd .Max .X ;_ecff ++{for _bcd :=0;_bcd < _gagd .Max .Y ;_bcd ++{_bdd :=_agcc (_fdfd .GrayAt (_ecff ,_bcd ),monochromeModel (_dbc ));_dgff .SetGray (_ecff ,_bcd ,_bdd );
};};return _gcdb ,nil ;};func (_dbcb *NRGBA16 )ColorModel ()_dc .Model {return NRGBA16Model };func _dbd (_fba ,_dgc *Monochrome ,_bgg []byte ,_fdgd int )(_dbf error ){var (_dba ,_ecc ,_fab ,_ace ,_eaf ,_ecb ,_fbaf ,_afg int ;_eaa ,_ggd ,_becf ,_edd uint32 ;
_dae ,_afc byte ;_edc uint16 ;);_fadc :=make ([]byte ,4);_gba :=make ([]byte ,4);for _fab =0;_fab < _fba .Height -1;_fab ,_ace =_fab +2,_ace +1{_dba =_fab *_fba .BytesPerLine ;_ecc =_ace *_dgc .BytesPerLine ;for _eaf ,_ecb =0,0;_eaf < _fdgd ;_eaf ,_ecb =_eaf +4,_ecb +1{for _fbaf =0;
_fbaf < 4;_fbaf ++{_afg =_dba +_eaf +_fbaf ;if _afg <=len (_fba .Data )-1&&_afg < _dba +_fba .BytesPerLine {_fadc [_fbaf ]=_fba .Data [_afg ];}else {_fadc [_fbaf ]=0x00;};_afg =_dba +_fba .BytesPerLine +_eaf +_fbaf ;if _afg <=len (_fba .Data )-1&&_afg < _dba +(2*_fba .BytesPerLine ){_gba [_fbaf ]=_fba .Data [_afg ];
}else {_gba [_fbaf ]=0x00;};};_eaa =_fc .BigEndian .Uint32 (_fadc );_ggd =_fc .BigEndian .Uint32 (_gba );_becf =_eaa &_ggd ;_becf |=_becf <<1;_edd =_eaa |_ggd ;_edd &=_edd <<1;_ggd =_becf &_edd ;_ggd &=0xaaaaaaaa;_eaa =_ggd |(_ggd <<7);_dae =byte (_eaa >>24);
_afc =byte ((_eaa >>8)&0xff);_afg =_ecc +_ecb ;if _afg +1==len (_dgc .Data )-1||_afg +1>=_ecc +_dgc .BytesPerLine {if _dbf =_dgc .setByte (_afg ,_bgg [_dae ]);_dbf !=nil {return _de .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_afg );};}else {_edc =(uint16 (_bgg [_dae ])<<8)|uint16 (_bgg [_afc ]);
if _dbf =_dgc .setTwoBytes (_afg ,_edc );_dbf !=nil {return _de .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_afg );
};_ecb ++;};};};return nil ;};type Gray4 struct{ImageBase };func (_cac *monochromeThresholdConverter )Convert (img _e .Image )(Image ,error ){if _fggg ,_feda :=img .(*Monochrome );_feda {return _fggg .Copy (),nil ;};_fbgeb :=img .Bounds ();_eeb ,_edb :=NewImage (_fbgeb .Max .X ,_fbgeb .Max .Y ,1,1,nil ,nil ,nil );
if _edb !=nil {return nil ,_edb ;};_eeb .(*Monochrome ).ModelThreshold =_cac .Threshold ;for _aefg :=0;_aefg < _fbgeb .Max .X ;_aefg ++{for _gadf :=0;_gadf < _fbgeb .Max .Y ;_gadf ++{_dggg :=img .At (_aefg ,_gadf );_eeb .Set (_aefg ,_gadf ,_dggg );};};
return _eeb ,nil ;};func ColorAtNRGBA16 (x ,y ,width ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_dc .NRGBA ,error ){_dcccg :=y *bytesPerLine +x *3/2;if _dcccg +1>=len (data ){return _dc .NRGBA {},_bdeb (x ,y );};const (_aaed =0xf;_cdbd =uint8 (0xff);
);_gedf :=_cdbd ;if alpha !=nil {_dcbb :=y *BytesPerLine (width ,4,1);if _dcbb < len (alpha ){if x %2==0{_gedf =(alpha [_dcbb ]>>uint (4))&_aaed ;}else {_gedf =alpha [_dcbb ]&_aaed ;};_gedf |=_gedf <<4;};};var _ffga ,_bgce ,_dagc uint8 ;if x *3%2==0{_ffga =(data [_dcccg ]>>uint (4))&_aaed ;
_bgce =data [_dcccg ]&_aaed ;_dagc =(data [_dcccg +1]>>uint (4))&_aaed ;}else {_ffga =data [_dcccg ]&_aaed ;_bgce =(data [_dcccg +1]>>uint (4))&_aaed ;_dagc =data [_dcccg +1]&_aaed ;};if len (decode )==6{_ffga =uint8 (uint32 (LinearInterpolate (float64 (_ffga ),0,15,decode [0],decode [1]))&0xf);
_bgce =uint8 (uint32 (LinearInterpolate (float64 (_bgce ),0,15,decode [2],decode [3]))&0xf);_dagc =uint8 (uint32 (LinearInterpolate (float64 (_dagc ),0,15,decode [4],decode [5]))&0xf);};return _dc .NRGBA {R :(_ffga <<4)|(_ffga &0xf),G :(_bgce <<4)|(_bgce &0xf),B :(_dagc <<4)|(_dagc &0xf),A :_gedf },nil ;
};var _ Image =&Monochrome {};func _gddf (_faaa nrgba64 ,_efdbg NRGBA ,_afec _e .Rectangle ){for _dgdg :=0;_dgdg < _afec .Max .X ;_dgdg ++{for _efeed :=0;_efeed < _afec .Max .Y ;_efeed ++{_daae :=_faaa .NRGBA64At (_dgdg ,_efeed );_efdbg .SetNRGBA (_dgdg ,_efeed ,_cgaa (_daae ));
};};};func _cgd (_dbb ,_fga *Monochrome ,_ggg []byte ,_ead int )(_gbac error ){var (_bba ,_ddf ,_ggcd ,_gfa ,_cfd ,_bbg ,_cgaf ,_gbd int ;_egg ,_ebe uint32 ;_ffab ,_fbg byte ;_eggb uint16 ;);_fed :=make ([]byte ,4);_aaf :=make ([]byte ,4);for _ggcd =0;
_ggcd < _dbb .Height -1;_ggcd ,_gfa =_ggcd +2,_gfa +1{_bba =_ggcd *_dbb .BytesPerLine ;_ddf =_gfa *_fga .BytesPerLine ;for _cfd ,_bbg =0,0;_cfd < _ead ;_cfd ,_bbg =_cfd +4,_bbg +1{for _cgaf =0;_cgaf < 4;_cgaf ++{_gbd =_bba +_cfd +_cgaf ;if _gbd <=len (_dbb .Data )-1&&_gbd < _bba +_dbb .BytesPerLine {_fed [_cgaf ]=_dbb .Data [_gbd ];
}else {_fed [_cgaf ]=0x00;};_gbd =_bba +_dbb .BytesPerLine +_cfd +_cgaf ;if _gbd <=len (_dbb .Data )-1&&_gbd < _bba +(2*_dbb .BytesPerLine ){_aaf [_cgaf ]=_dbb .Data [_gbd ];}else {_aaf [_cgaf ]=0x00;};};_egg =_fc .BigEndian .Uint32 (_fed );_ebe =_fc .BigEndian .Uint32 (_aaf );
_ebe &=_egg ;_ebe &=_ebe <<1;_ebe &=0xaaaaaaaa;_egg =_ebe |(_ebe <<7);_ffab =byte (_egg >>24);_fbg =byte ((_egg >>8)&0xff);_gbd =_ddf +_bbg ;if _gbd +1==len (_fga .Data )-1||_gbd +1>=_ddf +_fga .BytesPerLine {_fga .Data [_gbd ]=_ggg [_ffab ];if _gbac =_fga .setByte (_gbd ,_ggg [_ffab ]);
_gbac !=nil {return _de .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_gbd );};}else {_eggb =(uint16 (_ggg [_ffab ])<<8)|uint16 (_ggg [_fbg ]);if _gbac =_fga .setTwoBytes (_gbd ,_eggb );_gbac !=nil {return _de .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_gbd );
};_bbg ++;};};};return nil ;};var _dbgb [256]uint8 ;func (_fcec *Gray16 )Bounds ()_e .Rectangle {return _e .Rectangle {Max :_e .Point {X :_fcec .Width ,Y :_fcec .Height }};};func (_cgab *Monochrome )ResolveDecode ()error {if len (_cgab .Decode )!=2{return nil ;
};if _cgab .Decode [0]==1&&_cgab .Decode [1]==0{if _bbec :=_cgab .InverseData ();_bbec !=nil {return _bbec ;};_cgab .Decode =nil ;};return nil ;};func (_dffc *ImageBase )setEightFullBytes (_ebgg int ,_fgdd uint64 )error {if _ebgg +7> len (_dffc .Data )-1{return _f .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_dffc .Data [_ebgg ]=byte ((_fgdd &0xff00000000000000)>>56);_dffc .Data [_ebgg +1]=byte ((_fgdd &0xff000000000000)>>48);_dffc .Data [_ebgg +2]=byte ((_fgdd &0xff0000000000)>>40);_dffc .Data [_ebgg +3]=byte ((_fgdd &0xff00000000)>>32);_dffc .Data [_ebgg +4]=byte ((_fgdd &0xff000000)>>24);
_dffc .Data [_ebgg +5]=byte ((_fgdd &0xff0000)>>16);_dffc .Data [_ebgg +6]=byte ((_fgdd &0xff00)>>8);_dffc .Data [_ebgg +7]=byte (_fgdd &0xff);return nil ;};func (_acfd *Gray4 )ColorModel ()_dc .Model {return Gray4Model };type colorConverter struct{_fcc func (_fefd _e .Image )(Image ,error );
};func _aedd (_cfgf _e .Image ,_cfa Image ,_bac _e .Rectangle ){switch _ecfb :=_cfgf .(type ){case Gray :_dagbe (_ecfb ,_cfa .(Gray ),_bac );case NRGBA :_dggfe (_ecfb ,_cfa .(Gray ),_bac );case CMYK :_bdaf (_ecfb ,_cfa .(Gray ),_bac );case RGBA :_deg (_ecfb ,_cfa .(Gray ),_bac );
default:_bfd (_cfgf ,_cfa .(Image ),_bac );};};func ColorAtGray4BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_dc .Gray ,error ){_egcf :=y *bytesPerLine +x >>1;if _egcf >=len (data ){return _dc .Gray {},_de .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_ffca :=data [_egcf ]>>uint (4-(x &1)*4)&0xf;if len (decode )==2{_ffca =uint8 (uint32 (LinearInterpolate (float64 (_ffca ),0,15,decode [0],decode [1]))&0xf);};return _dc .Gray {Y :_ffca *17&0xff},nil ;};func (_bcbg *Gray16 )Histogram ()(_afcb [256]int ){for _eegd :=0;
_eegd < _bcbg .Width ;_eegd ++{for _gecg :=0;_gecg < _bcbg .Height ;_gecg ++{_afcb [_bcbg .GrayAt (_eegd ,_gecg ).Y ]++;};};return _afcb ;};func (_geef *Monochrome )ColorAt (x ,y int )(_dc .Color ,error ){return ColorAtGray1BPC (x ,y ,_geef .BytesPerLine ,_geef .Data ,_geef .Decode );
};func _eae (_efg ,_ddb *Monochrome )(_bc error ){_gc :=_ddb .BytesPerLine ;_bg :=_efg .BytesPerLine ;var _efa ,_da ,_fac ,_eg ,_cfgb int ;for _fac =0;_fac < _ddb .Height ;_fac ++{_efa =_fac *_gc ;_da =8*_fac *_bg ;for _eg =0;_eg < _gc ;_eg ++{if _bc =_efg .setEightBytes (_da +_eg *8,_bgfe [_ddb .Data [_efa +_eg ]]);
_bc !=nil {return _bc ;};};for _cfgb =1;_cfgb < 8;_cfgb ++{for _eg =0;_eg < _bg ;_eg ++{if _bc =_efg .setByte (_da +_cfgb *_bg +_eg ,_efg .Data [_da +_eg ]);_bc !=nil {return _bc ;};};};};return nil ;};func ColorAtGray8BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_dc .Gray ,error ){_ceec :=y *bytesPerLine +x ;
if _ceec >=len (data ){return _dc .Gray {},_de .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_daab :=data [_ceec ];if len (decode )==2{_daab =uint8 (uint32 (LinearInterpolate (float64 (_daab ),0,255,decode [0],decode [1]))&0xff);};return _dc .Gray {Y :_daab },nil ;};var _ Image =&Gray8 {};func _cgc (_gddbg _dc .RGBA )_dc .NRGBA {switch _gddbg .A {case 0xff:return _dc .NRGBA {R :_gddbg .R ,G :_gddbg .G ,B :_gddbg .B ,A :0xff};
case 0x00:return _dc .NRGBA {};default:_eee ,_agdf ,_fdcc ,_dggf :=_gddbg .RGBA ();_eee =(_eee *0xffff)/_dggf ;_agdf =(_agdf *0xffff)/_dggf ;_fdcc =(_fdcc *0xffff)/_dggf ;return _dc .NRGBA {R :uint8 (_eee >>8),G :uint8 (_agdf >>8),B :uint8 (_fdcc >>8),A :uint8 (_dggf >>8)};
};};func ColorAtGray2BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_dc .Gray ,error ){_gdfc :=y *bytesPerLine +x >>2;if _gdfc >=len (data ){return _dc .Gray {},_de .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_cceg :=data [_gdfc ]>>uint (6-(x &3)*2)&3;if len (decode )==2{_cceg =uint8 (uint32 (LinearInterpolate (float64 (_cceg ),0,3.0,decode [0],decode [1]))&3);};return _dc .Gray {Y :_cceg *85},nil ;};type Gray16 struct{ImageBase };func (_fdcb *Gray2 )ColorModel ()_dc .Model {return Gray2Model };
func (_cdd *Gray8 )Bounds ()_e .Rectangle {return _e .Rectangle {Max :_e .Point {X :_cdd .Width ,Y :_cdd .Height }};};func (_ebbf *Monochrome )setIndexedBit (_fdda int ){_ebbf .Data [(_fdda >>3)]|=0x80>>uint (_fdda &7)};var _ Gray =&Gray4 {};func (_ggeg *Monochrome )ColorModel ()_dc .Model {return MonochromeModel (_ggeg .ModelThreshold )};
func ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine int ,data []byte ,decode []float64 )(_dc .Color ,error ){switch bitsPerColor {case 1:return ColorAtGray1BPC (x ,y ,bytesPerLine ,data ,decode );case 2:return ColorAtGray2BPC (x ,y ,bytesPerLine ,data ,decode );
case 4:return ColorAtGray4BPC (x ,y ,bytesPerLine ,data ,decode );case 8:return ColorAtGray8BPC (x ,y ,bytesPerLine ,data ,decode );case 16:return ColorAtGray16BPC (x ,y ,bytesPerLine ,data ,decode );default:return nil ,_de .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0067\u0072\u0061\u0079\u0020\u0073c\u0061\u006c\u0065\u0020\u0062\u0069\u0074s\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020a\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );
};};func (_cfe *ImageBase )setByte (_abag int ,_bcgg byte )error {if _abag > len (_cfe .Data )-1{return _f .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_cfe .Data [_abag ]=_bcgg ;return nil ;};func (_feca *Gray4 )ColorAt (x ,y int )(_dc .Color ,error ){return ColorAtGray4BPC (x ,y ,_feca .BytesPerLine ,_feca .Data ,_feca .Decode );
};func ScaleAlphaToMonochrome (data []byte ,width ,height int )([]byte ,error ){_ea :=BytesPerLine (width ,8,1);if len (data )< _ea *height {return nil ,nil ;};_cd :=&Gray8 {NewImageBase (width ,height ,8,1,data ,nil ,nil )};_a ,_bb :=MonochromeConverter .Convert (_cd );
if _bb !=nil {return nil ,_bb ;};return _a .Base ().Data ,nil ;};func _dggfe (_abe NRGBA ,_faaf Gray ,_ffegb _e .Rectangle ){for _gbgd :=0;_gbgd < _ffegb .Max .X ;_gbgd ++{for _ggb :=0;_ggb < _ffegb .Max .Y ;_ggb ++{_fdbd :=_bdc (_abe .NRGBAAt (_gbgd ,_ggb ));
_faaf .SetGray (_gbgd ,_ggb ,_fdbd );};};};func _adeg (_dcgc _dc .RGBA )_dc .Gray {_egb :=(19595*uint32 (_dcgc .R )+38470*uint32 (_dcgc .G )+7471*uint32 (_dcgc .B )+1<<7)>>16;return _dc .Gray {Y :uint8 (_egb )};};var (Gray2Model =_dc .ModelFunc (_affeb );
Gray4Model =_dc .ModelFunc (_dbgd );NRGBA16Model =_dc .ModelFunc (_deaa ););func (_bgfg *NRGBA32 )setRGBA (_dgfa int ,_babc _dc .NRGBA ){_bafb :=3*_dgfa ;_bgfg .Data [_bafb ]=_babc .R ;_bgfg .Data [_bafb +1]=_babc .G ;_bgfg .Data [_bafb +2]=_babc .B ;if _dgfa < len (_bgfg .Alpha ){_bgfg .Alpha [_dgfa ]=_babc .A ;
};};func _bfb (_cec ,_efgc *Monochrome ,_aeb []byte ,_aab int )(_ecd error ){var (_gg ,_ebd ,_gbg ,_bedb ,_dcfe ,_faga ,_gef ,_ggc int ;_dccg ,_fgfe ,_cbe ,_dg uint32 ;_fgc ,_fad byte ;_bfbf uint16 ;);_daf :=make ([]byte ,4);_gbf :=make ([]byte ,4);for _gbg =0;
_gbg < _cec .Height -1;_gbg ,_bedb =_gbg +2,_bedb +1{_gg =_gbg *_cec .BytesPerLine ;_ebd =_bedb *_efgc .BytesPerLine ;for _dcfe ,_faga =0,0;_dcfe < _aab ;_dcfe ,_faga =_dcfe +4,_faga +1{for _gef =0;_gef < 4;_gef ++{_ggc =_gg +_dcfe +_gef ;if _ggc <=len (_cec .Data )-1&&_ggc < _gg +_cec .BytesPerLine {_daf [_gef ]=_cec .Data [_ggc ];
}else {_daf [_gef ]=0x00;};_ggc =_gg +_cec .BytesPerLine +_dcfe +_gef ;if _ggc <=len (_cec .Data )-1&&_ggc < _gg +(2*_cec .BytesPerLine ){_gbf [_gef ]=_cec .Data [_ggc ];}else {_gbf [_gef ]=0x00;};};_dccg =_fc .BigEndian .Uint32 (_daf );_fgfe =_fc .BigEndian .Uint32 (_gbf );
_cbe =_dccg &_fgfe ;_cbe |=_cbe <<1;_dg =_dccg |_fgfe ;_dg &=_dg <<1;_fgfe =_cbe |_dg ;_fgfe &=0xaaaaaaaa;_dccg =_fgfe |(_fgfe <<7);_fgc =byte (_dccg >>24);_fad =byte ((_dccg >>8)&0xff);_ggc =_ebd +_faga ;if _ggc +1==len (_efgc .Data )-1||_ggc +1>=_ebd +_efgc .BytesPerLine {if _ecd =_efgc .setByte (_ggc ,_aeb [_fgc ]);
_ecd !=nil {return _de .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_ggc );};}else {_bfbf =(uint16 (_aeb [_fgc ])<<8)|uint16 (_aeb [_fad ]);if _ecd =_efgc .setTwoBytes (_ggc ,_bfbf );_ecd !=nil {return _de .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_ggc );
};_faga ++;};};};return nil ;};func _ceb ()(_efff [256]uint32 ){for _cdc :=0;_cdc < 256;_cdc ++{if _cdc &0x01!=0{_efff [_cdc ]|=0xf;};if _cdc &0x02!=0{_efff [_cdc ]|=0xf0;};if _cdc &0x04!=0{_efff [_cdc ]|=0xf00;};if _cdc &0x08!=0{_efff [_cdc ]|=0xf000;
};if _cdc &0x10!=0{_efff [_cdc ]|=0xf0000;};if _cdc &0x20!=0{_efff [_cdc ]|=0xf00000;};if _cdc &0x40!=0{_efff [_cdc ]|=0xf000000;};if _cdc &0x80!=0{_efff [_cdc ]|=0xf0000000;};};return _efff ;};func _gedd (_gddbc *Monochrome ,_aaeb ,_eec ,_dbfca ,_bgab int ,_fafca RasterOperator ,_eab *Monochrome ,_fecb ,_fabge int )error {var (_cbbb bool ;
_fddg bool ;_eddb int ;_cecb int ;_fceaf int ;_afcf bool ;_cdbe byte ;_cegc int ;_gbgc int ;_fdgae int ;_abfe ,_ccdd int ;);_agff :=8-(_aaeb &7);_baeb :=_cgcg [_agff ];_aeba :=_gddbc .BytesPerLine *_eec +(_aaeb >>3);_dgdf :=_eab .BytesPerLine *_fabge +(_fecb >>3);
if _dbfca < _agff {_cbbb =true ;_baeb &=_aeag [8-_agff +_dbfca ];};if !_cbbb {_eddb =(_dbfca -_agff )>>3;if _eddb > 0{_fddg =true ;_cecb =_aeba +1;_fceaf =_dgdf +1;};};_cegc =(_aaeb +_dbfca )&7;if !(_cbbb ||_cegc ==0){_afcf =true ;_cdbe =_aeag [_cegc ];
_gbgc =_aeba +1+_eddb ;_fdgae =_dgdf +1+_eddb ;};switch _fafca {case PixSrc :for _abfe =0;_abfe < _bgab ;_abfe ++{_gddbc .Data [_aeba ]=_bfgd (_gddbc .Data [_aeba ],_eab .Data [_dgdf ],_baeb );_aeba +=_gddbc .BytesPerLine ;_dgdf +=_eab .BytesPerLine ;};
if _fddg {for _abfe =0;_abfe < _bgab ;_abfe ++{for _ccdd =0;_ccdd < _eddb ;_ccdd ++{_gddbc .Data [_cecb +_ccdd ]=_eab .Data [_fceaf +_ccdd ];};_cecb +=_gddbc .BytesPerLine ;_fceaf +=_eab .BytesPerLine ;};};if _afcf {for _abfe =0;_abfe < _bgab ;_abfe ++{_gddbc .Data [_gbgc ]=_bfgd (_gddbc .Data [_gbgc ],_eab .Data [_fdgae ],_cdbe );
_gbgc +=_gddbc .BytesPerLine ;_fdgae +=_eab .BytesPerLine ;};};case PixNotSrc :for _abfe =0;_abfe < _bgab ;_abfe ++{_gddbc .Data [_aeba ]=_bfgd (_gddbc .Data [_aeba ],^_eab .Data [_dgdf ],_baeb );_aeba +=_gddbc .BytesPerLine ;_dgdf +=_eab .BytesPerLine ;
};if _fddg {for _abfe =0;_abfe < _bgab ;_abfe ++{for _ccdd =0;_ccdd < _eddb ;_ccdd ++{_gddbc .Data [_cecb +_ccdd ]=^_eab .Data [_fceaf +_ccdd ];};_cecb +=_gddbc .BytesPerLine ;_fceaf +=_eab .BytesPerLine ;};};if _afcf {for _abfe =0;_abfe < _bgab ;_abfe ++{_gddbc .Data [_gbgc ]=_bfgd (_gddbc .Data [_gbgc ],^_eab .Data [_fdgae ],_cdbe );
_gbgc +=_gddbc .BytesPerLine ;_fdgae +=_eab .BytesPerLine ;};};case PixSrcOrDst :for _abfe =0;_abfe < _bgab ;_abfe ++{_gddbc .Data [_aeba ]=_bfgd (_gddbc .Data [_aeba ],_eab .Data [_dgdf ]|_gddbc .Data [_aeba ],_baeb );_aeba +=_gddbc .BytesPerLine ;_dgdf +=_eab .BytesPerLine ;
};if _fddg {for _abfe =0;_abfe < _bgab ;_abfe ++{for _ccdd =0;_ccdd < _eddb ;_ccdd ++{_gddbc .Data [_cecb +_ccdd ]|=_eab .Data [_fceaf +_ccdd ];};_cecb +=_gddbc .BytesPerLine ;_fceaf +=_eab .BytesPerLine ;};};if _afcf {for _abfe =0;_abfe < _bgab ;_abfe ++{_gddbc .Data [_gbgc ]=_bfgd (_gddbc .Data [_gbgc ],_eab .Data [_fdgae ]|_gddbc .Data [_gbgc ],_cdbe );
_gbgc +=_gddbc .BytesPerLine ;_fdgae +=_eab .BytesPerLine ;};};case PixSrcAndDst :for _abfe =0;_abfe < _bgab ;_abfe ++{_gddbc .Data [_aeba ]=_bfgd (_gddbc .Data [_aeba ],_eab .Data [_dgdf ]&_gddbc .Data [_aeba ],_baeb );_aeba +=_gddbc .BytesPerLine ;_dgdf +=_eab .BytesPerLine ;
};if _fddg {for _abfe =0;_abfe < _bgab ;_abfe ++{for _ccdd =0;_ccdd < _eddb ;_ccdd ++{_gddbc .Data [_cecb +_ccdd ]&=_eab .Data [_fceaf +_ccdd ];};_cecb +=_gddbc .BytesPerLine ;_fceaf +=_eab .BytesPerLine ;};};if _afcf {for _abfe =0;_abfe < _bgab ;_abfe ++{_gddbc .Data [_gbgc ]=_bfgd (_gddbc .Data [_gbgc ],_eab .Data [_fdgae ]&_gddbc .Data [_gbgc ],_cdbe );
_gbgc +=_gddbc .BytesPerLine ;_fdgae +=_eab .BytesPerLine ;};};case PixSrcXorDst :for _abfe =0;_abfe < _bgab ;_abfe ++{_gddbc .Data [_aeba ]=_bfgd (_gddbc .Data [_aeba ],_eab .Data [_dgdf ]^_gddbc .Data [_aeba ],_baeb );_aeba +=_gddbc .BytesPerLine ;_dgdf +=_eab .BytesPerLine ;
};if _fddg {for _abfe =0;_abfe < _bgab ;_abfe ++{for _ccdd =0;_ccdd < _eddb ;_ccdd ++{_gddbc .Data [_cecb +_ccdd ]^=_eab .Data [_fceaf +_ccdd ];};_cecb +=_gddbc .BytesPerLine ;_fceaf +=_eab .BytesPerLine ;};};if _afcf {for _abfe =0;_abfe < _bgab ;_abfe ++{_gddbc .Data [_gbgc ]=_bfgd (_gddbc .Data [_gbgc ],_eab .Data [_fdgae ]^_gddbc .Data [_gbgc ],_cdbe );
_gbgc +=_gddbc .BytesPerLine ;_fdgae +=_eab .BytesPerLine ;};};case PixNotSrcOrDst :for _abfe =0;_abfe < _bgab ;_abfe ++{_gddbc .Data [_aeba ]=_bfgd (_gddbc .Data [_aeba ],^(_eab .Data [_dgdf ])|_gddbc .Data [_aeba ],_baeb );_aeba +=_gddbc .BytesPerLine ;
_dgdf +=_eab .BytesPerLine ;};if _fddg {for _abfe =0;_abfe < _bgab ;_abfe ++{for _ccdd =0;_ccdd < _eddb ;_ccdd ++{_gddbc .Data [_cecb +_ccdd ]|=^(_eab .Data [_fceaf +_ccdd ]);};_cecb +=_gddbc .BytesPerLine ;_fceaf +=_eab .BytesPerLine ;};};if _afcf {for _abfe =0;
_abfe < _bgab ;_abfe ++{_gddbc .Data [_gbgc ]=_bfgd (_gddbc .Data [_gbgc ],^(_eab .Data [_fdgae ])|_gddbc .Data [_gbgc ],_cdbe );_gbgc +=_gddbc .BytesPerLine ;_fdgae +=_eab .BytesPerLine ;};};case PixNotSrcAndDst :for _abfe =0;_abfe < _bgab ;_abfe ++{_gddbc .Data [_aeba ]=_bfgd (_gddbc .Data [_aeba ],^(_eab .Data [_dgdf ])&_gddbc .Data [_aeba ],_baeb );
_aeba +=_gddbc .BytesPerLine ;_dgdf +=_eab .BytesPerLine ;};if _fddg {for _abfe =0;_abfe < _bgab ;_abfe ++{for _ccdd =0;_ccdd < _eddb ;_ccdd ++{_gddbc .Data [_cecb +_ccdd ]&=^_eab .Data [_fceaf +_ccdd ];};_cecb +=_gddbc .BytesPerLine ;_fceaf +=_eab .BytesPerLine ;
};};if _afcf {for _abfe =0;_abfe < _bgab ;_abfe ++{_gddbc .Data [_gbgc ]=_bfgd (_gddbc .Data [_gbgc ],^(_eab .Data [_fdgae ])&_gddbc .Data [_gbgc ],_cdbe );_gbgc +=_gddbc .BytesPerLine ;_fdgae +=_eab .BytesPerLine ;};};case PixSrcOrNotDst :for _abfe =0;
_abfe < _bgab ;_abfe ++{_gddbc .Data [_aeba ]=_bfgd (_gddbc .Data [_aeba ],_eab .Data [_dgdf ]|^(_gddbc .Data [_aeba ]),_baeb );_aeba +=_gddbc .BytesPerLine ;_dgdf +=_eab .BytesPerLine ;};if _fddg {for _abfe =0;_abfe < _bgab ;_abfe ++{for _ccdd =0;_ccdd < _eddb ;
_ccdd ++{_gddbc .Data [_cecb +_ccdd ]=_eab .Data [_fceaf +_ccdd ]|^(_gddbc .Data [_cecb +_ccdd ]);};_cecb +=_gddbc .BytesPerLine ;_fceaf +=_eab .BytesPerLine ;};};if _afcf {for _abfe =0;_abfe < _bgab ;_abfe ++{_gddbc .Data [_gbgc ]=_bfgd (_gddbc .Data [_gbgc ],_eab .Data [_fdgae ]|^(_gddbc .Data [_gbgc ]),_cdbe );
_gbgc +=_gddbc .BytesPerLine ;_fdgae +=_eab .BytesPerLine ;};};case PixSrcAndNotDst :for _abfe =0;_abfe < _bgab ;_abfe ++{_gddbc .Data [_aeba ]=_bfgd (_gddbc .Data [_aeba ],_eab .Data [_dgdf ]&^(_gddbc .Data [_aeba ]),_baeb );_aeba +=_gddbc .BytesPerLine ;
_dgdf +=_eab .BytesPerLine ;};if _fddg {for _abfe =0;_abfe < _bgab ;_abfe ++{for _ccdd =0;_ccdd < _eddb ;_ccdd ++{_gddbc .Data [_cecb +_ccdd ]=_eab .Data [_fceaf +_ccdd ]&^(_gddbc .Data [_cecb +_ccdd ]);};_cecb +=_gddbc .BytesPerLine ;_fceaf +=_eab .BytesPerLine ;
};};if _afcf {for _abfe =0;_abfe < _bgab ;_abfe ++{_gddbc .Data [_gbgc ]=_bfgd (_gddbc .Data [_gbgc ],_eab .Data [_fdgae ]&^(_gddbc .Data [_gbgc ]),_cdbe );_gbgc +=_gddbc .BytesPerLine ;_fdgae +=_eab .BytesPerLine ;};};case PixNotPixSrcOrDst :for _abfe =0;
_abfe < _bgab ;_abfe ++{_gddbc .Data [_aeba ]=_bfgd (_gddbc .Data [_aeba ],^(_eab .Data [_dgdf ]|_gddbc .Data [_aeba ]),_baeb );_aeba +=_gddbc .BytesPerLine ;_dgdf +=_eab .BytesPerLine ;};if _fddg {for _abfe =0;_abfe < _bgab ;_abfe ++{for _ccdd =0;_ccdd < _eddb ;
_ccdd ++{_gddbc .Data [_cecb +_ccdd ]=^(_eab .Data [_fceaf +_ccdd ]|_gddbc .Data [_cecb +_ccdd ]);};_cecb +=_gddbc .BytesPerLine ;_fceaf +=_eab .BytesPerLine ;};};if _afcf {for _abfe =0;_abfe < _bgab ;_abfe ++{_gddbc .Data [_gbgc ]=_bfgd (_gddbc .Data [_gbgc ],^(_eab .Data [_fdgae ]|_gddbc .Data [_gbgc ]),_cdbe );
_gbgc +=_gddbc .BytesPerLine ;_fdgae +=_eab .BytesPerLine ;};};case PixNotPixSrcAndDst :for _abfe =0;_abfe < _bgab ;_abfe ++{_gddbc .Data [_aeba ]=_bfgd (_gddbc .Data [_aeba ],^(_eab .Data [_dgdf ]&_gddbc .Data [_aeba ]),_baeb );_aeba +=_gddbc .BytesPerLine ;
_dgdf +=_eab .BytesPerLine ;};if _fddg {for _abfe =0;_abfe < _bgab ;_abfe ++{for _ccdd =0;_ccdd < _eddb ;_ccdd ++{_gddbc .Data [_cecb +_ccdd ]=^(_eab .Data [_fceaf +_ccdd ]&_gddbc .Data [_cecb +_ccdd ]);};_cecb +=_gddbc .BytesPerLine ;_fceaf +=_eab .BytesPerLine ;
};};if _afcf {for _abfe =0;_abfe < _bgab ;_abfe ++{_gddbc .Data [_gbgc ]=_bfgd (_gddbc .Data [_gbgc ],^(_eab .Data [_fdgae ]&_gddbc .Data [_gbgc ]),_cdbe );_gbgc +=_gddbc .BytesPerLine ;_fdgae +=_eab .BytesPerLine ;};};case PixNotPixSrcXorDst :for _abfe =0;
_abfe < _bgab ;_abfe ++{_gddbc .Data [_aeba ]=_bfgd (_gddbc .Data [_aeba ],^(_eab .Data [_dgdf ]^_gddbc .Data [_aeba ]),_baeb );_aeba +=_gddbc .BytesPerLine ;_dgdf +=_eab .BytesPerLine ;};if _fddg {for _abfe =0;_abfe < _bgab ;_abfe ++{for _ccdd =0;_ccdd < _eddb ;
_ccdd ++{_gddbc .Data [_cecb +_ccdd ]=^(_eab .Data [_fceaf +_ccdd ]^_gddbc .Data [_cecb +_ccdd ]);};_cecb +=_gddbc .BytesPerLine ;_fceaf +=_eab .BytesPerLine ;};};if _afcf {for _abfe =0;_abfe < _bgab ;_abfe ++{_gddbc .Data [_gbgc ]=_bfgd (_gddbc .Data [_gbgc ],^(_eab .Data [_fdgae ]^_gddbc .Data [_gbgc ]),_cdbe );
_gbgc +=_gddbc .BytesPerLine ;_fdgae +=_eab .BytesPerLine ;};};default:_cg .Log .Debug ("I\u006e\u0076\u0061\u006c\u0069\u0064 \u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070e\u0072\u0061\u0074o\u0072:\u0020\u0025\u0064",_fafca );return _f .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072");
};return nil ;};func NewImage (width ,height ,bitsPerComponent ,colorComponents int ,data ,alpha []byte ,decode []float64 )(Image ,error ){_cddg :=NewImageBase (width ,height ,bitsPerComponent ,colorComponents ,data ,alpha ,decode );var _dcbd Image ;switch colorComponents {case 1:switch bitsPerComponent {case 1:_dcbd =&Monochrome {ImageBase :_cddg ,ModelThreshold :0x0f};
case 2:_dcbd =&Gray2 {ImageBase :_cddg };case 4:_dcbd =&Gray4 {ImageBase :_cddg };case 8:_dcbd =&Gray8 {ImageBase :_cddg };case 16:_dcbd =&Gray16 {ImageBase :_cddg };};case 3:switch bitsPerComponent {case 4:_dcbd =&NRGBA16 {ImageBase :_cddg };case 8:_dcbd =&NRGBA32 {ImageBase :_cddg };
case 16:_dcbd =&NRGBA64 {ImageBase :_cddg };};case 4:_dcbd =&CMYK32 {ImageBase :_cddg };};if _dcbd ==nil {return nil ,ErrInvalidImage ;};return _dcbd ,nil ;};type CMYK32 struct{ImageBase };var _ _e .Image =&NRGBA16 {};func _ccefg (_baa Gray ,_afga NRGBA ,_fdec _e .Rectangle ){for _aebg :=0;
_aebg < _fdec .Max .X ;_aebg ++{for _gaeg :=0;_gaeg < _fdec .Max .Y ;_gaeg ++{_gdfg :=_baa .GrayAt (_aebg ,_gaeg );_afga .SetNRGBA (_aebg ,_gaeg ,_aeca (_gdfg ));};};};func _cge (_fafc _dc .Gray )_dc .Gray {_fafc .Y >>=4;_fafc .Y |=_fafc .Y <<4;return _fafc };
func _fdgb (_aag _e .Image )(Image ,error ){if _decd ,_geggb :=_aag .(*Gray2 );_geggb {return _decd .Copy (),nil ;};_abcc :=_aag .Bounds ();_ecffc ,_gbdf :=NewImage (_abcc .Max .X ,_abcc .Max .Y ,2,1,nil ,nil ,nil );if _gbdf !=nil {return nil ,_gbdf ;};
_aedd (_aag ,_ecffc ,_abcc );return _ecffc ,nil ;};func _ggffd (_aef _dc .NYCbCrA )_dc .NRGBA {_bbe :=int32 (_aef .Y )*0x10101;_agac :=int32 (_aef .Cb )-128;_ccca :=int32 (_aef .Cr )-128;_ebg :=_bbe +91881*_ccca ;if uint32 (_ebg )&0xff000000==0{_ebg >>=8;
}else {_ebg =^(_ebg >>31)&0xffff;};_dgca :=_bbe -22554*_agac -46802*_ccca ;if uint32 (_dgca )&0xff000000==0{_dgca >>=8;}else {_dgca =^(_dgca >>31)&0xffff;};_gfb :=_bbe +116130*_agac ;if uint32 (_gfb )&0xff000000==0{_gfb >>=8;}else {_gfb =^(_gfb >>31)&0xffff;
};return _dc .NRGBA {R :uint8 (_ebg >>8),G :uint8 (_dgca >>8),B :uint8 (_gfb >>8),A :_aef .A };};func (_fgacb *NRGBA64 )ColorModel ()_dc .Model {return _dc .NRGBA64Model };func _fcg (_fd *Monochrome ,_edf ,_edfa int )(*Monochrome ,error ){if _fd ==nil {return nil ,_f .New ("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064");
};if _edf <=0||_edfa <=0{return nil ,_f .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0073\u0063\u0061l\u0065\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020<\u003d\u0020\u0030");};if _edf ==_edfa {if _edf ==1{return _fd .copy (),nil ;
};if _edf ==2||_edf ==4||_edf ==8{_fbb ,_dccc :=_ad (_fd ,_edf );if _dccc !=nil {return nil ,_dccc ;};return _fbb ,nil ;};};_df :=_edf *_fd .Width ;_cgb :=_edfa *_fd .Height ;_db :=_bec (_df ,_cgb );_bgf :=_db .BytesPerLine ;var (_bed ,_eff ,_dbg ,_geg ,_dec int ;
_cca byte ;_dfe error ;);for _eff =0;_eff < _fd .Height ;_eff ++{_bed =_edfa *_eff *_bgf ;for _dbg =0;_dbg < _fd .Width ;_dbg ++{if _daa :=_fd .getBitAt (_dbg ,_eff );_daa {_dec =_edf *_dbg ;for _geg =0;_geg < _edf ;_geg ++{_db .setIndexedBit (_bed *8+_dec +_geg );
};};};for _geg =1;_geg < _edfa ;_geg ++{_aff :=_bed +_geg *_bgf ;for _ffd :=0;_ffd < _bgf ;_ffd ++{if _cca ,_dfe =_db .getByte (_bed +_ffd );_dfe !=nil {return nil ,_dfe ;};if _dfe =_db .setByte (_aff +_ffd ,_cca );_dfe !=nil {return nil ,_dfe ;};};};};
return _db ,nil ;};func _gcfdb (_bcfb *_e .Gray )bool {for _edfc :=0;_edfc < len (_bcfb .Pix );_edfc ++{if !_decb (_bcfb .Pix [_edfc ]){return false ;};};return true ;};var ErrInvalidImage =_f .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
func (_fabc *Gray8 )GrayAt (x ,y int )_dc .Gray {_afgd ,_ :=ColorAtGray8BPC (x ,y ,_fabc .BytesPerLine ,_fabc .Data ,_fabc .Decode );return _afgd ;};func _effe (_bfdg ,_baca NRGBA ,_ebce _e .Rectangle ){for _gbge :=0;_gbge < _ebce .Max .X ;_gbge ++{for _aacb :=0;
_aacb < _ebce .Max .Y ;_aacb ++{_baca .SetNRGBA (_gbge ,_aacb ,_bfdg .NRGBAAt (_gbge ,_aacb ));};};};func (_ddd *NRGBA32 )Copy ()Image {return &NRGBA32 {ImageBase :_ddd .copy ()}};func _bdaf (_egd CMYK ,_gfacb Gray ,_acg _e .Rectangle ){for _fbgb :=0;_fbgb < _acg .Max .X ;
_fbgb ++{for _bfdd :=0;_bfdd < _acg .Max .Y ;_bfdd ++{_ggaa :=_fgg (_egd .CMYKAt (_fbgb ,_bfdd ));_gfacb .SetGray (_fbgb ,_bfdd ,_ggaa );};};};func _bdeb (_aecc int ,_cdeba int )error {return _de .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",_aecc ,_cdeba );
};func (_gbebc *Gray8 )ColorAt (x ,y int )(_dc .Color ,error ){return ColorAtGray8BPC (x ,y ,_gbebc .BytesPerLine ,_gbebc .Data ,_gbebc .Decode );};func (_efe *ImageBase )Pix ()[]byte {return _efe .Data };func (_aeae *Gray2 )ColorAt (x ,y int )(_dc .Color ,error ){return ColorAtGray2BPC (x ,y ,_aeae .BytesPerLine ,_aeae .Data ,_aeae .Decode );
};type RGBA interface{RGBAAt (_cadgg ,_bfcge int )_dc .RGBA ;SetRGBA (_cdgg ,_egcc int ,_bgaa _dc .RGBA );};var _ _e .Image =&NRGBA32 {};func _bge (_eba NRGBA ,_gae CMYK ,_aafe _e .Rectangle ){for _eggd :=0;_eggd < _aafe .Max .X ;_eggd ++{for _edcf :=0;
_edcf < _aafe .Max .Y ;_edcf ++{_gea :=_eba .NRGBAAt (_eggd ,_edcf );_gae .SetCMYK (_eggd ,_edcf ,_fcf (_gea ));};};};func _agee (_bgbb *Monochrome ,_feab ,_daag int ,_eafd ,_gcae int ,_gfgb RasterOperator ){var (_eeeg bool ;_dfefg bool ;_bacc int ;_cfgff int ;
_cebc int ;_bfdb int ;_ebbc bool ;_fafb byte ;);_cecc :=8-(_feab &7);_gefb :=_cgcg [_cecc ];_fcbb :=_bgbb .BytesPerLine *_daag +(_feab >>3);if _eafd < _cecc {_eeeg =true ;_gefb &=_aeag [8-_cecc +_eafd ];};if !_eeeg {_bacc =(_eafd -_cecc )>>3;if _bacc !=0{_dfefg =true ;
_cfgff =_fcbb +1;};};_cebc =(_feab +_eafd )&7;if !(_eeeg ||_cebc ==0){_ebbc =true ;_fafb =_aeag [_cebc ];_bfdb =_fcbb +1+_bacc ;};var _dgce ,_gbbc int ;switch _gfgb {case PixClr :for _dgce =0;_dgce < _gcae ;_dgce ++{_bgbb .Data [_fcbb ]=_bfgd (_bgbb .Data [_fcbb ],0x0,_gefb );
_fcbb +=_bgbb .BytesPerLine ;};if _dfefg {for _dgce =0;_dgce < _gcae ;_dgce ++{for _gbbc =0;_gbbc < _bacc ;_gbbc ++{_bgbb .Data [_cfgff +_gbbc ]=0x0;};_cfgff +=_bgbb .BytesPerLine ;};};if _ebbc {for _dgce =0;_dgce < _gcae ;_dgce ++{_bgbb .Data [_bfdb ]=_bfgd (_bgbb .Data [_bfdb ],0x0,_fafb );
_bfdb +=_bgbb .BytesPerLine ;};};case PixSet :for _dgce =0;_dgce < _gcae ;_dgce ++{_bgbb .Data [_fcbb ]=_bfgd (_bgbb .Data [_fcbb ],0xff,_gefb );_fcbb +=_bgbb .BytesPerLine ;};if _dfefg {for _dgce =0;_dgce < _gcae ;_dgce ++{for _gbbc =0;_gbbc < _bacc ;
_gbbc ++{_bgbb .Data [_cfgff +_gbbc ]=0xff;};_cfgff +=_bgbb .BytesPerLine ;};};if _ebbc {for _dgce =0;_dgce < _gcae ;_dgce ++{_bgbb .Data [_bfdb ]=_bfgd (_bgbb .Data [_bfdb ],0xff,_fafb );_bfdb +=_bgbb .BytesPerLine ;};};case PixNotDst :for _dgce =0;_dgce < _gcae ;
_dgce ++{_bgbb .Data [_fcbb ]=_bfgd (_bgbb .Data [_fcbb ],^_bgbb .Data [_fcbb ],_gefb );_fcbb +=_bgbb .BytesPerLine ;};if _dfefg {for _dgce =0;_dgce < _gcae ;_dgce ++{for _gbbc =0;_gbbc < _bacc ;_gbbc ++{_bgbb .Data [_cfgff +_gbbc ]=^(_bgbb .Data [_cfgff +_gbbc ]);
};_cfgff +=_bgbb .BytesPerLine ;};};if _ebbc {for _dgce =0;_dgce < _gcae ;_dgce ++{_bgbb .Data [_bfdb ]=_bfgd (_bgbb .Data [_bfdb ],^_bgbb .Data [_bfdb ],_fafb );_bfdb +=_bgbb .BytesPerLine ;};};};};func (_dgcf *NRGBA32 )Bounds ()_e .Rectangle {return _e .Rectangle {Max :_e .Point {X :_dgcf .Width ,Y :_dgcf .Height }};
};var _ _e .Image =&Gray8 {};func (_dea colorConverter )Convert (src _e .Image )(Image ,error ){return _dea ._fcc (src )};func (_egge *CMYK32 )CMYKAt (x ,y int )_dc .CMYK {_dcg ,_ :=ColorAtCMYK (x ,y ,_egge .Width ,_egge .Data ,_egge .Decode );return _dcg ;
};func (_bged *Gray2 )Set (x ,y int ,c _dc .Color ){if x >=_bged .Width ||y >=_bged .Height {return ;};_egee :=Gray2Model .Convert (c ).(_dc .Gray );_abdd :=y *_bged .BytesPerLine ;_edg :=_abdd +(x >>2);_bgbc :=_egee .Y >>6;_bged .Data [_edg ]=(_bged .Data [_edg ]&(^(0xc0>>uint (2*((x )&3)))))|(_bgbc <<uint (6-2*(x &3)));
};func (_edef *NRGBA16 )ColorAt (x ,y int )(_dc .Color ,error ){return ColorAtNRGBA16 (x ,y ,_edef .Width ,_edef .BytesPerLine ,_edef .Data ,_edef .Alpha ,_edef .Decode );};type ColorConverter interface{Convert (_abc _e .Image )(Image ,error );};type nrgba64 interface{NRGBA64At (_fgcab ,_bacge int )_dc .NRGBA64 ;
SetNRGBA64 (_geea ,_ffea int ,_ffdcdg _dc .NRGBA64 );};type Histogramer interface{Histogram ()[256]int ;};func NewImageBase (width int ,height int ,bitsPerComponent int ,colorComponents int ,data []byte ,alpha []byte ,decode []float64 )ImageBase {_cdeb :=ImageBase {Width :width ,Height :height ,BitsPerComponent :bitsPerComponent ,ColorComponents :colorComponents ,Data :data ,Alpha :alpha ,Decode :decode ,BytesPerLine :BytesPerLine (width ,bitsPerComponent ,colorComponents )};
if data ==nil {_cdeb .Data =make ([]byte ,height *_cdeb .BytesPerLine );};return _cdeb ;};func (_adadb *NRGBA64 )Validate ()error {if len (_adadb .Data )!=3*2*_adadb .Width *_adadb .Height {return _f .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func _fee (_dbeaa Gray ,_ddfg NRGBA ,_caf _e .Rectangle ){for _gdc :=0;_gdc < _caf .Max .X ;_gdc ++{for _fbge :=0;_fbge < _caf .Max .Y ;_fbge ++{_fdccg :=_gaadg (_ddfg .NRGBAAt (_gdc ,_fbge ));_dbeaa .SetGray (_gdc ,_fbge ,_fdccg );};};
};func _gdd (_cbaa ,_eea *Monochrome ,_fec []byte ,_fdf int )(_dfd error ){var (_feb ,_gbc ,_fef ,_fdg ,_ebb ,_aga ,_gddb ,_gac int ;_dda ,_beeg uint32 ;_fcea ,_bea byte ;_gcg uint16 ;);_abd :=make ([]byte ,4);_gbe :=make ([]byte ,4);for _fef =0;_fef < _cbaa .Height -1;
_fef ,_fdg =_fef +2,_fdg +1{_feb =_fef *_cbaa .BytesPerLine ;_gbc =_fdg *_eea .BytesPerLine ;for _ebb ,_aga =0,0;_ebb < _fdf ;_ebb ,_aga =_ebb +4,_aga +1{for _gddb =0;_gddb < 4;_gddb ++{_gac =_feb +_ebb +_gddb ;if _gac <=len (_cbaa .Data )-1&&_gac < _feb +_cbaa .BytesPerLine {_abd [_gddb ]=_cbaa .Data [_gac ];
}else {_abd [_gddb ]=0x00;};_gac =_feb +_cbaa .BytesPerLine +_ebb +_gddb ;if _gac <=len (_cbaa .Data )-1&&_gac < _feb +(2*_cbaa .BytesPerLine ){_gbe [_gddb ]=_cbaa .Data [_gac ];}else {_gbe [_gddb ]=0x00;};};_dda =_fc .BigEndian .Uint32 (_abd );_beeg =_fc .BigEndian .Uint32 (_gbe );
_beeg |=_dda ;_beeg |=_beeg <<1;_beeg &=0xaaaaaaaa;_dda =_beeg |(_beeg <<7);_fcea =byte (_dda >>24);_bea =byte ((_dda >>8)&0xff);_gac =_gbc +_aga ;if _gac +1==len (_eea .Data )-1||_gac +1>=_gbc +_eea .BytesPerLine {_eea .Data [_gac ]=_fec [_fcea ];}else {_gcg =(uint16 (_fec [_fcea ])<<8)|uint16 (_fec [_bea ]);
if _dfd =_eea .setTwoBytes (_gac ,_gcg );_dfd !=nil {return _de .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_gac );
};_aga ++;};};};return nil ;};func (_ggfa *NRGBA16 )NRGBAAt (x ,y int )_dc .NRGBA {_bfgc ,_ :=ColorAtNRGBA16 (x ,y ,_ggfa .Width ,_ggfa .BytesPerLine ,_ggfa .Data ,_ggfa .Alpha ,_ggfa .Decode );return _bfgc ;};type Gray2 struct{ImageBase };func (_eeae *Gray4 )Base ()*ImageBase {return &_eeae .ImageBase };
func _dgcec (_dgcg _e .Image )(Image ,error ){if _dfaf ,_agcefg :=_dgcg .(*NRGBA32 );_agcefg {return _dfaf .Copy (),nil ;};_dbae ,_bfaae ,_bfgdc :=_eaaa (_dgcg ,1);_cabc ,_cdee :=NewImage (_dbae .Max .X ,_dbae .Max .Y ,8,3,nil ,_bfgdc ,nil );if _cdee !=nil {return nil ,_cdee ;
};_gdgd (_dgcg ,_cabc ,_dbae );if len (_bfgdc )!=0&&!_bfaae {if _bcda :=_ddfac (_bfgdc ,_cabc );_bcda !=nil {return nil ,_bcda ;};};return _cabc ,nil ;};func _daee (_dcfc int ,_bdg int )int {if _dcfc < _bdg {return _dcfc ;};return _bdg ;};func (_dgad *Monochrome )ReduceBinary (factor float64 )(*Monochrome ,error ){_dde :=_abad (uint (factor ));
if !IsPowerOf2 (uint (factor )){_dde ++;};_abb :=make ([]int ,_dde );for _ffef :=range _abb {_abb [_ffef ]=4;};_aae ,_cfc :=_aac (_dgad ,_abb ...);if _cfc !=nil {return nil ,_cfc ;};return _aae ,nil ;};type RasterOperator int ;func _fefb (_fae RGBA ,_daea CMYK ,_cef _e .Rectangle ){for _gfg :=0;
_gfg < _cef .Max .X ;_gfg ++{for _ebdf :=0;_ebdf < _cef .Max .Y ;_ebdf ++{_bfa :=_fae .RGBAAt (_gfg ,_ebdf );_daea .SetCMYK (_gfg ,_ebdf ,_afbf (_bfa ));};};};func (_ccge *ImageBase )setEightPartlyBytes (_gce ,_acc int ,_caff uint64 )(_cfdb error ){var (_ffcac byte ;
_gede int ;);for _abcd :=1;_abcd <=_acc ;_abcd ++{_gede =64-_abcd *8;_ffcac =byte (_caff >>uint (_gede )&0xff);if _cfdb =_ccge .setByte (_gce +_abcd -1,_ffcac );_cfdb !=nil {return _cfdb ;};};_gacg :=_ccge .BytesPerLine *8-_ccge .Width ;if _gacg ==0{return nil ;
};_gede -=8;_ffcac =byte (_caff >>uint (_gede )&0xff)<<uint (_gacg );if _cfdb =_ccge .setByte (_gce +_acc ,_ffcac );_cfdb !=nil {return _cfdb ;};return nil ;};func (_agec *NRGBA16 )Bounds ()_e .Rectangle {return _e .Rectangle {Max :_e .Point {X :_agec .Width ,Y :_agec .Height }};
};func _aeca (_ade _dc .Gray )_dc .NRGBA {return _dc .NRGBA {R :_ade .Y ,G :_ade .Y ,B :_ade .Y ,A :0xff}};func ColorAtNRGBA64 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_dc .NRGBA64 ,error ){_fegf :=(y *width +x )*2;_aagec :=_fegf *3;if _aagec +5>=len (data ){return _dc .NRGBA64 {},_de .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};const _ced =0xffff;_bccb :=uint16 (_ced );if alpha !=nil &&len (alpha )> _fegf +1{_bccb =uint16 (alpha [_fegf ])<<8|uint16 (alpha [_fegf +1]);};_eacd :=uint16 (data [_aagec ])<<8|uint16 (data [_aagec +1]);_eecg :=uint16 (data [_aagec +2])<<8|uint16 (data [_aagec +3]);
_bdbga :=uint16 (data [_aagec +4])<<8|uint16 (data [_aagec +5]);if len (decode )==6{_eacd =uint16 (uint64 (LinearInterpolate (float64 (_eacd ),0,65535,decode [0],decode [1]))&_ced );_eecg =uint16 (uint64 (LinearInterpolate (float64 (_eecg ),0,65535,decode [2],decode [3]))&_ced );
_bdbga =uint16 (uint64 (LinearInterpolate (float64 (_bdbga ),0,65535,decode [4],decode [5]))&_ced );};return _dc .NRGBA64 {R :_eacd ,G :_eecg ,B :_bdbga ,A :_bccb },nil ;};func (_bfg *CMYK32 )Copy ()Image {return &CMYK32 {ImageBase :_bfg .copy ()}};var _ Image =&Gray16 {};
func ColorAtGray1BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_dc .Gray ,error ){_acdf :=y *bytesPerLine +x >>3;if _acdf >=len (data ){return _dc .Gray {},_de .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_dagb :=data [_acdf ]>>uint (7-(x &7))&1;if len (decode )==2{_dagb =uint8 (LinearInterpolate (float64 (_dagb ),0.0,1.0,decode [0],decode [1]))&1;};return _dc .Gray {Y :_dagb *255},nil ;};var _ _e .Image =&Monochrome {};func (_afeb *Monochrome )setBit (_fde ,_bfba int ){_afeb .Data [_fde +(_bfba >>3)]|=0x80>>uint (_bfba &7);
};func LinearInterpolate (x ,xmin ,xmax ,ymin ,ymax float64 )float64 {if _d .Abs (xmax -xmin )< 0.000001{return ymin ;};_gbfa :=ymin +(x -xmin )*(ymax -ymin )/(xmax -xmin );return _gbfa ;};type NRGBA interface{NRGBAAt (_ffgd ,_bafd int )_dc .NRGBA ;SetNRGBA (_cgeb ,_ecdd int ,_ggdf _dc .NRGBA );
};func (_dacgc *NRGBA32 )At (x ,y int )_dc .Color {_ccad ,_ :=_dacgc .ColorAt (x ,y );return _ccad };func (_fdca *Gray4 )Set (x ,y int ,c _dc .Color ){if x >=_fdca .Width ||y >=_fdca .Height {return ;};_edde :=Gray4Model .Convert (c ).(_dc .Gray );_fdca .setGray (x ,y ,_edde );
};func (_dbaf *NRGBA64 )At (x ,y int )_dc .Color {_eeec ,_ :=_dbaf .ColorAt (x ,y );return _eeec };func (_ecbfg *ImageBase )newAlpha (){_bgc :=BytesPerLine (_ecbfg .Width ,_ecbfg .BitsPerComponent ,1);_ecbfg .Alpha =make ([]byte ,_ecbfg .Height *_bgc );
};func (_efbe *NRGBA64 )Set (x ,y int ,c _dc .Color ){_dcde :=(y *_efbe .Width +x )*2;_ggcf :=_dcde *3;if _ggcf +5>=len (_efbe .Data ){return ;};_gcgb :=_dc .NRGBA64Model .Convert (c ).(_dc .NRGBA64 );_efbe .setNRGBA64 (_ggcf ,_gcgb ,_dcde );};func (_dcd *Monochrome )InverseData ()error {return _dcd .RasterOperation (0,0,_dcd .Width ,_dcd .Height ,PixNotDst ,nil ,0,0);
};func (_ccec *Gray4 )At (x ,y int )_dc .Color {_aba ,_ :=_ccec .ColorAt (x ,y );return _aba };var _ Image =&NRGBA16 {};type shift int ;type NRGBA64 struct{ImageBase };func _adg (_bd *Monochrome ,_ae int ,_ed []uint )(*Monochrome ,error ){_be :=_ae *_bd .Width ;
_bf :=_ae *_bd .Height ;_adc :=_bec (_be ,_bf );for _bee ,_af :=range _ed {var _cf error ;switch _af {case 2:_cf =_ac (_adc ,_bd );case 4:_cf =_gaa (_adc ,_bd );case 8:_cf =_eae (_adc ,_bd );};if _cf !=nil {return nil ,_cf ;};if _bee !=len (_ed )-1{_bd =_adc .copy ();
};};return _adc ,nil ;};func (_bbgfg *NRGBA16 )setNRGBA (_egde ,_caeg ,_ddbbd int ,_cfed _dc .NRGBA ){if _egde *3%2==0{_bbgfg .Data [_ddbbd ]=(_cfed .R >>4)<<4|(_cfed .G >>4);_bbgfg .Data [_ddbbd +1]=(_cfed .B >>4)<<4|(_bbgfg .Data [_ddbbd +1]&0xf);}else {_bbgfg .Data [_ddbbd ]=(_bbgfg .Data [_ddbbd ]&0xf0)|(_cfed .R >>4);
_bbgfg .Data [_ddbbd +1]=(_cfed .G >>4)<<4|(_cfed .B >>4);};if _bbgfg .Alpha !=nil {_gbec :=_caeg *BytesPerLine (_bbgfg .Width ,4,1);if _gbec < len (_bbgfg .Alpha ){if _egde %2==0{_bbgfg .Alpha [_gbec ]=(_cfed .A >>uint (4))<<uint (4)|(_bbgfg .Alpha [_ddbbd ]&0xf);
}else {_bbgfg .Alpha [_gbec ]=(_bbgfg .Alpha [_gbec ]&0xf0)|(_cfed .A >>uint (4));};};};};func (_cad *Monochrome )Bounds ()_e .Rectangle {return _e .Rectangle {Max :_e .Point {X :_cad .Width ,Y :_cad .Height }};};func _ad (_eb *Monochrome ,_g int )(*Monochrome ,error ){if _eb ==nil {return nil ,_f .New ("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064");
};if _g ==1{return _eb .copy (),nil ;};if !IsPowerOf2 (uint (_g )){return nil ,_de .Errorf ("\u0070\u0072\u006fvi\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006ci\u0064 \u0065x\u0070a\u006e\u0064\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_g );
};_cde :=_gaad (_g );return _adg (_eb ,_g ,_cde );};func _gaadg (_bedg _dc .NRGBA )_dc .Gray {var _dfad _dc .NRGBA ;if _bedg ==_dfad {return _dc .Gray {Y :0xff};};_dbea ,_gee ,_ecaa ,_ :=_bedg .RGBA ();_bbgf :=(19595*_dbea +38470*_gee +7471*_ecaa +1<<15)>>24;
return _dc .Gray {Y :uint8 (_bbgf )};};func _cccde (_bgec *Monochrome ,_efac ,_fgea ,_gbdd ,_afcff int ,_bfda RasterOperator ,_afaf *Monochrome ,_gcfg ,_bbbb int )error {var (_bff bool ;_dgfd bool ;_dbdbd byte ;_agcef int ;_bdfe int ;_bbda int ;_ffdg int ;
_bgfca bool ;_dbcd int ;_decde int ;_egfe int ;_eggg bool ;_cadg byte ;_dad int ;_cfdbg int ;_facc int ;_gagdf byte ;_ddba int ;_ddcc int ;_gfaga uint ;_abagb uint ;_cfdc byte ;_fbdc shift ;_eadb bool ;_dacg bool ;_dgeg ,_bdff int ;);if _gcfg &7!=0{_ddcc =8-(_gcfg &7);
};if _efac &7!=0{_bdfe =8-(_efac &7);};if _ddcc ==0&&_bdfe ==0{_cfdc =_cgcg [0];}else {if _bdfe > _ddcc {_gfaga =uint (_bdfe -_ddcc );}else {_gfaga =uint (8-(_ddcc -_bdfe ));};_abagb =8-_gfaga ;_cfdc =_cgcg [_gfaga ];};if (_efac &7)!=0{_bff =true ;_agcef =8-(_efac &7);
_dbdbd =_cgcg [_agcef ];_bbda =_bgec .BytesPerLine *_fgea +(_efac >>3);_ffdg =_afaf .BytesPerLine *_bbbb +(_gcfg >>3);_ddba =8-(_gcfg &7);if _agcef > _ddba {_fbdc =_cdfag ;if _gbdd >=_ddcc {_eadb =true ;};}else {_fbdc =_bbed ;};};if _gbdd < _agcef {_dgfd =true ;
_dbdbd &=_aeag [8-_agcef +_gbdd ];};if !_dgfd {_dbcd =(_gbdd -_agcef )>>3;if _dbcd !=0{_bgfca =true ;_decde =_bgec .BytesPerLine *_fgea +((_efac +_bdfe )>>3);_egfe =_afaf .BytesPerLine *_bbbb +((_gcfg +_bdfe )>>3);};};_dad =(_efac +_gbdd )&7;if !(_dgfd ||_dad ==0){_eggg =true ;
_cadg =_aeag [_dad ];_cfdbg =_bgec .BytesPerLine *_fgea +((_efac +_bdfe )>>3)+_dbcd ;_facc =_afaf .BytesPerLine *_bbbb +((_gcfg +_bdfe )>>3)+_dbcd ;if _dad > int (_abagb ){_dacg =true ;};};switch _bfda {case PixSrc :if _bff {for _dgeg =0;_dgeg < _afcff ;
_dgeg ++{if _fbdc ==_cdfag {_gagdf =_afaf .Data [_ffdg ]<<_gfaga ;if _eadb {_gagdf =_bfgd (_gagdf ,_afaf .Data [_ffdg +1]>>_abagb ,_cfdc );};}else {_gagdf =_afaf .Data [_ffdg ]>>_abagb ;};_bgec .Data [_bbda ]=_bfgd (_bgec .Data [_bbda ],_gagdf ,_dbdbd );
_bbda +=_bgec .BytesPerLine ;_ffdg +=_afaf .BytesPerLine ;};};if _bgfca {for _dgeg =0;_dgeg < _afcff ;_dgeg ++{for _bdff =0;_bdff < _dbcd ;_bdff ++{_gagdf =_bfgd (_afaf .Data [_egfe +_bdff ]<<_gfaga ,_afaf .Data [_egfe +_bdff +1]>>_abagb ,_cfdc );_bgec .Data [_decde +_bdff ]=_gagdf ;
};_decde +=_bgec .BytesPerLine ;_egfe +=_afaf .BytesPerLine ;};};if _eggg {for _dgeg =0;_dgeg < _afcff ;_dgeg ++{_gagdf =_afaf .Data [_facc ]<<_gfaga ;if _dacg {_gagdf =_bfgd (_gagdf ,_afaf .Data [_facc +1]>>_abagb ,_cfdc );};_bgec .Data [_cfdbg ]=_bfgd (_bgec .Data [_cfdbg ],_gagdf ,_cadg );
_cfdbg +=_bgec .BytesPerLine ;_facc +=_afaf .BytesPerLine ;};};case PixNotSrc :if _bff {for _dgeg =0;_dgeg < _afcff ;_dgeg ++{if _fbdc ==_cdfag {_gagdf =_afaf .Data [_ffdg ]<<_gfaga ;if _eadb {_gagdf =_bfgd (_gagdf ,_afaf .Data [_ffdg +1]>>_abagb ,_cfdc );
};}else {_gagdf =_afaf .Data [_ffdg ]>>_abagb ;};_bgec .Data [_bbda ]=_bfgd (_bgec .Data [_bbda ],^_gagdf ,_dbdbd );_bbda +=_bgec .BytesPerLine ;_ffdg +=_afaf .BytesPerLine ;};};if _bgfca {for _dgeg =0;_dgeg < _afcff ;_dgeg ++{for _bdff =0;_bdff < _dbcd ;
_bdff ++{_gagdf =_bfgd (_afaf .Data [_egfe +_bdff ]<<_gfaga ,_afaf .Data [_egfe +_bdff +1]>>_abagb ,_cfdc );_bgec .Data [_decde +_bdff ]=^_gagdf ;};_decde +=_bgec .BytesPerLine ;_egfe +=_afaf .BytesPerLine ;};};if _eggg {for _dgeg =0;_dgeg < _afcff ;_dgeg ++{_gagdf =_afaf .Data [_facc ]<<_gfaga ;
if _dacg {_gagdf =_bfgd (_gagdf ,_afaf .Data [_facc +1]>>_abagb ,_cfdc );};_bgec .Data [_cfdbg ]=_bfgd (_bgec .Data [_cfdbg ],^_gagdf ,_cadg );_cfdbg +=_bgec .BytesPerLine ;_facc +=_afaf .BytesPerLine ;};};case PixSrcOrDst :if _bff {for _dgeg =0;_dgeg < _afcff ;
_dgeg ++{if _fbdc ==_cdfag {_gagdf =_afaf .Data [_ffdg ]<<_gfaga ;if _eadb {_gagdf =_bfgd (_gagdf ,_afaf .Data [_ffdg +1]>>_abagb ,_cfdc );};}else {_gagdf =_afaf .Data [_ffdg ]>>_abagb ;};_bgec .Data [_bbda ]=_bfgd (_bgec .Data [_bbda ],_gagdf |_bgec .Data [_bbda ],_dbdbd );
_bbda +=_bgec .BytesPerLine ;_ffdg +=_afaf .BytesPerLine ;};};if _bgfca {for _dgeg =0;_dgeg < _afcff ;_dgeg ++{for _bdff =0;_bdff < _dbcd ;_bdff ++{_gagdf =_bfgd (_afaf .Data [_egfe +_bdff ]<<_gfaga ,_afaf .Data [_egfe +_bdff +1]>>_abagb ,_cfdc );_bgec .Data [_decde +_bdff ]|=_gagdf ;
};_decde +=_bgec .BytesPerLine ;_egfe +=_afaf .BytesPerLine ;};};if _eggg {for _dgeg =0;_dgeg < _afcff ;_dgeg ++{_gagdf =_afaf .Data [_facc ]<<_gfaga ;if _dacg {_gagdf =_bfgd (_gagdf ,_afaf .Data [_facc +1]>>_abagb ,_cfdc );};_bgec .Data [_cfdbg ]=_bfgd (_bgec .Data [_cfdbg ],_gagdf |_bgec .Data [_cfdbg ],_cadg );
_cfdbg +=_bgec .BytesPerLine ;_facc +=_afaf .BytesPerLine ;};};case PixSrcAndDst :if _bff {for _dgeg =0;_dgeg < _afcff ;_dgeg ++{if _fbdc ==_cdfag {_gagdf =_afaf .Data [_ffdg ]<<_gfaga ;if _eadb {_gagdf =_bfgd (_gagdf ,_afaf .Data [_ffdg +1]>>_abagb ,_cfdc );
};}else {_gagdf =_afaf .Data [_ffdg ]>>_abagb ;};_bgec .Data [_bbda ]=_bfgd (_bgec .Data [_bbda ],_gagdf &_bgec .Data [_bbda ],_dbdbd );_bbda +=_bgec .BytesPerLine ;_ffdg +=_afaf .BytesPerLine ;};};if _bgfca {for _dgeg =0;_dgeg < _afcff ;_dgeg ++{for _bdff =0;
_bdff < _dbcd ;_bdff ++{_gagdf =_bfgd (_afaf .Data [_egfe +_bdff ]<<_gfaga ,_afaf .Data [_egfe +_bdff +1]>>_abagb ,_cfdc );_bgec .Data [_decde +_bdff ]&=_gagdf ;};_decde +=_bgec .BytesPerLine ;_egfe +=_afaf .BytesPerLine ;};};if _eggg {for _dgeg =0;_dgeg < _afcff ;
_dgeg ++{_gagdf =_afaf .Data [_facc ]<<_gfaga ;if _dacg {_gagdf =_bfgd (_gagdf ,_afaf .Data [_facc +1]>>_abagb ,_cfdc );};_bgec .Data [_cfdbg ]=_bfgd (_bgec .Data [_cfdbg ],_gagdf &_bgec .Data [_cfdbg ],_cadg );_cfdbg +=_bgec .BytesPerLine ;_facc +=_afaf .BytesPerLine ;
};};case PixSrcXorDst :if _bff {for _dgeg =0;_dgeg < _afcff ;_dgeg ++{if _fbdc ==_cdfag {_gagdf =_afaf .Data [_ffdg ]<<_gfaga ;if _eadb {_gagdf =_bfgd (_gagdf ,_afaf .Data [_ffdg +1]>>_abagb ,_cfdc );};}else {_gagdf =_afaf .Data [_ffdg ]>>_abagb ;};_bgec .Data [_bbda ]=_bfgd (_bgec .Data [_bbda ],_gagdf ^_bgec .Data [_bbda ],_dbdbd );
_bbda +=_bgec .BytesPerLine ;_ffdg +=_afaf .BytesPerLine ;};};if _bgfca {for _dgeg =0;_dgeg < _afcff ;_dgeg ++{for _bdff =0;_bdff < _dbcd ;_bdff ++{_gagdf =_bfgd (_afaf .Data [_egfe +_bdff ]<<_gfaga ,_afaf .Data [_egfe +_bdff +1]>>_abagb ,_cfdc );_bgec .Data [_decde +_bdff ]^=_gagdf ;
};_decde +=_bgec .BytesPerLine ;_egfe +=_afaf .BytesPerLine ;};};if _eggg {for _dgeg =0;_dgeg < _afcff ;_dgeg ++{_gagdf =_afaf .Data [_facc ]<<_gfaga ;if _dacg {_gagdf =_bfgd (_gagdf ,_afaf .Data [_facc +1]>>_abagb ,_cfdc );};_bgec .Data [_cfdbg ]=_bfgd (_bgec .Data [_cfdbg ],_gagdf ^_bgec .Data [_cfdbg ],_cadg );
_cfdbg +=_bgec .BytesPerLine ;_facc +=_afaf .BytesPerLine ;};};case PixNotSrcOrDst :if _bff {for _dgeg =0;_dgeg < _afcff ;_dgeg ++{if _fbdc ==_cdfag {_gagdf =_afaf .Data [_ffdg ]<<_gfaga ;if _eadb {_gagdf =_bfgd (_gagdf ,_afaf .Data [_ffdg +1]>>_abagb ,_cfdc );
};}else {_gagdf =_afaf .Data [_ffdg ]>>_abagb ;};_bgec .Data [_bbda ]=_bfgd (_bgec .Data [_bbda ],^_gagdf |_bgec .Data [_bbda ],_dbdbd );_bbda +=_bgec .BytesPerLine ;_ffdg +=_afaf .BytesPerLine ;};};if _bgfca {for _dgeg =0;_dgeg < _afcff ;_dgeg ++{for _bdff =0;
_bdff < _dbcd ;_bdff ++{_gagdf =_bfgd (_afaf .Data [_egfe +_bdff ]<<_gfaga ,_afaf .Data [_egfe +_bdff +1]>>_abagb ,_cfdc );_bgec .Data [_decde +_bdff ]|=^_gagdf ;};_decde +=_bgec .BytesPerLine ;_egfe +=_afaf .BytesPerLine ;};};if _eggg {for _dgeg =0;_dgeg < _afcff ;
_dgeg ++{_gagdf =_afaf .Data [_facc ]<<_gfaga ;if _dacg {_gagdf =_bfgd (_gagdf ,_afaf .Data [_facc +1]>>_abagb ,_cfdc );};_bgec .Data [_cfdbg ]=_bfgd (_bgec .Data [_cfdbg ],^_gagdf |_bgec .Data [_cfdbg ],_cadg );_cfdbg +=_bgec .BytesPerLine ;_facc +=_afaf .BytesPerLine ;
};};case PixNotSrcAndDst :if _bff {for _dgeg =0;_dgeg < _afcff ;_dgeg ++{if _fbdc ==_cdfag {_gagdf =_afaf .Data [_ffdg ]<<_gfaga ;if _eadb {_gagdf =_bfgd (_gagdf ,_afaf .Data [_ffdg +1]>>_abagb ,_cfdc );};}else {_gagdf =_afaf .Data [_ffdg ]>>_abagb ;};
_bgec .Data [_bbda ]=_bfgd (_bgec .Data [_bbda ],^_gagdf &_bgec .Data [_bbda ],_dbdbd );_bbda +=_bgec .BytesPerLine ;_ffdg +=_afaf .BytesPerLine ;};};if _bgfca {for _dgeg =0;_dgeg < _afcff ;_dgeg ++{for _bdff =0;_bdff < _dbcd ;_bdff ++{_gagdf =_bfgd (_afaf .Data [_egfe +_bdff ]<<_gfaga ,_afaf .Data [_egfe +_bdff +1]>>_abagb ,_cfdc );
_bgec .Data [_decde +_bdff ]&=^_gagdf ;};_decde +=_bgec .BytesPerLine ;_egfe +=_afaf .BytesPerLine ;};};if _eggg {for _dgeg =0;_dgeg < _afcff ;_dgeg ++{_gagdf =_afaf .Data [_facc ]<<_gfaga ;if _dacg {_gagdf =_bfgd (_gagdf ,_afaf .Data [_facc +1]>>_abagb ,_cfdc );
};_bgec .Data [_cfdbg ]=_bfgd (_bgec .Data [_cfdbg ],^_gagdf &_bgec .Data [_cfdbg ],_cadg );_cfdbg +=_bgec .BytesPerLine ;_facc +=_afaf .BytesPerLine ;};};case PixSrcOrNotDst :if _bff {for _dgeg =0;_dgeg < _afcff ;_dgeg ++{if _fbdc ==_cdfag {_gagdf =_afaf .Data [_ffdg ]<<_gfaga ;
if _eadb {_gagdf =_bfgd (_gagdf ,_afaf .Data [_ffdg +1]>>_abagb ,_cfdc );};}else {_gagdf =_afaf .Data [_ffdg ]>>_abagb ;};_bgec .Data [_bbda ]=_bfgd (_bgec .Data [_bbda ],_gagdf |^_bgec .Data [_bbda ],_dbdbd );_bbda +=_bgec .BytesPerLine ;_ffdg +=_afaf .BytesPerLine ;
};};if _bgfca {for _dgeg =0;_dgeg < _afcff ;_dgeg ++{for _bdff =0;_bdff < _dbcd ;_bdff ++{_gagdf =_bfgd (_afaf .Data [_egfe +_bdff ]<<_gfaga ,_afaf .Data [_egfe +_bdff +1]>>_abagb ,_cfdc );_bgec .Data [_decde +_bdff ]=_gagdf |^_bgec .Data [_decde +_bdff ];
};_decde +=_bgec .BytesPerLine ;_egfe +=_afaf .BytesPerLine ;};};if _eggg {for _dgeg =0;_dgeg < _afcff ;_dgeg ++{_gagdf =_afaf .Data [_facc ]<<_gfaga ;if _dacg {_gagdf =_bfgd (_gagdf ,_afaf .Data [_facc +1]>>_abagb ,_cfdc );};_bgec .Data [_cfdbg ]=_bfgd (_bgec .Data [_cfdbg ],_gagdf |^_bgec .Data [_cfdbg ],_cadg );
_cfdbg +=_bgec .BytesPerLine ;_facc +=_afaf .BytesPerLine ;};};case PixSrcAndNotDst :if _bff {for _dgeg =0;_dgeg < _afcff ;_dgeg ++{if _fbdc ==_cdfag {_gagdf =_afaf .Data [_ffdg ]<<_gfaga ;if _eadb {_gagdf =_bfgd (_gagdf ,_afaf .Data [_ffdg +1]>>_abagb ,_cfdc );
};}else {_gagdf =_afaf .Data [_ffdg ]>>_abagb ;};_bgec .Data [_bbda ]=_bfgd (_bgec .Data [_bbda ],_gagdf &^_bgec .Data [_bbda ],_dbdbd );_bbda +=_bgec .BytesPerLine ;_ffdg +=_afaf .BytesPerLine ;};};if _bgfca {for _dgeg =0;_dgeg < _afcff ;_dgeg ++{for _bdff =0;
_bdff < _dbcd ;_bdff ++{_gagdf =_bfgd (_afaf .Data [_egfe +_bdff ]<<_gfaga ,_afaf .Data [_egfe +_bdff +1]>>_abagb ,_cfdc );_bgec .Data [_decde +_bdff ]=_gagdf &^_bgec .Data [_decde +_bdff ];};_decde +=_bgec .BytesPerLine ;_egfe +=_afaf .BytesPerLine ;};
};if _eggg {for _dgeg =0;_dgeg < _afcff ;_dgeg ++{_gagdf =_afaf .Data [_facc ]<<_gfaga ;if _dacg {_gagdf =_bfgd (_gagdf ,_afaf .Data [_facc +1]>>_abagb ,_cfdc );};_bgec .Data [_cfdbg ]=_bfgd (_bgec .Data [_cfdbg ],_gagdf &^_bgec .Data [_cfdbg ],_cadg );
_cfdbg +=_bgec .BytesPerLine ;_facc +=_afaf .BytesPerLine ;};};case PixNotPixSrcOrDst :if _bff {for _dgeg =0;_dgeg < _afcff ;_dgeg ++{if _fbdc ==_cdfag {_gagdf =_afaf .Data [_ffdg ]<<_gfaga ;if _eadb {_gagdf =_bfgd (_gagdf ,_afaf .Data [_ffdg +1]>>_abagb ,_cfdc );
};}else {_gagdf =_afaf .Data [_ffdg ]>>_abagb ;};_bgec .Data [_bbda ]=_bfgd (_bgec .Data [_bbda ],^(_gagdf |_bgec .Data [_bbda ]),_dbdbd );_bbda +=_bgec .BytesPerLine ;_ffdg +=_afaf .BytesPerLine ;};};if _bgfca {for _dgeg =0;_dgeg < _afcff ;_dgeg ++{for _bdff =0;
_bdff < _dbcd ;_bdff ++{_gagdf =_bfgd (_afaf .Data [_egfe +_bdff ]<<_gfaga ,_afaf .Data [_egfe +_bdff +1]>>_abagb ,_cfdc );_bgec .Data [_decde +_bdff ]=^(_gagdf |_bgec .Data [_decde +_bdff ]);};_decde +=_bgec .BytesPerLine ;_egfe +=_afaf .BytesPerLine ;
};};if _eggg {for _dgeg =0;_dgeg < _afcff ;_dgeg ++{_gagdf =_afaf .Data [_facc ]<<_gfaga ;if _dacg {_gagdf =_bfgd (_gagdf ,_afaf .Data [_facc +1]>>_abagb ,_cfdc );};_bgec .Data [_cfdbg ]=_bfgd (_bgec .Data [_cfdbg ],^(_gagdf |_bgec .Data [_cfdbg ]),_cadg );
_cfdbg +=_bgec .BytesPerLine ;_facc +=_afaf .BytesPerLine ;};};case PixNotPixSrcAndDst :if _bff {for _dgeg =0;_dgeg < _afcff ;_dgeg ++{if _fbdc ==_cdfag {_gagdf =_afaf .Data [_ffdg ]<<_gfaga ;if _eadb {_gagdf =_bfgd (_gagdf ,_afaf .Data [_ffdg +1]>>_abagb ,_cfdc );
};}else {_gagdf =_afaf .Data [_ffdg ]>>_abagb ;};_bgec .Data [_bbda ]=_bfgd (_bgec .Data [_bbda ],^(_gagdf &_bgec .Data [_bbda ]),_dbdbd );_bbda +=_bgec .BytesPerLine ;_ffdg +=_afaf .BytesPerLine ;};};if _bgfca {for _dgeg =0;_dgeg < _afcff ;_dgeg ++{for _bdff =0;
_bdff < _dbcd ;_bdff ++{_gagdf =_bfgd (_afaf .Data [_egfe +_bdff ]<<_gfaga ,_afaf .Data [_egfe +_bdff +1]>>_abagb ,_cfdc );_bgec .Data [_decde +_bdff ]=^(_gagdf &_bgec .Data [_decde +_bdff ]);};_decde +=_bgec .BytesPerLine ;_egfe +=_afaf .BytesPerLine ;
};};if _eggg {for _dgeg =0;_dgeg < _afcff ;_dgeg ++{_gagdf =_afaf .Data [_facc ]<<_gfaga ;if _dacg {_gagdf =_bfgd (_gagdf ,_afaf .Data [_facc +1]>>_abagb ,_cfdc );};_bgec .Data [_cfdbg ]=_bfgd (_bgec .Data [_cfdbg ],^(_gagdf &_bgec .Data [_cfdbg ]),_cadg );
_cfdbg +=_bgec .BytesPerLine ;_facc +=_afaf .BytesPerLine ;};};case PixNotPixSrcXorDst :if _bff {for _dgeg =0;_dgeg < _afcff ;_dgeg ++{if _fbdc ==_cdfag {_gagdf =_afaf .Data [_ffdg ]<<_gfaga ;if _eadb {_gagdf =_bfgd (_gagdf ,_afaf .Data [_ffdg +1]>>_abagb ,_cfdc );
};}else {_gagdf =_afaf .Data [_ffdg ]>>_abagb ;};_bgec .Data [_bbda ]=_bfgd (_bgec .Data [_bbda ],^(_gagdf ^_bgec .Data [_bbda ]),_dbdbd );_bbda +=_bgec .BytesPerLine ;_ffdg +=_afaf .BytesPerLine ;};};if _bgfca {for _dgeg =0;_dgeg < _afcff ;_dgeg ++{for _bdff =0;
_bdff < _dbcd ;_bdff ++{_gagdf =_bfgd (_afaf .Data [_egfe +_bdff ]<<_gfaga ,_afaf .Data [_egfe +_bdff +1]>>_abagb ,_cfdc );_bgec .Data [_decde +_bdff ]=^(_gagdf ^_bgec .Data [_decde +_bdff ]);};_decde +=_bgec .BytesPerLine ;_egfe +=_afaf .BytesPerLine ;
};};if _eggg {for _dgeg =0;_dgeg < _afcff ;_dgeg ++{_gagdf =_afaf .Data [_facc ]<<_gfaga ;if _dacg {_gagdf =_bfgd (_gagdf ,_afaf .Data [_facc +1]>>_abagb ,_cfdc );};_bgec .Data [_cfdbg ]=_bfgd (_bgec .Data [_cfdbg ],^(_gagdf ^_bgec .Data [_cfdbg ]),_cadg );
_cfdbg +=_bgec .BytesPerLine ;_facc +=_afaf .BytesPerLine ;};};default:_cg .Log .Debug ("\u004f\u0070e\u0072\u0061\u0074\u0069\u006f\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006e\u006f\u0074\u0020\u0070\u0065\u0072\u006d\u0069tt\u0065\u0064",_bfda );
return _f .New ("\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065r\u0061\u0074\u0069\u006f\u006e\u0020\u006eo\u0074\u0020\u0070\u0065\u0072\u006d\u0069\u0074\u0074\u0065\u0064");};return nil ;};func AddDataPadding (width ,height ,bitsPerComponent ,colorComponents int ,data []byte )([]byte ,error ){_gfe :=BytesPerLine (width ,bitsPerComponent ,colorComponents );
if _gfe ==width *colorComponents *bitsPerComponent /8{return data ,nil ;};_abca :=width *colorComponents *bitsPerComponent ;_effgg :=_gfe *8;_fgeb :=8-(_effgg -_abca );_gecgd :=_b .NewReader (data );_fbbb :=_gfe -1;_egae :=make ([]byte ,_fbbb );_dcaa :=make ([]byte ,height *_gfe );
_fdgaa :=_b .NewWriterMSB (_dcaa );var _gefg uint64 ;var _cbcc error ;for _ddab :=0;_ddab < height ;_ddab ++{_ ,_cbcc =_gecgd .Read (_egae );if _cbcc !=nil {return nil ,_cbcc ;};_ ,_cbcc =_fdgaa .Write (_egae );if _cbcc !=nil {return nil ,_cbcc ;};_gefg ,_cbcc =_gecgd .ReadBits (byte (_fgeb ));
if _cbcc !=nil {return nil ,_cbcc ;};_ ,_cbcc =_fdgaa .WriteBits (_gefg ,_fgeb );if _cbcc !=nil {return nil ,_cbcc ;};_fdgaa .FinishByte ();};return _dcaa ,nil ;};func (_deed *Gray8 )ColorModel ()_dc .Model {return _dc .GrayModel };func (_dbcdd *NRGBA32 )ColorAt (x ,y int )(_dc .Color ,error ){return ColorAtNRGBA32 (x ,y ,_dbcdd .Width ,_dbcdd .Data ,_dbcdd .Alpha ,_dbcdd .Decode );
};func _cgaa (_egfd _dc .NRGBA64 )_dc .NRGBA {return _dc .NRGBA {R :uint8 (_egfd .R >>8),G :uint8 (_egfd .G >>8),B :uint8 (_egfd .B >>8),A :uint8 (_egfd .A >>8)};};func (_cafc *Gray16 )Copy ()Image {return &Gray16 {ImageBase :_cafc .copy ()}};func InDelta (expected ,current ,delta float64 )bool {_bgfee :=expected -current ;
if _bgfee <=-delta ||_bgfee >=delta {return false ;};return true ;};func (_ffdcd *Gray16 )At (x ,y int )_dc .Color {_ggcdg ,_ :=_ffdcd .ColorAt (x ,y );return _ggcdg };func _aac (_feg *Monochrome ,_ec ...int )(_aec *Monochrome ,_cbc error ){if _feg ==nil {return nil ,_f .New ("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d");
};if len (_ec )==0{return nil ,_f .New ("\u0074h\u0065\u0072e\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0061\u0074 \u006c\u0065\u0061\u0073\u0074\u0020o\u006e\u0065\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u006f\u0066 \u0072\u0065\u0064\u0075\u0063\u0074\u0069\u006f\u006e");
};_dcf :=_ddae ();_aec =_feg ;for _ ,_ba :=range _ec {if _ba <=0{break ;};_aec ,_cbc =_ega (_aec ,_ba ,_dcf );if _cbc !=nil {return nil ,_cbc ;};};return _aec ,nil ;};func (_egbb *ImageBase )copy ()ImageBase {_gdeda :=*_egbb ;_gdeda .Data =make ([]byte ,len (_egbb .Data ));
copy (_gdeda .Data ,_egbb .Data );return _gdeda ;};func _dbgd (_gcgc _dc .Color )_dc .Color {_agcg :=_dc .GrayModel .Convert (_gcgc ).(_dc .Gray );return _cge (_agcg );};func (_dcab *Monochrome )AddPadding ()(_fdb error ){if _ege :=((_dcab .Width *_dcab .Height )+7)>>3;
len (_dcab .Data )< _ege {return _de .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064a\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002e\u0020\u0054\u0068\u0065\u0020\u0064\u0061t\u0061\u0020s\u0068\u006fu\u006c\u0064\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0020\u0061\u0074 l\u0065\u0061\u0073\u0074\u003a\u0020\u0027\u0025\u0064'\u0020\u0062\u0079\u0074\u0065\u0073",len (_dcab .Data ),_ege );
};_dgdc :=_dcab .Width %8;if _dgdc ==0{return nil ;};_fbgea :=_dcab .Width /8;_ecgg :=_b .NewReader (_dcab .Data );_ccag :=make ([]byte ,_dcab .Height *_dcab .BytesPerLine );_efdb :=_b .NewWriterMSB (_ccag );_bega :=make ([]byte ,_fbgea );var (_fdaf int ;
_cbg uint64 ;);for _fdaf =0;_fdaf < _dcab .Height ;_fdaf ++{if _ ,_fdb =_ecgg .Read (_bega );_fdb !=nil {return _fdb ;};if _ ,_fdb =_efdb .Write (_bega );_fdb !=nil {return _fdb ;};if _cbg ,_fdb =_ecgg .ReadBits (byte (_dgdc ));_fdb !=nil {return _fdb ;
};if _fdb =_efdb .WriteByte (byte (_cbg )<<uint (8-_dgdc ));_fdb !=nil {return _fdb ;};};_dcab .Data =_efdb .Data ();return nil ;};func (_fcgd *Gray8 )At (x ,y int )_dc .Color {_ebc ,_ :=_fcgd .ColorAt (x ,y );return _ebc };func (_agab *Monochrome )Copy ()Image {return &Monochrome {ImageBase :_agab .ImageBase .copy (),ModelThreshold :_agab .ModelThreshold };
};func (_fcb *Monochrome )copy ()*Monochrome {_gddd :=_bec (_fcb .Width ,_fcb .Height );_gddd .ModelThreshold =_fcb .ModelThreshold ;_gddd .Data =make ([]byte ,len (_fcb .Data ));copy (_gddd .Data ,_fcb .Data );if len (_fcb .Decode )!=0{_gddd .Decode =make ([]float64 ,len (_fcb .Decode ));
copy (_gddd .Decode ,_fcb .Decode );};if len (_fcb .Alpha )!=0{_gddd .Alpha =make ([]byte ,len (_fcb .Alpha ));copy (_gddd .Alpha ,_fcb .Alpha );};return _gddd ;};func (_gbgf *NRGBA64 )Copy ()Image {return &NRGBA64 {ImageBase :_gbgf .copy ()}};func IsPowerOf2 (n uint )bool {return n > 0&&(n &(n -1))==0};
func (_bfad *Monochrome )SetGray (x ,y int ,g _dc .Gray ){_gca :=y *_bfad .BytesPerLine +x >>3;if _gca > len (_bfad .Data )-1{return ;};g =_agcc (g ,monochromeModel (_bfad .ModelThreshold ));_bfad .setGray (x ,g ,_gca );};type Gray interface{GrayAt (_ffeg ,_edcg int )_dc .Gray ;
SetGray (_dgbb ,_bcb int ,_bfbg _dc .Gray );};func (_bdfg *NRGBA32 )Set (x ,y int ,c _dc .Color ){_ggfe :=y *_bdfg .Width +x ;_gbgg :=3*_ggfe ;if _gbgg +2>=len (_bdfg .Data ){return ;};_fcgge :=_dc .NRGBAModel .Convert (c ).(_dc .NRGBA );_bdfg .setRGBA (_ggfe ,_fcgge );
};func (_efc *Monochrome )Validate ()error {if len (_efc .Data )!=_efc .Height *_efc .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_bdebd *NRGBA32 )NRGBAAt (x ,y int )_dc .NRGBA {_eegbd ,_ :=ColorAtNRGBA32 (x ,y ,_bdebd .Width ,_bdebd .Data ,_bdebd .Alpha ,_bdebd .Decode );
return _eegbd ;};const (PixSrc RasterOperator =0xc;PixDst RasterOperator =0xa;PixNotSrc RasterOperator =0x3;PixNotDst RasterOperator =0x5;PixClr RasterOperator =0x0;PixSet RasterOperator =0xf;PixSrcOrDst RasterOperator =0xe;PixSrcAndDst RasterOperator =0x8;
PixSrcXorDst RasterOperator =0x6;PixNotSrcOrDst RasterOperator =0xb;PixNotSrcAndDst RasterOperator =0x2;PixSrcOrNotDst RasterOperator =0xd;PixSrcAndNotDst RasterOperator =0x4;PixNotPixSrcOrDst RasterOperator =0x1;PixNotPixSrcAndDst RasterOperator =0x7;
PixNotPixSrcXorDst RasterOperator =0x9;PixPaint =PixSrcOrDst ;PixSubtract =PixNotSrcAndDst ;PixMask =PixSrcAndDst ;);func ImgToGray (i _e .Image )*_e .Gray {if _fcaf ,_gdgc :=i .(*_e .Gray );_gdgc {return _fcaf ;};_eecf :=i .Bounds ();_ddbf :=_e .NewGray (_eecf );
for _aegc :=0;_aegc < _eecf .Max .X ;_aegc ++{for _fgga :=0;_fgga < _eecf .Max .Y ;_fgga ++{_afea :=i .At (_aegc ,_fgga );_ddbf .Set (_aegc ,_fgga ,_afea );};};return _ddbf ;};func (_dagf *Monochrome )Base ()*ImageBase {return &_dagf .ImageBase };func (_ffage *NRGBA64 )NRGBA64At (x ,y int )_dc .NRGBA64 {_cdbb ,_ :=ColorAtNRGBA64 (x ,y ,_ffage .Width ,_ffage .Data ,_ffage .Alpha ,_ffage .Decode );
return _cdbb ;};func (_agcd *Gray2 )Bounds ()_e .Rectangle {return _e .Rectangle {Max :_e .Point {X :_agcd .Width ,Y :_agcd .Height }};};func (_abgb *Gray4 )setGray (_eeba int ,_gdeb int ,_gbb _dc .Gray ){_bggf :=_gdeb *_abgb .BytesPerLine ;_abdb :=_bggf +(_eeba >>1);
if _abdb >=len (_abgb .Data ){return ;};_bfbc :=_gbb .Y >>4;_abgb .Data [_abdb ]=(_abgb .Data [_abdb ]&(^(0xf0>>uint (4*(_eeba &1)))))|(_bfbc <<uint (4-4*(_eeba &1)));};func _ddfac (_acbe []byte ,_beeb Image )error {_gcbc :=true ;for _baecb :=0;_baecb < len (_acbe );
_baecb ++{if _acbe [_baecb ]!=0xff{_gcbc =false ;break ;};};if _gcbc {switch _efaa :=_beeb .(type ){case *NRGBA32 :_efaa .Alpha =nil ;case *NRGBA64 :_efaa .Alpha =nil ;default:return _de .Errorf ("i\u006ete\u0072n\u0061l\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020i\u006d\u0061\u0067\u0065\u0020s\u0068\u006f\u0075l\u0064\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0074\u0079\u0070e\u0020\u002a\u004eRGB\u0041\u0033\u0032\u0020\u006f\u0072 \u002a\u004e\u0052\u0047\u0042\u0041\u0036\u0034\u0020\u0062\u0075\u0074 \u0069s\u003a\u0020\u0025\u0054",_beeb );
};};return nil ;};func (_bcdg *Gray4 )Copy ()Image {return &Gray4 {ImageBase :_bcdg .copy ()}};func _eaaa (_aagc _e .Image ,_ddcf int )(_e .Rectangle ,bool ,[]byte ){_ddda :=_aagc .Bounds ();var (_agdb bool ;_eaea []byte ;);switch _gedeb :=_aagc .(type ){case SMasker :_agdb =_gedeb .HasAlpha ();
case NRGBA ,RGBA ,*_e .RGBA64 ,nrgba64 ,*_e .NYCbCrA :_eaea =make ([]byte ,_ddda .Max .X *_ddda .Max .Y *_ddcf );case *_e .Paletted :var _gace bool ;for _ ,_dcgb :=range _gedeb .Palette {_bced ,_bffd ,_dagda ,_bgae :=_dcgb .RGBA ();if _bced ==0&&_bffd ==0&&_dagda ==0&&_bgae !=0{_gace =true ;
break ;};};if _gace {_eaea =make ([]byte ,_ddda .Max .X *_ddda .Max .Y *_ddcf );};};return _ddda ,_agdb ,_eaea ;};func (_fdaae *NRGBA64 )Bounds ()_e .Rectangle {return _e .Rectangle {Max :_e .Point {X :_fdaae .Width ,Y :_fdaae .Height }};};func ColorAtCMYK (x ,y ,width int ,data []byte ,decode []float64 )(_dc .CMYK ,error ){_ccg :=4*(y *width +x );
if _ccg +3>=len (data ){return _dc .CMYK {},_de .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};C :=data [_ccg ]&0xff;M :=data [_ccg +1]&0xff;Y :=data [_ccg +2]&0xff;K :=data [_ccg +3]&0xff;if len (decode )==8{C =uint8 (uint32 (LinearInterpolate (float64 (C ),0,255,decode [0],decode [1]))&0xff);M =uint8 (uint32 (LinearInterpolate (float64 (M ),0,255,decode [2],decode [3]))&0xff);
Y =uint8 (uint32 (LinearInterpolate (float64 (Y ),0,255,decode [4],decode [5]))&0xff);K =uint8 (uint32 (LinearInterpolate (float64 (K ),0,255,decode [6],decode [7]))&0xff);};return _dc .CMYK {C :C ,M :M ,Y :Y ,K :K },nil ;};func (_fge *CMYK32 )Set (x ,y int ,c _dc .Color ){_eccg :=4*(y *_fge .Width +x );
if _eccg +3>=len (_fge .Data ){return ;};_age :=_dc .CMYKModel .Convert (c ).(_dc .CMYK );_fge .Data [_eccg ]=_age .C ;_fge .Data [_eccg +1]=_age .M ;_fge .Data [_eccg +2]=_age .Y ;_fge .Data [_eccg +3]=_age .K ;};var _ Image =&CMYK32 {};func (_fgd *Gray8 )Copy ()Image {return &Gray8 {ImageBase :_fgd .copy ()}};
func _cdab (_gecc RGBA ,_ddgb NRGBA ,_aaga _e .Rectangle ){for _bead :=0;_bead < _aaga .Max .X ;_bead ++{for _efee :=0;_efee < _aaga .Max .Y ;_efee ++{_gcdd :=_gecc .RGBAAt (_bead ,_efee );_ddgb .SetNRGBA (_bead ,_efee ,_cgc (_gcdd ));};};};func (_aaebg *NRGBA32 )Base ()*ImageBase {return &_aaebg .ImageBase };
type CMYK interface{CMYKAt (_ca ,_cgg int )_dc .CMYK ;SetCMYK (_gaab ,_gad int ,_dbe _dc .CMYK );};func (_ffdf *Gray4 )Histogram ()(_bdbg [256]int ){for _ece :=0;_ece < _ffdf .Width ;_ece ++{for _fdcac :=0;_fdcac < _ffdf .Height ;_fdcac ++{_bdbg [_ffdf .GrayAt (_ece ,_fdcac ).Y ]++;
};};return _bdbg ;};func (_cdb *Gray4 )GrayAt (x ,y int )_dc .Gray {_efdf ,_ :=ColorAtGray4BPC (x ,y ,_cdb .BytesPerLine ,_cdb .Data ,_cdb .Decode );return _efdf ;};func _gab (_ebbd _dc .CMYK )_dc .NRGBA {_faf ,_faa ,_cbf :=_dc .CMYKToRGB (_ebbd .C ,_ebbd .M ,_ebbd .Y ,_ebbd .K );
return _dc .NRGBA {R :_faf ,G :_faa ,B :_cbf ,A :0xff};};func (_eefd *Monochrome )ExpandBinary (factor int )(*Monochrome ,error ){if !IsPowerOf2 (uint (factor )){return nil ,_de .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0065\u0078\u0070\u0061\u006e\u0064\u0020b\u0069n\u0061\u0072\u0079\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",factor );
};return _ad (_eefd ,factor );};func _gdfa (_dcbdg ,_cbfd uint8 )uint8 {if _dcbdg < _cbfd {return 255;};return 0;};func (_gcb *NRGBA16 )Set (x ,y int ,c _dc .Color ){_cega :=y *_gcb .BytesPerLine +x *3/2;if _cega +1>=len (_gcb .Data ){return ;};_dgfg :=NRGBA16Model .Convert (c ).(_dc .NRGBA );
_gcb .setNRGBA (x ,y ,_cega ,_dgfg );};func (_gccd *NRGBA32 )ColorModel ()_dc .Model {return _dc .NRGBAModel };func BytesPerLine (width ,bitsPerComponent ,colorComponents int )int {return ((width *bitsPerComponent )*colorComponents +7)>>3;};func (_bca *Monochrome )Set (x ,y int ,c _dc .Color ){_bcc :=y *_bca .BytesPerLine +x >>3;
if _bcc > len (_bca .Data )-1{return ;};_gcfd :=_bca .ColorModel ().Convert (c ).(_dc .Gray );_bca .setGray (x ,_gcfd ,_bcc );};func ImgToBinary (i _e .Image ,threshold uint8 )*_e .Gray {switch _gedeg :=i .(type ){case *_e .Gray :if _gcfdb (_gedeg ){return _gedeg ;
};return _afafa (_gedeg ,threshold );case *_e .Gray16 :return _gcag (_gedeg ,threshold );default:return _fccdd (_gedeg ,threshold );};};func _bfgd (_bacg ,_aagf ,_adec byte )byte {return (_bacg &^(_adec ))|(_aagf &_adec )};func ColorAt (x ,y ,width ,bitsPerColor ,colorComponents ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_dc .Color ,error ){switch colorComponents {case 1:return ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine ,data ,decode );
case 3:return ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor ,data ,alpha ,decode );case 4:return ColorAtCMYK (x ,y ,width ,data ,decode );default:return nil ,_de .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0063o\u006c\u006f\u0072\u0020\u0063\u006f\u006dp\u006f\u006e\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0064",colorComponents );
};};func (_dcea *Gray2 )Base ()*ImageBase {return &_dcea .ImageBase };func _aea ()(_egf [256]uint16 ){for _dff :=0;_dff < 256;_dff ++{if _dff &0x01!=0{_egf [_dff ]|=0x3;};if _dff &0x02!=0{_egf [_dff ]|=0xc;};if _dff &0x04!=0{_egf [_dff ]|=0x30;};if _dff &0x08!=0{_egf [_dff ]|=0xc0;
};if _dff &0x10!=0{_egf [_dff ]|=0x300;};if _dff &0x20!=0{_egf [_dff ]|=0xc00;};if _dff &0x40!=0{_egf [_dff ]|=0x3000;};if _dff &0x80!=0{_egf [_dff ]|=0xc000;};};return _egf ;};func _gaad (_dee int )[]uint {var _aa []uint ;_cfgba :=_dee ;_acb :=_cfgba /8;
if _acb !=0{for _dfc :=0;_dfc < _acb ;_dfc ++{_aa =append (_aa ,8);};_ab :=_cfgba %8;_cfgba =0;if _ab !=0{_cfgba =_ab ;};};_fcge :=_cfgba /4;if _fcge !=0{for _bce :=0;_bce < _fcge ;_bce ++{_aa =append (_aa ,4);};_gag :=_cfgba %4;_cfgba =0;if _gag !=0{_cfgba =_gag ;
};};_cfgg :=_cfgba /2;if _cfgg !=0{for _bgb :=0;_bgb < _cfgg ;_bgb ++{_aa =append (_aa ,2);};};return _aa ;};type Image interface{_ff .Image ;Base ()*ImageBase ;Copy ()Image ;Pix ()[]byte ;ColorAt (_ecffe ,_ddgg int )(_dc .Color ,error );Validate ()error ;
};func _gaed (_gabe CMYK ,_eabf NRGBA ,_dcfb _e .Rectangle ){for _eggec :=0;_eggec < _dcfb .Max .X ;_eggec ++{for _aadda :=0;_aadda < _dcfb .Max .Y ;_aadda ++{_ccgg :=_gabe .CMYKAt (_eggec ,_aadda );_eabf .SetNRGBA (_eggec ,_aadda ,_gab (_ccgg ));};};};
func (_gbfg *NRGBA32 )Validate ()error {if len (_gbfg .Data )!=3*_gbfg .Width *_gbfg .Height {return _f .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func _abad (_bfbee uint )uint {var _affc uint ;for _bfbee !=0{_bfbee >>=1;_affc ++;};return _affc -1;};func (_fdaa *ImageBase )HasAlpha ()bool {if _fdaa .Alpha ==nil {return false ;};for _aegg :=range _fdaa .Alpha {if _fdaa .Alpha [_aegg ]!=0xff{return true ;
};};return false ;};func GetConverter (bitsPerComponent ,colorComponents int )(ColorConverter ,error ){switch colorComponents {case 1:switch bitsPerComponent {case 1:return MonochromeConverter ,nil ;case 2:return Gray2Converter ,nil ;case 4:return Gray4Converter ,nil ;
case 8:return GrayConverter ,nil ;case 16:return Gray16Converter ,nil ;};case 3:switch bitsPerComponent {case 4:return NRGBA16Converter ,nil ;case 8:return NRGBAConverter ,nil ;case 16:return NRGBA64Converter ,nil ;};case 4:return CMYKConverter ,nil ;};
return nil ,_de .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0043o\u006e\u0076\u0065\u0072\u0074\u0065\u0072\u0020\u0070\u0061\u0072\u0061\u006d\u0065t\u0065\u0072\u0073\u002e\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003a\u0020\u0025\u0064\u002c\u0020\u0043\u006f\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006et\u0073\u003a \u0025\u0064",bitsPerComponent ,colorComponents );
};func _ecef (_bcdb _e .Image )(Image ,error ){if _gaca ,_dbef :=_bcdb .(*Gray16 );_dbef {return _gaca .Copy (),nil ;};_gfge :=_bcdb .Bounds ();_efb ,_affee :=NewImage (_gfge .Max .X ,_gfge .Max .Y ,16,1,nil ,nil ,nil );if _affee !=nil {return nil ,_affee ;
};_aedd (_bcdb ,_efb ,_gfge );return _efb ,nil ;};func _ecefg (_adbb _e .Image )(Image ,error ){if _dabc ,_adbag :=_adbb .(*NRGBA16 );_adbag {return _dabc .Copy (),nil ;};_adabg :=_adbb .Bounds ();_ecab ,_acgc :=NewImage (_adabg .Max .X ,_adabg .Max .Y ,4,3,nil ,nil ,nil );
if _acgc !=nil {return nil ,_acgc ;};_gdgd (_adbb ,_ecab ,_adabg );return _ecab ,nil ;};func _adcf (_ecdb *_e .NYCbCrA ,_dfbb NRGBA ,_edba _e .Rectangle ){for _gcdc :=0;_gcdc < _edba .Max .X ;_gcdc ++{for _gdbd :=0;_gdbd < _edba .Max .Y ;_gdbd ++{_bdga :=_ecdb .NYCbCrAAt (_gcdc ,_gdbd );
_dfbb .SetNRGBA (_gcdc ,_gdbd ,_ggffd (_bdga ));};};};var _ Image =&NRGBA64 {};func _bfd (_fabg _e .Image ,_agf Image ,_beg _e .Rectangle ){for _dfcb :=0;_dfcb < _beg .Max .X ;_dfcb ++{for _eef :=0;_eef < _beg .Max .Y ;_eef ++{_eeg :=_fabg .At (_dfcb ,_eef );
_agf .Set (_dfcb ,_eef ,_eeg );};};};type SMasker interface{HasAlpha ()bool ;GetAlpha ()[]byte ;MakeAlpha ();};func _gfac (_gfbd _dc .Gray )_dc .Gray {_ebgd :=_gfbd .Y >>6;_ebgd |=_ebgd <<2;_gfbd .Y =_ebgd |_ebgd <<4;return _gfbd ;};func (_aca *NRGBA64 )Base ()*ImageBase {return &_aca .ImageBase };
func _dge (_agd _dc .NRGBA64 )_dc .Gray {var _cee _dc .NRGBA64 ;if _agd ==_cee {return _dc .Gray {Y :0xff};};_dbfd ,_aede ,_beaa ,_ :=_agd .RGBA ();_agc :=(19595*_dbfd +38470*_aede +7471*_beaa +1<<15)>>24;return _dc .Gray {Y :uint8 (_agc )};};func _afafa (_bdae *_e .Gray ,_fbbe uint8 )*_e .Gray {_bbeg :=_bdae .Bounds ();
_cbd :=_e .NewGray (_bbeg );for _aecg :=0;_aecg < _bbeg .Dx ();_aecg ++{for _faaac :=0;_faaac < _bbeg .Dy ();_faaac ++{_gff :=_bdae .GrayAt (_aecg ,_faaac );_cbd .SetGray (_aecg ,_faaac ,_dc .Gray {Y :_gdfa (_gff .Y ,_fbbe )});};};return _cbd ;};func _ee ()(_gb [256]uint64 ){for _dece :=0;
_dece < 256;_dece ++{if _dece &0x01!=0{_gb [_dece ]|=0xff;};if _dece &0x02!=0{_gb [_dece ]|=0xff00;};if _dece &0x04!=0{_gb [_dece ]|=0xff0000;};if _dece &0x08!=0{_gb [_dece ]|=0xff000000;};if _dece &0x10!=0{_gb [_dece ]|=0xff00000000;};if _dece &0x20!=0{_gb [_dece ]|=0xff0000000000;
};if _dece &0x40!=0{_gb [_dece ]|=0xff000000000000;};if _dece &0x80!=0{_gb [_dece ]|=0xff00000000000000;};};return _gb ;};var (_aeag =[]byte {0x00,0x80,0xC0,0xE0,0xF0,0xF8,0xFC,0xFE,0xFF};_cgcg =[]byte {0x00,0x01,0x03,0x07,0x0F,0x1F,0x3F,0x7F,0xFF};);var _ NRGBA =&NRGBA32 {};
var _ Image =&NRGBA32 {};func (_dfee *Gray16 )Validate ()error {if len (_dfee .Data )!=_dfee .Height *_dfee .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_fgbd *Gray16 )GrayAt (x ,y int )_dc .Gray {_bbd ,_ :=_fgbd .ColorAt (x ,y );return _dc .Gray {Y :uint8 (_bbd .(_dc .Gray16 ).Y >>8)};
};func ColorAtNRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_dc .NRGBA ,error ){_beee :=y *width +x ;_def :=3*_beee ;if _def +2>=len (data ){return _dc .NRGBA {},_de .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_aade :=uint8 (0xff);if alpha !=nil &&len (alpha )> _beee {_aade =alpha [_beee ];};_bdag ,_geeb ,_ggda :=data [_def ],data [_def +1],data [_def +2];if len (decode )==6{_bdag =uint8 (uint32 (LinearInterpolate (float64 (_bdag ),0,255,decode [0],decode [1]))&0xff);
_geeb =uint8 (uint32 (LinearInterpolate (float64 (_geeb ),0,255,decode [2],decode [3]))&0xff);_ggda =uint8 (uint32 (LinearInterpolate (float64 (_ggda ),0,255,decode [4],decode [5]))&0xff);};return _dc .NRGBA {R :_bdag ,G :_geeb ,B :_ggda ,A :_aade },nil ;
};func (_daaa *Gray2 )GrayAt (x ,y int )_dc .Gray {_fbff ,_ :=ColorAtGray2BPC (x ,y ,_daaa .BytesPerLine ,_daaa .Data ,_daaa .Decode );return _fbff ;};func (_bbga *CMYK32 )Base ()*ImageBase {return &_bbga .ImageBase };func (_bcbge *NRGBA16 )At (x ,y int )_dc .Color {_eac ,_ :=_bcbge .ColorAt (x ,y );
return _eac };func _decb (_gbda uint8 )bool {if _gbda ==0||_gbda ==255{return true ;};return false ;};var _ Image =&Gray2 {};type ImageBase struct{Width ,Height int ;BitsPerComponent ,ColorComponents int ;Data ,Alpha []byte ;Decode []float64 ;BytesPerLine int ;
};func RasterOperation (dest *Monochrome ,dx ,dy ,dw ,dh int ,op RasterOperator ,src *Monochrome ,sx ,sy int )error {return _dcac (dest ,dx ,dy ,dw ,dh ,op ,src ,sx ,sy );};func (_cdea *ImageBase )setFourBytes (_edbc int ,_gaaa uint32 )error {if _edbc +3> len (_cdea .Data )-1{return _de .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006fu\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065",_edbc );
};_cdea .Data [_edbc ]=byte ((_gaaa &0xff000000)>>24);_cdea .Data [_edbc +1]=byte ((_gaaa &0xff0000)>>16);_cdea .Data [_edbc +2]=byte ((_gaaa &0xff00)>>8);_cdea .Data [_edbc +3]=byte (_gaaa &0xff);return nil ;};func (_dgadf *Monochrome )setGrayBit (_ccef ,_gcac int ){_dgadf .Data [_ccef ]|=0x80>>uint (_gcac &7)};
func _bdc (_aed _dc .NRGBA )_dc .Gray {_dcb ,_geab ,_fadd ,_ :=_aed .RGBA ();_fda :=(19595*_dcb +38470*_geab +7471*_fadd +1<<15)>>24;return _dc .Gray {Y :uint8 (_fda )};};func _fccdd (_gdfe _e .Image ,_adcd uint8 )*_e .Gray {_gdge :=_gdfe .Bounds ();_gbdee :=_e .NewGray (_gdge );
var (_beae _dc .Color ;_cfge _dc .Gray ;);for _gbeg :=0;_gbeg < _gdge .Max .X ;_gbeg ++{for _ceff :=0;_ceff < _gdge .Max .Y ;_ceff ++{_beae =_gdfe .At (_gbeg ,_ceff );_gbdee .Set (_gbeg ,_ceff ,_beae );_cfge =_gbdee .GrayAt (_gbeg ,_ceff );_gbdee .SetGray (_gbeg ,_ceff ,_dc .Gray {Y :_gdfa (_cfge .Y ,_adcd )});
};};return _gbdee ;};const (_cdfag shift =iota ;_bbed ;);func (_bae *CMYK32 )Bounds ()_e .Rectangle {return _e .Rectangle {Max :_e .Point {X :_bae .Width ,Y :_bae .Height }};};func MonochromeThresholdConverter (threshold uint8 )ColorConverter {return &monochromeThresholdConverter {Threshold :threshold };
};func (_eca *CMYK32 )Validate ()error {if len (_eca .Data )!=4*_eca .Width *_eca .Height {return _f .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};var _ _e .Image =&NRGBA64 {};func _aedf (_aafa *Monochrome ,_bga ,_dgda ,_aaa ,_abeg int ,_face RasterOperator ,_adba *Monochrome ,_edfag ,_gbef int )error {var (_ddagb byte ;_dbeg int ;_ffdb int ;_decg ,_eegb int ;_fdcf ,_dafe int ;);_aad :=_aaa >>3;
_dbfc :=_aaa &7;if _dbfc > 0{_ddagb =_aeag [_dbfc ];};_dbeg =_adba .BytesPerLine *_gbef +(_edfag >>3);_ffdb =_aafa .BytesPerLine *_dgda +(_bga >>3);switch _face {case PixSrc :for _fdcf =0;_fdcf < _abeg ;_fdcf ++{_decg =_dbeg +_fdcf *_adba .BytesPerLine ;
_eegb =_ffdb +_fdcf *_aafa .BytesPerLine ;for _dafe =0;_dafe < _aad ;_dafe ++{_aafa .Data [_eegb ]=_adba .Data [_decg ];_eegb ++;_decg ++;};if _dbfc > 0{_aafa .Data [_eegb ]=_bfgd (_aafa .Data [_eegb ],_adba .Data [_decg ],_ddagb );};};case PixNotSrc :for _fdcf =0;
_fdcf < _abeg ;_fdcf ++{_decg =_dbeg +_fdcf *_adba .BytesPerLine ;_eegb =_ffdb +_fdcf *_aafa .BytesPerLine ;for _dafe =0;_dafe < _aad ;_dafe ++{_aafa .Data [_eegb ]=^(_adba .Data [_decg ]);_eegb ++;_decg ++;};if _dbfc > 0{_aafa .Data [_eegb ]=_bfgd (_aafa .Data [_eegb ],^_adba .Data [_decg ],_ddagb );
};};case PixSrcOrDst :for _fdcf =0;_fdcf < _abeg ;_fdcf ++{_decg =_dbeg +_fdcf *_adba .BytesPerLine ;_eegb =_ffdb +_fdcf *_aafa .BytesPerLine ;for _dafe =0;_dafe < _aad ;_dafe ++{_aafa .Data [_eegb ]|=_adba .Data [_decg ];_eegb ++;_decg ++;};if _dbfc > 0{_aafa .Data [_eegb ]=_bfgd (_aafa .Data [_eegb ],_adba .Data [_decg ]|_aafa .Data [_eegb ],_ddagb );
};};case PixSrcAndDst :for _fdcf =0;_fdcf < _abeg ;_fdcf ++{_decg =_dbeg +_fdcf *_adba .BytesPerLine ;_eegb =_ffdb +_fdcf *_aafa .BytesPerLine ;for _dafe =0;_dafe < _aad ;_dafe ++{_aafa .Data [_eegb ]&=_adba .Data [_decg ];_eegb ++;_decg ++;};if _dbfc > 0{_aafa .Data [_eegb ]=_bfgd (_aafa .Data [_eegb ],_adba .Data [_decg ]&_aafa .Data [_eegb ],_ddagb );
};};case PixSrcXorDst :for _fdcf =0;_fdcf < _abeg ;_fdcf ++{_decg =_dbeg +_fdcf *_adba .BytesPerLine ;_eegb =_ffdb +_fdcf *_aafa .BytesPerLine ;for _dafe =0;_dafe < _aad ;_dafe ++{_aafa .Data [_eegb ]^=_adba .Data [_decg ];_eegb ++;_decg ++;};if _dbfc > 0{_aafa .Data [_eegb ]=_bfgd (_aafa .Data [_eegb ],_adba .Data [_decg ]^_aafa .Data [_eegb ],_ddagb );
};};case PixNotSrcOrDst :for _fdcf =0;_fdcf < _abeg ;_fdcf ++{_decg =_dbeg +_fdcf *_adba .BytesPerLine ;_eegb =_ffdb +_fdcf *_aafa .BytesPerLine ;for _dafe =0;_dafe < _aad ;_dafe ++{_aafa .Data [_eegb ]|=^(_adba .Data [_decg ]);_eegb ++;_decg ++;};if _dbfc > 0{_aafa .Data [_eegb ]=_bfgd (_aafa .Data [_eegb ],^(_adba .Data [_decg ])|_aafa .Data [_eegb ],_ddagb );
};};case PixNotSrcAndDst :for _fdcf =0;_fdcf < _abeg ;_fdcf ++{_decg =_dbeg +_fdcf *_adba .BytesPerLine ;_eegb =_ffdb +_fdcf *_aafa .BytesPerLine ;for _dafe =0;_dafe < _aad ;_dafe ++{_aafa .Data [_eegb ]&=^(_adba .Data [_decg ]);_eegb ++;_decg ++;};if _dbfc > 0{_aafa .Data [_eegb ]=_bfgd (_aafa .Data [_eegb ],^(_adba .Data [_decg ])&_aafa .Data [_eegb ],_ddagb );
};};case PixSrcOrNotDst :for _fdcf =0;_fdcf < _abeg ;_fdcf ++{_decg =_dbeg +_fdcf *_adba .BytesPerLine ;_eegb =_ffdb +_fdcf *_aafa .BytesPerLine ;for _dafe =0;_dafe < _aad ;_dafe ++{_aafa .Data [_eegb ]=_adba .Data [_decg ]|^(_aafa .Data [_eegb ]);_eegb ++;
_decg ++;};if _dbfc > 0{_aafa .Data [_eegb ]=_bfgd (_aafa .Data [_eegb ],_adba .Data [_decg ]|^(_aafa .Data [_eegb ]),_ddagb );};};case PixSrcAndNotDst :for _fdcf =0;_fdcf < _abeg ;_fdcf ++{_decg =_dbeg +_fdcf *_adba .BytesPerLine ;_eegb =_ffdb +_fdcf *_aafa .BytesPerLine ;
for _dafe =0;_dafe < _aad ;_dafe ++{_aafa .Data [_eegb ]=_adba .Data [_decg ]&^(_aafa .Data [_eegb ]);_eegb ++;_decg ++;};if _dbfc > 0{_aafa .Data [_eegb ]=_bfgd (_aafa .Data [_eegb ],_adba .Data [_decg ]&^(_aafa .Data [_eegb ]),_ddagb );};};case PixNotPixSrcOrDst :for _fdcf =0;
_fdcf < _abeg ;_fdcf ++{_decg =_dbeg +_fdcf *_adba .BytesPerLine ;_eegb =_ffdb +_fdcf *_aafa .BytesPerLine ;for _dafe =0;_dafe < _aad ;_dafe ++{_aafa .Data [_eegb ]=^(_adba .Data [_decg ]|_aafa .Data [_eegb ]);_eegb ++;_decg ++;};if _dbfc > 0{_aafa .Data [_eegb ]=_bfgd (_aafa .Data [_eegb ],^(_adba .Data [_decg ]|_aafa .Data [_eegb ]),_ddagb );
};};case PixNotPixSrcAndDst :for _fdcf =0;_fdcf < _abeg ;_fdcf ++{_decg =_dbeg +_fdcf *_adba .BytesPerLine ;_eegb =_ffdb +_fdcf *_aafa .BytesPerLine ;for _dafe =0;_dafe < _aad ;_dafe ++{_aafa .Data [_eegb ]=^(_adba .Data [_decg ]&_aafa .Data [_eegb ]);
_eegb ++;_decg ++;};if _dbfc > 0{_aafa .Data [_eegb ]=_bfgd (_aafa .Data [_eegb ],^(_adba .Data [_decg ]&_aafa .Data [_eegb ]),_ddagb );};};case PixNotPixSrcXorDst :for _fdcf =0;_fdcf < _abeg ;_fdcf ++{_decg =_dbeg +_fdcf *_adba .BytesPerLine ;_eegb =_ffdb +_fdcf *_aafa .BytesPerLine ;
for _dafe =0;_dafe < _aad ;_dafe ++{_aafa .Data [_eegb ]=^(_adba .Data [_decg ]^_aafa .Data [_eegb ]);_eegb ++;_decg ++;};if _dbfc > 0{_aafa .Data [_eegb ]=_bfgd (_aafa .Data [_eegb ],^(_adba .Data [_decg ]^_aafa .Data [_eegb ]),_ddagb );};};default:_cg .Log .Debug ("\u0050\u0072ov\u0069\u0064\u0065d\u0020\u0069\u006e\u0076ali\u0064 r\u0061\u0073\u0074\u0065\u0072\u0020\u006fpe\u0072\u0061\u0074\u006f\u0072\u003a\u0020%\u0076",_face );
return _f .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072");};return nil ;};func (_dfa *CMYK32 )ColorModel ()_dc .Model {return _dc .CMYKModel };var _ _e .Image =&Gray16 {};
func _ega (_ede *Monochrome ,_gdf int ,_eda []byte )(_ffa *Monochrome ,_cbb error ){const _fgf ="\u0072\u0065d\u0075\u0063\u0065R\u0061\u006e\u006b\u0042\u0069\u006e\u0061\u0072\u0079";if _ede ==nil {return nil ,_f .New ("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d");
};if _gdf < 1||_gdf > 4{return nil ,_f .New ("\u006c\u0065\u0076\u0065\u006c\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020\u0073e\u0074\u0020\u007b\u0031\u002c\u0032\u002c\u0033\u002c\u0034\u007d");};if _ede .Height <=1{return nil ,_f .New ("\u0073\u006f\u0075rc\u0065\u0020\u0068\u0065\u0069\u0067\u0068\u0074\u0020m\u0075s\u0074 \u0062e\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020\u0027\u0032\u0027");
};_ffa =_bec (_ede .Width /2,_ede .Height /2);if _eda ==nil {_eda =_ddae ();};_aee :=_daee (_ede .BytesPerLine ,2*_ffa .BytesPerLine );switch _gdf {case 1:_cbb =_gdd (_ede ,_ffa ,_eda ,_aee );case 2:_cbb =_bfb (_ede ,_ffa ,_eda ,_aee );case 3:_cbb =_dbd (_ede ,_ffa ,_eda ,_aee );
case 4:_cbb =_cgd (_ede ,_ffa ,_eda ,_aee );};if _cbb !=nil {return nil ,_cbb ;};return _ffa ,nil ;};var (_dfb =_aea ();_ffb =_ceb ();_bgfe =_ee (););func AutoThresholdTriangle (histogram [256]int )uint8 {var _febc ,_ggfad ,_bfdec ,_fbe int ;for _gefgc :=0;
_gefgc < len (histogram );_gefgc ++{if histogram [_gefgc ]> 0{_febc =_gefgc ;break ;};};if _febc > 0{_febc --;};for _beag :=255;_beag > 0;_beag --{if histogram [_beag ]> 0{_fbe =_beag ;break ;};};if _fbe < 255{_fbe ++;};for _fggf :=0;_fggf < 256;_fggf ++{if histogram [_fggf ]> _ggfad {_bfdec =_fggf ;
_ggfad =histogram [_fggf ];};};var _cfag bool ;if (_bfdec -_febc )< (_fbe -_bfdec ){_cfag =true ;var _bcf int ;_ggaae :=255;for _bcf < _ggaae {_ecda :=histogram [_bcf ];histogram [_bcf ]=histogram [_ggaae ];histogram [_ggaae ]=_ecda ;_bcf ++;_ggaae --;
};_febc =255-_fbe ;_bfdec =255-_bfdec ;};if _febc ==_bfdec {return uint8 (_febc );};_afgdc :=float64 (histogram [_bfdec ]);_abab :=float64 (_febc -_bfdec );_adbac :=_d .Sqrt (_afgdc *_afgdc +_abab *_abab );_afgdc /=_adbac ;_abab /=_adbac ;_adbac =_afgdc *float64 (_febc )+_abab *float64 (histogram [_febc ]);
_fedeb :=_febc ;var _efcg float64 ;for _gbgge :=_febc +1;_gbgge <=_bfdec ;_gbgge ++{_egadd :=_afgdc *float64 (_gbgge )+_abab *float64 (histogram [_gbgge ])-_adbac ;if _egadd > _efcg {_fedeb =_gbgge ;_efcg =_egadd ;};};_fedeb --;if _cfag {var _fedc int ;
_adac :=255;for _fedc < _adac {_ebcf :=histogram [_fedc ];histogram [_fedc ]=histogram [_adac ];histogram [_adac ]=_ebcf ;_fedc ++;_adac --;};return uint8 (255-_fedeb );};return uint8 (_fedeb );};func _deaa (_fbc _dc .Color )_dc .Color {_bafe :=_dc .NRGBAModel .Convert (_fbc ).(_dc .NRGBA );
return _bagg (_bafe );};func (_cgca *Gray16 )Set (x ,y int ,c _dc .Color ){_eaac :=(y *_cgca .BytesPerLine /2+x )*2;if _eaac +1>=len (_cgca .Data ){return ;};_fcaa :=_dc .Gray16Model .Convert (c ).(_dc .Gray16 );_cgca .Data [_eaac ],_cgca .Data [_eaac +1]=uint8 (_fcaa .Y >>8),uint8 (_fcaa .Y &0xff);
};func _abagg (_aegb *Monochrome ,_adaa ,_gefc int ,_accf ,_afcd int ,_aecf RasterOperator ,_dbbga *Monochrome ,_ggfb ,_cfgac int )error {var _cfcb ,_fcfg ,_cbbf ,_cgcb int ;if _adaa < 0{_ggfb -=_adaa ;_accf +=_adaa ;_adaa =0;};if _ggfb < 0{_adaa -=_ggfb ;
_accf +=_ggfb ;_ggfb =0;};_cfcb =_adaa +_accf -_aegb .Width ;if _cfcb > 0{_accf -=_cfcb ;};_fcfg =_ggfb +_accf -_dbbga .Width ;if _fcfg > 0{_accf -=_fcfg ;};if _gefc < 0{_cfgac -=_gefc ;_afcd +=_gefc ;_gefc =0;};if _cfgac < 0{_gefc -=_cfgac ;_afcd +=_cfgac ;
_cfgac =0;};_cbbf =_gefc +_afcd -_aegb .Height ;if _cbbf > 0{_afcd -=_cbbf ;};_cgcb =_cfgac +_afcd -_dbbga .Height ;if _cgcb > 0{_afcd -=_cgcb ;};if _accf <=0||_afcd <=0{return nil ;};var _adf error ;switch {case _adaa &7==0&&_ggfb &7==0:_adf =_aedf (_aegb ,_adaa ,_gefc ,_accf ,_afcd ,_aecf ,_dbbga ,_ggfb ,_cfgac );
case _adaa &7==_ggfb &7:_adf =_gedd (_aegb ,_adaa ,_gefc ,_accf ,_afcd ,_aecf ,_dbbga ,_ggfb ,_cfgac );default:_adf =_cccde (_aegb ,_adaa ,_gefc ,_accf ,_afcd ,_aecf ,_dbbga ,_ggfb ,_cfgac );};if _adf !=nil {return _adf ;};return nil ;};func (_aafb *CMYK32 )At (x ,y int )_dc .Color {_gcf ,_ :=_aafb .ColorAt (x ,y );
return _gcf };func _fcfe (_ecbf _e .Image )(Image ,error ){if _fdga ,_fdgac :=_ecbf .(*Gray8 );_fdgac {return _fdga .Copy (),nil ;};_bbb :=_ecbf .Bounds ();_fafe ,_bbce :=NewImage (_bbb .Max .X ,_bbb .Max .Y ,8,1,nil ,nil ,nil );if _bbce !=nil {return nil ,_bbce ;
};_aedd (_ecbf ,_fafe ,_bbb );return _fafe ,nil ;};func _afbf (_bbac _dc .RGBA )_dc .CMYK {_bdf ,_baf ,_fbda ,_dggd :=_dc .RGBToCMYK (_bbac .R ,_bbac .G ,_bbac .B );return _dc .CMYK {C :_bdf ,M :_baf ,Y :_fbda ,K :_dggd };};func (_gfag *Gray16 )ColorAt (x ,y int )(_dc .Color ,error ){return ColorAtGray16BPC (x ,y ,_gfag .BytesPerLine ,_gfag .Data ,_gfag .Decode );
};func (_dgg *CMYK32 )SetCMYK (x ,y int ,c _dc .CMYK ){_bbge :=4*(y *_dgg .Width +x );if _bbge +3>=len (_dgg .Data ){return ;};_dgg .Data [_bbge ]=c .C ;_dgg .Data [_bbge +1]=c .M ;_dgg .Data [_bbge +2]=c .Y ;_dgg .Data [_bbge +3]=c .K ;};func (_gda *Monochrome )getBitAt (_dbbg ,_ffg int )bool {_bfbe :=_ffg *_gda .BytesPerLine +(_dbbg >>3);
_fcd :=_dbbg &0x07;_afbe :=uint (7-_fcd );if _bfbe > len (_gda .Data )-1{return false ;};if (_gda .Data [_bfbe ]>>_afbe )&0x01>=1{return true ;};return false ;};func (_edfb *ImageBase )setEightBytes (_dbfdag int ,_fcgf uint64 )error {_ddac :=_edfb .BytesPerLine -(_dbfdag %_edfb .BytesPerLine );
if _edfb .BytesPerLine !=_edfb .Width >>3{_ddac --;};if _ddac >=8{return _edfb .setEightFullBytes (_dbfdag ,_fcgf );};return _edfb .setEightPartlyBytes (_dbfdag ,_ddac ,_fcgf );};func _abcg (_aage _e .Image )(Image ,error ){if _caa ,_bgga :=_aage .(*Gray4 );
_bgga {return _caa .Copy (),nil ;};_gbeb :=_aage .Bounds ();_eag ,_dggc :=NewImage (_gbeb .Max .X ,_gbeb .Max .Y ,4,1,nil ,nil ,nil );if _dggc !=nil {return nil ,_dggc ;};_aedd (_aage ,_eag ,_gbeb );return _eag ,nil ;};func IsGrayImgBlackAndWhite (i *_e .Gray )bool {return _gcfdb (i )};
func (_bgff *NRGBA64 )setNRGBA64 (_geag int ,_fefbb _dc .NRGBA64 ,_bgac int ){_bgff .Data [_geag ]=uint8 (_fefbb .R >>8);_bgff .Data [_geag +1]=uint8 (_fefbb .R &0xff);_bgff .Data [_geag +2]=uint8 (_fefbb .G >>8);_bgff .Data [_geag +3]=uint8 (_fefbb .G &0xff);
_bgff .Data [_geag +4]=uint8 (_fefbb .B >>8);_bgff .Data [_geag +5]=uint8 (_fefbb .B &0xff);if _bgac +1< len (_bgff .Alpha ){_bgff .Alpha [_bgac ]=uint8 (_fefbb .A >>8);_bgff .Alpha [_bgac +1]=uint8 (_fefbb .A &0xff);};};func (_efag *ImageBase )getByte (_cdgc int )(byte ,error ){if _cdgc > len (_efag .Data )-1||_cdgc < 0{return 0,_de .Errorf ("\u0069\u006e\u0064\u0065x:\u0020\u0025\u0064\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006eg\u0065",_cdgc );
};return _efag .Data [_cdgc ],nil ;};func _gdgd (_affcd _e .Image ,_ddcca Image ,_abadf _e .Rectangle ){if _dgfb ,_aadd :=_affcd .(SMasker );_aadd &&_dgfb .HasAlpha (){_ddcca .(SMasker ).MakeAlpha ();};switch _bdfc :=_affcd .(type ){case Gray :_ccefg (_bdfc ,_ddcca .(NRGBA ),_abadf );
case NRGBA :_effe (_bdfc ,_ddcca .(NRGBA ),_abadf );case *_e .NYCbCrA :_adcf (_bdfc ,_ddcca .(NRGBA ),_abadf );case CMYK :_gaed (_bdfc ,_ddcca .(NRGBA ),_abadf );case RGBA :_cdab (_bdfc ,_ddcca .(NRGBA ),_abadf );case nrgba64 :_gddf (_bdfc ,_ddcca .(NRGBA ),_abadf );
default:_bfd (_affcd ,_ddcca ,_abadf );};};var _ Gray =&Gray2 {};func _ffefa (){for _fea :=0;_fea < 256;_fea ++{_dbgb [_fea ]=uint8 (_fea &0x1)+(uint8 (_fea >>1)&0x1)+(uint8 (_fea >>2)&0x1)+(uint8 (_fea >>3)&0x1)+(uint8 (_fea >>4)&0x1)+(uint8 (_fea >>5)&0x1)+(uint8 (_fea >>6)&0x1)+(uint8 (_fea >>7)&0x1);
};};func (_abbc *Gray8 )Validate ()error {if len (_abbc .Data )!=_abbc .Height *_abbc .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_affe monochromeModel )Convert (c _dc .Color )_dc .Color {_afa :=_dc .GrayModel .Convert (c ).(_dc .Gray );
return _agcc (_afa ,_affe );};func (_bfcg *Gray8 )Base ()*ImageBase {return &_bfcg .ImageBase };func _bec (_fbf ,_edec int )*Monochrome {return &Monochrome {ImageBase :NewImageBase (_fbf ,_edec ,1,1,nil ,nil ,nil ),ModelThreshold :0x0f};};func _bda (_efgcb Gray ,_bfde nrgba64 ,_bdad _e .Rectangle ){for _efd :=0;
_efd < _bdad .Max .X ;_efd ++{for _ggca :=0;_ggca < _bdad .Max .Y ;_ggca ++{_ecg :=_dge (_bfde .NRGBA64At (_efd ,_ggca ));_efgcb .SetGray (_efd ,_ggca ,_ecg );};};};func (_fbae *Gray16 )ColorModel ()_dc .Model {return _dc .Gray16Model };func _becfb (_egaf _e .Image )(Image ,error ){if _abac ,_gcge :=_egaf .(*NRGBA64 );
_gcge {return _abac .Copy (),nil ;};_fff ,_ebga ,_decc :=_eaaa (_egaf ,2);_cebe ,_cebf :=NewImage (_fff .Max .X ,_fff .Max .Y ,16,3,nil ,_decc ,nil );if _cebf !=nil {return nil ,_cebf ;};_fgdb (_egaf ,_cebe ,_fff );if len (_decc )!=0&&!_ebga {if _abaa :=_ddfac (_decc ,_cebe );
_abaa !=nil {return nil ,_abaa ;};};return _cebe ,nil ;};func NextPowerOf2 (n uint )uint {if IsPowerOf2 (n ){return n ;};return 1<<(_abad (n )+1);};func (_eddc *Monochrome )getBit (_gcc ,_fefe int )uint8 {return _eddc .Data [_gcc +(_fefe >>3)]>>uint (7-(_fefe &7))&1;
};