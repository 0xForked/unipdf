//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package imageutil ;import (_gg "encoding/binary";_g "errors";_eb "fmt";_fe "github.com/unidoc/unipdf/v3/common";_be "github.com/unidoc/unipdf/v3/internal/bitwise";_d "image";_gd "image/color";_e "image/draw";_f "math";);func (_ccac *Gray4 )ColorModel ()_gd .Model {return Gray4Model };
func (_geee *monochromeThresholdConverter )Convert (img _d .Image )(Image ,error ){if _dfcg ,_ffgc :=img .(*Monochrome );_ffgc {return _dfcg .Copy (),nil ;};_acda :=img .Bounds ();_fca ,_gcbc :=NewImage (_acda .Max .X ,_acda .Max .Y ,1,1,nil ,nil ,nil );
if _gcbc !=nil {return nil ,_gcbc ;};_fca .(*Monochrome ).ModelThreshold =_geee .Threshold ;for _ceec :=0;_ceec < _acda .Max .X ;_ceec ++{for _aeg :=0;_aeg < _acda .Max .Y ;_aeg ++{_fbcb :=img .At (_ceec ,_aeg );_fca .Set (_ceec ,_aeg ,_fbcb );};};return _fca ,nil ;
};func _eedf (_febdd _gd .RGBA )_gd .NRGBA {switch _febdd .A {case 0xff:return _gd .NRGBA {R :_febdd .R ,G :_febdd .G ,B :_febdd .B ,A :0xff};case 0x00:return _gd .NRGBA {};default:_efda ,_dgfg ,_eac ,_deg :=_febdd .RGBA ();_efda =(_efda *0xffff)/_deg ;
_dgfg =(_dgfg *0xffff)/_deg ;_eac =(_eac *0xffff)/_deg ;return _gd .NRGBA {R :uint8 (_efda >>8),G :uint8 (_dgfg >>8),B :uint8 (_eac >>8),A :uint8 (_deg >>8)};};};func (_dcgfe *Monochrome )Copy ()Image {return &Monochrome {ImageBase :_dcgfe .ImageBase .copy (),ModelThreshold :_dcgfe .ModelThreshold };
};func _agag (_dbb _gd .NRGBA )_gd .Gray {_ffeb ,_bfd ,_egdag ,_ :=_dbb .RGBA ();_gae :=(19595*_ffeb +38470*_bfd +7471*_egdag +1<<15)>>24;return _gd .Gray {Y :uint8 (_gae )};};func _cbd (_agc RGBA ,_fdde CMYK ,_fffc _d .Rectangle ){for _bbd :=0;_bbd < _fffc .Max .X ;
_bbd ++{for _egdc :=0;_egdc < _fffc .Max .Y ;_egdc ++{_eecg :=_agc .RGBAAt (_bbd ,_egdc );_fdde .SetCMYK (_bbd ,_egdc ,_eeba (_eecg ));};};};func _cb (_fbd *Monochrome ,_fcd ,_fcb int )(*Monochrome ,error ){if _fbd ==nil {return nil ,_g .New ("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064");
};if _fcd <=0||_fcb <=0{return nil ,_g .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0073\u0063\u0061l\u0065\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020<\u003d\u0020\u0030");};if _fcd ==_fcb {if _fcd ==1{return _fbd .copy (),nil ;};
if _fcd ==2||_fcd ==4||_fcd ==8{_dgg ,_gge :=_cd (_fbd ,_fcd );if _gge !=nil {return nil ,_gge ;};return _dgg ,nil ;};};_ba :=_fcd *_fbd .Width ;_eeg :=_fcb *_fbd .Height ;_ggfc :=_fga (_ba ,_eeg );_gfb :=_ggfc .BytesPerLine ;var (_ceg ,_dfd ,_eea ,_da ,_abc int ;
_bad byte ;_dbea error ;);for _dfd =0;_dfd < _fbd .Height ;_dfd ++{_ceg =_fcb *_dfd *_gfb ;for _eea =0;_eea < _fbd .Width ;_eea ++{if _cef :=_fbd .getBitAt (_eea ,_dfd );_cef {_abc =_fcd *_eea ;for _da =0;_da < _fcd ;_da ++{_ggfc .setIndexedBit (_ceg *8+_abc +_da );
};};};for _da =1;_da < _fcb ;_da ++{_afd :=_ceg +_da *_gfb ;for _bgd :=0;_bgd < _gfb ;_bgd ++{if _bad ,_dbea =_ggfc .getByte (_ceg +_bgd );_dbea !=nil {return nil ,_dbea ;};if _dbea =_ggfc .setByte (_afd +_bgd ,_bad );_dbea !=nil {return nil ,_dbea ;};
};};};return _ggfc ,nil ;};func (_beaa *RGBA32 )Copy ()Image {return &RGBA32 {ImageBase :_beaa .copy ()}};func (_caa *Monochrome )getBitAt (_egb ,_ggd int )bool {_gcaf :=_ggd *_caa .BytesPerLine +(_egb >>3);_dedg :=_egb &0x07;_bcfc :=uint (7-_dedg );if _gcaf > len (_caa .Data )-1{return false ;
};if (_caa .Data [_gcaf ]>>_bcfc )&0x01>=1{return true ;};return false ;};func _dggg (_fceeg ,_gdbe NRGBA ,_gdddf _d .Rectangle ){for _bfda :=0;_bfda < _gdddf .Max .X ;_bfda ++{for _egde :=0;_egde < _gdddf .Max .Y ;_egde ++{_gdbe .SetNRGBA (_bfda ,_egde ,_fceeg .NRGBAAt (_bfda ,_egde ));
};};};func (_gfcf *Gray4 )Bounds ()_d .Rectangle {return _d .Rectangle {Max :_d .Point {X :_gfcf .Width ,Y :_gfcf .Height }};};func (_ece *Monochrome )Bounds ()_d .Rectangle {return _d .Rectangle {Max :_d .Point {X :_ece .Width ,Y :_ece .Height }};};func ScaleAlphaToMonochrome (data []byte ,width ,height int )([]byte ,error ){_fg :=BytesPerLine (width ,8,1);
if len (data )< _fg *height {return nil ,nil ;};_c :=&Gray8 {NewImageBase (width ,height ,8,1,data ,nil ,nil )};_gf ,_fc :=MonochromeConverter .Convert (_c );if _fc !=nil {return nil ,_fc ;};return _gf .Base ().Data ,nil ;};func _bece (_agagf CMYK ,_eeea NRGBA ,_acfc _d .Rectangle ){for _cffea :=0;
_cffea < _acfc .Max .X ;_cffea ++{for _dfdc :=0;_dfdc < _acfc .Max .Y ;_dfdc ++{_cccc :=_agagf .CMYKAt (_cffea ,_dfdc );_eeea .SetNRGBA (_cffea ,_dfdc ,_acc (_cccc ));};};};func (_aeb *Gray4 )Histogram ()(_dabe [256]int ){for _aeea :=0;_aeea < _aeb .Width ;
_aeea ++{for _ebe :=0;_ebe < _aeb .Height ;_ebe ++{_dabe [_aeb .GrayAt (_aeea ,_ebe ).Y ]++;};};return _dabe ;};type NRGBA interface{NRGBAAt (_cadc ,_gea int )_gd .NRGBA ;SetNRGBA (_aeeg ,_ddag int ,_gdcgc _gd .NRGBA );};func _becca (_aada _d .Image ,_cbcb Image ,_adcd _d .Rectangle ){if _bbfe ,_agae :=_aada .(SMasker );
_agae &&_bbfe .HasAlpha (){_cbcb .(SMasker ).MakeAlpha ();};switch _aacc :=_aada .(type ){case Gray :_gbagc (_aacc ,_cbcb .(NRGBA ),_adcd );case NRGBA :_dggg (_aacc ,_cbcb .(NRGBA ),_adcd );case *_d .NYCbCrA :_ddcgb (_aacc ,_cbcb .(NRGBA ),_adcd );case CMYK :_bece (_aacc ,_cbcb .(NRGBA ),_adcd );
case RGBA :_edcc (_aacc ,_cbcb .(NRGBA ),_adcd );case nrgba64 :_degag (_aacc ,_cbcb .(NRGBA ),_adcd );default:_gbfc (_aada ,_cbcb ,_adcd );};};func _cfg (_fa int )[]uint {var _bc []uint ;_fac :=_fa ;_eeac :=_fac /8;if _eeac !=0{for _dee :=0;_dee < _eeac ;
_dee ++{_bc =append (_bc ,8);};_cfeb :=_fac %8;_fac =0;if _cfeb !=0{_fac =_cfeb ;};};_adg :=_fac /4;if _adg !=0{for _eef :=0;_eef < _adg ;_eef ++{_bc =append (_bc ,4);};_dab :=_fac %4;_fac =0;if _dab !=0{_fac =_dab ;};};_eaa :=_fac /2;if _eaa !=0{for _fef :=0;
_fef < _eaa ;_fef ++{_bc =append (_bc ,2);};};return _bc ;};type RGBA32 struct{ImageBase };func ConverterFunc (converterFunc func (_gdc _d .Image )(Image ,error ))ColorConverter {return colorConverter {_caff :converterFunc };};type CMYK interface{CMYKAt (_gcc ,_egec int )_gd .CMYK ;
SetCMYK (_bbc ,_gcg int ,_cab _gd .CMYK );};var (MonochromeConverter =ConverterFunc (_egad );Gray2Converter =ConverterFunc (_aefaa );Gray4Converter =ConverterFunc (_fcgd );GrayConverter =ConverterFunc (_ecgc );Gray16Converter =ConverterFunc (_gdeg );NRGBA16Converter =ConverterFunc (_dgegf );
NRGBAConverter =ConverterFunc (_daaa );NRGBA64Converter =ConverterFunc (_cbgd );RGBAConverter =ConverterFunc (_cgag );CMYKConverter =ConverterFunc (_aaa ););func (_cgcf *Monochrome )Base ()*ImageBase {return &_cgcf .ImageBase };func _egad (_afdcb _d .Image )(Image ,error ){if _ccf ,_cggg :=_afdcb .(*Monochrome );
_cggg {return _ccf ,nil ;};_gebe :=_afdcb .Bounds ();var _bbg Gray ;switch _ddbb :=_afdcb .(type ){case Gray :_bbg =_ddbb ;case NRGBA :_bbg =&Gray8 {ImageBase :NewImageBase (_gebe .Max .X ,_gebe .Max .Y ,8,1,nil ,nil ,nil )};_afbb (_bbg ,_ddbb ,_gebe );
case nrgba64 :_bbg =&Gray8 {ImageBase :NewImageBase (_gebe .Max .X ,_gebe .Max .Y ,8,1,nil ,nil ,nil )};_gbfa (_bbg ,_ddbb ,_gebe );default:_gbge ,_bdfb :=GrayConverter .Convert (_afdcb );if _bdfb !=nil {return nil ,_bdfb ;};_bbg =_gbge .(Gray );};_fagb ,_gde :=NewImage (_gebe .Max .X ,_gebe .Max .Y ,1,1,nil ,nil ,nil );
if _gde !=nil {return nil ,_gde ;};_dbag :=_fagb .(*Monochrome );_afdb :=AutoThresholdTriangle (GrayHistogram (_bbg ));for _gefa :=0;_gefa < _gebe .Max .X ;_gefa ++{for _dgab :=0;_dgab < _gebe .Max .Y ;_dgab ++{_effe :=_aadd (_bbg .GrayAt (_gefa ,_dgab ),monochromeModel (_afdb ));
_dbag .SetGray (_gefa ,_dgab ,_effe );};};return _fagb ,nil ;};func (_bcda *NRGBA16 )Set (x ,y int ,c _gd .Color ){_fcbbf :=y *_bcda .BytesPerLine +x *3/2;if _fcbbf +1>=len (_bcda .Data ){return ;};_cae :=NRGBA16Model .Convert (c ).(_gd .NRGBA );_bcda .setNRGBA (x ,y ,_fcbbf ,_cae );
};func _dae (_aab ,_edd *Monochrome ,_aag []byte ,_faf int )(_ccae error ){var (_fcc ,_aee ,_fba ,_eeag ,_gcb ,_eefe ,_dgge ,_gfa int ;_ec ,_cgc ,_fgf ,_bdf uint32 ;_fece ,_efd byte ;_bgfd uint16 ;);_dac :=make ([]byte ,4);_ccda :=make ([]byte ,4);for _fba =0;
_fba < _aab .Height -1;_fba ,_eeag =_fba +2,_eeag +1{_fcc =_fba *_aab .BytesPerLine ;_aee =_eeag *_edd .BytesPerLine ;for _gcb ,_eefe =0,0;_gcb < _faf ;_gcb ,_eefe =_gcb +4,_eefe +1{for _dgge =0;_dgge < 4;_dgge ++{_gfa =_fcc +_gcb +_dgge ;if _gfa <=len (_aab .Data )-1&&_gfa < _fcc +_aab .BytesPerLine {_dac [_dgge ]=_aab .Data [_gfa ];
}else {_dac [_dgge ]=0x00;};_gfa =_fcc +_aab .BytesPerLine +_gcb +_dgge ;if _gfa <=len (_aab .Data )-1&&_gfa < _fcc +(2*_aab .BytesPerLine ){_ccda [_dgge ]=_aab .Data [_gfa ];}else {_ccda [_dgge ]=0x00;};};_ec =_gg .BigEndian .Uint32 (_dac );_cgc =_gg .BigEndian .Uint32 (_ccda );
_fgf =_ec &_cgc ;_fgf |=_fgf <<1;_bdf =_ec |_cgc ;_bdf &=_bdf <<1;_cgc =_fgf &_bdf ;_cgc &=0xaaaaaaaa;_ec =_cgc |(_cgc <<7);_fece =byte (_ec >>24);_efd =byte ((_ec >>8)&0xff);_gfa =_aee +_eefe ;if _gfa +1==len (_edd .Data )-1||_gfa +1>=_aee +_edd .BytesPerLine {if _ccae =_edd .setByte (_gfa ,_aag [_fece ]);
_ccae !=nil {return _eb .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_gfa );};}else {_bgfd =(uint16 (_aag [_fece ])<<8)|uint16 (_aag [_efd ]);if _ccae =_edd .setTwoBytes (_gfa ,_bgfd );_ccae !=nil {return _eb .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_gfa );
};_eefe ++;};};};return nil ;};func _afbb (_bddb Gray ,_eded NRGBA ,_bgc _d .Rectangle ){for _cacf :=0;_cacf < _bgc .Max .X ;_cacf ++{for _gcea :=0;_gcea < _bgc .Max .Y ;_gcea ++{_dgdg :=_bfge (_eded .NRGBAAt (_cacf ,_gcea ));_bddb .SetGray (_cacf ,_gcea ,_dgdg );
};};};func _bbff (_dgag _d .Image ,_gadab Image ,_ecb _d .Rectangle ){switch _bafcc :=_dgag .(type ){case Gray :_cdca (_bafcc ,_gadab .(Gray ),_ecb );case NRGBA :_baed (_bafcc ,_gadab .(Gray ),_ecb );case CMYK :_adad (_bafcc ,_gadab .(Gray ),_ecb );case RGBA :_bbag (_bafcc ,_gadab .(Gray ),_ecb );
default:_gbfc (_dgag ,_gadab .(Image ),_ecb );};};func _bffd (_ecdd _gd .RGBA )_gd .Gray {_fdc :=(19595*uint32 (_ecdd .R )+38470*uint32 (_ecdd .G )+7471*uint32 (_ecdd .B )+1<<7)>>16;return _gd .Gray {Y :uint8 (_fdc )};};func ColorAtNRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_gd .NRGBA ,error ){_dgfgf :=y *width +x ;
_bbgde :=3*_dgfgf ;if _bbgde +2>=len (data ){return _gd .NRGBA {},_eb .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_ddec :=uint8 (0xff);if alpha !=nil &&len (alpha )> _dgfgf {_ddec =alpha [_dgfgf ];};_fgef ,_gfga ,_degd :=data [_bbgde ],data [_bbgde +1],data [_bbgde +2];if len (decode )==6{_fgef =uint8 (uint32 (LinearInterpolate (float64 (_fgef ),0,255,decode [0],decode [1]))&0xff);
_gfga =uint8 (uint32 (LinearInterpolate (float64 (_gfga ),0,255,decode [2],decode [3]))&0xff);_degd =uint8 (uint32 (LinearInterpolate (float64 (_degd ),0,255,decode [4],decode [5]))&0xff);};return _gd .NRGBA {R :_fgef ,G :_gfga ,B :_degd ,A :_ddec },nil ;
};func _aefaa (_fbg _d .Image )(Image ,error ){if _efbe ,_bdc :=_fbg .(*Gray2 );_bdc {return _efbe .Copy (),nil ;};_gfbb :=_fbg .Bounds ();_cba ,_agb :=NewImage (_gfbb .Max .X ,_gfbb .Max .Y ,2,1,nil ,nil ,nil );if _agb !=nil {return nil ,_agb ;};_bbff (_fbg ,_cba ,_gfbb );
return _cba ,nil ;};func (_bbac *NRGBA64 )Set (x ,y int ,c _gd .Color ){_ggab :=(y *_bbac .Width +x )*2;_fegb :=_ggab *3;if _fegb +5>=len (_bbac .Data ){return ;};_edda :=_gd .NRGBA64Model .Convert (c ).(_gd .NRGBA64 );_bbac .setNRGBA64 (_fegb ,_edda ,_ggab );
};type NRGBA16 struct{ImageBase };func _edcc (_bfdfb RGBA ,_cdgf NRGBA ,_acgaa _d .Rectangle ){for _bgcc :=0;_bgcc < _acgaa .Max .X ;_bgcc ++{for _cgfag :=0;_cgfag < _acgaa .Max .Y ;_cgfag ++{_becef :=_bfdfb .RGBAAt (_bgcc ,_cgfag );_cdgf .SetNRGBA (_bgcc ,_cgfag ,_eedf (_becef ));
};};};func (_dgfa monochromeModel )Convert (c _gd .Color )_gd .Color {_daac :=_gd .GrayModel .Convert (c ).(_gd .Gray );return _aadd (_daac ,_dgfa );};func _cbdf (_ddcg *Monochrome ,_acf ,_gdcae ,_ggcg ,_bcbge int ,_ecbd RasterOperator ,_fgb *Monochrome ,_dgga ,_gab int )error {var (_gdcc bool ;
_gafb bool ;_ddgf int ;_gcgf int ;_befc int ;_dagf bool ;_dcee byte ;_efgd int ;_dcgfa int ;_fgdd int ;_dced ,_bgab int ;);_fcad :=8-(_acf &7);_cede :=_eadg [_fcad ];_efdeg :=_ddcg .BytesPerLine *_gdcae +(_acf >>3);_fcccg :=_fgb .BytesPerLine *_gab +(_dgga >>3);
if _ggcg < _fcad {_gdcc =true ;_cede &=_fgeb [8-_fcad +_ggcg ];};if !_gdcc {_ddgf =(_ggcg -_fcad )>>3;if _ddgf > 0{_gafb =true ;_gcgf =_efdeg +1;_befc =_fcccg +1;};};_efgd =(_acf +_ggcg )&7;if !(_gdcc ||_efgd ==0){_dagf =true ;_dcee =_fgeb [_efgd ];_dcgfa =_efdeg +1+_ddgf ;
_fgdd =_fcccg +1+_ddgf ;};switch _ecbd {case PixSrc :for _dced =0;_dced < _bcbge ;_dced ++{_ddcg .Data [_efdeg ]=_dfbc (_ddcg .Data [_efdeg ],_fgb .Data [_fcccg ],_cede );_efdeg +=_ddcg .BytesPerLine ;_fcccg +=_fgb .BytesPerLine ;};if _gafb {for _dced =0;
_dced < _bcbge ;_dced ++{for _bgab =0;_bgab < _ddgf ;_bgab ++{_ddcg .Data [_gcgf +_bgab ]=_fgb .Data [_befc +_bgab ];};_gcgf +=_ddcg .BytesPerLine ;_befc +=_fgb .BytesPerLine ;};};if _dagf {for _dced =0;_dced < _bcbge ;_dced ++{_ddcg .Data [_dcgfa ]=_dfbc (_ddcg .Data [_dcgfa ],_fgb .Data [_fgdd ],_dcee );
_dcgfa +=_ddcg .BytesPerLine ;_fgdd +=_fgb .BytesPerLine ;};};case PixNotSrc :for _dced =0;_dced < _bcbge ;_dced ++{_ddcg .Data [_efdeg ]=_dfbc (_ddcg .Data [_efdeg ],^_fgb .Data [_fcccg ],_cede );_efdeg +=_ddcg .BytesPerLine ;_fcccg +=_fgb .BytesPerLine ;
};if _gafb {for _dced =0;_dced < _bcbge ;_dced ++{for _bgab =0;_bgab < _ddgf ;_bgab ++{_ddcg .Data [_gcgf +_bgab ]=^_fgb .Data [_befc +_bgab ];};_gcgf +=_ddcg .BytesPerLine ;_befc +=_fgb .BytesPerLine ;};};if _dagf {for _dced =0;_dced < _bcbge ;_dced ++{_ddcg .Data [_dcgfa ]=_dfbc (_ddcg .Data [_dcgfa ],^_fgb .Data [_fgdd ],_dcee );
_dcgfa +=_ddcg .BytesPerLine ;_fgdd +=_fgb .BytesPerLine ;};};case PixSrcOrDst :for _dced =0;_dced < _bcbge ;_dced ++{_ddcg .Data [_efdeg ]=_dfbc (_ddcg .Data [_efdeg ],_fgb .Data [_fcccg ]|_ddcg .Data [_efdeg ],_cede );_efdeg +=_ddcg .BytesPerLine ;_fcccg +=_fgb .BytesPerLine ;
};if _gafb {for _dced =0;_dced < _bcbge ;_dced ++{for _bgab =0;_bgab < _ddgf ;_bgab ++{_ddcg .Data [_gcgf +_bgab ]|=_fgb .Data [_befc +_bgab ];};_gcgf +=_ddcg .BytesPerLine ;_befc +=_fgb .BytesPerLine ;};};if _dagf {for _dced =0;_dced < _bcbge ;_dced ++{_ddcg .Data [_dcgfa ]=_dfbc (_ddcg .Data [_dcgfa ],_fgb .Data [_fgdd ]|_ddcg .Data [_dcgfa ],_dcee );
_dcgfa +=_ddcg .BytesPerLine ;_fgdd +=_fgb .BytesPerLine ;};};case PixSrcAndDst :for _dced =0;_dced < _bcbge ;_dced ++{_ddcg .Data [_efdeg ]=_dfbc (_ddcg .Data [_efdeg ],_fgb .Data [_fcccg ]&_ddcg .Data [_efdeg ],_cede );_efdeg +=_ddcg .BytesPerLine ;_fcccg +=_fgb .BytesPerLine ;
};if _gafb {for _dced =0;_dced < _bcbge ;_dced ++{for _bgab =0;_bgab < _ddgf ;_bgab ++{_ddcg .Data [_gcgf +_bgab ]&=_fgb .Data [_befc +_bgab ];};_gcgf +=_ddcg .BytesPerLine ;_befc +=_fgb .BytesPerLine ;};};if _dagf {for _dced =0;_dced < _bcbge ;_dced ++{_ddcg .Data [_dcgfa ]=_dfbc (_ddcg .Data [_dcgfa ],_fgb .Data [_fgdd ]&_ddcg .Data [_dcgfa ],_dcee );
_dcgfa +=_ddcg .BytesPerLine ;_fgdd +=_fgb .BytesPerLine ;};};case PixSrcXorDst :for _dced =0;_dced < _bcbge ;_dced ++{_ddcg .Data [_efdeg ]=_dfbc (_ddcg .Data [_efdeg ],_fgb .Data [_fcccg ]^_ddcg .Data [_efdeg ],_cede );_efdeg +=_ddcg .BytesPerLine ;_fcccg +=_fgb .BytesPerLine ;
};if _gafb {for _dced =0;_dced < _bcbge ;_dced ++{for _bgab =0;_bgab < _ddgf ;_bgab ++{_ddcg .Data [_gcgf +_bgab ]^=_fgb .Data [_befc +_bgab ];};_gcgf +=_ddcg .BytesPerLine ;_befc +=_fgb .BytesPerLine ;};};if _dagf {for _dced =0;_dced < _bcbge ;_dced ++{_ddcg .Data [_dcgfa ]=_dfbc (_ddcg .Data [_dcgfa ],_fgb .Data [_fgdd ]^_ddcg .Data [_dcgfa ],_dcee );
_dcgfa +=_ddcg .BytesPerLine ;_fgdd +=_fgb .BytesPerLine ;};};case PixNotSrcOrDst :for _dced =0;_dced < _bcbge ;_dced ++{_ddcg .Data [_efdeg ]=_dfbc (_ddcg .Data [_efdeg ],^(_fgb .Data [_fcccg ])|_ddcg .Data [_efdeg ],_cede );_efdeg +=_ddcg .BytesPerLine ;
_fcccg +=_fgb .BytesPerLine ;};if _gafb {for _dced =0;_dced < _bcbge ;_dced ++{for _bgab =0;_bgab < _ddgf ;_bgab ++{_ddcg .Data [_gcgf +_bgab ]|=^(_fgb .Data [_befc +_bgab ]);};_gcgf +=_ddcg .BytesPerLine ;_befc +=_fgb .BytesPerLine ;};};if _dagf {for _dced =0;
_dced < _bcbge ;_dced ++{_ddcg .Data [_dcgfa ]=_dfbc (_ddcg .Data [_dcgfa ],^(_fgb .Data [_fgdd ])|_ddcg .Data [_dcgfa ],_dcee );_dcgfa +=_ddcg .BytesPerLine ;_fgdd +=_fgb .BytesPerLine ;};};case PixNotSrcAndDst :for _dced =0;_dced < _bcbge ;_dced ++{_ddcg .Data [_efdeg ]=_dfbc (_ddcg .Data [_efdeg ],^(_fgb .Data [_fcccg ])&_ddcg .Data [_efdeg ],_cede );
_efdeg +=_ddcg .BytesPerLine ;_fcccg +=_fgb .BytesPerLine ;};if _gafb {for _dced =0;_dced < _bcbge ;_dced ++{for _bgab =0;_bgab < _ddgf ;_bgab ++{_ddcg .Data [_gcgf +_bgab ]&=^_fgb .Data [_befc +_bgab ];};_gcgf +=_ddcg .BytesPerLine ;_befc +=_fgb .BytesPerLine ;
};};if _dagf {for _dced =0;_dced < _bcbge ;_dced ++{_ddcg .Data [_dcgfa ]=_dfbc (_ddcg .Data [_dcgfa ],^(_fgb .Data [_fgdd ])&_ddcg .Data [_dcgfa ],_dcee );_dcgfa +=_ddcg .BytesPerLine ;_fgdd +=_fgb .BytesPerLine ;};};case PixSrcOrNotDst :for _dced =0;
_dced < _bcbge ;_dced ++{_ddcg .Data [_efdeg ]=_dfbc (_ddcg .Data [_efdeg ],_fgb .Data [_fcccg ]|^(_ddcg .Data [_efdeg ]),_cede );_efdeg +=_ddcg .BytesPerLine ;_fcccg +=_fgb .BytesPerLine ;};if _gafb {for _dced =0;_dced < _bcbge ;_dced ++{for _bgab =0;
_bgab < _ddgf ;_bgab ++{_ddcg .Data [_gcgf +_bgab ]=_fgb .Data [_befc +_bgab ]|^(_ddcg .Data [_gcgf +_bgab ]);};_gcgf +=_ddcg .BytesPerLine ;_befc +=_fgb .BytesPerLine ;};};if _dagf {for _dced =0;_dced < _bcbge ;_dced ++{_ddcg .Data [_dcgfa ]=_dfbc (_ddcg .Data [_dcgfa ],_fgb .Data [_fgdd ]|^(_ddcg .Data [_dcgfa ]),_dcee );
_dcgfa +=_ddcg .BytesPerLine ;_fgdd +=_fgb .BytesPerLine ;};};case PixSrcAndNotDst :for _dced =0;_dced < _bcbge ;_dced ++{_ddcg .Data [_efdeg ]=_dfbc (_ddcg .Data [_efdeg ],_fgb .Data [_fcccg ]&^(_ddcg .Data [_efdeg ]),_cede );_efdeg +=_ddcg .BytesPerLine ;
_fcccg +=_fgb .BytesPerLine ;};if _gafb {for _dced =0;_dced < _bcbge ;_dced ++{for _bgab =0;_bgab < _ddgf ;_bgab ++{_ddcg .Data [_gcgf +_bgab ]=_fgb .Data [_befc +_bgab ]&^(_ddcg .Data [_gcgf +_bgab ]);};_gcgf +=_ddcg .BytesPerLine ;_befc +=_fgb .BytesPerLine ;
};};if _dagf {for _dced =0;_dced < _bcbge ;_dced ++{_ddcg .Data [_dcgfa ]=_dfbc (_ddcg .Data [_dcgfa ],_fgb .Data [_fgdd ]&^(_ddcg .Data [_dcgfa ]),_dcee );_dcgfa +=_ddcg .BytesPerLine ;_fgdd +=_fgb .BytesPerLine ;};};case PixNotPixSrcOrDst :for _dced =0;
_dced < _bcbge ;_dced ++{_ddcg .Data [_efdeg ]=_dfbc (_ddcg .Data [_efdeg ],^(_fgb .Data [_fcccg ]|_ddcg .Data [_efdeg ]),_cede );_efdeg +=_ddcg .BytesPerLine ;_fcccg +=_fgb .BytesPerLine ;};if _gafb {for _dced =0;_dced < _bcbge ;_dced ++{for _bgab =0;
_bgab < _ddgf ;_bgab ++{_ddcg .Data [_gcgf +_bgab ]=^(_fgb .Data [_befc +_bgab ]|_ddcg .Data [_gcgf +_bgab ]);};_gcgf +=_ddcg .BytesPerLine ;_befc +=_fgb .BytesPerLine ;};};if _dagf {for _dced =0;_dced < _bcbge ;_dced ++{_ddcg .Data [_dcgfa ]=_dfbc (_ddcg .Data [_dcgfa ],^(_fgb .Data [_fgdd ]|_ddcg .Data [_dcgfa ]),_dcee );
_dcgfa +=_ddcg .BytesPerLine ;_fgdd +=_fgb .BytesPerLine ;};};case PixNotPixSrcAndDst :for _dced =0;_dced < _bcbge ;_dced ++{_ddcg .Data [_efdeg ]=_dfbc (_ddcg .Data [_efdeg ],^(_fgb .Data [_fcccg ]&_ddcg .Data [_efdeg ]),_cede );_efdeg +=_ddcg .BytesPerLine ;
_fcccg +=_fgb .BytesPerLine ;};if _gafb {for _dced =0;_dced < _bcbge ;_dced ++{for _bgab =0;_bgab < _ddgf ;_bgab ++{_ddcg .Data [_gcgf +_bgab ]=^(_fgb .Data [_befc +_bgab ]&_ddcg .Data [_gcgf +_bgab ]);};_gcgf +=_ddcg .BytesPerLine ;_befc +=_fgb .BytesPerLine ;
};};if _dagf {for _dced =0;_dced < _bcbge ;_dced ++{_ddcg .Data [_dcgfa ]=_dfbc (_ddcg .Data [_dcgfa ],^(_fgb .Data [_fgdd ]&_ddcg .Data [_dcgfa ]),_dcee );_dcgfa +=_ddcg .BytesPerLine ;_fgdd +=_fgb .BytesPerLine ;};};case PixNotPixSrcXorDst :for _dced =0;
_dced < _bcbge ;_dced ++{_ddcg .Data [_efdeg ]=_dfbc (_ddcg .Data [_efdeg ],^(_fgb .Data [_fcccg ]^_ddcg .Data [_efdeg ]),_cede );_efdeg +=_ddcg .BytesPerLine ;_fcccg +=_fgb .BytesPerLine ;};if _gafb {for _dced =0;_dced < _bcbge ;_dced ++{for _bgab =0;
_bgab < _ddgf ;_bgab ++{_ddcg .Data [_gcgf +_bgab ]=^(_fgb .Data [_befc +_bgab ]^_ddcg .Data [_gcgf +_bgab ]);};_gcgf +=_ddcg .BytesPerLine ;_befc +=_fgb .BytesPerLine ;};};if _dagf {for _dced =0;_dced < _bcbge ;_dced ++{_ddcg .Data [_dcgfa ]=_dfbc (_ddcg .Data [_dcgfa ],^(_fgb .Data [_fgdd ]^_ddcg .Data [_dcgfa ]),_dcee );
_dcgfa +=_ddcg .BytesPerLine ;_fgdd +=_fgb .BytesPerLine ;};};default:_fe .Log .Debug ("I\u006e\u0076\u0061\u006c\u0069\u0064 \u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070e\u0072\u0061\u0074o\u0072:\u0020\u0025\u0064",_ecbd );return _g .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072");
};return nil ;};func _bebb (_cabe _gd .Gray )_gd .Gray {_cabe .Y >>=4;_cabe .Y |=_cabe .Y <<4;return _cabe };func (_eeeg *RGBA32 )Validate ()error {if len (_eeeg .Data )!=3*_eeeg .Width *_eeeg .Height {return _g .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func _acc (_fdf _gd .CMYK )_gd .NRGBA {_dgfb ,_eed ,_cafa :=_gd .CMYKToRGB (_fdf .C ,_fdf .M ,_fdf .Y ,_fdf .K );return _gd .NRGBA {R :_dgfb ,G :_eed ,B :_cafa ,A :0xff};};func NextPowerOf2 (n uint )uint {if IsPowerOf2 (n ){return n ;};
return 1<<(_cadf (n )+1);};func _bd ()(_adb [256]uint32 ){for _aga :=0;_aga < 256;_aga ++{if _aga &0x01!=0{_adb [_aga ]|=0xf;};if _aga &0x02!=0{_adb [_aga ]|=0xf0;};if _aga &0x04!=0{_adb [_aga ]|=0xf00;};if _aga &0x08!=0{_adb [_aga ]|=0xf000;};if _aga &0x10!=0{_adb [_aga ]|=0xf0000;
};if _aga &0x20!=0{_adb [_aga ]|=0xf00000;};if _aga &0x40!=0{_adb [_aga ]|=0xf000000;};if _aga &0x80!=0{_adb [_aga ]|=0xf0000000;};};return _adb ;};func (_ddaf *ImageBase )setFourBytes (_fccc int ,_agfg uint32 )error {if _fccc +3> len (_ddaf .Data )-1{return _eb .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006fu\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065",_fccc );
};_ddaf .Data [_fccc ]=byte ((_agfg &0xff000000)>>24);_ddaf .Data [_fccc +1]=byte ((_agfg &0xff0000)>>16);_ddaf .Data [_fccc +2]=byte ((_agfg &0xff00)>>8);_ddaf .Data [_fccc +3]=byte (_agfg &0xff);return nil ;};func (_daad *ImageBase )copy ()ImageBase {_ddgd :=*_daad ;
_ddgd .Data =make ([]byte ,len (_daad .Data ));copy (_ddgd .Data ,_daad .Data );return _ddgd ;};func _gdgg (_agage _d .Image ,_ddac Image ,_ffca _d .Rectangle ){if _abea ,_bgde :=_agage .(SMasker );_bgde &&_abea .HasAlpha (){_ddac .(SMasker ).MakeAlpha ();
};_gbfc (_agage ,_ddac ,_ffca );};func (_gcad *RGBA32 )setRGBA (_abfec int ,_ddgab _gd .RGBA ){_ffdcaa :=3*_abfec ;_gcad .Data [_ffdcaa ]=_ddgab .R ;_gcad .Data [_ffdcaa +1]=_ddgab .G ;_gcad .Data [_ffdcaa +2]=_ddgab .B ;if _abfec < len (_gcad .Alpha ){_gcad .Alpha [_abfec ]=_ddgab .A ;
};};func (_fgfb *NRGBA64 )Validate ()error {if len (_fgfb .Data )!=3*2*_fgfb .Width *_fgfb .Height {return _g .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func (_ddb *CMYK32 )ColorAt (x ,y int )(_gd .Color ,error ){return ColorAtCMYK (x ,y ,_ddb .Width ,_ddb .Data ,_ddb .Decode );};func (_bffa *Gray16 )GrayAt (x ,y int )_gd .Gray {_aabg ,_ :=_bffa .ColorAt (x ,y );return _gd .Gray {Y :uint8 (_aabg .(_gd .Gray16 ).Y >>8)};
};type monochromeThresholdConverter struct{Threshold uint8 ;};func (_caba *CMYK32 )Base ()*ImageBase {return &_caba .ImageBase };func (_dacc *NRGBA16 )SetNRGBA (x ,y int ,c _gd .NRGBA ){_gcce :=y *_dacc .BytesPerLine +x *3/2;if _gcce +1>=len (_dacc .Data ){return ;
};c =_dgec (c );_dacc .setNRGBA (x ,y ,_gcce ,c );};func (_cbff *ImageBase )setTwoBytes (_eegff int ,_cgfa uint16 )error {if _eegff +1> len (_cbff .Data )-1{return _g .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_cbff .Data [_eegff ]=byte ((_cgfa &0xff00)>>8);_cbff .Data [_eegff +1]=byte (_cgfa &0xff);return nil ;};func _dcbe (_dbgd _gd .CMYK )_gd .Gray {_edfg ,_dec ,_dag :=_gd .CMYKToRGB (_dbgd .C ,_dbgd .M ,_dbgd .Y ,_dbgd .K );_eca :=(19595*uint32 (_edfg )+38470*uint32 (_dec )+7471*uint32 (_dag )+1<<7)>>16;
return _gd .Gray {Y :uint8 (_eca )};};func (_acce *Monochrome )setGrayBit (_cccg ,_dbab int ){_acce .Data [_cccg ]|=0x80>>uint (_dbab &7)};func (_fcdf *NRGBA64 )Bounds ()_d .Rectangle {return _d .Rectangle {Max :_d .Point {X :_fcdf .Width ,Y :_fcdf .Height }};
};func ColorAtGray16BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_gd .Gray16 ,error ){_bacd :=(y *bytesPerLine /2+x )*2;if _bacd +1>=len (data ){return _gd .Gray16 {},_eb .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_cbf :=uint16 (data [_bacd ])<<8|uint16 (data [_bacd +1]);if len (decode )==2{_cbf =uint16 (uint64 (LinearInterpolate (float64 (_cbf ),0,65535,decode [0],decode [1])));};return _gd .Gray16 {Y :_cbf },nil ;};func _bfge (_def _gd .NRGBA )_gd .Gray {var _bde _gd .NRGBA ;
if _def ==_bde {return _gd .Gray {Y :0xff};};_cfgb ,_gdg ,_gdab ,_ :=_def .RGBA ();_afdc :=(19595*_cfgb +38470*_gdg +7471*_gdab +1<<15)>>24;return _gd .Gray {Y :uint8 (_afdc )};};func RasterOperation (dest *Monochrome ,dx ,dy ,dw ,dh int ,op RasterOperator ,src *Monochrome ,sx ,sy int )error {return _gdff (dest ,dx ,dy ,dw ,dh ,op ,src ,sx ,sy );
};type ImageBase struct{Width ,Height int ;BitsPerComponent ,ColorComponents int ;Data ,Alpha []byte ;Decode []float64 ;BytesPerLine int ;};var _ _d .Image =&NRGBA64 {};func (_acb *Gray2 )Validate ()error {if len (_acb .Data )!=_acb .Height *_acb .BytesPerLine {return ErrInvalidImage ;
};return nil ;};func _fedc (_fdba NRGBA ,_agbc RGBA ,_ecaa _d .Rectangle ){for _dbfc :=0;_dbfc < _ecaa .Max .X ;_dbfc ++{for _abb :=0;_abb < _ecaa .Max .Y ;_abb ++{_gddg :=_fdba .NRGBAAt (_dbfc ,_abb );_agbc .SetRGBA (_dbfc ,_abb ,_gdca (_gddg ));};};};
func _aea (_aafe _gd .NYCbCrA )_gd .NRGBA {_eff :=int32 (_aafe .Y )*0x10101;_efde :=int32 (_aafe .Cb )-128;_ffec :=int32 (_aafe .Cr )-128;_fddc :=_eff +91881*_ffec ;if uint32 (_fddc )&0xff000000==0{_fddc >>=8;}else {_fddc =^(_fddc >>31)&0xffff;};_gdda :=_eff -22554*_efde -46802*_ffec ;
if uint32 (_gdda )&0xff000000==0{_gdda >>=8;}else {_gdda =^(_gdda >>31)&0xffff;};_dfce :=_eff +116130*_efde ;if uint32 (_dfce )&0xff000000==0{_dfce >>=8;}else {_dfce =^(_dfce >>31)&0xffff;};return _gd .NRGBA {R :uint8 (_fddc >>8),G :uint8 (_gdda >>8),B :uint8 (_dfce >>8),A :_aafe .A };
};type colorConverter struct{_caff func (_dga _d .Image )(Image ,error );};func (_dcfe *Gray2 )Base ()*ImageBase {return &_dcfe .ImageBase };func (_eebc *Monochrome )SetGray (x ,y int ,g _gd .Gray ){_gada :=y *_eebc .BytesPerLine +x >>3;if _gada > len (_eebc .Data )-1{return ;
};g =_aadd (g ,monochromeModel (_eebc .ModelThreshold ));_eebc .setGray (x ,g ,_gada );};func (_bbgg *Monochrome )setGray (_ddbg int ,_beb _gd .Gray ,_edfcg int ){if _beb .Y ==0{_bbgg .clearBit (_edfcg ,_ddbg );}else {_bbgg .setGrayBit (_edfcg ,_ddbg );
};};func (_gabc *NRGBA16 )NRGBAAt (x ,y int )_gd .NRGBA {_defc ,_ :=ColorAtNRGBA16 (x ,y ,_gabc .Width ,_gabc .BytesPerLine ,_gabc .Data ,_gabc .Alpha ,_gabc .Decode );return _defc ;};func (_cgaf *Gray16 )Set (x ,y int ,c _gd .Color ){_acae :=(y *_cgaf .BytesPerLine /2+x )*2;
if _acae +1>=len (_cgaf .Data ){return ;};_aba :=_gd .Gray16Model .Convert (c ).(_gd .Gray16 );_cgaf .Data [_acae ],_cgaf .Data [_acae +1]=uint8 (_aba .Y >>8),uint8 (_aba .Y &0xff);};func init (){_ffdaf ()};func (_bafd *Gray16 )Histogram ()(_bbbg [256]int ){for _fdee :=0;
_fdee < _bafd .Width ;_fdee ++{for _bcce :=0;_bcce < _bafd .Height ;_bcce ++{_bbbg [_bafd .GrayAt (_fdee ,_bcce ).Y ]++;};};return _bbbg ;};func (_acec *Gray16 )ColorModel ()_gd .Model {return _gd .Gray16Model };var _ Gray =&Monochrome {};func _bdbf (_feg ,_bff CMYK ,_fadb _d .Rectangle ){for _daf :=0;
_daf < _fadb .Max .X ;_daf ++{for _efe :=0;_efe < _fadb .Max .Y ;_efe ++{_bff .SetCMYK (_daf ,_efe ,_feg .CMYKAt (_daf ,_efe ));};};};type CMYK32 struct{ImageBase };func (_bfga *NRGBA32 )setRGBA (_cecbd int ,_aeag _gd .NRGBA ){_fbfd :=3*_cecbd ;_bfga .Data [_fbfd ]=_aeag .R ;
_bfga .Data [_fbfd +1]=_aeag .G ;_bfga .Data [_fbfd +2]=_aeag .B ;if _cecbd < len (_bfga .Alpha ){_bfga .Alpha [_cecbd ]=_aeag .A ;};};func (_ggfd *ImageBase )setEightFullBytes (_deb int ,_eeee uint64 )error {if _deb +7> len (_ggfd .Data )-1{return _g .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_ggfd .Data [_deb ]=byte ((_eeee &0xff00000000000000)>>56);_ggfd .Data [_deb +1]=byte ((_eeee &0xff000000000000)>>48);_ggfd .Data [_deb +2]=byte ((_eeee &0xff0000000000)>>40);_ggfd .Data [_deb +3]=byte ((_eeee &0xff00000000)>>32);_ggfd .Data [_deb +4]=byte ((_eeee &0xff000000)>>24);
_ggfd .Data [_deb +5]=byte ((_eeee &0xff0000)>>16);_ggfd .Data [_deb +6]=byte ((_eeee &0xff00)>>8);_ggfd .Data [_deb +7]=byte (_eeee &0xff);return nil ;};func (_dcbca *RGBA32 )SetRGBA (x ,y int ,c _gd .RGBA ){_acbb :=y *_dcbca .Width +x ;_gcde :=3*_acbb ;
if _gcde +2>=len (_dcbca .Data ){return ;};_dcbca .setRGBA (_acbb ,c );};var _ Image =&NRGBA16 {};func (_ced *Monochrome )copy ()*Monochrome {_dddg :=_fga (_ced .Width ,_ced .Height );_dddg .ModelThreshold =_ced .ModelThreshold ;_dddg .Data =make ([]byte ,len (_ced .Data ));
copy (_dddg .Data ,_ced .Data );if len (_ced .Decode )!=0{_dddg .Decode =make ([]float64 ,len (_ced .Decode ));copy (_dddg .Decode ,_ced .Decode );};if len (_ced .Alpha )!=0{_dddg .Alpha =make ([]byte ,len (_ced .Alpha ));copy (_dddg .Alpha ,_ced .Alpha );
};return _dddg ;};func (_ade *Gray8 )Base ()*ImageBase {return &_ade .ImageBase };func (_dceg *Monochrome )GrayAt (x ,y int )_gd .Gray {_fccf ,_ :=ColorAtGray1BPC (x ,y ,_dceg .BytesPerLine ,_dceg .Data ,_dceg .Decode );return _fccf ;};var _ Image =&RGBA32 {};
func (_ccfd *Gray4 )Base ()*ImageBase {return &_ccfd .ImageBase };var _ Image =&Gray8 {};func (_abgc *RGBA32 )Base ()*ImageBase {return &_abgc .ImageBase };func (_gbe *Gray4 )SetGray (x ,y int ,g _gd .Gray ){if x >=_gbe .Width ||y >=_gbe .Height {return ;
};g =_bebb (g );_gbe .setGray (x ,y ,g );};func _dcb ()(_fag []byte ){_fag =make ([]byte ,256);for _ffgf :=0;_ffgf < 256;_ffgf ++{_gdd :=byte (_ffgf );_fag [_gdd ]=(_gdd &0x01)|((_gdd &0x04)>>1)|((_gdd &0x10)>>2)|((_gdd &0x40)>>3)|((_gdd &0x02)<<3)|((_gdd &0x08)<<2)|((_gdd &0x20)<<1)|(_gdd &0x80);
};return _fag ;};func (_efbd *Monochrome )setBit (_bbce ,_badc int ){_efbd .Data [_bbce +(_badc >>3)]|=0x80>>uint (_badc &7);};func (_baca *NRGBA16 )At (x ,y int )_gd .Color {_eceeb ,_ :=_baca .ColorAt (x ,y );return _eceeb };func (_gdcg *Gray16 )SetGray (x ,y int ,g _gd .Gray ){_ccgb :=(y *_gdcg .BytesPerLine /2+x )*2;
if _ccgb +1>=len (_gdcg .Data ){return ;};_gdcg .Data [_ccgb ]=g .Y ;_gdcg .Data [_ccgb +1]=g .Y ;};func (_cebg *RGBA32 )Set (x ,y int ,c _gd .Color ){_fafb :=y *_cebg .Width +x ;_dadb :=3*_fafb ;if _dadb +2>=len (_cebg .Data ){return ;};_dcfa :=_gd .RGBAModel .Convert (c ).(_gd .RGBA );
_cebg .setRGBA (_fafb ,_dcfa );};func (_gecc *Gray2 )Bounds ()_d .Rectangle {return _d .Rectangle {Max :_d .Point {X :_gecc .Width ,Y :_gecc .Height }};};func _aaa (_abcg _d .Image )(Image ,error ){if _cgg ,_fcbg :=_abcg .(*CMYK32 );_fcbg {return _cgg .Copy (),nil ;
};_gaf :=_abcg .Bounds ();_afba ,_ceb :=NewImage (_gaf .Max .X ,_gaf .Max .Y ,8,4,nil ,nil ,nil );if _ceb !=nil {return nil ,_ceb ;};switch _cgbb :=_abcg .(type ){case CMYK :_bdbf (_cgbb ,_afba .(CMYK ),_gaf );case Gray :_fcbd (_cgbb ,_afba .(CMYK ),_gaf );
case NRGBA :_ead (_cgbb ,_afba .(CMYK ),_gaf );case RGBA :_cbd (_cgbb ,_afba .(CMYK ),_gaf );default:_gbfc (_abcg ,_afba ,_gaf );};return _afba ,nil ;};func (_cadb *Monochrome )IsUnpadded ()bool {return (_cadb .Width *_cadb .Height )==len (_cadb .Data )};
func _ddad (_efcc _gd .NRGBA64 )_gd .RGBA {_aadf ,_edb ,_ceeg ,_gaef :=_efcc .RGBA ();return _gd .RGBA {R :uint8 (_aadf >>8),G :uint8 (_edb >>8),B :uint8 (_ceeg >>8),A :uint8 (_gaef >>8)};};var _ _d .Image =&NRGBA32 {};func (_eefa *Monochrome )setIndexedBit (_bceb int ){_eefa .Data [(_bceb >>3)]|=0x80>>uint (_bceb &7)};
func _gcf (_bcfcd _gd .Color )_gd .Color {_bbea :=_gd .GrayModel .Convert (_bcfcd ).(_gd .Gray );return _bebb (_bbea );};func (_cabgc *RGBA32 )At (x ,y int )_gd .Color {_cdge ,_ :=_cabgc .ColorAt (x ,y );return _cdge };func (_beea *Monochrome )clearBit (_fecec ,_eaaa int ){_beea .Data [_fecec ]&=^(0x80>>uint (_eaaa &7))};
func (_bgcb *Gray8 )GrayAt (x ,y int )_gd .Gray {_gdaf ,_ :=ColorAtGray8BPC (x ,y ,_bgcb .BytesPerLine ,_bgcb .Data ,_bgcb .Decode );return _gdaf ;};func (_ffba *Gray4 )At (x ,y int )_gd .Color {_gade ,_ :=_ffba .ColorAt (x ,y );return _gade };func (_beac *Gray16 )Copy ()Image {return &Gray16 {ImageBase :_beac .copy ()}};
func (_aabd *ImageBase )GetAlpha ()[]byte {return _aabd .Alpha };type Image interface{_e .Image ;Base ()*ImageBase ;Copy ()Image ;Pix ()[]byte ;ColorAt (_eccf ,_gbde int )(_gd .Color ,error );Validate ()error ;};func _fcbd (_ggfe Gray ,_bce CMYK ,_adbg _d .Rectangle ){for _bec :=0;
_bec < _adbg .Max .X ;_bec ++{for _acd :=0;_acd < _adbg .Max .Y ;_acd ++{_cdc :=_ggfe .GrayAt (_bec ,_acd );_bce .SetCMYK (_bec ,_acd ,_dcdd (_cdc ));};};};func InDelta (expected ,current ,delta float64 )bool {_cgd :=expected -current ;if _cgd <=-delta ||_cgd >=delta {return false ;
};return true ;};func (_dgaf *NRGBA32 )ColorModel ()_gd .Model {return _gd .NRGBAModel };func _bbag (_cea RGBA ,_fgdb Gray ,_ffff _d .Rectangle ){for _degb :=0;_degb < _ffff .Max .X ;_degb ++{for _fcbga :=0;_fcbga < _ffff .Max .Y ;_fcbga ++{_dca :=_bffd (_cea .RGBAAt (_degb ,_fcbga ));
_fgdb .SetGray (_degb ,_fcbga ,_dca );};};};func (_fdd *CMYK32 )Set (x ,y int ,c _gd .Color ){_cgf :=4*(y *_fdd .Width +x );if _cgf +3>=len (_fdd .Data ){return ;};_dff :=_gd .CMYKModel .Convert (c ).(_gd .CMYK );_fdd .Data [_cgf ]=_dff .C ;_fdd .Data [_cgf +1]=_dff .M ;
_fdd .Data [_cgf +2]=_dff .Y ;_fdd .Data [_cgf +3]=_dff .K ;};var _ NRGBA =&NRGBA16 {};func (_dafb *Gray8 )Bounds ()_d .Rectangle {return _d .Rectangle {Max :_d .Point {X :_dafb .Width ,Y :_dafb .Height }};};func (_cebc *NRGBA64 )setNRGBA64 (_eceg int ,_abeb _gd .NRGBA64 ,_cfad int ){_cebc .Data [_eceg ]=uint8 (_abeb .R >>8);
_cebc .Data [_eceg +1]=uint8 (_abeb .R &0xff);_cebc .Data [_eceg +2]=uint8 (_abeb .G >>8);_cebc .Data [_eceg +3]=uint8 (_abeb .G &0xff);_cebc .Data [_eceg +4]=uint8 (_abeb .B >>8);_cebc .Data [_eceg +5]=uint8 (_abeb .B &0xff);if _cfad +1< len (_cebc .Alpha ){_cebc .Alpha [_cfad ]=uint8 (_abeb .A >>8);
_cebc .Alpha [_cfad +1]=uint8 (_abeb .A &0xff);};};func _dbgdd (_eaec CMYK ,_fded RGBA ,_aeda _d .Rectangle ){for _cebcc :=0;_cebcc < _aeda .Max .X ;_cebcc ++{for _cddba :=0;_cddba < _aeda .Max .Y ;_cddba ++{_bfc :=_eaec .CMYKAt (_cebcc ,_cddba );_fded .SetRGBA (_cebcc ,_cddba ,_deec (_bfc ));
};};};func _beeaa (_dfdd _d .Image ,_dcfbd int )(_d .Rectangle ,bool ,[]byte ){_ebfg :=_dfdd .Bounds ();var (_aac bool ;_gfgce []byte ;);switch _fabg :=_dfdd .(type ){case SMasker :_aac =_fabg .HasAlpha ();case NRGBA ,RGBA ,*_d .RGBA64 ,nrgba64 ,*_d .NYCbCrA :_gfgce =make ([]byte ,_ebfg .Max .X *_ebfg .Max .Y *_dcfbd );
case *_d .Paletted :var _afe bool ;for _ ,_cefe :=range _fabg .Palette {_egbc ,_befb ,_daca ,_dgea :=_cefe .RGBA ();if _egbc ==0&&_befb ==0&&_daca ==0&&_dgea !=0{_afe =true ;break ;};};if _afe {_gfgce =make ([]byte ,_ebfg .Max .X *_ebfg .Max .Y *_dcfbd );
};};return _ebfg ,_aac ,_gfgce ;};var _ Image =&Gray2 {};func (_bcebf *NRGBA64 )Copy ()Image {return &NRGBA64 {ImageBase :_bcebf .copy ()}};func _dgec (_gegc _gd .NRGBA )_gd .NRGBA {_gegc .R =_gegc .R >>4|(_gegc .R >>4)<<4;_gegc .G =_gegc .G >>4|(_gegc .G >>4)<<4;
_gegc .B =_gegc .B >>4|(_gegc .B >>4)<<4;return _gegc ;};func _cadf (_gcag uint )uint {var _ffdd uint ;for _gcag !=0{_gcag >>=1;_ffdd ++;};return _ffdd -1;};func (_efgb *NRGBA32 )Base ()*ImageBase {return &_efgb .ImageBase };func _eeba (_bbcb _gd .RGBA )_gd .CMYK {_gfd ,_feca ,_dabd ,_ddc :=_gd .RGBToCMYK (_bbcb .R ,_bbcb .G ,_bbcb .B );
return _gd .CMYK {C :_gfd ,M :_feca ,Y :_dabd ,K :_ddc };};func _cd (_db *Monochrome ,_bg int )(*Monochrome ,error ){if _db ==nil {return nil ,_g .New ("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064");};if _bg ==1{return _db .copy (),nil ;
};if !IsPowerOf2 (uint (_bg )){return nil ,_eb .Errorf ("\u0070\u0072\u006fvi\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006ci\u0064 \u0065x\u0070a\u006e\u0064\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_bg );};_ge :=_cfg (_bg );
return _ea (_db ,_bg ,_ge );};func (_bedd *Monochrome )RasterOperation (dx ,dy ,dw ,dh int ,op RasterOperator ,src *Monochrome ,sx ,sy int )error {return _gdff (_bedd ,dx ,dy ,dw ,dh ,op ,src ,sx ,sy );};func (_beeb *NRGBA16 )Bounds ()_d .Rectangle {return _d .Rectangle {Max :_d .Point {X :_beeb .Width ,Y :_beeb .Height }};
};func _dfc (_bb ,_geb *Monochrome ,_dgf []byte ,_eaf int )(_gbf error ){var (_fcbb ,_cbb ,_dcg ,_afg ,_aae ,_fee ,_fd ,_dd int ;_cad ,_fecc uint32 ;_ebg ,_ffb byte ;_bdb uint16 ;);_eec :=make ([]byte ,4);_ega :=make ([]byte ,4);for _dcg =0;_dcg < _bb .Height -1;
_dcg ,_afg =_dcg +2,_afg +1{_fcbb =_dcg *_bb .BytesPerLine ;_cbb =_afg *_geb .BytesPerLine ;for _aae ,_fee =0,0;_aae < _eaf ;_aae ,_fee =_aae +4,_fee +1{for _fd =0;_fd < 4;_fd ++{_dd =_fcbb +_aae +_fd ;if _dd <=len (_bb .Data )-1&&_dd < _fcbb +_bb .BytesPerLine {_eec [_fd ]=_bb .Data [_dd ];
}else {_eec [_fd ]=0x00;};_dd =_fcbb +_bb .BytesPerLine +_aae +_fd ;if _dd <=len (_bb .Data )-1&&_dd < _fcbb +(2*_bb .BytesPerLine ){_ega [_fd ]=_bb .Data [_dd ];}else {_ega [_fd ]=0x00;};};_cad =_gg .BigEndian .Uint32 (_eec );_fecc =_gg .BigEndian .Uint32 (_ega );
_fecc |=_cad ;_fecc |=_fecc <<1;_fecc &=0xaaaaaaaa;_cad =_fecc |(_fecc <<7);_ebg =byte (_cad >>24);_ffb =byte ((_cad >>8)&0xff);_dd =_cbb +_fee ;if _dd +1==len (_geb .Data )-1||_dd +1>=_cbb +_geb .BytesPerLine {_geb .Data [_dd ]=_dgf [_ebg ];}else {_bdb =(uint16 (_dgf [_ebg ])<<8)|uint16 (_dgf [_ffb ]);
if _gbf =_geb .setTwoBytes (_dd ,_bdb );_gbf !=nil {return _eb .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_dd );
};_fee ++;};};};return nil ;};func _fga (_fad ,_ccd int )*Monochrome {return &Monochrome {ImageBase :NewImageBase (_fad ,_ccd ,1,1,nil ,nil ,nil ),ModelThreshold :0x0f};};func _ddcgb (_bfea *_d .NYCbCrA ,_bcba NRGBA ,_eefg _d .Rectangle ){for _bfbeg :=0;
_bfbeg < _eefg .Max .X ;_bfbeg ++{for _cedeb :=0;_cedeb < _eefg .Max .Y ;_cedeb ++{_agdd :=_bfea .NYCbCrAAt (_bfbeg ,_cedeb );_bcba .SetNRGBA (_bfbeg ,_cedeb ,_aea (_agdd ));};};};func ImgToGray (i _d .Image )*_d .Gray {if _bdbge ,_gccd :=i .(*_d .Gray );
_gccd {return _bdbge ;};_cdb :=i .Bounds ();_afdccd :=_d .NewGray (_cdb );for _egaa :=0;_egaa < _cdb .Max .X ;_egaa ++{for _dfgb :=0;_dfgb < _cdb .Max .Y ;_dfgb ++{_cdba :=i .At (_egaa ,_dfgb );_afdccd .Set (_egaa ,_dfgb ,_cdba );};};return _afdccd ;};
func (_bbeb *NRGBA64 )SetNRGBA64 (x ,y int ,c _gd .NRGBA64 ){_degc :=(y *_bbeb .Width +x )*2;_bgdb :=_degc *3;if _bgdb +5>=len (_bbeb .Data ){return ;};_bbeb .setNRGBA64 (_bgdb ,c ,_degc );};func (_gcfe *NRGBA32 )Set (x ,y int ,c _gd .Color ){_dcegg :=y *_gcfe .Width +x ;
_gcbe :=3*_dcegg ;if _gcbe +2>=len (_gcfe .Data ){return ;};_eada :=_gd .NRGBAModel .Convert (c ).(_gd .NRGBA );_gcfe .setRGBA (_dcegg ,_eada );};type RGBA interface{RGBAAt (_eccc ,_cbed int )_gd .RGBA ;SetRGBA (_cacd ,_cddf int ,_cbea _gd .RGBA );};func _cbgd (_bcdd _d .Image )(Image ,error ){if _fbbfg ,_afbff :=_bcdd .(*NRGBA64 );
_afbff {return _fbbfg .Copy (),nil ;};_bedb ,_bdgf ,_cfff :=_beeaa (_bcdd ,2);_fffg ,_gabf :=NewImage (_bedb .Max .X ,_bedb .Max .Y ,16,3,nil ,_cfff ,nil );if _gabf !=nil {return nil ,_gabf ;};_gdgg (_bcdd ,_fffg ,_bedb );if len (_cfff )!=0&&!_bdgf {if _befd :=_gfcfe (_cfff ,_fffg );
_befd !=nil {return nil ,_befd ;};};return _fffg ,nil ;};var _ Gray =&Gray4 {};func (_ggca *Gray2 )At (x ,y int )_gd .Color {_bdbac ,_ :=_ggca .ColorAt (x ,y );return _bdbac };func _gdeg (_efec _d .Image )(Image ,error ){if _cgfg ,_efcd :=_efec .(*Gray16 );
_efcd {return _cgfg .Copy (),nil ;};_fdca :=_efec .Bounds ();_bbde ,_gbgb :=NewImage (_fdca .Max .X ,_fdca .Max .Y ,16,1,nil ,nil ,nil );if _gbgb !=nil {return nil ,_gbgb ;};_bbff (_efec ,_bbde ,_fdca );return _bbde ,nil ;};func _bbdaf (_fged _gd .Color )_gd .Color {_efbdb :=_gd .NRGBAModel .Convert (_fged ).(_gd .NRGBA );
return _dgec (_efbdb );};func (_fgc *NRGBA32 )At (x ,y int )_gd .Color {_ddbf ,_ :=_fgc .ColorAt (x ,y );return _ddbf };type ColorConverter interface{Convert (_daba _d .Image )(Image ,error );};func (_cegg *RGBA32 )ColorAt (x ,y int )(_gd .Color ,error ){return ColorAtRGBA32 (x ,y ,_cegg .Width ,_cegg .Data ,_cegg .Alpha ,_cegg .Decode );
};func ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor int ,data ,alpha []byte ,decode []float64 )(_gd .Color ,error ){switch bitsPerColor {case 4:return ColorAtNRGBA16 (x ,y ,width ,bytesPerLine ,data ,alpha ,decode );case 8:return ColorAtNRGBA32 (x ,y ,width ,data ,alpha ,decode );
case 16:return ColorAtNRGBA64 (x ,y ,width ,data ,alpha ,decode );default:return nil ,_eb .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0067\u0062\u0020b\u0069\u0074\u0073\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0061\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );
};};func _bcbfg (_bgbb *Monochrome ,_bdfbc ,_dfcc ,_fecd ,_fedg int ,_effac RasterOperator ){if _bdfbc < 0{_fecd +=_bdfbc ;_bdfbc =0;};_dbdd :=_bdfbc +_fecd -_bgbb .Width ;if _dbdd > 0{_fecd -=_dbdd ;};if _dfcc < 0{_fedg +=_dfcc ;_dfcc =0;};_face :=_dfcc +_fedg -_bgbb .Height ;
if _face > 0{_fedg -=_face ;};if _fecd <=0||_fedg <=0{return ;};if (_bdfbc &7)==0{_bge (_bgbb ,_bdfbc ,_dfcc ,_fecd ,_fedg ,_effac );}else {_bbae (_bgbb ,_bdfbc ,_dfcc ,_fecd ,_fedg ,_effac );};};func _dfbc (_ccbe ,_dbbb ,_cega byte )byte {return (_ccbe &^(_cega ))|(_dbbb &_cega )};
var _ _d .Image =&Gray8 {};var _ _d .Image =&RGBA32 {};func NewImageBase (width int ,height int ,bitsPerComponent int ,colorComponents int ,data []byte ,alpha []byte ,decode []float64 )ImageBase {_dbgb :=ImageBase {Width :width ,Height :height ,BitsPerComponent :bitsPerComponent ,ColorComponents :colorComponents ,Data :data ,Alpha :alpha ,Decode :decode ,BytesPerLine :BytesPerLine (width ,bitsPerComponent ,colorComponents )};
if data ==nil {_dbgb .Data =make ([]byte ,height *_dbgb .BytesPerLine );};return _dbgb ;};func NewImage (width ,height ,bitsPerComponent ,colorComponents int ,data ,alpha []byte ,decode []float64 )(Image ,error ){_acaeg :=NewImageBase (width ,height ,bitsPerComponent ,colorComponents ,data ,alpha ,decode );
var _cffe Image ;switch colorComponents {case 1:switch bitsPerComponent {case 1:_cffe =&Monochrome {ImageBase :_acaeg ,ModelThreshold :0x0f};case 2:_cffe =&Gray2 {ImageBase :_acaeg };case 4:_cffe =&Gray4 {ImageBase :_acaeg };case 8:_cffe =&Gray8 {ImageBase :_acaeg };
case 16:_cffe =&Gray16 {ImageBase :_acaeg };};case 3:switch bitsPerComponent {case 4:_cffe =&NRGBA16 {ImageBase :_acaeg };case 8:_cffe =&NRGBA32 {ImageBase :_acaeg };case 16:_cffe =&NRGBA64 {ImageBase :_acaeg };};case 4:_cffe =&CMYK32 {ImageBase :_acaeg };
};if _cffe ==nil {return nil ,ErrInvalidImage ;};return _cffe ,nil ;};var _ _d .Image =&Gray16 {};func _cbgc (_cbc _gd .Gray )_gd .NRGBA {return _gd .NRGBA {R :_cbc .Y ,G :_cbc .Y ,B :_cbc .Y ,A :0xff}};func _ee (_cc ,_ca *Monochrome )(_de error ){_bgb :=_ca .BytesPerLine ;
_df :=_cc .BytesPerLine ;var (_fcg byte ;_dg uint16 ;_eag ,_dfg ,_ff ,_ffe ,_cfb int ;);for _ff =0;_ff < _ca .Height ;_ff ++{_eag =_ff *_bgb ;_dfg =2*_ff *_df ;for _ffe =0;_ffe < _bgb ;_ffe ++{_fcg =_ca .Data [_eag +_ffe ];_dg =_dbg [_fcg ];_cfb =_dfg +_ffe *2;
if _cc .BytesPerLine !=_ca .BytesPerLine *2&&(_ffe +1)*2> _cc .BytesPerLine {_de =_cc .setByte (_cfb ,byte (_dg >>8));}else {_de =_cc .setTwoBytes (_cfb ,_dg );};if _de !=nil {return _de ;};};for _ffe =0;_ffe < _df ;_ffe ++{_cfb =_dfg +_df +_ffe ;_fcg =_cc .Data [_dfg +_ffe ];
if _de =_cc .setByte (_cfb ,_fcg );_de !=nil {return _de ;};};};return nil ;};type RasterOperator int ;func (_cda *ImageBase )Pix ()[]byte {return _cda .Data };func (_cefg *NRGBA16 )Base ()*ImageBase {return &_cefg .ImageBase };func _fagd (_efaa _gd .NYCbCrA )_gd .RGBA {_agfb ,_dbdg ,_bcf ,_faa :=_aea (_efaa ).RGBA ();
return _gd .RGBA {R :uint8 (_agfb >>8),G :uint8 (_dbdg >>8),B :uint8 (_bcf >>8),A :uint8 (_faa >>8)};};func _gbfa (_becb Gray ,_ecc nrgba64 ,_eafd _d .Rectangle ){for _gca :=0;_gca < _eafd .Max .X ;_gca ++{for _eafg :=0;_eafg < _eafd .Max .Y ;_eafg ++{_baf :=_eeae (_ecc .NRGBA64At (_gca ,_eafg ));
_becb .SetGray (_gca ,_eafg ,_baf );};};};func (_afbf *Gray4 )GrayAt (x ,y int )_gd .Gray {_baebf ,_ :=ColorAtGray4BPC (x ,y ,_afbf .BytesPerLine ,_afbf .Data ,_afbf .Decode );return _baebf ;};func _bbae (_dbfb *Monochrome ,_eeab ,_ddbe int ,_fbdf ,_gccg int ,_dbeaa RasterOperator ){var (_dgeg bool ;
_bgfb bool ;_eeacb int ;_dbfef int ;_fbbc int ;_dbce int ;_cdd bool ;_bdfe byte ;);_dfgd :=8-(_eeab &7);_aec :=_eadg [_dfgd ];_bdfef :=_dbfb .BytesPerLine *_ddbe +(_eeab >>3);if _fbdf < _dfgd {_dgeg =true ;_aec &=_fgeb [8-_dfgd +_fbdf ];};if !_dgeg {_eeacb =(_fbdf -_dfgd )>>3;
if _eeacb !=0{_bgfb =true ;_dbfef =_bdfef +1;};};_fbbc =(_eeab +_fbdf )&7;if !(_dgeg ||_fbbc ==0){_cdd =true ;_bdfe =_fgeb [_fbbc ];_dbce =_bdfef +1+_eeacb ;};var _ggac ,_aagd int ;switch _dbeaa {case PixClr :for _ggac =0;_ggac < _gccg ;_ggac ++{_dbfb .Data [_bdfef ]=_dfbc (_dbfb .Data [_bdfef ],0x0,_aec );
_bdfef +=_dbfb .BytesPerLine ;};if _bgfb {for _ggac =0;_ggac < _gccg ;_ggac ++{for _aagd =0;_aagd < _eeacb ;_aagd ++{_dbfb .Data [_dbfef +_aagd ]=0x0;};_dbfef +=_dbfb .BytesPerLine ;};};if _cdd {for _ggac =0;_ggac < _gccg ;_ggac ++{_dbfb .Data [_dbce ]=_dfbc (_dbfb .Data [_dbce ],0x0,_bdfe );
_dbce +=_dbfb .BytesPerLine ;};};case PixSet :for _ggac =0;_ggac < _gccg ;_ggac ++{_dbfb .Data [_bdfef ]=_dfbc (_dbfb .Data [_bdfef ],0xff,_aec );_bdfef +=_dbfb .BytesPerLine ;};if _bgfb {for _ggac =0;_ggac < _gccg ;_ggac ++{for _aagd =0;_aagd < _eeacb ;
_aagd ++{_dbfb .Data [_dbfef +_aagd ]=0xff;};_dbfef +=_dbfb .BytesPerLine ;};};if _cdd {for _ggac =0;_ggac < _gccg ;_ggac ++{_dbfb .Data [_dbce ]=_dfbc (_dbfb .Data [_dbce ],0xff,_bdfe );_dbce +=_dbfb .BytesPerLine ;};};case PixNotDst :for _ggac =0;_ggac < _gccg ;
_ggac ++{_dbfb .Data [_bdfef ]=_dfbc (_dbfb .Data [_bdfef ],^_dbfb .Data [_bdfef ],_aec );_bdfef +=_dbfb .BytesPerLine ;};if _bgfb {for _ggac =0;_ggac < _gccg ;_ggac ++{for _aagd =0;_aagd < _eeacb ;_aagd ++{_dbfb .Data [_dbfef +_aagd ]=^(_dbfb .Data [_dbfef +_aagd ]);
};_dbfef +=_dbfb .BytesPerLine ;};};if _cdd {for _ggac =0;_ggac < _gccg ;_ggac ++{_dbfb .Data [_dbce ]=_dfbc (_dbfb .Data [_dbce ],^_dbfb .Data [_dbce ],_bdfe );_dbce +=_dbfb .BytesPerLine ;};};};};var _ Gray =&Gray16 {};func (_facgd *Gray8 )Histogram ()(_afbae [256]int ){for _cadee :=0;
_cadee < len (_facgd .Data );_cadee ++{_afbae [_facgd .Data [_cadee ]]++;};return _afbae ;};func (_aagg *Gray2 )ColorModel ()_gd .Model {return Gray2Model };func (_bcc *CMYK32 )Validate ()error {if len (_bcc .Data )!=4*_bcc .Width *_bcc .Height {return _g .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func _aegfa (_ggdg _d .Image ,_ddea uint8 )*_d .Gray {_ffbe :=_ggdg .Bounds ();_cbaad :=_d .NewGray (_ffbe );var (_abfb _gd .Color ;_gcega _gd .Gray ;);for _dfff :=0;_dfff < _ffbe .Max .X ;_dfff ++{for _gcceg :=0;_gcceg < _ffbe .Max .Y ;
_gcceg ++{_abfb =_ggdg .At (_dfff ,_gcceg );_cbaad .Set (_dfff ,_gcceg ,_abfb );_gcega =_cbaad .GrayAt (_dfff ,_gcceg );_cbaad .SetGray (_dfff ,_gcceg ,_gd .Gray {Y :_febdg (_gcega .Y ,_ddea )});};};return _cbaad ;};func _ecgc (_gdafd _d .Image )(Image ,error ){if _dgcb ,_bcfcf :=_gdafd .(*Gray8 );
_bcfcf {return _dgcb .Copy (),nil ;};_bdde :=_gdafd .Bounds ();_dgdf ,_bab :=NewImage (_bdde .Max .X ,_bdde .Max .Y ,8,1,nil ,nil ,nil );if _bab !=nil {return nil ,_bab ;};_bbff (_gdafd ,_dgdf ,_bdde );return _dgdf ,nil ;};func _gdff (_ecgg *Monochrome ,_ggbe ,_cced ,_fcee ,_gbcc int ,_egeb RasterOperator ,_cdebg *Monochrome ,_fbbf ,_gddae int )error {if _ecgg ==nil {return _g .New ("\u006e\u0069\u006c\u0020\u0027\u0064\u0065\u0073\u0074\u0027\u0020\u0042i\u0074\u006d\u0061\u0070");
};if _egeb ==PixDst {return nil ;};switch _egeb {case PixClr ,PixSet ,PixNotDst :_bcbfg (_ecgg ,_ggbe ,_cced ,_fcee ,_gbcc ,_egeb );return nil ;};if _cdebg ==nil {_fe .Log .Debug ("\u0052a\u0073\u0074e\u0072\u004f\u0070\u0065r\u0061\u0074\u0069o\u006e\u0020\u0073\u006f\u0075\u0072\u0063\u0065\u0020bi\u0074\u006d\u0061p\u0020\u0069s\u0020\u006e\u006f\u0074\u0020\u0064e\u0066\u0069n\u0065\u0064");
return _g .New ("\u006e\u0069l\u0020\u0027\u0073r\u0063\u0027\u0020\u0062\u0069\u0074\u006d\u0061\u0070");};if _adc :=_faad (_ecgg ,_ggbe ,_cced ,_fcee ,_gbcc ,_egeb ,_cdebg ,_fbbf ,_gddae );_adc !=nil {return _adc ;};return nil ;};func (_ggfb *Gray16 )Bounds ()_d .Rectangle {return _d .Rectangle {Max :_d .Point {X :_ggfb .Width ,Y :_ggfb .Height }};
};func ColorAtCMYK (x ,y ,width int ,data []byte ,decode []float64 )(_gd .CMYK ,error ){_age :=4*(y *width +x );if _age +3>=len (data ){return _gd .CMYK {},_eb .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};C :=data [_age ]&0xff;M :=data [_age +1]&0xff;Y :=data [_age +2]&0xff;K :=data [_age +3]&0xff;if len (decode )==8{C =uint8 (uint32 (LinearInterpolate (float64 (C ),0,255,decode [0],decode [1]))&0xff);M =uint8 (uint32 (LinearInterpolate (float64 (M ),0,255,decode [2],decode [3]))&0xff);
Y =uint8 (uint32 (LinearInterpolate (float64 (Y ),0,255,decode [4],decode [5]))&0xff);K =uint8 (uint32 (LinearInterpolate (float64 (K ),0,255,decode [6],decode [7]))&0xff);};return _gd .CMYK {C :C ,M :M ,Y :Y ,K :K },nil ;};const (_efga shift =iota ;_agge ;
);func _gbagb (_dge _gd .Gray )_gd .Gray {_gdf :=_dge .Y >>6;_gdf |=_gdf <<2;_dge .Y =_gdf |_gdf <<4;return _dge ;};func (_dfcea *NRGBA16 )Copy ()Image {return &NRGBA16 {ImageBase :_dfcea .copy ()}};func (_ecee *Gray2 )Set (x ,y int ,c _gd .Color ){if x >=_ecee .Width ||y >=_ecee .Height {return ;
};_gcd :=Gray2Model .Convert (c ).(_gd .Gray );_bfbe :=y *_ecee .BytesPerLine ;_ggc :=_bfbe +(x >>2);_fagg :=_gcd .Y >>6;_ecee .Data [_ggc ]=(_ecee .Data [_ggc ]&(^(0xc0>>uint (2*((x )&3)))))|(_fagg <<uint (6-2*(x &3)));};func (_cgca *Monochrome )AddPadding ()(_ggbd error ){if _ffbg :=((_cgca .Width *_cgca .Height )+7)>>3;
len (_cgca .Data )< _ffbg {return _eb .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064a\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002e\u0020\u0054\u0068\u0065\u0020\u0064\u0061t\u0061\u0020s\u0068\u006fu\u006c\u0064\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0020\u0061\u0074 l\u0065\u0061\u0073\u0074\u003a\u0020\u0027\u0025\u0064'\u0020\u0062\u0079\u0074\u0065\u0073",len (_cgca .Data ),_ffbg );
};_edc :=_cgca .Width %8;if _edc ==0{return nil ;};_efag :=_cgca .Width /8;_bea :=_be .NewReader (_cgca .Data );_dege :=make ([]byte ,_cgca .Height *_cgca .BytesPerLine );_ebab :=_be .NewWriterMSB (_dege );_bcec :=make ([]byte ,_efag );var (_fage int ;
_bcfe uint64 ;);for _fage =0;_fage < _cgca .Height ;_fage ++{if _ ,_ggbd =_bea .Read (_bcec );_ggbd !=nil {return _ggbd ;};if _ ,_ggbd =_ebab .Write (_bcec );_ggbd !=nil {return _ggbd ;};if _bcfe ,_ggbd =_bea .ReadBits (byte (_edc ));_ggbd !=nil {return _ggbd ;
};if _ggbd =_ebab .WriteByte (byte (_bcfe )<<uint (8-_edc ));_ggbd !=nil {return _ggbd ;};};_cgca .Data =_ebab .Data ();return nil ;};func MonochromeModel (threshold uint8 )_gd .Model {return monochromeModel (threshold )};func (_fdg *Monochrome )Set (x ,y int ,c _gd .Color ){_aafg :=y *_fdg .BytesPerLine +x >>3;
if _aafg > len (_fdg .Data )-1{return ;};_gfaf :=_fdg .ColorModel ().Convert (c ).(_gd .Gray );_fdg .setGray (x ,_gfaf ,_aafg );};func (_bgeg *RGBA32 )RGBAAt (x ,y int )_gd .RGBA {_bdda ,_ :=ColorAtRGBA32 (x ,y ,_bgeg .Width ,_bgeg .Data ,_bgeg .Alpha ,_bgeg .Decode );
return _bdda ;};func (_ffdb *NRGBA16 )Validate ()error {if len (_ffdb .Data )!=3*_ffdb .Width *_ffdb .Height /2{return _g .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func (_dgeb *Gray2 )GrayAt (x ,y int )_gd .Gray {_fae ,_ :=ColorAtGray2BPC (x ,y ,_dgeb .BytesPerLine ,_dgeb .Data ,_dgeb .Decode );return _fae ;};func _cgag (_bged _d .Image )(Image ,error ){if _ebfc ,_acca :=_bged .(*RGBA32 );_acca {return _ebfc .Copy (),nil ;
};_bafa ,_ffecb ,_agagd :=_beeaa (_bged ,1);_fcba :=&RGBA32 {ImageBase :NewImageBase (_bafa .Max .X ,_bafa .Max .Y ,8,3,nil ,_agagd ,nil )};_fbgf (_bged ,_fcba ,_bafa );if len (_agagd )!=0&&!_ffecb {if _gggg :=_gfcfe (_agagd ,_fcba );_gggg !=nil {return nil ,_gggg ;
};};return _fcba ,nil ;};func IsPowerOf2 (n uint )bool {return n > 0&&(n &(n -1))==0};func (_aef *CMYK32 )CMYKAt (x ,y int )_gd .CMYK {_baeb ,_ :=ColorAtCMYK (x ,y ,_aef .Width ,_aef .Data ,_aef .Decode );return _baeb ;};func ColorAtNRGBA16 (x ,y ,width ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_gd .NRGBA ,error ){_add :=y *bytesPerLine +x *3/2;
if _add +1>=len (data ){return _gd .NRGBA {},_gdfg (x ,y );};const (_cegbd =0xf;_bfgef =uint8 (0xff););_cbgaf :=_bfgef ;if alpha !=nil {_eebcd :=y *BytesPerLine (width ,4,1);if _eebcd < len (alpha ){if x %2==0{_cbgaf =(alpha [_eebcd ]>>uint (4))&_cegbd ;
}else {_cbgaf =alpha [_eebcd ]&_cegbd ;};_cbgaf |=_cbgaf <<4;};};var _acgg ,_adaf ,_bacb uint8 ;if x *3%2==0{_acgg =(data [_add ]>>uint (4))&_cegbd ;_adaf =data [_add ]&_cegbd ;_bacb =(data [_add +1]>>uint (4))&_cegbd ;}else {_acgg =data [_add ]&_cegbd ;
_adaf =(data [_add +1]>>uint (4))&_cegbd ;_bacb =data [_add +1]&_cegbd ;};if len (decode )==6{_acgg =uint8 (uint32 (LinearInterpolate (float64 (_acgg ),0,15,decode [0],decode [1]))&0xf);_adaf =uint8 (uint32 (LinearInterpolate (float64 (_adaf ),0,15,decode [2],decode [3]))&0xf);
_bacb =uint8 (uint32 (LinearInterpolate (float64 (_bacb ),0,15,decode [4],decode [5]))&0xf);};return _gd .NRGBA {R :(_acgg <<4)|(_acgg &0xf),G :(_adaf <<4)|(_adaf &0xf),B :(_bacb <<4)|(_bacb &0xf),A :_cbgaf },nil ;};func _adad (_fdbb CMYK ,_efdea Gray ,_ebef _d .Rectangle ){for _cgfca :=0;
_cgfca < _ebef .Max .X ;_cgfca ++{for _eedga :=0;_eedga < _ebef .Max .Y ;_eedga ++{_fdce :=_dcbe (_fdbb .CMYKAt (_cgfca ,_eedga ));_efdea .SetGray (_cgfca ,_eedga ,_fdce );};};};func _ccag (_dccg *_d .Gray ,_dgeab uint8 )*_d .Gray {_cedg :=_dccg .Bounds ();
_cdce :=_d .NewGray (_cedg );for _agac :=0;_agac < _cedg .Dx ();_agac ++{for _bcfg :=0;_bcfg < _cedg .Dy ();_bcfg ++{_bfcg :=_dccg .GrayAt (_agac ,_bcfg );_cdce .SetGray (_agac ,_bcfg ,_gd .Gray {Y :_febdg (_bfcg .Y ,_dgeab )});};};return _cdce ;};func _bge (_fccd *Monochrome ,_efgf ,_eega int ,_dcfc ,_bcg int ,_dad RasterOperator ){var (_dcc int ;
_dabef byte ;_feccb ,_bafg int ;_afdeg int ;);_fedd :=_dcfc >>3;_faee :=_dcfc &7;if _faee > 0{_dabef =_fgeb [_faee ];};_dcc =_fccd .BytesPerLine *_eega +(_efgf >>3);switch _dad {case PixClr :for _feccb =0;_feccb < _bcg ;_feccb ++{_afdeg =_dcc +_feccb *_fccd .BytesPerLine ;
for _bafg =0;_bafg < _fedd ;_bafg ++{_fccd .Data [_afdeg ]=0x0;_afdeg ++;};if _faee > 0{_fccd .Data [_afdeg ]=_dfbc (_fccd .Data [_afdeg ],0x0,_dabef );};};case PixSet :for _feccb =0;_feccb < _bcg ;_feccb ++{_afdeg =_dcc +_feccb *_fccd .BytesPerLine ;for _bafg =0;
_bafg < _fedd ;_bafg ++{_fccd .Data [_afdeg ]=0xff;_afdeg ++;};if _faee > 0{_fccd .Data [_afdeg ]=_dfbc (_fccd .Data [_afdeg ],0xff,_dabef );};};case PixNotDst :for _feccb =0;_feccb < _bcg ;_feccb ++{_afdeg =_dcc +_feccb *_fccd .BytesPerLine ;for _bafg =0;
_bafg < _fedd ;_bafg ++{_fccd .Data [_afdeg ]=^_fccd .Data [_afdeg ];_afdeg ++;};if _faee > 0{_fccd .Data [_afdeg ]=_dfbc (_fccd .Data [_afdeg ],^_fccd .Data [_afdeg ],_dabef );};};};};func _ead (_eaef NRGBA ,_febd CMYK ,_cec _d .Rectangle ){for _dfba :=0;
_dfba < _cec .Max .X ;_dfba ++{for _bccc :=0;_bccc < _cec .Max .Y ;_bccc ++{_fbdg :=_eaef .NRGBAAt (_dfba ,_bccc );_febd .SetCMYK (_dfba ,_bccc ,_dbga (_fbdg ));};};};func (_cgdc *NRGBA64 )NRGBA64At (x ,y int )_gd .NRGBA64 {_cbaa ,_ :=ColorAtNRGBA64 (x ,y ,_cgdc .Width ,_cgdc .Data ,_cgdc .Alpha ,_cgdc .Decode );
return _cbaa ;};const (PixSrc RasterOperator =0xc;PixDst RasterOperator =0xa;PixNotSrc RasterOperator =0x3;PixNotDst RasterOperator =0x5;PixClr RasterOperator =0x0;PixSet RasterOperator =0xf;PixSrcOrDst RasterOperator =0xe;PixSrcAndDst RasterOperator =0x8;
PixSrcXorDst RasterOperator =0x6;PixNotSrcOrDst RasterOperator =0xb;PixNotSrcAndDst RasterOperator =0x2;PixSrcOrNotDst RasterOperator =0xd;PixSrcAndNotDst RasterOperator =0x4;PixNotPixSrcOrDst RasterOperator =0x1;PixNotPixSrcAndDst RasterOperator =0x7;
PixNotPixSrcXorDst RasterOperator =0x9;PixPaint =PixSrcOrDst ;PixSubtract =PixNotSrcAndDst ;PixMask =PixSrcAndDst ;);func (_ggg *ImageBase )setByte (_cefd int ,_cdae byte )error {if _cefd > len (_ggg .Data )-1{return _g .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_ggg .Data [_cefd ]=_cdae ;return nil ;};func (_cgb *CMYK32 )Copy ()Image {return &CMYK32 {ImageBase :_cgb .copy ()}};type Gray interface{GrayAt (_aefa ,_bcee int )_gd .Gray ;SetGray (_gadg ,_cecg int ,_efeg _gd .Gray );};func (_fff *CMYK32 )ColorModel ()_gd .Model {return _gd .CMYKModel };
func _degag (_ebb nrgba64 ,_agdc NRGBA ,_fdeb _d .Rectangle ){for _gfe :=0;_gfe < _fdeb .Max .X ;_gfe ++{for _caad :=0;_caad < _fdeb .Max .Y ;_caad ++{_caaf :=_ebb .NRGBA64At (_gfe ,_caad );_agdc .SetNRGBA (_gfe ,_caad ,_bba (_caaf ));};};};func (_ecd *CMYK32 )At (x ,y int )_gd .Color {_fbc ,_ :=_ecd .ColorAt (x ,y );
return _fbc };func _edfa (_ggeb _gd .Color )_gd .Color {_ddce :=_gd .GrayModel .Convert (_ggeb ).(_gd .Gray );return _gbagb (_ddce );};func (_dfae *Gray8 )ColorAt (x ,y int )(_gd .Color ,error ){return ColorAtGray8BPC (x ,y ,_dfae .BytesPerLine ,_dfae .Data ,_dfae .Decode );
};var (_fgeb =[]byte {0x00,0x80,0xC0,0xE0,0xF0,0xF8,0xFC,0xFE,0xFF};_eadg =[]byte {0x00,0x01,0x03,0x07,0x0F,0x1F,0x3F,0x7F,0xFF};);func _caddd (_afc int ,_gfg int )int {if _afc < _gfg {return _afc ;};return _gfg ;};func _af (_gef ,_ed *Monochrome )(_ag error ){_ffa :=_ed .BytesPerLine ;
_aca :=_gef .BytesPerLine ;_ab :=_ed .BytesPerLine *4-_gef .BytesPerLine ;var (_dba ,_abg byte ;_gee uint32 ;_dfb ,_fb ,_afb ,_ga ,_ggf ,_dbc ,_bgbe int ;);for _afb =0;_afb < _ed .Height ;_afb ++{_dfb =_afb *_ffa ;_fb =4*_afb *_aca ;for _ga =0;_ga < _ffa ;
_ga ++{_dba =_ed .Data [_dfb +_ga ];_gee =_eegb [_dba ];_dbc =_fb +_ga *4;if _ab !=0&&(_ga +1)*4> _gef .BytesPerLine {for _ggf =_ab ;_ggf > 0;_ggf --{_abg =byte ((_gee >>uint (_ggf *8))&0xff);_bgbe =_dbc +(_ab -_ggf );if _ag =_gef .setByte (_bgbe ,_abg );
_ag !=nil {return _ag ;};};}else if _ag =_gef .setFourBytes (_dbc ,_gee );_ag !=nil {return _ag ;};if _ag =_gef .setFourBytes (_fb +_ga *4,_eegb [_ed .Data [_dfb +_ga ]]);_ag !=nil {return _ag ;};};for _ggf =1;_ggf < 4;_ggf ++{for _ga =0;_ga < _aca ;_ga ++{if _ag =_gef .setByte (_fb +_ggf *_aca +_ga ,_gef .Data [_fb +_ga ]);
_ag !=nil {return _ag ;};};};};return nil ;};func ColorAtGray4BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_gd .Gray ,error ){_ebcd :=y *bytesPerLine +x >>1;if _ebcd >=len (data ){return _gd .Gray {},_eb .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_bgg :=data [_ebcd ]>>uint (4-(x &1)*4)&0xf;if len (decode )==2{_bgg =uint8 (uint32 (LinearInterpolate (float64 (_bgg ),0,15,decode [0],decode [1]))&0xf);};return _gd .Gray {Y :_bgg *17&0xff},nil ;};func (_bcdc *Gray4 )Copy ()Image {return &Gray4 {ImageBase :_bcdc .copy ()}};
func ColorAtGray8BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_gd .Gray ,error ){_cccb :=y *bytesPerLine +x ;if _cccb >=len (data ){return _gd .Gray {},_eb .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_bcef :=data [_cccb ];if len (decode )==2{_bcef =uint8 (uint32 (LinearInterpolate (float64 (_bcef ),0,255,decode [0],decode [1]))&0xff);};return _gd .Gray {Y :_bcef },nil ;};func _gdfg (_fafg int ,_gcafc int )error {return _eb .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",_fafg ,_gcafc );
};func (_bceec *ImageBase )MakeAlpha (){_bceec .newAlpha ()};func (_dega *NRGBA32 )Bounds ()_d .Rectangle {return _d .Rectangle {Max :_d .Point {X :_dega .Width ,Y :_dega .Height }};};func AddDataPadding (width ,height ,bitsPerComponent ,colorComponents int ,data []byte )([]byte ,error ){_gfgc :=BytesPerLine (width ,bitsPerComponent ,colorComponents );
if _gfgc ==width *colorComponents *bitsPerComponent /8{return data ,nil ;};_feec :=width *colorComponents *bitsPerComponent ;_fdaa :=_gfgc *8;_bef :=8-(_fdaa -_feec );_fdcb :=_be .NewReader (data );_ebfb :=_gfgc -1;_bbad :=make ([]byte ,_ebfb );_ffdca :=make ([]byte ,height *_gfgc );
_cebd :=_be .NewWriterMSB (_ffdca );var _fgeg uint64 ;var _bbcbb error ;for _dage :=0;_dage < height ;_dage ++{_ ,_bbcbb =_fdcb .Read (_bbad );if _bbcbb !=nil {return nil ,_bbcbb ;};_ ,_bbcbb =_cebd .Write (_bbad );if _bbcbb !=nil {return nil ,_bbcbb ;
};_fgeg ,_bbcbb =_fdcb .ReadBits (byte (_bef ));if _bbcbb !=nil {return nil ,_bbcbb ;};_ ,_bbcbb =_cebd .WriteBits (_fgeg ,_bef );if _bbcbb !=nil {return nil ,_bbcbb ;};_cebd .FinishByte ();};return _ffdca ,nil ;};func (_ffed *Gray8 )Copy ()Image {return &Gray8 {ImageBase :_ffed .copy ()}};
func LinearInterpolate (x ,xmin ,xmax ,ymin ,ymax float64 )float64 {if _f .Abs (xmax -xmin )< 0.000001{return ymin ;};_aafa :=ymin +(x -xmin )*(ymax -ymin )/(xmax -xmin );return _aafa ;};type monochromeModel uint8 ;var _ Image =&NRGBA64 {};func _cfe ()(_gad [256]uint16 ){for _eagd :=0;
_eagd < 256;_eagd ++{if _eagd &0x01!=0{_gad [_eagd ]|=0x3;};if _eagd &0x02!=0{_gad [_eagd ]|=0xc;};if _eagd &0x04!=0{_gad [_eagd ]|=0x30;};if _eagd &0x08!=0{_gad [_eagd ]|=0xc0;};if _eagd &0x10!=0{_gad [_eagd ]|=0x300;};if _eagd &0x20!=0{_gad [_eagd ]|=0xc00;
};if _eagd &0x40!=0{_gad [_eagd ]|=0x3000;};if _eagd &0x80!=0{_gad [_eagd ]|=0xc000;};};return _gad ;};func _dcd (_caf ,_cca *Monochrome ,_gdb []byte ,_fde int )(_cefa error ){var (_dgd ,_ccad ,_ege ,_bdg ,_dfe ,_fbdd ,_bga ,_ged int ;_fbe ,_ae ,_eged ,_gged uint32 ;
_cade ,_bbb byte ;_ffbc uint16 ;);_gac :=make ([]byte ,4);_dbf :=make ([]byte ,4);for _ege =0;_ege < _caf .Height -1;_ege ,_bdg =_ege +2,_bdg +1{_dgd =_ege *_caf .BytesPerLine ;_ccad =_bdg *_cca .BytesPerLine ;for _dfe ,_fbdd =0,0;_dfe < _fde ;_dfe ,_fbdd =_dfe +4,_fbdd +1{for _bga =0;
_bga < 4;_bga ++{_ged =_dgd +_dfe +_bga ;if _ged <=len (_caf .Data )-1&&_ged < _dgd +_caf .BytesPerLine {_gac [_bga ]=_caf .Data [_ged ];}else {_gac [_bga ]=0x00;};_ged =_dgd +_caf .BytesPerLine +_dfe +_bga ;if _ged <=len (_caf .Data )-1&&_ged < _dgd +(2*_caf .BytesPerLine ){_dbf [_bga ]=_caf .Data [_ged ];
}else {_dbf [_bga ]=0x00;};};_fbe =_gg .BigEndian .Uint32 (_gac );_ae =_gg .BigEndian .Uint32 (_dbf );_eged =_fbe &_ae ;_eged |=_eged <<1;_gged =_fbe |_ae ;_gged &=_gged <<1;_ae =_eged |_gged ;_ae &=0xaaaaaaaa;_fbe =_ae |(_ae <<7);_cade =byte (_fbe >>24);
_bbb =byte ((_fbe >>8)&0xff);_ged =_ccad +_fbdd ;if _ged +1==len (_cca .Data )-1||_ged +1>=_ccad +_cca .BytesPerLine {if _cefa =_cca .setByte (_ged ,_gdb [_cade ]);_cefa !=nil {return _eb .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_ged );};
}else {_ffbc =(uint16 (_gdb [_cade ])<<8)|uint16 (_gdb [_bbb ]);if _cefa =_cca .setTwoBytes (_ged ,_ffbc );_cefa !=nil {return _eb .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_ged );
};_fbdd ++;};};};return nil ;};type Gray2 struct{ImageBase };func (_fdbf *Gray4 )ColorAt (x ,y int )(_gd .Color ,error ){return ColorAtGray4BPC (x ,y ,_fdbf .BytesPerLine ,_fdbf .Data ,_fdbf .Decode );};func AutoThresholdTriangle (histogram [256]int )uint8 {var _ecda ,_fgdga ,_cffd ,_baa int ;
for _edgc :=0;_edgc < len (histogram );_edgc ++{if histogram [_edgc ]> 0{_ecda =_edgc ;break ;};};if _ecda > 0{_ecda --;};for _ccbc :=255;_ccbc > 0;_ccbc --{if histogram [_ccbc ]> 0{_baa =_ccbc ;break ;};};if _baa < 255{_baa ++;};for _gccef :=0;_gccef < 256;
_gccef ++{if histogram [_gccef ]> _fgdga {_cffd =_gccef ;_fgdga =histogram [_gccef ];};};var _eabc bool ;if (_cffd -_ecda )< (_baa -_cffd ){_eabc =true ;var _agdg int ;_begc :=255;for _agdg < _begc {_agcd :=histogram [_agdg ];histogram [_agdg ]=histogram [_begc ];
histogram [_begc ]=_agcd ;_agdg ++;_begc --;};_ecda =255-_baa ;_cffd =255-_cffd ;};if _ecda ==_cffd {return uint8 (_ecda );};_cgfgf :=float64 (histogram [_cffd ]);_afae :=float64 (_ecda -_cffd );_ggfg :=_f .Sqrt (_cgfgf *_cgfgf +_afae *_afae );_cgfgf /=_ggfg ;
_afae /=_ggfg ;_ggfg =_cgfgf *float64 (_ecda )+_afae *float64 (histogram [_ecda ]);_cedeg :=_ecda ;var _dfdda float64 ;for _beae :=_ecda +1;_beae <=_cffd ;_beae ++{_abbc :=_cgfgf *float64 (_beae )+_afae *float64 (histogram [_beae ])-_ggfg ;if _abbc > _dfdda {_cedeg =_beae ;
_dfdda =_abbc ;};};_cedeg --;if _eabc {var _ggebfc int ;_aega :=255;for _ggebfc < _aega {_egg :=histogram [_ggebfc ];histogram [_ggebfc ]=histogram [_aega ];histogram [_aega ]=_egg ;_ggebfc ++;_aega --;};return uint8 (255-_cedeg );};return uint8 (_cedeg );
};func (_dbeda *NRGBA64 )ColorAt (x ,y int )(_gd .Color ,error ){return ColorAtNRGBA64 (x ,y ,_dbeda .Width ,_dbeda .Data ,_dbeda .Alpha ,_dbeda .Decode );};type Gray16 struct{ImageBase };func (_bcb *Gray2 )ColorAt (x ,y int )(_gd .Color ,error ){return ColorAtGray2BPC (x ,y ,_bcb .BytesPerLine ,_bcb .Data ,_bcb .Decode );
};var ErrInvalidImage =_g .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
func (_bfeg *NRGBA32 )ColorAt (x ,y int )(_gd .Color ,error ){return ColorAtNRGBA32 (x ,y ,_bfeg .Width ,_bfeg .Data ,_bfeg .Alpha ,_bfeg .Decode );};var _ _d .Image =&NRGBA16 {};var _ Gray =&Gray2 {};func ColorAtGray2BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_gd .Gray ,error ){_fgdc :=y *bytesPerLine +x >>2;
if _fgdc >=len (data ){return _gd .Gray {},_eb .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_fcf :=data [_fgdc ]>>uint (6-(x &3)*2)&3;if len (decode )==2{_fcf =uint8 (uint32 (LinearInterpolate (float64 (_fcf ),0,3.0,decode [0],decode [1]))&3);};return _gd .Gray {Y :_fcf *85},nil ;};func _faad (_begb *Monochrome ,_ceae ,_gebb int ,_acbe ,_gfff int ,_bcbg RasterOperator ,_dbfg *Monochrome ,_gcae ,_abae int )error {var _aegf ,_edef ,_dcfb ,_edfe int ;
if _ceae < 0{_gcae -=_ceae ;_acbe +=_ceae ;_ceae =0;};if _gcae < 0{_ceae -=_gcae ;_acbe +=_gcae ;_gcae =0;};_aegf =_ceae +_acbe -_begb .Width ;if _aegf > 0{_acbe -=_aegf ;};_edef =_gcae +_acbe -_dbfg .Width ;if _edef > 0{_acbe -=_edef ;};if _gebb < 0{_abae -=_gebb ;
_gfff +=_gebb ;_gebb =0;};if _abae < 0{_gebb -=_abae ;_gfff +=_abae ;_abae =0;};_dcfb =_gebb +_gfff -_begb .Height ;if _dcfb > 0{_gfff -=_dcfb ;};_edfe =_abae +_gfff -_dbfg .Height ;if _edfe > 0{_gfff -=_edfe ;};if _acbe <=0||_gfff <=0{return nil ;};var _cdeg error ;
switch {case _ceae &7==0&&_gcae &7==0:_cdeg =_adadd (_begb ,_ceae ,_gebb ,_acbe ,_gfff ,_bcbg ,_dbfg ,_gcae ,_abae );case _ceae &7==_gcae &7:_cdeg =_cbdf (_begb ,_ceae ,_gebb ,_acbe ,_gfff ,_bcbg ,_dbfg ,_gcae ,_abae );default:_cdeg =_dece (_begb ,_ceae ,_gebb ,_acbe ,_gfff ,_bcbg ,_dbfg ,_gcae ,_abae );
};if _cdeg !=nil {return _cdeg ;};return nil ;};func (_abgf *NRGBA64 )Base ()*ImageBase {return &_abgf .ImageBase };func (_bbf *Monochrome )Scale (scale float64 )(*Monochrome ,error ){var _ddg bool ;_cgfc :=scale ;if scale < 1{_cgfc =1/scale ;_ddg =true ;
};_gddd :=NextPowerOf2 (uint (_cgfc ));if InDelta (float64 (_gddd ),_cgfc ,0.001){if _ddg {return _bbf .ReduceBinary (_cgfc );};return _bbf .ExpandBinary (int (_gddd ));};_effg :=int (_f .RoundToEven (float64 (_bbf .Width )*scale ));_dbec :=int (_f .RoundToEven (float64 (_bbf .Height )*scale ));
return _bbf .ScaleLow (_effg ,_dbec );};func (_gdbd colorConverter )Convert (src _d .Image )(Image ,error ){return _gdbd ._caff (src )};func _dbga (_facg _gd .NRGBA )_gd .CMYK {_dbd ,_becc ,_dda ,_ :=_facg .RGBA ();_cabf ,_ddd ,_dde ,_dgdd :=_gd .RGBToCMYK (uint8 (_dbd >>8),uint8 (_becc >>8),uint8 (_dda >>8));
return _gd .CMYK {C :_cabf ,M :_ddd ,Y :_dde ,K :_dgdd };};func (_fdcf *Monochrome )InverseData ()error {return _fdcf .RasterOperation (0,0,_fdcf .Width ,_fdcf .Height ,PixNotDst ,nil ,0,0);};var _ _d .Image =&Gray2 {};func (_ace *Gray16 )ColorAt (x ,y int )(_gd .Color ,error ){return ColorAtGray16BPC (x ,y ,_ace .BytesPerLine ,_ace .Data ,_ace .Decode );
};func (_cgbf *NRGBA32 )Validate ()error {if len (_cgbf .Data )!=3*_cgbf .Width *_cgbf .Height {return _g .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine int ,data []byte ,decode []float64 )(_gd .Color ,error ){switch bitsPerColor {case 1:return ColorAtGray1BPC (x ,y ,bytesPerLine ,data ,decode );case 2:return ColorAtGray2BPC (x ,y ,bytesPerLine ,data ,decode );
case 4:return ColorAtGray4BPC (x ,y ,bytesPerLine ,data ,decode );case 8:return ColorAtGray8BPC (x ,y ,bytesPerLine ,data ,decode );case 16:return ColorAtGray16BPC (x ,y ,bytesPerLine ,data ,decode );default:return nil ,_eb .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0067\u0072\u0061\u0079\u0020\u0073c\u0061\u006c\u0065\u0020\u0062\u0069\u0074s\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020a\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );
};};func (_fcdb *ImageBase )HasAlpha ()bool {if _fcdb .Alpha ==nil {return false ;};for _abf :=range _fcdb .Alpha {if _fcdb .Alpha [_abf ]!=0xff{return true ;};};return false ;};func (_dcde *ImageBase )getByte (_bdff int )(byte ,error ){if _bdff > len (_dcde .Data )-1||_bdff < 0{return 0,_eb .Errorf ("\u0069\u006e\u0064\u0065x:\u0020\u0025\u0064\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006eg\u0065",_bdff );
};return _dcde .Data [_bdff ],nil ;};func _fbgf (_adcf _d .Image ,_dfaf Image ,_egdg _d .Rectangle ){if _gbbf ,_dfea :=_adcf .(SMasker );_dfea &&_gbbf .HasAlpha (){_dfaf .(SMasker ).MakeAlpha ();};switch _cefab :=_adcf .(type ){case Gray :_gdgd (_cefab ,_dfaf .(RGBA ),_egdg );
case NRGBA :_fedc (_cefab ,_dfaf .(RGBA ),_egdg );case *_d .NYCbCrA :_egcb (_cefab ,_dfaf .(RGBA ),_egdg );case CMYK :_dbgdd (_cefab ,_dfaf .(RGBA ),_egdg );case RGBA :_abfc (_cefab ,_dfaf .(RGBA ),_egdg );case nrgba64 :_ceca (_cefab ,_dfaf .(RGBA ),_egdg );
default:_gbfc (_adcf ,_dfaf ,_egdg );};};var _ Image =&Gray4 {};func (_afaf *ImageBase )setEightPartlyBytes (_gbea ,_gecf int ,_gaa uint64 )(_cbag error ){var (_effdf byte ;_efg int ;);for _cecb :=1;_cecb <=_gecf ;_cecb ++{_efg =64-_cecb *8;_effdf =byte (_gaa >>uint (_efg )&0xff);
if _cbag =_afaf .setByte (_gbea +_cecb -1,_effdf );_cbag !=nil {return _cbag ;};};_fffa :=_afaf .BytesPerLine *8-_afaf .Width ;if _fffa ==0{return nil ;};_efg -=8;_effdf =byte (_gaa >>uint (_efg )&0xff)<<uint (_fffa );if _cbag =_afaf .setByte (_gbea +_gecf ,_effdf );
_cbag !=nil {return _cbag ;};return nil ;};func (_fbgg *Gray16 )Base ()*ImageBase {return &_fbgg .ImageBase };func (_fea *RGBA32 )Bounds ()_d .Rectangle {return _d .Rectangle {Max :_d .Point {X :_fea .Width ,Y :_fea .Height }};};type NRGBA32 struct{ImageBase };
func (_eeb *CMYK32 )Bounds ()_d .Rectangle {return _d .Rectangle {Max :_d .Point {X :_eeb .Width ,Y :_eeb .Height }};};func (_faae *NRGBA16 )setNRGBA (_aff ,_cfca ,_afdcc int ,_ddfe _gd .NRGBA ){if _aff *3%2==0{_faae .Data [_afdcc ]=(_ddfe .R >>4)<<4|(_ddfe .G >>4);
_faae .Data [_afdcc +1]=(_ddfe .B >>4)<<4|(_faae .Data [_afdcc +1]&0xf);}else {_faae .Data [_afdcc ]=(_faae .Data [_afdcc ]&0xf0)|(_ddfe .R >>4);_faae .Data [_afdcc +1]=(_ddfe .G >>4)<<4|(_ddfe .B >>4);};if _faae .Alpha !=nil {_cdde :=_cfca *BytesPerLine (_faae .Width ,4,1);
if _cdde < len (_faae .Alpha ){if _aff %2==0{_faae .Alpha [_cdde ]=(_ddfe .A >>uint (4))<<uint (4)|(_faae .Alpha [_afdcc ]&0xf);}else {_faae .Alpha [_cdde ]=(_faae .Alpha [_cdde ]&0xf0)|(_ddfe .A >>uint (4));};};};};func ColorAt (x ,y ,width ,bitsPerColor ,colorComponents ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_gd .Color ,error ){switch colorComponents {case 1:return ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine ,data ,decode );
case 3:return ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor ,data ,alpha ,decode );case 4:return ColorAtCMYK (x ,y ,width ,data ,decode );default:return nil ,_eb .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0063o\u006c\u006f\u0072\u0020\u0063\u006f\u006dp\u006f\u006e\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0064",colorComponents );
};};var (_dbg =_cfe ();_eegb =_bd ();_ef =_cff (););func (_agca *Gray16 )At (x ,y int )_gd .Color {_efac ,_ :=_agca .ColorAt (x ,y );return _efac };func _gdca (_gbg _gd .NRGBA )_gd .RGBA {_eecb ,_cadd ,_daa ,_afa :=_gbg .RGBA ();return _gd .RGBA {R :uint8 (_eecb >>8),G :uint8 (_cadd >>8),B :uint8 (_daa >>8),A :uint8 (_afa >>8)};
};func _dgegf (_ggcge _d .Image )(Image ,error ){if _ffc ,_bcgf :=_ggcge .(*NRGBA16 );_bcgf {return _ffc .Copy (),nil ;};_adbf :=_ggcge .Bounds ();_bbbc ,_agbb :=NewImage (_adbf .Max .X ,_adbf .Max .Y ,4,3,nil ,nil ,nil );if _agbb !=nil {return nil ,_agbb ;
};_becca (_ggcge ,_bbbc ,_adbf );return _bbbc ,nil ;};func (_dcdf *Monochrome )ScaleLow (width ,height int )(*Monochrome ,error ){if width < 0||height < 0{return nil ,_g .New ("\u0070\u0072\u006f\u0076\u0069\u0064e\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0069\u0064t\u0068\u0020\u0061\u006e\u0064\u0020\u0068e\u0069\u0067\u0068\u0074");
};_eegf :=_fga (width ,height );_bfb :=make ([]int ,height );_fgdf :=make ([]int ,width );_fddca :=float64 (_dcdf .Width )/float64 (width );_fceg :=float64 (_dcdf .Height )/float64 (height );for _gdee :=0;_gdee < height ;_gdee ++{_bfb [_gdee ]=int (_f .Min (_fceg *float64 (_gdee )+0.5,float64 (_dcdf .Height -1)));
};for _gbdf :=0;_gbdf < width ;_gbdf ++{_fgdf [_gbdf ]=int (_f .Min (_fddca *float64 (_gbdf )+0.5,float64 (_dcdf .Width -1)));};_eeda :=-1;_fbdb :=byte (0);for _aefb :=0;_aefb < height ;_aefb ++{_eedg :=_bfb [_aefb ]*_dcdf .BytesPerLine ;_fda :=_aefb *_eegf .BytesPerLine ;
for _dbdge :=0;_dbdge < width ;_dbdge ++{_ada :=_fgdf [_dbdge ];if _ada !=_eeda {_fbdb =_dcdf .getBit (_eedg ,_ada );if _fbdb !=0{_eegf .setBit (_fda ,_dbdge );};_eeda =_ada ;}else {if _fbdb !=0{_eegf .setBit (_fda ,_dbdge );};};};};return _eegf ,nil ;
};func _aaggf (_efef *_d .Gray16 ,_ecabc uint8 )*_d .Gray {_dbbe :=_efef .Bounds ();_fdfd :=_d .NewGray (_dbbe );for _ecge :=0;_ecge < _dbbe .Dx ();_ecge ++{for _abdd :=0;_abdd < _dbbe .Dy ();_abdd ++{_cedc :=_efef .Gray16At (_ecge ,_abdd );_fdfd .SetGray (_ecge ,_abdd ,_gd .Gray {Y :_febdg (uint8 (_cedc .Y /256),_ecabc )});
};};return _fdfd ;};var _ _d .Image =&Gray4 {};func (_bacf *Gray4 )Set (x ,y int ,c _gd .Color ){if x >=_bacf .Width ||y >=_bacf .Height {return ;};_fcdg :=Gray4Model .Convert (c ).(_gd .Gray );_bacf .setGray (x ,y ,_fcdg );};func (_fbf *Monochrome )ReduceBinary (factor float64 )(*Monochrome ,error ){_bdba :=_cadf (uint (factor ));
if !IsPowerOf2 (uint (factor )){_bdba ++;};_dcgfd :=make ([]int ,_bdba );for _agdf :=range _dcgfd {_dcgfd [_agdf ]=4;};_eeca ,_cbe :=_ffg (_fbf ,_dcgfd ...);if _cbe !=nil {return nil ,_cbe ;};return _eeca ,nil ;};func (_bac *Monochrome )ResolveDecode ()error {if len (_bac .Decode )!=2{return nil ;
};if _bac .Decode [0]==1&&_bac .Decode [1]==0{if _gadd :=_bac .InverseData ();_gadd !=nil {return _gadd ;};_bac .Decode =nil ;};return nil ;};type Monochrome struct{ImageBase ;ModelThreshold uint8 ;};func (_aabe *NRGBA32 )Copy ()Image {return &NRGBA32 {ImageBase :_aabe .copy ()}};
func (_ccaf *Gray2 )Copy ()Image {return &Gray2 {ImageBase :_ccaf .copy ()}};type nrgba64 interface{NRGBA64At (_ecgcb ,_efdegc int )_gd .NRGBA64 ;SetNRGBA64 (_adf ,_gfgaf int ,_bbeg _gd .NRGBA64 );};var _ Image =&NRGBA32 {};var _ Image =&CMYK32 {};type SMasker interface{HasAlpha ()bool ;
GetAlpha ()[]byte ;MakeAlpha ();};var _ NRGBA =&NRGBA32 {};func (_dgb *Gray8 )ColorModel ()_gd .Model {return _gd .GrayModel };func _abfc (_geea ,_bca RGBA ,_edcfe _d .Rectangle ){for _adgb :=0;_adgb < _edcfe .Max .X ;_adgb ++{for _abfd :=0;_abfd < _edcfe .Max .Y ;
_abfd ++{_bca .SetRGBA (_adgb ,_abfd ,_geea .RGBAAt (_adgb ,_abfd ));};};};func BytesPerLine (width ,bitsPerComponent ,colorComponents int )int {return ((width *bitsPerComponent )*colorComponents +7)>>3;};var _ecf [256]uint8 ;func (_gfdac *NRGBA64 )ColorModel ()_gd .Model {return _gd .NRGBA64Model };
func ImgToBinary (i _d .Image ,threshold uint8 )*_d .Gray {switch _fbcd :=i .(type ){case *_d .Gray :if _egdef (_fbcd ){return _fbcd ;};return _ccag (_fbcd ,threshold );case *_d .Gray16 :return _aaggf (_fbcd ,threshold );default:return _aegfa (_fbcd ,threshold );
};};func (_dcddf *Gray4 )Validate ()error {if len (_dcddf .Data )!=_dcddf .Height *_dcddf .BytesPerLine {return ErrInvalidImage ;};return nil ;};func IsGrayImgBlackAndWhite (i *_d .Gray )bool {return _egdef (i )};func _ea (_a *Monochrome ,_cdg int ,_cg []uint )(*Monochrome ,error ){_ad :=_cdg *_a .Width ;
_aa :=_cdg *_a .Height ;_gb :=_fga (_ad ,_aa );for _eba ,_ac :=range _cg {var _cf error ;switch _ac {case 2:_cf =_ee (_gb ,_a );case 4:_cf =_af (_gb ,_a );case 8:_cf =_aaf (_gb ,_a );};if _cf !=nil {return nil ,_cf ;};if _eba !=len (_cg )-1{_a =_gb .copy ();
};};return _gb ,nil ;};func _aaf (_feb ,_bee *Monochrome )(_dc error ){_cce :=_bee .BytesPerLine ;_eae :=_feb .BytesPerLine ;var _eg ,_cfc ,_agf ,_dbe ,_ce int ;for _agf =0;_agf < _bee .Height ;_agf ++{_eg =_agf *_cce ;_cfc =8*_agf *_eae ;for _dbe =0;_dbe < _cce ;
_dbe ++{if _dc =_feb .setEightBytes (_cfc +_dbe *8,_ef [_bee .Data [_eg +_dbe ]]);_dc !=nil {return _dc ;};};for _ce =1;_ce < 8;_ce ++{for _dbe =0;_dbe < _eae ;_dbe ++{if _dc =_feb .setByte (_cfc +_ce *_eae +_dbe ,_feb .Data [_cfc +_dbe ]);_dc !=nil {return _dc ;
};};};};return nil ;};func (_gbcb *ImageBase )newAlpha (){_fabf :=BytesPerLine (_gbcb .Width ,_gbcb .BitsPerComponent ,1);_gbcb .Alpha =make ([]byte ,_gbcb .Height *_fabf );};func _febdg (_feccg ,_bdfa uint8 )uint8 {if _feccg < _bdfa {return 255;};return 0;
};type Gray8 struct{ImageBase };func (_dgfe *Gray8 )Set (x ,y int ,c _gd .Color ){_dggc :=y *_dgfe .BytesPerLine +x ;if _dggc > len (_dgfe .Data )-1{return ;};_gaeb :=_gd .GrayModel .Convert (c );_dgfe .Data [_dggc ]=_gaeb .(_gd .Gray ).Y ;};func (_dggb *Gray2 )Histogram ()(_ddf [256]int ){for _bdgc :=0;
_bdgc < _dggb .Width ;_bdgc ++{for _bcbf :=0;_bcbf < _dggb .Height ;_bcbf ++{_ddf [_dggb .GrayAt (_bdgc ,_bcbf ).Y ]++;};};return _ddf ;};func (_abed *ImageBase )setEightBytes (_gddad int ,_abfe uint64 )error {_ffdc :=_abed .BytesPerLine -(_gddad %_abed .BytesPerLine );
if _abed .BytesPerLine !=_abed .Width >>3{_ffdc --;};if _ffdc >=8{return _abed .setEightFullBytes (_gddad ,_abfe );};return _abed .setEightPartlyBytes (_gddad ,_ffdc ,_abfe );};func (_gceg *CMYK32 )SetCMYK (x ,y int ,c _gd .CMYK ){_cac :=4*(y *_gceg .Width +x );
if _cac +3>=len (_gceg .Data ){return ;};_gceg .Data [_cac ]=c .C ;_gceg .Data [_cac +1]=c .M ;_gceg .Data [_cac +2]=c .Y ;_gceg .Data [_cac +3]=c .K ;};func _gfcfe (_cbec []byte ,_bbbce Image )error {_bgcbe :=true ;for _debb :=0;_debb < len (_cbec );_debb ++{if _cbec [_debb ]!=0xff{_bgcbe =false ;
break ;};};if _bgcbe {switch _caec :=_bbbce .(type ){case *NRGBA32 :_caec .Alpha =nil ;case *NRGBA64 :_caec .Alpha =nil ;default:return _eb .Errorf ("i\u006ete\u0072n\u0061l\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020i\u006d\u0061\u0067\u0065\u0020s\u0068\u006f\u0075l\u0064\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0074\u0079\u0070e\u0020\u002a\u004eRGB\u0041\u0033\u0032\u0020\u006f\u0072 \u002a\u004e\u0052\u0047\u0042\u0041\u0036\u0034\u0020\u0062\u0075\u0074 \u0069s\u003a\u0020\u0025\u0054",_bbbce );
};};return nil ;};func (_cggf *Gray2 )SetGray (x ,y int ,gray _gd .Gray ){_ccb :=_gbagb (gray );_eee :=y *_cggf .BytesPerLine ;_dfcb :=_eee +(x >>2);if _dfcb >=len (_cggf .Data ){return ;};_ebf :=_ccb .Y >>6;_cggf .Data [_dfcb ]=(_cggf .Data [_dfcb ]&(^(0xc0>>uint (2*((x )&3)))))|(_ebf <<uint (6-2*(x &3)));
};func _dcdd (_ccg _gd .Gray )_gd .CMYK {return _gd .CMYK {K :0xff-_ccg .Y }};func (_gbag *Monochrome )Validate ()error {if len (_gbag .Data )!=_gbag .Height *_gbag .BytesPerLine {return ErrInvalidImage ;};return nil ;};func _ggb (_gbb ,_dce int ,_agd []byte )*Monochrome {_fce :=_fga (_gbb ,_dce );
_fce .Data =_agd ;return _fce ;};var (Gray2Model =_gd .ModelFunc (_edfa );Gray4Model =_gd .ModelFunc (_gcf );NRGBA16Model =_gd .ModelFunc (_bbdaf ););func _geg (_fdb ,_cbbd *Monochrome ,_cdgc []byte ,_fbb int )(_gda error ){var (_cee ,_ede ,_dbfa ,_gbd ,_bcd ,_gff ,_cegb ,_bfg int ;
_dcgf ,_gce uint32 ;_egaf ,_cdec byte ;_cefc uint16 ;);_aad :=make ([]byte ,4);_aaeg :=make ([]byte ,4);for _dbfa =0;_dbfa < _fdb .Height -1;_dbfa ,_gbd =_dbfa +2,_gbd +1{_cee =_dbfa *_fdb .BytesPerLine ;_ede =_gbd *_cbbd .BytesPerLine ;for _bcd ,_gff =0,0;
_bcd < _fbb ;_bcd ,_gff =_bcd +4,_gff +1{for _cegb =0;_cegb < 4;_cegb ++{_bfg =_cee +_bcd +_cegb ;if _bfg <=len (_fdb .Data )-1&&_bfg < _cee +_fdb .BytesPerLine {_aad [_cegb ]=_fdb .Data [_bfg ];}else {_aad [_cegb ]=0x00;};_bfg =_cee +_fdb .BytesPerLine +_bcd +_cegb ;
if _bfg <=len (_fdb .Data )-1&&_bfg < _cee +(2*_fdb .BytesPerLine ){_aaeg [_cegb ]=_fdb .Data [_bfg ];}else {_aaeg [_cegb ]=0x00;};};_dcgf =_gg .BigEndian .Uint32 (_aad );_gce =_gg .BigEndian .Uint32 (_aaeg );_gce &=_dcgf ;_gce &=_gce <<1;_gce &=0xaaaaaaaa;
_dcgf =_gce |(_gce <<7);_egaf =byte (_dcgf >>24);_cdec =byte ((_dcgf >>8)&0xff);_bfg =_ede +_gff ;if _bfg +1==len (_cbbd .Data )-1||_bfg +1>=_ede +_cbbd .BytesPerLine {_cbbd .Data [_bfg ]=_cdgc [_egaf ];if _gda =_cbbd .setByte (_bfg ,_cdgc [_egaf ]);_gda !=nil {return _eb .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_bfg );
};}else {_cefc =(uint16 (_cdgc [_egaf ])<<8)|uint16 (_cdgc [_cdec ]);if _gda =_cbbd .setTwoBytes (_bfg ,_cefc );_gda !=nil {return _eb .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_bfg );
};_gff ++;};};};return nil ;};func _dece (_cgda *Monochrome ,_abaee ,_fdbbd ,_dfab ,_gacb int ,_bbgd RasterOperator ,_egac *Monochrome ,_cbcd ,_agbd int )error {var (_bdbaa bool ;_ecde bool ;_ebdc byte ;_gfdf int ;_cacaa int ;_adbc int ;_dbed int ;_bgaf bool ;
_fcdgd int ;_gfda int ;_fgdgf int ;_cffb bool ;_gcegc byte ;_dffa int ;_dgebf int ;_dbba int ;_ddae byte ;_fced int ;_ccdf int ;_gadf uint ;_faadf uint ;_dfcbg byte ;_bdge shift ;_dfdf bool ;_bcfee bool ;_ggebf ,_bbda int ;);if _cbcd &7!=0{_ccdf =8-(_cbcd &7);
};if _abaee &7!=0{_cacaa =8-(_abaee &7);};if _ccdf ==0&&_cacaa ==0{_dfcbg =_eadg [0];}else {if _cacaa > _ccdf {_gadf =uint (_cacaa -_ccdf );}else {_gadf =uint (8-(_ccdf -_cacaa ));};_faadf =8-_gadf ;_dfcbg =_eadg [_gadf ];};if (_abaee &7)!=0{_bdbaa =true ;
_gfdf =8-(_abaee &7);_ebdc =_eadg [_gfdf ];_adbc =_cgda .BytesPerLine *_fdbbd +(_abaee >>3);_dbed =_egac .BytesPerLine *_agbd +(_cbcd >>3);_fced =8-(_cbcd &7);if _gfdf > _fced {_bdge =_efga ;if _dfab >=_ccdf {_dfdf =true ;};}else {_bdge =_agge ;};};if _dfab < _gfdf {_ecde =true ;
_ebdc &=_fgeb [8-_gfdf +_dfab ];};if !_ecde {_fcdgd =(_dfab -_gfdf )>>3;if _fcdgd !=0{_bgaf =true ;_gfda =_cgda .BytesPerLine *_fdbbd +((_abaee +_cacaa )>>3);_fgdgf =_egac .BytesPerLine *_agbd +((_cbcd +_cacaa )>>3);};};_dffa =(_abaee +_dfab )&7;if !(_ecde ||_dffa ==0){_cffb =true ;
_gcegc =_fgeb [_dffa ];_dgebf =_cgda .BytesPerLine *_fdbbd +((_abaee +_cacaa )>>3)+_fcdgd ;_dbba =_egac .BytesPerLine *_agbd +((_cbcd +_cacaa )>>3)+_fcdgd ;if _dffa > int (_faadf ){_bcfee =true ;};};switch _bbgd {case PixSrc :if _bdbaa {for _ggebf =0;_ggebf < _gacb ;
_ggebf ++{if _bdge ==_efga {_ddae =_egac .Data [_dbed ]<<_gadf ;if _dfdf {_ddae =_dfbc (_ddae ,_egac .Data [_dbed +1]>>_faadf ,_dfcbg );};}else {_ddae =_egac .Data [_dbed ]>>_faadf ;};_cgda .Data [_adbc ]=_dfbc (_cgda .Data [_adbc ],_ddae ,_ebdc );_adbc +=_cgda .BytesPerLine ;
_dbed +=_egac .BytesPerLine ;};};if _bgaf {for _ggebf =0;_ggebf < _gacb ;_ggebf ++{for _bbda =0;_bbda < _fcdgd ;_bbda ++{_ddae =_dfbc (_egac .Data [_fgdgf +_bbda ]<<_gadf ,_egac .Data [_fgdgf +_bbda +1]>>_faadf ,_dfcbg );_cgda .Data [_gfda +_bbda ]=_ddae ;
};_gfda +=_cgda .BytesPerLine ;_fgdgf +=_egac .BytesPerLine ;};};if _cffb {for _ggebf =0;_ggebf < _gacb ;_ggebf ++{_ddae =_egac .Data [_dbba ]<<_gadf ;if _bcfee {_ddae =_dfbc (_ddae ,_egac .Data [_dbba +1]>>_faadf ,_dfcbg );};_cgda .Data [_dgebf ]=_dfbc (_cgda .Data [_dgebf ],_ddae ,_gcegc );
_dgebf +=_cgda .BytesPerLine ;_dbba +=_egac .BytesPerLine ;};};case PixNotSrc :if _bdbaa {for _ggebf =0;_ggebf < _gacb ;_ggebf ++{if _bdge ==_efga {_ddae =_egac .Data [_dbed ]<<_gadf ;if _dfdf {_ddae =_dfbc (_ddae ,_egac .Data [_dbed +1]>>_faadf ,_dfcbg );
};}else {_ddae =_egac .Data [_dbed ]>>_faadf ;};_cgda .Data [_adbc ]=_dfbc (_cgda .Data [_adbc ],^_ddae ,_ebdc );_adbc +=_cgda .BytesPerLine ;_dbed +=_egac .BytesPerLine ;};};if _bgaf {for _ggebf =0;_ggebf < _gacb ;_ggebf ++{for _bbda =0;_bbda < _fcdgd ;
_bbda ++{_ddae =_dfbc (_egac .Data [_fgdgf +_bbda ]<<_gadf ,_egac .Data [_fgdgf +_bbda +1]>>_faadf ,_dfcbg );_cgda .Data [_gfda +_bbda ]=^_ddae ;};_gfda +=_cgda .BytesPerLine ;_fgdgf +=_egac .BytesPerLine ;};};if _cffb {for _ggebf =0;_ggebf < _gacb ;_ggebf ++{_ddae =_egac .Data [_dbba ]<<_gadf ;
if _bcfee {_ddae =_dfbc (_ddae ,_egac .Data [_dbba +1]>>_faadf ,_dfcbg );};_cgda .Data [_dgebf ]=_dfbc (_cgda .Data [_dgebf ],^_ddae ,_gcegc );_dgebf +=_cgda .BytesPerLine ;_dbba +=_egac .BytesPerLine ;};};case PixSrcOrDst :if _bdbaa {for _ggebf =0;_ggebf < _gacb ;
_ggebf ++{if _bdge ==_efga {_ddae =_egac .Data [_dbed ]<<_gadf ;if _dfdf {_ddae =_dfbc (_ddae ,_egac .Data [_dbed +1]>>_faadf ,_dfcbg );};}else {_ddae =_egac .Data [_dbed ]>>_faadf ;};_cgda .Data [_adbc ]=_dfbc (_cgda .Data [_adbc ],_ddae |_cgda .Data [_adbc ],_ebdc );
_adbc +=_cgda .BytesPerLine ;_dbed +=_egac .BytesPerLine ;};};if _bgaf {for _ggebf =0;_ggebf < _gacb ;_ggebf ++{for _bbda =0;_bbda < _fcdgd ;_bbda ++{_ddae =_dfbc (_egac .Data [_fgdgf +_bbda ]<<_gadf ,_egac .Data [_fgdgf +_bbda +1]>>_faadf ,_dfcbg );_cgda .Data [_gfda +_bbda ]|=_ddae ;
};_gfda +=_cgda .BytesPerLine ;_fgdgf +=_egac .BytesPerLine ;};};if _cffb {for _ggebf =0;_ggebf < _gacb ;_ggebf ++{_ddae =_egac .Data [_dbba ]<<_gadf ;if _bcfee {_ddae =_dfbc (_ddae ,_egac .Data [_dbba +1]>>_faadf ,_dfcbg );};_cgda .Data [_dgebf ]=_dfbc (_cgda .Data [_dgebf ],_ddae |_cgda .Data [_dgebf ],_gcegc );
_dgebf +=_cgda .BytesPerLine ;_dbba +=_egac .BytesPerLine ;};};case PixSrcAndDst :if _bdbaa {for _ggebf =0;_ggebf < _gacb ;_ggebf ++{if _bdge ==_efga {_ddae =_egac .Data [_dbed ]<<_gadf ;if _dfdf {_ddae =_dfbc (_ddae ,_egac .Data [_dbed +1]>>_faadf ,_dfcbg );
};}else {_ddae =_egac .Data [_dbed ]>>_faadf ;};_cgda .Data [_adbc ]=_dfbc (_cgda .Data [_adbc ],_ddae &_cgda .Data [_adbc ],_ebdc );_adbc +=_cgda .BytesPerLine ;_dbed +=_egac .BytesPerLine ;};};if _bgaf {for _ggebf =0;_ggebf < _gacb ;_ggebf ++{for _bbda =0;
_bbda < _fcdgd ;_bbda ++{_ddae =_dfbc (_egac .Data [_fgdgf +_bbda ]<<_gadf ,_egac .Data [_fgdgf +_bbda +1]>>_faadf ,_dfcbg );_cgda .Data [_gfda +_bbda ]&=_ddae ;};_gfda +=_cgda .BytesPerLine ;_fgdgf +=_egac .BytesPerLine ;};};if _cffb {for _ggebf =0;_ggebf < _gacb ;
_ggebf ++{_ddae =_egac .Data [_dbba ]<<_gadf ;if _bcfee {_ddae =_dfbc (_ddae ,_egac .Data [_dbba +1]>>_faadf ,_dfcbg );};_cgda .Data [_dgebf ]=_dfbc (_cgda .Data [_dgebf ],_ddae &_cgda .Data [_dgebf ],_gcegc );_dgebf +=_cgda .BytesPerLine ;_dbba +=_egac .BytesPerLine ;
};};case PixSrcXorDst :if _bdbaa {for _ggebf =0;_ggebf < _gacb ;_ggebf ++{if _bdge ==_efga {_ddae =_egac .Data [_dbed ]<<_gadf ;if _dfdf {_ddae =_dfbc (_ddae ,_egac .Data [_dbed +1]>>_faadf ,_dfcbg );};}else {_ddae =_egac .Data [_dbed ]>>_faadf ;};_cgda .Data [_adbc ]=_dfbc (_cgda .Data [_adbc ],_ddae ^_cgda .Data [_adbc ],_ebdc );
_adbc +=_cgda .BytesPerLine ;_dbed +=_egac .BytesPerLine ;};};if _bgaf {for _ggebf =0;_ggebf < _gacb ;_ggebf ++{for _bbda =0;_bbda < _fcdgd ;_bbda ++{_ddae =_dfbc (_egac .Data [_fgdgf +_bbda ]<<_gadf ,_egac .Data [_fgdgf +_bbda +1]>>_faadf ,_dfcbg );_cgda .Data [_gfda +_bbda ]^=_ddae ;
};_gfda +=_cgda .BytesPerLine ;_fgdgf +=_egac .BytesPerLine ;};};if _cffb {for _ggebf =0;_ggebf < _gacb ;_ggebf ++{_ddae =_egac .Data [_dbba ]<<_gadf ;if _bcfee {_ddae =_dfbc (_ddae ,_egac .Data [_dbba +1]>>_faadf ,_dfcbg );};_cgda .Data [_dgebf ]=_dfbc (_cgda .Data [_dgebf ],_ddae ^_cgda .Data [_dgebf ],_gcegc );
_dgebf +=_cgda .BytesPerLine ;_dbba +=_egac .BytesPerLine ;};};case PixNotSrcOrDst :if _bdbaa {for _ggebf =0;_ggebf < _gacb ;_ggebf ++{if _bdge ==_efga {_ddae =_egac .Data [_dbed ]<<_gadf ;if _dfdf {_ddae =_dfbc (_ddae ,_egac .Data [_dbed +1]>>_faadf ,_dfcbg );
};}else {_ddae =_egac .Data [_dbed ]>>_faadf ;};_cgda .Data [_adbc ]=_dfbc (_cgda .Data [_adbc ],^_ddae |_cgda .Data [_adbc ],_ebdc );_adbc +=_cgda .BytesPerLine ;_dbed +=_egac .BytesPerLine ;};};if _bgaf {for _ggebf =0;_ggebf < _gacb ;_ggebf ++{for _bbda =0;
_bbda < _fcdgd ;_bbda ++{_ddae =_dfbc (_egac .Data [_fgdgf +_bbda ]<<_gadf ,_egac .Data [_fgdgf +_bbda +1]>>_faadf ,_dfcbg );_cgda .Data [_gfda +_bbda ]|=^_ddae ;};_gfda +=_cgda .BytesPerLine ;_fgdgf +=_egac .BytesPerLine ;};};if _cffb {for _ggebf =0;_ggebf < _gacb ;
_ggebf ++{_ddae =_egac .Data [_dbba ]<<_gadf ;if _bcfee {_ddae =_dfbc (_ddae ,_egac .Data [_dbba +1]>>_faadf ,_dfcbg );};_cgda .Data [_dgebf ]=_dfbc (_cgda .Data [_dgebf ],^_ddae |_cgda .Data [_dgebf ],_gcegc );_dgebf +=_cgda .BytesPerLine ;_dbba +=_egac .BytesPerLine ;
};};case PixNotSrcAndDst :if _bdbaa {for _ggebf =0;_ggebf < _gacb ;_ggebf ++{if _bdge ==_efga {_ddae =_egac .Data [_dbed ]<<_gadf ;if _dfdf {_ddae =_dfbc (_ddae ,_egac .Data [_dbed +1]>>_faadf ,_dfcbg );};}else {_ddae =_egac .Data [_dbed ]>>_faadf ;};_cgda .Data [_adbc ]=_dfbc (_cgda .Data [_adbc ],^_ddae &_cgda .Data [_adbc ],_ebdc );
_adbc +=_cgda .BytesPerLine ;_dbed +=_egac .BytesPerLine ;};};if _bgaf {for _ggebf =0;_ggebf < _gacb ;_ggebf ++{for _bbda =0;_bbda < _fcdgd ;_bbda ++{_ddae =_dfbc (_egac .Data [_fgdgf +_bbda ]<<_gadf ,_egac .Data [_fgdgf +_bbda +1]>>_faadf ,_dfcbg );_cgda .Data [_gfda +_bbda ]&=^_ddae ;
};_gfda +=_cgda .BytesPerLine ;_fgdgf +=_egac .BytesPerLine ;};};if _cffb {for _ggebf =0;_ggebf < _gacb ;_ggebf ++{_ddae =_egac .Data [_dbba ]<<_gadf ;if _bcfee {_ddae =_dfbc (_ddae ,_egac .Data [_dbba +1]>>_faadf ,_dfcbg );};_cgda .Data [_dgebf ]=_dfbc (_cgda .Data [_dgebf ],^_ddae &_cgda .Data [_dgebf ],_gcegc );
_dgebf +=_cgda .BytesPerLine ;_dbba +=_egac .BytesPerLine ;};};case PixSrcOrNotDst :if _bdbaa {for _ggebf =0;_ggebf < _gacb ;_ggebf ++{if _bdge ==_efga {_ddae =_egac .Data [_dbed ]<<_gadf ;if _dfdf {_ddae =_dfbc (_ddae ,_egac .Data [_dbed +1]>>_faadf ,_dfcbg );
};}else {_ddae =_egac .Data [_dbed ]>>_faadf ;};_cgda .Data [_adbc ]=_dfbc (_cgda .Data [_adbc ],_ddae |^_cgda .Data [_adbc ],_ebdc );_adbc +=_cgda .BytesPerLine ;_dbed +=_egac .BytesPerLine ;};};if _bgaf {for _ggebf =0;_ggebf < _gacb ;_ggebf ++{for _bbda =0;
_bbda < _fcdgd ;_bbda ++{_ddae =_dfbc (_egac .Data [_fgdgf +_bbda ]<<_gadf ,_egac .Data [_fgdgf +_bbda +1]>>_faadf ,_dfcbg );_cgda .Data [_gfda +_bbda ]=_ddae |^_cgda .Data [_gfda +_bbda ];};_gfda +=_cgda .BytesPerLine ;_fgdgf +=_egac .BytesPerLine ;};
};if _cffb {for _ggebf =0;_ggebf < _gacb ;_ggebf ++{_ddae =_egac .Data [_dbba ]<<_gadf ;if _bcfee {_ddae =_dfbc (_ddae ,_egac .Data [_dbba +1]>>_faadf ,_dfcbg );};_cgda .Data [_dgebf ]=_dfbc (_cgda .Data [_dgebf ],_ddae |^_cgda .Data [_dgebf ],_gcegc );
_dgebf +=_cgda .BytesPerLine ;_dbba +=_egac .BytesPerLine ;};};case PixSrcAndNotDst :if _bdbaa {for _ggebf =0;_ggebf < _gacb ;_ggebf ++{if _bdge ==_efga {_ddae =_egac .Data [_dbed ]<<_gadf ;if _dfdf {_ddae =_dfbc (_ddae ,_egac .Data [_dbed +1]>>_faadf ,_dfcbg );
};}else {_ddae =_egac .Data [_dbed ]>>_faadf ;};_cgda .Data [_adbc ]=_dfbc (_cgda .Data [_adbc ],_ddae &^_cgda .Data [_adbc ],_ebdc );_adbc +=_cgda .BytesPerLine ;_dbed +=_egac .BytesPerLine ;};};if _bgaf {for _ggebf =0;_ggebf < _gacb ;_ggebf ++{for _bbda =0;
_bbda < _fcdgd ;_bbda ++{_ddae =_dfbc (_egac .Data [_fgdgf +_bbda ]<<_gadf ,_egac .Data [_fgdgf +_bbda +1]>>_faadf ,_dfcbg );_cgda .Data [_gfda +_bbda ]=_ddae &^_cgda .Data [_gfda +_bbda ];};_gfda +=_cgda .BytesPerLine ;_fgdgf +=_egac .BytesPerLine ;};
};if _cffb {for _ggebf =0;_ggebf < _gacb ;_ggebf ++{_ddae =_egac .Data [_dbba ]<<_gadf ;if _bcfee {_ddae =_dfbc (_ddae ,_egac .Data [_dbba +1]>>_faadf ,_dfcbg );};_cgda .Data [_dgebf ]=_dfbc (_cgda .Data [_dgebf ],_ddae &^_cgda .Data [_dgebf ],_gcegc );
_dgebf +=_cgda .BytesPerLine ;_dbba +=_egac .BytesPerLine ;};};case PixNotPixSrcOrDst :if _bdbaa {for _ggebf =0;_ggebf < _gacb ;_ggebf ++{if _bdge ==_efga {_ddae =_egac .Data [_dbed ]<<_gadf ;if _dfdf {_ddae =_dfbc (_ddae ,_egac .Data [_dbed +1]>>_faadf ,_dfcbg );
};}else {_ddae =_egac .Data [_dbed ]>>_faadf ;};_cgda .Data [_adbc ]=_dfbc (_cgda .Data [_adbc ],^(_ddae |_cgda .Data [_adbc ]),_ebdc );_adbc +=_cgda .BytesPerLine ;_dbed +=_egac .BytesPerLine ;};};if _bgaf {for _ggebf =0;_ggebf < _gacb ;_ggebf ++{for _bbda =0;
_bbda < _fcdgd ;_bbda ++{_ddae =_dfbc (_egac .Data [_fgdgf +_bbda ]<<_gadf ,_egac .Data [_fgdgf +_bbda +1]>>_faadf ,_dfcbg );_cgda .Data [_gfda +_bbda ]=^(_ddae |_cgda .Data [_gfda +_bbda ]);};_gfda +=_cgda .BytesPerLine ;_fgdgf +=_egac .BytesPerLine ;
};};if _cffb {for _ggebf =0;_ggebf < _gacb ;_ggebf ++{_ddae =_egac .Data [_dbba ]<<_gadf ;if _bcfee {_ddae =_dfbc (_ddae ,_egac .Data [_dbba +1]>>_faadf ,_dfcbg );};_cgda .Data [_dgebf ]=_dfbc (_cgda .Data [_dgebf ],^(_ddae |_cgda .Data [_dgebf ]),_gcegc );
_dgebf +=_cgda .BytesPerLine ;_dbba +=_egac .BytesPerLine ;};};case PixNotPixSrcAndDst :if _bdbaa {for _ggebf =0;_ggebf < _gacb ;_ggebf ++{if _bdge ==_efga {_ddae =_egac .Data [_dbed ]<<_gadf ;if _dfdf {_ddae =_dfbc (_ddae ,_egac .Data [_dbed +1]>>_faadf ,_dfcbg );
};}else {_ddae =_egac .Data [_dbed ]>>_faadf ;};_cgda .Data [_adbc ]=_dfbc (_cgda .Data [_adbc ],^(_ddae &_cgda .Data [_adbc ]),_ebdc );_adbc +=_cgda .BytesPerLine ;_dbed +=_egac .BytesPerLine ;};};if _bgaf {for _ggebf =0;_ggebf < _gacb ;_ggebf ++{for _bbda =0;
_bbda < _fcdgd ;_bbda ++{_ddae =_dfbc (_egac .Data [_fgdgf +_bbda ]<<_gadf ,_egac .Data [_fgdgf +_bbda +1]>>_faadf ,_dfcbg );_cgda .Data [_gfda +_bbda ]=^(_ddae &_cgda .Data [_gfda +_bbda ]);};_gfda +=_cgda .BytesPerLine ;_fgdgf +=_egac .BytesPerLine ;
};};if _cffb {for _ggebf =0;_ggebf < _gacb ;_ggebf ++{_ddae =_egac .Data [_dbba ]<<_gadf ;if _bcfee {_ddae =_dfbc (_ddae ,_egac .Data [_dbba +1]>>_faadf ,_dfcbg );};_cgda .Data [_dgebf ]=_dfbc (_cgda .Data [_dgebf ],^(_ddae &_cgda .Data [_dgebf ]),_gcegc );
_dgebf +=_cgda .BytesPerLine ;_dbba +=_egac .BytesPerLine ;};};case PixNotPixSrcXorDst :if _bdbaa {for _ggebf =0;_ggebf < _gacb ;_ggebf ++{if _bdge ==_efga {_ddae =_egac .Data [_dbed ]<<_gadf ;if _dfdf {_ddae =_dfbc (_ddae ,_egac .Data [_dbed +1]>>_faadf ,_dfcbg );
};}else {_ddae =_egac .Data [_dbed ]>>_faadf ;};_cgda .Data [_adbc ]=_dfbc (_cgda .Data [_adbc ],^(_ddae ^_cgda .Data [_adbc ]),_ebdc );_adbc +=_cgda .BytesPerLine ;_dbed +=_egac .BytesPerLine ;};};if _bgaf {for _ggebf =0;_ggebf < _gacb ;_ggebf ++{for _bbda =0;
_bbda < _fcdgd ;_bbda ++{_ddae =_dfbc (_egac .Data [_fgdgf +_bbda ]<<_gadf ,_egac .Data [_fgdgf +_bbda +1]>>_faadf ,_dfcbg );_cgda .Data [_gfda +_bbda ]=^(_ddae ^_cgda .Data [_gfda +_bbda ]);};_gfda +=_cgda .BytesPerLine ;_fgdgf +=_egac .BytesPerLine ;
};};if _cffb {for _ggebf =0;_ggebf < _gacb ;_ggebf ++{_ddae =_egac .Data [_dbba ]<<_gadf ;if _bcfee {_ddae =_dfbc (_ddae ,_egac .Data [_dbba +1]>>_faadf ,_dfcbg );};_cgda .Data [_dgebf ]=_dfbc (_cgda .Data [_dgebf ],^(_ddae ^_cgda .Data [_dgebf ]),_gcegc );
_dgebf +=_cgda .BytesPerLine ;_dbba +=_egac .BytesPerLine ;};};default:_fe .Log .Debug ("\u004f\u0070e\u0072\u0061\u0074\u0069\u006f\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006e\u006f\u0074\u0020\u0070\u0065\u0072\u006d\u0069tt\u0065\u0064",_bbgd );
return _g .New ("\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065r\u0061\u0074\u0069\u006f\u006e\u0020\u006eo\u0074\u0020\u0070\u0065\u0072\u006d\u0069\u0074\u0074\u0065\u0064");};return nil ;};func _aadd (_gefc _gd .Gray ,_cgcd monochromeModel )_gd .Gray {if _gefc .Y > uint8 (_cgcd ){return _gd .Gray {Y :_f .MaxUint8 };
};return _gd .Gray {};};var _ _d .Image =&Monochrome {};func _ceca (_dfgc nrgba64 ,_fbbfe RGBA ,_edcaf _d .Rectangle ){for _abedd :=0;_abedd < _edcaf .Max .X ;_abedd ++{for _bdgcae :=0;_bdgcae < _edcaf .Max .Y ;_bdgcae ++{_gfee :=_dfgc .NRGBA64At (_abedd ,_bdgcae );
_fbbfe .SetRGBA (_abedd ,_bdgcae ,_ddad (_gfee ));};};};var _ RGBA =&RGBA32 {};type Gray4 struct{ImageBase };var _ Image =&Monochrome {};func _fcgd (_decb _d .Image )(Image ,error ){if _fab ,_dgc :=_decb .(*Gray4 );_dgc {return _fab .Copy (),nil ;};_ccacc :=_decb .Bounds ();
_bdgca ,_dbde :=NewImage (_ccacc .Max .X ,_ccacc .Max .Y ,4,1,nil ,nil ,nil );if _dbde !=nil {return nil ,_dbde ;};_bbff (_decb ,_bdgca ,_ccacc );return _bdgca ,nil ;};func GetConverter (bitsPerComponent ,colorComponents int )(ColorConverter ,error ){switch colorComponents {case 1:switch bitsPerComponent {case 1:return MonochromeConverter ,nil ;
case 2:return Gray2Converter ,nil ;case 4:return Gray4Converter ,nil ;case 8:return GrayConverter ,nil ;case 16:return Gray16Converter ,nil ;};case 3:switch bitsPerComponent {case 4:return NRGBA16Converter ,nil ;case 8:return NRGBAConverter ,nil ;case 16:return NRGBA64Converter ,nil ;
};case 4:return CMYKConverter ,nil ;};return nil ,_eb .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0043o\u006e\u0076\u0065\u0072\u0074\u0065\u0072\u0020\u0070\u0061\u0072\u0061\u006d\u0065t\u0065\u0072\u0073\u002e\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003a\u0020\u0025\u0064\u002c\u0020\u0043\u006f\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006et\u0073\u003a \u0025\u0064",bitsPerComponent ,colorComponents );
};type shift int ;func (_ded *Monochrome )Histogram ()(_dfbf [256]int ){for _ ,_gfc :=range _ded .Data {_dfbf [0xff]+=int (_ecf [_ded .Data [_gfc ]]);};return _dfbf ;};func _ffg (_bf *Monochrome ,_cfcc ...int )(_acg *Monochrome ,_egda error ){if _bf ==nil {return nil ,_g .New ("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d");
};if len (_cfcc )==0{return nil ,_g .New ("\u0074h\u0065\u0072e\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0061\u0074 \u006c\u0065\u0061\u0073\u0074\u0020o\u006e\u0065\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u006f\u0066 \u0072\u0065\u0064\u0075\u0063\u0074\u0069\u006f\u006e");
};_gfba :=_dcb ();_acg =_bf ;for _ ,_egdae :=range _cfcc {if _egdae <=0{break ;};_acg ,_egda =_bgf (_acg ,_egdae ,_gfba );if _egda !=nil {return nil ,_egda ;};};return _acg ,nil ;};func (_bfdf *Gray8 )SetGray (x ,y int ,g _gd .Gray ){_fcegf :=y *_bfdf .BytesPerLine +x ;
if _fcegf > len (_bfdf .Data )-1{return ;};_bfdf .Data [_fcegf ]=g .Y ;};func _egcb (_fegg *_d .NYCbCrA ,_gaec RGBA ,_fadd _d .Rectangle ){for _agaea :=0;_agaea < _fadd .Max .X ;_agaea ++{for _fbda :=0;_fbda < _fadd .Max .Y ;_fbda ++{_caef :=_fegg .NYCbCrAAt (_agaea ,_fbda );
_gaec .SetRGBA (_agaea ,_fbda ,_fagd (_caef ));};};};func GrayHistogram (g Gray )(_faddg [256]int ){switch _ecgcbg :=g .(type ){case Histogramer :return _ecgcbg .Histogram ();case _d .Image :_abd :=_ecgcbg .Bounds ();for _ccfc :=0;_ccfc < _abd .Max .X ;
_ccfc ++{for _afbe :=0;_afbe < _abd .Max .Y ;_afbe ++{_faddg [g .GrayAt (_ccfc ,_afbe ).Y ]++;};};return _faddg ;default:return [256]int {};};};func (_agg *Monochrome )At (x ,y int )_gd .Color {_bafc ,_ :=_agg .ColorAt (x ,y );return _bafc };func (_ffda *Gray8 )At (x ,y int )_gd .Color {_gbfe ,_ :=_ffda .ColorAt (x ,y );
return _gbfe };func FromGoImage (i _d .Image )(Image ,error ){switch _gdcab :=i .(type ){case Image :return _gdcab .Copy (),nil ;case Gray :return GrayConverter .Convert (i );case *_d .Gray16 :return Gray16Converter .Convert (i );case CMYK :return CMYKConverter .Convert (i );
case *_d .NRGBA64 :return NRGBA64Converter .Convert (i );default:return NRGBAConverter .Convert (i );};};func _bced (_bfcd uint8 )bool {if _bfcd ==0||_bfcd ==255{return true ;};return false ;};func _cdca (_aade ,_bed Gray ,_fcbf _d .Rectangle ){for _eafc :=0;
_eafc < _fcbf .Max .X ;_eafc ++{for _fafc :=0;_fafc < _fcbf .Max .Y ;_fafc ++{_bed .SetGray (_eafc ,_fafc ,_aade .GrayAt (_eafc ,_fafc ));};};};type Histogramer interface{Histogram ()[256]int ;};func _ffd (_ccef _gd .Gray )_gd .RGBA {return _gd .RGBA {R :_ccef .Y ,G :_ccef .Y ,B :_ccef .Y ,A :0xff}};
func (_effad *NRGBA32 )SetNRGBA (x ,y int ,c _gd .NRGBA ){_gacba :=y *_effad .Width +x ;_dadd :=3*_gacba ;if _dadd +2>=len (_effad .Data ){return ;};_effad .setRGBA (_gacba ,c );};func _cff ()(_cbg [256]uint64 ){for _egd :=0;_egd < 256;_egd ++{if _egd &0x01!=0{_cbg [_egd ]|=0xff;
};if _egd &0x02!=0{_cbg [_egd ]|=0xff00;};if _egd &0x04!=0{_cbg [_egd ]|=0xff0000;};if _egd &0x08!=0{_cbg [_egd ]|=0xff000000;};if _egd &0x10!=0{_cbg [_egd ]|=0xff00000000;};if _egd &0x20!=0{_cbg [_egd ]|=0xff0000000000;};if _egd &0x40!=0{_cbg [_egd ]|=0xff000000000000;
};if _egd &0x80!=0{_cbg [_egd ]|=0xff00000000000000;};};return _cbg ;};func (_geff *Monochrome )ExpandBinary (factor int )(*Monochrome ,error ){if !IsPowerOf2 (uint (factor )){return nil ,_eb .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0065\u0078\u0070\u0061\u006e\u0064\u0020b\u0069n\u0061\u0072\u0079\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",factor );
};return _cd (_geff ,factor );};func (_cdcc *Gray16 )Validate ()error {if len (_cdcc .Data )!=_cdcc .Height *_cdcc .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_dfa *Monochrome )ColorModel ()_gd .Model {return MonochromeModel (_dfa .ModelThreshold )};
func (_ebd *Monochrome )getBit (_fgaf ,_ceecf int )uint8 {return _ebd .Data [_fgaf +(_ceecf >>3)]>>uint (7-(_ceecf &7))&1;};func _egdef (_eaecb *_d .Gray )bool {for _acdf :=0;_acdf < len (_eaecb .Pix );_acdf ++{if !_bced (_eaecb .Pix [_acdf ]){return false ;
};};return true ;};func _bba (_fed _gd .NRGBA64 )_gd .NRGBA {return _gd .NRGBA {R :uint8 (_fed .R >>8),G :uint8 (_fed .G >>8),B :uint8 (_fed .B >>8),A :uint8 (_fed .A >>8)};};func (_gga *Gray4 )setGray (_edea int ,_ddga int ,_ecab _gd .Gray ){_bdbaca :=_ddga *_gga .BytesPerLine ;
_egbd :=_bdbaca +(_edea >>1);if _egbd >=len (_gga .Data ){return ;};_fbgd :=_ecab .Y >>4;_gga .Data [_egbd ]=(_gga .Data [_egbd ]&(^(0xf0>>uint (4*(_edea &1)))))|(_fbgd <<uint (4-4*(_edea &1)));};func _gbagc (_cbdd Gray ,_eacc NRGBA ,_bfgae _d .Rectangle ){for _gcec :=0;
_gcec < _bfgae .Max .X ;_gcec ++{for _gbeaa :=0;_gbeaa < _bfgae .Max .Y ;_gbeaa ++{_adbff :=_cbdd .GrayAt (_gcec ,_gbeaa );_eacc .SetNRGBA (_gcec ,_gbeaa ,_cbgc (_adbff ));};};};func _eeae (_bgdg _gd .NRGBA64 )_gd .Gray {var _dcf _gd .NRGBA64 ;if _bgdg ==_dcf {return _gd .Gray {Y :0xff};
};_bdd ,_dcba ,_fgd ,_ :=_bgdg .RGBA ();_afde :=(19595*_bdd +38470*_dcba +7471*_fgd +1<<15)>>24;return _gd .Gray {Y :uint8 (_afde )};};func ColorAtRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_gd .RGBA ,error ){_acge :=y *width +x ;_dagg :=3*_acge ;
if _dagg +2>=len (data ){return _gd .RGBA {},_eb .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_cadbf :=uint8 (0xff);if alpha !=nil &&len (alpha )> _acge {_cadbf =alpha [_acge ];};_aeff ,_cbba ,_dfef :=data [_dagg ],data [_dagg +1],data [_dagg +2];if len (decode )==6{_aeff =uint8 (uint32 (LinearInterpolate (float64 (_aeff ),0,255,decode [0],decode [1]))&0xff);
_cbba =uint8 (uint32 (LinearInterpolate (float64 (_cbba ),0,255,decode [2],decode [3]))&0xff);_dfef =uint8 (uint32 (LinearInterpolate (float64 (_dfef ),0,255,decode [4],decode [5]))&0xff);};return _gd .RGBA {R :_aeff ,G :_cbba ,B :_dfef ,A :_cadbf },nil ;
};func MonochromeThresholdConverter (threshold uint8 )ColorConverter {return &monochromeThresholdConverter {Threshold :threshold };};var _ Gray =&Gray8 {};func (_cddb *NRGBA16 )ColorModel ()_gd .Model {return NRGBA16Model };func (_bbcd *Gray8 )Validate ()error {if len (_bbcd .Data )!=_bbcd .Height *_bbcd .BytesPerLine {return ErrInvalidImage ;
};return nil ;};func _daaa (_cbee _d .Image )(Image ,error ){if _cag ,_dgda :=_cbee .(*NRGBA32 );_dgda {return _cag .Copy (),nil ;};_adbe ,_cadcc ,_acaa :=_beeaa (_cbee ,1);_aafd ,_beebd :=NewImage (_adbe .Max .X ,_adbe .Max .Y ,8,3,nil ,_acaa ,nil );if _beebd !=nil {return nil ,_beebd ;
};_becca (_cbee ,_aafd ,_adbe );if len (_acaa )!=0&&!_cadcc {if _dcda :=_gfcfe (_acaa ,_aafd );_dcda !=nil {return nil ,_dcda ;};};return _aafd ,nil ;};func _gbfc (_beg _d .Image ,_fadg Image ,_dcbc _d .Rectangle ){for _eaad :=0;_eaad < _dcbc .Max .X ;
_eaad ++{for _cabg :=0;_cabg < _dcbc .Max .Y ;_cabg ++{_cggb :=_beg .At (_eaad ,_cabg );_fadg .Set (_eaad ,_cabg ,_cggb );};};};func _adadd (_eaag *Monochrome ,_fgdg ,_fdcg ,_dabea ,_cgbe int ,_fbae RasterOperator ,_eab *Monochrome ,_caca ,_eaeb int )error {var (_adag byte ;
_cafg int ;_cefcc int ;_gaebg ,_eegg int ;_edca ,_aed int ;);_fffce :=_dabea >>3;_cacfb :=_dabea &7;if _cacfb > 0{_adag =_fgeb [_cacfb ];};_cafg =_eab .BytesPerLine *_eaeb +(_caca >>3);_cefcc =_eaag .BytesPerLine *_fdcg +(_fgdg >>3);switch _fbae {case PixSrc :for _edca =0;
_edca < _cgbe ;_edca ++{_gaebg =_cafg +_edca *_eab .BytesPerLine ;_eegg =_cefcc +_edca *_eaag .BytesPerLine ;for _aed =0;_aed < _fffce ;_aed ++{_eaag .Data [_eegg ]=_eab .Data [_gaebg ];_eegg ++;_gaebg ++;};if _cacfb > 0{_eaag .Data [_eegg ]=_dfbc (_eaag .Data [_eegg ],_eab .Data [_gaebg ],_adag );
};};case PixNotSrc :for _edca =0;_edca < _cgbe ;_edca ++{_gaebg =_cafg +_edca *_eab .BytesPerLine ;_eegg =_cefcc +_edca *_eaag .BytesPerLine ;for _aed =0;_aed < _fffce ;_aed ++{_eaag .Data [_eegg ]=^(_eab .Data [_gaebg ]);_eegg ++;_gaebg ++;};if _cacfb > 0{_eaag .Data [_eegg ]=_dfbc (_eaag .Data [_eegg ],^_eab .Data [_gaebg ],_adag );
};};case PixSrcOrDst :for _edca =0;_edca < _cgbe ;_edca ++{_gaebg =_cafg +_edca *_eab .BytesPerLine ;_eegg =_cefcc +_edca *_eaag .BytesPerLine ;for _aed =0;_aed < _fffce ;_aed ++{_eaag .Data [_eegg ]|=_eab .Data [_gaebg ];_eegg ++;_gaebg ++;};if _cacfb > 0{_eaag .Data [_eegg ]=_dfbc (_eaag .Data [_eegg ],_eab .Data [_gaebg ]|_eaag .Data [_eegg ],_adag );
};};case PixSrcAndDst :for _edca =0;_edca < _cgbe ;_edca ++{_gaebg =_cafg +_edca *_eab .BytesPerLine ;_eegg =_cefcc +_edca *_eaag .BytesPerLine ;for _aed =0;_aed < _fffce ;_aed ++{_eaag .Data [_eegg ]&=_eab .Data [_gaebg ];_eegg ++;_gaebg ++;};if _cacfb > 0{_eaag .Data [_eegg ]=_dfbc (_eaag .Data [_eegg ],_eab .Data [_gaebg ]&_eaag .Data [_eegg ],_adag );
};};case PixSrcXorDst :for _edca =0;_edca < _cgbe ;_edca ++{_gaebg =_cafg +_edca *_eab .BytesPerLine ;_eegg =_cefcc +_edca *_eaag .BytesPerLine ;for _aed =0;_aed < _fffce ;_aed ++{_eaag .Data [_eegg ]^=_eab .Data [_gaebg ];_eegg ++;_gaebg ++;};if _cacfb > 0{_eaag .Data [_eegg ]=_dfbc (_eaag .Data [_eegg ],_eab .Data [_gaebg ]^_eaag .Data [_eegg ],_adag );
};};case PixNotSrcOrDst :for _edca =0;_edca < _cgbe ;_edca ++{_gaebg =_cafg +_edca *_eab .BytesPerLine ;_eegg =_cefcc +_edca *_eaag .BytesPerLine ;for _aed =0;_aed < _fffce ;_aed ++{_eaag .Data [_eegg ]|=^(_eab .Data [_gaebg ]);_eegg ++;_gaebg ++;};if _cacfb > 0{_eaag .Data [_eegg ]=_dfbc (_eaag .Data [_eegg ],^(_eab .Data [_gaebg ])|_eaag .Data [_eegg ],_adag );
};};case PixNotSrcAndDst :for _edca =0;_edca < _cgbe ;_edca ++{_gaebg =_cafg +_edca *_eab .BytesPerLine ;_eegg =_cefcc +_edca *_eaag .BytesPerLine ;for _aed =0;_aed < _fffce ;_aed ++{_eaag .Data [_eegg ]&=^(_eab .Data [_gaebg ]);_eegg ++;_gaebg ++;};if _cacfb > 0{_eaag .Data [_eegg ]=_dfbc (_eaag .Data [_eegg ],^(_eab .Data [_gaebg ])&_eaag .Data [_eegg ],_adag );
};};case PixSrcOrNotDst :for _edca =0;_edca < _cgbe ;_edca ++{_gaebg =_cafg +_edca *_eab .BytesPerLine ;_eegg =_cefcc +_edca *_eaag .BytesPerLine ;for _aed =0;_aed < _fffce ;_aed ++{_eaag .Data [_eegg ]=_eab .Data [_gaebg ]|^(_eaag .Data [_eegg ]);_eegg ++;
_gaebg ++;};if _cacfb > 0{_eaag .Data [_eegg ]=_dfbc (_eaag .Data [_eegg ],_eab .Data [_gaebg ]|^(_eaag .Data [_eegg ]),_adag );};};case PixSrcAndNotDst :for _edca =0;_edca < _cgbe ;_edca ++{_gaebg =_cafg +_edca *_eab .BytesPerLine ;_eegg =_cefcc +_edca *_eaag .BytesPerLine ;
for _aed =0;_aed < _fffce ;_aed ++{_eaag .Data [_eegg ]=_eab .Data [_gaebg ]&^(_eaag .Data [_eegg ]);_eegg ++;_gaebg ++;};if _cacfb > 0{_eaag .Data [_eegg ]=_dfbc (_eaag .Data [_eegg ],_eab .Data [_gaebg ]&^(_eaag .Data [_eegg ]),_adag );};};case PixNotPixSrcOrDst :for _edca =0;
_edca < _cgbe ;_edca ++{_gaebg =_cafg +_edca *_eab .BytesPerLine ;_eegg =_cefcc +_edca *_eaag .BytesPerLine ;for _aed =0;_aed < _fffce ;_aed ++{_eaag .Data [_eegg ]=^(_eab .Data [_gaebg ]|_eaag .Data [_eegg ]);_eegg ++;_gaebg ++;};if _cacfb > 0{_eaag .Data [_eegg ]=_dfbc (_eaag .Data [_eegg ],^(_eab .Data [_gaebg ]|_eaag .Data [_eegg ]),_adag );
};};case PixNotPixSrcAndDst :for _edca =0;_edca < _cgbe ;_edca ++{_gaebg =_cafg +_edca *_eab .BytesPerLine ;_eegg =_cefcc +_edca *_eaag .BytesPerLine ;for _aed =0;_aed < _fffce ;_aed ++{_eaag .Data [_eegg ]=^(_eab .Data [_gaebg ]&_eaag .Data [_eegg ]);
_eegg ++;_gaebg ++;};if _cacfb > 0{_eaag .Data [_eegg ]=_dfbc (_eaag .Data [_eegg ],^(_eab .Data [_gaebg ]&_eaag .Data [_eegg ]),_adag );};};case PixNotPixSrcXorDst :for _edca =0;_edca < _cgbe ;_edca ++{_gaebg =_cafg +_edca *_eab .BytesPerLine ;_eegg =_cefcc +_edca *_eaag .BytesPerLine ;
for _aed =0;_aed < _fffce ;_aed ++{_eaag .Data [_eegg ]=^(_eab .Data [_gaebg ]^_eaag .Data [_eegg ]);_eegg ++;_gaebg ++;};if _cacfb > 0{_eaag .Data [_eegg ]=_dfbc (_eaag .Data [_eegg ],^(_eab .Data [_gaebg ]^_eaag .Data [_eegg ]),_adag );};};default:_fe .Log .Debug ("\u0050\u0072ov\u0069\u0064\u0065d\u0020\u0069\u006e\u0076ali\u0064 r\u0061\u0073\u0074\u0065\u0072\u0020\u006fpe\u0072\u0061\u0074\u006f\u0072\u003a\u0020%\u0076",_fbae );
return _g .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072");};return nil ;};type NRGBA64 struct{ImageBase };func _bgf (_efa *Monochrome ,_cga int ,_egc []byte )(_edf *Monochrome ,_fec error ){const _gc ="\u0072\u0065d\u0075\u0063\u0065R\u0061\u006e\u006b\u0042\u0069\u006e\u0061\u0072\u0079";
if _efa ==nil {return nil ,_g .New ("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d");};if _cga < 1||_cga > 4{return nil ,_g .New ("\u006c\u0065\u0076\u0065\u006c\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020\u0073e\u0074\u0020\u007b\u0031\u002c\u0032\u002c\u0033\u002c\u0034\u007d");
};if _efa .Height <=1{return nil ,_g .New ("\u0073\u006f\u0075rc\u0065\u0020\u0068\u0065\u0069\u0067\u0068\u0074\u0020m\u0075s\u0074 \u0062e\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020\u0027\u0032\u0027");};_edf =_fga (_efa .Width /2,_efa .Height /2);
if _egc ==nil {_egc =_dcb ();};_bae :=_caddd (_efa .BytesPerLine ,2*_edf .BytesPerLine );switch _cga {case 1:_fec =_dfc (_efa ,_edf ,_egc ,_bae );case 2:_fec =_dcd (_efa ,_edf ,_egc ,_bae );case 3:_fec =_dae (_efa ,_edf ,_egc ,_bae );case 4:_fec =_geg (_efa ,_edf ,_egc ,_bae );
};if _fec !=nil {return nil ,_fec ;};return _edf ,nil ;};func (_ecac *NRGBA64 )At (x ,y int )_gd .Color {_bddd ,_ :=_ecac .ColorAt (x ,y );return _bddd };func (_dfccb *NRGBA16 )ColorAt (x ,y int )(_gd .Color ,error ){return ColorAtNRGBA16 (x ,y ,_dfccb .Width ,_dfccb .BytesPerLine ,_dfccb .Data ,_dfccb .Alpha ,_dfccb .Decode );
};func _gdgd (_bdcd Gray ,_eadgd RGBA ,_fbbfa _d .Rectangle ){for _fagee :=0;_fagee < _fbbfa .Max .X ;_fagee ++{for _gbbe :=0;_gbbe < _fbbfa .Max .Y ;_gbbe ++{_cdebc :=_bdcd .GrayAt (_fagee ,_gbbe );_eadgd .SetRGBA (_fagee ,_gbbe ,_ffd (_cdebc ));};};};
func ColorAtNRGBA64 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_gd .NRGBA64 ,error ){_dcef :=(y *width +x )*2;_befba :=_dcef *3;if _befba +5>=len (data ){return _gd .NRGBA64 {},_eb .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};const _ffcg =0xffff;_gdgf :=uint16 (_ffcg );if alpha !=nil &&len (alpha )> _dcef +1{_gdgf =uint16 (alpha [_dcef ])<<8|uint16 (alpha [_dcef +1]);};_gbfd :=uint16 (data [_befba ])<<8|uint16 (data [_befba +1]);_geaf :=uint16 (data [_befba +2])<<8|uint16 (data [_befba +3]);
_adcg :=uint16 (data [_befba +4])<<8|uint16 (data [_befba +5]);if len (decode )==6{_gbfd =uint16 (uint64 (LinearInterpolate (float64 (_gbfd ),0,65535,decode [0],decode [1]))&_ffcg );_geaf =uint16 (uint64 (LinearInterpolate (float64 (_geaf ),0,65535,decode [2],decode [3]))&_ffcg );
_adcg =uint16 (uint64 (LinearInterpolate (float64 (_adcg ),0,65535,decode [4],decode [5]))&_ffcg );};return _gd .NRGBA64 {R :_gbfd ,G :_geaf ,B :_adcg ,A :_gdgf },nil ;};func _baed (_cdeb NRGBA ,_bfa Gray ,_eaab _d .Rectangle ){for _dfec :=0;_dfec < _eaab .Max .X ;
_dfec ++{for _acga :=0;_acga < _eaab .Max .Y ;_acga ++{_gefff :=_agag (_cdeb .NRGBAAt (_dfec ,_acga ));_bfa .SetGray (_dfec ,_acga ,_gefff );};};};func ColorAtGray1BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_gd .Gray ,error ){_fddf :=y *bytesPerLine +x >>3;
if _fddf >=len (data ){return _gd .Gray {},_eb .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_eaaf :=data [_fddf ]>>uint (7-(x &7))&1;if len (decode )==2{_eaaf =uint8 (LinearInterpolate (float64 (_eaaf ),0.0,1.0,decode [0],decode [1]))&1;};return _gd .Gray {Y :_eaaf *255},nil ;};func (_bffg *Monochrome )ColorAt (x ,y int )(_gd .Color ,error ){return ColorAtGray1BPC (x ,y ,_bffg .BytesPerLine ,_bffg .Data ,_bffg .Decode );
};var _ Image =&Gray16 {};func (_dbfd *RGBA32 )ColorModel ()_gd .Model {return _gd .NRGBAModel };func _deec (_efc _gd .CMYK )_gd .RGBA {_dbfe ,_cdcf ,_ebc :=_gd .CMYKToRGB (_efc .C ,_efc .M ,_efc .Y ,_efc .K );return _gd .RGBA {R :_dbfe ,G :_cdcf ,B :_ebc ,A :0xff};
};func _ffdaf (){for _aaef :=0;_aaef < 256;_aaef ++{_ecf [_aaef ]=uint8 (_aaef &0x1)+(uint8 (_aaef >>1)&0x1)+(uint8 (_aaef >>2)&0x1)+(uint8 (_aaef >>3)&0x1)+(uint8 (_aaef >>4)&0x1)+(uint8 (_aaef >>5)&0x1)+(uint8 (_aaef >>6)&0x1)+(uint8 (_aaef >>7)&0x1);
};};func (_agaf *NRGBA32 )NRGBAAt (x ,y int )_gd .NRGBA {_afbc ,_ :=ColorAtNRGBA32 (x ,y ,_agaf .Width ,_agaf .Data ,_agaf .Alpha ,_agaf .Decode );return _afbc ;};