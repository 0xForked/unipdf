//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package imageutil ;import (_f "encoding/binary";_c "errors";_cg "fmt";_fb "github.com/unidoc/unipdf/v3/common";_cf "github.com/unidoc/unipdf/v3/internal/bitwise";_b "image";_g "image/color";_ga "image/draw";_a "math";);func _gadf (_gac _g .Color )_g .Color {_bcfc :=_g .GrayModel .Convert (_gac ).(_g .Gray );
return _fcde (_bcfc );};func _bdb (_ag ,_ec *Monochrome )(_cb error ){_fe :=_ec .BytesPerLine ;_agc :=_ag .BytesPerLine ;var (_fbg byte ;_cbf uint16 ;_gbc ,_dc ,_ecb ,_de ,_gd int ;);for _ecb =0;_ecb < _ec .Height ;_ecb ++{_gbc =_ecb *_fe ;_dc =2*_ecb *_agc ;
for _de =0;_de < _fe ;_de ++{_fbg =_ec .Data [_gbc +_de ];_cbf =_ad [_fbg ];_gd =_dc +_de *2;if _ag .BytesPerLine !=_ec .BytesPerLine *2&&(_de +1)*2> _ag .BytesPerLine {_cb =_ag .setByte (_gd ,byte (_cbf >>8));}else {_cb =_ag .setTwoBytes (_gd ,_cbf );
};if _cb !=nil {return _cb ;};};for _de =0;_de < _agc ;_de ++{_gd =_dc +_agc +_de ;_fbg =_ag .Data [_dc +_de ];if _cb =_ag .setByte (_gd ,_fbg );_cb !=nil {return _cb ;};};};return nil ;};func _eecb (_daec _g .Gray )_g .Gray {_fdbe :=_daec .Y >>6;_fdbe |=_fdbe <<2;
_daec .Y =_fdbe |_fdbe <<4;return _daec ;};func _eea (_ebfc _g .NRGBA )_g .Gray {_dfbg ,_cdg ,_cega ,_ :=_ebfc .RGBA ();_cdd :=(19595*_dfbg +38470*_cdg +7471*_cega +1<<15)>>24;return _g .Gray {Y :uint8 (_cdd )};};func (_addc *CMYK32 )At (x ,y int )_g .Color {_cggb ,_ :=_addc .ColorAt (x ,y );
return _cggb };func (_gfeda *Gray4 )Base ()*ImageBase {return &_gfeda .ImageBase };func (_cfbd *Gray16 )GrayAt (x ,y int )_g .Gray {_cegg ,_ :=_cfbd .ColorAt (x ,y );return _g .Gray {Y :uint8 (_cegg .(_g .Gray16 ).Y >>8)};};func (_dgb *Monochrome )Set (x ,y int ,c _g .Color ){_aca :=y *_dgb .BytesPerLine +x >>3;
if _aca > len (_dgb .Data )-1{return ;};_ded :=_dgb .ColorModel ().Convert (c ).(_g .Gray );_dgb .setGray (x ,_ded ,_aca );};func _aeed (_befg _b .Image )(Image ,error ){if _debe ,_gge :=_befg .(*Gray2 );_gge {return _debe .Copy (),nil ;};_gfgb :=_befg .Bounds ();
_feac ,_bea :=NewImage (_gfgb .Max .X ,_gfgb .Max .Y ,2,1,nil ,nil ,nil );if _bea !=nil {return nil ,_bea ;};_ebdg (_befg ,_feac ,_gfgb );return _feac ,nil ;};type Image interface{_ga .Image ;Base ()*ImageBase ;Copy ()Image ;Pix ()[]byte ;ColorAt (_begd ,_gfef int )(_g .Color ,error );
Validate ()error ;};func (_cecf *ImageBase )setByte (_ggb int ,_dacd byte )error {if _ggb > len (_cecf .Data )-1{return _c .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_cecf .Data [_ggb ]=_dacd ;return nil ;
};func (_agdc *Gray2 )Set (x ,y int ,c _g .Color ){if x >=_agdc .Width ||y >=_agdc .Height {return ;};_gfb :=Gray2Model .Convert (c ).(_g .Gray );_bdf :=y *_agdc .BytesPerLine ;_adgg :=_bdf +(x >>2);_bdbf :=_gfb .Y >>6;_agdc .Data [_adgg ]=(_agdc .Data [_adgg ]&(^(0xc0>>uint (2*((x )&3)))))|(_bdbf <<uint (6-2*(x &3)));
};func (_ecfa *Gray4 )Histogram ()(_bedc [256]int ){for _bbf :=0;_bbf < _ecfa .Width ;_bbf ++{for _edbb :=0;_edbb < _ecfa .Height ;_edbb ++{_bedc [_ecfa .GrayAt (_bbf ,_edbb ).Y ]++;};};return _bedc ;};var _ Image =&Gray16 {};func (_ccbe *Monochrome )ResolveDecode ()error {if len (_ccbe .Decode )!=2{return nil ;
};if _ccbe .Decode [0]==1&&_ccbe .Decode [1]==0{if _fdge :=_ccbe .InverseData ();_fdge !=nil {return _fdge ;};_ccbe .Decode =nil ;};return nil ;};func (_cgab *Gray4 )GrayAt (x ,y int )_g .Gray {_gafd ,_ :=ColorAtGray4BPC (x ,y ,_cgab .BytesPerLine ,_cgab .Data ,_cgab .Decode );
return _gafd ;};func _eceb (_effb NRGBA ,_accab Gray ,_caa _b .Rectangle ){for _gccg :=0;_gccg < _caa .Max .X ;_gccg ++{for _ccab :=0;_ccab < _caa .Max .Y ;_ccab ++{_dbbe :=_eea (_effb .NRGBAAt (_gccg ,_ccab ));_accab .SetGray (_gccg ,_ccab ,_dbbe );};
};};func _efgd (_fadd *Monochrome ,_cfg ,_adddb int ,_baba ,_feec int ,_ecdd RasterOperator ){var (_efeg int ;_fagc byte ;_daecc ,_dbgb int ;_aggd int ;);_gffd :=_baba >>3;_dcaf :=_baba &7;if _dcaf > 0{_fagc =_baae [_dcaf ];};_efeg =_fadd .BytesPerLine *_adddb +(_cfg >>3);
switch _ecdd {case PixClr :for _daecc =0;_daecc < _feec ;_daecc ++{_aggd =_efeg +_daecc *_fadd .BytesPerLine ;for _dbgb =0;_dbgb < _gffd ;_dbgb ++{_fadd .Data [_aggd ]=0x0;_aggd ++;};if _dcaf > 0{_fadd .Data [_aggd ]=_geaa (_fadd .Data [_aggd ],0x0,_fagc );
};};case PixSet :for _daecc =0;_daecc < _feec ;_daecc ++{_aggd =_efeg +_daecc *_fadd .BytesPerLine ;for _dbgb =0;_dbgb < _gffd ;_dbgb ++{_fadd .Data [_aggd ]=0xff;_aggd ++;};if _dcaf > 0{_fadd .Data [_aggd ]=_geaa (_fadd .Data [_aggd ],0xff,_fagc );};};
case PixNotDst :for _daecc =0;_daecc < _feec ;_daecc ++{_aggd =_efeg +_daecc *_fadd .BytesPerLine ;for _dbgb =0;_dbgb < _gffd ;_dbgb ++{_fadd .Data [_aggd ]=^_fadd .Data [_aggd ];_aggd ++;};if _dcaf > 0{_fadd .Data [_aggd ]=_geaa (_fadd .Data [_aggd ],^_fadd .Data [_aggd ],_fagc );
};};};};func (_dfaca *ImageBase )copy ()ImageBase {_dcf :=*_dfaca ;_dcf .Data =make ([]byte ,len (_dfaca .Data ));copy (_dcf .Data ,_dfaca .Data );return _dcf ;};var _ _b .Image =&Monochrome {};func _bab (_dee ,_daa int ,_gfd []byte )*Monochrome {_ggg :=_gead (_dee ,_daa );
_ggg .Data =_gfd ;return _ggg ;};func _afgc (_baaf CMYK ,_aeag NRGBA ,_ebbb _b .Rectangle ){for _dcgd :=0;_dcgd < _ebbb .Max .X ;_dcgd ++{for _fgbg :=0;_fgbg < _ebbb .Max .Y ;_fgbg ++{_cfgg :=_baaf .CMYKAt (_dcgd ,_fgbg );_aeag .SetNRGBA (_dcgd ,_fgbg ,_bcb (_cfgg ));
};};};func (_fffc *ImageBase )HasAlpha ()bool {if _fffc .Alpha ==nil {return false ;};for _agdb :=range _fffc .Alpha {if _fffc .Alpha [_agdb ]!=0xff{return true ;};};return false ;};func _fa (_gea ,_gbd *Monochrome )(_abb error ){_fff :=_gbd .BytesPerLine ;
_fc :=_gea .BytesPerLine ;var _bed ,_ged ,_gedc ,_aba ,_ebf int ;for _gedc =0;_gedc < _gbd .Height ;_gedc ++{_bed =_gedc *_fff ;_ged =8*_gedc *_fc ;for _aba =0;_aba < _fff ;_aba ++{if _abb =_gea .setEightBytes (_ged +_aba *8,_bb [_gbd .Data [_bed +_aba ]]);
_abb !=nil {return _abb ;};};for _ebf =1;_ebf < 8;_ebf ++{for _aba =0;_aba < _fc ;_aba ++{if _abb =_gea .setByte (_ged +_ebf *_fc +_aba ,_gea .Data [_ged +_aba ]);_abb !=nil {return _abb ;};};};};return nil ;};func (_eca *CMYK32 )ColorModel ()_g .Model {return _g .CMYKModel };
func (_eedec *Gray2 )Base ()*ImageBase {return &_eedec .ImageBase };func (_eagd *Gray2 )At (x ,y int )_g .Color {_geae ,_ :=_eagd .ColorAt (x ,y );return _geae };func (_bfc *Gray8 )Set (x ,y int ,c _g .Color ){_ggce :=y *_bfc .BytesPerLine +x ;if _ggce > len (_bfc .Data )-1{return ;
};_ddb :=_g .GrayModel .Convert (c );_bfc .Data [_ggce ]=_ddb .(_g .Gray ).Y ;};func (_ccd *Monochrome )ScaleLow (width ,height int )(*Monochrome ,error ){if width < 0||height < 0{return nil ,_c .New ("\u0070\u0072\u006f\u0076\u0069\u0064e\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0069\u0064t\u0068\u0020\u0061\u006e\u0064\u0020\u0068e\u0069\u0067\u0068\u0074");
};_gade :=_gead (width ,height );_adcf :=make ([]int ,height );_dbccf :=make ([]int ,width );_egabb :=float64 (_ccd .Width )/float64 (width );_ebee :=float64 (_ccd .Height )/float64 (height );for _feea :=0;_feea < height ;_feea ++{_adcf [_feea ]=int (_a .Min (_ebee *float64 (_feea )+0.5,float64 (_ccd .Height -1)));
};for _gfa :=0;_gfa < width ;_gfa ++{_dbccf [_gfa ]=int (_a .Min (_egabb *float64 (_gfa )+0.5,float64 (_ccd .Width -1)));};_bedda :=-1;_fcgg :=byte (0);for _dddf :=0;_dddf < height ;_dddf ++{_bgg :=_adcf [_dddf ]*_ccd .BytesPerLine ;_befd :=_dddf *_gade .BytesPerLine ;
for _ace :=0;_ace < width ;_ace ++{_bcdc :=_dbccf [_ace ];if _bcdc !=_bedda {_fcgg =_ccd .getBit (_bgg ,_bcdc );if _fcgg !=0{_gade .setBit (_befd ,_ace );};_bedda =_bcdc ;}else {if _fcgg !=0{_gade .setBit (_befd ,_ace );};};};};return _gade ,nil ;};func (_bagf *NRGBA64 )NRGBA64At (x ,y int )_g .NRGBA64 {_dba ,_ :=ColorAtNRGBA64 (x ,y ,_bagf .Width ,_bagf .Data ,_bagf .Alpha ,_bagf .Decode );
return _dba ;};func _agff (_afcb RGBA ,_dcbd Gray ,_defe _b .Rectangle ){for _dfbb :=0;_dfbb < _defe .Max .X ;_dfbb ++{for _bebc :=0;_bebc < _defe .Max .Y ;_bebc ++{_egaf :=_cfb (_afcb .RGBAAt (_dfbb ,_bebc ));_dcbd .SetGray (_dfbb ,_bebc ,_egaf );};};
};var _ Image =&Gray2 {};func _dbgc (_ggad *Monochrome ,_adbb ,_adfd ,_eafca ,_aedg int ,_badab RasterOperator ,_eedd *Monochrome ,_dgabd ,_cdgg int )error {var (_gfc byte ;_cbe int ;_adec int ;_ffbc ,_cbcc int ;_dbge ,_badd int ;);_dcgb :=_eafca >>3;_eabb :=_eafca &7;
if _eabb > 0{_gfc =_baae [_eabb ];};_cbe =_eedd .BytesPerLine *_cdgg +(_dgabd >>3);_adec =_ggad .BytesPerLine *_adfd +(_adbb >>3);switch _badab {case PixSrc :for _dbge =0;_dbge < _aedg ;_dbge ++{_ffbc =_cbe +_dbge *_eedd .BytesPerLine ;_cbcc =_adec +_dbge *_ggad .BytesPerLine ;
for _badd =0;_badd < _dcgb ;_badd ++{_ggad .Data [_cbcc ]=_eedd .Data [_ffbc ];_cbcc ++;_ffbc ++;};if _eabb > 0{_ggad .Data [_cbcc ]=_geaa (_ggad .Data [_cbcc ],_eedd .Data [_ffbc ],_gfc );};};case PixNotSrc :for _dbge =0;_dbge < _aedg ;_dbge ++{_ffbc =_cbe +_dbge *_eedd .BytesPerLine ;
_cbcc =_adec +_dbge *_ggad .BytesPerLine ;for _badd =0;_badd < _dcgb ;_badd ++{_ggad .Data [_cbcc ]=^(_eedd .Data [_ffbc ]);_cbcc ++;_ffbc ++;};if _eabb > 0{_ggad .Data [_cbcc ]=_geaa (_ggad .Data [_cbcc ],^_eedd .Data [_ffbc ],_gfc );};};case PixSrcOrDst :for _dbge =0;
_dbge < _aedg ;_dbge ++{_ffbc =_cbe +_dbge *_eedd .BytesPerLine ;_cbcc =_adec +_dbge *_ggad .BytesPerLine ;for _badd =0;_badd < _dcgb ;_badd ++{_ggad .Data [_cbcc ]|=_eedd .Data [_ffbc ];_cbcc ++;_ffbc ++;};if _eabb > 0{_ggad .Data [_cbcc ]=_geaa (_ggad .Data [_cbcc ],_eedd .Data [_ffbc ]|_ggad .Data [_cbcc ],_gfc );
};};case PixSrcAndDst :for _dbge =0;_dbge < _aedg ;_dbge ++{_ffbc =_cbe +_dbge *_eedd .BytesPerLine ;_cbcc =_adec +_dbge *_ggad .BytesPerLine ;for _badd =0;_badd < _dcgb ;_badd ++{_ggad .Data [_cbcc ]&=_eedd .Data [_ffbc ];_cbcc ++;_ffbc ++;};if _eabb > 0{_ggad .Data [_cbcc ]=_geaa (_ggad .Data [_cbcc ],_eedd .Data [_ffbc ]&_ggad .Data [_cbcc ],_gfc );
};};case PixSrcXorDst :for _dbge =0;_dbge < _aedg ;_dbge ++{_ffbc =_cbe +_dbge *_eedd .BytesPerLine ;_cbcc =_adec +_dbge *_ggad .BytesPerLine ;for _badd =0;_badd < _dcgb ;_badd ++{_ggad .Data [_cbcc ]^=_eedd .Data [_ffbc ];_cbcc ++;_ffbc ++;};if _eabb > 0{_ggad .Data [_cbcc ]=_geaa (_ggad .Data [_cbcc ],_eedd .Data [_ffbc ]^_ggad .Data [_cbcc ],_gfc );
};};case PixNotSrcOrDst :for _dbge =0;_dbge < _aedg ;_dbge ++{_ffbc =_cbe +_dbge *_eedd .BytesPerLine ;_cbcc =_adec +_dbge *_ggad .BytesPerLine ;for _badd =0;_badd < _dcgb ;_badd ++{_ggad .Data [_cbcc ]|=^(_eedd .Data [_ffbc ]);_cbcc ++;_ffbc ++;};if _eabb > 0{_ggad .Data [_cbcc ]=_geaa (_ggad .Data [_cbcc ],^(_eedd .Data [_ffbc ])|_ggad .Data [_cbcc ],_gfc );
};};case PixNotSrcAndDst :for _dbge =0;_dbge < _aedg ;_dbge ++{_ffbc =_cbe +_dbge *_eedd .BytesPerLine ;_cbcc =_adec +_dbge *_ggad .BytesPerLine ;for _badd =0;_badd < _dcgb ;_badd ++{_ggad .Data [_cbcc ]&=^(_eedd .Data [_ffbc ]);_cbcc ++;_ffbc ++;};if _eabb > 0{_ggad .Data [_cbcc ]=_geaa (_ggad .Data [_cbcc ],^(_eedd .Data [_ffbc ])&_ggad .Data [_cbcc ],_gfc );
};};case PixSrcOrNotDst :for _dbge =0;_dbge < _aedg ;_dbge ++{_ffbc =_cbe +_dbge *_eedd .BytesPerLine ;_cbcc =_adec +_dbge *_ggad .BytesPerLine ;for _badd =0;_badd < _dcgb ;_badd ++{_ggad .Data [_cbcc ]=_eedd .Data [_ffbc ]|^(_ggad .Data [_cbcc ]);_cbcc ++;
_ffbc ++;};if _eabb > 0{_ggad .Data [_cbcc ]=_geaa (_ggad .Data [_cbcc ],_eedd .Data [_ffbc ]|^(_ggad .Data [_cbcc ]),_gfc );};};case PixSrcAndNotDst :for _dbge =0;_dbge < _aedg ;_dbge ++{_ffbc =_cbe +_dbge *_eedd .BytesPerLine ;_cbcc =_adec +_dbge *_ggad .BytesPerLine ;
for _badd =0;_badd < _dcgb ;_badd ++{_ggad .Data [_cbcc ]=_eedd .Data [_ffbc ]&^(_ggad .Data [_cbcc ]);_cbcc ++;_ffbc ++;};if _eabb > 0{_ggad .Data [_cbcc ]=_geaa (_ggad .Data [_cbcc ],_eedd .Data [_ffbc ]&^(_ggad .Data [_cbcc ]),_gfc );};};case PixNotPixSrcOrDst :for _dbge =0;
_dbge < _aedg ;_dbge ++{_ffbc =_cbe +_dbge *_eedd .BytesPerLine ;_cbcc =_adec +_dbge *_ggad .BytesPerLine ;for _badd =0;_badd < _dcgb ;_badd ++{_ggad .Data [_cbcc ]=^(_eedd .Data [_ffbc ]|_ggad .Data [_cbcc ]);_cbcc ++;_ffbc ++;};if _eabb > 0{_ggad .Data [_cbcc ]=_geaa (_ggad .Data [_cbcc ],^(_eedd .Data [_ffbc ]|_ggad .Data [_cbcc ]),_gfc );
};};case PixNotPixSrcAndDst :for _dbge =0;_dbge < _aedg ;_dbge ++{_ffbc =_cbe +_dbge *_eedd .BytesPerLine ;_cbcc =_adec +_dbge *_ggad .BytesPerLine ;for _badd =0;_badd < _dcgb ;_badd ++{_ggad .Data [_cbcc ]=^(_eedd .Data [_ffbc ]&_ggad .Data [_cbcc ]);
_cbcc ++;_ffbc ++;};if _eabb > 0{_ggad .Data [_cbcc ]=_geaa (_ggad .Data [_cbcc ],^(_eedd .Data [_ffbc ]&_ggad .Data [_cbcc ]),_gfc );};};case PixNotPixSrcXorDst :for _dbge =0;_dbge < _aedg ;_dbge ++{_ffbc =_cbe +_dbge *_eedd .BytesPerLine ;_cbcc =_adec +_dbge *_ggad .BytesPerLine ;
for _badd =0;_badd < _dcgb ;_badd ++{_ggad .Data [_cbcc ]=^(_eedd .Data [_ffbc ]^_ggad .Data [_cbcc ]);_cbcc ++;_ffbc ++;};if _eabb > 0{_ggad .Data [_cbcc ]=_geaa (_ggad .Data [_cbcc ],^(_eedd .Data [_ffbc ]^_ggad .Data [_cbcc ]),_gfc );};};default:_fb .Log .Debug ("\u0050\u0072ov\u0069\u0064\u0065d\u0020\u0069\u006e\u0076ali\u0064 r\u0061\u0073\u0074\u0065\u0072\u0020\u006fpe\u0072\u0061\u0074\u006f\u0072\u003a\u0020%\u0076",_badab );
return _c .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072");};return nil ;};func _bfdf (_beca *Monochrome ,_abea ,_dbgdf ,_cced ,_bba int ,_bfa RasterOperator ,_cadc *Monochrome ,_fcgb ,_egfe int )error {var (_dfce bool ;
_aggf bool ;_gebb byte ;_ebgd int ;_gaea int ;_abd int ;_abbf int ;_fccg bool ;_badgg int ;_cbca int ;_ffgc int ;_accac bool ;_aggb byte ;_daea int ;_fece int ;_ebcg int ;_cbeg byte ;_agaa int ;_cgac int ;_gedf uint ;_agbd uint ;_bbgee byte ;_bfbbc shift ;
_afag bool ;_cda bool ;_dacbd ,_degc int ;);if _fcgb &7!=0{_cgac =8-(_fcgb &7);};if _abea &7!=0{_gaea =8-(_abea &7);};if _cgac ==0&&_gaea ==0{_bbgee =_cdeb [0];}else {if _gaea > _cgac {_gedf =uint (_gaea -_cgac );}else {_gedf =uint (8-(_cgac -_gaea ));
};_agbd =8-_gedf ;_bbgee =_cdeb [_gedf ];};if (_abea &7)!=0{_dfce =true ;_ebgd =8-(_abea &7);_gebb =_cdeb [_ebgd ];_abd =_beca .BytesPerLine *_dbgdf +(_abea >>3);_abbf =_cadc .BytesPerLine *_egfe +(_fcgb >>3);_agaa =8-(_fcgb &7);if _ebgd > _agaa {_bfbbc =_eafce ;
if _cced >=_cgac {_afag =true ;};}else {_bfbbc =_bce ;};};if _cced < _ebgd {_aggf =true ;_gebb &=_baae [8-_ebgd +_cced ];};if !_aggf {_badgg =(_cced -_ebgd )>>3;if _badgg !=0{_fccg =true ;_cbca =_beca .BytesPerLine *_dbgdf +((_abea +_gaea )>>3);_ffgc =_cadc .BytesPerLine *_egfe +((_fcgb +_gaea )>>3);
};};_daea =(_abea +_cced )&7;if !(_aggf ||_daea ==0){_accac =true ;_aggb =_baae [_daea ];_fece =_beca .BytesPerLine *_dbgdf +((_abea +_gaea )>>3)+_badgg ;_ebcg =_cadc .BytesPerLine *_egfe +((_fcgb +_gaea )>>3)+_badgg ;if _daea > int (_agbd ){_cda =true ;
};};switch _bfa {case PixSrc :if _dfce {for _dacbd =0;_dacbd < _bba ;_dacbd ++{if _bfbbc ==_eafce {_cbeg =_cadc .Data [_abbf ]<<_gedf ;if _afag {_cbeg =_geaa (_cbeg ,_cadc .Data [_abbf +1]>>_agbd ,_bbgee );};}else {_cbeg =_cadc .Data [_abbf ]>>_agbd ;};
_beca .Data [_abd ]=_geaa (_beca .Data [_abd ],_cbeg ,_gebb );_abd +=_beca .BytesPerLine ;_abbf +=_cadc .BytesPerLine ;};};if _fccg {for _dacbd =0;_dacbd < _bba ;_dacbd ++{for _degc =0;_degc < _badgg ;_degc ++{_cbeg =_geaa (_cadc .Data [_ffgc +_degc ]<<_gedf ,_cadc .Data [_ffgc +_degc +1]>>_agbd ,_bbgee );
_beca .Data [_cbca +_degc ]=_cbeg ;};_cbca +=_beca .BytesPerLine ;_ffgc +=_cadc .BytesPerLine ;};};if _accac {for _dacbd =0;_dacbd < _bba ;_dacbd ++{_cbeg =_cadc .Data [_ebcg ]<<_gedf ;if _cda {_cbeg =_geaa (_cbeg ,_cadc .Data [_ebcg +1]>>_agbd ,_bbgee );
};_beca .Data [_fece ]=_geaa (_beca .Data [_fece ],_cbeg ,_aggb );_fece +=_beca .BytesPerLine ;_ebcg +=_cadc .BytesPerLine ;};};case PixNotSrc :if _dfce {for _dacbd =0;_dacbd < _bba ;_dacbd ++{if _bfbbc ==_eafce {_cbeg =_cadc .Data [_abbf ]<<_gedf ;if _afag {_cbeg =_geaa (_cbeg ,_cadc .Data [_abbf +1]>>_agbd ,_bbgee );
};}else {_cbeg =_cadc .Data [_abbf ]>>_agbd ;};_beca .Data [_abd ]=_geaa (_beca .Data [_abd ],^_cbeg ,_gebb );_abd +=_beca .BytesPerLine ;_abbf +=_cadc .BytesPerLine ;};};if _fccg {for _dacbd =0;_dacbd < _bba ;_dacbd ++{for _degc =0;_degc < _badgg ;_degc ++{_cbeg =_geaa (_cadc .Data [_ffgc +_degc ]<<_gedf ,_cadc .Data [_ffgc +_degc +1]>>_agbd ,_bbgee );
_beca .Data [_cbca +_degc ]=^_cbeg ;};_cbca +=_beca .BytesPerLine ;_ffgc +=_cadc .BytesPerLine ;};};if _accac {for _dacbd =0;_dacbd < _bba ;_dacbd ++{_cbeg =_cadc .Data [_ebcg ]<<_gedf ;if _cda {_cbeg =_geaa (_cbeg ,_cadc .Data [_ebcg +1]>>_agbd ,_bbgee );
};_beca .Data [_fece ]=_geaa (_beca .Data [_fece ],^_cbeg ,_aggb );_fece +=_beca .BytesPerLine ;_ebcg +=_cadc .BytesPerLine ;};};case PixSrcOrDst :if _dfce {for _dacbd =0;_dacbd < _bba ;_dacbd ++{if _bfbbc ==_eafce {_cbeg =_cadc .Data [_abbf ]<<_gedf ;
if _afag {_cbeg =_geaa (_cbeg ,_cadc .Data [_abbf +1]>>_agbd ,_bbgee );};}else {_cbeg =_cadc .Data [_abbf ]>>_agbd ;};_beca .Data [_abd ]=_geaa (_beca .Data [_abd ],_cbeg |_beca .Data [_abd ],_gebb );_abd +=_beca .BytesPerLine ;_abbf +=_cadc .BytesPerLine ;
};};if _fccg {for _dacbd =0;_dacbd < _bba ;_dacbd ++{for _degc =0;_degc < _badgg ;_degc ++{_cbeg =_geaa (_cadc .Data [_ffgc +_degc ]<<_gedf ,_cadc .Data [_ffgc +_degc +1]>>_agbd ,_bbgee );_beca .Data [_cbca +_degc ]|=_cbeg ;};_cbca +=_beca .BytesPerLine ;
_ffgc +=_cadc .BytesPerLine ;};};if _accac {for _dacbd =0;_dacbd < _bba ;_dacbd ++{_cbeg =_cadc .Data [_ebcg ]<<_gedf ;if _cda {_cbeg =_geaa (_cbeg ,_cadc .Data [_ebcg +1]>>_agbd ,_bbgee );};_beca .Data [_fece ]=_geaa (_beca .Data [_fece ],_cbeg |_beca .Data [_fece ],_aggb );
_fece +=_beca .BytesPerLine ;_ebcg +=_cadc .BytesPerLine ;};};case PixSrcAndDst :if _dfce {for _dacbd =0;_dacbd < _bba ;_dacbd ++{if _bfbbc ==_eafce {_cbeg =_cadc .Data [_abbf ]<<_gedf ;if _afag {_cbeg =_geaa (_cbeg ,_cadc .Data [_abbf +1]>>_agbd ,_bbgee );
};}else {_cbeg =_cadc .Data [_abbf ]>>_agbd ;};_beca .Data [_abd ]=_geaa (_beca .Data [_abd ],_cbeg &_beca .Data [_abd ],_gebb );_abd +=_beca .BytesPerLine ;_abbf +=_cadc .BytesPerLine ;};};if _fccg {for _dacbd =0;_dacbd < _bba ;_dacbd ++{for _degc =0;
_degc < _badgg ;_degc ++{_cbeg =_geaa (_cadc .Data [_ffgc +_degc ]<<_gedf ,_cadc .Data [_ffgc +_degc +1]>>_agbd ,_bbgee );_beca .Data [_cbca +_degc ]&=_cbeg ;};_cbca +=_beca .BytesPerLine ;_ffgc +=_cadc .BytesPerLine ;};};if _accac {for _dacbd =0;_dacbd < _bba ;
_dacbd ++{_cbeg =_cadc .Data [_ebcg ]<<_gedf ;if _cda {_cbeg =_geaa (_cbeg ,_cadc .Data [_ebcg +1]>>_agbd ,_bbgee );};_beca .Data [_fece ]=_geaa (_beca .Data [_fece ],_cbeg &_beca .Data [_fece ],_aggb );_fece +=_beca .BytesPerLine ;_ebcg +=_cadc .BytesPerLine ;
};};case PixSrcXorDst :if _dfce {for _dacbd =0;_dacbd < _bba ;_dacbd ++{if _bfbbc ==_eafce {_cbeg =_cadc .Data [_abbf ]<<_gedf ;if _afag {_cbeg =_geaa (_cbeg ,_cadc .Data [_abbf +1]>>_agbd ,_bbgee );};}else {_cbeg =_cadc .Data [_abbf ]>>_agbd ;};_beca .Data [_abd ]=_geaa (_beca .Data [_abd ],_cbeg ^_beca .Data [_abd ],_gebb );
_abd +=_beca .BytesPerLine ;_abbf +=_cadc .BytesPerLine ;};};if _fccg {for _dacbd =0;_dacbd < _bba ;_dacbd ++{for _degc =0;_degc < _badgg ;_degc ++{_cbeg =_geaa (_cadc .Data [_ffgc +_degc ]<<_gedf ,_cadc .Data [_ffgc +_degc +1]>>_agbd ,_bbgee );_beca .Data [_cbca +_degc ]^=_cbeg ;
};_cbca +=_beca .BytesPerLine ;_ffgc +=_cadc .BytesPerLine ;};};if _accac {for _dacbd =0;_dacbd < _bba ;_dacbd ++{_cbeg =_cadc .Data [_ebcg ]<<_gedf ;if _cda {_cbeg =_geaa (_cbeg ,_cadc .Data [_ebcg +1]>>_agbd ,_bbgee );};_beca .Data [_fece ]=_geaa (_beca .Data [_fece ],_cbeg ^_beca .Data [_fece ],_aggb );
_fece +=_beca .BytesPerLine ;_ebcg +=_cadc .BytesPerLine ;};};case PixNotSrcOrDst :if _dfce {for _dacbd =0;_dacbd < _bba ;_dacbd ++{if _bfbbc ==_eafce {_cbeg =_cadc .Data [_abbf ]<<_gedf ;if _afag {_cbeg =_geaa (_cbeg ,_cadc .Data [_abbf +1]>>_agbd ,_bbgee );
};}else {_cbeg =_cadc .Data [_abbf ]>>_agbd ;};_beca .Data [_abd ]=_geaa (_beca .Data [_abd ],^_cbeg |_beca .Data [_abd ],_gebb );_abd +=_beca .BytesPerLine ;_abbf +=_cadc .BytesPerLine ;};};if _fccg {for _dacbd =0;_dacbd < _bba ;_dacbd ++{for _degc =0;
_degc < _badgg ;_degc ++{_cbeg =_geaa (_cadc .Data [_ffgc +_degc ]<<_gedf ,_cadc .Data [_ffgc +_degc +1]>>_agbd ,_bbgee );_beca .Data [_cbca +_degc ]|=^_cbeg ;};_cbca +=_beca .BytesPerLine ;_ffgc +=_cadc .BytesPerLine ;};};if _accac {for _dacbd =0;_dacbd < _bba ;
_dacbd ++{_cbeg =_cadc .Data [_ebcg ]<<_gedf ;if _cda {_cbeg =_geaa (_cbeg ,_cadc .Data [_ebcg +1]>>_agbd ,_bbgee );};_beca .Data [_fece ]=_geaa (_beca .Data [_fece ],^_cbeg |_beca .Data [_fece ],_aggb );_fece +=_beca .BytesPerLine ;_ebcg +=_cadc .BytesPerLine ;
};};case PixNotSrcAndDst :if _dfce {for _dacbd =0;_dacbd < _bba ;_dacbd ++{if _bfbbc ==_eafce {_cbeg =_cadc .Data [_abbf ]<<_gedf ;if _afag {_cbeg =_geaa (_cbeg ,_cadc .Data [_abbf +1]>>_agbd ,_bbgee );};}else {_cbeg =_cadc .Data [_abbf ]>>_agbd ;};_beca .Data [_abd ]=_geaa (_beca .Data [_abd ],^_cbeg &_beca .Data [_abd ],_gebb );
_abd +=_beca .BytesPerLine ;_abbf +=_cadc .BytesPerLine ;};};if _fccg {for _dacbd =0;_dacbd < _bba ;_dacbd ++{for _degc =0;_degc < _badgg ;_degc ++{_cbeg =_geaa (_cadc .Data [_ffgc +_degc ]<<_gedf ,_cadc .Data [_ffgc +_degc +1]>>_agbd ,_bbgee );_beca .Data [_cbca +_degc ]&=^_cbeg ;
};_cbca +=_beca .BytesPerLine ;_ffgc +=_cadc .BytesPerLine ;};};if _accac {for _dacbd =0;_dacbd < _bba ;_dacbd ++{_cbeg =_cadc .Data [_ebcg ]<<_gedf ;if _cda {_cbeg =_geaa (_cbeg ,_cadc .Data [_ebcg +1]>>_agbd ,_bbgee );};_beca .Data [_fece ]=_geaa (_beca .Data [_fece ],^_cbeg &_beca .Data [_fece ],_aggb );
_fece +=_beca .BytesPerLine ;_ebcg +=_cadc .BytesPerLine ;};};case PixSrcOrNotDst :if _dfce {for _dacbd =0;_dacbd < _bba ;_dacbd ++{if _bfbbc ==_eafce {_cbeg =_cadc .Data [_abbf ]<<_gedf ;if _afag {_cbeg =_geaa (_cbeg ,_cadc .Data [_abbf +1]>>_agbd ,_bbgee );
};}else {_cbeg =_cadc .Data [_abbf ]>>_agbd ;};_beca .Data [_abd ]=_geaa (_beca .Data [_abd ],_cbeg |^_beca .Data [_abd ],_gebb );_abd +=_beca .BytesPerLine ;_abbf +=_cadc .BytesPerLine ;};};if _fccg {for _dacbd =0;_dacbd < _bba ;_dacbd ++{for _degc =0;
_degc < _badgg ;_degc ++{_cbeg =_geaa (_cadc .Data [_ffgc +_degc ]<<_gedf ,_cadc .Data [_ffgc +_degc +1]>>_agbd ,_bbgee );_beca .Data [_cbca +_degc ]=_cbeg |^_beca .Data [_cbca +_degc ];};_cbca +=_beca .BytesPerLine ;_ffgc +=_cadc .BytesPerLine ;};};if _accac {for _dacbd =0;
_dacbd < _bba ;_dacbd ++{_cbeg =_cadc .Data [_ebcg ]<<_gedf ;if _cda {_cbeg =_geaa (_cbeg ,_cadc .Data [_ebcg +1]>>_agbd ,_bbgee );};_beca .Data [_fece ]=_geaa (_beca .Data [_fece ],_cbeg |^_beca .Data [_fece ],_aggb );_fece +=_beca .BytesPerLine ;_ebcg +=_cadc .BytesPerLine ;
};};case PixSrcAndNotDst :if _dfce {for _dacbd =0;_dacbd < _bba ;_dacbd ++{if _bfbbc ==_eafce {_cbeg =_cadc .Data [_abbf ]<<_gedf ;if _afag {_cbeg =_geaa (_cbeg ,_cadc .Data [_abbf +1]>>_agbd ,_bbgee );};}else {_cbeg =_cadc .Data [_abbf ]>>_agbd ;};_beca .Data [_abd ]=_geaa (_beca .Data [_abd ],_cbeg &^_beca .Data [_abd ],_gebb );
_abd +=_beca .BytesPerLine ;_abbf +=_cadc .BytesPerLine ;};};if _fccg {for _dacbd =0;_dacbd < _bba ;_dacbd ++{for _degc =0;_degc < _badgg ;_degc ++{_cbeg =_geaa (_cadc .Data [_ffgc +_degc ]<<_gedf ,_cadc .Data [_ffgc +_degc +1]>>_agbd ,_bbgee );_beca .Data [_cbca +_degc ]=_cbeg &^_beca .Data [_cbca +_degc ];
};_cbca +=_beca .BytesPerLine ;_ffgc +=_cadc .BytesPerLine ;};};if _accac {for _dacbd =0;_dacbd < _bba ;_dacbd ++{_cbeg =_cadc .Data [_ebcg ]<<_gedf ;if _cda {_cbeg =_geaa (_cbeg ,_cadc .Data [_ebcg +1]>>_agbd ,_bbgee );};_beca .Data [_fece ]=_geaa (_beca .Data [_fece ],_cbeg &^_beca .Data [_fece ],_aggb );
_fece +=_beca .BytesPerLine ;_ebcg +=_cadc .BytesPerLine ;};};case PixNotPixSrcOrDst :if _dfce {for _dacbd =0;_dacbd < _bba ;_dacbd ++{if _bfbbc ==_eafce {_cbeg =_cadc .Data [_abbf ]<<_gedf ;if _afag {_cbeg =_geaa (_cbeg ,_cadc .Data [_abbf +1]>>_agbd ,_bbgee );
};}else {_cbeg =_cadc .Data [_abbf ]>>_agbd ;};_beca .Data [_abd ]=_geaa (_beca .Data [_abd ],^(_cbeg |_beca .Data [_abd ]),_gebb );_abd +=_beca .BytesPerLine ;_abbf +=_cadc .BytesPerLine ;};};if _fccg {for _dacbd =0;_dacbd < _bba ;_dacbd ++{for _degc =0;
_degc < _badgg ;_degc ++{_cbeg =_geaa (_cadc .Data [_ffgc +_degc ]<<_gedf ,_cadc .Data [_ffgc +_degc +1]>>_agbd ,_bbgee );_beca .Data [_cbca +_degc ]=^(_cbeg |_beca .Data [_cbca +_degc ]);};_cbca +=_beca .BytesPerLine ;_ffgc +=_cadc .BytesPerLine ;};};
if _accac {for _dacbd =0;_dacbd < _bba ;_dacbd ++{_cbeg =_cadc .Data [_ebcg ]<<_gedf ;if _cda {_cbeg =_geaa (_cbeg ,_cadc .Data [_ebcg +1]>>_agbd ,_bbgee );};_beca .Data [_fece ]=_geaa (_beca .Data [_fece ],^(_cbeg |_beca .Data [_fece ]),_aggb );_fece +=_beca .BytesPerLine ;
_ebcg +=_cadc .BytesPerLine ;};};case PixNotPixSrcAndDst :if _dfce {for _dacbd =0;_dacbd < _bba ;_dacbd ++{if _bfbbc ==_eafce {_cbeg =_cadc .Data [_abbf ]<<_gedf ;if _afag {_cbeg =_geaa (_cbeg ,_cadc .Data [_abbf +1]>>_agbd ,_bbgee );};}else {_cbeg =_cadc .Data [_abbf ]>>_agbd ;
};_beca .Data [_abd ]=_geaa (_beca .Data [_abd ],^(_cbeg &_beca .Data [_abd ]),_gebb );_abd +=_beca .BytesPerLine ;_abbf +=_cadc .BytesPerLine ;};};if _fccg {for _dacbd =0;_dacbd < _bba ;_dacbd ++{for _degc =0;_degc < _badgg ;_degc ++{_cbeg =_geaa (_cadc .Data [_ffgc +_degc ]<<_gedf ,_cadc .Data [_ffgc +_degc +1]>>_agbd ,_bbgee );
_beca .Data [_cbca +_degc ]=^(_cbeg &_beca .Data [_cbca +_degc ]);};_cbca +=_beca .BytesPerLine ;_ffgc +=_cadc .BytesPerLine ;};};if _accac {for _dacbd =0;_dacbd < _bba ;_dacbd ++{_cbeg =_cadc .Data [_ebcg ]<<_gedf ;if _cda {_cbeg =_geaa (_cbeg ,_cadc .Data [_ebcg +1]>>_agbd ,_bbgee );
};_beca .Data [_fece ]=_geaa (_beca .Data [_fece ],^(_cbeg &_beca .Data [_fece ]),_aggb );_fece +=_beca .BytesPerLine ;_ebcg +=_cadc .BytesPerLine ;};};case PixNotPixSrcXorDst :if _dfce {for _dacbd =0;_dacbd < _bba ;_dacbd ++{if _bfbbc ==_eafce {_cbeg =_cadc .Data [_abbf ]<<_gedf ;
if _afag {_cbeg =_geaa (_cbeg ,_cadc .Data [_abbf +1]>>_agbd ,_bbgee );};}else {_cbeg =_cadc .Data [_abbf ]>>_agbd ;};_beca .Data [_abd ]=_geaa (_beca .Data [_abd ],^(_cbeg ^_beca .Data [_abd ]),_gebb );_abd +=_beca .BytesPerLine ;_abbf +=_cadc .BytesPerLine ;
};};if _fccg {for _dacbd =0;_dacbd < _bba ;_dacbd ++{for _degc =0;_degc < _badgg ;_degc ++{_cbeg =_geaa (_cadc .Data [_ffgc +_degc ]<<_gedf ,_cadc .Data [_ffgc +_degc +1]>>_agbd ,_bbgee );_beca .Data [_cbca +_degc ]=^(_cbeg ^_beca .Data [_cbca +_degc ]);
};_cbca +=_beca .BytesPerLine ;_ffgc +=_cadc .BytesPerLine ;};};if _accac {for _dacbd =0;_dacbd < _bba ;_dacbd ++{_cbeg =_cadc .Data [_ebcg ]<<_gedf ;if _cda {_cbeg =_geaa (_cbeg ,_cadc .Data [_ebcg +1]>>_agbd ,_bbgee );};_beca .Data [_fece ]=_geaa (_beca .Data [_fece ],^(_cbeg ^_beca .Data [_fece ]),_aggb );
_fece +=_beca .BytesPerLine ;_ebcg +=_cadc .BytesPerLine ;};};default:_fb .Log .Debug ("\u004f\u0070e\u0072\u0061\u0074\u0069\u006f\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006e\u006f\u0074\u0020\u0070\u0065\u0072\u006d\u0069tt\u0065\u0064",_bfa );
return _c .New ("\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065r\u0061\u0074\u0069\u006f\u006e\u0020\u006eo\u0074\u0020\u0070\u0065\u0072\u006d\u0069\u0074\u0074\u0065\u0064");};return nil ;};type colorConverter struct{_abbc func (_bgaa _b .Image )(Image ,error );
};func ImgToGray (i _b .Image )*_b .Gray {if _gbgb ,_fafcf :=i .(*_b .Gray );_fafcf {return _gbgb ;};_ebeag :=i .Bounds ();_befdb :=_b .NewGray (_ebeag );for _abdg :=0;_abdg < _ebeag .Max .X ;_abdg ++{for _gfaf :=0;_gfaf < _ebeag .Max .Y ;_gfaf ++{_aeda :=i .At (_abdg ,_gfaf );
_befdb .Set (_abdg ,_gfaf ,_aeda );};};return _befdb ;};func (_ccbc *RGBA32 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtRGBA32 (x ,y ,_ccbc .Width ,_ccbc .Data ,_ccbc .Alpha ,_ccbc .Decode );};var _ _b .Image =&Gray2 {};var _ _b .Image =&NRGBA16 {};
var _ _b .Image =&NRGBA64 {};func _bac (_bc *Monochrome ,_af ,_fd int )(*Monochrome ,error ){if _bc ==nil {return nil ,_c .New ("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064");};if _af <=0||_fd <=0{return nil ,_c .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0073\u0063\u0061l\u0065\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020<\u003d\u0020\u0030");
};if _af ==_fd {if _af ==1{return _bc .copy (),nil ;};if _af ==2||_af ==4||_af ==8{_edb ,_bad :=_e (_bc ,_af );if _bad !=nil {return nil ,_bad ;};return _edb ,nil ;};};_fcb :=_af *_bc .Width ;_gf :=_fd *_bc .Height ;_ae :=_gead (_fcb ,_gf );_aea :=_ae .BytesPerLine ;
var (_ee ,_fac ,_acgb ,_fbgc ,_faf int ;_bdc byte ;_eg error ;);for _fac =0;_fac < _bc .Height ;_fac ++{_ee =_fd *_fac *_aea ;for _acgb =0;_acgb < _bc .Width ;_acgb ++{if _dae :=_bc .getBitAt (_acgb ,_fac );_dae {_faf =_af *_acgb ;for _fbgc =0;_fbgc < _af ;
_fbgc ++{_ae .setIndexedBit (_ee *8+_faf +_fbgc );};};};for _fbgc =1;_fbgc < _fd ;_fbgc ++{_bff :=_ee +_fbgc *_aea ;for _ffa :=0;_ffa < _aea ;_ffa ++{if _bdc ,_eg =_ae .getByte (_ee +_ffa );_eg !=nil {return nil ,_eg ;};if _eg =_ae .setByte (_bff +_ffa ,_bdc );
_eg !=nil {return nil ,_eg ;};};};};return _ae ,nil ;};func (_gdde *Gray4 )Validate ()error {if len (_gdde .Data )!=_gdde .Height *_gdde .BytesPerLine {return ErrInvalidImage ;};return nil ;};func _gead (_deb ,_dad int )*Monochrome {return &Monochrome {ImageBase :NewImageBase (_deb ,_dad ,1,1,nil ,nil ,nil ),ModelThreshold :0x0f};
};func (_cgc *NRGBA32 )Set (x ,y int ,c _g .Color ){_gbb :=y *_cgc .Width +x ;_bggg :=3*_gbb ;if _bggg +2>=len (_cgc .Data ){return ;};_dbdd :=_g .NRGBAModel .Convert (c ).(_g .NRGBA );_cgc .setRGBA (_gbb ,_dbdd );};func (_ebdb *NRGBA64 )Copy ()Image {return &NRGBA64 {ImageBase :_ebdb .copy ()}};
func _efb (_geab ,_afb CMYK ,_bag _b .Rectangle ){for _cgee :=0;_cgee < _bag .Max .X ;_cgee ++{for _cdb :=0;_cdb < _bag .Max .Y ;_cdb ++{_afb .SetCMYK (_cgee ,_cdb ,_geab .CMYKAt (_cgee ,_cdb ));};};};func (_gcfe *Gray8 )Base ()*ImageBase {return &_gcfe .ImageBase };
func (_fbgfb *Monochrome )clearBit (_ecad ,_ebcb int ){_fbgfb .Data [_ecad ]&=^(0x80>>uint (_ebcb &7))};func (_agg *Monochrome )ReduceBinary (factor float64 )(*Monochrome ,error ){_ggd :=_fgfc (uint (factor ));if !IsPowerOf2 (uint (factor )){_ggd ++;};
_fea :=make ([]int ,_ggd );for _dab :=range _fea {_fea [_dab ]=4;};_dfe ,_aafgc :=_aef (_agg ,_fea ...);if _aafgc !=nil {return nil ,_aafgc ;};return _dfe ,nil ;};func _dgda (_bebg []byte ,_efcaf Image )error {_fcbg :=true ;for _bbbg :=0;_bbbg < len (_bebg );
_bbbg ++{if _bebg [_bbbg ]!=0xff{_fcbg =false ;break ;};};if _fcbg {switch _fbea :=_efcaf .(type ){case *NRGBA32 :_fbea .Alpha =nil ;case *NRGBA64 :_fbea .Alpha =nil ;default:return _cg .Errorf ("i\u006ete\u0072n\u0061l\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020i\u006d\u0061\u0067\u0065\u0020s\u0068\u006f\u0075l\u0064\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0074\u0079\u0070e\u0020\u002a\u004eRGB\u0041\u0033\u0032\u0020\u006f\u0072 \u002a\u004e\u0052\u0047\u0042\u0041\u0036\u0034\u0020\u0062\u0075\u0074 \u0069s\u003a\u0020\u0025\u0054",_efcaf );
};};return nil ;};func ColorAt (x ,y ,width ,bitsPerColor ,colorComponents ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_g .Color ,error ){switch colorComponents {case 1:return ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine ,data ,decode );
case 3:return ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor ,data ,alpha ,decode );case 4:return ColorAtCMYK (x ,y ,width ,data ,decode );default:return nil ,_cg .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0063o\u006c\u006f\u0072\u0020\u0063\u006f\u006dp\u006f\u006e\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0064",colorComponents );
};};func (_cfbc *Gray8 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtGray8BPC (x ,y ,_cfbc .BytesPerLine ,_cfbc .Data ,_cfbc .Decode );};func _gabd (_acca _g .NYCbCrA )_g .NRGBA {_aafa :=int32 (_acca .Y )*0x10101;_ceec :=int32 (_acca .Cb )-128;
_cdbc :=int32 (_acca .Cr )-128;_fcgf :=_aafa +91881*_cdbc ;if uint32 (_fcgf )&0xff000000==0{_fcgf >>=8;}else {_fcgf =^(_fcgf >>31)&0xffff;};_aff :=_aafa -22554*_ceec -46802*_cdbc ;if uint32 (_aff )&0xff000000==0{_aff >>=8;}else {_aff =^(_aff >>31)&0xffff;
};_bfe :=_aafa +116130*_ceec ;if uint32 (_bfe )&0xff000000==0{_bfe >>=8;}else {_bfe =^(_bfe >>31)&0xffff;};return _g .NRGBA {R :uint8 (_fcgf >>8),G :uint8 (_aff >>8),B :uint8 (_bfe >>8),A :_acca .A };};func (_ccad *Monochrome )InverseData ()error {return _ccad .RasterOperation (0,0,_ccad .Width ,_ccad .Height ,PixNotDst ,nil ,0,0);
};func (_egdc *NRGBA16 )setNRGBA (_bfgc ,_edcf ,_gacf int ,_gfbc _g .NRGBA ){if _bfgc *3%2==0{_egdc .Data [_gacf ]=(_gfbc .R >>4)<<4|(_gfbc .G >>4);_egdc .Data [_gacf +1]=(_gfbc .B >>4)<<4|(_egdc .Data [_gacf +1]&0xf);}else {_egdc .Data [_gacf ]=(_egdc .Data [_gacf ]&0xf0)|(_gfbc .R >>4);
_egdc .Data [_gacf +1]=(_gfbc .G >>4)<<4|(_gfbc .B >>4);};if _egdc .Alpha !=nil {_efgf :=_edcf *BytesPerLine (_egdc .Width ,4,1);if _efgf < len (_egdc .Alpha ){if _bfgc %2==0{_egdc .Alpha [_efgf ]=(_gfbc .A >>uint (4))<<uint (4)|(_egdc .Alpha [_gacf ]&0xf);
}else {_egdc .Alpha [_efgf ]=(_egdc .Alpha [_efgf ]&0xf0)|(_gfbc .A >>uint (4));};};};};func (_cgbc *Gray2 )Copy ()Image {return &Gray2 {ImageBase :_cgbc .copy ()}};func (_fcba *Gray8 )SetGray (x ,y int ,g _g .Gray ){_adfg :=y *_fcba .BytesPerLine +x ;
if _adfg > len (_fcba .Data )-1{return ;};_fcba .Data [_adfg ]=g .Y ;};func _aeeff (_gage uint8 )bool {if _gage ==0||_gage ==255{return true ;};return false ;};func _cfb (_dafe _g .RGBA )_g .Gray {_gcee :=(19595*uint32 (_dafe .R )+38470*uint32 (_dafe .G )+7471*uint32 (_dafe .B )+1<<7)>>16;
return _g .Gray {Y :uint8 (_gcee )};};func _aec (_bfd _g .NRGBA )_g .Gray {var _cafd _g .NRGBA ;if _bfd ==_cafd {return _g .Gray {Y :0xff};};_cbad ,_cgd ,_acda ,_ :=_bfd .RGBA ();_dgab :=(19595*_cbad +38470*_cgd +7471*_acda +1<<15)>>24;return _g .Gray {Y :uint8 (_dgab )};
};func _cgb (_cgfa RGBA ,_fgaa CMYK ,_cee _b .Rectangle ){for _adc :=0;_adc < _cee .Max .X ;_adc ++{for _eed :=0;_eed < _cee .Max .Y ;_eed ++{_agbc :=_cgfa .RGBAAt (_adc ,_eed );_fgaa .SetCMYK (_adc ,_eed ,_bded (_agbc ));};};};func (_dedda *NRGBA64 )Base ()*ImageBase {return &_dedda .ImageBase };
type shift int ;func (_beeb *NRGBA16 )NRGBAAt (x ,y int )_g .NRGBA {_ceaae ,_ :=ColorAtNRGBA16 (x ,y ,_beeb .Width ,_beeb .BytesPerLine ,_beeb .Data ,_beeb .Alpha ,_beeb .Decode );return _ceaae ;};func (_gfba *ImageBase )newAlpha (){_gbe :=BytesPerLine (_gfba .Width ,_gfba .BitsPerComponent ,1);
_gfba .Alpha =make ([]byte ,_gfba .Height *_gbe );};func _bcb (_ddfb _g .CMYK )_g .NRGBA {_bcf ,_eda ,_aeg :=_g .CMYKToRGB (_ddfb .C ,_ddfb .M ,_ddfb .Y ,_ddfb .K );return _g .NRGBA {R :_bcf ,G :_eda ,B :_aeg ,A :0xff};};var (MonochromeConverter =ConverterFunc (_aafd );
Gray2Converter =ConverterFunc (_aeed );Gray4Converter =ConverterFunc (_dgf );GrayConverter =ConverterFunc (_babe );Gray16Converter =ConverterFunc (_fde );NRGBA16Converter =ConverterFunc (_bgaf );NRGBAConverter =ConverterFunc (_eeae );NRGBA64Converter =ConverterFunc (_eeaee );
RGBAConverter =ConverterFunc (_babb );CMYKConverter =ConverterFunc (_agbf ););func _fba (_eae _g .Color )_g .Color {_adbcg :=_g .GrayModel .Convert (_eae ).(_g .Gray );return _eecb (_adbcg );};func (_dadg *Gray2 )GrayAt (x ,y int )_g .Gray {_gec ,_ :=ColorAtGray2BPC (x ,y ,_dadg .BytesPerLine ,_dadg .Data ,_dadg .Decode );
return _gec ;};func init (){_gffg ()};func _acf (_dca _g .Gray )_g .RGBA {return _g .RGBA {R :_dca .Y ,G :_dca .Y ,B :_dca .Y ,A :0xff}};func _fgfc (_bbdd uint )uint {var _fffcd uint ;for _bbdd !=0{_bbdd >>=1;_fffcd ++;};return _fffcd -1;};func _eeaee (_bbeg _b .Image )(Image ,error ){if _gadb ,_dffc :=_bbeg .(*NRGBA64 );
_dffc {return _gadb .Copy (),nil ;};_badc ,_fedaa ,_gcda :=_ebecf (_bbeg ,2);_eefd ,_abcb :=NewImage (_badc .Max .X ,_badc .Max .Y ,16,3,nil ,_gcda ,nil );if _abcb !=nil {return nil ,_abcb ;};_gabba (_bbeg ,_eefd ,_badc );if len (_gcda )!=0&&!_fedaa {if _agbg :=_dgda (_gcda ,_eefd );
_agbg !=nil {return nil ,_agbg ;};};return _eefd ,nil ;};func (_dbgf *Gray4 )ColorModel ()_g .Model {return Gray4Model };var _ Gray =&Monochrome {};func _geaa (_cbdf ,_dfg ,_gbgg byte )byte {return (_cbdf &^(_gbgg ))|(_dfg &_gbgg )};func (_ddgc *ImageBase )Pix ()[]byte {return _ddgc .Data };
type Gray interface{GrayAt (_cbc ,_cad int )_g .Gray ;SetGray (_edda ,_dbgd int ,_agf _g .Gray );};type Monochrome struct{ImageBase ;ModelThreshold uint8 ;};func _bde (_egg NRGBA ,_fdd CMYK ,_afbd _b .Rectangle ){for _bga :=0;_bga < _afbd .Max .X ;_bga ++{for _aae :=0;
_aae < _afbd .Max .Y ;_aae ++{_fga :=_egg .NRGBAAt (_bga ,_aae );_fdd .SetCMYK (_bga ,_aae ,_ade (_fga ));};};};func _eeae (_cecd _b .Image )(Image ,error ){if _bdeg ,_bfdfb :=_cecd .(*NRGBA32 );_bfdfb {return _bdeg .Copy (),nil ;};_bdac ,_dec ,_fbfa :=_ebecf (_cecd ,1);
_fgbc ,_ebab :=NewImage (_bdac .Max .X ,_bdac .Max .Y ,8,3,nil ,_fbfa ,nil );if _ebab !=nil {return nil ,_ebab ;};_gdef (_cecd ,_fgbc ,_bdac );if len (_fbfa )!=0&&!_dec {if _gccd :=_dgda (_fbfa ,_fgbc );_gccd !=nil {return nil ,_gccd ;};};return _fgbc ,nil ;
};func (_ggcf *Monochrome )RasterOperation (dx ,dy ,dw ,dh int ,op RasterOperator ,src *Monochrome ,sx ,sy int )error {return _gbfg (_ggcf ,dx ,dy ,dw ,dh ,op ,src ,sx ,sy );};func (_eabc *Gray8 )Histogram ()(_bfgag [256]int ){for _bcce :=0;_bcce < len (_eabc .Data );
_bcce ++{_bfgag [_eabc .Data [_bcce ]]++;};return _bfgag ;};func (_agec *NRGBA64 )At (x ,y int )_g .Color {_afeb ,_ :=_agec .ColorAt (x ,y );return _afeb };var _ Image =&Monochrome {};func (_bdbd monochromeModel )Convert (c _g .Color )_g .Color {_bee :=_g .GrayModel .Convert (c ).(_g .Gray );
return _adf (_bee ,_bdbd );};func (_dbgda *Monochrome )AddPadding ()(_ecea error ){if _fcd :=((_dbgda .Width *_dbgda .Height )+7)>>3;len (_dbgda .Data )< _fcd {return _cg .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064a\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002e\u0020\u0054\u0068\u0065\u0020\u0064\u0061t\u0061\u0020s\u0068\u006fu\u006c\u0064\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0020\u0061\u0074 l\u0065\u0061\u0073\u0074\u003a\u0020\u0027\u0025\u0064'\u0020\u0062\u0079\u0074\u0065\u0073",len (_dbgda .Data ),_fcd );
};_ceff :=_dbgda .Width %8;if _ceff ==0{return nil ;};_cfffa :=_dbgda .Width /8;_dgc :=_cf .NewReader (_dbgda .Data );_egfa :=make ([]byte ,_dbgda .Height *_dbgda .BytesPerLine );_dceg :=_cf .NewWriterMSB (_egfa );_fbf :=make ([]byte ,_cfffa );var (_cbag int ;
_egea uint64 ;);for _cbag =0;_cbag < _dbgda .Height ;_cbag ++{if _ ,_ecea =_dgc .Read (_fbf );_ecea !=nil {return _ecea ;};if _ ,_ecea =_dceg .Write (_fbf );_ecea !=nil {return _ecea ;};if _egea ,_ecea =_dgc .ReadBits (byte (_ceff ));_ecea !=nil {return _ecea ;
};if _ecea =_dceg .WriteByte (byte (_egea )<<uint (8-_ceff ));_ecea !=nil {return _ecea ;};};_dbgda .Data =_dceg .Data ();return nil ;};func _abg (_deab *_b .NYCbCrA ,_ecfae NRGBA ,_fdab _b .Rectangle ){for _fecd :=0;_fecd < _fdab .Max .X ;_fecd ++{for _bbddb :=0;
_bbddb < _fdab .Max .Y ;_bbddb ++{_ddbbb :=_deab .NYCbCrAAt (_fecd ,_bbddb );_ecfae .SetNRGBA (_fecd ,_bbddb ,_gabd (_ddbbb ));};};};func _cdcg (_bcaa *_b .NYCbCrA ,_fgc RGBA ,_gfdb _b .Rectangle ){for _gbefb :=0;_gbefb < _gfdb .Max .X ;_gbefb ++{for _fecfb :=0;
_fecfb < _gfdb .Max .Y ;_fecfb ++{_bcdbb :=_bcaa .NYCbCrAAt (_gbefb ,_fecfb );_fgc .SetRGBA (_gbefb ,_fecfb ,_gbcda (_bcdbb ));};};};func _dbb (_cfff _b .Image ,_afe Image ,_ebe _b .Rectangle ){for _fedb :=0;_fedb < _ebe .Max .X ;_fedb ++{for _gaag :=0;
_gaag < _ebe .Max .Y ;_gaag ++{_cdc :=_cfff .At (_fedb ,_gaag );_afe .Set (_fedb ,_gaag ,_cdc );};};};func (_bacb *Gray2 )Histogram ()(_bbd [256]int ){for _cggcb :=0;_cggcb < _bacb .Width ;_cggcb ++{for _aeee :=0;_aeee < _bacb .Height ;_aeee ++{_bbd [_bacb .GrayAt (_cggcb ,_aeee ).Y ]++;
};};return _bbd ;};func LinearInterpolate (x ,xmin ,xmax ,ymin ,ymax float64 )float64 {if _a .Abs (xmax -xmin )< 0.000001{return ymin ;};_eafd :=ymin +(x -xmin )*(ymax -ymin )/(xmax -xmin );return _eafd ;};func _bcdff (_gdfd ,_gfga NRGBA ,_gdae _b .Rectangle ){for _babca :=0;
_babca < _gdae .Max .X ;_babca ++{for _affc :=0;_affc < _gdae .Max .Y ;_affc ++{_gfga .SetNRGBA (_babca ,_affc ,_gdfd .NRGBAAt (_babca ,_affc ));};};};type monochromeThresholdConverter struct{Threshold uint8 ;};func (_cae *NRGBA16 )ColorModel ()_g .Model {return NRGBA16Model };
func _adf (_eagf _g .Gray ,_ede monochromeModel )_g .Gray {if _eagf .Y > uint8 (_ede ){return _g .Gray {Y :_a .MaxUint8 };};return _g .Gray {};};func NextPowerOf2 (n uint )uint {if IsPowerOf2 (n ){return n ;};return 1<<(_fgfc (n )+1);};var _ Image =&CMYK32 {};
func _ebdg (_gabdg _b .Image ,_gaca Image ,_gaef _b .Rectangle ){switch _bfcc :=_gabdg .(type ){case Gray :_bgge (_bfcc ,_gaca .(Gray ),_gaef );case NRGBA :_eceb (_bfcc ,_gaca .(Gray ),_gaef );case CMYK :_ggabb (_bfcc ,_gaca .(Gray ),_gaef );case RGBA :_agff (_bfcc ,_gaca .(Gray ),_gaef );
default:_dbb (_gabdg ,_gaca ,_gaef );};};var _ _b .Image =&Gray4 {};func (_eacee *NRGBA32 )At (x ,y int )_g .Color {_cgaa ,_ :=_eacee .ColorAt (x ,y );return _cgaa };var _ NRGBA =&NRGBA16 {};func MonochromeThresholdConverter (threshold uint8 )ColorConverter {return &monochromeThresholdConverter {Threshold :threshold };
};func (_eedf *Gray4 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtGray4BPC (x ,y ,_eedf .BytesPerLine ,_eedf .Data ,_eedf .Decode );};func (_gdb *Gray2 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtGray2BPC (x ,y ,_gdb .BytesPerLine ,_gdb .Data ,_gdb .Decode );
};func (_aaga *RGBA32 )Set (x ,y int ,c _g .Color ){_gee :=y *_aaga .Width +x ;_cgdf :=3*_gee ;if _cgdf +2>=len (_aaga .Data ){return ;};_caef :=_g .RGBAModel .Convert (c ).(_g .RGBA );_aaga .setRGBA (_gee ,_caef );};func ColorAtGray1BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_g .Gray ,error ){_efbg :=y *bytesPerLine +x >>3;
if _efbg >=len (data ){return _g .Gray {},_cg .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_dbeg :=data [_efbg ]>>uint (7-(x &7))&1;if len (decode )==2{_dbeg =uint8 (LinearInterpolate (float64 (_dbeg ),0.0,1.0,decode [0],decode [1]))&1;};return _g .Gray {Y :_dbeg *255},nil ;};func (_ebb *Gray4 )Bounds ()_b .Rectangle {return _b .Rectangle {Max :_b .Point {X :_ebb .Width ,Y :_ebb .Height }};
};func (_fge *ImageBase )setTwoBytes (_bcfd int ,_cefb uint16 )error {if _bcfd +1> len (_fge .Data )-1{return _c .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_fge .Data [_bcfd ]=byte ((_cefb &0xff00)>>8);
_fge .Data [_bcfd +1]=byte (_cefb &0xff);return nil ;};func ConverterFunc (converterFunc func (_edc _b .Image )(Image ,error ))ColorConverter {return colorConverter {_abbc :converterFunc };};type RGBA32 struct{ImageBase };func _cgfe (_facd _g .RGBA )_g .NRGBA {switch _facd .A {case 0xff:return _g .NRGBA {R :_facd .R ,G :_facd .G ,B :_facd .B ,A :0xff};
case 0x00:return _g .NRGBA {};default:_feeg ,_fbcg ,_bgac ,_gae :=_facd .RGBA ();_feeg =(_feeg *0xffff)/_gae ;_fbcg =(_fbcg *0xffff)/_gae ;_bgac =(_bgac *0xffff)/_gae ;return _g .NRGBA {R :uint8 (_feeg >>8),G :uint8 (_fbcg >>8),B :uint8 (_bgac >>8),A :uint8 (_gae >>8)};
};};func (_aege *NRGBA32 )Validate ()error {if len (_aege .Data )!=3*_aege .Width *_aege .Height {return _c .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};var _gdgf [256]uint8 ;func (_cddae *NRGBA32 )SetNRGBA (x ,y int ,c _g .NRGBA ){_febg :=y *_cddae .Width +x ;_bedf :=3*_febg ;if _bedf +2>=len (_cddae .Data ){return ;};_cddae .setRGBA (_febg ,c );};func ColorAtRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_g .RGBA ,error ){_cfca :=y *width +x ;
_fgaf :=3*_cfca ;if _fgaf +2>=len (data ){return _g .RGBA {},_cg .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_agcdg :=uint8 (0xff);if alpha !=nil &&len (alpha )> _cfca {_agcdg =alpha [_cfca ];};_bbdc ,_ccdb ,_gbef :=data [_fgaf ],data [_fgaf +1],data [_fgaf +2];if len (decode )==6{_bbdc =uint8 (uint32 (LinearInterpolate (float64 (_bbdc ),0,255,decode [0],decode [1]))&0xff);
_ccdb =uint8 (uint32 (LinearInterpolate (float64 (_ccdb ),0,255,decode [2],decode [3]))&0xff);_gbef =uint8 (uint32 (LinearInterpolate (float64 (_gbef ),0,255,decode [4],decode [5]))&0xff);};return _g .RGBA {R :_bbdc ,G :_ccdb ,B :_gbef ,A :_agcdg },nil ;
};func (_fbcgd *Gray8 )At (x ,y int )_g .Color {_befc ,_ :=_fbcgd .ColorAt (x ,y );return _befc };func _fede (_dfcee nrgba64 ,_bdag NRGBA ,_eddg _b .Rectangle ){for _eaea :=0;_eaea < _eddg .Max .X ;_eaea ++{for _ffcd :=0;_ffcd < _eddg .Max .Y ;_ffcd ++{_gdaf :=_dfcee .NRGBA64At (_eaea ,_ffcd );
_bdag .SetNRGBA (_eaea ,_ffcd ,_eede (_gdaf ));};};};const (_eafce shift =iota ;_bce ;);type NRGBA interface{NRGBAAt (_aggg ,_aadb int )_g .NRGBA ;SetNRGBA (_fbef ,_eabg int ,_gfbd _g .NRGBA );};func _gffg (){for _ggec :=0;_ggec < 256;_ggec ++{_gdgf [_ggec ]=uint8 (_ggec &0x1)+(uint8 (_ggec >>1)&0x1)+(uint8 (_ggec >>2)&0x1)+(uint8 (_ggec >>3)&0x1)+(uint8 (_ggec >>4)&0x1)+(uint8 (_ggec >>5)&0x1)+(uint8 (_ggec >>6)&0x1)+(uint8 (_ggec >>7)&0x1);
};};func (_ecfe *ImageBase )setFourBytes (_fbag int ,_ffcb uint32 )error {if _fbag +3> len (_ecfe .Data )-1{return _cg .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006fu\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065",_fbag );
};_ecfe .Data [_fbag ]=byte ((_ffcb &0xff000000)>>24);_ecfe .Data [_fbag +1]=byte ((_ffcb &0xff0000)>>16);_ecfe .Data [_fbag +2]=byte ((_ffcb &0xff00)>>8);_ecfe .Data [_fbag +3]=byte (_ffcb &0xff);return nil ;};func _cab ()(_agcb []byte ){_agcb =make ([]byte ,256);
for _fef :=0;_fef < 256;_fef ++{_fcca :=byte (_fef );_agcb [_fcca ]=(_fcca &0x01)|((_fcca &0x04)>>1)|((_fcca &0x10)>>2)|((_fcca &0x40)>>3)|((_fcca &0x02)<<3)|((_fcca &0x08)<<2)|((_fcca &0x20)<<1)|(_fcca &0x80);};return _agcb ;};func (_fcac *Gray16 )Bounds ()_b .Rectangle {return _b .Rectangle {Max :_b .Point {X :_fcac .Width ,Y :_fcac .Height }};
};func (_ecgg *NRGBA16 )Bounds ()_b .Rectangle {return _b .Rectangle {Max :_b .Point {X :_ecgg .Width ,Y :_ecgg .Height }};};func _adb ()(_dcg [256]uint64 ){for _dga :=0;_dga < 256;_dga ++{if _dga &0x01!=0{_dcg [_dga ]|=0xff;};if _dga &0x02!=0{_dcg [_dga ]|=0xff00;
};if _dga &0x04!=0{_dcg [_dga ]|=0xff0000;};if _dga &0x08!=0{_dcg [_dga ]|=0xff000000;};if _dga &0x10!=0{_dcg [_dga ]|=0xff00000000;};if _dga &0x20!=0{_dcg [_dga ]|=0xff0000000000;};if _dga &0x40!=0{_dcg [_dga ]|=0xff000000000000;};if _dga &0x80!=0{_dcg [_dga ]|=0xff00000000000000;
};};return _dcg ;};func (_gdca *Gray8 )ColorModel ()_g .Model {return _g .GrayModel };func _babb (_edbfa _b .Image )(Image ,error ){if _dbfc ,_edag :=_edbfa .(*RGBA32 );_edag {return _dbfc .Copy (),nil ;};_bagge ,_caab ,_eefcb :=_ebecf (_edbfa ,1);_gcae :=&RGBA32 {ImageBase :NewImageBase (_bagge .Max .X ,_bagge .Max .Y ,8,3,nil ,_eefcb ,nil )};
_adfe (_edbfa ,_gcae ,_bagge );if len (_eefcb )!=0&&!_caab {if _fedd :=_dgda (_eefcb ,_gcae );_fedd !=nil {return nil ,_fedd ;};};return _gcae ,nil ;};func ColorAtNRGBA16 (x ,y ,width ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_g .NRGBA ,error ){_bgacc :=y *bytesPerLine +x *3/2;
if _bgacc +1>=len (data ){return _g .NRGBA {},_fegg (x ,y );};const (_bcfa =0xf;_cggg =uint8 (0xff););_bfef :=_cggg ;if alpha !=nil {_fgad :=y *BytesPerLine (width ,4,1);if _fgad < len (alpha ){if x %2==0{_bfef =(alpha [_fgad ]>>uint (4))&_bcfa ;}else {_bfef =alpha [_fgad ]&_bcfa ;
};_bfef |=_bfef <<4;};};var _cbea ,_gfbe ,_fcfa uint8 ;if x *3%2==0{_cbea =(data [_bgacc ]>>uint (4))&_bcfa ;_gfbe =data [_bgacc ]&_bcfa ;_fcfa =(data [_bgacc +1]>>uint (4))&_bcfa ;}else {_cbea =data [_bgacc ]&_bcfa ;_gfbe =(data [_bgacc +1]>>uint (4))&_bcfa ;
_fcfa =data [_bgacc +1]&_bcfa ;};if len (decode )==6{_cbea =uint8 (uint32 (LinearInterpolate (float64 (_cbea ),0,15,decode [0],decode [1]))&0xf);_gfbe =uint8 (uint32 (LinearInterpolate (float64 (_gfbe ),0,15,decode [2],decode [3]))&0xf);_fcfa =uint8 (uint32 (LinearInterpolate (float64 (_fcfa ),0,15,decode [4],decode [5]))&0xf);
};return _g .NRGBA {R :(_cbea <<4)|(_cbea &0xf),G :(_gfbe <<4)|(_gfbe &0xf),B :(_fcfa <<4)|(_fcfa &0xf),A :_bfef },nil ;};func _gbcda (_gbf _g .NYCbCrA )_g .RGBA {_ceaa ,_eged ,_ggge ,_dfcd :=_gabd (_gbf ).RGBA ();return _g .RGBA {R :uint8 (_ceaa >>8),G :uint8 (_eged >>8),B :uint8 (_ggge >>8),A :uint8 (_dfcd >>8)};
};func ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine int ,data []byte ,decode []float64 )(_g .Color ,error ){switch bitsPerColor {case 1:return ColorAtGray1BPC (x ,y ,bytesPerLine ,data ,decode );case 2:return ColorAtGray2BPC (x ,y ,bytesPerLine ,data ,decode );
case 4:return ColorAtGray4BPC (x ,y ,bytesPerLine ,data ,decode );case 8:return ColorAtGray8BPC (x ,y ,bytesPerLine ,data ,decode );case 16:return ColorAtGray16BPC (x ,y ,bytesPerLine ,data ,decode );default:return nil ,_cg .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0067\u0072\u0061\u0079\u0020\u0073c\u0061\u006c\u0065\u0020\u0062\u0069\u0074s\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020a\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );
};};func (_ccbf *Gray4 )Set (x ,y int ,c _g .Color ){if x >=_ccbf .Width ||y >=_ccbf .Height {return ;};_egabe :=Gray4Model .Convert (c ).(_g .Gray );_ccbf .setGray (x ,y ,_egabe );};func _bgaf (_fadb _b .Image )(Image ,error ){if _aefb ,_egfee :=_fadb .(*NRGBA16 );
_egfee {return _aefb .Copy (),nil ;};_gfffgf :=_fadb .Bounds ();_bfac ,_dfef :=NewImage (_gfffgf .Max .X ,_gfffgf .Max .Y ,4,3,nil ,nil ,nil );if _dfef !=nil {return nil ,_dfef ;};_gdef (_fadb ,_bfac ,_gfffgf );return _bfac ,nil ;};func _gbfg (_bada *Monochrome ,_ada ,_dgdda ,_gcag ,_agbce int ,_geca RasterOperator ,_bbge *Monochrome ,_adbfc ,_gcgg int )error {if _bada ==nil {return _c .New ("\u006e\u0069\u006c\u0020\u0027\u0064\u0065\u0073\u0074\u0027\u0020\u0042i\u0074\u006d\u0061\u0070");
};if _geca ==PixDst {return nil ;};switch _geca {case PixClr ,PixSet ,PixNotDst :_cccg (_bada ,_ada ,_dgdda ,_gcag ,_agbce ,_geca );return nil ;};if _bbge ==nil {_fb .Log .Debug ("\u0052a\u0073\u0074e\u0072\u004f\u0070\u0065r\u0061\u0074\u0069o\u006e\u0020\u0073\u006f\u0075\u0072\u0063\u0065\u0020bi\u0074\u006d\u0061p\u0020\u0069s\u0020\u006e\u006f\u0074\u0020\u0064e\u0066\u0069n\u0065\u0064");
return _c .New ("\u006e\u0069l\u0020\u0027\u0073r\u0063\u0027\u0020\u0062\u0069\u0074\u006d\u0061\u0070");};if _ggfg :=_gabdd (_bada ,_ada ,_dgdda ,_gcag ,_agbce ,_geca ,_bbge ,_adbfc ,_gcgg );_ggfg !=nil {return _ggfg ;};return nil ;};func (_ffbd *RGBA32 )Bounds ()_b .Rectangle {return _b .Rectangle {Max :_b .Point {X :_ffbd .Width ,Y :_ffbd .Height }};
};func (_deg *Gray8 )Validate ()error {if len (_deg .Data )!=_deg .Height *_deg .BytesPerLine {return ErrInvalidImage ;};return nil ;};func ColorAtGray16BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_g .Gray16 ,error ){_gcdbf :=(y *bytesPerLine /2+x )*2;
if _gcdbf +1>=len (data ){return _g .Gray16 {},_cg .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_gdba :=uint16 (data [_gcdbf ])<<8|uint16 (data [_gcdbf +1]);if len (decode )==2{_gdba =uint16 (uint64 (LinearInterpolate (float64 (_gdba ),0,65535,decode [0],decode [1])));};return _g .Gray16 {Y :_gdba },nil ;};func _fde (_feaf _b .Image )(Image ,error ){if _dddb ,_eafb :=_feaf .(*Gray16 );
_eafb {return _dddb .Copy (),nil ;};_acdf :=_feaf .Bounds ();_ggea ,_agee :=NewImage (_acdf .Max .X ,_acdf .Max .Y ,16,1,nil ,nil ,nil );if _agee !=nil {return nil ,_agee ;};_ebdg (_feaf ,_ggea ,_acdf );return _ggea ,nil ;};type NRGBA32 struct{ImageBase };
func (_efea colorConverter )Convert (src _b .Image )(Image ,error ){return _efea ._abbc (src )};func (_bagg *Gray16 )Validate ()error {if len (_bagg .Data )!=_bagg .Height *_bagg .BytesPerLine {return ErrInvalidImage ;};return nil ;};type NRGBA16 struct{ImageBase };
func (_dgfc *Gray16 )Histogram ()(_bcgg [256]int ){for _bbb :=0;_bbb < _dgfc .Width ;_bbb ++{for _gcfg :=0;_gcfg < _dgfc .Height ;_gcfg ++{_bcgg [_dgfc .GrayAt (_bbb ,_gcfg ).Y ]++;};};return _bcgg ;};func _eaff (_dbba _g .NRGBA64 )_g .Gray {var _dcaa _g .NRGBA64 ;
if _dbba ==_dcaa {return _g .Gray {Y :0xff};};_gfde ,_fgb ,_abee ,_ :=_dbba .RGBA ();_dfa :=(19595*_gfde +38470*_fgb +7471*_abee +1<<15)>>24;return _g .Gray {Y :uint8 (_dfa )};};func _bgge (_ecee ,_ebea Gray ,_bbbd _b .Rectangle ){for _bcac :=0;_bcac < _bbbd .Max .X ;
_bcac ++{for _bdbg :=0;_bdbg < _bbbd .Max .Y ;_bdbg ++{_ebea .SetGray (_bcac ,_bdbg ,_ecee .GrayAt (_bcac ,_bdbg ));};};};func MonochromeModel (threshold uint8 )_g .Model {return monochromeModel (threshold )};func (_bead *Gray8 )Bounds ()_b .Rectangle {return _b .Rectangle {Max :_b .Point {X :_bead .Width ,Y :_bead .Height }};
};func ColorAtGray4BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_g .Gray ,error ){_adbcc :=y *bytesPerLine +x >>1;if _adbcc >=len (data ){return _g .Gray {},_cg .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_geb :=data [_adbcc ]>>uint (4-(x &1)*4)&0xf;if len (decode )==2{_geb =uint8 (uint32 (LinearInterpolate (float64 (_geb ),0,15,decode [0],decode [1]))&0xf);};return _g .Gray {Y :_geb *17&0xff},nil ;};func (_beg *Gray4 )SetGray (x ,y int ,g _g .Gray ){if x >=_beg .Width ||y >=_beg .Height {return ;
};g =_fcde (g );_beg .setGray (x ,y ,g );};func _cccg (_bgc *Monochrome ,_gacae ,_bedcd ,_fbcf ,_ddcd int ,_gcdc RasterOperator ){if _gacae < 0{_fbcf +=_gacae ;_gacae =0;};_bcfdc :=_gacae +_fbcf -_bgc .Width ;if _bcfdc > 0{_fbcf -=_bcfdc ;};if _bedcd < 0{_ddcd +=_bedcd ;
_bedcd =0;};_gcbd :=_bedcd +_ddcd -_bgc .Height ;if _gcbd > 0{_ddcd -=_gcbd ;};if _fbcf <=0||_ddcd <=0{return ;};if (_gacae &7)==0{_efgd (_bgc ,_gacae ,_bedcd ,_fbcf ,_ddcd ,_gcdc );}else {_afcga (_bgc ,_gacae ,_bedcd ,_fbcf ,_ddcd ,_gcdc );};};func _ecaa (_dace ,_dbbd RGBA ,_accfa _b .Rectangle ){for _acee :=0;
_acee < _accfa .Max .X ;_acee ++{for _gcfd :=0;_gcfd < _accfa .Max .Y ;_gcfd ++{_dbbd .SetRGBA (_acee ,_gcfd ,_dace .RGBAAt (_acee ,_gcfd ));};};};var _ _b .Image =&RGBA32 {};func (_deag *Monochrome )getBitAt (_cdde ,_dgdc int )bool {_gbae :=_dgdc *_deag .BytesPerLine +(_cdde >>3);
_geag :=_cdde &0x07;_fbdc :=uint (7-_geag );if _gbae > len (_deag .Data )-1{return false ;};if (_deag .Data [_gbae ]>>_fbdc )&0x01>=1{return true ;};return false ;};func _gdg (_ggag _g .CMYK )_g .Gray {_gcd ,_adg ,_fgba :=_g .CMYKToRGB (_ggag .C ,_ggag .M ,_ggag .Y ,_ggag .K );
_dbg :=(19595*uint32 (_gcd )+38470*uint32 (_adg )+7471*uint32 (_fgba )+1<<7)>>16;return _g .Gray {Y :uint8 (_dbg )};};func (_eaf *CMYK32 )Validate ()error {if len (_eaf .Data )!=4*_eaf .Width *_eaf .Height {return _c .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func GrayHistogram (g Gray )(_bbee [256]int ){switch _bcgb :=g .(type ){case Histogramer :return _bcgb .Histogram ();case _b .Image :_bbce :=_bcgb .Bounds ();for _ebbbg :=0;_ebbbg < _bbce .Max .X ;_ebbbg ++{for _bdgfe :=0;_bdgfe < _bbce .Max .Y ;
_bdgfe ++{_bbee [g .GrayAt (_ebbbg ,_bdgfe ).Y ]++;};};return _bbee ;default:return [256]int {};};};func BytesPerLine (width ,bitsPerComponent ,colorComponents int )int {return ((width *bitsPerComponent )*colorComponents +7)>>3;};func (_deff *RGBA32 )Copy ()Image {return &RGBA32 {ImageBase :_deff .copy ()}};
func (_fbcc *Monochrome )setGrayBit (_edee ,_bge int ){_fbcc .Data [_edee ]|=0x80>>uint (_bge &7)};func InDelta (expected ,current ,delta float64 )bool {_bcbc :=expected -current ;if _bcbc <=-delta ||_bcbc >=delta {return false ;};return true ;};func (_afab *Gray2 )Validate ()error {if len (_afab .Data )!=_afab .Height *_afab .BytesPerLine {return ErrInvalidImage ;
};return nil ;};func AddDataPadding (width ,height ,bitsPerComponent ,colorComponents int ,data []byte )([]byte ,error ){_degf :=BytesPerLine (width ,bitsPerComponent ,colorComponents );if _degf ==width *colorComponents *bitsPerComponent /8{return data ,nil ;
};_cebd :=width *colorComponents *bitsPerComponent ;_cffd :=_degf *8;_egfd :=8-(_cffd -_cebd );_cffb :=_cf .NewReader (data );_dadb :=_degf -1;_bda :=make ([]byte ,_dadb );_ecfb :=make ([]byte ,height *_degf );_dgcg :=_cf .NewWriterMSB (_ecfb );var _bbfa uint64 ;
var _eadgg error ;for _dcff :=0;_dcff < height ;_dcff ++{_ ,_eadgg =_cffb .Read (_bda );if _eadgg !=nil {return nil ,_eadgg ;};_ ,_eadgg =_dgcg .Write (_bda );if _eadgg !=nil {return nil ,_eadgg ;};_bbfa ,_eadgg =_cffb .ReadBits (byte (_egfd ));if _eadgg !=nil {return nil ,_eadgg ;
};_ ,_eadgg =_dgcg .WriteBits (_bbfa ,_egfd );if _eadgg !=nil {return nil ,_eadgg ;};_dgcg .FinishByte ();};return _ecfb ,nil ;};func _gabdd (_dffg *Monochrome ,_dbeb ,_dbdc int ,_bbgf ,_fbe int ,_ebbc RasterOperator ,_egbd *Monochrome ,_gda ,_efae int )error {var _dfeb ,_afdf ,_baaag ,_fcaa int ;
if _dbeb < 0{_gda -=_dbeb ;_bbgf +=_dbeb ;_dbeb =0;};if _gda < 0{_dbeb -=_gda ;_bbgf +=_gda ;_gda =0;};_dfeb =_dbeb +_bbgf -_dffg .Width ;if _dfeb > 0{_bbgf -=_dfeb ;};_afdf =_gda +_bbgf -_egbd .Width ;if _afdf > 0{_bbgf -=_afdf ;};if _dbdc < 0{_efae -=_dbdc ;
_fbe +=_dbdc ;_dbdc =0;};if _efae < 0{_dbdc -=_efae ;_fbe +=_efae ;_efae =0;};_baaag =_dbdc +_fbe -_dffg .Height ;if _baaag > 0{_fbe -=_baaag ;};_fcaa =_efae +_fbe -_egbd .Height ;if _fcaa > 0{_fbe -=_fcaa ;};if _bbgf <=0||_fbe <=0{return nil ;};var _fdda error ;
switch {case _dbeb &7==0&&_gda &7==0:_fdda =_dbgc (_dffg ,_dbeb ,_dbdc ,_bbgf ,_fbe ,_ebbc ,_egbd ,_gda ,_efae );case _dbeb &7==_gda &7:_fdda =_fecf (_dffg ,_dbeb ,_dbdc ,_bbgf ,_fbe ,_ebbc ,_egbd ,_gda ,_efae );default:_fdda =_bfdf (_dffg ,_dbeb ,_dbdc ,_bbgf ,_fbe ,_ebbc ,_egbd ,_gda ,_efae );
};if _fdda !=nil {return _fdda ;};return nil ;};type Gray4 struct{ImageBase };func _gba (_gff int )[]uint {var _ddd []uint ;_cea :=_gff ;_eab :=_cea /8;if _eab !=0{for _abc :=0;_abc < _eab ;_abc ++{_ddd =append (_ddd ,8);};_afc :=_cea %8;_cea =0;if _afc !=0{_cea =_afc ;
};};_efg :=_cea /4;if _efg !=0{for _aa :=0;_aa < _efg ;_aa ++{_ddd =append (_ddd ,4);};_abf :=_cea %4;_cea =0;if _abf !=0{_cea =_abf ;};};_gg :=_cea /2;if _gg !=0{for _ceg :=0;_ceg < _gg ;_ceg ++{_ddd =append (_ddd ,2);};};return _ddd ;};var ErrInvalidImage =_c .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
func (_fdgd *Monochrome )Base ()*ImageBase {return &_fdgd .ImageBase };func (_ccade *NRGBA16 )SetNRGBA (x ,y int ,c _g .NRGBA ){_bdgc :=y *_ccade .BytesPerLine +x *3/2;if _bdgc +1>=len (_ccade .Data ){return ;};c =_cegc (c );_ccade .setNRGBA (x ,y ,_bdgc ,c );
};func (_acde *ImageBase )setEightFullBytes (_cfcg int ,_bfbg uint64 )error {if _cfcg +7> len (_acde .Data )-1{return _c .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_acde .Data [_cfcg ]=byte ((_bfbg &0xff00000000000000)>>56);
_acde .Data [_cfcg +1]=byte ((_bfbg &0xff000000000000)>>48);_acde .Data [_cfcg +2]=byte ((_bfbg &0xff0000000000)>>40);_acde .Data [_cfcg +3]=byte ((_bfbg &0xff00000000)>>32);_acde .Data [_cfcg +4]=byte ((_bfbg &0xff000000)>>24);_acde .Data [_cfcg +5]=byte ((_bfbg &0xff0000)>>16);
_acde .Data [_cfcg +6]=byte ((_bfbg &0xff00)>>8);_acde .Data [_cfcg +7]=byte (_bfbg &0xff);return nil ;};func _e (_db *Monochrome ,_acg int )(*Monochrome ,error ){if _db ==nil {return nil ,_c .New ("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064");
};if _acg ==1{return _db .copy (),nil ;};if !IsPowerOf2 (uint (_acg )){return nil ,_cg .Errorf ("\u0070\u0072\u006fvi\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006ci\u0064 \u0065x\u0070a\u006e\u0064\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_acg );
};_bf :=_gba (_acg );return _ce (_db ,_acg ,_bf );};var _ _b .Image =&NRGBA32 {};func (_dfac *Monochrome )ColorModel ()_g .Model {return MonochromeModel (_dfac .ModelThreshold )};func (_efda *NRGBA16 )Validate ()error {if len (_efda .Data )!=3*_efda .Width *_efda .Height /2{return _c .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func (_fce *NRGBA64 )SetNRGBA64 (x ,y int ,c _g .NRGBA64 ){_gabf :=(y *_fce .Width +x )*2;_fdf :=_gabf *3;if _fdf +5>=len (_fce .Data ){return ;};_fce .setNRGBA64 (_fdf ,c ,_gabf );};func (_dbe *Monochrome )setIndexedBit (_bcdd int ){_dbe .Data [(_bcdd >>3)]|=0x80>>uint (_bcdd &7)};
func IsGrayImgBlackAndWhite (i *_b .Gray )bool {return _cfea (i )};func (_fgbag *NRGBA32 )NRGBAAt (x ,y int )_g .NRGBA {_bcdb ,_ :=ColorAtNRGBA32 (x ,y ,_fgbag .Width ,_fgbag .Data ,_fgbag .Alpha ,_fgbag .Decode );return _bcdb ;};func _ade (_aag _g .NRGBA )_g .CMYK {_fag ,_gbdc ,_ecg ,_ :=_aag .RGBA ();
_fffd ,_gdcd ,_afd ,_eafg :=_g .RGBToCMYK (uint8 (_fag >>8),uint8 (_gbdc >>8),uint8 (_ecg >>8));return _g .CMYK {C :_fffd ,M :_gdcd ,Y :_afd ,K :_eafg };};type CMYK32 struct{ImageBase };var _ RGBA =&RGBA32 {};func FromGoImage (i _b .Image )(Image ,error ){switch _dbgg :=i .(type ){case Image :return _dbgg .Copy (),nil ;
case Gray :return GrayConverter .Convert (i );case *_b .Gray16 :return Gray16Converter .Convert (i );case CMYK :return CMYKConverter .Convert (i );case *_b .NRGBA64 :return NRGBA64Converter .Convert (i );default:return NRGBAConverter .Convert (i );};};
func _babe (_abeb _b .Image )(Image ,error ){if _ccf ,_bcfcf :=_abeb .(*Gray8 );_bcfcf {return _ccf .Copy (),nil ;};_adff :=_abeb .Bounds ();_ebfgg ,_gfdeb :=NewImage (_adff .Max .X ,_adff .Max .Y ,8,1,nil ,nil ,nil );if _gfdeb !=nil {return nil ,_gfdeb ;
};_ebdg (_abeb ,_ebfgg ,_adff );return _ebfgg ,nil ;};func (_gdd *CMYK32 )CMYKAt (x ,y int )_g .CMYK {_cebe ,_ :=ColorAtCMYK (x ,y ,_gdd .Width ,_gdd .Data ,_gdd .Decode );return _cebe ;};func _dbgdb (_abbd Gray ,_gcdg nrgba64 ,_bdg _b .Rectangle ){for _cfdf :=0;
_cfdf < _bdg .Max .X ;_cfdf ++{for _gddf :=0;_gddf < _bdg .Max .Y ;_gddf ++{_fgf :=_eaff (_gcdg .NRGBA64At (_cfdf ,_gddf ));_abbd .SetGray (_cfdf ,_gddf ,_fgf );};};};func _bedg (_febb nrgba64 ,_bfdff RGBA ,_bcec _b .Rectangle ){for _ebbf :=0;_ebbf < _bcec .Max .X ;
_ebbf ++{for _cfge :=0;_cfge < _bcec .Max .Y ;_cfge ++{_gaaa :=_febb .NRGBA64At (_ebbf ,_cfge );_bfdff .SetRGBA (_ebbf ,_cfge ,_gdcb (_gaaa ));};};};func (_eaeg *RGBA32 )SetRGBA (x ,y int ,c _g .RGBA ){_fegb :=y *_eaeg .Width +x ;_fgde :=3*_fegb ;if _fgde +2>=len (_eaeg .Data ){return ;
};_eaeg .setRGBA (_fegb ,c );};func NewImageBase (width int ,height int ,bitsPerComponent int ,colorComponents int ,data []byte ,alpha []byte ,decode []float64 )ImageBase {_debec :=ImageBase {Width :width ,Height :height ,BitsPerComponent :bitsPerComponent ,ColorComponents :colorComponents ,Data :data ,Alpha :alpha ,Decode :decode ,BytesPerLine :BytesPerLine (width ,bitsPerComponent ,colorComponents )};
if data ==nil {_debec .Data =make ([]byte ,height *_debec .BytesPerLine );};return _debec ;};type Gray8 struct{ImageBase };func (_cfa *ImageBase )getByte (_fdag int )(byte ,error ){if _fdag > len (_cfa .Data )-1||_fdag < 0{return 0,_cg .Errorf ("\u0069\u006e\u0064\u0065x:\u0020\u0025\u0064\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006eg\u0065",_fdag );
};return _cfa .Data [_fdag ],nil ;};func _agbf (_efe _b .Image )(Image ,error ){if _dff ,_bcdf :=_efe .(*CMYK32 );_bcdf {return _dff .Copy (),nil ;};_egb :=_efe .Bounds ();_fbbg ,_gegf :=NewImage (_egb .Max .X ,_egb .Max .Y ,8,4,nil ,nil ,nil );if _gegf !=nil {return nil ,_gegf ;
};switch _gfgf :=_efe .(type ){case CMYK :_efb (_gfgf ,_fbbg .(CMYK ),_egb );case Gray :_egd (_gfgf ,_fbbg .(CMYK ),_egb );case NRGBA :_bde (_gfgf ,_fbbg .(CMYK ),_egb );case RGBA :_cgb (_gfgf ,_fbbg .(CMYK ),_egb );default:_dbb (_efe ,_fbbg ,_egb );};
return _fbbg ,nil ;};type RasterOperator int ;func _ffag (_caabf CMYK ,_ggafb RGBA ,_agea _b .Rectangle ){for _gfbcf :=0;_gfbcf < _agea .Max .X ;_gfbcf ++{for _gceg :=0;_gceg < _agea .Max .Y ;_gceg ++{_ebga :=_caabf .CMYKAt (_gfbcf ,_gceg );_ggafb .SetRGBA (_gfbcf ,_gceg ,_ebac (_ebga ));
};};};func _cfea (_cedd *_b .Gray )bool {for _gedab :=0;_gedab < len (_cedd .Pix );_gedab ++{if !_aeeff (_cedd .Pix [_gedab ]){return false ;};};return true ;};var _ Image =&NRGBA16 {};func _ebac (_ebed _g .CMYK )_g .RGBA {_cebb ,_gdc ,_ffc :=_g .CMYKToRGB (_ebed .C ,_ebed .M ,_ebed .Y ,_ebed .K );
return _g .RGBA {R :_cebb ,G :_gdc ,B :_ffc ,A :0xff};};func _cba (_gaf ,_dac *Monochrome ,_ega []byte ,_cfd int )(_eaa error ){var (_bdd ,_eec ,_cbd ,_babc ,_dgg ,_dea ,_ege ,_cce int ;_eag ,_edg uint32 ;_dfb ,_cef byte ;_aaa uint16 ;);_cfe :=make ([]byte ,4);
_adbg :=make ([]byte ,4);for _cbd =0;_cbd < _gaf .Height -1;_cbd ,_babc =_cbd +2,_babc +1{_bdd =_cbd *_gaf .BytesPerLine ;_eec =_babc *_dac .BytesPerLine ;for _dgg ,_dea =0,0;_dgg < _cfd ;_dgg ,_dea =_dgg +4,_dea +1{for _ege =0;_ege < 4;_ege ++{_cce =_bdd +_dgg +_ege ;
if _cce <=len (_gaf .Data )-1&&_cce < _bdd +_gaf .BytesPerLine {_cfe [_ege ]=_gaf .Data [_cce ];}else {_cfe [_ege ]=0x00;};_cce =_bdd +_gaf .BytesPerLine +_dgg +_ege ;if _cce <=len (_gaf .Data )-1&&_cce < _bdd +(2*_gaf .BytesPerLine ){_adbg [_ege ]=_gaf .Data [_cce ];
}else {_adbg [_ege ]=0x00;};};_eag =_f .BigEndian .Uint32 (_cfe );_edg =_f .BigEndian .Uint32 (_adbg );_edg |=_eag ;_edg |=_edg <<1;_edg &=0xaaaaaaaa;_eag =_edg |(_edg <<7);_dfb =byte (_eag >>24);_cef =byte ((_eag >>8)&0xff);_cce =_eec +_dea ;if _cce +1==len (_dac .Data )-1||_cce +1>=_eec +_dac .BytesPerLine {_dac .Data [_cce ]=_ega [_dfb ];
}else {_aaa =(uint16 (_ega [_dfb ])<<8)|uint16 (_ega [_cef ]);if _eaa =_dac .setTwoBytes (_cce ,_aaa );_eaa !=nil {return _cg .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_cce );
};_dea ++;};};};return nil ;};func (_cbgg *Gray16 )ColorModel ()_g .Model {return _g .Gray16Model };type Histogramer interface{Histogram ()[256]int ;};func _dbcc (_fee ,_gbcd *Monochrome ,_acc []byte ,_aga int )(_egfg error ){var (_bfga ,_fca ,_addf ,_gbcc ,_aaaa ,_efa ,_ebfg ,_cga int ;
_fdg ,_eac uint32 ;_acd ,_geg byte ;_fcg uint16 ;);_aaf :=make ([]byte ,4);_gaa :=make ([]byte ,4);for _addf =0;_addf < _fee .Height -1;_addf ,_gbcc =_addf +2,_gbcc +1{_bfga =_addf *_fee .BytesPerLine ;_fca =_gbcc *_gbcd .BytesPerLine ;for _aaaa ,_efa =0,0;
_aaaa < _aga ;_aaaa ,_efa =_aaaa +4,_efa +1{for _ebfg =0;_ebfg < 4;_ebfg ++{_cga =_bfga +_aaaa +_ebfg ;if _cga <=len (_fee .Data )-1&&_cga < _bfga +_fee .BytesPerLine {_aaf [_ebfg ]=_fee .Data [_cga ];}else {_aaf [_ebfg ]=0x00;};_cga =_bfga +_fee .BytesPerLine +_aaaa +_ebfg ;
if _cga <=len (_fee .Data )-1&&_cga < _bfga +(2*_fee .BytesPerLine ){_gaa [_ebfg ]=_fee .Data [_cga ];}else {_gaa [_ebfg ]=0x00;};};_fdg =_f .BigEndian .Uint32 (_aaf );_eac =_f .BigEndian .Uint32 (_gaa );_eac &=_fdg ;_eac &=_eac <<1;_eac &=0xaaaaaaaa;_fdg =_eac |(_eac <<7);
_acd =byte (_fdg >>24);_geg =byte ((_fdg >>8)&0xff);_cga =_fca +_efa ;if _cga +1==len (_gbcd .Data )-1||_cga +1>=_fca +_gbcd .BytesPerLine {_gbcd .Data [_cga ]=_acc [_acd ];if _egfg =_gbcd .setByte (_cga ,_acc [_acd ]);_egfg !=nil {return _cg .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_cga );
};}else {_fcg =(uint16 (_acc [_acd ])<<8)|uint16 (_acc [_geg ]);if _egfg =_gbcd .setTwoBytes (_cga ,_fcg );_egfg !=nil {return _cg .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_cga );
};_efa ++;};};};return nil ;};func _bgcd (_dggg *_b .Gray ,_ddfcd uint8 )*_b .Gray {_gfeg :=_dggg .Bounds ();_ccgb :=_b .NewGray (_gfeg );for _gabfc :=0;_gabfc < _gfeg .Dx ();_gabfc ++{for _cebbc :=0;_cebbc < _gfeg .Dy ();_cebbc ++{_bbfe :=_dggg .GrayAt (_gabfc ,_cebbc );
_ccgb .SetGray (_gabfc ,_cebbc ,_g .Gray {Y :_ffbf (_bbfe .Y ,_ddfcd )});};};return _ccgb ;};func IsPowerOf2 (n uint )bool {return n > 0&&(n &(n -1))==0};type CMYK interface{CMYKAt (_ggc ,_cebf int )_g .CMYK ;SetCMYK (_cgf ,_fdc int ,_fbc _g .CMYK );};
func (_afcf *RGBA32 )At (x ,y int )_g .Color {_eecd ,_ :=_afcf .ColorAt (x ,y );return _eecd };func (_dbfaa *NRGBA64 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtNRGBA64 (x ,y ,_dbfaa .Width ,_dbfaa .Data ,_dbfaa .Alpha ,_dbfaa .Decode );};func (_cadcd *NRGBA32 )Base ()*ImageBase {return &_cadcd .ImageBase };
func _fddb (_aafg _g .NRGBA )_g .RGBA {_aeef ,_cfffc ,_gde ,_fec :=_aafg .RGBA ();return _g .RGBA {R :uint8 (_aeef >>8),G :uint8 (_cfffc >>8),B :uint8 (_gde >>8),A :uint8 (_fec >>8)};};func (_ebaa *Monochrome )IsUnpadded ()bool {return (_ebaa .Width *_ebaa .Height )==len (_ebaa .Data )};
func ColorAtGray2BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_g .Gray ,error ){_bfee :=y *bytesPerLine +x >>2;if _bfee >=len (data ){return _g .Gray {},_cg .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_afcc :=data [_bfee ]>>uint (6-(x &3)*2)&3;if len (decode )==2{_afcc =uint8 (uint32 (LinearInterpolate (float64 (_afcc ),0,3.0,decode [0],decode [1]))&3);};return _g .Gray {Y :_afcc *85},nil ;};func _fcde (_gcg _g .Gray )_g .Gray {_gcg .Y >>=4;_gcg .Y |=_gcg .Y <<4;
return _gcg };func _ebecf (_addae _b .Image ,_deaf int )(_b .Rectangle ,bool ,[]byte ){_fbaa :=_addae .Bounds ();var (_dbde bool ;_abbb []byte ;);switch _eedg :=_addae .(type ){case SMasker :_dbde =_eedg .HasAlpha ();case NRGBA ,RGBA ,*_b .RGBA64 ,nrgba64 ,*_b .NYCbCrA :_abbb =make ([]byte ,_fbaa .Max .X *_fbaa .Max .Y *_deaf );
case *_b .Paletted :var _bdda bool ;for _ ,_ccaba :=range _eedg .Palette {_bggc ,_eefg ,_cacb ,_eage :=_ccaba .RGBA ();if _bggc ==0&&_eefg ==0&&_cacb ==0&&_eage !=0{_bdda =true ;break ;};};if _bdda {_abbb =make ([]byte ,_fbaa .Max .X *_fbaa .Max .Y *_deaf );
};};return _fbaa ,_dbde ,_abbb ;};func _gfedf (_cffbd _b .Image ,_bgce uint8 )*_b .Gray {_bbdef :=_cffbd .Bounds ();_bbef :=_b .NewGray (_bbdef );var (_gbab _g .Color ;_cfdc _g .Gray ;);for _afef :=0;_afef < _bbdef .Max .X ;_afef ++{for _cdaa :=0;_cdaa < _bbdef .Max .Y ;
_cdaa ++{_gbab =_cffbd .At (_afef ,_cdaa );_bbef .Set (_afef ,_cdaa ,_gbab );_cfdc =_bbef .GrayAt (_afef ,_cdaa );_bbef .SetGray (_afef ,_cdaa ,_g .Gray {Y :_ffbf (_cfdc .Y ,_bgce )});};};return _bbef ;};func (_bbde *NRGBA16 )Base ()*ImageBase {return &_bbde .ImageBase };
func (_cdegg *ImageBase )MakeAlpha (){_cdegg .newAlpha ()};func (_bcc *CMYK32 )SetCMYK (x ,y int ,c _g .CMYK ){_geadb :=4*(y *_bcc .Width +x );if _geadb +3>=len (_bcc .Data ){return ;};_bcc .Data [_geadb ]=c .C ;_bcc .Data [_geadb +1]=c .M ;_bcc .Data [_geadb +2]=c .Y ;
_bcc .Data [_geadb +3]=c .K ;};func (_cdda *Gray16 )At (x ,y int )_g .Color {_deee ,_ :=_cdda .ColorAt (x ,y );return _deee };func (_cedb *NRGBA64 )ColorModel ()_g .Model {return _g .NRGBA64Model };func (_cabg *NRGBA64 )Validate ()error {if len (_cabg .Data )!=3*2*_cabg .Width *_cabg .Height {return _c .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};var _ Gray =&Gray16 {};type Gray16 struct{ImageBase };func _efc (_dbdg ,_gga *Monochrome ,_abe []byte ,_debb int )(_add error ){var (_cbfg ,_cgec ,_cfec ,_feg ,_aee ,_dgd ,_cbg ,_ffe int ;_facg ,_geaf ,_fgd ,_edd uint32 ;_gca ,_gfe byte ;
_dbc uint16 ;);_agb :=make ([]byte ,4);_fda :=make ([]byte ,4);for _cfec =0;_cfec < _dbdg .Height -1;_cfec ,_feg =_cfec +2,_feg +1{_cbfg =_cfec *_dbdg .BytesPerLine ;_cgec =_feg *_gga .BytesPerLine ;for _aee ,_dgd =0,0;_aee < _debb ;_aee ,_dgd =_aee +4,_dgd +1{for _cbg =0;
_cbg < 4;_cbg ++{_ffe =_cbfg +_aee +_cbg ;if _ffe <=len (_dbdg .Data )-1&&_ffe < _cbfg +_dbdg .BytesPerLine {_agb [_cbg ]=_dbdg .Data [_ffe ];}else {_agb [_cbg ]=0x00;};_ffe =_cbfg +_dbdg .BytesPerLine +_aee +_cbg ;if _ffe <=len (_dbdg .Data )-1&&_ffe < _cbfg +(2*_dbdg .BytesPerLine ){_fda [_cbg ]=_dbdg .Data [_ffe ];
}else {_fda [_cbg ]=0x00;};};_facg =_f .BigEndian .Uint32 (_agb );_geaf =_f .BigEndian .Uint32 (_fda );_fgd =_facg &_geaf ;_fgd |=_fgd <<1;_edd =_facg |_geaf ;_edd &=_edd <<1;_geaf =_fgd &_edd ;_geaf &=0xaaaaaaaa;_facg =_geaf |(_geaf <<7);_gca =byte (_facg >>24);
_gfe =byte ((_facg >>8)&0xff);_ffe =_cgec +_dgd ;if _ffe +1==len (_gga .Data )-1||_ffe +1>=_cgec +_gga .BytesPerLine {if _add =_gga .setByte (_ffe ,_abe [_gca ]);_add !=nil {return _cg .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_ffe );};}else {_dbc =(uint16 (_abe [_gca ])<<8)|uint16 (_abe [_gfe ]);
if _add =_gga .setTwoBytes (_ffe ,_dbc );_add !=nil {return _cg .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_ffe );
};_dgd ++;};};};return nil ;};func (_cfdd *Monochrome )At (x ,y int )_g .Color {_fbfb ,_ :=_cfdd .ColorAt (x ,y );return _fbfb };const (PixSrc RasterOperator =0xc;PixDst RasterOperator =0xa;PixNotSrc RasterOperator =0x3;PixNotDst RasterOperator =0x5;PixClr RasterOperator =0x0;
PixSet RasterOperator =0xf;PixSrcOrDst RasterOperator =0xe;PixSrcAndDst RasterOperator =0x8;PixSrcXorDst RasterOperator =0x6;PixNotSrcOrDst RasterOperator =0xb;PixNotSrcAndDst RasterOperator =0x2;PixSrcOrNotDst RasterOperator =0xd;PixSrcAndNotDst RasterOperator =0x4;
PixNotPixSrcOrDst RasterOperator =0x1;PixNotPixSrcAndDst RasterOperator =0x7;PixNotPixSrcXorDst RasterOperator =0x9;PixPaint =PixSrcOrDst ;PixSubtract =PixNotSrcAndDst ;PixMask =PixSrcAndDst ;);func (_bfeg *Monochrome )setGray (_cdbd int ,_egc _g .Gray ,_bbg int ){if _egc .Y ==0{_bfeg .clearBit (_bbg ,_cdbd );
}else {_bfeg .setGrayBit (_bbg ,_cdbd );};};func _eede (_facge _g .NRGBA64 )_g .NRGBA {return _g .NRGBA {R :uint8 (_facge .R >>8),G :uint8 (_facge .G >>8),B :uint8 (_facge .B >>8),A :uint8 (_facge .A >>8)};};func GetConverter (bitsPerComponent ,colorComponents int )(ColorConverter ,error ){switch colorComponents {case 1:switch bitsPerComponent {case 1:return MonochromeConverter ,nil ;
case 2:return Gray2Converter ,nil ;case 4:return Gray4Converter ,nil ;case 8:return GrayConverter ,nil ;case 16:return Gray16Converter ,nil ;};case 3:switch bitsPerComponent {case 4:return NRGBA16Converter ,nil ;case 8:return NRGBAConverter ,nil ;case 16:return NRGBA64Converter ,nil ;
};case 4:return CMYKConverter ,nil ;};return nil ,_cg .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0043o\u006e\u0076\u0065\u0072\u0074\u0065\u0072\u0020\u0070\u0061\u0072\u0061\u006d\u0065t\u0065\u0072\u0073\u002e\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003a\u0020\u0025\u0064\u002c\u0020\u0043\u006f\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006et\u0073\u003a \u0025\u0064",bitsPerComponent ,colorComponents );
};func (_dafec *RGBA32 )Validate ()error {if len (_dafec .Data )!=3*_dafec .Width *_dafec .Height {return _c .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func _afcga (_bdec *Monochrome ,_cabe ,_bgbb int ,_ffcf ,_gcdgd int ,_gdf RasterOperator ){var (_fecg bool ;_bcdcc bool ;_cbaa int ;_agga int ;_baaae int ;_agcd int ;_dcecg bool ;_aad byte ;);_eeda :=8-(_cabe &7);_bdcc :=_cdeb [_eeda ];
_gadfg :=_bdec .BytesPerLine *_bgbb +(_cabe >>3);if _ffcf < _eeda {_fecg =true ;_bdcc &=_baae [8-_eeda +_ffcf ];};if !_fecg {_cbaa =(_ffcf -_eeda )>>3;if _cbaa !=0{_bcdcc =true ;_agga =_gadfg +1;};};_baaae =(_cabe +_ffcf )&7;if !(_fecg ||_baaae ==0){_dcecg =true ;
_aad =_baae [_baaae ];_agcd =_gadfg +1+_cbaa ;};var _fcbe ,_dffe int ;switch _gdf {case PixClr :for _fcbe =0;_fcbe < _gcdgd ;_fcbe ++{_bdec .Data [_gadfg ]=_geaa (_bdec .Data [_gadfg ],0x0,_bdcc );_gadfg +=_bdec .BytesPerLine ;};if _bcdcc {for _fcbe =0;
_fcbe < _gcdgd ;_fcbe ++{for _dffe =0;_dffe < _cbaa ;_dffe ++{_bdec .Data [_agga +_dffe ]=0x0;};_agga +=_bdec .BytesPerLine ;};};if _dcecg {for _fcbe =0;_fcbe < _gcdgd ;_fcbe ++{_bdec .Data [_agcd ]=_geaa (_bdec .Data [_agcd ],0x0,_aad );_agcd +=_bdec .BytesPerLine ;
};};case PixSet :for _fcbe =0;_fcbe < _gcdgd ;_fcbe ++{_bdec .Data [_gadfg ]=_geaa (_bdec .Data [_gadfg ],0xff,_bdcc );_gadfg +=_bdec .BytesPerLine ;};if _bcdcc {for _fcbe =0;_fcbe < _gcdgd ;_fcbe ++{for _dffe =0;_dffe < _cbaa ;_dffe ++{_bdec .Data [_agga +_dffe ]=0xff;
};_agga +=_bdec .BytesPerLine ;};};if _dcecg {for _fcbe =0;_fcbe < _gcdgd ;_fcbe ++{_bdec .Data [_agcd ]=_geaa (_bdec .Data [_agcd ],0xff,_aad );_agcd +=_bdec .BytesPerLine ;};};case PixNotDst :for _fcbe =0;_fcbe < _gcdgd ;_fcbe ++{_bdec .Data [_gadfg ]=_geaa (_bdec .Data [_gadfg ],^_bdec .Data [_gadfg ],_bdcc );
_gadfg +=_bdec .BytesPerLine ;};if _bcdcc {for _fcbe =0;_fcbe < _gcdgd ;_fcbe ++{for _dffe =0;_dffe < _cbaa ;_dffe ++{_bdec .Data [_agga +_dffe ]=^(_bdec .Data [_agga +_dffe ]);};_agga +=_bdec .BytesPerLine ;};};if _dcecg {for _fcbe =0;_fcbe < _gcdgd ;
_fcbe ++{_bdec .Data [_agcd ]=_geaa (_bdec .Data [_agcd ],^_bdec .Data [_agcd ],_aad );_agcd +=_bdec .BytesPerLine ;};};};};func (_bgfb *NRGBA32 )Bounds ()_b .Rectangle {return _b .Rectangle {Max :_b .Point {X :_bgfb .Width ,Y :_bgfb .Height }};};func _bbga (_bdff _g .Color )_g .Color {_daaf :=_g .NRGBAModel .Convert (_bdff ).(_g .NRGBA );
return _cegc (_daaf );};func (_beaa *NRGBA32 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtNRGBA32 (x ,y ,_beaa .Width ,_beaa .Data ,_beaa .Alpha ,_beaa .Decode );};func _ebg (_age *Monochrome ,_agd int ,_ebae []byte )(_gbce *Monochrome ,_ddg error ){const _fg ="\u0072\u0065d\u0075\u0063\u0065R\u0061\u006e\u006b\u0042\u0069\u006e\u0061\u0072\u0079";
if _age ==nil {return nil ,_c .New ("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d");};if _agd < 1||_agd > 4{return nil ,_c .New ("\u006c\u0065\u0076\u0065\u006c\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020\u0073e\u0074\u0020\u007b\u0031\u002c\u0032\u002c\u0033\u002c\u0034\u007d");
};if _age .Height <=1{return nil ,_c .New ("\u0073\u006f\u0075rc\u0065\u0020\u0068\u0065\u0069\u0067\u0068\u0074\u0020m\u0075s\u0074 \u0062e\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020\u0027\u0032\u0027");};_gbce =_gead (_age .Width /2,_age .Height /2);
if _ebae ==nil {_ebae =_cab ();};_cgge :=_bdgg (_age .BytesPerLine ,2*_gbce .BytesPerLine );switch _agd {case 1:_ddg =_cba (_age ,_gbce ,_ebae ,_cgge );case 2:_ddg =_adbf (_age ,_gbce ,_ebae ,_cgge );case 3:_ddg =_efc (_age ,_gbce ,_ebae ,_cgge );case 4:_ddg =_dbcc (_age ,_gbce ,_ebae ,_cgge );
};if _ddg !=nil {return nil ,_ddg ;};return _gbce ,nil ;};func _cegc (_afabf _g .NRGBA )_g .NRGBA {_afabf .R =_afabf .R >>4|(_afabf .R >>4)<<4;_afabf .G =_afabf .G >>4|(_afabf .G >>4)<<4;_afabf .B =_afabf .B >>4|(_afabf .B >>4)<<4;return _afabf ;};func (_eeff *CMYK32 )Bounds ()_b .Rectangle {return _b .Rectangle {Max :_b .Point {X :_eeff .Width ,Y :_eeff .Height }};
};func _fed ()(_ebff [256]uint16 ){for _df :=0;_df < 256;_df ++{if _df &0x01!=0{_ebff [_df ]|=0x3;};if _df &0x02!=0{_ebff [_df ]|=0xc;};if _df &0x04!=0{_ebff [_df ]|=0x30;};if _df &0x08!=0{_ebff [_df ]|=0xc0;};if _df &0x10!=0{_ebff [_df ]|=0x300;};if _df &0x20!=0{_ebff [_df ]|=0xc00;
};if _df &0x40!=0{_ebff [_df ]|=0x3000;};if _df &0x80!=0{_ebff [_df ]|=0xc000;};};return _ebff ;};func _gabba (_cfdb _b .Image ,_eeb Image ,_aeefa _b .Rectangle ){if _gede ,_egfaf :=_cfdb .(SMasker );_egfaf &&_gede .HasAlpha (){_eeb .(SMasker ).MakeAlpha ();
};_dbb (_cfdb ,_eeb ,_aeefa );};func (_dbfa *Gray16 )Set (x ,y int ,c _g .Color ){_edad :=(y *_dbfa .BytesPerLine /2+x )*2;if _edad +1>=len (_dbfa .Data ){return ;};_dgad :=_g .Gray16Model .Convert (c ).(_g .Gray16 );_dbfa .Data [_edad ],_dbfa .Data [_edad +1]=uint8 (_dgad .Y >>8),uint8 (_dgad .Y &0xff);
};func (_ebc *Monochrome )setBit (_gdda ,_cafdf int ){_ebc .Data [_gdda +(_cafdf >>3)]|=0x80>>uint (_cafdf &7);};func (_bccc *NRGBA64 )Set (x ,y int ,c _g .Color ){_ced :=(y *_bccc .Width +x )*2;_fbba :=_ced *3;if _fbba +5>=len (_bccc .Data ){return ;};
_gdad :=_g .NRGBA64Model .Convert (c ).(_g .NRGBA64 );_bccc .setNRGBA64 (_fbba ,_gdad ,_ced );};func _ddeb (_bcgc Gray ,_eegg RGBA ,_fgbb _b .Rectangle ){for _gaad :=0;_gaad < _fgbb .Max .X ;_gaad ++{for _fafc :=0;_fafc < _fgbb .Max .Y ;_fafc ++{_egef :=_bcgc .GrayAt (_gaad ,_fafc );
_eegg .SetRGBA (_gaad ,_fafc ,_acf (_egef ));};};};func ColorAtNRGBA64 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_g .NRGBA64 ,error ){_baf :=(y *width +x )*2;_cgabb :=_baf *3;if _cgabb +5>=len (data ){return _g .NRGBA64 {},_cg .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};const _eafcf =0xffff;_fffcg :=uint16 (_eafcf );if alpha !=nil &&len (alpha )> _baf +1{_fffcg =uint16 (alpha [_baf ])<<8|uint16 (alpha [_baf +1]);};_cgeaf :=uint16 (data [_cgabb ])<<8|uint16 (data [_cgabb +1]);_fdfc :=uint16 (data [_cgabb +2])<<8|uint16 (data [_cgabb +3]);
_afagb :=uint16 (data [_cgabb +4])<<8|uint16 (data [_cgabb +5]);if len (decode )==6{_cgeaf =uint16 (uint64 (LinearInterpolate (float64 (_cgeaf ),0,65535,decode [0],decode [1]))&_eafcf );_fdfc =uint16 (uint64 (LinearInterpolate (float64 (_fdfc ),0,65535,decode [2],decode [3]))&_eafcf );
_afagb =uint16 (uint64 (LinearInterpolate (float64 (_afagb ),0,65535,decode [4],decode [5]))&_eafcf );};return _g .NRGBA64 {R :_cgeaf ,G :_fdfc ,B :_afagb ,A :_fffcg },nil ;};func (_dfcc *Monochrome )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtGray1BPC (x ,y ,_dfcc .BytesPerLine ,_dfcc .Data ,_dfcc .Decode );
};func _egf ()(_eeg [256]uint32 ){for _gfg :=0;_gfg < 256;_gfg ++{if _gfg &0x01!=0{_eeg [_gfg ]|=0xf;};if _gfg &0x02!=0{_eeg [_gfg ]|=0xf0;};if _gfg &0x04!=0{_eeg [_gfg ]|=0xf00;};if _gfg &0x08!=0{_eeg [_gfg ]|=0xf000;};if _gfg &0x10!=0{_eeg [_gfg ]|=0xf0000;
};if _gfg &0x20!=0{_eeg [_gfg ]|=0xf00000;};if _gfg &0x40!=0{_eeg [_gfg ]|=0xf000000;};if _gfg &0x80!=0{_eeg [_gfg ]|=0xf0000000;};};return _eeg ;};func _afa (_cfee _g .Gray )_g .CMYK {return _g .CMYK {K :0xff-_cfee .Y }};func (_ceae *NRGBA16 )Copy ()Image {return &NRGBA16 {ImageBase :_ceae .copy ()}};
func _gfed (_fbda _g .Gray )_g .NRGBA {return _g .NRGBA {R :_fbda .Y ,G :_fbda .Y ,B :_fbda .Y ,A :0xff}};func (_cbb *Gray2 )Bounds ()_b .Rectangle {return _b .Rectangle {Max :_b .Point {X :_cbb .Width ,Y :_cbb .Height }};};func (_eacb *Gray16 )SetGray (x ,y int ,g _g .Gray ){_gcdb :=(y *_eacb .BytesPerLine /2+x )*2;
if _gcdb +1>=len (_eacb .Data ){return ;};_eacb .Data [_gcdb ]=g .Y ;_eacb .Data [_gcdb +1]=g .Y ;};func (_feda *Gray4 )Copy ()Image {return &Gray4 {ImageBase :_feda .copy ()}};func (_egab *Monochrome )Scale (scale float64 )(*Monochrome ,error ){var _ceaad bool ;
_ebag :=scale ;if scale < 1{_ebag =1/scale ;_ceaad =true ;};_dgdd :=NextPowerOf2 (uint (_ebag ));if InDelta (float64 (_dgdd ),_ebag ,0.001){if _ceaad {return _egab .ReduceBinary (_ebag );};return _egab .ExpandBinary (int (_dgdd ));};_gcf :=int (_a .RoundToEven (float64 (_egab .Width )*scale ));
_aafc :=int (_a .RoundToEven (float64 (_egab .Height )*scale ));return _egab .ScaleLow (_gcf ,_aafc );};func (_bdcf *Monochrome )SetGray (x ,y int ,g _g .Gray ){_efgg :=y *_bdcf .BytesPerLine +x >>3;if _efgg > len (_bdcf .Data )-1{return ;};g =_adf (g ,monochromeModel (_bdcf .ModelThreshold ));
_bdcf .setGray (x ,g ,_efgg );};func _aafd (_dadc _b .Image )(Image ,error ){if _aaag ,_bgb :=_dadc .(*Monochrome );_bgb {return _aaag ,nil ;};_gafg :=_dadc .Bounds ();var _adda Gray ;switch _cec :=_dadc .(type ){case Gray :_adda =_cec ;case NRGBA :_adda =&Gray8 {ImageBase :NewImageBase (_gafg .Max .X ,_gafg .Max .Y ,8,1,nil ,nil ,nil )};
_fbgf (_adda ,_cec ,_gafg );case nrgba64 :_adda =&Gray8 {ImageBase :NewImageBase (_gafg .Max .X ,_gafg .Max .Y ,8,1,nil ,nil ,nil )};_dbgdb (_adda ,_cec ,_gafg );default:_bcfe ,_ggf :=GrayConverter .Convert (_dadc );if _ggf !=nil {return nil ,_ggf ;};_adda =_bcfe .(Gray );
};_ecf ,_ddfc :=NewImage (_gafg .Max .X ,_gafg .Max .Y ,1,1,nil ,nil ,nil );if _ddfc !=nil {return nil ,_ddfc ;};_bbe :=_ecf .(*Monochrome );_cdfg :=AutoThresholdTriangle (GrayHistogram (_adda ));for _gbca :=0;_gbca < _gafg .Max .X ;_gbca ++{for _cggc :=0;
_cggc < _gafg .Max .Y ;_cggc ++{_ffec :=_adf (_adda .GrayAt (_gbca ,_cggc ),monochromeModel (_cdfg ));_bbe .SetGray (_gbca ,_cggc ,_ffec );};};return _ecf ,nil ;};func _aef (_adbc *Monochrome ,_gfgg ...int )(_fcc *Monochrome ,_dge error ){if _adbc ==nil {return nil ,_c .New ("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d");
};if len (_gfgg )==0{return nil ,_c .New ("\u0074h\u0065\u0072e\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0061\u0074 \u006c\u0065\u0061\u0073\u0074\u0020o\u006e\u0065\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u006f\u0066 \u0072\u0065\u0064\u0075\u0063\u0074\u0069\u006f\u006e");
};_dce :=_cab ();_fcc =_adbc ;for _ ,_ffg :=range _gfgg {if _ffg <=0{break ;};_fcc ,_dge =_ebg (_fcc ,_ffg ,_dce );if _dge !=nil {return nil ,_dge ;};};return _fcc ,nil ;};func _fegg (_cfgf int ,_bdcg int )error {return _cg .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",_cfgf ,_bdcg );
};func _ffbf (_fedbc ,_bedgg uint8 )uint8 {if _fedbc < _bedgg {return 255;};return 0;};func _adfe (_gbaef _b .Image ,_cfddf Image ,_gbggg _b .Rectangle ){if _caeg ,_eeed :=_gbaef .(SMasker );_eeed &&_caeg .HasAlpha (){_cfddf .(SMasker ).MakeAlpha ();};
switch _fcfca :=_gbaef .(type ){case Gray :_ddeb (_fcfca ,_cfddf .(RGBA ),_gbggg );case NRGBA :_cfed (_fcfca ,_cfddf .(RGBA ),_gbggg );case *_b .NYCbCrA :_cdcg (_fcfca ,_cfddf .(RGBA ),_gbggg );case CMYK :_ffag (_fcfca ,_cfddf .(RGBA ),_gbggg );case RGBA :_ecaa (_fcfca ,_cfddf .(RGBA ),_gbggg );
case nrgba64 :_bedg (_fcfca ,_cfddf .(RGBA ),_gbggg );default:_dbb (_gbaef ,_cfddf ,_gbggg );};};func (_bega *Gray4 )setGray (_aed int ,_egabef int ,_aaef _g .Gray ){_ebcbb :=_egabef *_bega .BytesPerLine ;_gdgg :=_ebcbb +(_aed >>1);if _gdgg >=len (_bega .Data ){return ;
};_fcfc :=_aaef .Y >>4;_bega .Data [_gdgg ]=(_bega .Data [_gdgg ]&(^(0xf0>>uint (4*(_aed &1)))))|(_fcfc <<uint (4-4*(_aed &1)));};func (_gfdd *Monochrome )Copy ()Image {return &Monochrome {ImageBase :_gfdd .ImageBase .copy (),ModelThreshold :_gfdd .ModelThreshold };
};func (_ggaf *RGBA32 )Base ()*ImageBase {return &_ggaf .ImageBase };func (_aaab *Monochrome )copy ()*Monochrome {_bfea :=_gead (_aaab .Width ,_aaab .Height );_bfea .ModelThreshold =_aaab .ModelThreshold ;_bfea .Data =make ([]byte ,len (_aaab .Data ));
copy (_bfea .Data ,_aaab .Data );if len (_aaab .Decode )!=0{_bfea .Decode =make ([]float64 ,len (_aaab .Decode ));copy (_bfea .Decode ,_aaab .Decode );};if len (_aaab .Alpha )!=0{_bfea .Alpha =make ([]byte ,len (_aaab .Alpha ));copy (_bfea .Alpha ,_aaab .Alpha );
};return _bfea ;};type ImageBase struct{Width ,Height int ;BitsPerComponent ,ColorComponents int ;Data ,Alpha []byte ;Decode []float64 ;BytesPerLine int ;};type NRGBA64 struct{ImageBase };type Gray2 struct{ImageBase };var (Gray2Model =_g .ModelFunc (_fba );
Gray4Model =_g .ModelFunc (_gadf );NRGBA16Model =_g .ModelFunc (_bbga ););func ScaleAlphaToMonochrome (data []byte ,width ,height int )([]byte ,error ){_gad :=BytesPerLine (width ,8,1);if len (data )< _gad *height {return nil ,nil ;};_bg :=&Gray8 {NewImageBase (width ,height ,8,1,data ,nil ,nil )};
_ac ,_ab :=MonochromeConverter .Convert (_bg );if _ab !=nil {return nil ,_ab ;};return _ac .Base ().Data ,nil ;};func (_dedce *NRGBA32 )Copy ()Image {return &NRGBA32 {ImageBase :_dedce .copy ()}};func (_cgfbd *Gray2 )SetGray (x ,y int ,gray _g .Gray ){_cdeg :=_eecb (gray );
_fega :=y *_cgfbd .BytesPerLine ;_badg :=_fega +(x >>2);if _badg >=len (_cgfbd .Data ){return ;};_bfbb :=_cdeg .Y >>6;_cgfbd .Data [_badg ]=(_cgfbd .Data [_badg ]&(^(0xc0>>uint (2*((x )&3)))))|(_bfbb <<uint (6-2*(x &3)));};func _bdgg (_bfgf int ,_egec int )int {if _bfgf < _egec {return _bfgf ;
};return _egec ;};func (_cddg *ImageBase )setEightPartlyBytes (_bfdg ,_fefa int ,_agac uint64 )(_eddd error ){var (_eacd byte ;_gbg int ;);for _eaaa :=1;_eaaa <=_fefa ;_eaaa ++{_gbg =64-_eaaa *8;_eacd =byte (_agac >>uint (_gbg )&0xff);if _eddd =_cddg .setByte (_bfdg +_eaaa -1,_eacd );
_eddd !=nil {return _eddd ;};};_dcbf :=_cddg .BytesPerLine *8-_cddg .Width ;if _dcbf ==0{return nil ;};_gbg -=8;_eacd =byte (_agac >>uint (_gbg )&0xff)<<uint (_dcbf );if _eddd =_cddg .setByte (_bfdg +_fefa ,_eacd );_eddd !=nil {return _eddd ;};return nil ;
};func _gdef (_ddbb _b .Image ,_cdff Image ,_dcge _b .Rectangle ){if _dacg ,_effe :=_ddbb .(SMasker );_effe &&_dacg .HasAlpha (){_cdff .(SMasker ).MakeAlpha ();};switch _aaad :=_ddbb .(type ){case Gray :_cbdfd (_aaad ,_cdff .(NRGBA ),_dcge );case NRGBA :_bcdff (_aaad ,_cdff .(NRGBA ),_dcge );
case *_b .NYCbCrA :_abg (_aaad ,_cdff .(NRGBA ),_dcge );case CMYK :_afgc (_aaad ,_cdff .(NRGBA ),_dcge );case RGBA :_aeeg (_aaad ,_cdff .(NRGBA ),_dcge );case nrgba64 :_fede (_aaad ,_cdff .(NRGBA ),_dcge );default:_dbb (_ddbb ,_cdff ,_dcge );};};func (_edge *Monochrome )Bounds ()_b .Rectangle {return _b .Rectangle {Max :_b .Point {X :_edge .Width ,Y :_edge .Height }};
};type monochromeModel uint8 ;func (_gcc *Monochrome )Validate ()error {if len (_gcc .Data )!=_gcc .Height *_gcc .BytesPerLine {return ErrInvalidImage ;};return nil ;};type RGBA interface{RGBAAt (_aafda ,_fcab int )_g .RGBA ;SetRGBA (_ggda ,_bece int ,_efaba _g .RGBA );
};func _fbgf (_cgea Gray ,_gdeb NRGBA ,_daeb _b .Rectangle ){for _eeee :=0;_eeee < _daeb .Max .X ;_eeee ++{for _cgfb :=0;_cgfb < _daeb .Max .Y ;_cgfb ++{_acb :=_aec (_gdeb .NRGBAAt (_eeee ,_cgfb ));_cgea .SetGray (_eeee ,_cgfb ,_acb );};};};var _ _b .Image =&Gray8 {};
func (_afed *NRGBA64 )setNRGBA64 (_cggbg int ,_fadc _g .NRGBA64 ,_agda int ){_afed .Data [_cggbg ]=uint8 (_fadc .R >>8);_afed .Data [_cggbg +1]=uint8 (_fadc .R &0xff);_afed .Data [_cggbg +2]=uint8 (_fadc .G >>8);_afed .Data [_cggbg +3]=uint8 (_fadc .G &0xff);
_afed .Data [_cggbg +4]=uint8 (_fadc .B >>8);_afed .Data [_cggbg +5]=uint8 (_fadc .B &0xff);if _agda +1< len (_afed .Alpha ){_afed .Alpha [_agda ]=uint8 (_fadc .A >>8);_afed .Alpha [_agda +1]=uint8 (_fadc .A &0xff);};};var _ Gray =&Gray2 {};func (_abad *NRGBA64 )Bounds ()_b .Rectangle {return _b .Rectangle {Max :_b .Point {X :_abad .Width ,Y :_abad .Height }};
};var _ NRGBA =&NRGBA32 {};var (_baae =[]byte {0x00,0x80,0xC0,0xE0,0xF0,0xF8,0xFC,0xFE,0xFF};_cdeb =[]byte {0x00,0x01,0x03,0x07,0x0F,0x1F,0x3F,0x7F,0xFF};);var _ Image =&Gray4 {};var _ Image =&Gray8 {};func _dgf (_dcb _b .Image )(Image ,error ){if _fcdb ,_efca :=_dcb .(*Gray4 );
_efca {return _fcdb .Copy (),nil ;};_bec :=_dcb .Bounds ();_gcde ,_fegd :=NewImage (_bec .Max .X ,_bec .Max .Y ,4,1,nil ,nil ,nil );if _fegd !=nil {return nil ,_fegd ;};_ebdg (_dcb ,_gcde ,_bec );return _gcde ,nil ;};func (_aeca *Gray2 )ColorModel ()_g .Model {return Gray2Model };
func _ggabb (_cdbde CMYK ,_bdbc Gray ,_ccgc _b .Rectangle ){for _eafc :=0;_eafc < _ccgc .Max .X ;_eafc ++{for _bffd :=0;_bffd < _ccgc .Max .Y ;_bffd ++{_ggee :=_gdg (_cdbde .CMYKAt (_eafc ,_bffd ));_bdbc .SetGray (_eafc ,_bffd ,_ggee );};};};func _adbf (_cfc ,_gab *Monochrome ,_dbd []byte ,_edbd int )(_eee error ){var (_cge ,_gfda ,_fbd ,_ead ,_cff ,_fdb ,_baa ,_fcf int ;
_ddgd ,_cafc ,_efd ,_ffad uint32 ;_ddf ,_afcg byte ;_eadg uint16 ;);_daf :=make ([]byte ,4);_aab :=make ([]byte ,4);for _fbd =0;_fbd < _cfc .Height -1;_fbd ,_ead =_fbd +2,_ead +1{_cge =_fbd *_cfc .BytesPerLine ;_gfda =_ead *_gab .BytesPerLine ;for _cff ,_fdb =0,0;
_cff < _edbd ;_cff ,_fdb =_cff +4,_fdb +1{for _baa =0;_baa < 4;_baa ++{_fcf =_cge +_cff +_baa ;if _fcf <=len (_cfc .Data )-1&&_fcf < _cge +_cfc .BytesPerLine {_daf [_baa ]=_cfc .Data [_fcf ];}else {_daf [_baa ]=0x00;};_fcf =_cge +_cfc .BytesPerLine +_cff +_baa ;
if _fcf <=len (_cfc .Data )-1&&_fcf < _cge +(2*_cfc .BytesPerLine ){_aab [_baa ]=_cfc .Data [_fcf ];}else {_aab [_baa ]=0x00;};};_ddgd =_f .BigEndian .Uint32 (_daf );_cafc =_f .BigEndian .Uint32 (_aab );_efd =_ddgd &_cafc ;_efd |=_efd <<1;_ffad =_ddgd |_cafc ;
_ffad &=_ffad <<1;_cafc =_efd |_ffad ;_cafc &=0xaaaaaaaa;_ddgd =_cafc |(_cafc <<7);_ddf =byte (_ddgd >>24);_afcg =byte ((_ddgd >>8)&0xff);_fcf =_gfda +_fdb ;if _fcf +1==len (_gab .Data )-1||_fcf +1>=_gfda +_gab .BytesPerLine {if _eee =_gab .setByte (_fcf ,_dbd [_ddf ]);
_eee !=nil {return _cg .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_fcf );};}else {_eadg =(uint16 (_dbd [_ddf ])<<8)|uint16 (_dbd [_afcg ]);if _eee =_gab .setTwoBytes (_fcf ,_eadg );_eee !=nil {return _cg .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_fcf );
};_fdb ++;};};};return nil ;};var _ Image =&NRGBA64 {};func (_bgf *CMYK32 )Base ()*ImageBase {return &_bgf .ImageBase };func _aeeg (_gedfb RGBA ,_fbae NRGBA ,_aggc _b .Rectangle ){for _edcb :=0;_edcb < _aggc .Max .X ;_edcb ++{for _eaaae :=0;_eaaae < _aggc .Max .Y ;
_eaaae ++{_cecb :=_gedfb .RGBAAt (_edcb ,_eaaae );_fbae .SetNRGBA (_edcb ,_eaaae ,_cgfe (_cecb ));};};};func (_eef *CMYK32 )Copy ()Image {return &CMYK32 {ImageBase :_eef .copy ()}};func (_baad *NRGBA32 )setRGBA (_debeca int ,_ceecd _g .NRGBA ){_gbbf :=3*_debeca ;
_baad .Data [_gbbf ]=_ceecd .R ;_baad .Data [_gbbf +1]=_ceecd .G ;_baad .Data [_gbbf +2]=_ceecd .B ;if _debeca < len (_baad .Alpha ){_baad .Alpha [_debeca ]=_ceecd .A ;};};func (_ccee *RGBA32 )ColorModel ()_g .Model {return _g .NRGBAModel };func _gdcb (_bcca _g .NRGBA64 )_g .RGBA {_ebgg ,_dead ,_dacb ,_ccb :=_bcca .RGBA ();
return _g .RGBA {R :uint8 (_ebgg >>8),G :uint8 (_dead >>8),B :uint8 (_dacb >>8),A :uint8 (_ccb >>8)};};func (_gabdgb *NRGBA16 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtNRGBA16 (x ,y ,_gabdgb .Width ,_gabdgb .BytesPerLine ,_gabdgb .Data ,_gabdgb .Alpha ,_gabdgb .Decode );
};func (_cdfc *Monochrome )Histogram ()(_cgfab [256]int ){for _ ,_dfd :=range _cdfc .Data {_cgfab [0xff]+=int (_gdgf [_cdfc .Data [_dfd ]]);};return _cgfab ;};func (_gdfa *NRGBA32 )ColorModel ()_g .Model {return _g .NRGBAModel };func (_ggab *Monochrome )GrayAt (x ,y int )_g .Gray {_afg ,_ :=ColorAtGray1BPC (x ,y ,_ggab .BytesPerLine ,_ggab .Data ,_ggab .Decode );
return _afg ;};var _ Gray =&Gray4 {};func AutoThresholdTriangle (histogram [256]int )uint8 {var _ecfc ,_cbbf ,_dgbg ,_dcae int ;for _ebfa :=0;_ebfa < len (histogram );_ebfa ++{if histogram [_ebfa ]> 0{_ecfc =_ebfa ;break ;};};if _ecfc > 0{_ecfc --;};for _fbdfe :=255;
_fbdfe > 0;_fbdfe --{if histogram [_fbdfe ]> 0{_dcae =_fbdfe ;break ;};};if _dcae < 255{_dcae ++;};for _afgf :=0;_afgf < 256;_afgf ++{if histogram [_afgf ]> _cbbf {_dgbg =_afgf ;_cbbf =histogram [_afgf ];};};var _dcee bool ;if (_dgbg -_ecfc )< (_dcae -_dgbg ){_dcee =true ;
var _efgfb int ;_cebff :=255;for _efgfb < _cebff {_ggabc :=histogram [_efgfb ];histogram [_efgfb ]=histogram [_cebff ];histogram [_cebff ]=_ggabc ;_efgfb ++;_cebff --;};_ecfc =255-_dcae ;_dgbg =255-_dgbg ;};if _ecfc ==_dgbg {return uint8 (_ecfc );};_adecg :=float64 (histogram [_dgbg ]);
_aagff :=float64 (_ecfc -_dgbg );_ecbg :=_a .Sqrt (_adecg *_adecg +_aagff *_aagff );_adecg /=_ecbg ;_aagff /=_ecbg ;_ecbg =_adecg *float64 (_ecfc )+_aagff *float64 (histogram [_ecfc ]);_gefb :=_ecfc ;var _dbac float64 ;for _egga :=_ecfc +1;_egga <=_dgbg ;
_egga ++{_aac :=_adecg *float64 (_egga )+_aagff *float64 (histogram [_egga ])-_ecbg ;if _aac > _dbac {_gefb =_egga ;_dbac =_aac ;};};_gefb --;if _dcee {var _gfdc int ;_cfffd :=255;for _gfdc < _cfffd {_fcdf :=histogram [_gfdc ];histogram [_gfdc ]=histogram [_cfffd ];
histogram [_cfffd ]=_fcdf ;_gfdc ++;_cfffd --;};return uint8 (255-_gefb );};return uint8 (_gefb );};func (_feb *monochromeThresholdConverter )Convert (img _b .Image )(Image ,error ){if _bffc ,_fbgd :=img .(*Monochrome );_fbgd {return _bffc .Copy (),nil ;
};_adbgf :=img .Bounds ();_gfff ,_beddf :=NewImage (_adbgf .Max .X ,_adbgf .Max .Y ,1,1,nil ,nil ,nil );if _beddf !=nil {return nil ,_beddf ;};_gfff .(*Monochrome ).ModelThreshold =_feb .Threshold ;for _eadc :=0;_eadc < _adbgf .Max .X ;_eadc ++{for _eff :=0;
_eff < _adbgf .Max .Y ;_eff ++{_cafcf :=img .At (_eadc ,_eff );_gfff .Set (_eadc ,_eff ,_cafcf );};};return _gfff ,nil ;};func RasterOperation (dest *Monochrome ,dx ,dy ,dw ,dh int ,op RasterOperator ,src *Monochrome ,sx ,sy int )error {return _gbfg (dest ,dx ,dy ,dw ,dh ,op ,src ,sx ,sy );
};func (_dcec *Gray16 )Copy ()Image {return &Gray16 {ImageBase :_dcec .copy ()}};func _cac (_cd ,_be *Monochrome )(_ea error ){_cgg :=_be .BytesPerLine ;_gc :=_cd .BytesPerLine ;_dbf :=_be .BytesPerLine *4-_cd .BytesPerLine ;var (_dg ,_cca byte ;_bfg uint32 ;
_def ,_ed ,_defd ,_eba ,_ff ,_da ,_caf int ;);for _defd =0;_defd < _be .Height ;_defd ++{_def =_defd *_cgg ;_ed =4*_defd *_gc ;for _eba =0;_eba < _cgg ;_eba ++{_dg =_be .Data [_def +_eba ];_bfg =_ceb [_dg ];_da =_ed +_eba *4;if _dbf !=0&&(_eba +1)*4> _cd .BytesPerLine {for _ff =_dbf ;
_ff > 0;_ff --{_cca =byte ((_bfg >>uint (_ff *8))&0xff);_caf =_da +(_dbf -_ff );if _ea =_cd .setByte (_caf ,_cca );_ea !=nil {return _ea ;};};}else if _ea =_cd .setFourBytes (_da ,_bfg );_ea !=nil {return _ea ;};if _ea =_cd .setFourBytes (_ed +_eba *4,_ceb [_be .Data [_def +_eba ]]);
_ea !=nil {return _ea ;};};for _ff =1;_ff < 4;_ff ++{for _eba =0;_eba < _gc ;_eba ++{if _ea =_cd .setByte (_ed +_ff *_gc +_eba ,_cd .Data [_ed +_eba ]);_ea !=nil {return _ea ;};};};};return nil ;};func _fecf (_fbga *Monochrome ,_efbd ,_baag ,_bgbg ,_accf int ,_abfa RasterOperator ,_eace *Monochrome ,_adebd ,_efdf int )error {var (_fgbd bool ;
_gabb bool ;_cegab int ;_ggdf int ;_ffaf int ;_gfffg bool ;_dabc byte ;_adeg int ;_cgfc int ;_aaec int ;_fgag ,_befgg int ;);_egedc :=8-(_efbd &7);_dcfb :=_cdeb [_egedc ];_fbab :=_fbga .BytesPerLine *_baag +(_efbd >>3);_ecc :=_eace .BytesPerLine *_efdf +(_adebd >>3);
if _bgbg < _egedc {_fgbd =true ;_dcfb &=_baae [8-_egedc +_bgbg ];};if !_fgbd {_cegab =(_bgbg -_egedc )>>3;if _cegab > 0{_gabb =true ;_ggdf =_fbab +1;_ffaf =_ecc +1;};};_adeg =(_efbd +_bgbg )&7;if !(_fgbd ||_adeg ==0){_gfffg =true ;_dabc =_baae [_adeg ];
_cgfc =_fbab +1+_cegab ;_aaec =_ecc +1+_cegab ;};switch _abfa {case PixSrc :for _fgag =0;_fgag < _accf ;_fgag ++{_fbga .Data [_fbab ]=_geaa (_fbga .Data [_fbab ],_eace .Data [_ecc ],_dcfb );_fbab +=_fbga .BytesPerLine ;_ecc +=_eace .BytesPerLine ;};if _gabb {for _fgag =0;
_fgag < _accf ;_fgag ++{for _befgg =0;_befgg < _cegab ;_befgg ++{_fbga .Data [_ggdf +_befgg ]=_eace .Data [_ffaf +_befgg ];};_ggdf +=_fbga .BytesPerLine ;_ffaf +=_eace .BytesPerLine ;};};if _gfffg {for _fgag =0;_fgag < _accf ;_fgag ++{_fbga .Data [_cgfc ]=_geaa (_fbga .Data [_cgfc ],_eace .Data [_aaec ],_dabc );
_cgfc +=_fbga .BytesPerLine ;_aaec +=_eace .BytesPerLine ;};};case PixNotSrc :for _fgag =0;_fgag < _accf ;_fgag ++{_fbga .Data [_fbab ]=_geaa (_fbga .Data [_fbab ],^_eace .Data [_ecc ],_dcfb );_fbab +=_fbga .BytesPerLine ;_ecc +=_eace .BytesPerLine ;};
if _gabb {for _fgag =0;_fgag < _accf ;_fgag ++{for _befgg =0;_befgg < _cegab ;_befgg ++{_fbga .Data [_ggdf +_befgg ]=^_eace .Data [_ffaf +_befgg ];};_ggdf +=_fbga .BytesPerLine ;_ffaf +=_eace .BytesPerLine ;};};if _gfffg {for _fgag =0;_fgag < _accf ;_fgag ++{_fbga .Data [_cgfc ]=_geaa (_fbga .Data [_cgfc ],^_eace .Data [_aaec ],_dabc );
_cgfc +=_fbga .BytesPerLine ;_aaec +=_eace .BytesPerLine ;};};case PixSrcOrDst :for _fgag =0;_fgag < _accf ;_fgag ++{_fbga .Data [_fbab ]=_geaa (_fbga .Data [_fbab ],_eace .Data [_ecc ]|_fbga .Data [_fbab ],_dcfb );_fbab +=_fbga .BytesPerLine ;_ecc +=_eace .BytesPerLine ;
};if _gabb {for _fgag =0;_fgag < _accf ;_fgag ++{for _befgg =0;_befgg < _cegab ;_befgg ++{_fbga .Data [_ggdf +_befgg ]|=_eace .Data [_ffaf +_befgg ];};_ggdf +=_fbga .BytesPerLine ;_ffaf +=_eace .BytesPerLine ;};};if _gfffg {for _fgag =0;_fgag < _accf ;
_fgag ++{_fbga .Data [_cgfc ]=_geaa (_fbga .Data [_cgfc ],_eace .Data [_aaec ]|_fbga .Data [_cgfc ],_dabc );_cgfc +=_fbga .BytesPerLine ;_aaec +=_eace .BytesPerLine ;};};case PixSrcAndDst :for _fgag =0;_fgag < _accf ;_fgag ++{_fbga .Data [_fbab ]=_geaa (_fbga .Data [_fbab ],_eace .Data [_ecc ]&_fbga .Data [_fbab ],_dcfb );
_fbab +=_fbga .BytesPerLine ;_ecc +=_eace .BytesPerLine ;};if _gabb {for _fgag =0;_fgag < _accf ;_fgag ++{for _befgg =0;_befgg < _cegab ;_befgg ++{_fbga .Data [_ggdf +_befgg ]&=_eace .Data [_ffaf +_befgg ];};_ggdf +=_fbga .BytesPerLine ;_ffaf +=_eace .BytesPerLine ;
};};if _gfffg {for _fgag =0;_fgag < _accf ;_fgag ++{_fbga .Data [_cgfc ]=_geaa (_fbga .Data [_cgfc ],_eace .Data [_aaec ]&_fbga .Data [_cgfc ],_dabc );_cgfc +=_fbga .BytesPerLine ;_aaec +=_eace .BytesPerLine ;};};case PixSrcXorDst :for _fgag =0;_fgag < _accf ;
_fgag ++{_fbga .Data [_fbab ]=_geaa (_fbga .Data [_fbab ],_eace .Data [_ecc ]^_fbga .Data [_fbab ],_dcfb );_fbab +=_fbga .BytesPerLine ;_ecc +=_eace .BytesPerLine ;};if _gabb {for _fgag =0;_fgag < _accf ;_fgag ++{for _befgg =0;_befgg < _cegab ;_befgg ++{_fbga .Data [_ggdf +_befgg ]^=_eace .Data [_ffaf +_befgg ];
};_ggdf +=_fbga .BytesPerLine ;_ffaf +=_eace .BytesPerLine ;};};if _gfffg {for _fgag =0;_fgag < _accf ;_fgag ++{_fbga .Data [_cgfc ]=_geaa (_fbga .Data [_cgfc ],_eace .Data [_aaec ]^_fbga .Data [_cgfc ],_dabc );_cgfc +=_fbga .BytesPerLine ;_aaec +=_eace .BytesPerLine ;
};};case PixNotSrcOrDst :for _fgag =0;_fgag < _accf ;_fgag ++{_fbga .Data [_fbab ]=_geaa (_fbga .Data [_fbab ],^(_eace .Data [_ecc ])|_fbga .Data [_fbab ],_dcfb );_fbab +=_fbga .BytesPerLine ;_ecc +=_eace .BytesPerLine ;};if _gabb {for _fgag =0;_fgag < _accf ;
_fgag ++{for _befgg =0;_befgg < _cegab ;_befgg ++{_fbga .Data [_ggdf +_befgg ]|=^(_eace .Data [_ffaf +_befgg ]);};_ggdf +=_fbga .BytesPerLine ;_ffaf +=_eace .BytesPerLine ;};};if _gfffg {for _fgag =0;_fgag < _accf ;_fgag ++{_fbga .Data [_cgfc ]=_geaa (_fbga .Data [_cgfc ],^(_eace .Data [_aaec ])|_fbga .Data [_cgfc ],_dabc );
_cgfc +=_fbga .BytesPerLine ;_aaec +=_eace .BytesPerLine ;};};case PixNotSrcAndDst :for _fgag =0;_fgag < _accf ;_fgag ++{_fbga .Data [_fbab ]=_geaa (_fbga .Data [_fbab ],^(_eace .Data [_ecc ])&_fbga .Data [_fbab ],_dcfb );_fbab +=_fbga .BytesPerLine ;_ecc +=_eace .BytesPerLine ;
};if _gabb {for _fgag =0;_fgag < _accf ;_fgag ++{for _befgg =0;_befgg < _cegab ;_befgg ++{_fbga .Data [_ggdf +_befgg ]&=^_eace .Data [_ffaf +_befgg ];};_ggdf +=_fbga .BytesPerLine ;_ffaf +=_eace .BytesPerLine ;};};if _gfffg {for _fgag =0;_fgag < _accf ;
_fgag ++{_fbga .Data [_cgfc ]=_geaa (_fbga .Data [_cgfc ],^(_eace .Data [_aaec ])&_fbga .Data [_cgfc ],_dabc );_cgfc +=_fbga .BytesPerLine ;_aaec +=_eace .BytesPerLine ;};};case PixSrcOrNotDst :for _fgag =0;_fgag < _accf ;_fgag ++{_fbga .Data [_fbab ]=_geaa (_fbga .Data [_fbab ],_eace .Data [_ecc ]|^(_fbga .Data [_fbab ]),_dcfb );
_fbab +=_fbga .BytesPerLine ;_ecc +=_eace .BytesPerLine ;};if _gabb {for _fgag =0;_fgag < _accf ;_fgag ++{for _befgg =0;_befgg < _cegab ;_befgg ++{_fbga .Data [_ggdf +_befgg ]=_eace .Data [_ffaf +_befgg ]|^(_fbga .Data [_ggdf +_befgg ]);};_ggdf +=_fbga .BytesPerLine ;
_ffaf +=_eace .BytesPerLine ;};};if _gfffg {for _fgag =0;_fgag < _accf ;_fgag ++{_fbga .Data [_cgfc ]=_geaa (_fbga .Data [_cgfc ],_eace .Data [_aaec ]|^(_fbga .Data [_cgfc ]),_dabc );_cgfc +=_fbga .BytesPerLine ;_aaec +=_eace .BytesPerLine ;};};case PixSrcAndNotDst :for _fgag =0;
_fgag < _accf ;_fgag ++{_fbga .Data [_fbab ]=_geaa (_fbga .Data [_fbab ],_eace .Data [_ecc ]&^(_fbga .Data [_fbab ]),_dcfb );_fbab +=_fbga .BytesPerLine ;_ecc +=_eace .BytesPerLine ;};if _gabb {for _fgag =0;_fgag < _accf ;_fgag ++{for _befgg =0;_befgg < _cegab ;
_befgg ++{_fbga .Data [_ggdf +_befgg ]=_eace .Data [_ffaf +_befgg ]&^(_fbga .Data [_ggdf +_befgg ]);};_ggdf +=_fbga .BytesPerLine ;_ffaf +=_eace .BytesPerLine ;};};if _gfffg {for _fgag =0;_fgag < _accf ;_fgag ++{_fbga .Data [_cgfc ]=_geaa (_fbga .Data [_cgfc ],_eace .Data [_aaec ]&^(_fbga .Data [_cgfc ]),_dabc );
_cgfc +=_fbga .BytesPerLine ;_aaec +=_eace .BytesPerLine ;};};case PixNotPixSrcOrDst :for _fgag =0;_fgag < _accf ;_fgag ++{_fbga .Data [_fbab ]=_geaa (_fbga .Data [_fbab ],^(_eace .Data [_ecc ]|_fbga .Data [_fbab ]),_dcfb );_fbab +=_fbga .BytesPerLine ;
_ecc +=_eace .BytesPerLine ;};if _gabb {for _fgag =0;_fgag < _accf ;_fgag ++{for _befgg =0;_befgg < _cegab ;_befgg ++{_fbga .Data [_ggdf +_befgg ]=^(_eace .Data [_ffaf +_befgg ]|_fbga .Data [_ggdf +_befgg ]);};_ggdf +=_fbga .BytesPerLine ;_ffaf +=_eace .BytesPerLine ;
};};if _gfffg {for _fgag =0;_fgag < _accf ;_fgag ++{_fbga .Data [_cgfc ]=_geaa (_fbga .Data [_cgfc ],^(_eace .Data [_aaec ]|_fbga .Data [_cgfc ]),_dabc );_cgfc +=_fbga .BytesPerLine ;_aaec +=_eace .BytesPerLine ;};};case PixNotPixSrcAndDst :for _fgag =0;
_fgag < _accf ;_fgag ++{_fbga .Data [_fbab ]=_geaa (_fbga .Data [_fbab ],^(_eace .Data [_ecc ]&_fbga .Data [_fbab ]),_dcfb );_fbab +=_fbga .BytesPerLine ;_ecc +=_eace .BytesPerLine ;};if _gabb {for _fgag =0;_fgag < _accf ;_fgag ++{for _befgg =0;_befgg < _cegab ;
_befgg ++{_fbga .Data [_ggdf +_befgg ]=^(_eace .Data [_ffaf +_befgg ]&_fbga .Data [_ggdf +_befgg ]);};_ggdf +=_fbga .BytesPerLine ;_ffaf +=_eace .BytesPerLine ;};};if _gfffg {for _fgag =0;_fgag < _accf ;_fgag ++{_fbga .Data [_cgfc ]=_geaa (_fbga .Data [_cgfc ],^(_eace .Data [_aaec ]&_fbga .Data [_cgfc ]),_dabc );
_cgfc +=_fbga .BytesPerLine ;_aaec +=_eace .BytesPerLine ;};};case PixNotPixSrcXorDst :for _fgag =0;_fgag < _accf ;_fgag ++{_fbga .Data [_fbab ]=_geaa (_fbga .Data [_fbab ],^(_eace .Data [_ecc ]^_fbga .Data [_fbab ]),_dcfb );_fbab +=_fbga .BytesPerLine ;
_ecc +=_eace .BytesPerLine ;};if _gabb {for _fgag =0;_fgag < _accf ;_fgag ++{for _befgg =0;_befgg < _cegab ;_befgg ++{_fbga .Data [_ggdf +_befgg ]=^(_eace .Data [_ffaf +_befgg ]^_fbga .Data [_ggdf +_befgg ]);};_ggdf +=_fbga .BytesPerLine ;_ffaf +=_eace .BytesPerLine ;
};};if _gfffg {for _fgag =0;_fgag < _accf ;_fgag ++{_fbga .Data [_cgfc ]=_geaa (_fbga .Data [_cgfc ],^(_eace .Data [_aaec ]^_fbga .Data [_cgfc ]),_dabc );_cgfc +=_fbga .BytesPerLine ;_aaec +=_eace .BytesPerLine ;};};default:_fb .Log .Debug ("I\u006e\u0076\u0061\u006c\u0069\u0064 \u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070e\u0072\u0061\u0074o\u0072:\u0020\u0025\u0064",_abfa );
return _c .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072");};return nil ;};func (_ffge *NRGBA16 )Set (x ,y int ,c _g .Color ){_dgcgg :=y *_ffge .BytesPerLine +x *3/2;
if _dgcgg +1>=len (_ffge .Data ){return ;};_gfae :=NRGBA16Model .Convert (c ).(_g .NRGBA );_ffge .setNRGBA (x ,y ,_dgcgg ,_gfae );};func (_bbc *Gray8 )GrayAt (x ,y int )_g .Gray {_fcdd ,_ :=ColorAtGray8BPC (x ,y ,_bbc .BytesPerLine ,_bbc .Data ,_bbc .Decode );
return _fcdd ;};func _bbbdg (_edcg *_b .Gray16 ,_cffg uint8 )*_b .Gray {_bbdf :=_edcg .Bounds ();_cagd :=_b .NewGray (_bbdf );for _fced :=0;_fced < _bbdf .Dx ();_fced ++{for _ecdf :=0;_ecdf < _bbdf .Dy ();_ecdf ++{_eagb :=_edcg .Gray16At (_fced ,_ecdf );
_cagd .SetGray (_fced ,_ecdf ,_g .Gray {Y :_ffbf (uint8 (_eagb .Y /256),_cffg )});};};return _cagd ;};func (_afca *ImageBase )GetAlpha ()[]byte {return _afca .Alpha };func _cbdfd (_eece Gray ,_eaged NRGBA ,_cffa _b .Rectangle ){for _dbdf :=0;_dbdf < _cffa .Max .X ;
_dbdf ++{for _fdcb :=0;_fdcb < _cffa .Max .Y ;_fdcb ++{_ecfbe :=_eece .GrayAt (_dbdf ,_fdcb );_eaged .SetNRGBA (_dbdf ,_fdcb ,_gfed (_ecfbe ));};};};func ColorAtNRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_g .NRGBA ,error ){_egcc :=y *width +x ;
_efaa :=3*_egcc ;if _efaa +2>=len (data ){return _g .NRGBA {},_cg .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_bdgf :=uint8 (0xff);if alpha !=nil &&len (alpha )> _egcc {_bdgf =alpha [_egcc ];};_dcc ,_cfeee ,_gef :=data [_efaa ],data [_efaa +1],data [_efaa +2];if len (decode )==6{_dcc =uint8 (uint32 (LinearInterpolate (float64 (_dcc ),0,255,decode [0],decode [1]))&0xff);
_cfeee =uint8 (uint32 (LinearInterpolate (float64 (_cfeee ),0,255,decode [2],decode [3]))&0xff);_gef =uint8 (uint32 (LinearInterpolate (float64 (_gef ),0,255,decode [4],decode [5]))&0xff);};return _g .NRGBA {R :_dcc ,G :_cfeee ,B :_gef ,A :_bdgf },nil ;
};func ColorAtGray8BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_g .Gray ,error ){_bfbba :=y *bytesPerLine +x ;if _bfbba >=len (data ){return _g .Gray {},_cg .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_ecab :=data [_bfbba ];if len (decode )==2{_ecab =uint8 (uint32 (LinearInterpolate (float64 (_ecab ),0,255,decode [0],decode [1]))&0xff);};return _g .Gray {Y :_ecab },nil ;};func (_bdbdb *Monochrome )getBit (_baaa ,_aagf int )uint8 {return _bdbdb .Data [_baaa +(_aagf >>3)]>>uint (7-(_aagf &7))&1;
};var (_ad =_fed ();_ceb =_egf ();_bb =_adb (););func _cfed (_efbe NRGBA ,_efba RGBA ,_ffcg _b .Rectangle ){for _gaab :=0;_gaab < _ffcg .Max .X ;_gaab ++{for _eega :=0;_eega < _ffcg .Max .Y ;_eega ++{_dfbe :=_efbe .NRGBAAt (_gaab ,_eega );_efba .SetRGBA (_gaab ,_eega ,_fddb (_dfbe ));
};};};type nrgba64 interface{NRGBA64At (_dgcb ,_ecbc int )_g .NRGBA64 ;SetNRGBA64 (_ebbd ,_aeff int ,_ccaf _g .NRGBA64 );};func (_cgfg *RGBA32 )setRGBA (_aaadd int ,_dada _g .RGBA ){_cgecb :=3*_aaadd ;_cgfg .Data [_cgecb ]=_dada .R ;_cgfg .Data [_cgecb +1]=_dada .G ;
_cgfg .Data [_cgecb +2]=_dada .B ;if _aaadd < len (_cgfg .Alpha ){_cgfg .Alpha [_aaadd ]=_dada .A ;};};type SMasker interface{HasAlpha ()bool ;GetAlpha ()[]byte ;MakeAlpha ();};var _ _b .Image =&Gray16 {};func (_ece *CMYK32 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtCMYK (x ,y ,_ece .Width ,_ece .Data ,_ece .Decode );
};var _ Image =&NRGBA32 {};func (_dgec *Gray4 )At (x ,y int )_g .Color {_dade ,_ :=_dgec .ColorAt (x ,y );return _dade };func _bded (_ebec _g .RGBA )_g .CMYK {_befa ,_gbcb ,_bae ,_cde :=_g .RGBToCMYK (_ebec .R ,_ebec .G ,_ebec .B );return _g .CMYK {C :_befa ,M :_gbcb ,Y :_bae ,K :_cde };
};func (_eefc *Gray8 )Copy ()Image {return &Gray8 {ImageBase :_eefc .copy ()}};func ColorAtCMYK (x ,y ,width int ,data []byte ,decode []float64 )(_g .CMYK ,error ){_bcd :=4*(y *width +x );if _bcd +3>=len (data ){return _g .CMYK {},_cg .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};C :=data [_bcd ]&0xff;M :=data [_bcd +1]&0xff;Y :=data [_bcd +2]&0xff;K :=data [_bcd +3]&0xff;if len (decode )==8{C =uint8 (uint32 (LinearInterpolate (float64 (C ),0,255,decode [0],decode [1]))&0xff);M =uint8 (uint32 (LinearInterpolate (float64 (M ),0,255,decode [2],decode [3]))&0xff);
Y =uint8 (uint32 (LinearInterpolate (float64 (Y ),0,255,decode [4],decode [5]))&0xff);K =uint8 (uint32 (LinearInterpolate (float64 (K ),0,255,decode [6],decode [7]))&0xff);};return _g .CMYK {C :C ,M :M ,Y :Y ,K :K },nil ;};func (_adeb *Monochrome )ExpandBinary (factor int )(*Monochrome ,error ){if !IsPowerOf2 (uint (factor )){return nil ,_cg .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0065\u0078\u0070\u0061\u006e\u0064\u0020b\u0069n\u0061\u0072\u0079\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",factor );
};return _e (_adeb ,factor );};func ImgToBinary (i _b .Image ,threshold uint8 )*_b .Gray {switch _aefd :=i .(type ){case *_b .Gray :if _cfea (_aefd ){return _aefd ;};return _bgcd (_aefd ,threshold );case *_b .Gray16 :return _bbbdg (_aefd ,threshold );default:return _gfedf (_aefd ,threshold );
};};func _egd (_bef Gray ,_dde CMYK ,_cag _b .Rectangle ){for _bedd :=0;_bedd < _cag .Max .X ;_bedd ++{for _bfb :=0;_bfb < _cag .Max .Y ;_bfb ++{_gcb :=_bef .GrayAt (_bedd ,_bfb );_dde .SetCMYK (_bedd ,_bfb ,_afa (_gcb ));};};};var _ Image =&RGBA32 {};
func ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor int ,data ,alpha []byte ,decode []float64 )(_g .Color ,error ){switch bitsPerColor {case 4:return ColorAtNRGBA16 (x ,y ,width ,bytesPerLine ,data ,alpha ,decode );case 8:return ColorAtNRGBA32 (x ,y ,width ,data ,alpha ,decode );
case 16:return ColorAtNRGBA64 (x ,y ,width ,data ,alpha ,decode );default:return nil ,_cg .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0067\u0062\u0020b\u0069\u0074\u0073\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0061\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );
};};func (_facdg *ImageBase )setEightBytes (_gdcg int ,_ebeaf uint64 )error {_efab :=_facdg .BytesPerLine -(_gdcg %_facdg .BytesPerLine );if _facdg .BytesPerLine !=_facdg .Width >>3{_efab --;};if _efab >=8{return _facdg .setEightFullBytes (_gdcg ,_ebeaf );
};return _facdg .setEightPartlyBytes (_gdcg ,_efab ,_ebeaf );};func NewImage (width ,height ,bitsPerComponent ,colorComponents int ,data ,alpha []byte ,decode []float64 )(Image ,error ){_dedc :=NewImageBase (width ,height ,bitsPerComponent ,colorComponents ,data ,alpha ,decode );
var _dfff Image ;switch colorComponents {case 1:switch bitsPerComponent {case 1:_dfff =&Monochrome {ImageBase :_dedc ,ModelThreshold :0x0f};case 2:_dfff =&Gray2 {ImageBase :_dedc };case 4:_dfff =&Gray4 {ImageBase :_dedc };case 8:_dfff =&Gray8 {ImageBase :_dedc };
case 16:_dfff =&Gray16 {ImageBase :_dedc };};case 3:switch bitsPerComponent {case 4:_dfff =&NRGBA16 {ImageBase :_dedc };case 8:_dfff =&NRGBA32 {ImageBase :_dedc };case 16:_dfff =&NRGBA64 {ImageBase :_dedc };};case 4:_dfff =&CMYK32 {ImageBase :_dedc };};
if _dfff ==nil {return nil ,ErrInvalidImage ;};return _dfff ,nil ;};func _ce (_gb *Monochrome ,_ba int ,_eb []uint )(*Monochrome ,error ){_ef :=_ba *_gb .Width ;_cc :=_ba *_gb .Height ;_bd :=_gead (_ef ,_cc );for _ca ,_ge :=range _eb {var _dd error ;switch _ge {case 2:_dd =_bdb (_bd ,_gb );
case 4:_dd =_cac (_bd ,_gb );case 8:_dd =_fa (_bd ,_gb );};if _dd !=nil {return nil ,_dd ;};if _ca !=len (_eb )-1{_gb =_bd .copy ();};};return _bd ,nil ;};func (_bgd *Gray16 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtGray16BPC (x ,y ,_bgd .BytesPerLine ,_bgd .Data ,_bgd .Decode );
};func (_dfc *CMYK32 )Set (x ,y int ,c _g .Color ){_gce :=4*(y *_dfc .Width +x );if _gce +3>=len (_dfc .Data ){return ;};_fbb :=_g .CMYKModel .Convert (c ).(_g .CMYK );_dfc .Data [_gce ]=_fbb .C ;_dfc .Data [_gce +1]=_fbb .M ;_dfc .Data [_gce +2]=_fbb .Y ;
_dfc .Data [_gce +3]=_fbb .K ;};type ColorConverter interface{Convert (_cdf _b .Image )(Image ,error );};func (_ebgea *RGBA32 )RGBAAt (x ,y int )_g .RGBA {_dbee ,_ :=ColorAtRGBA32 (x ,y ,_ebgea .Width ,_ebgea .Data ,_ebgea .Alpha ,_ebgea .Decode );return _dbee ;
};func (_dfed *NRGBA16 )At (x ,y int )_g .Color {_gddfc ,_ :=_dfed .ColorAt (x ,y );return _gddfc };var _ Gray =&Gray8 {};func (_abaa *Gray16 )Base ()*ImageBase {return &_abaa .ImageBase };