//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package imageutil ;import (_g "errors";_ec "fmt";_gd "github.com/unidoc/unipdf/v3/internal/bitwise";_gb "image";_a "image/color";_d "image/draw";_ge "math";);type CMYK32 struct{ImageBase };func ColorAtNRGBA64 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_a .NRGBA64 ,error ){_eac :=(y *width +x )*2;_afbb :=_eac *3;if _afbb +5>=len (data ){return _a .NRGBA64 {},_ec .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};const _gbed =0xffff;_gdag :=uint16 (_gbed );if alpha !=nil &&len (alpha )> _eac +1{_gdag =uint16 (alpha [_eac ])<<8|uint16 (alpha [_eac +1]);};_dffd :=uint16 (data [_afbb ])<<8|uint16 (data [_afbb +1]);_dbef :=uint16 (data [_afbb +2])<<8|uint16 (data [_afbb +3]);_eda :=uint16 (data [_afbb +4])<<8|uint16 (data [_afbb +5]);if len (decode )==6{_dffd =uint16 (uint64 (LinearInterpolate (float64 (_dffd ),0,65535,decode [0],decode [1]))&_gbed );_dbef =uint16 (uint64 (LinearInterpolate (float64 (_dbef ),0,65535,decode [2],decode [3]))&_gbed );_eda =uint16 (uint64 (LinearInterpolate (float64 (_eda ),0,65535,decode [4],decode [5]))&_gbed );};return _a .NRGBA64 {R :_dffd ,G :_dbef ,B :_eda ,A :_gdag },nil ;};func (_baba *NRGBA64 )At (x ,y int )_a .Color {_cefc ,_ :=_baba .ColorAt (x ,y );return _cefc };func (_cbaf *Gray8 )Base ()*ImageBase {return &_cbaf .ImageBase };var _ Image =&NRGBA16 {};func (_cef *monochromeThresholdConverter )Convert (img _gb .Image )(Image ,error ){if _acaf ,_abd :=img .(*Monochrome );_abd {return _acaf .Copy (),nil ;};_abe :=img .Bounds ();_bbd ,_cbg :=NewImage (_abe .Max .X ,_abe .Max .Y ,1,1,nil ,nil ,nil );if _cbg !=nil {return nil ,_cbg ;};_bbd .(*Monochrome ).ModelThreshold =_cef .Threshold ;for _dbbc :=0;_dbbc < _abe .Max .X ;_dbbc ++{for _gde :=0;_gde < _abe .Max .Y ;_gde ++{_fee :=img .At (_dbbc ,_gde );_bbd .Set (_dbbc ,_gde ,_fee );};};return _bbd ,nil ;};func (_afb *CMYK32 )ColorModel ()_a .Model {return _a .CMYKModel };type monochromeModel uint8 ;func (_cfbe *NRGBA32 )Copy ()Image {return &NRGBA32 {ImageBase :_cfbe .copy ()}};var _ Image =&Gray2 {};func (_bae *Gray2 )GrayAt (x ,y int )_a .Gray {_dda ,_ :=ColorAtGray2BPC (x ,y ,_bae .BytesPerLine ,_bae .Data ,_bae .Decode );return _dda ;};func ConverterFunc (converterFunc func (_aeg _gb .Image )(Image ,error ))ColorConverter {return colorConverter {_cg :converterFunc };};type monochromeThresholdConverter struct{Threshold uint8 ;};func _fdde (_ggc _gb .Image ,_edcc Image ,_dbf _gb .Rectangle ){switch _edce :=_ggc .(type ){case Gray :_eca (_edce ,_edcc .(Gray ),_dbf );case NRGBA :_dcab (_edce ,_edcc .(Gray ),_dbf );case CMYK :_cdcb (_edce ,_edcc .(Gray ),_dbf );case RGBA :_cca (_edce ,_edcc .(Gray ),_dbf );default:_bgb (_ggc ,_edcc .(Image ),_dbf );};};func _badc (_eaeg _gb .Image )(Image ,error ){if _cbf ,_acad :=_eaeg .(*NRGBA16 );_acad {return _cbf .Copy (),nil ;};_ddcg :=_eaeg .Bounds ();_ebga ,_fdcf :=NewImage (_ddcg .Max .X ,_ddcg .Max .Y ,4,3,nil ,nil ,nil );if _fdcf !=nil {return nil ,_fdcf ;};_fggg (_eaeg ,_ebga ,_ddcg );return _ebga ,nil ;};type ImageBase struct{Width ,Height int ;BitsPerComponent ,ColorComponents int ;Data ,Alpha []byte ;Decode []float64 ;BytesPerLine int ;};func _cca (_fde RGBA ,_cab Gray ,_ggfe _gb .Rectangle ){for _feea :=0;_feea < _ggfe .Max .X ;_feea ++{for _fcbb :=0;_fcbb < _ggfe .Max .Y ;_fcbb ++{_acc :=_dbbe (_fde .RGBAAt (_feea ,_fcbb ));_cab .SetGray (_feea ,_fcbb ,_acc );};};};func (_fe *CMYK32 )Bounds ()_gb .Rectangle {return _gb .Rectangle {Max :_gb .Point {X :_fe .Width ,Y :_fe .Height }};};func IsGrayImgBlackAndWhite (i *_gb .Gray )bool {return _ccdf (i )};type colorConverter struct{_cg func (_dffe _gb .Image )(Image ,error );};var _ _gb .Image =&Gray16 {};func (_eef *NRGBA16 )setNRGBA (_bdga ,_cabb ,_cgbc int ,_bbga _a .NRGBA ){if _bdga *3%2==0{_eef .Data [_cgbc ]=(_bbga .R >>4)<<4|(_bbga .G >>4);_eef .Data [_cgbc +1]=(_bbga .B >>4)<<4|(_eef .Data [_cgbc +1]&0xf);}else {_eef .Data [_cgbc ]=(_eef .Data [_cgbc ]&0xf0)|(_bbga .R >>4);_eef .Data [_cgbc +1]=(_bbga .G >>4)<<4|(_bbga .B >>4);};if _eef .Alpha !=nil {_bfba :=_cabb *BytesPerLine (_eef .Width ,4,1);if _bfba < len (_eef .Alpha ){if _bdga %2==0{_eef .Alpha [_bfba ]=(_bbga .A >>uint (4))<<uint (4)|(_eef .Alpha [_cgbc ]&0xf);}else {_eef .Alpha [_bfba ]=(_eef .Alpha [_bfba ]&0xf0)|(_bbga .A >>uint (4));};};};};func (_dgfg *Gray16 )ColorAt (x ,y int )(_a .Color ,error ){return ColorAtGray16BPC (x ,y ,_dgfg .BytesPerLine ,_dgfg .Data ,_dgfg .Decode );};func (_dbb colorConverter )Convert (src _gb .Image )(Image ,error ){return _dbb ._cg (src )};func (_bdc *NRGBA32 )SetNRGBA (x ,y int ,c _a .NRGBA ){_ffbf :=y *_bdc .Width +x ;_abgbg :=3*_ffbf ;if _abgbg +2>=len (_bdc .Data ){return ;};_bdc .setRGBA (_ffbf ,c );return ;};func (_ca *Gray2 )Validate ()error {if len (_ca .Data )!=_ca .Height *_ca .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_cccf *Monochrome )setGray (_ebg int ,_bdee _a .Gray ,_fefb int ){if _bdee .Y ==0{_cccf .clearBit (_fefb ,_ebg );}else {_cccf .setBit (_fefb ,_ebg );};};func (_aec *Gray16 )ColorModel ()_a .Model {return _a .Gray16Model };func (_fcbe *NRGBA64 )setNRGBA64 (_efdc int ,_geddb _a .NRGBA64 ,_bea int ){_fcbe .Data [_efdc ]=uint8 (_geddb .R >>8);_fcbe .Data [_efdc +1]=uint8 (_geddb .R &0xff);_fcbe .Data [_efdc +2]=uint8 (_geddb .G >>8);_fcbe .Data [_efdc +3]=uint8 (_geddb .G &0xff);_fcbe .Data [_efdc +4]=uint8 (_geddb .B >>8);_fcbe .Data [_efdc +5]=uint8 (_geddb .B &0xff);if _bea +1< len (_fcbe .Alpha ){_fcbe .Alpha [_bea ]=uint8 (_geddb .A >>8);_fcbe .Alpha [_bea +1]=uint8 (_geddb .A &0xff);};};func (_dcg *Gray8 )Bounds ()_gb .Rectangle {return _gb .Rectangle {Max :_gb .Point {X :_dcg .Width ,Y :_dcg .Height }};};type Gray4 struct{ImageBase };func _cfg (_fbe _a .Gray )_a .CMYK {return _a .CMYK {K :0xff-_fbe .Y }};func (_gbce *NRGBA64 )Validate ()error {if len (_gbce .Data )!=3*2*_gbce .Width *_gbce .Height {return _g .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");};return nil ;};func (_dcb monochromeModel )Convert (c _a .Color )_a .Color {_dfb :=_a .GrayModel .Convert (c ).(_a .Gray );return _bf (_dfb ,_dcb );};func (_cec *Gray8 )Histogram ()(_abcf [256]int ){for _gcb :=0;_gcb < len (_cec .Data );_gcb ++{_abcf [_cec .Data [_gcb ]]++;};return _abcf ;};func (_bdgd *Gray4 )Copy ()Image {return &Gray4 {ImageBase :_bdgd .copy ()}};var _fbgf [256]uint8 ;func _cea (_cba _a .CMYK )_a .Gray {_ggg ,_aega ,_abg :=_a .CMYKToRGB (_cba .C ,_cba .M ,_cba .Y ,_cba .K );_ffg :=(19595*uint32 (_ggg )+38470*uint32 (_aega )+7471*uint32 (_abg )+1<<7)>>16;return _a .Gray {Y :uint8 (_ffg )};};func _dfag (_caf CMYK ,_fdgc NRGBA ,_eaff _gb .Rectangle ){for _aac :=0;_aac < _eaff .Max .X ;_aac ++{for _gddf :=0;_gddf < _eaff .Max .Y ;_gddf ++{_ccgf :=_caf .CMYKAt (_aac ,_gddf );_fdgc .SetNRGBA (_aac ,_gddf ,_bd (_ccgf ));};};};type SMasker interface{HasAlpha ()bool ;GetAlpha ()[]byte ;MakeAlpha ();};func BytesPerLine (width ,bitsPerComponent ,colorComponents int )int {return ((width *bitsPerComponent )*colorComponents +7)>>3;};func init (){_gadd ()};type RGBA interface{RGBAAt (_gded ,_fdc int )_a .RGBA ;SetRGBA (_gdaf ,_ggfed int ,_ggeg _a .RGBA );};func _deaa (_ecee []byte ,_bab Image )error {_acfd :=true ;for _gec :=0;_gec < len (_ecee );_gec ++{if _ecee [_gec ]!=0xff{_acfd =false ;break ;};};if _acfd {switch _fba :=_bab .(type ){case *NRGBA32 :_fba .Alpha =nil ;case *NRGBA64 :_fba .Alpha =nil ;default:return _ec .Errorf ("i\u006ete\u0072n\u0061l\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020i\u006d\u0061\u0067\u0065\u0020s\u0068\u006f\u0075l\u0064\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0074\u0079\u0070e\u0020\u002a\u004eRGB\u0041\u0033\u0032\u0020\u006f\u0072 \u002a\u004e\u0052\u0047\u0042\u0041\u0036\u0034\u0020\u0062\u0075\u0074 \u0069s\u003a\u0020\u0025\u0054",_bab );};};return nil ;};func _fac (_bde _a .RGBA )_a .NRGBA {switch _bde .A {case 0xff:return _a .NRGBA {R :_bde .R ,G :_bde .G ,B :_bde .B ,A :0xff};case 0x00:return _a .NRGBA {};default:_gdd ,_dba ,_bag ,_cd :=_bde .RGBA ();_gdd =(_gdd *0xffff)/_cd ;_dba =(_dba *0xffff)/_cd ;_bag =(_bag *0xffff)/_cd ;return _a .NRGBA {R :uint8 (_gdd >>8),G :uint8 (_dba >>8),B :uint8 (_bag >>8),A :uint8 (_cd >>8)};};};func _afee (_cfe _a .Gray )_a .Gray {_acdf :=_cfe .Y >>6;_acdf |=_acdf <<2;_cfe .Y =_acdf |_acdf <<4;return _cfe ;};func _ceeb (_gcdd Gray ,_ebae NRGBA ,_cefe _gb .Rectangle ){for _gaab :=0;_gaab < _cefe .Max .X ;_gaab ++{for _dabbb :=0;_dabbb < _cefe .Max .Y ;_dabbb ++{_adbf :=_gcdd .GrayAt (_gaab ,_dabbb );_ebae .SetNRGBA (_gaab ,_dabbb ,_eab (_adbf ));};};};func (_dce *Gray2 )Bounds ()_gb .Rectangle {return _gb .Rectangle {Max :_gb .Point {X :_dce .Width ,Y :_dce .Height }};};func (_gba *CMYK32 )SetCMYK (x ,y int ,c _a .CMYK ){_ee :=4*(y *_gba .Width +x );if _ee +3>=len (_gba .Data ){return ;};_gba .Data [_ee ]=c .C ;_gba .Data [_ee +1]=c .M ;_gba .Data [_ee +2]=c .Y ;_gba .Data [_ee +3]=c .K ;};func AddDataPadding (width ,height ,bitsPerComponent ,colorComponents int ,data []byte )([]byte ,error ){_dge :=BytesPerLine (width ,bitsPerComponent ,colorComponents );if _dge ==width *colorComponents *bitsPerComponent /8{return data ,nil ;};_gef :=width *colorComponents *bitsPerComponent ;_fccg :=_dge *8;_fgd :=8-(_fccg -_gef );_baec :=_gd .NewReader (data );_cag :=_dge -1;_ddb :=make ([]byte ,_cag );_dgfa :=make ([]byte ,height *_dge );_dbd :=_gd .NewWriterMSB (_dgfa );var _dae uint64 ;var _dbaa error ;for _eaa :=0;_eaa < height ;_eaa ++{_ ,_dbaa =_baec .Read (_ddb );if _dbaa !=nil {return nil ,_dbaa ;};_ ,_dbaa =_dbd .Write (_ddb );if _dbaa !=nil {return nil ,_dbaa ;};_dae ,_dbaa =_baec .ReadBits (byte (_fgd ));if _dbaa !=nil {return nil ,_dbaa ;};_ ,_dbaa =_dbd .WriteBits (_dae ,_fgd );if _dbaa !=nil {return nil ,_dbaa ;};_dbd .FinishByte ();};return _dgfa ,nil ;};func _gadd (){for _gcbc :=0;_gcbc < 256;_gcbc ++{_fbgf [_gcbc ]=uint8 (_gcbc &0x1)+(uint8 (_gcbc >>1)&0x1)+(uint8 (_gcbc >>2)&0x1)+(uint8 (_gcbc >>3)&0x1)+(uint8 (_gcbc >>4)&0x1)+(uint8 (_gcbc >>5)&0x1)+(uint8 (_gcbc >>6)&0x1)+(uint8 (_gcbc >>7)&0x1);};};func (_ff *CMYK32 )Set (x ,y int ,c _a .Color ){_df :=4*(y *_ff .Width +x );if _df +3>=len (_ff .Data ){return ;};_af :=_a .CMYKModel .Convert (c ).(_a .CMYK );_ff .Data [_df ]=_af .C ;_ff .Data [_df +1]=_af .M ;_ff .Data [_df +2]=_af .Y ;_ff .Data [_df +3]=_af .K ;};func (_cfgd *Monochrome )Validate ()error {if len (_cfgd .Data )!=_cfgd .Height *_cfgd .BytesPerLine {return ErrInvalidImage ;};return nil ;};func ColorAtNRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_a .NRGBA ,error ){_cdcd :=y *width +x ;_accg :=3*_cdcd ;if _accg +2>=len (data ){return _a .NRGBA {},_ec .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_bgef :=uint8 (0xff);if alpha !=nil &&len (alpha )> _cdcd {_bgef =alpha [_cdcd ];};_aadd ,_gefb ,_eecc :=data [_accg ],data [_accg +1],data [_accg +2];if len (decode )==6{_aadd =uint8 (uint32 (LinearInterpolate (float64 (_aadd ),0,255,decode [0],decode [1]))&0xff);_gefb =uint8 (uint32 (LinearInterpolate (float64 (_gefb ),0,255,decode [2],decode [3]))&0xff);_eecc =uint8 (uint32 (LinearInterpolate (float64 (_eecc ),0,255,decode [4],decode [5]))&0xff);};return _a .NRGBA {R :_aadd ,G :_gefb ,B :_eecc ,A :_bgef },nil ;};func _bfa (_fgfa _a .Color )_a .Color {_caae :=_a .GrayModel .Convert (_fgfa ).(_a .Gray );return _becb (_caae );};func _dbbe (_eae _a .RGBA )_a .Gray {_edfd :=(19595*uint32 (_eae .R )+38470*uint32 (_eae .G )+7471*uint32 (_eae .B )+1<<7)>>16;return _a .Gray {Y :uint8 (_edfd )};};func (_bfcc *NRGBA16 )ColorAt (x ,y int )(_a .Color ,error ){return ColorAtNRGBA16 (x ,y ,_bfcc .Width ,_bfcc .BytesPerLine ,_bfcc .Data ,_bfcc .Alpha ,_bfcc .Decode );};func _bcag (_dedb _gb .Image )(Image ,error ){if _gdea ,_acab :=_dedb .(*Gray16 );_acab {return _gdea .Copy (),nil ;};_facb :=_dedb .Bounds ();_cdab ,_bbe :=NewImage (_facb .Max .X ,_facb .Max .Y ,16,1,nil ,nil ,nil );if _bbe !=nil {return nil ,_bbe ;};_fdde (_dedb ,_cdab ,_facb );return _cdab ,nil ;};type NRGBA16 struct{ImageBase };func ColorAtGray1BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_a .Gray ,error ){_dfbb :=y *bytesPerLine +x >>3;if _dfbb >=len (data ){return _a .Gray {},_ec .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_cbc :=data [_dfbb ]>>uint (7-(x &7))&1;if len (decode )==2{_cbc =uint8 (LinearInterpolate (float64 (_cbc ),0.0,1.0,decode [0],decode [1]))&1;};return _a .Gray {Y :_cbc *255},nil ;};func (_agba *NRGBA16 )Copy ()Image {return &NRGBA16 {ImageBase :_agba .copy ()}};func (_bece *NRGBA32 )Bounds ()_gb .Rectangle {return _gb .Rectangle {Max :_gb .Point {X :_bece .Width ,Y :_bece .Height }};};func (_adba *Gray8 )ColorModel ()_a .Model {return _a .GrayModel };func _aaag (_agcg *_gb .NYCbCrA ,_bfcb NRGBA ,_decd _gb .Rectangle ){for _gff :=0;_gff < _decd .Max .X ;_gff ++{for _bff :=0;_bff < _decd .Max .Y ;_bff ++{_cdf :=_agcg .NYCbCrAAt (_gff ,_bff );_bfcb .SetNRGBA (_gff ,_bff ,_geef (_cdf ));};};};func _becb (_agbe _a .Gray )_a .Gray {_agbe .Y >>=4;_agbe .Y |=_agbe .Y <<4;return _agbe };func (_fcc *CMYK32 )Copy ()Image {return &CMYK32 {ImageBase :_fcc .copy ()}};func _bf (_gaf _a .Gray ,_eg monochromeModel )_a .Gray {if _gaf .Y > uint8 (_eg ){return _a .Gray {Y :_ge .MaxUint8 };};return _a .Gray {};};var _ _gb .Image =&Gray4 {};func (_gcd *NRGBA64 )ColorAt (x ,y int )(_a .Color ,error ){return ColorAtNRGBA64 (x ,y ,_gcd .Width ,_gcd .Data ,_gcd .Alpha ,_gcd .Decode );};type Histogramer interface{Histogram ()[256]int ;};func (_gda *Gray4 )At (x ,y int )_a .Color {_gggf ,_ :=_gda .ColorAt (x ,y );return _gggf };func (_ecbf *Monochrome )ColorAt (x ,y int )(_a .Color ,error ){return ColorAtGray1BPC (x ,y ,_ecbf .BytesPerLine ,_ecbf .Data ,_ecbf .Decode );};func (_begc *NRGBA16 )SetNRGBA (x ,y int ,c _a .NRGBA ){_dcf :=y *_begc .BytesPerLine +x *3/2;if _dcf +1>=len (_begc .Data ){return ;};c =_dcdf (c );_begc .setNRGBA (x ,y ,_dcf ,c );};func _dfec (_egeg *_gb .Gray ,_cfdd uint8 )*_gb .Gray {_fabb :=_egeg .Bounds ();_dbed :=_gb .NewGray (_fabb );for _gdg :=0;_gdg < _fabb .Dx ();_gdg ++{for _ecfe :=0;_ecfe < _fabb .Dy ();_ecfe ++{_gfbfd :=_egeg .GrayAt (_gdg ,_ecfe );_dbed .SetGray (_gdg ,_ecfe ,_a .Gray {Y :_cdd (_gfbfd .Y ,_cfdd )});};};return _dbed ;};func FromGoImage (i _gb .Image )(Image ,error ){switch _gacc :=i .(type ){case Image :return _gacc .Copy (),nil ;case Gray :return GrayConverter .Convert (i );case *_gb .Gray16 :return Gray16Converter .Convert (i );case CMYK :return CMYKConverter .Convert (i );case *_gb .NRGBA64 :return NRGBA64Converter .Convert (i );default:return NRGBAConverter .Convert (i );};};func (_gfbf *NRGBA64 )NRGBA64At (x ,y int )_a .NRGBA64 {_eba ,_ :=ColorAtNRGBA64 (x ,y ,_gfbf .Width ,_gfbf .Data ,_gfbf .Alpha ,_gfbf .Decode );return _eba ;};func _bd (_ged _a .CMYK )_a .NRGBA {_dec ,_aed ,_ecf :=_a .CMYKToRGB (_ged .C ,_ged .M ,_ged .Y ,_ged .K );return _a .NRGBA {R :_dec ,G :_aed ,B :_ecf ,A :0xff};};func ColorAtGray4BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_a .Gray ,error ){_edff :=y *bytesPerLine +x >>1;if _edff >=len (data ){return _a .Gray {},_ec .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_gccd :=data [_edff ]>>uint (4-(x &1)*4)&0xf;if len (decode )==2{_gccd =uint8 (uint32 (LinearInterpolate (float64 (_gccd ),0,15,decode [0],decode [1]))&0xf);};return _a .Gray {Y :_gccd *17&0xff},nil ;};func (_fcaf *Gray8 )Validate ()error {if len (_fcaf .Data )!=_fcaf .Height *_fcaf .BytesPerLine {return ErrInvalidImage ;};return nil ;};func _dcab (_edfdg NRGBA ,_bcf Gray ,_egc _gb .Rectangle ){for _gbad :=0;_gbad < _egc .Max .X ;_gbad ++{for _ceg :=0;_ceg < _egc .Max .Y ;_ceg ++{_ebb :=_ffa (_edfdg .NRGBAAt (_gbad ,_ceg ));_bcf .SetGray (_gbad ,_ceg ,_ebb );};};};func (_gcbb *Gray16 )Bounds ()_gb .Rectangle {return _gb .Rectangle {Max :_gb .Point {X :_gcbb .Width ,Y :_gcbb .Height }};};var _ _gb .Image =&Gray2 {};var _ Gray =&Gray8 {};type NRGBA32 struct{ImageBase };var _ Image =&Gray8 {};var _ Image =&NRGBA64 {};func GetConverter (bitsPerComponent ,colorComponents int )(ColorConverter ,error ){switch colorComponents {case 1:switch bitsPerComponent {case 1:return MonochromeConverter ,nil ;case 2:return Gray2Converter ,nil ;case 4:return Gray4Converter ,nil ;case 8:return GrayConverter ,nil ;case 16:return Gray16Converter ,nil ;};case 3:switch bitsPerComponent {case 4:return NRGBA16Converter ,nil ;case 8:return NRGBAConverter ,nil ;case 16:return NRGBA64Converter ,nil ;};case 4:return CMYKConverter ,nil ;};return nil ,_ec .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0043o\u006e\u0076\u0065\u0072\u0074\u0065\u0072\u0020\u0070\u0061\u0072\u0061\u006d\u0065t\u0065\u0072\u0073\u002e\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003a\u0020\u0025\u0064\u002c\u0020\u0043\u006f\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006et\u0073\u003a \u0025\u0064",bitsPerComponent ,colorComponents );};var _ _gb .Image =&NRGBA32 {};func (_debg *NRGBA16 )At (x ,y int )_a .Color {_ceba ,_ :=_debg .ColorAt (x ,y );return _ceba };type Image interface{_d .Image ;Base ()*ImageBase ;Copy ()Image ;Pix ()[]byte ;ColorAt (_efb ,_bfc int )(_a .Color ,error );Validate ()error ;};type Gray8 struct{ImageBase };var _ Image =&Gray4 {};func (_bgg *Gray4 )GrayAt (x ,y int )_a .Gray {_bgbc ,_ :=ColorAtGray4BPC (x ,y ,_bgg .BytesPerLine ,_bgg .Data ,_bgg .Decode );return _bgbc ;};func MonochromeModel (threshold uint8 )_a .Model {return monochromeModel (threshold )};var _ Image =&Monochrome {};func _bbgg (_dfg ,_dgc NRGBA ,_abfa _gb .Rectangle ){for _fbcf :=0;_fbcf < _abfa .Max .X ;_fbcf ++{for _ecbc :=0;_ecbc < _abfa .Max .Y ;_ecbc ++{_dgc .SetNRGBA (_fbcf ,_ecbc ,_dfg .NRGBAAt (_fbcf ,_ecbc ));};};};func (_fcfg *ImageBase )copy ()ImageBase {_acbfb :=*_fcfg ;_acbfb .Data =make ([]byte ,len (_fcfg .Data ));copy (_acbfb .Data ,_fcfg .Data );return _acbfb ;};func (_fea *Monochrome )Copy ()Image {return &Monochrome {ImageBase :_fea .ImageBase .copy (),ModelThreshold :_fea .ModelThreshold };};func (_ebe *Monochrome )GrayAt (x ,y int )_a .Gray {_fec ,_ :=ColorAtGray1BPC (x ,y ,_ebe .BytesPerLine ,_ebe .Data ,_ebe .Decode );return _fec ;};func NewImageBase (width int ,height int ,bitsPerComponent int ,colorComponents int ,data []byte ,alpha []byte ,decode []float64 )ImageBase {_dbc :=ImageBase {Width :width ,Height :height ,BitsPerComponent :bitsPerComponent ,ColorComponents :colorComponents ,Data :data ,Alpha :alpha ,Decode :decode ,BytesPerLine :BytesPerLine (width ,bitsPerComponent ,colorComponents )};if data ==nil {_dbc .Data =make ([]byte ,height *_dbc .BytesPerLine );};return _dbc ;};func _fda (_bce nrgba64 ,_ggd NRGBA ,_abbb _gb .Rectangle ){for _bdd :=0;_bdd < _abbb .Max .X ;_bdd ++{for _abab :=0;_abab < _abbb .Max .Y ;_abab ++{_fbf :=_bce .NRGBA64At (_bdd ,_abab );_ggd .SetNRGBA (_bdd ,_abab ,_adab (_fbf ));};};};func (_gdf *NRGBA32 )ColorAt (x ,y int )(_a .Color ,error ){return ColorAtNRGBA32 (x ,y ,_gdf .Width ,_gdf .Data ,_gdf .Alpha ,_gdf .Decode );};func (_bgd *Gray4 )ColorModel ()_a .Model {return Gray4Model };func (_facg *NRGBA32 )Base ()*ImageBase {return &_facg .ImageBase };func (_agbg *Gray16 )Histogram ()(_aegd [256]int ){for _ece :=0;_ece < _agbg .Width ;_ece ++{for _cdc :=0;_cdc < _agbg .Height ;_cdc ++{_aegd [_agbg .GrayAt (_ece ,_cdc ).Y ]++;};};return _aegd ;};func (_bfcd *NRGBA32 )Validate ()error {if len (_bfcd .Data )!=3*_bfcd .Width *_bfcd .Height {return _g .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");};return nil ;};func (_bfe *Gray16 )Set (x ,y int ,c _a .Color ){_cda :=(y *_bfe .BytesPerLine /2+x )*2;if _cda +1>=len (_bfe .Data ){return ;};_gcca :=_a .Gray16Model .Convert (c ).(_a .Gray16 );_bfe .Data [_cda ],_bfe .Data [_cda +1]=uint8 (_gcca .Y >>8),uint8 (_gcca .Y &0xff);};func (_agf *NRGBA32 )Set (x ,y int ,c _a .Color ){_ffd :=y *_agf .Width +x ;_ggb :=3*_ffd ;if _ggb +2>=len (_agf .Data ){return ;};_eced :=_a .NRGBAModel .Convert (c ).(_a .NRGBA );_agf .setRGBA (_ffd ,_eced );};func (_aada *Gray8 )GrayAt (x ,y int )_a .Gray {_cdgf ,_ :=ColorAtGray8BPC (x ,y ,_aada .BytesPerLine ,_aada .Data ,_aada .Decode );return _cdgf ;};func (_fdfg *NRGBA64 )Copy ()Image {return &NRGBA64 {ImageBase :_fdfg .copy ()}};func (_cbca *Gray2 )Histogram ()(_dab [256]int ){for _aag :=0;_aag < _cbca .Width ;_aag ++{for _cde :=0;_cde < _cbca .Height ;_cde ++{_dab [_cbca .GrayAt (_aag ,_cde ).Y ]++;};};return _dab ;};func (_acda *Gray4 )Validate ()error {if len (_acda .Data )!=_acda .Height *_acda .BytesPerLine {return ErrInvalidImage ;};return nil ;};var _ _gb .Image =&NRGBA64 {};func GrayHistogram (g Gray )(_edca [256]int ){switch _gace :=g .(type ){case Histogramer :return _gace .Histogram ();case _gb .Image :_ccfa :=_gace .Bounds ();for _ccaa :=0;_ccaa < _ccfa .Max .X ;_ccaa ++{for _fecg :=0;_fecg < _ccfa .Max .Y ;_fecg ++{_edca [g .GrayAt (_ccaa ,_fecg ).Y ]++;};};return _edca ;default:return [256]int {};};};func _bgf (_ef ,_ag CMYK ,_ce _gb .Rectangle ){for _efd :=0;_efd < _ce .Max .X ;_efd ++{for _aca :=0;_aca < _ce .Max .Y ;_aca ++{_ag .SetCMYK (_efd ,_aca ,_ef .CMYKAt (_efd ,_aca ));};};};var _ _gb .Image =&NRGBA16 {};func _cegb (_gbcb _gb .Image )(Image ,error ){if _bef ,_bcg :=_gbcb .(*NRGBA32 );_bcg {return _bef .Copy (),nil ;};_bda ,_gbeg ,_efad :=_dbcd (_gbcb ,1);_bfef ,_fcfb :=NewImage (_bda .Max .X ,_bda .Max .Y ,8,3,nil ,_efad ,nil );if _fcfb !=nil {return nil ,_fcfb ;};_fggg (_gbcb ,_bfef ,_bda );if len (_efad )!=0&&!_gbeg {if _fdgb :=_deaa (_efad ,_bfef );_fdgb !=nil {return nil ,_fdgb ;};};return _bfef ,nil ;};func (_egb *NRGBA16 )Base ()*ImageBase {return &_egb .ImageBase };func (_faf *Gray2 )Base ()*ImageBase {return &_faf .ImageBase };func (_gege *Gray8 )Copy ()Image {return &Gray8 {ImageBase :_gege .copy ()}};var _ Gray =&Gray16 {};func _ffa (_fef _a .NRGBA )_a .Gray {_gfd ,_ba ,_eb ,_ :=_fef .RGBA ();_ed :=(19595*_gfd +38470*_ba +7471*_eb +1<<15)>>24;return _a .Gray {Y :uint8 (_ed )};};type NRGBA interface{NRGBAAt (_agbb ,_cdge int )_a .NRGBA ;SetNRGBA (_egef ,_gdae int ,_cdb _a .NRGBA );};var _ Image =&Gray16 {};func _bgb (_gcf _gb .Image ,_aa Image ,_bge _gb .Rectangle ){for _ccb :=0;_ccb < _bge .Max .X ;_ccb ++{for _fa :=0;_fa < _bge .Max .Y ;_fa ++{_ccc :=_gcf .At (_ccb ,_fa );_aa .Set (_ccb ,_fa ,_ccc );};};};func _acbf (_fccc _a .RGBA )_a .CMYK {_bdg ,_add ,_geaeg ,_ede :=_a .RGBToCMYK (_fccc .R ,_fccc .G ,_fccc .B );return _a .CMYK {C :_bdg ,M :_add ,Y :_geaeg ,K :_ede };};func (_beg *Gray8 )SetGray (x ,y int ,g _a .Gray ){_geeg :=y *_beg .BytesPerLine +x ;if _geeg > len (_beg .Data )-1{return ;};_beg .Data [_geeg ]=g .Y ;};func (_edc *Gray8 )ColorAt (x ,y int )(_a .Color ,error ){return ColorAtGray8BPC (x ,y ,_edc .BytesPerLine ,_edc .Data ,_edc .Decode );};type NRGBA64 struct{ImageBase };func (_ddd *Monochrome )Histogram ()(_cfce [256]int ){for _ ,_eaf :=range _ddd .Data {_cfce [0xff]+=int (_fbgf [_ddd .Data [_eaf ]]);};return _cfce ;};func ColorAt (x ,y ,width ,bitsPerColor ,colorComponents ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_a .Color ,error ){switch colorComponents {case 1:return ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine ,data ,decode );case 3:return ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor ,data ,alpha ,decode );case 4:return ColorAtCMYK (x ,y ,width ,data ,decode );default:return nil ,_ec .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0063o\u006c\u006f\u0072\u0020\u0063\u006f\u006dp\u006f\u006e\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0064",colorComponents );};};func _edef (_dgf _gb .Image )(Image ,error ){if _gaa ,_cce :=_dgf .(*Gray4 );_cce {return _gaa .Copy (),nil ;};_bbad :=_dgf .Bounds ();_cac ,_efa :=NewImage (_bbad .Max .X ,_bbad .Max .Y ,4,1,nil ,nil ,nil );if _efa !=nil {return nil ,_efa ;};_fdde (_dgf ,_cac ,_bbad );return _cac ,nil ;};func ImgToBinary (i _gb .Image ,threshold uint8 )*_gb .Gray {switch _bged :=i .(type ){case *_gb .Gray :if _ccdf (_bged ){return _bged ;};return _dfec (_bged ,threshold );case *_gb .Gray16 :return _bead (_bged ,threshold );default:return _fced (_bged ,threshold );};};func _aba (_ae Gray ,_cc CMYK ,_ad _gb .Rectangle ){for _cf :=0;_cf < _ad .Max .X ;_cf ++{for _db :=0;_db < _ad .Max .Y ;_db ++{_ffc :=_ae .GrayAt (_cf ,_db );_cc .SetCMYK (_cf ,_db ,_cfg (_ffc ));};};};var _ Image =&NRGBA32 {};func (_dgbe *NRGBA32 )At (x ,y int )_a .Color {_gabg ,_ :=_dgbe .ColorAt (x ,y );return _gabg };var ErrInvalidImage =_g .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");func _gf (_eedc NRGBA ,_fd CMYK ,_gegg _gb .Rectangle ){for _acd :=0;_acd < _gegg .Max .X ;_acd ++{for _dff :=0;_dff < _gegg .Max .Y ;_dff ++{_cb :=_eedc .NRGBAAt (_acd ,_dff );_fd .SetCMYK (_acd ,_dff ,_ada (_cb ));};};};func ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine int ,data []byte ,decode []float64 )(_a .Color ,error ){switch bitsPerColor {case 1:return ColorAtGray1BPC (x ,y ,bytesPerLine ,data ,decode );case 2:return ColorAtGray2BPC (x ,y ,bytesPerLine ,data ,decode );case 4:return ColorAtGray4BPC (x ,y ,bytesPerLine ,data ,decode );case 8:return ColorAtGray8BPC (x ,y ,bytesPerLine ,data ,decode );case 16:return ColorAtGray16BPC (x ,y ,bytesPerLine ,data ,decode );default:return nil ,_ec .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0067\u0072\u0061\u0079\u0020\u0073c\u0061\u006c\u0065\u0020\u0062\u0069\u0074s\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020a\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );};};var _ _gb .Image =&Gray8 {};func (_feac *Gray16 )GrayAt (x ,y int )_a .Gray {_fdf ,_ :=_feac .ColorAt (x ,y );return _a .Gray {Y :uint8 (_fdf .(_a .Gray16 ).Y >>8)};};func (_febb *ImageBase )Pix ()[]byte {return _febb .Data };func (_fdg *Monochrome )ColorModel ()_a .Model {return MonochromeModel (_fdg .ModelThreshold )};func (_ebec *Gray4 )Bounds ()_gb .Rectangle {return _gb .Rectangle {Max :_gb .Point {X :_ebec .Width ,Y :_ebec .Height }};};func _cdcb (_bcc CMYK ,_fbgb Gray ,_acdd _gb .Rectangle ){for _ccef :=0;_ccef < _acdd .Max .X ;_ccef ++{for _cdee :=0;_cdee < _acdd .Max .Y ;_cdee ++{_aefg :=_cea (_bcc .CMYKAt (_ccef ,_cdee ));_fbgb .SetGray (_ccef ,_cdee ,_aefg );};};};func _fggg (_ffga _gb .Image ,_cge Image ,_ggfec _gb .Rectangle ){if _gade ,_ddcd :=_ffga .(SMasker );_ddcd &&_gade .HasAlpha (){_cge .(SMasker ).MakeAlpha ();};switch _gag :=_ffga .(type ){case Gray :_ceeb (_gag ,_cge .(NRGBA ),_ggfec );case NRGBA :_bbgg (_gag ,_cge .(NRGBA ),_ggfec );case *_gb .NYCbCrA :_aaag (_gag ,_cge .(NRGBA ),_ggfec );case CMYK :_dfag (_gag ,_cge .(NRGBA ),_ggfec );case RGBA :_gfe (_gag ,_cge .(NRGBA ),_ggfec );case nrgba64 :_fda (_gag ,_cge .(NRGBA ),_ggfec );default:_bgb (_ffga ,_cge ,_ggfec );};};func _geef (_fg _a .NYCbCrA )_a .NRGBA {_ffeb :=int32 (_fg .Y )*0x10101;_da :=int32 (_fg .Cb )-128;_bad :=int32 (_fg .Cr )-128;_ffb :=_ffeb +91881*_bad ;if uint32 (_ffb )&0xff000000==0{_ffb >>=8;}else {_ffb =^(_ffb >>31)&0xffff;};_ffcb :=_ffeb -22554*_da -46802*_bad ;if uint32 (_ffcb )&0xff000000==0{_ffcb >>=8;}else {_ffcb =^(_ffcb >>31)&0xffff;};_adc :=_ffeb +116130*_da ;if uint32 (_adc )&0xff000000==0{_adc >>=8;}else {_adc =^(_adc >>31)&0xffff;};return _a .NRGBA {R :uint8 (_ffb >>8),G :uint8 (_ffcb >>8),B :uint8 (_adc >>8),A :_fg .A };};func (_dca *Gray16 )SetGray (x ,y int ,g _a .Gray ){_bbf :=(y *_dca .BytesPerLine /2+x )*2;if _bbf +1>=len (_dca .Data ){return ;};_dca .Data [_bbf ]=g .Y ;_dca .Data [_bbf +1]=g .Y ;};func _ccdf (_edfc *_gb .Gray )bool {for _abea :=0;_abea < len (_edfc .Pix );_abea ++{if !_cgaa (_edfc .Pix [_abea ]){return false ;};};return true ;};func (_abadb *ImageBase )HasAlpha ()bool {if _abadb .Alpha ==nil {return false ;};for _bac :=range _abadb .Alpha {if _abadb .Alpha [_bac ]!=0xff{return true ;};};return false ;};func (_abad *Gray2 )ColorAt (x ,y int )(_a .Color ,error ){return ColorAtGray2BPC (x ,y ,_abad .BytesPerLine ,_abad .Data ,_abad .Decode );};type Gray16 struct{ImageBase };func _fbed (_gcdg _gb .Image ,_aecf Image ,_fdef _gb .Rectangle ){if _aefa ,_afdf :=_gcdg .(SMasker );_afdf &&_aefa .HasAlpha (){_aecf .(SMasker ).MakeAlpha ();};_bgb (_gcdg ,_aecf ,_fdef );};type nrgba64 interface{NRGBA64At (_bbgf ,_ddbf int )_a .NRGBA64 ;SetNRGBA64 (_cff ,_dfe int ,_fgff _a .NRGBA64 );};type CMYK interface{CMYKAt (_f ,_ab int )_a .CMYK ;SetCMYK (_b ,_c int ,_de _a .CMYK );};func _gfe (_edfdb RGBA ,_edec NRGBA ,_abdd _gb .Rectangle ){for _ecae :=0;_ecae < _abdd .Max .X ;_ecae ++{for _fecc :=0;_fecc < _abdd .Max .Y ;_fecc ++{_febf :=_edfdb .RGBAAt (_ecae ,_fecc );_edec .SetNRGBA (_ecae ,_fecc ,_fac (_febf ));};};};func (_cfa *NRGBA16 )Set (x ,y int ,c _a .Color ){_feeb :=y *_cfa .BytesPerLine +x *3/2;if _feeb +1>=len (_cfa .Data ){return ;};_agbbg :=NRGBA16Model .Convert (c ).(_a .NRGBA );_cfa .setNRGBA (x ,y ,_feeb ,_agbbg );};func _debd (_dbfa int ,_aaff int )error {return _ec .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",_dbfa ,_aaff );};func (_aga *Gray16 )Validate ()error {if len (_aga .Data )!=_aga .Height *_aga .BytesPerLine {return ErrInvalidImage ;};return nil ;};func AutoThresholdTriangle (histogram [256]int )uint8 {var _bdeb ,_bcfd ,_aeb ,_deeb int ;for _fbdc :=0;_fbdc < len (histogram );_fbdc ++{if histogram [_fbdc ]> 0{_bdeb =_fbdc ;break ;};};if _bdeb > 0{_bdeb --;};for _fbgd :=255;_fbgd > 0;_fbgd --{if histogram [_fbgd ]> 0{_deeb =_fbgd ;break ;};};if _deeb < 255{_deeb ++;};for _gdeb :=0;_gdeb < 256;_gdeb ++{if histogram [_gdeb ]> _bcfd {_aeb =_gdeb ;_bcfd =histogram [_gdeb ];};};var _ceab bool ;if (_aeb -_bdeb )< (_deeb -_aeb ){_ceab =true ;var _cgbd int ;_bffg :=255;for _cgbd < _bffg {_dga :=histogram [_cgbd ];histogram [_cgbd ]=histogram [_bffg ];histogram [_bffg ]=_dga ;_cgbd ++;_bffg --;};_bdeb =255-_deeb ;_aeb =255-_aeb ;};if _bdeb ==_aeb {return uint8 (_bdeb );};_aaeg :=float64 (histogram [_aeb ]);_ffbg :=float64 (_bdeb -_aeb );_bfeg :=_ge .Sqrt (_aaeg *_aaeg +_ffbg *_ffbg );_aaeg /=_bfeg ;_ffbg /=_bfeg ;_bfeg =_aaeg *float64 (_bdeb )+_ffbg *float64 (histogram [_bdeb ]);_bcee :=_bdeb ;var _degf float64 ;for _ccd :=_bdeb +1;_ccd <=_aeb ;_ccd ++{_cfbg :=_aaeg *float64 (_ccd )+_ffbg *float64 (histogram [_ccd ])-_bfeg ;if _cfbg > _degf {_bcee =_ccd ;_degf =_cfbg ;};};_bcee --;if _ceab {var _cafa int ;_fbfe :=255;for _cafa < _fbfe {_fagb :=histogram [_cafa ];histogram [_cafa ]=histogram [_fbfe ];histogram [_fbfe ]=_fagb ;_cafa ++;_fbfe --;};return uint8 (255-_bcee );};return uint8 (_bcee );};func (_caa *Gray4 )setGray (_ccg int ,_adad int ,_cdg _a .Gray ){_cfd :=_adad *_caa .BytesPerLine ;_geec :=_cfd +(_ccg >>1);if _geec >=len (_caa .Data ){return ;};_agc :=_cdg .Y >>4;_caa .Data [_geec ]=(_caa .Data [_geec ]&(^(0xf0>>uint (4*(_ccg &1)))))|(_agc <<uint (4-4*(_ccg &1)));};var _ Gray =&Gray2 {};func (_bc *CMYK32 )Validate ()error {if len (_bc .Data )!=4*_bc .Width *_bc .Height {return _g .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");};return nil ;};func _gac (_cefb _gb .Image )(Image ,error ){if _gfc ,_feb :=_cefb .(*Gray2 );_feb {return _gfc .Copy (),nil ;};_fbb :=_cefb .Bounds ();_abda ,_fff :=NewImage (_fbb .Max .X ,_fbb .Max .Y ,2,1,nil ,nil ,nil );if _fff !=nil {return nil ,_fff ;};_fdde (_cefb ,_abda ,_fbb );return _abda ,nil ;};func _cgaa (_befd uint8 )bool {if _befd ==0||_befd ==255{return true ;};return false ;};var (Gray2Model =_a .ModelFunc (_fgf );Gray4Model =_a .ModelFunc (_bfa );NRGBA16Model =_a .ModelFunc (_gbe ););func (_dacg *NRGBA32 )NRGBAAt (x ,y int )_a .NRGBA {_dbfc ,_ :=ColorAtNRGBA32 (x ,y ,_dacg .Width ,_dacg .Data ,_dacg .Alpha ,_dacg .Decode );return _dbfc ;};func _fced (_ffbfc _gb .Image ,_eceaf uint8 )*_gb .Gray {_aefb :=_ffbfc .Bounds ();_fbgfb :=_gb .NewGray (_aefb );var (_dbfg _a .Color ;_gdaeg _a .Gray ;);for _febd :=0;_febd < _aefb .Max .X ;_febd ++{for _abaa :=0;_abaa < _aefb .Max .Y ;_abaa ++{_dbfg =_ffbfc .At (_febd ,_abaa );_fbgfb .Set (_febd ,_abaa ,_dbfg );_gdaeg =_fbgfb .GrayAt (_febd ,_abaa );_fbgfb .SetGray (_febd ,_abaa ,_a .Gray {Y :_cdd (_gdaeg .Y ,_eceaf )});};};return _fbgfb ;};func ColorAtCMYK (x ,y ,width int ,data []byte ,decode []float64 )(_a .CMYK ,error ){_def :=4*(y *width +x );if _def +3>=len (data ){return _a .CMYK {},_ec .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};C :=data [_def ]&0xff;M :=data [_def +1]&0xff;Y :=data [_def +2]&0xff;K :=data [_def +3]&0xff;if len (decode )==8{C =uint8 (uint32 (LinearInterpolate (float64 (C ),0,255,decode [0],decode [1]))&0xff);M =uint8 (uint32 (LinearInterpolate (float64 (M ),0,255,decode [2],decode [3]))&0xff);Y =uint8 (uint32 (LinearInterpolate (float64 (Y ),0,255,decode [4],decode [5]))&0xff);K =uint8 (uint32 (LinearInterpolate (float64 (K ),0,255,decode [6],decode [7]))&0xff);};return _a .CMYK {C :C ,M :M ,Y :Y ,K :K },nil ;};func NewImage (width ,height ,bitsPerComponent ,colorComponents int ,data ,alpha []byte ,decode []float64 )(Image ,error ){_gfga :=NewImageBase (width ,height ,bitsPerComponent ,colorComponents ,data ,alpha ,decode );var _abff Image ;switch colorComponents {case 1:switch bitsPerComponent {case 1:_abff =&Monochrome {ImageBase :_gfga ,ModelThreshold :0x0f};case 2:_abff =&Gray2 {ImageBase :_gfga };case 4:_abff =&Gray4 {ImageBase :_gfga };case 8:_abff =&Gray8 {ImageBase :_gfga };case 16:_abff =&Gray16 {ImageBase :_gfga };};case 3:switch bitsPerComponent {case 4:_abff =&NRGBA16 {ImageBase :_gfga };case 8:_abff =&NRGBA32 {ImageBase :_gfga };case 16:_abff =&NRGBA64 {ImageBase :_gfga };};case 4:_abff =&CMYK32 {ImageBase :_gfga };};if _abff ==nil {return nil ,ErrInvalidImage ;};return _abff ,nil ;};var _ Gray =&Monochrome {};func (_ffebc *Gray16 )At (x ,y int )_a .Color {_fddc ,_ :=_ffebc .ColorAt (x ,y );return _fddc };func (_fbc *Gray4 )SetGray (x ,y int ,g _a .Gray ){if x >=_fbc .Width ||y >=_fbc .Height {return ;};g =_becb (g );_fbc .setGray (x ,y ,g );};func (_afa *NRGBA16 )NRGBAAt (x ,y int )_a .NRGBA {_faa ,_ :=ColorAtNRGBA16 (x ,y ,_afa .Width ,_afa .BytesPerLine ,_afa .Data ,_afa .Alpha ,_afa .Decode );return _faa ;};func MonochromeThresholdConverter (threshold uint8 )ColorConverter {return &monochromeThresholdConverter {Threshold :threshold };};func (_ac *CMYK32 )CMYKAt (x ,y int )_a .CMYK {_gg ,_ :=ColorAtCMYK (x ,y ,_ac .Width ,_ac .Data ,_ac .Decode );return _gg ;};func (_fgc *NRGBA64 )ColorModel ()_a .Model {return _a .NRGBA64Model };func (_bcb *Gray16 )Base ()*ImageBase {return &_bcb .ImageBase };func _cdd (_ccgfc ,_gbca uint8 )uint8 {if _ccgfc < _gbca {return 255;};return 0;};var _ Gray =&Gray4 {};func (_geggf *ImageBase )newAlpha (){_degc :=BytesPerLine (_geggf .Width ,_geggf .BitsPerComponent ,1);_geggf .Alpha =make ([]byte ,_geggf .Height *_degc );};func (_aea *NRGBA32 )setRGBA (_dcdfb int ,_bbec _a .NRGBA ){_ecea :=3*_dcdfb ;_aea .Data [_ecea ]=_bbec .R ;_aea .Data [_ecea +1]=_bbec .G ;_aea .Data [_ecea +2]=_bbec .B ;if _dcdfb < len (_aea .Alpha ){_aea .Alpha [_dcdfb ]=_bbec .A ;};};func _bead (_gada *_gb .Gray16 ,_gfde uint8 )*_gb .Gray {_abfc :=_gada .Bounds ();_ebgf :=_gb .NewGray (_abfc );for _adeg :=0;_adeg < _abfc .Dx ();_adeg ++{for _aagf :=0;_aagf < _abfc .Dy ();_aagf ++{_feda :=_gada .Gray16At (_adeg ,_aagf );_ebgf .SetGray (_adeg ,_aagf ,_a .Gray {Y :_cdd (uint8 (_feda .Y /256),_gfde )});};};return _ebgf ;};func ColorAtGray2BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_a .Gray ,error ){_adb :=y *bytesPerLine +x >>2;if _adb >=len (data ){return _a .Gray {},_ec .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_bbc :=data [_adb ]>>uint (6-(x &3)*2)&3;if len (decode )==2{_bbc =uint8 (uint32 (LinearInterpolate (float64 (_bbc ),0,3.0,decode [0],decode [1]))&3);};return _a .Gray {Y :_bbc *85},nil ;};func (_geb *NRGBA64 )Base ()*ImageBase {return &_geb .ImageBase };func LinearInterpolate (x ,xmin ,xmax ,ymin ,ymax float64 )float64 {if _ge .Abs (xmax -xmin )< 0.000001{return ymin ;};_degcd :=ymin +(x -xmin )*(ymax -ymin )/(xmax -xmin );return _degcd ;};func (_fbd *NRGBA64 )Set (x ,y int ,c _a .Color ){_gfca :=(y *_fbd .Width +x )*2;_ddf :=_gfca *3;if _ddf +5>=len (_fbd .Data ){return ;};_bbb :=_a .NRGBA64Model .Convert (c ).(_a .NRGBA64 );_fbd .setNRGBA64 (_ddf ,_bbb ,_gfca );};func _eca (_gdbc ,_fggfb Gray ,_aaa _gb .Rectangle ){for _ffae :=0;_ffae < _aaa .Max .X ;_ffae ++{for _aefd :=0;_aefd < _aaa .Max .Y ;_aefd ++{_fggfb .SetGray (_ffae ,_aefd ,_gdbc .GrayAt (_ffae ,_aefd ));};};};func _ada (_feg _a .NRGBA )_a .CMYK {_ceb ,_gge ,_gged ,_ :=_feg .RGBA ();_ffab ,_edf ,_ffe ,_cbd :=_a .RGBToCMYK (uint8 (_ceb >>8),uint8 (_gge >>8),uint8 (_gged >>8));return _a .CMYK {C :_ffab ,M :_edf ,Y :_ffe ,K :_cbd };};func (_afbd *Gray2 )Set (x ,y int ,c _a .Color ){if x >=_afbd .Width ||y >=_afbd .Height {return ;};_bba :=Gray2Model .Convert (c ).(_a .Gray );_ggfd :=y *_afbd .BytesPerLine ;_gadb :=_ggfd +(x >>2);_dbe :=_bba .Y >>6;_afbd .Data [_gadb ]=(_afbd .Data [_gadb ]&(^(0xc0>>uint (2*((x )&3)))))|(_dbe <<uint (6-2*(x &3)));};func _fgf (_aefe _a .Color )_a .Color {_ccf :=_a .GrayModel .Convert (_aefe ).(_a .Gray );return _afee (_ccf )};var _ Image =&CMYK32 {};func (_fce *Gray2 )At (x ,y int )_a .Color {_fca ,_ :=_fce .ColorAt (x ,y );return _fca };type Monochrome struct{ImageBase ;ModelThreshold uint8 ;};func _dcdf (_fbcd _a .NRGBA )_a .NRGBA {_fbcd .R =_fbcd .R >>4|(_fbcd .R >>4)<<4;_fbcd .G =_fbcd .G >>4|(_fbcd .G >>4)<<4;_fbcd .B =_fbcd .B >>4|(_fbcd .B >>4)<<4;return _fbcd ;};func _eab (_be _a .Gray )_a .NRGBA {return _a .NRGBA {R :_be .Y ,G :_be .Y ,B :_be .Y ,A :0xff}};func _dd (_bed _gb .Image )(Image ,error ){if _gfb ,_dg :=_bed .(*Monochrome );_dg {return _gfb ,nil ;};_abb ,_dfd :=_bed .(Gray );if !_dfd {_gggg ,_bec :=GrayConverter .Convert (_bed );if _bec !=nil {return nil ,_bec ;};_abb =_gggg .(Gray );};_acf :=_bed .Bounds ();_gad ,_bca :=NewImage (_acf .Max .X ,_acf .Max .Y ,1,1,nil ,nil ,nil );if _bca !=nil {return nil ,_bca ;};_gce :=_gad .(*Monochrome );_ecb :=AutoThresholdTriangle (GrayHistogram (_abb ));for _fdd :=0;_fdd < _acf .Max .X ;_fdd ++{for _agdg :=0;_agdg < _acf .Max .Y ;_agdg ++{_ebf :=_bf (_abb .GrayAt (_fdd ,_agdg ),monochromeModel (_ecb ));_gce .SetGray (_fdd ,_agdg ,_ebf );};};return _gad ,nil ;};type Gray2 struct{ImageBase };func (_dbfe *NRGBA16 )Bounds ()_gb .Rectangle {return _gb .Rectangle {Max :_gb .Point {X :_dbfe .Width ,Y :_dbfe .Height }};};func (_dfc *NRGBA64 )SetNRGBA64 (x ,y int ,c _a .NRGBA64 ){_gebg :=(y *_dfc .Width +x )*2;_ffgd :=_gebg *3;if _ffgd +5>=len (_dfc .Data ){return ;};_dfc .setNRGBA64 (_ffgd ,c ,_gebg );};func _dbcd (_ccee _gb .Image ,_afbg int )(_gb .Rectangle ,bool ,[]byte ){_ceda :=_ccee .Bounds ();var (_gbf bool ;_dgd []byte ;);switch _dabb :=_ccee .(type ){case SMasker :_gbf =_dabb .HasAlpha ();case NRGBA ,RGBA ,*_gb .RGBA64 ,nrgba64 ,*_gb .NYCbCrA :_dgd =make ([]byte ,_ceda .Max .X *_ceda .Max .Y *_afbg );};return _ceda ,_gbf ,_dgd ;};func (_bb *CMYK32 )At (x ,y int )_a .Color {_dc ,_ :=_bb .ColorAt (x ,y );return _dc };func (_bbdc *NRGBA16 )ColorModel ()_a .Model {return NRGBA16Model };var _ _gb .Image =&Monochrome {};func ColorAtGray16BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_a .Gray16 ,error ){_ggeb :=(y *bytesPerLine /2+x )*2;if _ggeb +1>=len (data ){return _a .Gray16 {},_ec .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_abaf :=uint16 (data [_ggeb ])<<8|uint16 (data [_ggeb +1]);if len (decode )==2{_abaf =uint16 (uint64 (LinearInterpolate (float64 (_abaf ),0,65535,decode [0],decode [1])));};return _a .Gray16 {Y :_abaf },nil ;};func ColorAtGray8BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_a .Gray ,error ){_dcbe :=y *bytesPerLine +x ;if _dcbe >=len (data ){return _a .Gray {},_ec .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_gbgc :=data [_dcbe ];if len (decode )==2{_gbgc =uint8 (uint32 (LinearInterpolate (float64 (_gbgc ),0,255,decode [0],decode [1]))&0xff);};return _a .Gray {Y :_gbgc },nil ;};func _adab (_efe _a .NRGBA64 )_a .NRGBA {return _a .NRGBA {R :uint8 (_efe .R >>8),G :uint8 (_efe .G >>8),B :uint8 (_efe .B >>8),A :uint8 (_efe .A >>8)};};func (_ggef *Gray8 )At (x ,y int )_a .Color {_bfag ,_ :=_ggef .ColorAt (x ,y );return _bfag };func _dag (_ege _gb .Image )(Image ,error ){if _deb ,_ceee :=_ege .(*Gray8 );_ceee {return _deb .Copy (),nil ;};_caaf :=_ege .Bounds ();_deg ,_ddc :=NewImage (_caaf .Max .X ,_caaf .Max .Y ,8,1,nil ,nil ,nil );if _ddc !=nil {return nil ,_ddc ;};_fdde (_ege ,_deg ,_caaf );return _deg ,nil ;};func (_dded *NRGBA32 )ColorModel ()_a .Model {return _a .NRGBAModel };func (_ccba *Gray2 )ColorModel ()_a .Model {return Gray2Model };var _ NRGBA =&NRGBA32 {};func ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor int ,data ,alpha []byte ,decode []float64 )(_a .Color ,error ){switch bitsPerColor {case 4:return ColorAtNRGBA16 (x ,y ,width ,bytesPerLine ,data ,alpha ,decode );case 8:return ColorAtNRGBA32 (x ,y ,width ,data ,alpha ,decode );case 16:return ColorAtNRGBA64 (x ,y ,width ,data ,alpha ,decode );default:return nil ,_ec .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0067\u0062\u0020b\u0069\u0074\u0073\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0061\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );};};func _bacc (_fegf _gb .Image )(Image ,error ){if _gaddc ,_aff :=_fegf .(*NRGBA64 );_aff {return _gaddc .Copy (),nil ;};_aae ,_fddf ,_dgde :=_dbcd (_fegf ,2);_daeb ,_aaga :=NewImage (_aae .Max .X ,_aae .Max .Y ,16,3,nil ,_dgde ,nil );if _aaga !=nil {return nil ,_aaga ;};_fbed (_fegf ,_daeb ,_aae );if len (_dgde )!=0&&!_fddf {if _cgd :=_deaa (_dgde ,_daeb );_cgd !=nil {return nil ,_cgd ;};};return _daeb ,nil ;};func (_gdb *Gray2 )SetGray (x ,y int ,gray _a .Gray ){_ecc :=_afee (gray );_ffba :=y *_gdb .BytesPerLine ;_cfb :=_ffba +(x >>2);if _cfb >=len (_gdb .Data ){return ;};_ggea :=_ecc .Y >>6;_gdb .Data [_cfb ]=(_gdb .Data [_cfb ]&(^(0xc0>>uint (2*((x )&3)))))|(_ggea <<uint (6-2*(x &3)));};var _ NRGBA =&NRGBA16 {};func (_dcd *ImageBase )GetAlpha ()[]byte {return _dcd .Alpha };var (MonochromeConverter =ConverterFunc (_dd );Gray2Converter =ConverterFunc (_gac );Gray4Converter =ConverterFunc (_edef );GrayConverter =ConverterFunc (_dag );Gray16Converter =ConverterFunc (_bcag );NRGBA16Converter =ConverterFunc (_badc );NRGBAConverter =ConverterFunc (_cegb );NRGBA64Converter =ConverterFunc (_bacc );CMYKConverter =ConverterFunc (_dee ););func _gbe (_fdb _a .Color )_a .Color {_cga :=_a .NRGBAModel .Convert (_fdb ).(_a .NRGBA );return _dcdf (_cga )};func (_fggf *Gray4 )Set (x ,y int ,c _a .Color ){if x >=_fggf .Width ||y >=_fggf .Height {return ;};_dbac :=Gray4Model .Convert (c ).(_a .Gray );_fggf .setGray (x ,y ,_dbac );};func (_afda *Monochrome )Base ()*ImageBase {return &_afda .ImageBase };func ColorAtNRGBA16 (x ,y ,width ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_a .NRGBA ,error ){_debge :=y *bytesPerLine +x *3/2;if _debge +1>=len (data ){return _a .NRGBA {},_debd (x ,y );};const (_ace =0xf;_ecbfe =uint8 (0xff););_bagcd :=_ecbfe ;if alpha !=nil {_gedd :=y *BytesPerLine (width ,4,1);if _gedd < len (alpha ){if x %2==0{_bagcd =(alpha [_gedd ]>>uint (4))&_ace ;}else {_bagcd =alpha [_gedd ]&_ace ;};_bagcd |=_bagcd <<4;};};var _acca ,_cbcg ,_fad uint8 ;if x *3%2==0{_acca =(data [_debge ]>>uint (4))&_ace ;_cbcg =data [_debge ]&_ace ;_fad =(data [_debge +1]>>uint (4))&_ace ;}else {_acca =data [_debge ]&_ace ;_cbcg =(data [_debge +1]>>uint (4))&_ace ;_fad =data [_debge +1]&_ace ;};if len (decode )==6{_acca =uint8 (uint32 (LinearInterpolate (float64 (_acca ),0,15,decode [0],decode [1]))&0xf);_cbcg =uint8 (uint32 (LinearInterpolate (float64 (_cbcg ),0,15,decode [2],decode [3]))&0xf);_fad =uint8 (uint32 (LinearInterpolate (float64 (_fad ),0,15,decode [4],decode [5]))&0xf);};return _a .NRGBA {R :(_acca <<4)|(_acca &0xf),G :(_cbcg <<4)|(_cbcg &0xf),B :(_fad <<4)|(_fad &0xf),A :_bagcd },nil ;};func (_fefe *Monochrome )SetGray (x ,y int ,g _a .Gray ){_aee :=y *_fefe .BytesPerLine +x >>3;if _aee > len (_fefe .Data )-1{return ;};g =_bf (g ,monochromeModel (_fefe .ModelThreshold ));_fefe .setGray (x ,g ,_aee );};func (_face *ImageBase )MakeAlpha (){_face .newAlpha ()};type ColorConverter interface{Convert (_ea _gb .Image )(Image ,error );};func (_ddg *Gray4 )Base ()*ImageBase {return &_ddg .ImageBase };func (_fc *CMYK32 )Base ()*ImageBase {return &_fc .ImageBase };func (_abbee *Gray4 )Histogram ()(_efed [256]int ){for _abc :=0;_abc < _abbee .Width ;_abc ++{for _gbd :=0;_gbd < _abbee .Height ;_gbd ++{_efed [_abbee .GrayAt (_abc ,_gbd ).Y ]++;};};return _efed ;};func (_efc *Gray4 )ColorAt (x ,y int )(_a .Color ,error ){return ColorAtGray4BPC (x ,y ,_efc .BytesPerLine ,_efc .Data ,_efc .Decode );};func (_gdda *Monochrome )Set (x ,y int ,c _a .Color ){_gcc :=y *_gdda .BytesPerLine +x >>3;if _gcc > len (_gdda .Data )-1{return ;};_fgg :=_gdda .ColorModel ().Convert (c ).(_a .Gray );_gdda .setGray (x ,_fgg ,_gcc );};func (_bfb *Monochrome )clearBit (_acfa ,_agb int ){_bfb .Data [_acfa ]&=^(0x80>>uint (_agb &7))};func (_ggede *NRGBA16 )Validate ()error {if len (_ggede .Data )!=3*_ggede .Width *_ggede .Height /2{return _g .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");};return nil ;};func ImgToGray (i _gb .Image )*_gb .Gray {if _bccg ,_fdff :=i .(*_gb .Gray );_fdff {return _bccg ;};_ceec :=i .Bounds ();_cbb :=_gb .NewGray (_ceec );for _cefa :=0;_cefa < _ceec .Max .X ;_cefa ++{for _ffcd :=0;_ffcd < _ceec .Max .Y ;_ffcd ++{_bcga :=i .At (_cefa ,_ffcd );_cbb .Set (_cefa ,_ffcd ,_bcga );};};return _cbb ;};func (_fag *Monochrome )setBit (_ade ,_decc int ){_fag .Data [_ade ]|=0x80>>uint (_decc &7)};func (_fcd *NRGBA64 )Bounds ()_gb .Rectangle {return _gb .Rectangle {Max :_gb .Point {X :_fcd .Width ,Y :_fcd .Height }};};func (_cfc *Monochrome )At (x ,y int )_a .Color {_aef ,_ :=_cfc .ColorAt (x ,y );return _aef };func _cbe (_afd RGBA ,_adf CMYK ,_acag _gb .Rectangle ){for _ced :=0;_ced < _acag .Max .X ;_ced ++{for _gc :=0;_gc < _acag .Max .Y ;_gc ++{_fbg :=_afd .RGBAAt (_ced ,_gc );_adf .SetCMYK (_ced ,_gc ,_acbf (_fbg ));};};};func (_dacc *Monochrome )Bounds ()_gb .Rectangle {return _gb .Rectangle {Max :_gb .Point {X :_dacc .Width ,Y :_dacc .Height }};};func (_gee *CMYK32 )ColorAt (x ,y int )(_a .Color ,error ){return ColorAtCMYK (x ,y ,_gee .Width ,_gee .Data ,_gee .Decode );};func (_eff *Gray16 )Copy ()Image {return &Gray16 {ImageBase :_eff .copy ()}};func (_aaf *Gray2 )Copy ()Image {return &Gray2 {ImageBase :_aaf .copy ()}};type Gray interface{GrayAt (_fefg ,_eabe int )_a .Gray ;SetGray (_bagc ,_gead int ,_afe _a .Gray );};func (_fed *Gray8 )Set (x ,y int ,c _a .Color ){_abca :=y *_fed .BytesPerLine +x ;if _abca > len (_fed .Data )-1{return ;};_abac :=_a .GrayModel .Convert (c );_fed .Data [_abca ]=_abac .(_a .Gray ).Y ;};func _dee (_gbc _gb .Image )(Image ,error ){if _eed ,_gea :=_gbc .(*CMYK32 );_gea {return _eed .Copy (),nil ;};_fb :=_gbc .Bounds ();_geae ,_abf :=NewImage (_fb .Max .X ,_fb .Max .Y ,8,4,nil ,nil ,nil );if _abf !=nil {return nil ,_abf ;};switch _geg :=_gbc .(type ){case CMYK :_bgf (_geg ,_geae .(CMYK ),_fb );case Gray :_aba (_geg ,_geae .(CMYK ),_fb );case NRGBA :_gf (_geg ,_geae .(CMYK ),_fb );case RGBA :_cbe (_geg ,_geae .(CMYK ),_fb );default:_bgb (_gbc ,_geae ,_fb );};return _geae ,nil ;};