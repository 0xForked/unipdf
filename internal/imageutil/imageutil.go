//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package imageutil ;import (_d "errors";_fc "fmt";_db "github.com/unidoc/unipdf/v3/internal/bitwise";_fd "image";_g "image/color";_fb "image/draw";_f "math";);func _fac (_aab _g .RGBA )_g .Gray {_ccf :=(19595*uint32 (_aab .R )+38470*uint32 (_aab .G )+7471*uint32 (_aab .B )+1<<7)>>16;return _g .Gray {Y :uint8 (_ccf )};};func ImgToBinary (i _fd .Image ,threshold uint8 )*_fd .Gray {switch _afde :=i .(type ){case *_fd .Gray :if _ccd (_afde ){return _afde ;};return _agf (_afde ,threshold );case *_fd .Gray16 :return _aecd (_afde ,threshold );default:return _ffac (_afde ,threshold );};};func ColorAt (x ,y ,width ,bitsPerColor ,colorComponents ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_g .Color ,error ){switch colorComponents {case 1:return ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine ,data ,decode );case 3:return ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor ,data ,alpha ,decode );case 4:return ColorAtCMYK (x ,y ,width ,data ,decode );default:return nil ,_fc .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0063o\u006c\u006f\u0072\u0020\u0063\u006f\u006dp\u006f\u006e\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0064",colorComponents );};};func (_dbd *Gray8 )At (x ,y int )_g .Color {_dcfe ,_ :=_dbd .ColorAt (x ,y );return _dcfe };func (_aed *Monochrome )GrayAt (x ,y int )_g .Gray {_bea ,_ :=ColorAtGray1BPC (x ,y ,_aed .BytesPerLine ,_aed .Data ,_aed .Decode );return _bea ;};type Image interface{_fb .Image ;Base ()*ImageBase ;Copy ()Image ;Pix ()[]byte ;ColorAt (_dfcb ,_fgb int )(_g .Color ,error );Validate ()error ;};func (_bfd *Gray2 )Set (x ,y int ,c _g .Color ){if x >=_bfd .Width ||y >=_bfd .Height {return ;};_cfa :=Gray2Model .Convert (c ).(_g .Gray );_deeg :=y *_bfd .BytesPerLine ;_age :=_deeg +(x >>2);_bba :=_cfa .Y >>6;_bfd .Data [_age ]=(_bfd .Data [_age ]&(^(0xc0>>uint (2*((x )&3)))))|(_bba <<uint (6-2*(x &3)));};func (_bfda *ImageBase )HasAlpha ()bool {if _bfda .Alpha ==nil {return false ;};for _dcba :=range _bfda .Alpha {if _bfda .Alpha [_dcba ]!=0xff{return true ;};};return false ;};func (_effgg *Gray2 )Base ()*ImageBase {return &_effgg .ImageBase };func _eda (_adaf _g .Gray ,_ecc monochromeModel )_g .Gray {if _adaf .Y > uint8 (_ecc ){return _g .Gray {Y :_f .MaxUint8 };};return _g .Gray {};};func (_edcd *NRGBA32 )Copy ()Image {return &NRGBA32 {ImageBase :_edcd .copy ()}};func (_cd *CMYK32 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtCMYK (x ,y ,_cd .Width ,_cd .Data ,_cd .Decode );};func BytesPerLine (width ,bitsPerComponent ,colorComponents int )int {return ((width *bitsPerComponent )*colorComponents +7)>>3;};var _ _fd .Image =&Monochrome {};func (_bbfd *Monochrome )Validate ()error {if len (_bbfd .Data )!=_bbfd .Height *_bbfd .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_ccfb *Gray4 )Validate ()error {if len (_ccfb .Data )!=_ccfb .Height *_ccfb .BytesPerLine {return ErrInvalidImage ;};return nil ;};type CMYK interface{CMYKAt (_gd ,_e int )_g .CMYK ;SetCMYK (_c ,_cg int ,_dc _g .CMYK );};func (_eedf *NRGBA16 )SetNRGBA (x ,y int ,c _g .NRGBA ){_cgdb :=y *_eedf .BytesPerLine +x *3/2;if _cgdb +1>=len (_eedf .Data ){return ;};c =_fbdg (c );_eedf .setNRGBA (x ,y ,_cgdb ,c );};func (_ddb *NRGBA32 )At (x ,y int )_g .Color {_ggbb ,_ :=_ddb .ColorAt (x ,y );return _ggbb };func ColorAtNRGBA64 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_g .NRGBA64 ,error ){_gbfa :=(y *width +x )*2;_bfa :=_gbfa *3;if _bfa +5>=len (data ){return _g .NRGBA64 {},_fc .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};const _bfac =0xffff;_fgbc :=uint16 (_bfac );if alpha !=nil &&len (alpha )> _gbfa +1{_fgbc =uint16 (alpha [_gbfa ])<<8|uint16 (alpha [_gbfa +1]);};_acfdb :=uint16 (data [_bfa ])<<8|uint16 (data [_bfa +1]);_cfca :=uint16 (data [_bfa +2])<<8|uint16 (data [_bfa +3]);_ccfc :=uint16 (data [_bfa +4])<<8|uint16 (data [_bfa +5]);if len (decode )==6{_acfdb =uint16 (uint64 (LinearInterpolate (float64 (_acfdb ),0,65535,decode [0],decode [1]))&_bfac );_cfca =uint16 (uint64 (LinearInterpolate (float64 (_cfca ),0,65535,decode [2],decode [3]))&_bfac );_ccfc =uint16 (uint64 (LinearInterpolate (float64 (_ccfc ),0,65535,decode [4],decode [5]))&_bfac );};return _g .NRGBA64 {R :_acfdb ,G :_cfca ,B :_ccfc ,A :_fgbc },nil ;};type Gray4 struct{ImageBase };var _ _fd .Image =&Gray2 {};func _cdg (_aec _g .RGBA )_g .NRGBA {switch _aec .A {case 0xff:return _g .NRGBA {R :_aec .R ,G :_aec .G ,B :_aec .B ,A :0xff};case 0x00:return _g .NRGBA {};default:_fca ,_ceec ,_cead ,_fgcg :=_aec .RGBA ();_fca =(_fca *0xffff)/_fgcg ;_ceec =(_ceec *0xffff)/_fgcg ;_cead =(_cead *0xffff)/_fgcg ;return _g .NRGBA {R :uint8 (_fca >>8),G :uint8 (_ceec >>8),B :uint8 (_cead >>8),A :uint8 (_fgcg >>8)};};};func (_bdcg *ImageBase )copy ()ImageBase {_afa :=*_bdcg ;_afa .Data =make ([]byte ,len (_bdcg .Data ));copy (_afa .Data ,_bdcg .Data );return _afa ;};func (_aea *Gray16 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtGray16BPC (x ,y ,_aea .BytesPerLine ,_aea .Data ,_aea .Decode );};func (_ggf *Gray4 )At (x ,y int )_g .Color {_aedd ,_ :=_ggf .ColorAt (x ,y );return _aedd };func (_eaaa *NRGBA16 )At (x ,y int )_g .Color {_gff ,_ :=_eaaa .ColorAt (x ,y );return _gff };func (_fcc *Gray4 )SetGray (x ,y int ,g _g .Gray ){if x >=_fcc .Width ||y >=_fcc .Height {return ;};g =_cde (g );_fcc .setGray (x ,y ,g );};func (_eed *Gray8 )Base ()*ImageBase {return &_eed .ImageBase };func (_ffab *NRGBA16 )NRGBAAt (x ,y int )_g .NRGBA {_dag ,_ :=ColorAtNRGBA16 (x ,y ,_ffab .Width ,_ffab .BytesPerLine ,_ffab .Data ,_ffab .Alpha ,_ffab .Decode );return _dag ;};var _ Image =&Gray8 {};func _bdf (_afb _g .Gray )_g .CMYK {return _g .CMYK {K :0xff-_afb .Y }};func _dcb (_gab _fd .Image )(Image ,error ){if _aag ,_ff :=_gab .(*Monochrome );_ff {return _aag ,nil ;};_faa ,_ffa :=_gab .(Gray );if !_ffa {_gaa ,_fbf :=GrayConverter .Convert (_gab );if _fbf !=nil {return nil ,_fbf ;};_faa =_gaa .(Gray );};_cdb :=_gab .Bounds ();_aef ,_cab :=NewImage (_cdb .Max .X ,_cdb .Max .Y ,1,1,nil ,nil ,nil );if _cab !=nil {return nil ,_cab ;};_gddc :=_aef .(*Monochrome );_adc :=AutoThresholdTriangle (GrayHistogram (_faa ));for _aaa :=0;_aaa < _cdb .Max .X ;_aaa ++{for _aaf :=0;_aaf < _cdb .Max .Y ;_aaf ++{_fbfb :=_eda (_faa .GrayAt (_aaa ,_aaf ),monochromeModel (_adc ));_gddc .SetGray (_aaa ,_aaf ,_fbfb );};};return _aef ,nil ;};func AddDataPadding (width ,height ,bitsPerComponent ,colorComponents int ,data []byte )([]byte ,error ){_bgg :=BytesPerLine (width ,bitsPerComponent ,colorComponents );if _bgg ==width *colorComponents *bitsPerComponent /8{return data ,nil ;};_gfa :=width *colorComponents *bitsPerComponent ;_adcb :=_bgg *8;_effe :=8-(_adcb -_gfa );_edb :=_db .NewReader (data );_cede :=_bgg -1;_baa :=make ([]byte ,_cede );_cdef :=make ([]byte ,height *_bgg );_eef :=_db .NewWriterMSB (_cdef );var _afea uint64 ;var _cgd error ;for _dbgg :=0;_dbgg < height ;_dbgg ++{_ ,_cgd =_edb .Read (_baa );if _cgd !=nil {return nil ,_cgd ;};_ ,_cgd =_eef .Write (_baa );if _cgd !=nil {return nil ,_cgd ;};_afea ,_cgd =_edb .ReadBits (byte (_effe ));if _cgd !=nil {return nil ,_cgd ;};_ ,_cgd =_eef .WriteBits (_afea ,_effe );if _cgd !=nil {return nil ,_cgd ;};_eef .FinishByte ();};return _cdef ,nil ;};type Histogramer interface{Histogram ()[256]int ;};func _ed (_bc NRGBA ,_fea CMYK ,_fgg _fd .Rectangle ){for _dca :=0;_dca < _fgg .Max .X ;_dca ++{for _cc :=0;_cc < _fgg .Max .Y ;_cc ++{_ae :=_bc .NRGBAAt (_dca ,_cc );_fea .SetCMYK (_dca ,_cc ,_ggb (_ae ));};};};var _ Image =&NRGBA16 {};type Gray8 struct{ImageBase };func MonochromeThresholdConverter (threshold uint8 )ColorConverter {return &monochromeThresholdConverter {Threshold :threshold };};func (_fffd *NRGBA64 )At (x ,y int )_g .Color {_fae ,_ :=_fffd .ColorAt (x ,y );return _fae };func (_eeb *Gray2 )Bounds ()_fd .Rectangle {return _fd .Rectangle {Max :_fd .Point {X :_eeb .Width ,Y :_eeb .Height }};};func init (){_gaaa ()};func (_fe *CMYK32 )Set (x ,y int ,c _g .Color ){_fg :=4*(y *_fe .Width +x );if _fg +3>=len (_fe .Data ){return ;};_bg :=_g .CMYKModel .Convert (c ).(_g .CMYK );_fe .Data [_fg ]=_bg .C ;_fe .Data [_fg +1]=_bg .M ;_fe .Data [_fg +2]=_bg .Y ;_fe .Data [_fg +3]=_bg .K ;};func (_dad *Gray4 )Copy ()Image {return &Gray4 {ImageBase :_dad .copy ()}};func _ebda (_gafa _fd .Image ,_ebbac Image ,_agc _fd .Rectangle ){if _dece ,_eeag :=_gafa .(SMasker );_eeag &&_dece .HasAlpha (){_ebbac .(SMasker ).MakeAlpha ();};switch _cdfg :=_gafa .(type ){case Gray :_acff (_cdfg ,_ebbac .(NRGBA ),_agc );case NRGBA :_egb (_cdfg ,_ebbac .(NRGBA ),_agc );case *_fd .NYCbCrA :_fcfb (_cdfg ,_ebbac .(NRGBA ),_agc );case CMYK :_afg (_cdfg ,_ebbac .(NRGBA ),_agc );case RGBA :_fbccg (_cdfg ,_ebbac .(NRGBA ),_agc );case nrgba64 :_bef (_cdfg ,_ebbac .(NRGBA ),_agc );default:_aff (_gafa ,_ebbac ,_agc );};};func MonochromeModel (threshold uint8 )_g .Model {return monochromeModel (threshold )};func (_dfd *Monochrome )Copy ()Image {return &Monochrome {ImageBase :_dfd .ImageBase .copy (),ModelThreshold :_dfd .ModelThreshold };};var _ Gray =&Gray16 {};func ConverterFunc (converterFunc func (_dgd _fd .Image )(Image ,error ))ColorConverter {return colorConverter {_cfe :converterFunc };};func _fbccg (_ddd RGBA ,_bbe NRGBA ,_cbcc _fd .Rectangle ){for _gbeg :=0;_gbeg < _cbcc .Max .X ;_gbeg ++{for _fcag :=0;_fcag < _cbcc .Max .Y ;_fcag ++{_dgea :=_ddd .RGBAAt (_gbeg ,_fcag );_bbe .SetNRGBA (_gbeg ,_fcag ,_cdg (_dgea ));};};};func (_ceae *Gray4 )Bounds ()_fd .Rectangle {return _fd .Rectangle {Max :_fd .Point {X :_ceae .Width ,Y :_ceae .Height }};};var _ _fd .Image =&Gray8 {};func (_adf *Gray4 )GrayAt (x ,y int )_g .Gray {_fcg ,_ :=ColorAtGray4BPC (x ,y ,_adf .BytesPerLine ,_adf .Data ,_adf .Decode );return _fcg ;};func (_agea *Gray16 )Copy ()Image {return &Gray16 {ImageBase :_agea .copy ()}};func (_dgde *NRGBA16 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtNRGBA16 (x ,y ,_dgde .Width ,_dgde .BytesPerLine ,_dgde .Data ,_dgde .Alpha ,_dgde .Decode );};var (MonochromeConverter =ConverterFunc (_dcb );Gray2Converter =ConverterFunc (_gddg );Gray4Converter =ConverterFunc (_fcga );GrayConverter =ConverterFunc (_feg );Gray16Converter =ConverterFunc (_aafa );NRGBA16Converter =ConverterFunc (_cabc );NRGBAConverter =ConverterFunc (_bagc );NRGBA64Converter =ConverterFunc (_cccb );CMYKConverter =ConverterFunc (_fbd ););var _ Image =&Gray2 {};func (_cdbd *Gray8 )Bounds ()_fd .Rectangle {return _fd .Rectangle {Max :_fd .Point {X :_cdbd .Width ,Y :_cdbd .Height }};};func _agf (_bdbb *_fd .Gray ,_adda uint8 )*_fd .Gray {_bce :=_bdbb .Bounds ();_dcfb :=_fd .NewGray (_bce );for _dga :=0;_dga < _bce .Dx ();_dga ++{for _gggc :=0;_gggc < _bce .Dy ();_gggc ++{_ccff :=_bdbb .GrayAt (_dga ,_gggc );_dcfb .SetGray (_dga ,_gggc ,_g .Gray {Y :_bca (_ccff .Y ,_adda )});};};return _dcfb ;};func (_cefc *Monochrome )Bounds ()_fd .Rectangle {return _fd .Rectangle {Max :_fd .Point {X :_cefc .Width ,Y :_cefc .Height }};};func _ea (_dbbc ,_eg CMYK ,_eba _fd .Rectangle ){for _ada :=0;_ada < _eba .Max .X ;_ada ++{for _ce :=0;_ce < _eba .Max .Y ;_ce ++{_eg .SetCMYK (_ada ,_ce ,_dbbc .CMYKAt (_ada ,_ce ));};};};var _ Gray =&Gray2 {};func (_gca *Gray16 )At (x ,y int )_g .Color {_bdfg ,_ :=_gca .ColorAt (x ,y );return _bdfg };func (_afbad *NRGBA16 )Set (x ,y int ,c _g .Color ){_afaf :=y *_afbad .BytesPerLine +x *3/2;if _afaf +1>=len (_afbad .Data ){return ;};_ddaa :=NRGBA16Model .Convert (c ).(_g .NRGBA );_afbad .setNRGBA (x ,y ,_afaf ,_ddaa );};func (_feba *Gray8 )Histogram ()(_efda [256]int ){for _fefd :=0;_fefd < len (_feba .Data );_fefd ++{_efda [_feba .Data [_fefd ]]++;};return _efda ;};func (_ceb *NRGBA64 )NRGBA64At (x ,y int )_g .NRGBA64 {_bbde ,_ :=ColorAtNRGBA64 (x ,y ,_ceb .Width ,_ceb .Data ,_ceb .Alpha ,_ceb .Decode );return _bbde ;};func ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine int ,data []byte ,decode []float64 )(_g .Color ,error ){switch bitsPerColor {case 1:return ColorAtGray1BPC (x ,y ,bytesPerLine ,data ,decode );case 2:return ColorAtGray2BPC (x ,y ,bytesPerLine ,data ,decode );case 4:return ColorAtGray4BPC (x ,y ,bytesPerLine ,data ,decode );case 8:return ColorAtGray8BPC (x ,y ,bytesPerLine ,data ,decode );case 16:return ColorAtGray16BPC (x ,y ,bytesPerLine ,data ,decode );default:return nil ,_fc .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0067\u0072\u0061\u0079\u0020\u0073c\u0061\u006c\u0065\u0020\u0062\u0069\u0074s\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020a\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );};};func _bb (_ggc _g .CMYK )_g .NRGBA {_fbc ,_cfg ,_fgcc :=_g .CMYKToRGB (_ggc .C ,_ggc .M ,_ggc .Y ,_ggc .K );return _g .NRGBA {R :_fbc ,G :_cfg ,B :_fgcc ,A :0xff};};func (_adde *NRGBA32 )ColorModel ()_g .Model {return _g .NRGBAModel };func (_fag *Monochrome )Histogram ()(_cff [256]int ){for _ ,_eddc :=range _fag .Data {_cff [0xff]+=int (_abg [_fag .Data [_eddc ]]);};return _cff ;};func (_gcec *NRGBA32 )NRGBAAt (x ,y int )_g .NRGBA {_ecca ,_ :=ColorAtNRGBA32 (x ,y ,_gcec .Width ,_gcec .Data ,_gcec .Alpha ,_gcec .Decode );return _ecca ;};func (_dcd *Gray4 )Set (x ,y int ,c _g .Color ){if x >=_dcd .Width ||y >=_dcd .Height {return ;};_cbd :=Gray4Model .Convert (c ).(_g .Gray );_dcd .setGray (x ,y ,_cbd );};type NRGBA64 struct{ImageBase };type monochromeModel uint8 ;func (_dcc *Monochrome )setBit (_gcda ,_aaff int ){_dcc .Data [_gcda ]|=0x80>>uint (_aaff &7)};func ColorAtGray2BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_g .Gray ,error ){_bcc :=y *bytesPerLine +x >>2;if _bcc >=len (data ){return _g .Gray {},_fc .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_bdb :=data [_bcc ]>>uint (6-(x &3)*2)&3;if len (decode )==2{_bdb =uint8 (uint32 (LinearInterpolate (float64 (_bdb ),0,3.0,decode [0],decode [1]))&3);};return _g .Gray {Y :_bdb *85},nil ;};func _ggb (_ebg _g .NRGBA )_g .CMYK {_gac ,_bge ,_cea ,_ :=_ebg .RGBA ();_cfga ,_abbf ,_ef ,_ac :=_g .RGBToCMYK (uint8 (_gac >>8),uint8 (_bge >>8),uint8 (_cea >>8));return _g .CMYK {C :_cfga ,M :_abbf ,Y :_ef ,K :_ac };};func (_eabd *Gray8 )ColorModel ()_g .Model {return _g .GrayModel };func (_gabf *NRGBA32 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtNRGBA32 (x ,y ,_gabf .Width ,_gabf .Data ,_gabf .Alpha ,_gabf .Decode );};func (_egfb *ImageBase )GetAlpha ()[]byte {return _egfb .Alpha };func (_eeg *Monochrome )Base ()*ImageBase {return &_eeg .ImageBase };func _aff (_ga _fd .Image ,_de Image ,_dee _fd .Rectangle ){for _aa :=0;_aa < _dee .Max .X ;_aa ++{for _dgf :=0;_dgf < _dee .Max .Y ;_dgf ++{_ccb :=_ga .At (_aa ,_dgf );_de .Set (_aa ,_dgf ,_ccb );};};};func _gcd (_dgg _g .NYCbCrA )_g .NRGBA {_cbb :=int32 (_dgg .Y )*0x10101;_egf :=int32 (_dgg .Cb )-128;_deb :=int32 (_dgg .Cr )-128;_bde :=_cbb +91881*_deb ;if uint32 (_bde )&0xff000000==0{_bde >>=8;}else {_bde =^(_bde >>31)&0xffff;};_dcag :=_cbb -22554*_egf -46802*_deb ;if uint32 (_dcag )&0xff000000==0{_dcag >>=8;}else {_dcag =^(_dcag >>31)&0xffff;};_bec :=_cbb +116130*_egf ;if uint32 (_bec )&0xff000000==0{_bec >>=8;}else {_bec =^(_bec >>31)&0xffff;};return _g .NRGBA {R :uint8 (_bde >>8),G :uint8 (_dcag >>8),B :uint8 (_bec >>8),A :_dgg .A };};var _ Image =&Gray16 {};func _ced (_dec _g .Gray )_g .NRGBA {return _g .NRGBA {R :_dec .Y ,G :_dec .Y ,B :_dec .Y ,A :0xff}};type CMYK32 struct{ImageBase };func _fab (_cef RGBA ,_agg CMYK ,_feb _fd .Rectangle ){for _fba :=0;_fba < _feb .Max .X ;_fba ++{for _dff :=0;_dff < _feb .Max .Y ;_dff ++{_gb :=_cef .RGBAAt (_fba ,_dff );_agg .SetCMYK (_fba ,_dff ,_eac (_gb ));};};};type nrgba64 interface{NRGBA64At (_ebeg ,_cfbb int )_g .NRGBA64 ;SetNRGBA64 (_cdde ,_gcad int ,_ccc _g .NRGBA64 );};func (_deg *Gray4 )Base ()*ImageBase {return &_deg .ImageBase };var _ _fd .Image =&NRGBA64 {};func _acff (_facge Gray ,_ffbe NRGBA ,_ccfa _fd .Rectangle ){for _gae :=0;_gae < _ccfa .Max .X ;_gae ++{for _aac :=0;_aac < _ccfa .Max .Y ;_aac ++{_fgef :=_facge .GrayAt (_gae ,_aac );_ffbe .SetNRGBA (_gae ,_aac ,_ced (_fgef ));};};};func (_fgd *ImageBase )newAlpha (){_dggg :=BytesPerLine (_fgd .Width ,_fgd .BitsPerComponent ,1);_fgd .Alpha =make ([]byte ,_fgd .Height *_dggg );};func _eee (_dba _fd .Image ,_ead Image ,_dadg _fd .Rectangle ){if _cfae ,_bacbg :=_dba .(SMasker );_bacbg &&_cfae .HasAlpha (){_ead .(SMasker ).MakeAlpha ();};_aff (_dba ,_ead ,_dadg );};var _abg [256]uint8 ;func (_dcaa *NRGBA64 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtNRGBA64 (x ,y ,_dcaa .Width ,_dcaa .Data ,_dcaa .Alpha ,_dcaa .Decode );};func (_fff *Gray4 )ColorModel ()_g .Model {return Gray4Model };var _ _fd .Image =&Gray16 {};func (_dbg *CMYK32 )Validate ()error {if len (_dbg .Data )!=4*_dbg .Width *_dbg .Height {return _d .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");};return nil ;};func _cde (_ccfe _g .Gray )_g .Gray {_ccfe .Y >>=4;_ccfe .Y |=_ccfe .Y <<4;return _ccfe };type colorConverter struct{_cfe func (_gdb _fd .Image )(Image ,error );};func _fccc (_gddb _g .Color )_g .Color {_eabg :=_g .NRGBAModel .Convert (_gddb ).(_g .NRGBA );return _fbdg (_eabg );};func (_adcd *Gray8 )SetGray (x ,y int ,g _g .Gray ){_ebe :=y *_adcd .BytesPerLine +x ;if _ebe > len (_adcd .Data )-1{return ;};_adcd .Data [_ebe ]=g .Y ;};var _ Gray =&Gray4 {};func (_cbg *Monochrome )SetGray (x ,y int ,g _g .Gray ){_fde :=y *_cbg .BytesPerLine +x >>3;if _fde > len (_cbg .Data )-1{return ;};g =_eda (g ,monochromeModel (_cbg .ModelThreshold ));_cbg .setGray (x ,g ,_fde );};func (_ebad *NRGBA16 )setNRGBA (_cad ,_cfea ,_bacb int ,_cfag _g .NRGBA ){if _cad *3%2==0{_ebad .Data [_bacb ]=(_cfag .R >>4)<<4|(_cfag .G >>4);_ebad .Data [_bacb +1]=(_cfag .B >>4)<<4|(_ebad .Data [_bacb +1]&0xf);}else {_ebad .Data [_bacb ]=(_ebad .Data [_bacb ]&0xf0)|(_cfag .R >>4);_ebad .Data [_bacb +1]=(_cfag .G >>4)<<4|(_cfag .B >>4);};if _ebad .Alpha !=nil {_aae :=_cfea *BytesPerLine (_ebad .Width ,4,1);if _aae < len (_ebad .Alpha ){if _cad %2==0{_ebad .Alpha [_aae ]=(_cfag .A >>uint (4))<<uint (4)|(_ebad .Alpha [_bacb ]&0xf);}else {_ebad .Alpha [_aae ]=(_ebad .Alpha [_aae ]&0xf0)|(_cfag .A >>uint (4));};};};};func (_eaf *Gray2 )GrayAt (x ,y int )_g .Gray {_ebac ,_ :=ColorAtGray2BPC (x ,y ,_eaf .BytesPerLine ,_eaf .Data ,_eaf .Decode );return _ebac ;};func (_dgb *NRGBA64 )setNRGBA64 (_eedd int ,_eebd _g .NRGBA64 ,_fdcd int ){_dgb .Data [_eedd ]=uint8 (_eebd .R >>8);_dgb .Data [_eedd +1]=uint8 (_eebd .R &0xff);_dgb .Data [_eedd +2]=uint8 (_eebd .G >>8);_dgb .Data [_eedd +3]=uint8 (_eebd .G &0xff);_dgb .Data [_eedd +4]=uint8 (_eebd .B >>8);_dgb .Data [_eedd +5]=uint8 (_eebd .B &0xff);if _fdcd +1< len (_dgb .Alpha ){_dgb .Alpha [_fdcd ]=uint8 (_eebd .A >>8);_dgb .Alpha [_fdcd +1]=uint8 (_eebd .A &0xff);};};func (_egd *Monochrome )setGray (_efd int ,_effg _g .Gray ,_gbcd int ){if _effg .Y ==0{_egd .clearBit (_gbcd ,_efd );}else {_egd .setBit (_gbcd ,_efd );};};func (_fdf *NRGBA32 )setRGBA (_fgcd int ,_cba _g .NRGBA ){_dcea :=3*_fgcd ;_fdf .Data [_dcea ]=_cba .R ;_fdf .Data [_dcea +1]=_cba .G ;_fdf .Data [_dcea +2]=_cba .B ;if _fgcd < len (_fdf .Alpha ){_fdf .Alpha [_fgcd ]=_cba .A ;};};func _ede (_abf _g .NRGBA )_g .Gray {_aeb ,_abb ,_dbc ,_ :=_abf .RGBA ();_cfc :=(19595*_aeb +38470*_abb +7471*_dbc +1<<15)>>24;return _g .Gray {Y :uint8 (_cfc )};};type Gray16 struct{ImageBase };func (_ceg *NRGBA32 )Bounds ()_fd .Rectangle {return _fd .Rectangle {Max :_fd .Point {X :_ceg .Width ,Y :_ceg .Height }};};func (_df *CMYK32 )Bounds ()_fd .Rectangle {return _fd .Rectangle {Max :_fd .Point {X :_df .Width ,Y :_df .Height }};};func _bca (_dfe ,_dgcg uint8 )uint8 {if _dfe < _dgcg {return 255;};return 0;};func ColorAtNRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_g .NRGBA ,error ){_cbaa :=y *width +x ;_gcdd :=3*_cbaa ;if _gcdd +2>=len (data ){return _g .NRGBA {},_fc .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_abfc :=uint8 (0xff);if alpha !=nil &&len (alpha )> _cbaa {_abfc =alpha [_cbaa ];};_fbeg ,_gcg ,_adfb :=data [_gcdd ],data [_gcdd +1],data [_gcdd +2];if len (decode )==6{_fbeg =uint8 (uint32 (LinearInterpolate (float64 (_fbeg ),0,255,decode [0],decode [1]))&0xff);_gcg =uint8 (uint32 (LinearInterpolate (float64 (_gcg ),0,255,decode [2],decode [3]))&0xff);_adfb =uint8 (uint32 (LinearInterpolate (float64 (_adfb ),0,255,decode [4],decode [5]))&0xff);};return _g .NRGBA {R :_fbeg ,G :_gcg ,B :_adfb ,A :_abfc },nil ;};func _daea (_gaf _fd .Image ,_cfgab int )(_fd .Rectangle ,bool ,[]byte ){_daa :=_gaf .Bounds ();var (_eaba bool ;_fbgb []byte ;);switch _cfb :=_gaf .(type ){case SMasker :_eaba =_cfb .HasAlpha ();case NRGBA ,RGBA ,*_fd .RGBA64 ,nrgba64 ,*_fd .NYCbCrA :_fbgb =make ([]byte ,_daa .Max .X *_daa .Max .Y *_cfgab );};return _daa ,_eaba ,_fbgb ;};func (_fbe *NRGBA32 )SetNRGBA (x ,y int ,c _g .NRGBA ){_agbg :=y *_fbe .Width +x ;_beab :=3*_agbg ;if _beab +2>=len (_fbe .Data ){return ;};_fbe .setRGBA (_agbg ,c );};func ImgToGray (i _fd .Image )*_fd .Gray {if _aadf ,_ggfb :=i .(*_fd .Gray );_ggfb {return _aadf ;};_gcde :=i .Bounds ();_gabe :=_fd .NewGray (_gcde );for _fgf :=0;_fgf < _gcde .Max .X ;_fgf ++{for _eceb :=0;_eceb < _gcde .Max .Y ;_eceb ++{_eeed :=i .At (_fgf ,_eceb );_gabe .Set (_fgf ,_eceb ,_eeed );};};return _gabe ;};func (_fegd *Gray16 )Bounds ()_fd .Rectangle {return _fd .Rectangle {Max :_fd .Point {X :_fegd .Width ,Y :_fegd .Height }};};func (_ffbg *NRGBA16 )Validate ()error {if len (_ffbg .Data )!=3*_ffbg .Width *_ffbg .Height /2{return _d .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");};return nil ;};func _aafa (_dgdd _fd .Image )(Image ,error ){if _dae ,_bae :=_dgdd .(*Gray16 );_bae {return _dae .Copy (),nil ;};_bbgb :=_dgdd .Bounds ();_ffc ,_fgcb :=NewImage (_bbgb .Max .X ,_bbgb .Max .Y ,16,1,nil ,nil ,nil );if _fgcb !=nil {return nil ,_fgcb ;};_ged (_dgdd ,_ffc ,_bbgb );return _ffc ,nil ;};func _gaaa (){for _afba :=0;_afba < 256;_afba ++{_abg [_afba ]=uint8 (_afba &0x1)+(uint8 (_afba >>1)&0x1)+(uint8 (_afba >>2)&0x1)+(uint8 (_afba >>3)&0x1)+(uint8 (_afba >>4)&0x1)+(uint8 (_afba >>5)&0x1)+(uint8 (_afba >>6)&0x1)+(uint8 (_afba >>7)&0x1);};};func (_ebba *Gray8 )Validate ()error {if len (_ebba .Data )!=_ebba .Height *_ebba .BytesPerLine {return ErrInvalidImage ;};return nil ;};func _aagd (_dffc CMYK ,_bac Gray ,_cbc _fd .Rectangle ){for _ded :=0;_ded < _cbc .Max .X ;_ded ++{for _dge :=0;_dge < _cbc .Max .Y ;_dge ++{_bfed :=_gad (_dffc .CMYKAt (_ded ,_dge ));_bac .SetGray (_ded ,_dge ,_bfed );};};};type Gray2 struct{ImageBase };type monochromeThresholdConverter struct{Threshold uint8 ;};func _cabc (_gbe _fd .Image )(Image ,error ){if _bbgg ,_fcfe :=_gbe .(*NRGBA16 );_fcfe {return _bbgg .Copy (),nil ;};_ccba :=_gbe .Bounds ();_adag ,_bbcc :=NewImage (_ccba .Max .X ,_ccba .Max .Y ,4,3,nil ,nil ,nil );if _bbcc !=nil {return nil ,_bbcc ;};_ebda (_gbe ,_adag ,_ccba );return _adag ,nil ;};func (_faab *Gray16 )SetGray (x ,y int ,g _g .Gray ){_bdcc :=(y *_faab .BytesPerLine /2+x )*2;if _bdcc +1>=len (_faab .Data ){return ;};_faab .Data [_bdcc ]=g .Y ;_faab .Data [_bdcc +1]=g .Y ;};func _afg (_dgda CMYK ,_efdf NRGBA ,_gadc _fd .Rectangle ){for _gdbe :=0;_gdbe < _gadc .Max .X ;_gdbe ++{for _cfd :=0;_cfd < _gadc .Max .Y ;_cfd ++{_dbged :=_dgda .CMYKAt (_gdbe ,_cfd );_efdf .SetNRGBA (_gdbe ,_cfd ,_bb (_dbged ));};};};func (_bgec *ImageBase )MakeAlpha (){_bgec .newAlpha ()};func (_dcab *NRGBA64 )ColorModel ()_g .Model {return _g .NRGBA64Model };func (_cddd *Gray16 )Validate ()error {if len (_cddd .Data )!=_cddd .Height *_cddd .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_ge *Gray2 )Copy ()Image {return &Gray2 {ImageBase :_ge .copy ()}};func (_faff *Gray16 )ColorModel ()_g .Model {return _g .Gray16Model };var (Gray2Model =_g .ModelFunc (_abd );Gray4Model =_g .ModelFunc (_cfef );NRGBA16Model =_g .ModelFunc (_fccc ););func (_deac *ImageBase )Pix ()[]byte {return _deac .Data };var _ Image =&NRGBA64 {};func (_edc *Monochrome )At (x ,y int )_g .Color {_cdf ,_ :=_edc .ColorAt (x ,y );return _cdf };var _ _fd .Image =&NRGBA16 {};var _ Image =&CMYK32 {};func (_fbg *CMYK32 )CMYKAt (x ,y int )_g .CMYK {_dg ,_ :=ColorAtCMYK (x ,y ,_fbg .Width ,_fbg .Data ,_fbg .Decode );return _dg ;};type SMasker interface{HasAlpha ()bool ;GetAlpha ()[]byte ;MakeAlpha ();};func AutoThresholdTriangle (histogram [256]int )uint8 {var _eebdd ,_faffa ,_egbb ,_fdda int ;for _gcc :=0;_gcc < len (histogram );_gcc ++{if histogram [_gcc ]> 0{_eebdd =_gcc ;break ;};};if _eebdd > 0{_eebdd --;};for _acfb :=255;_acfb > 0;_acfb --{if histogram [_acfb ]> 0{_fdda =_acfb ;break ;};};if _fdda < 255{_fdda ++;};for _bbee :=0;_bbee < 256;_bbee ++{if histogram [_bbee ]> _faffa {_egbb =_bbee ;_faffa =histogram [_bbee ];};};var _gggf bool ;if (_egbb -_eebdd )< (_fdda -_egbb ){_gggf =true ;var _edcbb int ;_ebff :=255;for _edcbb < _ebff {_cbec :=histogram [_edcbb ];histogram [_edcbb ]=histogram [_ebff ];histogram [_ebff ]=_cbec ;_edcbb ++;_ebff --;};_eebdd =255-_fdda ;_egbb =255-_egbb ;};if _eebdd ==_egbb {return uint8 (_eebdd );};_fgga :=float64 (histogram [_egbb ]);_efef :=float64 (_eebdd -_egbb );_bff :=_f .Sqrt (_fgga *_fgga +_efef *_efef );_fgga /=_bff ;_efef /=_bff ;_bff =_fgga *float64 (_eebdd )+_efef *float64 (histogram [_eebdd ]);_cabb :=_eebdd ;var _gcgd float64 ;for _acdg :=_eebdd +1;_acdg <=_egbb ;_acdg ++{_fdec :=_fgga *float64 (_acdg )+_efef *float64 (histogram [_acdg ])-_bff ;if _fdec > _gcgd {_cabb =_acdg ;_gcgd =_fdec ;};};_cabb --;if _gggf {var _ggfd int ;_bbdg :=255;for _ggfd < _bbdg {_adabg :=histogram [_ggfd ];histogram [_ggfd ]=histogram [_bbdg ];histogram [_bbdg ]=_adabg ;_ggfd ++;_bbdg --;};return uint8 (255-_cabb );};return uint8 (_cabb );};type ColorConverter interface{Convert (_ade _fd .Image )(Image ,error );};func ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor int ,data ,alpha []byte ,decode []float64 )(_g .Color ,error ){switch bitsPerColor {case 4:return ColorAtNRGBA16 (x ,y ,width ,bytesPerLine ,data ,alpha ,decode );case 8:return ColorAtNRGBA32 (x ,y ,width ,data ,alpha ,decode );case 16:return ColorAtNRGBA64 (x ,y ,width ,data ,alpha ,decode );default:return nil ,_fc .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0067\u0062\u0020b\u0069\u0074\u0073\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0061\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );};};func _geb (_bccf uint8 )bool {if _bccf ==0||_bccf ==255{return true ;};return false ;};func _eac (_def _g .RGBA )_g .CMYK {_ee ,_efg ,_ebf ,_febc :=_g .RGBToCMYK (_def .R ,_def .G ,_def .B );return _g .CMYK {C :_ee ,M :_efg ,Y :_ebf ,K :_febc };};func (_fgc *CMYK32 )SetCMYK (x ,y int ,c _g .CMYK ){_eb :=4*(y *_fgc .Width +x );if _eb +3>=len (_fgc .Data ){return ;};_fgc .Data [_eb ]=c .C ;_fgc .Data [_eb +1]=c .M ;_fgc .Data [_eb +2]=c .Y ;_fgc .Data [_eb +3]=c .K ;};func GetConverter (bitsPerComponent ,colorComponents int )(ColorConverter ,error ){switch colorComponents {case 1:switch bitsPerComponent {case 1:return MonochromeConverter ,nil ;case 2:return Gray2Converter ,nil ;case 4:return Gray4Converter ,nil ;case 8:return GrayConverter ,nil ;case 16:return Gray16Converter ,nil ;};case 3:switch bitsPerComponent {case 4:return NRGBA16Converter ,nil ;case 8:return NRGBAConverter ,nil ;case 16:return NRGBA64Converter ,nil ;};case 4:return CMYKConverter ,nil ;};return nil ,_fc .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0043o\u006e\u0076\u0065\u0072\u0074\u0065\u0072\u0020\u0070\u0061\u0072\u0061\u006d\u0065t\u0065\u0072\u0073\u002e\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003a\u0020\u0025\u0064\u002c\u0020\u0043\u006f\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006et\u0073\u003a \u0025\u0064",bitsPerComponent ,colorComponents );};func (_deee *Gray8 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtGray8BPC (x ,y ,_deee .BytesPerLine ,_deee .Data ,_deee .Decode );};func (_caa *Gray8 )Set (x ,y int ,c _g .Color ){_acda :=y *_caa .BytesPerLine +x ;if _acda > len (_caa .Data )-1{return ;};_fbdc :=_g .GrayModel .Convert (c );_caa .Data [_acda ]=_fbdc .(_g .Gray ).Y ;};func NewImage (width ,height ,bitsPerComponent ,colorComponents int ,data ,alpha []byte ,decode []float64 )(Image ,error ){_ebacf :=NewImageBase (width ,height ,bitsPerComponent ,colorComponents ,data ,alpha ,decode );var _adac Image ;switch colorComponents {case 1:switch bitsPerComponent {case 1:_adac =&Monochrome {ImageBase :_ebacf ,ModelThreshold :0x0f};case 2:_adac =&Gray2 {ImageBase :_ebacf };case 4:_adac =&Gray4 {ImageBase :_ebacf };case 8:_adac =&Gray8 {ImageBase :_ebacf };case 16:_adac =&Gray16 {ImageBase :_ebacf };};case 3:switch bitsPerComponent {case 4:_adac =&NRGBA16 {ImageBase :_ebacf };case 8:_adac =&NRGBA32 {ImageBase :_ebacf };case 16:_adac =&NRGBA64 {ImageBase :_ebacf };};case 4:_adac =&CMYK32 {ImageBase :_ebacf };};if _adac ==nil {return nil ,ErrInvalidImage ;};return _adac ,nil ;};func (_feda *NRGBA16 )Base ()*ImageBase {return &_feda .ImageBase };func (_bgbe *Gray4 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtGray4BPC (x ,y ,_bgbe .BytesPerLine ,_bgbe .Data ,_bgbe .Decode );};func (_bf *CMYK32 )Copy ()Image {return &CMYK32 {ImageBase :_bf .copy ()}};func _afc (_ggcc _g .Gray )_g .Gray {_abba :=_ggcc .Y >>6;_abba |=_abba <<2;_ggcc .Y =_abba |_abba <<4;return _ggcc ;};func _cfef (_efe _g .Color )_g .Color {_eafe :=_g .GrayModel .Convert (_efe ).(_g .Gray );return _cde (_eafe )};func (_edd *Monochrome )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtGray1BPC (x ,y ,_edd .BytesPerLine ,_edd .Data ,_edd .Decode );};var _ NRGBA =&NRGBA32 {};func (_adab *monochromeThresholdConverter )Convert (img _fd .Image )(Image ,error ){if _eae ,_cda :=img .(*Monochrome );_cda {return _eae .Copy (),nil ;};_eec :=img .Bounds ();_ece ,_bdd :=NewImage (_eec .Max .X ,_eec .Max .Y ,1,1,nil ,nil ,nil );if _bdd !=nil {return nil ,_bdd ;};_ece .(*Monochrome ).ModelThreshold =_adab .Threshold ;for _dfc :=0;_dfc < _eec .Max .X ;_dfc ++{for _acb :=0;_acb < _eec .Max .Y ;_acb ++{_gddd :=img .At (_dfc ,_acb );_ece .Set (_dfc ,_acb ,_gddd );};};return _ece ,nil ;};func (_cbe *Gray16 )GrayAt (x ,y int )_g .Gray {_beag ,_ :=_cbe .ColorAt (x ,y );return _g .Gray {Y :uint8 (_beag .(_g .Gray16 ).Y >>8)};};type Gray interface{GrayAt (_agb ,_ddg int )_g .Gray ;SetGray (_fdc ,_fcaa int ,_agd _g .Gray );};func (_gec *NRGBA64 )Validate ()error {if len (_gec .Data )!=3*2*_gec .Width *_gec .Height {return _d .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");};return nil ;};func _fbdg (_fdcb _g .NRGBA )_g .NRGBA {_fdcb .R =_fdcb .R >>4|(_fdcb .R >>4)<<4;_fdcb .G =_fdcb .G >>4|(_fdcb .G >>4)<<4;_fdcb .B =_fdcb .B >>4|(_fdcb .B >>4)<<4;return _fdcb ;};type NRGBA interface{NRGBAAt (_eag ,_cdcg int )_g .NRGBA ;SetNRGBA (_bbb ,_eaff int ,_fdd _g .NRGBA );};func (_aade *NRGBA16 )Bounds ()_fd .Rectangle {return _fd .Rectangle {Max :_fd .Point {X :_aade .Width ,Y :_aade .Height }};};func _faaa (_daf int ,_fec int )error {return _fc .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",_daf ,_fec );};func _bdce (_cgg RGBA ,_dgga Gray ,_decf _fd .Rectangle ){for _eca :=0;_eca < _decf .Max .X ;_eca ++{for _agba :=0;_agba < _decf .Max .Y ;_agba ++{_ffba :=_fac (_cgg .RGBAAt (_eca ,_agba ));_dgga .SetGray (_eca ,_agba ,_ffba );};};};func (_egdf *NRGBA32 )Set (x ,y int ,c _g .Color ){_ace :=y *_egdf .Width +x ;_gdg :=3*_ace ;if _gdg +2>=len (_egdf .Data ){return ;};_fddf :=_g .NRGBAModel .Convert (c ).(_g .NRGBA );_egdf .setRGBA (_ace ,_fddf );};func (_dbge *Gray2 )At (x ,y int )_g .Color {_fbac ,_ :=_dbge .ColorAt (x ,y );return _fbac };func (_gde *CMYK32 )Base ()*ImageBase {return &_gde .ImageBase };type RGBA interface{RGBAAt (_fda ,_fbcc int )_g .RGBA ;SetRGBA (_ebfe ,_gaae int ,_aece _g .RGBA );};func _dgfa (_ebdb ,_gbf Gray ,_efcb _fd .Rectangle ){for _edcb :=0;_edcb < _efcb .Max .X ;_edcb ++{for _aaaa :=0;_aaaa < _efcb .Max .Y ;_aaaa ++{_gbf .SetGray (_edcb ,_aaaa ,_ebdb .GrayAt (_edcb ,_aaaa ));};};};func ColorAtGray16BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_g .Gray16 ,error ){_adfe :=(y *bytesPerLine /2+x )*2;if _adfe +1>=len (data ){return _g .Gray16 {},_fc .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_fed :=uint16 (data [_adfe ])<<8|uint16 (data [_adfe +1]);if len (decode )==2{_fed =uint16 (uint64 (LinearInterpolate (float64 (_fed ),0,65535,decode [0],decode [1])));};return _g .Gray16 {Y :_fed },nil ;};func ColorAtGray4BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_g .Gray ,error ){_adfa :=y *bytesPerLine +x >>1;if _adfa >=len (data ){return _g .Gray {},_fc .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_bbd :=data [_adfa ]>>uint (4-(x &1)*4)&0xf;if len (decode )==2{_bbd =uint8 (uint32 (LinearInterpolate (float64 (_bbd ),0,15,decode [0],decode [1]))&0xf);};return _g .Gray {Y :_bbd *17&0xff},nil ;};func ColorAtNRGBA16 (x ,y ,width ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_g .NRGBA ,error ){_edbe :=y *bytesPerLine +x *3/2;if _edbe +1>=len (data ){return _g .NRGBA {},_faaa (x ,y );};const (_bfg =0xf;_bfdae =uint8 (0xff););_bcd :=_bfdae ;if alpha !=nil {_abga :=y *BytesPerLine (width ,4,1);if _abga < len (alpha ){if x %2==0{_bcd =(alpha [_abga ]>>uint (4))&_bfg ;}else {_bcd =alpha [_abga ]&_bfg ;};_bcd |=_bcd <<4;};};var _fce ,_dcbb ,_ceade uint8 ;if x *3%2==0{_fce =(data [_edbe ]>>uint (4))&_bfg ;_dcbb =data [_edbe ]&_bfg ;_ceade =(data [_edbe +1]>>uint (4))&_bfg ;}else {_fce =data [_edbe ]&_bfg ;_dcbb =(data [_edbe +1]>>uint (4))&_bfg ;_ceade =data [_edbe +1]&_bfg ;};if len (decode )==6{_fce =uint8 (uint32 (LinearInterpolate (float64 (_fce ),0,15,decode [0],decode [1]))&0xf);_dcbb =uint8 (uint32 (LinearInterpolate (float64 (_dcbb ),0,15,decode [2],decode [3]))&0xf);_ceade =uint8 (uint32 (LinearInterpolate (float64 (_ceade ),0,15,decode [4],decode [5]))&0xf);};return _g .NRGBA {R :(_fce <<4)|(_fce &0xf),G :(_dcbb <<4)|(_dcbb &0xf),B :(_ceade <<4)|(_ceade &0xf),A :_bcd },nil ;};func (_cdd *Gray8 )Copy ()Image {return &Gray8 {ImageBase :_cdd .copy ()}};func _dd (_ebb Gray ,_cf CMYK ,_cee _fd .Rectangle ){for _af :=0;_af < _cee .Max .X ;_af ++{for _gfb :=0;_gfb < _cee .Max .Y ;_gfb ++{_be :=_ebb .GrayAt (_af ,_gfb );_cf .SetCMYK (_af ,_gfb ,_bdf (_be ));};};};func _gddg (_bgef _fd .Image )(Image ,error ){if _fga ,_ecb :=_bgef .(*Gray2 );_ecb {return _fga .Copy (),nil ;};_gdbf :=_bgef .Bounds ();_efc ,_dffe :=NewImage (_gdbf .Max .X ,_gdbf .Max .Y ,2,1,nil ,nil ,nil );if _dffe !=nil {return nil ,_dffe ;};_ged (_bgef ,_efc ,_gdbf );return _efc ,nil ;};func (_gdda *NRGBA16 )ColorModel ()_g .Model {return NRGBA16Model };func GrayHistogram (g Gray )(_ggbg [256]int ){switch _egc :=g .(type ){case Histogramer :return _egc .Histogram ();case _fd .Image :_egg :=_egc .Bounds ();for _eebe :=0;_eebe < _egg .Max .X ;_eebe ++{for _adg :=0;_adg < _egg .Max .Y ;_adg ++{_ggbg [g .GrayAt (_eebe ,_adg ).Y ]++;};};return _ggbg ;default:return [256]int {};};};func IsGrayImgBlackAndWhite (i *_fd .Gray )bool {return _ccd (i )};func (_ba *CMYK32 )At (x ,y int )_g .Color {_gg ,_ :=_ba .ColorAt (x ,y );return _gg };func ColorAtGray8BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_g .Gray ,error ){_ceef :=y *bytesPerLine +x ;if _ceef >=len (data ){return _g .Gray {},_fc .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_dcfa :=data [_ceef ];if len (decode )==2{_dcfa =uint8 (uint32 (LinearInterpolate (float64 (_dcfa ),0,255,decode [0],decode [1]))&0xff);};return _g .Gray {Y :_dcfa },nil ;};func (_cag *NRGBA64 )SetNRGBA64 (x ,y int ,c _g .NRGBA64 ){_bbfde :=(y *_cag .Width +x )*2;_fbag :=_bbfde *3;if _fbag +5>=len (_cag .Data ){return ;};_cag .setNRGBA64 (_fbag ,c ,_bbfde );};func _abd (_aeda _g .Color )_g .Color {_gge :=_g .GrayModel .Convert (_aeda ).(_g .Gray );return _afc (_gge )};type ImageBase struct{Width ,Height int ;BitsPerComponent ,ColorComponents int ;Data ,Alpha []byte ;Decode []float64 ;BytesPerLine int ;};func _aecd (_gfe *_fd .Gray16 ,_bgcg uint8 )*_fd .Gray {_eeddb :=_gfe .Bounds ();_abe :=_fd .NewGray (_eeddb );for _ecad :=0;_ecad < _eeddb .Dx ();_ecad ++{for _gfbb :=0;_gfbb < _eeddb .Dy ();_gfbb ++{_eebdc :=_gfe .Gray16At (_ecad ,_gfbb );_abe .SetGray (_ecad ,_gfbb ,_g .Gray {Y :_bca (uint8 (_eebdc .Y /256),_bgcg )});};};return _abe ;};func ColorAtGray1BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_g .Gray ,error ){_ddf :=y *bytesPerLine +x >>3;if _ddf >=len (data ){return _g .Gray {},_fc .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_aggg :=data [_ddf ]>>uint (7-(x &7))&1;if len (decode )==2{_aggg =uint8 (LinearInterpolate (float64 (_aggg ),0.0,1.0,decode [0],decode [1]))&1;};return _g .Gray {Y :_aggg *255},nil ;};func (_gfbec *NRGBA64 )Set (x ,y int ,c _g .Color ){_cbbg :=(y *_gfbec .Width +x )*2;_abad :=_cbbg *3;if _abad +5>=len (_gfbec .Data ){return ;};_gdbd :=_g .NRGBA64Model .Convert (c ).(_g .NRGBA64 );_gfbec .setNRGBA64 (_abad ,_gdbd ,_cbbg );};func FromGoImage (i _fd .Image )(Image ,error ){switch _ggd :=i .(type ){case Image :return _ggd .Copy (),nil ;case Gray :return GrayConverter .Convert (i );case *_fd .Gray16 :return Gray16Converter .Convert (i );case CMYK :return CMYKConverter .Convert (i );case *_fd .NRGBA64 :return NRGBA64Converter .Convert (i );default:return NRGBAConverter .Convert (i );};};func (_dcg *Monochrome )clearBit (_fbgc ,_bgb int ){_dcg .Data [_fbgc ]&=^(0x80>>uint (_bgb &7))};var ErrInvalidImage =_d .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");var _ _fd .Image =&Gray4 {};var _ Image =&NRGBA32 {};func _ccd (_gba *_fd .Gray )bool {for _ggedf :=0;_ggedf < len (_gba .Pix );_ggedf ++{if !_geb (_gba .Pix [_ggedf ]){return false ;};};return true ;};func (_aafe *NRGBA64 )Bounds ()_fd .Rectangle {return _fd .Rectangle {Max :_fd .Point {X :_aafe .Width ,Y :_aafe .Height }};};var _ Gray =&Gray8 {};func (_dea *Gray2 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtGray2BPC (x ,y ,_dea .BytesPerLine ,_dea .Data ,_dea .Decode );};func _cccb (_ebc _fd .Image )(Image ,error ){if _cgec ,_ebegd :=_ebc .(*NRGBA64 );_ebegd {return _cgec .Copy (),nil ;};_bdcb ,_bbaf ,_cdgd :=_daea (_ebc ,2);_ccgg ,_abff :=NewImage (_bdcb .Max .X ,_bdcb .Max .Y ,16,3,nil ,_cdgd ,nil );if _abff !=nil {return nil ,_abff ;};_eee (_ebc ,_ccgg ,_bdcb );if len (_cdgd )!=0&&!_bbaf {if _caaa :=_ecf (_cdgd ,_ccgg );_caaa !=nil {return nil ,_caaa ;};};return _ccgg ,nil ;};func _ecf (_cdge []byte ,_fgce Image )error {_afab :=true ;for _feeb :=0;_feeb < len (_cdge );_feeb ++{if _cdge [_feeb ]!=0xff{_afab =false ;break ;};};if _afab {switch _aba :=_fgce .(type ){case *NRGBA32 :_aba .Alpha =nil ;case *NRGBA64 :_aba .Alpha =nil ;default:return _fc .Errorf ("i\u006ete\u0072n\u0061l\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020i\u006d\u0061\u0067\u0065\u0020s\u0068\u006f\u0075l\u0064\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0074\u0079\u0070e\u0020\u002a\u004eRGB\u0041\u0033\u0032\u0020\u006f\u0072 \u002a\u004e\u0052\u0047\u0042\u0041\u0036\u0034\u0020\u0062\u0075\u0074 \u0069s\u003a\u0020\u0025\u0054",_fgce );};};return nil ;};func _bagc (_gada _fd .Image )(Image ,error ){if _ddba ,_fge :=_gada .(*NRGBA32 );_fge {return _ddba .Copy (),nil ;};_cgag ,_efa ,_feff :=_daea (_gada ,1);_dgca ,_ceaf :=NewImage (_cgag .Max .X ,_cgag .Max .Y ,8,3,nil ,_feff ,nil );if _ceaf !=nil {return nil ,_ceaf ;};_ebda (_gada ,_dgca ,_cgag );if len (_feff )!=0&&!_efa {if _bdbf :=_ecf (_feff ,_dgca );_bdbf !=nil {return nil ,_bdbf ;};};return _dgca ,nil ;};func (_bbfe *Gray2 )SetGray (x ,y int ,gray _g .Gray ){_aede :=_afc (gray );_gadb :=y *_bbfe .BytesPerLine ;_aad :=_gadb +(x >>2);if _aad >=len (_bbfe .Data ){return ;};_dfg :=_aede .Y >>6;_bbfe .Data [_aad ]=(_bbfe .Data [_aad ]&(^(0xc0>>uint (2*((x )&3)))))|(_dfg <<uint (6-2*(x &3)));};func (_dgc *Gray16 )Histogram ()(_fgcf [256]int ){for _bbg :=0;_bbg < _dgc .Width ;_bbg ++{for _ebdg :=0;_ebdg < _dgc .Height ;_ebdg ++{_fgcf [_dgc .GrayAt (_bbg ,_ebdg ).Y ]++;};};return _fgcf ;};type Monochrome struct{ImageBase ;ModelThreshold uint8 ;};func _gad (_ccg _g .CMYK )_g .Gray {_fbae ,_eff ,_bd :=_g .CMYKToRGB (_ccg .C ,_ccg .M ,_ccg .Y ,_ccg .K );_ca :=(19595*uint32 (_fbae )+38470*uint32 (_eff )+7471*uint32 (_bd )+1<<7)>>16;return _g .Gray {Y :uint8 (_ca )};};func (_bgc *Monochrome )Set (x ,y int ,c _g .Color ){_aefa :=y *_bgc .BytesPerLine +x >>3;if _aefa > len (_bgc .Data )-1{return ;};_affe :=_bgc .ColorModel ().Convert (c ).(_g .Gray );_bgc .setGray (x ,_affe ,_aefa );};func _bef (_gabfa nrgba64 ,_bfb NRGBA ,_daeaf _fd .Rectangle ){for _fefdc :=0;_fefdc < _daeaf .Max .X ;_fefdc ++{for _cgga :=0;_cgga < _daeaf .Max .Y ;_cgga ++{_cce :=_gabfa .NRGBA64At (_fefdc ,_cgga );_bfb .SetNRGBA (_fefdc ,_cgga ,_ega (_cce ));};};};func _egb (_ggg ,_eaeb NRGBA ,_gbb _fd .Rectangle ){for _fcd :=0;_fcd < _gbb .Max .X ;_fcd ++{for _deff :=0;_deff < _gbb .Max .Y ;_deff ++{_eaeb .SetNRGBA (_fcd ,_deff ,_ggg .NRGBAAt (_fcd ,_deff ));};};};func (_a *CMYK32 )ColorModel ()_g .Model {return _g .CMYKModel };func (_ec colorConverter )Convert (src _fd .Image )(Image ,error ){return _ec ._cfe (src )};func NewImageBase (width int ,height int ,bitsPerComponent int ,colorComponents int ,data []byte ,alpha []byte ,decode []float64 )ImageBase {_cbcg :=ImageBase {Width :width ,Height :height ,BitsPerComponent :bitsPerComponent ,ColorComponents :colorComponents ,Data :data ,Alpha :alpha ,Decode :decode ,BytesPerLine :BytesPerLine (width ,bitsPerComponent ,colorComponents )};if data ==nil {_cbcg .Data =make ([]byte ,height *_cbcg .BytesPerLine );};return _cbcg ;};func (_fffa *NRGBA32 )Validate ()error {if len (_fffa .Data )!=3*_fffa .Width *_fffa .Height {return _d .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");};return nil ;};func _feg (_bdc _fd .Image )(Image ,error ){if _cfcc ,_acbd :=_bdc .(*Gray8 );_acbd {return _cfcc .Copy (),nil ;};_accg :=_bdc .Bounds ();_dda ,_eccf :=NewImage (_accg .Max .X ,_accg .Max .Y ,8,1,nil ,nil ,nil );if _eccf !=nil {return nil ,_eccf ;};_ged (_bdc ,_dda ,_accg );return _dda ,nil ;};func (_bag *Gray2 )Histogram ()(_bbc [256]int ){for _ffb :=0;_ffb < _bag .Width ;_ffb ++{for _feaf :=0;_feaf < _bag .Height ;_feaf ++{_bbc [_bag .GrayAt (_ffb ,_feaf ).Y ]++;};};return _bbc ;};func (_agbe *NRGBA16 )Copy ()Image {return &NRGBA16 {ImageBase :_agbe .copy ()}};func (_fcae *NRGBA32 )Base ()*ImageBase {return &_fcae .ImageBase };func (_cbgc *NRGBA64 )Copy ()Image {return &NRGBA64 {ImageBase :_cbgc .copy ()}};func ColorAtCMYK (x ,y ,width int ,data []byte ,decode []float64 )(_g .CMYK ,error ){_gdd :=4*(y *width +x );if _gdd +3>=len (data ){return _g .CMYK {},_fc .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};C :=data [_gdd ]&0xff;M :=data [_gdd +1]&0xff;Y :=data [_gdd +2]&0xff;K :=data [_gdd +3]&0xff;if len (decode )==8{C =uint8 (uint32 (LinearInterpolate (float64 (C ),0,255,decode [0],decode [1]))&0xff);M =uint8 (uint32 (LinearInterpolate (float64 (M ),0,255,decode [2],decode [3]))&0xff);Y =uint8 (uint32 (LinearInterpolate (float64 (Y ),0,255,decode [4],decode [5]))&0xff);K =uint8 (uint32 (LinearInterpolate (float64 (K ),0,255,decode [6],decode [7]))&0xff);};return _g .CMYK {C :C ,M :M ,Y :Y ,K :K },nil ;};type NRGBA32 struct{ImageBase };func (_cge *Gray4 )Histogram ()(_ebfd [256]int ){for _dcf :=0;_dcf < _cge .Width ;_dcf ++{for _dce :=0;_dce < _cge .Height ;_dce ++{_ebfd [_cge .GrayAt (_dcf ,_dce ).Y ]++;};};return _ebfd ;};func _fcfb (_fbfc *_fd .NYCbCrA ,_ffe NRGBA ,_gadg _fd .Rectangle ){for _dbe :=0;_dbe < _gadg .Max .X ;_dbe ++{for _abdf :=0;_abdf < _gadg .Max .Y ;_abdf ++{_dfdd :=_fbfc .NYCbCrAAt (_dbe ,_abdf );_ffe .SetNRGBA (_dbe ,_abdf ,_gcd (_dfdd ));};};};func (_agde *Gray4 )setGray (_eea int ,_gaad int ,_acbe _g .Gray ){_ecg :=_gaad *_agde .BytesPerLine ;_gce :=_ecg +(_eea >>1);if _gce >=len (_agde .Data ){return ;};_gged :=_acbe .Y >>4;_agde .Data [_gce ]=(_agde .Data [_gce ]&(^(0xf0>>uint (4*(_eea &1)))))|(_gged <<uint (4-4*(_eea &1)));};var _ NRGBA =&NRGBA16 {};var _ Image =&Monochrome {};func _ged (_cgc _fd .Image ,_adbc Image ,_cfff _fd .Rectangle ){switch _bed :=_cgc .(type ){case Gray :_dgfa (_bed ,_adbc .(Gray ),_cfff );case NRGBA :_fabd (_bed ,_adbc .(Gray ),_cfff );case CMYK :_aagd (_bed ,_adbc .(Gray ),_cfff );case RGBA :_bdce (_bed ,_adbc .(Gray ),_cfff );default:_aff (_cgc ,_adbc .(Image ),_cfff );};};var _ _fd .Image =&NRGBA32 {};func (_cedb *Monochrome )ColorModel ()_g .Model {return MonochromeModel (_cedb .ModelThreshold )};func _fcga (_ddgf _fd .Image )(Image ,error ){if _acf ,_agec :=_ddgf .(*Gray4 );_agec {return _acf .Copy (),nil ;};_edg :=_ddgf .Bounds ();_add ,_gacf :=NewImage (_edg .Max .X ,_edg .Max .Y ,4,1,nil ,nil ,nil );if _gacf !=nil {return nil ,_gacf ;};_ged (_ddgf ,_add ,_edg );return _add ,nil ;};func (_efb *Gray2 )ColorModel ()_g .Model {return Gray2Model };type NRGBA16 struct{ImageBase };var _ Image =&Gray4 {};func _ffac (_fabb _fd .Image ,_afgg uint8 )*_fd .Gray {_bfc :=_fabb .Bounds ();_aeac :=_fd .NewGray (_bfc );var (_bdbfb _g .Color ;_adce _g .Gray ;);for _acffa :=0;_acffa < _bfc .Max .X ;_acffa ++{for _ccbd :=0;_ccbd < _bfc .Max .Y ;_ccbd ++{_bdbfb =_fabb .At (_acffa ,_ccbd );_aeac .Set (_acffa ,_ccbd ,_bdbfb );_adce =_aeac .GrayAt (_acffa ,_ccbd );_aeac .SetGray (_acffa ,_ccbd ,_g .Gray {Y :_bca (_adce .Y ,_afgg )});};};return _aeac ;};var _ Gray =&Monochrome {};func (_cae *NRGBA64 )Base ()*ImageBase {return &_cae .ImageBase };func _ega (_gfd _g .NRGBA64 )_g .NRGBA {return _g .NRGBA {R :uint8 (_gfd .R >>8),G :uint8 (_gfd .G >>8),B :uint8 (_gfd .B >>8),A :uint8 (_gfd .A >>8)};};func (_gef *Gray2 )Validate ()error {if len (_gef .Data )!=_gef .Height *_gef .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_gbd monochromeModel )Convert (c _g .Color )_g .Color {_eab :=_g .GrayModel .Convert (c ).(_g .Gray );return _eda (_eab ,_gbd );};func LinearInterpolate (x ,xmin ,xmax ,ymin ,ymax float64 )float64 {if _f .Abs (xmax -xmin )< 0.000001{return ymin ;};_ggeb :=ymin +(x -xmin )*(ymax -ymin )/(xmax -xmin );return _ggeb ;};func (_ebd *Gray8 )GrayAt (x ,y int )_g .Gray {_cdcb ,_ :=ColorAtGray8BPC (x ,y ,_ebd .BytesPerLine ,_ebd .Data ,_ebd .Decode );return _cdcb ;};func (_gaac *Gray16 )Base ()*ImageBase {return &_gaac .ImageBase };func (_efba *Gray16 )Set (x ,y int ,c _g .Color ){_cbbc :=(y *_efba .BytesPerLine /2+x )*2;if _cbbc +1>=len (_efba .Data ){return ;};_cgeb :=_g .Gray16Model .Convert (c ).(_g .Gray16 );_efba .Data [_cbbc ],_efba .Data [_cbbc +1]=uint8 (_cgeb .Y >>8),uint8 (_cgeb .Y &0xff);};func _fbd (_ag _fd .Image )(Image ,error ){if _da ,_gf :=_ag .(*CMYK32 );_gf {return _da .Copy (),nil ;};_dbb :=_ag .Bounds ();_ab ,_cdc :=NewImage (_dbb .Max .X ,_dbb .Max .Y ,8,4,nil ,nil ,nil );if _cdc !=nil {return nil ,_cdc ;};switch _fa :=_ag .(type ){case CMYK :_ea (_fa ,_ab .(CMYK ),_dbb );case Gray :_dd (_fa ,_ab .(CMYK ),_dbb );case NRGBA :_ed (_fa ,_ab .(CMYK ),_dbb );case RGBA :_fab (_fa ,_ab .(CMYK ),_dbb );default:_aff (_ag ,_ab ,_dbb );};return _ab ,nil ;};func _fabd (_ffg NRGBA ,_ccbc Gray ,_becf _fd .Rectangle ){for _gbca :=0;_gbca < _becf .Max .X ;_gbca ++{for _bdeg :=0;_bdeg < _becf .Max .Y ;_bdeg ++{_afe :=_ede (_ffg .NRGBAAt (_gbca ,_bdeg ));_ccbc .SetGray (_gbca ,_bdeg ,_afe );};};};