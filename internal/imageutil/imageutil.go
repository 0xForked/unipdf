//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package imageutil ;import (_b "errors";_e "fmt";_gd "github.com/unidoc/unipdf/v3/internal/bitwise";_g "image";_cb "image/color";_d "image/draw";_f "math";);func (_cfbd *Gray16 )Base ()*ImageBase {return &_cfbd .ImageBase };func (_ccgc *Gray4 )ColorAt (x ,y int )(_cb .Color ,error ){return ColorAtGray4BPC (x ,y ,_ccgc .BytesPerLine ,_ccgc .Data ,_ccgc .Decode );};func (_gbe *Monochrome )GrayAt (x ,y int )_cb .Gray {_gfc ,_ :=ColorAtGray1BPC (x ,y ,_gbe .BytesPerLine ,_gbe .Data ,_gbe .Decode );return _gfc ;};func (_cfcc *Monochrome )Set (x ,y int ,c _cb .Color ){_cdeg :=y *_cfcc .BytesPerLine +x >>3;if _cdeg > len (_cfcc .Data )-1{return ;};_dbce :=_cfcc .ColorModel ().Convert (c ).(_cb .Gray );_cfcc .setGray (x ,_dbce ,_cdeg );};func (_bbf *Monochrome )Bounds ()_g .Rectangle {return _g .Rectangle {Max :_g .Point {X :_bbf .Width ,Y :_bbf .Height }};};var _ _g .Image =&NRGBA64 {};func (_afcb *Monochrome )ColorModel ()_cb .Model {return MonochromeModel (_afcb .ModelThreshold )};func (_ee *CMYK32 )ColorModel ()_cb .Model {return _cb .CMYKModel };func (_agcb *Gray8 )Bounds ()_g .Rectangle {return _g .Rectangle {Max :_g .Point {X :_agcb .Width ,Y :_agcb .Height }};};func ColorAtGray4BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_cb .Gray ,error ){_eba :=y *bytesPerLine +x >>1;if _eba >=len (data ){return _cb .Gray {},_e .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_cbg :=data [_eba ]>>uint (4-(x &1)*4)&0xf;if len (decode )==2{_cbg =uint8 (uint32 (LinearInterpolate (float64 (_cbg ),0,15,decode [0],decode [1]))&0xf);};return _cb .Gray {Y :_cbg *17&0xff},nil ;};type colorConverter struct{_aeg func (_cbea _g .Image )(Image ,error );};func ConverterFunc (converterFunc func (_ceef _g .Image )(Image ,error ))ColorConverter {return colorConverter {_aeg :converterFunc };};func _dbdc (_dgc _cb .Gray ,_gbg monochromeModel )_cb .Gray {if _dgc .Y > uint8 (_gbg ){return _cb .Gray {Y :_f .MaxUint8 };};return _cb .Gray {};};func ColorAtNRGBA16 (x ,y ,width ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_cb .NRGBA ,error ){_fca :=y *bytesPerLine +x *3/2;if _fca +1>=len (data ){return _cb .NRGBA {},_dgfe (x ,y );};const (_dcbg =0xf;_dea =uint8 (0xff););_aebe :=_dea ;if alpha !=nil {_cded :=y *BytesPerLine (width ,4,1);if _cded < len (alpha ){if x %2==0{_aebe =(alpha [_cded ]>>uint (4))&_dcbg ;}else {_aebe =alpha [_cded ]&_dcbg ;};_aebe |=_aebe <<4;};};var _acgg ,_dfac ,_dda uint8 ;if x *3%2==0{_acgg =(data [_fca ]>>uint (4))&_dcbg ;_dfac =data [_fca ]&_dcbg ;_dda =(data [_fca +1]>>uint (4))&_dcbg ;}else {_acgg =data [_fca ]&_dcbg ;_dfac =(data [_fca +1]>>uint (4))&_dcbg ;_dda =data [_fca +1]&_dcbg ;};if len (decode )==6{_acgg =uint8 (uint32 (LinearInterpolate (float64 (_acgg ),0,15,decode [0],decode [1]))&0xf);_dfac =uint8 (uint32 (LinearInterpolate (float64 (_dfac ),0,15,decode [2],decode [3]))&0xf);_dda =uint8 (uint32 (LinearInterpolate (float64 (_dda ),0,15,decode [4],decode [5]))&0xf);};return _cb .NRGBA {R :(_acgg <<4)|(_acgg &0xf),G :(_dfac <<4)|(_dfac &0xf),B :(_dda <<4)|(_dda &0xf),A :_aebe },nil ;};type RGBA interface{RGBAAt (_bgga ,_dag int )_cb .RGBA ;SetRGBA (_caab ,_bde int ,_cdag _cb .RGBA );};func (_eb *CMYK32 )SetCMYK (x ,y int ,c _cb .CMYK ){_ga :=4*(y *_eb .Width +x );if _ga +3>=len (_eb .Data ){return ;};_eb .Data [_ga ]=c .C ;_eb .Data [_ga +1]=c .M ;_eb .Data [_ga +2]=c .Y ;_eb .Data [_ga +3]=c .K ;};func (_ggc *Gray4 )Base ()*ImageBase {return &_ggc .ImageBase };func (_cgce *NRGBA32 )Set (x ,y int ,c _cb .Color ){_gfdc :=y *_cgce .Width +x ;_fdda :=3*_gfdc ;if _fdda +2>=len (_cgce .Data ){return ;};_cff :=_cb .NRGBAModel .Convert (c ).(_cb .NRGBA );_cgce .setRGBA (_gfdc ,_cff );};func (_bcb *Monochrome )Histogram ()(_gafa [256]int ){for _ ,_fad :=range _bcb .Data {_gafa [0xff]+=int (_eggfc [_bcb .Data [_fad ]]);};return _gafa ;};func (_fda *Gray4 )ColorModel ()_cb .Model {return Gray4Model };func (_df *CMYK32 )Validate ()error {if len (_df .Data )!=4*_df .Width *_df .Height {return _b .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");};return nil ;};type monochromeModel uint8 ;func _edd (_gcc _cb .NYCbCrA )_cb .NRGBA {_gbaf :=int32 (_gcc .Y )*0x10101;_ff :=int32 (_gcc .Cb )-128;_dbd :=int32 (_gcc .Cr )-128;_cfgg :=_gbaf +91881*_dbd ;if uint32 (_cfgg )&0xff000000==0{_cfgg >>=8;}else {_cfgg =^(_cfgg >>31)&0xffff;};_dfg :=_gbaf -22554*_ff -46802*_dbd ;if uint32 (_dfg )&0xff000000==0{_dfg >>=8;}else {_dfg =^(_dfg >>31)&0xffff;};_aag :=_gbaf +116130*_ff ;if uint32 (_aag )&0xff000000==0{_aag >>=8;}else {_aag =^(_aag >>31)&0xffff;};return _cb .NRGBA {R :uint8 (_cfgg >>8),G :uint8 (_dfg >>8),B :uint8 (_aag >>8),A :_gcc .A };};func _ddf (_afa _g .Image ,_debe Image ,_bcga _g .Rectangle ){switch _bce :=_afa .(type ){case Gray :_agbb (_bce ,_debe .(Gray ),_bcga );case NRGBA :_adde (_bce ,_debe .(Gray ),_bcga );case CMYK :_afag (_bce ,_debe .(Gray ),_bcga );case RGBA :_ebb (_bce ,_debe .(Gray ),_bcga );default:_cf (_afa ,_debe .(Image ),_bcga );};};func MonochromeModel (threshold uint8 )_cb .Model {return monochromeModel (threshold )};func (_fcfb *Gray8 )ColorAt (x ,y int )(_cb .Color ,error ){return ColorAtGray8BPC (x ,y ,_fcfb .BytesPerLine ,_fcfb .Data ,_fcfb .Decode );};var _ _g .Image =&NRGBA16 {};func (_baba *NRGBA64 )Validate ()error {if len (_baba .Data )!=3*2*_baba .Width *_baba .Height {return _b .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");};return nil ;};type monochromeThresholdConverter struct{Threshold uint8 ;};type Gray interface{GrayAt (_aaga ,_ded int )_cb .Gray ;SetGray (_eaa ,_feg int ,_bb _cb .Gray );};func (_bebb *NRGBA32 )Validate ()error {if len (_bebb .Data )!=3*_bebb .Width *_bebb .Height {return _b .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");};return nil ;};var _ Image =&Gray2 {};func _agbb (_ccb ,_ffe Gray ,_gbd _g .Rectangle ){for _gce :=0;_gce < _gbd .Max .X ;_gce ++{for _bbfg :=0;_bbfg < _gbd .Max .Y ;_bbfg ++{_ffe .SetGray (_gce ,_bbfg ,_ccb .GrayAt (_gce ,_bbfg ));};};};func MonochromeThresholdConverter (threshold uint8 )ColorConverter {return &monochromeThresholdConverter {Threshold :threshold };};var _ _g .Image =&Gray2 {};func (_cbgc *ImageBase )HasAlpha ()bool {if _cbgc .Alpha ==nil {return false ;};for _fgf :=range _cbgc .Alpha {if _cbgc .Alpha [_fgf ]!=0xff{return true ;};};return false ;};func (_aagg *NRGBA16 )setNRGBA (_cdb ,_cefgde ,_bgad int ,_feba _cb .NRGBA ){if _cdb *3%2==0{_aagg .Data [_bgad ]=(_feba .R >>4)<<4|(_feba .G >>4);_aagg .Data [_bgad +1]=(_feba .B >>4)<<4|(_aagg .Data [_bgad +1]&0xf);}else {_aagg .Data [_bgad ]=(_aagg .Data [_bgad ]&0xf0)|(_feba .R >>4);_aagg .Data [_bgad +1]=(_feba .G >>4)<<4|(_feba .B >>4);};if _aagg .Alpha !=nil {_gafe :=_cefgde *BytesPerLine (_aagg .Width ,4,1);if _gafe < len (_aagg .Alpha ){if _cdb %2==0{_aagg .Alpha [_gafe ]=(_feba .A >>uint (4))<<uint (4)|(_aagg .Alpha [_bgad ]&0xf);}else {_aagg .Alpha [_gafe ]=(_aagg .Alpha [_gafe ]&0xf0)|(_feba .A >>uint (4));};};};};func (_gebe *Gray8 )Set (x ,y int ,c _cb .Color ){_dgcf :=y *_gebe .BytesPerLine +x ;if _dgcf > len (_gebe .Data )-1{return ;};_efcc :=_cb .GrayModel .Convert (c );_gebe .Data [_dgcf ]=_efcc .(_cb .Gray ).Y ;};type ColorConverter interface{Convert (_cee _g .Image )(Image ,error );};func ColorAtGray16BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_cb .Gray16 ,error ){_bda :=(y *bytesPerLine /2+x )*2;if _bda +1>=len (data ){return _cb .Gray16 {},_e .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_dcd :=uint16 (data [_bda ])<<8|uint16 (data [_bda +1]);if len (decode )==2{_dcd =uint16 (uint64 (LinearInterpolate (float64 (_dcd ),0,65535,decode [0],decode [1])));};return _cb .Gray16 {Y :_dcd },nil ;};func (_ddg *NRGBA16 )ColorModel ()_cb .Model {return NRGBA16Model };func init (){_fae ()};func (_faac *Gray16 )At (x ,y int )_cb .Color {_fbef ,_ :=_faac .ColorAt (x ,y );return _fbef };func (_ddd *Gray16 )ColorModel ()_cb .Model {return _cb .Gray16Model };type NRGBA interface{NRGBAAt (_gde ,_dcea int )_cb .NRGBA ;SetNRGBA (_febc ,_fffgb int ,_agf _cb .NRGBA );};var _ Image =&Monochrome {};func (_cdf *Gray16 )Validate ()error {if len (_cdf .Data )!=_cdf .Height *_cdf .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_fg *Gray2 )Copy ()Image {return &Gray2 {ImageBase :_fg .copy ()}};func _ebd (_aced _g .Image ,_fcdf Image ,_defa _g .Rectangle ){if _eag ,_fecd :=_aced .(SMasker );_fecd &&_eag .HasAlpha (){_fcdf .(SMasker ).MakeAlpha ();};switch _dgea :=_aced .(type ){case Gray :_afge (_dgea ,_fcdf .(NRGBA ),_defa );case NRGBA :_bcbc (_dgea ,_fcdf .(NRGBA ),_defa );case *_g .NYCbCrA :_dde (_dgea ,_fcdf .(NRGBA ),_defa );case CMYK :_beg (_dgea ,_fcdf .(NRGBA ),_defa );case RGBA :_abd (_dgea ,_fcdf .(NRGBA ),_defa );case nrgba64 :_fdb (_dgea ,_fcdf .(NRGBA ),_defa );default:_cf (_aced ,_fcdf ,_defa );};};type Monochrome struct{ImageBase ;ModelThreshold uint8 ;};func (_cec *Gray2 )Set (x ,y int ,c _cb .Color ){if x >=_cec .Width ||y >=_cec .Height {return ;};_adfc :=Gray2Model .Convert (c ).(_cb .Gray );_gaa :=y *_cec .BytesPerLine ;_egb :=_gaa +(x >>2);_fgc :=_adfc .Y >>6;_cec .Data [_egb ]=(_cec .Data [_egb ]&(^(0xc0>>uint (2*((x )&3)))))|(_fgc <<uint (6-2*(x &3)));};func _debb (_fec _cb .Gray )_cb .Gray {_fec .Y >>=4;_fec .Y |=_fec .Y <<4;return _fec };func (_daed *ImageBase )GetAlpha ()[]byte {return _daed .Alpha };func _adb (_fde _cb .Gray )_cb .NRGBA {return _cb .NRGBA {R :_fde .Y ,G :_fde .Y ,B :_fde .Y ,A :0xff}};func (_bgfg *Gray16 )Set (x ,y int ,c _cb .Color ){_fgcaa :=(y *_bgfg .BytesPerLine /2+x )*2;if _fgcaa +1>=len (_bgfg .Data ){return ;};_beeg :=_cb .Gray16Model .Convert (c ).(_cb .Gray16 );_bgfg .Data [_fgcaa ],_bgfg .Data [_fgcaa +1]=uint8 (_beeg .Y >>8),uint8 (_beeg .Y &0xff);};func _bee (_fdc _cb .Color )_cb .Color {_ebgc :=_cb .GrayModel .Convert (_fdc ).(_cb .Gray );return _debb (_ebgc );};type ImageBase struct{Width ,Height int ;BitsPerComponent ,ColorComponents int ;Data ,Alpha []byte ;Decode []float64 ;BytesPerLine int ;};func _ebb (_beb RGBA ,_fba Gray ,_bdbb _g .Rectangle ){for _edb :=0;_edb < _bdbb .Max .X ;_edb ++{for _edde :=0;_edde < _bdbb .Max .Y ;_edde ++{_fcg :=_cc (_beb .RGBAAt (_edb ,_edde ));_fba .SetGray (_edb ,_edde ,_fcg );};};};var _ Gray =&Gray2 {};func (_aed *Gray8 )At (x ,y int )_cb .Color {_dbcc ,_ :=_aed .ColorAt (x ,y );return _dbcc };func (_acbg *NRGBA32 )Copy ()Image {return &NRGBA32 {ImageBase :_acbg .copy ()}};func (_fgeb *NRGBA16 )NRGBAAt (x ,y int )_cb .NRGBA {_dbg ,_ :=ColorAtNRGBA16 (x ,y ,_fgeb .Width ,_fgeb .BytesPerLine ,_fgeb .Data ,_fgeb .Alpha ,_fgeb .Decode );return _dbg ;};func ColorAtNRGBA64 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_cb .NRGBA64 ,error ){_cbce :=(y *width +x )*2;_ffda :=_cbce *3;if _ffda +5>=len (data ){return _cb .NRGBA64 {},_e .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};const _dbge =0xffff;_gdbb :=uint16 (_dbge );if alpha !=nil &&len (alpha )> _cbce +1{_gdbb =uint16 (alpha [_cbce ])<<8|uint16 (alpha [_cbce +1]);};_bbce :=uint16 (data [_ffda ])<<8|uint16 (data [_ffda +1]);_geaf :=uint16 (data [_ffda +2])<<8|uint16 (data [_ffda +3]);_bfg :=uint16 (data [_ffda +4])<<8|uint16 (data [_ffda +5]);if len (decode )==6{_bbce =uint16 (uint64 (LinearInterpolate (float64 (_bbce ),0,65535,decode [0],decode [1]))&_dbge );_geaf =uint16 (uint64 (LinearInterpolate (float64 (_geaf ),0,65535,decode [2],decode [3]))&_dbge );_bfg =uint16 (uint64 (LinearInterpolate (float64 (_bfg ),0,65535,decode [4],decode [5]))&_dbge );};return _cb .NRGBA64 {R :_bbce ,G :_geaf ,B :_bfg ,A :_gdbb },nil ;};func (_abe *Gray2 )Validate ()error {if len (_abe .Data )!=_abe .Height *_abe .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_bga *Gray8 )Base ()*ImageBase {return &_bga .ImageBase };func (_gfg *Gray16 )Histogram ()(_bdca [256]int ){for _agb :=0;_agb < _gfg .Width ;_agb ++{for _bafce :=0;_bafce < _gfg .Height ;_bafce ++{_bdca [_gfg .GrayAt (_agb ,_bafce ).Y ]++;};};return _bdca ;};var (Gray2Model =_cb .ModelFunc (_cfca );Gray4Model =_cb .ModelFunc (_bee );NRGBA16Model =_cb .ModelFunc (_dgg ););func (_acbga *NRGBA64 )ColorModel ()_cb .Model {return _cb .NRGBA64Model };func _fe (_ad Gray ,_ca CMYK ,_ged _g .Rectangle ){for _aff :=0;_aff < _ged .Max .X ;_aff ++{for _caf :=0;_caf < _ged .Max .Y ;_caf ++{_bec :=_ad .GrayAt (_aff ,_caf );_ca .SetCMYK (_aff ,_caf ,_afc (_bec ));};};};func (_fceb *NRGBA64 )NRGBA64At (x ,y int )_cb .NRGBA64 {_gbdc ,_ :=ColorAtNRGBA64 (x ,y ,_fceb .Width ,_fceb .Data ,_fceb .Alpha ,_fceb .Decode );return _gbdc ;};type NRGBA64 struct{ImageBase };func _dgg (_gebb _cb .Color )_cb .Color {_cbge :=_cb .NRGBAModel .Convert (_gebb ).(_cb .NRGBA );return _dbbf (_cbge );};var _ _g .Image =&Gray8 {};func _fceg (_fbb _cb .Gray )_cb .Gray {_acebc :=_fbb .Y >>6;_acebc |=_acebc <<2;_fbb .Y =_acebc |_acebc <<4;return _fbb ;};func (_efd *Gray8 )Copy ()Image {return &Gray8 {ImageBase :_efd .copy ()}};func (_ceeb *NRGBA32 )SetNRGBA (x ,y int ,c _cb .NRGBA ){_adfd :=y *_ceeb .Width +x ;_gef :=3*_adfd ;if _gef +2>=len (_ceeb .Data ){return ;};_ceeb .setRGBA (_adfd ,c );};func ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor int ,data ,alpha []byte ,decode []float64 )(_cb .Color ,error ){switch bitsPerColor {case 4:return ColorAtNRGBA16 (x ,y ,width ,bytesPerLine ,data ,alpha ,decode );case 8:return ColorAtNRGBA32 (x ,y ,width ,data ,alpha ,decode );case 16:return ColorAtNRGBA64 (x ,y ,width ,data ,alpha ,decode );default:return nil ,_e .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0067\u0062\u0020b\u0069\u0074\u0073\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0061\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );};};func _gac (_gfe RGBA ,_baf CMYK ,_faf _g .Rectangle ){for _gba :=0;_gba < _faf .Max .X ;_gba ++{for _bgf :=0;_bgf < _faf .Max .Y ;_bgf ++{_eg :=_gfe .RGBAAt (_gba ,_bgf );_baf .SetCMYK (_gba ,_bgf ,_egfd (_eg ));};};};func NewImage (width ,height ,bitsPerComponent ,colorComponents int ,data ,alpha []byte ,decode []float64 )(Image ,error ){_efea :=NewImageBase (width ,height ,bitsPerComponent ,colorComponents ,data ,alpha ,decode );var _bcgc Image ;switch colorComponents {case 1:switch bitsPerComponent {case 1:_bcgc =&Monochrome {ImageBase :_efea ,ModelThreshold :0x0f};case 2:_bcgc =&Gray2 {ImageBase :_efea };case 4:_bcgc =&Gray4 {ImageBase :_efea };case 8:_bcgc =&Gray8 {ImageBase :_efea };case 16:_bcgc =&Gray16 {ImageBase :_efea };};case 3:switch bitsPerComponent {case 4:_bcgc =&NRGBA16 {ImageBase :_efea };case 8:_bcgc =&NRGBA32 {ImageBase :_efea };case 16:_bcgc =&NRGBA64 {ImageBase :_efea };};case 4:_bcgc =&CMYK32 {ImageBase :_efea };};if _bcgc ==nil {return nil ,ErrInvalidImage ;};return _bcgc ,nil ;};func (_dfgb *ImageBase )MakeAlpha (){_dfgb .newAlpha ()};func (_bcge *Gray16 )ColorAt (x ,y int )(_cb .Color ,error ){return ColorAtGray16BPC (x ,y ,_bcge .BytesPerLine ,_bcge .Data ,_bcge .Decode );};func _cebg (_ccgfc _g .Image ,_fgb int )(_g .Rectangle ,bool ,[]byte ){_daa :=_ccgfc .Bounds ();var (_becd bool ;_cadfb []byte ;);switch _abed :=_ccgfc .(type ){case SMasker :_becd =_abed .HasAlpha ();case NRGBA ,RGBA ,*_g .RGBA64 ,nrgba64 ,*_g .NYCbCrA :_cadfb =make ([]byte ,_daa .Max .X *_daa .Max .Y *_fgb );};return _daa ,_becd ,_cadfb ;};func _beg (_gffd CMYK ,_bgbg NRGBA ,_aabf _g .Rectangle ){for _fbc :=0;_fbc < _aabf .Max .X ;_fbc ++{for _dafd :=0;_dafd < _aabf .Max .Y ;_dafd ++{_acc :=_gffd .CMYKAt (_fbc ,_dafd );_bgbg .SetNRGBA (_fbc ,_dafd ,_cbba (_acc ));};};};func _dde (_baac *_g .NYCbCrA ,_daea NRGBA ,_abf _g .Rectangle ){for _cgd :=0;_cgd < _abf .Max .X ;_cgd ++{for _dgca :=0;_dgca < _abf .Max .Y ;_dgca ++{_gbgd :=_baac .NYCbCrAAt (_cgd ,_dgca );_daea .SetNRGBA (_cgd ,_dgca ,_edd (_gbgd ));};};};func (_bddd *ImageBase )newAlpha (){_gae :=BytesPerLine (_bddd .Width ,_bddd .BitsPerComponent ,1);_bddd .Alpha =make ([]byte ,_bddd .Height *_gae );};func (_afg *NRGBA64 )Set (x ,y int ,c _cb .Color ){_ddfc :=(y *_afg .Width +x )*2;_ggdb :=_ddfc *3;if _ggdb +5>=len (_afg .Data ){return ;};_gbaa :=_cb .NRGBA64Model .Convert (c ).(_cb .NRGBA64 );_afg .setNRGBA64 (_ggdb ,_gbaa ,_ddfc );};func ColorAtCMYK (x ,y ,width int ,data []byte ,decode []float64 )(_cb .CMYK ,error ){_aa :=4*(y *width +x );if _aa +3>=len (data ){return _cb .CMYK {},_e .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};C :=data [_aa ]&0xff;M :=data [_aa +1]&0xff;Y :=data [_aa +2]&0xff;K :=data [_aa +3]&0xff;if len (decode )==8{C =uint8 (uint32 (LinearInterpolate (float64 (C ),0,255,decode [0],decode [1]))&0xff);M =uint8 (uint32 (LinearInterpolate (float64 (M ),0,255,decode [2],decode [3]))&0xff);Y =uint8 (uint32 (LinearInterpolate (float64 (Y ),0,255,decode [4],decode [5]))&0xff);K =uint8 (uint32 (LinearInterpolate (float64 (K ),0,255,decode [6],decode [7]))&0xff);};return _cb .CMYK {C :C ,M :M ,Y :Y ,K :K },nil ;};func AutoThresholdTriangle (histogram [256]int )uint8 {var _bgcb ,_fcebg ,_edf ,_gefb int ;for _gfff :=0;_gfff < len (histogram );_gfff ++{if histogram [_gfff ]> 0{_bgcb =_gfff ;break ;};};if _bgcb > 0{_bgcb --;};for _aabd :=255;_aabd > 0;_aabd --{if histogram [_aabd ]> 0{_gefb =_aabd ;break ;};};if _gefb < 255{_gefb ++;};for _dcaa :=0;_dcaa < 256;_dcaa ++{if histogram [_dcaa ]> _fcebg {_edf =_dcaa ;_fcebg =histogram [_dcaa ];};};var _gbafe bool ;if (_edf -_bgcb )< (_gefb -_edf ){_gbafe =true ;var _edcg int ;_aeea :=255;for _edcg < _aeea {_dcf :=histogram [_edcg ];histogram [_edcg ]=histogram [_aeea ];histogram [_aeea ]=_dcf ;_edcg ++;_aeea --;};_bgcb =255-_gefb ;_edf =255-_edf ;};if _bgcb ==_edf {return uint8 (_bgcb );};_efeg :=float64 (histogram [_edf ]);_gedd :=float64 (_bgcb -_edf );_cddc :=_f .Sqrt (_efeg *_efeg +_gedd *_gedd );_efeg /=_cddc ;_gedd /=_cddc ;_cddc =_efeg *float64 (_bgcb )+_gedd *float64 (histogram [_bgcb ]);_bgae :=_bgcb ;var _effe float64 ;for _edbb :=_bgcb +1;_edbb <=_edf ;_edbb ++{_faga :=_efeg *float64 (_edbb )+_gedd *float64 (histogram [_edbb ])-_cddc ;if _faga > _effe {_bgae =_edbb ;_effe =_faga ;};};_bgae --;if _gbafe {var _egae int ;_faba :=255;for _egae < _faba {_dadc :=histogram [_egae ];histogram [_egae ]=histogram [_faba ];histogram [_faba ]=_dadc ;_egae ++;_faba --;};return uint8 (255-_bgae );};return uint8 (_bgae );};func (_ced *CMYK32 )CMYKAt (x ,y int )_cb .CMYK {_db ,_ :=ColorAtCMYK (x ,y ,_ced .Width ,_ced .Data ,_ced .Decode );return _db ;};func _aee (_dged _g .Image )(Image ,error ){if _deg ,_bgca :=_dged .(*Gray8 );_bgca {return _deg .Copy (),nil ;};_bgb :=_dged .Bounds ();_cfcb ,_bcc :=NewImage (_bgb .Max .X ,_bgb .Max .Y ,8,1,nil ,nil ,nil );if _bcc !=nil {return nil ,_bcc ;};_ddf (_dged ,_cfcb ,_bgb );return _cfcb ,nil ;};var _ Gray =&Gray16 {};func (_afde *NRGBA32 )ColorModel ()_cb .Model {return _cb .NRGBAModel };func (_aedf *NRGBA16 )ColorAt (x ,y int )(_cb .Color ,error ){return ColorAtNRGBA16 (x ,y ,_aedf .Width ,_aedf .BytesPerLine ,_aedf .Data ,_aedf .Alpha ,_aedf .Decode );};func _ede (_bdab *_g .Gray )bool {for _fabf :=0;_fabf < len (_bdab .Pix );_fabf ++{if !_abfb (_bdab .Pix [_fabf ]){return false ;};};return true ;};func _aec (_egab *_g .Gray ,_cbd uint8 )*_g .Gray {_eacf :=_egab .Bounds ();_aada :=_g .NewGray (_eacf );for _gcge :=0;_gcge < _eacf .Dx ();_gcge ++{for _cac :=0;_cac < _eacf .Dy ();_cac ++{_facd :=_egab .GrayAt (_gcge ,_cac );_aada .SetGray (_gcge ,_cac ,_cb .Gray {Y :_eaag (_facd .Y ,_cbd )});};};return _aada ;};func (_bgaa *NRGBA16 )Set (x ,y int ,c _cb .Color ){_gab :=y *_bgaa .BytesPerLine +x *3/2;if _gab +1>=len (_bgaa .Data ){return ;};_fge :=NRGBA16Model .Convert (c ).(_cb .NRGBA );_bgaa .setNRGBA (x ,y ,_gab ,_fge );};var _ Image =&Gray4 {};var _ NRGBA =&NRGBA16 {};func _afc (_dce _cb .Gray )_cb .CMYK {return _cb .CMYK {K :0xff-_dce .Y }};func (_ada *ImageBase )Pix ()[]byte {return _ada .Data };func GrayHistogram (g Gray )(_abcd [256]int ){switch _egc :=g .(type ){case Histogramer :return _egc .Histogram ();case _g .Image :_fege :=_egc .Bounds ();for _fecde :=0;_fecde < _fege .Max .X ;_fecde ++{for _febac :=0;_febac < _fege .Max .Y ;_febac ++{_abcd [g .GrayAt (_fecde ,_febac ).Y ]++;};};return _abcd ;default:return [256]int {};};};func _fadb (_efag _g .Image )(Image ,error ){if _bdad ,_fed :=_efag .(*NRGBA32 );_fed {return _bdad .Copy (),nil ;};_aae ,_gbfg ,_fcfc :=_cebg (_efag ,1);_bcdg ,_aea :=NewImage (_aae .Max .X ,_aae .Max .Y ,8,3,nil ,_fcfc ,nil );if _aea !=nil {return nil ,_aea ;};_ebd (_efag ,_bcdg ,_aae );if len (_fcfc )!=0&&!_gbfg {if _aage :=_cbeg (_fcfc ,_bcdg );_aage !=nil {return nil ,_aage ;};};return _bcdg ,nil ;};func _ceg (_cca _g .Image )(Image ,error ){if _gbcf ,_cgb :=_cca .(*Gray16 );_cgb {return _gbcf .Copy (),nil ;};_gaac :=_cca .Bounds ();_ffga ,_daeb :=NewImage (_gaac .Max .X ,_gaac .Max .Y ,16,1,nil ,nil ,nil );if _daeb !=nil {return nil ,_daeb ;};_ddf (_cca ,_ffga ,_gaac );return _ffga ,nil ;};func _afag (_gedb CMYK ,_acbc Gray ,_cefc _g .Rectangle ){for _bdd :=0;_bdd < _cefc .Max .X ;_bdd ++{for _bfcd :=0;_bfcd < _cefc .Max .Y ;_bfcd ++{_aagb :=_eggf (_gedb .CMYKAt (_bdd ,_bfcd ));_acbc .SetGray (_bdd ,_bfcd ,_aagb );};};};var ErrInvalidImage =_b .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");func (_cddb *NRGBA32 )ColorAt (x ,y int )(_cb .Color ,error ){return ColorAtNRGBA32 (x ,y ,_cddb .Width ,_cddb .Data ,_cddb .Alpha ,_cddb .Decode );};func BytesPerLine (width ,bitsPerComponent ,colorComponents int )int {return ((width *bitsPerComponent )*colorComponents +7)>>3;};func _gca (_gg _g .Image )(Image ,error ){if _fdd ,_ffg :=_gg .(*Monochrome );_ffg {return _fdd ,nil ;};_dff ,_efe :=_gg .(Gray );if !_efe {_agd ,_cda :=GrayConverter .Convert (_gg );if _cda !=nil {return nil ,_cda ;};_dff =_agd .(Gray );};_gdg :=_gg .Bounds ();_eegf ,_bdc :=NewImage (_gdg .Max .X ,_gdg .Max .Y ,1,1,nil ,nil ,nil );if _bdc !=nil {return nil ,_bdc ;};_bfa :=_eegf .(*Monochrome );_efeb :=AutoThresholdTriangle (GrayHistogram (_dff ));for _bcf :=0;_bcf < _gdg .Max .X ;_bcf ++{for _bff :=0;_bff < _gdg .Max .Y ;_bff ++{_bfc :=_dbdc (_dff .GrayAt (_bcf ,_bff ),monochromeModel (_efeb ));_bfa .SetGray (_bcf ,_bff ,_bfc );};};return _eegf ,nil ;};func (_bbcf *Gray4 )setGray (_ebcb int ,_bdb int ,_gbcb _cb .Gray ){_efbb :=_bdb *_bbcf .BytesPerLine ;_feb :=_efbb +(_ebcb >>1);if _feb >=len (_bbcf .Data ){return ;};_cdgb :=_gbcb .Y >>4;_bbcf .Data [_feb ]=(_bbcf .Data [_feb ]&(^(0xf0>>uint (4*(_ebcb &1)))))|(_cdgb <<uint (4-4*(_ebcb &1)));};var _ Gray =&Monochrome {};func _cbb (_deb NRGBA ,_dd CMYK ,_ef _g .Rectangle ){for _eff :=0;_eff < _ef .Max .X ;_eff ++{for _dc :=0;_dc < _ef .Max .Y ;_dc ++{_bc :=_deb .NRGBAAt (_eff ,_dc );_dd .SetCMYK (_eff ,_dc ,_ab (_bc ));};};};func (_eege colorConverter )Convert (src _g .Image )(Image ,error ){return _eege ._aeg (src )};var _ Image =&CMYK32 {};func (_fgec *NRGBA32 )NRGBAAt (x ,y int )_cb .NRGBA {_fcfe ,_ :=ColorAtNRGBA32 (x ,y ,_fgec .Width ,_fgec .Data ,_fgec .Alpha ,_fgec .Decode );return _fcfe ;};func _cfca (_cgc _cb .Color )_cb .Color {_bba :=_cb .GrayModel .Convert (_cgc ).(_cb .Gray );return _fceg (_bba );};func (_dffg *Gray2 )At (x ,y int )_cb .Color {_cad ,_ :=_dffg .ColorAt (x ,y );return _cad };type nrgba64 interface{NRGBA64At (_aebg ,_bcee int )_cb .NRGBA64 ;SetNRGBA64 (_efad ,_ffdc int ,_fada _cb .NRGBA64 );};func ImgToBinary (i _g .Image ,threshold uint8 )*_g .Gray {switch _bdbgc :=i .(type ){case *_g .Gray :if _ede (_bdbgc ){return _bdbgc ;};return _aec (_bdbgc ,threshold );case *_g .Gray16 :return _fbf (_bdbgc ,threshold );default:return _feddc (_bdbgc ,threshold );};};var _eggfc [256]uint8 ;var (MonochromeConverter =ConverterFunc (_gca );Gray2Converter =ConverterFunc (_fgca );Gray4Converter =ConverterFunc (_bede );GrayConverter =ConverterFunc (_aee );Gray16Converter =ConverterFunc (_ceg );NRGBA16Converter =ConverterFunc (_fee );NRGBAConverter =ConverterFunc (_fadb );NRGBA64Converter =ConverterFunc (_gfde );CMYKConverter =ConverterFunc (_ae ););var _ _g .Image =&Gray4 {};func (_geb *Gray4 )At (x ,y int )_cb .Color {_bcg ,_ :=_geb .ColorAt (x ,y );return _bcg };func _cf (_ea _g .Image ,_egf Image ,_efc _g .Rectangle ){for _fcfa :=0;_fcfa < _efc .Max .X ;_fcfa ++{for _cfc :=0;_cfc < _efc .Max .Y ;_cfc ++{_ade :=_ea .At (_fcfa ,_cfc );_egf .Set (_fcfa ,_cfc ,_ade );};};};type Image interface{_d .Image ;Base ()*ImageBase ;Copy ()Image ;Pix ()[]byte ;ColorAt (_ega ,_cae int )(_cb .Color ,error );Validate ()error ;};func _ab (_bca _cb .NRGBA )_cb .CMYK {_abc ,_ebc ,_afb ,_ :=_bca .RGBA ();_aab ,_efa ,_fbg ,_dbe :=_cb .RGBToCMYK (uint8 (_abc >>8),uint8 (_ebc >>8),uint8 (_afb >>8));return _cb .CMYK {C :_aab ,M :_efa ,Y :_fbg ,K :_dbe };};func (_gacb *Gray4 )Validate ()error {if len (_gacb .Data )!=_gacb .Height *_gacb .BytesPerLine {return ErrInvalidImage ;};return nil ;};func _bede (_dge _g .Image )(Image ,error ){if _bedc ,_ebca :=_dge .(*Gray4 );_ebca {return _bedc .Copy (),nil ;};_bgg :=_dge .Bounds ();_agcg ,_bab :=NewImage (_bgg .Max .X ,_bgg .Max .Y ,4,1,nil ,nil ,nil );if _bab !=nil {return nil ,_bab ;};_ddf (_dge ,_agcg ,_bgg );return _agcg ,nil ;};func (_ag *CMYK32 )Copy ()Image {return &CMYK32 {ImageBase :_ag .copy ()}};func AddDataPadding (width ,height ,bitsPerComponent ,colorComponents int ,data []byte )([]byte ,error ){_fgfa :=BytesPerLine (width ,bitsPerComponent ,colorComponents );if _fgfa ==width *colorComponents *bitsPerComponent /8{return data ,nil ;};_cga :=width *colorComponents *bitsPerComponent ;_afad :=_fgfa *8;_fdf :=8-(_afad -_cga );_cadf :=_gd .NewReader (data );_dacd :=_fgfa -1;_bfd :=make ([]byte ,_dacd );_cdgf :=make ([]byte ,height *_fgfa );_dgd :=_gd .NewWriterMSB (_cdgf );var _dfgg uint64 ;var _dfd error ;for _gaea :=0;_gaea < height ;_gaea ++{_ ,_dfd =_cadf .Read (_bfd );if _dfd !=nil {return nil ,_dfd ;};_ ,_dfd =_dgd .Write (_bfd );if _dfd !=nil {return nil ,_dfd ;};_dfgg ,_dfd =_cadf .ReadBits (byte (_fdf ));if _dfd !=nil {return nil ,_dfd ;};_ ,_dfd =_dgd .WriteBits (_dfgg ,_fdf );if _dfd !=nil {return nil ,_dfd ;};_dgd .FinishByte ();};return _cdgf ,nil ;};func _afge (_aba Gray ,_debg NRGBA ,_fcec _g .Rectangle ){for _ccgdg :=0;_ccgdg < _fcec .Max .X ;_ccgdg ++{for _cedd :=0;_cedd < _fcec .Max .Y ;_cedd ++{_acee :=_aba .GrayAt (_ccgdg ,_cedd );_debg .SetNRGBA (_ccgdg ,_cedd ,_adb (_acee ));};};};func (_caba *NRGBA64 )SetNRGBA64 (x ,y int ,c _cb .NRGBA64 ){_ddcfa :=(y *_caba .Width +x )*2;_ddaa :=_ddcfa *3;if _ddaa +5>=len (_caba .Data ){return ;};_caba .setNRGBA64 (_ddaa ,c ,_ddcfa );};func _fee (_eef _g .Image )(Image ,error ){if _bfad ,_gag :=_eef .(*NRGBA16 );_gag {return _bfad .Copy (),nil ;};_afba :=_eef .Bounds ();_edc ,_eec :=NewImage (_afba .Max .X ,_afba .Max .Y ,4,3,nil ,nil ,nil );if _eec !=nil {return nil ,_eec ;};_ebd (_eef ,_edc ,_afba );return _edc ,nil ;};func _feddc (_dabf _g .Image ,_agde uint8 )*_g .Gray {_ecgf :=_dabf .Bounds ();_fdga :=_g .NewGray (_ecgf );var (_caaa _cb .Color ;_fdbb _cb .Gray ;);for _dcfe :=0;_dcfe < _ecgf .Max .X ;_dcfe ++{for _bcfd :=0;_bcfd < _ecgf .Max .Y ;_bcfd ++{_caaa =_dabf .At (_dcfe ,_bcfd );_fdga .Set (_dcfe ,_bcfd ,_caaa );_fdbb =_fdga .GrayAt (_dcfe ,_bcfd );_fdga .SetGray (_dcfe ,_bcfd ,_cb .Gray {Y :_eaag (_fdbb .Y ,_agde )});};};return _fdga ;};func (_ceee *NRGBA16 )SetNRGBA (x ,y int ,c _cb .NRGBA ){_caag :=y *_ceee .BytesPerLine +x *3/2;if _caag +1>=len (_ceee .Data ){return ;};c =_dbbf (c );_ceee .setNRGBA (x ,y ,_caag ,c );};func (_ecg *ImageBase )copy ()ImageBase {_ccgdb :=*_ecg ;_ccgdb .Data =make ([]byte ,len (_ecg .Data ));copy (_ccgdb .Data ,_ecg .Data );return _ccgdb ;};func (_cce *Gray8 )Histogram ()(_afe [256]int ){for _cedg :=0;_cedg < len (_cce .Data );_cedg ++{_afe [_cce .Data [_cedg ]]++;};return _afe ;};func (_bbc *Monochrome )SetGray (x ,y int ,g _cb .Gray ){_dab :=y *_bbc .BytesPerLine +x >>3;if _dab > len (_bbc .Data )-1{return ;};g =_dbdc (g ,monochromeModel (_bbc .ModelThreshold ));_bbc .setGray (x ,g ,_dab );};func ImgToGray (i _g .Image )*_g .Gray {if _geef ,_efdf :=i .(*_g .Gray );_efdf {return _geef ;};_defd :=i .Bounds ();_bdcd :=_g .NewGray (_defd );for _gebg :=0;_gebg < _defd .Max .X ;_gebg ++{for _fbcg :=0;_fbcg < _defd .Max .Y ;_fbcg ++{_fced :=i .At (_gebg ,_fbcg );_bdcd .Set (_gebg ,_fbcg ,_fced );};};return _bdcd ;};func (_dbc *Monochrome )Base ()*ImageBase {return &_dbc .ImageBase };func (_af *CMYK32 )Set (x ,y int ,c _cb .Color ){_fd :=4*(y *_af .Width +x );if _fd +3>=len (_af .Data ){return ;};_cbe :=_cb .CMYKModel .Convert (c ).(_cb .CMYK );_af .Data [_fd ]=_cbe .C ;_af .Data [_fd +1]=_cbe .M ;_af .Data [_fd +2]=_cbe .Y ;_af .Data [_fd +3]=_cbe .K ;};func (_fag *Monochrome )ColorAt (x ,y int )(_cb .Color ,error ){return ColorAtGray1BPC (x ,y ,_fag .BytesPerLine ,_fag .Data ,_fag .Decode );};func (_fcee *NRGBA32 )setRGBA (_dddf int ,_ccf _cb .NRGBA ){_cgbe :=3*_dddf ;_fcee .Data [_cgbe ]=_ccf .R ;_fcee .Data [_cgbe +1]=_ccf .G ;_fcee .Data [_cgbe +2]=_ccf .B ;if _dddf < len (_fcee .Alpha ){_fcee .Alpha [_dddf ]=_ccf .A ;};};func (_bea *Gray8 )Validate ()error {if len (_bea .Data )!=_bea .Height *_bea .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_cefgd *Gray4 )GrayAt (x ,y int )_cb .Gray {_aga ,_ :=ColorAtGray4BPC (x ,y ,_cefgd .BytesPerLine ,_cefgd .Data ,_cefgd .Decode );return _aga ;};func (_gbca *Gray8 )SetGray (x ,y int ,g _cb .Gray ){_aceg :=y *_gbca .BytesPerLine +x ;if _aceg > len (_gbca .Data )-1{return ;};_gbca .Data [_aceg ]=g .Y ;};func _dgfe (_aca int ,_aaaa int )error {return _e .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",_aca ,_aaaa );};func (_daf *Monochrome )setBit (_efaa ,_ceea int ){_daf .Data [_efaa ]|=0x80>>uint (_ceea &7)};type NRGBA32 struct{ImageBase };func LinearInterpolate (x ,xmin ,xmax ,ymin ,ymax float64 )float64 {if _f .Abs (xmax -xmin )< 0.000001{return ymin ;};_eca :=ymin +(x -xmin )*(ymax -ymin )/(xmax -xmin );return _eca ;};func (_bbfe *NRGBA64 )Bounds ()_g .Rectangle {return _g .Rectangle {Max :_g .Point {X :_bbfe .Width ,Y :_bbfe .Height }};};func _cbeg (_bgbb []byte ,_ccd Image )error {_ddae :=true ;for _ddcf :=0;_ddcf < len (_bgbb );_ddcf ++{if _bgbb [_ddcf ]!=0xff{_ddae =false ;break ;};};if _ddae {switch _ebcd :=_ccd .(type ){case *NRGBA32 :_ebcd .Alpha =nil ;case *NRGBA64 :_ebcd .Alpha =nil ;default:return _e .Errorf ("i\u006ete\u0072n\u0061l\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020i\u006d\u0061\u0067\u0065\u0020s\u0068\u006f\u0075l\u0064\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0074\u0079\u0070e\u0020\u002a\u004eRGB\u0041\u0033\u0032\u0020\u006f\u0072 \u002a\u004e\u0052\u0047\u0042\u0041\u0036\u0034\u0020\u0062\u0075\u0074 \u0069s\u003a\u0020\u0025\u0054",_ccd );};};return nil ;};func (_cea *Monochrome )At (x ,y int )_cb .Color {_gaf ,_ :=_cea .ColorAt (x ,y );return _gaf };func ColorAtGray2BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_cb .Gray ,error ){_cfb :=y *bytesPerLine +x >>2;if _cfb >=len (data ){return _cb .Gray {},_e .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_bbac :=data [_cfb ]>>uint (6-(x &3)*2)&3;if len (decode )==2{_bbac =uint8 (uint32 (LinearInterpolate (float64 (_bbac ),0,3.0,decode [0],decode [1]))&3);};return _cb .Gray {Y :_bbac *85},nil ;};var _ Image =&NRGBA16 {};func _aaa (_egg _cb .NRGBA )_cb .Gray {_cfg ,_aceb ,_ddb ,_ :=_egg .RGBA ();_cefg :=(19595*_cfg +38470*_aceb +7471*_ddb +1<<15)>>24;return _cb .Gray {Y :uint8 (_cefg )};};func _aabb (_cdd _cb .RGBA )_cb .NRGBA {switch _cdd .A {case 0xff:return _cb .NRGBA {R :_cdd .R ,G :_cdd .G ,B :_cdd .B ,A :0xff};case 0x00:return _cb .NRGBA {};default:_efb ,_dba ,_cde ,_becc :=_cdd .RGBA ();_efb =(_efb *0xffff)/_becc ;_dba =(_dba *0xffff)/_becc ;_cde =(_cde *0xffff)/_becc ;return _cb .NRGBA {R :uint8 (_efb >>8),G :uint8 (_dba >>8),B :uint8 (_cde >>8),A :uint8 (_becc >>8)};};};func (_dgff *Gray4 )Set (x ,y int ,c _cb .Color ){if x >=_dgff .Width ||y >=_dgff .Height {return ;};_dbcd :=Gray4Model .Convert (c ).(_cb .Gray );_dgff .setGray (x ,y ,_dbcd );};func (_eeba *NRGBA32 )Base ()*ImageBase {return &_eeba .ImageBase };func (_dfag *Gray2 )ColorModel ()_cb .Model {return Gray2Model };func (_ffc *Monochrome )Validate ()error {if len (_ffc .Data )!=_ffc .Height *_ffc .BytesPerLine {return ErrInvalidImage ;};return nil ;};func _fdb (_gfgb nrgba64 ,_adfe NRGBA ,_fdcg _g .Rectangle ){for _gefd :=0;_gefd < _fdcg .Max .X ;_gefd ++{for _aaec :=0;_aaec < _fdcg .Max .Y ;_aaec ++{_bedd :=_gfgb .NRGBA64At (_gefd ,_aaec );_adfe .SetNRGBA (_gefd ,_aaec ,_ec (_bedd ));};};};func (_adf monochromeModel )Convert (c _cb .Color )_cb .Color {_baa :=_cb .GrayModel .Convert (c ).(_cb .Gray );return _dbdc (_baa ,_adf );};func _ec (_bdg _cb .NRGBA64 )_cb .NRGBA {return _cb .NRGBA {R :uint8 (_bdg .R >>8),G :uint8 (_bdg .G >>8),B :uint8 (_bdg .B >>8),A :uint8 (_bdg .A >>8)};};func ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine int ,data []byte ,decode []float64 )(_cb .Color ,error ){switch bitsPerColor {case 1:return ColorAtGray1BPC (x ,y ,bytesPerLine ,data ,decode );case 2:return ColorAtGray2BPC (x ,y ,bytesPerLine ,data ,decode );case 4:return ColorAtGray4BPC (x ,y ,bytesPerLine ,data ,decode );case 8:return ColorAtGray8BPC (x ,y ,bytesPerLine ,data ,decode );case 16:return ColorAtGray16BPC (x ,y ,bytesPerLine ,data ,decode );default:return nil ,_e .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0067\u0072\u0061\u0079\u0020\u0073c\u0061\u006c\u0065\u0020\u0062\u0069\u0074s\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020a\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );};};func (_fbe *Gray2 )SetGray (x ,y int ,gray _cb .Gray ){_ege :=_fceg (gray );_fabe :=y *_fbe .BytesPerLine ;_egga :=_fabe +(x >>2);if _egga >=len (_fbe .Data ){return ;};_bbb :=_ege .Y >>6;_fbe .Data [_egga ]=(_fbe .Data [_egga ]&(^(0xc0>>uint (2*((x )&3)))))|(_bbb <<uint (6-2*(x &3)));};func (_acda *Gray4 )Histogram ()(_bafc [256]int ){for _dca :=0;_dca < _acda .Width ;_dca ++{for _gad :=0;_gad < _acda .Height ;_gad ++{_bafc [_acda .GrayAt (_dca ,_gad ).Y ]++;};};return _bafc ;};func _abfb (_eed uint8 )bool {if _eed ==0||_eed ==255{return true ;};return false ;};func (_def *NRGBA16 )At (x ,y int )_cb .Color {_cafd ,_ :=_def .ColorAt (x ,y );return _cafd };func (_aege *Gray2 )Bounds ()_g .Rectangle {return _g .Rectangle {Max :_g .Point {X :_aege .Width ,Y :_aege .Height }};};func (_egee *Gray8 )GrayAt (x ,y int )_cb .Gray {_fece ,_ :=ColorAtGray8BPC (x ,y ,_egee .BytesPerLine ,_egee .Data ,_egee .Decode );return _fece ;};var _ Gray =&Gray4 {};func ColorAt (x ,y ,width ,bitsPerColor ,colorComponents ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_cb .Color ,error ){switch colorComponents {case 1:return ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine ,data ,decode );case 3:return ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor ,data ,alpha ,decode );case 4:return ColorAtCMYK (x ,y ,width ,data ,decode );default:return nil ,_e .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0063o\u006c\u006f\u0072\u0020\u0063\u006f\u006dp\u006f\u006e\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0064",colorComponents );};};func (_fga *Gray4 )SetGray (x ,y int ,g _cb .Gray ){if x >=_fga .Width ||y >=_fga .Height {return ;};g =_debb (g );_fga .setGray (x ,y ,g );};type Gray8 struct{ImageBase };func (_ebbc *NRGBA16 )Bounds ()_g .Rectangle {return _g .Rectangle {Max :_g .Point {X :_ebbc .Width ,Y :_ebbc .Height }};};func (_dad *Gray2 )GrayAt (x ,y int )_cb .Gray {_bfb ,_ :=ColorAtGray2BPC (x ,y ,_dad .BytesPerLine ,_dad .Data ,_dad .Decode );return _bfb ;};func _eggf (_acb _cb .CMYK )_cb .Gray {_da ,_dg ,_cag :=_cb .CMYKToRGB (_acb .C ,_acb .M ,_acb .Y ,_acb .K );_agc :=(19595*uint32 (_da )+38470*uint32 (_dg )+7471*uint32 (_cag )+1<<7)>>16;return _cb .Gray {Y :uint8 (_agc )};};func (_ebg *Gray2 )Base ()*ImageBase {return &_ebg .ImageBase };func (_cef *CMYK32 )ColorAt (x ,y int )(_cb .Color ,error ){return ColorAtCMYK (x ,y ,_cef .Width ,_cef .Data ,_cef .Decode );};func _adde (_dacg NRGBA ,_bced Gray ,_agca _g .Rectangle ){for _gdc :=0;_gdc < _agca .Max .X ;_gdc ++{for _dbfa :=0;_dbfa < _agca .Max .Y ;_dbfa ++{_ece :=_aaa (_dacg .NRGBAAt (_gdc ,_dbfa ));_bced .SetGray (_gdc ,_dbfa ,_ece );};};};var _ Image =&Gray16 {};func (_eab *Monochrome )setGray (_fff int ,_gcd _cb .Gray ,_efcg int ){if _gcd .Y ==0{_eab .clearBit (_efcg ,_fff );}else {_eab .setBit (_efcg ,_fff );};};func (_cadc *NRGBA16 )Validate ()error {if len (_cadc .Data )!=3*_cadc .Width *_cadc .Height /2{return _b .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");};return nil ;};func _cg (_gb ,_cd CMYK ,_ace _g .Rectangle ){for _fcfd :=0;_fcfd < _ace .Max .X ;_fcfd ++{for _gf :=0;_gf < _ace .Max .Y ;_gf ++{_cd .SetCMYK (_fcfd ,_gf ,_gb .CMYKAt (_fcfd ,_gf ));};};};func (_ceag *NRGBA64 )ColorAt (x ,y int )(_cb .Color ,error ){return ColorAtNRGBA64 (x ,y ,_ceag .Width ,_ceag .Data ,_ceag .Alpha ,_ceag .Decode );};func ColorAtNRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_cb .NRGBA ,error ){_ccgf :=y *width +x ;_bfcb :=3*_ccgf ;if _bfcb +2>=len (data ){return _cb .NRGBA {},_e .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_bdbg :=uint8 (0xff);if alpha !=nil &&len (alpha )> _ccgf {_bdbg =alpha [_ccgf ];};_cgg ,_ceca ,_facbc :=data [_bfcb ],data [_bfcb +1],data [_bfcb +2];if len (decode )==6{_cgg =uint8 (uint32 (LinearInterpolate (float64 (_cgg ),0,255,decode [0],decode [1]))&0xff);_ceca =uint8 (uint32 (LinearInterpolate (float64 (_ceca ),0,255,decode [2],decode [3]))&0xff);_facbc =uint8 (uint32 (LinearInterpolate (float64 (_facbc ),0,255,decode [4],decode [5]))&0xff);};return _cb .NRGBA {R :_cgg ,G :_ceca ,B :_facbc ,A :_bdbg },nil ;};func (_eac *NRGBA32 )Bounds ()_g .Rectangle {return _g .Rectangle {Max :_g .Point {X :_eac .Width ,Y :_eac .Height }};};func _cbba (_dfa _cb .CMYK )_cb .NRGBA {_bae ,_dbf ,_dec :=_cb .CMYKToRGB (_dfa .C ,_dfa .M ,_dfa .Y ,_dfa .K );return _cb .NRGBA {R :_bae ,G :_dbf ,B :_dec ,A :0xff};};type Histogramer interface{Histogram ()[256]int ;};func _abd (_bege RGBA ,_afdeb NRGBA ,_ebbf _g .Rectangle ){for _aegb :=0;_aegb < _ebbf .Max .X ;_aegb ++{for _ggf :=0;_ggf < _ebbf .Max .Y ;_ggf ++{_dbdcd :=_bege .RGBAAt (_aegb ,_ggf );_afdeb .SetNRGBA (_aegb ,_ggf ,_aabb (_dbdcd ));};};};func _fgca (_afbg _g .Image )(Image ,error ){if _bedg ,_afd :=_afbg .(*Gray2 );_afd {return _bedg .Copy (),nil ;};_acef :=_afbg .Bounds ();_add ,_fea :=NewImage (_acef .Max .X ,_acef .Max .Y ,2,1,nil ,nil ,nil );if _fea !=nil {return nil ,_fea ;};_ddf (_afbg ,_add ,_acef );return _add ,nil ;};func (_ffgb *Gray16 )Bounds ()_g .Rectangle {return _g .Rectangle {Max :_g .Point {X :_ffgb .Width ,Y :_ffgb .Height }};};var _ Image =&NRGBA64 {};func (_gceg *NRGBA64 )Copy ()Image {return &NRGBA64 {ImageBase :_gceg .copy ()}};func (_dcc *Gray4 )Bounds ()_g .Rectangle {return _g .Rectangle {Max :_g .Point {X :_dcc .Width ,Y :_dcc .Height }};};func (_bdef *NRGBA32 )At (x ,y int )_cb .Color {_gdf ,_ :=_bdef .ColorAt (x ,y );return _gdf };func (_cbbc *Gray16 )SetGray (x ,y int ,g _cb .Gray ){_abca :=(y *_cbbc .BytesPerLine /2+x )*2;if _abca +1>=len (_cbbc .Data ){return ;};_cbbc .Data [_abca ]=g .Y ;_cbbc .Data [_abca +1]=g .Y ;};func ColorAtGray8BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_cb .Gray ,error ){_gge :=y *bytesPerLine +x ;if _gge >=len (data ){return _cb .Gray {},_e .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_dae :=data [_gge ];if len (decode )==2{_dae =uint8 (uint32 (LinearInterpolate (float64 (_dae ),0,255,decode [0],decode [1]))&0xff);};return _cb .Gray {Y :_dae },nil ;};var _ _g .Image =&Monochrome {};type CMYK32 struct{ImageBase };func _ae (_fc _g .Image )(Image ,error ){if _fcf ,_aeb :=_fc .(*CMYK32 );_aeb {return _fcf .Copy (),nil ;};_gee :=_fc .Bounds ();_fdg ,_cbc :=NewImage (_gee .Max .X ,_gee .Max .Y ,8,4,nil ,nil ,nil );if _cbc !=nil {return nil ,_cbc ;};switch _fa :=_fc .(type ){case CMYK :_cg (_fa ,_fdg .(CMYK ),_gee );case Gray :_fe (_fa ,_fdg .(CMYK ),_gee );case NRGBA :_cbb (_fa ,_fdg .(CMYK ),_gee );case RGBA :_gac (_fa ,_fdg .(CMYK ),_gee );default:_cf (_fc ,_fdg ,_gee );};return _fdg ,nil ;};var _ _g .Image =&NRGBA32 {};func (_eebb *NRGBA16 )Copy ()Image {return &NRGBA16 {ImageBase :_eebb .copy ()}};func _cc (_bf _cb .RGBA )_cb .Gray {_baed :=(19595*uint32 (_bf .R )+38470*uint32 (_bf .G )+7471*uint32 (_bf .B )+1<<7)>>16;return _cb .Gray {Y :uint8 (_baed )};};func _dbbf (_ggd _cb .NRGBA )_cb .NRGBA {_ggd .R =_ggd .R >>4|(_ggd .R >>4)<<4;_ggd .G =_ggd .G >>4|(_ggd .G >>4)<<4;_ggd .B =_ggd .B >>4|(_ggd .B >>4)<<4;return _ggd ;};func GetConverter (bitsPerComponent ,colorComponents int )(ColorConverter ,error ){switch colorComponents {case 1:switch bitsPerComponent {case 1:return MonochromeConverter ,nil ;case 2:return Gray2Converter ,nil ;case 4:return Gray4Converter ,nil ;case 8:return GrayConverter ,nil ;case 16:return Gray16Converter ,nil ;};case 3:switch bitsPerComponent {case 4:return NRGBA16Converter ,nil ;case 8:return NRGBAConverter ,nil ;case 16:return NRGBA64Converter ,nil ;};case 4:return CMYKConverter ,nil ;};return nil ,_e .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0043o\u006e\u0076\u0065\u0072\u0074\u0065\u0072\u0020\u0070\u0061\u0072\u0061\u006d\u0065t\u0065\u0072\u0073\u002e\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003a\u0020\u0025\u0064\u002c\u0020\u0043\u006f\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006et\u0073\u003a \u0025\u0064",bitsPerComponent ,colorComponents );};func (_abg *NRGBA64 )Base ()*ImageBase {return &_abg .ImageBase };func (_gbcc *Monochrome )clearBit (_bfe ,_ecd int ){_gbcc .Data [_bfe ]&=^(0x80>>uint (_ecd &7))};func FromGoImage (i _g .Image )(Image ,error ){switch _dcb :=i .(type ){case Image :return _dcb .Copy (),nil ;case Gray :return GrayConverter .Convert (i );case *_g .Gray16 :return Gray16Converter .Convert (i );case CMYK :return CMYKConverter .Convert (i );case *_g .NRGBA64 :return NRGBA64Converter .Convert (i );default:return NRGBAConverter .Convert (i );};};func (_gdb *Gray2 )ColorAt (x ,y int )(_cb .Color ,error ){return ColorAtGray2BPC (x ,y ,_gdb .BytesPerLine ,_gdb .Data ,_gdb .Decode );};var _ NRGBA =&NRGBA32 {};var _ Image =&Gray8 {};func (_dedb *Gray4 )Copy ()Image {return &Gray4 {ImageBase :_dedb .copy ()}};func (_gfd *Gray8 )ColorModel ()_cb .Model {return _cb .GrayModel };type Gray4 struct{ImageBase };var _ _g .Image =&Gray16 {};func _bcbc (_dgfgd ,_bfba NRGBA ,_gbccf _g .Rectangle ){for _adeb :=0;_adeb < _gbccf .Max .X ;_adeb ++{for _aaf :=0;_aaf < _gbccf .Max .Y ;_aaf ++{_bfba .SetNRGBA (_adeb ,_aaf ,_dgfgd .NRGBAAt (_adeb ,_aaf ));};};};type CMYK interface{CMYKAt (_bg ,_ge int )_cb .CMYK ;SetCMYK (_bd ,_de int ,_ed _cb .CMYK );};func (_efg *Gray2 )Histogram ()(_acd [256]int ){for _ccg :=0;_ccg < _efg .Width ;_ccg ++{for _gea :=0;_gea < _efg .Height ;_gea ++{_acd [_efg .GrayAt (_ccg ,_gea ).Y ]++;};};return _acd ;};func _gfde (_eee _g .Image )(Image ,error ){if _fedd ,_beba :=_eee .(*NRGBA64 );_beba {return _fedd .Copy (),nil ;};_deag ,_eaca ,_dbbg :=_cebg (_eee ,2);_efade ,_dgfg :=NewImage (_deag .Max .X ,_deag .Max .Y ,16,3,nil ,_dbbg ,nil );if _dgfg !=nil {return nil ,_dgfg ;};_deac (_eee ,_efade ,_deag );if len (_dbbg )!=0&&!_eaca {if _eea :=_cbeg (_dbbg ,_efade );_eea !=nil {return nil ,_eea ;};};return _efade ,nil ;};func (_aaba *NRGBA64 )setNRGBA64 (_adbg int ,_bgbe _cb .NRGBA64 ,_fdcf int ){_aaba .Data [_adbg ]=uint8 (_bgbe .R >>8);_aaba .Data [_adbg +1]=uint8 (_bgbe .R &0xff);_aaba .Data [_adbg +2]=uint8 (_bgbe .G >>8);_aaba .Data [_adbg +3]=uint8 (_bgbe .G &0xff);_aaba .Data [_adbg +4]=uint8 (_bgbe .B >>8);_aaba .Data [_adbg +5]=uint8 (_bgbe .B &0xff);if _fdcf +1< len (_aaba .Alpha ){_aaba .Alpha [_fdcf ]=uint8 (_bgbe .A >>8);_aaba .Alpha [_fdcf +1]=uint8 (_bgbe .A &0xff);};};func (_ebgcg *NRGBA64 )At (x ,y int )_cb .Color {_bded ,_ :=_ebgcg .ColorAt (x ,y );return _bded };func ColorAtGray1BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_cb .Gray ,error ){_dacb :=y *bytesPerLine +x >>3;if _dacb >=len (data ){return _cb .Gray {},_e .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_dgf :=data [_dacb ]>>uint (7-(x &7))&1;if len (decode )==2{_dgf =uint8 (LinearInterpolate (float64 (_dgf ),0.0,1.0,decode [0],decode [1]))&1;};return _cb .Gray {Y :_dgf *255},nil ;};func (_fffb *Gray16 )GrayAt (x ,y int )_cb .Gray {_bad ,_ :=_fffb .ColorAt (x ,y );return _cb .Gray {Y :uint8 (_bad .(_cb .Gray16 ).Y >>8)};};func (_eeg *CMYK32 )Bounds ()_g .Rectangle {return _g .Rectangle {Max :_g .Point {X :_eeg .Width ,Y :_eeg .Height }};};func _fae (){for _ffgg :=0;_ffgg < 256;_ffgg ++{_eggfc [_ffgg ]=uint8 (_ffgg &0x1)+(uint8 (_ffgg >>1)&0x1)+(uint8 (_ffgg >>2)&0x1)+(uint8 (_ffgg >>3)&0x1)+(uint8 (_ffgg >>4)&0x1)+(uint8 (_ffgg >>5)&0x1)+(uint8 (_ffgg >>6)&0x1)+(uint8 (_ffgg >>7)&0x1);};};func (_fb *CMYK32 )At (x ,y int )_cb .Color {_ba ,_ :=_fb .ColorAt (x ,y );return _ba };type Gray16 struct{ImageBase };type Gray2 struct{ImageBase };func (_a *CMYK32 )Base ()*ImageBase {return &_a .ImageBase };var _ Image =&NRGBA32 {};func (_acgd *Monochrome )Copy ()Image {return &Monochrome {ImageBase :_acgd .ImageBase .copy (),ModelThreshold :_acgd .ModelThreshold };};func _eaag (_ebag ,_fgg uint8 )uint8 {if _ebag < _fgg {return 255;};return 0;};type NRGBA16 struct{ImageBase };func _egfd (_bed _cb .RGBA )_cb .CMYK {_ceb ,_faa ,_gbc ,_ddc :=_cb .RGBToCMYK (_bed .R ,_bed .G ,_bed .B );return _cb .CMYK {C :_ceb ,M :_faa ,Y :_gbc ,K :_ddc };};var _ Gray =&Gray8 {};func (_bdba *NRGBA16 )Base ()*ImageBase {return &_bdba .ImageBase };func _fbf (_caad *_g .Gray16 ,_afdf uint8 )*_g .Gray {_cge :=_caad .Bounds ();_gbgg :=_g .NewGray (_cge );for _ggb :=0;_ggb < _cge .Dx ();_ggb ++{for _afdg :=0;_afdg < _cge .Dy ();_afdg ++{_gbgdd :=_caad .Gray16At (_ggb ,_afdg );_gbgg .SetGray (_ggb ,_afdg ,_cb .Gray {Y :_eaag (uint8 (_gbgdd .Y /256),_afdf )});};};return _gbgg ;};type SMasker interface{HasAlpha ()bool ;GetAlpha ()[]byte ;MakeAlpha ();};func (_bbd *Gray16 )Copy ()Image {return &Gray16 {ImageBase :_bbd .copy ()}};func IsGrayImgBlackAndWhite (i *_g .Gray )bool {return _ede (i )};func NewImageBase (width int ,height int ,bitsPerComponent int ,colorComponents int ,data []byte ,alpha []byte ,decode []float64 )ImageBase {_gcaa :=ImageBase {Width :width ,Height :height ,BitsPerComponent :bitsPerComponent ,ColorComponents :colorComponents ,Data :data ,Alpha :alpha ,Decode :decode ,BytesPerLine :BytesPerLine (width ,bitsPerComponent ,colorComponents )};if data ==nil {_gcaa .Data =make ([]byte ,height *_gcaa .BytesPerLine );};return _gcaa ;};func (_dac *monochromeThresholdConverter )Convert (img _g .Image )(Image ,error ){if _fce ,_acg :=img .(*Monochrome );_acg {return _fce .Copy (),nil ;};_fab :=img .Bounds ();_bcfe ,_bgc :=NewImage (_fab .Max .X ,_fab .Max .Y ,1,1,nil ,nil ,nil );if _bgc !=nil {return nil ,_bgc ;};_bcfe .(*Monochrome ).ModelThreshold =_dac .Threshold ;for _dede :=0;_dede < _fab .Max .X ;_dede ++{for _bbe :=0;_bbe < _fab .Max .Y ;_bbe ++{_ecb :=img .At (_dede ,_bbe );_bcfe .Set (_dede ,_bbe ,_ecb );};};return _bcfe ,nil ;};func _deac (_gbea _g .Image ,_aedd Image ,_ecaa _g .Rectangle ){if _cgcf ,_dgcg :=_gbea .(SMasker );_dgcg &&_cgcf .HasAlpha (){_aedd .(SMasker ).MakeAlpha ();};_cf (_gbea ,_aedd ,_ecaa );};