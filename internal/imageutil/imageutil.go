//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package imageutil ;import (_d "errors";_f "fmt";_fb "github.com/unidoc/unipdf/v3/internal/bitwise";_a "image";_b "image/color";_bf "image/draw";_dg "math";);func _dgdb (_dbg _b .RGBA )_b .CMYK {_cdee ,_cge ,_agcd ,_aaf :=_b .RGBToCMYK (_dbg .R ,_dbg .G ,_dbg .B );return _b .CMYK {C :_cdee ,M :_cge ,Y :_agcd ,K :_aaf };};func (_beb *Gray2 )Validate ()error {if len (_beb .Data )!=_beb .Height *_beb .BytesPerLine {return ErrInvalidImage ;};return nil ;};func _adbb (_fcgb _b .NRGBA )_b .NRGBA {_fcgb .R =_fcgb .R >>4|(_fcgb .R >>4)<<4;_fcgb .G =_fcgb .G >>4|(_fcgb .G >>4)<<4;_fcgb .B =_fcgb .B >>4|(_fcgb .B >>4)<<4;return _fcgb ;};func (_gadb *Gray8 )ColorAt (x ,y int )(_b .Color ,error ){return ColorAtGray8BPC (x ,y ,_gadb .BytesPerLine ,_gadb .Data ,_gadb .Decode );};func (_ea *CMYK32 )Bounds ()_a .Rectangle {return _a .Rectangle {Max :_a .Point {X :_ea .Width ,Y :_ea .Height }};};func (_bddg *ImageBase )MakeAlpha (){_bddg .newAlpha ()};var _ Image =&Gray16 {};type Gray4 struct{ImageBase };func (_dcaa *NRGBA32 )Bounds ()_a .Rectangle {return _a .Rectangle {Max :_a .Point {X :_dcaa .Width ,Y :_dcaa .Height }};};func (_ageb *Gray8 )Set (x ,y int ,c _b .Color ){_cgcg :=y *_ageb .BytesPerLine +x ;if _cgcg > len (_ageb .Data )-1{return ;};_baf :=_b .GrayModel .Convert (c );_ageb .Data [_cgcg ]=_baf .(_b .Gray ).Y ;};func (_ddg *NRGBA32 )SetNRGBA (x ,y int ,c _b .NRGBA ){_fbfd :=y *_ddg .Width +x ;_fgfba :=3*_fbfd ;if _fgfba +2>=len (_ddg .Data ){return ;};_ddg .setRGBA (_fbfd ,c );return ;};func (_gcag *Gray8 )ColorModel ()_b .Model {return _b .GrayModel };func (_cfc *Monochrome )Copy ()Image {return &Monochrome {ImageBase :_cfc .ImageBase .copy (),ModelThreshold :_cfc .ModelThreshold };};var _ _a .Image =&NRGBA32 {};func ImgToBinary (i _a .Image ,threshold uint8 )*_a .Gray {switch _fgggdf :=i .(type ){case *_a .Gray :if _bfb (_fgggdf ){return _fgggdf ;};return _fdge (_fgggdf ,threshold );case *_a .Gray16 :return _eagc (_fgggdf ,threshold );default:return _bgeb (_fgggdf ,threshold );};};var _ Gray =&Gray8 {};func _bgeb (_ecf _a .Image ,_fdba uint8 )*_a .Gray {_adeg :=_ecf .Bounds ();_efb :=_a .NewGray (_adeg );var (_bbe _b .Color ;_feeb _b .Gray ;);for _cdcd :=0;_cdcd < _adeg .Max .X ;_cdcd ++{for _deda :=0;_deda < _adeg .Max .Y ;_deda ++{_bbe =_ecf .At (_cdcd ,_deda );_efb .Set (_cdcd ,_deda ,_bbe );_feeb =_efb .GrayAt (_cdcd ,_deda );_efb .SetGray (_cdcd ,_deda ,_b .Gray {Y :_eeee (_feeb .Y ,_fdba )});};};return _efb ;};func (_beg *Gray2 )Base ()*ImageBase {return &_beg .ImageBase };func LinearInterpolate (x ,xmin ,xmax ,ymin ,ymax float64 )float64 {if _dg .Abs (xmax -xmin )< 0.000001{return ymin ;};_cebg :=ymin +(x -xmin )*(ymax -ymin )/(xmax -xmin );return _cebg ;};func _fdge (_adcb *_a .Gray ,_bcdb uint8 )*_a .Gray {_fbfe :=_adcb .Bounds ();_gbda :=_a .NewGray (_fbfe );for _fgag :=0;_fgag < _fbfe .Dx ();_fgag ++{for _gbgc :=0;_gbgc < _fbfe .Dy ();_gbgc ++{_fegb :=_adcb .GrayAt (_fgag ,_gbgc );_gbda .SetGray (_fgag ,_gbgc ,_b .Gray {Y :_eeee (_fegb .Y ,_bcdb )});};};return _gbda ;};func _fcfaf (_bef RGBA ,_fgggd Gray ,_gedg _a .Rectangle ){for _feag :=0;_feag < _gedg .Max .X ;_feag ++{for _fcg :=0;_fcg < _gedg .Max .Y ;_fcg ++{_becd :=_gbc (_bef .RGBAAt (_feag ,_fcg ));_fgggd .SetGray (_feag ,_fcg ,_becd );};};};type CMYK interface{CMYKAt (_gf ,_ga int )_b .CMYK ;SetCMYK (_af ,_db int ,_c _b .CMYK );};func GrayHistogram (g Gray )(_cfbdg [256]int ){switch _gaea :=g .(type ){case Histogramer :return _gaea .Histogram ();case _a .Image :_cgd :=_gaea .Bounds ();for _fef :=0;_fef < _cgd .Max .X ;_fef ++{for _egab :=0;_egab < _cgd .Max .Y ;_egab ++{_cfbdg [g .GrayAt (_fef ,_egab ).Y ]++;};};return _cfbdg ;default:return [256]int {};};};func (_fda *Monochrome )setBit (_gag ,_afc int ){_fda .Data [_gag ]|=0x80>>uint (_afc &7)};func (_gfa *Gray2 )Copy ()Image {return &Gray2 {ImageBase :_gfa .copy ()}};var _ Image =&Gray8 {};func (_eae *Monochrome )Set (x ,y int ,c _b .Color ){_dbgf :=y *_eae .BytesPerLine +x >>3;if _dbgf > len (_eae .Data )-1{return ;};_abe :=_eae .ColorModel ().Convert (c ).(_b .Gray );_eae .setGray (x ,_abe ,_dbgf );};var _ Gray =&Gray4 {};func _bdd (_eagf _a .Image )(Image ,error ){if _cae ,_fggg :=_eagf .(*Gray2 );_fggg {return _cae .Copy (),nil ;};_ddfa :=_eagf .Bounds ();_bccb ,_geag :=NewImage (_ddfa .Max .X ,_ddfa .Max .Y ,2,1,nil ,nil ,nil );if _geag !=nil {return nil ,_geag ;};_cbe (_eagf ,_bccb ,_ddfa );return _bccb ,nil ;};func _gc (_dbbg _b .CMYK )_b .Gray {_bcda ,_ffe ,_gbd :=_b .CMYKToRGB (_dbbg .C ,_dbbg .M ,_dbbg .Y ,_dbbg .K );_dbd :=(19595*uint32 (_bcda )+38470*uint32 (_ffe )+7471*uint32 (_gbd )+1<<7)>>16;return _b .Gray {Y :uint8 (_dbd )};};func (_dab *Monochrome )At (x ,y int )_b .Color {_cbdg ,_ :=_dab .ColorAt (x ,y );return _cbdg };func (_bdg *Gray8 )Base ()*ImageBase {return &_bdg .ImageBase };func ColorAtGray4BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_b .Gray ,error ){_eadd :=y *bytesPerLine +x >>1;if _eadd >=len (data ){return _b .Gray {},_f .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_efd :=data [_eadd ]>>uint (4-(x &1)*4)&0xf;if len (decode )==2{_efd =uint8 (uint32 (LinearInterpolate (float64 (_efd ),0,15,decode [0],decode [1]))&0xf);};return _b .Gray {Y :_efd *17&0xff},nil ;};func NewImageBase (width int ,height int ,bitsPerComponent int ,colorComponents int ,data []byte ,alpha []byte ,decode []float64 )ImageBase {_dee :=ImageBase {Width :width ,Height :height ,BitsPerComponent :bitsPerComponent ,ColorComponents :colorComponents ,Data :data ,Alpha :alpha ,Decode :decode ,BytesPerLine :BytesPerLine (width ,bitsPerComponent ,colorComponents )};if data ==nil {_dee .Data =make ([]byte ,height *_dee .BytesPerLine );};return _dee ;};func (_bgbe *NRGBA32 )ColorModel ()_b .Model {return _b .NRGBAModel };func (_ebgg *NRGBA16 )Validate ()error {if len (_ebgg .Data )!=3*_ebgg .Width *_ebgg .Height /2{return _d .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");};return nil ;};func (_ceab *Gray4 )GrayAt (x ,y int )_b .Gray {_eabf ,_ :=ColorAtGray4BPC (x ,y ,_ceab .BytesPerLine ,_ceab .Data ,_ceab .Decode );return _eabf ;};type ImageBase struct{Width ,Height int ;BitsPerComponent ,ColorComponents int ;Data ,Alpha []byte ;Decode []float64 ;BytesPerLine int ;};func (_bgf *Monochrome )Histogram ()(_aba [256]int ){for _ ,_gaf :=range _bgf .Data {_aba [0xff]+=int (_cebf [_bgf .Data [_gaf ]]);};return _aba ;};func init (){_aef ()};func (_bdb *Gray4 )Histogram ()(_bgb [256]int ){for _dggc :=0;_dggc < _bdb .Width ;_dggc ++{for _afa :=0;_afa < _bdb .Height ;_afa ++{_bgb [_bdb .GrayAt (_dggc ,_afa ).Y ]++;};};return _bgb ;};func (_aec *NRGBA32 )setRGBA (_afgb int ,_gbdbf _b .NRGBA ){_aag :=3*_afgb ;_aec .Data [_aag ]=_gbdbf .R ;_aec .Data [_aag +1]=_gbdbf .G ;_aec .Data [_aag +2]=_gbdbf .B ;if _afgb < len (_aec .Alpha ){_aec .Alpha [_afgb ]=_gbdbf .A ;};};func (_fdb *NRGBA32 )NRGBAAt (x ,y int )_b .NRGBA {_bdgg ,_ :=ColorAtNRGBA32 (x ,y ,_fdb .Width ,_fdb .Data ,_fdb .Alpha ,_fdb .Decode );return _bdgg ;};func (_cbdb *NRGBA16 )ColorModel ()_b .Model {return NRGBA16Model };func ColorAtNRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_b .NRGBA ,error ){_acdd :=y *width +x ;_fbfdd :=3*_acdd ;if _fbfdd +2>=len (data ){return _b .NRGBA {},_f .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_fge :=uint8 (0xff);if alpha !=nil &&len (alpha )> _acdd {_fge =alpha [_acdd ];};_egaa ,_eaad ,_egg :=data [_fbfdd ],data [_fbfdd +1],data [_fbfdd +2];if len (decode )==6{_egaa =uint8 (uint32 (LinearInterpolate (float64 (_egaa ),0,255,decode [0],decode [1]))&0xff);_eaad =uint8 (uint32 (LinearInterpolate (float64 (_eaad ),0,255,decode [2],decode [3]))&0xff);_egg =uint8 (uint32 (LinearInterpolate (float64 (_egg ),0,255,decode [4],decode [5]))&0xff);};return _b .NRGBA {R :_egaa ,G :_eaad ,B :_egg ,A :_fge },nil ;};func _fgda (_ccf _a .Image ,_bbb Image ,_cdab _a .Rectangle ){if _cfbd ,_abbc :=_ccf .(SMasker );_abbc &&_cfbd .HasAlpha (){_bbb .(SMasker ).MakeAlpha ();};switch _eeae :=_ccf .(type ){case Gray :_fdg (_eeae ,_bbb .(NRGBA ),_cdab );case NRGBA :_bdfd (_eeae ,_bbb .(NRGBA ),_cdab );case CMYK :_ebcg (_eeae ,_bbb .(NRGBA ),_cdab );case RGBA :_cdf (_eeae ,_bbb .(NRGBA ),_cdab );default:_gdg (_ccf ,_bbb ,_cdab );};};var _ Image =&NRGBA16 {};func _cdeb (_ecc _b .Gray )_b .Gray {_ecc .Y >>=4;_ecc .Y |=_ecc .Y <<4;return _ecc };func (_cfe *Monochrome )Bounds ()_a .Rectangle {return _a .Rectangle {Max :_a .Point {X :_cfe .Width ,Y :_cfe .Height }};};func (_gcd *Gray4 )Bounds ()_a .Rectangle {return _a .Rectangle {Max :_a .Point {X :_gcd .Width ,Y :_gcd .Height }};};func _dbge (_ddf _b .Gray )_b .Gray {_eded :=_ddf .Y >>6;_eded |=_eded <<2;_ddf .Y =_eded |_eded <<4;return _ddf ;};func (_bb *CMYK32 )Base ()*ImageBase {return &_bb .ImageBase };func (_adae *NRGBA16 )At (x ,y int )_b .Color {_faa ,_ :=_adae .ColorAt (x ,y );return _faa };func (_fded *Gray8 )At (x ,y int )_b .Color {_cbfde ,_ :=_fded .ColorAt (x ,y );return _cbfde };func (_ffb *NRGBA32 )ColorAt (x ,y int )(_b .Color ,error ){return ColorAtNRGBA32 (x ,y ,_ffb .Width ,_ffb .Data ,_ffb .Alpha ,_ffb .Decode );};type Image interface{_bf .Image ;Base ()*ImageBase ;Copy ()Image ;Pix ()[]byte ;ColorAt (_aga ,_gdde int )(_b .Color ,error );Validate ()error ;};func _cbe (_fadc _a .Image ,_fbg Image ,_addd _a .Rectangle ){switch _caf :=_fadc .(type ){case Gray :_cegb (_caf ,_fbg .(Gray ),_addd );case NRGBA :_gdec (_caf ,_fbg .(Gray ),_addd );case CMYK :_eeag (_caf ,_fbg .(Gray ),_addd );case RGBA :_fcfaf (_caf ,_fbg .(Gray ),_addd );default:_gdg (_fadc ,_fbg .(Image ),_addd );};};var _ Gray =&Gray16 {};func (_ebb *Gray2 )GrayAt (x ,y int )_b .Gray {_aafe ,_ :=ColorAtGray2BPC (x ,y ,_ebb .BytesPerLine ,_ebb .Data ,_ebb .Decode );return _aafe ;};func (_gdb *NRGBA32 )At (x ,y int )_b .Color {_fadd ,_ :=_gdb .ColorAt (x ,y );return _fadd };func FromGoImage (i _a .Image )(Image ,error ){switch _ege :=i .(type ){case Image :return _ege .Copy (),nil ;case Gray :return GrayConverter .Convert (i );case CMYK :return CMYKConverter .Convert (i );default:return NRGBAConverter .Convert (i );};};func (_eda *Gray16 )ColorAt (x ,y int )(_b .Color ,error ){return ColorAtGray16BPC (x ,y ,_eda .BytesPerLine ,_eda .Data ,_eda .Decode );};func (_abaa *Gray8 )Bounds ()_a .Rectangle {return _a .Rectangle {Max :_a .Point {X :_abaa .Width ,Y :_abaa .Height }};};func (_bac *Gray2 )SetGray (x ,y int ,gray _b .Gray ){_adcf :=_dbge (gray );_dda :=y *_bac .BytesPerLine ;_fed :=_dda +(x >>2);if _fed >=len (_bac .Data ){return ;};_dffd :=_adcf .Y >>6;_bac .Data [_fed ]=(_bac .Data [_fed ]&(^(0xc0>>uint (2*((x )&3)))))|(_dffd <<uint (6-2*(x &3)));};func _bdfd (_decbd ,_bbdb NRGBA ,_bbc _a .Rectangle ){for _fbfb :=0;_fbfb < _bbc .Max .X ;_fbfb ++{for _dbcd :=0;_dbcd < _bbc .Max .Y ;_dbcd ++{_bbdb .SetNRGBA (_fbfb ,_dbcd ,_decbd .NRGBAAt (_fbfb ,_dbcd ));};};};func _cbb (_fgf _a .Image )(Image ,error ){if _fba ,_eaa :=_fgf .(*Gray4 );_eaa {return _fba .Copy (),nil ;};_gaecb :=_fgf .Bounds ();_cefc ,_dgfg :=NewImage (_gaecb .Max .X ,_gaecb .Max .Y ,4,1,nil ,nil ,nil );if _dgfg !=nil {return nil ,_dgfg ;};_cbe (_fgf ,_cefc ,_gaecb );return _cefc ,nil ;};func _bec (_ge ,_ace CMYK ,_gff _a .Rectangle ){for _bcd :=0;_bcd < _gff .Max .X ;_bcd ++{for _eg :=0;_eg < _gff .Max .Y ;_eg ++{_ace .SetCMYK (_bcd ,_eg ,_ge .CMYKAt (_bcd ,_eg ));};};};func (_cgg colorConverter )Convert (src _a .Image )(Image ,error ){return _cgg ._eb (src )};func (_bcde *ImageBase )HasAlpha ()bool {return _bcde .Alpha !=nil };type Gray2 struct{ImageBase };var _cebf [256]uint8 ;var _ _a .Image =&NRGBA64 {};var (MonochromeConverter =ConverterFunc (_dc );Gray2Converter =ConverterFunc (_bdd );Gray4Converter =ConverterFunc (_cbb );GrayConverter =ConverterFunc (_cade );Gray16Converter =ConverterFunc (_cfaa );NRGBA16Converter =ConverterFunc (_aeg );NRGBAConverter =ConverterFunc (_ceag );NRGBA64Converter =ConverterFunc (_caff );CMYKConverter =ConverterFunc (_fbf ););func (_fcfa *Gray16 )Copy ()Image {return &Gray16 {ImageBase :_fcfa .copy ()}};var _ _a .Image =&Gray2 {};func (_eabd *Monochrome )ColorAt (x ,y int )(_b .Color ,error ){return ColorAtGray1BPC (x ,y ,_eabd .BytesPerLine ,_eabd .Data ,_eabd .Decode );};type monochromeThresholdConverter struct{Threshold uint8 ;};var _ _a .Image =&Gray16 {};func _ceag (_abcg _a .Image )(Image ,error ){if _cdc ,_babae :=_abcg .(*NRGBA32 );_babae {return _cdc .Copy (),nil ;};_ffdc :=_abcg .Bounds ();_abcgc ,_geeg :=NewImage (_ffdc .Max .X ,_ffdc .Max .Y ,8,3,nil ,nil ,nil );if _geeg !=nil {return nil ,_geeg ;};_fgda (_abcg ,_abcgc ,_ffdc );return _abcgc ,nil ;};type Gray16 struct{ImageBase };type Histogramer interface{Histogram ()[256]int ;};func _afb (_ebd uint8 )bool {if _ebd ==0||_ebd ==255{return true ;};return false ;};var _ NRGBA =&NRGBA32 {};func (_df *CMYK32 )Validate ()error {if len (_df .Data )!=4*_df .Width *_df .Height {return _d .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");};return nil ;};func ColorAtGray16BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_b .Gray16 ,error ){_gdgc :=(y *bytesPerLine /2+x )*2;if _gdgc +1>=len (data ){return _b .Gray16 {},_f .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_acbe :=uint16 (data [_gdgc ])<<8|uint16 (data [_gdgc +1]);if len (decode )==2{_acbe =uint16 (uint64 (LinearInterpolate (float64 (_acbe ),0,65535,decode [0],decode [1])));};return _b .Gray16 {Y :_acbe },nil ;};func ColorAtNRGBA16 (x ,y ,width ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_b .NRGBA ,error ){_ced :=y *bytesPerLine +x *3/2;if _ced +1>=len (data ){return _b .NRGBA {},_gcc (x ,y );};const (_ade =0xf;_gdgb =uint8 (0xff););_bdc :=_gdgb ;if alpha !=nil {_egf :=y *BytesPerLine (width ,4,1);if _egf < len (alpha ){if x %2==0{_bdc =(alpha [_egf ]>>uint (4))&_ade ;}else {_bdc =alpha [_egf ]&_ade ;};_bdc |=_bdc <<4;};};var _bdgc ,_becg ,_cdba uint8 ;if x *3%2==0{_bdgc =(data [_ced ]>>uint (4))&_ade ;_becg =data [_ced ]&_ade ;_cdba =(data [_ced +1]>>uint (4))&_ade ;}else {_bdgc =data [_ced ]&_ade ;_becg =(data [_ced +1]>>uint (4))&_ade ;_cdba =data [_ced +1]&_ade ;};if len (decode )==6{_bdgc =uint8 (uint32 (LinearInterpolate (float64 (_bdgc ),0,15,decode [0],decode [1]))&0xf);_becg =uint8 (uint32 (LinearInterpolate (float64 (_becg ),0,15,decode [2],decode [3]))&0xf);_cdba =uint8 (uint32 (LinearInterpolate (float64 (_cdba ),0,15,decode [4],decode [5]))&0xf);};return _b .NRGBA {R :(_bdgc <<4)|(_bdgc &0xf),G :(_becg <<4)|(_becg &0xf),B :(_cdba <<4)|(_cdba &0xf),A :_bdc },nil ;};func (_fegf *NRGBA64 )Copy ()Image {return &NRGBA64 {ImageBase :_fegf .copy ()}};var _ Image =&CMYK32 {};func ImgToGray (i _a .Image )*_a .Gray {if _ccgd ,_cafd :=i .(*_a .Gray );_cafd {return _ccgd ;};_faad :=i .Bounds ();_dcdb :=_a .NewGray (_faad );for _abff :=0;_abff < _faad .Max .X ;_abff ++{for _bgec :=0;_bgec < _faad .Max .Y ;_bgec ++{_cafff :=i .At (_abff ,_bgec );_dcdb .Set (_abff ,_bgec ,_cafff );};};return _dcdb ;};func AutoThresholdTriangle (histogram [256]int )uint8 {var _acgb ,_bcac ,_ddec ,_dffdg int ;for _gcbf :=0;_gcbf < len (histogram );_gcbf ++{if histogram [_gcbf ]> 0{_acgb =_gcbf ;break ;};};if _acgb > 0{_acgb --;};for _adaa :=255;_adaa > 0;_adaa --{if histogram [_adaa ]> 0{_dffdg =_adaa ;break ;};};if _dffdg < 255{_dffdg ++;};for _agfg :=0;_agfg < 256;_agfg ++{if histogram [_agfg ]> _bcac {_ddec =_agfg ;_bcac =histogram [_agfg ];};};var _fcd bool ;if (_ddec -_acgb )< (_dffdg -_ddec ){_fcd =true ;var _ccb int ;_eagg :=255;for _ccb < _eagg {_dacg :=histogram [_ccb ];histogram [_ccb ]=histogram [_eagg ];histogram [_eagg ]=_dacg ;_ccb ++;_eagg --;};_acgb =255-_dffdg ;_ddec =255-_ddec ;};if _acgb ==_ddec {return uint8 (_acgb );};_eff :=float64 (histogram [_ddec ]);_baed :=float64 (_acgb -_ddec );_eefd :=_dg .Sqrt (_eff *_eff +_baed *_baed );_eff /=_eefd ;_baed /=_eefd ;_eefd =_eff *float64 (_acgb )+_baed *float64 (histogram [_acgb ]);_gcda :=_acgb ;var _eggb float64 ;for _eafeg :=_acgb +1;_eafeg <=_ddec ;_eafeg ++{_cddc :=_eff *float64 (_eafeg )+_baed *float64 (histogram [_eafeg ])-_eefd ;if _cddc > _eggb {_gcda =_eafeg ;_eggb =_cddc ;};};_gcda --;if _fcd {var _agg int ;_fbdb :=255;for _agg < _fbdb {_fadg :=histogram [_agg ];histogram [_agg ]=histogram [_fbdb ];histogram [_fbdb ]=_fadg ;_agg ++;_fbdb --;};return uint8 (255-_gcda );};return uint8 (_gcda );};func (_dfef *Gray4 )ColorAt (x ,y int )(_b .Color ,error ){return ColorAtGray4BPC (x ,y ,_dfef .BytesPerLine ,_dfef .Data ,_dfef .Decode );};func (_baba *Gray2 )ColorModel ()_b .Model {return Gray2Model };func (_dec *ImageBase )Pix ()[]byte {return _dec .Data };func (_agebc *Gray16 )SetGray (x ,y int ,g _b .Gray ){_egbf :=(y *_agebc .BytesPerLine /2+x )*2;if _egbf +1>=len (_agebc .Data ){return ;};_agebc .Data [_egbf ]=g .Y ;_agebc .Data [_egbf +1]=g .Y ;};func _gdec (_dag NRGBA ,_cab Gray ,_ebbb _a .Rectangle ){for _bcaf :=0;_bcaf < _ebbb .Max .X ;_bcaf ++{for _eaag :=0;_eaag < _ebbb .Max .Y ;_eaag ++{_gbdb :=_adc (_dag .NRGBAAt (_bcaf ,_eaag ));_cab .SetGray (_bcaf ,_eaag ,_gbdb );};};};func ColorAtGray8BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_b .Gray ,error ){_dggb :=y *bytesPerLine +x ;if _dggb >=len (data ){return _b .Gray {},_f .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_bcag :=data [_dggb ];if len (decode )==2{_bcag =uint8 (uint32 (LinearInterpolate (float64 (_bcag ),0,255,decode [0],decode [1]))&0xff);};return _b .Gray {Y :_bcag },nil ;};func (_acbc *NRGBA16 )NRGBAAt (x ,y int )_b .NRGBA {_ffdb ,_ :=ColorAtNRGBA16 (x ,y ,_acbc .Width ,_acbc .BytesPerLine ,_acbc .Data ,_acbc .Alpha ,_acbc .Decode );return _ffdb ;};func ColorAt (x ,y ,width ,bitsPerColor ,colorComponents ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_b .Color ,error ){switch colorComponents {case 1:return ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine ,data ,decode );case 3:return ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor ,data ,alpha ,decode );case 4:return ColorAtCMYK (x ,y ,width ,data ,decode );default:return nil ,_f .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0063o\u006c\u006f\u0072\u0020\u0063\u006f\u006dp\u006f\u006e\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0064",colorComponents );};};func _cade (_cddb _a .Image )(Image ,error ){if _fae ,_eea :=_cddb .(*Gray8 );_eea {return _fae .Copy (),nil ;};_gdef :=_cddb .Bounds ();_eaf ,_adgf :=NewImage (_gdef .Max .X ,_gdef .Max .Y ,8,1,nil ,nil ,nil );if _adgf !=nil {return nil ,_adgf ;};_cbe (_cddb ,_eaf ,_gdef );return _eaf ,nil ;};func (_bfe *Monochrome )clearBit (_adcg ,_ebc int ){_bfe .Data [_adcg ]&=^(0x80>>uint (_ebc &7))};func _bfb (_ddgc *_a .Gray )bool {for _gdbd :=0;_gdbd < len (_ddgc .Pix );_gdbd ++{if !_afb (_ddgc .Pix [_gdbd ]){return false ;};};return true ;};func (_egba *NRGBA32 )Set (x ,y int ,c _b .Color ){_bfg :=y *_egba .Width +x ;_bdca :=3*_bfg ;if _bdca +2>=len (_egba .Data ){return ;};_bcdd :=_b .NRGBAModel .Convert (c ).(_b .NRGBA );_egba .setRGBA (_bfg ,_bcdd );};func (_acef *Gray8 )SetGray (x ,y int ,g _b .Gray ){_cgcd :=y *_acef .BytesPerLine +x ;if _cgcd > len (_acef .Data )-1{return ;};_acef .Data [_cgcd ]=g .Y ;};var _ Image =&Gray4 {};var ErrInvalidImage =_d .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");type NRGBA16 struct{ImageBase };func _fec (_dea _b .Gray ,_ef monochromeModel )_b .Gray {if _dea .Y > uint8 (_ef ){return _b .Gray {Y :_dg .MaxUint8 };};return _b .Gray {};};func (_dbdc *Gray2 )ColorAt (x ,y int )(_b .Color ,error ){return ColorAtGray2BPC (x ,y ,_dbdc .BytesPerLine ,_dbdc .Data ,_dbdc .Decode );};var (Gray2Model =_b .ModelFunc (_agb );Gray4Model =_b .ModelFunc (_fdc );NRGBA16Model =_b .ModelFunc (_ebef ););func _ebef (_acca _b .Color )_b .Color {_cga :=_b .NRGBAModel .Convert (_acca ).(_b .NRGBA );return _adbb (_cga );};func _abf (_cggf _b .Gray )_b .NRGBA {return _b .NRGBA {R :_cggf .Y ,G :_cggf .Y ,B :_cggf .Y ,A :0xff}};var _ Gray =&Gray2 {};func (_fcfg *ImageBase )copy ()ImageBase {_eddc :=*_fcfg ;_eddc .Data =make ([]byte ,len (_fcfg .Data ));copy (_eddc .Data ,_fcfg .Data );return _eddc ;};func (_bgd *Monochrome )setGray (_cebe int ,_gca _b .Gray ,_ddd int ){if _gca .Y ==0{_bgd .clearBit (_ddd ,_cebe );}else {_bgd .setBit (_ddd ,_cebe );};};func (_bdf *Gray8 )GrayAt (x ,y int )_b .Gray {_dfga ,_ :=ColorAtGray8BPC (x ,y ,_bdf .BytesPerLine ,_bdf .Data ,_bdf .Decode );return _dfga ;};func _gba (_gaee Gray ,_fgd CMYK ,_cfd _a .Rectangle ){for _cg :=0;_cg < _cfd .Max .X ;_cg ++{for _gec :=0;_gec < _cfd .Max .Y ;_gec ++{_ead :=_gaee .GrayAt (_cg ,_gec );_fgd .SetCMYK (_cg ,_gec ,_fcc (_ead ));};};};func (_gbad *Gray16 )At (x ,y int )_b .Color {_cfb ,_ :=_gbad .ColorAt (x ,y );return _cfb };func (_eab *monochromeThresholdConverter )Convert (img _a .Image )(Image ,error ){if _adce ,_fcf :=img .(*Monochrome );_fcf {return _adce .Copy (),nil ;};_fe :=img .Bounds ();_eag ,_bgc :=NewImage (_fe .Max .X ,_fe .Max .Y ,1,1,nil ,nil ,nil );if _bgc !=nil {return nil ,_bgc ;};_eag .(*Monochrome ).ModelThreshold =_eab .Threshold ;for _def :=0;_def < _fe .Max .X ;_def ++{for _aeb :=0;_aeb < _fe .Max .Y ;_aeb ++{_ed :=img .At (_def ,_aeb );_eag .Set (_def ,_aeb ,_ed );};};return _eag ,nil ;};func (_bed *Monochrome )Validate ()error {if len (_bed .Data )!=_bed .Height *_bed .BytesPerLine {return ErrInvalidImage ;};return nil ;};func _fdg (_gbgf Gray ,_bbcg NRGBA ,_eca _a .Rectangle ){for _ddae :=0;_ddae < _eca .Max .X ;_ddae ++{for _gecgd :=0;_gecgd < _eca .Max .Y ;_gecgd ++{_aegg :=_gbgf .GrayAt (_ddae ,_gecgd );_bbcg .SetNRGBA (_ddae ,_gecgd ,_abf (_aegg ));};};};func ConverterFunc (converterFunc func (_ada _a .Image )(Image ,error ))ColorConverter {return colorConverter {_eb :converterFunc };};func (_cbdc *NRGBA32 )Base ()*ImageBase {return &_cbdc .ImageBase };func _fcc (_babe _b .Gray )_b .CMYK {return _b .CMYK {K :0xff-_babe .Y }};func (_ccd *Gray4 )SetGray (x ,y int ,g _b .Gray ){if x >=_ccd .Width ||y >=_ccd .Height {return ;};g =_cdeb (g );_ccd .setGray (x ,y ,g );};func _aef (){for _ccaa :=0;_ccaa < 256;_ccaa ++{_cebf [_ccaa ]=uint8 (_ccaa &0x1)+(uint8 (_ccaa >>1)&0x1)+(uint8 (_ccaa >>2)&0x1)+(uint8 (_ccaa >>3)&0x1)+(uint8 (_ccaa >>4)&0x1)+(uint8 (_ccaa >>5)&0x1)+(uint8 (_ccaa >>6)&0x1)+(uint8 (_ccaa >>7)&0x1);};};func ColorAtGray1BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_b .Gray ,error ){_abb :=y *bytesPerLine +x >>3;if _abb >=len (data ){return _b .Gray {},_f .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_agca :=data [_abb ]>>uint (7-(x &7))&1;if len (decode )==2{_agca =uint8 (LinearInterpolate (float64 (_agca ),0.0,1.0,decode [0],decode [1]))&1;};return _b .Gray {Y :_agca *255},nil ;};func (_aae *NRGBA64 )SetNRGBA64 (x ,y int ,c _b .NRGBA64 ){_fdce :=(y *_aae .Width +x )*2;_cbfa :=_fdce *3;if _cbfa +5>=len (_aae .Data ){return ;};_aae .setNRGBA64 (_cbfa ,c ,_fdce );};func (_gcg monochromeModel )Convert (c _b .Color )_b .Color {_afg :=_b .GrayModel .Convert (c ).(_b .Gray );return _fec (_afg ,_gcg );};func _ce (_bca _b .CMYK )_b .NRGBA {_ded ,_fcb ,_dd :=_b .CMYKToRGB (_bca .C ,_bca .M ,_bca .Y ,_bca .K );return _b .NRGBA {R :_ded ,G :_fcb ,B :_dd ,A :0xff};};func BytesPerLine (width ,bitsPerComponent ,colorComponents int )int {return ((width *bitsPerComponent )*colorComponents +7)>>3;};func (_afcd *NRGBA64 )At (x ,y int )_b .Color {_gfdb ,_ :=_afcd .ColorAt (x ,y );return _gfdb };func _fbf (_add _a .Image )(Image ,error ){if _fgc ,_dfc :=_add .(*CMYK32 );_dfc {return _fgc .Copy (),nil ;};_acg :=_add .Bounds ();_fc ,_ab :=NewImage (_acg .Max .X ,_acg .Max .Y ,8,4,nil ,nil ,nil );if _ab !=nil {return nil ,_ab ;};switch _gd :=_add .(type ){case CMYK :_bec (_gd ,_fc .(CMYK ),_acg );case Gray :_gba (_gd ,_fc .(CMYK ),_acg );case NRGBA :_dgd (_gd ,_fc .(CMYK ),_acg );case RGBA :_cfa (_gd ,_fc .(CMYK ),_acg );default:_gdg (_add ,_fc ,_acg );};return _fc ,nil ;};var _ Image =&NRGBA32 {};func (_feg *Gray16 )ColorModel ()_b .Model {return _b .Gray16Model };func (_bc *CMYK32 )Set (x ,y int ,c _b .Color ){_e :=4*(y *_bc .Width +x );if _e +3>=len (_bc .Data ){return ;};_cf :=_b .CMYKModel .Convert (c ).(_b .CMYK );_bc .Data [_e ]=_cf .C ;_bc .Data [_e +1]=_cf .M ;_bc .Data [_e +2]=_cf .Y ;_bc .Data [_e +3]=_cf .K ;};func (_cadc *Gray4 )At (x ,y int )_b .Color {_ecg ,_ :=_cadc .ColorAt (x ,y );return _ecg };func NewImage (width ,height ,bitsPerComponent ,colorComponents int ,data ,alpha []byte ,decode []float64 )(Image ,error ){_eead :=NewImageBase (width ,height ,bitsPerComponent ,colorComponents ,data ,alpha ,decode );var _gee Image ;switch colorComponents {case 1:switch bitsPerComponent {case 1:_gee =&Monochrome {ImageBase :_eead ,ModelThreshold :0x0f};case 2:_gee =&Gray2 {ImageBase :_eead };case 4:_gee =&Gray4 {ImageBase :_eead };case 8:_gee =&Gray8 {ImageBase :_eead };case 16:_gee =&Gray16 {ImageBase :_eead };};case 3:switch bitsPerComponent {case 4:_gee =&NRGBA16 {ImageBase :_eead };case 8:_gee =&NRGBA32 {ImageBase :_eead };case 16:_gee =&NRGBA64 {ImageBase :_eead };};case 4:_gee =&CMYK32 {ImageBase :_eead };};if _gee ==nil {return nil ,ErrInvalidImage ;};return _gee ,nil ;};func (_dbb *CMYK32 )Copy ()Image {return &CMYK32 {ImageBase :_dbb .copy ()}};func (_fd *CMYK32 )CMYKAt (x ,y int )_b .CMYK {_ffd ,_ :=ColorAtCMYK (x ,y ,_fd .Width ,_fd .Data ,_fd .Decode );return _ffd ;};func _aeg (_dcfac _a .Image )(Image ,error ){if _fgfb ,_agbb :=_dcfac .(*NRGBA16 );_agbb {return _fgfb .Copy (),nil ;};_abfd :=_dcfac .Bounds ();_bbdd ,_fgde :=NewImage (_abfd .Max .X ,_abfd .Max .Y ,4,3,nil ,nil ,nil );if _fgde !=nil {return nil ,_fgde ;};_fgda (_dcfac ,_bbdd ,_abfd );return _bbdd ,nil ;};func (_fcge *NRGBA16 )Copy ()Image {return &NRGBA16 {ImageBase :_fcge .copy ()}};func _cfaa (_bbd _a .Image )(Image ,error ){if _edd ,_gbg :=_bbd .(*Gray16 );_gbg {return _edd .Copy (),nil ;};_fegc :=_bbd .Bounds ();_geab ,_dbef :=NewImage (_fegc .Max .X ,_fegc .Max .Y ,16,1,nil ,nil ,nil );if _dbef !=nil {return nil ,_dbef ;};_cbe (_bbd ,_geab ,_fegc );return _geab ,nil ;};type NRGBA32 struct{ImageBase };func (_bfd *Gray2 )Bounds ()_a .Rectangle {return _a .Rectangle {Max :_a .Point {X :_bfd .Width ,Y :_bfd .Height }};};type NRGBA interface{NRGBAAt (_efab ,_deff int )_b .NRGBA ;SetNRGBA (_eafe ,_gdcg int ,_dae _b .NRGBA );};func _cegb (_eddf ,_fcbg Gray ,_fab _a .Rectangle ){for _aebf :=0;_aebf < _fab .Max .X ;_aebf ++{for _ged :=0;_ged < _fab .Max .Y ;_ged ++{_fcbg .SetGray (_aebf ,_ged ,_eddf .GrayAt (_aebf ,_ged ));};};};func GetConverter (bitsPerComponent ,colorComponents int )(ColorConverter ,error ){switch colorComponents {case 1:switch bitsPerComponent {case 1:return MonochromeConverter ,nil ;case 2:return Gray2Converter ,nil ;case 4:return Gray4Converter ,nil ;case 8:return GrayConverter ,nil ;case 16:return Gray16Converter ,nil ;};case 3:switch bitsPerComponent {case 4:return NRGBA16Converter ,nil ;case 8:return NRGBAConverter ,nil ;case 16:return NRGBA64Converter ,nil ;};case 4:return CMYKConverter ,nil ;};return nil ,_f .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0043o\u006e\u0076\u0065\u0072\u0074\u0065\u0072\u0020\u0070\u0061\u0072\u0061\u006d\u0065t\u0065\u0072\u0073\u002e\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003a\u0020\u0025\u0064\u002c\u0020\u0043\u006f\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006et\u0073\u003a \u0025\u0064",bitsPerComponent ,colorComponents );};type Gray8 struct{ImageBase };func (_bba *NRGBA16 )ColorAt (x ,y int )(_b .Color ,error ){return ColorAtNRGBA16 (x ,y ,_bba .Width ,_bba .BytesPerLine ,_bba .Data ,_bba .Alpha ,_bba .Decode );};var _ _a .Image =&Monochrome {};func (_cgee *Monochrome )ColorModel ()_b .Model {return MonochromeModel (_cgee .ModelThreshold )};func (_cbdd *NRGBA32 )Copy ()Image {return &NRGBA32 {ImageBase :_cbdd .copy ()}};func _fdc (_eacg _b .Color )_b .Color {_cbf :=_b .GrayModel .Convert (_eacg ).(_b .Gray );return _cdeb (_cbf )};func (_gfg *Gray2 )Histogram ()(_cdda [256]int ){for _edcg :=0;_edcg < _gfg .Width ;_edcg ++{for _ddad :=0;_ddad < _gfg .Height ;_ddad ++{_cdda [_gfg .GrayAt (_edcg ,_ddad ).Y ]++;};};return _cdda ;};func (_cgfd *Gray16 )Validate ()error {if len (_cgfd .Data )!=_cgfd .Height *_cgfd .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_cd *CMYK32 )At (x ,y int )_b .Color {_bfa ,_ :=_cd .ColorAt (x ,y );return _bfa };func (_ff *CMYK32 )ColorAt (x ,y int )(_b .Color ,error ){return ColorAtCMYK (x ,y ,_ff .Width ,_ff .Data ,_ff .Decode );};func (_dfcb *Gray16 )Bounds ()_a .Rectangle {return _a .Rectangle {Max :_a .Point {X :_dfcb .Width ,Y :_dfcb .Height }};};func _dc (_ec _a .Image )(Image ,error ){if _afd ,_caa :=_ec .(*Monochrome );_caa {return _afd ,nil ;};_dcf ,_acd :=_ec .(Gray );if !_acd {_ae ,_fbff :=GrayConverter .Convert (_ec );if _fbff !=nil {return nil ,_fbff ;};_dcf =_ae .(Gray );};_dff :=_ec .Bounds ();_ebe ,_ega :=NewImage (_dff .Max .X ,_dff .Max .Y ,1,1,nil ,nil ,nil );if _ega !=nil {return nil ,_ega ;};_gad :=_ebe .(*Monochrome );_cgge :=AutoThresholdTriangle (GrayHistogram (_dcf ));for _cdg :=0;_cdg < _dff .Max .X ;_cdg ++{for _fgae :=0;_fgae < _dff .Max .Y ;_fgae ++{_gdc :=_fec (_dcf .GrayAt (_cdg ,_fgae ),monochromeModel (_cgge ));_gad .SetGray (_cdg ,_fgae ,_gdc );};};return _ebe ,nil ;};func (_dacd *Gray4 )Base ()*ImageBase {return &_dacd .ImageBase };var _ _a .Image =&Gray8 {};func (_cdgd *Gray4 )Validate ()error {if len (_cdgd .Data )!=_cdgd .Height *_cdgd .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_cdb *NRGBA16 )Base ()*ImageBase {return &_cdb .ImageBase };type NRGBA64 struct{ImageBase };type colorConverter struct{_eb func (_adg _a .Image )(Image ,error );};func (_dfgb *Gray4 )setGray (_deb int ,_fce int ,_gbae _b .Gray ){_geaf :=_fce *_dfgb .BytesPerLine ;_fad :=_geaf +(_deb >>1);if _fad >=len (_dfgb .Data ){return ;};_gaec :=_gbae .Y >>4;_dfgb .Data [_fad ]=(_dfgb .Data [_fad ]&(^(0xf0>>uint (4*(_deb &1)))))|(_gaec <<uint (4-4*(_deb &1)));};func (_cbfd *Gray8 )Validate ()error {if len (_cbfd .Data )!=_cbfd .Height *_cbfd .BytesPerLine {return ErrInvalidImage ;};return nil ;};var _ _a .Image =&NRGBA16 {};func (_caaf *NRGBA16 )Set (x ,y int ,c _b .Color ){_bfac :=y *_caaf .BytesPerLine +x *3/2;if _bfac +1>=len (_caaf .Data ){return ;};_agee :=NRGBA16Model .Convert (c ).(_b .NRGBA );_caaf .setNRGBA (x ,y ,_bfac ,_agee );};func (_dddd *NRGBA16 )SetNRGBA (x ,y int ,c _b .NRGBA ){_bag :=y *_dddd .BytesPerLine +x *3/2;if _bag +1>=len (_dddd .Data ){return ;};c =_adbb (c );_dddd .setNRGBA (x ,y ,_bag ,c );};var _ Image =&NRGBA64 {};type ColorConverter interface{Convert (_gg _a .Image )(Image ,error );};var _ NRGBA =&NRGBA16 {};func ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine int ,data []byte ,decode []float64 )(_b .Color ,error ){switch bitsPerColor {case 1:return ColorAtGray1BPC (x ,y ,bytesPerLine ,data ,decode );case 2:return ColorAtGray2BPC (x ,y ,bytesPerLine ,data ,decode );case 4:return ColorAtGray4BPC (x ,y ,bytesPerLine ,data ,decode );case 8:return ColorAtGray8BPC (x ,y ,bytesPerLine ,data ,decode );case 16:return ColorAtGray16BPC (x ,y ,bytesPerLine ,data ,decode );default:return nil ,_f .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0067\u0072\u0061\u0079\u0020\u0073c\u0061\u006c\u0065\u0020\u0062\u0069\u0074s\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020a\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );};};func (_cbga *ImageBase )newAlpha (){_dgda :=BytesPerLine (_cbga .Width ,_cbga .BitsPerComponent ,1);_cbga .Alpha =make ([]byte ,_cbga .Height *_dgda );};func (_afab *Gray16 )Set (x ,y int ,c _b .Color ){_ddb :=(y *_afab .BytesPerLine /2+x )*2;if _ddb +1>=len (_afab .Data ){return ;};_ffc :=_b .Gray16Model .Convert (c ).(_b .Gray16 );_afab .Data [_ddb ],_afab .Data [_ddb +1]=uint8 (_ffc .Y >>8),uint8 (_ffc .Y &0xff);};var _ Gray =&Monochrome {};var _ Image =&Monochrome {};func (_dfcg *Gray2 )At (x ,y int )_b .Color {_ede ,_ :=_dfcg .ColorAt (x ,y );return _ede };func (_bgbf *NRGBA32 )Validate ()error {if len (_bgbf .Data )!=3*_bgbf .Width *_bgbf .Height {return _d .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");};return nil ;};func ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor int ,data ,alpha []byte ,decode []float64 )(_b .Color ,error ){switch bitsPerColor {case 4:return ColorAtNRGBA16 (x ,y ,width ,bytesPerLine ,data ,alpha ,decode );case 8:return ColorAtNRGBA32 (x ,y ,width ,data ,alpha ,decode );case 16:return ColorAtNRGBA64 (x ,y ,width ,data ,alpha ,decode );default:return nil ,_f .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0067\u0062\u0020b\u0069\u0074\u0073\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0061\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );};};func (_agd *Gray4 )ColorModel ()_b .Model {return Gray4Model };func ColorAtNRGBA64 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_b .NRGBA64 ,error ){_gcge :=(y *width +x )*2;_eec :=_gcge *3;if _eec +5>=len (data ){return _b .NRGBA64 {},_f .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};const _gbed =0xffff;_gcb :=uint16 (_gbed );if alpha !=nil &&len (alpha )> _gcge +1{_gcb =uint16 (alpha [_gcge ])<<8|uint16 (alpha [_gcge +1]);};_aff :=uint16 (data [_eec ])<<8|uint16 (data [_eec +1]);_bfacb :=uint16 (data [_eec +2])<<8|uint16 (data [_eec +3]);_fccg :=uint16 (data [_eec +4])<<8|uint16 (data [_eec +5]);if len (decode )==6{_aff =uint16 (uint64 (LinearInterpolate (float64 (_aff ),0,65535,decode [0],decode [1]))&_gbed );_bfacb =uint16 (uint64 (LinearInterpolate (float64 (_bfacb ),0,65535,decode [2],decode [3]))&_gbed );_fccg =uint16 (uint64 (LinearInterpolate (float64 (_fccg ),0,65535,decode [4],decode [5]))&_gbed );};return _b .NRGBA64 {R :_aff ,G :_bfacb ,B :_fccg ,A :_gcb },nil ;};func _adc (_cba _b .NRGBA )_b .Gray {_bd ,_dac ,_fga ,_ :=_cba .RGBA ();_fde :=(19595*_bd +38470*_dac +7471*_fga +1<<15)>>24;return _b .Gray {Y :uint8 (_fde )};};func (_cdaf *Gray16 )Base ()*ImageBase {return &_cdaf .ImageBase };func _gcc (_dgfd int ,_cabb int )error {return _f .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",_dgfd ,_cabb );};func _dgd (_gae NRGBA ,_ag CMYK ,_bg _a .Rectangle ){for _agc :=0;_agc < _bg .Max .X ;_agc ++{for _cb :=0;_cb < _bg .Max .Y ;_cb ++{_gb :=_gae .NRGBAAt (_agc ,_cb );_ag .SetCMYK (_agc ,_cb ,_ee (_gb ));};};};func (_feb *NRGBA64 )Base ()*ImageBase {return &_feb .ImageBase };func _ee (_fa _b .NRGBA )_b .CMYK {_bab ,_cgc ,_daa ,_ :=_fa .RGBA ();_bbfg ,_bcc ,_dde ,_ceb :=_b .RGBToCMYK (uint8 (_bab >>8),uint8 (_cgc >>8),uint8 (_daa >>8));return _b .CMYK {C :_bbfg ,M :_bcc ,Y :_dde ,K :_ceb };};func _cfa (_age RGBA ,_acb CMYK ,_abc _a .Rectangle ){for _fdd :=0;_fdd < _abc .Max .X ;_fdd ++{for _bbf :=0;_bbf < _abc .Max .Y ;_bbf ++{_cda :=_age .RGBAAt (_fdd ,_bbf );_acb .SetCMYK (_fdd ,_bbf ,_dgdb (_cda ));};};};func (_cggcc *NRGBA16 )setNRGBA (_fdf ,_deba ,_efg int ,_fgdd _b .NRGBA ){if _fdf *3%2==0{_cggcc .Data [_efg ]=(_fgdd .R >>4)<<4|(_fgdd .G >>4);_cggcc .Data [_efg +1]=(_fgdd .B >>4)<<4|(_cggcc .Data [_efg +1]&0xf);}else {_cggcc .Data [_efg ]=(_cggcc .Data [_efg ]&0xf0)|(_fgdd .R >>4);_cggcc .Data [_efg +1]=(_fgdd .G >>4)<<4|(_fgdd .B >>4);};if _cggcc .Alpha !=nil {_gafe :=_deba *BytesPerLine (_cggcc .Width ,4,1);if _gafe < len (_cggcc .Alpha ){if _fdf %2==0{_cggcc .Alpha [_gafe ]=(_fgdd .A >>uint (4))<<uint (4)|(_cggcc .Alpha [_efg ]&0xf);}else {_cggcc .Alpha [_gafe ]=(_cggcc .Alpha [_gafe ]&0xf0)|(_fgdd .A >>uint (4));};};};};func ColorAtCMYK (x ,y ,width int ,data []byte ,decode []float64 )(_b .CMYK ,error ){_be :=4*(y *width +x );if _be +3>=len (data ){return _b .CMYK {},_f .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};C :=data [_be ]&0xff;M :=data [_be +1]&0xff;Y :=data [_be +2]&0xff;K :=data [_be +3]&0xff;if len (decode )==8{C =uint8 (uint32 (LinearInterpolate (float64 (C ),0,255,decode [0],decode [1]))&0xff);M =uint8 (uint32 (LinearInterpolate (float64 (M ),0,255,decode [2],decode [3]))&0xff);Y =uint8 (uint32 (LinearInterpolate (float64 (Y ),0,255,decode [4],decode [5]))&0xff);K =uint8 (uint32 (LinearInterpolate (float64 (K ),0,255,decode [6],decode [7]))&0xff);};return _b .CMYK {C :C ,M :M ,Y :Y ,K :K },nil ;};var _ _a .Image =&Gray4 {};func (_ebfc *NRGBA64 )NRGBA64At (x ,y int )_b .NRGBA64 {_cfae ,_ :=ColorAtNRGBA64 (x ,y ,_ebfc .Width ,_ebfc .Data ,_ebfc .Alpha ,_ebfc .Decode );return _cfae ;};func (_cdae *NRGBA16 )Bounds ()_a .Rectangle {return _a .Rectangle {Max :_a .Point {X :_cdae .Width ,Y :_cdae .Height }};};func _eeee (_afdf ,_aegb uint8 )uint8 {if _afdf < _aegb {return 255;};return 0;};type RGBA interface{RGBAAt (_defd ,_debd int )_b .RGBA ;SetRGBA (_ccg ,_gedc int ,_decb _b .RGBA );};func _agb (_afgd _b .Color )_b .Color {_eacf :=_b .GrayModel .Convert (_afgd ).(_b .Gray );return _dbge (_eacf );};func _ca (_ggg _b .RGBA )_b .NRGBA {switch _ggg .A {case 0xff:return _b .NRGBA {R :_ggg .R ,G :_ggg .G ,B :_ggg .B ,A :0xff};case 0x00:return _b .NRGBA {};default:_dgg ,_fgg ,_ebg ,_gge :=_ggg .RGBA ();_dgg =(_dgg *0xffff)/_gge ;_fgg =(_fgg *0xffff)/_gge ;_ebg =(_ebg *0xffff)/_gge ;return _b .NRGBA {R :uint8 (_dgg >>8),G :uint8 (_fgg >>8),B :uint8 (_ebg >>8),A :uint8 (_gge >>8)};};};func (_gdab *NRGBA64 )Bounds ()_a .Rectangle {return _a .Rectangle {Max :_a .Point {X :_gdab .Width ,Y :_gdab .Height }};};func ColorAtGray2BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_b .Gray ,error ){_dfg :=y *bytesPerLine +x >>2;if _dfg >=len (data ){return _b .Gray {},_f .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_caaa :=data [_dfg ]>>uint (6-(x &3)*2)&3;if len (decode )==2{_caaa =uint8 (uint32 (LinearInterpolate (float64 (_caaa ),0,3.0,decode [0],decode [1]))&3);};return _b .Gray {Y :_caaa *85},nil ;};func MonochromeModel (threshold uint8 )_b .Model {return monochromeModel (threshold )};func (_edc *Gray2 )Set (x ,y int ,c _b .Color ){if x >=_edc .Width ||y >=_edc .Height {return ;};_bcgd :=Gray2Model .Convert (c ).(_b .Gray );_eba :=y *_edc .BytesPerLine ;_dca :=_eba +(x >>2);_cea :=_bcgd .Y >>6;_edc .Data [_dca ]=(_edc .Data [_dca ]&(^(0xc0>>uint (2*((x )&3)))))|(_cea <<uint (6-2*(x &3)));};type monochromeModel uint8 ;func _gdg (_cbd _a .Image ,_cde Image ,_aa _a .Rectangle ){for _cdd :=0;_cdd < _aa .Max .X ;_cdd ++{for _gea :=0;_gea < _aa .Max .Y ;_gea ++{_cc :=_cbd .At (_cdd ,_gea );_cde .Set (_cdd ,_gea ,_cc );};};};func (_cfeb *Monochrome )GrayAt (x ,y int )_b .Gray {_bcg ,_ :=ColorAtGray1BPC (x ,y ,_cfeb .BytesPerLine ,_cfeb .Data ,_cfeb .Decode );return _bcg ;};func (_ddbc *NRGBA64 )ColorModel ()_b .Model {return _b .NRGBA64Model };func (_gcdg *NRGBA64 )Validate ()error {if len (_gcdg .Data )!=3*2*_gcdg .Width *_gcdg .Height {return _d .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");};return nil ;};func _cdf (_cfee RGBA ,_bgca NRGBA ,_eee _a .Rectangle ){for _fgaef :=0;_fgaef < _eee .Max .X ;_fgaef ++{for _fdfg :=0;_fdfg < _eee .Max .Y ;_fdfg ++{_fee :=_cfee .RGBAAt (_fgaef ,_fdfg );_bgca .SetNRGBA (_fgaef ,_fdfg ,_ca (_fee ));};};};func MonochromeThresholdConverter (threshold uint8 )ColorConverter {return &monochromeThresholdConverter {Threshold :threshold };};func (_agf *NRGBA64 )ColorAt (x ,y int )(_b .Color ,error ){return ColorAtNRGBA64 (x ,y ,_agf .Width ,_agf .Data ,_agf .Alpha ,_agf .Decode );};type CMYK32 struct{ImageBase };type SMasker interface{HasAlpha ()bool ;GetAlpha ()[]byte ;MakeAlpha ();};func _caff (_gcf _a .Image )(Image ,error ){if _abd ,_fgac :=_gcf .(*NRGBA64 );_fgac {return _abd .Copy (),nil ;};_adf :=_gcf .Bounds ();_eabfd ,_cbfe :=NewImage (_adf .Max .X ,_adf .Max .Y ,16,3,nil ,nil ,nil );if _cbfe !=nil {return nil ,_cbfe ;};_fgda (_gcf ,_eabfd ,_adf );return _eabfd ,nil ;};func (_eeagg *NRGBA64 )Set (x ,y int ,c _b .Color ){_fbdf :=(y *_eeagg .Width +x )*2;_ebaa :=_fbdf *3;if _ebaa +5>=len (_eeagg .Data ){return ;};_gfdc :=_b .NRGBA64Model .Convert (c ).(_b .NRGBA64 );_eeagg .setNRGBA64 (_ebaa ,_gfdc ,_fbdf );};func (_ebca *Gray4 )Copy ()Image {return &Gray4 {ImageBase :_ebca .copy ()}};func (_eaee *Gray16 )GrayAt (x ,y int )_b .Gray {_gecg ,_ :=_eaee .ColorAt (x ,y );return _b .Gray {Y :uint8 (_gecg .(_b .Gray16 ).Y >>8)};};func IsGrayImgBlackAndWhite (i *_a .Gray )bool {return _bfb (i )};func (_cgb *Gray8 )Histogram ()(_efa [256]int ){for _gbde :=0;_gbde < len (_cgb .Data );_gbde ++{_efa [_cgb .Data [_gbde ]]++;};return _efa ;};func (_adb *Monochrome )SetGray (x ,y int ,g _b .Gray ){_dbga :=y *_adb .BytesPerLine +x >>3;if _dbga > len (_adb .Data )-1{return ;};g =_fec (g ,monochromeModel (_adb .ModelThreshold ));_adb .setGray (x ,g ,_dbga );};func (_de *CMYK32 )SetCMYK (x ,y int ,c _b .CMYK ){_da :=4*(y *_de .Width +x );if _da +3>=len (_de .Data ){return ;};_de .Data [_da ]=c .C ;_de .Data [_da +1]=c .M ;_de .Data [_da +2]=c .Y ;_de .Data [_da +3]=c .K ;};func (_geb *Gray8 )Copy ()Image {return &Gray8 {ImageBase :_geb .copy ()}};func _eagc (_bbae *_a .Gray16 ,_cfbb uint8 )*_a .Gray {_deg :=_bbae .Bounds ();_aefc :=_a .NewGray (_deg );for _cebd :=0;_cebd < _deg .Dx ();_cebd ++{for _eed :=0;_eed < _deg .Dy ();_eed ++{_eecg :=_bbae .Gray16At (_cebd ,_eed );_aefc .SetGray (_cebd ,_eed ,_b .Gray {Y :_eeee (uint8 (_eecg .Y /256),_cfbb )});};};return _aefc ;};func (_cefg *Gray16 )Histogram ()(_dfgc [256]int ){for _gda :=0;_gda < _cefg .Width ;_gda ++{for _deaa :=0;_deaa < _cefg .Height ;_deaa ++{_dfgc [_cefg .GrayAt (_gda ,_deaa ).Y ]++;};};return _dfgc ;};func AddDataPadding (width ,height ,bitsPerComponent ,colorComponents int ,data []byte )([]byte ,error ){_fdac :=BytesPerLine (width ,bitsPerComponent ,colorComponents );if _fdac ==width *colorComponents *bitsPerComponent /8{return data ,nil ;};_aad :=width *colorComponents *bitsPerComponent ;_agcc :=_fdac *8;_bfdg :=8-(_agcc -_aad );_eefa :=_fb .NewReader (data );_dcfd :=_fdac -1;_cfg :=make ([]byte ,_dcfd );_geae :=make ([]byte ,height *_fdac );_dgc :=_fb .NewWriterMSB (_geae );var _efe uint64 ;var _agce error ;for _fca :=0;_fca < height ;_fca ++{_ ,_agce =_eefa .Read (_cfg );if _agce !=nil {return nil ,_agce ;};_ ,_agce =_dgc .Write (_cfg );if _agce !=nil {return nil ,_agce ;};_efe ,_agce =_eefa .ReadBits (byte (_bfdg ));if _agce !=nil {return nil ,_agce ;};_ ,_agce =_dgc .WriteBits (_efe ,_bfdg );if _agce !=nil {return nil ,_agce ;};_dgc .FinishByte ();};return _geae ,nil ;};func _gbc (_cca _b .RGBA )_b .Gray {_egb :=(19595*uint32 (_cca .R )+38470*uint32 (_cca .G )+7471*uint32 (_cca .B )+1<<7)>>16;return _b .Gray {Y :uint8 (_egb )};};type Monochrome struct{ImageBase ;ModelThreshold uint8 ;};func (_fedc *ImageBase )GetAlpha ()[]byte {return _fedc .Alpha };func (_cad *Monochrome )Base ()*ImageBase {return &_cad .ImageBase };func (_ad *CMYK32 )ColorModel ()_b .Model {return _b .CMYKModel };type Gray interface{GrayAt (_eef ,_fcbe int )_b .Gray ;SetGray (_fcbb ,_egc int ,_cef _b .Gray );};func (_cgf *Gray4 )Set (x ,y int ,c _b .Color ){if x >=_cgf .Width ||y >=_cgf .Height {return ;};_gdd :=Gray4Model .Convert (c ).(_b .Gray );_cgf .setGray (x ,y ,_gdd );};func _eeag (_ece CMYK ,_acga Gray ,_bae _a .Rectangle ){for _dbc :=0;_dbc < _bae .Max .X ;_dbc ++{for _cggc :=0;_cggc < _bae .Max .Y ;_cggc ++{_dcb :=_gc (_ece .CMYKAt (_dbc ,_cggc ));_acga .SetGray (_dbc ,_cggc ,_dcb );};};};var _ Image =&Gray2 {};func (_fac *NRGBA64 )setNRGBA64 (_bff int ,_acdg _b .NRGBA64 ,_bbfb int ){_fac .Data [_bff ]=uint8 (_acdg .R >>8);_fac .Data [_bff +1]=uint8 (_acdg .R &0xff);_fac .Data [_bff +2]=uint8 (_acdg .G >>8);_fac .Data [_bff +3]=uint8 (_acdg .G &0xff);_fac .Data [_bff +4]=uint8 (_acdg .B >>8);_fac .Data [_bff +5]=uint8 (_acdg .B &0xff);if _bbfb +1< len (_fac .Alpha ){_fac .Alpha [_bbfb ]=uint8 (_acdg .A >>8);_fac .Alpha [_bbfb +1]=uint8 (_acdg .A &0xff);};};func _ebcg (_dcd CMYK ,_dece NRGBA ,_dbdg _a .Rectangle ){for _cgae :=0;_cgae < _dbdg .Max .X ;_cgae ++{for _gbdeg :=0;_gbdeg < _dbdg .Max .Y ;_gbdeg ++{_ecb :=_dcd .CMYKAt (_cgae ,_gbdeg );_dece .SetNRGBA (_cgae ,_gbdeg ,_ce (_ecb ));};};};