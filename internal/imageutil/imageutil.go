//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package imageutil ;import (_dc "encoding/binary";_bd "errors";_cb "fmt";_cbd "github.com/unidoc/unipdf/v3/common";_gc "github.com/unidoc/unipdf/v3/internal/bitwise";_a "image";_g "image/color";_d "image/draw";_c "math";);func (_bdd *ImageBase )MakeAlpha (){_bdd .newAlpha ()};
func (_eef *Gray4 )setGray (_ffdab int ,_edad int ,_bdad _g .Gray ){_aceb :=_edad *_eef .BytesPerLine ;_fcfe :=_aceb +(_ffdab >>1);if _fcfe >=len (_eef .Data ){return ;};_aab :=_bdad .Y >>4;_eef .Data [_fcfe ]=(_eef .Data [_fcfe ]&(^(0xf0>>uint (4*(_ffdab &1)))))|(_aab <<uint (4-4*(_ffdab &1)));
};func (_fagb *Gray8 )GrayAt (x ,y int )_g .Gray {_beca ,_ :=ColorAtGray8BPC (x ,y ,_fagb .BytesPerLine ,_fagb .Data ,_fagb .Decode );return _beca ;};var _fecd [256]uint8 ;func ColorAtGray2BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_g .Gray ,error ){_egeg :=y *bytesPerLine +x >>2;
if _egeg >=len (data ){return _g .Gray {},_cb .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_bedg :=data [_egeg ]>>uint (6-(x &3)*2)&3;if len (decode )==2{_bedg =uint8 (uint32 (LinearInterpolate (float64 (_bedg ),0,3.0,decode [0],decode [1]))&3);};return _g .Gray {Y :_bedg *85},nil ;};func (_edeg *Monochrome )RasterOperation (dx ,dy ,dw ,dh int ,op RasterOperator ,src *Monochrome ,sx ,sy int )error {return _caaa (_edeg ,dx ,dy ,dw ,dh ,op ,src ,sx ,sy );
};func _ccbf (_fbdc _a .Image )(Image ,error ){if _aeg ,_baff :=_fbdc .(*CMYK32 );_baff {return _aeg .Copy (),nil ;};_dae :=_fbdc .Bounds ();_cfce ,_afdd :=NewImage (_dae .Max .X ,_dae .Max .Y ,8,4,nil ,nil ,nil );if _afdd !=nil {return nil ,_afdd ;};switch _dag :=_fbdc .(type ){case CMYK :_dcc (_dag ,_cfce .(CMYK ),_dae );
case Gray :_gac (_dag ,_cfce .(CMYK ),_dae );case NRGBA :_dgg (_dag ,_cfce .(CMYK ),_dae );case RGBA :_ddc (_dag ,_cfce .(CMYK ),_dae );default:_gaac (_fbdc ,_cfce ,_dae );};return _cfce ,nil ;};func AddDataPadding (width ,height ,bitsPerComponent ,colorComponents int ,data []byte )([]byte ,error ){_ffbd :=BytesPerLine (width ,bitsPerComponent ,colorComponents );
if _ffbd ==width *colorComponents *bitsPerComponent /8{return data ,nil ;};_agbg :=width *colorComponents *bitsPerComponent ;_egegb :=_ffbd *8;_cbba :=8-(_egegb -_agbg );_baedg :=_gc .NewReader (data );_bdgb :=_ffbd -1;_ceff :=make ([]byte ,_bdgb );_fcef :=make ([]byte ,height *_ffbd );
_ebaae :=_gc .NewWriterMSB (_fcef );var _gfgf uint64 ;var _gfdef error ;for _bee :=0;_bee < height ;_bee ++{_ ,_gfdef =_baedg .Read (_ceff );if _gfdef !=nil {return nil ,_gfdef ;};_ ,_gfdef =_ebaae .Write (_ceff );if _gfdef !=nil {return nil ,_gfdef ;};
_gfgf ,_gfdef =_baedg .ReadBits (byte (_cbba ));if _gfdef !=nil {return nil ,_gfdef ;};_ ,_gfdef =_ebaae .WriteBits (_gfgf ,_cbba );if _gfdef !=nil {return nil ,_gfdef ;};_ebaae .FinishByte ();};return _fcef ,nil ;};func _caaa (_cecf *Monochrome ,_egbd ,_afgea ,_gfaa ,_ccee int ,_fafc RasterOperator ,_defb *Monochrome ,_abgd ,_acgf int )error {if _cecf ==nil {return _bd .New ("\u006e\u0069\u006c\u0020\u0027\u0064\u0065\u0073\u0074\u0027\u0020\u0042i\u0074\u006d\u0061\u0070");
};if _fafc ==PixDst {return nil ;};switch _fafc {case PixClr ,PixSet ,PixNotDst :_efgd (_cecf ,_egbd ,_afgea ,_gfaa ,_ccee ,_fafc );return nil ;};if _defb ==nil {_cbd .Log .Debug ("\u0052a\u0073\u0074e\u0072\u004f\u0070\u0065r\u0061\u0074\u0069o\u006e\u0020\u0073\u006f\u0075\u0072\u0063\u0065\u0020bi\u0074\u006d\u0061p\u0020\u0069s\u0020\u006e\u006f\u0074\u0020\u0064e\u0066\u0069n\u0065\u0064");
return _bd .New ("\u006e\u0069l\u0020\u0027\u0073r\u0063\u0027\u0020\u0062\u0069\u0074\u006d\u0061\u0070");};if _gedc :=_dgcea (_cecf ,_egbd ,_afgea ,_gfaa ,_ccee ,_fafc ,_defb ,_abgd ,_acgf );_gedc !=nil {return _gedc ;};return nil ;};var _ NRGBA =&NRGBA32 {};
func (_gfe *CMYK32 )ColorModel ()_g .Model {return _g .CMYKModel };func _cef ()(_eafg [256]uint32 ){for _fbb :=0;_fbb < 256;_fbb ++{if _fbb &0x01!=0{_eafg [_fbb ]|=0xf;};if _fbb &0x02!=0{_eafg [_fbb ]|=0xf0;};if _fbb &0x04!=0{_eafg [_fbb ]|=0xf00;};if _fbb &0x08!=0{_eafg [_fbb ]|=0xf000;
};if _fbb &0x10!=0{_eafg [_fbb ]|=0xf0000;};if _fbb &0x20!=0{_eafg [_fbb ]|=0xf00000;};if _fbb &0x40!=0{_eafg [_fbb ]|=0xf000000;};if _fbb &0x80!=0{_eafg [_fbb ]|=0xf0000000;};};return _eafg ;};func (_feea *ImageBase )HasAlpha ()bool {if _feea .Alpha ==nil {return false ;
};for _ffbg :=range _feea .Alpha {if _feea .Alpha [_ffbg ]!=0xff{return true ;};};return false ;};func (_ecgb *Gray4 )Bounds ()_a .Rectangle {return _a .Rectangle {Max :_a .Point {X :_ecgb .Width ,Y :_ecgb .Height }};};func _dggcb (_eggbg *_a .Gray16 ,_agca uint8 )*_a .Gray {_fcad :=_eggbg .Bounds ();
_gdea :=_a .NewGray (_fcad );for _dfgaf :=0;_dfgaf < _fcad .Dx ();_dfgaf ++{for _eecd :=0;_eecd < _fcad .Dy ();_eecd ++{_gfgb :=_eggbg .Gray16At (_dfgaf ,_eecd );_gdea .SetGray (_dfgaf ,_eecd ,_g .Gray {Y :_deba (uint8 (_gfgb .Y /256),_agca )});};};return _gdea ;
};func _cfc (_bf *Monochrome ,_ede int ,_aff []byte )(_eac *Monochrome ,_gge error ){const _abfa ="\u0072\u0065d\u0075\u0063\u0065R\u0061\u006e\u006b\u0042\u0069\u006e\u0061\u0072\u0079";if _bf ==nil {return nil ,_bd .New ("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d");
};if _ede < 1||_ede > 4{return nil ,_bd .New ("\u006c\u0065\u0076\u0065\u006c\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020\u0073e\u0074\u0020\u007b\u0031\u002c\u0032\u002c\u0033\u002c\u0034\u007d");};if _bf .Height <=1{return nil ,_bd .New ("\u0073\u006f\u0075rc\u0065\u0020\u0068\u0065\u0069\u0067\u0068\u0074\u0020m\u0075s\u0074 \u0062e\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020\u0027\u0032\u0027");
};_eac =_cbdf (_bf .Width /2,_bf .Height /2);if _aff ==nil {_aff =_cgef ();};_afc :=_cgee (_bf .BytesPerLine ,2*_eac .BytesPerLine );switch _ede {case 1:_gge =_acg (_bf ,_eac ,_aff ,_afc );case 2:_gge =_gag (_bf ,_eac ,_aff ,_afc );case 3:_gge =_fa (_bf ,_eac ,_aff ,_afc );
case 4:_gge =_bb (_bf ,_eac ,_aff ,_afc );};if _gge !=nil {return nil ,_gge ;};return _eac ,nil ;};func _ebda (_dccd _g .RGBA )_g .NRGBA {switch _dccd .A {case 0xff:return _g .NRGBA {R :_dccd .R ,G :_dccd .G ,B :_dccd .B ,A :0xff};case 0x00:return _g .NRGBA {};
default:_fegb ,_ageg ,_bcaa ,_defe :=_dccd .RGBA ();_fegb =(_fegb *0xffff)/_defe ;_ageg =(_ageg *0xffff)/_defe ;_bcaa =(_bcaa *0xffff)/_defe ;return _g .NRGBA {R :uint8 (_fegb >>8),G :uint8 (_ageg >>8),B :uint8 (_bcaa >>8),A :uint8 (_defe >>8)};};};func (_edb *CMYK32 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtCMYK (x ,y ,_edb .Width ,_edb .Data ,_edb .Decode );
};type CMYK32 struct{ImageBase };func _acg (_dde ,_dff *Monochrome ,_ced []byte ,_dcbf int )(_dbdd error ){var (_dbf ,_dddc ,_gad ,_dgdg ,_aae ,_dcf ,_gde ,_ff int ;_dda ,_fec uint32 ;_ageb ,_ebbd byte ;_egg uint16 ;);_eae :=make ([]byte ,4);_cbag :=make ([]byte ,4);
for _gad =0;_gad < _dde .Height -1;_gad ,_dgdg =_gad +2,_dgdg +1{_dbf =_gad *_dde .BytesPerLine ;_dddc =_dgdg *_dff .BytesPerLine ;for _aae ,_dcf =0,0;_aae < _dcbf ;_aae ,_dcf =_aae +4,_dcf +1{for _gde =0;_gde < 4;_gde ++{_ff =_dbf +_aae +_gde ;if _ff <=len (_dde .Data )-1&&_ff < _dbf +_dde .BytesPerLine {_eae [_gde ]=_dde .Data [_ff ];
}else {_eae [_gde ]=0x00;};_ff =_dbf +_dde .BytesPerLine +_aae +_gde ;if _ff <=len (_dde .Data )-1&&_ff < _dbf +(2*_dde .BytesPerLine ){_cbag [_gde ]=_dde .Data [_ff ];}else {_cbag [_gde ]=0x00;};};_dda =_dc .BigEndian .Uint32 (_eae );_fec =_dc .BigEndian .Uint32 (_cbag );
_fec |=_dda ;_fec |=_fec <<1;_fec &=0xaaaaaaaa;_dda =_fec |(_fec <<7);_ageb =byte (_dda >>24);_ebbd =byte ((_dda >>8)&0xff);_ff =_dddc +_dcf ;if _ff +1==len (_dff .Data )-1||_ff +1>=_dddc +_dff .BytesPerLine {_dff .Data [_ff ]=_ced [_ageb ];}else {_egg =(uint16 (_ced [_ageb ])<<8)|uint16 (_ced [_ebbd ]);
if _dbdd =_dff .setTwoBytes (_ff ,_egg );_dbdd !=nil {return _cb .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_ff );
};_dcf ++;};};};return nil ;};func _dgcea (_gaf *Monochrome ,_becb ,_dfae int ,_dbddae ,_ddbe int ,_dacf RasterOperator ,_fgd *Monochrome ,_bece ,_efaa int )error {var _bgeb ,_dbda ,_ggg ,_abae int ;if _becb < 0{_bece -=_becb ;_dbddae +=_becb ;_becb =0;
};if _bece < 0{_becb -=_bece ;_dbddae +=_bece ;_bece =0;};_bgeb =_becb +_dbddae -_gaf .Width ;if _bgeb > 0{_dbddae -=_bgeb ;};_dbda =_bece +_dbddae -_fgd .Width ;if _dbda > 0{_dbddae -=_dbda ;};if _dfae < 0{_efaa -=_dfae ;_ddbe +=_dfae ;_dfae =0;};if _efaa < 0{_dfae -=_efaa ;
_ddbe +=_efaa ;_efaa =0;};_ggg =_dfae +_ddbe -_gaf .Height ;if _ggg > 0{_ddbe -=_ggg ;};_abae =_efaa +_ddbe -_fgd .Height ;if _abae > 0{_ddbe -=_abae ;};if _dbddae <=0||_ddbe <=0{return nil ;};var _fcfd error ;switch {case _becb &7==0&&_bece &7==0:_fcfd =_ccea (_gaf ,_becb ,_dfae ,_dbddae ,_ddbe ,_dacf ,_fgd ,_bece ,_efaa );
case _becb &7==_bece &7:_fcfd =_dfbc (_gaf ,_becb ,_dfae ,_dbddae ,_ddbe ,_dacf ,_fgd ,_bece ,_efaa );default:_fcfd =_geee (_gaf ,_becb ,_dfae ,_dbddae ,_ddbe ,_dacf ,_fgd ,_bece ,_efaa );};if _fcfd !=nil {return _fcfd ;};return nil ;};func (_cdef *Monochrome )Copy ()Image {return &Monochrome {ImageBase :_cdef .ImageBase .copy (),ModelThreshold :_cdef .ModelThreshold };
};var (Gray2Model =_g .ModelFunc (_acef );Gray4Model =_g .ModelFunc (_fea );NRGBA16Model =_g .ModelFunc (_fedc ););func ColorAtNRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_g .NRGBA ,error ){_bea :=y *width +x ;_fccf :=3*_bea ;if _fccf +2>=len (data ){return _g .NRGBA {},_cb .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_edcf :=uint8 (0xff);if alpha !=nil &&len (alpha )> _bea {_edcf =alpha [_bea ];};_gecf ,_fad ,_fbfb :=data [_fccf ],data [_fccf +1],data [_fccf +2];if len (decode )==6{_gecf =uint8 (uint32 (LinearInterpolate (float64 (_gecf ),0,255,decode [0],decode [1]))&0xff);
_fad =uint8 (uint32 (LinearInterpolate (float64 (_fad ),0,255,decode [2],decode [3]))&0xff);_fbfb =uint8 (uint32 (LinearInterpolate (float64 (_fbfb ),0,255,decode [4],decode [5]))&0xff);};return _g .NRGBA {R :_gecf ,G :_fad ,B :_fbfb ,A :_edcf },nil ;};
func ColorAtGray16BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_g .Gray16 ,error ){_cdde :=(y *bytesPerLine /2+x )*2;if _cdde +1>=len (data ){return _g .Gray16 {},_cb .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_fcee :=uint16 (data [_cdde ])<<8|uint16 (data [_cdde +1]);if len (decode )==2{_fcee =uint16 (uint64 (LinearInterpolate (float64 (_fcee ),0,65535,decode [0],decode [1])));};return _g .Gray16 {Y :_fcee },nil ;};func _ddfa (_deda NRGBA ,_acdc RGBA ,_dfaa _a .Rectangle ){for _fedb :=0;
_fedb < _dfaa .Max .X ;_fedb ++{for _bccg :=0;_bccg < _dfaa .Max .Y ;_bccg ++{_fadc :=_deda .NRGBAAt (_fedb ,_bccg );_acdc .SetRGBA (_fedb ,_bccg ,_gbbe (_fadc ));};};};func _edde (_cgefd _a .Image )(Image ,error ){if _bcfgb ,_acec :=_cgefd .(*NRGBA16 );
_acec {return _bcfgb .Copy (),nil ;};_fcdd :=_cgefd .Bounds ();_eceed ,_gadcb :=NewImage (_fcdd .Max .X ,_fcdd .Max .Y ,4,3,nil ,nil ,nil );if _gadcb !=nil {return nil ,_gadcb ;};_gageb (_cgefd ,_eceed ,_fcdd );return _eceed ,nil ;};type NRGBA interface{NRGBAAt (_cddg ,_efgc int )_g .NRGBA ;
SetNRGBA (_adbf ,_dcgb int ,_eggfc _g .NRGBA );};func (_beba *CMYK32 )Base ()*ImageBase {return &_beba .ImageBase };func (_fedg *Gray8 )Validate ()error {if len (_fedg .Data )!=_fedg .Height *_fedg .BytesPerLine {return ErrInvalidImage ;};return nil ;};
func (_bgbe *NRGBA32 )Copy ()Image {return &NRGBA32 {ImageBase :_bgbe .copy ()}};func _bfdg (_ccdf _a .Image )(Image ,error ){if _adga ,_babg :=_ccdf .(*RGBA32 );_babg {return _adga .Copy (),nil ;};_debg ,_afbea ,_cacd :=_bgfca (_ccdf ,1);_eeef :=&RGBA32 {ImageBase :NewImageBase (_debg .Max .X ,_debg .Max .Y ,8,3,nil ,_cacd ,nil )};
_ebbgg (_ccdf ,_eeef ,_debg );if len (_cacd )!=0&&!_afbea {if _bagb :=_dgcd (_cacd ,_eeef );_bagb !=nil {return nil ,_bagb ;};};return _eeef ,nil ;};func (_dbfe monochromeModel )Convert (c _g .Color )_g .Color {_ebfa :=_g .GrayModel .Convert (c ).(_g .Gray );
return _bcac (_ebfa ,_dbfe );};func ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine int ,data []byte ,decode []float64 )(_g .Color ,error ){switch bitsPerColor {case 1:return ColorAtGray1BPC (x ,y ,bytesPerLine ,data ,decode );case 2:return ColorAtGray2BPC (x ,y ,bytesPerLine ,data ,decode );
case 4:return ColorAtGray4BPC (x ,y ,bytesPerLine ,data ,decode );case 8:return ColorAtGray8BPC (x ,y ,bytesPerLine ,data ,decode );case 16:return ColorAtGray16BPC (x ,y ,bytesPerLine ,data ,decode );default:return nil ,_cb .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0067\u0072\u0061\u0079\u0020\u0073c\u0061\u006c\u0065\u0020\u0062\u0069\u0074s\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020a\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );
};};func (_caec *Monochrome )SetGray (x ,y int ,g _g .Gray ){_ebe :=y *_caec .BytesPerLine +x >>3;if _ebe > len (_caec .Data )-1{return ;};g =_bcac (g ,monochromeModel (_caec .ModelThreshold ));_caec .setGray (x ,g ,_ebe );};func _fea (_caa _g .Color )_g .Color {_caee :=_g .GrayModel .Convert (_caa ).(_g .Gray );
return _effb (_caee )};func _gageb (_deff _a .Image ,_fegcf Image ,_cead _a .Rectangle ){if _cgcf ,_abca :=_deff .(SMasker );_abca &&_cgcf .HasAlpha (){_fegcf .(SMasker ).MakeAlpha ();};switch _eded :=_deff .(type ){case Gray :_befc (_eded ,_fegcf .(NRGBA ),_cead );
case NRGBA :_gcdg (_eded ,_fegcf .(NRGBA ),_cead );case *_a .NYCbCrA :_agfg (_eded ,_fegcf .(NRGBA ),_cead );case CMYK :_fbec (_eded ,_fegcf .(NRGBA ),_cead );case RGBA :_agbc (_eded ,_fegcf .(NRGBA ),_cead );case nrgba64 :_adgg (_eded ,_fegcf .(NRGBA ),_cead );
default:_gaac (_deff ,_fegcf ,_cead );};};func ColorAtCMYK (x ,y ,width int ,data []byte ,decode []float64 )(_g .CMYK ,error ){_cae :=4*(y *width +x );if _cae +3>=len (data ){return _g .CMYK {},_cb .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};C :=data [_cae ]&0xff;M :=data [_cae +1]&0xff;Y :=data [_cae +2]&0xff;K :=data [_cae +3]&0xff;if len (decode )==8{C =uint8 (uint32 (LinearInterpolate (float64 (C ),0,255,decode [0],decode [1]))&0xff);M =uint8 (uint32 (LinearInterpolate (float64 (M ),0,255,decode [2],decode [3]))&0xff);
Y =uint8 (uint32 (LinearInterpolate (float64 (Y ),0,255,decode [4],decode [5]))&0xff);K =uint8 (uint32 (LinearInterpolate (float64 (K ),0,255,decode [6],decode [7]))&0xff);};return _g .CMYK {C :C ,M :M ,Y :Y ,K :K },nil ;};func _gbbe (_gccc _g .NRGBA )_g .RGBA {_bab ,_bga ,_caf ,_aea :=_gccc .RGBA ();
return _g .RGBA {R :uint8 (_bab >>8),G :uint8 (_bga >>8),B :uint8 (_caf >>8),A :uint8 (_aea >>8)};};func (_eaca *ImageBase )getByte (_bbg int )(byte ,error ){if _bbg > len (_eaca .Data )-1||_bbg < 0{return 0,_cb .Errorf ("\u0069\u006e\u0064\u0065x:\u0020\u0025\u0064\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006eg\u0065",_bbg );
};return _eaca .Data [_bbg ],nil ;};func _egdf (_adfa _g .NRGBA64 )_g .RGBA {_ecd ,_affee ,_cgeg ,_fegba :=_adfa .RGBA ();return _g .RGBA {R :uint8 (_ecd >>8),G :uint8 (_affee >>8),B :uint8 (_cgeg >>8),A :uint8 (_fegba >>8)};};func _gdabc (_dedf RGBA ,_fgac Gray ,_cgf _a .Rectangle ){for _aafa :=0;
_aafa < _cgf .Max .X ;_aafa ++{for _ecbd :=0;_ecbd < _cgf .Max .Y ;_ecbd ++{_fbed :=_bfe (_dedf .RGBAAt (_aafa ,_ecbd ));_fgac .SetGray (_aafa ,_ecbd ,_fbed );};};};var _ Gray =&Gray16 {};func (_fgcc *Gray2 )Set (x ,y int ,c _g .Color ){if x >=_fgcc .Width ||y >=_fgcc .Height {return ;
};_bgc :=Gray2Model .Convert (c ).(_g .Gray );_dgfa :=y *_fgcc .BytesPerLine ;_agdf :=_dgfa +(x >>2);_fae :=_bgc .Y >>6;_fgcc .Data [_agdf ]=(_fgcc .Data [_agdf ]&(^(0xc0>>uint (2*((x )&3)))))|(_fae <<uint (6-2*(x &3)));};func (_fba *Monochrome )ExpandBinary (factor int )(*Monochrome ,error ){if !IsPowerOf2 (uint (factor )){return nil ,_cb .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0065\u0078\u0070\u0061\u006e\u0064\u0020b\u0069n\u0061\u0072\u0079\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",factor );
};return _cf (_fba ,factor );};func _gfba (_egcb Gray ,_efca NRGBA ,_fbc _a .Rectangle ){for _fdb :=0;_fdb < _fbc .Max .X ;_fdb ++{for _adac :=0;_adac < _fbc .Max .Y ;_adac ++{_cgg :=_fcf (_efca .NRGBAAt (_fdb ,_adac ));_egcb .SetGray (_fdb ,_adac ,_cgg );
};};};func (_dbdgb *NRGBA64 )Base ()*ImageBase {return &_dbdgb .ImageBase };func _efgd (_dcae *Monochrome ,_ffc ,_eabc ,_fegg ,_cgc int ,_fgcf RasterOperator ){if _ffc < 0{_fegg +=_ffc ;_ffc =0;};_fcaa :=_ffc +_fegg -_dcae .Width ;if _fcaa > 0{_fegg -=_fcaa ;
};if _eabc < 0{_cgc +=_eabc ;_eabc =0;};_gbfc :=_eabc +_cgc -_dcae .Height ;if _gbfc > 0{_cgc -=_gbfc ;};if _fegg <=0||_cgc <=0{return ;};if (_ffc &7)==0{_egbbd (_dcae ,_ffc ,_eabc ,_fegg ,_cgc ,_fgcf );}else {_gae (_dcae ,_ffc ,_eabc ,_fegg ,_cgc ,_fgcf );
};};func _aec (_dcb *Monochrome ,_bed ,_gdb int )(*Monochrome ,error ){if _dcb ==nil {return nil ,_bd .New ("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064");};if _bed <=0||_gdb <=0{return nil ,_bd .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0073\u0063\u0061l\u0065\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020<\u003d\u0020\u0030");
};if _bed ==_gdb {if _bed ==1{return _dcb .copy (),nil ;};if _bed ==2||_bed ==4||_bed ==8{_gfab ,_de :=_cf (_dcb ,_bed );if _de !=nil {return nil ,_de ;};return _gfab ,nil ;};};_ecg :=_bed *_dcb .Width ;_edc :=_gdb *_dcb .Height ;_aga :=_cbdf (_ecg ,_edc );
_efa :=_aga .BytesPerLine ;var (_ccc ,_dg ,_ebbg ,_bag ,_deb int ;_eaf byte ;_eeb error ;);for _dg =0;_dg < _dcb .Height ;_dg ++{_ccc =_gdb *_dg *_efa ;for _ebbg =0;_ebbg < _dcb .Width ;_ebbg ++{if _cgac :=_dcb .getBitAt (_ebbg ,_dg );_cgac {_deb =_bed *_ebbg ;
for _bag =0;_bag < _bed ;_bag ++{_aga .setIndexedBit (_ccc *8+_deb +_bag );};};};for _bag =1;_bag < _gdb ;_bag ++{_agf :=_ccc +_bag *_efa ;for _acc :=0;_acc < _efa ;_acc ++{if _eaf ,_eeb =_aga .getByte (_ccc +_acc );_eeb !=nil {return nil ,_eeb ;};if _eeb =_aga .setByte (_agf +_acc ,_eaf );
_eeb !=nil {return nil ,_eeb ;};};};};return _aga ,nil ;};func _ebbgg (_cfdeb _a .Image ,_ecaf Image ,_gegc _a .Rectangle ){if _dcbfg ,_cbdd :=_cfdeb .(SMasker );_cbdd &&_dcbfg .HasAlpha (){_ecaf .(SMasker ).MakeAlpha ();};switch _abff :=_cfdeb .(type ){case Gray :_ebga (_abff ,_ecaf .(RGBA ),_gegc );
case NRGBA :_ddfa (_abff ,_ecaf .(RGBA ),_gegc );case *_a .NYCbCrA :_bcda (_abff ,_ecaf .(RGBA ),_gegc );case CMYK :_egbbb (_abff ,_ecaf .(RGBA ),_gegc );case RGBA :_eefe (_abff ,_ecaf .(RGBA ),_gegc );case nrgba64 :_affgd (_abff ,_ecaf .(RGBA ),_gegc );
default:_gaac (_cfdeb ,_ecaf ,_gegc );};};func (_fdg *NRGBA16 )ColorModel ()_g .Model {return NRGBA16Model };var _ Gray =&Gray8 {};func _agfg (_bgdc *_a .NYCbCrA ,_fcgbc NRGBA ,_baaf _a .Rectangle ){for _fdfb :=0;_fdfb < _baaf .Max .X ;_fdfb ++{for _bafe :=0;
_bafe < _baaf .Max .Y ;_bafe ++{_ffdf :=_bgdc .NYCbCrAAt (_fdfb ,_bafe );_fcgbc .SetNRGBA (_fdfb ,_bafe ,_acgc (_ffdf ));};};};type Gray2 struct{ImageBase };func ColorAtNRGBA16 (x ,y ,width ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_g .NRGBA ,error ){_feeeg :=y *bytesPerLine +x *3/2;
if _feeeg +1>=len (data ){return _g .NRGBA {},_dgee (x ,y );};const (_ggbe =0xf;_beeb =uint8 (0xff););_egba :=_beeb ;if alpha !=nil {_fecce :=y *BytesPerLine (width ,4,1);if _fecce < len (alpha ){if x %2==0{_egba =(alpha [_fecce ]>>uint (4))&_ggbe ;}else {_egba =alpha [_fecce ]&_ggbe ;
};_egba |=_egba <<4;};};var _fabc ,_ddbd ,_bdce uint8 ;if x *3%2==0{_fabc =(data [_feeeg ]>>uint (4))&_ggbe ;_ddbd =data [_feeeg ]&_ggbe ;_bdce =(data [_feeeg +1]>>uint (4))&_ggbe ;}else {_fabc =data [_feeeg ]&_ggbe ;_ddbd =(data [_feeeg +1]>>uint (4))&_ggbe ;
_bdce =data [_feeeg +1]&_ggbe ;};if len (decode )==6{_fabc =uint8 (uint32 (LinearInterpolate (float64 (_fabc ),0,15,decode [0],decode [1]))&0xf);_ddbd =uint8 (uint32 (LinearInterpolate (float64 (_ddbd ),0,15,decode [2],decode [3]))&0xf);_bdce =uint8 (uint32 (LinearInterpolate (float64 (_bdce ),0,15,decode [4],decode [5]))&0xf);
};return _g .NRGBA {R :(_fabc <<4)|(_fabc &0xf),G :(_ddbd <<4)|(_ddbd &0xf),B :(_bdce <<4)|(_bdce &0xf),A :_egba },nil ;};func _ace (_aca _g .NRGBA64 )_g .Gray {var _cfeb _g .NRGBA64 ;if _aca ==_cfeb {return _g .Gray {Y :0xff};};_dabf ,_bcbg ,_ffb ,_ :=_aca .RGBA ();
_gfb :=(19595*_dabf +38470*_bcbg +7471*_ffb +1<<15)>>24;return _g .Gray {Y :uint8 (_gfb )};};func (_abeg *Monochrome )Base ()*ImageBase {return &_abeg .ImageBase };var _ _a .Image =&Gray4 {};type NRGBA16 struct{ImageBase };func (_geg *Gray16 )GrayAt (x ,y int )_g .Gray {_gfdc ,_ :=_geg .ColorAt (x ,y );
return _g .Gray {Y :uint8 (_gfdc .(_g .Gray16 ).Y >>8)};};func (_aagf *ImageBase )Pix ()[]byte {return _aagf .Data };func ScaleAlphaToMonochrome (data []byte ,width ,height int )([]byte ,error ){_ad :=BytesPerLine (width ,8,1);if len (data )< _ad *height {return nil ,nil ;
};_db :=&Gray8 {NewImageBase (width ,height ,8,1,data ,nil ,nil )};_f ,_df :=MonochromeConverter .Convert (_db );if _df !=nil {return nil ,_df ;};return _f .Base ().Data ,nil ;};func (_cgff *NRGBA16 )Base ()*ImageBase {return &_cgff .ImageBase };func (_agff *Monochrome )Scale (scale float64 )(*Monochrome ,error ){var _gagc bool ;
_agc :=scale ;if scale < 1{_agc =1/scale ;_gagc =true ;};_bgd :=NextPowerOf2 (uint (_agc ));if InDelta (float64 (_bgd ),_agc ,0.001){if _gagc {return _agff .ReduceBinary (_agc );};return _agff .ExpandBinary (int (_bgd ));};_feee :=int (_c .RoundToEven (float64 (_agff .Width )*scale ));
_ebbgd :=int (_c .RoundToEven (float64 (_agff .Height )*scale ));return _agff .ScaleLow (_feee ,_ebbgd );};var _ _a .Image =&Gray2 {};func _abfdf (_bbcd _a .Image ,_afba Image ,_ccfb _a .Rectangle ){switch _agaf :=_bbcd .(type ){case Gray :_cfcef (_agaf ,_afba .(Gray ),_ccfb );
case NRGBA :_eeae (_agaf ,_afba .(Gray ),_ccfb );case CMYK :_aded (_agaf ,_afba .(Gray ),_ccfb );case RGBA :_gdabc (_agaf ,_afba .(Gray ),_ccfb );default:_gaac (_bbcd ,_afba .(Image ),_ccfb );};};var _ _a .Image =&Gray16 {};func (_daa *RGBA32 )SetRGBA (x ,y int ,c _g .RGBA ){_bbd :=y *_daa .Width +x ;
_beaf :=3*_bbd ;if _beaf +2>=len (_daa .Data ){return ;};_daa .setRGBA (_bbd ,c );};func _ece (_fff _g .CMYK )_g .RGBA {_abfd ,_ggf ,_bcc :=_g .CMYKToRGB (_fff .C ,_fff .M ,_fff .Y ,_fff .K );return _g .RGBA {R :_abfd ,G :_ggf ,B :_bcc ,A :0xff};};func init (){_gdad ()};
func (_dac *CMYK32 )Bounds ()_a .Rectangle {return _a .Rectangle {Max :_a .Point {X :_dac .Width ,Y :_dac .Height }};};func _geee (_fdbc *Monochrome ,_dggd ,_bdca ,_cgge ,_bbad int ,_edfb RasterOperator ,_ffab *Monochrome ,_cfaf ,_ebbe int )error {var (_dafd bool ;
_edgg bool ;_dbfc byte ;_feeaa int ;_faec int ;_gfag int ;_adeg int ;_bfcbc bool ;_bfgb int ;_cgdc int ;_eegc int ;_cbgcg bool ;_ggff byte ;_bbcb int ;_eee int ;_ffbda int ;_feceg byte ;_decac int ;_gbfe int ;_bgcc uint ;_gabf uint ;_adfc byte ;_edbe shift ;
_acce bool ;_bbgg bool ;_aefb ,_fefb int ;);if _cfaf &7!=0{_gbfe =8-(_cfaf &7);};if _dggd &7!=0{_faec =8-(_dggd &7);};if _gbfe ==0&&_faec ==0{_adfc =_fgfe [0];}else {if _faec > _gbfe {_bgcc =uint (_faec -_gbfe );}else {_bgcc =uint (8-(_gbfe -_faec ));};
_gabf =8-_bgcc ;_adfc =_fgfe [_bgcc ];};if (_dggd &7)!=0{_dafd =true ;_feeaa =8-(_dggd &7);_dbfc =_fgfe [_feeaa ];_gfag =_fdbc .BytesPerLine *_bdca +(_dggd >>3);_adeg =_ffab .BytesPerLine *_ebbe +(_cfaf >>3);_decac =8-(_cfaf &7);if _feeaa > _decac {_edbe =_aefc ;
if _cgge >=_gbfe {_acce =true ;};}else {_edbe =_affef ;};};if _cgge < _feeaa {_edgg =true ;_dbfc &=_ffdba [8-_feeaa +_cgge ];};if !_edgg {_bfgb =(_cgge -_feeaa )>>3;if _bfgb !=0{_bfcbc =true ;_cgdc =_fdbc .BytesPerLine *_bdca +((_dggd +_faec )>>3);_eegc =_ffab .BytesPerLine *_ebbe +((_cfaf +_faec )>>3);
};};_bbcb =(_dggd +_cgge )&7;if !(_edgg ||_bbcb ==0){_cbgcg =true ;_ggff =_ffdba [_bbcb ];_eee =_fdbc .BytesPerLine *_bdca +((_dggd +_faec )>>3)+_bfgb ;_ffbda =_ffab .BytesPerLine *_ebbe +((_cfaf +_faec )>>3)+_bfgb ;if _bbcb > int (_gabf ){_bbgg =true ;
};};switch _edfb {case PixSrc :if _dafd {for _aefb =0;_aefb < _bbad ;_aefb ++{if _edbe ==_aefc {_feceg =_ffab .Data [_adeg ]<<_bgcc ;if _acce {_feceg =_gfdg (_feceg ,_ffab .Data [_adeg +1]>>_gabf ,_adfc );};}else {_feceg =_ffab .Data [_adeg ]>>_gabf ;};
_fdbc .Data [_gfag ]=_gfdg (_fdbc .Data [_gfag ],_feceg ,_dbfc );_gfag +=_fdbc .BytesPerLine ;_adeg +=_ffab .BytesPerLine ;};};if _bfcbc {for _aefb =0;_aefb < _bbad ;_aefb ++{for _fefb =0;_fefb < _bfgb ;_fefb ++{_feceg =_gfdg (_ffab .Data [_eegc +_fefb ]<<_bgcc ,_ffab .Data [_eegc +_fefb +1]>>_gabf ,_adfc );
_fdbc .Data [_cgdc +_fefb ]=_feceg ;};_cgdc +=_fdbc .BytesPerLine ;_eegc +=_ffab .BytesPerLine ;};};if _cbgcg {for _aefb =0;_aefb < _bbad ;_aefb ++{_feceg =_ffab .Data [_ffbda ]<<_bgcc ;if _bbgg {_feceg =_gfdg (_feceg ,_ffab .Data [_ffbda +1]>>_gabf ,_adfc );
};_fdbc .Data [_eee ]=_gfdg (_fdbc .Data [_eee ],_feceg ,_ggff );_eee +=_fdbc .BytesPerLine ;_ffbda +=_ffab .BytesPerLine ;};};case PixNotSrc :if _dafd {for _aefb =0;_aefb < _bbad ;_aefb ++{if _edbe ==_aefc {_feceg =_ffab .Data [_adeg ]<<_bgcc ;if _acce {_feceg =_gfdg (_feceg ,_ffab .Data [_adeg +1]>>_gabf ,_adfc );
};}else {_feceg =_ffab .Data [_adeg ]>>_gabf ;};_fdbc .Data [_gfag ]=_gfdg (_fdbc .Data [_gfag ],^_feceg ,_dbfc );_gfag +=_fdbc .BytesPerLine ;_adeg +=_ffab .BytesPerLine ;};};if _bfcbc {for _aefb =0;_aefb < _bbad ;_aefb ++{for _fefb =0;_fefb < _bfgb ;
_fefb ++{_feceg =_gfdg (_ffab .Data [_eegc +_fefb ]<<_bgcc ,_ffab .Data [_eegc +_fefb +1]>>_gabf ,_adfc );_fdbc .Data [_cgdc +_fefb ]=^_feceg ;};_cgdc +=_fdbc .BytesPerLine ;_eegc +=_ffab .BytesPerLine ;};};if _cbgcg {for _aefb =0;_aefb < _bbad ;_aefb ++{_feceg =_ffab .Data [_ffbda ]<<_bgcc ;
if _bbgg {_feceg =_gfdg (_feceg ,_ffab .Data [_ffbda +1]>>_gabf ,_adfc );};_fdbc .Data [_eee ]=_gfdg (_fdbc .Data [_eee ],^_feceg ,_ggff );_eee +=_fdbc .BytesPerLine ;_ffbda +=_ffab .BytesPerLine ;};};case PixSrcOrDst :if _dafd {for _aefb =0;_aefb < _bbad ;
_aefb ++{if _edbe ==_aefc {_feceg =_ffab .Data [_adeg ]<<_bgcc ;if _acce {_feceg =_gfdg (_feceg ,_ffab .Data [_adeg +1]>>_gabf ,_adfc );};}else {_feceg =_ffab .Data [_adeg ]>>_gabf ;};_fdbc .Data [_gfag ]=_gfdg (_fdbc .Data [_gfag ],_feceg |_fdbc .Data [_gfag ],_dbfc );
_gfag +=_fdbc .BytesPerLine ;_adeg +=_ffab .BytesPerLine ;};};if _bfcbc {for _aefb =0;_aefb < _bbad ;_aefb ++{for _fefb =0;_fefb < _bfgb ;_fefb ++{_feceg =_gfdg (_ffab .Data [_eegc +_fefb ]<<_bgcc ,_ffab .Data [_eegc +_fefb +1]>>_gabf ,_adfc );_fdbc .Data [_cgdc +_fefb ]|=_feceg ;
};_cgdc +=_fdbc .BytesPerLine ;_eegc +=_ffab .BytesPerLine ;};};if _cbgcg {for _aefb =0;_aefb < _bbad ;_aefb ++{_feceg =_ffab .Data [_ffbda ]<<_bgcc ;if _bbgg {_feceg =_gfdg (_feceg ,_ffab .Data [_ffbda +1]>>_gabf ,_adfc );};_fdbc .Data [_eee ]=_gfdg (_fdbc .Data [_eee ],_feceg |_fdbc .Data [_eee ],_ggff );
_eee +=_fdbc .BytesPerLine ;_ffbda +=_ffab .BytesPerLine ;};};case PixSrcAndDst :if _dafd {for _aefb =0;_aefb < _bbad ;_aefb ++{if _edbe ==_aefc {_feceg =_ffab .Data [_adeg ]<<_bgcc ;if _acce {_feceg =_gfdg (_feceg ,_ffab .Data [_adeg +1]>>_gabf ,_adfc );
};}else {_feceg =_ffab .Data [_adeg ]>>_gabf ;};_fdbc .Data [_gfag ]=_gfdg (_fdbc .Data [_gfag ],_feceg &_fdbc .Data [_gfag ],_dbfc );_gfag +=_fdbc .BytesPerLine ;_adeg +=_ffab .BytesPerLine ;};};if _bfcbc {for _aefb =0;_aefb < _bbad ;_aefb ++{for _fefb =0;
_fefb < _bfgb ;_fefb ++{_feceg =_gfdg (_ffab .Data [_eegc +_fefb ]<<_bgcc ,_ffab .Data [_eegc +_fefb +1]>>_gabf ,_adfc );_fdbc .Data [_cgdc +_fefb ]&=_feceg ;};_cgdc +=_fdbc .BytesPerLine ;_eegc +=_ffab .BytesPerLine ;};};if _cbgcg {for _aefb =0;_aefb < _bbad ;
_aefb ++{_feceg =_ffab .Data [_ffbda ]<<_bgcc ;if _bbgg {_feceg =_gfdg (_feceg ,_ffab .Data [_ffbda +1]>>_gabf ,_adfc );};_fdbc .Data [_eee ]=_gfdg (_fdbc .Data [_eee ],_feceg &_fdbc .Data [_eee ],_ggff );_eee +=_fdbc .BytesPerLine ;_ffbda +=_ffab .BytesPerLine ;
};};case PixSrcXorDst :if _dafd {for _aefb =0;_aefb < _bbad ;_aefb ++{if _edbe ==_aefc {_feceg =_ffab .Data [_adeg ]<<_bgcc ;if _acce {_feceg =_gfdg (_feceg ,_ffab .Data [_adeg +1]>>_gabf ,_adfc );};}else {_feceg =_ffab .Data [_adeg ]>>_gabf ;};_fdbc .Data [_gfag ]=_gfdg (_fdbc .Data [_gfag ],_feceg ^_fdbc .Data [_gfag ],_dbfc );
_gfag +=_fdbc .BytesPerLine ;_adeg +=_ffab .BytesPerLine ;};};if _bfcbc {for _aefb =0;_aefb < _bbad ;_aefb ++{for _fefb =0;_fefb < _bfgb ;_fefb ++{_feceg =_gfdg (_ffab .Data [_eegc +_fefb ]<<_bgcc ,_ffab .Data [_eegc +_fefb +1]>>_gabf ,_adfc );_fdbc .Data [_cgdc +_fefb ]^=_feceg ;
};_cgdc +=_fdbc .BytesPerLine ;_eegc +=_ffab .BytesPerLine ;};};if _cbgcg {for _aefb =0;_aefb < _bbad ;_aefb ++{_feceg =_ffab .Data [_ffbda ]<<_bgcc ;if _bbgg {_feceg =_gfdg (_feceg ,_ffab .Data [_ffbda +1]>>_gabf ,_adfc );};_fdbc .Data [_eee ]=_gfdg (_fdbc .Data [_eee ],_feceg ^_fdbc .Data [_eee ],_ggff );
_eee +=_fdbc .BytesPerLine ;_ffbda +=_ffab .BytesPerLine ;};};case PixNotSrcOrDst :if _dafd {for _aefb =0;_aefb < _bbad ;_aefb ++{if _edbe ==_aefc {_feceg =_ffab .Data [_adeg ]<<_bgcc ;if _acce {_feceg =_gfdg (_feceg ,_ffab .Data [_adeg +1]>>_gabf ,_adfc );
};}else {_feceg =_ffab .Data [_adeg ]>>_gabf ;};_fdbc .Data [_gfag ]=_gfdg (_fdbc .Data [_gfag ],^_feceg |_fdbc .Data [_gfag ],_dbfc );_gfag +=_fdbc .BytesPerLine ;_adeg +=_ffab .BytesPerLine ;};};if _bfcbc {for _aefb =0;_aefb < _bbad ;_aefb ++{for _fefb =0;
_fefb < _bfgb ;_fefb ++{_feceg =_gfdg (_ffab .Data [_eegc +_fefb ]<<_bgcc ,_ffab .Data [_eegc +_fefb +1]>>_gabf ,_adfc );_fdbc .Data [_cgdc +_fefb ]|=^_feceg ;};_cgdc +=_fdbc .BytesPerLine ;_eegc +=_ffab .BytesPerLine ;};};if _cbgcg {for _aefb =0;_aefb < _bbad ;
_aefb ++{_feceg =_ffab .Data [_ffbda ]<<_bgcc ;if _bbgg {_feceg =_gfdg (_feceg ,_ffab .Data [_ffbda +1]>>_gabf ,_adfc );};_fdbc .Data [_eee ]=_gfdg (_fdbc .Data [_eee ],^_feceg |_fdbc .Data [_eee ],_ggff );_eee +=_fdbc .BytesPerLine ;_ffbda +=_ffab .BytesPerLine ;
};};case PixNotSrcAndDst :if _dafd {for _aefb =0;_aefb < _bbad ;_aefb ++{if _edbe ==_aefc {_feceg =_ffab .Data [_adeg ]<<_bgcc ;if _acce {_feceg =_gfdg (_feceg ,_ffab .Data [_adeg +1]>>_gabf ,_adfc );};}else {_feceg =_ffab .Data [_adeg ]>>_gabf ;};_fdbc .Data [_gfag ]=_gfdg (_fdbc .Data [_gfag ],^_feceg &_fdbc .Data [_gfag ],_dbfc );
_gfag +=_fdbc .BytesPerLine ;_adeg +=_ffab .BytesPerLine ;};};if _bfcbc {for _aefb =0;_aefb < _bbad ;_aefb ++{for _fefb =0;_fefb < _bfgb ;_fefb ++{_feceg =_gfdg (_ffab .Data [_eegc +_fefb ]<<_bgcc ,_ffab .Data [_eegc +_fefb +1]>>_gabf ,_adfc );_fdbc .Data [_cgdc +_fefb ]&=^_feceg ;
};_cgdc +=_fdbc .BytesPerLine ;_eegc +=_ffab .BytesPerLine ;};};if _cbgcg {for _aefb =0;_aefb < _bbad ;_aefb ++{_feceg =_ffab .Data [_ffbda ]<<_bgcc ;if _bbgg {_feceg =_gfdg (_feceg ,_ffab .Data [_ffbda +1]>>_gabf ,_adfc );};_fdbc .Data [_eee ]=_gfdg (_fdbc .Data [_eee ],^_feceg &_fdbc .Data [_eee ],_ggff );
_eee +=_fdbc .BytesPerLine ;_ffbda +=_ffab .BytesPerLine ;};};case PixSrcOrNotDst :if _dafd {for _aefb =0;_aefb < _bbad ;_aefb ++{if _edbe ==_aefc {_feceg =_ffab .Data [_adeg ]<<_bgcc ;if _acce {_feceg =_gfdg (_feceg ,_ffab .Data [_adeg +1]>>_gabf ,_adfc );
};}else {_feceg =_ffab .Data [_adeg ]>>_gabf ;};_fdbc .Data [_gfag ]=_gfdg (_fdbc .Data [_gfag ],_feceg |^_fdbc .Data [_gfag ],_dbfc );_gfag +=_fdbc .BytesPerLine ;_adeg +=_ffab .BytesPerLine ;};};if _bfcbc {for _aefb =0;_aefb < _bbad ;_aefb ++{for _fefb =0;
_fefb < _bfgb ;_fefb ++{_feceg =_gfdg (_ffab .Data [_eegc +_fefb ]<<_bgcc ,_ffab .Data [_eegc +_fefb +1]>>_gabf ,_adfc );_fdbc .Data [_cgdc +_fefb ]=_feceg |^_fdbc .Data [_cgdc +_fefb ];};_cgdc +=_fdbc .BytesPerLine ;_eegc +=_ffab .BytesPerLine ;};};if _cbgcg {for _aefb =0;
_aefb < _bbad ;_aefb ++{_feceg =_ffab .Data [_ffbda ]<<_bgcc ;if _bbgg {_feceg =_gfdg (_feceg ,_ffab .Data [_ffbda +1]>>_gabf ,_adfc );};_fdbc .Data [_eee ]=_gfdg (_fdbc .Data [_eee ],_feceg |^_fdbc .Data [_eee ],_ggff );_eee +=_fdbc .BytesPerLine ;_ffbda +=_ffab .BytesPerLine ;
};};case PixSrcAndNotDst :if _dafd {for _aefb =0;_aefb < _bbad ;_aefb ++{if _edbe ==_aefc {_feceg =_ffab .Data [_adeg ]<<_bgcc ;if _acce {_feceg =_gfdg (_feceg ,_ffab .Data [_adeg +1]>>_gabf ,_adfc );};}else {_feceg =_ffab .Data [_adeg ]>>_gabf ;};_fdbc .Data [_gfag ]=_gfdg (_fdbc .Data [_gfag ],_feceg &^_fdbc .Data [_gfag ],_dbfc );
_gfag +=_fdbc .BytesPerLine ;_adeg +=_ffab .BytesPerLine ;};};if _bfcbc {for _aefb =0;_aefb < _bbad ;_aefb ++{for _fefb =0;_fefb < _bfgb ;_fefb ++{_feceg =_gfdg (_ffab .Data [_eegc +_fefb ]<<_bgcc ,_ffab .Data [_eegc +_fefb +1]>>_gabf ,_adfc );_fdbc .Data [_cgdc +_fefb ]=_feceg &^_fdbc .Data [_cgdc +_fefb ];
};_cgdc +=_fdbc .BytesPerLine ;_eegc +=_ffab .BytesPerLine ;};};if _cbgcg {for _aefb =0;_aefb < _bbad ;_aefb ++{_feceg =_ffab .Data [_ffbda ]<<_bgcc ;if _bbgg {_feceg =_gfdg (_feceg ,_ffab .Data [_ffbda +1]>>_gabf ,_adfc );};_fdbc .Data [_eee ]=_gfdg (_fdbc .Data [_eee ],_feceg &^_fdbc .Data [_eee ],_ggff );
_eee +=_fdbc .BytesPerLine ;_ffbda +=_ffab .BytesPerLine ;};};case PixNotPixSrcOrDst :if _dafd {for _aefb =0;_aefb < _bbad ;_aefb ++{if _edbe ==_aefc {_feceg =_ffab .Data [_adeg ]<<_bgcc ;if _acce {_feceg =_gfdg (_feceg ,_ffab .Data [_adeg +1]>>_gabf ,_adfc );
};}else {_feceg =_ffab .Data [_adeg ]>>_gabf ;};_fdbc .Data [_gfag ]=_gfdg (_fdbc .Data [_gfag ],^(_feceg |_fdbc .Data [_gfag ]),_dbfc );_gfag +=_fdbc .BytesPerLine ;_adeg +=_ffab .BytesPerLine ;};};if _bfcbc {for _aefb =0;_aefb < _bbad ;_aefb ++{for _fefb =0;
_fefb < _bfgb ;_fefb ++{_feceg =_gfdg (_ffab .Data [_eegc +_fefb ]<<_bgcc ,_ffab .Data [_eegc +_fefb +1]>>_gabf ,_adfc );_fdbc .Data [_cgdc +_fefb ]=^(_feceg |_fdbc .Data [_cgdc +_fefb ]);};_cgdc +=_fdbc .BytesPerLine ;_eegc +=_ffab .BytesPerLine ;};};
if _cbgcg {for _aefb =0;_aefb < _bbad ;_aefb ++{_feceg =_ffab .Data [_ffbda ]<<_bgcc ;if _bbgg {_feceg =_gfdg (_feceg ,_ffab .Data [_ffbda +1]>>_gabf ,_adfc );};_fdbc .Data [_eee ]=_gfdg (_fdbc .Data [_eee ],^(_feceg |_fdbc .Data [_eee ]),_ggff );_eee +=_fdbc .BytesPerLine ;
_ffbda +=_ffab .BytesPerLine ;};};case PixNotPixSrcAndDst :if _dafd {for _aefb =0;_aefb < _bbad ;_aefb ++{if _edbe ==_aefc {_feceg =_ffab .Data [_adeg ]<<_bgcc ;if _acce {_feceg =_gfdg (_feceg ,_ffab .Data [_adeg +1]>>_gabf ,_adfc );};}else {_feceg =_ffab .Data [_adeg ]>>_gabf ;
};_fdbc .Data [_gfag ]=_gfdg (_fdbc .Data [_gfag ],^(_feceg &_fdbc .Data [_gfag ]),_dbfc );_gfag +=_fdbc .BytesPerLine ;_adeg +=_ffab .BytesPerLine ;};};if _bfcbc {for _aefb =0;_aefb < _bbad ;_aefb ++{for _fefb =0;_fefb < _bfgb ;_fefb ++{_feceg =_gfdg (_ffab .Data [_eegc +_fefb ]<<_bgcc ,_ffab .Data [_eegc +_fefb +1]>>_gabf ,_adfc );
_fdbc .Data [_cgdc +_fefb ]=^(_feceg &_fdbc .Data [_cgdc +_fefb ]);};_cgdc +=_fdbc .BytesPerLine ;_eegc +=_ffab .BytesPerLine ;};};if _cbgcg {for _aefb =0;_aefb < _bbad ;_aefb ++{_feceg =_ffab .Data [_ffbda ]<<_bgcc ;if _bbgg {_feceg =_gfdg (_feceg ,_ffab .Data [_ffbda +1]>>_gabf ,_adfc );
};_fdbc .Data [_eee ]=_gfdg (_fdbc .Data [_eee ],^(_feceg &_fdbc .Data [_eee ]),_ggff );_eee +=_fdbc .BytesPerLine ;_ffbda +=_ffab .BytesPerLine ;};};case PixNotPixSrcXorDst :if _dafd {for _aefb =0;_aefb < _bbad ;_aefb ++{if _edbe ==_aefc {_feceg =_ffab .Data [_adeg ]<<_bgcc ;
if _acce {_feceg =_gfdg (_feceg ,_ffab .Data [_adeg +1]>>_gabf ,_adfc );};}else {_feceg =_ffab .Data [_adeg ]>>_gabf ;};_fdbc .Data [_gfag ]=_gfdg (_fdbc .Data [_gfag ],^(_feceg ^_fdbc .Data [_gfag ]),_dbfc );_gfag +=_fdbc .BytesPerLine ;_adeg +=_ffab .BytesPerLine ;
};};if _bfcbc {for _aefb =0;_aefb < _bbad ;_aefb ++{for _fefb =0;_fefb < _bfgb ;_fefb ++{_feceg =_gfdg (_ffab .Data [_eegc +_fefb ]<<_bgcc ,_ffab .Data [_eegc +_fefb +1]>>_gabf ,_adfc );_fdbc .Data [_cgdc +_fefb ]=^(_feceg ^_fdbc .Data [_cgdc +_fefb ]);
};_cgdc +=_fdbc .BytesPerLine ;_eegc +=_ffab .BytesPerLine ;};};if _cbgcg {for _aefb =0;_aefb < _bbad ;_aefb ++{_feceg =_ffab .Data [_ffbda ]<<_bgcc ;if _bbgg {_feceg =_gfdg (_feceg ,_ffab .Data [_ffbda +1]>>_gabf ,_adfc );};_fdbc .Data [_eee ]=_gfdg (_fdbc .Data [_eee ],^(_feceg ^_fdbc .Data [_eee ]),_ggff );
_eee +=_fdbc .BytesPerLine ;_ffbda +=_ffab .BytesPerLine ;};};default:_cbd .Log .Debug ("\u004f\u0070e\u0072\u0061\u0074\u0069\u006f\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006e\u006f\u0074\u0020\u0070\u0065\u0072\u006d\u0069tt\u0065\u0064",_edfb );
return _bd .New ("\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065r\u0061\u0074\u0069\u006f\u006e\u0020\u006eo\u0074\u0020\u0070\u0065\u0072\u006d\u0069\u0074\u0074\u0065\u0064");};return nil ;};func _bdeb (_eebd _g .CMYK )_g .NRGBA {_cce ,_dgf ,_dbdf :=_g .CMYKToRGB (_eebd .C ,_eebd .M ,_eebd .Y ,_eebd .K );
return _g .NRGBA {R :_cce ,G :_dgf ,B :_dbdf ,A :0xff};};func _cfg ()(_bad [256]uint64 ){for _ebf :=0;_ebf < 256;_ebf ++{if _ebf &0x01!=0{_bad [_ebf ]|=0xff;};if _ebf &0x02!=0{_bad [_ebf ]|=0xff00;};if _ebf &0x04!=0{_bad [_ebf ]|=0xff0000;};if _ebf &0x08!=0{_bad [_ebf ]|=0xff000000;
};if _ebf &0x10!=0{_bad [_ebf ]|=0xff00000000;};if _ebf &0x20!=0{_bad [_ebf ]|=0xff0000000000;};if _ebf &0x40!=0{_bad [_ebf ]|=0xff000000000000;};if _ebf &0x80!=0{_bad [_ebf ]|=0xff00000000000000;};};return _bad ;};func (_ecfde *Gray4 )GrayAt (x ,y int )_g .Gray {_debe ,_ :=ColorAtGray4BPC (x ,y ,_ecfde .BytesPerLine ,_ecfde .Data ,_ecfde .Decode );
return _debe ;};func MonochromeModel (threshold uint8 )_g .Model {return monochromeModel (threshold )};func (_bgda *Monochrome )getBit (_fcd ,_cegff int )uint8 {return _bgda .Data [_fcd +(_cegff >>3)]>>uint (7-(_cegff &7))&1;};func _cbdf (_aee ,_egde int )*Monochrome {return &Monochrome {ImageBase :NewImageBase (_aee ,_egde ,1,1,nil ,nil ,nil ),ModelThreshold :0x0f};
};func _efcg (_eeec _a .Image )(Image ,error ){if _ddgb ,_gcfge :=_eeec .(*NRGBA32 );_gcfge {return _ddgb .Copy (),nil ;};_eegg ,_bgeed ,_cddc :=_bgfca (_eeec ,1);_bedaa ,_bdef :=NewImage (_eegg .Max .X ,_eegg .Max .Y ,8,3,nil ,_cddc ,nil );if _bdef !=nil {return nil ,_bdef ;
};_gageb (_eeec ,_bedaa ,_eegg );if len (_cddc )!=0&&!_bgeed {if _gffg :=_dgcd (_cddc ,_bedaa );_gffg !=nil {return nil ,_gffg ;};};return _bedaa ,nil ;};func _befc (_fdeb Gray ,_dgae NRGBA ,_gdae _a .Rectangle ){for _gdc :=0;_gdc < _gdae .Max .X ;_gdc ++{for _fgga :=0;
_fgga < _gdae .Max .Y ;_fgga ++{_dcef :=_fdeb .GrayAt (_gdc ,_fgga );_dgae .SetNRGBA (_gdc ,_fgga ,_bafb (_dcef ));};};};func (_ecbg *Monochrome )setBit (_dgfd ,_afcd int ){_ecbg .Data [_dgfd +(_afcd >>3)]|=0x80>>uint (_afcd &7);};func (_ffdb *Gray2 )Bounds ()_a .Rectangle {return _a .Rectangle {Max :_a .Point {X :_ffdb .Width ,Y :_ffdb .Height }};
};func _ccea (_dgba *Monochrome ,_aef ,_cea ,_gfea ,_gbaa int ,_gcfa RasterOperator ,_aafd *Monochrome ,_bcbcd ,_bfd int )error {var (_egaf byte ;_dafga int ;_eddg int ;_dgcg ,_babb int ;_eedf ,_debeg int ;);_dbgfd :=_gfea >>3;_eag :=_gfea &7;if _eag > 0{_egaf =_ffdba [_eag ];
};_dafga =_aafd .BytesPerLine *_bfd +(_bcbcd >>3);_eddg =_dgba .BytesPerLine *_cea +(_aef >>3);switch _gcfa {case PixSrc :for _eedf =0;_eedf < _gbaa ;_eedf ++{_dgcg =_dafga +_eedf *_aafd .BytesPerLine ;_babb =_eddg +_eedf *_dgba .BytesPerLine ;for _debeg =0;
_debeg < _dbgfd ;_debeg ++{_dgba .Data [_babb ]=_aafd .Data [_dgcg ];_babb ++;_dgcg ++;};if _eag > 0{_dgba .Data [_babb ]=_gfdg (_dgba .Data [_babb ],_aafd .Data [_dgcg ],_egaf );};};case PixNotSrc :for _eedf =0;_eedf < _gbaa ;_eedf ++{_dgcg =_dafga +_eedf *_aafd .BytesPerLine ;
_babb =_eddg +_eedf *_dgba .BytesPerLine ;for _debeg =0;_debeg < _dbgfd ;_debeg ++{_dgba .Data [_babb ]=^(_aafd .Data [_dgcg ]);_babb ++;_dgcg ++;};if _eag > 0{_dgba .Data [_babb ]=_gfdg (_dgba .Data [_babb ],^_aafd .Data [_dgcg ],_egaf );};};case PixSrcOrDst :for _eedf =0;
_eedf < _gbaa ;_eedf ++{_dgcg =_dafga +_eedf *_aafd .BytesPerLine ;_babb =_eddg +_eedf *_dgba .BytesPerLine ;for _debeg =0;_debeg < _dbgfd ;_debeg ++{_dgba .Data [_babb ]|=_aafd .Data [_dgcg ];_babb ++;_dgcg ++;};if _eag > 0{_dgba .Data [_babb ]=_gfdg (_dgba .Data [_babb ],_aafd .Data [_dgcg ]|_dgba .Data [_babb ],_egaf );
};};case PixSrcAndDst :for _eedf =0;_eedf < _gbaa ;_eedf ++{_dgcg =_dafga +_eedf *_aafd .BytesPerLine ;_babb =_eddg +_eedf *_dgba .BytesPerLine ;for _debeg =0;_debeg < _dbgfd ;_debeg ++{_dgba .Data [_babb ]&=_aafd .Data [_dgcg ];_babb ++;_dgcg ++;};if _eag > 0{_dgba .Data [_babb ]=_gfdg (_dgba .Data [_babb ],_aafd .Data [_dgcg ]&_dgba .Data [_babb ],_egaf );
};};case PixSrcXorDst :for _eedf =0;_eedf < _gbaa ;_eedf ++{_dgcg =_dafga +_eedf *_aafd .BytesPerLine ;_babb =_eddg +_eedf *_dgba .BytesPerLine ;for _debeg =0;_debeg < _dbgfd ;_debeg ++{_dgba .Data [_babb ]^=_aafd .Data [_dgcg ];_babb ++;_dgcg ++;};if _eag > 0{_dgba .Data [_babb ]=_gfdg (_dgba .Data [_babb ],_aafd .Data [_dgcg ]^_dgba .Data [_babb ],_egaf );
};};case PixNotSrcOrDst :for _eedf =0;_eedf < _gbaa ;_eedf ++{_dgcg =_dafga +_eedf *_aafd .BytesPerLine ;_babb =_eddg +_eedf *_dgba .BytesPerLine ;for _debeg =0;_debeg < _dbgfd ;_debeg ++{_dgba .Data [_babb ]|=^(_aafd .Data [_dgcg ]);_babb ++;_dgcg ++;
};if _eag > 0{_dgba .Data [_babb ]=_gfdg (_dgba .Data [_babb ],^(_aafd .Data [_dgcg ])|_dgba .Data [_babb ],_egaf );};};case PixNotSrcAndDst :for _eedf =0;_eedf < _gbaa ;_eedf ++{_dgcg =_dafga +_eedf *_aafd .BytesPerLine ;_babb =_eddg +_eedf *_dgba .BytesPerLine ;
for _debeg =0;_debeg < _dbgfd ;_debeg ++{_dgba .Data [_babb ]&=^(_aafd .Data [_dgcg ]);_babb ++;_dgcg ++;};if _eag > 0{_dgba .Data [_babb ]=_gfdg (_dgba .Data [_babb ],^(_aafd .Data [_dgcg ])&_dgba .Data [_babb ],_egaf );};};case PixSrcOrNotDst :for _eedf =0;
_eedf < _gbaa ;_eedf ++{_dgcg =_dafga +_eedf *_aafd .BytesPerLine ;_babb =_eddg +_eedf *_dgba .BytesPerLine ;for _debeg =0;_debeg < _dbgfd ;_debeg ++{_dgba .Data [_babb ]=_aafd .Data [_dgcg ]|^(_dgba .Data [_babb ]);_babb ++;_dgcg ++;};if _eag > 0{_dgba .Data [_babb ]=_gfdg (_dgba .Data [_babb ],_aafd .Data [_dgcg ]|^(_dgba .Data [_babb ]),_egaf );
};};case PixSrcAndNotDst :for _eedf =0;_eedf < _gbaa ;_eedf ++{_dgcg =_dafga +_eedf *_aafd .BytesPerLine ;_babb =_eddg +_eedf *_dgba .BytesPerLine ;for _debeg =0;_debeg < _dbgfd ;_debeg ++{_dgba .Data [_babb ]=_aafd .Data [_dgcg ]&^(_dgba .Data [_babb ]);
_babb ++;_dgcg ++;};if _eag > 0{_dgba .Data [_babb ]=_gfdg (_dgba .Data [_babb ],_aafd .Data [_dgcg ]&^(_dgba .Data [_babb ]),_egaf );};};case PixNotPixSrcOrDst :for _eedf =0;_eedf < _gbaa ;_eedf ++{_dgcg =_dafga +_eedf *_aafd .BytesPerLine ;_babb =_eddg +_eedf *_dgba .BytesPerLine ;
for _debeg =0;_debeg < _dbgfd ;_debeg ++{_dgba .Data [_babb ]=^(_aafd .Data [_dgcg ]|_dgba .Data [_babb ]);_babb ++;_dgcg ++;};if _eag > 0{_dgba .Data [_babb ]=_gfdg (_dgba .Data [_babb ],^(_aafd .Data [_dgcg ]|_dgba .Data [_babb ]),_egaf );};};case PixNotPixSrcAndDst :for _eedf =0;
_eedf < _gbaa ;_eedf ++{_dgcg =_dafga +_eedf *_aafd .BytesPerLine ;_babb =_eddg +_eedf *_dgba .BytesPerLine ;for _debeg =0;_debeg < _dbgfd ;_debeg ++{_dgba .Data [_babb ]=^(_aafd .Data [_dgcg ]&_dgba .Data [_babb ]);_babb ++;_dgcg ++;};if _eag > 0{_dgba .Data [_babb ]=_gfdg (_dgba .Data [_babb ],^(_aafd .Data [_dgcg ]&_dgba .Data [_babb ]),_egaf );
};};case PixNotPixSrcXorDst :for _eedf =0;_eedf < _gbaa ;_eedf ++{_dgcg =_dafga +_eedf *_aafd .BytesPerLine ;_babb =_eddg +_eedf *_dgba .BytesPerLine ;for _debeg =0;_debeg < _dbgfd ;_debeg ++{_dgba .Data [_babb ]=^(_aafd .Data [_dgcg ]^_dgba .Data [_babb ]);
_babb ++;_dgcg ++;};if _eag > 0{_dgba .Data [_babb ]=_gfdg (_dgba .Data [_babb ],^(_aafd .Data [_dgcg ]^_dgba .Data [_babb ]),_egaf );};};default:_cbd .Log .Debug ("\u0050\u0072ov\u0069\u0064\u0065d\u0020\u0069\u006e\u0076ali\u0064 r\u0061\u0073\u0074\u0065\u0072\u0020\u006fpe\u0072\u0061\u0074\u006f\u0072\u003a\u0020%\u0076",_gcfa );
return _bd .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072");};return nil ;};func _bbcf (_bgbg _g .NRGBA )_g .Gray {_fbf ,_dge ,_dab ,_ :=_bgbg .RGBA ();_afb :=(19595*_fbf +38470*_dge +7471*_dab +1<<15)>>24;
return _g .Gray {Y :uint8 (_afb )};};func _fcgb (_dadg _a .Image )(Image ,error ){if _cegc ,_gca :=_dadg .(*Gray16 );_gca {return _cegc .Copy (),nil ;};_dca :=_dadg .Bounds ();_facc ,_fbead :=NewImage (_dca .Max .X ,_dca .Max .Y ,16,1,nil ,nil ,nil );if _fbead !=nil {return nil ,_fbead ;
};_abfdf (_dadg ,_facc ,_dca );return _facc ,nil ;};func (_gaced *NRGBA64 )Set (x ,y int ,c _g .Color ){_afadb :=(y *_gaced .Width +x )*2;_eabg :=_afadb *3;if _eabg +5>=len (_gaced .Data ){return ;};_cbcee :=_g .NRGBA64Model .Convert (c ).(_g .NRGBA64 );
_gaced .setNRGBA64 (_eabg ,_cbcee ,_afadb );};func (_dad *Gray2 )At (x ,y int )_g .Color {_dacc ,_ :=_dad .ColorAt (x ,y );return _dacc };var _ Image =&Gray8 {};func (_bged *NRGBA64 )ColorModel ()_g .Model {return _g .NRGBA64Model };func (_bggfa *RGBA32 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtRGBA32 (x ,y ,_bggfa .Width ,_bggfa .Data ,_bggfa .Alpha ,_bggfa .Decode );
};func _gac (_dbgf Gray ,_bff CMYK ,_dbgd _a .Rectangle ){for _ccdd :=0;_ccdd < _dbgd .Max .X ;_ccdd ++{for _eafd :=0;_eafd < _dbgd .Max .Y ;_eafd ++{_egc :=_dbgf .GrayAt (_ccdd ,_eafd );_bff .SetCMYK (_ccdd ,_eafd ,_bebf (_egc ));};};};type NRGBA32 struct{ImageBase };
func _fc (_gaa int )[]uint {var _acf []uint ;_ada :=_gaa ;_bc :=_ada /8;if _bc !=0{for _eca :=0;_eca < _bc ;_eca ++{_acf =append (_acf ,8);};_dfeg :=_ada %8;_ada =0;if _dfeg !=0{_ada =_dfeg ;};};_gbd :=_ada /4;if _gbd !=0{for _acd :=0;_acd < _gbd ;_acd ++{_acf =append (_acf ,4);
};_fbd :=_ada %4;_ada =0;if _fbd !=0{_ada =_fbd ;};};_beb :=_ada /2;if _beb !=0{for _cde :=0;_cde < _beb ;_cde ++{_acf =append (_acf ,2);};};return _acf ;};var ErrInvalidImage =_bd .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
func (_ddfg *CMYK32 )Set (x ,y int ,c _g .Color ){_egb :=4*(y *_ddfg .Width +x );if _egb +3>=len (_ddfg .Data ){return ;};_fgf :=_g .CMYKModel .Convert (c ).(_g .CMYK );_ddfg .Data [_egb ]=_fgf .C ;_ddfg .Data [_egb +1]=_fgf .M ;_ddfg .Data [_egb +2]=_fgf .Y ;
_ddfg .Data [_egb +3]=_fgf .K ;};func _egbbb (_fega CMYK ,_gbgg RGBA ,_febd _a .Rectangle ){for _gfbc :=0;_gfbc < _febd .Max .X ;_gfbc ++{for _bced :=0;_bced < _febd .Max .Y ;_bced ++{_aeabb :=_fega .CMYKAt (_gfbc ,_bced );_gbgg .SetRGBA (_gfbc ,_bced ,_ece (_aeabb ));
};};};func (_fbg *Gray4 )At (x ,y int )_g .Color {_ffbe ,_ :=_fbg .ColorAt (x ,y );return _ffbe };var _ Image =&Monochrome {};func (_decg *Gray4 )Set (x ,y int ,c _g .Color ){if x >=_decg .Width ||y >=_decg .Height {return ;};_cdeg :=Gray4Model .Convert (c ).(_g .Gray );
_decg .setGray (x ,y ,_cdeg );};func _abec (_bccb _a .Image )(Image ,error ){if _cfebe ,_agcc :=_bccb .(*Gray8 );_agcc {return _cfebe .Copy (),nil ;};_cabc :=_bccb .Bounds ();_dgce ,_decf :=NewImage (_cabc .Max .X ,_cabc .Max .Y ,8,1,nil ,nil ,nil );if _decf !=nil {return nil ,_decf ;
};_abfdf (_bccb ,_dgce ,_cabc );return _dgce ,nil ;};type Histogramer interface{Histogram ()[256]int ;};func _adgg (_cdcf nrgba64 ,_bdbf NRGBA ,_dace _a .Rectangle ){for _eaac :=0;_eaac < _dace .Max .X ;_eaac ++{for _adggb :=0;_adggb < _dace .Max .Y ;_adggb ++{_agde :=_cdcf .NRGBA64At (_eaac ,_adggb );
_bdbf .SetNRGBA (_eaac ,_adggb ,_fbfa (_agde ));};};};func _acgc (_ddg _g .NYCbCrA )_g .NRGBA {_bebcg :=int32 (_ddg .Y )*0x10101;_cfab :=int32 (_ddg .Cb )-128;_bfg :=int32 (_ddg .Cr )-128;_afg :=_bebcg +91881*_bfg ;if uint32 (_afg )&0xff000000==0{_afg >>=8;
}else {_afg =^(_afg >>31)&0xffff;};_bgf :=_bebcg -22554*_cfab -46802*_bfg ;if uint32 (_bgf )&0xff000000==0{_bgf >>=8;}else {_bgf =^(_bgf >>31)&0xffff;};_dcbd :=_bebcg +116130*_cfab ;if uint32 (_dcbd )&0xff000000==0{_dcbd >>=8;}else {_dcbd =^(_dcbd >>31)&0xffff;
};return _g .NRGBA {R :uint8 (_afg >>8),G :uint8 (_bgf >>8),B :uint8 (_dcbd >>8),A :_ddg .A };};type ImageBase struct{Width ,Height int ;BitsPerComponent ,ColorComponents int ;Data ,Alpha []byte ;Decode []float64 ;BytesPerLine int ;};func (_fcb *Gray4 )Validate ()error {if len (_fcb .Data )!=_fcb .Height *_fcb .BytesPerLine {return ErrInvalidImage ;
};return nil ;};func (_bae *ImageBase )setEightBytes (_gfc int ,_dbgc uint64 )error {_acac :=_bae .BytesPerLine -(_gfc %_bae .BytesPerLine );if _bae .BytesPerLine !=_bae .Width >>3{_acac --;};if _acac >=8{return _bae .setEightFullBytes (_gfc ,_dbgc );};
return _bae .setEightPartlyBytes (_gfc ,_acac ,_dbgc );};func (_acfc *Gray16 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtGray16BPC (x ,y ,_acfc .BytesPerLine ,_acfc .Data ,_acfc .Decode );};func (_gdg *Gray4 )ColorModel ()_g .Model {return Gray4Model };
func (_ffbcc *NRGBA16 )Validate ()error {if len (_ffbcc .Data )!=3*_ffbcc .Width *_ffbcc .Height /2{return _bd .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};var (_dgd =_dea ();_fd =_cef ();_feg =_cfg (););func (_abde *Gray8 )SetGray (x ,y int ,g _g .Gray ){_dceb :=y *_abde .BytesPerLine +x ;if _dceb > len (_abde .Data )-1{return ;};_abde .Data [_dceb ]=g .Y ;};func ColorAtNRGBA64 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_g .NRGBA64 ,error ){_gade :=(y *width +x )*2;
_acdd :=_gade *3;if _acdd +5>=len (data ){return _g .NRGBA64 {},_cb .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};const _ffae =0xffff;_baae :=uint16 (_ffae );if alpha !=nil &&len (alpha )> _gade +1{_baae =uint16 (alpha [_gade ])<<8|uint16 (alpha [_gade +1]);};_eebb :=uint16 (data [_acdd ])<<8|uint16 (data [_acdd +1]);_ffef :=uint16 (data [_acdd +2])<<8|uint16 (data [_acdd +3]);
_bcacb :=uint16 (data [_acdd +4])<<8|uint16 (data [_acdd +5]);if len (decode )==6{_eebb =uint16 (uint64 (LinearInterpolate (float64 (_eebb ),0,65535,decode [0],decode [1]))&_ffae );_ffef =uint16 (uint64 (LinearInterpolate (float64 (_ffef ),0,65535,decode [2],decode [3]))&_ffae );
_bcacb =uint16 (uint64 (LinearInterpolate (float64 (_bcacb ),0,65535,decode [4],decode [5]))&_ffae );};return _g .NRGBA64 {R :_eebb ,G :_ffef ,B :_bcacb ,A :_baae },nil ;};func NextPowerOf2 (n uint )uint {if IsPowerOf2 (n ){return n ;};return 1<<(_dfg (n )+1);
};func _fbec (_cfbf CMYK ,_eggb NRGBA ,_aaec _a .Rectangle ){for _fcgg :=0;_fcgg < _aaec .Max .X ;_fcgg ++{for _cbcc :=0;_cbcc < _aaec .Max .Y ;_cbcc ++{_eeag :=_cfbf .CMYKAt (_fcgg ,_cbcc );_eggb .SetNRGBA (_fcgg ,_cbcc ,_bdeb (_eeag ));};};};func (_feae *RGBA32 )ColorModel ()_g .Model {return _g .NRGBAModel };
func _affgd (_abbbd nrgba64 ,_ceagc RGBA ,_fedfd _a .Rectangle ){for _efbc :=0;_efbc < _fedfd .Max .X ;_efbc ++{for _adcf :=0;_adcf < _fedfd .Max .Y ;_adcf ++{_gcge :=_abbbd .NRGBA64At (_efbc ,_adcf );_ceagc .SetRGBA (_efbc ,_adcf ,_egdf (_gcge ));};};
};var (MonochromeConverter =ConverterFunc (_cad );Gray2Converter =ConverterFunc (_bggf );Gray4Converter =ConverterFunc (_ddfd );GrayConverter =ConverterFunc (_abec );Gray16Converter =ConverterFunc (_fcgb );NRGBA16Converter =ConverterFunc (_edde );NRGBAConverter =ConverterFunc (_efcg );
NRGBA64Converter =ConverterFunc (_cbaeg );RGBAConverter =ConverterFunc (_bfdg );CMYKConverter =ConverterFunc (_ccbf ););func ColorAtGray8BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_g .Gray ,error ){_effba :=y *bytesPerLine +x ;if _effba >=len (data ){return _g .Gray {},_cb .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_fece :=data [_effba ];if len (decode )==2{_fece =uint8 (uint32 (LinearInterpolate (float64 (_fece ),0,255,decode [0],decode [1]))&0xff);};return _g .Gray {Y :_fece },nil ;};func _gdad (){for _gfde :=0;_gfde < 256;_gfde ++{_fecd [_gfde ]=uint8 (_gfde &0x1)+(uint8 (_gfde >>1)&0x1)+(uint8 (_gfde >>2)&0x1)+(uint8 (_gfde >>3)&0x1)+(uint8 (_gfde >>4)&0x1)+(uint8 (_gfde >>5)&0x1)+(uint8 (_gfde >>6)&0x1)+(uint8 (_gfde >>7)&0x1);
};};var _ Gray =&Gray2 {};func (_fbcf *ImageBase )setEightPartlyBytes (_fgedb ,_dfee int ,_cdg uint64 )(_dfaf error ){var (_eafgc byte ;_ggdg int ;);for _dbbf :=1;_dbbf <=_dfee ;_dbbf ++{_ggdg =64-_dbbf *8;_eafgc =byte (_cdg >>uint (_ggdg )&0xff);if _dfaf =_fbcf .setByte (_fgedb +_dbbf -1,_eafgc );
_dfaf !=nil {return _dfaf ;};};_dgeaa :=_fbcf .BytesPerLine *8-_fbcf .Width ;if _dgeaa ==0{return nil ;};_ggdg -=8;_eafgc =byte (_cdg >>uint (_ggdg )&0xff)<<uint (_dgeaa );if _dfaf =_fbcf .setByte (_fgedb +_dfee ,_eafgc );_dfaf !=nil {return _dfaf ;};return nil ;
};func (_acgd *NRGBA16 )SetNRGBA (x ,y int ,c _g .NRGBA ){_bagg :=y *_acgd .BytesPerLine +x *3/2;if _bagg +1>=len (_acgd .Data ){return ;};c =_ggc (c );_acgd .setNRGBA (x ,y ,_bagg ,c );};func (_ddaf *Gray8 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtGray8BPC (x ,y ,_ddaf .BytesPerLine ,_ddaf .Data ,_ddaf .Decode );
};func (_aacb *NRGBA32 )Bounds ()_a .Rectangle {return _a .Rectangle {Max :_a .Point {X :_aacb .Width ,Y :_aacb .Height }};};func (_afdda *ImageBase )newAlpha (){_dbdb :=BytesPerLine (_afdda .Width ,_afdda .BitsPerComponent ,1);_afdda .Alpha =make ([]byte ,_afdda .Height *_dbdb );
};type SMasker interface{HasAlpha ()bool ;GetAlpha ()[]byte ;MakeAlpha ();};func _ccf (_ee ,_be *Monochrome )(_dfbg error ){_ga :=_be .BytesPerLine ;_egd :=_ee .BytesPerLine ;var (_ed byte ;_dbd uint16 ;_gd ,_cba ,_fe ,_gg ,_ef int ;);for _fe =0;_fe < _be .Height ;
_fe ++{_gd =_fe *_ga ;_cba =2*_fe *_egd ;for _gg =0;_gg < _ga ;_gg ++{_ed =_be .Data [_gd +_gg ];_dbd =_dgd [_ed ];_ef =_cba +_gg *2;if _ee .BytesPerLine !=_be .BytesPerLine *2&&(_gg +1)*2> _ee .BytesPerLine {_dfbg =_ee .setByte (_ef ,byte (_dbd >>8));
}else {_dfbg =_ee .setTwoBytes (_ef ,_dbd );};if _dfbg !=nil {return _dfbg ;};};for _gg =0;_gg < _egd ;_gg ++{_ef =_cba +_egd +_gg ;_ed =_ee .Data [_cba +_gg ];if _dfbg =_ee .setByte (_ef ,_ed );_dfbg !=nil {return _dfbg ;};};};return nil ;};func (_feeb *Gray2 )ColorModel ()_g .Model {return Gray2Model };
func (_abdc *Monochrome )ScaleLow (width ,height int )(*Monochrome ,error ){if width < 0||height < 0{return nil ,_bd .New ("\u0070\u0072\u006f\u0076\u0069\u0064e\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0069\u0064t\u0068\u0020\u0061\u006e\u0064\u0020\u0068e\u0069\u0067\u0068\u0074");
};_fdc :=_cbdf (width ,height );_dage :=make ([]int ,height );_dgde :=make ([]int ,width );_afbeg :=float64 (_abdc .Width )/float64 (width );_dcd :=float64 (_abdc .Height )/float64 (height );for _gbfa :=0;_gbfa < height ;_gbfa ++{_dage [_gbfa ]=int (_c .Min (_dcd *float64 (_gbfa )+0.5,float64 (_abdc .Height -1)));
};for _ffd :=0;_ffd < width ;_ffd ++{_dgde [_ffd ]=int (_c .Min (_afbeg *float64 (_ffd )+0.5,float64 (_abdc .Width -1)));};_aeb :=-1;_dcfd :=byte (0);for _bgef :=0;_bgef < height ;_bgef ++{_cfca :=_dage [_bgef ]*_abdc .BytesPerLine ;_fbca :=_bgef *_fdc .BytesPerLine ;
for _ceec :=0;_ceec < width ;_ceec ++{_agd :=_dgde [_ceec ];if _agd !=_aeb {_dcfd =_abdc .getBit (_cfca ,_agd );if _dcfd !=0{_fdc .setBit (_fbca ,_ceec );};_aeb =_agd ;}else {if _dcfd !=0{_fdc .setBit (_fbca ,_ceec );};};};};return _fdc ,nil ;};func (_dgec *ImageBase )setEightFullBytes (_bgea int ,_egdd uint64 )error {if _bgea +7> len (_dgec .Data )-1{return _bd .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_dgec .Data [_bgea ]=byte ((_egdd &0xff00000000000000)>>56);_dgec .Data [_bgea +1]=byte ((_egdd &0xff000000000000)>>48);_dgec .Data [_bgea +2]=byte ((_egdd &0xff0000000000)>>40);_dgec .Data [_bgea +3]=byte ((_egdd &0xff00000000)>>32);_dgec .Data [_bgea +4]=byte ((_egdd &0xff000000)>>24);
_dgec .Data [_bgea +5]=byte ((_egdd &0xff0000)>>16);_dgec .Data [_bgea +6]=byte ((_egdd &0xff00)>>8);_dgec .Data [_bgea +7]=byte (_egdd &0xff);return nil ;};func _dgee (_bdcc int ,_aacd int )error {return _cb .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",_bdcc ,_aacd );
};func (_fgffc *NRGBA32 )setRGBA (_cebg int ,_aeab _g .NRGBA ){_fgfag :=3*_cebg ;_fgffc .Data [_fgfag ]=_aeab .R ;_fgffc .Data [_fgfag +1]=_aeab .G ;_fgffc .Data [_fgfag +2]=_aeab .B ;if _cebg < len (_fgffc .Alpha ){_fgffc .Alpha [_cebg ]=_aeab .A ;};};
type monochromeThresholdConverter struct{Threshold uint8 ;};func (_bfa *Gray8 )Histogram ()(_cfb [256]int ){for _dce :=0;_dce < len (_bfa .Data );_dce ++{_cfb [_bfa .Data [_dce ]]++;};return _cfb ;};func (_eddff *NRGBA64 )NRGBA64At (x ,y int )_g .NRGBA64 {_acdgga ,_ :=ColorAtNRGBA64 (x ,y ,_eddff .Width ,_eddff .Data ,_eddff .Alpha ,_eddff .Decode );
return _acdgga ;};func (_ebba *NRGBA16 )Copy ()Image {return &NRGBA16 {ImageBase :_ebba .copy ()}};type RGBA32 struct{ImageBase };func (_ceag *NRGBA32 )Set (x ,y int ,c _g .Color ){_cdgb :=y *_ceag .Width +x ;_cdfe :=3*_cdgb ;if _cdfe +2>=len (_ceag .Data ){return ;
};_eebe :=_g .NRGBAModel .Convert (c ).(_g .NRGBA );_ceag .setRGBA (_cdgb ,_eebe );};func (_eegce *NRGBA32 )ColorModel ()_g .Model {return _g .NRGBAModel };func ColorAtGray1BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_g .Gray ,error ){_cbcf :=y *bytesPerLine +x >>3;
if _cbcf >=len (data ){return _g .Gray {},_cb .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_eafb :=data [_cbcf ]>>uint (7-(x &7))&1;if len (decode )==2{_eafb =uint8 (LinearInterpolate (float64 (_eafb ),0.0,1.0,decode [0],decode [1]))&1;};return _g .Gray {Y :_eafb *255},nil ;};func _dbc (_cga ,_cgb *Monochrome )(_ddd error ){_fee :=_cgb .BytesPerLine ;
_gfa :=_cga .BytesPerLine ;_gce :=_cgb .BytesPerLine *4-_cga .BytesPerLine ;var (_dbb ,_ccb byte ;_ab uint32 ;_gab ,_eba ,_ba ,_cd ,_ag ,_bda ,_edg int ;);for _ba =0;_ba < _cgb .Height ;_ba ++{_gab =_ba *_fee ;_eba =4*_ba *_gfa ;for _cd =0;_cd < _fee ;
_cd ++{_dbb =_cgb .Data [_gab +_cd ];_ab =_fd [_dbb ];_bda =_eba +_cd *4;if _gce !=0&&(_cd +1)*4> _cga .BytesPerLine {for _ag =_gce ;_ag > 0;_ag --{_ccb =byte ((_ab >>uint (_ag *8))&0xff);_edg =_bda +(_gce -_ag );if _ddd =_cga .setByte (_edg ,_ccb );_ddd !=nil {return _ddd ;
};};}else if _ddd =_cga .setFourBytes (_bda ,_ab );_ddd !=nil {return _ddd ;};if _ddd =_cga .setFourBytes (_eba +_cd *4,_fd [_cgb .Data [_gab +_cd ]]);_ddd !=nil {return _ddd ;};};for _ag =1;_ag < 4;_ag ++{for _cd =0;_cd < _gfa ;_cd ++{if _ddd =_cga .setByte (_eba +_ag *_gfa +_cd ,_cga .Data [_eba +_cd ]);
_ddd !=nil {return _ddd ;};};};};return nil ;};func _dfg (_baed uint )uint {var _fgee uint ;for _baed !=0{_baed >>=1;_fgee ++;};return _fgee -1;};type Image interface{_d .Image ;Base ()*ImageBase ;Copy ()Image ;Pix ()[]byte ;ColorAt (_eacg ,_fcce int )(_g .Color ,error );
Validate ()error ;};func _bcac (_fdaa _g .Gray ,_gcfg monochromeModel )_g .Gray {if _fdaa .Y > uint8 (_gcfg ){return _g .Gray {Y :_c .MaxUint8 };};return _g .Gray {};};func (_agdc *Gray4 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtGray4BPC (x ,y ,_agdc .BytesPerLine ,_agdc .Data ,_agdc .Decode );
};func (_dcfe *Gray2 )GrayAt (x ,y int )_g .Gray {_bgdb ,_ :=ColorAtGray2BPC (x ,y ,_dcfe .BytesPerLine ,_dcfe .Data ,_dcfe .Decode );return _bgdb ;};var _ Gray =&Gray4 {};func (_effg *NRGBA32 )Base ()*ImageBase {return &_effg .ImageBase };func (_ddaae *NRGBA16 )Set (x ,y int ,c _g .Color ){_aeff :=y *_ddaae .BytesPerLine +x *3/2;
if _aeff +1>=len (_ddaae .Data ){return ;};_bfcf :=NRGBA16Model .Convert (c ).(_g .NRGBA );_ddaae .setNRGBA (x ,y ,_aeff ,_bfcf );};func (_aggg *Gray2 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtGray2BPC (x ,y ,_aggg .BytesPerLine ,_aggg .Data ,_aggg .Decode );
};func _fedc (_ecde _g .Color )_g .Color {_cfagb :=_g .NRGBAModel .Convert (_ecde ).(_g .NRGBA );return _ggc (_cfagb );};func _bcda (_dcgc *_a .NYCbCrA ,_decfc RGBA ,_fgef _a .Rectangle ){for _eafgf :=0;_eafgf < _fgef .Max .X ;_eafgf ++{for _gdcd :=0;_gdcd < _fgef .Max .Y ;
_gdcd ++{_eadb :=_dcgc .NYCbCrAAt (_eafgf ,_gdcd );_decfc .SetRGBA (_eafgf ,_gdcd ,_efcf (_eadb ));};};};func (_gbg *monochromeThresholdConverter )Convert (img _a .Image )(Image ,error ){if _dba ,_gfd :=img .(*Monochrome );_gfd {return _dba .Copy (),nil ;
};_gec :=img .Bounds ();_aeac ,_ged :=NewImage (_gec .Max .X ,_gec .Max .Y ,1,1,nil ,nil ,nil );if _ged !=nil {return nil ,_ged ;};_aeac .(*Monochrome ).ModelThreshold =_gbg .Threshold ;for _fagg :=0;_fagg < _gec .Max .X ;_fagg ++{for _dee :=0;_dee < _gec .Max .Y ;
_dee ++{_ecfa :=img .At (_fagg ,_dee );_aeac .Set (_fagg ,_dee ,_ecfa );};};return _aeac ,nil ;};func _dfe (_fb ,_ce *Monochrome )(_ec error ){_ebaf :=_ce .BytesPerLine ;_ceb :=_fb .BytesPerLine ;var _ecb ,_ae ,_ea ,_aa ,_aed int ;for _ea =0;_ea < _ce .Height ;
_ea ++{_ecb =_ea *_ebaf ;_ae =8*_ea *_ceb ;for _aa =0;_aa < _ebaf ;_aa ++{if _ec =_fb .setEightBytes (_ae +_aa *8,_feg [_ce .Data [_ecb +_aa ]]);_ec !=nil {return _ec ;};};for _aed =1;_aed < 8;_aed ++{for _aa =0;_aa < _ceb ;_aa ++{if _ec =_fb .setByte (_ae +_aed *_ceb +_aa ,_fb .Data [_ae +_aa ]);
_ec !=nil {return _ec ;};};};};return nil ;};func _deba (_ccdc ,_agea uint8 )uint8 {if _ccdc < _agea {return 255;};return 0;};const (_aefc shift =iota ;_affef ;);func _eedb (_bfb _a .Image ,_dede Image ,_fcefe _a .Rectangle ){if _gfda ,_aecc :=_bfb .(SMasker );
_aecc &&_gfda .HasAlpha (){_dede .(SMasker ).MakeAlpha ();};_gaac (_bfb ,_dede ,_fcefe );};func (_gbfd *Monochrome )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtGray1BPC (x ,y ,_gbfd .BytesPerLine ,_gbfd .Data ,_gbfd .Decode );};func (_ggbf *ImageBase )setByte (_fbgg int ,_cfee byte )error {if _fbgg > len (_ggbf .Data )-1{return _bd .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_ggbf .Data [_fbgg ]=_cfee ;return nil ;};func _bbfg (_cfeg _a .Image ,_fcac uint8 )*_a .Gray {_afadc :=_cfeg .Bounds ();_dagbe :=_a .NewGray (_afadc );var (_fbcfa _g .Color ;_cdfg _g .Gray ;);for _bgcf :=0;_bgcf < _afadc .Max .X ;_bgcf ++{for _afgg :=0;
_afgg < _afadc .Max .Y ;_afgg ++{_fbcfa =_cfeg .At (_bgcf ,_afgg );_dagbe .Set (_bgcf ,_afgg ,_fbcfa );_cdfg =_dagbe .GrayAt (_bgcf ,_afgg );_dagbe .SetGray (_bgcf ,_afgg ,_g .Gray {Y :_deba (_cdfg .Y ,_fcac )});};};return _dagbe ;};func _gbbc (_cbbd Gray ,_dcbg nrgba64 ,_fgc _a .Rectangle ){for _bge :=0;
_bge < _fgc .Max .X ;_bge ++{for _fedf :=0;_fedf < _fgc .Max .Y ;_fedf ++{_bcef :=_ace (_dcbg .NRGBA64At (_bge ,_fedf ));_cbbd .SetGray (_bge ,_fedf ,_bcef );};};};func _effb (_afe _g .Gray )_g .Gray {_afe .Y >>=4;_afe .Y |=_afe .Y <<4;return _afe };func _ggc (_aege _g .NRGBA )_g .NRGBA {_aege .R =_aege .R >>4|(_aege .R >>4)<<4;
_aege .G =_aege .G >>4|(_aege .G >>4)<<4;_aege .B =_aege .B >>4|(_aege .B >>4)<<4;return _aege ;};func (_egdfc *NRGBA32 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtNRGBA32 (x ,y ,_egdfc .Width ,_egdfc .Data ,_egdfc .Alpha ,_egdfc .Decode );};
func (_adbfa *NRGBA16 )Bounds ()_a .Rectangle {return _a .Rectangle {Max :_a .Point {X :_adbfa .Width ,Y :_adbfa .Height }};};func (_cfgd *Monochrome )ReduceBinary (factor float64 )(*Monochrome ,error ){_abea :=_dfg (uint (factor ));if !IsPowerOf2 (uint (factor )){_abea ++;
};_efcfg :=make ([]int ,_abea );for _bcgc :=range _efcfg {_efcfg [_bcgc ]=4;};_bagd ,_aac :=_efg (_cfgd ,_efcfg ...);if _aac !=nil {return nil ,_aac ;};return _bagd ,nil ;};var _ Image =&NRGBA16 {};func _eeae (_bdcd NRGBA ,_ddfc Gray ,_gfdce _a .Rectangle ){for _cbbe :=0;
_cbbe < _gfdce .Max .X ;_cbbe ++{for _adfad :=0;_adfad < _gfdce .Max .Y ;_adfad ++{_gbad :=_bbcf (_bdcd .NRGBAAt (_cbbe ,_adfad ));_ddfc .SetGray (_cbbe ,_adfad ,_gbad );};};};func (_bacg *Gray16 )Histogram ()(_bbfd [256]int ){for _cffa :=0;_cffa < _bacg .Width ;
_cffa ++{for _dagb :=0;_dagb < _bacg .Height ;_dagb ++{_bbfd [_bacg .GrayAt (_cffa ,_dagb ).Y ]++;};};return _bbfd ;};var _ Image =&RGBA32 {};func (_feb *Monochrome )Histogram ()(_efdd [256]int ){for _ ,_efba :=range _feb .Data {_efdd [0xff]+=int (_fecd [_feb .Data [_efba ]]);
};return _efdd ;};func (_dfbgb *Gray2 )Copy ()Image {return &Gray2 {ImageBase :_dfbgb .copy ()}};func _cbaeg (_ggde _a .Image )(Image ,error ){if _abbb ,_eaae :=_ggde .(*NRGBA64 );_eaae {return _abbb .Copy (),nil ;};_cfde ,_baec ,_gbdaf :=_bgfca (_ggde ,2);
_aceg ,_cgdb :=NewImage (_cfde .Max .X ,_cfde .Max .Y ,16,3,nil ,_gbdaf ,nil );if _cgdb !=nil {return nil ,_cgdb ;};_eedb (_ggde ,_aceg ,_cfde );if len (_gbdaf )!=0&&!_baec {if _gggba :=_dgcd (_gbdaf ,_aceg );_gggba !=nil {return nil ,_gggba ;};};return _aceg ,nil ;
};func (_afad colorConverter )Convert (src _a .Image )(Image ,error ){return _afad ._cac (src )};func (_deca *ImageBase )setFourBytes (_ggfd int ,_aadc uint32 )error {if _ggfd +3> len (_deca .Data )-1{return _cb .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006fu\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065",_ggfd );
};_deca .Data [_ggfd ]=byte ((_aadc &0xff000000)>>24);_deca .Data [_ggfd +1]=byte ((_aadc &0xff0000)>>16);_deca .Data [_ggfd +2]=byte ((_aadc &0xff00)>>8);_deca .Data [_ggfd +3]=byte (_aadc &0xff);return nil ;};func _ddfd (_ecacb _a .Image )(Image ,error ){if _gacec ,_bac :=_ecacb .(*Gray4 );
_bac {return _gacec .Copy (),nil ;};_fged :=_ecacb .Bounds ();_fegc ,_fbba :=NewImage (_fged .Max .X ,_fged .Max .Y ,4,1,nil ,nil ,nil );if _fbba !=nil {return nil ,_fbba ;};_abfdf (_ecacb ,_fegc ,_fged );return _fegc ,nil ;};func RasterOperation (dest *Monochrome ,dx ,dy ,dw ,dh int ,op RasterOperator ,src *Monochrome ,sx ,sy int )error {return _caaa (dest ,dx ,dy ,dw ,dh ,op ,src ,sx ,sy );
};func (_abb *NRGBA32 )At (x ,y int )_g .Color {_geb ,_ :=_abb .ColorAt (x ,y );return _geb };func (_ggfa *Gray8 )At (x ,y int )_g .Color {_adab ,_ :=_ggfa .ColorAt (x ,y );return _adab };func (_gbgb *Gray8 )Bounds ()_a .Rectangle {return _a .Rectangle {Max :_a .Point {X :_gbgb .Width ,Y :_gbgb .Height }};
};func GetConverter (bitsPerComponent ,colorComponents int )(ColorConverter ,error ){switch colorComponents {case 1:switch bitsPerComponent {case 1:return MonochromeConverter ,nil ;case 2:return Gray2Converter ,nil ;case 4:return Gray4Converter ,nil ;case 8:return GrayConverter ,nil ;
case 16:return Gray16Converter ,nil ;};case 3:switch bitsPerComponent {case 4:return NRGBA16Converter ,nil ;case 8:return NRGBAConverter ,nil ;case 16:return NRGBA64Converter ,nil ;};case 4:return CMYKConverter ,nil ;};return nil ,_cb .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0043o\u006e\u0076\u0065\u0072\u0074\u0065\u0072\u0020\u0070\u0061\u0072\u0061\u006d\u0065t\u0065\u0072\u0073\u002e\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003a\u0020\u0025\u0064\u002c\u0020\u0043\u006f\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006et\u0073\u003a \u0025\u0064",bitsPerComponent ,colorComponents );
};func (_bgbc *ImageBase )copy ()ImageBase {_aeag :=*_bgbc ;_aeag .Data =make ([]byte ,len (_bgbc .Data ));copy (_aeag .Data ,_bgbc .Data );return _aeag ;};func (_eaec *Monochrome )Set (x ,y int ,c _g .Color ){_cdda :=y *_eaec .BytesPerLine +x >>3;if _cdda > len (_eaec .Data )-1{return ;
};_edba :=_eaec .ColorModel ().Convert (c ).(_g .Gray );_eaec .setGray (x ,_edba ,_cdda );};func (_fdff *RGBA32 )RGBAAt (x ,y int )_g .RGBA {_gcag ,_ :=ColorAtRGBA32 (x ,y ,_fdff .Width ,_fdff .Data ,_fdff .Alpha ,_fdff .Decode );return _gcag ;};type Gray interface{GrayAt (_bbcfc ,_bcg int )_g .Gray ;
SetGray (_gdab ,_eaa int ,_cdac _g .Gray );};func (_fce *Gray4 )Copy ()Image {return &Gray4 {ImageBase :_fce .copy ()}};func _gaac (_adg _a .Image ,_bbf Image ,_cbc _a .Rectangle ){for _dbe :=0;_dbe < _cbc .Max .X ;_dbe ++{for _dbdda :=0;_dbdda < _cbc .Max .Y ;
_dbdda ++{_ecff :=_adg .At (_dbe ,_dbdda );_bbf .Set (_dbe ,_dbdda ,_ecff );};};};func (_efec *Gray16 )At (x ,y int )_g .Color {_cabg ,_ :=_efec .ColorAt (x ,y );return _cabg };func ConverterFunc (converterFunc func (_ecc _a .Image )(Image ,error ))ColorConverter {return colorConverter {_cac :converterFunc };
};func _fdea (_gdf _g .Gray )_g .Gray {_ecce :=_gdf .Y >>6;_ecce |=_ecce <<2;_gdf .Y =_ecce |_ecce <<4;return _gdf ;};func ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor int ,data ,alpha []byte ,decode []float64 )(_g .Color ,error ){switch bitsPerColor {case 4:return ColorAtNRGBA16 (x ,y ,width ,bytesPerLine ,data ,alpha ,decode );
case 8:return ColorAtNRGBA32 (x ,y ,width ,data ,alpha ,decode );case 16:return ColorAtNRGBA64 (x ,y ,width ,data ,alpha ,decode );default:return nil ,_cb .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0067\u0062\u0020b\u0069\u0074\u0073\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0061\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );
};};func (_fgb *CMYK32 )Copy ()Image {return &CMYK32 {ImageBase :_fgb .copy ()}};func (_fgbb *NRGBA64 )At (x ,y int )_g .Color {_ebgf ,_ :=_fgbb .ColorAt (x ,y );return _ebgf };func _fa (_afa ,_ggb *Monochrome ,_cdea []byte ,_efe int )(_eggf error ){var (_ddb ,_eed ,_dga ,_edee ,_gbf ,_ega ,_ggd ,_ecfd int ;
_ge ,_gcee ,_afd ,_aag uint32 ;_bdag ,_edcb byte ;_ebg uint16 ;);_ddf :=make ([]byte ,4);_bcb :=make ([]byte ,4);for _dga =0;_dga < _afa .Height -1;_dga ,_edee =_dga +2,_edee +1{_ddb =_dga *_afa .BytesPerLine ;_eed =_edee *_ggb .BytesPerLine ;for _gbf ,_ega =0,0;
_gbf < _efe ;_gbf ,_ega =_gbf +4,_ega +1{for _ggd =0;_ggd < 4;_ggd ++{_ecfd =_ddb +_gbf +_ggd ;if _ecfd <=len (_afa .Data )-1&&_ecfd < _ddb +_afa .BytesPerLine {_ddf [_ggd ]=_afa .Data [_ecfd ];}else {_ddf [_ggd ]=0x00;};_ecfd =_ddb +_afa .BytesPerLine +_gbf +_ggd ;
if _ecfd <=len (_afa .Data )-1&&_ecfd < _ddb +(2*_afa .BytesPerLine ){_bcb [_ggd ]=_afa .Data [_ecfd ];}else {_bcb [_ggd ]=0x00;};};_ge =_dc .BigEndian .Uint32 (_ddf );_gcee =_dc .BigEndian .Uint32 (_bcb );_afd =_ge &_gcee ;_afd |=_afd <<1;_aag =_ge |_gcee ;
_aag &=_aag <<1;_gcee =_afd &_aag ;_gcee &=0xaaaaaaaa;_ge =_gcee |(_gcee <<7);_bdag =byte (_ge >>24);_edcb =byte ((_ge >>8)&0xff);_ecfd =_eed +_ega ;if _ecfd +1==len (_ggb .Data )-1||_ecfd +1>=_eed +_ggb .BytesPerLine {if _eggf =_ggb .setByte (_ecfd ,_cdea [_bdag ]);
_eggf !=nil {return _cb .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_ecfd );};}else {_ebg =(uint16 (_cdea [_bdag ])<<8)|uint16 (_cdea [_edcb ]);if _eggf =_ggb .setTwoBytes (_ecfd ,_ebg );_eggf !=nil {return _cb .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_ecfd );
};_ega ++;};};};return nil ;};func (_cbbcd *RGBA32 )Copy ()Image {return &RGBA32 {ImageBase :_cbbcd .copy ()}};func _bggf (_fdbd _a .Image )(Image ,error ){if _cgbe ,_fggc :=_fdbd .(*Gray2 );_fggc {return _cgbe .Copy (),nil ;};_cddad :=_fdbd .Bounds ();
_bebe ,_efae :=NewImage (_cddad .Max .X ,_cddad .Max .Y ,2,1,nil ,nil ,nil );if _efae !=nil {return nil ,_efae ;};_abfdf (_fdbd ,_bebe ,_cddad );return _bebe ,nil ;};func (_fab *Monochrome )InverseData ()error {return _fab .RasterOperation (0,0,_fab .Width ,_fab .Height ,PixNotDst ,nil ,0,0);
};func _dgcd (_gccf []byte ,_afaa Image )error {_gdaaf :=true ;for _ebgbg :=0;_ebgbg < len (_gccf );_ebgbg ++{if _gccf [_ebgbg ]!=0xff{_gdaaf =false ;break ;};};if _gdaaf {switch _fcfcc :=_afaa .(type ){case *NRGBA32 :_fcfcc .Alpha =nil ;case *NRGBA64 :_fcfcc .Alpha =nil ;
default:return _cb .Errorf ("i\u006ete\u0072n\u0061l\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020i\u006d\u0061\u0067\u0065\u0020s\u0068\u006f\u0075l\u0064\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0074\u0079\u0070e\u0020\u002a\u004eRGB\u0041\u0033\u0032\u0020\u006f\u0072 \u002a\u004e\u0052\u0047\u0042\u0041\u0036\u0034\u0020\u0062\u0075\u0074 \u0069s\u003a\u0020\u0025\u0054",_afaa );
};};return nil ;};type Monochrome struct{ImageBase ;ModelThreshold uint8 ;};var _ _a .Image =&NRGBA32 {};func _bedb (_gba _g .CMYK )_g .Gray {_bfca ,_bcbc ,_abfef :=_g .CMYKToRGB (_gba .C ,_gba .M ,_gba .Y ,_gba .K );_ddce :=(19595*uint32 (_bfca )+38470*uint32 (_bcbc )+7471*uint32 (_abfef )+1<<7)>>16;
return _g .Gray {Y :uint8 (_ddce )};};func (_fgeda *Gray8 )Base ()*ImageBase {return &_fgeda .ImageBase };func (_cfaee *Monochrome )copy ()*Monochrome {_edbab :=_cbdf (_cfaee .Width ,_cfaee .Height );_edbab .ModelThreshold =_cfaee .ModelThreshold ;_edbab .Data =make ([]byte ,len (_cfaee .Data ));
copy (_edbab .Data ,_cfaee .Data );if len (_cfaee .Decode )!=0{_edbab .Decode =make ([]float64 ,len (_cfaee .Decode ));copy (_edbab .Decode ,_cfaee .Decode );};if len (_cfaee .Alpha )!=0{_edbab .Alpha =make ([]byte ,len (_cfaee .Alpha ));copy (_edbab .Alpha ,_cfaee .Alpha );
};return _edbab ;};var _ _a .Image =&NRGBA16 {};type CMYK interface{CMYKAt (_fde ,_badg int )_g .CMYK ;SetCMYK (_bfc ,_ffa int ,_bca _g .CMYK );};func (_bgac *RGBA32 )Validate ()error {if len (_bgac .Data )!=3*_bgac .Width *_bgac .Height {return _bd .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func InDelta (expected ,current ,delta float64 )bool {_bccc :=expected -current ;if _bccc <=-delta ||_bccc >=delta {return false ;};return true ;};type nrgba64 interface{NRGBA64At (_cbbaa ,_gggb int )_g .NRGBA64 ;SetNRGBA64 (_ffcg ,_gbcc int ,_cgbbg _g .NRGBA64 );
};var _ Image =&NRGBA64 {};func (_acdf *Monochrome )AddPadding ()(_deef error ){if _afge :=((_acdf .Width *_acdf .Height )+7)>>3;len (_acdf .Data )< _afge {return _cb .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064a\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002e\u0020\u0054\u0068\u0065\u0020\u0064\u0061t\u0061\u0020s\u0068\u006fu\u006c\u0064\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0020\u0061\u0074 l\u0065\u0061\u0073\u0074\u003a\u0020\u0027\u0025\u0064'\u0020\u0062\u0079\u0074\u0065\u0073",len (_acdf .Data ),_afge );
};_abda :=_acdf .Width %8;if _abda ==0{return nil ;};_fdef :=_acdf .Width /8;_dege :=_gc .NewReader (_acdf .Data );_acfb :=make ([]byte ,_acdf .Height *_acdf .BytesPerLine );_aedcc :=_gc .NewWriterMSB (_acfb );_bdc :=make ([]byte ,_fdef );var (_afbe int ;
_bcea uint64 ;);for _afbe =0;_afbe < _acdf .Height ;_afbe ++{if _ ,_deef =_dege .Read (_bdc );_deef !=nil {return _deef ;};if _ ,_deef =_aedcc .Write (_bdc );_deef !=nil {return _deef ;};if _bcea ,_deef =_dege .ReadBits (byte (_abda ));_deef !=nil {return _deef ;
};if _deef =_aedcc .WriteByte (byte (_bcea )<<uint (8-_abda ));_deef !=nil {return _deef ;};};_acdf .Data =_aedcc .Data ();return nil ;};func NewImageBase (width int ,height int ,bitsPerComponent int ,colorComponents int ,data []byte ,alpha []byte ,decode []float64 )ImageBase {_gbdd :=ImageBase {Width :width ,Height :height ,BitsPerComponent :bitsPerComponent ,ColorComponents :colorComponents ,Data :data ,Alpha :alpha ,Decode :decode ,BytesPerLine :BytesPerLine (width ,bitsPerComponent ,colorComponents )};
if data ==nil {_gbdd .Data =make ([]byte ,height *_gbdd .BytesPerLine );};return _gbdd ;};type colorConverter struct{_cac func (_dfcb _a .Image )(Image ,error );};func (_gadc *Monochrome )clearBit (_fcdf ,_bgg int ){_gadc .Data [_fcdf ]&=^(0x80>>uint (_bgg &7))};
var _ Image =&Gray4 {};type RGBA interface{RGBAAt (_ggfcd ,_bcgg int )_g .RGBA ;SetRGBA (_fcbe ,_ffbc int ,_aabg _g .RGBA );};func _ddc (_fecc RGBA ,_cbb CMYK ,_eabd _a .Rectangle ){for _cdd :=0;_cdd < _eabd .Max .X ;_cdd ++{for _fcc :=0;_fcc < _eabd .Max .Y ;
_fcc ++{_abe :=_fecc .RGBAAt (_cdd ,_fcc );_cbb .SetCMYK (_cdd ,_fcc ,_fgae (_abe ));};};};func IsPowerOf2 (n uint )bool {return n > 0&&(n &(n -1))==0};func (_dcdg *Gray8 )Copy ()Image {return &Gray8 {ImageBase :_dcdg .copy ()}};func _gae (_ccag *Monochrome ,_affb ,_gbgbc int ,_agbf ,_dbff int ,_faa RasterOperator ){var (_fcfcd bool ;
_afbgg bool ;_adfaa int ;_gfee int ;_gbgf int ;_fdcc int ;_gfce bool ;_eggec byte ;);_ccbe :=8-(_affb &7);_dfga :=_fgfe [_ccbe ];_cdee :=_ccag .BytesPerLine *_gbgbc +(_affb >>3);if _agbf < _ccbe {_fcfcd =true ;_dfga &=_ffdba [8-_ccbe +_agbf ];};if !_fcfcd {_adfaa =(_agbf -_ccbe )>>3;
if _adfaa !=0{_afbgg =true ;_gfee =_cdee +1;};};_gbgf =(_affb +_agbf )&7;if !(_fcfcd ||_gbgf ==0){_gfce =true ;_eggec =_ffdba [_gbgf ];_fdcc =_cdee +1+_adfaa ;};var _effc ,_defa int ;switch _faa {case PixClr :for _effc =0;_effc < _dbff ;_effc ++{_ccag .Data [_cdee ]=_gfdg (_ccag .Data [_cdee ],0x0,_dfga );
_cdee +=_ccag .BytesPerLine ;};if _afbgg {for _effc =0;_effc < _dbff ;_effc ++{for _defa =0;_defa < _adfaa ;_defa ++{_ccag .Data [_gfee +_defa ]=0x0;};_gfee +=_ccag .BytesPerLine ;};};if _gfce {for _effc =0;_effc < _dbff ;_effc ++{_ccag .Data [_fdcc ]=_gfdg (_ccag .Data [_fdcc ],0x0,_eggec );
_fdcc +=_ccag .BytesPerLine ;};};case PixSet :for _effc =0;_effc < _dbff ;_effc ++{_ccag .Data [_cdee ]=_gfdg (_ccag .Data [_cdee ],0xff,_dfga );_cdee +=_ccag .BytesPerLine ;};if _afbgg {for _effc =0;_effc < _dbff ;_effc ++{for _defa =0;_defa < _adfaa ;
_defa ++{_ccag .Data [_gfee +_defa ]=0xff;};_gfee +=_ccag .BytesPerLine ;};};if _gfce {for _effc =0;_effc < _dbff ;_effc ++{_ccag .Data [_fdcc ]=_gfdg (_ccag .Data [_fdcc ],0xff,_eggec );_fdcc +=_ccag .BytesPerLine ;};};case PixNotDst :for _effc =0;_effc < _dbff ;
_effc ++{_ccag .Data [_cdee ]=_gfdg (_ccag .Data [_cdee ],^_ccag .Data [_cdee ],_dfga );_cdee +=_ccag .BytesPerLine ;};if _afbgg {for _effc =0;_effc < _dbff ;_effc ++{for _defa =0;_defa < _adfaa ;_defa ++{_ccag .Data [_gfee +_defa ]=^(_ccag .Data [_gfee +_defa ]);
};_gfee +=_ccag .BytesPerLine ;};};if _gfce {for _effc =0;_effc < _dbff ;_effc ++{_ccag .Data [_fdcc ]=_gfdg (_ccag .Data [_fdcc ],^_ccag .Data [_fdcc ],_eggec );_fdcc +=_ccag .BytesPerLine ;};};};};func _gfdg (_agbe ,_fedfg ,_bgee byte )byte {return (_agbe &^(_bgee ))|(_fedfg &_bgee )};
func _eefe (_efbd ,_dagg RGBA ,_abee _a .Rectangle ){for _dgdf :=0;_dgdf < _abee .Max .X ;_dgdf ++{for _ccdg :=0;_ccdg < _abee .Max .Y ;_ccdg ++{_dagg .SetRGBA (_dgdf ,_ccdg ,_efbd .RGBAAt (_dgdf ,_ccdg ));};};};func _agbc (_gcbf RGBA ,_dbec NRGBA ,_ccac _a .Rectangle ){for _agbfd :=0;
_agbfd < _ccac .Max .X ;_agbfd ++{for _gcdc :=0;_gcdc < _ccac .Max .Y ;_gcdc ++{_afac :=_gcbf .RGBAAt (_agbfd ,_gcdc );_dbec .SetNRGBA (_agbfd ,_gcdc ,_ebda (_afac ));};};};func _efg (_deg *Monochrome ,_da ...int )(_ca *Monochrome ,_age error ){if _deg ==nil {return nil ,_bd .New ("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d");
};if len (_da )==0{return nil ,_bd .New ("\u0074h\u0065\u0072e\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0061\u0074 \u006c\u0065\u0061\u0073\u0074\u0020o\u006e\u0065\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u006f\u0066 \u0072\u0065\u0064\u0075\u0063\u0074\u0069\u006f\u006e");
};_eeg :=_cgef ();_ca =_deg ;for _ ,_dfc :=range _da {if _dfc <=0{break ;};_ca ,_age =_cfc (_ca ,_dfc ,_eeg );if _age !=nil {return nil ,_age ;};};return _ca ,nil ;};var _ NRGBA =&NRGBA16 {};func ColorAtGray4BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_g .Gray ,error ){_bcaf :=y *bytesPerLine +x >>1;
if _bcaf >=len (data ){return _g .Gray {},_cb .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_gcd :=data [_bcaf ]>>uint (4-(x &1)*4)&0xf;if len (decode )==2{_gcd =uint8 (uint32 (LinearInterpolate (float64 (_gcd ),0,15,decode [0],decode [1]))&0xf);};return _g .Gray {Y :_gcd *17&0xff},nil ;};func NewImage (width ,height ,bitsPerComponent ,colorComponents int ,data ,alpha []byte ,decode []float64 )(Image ,error ){_feaa :=NewImageBase (width ,height ,bitsPerComponent ,colorComponents ,data ,alpha ,decode );
var _efab Image ;switch colorComponents {case 1:switch bitsPerComponent {case 1:_efab =&Monochrome {ImageBase :_feaa ,ModelThreshold :0x0f};case 2:_efab =&Gray2 {ImageBase :_feaa };case 4:_efab =&Gray4 {ImageBase :_feaa };case 8:_efab =&Gray8 {ImageBase :_feaa };
case 16:_efab =&Gray16 {ImageBase :_feaa };};case 3:switch bitsPerComponent {case 4:_efab =&NRGBA16 {ImageBase :_feaa };case 8:_efab =&NRGBA32 {ImageBase :_feaa };case 16:_efab =&NRGBA64 {ImageBase :_feaa };};case 4:_efab =&CMYK32 {ImageBase :_feaa };};
if _efab ==nil {return nil ,ErrInvalidImage ;};return _efab ,nil ;};type monochromeModel uint8 ;func _abd (_aba _g .NRGBA )_g .CMYK {_dgea ,_gcce ,_gace ,_ :=_aba .RGBA ();_cda ,_gcb ,_fgff ,_daga :=_g .RGBToCMYK (uint8 (_dgea >>8),uint8 (_gcce >>8),uint8 (_gace >>8));
return _g .CMYK {C :_cda ,M :_gcb ,Y :_fgff ,K :_daga };};func (_eaeg *CMYK32 )At (x ,y int )_g .Color {_aafb ,_ :=_eaeg .ColorAt (x ,y );return _aafb };var _ Image =&CMYK32 {};var _ Image =&Gray16 {};func _cfcef (_cdbc ,_cafc Gray ,_gdfd _a .Rectangle ){for _cbae :=0;
_cbae < _gdfd .Max .X ;_cbae ++{for _caba :=0;_caba < _gdfd .Max .Y ;_caba ++{_cafc .SetGray (_cbae ,_caba ,_cdbc .GrayAt (_cbae ,_caba ));};};};func ImgToGray (i _a .Image )*_a .Gray {if _bcbgb ,_caaae :=i .(*_a .Gray );_caaae {return _bcbgb ;};_ecca :=i .Bounds ();
_bgbce :=_a .NewGray (_ecca );for _ccgf :=0;_ccgf < _ecca .Max .X ;_ccgf ++{for _dddb :=0;_dddb < _ecca .Max .Y ;_dddb ++{_dfgad :=i .At (_ccgf ,_dddb );_bgbce .Set (_ccgf ,_dddb ,_dfgad );};};return _bgbce ;};func (_cgcd *NRGBA64 )Bounds ()_a .Rectangle {return _a .Rectangle {Max :_a .Point {X :_cgcd .Width ,Y :_cgcd .Height }};
};func (_gaacf *ImageBase )GetAlpha ()[]byte {return _gaacf .Alpha };func (_fge *Gray2 )Base ()*ImageBase {return &_fge .ImageBase };func (_gbfae *NRGBA16 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtNRGBA16 (x ,y ,_gbfae .Width ,_gbfae .BytesPerLine ,_gbfae .Data ,_gbfae .Alpha ,_gbfae .Decode );
};func (_dgfb *Gray4 )SetGray (x ,y int ,g _g .Gray ){if x >=_dgfb .Width ||y >=_dgfb .Height {return ;};g =_effb (g );_dgfb .setGray (x ,y ,g );};type shift int ;var _ _a .Image =&NRGBA64 {};func _ceadg (_cbaee *_a .Gray ,_degb uint8 )*_a .Gray {_cgegb :=_cbaee .Bounds ();
_edfbb :=_a .NewGray (_cgegb );for _fgaa :=0;_fgaa < _cgegb .Dx ();_fgaa ++{for _efecf :=0;_efecf < _cgegb .Dy ();_efecf ++{_gebg :=_cbaee .GrayAt (_fgaa ,_efecf );_edfbb .SetGray (_fgaa ,_efecf ,_g .Gray {Y :_deba (_gebg .Y ,_degb )});};};return _edfbb ;
};func (_eabb *Gray16 )Set (x ,y int ,c _g .Color ){_fac :=(y *_eabb .BytesPerLine /2+x )*2;if _fac +1>=len (_eabb .Data ){return ;};_gfbd :=_g .Gray16Model .Convert (c ).(_g .Gray16 );_eabb .Data [_fac ],_eabb .Data [_fac +1]=uint8 (_gfbd .Y >>8),uint8 (_gfbd .Y &0xff);
};func (_baad *NRGBA64 )Validate ()error {if len (_baad .Data )!=3*2*_baad .Width *_baad .Height {return _bd .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func (_dfcg *NRGBA32 )SetNRGBA (x ,y int ,c _g .NRGBA ){_cfbc :=y *_dfcg .Width +x ;_fcefb :=3*_cfbc ;if _fcefb +2>=len (_dfcg .Data ){return ;};_dfcg .setRGBA (_cfbc ,c );};func _acgce (_cede *_a .Gray )bool {for _cgbd :=0;_cgbd < len (_cede .Pix );
_cgbd ++{if !_ecdg (_cede .Pix [_cgbd ]){return false ;};};return true ;};func (_bgfce *NRGBA64 )Copy ()Image {return &NRGBA64 {ImageBase :_bgfce .copy ()}};var _ _a .Image =&Gray8 {};func (_dcff *Gray2 )Validate ()error {if len (_dcff .Data )!=_dcff .Height *_dcff .BytesPerLine {return ErrInvalidImage ;
};return nil ;};func _ecdg (_cccb uint8 )bool {if _cccb ==0||_cccb ==255{return true ;};return false ;};func MonochromeThresholdConverter (threshold uint8 )ColorConverter {return &monochromeThresholdConverter {Threshold :threshold };};func GrayHistogram (g Gray )(_deea [256]int ){switch _eggecd :=g .(type ){case Histogramer :return _eggecd .Histogram ();
case _a .Image :_aagfb :=_eggecd .Bounds ();for _bedgc :=0;_bedgc < _aagfb .Max .X ;_bedgc ++{for _bbga :=0;_bbga < _aagfb .Max .Y ;_bbga ++{_deea [g .GrayAt (_bedgc ,_bbga ).Y ]++;};};return _deea ;default:return [256]int {};};};func (_dgfbc *Gray16 )Bounds ()_a .Rectangle {return _a .Rectangle {Max :_a .Point {X :_dgfbc .Width ,Y :_dgfbc .Height }};
};func (_ccd *CMYK32 )Validate ()error {if len (_ccd .Data )!=4*_ccd .Width *_ccd .Height {return _bd .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func (_gccfg *NRGBA64 )setNRGBA64 (_bade int ,_defdc _g .NRGBA64 ,_fcbb int ){_gccfg .Data [_bade ]=uint8 (_defdc .R >>8);_gccfg .Data [_bade +1]=uint8 (_defdc .R &0xff);_gccfg .Data [_bade +2]=uint8 (_defdc .G >>8);_gccfg .Data [_bade +3]=uint8 (_defdc .G &0xff);
_gccfg .Data [_bade +4]=uint8 (_defdc .B >>8);_gccfg .Data [_bade +5]=uint8 (_defdc .B &0xff);if _fcbb +1< len (_gccfg .Alpha ){_gccfg .Alpha [_fcbb ]=uint8 (_defdc .A >>8);_gccfg .Alpha [_fcbb +1]=uint8 (_defdc .A &0xff);};};func (_adfb *Gray16 )ColorModel ()_g .Model {return _g .Gray16Model };
func (_gddb *Gray8 )Set (x ,y int ,c _g .Color ){_dgded :=y *_gddb .BytesPerLine +x ;if _dgded > len (_gddb .Data )-1{return ;};_gdbd :=_g .GrayModel .Convert (c );_gddb .Data [_dgded ]=_gdbd .(_g .Gray ).Y ;};func (_adgb *RGBA32 )Set (x ,y int ,c _g .Color ){_dbeca :=y *_adgb .Width +x ;
_daea :=3*_dbeca ;if _daea +2>=len (_adgb .Data ){return ;};_cade :=_g .RGBAModel .Convert (c ).(_g .RGBA );_adgb .setRGBA (_dbeca ,_cade );};func (_aeecd *NRGBA64 )SetNRGBA64 (x ,y int ,c _g .NRGBA64 ){_dbge :=(y *_aeecd .Width +x )*2;_bege :=_dbge *3;
if _bege +5>=len (_aeecd .Data ){return ;};_aeecd .setNRGBA64 (_bege ,c ,_dbge );};func _dcc (_ecag ,_cdb CMYK ,_bde _a .Rectangle ){for _efce :=0;_efce < _bde .Max .X ;_efce ++{for _bgb :=0;_bgb < _bde .Max .Y ;_bgb ++{_cdb .SetCMYK (_efce ,_bgb ,_ecag .CMYKAt (_efce ,_bgb ));
};};};func _cad (_edd _a .Image )(Image ,error ){if _fda ,_ggbg :=_edd .(*Monochrome );_ggbg {return _fda ,nil ;};_daec :=_edd .Bounds ();var _fcg Gray ;switch _daeg :=_edd .(type ){case Gray :_fcg =_daeg ;case NRGBA :_fcg =&Gray8 {ImageBase :NewImageBase (_daec .Max .X ,_daec .Max .Y ,8,1,nil ,nil ,nil )};
_gfba (_fcg ,_daeg ,_daec );case nrgba64 :_fcg =&Gray8 {ImageBase :NewImageBase (_daec .Max .X ,_daec .Max .Y ,8,1,nil ,nil ,nil )};_gbbc (_fcg ,_daeg ,_daec );default:_gcf ,_fbdg :=GrayConverter .Convert (_edd );if _fbdg !=nil {return nil ,_fbdg ;};_fcg =_gcf .(Gray );
};_fbea ,_cebc :=NewImage (_daec .Max .X ,_daec .Max .Y ,1,1,nil ,nil ,nil );if _cebc !=nil {return nil ,_cebc ;};_deae :=_fbea .(*Monochrome );_beg :=AutoThresholdTriangle (GrayHistogram (_fcg ));for _ebgb :=0;_ebgb < _daec .Max .X ;_ebgb ++{for _ggfc :=0;
_ggfc < _daec .Max .Y ;_ggfc ++{_dfa :=_bcac (_fcg .GrayAt (_ebgb ,_ggfc ),monochromeModel (_beg ));_deae .SetGray (_ebgb ,_ggfc ,_dfa );};};return _fbea ,nil ;};func ColorAtRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_g .RGBA ,error ){_abecb :=y *width +x ;
_fafbe :=3*_abecb ;if _fafbe +2>=len (data ){return _g .RGBA {},_cb .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_abfc :=uint8 (0xff);if alpha !=nil &&len (alpha )> _abecb {_abfc =alpha [_abecb ];};_dgga ,_ebcd ,_gdba :=data [_fafbe ],data [_fafbe +1],data [_fafbe +2];if len (decode )==6{_dgga =uint8 (uint32 (LinearInterpolate (float64 (_dgga ),0,255,decode [0],decode [1]))&0xff);
_ebcd =uint8 (uint32 (LinearInterpolate (float64 (_ebcd ),0,255,decode [2],decode [3]))&0xff);_gdba =uint8 (uint32 (LinearInterpolate (float64 (_gdba ),0,255,decode [4],decode [5]))&0xff);};return _g .RGBA {R :_dgga ,G :_ebcd ,B :_gdba ,A :_abfc },nil ;
};func _efcf (_dgb _g .NYCbCrA )_g .RGBA {_dgc ,_agac ,_cagc ,_cbca :=_acgc (_dgb ).RGBA ();return _g .RGBA {R :uint8 (_dgc >>8),G :uint8 (_agac >>8),B :uint8 (_cagc >>8),A :uint8 (_cbca >>8)};};type NRGBA64 struct{ImageBase };var _ _a .Image =&RGBA32 {};
func _bgfca (_acdgg _a .Image ,_ebea int )(_a .Rectangle ,bool ,[]byte ){_ddfcg :=_acdgg .Bounds ();var (_cdbb bool ;_cdaf []byte ;);switch _bdb :=_acdgg .(type ){case SMasker :_cdbb =_bdb .HasAlpha ();case NRGBA ,RGBA ,*_a .RGBA64 ,nrgba64 ,*_a .NYCbCrA :_cdaf =make ([]byte ,_ddfcg .Max .X *_ddfcg .Max .Y *_ebea );
case *_a .Paletted :var _acae bool ;for _ ,_ddcf :=range _bdb .Palette {_fceec ,_aaff ,_fabaf ,_defac :=_ddcf .RGBA ();if _fceec ==0&&_aaff ==0&&_fabaf ==0&&_defac !=0{_acae =true ;break ;};};if _acae {_cdaf =make ([]byte ,_ddfcg .Max .X *_ddfcg .Max .Y *_ebea );
};};return _ddfcg ,_cdbb ,_cdaf ;};func _dea ()(_abf [256]uint16 ){for _eda :=0;_eda < 256;_eda ++{if _eda &0x01!=0{_abf [_eda ]|=0x3;};if _eda &0x02!=0{_abf [_eda ]|=0xc;};if _eda &0x04!=0{_abf [_eda ]|=0x30;};if _eda &0x08!=0{_abf [_eda ]|=0xc0;};if _eda &0x10!=0{_abf [_eda ]|=0x300;
};if _eda &0x20!=0{_abf [_eda ]|=0xc00;};if _eda &0x40!=0{_abf [_eda ]|=0x3000;};if _eda &0x80!=0{_abf [_eda ]|=0xc000;};};return _abf ;};var (_ffdba =[]byte {0x00,0x80,0xC0,0xE0,0xF0,0xF8,0xFC,0xFE,0xFF};_fgfe =[]byte {0x00,0x01,0x03,0x07,0x0F,0x1F,0x3F,0x7F,0xFF};
);var _ Image =&Gray2 {};func _bb (_bbc ,_agg *Monochrome ,_ffe []byte ,_gea int )(_dffd error ){var (_bdff ,_dbg ,_aedc ,_badd ,_aad ,_gfg ,_ecac ,_affg int ;_gbb ,_gdd uint32 ;_cee ,_ebc byte ;_gda uint16 ;);_eab :=make ([]byte ,4);_ege :=make ([]byte ,4);
for _aedc =0;_aedc < _bbc .Height -1;_aedc ,_badd =_aedc +2,_badd +1{_bdff =_aedc *_bbc .BytesPerLine ;_dbg =_badd *_agg .BytesPerLine ;for _aad ,_gfg =0,0;_aad < _gea ;_aad ,_gfg =_aad +4,_gfg +1{for _ecac =0;_ecac < 4;_ecac ++{_affg =_bdff +_aad +_ecac ;
if _affg <=len (_bbc .Data )-1&&_affg < _bdff +_bbc .BytesPerLine {_eab [_ecac ]=_bbc .Data [_affg ];}else {_eab [_ecac ]=0x00;};_affg =_bdff +_bbc .BytesPerLine +_aad +_ecac ;if _affg <=len (_bbc .Data )-1&&_affg < _bdff +(2*_bbc .BytesPerLine ){_ege [_ecac ]=_bbc .Data [_affg ];
}else {_ege [_ecac ]=0x00;};};_gbb =_dc .BigEndian .Uint32 (_eab );_gdd =_dc .BigEndian .Uint32 (_ege );_gdd &=_gbb ;_gdd &=_gdd <<1;_gdd &=0xaaaaaaaa;_gbb =_gdd |(_gdd <<7);_cee =byte (_gbb >>24);_ebc =byte ((_gbb >>8)&0xff);_affg =_dbg +_gfg ;if _affg +1==len (_agg .Data )-1||_affg +1>=_dbg +_agg .BytesPerLine {_agg .Data [_affg ]=_ffe [_cee ];
if _dffd =_agg .setByte (_affg ,_ffe [_cee ]);_dffd !=nil {return _cb .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_affg );};}else {_gda =(uint16 (_ffe [_cee ])<<8)|uint16 (_ffe [_ebc ]);if _dffd =_agg .setTwoBytes (_affg ,_gda );_dffd !=nil {return _cb .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_affg );
};_gfg ++;};};};return nil ;};func _e (_eb *Monochrome ,_fg int ,_dfb []uint )(*Monochrome ,error ){_ac :=_fg *_eb .Width ;_ebb :=_fg *_eb .Height ;_gb :=_cbdf (_ac ,_ebb );for _eg ,_dd :=range _dfb {var _gf error ;switch _dd {case 2:_gf =_ccf (_gb ,_eb );
case 4:_gf =_dbc (_gb ,_eb );case 8:_gf =_dfe (_gb ,_eb );};if _gf !=nil {return nil ,_gf ;};if _eg !=len (_dfb )-1{_eb =_gb .copy ();};};return _gb ,nil ;};func (_ebcf *Monochrome )setGray (_bdg int ,_efge _g .Gray ,_faba int ){if _efge .Y ==0{_ebcf .clearBit (_faba ,_bdg );
}else {_ebcf .setGrayBit (_faba ,_bdg );};};func (_egbb *Gray16 )SetGray (x ,y int ,g _g .Gray ){_gdaa :=(y *_egbb .BytesPerLine /2+x )*2;if _gdaa +1>=len (_egbb .Data ){return ;};_egbb .Data [_gdaa ]=g .Y ;_egbb .Data [_gdaa +1]=g .Y ;};func LinearInterpolate (x ,xmin ,xmax ,ymin ,ymax float64 )float64 {if _c .Abs (xmax -xmin )< 0.000001{return ymin ;
};_gbda :=ymin +(x -xmin )*(ymax -ymin )/(xmax -xmin );return _gbda ;};func (_fecb *RGBA32 )At (x ,y int )_g .Color {_ffeg ,_ :=_fecb .ColorAt (x ,y );return _ffeg };func BytesPerLine (width ,bitsPerComponent ,colorComponents int )int {return ((width *bitsPerComponent )*colorComponents +7)>>3;
};func (_dafe *NRGBA16 )At (x ,y int )_g .Color {_dgdcf ,_ :=_dafe .ColorAt (x ,y );return _dgdcf };func _fga (_fef ,_cfa int ,_affe []byte )*Monochrome {_cge :=_cbdf (_fef ,_cfa );_cge .Data =_affe ;return _cge ;};func (_fgad *Monochrome )getBitAt (_bebd ,_aacc int )bool {_cegf :=_aacc *_fgad .BytesPerLine +(_bebd >>3);
_dec :=_bebd &0x07;_gced :=uint (7-_dec );if _cegf > len (_fgad .Data )-1{return false ;};if (_fgad .Data [_cegf ]>>_gced )&0x01>=1{return true ;};return false ;};func (_abfe *CMYK32 )SetCMYK (x ,y int ,c _g .CMYK ){_dgdc :=4*(y *_abfe .Width +x );if _dgdc +3>=len (_abfe .Data ){return ;
};_abfe .Data [_dgdc ]=c .C ;_abfe .Data [_dgdc +1]=c .M ;_abfe .Data [_dgdc +2]=c .Y ;_abfe .Data [_dgdc +3]=c .K ;};var _ Image =&NRGBA32 {};func _dfbc (_cccd *Monochrome ,_bfea ,_fcde ,_ebfc ,_efad int ,_bbgb RasterOperator ,_fdeg *Monochrome ,_aaef ,_dgac int )error {var (_fdfd bool ;
_cbe bool ;_ddfcb int ;_agdce int ;_dfaee int ;_affa bool ;_dcdd byte ;_ggfg int ;_efcc int ;_ffdc int ;_cdf ,_gee int ;);_abfb :=8-(_bfea &7);_bgbb :=_fgfe [_abfb ];_bba :=_cccd .BytesPerLine *_fcde +(_bfea >>3);_gga :=_fdeg .BytesPerLine *_dgac +(_aaef >>3);
if _ebfc < _abfb {_fdfd =true ;_bgbb &=_ffdba [8-_abfb +_ebfc ];};if !_fdfd {_ddfcb =(_ebfc -_abfb )>>3;if _ddfcb > 0{_cbe =true ;_agdce =_bba +1;_dfaee =_gga +1;};};_ggfg =(_bfea +_ebfc )&7;if !(_fdfd ||_ggfg ==0){_affa =true ;_dcdd =_ffdba [_ggfg ];_efcc =_bba +1+_ddfcb ;
_ffdc =_gga +1+_ddfcb ;};switch _bbgb {case PixSrc :for _cdf =0;_cdf < _efad ;_cdf ++{_cccd .Data [_bba ]=_gfdg (_cccd .Data [_bba ],_fdeg .Data [_gga ],_bgbb );_bba +=_cccd .BytesPerLine ;_gga +=_fdeg .BytesPerLine ;};if _cbe {for _cdf =0;_cdf < _efad ;
_cdf ++{for _gee =0;_gee < _ddfcb ;_gee ++{_cccd .Data [_agdce +_gee ]=_fdeg .Data [_dfaee +_gee ];};_agdce +=_cccd .BytesPerLine ;_dfaee +=_fdeg .BytesPerLine ;};};if _affa {for _cdf =0;_cdf < _efad ;_cdf ++{_cccd .Data [_efcc ]=_gfdg (_cccd .Data [_efcc ],_fdeg .Data [_ffdc ],_dcdd );
_efcc +=_cccd .BytesPerLine ;_ffdc +=_fdeg .BytesPerLine ;};};case PixNotSrc :for _cdf =0;_cdf < _efad ;_cdf ++{_cccd .Data [_bba ]=_gfdg (_cccd .Data [_bba ],^_fdeg .Data [_gga ],_bgbb );_bba +=_cccd .BytesPerLine ;_gga +=_fdeg .BytesPerLine ;};if _cbe {for _cdf =0;
_cdf < _efad ;_cdf ++{for _gee =0;_gee < _ddfcb ;_gee ++{_cccd .Data [_agdce +_gee ]=^_fdeg .Data [_dfaee +_gee ];};_agdce +=_cccd .BytesPerLine ;_dfaee +=_fdeg .BytesPerLine ;};};if _affa {for _cdf =0;_cdf < _efad ;_cdf ++{_cccd .Data [_efcc ]=_gfdg (_cccd .Data [_efcc ],^_fdeg .Data [_ffdc ],_dcdd );
_efcc +=_cccd .BytesPerLine ;_ffdc +=_fdeg .BytesPerLine ;};};case PixSrcOrDst :for _cdf =0;_cdf < _efad ;_cdf ++{_cccd .Data [_bba ]=_gfdg (_cccd .Data [_bba ],_fdeg .Data [_gga ]|_cccd .Data [_bba ],_bgbb );_bba +=_cccd .BytesPerLine ;_gga +=_fdeg .BytesPerLine ;
};if _cbe {for _cdf =0;_cdf < _efad ;_cdf ++{for _gee =0;_gee < _ddfcb ;_gee ++{_cccd .Data [_agdce +_gee ]|=_fdeg .Data [_dfaee +_gee ];};_agdce +=_cccd .BytesPerLine ;_dfaee +=_fdeg .BytesPerLine ;};};if _affa {for _cdf =0;_cdf < _efad ;_cdf ++{_cccd .Data [_efcc ]=_gfdg (_cccd .Data [_efcc ],_fdeg .Data [_ffdc ]|_cccd .Data [_efcc ],_dcdd );
_efcc +=_cccd .BytesPerLine ;_ffdc +=_fdeg .BytesPerLine ;};};case PixSrcAndDst :for _cdf =0;_cdf < _efad ;_cdf ++{_cccd .Data [_bba ]=_gfdg (_cccd .Data [_bba ],_fdeg .Data [_gga ]&_cccd .Data [_bba ],_bgbb );_bba +=_cccd .BytesPerLine ;_gga +=_fdeg .BytesPerLine ;
};if _cbe {for _cdf =0;_cdf < _efad ;_cdf ++{for _gee =0;_gee < _ddfcb ;_gee ++{_cccd .Data [_agdce +_gee ]&=_fdeg .Data [_dfaee +_gee ];};_agdce +=_cccd .BytesPerLine ;_dfaee +=_fdeg .BytesPerLine ;};};if _affa {for _cdf =0;_cdf < _efad ;_cdf ++{_cccd .Data [_efcc ]=_gfdg (_cccd .Data [_efcc ],_fdeg .Data [_ffdc ]&_cccd .Data [_efcc ],_dcdd );
_efcc +=_cccd .BytesPerLine ;_ffdc +=_fdeg .BytesPerLine ;};};case PixSrcXorDst :for _cdf =0;_cdf < _efad ;_cdf ++{_cccd .Data [_bba ]=_gfdg (_cccd .Data [_bba ],_fdeg .Data [_gga ]^_cccd .Data [_bba ],_bgbb );_bba +=_cccd .BytesPerLine ;_gga +=_fdeg .BytesPerLine ;
};if _cbe {for _cdf =0;_cdf < _efad ;_cdf ++{for _gee =0;_gee < _ddfcb ;_gee ++{_cccd .Data [_agdce +_gee ]^=_fdeg .Data [_dfaee +_gee ];};_agdce +=_cccd .BytesPerLine ;_dfaee +=_fdeg .BytesPerLine ;};};if _affa {for _cdf =0;_cdf < _efad ;_cdf ++{_cccd .Data [_efcc ]=_gfdg (_cccd .Data [_efcc ],_fdeg .Data [_ffdc ]^_cccd .Data [_efcc ],_dcdd );
_efcc +=_cccd .BytesPerLine ;_ffdc +=_fdeg .BytesPerLine ;};};case PixNotSrcOrDst :for _cdf =0;_cdf < _efad ;_cdf ++{_cccd .Data [_bba ]=_gfdg (_cccd .Data [_bba ],^(_fdeg .Data [_gga ])|_cccd .Data [_bba ],_bgbb );_bba +=_cccd .BytesPerLine ;_gga +=_fdeg .BytesPerLine ;
};if _cbe {for _cdf =0;_cdf < _efad ;_cdf ++{for _gee =0;_gee < _ddfcb ;_gee ++{_cccd .Data [_agdce +_gee ]|=^(_fdeg .Data [_dfaee +_gee ]);};_agdce +=_cccd .BytesPerLine ;_dfaee +=_fdeg .BytesPerLine ;};};if _affa {for _cdf =0;_cdf < _efad ;_cdf ++{_cccd .Data [_efcc ]=_gfdg (_cccd .Data [_efcc ],^(_fdeg .Data [_ffdc ])|_cccd .Data [_efcc ],_dcdd );
_efcc +=_cccd .BytesPerLine ;_ffdc +=_fdeg .BytesPerLine ;};};case PixNotSrcAndDst :for _cdf =0;_cdf < _efad ;_cdf ++{_cccd .Data [_bba ]=_gfdg (_cccd .Data [_bba ],^(_fdeg .Data [_gga ])&_cccd .Data [_bba ],_bgbb );_bba +=_cccd .BytesPerLine ;_gga +=_fdeg .BytesPerLine ;
};if _cbe {for _cdf =0;_cdf < _efad ;_cdf ++{for _gee =0;_gee < _ddfcb ;_gee ++{_cccd .Data [_agdce +_gee ]&=^_fdeg .Data [_dfaee +_gee ];};_agdce +=_cccd .BytesPerLine ;_dfaee +=_fdeg .BytesPerLine ;};};if _affa {for _cdf =0;_cdf < _efad ;_cdf ++{_cccd .Data [_efcc ]=_gfdg (_cccd .Data [_efcc ],^(_fdeg .Data [_ffdc ])&_cccd .Data [_efcc ],_dcdd );
_efcc +=_cccd .BytesPerLine ;_ffdc +=_fdeg .BytesPerLine ;};};case PixSrcOrNotDst :for _cdf =0;_cdf < _efad ;_cdf ++{_cccd .Data [_bba ]=_gfdg (_cccd .Data [_bba ],_fdeg .Data [_gga ]|^(_cccd .Data [_bba ]),_bgbb );_bba +=_cccd .BytesPerLine ;_gga +=_fdeg .BytesPerLine ;
};if _cbe {for _cdf =0;_cdf < _efad ;_cdf ++{for _gee =0;_gee < _ddfcb ;_gee ++{_cccd .Data [_agdce +_gee ]=_fdeg .Data [_dfaee +_gee ]|^(_cccd .Data [_agdce +_gee ]);};_agdce +=_cccd .BytesPerLine ;_dfaee +=_fdeg .BytesPerLine ;};};if _affa {for _cdf =0;
_cdf < _efad ;_cdf ++{_cccd .Data [_efcc ]=_gfdg (_cccd .Data [_efcc ],_fdeg .Data [_ffdc ]|^(_cccd .Data [_efcc ]),_dcdd );_efcc +=_cccd .BytesPerLine ;_ffdc +=_fdeg .BytesPerLine ;};};case PixSrcAndNotDst :for _cdf =0;_cdf < _efad ;_cdf ++{_cccd .Data [_bba ]=_gfdg (_cccd .Data [_bba ],_fdeg .Data [_gga ]&^(_cccd .Data [_bba ]),_bgbb );
_bba +=_cccd .BytesPerLine ;_gga +=_fdeg .BytesPerLine ;};if _cbe {for _cdf =0;_cdf < _efad ;_cdf ++{for _gee =0;_gee < _ddfcb ;_gee ++{_cccd .Data [_agdce +_gee ]=_fdeg .Data [_dfaee +_gee ]&^(_cccd .Data [_agdce +_gee ]);};_agdce +=_cccd .BytesPerLine ;
_dfaee +=_fdeg .BytesPerLine ;};};if _affa {for _cdf =0;_cdf < _efad ;_cdf ++{_cccd .Data [_efcc ]=_gfdg (_cccd .Data [_efcc ],_fdeg .Data [_ffdc ]&^(_cccd .Data [_efcc ]),_dcdd );_efcc +=_cccd .BytesPerLine ;_ffdc +=_fdeg .BytesPerLine ;};};case PixNotPixSrcOrDst :for _cdf =0;
_cdf < _efad ;_cdf ++{_cccd .Data [_bba ]=_gfdg (_cccd .Data [_bba ],^(_fdeg .Data [_gga ]|_cccd .Data [_bba ]),_bgbb );_bba +=_cccd .BytesPerLine ;_gga +=_fdeg .BytesPerLine ;};if _cbe {for _cdf =0;_cdf < _efad ;_cdf ++{for _gee =0;_gee < _ddfcb ;_gee ++{_cccd .Data [_agdce +_gee ]=^(_fdeg .Data [_dfaee +_gee ]|_cccd .Data [_agdce +_gee ]);
};_agdce +=_cccd .BytesPerLine ;_dfaee +=_fdeg .BytesPerLine ;};};if _affa {for _cdf =0;_cdf < _efad ;_cdf ++{_cccd .Data [_efcc ]=_gfdg (_cccd .Data [_efcc ],^(_fdeg .Data [_ffdc ]|_cccd .Data [_efcc ]),_dcdd );_efcc +=_cccd .BytesPerLine ;_ffdc +=_fdeg .BytesPerLine ;
};};case PixNotPixSrcAndDst :for _cdf =0;_cdf < _efad ;_cdf ++{_cccd .Data [_bba ]=_gfdg (_cccd .Data [_bba ],^(_fdeg .Data [_gga ]&_cccd .Data [_bba ]),_bgbb );_bba +=_cccd .BytesPerLine ;_gga +=_fdeg .BytesPerLine ;};if _cbe {for _cdf =0;_cdf < _efad ;
_cdf ++{for _gee =0;_gee < _ddfcb ;_gee ++{_cccd .Data [_agdce +_gee ]=^(_fdeg .Data [_dfaee +_gee ]&_cccd .Data [_agdce +_gee ]);};_agdce +=_cccd .BytesPerLine ;_dfaee +=_fdeg .BytesPerLine ;};};if _affa {for _cdf =0;_cdf < _efad ;_cdf ++{_cccd .Data [_efcc ]=_gfdg (_cccd .Data [_efcc ],^(_fdeg .Data [_ffdc ]&_cccd .Data [_efcc ]),_dcdd );
_efcc +=_cccd .BytesPerLine ;_ffdc +=_fdeg .BytesPerLine ;};};case PixNotPixSrcXorDst :for _cdf =0;_cdf < _efad ;_cdf ++{_cccd .Data [_bba ]=_gfdg (_cccd .Data [_bba ],^(_fdeg .Data [_gga ]^_cccd .Data [_bba ]),_bgbb );_bba +=_cccd .BytesPerLine ;_gga +=_fdeg .BytesPerLine ;
};if _cbe {for _cdf =0;_cdf < _efad ;_cdf ++{for _gee =0;_gee < _ddfcb ;_gee ++{_cccd .Data [_agdce +_gee ]=^(_fdeg .Data [_dfaee +_gee ]^_cccd .Data [_agdce +_gee ]);};_agdce +=_cccd .BytesPerLine ;_dfaee +=_fdeg .BytesPerLine ;};};if _affa {for _cdf =0;
_cdf < _efad ;_cdf ++{_cccd .Data [_efcc ]=_gfdg (_cccd .Data [_efcc ],^(_fdeg .Data [_ffdc ]^_cccd .Data [_efcc ]),_dcdd );_efcc +=_cccd .BytesPerLine ;_ffdc +=_fdeg .BytesPerLine ;};};default:_cbd .Log .Debug ("I\u006e\u0076\u0061\u006c\u0069\u0064 \u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070e\u0072\u0061\u0074o\u0072:\u0020\u0025\u0064",_bbgb );
return _bd .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072");};return nil ;};func (_eeecg *RGBA32 )Bounds ()_a .Rectangle {return _a .Rectangle {Max :_a .Point {X :_eeecg .Width ,Y :_eeecg .Height }};
};func (_fbda *RGBA32 )setRGBA (_dbdga int ,_cdbca _g .RGBA ){_bfge :=3*_dbdga ;_fbda .Data [_bfge ]=_cdbca .R ;_fbda .Data [_bfge +1]=_cdbca .G ;_fbda .Data [_bfge +2]=_cdbca .B ;if _dbdga < len (_fbda .Alpha ){_fbda .Alpha [_dbdga ]=_cdbca .A ;};};func (_babf *ImageBase )setTwoBytes (_abeb int ,_eadf uint16 )error {if _abeb +1> len (_babf .Data )-1{return _bd .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_babf .Data [_abeb ]=byte ((_eadf &0xff00)>>8);_babf .Data [_abeb +1]=byte (_eadf &0xff);return nil ;};func (_cbad *NRGBA32 )Validate ()error {if len (_cbad .Data )!=3*_cbad .Width *_cbad .Height {return _bd .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func _cgee (_eafa int ,_dafg int )int {if _eafa < _dafg {return _eafa ;};return _dafg ;};type Gray16 struct{ImageBase };func (_fcfc *Gray8 )ColorModel ()_g .Model {return _g .GrayModel };func _dgg (_cca NRGBA ,_adf CMYK ,_cfe _a .Rectangle ){for _fecf :=0;
_fecf < _cfe .Max .X ;_fecf ++{for _acdg :=0;_acdg < _cfe .Max .Y ;_acdg ++{_cfae :=_cca .NRGBAAt (_fecf ,_acdg );_adf .SetCMYK (_fecf ,_acdg ,_abd (_cfae ));};};};func _fcf (_fag _g .NRGBA )_g .Gray {var _gcc _g .NRGBA ;if _fag ==_gcc {return _g .Gray {Y :0xff};
};_gdde ,_agb ,_edag ,_ :=_fag .RGBA ();_cgbb :=(19595*_gdde +38470*_agb +7471*_edag +1<<15)>>24;return _g .Gray {Y :uint8 (_cgbb )};};func (_dacce *Gray4 )Base ()*ImageBase {return &_dacce .ImageBase };const (PixSrc RasterOperator =0xc;PixDst RasterOperator =0xa;
PixNotSrc RasterOperator =0x3;PixNotDst RasterOperator =0x5;PixClr RasterOperator =0x0;PixSet RasterOperator =0xf;PixSrcOrDst RasterOperator =0xe;PixSrcAndDst RasterOperator =0x8;PixSrcXorDst RasterOperator =0x6;PixNotSrcOrDst RasterOperator =0xb;PixNotSrcAndDst RasterOperator =0x2;
PixSrcOrNotDst RasterOperator =0xd;PixSrcAndNotDst RasterOperator =0x4;PixNotPixSrcOrDst RasterOperator =0x1;PixNotPixSrcAndDst RasterOperator =0x7;PixNotPixSrcXorDst RasterOperator =0x9;PixPaint =PixSrcOrDst ;PixSubtract =PixNotSrcAndDst ;PixMask =PixSrcAndDst ;
);func FromGoImage (i _a .Image )(Image ,error ){switch _bgeg :=i .(type ){case Image :return _bgeg .Copy (),nil ;case Gray :return GrayConverter .Convert (i );case *_a .Gray16 :return Gray16Converter .Convert (i );case CMYK :return CMYKConverter .Convert (i );
case *_a .NRGBA64 :return NRGBA64Converter .Convert (i );default:return NRGBAConverter .Convert (i );};};func _gcdg (_fafca ,_bbcba NRGBA ,_fafb _a .Rectangle ){for _adfg :=0;_adfg < _fafb .Max .X ;_adfg ++{for _dabc :=0;_dabc < _fafb .Max .Y ;_dabc ++{_bbcba .SetNRGBA (_adfg ,_dabc ,_fafca .NRGBAAt (_adfg ,_dabc ));
};};};var _ Gray =&Monochrome {};func _egbbd (_fbbf *Monochrome ,_eec ,_gfad int ,_gccea ,_eddf int ,_adba RasterOperator ){var (_bgfc int ;_fgfa byte ;_efgdd ,_gffd int ;_fcdg int ;);_gagcc :=_gccea >>3;_ebfd :=_gccea &7;if _ebfd > 0{_fgfa =_ffdba [_ebfd ];
};_bgfc =_fbbf .BytesPerLine *_gfad +(_eec >>3);switch _adba {case PixClr :for _efgdd =0;_efgdd < _eddf ;_efgdd ++{_fcdg =_bgfc +_efgdd *_fbbf .BytesPerLine ;for _gffd =0;_gffd < _gagcc ;_gffd ++{_fbbf .Data [_fcdg ]=0x0;_fcdg ++;};if _ebfd > 0{_fbbf .Data [_fcdg ]=_gfdg (_fbbf .Data [_fcdg ],0x0,_fgfa );
};};case PixSet :for _efgdd =0;_efgdd < _eddf ;_efgdd ++{_fcdg =_bgfc +_efgdd *_fbbf .BytesPerLine ;for _gffd =0;_gffd < _gagcc ;_gffd ++{_fbbf .Data [_fcdg ]=0xff;_fcdg ++;};if _ebfd > 0{_fbbf .Data [_fcdg ]=_gfdg (_fbbf .Data [_fcdg ],0xff,_fgfa );};
};case PixNotDst :for _efgdd =0;_efgdd < _eddf ;_efgdd ++{_fcdg =_bgfc +_efgdd *_fbbf .BytesPerLine ;for _gffd =0;_gffd < _gagcc ;_gffd ++{_fbbf .Data [_fcdg ]=^_fbbf .Data [_fcdg ];_fcdg ++;};if _ebfd > 0{_fbbf .Data [_fcdg ]=_gfdg (_fbbf .Data [_fcdg ],^_fbbf .Data [_fcdg ],_fgfa );
};};};};var _ _a .Image =&Monochrome {};func (_bcd *NRGBA16 )setNRGBA (_gcccd ,_fafg ,_gecc int ,_fbaa _g .NRGBA ){if _gcccd *3%2==0{_bcd .Data [_gecc ]=(_fbaa .R >>4)<<4|(_fbaa .G >>4);_bcd .Data [_gecc +1]=(_fbaa .B >>4)<<4|(_bcd .Data [_gecc +1]&0xf);
}else {_bcd .Data [_gecc ]=(_bcd .Data [_gecc ]&0xf0)|(_fbaa .R >>4);_bcd .Data [_gecc +1]=(_fbaa .G >>4)<<4|(_fbaa .B >>4);};if _bcd .Alpha !=nil {_afbc :=_fafg *BytesPerLine (_bcd .Width ,4,1);if _afbc < len (_bcd .Alpha ){if _gcccd %2==0{_bcd .Alpha [_afbc ]=(_fbaa .A >>uint (4))<<uint (4)|(_bcd .Alpha [_gecc ]&0xf);
}else {_bcd .Alpha [_afbc ]=(_bcd .Alpha [_afbc ]&0xf0)|(_fbaa .A >>uint (4));};};};};func (_fgg *Gray2 )SetGray (x ,y int ,gray _g .Gray ){_fdf :=_fdea (gray );_feda :=y *_fgg .BytesPerLine ;_afgf :=_feda +(x >>2);if _afgf >=len (_fgg .Data ){return ;
};_ebaa :=_fdf .Y >>6;_fgg .Data [_afgf ]=(_fgg .Data [_afgf ]&(^(0xc0>>uint (2*((x )&3)))))|(_ebaa <<uint (6-2*(x &3)));};func (_ceef *Gray16 )Validate ()error {if len (_ceef .Data )!=_ceef .Height *_ceef .BytesPerLine {return ErrInvalidImage ;};return nil ;
};func _gbe (_cfcf _g .Gray )_g .RGBA {return _g .RGBA {R :_cfcf .Y ,G :_cfcf .Y ,B :_cfcf .Y ,A :0xff}};var _ RGBA =&RGBA32 {};func _bebf (_afbg _g .Gray )_g .CMYK {return _g .CMYK {K :0xff-_afbg .Y }};func _gag (_ebd ,_adb *Monochrome ,_eff []byte ,_ade int )(_efc error ){var (_bce ,_def ,_baf ,_dbdg ,_fbe ,_cfag ,_eggg ,_afca int ;
_bdf ,_bg ,_aeda ,_cbg uint32 ;_fed ,_aeec byte ;_bcf uint16 ;);_edf :=make ([]byte ,4);_affc :=make ([]byte ,4);for _baf =0;_baf < _ebd .Height -1;_baf ,_dbdg =_baf +2,_dbdg +1{_bce =_baf *_ebd .BytesPerLine ;_def =_dbdg *_adb .BytesPerLine ;for _fbe ,_cfag =0,0;
_fbe < _ade ;_fbe ,_cfag =_fbe +4,_cfag +1{for _eggg =0;_eggg < 4;_eggg ++{_afca =_bce +_fbe +_eggg ;if _afca <=len (_ebd .Data )-1&&_afca < _bce +_ebd .BytesPerLine {_edf [_eggg ]=_ebd .Data [_afca ];}else {_edf [_eggg ]=0x00;};_afca =_bce +_ebd .BytesPerLine +_fbe +_eggg ;
if _afca <=len (_ebd .Data )-1&&_afca < _bce +(2*_ebd .BytesPerLine ){_affc [_eggg ]=_ebd .Data [_afca ];}else {_affc [_eggg ]=0x00;};};_bdf =_dc .BigEndian .Uint32 (_edf );_bg =_dc .BigEndian .Uint32 (_affc );_aeda =_bdf &_bg ;_aeda |=_aeda <<1;_cbg =_bdf |_bg ;
_cbg &=_cbg <<1;_bg =_aeda |_cbg ;_bg &=0xaaaaaaaa;_bdf =_bg |(_bg <<7);_fed =byte (_bdf >>24);_aeec =byte ((_bdf >>8)&0xff);_afca =_def +_cfag ;if _afca +1==len (_adb .Data )-1||_afca +1>=_def +_adb .BytesPerLine {if _efc =_adb .setByte (_afca ,_eff [_fed ]);
_efc !=nil {return _cb .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_afca );};}else {_bcf =(uint16 (_eff [_fed ])<<8)|uint16 (_eff [_aeec ]);if _efc =_adb .setTwoBytes (_afca ,_bcf );_efc !=nil {return _cb .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_afca );
};_cfag ++;};};};return nil ;};func (_faf *Monochrome )GrayAt (x ,y int )_g .Gray {_dffdc ,_ :=ColorAtGray1BPC (x ,y ,_faf .BytesPerLine ,_faf .Data ,_faf .Decode );return _dffdc ;};func (_fefc *Gray4 )Histogram ()(_cbce [256]int ){for _fded :=0;_fded < _fefc .Width ;
_fded ++{for _efef :=0;_efef < _fefc .Height ;_efef ++{_cbce [_fefc .GrayAt (_fded ,_efef ).Y ]++;};};return _cbce ;};func (_dcg *CMYK32 )CMYKAt (x ,y int )_g .CMYK {_bebc ,_ :=ColorAtCMYK (x ,y ,_dcg .Width ,_dcg .Data ,_dcg .Decode );return _bebc ;};
func (_fdcfd *NRGBA64 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtNRGBA64 (x ,y ,_fdcfd .Width ,_fdcfd .Data ,_fdcfd .Alpha ,_fdcfd .Decode );};func _fbfa (_cfd _g .NRGBA64 )_g .NRGBA {return _g .NRGBA {R :uint8 (_cfd .R >>8),G :uint8 (_cfd .G >>8),B :uint8 (_cfd .B >>8),A :uint8 (_cfd .A >>8)};
};func (_bgbf *Gray16 )Copy ()Image {return &Gray16 {ImageBase :_bgbf .copy ()}};func (_bfcb *Monochrome )At (x ,y int )_g .Color {_ffda ,_ :=_bfcb .ColorAt (x ,y );return _ffda };func (_acfg *NRGBA32 )NRGBAAt (x ,y int )_g .NRGBA {_baab ,_ :=ColorAtNRGBA32 (x ,y ,_acfg .Width ,_acfg .Data ,_acfg .Alpha ,_acfg .Decode );
return _baab ;};func ImgToBinary (i _a .Image ,threshold uint8 )*_a .Gray {switch _cgce :=i .(type ){case *_a .Gray :if _acgce (_cgce ){return _cgce ;};return _ceadg (_cgce ,threshold );case *_a .Gray16 :return _dggcb (_cgce ,threshold );default:return _bbfg (_cgce ,threshold );
};};func _bfe (_fbeb _g .RGBA )_g .Gray {_bbce :=(19595*uint32 (_fbeb .R )+38470*uint32 (_fbeb .G )+7471*uint32 (_fbeb .B )+1<<7)>>16;return _g .Gray {Y :uint8 (_bbce )};};func (_gcg *NRGBA16 )NRGBAAt (x ,y int )_g .NRGBA {_cdbe ,_ :=ColorAtNRGBA16 (x ,y ,_gcg .Width ,_gcg .BytesPerLine ,_gcg .Data ,_gcg .Alpha ,_gcg .Decode );
return _cdbe ;};func (_addf *RGBA32 )Base ()*ImageBase {return &_addf .ImageBase };func (_fca *Monochrome )IsUnpadded ()bool {return (_fca .Width *_fca .Height )==len (_fca .Data )};func (_cagcc *Gray2 )Histogram ()(_gage [256]int ){for _ded :=0;_ded < _cagcc .Width ;
_ded ++{for _ddaa :=0;_ddaa < _cagcc .Height ;_ddaa ++{_gage [_cagcc .GrayAt (_ded ,_ddaa ).Y ]++;};};return _gage ;};func _acef (_gdbc _g .Color )_g .Color {_add :=_g .GrayModel .Convert (_gdbc ).(_g .Gray );return _fdea (_add );};func ColorAt (x ,y ,width ,bitsPerColor ,colorComponents ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_g .Color ,error ){switch colorComponents {case 1:return ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine ,data ,decode );
case 3:return ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor ,data ,alpha ,decode );case 4:return ColorAtCMYK (x ,y ,width ,data ,decode );default:return nil ,_cb .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0063o\u006c\u006f\u0072\u0020\u0063\u006f\u006dp\u006f\u006e\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0064",colorComponents );
};};func (_efb *Monochrome )Bounds ()_a .Rectangle {return _a .Rectangle {Max :_a .Point {X :_efb .Width ,Y :_efb .Height }};};func AutoThresholdTriangle (histogram [256]int )uint8 {var _afee ,_geeg ,_cegd ,_gbfaec int ;for _fggcg :=0;_fggcg < len (histogram );
_fggcg ++{if histogram [_fggcg ]> 0{_afee =_fggcg ;break ;};};if _afee > 0{_afee --;};for _bebfb :=255;_bebfb > 0;_bebfb --{if histogram [_bebfb ]> 0{_gbfaec =_bebfb ;break ;};};if _gbfaec < 255{_gbfaec ++;};for _gecd :=0;_gecd < 256;_gecd ++{if histogram [_gecd ]> _geeg {_cegd =_gecd ;
_geeg =histogram [_gecd ];};};var _cedb bool ;if (_cegd -_afee )< (_gbfaec -_cegd ){_cedb =true ;var _eedfb int ;_gadf :=255;for _eedfb < _gadf {_bcab :=histogram [_eedfb ];histogram [_eedfb ]=histogram [_gadf ];histogram [_gadf ]=_bcab ;_eedfb ++;_gadf --;
};_afee =255-_gbfaec ;_cegd =255-_cegd ;};if _afee ==_cegd {return uint8 (_afee );};_ffea :=float64 (histogram [_cegd ]);_eaaec :=float64 (_afee -_cegd );_dgff :=_c .Sqrt (_ffea *_ffea +_eaaec *_eaaec );_ffea /=_dgff ;_eaaec /=_dgff ;_dgff =_ffea *float64 (_afee )+_eaaec *float64 (histogram [_afee ]);
_aaca :=_afee ;var _fada float64 ;for _abga :=_afee +1;_abga <=_cegd ;_abga ++{_bcfe :=_ffea *float64 (_abga )+_eaaec *float64 (histogram [_abga ])-_dgff ;if _bcfe > _fada {_aaca =_abga ;_fada =_bcfe ;};};_aaca --;if _cedb {var _dbad int ;_gafc :=255;for _dbad < _gafc {_bbfdc :=histogram [_dbad ];
histogram [_dbad ]=histogram [_gafc ];histogram [_gafc ]=_bbfdc ;_dbad ++;_gafc --;};return uint8 (255-_aaca );};return uint8 (_aaca );};type Gray4 struct{ImageBase };func _fgae (_ccg _g .RGBA )_g .CMYK {_dccdg ,_eea ,_ccfa ,_dggc :=_g .RGBToCMYK (_ccg .R ,_ccg .G ,_ccg .B );
return _g .CMYK {C :_dccdg ,M :_eea ,Y :_ccfa ,K :_dggc };};func _aded (_bcfg CMYK ,_defd Gray ,_gbga _a .Rectangle ){for _ffg :=0;_ffg < _gbga .Max .X ;_ffg ++{for _gbc :=0;_gbc < _gbga .Max .Y ;_gbc ++{_aaa :=_bedb (_bcfg .CMYKAt (_ffg ,_gbc ));_defd .SetGray (_ffg ,_gbc ,_aaa );
};};};func (_fabg *Monochrome )ColorModel ()_g .Model {return MonochromeModel (_fabg .ModelThreshold )};func IsGrayImgBlackAndWhite (i *_a .Gray )bool {return _acgce (i )};func (_feff *Monochrome )setGrayBit (_gaag ,_acdga int ){_feff .Data [_gaag ]|=0x80>>uint (_acdga &7)};
func _bafb (_beda _g .Gray )_g .NRGBA {return _g .NRGBA {R :_beda .Y ,G :_beda .Y ,B :_beda .Y ,A :0xff}};func (_cffb *Monochrome )setIndexedBit (_cage int ){_cffb .Data [(_cage >>3)]|=0x80>>uint (_cage &7)};func _cf (_cg *Monochrome ,_cc int )(*Monochrome ,error ){if _cg ==nil {return nil ,_bd .New ("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064");
};if _cc ==1{return _cg .copy (),nil ;};if !IsPowerOf2 (uint (_cc )){return nil ,_cb .Errorf ("\u0070\u0072\u006fvi\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006ci\u0064 \u0065x\u0070a\u006e\u0064\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_cc );
};_af :=_fc (_cc );return _e (_cg ,_cc ,_af );};func (_gff *Monochrome )ResolveDecode ()error {if len (_gff .Decode )!=2{return nil ;};if _gff .Decode [0]==1&&_gff .Decode [1]==0{if _cff :=_gff .InverseData ();_cff !=nil {return _cff ;};_gff .Decode =nil ;
};return nil ;};func _cgef ()(_aaf []byte ){_aaf =make ([]byte ,256);for _afff :=0;_afff < 256;_afff ++{_cag :=byte (_afff );_aaf [_cag ]=(_cag &0x01)|((_cag &0x04)>>1)|((_cag &0x10)>>2)|((_cag &0x40)>>3)|((_cag &0x02)<<3)|((_cag &0x08)<<2)|((_cag &0x20)<<1)|(_cag &0x80);
};return _aaf ;};func _ebga (_bace Gray ,_gbeb RGBA ,_dffc _a .Rectangle ){for _gaca :=0;_gaca < _dffc .Max .X ;_gaca ++{for _fgdd :=0;_fgdd < _dffc .Max .Y ;_fgdd ++{_fbcb :=_bace .GrayAt (_gaca ,_fgdd );_gbeb .SetRGBA (_gaca ,_fgdd ,_gbe (_fbcb ));};
};};func (_fbfd *Monochrome )Validate ()error {if len (_fbfd .Data )!=_fbfd .Height *_fbfd .BytesPerLine {return ErrInvalidImage ;};return nil ;};type Gray8 struct{ImageBase };type ColorConverter interface{Convert (_ebdd _a .Image )(Image ,error );};type RasterOperator int ;
func (_daf *Gray16 )Base ()*ImageBase {return &_daf .ImageBase };