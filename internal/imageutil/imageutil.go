//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package imageutil ;import (_gg "encoding/binary";_a "errors";_ef "fmt";_gf "github.com/unidoc/unipdf/v3/common";_b "github.com/unidoc/unipdf/v3/internal/bitwise";_f "image";_g "image/color";_d "image/draw";_ed "math";);func (_adfa *Gray16 )Histogram ()(_efed [256]int ){for _gaff :=0;
_gaff < _adfa .Width ;_gaff ++{for _adad :=0;_adad < _adfa .Height ;_adad ++{_efed [_adfa .GrayAt (_gaff ,_adad ).Y ]++;};};return _efed ;};func _ebfg (_faac uint )uint {var _eaec uint ;for _faac !=0{_faac >>=1;_eaec ++;};return _eaec -1;};func _eea (_gaa ,_gba *Monochrome ,_bc []byte ,_fba int )(_gddd error ){var (_fgaa ,_aeg ,_dcd ,_cad ,_bgb ,_fcc ,_aegf ,_fbd int ;
_gca ,_ffc uint32 ;_fece ,_geaa byte ;_fggf uint16 ;);_abf :=make ([]byte ,4);_fabg :=make ([]byte ,4);for _dcd =0;_dcd < _gaa .Height -1;_dcd ,_cad =_dcd +2,_cad +1{_fgaa =_dcd *_gaa .BytesPerLine ;_aeg =_cad *_gba .BytesPerLine ;for _bgb ,_fcc =0,0;_bgb < _fba ;
_bgb ,_fcc =_bgb +4,_fcc +1{for _aegf =0;_aegf < 4;_aegf ++{_fbd =_fgaa +_bgb +_aegf ;if _fbd <=len (_gaa .Data )-1&&_fbd < _fgaa +_gaa .BytesPerLine {_abf [_aegf ]=_gaa .Data [_fbd ];}else {_abf [_aegf ]=0x00;};_fbd =_fgaa +_gaa .BytesPerLine +_bgb +_aegf ;
if _fbd <=len (_gaa .Data )-1&&_fbd < _fgaa +(2*_gaa .BytesPerLine ){_fabg [_aegf ]=_gaa .Data [_fbd ];}else {_fabg [_aegf ]=0x00;};};_gca =_gg .BigEndian .Uint32 (_abf );_ffc =_gg .BigEndian .Uint32 (_fabg );_ffc &=_gca ;_ffc &=_ffc <<1;_ffc &=0xaaaaaaaa;
_gca =_ffc |(_ffc <<7);_fece =byte (_gca >>24);_geaa =byte ((_gca >>8)&0xff);_fbd =_aeg +_fcc ;if _fbd +1==len (_gba .Data )-1||_fbd +1>=_aeg +_gba .BytesPerLine {_gba .Data [_fbd ]=_bc [_fece ];if _gddd =_gba .setByte (_fbd ,_bc [_fece ]);_gddd !=nil {return _ef .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_fbd );
};}else {_fggf =(uint16 (_bc [_fece ])<<8)|uint16 (_bc [_geaa ]);if _gddd =_gba .setTwoBytes (_fbd ,_fggf );_gddd !=nil {return _ef .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_fbd );
};_fcc ++;};};};return nil ;};func _adde (_aggb Gray ,_gbfa nrgba64 ,_fbcd _f .Rectangle ){for _bfaa :=0;_bfaa < _fbcd .Max .X ;_bfaa ++{for _cdaf :=0;_cdaf < _fbcd .Max .Y ;_cdaf ++{_dfa :=_aeb (_gbfa .NRGBA64At (_bfaa ,_cdaf ));_aggb .SetGray (_bfaa ,_cdaf ,_dfa );
};};};func _efg (_faee *Monochrome ,_gbda ,_faaf ,_gegea ,_gfad int ,_gfce RasterOperator ,_ffcb *Monochrome ,_bggf ,_bgea int )error {if _faee ==nil {return _a .New ("\u006e\u0069\u006c\u0020\u0027\u0064\u0065\u0073\u0074\u0027\u0020\u0042i\u0074\u006d\u0061\u0070");
};if _gfce ==PixDst {return nil ;};switch _gfce {case PixClr ,PixSet ,PixNotDst :_bfbe (_faee ,_gbda ,_faaf ,_gegea ,_gfad ,_gfce );return nil ;};if _ffcb ==nil {_gf .Log .Debug ("\u0052a\u0073\u0074e\u0072\u004f\u0070\u0065r\u0061\u0074\u0069o\u006e\u0020\u0073\u006f\u0075\u0072\u0063\u0065\u0020bi\u0074\u006d\u0061p\u0020\u0069s\u0020\u006e\u006f\u0074\u0020\u0064e\u0066\u0069n\u0065\u0064");
return _a .New ("\u006e\u0069l\u0020\u0027\u0073r\u0063\u0027\u0020\u0062\u0069\u0074\u006d\u0061\u0070");};if _dafcf :=_geeg (_faee ,_gbda ,_faaf ,_gegea ,_gfad ,_gfce ,_ffcb ,_bggf ,_bgea );_dafcf !=nil {return _dafcf ;};return nil ;};var _ _f .Image =&Gray8 {};
func _ea ()(_ggg [256]uint32 ){for _bg :=0;_bg < 256;_bg ++{if _bg &0x01!=0{_ggg [_bg ]|=0xf;};if _bg &0x02!=0{_ggg [_bg ]|=0xf0;};if _bg &0x04!=0{_ggg [_bg ]|=0xf00;};if _bg &0x08!=0{_ggg [_bg ]|=0xf000;};if _bg &0x10!=0{_ggg [_bg ]|=0xf0000;};if _bg &0x20!=0{_ggg [_bg ]|=0xf00000;
};if _bg &0x40!=0{_ggg [_bg ]|=0xf000000;};if _bg &0x80!=0{_ggg [_bg ]|=0xf0000000;};};return _ggg ;};func (_abcfc *NRGBA64 )Copy ()Image {return &NRGBA64 {ImageBase :_abcfc .copy ()}};func _fccb ()(_cbc []byte ){_cbc =make ([]byte ,256);for _agfg :=0;
_agfg < 256;_agfg ++{_aaf :=byte (_agfg );_cbc [_aaf ]=(_aaf &0x01)|((_aaf &0x04)>>1)|((_aaf &0x10)>>2)|((_aaf &0x40)>>3)|((_aaf &0x02)<<3)|((_aaf &0x08)<<2)|((_aaf &0x20)<<1)|(_aaf &0x80);};return _cbc ;};func _aead (_afee *Monochrome ,_ecfg ,_bgcdd ,_dfag ,_cfdfb int ,_gded RasterOperator ,_feba *Monochrome ,_gdgg ,_aadd int )error {var (_gbbga byte ;
_cgee int ;_dafg int ;_cdbea ,_bfbb int ;_bfeg ,_bgeg int ;);_bbge :=_dfag >>3;_ebce :=_dfag &7;if _ebce > 0{_gbbga =_gbcf [_ebce ];};_cgee =_feba .BytesPerLine *_aadd +(_gdgg >>3);_dafg =_afee .BytesPerLine *_bgcdd +(_ecfg >>3);switch _gded {case PixSrc :for _bfeg =0;
_bfeg < _cfdfb ;_bfeg ++{_cdbea =_cgee +_bfeg *_feba .BytesPerLine ;_bfbb =_dafg +_bfeg *_afee .BytesPerLine ;for _bgeg =0;_bgeg < _bbge ;_bgeg ++{_afee .Data [_bfbb ]=_feba .Data [_cdbea ];_bfbb ++;_cdbea ++;};if _ebce > 0{_afee .Data [_bfbb ]=_fage (_afee .Data [_bfbb ],_feba .Data [_cdbea ],_gbbga );
};};case PixNotSrc :for _bfeg =0;_bfeg < _cfdfb ;_bfeg ++{_cdbea =_cgee +_bfeg *_feba .BytesPerLine ;_bfbb =_dafg +_bfeg *_afee .BytesPerLine ;for _bgeg =0;_bgeg < _bbge ;_bgeg ++{_afee .Data [_bfbb ]=^(_feba .Data [_cdbea ]);_bfbb ++;_cdbea ++;};if _ebce > 0{_afee .Data [_bfbb ]=_fage (_afee .Data [_bfbb ],^_feba .Data [_cdbea ],_gbbga );
};};case PixSrcOrDst :for _bfeg =0;_bfeg < _cfdfb ;_bfeg ++{_cdbea =_cgee +_bfeg *_feba .BytesPerLine ;_bfbb =_dafg +_bfeg *_afee .BytesPerLine ;for _bgeg =0;_bgeg < _bbge ;_bgeg ++{_afee .Data [_bfbb ]|=_feba .Data [_cdbea ];_bfbb ++;_cdbea ++;};if _ebce > 0{_afee .Data [_bfbb ]=_fage (_afee .Data [_bfbb ],_feba .Data [_cdbea ]|_afee .Data [_bfbb ],_gbbga );
};};case PixSrcAndDst :for _bfeg =0;_bfeg < _cfdfb ;_bfeg ++{_cdbea =_cgee +_bfeg *_feba .BytesPerLine ;_bfbb =_dafg +_bfeg *_afee .BytesPerLine ;for _bgeg =0;_bgeg < _bbge ;_bgeg ++{_afee .Data [_bfbb ]&=_feba .Data [_cdbea ];_bfbb ++;_cdbea ++;};if _ebce > 0{_afee .Data [_bfbb ]=_fage (_afee .Data [_bfbb ],_feba .Data [_cdbea ]&_afee .Data [_bfbb ],_gbbga );
};};case PixSrcXorDst :for _bfeg =0;_bfeg < _cfdfb ;_bfeg ++{_cdbea =_cgee +_bfeg *_feba .BytesPerLine ;_bfbb =_dafg +_bfeg *_afee .BytesPerLine ;for _bgeg =0;_bgeg < _bbge ;_bgeg ++{_afee .Data [_bfbb ]^=_feba .Data [_cdbea ];_bfbb ++;_cdbea ++;};if _ebce > 0{_afee .Data [_bfbb ]=_fage (_afee .Data [_bfbb ],_feba .Data [_cdbea ]^_afee .Data [_bfbb ],_gbbga );
};};case PixNotSrcOrDst :for _bfeg =0;_bfeg < _cfdfb ;_bfeg ++{_cdbea =_cgee +_bfeg *_feba .BytesPerLine ;_bfbb =_dafg +_bfeg *_afee .BytesPerLine ;for _bgeg =0;_bgeg < _bbge ;_bgeg ++{_afee .Data [_bfbb ]|=^(_feba .Data [_cdbea ]);_bfbb ++;_cdbea ++;};
if _ebce > 0{_afee .Data [_bfbb ]=_fage (_afee .Data [_bfbb ],^(_feba .Data [_cdbea ])|_afee .Data [_bfbb ],_gbbga );};};case PixNotSrcAndDst :for _bfeg =0;_bfeg < _cfdfb ;_bfeg ++{_cdbea =_cgee +_bfeg *_feba .BytesPerLine ;_bfbb =_dafg +_bfeg *_afee .BytesPerLine ;
for _bgeg =0;_bgeg < _bbge ;_bgeg ++{_afee .Data [_bfbb ]&=^(_feba .Data [_cdbea ]);_bfbb ++;_cdbea ++;};if _ebce > 0{_afee .Data [_bfbb ]=_fage (_afee .Data [_bfbb ],^(_feba .Data [_cdbea ])&_afee .Data [_bfbb ],_gbbga );};};case PixSrcOrNotDst :for _bfeg =0;
_bfeg < _cfdfb ;_bfeg ++{_cdbea =_cgee +_bfeg *_feba .BytesPerLine ;_bfbb =_dafg +_bfeg *_afee .BytesPerLine ;for _bgeg =0;_bgeg < _bbge ;_bgeg ++{_afee .Data [_bfbb ]=_feba .Data [_cdbea ]|^(_afee .Data [_bfbb ]);_bfbb ++;_cdbea ++;};if _ebce > 0{_afee .Data [_bfbb ]=_fage (_afee .Data [_bfbb ],_feba .Data [_cdbea ]|^(_afee .Data [_bfbb ]),_gbbga );
};};case PixSrcAndNotDst :for _bfeg =0;_bfeg < _cfdfb ;_bfeg ++{_cdbea =_cgee +_bfeg *_feba .BytesPerLine ;_bfbb =_dafg +_bfeg *_afee .BytesPerLine ;for _bgeg =0;_bgeg < _bbge ;_bgeg ++{_afee .Data [_bfbb ]=_feba .Data [_cdbea ]&^(_afee .Data [_bfbb ]);
_bfbb ++;_cdbea ++;};if _ebce > 0{_afee .Data [_bfbb ]=_fage (_afee .Data [_bfbb ],_feba .Data [_cdbea ]&^(_afee .Data [_bfbb ]),_gbbga );};};case PixNotPixSrcOrDst :for _bfeg =0;_bfeg < _cfdfb ;_bfeg ++{_cdbea =_cgee +_bfeg *_feba .BytesPerLine ;_bfbb =_dafg +_bfeg *_afee .BytesPerLine ;
for _bgeg =0;_bgeg < _bbge ;_bgeg ++{_afee .Data [_bfbb ]=^(_feba .Data [_cdbea ]|_afee .Data [_bfbb ]);_bfbb ++;_cdbea ++;};if _ebce > 0{_afee .Data [_bfbb ]=_fage (_afee .Data [_bfbb ],^(_feba .Data [_cdbea ]|_afee .Data [_bfbb ]),_gbbga );};};case PixNotPixSrcAndDst :for _bfeg =0;
_bfeg < _cfdfb ;_bfeg ++{_cdbea =_cgee +_bfeg *_feba .BytesPerLine ;_bfbb =_dafg +_bfeg *_afee .BytesPerLine ;for _bgeg =0;_bgeg < _bbge ;_bgeg ++{_afee .Data [_bfbb ]=^(_feba .Data [_cdbea ]&_afee .Data [_bfbb ]);_bfbb ++;_cdbea ++;};if _ebce > 0{_afee .Data [_bfbb ]=_fage (_afee .Data [_bfbb ],^(_feba .Data [_cdbea ]&_afee .Data [_bfbb ]),_gbbga );
};};case PixNotPixSrcXorDst :for _bfeg =0;_bfeg < _cfdfb ;_bfeg ++{_cdbea =_cgee +_bfeg *_feba .BytesPerLine ;_bfbb =_dafg +_bfeg *_afee .BytesPerLine ;for _bgeg =0;_bgeg < _bbge ;_bgeg ++{_afee .Data [_bfbb ]=^(_feba .Data [_cdbea ]^_afee .Data [_bfbb ]);
_bfbb ++;_cdbea ++;};if _ebce > 0{_afee .Data [_bfbb ]=_fage (_afee .Data [_bfbb ],^(_feba .Data [_cdbea ]^_afee .Data [_bfbb ]),_gbbga );};};default:_gf .Log .Debug ("\u0050\u0072ov\u0069\u0064\u0065d\u0020\u0069\u006e\u0076ali\u0064 r\u0061\u0073\u0074\u0065\u0072\u0020\u006fpe\u0072\u0061\u0074\u006f\u0072\u003a\u0020%\u0076",_gded );
return _a .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072");};return nil ;};var _ _f .Image =&Monochrome {};func ScaleAlphaToMonochrome (data []byte ,width ,height int )([]byte ,error ){_fc :=BytesPerLine (width ,8,1);
if len (data )< _fc *height {return nil ,nil ;};_df :=&Gray8 {NewImageBase (width ,height ,8,1,data ,nil ,nil )};_dc ,_c :=MonochromeConverter .Convert (_df );if _c !=nil {return nil ,_c ;};return _dc .Base ().Data ,nil ;};func (_cdgcg *Gray4 )Base ()*ImageBase {return &_cdgcg .ImageBase };
func (_dbba *Gray2 )Base ()*ImageBase {return &_dbba .ImageBase };func (_eed *monochromeThresholdConverter )Convert (img _f .Image )(Image ,error ){if _eca ,_daca :=img .(*Monochrome );_daca {return _eca .Copy (),nil ;};_ggbag :=img .Bounds ();_gac ,_bcf :=NewImage (_ggbag .Max .X ,_ggbag .Max .Y ,1,1,nil ,nil ,nil );
if _bcf !=nil {return nil ,_bcf ;};_gac .(*Monochrome ).ModelThreshold =_eed .Threshold ;for _aab :=0;_aab < _ggbag .Max .X ;_aab ++{for _cag :=0;_cag < _ggbag .Max .Y ;_cag ++{_efc :=img .At (_aab ,_cag );_gac .Set (_aab ,_cag ,_efc );};};return _gac ,nil ;
};var _ Image =&Gray16 {};func ColorAt (x ,y ,width ,bitsPerColor ,colorComponents ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_g .Color ,error ){switch colorComponents {case 1:return ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine ,data ,decode );
case 3:return ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor ,data ,alpha ,decode );case 4:return ColorAtCMYK (x ,y ,width ,data ,decode );default:return nil ,_ef .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0063o\u006c\u006f\u0072\u0020\u0063\u006f\u006dp\u006f\u006e\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0064",colorComponents );
};};func _cfag (_fdca _f .Image )(Image ,error ){if _acab ,_bbbb :=_fdca .(*Monochrome );_bbbb {return _acab ,nil ;};_ebff :=_fdca .Bounds ();var _adfg Gray ;switch _bdge :=_fdca .(type ){case Gray :_adfg =_bdge ;case NRGBA :_adfg =&Gray8 {ImageBase :NewImageBase (_ebff .Max .X ,_ebff .Max .Y ,8,1,nil ,nil ,nil )};
_dea (_adfg ,_bdge ,_ebff );case nrgba64 :_adfg =&Gray8 {ImageBase :NewImageBase (_ebff .Max .X ,_ebff .Max .Y ,8,1,nil ,nil ,nil )};_adde (_adfg ,_bdge ,_ebff );default:_cfca ,_acd :=GrayConverter .Convert (_fdca );if _acd !=nil {return nil ,_acd ;};_adfg =_cfca .(Gray );
};_ceca ,_fded :=NewImage (_ebff .Max .X ,_ebff .Max .Y ,1,1,nil ,nil ,nil );if _fded !=nil {return nil ,_fded ;};_fcd :=_ceca .(*Monochrome );_agee :=AutoThresholdTriangle (GrayHistogram (_adfg ));for _eee :=0;_eee < _ebff .Max .X ;_eee ++{for _ddbb :=0;
_ddbb < _ebff .Max .Y ;_ddbb ++{_ged :=_eec (_adfg .GrayAt (_eee ,_ddbb ),monochromeModel (_agee ));_fcd .SetGray (_eee ,_ddbb ,_ged );};};return _ceca ,nil ;};func ColorAtGray4BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_g .Gray ,error ){_cfdf :=y *bytesPerLine +x >>1;
if _cfdf >=len (data ){return _g .Gray {},_ef .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_dgbg :=data [_cfdf ]>>uint (4-(x &1)*4)&0xf;if len (decode )==2{_dgbg =uint8 (uint32 (LinearInterpolate (float64 (_dgbg ),0,15,decode [0],decode [1]))&0xf);};return _g .Gray {Y :_dgbg *17&0xff},nil ;};func ColorAtNRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_g .NRGBA ,error ){_beea :=y *width +x ;
_fffa :=3*_beea ;if _fffa +2>=len (data ){return _g .NRGBA {},_ef .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_bedf :=uint8 (0xff);if alpha !=nil &&len (alpha )> _beea {_bedf =alpha [_beea ];};_bfce ,_caee ,_bcef :=data [_fffa ],data [_fffa +1],data [_fffa +2];if len (decode )==6{_bfce =uint8 (uint32 (LinearInterpolate (float64 (_bfce ),0,255,decode [0],decode [1]))&0xff);
_caee =uint8 (uint32 (LinearInterpolate (float64 (_caee ),0,255,decode [2],decode [3]))&0xff);_bcef =uint8 (uint32 (LinearInterpolate (float64 (_bcef ),0,255,decode [4],decode [5]))&0xff);};return _g .NRGBA {R :_bfce ,G :_caee ,B :_bcef ,A :_bedf },nil ;
};func ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine int ,data []byte ,decode []float64 )(_g .Color ,error ){switch bitsPerColor {case 1:return ColorAtGray1BPC (x ,y ,bytesPerLine ,data ,decode );case 2:return ColorAtGray2BPC (x ,y ,bytesPerLine ,data ,decode );
case 4:return ColorAtGray4BPC (x ,y ,bytesPerLine ,data ,decode );case 8:return ColorAtGray8BPC (x ,y ,bytesPerLine ,data ,decode );case 16:return ColorAtGray16BPC (x ,y ,bytesPerLine ,data ,decode );default:return nil ,_ef .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0067\u0072\u0061\u0079\u0020\u0073c\u0061\u006c\u0065\u0020\u0062\u0069\u0074s\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020a\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );
};};func (_bgg *Monochrome )IsUnpadded ()bool {return (_bgg .Width *_bgg .Height )==len (_bgg .Data )};var (_gbcf =[]byte {0x00,0x80,0xC0,0xE0,0xF0,0xF8,0xFC,0xFE,0xFF};_befa =[]byte {0x00,0x01,0x03,0x07,0x0F,0x1F,0x3F,0x7F,0xFF};);func _eddd (_gfeg int ,_aeac int )int {if _gfeg < _aeac {return _gfeg ;
};return _aeac ;};func (_cfbd *NRGBA32 )Validate ()error {if len (_cfbd .Data )!=3*_cfbd .Width *_cfbd .Height {return _a .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func (_fdbd *Gray8 )ColorModel ()_g .Model {return _g .GrayModel };func _eafe (_fedbf *Monochrome ,_aaec ,_cdgg int ,_gfdb ,_aaega int ,_fddd RasterOperator ){var (_dgab int ;_ebgc byte ;_ffbe ,_eaca int ;_acdfc int ;);_cdga :=_gfdb >>3;
_fafg :=_gfdb &7;if _fafg > 0{_ebgc =_gbcf [_fafg ];};_dgab =_fedbf .BytesPerLine *_cdgg +(_aaec >>3);switch _fddd {case PixClr :for _ffbe =0;_ffbe < _aaega ;_ffbe ++{_acdfc =_dgab +_ffbe *_fedbf .BytesPerLine ;for _eaca =0;_eaca < _cdga ;_eaca ++{_fedbf .Data [_acdfc ]=0x0;
_acdfc ++;};if _fafg > 0{_fedbf .Data [_acdfc ]=_fage (_fedbf .Data [_acdfc ],0x0,_ebgc );};};case PixSet :for _ffbe =0;_ffbe < _aaega ;_ffbe ++{_acdfc =_dgab +_ffbe *_fedbf .BytesPerLine ;for _eaca =0;_eaca < _cdga ;_eaca ++{_fedbf .Data [_acdfc ]=0xff;
_acdfc ++;};if _fafg > 0{_fedbf .Data [_acdfc ]=_fage (_fedbf .Data [_acdfc ],0xff,_ebgc );};};case PixNotDst :for _ffbe =0;_ffbe < _aaega ;_ffbe ++{_acdfc =_dgab +_ffbe *_fedbf .BytesPerLine ;for _eaca =0;_eaca < _cdga ;_eaca ++{_fedbf .Data [_acdfc ]=^_fedbf .Data [_acdfc ];
_acdfc ++;};if _fafg > 0{_fedbf .Data [_acdfc ]=_fage (_fedbf .Data [_acdfc ],^_fedbf .Data [_acdfc ],_ebgc );};};};};func ColorAtCMYK (x ,y ,width int ,data []byte ,decode []float64 )(_g .CMYK ,error ){_gad :=4*(y *width +x );if _gad +3>=len (data ){return _g .CMYK {},_ef .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};C :=data [_gad ]&0xff;M :=data [_gad +1]&0xff;Y :=data [_gad +2]&0xff;K :=data [_gad +3]&0xff;if len (decode )==8{C =uint8 (uint32 (LinearInterpolate (float64 (C ),0,255,decode [0],decode [1]))&0xff);M =uint8 (uint32 (LinearInterpolate (float64 (M ),0,255,decode [2],decode [3]))&0xff);
Y =uint8 (uint32 (LinearInterpolate (float64 (Y ),0,255,decode [4],decode [5]))&0xff);K =uint8 (uint32 (LinearInterpolate (float64 (K ),0,255,decode [6],decode [7]))&0xff);};return _g .CMYK {C :C ,M :M ,Y :Y ,K :K },nil ;};func _bgfa (_afcg RGBA ,_edbc NRGBA ,_acde _f .Rectangle ){for _cbdag :=0;
_cbdag < _acde .Max .X ;_cbdag ++{for _bcgf :=0;_bcgf < _acde .Max .Y ;_bcgf ++{_geca :=_afcg .RGBAAt (_cbdag ,_bcgf );_edbc .SetNRGBA (_cbdag ,_bcgf ,_dda (_geca ));};};};func (_gcea *NRGBA16 )SetNRGBA (x ,y int ,c _g .NRGBA ){_ddfd :=y *_gcea .BytesPerLine +x *3/2;
if _ddfd +1>=len (_gcea .Data ){return ;};c =_gdcb (c );_gcea .setNRGBA (x ,y ,_ddfd ,c );};func (_dbfc *Gray16 )Set (x ,y int ,c _g .Color ){_gcdb :=(y *_dbfc .BytesPerLine /2+x )*2;if _gcdb +1>=len (_dbfc .Data ){return ;};_cdbbc :=_g .Gray16Model .Convert (c ).(_g .Gray16 );
_dbfc .Data [_gcdb ],_dbfc .Data [_gcdb +1]=uint8 (_cdbbc .Y >>8),uint8 (_cdbbc .Y &0xff);};var _ _f .Image =&NRGBA16 {};func _dbfcfc (_dddcg uint8 )bool {if _dddcg ==0||_dddcg ==255{return true ;};return false ;};func _ggd (_ggfc _g .RGBA )_g .CMYK {_ecbb ,_gdde ,_bbc ,_efd :=_g .RGBToCMYK (_ggfc .R ,_ggfc .G ,_ggfc .B );
return _g .CMYK {C :_ecbb ,M :_gdde ,Y :_bbc ,K :_efd };};func _bdfb (_babeb _f .Image )(Image ,error ){if _fbfe ,_cdcg :=_babeb .(*NRGBA16 );_cdcg {return _fbfe .Copy (),nil ;};_dgdc :=_babeb .Bounds ();_febd ,_egec :=NewImage (_dgdc .Max .X ,_dgdc .Max .Y ,4,3,nil ,nil ,nil );
if _egec !=nil {return nil ,_egec ;};_dgge (_babeb ,_febd ,_dgdc );return _febd ,nil ;};func _bgc (_aace ,_eegc *Monochrome ,_ffab []byte ,_dac int )(_gfed error ){var (_cfd ,_fdge ,_eaa ,_gdb ,_fabc ,_eac ,_fda ,_efe int ;_efa ,_bga ,_ccgd ,_fec uint32 ;
_babb ,_ggba byte ;_edg uint16 ;);_fdgg :=make ([]byte ,4);_dbb :=make ([]byte ,4);for _eaa =0;_eaa < _aace .Height -1;_eaa ,_gdb =_eaa +2,_gdb +1{_cfd =_eaa *_aace .BytesPerLine ;_fdge =_gdb *_eegc .BytesPerLine ;for _fabc ,_eac =0,0;_fabc < _dac ;_fabc ,_eac =_fabc +4,_eac +1{for _fda =0;
_fda < 4;_fda ++{_efe =_cfd +_fabc +_fda ;if _efe <=len (_aace .Data )-1&&_efe < _cfd +_aace .BytesPerLine {_fdgg [_fda ]=_aace .Data [_efe ];}else {_fdgg [_fda ]=0x00;};_efe =_cfd +_aace .BytesPerLine +_fabc +_fda ;if _efe <=len (_aace .Data )-1&&_efe < _cfd +(2*_aace .BytesPerLine ){_dbb [_fda ]=_aace .Data [_efe ];
}else {_dbb [_fda ]=0x00;};};_efa =_gg .BigEndian .Uint32 (_fdgg );_bga =_gg .BigEndian .Uint32 (_dbb );_ccgd =_efa &_bga ;_ccgd |=_ccgd <<1;_fec =_efa |_bga ;_fec &=_fec <<1;_bga =_ccgd |_fec ;_bga &=0xaaaaaaaa;_efa =_bga |(_bga <<7);_babb =byte (_efa >>24);
_ggba =byte ((_efa >>8)&0xff);_efe =_fdge +_eac ;if _efe +1==len (_eegc .Data )-1||_efe +1>=_fdge +_eegc .BytesPerLine {if _gfed =_eegc .setByte (_efe ,_ffab [_babb ]);_gfed !=nil {return _ef .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_efe );
};}else {_edg =(uint16 (_ffab [_babb ])<<8)|uint16 (_ffab [_ggba ]);if _gfed =_eegc .setTwoBytes (_efe ,_edg );_gfed !=nil {return _ef .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_efe );
};_eac ++;};};};return nil ;};func _fcae (_gab _f .Image )(Image ,error ){if _egdf ,_dcec :=_gab .(*Gray2 );_dcec {return _egdf .Copy (),nil ;};_fagf :=_gab .Bounds ();_bdfc ,_cea :=NewImage (_fagf .Max .X ,_fagf .Max .Y ,2,1,nil ,nil ,nil );if _cea !=nil {return nil ,_cea ;
};_acfc (_gab ,_bdfc ,_fagf );return _bdfc ,nil ;};func (_dff *ImageBase )setEightPartlyBytes (_ccf ,_beaba int ,_bdfa uint64 )(_cdcd error ){var (_effag byte ;_cgaf int ;);for _eefc :=1;_eefc <=_beaba ;_eefc ++{_cgaf =64-_eefc *8;_effag =byte (_bdfa >>uint (_cgaf )&0xff);
if _cdcd =_dff .setByte (_ccf +_eefc -1,_effag );_cdcd !=nil {return _cdcd ;};};_aeaa :=_dff .BytesPerLine *8-_dff .Width ;if _aeaa ==0{return nil ;};_cgaf -=8;_effag =byte (_bdfa >>uint (_cgaf )&0xff)<<uint (_aeaa );if _cdcd =_dff .setByte (_ccf +_beaba ,_effag );
_cdcd !=nil {return _cdcd ;};return nil ;};func _ded (_dddb _g .Gray )_g .RGBA {return _g .RGBA {R :_dddb .Y ,G :_dddb .Y ,B :_dddb .Y ,A :0xff}};func (_bdff *Gray4 )Histogram ()(_edcc [256]int ){for _fbec :=0;_fbec < _bdff .Width ;_fbec ++{for _eecb :=0;
_eecb < _bdff .Height ;_eecb ++{_edcc [_bdff .GrayAt (_fbec ,_eecb ).Y ]++;};};return _edcc ;};func _eeff (_bebb _g .Gray )_g .Gray {_bebb .Y >>=4;_bebb .Y |=_bebb .Y <<4;return _bebb };func ColorAtRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_g .RGBA ,error ){_agfde :=y *width +x ;
_dfad :=3*_agfde ;if _dfad +2>=len (data ){return _g .RGBA {},_ef .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_fffc :=uint8 (0xff);if alpha !=nil &&len (alpha )> _agfde {_fffc =alpha [_agfde ];};_bcbc ,_gdfc ,_aacg :=data [_dfad ],data [_dfad +1],data [_dfad +2];if len (decode )==6{_bcbc =uint8 (uint32 (LinearInterpolate (float64 (_bcbc ),0,255,decode [0],decode [1]))&0xff);
_gdfc =uint8 (uint32 (LinearInterpolate (float64 (_gdfc ),0,255,decode [2],decode [3]))&0xff);_aacg =uint8 (uint32 (LinearInterpolate (float64 (_aacg ),0,255,decode [4],decode [5]))&0xff);};return _g .RGBA {R :_bcbc ,G :_gdfc ,B :_aacg ,A :_fffc },nil ;
};func (_gbd *Gray16 )At (x ,y int )_g .Color {_geb ,_ :=_gbd .ColorAt (x ,y );return _geb };func BytesPerLine (width ,bitsPerComponent ,colorComponents int )int {return ((width *bitsPerComponent )*colorComponents +7)>>3;};func _dea (_gdbc Gray ,_fdcd NRGBA ,_bbg _f .Rectangle ){for _dag :=0;
_dag < _bbg .Max .X ;_dag ++{for _bce :=0;_bce < _bbg .Max .Y ;_bce ++{_bac :=_bca (_fdcd .NRGBAAt (_dag ,_bce ));_gdbc .SetGray (_dag ,_bce ,_bac );};};};type CMYK interface{CMYKAt (_bcb ,_def int )_g .CMYK ;SetCMYK (_cac ,_adf int ,_eeaa _g .CMYK );};
func NextPowerOf2 (n uint )uint {if IsPowerOf2 (n ){return n ;};return 1<<(_ebfg (n )+1);};func _de (_ddg ,_gcf *Monochrome )(_ceb error ){_dbf :=_gcf .BytesPerLine ;_cfa :=_ddg .BytesPerLine ;var _cdb ,_gfd ,_acf ,_bdc ,_gef int ;for _acf =0;_acf < _gcf .Height ;
_acf ++{_cdb =_acf *_dbf ;_gfd =8*_acf *_cfa ;for _bdc =0;_bdc < _dbf ;_bdc ++{if _ceb =_ddg .setEightBytes (_gfd +_bdc *8,_da [_gcf .Data [_cdb +_bdc ]]);_ceb !=nil {return _ceb ;};};for _gef =1;_gef < 8;_gef ++{for _bdc =0;_bdc < _cfa ;_bdc ++{if _ceb =_ddg .setByte (_gfd +_gef *_cfa +_bdc ,_ddg .Data [_gfd +_bdc ]);
_ceb !=nil {return _ceb ;};};};};return nil ;};func (_dbab *Monochrome )Histogram ()(_gdg [256]int ){for _ ,_eece :=range _dbab .Data {_gdg [0xff]+=int (_gfbcc [_dbab .Data [_eece ]]);};return _gdg ;};func (_bacaa *NRGBA32 )NRGBAAt (x ,y int )_g .NRGBA {_aaaa ,_ :=ColorAtNRGBA32 (x ,y ,_bacaa .Width ,_bacaa .Data ,_bacaa .Alpha ,_bacaa .Decode );
return _aaaa ;};type monochromeThresholdConverter struct{Threshold uint8 ;};type RGBA interface{RGBAAt (_badg ,_eddb int )_g .RGBA ;SetRGBA (_gec ,_gedad int ,_bcbbb _g .RGBA );};func NewImageBase (width int ,height int ,bitsPerComponent int ,colorComponents int ,data []byte ,alpha []byte ,decode []float64 )ImageBase {_geg :=ImageBase {Width :width ,Height :height ,BitsPerComponent :bitsPerComponent ,ColorComponents :colorComponents ,Data :data ,Alpha :alpha ,Decode :decode ,BytesPerLine :BytesPerLine (width ,bitsPerComponent ,colorComponents )};
if data ==nil {_geg .Data =make ([]byte ,height *_geg .BytesPerLine );};return _geg ;};var _ Gray =&Gray2 {};func _edfg (_agfe _g .Gray )_g .CMYK {return _g .CMYK {K :0xff-_agfe .Y }};func (_acaab *Monochrome )Validate ()error {if len (_acaab .Data )!=_acaab .Height *_acaab .BytesPerLine {return ErrInvalidImage ;
};return nil ;};type monochromeModel uint8 ;type SMasker interface{HasAlpha ()bool ;GetAlpha ()[]byte ;MakeAlpha ();};func (_feg *Gray2 )Histogram ()(_degf [256]int ){for _cgfb :=0;_cgfb < _feg .Width ;_cgfb ++{for _fcaf :=0;_fcaf < _feg .Height ;_fcaf ++{_degf [_feg .GrayAt (_cgfb ,_fcaf ).Y ]++;
};};return _degf ;};func (_bgee *Monochrome )AddPadding ()(_debc error ){if _fce :=((_bgee .Width *_bgee .Height )+7)>>3;len (_bgee .Data )< _fce {return _ef .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064a\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002e\u0020\u0054\u0068\u0065\u0020\u0064\u0061t\u0061\u0020s\u0068\u006fu\u006c\u0064\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0020\u0061\u0074 l\u0065\u0061\u0073\u0074\u003a\u0020\u0027\u0025\u0064'\u0020\u0062\u0079\u0074\u0065\u0073",len (_bgee .Data ),_fce );
};_eeacd :=_bgee .Width %8;if _eeacd ==0{return nil ;};_agd :=_bgee .Width /8;_dgc :=_b .NewReader (_bgee .Data );_dfd :=make ([]byte ,_bgee .Height *_bgee .BytesPerLine );_bdae :=_b .NewWriterMSB (_dfd );_fabd :=make ([]byte ,_agd );var (_aef int ;_bfgf uint64 ;
);for _aef =0;_aef < _bgee .Height ;_aef ++{if _ ,_debc =_dgc .Read (_fabd );_debc !=nil {return _debc ;};if _ ,_debc =_bdae .Write (_fabd );_debc !=nil {return _debc ;};if _bfgf ,_debc =_dgc .ReadBits (byte (_eeacd ));_debc !=nil {return _debc ;};if _debc =_bdae .WriteByte (byte (_bfgf )<<uint (8-_eeacd ));
_debc !=nil {return _debc ;};};_bgee .Data =_bdae .Data ();return nil ;};func _edae (_fac _g .NYCbCrA )_g .RGBA {_ecge ,_ade ,_bgag ,_eag :=_eead (_fac ).RGBA ();return _g .RGBA {R :uint8 (_ecge >>8),G :uint8 (_ade >>8),B :uint8 (_bgag >>8),A :uint8 (_eag >>8)};
};func _agg (_cbda int )[]uint {var _gfb []uint ;_bec :=_cbda ;_dcfg :=_bec /8;if _dcfg !=0{for _cfg :=0;_cfg < _dcfg ;_cfg ++{_gfb =append (_gfb ,8);};_cae :=_bec %8;_bec =0;if _cae !=0{_bec =_cae ;};};_cbb :=_bec /4;if _cbb !=0{for _bbf :=0;_bbf < _cbb ;
_bbf ++{_gfb =append (_gfb ,4);};_caf :=_bec %4;_bec =0;if _caf !=0{_bec =_caf ;};};_eaf :=_bec /2;if _eaf !=0{for _aed :=0;_aed < _eaf ;_aed ++{_gfb =append (_gfb ,2);};};return _gfb ;};func (_fagce *Gray4 )setGray (_fcfb int ,_ccca int ,_gbc _g .Gray ){_bfe :=_ccca *_fagce .BytesPerLine ;
_abdd :=_bfe +(_fcfb >>1);if _abdd >=len (_fagce .Data ){return ;};_caae :=_gbc .Y >>4;_fagce .Data [_abdd ]=(_fagce .Data [_abdd ]&(^(0xf0>>uint (4*(_fcfb &1)))))|(_caae <<uint (4-4*(_fcfb &1)));};func ImgToGray (i _f .Image )*_f .Gray {if _cfeb ,_fgcfd :=i .(*_f .Gray );
_fgcfd {return _cfeb ;};_aeadc :=i .Bounds ();_dcbf :=_f .NewGray (_aeadc );for _fcce :=0;_fcce < _aeadc .Max .X ;_fcce ++{for _abad :=0;_abad < _aeadc .Max .Y ;_abad ++{_eaaef :=i .At (_fcce ,_abad );_dcbf .Set (_fcce ,_abad ,_eaaef );};};return _dcbf ;
};func _cga (_gdcg _f .Image )(Image ,error ){if _dfdff ,_fbce :=_gdcg .(*Gray4 );_fbce {return _dfdff .Copy (),nil ;};_ggga :=_gdcg .Bounds ();_fed ,_ceg :=NewImage (_ggga .Max .X ,_ggga .Max .Y ,4,1,nil ,nil ,nil );if _ceg !=nil {return nil ,_ceg ;};
_acfc (_gdcg ,_fed ,_ggga );return _fed ,nil ;};func (_effg *Gray2 )Copy ()Image {return &Gray2 {ImageBase :_effg .copy ()}};func _dgge (_bfgb _f .Image ,_dead Image ,_abec _f .Rectangle ){if _fgedf ,_gfaad :=_bfgb .(SMasker );_gfaad &&_fgedf .HasAlpha (){_dead .(SMasker ).MakeAlpha ();
};switch _cagf :=_bfgb .(type ){case Gray :_aage (_cagf ,_dead .(NRGBA ),_abec );case NRGBA :_gfde (_cagf ,_dead .(NRGBA ),_abec );case *_f .NYCbCrA :_eebca (_cagf ,_dead .(NRGBA ),_abec );case CMYK :_geec (_cagf ,_dead .(NRGBA ),_abec );case RGBA :_bgfa (_cagf ,_dead .(NRGBA ),_abec );
case nrgba64 :_adgd (_cagf ,_dead .(NRGBA ),_abec );default:_fbcb (_bfgb ,_dead ,_abec );};};func (_cffd *NRGBA64 )At (x ,y int )_g .Color {_ecaa ,_ :=_cffd .ColorAt (x ,y );return _ecaa };func _eebca (_gbbgd *_f .NYCbCrA ,_aabc NRGBA ,_aeddd _f .Rectangle ){for _geef :=0;
_geef < _aeddd .Max .X ;_geef ++{for _acgg :=0;_acgg < _aeddd .Max .Y ;_acgg ++{_fgcc :=_gbbgd .NYCbCrAAt (_geef ,_acgg );_aabc .SetNRGBA (_geef ,_acgg ,_eead (_fgcc ));};};};func init (){_gcgg ()};func _adcb (_cdab ,_gbfd Gray ,_aefb _f .Rectangle ){for _gaae :=0;
_gaae < _aefb .Max .X ;_gaae ++{for _cdfg :=0;_cdfg < _aefb .Max .Y ;_cdfg ++{_gbfd .SetGray (_gaae ,_cdfg ,_cdab .GrayAt (_gaae ,_cdfg ));};};};func ColorAtGray2BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_g .Gray ,error ){_abfc :=y *bytesPerLine +x >>2;
if _abfc >=len (data ){return _g .Gray {},_ef .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_efaa :=data [_abfc ]>>uint (6-(x &3)*2)&3;if len (decode )==2{_efaa =uint8 (uint32 (LinearInterpolate (float64 (_efaa ),0,3.0,decode [0],decode [1]))&3);};return _g .Gray {Y :_efaa *85},nil ;};var _ RGBA =&RGBA32 {};func _fgedfa (_fffdb *_f .Gray ,_gfeb uint8 )*_f .Gray {_cfeba :=_fffdb .Bounds ();
_gcbd :=_f .NewGray (_cfeba );for _fbdga :=0;_fbdga < _cfeba .Dx ();_fbdga ++{for _bfab :=0;_bfab < _cfeba .Dy ();_bfab ++{_cfdd :=_fffdb .GrayAt (_fbdga ,_bfab );_gcbd .SetGray (_fbdga ,_bfab ,_g .Gray {Y :_aeed (_cfdd .Y ,_gfeb )});};};return _gcbd ;
};func (_dfce *Gray16 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtGray16BPC (x ,y ,_dfce .BytesPerLine ,_dfce .Data ,_dfce .Decode );};func (_afgd *ImageBase )getByte (_aaegd int )(byte ,error ){if _aaegd > len (_afgd .Data )-1||_aaegd < 0{return 0,_ef .Errorf ("\u0069\u006e\u0064\u0065x:\u0020\u0025\u0064\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006eg\u0065",_aaegd );
};return _afgd .Data [_aaegd ],nil ;};func (_abfa *Monochrome )Set (x ,y int ,c _g .Color ){_bgce :=y *_abfa .BytesPerLine +x >>3;if _bgce > len (_abfa .Data )-1{return ;};_dbd :=_abfa .ColorModel ().Convert (c ).(_g .Gray );_abfa .setGray (x ,_dbd ,_bgce );
};func (_fbg *Gray8 )Set (x ,y int ,c _g .Color ){_eddf :=y *_fbg .BytesPerLine +x ;if _eddf > len (_fbg .Data )-1{return ;};_adb :=_g .GrayModel .Convert (c );_fbg .Data [_eddf ]=_adb .(_g .Gray ).Y ;};type Gray interface{GrayAt (_dge ,_bed int )_g .Gray ;
SetGray (_acbfb ,_gbe int ,_bfa _g .Gray );};func _aae (_afg ,_faed CMYK ,_gdc _f .Rectangle ){for _fef :=0;_fef < _gdc .Max .X ;_fef ++{for _gggc :=0;_gggc < _gdc .Max .Y ;_gggc ++{_faed .SetCMYK (_fef ,_gggc ,_afg .CMYKAt (_fef ,_gggc ));};};};func (_cdafd *NRGBA16 )setNRGBA (_cef ,_edeca ,_adg int ,_dede _g .NRGBA ){if _cef *3%2==0{_cdafd .Data [_adg ]=(_dede .R >>4)<<4|(_dede .G >>4);
_cdafd .Data [_adg +1]=(_dede .B >>4)<<4|(_cdafd .Data [_adg +1]&0xf);}else {_cdafd .Data [_adg ]=(_cdafd .Data [_adg ]&0xf0)|(_dede .R >>4);_cdafd .Data [_adg +1]=(_dede .G >>4)<<4|(_dede .B >>4);};if _cdafd .Alpha !=nil {_badb :=_edeca *BytesPerLine (_cdafd .Width ,4,1);
if _badb < len (_cdafd .Alpha ){if _cef %2==0{_cdafd .Alpha [_badb ]=(_dede .A >>uint (4))<<uint (4)|(_cdafd .Alpha [_adg ]&0xf);}else {_cdafd .Alpha [_badb ]=(_cdafd .Alpha [_badb ]&0xf0)|(_dede .A >>uint (4));};};};};type ColorConverter interface{Convert (_deg _f .Image )(Image ,error );
};func (_cbdg *NRGBA16 )Copy ()Image {return &NRGBA16 {ImageBase :_cbdg .copy ()}};const (_fdcgf shift =iota ;_gaffg ;);func (_acaag *CMYK32 )Copy ()Image {return &CMYK32 {ImageBase :_acaag .copy ()}};func (_ggfcd *ImageBase )setFourBytes (_cfb int ,_bdb uint32 )error {if _cfb +3> len (_ggfcd .Data )-1{return _ef .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006fu\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065",_cfb );
};_ggfcd .Data [_cfb ]=byte ((_bdb &0xff000000)>>24);_ggfcd .Data [_cfb +1]=byte ((_bdb &0xff0000)>>16);_ggfcd .Data [_cfb +2]=byte ((_bdb &0xff00)>>8);_ggfcd .Data [_cfb +3]=byte (_bdb &0xff);return nil ;};var _ Image =&CMYK32 {};func (_afbed *NRGBA16 )NRGBAAt (x ,y int )_g .NRGBA {_fcdc ,_ :=ColorAtNRGBA16 (x ,y ,_afbed .Width ,_afbed .BytesPerLine ,_afbed .Data ,_afbed .Alpha ,_afbed .Decode );
return _fcdc ;};func _fa (_dg *Monochrome ,_db int ,_bd []uint )(*Monochrome ,error ){_af :=_db *_dg .Width ;_cc :=_db *_dg .Height ;_ba :=_bab (_af ,_cc );for _ca ,_ga :=range _bd {var _dba error ;switch _ga {case 2:_dba =_ae (_ba ,_dg );case 4:_dba =_ac (_ba ,_dg );
case 8:_dba =_de (_ba ,_dg );};if _dba !=nil {return nil ,_dba ;};if _ca !=len (_bd )-1{_dg =_ba .copy ();};};return _ba ,nil ;};func GetConverter (bitsPerComponent ,colorComponents int )(ColorConverter ,error ){switch colorComponents {case 1:switch bitsPerComponent {case 1:return MonochromeConverter ,nil ;
case 2:return Gray2Converter ,nil ;case 4:return Gray4Converter ,nil ;case 8:return GrayConverter ,nil ;case 16:return Gray16Converter ,nil ;};case 3:switch bitsPerComponent {case 4:return NRGBA16Converter ,nil ;case 8:return NRGBAConverter ,nil ;case 16:return NRGBA64Converter ,nil ;
};case 4:return CMYKConverter ,nil ;};return nil ,_ef .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0043o\u006e\u0076\u0065\u0072\u0074\u0065\u0072\u0020\u0070\u0061\u0072\u0061\u006d\u0065t\u0065\u0072\u0073\u002e\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003a\u0020\u0025\u0064\u002c\u0020\u0043\u006f\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006et\u0073\u003a \u0025\u0064",bitsPerComponent ,colorComponents );
};func (_abab *RGBA32 )Base ()*ImageBase {return &_abab .ImageBase };func (_gdcf *Gray16 )Copy ()Image {return &Gray16 {ImageBase :_gdcf .copy ()}};var _ Image =&Gray4 {};func _fafge (_ceec _f .Image ,_dcgc int )(_f .Rectangle ,bool ,[]byte ){_adef :=_ceec .Bounds ();
var (_ffae bool ;_cebf []byte ;);switch _deag :=_ceec .(type ){case SMasker :_ffae =_deag .HasAlpha ();case NRGBA ,RGBA ,*_f .RGBA64 ,nrgba64 ,*_f .NYCbCrA :_cebf =make ([]byte ,_adef .Max .X *_adef .Max .Y *_dcgc );case *_f .Paletted :var _cebd bool ;
for _ ,_effc :=range _deag .Palette {_gfdbf ,_gcga ,_bdbe ,_bgf :=_effc .RGBA ();if _gfdbf ==0&&_gcga ==0&&_bdbe ==0&&_bgf !=0{_cebd =true ;break ;};};if _cebd {_cebf =make ([]byte ,_adef .Max .X *_adef .Max .Y *_dcgc );};};return _adef ,_ffae ,_cebf ;
};var _ Gray =&Gray8 {};func _eead (_cgb _g .NYCbCrA )_g .NRGBA {_bafb :=int32 (_cgb .Y )*0x10101;_ggc :=int32 (_cgb .Cb )-128;_cbe :=int32 (_cgb .Cr )-128;_cec :=_bafb +91881*_cbe ;if uint32 (_cec )&0xff000000==0{_cec >>=8;}else {_cec =^(_cec >>31)&0xffff;
};_aade :=_bafb -22554*_ggc -46802*_cbe ;if uint32 (_aade )&0xff000000==0{_aade >>=8;}else {_aade =^(_aade >>31)&0xffff;};_dad :=_bafb +116130*_ggc ;if uint32 (_dad )&0xff000000==0{_dad >>=8;}else {_dad =^(_dad >>31)&0xffff;};return _g .NRGBA {R :uint8 (_cec >>8),G :uint8 (_aade >>8),B :uint8 (_dad >>8),A :_cgb .A };
};func _ae (_cb ,_edc *Monochrome )(_fb error ){_be :=_edc .BytesPerLine ;_ab :=_cb .BytesPerLine ;var (_fe byte ;_ffa uint16 ;_ec ,_gd ,_gc ,_bf ,_cd int ;);for _gc =0;_gc < _edc .Height ;_gc ++{_ec =_gc *_be ;_gd =2*_gc *_ab ;for _bf =0;_bf < _be ;_bf ++{_fe =_edc .Data [_ec +_bf ];
_ffa =_gbb [_fe ];_cd =_gd +_bf *2;if _cb .BytesPerLine !=_edc .BytesPerLine *2&&(_bf +1)*2> _cb .BytesPerLine {_fb =_cb .setByte (_cd ,byte (_ffa >>8));}else {_fb =_cb .setTwoBytes (_cd ,_ffa );};if _fb !=nil {return _fb ;};};for _bf =0;_bf < _ab ;_bf ++{_cd =_gd +_ab +_bf ;
_fe =_cb .Data [_gd +_bf ];if _fb =_cb .setByte (_cd ,_fe );_fb !=nil {return _fb ;};};};return nil ;};func (_efee colorConverter )Convert (src _f .Image )(Image ,error ){return _efee ._daad (src )};func ColorAtGray8BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_g .Gray ,error ){_deae :=y *bytesPerLine +x ;
if _deae >=len (data ){return _g .Gray {},_ef .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_bdab :=data [_deae ];if len (decode )==2{_bdab =uint8 (uint32 (LinearInterpolate (float64 (_bdab ),0,255,decode [0],decode [1]))&0xff);};return _g .Gray {Y :_bdab },nil ;};func _bbd (_dcc *Monochrome ,_gag ,_dcf int )(*Monochrome ,error ){if _dcc ==nil {return nil ,_a .New ("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064");
};if _gag <=0||_dcf <=0{return nil ,_a .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0073\u0063\u0061l\u0065\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020<\u003d\u0020\u0030");};if _gag ==_dcf {if _gag ==1{return _dcc .copy (),nil ;};
if _gag ==2||_gag ==4||_gag ==8{_ffd ,_afa :=_edf (_dcc ,_gag );if _afa !=nil {return nil ,_afa ;};return _ffd ,nil ;};};_cbd :=_gag *_dcc .Width ;_aca :=_dcf *_dcc .Height ;_bdf :=_bab (_cbd ,_aca );_ag :=_bdf .BytesPerLine ;var (_gaf ,_edb ,_fad ,_bda ,_acb int ;
_ee byte ;_ddgd error ;);for _edb =0;_edb < _dcc .Height ;_edb ++{_gaf =_dcf *_edb *_ag ;for _fad =0;_fad < _dcc .Width ;_fad ++{if _deb :=_dcc .getBitAt (_fad ,_edb );_deb {_acb =_gag *_fad ;for _bda =0;_bda < _gag ;_bda ++{_bdf .setIndexedBit (_gaf *8+_acb +_bda );
};};};for _bda =1;_bda < _dcf ;_bda ++{_bfc :=_gaf +_bda *_ag ;for _cg :=0;_cg < _ag ;_cg ++{if _ee ,_ddgd =_bdf .getByte (_gaf +_cg );_ddgd !=nil {return nil ,_ddgd ;};if _ddgd =_bdf .setByte (_bfc +_cg ,_ee );_ddgd !=nil {return nil ,_ddgd ;};};};};return _bdf ,nil ;
};func (_edcf *NRGBA64 )Bounds ()_f .Rectangle {return _f .Rectangle {Max :_f .Point {X :_edcf .Width ,Y :_edcf .Height }};};func _bgab (_cfgda Gray ,_fgdf RGBA ,_cded _f .Rectangle ){for _bdcf :=0;_bdcf < _cded .Max .X ;_bdcf ++{for _faec :=0;_faec < _cded .Max .Y ;
_faec ++{_fbgg :=_cfgda .GrayAt (_bdcf ,_faec );_fgdf .SetRGBA (_bdcf ,_faec ,_ded (_fbgg ));};};};func (_cfdb *RGBA32 )Set (x ,y int ,c _g .Color ){_cecb :=y *_cfdb .Width +x ;_dcdb :=3*_cecb ;if _dcdb +2>=len (_cfdb .Data ){return ;};_edcg :=_g .RGBAModel .Convert (c ).(_g .RGBA );
_cfdb .setRGBA (_cecb ,_edcg );};func _aeb (_badd _g .NRGBA64 )_g .Gray {var _eab _g .NRGBA64 ;if _badd ==_eab {return _g .Gray {Y :0xff};};_gdf ,_fgcg ,_fbde ,_ :=_badd .RGBA ();_ecff :=(19595*_gdf +38470*_fgcg +7471*_fbde +1<<15)>>24;return _g .Gray {Y :uint8 (_ecff )};
};func (_daf *Gray16 )Validate ()error {if len (_daf .Data )!=_daf .Height *_daf .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_gbbd *Gray4 )ColorModel ()_g .Model {return Gray4Model };func (_gddcf *NRGBA16 )ColorModel ()_g .Model {return NRGBA16Model };
func (_baab *ImageBase )MakeAlpha (){_baab .newAlpha ()};type colorConverter struct{_daad func (_fdb _f .Image )(Image ,error );};func _gbfdg (_effa CMYK ,_eebc Gray ,_dbfa _f .Rectangle ){for _dfbg :=0;_dfbg < _dbfa .Max .X ;_dfbg ++{for _aadf :=0;_aadf < _dbfa .Max .Y ;
_aadf ++{_ebdc :=_gddc (_effa .CMYKAt (_dfbg ,_aadf ));_eebc .SetGray (_dfbg ,_aadf ,_ebdc );};};};func (_eefa *Gray16 )ColorModel ()_g .Model {return _g .Gray16Model };func _ccd (_fgce ,_cge int ,_fab []byte )*Monochrome {_acbb :=_bab (_fgce ,_cge );_acbb .Data =_fab ;
return _acbb ;};func (_eagaa *Gray2 )GrayAt (x ,y int )_g .Gray {_ddfa ,_ :=ColorAtGray2BPC (x ,y ,_eagaa .BytesPerLine ,_eagaa .Data ,_eagaa .Decode );return _ddfa ;};func (_cgd *Gray8 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtGray8BPC (x ,y ,_cgd .BytesPerLine ,_cgd .Data ,_cgd .Decode );
};type nrgba64 interface{NRGBA64At (_faeb ,_fbcc int )_g .NRGBA64 ;SetNRGBA64 (_dgf ,_cbgb int ,_fgcf _g .NRGBA64 );};func _febb (_bcgga []byte ,_ebgg Image )error {_ebgba :=true ;for _adcg :=0;_adcg < len (_bcgga );_adcg ++{if _bcgga [_adcg ]!=0xff{_ebgba =false ;
break ;};};if _ebgba {switch _aefbb :=_ebgg .(type ){case *NRGBA32 :_aefbb .Alpha =nil ;case *NRGBA64 :_aefbb .Alpha =nil ;default:return _ef .Errorf ("i\u006ete\u0072n\u0061l\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020i\u006d\u0061\u0067\u0065\u0020s\u0068\u006f\u0075l\u0064\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0074\u0079\u0070e\u0020\u002a\u004eRGB\u0041\u0033\u0032\u0020\u006f\u0072 \u002a\u004e\u0052\u0047\u0042\u0041\u0036\u0034\u0020\u0062\u0075\u0074 \u0069s\u003a\u0020\u0025\u0054",_ebgg );
};};return nil ;};type ImageBase struct{Width ,Height int ;BitsPerComponent ,ColorComponents int ;Data ,Alpha []byte ;Decode []float64 ;BytesPerLine int ;};func _fbdg (_fbf _g .NRGBA )_g .Gray {_ebcc ,_dcea ,_cdf ,_ :=_fbf .RGBA ();_dgb :=(19595*_ebcc +38470*_dcea +7471*_cdf +1<<15)>>24;
return _g .Gray {Y :uint8 (_dgb )};};func (_fgd *NRGBA32 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtNRGBA32 (x ,y ,_fgd .Width ,_fgd .Data ,_fgd .Alpha ,_fgd .Decode );};func (_beed *ImageBase )setTwoBytes (_bggbd int ,_edad uint16 )error {if _bggbd +1> len (_beed .Data )-1{return _a .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_beed .Data [_bggbd ]=byte ((_edad &0xff00)>>8);_beed .Data [_bggbd +1]=byte (_edad &0xff);return nil ;};func (_ggfa *Gray16 )Bounds ()_f .Rectangle {return _f .Rectangle {Max :_f .Point {X :_ggfa .Width ,Y :_ggfa .Height }};};func (_dddg *ImageBase )setByte (_efaad int ,_cdc byte )error {if _efaad > len (_dddg .Data )-1{return _a .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_dddg .Data [_efaad ]=_cdc ;return nil ;};var _ Image =&NRGBA64 {};func _cgff (_ebef _g .Color )_g .Color {_eafb :=_g .GrayModel .Convert (_ebef ).(_g .Gray );return _fbb (_eafb );};func RasterOperation (dest *Monochrome ,dx ,dy ,dw ,dh int ,op RasterOperator ,src *Monochrome ,sx ,sy int )error {return _efg (dest ,dx ,dy ,dw ,dh ,op ,src ,sx ,sy );
};func _dbfcf (_ceba _f .Image )(Image ,error ){if _fcdd ,_cfbc :=_ceba .(*NRGBA32 );_cfbc {return _fcdd .Copy (),nil ;};_abcfe ,_ecdg ,_degc :=_fafge (_ceba ,1);_eede ,_ddfde :=NewImage (_abcfe .Max .X ,_abcfe .Max .Y ,8,3,nil ,_degc ,nil );if _ddfde !=nil {return nil ,_ddfde ;
};_dgge (_ceba ,_eede ,_abcfe );if len (_degc )!=0&&!_ecdg {if _fdcf :=_febb (_degc ,_eede );_fdcf !=nil {return nil ,_fdcf ;};};return _eede ,nil ;};const (PixSrc RasterOperator =0xc;PixDst RasterOperator =0xa;PixNotSrc RasterOperator =0x3;PixNotDst RasterOperator =0x5;
PixClr RasterOperator =0x0;PixSet RasterOperator =0xf;PixSrcOrDst RasterOperator =0xe;PixSrcAndDst RasterOperator =0x8;PixSrcXorDst RasterOperator =0x6;PixNotSrcOrDst RasterOperator =0xb;PixNotSrcAndDst RasterOperator =0x2;PixSrcOrNotDst RasterOperator =0xd;
PixSrcAndNotDst RasterOperator =0x4;PixNotPixSrcOrDst RasterOperator =0x1;PixNotPixSrcAndDst RasterOperator =0x7;PixNotPixSrcXorDst RasterOperator =0x9;PixPaint =PixSrcOrDst ;PixSubtract =PixNotSrcAndDst ;PixMask =PixSrcAndDst ;);func (_gaaaf *ImageBase )HasAlpha ()bool {if _gaaaf .Alpha ==nil {return false ;
};for _dgeg :=range _gaaaf .Alpha {if _gaaaf .Alpha [_dgeg ]!=0xff{return true ;};};return false ;};func (_fbdc *NRGBA64 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtNRGBA64 (x ,y ,_fbdc .Width ,_fbdc .Data ,_fbdc .Alpha ,_fbdc .Decode );};func _bde (_faf ,_abg *Monochrome ,_gfe []byte ,_eeb int )(_fgg error ){var (_faa ,_bfcc ,_dga ,_ede ,_aedc ,_eb ,_bfd ,_fdc int ;
_ecf ,_beab uint32 ;_ddgf ,_ecfa byte ;_fdg uint16 ;);_fae :=make ([]byte ,4);_ebc :=make ([]byte ,4);for _dga =0;_dga < _faf .Height -1;_dga ,_ede =_dga +2,_ede +1{_faa =_dga *_faf .BytesPerLine ;_bfcc =_ede *_abg .BytesPerLine ;for _aedc ,_eb =0,0;_aedc < _eeb ;
_aedc ,_eb =_aedc +4,_eb +1{for _bfd =0;_bfd < 4;_bfd ++{_fdc =_faa +_aedc +_bfd ;if _fdc <=len (_faf .Data )-1&&_fdc < _faa +_faf .BytesPerLine {_fae [_bfd ]=_faf .Data [_fdc ];}else {_fae [_bfd ]=0x00;};_fdc =_faa +_faf .BytesPerLine +_aedc +_bfd ;if _fdc <=len (_faf .Data )-1&&_fdc < _faa +(2*_faf .BytesPerLine ){_ebc [_bfd ]=_faf .Data [_fdc ];
}else {_ebc [_bfd ]=0x00;};};_ecf =_gg .BigEndian .Uint32 (_fae );_beab =_gg .BigEndian .Uint32 (_ebc );_beab |=_ecf ;_beab |=_beab <<1;_beab &=0xaaaaaaaa;_ecf =_beab |(_beab <<7);_ddgf =byte (_ecf >>24);_ecfa =byte ((_ecf >>8)&0xff);_fdc =_bfcc +_eb ;
if _fdc +1==len (_abg .Data )-1||_fdc +1>=_bfcc +_abg .BytesPerLine {_abg .Data [_fdc ]=_gfe [_ddgf ];}else {_fdg =(uint16 (_gfe [_ddgf ])<<8)|uint16 (_gfe [_ecfa ]);if _fgg =_abg .setTwoBytes (_fdc ,_fdg );_fgg !=nil {return _ef .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_fdc );
};_eb ++;};};};return nil ;};func _gcbb (_acef int ,_cece int )error {return _ef .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",_acef ,_cece );
};func (_acag *Gray16 )SetGray (x ,y int ,g _g .Gray ){_ddga :=(y *_acag .BytesPerLine /2+x )*2;if _ddga +1>=len (_acag .Data ){return ;};_acag .Data [_ddga ]=g .Y ;_acag .Data [_ddga +1]=g .Y ;};func _ecbf (_feeb CMYK ,_fcea RGBA ,_cbdge _f .Rectangle ){for _bagf :=0;
_bagf < _cbdge .Max .X ;_bagf ++{for _aefg :=0;_aefg < _cbdge .Max .Y ;_aefg ++{_fcfd :=_feeb .CMYKAt (_bagf ,_aefg );_fcea .SetRGBA (_bagf ,_aefg ,_abb (_fcfd ));};};};func _gddc (_ebeg _g .CMYK )_g .Gray {_acaaa ,_acba ,_bbbd :=_g .CMYKToRGB (_ebeg .C ,_ebeg .M ,_ebeg .Y ,_ebeg .K );
_befe :=(19595*uint32 (_acaaa )+38470*uint32 (_acba )+7471*uint32 (_bbbd )+1<<7)>>16;return _g .Gray {Y :uint8 (_befe )};};func _beacg (_egfc ,_afgg RGBA ,_ceac _f .Rectangle ){for _dcbed :=0;_dcbed < _ceac .Max .X ;_dcbed ++{for _aebb :=0;_aebb < _ceac .Max .Y ;
_aebb ++{_afgg .SetRGBA (_dcbed ,_aebb ,_egfc .RGBAAt (_dcbed ,_aebb ));};};};var _ Gray =&Gray16 {};var ErrInvalidImage =_a .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
func (_cadd *Gray4 )Validate ()error {if len (_cadd .Data )!=_cadd .Height *_cadd .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_aaeg *ImageBase )Pix ()[]byte {return _aaeg .Data };func (_egc *Gray4 )GrayAt (x ,y int )_g .Gray {_dfdf ,_ :=ColorAtGray4BPC (x ,y ,_egc .BytesPerLine ,_egc .Data ,_egc .Decode );
return _dfdf ;};var _ NRGBA =&NRGBA16 {};func _cab ()(_eg [256]uint64 ){for _fdf :=0;_fdf < 256;_fdf ++{if _fdf &0x01!=0{_eg [_fdf ]|=0xff;};if _fdf &0x02!=0{_eg [_fdf ]|=0xff00;};if _fdf &0x04!=0{_eg [_fdf ]|=0xff0000;};if _fdf &0x08!=0{_eg [_fdf ]|=0xff000000;
};if _fdf &0x10!=0{_eg [_fdf ]|=0xff00000000;};if _fdf &0x20!=0{_eg [_fdf ]|=0xff0000000000;};if _fdf &0x40!=0{_eg [_fdf ]|=0xff000000000000;};if _fdf &0x80!=0{_eg [_fdf ]|=0xff00000000000000;};};return _eg ;};func IsGrayImgBlackAndWhite (i *_f .Gray )bool {return _fgadf (i )};
func (_ace *CMYK32 )At (x ,y int )_g .Color {_bddd ,_ :=_ace .ColorAt (x ,y );return _bddd };type RasterOperator int ;func (_ebca *Gray4 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtGray4BPC (x ,y ,_ebca .BytesPerLine ,_ebca .Data ,_ebca .Decode );
};func (_bcdb *NRGBA64 )Base ()*ImageBase {return &_bcdb .ImageBase };func _dgdf (_daba _g .NRGBA )_g .RGBA {_dbe ,_ggf ,_eeac ,_bcbb :=_daba .RGBA ();return _g .RGBA {R :uint8 (_dbe >>8),G :uint8 (_ggf >>8),B :uint8 (_eeac >>8),A :uint8 (_bcbb >>8)};};
func (_gcfd *Monochrome )Scale (scale float64 )(*Monochrome ,error ){var _ccdf bool ;_bffb :=scale ;if scale < 1{_bffb =1/scale ;_ccdf =true ;};_bdda :=NextPowerOf2 (uint (_bffb ));if InDelta (float64 (_bdda ),_bffb ,0.001){if _ccdf {return _gcfd .ReduceBinary (_bffb );
};return _gcfd .ExpandBinary (int (_bdda ));};_feb :=int (_ed .RoundToEven (float64 (_gcfd .Width )*scale ));_fdga :=int (_ed .RoundToEven (float64 (_gcfd .Height )*scale ));return _gcfd .ScaleLow (_feb ,_fdga );};func (_bbfd *Monochrome )getBit (_geaf ,_fafa int )uint8 {return _bbfd .Data [_geaf +(_fafa >>3)]>>uint (7-(_fafa &7))&1;
};func ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor int ,data ,alpha []byte ,decode []float64 )(_g .Color ,error ){switch bitsPerColor {case 4:return ColorAtNRGBA16 (x ,y ,width ,bytesPerLine ,data ,alpha ,decode );case 8:return ColorAtNRGBA32 (x ,y ,width ,data ,alpha ,decode );
case 16:return ColorAtNRGBA64 (x ,y ,width ,data ,alpha ,decode );default:return nil ,_ef .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0067\u0062\u0020b\u0069\u0074\u0073\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0061\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );
};};var _ _f .Image =&Gray16 {};func (_dbgg *RGBA32 )SetRGBA (x ,y int ,c _g .RGBA ){_caeea :=y *_dbgg .Width +x ;_abecd :=3*_caeea ;if _abecd +2>=len (_dbgg .Data ){return ;};_dbgg .setRGBA (_caeea ,c );};func (_eaga monochromeModel )Convert (c _g .Color )_g .Color {_adc :=_g .GrayModel .Convert (c ).(_g .Gray );
return _eec (_adc ,_eaga );};func _gefg (_caab _f .Image ,_egece uint8 )*_f .Gray {_ddcgd :=_caab .Bounds ();_abaf :=_f .NewGray (_ddcgd );var (_dgegf _g .Color ;_fgcge _g .Gray ;);for _ced :=0;_ced < _ddcgd .Max .X ;_ced ++{for _cacc :=0;_cacc < _ddcgd .Max .Y ;
_cacc ++{_dgegf =_caab .At (_ced ,_cacc );_abaf .Set (_ced ,_cacc ,_dgegf );_fgcge =_abaf .GrayAt (_ced ,_cacc );_abaf .SetGray (_ced ,_cacc ,_g .Gray {Y :_aeed (_fgcge .Y ,_egece )});};};return _abaf ;};func (_dgca *Gray8 )Bounds ()_f .Rectangle {return _f .Rectangle {Max :_f .Point {X :_dgca .Width ,Y :_dgca .Height }};
};func (_bgae *Gray8 )Base ()*ImageBase {return &_bgae .ImageBase };func _gcgg (){for _bbcf :=0;_bbcf < 256;_bbcf ++{_gfbcc [_bbcf ]=uint8 (_bbcf &0x1)+(uint8 (_bbcf >>1)&0x1)+(uint8 (_bbcf >>2)&0x1)+(uint8 (_bbcf >>3)&0x1)+(uint8 (_bbcf >>4)&0x1)+(uint8 (_bbcf >>5)&0x1)+(uint8 (_bbcf >>6)&0x1)+(uint8 (_bbcf >>7)&0x1);
};};var (MonochromeConverter =ConverterFunc (_cfag );Gray2Converter =ConverterFunc (_fcae );Gray4Converter =ConverterFunc (_cga );GrayConverter =ConverterFunc (_fefbe );Gray16Converter =ConverterFunc (_ggbb );NRGBA16Converter =ConverterFunc (_bdfb );NRGBAConverter =ConverterFunc (_dbfcf );
NRGBA64Converter =ConverterFunc (_abag );RGBAConverter =ConverterFunc (_bfada );CMYKConverter =ConverterFunc (_egd ););var _ NRGBA =&NRGBA32 {};func (_gbaf *Gray2 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtGray2BPC (x ,y ,_gbaf .BytesPerLine ,_gbaf .Data ,_gbaf .Decode );
};var _ Gray =&Monochrome {};func (_dagc *ImageBase )newAlpha (){_gccf :=BytesPerLine (_dagc .Width ,_dagc .BitsPerComponent ,1);_dagc .Alpha =make ([]byte ,_dagc .Height *_gccf );};func (_fdgd *ImageBase )copy ()ImageBase {_feed :=*_fdgd ;_feed .Data =make ([]byte ,len (_fdgd .Data ));
copy (_feed .Data ,_fdgd .Data );return _feed ;};func (_cdbcf *NRGBA32 )At (x ,y int )_g .Color {_dcac ,_ :=_cdbcf .ColorAt (x ,y );return _dcac };var _ _f .Image =&Gray4 {};var _gfbcc [256]uint8 ;func _ggbb (_cacg _f .Image )(Image ,error ){if _aege ,_aafc :=_cacg .(*Gray16 );
_aafc {return _aege .Copy (),nil ;};_cgc :=_cacg .Bounds ();_eedd ,_gfc :=NewImage (_cgc .Max .X ,_cgc .Max .Y ,16,1,nil ,nil ,nil );if _gfc !=nil {return nil ,_gfc ;};_acfc (_cacg ,_eedd ,_cgc );return _eedd ,nil ;};func (_dca *Monochrome )ResolveDecode ()error {if len (_dca .Decode )!=2{return nil ;
};if _dca .Decode [0]==1&&_dca .Decode [1]==0{if _abd :=_dca .InverseData ();_abd !=nil {return _abd ;};_dca .Decode =nil ;};return nil ;};func _ddcd (_dggc *Monochrome ,_acdff ,_dgbe int ,_afca ,_gfef int ,_badc RasterOperator ){var (_abcc bool ;_egagd bool ;
_aadee int ;_bged int ;_efbde int ;_bfaac int ;_cce bool ;_faae byte ;);_edge :=8-(_acdff &7);_cbbc :=_befa [_edge ];_bfad :=_dggc .BytesPerLine *_dgbe +(_acdff >>3);if _afca < _edge {_abcc =true ;_cbbc &=_gbcf [8-_edge +_afca ];};if !_abcc {_aadee =(_afca -_edge )>>3;
if _aadee !=0{_egagd =true ;_bged =_bfad +1;};};_efbde =(_acdff +_afca )&7;if !(_abcc ||_efbde ==0){_cce =true ;_faae =_gbcf [_efbde ];_bfaac =_bfad +1+_aadee ;};var _bfaf ,_edba int ;switch _badc {case PixClr :for _bfaf =0;_bfaf < _gfef ;_bfaf ++{_dggc .Data [_bfad ]=_fage (_dggc .Data [_bfad ],0x0,_cbbc );
_bfad +=_dggc .BytesPerLine ;};if _egagd {for _bfaf =0;_bfaf < _gfef ;_bfaf ++{for _edba =0;_edba < _aadee ;_edba ++{_dggc .Data [_bged +_edba ]=0x0;};_bged +=_dggc .BytesPerLine ;};};if _cce {for _bfaf =0;_bfaf < _gfef ;_bfaf ++{_dggc .Data [_bfaac ]=_fage (_dggc .Data [_bfaac ],0x0,_faae );
_bfaac +=_dggc .BytesPerLine ;};};case PixSet :for _bfaf =0;_bfaf < _gfef ;_bfaf ++{_dggc .Data [_bfad ]=_fage (_dggc .Data [_bfad ],0xff,_cbbc );_bfad +=_dggc .BytesPerLine ;};if _egagd {for _bfaf =0;_bfaf < _gfef ;_bfaf ++{for _edba =0;_edba < _aadee ;
_edba ++{_dggc .Data [_bged +_edba ]=0xff;};_bged +=_dggc .BytesPerLine ;};};if _cce {for _bfaf =0;_bfaf < _gfef ;_bfaf ++{_dggc .Data [_bfaac ]=_fage (_dggc .Data [_bfaac ],0xff,_faae );_bfaac +=_dggc .BytesPerLine ;};};case PixNotDst :for _bfaf =0;_bfaf < _gfef ;
_bfaf ++{_dggc .Data [_bfad ]=_fage (_dggc .Data [_bfad ],^_dggc .Data [_bfad ],_cbbc );_bfad +=_dggc .BytesPerLine ;};if _egagd {for _bfaf =0;_bfaf < _gfef ;_bfaf ++{for _edba =0;_edba < _aadee ;_edba ++{_dggc .Data [_bged +_edba ]=^(_dggc .Data [_bged +_edba ]);
};_bged +=_dggc .BytesPerLine ;};};if _cce {for _bfaf =0;_bfaf < _gfef ;_bfaf ++{_dggc .Data [_bfaac ]=_fage (_dggc .Data [_bfaac ],^_dggc .Data [_bfaac ],_faae );_bfaac +=_dggc .BytesPerLine ;};};};};func (_gga *Monochrome )ReduceBinary (factor float64 )(*Monochrome ,error ){_bff :=_ebfg (uint (factor ));
if !IsPowerOf2 (uint (factor )){_bff ++;};_bfgfa :=make ([]int ,_bff );for _afab :=range _bfgfa {_bfgfa [_afab ]=4;};_edbe ,_dedc :=_cdbe (_gga ,_bfgfa ...);if _dedc !=nil {return nil ,_dedc ;};return _edbe ,nil ;};func _bab (_ggb ,_cde int )*Monochrome {return &Monochrome {ImageBase :NewImageBase (_ggb ,_cde ,1,1,nil ,nil ,nil ),ModelThreshold :0x0f};
};func _ffdf (_eefdd nrgba64 ,_bgga RGBA ,_egbf _f .Rectangle ){for _ebefc :=0;_ebefc < _egbf .Max .X ;_ebefc ++{for _ccfe :=0;_ccfe < _egbf .Max .Y ;_ccfe ++{_cadeg :=_eefdd .NRGBA64At (_ebefc ,_ccfe );_bgga .SetRGBA (_ebefc ,_ccfe ,_bgaf (_cadeg ));};
};};func _egda (_cdff _g .RGBA )_g .Gray {_dde :=(19595*uint32 (_cdff .R )+38470*uint32 (_cdff .G )+7471*uint32 (_cdff .B )+1<<7)>>16;return _g .Gray {Y :uint8 (_dde )};};var _ _f .Image =&RGBA32 {};func ConverterFunc (converterFunc func (_eba _f .Image )(Image ,error ))ColorConverter {return colorConverter {_daad :converterFunc };
};var (_gbb =_ddbd ();_ddb =_ea ();_da =_cab (););func _geda (_bbbe RGBA ,_gaab Gray ,_dfae _f .Rectangle ){for _bcce :=0;_bcce < _dfae .Max .X ;_bcce ++{for _ece :=0;_ece < _dfae .Max .Y ;_ece ++{_ebaa :=_egda (_bbbe .RGBAAt (_bcce ,_ece ));_gaab .SetGray (_bcce ,_ece ,_ebaa );
};};};func _fcgf (_dccc *Monochrome ,_ebcg ,_dagg ,_afbe ,_fafc int ,_cfcg RasterOperator ,_begc *Monochrome ,_bcd ,_babe int )error {var (_bafa bool ;_cfaba bool ;_fefbf int ;_afgb int ;_dfg int ;_ecdd bool ;_gcb byte ;_cgad int ;_dee int ;_cead int ;
_fdgf ,_fabge int ;);_bedc :=8-(_ebcg &7);_begg :=_befa [_bedc ];_gbfab :=_dccc .BytesPerLine *_dagg +(_ebcg >>3);_acffa :=_begc .BytesPerLine *_babe +(_bcd >>3);if _afbe < _bedc {_bafa =true ;_begg &=_gbcf [8-_bedc +_afbe ];};if !_bafa {_fefbf =(_afbe -_bedc )>>3;
if _fefbf > 0{_cfaba =true ;_afgb =_gbfab +1;_dfg =_acffa +1;};};_cgad =(_ebcg +_afbe )&7;if !(_bafa ||_cgad ==0){_ecdd =true ;_gcb =_gbcf [_cgad ];_dee =_gbfab +1+_fefbf ;_cead =_acffa +1+_fefbf ;};switch _cfcg {case PixSrc :for _fdgf =0;_fdgf < _fafc ;
_fdgf ++{_dccc .Data [_gbfab ]=_fage (_dccc .Data [_gbfab ],_begc .Data [_acffa ],_begg );_gbfab +=_dccc .BytesPerLine ;_acffa +=_begc .BytesPerLine ;};if _cfaba {for _fdgf =0;_fdgf < _fafc ;_fdgf ++{for _fabge =0;_fabge < _fefbf ;_fabge ++{_dccc .Data [_afgb +_fabge ]=_begc .Data [_dfg +_fabge ];
};_afgb +=_dccc .BytesPerLine ;_dfg +=_begc .BytesPerLine ;};};if _ecdd {for _fdgf =0;_fdgf < _fafc ;_fdgf ++{_dccc .Data [_dee ]=_fage (_dccc .Data [_dee ],_begc .Data [_cead ],_gcb );_dee +=_dccc .BytesPerLine ;_cead +=_begc .BytesPerLine ;};};case PixNotSrc :for _fdgf =0;
_fdgf < _fafc ;_fdgf ++{_dccc .Data [_gbfab ]=_fage (_dccc .Data [_gbfab ],^_begc .Data [_acffa ],_begg );_gbfab +=_dccc .BytesPerLine ;_acffa +=_begc .BytesPerLine ;};if _cfaba {for _fdgf =0;_fdgf < _fafc ;_fdgf ++{for _fabge =0;_fabge < _fefbf ;_fabge ++{_dccc .Data [_afgb +_fabge ]=^_begc .Data [_dfg +_fabge ];
};_afgb +=_dccc .BytesPerLine ;_dfg +=_begc .BytesPerLine ;};};if _ecdd {for _fdgf =0;_fdgf < _fafc ;_fdgf ++{_dccc .Data [_dee ]=_fage (_dccc .Data [_dee ],^_begc .Data [_cead ],_gcb );_dee +=_dccc .BytesPerLine ;_cead +=_begc .BytesPerLine ;};};case PixSrcOrDst :for _fdgf =0;
_fdgf < _fafc ;_fdgf ++{_dccc .Data [_gbfab ]=_fage (_dccc .Data [_gbfab ],_begc .Data [_acffa ]|_dccc .Data [_gbfab ],_begg );_gbfab +=_dccc .BytesPerLine ;_acffa +=_begc .BytesPerLine ;};if _cfaba {for _fdgf =0;_fdgf < _fafc ;_fdgf ++{for _fabge =0;_fabge < _fefbf ;
_fabge ++{_dccc .Data [_afgb +_fabge ]|=_begc .Data [_dfg +_fabge ];};_afgb +=_dccc .BytesPerLine ;_dfg +=_begc .BytesPerLine ;};};if _ecdd {for _fdgf =0;_fdgf < _fafc ;_fdgf ++{_dccc .Data [_dee ]=_fage (_dccc .Data [_dee ],_begc .Data [_cead ]|_dccc .Data [_dee ],_gcb );
_dee +=_dccc .BytesPerLine ;_cead +=_begc .BytesPerLine ;};};case PixSrcAndDst :for _fdgf =0;_fdgf < _fafc ;_fdgf ++{_dccc .Data [_gbfab ]=_fage (_dccc .Data [_gbfab ],_begc .Data [_acffa ]&_dccc .Data [_gbfab ],_begg );_gbfab +=_dccc .BytesPerLine ;_acffa +=_begc .BytesPerLine ;
};if _cfaba {for _fdgf =0;_fdgf < _fafc ;_fdgf ++{for _fabge =0;_fabge < _fefbf ;_fabge ++{_dccc .Data [_afgb +_fabge ]&=_begc .Data [_dfg +_fabge ];};_afgb +=_dccc .BytesPerLine ;_dfg +=_begc .BytesPerLine ;};};if _ecdd {for _fdgf =0;_fdgf < _fafc ;_fdgf ++{_dccc .Data [_dee ]=_fage (_dccc .Data [_dee ],_begc .Data [_cead ]&_dccc .Data [_dee ],_gcb );
_dee +=_dccc .BytesPerLine ;_cead +=_begc .BytesPerLine ;};};case PixSrcXorDst :for _fdgf =0;_fdgf < _fafc ;_fdgf ++{_dccc .Data [_gbfab ]=_fage (_dccc .Data [_gbfab ],_begc .Data [_acffa ]^_dccc .Data [_gbfab ],_begg );_gbfab +=_dccc .BytesPerLine ;_acffa +=_begc .BytesPerLine ;
};if _cfaba {for _fdgf =0;_fdgf < _fafc ;_fdgf ++{for _fabge =0;_fabge < _fefbf ;_fabge ++{_dccc .Data [_afgb +_fabge ]^=_begc .Data [_dfg +_fabge ];};_afgb +=_dccc .BytesPerLine ;_dfg +=_begc .BytesPerLine ;};};if _ecdd {for _fdgf =0;_fdgf < _fafc ;_fdgf ++{_dccc .Data [_dee ]=_fage (_dccc .Data [_dee ],_begc .Data [_cead ]^_dccc .Data [_dee ],_gcb );
_dee +=_dccc .BytesPerLine ;_cead +=_begc .BytesPerLine ;};};case PixNotSrcOrDst :for _fdgf =0;_fdgf < _fafc ;_fdgf ++{_dccc .Data [_gbfab ]=_fage (_dccc .Data [_gbfab ],^(_begc .Data [_acffa ])|_dccc .Data [_gbfab ],_begg );_gbfab +=_dccc .BytesPerLine ;
_acffa +=_begc .BytesPerLine ;};if _cfaba {for _fdgf =0;_fdgf < _fafc ;_fdgf ++{for _fabge =0;_fabge < _fefbf ;_fabge ++{_dccc .Data [_afgb +_fabge ]|=^(_begc .Data [_dfg +_fabge ]);};_afgb +=_dccc .BytesPerLine ;_dfg +=_begc .BytesPerLine ;};};if _ecdd {for _fdgf =0;
_fdgf < _fafc ;_fdgf ++{_dccc .Data [_dee ]=_fage (_dccc .Data [_dee ],^(_begc .Data [_cead ])|_dccc .Data [_dee ],_gcb );_dee +=_dccc .BytesPerLine ;_cead +=_begc .BytesPerLine ;};};case PixNotSrcAndDst :for _fdgf =0;_fdgf < _fafc ;_fdgf ++{_dccc .Data [_gbfab ]=_fage (_dccc .Data [_gbfab ],^(_begc .Data [_acffa ])&_dccc .Data [_gbfab ],_begg );
_gbfab +=_dccc .BytesPerLine ;_acffa +=_begc .BytesPerLine ;};if _cfaba {for _fdgf =0;_fdgf < _fafc ;_fdgf ++{for _fabge =0;_fabge < _fefbf ;_fabge ++{_dccc .Data [_afgb +_fabge ]&=^_begc .Data [_dfg +_fabge ];};_afgb +=_dccc .BytesPerLine ;_dfg +=_begc .BytesPerLine ;
};};if _ecdd {for _fdgf =0;_fdgf < _fafc ;_fdgf ++{_dccc .Data [_dee ]=_fage (_dccc .Data [_dee ],^(_begc .Data [_cead ])&_dccc .Data [_dee ],_gcb );_dee +=_dccc .BytesPerLine ;_cead +=_begc .BytesPerLine ;};};case PixSrcOrNotDst :for _fdgf =0;_fdgf < _fafc ;
_fdgf ++{_dccc .Data [_gbfab ]=_fage (_dccc .Data [_gbfab ],_begc .Data [_acffa ]|^(_dccc .Data [_gbfab ]),_begg );_gbfab +=_dccc .BytesPerLine ;_acffa +=_begc .BytesPerLine ;};if _cfaba {for _fdgf =0;_fdgf < _fafc ;_fdgf ++{for _fabge =0;_fabge < _fefbf ;
_fabge ++{_dccc .Data [_afgb +_fabge ]=_begc .Data [_dfg +_fabge ]|^(_dccc .Data [_afgb +_fabge ]);};_afgb +=_dccc .BytesPerLine ;_dfg +=_begc .BytesPerLine ;};};if _ecdd {for _fdgf =0;_fdgf < _fafc ;_fdgf ++{_dccc .Data [_dee ]=_fage (_dccc .Data [_dee ],_begc .Data [_cead ]|^(_dccc .Data [_dee ]),_gcb );
_dee +=_dccc .BytesPerLine ;_cead +=_begc .BytesPerLine ;};};case PixSrcAndNotDst :for _fdgf =0;_fdgf < _fafc ;_fdgf ++{_dccc .Data [_gbfab ]=_fage (_dccc .Data [_gbfab ],_begc .Data [_acffa ]&^(_dccc .Data [_gbfab ]),_begg );_gbfab +=_dccc .BytesPerLine ;
_acffa +=_begc .BytesPerLine ;};if _cfaba {for _fdgf =0;_fdgf < _fafc ;_fdgf ++{for _fabge =0;_fabge < _fefbf ;_fabge ++{_dccc .Data [_afgb +_fabge ]=_begc .Data [_dfg +_fabge ]&^(_dccc .Data [_afgb +_fabge ]);};_afgb +=_dccc .BytesPerLine ;_dfg +=_begc .BytesPerLine ;
};};if _ecdd {for _fdgf =0;_fdgf < _fafc ;_fdgf ++{_dccc .Data [_dee ]=_fage (_dccc .Data [_dee ],_begc .Data [_cead ]&^(_dccc .Data [_dee ]),_gcb );_dee +=_dccc .BytesPerLine ;_cead +=_begc .BytesPerLine ;};};case PixNotPixSrcOrDst :for _fdgf =0;_fdgf < _fafc ;
_fdgf ++{_dccc .Data [_gbfab ]=_fage (_dccc .Data [_gbfab ],^(_begc .Data [_acffa ]|_dccc .Data [_gbfab ]),_begg );_gbfab +=_dccc .BytesPerLine ;_acffa +=_begc .BytesPerLine ;};if _cfaba {for _fdgf =0;_fdgf < _fafc ;_fdgf ++{for _fabge =0;_fabge < _fefbf ;
_fabge ++{_dccc .Data [_afgb +_fabge ]=^(_begc .Data [_dfg +_fabge ]|_dccc .Data [_afgb +_fabge ]);};_afgb +=_dccc .BytesPerLine ;_dfg +=_begc .BytesPerLine ;};};if _ecdd {for _fdgf =0;_fdgf < _fafc ;_fdgf ++{_dccc .Data [_dee ]=_fage (_dccc .Data [_dee ],^(_begc .Data [_cead ]|_dccc .Data [_dee ]),_gcb );
_dee +=_dccc .BytesPerLine ;_cead +=_begc .BytesPerLine ;};};case PixNotPixSrcAndDst :for _fdgf =0;_fdgf < _fafc ;_fdgf ++{_dccc .Data [_gbfab ]=_fage (_dccc .Data [_gbfab ],^(_begc .Data [_acffa ]&_dccc .Data [_gbfab ]),_begg );_gbfab +=_dccc .BytesPerLine ;
_acffa +=_begc .BytesPerLine ;};if _cfaba {for _fdgf =0;_fdgf < _fafc ;_fdgf ++{for _fabge =0;_fabge < _fefbf ;_fabge ++{_dccc .Data [_afgb +_fabge ]=^(_begc .Data [_dfg +_fabge ]&_dccc .Data [_afgb +_fabge ]);};_afgb +=_dccc .BytesPerLine ;_dfg +=_begc .BytesPerLine ;
};};if _ecdd {for _fdgf =0;_fdgf < _fafc ;_fdgf ++{_dccc .Data [_dee ]=_fage (_dccc .Data [_dee ],^(_begc .Data [_cead ]&_dccc .Data [_dee ]),_gcb );_dee +=_dccc .BytesPerLine ;_cead +=_begc .BytesPerLine ;};};case PixNotPixSrcXorDst :for _fdgf =0;_fdgf < _fafc ;
_fdgf ++{_dccc .Data [_gbfab ]=_fage (_dccc .Data [_gbfab ],^(_begc .Data [_acffa ]^_dccc .Data [_gbfab ]),_begg );_gbfab +=_dccc .BytesPerLine ;_acffa +=_begc .BytesPerLine ;};if _cfaba {for _fdgf =0;_fdgf < _fafc ;_fdgf ++{for _fabge =0;_fabge < _fefbf ;
_fabge ++{_dccc .Data [_afgb +_fabge ]=^(_begc .Data [_dfg +_fabge ]^_dccc .Data [_afgb +_fabge ]);};_afgb +=_dccc .BytesPerLine ;_dfg +=_begc .BytesPerLine ;};};if _ecdd {for _fdgf =0;_fdgf < _fafc ;_fdgf ++{_dccc .Data [_dee ]=_fage (_dccc .Data [_dee ],^(_begc .Data [_cead ]^_dccc .Data [_dee ]),_gcb );
_dee +=_dccc .BytesPerLine ;_cead +=_begc .BytesPerLine ;};};default:_gf .Log .Debug ("I\u006e\u0076\u0061\u006c\u0069\u0064 \u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070e\u0072\u0061\u0074o\u0072:\u0020\u0025\u0064",_cfcg );return _a .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072");
};return nil ;};func _adgd (_dbg nrgba64 ,_ageef NRGBA ,_abddf _f .Rectangle ){for _ecag :=0;_ecag < _abddf .Max .X ;_ecag ++{for _gae :=0;_gae < _abddf .Max .Y ;_gae ++{_fgbe :=_dbg .NRGBA64At (_ecag ,_gae );_ageef .SetNRGBA (_ecag ,_gae ,_acff (_fgbe ));
};};};func (_fde *CMYK32 )CMYKAt (x ,y int )_g .CMYK {_cdg ,_ :=ColorAtCMYK (x ,y ,_fde .Width ,_fde .Data ,_fde .Decode );return _cdg ;};func (_becf *Monochrome )At (x ,y int )_g .Color {_ebee ,_ :=_becf .ColorAt (x ,y );return _ebee };type CMYK32 struct{ImageBase };
func _fbcb (_bcc _f .Image ,_efbc Image ,_edeb _f .Rectangle ){for _bae :=0;_bae < _edeb .Max .X ;_bae ++{for _abcf :=0;_abcf < _edeb .Max .Y ;_abcf ++{_gbf :=_bcc .At (_bae ,_abcf );_efbc .Set (_bae ,_abcf ,_gbf );};};};type NRGBA16 struct{ImageBase };
var (Gray2Model =_g .ModelFunc (_cgff );Gray4Model =_g .ModelFunc (_bcfbb );NRGBA16Model =_g .ModelFunc (_edadg ););func MonochromeModel (threshold uint8 )_g .Model {return monochromeModel (threshold )};func (_bgaad *Gray2 )Set (x ,y int ,c _g .Color ){if x >=_bgaad .Width ||y >=_bgaad .Height {return ;
};_baca :=Gray2Model .Convert (c ).(_g .Gray );_gcfa :=y *_bgaad .BytesPerLine ;_fefb :=_gcfa +(x >>2);_dec :=_baca .Y >>6;_bgaad .Data [_fefb ]=(_bgaad .Data [_fefb ]&(^(0xc0>>uint (2*((x )&3)))))|(_dec <<uint (6-2*(x &3)));};func (_dcb *CMYK32 )ColorModel ()_g .Model {return _g .CMYKModel };
func (_dfcg *Gray4 )SetGray (x ,y int ,g _g .Gray ){if x >=_dfcg .Width ||y >=_dfcg .Height {return ;};g =_eeff (g );_dfcg .setGray (x ,y ,g );};type Gray4 struct{ImageBase };func _fgadf (_ageg *_f .Gray )bool {for _fgbg :=0;_fgbg < len (_ageg .Pix );_fgbg ++{if !_dbfcfc (_ageg .Pix [_fgbg ]){return false ;
};};return true ;};func (_addd *Gray4 )Set (x ,y int ,c _g .Color ){if x >=_addd .Width ||y >=_addd .Height {return ;};_cfaa :=Gray4Model .Convert (c ).(_g .Gray );_addd .setGray (x ,y ,_cfaa );};func (_gbfb *NRGBA64 )ColorModel ()_g .Model {return _g .NRGBA64Model };
type Image interface{_d .Image ;Base ()*ImageBase ;Copy ()Image ;Pix ()[]byte ;ColorAt (_egf ,_dae int )(_g .Color ,error );Validate ()error ;};var _ Image =&Gray8 {};var _ _f .Image =&Gray2 {};func (_bbab *CMYK32 )Set (x ,y int ,c _g .Color ){_dbc :=4*(y *_bbab .Width +x );
if _dbc +3>=len (_bbab .Data ){return ;};_ddd :=_g .CMYKModel .Convert (c ).(_g .CMYK );_bbab .Data [_dbc ]=_ddd .C ;_bbab .Data [_dbc +1]=_ddd .M ;_bbab .Data [_dbc +2]=_ddd .Y ;_bbab .Data [_dbc +3]=_ddd .K ;};func (_bacc *Gray2 )At (x ,y int )_g .Color {_dbce ,_ :=_bacc .ColorAt (x ,y );
return _dbce };func _affa (_bef RGBA ,_ecgc CMYK ,_ffb _f .Rectangle ){for _bbb :=0;_bbb < _ffb .Max .X ;_bbb ++{for _eef :=0;_eef < _ffb .Max .Y ;_eef ++{_eefd :=_bef .RGBAAt (_bbb ,_eef );_ecgc .SetCMYK (_bbb ,_eef ,_ggd (_eefd ));};};};func (_effgg *NRGBA16 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtNRGBA16 (x ,y ,_effgg .Width ,_effgg .BytesPerLine ,_effgg .Data ,_effgg .Alpha ,_effgg .Decode );
};func (_bgeag *NRGBA16 )Validate ()error {if len (_bgeag .Data )!=3*_bgeag .Width *_bgeag .Height /2{return _a .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func (_fdcg *Monochrome )copy ()*Monochrome {_fdba :=_bab (_fdcg .Width ,_fdcg .Height );_fdba .ModelThreshold =_fdcg .ModelThreshold ;_fdba .Data =make ([]byte ,len (_fdcg .Data ));copy (_fdba .Data ,_fdcg .Data );if len (_fdcg .Decode )!=0{_fdba .Decode =make ([]float64 ,len (_fdcg .Decode ));
copy (_fdba .Decode ,_fdcg .Decode );};if len (_fdcg .Alpha )!=0{_fdba .Alpha =make ([]byte ,len (_fdcg .Alpha ));copy (_fdba .Alpha ,_fdcg .Alpha );};return _fdba ;};func _cdbe (_daa *Monochrome ,_cfgb ...int )(_aa *Monochrome ,_cafb error ){if _daa ==nil {return nil ,_a .New ("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d");
};if len (_cfgb )==0{return nil ,_a .New ("\u0074h\u0065\u0072e\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0061\u0074 \u006c\u0065\u0061\u0073\u0074\u0020o\u006e\u0065\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u006f\u0066 \u0072\u0065\u0064\u0075\u0063\u0074\u0069\u006f\u006e");
};_gce :=_fccb ();_aa =_daa ;for _ ,_cda :=range _cfgb {if _cda <=0{break ;};_aa ,_cafb =_aac (_aa ,_cda ,_gce );if _cafb !=nil {return nil ,_cafb ;};};return _aa ,nil ;};func (_fdcgge *Gray8 )At (x ,y int )_g .Color {_ffbd ,_ :=_fdcgge .ColorAt (x ,y );
return _ffbd };func _gcaa (_ebe _g .NRGBA )_g .CMYK {_degg ,_dcdg ,_ebf ,_ :=_ebe .RGBA ();_dabf ,_dgd ,_bee ,_baf :=_g .RGBToCMYK (uint8 (_degg >>8),uint8 (_dcdg >>8),uint8 (_ebf >>8));return _g .CMYK {C :_dabf ,M :_dgd ,Y :_bee ,K :_baf };};func (_gaaea *NRGBA16 )Set (x ,y int ,c _g .Color ){_eaeba :=y *_gaaea .BytesPerLine +x *3/2;
if _eaeba +1>=len (_gaaea .Data ){return ;};_dcbe :=NRGBA16Model .Convert (c ).(_g .NRGBA );_gaaea .setNRGBA (x ,y ,_eaeba ,_dcbe );};var _ _f .Image =&NRGBA64 {};type Gray8 struct{ImageBase };func (_ddgg *NRGBA32 )setRGBA (_eggd int ,_eabf _g .NRGBA ){_cgcb :=3*_eggd ;
_ddgg .Data [_cgcb ]=_eabf .R ;_ddgg .Data [_cgcb +1]=_eabf .G ;_ddgg .Data [_cgcb +2]=_eabf .B ;if _eggd < len (_ddgg .Alpha ){_ddgg .Alpha [_eggd ]=_eabf .A ;};};func (_bbgf *Monochrome )RasterOperation (dx ,dy ,dw ,dh int ,op RasterOperator ,src *Monochrome ,sx ,sy int )error {return _efg (_bbgf ,dx ,dy ,dw ,dh ,op ,src ,sx ,sy );
};func _fefbe (_fedb _f .Image )(Image ,error ){if _eeae ,_gfac :=_fedb .(*Gray8 );_gfac {return _eeae .Copy (),nil ;};_eaag :=_fedb .Bounds ();_eada ,_aedd :=NewImage (_eaag .Max .X ,_eaag .Max .Y ,8,1,nil ,nil ,nil );if _aedd !=nil {return nil ,_aedd ;
};_acfc (_fedb ,_eada ,_eaag );return _eada ,nil ;};func _gdd (_gfa ,_gcg *Monochrome ,_bge []byte ,_fga int )(_cebb error ){var (_ffe ,_aaca ,_abc ,_aff ,_gff ,_ggbac ,_edec ,_aad int ;_dce ,_gea ,_gcfe ,_cgg uint32 ;_ccc ,_bdeb byte ;_ead uint16 ;);_cebbe :=make ([]byte ,4);
_aea :=make ([]byte ,4);for _abc =0;_abc < _gfa .Height -1;_abc ,_aff =_abc +2,_aff +1{_ffe =_abc *_gfa .BytesPerLine ;_aaca =_aff *_gcg .BytesPerLine ;for _gff ,_ggbac =0,0;_gff < _fga ;_gff ,_ggbac =_gff +4,_ggbac +1{for _edec =0;_edec < 4;_edec ++{_aad =_ffe +_gff +_edec ;
if _aad <=len (_gfa .Data )-1&&_aad < _ffe +_gfa .BytesPerLine {_cebbe [_edec ]=_gfa .Data [_aad ];}else {_cebbe [_edec ]=0x00;};_aad =_ffe +_gfa .BytesPerLine +_gff +_edec ;if _aad <=len (_gfa .Data )-1&&_aad < _ffe +(2*_gfa .BytesPerLine ){_aea [_edec ]=_gfa .Data [_aad ];
}else {_aea [_edec ]=0x00;};};_dce =_gg .BigEndian .Uint32 (_cebbe );_gea =_gg .BigEndian .Uint32 (_aea );_gcfe =_dce &_gea ;_gcfe |=_gcfe <<1;_cgg =_dce |_gea ;_cgg &=_cgg <<1;_gea =_gcfe &_cgg ;_gea &=0xaaaaaaaa;_dce =_gea |(_gea <<7);_ccc =byte (_dce >>24);
_bdeb =byte ((_dce >>8)&0xff);_aad =_aaca +_ggbac ;if _aad +1==len (_gcg .Data )-1||_aad +1>=_aaca +_gcg .BytesPerLine {if _cebb =_gcg .setByte (_aad ,_bge [_ccc ]);_cebb !=nil {return _ef .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_aad );
};}else {_ead =(uint16 (_bge [_ccc ])<<8)|uint16 (_bge [_bdeb ]);if _cebb =_gcg .setTwoBytes (_aad ,_ead );_cebb !=nil {return _ef .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_aad );
};_ggbac ++;};};};return nil ;};func AddDataPadding (width ,height ,bitsPerComponent ,colorComponents int ,data []byte )([]byte ,error ){_afbc :=BytesPerLine (width ,bitsPerComponent ,colorComponents );if _afbc ==width *colorComponents *bitsPerComponent /8{return data ,nil ;
};_acea :=width *colorComponents *bitsPerComponent ;_ebegfb :=_afbc *8;_eebe :=8-(_ebegfb -_acea );_bbdb :=_b .NewReader (data );_fcef :=_afbc -1;_abga :=make ([]byte ,_fcef );_becfg :=make ([]byte ,height *_afbc );_ggbe :=_b .NewWriterMSB (_becfg );var _fcaa uint64 ;
var _gege error ;for _baac :=0;_baac < height ;_baac ++{_ ,_gege =_bbdb .Read (_abga );if _gege !=nil {return nil ,_gege ;};_ ,_gege =_ggbe .Write (_abga );if _gege !=nil {return nil ,_gege ;};_fcaa ,_gege =_bbdb .ReadBits (byte (_eebe ));if _gege !=nil {return nil ,_gege ;
};_ ,_gege =_ggbe .WriteBits (_fcaa ,_eebe );if _gege !=nil {return nil ,_gege ;};_ggbe .FinishByte ();};return _becfg ,nil ;};func FromGoImage (i _f .Image )(Image ,error ){switch _bebaf :=i .(type ){case Image :return _bebaf .Copy (),nil ;case Gray :return GrayConverter .Convert (i );
case *_f .Gray16 :return Gray16Converter .Convert (i );case CMYK :return CMYKConverter .Convert (i );case *_f .NRGBA64 :return NRGBA64Converter .Convert (i );default:return NRGBAConverter .Convert (i );};};type NRGBA32 struct{ImageBase };func (_gdff *RGBA32 )Validate ()error {if len (_gdff .Data )!=3*_gdff .Width *_gdff .Height {return _a .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func (_gcgb *NRGBA16 )At (x ,y int )_g .Color {_gdbg ,_ :=_gcgb .ColorAt (x ,y );return _gdbg };func (_eabd *NRGBA32 )Copy ()Image {return &NRGBA32 {ImageBase :_eabd .copy ()}};func ColorAtNRGBA16 (x ,y ,width ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_g .NRGBA ,error ){_fegd :=y *bytesPerLine +x *3/2;
if _fegd +1>=len (data ){return _g .NRGBA {},_gcbb (x ,y );};const (_eegcg =0xf;_afcb =uint8 (0xff););_fced :=_afcb ;if alpha !=nil {_dcede :=y *BytesPerLine (width ,4,1);if _dcede < len (alpha ){if x %2==0{_fced =(alpha [_dcede ]>>uint (4))&_eegcg ;}else {_fced =alpha [_dcede ]&_eegcg ;
};_fced |=_fced <<4;};};var _eeec ,_afbd ,_eacg uint8 ;if x *3%2==0{_eeec =(data [_fegd ]>>uint (4))&_eegcg ;_afbd =data [_fegd ]&_eegcg ;_eacg =(data [_fegd +1]>>uint (4))&_eegcg ;}else {_eeec =data [_fegd ]&_eegcg ;_afbd =(data [_fegd +1]>>uint (4))&_eegcg ;
_eacg =data [_fegd +1]&_eegcg ;};if len (decode )==6{_eeec =uint8 (uint32 (LinearInterpolate (float64 (_eeec ),0,15,decode [0],decode [1]))&0xf);_afbd =uint8 (uint32 (LinearInterpolate (float64 (_afbd ),0,15,decode [2],decode [3]))&0xf);_eacg =uint8 (uint32 (LinearInterpolate (float64 (_eacg ),0,15,decode [4],decode [5]))&0xf);
};return _g .NRGBA {R :(_eeec <<4)|(_eeec &0xf),G :(_afbd <<4)|(_afbd &0xf),B :(_eacg <<4)|(_eacg &0xf),A :_fced },nil ;};func (_fefd *ImageBase )GetAlpha ()[]byte {return _fefd .Alpha };func InDelta (expected ,current ,delta float64 )bool {_dbca :=expected -current ;
if _dbca <=-delta ||_dbca >=delta {return false ;};return true ;};func (_eae *Gray2 )ColorModel ()_g .Model {return Gray2Model };func _ddbd ()(_agf [256]uint16 ){for _ecb :=0;_ecb < 256;_ecb ++{if _ecb &0x01!=0{_agf [_ecb ]|=0x3;};if _ecb &0x02!=0{_agf [_ecb ]|=0xc;
};if _ecb &0x04!=0{_agf [_ecb ]|=0x30;};if _ecb &0x08!=0{_agf [_ecb ]|=0xc0;};if _ecb &0x10!=0{_agf [_ecb ]|=0x300;};if _ecb &0x20!=0{_agf [_ecb ]|=0xc00;};if _ecb &0x40!=0{_agf [_ecb ]|=0x3000;};if _ecb &0x80!=0{_agf [_ecb ]|=0xc000;};};return _agf ;};
func AutoThresholdTriangle (histogram [256]int )uint8 {var _gagb ,_egab ,_gcff ,_gadb int ;for _eafeg :=0;_eafeg < len (histogram );_eafeg ++{if histogram [_eafeg ]> 0{_gagb =_eafeg ;break ;};};if _gagb > 0{_gagb --;};for _fffd :=255;_fffd > 0;_fffd --{if histogram [_fffd ]> 0{_gadb =_fffd ;
break ;};};if _gadb < 255{_gadb ++;};for _fbga :=0;_fbga < 256;_fbga ++{if histogram [_fbga ]> _egab {_gcff =_fbga ;_egab =histogram [_fbga ];};};var _fbdfg bool ;if (_gcff -_gagb )< (_gadb -_gcff ){_fbdfg =true ;var _bebff int ;_cbba :=255;for _bebff < _cbba {_cbdee :=histogram [_bebff ];
histogram [_bebff ]=histogram [_cbba ];histogram [_cbba ]=_cbdee ;_bebff ++;_cbba --;};_gagb =255-_gadb ;_gcff =255-_gcff ;};if _gagb ==_gcff {return uint8 (_gagb );};_dadg :=float64 (histogram [_gcff ]);_dbge :=float64 (_gagb -_gcff );_ccae :=_ed .Sqrt (_dadg *_dadg +_dbge *_dbge );
_dadg /=_ccae ;_dbge /=_ccae ;_ccae =_dadg *float64 (_gagb )+_dbge *float64 (histogram [_gagb ]);_cfdfe :=_gagb ;var _ffea float64 ;for _cgdg :=_gagb +1;_cgdg <=_gcff ;_cgdg ++{_ccde :=_dadg *float64 (_cgdg )+_dbge *float64 (histogram [_cgdg ])-_ccae ;
if _ccde > _ffea {_cfdfe =_cgdg ;_ffea =_ccde ;};};_cfdfe --;if _fbdfg {var _acbg int ;_agbe :=255;for _acbg < _agbe {_cfee :=histogram [_acbg ];histogram [_acbg ]=histogram [_agbe ];histogram [_agbe ]=_cfee ;_acbg ++;_agbe --;};return uint8 (255-_cfdfe );
};return uint8 (_cfdfe );};func (_fagc *Monochrome )clearBit (_abdf ,_fbda int ){_fagc .Data [_abdf ]&=^(0x80>>uint (_fbda &7))};func _egg (_gadg _g .Gray )_g .NRGBA {return _g .NRGBA {R :_gadg .Y ,G :_gadg .Y ,B :_gadg .Y ,A :0xff}};func (_ada *Monochrome )setGray (_gfbb int ,_fgcgc _g .Gray ,_fbfg int ){if _fgcgc .Y ==0{_ada .clearBit (_fbfg ,_gfbb );
}else {_ada .setGrayBit (_fbfg ,_gfbb );};};func _aage (_efdb Gray ,_bcfc NRGBA ,_acfd _f .Rectangle ){for _ecfac :=0;_ecfac < _acfd .Max .X ;_ecfac ++{for _aadfc :=0;_aadfc < _acfd .Max .Y ;_aadfc ++{_eabaa :=_efdb .GrayAt (_ecfac ,_aadfc );_bcfc .SetNRGBA (_ecfac ,_aadfc ,_egg (_eabaa ));
};};};func (_eaeb *Gray16 )GrayAt (x ,y int )_g .Gray {_ecac ,_ :=_eaeb .ColorAt (x ,y );return _g .Gray {Y :uint8 (_ecac .(_g .Gray16 ).Y >>8)};};var _ Image =&NRGBA16 {};type NRGBA interface{NRGBAAt (_gegf ,_eadf int )_g .NRGBA ;SetNRGBA (_deac ,_bfdd int ,_gffe _g .NRGBA );
};func NewImage (width ,height ,bitsPerComponent ,colorComponents int ,data ,alpha []byte ,decode []float64 )(Image ,error ){_cfaf :=NewImageBase (width ,height ,bitsPerComponent ,colorComponents ,data ,alpha ,decode );var _aaag Image ;switch colorComponents {case 1:switch bitsPerComponent {case 1:_aaag =&Monochrome {ImageBase :_cfaf ,ModelThreshold :0x0f};
case 2:_aaag =&Gray2 {ImageBase :_cfaf };case 4:_aaag =&Gray4 {ImageBase :_cfaf };case 8:_aaag =&Gray8 {ImageBase :_cfaf };case 16:_aaag =&Gray16 {ImageBase :_cfaf };};case 3:switch bitsPerComponent {case 4:_aaag =&NRGBA16 {ImageBase :_cfaf };case 8:_aaag =&NRGBA32 {ImageBase :_cfaf };
case 16:_aaag =&NRGBA64 {ImageBase :_cfaf };};case 4:_aaag =&CMYK32 {ImageBase :_cfaf };};if _aaag ==nil {return nil ,ErrInvalidImage ;};return _aaag ,nil ;};func _acff (_agc _g .NRGBA64 )_g .NRGBA {return _g .NRGBA {R :uint8 (_agc .R >>8),G :uint8 (_agc .G >>8),B :uint8 (_agc .B >>8),A :uint8 (_agc .A >>8)};
};func (_cff *NRGBA32 )ColorModel ()_g .Model {return _g .NRGBAModel };func _aeed (_fgccd ,_aeged uint8 )uint8 {if _fgccd < _aeged {return 255;};return 0;};func (_ecbc *Gray4 )Copy ()Image {return &Gray4 {ImageBase :_ecbc .copy ()}};func (_adbae *NRGBA16 )Bounds ()_f .Rectangle {return _f .Rectangle {Max :_f .Point {X :_adbae .Width ,Y :_adbae .Height }};
};func _aacac (_cade *Monochrome ,_aga ,_gega ,_gfee ,_ddag int ,_bcde RasterOperator ,_ebgb *Monochrome ,_eedde ,_ceaa int )error {var (_bffg bool ;_ebfd bool ;_dcfd byte ;_ffcba int ;_aabe int ;_dadd int ;_ccad int ;_abfcb bool ;_bggfa int ;_fedg int ;
_gccff int ;_fffe bool ;_abfaa byte ;_gfbga int ;_begf int ;_efbca int ;_afc byte ;_abfe int ;_fabgg int ;_cadf uint ;_afda uint ;_baff byte ;_fged shift ;_egac bool ;_cdde bool ;_dabac ,_gace int ;);if _eedde &7!=0{_fabgg =8-(_eedde &7);};if _aga &7!=0{_aabe =8-(_aga &7);
};if _fabgg ==0&&_aabe ==0{_baff =_befa [0];}else {if _aabe > _fabgg {_cadf =uint (_aabe -_fabgg );}else {_cadf =uint (8-(_fabgg -_aabe ));};_afda =8-_cadf ;_baff =_befa [_cadf ];};if (_aga &7)!=0{_bffg =true ;_ffcba =8-(_aga &7);_dcfd =_befa [_ffcba ];
_dadd =_cade .BytesPerLine *_gega +(_aga >>3);_ccad =_ebgb .BytesPerLine *_ceaa +(_eedde >>3);_abfe =8-(_eedde &7);if _ffcba > _abfe {_fged =_fdcgf ;if _gfee >=_fabgg {_egac =true ;};}else {_fged =_gaffg ;};};if _gfee < _ffcba {_ebfd =true ;_dcfd &=_gbcf [8-_ffcba +_gfee ];
};if !_ebfd {_bggfa =(_gfee -_ffcba )>>3;if _bggfa !=0{_abfcb =true ;_fedg =_cade .BytesPerLine *_gega +((_aga +_aabe )>>3);_gccff =_ebgb .BytesPerLine *_ceaa +((_eedde +_aabe )>>3);};};_gfbga =(_aga +_gfee )&7;if !(_ebfd ||_gfbga ==0){_fffe =true ;_abfaa =_gbcf [_gfbga ];
_begf =_cade .BytesPerLine *_gega +((_aga +_aabe )>>3)+_bggfa ;_efbca =_ebgb .BytesPerLine *_ceaa +((_eedde +_aabe )>>3)+_bggfa ;if _gfbga > int (_afda ){_cdde =true ;};};switch _bcde {case PixSrc :if _bffg {for _dabac =0;_dabac < _ddag ;_dabac ++{if _fged ==_fdcgf {_afc =_ebgb .Data [_ccad ]<<_cadf ;
if _egac {_afc =_fage (_afc ,_ebgb .Data [_ccad +1]>>_afda ,_baff );};}else {_afc =_ebgb .Data [_ccad ]>>_afda ;};_cade .Data [_dadd ]=_fage (_cade .Data [_dadd ],_afc ,_dcfd );_dadd +=_cade .BytesPerLine ;_ccad +=_ebgb .BytesPerLine ;};};if _abfcb {for _dabac =0;
_dabac < _ddag ;_dabac ++{for _gace =0;_gace < _bggfa ;_gace ++{_afc =_fage (_ebgb .Data [_gccff +_gace ]<<_cadf ,_ebgb .Data [_gccff +_gace +1]>>_afda ,_baff );_cade .Data [_fedg +_gace ]=_afc ;};_fedg +=_cade .BytesPerLine ;_gccff +=_ebgb .BytesPerLine ;
};};if _fffe {for _dabac =0;_dabac < _ddag ;_dabac ++{_afc =_ebgb .Data [_efbca ]<<_cadf ;if _cdde {_afc =_fage (_afc ,_ebgb .Data [_efbca +1]>>_afda ,_baff );};_cade .Data [_begf ]=_fage (_cade .Data [_begf ],_afc ,_abfaa );_begf +=_cade .BytesPerLine ;
_efbca +=_ebgb .BytesPerLine ;};};case PixNotSrc :if _bffg {for _dabac =0;_dabac < _ddag ;_dabac ++{if _fged ==_fdcgf {_afc =_ebgb .Data [_ccad ]<<_cadf ;if _egac {_afc =_fage (_afc ,_ebgb .Data [_ccad +1]>>_afda ,_baff );};}else {_afc =_ebgb .Data [_ccad ]>>_afda ;
};_cade .Data [_dadd ]=_fage (_cade .Data [_dadd ],^_afc ,_dcfd );_dadd +=_cade .BytesPerLine ;_ccad +=_ebgb .BytesPerLine ;};};if _abfcb {for _dabac =0;_dabac < _ddag ;_dabac ++{for _gace =0;_gace < _bggfa ;_gace ++{_afc =_fage (_ebgb .Data [_gccff +_gace ]<<_cadf ,_ebgb .Data [_gccff +_gace +1]>>_afda ,_baff );
_cade .Data [_fedg +_gace ]=^_afc ;};_fedg +=_cade .BytesPerLine ;_gccff +=_ebgb .BytesPerLine ;};};if _fffe {for _dabac =0;_dabac < _ddag ;_dabac ++{_afc =_ebgb .Data [_efbca ]<<_cadf ;if _cdde {_afc =_fage (_afc ,_ebgb .Data [_efbca +1]>>_afda ,_baff );
};_cade .Data [_begf ]=_fage (_cade .Data [_begf ],^_afc ,_abfaa );_begf +=_cade .BytesPerLine ;_efbca +=_ebgb .BytesPerLine ;};};case PixSrcOrDst :if _bffg {for _dabac =0;_dabac < _ddag ;_dabac ++{if _fged ==_fdcgf {_afc =_ebgb .Data [_ccad ]<<_cadf ;
if _egac {_afc =_fage (_afc ,_ebgb .Data [_ccad +1]>>_afda ,_baff );};}else {_afc =_ebgb .Data [_ccad ]>>_afda ;};_cade .Data [_dadd ]=_fage (_cade .Data [_dadd ],_afc |_cade .Data [_dadd ],_dcfd );_dadd +=_cade .BytesPerLine ;_ccad +=_ebgb .BytesPerLine ;
};};if _abfcb {for _dabac =0;_dabac < _ddag ;_dabac ++{for _gace =0;_gace < _bggfa ;_gace ++{_afc =_fage (_ebgb .Data [_gccff +_gace ]<<_cadf ,_ebgb .Data [_gccff +_gace +1]>>_afda ,_baff );_cade .Data [_fedg +_gace ]|=_afc ;};_fedg +=_cade .BytesPerLine ;
_gccff +=_ebgb .BytesPerLine ;};};if _fffe {for _dabac =0;_dabac < _ddag ;_dabac ++{_afc =_ebgb .Data [_efbca ]<<_cadf ;if _cdde {_afc =_fage (_afc ,_ebgb .Data [_efbca +1]>>_afda ,_baff );};_cade .Data [_begf ]=_fage (_cade .Data [_begf ],_afc |_cade .Data [_begf ],_abfaa );
_begf +=_cade .BytesPerLine ;_efbca +=_ebgb .BytesPerLine ;};};case PixSrcAndDst :if _bffg {for _dabac =0;_dabac < _ddag ;_dabac ++{if _fged ==_fdcgf {_afc =_ebgb .Data [_ccad ]<<_cadf ;if _egac {_afc =_fage (_afc ,_ebgb .Data [_ccad +1]>>_afda ,_baff );
};}else {_afc =_ebgb .Data [_ccad ]>>_afda ;};_cade .Data [_dadd ]=_fage (_cade .Data [_dadd ],_afc &_cade .Data [_dadd ],_dcfd );_dadd +=_cade .BytesPerLine ;_ccad +=_ebgb .BytesPerLine ;};};if _abfcb {for _dabac =0;_dabac < _ddag ;_dabac ++{for _gace =0;
_gace < _bggfa ;_gace ++{_afc =_fage (_ebgb .Data [_gccff +_gace ]<<_cadf ,_ebgb .Data [_gccff +_gace +1]>>_afda ,_baff );_cade .Data [_fedg +_gace ]&=_afc ;};_fedg +=_cade .BytesPerLine ;_gccff +=_ebgb .BytesPerLine ;};};if _fffe {for _dabac =0;_dabac < _ddag ;
_dabac ++{_afc =_ebgb .Data [_efbca ]<<_cadf ;if _cdde {_afc =_fage (_afc ,_ebgb .Data [_efbca +1]>>_afda ,_baff );};_cade .Data [_begf ]=_fage (_cade .Data [_begf ],_afc &_cade .Data [_begf ],_abfaa );_begf +=_cade .BytesPerLine ;_efbca +=_ebgb .BytesPerLine ;
};};case PixSrcXorDst :if _bffg {for _dabac =0;_dabac < _ddag ;_dabac ++{if _fged ==_fdcgf {_afc =_ebgb .Data [_ccad ]<<_cadf ;if _egac {_afc =_fage (_afc ,_ebgb .Data [_ccad +1]>>_afda ,_baff );};}else {_afc =_ebgb .Data [_ccad ]>>_afda ;};_cade .Data [_dadd ]=_fage (_cade .Data [_dadd ],_afc ^_cade .Data [_dadd ],_dcfd );
_dadd +=_cade .BytesPerLine ;_ccad +=_ebgb .BytesPerLine ;};};if _abfcb {for _dabac =0;_dabac < _ddag ;_dabac ++{for _gace =0;_gace < _bggfa ;_gace ++{_afc =_fage (_ebgb .Data [_gccff +_gace ]<<_cadf ,_ebgb .Data [_gccff +_gace +1]>>_afda ,_baff );_cade .Data [_fedg +_gace ]^=_afc ;
};_fedg +=_cade .BytesPerLine ;_gccff +=_ebgb .BytesPerLine ;};};if _fffe {for _dabac =0;_dabac < _ddag ;_dabac ++{_afc =_ebgb .Data [_efbca ]<<_cadf ;if _cdde {_afc =_fage (_afc ,_ebgb .Data [_efbca +1]>>_afda ,_baff );};_cade .Data [_begf ]=_fage (_cade .Data [_begf ],_afc ^_cade .Data [_begf ],_abfaa );
_begf +=_cade .BytesPerLine ;_efbca +=_ebgb .BytesPerLine ;};};case PixNotSrcOrDst :if _bffg {for _dabac =0;_dabac < _ddag ;_dabac ++{if _fged ==_fdcgf {_afc =_ebgb .Data [_ccad ]<<_cadf ;if _egac {_afc =_fage (_afc ,_ebgb .Data [_ccad +1]>>_afda ,_baff );
};}else {_afc =_ebgb .Data [_ccad ]>>_afda ;};_cade .Data [_dadd ]=_fage (_cade .Data [_dadd ],^_afc |_cade .Data [_dadd ],_dcfd );_dadd +=_cade .BytesPerLine ;_ccad +=_ebgb .BytesPerLine ;};};if _abfcb {for _dabac =0;_dabac < _ddag ;_dabac ++{for _gace =0;
_gace < _bggfa ;_gace ++{_afc =_fage (_ebgb .Data [_gccff +_gace ]<<_cadf ,_ebgb .Data [_gccff +_gace +1]>>_afda ,_baff );_cade .Data [_fedg +_gace ]|=^_afc ;};_fedg +=_cade .BytesPerLine ;_gccff +=_ebgb .BytesPerLine ;};};if _fffe {for _dabac =0;_dabac < _ddag ;
_dabac ++{_afc =_ebgb .Data [_efbca ]<<_cadf ;if _cdde {_afc =_fage (_afc ,_ebgb .Data [_efbca +1]>>_afda ,_baff );};_cade .Data [_begf ]=_fage (_cade .Data [_begf ],^_afc |_cade .Data [_begf ],_abfaa );_begf +=_cade .BytesPerLine ;_efbca +=_ebgb .BytesPerLine ;
};};case PixNotSrcAndDst :if _bffg {for _dabac =0;_dabac < _ddag ;_dabac ++{if _fged ==_fdcgf {_afc =_ebgb .Data [_ccad ]<<_cadf ;if _egac {_afc =_fage (_afc ,_ebgb .Data [_ccad +1]>>_afda ,_baff );};}else {_afc =_ebgb .Data [_ccad ]>>_afda ;};_cade .Data [_dadd ]=_fage (_cade .Data [_dadd ],^_afc &_cade .Data [_dadd ],_dcfd );
_dadd +=_cade .BytesPerLine ;_ccad +=_ebgb .BytesPerLine ;};};if _abfcb {for _dabac =0;_dabac < _ddag ;_dabac ++{for _gace =0;_gace < _bggfa ;_gace ++{_afc =_fage (_ebgb .Data [_gccff +_gace ]<<_cadf ,_ebgb .Data [_gccff +_gace +1]>>_afda ,_baff );_cade .Data [_fedg +_gace ]&=^_afc ;
};_fedg +=_cade .BytesPerLine ;_gccff +=_ebgb .BytesPerLine ;};};if _fffe {for _dabac =0;_dabac < _ddag ;_dabac ++{_afc =_ebgb .Data [_efbca ]<<_cadf ;if _cdde {_afc =_fage (_afc ,_ebgb .Data [_efbca +1]>>_afda ,_baff );};_cade .Data [_begf ]=_fage (_cade .Data [_begf ],^_afc &_cade .Data [_begf ],_abfaa );
_begf +=_cade .BytesPerLine ;_efbca +=_ebgb .BytesPerLine ;};};case PixSrcOrNotDst :if _bffg {for _dabac =0;_dabac < _ddag ;_dabac ++{if _fged ==_fdcgf {_afc =_ebgb .Data [_ccad ]<<_cadf ;if _egac {_afc =_fage (_afc ,_ebgb .Data [_ccad +1]>>_afda ,_baff );
};}else {_afc =_ebgb .Data [_ccad ]>>_afda ;};_cade .Data [_dadd ]=_fage (_cade .Data [_dadd ],_afc |^_cade .Data [_dadd ],_dcfd );_dadd +=_cade .BytesPerLine ;_ccad +=_ebgb .BytesPerLine ;};};if _abfcb {for _dabac =0;_dabac < _ddag ;_dabac ++{for _gace =0;
_gace < _bggfa ;_gace ++{_afc =_fage (_ebgb .Data [_gccff +_gace ]<<_cadf ,_ebgb .Data [_gccff +_gace +1]>>_afda ,_baff );_cade .Data [_fedg +_gace ]=_afc |^_cade .Data [_fedg +_gace ];};_fedg +=_cade .BytesPerLine ;_gccff +=_ebgb .BytesPerLine ;};};if _fffe {for _dabac =0;
_dabac < _ddag ;_dabac ++{_afc =_ebgb .Data [_efbca ]<<_cadf ;if _cdde {_afc =_fage (_afc ,_ebgb .Data [_efbca +1]>>_afda ,_baff );};_cade .Data [_begf ]=_fage (_cade .Data [_begf ],_afc |^_cade .Data [_begf ],_abfaa );_begf +=_cade .BytesPerLine ;_efbca +=_ebgb .BytesPerLine ;
};};case PixSrcAndNotDst :if _bffg {for _dabac =0;_dabac < _ddag ;_dabac ++{if _fged ==_fdcgf {_afc =_ebgb .Data [_ccad ]<<_cadf ;if _egac {_afc =_fage (_afc ,_ebgb .Data [_ccad +1]>>_afda ,_baff );};}else {_afc =_ebgb .Data [_ccad ]>>_afda ;};_cade .Data [_dadd ]=_fage (_cade .Data [_dadd ],_afc &^_cade .Data [_dadd ],_dcfd );
_dadd +=_cade .BytesPerLine ;_ccad +=_ebgb .BytesPerLine ;};};if _abfcb {for _dabac =0;_dabac < _ddag ;_dabac ++{for _gace =0;_gace < _bggfa ;_gace ++{_afc =_fage (_ebgb .Data [_gccff +_gace ]<<_cadf ,_ebgb .Data [_gccff +_gace +1]>>_afda ,_baff );_cade .Data [_fedg +_gace ]=_afc &^_cade .Data [_fedg +_gace ];
};_fedg +=_cade .BytesPerLine ;_gccff +=_ebgb .BytesPerLine ;};};if _fffe {for _dabac =0;_dabac < _ddag ;_dabac ++{_afc =_ebgb .Data [_efbca ]<<_cadf ;if _cdde {_afc =_fage (_afc ,_ebgb .Data [_efbca +1]>>_afda ,_baff );};_cade .Data [_begf ]=_fage (_cade .Data [_begf ],_afc &^_cade .Data [_begf ],_abfaa );
_begf +=_cade .BytesPerLine ;_efbca +=_ebgb .BytesPerLine ;};};case PixNotPixSrcOrDst :if _bffg {for _dabac =0;_dabac < _ddag ;_dabac ++{if _fged ==_fdcgf {_afc =_ebgb .Data [_ccad ]<<_cadf ;if _egac {_afc =_fage (_afc ,_ebgb .Data [_ccad +1]>>_afda ,_baff );
};}else {_afc =_ebgb .Data [_ccad ]>>_afda ;};_cade .Data [_dadd ]=_fage (_cade .Data [_dadd ],^(_afc |_cade .Data [_dadd ]),_dcfd );_dadd +=_cade .BytesPerLine ;_ccad +=_ebgb .BytesPerLine ;};};if _abfcb {for _dabac =0;_dabac < _ddag ;_dabac ++{for _gace =0;
_gace < _bggfa ;_gace ++{_afc =_fage (_ebgb .Data [_gccff +_gace ]<<_cadf ,_ebgb .Data [_gccff +_gace +1]>>_afda ,_baff );_cade .Data [_fedg +_gace ]=^(_afc |_cade .Data [_fedg +_gace ]);};_fedg +=_cade .BytesPerLine ;_gccff +=_ebgb .BytesPerLine ;};};
if _fffe {for _dabac =0;_dabac < _ddag ;_dabac ++{_afc =_ebgb .Data [_efbca ]<<_cadf ;if _cdde {_afc =_fage (_afc ,_ebgb .Data [_efbca +1]>>_afda ,_baff );};_cade .Data [_begf ]=_fage (_cade .Data [_begf ],^(_afc |_cade .Data [_begf ]),_abfaa );_begf +=_cade .BytesPerLine ;
_efbca +=_ebgb .BytesPerLine ;};};case PixNotPixSrcAndDst :if _bffg {for _dabac =0;_dabac < _ddag ;_dabac ++{if _fged ==_fdcgf {_afc =_ebgb .Data [_ccad ]<<_cadf ;if _egac {_afc =_fage (_afc ,_ebgb .Data [_ccad +1]>>_afda ,_baff );};}else {_afc =_ebgb .Data [_ccad ]>>_afda ;
};_cade .Data [_dadd ]=_fage (_cade .Data [_dadd ],^(_afc &_cade .Data [_dadd ]),_dcfd );_dadd +=_cade .BytesPerLine ;_ccad +=_ebgb .BytesPerLine ;};};if _abfcb {for _dabac =0;_dabac < _ddag ;_dabac ++{for _gace =0;_gace < _bggfa ;_gace ++{_afc =_fage (_ebgb .Data [_gccff +_gace ]<<_cadf ,_ebgb .Data [_gccff +_gace +1]>>_afda ,_baff );
_cade .Data [_fedg +_gace ]=^(_afc &_cade .Data [_fedg +_gace ]);};_fedg +=_cade .BytesPerLine ;_gccff +=_ebgb .BytesPerLine ;};};if _fffe {for _dabac =0;_dabac < _ddag ;_dabac ++{_afc =_ebgb .Data [_efbca ]<<_cadf ;if _cdde {_afc =_fage (_afc ,_ebgb .Data [_efbca +1]>>_afda ,_baff );
};_cade .Data [_begf ]=_fage (_cade .Data [_begf ],^(_afc &_cade .Data [_begf ]),_abfaa );_begf +=_cade .BytesPerLine ;_efbca +=_ebgb .BytesPerLine ;};};case PixNotPixSrcXorDst :if _bffg {for _dabac =0;_dabac < _ddag ;_dabac ++{if _fged ==_fdcgf {_afc =_ebgb .Data [_ccad ]<<_cadf ;
if _egac {_afc =_fage (_afc ,_ebgb .Data [_ccad +1]>>_afda ,_baff );};}else {_afc =_ebgb .Data [_ccad ]>>_afda ;};_cade .Data [_dadd ]=_fage (_cade .Data [_dadd ],^(_afc ^_cade .Data [_dadd ]),_dcfd );_dadd +=_cade .BytesPerLine ;_ccad +=_ebgb .BytesPerLine ;
};};if _abfcb {for _dabac =0;_dabac < _ddag ;_dabac ++{for _gace =0;_gace < _bggfa ;_gace ++{_afc =_fage (_ebgb .Data [_gccff +_gace ]<<_cadf ,_ebgb .Data [_gccff +_gace +1]>>_afda ,_baff );_cade .Data [_fedg +_gace ]=^(_afc ^_cade .Data [_fedg +_gace ]);
};_fedg +=_cade .BytesPerLine ;_gccff +=_ebgb .BytesPerLine ;};};if _fffe {for _dabac =0;_dabac < _ddag ;_dabac ++{_afc =_ebgb .Data [_efbca ]<<_cadf ;if _cdde {_afc =_fage (_afc ,_ebgb .Data [_efbca +1]>>_afda ,_baff );};_cade .Data [_begf ]=_fage (_cade .Data [_begf ],^(_afc ^_cade .Data [_begf ]),_abfaa );
_begf +=_cade .BytesPerLine ;_efbca +=_ebgb .BytesPerLine ;};};default:_gf .Log .Debug ("\u004f\u0070e\u0072\u0061\u0074\u0069\u006f\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006e\u006f\u0074\u0020\u0070\u0065\u0072\u006d\u0069tt\u0065\u0064",_bcde );
return _a .New ("\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065r\u0061\u0074\u0069\u006f\u006e\u0020\u006eo\u0074\u0020\u0070\u0065\u0072\u006d\u0069\u0074\u0074\u0065\u0064");};return nil ;};type Gray2 struct{ImageBase };func (_cggd *Gray4 )Bounds ()_f .Rectangle {return _f .Rectangle {Max :_f .Point {X :_cggd .Width ,Y :_cggd .Height }};
};func _eec (_bfgd _g .Gray ,_cbdd monochromeModel )_g .Gray {if _bfgd .Y > uint8 (_cbdd ){return _g .Gray {Y :_ed .MaxUint8 };};return _g .Gray {};};func (_acaa *CMYK32 )Base ()*ImageBase {return &_acaa .ImageBase };func _dcba (_ccb *_f .NYCbCrA ,_fgdd RGBA ,_egeg _f .Rectangle ){for _cdggb :=0;
_cdggb < _egeg .Max .X ;_cdggb ++{for _efcc :=0;_efcc < _egeg .Max .Y ;_efcc ++{_acfa :=_ccb .NYCbCrAAt (_cdggb ,_efcc );_fgdd .SetRGBA (_cdggb ,_efcc ,_edae (_acfa ));};};};func IsPowerOf2 (n uint )bool {return n > 0&&(n &(n -1))==0};func (_bdga *RGBA32 )setRGBA (_dgdg int ,_efga _g .RGBA ){_ddbe :=3*_dgdg ;
_bdga .Data [_ddbe ]=_efga .R ;_bdga .Data [_ddbe +1]=_efga .G ;_bdga .Data [_ddbe +2]=_efga .B ;if _dgdg < len (_bdga .Alpha ){_bdga .Alpha [_dgdg ]=_efga .A ;};};func (_caef *NRGBA32 )Base ()*ImageBase {return &_caef .ImageBase };func (_efag *Monochrome )Bounds ()_f .Rectangle {return _f .Rectangle {Max :_f .Point {X :_efag .Width ,Y :_efag .Height }};
};func _bca (_acbbb _g .NRGBA )_g .Gray {var _fbcg _g .NRGBA ;if _acbbb ==_fbcg {return _g .Gray {Y :0xff};};_gffg ,_dega ,_acbf ,_ :=_acbbb .RGBA ();_bbdd :=(19595*_gffg +38470*_dega +7471*_acbf +1<<15)>>24;return _g .Gray {Y :uint8 (_bbdd )};};func _bcfbb (_gggcd _g .Color )_g .Color {_gfbc :=_g .GrayModel .Convert (_gggcd ).(_g .Gray );
return _eeff (_gfbc );};func _gdcb (_egce _g .NRGBA )_g .NRGBA {_egce .R =_egce .R >>4|(_egce .R >>4)<<4;_egce .G =_egce .G >>4|(_egce .G >>4)<<4;_egce .B =_egce .B >>4|(_egce .B >>4)<<4;return _egce ;};func (_ddad *Monochrome )Base ()*ImageBase {return &_ddad .ImageBase };
func (_gcbg *NRGBA32 )Bounds ()_f .Rectangle {return _f .Rectangle {Max :_f .Point {X :_gcbg .Width ,Y :_gcbg .Height }};};func _ac (_bea ,_fcg *Monochrome )(_bdd error ){_efb :=_fcg .BytesPerLine ;_ccg :=_bea .BytesPerLine ;_fd :=_fcg .BytesPerLine *4-_bea .BytesPerLine ;
var (_bb ,_bba byte ;_fg uint32 ;_ge ,_cf ,_gb ,_abe ,_baa ,_beb ,_dd int ;);for _gb =0;_gb < _fcg .Height ;_gb ++{_ge =_gb *_efb ;_cf =4*_gb *_ccg ;for _abe =0;_abe < _efb ;_abe ++{_bb =_fcg .Data [_ge +_abe ];_fg =_ddb [_bb ];_beb =_cf +_abe *4;if _fd !=0&&(_abe +1)*4> _bea .BytesPerLine {for _baa =_fd ;
_baa > 0;_baa --{_bba =byte ((_fg >>uint (_baa *8))&0xff);_dd =_beb +(_fd -_baa );if _bdd =_bea .setByte (_dd ,_bba );_bdd !=nil {return _bdd ;};};}else if _bdd =_bea .setFourBytes (_beb ,_fg );_bdd !=nil {return _bdd ;};if _bdd =_bea .setFourBytes (_cf +_abe *4,_ddb [_fcg .Data [_ge +_abe ]]);
_bdd !=nil {return _bdd ;};};for _baa =1;_baa < 4;_baa ++{for _abe =0;_abe < _ccg ;_abe ++{if _bdd =_bea .setByte (_cf +_baa *_ccg +_abe ,_bea .Data [_cf +_abe ]);_bdd !=nil {return _bdd ;};};};};return nil ;};func (_acee *Gray2 )Validate ()error {if len (_acee .Data )!=_acee .Height *_acee .BytesPerLine {return ErrInvalidImage ;
};return nil ;};func _dcca (_eaea *_f .Gray16 ,_beedb uint8 )*_f .Gray {_ddac :=_eaea .Bounds ();_gaee :=_f .NewGray (_ddac );for _feab :=0;_feab < _ddac .Dx ();_feab ++{for _gcfc :=0;_gcfc < _ddac .Dy ();_gcfc ++{_bdfg :=_eaea .Gray16At (_feab ,_gcfc );
_gaee .SetGray (_feab ,_gcfc ,_g .Gray {Y :_aeed (uint8 (_bdfg .Y /256),_beedb )});};};return _gaee ;};func (_eagb *RGBA32 )RGBAAt (x ,y int )_g .RGBA {_dccg ,_ :=ColorAtRGBA32 (x ,y ,_eagb .Width ,_eagb .Data ,_eagb .Alpha ,_eagb .Decode );return _dccg ;
};func _gfde (_agb ,_afbf NRGBA ,_dagce _f .Rectangle ){for _afcc :=0;_afcc < _dagce .Max .X ;_afcc ++{for _egga :=0;_egga < _dagce .Max .Y ;_egga ++{_afbf .SetNRGBA (_afcc ,_egga ,_agb .NRGBAAt (_afcc ,_egga ));};};};var _ Image =&NRGBA32 {};func (_eadb *RGBA32 )Bounds ()_f .Rectangle {return _f .Rectangle {Max :_f .Point {X :_eadb .Width ,Y :_eadb .Height }};
};func (_abcfg *Monochrome )setIndexedBit (_cfce int ){_abcfg .Data [(_cfce >>3)]|=0x80>>uint (_cfce &7);};type Gray16 struct{ImageBase };func (_egb *ImageBase )setEightBytes (_dafc int ,_ecc uint64 )error {_ccag :=_egb .BytesPerLine -(_dafc %_egb .BytesPerLine );
if _egb .BytesPerLine !=_egb .Width >>3{_ccag --;};if _ccag >=8{return _egb .setEightFullBytes (_dafc ,_ecc );};return _egb .setEightPartlyBytes (_dafc ,_ccag ,_ecc );};func (_gffd *RGBA32 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtRGBA32 (x ,y ,_gffd .Width ,_gffd .Data ,_gffd .Alpha ,_gffd .Decode );
};func LinearInterpolate (x ,xmin ,xmax ,ymin ,ymax float64 )float64 {if _ed .Abs (xmax -xmin )< 0.000001{return ymin ;};_bcgg :=ymin +(x -xmin )*(ymax -ymin )/(xmax -xmin );return _bcgg ;};func _edf (_ff *Monochrome ,_ce int )(*Monochrome ,error ){if _ff ==nil {return nil ,_a .New ("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064");
};if _ce ==1{return _ff .copy (),nil ;};if !IsPowerOf2 (uint (_ce )){return nil ,_ef .Errorf ("\u0070\u0072\u006fvi\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006ci\u0064 \u0065x\u0070a\u006e\u0064\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_ce );
};_ad :=_agg (_ce );return _fa (_ff ,_ce ,_ad );};func (_bbae *NRGBA64 )setNRGBA64 (_efef int ,_eega _g .NRGBA64 ,_eafbc int ){_bbae .Data [_efef ]=uint8 (_eega .R >>8);_bbae .Data [_efef +1]=uint8 (_eega .R &0xff);_bbae .Data [_efef +2]=uint8 (_eega .G >>8);
_bbae .Data [_efef +3]=uint8 (_eega .G &0xff);_bbae .Data [_efef +4]=uint8 (_eega .B >>8);_bbae .Data [_efef +5]=uint8 (_eega .B &0xff);if _eafbc +1< len (_bbae .Alpha ){_bbae .Alpha [_eafbc ]=uint8 (_eega .A >>8);_bbae .Alpha [_eafbc +1]=uint8 (_eega .A &0xff);
};};func _dda (_afed _g .RGBA )_g .NRGBA {switch _afed .A {case 0xff:return _g .NRGBA {R :_afed .R ,G :_afed .G ,B :_afed .B ,A :0xff};case 0x00:return _g .NRGBA {};default:_cebbee ,_defe ,_eaba ,_eff :=_afed .RGBA ();_cebbee =(_cebbee *0xffff)/_eff ;_defe =(_defe *0xffff)/_eff ;
_eaba =(_eaba *0xffff)/_eff ;return _g .NRGBA {R :uint8 (_cebbee >>8),G :uint8 (_defe >>8),B :uint8 (_eaba >>8),A :uint8 (_eff >>8)};};};type RGBA32 struct{ImageBase };func (_ecae *Monochrome )GrayAt (x ,y int )_g .Gray {_gefe ,_ :=ColorAtGray1BPC (x ,y ,_ecae .BytesPerLine ,_ecae .Data ,_ecae .Decode );
return _gefe ;};func _bfbe (_gfaa *Monochrome ,_ffeb ,_dbec ,_ddfb ,_bcag int ,_cddg RasterOperator ){if _ffeb < 0{_ddfb +=_ffeb ;_ffeb =0;};_faedg :=_ffeb +_ddfb -_gfaa .Width ;if _faedg > 0{_ddfb -=_faedg ;};if _dbec < 0{_bcag +=_dbec ;_dbec =0;};_beae :=_dbec +_bcag -_gfaa .Height ;
if _beae > 0{_bcag -=_beae ;};if _ddfb <=0||_bcag <=0{return ;};if (_ffeb &7)==0{_eafe (_gfaa ,_ffeb ,_dbec ,_ddfb ,_bcag ,_cddg );}else {_ddcd (_gfaa ,_ffeb ,_dbec ,_ddfb ,_bcag ,_cddg );};};func (_adfe *NRGBA16 )Base ()*ImageBase {return &_adfe .ImageBase };
func (_cfe *NRGBA64 )Validate ()error {if len (_cfe .Data )!=3*2*_cfe .Width *_cfe .Height {return _a .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func _cegc (_gfcd _f .Image ,_ebcaa Image ,_daea _f .Rectangle ){if _egge ,_ddggf :=_gfcd .(SMasker );_ddggf &&_egge .HasAlpha (){_ebcaa .(SMasker ).MakeAlpha ();};switch _acefe :=_gfcd .(type ){case Gray :_bgab (_acefe ,_ebcaa .(RGBA ),_daea );
case NRGBA :_ebea (_acefe ,_ebcaa .(RGBA ),_daea );case *_f .NYCbCrA :_dcba (_acefe ,_ebcaa .(RGBA ),_daea );case CMYK :_ecbf (_acefe ,_ebcaa .(RGBA ),_daea );case RGBA :_beacg (_acefe ,_ebcaa .(RGBA ),_daea );case nrgba64 :_ffdf (_acefe ,_ebcaa .(RGBA ),_daea );
default:_fbcb (_gfcd ,_ebcaa ,_daea );};};func _bddb (_bagc _f .Image ,_edaeg Image ,_acgb _f .Rectangle ){if _bcbd ,_effga :=_bagc .(SMasker );_effga &&_bcbd .HasAlpha (){_edaeg .(SMasker ).MakeAlpha ();};_fbcb (_bagc ,_edaeg ,_acgb );};func (_fdbde *RGBA32 )ColorModel ()_g .Model {return _g .NRGBAModel };
func _fbb (_ebegf _g .Gray )_g .Gray {_ggcb :=_ebegf .Y >>6;_ggcb |=_ggcb <<2;_ebegf .Y =_ggcb |_ggcb <<4;return _ebegf ;};func (_gdfa *NRGBA64 )NRGBA64At (x ,y int )_g .NRGBA64 {_ggfga ,_ :=ColorAtNRGBA64 (x ,y ,_gdfa .Width ,_gdfa .Data ,_gdfa .Alpha ,_gdfa .Decode );
return _ggfga ;};func (_dfc *Gray2 )Bounds ()_f .Rectangle {return _f .Rectangle {Max :_f .Point {X :_dfc .Width ,Y :_dfc .Height }};};type shift int ;func (_ddf *Monochrome )ExpandBinary (factor int )(*Monochrome ,error ){if !IsPowerOf2 (uint (factor )){return nil ,_ef .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0065\u0078\u0070\u0061\u006e\u0064\u0020b\u0069n\u0061\u0072\u0079\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",factor );
};return _edf (_ddf ,factor );};var _ Image =&RGBA32 {};func _fage (_ggfg ,_cdeg ,_bddde byte )byte {return (_ggfg &^(_bddde ))|(_cdeg &_bddde )};func (_ecgea *ImageBase )setEightFullBytes (_gfec int ,_fbfd uint64 )error {if _gfec +7> len (_ecgea .Data )-1{return _a .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_ecgea .Data [_gfec ]=byte ((_fbfd &0xff00000000000000)>>56);_ecgea .Data [_gfec +1]=byte ((_fbfd &0xff000000000000)>>48);_ecgea .Data [_gfec +2]=byte ((_fbfd &0xff0000000000)>>40);_ecgea .Data [_gfec +3]=byte ((_fbfd &0xff00000000)>>32);_ecgea .Data [_gfec +4]=byte ((_fbfd &0xff000000)>>24);
_ecgea .Data [_gfec +5]=byte ((_fbfd &0xff0000)>>16);_ecgea .Data [_gfec +6]=byte ((_fbfd &0xff00)>>8);_ecgea .Data [_gfec +7]=byte (_fbfd &0xff);return nil ;};func (_acc *Monochrome )setGrayBit (_abef ,_ecad int ){_acc .Data [_abef ]|=0x80>>uint (_ecad &7)};
func (_fcba *RGBA32 )At (x ,y int )_g .Color {_ffgf ,_ :=_fcba .ColorAt (x ,y );return _ffgf };func (_aagc *RGBA32 )Copy ()Image {return &RGBA32 {ImageBase :_aagc .copy ()}};func (_dfda *Monochrome )Copy ()Image {return &Monochrome {ImageBase :_dfda .ImageBase .copy (),ModelThreshold :_dfda .ModelThreshold };
};func (_ddge *Monochrome )setBit (_cdbc ,_cbge int ){_ddge .Data [_cdbc +(_cbge >>3)]|=0x80>>uint (_cbge &7);};func _bfada (_gcbf _f .Image )(Image ,error ){if _agbd ,_fdedg :=_gcbf .(*RGBA32 );_fdedg {return _agbd .Copy (),nil ;};_fdggd ,_gecg ,_fdcaf :=_fafge (_gcbf ,1);
_ebceg ,_dbda :=NewImage (_fdggd .Max .X ,_fdggd .Max .Y ,8,3,nil ,_fdcaf ,nil );if _dbda !=nil {return nil ,_dbda ;};_cegc (_gcbf ,_ebceg ,_fdggd );if len (_fdcaf )!=0&&!_gecg {if _fefdb :=_febb (_fdcaf ,_ebceg );_fefdb !=nil {return nil ,_fefdb ;};};
return _ebceg ,nil ;};func (_gcc *CMYK32 )SetCMYK (x ,y int ,c _g .CMYK ){_cfgd :=4*(y *_gcc .Width +x );if _cfgd +3>=len (_gcc .Data ){return ;};_gcc .Data [_cfgd ]=c .C ;_gcc .Data [_cfgd +1]=c .M ;_gcc .Data [_cfgd +2]=c .Y ;_gcc .Data [_cfgd +3]=c .K ;
};func _eeabg (_befb NRGBA ,_fecd Gray ,_bgcd _f .Rectangle ){for _dbbd :=0;_dbbd < _bgcd .Max .X ;_dbbd ++{for _egdc :=0;_egdc < _bgcd .Max .Y ;_egdc ++{_acca :=_fbdg (_befb .NRGBAAt (_dbbd ,_egdc ));_fecd .SetGray (_dbbd ,_egdc ,_acca );};};};func GrayHistogram (g Gray )(_fccg [256]int ){switch _fccgb :=g .(type ){case Histogramer :return _fccgb .Histogram ();
case _f .Image :_bccc :=_fccgb .Bounds ();for _gefa :=0;_gefa < _bccc .Max .X ;_gefa ++{for _agdb :=0;_agdb < _bccc .Max .Y ;_agdb ++{_fccg [g .GrayAt (_gefa ,_agdb ).Y ]++;};};return _fccg ;default:return [256]int {};};};func (_gcab *Gray16 )Base ()*ImageBase {return &_gcab .ImageBase };
func (_cgde *Gray8 )Histogram ()(_ffg [256]int ){for _cgfbe :=0;_cgfbe < len (_cgde .Data );_cgfbe ++{_ffg [_cgde .Data [_cgfbe ]]++;};return _ffg ;};func _ebea (_bafe NRGBA ,_fbge RGBA ,_cgfd _f .Rectangle ){for _fdbc :=0;_fdbc < _cgfd .Max .X ;_fdbc ++{for _fgad :=0;
_fgad < _cgfd .Max .Y ;_fgad ++{_dbae :=_bafe .NRGBAAt (_fdbc ,_fgad );_fbge .SetRGBA (_fdbc ,_fgad ,_dgdf (_dbae ));};};};func (_cbcd *Monochrome )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtGray1BPC (x ,y ,_cbcd .BytesPerLine ,_cbcd .Data ,_cbcd .Decode );
};func ColorAtGray16BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_g .Gray16 ,error ){_acdf :=(y *bytesPerLine /2+x )*2;if _acdf +1>=len (data ){return _g .Gray16 {},_ef .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_eeab :=uint16 (data [_acdf ])<<8|uint16 (data [_acdf +1]);if len (decode )==2{_eeab =uint16 (uint64 (LinearInterpolate (float64 (_eeab ),0,65535,decode [0],decode [1])));};return _g .Gray16 {Y :_eeab },nil ;};func (_bgeea *NRGBA64 )Set (x ,y int ,c _g .Color ){_edgeg :=(y *_bgeea .Width +x )*2;
_dffe :=_edgeg *3;if _dffe +5>=len (_bgeea .Data ){return ;};_cgfe :=_g .NRGBA64Model .Convert (c ).(_g .NRGBA64 );_bgeea .setNRGBA64 (_dffe ,_cgfe ,_edgeg );};func (_dgg *Monochrome )ColorModel ()_g .Model {return MonochromeModel (_dgg .ModelThreshold )};
func _abag (_bcdg _f .Image )(Image ,error ){if _aeaf ,_gggae :=_bcdg .(*NRGBA64 );_gggae {return _aeaf .Copy (),nil ;};_geab ,_geag ,_afad :=_fafge (_bcdg ,2);_abge ,_abde :=NewImage (_geab .Max .X ,_geab .Max .Y ,16,3,nil ,_afad ,nil );if _abde !=nil {return nil ,_abde ;
};_bddb (_bcdg ,_abge ,_geab );if len (_afad )!=0&&!_geag {if _bccee :=_febb (_afad ,_abge );_bccee !=nil {return nil ,_bccee ;};};return _abge ,nil ;};type NRGBA64 struct{ImageBase };func (_gfacd *NRGBA32 )SetNRGBA (x ,y int ,c _g .NRGBA ){_gffge :=y *_gfacd .Width +x ;
_accb :=3*_gffge ;if _accb +2>=len (_gfacd .Data ){return ;};_gfacd .setRGBA (_gffge ,c );};func _edadg (_ebeb _g .Color )_g .Color {_cbbca :=_g .NRGBAModel .Convert (_ebeb ).(_g .NRGBA );return _gdcb (_cbbca );};func (_dffa *NRGBA64 )SetNRGBA64 (x ,y int ,c _g .NRGBA64 ){_dcfc :=(y *_dffa .Width +x )*2;
_dbfg :=_dcfc *3;if _dbfg +5>=len (_dffa .Data ){return ;};_dffa .setNRGBA64 (_dbfg ,c ,_dcfc );};func _geec (_afec CMYK ,_bace NRGBA ,_faaea _f .Rectangle ){for _cgdc :=0;_cgdc < _faaea .Max .X ;_cgdc ++{for _fcfgf :=0;_fcfgf < _faaea .Max .Y ;_fcfgf ++{_fgfb :=_afec .CMYKAt (_cgdc ,_fcfgf );
_bace .SetNRGBA (_cgdc ,_fcfgf ,_fdd (_fgfb ));};};};func _fdd (_aag _g .CMYK )_g .NRGBA {_agfd ,_afe ,_dedf :=_g .CMYKToRGB (_aag .C ,_aag .M ,_aag .Y ,_aag .K );return _g .NRGBA {R :_agfd ,G :_afe ,B :_dedf ,A :0xff};};func _abb (_abgc _g .CMYK )_g .RGBA {_bfdf ,_bdeg ,_fea :=_g .CMYKToRGB (_abgc .C ,_abgc .M ,_abgc .Y ,_abgc .K );
return _g .RGBA {R :_bfdf ,G :_bdeg ,B :_fea ,A :0xff};};func (_fbe *CMYK32 )Validate ()error {if len (_fbe .Data )!=4*_fbe .Width *_fbe .Height {return _a .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};type Histogramer interface{Histogram ()[256]int ;};func (_adba *Gray8 )GrayAt (x ,y int )_g .Gray {_agfc ,_ :=ColorAtGray8BPC (x ,y ,_adba .BytesPerLine ,_adba .Data ,_adba .Decode );return _agfc ;};func (_baddc *Monochrome )InverseData ()error {return _baddc .RasterOperation (0,0,_baddc .Width ,_baddc .Height ,PixNotDst ,nil ,0,0);
};func MonochromeThresholdConverter (threshold uint8 )ColorConverter {return &monochromeThresholdConverter {Threshold :threshold };};func _aac (_fge *Monochrome ,_afd int ,_eeg []byte )(_fgc *Monochrome ,_ecbg error ){const _fbc ="\u0072\u0065d\u0075\u0063\u0065R\u0061\u006e\u006b\u0042\u0069\u006e\u0061\u0072\u0079";
if _fge ==nil {return nil ,_a .New ("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d");};if _afd < 1||_afd > 4{return nil ,_a .New ("\u006c\u0065\u0076\u0065\u006c\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020\u0073e\u0074\u0020\u007b\u0031\u002c\u0032\u002c\u0033\u002c\u0034\u007d");
};if _fge .Height <=1{return nil ,_a .New ("\u0073\u006f\u0075rc\u0065\u0020\u0068\u0065\u0069\u0067\u0068\u0074\u0020m\u0075s\u0074 \u0062e\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020\u0027\u0032\u0027");};_fgc =_bab (_fge .Width /2,_fge .Height /2);
if _eeg ==nil {_eeg =_fccb ();};_dab :=_eddd (_fge .BytesPerLine ,2*_fgc .BytesPerLine );switch _afd {case 1:_ecbg =_bde (_fge ,_fgc ,_eeg ,_dab );case 2:_ecbg =_bgc (_fge ,_fgc ,_eeg ,_dab );case 3:_ecbg =_gdd (_fge ,_fgc ,_eeg ,_dab );case 4:_ecbg =_eea (_fge ,_fgc ,_eeg ,_dab );
};if _ecbg !=nil {return nil ,_ecbg ;};return _fgc ,nil ;};func _gfbfa (_fbdf NRGBA ,_edea CMYK ,_ccgb _f .Rectangle ){for _cdbb :=0;_cdbb < _ccgb .Max .X ;_cdbb ++{for _ecg :=0;_ecg < _ccgb .Max .Y ;_ecg ++{_fca :=_fbdf .NRGBAAt (_cdbb ,_ecg );_edea .SetCMYK (_cdbb ,_ecg ,_gcaa (_fca ));
};};};var _ Image =&Gray2 {};func _egd (_fcb _f .Image )(Image ,error ){if _bad ,_ccgdc :=_fcb .(*CMYK32 );_ccgdc {return _bad .Copy (),nil ;};_edga :=_fcb .Bounds ();_gbbg ,_cbce :=NewImage (_edga .Max .X ,_edga .Max .Y ,8,4,nil ,nil ,nil );if _cbce !=nil {return nil ,_cbce ;
};switch _bdg :=_fcb .(type ){case CMYK :_aae (_bdg ,_gbbg .(CMYK ),_edga );case Gray :_add (_bdg ,_gbbg .(CMYK ),_edga );case NRGBA :_gfbfa (_bdg ,_gbbg .(CMYK ),_edga );case RGBA :_affa (_bdg ,_gbbg .(CMYK ),_edga );default:_fbcb (_fcb ,_gbbg ,_edga );
};return _gbbg ,nil ;};func (_bfbd *Monochrome )getBitAt (_gdgb ,_aggg int )bool {_ecfff :=_aggg *_bfbd .BytesPerLine +(_gdgb >>3);_acg :=_gdgb &0x07;_aaae :=uint (7-_acg );if _ecfff > len (_bfbd .Data )-1{return false ;};if (_bfbd .Data [_ecfff ]>>_aaae )&0x01>=1{return true ;
};return false ;};type Monochrome struct{ImageBase ;ModelThreshold uint8 ;};func (_gee *Gray8 )Validate ()error {if len (_gee .Data )!=_gee .Height *_gee .BytesPerLine {return ErrInvalidImage ;};return nil ;};func _add (_bfg Gray ,_bgaa CMYK ,_ebd _f .Rectangle ){for _gaaa :=0;
_gaaa < _ebd .Max .X ;_gaaa ++{for _aaa :=0;_aaa < _ebd .Max .Y ;_aaa ++{_cfc :=_bfg .GrayAt (_gaaa ,_aaa );_bgaa .SetCMYK (_gaaa ,_aaa ,_edfg (_cfc ));};};};func (_eafd *Gray2 )SetGray (x ,y int ,gray _g .Gray ){_fdcgg :=_fbb (gray );_afb :=y *_eafd .BytesPerLine ;
_cee :=_afb +(x >>2);if _cee >=len (_eafd .Data ){return ;};_dfb :=_fdcgg .Y >>6;_eafd .Data [_cee ]=(_eafd .Data [_cee ]&(^(0xc0>>uint (2*((x )&3)))))|(_dfb <<uint (6-2*(x &3)));};var _ Image =&Monochrome {};var _ Gray =&Gray4 {};func _bgaf (_ege _g .NRGBA64 )_g .RGBA {_cbg ,_fbdb ,_aaad ,_eegg :=_ege .RGBA ();
return _g .RGBA {R :uint8 (_cbg >>8),G :uint8 (_fbdb >>8),B :uint8 (_aaad >>8),A :uint8 (_eegg >>8)};};func (_cca *Monochrome )ScaleLow (width ,height int )(*Monochrome ,error ){if width < 0||height < 0{return nil ,_a .New ("\u0070\u0072\u006f\u0076\u0069\u0064e\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0069\u0064t\u0068\u0020\u0061\u006e\u0064\u0020\u0068e\u0069\u0067\u0068\u0074");
};_gafb :=_bab (width ,height );_fag :=make ([]int ,height );_cdgc :=make ([]int ,width );_cgf :=float64 (_cca .Width )/float64 (width );_gedg :=float64 (_cca .Height )/float64 (height );for _gde :=0;_gde < height ;_gde ++{_fag [_gde ]=int (_ed .Min (_gedg *float64 (_gde )+0.5,float64 (_cca .Height -1)));
};for _bage :=0;_bage < width ;_bage ++{_cdgc [_bage ]=int (_ed .Min (_cgf *float64 (_bage )+0.5,float64 (_cca .Width -1)));};_bcg :=-1;_aaga :=byte (0);for _faea :=0;_faea < height ;_faea ++{_eacb :=_fag [_faea ]*_cca .BytesPerLine ;_bfb :=_faea *_gafb .BytesPerLine ;
for _befg :=0;_befg < width ;_befg ++{_dagb :=_cdgc [_befg ];if _dagb !=_bcg {_aaga =_cca .getBit (_eacb ,_dagb );if _aaga !=0{_gafb .setBit (_bfb ,_befg );};_bcg =_dagb ;}else {if _aaga !=0{_gafb .setBit (_bfb ,_befg );};};};};return _gafb ,nil ;};func (_gfbg *Monochrome )SetGray (x ,y int ,g _g .Gray ){_eefde :=y *_gfbg .BytesPerLine +x >>3;
if _eefde > len (_gfbg .Data )-1{return ;};g =_eec (g ,monochromeModel (_gfbg .ModelThreshold ));_gfbg .setGray (x ,g ,_eefde );};func (_edd *CMYK32 )ColorAt (x ,y int )(_g .Color ,error ){return ColorAtCMYK (x ,y ,_edd .Width ,_edd .Data ,_edd .Decode );
};func ColorAtNRGBA64 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_g .NRGBA64 ,error ){_ffga :=(y *width +x )*2;_agggc :=_ffga *3;if _agggc +5>=len (data ){return _g .NRGBA64 {},_ef .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};const _dddc =0xffff;_dbdd :=uint16 (_dddc );if alpha !=nil &&len (alpha )> _ffga +1{_dbdd =uint16 (alpha [_ffga ])<<8|uint16 (alpha [_ffga +1]);};_gdbgf :=uint16 (data [_agggc ])<<8|uint16 (data [_agggc +1]);_abggf :=uint16 (data [_agggc +2])<<8|uint16 (data [_agggc +3]);
_dfdc :=uint16 (data [_agggc +4])<<8|uint16 (data [_agggc +5]);if len (decode )==6{_gdbgf =uint16 (uint64 (LinearInterpolate (float64 (_gdbgf ),0,65535,decode [0],decode [1]))&_dddc );_abggf =uint16 (uint64 (LinearInterpolate (float64 (_abggf ),0,65535,decode [2],decode [3]))&_dddc );
_dfdc =uint16 (uint64 (LinearInterpolate (float64 (_dfdc ),0,65535,decode [4],decode [5]))&_dddc );};return _g .NRGBA64 {R :_gdbgf ,G :_abggf ,B :_dfdc ,A :_dbdd },nil ;};func (_ebb *NRGBA32 )Set (x ,y int ,c _g .Color ){_cdcgd :=y *_ebb .Width +x ;_cbca :=3*_cdcgd ;
if _cbca +2>=len (_ebb .Data ){return ;};_fdfc :=_g .NRGBAModel .Convert (c ).(_g .NRGBA );_ebb .setRGBA (_cdcgd ,_fdfc );};func ImgToBinary (i _f .Image ,threshold uint8 )*_f .Gray {switch _dcacg :=i .(type ){case *_f .Gray :if _fgadf (_dcacg ){return _dcacg ;
};return _fgedfa (_dcacg ,threshold );case *_f .Gray16 :return _dcca (_dcacg ,threshold );default:return _gefg (_dcacg ,threshold );};};func (_bddag *Gray4 )At (x ,y int )_g .Color {_fcab ,_ :=_bddag .ColorAt (x ,y );return _fcab };func ColorAtGray1BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_g .Gray ,error ){_bggb :=y *bytesPerLine +x >>3;
if _bggb >=len (data ){return _g .Gray {},_ef .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_efbd :=data [_bggb ]>>uint (7-(x &7))&1;if len (decode )==2{_efbd =uint8 (LinearInterpolate (float64 (_efbd ),0.0,1.0,decode [0],decode [1]))&1;};return _g .Gray {Y :_efbd *255},nil ;};func _acfc (_efab _f .Image ,_ggbab Image ,_bbe _f .Rectangle ){switch _bggd :=_efab .(type ){case Gray :_adcb (_bggd ,_ggbab .(Gray ),_bbe );
case NRGBA :_eeabg (_bggd ,_ggbab .(Gray ),_bbe );case CMYK :_gbfdg (_bggd ,_ggbab .(Gray ),_bbe );case RGBA :_geda (_bggd ,_ggbab .(Gray ),_bbe );default:_fbcb (_efab ,_ggbab .(Image ),_bbe );};};func (_fee *Gray8 )Copy ()Image {return &Gray8 {ImageBase :_fee .copy ()}};
func (_cdba *Gray8 )SetGray (x ,y int ,g _g .Gray ){_bacg :=y *_cdba .BytesPerLine +x ;if _bacg > len (_cdba .Data )-1{return ;};_cdba .Data [_bacg ]=g .Y ;};var _ _f .Image =&NRGBA32 {};func (_bebf *CMYK32 )Bounds ()_f .Rectangle {return _f .Rectangle {Max :_f .Point {X :_bebf .Width ,Y :_bebf .Height }};
};func _geeg (_beac *Monochrome ,_aebf ,_fff int ,_abgg ,_bbee int ,_bbdg RasterOperator ,_ceab *Monochrome ,_bgbc ,_fdeg int )error {var _ddcg ,_aee ,_egag ,_cdd int ;if _aebf < 0{_bgbc -=_aebf ;_abgg +=_aebf ;_aebf =0;};if _bgbc < 0{_aebf -=_bgbc ;_abgg +=_bgbc ;
_bgbc =0;};_ddcg =_aebf +_abgg -_beac .Width ;if _ddcg > 0{_abgg -=_ddcg ;};_aee =_bgbc +_abgg -_ceab .Width ;if _aee > 0{_abgg -=_aee ;};if _fff < 0{_fdeg -=_fff ;_bbee +=_fff ;_fff =0;};if _fdeg < 0{_fff -=_fdeg ;_bbee +=_fdeg ;_fdeg =0;};_egag =_fff +_bbee -_beac .Height ;
if _egag > 0{_bbee -=_egag ;};_cdd =_fdeg +_bbee -_ceab .Height ;if _cdd > 0{_bbee -=_cdd ;};if _abgg <=0||_bbee <=0{return nil ;};var _eabag error ;switch {case _aebf &7==0&&_bgbc &7==0:_eabag =_aead (_beac ,_aebf ,_fff ,_abgg ,_bbee ,_bbdg ,_ceab ,_bgbc ,_fdeg );
case _aebf &7==_bgbc &7:_eabag =_fcgf (_beac ,_aebf ,_fff ,_abgg ,_bbee ,_bbdg ,_ceab ,_bgbc ,_fdeg );default:_eabag =_aacac (_beac ,_aebf ,_fff ,_abgg ,_bbee ,_bbdg ,_ceab ,_bgbc ,_fdeg );};if _eabag !=nil {return _eabag ;};return nil ;};