//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package imageutil ;import (_a "encoding/binary";_f "errors";_b "fmt";_ee "github.com/unidoc/unipdf/v3/common";_bd "github.com/unidoc/unipdf/v3/internal/bitwise";_cg "image";_c "image/color";_ge "image/draw";_g "math";);func (_bdfe *Monochrome )InverseData ()error {return _bdfe .RasterOperation (0,0,_bdfe .Width ,_bdfe .Height ,PixNotDst ,nil ,0,0);
};func (_agab *Monochrome )Histogram ()(_cdgb [256]int ){for _ ,_dagc :=range _agab .Data {_cdgb [0xff]+=int (_cafgc [_agab .Data [_dagc ]]);};return _cdgb ;};func (_bcdfd *Monochrome )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtGray1BPC (x ,y ,_bcdfd .BytesPerLine ,_bcdfd .Data ,_bcdfd .Decode );
};func _aee (_dfd int )[]uint {var _fde []uint ;_ggb :=_dfd ;_dcc :=_ggb /8;if _dcc !=0{for _cb :=0;_cb < _dcc ;_cb ++{_fde =append (_fde ,8);};_cffb :=_ggb %8;_ggb =0;if _cffb !=0{_ggb =_cffb ;};};_agd :=_ggb /4;if _agd !=0{for _ggf :=0;_ggf < _agd ;_ggf ++{_fde =append (_fde ,4);
};_gdd :=_ggb %4;_ggb =0;if _gdd !=0{_ggb =_gdd ;};};_bf :=_ggb /2;if _bf !=0{for _eac :=0;_eac < _bf ;_eac ++{_fde =append (_fde ,2);};};return _fde ;};func ColorAtGray1BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_c .Gray ,error ){_fede :=y *bytesPerLine +x >>3;
if _fede >=len (data ){return _c .Gray {},_b .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_gcg :=data [_fede ]>>uint (7-(x &7))&1;if len (decode )==2{_gcg =uint8 (LinearInterpolate (float64 (_gcg ),0.0,1.0,decode [0],decode [1]))&1;};return _c .Gray {Y :_gcg *255},nil ;};type monochromeThresholdConverter struct{Threshold uint8 ;};func IsGrayImgBlackAndWhite (i *_cg .Gray )bool {return _gebe (i )};
func _egfd (_fff _c .NRGBA64 )_c .NRGBA {return _c .NRGBA {R :uint8 (_fff .R >>8),G :uint8 (_fff .G >>8),B :uint8 (_fff .B >>8),A :uint8 (_fff .A >>8)};};func _gddd (_cea _c .Gray )_c .NRGBA {return _c .NRGBA {R :_cea .Y ,G :_cea .Y ,B :_cea .Y ,A :0xff}};
func ColorAtCMYK (x ,y ,width int ,data []byte ,decode []float64 )(_c .CMYK ,error ){_bbg :=4*(y *width +x );if _bbg +3>=len (data ){return _c .CMYK {},_b .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};C :=data [_bbg ]&0xff;M :=data [_bbg +1]&0xff;Y :=data [_bbg +2]&0xff;K :=data [_bbg +3]&0xff;if len (decode )==8{C =uint8 (uint32 (LinearInterpolate (float64 (C ),0,255,decode [0],decode [1]))&0xff);M =uint8 (uint32 (LinearInterpolate (float64 (M ),0,255,decode [2],decode [3]))&0xff);
Y =uint8 (uint32 (LinearInterpolate (float64 (Y ),0,255,decode [4],decode [5]))&0xff);K =uint8 (uint32 (LinearInterpolate (float64 (K ),0,255,decode [6],decode [7]))&0xff);};return _c .CMYK {C :C ,M :M ,Y :Y ,K :K },nil ;};func _afg (_gcbf _c .Gray ,_cgg monochromeModel )_c .Gray {if _gcbf .Y > uint8 (_cgg ){return _c .Gray {Y :_g .MaxUint8 };
};return _c .Gray {};};func (_bgca *ImageBase )getByte (_cfbag int )(byte ,error ){if _cfbag > len (_bgca .Data )-1||_cfbag < 0{return 0,_b .Errorf ("\u0069\u006e\u0064\u0065x:\u0020\u0025\u0064\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006eg\u0065",_cfbag );
};return _bgca .Data [_cfbag ],nil ;};func (_eaac *Gray4 )SetGray (x ,y int ,g _c .Gray ){if x >=_eaac .Width ||y >=_eaac .Height {return ;};g =_gga (g );_eaac .setGray (x ,y ,g );};type RasterOperator int ;func _dbaf (_ccd Gray ,_bge CMYK ,_dbf _cg .Rectangle ){for _baa :=0;
_baa < _dbf .Max .X ;_baa ++{for _dead :=0;_dead < _dbf .Max .Y ;_dead ++{_gad :=_ccd .GrayAt (_baa ,_dead );_bge .SetCMYK (_baa ,_dead ,_aeea (_gad ));};};};func (_fec *ImageBase )MakeAlpha (){_fec .newAlpha ()};var _ Image =&Monochrome {};func _cda (_cfbg _cg .Image )(Image ,error ){if _bcg ,_fcg :=_cfbg .(*Gray8 );
_fcg {return _bcg .Copy (),nil ;};_gagc :=_cfbg .Bounds ();_aefe ,_egc :=NewImage (_gagc .Max .X ,_gagc .Max .Y ,8,1,nil ,nil ,nil );if _egc !=nil {return nil ,_egc ;};_geaa (_cfbg ,_aefe ,_gagc );return _aefe ,nil ;};func (_dbg *Gray4 )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtGray4BPC (x ,y ,_dbg .BytesPerLine ,_dbg .Data ,_dbg .Decode );
};func (_edga *Gray16 )At (x ,y int )_c .Color {_cbab ,_ :=_edga .ColorAt (x ,y );return _cbab };func (_deb *Monochrome )RasterOperation (dx ,dy ,dw ,dh int ,op RasterOperator ,src *Monochrome ,sx ,sy int )error {return _cafac (_deb ,dx ,dy ,dw ,dh ,op ,src ,sx ,sy );
};func (_adbc *Gray16 )Histogram ()(_ccdgf [256]int ){for _ggcg :=0;_ggcg < _adbc .Width ;_ggcg ++{for _egd :=0;_egd < _adbc .Height ;_egd ++{_ccdgf [_adbc .GrayAt (_ggcg ,_egd ).Y ]++;};};return _ccdgf ;};func _ccdb (_fgca _cg .Image ,_dbfe Image ,_bdeb _cg .Rectangle ){if _agddd ,_ffbb :=_fgca .(SMasker );
_ffbb &&_agddd .HasAlpha (){_dbfe .(SMasker ).MakeAlpha ();};switch _fbgd :=_fgca .(type ){case Gray :_cdgc (_fbgd ,_dbfe .(NRGBA ),_bdeb );case NRGBA :_fbca (_fbgd ,_dbfe .(NRGBA ),_bdeb );case *_cg .NYCbCrA :_geab (_fbgd ,_dbfe .(NRGBA ),_bdeb );case CMYK :_daeg (_fbgd ,_dbfe .(NRGBA ),_bdeb );
case RGBA :_edcd (_fbgd ,_dbfe .(NRGBA ),_bdeb );case nrgba64 :_adad (_fbgd ,_dbfe .(NRGBA ),_bdeb );default:_ebd (_fgca ,_dbfe ,_bdeb );};};func (_dbef *Gray16 )Base ()*ImageBase {return &_dbef .ImageBase };func _deac ()(_bafc []byte ){_bafc =make ([]byte ,256);
for _fgb :=0;_fgb < 256;_fgb ++{_ggdf :=byte (_fgb );_bafc [_ggdf ]=(_ggdf &0x01)|((_ggdf &0x04)>>1)|((_ggdf &0x10)>>2)|((_ggdf &0x40)>>3)|((_ggdf &0x02)<<3)|((_ggdf &0x08)<<2)|((_ggdf &0x20)<<1)|(_ggdf &0x80);};return _bafc ;};type Gray interface{GrayAt (_eacb ,_bfd int )_c .Gray ;
SetGray (_eege ,_fadd int ,_dcb _c .Gray );};func _edec (_gfcd _c .NYCbCrA )_c .NRGBA {_deg :=int32 (_gfcd .Y )*0x10101;_cbd :=int32 (_gfcd .Cb )-128;_dgac :=int32 (_gfcd .Cr )-128;_fbe :=_deg +91881*_dgac ;if uint32 (_fbe )&0xff000000==0{_fbe >>=8;}else {_fbe =^(_fbe >>31)&0xffff;
};_eeccd :=_deg -22554*_cbd -46802*_dgac ;if uint32 (_eeccd )&0xff000000==0{_eeccd >>=8;}else {_eeccd =^(_eeccd >>31)&0xffff;};_bfba :=_deg +116130*_cbd ;if uint32 (_bfba )&0xff000000==0{_bfba >>=8;}else {_bfba =^(_bfba >>31)&0xffff;};return _c .NRGBA {R :uint8 (_fbe >>8),G :uint8 (_eeccd >>8),B :uint8 (_bfba >>8),A :_gfcd .A };
};func (_cca *CMYK32 )CMYKAt (x ,y int )_c .CMYK {_eafg ,_ :=ColorAtCMYK (x ,y ,_cca .Width ,_cca .Data ,_cca .Decode );return _eafg ;};func _cc (_fb *Monochrome ,_bgf int ,_cd []uint )(*Monochrome ,error ){_dec :=_bgf *_fb .Width ;_bc :=_bgf *_fb .Height ;
_ged :=_fba (_dec ,_bc );for _ag ,_bdd :=range _cd {var _ef error ;switch _bdd {case 2:_ef =_ec (_ged ,_fb );case 4:_ef =_be (_ged ,_fb );case 8:_ef =_bed (_ged ,_fb );};if _ef !=nil {return nil ,_ef ;};if _ag !=len (_cd )-1{_fb =_ged .copy ();};};return _ged ,nil ;
};func _dcac (_dacd _c .NRGBA )_c .Gray {_fcb ,_ffba ,_cdb ,_ :=_dacd .RGBA ();_daag :=(19595*_fcb +38470*_ffba +7471*_cdb +1<<15)>>24;return _c .Gray {Y :uint8 (_daag )};};func (_eegf *Monochrome )At (x ,y int )_c .Color {_aed ,_ :=_eegf .ColorAt (x ,y );
return _aed };func (_ccedd *NRGBA16 )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtNRGBA16 (x ,y ,_ccedd .Width ,_ccedd .BytesPerLine ,_ccedd .Data ,_ccedd .Alpha ,_ccedd .Decode );};var _ Image =&Gray2 {};func NextPowerOf2 (n uint )uint {if IsPowerOf2 (n ){return n ;
};return 1<<(_dcaca (n )+1);};func _ecgd (_ceaf _c .Gray )_c .Gray {_fbd :=_ceaf .Y >>6;_fbd |=_fbd <<2;_ceaf .Y =_fbd |_fbd <<4;return _ceaf ;};var (_dg =_gfc ();_agc =_ff ();_dca =_dbd (););func MonochromeModel (threshold uint8 )_c .Model {return monochromeModel (threshold )};
var _ Image =&CMYK32 {};var (Gray2Model =_c .ModelFunc (_fagg );Gray4Model =_c .ModelFunc (_dadf );NRGBA16Model =_c .ModelFunc (_cacb ););var _ Image =&Gray4 {};func ConverterFunc (converterFunc func (_afef _cg .Image )(Image ,error ))ColorConverter {return colorConverter {_gbde :converterFunc };
};func (_cgfff *Monochrome )IsUnpadded ()bool {return (_cgfff .Width *_cgfff .Height )==len (_cgfff .Data );};func (_ddbc *Gray8 )Validate ()error {if len (_ddbc .Data )!=_ddbc .Height *_ddbc .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_gebbc *Gray16 )Set (x ,y int ,c _c .Color ){_gdbe :=(y *_gebbc .BytesPerLine /2+x )*2;
if _gdbe +1>=len (_gebbc .Data ){return ;};_abe :=_c .Gray16Model .Convert (c ).(_c .Gray16 );_gebbc .Data [_gdbe ],_gebbc .Data [_gdbe +1]=uint8 (_abe .Y >>8),uint8 (_abe .Y &0xff);};func (_cdfe *Gray4 )Base ()*ImageBase {return &_cdfe .ImageBase };func NewImage (width ,height ,bitsPerComponent ,colorComponents int ,data ,alpha []byte ,decode []float64 )(Image ,error ){_ggff :=NewImageBase (width ,height ,bitsPerComponent ,colorComponents ,data ,alpha ,decode );
var _daba Image ;switch colorComponents {case 1:switch bitsPerComponent {case 1:_daba =&Monochrome {ImageBase :_ggff ,ModelThreshold :0x0f};case 2:_daba =&Gray2 {ImageBase :_ggff };case 4:_daba =&Gray4 {ImageBase :_ggff };case 8:_daba =&Gray8 {ImageBase :_ggff };
case 16:_daba =&Gray16 {ImageBase :_ggff };};case 3:switch bitsPerComponent {case 4:_daba =&NRGBA16 {ImageBase :_ggff };case 8:_daba =&NRGBA32 {ImageBase :_ggff };case 16:_daba =&NRGBA64 {ImageBase :_ggff };};case 4:_daba =&CMYK32 {ImageBase :_ggff };};
if _daba ==nil {return nil ,ErrInvalidImage ;};return _daba ,nil ;};func (_bfgc *ImageBase )copy ()ImageBase {_ccff :=*_bfgc ;_ccff .Data =make ([]byte ,len (_bfgc .Data ));copy (_ccff .Data ,_bfgc .Data );return _ccff ;};func ImgToGray (i _cg .Image )*_cg .Gray {if _ebac ,_eddb :=i .(*_cg .Gray );
_eddb {return _ebac ;};_efce :=i .Bounds ();_dcag :=_cg .NewGray (_efce );for _aagg :=0;_aagg < _efce .Max .X ;_aagg ++{for _gebf :=0;_gebf < _efce .Max .Y ;_gebf ++{_ddee :=i .At (_aagg ,_gebf );_dcag .Set (_aagg ,_gebf ,_ddee );};};return _dcag ;};func _cgd (_bbdc *Monochrome ,_faeb ,_eabgf ,_gab ,_adg int ,_dcaa RasterOperator ,_fbfb *Monochrome ,_adca ,_bbfda int )error {var (_agdc bool ;
_gedd bool ;_bdefa int ;_bad int ;_ggeg int ;_fddf bool ;_bgba byte ;_cbgb int ;_bdge int ;_bfbg int ;_cbdeb ,_efgc int ;);_fdfb :=8-(_faeb &7);_ggab :=_afec [_fdfb ];_gggg :=_bbdc .BytesPerLine *_eabgf +(_faeb >>3);_aafd :=_fbfb .BytesPerLine *_bbfda +(_adca >>3);
if _gab < _fdfb {_agdc =true ;_ggab &=_edge [8-_fdfb +_gab ];};if !_agdc {_bdefa =(_gab -_fdfb )>>3;if _bdefa > 0{_gedd =true ;_bad =_gggg +1;_ggeg =_aafd +1;};};_cbgb =(_faeb +_gab )&7;if !(_agdc ||_cbgb ==0){_fddf =true ;_bgba =_edge [_cbgb ];_bdge =_gggg +1+_bdefa ;
_bfbg =_aafd +1+_bdefa ;};switch _dcaa {case PixSrc :for _cbdeb =0;_cbdeb < _adg ;_cbdeb ++{_bbdc .Data [_gggg ]=_gede (_bbdc .Data [_gggg ],_fbfb .Data [_aafd ],_ggab );_gggg +=_bbdc .BytesPerLine ;_aafd +=_fbfb .BytesPerLine ;};if _gedd {for _cbdeb =0;
_cbdeb < _adg ;_cbdeb ++{for _efgc =0;_efgc < _bdefa ;_efgc ++{_bbdc .Data [_bad +_efgc ]=_fbfb .Data [_ggeg +_efgc ];};_bad +=_bbdc .BytesPerLine ;_ggeg +=_fbfb .BytesPerLine ;};};if _fddf {for _cbdeb =0;_cbdeb < _adg ;_cbdeb ++{_bbdc .Data [_bdge ]=_gede (_bbdc .Data [_bdge ],_fbfb .Data [_bfbg ],_bgba );
_bdge +=_bbdc .BytesPerLine ;_bfbg +=_fbfb .BytesPerLine ;};};case PixNotSrc :for _cbdeb =0;_cbdeb < _adg ;_cbdeb ++{_bbdc .Data [_gggg ]=_gede (_bbdc .Data [_gggg ],^_fbfb .Data [_aafd ],_ggab );_gggg +=_bbdc .BytesPerLine ;_aafd +=_fbfb .BytesPerLine ;
};if _gedd {for _cbdeb =0;_cbdeb < _adg ;_cbdeb ++{for _efgc =0;_efgc < _bdefa ;_efgc ++{_bbdc .Data [_bad +_efgc ]=^_fbfb .Data [_ggeg +_efgc ];};_bad +=_bbdc .BytesPerLine ;_ggeg +=_fbfb .BytesPerLine ;};};if _fddf {for _cbdeb =0;_cbdeb < _adg ;_cbdeb ++{_bbdc .Data [_bdge ]=_gede (_bbdc .Data [_bdge ],^_fbfb .Data [_bfbg ],_bgba );
_bdge +=_bbdc .BytesPerLine ;_bfbg +=_fbfb .BytesPerLine ;};};case PixSrcOrDst :for _cbdeb =0;_cbdeb < _adg ;_cbdeb ++{_bbdc .Data [_gggg ]=_gede (_bbdc .Data [_gggg ],_fbfb .Data [_aafd ]|_bbdc .Data [_gggg ],_ggab );_gggg +=_bbdc .BytesPerLine ;_aafd +=_fbfb .BytesPerLine ;
};if _gedd {for _cbdeb =0;_cbdeb < _adg ;_cbdeb ++{for _efgc =0;_efgc < _bdefa ;_efgc ++{_bbdc .Data [_bad +_efgc ]|=_fbfb .Data [_ggeg +_efgc ];};_bad +=_bbdc .BytesPerLine ;_ggeg +=_fbfb .BytesPerLine ;};};if _fddf {for _cbdeb =0;_cbdeb < _adg ;_cbdeb ++{_bbdc .Data [_bdge ]=_gede (_bbdc .Data [_bdge ],_fbfb .Data [_bfbg ]|_bbdc .Data [_bdge ],_bgba );
_bdge +=_bbdc .BytesPerLine ;_bfbg +=_fbfb .BytesPerLine ;};};case PixSrcAndDst :for _cbdeb =0;_cbdeb < _adg ;_cbdeb ++{_bbdc .Data [_gggg ]=_gede (_bbdc .Data [_gggg ],_fbfb .Data [_aafd ]&_bbdc .Data [_gggg ],_ggab );_gggg +=_bbdc .BytesPerLine ;_aafd +=_fbfb .BytesPerLine ;
};if _gedd {for _cbdeb =0;_cbdeb < _adg ;_cbdeb ++{for _efgc =0;_efgc < _bdefa ;_efgc ++{_bbdc .Data [_bad +_efgc ]&=_fbfb .Data [_ggeg +_efgc ];};_bad +=_bbdc .BytesPerLine ;_ggeg +=_fbfb .BytesPerLine ;};};if _fddf {for _cbdeb =0;_cbdeb < _adg ;_cbdeb ++{_bbdc .Data [_bdge ]=_gede (_bbdc .Data [_bdge ],_fbfb .Data [_bfbg ]&_bbdc .Data [_bdge ],_bgba );
_bdge +=_bbdc .BytesPerLine ;_bfbg +=_fbfb .BytesPerLine ;};};case PixSrcXorDst :for _cbdeb =0;_cbdeb < _adg ;_cbdeb ++{_bbdc .Data [_gggg ]=_gede (_bbdc .Data [_gggg ],_fbfb .Data [_aafd ]^_bbdc .Data [_gggg ],_ggab );_gggg +=_bbdc .BytesPerLine ;_aafd +=_fbfb .BytesPerLine ;
};if _gedd {for _cbdeb =0;_cbdeb < _adg ;_cbdeb ++{for _efgc =0;_efgc < _bdefa ;_efgc ++{_bbdc .Data [_bad +_efgc ]^=_fbfb .Data [_ggeg +_efgc ];};_bad +=_bbdc .BytesPerLine ;_ggeg +=_fbfb .BytesPerLine ;};};if _fddf {for _cbdeb =0;_cbdeb < _adg ;_cbdeb ++{_bbdc .Data [_bdge ]=_gede (_bbdc .Data [_bdge ],_fbfb .Data [_bfbg ]^_bbdc .Data [_bdge ],_bgba );
_bdge +=_bbdc .BytesPerLine ;_bfbg +=_fbfb .BytesPerLine ;};};case PixNotSrcOrDst :for _cbdeb =0;_cbdeb < _adg ;_cbdeb ++{_bbdc .Data [_gggg ]=_gede (_bbdc .Data [_gggg ],^(_fbfb .Data [_aafd ])|_bbdc .Data [_gggg ],_ggab );_gggg +=_bbdc .BytesPerLine ;
_aafd +=_fbfb .BytesPerLine ;};if _gedd {for _cbdeb =0;_cbdeb < _adg ;_cbdeb ++{for _efgc =0;_efgc < _bdefa ;_efgc ++{_bbdc .Data [_bad +_efgc ]|=^(_fbfb .Data [_ggeg +_efgc ]);};_bad +=_bbdc .BytesPerLine ;_ggeg +=_fbfb .BytesPerLine ;};};if _fddf {for _cbdeb =0;
_cbdeb < _adg ;_cbdeb ++{_bbdc .Data [_bdge ]=_gede (_bbdc .Data [_bdge ],^(_fbfb .Data [_bfbg ])|_bbdc .Data [_bdge ],_bgba );_bdge +=_bbdc .BytesPerLine ;_bfbg +=_fbfb .BytesPerLine ;};};case PixNotSrcAndDst :for _cbdeb =0;_cbdeb < _adg ;_cbdeb ++{_bbdc .Data [_gggg ]=_gede (_bbdc .Data [_gggg ],^(_fbfb .Data [_aafd ])&_bbdc .Data [_gggg ],_ggab );
_gggg +=_bbdc .BytesPerLine ;_aafd +=_fbfb .BytesPerLine ;};if _gedd {for _cbdeb =0;_cbdeb < _adg ;_cbdeb ++{for _efgc =0;_efgc < _bdefa ;_efgc ++{_bbdc .Data [_bad +_efgc ]&=^_fbfb .Data [_ggeg +_efgc ];};_bad +=_bbdc .BytesPerLine ;_ggeg +=_fbfb .BytesPerLine ;
};};if _fddf {for _cbdeb =0;_cbdeb < _adg ;_cbdeb ++{_bbdc .Data [_bdge ]=_gede (_bbdc .Data [_bdge ],^(_fbfb .Data [_bfbg ])&_bbdc .Data [_bdge ],_bgba );_bdge +=_bbdc .BytesPerLine ;_bfbg +=_fbfb .BytesPerLine ;};};case PixSrcOrNotDst :for _cbdeb =0;
_cbdeb < _adg ;_cbdeb ++{_bbdc .Data [_gggg ]=_gede (_bbdc .Data [_gggg ],_fbfb .Data [_aafd ]|^(_bbdc .Data [_gggg ]),_ggab );_gggg +=_bbdc .BytesPerLine ;_aafd +=_fbfb .BytesPerLine ;};if _gedd {for _cbdeb =0;_cbdeb < _adg ;_cbdeb ++{for _efgc =0;_efgc < _bdefa ;
_efgc ++{_bbdc .Data [_bad +_efgc ]=_fbfb .Data [_ggeg +_efgc ]|^(_bbdc .Data [_bad +_efgc ]);};_bad +=_bbdc .BytesPerLine ;_ggeg +=_fbfb .BytesPerLine ;};};if _fddf {for _cbdeb =0;_cbdeb < _adg ;_cbdeb ++{_bbdc .Data [_bdge ]=_gede (_bbdc .Data [_bdge ],_fbfb .Data [_bfbg ]|^(_bbdc .Data [_bdge ]),_bgba );
_bdge +=_bbdc .BytesPerLine ;_bfbg +=_fbfb .BytesPerLine ;};};case PixSrcAndNotDst :for _cbdeb =0;_cbdeb < _adg ;_cbdeb ++{_bbdc .Data [_gggg ]=_gede (_bbdc .Data [_gggg ],_fbfb .Data [_aafd ]&^(_bbdc .Data [_gggg ]),_ggab );_gggg +=_bbdc .BytesPerLine ;
_aafd +=_fbfb .BytesPerLine ;};if _gedd {for _cbdeb =0;_cbdeb < _adg ;_cbdeb ++{for _efgc =0;_efgc < _bdefa ;_efgc ++{_bbdc .Data [_bad +_efgc ]=_fbfb .Data [_ggeg +_efgc ]&^(_bbdc .Data [_bad +_efgc ]);};_bad +=_bbdc .BytesPerLine ;_ggeg +=_fbfb .BytesPerLine ;
};};if _fddf {for _cbdeb =0;_cbdeb < _adg ;_cbdeb ++{_bbdc .Data [_bdge ]=_gede (_bbdc .Data [_bdge ],_fbfb .Data [_bfbg ]&^(_bbdc .Data [_bdge ]),_bgba );_bdge +=_bbdc .BytesPerLine ;_bfbg +=_fbfb .BytesPerLine ;};};case PixNotPixSrcOrDst :for _cbdeb =0;
_cbdeb < _adg ;_cbdeb ++{_bbdc .Data [_gggg ]=_gede (_bbdc .Data [_gggg ],^(_fbfb .Data [_aafd ]|_bbdc .Data [_gggg ]),_ggab );_gggg +=_bbdc .BytesPerLine ;_aafd +=_fbfb .BytesPerLine ;};if _gedd {for _cbdeb =0;_cbdeb < _adg ;_cbdeb ++{for _efgc =0;_efgc < _bdefa ;
_efgc ++{_bbdc .Data [_bad +_efgc ]=^(_fbfb .Data [_ggeg +_efgc ]|_bbdc .Data [_bad +_efgc ]);};_bad +=_bbdc .BytesPerLine ;_ggeg +=_fbfb .BytesPerLine ;};};if _fddf {for _cbdeb =0;_cbdeb < _adg ;_cbdeb ++{_bbdc .Data [_bdge ]=_gede (_bbdc .Data [_bdge ],^(_fbfb .Data [_bfbg ]|_bbdc .Data [_bdge ]),_bgba );
_bdge +=_bbdc .BytesPerLine ;_bfbg +=_fbfb .BytesPerLine ;};};case PixNotPixSrcAndDst :for _cbdeb =0;_cbdeb < _adg ;_cbdeb ++{_bbdc .Data [_gggg ]=_gede (_bbdc .Data [_gggg ],^(_fbfb .Data [_aafd ]&_bbdc .Data [_gggg ]),_ggab );_gggg +=_bbdc .BytesPerLine ;
_aafd +=_fbfb .BytesPerLine ;};if _gedd {for _cbdeb =0;_cbdeb < _adg ;_cbdeb ++{for _efgc =0;_efgc < _bdefa ;_efgc ++{_bbdc .Data [_bad +_efgc ]=^(_fbfb .Data [_ggeg +_efgc ]&_bbdc .Data [_bad +_efgc ]);};_bad +=_bbdc .BytesPerLine ;_ggeg +=_fbfb .BytesPerLine ;
};};if _fddf {for _cbdeb =0;_cbdeb < _adg ;_cbdeb ++{_bbdc .Data [_bdge ]=_gede (_bbdc .Data [_bdge ],^(_fbfb .Data [_bfbg ]&_bbdc .Data [_bdge ]),_bgba );_bdge +=_bbdc .BytesPerLine ;_bfbg +=_fbfb .BytesPerLine ;};};case PixNotPixSrcXorDst :for _cbdeb =0;
_cbdeb < _adg ;_cbdeb ++{_bbdc .Data [_gggg ]=_gede (_bbdc .Data [_gggg ],^(_fbfb .Data [_aafd ]^_bbdc .Data [_gggg ]),_ggab );_gggg +=_bbdc .BytesPerLine ;_aafd +=_fbfb .BytesPerLine ;};if _gedd {for _cbdeb =0;_cbdeb < _adg ;_cbdeb ++{for _efgc =0;_efgc < _bdefa ;
_efgc ++{_bbdc .Data [_bad +_efgc ]=^(_fbfb .Data [_ggeg +_efgc ]^_bbdc .Data [_bad +_efgc ]);};_bad +=_bbdc .BytesPerLine ;_ggeg +=_fbfb .BytesPerLine ;};};if _fddf {for _cbdeb =0;_cbdeb < _adg ;_cbdeb ++{_bbdc .Data [_bdge ]=_gede (_bbdc .Data [_bdge ],^(_fbfb .Data [_bfbg ]^_bbdc .Data [_bdge ]),_bgba );
_bdge +=_bbdc .BytesPerLine ;_bfbg +=_fbfb .BytesPerLine ;};};default:_ee .Log .Debug ("I\u006e\u0076\u0061\u006c\u0069\u0064 \u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070e\u0072\u0061\u0074o\u0072:\u0020\u0025\u0064",_dcaa );return _f .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072");
};return nil ;};var _ Gray =&Gray4 {};func (_ffcc *NRGBA64 )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtNRGBA64 (x ,y ,_ffcc .Width ,_ffcc .Data ,_ffcc .Alpha ,_ffcc .Decode );};func (_edg *Gray4 )GrayAt (x ,y int )_c .Gray {_aab ,_ :=ColorAtGray4BPC (x ,y ,_edg .BytesPerLine ,_edg .Data ,_edg .Decode );
return _aab ;};func (_fece *NRGBA64 )Copy ()Image {return &NRGBA64 {ImageBase :_fece .copy ()}};func (_beab *NRGBA32 )At (x ,y int )_c .Color {_eaceg ,_ :=_beab .ColorAt (x ,y );return _eaceg };var (MonochromeConverter =ConverterFunc (_eeee );Gray2Converter =ConverterFunc (_afeb );
Gray4Converter =ConverterFunc (_gdbg );GrayConverter =ConverterFunc (_cda );Gray16Converter =ConverterFunc (_gdec );NRGBA16Converter =ConverterFunc (_aedd );NRGBAConverter =ConverterFunc (_agea );NRGBA64Converter =ConverterFunc (_bcde );CMYKConverter =ConverterFunc (_bcdf );
);func _aeea (_abaeb _c .Gray )_c .CMYK {return _c .CMYK {K :0xff-_abaeb .Y }};func (_aebf *Monochrome )setGray (_fgbf int ,_dcd _c .Gray ,_aeba int ){if _dcd .Y ==0{_aebf .clearBit (_aeba ,_fgbf );}else {_aebf .setGrayBit (_aeba ,_fgbf );};};func (_beac *NRGBA64 )setNRGBA64 (_cdbd int ,_bgaa _c .NRGBA64 ,_fddfe int ){_beac .Data [_cdbd ]=uint8 (_bgaa .R >>8);
_beac .Data [_cdbd +1]=uint8 (_bgaa .R &0xff);_beac .Data [_cdbd +2]=uint8 (_bgaa .G >>8);_beac .Data [_cdbd +3]=uint8 (_bgaa .G &0xff);_beac .Data [_cdbd +4]=uint8 (_bgaa .B >>8);_beac .Data [_cdbd +5]=uint8 (_bgaa .B &0xff);if _fddfe +1< len (_beac .Alpha ){_beac .Alpha [_fddfe ]=uint8 (_bgaa .A >>8);
_beac .Alpha [_fddfe +1]=uint8 (_bgaa .A &0xff);};};var _ _cg .Image =&Monochrome {};func (_cad *Monochrome )ResolveDecode ()error {if len (_cad .Decode )!=2{return nil ;};if _cad .Decode [0]==1&&_cad .Decode [1]==0{if _dfgc :=_cad .InverseData ();_dfgc !=nil {return _dfgc ;
};_cad .Decode =nil ;};return nil ;};func _gcf (_bffd uint8 )bool {if _bffd ==0||_bffd ==255{return true ;};return false ;};func _fgbc (_fad _c .NRGBA )_c .Gray {var _ebff _c .NRGBA ;if _fad ==_ebff {return _c .Gray {Y :0xff};};_gaac ,_ecc ,_daab ,_ :=_fad .RGBA ();
_abdd :=(19595*_gaac +38470*_ecc +7471*_daab +1<<15)>>24;return _c .Gray {Y :uint8 (_abdd )};};func _ebd (_beg _cg .Image ,_bdf Image ,_bffe _cg .Rectangle ){for _feba :=0;_feba < _bffe .Max .X ;_feba ++{for _gcba :=0;_gcba < _bffe .Max .Y ;_gcba ++{_gaga :=_beg .At (_feba ,_gcba );
_bdf .Set (_feba ,_gcba ,_gaga );};};};func (_ffff *NRGBA64 )Base ()*ImageBase {return &_ffff .ImageBase };func init (){_dabf ()};func _egba (_ecb _c .RGBA )_c .Gray {_cfg :=(19595*uint32 (_ecb .R )+38470*uint32 (_ecb .G )+7471*uint32 (_ecb .B )+1<<7)>>16;
return _c .Gray {Y :uint8 (_cfg )};};func (_cfgb *Monochrome )Set (x ,y int ,c _c .Color ){_cffd :=y *_cfgb .BytesPerLine +x >>3;if _cffd > len (_cfgb .Data )-1{return ;};_abgg :=_cfgb .ColorModel ().Convert (c ).(_c .Gray );_cfgb .setGray (x ,_abgg ,_cffd );
};func (_ceg *Monochrome )AddPadding ()(_ced error ){if _ebb :=((_ceg .Width *_ceg .Height )+7)>>3;len (_ceg .Data )< _ebb {return _b .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064a\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002e\u0020\u0054\u0068\u0065\u0020\u0064\u0061t\u0061\u0020s\u0068\u006fu\u006c\u0064\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0020\u0061\u0074 l\u0065\u0061\u0073\u0074\u003a\u0020\u0027\u0025\u0064'\u0020\u0062\u0079\u0074\u0065\u0073",len (_ceg .Data ),_ebb );
};_abdg :=_ceg .Width %8;if _abdg ==0{return nil ;};_fgcge :=_ceg .Width /8;_dfdd :=_bd .NewReader (_ceg .Data );_fbfd :=make ([]byte ,_ceg .Height *_ceg .BytesPerLine );_agdd :=_bd .NewWriterMSB (_fbfd );_bga :=make ([]byte ,_fgcge );var (_bag int ;_gfgb uint64 ;
);for _bag =0;_bag < _ceg .Height ;_bag ++{if _ ,_ced =_dfdd .Read (_bga );_ced !=nil {return _ced ;};if _ ,_ced =_agdd .Write (_bga );_ced !=nil {return _ced ;};if _gfgb ,_ced =_dfdd .ReadBits (byte (_abdg ));_ced !=nil {return _ced ;};if _ced =_agdd .WriteByte (byte (_gfgb )<<uint (8-_abdg ));
_ced !=nil {return _ced ;};};_ceg .Data =_agdd .Data ();return nil ;};func (_gebb *Gray2 )Validate ()error {if len (_gebb .Data )!=_gebb .Height *_gebb .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_dbec *NRGBA16 )ColorModel ()_c .Model {return NRGBA16Model };
func (_ebfd *Monochrome )Validate ()error {if len (_ebfd .Data )!=_ebfd .Height *_ebfd .BytesPerLine {return ErrInvalidImage ;};return nil ;};func GrayHistogram (g Gray )(_ggdfa [256]int ){switch _dcgcg :=g .(type ){case Histogramer :return _dcgcg .Histogram ();
case _cg .Image :_feeb :=_dcgcg .Bounds ();for _fbedc :=0;_fbedc < _feeb .Max .X ;_fbedc ++{for _cffde :=0;_cffde < _feeb .Max .Y ;_cffde ++{_ggdfa [g .GrayAt (_fbedc ,_cffde ).Y ]++;};};return _ggdfa ;default:return [256]int {};};};func _gfc ()(_aec [256]uint16 ){for _cef :=0;
_cef < 256;_cef ++{if _cef &0x01!=0{_aec [_cef ]|=0x3;};if _cef &0x02!=0{_aec [_cef ]|=0xc;};if _cef &0x04!=0{_aec [_cef ]|=0x30;};if _cef &0x08!=0{_aec [_cef ]|=0xc0;};if _cef &0x10!=0{_aec [_cef ]|=0x300;};if _cef &0x20!=0{_aec [_cef ]|=0xc00;};if _cef &0x40!=0{_aec [_cef ]|=0x3000;
};if _cef &0x80!=0{_aec [_cef ]|=0xc000;};};return _aec ;};func ScaleAlphaToMonochrome (data []byte ,width ,height int )([]byte ,error ){_gd :=BytesPerLine (width ,8,1);if len (data )< _gd *height {return nil ,nil ;};_eg :=&Gray8 {NewImageBase (width ,height ,8,1,data ,nil ,nil )};
_d ,_dd :=MonochromeConverter .Convert (_eg );if _dd !=nil {return nil ,_dd ;};return _d .Base ().Data ,nil ;};func (_edbc *NRGBA16 )Set (x ,y int ,c _c .Color ){_dfgd :=y *_edbc .BytesPerLine +x *3/2;if _dfgd +1>=len (_edbc .Data ){return ;};_daagd :=NRGBA16Model .Convert (c ).(_c .NRGBA );
_edbc .setNRGBA (x ,y ,_dfgd ,_daagd );};func (_cfgf *Gray4 )ColorModel ()_c .Model {return Gray4Model };var (_edge =[]byte {0x00,0x80,0xC0,0xE0,0xF0,0xF8,0xFC,0xFE,0xFF};_afec =[]byte {0x00,0x01,0x03,0x07,0x0F,0x1F,0x3F,0x7F,0xFF};);func (_edbb *Gray4 )Validate ()error {if len (_edbb .Data )!=_edbb .Height *_edbb .BytesPerLine {return ErrInvalidImage ;
};return nil ;};type shift int ;func _fag (_agca _c .CMYK )_c .Gray {_dccfd ,_babf ,_fbf :=_c .CMYKToRGB (_agca .C ,_agca .M ,_agca .Y ,_agca .K );_adcf :=(19595*uint32 (_dccfd )+38470*uint32 (_babf )+7471*uint32 (_fbf )+1<<7)>>16;return _c .Gray {Y :uint8 (_adcf )};
};type Image interface{_ge .Image ;Base ()*ImageBase ;Copy ()Image ;Pix ()[]byte ;ColorAt (_dbdd ,_aaab int )(_c .Color ,error );Validate ()error ;};func _effg (_cgec int ,_abbb int )int {if _cgec < _abbb {return _cgec ;};return _abbb ;};var _ _cg .Image =&Gray2 {};
func _eceb (_ebed _c .NRGBA )_c .NRGBA {_ebed .R =_ebed .R >>4|(_ebed .R >>4)<<4;_ebed .G =_ebed .G >>4|(_ebed .G >>4)<<4;_ebed .B =_ebed .B >>4|(_ebed .B >>4)<<4;return _ebed ;};type NRGBA16 struct{ImageBase };func (_egbb *Gray8 )GrayAt (x ,y int )_c .Gray {_bfc ,_ :=ColorAtGray8BPC (x ,y ,_egbb .BytesPerLine ,_egbb .Data ,_egbb .Decode );
return _bfc ;};func ColorAtNRGBA16 (x ,y ,width ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_c .NRGBA ,error ){_cgcd :=y *bytesPerLine +x *3/2;if _cgcd +1>=len (data ){return _c .NRGBA {},_ffega (x ,y );};const (_abdf =0xf;_abcf =uint8 (0xff);
);_gfbb :=_abcf ;if alpha !=nil {_gecg :=y *BytesPerLine (width ,4,1);if _gecg < len (alpha ){if x %2==0{_gfbb =(alpha [_gecg ]>>uint (4))&_abdf ;}else {_gfbb =alpha [_gecg ]&_abdf ;};_gfbb |=_gfbb <<4;};};var _bfff ,_acbe ,_dbee uint8 ;if x *3%2==0{_bfff =(data [_cgcd ]>>uint (4))&_abdf ;
_acbe =data [_cgcd ]&_abdf ;_dbee =(data [_cgcd +1]>>uint (4))&_abdf ;}else {_bfff =data [_cgcd ]&_abdf ;_acbe =(data [_cgcd +1]>>uint (4))&_abdf ;_dbee =data [_cgcd +1]&_abdf ;};if len (decode )==6{_bfff =uint8 (uint32 (LinearInterpolate (float64 (_bfff ),0,15,decode [0],decode [1]))&0xf);
_acbe =uint8 (uint32 (LinearInterpolate (float64 (_acbe ),0,15,decode [2],decode [3]))&0xf);_dbee =uint8 (uint32 (LinearInterpolate (float64 (_dbee ),0,15,decode [4],decode [5]))&0xf);};return _c .NRGBA {R :(_bfff <<4)|(_bfff &0xf),G :(_acbe <<4)|(_acbe &0xf),B :(_dbee <<4)|(_dbee &0xf),A :_gfbb },nil ;
};func (_ddcd *NRGBA64 )SetNRGBA64 (x ,y int ,c _c .NRGBA64 ){_cbabg :=(y *_ddcd .Width +x )*2;_ffab :=_cbabg *3;if _ffab +5>=len (_ddcd .Data ){return ;};_ddcd .setNRGBA64 (_ffab ,c ,_cbabg );};func (_def *Gray8 )Base ()*ImageBase {return &_def .ImageBase };
func _be (_aa ,_fge *Monochrome )(_df error ){_aga :=_fge .BytesPerLine ;_bgc :=_aa .BytesPerLine ;_fgg :=_fge .BytesPerLine *4-_aa .BytesPerLine ;var (_gg ,_cgf byte ;_ede uint32 ;_fd ,_bdg ,_fe ,_bb ,_gec ,_bde ,_ac int ;);for _fe =0;_fe < _fge .Height ;
_fe ++{_fd =_fe *_aga ;_bdg =4*_fe *_bgc ;for _bb =0;_bb < _aga ;_bb ++{_gg =_fge .Data [_fd +_bb ];_ede =_agc [_gg ];_bde =_bdg +_bb *4;if _fgg !=0&&(_bb +1)*4> _aa .BytesPerLine {for _gec =_fgg ;_gec > 0;_gec --{_cgf =byte ((_ede >>uint (_gec *8))&0xff);
_ac =_bde +(_fgg -_gec );if _df =_aa .setByte (_ac ,_cgf );_df !=nil {return _df ;};};}else if _df =_aa .setFourBytes (_bde ,_ede );_df !=nil {return _df ;};if _df =_aa .setFourBytes (_bdg +_bb *4,_agc [_fge .Data [_fd +_bb ]]);_df !=nil {return _df ;};
};for _gec =1;_gec < 4;_gec ++{for _bb =0;_bb < _bgc ;_bb ++{if _df =_aa .setByte (_bdg +_gec *_bgc +_bb ,_aa .Data [_bdg +_bb ]);_df !=nil {return _df ;};};};};return nil ;};func IsPowerOf2 (n uint )bool {return n > 0&&(n &(n -1))==0};func _gdbg (_bdbb _cg .Image )(Image ,error ){if _ggfc ,_eda :=_bdbb .(*Gray4 );
_eda {return _ggfc .Copy (),nil ;};_cbeg :=_bdbb .Bounds ();_facg ,_cddc :=NewImage (_cbeg .Max .X ,_cbeg .Max .Y ,4,1,nil ,nil ,nil );if _cddc !=nil {return nil ,_cddc ;};_geaa (_bdbb ,_facg ,_cbeg );return _facg ,nil ;};func (_cgcc *NRGBA32 )SetNRGBA (x ,y int ,c _c .NRGBA ){_cgee :=y *_cgcc .Width +x ;
_abcc :=3*_cgee ;if _abcc +2>=len (_cgcc .Data ){return ;};_cgcc .setRGBA (_cgee ,c );};func _fba (_bab ,_ggg int )*Monochrome {return &Monochrome {ImageBase :NewImageBase (_bab ,_ggg ,1,1,nil ,nil ,nil ),ModelThreshold :0x0f};};func (_cag *CMYK32 )Validate ()error {if len (_cag .Data )!=4*_cag .Width *_cag .Height {return _f .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func _bbab (_abd ,_cbg *Monochrome ,_fac []byte ,_faf int )(_bacd error ){var (_fae ,_efb ,_gddc ,_cfdb ,_cdf ,_fbac ,_bbd ,_eab int ;_dgf ,_ada ,_baf ,_ccb uint32 ;_bcd ,_agaf byte ;_gge uint16 ;);_gc :=make ([]byte ,4);_gaf :=make ([]byte ,4);
for _gddc =0;_gddc < _abd .Height -1;_gddc ,_cfdb =_gddc +2,_cfdb +1{_fae =_gddc *_abd .BytesPerLine ;_efb =_cfdb *_cbg .BytesPerLine ;for _cdf ,_fbac =0,0;_cdf < _faf ;_cdf ,_fbac =_cdf +4,_fbac +1{for _bbd =0;_bbd < 4;_bbd ++{_eab =_fae +_cdf +_bbd ;
if _eab <=len (_abd .Data )-1&&_eab < _fae +_abd .BytesPerLine {_gc [_bbd ]=_abd .Data [_eab ];}else {_gc [_bbd ]=0x00;};_eab =_fae +_abd .BytesPerLine +_cdf +_bbd ;if _eab <=len (_abd .Data )-1&&_eab < _fae +(2*_abd .BytesPerLine ){_gaf [_bbd ]=_abd .Data [_eab ];
}else {_gaf [_bbd ]=0x00;};};_dgf =_a .BigEndian .Uint32 (_gc );_ada =_a .BigEndian .Uint32 (_gaf );_baf =_dgf &_ada ;_baf |=_baf <<1;_ccb =_dgf |_ada ;_ccb &=_ccb <<1;_ada =_baf &_ccb ;_ada &=0xaaaaaaaa;_dgf =_ada |(_ada <<7);_bcd =byte (_dgf >>24);_agaf =byte ((_dgf >>8)&0xff);
_eab =_efb +_fbac ;if _eab +1==len (_cbg .Data )-1||_eab +1>=_efb +_cbg .BytesPerLine {if _bacd =_cbg .setByte (_eab ,_fac [_bcd ]);_bacd !=nil {return _b .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_eab );};}else {_gge =(uint16 (_fac [_bcd ])<<8)|uint16 (_fac [_agaf ]);
if _bacd =_cbg .setTwoBytes (_eab ,_gge );_bacd !=nil {return _b .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_eab );
};_fbac ++;};};};return nil ;};func AddDataPadding (width ,height ,bitsPerComponent ,colorComponents int ,data []byte )([]byte ,error ){_fegc :=BytesPerLine (width ,bitsPerComponent ,colorComponents );if _fegc ==width *colorComponents *bitsPerComponent /8{return data ,nil ;
};_ffde :=width *colorComponents *bitsPerComponent ;_gaae :=_fegc *8;_dcdb :=8-(_gaae -_ffde );_gdba :=_bd .NewReader (data );_gbc :=_fegc -1;_cdgf :=make ([]byte ,_gbc );_abce :=make ([]byte ,height *_fegc );_bbe :=_bd .NewWriterMSB (_abce );var _daage uint64 ;
var _edbf error ;for _aaef :=0;_aaef < height ;_aaef ++{_ ,_edbf =_gdba .Read (_cdgf );if _edbf !=nil {return nil ,_edbf ;};_ ,_edbf =_bbe .Write (_cdgf );if _edbf !=nil {return nil ,_edbf ;};_daage ,_edbf =_gdba .ReadBits (byte (_dcdb ));if _edbf !=nil {return nil ,_edbf ;
};_ ,_edbf =_bbe .WriteBits (_daage ,_dcdb );if _edbf !=nil {return nil ,_edbf ;};_bbe .FinishByte ();};return _abce ,nil ;};func ImgToBinary (i _cg .Image ,threshold uint8 )*_cg .Gray {switch _eefd :=i .(type ){case *_cg .Gray :if _gebe (_eefd ){return _eefd ;
};return _cgaa (_eefd ,threshold );case *_cg .Gray16 :return _cagf (_eefd ,threshold );default:return _acbd (_eefd ,threshold );};};func (_cdfb *Gray2 )SetGray (x ,y int ,gray _c .Gray ){_bgff :=_ecgd (gray );_fadf :=y *_cdfb .BytesPerLine ;_edef :=_fadf +(x >>2);
if _edef >=len (_cdfb .Data ){return ;};_dfcg :=_bgff .Y >>6;_cdfb .Data [_edef ]=(_cdfb .Data [_edef ]&(^(0xc0>>uint (2*((x )&3)))))|(_dfcg <<uint (6-2*(x &3)));};var _ _cg .Image =&Gray8 {};func RasterOperation (dest *Monochrome ,dx ,dy ,dw ,dh int ,op RasterOperator ,src *Monochrome ,sx ,sy int )error {return _cafac (dest ,dx ,dy ,dw ,dh ,op ,src ,sx ,sy );
};func (_afda *Gray8 )Set (x ,y int ,c _c .Color ){_adbd :=y *_afda .BytesPerLine +x ;if _adbd > len (_afda .Data )-1{return ;};_fdae :=_c .GrayModel .Convert (c );_afda .Data [_adbd ]=_fdae .(_c .Gray ).Y ;};func _bcde (_faab _cg .Image )(Image ,error ){if _bedd ,_fgea :=_faab .(*NRGBA64 );
_fgea {return _bedd .Copy (),nil ;};_cbeb ,_geag ,_fgce :=_gagb (_faab ,2);_dcda ,_fgbe :=NewImage (_cbeb .Max .X ,_cbeb .Max .Y ,16,3,nil ,_fgce ,nil );if _fgbe !=nil {return nil ,_fgbe ;};_cadd (_faab ,_dcda ,_cbeb );if len (_fgce )!=0&&!_geag {if _cdfc :=_dcbe (_fgce ,_dcda );
_cdfc !=nil {return nil ,_cdfc ;};};return _dcda ,nil ;};func (_abgb *NRGBA16 )At (x ,y int )_c .Color {_egcb ,_ :=_abgb .ColorAt (x ,y );return _egcb };var _ Gray =&Monochrome {};func (_dfdc *CMYK32 )SetCMYK (x ,y int ,c _c .CMYK ){_eee :=4*(y *_dfdc .Width +x );
if _eee +3>=len (_dfdc .Data ){return ;};_dfdc .Data [_eee ]=c .C ;_dfdc .Data [_eee +1]=c .M ;_dfdc .Data [_eee +2]=c .Y ;_dfdc .Data [_eee +3]=c .K ;};func (_fdf *ImageBase )GetAlpha ()[]byte {return _fdf .Alpha };func (_egea *Gray2 )GrayAt (x ,y int )_c .Gray {_dfaa ,_ :=ColorAtGray2BPC (x ,y ,_egea .BytesPerLine ,_egea .Data ,_egea .Decode );
return _dfaa ;};func (_ccfab *Monochrome )setIndexedBit (_ageg int ){_ccfab .Data [(_ageg >>3)]|=0x80>>uint (_ageg &7);};func (_baae *Gray2 )Bounds ()_cg .Rectangle {return _cg .Rectangle {Max :_cg .Point {X :_baae .Width ,Y :_baae .Height }};};func _cdgc (_bgebc Gray ,_cgfa NRGBA ,_ccbca _cg .Rectangle ){for _dedb :=0;
_dedb < _ccbca .Max .X ;_dedb ++{for _aabb :=0;_aabb < _ccbca .Max .Y ;_aabb ++{_bbce :=_bgebc .GrayAt (_dedb ,_aabb );_cgfa .SetNRGBA (_dedb ,_aabb ,_gddd (_bbce ));};};};func _bg (_ddg *Monochrome ,_dc int )(*Monochrome ,error ){if _ddg ==nil {return nil ,_f .New ("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064");
};if _dc ==1{return _ddg .copy (),nil ;};if !IsPowerOf2 (uint (_dc )){return nil ,_b .Errorf ("\u0070\u0072\u006fvi\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006ci\u0064 \u0065x\u0070a\u006e\u0064\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_dc );
};_de :=_aee (_dc );return _cc (_ddg ,_dc ,_de );};func _dcaca (_aaga uint )uint {var _fgdf uint ;for _aaga !=0{_aaga >>=1;_fgdf ++;};return _fgdf -1;};func _aca (_ddc ,_gag int ,_cfa []byte )*Monochrome {_dgb :=_fba (_ddc ,_gag );_dgb .Data =_cfa ;return _dgb ;
};func _adad (_ffaf nrgba64 ,_caddf NRGBA ,_gagd _cg .Rectangle ){for _baba :=0;_baba < _gagd .Max .X ;_baba ++{for _fgabe :=0;_fgabe < _gagd .Max .Y ;_fgabe ++{_bfec :=_ffaf .NRGBA64At (_baba ,_fgabe );_caddf .SetNRGBA (_baba ,_fgabe ,_egfd (_bfec ));
};};};var _ Image =&NRGBA32 {};func _cff (_aba *Monochrome ,_agae ,_aad int )(*Monochrome ,error ){if _aba ==nil {return nil ,_f .New ("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064");};if _agae <=0||_aad <=0{return nil ,_f .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0073\u0063\u0061l\u0065\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020<\u003d\u0020\u0030");
};if _agae ==_aad {if _agae ==1{return _aba .copy (),nil ;};if _agae ==2||_agae ==4||_agae ==8{_bbb ,_abc :=_bg (_aba ,_agae );if _abc !=nil {return nil ,_abc ;};return _bbb ,nil ;};};_gf :=_agae *_aba .Width ;_dcg :=_aad *_aba .Height ;_eef :=_fba (_gf ,_dcg );
_ae :=_eef .BytesPerLine ;var (_ba ,_db ,_dea ,_fea ,_cdg int ;_aeb byte ;_bdgc error ;);for _db =0;_db < _aba .Height ;_db ++{_ba =_aad *_db *_ae ;for _dea =0;_dea < _aba .Width ;_dea ++{if _gb :=_aba .getBitAt (_dea ,_db );_gb {_cdg =_agae *_dea ;for _fea =0;
_fea < _agae ;_fea ++{_eef .setIndexedBit (_ba *8+_cdg +_fea );};};};for _fea =1;_fea < _aad ;_fea ++{_cgb :=_ba +_fea *_ae ;for _geb :=0;_geb < _ae ;_geb ++{if _aeb ,_bdgc =_eef .getByte (_ba +_geb );_bdgc !=nil {return nil ,_bdgc ;};if _bdgc =_eef .setByte (_cgb +_geb ,_aeb );
_bdgc !=nil {return nil ,_bdgc ;};};};};return _eef ,nil ;};func (_aag *Monochrome )setBit (_decgg ,_fbg int ){_aag .Data [_decgg +(_fbg >>3)]|=0x80>>uint (_fbg &7)};func (_edecc *Monochrome )copy ()*Monochrome {_agfb :=_fba (_edecc .Width ,_edecc .Height );
_agfb .ModelThreshold =_edecc .ModelThreshold ;_agfb .Data =make ([]byte ,len (_edecc .Data ));copy (_agfb .Data ,_edecc .Data );if len (_edecc .Decode )!=0{_agfb .Decode =make ([]float64 ,len (_edecc .Decode ));copy (_agfb .Decode ,_edecc .Decode );};
if len (_edecc .Alpha )!=0{_agfb .Alpha =make ([]byte ,len (_edecc .Alpha ));copy (_agfb .Alpha ,_edecc .Alpha );};return _agfb ;};func (_cfb *CMYK32 )Copy ()Image {return &CMYK32 {ImageBase :_cfb .copy ()}};func _gebe (_dgde *_cg .Gray )bool {for _eaace :=0;
_eaace < len (_dgde .Pix );_eaace ++{if !_gcf (_dgde .Pix [_eaace ]){return false ;};};return true ;};func (_feab *Gray16 )ColorModel ()_c .Model {return _c .Gray16Model };func _aaa (_bgeb NRGBA ,_dcga Gray ,_gcde _cg .Rectangle ){for _ddeb :=0;_ddeb < _gcde .Max .X ;
_ddeb ++{for _gcag :=0;_gcag < _gcde .Max .Y ;_gcag ++{_ebc :=_dcac (_bgeb .NRGBAAt (_ddeb ,_gcag ));_dcga .SetGray (_ddeb ,_gcag ,_ebc );};};};var _ _cg .Image =&NRGBA32 {};func _eeee (_gefe _cg .Image )(Image ,error ){if _adfc ,_gcbge :=_gefe .(*Monochrome );
_gcbge {return _adfc ,nil ;};_edcf :=_gefe .Bounds ();var _ecdcf Gray ;switch _ceaa :=_gefe .(type ){case Gray :_ecdcf =_ceaa ;case NRGBA :_ecdcf =&Gray8 {ImageBase :NewImageBase (_edcf .Max .X ,_edcf .Max .Y ,8,1,nil ,nil ,nil )};_fddc (_ecdcf ,_ceaa ,_edcf );
case nrgba64 :_ecdcf =&Gray8 {ImageBase :NewImageBase (_edcf .Max .X ,_edcf .Max .Y ,8,1,nil ,nil ,nil )};_daf (_ecdcf ,_ceaa ,_edcf );default:_ccfa ,_eedb :=GrayConverter .Convert (_gefe );if _eedb !=nil {return nil ,_eedb ;};_ecdcf =_ccfa .(Gray );};
_gbdf ,_agf :=NewImage (_edcf .Max .X ,_edcf .Max .Y ,1,1,nil ,nil ,nil );if _agf !=nil {return nil ,_agf ;};_bgfa :=_gbdf .(*Monochrome );_gebg :=AutoThresholdTriangle (GrayHistogram (_ecdcf ));for _cfff :=0;_cfff < _edcf .Max .X ;_cfff ++{for _dcbf :=0;
_dcbf < _edcf .Max .Y ;_dcbf ++{_afd :=_afg (_ecdcf .GrayAt (_cfff ,_dcbf ),monochromeModel (_gebg ));_bgfa .SetGray (_cfff ,_dcbf ,_afd );};};return _gbdf ,nil ;};func _dcbe (_efbf []byte ,_fcdd Image )error {_defe :=true ;for _gagg :=0;_gagg < len (_efbf );
_gagg ++{if _efbf [_gagg ]!=0xff{_defe =false ;break ;};};if _defe {switch _feade :=_fcdd .(type ){case *NRGBA32 :_feade .Alpha =nil ;case *NRGBA64 :_feade .Alpha =nil ;default:return _b .Errorf ("i\u006ete\u0072n\u0061l\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020i\u006d\u0061\u0067\u0065\u0020s\u0068\u006f\u0075l\u0064\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0074\u0079\u0070e\u0020\u002a\u004eRGB\u0041\u0033\u0032\u0020\u006f\u0072 \u002a\u004e\u0052\u0047\u0042\u0041\u0036\u0034\u0020\u0062\u0075\u0074 \u0069s\u003a\u0020\u0025\u0054",_fcdd );
};};return nil ;};func (_edeg *Gray4 )Set (x ,y int ,c _c .Color ){if x >=_edeg .Width ||y >=_edeg .Height {return ;};_bbag :=Gray4Model .Convert (c ).(_c .Gray );_edeg .setGray (x ,y ,_bbag );};func (_cefbd *Monochrome )Base ()*ImageBase {return &_cefbd .ImageBase };
func (_gefb *Gray4 )setGray (_gcgb int ,_cbca int ,_dbb _c .Gray ){_ecgg :=_cbca *_gefb .BytesPerLine ;_aefd :=_ecgg +(_gcgb >>1);if _aefd >=len (_gefb .Data ){return ;};_fgae :=_dbb .Y >>4;_gefb .Data [_aefd ]=(_gefb .Data [_aefd ]&(^(0xf0>>uint (4*(_gcgb &1)))))|(_fgae <<uint (4-4*(_gcgb &1)));
};func (_afb *Gray4 )At (x ,y int )_c .Color {_daec ,_ :=_afb .ColorAt (x ,y );return _daec };func _bae (_aaf _c .NRGBA64 )_c .Gray {var _ccfb _c .NRGBA64 ;if _aaf ==_ccfb {return _c .Gray {Y :0xff};};_dfda ,_bfg ,_eaa ,_ :=_aaf .RGBA ();_deaae :=(19595*_dfda +38470*_bfg +7471*_eaa +1<<15)>>24;
return _c .Gray {Y :uint8 (_deaae )};};func (_decc *Gray4 )Copy ()Image {return &Gray4 {ImageBase :_decc .copy ()}};func NewImageBase (width int ,height int ,bitsPerComponent int ,colorComponents int ,data []byte ,alpha []byte ,decode []float64 )ImageBase {_efae :=ImageBase {Width :width ,Height :height ,BitsPerComponent :bitsPerComponent ,ColorComponents :colorComponents ,Data :data ,Alpha :alpha ,Decode :decode ,BytesPerLine :BytesPerLine (width ,bitsPerComponent ,colorComponents )};
if data ==nil {_efae .Data =make ([]byte ,height *_efae .BytesPerLine );};return _efae ;};func (_cge *Monochrome )Copy ()Image {return &Monochrome {ImageBase :_cge .ImageBase .copy (),ModelThreshold :_cge .ModelThreshold };};func (_cggf *Gray16 )Bounds ()_cg .Rectangle {return _cg .Rectangle {Max :_cg .Point {X :_cggf .Width ,Y :_cggf .Height }};
};func (_afgc *Gray4 )Bounds ()_cg .Rectangle {return _cg .Rectangle {Max :_cg .Point {X :_afgc .Width ,Y :_afgc .Height }};};func (_bdga *ImageBase )setByte (_gafa int ,_egeb byte )error {if _gafa > len (_bdga .Data )-1{return _f .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_bdga .Data [_gafa ]=_egeb ;return nil ;};func (_bdef *ImageBase )HasAlpha ()bool {if _bdef .Alpha ==nil {return false ;};for _gbf :=range _bdef .Alpha {if _bdef .Alpha [_gbf ]!=0xff{return true ;};};return false ;};type RGBA interface{RGBAAt (_becg ,_cacg int )_c .RGBA ;
SetRGBA (_bcbf ,_fdgb int ,_ddbce _c .RGBA );};func (_gffgb *NRGBA32 )Copy ()Image {return &NRGBA32 {ImageBase :_gffgb .copy ()}};func ColorAtNRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_c .NRGBA ,error ){_egce :=y *width +x ;_bafbf :=3*_egce ;
if _bafbf +2>=len (data ){return _c .NRGBA {},_b .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_ccbc :=uint8 (0xff);if alpha !=nil &&len (alpha )> _egce {_ccbc =alpha [_egce ];};_deade ,_cbdeg ,_aeeed :=data [_bafbf ],data [_bafbf +1],data [_bafbf +2];if len (decode )==6{_deade =uint8 (uint32 (LinearInterpolate (float64 (_deade ),0,255,decode [0],decode [1]))&0xff);
_cbdeg =uint8 (uint32 (LinearInterpolate (float64 (_cbdeg ),0,255,decode [2],decode [3]))&0xff);_aeeed =uint8 (uint32 (LinearInterpolate (float64 (_aeeed ),0,255,decode [4],decode [5]))&0xff);};return _c .NRGBA {R :_deade ,G :_cbdeg ,B :_aeeed ,A :_ccbc },nil ;
};type SMasker interface{HasAlpha ()bool ;GetAlpha ()[]byte ;MakeAlpha ();};func ColorAtGray4BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_c .Gray ,error ){_dcfa :=y *bytesPerLine +x >>1;if _dcfa >=len (data ){return _c .Gray {},_b .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_cfba :=data [_dcfa ]>>uint (4-(x &1)*4)&0xf;if len (decode )==2{_cfba =uint8 (uint32 (LinearInterpolate (float64 (_cfba ),0,15,decode [0],decode [1]))&0xf);};return _c .Gray {Y :_cfba *17&0xff},nil ;};func _acbd (_bcc _cg .Image ,_afde uint8 )*_cg .Gray {_fdc :=_bcc .Bounds ();
_edbca :=_cg .NewGray (_fdc );var (_adfg _c .Color ;_ggabg _c .Gray ;);for _edaf :=0;_edaf < _fdc .Max .X ;_edaf ++{for _fbfa :=0;_fbfa < _fdc .Max .Y ;_fbfa ++{_adfg =_bcc .At (_edaf ,_fbfa );_edbca .Set (_edaf ,_fbfa ,_adfg );_ggabg =_edbca .GrayAt (_edaf ,_fbfa );
_edbca .SetGray (_edaf ,_fbfa ,_c .Gray {Y :_efcgc (_ggabg .Y ,_afde )});};};return _edbca ;};func _efcgc (_agb ,_fgbca uint8 )uint8 {if _agb < _fgbca {return 255;};return 0;};func (_caa *NRGBA32 )NRGBAAt (x ,y int )_c .NRGBA {_dbgce ,_ :=ColorAtNRGBA32 (x ,y ,_caa .Width ,_caa .Data ,_caa .Alpha ,_caa .Decode );
return _dbgce ;};func (_aecd *Monochrome )setGrayBit (_fdb ,_gffb int ){_aecd .Data [_fdb ]|=0x80>>uint (_gffb &7)};func (_dab *Gray16 )Validate ()error {if len (_dab .Data )!=_dab .Height *_dab .BytesPerLine {return ErrInvalidImage ;};return nil ;};var _cafgc [256]uint8 ;
func _gbb (_dbff *Monochrome ,_gbdb ,_dcgca ,_gacf ,_cdbb int ,_ebdb RasterOperator ){if _gbdb < 0{_gacf +=_gbdb ;_gbdb =0;};_dcbc :=_gbdb +_gacf -_dbff .Width ;if _dcbc > 0{_gacf -=_dcbc ;};if _dcgca < 0{_cdbb +=_dcgca ;_dcgca =0;};_dee :=_dcgca +_cdbb -_dbff .Height ;
if _dee > 0{_cdbb -=_dee ;};if _gacf <=0||_cdbb <=0{return ;};if (_gbdb &7)==0{_cee (_dbff ,_gbdb ,_dcgca ,_gacf ,_cdbb ,_ebdb );}else {_aaaa (_dbff ,_gbdb ,_dcgca ,_gacf ,_cdbb ,_ebdb );};};func _afe (_bcee ,_dac CMYK ,_bff _cg .Rectangle ){for _ffbd :=0;
_ffbd < _bff .Max .X ;_ffbd ++{for _fgcb :=0;_fgcb < _bff .Max .Y ;_fgcb ++{_dac .SetCMYK (_ffbd ,_fgcb ,_bcee .CMYKAt (_ffbd ,_fgcb ));};};};func (_bcad *NRGBA16 )Base ()*ImageBase {return &_bcad .ImageBase };func _geab (_dgaae *_cg .NYCbCrA ,_abdde NRGBA ,_cdfgb _cg .Rectangle ){for _caea :=0;
_caea < _cdfgb .Max .X ;_caea ++{for _cgfe :=0;_cgfe < _cdfgb .Max .Y ;_cgfe ++{_gead :=_dgaae .NYCbCrAAt (_caea ,_cgfe );_abdde .SetNRGBA (_caea ,_cgfe ,_edec (_gead ));};};};func (_edae *Gray16 )GrayAt (x ,y int )_c .Gray {_baec ,_ :=_edae .ColorAt (x ,y );
return _c .Gray {Y :uint8 (_baec .(_c .Gray16 ).Y >>8)};};type ImageBase struct{Width ,Height int ;BitsPerComponent ,ColorComponents int ;Data ,Alpha []byte ;Decode []float64 ;BytesPerLine int ;};func (_egad *Gray16 )Copy ()Image {return &Gray16 {ImageBase :_egad .copy ()}};
type CMYK32 struct{ImageBase };func (_agcb *ImageBase )setTwoBytes (_cce int ,_aafe uint16 )error {if _cce +1> len (_agcb .Data )-1{return _f .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_agcb .Data [_cce ]=byte ((_aafe &0xff00)>>8);
_agcb .Data [_cce +1]=byte (_aafe &0xff);return nil ;};type ColorConverter interface{Convert (_gff _cg .Image )(Image ,error );};func (_gacd *Gray2 )At (x ,y int )_c .Color {_ffec ,_ :=_gacd .ColorAt (x ,y );return _ffec };func (_abga *Gray16 )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtGray16BPC (x ,y ,_abga .BytesPerLine ,_abga .Data ,_abga .Decode );
};func _cde (_fcc _c .NRGBA )_c .CMYK {_ecdc ,_fgab ,_dddb ,_ :=_fcc .RGBA ();_eabg ,_fed ,_bffa ,_dfg :=_c .RGBToCMYK (uint8 (_ecdc >>8),uint8 (_fgab >>8),uint8 (_dddb >>8));return _c .CMYK {C :_eabg ,M :_fed ,Y :_bffa ,K :_dfg };};func _fddc (_gfge Gray ,_cdbc NRGBA ,_efa _cg .Rectangle ){for _cga :=0;
_cga < _efa .Max .X ;_cga ++{for _gbg :=0;_gbg < _efa .Max .Y ;_gbg ++{_gage :=_fgbc (_cdbc .NRGBAAt (_cga ,_gbg ));_gfge .SetGray (_cga ,_gbg ,_gage );};};};func _daf (_bbf Gray ,_agdb nrgba64 ,_gggc _cg .Rectangle ){for _ccdg :=0;_ccdg < _gggc .Max .X ;
_ccdg ++{for _ccdc :=0;_ccdc < _gggc .Max .Y ;_ccdc ++{_fgcg :=_bae (_agdb .NRGBA64At (_ccdg ,_ccdc ));_bbf .SetGray (_ccdg ,_ccdc ,_fgcg );};};};type Histogramer interface{Histogram ()[256]int ;};func _ff ()(_gdb [256]uint32 ){for _eb :=0;_eb < 256;_eb ++{if _eb &0x01!=0{_gdb [_eb ]|=0xf;
};if _eb &0x02!=0{_gdb [_eb ]|=0xf0;};if _eb &0x04!=0{_gdb [_eb ]|=0xf00;};if _eb &0x08!=0{_gdb [_eb ]|=0xf000;};if _eb &0x10!=0{_gdb [_eb ]|=0xf0000;};if _eb &0x20!=0{_gdb [_eb ]|=0xf00000;};if _eb &0x40!=0{_gdb [_eb ]|=0xf000000;};if _eb &0x80!=0{_gdb [_eb ]|=0xf0000000;
};};return _gdb ;};func _abab (_gfd NRGBA ,_edb CMYK ,_bdad _cg .Rectangle ){for _dccf :=0;_dccf < _bdad .Max .X ;_dccf ++{for _daa :=0;_daa < _bdad .Max .Y ;_daa ++{_ddbf :=_gfd .NRGBAAt (_dccf ,_daa );_edb .SetCMYK (_dccf ,_daa ,_cde (_ddbf ));};};};
const (_fcgc shift =iota ;_bbfa ;);const (PixSrc RasterOperator =0xc;PixDst RasterOperator =0xa;PixNotSrc RasterOperator =0x3;PixNotDst RasterOperator =0x5;PixClr RasterOperator =0x0;PixSet RasterOperator =0xf;PixSrcOrDst RasterOperator =0xe;PixSrcAndDst RasterOperator =0x8;
PixSrcXorDst RasterOperator =0x6;PixNotSrcOrDst RasterOperator =0xb;PixNotSrcAndDst RasterOperator =0x2;PixSrcOrNotDst RasterOperator =0xd;PixSrcAndNotDst RasterOperator =0x4;PixNotPixSrcOrDst RasterOperator =0x1;PixNotPixSrcAndDst RasterOperator =0x7;
PixNotPixSrcXorDst RasterOperator =0x9;PixPaint =PixSrcOrDst ;PixSubtract =PixNotSrcAndDst ;PixMask =PixSrcAndDst ;);func GetConverter (bitsPerComponent ,colorComponents int )(ColorConverter ,error ){switch colorComponents {case 1:switch bitsPerComponent {case 1:return MonochromeConverter ,nil ;
case 2:return Gray2Converter ,nil ;case 4:return Gray4Converter ,nil ;case 8:return GrayConverter ,nil ;case 16:return Gray16Converter ,nil ;};case 3:switch bitsPerComponent {case 4:return NRGBA16Converter ,nil ;case 8:return NRGBAConverter ,nil ;case 16:return NRGBA64Converter ,nil ;
};case 4:return CMYKConverter ,nil ;};return nil ,_b .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0043o\u006e\u0076\u0065\u0072\u0074\u0065\u0072\u0020\u0070\u0061\u0072\u0061\u006d\u0065t\u0065\u0072\u0073\u002e\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003a\u0020\u0025\u0064\u002c\u0020\u0043\u006f\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006et\u0073\u003a \u0025\u0064",bitsPerComponent ,colorComponents );
};func (_efad *NRGBA32 )ColorModel ()_c .Model {return _c .NRGBAModel };type NRGBA64 struct{ImageBase };var _ Image =&NRGBA16 {};func ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine int ,data []byte ,decode []float64 )(_c .Color ,error ){switch bitsPerColor {case 1:return ColorAtGray1BPC (x ,y ,bytesPerLine ,data ,decode );
case 2:return ColorAtGray2BPC (x ,y ,bytesPerLine ,data ,decode );case 4:return ColorAtGray4BPC (x ,y ,bytesPerLine ,data ,decode );case 8:return ColorAtGray8BPC (x ,y ,bytesPerLine ,data ,decode );case 16:return ColorAtGray16BPC (x ,y ,bytesPerLine ,data ,decode );
default:return nil ,_b .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0067\u0072\u0061\u0079\u0020\u0073c\u0061\u006c\u0065\u0020\u0062\u0069\u0074s\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020a\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );
};};var _ Gray =&Gray8 {};func (_fbed *NRGBA64 )Validate ()error {if len (_fbed .Data )!=3*2*_fbed .Width *_fbed .Height {return _f .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func _bed (_eec ,_ab *Monochrome )(_agg error ){_dce :=_ab .BytesPerLine ;_cgc :=_eec .BytesPerLine ;var _fbb ,_efg ,_dae ,_bcf ,_bdec int ;for _dae =0;_dae < _ab .Height ;_dae ++{_fbb =_dae *_dce ;_efg =8*_dae *_cgc ;for _bcf =0;_bcf < _dce ;
_bcf ++{if _agg =_eec .setEightBytes (_efg +_bcf *8,_dca [_ab .Data [_fbb +_bcf ]]);_agg !=nil {return _agg ;};};for _bdec =1;_bdec < 8;_bdec ++{for _bcf =0;_bcf < _cgc ;_bcf ++{if _agg =_eec .setByte (_efg +_bdec *_cgc +_bcf ,_eec .Data [_efg +_bcf ]);
_agg !=nil {return _agg ;};};};};return nil ;};var _ NRGBA =&NRGBA32 {};func (_fbbc *ImageBase )setEightPartlyBytes (_gebde ,_cggg int ,_eecd uint64 )(_egbae error ){var (_dfe byte ;_gecc int ;);for _ccfd :=1;_ccfd <=_cggg ;_ccfd ++{_gecc =64-_ccfd *8;
_dfe =byte (_eecd >>uint (_gecc )&0xff);if _egbae =_fbbc .setByte (_gebde +_ccfd -1,_dfe );_egbae !=nil {return _egbae ;};};_ceaag :=_fbbc .BytesPerLine *8-_fbbc .Width ;if _ceaag ==0{return nil ;};_gecc -=8;_dfe =byte (_eecd >>uint (_gecc )&0xff)<<uint (_ceaag );
if _egbae =_fbbc .setByte (_gebde +_cggg ,_dfe );_egbae !=nil {return _egbae ;};return nil ;};type Gray4 struct{ImageBase };func (_eabe *Gray4 )Histogram ()(_gfe [256]int ){for _ace :=0;_ace < _eabe .Width ;_ace ++{for _cab :=0;_cab < _eabe .Height ;_cab ++{_gfe [_eabe .GrayAt (_ace ,_cab ).Y ]++;
};};return _gfe ;};func (_fca *ImageBase )Pix ()[]byte {return _fca .Data };func _gede (_cefe ,_agef ,_cbf byte )byte {return (_cefe &^(_cbf ))|(_agef &_cbf )};func _cdd (_bfb *Monochrome ,_cgff ...int )(_fa *Monochrome ,_ebg error ){if _bfb ==nil {return nil ,_f .New ("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d");
};if len (_cgff )==0{return nil ,_f .New ("\u0074h\u0065\u0072e\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0061\u0074 \u006c\u0065\u0061\u0073\u0074\u0020o\u006e\u0065\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u006f\u0066 \u0072\u0065\u0064\u0075\u0063\u0074\u0069\u006f\u006e");
};_fda :=_deac ();_fa =_bfb ;for _ ,_ad :=range _cgff {if _ad <=0{break ;};_fa ,_ebg =_bec (_fa ,_ad ,_fda );if _ebg !=nil {return nil ,_ebg ;};};return _fa ,nil ;};func (_faed *Monochrome )Scale (scale float64 )(*Monochrome ,error ){var _bfa bool ;_cbc :=scale ;
if scale < 1{_cbc =1/scale ;_bfa =true ;};_bggc :=NextPowerOf2 (uint (_cbc ));if InDelta (float64 (_bggc ),_cbc ,0.001){if _bfa {return _faed .ReduceBinary (_cbc );};return _faed .ExpandBinary (int (_bggc ));};_dge :=int (_g .RoundToEven (float64 (_faed .Width )*scale ));
_bgge :=int (_g .RoundToEven (float64 (_faed .Height )*scale ));return _faed .ScaleLow (_dge ,_bgge );};func (_cdba *NRGBA64 )ColorModel ()_c .Model {return _c .NRGBA64Model };func (_cgdef *NRGBA64 )Set (x ,y int ,c _c .Color ){_gbee :=(y *_cgdef .Width +x )*2;
_aafdf :=_gbee *3;if _aafdf +5>=len (_cgdef .Data ){return ;};_fbcc :=_c .NRGBA64Model .Convert (c ).(_c .NRGBA64 );_cgdef .setNRGBA64 (_aafdf ,_fbcc ,_gbee );};func _bgbc (_cddde *Monochrome ,_adbb ,_bcb ,_ebdc ,_cbb int ,_cced RasterOperator ,_cgac *Monochrome ,_fbab ,_fbbcc int )error {var (_dcbfb byte ;
_aaeba int ;_cggc int ;_bfcb ,_fgdd int ;_daca ,_cecff int ;);_edegd :=_ebdc >>3;_bffb :=_ebdc &7;if _bffb > 0{_dcbfb =_edge [_bffb ];};_aaeba =_cgac .BytesPerLine *_fbbcc +(_fbab >>3);_cggc =_cddde .BytesPerLine *_bcb +(_adbb >>3);switch _cced {case PixSrc :for _daca =0;
_daca < _cbb ;_daca ++{_bfcb =_aaeba +_daca *_cgac .BytesPerLine ;_fgdd =_cggc +_daca *_cddde .BytesPerLine ;for _cecff =0;_cecff < _edegd ;_cecff ++{_cddde .Data [_fgdd ]=_cgac .Data [_bfcb ];_fgdd ++;_bfcb ++;};if _bffb > 0{_cddde .Data [_fgdd ]=_gede (_cddde .Data [_fgdd ],_cgac .Data [_bfcb ],_dcbfb );
};};case PixNotSrc :for _daca =0;_daca < _cbb ;_daca ++{_bfcb =_aaeba +_daca *_cgac .BytesPerLine ;_fgdd =_cggc +_daca *_cddde .BytesPerLine ;for _cecff =0;_cecff < _edegd ;_cecff ++{_cddde .Data [_fgdd ]=^(_cgac .Data [_bfcb ]);_fgdd ++;_bfcb ++;};if _bffb > 0{_cddde .Data [_fgdd ]=_gede (_cddde .Data [_fgdd ],^_cgac .Data [_bfcb ],_dcbfb );
};};case PixSrcOrDst :for _daca =0;_daca < _cbb ;_daca ++{_bfcb =_aaeba +_daca *_cgac .BytesPerLine ;_fgdd =_cggc +_daca *_cddde .BytesPerLine ;for _cecff =0;_cecff < _edegd ;_cecff ++{_cddde .Data [_fgdd ]|=_cgac .Data [_bfcb ];_fgdd ++;_bfcb ++;};if _bffb > 0{_cddde .Data [_fgdd ]=_gede (_cddde .Data [_fgdd ],_cgac .Data [_bfcb ]|_cddde .Data [_fgdd ],_dcbfb );
};};case PixSrcAndDst :for _daca =0;_daca < _cbb ;_daca ++{_bfcb =_aaeba +_daca *_cgac .BytesPerLine ;_fgdd =_cggc +_daca *_cddde .BytesPerLine ;for _cecff =0;_cecff < _edegd ;_cecff ++{_cddde .Data [_fgdd ]&=_cgac .Data [_bfcb ];_fgdd ++;_bfcb ++;};if _bffb > 0{_cddde .Data [_fgdd ]=_gede (_cddde .Data [_fgdd ],_cgac .Data [_bfcb ]&_cddde .Data [_fgdd ],_dcbfb );
};};case PixSrcXorDst :for _daca =0;_daca < _cbb ;_daca ++{_bfcb =_aaeba +_daca *_cgac .BytesPerLine ;_fgdd =_cggc +_daca *_cddde .BytesPerLine ;for _cecff =0;_cecff < _edegd ;_cecff ++{_cddde .Data [_fgdd ]^=_cgac .Data [_bfcb ];_fgdd ++;_bfcb ++;};if _bffb > 0{_cddde .Data [_fgdd ]=_gede (_cddde .Data [_fgdd ],_cgac .Data [_bfcb ]^_cddde .Data [_fgdd ],_dcbfb );
};};case PixNotSrcOrDst :for _daca =0;_daca < _cbb ;_daca ++{_bfcb =_aaeba +_daca *_cgac .BytesPerLine ;_fgdd =_cggc +_daca *_cddde .BytesPerLine ;for _cecff =0;_cecff < _edegd ;_cecff ++{_cddde .Data [_fgdd ]|=^(_cgac .Data [_bfcb ]);_fgdd ++;_bfcb ++;
};if _bffb > 0{_cddde .Data [_fgdd ]=_gede (_cddde .Data [_fgdd ],^(_cgac .Data [_bfcb ])|_cddde .Data [_fgdd ],_dcbfb );};};case PixNotSrcAndDst :for _daca =0;_daca < _cbb ;_daca ++{_bfcb =_aaeba +_daca *_cgac .BytesPerLine ;_fgdd =_cggc +_daca *_cddde .BytesPerLine ;
for _cecff =0;_cecff < _edegd ;_cecff ++{_cddde .Data [_fgdd ]&=^(_cgac .Data [_bfcb ]);_fgdd ++;_bfcb ++;};if _bffb > 0{_cddde .Data [_fgdd ]=_gede (_cddde .Data [_fgdd ],^(_cgac .Data [_bfcb ])&_cddde .Data [_fgdd ],_dcbfb );};};case PixSrcOrNotDst :for _daca =0;
_daca < _cbb ;_daca ++{_bfcb =_aaeba +_daca *_cgac .BytesPerLine ;_fgdd =_cggc +_daca *_cddde .BytesPerLine ;for _cecff =0;_cecff < _edegd ;_cecff ++{_cddde .Data [_fgdd ]=_cgac .Data [_bfcb ]|^(_cddde .Data [_fgdd ]);_fgdd ++;_bfcb ++;};if _bffb > 0{_cddde .Data [_fgdd ]=_gede (_cddde .Data [_fgdd ],_cgac .Data [_bfcb ]|^(_cddde .Data [_fgdd ]),_dcbfb );
};};case PixSrcAndNotDst :for _daca =0;_daca < _cbb ;_daca ++{_bfcb =_aaeba +_daca *_cgac .BytesPerLine ;_fgdd =_cggc +_daca *_cddde .BytesPerLine ;for _cecff =0;_cecff < _edegd ;_cecff ++{_cddde .Data [_fgdd ]=_cgac .Data [_bfcb ]&^(_cddde .Data [_fgdd ]);
_fgdd ++;_bfcb ++;};if _bffb > 0{_cddde .Data [_fgdd ]=_gede (_cddde .Data [_fgdd ],_cgac .Data [_bfcb ]&^(_cddde .Data [_fgdd ]),_dcbfb );};};case PixNotPixSrcOrDst :for _daca =0;_daca < _cbb ;_daca ++{_bfcb =_aaeba +_daca *_cgac .BytesPerLine ;_fgdd =_cggc +_daca *_cddde .BytesPerLine ;
for _cecff =0;_cecff < _edegd ;_cecff ++{_cddde .Data [_fgdd ]=^(_cgac .Data [_bfcb ]|_cddde .Data [_fgdd ]);_fgdd ++;_bfcb ++;};if _bffb > 0{_cddde .Data [_fgdd ]=_gede (_cddde .Data [_fgdd ],^(_cgac .Data [_bfcb ]|_cddde .Data [_fgdd ]),_dcbfb );};};
case PixNotPixSrcAndDst :for _daca =0;_daca < _cbb ;_daca ++{_bfcb =_aaeba +_daca *_cgac .BytesPerLine ;_fgdd =_cggc +_daca *_cddde .BytesPerLine ;for _cecff =0;_cecff < _edegd ;_cecff ++{_cddde .Data [_fgdd ]=^(_cgac .Data [_bfcb ]&_cddde .Data [_fgdd ]);
_fgdd ++;_bfcb ++;};if _bffb > 0{_cddde .Data [_fgdd ]=_gede (_cddde .Data [_fgdd ],^(_cgac .Data [_bfcb ]&_cddde .Data [_fgdd ]),_dcbfb );};};case PixNotPixSrcXorDst :for _daca =0;_daca < _cbb ;_daca ++{_bfcb =_aaeba +_daca *_cgac .BytesPerLine ;_fgdd =_cggc +_daca *_cddde .BytesPerLine ;
for _cecff =0;_cecff < _edegd ;_cecff ++{_cddde .Data [_fgdd ]=^(_cgac .Data [_bfcb ]^_cddde .Data [_fgdd ]);_fgdd ++;_bfcb ++;};if _bffb > 0{_cddde .Data [_fgdd ]=_gede (_cddde .Data [_fgdd ],^(_cgac .Data [_bfcb ]^_cddde .Data [_fgdd ]),_dcbfb );};};
default:_ee .Log .Debug ("\u0050\u0072ov\u0069\u0064\u0065d\u0020\u0069\u006e\u0076ali\u0064 r\u0061\u0073\u0074\u0065\u0072\u0020\u006fpe\u0072\u0061\u0074\u006f\u0072\u003a\u0020%\u0076",_cced );return _f .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072");
};return nil ;};func _dbd ()(_gfg [256]uint64 ){for _ebf :=0;_ebf < 256;_ebf ++{if _ebf &0x01!=0{_gfg [_ebf ]|=0xff;};if _ebf &0x02!=0{_gfg [_ebf ]|=0xff00;};if _ebf &0x04!=0{_gfg [_ebf ]|=0xff0000;};if _ebf &0x08!=0{_gfg [_ebf ]|=0xff000000;};if _ebf &0x10!=0{_gfg [_ebf ]|=0xff00000000;
};if _ebf &0x20!=0{_gfg [_ebf ]|=0xff0000000000;};if _ebf &0x40!=0{_gfg [_ebf ]|=0xff000000000000;};if _ebf &0x80!=0{_gfg [_ebf ]|=0xff00000000000000;};};return _gfg ;};type NRGBA32 struct{ImageBase };func _bgfad (_aged RGBA ,_dafd Gray ,_aada _cg .Rectangle ){for _dece :=0;
_dece < _aada .Max .X ;_dece ++{for _abaa :=0;_abaa < _aada .Max .Y ;_abaa ++{_cged :=_egba (_aged .RGBAAt (_dece ,_abaa ));_dafd .SetGray (_dece ,_abaa ,_cged );};};};func (_dcgf *Gray8 )Bounds ()_cg .Rectangle {return _cg .Rectangle {Max :_cg .Point {X :_dcgf .Width ,Y :_dcgf .Height }};
};var _ Image =&NRGBA64 {};type NRGBA interface{NRGBAAt (_dega ,_bgcf int )_c .NRGBA ;SetNRGBA (_dabfc ,_gafef int ,_gcca _c .NRGBA );};func ColorAtGray2BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_c .Gray ,error ){_aae :=y *bytesPerLine +x >>2;
if _aae >=len (data ){return _c .Gray {},_b .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_dadb :=data [_aae ]>>uint (6-(x &3)*2)&3;if len (decode )==2{_dadb =uint8 (uint32 (LinearInterpolate (float64 (_dadb ),0,3.0,decode [0],decode [1]))&3);};return _c .Gray {Y :_dadb *85},nil ;};func (_gdbf *Gray8 )ColorModel ()_c .Model {return _c .GrayModel };
func (_bgb *Gray2 )ColorModel ()_c .Model {return Gray2Model };func (_gdgg *NRGBA64 )NRGBA64At (x ,y int )_c .NRGBA64 {_agddf ,_ :=ColorAtNRGBA64 (x ,y ,_gdgg .Width ,_gdgg .Data ,_gdgg .Alpha ,_gdgg .Decode );return _agddf ;};func _bec (_edf *Monochrome ,_becd int ,_bda []byte )(_ddb *Monochrome ,_gae error ){const _ggd ="\u0072\u0065d\u0075\u0063\u0065R\u0061\u006e\u006b\u0042\u0069\u006e\u0061\u0072\u0079";
if _edf ==nil {return nil ,_f .New ("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d");};if _becd < 1||_becd > 4{return nil ,_f .New ("\u006c\u0065\u0076\u0065\u006c\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020\u0073e\u0074\u0020\u007b\u0031\u002c\u0032\u002c\u0033\u002c\u0034\u007d");
};if _edf .Height <=1{return nil ,_f .New ("\u0073\u006f\u0075rc\u0065\u0020\u0068\u0065\u0069\u0067\u0068\u0074\u0020m\u0075s\u0074 \u0062e\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020\u0027\u0032\u0027");};_ddb =_fba (_edf .Width /2,_edf .Height /2);
if _bda ==nil {_bda =_deac ();};_aea :=_effg (_edf .BytesPerLine ,2*_ddb .BytesPerLine );switch _becd {case 1:_gae =_deaa (_edf ,_ddb ,_bda ,_aea );case 2:_gae =_cfc (_edf ,_ddb ,_bda ,_aea );case 3:_gae =_bbab (_edf ,_ddb ,_bda ,_aea );case 4:_gae =_ege (_edf ,_ddb ,_bda ,_aea );
};if _gae !=nil {return nil ,_gae ;};return _ddb ,nil ;};func _cadd (_cagc _cg .Image ,_fgeee Image ,_gaeba _cg .Rectangle ){if _bbac ,_dbafe :=_cagc .(SMasker );_dbafe &&_bbac .HasAlpha (){_fgeee .(SMasker ).MakeAlpha ();};_ebd (_cagc ,_fgeee ,_gaeba );
};func _gga (_cdeb _c .Gray )_c .Gray {_cdeb .Y >>=4;_cdeb .Y |=_cdeb .Y <<4;return _cdeb };func _dgfc (_ccg _c .RGBA )_c .CMYK {_gbaa ,_fedb ,_ebde ,_eged :=_c .RGBToCMYK (_ccg .R ,_ccg .G ,_ccg .B );return _c .CMYK {C :_gbaa ,M :_fedb ,Y :_ebde ,K :_eged };
};func _cfc (_ebgc ,_cdda *Monochrome ,_fgc []byte ,_ddgb int )(_ece error ){var (_adf ,_acce ,_egb ,_af ,_ccfg ,_bba ,_acf ,_dcge int ;_abf ,_fdg ,_gea ,_aff uint32 ;_eba ,_fdea byte ;_bac uint16 ;);_gebd :=make ([]byte ,4);_ddf :=make ([]byte ,4);for _egb =0;
_egb < _ebgc .Height -1;_egb ,_af =_egb +2,_af +1{_adf =_egb *_ebgc .BytesPerLine ;_acce =_af *_cdda .BytesPerLine ;for _ccfg ,_bba =0,0;_ccfg < _ddgb ;_ccfg ,_bba =_ccfg +4,_bba +1{for _acf =0;_acf < 4;_acf ++{_dcge =_adf +_ccfg +_acf ;if _dcge <=len (_ebgc .Data )-1&&_dcge < _adf +_ebgc .BytesPerLine {_gebd [_acf ]=_ebgc .Data [_dcge ];
}else {_gebd [_acf ]=0x00;};_dcge =_adf +_ebgc .BytesPerLine +_ccfg +_acf ;if _dcge <=len (_ebgc .Data )-1&&_dcge < _adf +(2*_ebgc .BytesPerLine ){_ddf [_acf ]=_ebgc .Data [_dcge ];}else {_ddf [_acf ]=0x00;};};_abf =_a .BigEndian .Uint32 (_gebd );_fdg =_a .BigEndian .Uint32 (_ddf );
_gea =_abf &_fdg ;_gea |=_gea <<1;_aff =_abf |_fdg ;_aff &=_aff <<1;_fdg =_gea |_aff ;_fdg &=0xaaaaaaaa;_abf =_fdg |(_fdg <<7);_eba =byte (_abf >>24);_fdea =byte ((_abf >>8)&0xff);_dcge =_acce +_bba ;if _dcge +1==len (_cdda .Data )-1||_dcge +1>=_acce +_cdda .BytesPerLine {if _ece =_cdda .setByte (_dcge ,_fgc [_eba ]);
_ece !=nil {return _b .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_dcge );};}else {_bac =(uint16 (_fgc [_eba ])<<8)|uint16 (_fgc [_fdea ]);if _ece =_cdda .setTwoBytes (_dcge ,_bac );_ece !=nil {return _b .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_dcge );
};_bba ++;};};};return nil ;};func (_cgbg *Monochrome )getBitAt (_gca ,_gdbc int )bool {_bdbe :=_gdbc *_cgbg .BytesPerLine +(_gca >>3);_cgfc :=_gca &0x07;_ggef :=uint (7-_cgfc );if _bdbe > len (_cgbg .Data )-1{return false ;};if (_cgbg .Data [_bdbe ]>>_ggef )&0x01>=1{return true ;
};return false ;};func _eeed (_cgedg *Monochrome ,_cac ,_abff int ,_cfbgd ,_dcfc int ,_dddd RasterOperator ,_dbab *Monochrome ,_agfc ,_degd int )error {var _dcggd ,_geaf ,_deca ,_bged int ;if _cac < 0{_agfc -=_cac ;_cfbgd +=_cac ;_cac =0;};if _agfc < 0{_cac -=_agfc ;
_cfbgd +=_agfc ;_agfc =0;};_dcggd =_cac +_cfbgd -_cgedg .Width ;if _dcggd > 0{_cfbgd -=_dcggd ;};_geaf =_agfc +_cfbgd -_dbab .Width ;if _geaf > 0{_cfbgd -=_geaf ;};if _abff < 0{_degd -=_abff ;_dcfc +=_abff ;_abff =0;};if _degd < 0{_abff -=_degd ;_dcfc +=_degd ;
_degd =0;};_deca =_abff +_dcfc -_cgedg .Height ;if _deca > 0{_dcfc -=_deca ;};_bged =_degd +_dcfc -_dbab .Height ;if _bged > 0{_dcfc -=_bged ;};if _cfbgd <=0||_dcfc <=0{return nil ;};var _dbaag error ;switch {case _cac &7==0&&_agfc &7==0:_dbaag =_bgbc (_cgedg ,_cac ,_abff ,_cfbgd ,_dcfc ,_dddd ,_dbab ,_agfc ,_degd );
case _cac &7==_agfc &7:_dbaag =_cgd (_cgedg ,_cac ,_abff ,_cfbgd ,_dcfc ,_dddd ,_dbab ,_agfc ,_degd );default:_dbaag =_bcbd (_cgedg ,_cac ,_abff ,_cfbgd ,_dcfc ,_dddd ,_dbab ,_agfc ,_degd );};if _dbaag !=nil {return _dbaag ;};return nil ;};var _ Gray =&Gray2 {};
func InDelta (expected ,current ,delta float64 )bool {_cecf :=expected -current ;if _cecf <=-delta ||_cecf >=delta {return false ;};return true ;};func _fagg (_febf _c .Color )_c .Color {_bfbd :=_c .GrayModel .Convert (_febf ).(_c .Gray );return _ecgd (_bfbd );
};func (_fafg *NRGBA16 )NRGBAAt (x ,y int )_c .NRGBA {_bfee ,_ :=ColorAtNRGBA16 (x ,y ,_fafg .Width ,_fafg .BytesPerLine ,_fafg .Data ,_fafg .Alpha ,_fafg .Decode );return _bfee ;};func (_eag *Monochrome )ReduceBinary (factor float64 )(*Monochrome ,error ){_add :=_dcaca (uint (factor ));
if !IsPowerOf2 (uint (factor )){_add ++;};_becb :=make ([]int ,_add );for _dag :=range _becb {_becb [_dag ]=4;};_feg ,_dfa :=_cdd (_eag ,_becb ...);if _dfa !=nil {return nil ,_dfa ;};return _feg ,nil ;};func (_gbd *CMYK32 )Bounds ()_cg .Rectangle {return _cg .Rectangle {Max :_cg .Point {X :_gbd .Width ,Y :_gbd .Height }};
};func (_agcc *Gray8 )Histogram ()(_ffg [256]int ){for _ggeec :=0;_ggeec < len (_agcc .Data );_ggeec ++{_ffg [_agcc .Data [_ggeec ]]++;};return _ffg ;};var _ Gray =&Gray16 {};var _ _cg .Image =&NRGBA16 {};func _aaaa (_gfagc *Monochrome ,_bafca ,_ebbg int ,_dgad ,_bbbb int ,_edca RasterOperator ){var (_fedee bool ;
_accda bool ;_edgac int ;_gadg int ;_deadg int ;_gbfa int ;_bbdf bool ;_acca byte ;);_daddb :=8-(_bafca &7);_dcbce :=_afec [_daddb ];_ccdgff :=_gfagc .BytesPerLine *_ebbg +(_bafca >>3);if _dgad < _daddb {_fedee =true ;_dcbce &=_edge [8-_daddb +_dgad ];
};if !_fedee {_edgac =(_dgad -_daddb )>>3;if _edgac !=0{_accda =true ;_gadg =_ccdgff +1;};};_deadg =(_bafca +_dgad )&7;if !(_fedee ||_deadg ==0){_bbdf =true ;_acca =_edge [_deadg ];_gbfa =_ccdgff +1+_edgac ;};var _gcab ,_dafb int ;switch _edca {case PixClr :for _gcab =0;
_gcab < _bbbb ;_gcab ++{_gfagc .Data [_ccdgff ]=_gede (_gfagc .Data [_ccdgff ],0x0,_dcbce );_ccdgff +=_gfagc .BytesPerLine ;};if _accda {for _gcab =0;_gcab < _bbbb ;_gcab ++{for _dafb =0;_dafb < _edgac ;_dafb ++{_gfagc .Data [_gadg +_dafb ]=0x0;};_gadg +=_gfagc .BytesPerLine ;
};};if _bbdf {for _gcab =0;_gcab < _bbbb ;_gcab ++{_gfagc .Data [_gbfa ]=_gede (_gfagc .Data [_gbfa ],0x0,_acca );_gbfa +=_gfagc .BytesPerLine ;};};case PixSet :for _gcab =0;_gcab < _bbbb ;_gcab ++{_gfagc .Data [_ccdgff ]=_gede (_gfagc .Data [_ccdgff ],0xff,_dcbce );
_ccdgff +=_gfagc .BytesPerLine ;};if _accda {for _gcab =0;_gcab < _bbbb ;_gcab ++{for _dafb =0;_dafb < _edgac ;_dafb ++{_gfagc .Data [_gadg +_dafb ]=0xff;};_gadg +=_gfagc .BytesPerLine ;};};if _bbdf {for _gcab =0;_gcab < _bbbb ;_gcab ++{_gfagc .Data [_gbfa ]=_gede (_gfagc .Data [_gbfa ],0xff,_acca );
_gbfa +=_gfagc .BytesPerLine ;};};case PixNotDst :for _gcab =0;_gcab < _bbbb ;_gcab ++{_gfagc .Data [_ccdgff ]=_gede (_gfagc .Data [_ccdgff ],^_gfagc .Data [_ccdgff ],_dcbce );_ccdgff +=_gfagc .BytesPerLine ;};if _accda {for _gcab =0;_gcab < _bbbb ;_gcab ++{for _dafb =0;
_dafb < _edgac ;_dafb ++{_gfagc .Data [_gadg +_dafb ]=^(_gfagc .Data [_gadg +_dafb ]);};_gadg +=_gfagc .BytesPerLine ;};};if _bbdf {for _gcab =0;_gcab < _bbbb ;_gcab ++{_gfagc .Data [_gbfa ]=_gede (_gfagc .Data [_gbfa ],^_gfagc .Data [_gbfa ],_acca );_gbfa +=_gfagc .BytesPerLine ;
};};};};func _dadf (_baef _c .Color )_c .Color {_ddge :=_c .GrayModel .Convert (_baef ).(_c .Gray );return _gga (_ddge );};func _cee (_bafg *Monochrome ,_becc ,_fgdfb int ,_cgca ,_gfff int ,_edbg RasterOperator ){var (_ababe int ;_fcef byte ;_acb ,_edag int ;
_cfbad int ;);_bddc :=_cgca >>3;_dfcb :=_cgca &7;if _dfcb > 0{_fcef =_edge [_dfcb ];};_ababe =_bafg .BytesPerLine *_fgdfb +(_becc >>3);switch _edbg {case PixClr :for _acb =0;_acb < _gfff ;_acb ++{_cfbad =_ababe +_acb *_bafg .BytesPerLine ;for _edag =0;
_edag < _bddc ;_edag ++{_bafg .Data [_cfbad ]=0x0;_cfbad ++;};if _dfcb > 0{_bafg .Data [_cfbad ]=_gede (_bafg .Data [_cfbad ],0x0,_fcef );};};case PixSet :for _acb =0;_acb < _gfff ;_acb ++{_cfbad =_ababe +_acb *_bafg .BytesPerLine ;for _edag =0;_edag < _bddc ;
_edag ++{_bafg .Data [_cfbad ]=0xff;_cfbad ++;};if _dfcb > 0{_bafg .Data [_cfbad ]=_gede (_bafg .Data [_cfbad ],0xff,_fcef );};};case PixNotDst :for _acb =0;_acb < _gfff ;_acb ++{_cfbad =_ababe +_acb *_bafg .BytesPerLine ;for _edag =0;_edag < _bddc ;_edag ++{_bafg .Data [_cfbad ]=^_bafg .Data [_cfbad ];
_cfbad ++;};if _dfcb > 0{_bafg .Data [_cfbad ]=_gede (_bafg .Data [_cfbad ],^_bafg .Data [_cfbad ],_fcef );};};};};func _ggee (_abb _c .RGBA )_c .NRGBA {switch _abb .A {case 0xff:return _c .NRGBA {R :_abb .R ,G :_abb .G ,B :_abb .B ,A :0xff};case 0x00:return _c .NRGBA {};
default:_deaaa ,_fbbf ,_dddf ,_edc :=_abb .RGBA ();_deaaa =(_deaaa *0xffff)/_edc ;_fbbf =(_fbbf *0xffff)/_edc ;_dddf =(_dddf *0xffff)/_edc ;return _c .NRGBA {R :uint8 (_deaaa >>8),G :uint8 (_fbbf >>8),B :uint8 (_dddf >>8),A :uint8 (_edc >>8)};};};func _dabf (){for _fgd :=0;
_fgd < 256;_fgd ++{_cafgc [_fgd ]=uint8 (_fgd &0x1)+(uint8 (_fgd >>1)&0x1)+(uint8 (_fgd >>2)&0x1)+(uint8 (_fgd >>3)&0x1)+(uint8 (_fgd >>4)&0x1)+(uint8 (_fgd >>5)&0x1)+(uint8 (_fgd >>6)&0x1)+(uint8 (_fgd >>7)&0x1);};};func (_agde *Monochrome )ColorModel ()_c .Model {return MonochromeModel (_agde .ModelThreshold )};
func _edcd (_gcabf RGBA ,_fecg NRGBA ,_cfga _cg .Rectangle ){for _affb :=0;_affb < _cfga .Max .X ;_affb ++{for _gagbe :=0;_gagbe < _cfga .Max .Y ;_gagbe ++{_dceb :=_gcabf .RGBAAt (_affb ,_gagbe );_fecg .SetNRGBA (_affb ,_gagbe ,_ggee (_dceb ));};};};func (_ecff *NRGBA16 )SetNRGBA (x ,y int ,c _c .NRGBA ){_cgdc :=y *_ecff .BytesPerLine +x *3/2;
if _cgdc +1>=len (_ecff .Data ){return ;};c =_eceb (c );_ecff .setNRGBA (x ,y ,_cgdc ,c );};func (_cbff *NRGBA16 )Copy ()Image {return &NRGBA16 {ImageBase :_cbff .copy ()}};func (_ffbg *Gray8 )Copy ()Image {return &Gray8 {ImageBase :_ffbg .copy ()}};func _bcbd (_fdeg *Monochrome ,_acad ,_bgcd ,_bgcb ,_gbad int ,_acacf RasterOperator ,_gdbffb *Monochrome ,_dcgc ,_abee int )error {var (_bcga bool ;
_cbad bool ;_fgee byte ;_bbaa int ;_dfge int ;_fbdf int ;_gbae int ;_bdade bool ;_ffee int ;_cdfg int ;_ccdd int ;_ead bool ;_gafe byte ;_ecf int ;_addg int ;_bfce int ;_bef byte ;_gbgb int ;_gfag int ;_bbae uint ;_dacae uint ;_bagf byte ;_eae shift ;_bdgd bool ;
_bdab bool ;_afbb ,_gfde int ;);if _dcgc &7!=0{_gfag =8-(_dcgc &7);};if _acad &7!=0{_dfge =8-(_acad &7);};if _gfag ==0&&_dfge ==0{_bagf =_afec [0];}else {if _dfge > _gfag {_bbae =uint (_dfge -_gfag );}else {_bbae =uint (8-(_gfag -_dfge ));};_dacae =8-_bbae ;
_bagf =_afec [_bbae ];};if (_acad &7)!=0{_bcga =true ;_bbaa =8-(_acad &7);_fgee =_afec [_bbaa ];_fbdf =_fdeg .BytesPerLine *_bgcd +(_acad >>3);_gbae =_gdbffb .BytesPerLine *_abee +(_dcgc >>3);_gbgb =8-(_dcgc &7);if _bbaa > _gbgb {_eae =_fcgc ;if _bgcb >=_gfag {_bdgd =true ;
};}else {_eae =_bbfa ;};};if _bgcb < _bbaa {_cbad =true ;_fgee &=_edge [8-_bbaa +_bgcb ];};if !_cbad {_ffee =(_bgcb -_bbaa )>>3;if _ffee !=0{_bdade =true ;_cdfg =_fdeg .BytesPerLine *_bgcd +((_acad +_dfge )>>3);_ccdd =_gdbffb .BytesPerLine *_abee +((_dcgc +_dfge )>>3);
};};_ecf =(_acad +_bgcb )&7;if !(_cbad ||_ecf ==0){_ead =true ;_gafe =_edge [_ecf ];_addg =_fdeg .BytesPerLine *_bgcd +((_acad +_dfge )>>3)+_ffee ;_bfce =_gdbffb .BytesPerLine *_abee +((_dcgc +_dfge )>>3)+_ffee ;if _ecf > int (_dacae ){_bdab =true ;};};
switch _acacf {case PixSrc :if _bcga {for _afbb =0;_afbb < _gbad ;_afbb ++{if _eae ==_fcgc {_bef =_gdbffb .Data [_gbae ]<<_bbae ;if _bdgd {_bef =_gede (_bef ,_gdbffb .Data [_gbae +1]>>_dacae ,_bagf );};}else {_bef =_gdbffb .Data [_gbae ]>>_dacae ;};_fdeg .Data [_fbdf ]=_gede (_fdeg .Data [_fbdf ],_bef ,_fgee );
_fbdf +=_fdeg .BytesPerLine ;_gbae +=_gdbffb .BytesPerLine ;};};if _bdade {for _afbb =0;_afbb < _gbad ;_afbb ++{for _gfde =0;_gfde < _ffee ;_gfde ++{_bef =_gede (_gdbffb .Data [_ccdd +_gfde ]<<_bbae ,_gdbffb .Data [_ccdd +_gfde +1]>>_dacae ,_bagf );_fdeg .Data [_cdfg +_gfde ]=_bef ;
};_cdfg +=_fdeg .BytesPerLine ;_ccdd +=_gdbffb .BytesPerLine ;};};if _ead {for _afbb =0;_afbb < _gbad ;_afbb ++{_bef =_gdbffb .Data [_bfce ]<<_bbae ;if _bdab {_bef =_gede (_bef ,_gdbffb .Data [_bfce +1]>>_dacae ,_bagf );};_fdeg .Data [_addg ]=_gede (_fdeg .Data [_addg ],_bef ,_gafe );
_addg +=_fdeg .BytesPerLine ;_bfce +=_gdbffb .BytesPerLine ;};};case PixNotSrc :if _bcga {for _afbb =0;_afbb < _gbad ;_afbb ++{if _eae ==_fcgc {_bef =_gdbffb .Data [_gbae ]<<_bbae ;if _bdgd {_bef =_gede (_bef ,_gdbffb .Data [_gbae +1]>>_dacae ,_bagf );
};}else {_bef =_gdbffb .Data [_gbae ]>>_dacae ;};_fdeg .Data [_fbdf ]=_gede (_fdeg .Data [_fbdf ],^_bef ,_fgee );_fbdf +=_fdeg .BytesPerLine ;_gbae +=_gdbffb .BytesPerLine ;};};if _bdade {for _afbb =0;_afbb < _gbad ;_afbb ++{for _gfde =0;_gfde < _ffee ;
_gfde ++{_bef =_gede (_gdbffb .Data [_ccdd +_gfde ]<<_bbae ,_gdbffb .Data [_ccdd +_gfde +1]>>_dacae ,_bagf );_fdeg .Data [_cdfg +_gfde ]=^_bef ;};_cdfg +=_fdeg .BytesPerLine ;_ccdd +=_gdbffb .BytesPerLine ;};};if _ead {for _afbb =0;_afbb < _gbad ;_afbb ++{_bef =_gdbffb .Data [_bfce ]<<_bbae ;
if _bdab {_bef =_gede (_bef ,_gdbffb .Data [_bfce +1]>>_dacae ,_bagf );};_fdeg .Data [_addg ]=_gede (_fdeg .Data [_addg ],^_bef ,_gafe );_addg +=_fdeg .BytesPerLine ;_bfce +=_gdbffb .BytesPerLine ;};};case PixSrcOrDst :if _bcga {for _afbb =0;_afbb < _gbad ;
_afbb ++{if _eae ==_fcgc {_bef =_gdbffb .Data [_gbae ]<<_bbae ;if _bdgd {_bef =_gede (_bef ,_gdbffb .Data [_gbae +1]>>_dacae ,_bagf );};}else {_bef =_gdbffb .Data [_gbae ]>>_dacae ;};_fdeg .Data [_fbdf ]=_gede (_fdeg .Data [_fbdf ],_bef |_fdeg .Data [_fbdf ],_fgee );
_fbdf +=_fdeg .BytesPerLine ;_gbae +=_gdbffb .BytesPerLine ;};};if _bdade {for _afbb =0;_afbb < _gbad ;_afbb ++{for _gfde =0;_gfde < _ffee ;_gfde ++{_bef =_gede (_gdbffb .Data [_ccdd +_gfde ]<<_bbae ,_gdbffb .Data [_ccdd +_gfde +1]>>_dacae ,_bagf );_fdeg .Data [_cdfg +_gfde ]|=_bef ;
};_cdfg +=_fdeg .BytesPerLine ;_ccdd +=_gdbffb .BytesPerLine ;};};if _ead {for _afbb =0;_afbb < _gbad ;_afbb ++{_bef =_gdbffb .Data [_bfce ]<<_bbae ;if _bdab {_bef =_gede (_bef ,_gdbffb .Data [_bfce +1]>>_dacae ,_bagf );};_fdeg .Data [_addg ]=_gede (_fdeg .Data [_addg ],_bef |_fdeg .Data [_addg ],_gafe );
_addg +=_fdeg .BytesPerLine ;_bfce +=_gdbffb .BytesPerLine ;};};case PixSrcAndDst :if _bcga {for _afbb =0;_afbb < _gbad ;_afbb ++{if _eae ==_fcgc {_bef =_gdbffb .Data [_gbae ]<<_bbae ;if _bdgd {_bef =_gede (_bef ,_gdbffb .Data [_gbae +1]>>_dacae ,_bagf );
};}else {_bef =_gdbffb .Data [_gbae ]>>_dacae ;};_fdeg .Data [_fbdf ]=_gede (_fdeg .Data [_fbdf ],_bef &_fdeg .Data [_fbdf ],_fgee );_fbdf +=_fdeg .BytesPerLine ;_gbae +=_gdbffb .BytesPerLine ;};};if _bdade {for _afbb =0;_afbb < _gbad ;_afbb ++{for _gfde =0;
_gfde < _ffee ;_gfde ++{_bef =_gede (_gdbffb .Data [_ccdd +_gfde ]<<_bbae ,_gdbffb .Data [_ccdd +_gfde +1]>>_dacae ,_bagf );_fdeg .Data [_cdfg +_gfde ]&=_bef ;};_cdfg +=_fdeg .BytesPerLine ;_ccdd +=_gdbffb .BytesPerLine ;};};if _ead {for _afbb =0;_afbb < _gbad ;
_afbb ++{_bef =_gdbffb .Data [_bfce ]<<_bbae ;if _bdab {_bef =_gede (_bef ,_gdbffb .Data [_bfce +1]>>_dacae ,_bagf );};_fdeg .Data [_addg ]=_gede (_fdeg .Data [_addg ],_bef &_fdeg .Data [_addg ],_gafe );_addg +=_fdeg .BytesPerLine ;_bfce +=_gdbffb .BytesPerLine ;
};};case PixSrcXorDst :if _bcga {for _afbb =0;_afbb < _gbad ;_afbb ++{if _eae ==_fcgc {_bef =_gdbffb .Data [_gbae ]<<_bbae ;if _bdgd {_bef =_gede (_bef ,_gdbffb .Data [_gbae +1]>>_dacae ,_bagf );};}else {_bef =_gdbffb .Data [_gbae ]>>_dacae ;};_fdeg .Data [_fbdf ]=_gede (_fdeg .Data [_fbdf ],_bef ^_fdeg .Data [_fbdf ],_fgee );
_fbdf +=_fdeg .BytesPerLine ;_gbae +=_gdbffb .BytesPerLine ;};};if _bdade {for _afbb =0;_afbb < _gbad ;_afbb ++{for _gfde =0;_gfde < _ffee ;_gfde ++{_bef =_gede (_gdbffb .Data [_ccdd +_gfde ]<<_bbae ,_gdbffb .Data [_ccdd +_gfde +1]>>_dacae ,_bagf );_fdeg .Data [_cdfg +_gfde ]^=_bef ;
};_cdfg +=_fdeg .BytesPerLine ;_ccdd +=_gdbffb .BytesPerLine ;};};if _ead {for _afbb =0;_afbb < _gbad ;_afbb ++{_bef =_gdbffb .Data [_bfce ]<<_bbae ;if _bdab {_bef =_gede (_bef ,_gdbffb .Data [_bfce +1]>>_dacae ,_bagf );};_fdeg .Data [_addg ]=_gede (_fdeg .Data [_addg ],_bef ^_fdeg .Data [_addg ],_gafe );
_addg +=_fdeg .BytesPerLine ;_bfce +=_gdbffb .BytesPerLine ;};};case PixNotSrcOrDst :if _bcga {for _afbb =0;_afbb < _gbad ;_afbb ++{if _eae ==_fcgc {_bef =_gdbffb .Data [_gbae ]<<_bbae ;if _bdgd {_bef =_gede (_bef ,_gdbffb .Data [_gbae +1]>>_dacae ,_bagf );
};}else {_bef =_gdbffb .Data [_gbae ]>>_dacae ;};_fdeg .Data [_fbdf ]=_gede (_fdeg .Data [_fbdf ],^_bef |_fdeg .Data [_fbdf ],_fgee );_fbdf +=_fdeg .BytesPerLine ;_gbae +=_gdbffb .BytesPerLine ;};};if _bdade {for _afbb =0;_afbb < _gbad ;_afbb ++{for _gfde =0;
_gfde < _ffee ;_gfde ++{_bef =_gede (_gdbffb .Data [_ccdd +_gfde ]<<_bbae ,_gdbffb .Data [_ccdd +_gfde +1]>>_dacae ,_bagf );_fdeg .Data [_cdfg +_gfde ]|=^_bef ;};_cdfg +=_fdeg .BytesPerLine ;_ccdd +=_gdbffb .BytesPerLine ;};};if _ead {for _afbb =0;_afbb < _gbad ;
_afbb ++{_bef =_gdbffb .Data [_bfce ]<<_bbae ;if _bdab {_bef =_gede (_bef ,_gdbffb .Data [_bfce +1]>>_dacae ,_bagf );};_fdeg .Data [_addg ]=_gede (_fdeg .Data [_addg ],^_bef |_fdeg .Data [_addg ],_gafe );_addg +=_fdeg .BytesPerLine ;_bfce +=_gdbffb .BytesPerLine ;
};};case PixNotSrcAndDst :if _bcga {for _afbb =0;_afbb < _gbad ;_afbb ++{if _eae ==_fcgc {_bef =_gdbffb .Data [_gbae ]<<_bbae ;if _bdgd {_bef =_gede (_bef ,_gdbffb .Data [_gbae +1]>>_dacae ,_bagf );};}else {_bef =_gdbffb .Data [_gbae ]>>_dacae ;};_fdeg .Data [_fbdf ]=_gede (_fdeg .Data [_fbdf ],^_bef &_fdeg .Data [_fbdf ],_fgee );
_fbdf +=_fdeg .BytesPerLine ;_gbae +=_gdbffb .BytesPerLine ;};};if _bdade {for _afbb =0;_afbb < _gbad ;_afbb ++{for _gfde =0;_gfde < _ffee ;_gfde ++{_bef =_gede (_gdbffb .Data [_ccdd +_gfde ]<<_bbae ,_gdbffb .Data [_ccdd +_gfde +1]>>_dacae ,_bagf );_fdeg .Data [_cdfg +_gfde ]&=^_bef ;
};_cdfg +=_fdeg .BytesPerLine ;_ccdd +=_gdbffb .BytesPerLine ;};};if _ead {for _afbb =0;_afbb < _gbad ;_afbb ++{_bef =_gdbffb .Data [_bfce ]<<_bbae ;if _bdab {_bef =_gede (_bef ,_gdbffb .Data [_bfce +1]>>_dacae ,_bagf );};_fdeg .Data [_addg ]=_gede (_fdeg .Data [_addg ],^_bef &_fdeg .Data [_addg ],_gafe );
_addg +=_fdeg .BytesPerLine ;_bfce +=_gdbffb .BytesPerLine ;};};case PixSrcOrNotDst :if _bcga {for _afbb =0;_afbb < _gbad ;_afbb ++{if _eae ==_fcgc {_bef =_gdbffb .Data [_gbae ]<<_bbae ;if _bdgd {_bef =_gede (_bef ,_gdbffb .Data [_gbae +1]>>_dacae ,_bagf );
};}else {_bef =_gdbffb .Data [_gbae ]>>_dacae ;};_fdeg .Data [_fbdf ]=_gede (_fdeg .Data [_fbdf ],_bef |^_fdeg .Data [_fbdf ],_fgee );_fbdf +=_fdeg .BytesPerLine ;_gbae +=_gdbffb .BytesPerLine ;};};if _bdade {for _afbb =0;_afbb < _gbad ;_afbb ++{for _gfde =0;
_gfde < _ffee ;_gfde ++{_bef =_gede (_gdbffb .Data [_ccdd +_gfde ]<<_bbae ,_gdbffb .Data [_ccdd +_gfde +1]>>_dacae ,_bagf );_fdeg .Data [_cdfg +_gfde ]=_bef |^_fdeg .Data [_cdfg +_gfde ];};_cdfg +=_fdeg .BytesPerLine ;_ccdd +=_gdbffb .BytesPerLine ;};};
if _ead {for _afbb =0;_afbb < _gbad ;_afbb ++{_bef =_gdbffb .Data [_bfce ]<<_bbae ;if _bdab {_bef =_gede (_bef ,_gdbffb .Data [_bfce +1]>>_dacae ,_bagf );};_fdeg .Data [_addg ]=_gede (_fdeg .Data [_addg ],_bef |^_fdeg .Data [_addg ],_gafe );_addg +=_fdeg .BytesPerLine ;
_bfce +=_gdbffb .BytesPerLine ;};};case PixSrcAndNotDst :if _bcga {for _afbb =0;_afbb < _gbad ;_afbb ++{if _eae ==_fcgc {_bef =_gdbffb .Data [_gbae ]<<_bbae ;if _bdgd {_bef =_gede (_bef ,_gdbffb .Data [_gbae +1]>>_dacae ,_bagf );};}else {_bef =_gdbffb .Data [_gbae ]>>_dacae ;
};_fdeg .Data [_fbdf ]=_gede (_fdeg .Data [_fbdf ],_bef &^_fdeg .Data [_fbdf ],_fgee );_fbdf +=_fdeg .BytesPerLine ;_gbae +=_gdbffb .BytesPerLine ;};};if _bdade {for _afbb =0;_afbb < _gbad ;_afbb ++{for _gfde =0;_gfde < _ffee ;_gfde ++{_bef =_gede (_gdbffb .Data [_ccdd +_gfde ]<<_bbae ,_gdbffb .Data [_ccdd +_gfde +1]>>_dacae ,_bagf );
_fdeg .Data [_cdfg +_gfde ]=_bef &^_fdeg .Data [_cdfg +_gfde ];};_cdfg +=_fdeg .BytesPerLine ;_ccdd +=_gdbffb .BytesPerLine ;};};if _ead {for _afbb =0;_afbb < _gbad ;_afbb ++{_bef =_gdbffb .Data [_bfce ]<<_bbae ;if _bdab {_bef =_gede (_bef ,_gdbffb .Data [_bfce +1]>>_dacae ,_bagf );
};_fdeg .Data [_addg ]=_gede (_fdeg .Data [_addg ],_bef &^_fdeg .Data [_addg ],_gafe );_addg +=_fdeg .BytesPerLine ;_bfce +=_gdbffb .BytesPerLine ;};};case PixNotPixSrcOrDst :if _bcga {for _afbb =0;_afbb < _gbad ;_afbb ++{if _eae ==_fcgc {_bef =_gdbffb .Data [_gbae ]<<_bbae ;
if _bdgd {_bef =_gede (_bef ,_gdbffb .Data [_gbae +1]>>_dacae ,_bagf );};}else {_bef =_gdbffb .Data [_gbae ]>>_dacae ;};_fdeg .Data [_fbdf ]=_gede (_fdeg .Data [_fbdf ],^(_bef |_fdeg .Data [_fbdf ]),_fgee );_fbdf +=_fdeg .BytesPerLine ;_gbae +=_gdbffb .BytesPerLine ;
};};if _bdade {for _afbb =0;_afbb < _gbad ;_afbb ++{for _gfde =0;_gfde < _ffee ;_gfde ++{_bef =_gede (_gdbffb .Data [_ccdd +_gfde ]<<_bbae ,_gdbffb .Data [_ccdd +_gfde +1]>>_dacae ,_bagf );_fdeg .Data [_cdfg +_gfde ]=^(_bef |_fdeg .Data [_cdfg +_gfde ]);
};_cdfg +=_fdeg .BytesPerLine ;_ccdd +=_gdbffb .BytesPerLine ;};};if _ead {for _afbb =0;_afbb < _gbad ;_afbb ++{_bef =_gdbffb .Data [_bfce ]<<_bbae ;if _bdab {_bef =_gede (_bef ,_gdbffb .Data [_bfce +1]>>_dacae ,_bagf );};_fdeg .Data [_addg ]=_gede (_fdeg .Data [_addg ],^(_bef |_fdeg .Data [_addg ]),_gafe );
_addg +=_fdeg .BytesPerLine ;_bfce +=_gdbffb .BytesPerLine ;};};case PixNotPixSrcAndDst :if _bcga {for _afbb =0;_afbb < _gbad ;_afbb ++{if _eae ==_fcgc {_bef =_gdbffb .Data [_gbae ]<<_bbae ;if _bdgd {_bef =_gede (_bef ,_gdbffb .Data [_gbae +1]>>_dacae ,_bagf );
};}else {_bef =_gdbffb .Data [_gbae ]>>_dacae ;};_fdeg .Data [_fbdf ]=_gede (_fdeg .Data [_fbdf ],^(_bef &_fdeg .Data [_fbdf ]),_fgee );_fbdf +=_fdeg .BytesPerLine ;_gbae +=_gdbffb .BytesPerLine ;};};if _bdade {for _afbb =0;_afbb < _gbad ;_afbb ++{for _gfde =0;
_gfde < _ffee ;_gfde ++{_bef =_gede (_gdbffb .Data [_ccdd +_gfde ]<<_bbae ,_gdbffb .Data [_ccdd +_gfde +1]>>_dacae ,_bagf );_fdeg .Data [_cdfg +_gfde ]=^(_bef &_fdeg .Data [_cdfg +_gfde ]);};_cdfg +=_fdeg .BytesPerLine ;_ccdd +=_gdbffb .BytesPerLine ;};
};if _ead {for _afbb =0;_afbb < _gbad ;_afbb ++{_bef =_gdbffb .Data [_bfce ]<<_bbae ;if _bdab {_bef =_gede (_bef ,_gdbffb .Data [_bfce +1]>>_dacae ,_bagf );};_fdeg .Data [_addg ]=_gede (_fdeg .Data [_addg ],^(_bef &_fdeg .Data [_addg ]),_gafe );_addg +=_fdeg .BytesPerLine ;
_bfce +=_gdbffb .BytesPerLine ;};};case PixNotPixSrcXorDst :if _bcga {for _afbb =0;_afbb < _gbad ;_afbb ++{if _eae ==_fcgc {_bef =_gdbffb .Data [_gbae ]<<_bbae ;if _bdgd {_bef =_gede (_bef ,_gdbffb .Data [_gbae +1]>>_dacae ,_bagf );};}else {_bef =_gdbffb .Data [_gbae ]>>_dacae ;
};_fdeg .Data [_fbdf ]=_gede (_fdeg .Data [_fbdf ],^(_bef ^_fdeg .Data [_fbdf ]),_fgee );_fbdf +=_fdeg .BytesPerLine ;_gbae +=_gdbffb .BytesPerLine ;};};if _bdade {for _afbb =0;_afbb < _gbad ;_afbb ++{for _gfde =0;_gfde < _ffee ;_gfde ++{_bef =_gede (_gdbffb .Data [_ccdd +_gfde ]<<_bbae ,_gdbffb .Data [_ccdd +_gfde +1]>>_dacae ,_bagf );
_fdeg .Data [_cdfg +_gfde ]=^(_bef ^_fdeg .Data [_cdfg +_gfde ]);};_cdfg +=_fdeg .BytesPerLine ;_ccdd +=_gdbffb .BytesPerLine ;};};if _ead {for _afbb =0;_afbb < _gbad ;_afbb ++{_bef =_gdbffb .Data [_bfce ]<<_bbae ;if _bdab {_bef =_gede (_bef ,_gdbffb .Data [_bfce +1]>>_dacae ,_bagf );
};_fdeg .Data [_addg ]=_gede (_fdeg .Data [_addg ],^(_bef ^_fdeg .Data [_addg ]),_gafe );_addg +=_fdeg .BytesPerLine ;_bfce +=_gdbffb .BytesPerLine ;};};default:_ee .Log .Debug ("\u004f\u0070e\u0072\u0061\u0074\u0069\u006f\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006e\u006f\u0074\u0020\u0070\u0065\u0072\u006d\u0069tt\u0065\u0064",_acacf );
return _f .New ("\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065r\u0061\u0074\u0069\u006f\u006e\u0020\u006eo\u0074\u0020\u0070\u0065\u0072\u006d\u0069\u0074\u0074\u0065\u0064");};return nil ;};type Gray16 struct{ImageBase };func (_bfdb *Gray16 )SetGray (x ,y int ,g _c .Gray ){_gcdb :=(y *_bfdb .BytesPerLine /2+x )*2;
if _gcdb +1>=len (_bfdb .Data ){return ;};_bfdb .Data [_gcdb ]=g .Y ;_bfdb .Data [_gcdb +1]=g .Y ;};type Gray8 struct{ImageBase };func (_ddgbb *NRGBA16 )Validate ()error {if len (_ddgbb .Data )!=3*_ddgbb .Width *_ddgbb .Height /2{return _f .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func _ege (_ggdc ,_ggfd *Monochrome ,_bbdd []byte ,_efd int )(_dga error ){var (_ded ,_decd ,_fafb ,_edfd ,_aead ,_aeg ,_fga ,_decg int ;_gbe ,_ffeg uint32 ;_gba ,_gaa byte ;_egf uint16 ;);_gef :=make ([]byte ,4);_cafg :=make ([]byte ,4);
for _fafb =0;_fafb < _ggdc .Height -1;_fafb ,_edfd =_fafb +2,_edfd +1{_ded =_fafb *_ggdc .BytesPerLine ;_decd =_edfd *_ggfd .BytesPerLine ;for _aead ,_aeg =0,0;_aead < _efd ;_aead ,_aeg =_aead +4,_aeg +1{for _fga =0;_fga < 4;_fga ++{_decg =_ded +_aead +_fga ;
if _decg <=len (_ggdc .Data )-1&&_decg < _ded +_ggdc .BytesPerLine {_gef [_fga ]=_ggdc .Data [_decg ];}else {_gef [_fga ]=0x00;};_decg =_ded +_ggdc .BytesPerLine +_aead +_fga ;if _decg <=len (_ggdc .Data )-1&&_decg < _ded +(2*_ggdc .BytesPerLine ){_cafg [_fga ]=_ggdc .Data [_decg ];
}else {_cafg [_fga ]=0x00;};};_gbe =_a .BigEndian .Uint32 (_gef );_ffeg =_a .BigEndian .Uint32 (_cafg );_ffeg &=_gbe ;_ffeg &=_ffeg <<1;_ffeg &=0xaaaaaaaa;_gbe =_ffeg |(_ffeg <<7);_gba =byte (_gbe >>24);_gaa =byte ((_gbe >>8)&0xff);_decg =_decd +_aeg ;
if _decg +1==len (_ggfd .Data )-1||_decg +1>=_decd +_ggfd .BytesPerLine {_ggfd .Data [_decg ]=_bbdd [_gba ];if _dga =_ggfd .setByte (_decg ,_bbdd [_gba ]);_dga !=nil {return _b .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_decg );};}else {_egf =(uint16 (_bbdd [_gba ])<<8)|uint16 (_bbdd [_gaa ]);
if _dga =_ggfd .setTwoBytes (_decg ,_egf );_dga !=nil {return _b .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_decg );
};_aeg ++;};};};return nil ;};func ColorAtGray16BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_c .Gray16 ,error ){_cae :=(y *bytesPerLine /2+x )*2;if _cae +1>=len (data ){return _c .Gray16 {},_b .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_cecc :=uint16 (data [_cae ])<<8|uint16 (data [_cae +1]);if len (decode )==2{_cecc =uint16 (uint64 (LinearInterpolate (float64 (_cecc ),0,65535,decode [0],decode [1])));};return _c .Gray16 {Y :_cecc },nil ;};var ErrInvalidImage =_f .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
func ColorAtNRGBA64 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_c .NRGBA64 ,error ){_ddfd :=(y *width +x )*2;_dcff :=_ddfd *3;if _dcff +5>=len (data ){return _c .NRGBA64 {},_b .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};const _cbce =0xffff;_geg :=uint16 (_cbce );if alpha !=nil &&len (alpha )> _ddfd +1{_geg =uint16 (alpha [_ddfd ])<<8|uint16 (alpha [_ddfd +1]);};_cbaa :=uint16 (data [_dcff ])<<8|uint16 (data [_dcff +1]);_edgg :=uint16 (data [_dcff +2])<<8|uint16 (data [_dcff +3]);
_eddg :=uint16 (data [_dcff +4])<<8|uint16 (data [_dcff +5]);if len (decode )==6{_cbaa =uint16 (uint64 (LinearInterpolate (float64 (_cbaa ),0,65535,decode [0],decode [1]))&_cbce );_edgg =uint16 (uint64 (LinearInterpolate (float64 (_edgg ),0,65535,decode [2],decode [3]))&_cbce );
_eddg =uint16 (uint64 (LinearInterpolate (float64 (_eddg ),0,65535,decode [4],decode [5]))&_cbce );};return _c .NRGBA64 {R :_cbaa ,G :_edgg ,B :_eddg ,A :_geg },nil ;};func _cafac (_cdeg *Monochrome ,_efeg ,_ddbff ,_bfac ,_gdbff int ,_dged RasterOperator ,_gce *Monochrome ,_fgbfc ,_agdee int )error {if _cdeg ==nil {return _f .New ("\u006e\u0069\u006c\u0020\u0027\u0064\u0065\u0073\u0074\u0027\u0020\u0042i\u0074\u006d\u0061\u0070");
};if _dged ==PixDst {return nil ;};switch _dged {case PixClr ,PixSet ,PixNotDst :_gbb (_cdeg ,_efeg ,_ddbff ,_bfac ,_gdbff ,_dged );return nil ;};if _gce ==nil {_ee .Log .Debug ("\u0052a\u0073\u0074e\u0072\u004f\u0070\u0065r\u0061\u0074\u0069o\u006e\u0020\u0073\u006f\u0075\u0072\u0063\u0065\u0020bi\u0074\u006d\u0061p\u0020\u0069s\u0020\u006e\u006f\u0074\u0020\u0064e\u0066\u0069n\u0065\u0064");
return _f .New ("\u006e\u0069l\u0020\u0027\u0073r\u0063\u0027\u0020\u0062\u0069\u0074\u006d\u0061\u0070");};if _caba :=_eeed (_cdeg ,_efeg ,_ddbff ,_bfac ,_gdbff ,_dged ,_gce ,_fgbfc ,_agdee );_caba !=nil {return _caba ;};return nil ;};func _daeg (_aaee CMYK ,_cggfd NRGBA ,_fdga _cg .Rectangle ){for _fgaf :=0;
_fgaf < _fdga .Max .X ;_fgaf ++{for _fadde :=0;_fadde < _fdga .Max .Y ;_fadde ++{_bgbcb :=_aaee .CMYKAt (_fgaf ,_fadde );_cggfd .SetNRGBA (_fgaf ,_fadde ,_edd (_bgbcb ));};};};func (_acbed *NRGBA32 )Set (x ,y int ,c _c .Color ){_bafb :=y *_acbed .Width +x ;
_bgbbc :=3*_bafb ;if _bgbbc +2>=len (_acbed .Data ){return ;};_bcadd :=_c .NRGBAModel .Convert (c ).(_c .NRGBA );_acbed .setRGBA (_bafb ,_bcadd );};type CMYK interface{CMYKAt (_gcb ,_dgbb int )_c .CMYK ;SetCMYK (_bafcd ,_ffa int ,_fc _c .CMYK );};func (_agabe *NRGBA32 )Validate ()error {if len (_agabe .Data )!=3*_agabe .Width *_agabe .Height {return _f .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};var _ Image =&Gray16 {};func (_ccc *NRGBA32 )setRGBA (_fgef int ,_aac _c .NRGBA ){_dgae :=3*_fgef ;_ccc .Data [_dgae ]=_aac .R ;_ccc .Data [_dgae +1]=_aac .G ;_ccc .Data [_dgae +2]=_aac .B ;if _fgef < len (_ccc .Alpha ){_ccc .Alpha [_fgef ]=_aac .A ;
};};func (_cddd *ImageBase )setEightBytes (_ggda int ,_gcbac uint64 )error {_dbgc :=_cddd .BytesPerLine -(_ggda %_cddd .BytesPerLine );if _cddd .BytesPerLine !=_cddd .Width >>3{_dbgc --;};if _dbgc >=8{return _cddd .setEightFullBytes (_ggda ,_gcbac );};
return _cddd .setEightPartlyBytes (_ggda ,_dbgc ,_gcbac );};func _edd (_ebffb _c .CMYK )_c .NRGBA {_cefb ,_fcbf ,_abae :=_c .CMYKToRGB (_ebffb .C ,_ebffb .M ,_ebffb .Y ,_ebffb .K );return _c .NRGBA {R :_cefb ,G :_fcbf ,B :_abae ,A :0xff};};func (_bggf *Monochrome )ScaleLow (width ,height int )(*Monochrome ,error ){if width < 0||height < 0{return nil ,_f .New ("\u0070\u0072\u006f\u0076\u0069\u0064e\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0069\u0064t\u0068\u0020\u0061\u006e\u0064\u0020\u0068e\u0069\u0067\u0068\u0074");
};_fgbb :=_fba (width ,height );_aeadc :=make ([]int ,height );_bggd :=make ([]int ,width );_cfffc :=float64 (_bggf .Width )/float64 (width );_gedb :=float64 (_bggf .Height )/float64 (height );for _afa :=0;_afa < height ;_afa ++{_aeadc [_afa ]=int (_g .Min (_gedb *float64 (_afa )+0.5,float64 (_bggf .Height -1)));
};for _bcfa :=0;_bcfa < width ;_bcfa ++{_bggd [_bcfa ]=int (_g .Min (_cfffc *float64 (_bcfa )+0.5,float64 (_bggf .Width -1)));};_dbe :=-1;_eccg :=byte (0);for _cdgg :=0;_cdgg < height ;_cdgg ++{_eeb :=_aeadc [_cdgg ]*_bggf .BytesPerLine ;_fdda :=_cdgg *_fgbb .BytesPerLine ;
for _dcfe :=0;_dcfe < width ;_dcfe ++{_cec :=_bggd [_dcfe ];if _cec !=_dbe {_eccg =_bggf .getBit (_eeb ,_cec );if _eccg !=0{_fgbb .setBit (_fdda ,_dcfe );};_dbe =_cec ;}else {if _eccg !=0{_fgbb .setBit (_fdda ,_dcfe );};};};};return _fgbb ,nil ;};var _ _cg .Image =&Gray16 {};
func _eff (_fdd RGBA ,_dfb CMYK ,_feb _cg .Rectangle ){for _efcg :=0;_efcg < _feb .Max .X ;_efcg ++{for _acac :=0;_acac < _feb .Max .Y ;_acac ++{_dcee :=_fdd .RGBAAt (_efcg ,_acac );_dfb .SetCMYK (_efcg ,_acac ,_dgfc (_dcee ));};};};func ColorAt (x ,y ,width ,bitsPerColor ,colorComponents ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_c .Color ,error ){switch colorComponents {case 1:return ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine ,data ,decode );
case 3:return ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor ,data ,alpha ,decode );case 4:return ColorAtCMYK (x ,y ,width ,data ,decode );default:return nil ,_b .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0063o\u006c\u006f\u0072\u0020\u0063\u006f\u006dp\u006f\u006e\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0064",colorComponents );
};};func (_cgbgf *ImageBase )setFourBytes (_afge int ,_fcae uint32 )error {if _afge +3> len (_cgbgf .Data )-1{return _b .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006fu\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065",_afge );
};_cgbgf .Data [_afge ]=byte ((_fcae &0xff000000)>>24);_cgbgf .Data [_afge +1]=byte ((_fcae &0xff0000)>>16);_cgbgf .Data [_afge +2]=byte ((_fcae &0xff00)>>8);_cgbgf .Data [_afge +3]=byte (_fcae &0xff);return nil ;};func _agea (_dfga _cg .Image )(Image ,error ){if _gacfc ,_afc :=_dfga .(*NRGBA32 );
_afc {return _gacfc .Copy (),nil ;};_ceccf ,_dbeed ,_baee :=_gagb (_dfga ,1);_ffc ,_bdeg :=NewImage (_ceccf .Max .X ,_ceccf .Max .Y ,8,3,nil ,_baee ,nil );if _bdeg !=nil {return nil ,_bdeg ;};_ccdb (_dfga ,_ffc ,_ceccf );if len (_baee )!=0&&!_dbeed {if _gebbg :=_dcbe (_baee ,_ffc );
_gebbg !=nil {return nil ,_gebbg ;};};return _ffc ,nil ;};func (_dde *Gray8 )At (x ,y int )_c .Color {_fdbc ,_ :=_dde .ColorAt (x ,y );return _fdbc };func FromGoImage (i _cg .Image )(Image ,error ){switch _geeb :=i .(type ){case Image :return _geeb .Copy (),nil ;
case Gray :return GrayConverter .Convert (i );case *_cg .Gray16 :return Gray16Converter .Convert (i );case CMYK :return CMYKConverter .Convert (i );case *_cg .NRGBA64 :return NRGBA64Converter .Convert (i );default:return NRGBAConverter .Convert (i );};
};func (_bada *NRGBA32 )Bounds ()_cg .Rectangle {return _cg .Rectangle {Max :_cg .Point {X :_bada .Width ,Y :_bada .Height }};};func _gdec (_bgbb _cg .Image )(Image ,error ){if _dgg ,_fbge :=_bgbb .(*Gray16 );_fbge {return _dgg .Copy (),nil ;};_eccga :=_bgbb .Bounds ();
_ccge ,_bfaf :=NewImage (_eccga .Max .X ,_eccga .Max .Y ,16,1,nil ,nil ,nil );if _bfaf !=nil {return nil ,_bfaf ;};_geaa (_bgbb ,_ccge ,_eccga );return _ccge ,nil ;};func _deaa (_efc ,_ecd *Monochrome ,_gaec []byte ,_gfb int )(_eaf error ){var (_acd ,_ffe ,_efe ,_caf ,_ccf ,_bfe ,_eeg ,_dfc int ;
_dcgg ,_dcec uint32 ;_eed ,_acc byte ;_dba uint16 ;);_ffb :=make ([]byte ,4);_gddb :=make ([]byte ,4);for _efe =0;_efe < _efc .Height -1;_efe ,_caf =_efe +2,_caf +1{_acd =_efe *_efc .BytesPerLine ;_ffe =_caf *_ecd .BytesPerLine ;for _ccf ,_bfe =0,0;_ccf < _gfb ;
_ccf ,_bfe =_ccf +4,_bfe +1{for _eeg =0;_eeg < 4;_eeg ++{_dfc =_acd +_ccf +_eeg ;if _dfc <=len (_efc .Data )-1&&_dfc < _acd +_efc .BytesPerLine {_ffb [_eeg ]=_efc .Data [_dfc ];}else {_ffb [_eeg ]=0x00;};_dfc =_acd +_efc .BytesPerLine +_ccf +_eeg ;if _dfc <=len (_efc .Data )-1&&_dfc < _acd +(2*_efc .BytesPerLine ){_gddb [_eeg ]=_efc .Data [_dfc ];
}else {_gddb [_eeg ]=0x00;};};_dcgg =_a .BigEndian .Uint32 (_ffb );_dcec =_a .BigEndian .Uint32 (_gddb );_dcec |=_dcgg ;_dcec |=_dcec <<1;_dcec &=0xaaaaaaaa;_dcgg =_dcec |(_dcec <<7);_eed =byte (_dcgg >>24);_acc =byte ((_dcgg >>8)&0xff);_dfc =_ffe +_bfe ;
if _dfc +1==len (_ecd .Data )-1||_dfc +1>=_ffe +_ecd .BytesPerLine {_ecd .Data [_dfc ]=_gaec [_eed ];}else {_dba =(uint16 (_gaec [_eed ])<<8)|uint16 (_gaec [_acc ]);if _eaf =_ecd .setTwoBytes (_dfc ,_dba );_eaf !=nil {return _b .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_dfc );
};_bfe ++;};};};return nil ;};func (_dggg *NRGBA64 )Bounds ()_cg .Rectangle {return _cg .Rectangle {Max :_cg .Point {X :_dggg .Width ,Y :_dggg .Height }};};func AutoThresholdTriangle (histogram [256]int )uint8 {var _cebd ,_fgeed ,_dfgg ,_cbfg int ;for _aeddb :=0;
_aeddb < len (histogram );_aeddb ++{if histogram [_aeddb ]> 0{_cebd =_aeddb ;break ;};};if _cebd > 0{_cebd --;};for _cfab :=255;_cfab > 0;_cfab --{if histogram [_cfab ]> 0{_cbfg =_cfab ;break ;};};if _cbfg < 255{_cbfg ++;};for _afgcg :=0;_afgcg < 256;_afgcg ++{if histogram [_afgcg ]> _fgeed {_dfgg =_afgcg ;
_fgeed =histogram [_afgcg ];};};var _ecaf bool ;if (_dfgg -_cebd )< (_cbfg -_dfgg ){_ecaf =true ;var _egdf int ;_fee :=255;for _egdf < _fee {_aaaf :=histogram [_egdf ];histogram [_egdf ]=histogram [_fee ];histogram [_fee ]=_aaaf ;_egdf ++;_fee --;};_cebd =255-_cbfg ;
_dfgg =255-_dfgg ;};if _cebd ==_dfgg {return uint8 (_cebd );};_bfecc :=float64 (histogram [_dfgg ]);_decb :=float64 (_cebd -_dfgg );_dbce :=_g .Sqrt (_bfecc *_bfecc +_decb *_decb );_bfecc /=_dbce ;_decb /=_dbce ;_dbce =_bfecc *float64 (_cebd )+_decb *float64 (histogram [_cebd ]);
_cdgbb :=_cebd ;var _dda float64 ;for _aeab :=_cebd +1;_aeab <=_dfgg ;_aeab ++{_ebbf :=_bfecc *float64 (_aeab )+_decb *float64 (histogram [_aeab ])-_dbce ;if _ebbf > _dda {_cdgbb =_aeab ;_dda =_ebbf ;};};_cdgbb --;if _ecaf {var _eafge int ;_aceg :=255;
for _eafge < _aceg {_gdaa :=histogram [_eafge ];histogram [_eafge ]=histogram [_aceg ];histogram [_aceg ]=_gdaa ;_eafge ++;_aceg --;};return uint8 (255-_cdgbb );};return uint8 (_cdgbb );};func (_cafgb *Monochrome )getBit (_fce ,_dbcc int )uint8 {return _cafgb .Data [_fce +(_dbcc >>3)]>>uint (7-(_dbcc &7))&1;
};func _cagf (_fdeb *_cg .Gray16 ,_fcecb uint8 )*_cg .Gray {_ffdg :=_fdeb .Bounds ();_abfd :=_cg .NewGray (_ffdg );for _degga :=0;_degga < _ffdg .Dx ();_degga ++{for _dfaac :=0;_dfaac < _ffdg .Dy ();_dfaac ++{_cgbf :=_fdeb .Gray16At (_degga ,_dfaac );_abfd .SetGray (_degga ,_dfaac ,_c .Gray {Y :_efcgc (uint8 (_cgbf .Y /256),_fcecb )});
};};return _abfd ;};func (_fbee *Gray2 )Histogram ()(_bcfd [256]int ){for _fgfd :=0;_fgfd < _fbee .Width ;_fgfd ++{for _faa :=0;_faa < _fbee .Height ;_faa ++{_bcfd [_fbee .GrayAt (_fgfd ,_faa ).Y ]++;};};return _bcfd ;};func _egge (_gaeb CMYK ,_bdfc Gray ,_daea _cg .Rectangle ){for _bdgcc :=0;
_bdgcc < _daea .Max .X ;_bdgcc ++{for _dbbb :=0;_dbbb < _daea .Max .Y ;_dbbb ++{_dcdg :=_fag (_gaeb .CMYKAt (_bdgcc ,_dbbb ));_bdfc .SetGray (_bdgcc ,_dbbb ,_dcdg );};};};func (_bbfd *monochromeThresholdConverter )Convert (img _cg .Image )(Image ,error ){if _abdda ,_cdc :=img .(*Monochrome );
_cdc {return _abdda .Copy (),nil ;};_dbc :=img .Bounds ();_gcc ,_dfba :=NewImage (_dbc .Max .X ,_dbc .Max .Y ,1,1,nil ,nil ,nil );if _dfba !=nil {return nil ,_dfba ;};_gcc .(*Monochrome ).ModelThreshold =_bbfd .Threshold ;for _gcd :=0;_gcd < _dbc .Max .X ;
_gcd ++{for _ecg :=0;_ecg < _dbc .Max .Y ;_ecg ++{_edff :=img .At (_gcd ,_ecg );_gcc .Set (_gcd ,_ecg ,_edff );};};return _gcc ,nil ;};func _aedd (_ffgd _cg .Image )(Image ,error ){if _cgde ,_bdfa :=_ffgd .(*NRGBA16 );_bdfa {return _cgde .Copy (),nil ;
};_edfff :=_ffgd .Bounds ();_ccfde ,_ebeg :=NewImage (_edfff .Max .X ,_edfff .Max .Y ,4,3,nil ,nil ,nil );if _ebeg !=nil {return nil ,_ebeg ;};_ccdb (_ffgd ,_ccfde ,_edfff );return _ccfde ,nil ;};func _ffega (_bbgg int ,_bea int )error {return _b .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",_bbgg ,_bea );
};func (_eegb *Gray2 )Copy ()Image {return &Gray2 {ImageBase :_eegb .copy ()}};type nrgba64 interface{NRGBA64At (_cfac ,_cfdc int )_c .NRGBA64 ;SetNRGBA64 (_gdf ,_cgag int ,_cace _c .NRGBA64 );};func _ec (_fg ,_ce *Monochrome )(_cf error ){_ed :=_ce .BytesPerLine ;
_ea :=_fg .BytesPerLine ;var (_age byte ;_ga uint16 ;_ca ,_bce ,_da ,_cfd ,_ddd int ;);for _da =0;_da < _ce .Height ;_da ++{_ca =_da *_ed ;_bce =2*_da *_ea ;for _cfd =0;_cfd < _ed ;_cfd ++{_age =_ce .Data [_ca +_cfd ];_ga =_dg [_age ];_ddd =_bce +_cfd *2;
if _fg .BytesPerLine !=_ce .BytesPerLine *2&&(_cfd +1)*2> _fg .BytesPerLine {_cf =_fg .setByte (_ddd ,byte (_ga >>8));}else {_cf =_fg .setTwoBytes (_ddd ,_ga );};if _cf !=nil {return _cf ;};};for _cfd =0;_cfd < _ea ;_cfd ++{_ddd =_bce +_ea +_cfd ;_age =_fg .Data [_bce +_cfd ];
if _cf =_fg .setByte (_ddd ,_age );_cf !=nil {return _cf ;};};};return nil ;};func (_fbag *ImageBase )setEightFullBytes (_dgab int ,_caef uint64 )error {if _dgab +7> len (_fbag .Data )-1{return _f .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_fbag .Data [_dgab ]=byte ((_caef &0xff00000000000000)>>56);_fbag .Data [_dgab +1]=byte ((_caef &0xff000000000000)>>48);_fbag .Data [_dgab +2]=byte ((_caef &0xff0000000000)>>40);_fbag .Data [_dgab +3]=byte ((_caef &0xff00000000)>>32);_fbag .Data [_dgab +4]=byte ((_caef &0xff000000)>>24);
_fbag .Data [_dgab +5]=byte ((_caef &0xff0000)>>16);_fbag .Data [_dgab +6]=byte ((_caef &0xff00)>>8);_fbag .Data [_dgab +7]=byte (_caef &0xff);return nil ;};func MonochromeThresholdConverter (threshold uint8 )ColorConverter {return &monochromeThresholdConverter {Threshold :threshold };
};type Monochrome struct{ImageBase ;ModelThreshold uint8 ;};func ColorAtGray8BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_c .Gray ,error ){_fgbfe :=y *bytesPerLine +x ;if _fgbfe >=len (data ){return _c .Gray {},_b .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_bgfg :=data [_fgbfe ];if len (decode )==2{_bgfg =uint8 (uint32 (LinearInterpolate (float64 (_bgfg ),0,255,decode [0],decode [1]))&0xff);};return _c .Gray {Y :_bgfg },nil ;};func _gagb (_gbga _cg .Image ,_agdbc int )(_cg .Rectangle ,bool ,[]byte ){_gccb :=_gbga .Bounds ();
var (_gfcdg bool ;_bbddc []byte ;);switch _gdde :=_gbga .(type ){case SMasker :_gfcdg =_gdde .HasAlpha ();case NRGBA ,RGBA ,*_cg .RGBA64 ,nrgba64 ,*_cg .NYCbCrA :_bbddc =make ([]byte ,_gccb .Max .X *_gccb .Max .Y *_agdbc );case *_cg .Paletted :var _eacg bool ;
for _ ,_eeba :=range _gdde .Palette {_bgcc ,_efda ,_gdg ,_daad :=_eeba .RGBA ();if _bgcc ==0&&_efda ==0&&_gdg ==0&&_daad !=0{_eacg =true ;break ;};};if _eacg {_bbddc =make ([]byte ,_gccb .Max .X *_gccb .Max .Y *_agdbc );};};return _gccb ,_gfcdg ,_bbddc ;
};func (_cbde *Monochrome )Bounds ()_cg .Rectangle {return _cg .Rectangle {Max :_cg .Point {X :_cbde .Width ,Y :_cbde .Height }};};func (_edba *Gray8 )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtGray8BPC (x ,y ,_edba .BytesPerLine ,_edba .Data ,_edba .Decode );
};func (_cbaf *Gray2 )Base ()*ImageBase {return &_cbaf .ImageBase };func (_ffbdg *Gray2 )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtGray2BPC (x ,y ,_ffbdg .BytesPerLine ,_ffbdg .Data ,_ffbdg .Decode );};func (_ffd colorConverter )Convert (src _cg .Image )(Image ,error ){return _ffd ._gbde (src )};
func (_efbe *NRGBA64 )At (x ,y int )_c .Color {_gccd ,_ :=_efbe .ColorAt (x ,y );return _gccd };func (_dced *NRGBA32 )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtNRGBA32 (x ,y ,_dced .Width ,_dced .Data ,_dced .Alpha ,_dced .Decode );};func (_fbaa *NRGBA16 )setNRGBA (_cebf ,_ecdg ,_badd int ,_bbcb _c .NRGBA ){if _cebf *3%2==0{_fbaa .Data [_badd ]=(_bbcb .R >>4)<<4|(_bbcb .G >>4);
_fbaa .Data [_badd +1]=(_bbcb .B >>4)<<4|(_fbaa .Data [_badd +1]&0xf);}else {_fbaa .Data [_badd ]=(_fbaa .Data [_badd ]&0xf0)|(_bbcb .R >>4);_fbaa .Data [_badd +1]=(_bbcb .G >>4)<<4|(_bbcb .B >>4);};if _fbaa .Alpha !=nil {_gdece :=_ecdg *BytesPerLine (_fbaa .Width ,4,1);
if _gdece < len (_fbaa .Alpha ){if _cebf %2==0{_fbaa .Alpha [_gdece ]=(_bbcb .A >>uint (4))<<uint (4)|(_fbaa .Alpha [_badd ]&0xf);}else {_fbaa .Alpha [_gdece ]=(_fbaa .Alpha [_gdece ]&0xf0)|(_bbcb .A >>uint (4));};};};};func (_fcec *Gray8 )SetGray (x ,y int ,g _c .Gray ){_ebeb :=y *_fcec .BytesPerLine +x ;
if _ebeb > len (_fcec .Data )-1{return ;};_fcec .Data [_ebeb ]=g .Y ;};var _ NRGBA =&NRGBA16 {};type monochromeModel uint8 ;func (_abac *Monochrome )ExpandBinary (factor int )(*Monochrome ,error ){if !IsPowerOf2 (uint (factor )){return nil ,_b .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0065\u0078\u0070\u0061\u006e\u0064\u0020b\u0069n\u0061\u0072\u0079\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",factor );
};return _bg (_abac ,factor );};func _fbca (_gefef ,_bgcda NRGBA ,_feadf _cg .Rectangle ){for _bece :=0;_bece < _feadf .Max .X ;_bece ++{for _aagd :=0;_aagd < _feadf .Max .Y ;_aagd ++{_bgcda .SetNRGBA (_bece ,_aagd ,_gefef .NRGBAAt (_bece ,_aagd ));};};
};func (_cbda *ImageBase )newAlpha (){_cead :=BytesPerLine (_cbda .Width ,_cbda .BitsPerComponent ,1);_cbda .Alpha =make ([]byte ,_cbda .Height *_cead );};func _afeb (_aeeg _cg .Image )(Image ,error ){if _accc ,_ega :=_aeeg .(*Gray2 );_ega {return _accc .Copy (),nil ;
};_fedbg :=_aeeg .Bounds ();_aebaa ,_ebe :=NewImage (_fedbg .Max .X ,_fedbg .Max .Y ,2,1,nil ,nil ,nil );if _ebe !=nil {return nil ,_ebe ;};_geaa (_aeeg ,_aebaa ,_fedbg );return _aebaa ,nil ;};func (_bdfea *Monochrome )SetGray (x ,y int ,g _c .Gray ){_bdb :=y *_bdfea .BytesPerLine +x >>3;
if _bdb > len (_bdfea .Data )-1{return ;};g =_afg (g ,monochromeModel (_bdfea .ModelThreshold ));_bdfea .setGray (x ,g ,_bdb );};func (_eedc *CMYK32 )ColorModel ()_c .Model {return _c .CMYKModel };func (_fdec *CMYK32 )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtCMYK (x ,y ,_fdec .Width ,_fdec .Data ,_fdec .Decode );
};func (_abgc *CMYK32 )At (x ,y int )_c .Color {_aeee ,_ :=_abgc .ColorAt (x ,y );return _aeee };func BytesPerLine (width ,bitsPerComponent ,colorComponents int )int {return ((width *bitsPerComponent )*colorComponents +7)>>3;};func (_bggfd *Monochrome )GrayAt (x ,y int )_c .Gray {_dgfe ,_ :=ColorAtGray1BPC (x ,y ,_bggfd .BytesPerLine ,_bggfd .Data ,_bggfd .Decode );
return _dgfe ;};func (_aef *CMYK32 )Set (x ,y int ,c _c .Color ){_bacc :=4*(y *_aef .Width +x );if _bacc +3>=len (_aef .Data ){return ;};_gac :=_c .CMYKModel .Convert (c ).(_c .CMYK );_aef .Data [_bacc ]=_gac .C ;_aef .Data [_bacc +1]=_gac .M ;_aef .Data [_bacc +2]=_gac .Y ;
_aef .Data [_bacc +3]=_gac .K ;};func _cacb (_ebca _c .Color )_c .Color {_dff :=_c .NRGBAModel .Convert (_ebca ).(_c .NRGBA );return _eceb (_dff );};func (_cafga *CMYK32 )Base ()*ImageBase {return &_cafga .ImageBase };func (_gee *Gray2 )Set (x ,y int ,c _c .Color ){if x >=_gee .Width ||y >=_gee .Height {return ;
};_gde :=Gray2Model .Convert (c ).(_c .Gray );_cdbg :=y *_gee .BytesPerLine ;_dcgd :=_cdbg +(x >>2);_bbba :=_gde .Y >>6;_gee .Data [_dcgd ]=(_gee .Data [_dcgd ]&(^(0xc0>>uint (2*((x )&3)))))|(_bbba <<uint (6-2*(x &3)));};func (_ggcb *NRGBA32 )Base ()*ImageBase {return &_ggcb .ImageBase };
func _cgaa (_gcec *_cg .Gray ,_gacfg uint8 )*_cg .Gray {_fgeag :=_gcec .Bounds ();_gfffd :=_cg .NewGray (_fgeag );for _gbeed :=0;_gbeed < _fgeag .Dx ();_gbeed ++{for _agdef :=0;_agdef < _fgeag .Dy ();_agdef ++{_gaeg :=_gcec .GrayAt (_gbeed ,_agdef );_gfffd .SetGray (_gbeed ,_agdef ,_c .Gray {Y :_efcgc (_gaeg .Y ,_gacfg )});
};};return _gfffd ;};func _gefd (_fgeb ,_gda Gray ,_geff _cg .Rectangle ){for _ecaa :=0;_ecaa < _geff .Max .X ;_ecaa ++{for _gffg :=0;_gffg < _geff .Max .Y ;_gffg ++{_gda .SetGray (_ecaa ,_gffg ,_fgeb .GrayAt (_ecaa ,_gffg ));};};};func (_fafc *Monochrome )clearBit (_cba ,_gecf int ){_fafc .Data [_cba ]&=^(0x80>>uint (_gecf &7))};
func _bcdf (_accd _cg .Image )(Image ,error ){if _bbc ,_ggc :=_accd .(*CMYK32 );_ggc {return _bbc .Copy (),nil ;};_adc :=_accd .Bounds ();_dgaa ,_dfcd :=NewImage (_adc .Max .X ,_adc .Max .Y ,8,4,nil ,nil ,nil );if _dfcd !=nil {return nil ,_dfcd ;};switch _aadg :=_accd .(type ){case CMYK :_afe (_aadg ,_dgaa .(CMYK ),_adc );
case Gray :_dbaf (_aadg ,_dgaa .(CMYK ),_adc );case NRGBA :_abab (_aadg ,_dgaa .(CMYK ),_adc );case RGBA :_eff (_aadg ,_dgaa .(CMYK ),_adc );default:_ebd (_accd ,_dgaa ,_adc );};return _dgaa ,nil ;};func (_eace *NRGBA16 )Bounds ()_cg .Rectangle {return _cg .Rectangle {Max :_cg .Point {X :_eace .Width ,Y :_eace .Height }};
};var _ _cg .Image =&NRGBA64 {};func _geaa (_dafa _cg .Image ,_bcgc Image ,_gacdc _cg .Rectangle ){switch _degg :=_dafa .(type ){case Gray :_gefd (_degg ,_bcgc .(Gray ),_gacdc );case NRGBA :_aaa (_degg ,_bcgc .(Gray ),_gacdc );case CMYK :_egge (_degg ,_bcgc .(Gray ),_gacdc );
case RGBA :_bgfad (_degg ,_bcgc .(Gray ),_gacdc );default:_ebd (_dafa ,_bcgc .(Image ),_gacdc );};};func (_egg monochromeModel )Convert (c _c .Color )_c .Color {_dad :=_c .GrayModel .Convert (c ).(_c .Gray );return _afg (_dad ,_egg );};type Gray2 struct{ImageBase };
var _ _cg .Image =&Gray4 {};func ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor int ,data ,alpha []byte ,decode []float64 )(_c .Color ,error ){switch bitsPerColor {case 4:return ColorAtNRGBA16 (x ,y ,width ,bytesPerLine ,data ,alpha ,decode );case 8:return ColorAtNRGBA32 (x ,y ,width ,data ,alpha ,decode );
case 16:return ColorAtNRGBA64 (x ,y ,width ,data ,alpha ,decode );default:return nil ,_b .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0067\u0062\u0020b\u0069\u0074\u0073\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0061\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );
};};func LinearInterpolate (x ,xmin ,xmax ,ymin ,ymax float64 )float64 {if _g .Abs (xmax -xmin )< 0.000001{return ymin ;};_efga :=ymin +(x -xmin )*(ymax -ymin )/(xmax -xmin );return _efga ;};var _ Image =&Gray8 {};type colorConverter struct{_gbde func (_ceb _cg .Image )(Image ,error );
};