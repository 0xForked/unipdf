//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package imageutil ;import (_db "errors";_a "fmt";_df "github.com/unidoc/unipdf/v3/internal/bitwise";_e "image";_c "image/color";_b "image/draw";_f "math";);func (_bbcd *Gray4 )SetGray (x ,y int ,g _c .Gray ){if x >=_bbcd .Width ||y >=_bbcd .Height {return ;};g =_ccg (g );_bbcd .setGray (x ,y ,g );};func (_ddcd *monochromeThresholdConverter )Convert (img _e .Image )(Image ,error ){if _fce ,_gcgf :=img .(*Monochrome );_gcgf {return _fce .Copy (),nil ;};_gcc :=img .Bounds ();_dgba ,_bdg :=NewImage (_gcc .Max .X ,_gcc .Max .Y ,1,1,nil ,nil ,nil );if _bdg !=nil {return nil ,_bdg ;};_dgba .(*Monochrome ).ModelThreshold =_ddcd .Threshold ;for _fca :=0;_fca < _gcc .Max .X ;_fca ++{for _ebce :=0;_ebce < _gcc .Max .Y ;_ebce ++{_ce :=img .At (_fca ,_ebce );_dgba .Set (_fca ,_ebce ,_ce );};};return _dgba ,nil ;};func _ggc (_dfbc _e .Image ,_gb Image ,_dg _e .Rectangle ){for _bfb :=0;_bfb < _dg .Max .X ;_bfb ++{for _gbf :=0;_gbf < _dg .Max .Y ;_gbf ++{_bcf :=_dfbc .At (_bfb ,_gbf );_gb .Set (_bfb ,_gbf ,_bcf );};};};func _ebcb (_acae _e .Image )(Image ,error ){if _eeg ,_bbaf :=_acae .(*NRGBA16 );_bbaf {return _eeg .Copy (),nil ;};_ecb :=_acae .Bounds ();_fda ,_bdfe :=NewImage (_ecb .Max .X ,_ecb .Max .Y ,4,3,nil ,nil ,nil );if _bdfe !=nil {return nil ,_bdfe ;};_efde (_acae ,_fda ,_ecb );return _fda ,nil ;};var _ Gray =&Gray2 {};func (_gaf *Monochrome )SetGray (x ,y int ,g _c .Gray ){_fdec :=y *_gaf .BytesPerLine +x >>3;if _fdec > len (_gaf .Data )-1{return ;};g =_bba (g ,monochromeModel (_gaf .ModelThreshold ));_gaf .setGray (x ,g ,_fdec );};func _agd (_bgg _c .Gray )_c .Gray {_fdc :=_bgg .Y >>6;_fdc |=_fdc <<2;_bgg .Y =_fdc |_fdc <<4;return _bgg ;};func (_fdbg *ImageBase )GetAlpha ()[]byte {return _fdbg .Alpha };var _ NRGBA =&NRGBA32 {};func (_fef *NRGBA64 )setNRGBA64 (_feaf int ,_agdd _c .NRGBA64 ,_bga int ){_fef .Data [_feaf ]=uint8 (_agdd .R >>8);_fef .Data [_feaf +1]=uint8 (_agdd .R &0xff);_fef .Data [_feaf +2]=uint8 (_agdd .G >>8);_fef .Data [_feaf +3]=uint8 (_agdd .G &0xff);_fef .Data [_feaf +4]=uint8 (_agdd .B >>8);_fef .Data [_feaf +5]=uint8 (_agdd .B &0xff);if _bga +1< len (_fef .Alpha ){_fef .Alpha [_bga ]=uint8 (_agdd .A >>8);_fef .Alpha [_bga +1]=uint8 (_agdd .A &0xff);};};type monochromeModel uint8 ;var _ _e .Image =&NRGBA32 {};func (_aefg *Gray4 )At (x ,y int )_c .Color {_adf ,_ :=_aefg .ColorAt (x ,y );return _adf };func (_baf *Gray2 )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtGray2BPC (x ,y ,_baf .BytesPerLine ,_baf .Data ,_baf .Decode );};func (_dbfd *Gray8 )GrayAt (x ,y int )_c .Gray {_cda ,_ :=ColorAtGray8BPC (x ,y ,_dbfd .BytesPerLine ,_dbfd .Data ,_dbfd .Decode );return _cda ;};func (_fbb *NRGBA32 )NRGBAAt (x ,y int )_c .NRGBA {_babd ,_ :=ColorAtNRGBA32 (x ,y ,_fbb .Width ,_fbb .Data ,_fbb .Alpha ,_fbb .Decode );return _babd ;};func _gfe (_gcb _e .Image ,_faf Image ,_bgdg _e .Rectangle ){switch _eeef :=_gcb .(type ){case Gray :_fcgc (_eeef ,_faf .(Gray ),_bgdg );case NRGBA :_cbea (_eeef ,_faf .(Gray ),_bgdg );case CMYK :_dfged (_eeef ,_faf .(Gray ),_bgdg );case RGBA :_ggg (_eeef ,_faf .(Gray ),_bgdg );default:_ggc (_gcb ,_faf .(Image ),_bgdg );};};func (_dcbe *NRGBA64 )At (x ,y int )_c .Color {_bef ,_ :=_dcbe .ColorAt (x ,y );return _bef };func _ge (_egf Gray ,_fc CMYK ,_ea _e .Rectangle ){for _eac :=0;_eac < _ea .Max .X ;_eac ++{for _aa :=0;_aa < _ea .Max .Y ;_aa ++{_ebc :=_egf .GrayAt (_eac ,_aa );_fc .SetCMYK (_eac ,_aa ,_gde (_ebc ));};};};func (_gafa *NRGBA32 )setRGBA (_abe int ,_eebe _c .NRGBA ){_adb :=3*_abe ;_gafa .Data [_adb ]=_eebe .R ;_gafa .Data [_adb +1]=_eebe .G ;_gafa .Data [_adb +2]=_eebe .B ;if _abe < len (_gafa .Alpha ){_gafa .Alpha [_abe ]=_eebe .A ;};};var _ Image =&Monochrome {};func _efe (_gca _c .RGBA )_c .NRGBA {switch _gca .A {case 0xff:return _c .NRGBA {R :_gca .R ,G :_gca .G ,B :_gca .B ,A :0xff};case 0x00:return _c .NRGBA {};default:_ggf ,_edd ,_cf ,_aff :=_gca .RGBA ();_ggf =(_ggf *0xffff)/_aff ;_edd =(_edd *0xffff)/_aff ;_cf =(_cf *0xffff)/_aff ;return _c .NRGBA {R :uint8 (_ggf >>8),G :uint8 (_edd >>8),B :uint8 (_cf >>8),A :uint8 (_aff >>8)};};};func (_cfa *Monochrome )At (x ,y int )_c .Color {_aabc ,_ :=_cfa .ColorAt (x ,y );return _aabc };func (_gbg *Gray16 )SetGray (x ,y int ,g _c .Gray ){_gac :=(y *_gbg .BytesPerLine /2+x )*2;if _gac +1>=len (_gbg .Data ){return ;};_gbg .Data [_gac ]=g .Y ;_gbg .Data [_gac +1]=g .Y ;};var _ Image =&Gray16 {};func (_eebg *NRGBA32 )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtNRGBA32 (x ,y ,_eebg .Width ,_eebg .Data ,_eebg .Alpha ,_eebg .Decode );};type Gray2 struct{ImageBase };func (_aabcf *Gray16 )Copy ()Image {return &Gray16 {ImageBase :_aabcf .copy ()}};func _agga (_bagf *_e .Gray ,_ceedd uint8 )*_e .Gray {_afda :=_bagf .Bounds ();_eegf :=_e .NewGray (_afda );for _fcdbd :=0;_fcdbd < _afda .Dx ();_fcdbd ++{for _ggce :=0;_ggce < _afda .Dy ();_ggce ++{_accc :=_bagf .GrayAt (_fcdbd ,_ggce );_eegf .SetGray (_fcdbd ,_ggce ,_c .Gray {Y :_dfae (_accc .Y ,_ceedd )});};};return _eegf ;};func (_cbb *Gray4 )setGray (_dab int ,_gbe int ,_fcge _c .Gray ){_debda :=_gbe *_cbb .BytesPerLine ;_acf :=_debda +(_dab >>1);if _acf >=len (_cbb .Data ){return ;};_fdd :=_fcge .Y >>4;_cbb .Data [_acf ]=(_cbb .Data [_acf ]&(^(0xf0>>uint (4*(_dab &1)))))|(_fdd <<uint (4-4*(_dab &1)));};func (_ebf *CMYK32 )Validate ()error {if len (_ebf .Data )!=4*_ebf .Width *_ebf .Height {return _db .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");};return nil ;};type Gray4 struct{ImageBase };func _dfged (_bcbf CMYK ,_eccf Gray ,_daec _e .Rectangle ){for _eed :=0;_eed < _daec .Max .X ;_eed ++{for _egbdd :=0;_egbdd < _daec .Max .Y ;_egbdd ++{_fge :=_bcb (_bcbf .CMYKAt (_eed ,_egbdd ));_eccf .SetGray (_eed ,_egbdd ,_fge );};};};func (_aedb *NRGBA16 )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtNRGBA16 (x ,y ,_aedb .Width ,_aedb .BytesPerLine ,_aedb .Data ,_aedb .Alpha ,_aedb .Decode );};func (_ace *ImageBase )Pix ()[]byte {return _ace .Data };func (_fcb *Monochrome )Base ()*ImageBase {return &_fcb .ImageBase };func (_cdcg *Gray8 )Set (x ,y int ,c _c .Color ){_acab :=y *_cdcg .BytesPerLine +x ;if _acab > len (_cdcg .Data )-1{return ;};_fgg :=_c .GrayModel .Convert (c );_cdcg .Data [_acab ]=_fgg .(_c .Gray ).Y ;};func _agc (){for _aae :=0;_aae < 256;_aae ++{_aefd [_aae ]=uint8 (_aae &0x1)+(uint8 (_aae >>1)&0x1)+(uint8 (_aae >>2)&0x1)+(uint8 (_aae >>3)&0x1)+(uint8 (_aae >>4)&0x1)+(uint8 (_aae >>5)&0x1)+(uint8 (_aae >>6)&0x1)+(uint8 (_aae >>7)&0x1);};};var _aefd [256]uint8 ;func (_aeef *NRGBA64 )Base ()*ImageBase {return &_aeef .ImageBase };var _ Image =&NRGBA32 {};func init (){_agc ()};func _cege (_ddcf *_e .NYCbCrA ,_dfdc NRGBA ,_dfecf _e .Rectangle ){for _aead :=0;_aead < _dfecf .Max .X ;_aead ++{for _cbae :=0;_cbae < _dfecf .Max .Y ;_cbae ++{_cdbg :=_ddcf .NYCbCrAAt (_aead ,_cbae );_dfdc .SetNRGBA (_aead ,_cbae ,_ebcd (_cdbg ));};};};func _cef (_egd _e .Image )(Image ,error ){if _gga ,_ebgg :=_egd .(*Gray8 );_ebgg {return _gga .Copy (),nil ;};_dbfc :=_egd .Bounds ();_cec ,_cbc :=NewImage (_dbfc .Max .X ,_dbfc .Max .Y ,8,1,nil ,nil ,nil );if _cbc !=nil {return nil ,_cbc ;};_gfe (_egd ,_cec ,_dbfc );return _cec ,nil ;};func NewImage (width ,height ,bitsPerComponent ,colorComponents int ,data ,alpha []byte ,decode []float64 )(Image ,error ){_afa :=NewImageBase (width ,height ,bitsPerComponent ,colorComponents ,data ,alpha ,decode );var _bbb Image ;switch colorComponents {case 1:switch bitsPerComponent {case 1:_bbb =&Monochrome {ImageBase :_afa ,ModelThreshold :0x0f};case 2:_bbb =&Gray2 {ImageBase :_afa };case 4:_bbb =&Gray4 {ImageBase :_afa };case 8:_bbb =&Gray8 {ImageBase :_afa };case 16:_bbb =&Gray16 {ImageBase :_afa };};case 3:switch bitsPerComponent {case 4:_bbb =&NRGBA16 {ImageBase :_afa };case 8:_bbb =&NRGBA32 {ImageBase :_afa };case 16:_bbb =&NRGBA64 {ImageBase :_afa };};case 4:_bbb =&CMYK32 {ImageBase :_afa };};if _bbb ==nil {return nil ,ErrInvalidImage ;};return _bbb ,nil ;};func (_aebc *NRGBA64 )Set (x ,y int ,c _c .Color ){_bafd :=(y *_aebc .Width +x )*2;_acabc :=_bafd *3;if _acabc +5>=len (_aebc .Data ){return ;};_ceea :=_c .NRGBA64Model .Convert (c ).(_c .NRGBA64 );_aebc .setNRGBA64 (_acabc ,_ceea ,_bafd );};var _ Image =&Gray4 {};func MonochromeModel (threshold uint8 )_c .Model {return monochromeModel (threshold )};func _egbd (_edfc _e .Image )(Image ,error ){if _ecf ,_cgd :=_edfc .(*Gray4 );_cgd {return _ecf .Copy (),nil ;};_edda :=_edfc .Bounds ();_cfg ,_dbg :=NewImage (_edda .Max .X ,_edda .Max .Y ,4,1,nil ,nil ,nil );if _dbg !=nil {return nil ,_dbg ;};_gfe (_edfc ,_cfg ,_edda );return _cfg ,nil ;};func (_gea *Gray16 )Validate ()error {if len (_gea .Data )!=_gea .Height *_gea .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_dcb *Gray4 )Set (x ,y int ,c _c .Color ){if x >=_dcb .Width ||y >=_dcb .Height {return ;};_edg :=Gray4Model .Convert (c ).(_c .Gray );_dcb .setGray (x ,y ,_edg );};func (_fgb *NRGBA32 )Bounds ()_e .Rectangle {return _e .Rectangle {Max :_e .Point {X :_fgb .Width ,Y :_fgb .Height }};};var _ Gray =&Gray8 {};func _aed (_bab _c .RGBA )_c .CMYK {_bfec ,_eaf ,_fcfb ,_dac :=_c .RGBToCMYK (_bab .R ,_bab .G ,_bab .B );return _c .CMYK {C :_bfec ,M :_eaf ,Y :_fcfb ,K :_dac };};func (_bcgac *NRGBA64 )Copy ()Image {return &NRGBA64 {ImageBase :_bcgac .copy ()}};func (_gef *ImageBase )newAlpha (){_dcee :=BytesPerLine (_gef .Width ,_gef .BitsPerComponent ,1);_gef .Alpha =make ([]byte ,_gef .Height *_dcee );};func _adfcd (_daf _e .Image )(Image ,error ){if _fddg ,_affe :=_daf .(*NRGBA32 );_affe {return _fddg .Copy (),nil ;};_fcdc ,_acfa ,_efdgc :=_gfg (_daf ,1);_bgbd ,_dacd :=NewImage (_fcdc .Max .X ,_fcdc .Max .Y ,8,3,nil ,_efdgc ,nil );if _dacd !=nil {return nil ,_dacd ;};_efde (_daf ,_bgbd ,_fcdc );if len (_efdgc )!=0&&!_acfa {if _bfff :=_bfbg (_efdgc ,_bgbd );_bfff !=nil {return nil ,_bfff ;};};return _bgbd ,nil ;};func (_edc *Gray2 )Base ()*ImageBase {return &_edc .ImageBase };func ColorAtGray8BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_c .Gray ,error ){_deff :=y *bytesPerLine +x ;if _deff >=len (data ){return _c .Gray {},_a .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_dcf :=data [_deff ];if len (decode )==2{_dcf =uint8 (uint32 (LinearInterpolate (float64 (_dcf ),0,255,decode [0],decode [1]))&0xff);};return _c .Gray {Y :_dcf },nil ;};func (_egac *Gray8 )Copy ()Image {return &Gray8 {ImageBase :_egac .copy ()}};type RGBA interface{RGBAAt (_edab ,_fdcf int )_c .RGBA ;SetRGBA (_edgc ,_geaf int ,_bdb _c .RGBA );};func _bb (_da _c .NRGBA )_c .CMYK {_cdc ,_bcc ,_ga ,_ :=_da .RGBA ();_ddaa ,_bge ,_gbff ,_fab :=_c .RGBToCMYK (uint8 (_cdc >>8),uint8 (_bcc >>8),uint8 (_ga >>8));return _c .CMYK {C :_ddaa ,M :_bge ,Y :_gbff ,K :_fab };};func _ebaaa (_cbge int ,_dfaag int )error {return _a .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",_cbge ,_dfaag );};func (_dbgg *Gray16 )Set (x ,y int ,c _c .Color ){_daa :=(y *_dbgg .BytesPerLine /2+x )*2;if _daa +1>=len (_dbgg .Data ){return ;};_fdcbe :=_c .Gray16Model .Convert (c ).(_c .Gray16 );_dbgg .Data [_daa ],_dbgg .Data [_daa +1]=uint8 (_fdcbe .Y >>8),uint8 (_fdcbe .Y &0xff);};var _ Image =&Gray8 {};type NRGBA interface{NRGBAAt (_cefa ,_fba int )_c .NRGBA ;SetNRGBA (_edaf ,_fddb int ,_fddc _c .NRGBA );};func (_ffga *Gray2 )Bounds ()_e .Rectangle {return _e .Rectangle {Max :_e .Point {X :_ffga .Width ,Y :_ffga .Height }};};func (_dfa *Gray2 )GrayAt (x ,y int )_c .Gray {_fdcb ,_ :=ColorAtGray2BPC (x ,y ,_dfa .BytesPerLine ,_dfa .Data ,_dfa .Decode );return _fdcb ;};func ColorAtGray1BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_c .Gray ,error ){_bfdf :=y *bytesPerLine +x >>3;if _bfdf >=len (data ){return _c .Gray {},_a .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_adg :=data [_bfdf ]>>uint (7-(x &7))&1;if len (decode )==2{_adg =uint8 (LinearInterpolate (float64 (_adg ),0.0,1.0,decode [0],decode [1]))&1;};return _c .Gray {Y :_adg *255},nil ;};func (_ega *CMYK32 )SetCMYK (x ,y int ,c _c .CMYK ){_cd :=4*(y *_ega .Width +x );if _cd +3>=len (_ega .Data ){return ;};_ega .Data [_cd ]=c .C ;_ega .Data [_cd +1]=c .M ;_ega .Data [_cd +2]=c .Y ;_ega .Data [_cd +3]=c .K ;};func ColorAtGray2BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_c .Gray ,error ){_bgd :=y *bytesPerLine +x >>2;if _bgd >=len (data ){return _c .Gray {},_a .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_defc :=data [_bgd ]>>uint (6-(x &3)*2)&3;if len (decode )==2{_defc =uint8 (uint32 (LinearInterpolate (float64 (_defc ),0,3.0,decode [0],decode [1]))&3);};return _c .Gray {Y :_defc *85},nil ;};func (_ggff *NRGBA32 )Copy ()Image {return &NRGBA32 {ImageBase :_ggff .copy ()}};func (_ead *Monochrome )ColorModel ()_c .Model {return MonochromeModel (_ead .ModelThreshold )};func _ebg (_bcga _c .Color )_c .Color {_bffa :=_c .GrayModel .Convert (_bcga ).(_c .Gray );return _agd (_bffa );};func _bba (_bdf _c .Gray ,_fe monochromeModel )_c .Gray {if _bdf .Y > uint8 (_fe ){return _c .Gray {Y :_f .MaxUint8 };};return _c .Gray {};};func (_add *Gray2 )At (x ,y int )_c .Color {_abf ,_ :=_add .ColorAt (x ,y );return _abf };type NRGBA16 struct{ImageBase };func (_fdb *CMYK32 )Bounds ()_e .Rectangle {return _e .Rectangle {Max :_e .Point {X :_fdb .Width ,Y :_fdb .Height }};};func (_ffe *Gray8 )SetGray (x ,y int ,g _c .Gray ){_bbdf :=y *_ffe .BytesPerLine +x ;if _bbdf > len (_ffe .Data )-1{return ;};_ffe .Data [_bbdf ]=g .Y ;};func AutoThresholdTriangle (histogram [256]int )uint8 {var _feda ,_ccba ,_ecfa ,_adfce int ;for _bfdb :=0;_bfdb < len (histogram );_bfdb ++{if histogram [_bfdb ]> 0{_feda =_bfdb ;break ;};};if _feda > 0{_feda --;};for _dcc :=255;_dcc > 0;_dcc --{if histogram [_dcc ]> 0{_adfce =_dcc ;break ;};};if _adfce < 255{_adfce ++;};for _fafg :=0;_fafg < 256;_fafg ++{if histogram [_fafg ]> _ccba {_ecfa =_fafg ;_ccba =histogram [_fafg ];};};var _aafe bool ;if (_ecfa -_feda )< (_adfce -_ecfa ){_aafe =true ;var _bcdfc int ;_eeba :=255;for _bcdfc < _eeba {_cged :=histogram [_bcdfc ];histogram [_bcdfc ]=histogram [_eeba ];histogram [_eeba ]=_cged ;_bcdfc ++;_eeba --;};_feda =255-_adfce ;_ecfa =255-_ecfa ;};if _feda ==_ecfa {return uint8 (_feda );};_cecb :=float64 (histogram [_ecfa ]);_egff :=float64 (_feda -_ecfa );_abee :=_f .Sqrt (_cecb *_cecb +_egff *_egff );_cecb /=_abee ;_egff /=_abee ;_abee =_cecb *float64 (_feda )+_egff *float64 (histogram [_feda ]);_afbf :=_feda ;var _dbgd float64 ;for _fgec :=_feda +1;_fgec <=_ecfa ;_fgec ++{_ebcgc :=_cecb *float64 (_fgec )+_egff *float64 (histogram [_fgec ])-_abee ;if _ebcgc > _dbgd {_afbf =_fgec ;_dbgd =_ebcgc ;};};_afbf --;if _aafe {var _bfc int ;_bace :=255;for _bfc < _bace {_acged :=histogram [_bfc ];histogram [_bfc ]=histogram [_bace ];histogram [_bace ]=_acged ;_bfc ++;_bace --;};return uint8 (255-_afbf );};return uint8 (_afbf );};func _eged (_eabg *_e .Gray16 ,_aeec uint8 )*_e .Gray {_ade :=_eabg .Bounds ();_ggfc :=_e .NewGray (_ade );for _cdff :=0;_cdff < _ade .Dx ();_cdff ++{for _aaaa :=0;_aaaa < _ade .Dy ();_aaaa ++{_cbdb :=_eabg .Gray16At (_cdff ,_aaaa );_ggfc .SetGray (_cdff ,_aaaa ,_c .Gray {Y :_dfae (uint8 (_cbdb .Y /256),_aeec )});};};return _ggfc ;};func _ccg (_gae _c .Gray )_c .Gray {_gae .Y >>=4;_gae .Y |=_gae .Y <<4;return _gae };func _gda (_fbag _c .NRGBA )_c .NRGBA {_fbag .R =_fbag .R >>4|(_fbag .R >>4)<<4;_fbag .G =_fbag .G >>4|(_fbag .G >>4)<<4;_fbag .B =_fbag .B >>4|(_fbag .B >>4)<<4;return _fbag ;};var _ Gray =&Monochrome {};func _aaff (_ccd nrgba64 ,_cddc NRGBA ,_bgff _e .Rectangle ){for _ccde :=0;_ccde < _bgff .Max .X ;_ccde ++{for _cdfe :=0;_cdfe < _bgff .Max .Y ;_cdfe ++{_fedd :=_ccd .NRGBA64At (_ccde ,_cdfe );_cddc .SetNRGBA (_ccde ,_cdfe ,_edf (_fedd ));};};};func (_fgc *ImageBase )copy ()ImageBase {_cdg :=*_fgc ;_cdg .Data =make ([]byte ,len (_fgc .Data ));copy (_cdg .Data ,_fgc .Data );return _cdg ;};func ColorAtGray16BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_c .Gray16 ,error ){_cdf :=(y *bytesPerLine /2+x )*2;if _cdf +1>=len (data ){return _c .Gray16 {},_a .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_ced :=uint16 (data [_cdf ])<<8|uint16 (data [_cdf +1]);if len (decode )==2{_ced =uint16 (uint64 (LinearInterpolate (float64 (_ced ),0,65535,decode [0],decode [1])));};return _c .Gray16 {Y :_ced },nil ;};func _gde (_fad _c .Gray )_c .CMYK {return _c .CMYK {K :0xff-_fad .Y }};var _ Image =&NRGBA64 {};func (_gcfa *Gray16 )Base ()*ImageBase {return &_gcfa .ImageBase };func ColorAtGray4BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_c .Gray ,error ){_gfb :=y *bytesPerLine +x >>1;if _gfb >=len (data ){return _c .Gray {},_a .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_cacc :=data [_gfb ]>>uint (4-(x &1)*4)&0xf;if len (decode )==2{_cacc =uint8 (uint32 (LinearInterpolate (float64 (_cacc ),0,15,decode [0],decode [1]))&0xf);};return _c .Gray {Y :_cacc *17&0xff},nil ;};func _fcgc (_edb ,_gaee Gray ,_ede _e .Rectangle ){for _bgb :=0;_bgb < _ede .Max .X ;_bgb ++{for _bafcf :=0;_bafcf < _ede .Max .Y ;_bafcf ++{_gaee .SetGray (_bgb ,_bafcf ,_edb .GrayAt (_bgb ,_bafcf ));};};};type Image interface{_b .Image ;Base ()*ImageBase ;Copy ()Image ;Pix ()[]byte ;ColorAt (_bccc ,_egdb int )(_c .Color ,error );Validate ()error ;};func _efde (_ebac _e .Image ,_bac Image ,_eccfe _e .Rectangle ){if _edde ,_eecc :=_ebac .(SMasker );_eecc &&_edde .HasAlpha (){_bac .(SMasker ).MakeAlpha ();};switch _eeaa :=_ebac .(type ){case Gray :_edcg (_eeaa ,_bac .(NRGBA ),_eccfe );case NRGBA :_feg (_eeaa ,_bac .(NRGBA ),_eccfe );case *_e .NYCbCrA :_cege (_eeaa ,_bac .(NRGBA ),_eccfe );case CMYK :_dgd (_eeaa ,_bac .(NRGBA ),_eccfe );case RGBA :_cab (_eeaa ,_bac .(NRGBA ),_eccfe );case nrgba64 :_aaff (_eeaa ,_bac .(NRGBA ),_eccfe );default:_ggc (_ebac ,_bac ,_eccfe );};};func (_ceg *Gray16 )Histogram ()(_affg [256]int ){for _fdcc :=0;_fdcc < _ceg .Width ;_fdcc ++{for _afeg :=0;_afeg < _ceg .Height ;_afeg ++{_affg [_ceg .GrayAt (_fdcc ,_afeg ).Y ]++;};};return _affg ;};func (_ffb *CMYK32 )Base ()*ImageBase {return &_ffb .ImageBase };func (_cfgb *Gray16 )GrayAt (x ,y int )_c .Gray {_aec ,_ :=_cfgb .ColorAt (x ,y );return _c .Gray {Y :uint8 (_aec .(_c .Gray16 ).Y >>8)};};func (_aggd *Gray4 )ColorModel ()_c .Model {return Gray4Model };func (_dege *NRGBA64 )ColorModel ()_c .Model {return _c .NRGBA64Model };var _ Gray =&Gray4 {};func (_gebc *NRGBA64 )NRGBA64At (x ,y int )_c .NRGBA64 {_acda ,_ :=ColorAtNRGBA64 (x ,y ,_gebc .Width ,_gebc .Data ,_gebc .Alpha ,_gebc .Decode );return _acda ;};var _ Image =&CMYK32 {};func _ggg (_egfc RGBA ,_afbd Gray ,_dee _e .Rectangle ){for _fec :=0;_fec < _dee .Max .X ;_fec ++{for _cdbc :=0;_cdbc < _dee .Max .Y ;_cdbc ++{_dfec :=_acc (_egfc .RGBAAt (_fec ,_cdbc ));_afbd .SetGray (_fec ,_cdbc ,_dfec );};};};func _gfg (_gbec _e .Image ,_fbbe int )(_e .Rectangle ,bool ,[]byte ){_dgc :=_gbec .Bounds ();var (_beab bool ;_cegd []byte ;);switch _aedbg :=_gbec .(type ){case SMasker :_beab =_aedbg .HasAlpha ();case NRGBA ,RGBA ,*_e .RGBA64 ,nrgba64 ,*_e .NYCbCrA :_cegd =make ([]byte ,_dgc .Max .X *_dgc .Max .Y *_fbbe );};return _dgc ,_beab ,_cegd ;};func (_bc *CMYK32 )ColorModel ()_c .Model {return _c .CMYKModel };func (_egafe *NRGBA32 )Base ()*ImageBase {return &_egafe .ImageBase };func (_fgdg *NRGBA16 )Set (x ,y int ,c _c .Color ){_cgg :=y *_fgdg .BytesPerLine +x *3/2;if _cgg +1>=len (_fgdg .Data ){return ;};_fadab :=NRGBA16Model .Convert (c ).(_c .NRGBA );_fgdg .setNRGBA (x ,y ,_cgg ,_fadab );};func (_cacd *Gray8 )ColorModel ()_c .Model {return _c .GrayModel };func _ca (_fgd _e .Image )(Image ,error ){if _dbf ,_ae :=_fgd .(*CMYK32 );_ae {return _dbf .Copy (),nil ;};_egb :=_fgd .Bounds ();_egaf ,_cb :=NewImage (_egb .Max .X ,_egb .Max .Y ,8,4,nil ,nil ,nil );if _cb !=nil {return nil ,_cb ;};switch _aeb :=_fgd .(type ){case CMYK :_gc (_aeb ,_egaf .(CMYK ),_egb );case Gray :_ge (_aeb ,_egaf .(CMYK ),_egb );case NRGBA :_fde (_aeb ,_egaf .(CMYK ),_egb );case RGBA :_eag (_aeb ,_egaf .(CMYK ),_egb );default:_ggc (_fgd ,_egaf ,_egb );};return _egaf ,nil ;};type monochromeThresholdConverter struct{Threshold uint8 ;};func (_aad *Monochrome )Validate ()error {if len (_aad .Data )!=_aad .Height *_aad .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_fee *Gray4 )Validate ()error {if len (_fee .Data )!=_fee .Height *_fee .BytesPerLine {return ErrInvalidImage ;};return nil ;};func LinearInterpolate (x ,xmin ,xmax ,ymin ,ymax float64 )float64 {if _f .Abs (xmax -xmin )< 0.000001{return ymin ;};_cfcg :=ymin +(x -xmin )*(ymax -ymin )/(xmax -xmin );return _cfcg ;};func (_abaa *Gray16 )ColorModel ()_c .Model {return _c .Gray16Model };var _ Image =&Gray2 {};type ImageBase struct{Width ,Height int ;BitsPerComponent ,ColorComponents int ;Data ,Alpha []byte ;Decode []float64 ;BytesPerLine int ;};func (_ebcg *NRGBA64 )Validate ()error {if len (_ebcg .Data )!=3*2*_ebcg .Width *_ebcg .Height {return _db .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");};return nil ;};func (_bg *CMYK32 )Set (x ,y int ,c _c .Color ){_eg :=4*(y *_bg .Width +x );if _eg +3>=len (_bg .Data ){return ;};_de :=_c .CMYKModel .Convert (c ).(_c .CMYK );_bg .Data [_eg ]=_de .C ;_bg .Data [_eg +1]=_de .M ;_bg .Data [_eg +2]=_de .Y ;_bg .Data [_eg +3]=_de .K ;};type nrgba64 interface{NRGBA64At (_eabc ,_eaba int )_c .NRGBA64 ;SetNRGBA64 (_cddf ,_abfe int ,_fdeb _c .NRGBA64 );};func (_aaa *Gray8 )Histogram ()(_ecc [256]int ){for _afb :=0;_afb < len (_aaa .Data );_afb ++{_ecc [_aaa .Data [_afb ]]++;};return _ecc ;};var (MonochromeConverter =ConverterFunc (_ec );Gray2Converter =ConverterFunc (_fabb );Gray4Converter =ConverterFunc (_egbd );GrayConverter =ConverterFunc (_cef );Gray16Converter =ConverterFunc (_dbac );NRGBA16Converter =ConverterFunc (_ebcb );NRGBAConverter =ConverterFunc (_adfcd );NRGBA64Converter =ConverterFunc (_bdfd );CMYKConverter =ConverterFunc (_ca ););func ColorAt (x ,y ,width ,bitsPerColor ,colorComponents ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_c .Color ,error ){switch colorComponents {case 1:return ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine ,data ,decode );case 3:return ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor ,data ,alpha ,decode );case 4:return ColorAtCMYK (x ,y ,width ,data ,decode );default:return nil ,_a .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0063o\u006c\u006f\u0072\u0020\u0063\u006f\u006dp\u006f\u006e\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0064",colorComponents );};};func (_bcdg *NRGBA32 )At (x ,y int )_c .Color {_aee ,_ :=_bcdg .ColorAt (x ,y );return _aee };func ColorAtCMYK (x ,y ,width int ,data []byte ,decode []float64 )(_c .CMYK ,error ){_egg :=4*(y *width +x );if _egg +3>=len (data ){return _c .CMYK {},_a .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};C :=data [_egg ]&0xff;M :=data [_egg +1]&0xff;Y :=data [_egg +2]&0xff;K :=data [_egg +3]&0xff;if len (decode )==8{C =uint8 (uint32 (LinearInterpolate (float64 (C ),0,255,decode [0],decode [1]))&0xff);M =uint8 (uint32 (LinearInterpolate (float64 (M ),0,255,decode [2],decode [3]))&0xff);Y =uint8 (uint32 (LinearInterpolate (float64 (Y ),0,255,decode [4],decode [5]))&0xff);K =uint8 (uint32 (LinearInterpolate (float64 (K ),0,255,decode [6],decode [7]))&0xff);};return _c .CMYK {C :C ,M :M ,Y :Y ,K :K },nil ;};func (_cbee monochromeModel )Convert (c _c .Color )_c .Color {_cdb :=_c .GrayModel .Convert (c ).(_c .Gray );return _bba (_cdb ,_cbee );};func (_g *CMYK32 )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtCMYK (x ,y ,_g .Width ,_g .Data ,_g .Decode );};func (_bafc *Gray4 )Histogram ()(_cee [256]int ){for _ddde :=0;_ddde < _bafc .Width ;_ddde ++{for _dagb :=0;_dagb < _bafc .Height ;_dagb ++{_cee [_bafc .GrayAt (_ddde ,_dagb ).Y ]++;};};return _cee ;};func _dagg (_gec _e .Image ,_cefe uint8 )*_e .Gray {_afg :=_gec .Bounds ();_agbb :=_e .NewGray (_afg );var (_fbfb _c .Color ;_dcba _c .Gray ;);for _caga :=0;_caga < _afg .Max .X ;_caga ++{for _cbgg :=0;_cbgg < _afg .Max .Y ;_cbgg ++{_fbfb =_gec .At (_caga ,_cbgg );_agbb .Set (_caga ,_cbgg ,_fbfb );_dcba =_agbb .GrayAt (_caga ,_cbgg );_agbb .SetGray (_caga ,_cbgg ,_c .Gray {Y :_dfae (_dcba .Y ,_cefe )});};};return _agbb ;};func (_dfd *NRGBA32 )Validate ()error {if len (_dfd .Data )!=3*_dfd .Width *_dfd .Height {return _db .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");};return nil ;};func (_cg *CMYK32 )At (x ,y int )_c .Color {_fa ,_ :=_cg .ColorAt (x ,y );return _fa };func _cbea (_cbd NRGBA ,_cfc Gray ,_fae _e .Rectangle ){for _fbf :=0;_fbf < _fae .Max .X ;_fbf ++{for _gfba :=0;_gfba < _fae .Max .Y ;_gfba ++{_bed :=_gcf (_cbd .NRGBAAt (_fbf ,_gfba ));_cfc .SetGray (_fbf ,_gfba ,_bed );};};};func (_eff *Gray8 )Validate ()error {if len (_eff .Data )!=_eff .Height *_eff .BytesPerLine {return ErrInvalidImage ;};return nil ;};func _fabb (_fcg _e .Image )(Image ,error ){if _fcea ,_cgc :=_fcg .(*Gray2 );_cgc {return _fcea .Copy (),nil ;};_gf :=_fcg .Bounds ();_ggfb ,_ege :=NewImage (_gf .Max .X ,_gf .Max .Y ,2,1,nil ,nil ,nil );if _ege !=nil {return nil ,_ege ;};_gfe (_fcg ,_ggfb ,_gf );return _ggfb ,nil ;};func _ebcd (_ggb _c .NYCbCrA )_c .NRGBA {_deg :=int32 (_ggb .Y )*0x10101;_bff :=int32 (_ggb .Cb )-128;_ffg :=int32 (_ggb .Cr )-128;_dgb :=_deg +91881*_ffg ;if uint32 (_dgb )&0xff000000==0{_dgb >>=8;}else {_dgb =^(_dgb >>31)&0xffff;};_acd :=_deg -22554*_bff -46802*_ffg ;if uint32 (_acd )&0xff000000==0{_acd >>=8;}else {_acd =^(_acd >>31)&0xffff;};_afc :=_deg +116130*_bff ;if uint32 (_afc )&0xff000000==0{_afc >>=8;}else {_afc =^(_afc >>31)&0xffff;};return _c .NRGBA {R :uint8 (_dgb >>8),G :uint8 (_acd >>8),B :uint8 (_afc >>8),A :_ggb .A };};func _dfae (_adgd ,_dfed uint8 )uint8 {if _adgd < _dfed {return 255;};return 0;};type colorConverter struct{_bcd func (_dba _e .Image )(Image ,error );};func _bdfd (_aadc _e .Image )(Image ,error ){if _ccf ,_dfdf :=_aadc .(*NRGBA64 );_dfdf {return _ccf .Copy (),nil ;};_feaff ,_cfcd ,_bedf :=_gfg (_aadc ,2);_agec ,_dceecb :=NewImage (_feaff .Max .X ,_feaff .Max .Y ,16,3,nil ,_bedf ,nil );if _dceecb !=nil {return nil ,_dceecb ;};_cdee (_aadc ,_agec ,_feaff );if len (_bedf )!=0&&!_cfcd {if _efeb :=_bfbg (_bedf ,_agec );_efeb !=nil {return nil ,_efeb ;};};return _agec ,nil ;};func (_dca colorConverter )Convert (src _e .Image )(Image ,error ){return _dca ._bcd (src )};var (Gray2Model =_c .ModelFunc (_ebg );Gray4Model =_c .ModelFunc (_ffae );NRGBA16Model =_c .ModelFunc (_gbfg ););func _aebce (_cfd uint8 )bool {if _cfd ==0||_cfd ==255{return true ;};return false ;};type Histogramer interface{Histogram ()[256]int ;};func (_edgca *NRGBA16 )At (x ,y int )_c .Color {_ddaf ,_ :=_edgca .ColorAt (x ,y );return _ddaf };func FromGoImage (i _e .Image )(Image ,error ){switch _eddac :=i .(type ){case Image :return _eddac .Copy (),nil ;case Gray :return GrayConverter .Convert (i );case *_e .Gray16 :return Gray16Converter .Convert (i );case CMYK :return CMYKConverter .Convert (i );case *_e .NRGBA64 :return NRGBA64Converter .Convert (i );default:return NRGBAConverter .Convert (i );};};func _cdee (_aeda _e .Image ,_edbd Image ,_beda _e .Rectangle ){if _dfc ,_agba :=_aeda .(SMasker );_agba &&_dfc .HasAlpha (){_edbd .(SMasker ).MakeAlpha ();};_ggc (_aeda ,_edbd ,_beda );};func BytesPerLine (width ,bitsPerComponent ,colorComponents int )int {return ((width *bitsPerComponent )*colorComponents +7)>>3;};func MonochromeThresholdConverter (threshold uint8 )ColorConverter {return &monochromeThresholdConverter {Threshold :threshold };};func ImgToGray (i _e .Image )*_e .Gray {if _ebfc ,_adbb :=i .(*_e .Gray );_adbb {return _ebfc ;};_cage :=i .Bounds ();_cgee :=_e .NewGray (_cage );for _ccag :=0;_ccag < _cage .Max .X ;_ccag ++{for _fadd :=0;_fadd < _cage .Max .Y ;_fadd ++{_geac :=i .At (_ccag ,_fadd );_cgee .Set (_ccag ,_fadd ,_geac );};};return _cgee ;};type Gray interface{GrayAt (_dcd ,_dfg int )_c .Gray ;SetGray (_bgf ,_fag int ,_cbg _c .Gray );};func (_dbbd *NRGBA64 )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtNRGBA64 (x ,y ,_dbbd .Width ,_dbbd .Data ,_dbbd .Alpha ,_dbbd .Decode );};func (_gdgd *Gray8 )At (x ,y int )_c .Color {_efdf ,_ :=_gdgd .ColorAt (x ,y );return _efdf };func (_aaf *Monochrome )Histogram ()(_gbfb [256]int ){for _ ,_dgg :=range _aaf .Data {_gbfb [0xff]+=int (_aefd [_aaf .Data [_dgg ]]);};return _gbfb ;};func _fde (_bd NRGBA ,_dc CMYK ,_dce _e .Rectangle ){for _ag :=0;_ag < _dce .Max .X ;_ag ++{for _gg :=0;_gg < _dce .Max .Y ;_gg ++{_fga :=_bd .NRGBAAt (_ag ,_gg );_dc .SetCMYK (_ag ,_gg ,_bb (_fga ));};};};func (_efec *NRGBA32 )Set (x ,y int ,c _c .Color ){_cbgc :=y *_efec .Width +x ;_fbab :=3*_cbgc ;if _fbab +2>=len (_efec .Data ){return ;};_efda :=_c .NRGBAModel .Convert (c ).(_c .NRGBA );_efec .setRGBA (_cbgc ,_efda );};var _ _e .Image =&NRGBA16 {};func GrayHistogram (g Gray )(_bgbc [256]int ){switch _ccaa :=g .(type ){case Histogramer :return _ccaa .Histogram ();case _e .Image :_bde :=_ccaa .Bounds ();for _agef :=0;_agef < _bde .Max .X ;_agef ++{for _gbfe :=0;_gbfe < _bde .Max .Y ;_gbfe ++{_bgbc [g .GrayAt (_agef ,_gbfe ).Y ]++;};};return _bgbc ;default:return [256]int {};};};func _acg (_cge _c .Gray )_c .NRGBA {return _c .NRGBA {R :_cge .Y ,G :_cge .Y ,B :_cge .Y ,A :0xff}};func _ffae (_dbeb _c .Color )_c .Color {_dfaa :=_c .GrayModel .Convert (_dbeb ).(_c .Gray );return _ccg (_dfaa );};type SMasker interface{HasAlpha ()bool ;GetAlpha ()[]byte ;MakeAlpha ();};func _ec (_def _e .Image )(Image ,error ){if _aab ,_cdd :=_def .(*Monochrome );_cdd {return _aab ,nil ;};_eba ,_efdg :=_def .(Gray );if !_efdg {_gag ,_dgf :=GrayConverter .Convert (_def );if _dgf !=nil {return nil ,_dgf ;};_eba =_gag .(Gray );};_accg :=_def .Bounds ();_bcg ,_bea :=NewImage (_accg .Max .X ,_accg .Max .Y ,1,1,nil ,nil ,nil );if _bea !=nil {return nil ,_bea ;};_ab :=_bcg .(*Monochrome );_bfd :=AutoThresholdTriangle (GrayHistogram (_eba ));for _age :=0;_age < _accg .Max .X ;_age ++{for _bag :=0;_bag < _accg .Max .Y ;_bag ++{_efeg :=_bba (_eba .GrayAt (_age ,_bag ),monochromeModel (_bfd ));_ab .SetGray (_age ,_bag ,_efeg );};};return _bcg ,nil ;};func (_aedc *Monochrome )setBit (_fcag ,_bccb int ){_aedc .Data [_fcag ]|=0x80>>uint (_bccb &7)};func GetConverter (bitsPerComponent ,colorComponents int )(ColorConverter ,error ){switch colorComponents {case 1:switch bitsPerComponent {case 1:return MonochromeConverter ,nil ;case 2:return Gray2Converter ,nil ;case 4:return Gray4Converter ,nil ;case 8:return GrayConverter ,nil ;case 16:return Gray16Converter ,nil ;};case 3:switch bitsPerComponent {case 4:return NRGBA16Converter ,nil ;case 8:return NRGBAConverter ,nil ;case 16:return NRGBA64Converter ,nil ;};case 4:return CMYKConverter ,nil ;};return nil ,_a .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0043o\u006e\u0076\u0065\u0072\u0074\u0065\u0072\u0020\u0070\u0061\u0072\u0061\u006d\u0065t\u0065\u0072\u0073\u002e\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003a\u0020\u0025\u0064\u002c\u0020\u0043\u006f\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006et\u0073\u003a \u0025\u0064",bitsPerComponent ,colorComponents );};func (_aba *Gray2 )Validate ()error {if len (_aba .Data )!=_aba .Height *_aba .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_faa *NRGBA32 )ColorModel ()_c .Model {return _c .NRGBAModel };var _ _e .Image =&Gray16 {};var _ Image =&NRGBA16 {};func _eag (_be RGBA ,_af CMYK ,_ac _e .Rectangle ){for _ed :=0;_ed < _ac .Max .X ;_ed ++{for _dda :=0;_dda < _ac .Max .Y ;_dda ++{_aca :=_be .RGBAAt (_ed ,_dda );_af .SetCMYK (_ed ,_dda ,_aed (_aca ));};};};func (_fdcfa *NRGBA16 )Base ()*ImageBase {return &_fdcfa .ImageBase };func (_fea *Gray4 )Bounds ()_e .Rectangle {return _e .Rectangle {Max :_e .Point {X :_fea .Width ,Y :_fea .Height }};};func (_fcbgb *NRGBA16 )Copy ()Image {return &NRGBA16 {ImageBase :_fcbgb .copy ()}};var _ _e .Image =&Gray2 {};func (_dbe *Monochrome )Bounds ()_e .Rectangle {return _e .Rectangle {Max :_e .Point {X :_dbe .Width ,Y :_dbe .Height }};};func _dgd (_dgfd CMYK ,_fgbf NRGBA ,_dbaf _e .Rectangle ){for _aeba :=0;_aeba < _dbaf .Max .X ;_aeba ++{for _bgfg :=0;_bgfg < _dbaf .Max .Y ;_bgfg ++{_dgbd :=_dgfd .CMYKAt (_aeba ,_bgfg );_fgbf .SetNRGBA (_aeba ,_bgfg ,_cad (_dgbd ));};};};func _dbac (_cgce _e .Image )(Image ,error ){if _bgdd ,_acge :=_cgce .(*Gray16 );_acge {return _bgdd .Copy (),nil ;};_beb :=_cgce .Bounds ();_fcae ,_dde :=NewImage (_beb .Max .X ,_beb .Max .Y ,16,1,nil ,nil ,nil );if _dde !=nil {return nil ,_dde ;};_gfe (_cgce ,_fcae ,_beb );return _fcae ,nil ;};func (_gdf *Monochrome )clearBit (_cfba ,_cea int ){_gdf .Data [_cfba ]&=^(0x80>>uint (_cea &7))};func _gc (_dec ,_ef CMYK ,_gcg _e .Rectangle ){for _ffa :=0;_ffa < _gcg .Max .X ;_ffa ++{for _efc :=0;_efc < _gcg .Max .Y ;_efc ++{_ef .SetCMYK (_ffa ,_efc ,_dec .CMYKAt (_ffa ,_efc ));};};};var _ _e .Image =&Monochrome {};func (_acea *NRGBA64 )SetNRGBA64 (x ,y int ,c _c .NRGBA64 ){_bae :=(y *_acea .Width +x )*2;_gfa :=_bae *3;if _gfa +5>=len (_acea .Data ){return ;};_acea .setNRGBA64 (_gfa ,c ,_bae );};func (_eee *Gray8 )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtGray8BPC (x ,y ,_eee .BytesPerLine ,_eee .Data ,_eee .Decode );};var _ _e .Image =&NRGBA64 {};func ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine int ,data []byte ,decode []float64 )(_c .Color ,error ){switch bitsPerColor {case 1:return ColorAtGray1BPC (x ,y ,bytesPerLine ,data ,decode );case 2:return ColorAtGray2BPC (x ,y ,bytesPerLine ,data ,decode );case 4:return ColorAtGray4BPC (x ,y ,bytesPerLine ,data ,decode );case 8:return ColorAtGray8BPC (x ,y ,bytesPerLine ,data ,decode );case 16:return ColorAtGray16BPC (x ,y ,bytesPerLine ,data ,decode );default:return nil ,_a .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0067\u0072\u0061\u0079\u0020\u0073c\u0061\u006c\u0065\u0020\u0062\u0069\u0074s\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020a\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );};};var _ NRGBA =&NRGBA16 {};func (_afe *Gray2 )Copy ()Image {return &Gray2 {ImageBase :_afe .copy ()}};func (_dd *CMYK32 )Copy ()Image {return &CMYK32 {ImageBase :_dd .copy ()}};func (_cac *Monochrome )GrayAt (x ,y int )_c .Gray {_ebe ,_ :=ColorAtGray1BPC (x ,y ,_cac .BytesPerLine ,_cac .Data ,_cac .Decode );return _ebe ;};func (_bdfc *ImageBase )MakeAlpha (){_bdfc .newAlpha ()};func (_cba *Gray2 )ColorModel ()_c .Model {return Gray2Model };func _gcf (_ebd _c .NRGBA )_c .Gray {_ffc ,_fcf ,_ffbg ,_ :=_ebd .RGBA ();_deb :=(19595*_ffc +38470*_fcf +7471*_ffbg +1<<15)>>24;return _c .Gray {Y :uint8 (_deb )};};func (_cbgb *Gray8 )Base ()*ImageBase {return &_cbgb .ImageBase };func _cab (_ffce RGBA ,_bcgg NRGBA ,_dfaage _e .Rectangle ){for _gbgd :=0;_gbgd < _dfaage .Max .X ;_gbgd ++{for _fed :=0;_fed < _dfaage .Max .Y ;_fed ++{_fcdb :=_ffce .RGBAAt (_gbgd ,_fed );_bcgg .SetNRGBA (_gbgd ,_fed ,_efe (_fcdb ));};};};func (_cgb *Monochrome )setGray (_dae int ,_ebaa _c .Gray ,_adad int ){if _ebaa .Y ==0{_cgb .clearBit (_adad ,_dae );}else {_cgb .setBit (_adad ,_dae );};};func _gbfg (_adgc _c .Color )_c .Color {_dbdc :=_c .NRGBAModel .Convert (_adgc ).(_c .NRGBA );return _gda (_dbdc );};type ColorConverter interface{Convert (_gee _e .Image )(Image ,error );};func ColorAtNRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_c .NRGBA ,error ){_dbde :=y *width +x ;_ecg :=3*_dbde ;if _ecg +2>=len (data ){return _c .NRGBA {},_a .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_agb :=uint8 (0xff);if alpha !=nil &&len (alpha )> _dbde {_agb =alpha [_dbde ];};_fdg ,_cdea ,_fcgf :=data [_ecg ],data [_ecg +1],data [_ecg +2];if len (decode )==6{_fdg =uint8 (uint32 (LinearInterpolate (float64 (_fdg ),0,255,decode [0],decode [1]))&0xff);_cdea =uint8 (uint32 (LinearInterpolate (float64 (_cdea ),0,255,decode [2],decode [3]))&0xff);_fcgf =uint8 (uint32 (LinearInterpolate (float64 (_fcgf ),0,255,decode [4],decode [5]))&0xff);};return _c .NRGBA {R :_fdg ,G :_cdea ,B :_fcgf ,A :_agb },nil ;};func ColorAtNRGBA16 (x ,y ,width ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_c .NRGBA ,error ){_dbfg :=y *bytesPerLine +x *3/2;if _dbfg +1>=len (data ){return _c .NRGBA {},_ebaaa (x ,y );};const (_fgge =0xf;_dfga =uint8 (0xff););_bcde :=_dfga ;if alpha !=nil {_abdgf :=y *BytesPerLine (width ,4,1);if _abdgf < len (alpha ){if x %2==0{_bcde =(alpha [_abdgf ]>>uint (4))&_fgge ;}else {_bcde =alpha [_abdgf ]&_fgge ;};_bcde |=_bcde <<4;};};var _fbd ,_ceb ,_bbf uint8 ;if x *3%2==0{_fbd =(data [_dbfg ]>>uint (4))&_fgge ;_ceb =data [_dbfg ]&_fgge ;_bbf =(data [_dbfg +1]>>uint (4))&_fgge ;}else {_fbd =data [_dbfg ]&_fgge ;_ceb =(data [_dbfg +1]>>uint (4))&_fgge ;_bbf =data [_dbfg +1]&_fgge ;};if len (decode )==6{_fbd =uint8 (uint32 (LinearInterpolate (float64 (_fbd ),0,15,decode [0],decode [1]))&0xf);_ceb =uint8 (uint32 (LinearInterpolate (float64 (_ceb ),0,15,decode [2],decode [3]))&0xf);_bbf =uint8 (uint32 (LinearInterpolate (float64 (_bbf ),0,15,decode [4],decode [5]))&0xf);};return _c .NRGBA {R :(_fbd <<4)|(_fbd &0xf),G :(_ceb <<4)|(_ceb &0xf),B :(_bbf <<4)|(_bbf &0xf),A :_bcde },nil ;};func (_dfbf *Gray8 )Bounds ()_e .Rectangle {return _e .Rectangle {Max :_e .Point {X :_dfbf .Width ,Y :_dfbf .Height }};};func (_ddb *Gray4 )Base ()*ImageBase {return &_ddb .ImageBase };func (_degf *NRGBA32 )SetNRGBA (x ,y int ,c _c .NRGBA ){_gdd :=y *_degf .Width +x ;_efa :=3*_gdd ;if _efa +2>=len (_degf .Data ){return ;};_degf .setRGBA (_gdd ,c );};type NRGBA32 struct{ImageBase };func ConverterFunc (converterFunc func (_cc _e .Image )(Image ,error ))ColorConverter {return colorConverter {_bcd :converterFunc };};func (_aeg *ImageBase )HasAlpha ()bool {if _aeg .Alpha ==nil {return false ;};for _dad :=range _aeg .Alpha {if _aeg .Alpha [_dad ]!=0xff{return true ;};};return false ;};func (_bdfcd *NRGBA16 )Validate ()error {if len (_bdfcd .Data )!=3*_bdfcd .Width *_bdfcd .Height /2{return _db .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");};return nil ;};func (_abg *Gray2 )SetGray (x ,y int ,gray _c .Gray ){_bfecf :=_agd (gray );_debd :=y *_abg .BytesPerLine ;_agg :=_debd +(x >>2);if _agg >=len (_abg .Data ){return ;};_adc :=_bfecf .Y >>6;_abg .Data [_agg ]=(_abg .Data [_agg ]&(^(0xc0>>uint (2*((x )&3)))))|(_adc <<uint (6-2*(x &3)));};func (_bf *CMYK32 )CMYKAt (x ,y int )_c .CMYK {_dbc ,_ :=ColorAtCMYK (x ,y ,_bf .Width ,_bf .Data ,_bf .Decode );return _dbc ;};var _ _e .Image =&Gray8 {};func (_abb *Gray4 )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtGray4BPC (x ,y ,_abb .BytesPerLine ,_abb .Data ,_abb .Decode );};func ImgToBinary (i _e .Image ,threshold uint8 )*_e .Gray {switch _dgab :=i .(type ){case *_e .Gray :if _bffad (_dgab ){return _dgab ;};return _agga (_dgab ,threshold );case *_e .Gray16 :return _eged (_dgab ,threshold );default:return _dagg (_dgab ,threshold );};};type NRGBA64 struct{ImageBase };func _bcb (_bccg _c .CMYK )_c .Gray {_efd ,_ddc ,_bdc :=_c .CMYKToRGB (_bccg .C ,_bccg .M ,_bccg .Y ,_bccg .K );_aag :=(19595*uint32 (_efd )+38470*uint32 (_ddc )+7471*uint32 (_bdc )+1<<7)>>16;return _c .Gray {Y :uint8 (_aag )};};type CMYK32 struct{ImageBase };func IsGrayImgBlackAndWhite (i *_e .Gray )bool {return _bffad (i )};func _cad (_bfe _c .CMYK )_c .NRGBA {_ddae ,_ebde ,_cbe :=_c .CMYKToRGB (_bfe .C ,_bfe .M ,_bfe .Y ,_bfe .K );return _c .NRGBA {R :_ddae ,G :_ebde ,B :_cbe ,A :0xff};};func (_cdgb *NRGBA64 )Bounds ()_e .Rectangle {return _e .Rectangle {Max :_e .Point {X :_cdgb .Width ,Y :_cdgb .Height }};};func (_bbc *Gray2 )Set (x ,y int ,c _c .Color ){if x >=_bbc .Width ||y >=_bbc .Height {return ;};_ggd :=Gray2Model .Convert (c ).(_c .Gray );_ecd :=y *_bbc .BytesPerLine ;_fcd :=_ecd +(x >>2);_dfe :=_ggd .Y >>6;_bbc .Data [_fcd ]=(_bbc .Data [_fcd ]&(^(0xc0>>uint (2*((x )&3)))))|(_dfe <<uint (6-2*(x &3)));};func (_cbec *Gray4 )Copy ()Image {return &Gray4 {ImageBase :_cbec .copy ()}};func (_cde *NRGBA16 )setNRGBA (_cded ,_dcbg ,_aefdd int ,_aadg _c .NRGBA ){if _cded *3%2==0{_cde .Data [_aefdd ]=(_aadg .R >>4)<<4|(_aadg .G >>4);_cde .Data [_aefdd +1]=(_aadg .B >>4)<<4|(_cde .Data [_aefdd +1]&0xf);}else {_cde .Data [_aefdd ]=(_cde .Data [_aefdd ]&0xf0)|(_aadg .R >>4);_cde .Data [_aefdd +1]=(_aadg .G >>4)<<4|(_aadg .B >>4);};if _cde .Alpha !=nil {_cbeeb :=_dcbg *BytesPerLine (_cde .Width ,4,1);if _cbeeb < len (_cde .Alpha ){if _cded %2==0{_cde .Alpha [_cbeeb ]=(_aadg .A >>uint (4))<<uint (4)|(_cde .Alpha [_aefdd ]&0xf);}else {_cde .Alpha [_cbeeb ]=(_cde .Alpha [_cbeeb ]&0xf0)|(_aadg .A >>uint (4));};};};};var ErrInvalidImage =_db .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");func ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor int ,data ,alpha []byte ,decode []float64 )(_c .Color ,error ){switch bitsPerColor {case 4:return ColorAtNRGBA16 (x ,y ,width ,bytesPerLine ,data ,alpha ,decode );case 8:return ColorAtNRGBA32 (x ,y ,width ,data ,alpha ,decode );case 16:return ColorAtNRGBA64 (x ,y ,width ,data ,alpha ,decode );default:return nil ,_a .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0067\u0062\u0020b\u0069\u0074\u0073\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0061\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );};};type CMYK interface{CMYKAt (_dfb ,_fg int )_c .CMYK ;SetCMYK (_fd ,_ee int ,_ff _c .CMYK );};var _ _e .Image =&Gray4 {};func (_ddd *Monochrome )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtGray1BPC (x ,y ,_ddd .BytesPerLine ,_ddd .Data ,_ddd .Decode );};func (_dbge *NRGBA16 )NRGBAAt (x ,y int )_c .NRGBA {_ccbd ,_ :=ColorAtNRGBA16 (x ,y ,_dbge .Width ,_dbge .BytesPerLine ,_dbge .Data ,_dbge .Alpha ,_dbge .Decode );return _ccbd ;};func (_gdec *Gray4 )GrayAt (x ,y int )_c .Gray {_gab ,_ :=ColorAtGray4BPC (x ,y ,_gdec .BytesPerLine ,_gdec .Data ,_gdec .Decode );return _gab ;};func (_dade *NRGBA16 )SetNRGBA (x ,y int ,c _c .NRGBA ){_ccad :=y *_dade .BytesPerLine +x *3/2;if _ccad +1>=len (_dade .Data ){return ;};c =_gda (c );_dade .setNRGBA (x ,y ,_ccad ,c );};var _ Gray =&Gray16 {};func AddDataPadding (width ,height ,bitsPerComponent ,colorComponents int ,data []byte )([]byte ,error ){_gba :=BytesPerLine (width ,bitsPerComponent ,colorComponents );if _gba ==width *colorComponents *bitsPerComponent /8{return data ,nil ;};_eafe :=width *colorComponents *bitsPerComponent ;_bcdf :=_gba *8;_dcbf :=8-(_bcdf -_eafe );_aabb :=_df .NewReader (data );_cgcf :=_gba -1;_bfg :=make ([]byte ,_cgcf );_edfcf :=make ([]byte ,height *_gba );_dceec :=_df .NewWriterMSB (_edfcf );var _eef uint64 ;var _acdf error ;for _adfc :=0;_adfc < height ;_adfc ++{_ ,_acdf =_aabb .Read (_bfg );if _acdf !=nil {return nil ,_acdf ;};_ ,_acdf =_dceec .Write (_bfg );if _acdf !=nil {return nil ,_acdf ;};_eef ,_acdf =_aabb .ReadBits (byte (_dcbf ));if _acdf !=nil {return nil ,_acdf ;};_ ,_acdf =_dceec .WriteBits (_eef ,_dcbf );if _acdf !=nil {return nil ,_acdf ;};_dceec .FinishByte ();};return _edfcf ,nil ;};func (_ccb *Gray2 )Histogram ()(_dcdg [256]int ){for _abdg :=0;_abdg < _ccb .Width ;_abdg ++{for _gdg :=0;_gdg < _ccb .Height ;_gdg ++{_dcdg [_ccb .GrayAt (_abdg ,_gdg ).Y ]++;};};return _dcdg ;};func ColorAtNRGBA64 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_c .NRGBA64 ,error ){_efg :=(y *width +x )*2;_gcgd :=_efg *3;if _gcgd +5>=len (data ){return _c .NRGBA64 {},_a .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};const _gbb =0xffff;_afd :=uint16 (_gbb );if alpha !=nil &&len (alpha )> _efg +1{_afd =uint16 (alpha [_efg ])<<8|uint16 (alpha [_efg +1]);};_befe :=uint16 (data [_gcgd ])<<8|uint16 (data [_gcgd +1]);_gfc :=uint16 (data [_gcgd +2])<<8|uint16 (data [_gcgd +3]);_baff :=uint16 (data [_gcgd +4])<<8|uint16 (data [_gcgd +5]);if len (decode )==6{_befe =uint16 (uint64 (LinearInterpolate (float64 (_befe ),0,65535,decode [0],decode [1]))&_gbb );_gfc =uint16 (uint64 (LinearInterpolate (float64 (_gfc ),0,65535,decode [2],decode [3]))&_gbb );_baff =uint16 (uint64 (LinearInterpolate (float64 (_baff ),0,65535,decode [4],decode [5]))&_gbb );};return _c .NRGBA64 {R :_befe ,G :_gfc ,B :_baff ,A :_afd },nil ;};func _bffad (_gagd *_e .Gray )bool {for _bee :=0;_bee < len (_gagd .Pix );_bee ++{if !_aebce (_gagd .Pix [_bee ]){return false ;};};return true ;};func _bfbg (_eabb []byte ,_gbc Image )error {_bbbg :=true ;for _fddgb :=0;_fddgb < len (_eabb );_fddgb ++{if _eabb [_fddgb ]!=0xff{_bbbg =false ;break ;};};if _bbbg {switch _egde :=_gbc .(type ){case *NRGBA32 :_egde .Alpha =nil ;case *NRGBA64 :_egde .Alpha =nil ;default:return _a .Errorf ("i\u006ete\u0072n\u0061l\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020i\u006d\u0061\u0067\u0065\u0020s\u0068\u006f\u0075l\u0064\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0074\u0079\u0070e\u0020\u002a\u004eRGB\u0041\u0033\u0032\u0020\u006f\u0072 \u002a\u004e\u0052\u0047\u0042\u0041\u0036\u0034\u0020\u0062\u0075\u0074 \u0069s\u003a\u0020\u0025\u0054",_gbc );};};return nil ;};func (_dbd *Monochrome )Copy ()Image {return &Monochrome {ImageBase :_dbd .ImageBase .copy (),ModelThreshold :_dbd .ModelThreshold };};func (_ccbf *NRGBA16 )Bounds ()_e .Rectangle {return _e .Rectangle {Max :_e .Point {X :_ccbf .Width ,Y :_ccbf .Height }};};func (_dag *Monochrome )Set (x ,y int ,c _c .Color ){_eab :=y *_dag .BytesPerLine +x >>3;if _eab > len (_dag .Data )-1{return ;};_bged :=_dag .ColorModel ().Convert (c ).(_c .Gray );_dag .setGray (x ,_bged ,_eab );};func (_egc *Gray16 )At (x ,y int )_c .Color {_geb ,_ :=_egc .ColorAt (x ,y );return _geb };func _edf (_agf _c .NRGBA64 )_c .NRGBA {return _c .NRGBA {R :uint8 (_agf .R >>8),G :uint8 (_agf .G >>8),B :uint8 (_agf .B >>8),A :uint8 (_agf .A >>8)};};func _acc (_ba _c .RGBA )_c .Gray {_ad :=(19595*uint32 (_ba .R )+38470*uint32 (_ba .G )+7471*uint32 (_ba .B )+1<<7)>>16;return _c .Gray {Y :uint8 (_ad )};};func _feg (_dcg ,_fdf NRGBA ,_gdfb _e .Rectangle ){for _fbge :=0;_fbge < _gdfb .Max .X ;_fbge ++{for _gad :=0;_gad < _gdfb .Max .Y ;_gad ++{_fdf .SetNRGBA (_fbge ,_gad ,_dcg .NRGBAAt (_fbge ,_gad ));};};};func (_fb *Gray16 )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtGray16BPC (x ,y ,_fb .BytesPerLine ,_fb .Data ,_fb .Decode );};func NewImageBase (width int ,height int ,bitsPerComponent int ,colorComponents int ,data []byte ,alpha []byte ,decode []float64 )ImageBase {_eea :=ImageBase {Width :width ,Height :height ,BitsPerComponent :bitsPerComponent ,ColorComponents :colorComponents ,Data :data ,Alpha :alpha ,Decode :decode ,BytesPerLine :BytesPerLine (width ,bitsPerComponent ,colorComponents )};if data ==nil {_eea .Data =make ([]byte ,height *_eea .BytesPerLine );};return _eea ;};func _edcg (_ebea Gray ,_daeca NRGBA ,_eca _e .Rectangle ){for _beba :=0;_beba < _eca .Max .X ;_beba ++{for _cag :=0;_cag < _eca .Max .Y ;_cag ++{_dfcf :=_ebea .GrayAt (_beba ,_cag );_daeca .SetNRGBA (_beba ,_cag ,_acg (_dfcf ));};};};func (_bbca *Gray16 )Bounds ()_e .Rectangle {return _e .Rectangle {Max :_e .Point {X :_bbca .Width ,Y :_bbca .Height }};};type Gray8 struct{ImageBase };type Gray16 struct{ImageBase };func (_ece *NRGBA16 )ColorModel ()_c .Model {return NRGBA16Model };type Monochrome struct{ImageBase ;ModelThreshold uint8 ;};