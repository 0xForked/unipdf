//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package imageutil ;import (_b "encoding/binary";_c "errors";_ba "fmt";_ca "github.com/unidoc/unipdf/v3/common";_bag "github.com/unidoc/unipdf/v3/internal/bitwise";_ec "image";_d "image/color";_a "image/draw";_e "math";);func ColorAtGray8BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_d .Gray ,error ){_gbge :=y *bytesPerLine +x ;
if _gbge >=len (data ){return _d .Gray {},_ba .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_edcde :=data [_gbge ];if len (decode )==2{_edcde =uint8 (uint32 (LinearInterpolate (float64 (_edcde ),0,255,decode [0],decode [1]))&0xff);};return _d .Gray {Y :_edcde },nil ;};func _ceg (_ddgd *Monochrome ,_bdcb ,_ecgc ,_dfce ,_edbg int ,_dgb RasterOperator ,_cedc *Monochrome ,_gaab ,_abee int )error {var (_effb bool ;
_ecaa bool ;_edba int ;_faba int ;_cgbcg int ;_dgbf bool ;_efb byte ;_geba int ;_bdfa int ;_accg int ;_efeb ,_dcgd int ;);_abga :=8-(_bdcb &7);_dccd :=_eefb [_abga ];_acga :=_ddgd .BytesPerLine *_ecgc +(_bdcb >>3);_cdff :=_cedc .BytesPerLine *_abee +(_gaab >>3);
if _dfce < _abga {_effb =true ;_dccd &=_aaaa [8-_abga +_dfce ];};if !_effb {_edba =(_dfce -_abga )>>3;if _edba > 0{_ecaa =true ;_faba =_acga +1;_cgbcg =_cdff +1;};};_geba =(_bdcb +_dfce )&7;if !(_effb ||_geba ==0){_dgbf =true ;_efb =_aaaa [_geba ];_bdfa =_acga +1+_edba ;
_accg =_cdff +1+_edba ;};switch _dgb {case PixSrc :for _efeb =0;_efeb < _edbg ;_efeb ++{_ddgd .Data [_acga ]=_cdea (_ddgd .Data [_acga ],_cedc .Data [_cdff ],_dccd );_acga +=_ddgd .BytesPerLine ;_cdff +=_cedc .BytesPerLine ;};if _ecaa {for _efeb =0;_efeb < _edbg ;
_efeb ++{for _dcgd =0;_dcgd < _edba ;_dcgd ++{_ddgd .Data [_faba +_dcgd ]=_cedc .Data [_cgbcg +_dcgd ];};_faba +=_ddgd .BytesPerLine ;_cgbcg +=_cedc .BytesPerLine ;};};if _dgbf {for _efeb =0;_efeb < _edbg ;_efeb ++{_ddgd .Data [_bdfa ]=_cdea (_ddgd .Data [_bdfa ],_cedc .Data [_accg ],_efb );
_bdfa +=_ddgd .BytesPerLine ;_accg +=_cedc .BytesPerLine ;};};case PixNotSrc :for _efeb =0;_efeb < _edbg ;_efeb ++{_ddgd .Data [_acga ]=_cdea (_ddgd .Data [_acga ],^_cedc .Data [_cdff ],_dccd );_acga +=_ddgd .BytesPerLine ;_cdff +=_cedc .BytesPerLine ;
};if _ecaa {for _efeb =0;_efeb < _edbg ;_efeb ++{for _dcgd =0;_dcgd < _edba ;_dcgd ++{_ddgd .Data [_faba +_dcgd ]=^_cedc .Data [_cgbcg +_dcgd ];};_faba +=_ddgd .BytesPerLine ;_cgbcg +=_cedc .BytesPerLine ;};};if _dgbf {for _efeb =0;_efeb < _edbg ;_efeb ++{_ddgd .Data [_bdfa ]=_cdea (_ddgd .Data [_bdfa ],^_cedc .Data [_accg ],_efb );
_bdfa +=_ddgd .BytesPerLine ;_accg +=_cedc .BytesPerLine ;};};case PixSrcOrDst :for _efeb =0;_efeb < _edbg ;_efeb ++{_ddgd .Data [_acga ]=_cdea (_ddgd .Data [_acga ],_cedc .Data [_cdff ]|_ddgd .Data [_acga ],_dccd );_acga +=_ddgd .BytesPerLine ;_cdff +=_cedc .BytesPerLine ;
};if _ecaa {for _efeb =0;_efeb < _edbg ;_efeb ++{for _dcgd =0;_dcgd < _edba ;_dcgd ++{_ddgd .Data [_faba +_dcgd ]|=_cedc .Data [_cgbcg +_dcgd ];};_faba +=_ddgd .BytesPerLine ;_cgbcg +=_cedc .BytesPerLine ;};};if _dgbf {for _efeb =0;_efeb < _edbg ;_efeb ++{_ddgd .Data [_bdfa ]=_cdea (_ddgd .Data [_bdfa ],_cedc .Data [_accg ]|_ddgd .Data [_bdfa ],_efb );
_bdfa +=_ddgd .BytesPerLine ;_accg +=_cedc .BytesPerLine ;};};case PixSrcAndDst :for _efeb =0;_efeb < _edbg ;_efeb ++{_ddgd .Data [_acga ]=_cdea (_ddgd .Data [_acga ],_cedc .Data [_cdff ]&_ddgd .Data [_acga ],_dccd );_acga +=_ddgd .BytesPerLine ;_cdff +=_cedc .BytesPerLine ;
};if _ecaa {for _efeb =0;_efeb < _edbg ;_efeb ++{for _dcgd =0;_dcgd < _edba ;_dcgd ++{_ddgd .Data [_faba +_dcgd ]&=_cedc .Data [_cgbcg +_dcgd ];};_faba +=_ddgd .BytesPerLine ;_cgbcg +=_cedc .BytesPerLine ;};};if _dgbf {for _efeb =0;_efeb < _edbg ;_efeb ++{_ddgd .Data [_bdfa ]=_cdea (_ddgd .Data [_bdfa ],_cedc .Data [_accg ]&_ddgd .Data [_bdfa ],_efb );
_bdfa +=_ddgd .BytesPerLine ;_accg +=_cedc .BytesPerLine ;};};case PixSrcXorDst :for _efeb =0;_efeb < _edbg ;_efeb ++{_ddgd .Data [_acga ]=_cdea (_ddgd .Data [_acga ],_cedc .Data [_cdff ]^_ddgd .Data [_acga ],_dccd );_acga +=_ddgd .BytesPerLine ;_cdff +=_cedc .BytesPerLine ;
};if _ecaa {for _efeb =0;_efeb < _edbg ;_efeb ++{for _dcgd =0;_dcgd < _edba ;_dcgd ++{_ddgd .Data [_faba +_dcgd ]^=_cedc .Data [_cgbcg +_dcgd ];};_faba +=_ddgd .BytesPerLine ;_cgbcg +=_cedc .BytesPerLine ;};};if _dgbf {for _efeb =0;_efeb < _edbg ;_efeb ++{_ddgd .Data [_bdfa ]=_cdea (_ddgd .Data [_bdfa ],_cedc .Data [_accg ]^_ddgd .Data [_bdfa ],_efb );
_bdfa +=_ddgd .BytesPerLine ;_accg +=_cedc .BytesPerLine ;};};case PixNotSrcOrDst :for _efeb =0;_efeb < _edbg ;_efeb ++{_ddgd .Data [_acga ]=_cdea (_ddgd .Data [_acga ],^(_cedc .Data [_cdff ])|_ddgd .Data [_acga ],_dccd );_acga +=_ddgd .BytesPerLine ;_cdff +=_cedc .BytesPerLine ;
};if _ecaa {for _efeb =0;_efeb < _edbg ;_efeb ++{for _dcgd =0;_dcgd < _edba ;_dcgd ++{_ddgd .Data [_faba +_dcgd ]|=^(_cedc .Data [_cgbcg +_dcgd ]);};_faba +=_ddgd .BytesPerLine ;_cgbcg +=_cedc .BytesPerLine ;};};if _dgbf {for _efeb =0;_efeb < _edbg ;_efeb ++{_ddgd .Data [_bdfa ]=_cdea (_ddgd .Data [_bdfa ],^(_cedc .Data [_accg ])|_ddgd .Data [_bdfa ],_efb );
_bdfa +=_ddgd .BytesPerLine ;_accg +=_cedc .BytesPerLine ;};};case PixNotSrcAndDst :for _efeb =0;_efeb < _edbg ;_efeb ++{_ddgd .Data [_acga ]=_cdea (_ddgd .Data [_acga ],^(_cedc .Data [_cdff ])&_ddgd .Data [_acga ],_dccd );_acga +=_ddgd .BytesPerLine ;
_cdff +=_cedc .BytesPerLine ;};if _ecaa {for _efeb =0;_efeb < _edbg ;_efeb ++{for _dcgd =0;_dcgd < _edba ;_dcgd ++{_ddgd .Data [_faba +_dcgd ]&=^_cedc .Data [_cgbcg +_dcgd ];};_faba +=_ddgd .BytesPerLine ;_cgbcg +=_cedc .BytesPerLine ;};};if _dgbf {for _efeb =0;
_efeb < _edbg ;_efeb ++{_ddgd .Data [_bdfa ]=_cdea (_ddgd .Data [_bdfa ],^(_cedc .Data [_accg ])&_ddgd .Data [_bdfa ],_efb );_bdfa +=_ddgd .BytesPerLine ;_accg +=_cedc .BytesPerLine ;};};case PixSrcOrNotDst :for _efeb =0;_efeb < _edbg ;_efeb ++{_ddgd .Data [_acga ]=_cdea (_ddgd .Data [_acga ],_cedc .Data [_cdff ]|^(_ddgd .Data [_acga ]),_dccd );
_acga +=_ddgd .BytesPerLine ;_cdff +=_cedc .BytesPerLine ;};if _ecaa {for _efeb =0;_efeb < _edbg ;_efeb ++{for _dcgd =0;_dcgd < _edba ;_dcgd ++{_ddgd .Data [_faba +_dcgd ]=_cedc .Data [_cgbcg +_dcgd ]|^(_ddgd .Data [_faba +_dcgd ]);};_faba +=_ddgd .BytesPerLine ;
_cgbcg +=_cedc .BytesPerLine ;};};if _dgbf {for _efeb =0;_efeb < _edbg ;_efeb ++{_ddgd .Data [_bdfa ]=_cdea (_ddgd .Data [_bdfa ],_cedc .Data [_accg ]|^(_ddgd .Data [_bdfa ]),_efb );_bdfa +=_ddgd .BytesPerLine ;_accg +=_cedc .BytesPerLine ;};};case PixSrcAndNotDst :for _efeb =0;
_efeb < _edbg ;_efeb ++{_ddgd .Data [_acga ]=_cdea (_ddgd .Data [_acga ],_cedc .Data [_cdff ]&^(_ddgd .Data [_acga ]),_dccd );_acga +=_ddgd .BytesPerLine ;_cdff +=_cedc .BytesPerLine ;};if _ecaa {for _efeb =0;_efeb < _edbg ;_efeb ++{for _dcgd =0;_dcgd < _edba ;
_dcgd ++{_ddgd .Data [_faba +_dcgd ]=_cedc .Data [_cgbcg +_dcgd ]&^(_ddgd .Data [_faba +_dcgd ]);};_faba +=_ddgd .BytesPerLine ;_cgbcg +=_cedc .BytesPerLine ;};};if _dgbf {for _efeb =0;_efeb < _edbg ;_efeb ++{_ddgd .Data [_bdfa ]=_cdea (_ddgd .Data [_bdfa ],_cedc .Data [_accg ]&^(_ddgd .Data [_bdfa ]),_efb );
_bdfa +=_ddgd .BytesPerLine ;_accg +=_cedc .BytesPerLine ;};};case PixNotPixSrcOrDst :for _efeb =0;_efeb < _edbg ;_efeb ++{_ddgd .Data [_acga ]=_cdea (_ddgd .Data [_acga ],^(_cedc .Data [_cdff ]|_ddgd .Data [_acga ]),_dccd );_acga +=_ddgd .BytesPerLine ;
_cdff +=_cedc .BytesPerLine ;};if _ecaa {for _efeb =0;_efeb < _edbg ;_efeb ++{for _dcgd =0;_dcgd < _edba ;_dcgd ++{_ddgd .Data [_faba +_dcgd ]=^(_cedc .Data [_cgbcg +_dcgd ]|_ddgd .Data [_faba +_dcgd ]);};_faba +=_ddgd .BytesPerLine ;_cgbcg +=_cedc .BytesPerLine ;
};};if _dgbf {for _efeb =0;_efeb < _edbg ;_efeb ++{_ddgd .Data [_bdfa ]=_cdea (_ddgd .Data [_bdfa ],^(_cedc .Data [_accg ]|_ddgd .Data [_bdfa ]),_efb );_bdfa +=_ddgd .BytesPerLine ;_accg +=_cedc .BytesPerLine ;};};case PixNotPixSrcAndDst :for _efeb =0;
_efeb < _edbg ;_efeb ++{_ddgd .Data [_acga ]=_cdea (_ddgd .Data [_acga ],^(_cedc .Data [_cdff ]&_ddgd .Data [_acga ]),_dccd );_acga +=_ddgd .BytesPerLine ;_cdff +=_cedc .BytesPerLine ;};if _ecaa {for _efeb =0;_efeb < _edbg ;_efeb ++{for _dcgd =0;_dcgd < _edba ;
_dcgd ++{_ddgd .Data [_faba +_dcgd ]=^(_cedc .Data [_cgbcg +_dcgd ]&_ddgd .Data [_faba +_dcgd ]);};_faba +=_ddgd .BytesPerLine ;_cgbcg +=_cedc .BytesPerLine ;};};if _dgbf {for _efeb =0;_efeb < _edbg ;_efeb ++{_ddgd .Data [_bdfa ]=_cdea (_ddgd .Data [_bdfa ],^(_cedc .Data [_accg ]&_ddgd .Data [_bdfa ]),_efb );
_bdfa +=_ddgd .BytesPerLine ;_accg +=_cedc .BytesPerLine ;};};case PixNotPixSrcXorDst :for _efeb =0;_efeb < _edbg ;_efeb ++{_ddgd .Data [_acga ]=_cdea (_ddgd .Data [_acga ],^(_cedc .Data [_cdff ]^_ddgd .Data [_acga ]),_dccd );_acga +=_ddgd .BytesPerLine ;
_cdff +=_cedc .BytesPerLine ;};if _ecaa {for _efeb =0;_efeb < _edbg ;_efeb ++{for _dcgd =0;_dcgd < _edba ;_dcgd ++{_ddgd .Data [_faba +_dcgd ]=^(_cedc .Data [_cgbcg +_dcgd ]^_ddgd .Data [_faba +_dcgd ]);};_faba +=_ddgd .BytesPerLine ;_cgbcg +=_cedc .BytesPerLine ;
};};if _dgbf {for _efeb =0;_efeb < _edbg ;_efeb ++{_ddgd .Data [_bdfa ]=_cdea (_ddgd .Data [_bdfa ],^(_cedc .Data [_accg ]^_ddgd .Data [_bdfa ]),_efb );_bdfa +=_ddgd .BytesPerLine ;_accg +=_cedc .BytesPerLine ;};};default:_ca .Log .Debug ("I\u006e\u0076\u0061\u006c\u0069\u0064 \u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070e\u0072\u0061\u0074o\u0072:\u0020\u0025\u0064",_dgb );
return _c .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072");};return nil ;};func (_gbda *NRGBA16 )ColorAt (x ,y int )(_d .Color ,error ){return ColorAtNRGBA16 (x ,y ,_gbda .Width ,_gbda .BytesPerLine ,_gbda .Data ,_gbda .Alpha ,_gbda .Decode );
};type CMYK32 struct{ImageBase };func _cdca (_cca _d .NYCbCrA )_d .RGBA {_dbeg ,_fba ,_edg ,_dabf :=_eage (_cca ).RGBA ();return _d .RGBA {R :uint8 (_dbeg >>8),G :uint8 (_fba >>8),B :uint8 (_edg >>8),A :uint8 (_dabf >>8)};};func (_eec *Gray4 )GrayAt (x ,y int )_d .Gray {_egbae ,_ :=ColorAtGray4BPC (x ,y ,_eec .BytesPerLine ,_eec .Data ,_eec .Decode );
return _egbae ;};type ColorConverter interface{Convert (_cabf _ec .Image )(Image ,error );};func (_bacdc *NRGBA16 )setNRGBA (_eddb ,_aega ,_abgab int ,_fgef _d .NRGBA ){if _eddb *3%2==0{_bacdc .Data [_abgab ]=(_fgef .R >>4)<<4|(_fgef .G >>4);_bacdc .Data [_abgab +1]=(_fgef .B >>4)<<4|(_bacdc .Data [_abgab +1]&0xf);
}else {_bacdc .Data [_abgab ]=(_bacdc .Data [_abgab ]&0xf0)|(_fgef .R >>4);_bacdc .Data [_abgab +1]=(_fgef .G >>4)<<4|(_fgef .B >>4);};if _bacdc .Alpha !=nil {_abgabc :=_aega *BytesPerLine (_bacdc .Width ,4,1);if _abgabc < len (_bacdc .Alpha ){if _eddb %2==0{_bacdc .Alpha [_abgabc ]=(_fgef .A >>uint (4))<<uint (4)|(_bacdc .Alpha [_abgab ]&0xf);
}else {_bacdc .Alpha [_abgabc ]=(_bacdc .Alpha [_abgabc ]&0xf0)|(_fgef .A >>uint (4));};};};};func (_ege *CMYK32 )CMYKAt (x ,y int )_d .CMYK {_fbfa ,_ :=ColorAtCMYK (x ,y ,_ege .Width ,_ege .Data ,_ege .Decode );return _fbfa ;};func _eefg (_ceeg nrgba64 ,_gfeed RGBA ,_feacb _ec .Rectangle ){for _dddcc :=0;
_dddcc < _feacb .Max .X ;_dddcc ++{for _fgee :=0;_fgee < _feacb .Max .Y ;_fgee ++{_fbea :=_ceeg .NRGBA64At (_dddcc ,_fgee );_gfeed .SetRGBA (_dddcc ,_fgee ,_ddb (_fbea ));};};};func _bcbe (_daba *Monochrome ,_aeba ,_cedbg ,_agbbe ,_aabb int ,_adccd RasterOperator ,_gagb *Monochrome ,_bbfe ,_bdcf int )error {if _daba ==nil {return _c .New ("\u006e\u0069\u006c\u0020\u0027\u0064\u0065\u0073\u0074\u0027\u0020\u0042i\u0074\u006d\u0061\u0070");
};if _adccd ==PixDst {return nil ;};switch _adccd {case PixClr ,PixSet ,PixNotDst :_dgad (_daba ,_aeba ,_cedbg ,_agbbe ,_aabb ,_adccd );return nil ;};if _gagb ==nil {_ca .Log .Debug ("\u0052a\u0073\u0074e\u0072\u004f\u0070\u0065r\u0061\u0074\u0069o\u006e\u0020\u0073\u006f\u0075\u0072\u0063\u0065\u0020bi\u0074\u006d\u0061p\u0020\u0069s\u0020\u006e\u006f\u0074\u0020\u0064e\u0066\u0069n\u0065\u0064");
return _c .New ("\u006e\u0069l\u0020\u0027\u0073r\u0063\u0027\u0020\u0062\u0069\u0074\u006d\u0061\u0070");};if _bbb :=_gcgd (_daba ,_aeba ,_cedbg ,_agbbe ,_aabb ,_adccd ,_gagb ,_bbfe ,_bdcf );_bbb !=nil {return _bbb ;};return nil ;};func (_bgfea *NRGBA64 )Validate ()error {if len (_bgfea .Data )!=3*2*_bgfea .Width *_bgfea .Height {return _c .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func (_fdbf colorConverter )Convert (src _ec .Image )(Image ,error ){return _fdbf ._dcbg (src )};func _fcbc (_fbcc _ec .Image )(Image ,error ){if _adfg ,_gcab :=_fbcc .(*Monochrome );_gcab {return _adfg ,nil ;};_cac :=_fbcc .Bounds ();var _ebgf Gray ;
switch _beg :=_fbcc .(type ){case Gray :_ebgf =_beg ;case NRGBA :_ebgf =&Gray8 {ImageBase :NewImageBase (_cac .Max .X ,_cac .Max .Y ,8,1,nil ,nil ,nil )};_fcd (_ebgf ,_beg ,_cac );case nrgba64 :_ebgf =&Gray8 {ImageBase :NewImageBase (_cac .Max .X ,_cac .Max .Y ,8,1,nil ,nil ,nil )};
_dec (_ebgf ,_beg ,_cac );default:_gefa ,_edcb :=GrayConverter .Convert (_fbcc );if _edcb !=nil {return nil ,_edcb ;};_ebgf =_gefa .(Gray );};_feg ,_eeeg :=NewImage (_cac .Max .X ,_cac .Max .Y ,1,1,nil ,nil ,nil );if _eeeg !=nil {return nil ,_eeeg ;};_beaf :=_feg .(*Monochrome );
_aeaf :=AutoThresholdTriangle (GrayHistogram (_ebgf ));for _edd :=0;_edd < _cac .Max .X ;_edd ++{for _cfcg :=0;_cfcg < _cac .Max .Y ;_cfcg ++{_ddf :=_fgea (_ebgf .GrayAt (_edd ,_cfcg ),monochromeModel (_aeaf ));_beaf .SetGray (_edd ,_cfcg ,_ddf );};};return _feg ,nil ;
};func (_fbcb *CMYK32 )ColorModel ()_d .Model {return _d .CMYKModel };var ErrInvalidImage =_c .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
func _gcgd (_cgca *Monochrome ,_fced ,_eeaba int ,_cce ,_gcfa int ,_dgg RasterOperator ,_gdcd *Monochrome ,_dbac ,_gdfg int )error {var _edfe ,_edac ,_gegf ,_afagd int ;if _fced < 0{_dbac -=_fced ;_cce +=_fced ;_fced =0;};if _dbac < 0{_fced -=_dbac ;_cce +=_dbac ;
_dbac =0;};_edfe =_fced +_cce -_cgca .Width ;if _edfe > 0{_cce -=_edfe ;};_edac =_dbac +_cce -_gdcd .Width ;if _edac > 0{_cce -=_edac ;};if _eeaba < 0{_gdfg -=_eeaba ;_gcfa +=_eeaba ;_eeaba =0;};if _gdfg < 0{_eeaba -=_gdfg ;_gcfa +=_gdfg ;_gdfg =0;};_gegf =_eeaba +_gcfa -_cgca .Height ;
if _gegf > 0{_gcfa -=_gegf ;};_afagd =_gdfg +_gcfa -_gdcd .Height ;if _afagd > 0{_gcfa -=_afagd ;};if _cce <=0||_gcfa <=0{return nil ;};var _gdca error ;switch {case _fced &7==0&&_dbac &7==0:_gdca =_cbfc (_cgca ,_fced ,_eeaba ,_cce ,_gcfa ,_dgg ,_gdcd ,_dbac ,_gdfg );
case _fced &7==_dbac &7:_gdca =_ceg (_cgca ,_fced ,_eeaba ,_cce ,_gcfa ,_dgg ,_gdcd ,_dbac ,_gdfg );default:_gdca =_ecgae (_cgca ,_fced ,_eeaba ,_cce ,_gcfa ,_dgg ,_gdcd ,_dbac ,_gdfg );};if _gdca !=nil {return _gdca ;};return nil ;};func _gfabf (_cgbcgg *_ec .NYCbCrA ,_bge RGBA ,_faabf _ec .Rectangle ){for _dabfa :=0;
_dabfa < _faabf .Max .X ;_dabfa ++{for _ccaeg :=0;_ccaeg < _faabf .Max .Y ;_ccaeg ++{_cegc :=_cgbcgg .NYCbCrAAt (_dabfa ,_ccaeg );_bge .SetRGBA (_dabfa ,_ccaeg ,_cdca (_cegc ));};};};func _ddb (_fcbb _d .NRGBA64 )_d .RGBA {_abba ,_cede ,_bcdf ,_gcf :=_fcbb .RGBA ();
return _d .RGBA {R :uint8 (_abba >>8),G :uint8 (_cede >>8),B :uint8 (_bcdf >>8),A :uint8 (_gcf >>8)};};func _feed (_cdda RGBA ,_dbe CMYK ,_aee _ec .Rectangle ){for _ead :=0;_ead < _aee .Max .X ;_ead ++{for _bcec :=0;_bcec < _aee .Max .Y ;_bcec ++{_caa :=_cdda .RGBAAt (_ead ,_bcec );
_dbe .SetCMYK (_ead ,_bcec ,_fbdd (_caa ));};};};var _ NRGBA =&NRGBA16 {};func (_gbgf *NRGBA16 )Bounds ()_ec .Rectangle {return _ec .Rectangle {Max :_ec .Point {X :_gbgf .Width ,Y :_gbgf .Height }};};func (_fdggg *NRGBA64 )Bounds ()_ec .Rectangle {return _ec .Rectangle {Max :_ec .Point {X :_fdggg .Width ,Y :_fdggg .Height }};
};func _fbdd (_gbf _d .RGBA )_d .CMYK {_dae ,_gdbf ,_bea ,_fdeg :=_d .RGBToCMYK (_gbf .R ,_gbf .G ,_gbf .B );return _d .CMYK {C :_dae ,M :_gdbf ,Y :_bea ,K :_fdeg };};func (_egd *Gray4 )Histogram ()(_dga [256]int ){for _caac :=0;_caac < _egd .Width ;_caac ++{for _dffa :=0;
_dffa < _egd .Height ;_dffa ++{_dga [_egd .GrayAt (_caac ,_dffa ).Y ]++;};};return _dga ;};var _ Image =&Monochrome {};func (_gegg *ImageBase )MakeAlpha (){_gegg .newAlpha ()};func _gdbd (_cdec ,_eeab CMYK ,_aegg _ec .Rectangle ){for _dfcb :=0;_dfcb < _aegg .Max .X ;
_dfcb ++{for _gbg :=0;_gbg < _aegg .Max .Y ;_gbg ++{_eeab .SetCMYK (_dfcb ,_gbg ,_cdec .CMYKAt (_dfcb ,_gbg ));};};};func (_feaa *Monochrome )setIndexedBit (_cddac int ){_feaa .Data [(_cddac >>3)]|=0x80>>uint (_cddac &7);};func (_bgae *Gray4 )At (x ,y int )_d .Color {_fbb ,_ :=_bgae .ColorAt (x ,y );
return _fbb };func (_egaa *monochromeThresholdConverter )Convert (img _ec .Image )(Image ,error ){if _aedg ,_acg :=img .(*Monochrome );_acg {return _aedg .Copy (),nil ;};_fgfd :=img .Bounds ();_bbdc ,_adab :=NewImage (_fgfd .Max .X ,_fgfd .Max .Y ,1,1,nil ,nil ,nil );
if _adab !=nil {return nil ,_adab ;};_bbdc .(*Monochrome ).ModelThreshold =_egaa .Threshold ;for _decg :=0;_decg < _fgfd .Max .X ;_decg ++{for _ccad :=0;_ccad < _fgfd .Max .Y ;_ccad ++{_eedd :=img .At (_decg ,_ccad );_bbdc .Set (_decg ,_ccad ,_eedd );};
};return _bbdc ,nil ;};func (_afe *ImageBase )Pix ()[]byte {return _afe .Data };func _bfgg (){for _ffca :=0;_ffca < 256;_ffca ++{_ebdg [_ffca ]=uint8 (_ffca &0x1)+(uint8 (_ffca >>1)&0x1)+(uint8 (_ffca >>2)&0x1)+(uint8 (_ffca >>3)&0x1)+(uint8 (_ffca >>4)&0x1)+(uint8 (_ffca >>5)&0x1)+(uint8 (_ffca >>6)&0x1)+(uint8 (_ffca >>7)&0x1);
};};func (_gfee *Gray8 )Set (x ,y int ,c _d .Color ){_cefg :=y *_gfee .BytesPerLine +x ;if _cefg > len (_gfee .Data )-1{return ;};_bcgf :=_d .GrayModel .Convert (c );_gfee .Data [_cefg ]=_bcgf .(_d .Gray ).Y ;};func _bc ()(_ccd [256]uint32 ){for _afc :=0;
_afc < 256;_afc ++{if _afc &0x01!=0{_ccd [_afc ]|=0xf;};if _afc &0x02!=0{_ccd [_afc ]|=0xf0;};if _afc &0x04!=0{_ccd [_afc ]|=0xf00;};if _afc &0x08!=0{_ccd [_afc ]|=0xf000;};if _afc &0x10!=0{_ccd [_afc ]|=0xf0000;};if _afc &0x20!=0{_ccd [_afc ]|=0xf00000;
};if _afc &0x40!=0{_ccd [_afc ]|=0xf000000;};if _afc &0x80!=0{_ccd [_afc ]|=0xf0000000;};};return _ccd ;};type ImageBase struct{Width ,Height int ;BitsPerComponent ,ColorComponents int ;Data ,Alpha []byte ;Decode []float64 ;BytesPerLine int ;};func _cdea (_ecfa ,_adga ,_fbge byte )byte {return (_ecfa &^(_fbge ))|(_adga &_fbge )};
var _ Gray =&Gray8 {};func (_efad *NRGBA32 )Validate ()error {if len (_efad .Data )!=3*_efad .Width *_efad .Height {return _c .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func (_dfaa *ImageBase )getByte (_fcac int )(byte ,error ){if _fcac > len (_dfaa .Data )-1||_fcac < 0{return 0,_ba .Errorf ("\u0069\u006e\u0064\u0065x:\u0020\u0025\u0064\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006eg\u0065",_fcac );
};return _dfaa .Data [_fcac ],nil ;};var _ _ec .Image =&Gray4 {};func (_dccb *Monochrome )RasterOperation (dx ,dy ,dw ,dh int ,op RasterOperator ,src *Monochrome ,sx ,sy int )error {return _bcbe (_dccb ,dx ,dy ,dw ,dh ,op ,src ,sx ,sy );};var _ _ec .Image =&NRGBA32 {};
func _dcga (_gdg _d .Gray )_d .Gray {_ddgc :=_gdg .Y >>6;_ddgc |=_ddgc <<2;_gdg .Y =_ddgc |_ddgc <<4;return _gdg ;};type SMasker interface{HasAlpha ()bool ;GetAlpha ()[]byte ;MakeAlpha ();};func ColorAtNRGBA16 (x ,y ,width ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_d .NRGBA ,error ){_cacb :=y *bytesPerLine +x *3/2;
if _cacb +1>=len (data ){return _d .NRGBA {},_abf (x ,y );};const (_ccda =0xf;_edga =uint8 (0xff););_gaea :=_edga ;if alpha !=nil {_gfbdc :=y *BytesPerLine (width ,4,1);if _gfbdc < len (alpha ){if x %2==0{_gaea =(alpha [_gfbdc ]>>uint (4))&_ccda ;}else {_gaea =alpha [_gfbdc ]&_ccda ;
};_gaea |=_gaea <<4;};};var _fcadb ,_bgfc ,_cbfd uint8 ;if x *3%2==0{_fcadb =(data [_cacb ]>>uint (4))&_ccda ;_bgfc =data [_cacb ]&_ccda ;_cbfd =(data [_cacb +1]>>uint (4))&_ccda ;}else {_fcadb =data [_cacb ]&_ccda ;_bgfc =(data [_cacb +1]>>uint (4))&_ccda ;
_cbfd =data [_cacb +1]&_ccda ;};if len (decode )==6{_fcadb =uint8 (uint32 (LinearInterpolate (float64 (_fcadb ),0,15,decode [0],decode [1]))&0xf);_bgfc =uint8 (uint32 (LinearInterpolate (float64 (_bgfc ),0,15,decode [2],decode [3]))&0xf);_cbfd =uint8 (uint32 (LinearInterpolate (float64 (_cbfd ),0,15,decode [4],decode [5]))&0xf);
};return _d .NRGBA {R :(_fcadb <<4)|(_fcadb &0xf),G :(_bgfc <<4)|(_bgfc &0xf),B :(_cbfd <<4)|(_cbfd &0xf),A :_gaea },nil ;};func (_eef *Gray16 )Bounds ()_ec .Rectangle {return _ec .Rectangle {Max :_ec .Point {X :_eef .Width ,Y :_eef .Height }};};var _ Gray =&Gray2 {};
func _cgeb (_geeg CMYK ,_aadaf RGBA ,_deaf _ec .Rectangle ){for _fgfc :=0;_fgfc < _deaf .Max .X ;_fgfc ++{for _aaaf :=0;_aaaf < _deaf .Max .Y ;_aaaf ++{_bbab :=_geeg .CMYKAt (_fgfc ,_aaaf );_aadaf .SetRGBA (_fgfc ,_aaaf ,_cdfg (_bbab ));};};};func (_bef *NRGBA16 )At (x ,y int )_d .Color {_ebbb ,_ :=_bef .ColorAt (x ,y );
return _ebbb };func _age (_bd *Monochrome ,_ggbc ,_ef int )(*Monochrome ,error ){if _bd ==nil {return nil ,_c .New ("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064");};if _ggbc <=0||_ef <=0{return nil ,_c .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0073\u0063\u0061l\u0065\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020<\u003d\u0020\u0030");
};if _ggbc ==_ef {if _ggbc ==1{return _bd .copy (),nil ;};if _ggbc ==2||_ggbc ==4||_ggbc ==8{_gdf ,_bfa :=_ee (_bd ,_ggbc );if _bfa !=nil {return nil ,_bfa ;};return _gdf ,nil ;};};_aef :=_ggbc *_bd .Width ;_gcg :=_ef *_bd .Height ;_ga :=_cga (_aef ,_gcg );
_dgcf :=_ga .BytesPerLine ;var (_ega ,_aba ,_agd ,_gb ,_aefd int ;_cg byte ;_ddc error ;);for _aba =0;_aba < _bd .Height ;_aba ++{_ega =_ef *_aba *_dgcf ;for _agd =0;_agd < _bd .Width ;_agd ++{if _bfd :=_bd .getBitAt (_agd ,_aba );_bfd {_aefd =_ggbc *_agd ;
for _gb =0;_gb < _ggbc ;_gb ++{_ga .setIndexedBit (_ega *8+_aefd +_gb );};};};for _gb =1;_gb < _ef ;_gb ++{_cbb :=_ega +_gb *_dgcf ;for _baa :=0;_baa < _dgcf ;_baa ++{if _cg ,_ddc =_ga .getByte (_ega +_baa );_ddc !=nil {return nil ,_ddc ;};if _ddc =_ga .setByte (_cbb +_baa ,_cg );
_ddc !=nil {return nil ,_ddc ;};};};};return _ga ,nil ;};func _faf (_cae ,_cgb *Monochrome ,_cfaf []byte ,_bfgf int )(_ed error ){var (_gcga ,_gdb ,_dded ,_fbca ,_ddeg ,_efa ,_edb ,_fbf int ;_fac ,_fdedf ,_cfe ,_bdc uint32 ;_gfa ,_afaf byte ;_aecg uint16 ;
);_cbc :=make ([]byte ,4);_dcfb :=make ([]byte ,4);for _dded =0;_dded < _cae .Height -1;_dded ,_fbca =_dded +2,_fbca +1{_gcga =_dded *_cae .BytesPerLine ;_gdb =_fbca *_cgb .BytesPerLine ;for _ddeg ,_efa =0,0;_ddeg < _bfgf ;_ddeg ,_efa =_ddeg +4,_efa +1{for _edb =0;
_edb < 4;_edb ++{_fbf =_gcga +_ddeg +_edb ;if _fbf <=len (_cae .Data )-1&&_fbf < _gcga +_cae .BytesPerLine {_cbc [_edb ]=_cae .Data [_fbf ];}else {_cbc [_edb ]=0x00;};_fbf =_gcga +_cae .BytesPerLine +_ddeg +_edb ;if _fbf <=len (_cae .Data )-1&&_fbf < _gcga +(2*_cae .BytesPerLine ){_dcfb [_edb ]=_cae .Data [_fbf ];
}else {_dcfb [_edb ]=0x00;};};_fac =_b .BigEndian .Uint32 (_cbc );_fdedf =_b .BigEndian .Uint32 (_dcfb );_cfe =_fac &_fdedf ;_cfe |=_cfe <<1;_bdc =_fac |_fdedf ;_bdc &=_bdc <<1;_fdedf =_cfe &_bdc ;_fdedf &=0xaaaaaaaa;_fac =_fdedf |(_fdedf <<7);_gfa =byte (_fac >>24);
_afaf =byte ((_fac >>8)&0xff);_fbf =_gdb +_efa ;if _fbf +1==len (_cgb .Data )-1||_fbf +1>=_gdb +_cgb .BytesPerLine {if _ed =_cgb .setByte (_fbf ,_cfaf [_gfa ]);_ed !=nil {return _ba .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_fbf );};}else {_aecg =(uint16 (_cfaf [_gfa ])<<8)|uint16 (_cfaf [_afaf ]);
if _ed =_cgb .setTwoBytes (_fbf ,_aecg );_ed !=nil {return _ba .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_fbf );
};_efa ++;};};};return nil ;};func (_agfdg *NRGBA16 )Copy ()Image {return &NRGBA16 {ImageBase :_agfdg .copy ()}};func MonochromeModel (threshold uint8 )_d .Model {return monochromeModel (threshold )};func (_cbf *Gray8 )ColorAt (x ,y int )(_d .Color ,error ){return ColorAtGray8BPC (x ,y ,_cbf .BytesPerLine ,_cbf .Data ,_cbf .Decode );
};func _aaca (_acfe _ec .Image ,_faee Image ,_aggc _ec .Rectangle ){if _fagf ,_fedf :=_acfe .(SMasker );_fedf &&_fagf .HasAlpha (){_faee .(SMasker ).MakeAlpha ();};_ebda (_acfe ,_faee ,_aggc );};type Monochrome struct{ImageBase ;ModelThreshold uint8 ;};
func (_daed *Monochrome )Set (x ,y int ,c _d .Color ){_cgef :=y *_daed .BytesPerLine +x >>3;if _cgef > len (_daed .Data )-1{return ;};_ffe :=_daed .ColorModel ().Convert (c ).(_d .Gray );_daed .setGray (x ,_ffe ,_cgef );};type NRGBA64 struct{ImageBase };
type CMYK interface{CMYKAt (_fgf ,_efe int )_d .CMYK ;SetCMYK (_dbce ,_fce int ,_fadf _d .CMYK );};type monochromeThresholdConverter struct{Threshold uint8 ;};func (_dbceb *Gray4 )Base ()*ImageBase {return &_dbceb .ImageBase };func ImgToGray (i _ec .Image )*_ec .Gray {if _acbe ,_affd :=i .(*_ec .Gray );
_affd {return _acbe ;};_eadb :=i .Bounds ();_cddf :=_ec .NewGray (_eadb );for _cfaa :=0;_cfaa < _eadb .Max .X ;_cfaa ++{for _dgbga :=0;_dgbga < _eadb .Max .Y ;_dgbga ++{_bcag :=i .At (_cfaa ,_dgbga );_cddf .Set (_cfaa ,_dgbga ,_bcag );};};return _cddf ;
};func BytesPerLine (width ,bitsPerComponent ,colorComponents int )int {return ((width *bitsPerComponent )*colorComponents +7)>>3;};func _cgbd (_aab _d .Gray )_d .Gray {_aab .Y >>=4;_aab .Y |=_aab .Y <<4;return _aab };func (_fdd monochromeModel )Convert (c _d .Color )_d .Color {_edca :=_d .GrayModel .Convert (c ).(_d .Gray );
return _fgea (_edca ,_fdd );};func _abbg (_eagee ,_dccc Gray ,_ggbf _ec .Rectangle ){for _badc :=0;_badc < _ggbf .Max .X ;_badc ++{for _baff :=0;_baff < _ggbf .Max .Y ;_baff ++{_dccc .SetGray (_badc ,_baff ,_eagee .GrayAt (_badc ,_baff ));};};};func (_dffc *Monochrome )Validate ()error {if len (_dffc .Data )!=_dffc .Height *_dffc .BytesPerLine {return ErrInvalidImage ;
};return nil ;};func (_aecc *RGBA32 )ColorModel ()_d .Model {return _d .NRGBAModel };func init (){_bfgg ()};func _bfda (_cccf *_ec .NYCbCrA ,_afbbd NRGBA ,_abfe _ec .Rectangle ){for _fcceb :=0;_fcceb < _abfe .Max .X ;_fcceb ++{for _bcfg :=0;_bcfg < _abfe .Max .Y ;
_bcfg ++{_fcfc :=_cccf .NYCbCrAAt (_fcceb ,_bcfg );_afbbd .SetNRGBA (_fcceb ,_bcfg ,_eage (_fcfc ));};};};func _efefb (_fcab *Monochrome ,_daeb ,_ggfff int ,_bbgeg ,_bccb int ,_cdge RasterOperator ){var (_febb bool ;_beab bool ;_aabg int ;_faag int ;_ffgg int ;
_dacc int ;_agfd bool ;_fed byte ;);_egda :=8-(_daeb &7);_badd :=_eefb [_egda ];_ecdgg :=_fcab .BytesPerLine *_ggfff +(_daeb >>3);if _bbgeg < _egda {_febb =true ;_badd &=_aaaa [8-_egda +_bbgeg ];};if !_febb {_aabg =(_bbgeg -_egda )>>3;if _aabg !=0{_beab =true ;
_faag =_ecdgg +1;};};_ffgg =(_daeb +_bbgeg )&7;if !(_febb ||_ffgg ==0){_agfd =true ;_fed =_aaaa [_ffgg ];_dacc =_ecdgg +1+_aabg ;};var _agc ,_gbad int ;switch _cdge {case PixClr :for _agc =0;_agc < _bccb ;_agc ++{_fcab .Data [_ecdgg ]=_cdea (_fcab .Data [_ecdgg ],0x0,_badd );
_ecdgg +=_fcab .BytesPerLine ;};if _beab {for _agc =0;_agc < _bccb ;_agc ++{for _gbad =0;_gbad < _aabg ;_gbad ++{_fcab .Data [_faag +_gbad ]=0x0;};_faag +=_fcab .BytesPerLine ;};};if _agfd {for _agc =0;_agc < _bccb ;_agc ++{_fcab .Data [_dacc ]=_cdea (_fcab .Data [_dacc ],0x0,_fed );
_dacc +=_fcab .BytesPerLine ;};};case PixSet :for _agc =0;_agc < _bccb ;_agc ++{_fcab .Data [_ecdgg ]=_cdea (_fcab .Data [_ecdgg ],0xff,_badd );_ecdgg +=_fcab .BytesPerLine ;};if _beab {for _agc =0;_agc < _bccb ;_agc ++{for _gbad =0;_gbad < _aabg ;_gbad ++{_fcab .Data [_faag +_gbad ]=0xff;
};_faag +=_fcab .BytesPerLine ;};};if _agfd {for _agc =0;_agc < _bccb ;_agc ++{_fcab .Data [_dacc ]=_cdea (_fcab .Data [_dacc ],0xff,_fed );_dacc +=_fcab .BytesPerLine ;};};case PixNotDst :for _agc =0;_agc < _bccb ;_agc ++{_fcab .Data [_ecdgg ]=_cdea (_fcab .Data [_ecdgg ],^_fcab .Data [_ecdgg ],_badd );
_ecdgg +=_fcab .BytesPerLine ;};if _beab {for _agc =0;_agc < _bccb ;_agc ++{for _gbad =0;_gbad < _aabg ;_gbad ++{_fcab .Data [_faag +_gbad ]=^(_fcab .Data [_faag +_gbad ]);};_faag +=_fcab .BytesPerLine ;};};if _agfd {for _agc =0;_agc < _bccb ;_agc ++{_fcab .Data [_dacc ]=_cdea (_fcab .Data [_dacc ],^_fcab .Data [_dacc ],_fed );
_dacc +=_fcab .BytesPerLine ;};};};};func _aea ()(_ced [256]uint64 ){for _cdc :=0;_cdc < 256;_cdc ++{if _cdc &0x01!=0{_ced [_cdc ]|=0xff;};if _cdc &0x02!=0{_ced [_cdc ]|=0xff00;};if _cdc &0x04!=0{_ced [_cdc ]|=0xff0000;};if _cdc &0x08!=0{_ced [_cdc ]|=0xff000000;
};if _cdc &0x10!=0{_ced [_cdc ]|=0xff00000000;};if _cdc &0x20!=0{_ced [_cdc ]|=0xff0000000000;};if _cdc &0x40!=0{_ced [_cdc ]|=0xff000000000000;};if _cdc &0x80!=0{_ced [_cdc ]|=0xff00000000000000;};};return _ced ;};func (_defe *Gray4 )Validate ()error {if len (_defe .Data )!=_defe .Height *_defe .BytesPerLine {return ErrInvalidImage ;
};return nil ;};type Gray8 struct{ImageBase };var _ _ec .Image =&Gray8 {};func ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor int ,data ,alpha []byte ,decode []float64 )(_d .Color ,error ){switch bitsPerColor {case 4:return ColorAtNRGBA16 (x ,y ,width ,bytesPerLine ,data ,alpha ,decode );
case 8:return ColorAtNRGBA32 (x ,y ,width ,data ,alpha ,decode );case 16:return ColorAtNRGBA64 (x ,y ,width ,data ,alpha ,decode );default:return nil ,_ba .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0067\u0062\u0020b\u0069\u0074\u0073\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0061\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );
};};type Gray16 struct{ImageBase };func (_dbbc *Gray16 )ColorAt (x ,y int )(_d .Color ,error ){return ColorAtGray16BPC (x ,y ,_dbbc .BytesPerLine ,_dbbc .Data ,_dbbc .Decode );};func ColorAt (x ,y ,width ,bitsPerColor ,colorComponents ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_d .Color ,error ){switch colorComponents {case 1:return ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine ,data ,decode );
case 3:return ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor ,data ,alpha ,decode );case 4:return ColorAtCMYK (x ,y ,width ,data ,decode );default:return nil ,_ba .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0063o\u006c\u006f\u0072\u0020\u0063\u006f\u006dp\u006f\u006e\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0064",colorComponents );
};};func (_dgca *Gray2 )ColorAt (x ,y int )(_d .Color ,error ){return ColorAtGray2BPC (x ,y ,_dgca .BytesPerLine ,_dgca .Data ,_dgca .Decode );};func (_feaf *Gray2 )Bounds ()_ec .Rectangle {return _ec .Rectangle {Max :_ec .Point {X :_feaf .Width ,Y :_feaf .Height }};
};func _afff (_fceeb *_ec .Gray )bool {for _aeagb :=0;_aeagb < len (_fceeb .Pix );_aeagb ++{if !_gced (_fceeb .Pix [_aeagb ]){return false ;};};return true ;};func (_beeb *RGBA32 )At (x ,y int )_d .Color {_ebcbd ,_ :=_beeb .ColorAt (x ,y );return _ebcbd };
func _abf (_egdga int ,_cfcf int )error {return _ba .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",_egdga ,_cfcf );
};func _ffc (_egfg _d .Gray )_d .NRGBA {return _d .NRGBA {R :_egfg .Y ,G :_egfg .Y ,B :_egfg .Y ,A :0xff}};func GetConverter (bitsPerComponent ,colorComponents int )(ColorConverter ,error ){switch colorComponents {case 1:switch bitsPerComponent {case 1:return MonochromeConverter ,nil ;
case 2:return Gray2Converter ,nil ;case 4:return Gray4Converter ,nil ;case 8:return GrayConverter ,nil ;case 16:return Gray16Converter ,nil ;};case 3:switch bitsPerComponent {case 4:return NRGBA16Converter ,nil ;case 8:return NRGBAConverter ,nil ;case 16:return NRGBA64Converter ,nil ;
};case 4:return CMYKConverter ,nil ;};return nil ,_ba .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0043o\u006e\u0076\u0065\u0072\u0074\u0065\u0072\u0020\u0070\u0061\u0072\u0061\u006d\u0065t\u0065\u0072\u0073\u002e\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003a\u0020\u0025\u0064\u002c\u0020\u0043\u006f\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006et\u0073\u003a \u0025\u0064",bitsPerComponent ,colorComponents );
};func MonochromeThresholdConverter (threshold uint8 )ColorConverter {return &monochromeThresholdConverter {Threshold :threshold };};func _cdg (_dbd _d .NRGBA )_d .CMYK {_abc ,_cfeb ,_dbdg ,_ :=_dbd .RGBA ();_efcf ,_bca ,_egba ,_edf :=_d .RGBToCMYK (uint8 (_abc >>8),uint8 (_cfeb >>8),uint8 (_dbdg >>8));
return _d .CMYK {C :_efcf ,M :_bca ,Y :_egba ,K :_edf };};type Gray4 struct{ImageBase };func FromGoImage (i _ec .Image )(Image ,error ){switch _aeab :=i .(type ){case Image :return _aeab .Copy (),nil ;case Gray :return GrayConverter .Convert (i );case *_ec .Gray16 :return Gray16Converter .Convert (i );
case CMYK :return CMYKConverter .Convert (i );case *_ec .NRGBA64 :return NRGBA64Converter .Convert (i );default:return NRGBAConverter .Convert (i );};};func (_gdc *Monochrome )setGray (_geca int ,_eeafe _d .Gray ,_bad int ){if _eeafe .Y ==0{_gdc .clearBit (_bad ,_geca );
}else {_gdc .setGrayBit (_bad ,_geca );};};func (_gcad *Gray16 )Base ()*ImageBase {return &_gcad .ImageBase };func (_cega *NRGBA64 )setNRGBA64 (_eced int ,_dcgda _d .NRGBA64 ,_ggge int ){_cega .Data [_eced ]=uint8 (_dcgda .R >>8);_cega .Data [_eced +1]=uint8 (_dcgda .R &0xff);
_cega .Data [_eced +2]=uint8 (_dcgda .G >>8);_cega .Data [_eced +3]=uint8 (_dcgda .G &0xff);_cega .Data [_eced +4]=uint8 (_dcgda .B >>8);_cega .Data [_eced +5]=uint8 (_dcgda .B &0xff);if _ggge +1< len (_cega .Alpha ){_cega .Alpha [_ggge ]=uint8 (_dcgda .A >>8);
_cega .Alpha [_ggge +1]=uint8 (_dcgda .A &0xff);};};func (_fafa *CMYK32 )Base ()*ImageBase {return &_fafa .ImageBase };var _ Image =&Gray4 {};func _ggeb (_cfb Gray ,_ggad NRGBA ,_ceac _ec .Rectangle ){for _aegd :=0;_aegd < _ceac .Max .X ;_aegd ++{for _dedc :=0;
_dedc < _ceac .Max .Y ;_dedc ++{_beea :=_cfb .GrayAt (_aegd ,_dedc );_ggad .SetNRGBA (_aegd ,_dedc ,_ffc (_beea ));};};};func _efge (_beff _ec .Image )(Image ,error ){if _agfb ,_cebe :=_beff .(*NRGBA16 );_cebe {return _agfb .Copy (),nil ;};_dgbc :=_beff .Bounds ();
_aae ,_gcbbb :=NewImage (_dgbc .Max .X ,_dgbc .Max .Y ,4,3,nil ,nil ,nil );if _gcbbb !=nil {return nil ,_gcbbb ;};_afbc (_beff ,_aae ,_dgbc );return _aae ,nil ;};func (_eceg *NRGBA64 )ColorAt (x ,y int )(_d .Color ,error ){return ColorAtNRGBA64 (x ,y ,_eceg .Width ,_eceg .Data ,_eceg .Alpha ,_eceg .Decode );
};var _ Image =&RGBA32 {};var _ _ec .Image =&NRGBA64 {};func (_dfbf *NRGBA32 )ColorAt (x ,y int )(_d .Color ,error ){return ColorAtNRGBA32 (x ,y ,_dfbf .Width ,_dfbf .Data ,_dfbf .Alpha ,_dfbf .Decode );};func (_gaff *Monochrome )Scale (scale float64 )(*Monochrome ,error ){var _fcffe bool ;
_agga :=scale ;if scale < 1{_agga =1/scale ;_fcffe =true ;};_aecb :=NextPowerOf2 (uint (_agga ));if InDelta (float64 (_aecb ),_agga ,0.001){if _fcffe {return _gaff .ReduceBinary (_agga );};return _gaff .ExpandBinary (int (_aecb ));};_aga :=int (_e .RoundToEven (float64 (_gaff .Width )*scale ));
_bcdfb :=int (_e .RoundToEven (float64 (_gaff .Height )*scale ));return _gaff .ScaleLow (_aga ,_bcdfb );};func (_edfb *RGBA32 )RGBAAt (x ,y int )_d .RGBA {_gcff ,_ :=ColorAtRGBA32 (x ,y ,_edfb .Width ,_edfb .Data ,_edfb .Alpha ,_edfb .Decode );return _gcff ;
};func (_dbca *Gray8 )GrayAt (x ,y int )_d .Gray {_geac ,_ :=ColorAtGray8BPC (x ,y ,_dbca .BytesPerLine ,_dbca .Data ,_dbca .Decode );return _geac ;};func (_fcce *Gray4 )Bounds ()_ec .Rectangle {return _ec .Rectangle {Max :_ec .Point {X :_fcce .Width ,Y :_fcce .Height }};
};func (_gfg *Gray2 )SetGray (x ,y int ,gray _d .Gray ){_gefc :=_dcga (gray );_cecg :=y *_gfg .BytesPerLine ;_caaf :=_cecg +(x >>2);if _caaf >=len (_gfg .Data ){return ;};_gcgc :=_gefc .Y >>6;_gfg .Data [_caaf ]=(_gfg .Data [_caaf ]&(^(0xc0>>uint (2*((x )&3)))))|(_gcgc <<uint (6-2*(x &3)));
};func (_cbad *Gray16 )Validate ()error {if len (_cbad .Data )!=_cbad .Height *_cbad .BytesPerLine {return ErrInvalidImage ;};return nil ;};type Gray2 struct{ImageBase };func (_cbd *Monochrome )IsUnpadded ()bool {return (_cbd .Width *_cbd .Height )==len (_cbd .Data )};
func (_fgeab *RGBA32 )setRGBA (_aada int ,_efedf _d .RGBA ){_fbdf :=3*_aada ;_fgeab .Data [_fbdf ]=_efedf .R ;_fgeab .Data [_fbdf +1]=_efedf .G ;_fgeab .Data [_fbdf +2]=_efedf .B ;if _aada < len (_fgeab .Alpha ){_fgeab .Alpha [_aada ]=_efedf .A ;};};func (_ggbge *NRGBA64 )ColorModel ()_d .Model {return _d .NRGBA64Model };
type NRGBA interface{NRGBAAt (_gefac ,_dacf int )_d .NRGBA ;SetNRGBA (_daecf ,_egdb int ,_accb _d .NRGBA );};func (_agbb *Gray8 )Validate ()error {if len (_agbb .Data )!=_agbb .Height *_agbb .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_fdaa *Monochrome )ColorAt (x ,y int )(_d .Color ,error ){return ColorAtGray1BPC (x ,y ,_fdaa .BytesPerLine ,_fdaa .Data ,_fdaa .Decode );
};func ColorAtGray4BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_d .Gray ,error ){_agdf :=y *bytesPerLine +x >>1;if _agdf >=len (data ){return _d .Gray {},_ba .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_feafc :=data [_agdf ]>>uint (4-(x &1)*4)&0xf;if len (decode )==2{_feafc =uint8 (uint32 (LinearInterpolate (float64 (_feafc ),0,15,decode [0],decode [1]))&0xf);};return _d .Gray {Y :_feafc *17&0xff},nil ;};func _cdfg (_efdc _d .CMYK )_d .RGBA {_bcf ,_bee ,_gad :=_d .CMYKToRGB (_efdc .C ,_efdc .M ,_efdc .Y ,_efdc .K );
return _d .RGBA {R :_bcf ,G :_bee ,B :_gad ,A :0xff};};func (_gfbd *CMYK32 )SetCMYK (x ,y int ,c _d .CMYK ){_gae :=4*(y *_gfbd .Width +x );if _gae +3>=len (_gfbd .Data ){return ;};_gfbd .Data [_gae ]=c .C ;_gfbd .Data [_gae +1]=c .M ;_gfbd .Data [_gae +2]=c .Y ;
_gfbd .Data [_gae +3]=c .K ;};func _cdbc (_abcc _d .Gray )_d .CMYK {return _d .CMYK {K :0xff-_abcc .Y }};func _gdab (_acbd []byte ,_afac Image )error {_egeb :=true ;for _efec :=0;_efec < len (_acbd );_efec ++{if _acbd [_efec ]!=0xff{_egeb =false ;break ;
};};if _egeb {switch _bfbf :=_afac .(type ){case *NRGBA32 :_bfbf .Alpha =nil ;case *NRGBA64 :_bfbf .Alpha =nil ;default:return _ba .Errorf ("i\u006ete\u0072n\u0061l\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020i\u006d\u0061\u0067\u0065\u0020s\u0068\u006f\u0075l\u0064\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0074\u0079\u0070e\u0020\u002a\u004eRGB\u0041\u0033\u0032\u0020\u006f\u0072 \u002a\u004e\u0052\u0047\u0042\u0041\u0036\u0034\u0020\u0062\u0075\u0074 \u0069s\u003a\u0020\u0025\u0054",_afac );
};};return nil ;};func (_fbg *Gray2 )Copy ()Image {return &Gray2 {ImageBase :_fbg .copy ()}};func _fbcg (_ffff *_ec .Gray16 ,_ddga uint8 )*_ec .Gray {_aggf :=_ffff .Bounds ();_eefge :=_ec .NewGray (_aggf );for _fdgfe :=0;_fdgfe < _aggf .Dx ();_fdgfe ++{for _eede :=0;
_eede < _aggf .Dy ();_eede ++{_fage :=_ffff .Gray16At (_fdgfe ,_eede );_eefge .SetGray (_fdgfe ,_eede ,_d .Gray {Y :_gecc (uint8 (_fage .Y /256),_ddga )});};};return _eefge ;};var _ Gray =&Gray16 {};func _beag (_fbga CMYK ,_fegcd NRGBA ,_beed _ec .Rectangle ){for _cfbb :=0;
_cfbb < _beed .Max .X ;_cfbb ++{for _fcda :=0;_fcda < _beed .Max .Y ;_fcda ++{_eadf :=_fbga .CMYKAt (_cfbb ,_fcda );_fegcd .SetNRGBA (_cfbb ,_fcda ,_baab (_eadf ));};};};const (_ebcdg shift =iota ;_egge ;);var _ _ec .Image =&RGBA32 {};func (_abbaa *Gray4 )ColorModel ()_d .Model {return Gray4Model };
func RasterOperation (dest *Monochrome ,dx ,dy ,dw ,dh int ,op RasterOperator ,src *Monochrome ,sx ,sy int )error {return _bcbe (dest ,dx ,dy ,dw ,dh ,op ,src ,sx ,sy );};func _eeac (_ceec nrgba64 ,_dfccd NRGBA ,_ddac _ec .Rectangle ){for _bgfa :=0;_bgfa < _ddac .Max .X ;
_bgfa ++{for _ceba :=0;_ceba < _ddac .Max .Y ;_ceba ++{_agfgc :=_ceec .NRGBA64At (_bgfa ,_ceba );_dfccd .SetNRGBA (_bgfa ,_ceba ,_dfde (_agfgc ));};};};func _feba (_eafe _d .NRGBA )_d .NRGBA {_eafe .R =_eafe .R >>4|(_eafe .R >>4)<<4;_eafe .G =_eafe .G >>4|(_eafe .G >>4)<<4;
_eafe .B =_eafe .B >>4|(_eafe .B >>4)<<4;return _eafe ;};func (_daf *Gray8 )Base ()*ImageBase {return &_daf .ImageBase };func (_gfge *RGBA32 )SetRGBA (x ,y int ,c _d .RGBA ){_bgfee :=y *_gfge .Width +x ;_bfbbac :=3*_bgfee ;if _bfbbac +2>=len (_gfge .Data ){return ;
};_gfge .setRGBA (_bgfee ,c );};func (_debe *Monochrome )Histogram ()(_ffad [256]int ){for _ ,_dffe :=range _debe .Data {_ffad [0xff]+=int (_ebdg [_debe .Data [_dffe ]]);};return _ffad ;};func _ebcbb (_beae _d .Color )_d .Color {_ggce :=_d .GrayModel .Convert (_beae ).(_d .Gray );
return _dcga (_ggce );};type RasterOperator int ;func _cbfc (_cgab *Monochrome ,_acba ,_gdcb ,_fgbd ,_geb int ,_bcfdc RasterOperator ,_ece *Monochrome ,_dafb ,_daedf int )error {var (_bgbbg byte ;_fcae int ;_cdde int ;_efef ,_cfef int ;_ccdg ,_gab int ;
);_bfcg :=_fgbd >>3;_aebd :=_fgbd &7;if _aebd > 0{_bgbbg =_aaaa [_aebd ];};_fcae =_ece .BytesPerLine *_daedf +(_dafb >>3);_cdde =_cgab .BytesPerLine *_gdcb +(_acba >>3);switch _bcfdc {case PixSrc :for _ccdg =0;_ccdg < _geb ;_ccdg ++{_efef =_fcae +_ccdg *_ece .BytesPerLine ;
_cfef =_cdde +_ccdg *_cgab .BytesPerLine ;for _gab =0;_gab < _bfcg ;_gab ++{_cgab .Data [_cfef ]=_ece .Data [_efef ];_cfef ++;_efef ++;};if _aebd > 0{_cgab .Data [_cfef ]=_cdea (_cgab .Data [_cfef ],_ece .Data [_efef ],_bgbbg );};};case PixNotSrc :for _ccdg =0;
_ccdg < _geb ;_ccdg ++{_efef =_fcae +_ccdg *_ece .BytesPerLine ;_cfef =_cdde +_ccdg *_cgab .BytesPerLine ;for _gab =0;_gab < _bfcg ;_gab ++{_cgab .Data [_cfef ]=^(_ece .Data [_efef ]);_cfef ++;_efef ++;};if _aebd > 0{_cgab .Data [_cfef ]=_cdea (_cgab .Data [_cfef ],^_ece .Data [_efef ],_bgbbg );
};};case PixSrcOrDst :for _ccdg =0;_ccdg < _geb ;_ccdg ++{_efef =_fcae +_ccdg *_ece .BytesPerLine ;_cfef =_cdde +_ccdg *_cgab .BytesPerLine ;for _gab =0;_gab < _bfcg ;_gab ++{_cgab .Data [_cfef ]|=_ece .Data [_efef ];_cfef ++;_efef ++;};if _aebd > 0{_cgab .Data [_cfef ]=_cdea (_cgab .Data [_cfef ],_ece .Data [_efef ]|_cgab .Data [_cfef ],_bgbbg );
};};case PixSrcAndDst :for _ccdg =0;_ccdg < _geb ;_ccdg ++{_efef =_fcae +_ccdg *_ece .BytesPerLine ;_cfef =_cdde +_ccdg *_cgab .BytesPerLine ;for _gab =0;_gab < _bfcg ;_gab ++{_cgab .Data [_cfef ]&=_ece .Data [_efef ];_cfef ++;_efef ++;};if _aebd > 0{_cgab .Data [_cfef ]=_cdea (_cgab .Data [_cfef ],_ece .Data [_efef ]&_cgab .Data [_cfef ],_bgbbg );
};};case PixSrcXorDst :for _ccdg =0;_ccdg < _geb ;_ccdg ++{_efef =_fcae +_ccdg *_ece .BytesPerLine ;_cfef =_cdde +_ccdg *_cgab .BytesPerLine ;for _gab =0;_gab < _bfcg ;_gab ++{_cgab .Data [_cfef ]^=_ece .Data [_efef ];_cfef ++;_efef ++;};if _aebd > 0{_cgab .Data [_cfef ]=_cdea (_cgab .Data [_cfef ],_ece .Data [_efef ]^_cgab .Data [_cfef ],_bgbbg );
};};case PixNotSrcOrDst :for _ccdg =0;_ccdg < _geb ;_ccdg ++{_efef =_fcae +_ccdg *_ece .BytesPerLine ;_cfef =_cdde +_ccdg *_cgab .BytesPerLine ;for _gab =0;_gab < _bfcg ;_gab ++{_cgab .Data [_cfef ]|=^(_ece .Data [_efef ]);_cfef ++;_efef ++;};if _aebd > 0{_cgab .Data [_cfef ]=_cdea (_cgab .Data [_cfef ],^(_ece .Data [_efef ])|_cgab .Data [_cfef ],_bgbbg );
};};case PixNotSrcAndDst :for _ccdg =0;_ccdg < _geb ;_ccdg ++{_efef =_fcae +_ccdg *_ece .BytesPerLine ;_cfef =_cdde +_ccdg *_cgab .BytesPerLine ;for _gab =0;_gab < _bfcg ;_gab ++{_cgab .Data [_cfef ]&=^(_ece .Data [_efef ]);_cfef ++;_efef ++;};if _aebd > 0{_cgab .Data [_cfef ]=_cdea (_cgab .Data [_cfef ],^(_ece .Data [_efef ])&_cgab .Data [_cfef ],_bgbbg );
};};case PixSrcOrNotDst :for _ccdg =0;_ccdg < _geb ;_ccdg ++{_efef =_fcae +_ccdg *_ece .BytesPerLine ;_cfef =_cdde +_ccdg *_cgab .BytesPerLine ;for _gab =0;_gab < _bfcg ;_gab ++{_cgab .Data [_cfef ]=_ece .Data [_efef ]|^(_cgab .Data [_cfef ]);_cfef ++;
_efef ++;};if _aebd > 0{_cgab .Data [_cfef ]=_cdea (_cgab .Data [_cfef ],_ece .Data [_efef ]|^(_cgab .Data [_cfef ]),_bgbbg );};};case PixSrcAndNotDst :for _ccdg =0;_ccdg < _geb ;_ccdg ++{_efef =_fcae +_ccdg *_ece .BytesPerLine ;_cfef =_cdde +_ccdg *_cgab .BytesPerLine ;
for _gab =0;_gab < _bfcg ;_gab ++{_cgab .Data [_cfef ]=_ece .Data [_efef ]&^(_cgab .Data [_cfef ]);_cfef ++;_efef ++;};if _aebd > 0{_cgab .Data [_cfef ]=_cdea (_cgab .Data [_cfef ],_ece .Data [_efef ]&^(_cgab .Data [_cfef ]),_bgbbg );};};case PixNotPixSrcOrDst :for _ccdg =0;
_ccdg < _geb ;_ccdg ++{_efef =_fcae +_ccdg *_ece .BytesPerLine ;_cfef =_cdde +_ccdg *_cgab .BytesPerLine ;for _gab =0;_gab < _bfcg ;_gab ++{_cgab .Data [_cfef ]=^(_ece .Data [_efef ]|_cgab .Data [_cfef ]);_cfef ++;_efef ++;};if _aebd > 0{_cgab .Data [_cfef ]=_cdea (_cgab .Data [_cfef ],^(_ece .Data [_efef ]|_cgab .Data [_cfef ]),_bgbbg );
};};case PixNotPixSrcAndDst :for _ccdg =0;_ccdg < _geb ;_ccdg ++{_efef =_fcae +_ccdg *_ece .BytesPerLine ;_cfef =_cdde +_ccdg *_cgab .BytesPerLine ;for _gab =0;_gab < _bfcg ;_gab ++{_cgab .Data [_cfef ]=^(_ece .Data [_efef ]&_cgab .Data [_cfef ]);_cfef ++;
_efef ++;};if _aebd > 0{_cgab .Data [_cfef ]=_cdea (_cgab .Data [_cfef ],^(_ece .Data [_efef ]&_cgab .Data [_cfef ]),_bgbbg );};};case PixNotPixSrcXorDst :for _ccdg =0;_ccdg < _geb ;_ccdg ++{_efef =_fcae +_ccdg *_ece .BytesPerLine ;_cfef =_cdde +_ccdg *_cgab .BytesPerLine ;
for _gab =0;_gab < _bfcg ;_gab ++{_cgab .Data [_cfef ]=^(_ece .Data [_efef ]^_cgab .Data [_cfef ]);_cfef ++;_efef ++;};if _aebd > 0{_cgab .Data [_cfef ]=_cdea (_cgab .Data [_cfef ],^(_ece .Data [_efef ]^_cgab .Data [_cfef ]),_bgbbg );};};default:_ca .Log .Debug ("\u0050\u0072ov\u0069\u0064\u0065d\u0020\u0069\u006e\u0076ali\u0064 r\u0061\u0073\u0074\u0065\u0072\u0020\u006fpe\u0072\u0061\u0074\u006f\u0072\u003a\u0020%\u0076",_bcfdc );
return _c .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072");};return nil ;};type colorConverter struct{_dcbg func (_fcc _ec .Image )(Image ,error );};func ConverterFunc (converterFunc func (_feb _ec .Image )(Image ,error ))ColorConverter {return colorConverter {_dcbg :converterFunc };
};func LinearInterpolate (x ,xmin ,xmax ,ymin ,ymax float64 )float64 {if _e .Abs (xmax -xmin )< 0.000001{return ymin ;};_aeeg :=ymin +(x -xmin )*(ymax -ymin )/(xmax -xmin );return _aeeg ;};func (_cfcga *Gray16 )SetGray (x ,y int ,g _d .Gray ){_ffcb :=(y *_cfcga .BytesPerLine /2+x )*2;
if _ffcb +1>=len (_cfcga .Data ){return ;};_cfcga .Data [_ffcb ]=g .Y ;_cfcga .Data [_ffcb +1]=g .Y ;};func (_gbdf *Monochrome )setGrayBit (_aead ,_bdba int ){_gbdf .Data [_aead ]|=0x80>>uint (_bdba &7)};func _dd (_de ,_ded *Monochrome )(_be error ){_egg :=_ded .BytesPerLine ;
_cb :=_de .BytesPerLine ;_db :=_ded .BytesPerLine *4-_de .BytesPerLine ;var (_gff ,_bab byte ;_eb uint32 ;_cab ,_dda ,_dgc ,_fbd ,_cc ,_ag ,_fa int ;);for _dgc =0;_dgc < _ded .Height ;_dgc ++{_cab =_dgc *_egg ;_dda =4*_dgc *_cb ;for _fbd =0;_fbd < _egg ;
_fbd ++{_gff =_ded .Data [_cab +_fbd ];_eb =_agf [_gff ];_ag =_dda +_fbd *4;if _db !=0&&(_fbd +1)*4> _de .BytesPerLine {for _cc =_db ;_cc > 0;_cc --{_bab =byte ((_eb >>uint (_cc *8))&0xff);_fa =_ag +(_db -_cc );if _be =_de .setByte (_fa ,_bab );_be !=nil {return _be ;
};};}else if _be =_de .setFourBytes (_ag ,_eb );_be !=nil {return _be ;};if _be =_de .setFourBytes (_dda +_fbd *4,_agf [_ded .Data [_cab +_fbd ]]);_be !=nil {return _be ;};};for _cc =1;_cc < 4;_cc ++{for _fbd =0;_fbd < _cb ;_fbd ++{if _be =_de .setByte (_dda +_cc *_cb +_fbd ,_de .Data [_dda +_fbd ]);
_be !=nil {return _be ;};};};};return nil ;};func (_bedg *NRGBA16 )NRGBAAt (x ,y int )_d .NRGBA {_abeb ,_ :=ColorAtNRGBA16 (x ,y ,_bedg .Width ,_bedg .BytesPerLine ,_bedg .Data ,_bedg .Alpha ,_bedg .Decode );return _abeb ;};func (_cafb *ImageBase )GetAlpha ()[]byte {return _cafb .Alpha };
var _ _ec .Image =&NRGBA16 {};func (_gaae *Gray4 )Copy ()Image {return &Gray4 {ImageBase :_gaae .copy ()}};func (_eagb *Gray16 )At (x ,y int )_d .Color {_egafc ,_ :=_eagb .ColorAt (x ,y );return _egafc };func (_cceb *NRGBA64 )Copy ()Image {return &NRGBA64 {ImageBase :_cceb .copy ()}};
func (_gaga *NRGBA64 )NRGBA64At (x ,y int )_d .NRGBA64 {_dcgf ,_ :=ColorAtNRGBA64 (x ,y ,_gaga .Width ,_gaga .Data ,_gaga .Alpha ,_gaga .Decode );return _dcgf ;};func _baf (_acb _d .Gray )_d .RGBA {return _d .RGBA {R :_acb .Y ,G :_acb .Y ,B :_acb .Y ,A :0xff}};
func (_bbcf *Gray8 )ColorModel ()_d .Model {return _d .GrayModel };func _ecga (_gaf _d .NRGBA )_d .Gray {_geg ,_fdcf ,_ecfd ,_ :=_gaf .RGBA ();_daga :=(19595*_geg +38470*_fdcf +7471*_ecfd +1<<15)>>24;return _d .Gray {Y :uint8 (_daga )};};func _cfc (_faa *Monochrome ,_bfg int ,_dbb []byte )(_ad *Monochrome ,_dde error ){const _dfb ="\u0072\u0065d\u0075\u0063\u0065R\u0061\u006e\u006b\u0042\u0069\u006e\u0061\u0072\u0079";
if _faa ==nil {return nil ,_c .New ("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d");};if _bfg < 1||_bfg > 4{return nil ,_c .New ("\u006c\u0065\u0076\u0065\u006c\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020\u0073e\u0074\u0020\u007b\u0031\u002c\u0032\u002c\u0033\u002c\u0034\u007d");
};if _faa .Height <=1{return nil ,_c .New ("\u0073\u006f\u0075rc\u0065\u0020\u0068\u0065\u0069\u0067\u0068\u0074\u0020m\u0075s\u0074 \u0062e\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020\u0027\u0032\u0027");};_ad =_cga (_faa .Width /2,_faa .Height /2);
if _dbb ==nil {_dbb =_adb ();};_ac :=_facf (_faa .BytesPerLine ,2*_ad .BytesPerLine );switch _bfg {case 1:_dde =_gfb (_faa ,_ad ,_dbb ,_ac );case 2:_dde =_fcf (_faa ,_ad ,_dbb ,_ac );case 3:_dde =_faf (_faa ,_ad ,_dbb ,_ac );case 4:_dde =_acf (_faa ,_ad ,_dbb ,_ac );
};if _dde !=nil {return nil ,_dde ;};return _ad ,nil ;};func _aged (_add _d .CMYK )_d .Gray {_bbd ,_eee ,_gee :=_d .CMYKToRGB (_add .C ,_add .M ,_add .Y ,_add .K );_abe :=(19595*uint32 (_bbd )+38470*uint32 (_eee )+7471*uint32 (_gee )+1<<7)>>16;return _d .Gray {Y :uint8 (_abe )};
};func (_bed *Monochrome )Base ()*ImageBase {return &_bed .ImageBase };func (_ggde *Monochrome )clearBit (_edge ,_egefe int ){_ggde .Data [_edge ]&=^(0x80>>uint (_egefe &7))};var _ Image =&Gray16 {};func (_fddg *Monochrome )SetGray (x ,y int ,g _d .Gray ){_gbd :=y *_fddg .BytesPerLine +x >>3;
if _gbd > len (_fddg .Data )-1{return ;};g =_fgea (g ,monochromeModel (_fddg .ModelThreshold ));_fddg .setGray (x ,g ,_gbd );};func (_cefcd *NRGBA16 )Validate ()error {if len (_cefcd .Data )!=3*_cefcd .Width *_cefcd .Height /2{return _c .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func (_fcacd *NRGBA64 )Set (x ,y int ,c _d .Color ){_gfgf :=(y *_fcacd .Width +x )*2;_fgbg :=_gfgf *3;if _fgbg +5>=len (_fcacd .Data ){return ;};_cff :=_d .NRGBA64Model .Convert (c ).(_d .NRGBA64 );_fcacd .setNRGBA64 (_fgbg ,_cff ,_gfgf );
};func _feac (_gag _d .RGBA )_d .NRGBA {switch _gag .A {case 0xff:return _d .NRGBA {R :_gag .R ,G :_gag .G ,B :_gag .B ,A :0xff};case 0x00:return _d .NRGBA {};default:_aadbc ,_deba ,_dee ,_bfad :=_gag .RGBA ();_aadbc =(_aadbc *0xffff)/_bfad ;_deba =(_deba *0xffff)/_bfad ;
_dee =(_dee *0xffff)/_bfad ;return _d .NRGBA {R :uint8 (_aadbc >>8),G :uint8 (_deba >>8),B :uint8 (_dee >>8),A :uint8 (_bfad >>8)};};};func (_ebdgd *RGBA32 )Copy ()Image {return &RGBA32 {ImageBase :_ebdgd .copy ()}};func ColorAtCMYK (x ,y ,width int ,data []byte ,decode []float64 )(_d .CMYK ,error ){_adf :=4*(y *width +x );
if _adf +3>=len (data ){return _d .CMYK {},_ba .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};C :=data [_adf ]&0xff;M :=data [_adf +1]&0xff;Y :=data [_adf +2]&0xff;K :=data [_adf +3]&0xff;if len (decode )==8{C =uint8 (uint32 (LinearInterpolate (float64 (C ),0,255,decode [0],decode [1]))&0xff);M =uint8 (uint32 (LinearInterpolate (float64 (M ),0,255,decode [2],decode [3]))&0xff);
Y =uint8 (uint32 (LinearInterpolate (float64 (Y ),0,255,decode [4],decode [5]))&0xff);K =uint8 (uint32 (LinearInterpolate (float64 (K ),0,255,decode [6],decode [7]))&0xff);};return _d .CMYK {C :C ,M :M ,Y :Y ,K :K },nil ;};func _aed (_cgf _ec .Image )(Image ,error ){if _eag ,_fgfb :=_cgf .(*CMYK32 );
_fgfb {return _eag .Copy (),nil ;};_gacf :=_cgf .Bounds ();_bce ,_fdb :=NewImage (_gacf .Max .X ,_gacf .Max .Y ,8,4,nil ,nil ,nil );if _fdb !=nil {return nil ,_fdb ;};switch _gda :=_cgf .(type ){case CMYK :_gdbd (_gda ,_bce .(CMYK ),_gacf );case Gray :_ebff (_gda ,_bce .(CMYK ),_gacf );
case NRGBA :_bfbg (_gda ,_bce .(CMYK ),_gacf );case RGBA :_feed (_gda ,_bce .(CMYK ),_gacf );default:_ebda (_cgf ,_bce ,_gacf );};return _bce ,nil ;};type Histogramer interface{Histogram ()[256]int ;};func (_aecgcd *Monochrome )At (x ,y int )_d .Color {_gbbc ,_ :=_aecgcd .ColorAt (x ,y );
return _gbbc };func (_cgac *Monochrome )GrayAt (x ,y int )_d .Gray {_dbced ,_ :=ColorAtGray1BPC (x ,y ,_cgac .BytesPerLine ,_cgac .Data ,_cgac .Decode );return _dbced ;};func ColorAtGray16BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_d .Gray16 ,error ){_eae :=(y *bytesPerLine /2+x )*2;
if _eae +1>=len (data ){return _d .Gray16 {},_ba .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_dcc :=uint16 (data [_eae ])<<8|uint16 (data [_eae +1]);if len (decode )==2{_dcc =uint16 (uint64 (LinearInterpolate (float64 (_dcc ),0,65535,decode [0],decode [1])));};return _d .Gray16 {Y :_dcc },nil ;};var _ _ec .Image =&Monochrome {};func ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine int ,data []byte ,decode []float64 )(_d .Color ,error ){switch bitsPerColor {case 1:return ColorAtGray1BPC (x ,y ,bytesPerLine ,data ,decode );
case 2:return ColorAtGray2BPC (x ,y ,bytesPerLine ,data ,decode );case 4:return ColorAtGray4BPC (x ,y ,bytesPerLine ,data ,decode );case 8:return ColorAtGray8BPC (x ,y ,bytesPerLine ,data ,decode );case 16:return ColorAtGray16BPC (x ,y ,bytesPerLine ,data ,decode );
default:return nil ,_ba .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0067\u0072\u0061\u0079\u0020\u0073c\u0061\u006c\u0065\u0020\u0062\u0069\u0074s\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020a\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );
};};type RGBA32 struct{ImageBase };func (_cgbc *Gray2 )At (x ,y int )_d .Color {_dfbb ,_ :=_cgbc .ColorAt (x ,y );return _dfbb };func (_cfaff *ImageBase )setEightPartlyBytes (_acfc ,_gdfe int ,_bbg uint64 )(_abaf error ){var (_fcgf byte ;_gbbb int ;);for _gfcf :=1;
_gfcf <=_gdfe ;_gfcf ++{_gbbb =64-_gfcf *8;_fcgf =byte (_bbg >>uint (_gbbb )&0xff);if _abaf =_cfaff .setByte (_acfc +_gfcf -1,_fcgf );_abaf !=nil {return _abaf ;};};_bfec :=_cfaff .BytesPerLine *8-_cfaff .Width ;if _bfec ==0{return nil ;};_gbbb -=8;_fcgf =byte (_bbg >>uint (_gbbb )&0xff)<<uint (_bfec );
if _abaf =_cfaff .setByte (_acfc +_gdfe ,_fcgf );_abaf !=nil {return _abaf ;};return nil ;};var _ _ec .Image =&Gray16 {};var _ Image =&NRGBA32 {};func (_bdaa *NRGBA32 )Base ()*ImageBase {return &_bdaa .ImageBase };func (_dfcag *ImageBase )setByte (_cbbe int ,_fddgg byte )error {if _cbbe > len (_dfcag .Data )-1{return _c .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_dfcag .Data [_cbbe ]=_fddgg ;return nil ;};var _ Image =&NRGBA64 {};func (_agaa *NRGBA32 )NRGBAAt (x ,y int )_d .NRGBA {_fgac ,_ :=ColorAtNRGBA32 (x ,y ,_agaa .Width ,_agaa .Data ,_agaa .Alpha ,_agaa .Decode );return _fgac ;};func _gced (_bagd uint8 )bool {if _bagd ==0||_bagd ==255{return true ;
};return false ;};func (_cdba *Gray4 )ColorAt (x ,y int )(_d .Color ,error ){return ColorAtGray4BPC (x ,y ,_cdba .BytesPerLine ,_cdba .Data ,_cdba .Decode );};func (_abed *RGBA32 )Base ()*ImageBase {return &_abed .ImageBase };var (MonochromeConverter =ConverterFunc (_fcbc );
Gray2Converter =ConverterFunc (_gea );Gray4Converter =ConverterFunc (_aaa );GrayConverter =ConverterFunc (_dfca );Gray16Converter =ConverterFunc (_gefgg );NRGBA16Converter =ConverterFunc (_efge );NRGBAConverter =ConverterFunc (_egfd );NRGBA64Converter =ConverterFunc (_bbdd );
RGBAConverter =ConverterFunc (_gabd );CMYKConverter =ConverterFunc (_aed ););func (_abbga *ImageBase )HasAlpha ()bool {if _abbga .Alpha ==nil {return false ;};for _bcfd :=range _abbga .Alpha {if _abbga .Alpha [_bcfd ]!=0xff{return true ;};};return false ;
};func (_bgbf *Gray16 )Set (x ,y int ,c _d .Color ){_ebcd :=(y *_bgbf .BytesPerLine /2+x )*2;if _ebcd +1>=len (_bgbf .Data ){return ;};_dce :=_d .Gray16Model .Convert (c ).(_d .Gray16 );_bgbf .Data [_ebcd ],_bgbf .Data [_ebcd +1]=uint8 (_dce .Y >>8),uint8 (_dce .Y &0xff);
};func (_ecad *NRGBA32 )Bounds ()_ec .Rectangle {return _ec .Rectangle {Max :_ec .Point {X :_ecad .Width ,Y :_ecad .Height }};};var _ Gray =&Monochrome {};func _cbgg (_ccfb ,_afdd RGBA ,_caga _ec .Rectangle ){for _bbgff :=0;_bbgff < _caga .Max .X ;_bbgff ++{for _cbcdc :=0;
_cbcdc < _caga .Max .Y ;_cbcdc ++{_afdd .SetRGBA (_bbgff ,_cbcdc ,_ccfb .RGBAAt (_bbgff ,_cbcdc ));};};};func _gecc (_gfae ,_ccfd uint8 )uint8 {if _gfae < _ccfd {return 255;};return 0;};func _bcdg (_bfdc NRGBA ,_bggg Gray ,_adcc _ec .Rectangle ){for _efgg :=0;
_efgg < _adcc .Max .X ;_efgg ++{for _dge :=0;_dge < _adcc .Max .Y ;_dge ++{_acbc :=_ecga (_bfdc .NRGBAAt (_efgg ,_dge ));_bggg .SetGray (_efgg ,_dge ,_acbc );};};};func (_edcd *Gray4 )SetGray (x ,y int ,g _d .Gray ){if x >=_edcd .Width ||y >=_edcd .Height {return ;
};g =_cgbd (g );_edcd .setGray (x ,y ,g );};func NewImage (width ,height ,bitsPerComponent ,colorComponents int ,data ,alpha []byte ,decode []float64 )(Image ,error ){_febc :=NewImageBase (width ,height ,bitsPerComponent ,colorComponents ,data ,alpha ,decode );
var _gece Image ;switch colorComponents {case 1:switch bitsPerComponent {case 1:_gece =&Monochrome {ImageBase :_febc ,ModelThreshold :0x0f};case 2:_gece =&Gray2 {ImageBase :_febc };case 4:_gece =&Gray4 {ImageBase :_febc };case 8:_gece =&Gray8 {ImageBase :_febc };
case 16:_gece =&Gray16 {ImageBase :_febc };};case 3:switch bitsPerComponent {case 4:_gece =&NRGBA16 {ImageBase :_febc };case 8:_gece =&NRGBA32 {ImageBase :_febc };case 16:_gece =&NRGBA64 {ImageBase :_febc };};case 4:_gece =&CMYK32 {ImageBase :_febc };};
if _gece ==nil {return nil ,ErrInvalidImage ;};return _gece ,nil ;};var _ebdg [256]uint8 ;func _ge (_fbe ,_fde int ,_cbg []byte )*Monochrome {_cfab :=_cga (_fbe ,_fde );_cfab .Data =_cbg ;return _cfab ;};func (_bcbb *NRGBA32 )setRGBA (_dgada int ,_gfd _d .NRGBA ){_gaec :=3*_dgada ;
_bcbb .Data [_gaec ]=_gfd .R ;_bcbb .Data [_gaec +1]=_gfd .G ;_bcbb .Data [_gaec +2]=_gfd .B ;if _dgada < len (_bcbb .Alpha ){_bcbb .Alpha [_dgada ]=_gfd .A ;};};func _afgd (_eabc Gray ,_gffa RGBA ,_aadbf _ec .Rectangle ){for _bbad :=0;_bbad < _aadbf .Max .X ;
_bbad ++{for _acbaf :=0;_acbaf < _aadbf .Max .Y ;_acbaf ++{_cdfgg :=_eabc .GrayAt (_bbad ,_acbaf );_gffa .SetRGBA (_bbad ,_acbaf ,_baf (_cdfgg ));};};};type NRGBA32 struct{ImageBase };var (_aaaa =[]byte {0x00,0x80,0xC0,0xE0,0xF0,0xF8,0xFC,0xFE,0xFF};_eefb =[]byte {0x00,0x01,0x03,0x07,0x0F,0x1F,0x3F,0x7F,0xFF};
);type shift int ;func IsGrayImgBlackAndWhite (i *_ec .Gray )bool {return _afff (i )};func (_fgfdb *Monochrome )ColorModel ()_d .Model {return MonochromeModel (_fgfdb .ModelThreshold )};var _ RGBA =&RGBA32 {};func (_badf *Gray2 )Base ()*ImageBase {return &_badf .ImageBase };
func _fbab (_fafd uint )uint {var _bde uint ;for _fafd !=0{_fafd >>=1;_bde ++;};return _bde -1;};func _fcd (_cec Gray ,_dbcg NRGBA ,_egec _ec .Rectangle ){for _cgbg :=0;_cgbg < _egec .Max .X ;_cgbg ++{for _ebca :=0;_ebca < _egec .Max .Y ;_ebca ++{_agbe :=_bbf (_dbcg .NRGBAAt (_cgbg ,_ebca ));
_cec .SetGray (_cgbg ,_ebca ,_agbe );};};};func ColorAtGray1BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_d .Gray ,error ){_cgcb :=y *bytesPerLine +x >>3;if _cgcb >=len (data ){return _d .Gray {},_ba .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_fab :=data [_cgcb ]>>uint (7-(x &7))&1;if len (decode )==2{_fab =uint8 (LinearInterpolate (float64 (_fab ),0.0,1.0,decode [0],decode [1]))&1;};return _d .Gray {Y :_fab *255},nil ;};var (Gray2Model =_d .ModelFunc (_ebcbb );Gray4Model =_d .ModelFunc (_eegg );
NRGBA16Model =_d .ModelFunc (_gfeb ););func _fgea (_gec _d .Gray ,_gagf monochromeModel )_d .Gray {if _gec .Y > uint8 (_gagf ){return _d .Gray {Y :_e .MaxUint8 };};return _d .Gray {};};func _edbc (_aacbf RGBA ,_ddcd NRGBA ,_cagb _ec .Rectangle ){for _ccdae :=0;
_ccdae < _cagb .Max .X ;_ccdae ++{for _cbcd :=0;_cbcd < _cagb .Max .Y ;_cbcd ++{_baeg :=_aacbf .RGBAAt (_ccdae ,_cbcd );_ddcd .SetNRGBA (_ccdae ,_cbcd ,_feac (_baeg ));};};};const (PixSrc RasterOperator =0xc;PixDst RasterOperator =0xa;PixNotSrc RasterOperator =0x3;
PixNotDst RasterOperator =0x5;PixClr RasterOperator =0x0;PixSet RasterOperator =0xf;PixSrcOrDst RasterOperator =0xe;PixSrcAndDst RasterOperator =0x8;PixSrcXorDst RasterOperator =0x6;PixNotSrcOrDst RasterOperator =0xb;PixNotSrcAndDst RasterOperator =0x2;
PixSrcOrNotDst RasterOperator =0xd;PixSrcAndNotDst RasterOperator =0x4;PixNotPixSrcOrDst RasterOperator =0x1;PixNotPixSrcAndDst RasterOperator =0x7;PixNotPixSrcXorDst RasterOperator =0x9;PixPaint =PixSrcOrDst ;PixSubtract =PixNotSrcAndDst ;PixMask =PixSrcAndDst ;
);var _ Image =&NRGBA16 {};func _gg (_eg ,_ggb *Monochrome )(_bgg error ){_af :=_ggb .BytesPerLine ;_fg :=_eg .BytesPerLine ;var (_gge byte ;_dg uint16 ;_fge ,_fgd ,_fc ,_gf ,_fd int ;);for _fc =0;_fc < _ggb .Height ;_fc ++{_fge =_fc *_af ;_fgd =2*_fc *_fg ;
for _gf =0;_gf < _af ;_gf ++{_gge =_ggb .Data [_fge +_gf ];_dg =_fad [_gge ];_fd =_fgd +_gf *2;if _eg .BytesPerLine !=_ggb .BytesPerLine *2&&(_gf +1)*2> _eg .BytesPerLine {_bgg =_eg .setByte (_fd ,byte (_dg >>8));}else {_bgg =_eg .setTwoBytes (_fd ,_dg );
};if _bgg !=nil {return _bgg ;};};for _gf =0;_gf < _fg ;_gf ++{_fd =_fgd +_fg +_gf ;_gge =_eg .Data [_fgd +_gf ];if _bgg =_eg .setByte (_fd ,_gge );_bgg !=nil {return _bgg ;};};};return nil ;};func _dbacb (_abdca _ec .Image ,_cfcfb uint8 )*_ec .Gray {_aacc :=_abdca .Bounds ();
_fdeb :=_ec .NewGray (_aacc );var (_abbae _d .Color ;_fcbdg _d .Gray ;);for _dgbd :=0;_dgbd < _aacc .Max .X ;_dgbd ++{for _aceg :=0;_aceg < _aacc .Max .Y ;_aceg ++{_abbae =_abdca .At (_dgbd ,_aceg );_fdeb .Set (_dgbd ,_aceg ,_abbae );_fcbdg =_fdeb .GrayAt (_dgbd ,_aceg );
_fdeb .SetGray (_dgbd ,_aceg ,_d .Gray {Y :_gecc (_fcbdg .Y ,_cfcfb )});};};return _fdeb ;};func (_beecd *NRGBA16 )Base ()*ImageBase {return &_beecd .ImageBase };func (_afba *NRGBA64 )At (x ,y int )_d .Color {_bgce ,_ :=_afba .ColorAt (x ,y );return _bgce };
func _bf (_aad ,_aff *Monochrome )(_ce error ){_afd :=_aff .BytesPerLine ;_cde :=_aad .BytesPerLine ;var _dcf ,_ggg ,_fdg ,_cba ,_ccb int ;for _fdg =0;_fdg < _aff .Height ;_fdg ++{_dcf =_fdg *_afd ;_ggg =8*_fdg *_cde ;for _cba =0;_cba < _afd ;_cba ++{if _ce =_aad .setEightBytes (_ggg +_cba *8,_dgf [_aff .Data [_dcf +_cba ]]);
_ce !=nil {return _ce ;};};for _ccb =1;_ccb < 8;_ccb ++{for _cba =0;_cba < _cde ;_cba ++{if _ce =_aad .setByte (_ggg +_ccb *_cde +_cba ,_aad .Data [_ggg +_cba ]);_ce !=nil {return _ce ;};};};};return nil ;};func (_gbde *Monochrome )getBitAt (_aeec ,_aeag int )bool {_dfbg :=_aeag *_gbde .BytesPerLine +(_aeec >>3);
_cgce :=_aeec &0x07;_cedb :=uint (7-_cgce );if _dfbg > len (_gbde .Data )-1{return false ;};if (_gbde .Data [_dfbg ]>>_cedb )&0x01>=1{return true ;};return false ;};func (_dadc *Monochrome )copy ()*Monochrome {_cdcf :=_cga (_dadc .Width ,_dadc .Height );
_cdcf .ModelThreshold =_dadc .ModelThreshold ;_cdcf .Data =make ([]byte ,len (_dadc .Data ));copy (_cdcf .Data ,_dadc .Data );if len (_dadc .Decode )!=0{_cdcf .Decode =make ([]float64 ,len (_dadc .Decode ));copy (_cdcf .Decode ,_dadc .Decode );};if len (_dadc .Alpha )!=0{_cdcf .Alpha =make ([]byte ,len (_dadc .Alpha ));
copy (_cdcf .Alpha ,_dadc .Alpha );};return _cdcf ;};func (_edab *Monochrome )setBit (_dabg ,_ceca int ){_edab .Data [_dabg +(_ceca >>3)]|=0x80>>uint (_ceca &7);};func _afbc (_fgcdb _ec .Image ,_fddf Image ,_aefb _ec .Rectangle ){if _dddc ,_afgcd :=_fgcdb .(SMasker );
_afgcd &&_dddc .HasAlpha (){_fddf .(SMasker ).MakeAlpha ();};switch _eabf :=_fgcdb .(type ){case Gray :_ggeb (_eabf ,_fddf .(NRGBA ),_aefb );case NRGBA :_ffda (_eabf ,_fddf .(NRGBA ),_aefb );case *_ec .NYCbCrA :_bfda (_eabf ,_fddf .(NRGBA ),_aefb );case CMYK :_beag (_eabf ,_fddf .(NRGBA ),_aefb );
case RGBA :_edbc (_eabf ,_fddf .(NRGBA ),_aefb );case nrgba64 :_eeac (_eabf ,_fddf .(NRGBA ),_aefb );default:_ebda (_fgcdb ,_fddf ,_aefb );};};var _ _ec .Image =&Gray2 {};func _cdaf (_gfced _ec .Image ,_fffe Image ,_bafad _ec .Rectangle ){if _faeg ,_bdcc :=_gfced .(SMasker );
_bdcc &&_faeg .HasAlpha (){_fffe .(SMasker ).MakeAlpha ();};switch _cbed :=_gfced .(type ){case Gray :_afgd (_cbed ,_fffe .(RGBA ),_bafad );case NRGBA :_egecbb (_cbed ,_fffe .(RGBA ),_bafad );case *_ec .NYCbCrA :_gfabf (_cbed ,_fffe .(RGBA ),_bafad );case CMYK :_cgeb (_cbed ,_fffe .(RGBA ),_bafad );
case RGBA :_cbgg (_cbed ,_fffe .(RGBA ),_bafad );case nrgba64 :_eefg (_cbed ,_fffe .(RGBA ),_bafad );default:_ebda (_gfced ,_fffe ,_bafad );};};var _ NRGBA =&NRGBA32 {};func _dfca (_ddbg _ec .Image )(Image ,error ){if _eaa ,_cgg :=_ddbg .(*Gray8 );_cgg {return _eaa .Copy (),nil ;
};_egdg :=_ddbg .Bounds ();_bafa ,_gcgf :=NewImage (_egdg .Max .X ,_egdg .Max .Y ,8,1,nil ,nil ,nil );if _gcgf !=nil {return nil ,_gcgf ;};_dcfd (_ddbg ,_bafa ,_egdg );return _bafa ,nil ;};func _dfde (_fgde _d .NRGBA64 )_d .NRGBA {return _d .NRGBA {R :uint8 (_fgde .R >>8),G :uint8 (_fgde .G >>8),B :uint8 (_fgde .B >>8),A :uint8 (_fgde .A >>8)};
};func _fcf (_ebf ,_dcbb *Monochrome ,_feec []byte ,_abg int )(_baag error ){var (_ggd ,_ccdd ,_dab ,_ddef ,_egb ,_gbea ,_abd ,_bba int ;_fdc ,_dfba ,_dcbe ,_eea uint32 ;_dfa ,_dad byte ;_gef uint16 ;);_fded :=make ([]byte ,4);_fbec :=make ([]byte ,4);
for _dab =0;_dab < _ebf .Height -1;_dab ,_ddef =_dab +2,_ddef +1{_ggd =_dab *_ebf .BytesPerLine ;_ccdd =_ddef *_dcbb .BytesPerLine ;for _egb ,_gbea =0,0;_egb < _abg ;_egb ,_gbea =_egb +4,_gbea +1{for _abd =0;_abd < 4;_abd ++{_bba =_ggd +_egb +_abd ;if _bba <=len (_ebf .Data )-1&&_bba < _ggd +_ebf .BytesPerLine {_fded [_abd ]=_ebf .Data [_bba ];
}else {_fded [_abd ]=0x00;};_bba =_ggd +_ebf .BytesPerLine +_egb +_abd ;if _bba <=len (_ebf .Data )-1&&_bba < _ggd +(2*_ebf .BytesPerLine ){_fbec [_abd ]=_ebf .Data [_bba ];}else {_fbec [_abd ]=0x00;};};_fdc =_b .BigEndian .Uint32 (_fded );_dfba =_b .BigEndian .Uint32 (_fbec );
_dcbe =_fdc &_dfba ;_dcbe |=_dcbe <<1;_eea =_fdc |_dfba ;_eea &=_eea <<1;_dfba =_dcbe |_eea ;_dfba &=0xaaaaaaaa;_fdc =_dfba |(_dfba <<7);_dfa =byte (_fdc >>24);_dad =byte ((_fdc >>8)&0xff);_bba =_ccdd +_gbea ;if _bba +1==len (_dcbb .Data )-1||_bba +1>=_ccdd +_dcbb .BytesPerLine {if _baag =_dcbb .setByte (_bba ,_feec [_dfa ]);
_baag !=nil {return _ba .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_bba );};}else {_gef =(uint16 (_feec [_dfa ])<<8)|uint16 (_feec [_dad ]);if _baag =_dcbb .setTwoBytes (_bba ,_gef );_baag !=nil {return _ba .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_bba );
};_gbea ++;};};};return nil ;};func _dcd (_fdba CMYK ,_dgfc Gray ,_fegc _ec .Rectangle ){for _dbgd :=0;_dbgd < _fegc .Max .X ;_dbgd ++{for _fbcbg :=0;_fbcbg < _fegc .Max .Y ;_fbcbg ++{_gfaf :=_aged (_fdba .CMYKAt (_dbgd ,_fbcbg ));_dgfc .SetGray (_dbgd ,_fbcbg ,_gfaf );
};};};func (_afb *Gray4 )Set (x ,y int ,c _d .Color ){if x >=_afb .Width ||y >=_afb .Height {return ;};_bdfd :=Gray4Model .Convert (c ).(_d .Gray );_afb .setGray (x ,y ,_bdfd );};func (_gffb *ImageBase )copy ()ImageBase {_aag :=*_gffb ;_aag .Data =make ([]byte ,len (_gffb .Data ));
copy (_aag .Data ,_gffb .Data );return _aag ;};func _ggab (_dgga _ec .Image ,_fef int )(_ec .Rectangle ,bool ,[]byte ){_eeabg :=_dgga .Bounds ();var (_beece bool ;_bdfb []byte ;);switch _bcdfg :=_dgga .(type ){case SMasker :_beece =_bcdfg .HasAlpha ();
case NRGBA ,RGBA ,*_ec .RGBA64 ,nrgba64 ,*_ec .NYCbCrA :_bdfb =make ([]byte ,_eeabg .Max .X *_eeabg .Max .Y *_fef );case *_ec .Paletted :var _efebe bool ;for _ ,_aafd :=range _bcdfg .Palette {_efade ,_gggd ,_gefgb ,_gedb :=_aafd .RGBA ();if _efade ==0&&_gggd ==0&&_gefgb ==0&&_gedb !=0{_efebe =true ;
break ;};};if _efebe {_bdfb =make ([]byte ,_eeabg .Max .X *_eeabg .Max .Y *_fef );};};return _eeabg ,_beece ,_bdfb ;};func ColorAtNRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_d .NRGBA ,error ){_gbgc :=y *width +x ;_acd :=3*_gbgc ;if _acd +2>=len (data ){return _d .NRGBA {},_ba .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_eaac :=uint8 (0xff);if alpha !=nil &&len (alpha )> _gbgc {_eaac =alpha [_gbgc ];};_cbdg ,_bfabc ,_cdbe :=data [_acd ],data [_acd +1],data [_acd +2];if len (decode )==6{_cbdg =uint8 (uint32 (LinearInterpolate (float64 (_cbdg ),0,255,decode [0],decode [1]))&0xff);
_bfabc =uint8 (uint32 (LinearInterpolate (float64 (_bfabc ),0,255,decode [2],decode [3]))&0xff);_cdbe =uint8 (uint32 (LinearInterpolate (float64 (_cdbe ),0,255,decode [4],decode [5]))&0xff);};return _d .NRGBA {R :_cbdg ,G :_bfabc ,B :_cdbe ,A :_eaac },nil ;
};var _ Image =&CMYK32 {};func _gabd (_eacae _ec .Image )(Image ,error ){if _ceeb ,_egafg :=_eacae .(*RGBA32 );_egafg {return _ceeb .Copy (),nil ;};_fcbg ,_bbde ,_ecfdd :=_ggab (_eacae ,1);_afcd :=&RGBA32 {ImageBase :NewImageBase (_fcbg .Max .X ,_fcbg .Max .Y ,8,3,nil ,_ecfdd ,nil )};
_cdaf (_eacae ,_afcd ,_fcbg );if len (_ecfdd )!=0&&!_bbde {if _fdbd :=_gdab (_ecfdd ,_afcd );_fdbd !=nil {return nil ,_fdbd ;};};return _afcd ,nil ;};func ScaleAlphaToMonochrome (data []byte ,width ,height int )([]byte ,error ){_da :=BytesPerLine (width ,8,1);
if len (data )< _da *height {return nil ,nil ;};_bg :=&Gray8 {NewImageBase (width ,height ,8,1,data ,nil ,nil )};_ea ,_ff :=MonochromeConverter .Convert (_bg );if _ff !=nil {return nil ,_ff ;};return _ea .Base ().Data ,nil ;};func (_dfdg *Gray8 )Bounds ()_ec .Rectangle {return _ec .Rectangle {Max :_ec .Point {X :_dfdg .Width ,Y :_dfdg .Height }};
};func (_adbd *NRGBA16 )Set (x ,y int ,c _d .Color ){_agfda :=y *_adbd .BytesPerLine +x *3/2;if _agfda +1>=len (_adbd .Data ){return ;};_bbbc :=NRGBA16Model .Convert (c ).(_d .NRGBA );_adbd .setNRGBA (x ,y ,_agfda ,_bbbc );};func NextPowerOf2 (n uint )uint {if IsPowerOf2 (n ){return n ;
};return 1<<(_fbab (n )+1);};func (_abdeg *NRGBA64 )Base ()*ImageBase {return &_abdeg .ImageBase };func ImgToBinary (i _ec .Image ,threshold uint8 )*_ec .Gray {switch _egdf :=i .(type ){case *_ec .Gray :if _afff (_egdf ){return _egdf ;};return _dedcf (_egdf ,threshold );
case *_ec .Gray16 :return _fbcg (_egdf ,threshold );default:return _dbacb (_egdf ,threshold );};};func (_cda *NRGBA32 )At (x ,y int )_d .Color {_cbcf ,_ :=_cda .ColorAt (x ,y );return _cbcf };func (_dcdg *ImageBase )setEightFullBytes (_bcad int ,_deed uint64 )error {if _bcad +7> len (_dcdg .Data )-1{return _c .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_dcdg .Data [_bcad ]=byte ((_deed &0xff00000000000000)>>56);_dcdg .Data [_bcad +1]=byte ((_deed &0xff000000000000)>>48);_dcdg .Data [_bcad +2]=byte ((_deed &0xff0000000000)>>40);_dcdg .Data [_bcad +3]=byte ((_deed &0xff00000000)>>32);_dcdg .Data [_bcad +4]=byte ((_deed &0xff000000)>>24);
_dcdg .Data [_bcad +5]=byte ((_deed &0xff0000)>>16);_dcdg .Data [_bcad +6]=byte ((_deed &0xff00)>>8);_dcdg .Data [_bcad +7]=byte (_deed &0xff);return nil ;};func _ecgae (_acfcg *Monochrome ,_ggff ,_bda ,_ageb ,_dafe int ,_eefe RasterOperator ,_bbge *Monochrome ,_fgcd ,_bbgf int )error {var (_dbgb bool ;
_dgeb bool ;_cdcc byte ;_dcgae int ;_gdgf int ;_geea int ;_fffc int ;_cfeg bool ;_eagf int ;_fae int ;_cebf int ;_edce bool ;_cfcd byte ;_gegfc int ;_afbb int ;_cefga int ;_bagb byte ;_bbgc int ;_fdege int ;_cbdf uint ;_bfca uint ;_cefc byte ;_cbbed shift ;
_efcfe bool ;_bfcb bool ;_gdgd ,_afab int ;);if _fgcd &7!=0{_fdege =8-(_fgcd &7);};if _ggff &7!=0{_gdgf =8-(_ggff &7);};if _fdege ==0&&_gdgf ==0{_cefc =_eefb [0];}else {if _gdgf > _fdege {_cbdf =uint (_gdgf -_fdege );}else {_cbdf =uint (8-(_fdege -_gdgf ));
};_bfca =8-_cbdf ;_cefc =_eefb [_cbdf ];};if (_ggff &7)!=0{_dbgb =true ;_dcgae =8-(_ggff &7);_cdcc =_eefb [_dcgae ];_geea =_acfcg .BytesPerLine *_bda +(_ggff >>3);_fffc =_bbge .BytesPerLine *_bbgf +(_fgcd >>3);_bbgc =8-(_fgcd &7);if _dcgae > _bbgc {_cbbed =_ebcdg ;
if _ageb >=_fdege {_efcfe =true ;};}else {_cbbed =_egge ;};};if _ageb < _dcgae {_dgeb =true ;_cdcc &=_aaaa [8-_dcgae +_ageb ];};if !_dgeb {_eagf =(_ageb -_dcgae )>>3;if _eagf !=0{_cfeg =true ;_fae =_acfcg .BytesPerLine *_bda +((_ggff +_gdgf )>>3);_cebf =_bbge .BytesPerLine *_bbgf +((_fgcd +_gdgf )>>3);
};};_gegfc =(_ggff +_ageb )&7;if !(_dgeb ||_gegfc ==0){_edce =true ;_cfcd =_aaaa [_gegfc ];_afbb =_acfcg .BytesPerLine *_bda +((_ggff +_gdgf )>>3)+_eagf ;_cefga =_bbge .BytesPerLine *_bbgf +((_fgcd +_gdgf )>>3)+_eagf ;if _gegfc > int (_bfca ){_bfcb =true ;
};};switch _eefe {case PixSrc :if _dbgb {for _gdgd =0;_gdgd < _dafe ;_gdgd ++{if _cbbed ==_ebcdg {_bagb =_bbge .Data [_fffc ]<<_cbdf ;if _efcfe {_bagb =_cdea (_bagb ,_bbge .Data [_fffc +1]>>_bfca ,_cefc );};}else {_bagb =_bbge .Data [_fffc ]>>_bfca ;};
_acfcg .Data [_geea ]=_cdea (_acfcg .Data [_geea ],_bagb ,_cdcc );_geea +=_acfcg .BytesPerLine ;_fffc +=_bbge .BytesPerLine ;};};if _cfeg {for _gdgd =0;_gdgd < _dafe ;_gdgd ++{for _afab =0;_afab < _eagf ;_afab ++{_bagb =_cdea (_bbge .Data [_cebf +_afab ]<<_cbdf ,_bbge .Data [_cebf +_afab +1]>>_bfca ,_cefc );
_acfcg .Data [_fae +_afab ]=_bagb ;};_fae +=_acfcg .BytesPerLine ;_cebf +=_bbge .BytesPerLine ;};};if _edce {for _gdgd =0;_gdgd < _dafe ;_gdgd ++{_bagb =_bbge .Data [_cefga ]<<_cbdf ;if _bfcb {_bagb =_cdea (_bagb ,_bbge .Data [_cefga +1]>>_bfca ,_cefc );
};_acfcg .Data [_afbb ]=_cdea (_acfcg .Data [_afbb ],_bagb ,_cfcd );_afbb +=_acfcg .BytesPerLine ;_cefga +=_bbge .BytesPerLine ;};};case PixNotSrc :if _dbgb {for _gdgd =0;_gdgd < _dafe ;_gdgd ++{if _cbbed ==_ebcdg {_bagb =_bbge .Data [_fffc ]<<_cbdf ;if _efcfe {_bagb =_cdea (_bagb ,_bbge .Data [_fffc +1]>>_bfca ,_cefc );
};}else {_bagb =_bbge .Data [_fffc ]>>_bfca ;};_acfcg .Data [_geea ]=_cdea (_acfcg .Data [_geea ],^_bagb ,_cdcc );_geea +=_acfcg .BytesPerLine ;_fffc +=_bbge .BytesPerLine ;};};if _cfeg {for _gdgd =0;_gdgd < _dafe ;_gdgd ++{for _afab =0;_afab < _eagf ;
_afab ++{_bagb =_cdea (_bbge .Data [_cebf +_afab ]<<_cbdf ,_bbge .Data [_cebf +_afab +1]>>_bfca ,_cefc );_acfcg .Data [_fae +_afab ]=^_bagb ;};_fae +=_acfcg .BytesPerLine ;_cebf +=_bbge .BytesPerLine ;};};if _edce {for _gdgd =0;_gdgd < _dafe ;_gdgd ++{_bagb =_bbge .Data [_cefga ]<<_cbdf ;
if _bfcb {_bagb =_cdea (_bagb ,_bbge .Data [_cefga +1]>>_bfca ,_cefc );};_acfcg .Data [_afbb ]=_cdea (_acfcg .Data [_afbb ],^_bagb ,_cfcd );_afbb +=_acfcg .BytesPerLine ;_cefga +=_bbge .BytesPerLine ;};};case PixSrcOrDst :if _dbgb {for _gdgd =0;_gdgd < _dafe ;
_gdgd ++{if _cbbed ==_ebcdg {_bagb =_bbge .Data [_fffc ]<<_cbdf ;if _efcfe {_bagb =_cdea (_bagb ,_bbge .Data [_fffc +1]>>_bfca ,_cefc );};}else {_bagb =_bbge .Data [_fffc ]>>_bfca ;};_acfcg .Data [_geea ]=_cdea (_acfcg .Data [_geea ],_bagb |_acfcg .Data [_geea ],_cdcc );
_geea +=_acfcg .BytesPerLine ;_fffc +=_bbge .BytesPerLine ;};};if _cfeg {for _gdgd =0;_gdgd < _dafe ;_gdgd ++{for _afab =0;_afab < _eagf ;_afab ++{_bagb =_cdea (_bbge .Data [_cebf +_afab ]<<_cbdf ,_bbge .Data [_cebf +_afab +1]>>_bfca ,_cefc );_acfcg .Data [_fae +_afab ]|=_bagb ;
};_fae +=_acfcg .BytesPerLine ;_cebf +=_bbge .BytesPerLine ;};};if _edce {for _gdgd =0;_gdgd < _dafe ;_gdgd ++{_bagb =_bbge .Data [_cefga ]<<_cbdf ;if _bfcb {_bagb =_cdea (_bagb ,_bbge .Data [_cefga +1]>>_bfca ,_cefc );};_acfcg .Data [_afbb ]=_cdea (_acfcg .Data [_afbb ],_bagb |_acfcg .Data [_afbb ],_cfcd );
_afbb +=_acfcg .BytesPerLine ;_cefga +=_bbge .BytesPerLine ;};};case PixSrcAndDst :if _dbgb {for _gdgd =0;_gdgd < _dafe ;_gdgd ++{if _cbbed ==_ebcdg {_bagb =_bbge .Data [_fffc ]<<_cbdf ;if _efcfe {_bagb =_cdea (_bagb ,_bbge .Data [_fffc +1]>>_bfca ,_cefc );
};}else {_bagb =_bbge .Data [_fffc ]>>_bfca ;};_acfcg .Data [_geea ]=_cdea (_acfcg .Data [_geea ],_bagb &_acfcg .Data [_geea ],_cdcc );_geea +=_acfcg .BytesPerLine ;_fffc +=_bbge .BytesPerLine ;};};if _cfeg {for _gdgd =0;_gdgd < _dafe ;_gdgd ++{for _afab =0;
_afab < _eagf ;_afab ++{_bagb =_cdea (_bbge .Data [_cebf +_afab ]<<_cbdf ,_bbge .Data [_cebf +_afab +1]>>_bfca ,_cefc );_acfcg .Data [_fae +_afab ]&=_bagb ;};_fae +=_acfcg .BytesPerLine ;_cebf +=_bbge .BytesPerLine ;};};if _edce {for _gdgd =0;_gdgd < _dafe ;
_gdgd ++{_bagb =_bbge .Data [_cefga ]<<_cbdf ;if _bfcb {_bagb =_cdea (_bagb ,_bbge .Data [_cefga +1]>>_bfca ,_cefc );};_acfcg .Data [_afbb ]=_cdea (_acfcg .Data [_afbb ],_bagb &_acfcg .Data [_afbb ],_cfcd );_afbb +=_acfcg .BytesPerLine ;_cefga +=_bbge .BytesPerLine ;
};};case PixSrcXorDst :if _dbgb {for _gdgd =0;_gdgd < _dafe ;_gdgd ++{if _cbbed ==_ebcdg {_bagb =_bbge .Data [_fffc ]<<_cbdf ;if _efcfe {_bagb =_cdea (_bagb ,_bbge .Data [_fffc +1]>>_bfca ,_cefc );};}else {_bagb =_bbge .Data [_fffc ]>>_bfca ;};_acfcg .Data [_geea ]=_cdea (_acfcg .Data [_geea ],_bagb ^_acfcg .Data [_geea ],_cdcc );
_geea +=_acfcg .BytesPerLine ;_fffc +=_bbge .BytesPerLine ;};};if _cfeg {for _gdgd =0;_gdgd < _dafe ;_gdgd ++{for _afab =0;_afab < _eagf ;_afab ++{_bagb =_cdea (_bbge .Data [_cebf +_afab ]<<_cbdf ,_bbge .Data [_cebf +_afab +1]>>_bfca ,_cefc );_acfcg .Data [_fae +_afab ]^=_bagb ;
};_fae +=_acfcg .BytesPerLine ;_cebf +=_bbge .BytesPerLine ;};};if _edce {for _gdgd =0;_gdgd < _dafe ;_gdgd ++{_bagb =_bbge .Data [_cefga ]<<_cbdf ;if _bfcb {_bagb =_cdea (_bagb ,_bbge .Data [_cefga +1]>>_bfca ,_cefc );};_acfcg .Data [_afbb ]=_cdea (_acfcg .Data [_afbb ],_bagb ^_acfcg .Data [_afbb ],_cfcd );
_afbb +=_acfcg .BytesPerLine ;_cefga +=_bbge .BytesPerLine ;};};case PixNotSrcOrDst :if _dbgb {for _gdgd =0;_gdgd < _dafe ;_gdgd ++{if _cbbed ==_ebcdg {_bagb =_bbge .Data [_fffc ]<<_cbdf ;if _efcfe {_bagb =_cdea (_bagb ,_bbge .Data [_fffc +1]>>_bfca ,_cefc );
};}else {_bagb =_bbge .Data [_fffc ]>>_bfca ;};_acfcg .Data [_geea ]=_cdea (_acfcg .Data [_geea ],^_bagb |_acfcg .Data [_geea ],_cdcc );_geea +=_acfcg .BytesPerLine ;_fffc +=_bbge .BytesPerLine ;};};if _cfeg {for _gdgd =0;_gdgd < _dafe ;_gdgd ++{for _afab =0;
_afab < _eagf ;_afab ++{_bagb =_cdea (_bbge .Data [_cebf +_afab ]<<_cbdf ,_bbge .Data [_cebf +_afab +1]>>_bfca ,_cefc );_acfcg .Data [_fae +_afab ]|=^_bagb ;};_fae +=_acfcg .BytesPerLine ;_cebf +=_bbge .BytesPerLine ;};};if _edce {for _gdgd =0;_gdgd < _dafe ;
_gdgd ++{_bagb =_bbge .Data [_cefga ]<<_cbdf ;if _bfcb {_bagb =_cdea (_bagb ,_bbge .Data [_cefga +1]>>_bfca ,_cefc );};_acfcg .Data [_afbb ]=_cdea (_acfcg .Data [_afbb ],^_bagb |_acfcg .Data [_afbb ],_cfcd );_afbb +=_acfcg .BytesPerLine ;_cefga +=_bbge .BytesPerLine ;
};};case PixNotSrcAndDst :if _dbgb {for _gdgd =0;_gdgd < _dafe ;_gdgd ++{if _cbbed ==_ebcdg {_bagb =_bbge .Data [_fffc ]<<_cbdf ;if _efcfe {_bagb =_cdea (_bagb ,_bbge .Data [_fffc +1]>>_bfca ,_cefc );};}else {_bagb =_bbge .Data [_fffc ]>>_bfca ;};_acfcg .Data [_geea ]=_cdea (_acfcg .Data [_geea ],^_bagb &_acfcg .Data [_geea ],_cdcc );
_geea +=_acfcg .BytesPerLine ;_fffc +=_bbge .BytesPerLine ;};};if _cfeg {for _gdgd =0;_gdgd < _dafe ;_gdgd ++{for _afab =0;_afab < _eagf ;_afab ++{_bagb =_cdea (_bbge .Data [_cebf +_afab ]<<_cbdf ,_bbge .Data [_cebf +_afab +1]>>_bfca ,_cefc );_acfcg .Data [_fae +_afab ]&=^_bagb ;
};_fae +=_acfcg .BytesPerLine ;_cebf +=_bbge .BytesPerLine ;};};if _edce {for _gdgd =0;_gdgd < _dafe ;_gdgd ++{_bagb =_bbge .Data [_cefga ]<<_cbdf ;if _bfcb {_bagb =_cdea (_bagb ,_bbge .Data [_cefga +1]>>_bfca ,_cefc );};_acfcg .Data [_afbb ]=_cdea (_acfcg .Data [_afbb ],^_bagb &_acfcg .Data [_afbb ],_cfcd );
_afbb +=_acfcg .BytesPerLine ;_cefga +=_bbge .BytesPerLine ;};};case PixSrcOrNotDst :if _dbgb {for _gdgd =0;_gdgd < _dafe ;_gdgd ++{if _cbbed ==_ebcdg {_bagb =_bbge .Data [_fffc ]<<_cbdf ;if _efcfe {_bagb =_cdea (_bagb ,_bbge .Data [_fffc +1]>>_bfca ,_cefc );
};}else {_bagb =_bbge .Data [_fffc ]>>_bfca ;};_acfcg .Data [_geea ]=_cdea (_acfcg .Data [_geea ],_bagb |^_acfcg .Data [_geea ],_cdcc );_geea +=_acfcg .BytesPerLine ;_fffc +=_bbge .BytesPerLine ;};};if _cfeg {for _gdgd =0;_gdgd < _dafe ;_gdgd ++{for _afab =0;
_afab < _eagf ;_afab ++{_bagb =_cdea (_bbge .Data [_cebf +_afab ]<<_cbdf ,_bbge .Data [_cebf +_afab +1]>>_bfca ,_cefc );_acfcg .Data [_fae +_afab ]=_bagb |^_acfcg .Data [_fae +_afab ];};_fae +=_acfcg .BytesPerLine ;_cebf +=_bbge .BytesPerLine ;};};if _edce {for _gdgd =0;
_gdgd < _dafe ;_gdgd ++{_bagb =_bbge .Data [_cefga ]<<_cbdf ;if _bfcb {_bagb =_cdea (_bagb ,_bbge .Data [_cefga +1]>>_bfca ,_cefc );};_acfcg .Data [_afbb ]=_cdea (_acfcg .Data [_afbb ],_bagb |^_acfcg .Data [_afbb ],_cfcd );_afbb +=_acfcg .BytesPerLine ;
_cefga +=_bbge .BytesPerLine ;};};case PixSrcAndNotDst :if _dbgb {for _gdgd =0;_gdgd < _dafe ;_gdgd ++{if _cbbed ==_ebcdg {_bagb =_bbge .Data [_fffc ]<<_cbdf ;if _efcfe {_bagb =_cdea (_bagb ,_bbge .Data [_fffc +1]>>_bfca ,_cefc );};}else {_bagb =_bbge .Data [_fffc ]>>_bfca ;
};_acfcg .Data [_geea ]=_cdea (_acfcg .Data [_geea ],_bagb &^_acfcg .Data [_geea ],_cdcc );_geea +=_acfcg .BytesPerLine ;_fffc +=_bbge .BytesPerLine ;};};if _cfeg {for _gdgd =0;_gdgd < _dafe ;_gdgd ++{for _afab =0;_afab < _eagf ;_afab ++{_bagb =_cdea (_bbge .Data [_cebf +_afab ]<<_cbdf ,_bbge .Data [_cebf +_afab +1]>>_bfca ,_cefc );
_acfcg .Data [_fae +_afab ]=_bagb &^_acfcg .Data [_fae +_afab ];};_fae +=_acfcg .BytesPerLine ;_cebf +=_bbge .BytesPerLine ;};};if _edce {for _gdgd =0;_gdgd < _dafe ;_gdgd ++{_bagb =_bbge .Data [_cefga ]<<_cbdf ;if _bfcb {_bagb =_cdea (_bagb ,_bbge .Data [_cefga +1]>>_bfca ,_cefc );
};_acfcg .Data [_afbb ]=_cdea (_acfcg .Data [_afbb ],_bagb &^_acfcg .Data [_afbb ],_cfcd );_afbb +=_acfcg .BytesPerLine ;_cefga +=_bbge .BytesPerLine ;};};case PixNotPixSrcOrDst :if _dbgb {for _gdgd =0;_gdgd < _dafe ;_gdgd ++{if _cbbed ==_ebcdg {_bagb =_bbge .Data [_fffc ]<<_cbdf ;
if _efcfe {_bagb =_cdea (_bagb ,_bbge .Data [_fffc +1]>>_bfca ,_cefc );};}else {_bagb =_bbge .Data [_fffc ]>>_bfca ;};_acfcg .Data [_geea ]=_cdea (_acfcg .Data [_geea ],^(_bagb |_acfcg .Data [_geea ]),_cdcc );_geea +=_acfcg .BytesPerLine ;_fffc +=_bbge .BytesPerLine ;
};};if _cfeg {for _gdgd =0;_gdgd < _dafe ;_gdgd ++{for _afab =0;_afab < _eagf ;_afab ++{_bagb =_cdea (_bbge .Data [_cebf +_afab ]<<_cbdf ,_bbge .Data [_cebf +_afab +1]>>_bfca ,_cefc );_acfcg .Data [_fae +_afab ]=^(_bagb |_acfcg .Data [_fae +_afab ]);};
_fae +=_acfcg .BytesPerLine ;_cebf +=_bbge .BytesPerLine ;};};if _edce {for _gdgd =0;_gdgd < _dafe ;_gdgd ++{_bagb =_bbge .Data [_cefga ]<<_cbdf ;if _bfcb {_bagb =_cdea (_bagb ,_bbge .Data [_cefga +1]>>_bfca ,_cefc );};_acfcg .Data [_afbb ]=_cdea (_acfcg .Data [_afbb ],^(_bagb |_acfcg .Data [_afbb ]),_cfcd );
_afbb +=_acfcg .BytesPerLine ;_cefga +=_bbge .BytesPerLine ;};};case PixNotPixSrcAndDst :if _dbgb {for _gdgd =0;_gdgd < _dafe ;_gdgd ++{if _cbbed ==_ebcdg {_bagb =_bbge .Data [_fffc ]<<_cbdf ;if _efcfe {_bagb =_cdea (_bagb ,_bbge .Data [_fffc +1]>>_bfca ,_cefc );
};}else {_bagb =_bbge .Data [_fffc ]>>_bfca ;};_acfcg .Data [_geea ]=_cdea (_acfcg .Data [_geea ],^(_bagb &_acfcg .Data [_geea ]),_cdcc );_geea +=_acfcg .BytesPerLine ;_fffc +=_bbge .BytesPerLine ;};};if _cfeg {for _gdgd =0;_gdgd < _dafe ;_gdgd ++{for _afab =0;
_afab < _eagf ;_afab ++{_bagb =_cdea (_bbge .Data [_cebf +_afab ]<<_cbdf ,_bbge .Data [_cebf +_afab +1]>>_bfca ,_cefc );_acfcg .Data [_fae +_afab ]=^(_bagb &_acfcg .Data [_fae +_afab ]);};_fae +=_acfcg .BytesPerLine ;_cebf +=_bbge .BytesPerLine ;};};if _edce {for _gdgd =0;
_gdgd < _dafe ;_gdgd ++{_bagb =_bbge .Data [_cefga ]<<_cbdf ;if _bfcb {_bagb =_cdea (_bagb ,_bbge .Data [_cefga +1]>>_bfca ,_cefc );};_acfcg .Data [_afbb ]=_cdea (_acfcg .Data [_afbb ],^(_bagb &_acfcg .Data [_afbb ]),_cfcd );_afbb +=_acfcg .BytesPerLine ;
_cefga +=_bbge .BytesPerLine ;};};case PixNotPixSrcXorDst :if _dbgb {for _gdgd =0;_gdgd < _dafe ;_gdgd ++{if _cbbed ==_ebcdg {_bagb =_bbge .Data [_fffc ]<<_cbdf ;if _efcfe {_bagb =_cdea (_bagb ,_bbge .Data [_fffc +1]>>_bfca ,_cefc );};}else {_bagb =_bbge .Data [_fffc ]>>_bfca ;
};_acfcg .Data [_geea ]=_cdea (_acfcg .Data [_geea ],^(_bagb ^_acfcg .Data [_geea ]),_cdcc );_geea +=_acfcg .BytesPerLine ;_fffc +=_bbge .BytesPerLine ;};};if _cfeg {for _gdgd =0;_gdgd < _dafe ;_gdgd ++{for _afab =0;_afab < _eagf ;_afab ++{_bagb =_cdea (_bbge .Data [_cebf +_afab ]<<_cbdf ,_bbge .Data [_cebf +_afab +1]>>_bfca ,_cefc );
_acfcg .Data [_fae +_afab ]=^(_bagb ^_acfcg .Data [_fae +_afab ]);};_fae +=_acfcg .BytesPerLine ;_cebf +=_bbge .BytesPerLine ;};};if _edce {for _gdgd =0;_gdgd < _dafe ;_gdgd ++{_bagb =_bbge .Data [_cefga ]<<_cbdf ;if _bfcb {_bagb =_cdea (_bagb ,_bbge .Data [_cefga +1]>>_bfca ,_cefc );
};_acfcg .Data [_afbb ]=_cdea (_acfcg .Data [_afbb ],^(_bagb ^_acfcg .Data [_afbb ]),_cfcd );_afbb +=_acfcg .BytesPerLine ;_cefga +=_bbge .BytesPerLine ;};};default:_ca .Log .Debug ("\u004f\u0070e\u0072\u0061\u0074\u0069\u006f\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006e\u006f\u0074\u0020\u0070\u0065\u0072\u006d\u0069tt\u0065\u0064",_eefe );
return _c .New ("\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065r\u0061\u0074\u0069\u006f\u006e\u0020\u006eo\u0074\u0020\u0070\u0065\u0072\u006d\u0069\u0074\u0074\u0065\u0064");};return nil ;};func (_acgea *NRGBA32 )Set (x ,y int ,c _d .Color ){_ffeb :=y *_acgea .Width +x ;
_bbcb :=3*_ffeb ;if _bbcb +2>=len (_acgea .Data ){return ;};_fcabc :=_d .NRGBAModel .Convert (c ).(_d .NRGBA );_acgea .setRGBA (_ffeb ,_fcabc );};func (_gcbc *Gray16 )Copy ()Image {return &Gray16 {ImageBase :_gcbc .copy ()}};func _dec (_fgb Gray ,_gfe nrgba64 ,_dcbc _ec .Rectangle ){for _ecfdc :=0;
_ecfdc < _dcbc .Max .X ;_ecfdc ++{for _ddefe :=0;_ddefe < _dcbc .Max .Y ;_ddefe ++{_ccf :=_bbc (_gfe .NRGBA64At (_ecfdc ,_ddefe ));_fgb .SetGray (_ecfdc ,_ddefe ,_ccf );};};};func (_bbdg *NRGBA32 )SetNRGBA (x ,y int ,c _d .NRGBA ){_ccea :=y *_bbdg .Width +x ;
_cebb :=3*_ccea ;if _cebb +2>=len (_bbdg .Data ){return ;};_bbdg .setRGBA (_ccea ,c );};func (_egbc *Monochrome )getBit (_caf ,_fec int )uint8 {return _egbc .Data [_caf +(_fec >>3)]>>uint (7-(_fec &7))&1;};func (_ffdb *Gray2 )ColorModel ()_d .Model {return Gray2Model };
func (_abb *CMYK32 )At (x ,y int )_d .Color {_abgd ,_ :=_abb .ColorAt (x ,y );return _abgd };func (_gaac *Monochrome )ResolveDecode ()error {if len (_gaac .Decode )!=2{return nil ;};if _gaac .Decode [0]==1&&_gaac .Decode [1]==0{if _ageef :=_gaac .InverseData ();
_ageef !=nil {return _ageef ;};_gaac .Decode =nil ;};return nil ;};func _dedcf (_gdgg *_ec .Gray ,_egbf uint8 )*_ec .Gray {_efff :=_gdgg .Bounds ();_bgaea :=_ec .NewGray (_efff );for _cbgga :=0;_cbgga < _efff .Dx ();_cbgga ++{for _ecef :=0;_ecef < _efff .Dy ();
_ecef ++{_aadag :=_gdgg .GrayAt (_cbgga ,_ecef );_bgaea .SetGray (_cbgga ,_ecef ,_d .Gray {Y :_gecc (_aadag .Y ,_egbf )});};};return _bgaea ;};func _ebda (_cbee _ec .Image ,_edc Image ,_fdcc _ec .Rectangle ){for _ecg :=0;_ecg < _fdcc .Max .X ;_ecg ++{for _cdeg :=0;
_cdeg < _fdcc .Max .Y ;_cdeg ++{_eeb :=_cbee .At (_ecg ,_cdeg );_edc .Set (_ecg ,_cdeg ,_eeb );};};};func (_gcd *Monochrome )Bounds ()_ec .Rectangle {return _ec .Rectangle {Max :_ec .Point {X :_gcd .Width ,Y :_gcd .Height }};};func (_ada *CMYK32 )Validate ()error {if len (_ada .Data )!=4*_ada .Width *_ada .Height {return _c .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};type RGBA interface{RGBAAt (_fcfdb ,_dcca int )_d .RGBA ;SetRGBA (_gdcfa ,_adabg int ,_adcaa _d .RGBA );};func _egfd (_dfbfa _ec .Image )(Image ,error ){if _afee ,_accgf :=_dfbfa .(*NRGBA32 );_accgf {return _afee .Copy (),nil ;};_dgbg ,_afca ,_ccae :=_ggab (_dfbfa ,1);
_gacg ,_cddb :=NewImage (_dgbg .Max .X ,_dgbg .Max .Y ,8,3,nil ,_ccae ,nil );if _cddb !=nil {return nil ,_cddb ;};_afbc (_dfbfa ,_gacg ,_dgbg );if len (_ccae )!=0&&!_afca {if _cea :=_gdab (_ccae ,_gacg );_cea !=nil {return nil ,_cea ;};};return _gacg ,nil ;
};func _gea (_feag _ec .Image )(Image ,error ){if _faab ,_abccc :=_feag .(*Gray2 );_abccc {return _faab .Copy (),nil ;};_ddfd :=_feag .Bounds ();_gefcc ,_edgf :=NewImage (_ddfd .Max .X ,_ddfd .Max .Y ,2,1,nil ,nil ,nil );if _edgf !=nil {return nil ,_edgf ;
};_dcfd (_feag ,_gefcc ,_ddfd );return _gefcc ,nil ;};func _dgad (_efdcc *Monochrome ,_fbfb ,_cbaa ,_cecb ,_bfab int ,_efebf RasterOperator ){if _fbfb < 0{_cecb +=_fbfb ;_fbfb =0;};_eaff :=_fbfb +_cecb -_efdcc .Width ;if _eaff > 0{_cecb -=_eaff ;};if _cbaa < 0{_bfab +=_cbaa ;
_cbaa =0;};_adgc :=_cbaa +_bfab -_efdcc .Height ;if _adgc > 0{_bfab -=_adgc ;};if _cecb <=0||_bfab <=0{return ;};if (_fbfb &7)==0{_fdgf (_efdcc ,_fbfb ,_cbaa ,_cecb ,_bfab ,_efebf );}else {_efefb (_efdcc ,_fbfb ,_cbaa ,_cecb ,_bfab ,_efebf );};};func _adb ()(_ddaf []byte ){_ddaf =make ([]byte ,256);
for _ecf :=0;_ecf < 256;_ecf ++{_bfac :=byte (_ecf );_ddaf [_bfac ]=(_bfac &0x01)|((_bfac &0x04)>>1)|((_bfac &0x10)>>2)|((_bfac &0x40)>>3)|((_bfac &0x02)<<3)|((_bfac &0x08)<<2)|((_bfac &0x20)<<1)|(_bfac &0x80);};return _ddaf ;};type NRGBA16 struct{ImageBase };
func (_afbbde *RGBA32 )Validate ()error {if len (_afbbde .Data )!=3*_afbbde .Width *_afbbde .Height {return _c .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func (_bcae *NRGBA32 )ColorModel ()_d .Model {return _d .NRGBAModel };func _efg (_fcb *Monochrome ,_cee ...int )(_cfa *Monochrome ,_aeg error ){if _fcb ==nil {return nil ,_c .New ("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d");
};if len (_cee )==0{return nil ,_c .New ("\u0074h\u0065\u0072e\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0061\u0074 \u006c\u0065\u0061\u0073\u0074\u0020o\u006e\u0065\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u006f\u0066 \u0072\u0065\u0064\u0075\u0063\u0074\u0069\u006f\u006e");
};_fe :=_adb ();_cfa =_fcb ;for _ ,_ecd :=range _cee {if _ecd <=0{break ;};_cfa ,_aeg =_cfc (_cfa ,_ecd ,_fe );if _aeg !=nil {return nil ,_aeg ;};};return _cfa ,nil ;};type Gray interface{GrayAt (_ebcb ,_acbg int )_d .Gray ;SetGray (_dcfgb ,_cge int ,_eeg _d .Gray );
};func NewImageBase (width int ,height int ,bitsPerComponent int ,colorComponents int ,data []byte ,alpha []byte ,decode []float64 )ImageBase {_caab :=ImageBase {Width :width ,Height :height ,BitsPerComponent :bitsPerComponent ,ColorComponents :colorComponents ,Data :data ,Alpha :alpha ,Decode :decode ,BytesPerLine :BytesPerLine (width ,bitsPerComponent ,colorComponents )};
if data ==nil {_caab .Data =make ([]byte ,height *_caab .BytesPerLine );};return _caab ;};func (_cged *Gray4 )setGray (_cef int ,_fdef int ,_abad _d .Gray ){_bgbb :=_fdef *_cged .BytesPerLine ;_bcaa :=_bgbb +(_cef >>1);if _bcaa >=len (_cged .Data ){return ;
};_ffg :=_abad .Y >>4;_cged .Data [_bcaa ]=(_cged .Data [_bcaa ]&(^(0xf0>>uint (4*(_cef &1)))))|(_ffg <<uint (4-4*(_cef &1)));};func _dc (_gd *Monochrome ,_cd int ,_ae []uint )(*Monochrome ,error ){_df :=_cd *_gd .Width ;_eed :=_cd *_gd .Height ;_aa :=_cga (_df ,_eed );
for _aac ,_cdb :=range _ae {var _fb error ;switch _cdb {case 2:_fb =_gg (_aa ,_gd );case 4:_fb =_dd (_aa ,_gd );case 8:_fb =_bf (_aa ,_gd );};if _fb !=nil {return nil ,_fb ;};if _aac !=len (_ae )-1{_gd =_aa .copy ();};};return _aa ,nil ;};func _gfb (_eac ,_eba *Monochrome ,_dcb []byte ,_ebd int )(_cdf error ){var (_ccbc ,_gbe ,_ccbg ,_gbcf ,_ebb ,_ebg ,_fgg ,_fee int ;
_egaf ,_agb uint32 ;_gac ,_gaa byte ;_fbed uint16 ;);_dac :=make ([]byte ,4);_dcg :=make ([]byte ,4);for _ccbg =0;_ccbg < _eac .Height -1;_ccbg ,_gbcf =_ccbg +2,_gbcf +1{_ccbc =_ccbg *_eac .BytesPerLine ;_gbe =_gbcf *_eba .BytesPerLine ;for _ebb ,_ebg =0,0;
_ebb < _ebd ;_ebb ,_ebg =_ebb +4,_ebg +1{for _fgg =0;_fgg < 4;_fgg ++{_fee =_ccbc +_ebb +_fgg ;if _fee <=len (_eac .Data )-1&&_fee < _ccbc +_eac .BytesPerLine {_dac [_fgg ]=_eac .Data [_fee ];}else {_dac [_fgg ]=0x00;};_fee =_ccbc +_eac .BytesPerLine +_ebb +_fgg ;
if _fee <=len (_eac .Data )-1&&_fee < _ccbc +(2*_eac .BytesPerLine ){_dcg [_fgg ]=_eac .Data [_fee ];}else {_dcg [_fgg ]=0x00;};};_egaf =_b .BigEndian .Uint32 (_dac );_agb =_b .BigEndian .Uint32 (_dcg );_agb |=_egaf ;_agb |=_agb <<1;_agb &=0xaaaaaaaa;_egaf =_agb |(_agb <<7);
_gac =byte (_egaf >>24);_gaa =byte ((_egaf >>8)&0xff);_fee =_gbe +_ebg ;if _fee +1==len (_eba .Data )-1||_fee +1>=_gbe +_eba .BytesPerLine {_eba .Data [_fee ]=_dcb [_gac ];}else {_fbed =(uint16 (_dcb [_gac ])<<8)|uint16 (_dcb [_gaa ]);if _cdf =_eba .setTwoBytes (_fee ,_fbed );
_cdf !=nil {return _ba .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_fee );};_ebg ++;};};};return nil ;
};func (_fege *Monochrome )ReduceBinary (factor float64 )(*Monochrome ,error ){_bfgfe :=_fbab (uint (factor ));if !IsPowerOf2 (uint (factor )){_bfgfe ++;};_ggbg :=make ([]int ,_bfgfe );for _bdd :=range _ggbg {_ggbg [_bdd ]=4;};_adca ,_bcfe :=_efg (_fege ,_ggbg ...);
if _bcfe !=nil {return nil ,_bcfe ;};return _adca ,nil ;};func (_acc *Monochrome )AddPadding ()(_def error ){if _bcc :=((_acc .Width *_acc .Height )+7)>>3;len (_acc .Data )< _bcc {return _ba .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064a\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002e\u0020\u0054\u0068\u0065\u0020\u0064\u0061t\u0061\u0020s\u0068\u006fu\u006c\u0064\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0020\u0061\u0074 l\u0065\u0061\u0073\u0074\u003a\u0020\u0027\u0025\u0064'\u0020\u0062\u0079\u0074\u0065\u0073",len (_acc .Data ),_bcc );
};_ebgc :=_acc .Width %8;if _ebgc ==0{return nil ;};_bgaa :=_acc .Width /8;_caed :=_bag .NewReader (_acc .Data );_afgc :=make ([]byte ,_acc .Height *_acc .BytesPerLine );_adaba :=_bag .NewWriterMSB (_afgc );_bgb :=make ([]byte ,_bgaa );var (_ddcg int ;
_beafb uint64 ;);for _ddcg =0;_ddcg < _acc .Height ;_ddcg ++{if _ ,_def =_caed .Read (_bgb );_def !=nil {return _def ;};if _ ,_def =_adaba .Write (_bgb );_def !=nil {return _def ;};if _beafb ,_def =_caed .ReadBits (byte (_ebgc ));_def !=nil {return _def ;
};if _def =_adaba .WriteByte (byte (_beafb )<<uint (8-_ebgc ));_def !=nil {return _def ;};};_acc .Data =_adaba .Data ();return nil ;};func (_gecaf *Gray2 )Validate ()error {if len (_gecaf .Data )!=_gecaf .Height *_gecaf .BytesPerLine {return ErrInvalidImage ;
};return nil ;};func ColorAtRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_d .RGBA ,error ){_cfec :=y *width +x ;_efbe :=3*_cfec ;if _efbe +2>=len (data ){return _d .RGBA {},_ba .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_dbbe :=uint8 (0xff);if alpha !=nil &&len (alpha )> _cfec {_dbbe =alpha [_cfec ];};_bdge ,_bdcbc ,_beddb :=data [_efbe ],data [_efbe +1],data [_efbe +2];if len (decode )==6{_bdge =uint8 (uint32 (LinearInterpolate (float64 (_bdge ),0,255,decode [0],decode [1]))&0xff);
_bdcbc =uint8 (uint32 (LinearInterpolate (float64 (_bdcbc ),0,255,decode [2],decode [3]))&0xff);_beddb =uint8 (uint32 (LinearInterpolate (float64 (_beddb ),0,255,decode [4],decode [5]))&0xff);};return _d .RGBA {R :_bdge ,G :_bdcbc ,B :_beddb ,A :_dbbe },nil ;
};func (_dag *CMYK32 )Set (x ,y int ,c _d .Color ){_abdc :=4*(y *_dag .Width +x );if _abdc +3>=len (_dag .Data ){return ;};_ccdf :=_d .CMYKModel .Convert (c ).(_d .CMYK );_dag .Data [_abdc ]=_ccdf .C ;_dag .Data [_abdc +1]=_ccdf .M ;_dag .Data [_abdc +2]=_ccdf .Y ;
_dag .Data [_abdc +3]=_ccdf .K ;};func _gefgg (_dea _ec .Image )(Image ,error ){if _caba ,_ace :=_dea .(*Gray16 );_ace {return _caba .Copy (),nil ;};_effg :=_dea .Bounds ();_cfae ,_badg :=NewImage (_effg .Max .X ,_effg .Max .Y ,16,1,nil ,nil ,nil );if _badg !=nil {return nil ,_badg ;
};_dcfd (_dea ,_cfae ,_effg );return _cfae ,nil ;};func _bbdd (_deff _ec .Image )(Image ,error ){if _dgacf ,_aacb :=_deff .(*NRGBA64 );_aacb {return _dgacf .Copy (),nil ;};_adde ,_cbdgb ,_gabc :=_ggab (_deff ,2);_daebg ,_ggfg :=NewImage (_adde .Max .X ,_adde .Max .Y ,16,3,nil ,_gabc ,nil );
if _ggfg !=nil {return nil ,_ggfg ;};_aaca (_deff ,_daebg ,_adde );if len (_gabc )!=0&&!_cbdgb {if _cfee :=_gdab (_gabc ,_daebg );_cfee !=nil {return nil ,_cfee ;};};return _daebg ,nil ;};func (_efed *Monochrome )ExpandBinary (factor int )(*Monochrome ,error ){if !IsPowerOf2 (uint (factor )){return nil ,_ba .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0065\u0078\u0070\u0061\u006e\u0064\u0020b\u0069n\u0061\u0072\u0079\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",factor );
};return _ee (_efed ,factor );};func _ebff (_gacfd Gray ,_facb CMYK ,_dgfe _ec .Rectangle ){for _fggc :=0;_fggc < _dgfe .Max .X ;_fggc ++{for _baac :=0;_baac < _dgfe .Max .Y ;_baac ++{_fea :=_gacfd .GrayAt (_fggc ,_baac );_facb .SetCMYK (_fggc ,_baac ,_cdbc (_fea ));
};};};func _gfeb (_eaggf _d .Color )_d .Color {_cdbab :=_d .NRGBAModel .Convert (_eaggf ).(_d .NRGBA );return _feba (_cdbab );};var _ Gray =&Gray4 {};func (_eccb *NRGBA16 )ColorModel ()_d .Model {return NRGBA16Model };func (_dbg *Gray2 )Set (x ,y int ,c _d .Color ){if x >=_dbg .Width ||y >=_dbg .Height {return ;
};_gfeg :=Gray2Model .Convert (c ).(_d .Gray );_bacd :=y *_dbg .BytesPerLine ;_bcgc :=_bacd +(x >>2);_daa :=_gfeg .Y >>6;_dbg .Data [_bcgc ]=(_dbg .Data [_bcgc ]&(^(0xc0>>uint (2*((x )&3)))))|(_daa <<uint (6-2*(x &3)));};func (_abda *Gray16 )ColorModel ()_d .Model {return _d .Gray16Model };
type monochromeModel uint8 ;func (_fcfff *ImageBase )setTwoBytes (_ecc int ,_bbcfd uint16 )error {if _ecc +1> len (_fcfff .Data )-1{return _c .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_fcfff .Data [_ecc ]=byte ((_bbcfd &0xff00)>>8);
_fcfff .Data [_ecc +1]=byte (_bbcfd &0xff);return nil ;};func _bae (_gba _d .RGBA )_d .Gray {_cddd :=(19595*uint32 (_gba .R )+38470*uint32 (_gba .G )+7471*uint32 (_gba .B )+1<<7)>>16;return _d .Gray {Y :uint8 (_cddd )};};func (_dba *Monochrome )Copy ()Image {return &Monochrome {ImageBase :_dba .ImageBase .copy (),ModelThreshold :_dba .ModelThreshold };
};func IsPowerOf2 (n uint )bool {return n > 0&&(n &(n -1))==0};func _aaa (_fcee _ec .Image )(Image ,error ){if _gfbe ,_bgf :=_fcee .(*Gray4 );_bgf {return _gfbe .Copy (),nil ;};_gdcf :=_fcee .Bounds ();_fbcf ,_gcge :=NewImage (_gdcf .Max .X ,_gdcf .Max .Y ,4,1,nil ,nil ,nil );
if _gcge !=nil {return nil ,_gcge ;};_dcfd (_fcee ,_fbcf ,_gdcf );return _fbcf ,nil ;};func _bac ()(_bfb [256]uint16 ){for _afa :=0;_afa < 256;_afa ++{if _afa &0x01!=0{_bfb [_afa ]|=0x3;};if _afa &0x02!=0{_bfb [_afa ]|=0xc;};if _afa &0x04!=0{_bfb [_afa ]|=0x30;
};if _afa &0x08!=0{_bfb [_afa ]|=0xc0;};if _afa &0x10!=0{_bfb [_afa ]|=0x300;};if _afa &0x20!=0{_bfb [_afa ]|=0xc00;};if _afa &0x40!=0{_bfb [_afa ]|=0x3000;};if _afa &0x80!=0{_bfb [_afa ]|=0xc000;};};return _bfb ;};func _ffda (_bcge ,_gacff NRGBA ,_ddca _ec .Rectangle ){for _aebb :=0;
_aebb < _ddca .Max .X ;_aebb ++{for _deef :=0;_deef < _ddca .Max .Y ;_deef ++{_gacff .SetNRGBA (_aebb ,_deef ,_bcge .NRGBAAt (_aebb ,_deef ));};};};func (_eab *Gray8 )Histogram ()(_gcbe [256]int ){for _edgc :=0;_edgc < len (_eab .Data );_edgc ++{_gcbe [_eab .Data [_edgc ]]++;
};return _gcbe ;};func (_bgfb *ImageBase )setEightBytes (_bgfe int ,_ddgf uint64 )error {_eca :=_bgfb .BytesPerLine -(_bgfe %_bgfb .BytesPerLine );if _bgfb .BytesPerLine !=_bgfb .Width >>3{_eca --;};if _eca >=8{return _bgfb .setEightFullBytes (_bgfe ,_ddgf );
};return _bgfb .setEightPartlyBytes (_bgfe ,_eca ,_ddgf );};func _facf (_dbde int ,_ged int )int {if _dbde < _ged {return _dbde ;};return _ged ;};func _bbc (_bga _d .NRGBA64 )_d .Gray {var _agee _d .NRGBA64 ;if _bga ==_agee {return _d .Gray {Y :0xff};};
_fda ,_bcd ,_dcfg ,_ :=_bga .RGBA ();_baacd :=(19595*_fda +38470*_bcd +7471*_dcfg +1<<15)>>24;return _d .Gray {Y :uint8 (_baacd )};};func _dcfd (_fdcfd _ec .Image ,_dffag Image ,_afag _ec .Rectangle ){switch _cbcc :=_fdcfd .(type ){case Gray :_abbg (_cbcc ,_dffag .(Gray ),_afag );
case NRGBA :_bcdg (_cbcc ,_dffag .(Gray ),_afag );case CMYK :_dcd (_cbcc ,_dffag .(Gray ),_afag );case RGBA :_edaa (_cbcc ,_dffag .(Gray ),_afag );default:_ebda (_fdcfd ,_dffag ,_afag );};};func GrayHistogram (g Gray )(_cccfe [256]int ){switch _fbag :=g .(type ){case Histogramer :return _fbag .Histogram ();
case _ec .Image :_eddc :=_fbag .Bounds ();for _gede :=0;_gede < _eddc .Max .X ;_gede ++{for _gacc :=0;_gacc < _eddc .Max .Y ;_gacc ++{_cccfe [g .GrayAt (_gede ,_gacc ).Y ]++;};};return _cccfe ;default:return [256]int {};};};func (_dbeb *ImageBase )newAlpha (){_degf :=BytesPerLine (_dbeb .Width ,_dbeb .BitsPerComponent ,1);
_dbeb .Alpha =make ([]byte ,_dbeb .Height *_degf );};func _ddcf (_gfbf _d .NRGBA )_d .RGBA {_debg ,_adg ,_adc ,_ffcc :=_gfbf .RGBA ();return _d .RGBA {R :uint8 (_debg >>8),G :uint8 (_adg >>8),B :uint8 (_adc >>8),A :uint8 (_ffcc >>8)};};func _cga (_ebc ,_beb int )*Monochrome {return &Monochrome {ImageBase :NewImageBase (_ebc ,_beb ,1,1,nil ,nil ,nil ),ModelThreshold :0x0f};
};type Image interface{_a .Image ;Base ()*ImageBase ;Copy ()Image ;Pix ()[]byte ;ColorAt (_fcbd ,_edda int )(_d .Color ,error );Validate ()error ;};func _fdgf (_eagdc *Monochrome ,_fdca ,_afbf int ,_afabe ,_cgefb int ,_dcgb RasterOperator ){var (_abde int ;
_gdga byte ;_dfcc ,_agbef int ;_dffaf int ;);_gbee :=_afabe >>3;_ddfc :=_afabe &7;if _ddfc > 0{_gdga =_aaaa [_ddfc ];};_abde =_eagdc .BytesPerLine *_afbf +(_fdca >>3);switch _dcgb {case PixClr :for _dfcc =0;_dfcc < _cgefb ;_dfcc ++{_dffaf =_abde +_dfcc *_eagdc .BytesPerLine ;
for _agbef =0;_agbef < _gbee ;_agbef ++{_eagdc .Data [_dffaf ]=0x0;_dffaf ++;};if _ddfc > 0{_eagdc .Data [_dffaf ]=_cdea (_eagdc .Data [_dffaf ],0x0,_gdga );};};case PixSet :for _dfcc =0;_dfcc < _cgefb ;_dfcc ++{_dffaf =_abde +_dfcc *_eagdc .BytesPerLine ;
for _agbef =0;_agbef < _gbee ;_agbef ++{_eagdc .Data [_dffaf ]=0xff;_dffaf ++;};if _ddfc > 0{_eagdc .Data [_dffaf ]=_cdea (_eagdc .Data [_dffaf ],0xff,_gdga );};};case PixNotDst :for _dfcc =0;_dfcc < _cgefb ;_dfcc ++{_dffaf =_abde +_dfcc *_eagdc .BytesPerLine ;
for _agbef =0;_agbef < _gbee ;_agbef ++{_eagdc .Data [_dffaf ]=^_eagdc .Data [_dffaf ];_dffaf ++;};if _ddfc > 0{_eagdc .Data [_dffaf ]=_cdea (_eagdc .Data [_dffaf ],^_eagdc .Data [_dffaf ],_gdga );};};};};func (_fgcdf *NRGBA32 )Copy ()Image {return &NRGBA32 {ImageBase :_fgcdf .copy ()}};
var _ Image =&Gray8 {};func ColorAtNRGBA64 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_d .NRGBA64 ,error ){_egecg :=(y *width +x )*2;_eaca :=_egecg *3;if _eaca +5>=len (data ){return _d .NRGBA64 {},_ba .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};const _cbbb =0xffff;_bdaae :=uint16 (_cbbb );if alpha !=nil &&len (alpha )> _egecg +1{_bdaae =uint16 (alpha [_egecg ])<<8|uint16 (alpha [_egecg +1]);};_fbcab :=uint16 (data [_eaca ])<<8|uint16 (data [_eaca +1]);_cgd :=uint16 (data [_eaca +2])<<8|uint16 (data [_eaca +3]);
_cdcca :=uint16 (data [_eaca +4])<<8|uint16 (data [_eaca +5]);if len (decode )==6{_fbcab =uint16 (uint64 (LinearInterpolate (float64 (_fbcab ),0,65535,decode [0],decode [1]))&_cbbb );_cgd =uint16 (uint64 (LinearInterpolate (float64 (_cgd ),0,65535,decode [2],decode [3]))&_cbbb );
_cdcca =uint16 (uint64 (LinearInterpolate (float64 (_cdcca ),0,65535,decode [4],decode [5]))&_cbbb );};return _d .NRGBA64 {R :_fbcab ,G :_cgd ,B :_cdcca ,A :_bdaae },nil ;};func _ee (_g *Monochrome ,_ab int )(*Monochrome ,error ){if _g ==nil {return nil ,_c .New ("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064");
};if _ab ==1{return _g .copy (),nil ;};if !IsPowerOf2 (uint (_ab )){return nil ,_ba .Errorf ("\u0070\u0072\u006fvi\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006ci\u0064 \u0065x\u0070a\u006e\u0064\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_ab );
};_gc :=_cdd (_ab );return _dc (_g ,_ab ,_gc );};func (_dfg *Monochrome )ScaleLow (width ,height int )(*Monochrome ,error ){if width < 0||height < 0{return nil ,_c .New ("\u0070\u0072\u006f\u0076\u0069\u0064e\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0069\u0064t\u0068\u0020\u0061\u006e\u0064\u0020\u0068e\u0069\u0067\u0068\u0074");
};_cgc :=_cga (width ,height );_fff :=make ([]int ,height );_bff :=make ([]int ,width );_bfdf :=float64 (_dfg .Width )/float64 (width );_ecgg :=float64 (_dfg .Height )/float64 (height );for _cgfb :=0;_cgfb < height ;_cgfb ++{_fff [_cgfb ]=int (_e .Min (_ecgg *float64 (_cgfb )+0.5,float64 (_dfg .Height -1)));
};for _bead :=0;_bead < width ;_bead ++{_bff [_bead ]=int (_e .Min (_bfdf *float64 (_bead )+0.5,float64 (_dfg .Width -1)));};_aede :=-1;_aecgc :=byte (0);for _adcg :=0;_adcg < height ;_adcg ++{_gbb :=_fff [_adcg ]*_dfg .BytesPerLine ;_bedd :=_adcg *_cgc .BytesPerLine ;
for _agea :=0;_agea < width ;_agea ++{_acge :=_bff [_agea ];if _acge !=_aede {_aecgc =_dfg .getBit (_gbb ,_acge );if _aecgc !=0{_cgc .setBit (_bedd ,_agea );};_aede =_acge ;}else {if _aecgc !=0{_cgc .setBit (_bedd ,_agea );};};};};return _cgc ,nil ;};func (_abge *Gray2 )Histogram ()(_eagg [256]int ){for _egbb :=0;
_egbb < _abge .Width ;_egbb ++{for _aggg :=0;_aggg < _abge .Height ;_aggg ++{_eagg [_abge .GrayAt (_egbb ,_aggg ).Y ]++;};};return _eagg ;};func (_gfc *Gray16 )Histogram ()(_cag [256]int ){for _fgeb :=0;_fgeb < _gfc .Width ;_fgeb ++{for _cgad :=0;_cgad < _gfc .Height ;
_cgad ++{_cag [_gfc .GrayAt (_fgeb ,_cgad ).Y ]++;};};return _cag ;};func InDelta (expected ,current ,delta float64 )bool {_aeb :=expected -current ;if _aeb <=-delta ||_aeb >=delta {return false ;};return true ;};func _bbf (_dfe _d .NRGBA )_d .Gray {var _eagd _d .NRGBA ;
if _dfe ==_eagd {return _d .Gray {Y :0xff};};_ecdg ,_fgfe ,_cfabf ,_ :=_dfe .RGBA ();_baca :=(19595*_ecdg +38470*_fgfe +7471*_cfabf +1<<15)>>24;return _d .Gray {Y :uint8 (_baca )};};func (_aebf *RGBA32 )Bounds ()_ec .Rectangle {return _ec .Rectangle {Max :_ec .Point {X :_aebf .Width ,Y :_aebf .Height }};
};func _eegg (_gcfc _d .Color )_d .Color {_gefg :=_d .GrayModel .Convert (_gcfc ).(_d .Gray );return _cgbd (_gefg );};func _cdd (_fgc int )[]uint {var _cf []uint ;_bb :=_fgc ;_dede :=_bb /8;if _dede !=0{for _bcb :=0;_bcb < _dede ;_bcb ++{_cf =append (_cf ,8);
};_ffa :=_bb %8;_bb =0;if _ffa !=0{_bb =_ffa ;};};_fdgg :=_bb /4;if _fdgg !=0{for _aec :=0;_aec < _fdgg ;_aec ++{_cf =append (_cf ,4);};_gbc :=_bb %4;_bb =0;if _gbc !=0{_bb =_gbc ;};};_fbc :=_bb /2;if _fbc !=0{for _efd :=0;_efd < _fbc ;_efd ++{_cf =append (_cf ,2);
};};return _cf ;};func (_eeaff *RGBA32 )ColorAt (x ,y int )(_d .Color ,error ){return ColorAtRGBA32 (x ,y ,_eeaff .Width ,_eeaff .Data ,_eeaff .Alpha ,_eeaff .Decode );};func (_fbdc *Monochrome )InverseData ()error {return _fbdc .RasterOperation (0,0,_fbdc .Width ,_fbdc .Height ,PixNotDst ,nil ,0,0);
};func (_egc *Gray8 )At (x ,y int )_d .Color {_fca ,_ :=_egc .ColorAt (x ,y );return _fca };func (_cfdf *NRGBA64 )SetNRGBA64 (x ,y int ,c _d .NRGBA64 ){_ecae :=(y *_cfdf .Width +x )*2;_ddag :=_ecae *3;if _ddag +5>=len (_cfdf .Data ){return ;};_cfdf .setNRGBA64 (_ddag ,c ,_ecae );
};type nrgba64 interface{NRGBA64At (_bfea ,_effc int )_d .NRGBA64 ;SetNRGBA64 (_ggec ,_bebc int ,_dgce _d .NRGBA64 );};func _acf (_dgd ,_dfd *Monochrome ,_deb []byte ,_bagf int )(_egf error ){var (_cbe ,_fag ,_dbc ,_fcfd ,_bfe ,_afg ,_dfc ,_efc int ;_eeaf ,_bgc uint32 ;
_fcff ,_aadb byte ;_bbac uint16 ;);_bcg :=make ([]byte ,4);_agef :=make ([]byte ,4);for _dbc =0;_dbc < _dgd .Height -1;_dbc ,_fcfd =_dbc +2,_fcfd +1{_cbe =_dbc *_dgd .BytesPerLine ;_fag =_fcfd *_dfd .BytesPerLine ;for _bfe ,_afg =0,0;_bfe < _bagf ;_bfe ,_afg =_bfe +4,_afg +1{for _dfc =0;
_dfc < 4;_dfc ++{_efc =_cbe +_bfe +_dfc ;if _efc <=len (_dgd .Data )-1&&_efc < _cbe +_dgd .BytesPerLine {_bcg [_dfc ]=_dgd .Data [_efc ];}else {_bcg [_dfc ]=0x00;};_efc =_cbe +_dgd .BytesPerLine +_bfe +_dfc ;if _efc <=len (_dgd .Data )-1&&_efc < _cbe +(2*_dgd .BytesPerLine ){_agef [_dfc ]=_dgd .Data [_efc ];
}else {_agef [_dfc ]=0x00;};};_eeaf =_b .BigEndian .Uint32 (_bcg );_bgc =_b .BigEndian .Uint32 (_agef );_bgc &=_eeaf ;_bgc &=_bgc <<1;_bgc &=0xaaaaaaaa;_eeaf =_bgc |(_bgc <<7);_fcff =byte (_eeaf >>24);_aadb =byte ((_eeaf >>8)&0xff);_efc =_fag +_afg ;if _efc +1==len (_dfd .Data )-1||_efc +1>=_fag +_dfd .BytesPerLine {_dfd .Data [_efc ]=_deb [_fcff ];
if _egf =_dfd .setByte (_efc ,_deb [_fcff ]);_egf !=nil {return _ba .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_efc );};}else {_bbac =(uint16 (_deb [_fcff ])<<8)|uint16 (_deb [_aadb ]);if _egf =_dfd .setTwoBytes (_efc ,_bbac );_egf !=nil {return _ba .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_efc );
};_afg ++;};};};return nil ;};func AutoThresholdTriangle (histogram [256]int )uint8 {var _fcca ,_aeca ,_abfb ,_aabf int ;for _bgdf :=0;_bgdf < len (histogram );_bgdf ++{if histogram [_bgdf ]> 0{_fcca =_bgdf ;break ;};};if _fcca > 0{_fcca --;};for _gcacf :=255;
_gcacf > 0;_gcacf --{if histogram [_gcacf ]> 0{_aabf =_gcacf ;break ;};};if _aabf < 255{_aabf ++;};for _ggcd :=0;_ggcd < 256;_ggcd ++{if histogram [_ggcd ]> _aeca {_abfb =_ggcd ;_aeca =histogram [_ggcd ];};};var _cfea bool ;if (_abfb -_fcca )< (_aabf -_abfb ){_cfea =true ;
var _dabe int ;_fbba :=255;for _dabe < _fbba {_dbbd :=histogram [_dabe ];histogram [_dabe ]=histogram [_fbba ];histogram [_fbba ]=_dbbd ;_dabe ++;_fbba --;};_fcca =255-_aabf ;_abfb =255-_abfb ;};if _fcca ==_abfb {return uint8 (_fcca );};_fdedg :=float64 (histogram [_abfb ]);
_ecgca :=float64 (_fcca -_abfb );_bcdc :=_e .Sqrt (_fdedg *_fdedg +_ecgca *_ecgca );_fdedg /=_bcdc ;_ecgca /=_bcdc ;_bcdc =_fdedg *float64 (_fcca )+_ecgca *float64 (histogram [_fcca ]);_gace :=_fcca ;var _dgfee float64 ;for _fggd :=_fcca +1;_fggd <=_abfb ;
_fggd ++{_egeca :=_fdedg *float64 (_fggd )+_ecgca *float64 (histogram [_fggd ])-_bcdc ;if _egeca > _dgfee {_gace =_fggd ;_dgfee =_egeca ;};};_gace --;if _cfea {var _bgfd int ;_gggg :=255;for _bgfd < _gggg {_cegg :=histogram [_bgfd ];histogram [_bgfd ]=histogram [_gggg ];
histogram [_gggg ]=_cegg ;_bgfd ++;_gggg --;};return uint8 (255-_gace );};return uint8 (_gace );};func _egecbb (_bec NRGBA ,_bbfee RGBA ,_gaeag _ec .Rectangle ){for _fdf :=0;_fdf < _gaeag .Max .X ;_fdf ++{for _dbda :=0;_dbda < _gaeag .Max .Y ;_dbda ++{_bfgb :=_bec .NRGBAAt (_fdf ,_dbda );
_bbfee .SetRGBA (_fdf ,_dbda ,_ddcf (_bfgb ));};};};func (_gcc *RGBA32 )Set (x ,y int ,c _d .Color ){_gdgdb :=y *_gcc .Width +x ;_ffdc :=3*_gdgdb ;if _ffdc +2>=len (_gcc .Data ){return ;};_edgcb :=_d .RGBAModel .Convert (c ).(_d .RGBA );_gcc .setRGBA (_gdgdb ,_edgcb );
};func _edaa (_beec RGBA ,_ggbcf Gray ,_eada _ec .Rectangle ){for _babf :=0;_babf < _eada .Max .X ;_babf ++{for _agge :=0;_agge < _eada .Max .Y ;_agge ++{_fafad :=_bae (_beec .RGBAAt (_babf ,_agge ));_ggbcf .SetGray (_babf ,_agge ,_fafad );};};};func (_bfc *Gray16 )GrayAt (x ,y int )_d .Gray {_bcgg ,_ :=_bfc .ColorAt (x ,y );
return _d .Gray {Y :uint8 (_bcgg .(_d .Gray16 ).Y >>8)};};func (_dca *CMYK32 )Bounds ()_ec .Rectangle {return _ec .Rectangle {Max :_ec .Point {X :_dca .Width ,Y :_dca .Height }};};var (_fad =_bac ();_agf =_bc ();_dgf =_aea (););func (_abce *NRGBA16 )SetNRGBA (x ,y int ,c _d .NRGBA ){_ebgcg :=y *_abce .BytesPerLine +x *3/2;
if _ebgcg +1>=len (_abce .Data ){return ;};c =_feba (c );_abce .setNRGBA (x ,y ,_ebgcg ,c );};func (_ccg *Gray8 )Copy ()Image {return &Gray8 {ImageBase :_ccg .copy ()}};func (_gbed *ImageBase )setFourBytes (_badb int ,_ceb uint32 )error {if _badb +3> len (_gbed .Data )-1{return _ba .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006fu\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065",_badb );
};_gbed .Data [_badb ]=byte ((_ceb &0xff000000)>>24);_gbed .Data [_badb +1]=byte ((_ceb &0xff0000)>>16);_gbed .Data [_badb +2]=byte ((_ceb &0xff00)>>8);_gbed .Data [_badb +3]=byte (_ceb &0xff);return nil ;};func ColorAtGray2BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_d .Gray ,error ){_eacd :=y *bytesPerLine +x >>2;
if _eacd >=len (data ){return _d .Gray {},_ba .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_fadd :=data [_eacd ]>>uint (6-(x &3)*2)&3;if len (decode )==2{_fadd =uint8 (uint32 (LinearInterpolate (float64 (_fadd ),0,3.0,decode [0],decode [1]))&3);};return _d .Gray {Y :_fadd *85},nil ;};var _ Image =&Gray2 {};func AddDataPadding (width ,height ,bitsPerComponent ,colorComponents int ,data []byte )([]byte ,error ){_edgg :=BytesPerLine (width ,bitsPerComponent ,colorComponents );
if _edgg ==width *colorComponents *bitsPerComponent /8{return data ,nil ;};_dgac :=width *colorComponents *bitsPerComponent ;_daec :=_edgg *8;_eddd :=8-(_daec -_dgac );_cbaf :=_bag .NewReader (data );_egecb :=_edgg -1;_abae :=make ([]byte ,_egecb );_aaf :=make ([]byte ,height *_edgg );
_aefg :=_bag .NewWriterMSB (_aaf );var _gfce uint64 ;var _ebac error ;for _afde :=0;_afde < height ;_afde ++{_ ,_ebac =_cbaf .Read (_abae );if _ebac !=nil {return nil ,_ebac ;};_ ,_ebac =_aefg .Write (_abae );if _ebac !=nil {return nil ,_ebac ;};_gfce ,_ebac =_cbaf .ReadBits (byte (_eddd ));
if _ebac !=nil {return nil ,_ebac ;};_ ,_ebac =_aefg .WriteBits (_gfce ,_eddd );if _ebac !=nil {return nil ,_ebac ;};_aefg .FinishByte ();};return _aaf ,nil ;};func (_gcdc *Gray8 )SetGray (x ,y int ,g _d .Gray ){_cgfg :=y *_gcdc .BytesPerLine +x ;if _cgfg > len (_gcdc .Data )-1{return ;
};_gcdc .Data [_cgfg ]=g .Y ;};func (_eff *CMYK32 )Copy ()Image {return &CMYK32 {ImageBase :_eff .copy ()}};func _baab (_bdb _d .CMYK )_d .NRGBA {_gaee ,_agg ,_afdc :=_d .CMYKToRGB (_bdb .C ,_bdb .M ,_bdb .Y ,_bdb .K );return _d .NRGBA {R :_gaee ,G :_agg ,B :_afdc ,A :0xff};
};func _bfbg (_fcg NRGBA ,_eaf CMYK ,_gca _ec .Rectangle ){for _gbce :=0;_gbce < _gca .Max .X ;_gbce ++{for _deg :=0;_deg < _gca .Max .Y ;_deg ++{_fbfg :=_fcg .NRGBAAt (_gbce ,_deg );_eaf .SetCMYK (_gbce ,_deg ,_cdg (_fbfg ));};};};func (_ggc *CMYK32 )ColorAt (x ,y int )(_d .Color ,error ){return ColorAtCMYK (x ,y ,_ggc .Width ,_ggc .Data ,_ggc .Decode );
};func (_bfbb *Gray2 )GrayAt (x ,y int )_d .Gray {_dbf ,_ :=ColorAtGray2BPC (x ,y ,_bfbb .BytesPerLine ,_bfbb .Data ,_bfbb .Decode );return _dbf ;};func _eage (_bdf _d .NYCbCrA )_d .NRGBA {_dedb :=int32 (_bdf .Y )*0x10101;_gdac :=int32 (_bdf .Cb )-128;
_egef :=int32 (_bdf .Cr )-128;_gce :=_dedb +91881*_egef ;if uint32 (_gce )&0xff000000==0{_gce >>=8;}else {_gce =^(_gce >>31)&0xffff;};_cfd :=_dedb -22554*_gdac -46802*_egef ;if uint32 (_cfd )&0xff000000==0{_cfd >>=8;}else {_cfd =^(_cfd >>31)&0xffff;};_dbcb :=_dedb +116130*_gdac ;
if uint32 (_dbcb )&0xff000000==0{_dbcb >>=8;}else {_dbcb =^(_dbcb >>31)&0xffff;};return _d .NRGBA {R :uint8 (_gce >>8),G :uint8 (_cfd >>8),B :uint8 (_dbcb >>8),A :_bdf .A };};