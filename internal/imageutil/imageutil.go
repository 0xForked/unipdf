//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package imageutil ;import (_gd "encoding/binary";_d "errors";_c "fmt";_gg "github.com/unidoc/unipdf/v3/common";_fd "github.com/unidoc/unipdf/v3/internal/bitwise";_b "image";_ed "image/color";_f "image/draw";_g "math";);type NRGBA64 struct{ImageBase };func _deb (_bcb _b .Image ,_bcdb Image ,_cce _b .Rectangle ){for _fbgg :=0;
_fbgg < _cce .Max .X ;_fbgg ++{for _bgec :=0;_bgec < _cce .Max .Y ;_bgec ++{_bea :=_bcb .At (_fbgg ,_bgec );_bcdb .Set (_fbgg ,_bgec ,_bea );};};};func (_bcca *Gray2 )Copy ()Image {return &Gray2 {ImageBase :_bcca .copy ()}};type NRGBA16 struct{ImageBase };
func (_gged *Gray8 )At (x ,y int )_ed .Color {_dbe ,_ :=_gged .ColorAt (x ,y );return _dbe };func ColorAt (x ,y ,width ,bitsPerColor ,colorComponents ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_ed .Color ,error ){switch colorComponents {case 1:return ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine ,data ,decode );
case 3:return ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor ,data ,alpha ,decode );case 4:return ColorAtCMYK (x ,y ,width ,data ,decode );default:return nil ,_c .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0063o\u006c\u006f\u0072\u0020\u0063\u006f\u006dp\u006f\u006e\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0064",colorComponents );
};};func _geaef (_aaag _ed .CMYK )_ed .NRGBA {_dbb ,_gaa ,_efce :=_ed .CMYKToRGB (_aaag .C ,_aaag .M ,_aaag .Y ,_aaag .K );return _ed .NRGBA {R :_dbb ,G :_gaa ,B :_efce ,A :0xff};};const (_adgce shift =iota ;_fbfc ;);func (_aga *Monochrome )ResolveDecode ()error {if len (_aga .Decode )!=2{return nil ;
};if _aga .Decode [0]==1&&_aga .Decode [1]==0{if _gegb :=_aga .InverseData ();_gegb !=nil {return _gegb ;};_aga .Decode =nil ;};return nil ;};func NewImage (width ,height ,bitsPerComponent ,colorComponents int ,data ,alpha []byte ,decode []float64 )(Image ,error ){_gfa :=NewImageBase (width ,height ,bitsPerComponent ,colorComponents ,data ,alpha ,decode );
var _bcffc Image ;switch colorComponents {case 1:switch bitsPerComponent {case 1:_bcffc =&Monochrome {ImageBase :_gfa ,ModelThreshold :0x0f};case 2:_bcffc =&Gray2 {ImageBase :_gfa };case 4:_bcffc =&Gray4 {ImageBase :_gfa };case 8:_bcffc =&Gray8 {ImageBase :_gfa };
case 16:_bcffc =&Gray16 {ImageBase :_gfa };};case 3:switch bitsPerComponent {case 4:_bcffc =&NRGBA16 {ImageBase :_gfa };case 8:_bcffc =&NRGBA32 {ImageBase :_gfa };case 16:_bcffc =&NRGBA64 {ImageBase :_gfa };};case 4:_bcffc =&CMYK32 {ImageBase :_gfa };};
if _bcffc ==nil {return nil ,ErrInvalidImage ;};return _bcffc ,nil ;};func _caba (_aecg ,_egcd uint8 )uint8 {if _aecg < _egcd {return 255;};return 0;};func (_eacf *NRGBA16 )NRGBAAt (x ,y int )_ed .NRGBA {_fdcc ,_ :=ColorAtNRGBA16 (x ,y ,_eacf .Width ,_eacf .BytesPerLine ,_eacf .Data ,_eacf .Alpha ,_eacf .Decode );
return _fdcc ;};func ColorAtRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_ed .RGBA ,error ){_adbfb :=y *width +x ;_dcfb :=3*_adbfb ;if _dcfb +2>=len (data ){return _ed .RGBA {},_c .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_bgbb :=uint8 (0xff);if alpha !=nil &&len (alpha )> _adbfb {_bgbb =alpha [_adbfb ];};_gbdf ,_fccda ,_abbf :=data [_dcfb ],data [_dcfb +1],data [_dcfb +2];if len (decode )==6{_gbdf =uint8 (uint32 (LinearInterpolate (float64 (_gbdf ),0,255,decode [0],decode [1]))&0xff);
_fccda =uint8 (uint32 (LinearInterpolate (float64 (_fccda ),0,255,decode [2],decode [3]))&0xff);_abbf =uint8 (uint32 (LinearInterpolate (float64 (_abbf ),0,255,decode [4],decode [5]))&0xff);};return _ed .RGBA {R :_gbdf ,G :_fccda ,B :_abbf ,A :_bgbb },nil ;
};func (_ddfeb *NRGBA64 )Set (x ,y int ,c _ed .Color ){_aefde :=(y *_ddfeb .Width +x )*2;_dagaf :=_aefde *3;if _dagaf +5>=len (_ddfeb .Data ){return ;};_bggf :=_ed .NRGBA64Model .Convert (c ).(_ed .NRGBA64 );_ddfeb .setNRGBA64 (_dagaf ,_bggf ,_aefde );
};func (_efcb *Gray4 )At (x ,y int )_ed .Color {_abad ,_ :=_efcb .ColorAt (x ,y );return _abad };type Image interface{_f .Image ;Base ()*ImageBase ;Copy ()Image ;Pix ()[]byte ;ColorAt (_gecd ,_cdff int )(_ed .Color ,error );Validate ()error ;};func _de (_ba *Monochrome ,_cc int )(*Monochrome ,error ){if _ba ==nil {return nil ,_d .New ("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064");
};if _cc ==1{return _ba .copy (),nil ;};if !IsPowerOf2 (uint (_cc )){return nil ,_c .Errorf ("\u0070\u0072\u006fvi\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006ci\u0064 \u0065x\u0070a\u006e\u0064\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_cc );
};_a :=_ecg (_cc );return _deg (_ba ,_cc ,_a );};func (_eddga *NRGBA16 )Copy ()Image {return &NRGBA16 {ImageBase :_eddga .copy ()}};func _fcec (_afcf int ,_dacdd int )int {if _afcf < _dacdd {return _afcf ;};return _dacdd ;};func (_ebg *CMYK32 )Copy ()Image {return &CMYK32 {ImageBase :_ebg .copy ()}};
func (_eeadc *Gray16 )Bounds ()_b .Rectangle {return _b .Rectangle {Max :_b .Point {X :_eeadc .Width ,Y :_eeadc .Height }};};var _ _b .Image =&Gray4 {};var _ Gray =&Gray8 {};func _cgeeb (_affe _b .Image )(Image ,error ){if _befb ,_ggce :=_affe .(*Gray16 );
_ggce {return _befb .Copy (),nil ;};_fdba :=_affe .Bounds ();_fdbf ,_aeec :=NewImage (_fdba .Max .X ,_fdba .Max .Y ,16,1,nil ,nil ,nil );if _aeec !=nil {return nil ,_aeec ;};_gdcf (_affe ,_fdbf ,_fdba );return _fdbf ,nil ;};func (_cefc *Gray16 )At (x ,y int )_ed .Color {_bfac ,_ :=_cefc .ColorAt (x ,y );
return _bfac };func _afea (_bfbea nrgba64 ,_fdgd NRGBA ,_gedd _b .Rectangle ){for _dagbe :=0;_dagbe < _gedd .Max .X ;_dagbe ++{for _afbf :=0;_afbf < _gedd .Max .Y ;_afbf ++{_bgebd :=_bfbea .NRGBA64At (_dagbe ,_afbf );_fdgd .SetNRGBA (_dagbe ,_afbf ,_fef (_bgebd ));
};};};func (_aedb *ImageBase )copy ()ImageBase {_aecd :=*_aedb ;_aecd .Data =make ([]byte ,len (_aedb .Data ));copy (_aecd .Data ,_aedb .Data );return _aecd ;};func (_ebcg *Gray4 )GrayAt (x ,y int )_ed .Gray {_aabg ,_ :=ColorAtGray4BPC (x ,y ,_ebcg .BytesPerLine ,_ebcg .Data ,_ebcg .Decode );
return _aabg ;};func (_feff *Monochrome )ExpandBinary (factor int )(*Monochrome ,error ){if !IsPowerOf2 (uint (factor )){return nil ,_c .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0065\u0078\u0070\u0061\u006e\u0064\u0020b\u0069n\u0061\u0072\u0079\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",factor );
};return _de (_feff ,factor );};var _ _b .Image =&NRGBA64 {};func (_dff *NRGBA16 )ColorAt (x ,y int )(_ed .Color ,error ){return ColorAtNRGBA16 (x ,y ,_dff .Width ,_dff .BytesPerLine ,_dff .Data ,_dff .Alpha ,_dff .Decode );};func _gba (_bda ,_bcf *Monochrome ,_dec []byte ,_dfb int )(_cbc error ){var (_gca ,_gdc ,_bcfg ,_aeg ,_ggdc ,_ceeg ,_acf ,_abb int ;
_adeg ,_dgga uint32 ;_cdf ,_beg byte ;_bfg uint16 ;);_edfb :=make ([]byte ,4);_gda :=make ([]byte ,4);for _bcfg =0;_bcfg < _bda .Height -1;_bcfg ,_aeg =_bcfg +2,_aeg +1{_gca =_bcfg *_bda .BytesPerLine ;_gdc =_aeg *_bcf .BytesPerLine ;for _ggdc ,_ceeg =0,0;
_ggdc < _dfb ;_ggdc ,_ceeg =_ggdc +4,_ceeg +1{for _acf =0;_acf < 4;_acf ++{_abb =_gca +_ggdc +_acf ;if _abb <=len (_bda .Data )-1&&_abb < _gca +_bda .BytesPerLine {_edfb [_acf ]=_bda .Data [_abb ];}else {_edfb [_acf ]=0x00;};_abb =_gca +_bda .BytesPerLine +_ggdc +_acf ;
if _abb <=len (_bda .Data )-1&&_abb < _gca +(2*_bda .BytesPerLine ){_gda [_acf ]=_bda .Data [_abb ];}else {_gda [_acf ]=0x00;};};_adeg =_gd .BigEndian .Uint32 (_edfb );_dgga =_gd .BigEndian .Uint32 (_gda );_dgga &=_adeg ;_dgga &=_dgga <<1;_dgga &=0xaaaaaaaa;
_adeg =_dgga |(_dgga <<7);_cdf =byte (_adeg >>24);_beg =byte ((_adeg >>8)&0xff);_abb =_gdc +_ceeg ;if _abb +1==len (_bcf .Data )-1||_abb +1>=_gdc +_bcf .BytesPerLine {_bcf .Data [_abb ]=_dec [_cdf ];if _cbc =_bcf .setByte (_abb ,_dec [_cdf ]);_cbc !=nil {return _c .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_abb );
};}else {_bfg =(uint16 (_dec [_cdf ])<<8)|uint16 (_dec [_beg ]);if _cbc =_bcf .setTwoBytes (_abb ,_bfg );_cbc !=nil {return _c .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_abb );
};_ceeg ++;};};};return nil ;};var _ Image =&Gray8 {};func (_aeba *Monochrome )getBit (_ffg ,_ffbg int )uint8 {return _aeba .Data [_ffg +(_ffbg >>3)]>>uint (7-(_ffbg &7))&1;};func ColorAtCMYK (x ,y ,width int ,data []byte ,decode []float64 )(_ed .CMYK ,error ){_geae :=4*(y *width +x );
if _geae +3>=len (data ){return _ed .CMYK {},_c .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};C :=data [_geae ]&0xff;M :=data [_geae +1]&0xff;Y :=data [_geae +2]&0xff;K :=data [_geae +3]&0xff;if len (decode )==8{C =uint8 (uint32 (LinearInterpolate (float64 (C ),0,255,decode [0],decode [1]))&0xff);M =uint8 (uint32 (LinearInterpolate (float64 (M ),0,255,decode [2],decode [3]))&0xff);
Y =uint8 (uint32 (LinearInterpolate (float64 (Y ),0,255,decode [4],decode [5]))&0xff);K =uint8 (uint32 (LinearInterpolate (float64 (K ),0,255,decode [6],decode [7]))&0xff);};return _ed .CMYK {C :C ,M :M ,Y :Y ,K :K },nil ;};var _ _b .Image =&NRGBA16 {};
func _dgcd (_ddc _ed .RGBA )_ed .CMYK {_ccf ,_abde ,_bdbb ,_gdae :=_ed .RGBToCMYK (_ddc .R ,_ddc .G ,_ddc .B );return _ed .CMYK {C :_ccf ,M :_abde ,Y :_bdbb ,K :_gdae };};const (PixSrc RasterOperator =0xc;PixDst RasterOperator =0xa;PixNotSrc RasterOperator =0x3;
PixNotDst RasterOperator =0x5;PixClr RasterOperator =0x0;PixSet RasterOperator =0xf;PixSrcOrDst RasterOperator =0xe;PixSrcAndDst RasterOperator =0x8;PixSrcXorDst RasterOperator =0x6;PixNotSrcOrDst RasterOperator =0xb;PixNotSrcAndDst RasterOperator =0x2;
PixSrcOrNotDst RasterOperator =0xd;PixSrcAndNotDst RasterOperator =0x4;PixNotPixSrcOrDst RasterOperator =0x1;PixNotPixSrcAndDst RasterOperator =0x7;PixNotPixSrcXorDst RasterOperator =0x9;PixPaint =PixSrcOrDst ;PixSubtract =PixNotSrcAndDst ;PixMask =PixSrcAndDst ;
);func (_adggg *Gray4 )ColorModel ()_ed .Model {return Gray4Model };func _afga (_dbgb Gray ,_bgbf NRGBA ,_dcba _b .Rectangle ){for _ggba :=0;_ggba < _dcba .Max .X ;_ggba ++{for _dgeg :=0;_dgeg < _dcba .Max .Y ;_dgeg ++{_dfcd :=_dbgb .GrayAt (_ggba ,_dgeg );
_bgbf .SetNRGBA (_ggba ,_dgeg ,_deca (_dfcd ));};};};func (_eaff *Gray8 )Copy ()Image {return &Gray8 {ImageBase :_eaff .copy ()}};func _fccab (_baea uint )uint {var _fbbg uint ;for _baea !=0{_baea >>=1;_fbbg ++;};return _fbbg -1;};func MonochromeModel (threshold uint8 )_ed .Model {return monochromeModel (threshold )};
func (_bggef *Gray8 )Histogram ()(_cbce [256]int ){for _agcg :=0;_agcg < len (_bggef .Data );_agcg ++{_cbce [_bggef .Data [_agcg ]]++;};return _cbce ;};type ImageBase struct{Width ,Height int ;BitsPerComponent ,ColorComponents int ;Data ,Alpha []byte ;
Decode []float64 ;BytesPerLine int ;};func _cdfc (_ffce _ed .NRGBA )_ed .RGBA {_cgb ,_ceec ,_fegb ,_bbcc :=_ffce .RGBA ();return _ed .RGBA {R :uint8 (_cgb >>8),G :uint8 (_ceec >>8),B :uint8 (_fegb >>8),A :uint8 (_bbcc >>8)};};func (_aedf *Gray8 )GrayAt (x ,y int )_ed .Gray {_eeda ,_ :=ColorAtGray8BPC (x ,y ,_aedf .BytesPerLine ,_aedf .Data ,_aedf .Decode );
return _eeda ;};func (_dega *Gray2 )SetGray (x ,y int ,gray _ed .Gray ){_bccc :=_ageb (gray );_ebe :=y *_dega .BytesPerLine ;_bgg :=_ebe +(x >>2);if _bgg >=len (_dega .Data ){return ;};_cba :=_bccc .Y >>6;_dega .Data [_bgg ]=(_dega .Data [_bgg ]&(^(0xc0>>uint (2*((x )&3)))))|(_cba <<uint (6-2*(x &3)));
};func BytesPerLine (width ,bitsPerComponent ,colorComponents int )int {return ((width *bitsPerComponent )*colorComponents +7)>>3;};func (_cab *Monochrome )Histogram ()(_dbfb [256]int ){for _ ,_ebf :=range _cab .Data {_dbfb [0xff]+=int (_ceb [_cab .Data [_ebf ]]);
};return _dbfb ;};type Gray interface{GrayAt (_baf ,_ggab int )_ed .Gray ;SetGray (_geaa ,_egcb int ,_cdg _ed .Gray );};func _defb (_eadab _b .Image )(Image ,error ){if _bbgf ,_adaf :=_eadab .(*NRGBA16 );_adaf {return _bbgf .Copy (),nil ;};_aebaf :=_eadab .Bounds ();
_edae ,_gdbef :=NewImage (_aebaf .Max .X ,_aebaf .Max .Y ,4,3,nil ,nil ,nil );if _gdbef !=nil {return nil ,_gdbef ;};_gdee (_eadab ,_edae ,_aebaf );return _edae ,nil ;};func (_fgbd *NRGBA32 )Bounds ()_b .Rectangle {return _b .Rectangle {Max :_b .Point {X :_fgbd .Width ,Y :_fgbd .Height }};
};func _dcbc (_eaa ,_fbg *Monochrome ,_edda []byte ,_eeb int )(_fdg error ){var (_deaf ,_cgd ,_fcc ,_ggb ,_acea ,_bcc ,_cdeg ,_afc int ;_eea ,_fcf ,_adef ,_ggg uint32 ;_ceea ,_acg byte ;_efc uint16 ;);_cdb :=make ([]byte ,4);_abg :=make ([]byte ,4);for _fcc =0;
_fcc < _eaa .Height -1;_fcc ,_ggb =_fcc +2,_ggb +1{_deaf =_fcc *_eaa .BytesPerLine ;_cgd =_ggb *_fbg .BytesPerLine ;for _acea ,_bcc =0,0;_acea < _eeb ;_acea ,_bcc =_acea +4,_bcc +1{for _cdeg =0;_cdeg < 4;_cdeg ++{_afc =_deaf +_acea +_cdeg ;if _afc <=len (_eaa .Data )-1&&_afc < _deaf +_eaa .BytesPerLine {_cdb [_cdeg ]=_eaa .Data [_afc ];
}else {_cdb [_cdeg ]=0x00;};_afc =_deaf +_eaa .BytesPerLine +_acea +_cdeg ;if _afc <=len (_eaa .Data )-1&&_afc < _deaf +(2*_eaa .BytesPerLine ){_abg [_cdeg ]=_eaa .Data [_afc ];}else {_abg [_cdeg ]=0x00;};};_eea =_gd .BigEndian .Uint32 (_cdb );_fcf =_gd .BigEndian .Uint32 (_abg );
_adef =_eea &_fcf ;_adef |=_adef <<1;_ggg =_eea |_fcf ;_ggg &=_ggg <<1;_fcf =_adef |_ggg ;_fcf &=0xaaaaaaaa;_eea =_fcf |(_fcf <<7);_ceea =byte (_eea >>24);_acg =byte ((_eea >>8)&0xff);_afc =_cgd +_bcc ;if _afc +1==len (_fbg .Data )-1||_afc +1>=_cgd +_fbg .BytesPerLine {if _fdg =_fbg .setByte (_afc ,_edda [_ceea ]);
_fdg !=nil {return _c .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_afc );};}else {_efc =(uint16 (_edda [_ceea ])<<8)|uint16 (_edda [_acg ]);if _fdg =_fbg .setTwoBytes (_afc ,_efc );_fdg !=nil {return _c .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_afc );
};_bcc ++;};};};return nil ;};func _dcg (_gdab NRGBA ,_baef Gray ,_dfeg _b .Rectangle ){for _cced :=0;_cced < _dfeg .Max .X ;_cced ++{for _cdad :=0;_cdad < _dfeg .Max .Y ;_cdad ++{_caa :=_cbdc (_gdab .NRGBAAt (_cced ,_cdad ));_baef .SetGray (_cced ,_cdad ,_caa );
};};};func (_dbga *NRGBA64 )Bounds ()_b .Rectangle {return _b .Rectangle {Max :_b .Point {X :_dbga .Width ,Y :_dbga .Height }};};func (_dbcb *CMYK32 )Validate ()error {if len (_dbcb .Data )!=4*_dbcb .Width *_dbcb .Height {return _d .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func ColorAtNRGBA16 (x ,y ,width ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_ed .NRGBA ,error ){_ffff :=y *bytesPerLine +x *3/2;if _ffff +1>=len (data ){return _ed .NRGBA {},_aadb (x ,y );};const (_ccbf =0xf;_efcbc =uint8 (0xff);
);_gcfd :=_efcbc ;if alpha !=nil {_cgfb :=y *BytesPerLine (width ,4,1);if _cgfb < len (alpha ){if x %2==0{_gcfd =(alpha [_cgfb ]>>uint (4))&_ccbf ;}else {_gcfd =alpha [_cgfb ]&_ccbf ;};_gcfd |=_gcfd <<4;};};var _caab ,_aefa ,_gdggd uint8 ;if x *3%2==0{_caab =(data [_ffff ]>>uint (4))&_ccbf ;
_aefa =data [_ffff ]&_ccbf ;_gdggd =(data [_ffff +1]>>uint (4))&_ccbf ;}else {_caab =data [_ffff ]&_ccbf ;_aefa =(data [_ffff +1]>>uint (4))&_ccbf ;_gdggd =data [_ffff +1]&_ccbf ;};if len (decode )==6{_caab =uint8 (uint32 (LinearInterpolate (float64 (_caab ),0,15,decode [0],decode [1]))&0xf);
_aefa =uint8 (uint32 (LinearInterpolate (float64 (_aefa ),0,15,decode [2],decode [3]))&0xf);_gdggd =uint8 (uint32 (LinearInterpolate (float64 (_gdggd ),0,15,decode [4],decode [5]))&0xf);};return _ed .NRGBA {R :(_caab <<4)|(_caab &0xf),G :(_aefa <<4)|(_aefa &0xf),B :(_gdggd <<4)|(_gdggd &0xf),A :_gcfd },nil ;
};func _ddg (_cgcg _b .Image )(Image ,error ){if _eead ,_fecg :=_cgcg .(*Monochrome );_fecg {return _eead ,nil ;};_efe :=_cgcg .Bounds ();var _fccg Gray ;switch _gead :=_cgcg .(type ){case Gray :_fccg =_gead ;case NRGBA :_fccg =&Gray8 {ImageBase :NewImageBase (_efe .Max .X ,_efe .Max .Y ,8,1,nil ,nil ,nil )};
_gfbe (_fccg ,_gead ,_efe );case nrgba64 :_fccg =&Gray8 {ImageBase :NewImageBase (_efe .Max .X ,_efe .Max .Y ,8,1,nil ,nil ,nil )};_efb (_fccg ,_gead ,_efe );default:_eef ,_agb :=GrayConverter .Convert (_cgcg );if _agb !=nil {return nil ,_agb ;};_fccg =_eef .(Gray );
};_fcdbe ,_dfd :=NewImage (_efe .Max .X ,_efe .Max .Y ,1,1,nil ,nil ,nil );if _dfd !=nil {return nil ,_dfd ;};_gfb :=_fcdbe .(*Monochrome );_dee :=AutoThresholdTriangle (GrayHistogram (_fccg ));for _bac :=0;_bac < _efe .Max .X ;_bac ++{for _eadc :=0;_eadc < _efe .Max .Y ;
_eadc ++{_gfbg :=_adag (_fccg .GrayAt (_bac ,_eadc ),monochromeModel (_dee ));_gfb .SetGray (_bac ,_eadc ,_gfbg );};};return _fcdbe ,nil ;};func ColorAtGray2BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_ed .Gray ,error ){_fffd :=y *bytesPerLine +x >>2;
if _fffd >=len (data ){return _ed .Gray {},_c .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_ccdc :=data [_fffd ]>>uint (6-(x &3)*2)&3;if len (decode )==2{_ccdc =uint8 (uint32 (LinearInterpolate (float64 (_ccdc ),0,3.0,decode [0],decode [1]))&3);};return _ed .Gray {Y :_ccdc *85},nil ;};func _adg (_acgg _ed .RGBA )_ed .NRGBA {switch _acgg .A {case 0xff:return _ed .NRGBA {R :_acgg .R ,G :_acgg .G ,B :_acgg .B ,A :0xff};
case 0x00:return _ed .NRGBA {};default:_gdf ,_bfe ,_egcec ,_feg :=_acgg .RGBA ();_gdf =(_gdf *0xffff)/_feg ;_bfe =(_bfe *0xffff)/_feg ;_egcec =(_egcec *0xffff)/_feg ;return _ed .NRGBA {R :uint8 (_gdf >>8),G :uint8 (_bfe >>8),B :uint8 (_egcec >>8),A :uint8 (_feg >>8)};
};};func (_ddbb *NRGBA32 )At (x ,y int )_ed .Color {_agced ,_ :=_ddbb .ColorAt (x ,y );return _agced };func (_dacg *Gray2 )Histogram ()(_dadcd [256]int ){for _aba :=0;_aba < _dacg .Width ;_aba ++{for _gfc :=0;_gfc < _dacg .Height ;_gfc ++{_dadcd [_dacg .GrayAt (_aba ,_gfc ).Y ]++;
};};return _dadcd ;};func (_acc *Gray4 )Base ()*ImageBase {return &_acc .ImageBase };func _cde (_eeg ,_gcd *Monochrome ,_gebd []byte ,_gde int )(_dceda error ){var (_dd ,_gee ,_dcd ,_eadd ,_df ,_faag ,_cca ,_bdg int ;_fde ,_eaf uint32 ;_cee ,_fda byte ;
_aab uint16 ;);_egd :=make ([]byte ,4);_db :=make ([]byte ,4);for _dcd =0;_dcd < _eeg .Height -1;_dcd ,_eadd =_dcd +2,_eadd +1{_dd =_dcd *_eeg .BytesPerLine ;_gee =_eadd *_gcd .BytesPerLine ;for _df ,_faag =0,0;_df < _gde ;_df ,_faag =_df +4,_faag +1{for _cca =0;
_cca < 4;_cca ++{_bdg =_dd +_df +_cca ;if _bdg <=len (_eeg .Data )-1&&_bdg < _dd +_eeg .BytesPerLine {_egd [_cca ]=_eeg .Data [_bdg ];}else {_egd [_cca ]=0x00;};_bdg =_dd +_eeg .BytesPerLine +_df +_cca ;if _bdg <=len (_eeg .Data )-1&&_bdg < _dd +(2*_eeg .BytesPerLine ){_db [_cca ]=_eeg .Data [_bdg ];
}else {_db [_cca ]=0x00;};};_fde =_gd .BigEndian .Uint32 (_egd );_eaf =_gd .BigEndian .Uint32 (_db );_eaf |=_fde ;_eaf |=_eaf <<1;_eaf &=0xaaaaaaaa;_fde =_eaf |(_eaf <<7);_cee =byte (_fde >>24);_fda =byte ((_fde >>8)&0xff);_bdg =_gee +_faag ;if _bdg +1==len (_gcd .Data )-1||_bdg +1>=_gee +_gcd .BytesPerLine {_gcd .Data [_bdg ]=_gebd [_cee ];
}else {_aab =(uint16 (_gebd [_cee ])<<8)|uint16 (_gebd [_fda ]);if _dceda =_gcd .setTwoBytes (_bdg ,_aab );_dceda !=nil {return _c .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_bdg );
};_faag ++;};};};return nil ;};func (_abgb *Monochrome )setBit (_bccb ,_gbdg int ){_abgb .Data [_bccb +(_gbdg >>3)]|=0x80>>uint (_gbdg &7);};func (_gcac *ImageBase )setEightFullBytes (_fgbb int ,_bafad uint64 )error {if _fgbb +7> len (_gcac .Data )-1{return _d .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_gcac .Data [_fgbb ]=byte ((_bafad &0xff00000000000000)>>56);_gcac .Data [_fgbb +1]=byte ((_bafad &0xff000000000000)>>48);_gcac .Data [_fgbb +2]=byte ((_bafad &0xff0000000000)>>40);_gcac .Data [_fgbb +3]=byte ((_bafad &0xff00000000)>>32);_gcac .Data [_fgbb +4]=byte ((_bafad &0xff000000)>>24);
_gcac .Data [_fgbb +5]=byte ((_bafad &0xff0000)>>16);_gcac .Data [_fgbb +6]=byte ((_bafad &0xff00)>>8);_gcac .Data [_fgbb +7]=byte (_bafad &0xff);return nil ;};func (_fagd *Monochrome )AddPadding ()(_ddfe error ){if _gbac :=((_fagd .Width *_fagd .Height )+7)>>3;
len (_fagd .Data )< _gbac {return _c .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064a\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002e\u0020\u0054\u0068\u0065\u0020\u0064\u0061t\u0061\u0020s\u0068\u006fu\u006c\u0064\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0020\u0061\u0074 l\u0065\u0061\u0073\u0074\u003a\u0020\u0027\u0025\u0064'\u0020\u0062\u0079\u0074\u0065\u0073",len (_fagd .Data ),_gbac );
};_cfc :=_fagd .Width %8;if _cfc ==0{return nil ;};_cgeg :=_fagd .Width /8;_def :=_fd .NewReader (_fagd .Data );_gdgd :=make ([]byte ,_fagd .Height *_fagd .BytesPerLine );_gbb :=_fd .NewWriterMSB (_gdgd );_cbb :=make ([]byte ,_cgeg );var (_eeaa int ;_ged uint64 ;
);for _eeaa =0;_eeaa < _fagd .Height ;_eeaa ++{if _ ,_ddfe =_def .Read (_cbb );_ddfe !=nil {return _ddfe ;};if _ ,_ddfe =_gbb .Write (_cbb );_ddfe !=nil {return _ddfe ;};if _ged ,_ddfe =_def .ReadBits (byte (_cfc ));_ddfe !=nil {return _ddfe ;};if _ddfe =_gbb .WriteByte (byte (_ged )<<uint (8-_cfc ));
_ddfe !=nil {return _ddfe ;};};_fagd .Data =_gbb .Data ();return nil ;};type shift int ;func init (){_becb ()};func MonochromeThresholdConverter (threshold uint8 )ColorConverter {return &monochromeThresholdConverter {Threshold :threshold };};var _ceb [256]uint8 ;
func (_gfcd *Gray16 )GrayAt (x ,y int )_ed .Gray {_edcd ,_ :=_gfcd .ColorAt (x ,y );return _ed .Gray {Y :uint8 (_edcd .(_ed .Gray16 ).Y >>8)};};type nrgba64 interface{NRGBA64At (_dcgg ,_egbfe int )_ed .NRGBA64 ;SetNRGBA64 (_babc ,_eddb int ,_ecae _ed .NRGBA64 );
};func _deafg (_dded NRGBA ,_aaagc RGBA ,_feeag _b .Rectangle ){for _fecag :=0;_fecag < _feeag .Max .X ;_fecag ++{for _ffdd :=0;_ffdd < _feeag .Max .Y ;_ffdd ++{_facd :=_dded .NRGBAAt (_fecag ,_ffdd );_aaagc .SetRGBA (_fecag ,_ffdd ,_cdfc (_facd ));};};
};func _cbcb (_dedd _ed .Gray )_ed .RGBA {return _ed .RGBA {R :_dedd .Y ,G :_dedd .Y ,B :_dedd .Y ,A :0xff}};type ColorConverter interface{Convert (_caf _b .Image )(Image ,error );};func _acb ()(_dbc []byte ){_dbc =make ([]byte ,256);for _cfb :=0;_cfb < 256;
_cfb ++{_dad :=byte (_cfb );_dbc [_dad ]=(_dad &0x01)|((_dad &0x04)>>1)|((_dad &0x10)>>2)|((_dad &0x40)>>3)|((_dad &0x02)<<3)|((_dad &0x08)<<2)|((_dad &0x20)<<1)|(_dad &0x80);};return _dbc ;};func (_adecg *NRGBA16 )Base ()*ImageBase {return &_adecg .ImageBase };
func InDelta (expected ,current ,delta float64 )bool {_beed :=expected -current ;if _beed <=-delta ||_beed >=delta {return false ;};return true ;};func (_abbbc *Monochrome )copy ()*Monochrome {_afa :=_bdc (_abbbc .Width ,_abbbc .Height );_afa .ModelThreshold =_abbbc .ModelThreshold ;
_afa .Data =make ([]byte ,len (_abbbc .Data ));copy (_afa .Data ,_abbbc .Data );if len (_abbbc .Decode )!=0{_afa .Decode =make ([]float64 ,len (_abbbc .Decode ));copy (_afa .Decode ,_abbbc .Decode );};if len (_abbbc .Alpha )!=0{_afa .Alpha =make ([]byte ,len (_abbbc .Alpha ));
copy (_afa .Alpha ,_abbbc .Alpha );};return _afa ;};func (_ecgb *Monochrome )Copy ()Image {return &Monochrome {ImageBase :_ecgb .ImageBase .copy (),ModelThreshold :_ecgb .ModelThreshold };};func (_ggda *RGBA32 )SetRGBA (x ,y int ,c _ed .RGBA ){_gcad :=y *_ggda .Width +x ;
_egec :=3*_gcad ;if _egec +2>=len (_ggda .Data ){return ;};_ggda .setRGBA (_gcad ,c );};func (_egfb *ImageBase )GetAlpha ()[]byte {return _egfb .Alpha };var _ Gray =&Gray2 {};func _abdc (_efgg _b .Image )(Image ,error ){if _egee ,_fgfb :=_efgg .(*RGBA32 );
_fgfb {return _egee .Copy (),nil ;};_cac ,_afgfa ,_gcgfg :=_cebd (_efgg ,1);_dgegd :=&RGBA32 {ImageBase :NewImageBase (_cac .Max .X ,_cac .Max .Y ,8,3,nil ,_gcgfg ,nil )};_fbcd (_efgg ,_dgegd ,_cac );if len (_gcgfg )!=0&&!_afgfa {if _ebfa :=_gfee (_gcgfg ,_dgegd );
_ebfa !=nil {return nil ,_ebfa ;};};return _dgegd ,nil ;};var _ _b .Image =&Monochrome {};var (Gray2Model =_ed .ModelFunc (_bafa );Gray4Model =_ed .ModelFunc (_egff );NRGBA16Model =_ed .ModelFunc (_ddcf ););func (_ecgg *Monochrome )clearBit (_cdae ,_dbbd int ){_ecgg .Data [_cdae ]&=^(0x80>>uint (_dbbd &7))};
func _cebd (_bbgc _b .Image ,_dcf int )(_b .Rectangle ,bool ,[]byte ){_dcee :=_bbgc .Bounds ();var (_eaded bool ;_ebgf []byte ;);switch _cbcef :=_bbgc .(type ){case SMasker :_eaded =_cbcef .HasAlpha ();case NRGBA ,RGBA ,*_b .RGBA64 ,nrgba64 ,*_b .NYCbCrA :_ebgf =make ([]byte ,_dcee .Max .X *_dcee .Max .Y *_dcf );
case *_b .Paletted :var _gdgdc bool ;for _ ,_gaec :=range _cbcef .Palette {_eeebf ,_dccd ,_dabb ,_abed :=_gaec .RGBA ();if _eeebf ==0&&_dccd ==0&&_dabb ==0&&_abed !=0{_gdgdc =true ;break ;};};if _gdgdc {_ebgf =make ([]byte ,_dcee .Max .X *_dcee .Max .Y *_dcf );
};};return _dcee ,_eaded ,_ebgf ;};func (_gcg *CMYK32 )At (x ,y int )_ed .Color {_acbg ,_ :=_gcg .ColorAt (x ,y );return _acbg };func (_ddb *Gray16 )Set (x ,y int ,c _ed .Color ){_fdaf :=(y *_ddb .BytesPerLine /2+x )*2;if _fdaf +1>=len (_ddb .Data ){return ;
};_baaa :=_ed .Gray16Model .Convert (c ).(_ed .Gray16 );_ddb .Data [_fdaf ],_ddb .Data [_fdaf +1]=uint8 (_baaa .Y >>8),uint8 (_baaa .Y &0xff);};func (_aeea *ImageBase )setEightBytes (_cege int ,_bggefe uint64 )error {_fccea :=_aeea .BytesPerLine -(_cege %_aeea .BytesPerLine );
if _aeea .BytesPerLine !=_aeea .Width >>3{_fccea --;};if _fccea >=8{return _aeea .setEightFullBytes (_cege ,_bggefe );};return _aeea .setEightPartlyBytes (_cege ,_fccea ,_bggefe );};func _gfed (_eefc *_b .NYCbCrA ,_gcc RGBA ,_gebf _b .Rectangle ){for _bbdfg :=0;
_bbdfg < _gebf .Max .X ;_bbdfg ++{for _fcga :=0;_fcga < _gebf .Max .Y ;_fcga ++{_dgfa :=_eefc .NYCbCrAAt (_bbdfg ,_fcga );_gcc .SetRGBA (_bbdfg ,_fcga ,_bfeb (_dgfa ));};};};func _cbdc (_gbd _ed .NRGBA )_ed .Gray {_aagc ,_feb ,_aafc ,_ :=_gbd .RGBA ();
_agee :=(19595*_aagc +38470*_feb +7471*_aafc +1<<15)>>24;return _ed .Gray {Y :uint8 (_agee )};};var _ Image =&Gray2 {};func _bafa (_ffdb _ed .Color )_ed .Color {_cgda :=_ed .GrayModel .Convert (_ffdb ).(_ed .Gray );return _ageb (_cgda );};func _fbdc (_defc Gray ,_adgb RGBA ,_dbcf _b .Rectangle ){for _bcde :=0;
_bcde < _dbcf .Max .X ;_bcde ++{for _gbfg :=0;_gbfg < _dbcf .Max .Y ;_gbfg ++{_gbba :=_defc .GrayAt (_bcde ,_gbfg );_adgb .SetRGBA (_bcde ,_gbfg ,_cbcb (_gbba ));};};};func (_cadf *Monochrome )Set (x ,y int ,c _ed .Color ){_gcae :=y *_cadf .BytesPerLine +x >>3;
if _gcae > len (_cadf .Data )-1{return ;};_aca :=_cadf .ColorModel ().Convert (c ).(_ed .Gray );_cadf .setGray (x ,_aca ,_gcae );};func _aad (_aaa *Monochrome ,_agc ,_bec int )(*Monochrome ,error ){if _aaa ==nil {return nil ,_d .New ("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064");
};if _agc <=0||_bec <=0{return nil ,_d .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0073\u0063\u0061l\u0065\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020<\u003d\u0020\u0030");};if _agc ==_bec {if _agc ==1{return _aaa .copy (),nil ;};
if _agc ==2||_agc ==4||_agc ==8{_fa ,_ff :=_de (_aaa ,_agc );if _ff !=nil {return nil ,_ff ;};return _fa ,nil ;};};_abc :=_agc *_aaa .Width ;_ccb :=_bec *_aaa .Height ;_cg :=_bdc (_abc ,_ccb );_gea :=_cg .BytesPerLine ;var (_gfg ,_gae ,_ega ,_dced ,_ce int ;
_ee byte ;_bee error ;);for _gae =0;_gae < _aaa .Height ;_gae ++{_gfg =_bec *_gae *_gea ;for _ega =0;_ega < _aaa .Width ;_ega ++{if _ggf :=_aaa .getBitAt (_ega ,_gae );_ggf {_ce =_agc *_ega ;for _dced =0;_dced < _agc ;_dced ++{_cg .setIndexedBit (_gfg *8+_ce +_dced );
};};};for _dced =1;_dced < _bec ;_dced ++{_ac :=_gfg +_dced *_gea ;for _dedb :=0;_dedb < _gea ;_dedb ++{if _ee ,_bee =_cg .getByte (_gfg +_dedb );_bee !=nil {return nil ,_bee ;};if _bee =_cg .setByte (_ac +_dedb ,_ee );_bee !=nil {return nil ,_bee ;};};
};};return _cg ,nil ;};func _cabd (_dfdf _b .Image )(Image ,error ){if _fgb ,_cbgb :=_dfdf .(*Gray8 );_cbgb {return _fgb .Copy (),nil ;};_gbacd :=_dfdf .Bounds ();_adgc ,_egg :=NewImage (_gbacd .Max .X ,_gbacd .Max .Y ,8,1,nil ,nil ,nil );if _egg !=nil {return nil ,_egg ;
};_gdcf (_dfdf ,_adgc ,_gbacd );return _adgc ,nil ;};func (_fgee *CMYK32 )ColorModel ()_ed .Model {return _ed .CMYKModel };func _fdcg (_fcae _b .Image )(Image ,error ){if _dfdbb ,_adefc :=_fcae .(*NRGBA64 );_adefc {return _dfdbb .Copy (),nil ;};_bgeba ,_cgcfe ,_egcf :=_cebd (_fcae ,2);
_ebbf ,_efecd :=NewImage (_bgeba .Max .X ,_bgeba .Max .Y ,16,3,nil ,_egcf ,nil );if _efecd !=nil {return nil ,_efecd ;};_eafe (_fcae ,_ebbf ,_bgeba );if len (_egcf )!=0&&!_cgcfe {if _fcad :=_gfee (_egcf ,_ebbf );_fcad !=nil {return nil ,_fcad ;};};return _ebbf ,nil ;
};func ImgToGray (i _b .Image )*_b .Gray {if _gfegc ,_dgafe :=i .(*_b .Gray );_dgafe {return _gfegc ;};_bgae :=i .Bounds ();_eeee :=_b .NewGray (_bgae );for _cdaef :=0;_cdaef < _bgae .Max .X ;_cdaef ++{for _egae :=0;_egae < _bgae .Max .Y ;_egae ++{_cfgf :=i .At (_cdaef ,_egae );
_eeee .Set (_cdaef ,_egae ,_cfgf );};};return _eeee ;};func _bb (_dc ,_ad *Monochrome )(_dce error ){_add :=_ad .BytesPerLine ;_degf :=_dc .BytesPerLine ;var (_bge byte ;_bgc uint16 ;_cd ,_bbb ,_bad ,_bf ,_ggc int ;);for _bad =0;_bad < _ad .Height ;_bad ++{_cd =_bad *_add ;
_bbb =2*_bad *_degf ;for _bf =0;_bf < _add ;_bf ++{_bge =_ad .Data [_cd +_bf ];_bgc =_faf [_bge ];_ggc =_bbb +_bf *2;if _dc .BytesPerLine !=_ad .BytesPerLine *2&&(_bf +1)*2> _dc .BytesPerLine {_dce =_dc .setByte (_ggc ,byte (_bgc >>8));}else {_dce =_dc .setTwoBytes (_ggc ,_bgc );
};if _dce !=nil {return _dce ;};};for _bf =0;_bf < _degf ;_bf ++{_ggc =_bbb +_degf +_bf ;_bge =_dc .Data [_bbb +_bf ];if _dce =_dc .setByte (_ggc ,_bge );_dce !=nil {return _dce ;};};};return nil ;};func (_aecf *Gray2 )Set (x ,y int ,c _ed .Color ){if x >=_aecf .Width ||y >=_aecf .Height {return ;
};_cgcf :=Gray2Model .Convert (c ).(_ed .Gray );_geaec :=y *_aecf .BytesPerLine ;_deeg :=_geaec +(x >>2);_gdaf :=_cgcf .Y >>6;_aecf .Data [_deeg ]=(_aecf .Data [_deeg ]&(^(0xc0>>uint (2*((x )&3)))))|(_gdaf <<uint (6-2*(x &3)));};func (_aee *Monochrome )SetGray (x ,y int ,g _ed .Gray ){_ffcce :=y *_aee .BytesPerLine +x >>3;
if _ffcce > len (_aee .Data )-1{return ;};g =_adag (g ,monochromeModel (_aee .ModelThreshold ));_aee .setGray (x ,g ,_ffcce );};func (_eddg *ImageBase )HasAlpha ()bool {if _eddg .Alpha ==nil {return false ;};for _egdb :=range _eddg .Alpha {if _eddg .Alpha [_egdb ]!=0xff{return true ;
};};return false ;};func (_cegd *Gray8 )ColorModel ()_ed .Model {return _ed .GrayModel };func (_dde monochromeModel )Convert (c _ed .Color )_ed .Color {_bcff :=_ed .GrayModel .Convert (c ).(_ed .Gray );return _adag (_bcff ,_dde );};func _egce (_bdbg _ed .Gray )_ed .CMYK {return _ed .CMYK {K :0xff-_bdbg .Y }};
func (_ebda *Gray8 )ColorAt (x ,y int )(_ed .Color ,error ){return ColorAtGray8BPC (x ,y ,_ebda .BytesPerLine ,_ebda .Data ,_ebda .Decode );};func _cefb (_abade nrgba64 ,_gcgcf RGBA ,_face _b .Rectangle ){for _eecf :=0;_eecf < _face .Max .X ;_eecf ++{for _daadf :=0;
_daadf < _face .Max .Y ;_daadf ++{_dbdaa :=_abade .NRGBA64At (_eecf ,_daadf );_gcgcf .SetRGBA (_eecf ,_daadf ,_ada (_dbdaa ));};};};func (_fded *Monochrome )ScaleLow (width ,height int )(*Monochrome ,error ){if width < 0||height < 0{return nil ,_d .New ("\u0070\u0072\u006f\u0076\u0069\u0064e\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0069\u0064t\u0068\u0020\u0061\u006e\u0064\u0020\u0068e\u0069\u0067\u0068\u0074");
};_aaae :=_bdc (width ,height );_agaa :=make ([]int ,height );_dgdg :=make ([]int ,width );_acab :=float64 (_fded .Width )/float64 (width );_dac :=float64 (_fded .Height )/float64 (height );for _aefd :=0;_aefd < height ;_aefd ++{_agaa [_aefd ]=int (_g .Min (_dac *float64 (_aefd )+0.5,float64 (_fded .Height -1)));
};for _ggbd :=0;_ggbd < width ;_ggbd ++{_dgdg [_ggbd ]=int (_g .Min (_acab *float64 (_ggbd )+0.5,float64 (_fded .Width -1)));};_gaaa :=-1;_gcdb :=byte (0);for _gedg :=0;_gedg < height ;_gedg ++{_bade :=_agaa [_gedg ]*_fded .BytesPerLine ;_gddd :=_gedg *_aaae .BytesPerLine ;
for _bdgg :=0;_bdgg < width ;_bdgg ++{_dabf :=_dgdg [_bdgg ];if _dabf !=_gaaa {_gcdb =_fded .getBit (_bade ,_dabf );if _gcdb !=0{_aaae .setBit (_gddd ,_bdgg );};_gaaa =_dabf ;}else {if _gcdb !=0{_aaae .setBit (_gddd ,_bdgg );};};};};return _aaae ,nil ;
};func ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine int ,data []byte ,decode []float64 )(_ed .Color ,error ){switch bitsPerColor {case 1:return ColorAtGray1BPC (x ,y ,bytesPerLine ,data ,decode );case 2:return ColorAtGray2BPC (x ,y ,bytesPerLine ,data ,decode );
case 4:return ColorAtGray4BPC (x ,y ,bytesPerLine ,data ,decode );case 8:return ColorAtGray8BPC (x ,y ,bytesPerLine ,data ,decode );case 16:return ColorAtGray16BPC (x ,y ,bytesPerLine ,data ,decode );default:return nil ,_c .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0067\u0072\u0061\u0079\u0020\u0073c\u0061\u006c\u0065\u0020\u0062\u0069\u0074s\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020a\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );
};};func _fece (_eaea *Monochrome ,_aeag ,_agf ,_eaed ,_fccd int ,_gdbe RasterOperator ,_eedb *Monochrome ,_cdac ,_aged int )error {var (_afce byte ;_eec int ;_eeeb int ;_gdbf ,_aedcc int ;_efcfc ,_fecd int ;);_cgfc :=_eaed >>3;_abdbb :=_eaed &7;if _abdbb > 0{_afce =_dgac [_abdbb ];
};_eec =_eedb .BytesPerLine *_aged +(_cdac >>3);_eeeb =_eaea .BytesPerLine *_agf +(_aeag >>3);switch _gdbe {case PixSrc :for _efcfc =0;_efcfc < _fccd ;_efcfc ++{_gdbf =_eec +_efcfc *_eedb .BytesPerLine ;_aedcc =_eeeb +_efcfc *_eaea .BytesPerLine ;for _fecd =0;
_fecd < _cgfc ;_fecd ++{_eaea .Data [_aedcc ]=_eedb .Data [_gdbf ];_aedcc ++;_gdbf ++;};if _abdbb > 0{_eaea .Data [_aedcc ]=_gdfb (_eaea .Data [_aedcc ],_eedb .Data [_gdbf ],_afce );};};case PixNotSrc :for _efcfc =0;_efcfc < _fccd ;_efcfc ++{_gdbf =_eec +_efcfc *_eedb .BytesPerLine ;
_aedcc =_eeeb +_efcfc *_eaea .BytesPerLine ;for _fecd =0;_fecd < _cgfc ;_fecd ++{_eaea .Data [_aedcc ]=^(_eedb .Data [_gdbf ]);_aedcc ++;_gdbf ++;};if _abdbb > 0{_eaea .Data [_aedcc ]=_gdfb (_eaea .Data [_aedcc ],^_eedb .Data [_gdbf ],_afce );};};case PixSrcOrDst :for _efcfc =0;
_efcfc < _fccd ;_efcfc ++{_gdbf =_eec +_efcfc *_eedb .BytesPerLine ;_aedcc =_eeeb +_efcfc *_eaea .BytesPerLine ;for _fecd =0;_fecd < _cgfc ;_fecd ++{_eaea .Data [_aedcc ]|=_eedb .Data [_gdbf ];_aedcc ++;_gdbf ++;};if _abdbb > 0{_eaea .Data [_aedcc ]=_gdfb (_eaea .Data [_aedcc ],_eedb .Data [_gdbf ]|_eaea .Data [_aedcc ],_afce );
};};case PixSrcAndDst :for _efcfc =0;_efcfc < _fccd ;_efcfc ++{_gdbf =_eec +_efcfc *_eedb .BytesPerLine ;_aedcc =_eeeb +_efcfc *_eaea .BytesPerLine ;for _fecd =0;_fecd < _cgfc ;_fecd ++{_eaea .Data [_aedcc ]&=_eedb .Data [_gdbf ];_aedcc ++;_gdbf ++;};if _abdbb > 0{_eaea .Data [_aedcc ]=_gdfb (_eaea .Data [_aedcc ],_eedb .Data [_gdbf ]&_eaea .Data [_aedcc ],_afce );
};};case PixSrcXorDst :for _efcfc =0;_efcfc < _fccd ;_efcfc ++{_gdbf =_eec +_efcfc *_eedb .BytesPerLine ;_aedcc =_eeeb +_efcfc *_eaea .BytesPerLine ;for _fecd =0;_fecd < _cgfc ;_fecd ++{_eaea .Data [_aedcc ]^=_eedb .Data [_gdbf ];_aedcc ++;_gdbf ++;};if _abdbb > 0{_eaea .Data [_aedcc ]=_gdfb (_eaea .Data [_aedcc ],_eedb .Data [_gdbf ]^_eaea .Data [_aedcc ],_afce );
};};case PixNotSrcOrDst :for _efcfc =0;_efcfc < _fccd ;_efcfc ++{_gdbf =_eec +_efcfc *_eedb .BytesPerLine ;_aedcc =_eeeb +_efcfc *_eaea .BytesPerLine ;for _fecd =0;_fecd < _cgfc ;_fecd ++{_eaea .Data [_aedcc ]|=^(_eedb .Data [_gdbf ]);_aedcc ++;_gdbf ++;
};if _abdbb > 0{_eaea .Data [_aedcc ]=_gdfb (_eaea .Data [_aedcc ],^(_eedb .Data [_gdbf ])|_eaea .Data [_aedcc ],_afce );};};case PixNotSrcAndDst :for _efcfc =0;_efcfc < _fccd ;_efcfc ++{_gdbf =_eec +_efcfc *_eedb .BytesPerLine ;_aedcc =_eeeb +_efcfc *_eaea .BytesPerLine ;
for _fecd =0;_fecd < _cgfc ;_fecd ++{_eaea .Data [_aedcc ]&=^(_eedb .Data [_gdbf ]);_aedcc ++;_gdbf ++;};if _abdbb > 0{_eaea .Data [_aedcc ]=_gdfb (_eaea .Data [_aedcc ],^(_eedb .Data [_gdbf ])&_eaea .Data [_aedcc ],_afce );};};case PixSrcOrNotDst :for _efcfc =0;
_efcfc < _fccd ;_efcfc ++{_gdbf =_eec +_efcfc *_eedb .BytesPerLine ;_aedcc =_eeeb +_efcfc *_eaea .BytesPerLine ;for _fecd =0;_fecd < _cgfc ;_fecd ++{_eaea .Data [_aedcc ]=_eedb .Data [_gdbf ]|^(_eaea .Data [_aedcc ]);_aedcc ++;_gdbf ++;};if _abdbb > 0{_eaea .Data [_aedcc ]=_gdfb (_eaea .Data [_aedcc ],_eedb .Data [_gdbf ]|^(_eaea .Data [_aedcc ]),_afce );
};};case PixSrcAndNotDst :for _efcfc =0;_efcfc < _fccd ;_efcfc ++{_gdbf =_eec +_efcfc *_eedb .BytesPerLine ;_aedcc =_eeeb +_efcfc *_eaea .BytesPerLine ;for _fecd =0;_fecd < _cgfc ;_fecd ++{_eaea .Data [_aedcc ]=_eedb .Data [_gdbf ]&^(_eaea .Data [_aedcc ]);
_aedcc ++;_gdbf ++;};if _abdbb > 0{_eaea .Data [_aedcc ]=_gdfb (_eaea .Data [_aedcc ],_eedb .Data [_gdbf ]&^(_eaea .Data [_aedcc ]),_afce );};};case PixNotPixSrcOrDst :for _efcfc =0;_efcfc < _fccd ;_efcfc ++{_gdbf =_eec +_efcfc *_eedb .BytesPerLine ;_aedcc =_eeeb +_efcfc *_eaea .BytesPerLine ;
for _fecd =0;_fecd < _cgfc ;_fecd ++{_eaea .Data [_aedcc ]=^(_eedb .Data [_gdbf ]|_eaea .Data [_aedcc ]);_aedcc ++;_gdbf ++;};if _abdbb > 0{_eaea .Data [_aedcc ]=_gdfb (_eaea .Data [_aedcc ],^(_eedb .Data [_gdbf ]|_eaea .Data [_aedcc ]),_afce );};};case PixNotPixSrcAndDst :for _efcfc =0;
_efcfc < _fccd ;_efcfc ++{_gdbf =_eec +_efcfc *_eedb .BytesPerLine ;_aedcc =_eeeb +_efcfc *_eaea .BytesPerLine ;for _fecd =0;_fecd < _cgfc ;_fecd ++{_eaea .Data [_aedcc ]=^(_eedb .Data [_gdbf ]&_eaea .Data [_aedcc ]);_aedcc ++;_gdbf ++;};if _abdbb > 0{_eaea .Data [_aedcc ]=_gdfb (_eaea .Data [_aedcc ],^(_eedb .Data [_gdbf ]&_eaea .Data [_aedcc ]),_afce );
};};case PixNotPixSrcXorDst :for _efcfc =0;_efcfc < _fccd ;_efcfc ++{_gdbf =_eec +_efcfc *_eedb .BytesPerLine ;_aedcc =_eeeb +_efcfc *_eaea .BytesPerLine ;for _fecd =0;_fecd < _cgfc ;_fecd ++{_eaea .Data [_aedcc ]=^(_eedb .Data [_gdbf ]^_eaea .Data [_aedcc ]);
_aedcc ++;_gdbf ++;};if _abdbb > 0{_eaea .Data [_aedcc ]=_gdfb (_eaea .Data [_aedcc ],^(_eedb .Data [_gdbf ]^_eaea .Data [_aedcc ]),_afce );};};default:_gg .Log .Debug ("\u0050\u0072ov\u0069\u0064\u0065d\u0020\u0069\u006e\u0076ali\u0064 r\u0061\u0073\u0074\u0065\u0072\u0020\u006fpe\u0072\u0061\u0074\u006f\u0072\u003a\u0020%\u0076",_gdbe );
return _d .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072");};return nil ;};type NRGBA32 struct{ImageBase };func _bfc (_cae ,_aaf int ,_dea []byte )*Monochrome {_ead :=_bdc (_cae ,_aaf );
_ead .Data =_dea ;return _ead ;};func (_cgbf *NRGBA32 )Base ()*ImageBase {return &_cgbf .ImageBase };func (_agcge *RGBA32 )ColorAt (x ,y int )(_ed .Color ,error ){return ColorAtRGBA32 (x ,y ,_agcge .Width ,_agcge .Data ,_agcge .Alpha ,_agcge .Decode );
};func _ecg (_gb int )[]uint {var _dcb []uint ;_dceg :=_gb ;_cag :=_dceg /8;if _cag !=0{for _ceg :=0;_ceg < _cag ;_ceg ++{_dcb =append (_dcb ,8);};_faa :=_dceg %8;_dceg =0;if _faa !=0{_dceg =_faa ;};};_edca :=_dceg /4;if _edca !=0{for _bba :=0;_bba < _edca ;
_bba ++{_dcb =append (_dcb ,4);};_cge :=_dceg %4;_dceg =0;if _cge !=0{_dceg =_cge ;};};_gfd :=_dceg /2;if _gfd !=0{for _daa :=0;_daa < _gfd ;_daa ++{_dcb =append (_dcb ,2);};};return _dcb ;};func (_geac *ImageBase )getByte (_ddce int )(byte ,error ){if _ddce > len (_geac .Data )-1||_ddce < 0{return 0,_c .Errorf ("\u0069\u006e\u0064\u0065x:\u0020\u0025\u0064\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006eg\u0065",_ddce );
};return _geac .Data [_ddce ],nil ;};func (_bfae *Gray8 )Set (x ,y int ,c _ed .Color ){_dacd :=y *_bfae .BytesPerLine +x ;if _dacd > len (_bfae .Data )-1{return ;};_afde :=_ed .GrayModel .Convert (c );_bfae .Data [_dacd ]=_afde .(_ed .Gray ).Y ;};func (_bggc *Gray4 )Copy ()Image {return &Gray4 {ImageBase :_bggc .copy ()}};
func (_ccef *Gray2 )ColorAt (x ,y int )(_ed .Color ,error ){return ColorAtGray2BPC (x ,y ,_ccef .BytesPerLine ,_ccef .Data ,_ccef .Decode );};func _fbfd (_egb _ed .NRGBA )_ed .Gray {var _fcfe _ed .NRGBA ;if _egb ==_fcfe {return _ed .Gray {Y :0xff};};_fec ,_ebc ,_aff ,_ :=_egb .RGBA ();
_ced :=(19595*_fec +38470*_ebc +7471*_aff +1<<15)>>24;return _ed .Gray {Y :uint8 (_ced )};};func (_gdgg *ImageBase )setTwoBytes (_ggfg int ,_acef uint16 )error {if _ggfg +1> len (_gdgg .Data )-1{return _d .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_gdgg .Data [_ggfg ]=byte ((_acef &0xff00)>>8);_gdgg .Data [_ggfg +1]=byte (_acef &0xff);return nil ;};func (_gggb *NRGBA16 )Validate ()error {if len (_gggb .Data )!=3*_gggb .Width *_gggb .Height /2{return _d .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func ImgToBinary (i _b .Image ,threshold uint8 )*_b .Gray {switch _bffa :=i .(type ){case *_b .Gray :if _bcag (_bffa ){return _bffa ;};return _dedf (_bffa ,threshold );case *_b .Gray16 :return _bagbc (_bffa ,threshold );default:return _aafb (_bffa ,threshold );
};};func _becb (){for _defd :=0;_defd < 256;_defd ++{_ceb [_defd ]=uint8 (_defd &0x1)+(uint8 (_defd >>1)&0x1)+(uint8 (_defd >>2)&0x1)+(uint8 (_defd >>3)&0x1)+(uint8 (_defd >>4)&0x1)+(uint8 (_defd >>5)&0x1)+(uint8 (_defd >>6)&0x1)+(uint8 (_defd >>7)&0x1);
};};func LinearInterpolate (x ,xmin ,xmax ,ymin ,ymax float64 )float64 {if _g .Abs (xmax -xmin )< 0.000001{return ymin ;};_gcf :=ymin +(x -xmin )*(ymax -ymin )/(xmax -xmin );return _gcf ;};func (_ddd *NRGBA16 )ColorModel ()_ed .Model {return NRGBA16Model };
func _fcfga (_geaad _b .Image )(Image ,error ){if _ebec ,_feca :=_geaad .(*Gray2 );_feca {return _ebec .Copy (),nil ;};_ebgb :=_geaad .Bounds ();_dafbe ,_bfad :=NewImage (_ebgb .Max .X ,_ebgb .Max .Y ,2,1,nil ,nil ,nil );if _bfad !=nil {return nil ,_bfad ;
};_gdcf (_geaad ,_dafbe ,_ebgb );return _dafbe ,nil ;};var _ NRGBA =&NRGBA32 {};func (_fcb *Gray2 )Bounds ()_b .Rectangle {return _b .Rectangle {Max :_b .Point {X :_fcb .Width ,Y :_fcb .Height }};};func (_ceeb *Monochrome )At (x ,y int )_ed .Color {_edba ,_ :=_ceeb .ColorAt (x ,y );
return _edba };func (_acaf *Gray16 )Validate ()error {if len (_acaf .Data )!=_acaf .Height *_acaf .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_gag *ImageBase )MakeAlpha (){_gag .newAlpha ()};type RasterOperator int ;func _aeca (_edcc RGBA ,_ffda Gray ,_abdb _b .Rectangle ){for _ecga :=0;
_ecga < _abdb .Max .X ;_ecga ++{for _ceebe :=0;_ceebe < _abdb .Max .Y ;_ceebe ++{_fcbg :=_cgec (_edcc .RGBAAt (_ecga ,_ceebe ));_ffda .SetGray (_ecga ,_ceebe ,_fcbg );};};};var _ Gray =&Monochrome {};func ColorAtGray16BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_ed .Gray16 ,error ){_aadad :=(y *bytesPerLine /2+x )*2;
if _aadad +1>=len (data ){return _ed .Gray16 {},_c .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_abadf :=uint16 (data [_aadad ])<<8|uint16 (data [_aadad +1]);if len (decode )==2{_abadf =uint16 (uint64 (LinearInterpolate (float64 (_abadf ),0,65535,decode [0],decode [1])));};return _ed .Gray16 {Y :_abadf },nil ;};func _deg (_bc *Monochrome ,_ea int ,_cb []uint )(*Monochrome ,error ){_ec :=_ea *_bc .Width ;
_edf :=_ea *_bc .Height ;_dg :=_bdc (_ec ,_edf );for _ge ,_ag :=range _cb {var _fg error ;switch _ag {case 2:_fg =_bb (_dg ,_bc );case 4:_fg =_ef (_dg ,_bc );case 8:_fg =_fbf (_dg ,_bc );};if _fg !=nil {return nil ,_fg ;};if _ge !=len (_cb )-1{_bc =_dg .copy ();
};};return _dg ,nil ;};func (_edfc *Gray4 )Validate ()error {if len (_edfc .Data )!=_edfc .Height *_edfc .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_fed *Monochrome )ReduceBinary (factor float64 )(*Monochrome ,error ){_ccff :=_fccab (uint (factor ));
if !IsPowerOf2 (uint (factor )){_ccff ++;};_baga :=make ([]int ,_ccff );for _ffb :=range _baga {_baga [_ffb ]=4;};_gdff ,_agce :=_gab (_fed ,_baga ...);if _agce !=nil {return nil ,_agce ;};return _gdff ,nil ;};func _aadc (_eaag *Monochrome ,_dbfc ,_ggff ,_bdac ,_dfdb int ,_bbed RasterOperator ){if _dbfc < 0{_bdac +=_dbfc ;
_dbfc =0;};_gecc :=_dbfc +_bdac -_eaag .Width ;if _gecc > 0{_bdac -=_gecc ;};if _ggff < 0{_dfdb +=_ggff ;_ggff =0;};_agbf :=_ggff +_dfdb -_eaag .Height ;if _agbf > 0{_dfdb -=_agbf ;};if _bdac <=0||_dfdb <=0{return ;};if (_dbfc &7)==0{_gcdg (_eaag ,_dbfc ,_ggff ,_bdac ,_dfdb ,_bbed );
}else {_bagef (_eaag ,_dbfc ,_ggff ,_bdac ,_dfdb ,_bbed );};};func (_bggcg *NRGBA16 )SetNRGBA (x ,y int ,c _ed .NRGBA ){_ceag :=y *_bggcg .BytesPerLine +x *3/2;if _ceag +1>=len (_bggcg .Data ){return ;};c =_eedbb (c );_bggcg .setNRGBA (x ,y ,_ceag ,c );
};func (_dgce *NRGBA64 )ColorAt (x ,y int )(_ed .Color ,error ){return ColorAtNRGBA64 (x ,y ,_dgce .Width ,_dgce .Data ,_dgce .Alpha ,_dgce .Decode );};func (_bfb *Gray16 )Copy ()Image {return &Gray16 {ImageBase :_bfb .copy ()}};func (_gff *Monochrome )InverseData ()error {return _gff .RasterOperation (0,0,_gff .Width ,_gff .Height ,PixNotDst ,nil ,0,0);
};func _caec (_fcdb _ed .NYCbCrA )_ed .NRGBA {_cfa :=int32 (_fcdb .Y )*0x10101;_aac :=int32 (_fcdb .Cb )-128;_gaed :=int32 (_fcdb .Cr )-128;_bdce :=_cfa +91881*_gaed ;if uint32 (_bdce )&0xff000000==0{_bdce >>=8;}else {_bdce =^(_bdce >>31)&0xffff;};_gbad :=_cfa -22554*_aac -46802*_gaed ;
if uint32 (_gbad )&0xff000000==0{_gbad >>=8;}else {_gbad =^(_gbad >>31)&0xffff;};_bde :=_cfa +116130*_aac ;if uint32 (_bde )&0xff000000==0{_bde >>=8;}else {_bde =^(_bde >>31)&0xffff;};return _ed .NRGBA {R :uint8 (_bdce >>8),G :uint8 (_gbad >>8),B :uint8 (_bde >>8),A :_fcdb .A };
};func _gge ()(_daf [256]uint16 ){for _ccd :=0;_ccd < 256;_ccd ++{if _ccd &0x01!=0{_daf [_ccd ]|=0x3;};if _ccd &0x02!=0{_daf [_ccd ]|=0xc;};if _ccd &0x04!=0{_daf [_ccd ]|=0x30;};if _ccd &0x08!=0{_daf [_ccd ]|=0xc0;};if _ccd &0x10!=0{_daf [_ccd ]|=0x300;
};if _ccd &0x20!=0{_daf [_ccd ]|=0xc00;};if _ccd &0x40!=0{_daf [_ccd ]|=0x3000;};if _ccd &0x80!=0{_daf [_ccd ]|=0xc000;};};return _daf ;};func (_fdc *Gray4 )Histogram ()(_bbf [256]int ){for _aadd :=0;_aadd < _fdc .Width ;_aadd ++{for _gbce :=0;_gbce < _fdc .Height ;
_gbce ++{_bbf [_fdc .GrayAt (_aadd ,_gbce ).Y ]++;};};return _bbf ;};func (_ccbd *monochromeThresholdConverter )Convert (img _b .Image )(Image ,error ){if _bgeb ,_eagd :=img .(*Monochrome );_eagd {return _bgeb .Copy (),nil ;};_fffb :=img .Bounds ();_dede ,_deddb :=NewImage (_fffb .Max .X ,_fffb .Max .Y ,1,1,nil ,nil ,nil );
if _deddb !=nil {return nil ,_deddb ;};_dede .(*Monochrome ).ModelThreshold =_ccbd .Threshold ;for _fcca :=0;_fcca < _fffb .Max .X ;_fcca ++{for _bage :=0;_bage < _fffb .Max .Y ;_bage ++{_agd :=img .At (_fcca ,_bage );_dede .Set (_fcca ,_bage ,_agd );};
};return _dede ,nil ;};func (_gffa *Gray2 )Base ()*ImageBase {return &_gffa .ImageBase };type Gray2 struct{ImageBase };func _bagbc (_egeee *_b .Gray16 ,_fffg uint8 )*_b .Gray {_aafdb :=_egeee .Bounds ();_fdbaf :=_b .NewGray (_aafdb );for _abbdd :=0;_abbdd < _aafdb .Dx ();
_abbdd ++{for _fcfd :=0;_fcfd < _aafdb .Dy ();_fcfd ++{_daab :=_egeee .Gray16At (_abbdd ,_fcfd );_fdbaf .SetGray (_abbdd ,_fcfd ,_ed .Gray {Y :_caba (uint8 (_daab .Y /256),_fffg )});};};return _fdbaf ;};func (_edg *Gray8 )Validate ()error {if len (_edg .Data )!=_edg .Height *_edg .BytesPerLine {return ErrInvalidImage ;
};return nil ;};func _cadd (_ddccf *Monochrome ,_eaddc ,_ecgcd ,_aecc ,_fdeg int ,_ddcg RasterOperator ,_fdf *Monochrome ,_dbbbb ,_ebb int )error {var (_gdcfb bool ;_gcfa bool ;_cdca byte ;_eabb int ;_ccfc int ;_bcac int ;_bdgd int ;_ebag bool ;_gfae int ;
_eged int ;_gfgf int ;_dgaf bool ;_ccfe byte ;_ecbc int ;_bdbf int ;_eefbb int ;_gabc byte ;_gggg int ;_eca int ;_fecgg uint ;_agfc uint ;_dbbf byte ;_dbg shift ;_bebc bool ;_daga bool ;_bccbf ,_bfd int ;);if _dbbbb &7!=0{_eca =8-(_dbbbb &7);};if _eaddc &7!=0{_ccfc =8-(_eaddc &7);
};if _eca ==0&&_ccfc ==0{_dbbf =_aadcc [0];}else {if _ccfc > _eca {_fecgg =uint (_ccfc -_eca );}else {_fecgg =uint (8-(_eca -_ccfc ));};_agfc =8-_fecgg ;_dbbf =_aadcc [_fecgg ];};if (_eaddc &7)!=0{_gdcfb =true ;_eabb =8-(_eaddc &7);_cdca =_aadcc [_eabb ];
_bcac =_ddccf .BytesPerLine *_ecgcd +(_eaddc >>3);_bdgd =_fdf .BytesPerLine *_ebb +(_dbbbb >>3);_gggg =8-(_dbbbb &7);if _eabb > _gggg {_dbg =_adgce ;if _aecc >=_eca {_bebc =true ;};}else {_dbg =_fbfc ;};};if _aecc < _eabb {_gcfa =true ;_cdca &=_dgac [8-_eabb +_aecc ];
};if !_gcfa {_gfae =(_aecc -_eabb )>>3;if _gfae !=0{_ebag =true ;_eged =_ddccf .BytesPerLine *_ecgcd +((_eaddc +_ccfc )>>3);_gfgf =_fdf .BytesPerLine *_ebb +((_dbbbb +_ccfc )>>3);};};_ecbc =(_eaddc +_aecc )&7;if !(_gcfa ||_ecbc ==0){_dgaf =true ;_ccfe =_dgac [_ecbc ];
_bdbf =_ddccf .BytesPerLine *_ecgcd +((_eaddc +_ccfc )>>3)+_gfae ;_eefbb =_fdf .BytesPerLine *_ebb +((_dbbbb +_ccfc )>>3)+_gfae ;if _ecbc > int (_agfc ){_daga =true ;};};switch _ddcg {case PixSrc :if _gdcfb {for _bccbf =0;_bccbf < _fdeg ;_bccbf ++{if _dbg ==_adgce {_gabc =_fdf .Data [_bdgd ]<<_fecgg ;
if _bebc {_gabc =_gdfb (_gabc ,_fdf .Data [_bdgd +1]>>_agfc ,_dbbf );};}else {_gabc =_fdf .Data [_bdgd ]>>_agfc ;};_ddccf .Data [_bcac ]=_gdfb (_ddccf .Data [_bcac ],_gabc ,_cdca );_bcac +=_ddccf .BytesPerLine ;_bdgd +=_fdf .BytesPerLine ;};};if _ebag {for _bccbf =0;
_bccbf < _fdeg ;_bccbf ++{for _bfd =0;_bfd < _gfae ;_bfd ++{_gabc =_gdfb (_fdf .Data [_gfgf +_bfd ]<<_fecgg ,_fdf .Data [_gfgf +_bfd +1]>>_agfc ,_dbbf );_ddccf .Data [_eged +_bfd ]=_gabc ;};_eged +=_ddccf .BytesPerLine ;_gfgf +=_fdf .BytesPerLine ;};};
if _dgaf {for _bccbf =0;_bccbf < _fdeg ;_bccbf ++{_gabc =_fdf .Data [_eefbb ]<<_fecgg ;if _daga {_gabc =_gdfb (_gabc ,_fdf .Data [_eefbb +1]>>_agfc ,_dbbf );};_ddccf .Data [_bdbf ]=_gdfb (_ddccf .Data [_bdbf ],_gabc ,_ccfe );_bdbf +=_ddccf .BytesPerLine ;
_eefbb +=_fdf .BytesPerLine ;};};case PixNotSrc :if _gdcfb {for _bccbf =0;_bccbf < _fdeg ;_bccbf ++{if _dbg ==_adgce {_gabc =_fdf .Data [_bdgd ]<<_fecgg ;if _bebc {_gabc =_gdfb (_gabc ,_fdf .Data [_bdgd +1]>>_agfc ,_dbbf );};}else {_gabc =_fdf .Data [_bdgd ]>>_agfc ;
};_ddccf .Data [_bcac ]=_gdfb (_ddccf .Data [_bcac ],^_gabc ,_cdca );_bcac +=_ddccf .BytesPerLine ;_bdgd +=_fdf .BytesPerLine ;};};if _ebag {for _bccbf =0;_bccbf < _fdeg ;_bccbf ++{for _bfd =0;_bfd < _gfae ;_bfd ++{_gabc =_gdfb (_fdf .Data [_gfgf +_bfd ]<<_fecgg ,_fdf .Data [_gfgf +_bfd +1]>>_agfc ,_dbbf );
_ddccf .Data [_eged +_bfd ]=^_gabc ;};_eged +=_ddccf .BytesPerLine ;_gfgf +=_fdf .BytesPerLine ;};};if _dgaf {for _bccbf =0;_bccbf < _fdeg ;_bccbf ++{_gabc =_fdf .Data [_eefbb ]<<_fecgg ;if _daga {_gabc =_gdfb (_gabc ,_fdf .Data [_eefbb +1]>>_agfc ,_dbbf );
};_ddccf .Data [_bdbf ]=_gdfb (_ddccf .Data [_bdbf ],^_gabc ,_ccfe );_bdbf +=_ddccf .BytesPerLine ;_eefbb +=_fdf .BytesPerLine ;};};case PixSrcOrDst :if _gdcfb {for _bccbf =0;_bccbf < _fdeg ;_bccbf ++{if _dbg ==_adgce {_gabc =_fdf .Data [_bdgd ]<<_fecgg ;
if _bebc {_gabc =_gdfb (_gabc ,_fdf .Data [_bdgd +1]>>_agfc ,_dbbf );};}else {_gabc =_fdf .Data [_bdgd ]>>_agfc ;};_ddccf .Data [_bcac ]=_gdfb (_ddccf .Data [_bcac ],_gabc |_ddccf .Data [_bcac ],_cdca );_bcac +=_ddccf .BytesPerLine ;_bdgd +=_fdf .BytesPerLine ;
};};if _ebag {for _bccbf =0;_bccbf < _fdeg ;_bccbf ++{for _bfd =0;_bfd < _gfae ;_bfd ++{_gabc =_gdfb (_fdf .Data [_gfgf +_bfd ]<<_fecgg ,_fdf .Data [_gfgf +_bfd +1]>>_agfc ,_dbbf );_ddccf .Data [_eged +_bfd ]|=_gabc ;};_eged +=_ddccf .BytesPerLine ;_gfgf +=_fdf .BytesPerLine ;
};};if _dgaf {for _bccbf =0;_bccbf < _fdeg ;_bccbf ++{_gabc =_fdf .Data [_eefbb ]<<_fecgg ;if _daga {_gabc =_gdfb (_gabc ,_fdf .Data [_eefbb +1]>>_agfc ,_dbbf );};_ddccf .Data [_bdbf ]=_gdfb (_ddccf .Data [_bdbf ],_gabc |_ddccf .Data [_bdbf ],_ccfe );_bdbf +=_ddccf .BytesPerLine ;
_eefbb +=_fdf .BytesPerLine ;};};case PixSrcAndDst :if _gdcfb {for _bccbf =0;_bccbf < _fdeg ;_bccbf ++{if _dbg ==_adgce {_gabc =_fdf .Data [_bdgd ]<<_fecgg ;if _bebc {_gabc =_gdfb (_gabc ,_fdf .Data [_bdgd +1]>>_agfc ,_dbbf );};}else {_gabc =_fdf .Data [_bdgd ]>>_agfc ;
};_ddccf .Data [_bcac ]=_gdfb (_ddccf .Data [_bcac ],_gabc &_ddccf .Data [_bcac ],_cdca );_bcac +=_ddccf .BytesPerLine ;_bdgd +=_fdf .BytesPerLine ;};};if _ebag {for _bccbf =0;_bccbf < _fdeg ;_bccbf ++{for _bfd =0;_bfd < _gfae ;_bfd ++{_gabc =_gdfb (_fdf .Data [_gfgf +_bfd ]<<_fecgg ,_fdf .Data [_gfgf +_bfd +1]>>_agfc ,_dbbf );
_ddccf .Data [_eged +_bfd ]&=_gabc ;};_eged +=_ddccf .BytesPerLine ;_gfgf +=_fdf .BytesPerLine ;};};if _dgaf {for _bccbf =0;_bccbf < _fdeg ;_bccbf ++{_gabc =_fdf .Data [_eefbb ]<<_fecgg ;if _daga {_gabc =_gdfb (_gabc ,_fdf .Data [_eefbb +1]>>_agfc ,_dbbf );
};_ddccf .Data [_bdbf ]=_gdfb (_ddccf .Data [_bdbf ],_gabc &_ddccf .Data [_bdbf ],_ccfe );_bdbf +=_ddccf .BytesPerLine ;_eefbb +=_fdf .BytesPerLine ;};};case PixSrcXorDst :if _gdcfb {for _bccbf =0;_bccbf < _fdeg ;_bccbf ++{if _dbg ==_adgce {_gabc =_fdf .Data [_bdgd ]<<_fecgg ;
if _bebc {_gabc =_gdfb (_gabc ,_fdf .Data [_bdgd +1]>>_agfc ,_dbbf );};}else {_gabc =_fdf .Data [_bdgd ]>>_agfc ;};_ddccf .Data [_bcac ]=_gdfb (_ddccf .Data [_bcac ],_gabc ^_ddccf .Data [_bcac ],_cdca );_bcac +=_ddccf .BytesPerLine ;_bdgd +=_fdf .BytesPerLine ;
};};if _ebag {for _bccbf =0;_bccbf < _fdeg ;_bccbf ++{for _bfd =0;_bfd < _gfae ;_bfd ++{_gabc =_gdfb (_fdf .Data [_gfgf +_bfd ]<<_fecgg ,_fdf .Data [_gfgf +_bfd +1]>>_agfc ,_dbbf );_ddccf .Data [_eged +_bfd ]^=_gabc ;};_eged +=_ddccf .BytesPerLine ;_gfgf +=_fdf .BytesPerLine ;
};};if _dgaf {for _bccbf =0;_bccbf < _fdeg ;_bccbf ++{_gabc =_fdf .Data [_eefbb ]<<_fecgg ;if _daga {_gabc =_gdfb (_gabc ,_fdf .Data [_eefbb +1]>>_agfc ,_dbbf );};_ddccf .Data [_bdbf ]=_gdfb (_ddccf .Data [_bdbf ],_gabc ^_ddccf .Data [_bdbf ],_ccfe );_bdbf +=_ddccf .BytesPerLine ;
_eefbb +=_fdf .BytesPerLine ;};};case PixNotSrcOrDst :if _gdcfb {for _bccbf =0;_bccbf < _fdeg ;_bccbf ++{if _dbg ==_adgce {_gabc =_fdf .Data [_bdgd ]<<_fecgg ;if _bebc {_gabc =_gdfb (_gabc ,_fdf .Data [_bdgd +1]>>_agfc ,_dbbf );};}else {_gabc =_fdf .Data [_bdgd ]>>_agfc ;
};_ddccf .Data [_bcac ]=_gdfb (_ddccf .Data [_bcac ],^_gabc |_ddccf .Data [_bcac ],_cdca );_bcac +=_ddccf .BytesPerLine ;_bdgd +=_fdf .BytesPerLine ;};};if _ebag {for _bccbf =0;_bccbf < _fdeg ;_bccbf ++{for _bfd =0;_bfd < _gfae ;_bfd ++{_gabc =_gdfb (_fdf .Data [_gfgf +_bfd ]<<_fecgg ,_fdf .Data [_gfgf +_bfd +1]>>_agfc ,_dbbf );
_ddccf .Data [_eged +_bfd ]|=^_gabc ;};_eged +=_ddccf .BytesPerLine ;_gfgf +=_fdf .BytesPerLine ;};};if _dgaf {for _bccbf =0;_bccbf < _fdeg ;_bccbf ++{_gabc =_fdf .Data [_eefbb ]<<_fecgg ;if _daga {_gabc =_gdfb (_gabc ,_fdf .Data [_eefbb +1]>>_agfc ,_dbbf );
};_ddccf .Data [_bdbf ]=_gdfb (_ddccf .Data [_bdbf ],^_gabc |_ddccf .Data [_bdbf ],_ccfe );_bdbf +=_ddccf .BytesPerLine ;_eefbb +=_fdf .BytesPerLine ;};};case PixNotSrcAndDst :if _gdcfb {for _bccbf =0;_bccbf < _fdeg ;_bccbf ++{if _dbg ==_adgce {_gabc =_fdf .Data [_bdgd ]<<_fecgg ;
if _bebc {_gabc =_gdfb (_gabc ,_fdf .Data [_bdgd +1]>>_agfc ,_dbbf );};}else {_gabc =_fdf .Data [_bdgd ]>>_agfc ;};_ddccf .Data [_bcac ]=_gdfb (_ddccf .Data [_bcac ],^_gabc &_ddccf .Data [_bcac ],_cdca );_bcac +=_ddccf .BytesPerLine ;_bdgd +=_fdf .BytesPerLine ;
};};if _ebag {for _bccbf =0;_bccbf < _fdeg ;_bccbf ++{for _bfd =0;_bfd < _gfae ;_bfd ++{_gabc =_gdfb (_fdf .Data [_gfgf +_bfd ]<<_fecgg ,_fdf .Data [_gfgf +_bfd +1]>>_agfc ,_dbbf );_ddccf .Data [_eged +_bfd ]&=^_gabc ;};_eged +=_ddccf .BytesPerLine ;_gfgf +=_fdf .BytesPerLine ;
};};if _dgaf {for _bccbf =0;_bccbf < _fdeg ;_bccbf ++{_gabc =_fdf .Data [_eefbb ]<<_fecgg ;if _daga {_gabc =_gdfb (_gabc ,_fdf .Data [_eefbb +1]>>_agfc ,_dbbf );};_ddccf .Data [_bdbf ]=_gdfb (_ddccf .Data [_bdbf ],^_gabc &_ddccf .Data [_bdbf ],_ccfe );
_bdbf +=_ddccf .BytesPerLine ;_eefbb +=_fdf .BytesPerLine ;};};case PixSrcOrNotDst :if _gdcfb {for _bccbf =0;_bccbf < _fdeg ;_bccbf ++{if _dbg ==_adgce {_gabc =_fdf .Data [_bdgd ]<<_fecgg ;if _bebc {_gabc =_gdfb (_gabc ,_fdf .Data [_bdgd +1]>>_agfc ,_dbbf );
};}else {_gabc =_fdf .Data [_bdgd ]>>_agfc ;};_ddccf .Data [_bcac ]=_gdfb (_ddccf .Data [_bcac ],_gabc |^_ddccf .Data [_bcac ],_cdca );_bcac +=_ddccf .BytesPerLine ;_bdgd +=_fdf .BytesPerLine ;};};if _ebag {for _bccbf =0;_bccbf < _fdeg ;_bccbf ++{for _bfd =0;
_bfd < _gfae ;_bfd ++{_gabc =_gdfb (_fdf .Data [_gfgf +_bfd ]<<_fecgg ,_fdf .Data [_gfgf +_bfd +1]>>_agfc ,_dbbf );_ddccf .Data [_eged +_bfd ]=_gabc |^_ddccf .Data [_eged +_bfd ];};_eged +=_ddccf .BytesPerLine ;_gfgf +=_fdf .BytesPerLine ;};};if _dgaf {for _bccbf =0;
_bccbf < _fdeg ;_bccbf ++{_gabc =_fdf .Data [_eefbb ]<<_fecgg ;if _daga {_gabc =_gdfb (_gabc ,_fdf .Data [_eefbb +1]>>_agfc ,_dbbf );};_ddccf .Data [_bdbf ]=_gdfb (_ddccf .Data [_bdbf ],_gabc |^_ddccf .Data [_bdbf ],_ccfe );_bdbf +=_ddccf .BytesPerLine ;
_eefbb +=_fdf .BytesPerLine ;};};case PixSrcAndNotDst :if _gdcfb {for _bccbf =0;_bccbf < _fdeg ;_bccbf ++{if _dbg ==_adgce {_gabc =_fdf .Data [_bdgd ]<<_fecgg ;if _bebc {_gabc =_gdfb (_gabc ,_fdf .Data [_bdgd +1]>>_agfc ,_dbbf );};}else {_gabc =_fdf .Data [_bdgd ]>>_agfc ;
};_ddccf .Data [_bcac ]=_gdfb (_ddccf .Data [_bcac ],_gabc &^_ddccf .Data [_bcac ],_cdca );_bcac +=_ddccf .BytesPerLine ;_bdgd +=_fdf .BytesPerLine ;};};if _ebag {for _bccbf =0;_bccbf < _fdeg ;_bccbf ++{for _bfd =0;_bfd < _gfae ;_bfd ++{_gabc =_gdfb (_fdf .Data [_gfgf +_bfd ]<<_fecgg ,_fdf .Data [_gfgf +_bfd +1]>>_agfc ,_dbbf );
_ddccf .Data [_eged +_bfd ]=_gabc &^_ddccf .Data [_eged +_bfd ];};_eged +=_ddccf .BytesPerLine ;_gfgf +=_fdf .BytesPerLine ;};};if _dgaf {for _bccbf =0;_bccbf < _fdeg ;_bccbf ++{_gabc =_fdf .Data [_eefbb ]<<_fecgg ;if _daga {_gabc =_gdfb (_gabc ,_fdf .Data [_eefbb +1]>>_agfc ,_dbbf );
};_ddccf .Data [_bdbf ]=_gdfb (_ddccf .Data [_bdbf ],_gabc &^_ddccf .Data [_bdbf ],_ccfe );_bdbf +=_ddccf .BytesPerLine ;_eefbb +=_fdf .BytesPerLine ;};};case PixNotPixSrcOrDst :if _gdcfb {for _bccbf =0;_bccbf < _fdeg ;_bccbf ++{if _dbg ==_adgce {_gabc =_fdf .Data [_bdgd ]<<_fecgg ;
if _bebc {_gabc =_gdfb (_gabc ,_fdf .Data [_bdgd +1]>>_agfc ,_dbbf );};}else {_gabc =_fdf .Data [_bdgd ]>>_agfc ;};_ddccf .Data [_bcac ]=_gdfb (_ddccf .Data [_bcac ],^(_gabc |_ddccf .Data [_bcac ]),_cdca );_bcac +=_ddccf .BytesPerLine ;_bdgd +=_fdf .BytesPerLine ;
};};if _ebag {for _bccbf =0;_bccbf < _fdeg ;_bccbf ++{for _bfd =0;_bfd < _gfae ;_bfd ++{_gabc =_gdfb (_fdf .Data [_gfgf +_bfd ]<<_fecgg ,_fdf .Data [_gfgf +_bfd +1]>>_agfc ,_dbbf );_ddccf .Data [_eged +_bfd ]=^(_gabc |_ddccf .Data [_eged +_bfd ]);};_eged +=_ddccf .BytesPerLine ;
_gfgf +=_fdf .BytesPerLine ;};};if _dgaf {for _bccbf =0;_bccbf < _fdeg ;_bccbf ++{_gabc =_fdf .Data [_eefbb ]<<_fecgg ;if _daga {_gabc =_gdfb (_gabc ,_fdf .Data [_eefbb +1]>>_agfc ,_dbbf );};_ddccf .Data [_bdbf ]=_gdfb (_ddccf .Data [_bdbf ],^(_gabc |_ddccf .Data [_bdbf ]),_ccfe );
_bdbf +=_ddccf .BytesPerLine ;_eefbb +=_fdf .BytesPerLine ;};};case PixNotPixSrcAndDst :if _gdcfb {for _bccbf =0;_bccbf < _fdeg ;_bccbf ++{if _dbg ==_adgce {_gabc =_fdf .Data [_bdgd ]<<_fecgg ;if _bebc {_gabc =_gdfb (_gabc ,_fdf .Data [_bdgd +1]>>_agfc ,_dbbf );
};}else {_gabc =_fdf .Data [_bdgd ]>>_agfc ;};_ddccf .Data [_bcac ]=_gdfb (_ddccf .Data [_bcac ],^(_gabc &_ddccf .Data [_bcac ]),_cdca );_bcac +=_ddccf .BytesPerLine ;_bdgd +=_fdf .BytesPerLine ;};};if _ebag {for _bccbf =0;_bccbf < _fdeg ;_bccbf ++{for _bfd =0;
_bfd < _gfae ;_bfd ++{_gabc =_gdfb (_fdf .Data [_gfgf +_bfd ]<<_fecgg ,_fdf .Data [_gfgf +_bfd +1]>>_agfc ,_dbbf );_ddccf .Data [_eged +_bfd ]=^(_gabc &_ddccf .Data [_eged +_bfd ]);};_eged +=_ddccf .BytesPerLine ;_gfgf +=_fdf .BytesPerLine ;};};if _dgaf {for _bccbf =0;
_bccbf < _fdeg ;_bccbf ++{_gabc =_fdf .Data [_eefbb ]<<_fecgg ;if _daga {_gabc =_gdfb (_gabc ,_fdf .Data [_eefbb +1]>>_agfc ,_dbbf );};_ddccf .Data [_bdbf ]=_gdfb (_ddccf .Data [_bdbf ],^(_gabc &_ddccf .Data [_bdbf ]),_ccfe );_bdbf +=_ddccf .BytesPerLine ;
_eefbb +=_fdf .BytesPerLine ;};};case PixNotPixSrcXorDst :if _gdcfb {for _bccbf =0;_bccbf < _fdeg ;_bccbf ++{if _dbg ==_adgce {_gabc =_fdf .Data [_bdgd ]<<_fecgg ;if _bebc {_gabc =_gdfb (_gabc ,_fdf .Data [_bdgd +1]>>_agfc ,_dbbf );};}else {_gabc =_fdf .Data [_bdgd ]>>_agfc ;
};_ddccf .Data [_bcac ]=_gdfb (_ddccf .Data [_bcac ],^(_gabc ^_ddccf .Data [_bcac ]),_cdca );_bcac +=_ddccf .BytesPerLine ;_bdgd +=_fdf .BytesPerLine ;};};if _ebag {for _bccbf =0;_bccbf < _fdeg ;_bccbf ++{for _bfd =0;_bfd < _gfae ;_bfd ++{_gabc =_gdfb (_fdf .Data [_gfgf +_bfd ]<<_fecgg ,_fdf .Data [_gfgf +_bfd +1]>>_agfc ,_dbbf );
_ddccf .Data [_eged +_bfd ]=^(_gabc ^_ddccf .Data [_eged +_bfd ]);};_eged +=_ddccf .BytesPerLine ;_gfgf +=_fdf .BytesPerLine ;};};if _dgaf {for _bccbf =0;_bccbf < _fdeg ;_bccbf ++{_gabc =_fdf .Data [_eefbb ]<<_fecgg ;if _daga {_gabc =_gdfb (_gabc ,_fdf .Data [_eefbb +1]>>_agfc ,_dbbf );
};_ddccf .Data [_bdbf ]=_gdfb (_ddccf .Data [_bdbf ],^(_gabc ^_ddccf .Data [_bdbf ]),_ccfe );_bdbf +=_ddccf .BytesPerLine ;_eefbb +=_fdf .BytesPerLine ;};};default:_gg .Log .Debug ("\u004f\u0070e\u0072\u0061\u0074\u0069\u006f\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006e\u006f\u0074\u0020\u0070\u0065\u0072\u006d\u0069tt\u0065\u0064",_ddcg );
return _d .New ("\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065r\u0061\u0074\u0069\u006f\u006e\u0020\u006eo\u0074\u0020\u0070\u0065\u0072\u006d\u0069\u0074\u0074\u0065\u0064");};return nil ;};func _gdcf (_cabdc _b .Image ,_eda Image ,_feab _b .Rectangle ){switch _dbde :=_cabdc .(type ){case Gray :_ccc (_dbde ,_eda .(Gray ),_feab );
case NRGBA :_dcg (_dbde ,_eda .(Gray ),_feab );case CMYK :_afac (_dbde ,_eda .(Gray ),_feab );case RGBA :_aeca (_dbde ,_eda .(Gray ),_feab );default:_deb (_cabdc ,_eda ,_feab );};};func _ddcf (_ebfg _ed .Color )_ed .Color {_ecggc :=_ed .NRGBAModel .Convert (_ebfg ).(_ed .NRGBA );
return _eedbb (_ecggc );};func _egag (_fgg _ed .CMYK )_ed .Gray {_gcdd ,_bcdd ,_adbf :=_ed .CMYKToRGB (_fgg .C ,_fgg .M ,_fgg .Y ,_fgg .K );_bcfa :=(19595*uint32 (_gcdd )+38470*uint32 (_bcdd )+7471*uint32 (_adbf )+1<<7)>>16;return _ed .Gray {Y :uint8 (_bcfa )};
};var _ _b .Image =&Gray16 {};func RasterOperation (dest *Monochrome ,dx ,dy ,dw ,dh int ,op RasterOperator ,src *Monochrome ,sx ,sy int )error {return _adec (dest ,dx ,dy ,dw ,dh ,op ,src ,sx ,sy );};func _gce (_eaeba *Monochrome ,_cgecb ,_eebf int ,_fdag ,_bff int ,_caef RasterOperator ,_dfg *Monochrome ,_efdg ,_cbgg int )error {var _gef ,_gffd ,_cbef ,_ceebg int ;
if _cgecb < 0{_efdg -=_cgecb ;_fdag +=_cgecb ;_cgecb =0;};if _efdg < 0{_cgecb -=_efdg ;_fdag +=_efdg ;_efdg =0;};_gef =_cgecb +_fdag -_eaeba .Width ;if _gef > 0{_fdag -=_gef ;};_gffd =_efdg +_fdag -_dfg .Width ;if _gffd > 0{_fdag -=_gffd ;};if _eebf < 0{_cbgg -=_eebf ;
_bff +=_eebf ;_eebf =0;};if _cbgg < 0{_eebf -=_cbgg ;_bff +=_cbgg ;_cbgg =0;};_cbef =_eebf +_bff -_eaeba .Height ;if _cbef > 0{_bff -=_cbef ;};_ceebg =_cbgg +_bff -_dfg .Height ;if _ceebg > 0{_bff -=_ceebg ;};if _fdag <=0||_bff <=0{return nil ;};var _fcg error ;
switch {case _cgecb &7==0&&_efdg &7==0:_fcg =_fece (_eaeba ,_cgecb ,_eebf ,_fdag ,_bff ,_caef ,_dfg ,_efdg ,_cbgg );case _cgecb &7==_efdg &7:_fcg =_bgbd (_eaeba ,_cgecb ,_eebf ,_fdag ,_bff ,_caef ,_dfg ,_efdg ,_cbgg );default:_fcg =_cadd (_eaeba ,_cgecb ,_eebf ,_fdag ,_bff ,_caef ,_dfg ,_efdg ,_cbgg );
};if _fcg !=nil {return _fcg ;};return nil ;};func FromGoImage (i _b .Image )(Image ,error ){switch _ebdd :=i .(type ){case Image :return _ebdd .Copy (),nil ;case Gray :return GrayConverter .Convert (i );case *_b .Gray16 :return Gray16Converter .Convert (i );
case CMYK :return CMYKConverter .Convert (i );case *_b .NRGBA64 :return NRGBA64Converter .Convert (i );default:return NRGBAConverter .Convert (i );};};func (_cdcg *Monochrome )GrayAt (x ,y int )_ed .Gray {_ebd ,_ :=ColorAtGray1BPC (x ,y ,_cdcg .BytesPerLine ,_cdcg .Data ,_cdcg .Decode );
return _ebd ;};func _aadb (_caad int ,_fcba int )error {return _c .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",_caad ,_fcba );
};func (_efbg *NRGBA16 )Set (x ,y int ,c _ed .Color ){_egde :=y *_efbg .BytesPerLine +x *3/2;if _egde +1>=len (_efbg .Data ){return ;};_dca :=NRGBA16Model .Convert (c ).(_ed .NRGBA );_efbg .setNRGBA (x ,y ,_egde ,_dca );};func _deca (_fbed _ed .Gray )_ed .NRGBA {return _ed .NRGBA {R :_fbed .Y ,G :_fbed .Y ,B :_fbed .Y ,A :0xff}};
func (_geg *Monochrome )Base ()*ImageBase {return &_geg .ImageBase };func (_eafg *Monochrome )setGrayBit (_bccg ,_ffbe int ){_eafg .Data [_bccg ]|=0x80>>uint (_ffbe &7)};var _ Image =&NRGBA32 {};func (_fdea *NRGBA32 )Validate ()error {if len (_fdea .Data )!=3*_fdea .Width *_fdea .Height {return _d .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func _eedbb (_cga _ed .NRGBA )_ed .NRGBA {_cga .R =_cga .R >>4|(_cga .R >>4)<<4;_cga .G =_cga .G >>4|(_cga .G >>4)<<4;_cga .B =_cga .B >>4|(_cga .B >>4)<<4;return _cga ;};func _ccc (_gbcd ,_cdfd Gray ,_eacd _b .Rectangle ){for _fad :=0;
_fad < _eacd .Max .X ;_fad ++{for _bfbg :=0;_bfbg < _eacd .Max .Y ;_bfbg ++{_cdfd .SetGray (_fad ,_bfbg ,_gbcd .GrayAt (_fad ,_bfbg ));};};};func _aafb (_cgcdg _b .Image ,_fbgc uint8 )*_b .Gray {_gaae :=_cgcdg .Bounds ();_gbgd :=_b .NewGray (_gaae );var (_ggdb _ed .Color ;
_cbde _ed .Gray ;);for _ggffa :=0;_ggffa < _gaae .Max .X ;_ggffa ++{for _abcef :=0;_abcef < _gaae .Max .Y ;_abcef ++{_ggdb =_cgcdg .At (_ggffa ,_abcef );_gbgd .Set (_ggffa ,_abcef ,_ggdb );_cbde =_gbgd .GrayAt (_ggffa ,_abcef );_gbgd .SetGray (_ggffa ,_abcef ,_ed .Gray {Y :_caba (_cbde .Y ,_fbgc )});
};};return _gbgd ;};func (_abbd *Monochrome )IsUnpadded ()bool {return (_abbd .Width *_abbd .Height )==len (_abbd .Data )};var _ Image =&Gray16 {};func (_ggcd *RGBA32 )At (x ,y int )_ed .Color {_cbfdb ,_ :=_ggcd .ColorAt (x ,y );return _cbfdb };func (_gadb *Gray16 )Histogram ()(_dbbb [256]int ){for _dda :=0;
_dda < _gadb .Width ;_dda ++{for _bfbe :=0;_bfbe < _gadb .Height ;_bfbe ++{_dbbb [_gadb .GrayAt (_dda ,_bfbe ).Y ]++;};};return _dbbb ;};func (_bccbe *RGBA32 )Validate ()error {if len (_bccbe .Data )!=3*_bccbe .Width *_bccbe .Height {return _d .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func (_gbbb *NRGBA16 )setNRGBA (_beff ,_gabf ,_baab int ,_fcfb _ed .NRGBA ){if _beff *3%2==0{_gbbb .Data [_baab ]=(_fcfb .R >>4)<<4|(_fcfb .G >>4);_gbbb .Data [_baab +1]=(_fcfb .B >>4)<<4|(_gbbb .Data [_baab +1]&0xf);}else {_gbbb .Data [_baab ]=(_gbbb .Data [_baab ]&0xf0)|(_fcfb .R >>4);
_gbbb .Data [_baab +1]=(_fcfb .G >>4)<<4|(_fcfb .B >>4);};if _gbbb .Alpha !=nil {_fbdd :=_gabf *BytesPerLine (_gbbb .Width ,4,1);if _fbdd < len (_gbbb .Alpha ){if _beff %2==0{_gbbb .Alpha [_fbdd ]=(_fcfb .A >>uint (4))<<uint (4)|(_gbbb .Alpha [_baab ]&0xf);
}else {_gbbb .Alpha [_fbdd ]=(_gbbb .Alpha [_fbdd ]&0xf0)|(_fcfb .A >>uint (4));};};};};func (_ddaf *Gray16 )SetGray (x ,y int ,g _ed .Gray ){_afg :=(y *_ddaf .BytesPerLine /2+x )*2;if _afg +1>=len (_ddaf .Data ){return ;};_ddaf .Data [_afg ]=g .Y ;_ddaf .Data [_afg +1]=g .Y ;
};func (_deddc *Gray4 )Set (x ,y int ,c _ed .Color ){if x >=_deddc .Width ||y >=_deddc .Height {return ;};_baa :=Gray4Model .Convert (c ).(_ed .Gray );_deddc .setGray (x ,y ,_baa );};func (_bbdc *Gray8 )SetGray (x ,y int ,g _ed .Gray ){_faae :=y *_bbdc .BytesPerLine +x ;
if _faae > len (_bbdc .Data )-1{return ;};_bbdc .Data [_faae ]=g .Y ;};func _afb (_decf Gray ,_gabb CMYK ,_cfbb _b .Rectangle ){for _befd :=0;_befd < _cfbb .Max .X ;_befd ++{for _ffe :=0;_ffe < _cfbb .Max .Y ;_ffe ++{_cef :=_decf .GrayAt (_befd ,_ffe );
_gabb .SetCMYK (_befd ,_ffe ,_egce (_cef ));};};};func _dab (_cec _ed .CMYK )_ed .RGBA {_fcd ,_bbab ,_dafb :=_ed .CMYKToRGB (_cec .C ,_cec .M ,_cec .Y ,_cec .K );return _ed .RGBA {R :_fcd ,G :_bbab ,B :_dafb ,A :0xff};};func GetConverter (bitsPerComponent ,colorComponents int )(ColorConverter ,error ){switch colorComponents {case 1:switch bitsPerComponent {case 1:return MonochromeConverter ,nil ;
case 2:return Gray2Converter ,nil ;case 4:return Gray4Converter ,nil ;case 8:return GrayConverter ,nil ;case 16:return Gray16Converter ,nil ;};case 3:switch bitsPerComponent {case 4:return NRGBA16Converter ,nil ;case 8:return NRGBAConverter ,nil ;case 16:return NRGBA64Converter ,nil ;
};case 4:return CMYKConverter ,nil ;};return nil ,_c .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0043o\u006e\u0076\u0065\u0072\u0074\u0065\u0072\u0020\u0070\u0061\u0072\u0061\u006d\u0065t\u0065\u0072\u0073\u002e\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003a\u0020\u0025\u0064\u002c\u0020\u0043\u006f\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006et\u0073\u003a \u0025\u0064",bitsPerComponent ,colorComponents );
};func _efb (_aabaf Gray ,_ddcc nrgba64 ,_cgdcg _b .Rectangle ){for _efg :=0;_efg < _cgdcg .Max .X ;_efg ++{for _gabg :=0;_gabg < _cgdcg .Max .Y ;_gabg ++{_fbec :=_dge (_ddcc .NRGBA64At (_efg ,_gabg ));_aabaf .SetGray (_efg ,_gabg ,_fbec );};};};func (_ggfge *NRGBA32 )setRGBA (_eegg int ,_dabg _ed .NRGBA ){_egffc :=3*_eegg ;
_ggfge .Data [_egffc ]=_dabg .R ;_ggfge .Data [_egffc +1]=_dabg .G ;_ggfge .Data [_egffc +2]=_dabg .B ;if _eegg < len (_ggfge .Alpha ){_ggfge .Alpha [_eegg ]=_dabg .A ;};};func (_abce *Gray4 )setGray (_gfeg int ,_bbg int ,_fdca _ed .Gray ){_gfdc :=_bbg *_abce .BytesPerLine ;
_bgge :=_gfdc +(_gfeg >>1);if _bgge >=len (_abce .Data ){return ;};_fbdb :=_fdca .Y >>4;_abce .Data [_bgge ]=(_abce .Data [_bgge ]&(^(0xf0>>uint (4*(_gfeg &1)))))|(_fbdb <<uint (4-4*(_gfeg &1)));};func _bcag (_bbgb *_b .Gray )bool {for _fgeg :=0;_fgeg < len (_bbgb .Pix );
_fgeg ++{if !_bgfc (_bbgb .Pix [_fgeg ]){return false ;};};return true ;};var _ _b .Image =&Gray8 {};func _cgec (_dba _ed .RGBA )_ed .Gray {_ffeg :=(19595*uint32 (_dba .R )+38470*uint32 (_dba .G )+7471*uint32 (_dba .B )+1<<7)>>16;return _ed .Gray {Y :uint8 (_ffeg )};
};func (_dece *RGBA32 )setRGBA (_bdebe int ,_aacbf _ed .RGBA ){_aacc :=3*_bdebe ;_dece .Data [_aacc ]=_aacbf .R ;_dece .Data [_aacc +1]=_aacbf .G ;_dece .Data [_aacc +2]=_aacbf .B ;if _bdebe < len (_dece .Alpha ){_dece .Alpha [_bdebe ]=_aacbf .A ;};};func AddDataPadding (width ,height ,bitsPerComponent ,colorComponents int ,data []byte )([]byte ,error ){_eaeb :=BytesPerLine (width ,bitsPerComponent ,colorComponents );
if _eaeb ==width *colorComponents *bitsPerComponent /8{return data ,nil ;};_edbg :=width *colorComponents *bitsPerComponent ;_edag :=_eaeb *8;_fbbge :=8-(_edag -_edbg );_cbfd :=_fd .NewReader (data );_dcdg :=_eaeb -1;_bfbd :=make ([]byte ,_dcdg );_cbda :=make ([]byte ,height *_eaeb );
_ccca :=_fd .NewWriterMSB (_cbda );var _dagb uint64 ;var _eeag error ;for _agac :=0;_agac < height ;_agac ++{_ ,_eeag =_cbfd .Read (_bfbd );if _eeag !=nil {return nil ,_eeag ;};_ ,_eeag =_ccca .Write (_bfbd );if _eeag !=nil {return nil ,_eeag ;};_dagb ,_eeag =_cbfd .ReadBits (byte (_fbbge ));
if _eeag !=nil {return nil ,_eeag ;};_ ,_eeag =_ccca .WriteBits (_dagb ,_fbbge );if _eeag !=nil {return nil ,_eeag ;};_ccca .FinishByte ();};return _cbda ,nil ;};func (_afddc *RGBA32 )Set (x ,y int ,c _ed .Color ){_cbed :=y *_afddc .Width +x ;_afcb :=3*_cbed ;
if _afcb +2>=len (_afddc .Data ){return ;};_gbcg :=_ed .RGBAModel .Convert (c ).(_ed .RGBA );_afddc .setRGBA (_cbed ,_gbcg );};func (_ede *NRGBA64 )At (x ,y int )_ed .Color {_aggee ,_ :=_ede .ColorAt (x ,y );return _aggee };func _bagef (_gbcb *Monochrome ,_caeg ,_dbcbb int ,_febe ,_fafc int ,_fdbfc RasterOperator ){var (_bffe bool ;
_egfa bool ;_gegd int ;_bagd int ;_ebbc int ;_bgabf int ;_cdaa bool ;_gbacg byte ;);_fbee :=8-(_caeg &7);_ddba :=_aadcc [_fbee ];_ecba :=_gbcb .BytesPerLine *_dbcbb +(_caeg >>3);if _febe < _fbee {_bffe =true ;_ddba &=_dgac [8-_fbee +_febe ];};if !_bffe {_gegd =(_febe -_fbee )>>3;
if _gegd !=0{_egfa =true ;_bagd =_ecba +1;};};_ebbc =(_caeg +_febe )&7;if !(_bffe ||_ebbc ==0){_cdaa =true ;_gbacg =_dgac [_ebbc ];_bgabf =_ecba +1+_gegd ;};var _gabbf ,_dedec int ;switch _fdbfc {case PixClr :for _gabbf =0;_gabbf < _fafc ;_gabbf ++{_gbcb .Data [_ecba ]=_gdfb (_gbcb .Data [_ecba ],0x0,_ddba );
_ecba +=_gbcb .BytesPerLine ;};if _egfa {for _gabbf =0;_gabbf < _fafc ;_gabbf ++{for _dedec =0;_dedec < _gegd ;_dedec ++{_gbcb .Data [_bagd +_dedec ]=0x0;};_bagd +=_gbcb .BytesPerLine ;};};if _cdaa {for _gabbf =0;_gabbf < _fafc ;_gabbf ++{_gbcb .Data [_bgabf ]=_gdfb (_gbcb .Data [_bgabf ],0x0,_gbacg );
_bgabf +=_gbcb .BytesPerLine ;};};case PixSet :for _gabbf =0;_gabbf < _fafc ;_gabbf ++{_gbcb .Data [_ecba ]=_gdfb (_gbcb .Data [_ecba ],0xff,_ddba );_ecba +=_gbcb .BytesPerLine ;};if _egfa {for _gabbf =0;_gabbf < _fafc ;_gabbf ++{for _dedec =0;_dedec < _gegd ;
_dedec ++{_gbcb .Data [_bagd +_dedec ]=0xff;};_bagd +=_gbcb .BytesPerLine ;};};if _cdaa {for _gabbf =0;_gabbf < _fafc ;_gabbf ++{_gbcb .Data [_bgabf ]=_gdfb (_gbcb .Data [_bgabf ],0xff,_gbacg );_bgabf +=_gbcb .BytesPerLine ;};};case PixNotDst :for _gabbf =0;
_gabbf < _fafc ;_gabbf ++{_gbcb .Data [_ecba ]=_gdfb (_gbcb .Data [_ecba ],^_gbcb .Data [_ecba ],_ddba );_ecba +=_gbcb .BytesPerLine ;};if _egfa {for _gabbf =0;_gabbf < _fafc ;_gabbf ++{for _dedec =0;_dedec < _gegd ;_dedec ++{_gbcb .Data [_bagd +_dedec ]=^(_gbcb .Data [_bagd +_dedec ]);
};_bagd +=_gbcb .BytesPerLine ;};};if _cdaa {for _gabbf =0;_gabbf < _fafc ;_gabbf ++{_gbcb .Data [_bgabf ]=_gdfb (_gbcb .Data [_bgabf ],^_gbcb .Data [_bgabf ],_gbacg );_bgabf +=_gbcb .BytesPerLine ;};};};};func _adb ()(_dgg [256]uint64 ){for _bbc :=0;_bbc < 256;
_bbc ++{if _bbc &0x01!=0{_dgg [_bbc ]|=0xff;};if _bbc &0x02!=0{_dgg [_bbc ]|=0xff00;};if _bbc &0x04!=0{_dgg [_bbc ]|=0xff0000;};if _bbc &0x08!=0{_dgg [_bbc ]|=0xff000000;};if _bbc &0x10!=0{_dgg [_bbc ]|=0xff00000000;};if _bbc &0x20!=0{_dgg [_bbc ]|=0xff0000000000;
};if _bbc &0x40!=0{_dgg [_bbc ]|=0xff000000000000;};if _bbc &0x80!=0{_dgg [_bbc ]|=0xff00000000000000;};};return _dgg ;};func _gdeed (_gcgf *_b .NYCbCrA ,_gedgg NRGBA ,_aebg _b .Rectangle ){for _fcee :=0;_fcee < _aebg .Max .X ;_fcee ++{for _fdedf :=0;_fdedf < _aebg .Max .Y ;
_fdedf ++{_efgb :=_gcgf .NYCbCrAAt (_fcee ,_fdedf );_gedgg .SetNRGBA (_fcee ,_fdedf ,_caec (_efgb ));};};};var _ NRGBA =&NRGBA16 {};func _gab (_bag *Monochrome ,_dgd ...int )(_ffcc *Monochrome ,_fc error ){if _bag ==nil {return nil ,_d .New ("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d");
};if len (_dgd )==0{return nil ,_d .New ("\u0074h\u0065\u0072e\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0061\u0074 \u006c\u0065\u0061\u0073\u0074\u0020o\u006e\u0065\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u006f\u0066 \u0072\u0065\u0064\u0075\u0063\u0074\u0069\u006f\u006e");
};_cf :=_acb ();_ffcc =_bag ;for _ ,_ggd :=range _dgd {if _ggd <=0{break ;};_ffcc ,_fc =_cdc (_ffcc ,_ggd ,_cf );if _fc !=nil {return nil ,_fc ;};};return _ffcc ,nil ;};func (_gcgc *RGBA32 )ColorModel ()_ed .Model {return _ed .NRGBAModel };type SMasker interface{HasAlpha ()bool ;
GetAlpha ()[]byte ;MakeAlpha ();};func _ffc ()(_gec [256]uint32 ){for _aed :=0;_aed < 256;_aed ++{if _aed &0x01!=0{_gec [_aed ]|=0xf;};if _aed &0x02!=0{_gec [_aed ]|=0xf0;};if _aed &0x04!=0{_gec [_aed ]|=0xf00;};if _aed &0x08!=0{_gec [_aed ]|=0xf000;};
if _aed &0x10!=0{_gec [_aed ]|=0xf0000;};if _aed &0x20!=0{_gec [_aed ]|=0xf00000;};if _aed &0x40!=0{_gec [_aed ]|=0xf000000;};if _aed &0x80!=0{_gec [_aed ]|=0xf0000000;};};return _gec ;};func (_aadf *Monochrome )ColorAt (x ,y int )(_ed .Color ,error ){return ColorAtGray1BPC (x ,y ,_aadf .BytesPerLine ,_aadf .Data ,_aadf .Decode );
};func (_ecgd *NRGBA64 )ColorModel ()_ed .Model {return _ed .NRGBA64Model };func (_fdeb *ImageBase )setEightPartlyBytes (_gafd ,_afgf int ,_fbb uint64 )(_bcfdd error ){var (_ddag byte ;_cegeb int ;);for _faaed :=1;_faaed <=_afgf ;_faaed ++{_cegeb =64-_faaed *8;
_ddag =byte (_fbb >>uint (_cegeb )&0xff);if _bcfdd =_fdeb .setByte (_gafd +_faaed -1,_ddag );_bcfdd !=nil {return _bcfdd ;};};_fefe :=_fdeb .BytesPerLine *8-_fdeb .Width ;if _fefe ==0{return nil ;};_cegeb -=8;_ddag =byte (_fbb >>uint (_cegeb )&0xff)<<uint (_fefe );
if _bcfdd =_fdeb .setByte (_gafd +_afgf ,_ddag );_bcfdd !=nil {return _bcfdd ;};return nil ;};var _ Gray =&Gray16 {};func _gdfb (_decfa ,_aeccb ,_cbge byte )byte {return (_decfa &^(_cbge ))|(_aeccb &_cbge )};var ErrInvalidImage =_d .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
func (_bcbb *NRGBA32 )SetNRGBA (x ,y int ,c _ed .NRGBA ){_ebcge :=y *_bcbb .Width +x ;_deee :=3*_ebcge ;if _deee +2>=len (_bcbb .Data ){return ;};_bcbb .setRGBA (_ebcge ,c );};func (_aacb *Monochrome )setIndexedBit (_faab int ){_aacb .Data [(_faab >>3)]|=0x80>>uint (_faab &7)};
var _ _b .Image =&NRGBA32 {};func _gdg (_cdcc RGBA ,_cega CMYK ,_dfc _b .Rectangle ){for _aec :=0;_aec < _dfc .Max .X ;_aec ++{for _eae :=0;_eae < _dfc .Max .Y ;_eae ++{_dadca :=_cdcc .RGBAAt (_aec ,_eae );_cega .SetCMYK (_aec ,_eae ,_dgcd (_dadca ));};
};};func _fae (_cfd _ed .Gray )_ed .Gray {_cfd .Y >>=4;_cfd .Y |=_cfd .Y <<4;return _cfd };func (_eeff *Monochrome )getBitAt (_ccaf ,_ddcb int )bool {_fbd :=_ddcb *_eeff .BytesPerLine +(_ccaf >>3);_fcfg :=_ccaf &0x07;_fegc :=uint (7-_fcfg );if _fbd > len (_eeff .Data )-1{return false ;
};if (_eeff .Data [_fbd ]>>_fegc )&0x01>=1{return true ;};return false ;};func _ccag (_efa _ed .NRGBA )_ed .CMYK {_fff ,_cceg ,_aagd ,_ :=_efa .RGBA ();_gbc ,_aaba ,_cdd ,_dfa :=_ed .RGBToCMYK (uint8 (_fff >>8),uint8 (_cceg >>8),uint8 (_aagd >>8));return _ed .CMYK {C :_gbc ,M :_aaba ,Y :_cdd ,K :_dfa };
};func (_aag *CMYK32 )ColorAt (x ,y int )(_ed .Color ,error ){return ColorAtCMYK (x ,y ,_aag .Width ,_aag .Data ,_aag .Decode );};var (_faf =_gge ();_eag =_ffc ();_bfa =_adb (););func (_bdgc *NRGBA32 )Copy ()Image {return &NRGBA32 {ImageBase :_bdgc .copy ()}};
func (_edbf *RGBA32 )Bounds ()_b .Rectangle {return _b .Rectangle {Max :_b .Point {X :_edbf .Width ,Y :_edbf .Height }};};func (_ccad *NRGBA16 )Bounds ()_b .Rectangle {return _b .Rectangle {Max :_b .Point {X :_ccad .Width ,Y :_ccad .Height }};};func _adec (_aebe *Monochrome ,_bdbc ,_fgef ,_bbbae ,_bggg int ,_edbc RasterOperator ,_defa *Monochrome ,_eggc ,_fbef int )error {if _aebe ==nil {return _d .New ("\u006e\u0069\u006c\u0020\u0027\u0064\u0065\u0073\u0074\u0027\u0020\u0042i\u0074\u006d\u0061\u0070");
};if _edbc ==PixDst {return nil ;};switch _edbc {case PixClr ,PixSet ,PixNotDst :_aadc (_aebe ,_bdbc ,_fgef ,_bbbae ,_bggg ,_edbc );return nil ;};if _defa ==nil {_gg .Log .Debug ("\u0052a\u0073\u0074e\u0072\u004f\u0070\u0065r\u0061\u0074\u0069o\u006e\u0020\u0073\u006f\u0075\u0072\u0063\u0065\u0020bi\u0074\u006d\u0061p\u0020\u0069s\u0020\u006e\u006f\u0074\u0020\u0064e\u0066\u0069n\u0065\u0064");
return _d .New ("\u006e\u0069l\u0020\u0027\u0073r\u0063\u0027\u0020\u0062\u0069\u0074\u006d\u0061\u0070");};if _dggae :=_gce (_aebe ,_bdbc ,_fgef ,_bbbae ,_bggg ,_edbc ,_defa ,_eggc ,_fbef );_dggae !=nil {return _dggae ;};return nil ;};func (_fcfa *NRGBA32 )NRGBAAt (x ,y int )_ed .NRGBA {_bdbe ,_ :=ColorAtNRGBA32 (x ,y ,_fcfa .Width ,_fcfa .Data ,_fcfa .Alpha ,_fcfa .Decode );
return _bdbe ;};func (_dfbg *Monochrome )setGray (_fdef int ,_ecdf _ed .Gray ,_fedd int ){if _ecdf .Y ==0{_dfbg .clearBit (_fedd ,_fdef );}else {_dfbg .setGrayBit (_fedd ,_fdef );};};var _ Gray =&Gray4 {};func (_dggga *ImageBase )Pix ()[]byte {return _dggga .Data };
func (_gad *Monochrome )Bounds ()_b .Rectangle {return _b .Rectangle {Max :_b .Point {X :_gad .Width ,Y :_gad .Height }};};var _ Image =&Gray4 {};type CMYK interface{CMYKAt (_bdcg ,_bcfb int )_ed .CMYK ;SetCMYK (_ecgc ,_geca int ,_dadc _ed .CMYK );};func _adag (_cgcd _ed .Gray ,_ecd monochromeModel )_ed .Gray {if _cgcd .Y > uint8 (_ecd ){return _ed .Gray {Y :_g .MaxUint8 };
};return _ed .Gray {};};var _ Image =&RGBA32 {};func (_faac *NRGBA64 )SetNRGBA64 (x ,y int ,c _ed .NRGBA64 ){_dgad :=(y *_faac .Width +x )*2;_fcgb :=_dgad *3;if _fcgb +5>=len (_faac .Data ){return ;};_faac .setNRGBA64 (_fcgb ,c ,_dgad );};func _ecb (_cda _b .Image )(Image ,error ){if _gga ,_cdfe :=_cda .(*CMYK32 );
_cdfe {return _gga .Copy (),nil ;};_fbc :=_cda .Bounds ();_cgg ,_bbdf :=NewImage (_fbc .Max .X ,_fbc .Max .Y ,8,4,nil ,nil ,nil );if _bbdf !=nil {return nil ,_bbdf ;};switch _bga :=_cda .(type ){case CMYK :_abbb (_bga ,_cgg .(CMYK ),_fbc );case Gray :_afb (_bga ,_cgg .(CMYK ),_fbc );
case NRGBA :_eba (_bga ,_cgg .(CMYK ),_fbc );case RGBA :_gdg (_bga ,_cgg .(CMYK ),_fbc );default:_deb (_cda ,_cgg ,_fbc );};return _cgg ,nil ;};func _fafg (_fdfc RGBA ,_cegeg NRGBA ,_edgd _b .Rectangle ){for _eefff :=0;_eefff < _edgd .Max .X ;_eefff ++{for _gdac :=0;
_gdac < _edgd .Max .Y ;_gdac ++{_ffcea :=_fdfc .RGBAAt (_eefff ,_gdac );_cegeg .SetNRGBA (_eefff ,_gdac ,_adg (_ffcea ));};};};var _ Image =&NRGBA64 {};func (_fgf *CMYK32 )Base ()*ImageBase {return &_fgf .ImageBase };func _fbf (_ccg ,_fdb *Monochrome )(_ab error ){_gc :=_fdb .BytesPerLine ;
_fe :=_ccg .BytesPerLine ;var _eg ,_cbg ,_be ,_gdb ,_bd int ;for _be =0;_be < _fdb .Height ;_be ++{_eg =_be *_gc ;_cbg =8*_be *_fe ;for _gdb =0;_gdb < _gc ;_gdb ++{if _ab =_ccg .setEightBytes (_cbg +_gdb *8,_bfa [_fdb .Data [_eg +_gdb ]]);_ab !=nil {return _ab ;
};};for _bd =1;_bd < 8;_bd ++{for _gdb =0;_gdb < _fe ;_gdb ++{if _ab =_ccg .setByte (_cbg +_bd *_fe +_gdb ,_ccg .Data [_cbg +_gdb ]);_ab !=nil {return _ab ;};};};};return nil ;};func _gfegg (_daae _b .Image )(Image ,error ){if _dgb ,_aada :=_daae .(*Gray4 );
_aada {return _dgb .Copy (),nil ;};_efbb :=_daae .Bounds ();_gbab ,_bdba :=NewImage (_efbb .Max .X ,_efbb .Max .Y ,4,1,nil ,nil ,nil );if _bdba !=nil {return nil ,_bdba ;};_gdcf (_daae ,_gbab ,_efbb );return _gbab ,nil ;};var _ _b .Image =&Gray2 {};func _gfee (_ecf []byte ,_bgea Image )error {_fada :=true ;
for _gefa :=0;_gefa < len (_ecf );_gefa ++{if _ecf [_gefa ]!=0xff{_fada =false ;break ;};};if _fada {switch _eccc :=_bgea .(type ){case *NRGBA32 :_eccc .Alpha =nil ;case *NRGBA64 :_eccc .Alpha =nil ;default:return _c .Errorf ("i\u006ete\u0072n\u0061l\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020i\u006d\u0061\u0067\u0065\u0020s\u0068\u006f\u0075l\u0064\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0074\u0079\u0070e\u0020\u002a\u004eRGB\u0041\u0033\u0032\u0020\u006f\u0072 \u002a\u004e\u0052\u0047\u0042\u0041\u0036\u0034\u0020\u0062\u0075\u0074 \u0069s\u003a\u0020\u0025\u0054",_bgea );
};};return nil ;};type NRGBA interface{NRGBAAt (_fcea ,_eadef int )_ed .NRGBA ;SetNRGBA (_afgff ,_agge int ,_ffgc _ed .NRGBA );};var _ _b .Image =&RGBA32 {};func (_gabe *NRGBA64 )setNRGBA64 (_abbdg int ,_afgd _ed .NRGBA64 ,_egdd int ){_gabe .Data [_abbdg ]=uint8 (_afgd .R >>8);
_gabe .Data [_abbdg +1]=uint8 (_afgd .R &0xff);_gabe .Data [_abbdg +2]=uint8 (_afgd .G >>8);_gabe .Data [_abbdg +3]=uint8 (_afgd .G &0xff);_gabe .Data [_abbdg +4]=uint8 (_afgd .B >>8);_gabe .Data [_abbdg +5]=uint8 (_afgd .B &0xff);if _egdd +1< len (_gabe .Alpha ){_gabe .Alpha [_egdd ]=uint8 (_afgd .A >>8);
_gabe .Alpha [_egdd +1]=uint8 (_afgd .A &0xff);};};func (_afd *CMYK32 )CMYKAt (x ,y int )_ed .CMYK {_beb ,_ :=ColorAtCMYK (x ,y ,_afd .Width ,_afd .Data ,_afd .Decode );return _beb ;};func GrayHistogram (g Gray )(_eafff [256]int ){switch _ccgc :=g .(type ){case Histogramer :return _ccgc .Histogram ();
case _b .Image :_ecaf :=_ccgc .Bounds ();for _ccaga :=0;_ccaga < _ecaf .Max .X ;_ccaga ++{for _gece :=0;_gece < _ecaf .Max .Y ;_gece ++{_eafff [g .GrayAt (_ccaga ,_gece ).Y ]++;};};return _eafff ;default:return [256]int {};};};func _dge (_cegcc _ed .NRGBA64 )_ed .Gray {var _beca _ed .NRGBA64 ;
if _cegcc ==_beca {return _ed .Gray {Y :0xff};};_eeaeg ,_gbf ,_cad ,_ :=_cegcc .RGBA ();_acfc :=(19595*_eeaeg +38470*_gbf +7471*_cad +1<<15)>>24;return _ed .Gray {Y :uint8 (_acfc )};};var (_dgac =[]byte {0x00,0x80,0xC0,0xE0,0xF0,0xF8,0xFC,0xFE,0xFF};_aadcc =[]byte {0x00,0x01,0x03,0x07,0x0F,0x1F,0x3F,0x7F,0xFF};
);func (_badd *Gray16 )Base ()*ImageBase {return &_badd .ImageBase };type Monochrome struct{ImageBase ;ModelThreshold uint8 ;};func (_gbg *Monochrome )ColorModel ()_ed .Model {return MonochromeModel (_gbg .ModelThreshold )};func _fef (_fag _ed .NRGBA64 )_ed .NRGBA {return _ed .NRGBA {R :uint8 (_fag .R >>8),G :uint8 (_fag .G >>8),B :uint8 (_fag .B >>8),A :uint8 (_fag .A >>8)};
};type colorConverter struct{_gac func (_baeb _b .Image )(Image ,error );};var _ RGBA =&RGBA32 {};func (_aggg *Gray8 )Base ()*ImageBase {return &_aggg .ImageBase };func (_gdec *Monochrome )Scale (scale float64 )(*Monochrome ,error ){var _dfea bool ;_dag :=scale ;
if scale < 1{_dag =1/scale ;_dfea =true ;};_dgf :=NextPowerOf2 (uint (_dag ));if InDelta (float64 (_dgf ),_dag ,0.001){if _dfea {return _gdec .ReduceBinary (_dag );};return _gdec .ExpandBinary (int (_dgf ));};_adcb :=int (_g .RoundToEven (float64 (_gdec .Width )*scale ));
_bgab :=int (_g .RoundToEven (float64 (_gdec .Height )*scale ));return _gdec .ScaleLow (_adcb ,_bgab );};func _ada (_gdfd _ed .NRGBA64 )_ed .RGBA {_eed ,_cgee ,_bbe ,_debd :=_gdfd .RGBA ();return _ed .RGBA {R :uint8 (_eed >>8),G :uint8 (_cgee >>8),B :uint8 (_bbe >>8),A :uint8 (_debd >>8)};
};func (_cea *Gray2 )ColorModel ()_ed .Model {return Gray2Model };type CMYK32 struct{ImageBase };func (_dbfe *NRGBA64 )Base ()*ImageBase {return &_dbfe .ImageBase };func (_edbca *NRGBA64 )NRGBA64At (x ,y int )_ed .NRGBA64 {_fac ,_ :=ColorAtNRGBA64 (x ,y ,_edbca .Width ,_edbca .Data ,_edbca .Alpha ,_edbca .Decode );
return _fac ;};func _dbge (_bdcc _b .Image )(Image ,error ){if _caed ,_baff :=_bdcc .(*NRGBA32 );_baff {return _caed .Copy (),nil ;};_ggdg ,_gdfe ,_bgf :=_cebd (_bdcc ,1);_cgaa ,_fbefd :=NewImage (_ggdg .Max .X ,_ggdg .Max .Y ,8,3,nil ,_bgf ,nil );if _fbefd !=nil {return nil ,_fbefd ;
};_gdee (_bdcc ,_cgaa ,_ggdg );if len (_bgf )!=0&&!_gdfe {if _dgfb :=_gfee (_bgf ,_cgaa );_dgfb !=nil {return nil ,_dgfb ;};};return _cgaa ,nil ;};type Gray8 struct{ImageBase };func _bgfc (_adgag uint8 )bool {if _adgag ==0||_adgag ==255{return true ;};
return false ;};func (_eade *CMYK32 )SetCMYK (x ,y int ,c _ed .CMYK ){_bae :=4*(y *_eade .Width +x );if _bae +3>=len (_eade .Data ){return ;};_eade .Data [_bae ]=c .C ;_eade .Data [_bae +1]=c .M ;_eade .Data [_bae +2]=c .Y ;_eade .Data [_bae +3]=c .K ;
};func _ageb (_geeb _ed .Gray )_ed .Gray {_beba :=_geeb .Y >>6;_beba |=_beba <<2;_geeb .Y =_beba |_beba <<4;return _geeb ;};func _fbcd (_becd _b .Image ,_decad Image ,_dggb _b .Rectangle ){if _bfag ,_edcg :=_becd .(SMasker );_edcg &&_bfag .HasAlpha (){_decad .(SMasker ).MakeAlpha ();
};switch _gagc :=_becd .(type ){case Gray :_fbdc (_gagc ,_decad .(RGBA ),_dggb );case NRGBA :_deafg (_gagc ,_decad .(RGBA ),_dggb );case *_b .NYCbCrA :_gfed (_gagc ,_decad .(RGBA ),_dggb );case CMYK :_fga (_gagc ,_decad .(RGBA ),_dggb );case RGBA :_bdbcb (_gagc ,_decad .(RGBA ),_dggb );
case nrgba64 :_cefb (_gagc ,_decad .(RGBA ),_dggb );default:_deb (_becd ,_decad ,_dggb );};};func ColorAtGray8BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_ed .Gray ,error ){_eaga :=y *bytesPerLine +x ;if _eaga >=len (data ){return _ed .Gray {},_c .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_eddc :=data [_eaga ];if len (decode )==2{_eddc =uint8 (uint32 (LinearInterpolate (float64 (_eddc ),0,255,decode [0],decode [1]))&0xff);};return _ed .Gray {Y :_eddc },nil ;};var (MonochromeConverter =ConverterFunc (_ddg );Gray2Converter =ConverterFunc (_fcfga );
Gray4Converter =ConverterFunc (_gfegg );GrayConverter =ConverterFunc (_cabd );Gray16Converter =ConverterFunc (_cgeeb );NRGBA16Converter =ConverterFunc (_defb );NRGBAConverter =ConverterFunc (_dbge );NRGBA64Converter =ConverterFunc (_fdcg );RGBAConverter =ConverterFunc (_abdc );
CMYKConverter =ConverterFunc (_ecb ););func NewImageBase (width int ,height int ,bitsPerComponent int ,colorComponents int ,data []byte ,alpha []byte ,decode []float64 )ImageBase {_aaga :=ImageBase {Width :width ,Height :height ,BitsPerComponent :bitsPerComponent ,ColorComponents :colorComponents ,Data :data ,Alpha :alpha ,Decode :decode ,BytesPerLine :BytesPerLine (width ,bitsPerComponent ,colorComponents )};
if data ==nil {_aaga .Data =make ([]byte ,height *_aaga .BytesPerLine );};return _aaga ;};type RGBA interface{RGBAAt (_bfga ,_agfe int )_ed .RGBA ;SetRGBA (_efgc ,_fbge int ,_afdb _ed .RGBA );};func (_dfe *CMYK32 )Set (x ,y int ,c _ed .Color ){_cdeb :=4*(y *_dfe .Width +x );
if _cdeb +3>=len (_dfe .Data ){return ;};_abgd :=_ed .CMYKModel .Convert (c ).(_ed .CMYK );_dfe .Data [_cdeb ]=_abgd .C ;_dfe .Data [_cdeb +1]=_abgd .M ;_dfe .Data [_cdeb +2]=_abgd .Y ;_dfe .Data [_cdeb +3]=_abgd .K ;};type Gray16 struct{ImageBase };func (_abae *Gray16 )ColorModel ()_ed .Model {return _ed .Gray16Model };
func _abgc (_fee ,_egad *Monochrome ,_eac []byte ,_bdf int )(_ccbe error ){var (_gfea ,_bbd ,_gaf ,_cgdd ,_dcc ,_aaad ,_egc ,_ffd int ;_eb ,_eab ,_bbba ,_bcae uint32 ;_bab ,_bgd byte ;_cgc uint16 ;);_fbe :=make ([]byte ,4);_aef :=make ([]byte ,4);for _gaf =0;
_gaf < _fee .Height -1;_gaf ,_cgdd =_gaf +2,_cgdd +1{_gfea =_gaf *_fee .BytesPerLine ;_bbd =_cgdd *_egad .BytesPerLine ;for _dcc ,_aaad =0,0;_dcc < _bdf ;_dcc ,_aaad =_dcc +4,_aaad +1{for _egc =0;_egc < 4;_egc ++{_ffd =_gfea +_dcc +_egc ;if _ffd <=len (_fee .Data )-1&&_ffd < _gfea +_fee .BytesPerLine {_fbe [_egc ]=_fee .Data [_ffd ];
}else {_fbe [_egc ]=0x00;};_ffd =_gfea +_fee .BytesPerLine +_dcc +_egc ;if _ffd <=len (_fee .Data )-1&&_ffd < _gfea +(2*_fee .BytesPerLine ){_aef [_egc ]=_fee .Data [_ffd ];}else {_aef [_egc ]=0x00;};};_eb =_gd .BigEndian .Uint32 (_fbe );_eab =_gd .BigEndian .Uint32 (_aef );
_bbba =_eb &_eab ;_bbba |=_bbba <<1;_bcae =_eb |_eab ;_bcae &=_bcae <<1;_eab =_bbba &_bcae ;_eab &=0xaaaaaaaa;_eb =_eab |(_eab <<7);_bab =byte (_eb >>24);_bgd =byte ((_eb >>8)&0xff);_ffd =_bbd +_aaad ;if _ffd +1==len (_egad .Data )-1||_ffd +1>=_bbd +_egad .BytesPerLine {if _ccbe =_egad .setByte (_ffd ,_eac [_bab ]);
_ccbe !=nil {return _c .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_ffd );};}else {_cgc =(uint16 (_eac [_bab ])<<8)|uint16 (_eac [_bgd ]);if _ccbe =_egad .setTwoBytes (_ffd ,_cgc );_ccbe !=nil {return _c .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_ffd );
};_aaad ++;};};};return nil ;};func IsPowerOf2 (n uint )bool {return n > 0&&(n &(n -1))==0};type Histogramer interface{Histogram ()[256]int ;};func NextPowerOf2 (n uint )uint {if IsPowerOf2 (n ){return n ;};return 1<<(_fccab (n )+1);};var _ Image =&Monochrome {};
func _bfeb (_dged _ed .NYCbCrA )_ed .RGBA {_ddf ,_baee ,_ece ,_agg :=_caec (_dged ).RGBA ();return _ed .RGBA {R :uint8 (_ddf >>8),G :uint8 (_baee >>8),B :uint8 (_ece >>8),A :uint8 (_agg >>8)};};func (_agcd *Gray4 )Bounds ()_b .Rectangle {return _b .Rectangle {Max :_b .Point {X :_agcd .Width ,Y :_agcd .Height }};
};func ColorAtNRGBA64 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_ed .NRGBA64 ,error ){_eggcf :=(y *width +x )*2;_cfg :=_eggcf *3;if _cfg +5>=len (data ){return _ed .NRGBA64 {},_c .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};const _egac =0xffff;_eagae :=uint16 (_egac );if alpha !=nil &&len (alpha )> _eggcf +1{_eagae =uint16 (alpha [_eggcf ])<<8|uint16 (alpha [_eggcf +1]);};_ecdg :=uint16 (data [_cfg ])<<8|uint16 (data [_cfg +1]);_gdgdd :=uint16 (data [_cfg +2])<<8|uint16 (data [_cfg +3]);
_bagb :=uint16 (data [_cfg +4])<<8|uint16 (data [_cfg +5]);if len (decode )==6{_ecdg =uint16 (uint64 (LinearInterpolate (float64 (_ecdg ),0,65535,decode [0],decode [1]))&_egac );_gdgdd =uint16 (uint64 (LinearInterpolate (float64 (_gdgdd ),0,65535,decode [2],decode [3]))&_egac );
_bagb =uint16 (uint64 (LinearInterpolate (float64 (_bagb ),0,65535,decode [4],decode [5]))&_egac );};return _ed .NRGBA64 {R :_ecdg ,G :_gdgdd ,B :_bagb ,A :_eagae },nil ;};func (_abd colorConverter )Convert (src _b .Image )(Image ,error ){return _abd ._gac (src )};
func (_agbd *Gray16 )ColorAt (x ,y int )(_ed .Color ,error ){return ColorAtGray16BPC (x ,y ,_agbd .BytesPerLine ,_agbd .Data ,_agbd .Decode );};func (_fccf *NRGBA64 )Copy ()Image {return &NRGBA64 {ImageBase :_fccf .copy ()}};func ColorAtNRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_ed .NRGBA ,error ){_fdbg :=y *width +x ;
_befg :=3*_fdbg ;if _befg +2>=len (data ){return _ed .NRGBA {},_c .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_dbdc :=uint8 (0xff);if alpha !=nil &&len (alpha )> _fdbg {_dbdc =alpha [_fdbg ];};_caga ,_fdbab ,_fbbd :=data [_befg ],data [_befg +1],data [_befg +2];if len (decode )==6{_caga =uint8 (uint32 (LinearInterpolate (float64 (_caga ),0,255,decode [0],decode [1]))&0xff);
_fdbab =uint8 (uint32 (LinearInterpolate (float64 (_fdbab ),0,255,decode [2],decode [3]))&0xff);_fbbd =uint8 (uint32 (LinearInterpolate (float64 (_fbbd ),0,255,decode [4],decode [5]))&0xff);};return _ed .NRGBA {R :_caga ,G :_fdbab ,B :_fbbd ,A :_dbdc },nil ;
};func (_begc *RGBA32 )Copy ()Image {return &RGBA32 {ImageBase :_begc .copy ()}};func _fggg (_agebb CMYK ,_dcaa NRGBA ,_dbda _b .Rectangle ){for _eabfd :=0;_eabfd < _dbda .Max .X ;_eabfd ++{for _bded :=0;_bded < _dbda .Max .Y ;_bded ++{_eacc :=_agebb .CMYKAt (_eabfd ,_bded );
_dcaa .SetNRGBA (_eabfd ,_bded ,_geaef (_eacc ));};};};func _efba (_adaa ,_bfaee NRGBA ,_geed _b .Rectangle ){for _gbag :=0;_gbag < _geed .Max .X ;_gbag ++{for _abeb :=0;_abeb < _geed .Max .Y ;_abeb ++{_bfaee .SetNRGBA (_gbag ,_abeb ,_adaa .NRGBAAt (_gbag ,_abeb ));
};};};func (_gada *Gray2 )Validate ()error {if len (_gada .Data )!=_gada .Height *_gada .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_abdf *Gray4 )SetGray (x ,y int ,g _ed .Gray ){if x >=_abdf .Width ||y >=_abdf .Height {return ;};g =_fae (g );
_abdf .setGray (x ,y ,g );};func (_cdaee *RGBA32 )Base ()*ImageBase {return &_cdaee .ImageBase };func (_adgg *Monochrome )Validate ()error {if len (_adgg .Data )!=_adgg .Height *_adgg .BytesPerLine {return ErrInvalidImage ;};return nil ;};func IsGrayImgBlackAndWhite (i *_b .Gray )bool {return _bcag (i )};
func _cdc (_cegc *Monochrome ,_ace int ,_faad []byte )(_gaeb *Monochrome ,_aaac error ){const _edd ="\u0072\u0065d\u0075\u0063\u0065R\u0061\u006e\u006b\u0042\u0069\u006e\u0061\u0072\u0079";if _cegc ==nil {return nil ,_d .New ("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d");
};if _ace < 1||_ace > 4{return nil ,_d .New ("\u006c\u0065\u0076\u0065\u006c\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020\u0073e\u0074\u0020\u007b\u0031\u002c\u0032\u002c\u0033\u002c\u0034\u007d");};if _cegc .Height <=1{return nil ,_d .New ("\u0073\u006f\u0075rc\u0065\u0020\u0068\u0065\u0069\u0067\u0068\u0074\u0020m\u0075s\u0074 \u0062e\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020\u0027\u0032\u0027");
};_gaeb =_bdc (_cegc .Width /2,_cegc .Height /2);if _faad ==nil {_faad =_acb ();};_ade :=_fcec (_cegc .BytesPerLine ,2*_gaeb .BytesPerLine );switch _ace {case 1:_aaac =_cde (_cegc ,_gaeb ,_faad ,_ade );case 2:_aaac =_dcbc (_cegc ,_gaeb ,_faad ,_ade );case 3:_aaac =_abgc (_cegc ,_gaeb ,_faad ,_ade );
case 4:_aaac =_gba (_cegc ,_gaeb ,_faad ,_ade );};if _aaac !=nil {return nil ,_aaac ;};return _gaeb ,nil ;};func _bdbcb (_dabgc ,_afeb RGBA ,_cabda _b .Rectangle ){for _agef :=0;_agef < _cabda .Max .X ;_agef ++{for _bfba :=0;_bfba < _cabda .Max .Y ;_bfba ++{_afeb .SetRGBA (_agef ,_bfba ,_dabgc .RGBAAt (_agef ,_bfba ));
};};};func _bdc (_fca ,_cbe int )*Monochrome {return &Monochrome {ImageBase :NewImageBase (_fca ,_cbe ,1,1,nil ,nil ,nil ),ModelThreshold :0x0f};};func (_febc *ImageBase )setFourBytes (_gfbb int ,_ffeb uint32 )error {if _gfbb +3> len (_febc .Data )-1{return _c .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006fu\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065",_gfbb );
};_febc .Data [_gfbb ]=byte ((_ffeb &0xff000000)>>24);_febc .Data [_gfbb +1]=byte ((_ffeb &0xff0000)>>16);_febc .Data [_gfbb +2]=byte ((_ffeb &0xff00)>>8);_febc .Data [_gfbb +3]=byte (_ffeb &0xff);return nil ;};func (_fccc *NRGBA32 )ColorModel ()_ed .Model {return _ed .NRGBAModel };
func AutoThresholdTriangle (histogram [256]int )uint8 {var _adga ,_ggbg ,_bebea ,_ddge int ;for _egcbe :=0;_egcbe < len (histogram );_egcbe ++{if histogram [_egcbe ]> 0{_adga =_egcbe ;break ;};};if _adga > 0{_adga --;};for _efecc :=255;_efecc > 0;_efecc --{if histogram [_efecc ]> 0{_ddge =_efecc ;
break ;};};if _ddge < 255{_ddge ++;};for _ffge :=0;_ffge < 256;_ffge ++{if histogram [_ffge ]> _ggbg {_bebea =_ffge ;_ggbg =histogram [_ffge ];};};var _bdgca bool ;if (_bebea -_adga )< (_ddge -_bebea ){_bdgca =true ;var _dcbf int ;_aggc :=255;for _dcbf < _aggc {_ggcg :=histogram [_dcbf ];
histogram [_dcbf ]=histogram [_aggc ];histogram [_aggc ]=_ggcg ;_dcbf ++;_aggc --;};_adga =255-_ddge ;_bebea =255-_bebea ;};if _adga ==_bebea {return uint8 (_adga );};_fbba :=float64 (histogram [_bebea ]);_eaagf :=float64 (_adga -_bebea );_gefc :=_g .Sqrt (_fbba *_fbba +_eaagf *_eaagf );
_fbba /=_gefc ;_eaagf /=_gefc ;_gefc =_fbba *float64 (_adga )+_eaagf *float64 (histogram [_adga ]);_gaca :=_adga ;var _bebag float64 ;for _bbda :=_adga +1;_bbda <=_bebea ;_bbda ++{_abcb :=_fbba *float64 (_bbda )+_eaagf *float64 (histogram [_bbda ])-_gefc ;
if _abcb > _bebag {_gaca =_bbda ;_bebag =_abcb ;};};_gaca --;if _bdgca {var _edbd int ;_cbgf :=255;for _edbd < _cbgf {_adcbf :=histogram [_edbd ];histogram [_edbd ]=histogram [_cbgf ];histogram [_cbgf ]=_adcbf ;_edbd ++;_cbgf --;};return uint8 (255-_gaca );
};return uint8 (_gaca );};func ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor int ,data ,alpha []byte ,decode []float64 )(_ed .Color ,error ){switch bitsPerColor {case 4:return ColorAtNRGBA16 (x ,y ,width ,bytesPerLine ,data ,alpha ,decode );case 8:return ColorAtNRGBA32 (x ,y ,width ,data ,alpha ,decode );
case 16:return ColorAtNRGBA64 (x ,y ,width ,data ,alpha ,decode );default:return nil ,_c .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0067\u0062\u0020b\u0069\u0074\u0073\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0061\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );
};};func _gdee (_eacb _b .Image ,_fgdg Image ,_ddda _b .Rectangle ){if _bdd ,_acd :=_eacb .(SMasker );_acd &&_bdd .HasAlpha (){_fgdg .(SMasker ).MakeAlpha ();};switch _gfgc :=_eacb .(type ){case Gray :_afga (_gfgc ,_fgdg .(NRGBA ),_ddda );case NRGBA :_efba (_gfgc ,_fgdg .(NRGBA ),_ddda );
case *_b .NYCbCrA :_gdeed (_gfgc ,_fgdg .(NRGBA ),_ddda );case CMYK :_fggg (_gfgc ,_fgdg .(NRGBA ),_ddda );case RGBA :_fafg (_gfgc ,_fgdg .(NRGBA ),_ddda );case nrgba64 :_afea (_gfgc ,_fgdg .(NRGBA ),_ddda );default:_deb (_eacb ,_fgdg ,_ddda );};};func (_feeb *ImageBase )newAlpha (){_gabbg :=BytesPerLine (_feeb .Width ,_feeb .BitsPerComponent ,1);
_feeb .Alpha =make ([]byte ,_feeb .Height *_gabbg );};func _gcdg (_efee *Monochrome ,_aege ,_eada int ,_gafb ,_fdbb int ,_fced RasterOperator ){var (_fffc int ;_dfce byte ;_efcba ,_bdge int ;_dgbc int ;);_fcag :=_gafb >>3;_gcfe :=_gafb &7;if _gcfe > 0{_dfce =_dgac [_gcfe ];
};_fffc =_efee .BytesPerLine *_eada +(_aege >>3);switch _fced {case PixClr :for _efcba =0;_efcba < _fdbb ;_efcba ++{_dgbc =_fffc +_efcba *_efee .BytesPerLine ;for _bdge =0;_bdge < _fcag ;_bdge ++{_efee .Data [_dgbc ]=0x0;_dgbc ++;};if _gcfe > 0{_efee .Data [_dgbc ]=_gdfb (_efee .Data [_dgbc ],0x0,_dfce );
};};case PixSet :for _efcba =0;_efcba < _fdbb ;_efcba ++{_dgbc =_fffc +_efcba *_efee .BytesPerLine ;for _bdge =0;_bdge < _fcag ;_bdge ++{_efee .Data [_dgbc ]=0xff;_dgbc ++;};if _gcfe > 0{_efee .Data [_dgbc ]=_gdfb (_efee .Data [_dgbc ],0xff,_dfce );};};
case PixNotDst :for _efcba =0;_efcba < _fdbb ;_efcba ++{_dgbc =_fffc +_efcba *_efee .BytesPerLine ;for _bdge =0;_bdge < _fcag ;_bdge ++{_efee .Data [_dgbc ]=^_efee .Data [_dgbc ];_dgbc ++;};if _gcfe > 0{_efee .Data [_dgbc ]=_gdfb (_efee .Data [_dgbc ],^_efee .Data [_dgbc ],_dfce );
};};};};func ConverterFunc (converterFunc func (_cgf _b .Image )(Image ,error ))ColorConverter {return colorConverter {_gac :converterFunc };};func (_aafg *ImageBase )setByte (_cagf int ,_fce byte )error {if _cagf > len (_aafg .Data )-1{return _d .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_aafg .Data [_cagf ]=_fce ;return nil ;};func _eafe (_fgfe _b .Image ,_deeb Image ,_eebe _b .Rectangle ){if _eabf ,_agde :=_fgfe .(SMasker );_agde &&_eabf .HasAlpha (){_deeb .(SMasker ).MakeAlpha ();};_deb (_fgfe ,_deeb ,_eebe );};func ColorAtGray1BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_ed .Gray ,error ){_egbc :=y *bytesPerLine +x >>3;
if _egbc >=len (data ){return _ed .Gray {},_c .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_daad :=data [_egbc ]>>uint (7-(x &7))&1;if len (decode )==2{_daad =uint8 (LinearInterpolate (float64 (_daad ),0.0,1.0,decode [0],decode [1]))&1;};return _ed .Gray {Y :_daad *255},nil ;};func ColorAtGray4BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_ed .Gray ,error ){_eefb :=y *bytesPerLine +x >>1;
if _eefb >=len (data ){return _ed .Gray {},_c .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_bedc :=data [_eefb ]>>uint (4-(x &1)*4)&0xf;if len (decode )==2{_bedc =uint8 (uint32 (LinearInterpolate (float64 (_bedc ),0,15,decode [0],decode [1]))&0xf);};return _ed .Gray {Y :_bedc *17&0xff},nil ;};func (_feea *RGBA32 )RGBAAt (x ,y int )_ed .RGBA {_bdbeg ,_ :=ColorAtRGBA32 (x ,y ,_feea .Width ,_feea .Data ,_feea .Alpha ,_feea .Decode );
return _bdbeg ;};func (_bfgf *NRGBA64 )Validate ()error {if len (_bfgf .Data )!=3*2*_bfgf .Width *_bfgf .Height {return _d .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func _egff (_fdaef _ed .Color )_ed .Color {_dbd :=_ed .GrayModel .Convert (_fdaef ).(_ed .Gray );return _fae (_dbd );};type monochromeModel uint8 ;func (_dggg *Gray2 )GrayAt (x ,y int )_ed .Gray {_acad ,_ :=ColorAtGray2BPC (x ,y ,_dggg .BytesPerLine ,_dggg .Data ,_dggg .Decode );
return _acad ;};func (_cddg *Gray2 )At (x ,y int )_ed .Color {_fdge ,_ :=_cddg .ColorAt (x ,y );return _fdge };var _ Image =&NRGBA16 {};func (_dbca *NRGBA32 )ColorAt (x ,y int )(_ed .Color ,error ){return ColorAtNRGBA32 (x ,y ,_dbca .Width ,_dbca .Data ,_dbca .Alpha ,_dbca .Decode );
};func _fga (_gcfc CMYK ,_geaf RGBA ,_bebe _b .Rectangle ){for _eacg :=0;_eacg < _bebe .Max .X ;_eacg ++{for _eafec :=0;_eafec < _bebe .Max .Y ;_eafec ++{_gded :=_gcfc .CMYKAt (_eacg ,_eafec );_geaf .SetRGBA (_eacg ,_eafec ,_dab (_gded ));};};};func (_gdgb *NRGBA16 )At (x ,y int )_ed .Color {_ccda ,_ :=_gdgb .ColorAt (x ,y );
return _ccda };var _ Image =&CMYK32 {};func _gfbe (_efcf Gray ,_ffdc NRGBA ,_cagc _b .Rectangle ){for _bgb :=0;_bgb < _cagc .Max .X ;_bgb ++{for _decd :=0;_decd < _cagc .Max .Y ;_decd ++{_cbec :=_fbfd (_ffdc .NRGBAAt (_bgb ,_decd ));_efcf .SetGray (_bgb ,_decd ,_cbec );
};};};func _ef (_edc ,_af *Monochrome )(_gfe error ){_ded :=_af .BytesPerLine ;_bca :=_edc .BytesPerLine ;_aa :=_af .BytesPerLine *4-_edc .BytesPerLine ;var (_fba ,_ca byte ;_ae uint32 ;_bcd ,_fbag ,_fge ,_dgc ,_ga ,_da ,_geb int ;);for _fge =0;_fge < _af .Height ;
_fge ++{_bcd =_fge *_ded ;_fbag =4*_fge *_bca ;for _dgc =0;_dgc < _ded ;_dgc ++{_fba =_af .Data [_bcd +_dgc ];_ae =_eag [_fba ];_da =_fbag +_dgc *4;if _aa !=0&&(_dgc +1)*4> _edc .BytesPerLine {for _ga =_aa ;_ga > 0;_ga --{_ca =byte ((_ae >>uint (_ga *8))&0xff);
_geb =_da +(_aa -_ga );if _gfe =_edc .setByte (_geb ,_ca );_gfe !=nil {return _gfe ;};};}else if _gfe =_edc .setFourBytes (_da ,_ae );_gfe !=nil {return _gfe ;};if _gfe =_edc .setFourBytes (_fbag +_dgc *4,_eag [_af .Data [_bcd +_dgc ]]);_gfe !=nil {return _gfe ;
};};for _ga =1;_ga < 4;_ga ++{for _dgc =0;_dgc < _bca ;_dgc ++{if _gfe =_edc .setByte (_fbag +_ga *_bca +_dgc ,_edc .Data [_fbag +_dgc ]);_gfe !=nil {return _gfe ;};};};};return nil ;};func _eba (_bebd NRGBA ,_dbf CMYK ,_daac _b .Rectangle ){for _bed :=0;
_bed < _daac .Max .X ;_bed ++{for _eff :=0;_eff < _daac .Max .Y ;_eff ++{_cgdg :=_bebd .NRGBAAt (_bed ,_eff );_dbf .SetCMYK (_bed ,_eff ,_ccag (_cgdg ));};};};func (_gdfa *Monochrome )RasterOperation (dx ,dy ,dw ,dh int ,op RasterOperator ,src *Monochrome ,sx ,sy int )error {return _adec (_gdfa ,dx ,dy ,dw ,dh ,op ,src ,sx ,sy );
};func ScaleAlphaToMonochrome (data []byte ,width ,height int )([]byte ,error ){_edb :=BytesPerLine (width ,8,1);if len (data )< _edb *height {return nil ,nil ;};_fb :=&Gray8 {NewImageBase (width ,height ,8,1,data ,nil ,nil )};_bg ,_gf :=MonochromeConverter .Convert (_fb );
if _gf !=nil {return nil ,_gf ;};return _bg .Base ().Data ,nil ;};type monochromeThresholdConverter struct{Threshold uint8 ;};func (_cff *CMYK32 )Bounds ()_b .Rectangle {return _b .Rectangle {Max :_b .Point {X :_cff .Width ,Y :_cff .Height }};};func _dedf (_dcdf *_b .Gray ,_gceg uint8 )*_b .Gray {_eafa :=_dcdf .Bounds ();
_fefc :=_b .NewGray (_eafa );for _ebfd :=0;_ebfd < _eafa .Dx ();_ebfd ++{for _dfgc :=0;_dfgc < _eafa .Dy ();_dfgc ++{_cafb :=_dcdf .GrayAt (_ebfd ,_dfgc );_fefc .SetGray (_ebfd ,_dfgc ,_ed .Gray {Y :_caba (_cafb .Y ,_gceg )});};};return _fefc ;};func (_edbad *NRGBA32 )Set (x ,y int ,c _ed .Color ){_fgdb :=y *_edbad .Width +x ;
_gbded :=3*_fgdb ;if _gbded +2>=len (_edbad .Data ){return ;};_dgggc :=_ed .NRGBAModel .Convert (c ).(_ed .NRGBA );_edbad .setRGBA (_fgdb ,_dgggc );};func (_fcce *Gray8 )Bounds ()_b .Rectangle {return _b .Rectangle {Max :_b .Point {X :_fcce .Width ,Y :_fcce .Height }};
};type RGBA32 struct{ImageBase };func _afac (_dfbgf CMYK ,_ege Gray ,_bgeg _b .Rectangle ){for _dgec :=0;_dgec < _bgeg .Max .X ;_dgec ++{for _gbde :=0;_gbde < _bgeg .Max .Y ;_gbde ++{_bgcg :=_egag (_dfbgf .CMYKAt (_dgec ,_gbde ));_ege .SetGray (_dgec ,_gbde ,_bgcg );
};};};func _abbb (_cbd ,_eeae CMYK ,_cdab _b .Rectangle ){for _beeg :=0;_beeg < _cdab .Max .X ;_beeg ++{for _bdb :=0;_bdb < _cdab .Max .Y ;_bdb ++{_eeae .SetCMYK (_beeg ,_bdb ,_cbd .CMYKAt (_beeg ,_bdb ));};};};type Gray4 struct{ImageBase };func _bgbd (_bfadd *Monochrome ,_cdee ,_edbe ,_deegb ,_abge int ,_begb RasterOperator ,_fage *Monochrome ,_adea ,_fcbb int )error {var (_bggee bool ;
_caaf bool ;_bgdb int ;_aeeg int ;_eedd int ;_gaab bool ;_abe byte ;_bgad int ;_cadb int ;_gbe int ;_cagcc ,_ecbe int ;);_edce :=8-(_cdee &7);_afgg :=_aadcc [_edce ];_afba :=_bfadd .BytesPerLine *_edbe +(_cdee >>3);_ceff :=_fage .BytesPerLine *_fcbb +(_adea >>3);
if _deegb < _edce {_bggee =true ;_afgg &=_dgac [8-_edce +_deegb ];};if !_bggee {_bgdb =(_deegb -_edce )>>3;if _bgdb > 0{_caaf =true ;_aeeg =_afba +1;_eedd =_ceff +1;};};_bgad =(_cdee +_deegb )&7;if !(_bggee ||_bgad ==0){_gaab =true ;_abe =_dgac [_bgad ];
_cadb =_afba +1+_bgdb ;_gbe =_ceff +1+_bgdb ;};switch _begb {case PixSrc :for _cagcc =0;_cagcc < _abge ;_cagcc ++{_bfadd .Data [_afba ]=_gdfb (_bfadd .Data [_afba ],_fage .Data [_ceff ],_afgg );_afba +=_bfadd .BytesPerLine ;_ceff +=_fage .BytesPerLine ;
};if _caaf {for _cagcc =0;_cagcc < _abge ;_cagcc ++{for _ecbe =0;_ecbe < _bgdb ;_ecbe ++{_bfadd .Data [_aeeg +_ecbe ]=_fage .Data [_eedd +_ecbe ];};_aeeg +=_bfadd .BytesPerLine ;_eedd +=_fage .BytesPerLine ;};};if _gaab {for _cagcc =0;_cagcc < _abge ;_cagcc ++{_bfadd .Data [_cadb ]=_gdfb (_bfadd .Data [_cadb ],_fage .Data [_gbe ],_abe );
_cadb +=_bfadd .BytesPerLine ;_gbe +=_fage .BytesPerLine ;};};case PixNotSrc :for _cagcc =0;_cagcc < _abge ;_cagcc ++{_bfadd .Data [_afba ]=_gdfb (_bfadd .Data [_afba ],^_fage .Data [_ceff ],_afgg );_afba +=_bfadd .BytesPerLine ;_ceff +=_fage .BytesPerLine ;
};if _caaf {for _cagcc =0;_cagcc < _abge ;_cagcc ++{for _ecbe =0;_ecbe < _bgdb ;_ecbe ++{_bfadd .Data [_aeeg +_ecbe ]=^_fage .Data [_eedd +_ecbe ];};_aeeg +=_bfadd .BytesPerLine ;_eedd +=_fage .BytesPerLine ;};};if _gaab {for _cagcc =0;_cagcc < _abge ;
_cagcc ++{_bfadd .Data [_cadb ]=_gdfb (_bfadd .Data [_cadb ],^_fage .Data [_gbe ],_abe );_cadb +=_bfadd .BytesPerLine ;_gbe +=_fage .BytesPerLine ;};};case PixSrcOrDst :for _cagcc =0;_cagcc < _abge ;_cagcc ++{_bfadd .Data [_afba ]=_gdfb (_bfadd .Data [_afba ],_fage .Data [_ceff ]|_bfadd .Data [_afba ],_afgg );
_afba +=_bfadd .BytesPerLine ;_ceff +=_fage .BytesPerLine ;};if _caaf {for _cagcc =0;_cagcc < _abge ;_cagcc ++{for _ecbe =0;_ecbe < _bgdb ;_ecbe ++{_bfadd .Data [_aeeg +_ecbe ]|=_fage .Data [_eedd +_ecbe ];};_aeeg +=_bfadd .BytesPerLine ;_eedd +=_fage .BytesPerLine ;
};};if _gaab {for _cagcc =0;_cagcc < _abge ;_cagcc ++{_bfadd .Data [_cadb ]=_gdfb (_bfadd .Data [_cadb ],_fage .Data [_gbe ]|_bfadd .Data [_cadb ],_abe );_cadb +=_bfadd .BytesPerLine ;_gbe +=_fage .BytesPerLine ;};};case PixSrcAndDst :for _cagcc =0;_cagcc < _abge ;
_cagcc ++{_bfadd .Data [_afba ]=_gdfb (_bfadd .Data [_afba ],_fage .Data [_ceff ]&_bfadd .Data [_afba ],_afgg );_afba +=_bfadd .BytesPerLine ;_ceff +=_fage .BytesPerLine ;};if _caaf {for _cagcc =0;_cagcc < _abge ;_cagcc ++{for _ecbe =0;_ecbe < _bgdb ;_ecbe ++{_bfadd .Data [_aeeg +_ecbe ]&=_fage .Data [_eedd +_ecbe ];
};_aeeg +=_bfadd .BytesPerLine ;_eedd +=_fage .BytesPerLine ;};};if _gaab {for _cagcc =0;_cagcc < _abge ;_cagcc ++{_bfadd .Data [_cadb ]=_gdfb (_bfadd .Data [_cadb ],_fage .Data [_gbe ]&_bfadd .Data [_cadb ],_abe );_cadb +=_bfadd .BytesPerLine ;_gbe +=_fage .BytesPerLine ;
};};case PixSrcXorDst :for _cagcc =0;_cagcc < _abge ;_cagcc ++{_bfadd .Data [_afba ]=_gdfb (_bfadd .Data [_afba ],_fage .Data [_ceff ]^_bfadd .Data [_afba ],_afgg );_afba +=_bfadd .BytesPerLine ;_ceff +=_fage .BytesPerLine ;};if _caaf {for _cagcc =0;_cagcc < _abge ;
_cagcc ++{for _ecbe =0;_ecbe < _bgdb ;_ecbe ++{_bfadd .Data [_aeeg +_ecbe ]^=_fage .Data [_eedd +_ecbe ];};_aeeg +=_bfadd .BytesPerLine ;_eedd +=_fage .BytesPerLine ;};};if _gaab {for _cagcc =0;_cagcc < _abge ;_cagcc ++{_bfadd .Data [_cadb ]=_gdfb (_bfadd .Data [_cadb ],_fage .Data [_gbe ]^_bfadd .Data [_cadb ],_abe );
_cadb +=_bfadd .BytesPerLine ;_gbe +=_fage .BytesPerLine ;};};case PixNotSrcOrDst :for _cagcc =0;_cagcc < _abge ;_cagcc ++{_bfadd .Data [_afba ]=_gdfb (_bfadd .Data [_afba ],^(_fage .Data [_ceff ])|_bfadd .Data [_afba ],_afgg );_afba +=_bfadd .BytesPerLine ;
_ceff +=_fage .BytesPerLine ;};if _caaf {for _cagcc =0;_cagcc < _abge ;_cagcc ++{for _ecbe =0;_ecbe < _bgdb ;_ecbe ++{_bfadd .Data [_aeeg +_ecbe ]|=^(_fage .Data [_eedd +_ecbe ]);};_aeeg +=_bfadd .BytesPerLine ;_eedd +=_fage .BytesPerLine ;};};if _gaab {for _cagcc =0;
_cagcc < _abge ;_cagcc ++{_bfadd .Data [_cadb ]=_gdfb (_bfadd .Data [_cadb ],^(_fage .Data [_gbe ])|_bfadd .Data [_cadb ],_abe );_cadb +=_bfadd .BytesPerLine ;_gbe +=_fage .BytesPerLine ;};};case PixNotSrcAndDst :for _cagcc =0;_cagcc < _abge ;_cagcc ++{_bfadd .Data [_afba ]=_gdfb (_bfadd .Data [_afba ],^(_fage .Data [_ceff ])&_bfadd .Data [_afba ],_afgg );
_afba +=_bfadd .BytesPerLine ;_ceff +=_fage .BytesPerLine ;};if _caaf {for _cagcc =0;_cagcc < _abge ;_cagcc ++{for _ecbe =0;_ecbe < _bgdb ;_ecbe ++{_bfadd .Data [_aeeg +_ecbe ]&=^_fage .Data [_eedd +_ecbe ];};_aeeg +=_bfadd .BytesPerLine ;_eedd +=_fage .BytesPerLine ;
};};if _gaab {for _cagcc =0;_cagcc < _abge ;_cagcc ++{_bfadd .Data [_cadb ]=_gdfb (_bfadd .Data [_cadb ],^(_fage .Data [_gbe ])&_bfadd .Data [_cadb ],_abe );_cadb +=_bfadd .BytesPerLine ;_gbe +=_fage .BytesPerLine ;};};case PixSrcOrNotDst :for _cagcc =0;
_cagcc < _abge ;_cagcc ++{_bfadd .Data [_afba ]=_gdfb (_bfadd .Data [_afba ],_fage .Data [_ceff ]|^(_bfadd .Data [_afba ]),_afgg );_afba +=_bfadd .BytesPerLine ;_ceff +=_fage .BytesPerLine ;};if _caaf {for _cagcc =0;_cagcc < _abge ;_cagcc ++{for _ecbe =0;
_ecbe < _bgdb ;_ecbe ++{_bfadd .Data [_aeeg +_ecbe ]=_fage .Data [_eedd +_ecbe ]|^(_bfadd .Data [_aeeg +_ecbe ]);};_aeeg +=_bfadd .BytesPerLine ;_eedd +=_fage .BytesPerLine ;};};if _gaab {for _cagcc =0;_cagcc < _abge ;_cagcc ++{_bfadd .Data [_cadb ]=_gdfb (_bfadd .Data [_cadb ],_fage .Data [_gbe ]|^(_bfadd .Data [_cadb ]),_abe );
_cadb +=_bfadd .BytesPerLine ;_gbe +=_fage .BytesPerLine ;};};case PixSrcAndNotDst :for _cagcc =0;_cagcc < _abge ;_cagcc ++{_bfadd .Data [_afba ]=_gdfb (_bfadd .Data [_afba ],_fage .Data [_ceff ]&^(_bfadd .Data [_afba ]),_afgg );_afba +=_bfadd .BytesPerLine ;
_ceff +=_fage .BytesPerLine ;};if _caaf {for _cagcc =0;_cagcc < _abge ;_cagcc ++{for _ecbe =0;_ecbe < _bgdb ;_ecbe ++{_bfadd .Data [_aeeg +_ecbe ]=_fage .Data [_eedd +_ecbe ]&^(_bfadd .Data [_aeeg +_ecbe ]);};_aeeg +=_bfadd .BytesPerLine ;_eedd +=_fage .BytesPerLine ;
};};if _gaab {for _cagcc =0;_cagcc < _abge ;_cagcc ++{_bfadd .Data [_cadb ]=_gdfb (_bfadd .Data [_cadb ],_fage .Data [_gbe ]&^(_bfadd .Data [_cadb ]),_abe );_cadb +=_bfadd .BytesPerLine ;_gbe +=_fage .BytesPerLine ;};};case PixNotPixSrcOrDst :for _cagcc =0;
_cagcc < _abge ;_cagcc ++{_bfadd .Data [_afba ]=_gdfb (_bfadd .Data [_afba ],^(_fage .Data [_ceff ]|_bfadd .Data [_afba ]),_afgg );_afba +=_bfadd .BytesPerLine ;_ceff +=_fage .BytesPerLine ;};if _caaf {for _cagcc =0;_cagcc < _abge ;_cagcc ++{for _ecbe =0;
_ecbe < _bgdb ;_ecbe ++{_bfadd .Data [_aeeg +_ecbe ]=^(_fage .Data [_eedd +_ecbe ]|_bfadd .Data [_aeeg +_ecbe ]);};_aeeg +=_bfadd .BytesPerLine ;_eedd +=_fage .BytesPerLine ;};};if _gaab {for _cagcc =0;_cagcc < _abge ;_cagcc ++{_bfadd .Data [_cadb ]=_gdfb (_bfadd .Data [_cadb ],^(_fage .Data [_gbe ]|_bfadd .Data [_cadb ]),_abe );
_cadb +=_bfadd .BytesPerLine ;_gbe +=_fage .BytesPerLine ;};};case PixNotPixSrcAndDst :for _cagcc =0;_cagcc < _abge ;_cagcc ++{_bfadd .Data [_afba ]=_gdfb (_bfadd .Data [_afba ],^(_fage .Data [_ceff ]&_bfadd .Data [_afba ]),_afgg );_afba +=_bfadd .BytesPerLine ;
_ceff +=_fage .BytesPerLine ;};if _caaf {for _cagcc =0;_cagcc < _abge ;_cagcc ++{for _ecbe =0;_ecbe < _bgdb ;_ecbe ++{_bfadd .Data [_aeeg +_ecbe ]=^(_fage .Data [_eedd +_ecbe ]&_bfadd .Data [_aeeg +_ecbe ]);};_aeeg +=_bfadd .BytesPerLine ;_eedd +=_fage .BytesPerLine ;
};};if _gaab {for _cagcc =0;_cagcc < _abge ;_cagcc ++{_bfadd .Data [_cadb ]=_gdfb (_bfadd .Data [_cadb ],^(_fage .Data [_gbe ]&_bfadd .Data [_cadb ]),_abe );_cadb +=_bfadd .BytesPerLine ;_gbe +=_fage .BytesPerLine ;};};case PixNotPixSrcXorDst :for _cagcc =0;
_cagcc < _abge ;_cagcc ++{_bfadd .Data [_afba ]=_gdfb (_bfadd .Data [_afba ],^(_fage .Data [_ceff ]^_bfadd .Data [_afba ]),_afgg );_afba +=_bfadd .BytesPerLine ;_ceff +=_fage .BytesPerLine ;};if _caaf {for _cagcc =0;_cagcc < _abge ;_cagcc ++{for _ecbe =0;
_ecbe < _bgdb ;_ecbe ++{_bfadd .Data [_aeeg +_ecbe ]=^(_fage .Data [_eedd +_ecbe ]^_bfadd .Data [_aeeg +_ecbe ]);};_aeeg +=_bfadd .BytesPerLine ;_eedd +=_fage .BytesPerLine ;};};if _gaab {for _cagcc =0;_cagcc < _abge ;_cagcc ++{_bfadd .Data [_cadb ]=_gdfb (_bfadd .Data [_cadb ],^(_fage .Data [_gbe ]^_bfadd .Data [_cadb ]),_abe );
_cadb +=_bfadd .BytesPerLine ;_gbe +=_fage .BytesPerLine ;};};default:_gg .Log .Debug ("I\u006e\u0076\u0061\u006c\u0069\u0064 \u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070e\u0072\u0061\u0074o\u0072:\u0020\u0025\u0064",_begb );return _d .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072");
};return nil ;};func (_eee *Gray4 )ColorAt (x ,y int )(_ed .Color ,error ){return ColorAtGray4BPC (x ,y ,_eee .BytesPerLine ,_eee .Data ,_eee .Decode );};