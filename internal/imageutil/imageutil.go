//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package imageutil ;import (_fe "encoding/binary";_g "errors";_cc "fmt";_b "github.com/unidoc/unipdf/v3/common";_a "github.com/unidoc/unipdf/v3/internal/bitwise";_c "image";_d "image/color";_dg "image/draw";_gf "math";);func (_ccfa *NRGBA32 )Validate ()error {if len (_ccfa .Data )!=3*_ccfa .Width *_ccfa .Height {return _g .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func _fdgc (_fcbf int ,_ffecf int )int {if _fcbf < _ffecf {return _fcbf ;};return _ffecf ;};func _bdbeb (_eea CMYK ,_gbdg Gray ,_ebaf _c .Rectangle ){for _fbfb :=0;_fbfb < _ebaf .Max .X ;_fbfb ++{for _eff :=0;_eff < _ebaf .Max .Y ;_eff ++{_ggdg :=_bgbg (_eea .CMYKAt (_fbfb ,_eff ));
_gbdg .SetGray (_fbfb ,_eff ,_ggdg );};};};func _fag (_eced _d .CMYK )_d .RGBA {_gaa ,_ced ,_aeaa :=_d .CMYKToRGB (_eced .C ,_eced .M ,_eced .Y ,_eced .K );return _d .RGBA {R :_gaa ,G :_ced ,B :_aeaa ,A :0xff};};func (_aeda *Monochrome )Histogram ()(_acg [256]int ){for _ ,_fbaeb :=range _aeda .Data {_acg [0xff]+=int (_egf [_aeda .Data [_fbaeb ]]);
};return _acg ;};type monochromeThresholdConverter struct{Threshold uint8 ;};func (_cbabb *Gray8 )Set (x ,y int ,c _d .Color ){_adfb :=y *_cbabb .BytesPerLine +x ;if _adfb > len (_cbabb .Data )-1{return ;};_cggf :=_d .GrayModel .Convert (c );_cbabb .Data [_adfb ]=_cggf .(_d .Gray ).Y ;
};type RGBA interface{RGBAAt (_bgcf ,_dddg int )_d .RGBA ;SetRGBA (_cgbf ,_begca int ,_ecf _d .RGBA );};func (_bafd *Monochrome )AddPadding ()(_defg error ){if _cddg :=((_bafd .Width *_bafd .Height )+7)>>3;len (_bafd .Data )< _cddg {return _cc .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064a\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002e\u0020\u0054\u0068\u0065\u0020\u0064\u0061t\u0061\u0020s\u0068\u006fu\u006c\u0064\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0020\u0061\u0074 l\u0065\u0061\u0073\u0074\u003a\u0020\u0027\u0025\u0064'\u0020\u0062\u0079\u0074\u0065\u0073",len (_bafd .Data ),_cddg );
};_fgda :=_bafd .Width %8;if _fgda ==0{return nil ;};_aba :=_bafd .Width /8;_fbae :=_a .NewReader (_bafd .Data );_faaf :=make ([]byte ,_bafd .Height *_bafd .BytesPerLine );_ccdc :=_a .NewWriterMSB (_faaf );_gadc :=make ([]byte ,_aba );var (_fage int ;_ccdda uint64 ;
);for _fage =0;_fage < _bafd .Height ;_fage ++{if _ ,_defg =_fbae .Read (_gadc );_defg !=nil {return _defg ;};if _ ,_defg =_ccdc .Write (_gadc );_defg !=nil {return _defg ;};if _ccdda ,_defg =_fbae .ReadBits (byte (_fgda ));_defg !=nil {return _defg ;};
if _defg =_ccdc .WriteByte (byte (_ccdda )<<uint (8-_fgda ));_defg !=nil {return _defg ;};};_bafd .Data =_ccdc .Data ();return nil ;};func _ded (_ffeg _c .Image ,_eeab Image ,_dcdc _c .Rectangle ){if _afaac ,_ddfca :=_ffeg .(SMasker );_ddfca &&_afaac .HasAlpha (){_eeab .(SMasker ).MakeAlpha ();
};_cabe (_ffeg ,_eeab ,_dcdc );};var _ NRGBA =&NRGBA32 {};func _df (_gb ,_dee *Monochrome )(_be error ){_ead :=_dee .BytesPerLine ;_fd :=_gb .BytesPerLine ;var (_cbg byte ;_eaf uint16 ;_bffg ,_ae ,_gcg ,_cbb ,_ge int ;);for _gcg =0;_gcg < _dee .Height ;
_gcg ++{_bffg =_gcg *_ead ;_ae =2*_gcg *_fd ;for _cbb =0;_cbb < _ead ;_cbb ++{_cbg =_dee .Data [_bffg +_cbb ];_eaf =_fefe [_cbg ];_ge =_ae +_cbb *2;if _gb .BytesPerLine !=_dee .BytesPerLine *2&&(_cbb +1)*2> _gb .BytesPerLine {_be =_gb .setByte (_ge ,byte (_eaf >>8));
}else {_be =_gb .setTwoBytes (_ge ,_eaf );};if _be !=nil {return _be ;};};for _cbb =0;_cbb < _fd ;_cbb ++{_ge =_ae +_fd +_cbb ;_cbg =_gb .Data [_ae +_cbb ];if _be =_gb .setByte (_ge ,_cbg );_be !=nil {return _be ;};};};return nil ;};func (_dfd *Monochrome )Set (x ,y int ,c _d .Color ){_fge :=y *_dfd .BytesPerLine +x >>3;
if _fge > len (_dfd .Data )-1{return ;};_aeef :=_dfd .ColorModel ().Convert (c ).(_d .Gray );_dfd .setGray (x ,_aeef ,_fge );};func (_fdaca *Gray8 )SetGray (x ,y int ,g _d .Gray ){_fgg :=y *_fdaca .BytesPerLine +x ;if _fgg > len (_fdaca .Data )-1{return ;
};_fdaca .Data [_fgg ]=g .Y ;};var _ Image =&Monochrome {};func _gcf (_cgce *Monochrome ,_gecb int ,_ag []byte )(_bcb *Monochrome ,_cbf error ){const _aga ="\u0072\u0065d\u0075\u0063\u0065R\u0061\u006e\u006b\u0042\u0069\u006e\u0061\u0072\u0079";if _cgce ==nil {return nil ,_g .New ("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d");
};if _gecb < 1||_gecb > 4{return nil ,_g .New ("\u006c\u0065\u0076\u0065\u006c\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020\u0073e\u0074\u0020\u007b\u0031\u002c\u0032\u002c\u0033\u002c\u0034\u007d");};if _cgce .Height <=1{return nil ,_g .New ("\u0073\u006f\u0075rc\u0065\u0020\u0068\u0065\u0069\u0067\u0068\u0074\u0020m\u0075s\u0074 \u0062e\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020\u0027\u0032\u0027");
};_bcb =_dgb (_cgce .Width /2,_cgce .Height /2);if _ag ==nil {_ag =_gff ();};_dd :=_fdgc (_cgce .BytesPerLine ,2*_bcb .BytesPerLine );switch _gecb {case 1:_cbf =_ggf (_cgce ,_bcb ,_ag ,_dd );case 2:_cbf =_gfc (_cgce ,_bcb ,_ag ,_dd );case 3:_cbf =_bbb (_cgce ,_bcb ,_ag ,_dd );
case 4:_cbf =_gda (_cgce ,_bcb ,_ag ,_dd );};if _cbf !=nil {return nil ,_cbf ;};return _bcb ,nil ;};func _dec (_abd *Monochrome ,_afa ,_eaff int )(*Monochrome ,error ){if _abd ==nil {return nil ,_g .New ("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064");
};if _afa <=0||_eaff <=0{return nil ,_g .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0073\u0063\u0061l\u0065\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020<\u003d\u0020\u0030");};if _afa ==_eaff {if _afa ==1{return _abd .copy (),nil ;
};if _afa ==2||_afa ==4||_afa ==8{_baf ,_afe :=_gc (_abd ,_afa );if _afe !=nil {return nil ,_afe ;};return _baf ,nil ;};};_fg :=_afa *_abd .Width ;_da :=_eaff *_abd .Height ;_cca :=_dgb (_fg ,_da );_gadg :=_cca .BytesPerLine ;var (_bea ,_fgc ,_ad ,_ged ,_dag int ;
_eb byte ;_fba error ;);for _fgc =0;_fgc < _abd .Height ;_fgc ++{_bea =_eaff *_fgc *_gadg ;for _ad =0;_ad < _abd .Width ;_ad ++{if _cd :=_abd .getBitAt (_ad ,_fgc );_cd {_dag =_afa *_ad ;for _ged =0;_ged < _afa ;_ged ++{_cca .setIndexedBit (_bea *8+_dag +_ged );
};};};for _ged =1;_ged < _eaff ;_ged ++{_abg :=_bea +_ged *_gadg ;for _bgb :=0;_bgb < _gadg ;_bgb ++{if _eb ,_fba =_cca .getByte (_bea +_bgb );_fba !=nil {return nil ,_fba ;};if _fba =_cca .setByte (_abg +_bgb ,_eb );_fba !=nil {return nil ,_fba ;};};};
};return _cca ,nil ;};func (_gdcg *NRGBA64 )NRGBA64At (x ,y int )_d .NRGBA64 {_gfad ,_ :=ColorAtNRGBA64 (x ,y ,_gdcg .Width ,_gdcg .Data ,_gdcg .Alpha ,_gdcg .Decode );return _gfad ;};func (_aefg *ImageBase )getByte (_ffad int )(byte ,error ){if _ffad > len (_aefg .Data )-1||_ffad < 0{return 0,_cc .Errorf ("\u0069\u006e\u0064\u0065x:\u0020\u0025\u0064\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006eg\u0065",_ffad );
};return _aefg .Data [_ffad ],nil ;};func (_gdebf *RGBA32 )ColorAt (x ,y int )(_d .Color ,error ){return ColorAtRGBA32 (x ,y ,_gdebf .Width ,_gdebf .Data ,_gdebf .Alpha ,_gdebf .Decode );};func _dgb (_aad ,_ef int )*Monochrome {return &Monochrome {ImageBase :NewImageBase (_aad ,_ef ,1,1,nil ,nil ,nil ),ModelThreshold :0x0f};
};func _dagf (_cbcf *_c .Gray16 ,_bgfd uint8 )*_c .Gray {_fgfb :=_cbcf .Bounds ();_ecaa :=_c .NewGray (_fgfb );for _dbaca :=0;_dbaca < _fgfb .Dx ();_dbaca ++{for _fdae :=0;_fdae < _fgfb .Dy ();_fdae ++{_cgcg :=_cbcf .Gray16At (_dbaca ,_fdae );_ecaa .SetGray (_dbaca ,_fdae ,_d .Gray {Y :_gada (uint8 (_cgcg .Y /256),_bgfd )});
};};return _ecaa ;};func _egb (_gd ,_aeg *Monochrome )(_fef error ){_ba :=_aeg .BytesPerLine ;_cg :=_gd .BytesPerLine ;_fee :=_aeg .BytesPerLine *4-_gd .BytesPerLine ;var (_af ,_gg byte ;_ega uint32 ;_gad ,_ed ,_fb ,_gfd ,_cgc ,_fc ,_db int ;);for _fb =0;
_fb < _aeg .Height ;_fb ++{_gad =_fb *_ba ;_ed =4*_fb *_cg ;for _gfd =0;_gfd < _ba ;_gfd ++{_af =_aeg .Data [_gad +_gfd ];_ega =_ccd [_af ];_fc =_ed +_gfd *4;if _fee !=0&&(_gfd +1)*4> _gd .BytesPerLine {for _cgc =_fee ;_cgc > 0;_cgc --{_gg =byte ((_ega >>uint (_cgc *8))&0xff);
_db =_fc +(_fee -_cgc );if _fef =_gd .setByte (_db ,_gg );_fef !=nil {return _fef ;};};}else if _fef =_gd .setFourBytes (_fc ,_ega );_fef !=nil {return _fef ;};if _fef =_gd .setFourBytes (_ed +_gfd *4,_ccd [_aeg .Data [_gad +_gfd ]]);_fef !=nil {return _fef ;
};};for _cgc =1;_cgc < 4;_cgc ++{for _gfd =0;_gfd < _cg ;_gfd ++{if _fef =_gd .setByte (_ed +_cgc *_cg +_gfd ,_gd .Data [_ed +_gfd ]);_fef !=nil {return _fef ;};};};};return nil ;};type NRGBA16 struct{ImageBase };func (_eagb *Gray2 )Base ()*ImageBase {return &_eagb .ImageBase };
func (_cedf *Gray8 )ColorAt (x ,y int )(_d .Color ,error ){return ColorAtGray8BPC (x ,y ,_cedf .BytesPerLine ,_cedf .Data ,_cedf .Decode );};var _ Image =&Gray2 {};func (_bffgc *CMYK32 )CMYKAt (x ,y int )_d .CMYK {_bed ,_ :=ColorAtCMYK (x ,y ,_bffgc .Width ,_bffgc .Data ,_bffgc .Decode );
return _bed ;};func _fcca (_badf Gray ,_ffecd RGBA ,_caae _c .Rectangle ){for _bagc :=0;_bagc < _caae .Max .X ;_bagc ++{for _dgdg :=0;_dgdg < _caae .Max .Y ;_dgdg ++{_fedd :=_badf .GrayAt (_bagc ,_dgdg );_ffecd .SetRGBA (_bagc ,_dgdg ,_dgff (_fedd ));};
};};func ColorAtGray1BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_d .Gray ,error ){_cbgg :=y *bytesPerLine +x >>3;if _cbgg >=len (data ){return _d .Gray {},_cc .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_gdfb :=data [_cbgg ]>>uint (7-(x &7))&1;if len (decode )==2{_gdfb =uint8 (LinearInterpolate (float64 (_gdfb ),0.0,1.0,decode [0],decode [1]))&1;};return _d .Gray {Y :_gdfb *255},nil ;};func _cabe (_gba _c .Image ,_gaba Image ,_agd _c .Rectangle ){for _ege :=0;
_ege < _agd .Max .X ;_ege ++{for _decf :=0;_decf < _agd .Max .Y ;_decf ++{_defd :=_gba .At (_ege ,_decf );_gaba .Set (_ege ,_decf ,_defd );};};};func _faa (_ccc RGBA ,_cfbc CMYK ,_ccdd _c .Rectangle ){for _dfbd :=0;_dfbd < _ccdd .Max .X ;_dfbd ++{for _eba :=0;
_eba < _ccdd .Max .Y ;_eba ++{_ccb :=_ccc .RGBAAt (_dfbd ,_eba );_cfbc .SetCMYK (_dfbd ,_eba ,_feaac (_ccb ));};};};func (_bege *Gray2 )ColorAt (x ,y int )(_d .Color ,error ){return ColorAtGray2BPC (x ,y ,_bege .BytesPerLine ,_bege .Data ,_bege .Decode );
};func MonochromeModel (threshold uint8 )_d .Model {return monochromeModel (threshold )};func (_bgg *Gray4 )Histogram ()(_acf [256]int ){for _edgb :=0;_edgb < _bgg .Width ;_edgb ++{for _bgge :=0;_bgge < _bgg .Height ;_bgge ++{_acf [_bgg .GrayAt (_edgb ,_bgge ).Y ]++;
};};return _acf ;};var _ Image =&NRGBA16 {};func (_cecf *Monochrome )SetGray (x ,y int ,g _d .Gray ){_bfaf :=y *_cecf .BytesPerLine +x >>3;if _bfaf > len (_cecf .Data )-1{return ;};g =_ffec (g ,monochromeModel (_cecf .ModelThreshold ));_cecf .setGray (x ,g ,_bfaf );
};func (_fdbg *Monochrome )At (x ,y int )_d .Color {_ddea ,_ :=_fdbg .ColorAt (x ,y );return _ddea };var _egf [256]uint8 ;func (_cabg *Monochrome )setGray (_adea int ,_aedab _d .Gray ,_accb int ){if _aedab .Y ==0{_cabg .clearBit (_accb ,_adea );}else {_cabg .setGrayBit (_accb ,_adea );
};};func (_ddb *Gray16 )Histogram ()(_bddc [256]int ){for _gbcf :=0;_gbcf < _ddb .Width ;_gbcf ++{for _agg :=0;_agg < _ddb .Height ;_agg ++{_bddc [_ddb .GrayAt (_gbcf ,_agg ).Y ]++;};};return _bddc ;};func AddDataPadding (width ,height ,bitsPerComponent ,colorComponents int ,data []byte )([]byte ,error ){_dgef :=BytesPerLine (width ,bitsPerComponent ,colorComponents );
if _dgef ==width *colorComponents *bitsPerComponent /8{return data ,nil ;};_fagb :=width *colorComponents *bitsPerComponent ;_bga :=_dgef *8;_befe :=8-(_bga -_fagb );_feac :=_a .NewReader (data );_aebf :=_dgef -1;_aaeb :=make ([]byte ,_aebf );_efef :=make ([]byte ,height *_dgef );
_ebdb :=_a .NewWriterMSB (_efef );var _ebf uint64 ;var _edef error ;for _fbafe :=0;_fbafe < height ;_fbafe ++{_ ,_edef =_feac .Read (_aaeb );if _edef !=nil {return nil ,_edef ;};_ ,_edef =_ebdb .Write (_aaeb );if _edef !=nil {return nil ,_edef ;};_ebf ,_edef =_feac .ReadBits (byte (_befe ));
if _edef !=nil {return nil ,_edef ;};_ ,_edef =_ebdb .WriteBits (_ebf ,_befe );if _edef !=nil {return nil ,_edef ;};_ebdb .FinishByte ();};return _efef ,nil ;};type NRGBA32 struct{ImageBase };func (_ccee *Gray4 )ColorModel ()_d .Model {return Gray4Model };
func ColorAt (x ,y ,width ,bitsPerColor ,colorComponents ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_d .Color ,error ){switch colorComponents {case 1:return ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine ,data ,decode );case 3:return ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor ,data ,alpha ,decode );
case 4:return ColorAtCMYK (x ,y ,width ,data ,decode );default:return nil ,_cc .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0063o\u006c\u006f\u0072\u0020\u0063\u006f\u006dp\u006f\u006e\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0064",colorComponents );
};};func (_fbad *NRGBA64 )ColorAt (x ,y int )(_d .Color ,error ){return ColorAtNRGBA64 (x ,y ,_fbad .Width ,_fbad .Data ,_fbad .Alpha ,_fbad .Decode );};func (_fdgd *NRGBA16 )At (x ,y int )_d .Color {_geeb ,_ :=_fdgd .ColorAt (x ,y );return _geeb };func _bcfb (_faed _d .NRGBA )_d .RGBA {_fdbe ,_bbc ,_dadf ,_dae :=_faed .RGBA ();
return _d .RGBA {R :uint8 (_fdbe >>8),G :uint8 (_bbc >>8),B :uint8 (_dadf >>8),A :uint8 (_dae >>8)};};func (_agaba *NRGBA16 )Validate ()error {if len (_agaba .Data )!=3*_agaba .Width *_agaba .Height /2{return _g .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func (_afff *RGBA32 )setRGBA (_fagea int ,_acgf _d .RGBA ){_fcdba :=3*_fagea ;_afff .Data [_fcdba ]=_acgf .R ;_afff .Data [_fcdba +1]=_acgf .G ;_afff .Data [_fcdba +2]=_acgf .B ;if _fagea < len (_afff .Alpha ){_afff .Alpha [_fagea ]=_acgf .A ;
};};func _feb (_bfdd int ,_febg int )error {return _cc .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",_bfdd ,_febg );
};var _ Image =&NRGBA32 {};func (_dcf *ImageBase )newAlpha (){_beeg :=BytesPerLine (_dcf .Width ,_dcf .BitsPerComponent ,1);_dcf .Alpha =make ([]byte ,_dcf .Height *_beeg );};func (_cec colorConverter )Convert (src _c .Image )(Image ,error ){return _cec ._ggd (src )};
func _gbade (_abac _c .Image )(Image ,error ){if _gbdea ,_feca :=_abac .(*NRGBA64 );_feca {return _gbdea .Copy (),nil ;};_ebaa ,_dddgg ,_dgfa :=_ddbc (_abac ,2);_ebfa ,_dcde :=NewImage (_ebaa .Max .X ,_ebaa .Max .Y ,16,3,nil ,_dgfa ,nil );if _dcde !=nil {return nil ,_dcde ;
};_ded (_abac ,_ebfa ,_ebaa );if len (_dgfa )!=0&&!_dddgg {if _gfe :=_fbcd (_dgfa ,_ebfa );_gfe !=nil {return nil ,_gfe ;};};return _ebfa ,nil ;};func _fbcd (_ddeg []byte ,_cfdd Image )error {_cfdf :=true ;for _cedee :=0;_cedee < len (_ddeg );_cedee ++{if _ddeg [_cedee ]!=0xff{_cfdf =false ;
break ;};};if _cfdf {switch _bffb :=_cfdd .(type ){case *NRGBA32 :_bffb .Alpha =nil ;case *NRGBA64 :_bffb .Alpha =nil ;default:return _cc .Errorf ("i\u006ete\u0072n\u0061l\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020i\u006d\u0061\u0067\u0065\u0020s\u0068\u006f\u0075l\u0064\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0074\u0079\u0070e\u0020\u002a\u004eRGB\u0041\u0033\u0032\u0020\u006f\u0072 \u002a\u004e\u0052\u0047\u0042\u0041\u0036\u0034\u0020\u0062\u0075\u0074 \u0069s\u003a\u0020\u0025\u0054",_cfdd );
};};return nil ;};func _geb (_ccec ,_adf int ,_fed []byte )*Monochrome {_bdge :=_dgb (_ccec ,_adf );_bdge .Data =_fed ;return _bdge ;};func _cbfg (_aaa _d .CMYK )_d .NRGBA {_cbdg ,_ggg ,_aegcf :=_d .CMYKToRGB (_aaa .C ,_aaa .M ,_aaa .Y ,_aaa .K );return _d .NRGBA {R :_cbdg ,G :_ggg ,B :_aegcf ,A :0xff};
};func _gada (_cdec ,_bdef uint8 )uint8 {if _cdec < _bdef {return 255;};return 0;};var _ Image =&Gray8 {};func (_aefa *monochromeThresholdConverter )Convert (img _c .Image )(Image ,error ){if _beb ,_fgag :=img .(*Monochrome );_fgag {return _beb .Copy (),nil ;
};_agab :=img .Bounds ();_fdf ,_fcf :=NewImage (_agab .Max .X ,_agab .Max .Y ,1,1,nil ,nil ,nil );if _fcf !=nil {return nil ,_fcf ;};_fdf .(*Monochrome ).ModelThreshold =_aefa .Threshold ;for _bef :=0;_bef < _agab .Max .X ;_bef ++{for _cccg :=0;_cccg < _agab .Max .Y ;
_cccg ++{_gacf :=img .At (_bef ,_cccg );_fdf .Set (_bef ,_cccg ,_gacf );};};return _fdf ,nil ;};func _dbb ()(_eeb [256]uint16 ){for _afg :=0;_afg < 256;_afg ++{if _afg &0x01!=0{_eeb [_afg ]|=0x3;};if _afg &0x02!=0{_eeb [_afg ]|=0xc;};if _afg &0x04!=0{_eeb [_afg ]|=0x30;
};if _afg &0x08!=0{_eeb [_afg ]|=0xc0;};if _afg &0x10!=0{_eeb [_afg ]|=0x300;};if _afg &0x20!=0{_eeb [_afg ]|=0xc00;};if _afg &0x40!=0{_eeb [_afg ]|=0x3000;};if _afg &0x80!=0{_eeb [_afg ]|=0xc000;};};return _eeb ;};func (_eacd *Gray2 )Histogram ()(_dddd [256]int ){for _efaa :=0;
_efaa < _eacd .Width ;_efaa ++{for _ccde :=0;_ccde < _eacd .Height ;_ccde ++{_dddd [_eacd .GrayAt (_efaa ,_ccde ).Y ]++;};};return _dddd ;};func (_acdc *Gray16 )At (x ,y int )_d .Color {_bdcf ,_ :=_acdc .ColorAt (x ,y );return _bdcf };func (_fdgb *NRGBA64 )setNRGBA64 (_bcaf int ,_geea _d .NRGBA64 ,_gbgg int ){_fdgb .Data [_bcaf ]=uint8 (_geea .R >>8);
_fdgb .Data [_bcaf +1]=uint8 (_geea .R &0xff);_fdgb .Data [_bcaf +2]=uint8 (_geea .G >>8);_fdgb .Data [_bcaf +3]=uint8 (_geea .G &0xff);_fdgb .Data [_bcaf +4]=uint8 (_geea .B >>8);_fdgb .Data [_bcaf +5]=uint8 (_geea .B &0xff);if _gbgg +1< len (_fdgb .Alpha ){_fdgb .Alpha [_gbgg ]=uint8 (_geea .A >>8);
_fdgb .Alpha [_gbgg +1]=uint8 (_geea .A &0xff);};};func (_afeg *Gray4 )SetGray (x ,y int ,g _d .Gray ){if x >=_afeg .Width ||y >=_afeg .Height {return ;};g =_bceb (g );_afeg .setGray (x ,y ,g );};var (_egca =[]byte {0x00,0x80,0xC0,0xE0,0xF0,0xF8,0xFC,0xFE,0xFF};
_ggba =[]byte {0x00,0x01,0x03,0x07,0x0F,0x1F,0x3F,0x7F,0xFF};);func _fda (_afaa _d .NYCbCrA )_d .NRGBA {_cdcf :=int32 (_afaa .Y )*0x10101;_bfa :=int32 (_afaa .Cb )-128;_aab :=int32 (_afaa .Cr )-128;_dde :=_cdcf +91881*_aab ;if uint32 (_dde )&0xff000000==0{_dde >>=8;
}else {_dde =^(_dde >>31)&0xffff;};_gdgg :=_cdcf -22554*_bfa -46802*_aab ;if uint32 (_gdgg )&0xff000000==0{_gdgg >>=8;}else {_gdgg =^(_gdgg >>31)&0xffff;};_gcd :=_cdcf +116130*_bfa ;if uint32 (_gcd )&0xff000000==0{_gcd >>=8;}else {_gcd =^(_gcd >>31)&0xffff;
};return _d .NRGBA {R :uint8 (_dde >>8),G :uint8 (_gdgg >>8),B :uint8 (_gcd >>8),A :_afaa .A };};func (_feaed *ImageBase )MakeAlpha (){_feaed .newAlpha ()};func init (){_aded ()};func (_gcce *Gray16 )ColorModel ()_d .Model {return _d .Gray16Model };var _ Gray =&Monochrome {};
func NewImageBase (width int ,height int ,bitsPerComponent int ,colorComponents int ,data []byte ,alpha []byte ,decode []float64 )ImageBase {_begbf :=ImageBase {Width :width ,Height :height ,BitsPerComponent :bitsPerComponent ,ColorComponents :colorComponents ,Data :data ,Alpha :alpha ,Decode :decode ,BytesPerLine :BytesPerLine (width ,bitsPerComponent ,colorComponents )};
if data ==nil {_begbf .Data =make ([]byte ,height *_begbf .BytesPerLine );};return _begbf ;};func (_abggb *NRGBA16 )Copy ()Image {return &NRGBA16 {ImageBase :_abggb .copy ()}};type NRGBA64 struct{ImageBase };func _gdge (_ddba ,_aedd RGBA ,_cffb _c .Rectangle ){for _gdee :=0;
_gdee < _cffb .Max .X ;_gdee ++{for _cgcec :=0;_cgcec < _cffb .Max .Y ;_cgcec ++{_aedd .SetRGBA (_gdee ,_cgcec ,_ddba .RGBAAt (_gdee ,_cgcec ));};};};func _bbb (_eac ,_gcfg *Monochrome ,_fgb []byte ,_fab int )(_feg error ){var (_fbg ,_dgbc ,_ac ,_gcff ,_fbb ,_cdg ,_fegg ,_deb int ;
_gac ,_aff ,_gcb ,_decb uint32 ;_fabd ,_ecd byte ;_gacb uint16 ;);_cgg :=make ([]byte ,4);_gef :=make ([]byte ,4);for _ac =0;_ac < _eac .Height -1;_ac ,_gcff =_ac +2,_gcff +1{_fbg =_ac *_eac .BytesPerLine ;_dgbc =_gcff *_gcfg .BytesPerLine ;for _fbb ,_cdg =0,0;
_fbb < _fab ;_fbb ,_cdg =_fbb +4,_cdg +1{for _fegg =0;_fegg < 4;_fegg ++{_deb =_fbg +_fbb +_fegg ;if _deb <=len (_eac .Data )-1&&_deb < _fbg +_eac .BytesPerLine {_cgg [_fegg ]=_eac .Data [_deb ];}else {_cgg [_fegg ]=0x00;};_deb =_fbg +_eac .BytesPerLine +_fbb +_fegg ;
if _deb <=len (_eac .Data )-1&&_deb < _fbg +(2*_eac .BytesPerLine ){_gef [_fegg ]=_eac .Data [_deb ];}else {_gef [_fegg ]=0x00;};};_gac =_fe .BigEndian .Uint32 (_cgg );_aff =_fe .BigEndian .Uint32 (_gef );_gcb =_gac &_aff ;_gcb |=_gcb <<1;_decb =_gac |_aff ;
_decb &=_decb <<1;_aff =_gcb &_decb ;_aff &=0xaaaaaaaa;_gac =_aff |(_aff <<7);_fabd =byte (_gac >>24);_ecd =byte ((_gac >>8)&0xff);_deb =_dgbc +_cdg ;if _deb +1==len (_gcfg .Data )-1||_deb +1>=_dgbc +_gcfg .BytesPerLine {if _feg =_gcfg .setByte (_deb ,_fgb [_fabd ]);
_feg !=nil {return _cc .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_deb );};}else {_gacb =(uint16 (_fgb [_fabd ])<<8)|uint16 (_fgb [_ecd ]);if _feg =_gcfg .setTwoBytes (_deb ,_gacb );_feg !=nil {return _cc .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_deb );
};_cdg ++;};};};return nil ;};func (_abee *NRGBA32 )Bounds ()_c .Rectangle {return _c .Rectangle {Max :_c .Point {X :_abee .Width ,Y :_abee .Height }};};func (_bfea *Gray2 )ColorModel ()_d .Model {return Gray2Model };func ColorAtGray4BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_d .Gray ,error ){_cbe :=y *bytesPerLine +x >>1;
if _cbe >=len (data ){return _d .Gray {},_cc .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_efdd :=data [_cbe ]>>uint (4-(x &1)*4)&0xf;if len (decode )==2{_efdd =uint8 (uint32 (LinearInterpolate (float64 (_efdd ),0,15,decode [0],decode [1]))&0xf);};return _d .Gray {Y :_efdd *17&0xff},nil ;};func (_aede *Gray16 )GrayAt (x ,y int )_d .Gray {_eeec ,_ :=_aede .ColorAt (x ,y );
return _d .Gray {Y :uint8 (_eeec .(_d .Gray16 ).Y >>8)};};func (_efc *CMYK32 )Bounds ()_c .Rectangle {return _c .Rectangle {Max :_c .Point {X :_efc .Width ,Y :_efc .Height }};};var _ Image =&RGBA32 {};func _gbbf (_bbca *Monochrome ,_defe ,_bcea int ,_edf ,_fbfbg int ,_ccfe RasterOperator ,_dcfg *Monochrome ,_gbaa ,_bec int )error {var _eead ,_eegd ,_cafcbg ,_cede int ;
if _defe < 0{_gbaa -=_defe ;_edf +=_defe ;_defe =0;};if _gbaa < 0{_defe -=_gbaa ;_edf +=_gbaa ;_gbaa =0;};_eead =_defe +_edf -_bbca .Width ;if _eead > 0{_edf -=_eead ;};_eegd =_gbaa +_edf -_dcfg .Width ;if _eegd > 0{_edf -=_eegd ;};if _bcea < 0{_bec -=_bcea ;
_fbfbg +=_bcea ;_bcea =0;};if _bec < 0{_bcea -=_bec ;_fbfbg +=_bec ;_bec =0;};_cafcbg =_bcea +_fbfbg -_bbca .Height ;if _cafcbg > 0{_fbfbg -=_cafcbg ;};_cede =_bec +_fbfbg -_dcfg .Height ;if _cede > 0{_fbfbg -=_cede ;};if _edf <=0||_fbfbg <=0{return nil ;
};var _abab error ;switch {case _defe &7==0&&_gbaa &7==0:_abab =_becg (_bbca ,_defe ,_bcea ,_edf ,_fbfbg ,_ccfe ,_dcfg ,_gbaa ,_bec );case _defe &7==_gbaa &7:_abab =_cada (_bbca ,_defe ,_bcea ,_edf ,_fbfbg ,_ccfe ,_dcfg ,_gbaa ,_bec );default:_abab =_cfdb (_bbca ,_defe ,_bcea ,_edf ,_fbfbg ,_ccfe ,_dcfg ,_gbaa ,_bec );
};if _abab !=nil {return _abab ;};return nil ;};func _aee (_eecf _c .Image )(Image ,error ){if _cbfe ,_gbd :=_eecf .(*Monochrome );_gbd {return _cbfe ,nil ;};_fcb :=_eecf .Bounds ();var _cafc Gray ;switch _gfb :=_eecf .(type ){case Gray :_cafc =_gfb ;case NRGBA :_cafc =&Gray8 {ImageBase :NewImageBase (_fcb .Max .X ,_fcb .Max .Y ,8,1,nil ,nil ,nil )};
_cad (_cafc ,_gfb ,_fcb );case nrgba64 :_cafc =&Gray8 {ImageBase :NewImageBase (_fcb .Max .X ,_fcb .Max .Y ,8,1,nil ,nil ,nil )};_bfag (_cafc ,_gfb ,_fcb );default:_ccf ,_dca :=GrayConverter .Convert (_eecf );if _dca !=nil {return nil ,_dca ;};_cafc =_ccf .(Gray );
};_cbbc ,_bbcf :=NewImage (_fcb .Max .X ,_fcb .Max .Y ,1,1,nil ,nil ,nil );if _bbcf !=nil {return nil ,_bbcf ;};_daeg :=_cbbc .(*Monochrome );_dcd :=AutoThresholdTriangle (GrayHistogram (_cafc ));for _aegd :=0;_aegd < _fcb .Max .X ;_aegd ++{for _eebe :=0;
_eebe < _fcb .Max .Y ;_eebe ++{_dgd :=_ffec (_cafc .GrayAt (_aegd ,_eebe ),monochromeModel (_dcd ));_daeg .SetGray (_aegd ,_eebe ,_dgd );};};return _cbbc ,nil ;};func (_gacff *NRGBA64 )Bounds ()_c .Rectangle {return _c .Rectangle {Max :_c .Point {X :_gacff .Width ,Y :_gacff .Height }};
};func GetConverter (bitsPerComponent ,colorComponents int )(ColorConverter ,error ){switch colorComponents {case 1:switch bitsPerComponent {case 1:return MonochromeConverter ,nil ;case 2:return Gray2Converter ,nil ;case 4:return Gray4Converter ,nil ;case 8:return GrayConverter ,nil ;
case 16:return Gray16Converter ,nil ;};case 3:switch bitsPerComponent {case 4:return NRGBA16Converter ,nil ;case 8:return NRGBAConverter ,nil ;case 16:return NRGBA64Converter ,nil ;};case 4:return CMYKConverter ,nil ;};return nil ,_cc .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0043o\u006e\u0076\u0065\u0072\u0074\u0065\u0072\u0020\u0070\u0061\u0072\u0061\u006d\u0065t\u0065\u0072\u0073\u002e\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003a\u0020\u0025\u0064\u002c\u0020\u0043\u006f\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006et\u0073\u003a \u0025\u0064",bitsPerComponent ,colorComponents );
};func ColorAtGray2BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_d .Gray ,error ){_aaae :=y *bytesPerLine +x >>2;if _aaae >=len (data ){return _d .Gray {},_cc .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_dbcd :=data [_aaae ]>>uint (6-(x &3)*2)&3;if len (decode )==2{_dbcd =uint8 (uint32 (LinearInterpolate (float64 (_dbcd ),0,3.0,decode [0],decode [1]))&3);};return _d .Gray {Y :_dbcd *85},nil ;};func (_adag *Gray16 )Copy ()Image {return &Gray16 {ImageBase :_adag .copy ()}};
func (_aeabf *ImageBase )setEightBytes (_aadg int ,_agafe uint64 )error {_baec :=_aeabf .BytesPerLine -(_aadg %_aeabf .BytesPerLine );if _aeabf .BytesPerLine !=_aeabf .Width >>3{_baec --;};if _baec >=8{return _aeabf .setEightFullBytes (_aadg ,_agafe );
};return _aeabf .setEightPartlyBytes (_aadg ,_baec ,_agafe );};func (_bdbg *Monochrome )Base ()*ImageBase {return &_bdbg .ImageBase };func _ffec (_fec _d .Gray ,_dfbc monochromeModel )_d .Gray {if _fec .Y > uint8 (_dfbc ){return _d .Gray {Y :_gf .MaxUint8 };
};return _d .Gray {};};func _eafg (_aeb RGBA ,_gcgce Gray ,_fdba _c .Rectangle ){for _cdaa :=0;_cdaa < _fdba .Max .X ;_cdaa ++{for _gdeb :=0;_gdeb < _fdba .Max .Y ;_gdeb ++{_fefc :=_fbc (_aeb .RGBAAt (_cdaa ,_gdeb ));_gcgce .SetGray (_cdaa ,_gdeb ,_fefc );
};};};func (_bcgfb *Monochrome )InverseData ()error {return _bcgfb .RasterOperation (0,0,_bcgfb .Width ,_bcgfb .Height ,PixNotDst ,nil ,0,0);};func FromGoImage (i _c .Image )(Image ,error ){switch _efde :=i .(type ){case Image :return _efde .Copy (),nil ;
case Gray :return GrayConverter .Convert (i );case *_c .Gray16 :return Gray16Converter .Convert (i );case CMYK :return CMYKConverter .Convert (i );case *_c .NRGBA64 :return NRGBA64Converter .Convert (i );default:return NRGBAConverter .Convert (i );};};
var ErrInvalidImage =_g .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
func (_cfdc *Gray2 )SetGray (x ,y int ,gray _d .Gray ){_ffcg :=_gaaa (gray );_fbd :=y *_cfdc .BytesPerLine ;_cade :=_fbd +(x >>2);if _cade >=len (_cfdc .Data ){return ;};_gebd :=_ffcg .Y >>6;_cfdc .Data [_cade ]=(_cfdc .Data [_cade ]&(^(0xc0>>uint (2*((x )&3)))))|(_gebd <<uint (6-2*(x &3)));
};var _ NRGBA =&NRGBA16 {};func _fgec (_bgag _d .Color )_d .Color {_geae :=_d .NRGBAModel .Convert (_bgag ).(_d .NRGBA );return _ddfe (_geae );};type Gray2 struct{ImageBase };func (_gdae *NRGBA32 )Base ()*ImageBase {return &_gdae .ImageBase };func (_edcf *RGBA32 )Set (x ,y int ,c _d .Color ){_dbfb :=y *_edcf .Width +x ;
_adgc :=3*_dbfb ;if _adgc +2>=len (_edcf .Data ){return ;};_dcdab :=_d .RGBAModel .Convert (c ).(_d .RGBA );_edcf .setRGBA (_dbfb ,_dcdab );};func (_bfgc *RGBA32 )Base ()*ImageBase {return &_bfgc .ImageBase };type RasterOperator int ;func (_feaba *Monochrome )RasterOperation (dx ,dy ,dw ,dh int ,op RasterOperator ,src *Monochrome ,sx ,sy int )error {return _daca (_feaba ,dx ,dy ,dw ,dh ,op ,src ,sx ,sy );
};func (_ecc *Gray4 )setGray (_gecd int ,_cgcb int ,_acae _d .Gray ){_cdfg :=_cgcb *_ecc .BytesPerLine ;_fcd :=_cdfg +(_gecd >>1);if _fcd >=len (_ecc .Data ){return ;};_ceb :=_acae .Y >>4;_ecc .Data [_fcd ]=(_ecc .Data [_fcd ]&(^(0xf0>>uint (4*(_gecd &1)))))|(_ceb <<uint (4-4*(_gecd &1)));
};func (_efda *Monochrome )clearBit (_degc ,_fcaf int ){_efda .Data [_degc ]&=^(0x80>>uint (_fcaf &7))};func (_ace *Monochrome )Copy ()Image {return &Monochrome {ImageBase :_ace .ImageBase .copy (),ModelThreshold :_ace .ModelThreshold };};var _ RGBA =&RGBA32 {};
func (_cabfg *Gray8 )ColorModel ()_d .Model {return _d .GrayModel };func _cb (_bfe *Monochrome ,_bff int ,_aa []uint )(*Monochrome ,error ){_ga :=_bff *_bfe .Width ;_bc :=_bff *_bfe .Height ;_ca :=_dgb (_ga ,_bc );for _ea ,_abe :=range _aa {var _eg error ;
switch _abe {case 2:_eg =_df (_ca ,_bfe );case 4:_eg =_egb (_ca ,_bfe );case 8:_eg =_ee (_ca ,_bfe );};if _eg !=nil {return nil ,_eg ;};if _ea !=len (_aa )-1{_bfe =_ca .copy ();};};return _ca ,nil ;};func (_gacd *NRGBA64 )SetNRGBA64 (x ,y int ,c _d .NRGBA64 ){_becgd :=(y *_gacd .Width +x )*2;
_dbfd :=_becgd *3;if _dbfd +5>=len (_gacd .Data ){return ;};_gacd .setNRGBA64 (_dbfd ,c ,_becgd );};func _cbgac (_cfc RGBA ,_dbge NRGBA ,_gdde _c .Rectangle ){for _bebc :=0;_bebc < _gdde .Max .X ;_bebc ++{for _ceee :=0;_ceee < _gdde .Max .Y ;_ceee ++{_gbcba :=_cfc .RGBAAt (_bebc ,_ceee );
_dbge .SetNRGBA (_bebc ,_ceee ,_bcbf (_gbcba ));};};};func (_bba *Monochrome )setGrayBit (_gdfg ,_ggb int ){_bba .Data [_gdfg ]|=0x80>>uint (_ggb &7)};func _abcf (_dad _d .NRGBA )_d .Gray {var _decc _d .NRGBA ;if _dad ==_decc {return _d .Gray {Y :0xff};
};_gacbb ,_agcc ,_deca ,_ :=_dad .RGBA ();_bgd :=(19595*_gacbb +38470*_agcc +7471*_deca +1<<15)>>24;return _d .Gray {Y :uint8 (_bgd )};};func (_ddaf *Monochrome )setBit (_egag ,_eceg int ){_ddaf .Data [_egag +(_eceg >>3)]|=0x80>>uint (_eceg &7);};var _ Image =&Gray4 {};
func (_aed *CMYK32 )Set (x ,y int ,c _d .Color ){_efe :=4*(y *_aed .Width +x );if _efe +3>=len (_aed .Data ){return ;};_gdb :=_d .CMYKModel .Convert (c ).(_d .CMYK );_aed .Data [_efe ]=_gdb .C ;_aed .Data [_efe +1]=_gdb .M ;_aed .Data [_efe +2]=_gdb .Y ;
_aed .Data [_efe +3]=_gdb .K ;};func _bfd (_dcb _c .Image )(Image ,error ){if _ddbf ,_adc :=_dcb .(*Gray16 );_adc {return _ddbf .Copy (),nil ;};_ebag :=_dcb .Bounds ();_eega ,_ddga :=NewImage (_ebag .Max .X ,_ebag .Max .Y ,16,1,nil ,nil ,nil );if _ddga !=nil {return nil ,_ddga ;
};_cbcbe (_dcb ,_eega ,_ebag );return _eega ,nil ;};type Gray4 struct{ImageBase };func (_efgc *Gray4 )ColorAt (x ,y int )(_d .Color ,error ){return ColorAtGray4BPC (x ,y ,_efgc .BytesPerLine ,_efgc .Data ,_efgc .Decode );};func _befbe (_egfd _c .Image )(Image ,error ){if _gged ,_gbgbf :=_egfd .(*RGBA32 );
_gbgbf {return _gged .Copy (),nil ;};_bdcd ,_dbacd ,_gbffc :=_ddbc (_egfd ,1);_aggb :=&RGBA32 {ImageBase :NewImageBase (_bdcd .Max .X ,_bdcd .Max .Y ,8,3,nil ,_gbffc ,nil )};_dggf (_egfd ,_aggb ,_bdcd );if len (_gbffc )!=0&&!_dbacd {if _cgac :=_fbcd (_gbffc ,_aggb );
_cgac !=nil {return nil ,_cgac ;};};return _aggb ,nil ;};func (_afaf *Monochrome )setIndexedBit (_dbf int ){_afaf .Data [(_dbf >>3)]|=0x80>>uint (_dbf &7)};func (_efag *Gray2 )GrayAt (x ,y int )_d .Gray {_deag ,_ :=ColorAtGray2BPC (x ,y ,_efag .BytesPerLine ,_efag .Data ,_efag .Decode );
return _deag ;};func (_gfg *Gray4 )At (x ,y int )_d .Color {_ggbe ,_ :=_gfg .ColorAt (x ,y );return _ggbe };func (_gfceb *NRGBA64 )Copy ()Image {return &NRGBA64 {ImageBase :_gfceb .copy ()}};var (_fefe =_dbb ();_ccd =_dab ();_dc =_dge (););func (_cbcb *Monochrome )ColorAt (x ,y int )(_d .Color ,error ){return ColorAtGray1BPC (x ,y ,_cbcb .BytesPerLine ,_cbcb .Data ,_cbcb .Decode );
};var _ Gray =&Gray4 {};func (_fgca *CMYK32 )At (x ,y int )_d .Color {_cfg ,_ :=_fgca .ColorAt (x ,y );return _cfg };func (_cfeg *NRGBA16 )NRGBAAt (x ,y int )_d .NRGBA {_efgce ,_ :=ColorAtNRGBA16 (x ,y ,_cfeg .Width ,_cfeg .BytesPerLine ,_cfeg .Data ,_cfeg .Alpha ,_cfeg .Decode );
return _efgce ;};func ConverterFunc (converterFunc func (_cbc _c .Image )(Image ,error ))ColorConverter {return colorConverter {_ggd :converterFunc };};func (_adff *NRGBA32 )SetNRGBA (x ,y int ,c _d .NRGBA ){_feef :=y *_adff .Width +x ;_gdba :=3*_feef ;
if _gdba +2>=len (_adff .Data ){return ;};_adff .setRGBA (_feef ,c );};func ImgToGray (i _c .Image )*_c .Gray {if _ffg ,_cgfc :=i .(*_c .Gray );_cgfc {return _ffg ;};_degcd :=i .Bounds ();_abcac :=_c .NewGray (_degcd );for _begce :=0;_begce < _degcd .Max .X ;
_begce ++{for _ddegb :=0;_ddegb < _degcd .Max .Y ;_ddegb ++{_dcfcg :=i .At (_begce ,_ddegb );_abcac .Set (_begce ,_ddegb ,_dcfcg );};};return _abcac ;};func _ceec (_fdeb ,_abeb NRGBA ,_fcba _c .Rectangle ){for _ggbd :=0;_ggbd < _fcba .Max .X ;_ggbd ++{for _cfae :=0;
_cfae < _fcba .Max .Y ;_cfae ++{_abeb .SetNRGBA (_ggbd ,_cfae ,_fdeb .NRGBAAt (_ggbd ,_cfae ));};};};func (_gadgg *Gray8 )At (x ,y int )_d .Color {_cgbd ,_ :=_gadgg .ColorAt (x ,y );return _cgbd };var _ _c .Image =&Gray2 {};func (_gae *Monochrome )ReduceBinary (factor float64 )(*Monochrome ,error ){_faab :=_gafe (uint (factor ));
if !IsPowerOf2 (uint (factor )){_faab ++;};_fdbec :=make ([]int ,_faab );for _ggff :=range _fdbec {_fdbec [_ggff ]=4;};_gebf ,_gbcg :=_caa (_gae ,_fdbec ...);if _gbcg !=nil {return nil ,_gbcg ;};return _gebf ,nil ;};func _feaac (_bfec _d .RGBA )_d .CMYK {_aca ,_gbad ,_deec ,_acdf :=_d .RGBToCMYK (_bfec .R ,_bfec .G ,_bfec .B );
return _d .CMYK {C :_aca ,M :_gbad ,Y :_deec ,K :_acdf };};func (_befb *NRGBA16 )ColorAt (x ,y int )(_d .Color ,error ){return ColorAtNRGBA16 (x ,y ,_befb .Width ,_befb .BytesPerLine ,_befb .Data ,_befb .Alpha ,_befb .Decode );};var _ Image =&NRGBA64 {};
func _ddbc (_ceba _c .Image ,_ecaeb int )(_c .Rectangle ,bool ,[]byte ){_ecfb :=_ceba .Bounds ();var (_fefg bool ;_afbb []byte ;);switch _ceae :=_ceba .(type ){case SMasker :_fefg =_ceae .HasAlpha ();case NRGBA ,RGBA ,*_c .RGBA64 ,nrgba64 ,*_c .NYCbCrA :_afbb =make ([]byte ,_ecfb .Max .X *_ecfb .Max .Y *_ecaeb );
case *_c .Paletted :var _baff bool ;for _ ,_geab :=range _ceae .Palette {_eage ,_ecedb ,_gfba ,_gfga :=_geab .RGBA ();if _eage ==0&&_ecedb ==0&&_gfba ==0&&_gfga !=0{_baff =true ;break ;};};if _baff {_afbb =make ([]byte ,_ecfb .Max .X *_ecfb .Max .Y *_ecaeb );
};};return _ecfb ,_fefg ,_afbb ;};func _bceb (_cccge _d .Gray )_d .Gray {_cccge .Y >>=4;_cccge .Y |=_cccge .Y <<4;return _cccge };func _dbcb (_gebe _d .NRGBA64 )_d .RGBA {_acb ,_bdbc ,_daaf ,_gbffe :=_gebe .RGBA ();return _d .RGBA {R :uint8 (_acb >>8),G :uint8 (_bdbc >>8),B :uint8 (_daaf >>8),A :uint8 (_gbffe >>8)};
};func ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine int ,data []byte ,decode []float64 )(_d .Color ,error ){switch bitsPerColor {case 1:return ColorAtGray1BPC (x ,y ,bytesPerLine ,data ,decode );case 2:return ColorAtGray2BPC (x ,y ,bytesPerLine ,data ,decode );
case 4:return ColorAtGray4BPC (x ,y ,bytesPerLine ,data ,decode );case 8:return ColorAtGray8BPC (x ,y ,bytesPerLine ,data ,decode );case 16:return ColorAtGray16BPC (x ,y ,bytesPerLine ,data ,decode );default:return nil ,_cc .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0067\u0072\u0061\u0079\u0020\u0073c\u0061\u006c\u0065\u0020\u0062\u0069\u0074s\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020a\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );
};};func (_dfdb *Gray4 )Bounds ()_c .Rectangle {return _c .Rectangle {Max :_c .Point {X :_dfdb .Width ,Y :_dfdb .Height }};};func (_ccag *CMYK32 )SetCMYK (x ,y int ,c _d .CMYK ){_dacb :=4*(y *_ccag .Width +x );if _dacb +3>=len (_ccag .Data ){return ;};
_ccag .Data [_dacb ]=c .C ;_ccag .Data [_dacb +1]=c .M ;_ccag .Data [_dacb +2]=c .Y ;_ccag .Data [_dacb +3]=c .K ;};func _bfag (_gbe Gray ,_eecb nrgba64 ,_agf _c .Rectangle ){for _eefad :=0;_eefad < _agf .Max .X ;_eefad ++{for _bbdf :=0;_bbdf < _agf .Max .Y ;
_bbdf ++{_abcc :=_bede (_eecb .NRGBA64At (_eefad ,_bbdf ));_gbe .SetGray (_eefad ,_bbdf ,_abcc );};};};func _gaaa (_deecd _d .Gray )_d .Gray {_dffc :=_deecd .Y >>6;_dffc |=_dffc <<2;_deecd .Y =_dffc |_dffc <<4;return _deecd ;};func (_abcae *NRGBA16 )SetNRGBA (x ,y int ,c _d .NRGBA ){_acdg :=y *_abcae .BytesPerLine +x *3/2;
if _acdg +1>=len (_abcae .Data ){return ;};c =_ddfe (c );_abcae .setNRGBA (x ,y ,_acdg ,c );};func (_gefd *Gray8 )Histogram ()(_gcgd [256]int ){for _gfcd :=0;_gfcd < len (_gefd .Data );_gfcd ++{_gcgd [_gefd .Data [_gfcd ]]++;};return _gcgd ;};func BytesPerLine (width ,bitsPerComponent ,colorComponents int )int {return ((width *bitsPerComponent )*colorComponents +7)>>3;
};func _ee (_ce ,_gge *Monochrome )(_ff error ){_aae :=_gge .BytesPerLine ;_bdd :=_ce .BytesPerLine ;var _bdg ,_fff ,_bcg ,_bcgb ,_bg int ;for _bcg =0;_bcg < _gge .Height ;_bcg ++{_bdg =_bcg *_aae ;_fff =8*_bcg *_bdd ;for _bcgb =0;_bcgb < _aae ;_bcgb ++{if _ff =_ce .setEightBytes (_fff +_bcgb *8,_dc [_gge .Data [_bdg +_bcgb ]]);
_ff !=nil {return _ff ;};};for _bg =1;_bg < 8;_bg ++{for _bcgb =0;_bcgb < _bdd ;_bcgb ++{if _ff =_ce .setByte (_fff +_bg *_bdd +_bcgb ,_ce .Data [_fff +_bcgb ]);_ff !=nil {return _ff ;};};};};return nil ;};func (_fefb *RGBA32 )ColorModel ()_d .Model {return _d .NRGBAModel };
type Gray16 struct{ImageBase };func (_fggf *NRGBA16 )Set (x ,y int ,c _d .Color ){_gbgb :=y *_fggf .BytesPerLine +x *3/2;if _gbgb +1>=len (_fggf .Data ){return ;};_bebf :=NRGBA16Model .Convert (c ).(_d .NRGBA );_fggf .setNRGBA (x ,y ,_gbgb ,_bebf );};func (_aag *CMYK32 )Copy ()Image {return &CMYK32 {ImageBase :_aag .copy ()}};
func _cfdb (_gbee *Monochrome ,_bfda ,_ggffg ,_aeff ,_debb int ,_gdcf RasterOperator ,_acfg *Monochrome ,_agb ,_egfb int )error {var (_aaf bool ;_ggbf bool ;_bag byte ;_beeb int ;_abdea int ;_gadd int ;_debf int ;_beda bool ;_egaeb int ;_dacg int ;_fgef int ;
_bdedb bool ;_dggdc byte ;_dfgc int ;_bfde int ;_edfg int ;_eabb byte ;_fde int ;_fggd int ;_bagf uint ;_fbdf uint ;_gcceg byte ;_eeef shift ;_fdde bool ;_dffd bool ;_gafd ,_gecbf int ;);if _agb &7!=0{_fggd =8-(_agb &7);};if _bfda &7!=0{_abdea =8-(_bfda &7);
};if _fggd ==0&&_abdea ==0{_gcceg =_ggba [0];}else {if _abdea > _fggd {_bagf =uint (_abdea -_fggd );}else {_bagf =uint (8-(_fggd -_abdea ));};_fbdf =8-_bagf ;_gcceg =_ggba [_bagf ];};if (_bfda &7)!=0{_aaf =true ;_beeb =8-(_bfda &7);_bag =_ggba [_beeb ];
_gadd =_gbee .BytesPerLine *_ggffg +(_bfda >>3);_debf =_acfg .BytesPerLine *_egfb +(_agb >>3);_fde =8-(_agb &7);if _beeb > _fde {_eeef =_gegg ;if _aeff >=_fggd {_fdde =true ;};}else {_eeef =_fegc ;};};if _aeff < _beeb {_ggbf =true ;_bag &=_egca [8-_beeb +_aeff ];
};if !_ggbf {_egaeb =(_aeff -_beeb )>>3;if _egaeb !=0{_beda =true ;_dacg =_gbee .BytesPerLine *_ggffg +((_bfda +_abdea )>>3);_fgef =_acfg .BytesPerLine *_egfb +((_agb +_abdea )>>3);};};_dfgc =(_bfda +_aeff )&7;if !(_ggbf ||_dfgc ==0){_bdedb =true ;_dggdc =_egca [_dfgc ];
_bfde =_gbee .BytesPerLine *_ggffg +((_bfda +_abdea )>>3)+_egaeb ;_edfg =_acfg .BytesPerLine *_egfb +((_agb +_abdea )>>3)+_egaeb ;if _dfgc > int (_fbdf ){_dffd =true ;};};switch _gdcf {case PixSrc :if _aaf {for _gafd =0;_gafd < _debb ;_gafd ++{if _eeef ==_gegg {_eabb =_acfg .Data [_debf ]<<_bagf ;
if _fdde {_eabb =_bbff (_eabb ,_acfg .Data [_debf +1]>>_fbdf ,_gcceg );};}else {_eabb =_acfg .Data [_debf ]>>_fbdf ;};_gbee .Data [_gadd ]=_bbff (_gbee .Data [_gadd ],_eabb ,_bag );_gadd +=_gbee .BytesPerLine ;_debf +=_acfg .BytesPerLine ;};};if _beda {for _gafd =0;
_gafd < _debb ;_gafd ++{for _gecbf =0;_gecbf < _egaeb ;_gecbf ++{_eabb =_bbff (_acfg .Data [_fgef +_gecbf ]<<_bagf ,_acfg .Data [_fgef +_gecbf +1]>>_fbdf ,_gcceg );_gbee .Data [_dacg +_gecbf ]=_eabb ;};_dacg +=_gbee .BytesPerLine ;_fgef +=_acfg .BytesPerLine ;
};};if _bdedb {for _gafd =0;_gafd < _debb ;_gafd ++{_eabb =_acfg .Data [_edfg ]<<_bagf ;if _dffd {_eabb =_bbff (_eabb ,_acfg .Data [_edfg +1]>>_fbdf ,_gcceg );};_gbee .Data [_bfde ]=_bbff (_gbee .Data [_bfde ],_eabb ,_dggdc );_bfde +=_gbee .BytesPerLine ;
_edfg +=_acfg .BytesPerLine ;};};case PixNotSrc :if _aaf {for _gafd =0;_gafd < _debb ;_gafd ++{if _eeef ==_gegg {_eabb =_acfg .Data [_debf ]<<_bagf ;if _fdde {_eabb =_bbff (_eabb ,_acfg .Data [_debf +1]>>_fbdf ,_gcceg );};}else {_eabb =_acfg .Data [_debf ]>>_fbdf ;
};_gbee .Data [_gadd ]=_bbff (_gbee .Data [_gadd ],^_eabb ,_bag );_gadd +=_gbee .BytesPerLine ;_debf +=_acfg .BytesPerLine ;};};if _beda {for _gafd =0;_gafd < _debb ;_gafd ++{for _gecbf =0;_gecbf < _egaeb ;_gecbf ++{_eabb =_bbff (_acfg .Data [_fgef +_gecbf ]<<_bagf ,_acfg .Data [_fgef +_gecbf +1]>>_fbdf ,_gcceg );
_gbee .Data [_dacg +_gecbf ]=^_eabb ;};_dacg +=_gbee .BytesPerLine ;_fgef +=_acfg .BytesPerLine ;};};if _bdedb {for _gafd =0;_gafd < _debb ;_gafd ++{_eabb =_acfg .Data [_edfg ]<<_bagf ;if _dffd {_eabb =_bbff (_eabb ,_acfg .Data [_edfg +1]>>_fbdf ,_gcceg );
};_gbee .Data [_bfde ]=_bbff (_gbee .Data [_bfde ],^_eabb ,_dggdc );_bfde +=_gbee .BytesPerLine ;_edfg +=_acfg .BytesPerLine ;};};case PixSrcOrDst :if _aaf {for _gafd =0;_gafd < _debb ;_gafd ++{if _eeef ==_gegg {_eabb =_acfg .Data [_debf ]<<_bagf ;if _fdde {_eabb =_bbff (_eabb ,_acfg .Data [_debf +1]>>_fbdf ,_gcceg );
};}else {_eabb =_acfg .Data [_debf ]>>_fbdf ;};_gbee .Data [_gadd ]=_bbff (_gbee .Data [_gadd ],_eabb |_gbee .Data [_gadd ],_bag );_gadd +=_gbee .BytesPerLine ;_debf +=_acfg .BytesPerLine ;};};if _beda {for _gafd =0;_gafd < _debb ;_gafd ++{for _gecbf =0;
_gecbf < _egaeb ;_gecbf ++{_eabb =_bbff (_acfg .Data [_fgef +_gecbf ]<<_bagf ,_acfg .Data [_fgef +_gecbf +1]>>_fbdf ,_gcceg );_gbee .Data [_dacg +_gecbf ]|=_eabb ;};_dacg +=_gbee .BytesPerLine ;_fgef +=_acfg .BytesPerLine ;};};if _bdedb {for _gafd =0;_gafd < _debb ;
_gafd ++{_eabb =_acfg .Data [_edfg ]<<_bagf ;if _dffd {_eabb =_bbff (_eabb ,_acfg .Data [_edfg +1]>>_fbdf ,_gcceg );};_gbee .Data [_bfde ]=_bbff (_gbee .Data [_bfde ],_eabb |_gbee .Data [_bfde ],_dggdc );_bfde +=_gbee .BytesPerLine ;_edfg +=_acfg .BytesPerLine ;
};};case PixSrcAndDst :if _aaf {for _gafd =0;_gafd < _debb ;_gafd ++{if _eeef ==_gegg {_eabb =_acfg .Data [_debf ]<<_bagf ;if _fdde {_eabb =_bbff (_eabb ,_acfg .Data [_debf +1]>>_fbdf ,_gcceg );};}else {_eabb =_acfg .Data [_debf ]>>_fbdf ;};_gbee .Data [_gadd ]=_bbff (_gbee .Data [_gadd ],_eabb &_gbee .Data [_gadd ],_bag );
_gadd +=_gbee .BytesPerLine ;_debf +=_acfg .BytesPerLine ;};};if _beda {for _gafd =0;_gafd < _debb ;_gafd ++{for _gecbf =0;_gecbf < _egaeb ;_gecbf ++{_eabb =_bbff (_acfg .Data [_fgef +_gecbf ]<<_bagf ,_acfg .Data [_fgef +_gecbf +1]>>_fbdf ,_gcceg );_gbee .Data [_dacg +_gecbf ]&=_eabb ;
};_dacg +=_gbee .BytesPerLine ;_fgef +=_acfg .BytesPerLine ;};};if _bdedb {for _gafd =0;_gafd < _debb ;_gafd ++{_eabb =_acfg .Data [_edfg ]<<_bagf ;if _dffd {_eabb =_bbff (_eabb ,_acfg .Data [_edfg +1]>>_fbdf ,_gcceg );};_gbee .Data [_bfde ]=_bbff (_gbee .Data [_bfde ],_eabb &_gbee .Data [_bfde ],_dggdc );
_bfde +=_gbee .BytesPerLine ;_edfg +=_acfg .BytesPerLine ;};};case PixSrcXorDst :if _aaf {for _gafd =0;_gafd < _debb ;_gafd ++{if _eeef ==_gegg {_eabb =_acfg .Data [_debf ]<<_bagf ;if _fdde {_eabb =_bbff (_eabb ,_acfg .Data [_debf +1]>>_fbdf ,_gcceg );
};}else {_eabb =_acfg .Data [_debf ]>>_fbdf ;};_gbee .Data [_gadd ]=_bbff (_gbee .Data [_gadd ],_eabb ^_gbee .Data [_gadd ],_bag );_gadd +=_gbee .BytesPerLine ;_debf +=_acfg .BytesPerLine ;};};if _beda {for _gafd =0;_gafd < _debb ;_gafd ++{for _gecbf =0;
_gecbf < _egaeb ;_gecbf ++{_eabb =_bbff (_acfg .Data [_fgef +_gecbf ]<<_bagf ,_acfg .Data [_fgef +_gecbf +1]>>_fbdf ,_gcceg );_gbee .Data [_dacg +_gecbf ]^=_eabb ;};_dacg +=_gbee .BytesPerLine ;_fgef +=_acfg .BytesPerLine ;};};if _bdedb {for _gafd =0;_gafd < _debb ;
_gafd ++{_eabb =_acfg .Data [_edfg ]<<_bagf ;if _dffd {_eabb =_bbff (_eabb ,_acfg .Data [_edfg +1]>>_fbdf ,_gcceg );};_gbee .Data [_bfde ]=_bbff (_gbee .Data [_bfde ],_eabb ^_gbee .Data [_bfde ],_dggdc );_bfde +=_gbee .BytesPerLine ;_edfg +=_acfg .BytesPerLine ;
};};case PixNotSrcOrDst :if _aaf {for _gafd =0;_gafd < _debb ;_gafd ++{if _eeef ==_gegg {_eabb =_acfg .Data [_debf ]<<_bagf ;if _fdde {_eabb =_bbff (_eabb ,_acfg .Data [_debf +1]>>_fbdf ,_gcceg );};}else {_eabb =_acfg .Data [_debf ]>>_fbdf ;};_gbee .Data [_gadd ]=_bbff (_gbee .Data [_gadd ],^_eabb |_gbee .Data [_gadd ],_bag );
_gadd +=_gbee .BytesPerLine ;_debf +=_acfg .BytesPerLine ;};};if _beda {for _gafd =0;_gafd < _debb ;_gafd ++{for _gecbf =0;_gecbf < _egaeb ;_gecbf ++{_eabb =_bbff (_acfg .Data [_fgef +_gecbf ]<<_bagf ,_acfg .Data [_fgef +_gecbf +1]>>_fbdf ,_gcceg );_gbee .Data [_dacg +_gecbf ]|=^_eabb ;
};_dacg +=_gbee .BytesPerLine ;_fgef +=_acfg .BytesPerLine ;};};if _bdedb {for _gafd =0;_gafd < _debb ;_gafd ++{_eabb =_acfg .Data [_edfg ]<<_bagf ;if _dffd {_eabb =_bbff (_eabb ,_acfg .Data [_edfg +1]>>_fbdf ,_gcceg );};_gbee .Data [_bfde ]=_bbff (_gbee .Data [_bfde ],^_eabb |_gbee .Data [_bfde ],_dggdc );
_bfde +=_gbee .BytesPerLine ;_edfg +=_acfg .BytesPerLine ;};};case PixNotSrcAndDst :if _aaf {for _gafd =0;_gafd < _debb ;_gafd ++{if _eeef ==_gegg {_eabb =_acfg .Data [_debf ]<<_bagf ;if _fdde {_eabb =_bbff (_eabb ,_acfg .Data [_debf +1]>>_fbdf ,_gcceg );
};}else {_eabb =_acfg .Data [_debf ]>>_fbdf ;};_gbee .Data [_gadd ]=_bbff (_gbee .Data [_gadd ],^_eabb &_gbee .Data [_gadd ],_bag );_gadd +=_gbee .BytesPerLine ;_debf +=_acfg .BytesPerLine ;};};if _beda {for _gafd =0;_gafd < _debb ;_gafd ++{for _gecbf =0;
_gecbf < _egaeb ;_gecbf ++{_eabb =_bbff (_acfg .Data [_fgef +_gecbf ]<<_bagf ,_acfg .Data [_fgef +_gecbf +1]>>_fbdf ,_gcceg );_gbee .Data [_dacg +_gecbf ]&=^_eabb ;};_dacg +=_gbee .BytesPerLine ;_fgef +=_acfg .BytesPerLine ;};};if _bdedb {for _gafd =0;
_gafd < _debb ;_gafd ++{_eabb =_acfg .Data [_edfg ]<<_bagf ;if _dffd {_eabb =_bbff (_eabb ,_acfg .Data [_edfg +1]>>_fbdf ,_gcceg );};_gbee .Data [_bfde ]=_bbff (_gbee .Data [_bfde ],^_eabb &_gbee .Data [_bfde ],_dggdc );_bfde +=_gbee .BytesPerLine ;_edfg +=_acfg .BytesPerLine ;
};};case PixSrcOrNotDst :if _aaf {for _gafd =0;_gafd < _debb ;_gafd ++{if _eeef ==_gegg {_eabb =_acfg .Data [_debf ]<<_bagf ;if _fdde {_eabb =_bbff (_eabb ,_acfg .Data [_debf +1]>>_fbdf ,_gcceg );};}else {_eabb =_acfg .Data [_debf ]>>_fbdf ;};_gbee .Data [_gadd ]=_bbff (_gbee .Data [_gadd ],_eabb |^_gbee .Data [_gadd ],_bag );
_gadd +=_gbee .BytesPerLine ;_debf +=_acfg .BytesPerLine ;};};if _beda {for _gafd =0;_gafd < _debb ;_gafd ++{for _gecbf =0;_gecbf < _egaeb ;_gecbf ++{_eabb =_bbff (_acfg .Data [_fgef +_gecbf ]<<_bagf ,_acfg .Data [_fgef +_gecbf +1]>>_fbdf ,_gcceg );_gbee .Data [_dacg +_gecbf ]=_eabb |^_gbee .Data [_dacg +_gecbf ];
};_dacg +=_gbee .BytesPerLine ;_fgef +=_acfg .BytesPerLine ;};};if _bdedb {for _gafd =0;_gafd < _debb ;_gafd ++{_eabb =_acfg .Data [_edfg ]<<_bagf ;if _dffd {_eabb =_bbff (_eabb ,_acfg .Data [_edfg +1]>>_fbdf ,_gcceg );};_gbee .Data [_bfde ]=_bbff (_gbee .Data [_bfde ],_eabb |^_gbee .Data [_bfde ],_dggdc );
_bfde +=_gbee .BytesPerLine ;_edfg +=_acfg .BytesPerLine ;};};case PixSrcAndNotDst :if _aaf {for _gafd =0;_gafd < _debb ;_gafd ++{if _eeef ==_gegg {_eabb =_acfg .Data [_debf ]<<_bagf ;if _fdde {_eabb =_bbff (_eabb ,_acfg .Data [_debf +1]>>_fbdf ,_gcceg );
};}else {_eabb =_acfg .Data [_debf ]>>_fbdf ;};_gbee .Data [_gadd ]=_bbff (_gbee .Data [_gadd ],_eabb &^_gbee .Data [_gadd ],_bag );_gadd +=_gbee .BytesPerLine ;_debf +=_acfg .BytesPerLine ;};};if _beda {for _gafd =0;_gafd < _debb ;_gafd ++{for _gecbf =0;
_gecbf < _egaeb ;_gecbf ++{_eabb =_bbff (_acfg .Data [_fgef +_gecbf ]<<_bagf ,_acfg .Data [_fgef +_gecbf +1]>>_fbdf ,_gcceg );_gbee .Data [_dacg +_gecbf ]=_eabb &^_gbee .Data [_dacg +_gecbf ];};_dacg +=_gbee .BytesPerLine ;_fgef +=_acfg .BytesPerLine ;
};};if _bdedb {for _gafd =0;_gafd < _debb ;_gafd ++{_eabb =_acfg .Data [_edfg ]<<_bagf ;if _dffd {_eabb =_bbff (_eabb ,_acfg .Data [_edfg +1]>>_fbdf ,_gcceg );};_gbee .Data [_bfde ]=_bbff (_gbee .Data [_bfde ],_eabb &^_gbee .Data [_bfde ],_dggdc );_bfde +=_gbee .BytesPerLine ;
_edfg +=_acfg .BytesPerLine ;};};case PixNotPixSrcOrDst :if _aaf {for _gafd =0;_gafd < _debb ;_gafd ++{if _eeef ==_gegg {_eabb =_acfg .Data [_debf ]<<_bagf ;if _fdde {_eabb =_bbff (_eabb ,_acfg .Data [_debf +1]>>_fbdf ,_gcceg );};}else {_eabb =_acfg .Data [_debf ]>>_fbdf ;
};_gbee .Data [_gadd ]=_bbff (_gbee .Data [_gadd ],^(_eabb |_gbee .Data [_gadd ]),_bag );_gadd +=_gbee .BytesPerLine ;_debf +=_acfg .BytesPerLine ;};};if _beda {for _gafd =0;_gafd < _debb ;_gafd ++{for _gecbf =0;_gecbf < _egaeb ;_gecbf ++{_eabb =_bbff (_acfg .Data [_fgef +_gecbf ]<<_bagf ,_acfg .Data [_fgef +_gecbf +1]>>_fbdf ,_gcceg );
_gbee .Data [_dacg +_gecbf ]=^(_eabb |_gbee .Data [_dacg +_gecbf ]);};_dacg +=_gbee .BytesPerLine ;_fgef +=_acfg .BytesPerLine ;};};if _bdedb {for _gafd =0;_gafd < _debb ;_gafd ++{_eabb =_acfg .Data [_edfg ]<<_bagf ;if _dffd {_eabb =_bbff (_eabb ,_acfg .Data [_edfg +1]>>_fbdf ,_gcceg );
};_gbee .Data [_bfde ]=_bbff (_gbee .Data [_bfde ],^(_eabb |_gbee .Data [_bfde ]),_dggdc );_bfde +=_gbee .BytesPerLine ;_edfg +=_acfg .BytesPerLine ;};};case PixNotPixSrcAndDst :if _aaf {for _gafd =0;_gafd < _debb ;_gafd ++{if _eeef ==_gegg {_eabb =_acfg .Data [_debf ]<<_bagf ;
if _fdde {_eabb =_bbff (_eabb ,_acfg .Data [_debf +1]>>_fbdf ,_gcceg );};}else {_eabb =_acfg .Data [_debf ]>>_fbdf ;};_gbee .Data [_gadd ]=_bbff (_gbee .Data [_gadd ],^(_eabb &_gbee .Data [_gadd ]),_bag );_gadd +=_gbee .BytesPerLine ;_debf +=_acfg .BytesPerLine ;
};};if _beda {for _gafd =0;_gafd < _debb ;_gafd ++{for _gecbf =0;_gecbf < _egaeb ;_gecbf ++{_eabb =_bbff (_acfg .Data [_fgef +_gecbf ]<<_bagf ,_acfg .Data [_fgef +_gecbf +1]>>_fbdf ,_gcceg );_gbee .Data [_dacg +_gecbf ]=^(_eabb &_gbee .Data [_dacg +_gecbf ]);
};_dacg +=_gbee .BytesPerLine ;_fgef +=_acfg .BytesPerLine ;};};if _bdedb {for _gafd =0;_gafd < _debb ;_gafd ++{_eabb =_acfg .Data [_edfg ]<<_bagf ;if _dffd {_eabb =_bbff (_eabb ,_acfg .Data [_edfg +1]>>_fbdf ,_gcceg );};_gbee .Data [_bfde ]=_bbff (_gbee .Data [_bfde ],^(_eabb &_gbee .Data [_bfde ]),_dggdc );
_bfde +=_gbee .BytesPerLine ;_edfg +=_acfg .BytesPerLine ;};};case PixNotPixSrcXorDst :if _aaf {for _gafd =0;_gafd < _debb ;_gafd ++{if _eeef ==_gegg {_eabb =_acfg .Data [_debf ]<<_bagf ;if _fdde {_eabb =_bbff (_eabb ,_acfg .Data [_debf +1]>>_fbdf ,_gcceg );
};}else {_eabb =_acfg .Data [_debf ]>>_fbdf ;};_gbee .Data [_gadd ]=_bbff (_gbee .Data [_gadd ],^(_eabb ^_gbee .Data [_gadd ]),_bag );_gadd +=_gbee .BytesPerLine ;_debf +=_acfg .BytesPerLine ;};};if _beda {for _gafd =0;_gafd < _debb ;_gafd ++{for _gecbf =0;
_gecbf < _egaeb ;_gecbf ++{_eabb =_bbff (_acfg .Data [_fgef +_gecbf ]<<_bagf ,_acfg .Data [_fgef +_gecbf +1]>>_fbdf ,_gcceg );_gbee .Data [_dacg +_gecbf ]=^(_eabb ^_gbee .Data [_dacg +_gecbf ]);};_dacg +=_gbee .BytesPerLine ;_fgef +=_acfg .BytesPerLine ;
};};if _bdedb {for _gafd =0;_gafd < _debb ;_gafd ++{_eabb =_acfg .Data [_edfg ]<<_bagf ;if _dffd {_eabb =_bbff (_eabb ,_acfg .Data [_edfg +1]>>_fbdf ,_gcceg );};_gbee .Data [_bfde ]=_bbff (_gbee .Data [_bfde ],^(_eabb ^_gbee .Data [_bfde ]),_dggdc );_bfde +=_gbee .BytesPerLine ;
_edfg +=_acfg .BytesPerLine ;};};default:_b .Log .Debug ("\u004f\u0070e\u0072\u0061\u0074\u0069\u006f\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006e\u006f\u0074\u0020\u0070\u0065\u0072\u006d\u0069tt\u0065\u0064",_gdcf );return _g .New ("\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065r\u0061\u0074\u0069\u006f\u006e\u0020\u006eo\u0074\u0020\u0070\u0065\u0072\u006d\u0069\u0074\u0074\u0065\u0064");
};return nil ;};func (_cafg *Gray2 )Set (x ,y int ,c _d .Color ){if x >=_cafg .Width ||y >=_cafg .Height {return ;};_gaf :=Gray2Model .Convert (c ).(_d .Gray );_gaee :=y *_cafg .BytesPerLine ;_eaeg :=_gaee +(x >>2);_fged :=_gaf .Y >>6;_cafg .Data [_eaeg ]=(_cafg .Data [_eaeg ]&(^(0xc0>>uint (2*((x )&3)))))|(_fged <<uint (6-2*(x &3)));
};func _dge ()(_gec [256]uint64 ){for _eadd :=0;_eadd < 256;_eadd ++{if _eadd &0x01!=0{_gec [_eadd ]|=0xff;};if _eadd &0x02!=0{_gec [_eadd ]|=0xff00;};if _eadd &0x04!=0{_gec [_eadd ]|=0xff0000;};if _eadd &0x08!=0{_gec [_eadd ]|=0xff000000;};if _eadd &0x10!=0{_gec [_eadd ]|=0xff00000000;
};if _eadd &0x20!=0{_gec [_eadd ]|=0xff0000000000;};if _eadd &0x40!=0{_gec [_eadd ]|=0xff000000000000;};if _eadd &0x80!=0{_gec [_eadd ]|=0xff00000000000000;};};return _gec ;};type ImageBase struct{Width ,Height int ;BitsPerComponent ,ColorComponents int ;
Data ,Alpha []byte ;Decode []float64 ;BytesPerLine int ;};func _cad (_bac Gray ,_feec NRGBA ,_ecdf _c .Rectangle ){for _gcdg :=0;_gcdg < _ecdf .Max .X ;_gcdg ++{for _facb :=0;_facb < _ecdf .Max .Y ;_facb ++{_dbe :=_abcf (_feec .NRGBAAt (_gcdg ,_facb ));
_bac .SetGray (_gcdg ,_facb ,_dbe );};};};func (_gbdeg *Monochrome )Bounds ()_c .Rectangle {return _c .Rectangle {Max :_c .Point {X :_gbdeg .Width ,Y :_gbdeg .Height }};};func (_gcbd *Monochrome )ExpandBinary (factor int )(*Monochrome ,error ){if !IsPowerOf2 (uint (factor )){return nil ,_cc .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0065\u0078\u0070\u0061\u006e\u0064\u0020b\u0069n\u0061\u0072\u0079\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",factor );
};return _gc (_gcbd ,factor );};func _dgbd (_aabb _d .NRGBA64 )_d .NRGBA {return _d .NRGBA {R :uint8 (_aabb .R >>8),G :uint8 (_aabb .G >>8),B :uint8 (_aabb .B >>8),A :uint8 (_aabb .A >>8)};};func _eabe (_ddab ,_abag Gray ,_abb _c .Rectangle ){for _eded :=0;
_eded < _abb .Max .X ;_eded ++{for _ccae :=0;_ccae < _abb .Max .Y ;_ccae ++{_abag .SetGray (_eded ,_ccae ,_ddab .GrayAt (_eded ,_ccae ));};};};func ColorAtGray16BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_d .Gray16 ,error ){_eegb :=(y *bytesPerLine /2+x )*2;
if _eegb +1>=len (data ){return _d .Gray16 {},_cc .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_cdeb :=uint16 (data [_eegb ])<<8|uint16 (data [_eegb +1]);if len (decode )==2{_cdeb =uint16 (uint64 (LinearInterpolate (float64 (_cdeb ),0,65535,decode [0],decode [1])));};return _d .Gray16 {Y :_cdeb },nil ;};func _gdgdg (_cgfb *_c .NYCbCrA ,_abda RGBA ,_dfgbg _c .Rectangle ){for _eada :=0;
_eada < _dfgbg .Max .X ;_eada ++{for _cfge :=0;_cfge < _dfgbg .Max .Y ;_cfge ++{_bbag :=_cgfb .NYCbCrAAt (_eada ,_cfge );_abda .SetRGBA (_eada ,_cfge ,_gaab (_bbag ));};};};func _bagd (_bfaad *Monochrome ,_cee ,_ccg ,_facf ,_efcb int ,_ggbc RasterOperator ){if _cee < 0{_facf +=_cee ;
_cee =0;};_feecaf :=_cee +_facf -_bfaad .Width ;if _feecaf > 0{_facf -=_feecaf ;};if _ccg < 0{_efcb +=_ccg ;_ccg =0;};_cebd :=_ccg +_efcb -_bfaad .Height ;if _cebd > 0{_efcb -=_cebd ;};if _facf <=0||_efcb <=0{return ;};if (_cee &7)==0{_gfdf (_bfaad ,_cee ,_ccg ,_facf ,_efcb ,_ggbc );
}else {_eeae (_bfaad ,_cee ,_ccg ,_facf ,_efcb ,_ggbc );};};func _dbca (_fbga CMYK ,_cdba RGBA ,_ceeg _c .Rectangle ){for _fdded :=0;_fdded < _ceeg .Max .X ;_fdded ++{for _cggfc :=0;_cggfc < _ceeg .Max .Y ;_cggfc ++{_eegaf :=_fbga .CMYKAt (_fdded ,_cggfc );
_cdba .SetRGBA (_fdded ,_cggfc ,_fag (_eegaf ));};};};func (_bbdc *ImageBase )GetAlpha ()[]byte {return _bbdc .Alpha };func NextPowerOf2 (n uint )uint {if IsPowerOf2 (n ){return n ;};return 1<<(_gafe (n )+1);};func (_bbbb *ImageBase )copy ()ImageBase {_bcff :=*_bbbb ;
_bcff .Data =make ([]byte ,len (_bbbb .Data ));copy (_bcff .Data ,_bbbb .Data );return _bcff ;};func _dgff (_aegcg _d .Gray )_d .RGBA {return _d .RGBA {R :_aegcg .Y ,G :_aegcg .Y ,B :_aegcg .Y ,A :0xff}};func (_edeb *ImageBase )setEightPartlyBytes (_eaega ,_dcfc int ,_fgagd uint64 )(_cfag error ){var (_aggg byte ;
_ebg int ;);for _bgcc :=1;_bgcc <=_dcfc ;_bgcc ++{_ebg =64-_bgcc *8;_aggg =byte (_fgagd >>uint (_ebg )&0xff);if _cfag =_edeb .setByte (_eaega +_bgcc -1,_aggg );_cfag !=nil {return _cfag ;};};_dfa :=_edeb .BytesPerLine *8-_edeb .Width ;if _dfa ==0{return nil ;
};_ebg -=8;_aggg =byte (_fgagd >>uint (_ebg )&0xff)<<uint (_dfa );if _cfag =_edeb .setByte (_eaega +_dcfc ,_aggg );_cfag !=nil {return _cfag ;};return nil ;};type Gray8 struct{ImageBase };func (_adfd *Gray16 )ColorAt (x ,y int )(_d .Color ,error ){return ColorAtGray16BPC (x ,y ,_adfd .BytesPerLine ,_adfd .Data ,_adfd .Decode );
};var _ _c .Image =&RGBA32 {};func _daca (_cceg *Monochrome ,_bcfc ,_edeg ,_gdad ,_gggg int ,_bgcg RasterOperator ,_dagc *Monochrome ,_fbbg ,_ccebd int )error {if _cceg ==nil {return _g .New ("\u006e\u0069\u006c\u0020\u0027\u0064\u0065\u0073\u0074\u0027\u0020\u0042i\u0074\u006d\u0061\u0070");
};if _bgcg ==PixDst {return nil ;};switch _bgcg {case PixClr ,PixSet ,PixNotDst :_bagd (_cceg ,_bcfc ,_edeg ,_gdad ,_gggg ,_bgcg );return nil ;};if _dagc ==nil {_b .Log .Debug ("\u0052a\u0073\u0074e\u0072\u004f\u0070\u0065r\u0061\u0074\u0069o\u006e\u0020\u0073\u006f\u0075\u0072\u0063\u0065\u0020bi\u0074\u006d\u0061p\u0020\u0069s\u0020\u006e\u006f\u0074\u0020\u0064e\u0066\u0069n\u0065\u0064");
return _g .New ("\u006e\u0069l\u0020\u0027\u0073r\u0063\u0027\u0020\u0062\u0069\u0074\u006d\u0061\u0070");};if _eeff :=_gbbf (_cceg ,_bcfc ,_edeg ,_gdad ,_gggg ,_bgcg ,_dagc ,_fbbg ,_ccebd );_eeff !=nil {return _eeff ;};return nil ;};func _efdc (_gfcb _d .Color )_d .Color {_bda :=_d .GrayModel .Convert (_gfcb ).(_d .Gray );
return _bceb (_bda );};func ScaleAlphaToMonochrome (data []byte ,width ,height int )([]byte ,error ){_e :=BytesPerLine (width ,8,1);if len (data )< _e *height {return nil ,nil ;};_cce :=&Gray8 {NewImageBase (width ,height ,8,1,data ,nil ,nil )};_bf ,_ab :=MonochromeConverter .Convert (_cce );
if _ab !=nil {return nil ,_ab ;};return _bf .Base ().Data ,nil ;};func (_cafcb *Gray16 )SetGray (x ,y int ,g _d .Gray ){_cac :=(y *_cafcb .BytesPerLine /2+x )*2;if _cac +1>=len (_cafcb .Data ){return ;};_cafcb .Data [_cac ]=g .Y ;_cafcb .Data [_cac +1]=g .Y ;
};func (_cfd *Gray2 )Validate ()error {if len (_cfd .Data )!=_cfd .Height *_cfd .BytesPerLine {return ErrInvalidImage ;};return nil ;};func _gfc (_cgf ,_dgf *Monochrome ,_dgeb []byte ,_cfb int )(_dff error ){var (_gbf ,_bfc ,_ece ,_egbd ,_deg ,_fdd ,_agc ,_feae int ;
_dfgb ,_cff ,_fae ,_aadb uint32 ;_geg ,_ede byte ;_eec uint16 ;);_ade :=make ([]byte ,4);_fga :=make ([]byte ,4);for _ece =0;_ece < _cgf .Height -1;_ece ,_egbd =_ece +2,_egbd +1{_gbf =_ece *_cgf .BytesPerLine ;_bfc =_egbd *_dgf .BytesPerLine ;for _deg ,_fdd =0,0;
_deg < _cfb ;_deg ,_fdd =_deg +4,_fdd +1{for _agc =0;_agc < 4;_agc ++{_feae =_gbf +_deg +_agc ;if _feae <=len (_cgf .Data )-1&&_feae < _gbf +_cgf .BytesPerLine {_ade [_agc ]=_cgf .Data [_feae ];}else {_ade [_agc ]=0x00;};_feae =_gbf +_cgf .BytesPerLine +_deg +_agc ;
if _feae <=len (_cgf .Data )-1&&_feae < _gbf +(2*_cgf .BytesPerLine ){_fga [_agc ]=_cgf .Data [_feae ];}else {_fga [_agc ]=0x00;};};_dfgb =_fe .BigEndian .Uint32 (_ade );_cff =_fe .BigEndian .Uint32 (_fga );_fae =_dfgb &_cff ;_fae |=_fae <<1;_aadb =_dfgb |_cff ;
_aadb &=_aadb <<1;_cff =_fae |_aadb ;_cff &=0xaaaaaaaa;_dfgb =_cff |(_cff <<7);_geg =byte (_dfgb >>24);_ede =byte ((_dfgb >>8)&0xff);_feae =_bfc +_fdd ;if _feae +1==len (_dgf .Data )-1||_feae +1>=_bfc +_dgf .BytesPerLine {if _dff =_dgf .setByte (_feae ,_dgeb [_geg ]);
_dff !=nil {return _cc .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_feae );};}else {_eec =(uint16 (_dgeb [_geg ])<<8)|uint16 (_dgeb [_ede ]);if _dff =_dgf .setTwoBytes (_feae ,_eec );_dff !=nil {return _cc .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_feae );
};_fdd ++;};};};return nil ;};func (_fgge *NRGBA64 )Base ()*ImageBase {return &_fgge .ImageBase };func ColorAtNRGBA64 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_d .NRGBA64 ,error ){_bcecf :=(y *width +x )*2;_gebdc :=_bcecf *3;if _gebdc +5>=len (data ){return _d .NRGBA64 {},_cc .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};const _aacf =0xffff;_effg :=uint16 (_aacf );if alpha !=nil &&len (alpha )> _bcecf +1{_effg =uint16 (alpha [_bcecf ])<<8|uint16 (alpha [_bcecf +1]);};_agbe :=uint16 (data [_gebdc ])<<8|uint16 (data [_gebdc +1]);_gcdf :=uint16 (data [_gebdc +2])<<8|uint16 (data [_gebdc +3]);
_ceef :=uint16 (data [_gebdc +4])<<8|uint16 (data [_gebdc +5]);if len (decode )==6{_agbe =uint16 (uint64 (LinearInterpolate (float64 (_agbe ),0,65535,decode [0],decode [1]))&_aacf );_gcdf =uint16 (uint64 (LinearInterpolate (float64 (_gcdf ),0,65535,decode [2],decode [3]))&_aacf );
_ceef =uint16 (uint64 (LinearInterpolate (float64 (_ceef ),0,65535,decode [4],decode [5]))&_aacf );};return _d .NRGBA64 {R :_agbe ,G :_gcdf ,B :_ceef ,A :_effg },nil ;};func (_bdee *NRGBA16 )Bounds ()_c .Rectangle {return _c .Rectangle {Max :_c .Point {X :_bdee .Width ,Y :_bdee .Height }};
};type colorConverter struct{_ggd func (_bdbb _c .Image )(Image ,error );};func NewImage (width ,height ,bitsPerComponent ,colorComponents int ,data ,alpha []byte ,decode []float64 )(Image ,error ){_debgf :=NewImageBase (width ,height ,bitsPerComponent ,colorComponents ,data ,alpha ,decode );
var _eadff Image ;switch colorComponents {case 1:switch bitsPerComponent {case 1:_eadff =&Monochrome {ImageBase :_debgf ,ModelThreshold :0x0f};case 2:_eadff =&Gray2 {ImageBase :_debgf };case 4:_eadff =&Gray4 {ImageBase :_debgf };case 8:_eadff =&Gray8 {ImageBase :_debgf };
case 16:_eadff =&Gray16 {ImageBase :_debgf };};case 3:switch bitsPerComponent {case 4:_eadff =&NRGBA16 {ImageBase :_debgf };case 8:_eadff =&NRGBA32 {ImageBase :_debgf };case 16:_eadff =&NRGBA64 {ImageBase :_debgf };};case 4:_eadff =&CMYK32 {ImageBase :_debgf };
};if _eadff ==nil {return nil ,ErrInvalidImage ;};return _eadff ,nil ;};type ColorConverter interface{Convert (_fdcf _c .Image )(Image ,error );};func IsPowerOf2 (n uint )bool {return n > 0&&(n &(n -1))==0};func (_afd *NRGBA16 )Base ()*ImageBase {return &_afd .ImageBase };
var _ Gray =&Gray16 {};func _gc (_de *Monochrome ,_ec int )(*Monochrome ,error ){if _de ==nil {return nil ,_g .New ("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064");};if _ec ==1{return _de .copy (),nil ;};if !IsPowerOf2 (uint (_ec )){return nil ,_cc .Errorf ("\u0070\u0072\u006fvi\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006ci\u0064 \u0065x\u0070a\u006e\u0064\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_ec );
};_bd :=_beg (_ec );return _cb (_de ,_ec ,_bd );};type shift int ;func (_agcf *NRGBA64 )Validate ()error {if len (_agcf .Data )!=3*2*_agcf .Width *_agcf .Height {return _g .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func _bede (_ebe _d .NRGBA64 )_d .Gray {var _cgbg _d .NRGBA64 ;if _ebe ==_cgbg {return _d .Gray {Y :0xff};};_ddg ,_egcc ,_aec ,_ :=_ebe .RGBA ();_fgd :=(19595*_ddg +38470*_egcc +7471*_aec +1<<15)>>24;return _d .Gray {Y :uint8 (_fgd )};};
func (_bdb *CMYK32 )Validate ()error {if len (_bdb .Data )!=4*_bdb .Width *_bdb .Height {return _g .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func _eeae (_beff *Monochrome ,_dege ,_cebc int ,_ccfea ,_bgde int ,_eefada RasterOperator ){var (_eaad bool ;_gede bool ;_agfc int ;_gbbfa int ;_agbd int ;_bcc int ;_cbabf bool ;_ebeb byte ;);_dabc :=8-(_dege &7);_bgcgf :=_ggba [_dabc ];
_gcbff :=_beff .BytesPerLine *_cebc +(_dege >>3);if _ccfea < _dabc {_eaad =true ;_bgcgf &=_egca [8-_dabc +_ccfea ];};if !_eaad {_agfc =(_ccfea -_dabc )>>3;if _agfc !=0{_gede =true ;_gbbfa =_gcbff +1;};};_agbd =(_dege +_ccfea )&7;if !(_eaad ||_agbd ==0){_cbabf =true ;
_ebeb =_egca [_agbd ];_bcc =_gcbff +1+_agfc ;};var _gfa ,_fcdc int ;switch _eefada {case PixClr :for _gfa =0;_gfa < _bgde ;_gfa ++{_beff .Data [_gcbff ]=_bbff (_beff .Data [_gcbff ],0x0,_bgcgf );_gcbff +=_beff .BytesPerLine ;};if _gede {for _gfa =0;_gfa < _bgde ;
_gfa ++{for _fcdc =0;_fcdc < _agfc ;_fcdc ++{_beff .Data [_gbbfa +_fcdc ]=0x0;};_gbbfa +=_beff .BytesPerLine ;};};if _cbabf {for _gfa =0;_gfa < _bgde ;_gfa ++{_beff .Data [_bcc ]=_bbff (_beff .Data [_bcc ],0x0,_ebeb );_bcc +=_beff .BytesPerLine ;};};case PixSet :for _gfa =0;
_gfa < _bgde ;_gfa ++{_beff .Data [_gcbff ]=_bbff (_beff .Data [_gcbff ],0xff,_bgcgf );_gcbff +=_beff .BytesPerLine ;};if _gede {for _gfa =0;_gfa < _bgde ;_gfa ++{for _fcdc =0;_fcdc < _agfc ;_fcdc ++{_beff .Data [_gbbfa +_fcdc ]=0xff;};_gbbfa +=_beff .BytesPerLine ;
};};if _cbabf {for _gfa =0;_gfa < _bgde ;_gfa ++{_beff .Data [_bcc ]=_bbff (_beff .Data [_bcc ],0xff,_ebeb );_bcc +=_beff .BytesPerLine ;};};case PixNotDst :for _gfa =0;_gfa < _bgde ;_gfa ++{_beff .Data [_gcbff ]=_bbff (_beff .Data [_gcbff ],^_beff .Data [_gcbff ],_bgcgf );
_gcbff +=_beff .BytesPerLine ;};if _gede {for _gfa =0;_gfa < _bgde ;_gfa ++{for _fcdc =0;_fcdc < _agfc ;_fcdc ++{_beff .Data [_gbbfa +_fcdc ]=^(_beff .Data [_gbbfa +_fcdc ]);};_gbbfa +=_beff .BytesPerLine ;};};if _cbabf {for _gfa =0;_gfa < _bgde ;_gfa ++{_beff .Data [_bcc ]=_bbff (_beff .Data [_bcc ],^_beff .Data [_bcc ],_ebeb );
_bcc +=_beff .BytesPerLine ;};};};};func _ccbd (_fagd CMYK ,_aaef NRGBA ,_efbb _c .Rectangle ){for _bedeg :=0;_bedeg < _efbb .Max .X ;_bedeg ++{for _bfee :=0;_bfee < _efbb .Max .Y ;_bfee ++{_fadf :=_fagd .CMYKAt (_bedeg ,_bfee );_aaef .SetNRGBA (_bedeg ,_bfee ,_cbfg (_fadf ));
};};};func (_cgbb *Monochrome )ResolveDecode ()error {if len (_cgbb .Decode )!=2{return nil ;};if _cgbb .Decode [0]==1&&_cgbb .Decode [1]==0{if _gcgc :=_cgbb .InverseData ();_gcgc !=nil {return _gcgc ;};_cgbb .Decode =nil ;};return nil ;};func (_aaaef *ImageBase )Pix ()[]byte {return _aaaef .Data };
type NRGBA interface{NRGBAAt (_dcec ,_bbcb int )_d .NRGBA ;SetNRGBA (_gegb ,_afcg int ,_gfce _d .NRGBA );};func _cada (_ebdd *Monochrome ,_dcaa ,_gedf ,_ggdcb ,_ggaf int ,_bbbf RasterOperator ,_cfef *Monochrome ,_eefc ,_dfcf int )error {var (_ecac bool ;
_ecae bool ;_cdge int ;_age int ;_bcec int ;_bcaa bool ;_cbdf byte ;_gefg int ;_abba int ;_dcaf int ;_abgb ,_ffadd int ;);_abbc :=8-(_dcaa &7);_gaac :=_ggba [_abbc ];_cdcb :=_ebdd .BytesPerLine *_gedf +(_dcaa >>3);_fdfd :=_cfef .BytesPerLine *_dfcf +(_eefc >>3);
if _ggdcb < _abbc {_ecac =true ;_gaac &=_egca [8-_abbc +_ggdcb ];};if !_ecac {_cdge =(_ggdcb -_abbc )>>3;if _cdge > 0{_ecae =true ;_age =_cdcb +1;_bcec =_fdfd +1;};};_gefg =(_dcaa +_ggdcb )&7;if !(_ecac ||_gefg ==0){_bcaa =true ;_cbdf =_egca [_gefg ];_abba =_cdcb +1+_cdge ;
_dcaf =_fdfd +1+_cdge ;};switch _bbbf {case PixSrc :for _abgb =0;_abgb < _ggaf ;_abgb ++{_ebdd .Data [_cdcb ]=_bbff (_ebdd .Data [_cdcb ],_cfef .Data [_fdfd ],_gaac );_cdcb +=_ebdd .BytesPerLine ;_fdfd +=_cfef .BytesPerLine ;};if _ecae {for _abgb =0;_abgb < _ggaf ;
_abgb ++{for _ffadd =0;_ffadd < _cdge ;_ffadd ++{_ebdd .Data [_age +_ffadd ]=_cfef .Data [_bcec +_ffadd ];};_age +=_ebdd .BytesPerLine ;_bcec +=_cfef .BytesPerLine ;};};if _bcaa {for _abgb =0;_abgb < _ggaf ;_abgb ++{_ebdd .Data [_abba ]=_bbff (_ebdd .Data [_abba ],_cfef .Data [_dcaf ],_cbdf );
_abba +=_ebdd .BytesPerLine ;_dcaf +=_cfef .BytesPerLine ;};};case PixNotSrc :for _abgb =0;_abgb < _ggaf ;_abgb ++{_ebdd .Data [_cdcb ]=_bbff (_ebdd .Data [_cdcb ],^_cfef .Data [_fdfd ],_gaac );_cdcb +=_ebdd .BytesPerLine ;_fdfd +=_cfef .BytesPerLine ;
};if _ecae {for _abgb =0;_abgb < _ggaf ;_abgb ++{for _ffadd =0;_ffadd < _cdge ;_ffadd ++{_ebdd .Data [_age +_ffadd ]=^_cfef .Data [_bcec +_ffadd ];};_age +=_ebdd .BytesPerLine ;_bcec +=_cfef .BytesPerLine ;};};if _bcaa {for _abgb =0;_abgb < _ggaf ;_abgb ++{_ebdd .Data [_abba ]=_bbff (_ebdd .Data [_abba ],^_cfef .Data [_dcaf ],_cbdf );
_abba +=_ebdd .BytesPerLine ;_dcaf +=_cfef .BytesPerLine ;};};case PixSrcOrDst :for _abgb =0;_abgb < _ggaf ;_abgb ++{_ebdd .Data [_cdcb ]=_bbff (_ebdd .Data [_cdcb ],_cfef .Data [_fdfd ]|_ebdd .Data [_cdcb ],_gaac );_cdcb +=_ebdd .BytesPerLine ;_fdfd +=_cfef .BytesPerLine ;
};if _ecae {for _abgb =0;_abgb < _ggaf ;_abgb ++{for _ffadd =0;_ffadd < _cdge ;_ffadd ++{_ebdd .Data [_age +_ffadd ]|=_cfef .Data [_bcec +_ffadd ];};_age +=_ebdd .BytesPerLine ;_bcec +=_cfef .BytesPerLine ;};};if _bcaa {for _abgb =0;_abgb < _ggaf ;_abgb ++{_ebdd .Data [_abba ]=_bbff (_ebdd .Data [_abba ],_cfef .Data [_dcaf ]|_ebdd .Data [_abba ],_cbdf );
_abba +=_ebdd .BytesPerLine ;_dcaf +=_cfef .BytesPerLine ;};};case PixSrcAndDst :for _abgb =0;_abgb < _ggaf ;_abgb ++{_ebdd .Data [_cdcb ]=_bbff (_ebdd .Data [_cdcb ],_cfef .Data [_fdfd ]&_ebdd .Data [_cdcb ],_gaac );_cdcb +=_ebdd .BytesPerLine ;_fdfd +=_cfef .BytesPerLine ;
};if _ecae {for _abgb =0;_abgb < _ggaf ;_abgb ++{for _ffadd =0;_ffadd < _cdge ;_ffadd ++{_ebdd .Data [_age +_ffadd ]&=_cfef .Data [_bcec +_ffadd ];};_age +=_ebdd .BytesPerLine ;_bcec +=_cfef .BytesPerLine ;};};if _bcaa {for _abgb =0;_abgb < _ggaf ;_abgb ++{_ebdd .Data [_abba ]=_bbff (_ebdd .Data [_abba ],_cfef .Data [_dcaf ]&_ebdd .Data [_abba ],_cbdf );
_abba +=_ebdd .BytesPerLine ;_dcaf +=_cfef .BytesPerLine ;};};case PixSrcXorDst :for _abgb =0;_abgb < _ggaf ;_abgb ++{_ebdd .Data [_cdcb ]=_bbff (_ebdd .Data [_cdcb ],_cfef .Data [_fdfd ]^_ebdd .Data [_cdcb ],_gaac );_cdcb +=_ebdd .BytesPerLine ;_fdfd +=_cfef .BytesPerLine ;
};if _ecae {for _abgb =0;_abgb < _ggaf ;_abgb ++{for _ffadd =0;_ffadd < _cdge ;_ffadd ++{_ebdd .Data [_age +_ffadd ]^=_cfef .Data [_bcec +_ffadd ];};_age +=_ebdd .BytesPerLine ;_bcec +=_cfef .BytesPerLine ;};};if _bcaa {for _abgb =0;_abgb < _ggaf ;_abgb ++{_ebdd .Data [_abba ]=_bbff (_ebdd .Data [_abba ],_cfef .Data [_dcaf ]^_ebdd .Data [_abba ],_cbdf );
_abba +=_ebdd .BytesPerLine ;_dcaf +=_cfef .BytesPerLine ;};};case PixNotSrcOrDst :for _abgb =0;_abgb < _ggaf ;_abgb ++{_ebdd .Data [_cdcb ]=_bbff (_ebdd .Data [_cdcb ],^(_cfef .Data [_fdfd ])|_ebdd .Data [_cdcb ],_gaac );_cdcb +=_ebdd .BytesPerLine ;_fdfd +=_cfef .BytesPerLine ;
};if _ecae {for _abgb =0;_abgb < _ggaf ;_abgb ++{for _ffadd =0;_ffadd < _cdge ;_ffadd ++{_ebdd .Data [_age +_ffadd ]|=^(_cfef .Data [_bcec +_ffadd ]);};_age +=_ebdd .BytesPerLine ;_bcec +=_cfef .BytesPerLine ;};};if _bcaa {for _abgb =0;_abgb < _ggaf ;_abgb ++{_ebdd .Data [_abba ]=_bbff (_ebdd .Data [_abba ],^(_cfef .Data [_dcaf ])|_ebdd .Data [_abba ],_cbdf );
_abba +=_ebdd .BytesPerLine ;_dcaf +=_cfef .BytesPerLine ;};};case PixNotSrcAndDst :for _abgb =0;_abgb < _ggaf ;_abgb ++{_ebdd .Data [_cdcb ]=_bbff (_ebdd .Data [_cdcb ],^(_cfef .Data [_fdfd ])&_ebdd .Data [_cdcb ],_gaac );_cdcb +=_ebdd .BytesPerLine ;
_fdfd +=_cfef .BytesPerLine ;};if _ecae {for _abgb =0;_abgb < _ggaf ;_abgb ++{for _ffadd =0;_ffadd < _cdge ;_ffadd ++{_ebdd .Data [_age +_ffadd ]&=^_cfef .Data [_bcec +_ffadd ];};_age +=_ebdd .BytesPerLine ;_bcec +=_cfef .BytesPerLine ;};};if _bcaa {for _abgb =0;
_abgb < _ggaf ;_abgb ++{_ebdd .Data [_abba ]=_bbff (_ebdd .Data [_abba ],^(_cfef .Data [_dcaf ])&_ebdd .Data [_abba ],_cbdf );_abba +=_ebdd .BytesPerLine ;_dcaf +=_cfef .BytesPerLine ;};};case PixSrcOrNotDst :for _abgb =0;_abgb < _ggaf ;_abgb ++{_ebdd .Data [_cdcb ]=_bbff (_ebdd .Data [_cdcb ],_cfef .Data [_fdfd ]|^(_ebdd .Data [_cdcb ]),_gaac );
_cdcb +=_ebdd .BytesPerLine ;_fdfd +=_cfef .BytesPerLine ;};if _ecae {for _abgb =0;_abgb < _ggaf ;_abgb ++{for _ffadd =0;_ffadd < _cdge ;_ffadd ++{_ebdd .Data [_age +_ffadd ]=_cfef .Data [_bcec +_ffadd ]|^(_ebdd .Data [_age +_ffadd ]);};_age +=_ebdd .BytesPerLine ;
_bcec +=_cfef .BytesPerLine ;};};if _bcaa {for _abgb =0;_abgb < _ggaf ;_abgb ++{_ebdd .Data [_abba ]=_bbff (_ebdd .Data [_abba ],_cfef .Data [_dcaf ]|^(_ebdd .Data [_abba ]),_cbdf );_abba +=_ebdd .BytesPerLine ;_dcaf +=_cfef .BytesPerLine ;};};case PixSrcAndNotDst :for _abgb =0;
_abgb < _ggaf ;_abgb ++{_ebdd .Data [_cdcb ]=_bbff (_ebdd .Data [_cdcb ],_cfef .Data [_fdfd ]&^(_ebdd .Data [_cdcb ]),_gaac );_cdcb +=_ebdd .BytesPerLine ;_fdfd +=_cfef .BytesPerLine ;};if _ecae {for _abgb =0;_abgb < _ggaf ;_abgb ++{for _ffadd =0;_ffadd < _cdge ;
_ffadd ++{_ebdd .Data [_age +_ffadd ]=_cfef .Data [_bcec +_ffadd ]&^(_ebdd .Data [_age +_ffadd ]);};_age +=_ebdd .BytesPerLine ;_bcec +=_cfef .BytesPerLine ;};};if _bcaa {for _abgb =0;_abgb < _ggaf ;_abgb ++{_ebdd .Data [_abba ]=_bbff (_ebdd .Data [_abba ],_cfef .Data [_dcaf ]&^(_ebdd .Data [_abba ]),_cbdf );
_abba +=_ebdd .BytesPerLine ;_dcaf +=_cfef .BytesPerLine ;};};case PixNotPixSrcOrDst :for _abgb =0;_abgb < _ggaf ;_abgb ++{_ebdd .Data [_cdcb ]=_bbff (_ebdd .Data [_cdcb ],^(_cfef .Data [_fdfd ]|_ebdd .Data [_cdcb ]),_gaac );_cdcb +=_ebdd .BytesPerLine ;
_fdfd +=_cfef .BytesPerLine ;};if _ecae {for _abgb =0;_abgb < _ggaf ;_abgb ++{for _ffadd =0;_ffadd < _cdge ;_ffadd ++{_ebdd .Data [_age +_ffadd ]=^(_cfef .Data [_bcec +_ffadd ]|_ebdd .Data [_age +_ffadd ]);};_age +=_ebdd .BytesPerLine ;_bcec +=_cfef .BytesPerLine ;
};};if _bcaa {for _abgb =0;_abgb < _ggaf ;_abgb ++{_ebdd .Data [_abba ]=_bbff (_ebdd .Data [_abba ],^(_cfef .Data [_dcaf ]|_ebdd .Data [_abba ]),_cbdf );_abba +=_ebdd .BytesPerLine ;_dcaf +=_cfef .BytesPerLine ;};};case PixNotPixSrcAndDst :for _abgb =0;
_abgb < _ggaf ;_abgb ++{_ebdd .Data [_cdcb ]=_bbff (_ebdd .Data [_cdcb ],^(_cfef .Data [_fdfd ]&_ebdd .Data [_cdcb ]),_gaac );_cdcb +=_ebdd .BytesPerLine ;_fdfd +=_cfef .BytesPerLine ;};if _ecae {for _abgb =0;_abgb < _ggaf ;_abgb ++{for _ffadd =0;_ffadd < _cdge ;
_ffadd ++{_ebdd .Data [_age +_ffadd ]=^(_cfef .Data [_bcec +_ffadd ]&_ebdd .Data [_age +_ffadd ]);};_age +=_ebdd .BytesPerLine ;_bcec +=_cfef .BytesPerLine ;};};if _bcaa {for _abgb =0;_abgb < _ggaf ;_abgb ++{_ebdd .Data [_abba ]=_bbff (_ebdd .Data [_abba ],^(_cfef .Data [_dcaf ]&_ebdd .Data [_abba ]),_cbdf );
_abba +=_ebdd .BytesPerLine ;_dcaf +=_cfef .BytesPerLine ;};};case PixNotPixSrcXorDst :for _abgb =0;_abgb < _ggaf ;_abgb ++{_ebdd .Data [_cdcb ]=_bbff (_ebdd .Data [_cdcb ],^(_cfef .Data [_fdfd ]^_ebdd .Data [_cdcb ]),_gaac );_cdcb +=_ebdd .BytesPerLine ;
_fdfd +=_cfef .BytesPerLine ;};if _ecae {for _abgb =0;_abgb < _ggaf ;_abgb ++{for _ffadd =0;_ffadd < _cdge ;_ffadd ++{_ebdd .Data [_age +_ffadd ]=^(_cfef .Data [_bcec +_ffadd ]^_ebdd .Data [_age +_ffadd ]);};_age +=_ebdd .BytesPerLine ;_bcec +=_cfef .BytesPerLine ;
};};if _bcaa {for _abgb =0;_abgb < _ggaf ;_abgb ++{_ebdd .Data [_abba ]=_bbff (_ebdd .Data [_abba ],^(_cfef .Data [_dcaf ]^_ebdd .Data [_abba ]),_cbdf );_abba +=_ebdd .BytesPerLine ;_dcaf +=_cfef .BytesPerLine ;};};default:_b .Log .Debug ("I\u006e\u0076\u0061\u006c\u0069\u0064 \u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070e\u0072\u0061\u0074o\u0072:\u0020\u0025\u0064",_bbbf );
return _g .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072");};return nil ;};func (_bdgg *Gray2 )At (x ,y int )_d .Color {_baab ,_ :=_bdgg .ColorAt (x ,y );return _baab };
func (_aaea *RGBA32 )Bounds ()_c .Rectangle {return _c .Rectangle {Max :_c .Point {X :_aaea .Width ,Y :_aaea .Height }};};func _bfae (_ebb Gray ,_acbg NRGBA ,_cggfe _c .Rectangle ){for _begdd :=0;_begdd < _cggfe .Max .X ;_begdd ++{for _bbbc :=0;_bbbc < _cggfe .Max .Y ;
_bbbc ++{_eeadc :=_ebb .GrayAt (_begdd ,_bbbc );_acbg .SetNRGBA (_begdd ,_bbbc ,_aac (_eeadc ));};};};const (PixSrc RasterOperator =0xc;PixDst RasterOperator =0xa;PixNotSrc RasterOperator =0x3;PixNotDst RasterOperator =0x5;PixClr RasterOperator =0x0;PixSet RasterOperator =0xf;
PixSrcOrDst RasterOperator =0xe;PixSrcAndDst RasterOperator =0x8;PixSrcXorDst RasterOperator =0x6;PixNotSrcOrDst RasterOperator =0xb;PixNotSrcAndDst RasterOperator =0x2;PixSrcOrNotDst RasterOperator =0xd;PixSrcAndNotDst RasterOperator =0x4;PixNotPixSrcOrDst RasterOperator =0x1;
PixNotPixSrcAndDst RasterOperator =0x7;PixNotPixSrcXorDst RasterOperator =0x9;PixPaint =PixSrcOrDst ;PixSubtract =PixNotSrcAndDst ;PixMask =PixSrcAndDst ;);func _gafe (_cceb uint )uint {var _dgdb uint ;for _cceb !=0{_cceb >>=1;_dgdb ++;};return _dgdb -1;
};func _gcbb (_egef _c .Image )(Image ,error ){if _fdbc ,_adeaf :=_egef .(*NRGBA32 );_adeaf {return _fdbc .Copy (),nil ;};_dbab ,_fgagf ,_bfca :=_ddbc (_egef ,1);_eefcc ,_gedc :=NewImage (_dbab .Max .X ,_dbab .Max .Y ,8,3,nil ,_bfca ,nil );if _gedc !=nil {return nil ,_gedc ;
};_dbac (_egef ,_eefcc ,_dbab );if len (_bfca )!=0&&!_fgagf {if _afba :=_fbcd (_bfca ,_eefcc );_afba !=nil {return nil ,_afba ;};};return _eefcc ,nil ;};func _beg (_bb int )[]uint {var _eae []uint ;_fbaf :=_bb ;_abf :=_fbaf /8;if _abf !=0{for _beaf :=0;
_beaf < _abf ;_beaf ++{_eae =append (_eae ,8);};_bcd :=_fbaf %8;_fbaf =0;if _bcd !=0{_fbaf =_bcd ;};};_cf :=_fbaf /4;if _cf !=0{for _cdd :=0;_cdd < _cf ;_cdd ++{_eae =append (_eae ,4);};_fdc :=_fbaf %4;_fbaf =0;if _fdc !=0{_fbaf =_fdc ;};};_caf :=_fbaf /2;
if _caf !=0{for _eef :=0;_eef < _caf ;_eef ++{_eae =append (_eae ,2);};};return _eae ;};func (_aceg *NRGBA64 )ColorModel ()_d .Model {return _d .NRGBA64Model };func _ecfa (_cfda *_c .NYCbCrA ,_eeece NRGBA ,_ecba _c .Rectangle ){for _edae :=0;_edae < _ecba .Max .X ;
_edae ++{for _ebgd :=0;_ebgd < _ecba .Max .Y ;_ebgd ++{_fafe :=_cfda .NYCbCrAAt (_edae ,_ebgd );_eeece .SetNRGBA (_edae ,_ebgd ,_fda (_fafe ));};};};func ColorAtCMYK (x ,y ,width int ,data []byte ,decode []float64 )(_d .CMYK ,error ){_dda :=4*(y *width +x );
if _dda +3>=len (data ){return _d .CMYK {},_cc .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};C :=data [_dda ]&0xff;M :=data [_dda +1]&0xff;Y :=data [_dda +2]&0xff;K :=data [_dda +3]&0xff;if len (decode )==8{C =uint8 (uint32 (LinearInterpolate (float64 (C ),0,255,decode [0],decode [1]))&0xff);M =uint8 (uint32 (LinearInterpolate (float64 (M ),0,255,decode [2],decode [3]))&0xff);
Y =uint8 (uint32 (LinearInterpolate (float64 (Y ),0,255,decode [4],decode [5]))&0xff);K =uint8 (uint32 (LinearInterpolate (float64 (K ),0,255,decode [6],decode [7]))&0xff);};return _d .CMYK {C :C ,M :M ,Y :Y ,K :K },nil ;};func _bbff (_fcc ,_degf ,_cgfd byte )byte {return (_fcc &^(_cgfd ))|(_degf &_cgfd )};
func (_affd *ImageBase )HasAlpha ()bool {if _affd .Alpha ==nil {return false ;};for _eaab :=range _affd .Alpha {if _affd .Alpha [_eaab ]!=0xff{return true ;};};return false ;};func ImgToBinary (i _c .Image ,threshold uint8 )*_c .Gray {switch _gfaa :=i .(type ){case *_c .Gray :if _geee (_gfaa ){return _gfaa ;
};return _cdfb (_gfaa ,threshold );case *_c .Gray16 :return _dagf (_gfaa ,threshold );default:return _cbec (_gfaa ,threshold );};};func ColorAtNRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_d .NRGBA ,error ){_fggdb :=y *width +x ;_deab :=3*_fggdb ;
if _deab +2>=len (data ){return _d .NRGBA {},_cc .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_cbga :=uint8 (0xff);if alpha !=nil &&len (alpha )> _fggdb {_cbga =alpha [_fggdb ];};_abfa ,_ecegd ,_aafa :=data [_deab ],data [_deab +1],data [_deab +2];if len (decode )==6{_abfa =uint8 (uint32 (LinearInterpolate (float64 (_abfa ),0,255,decode [0],decode [1]))&0xff);
_ecegd =uint8 (uint32 (LinearInterpolate (float64 (_ecegd ),0,255,decode [2],decode [3]))&0xff);_aafa =uint8 (uint32 (LinearInterpolate (float64 (_aafa ),0,255,decode [4],decode [5]))&0xff);};return _d .NRGBA {R :_abfa ,G :_ecegd ,B :_aafa ,A :_cbga },nil ;
};func ColorAtGray8BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_d .Gray ,error ){_cagc :=y *bytesPerLine +x ;if _cagc >=len (data ){return _d .Gray {},_cc .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_dbed :=data [_cagc ];if len (decode )==2{_dbed =uint8 (uint32 (LinearInterpolate (float64 (_dbed ),0,255,decode [0],decode [1]))&0xff);};return _d .Gray {Y :_dbed },nil ;};func (_eabd *Gray4 )Set (x ,y int ,c _d .Color ){if x >=_eabd .Width ||y >=_eabd .Height {return ;
};_bddg :=Gray4Model .Convert (c ).(_d .Gray );_eabd .setGray (x ,y ,_bddg );};func _gee (_bdbe NRGBA ,_dgg CMYK ,_debg _c .Rectangle ){for _ffa :=0;_ffa < _debg .Max .X ;_ffa ++{for _baa :=0;_baa < _debg .Max .Y ;_baa ++{_cdf :=_bdbe .NRGBAAt (_ffa ,_baa );
_dgg .SetCMYK (_ffa ,_baa ,_edb (_cdf ));};};};type Histogramer interface{Histogram ()[256]int ;};func _dfdab (_baac uint8 )bool {if _baac ==0||_baac ==255{return true ;};return false ;};func _bgbg (_cfa _d .CMYK )_d .Gray {_gdd ,_ffe ,_bdba :=_d .CMYKToRGB (_cfa .C ,_cfa .M ,_cfa .Y ,_cfa .K );
_bcfe :=(19595*uint32 (_gdd )+38470*uint32 (_ffe )+7471*uint32 (_bdba )+1<<7)>>16;return _d .Gray {Y :uint8 (_bcfe )};};func _becg (_cfbe *Monochrome ,_eaga ,_bafc ,_ceg ,_fcdd int ,_aeaed RasterOperator ,_cgaa *Monochrome ,_gbcb ,_fabf int )error {var (_babd byte ;
_bbf int ;_aaca int ;_dfbb ,_egae int ;_ebgc ,_cedb int ;);_eaffa :=_ceg >>3;_becc :=_ceg &7;if _becc > 0{_babd =_egca [_becc ];};_bbf =_cgaa .BytesPerLine *_fabf +(_gbcb >>3);_aaca =_cfbe .BytesPerLine *_bafc +(_eaga >>3);switch _aeaed {case PixSrc :for _ebgc =0;
_ebgc < _fcdd ;_ebgc ++{_dfbb =_bbf +_ebgc *_cgaa .BytesPerLine ;_egae =_aaca +_ebgc *_cfbe .BytesPerLine ;for _cedb =0;_cedb < _eaffa ;_cedb ++{_cfbe .Data [_egae ]=_cgaa .Data [_dfbb ];_egae ++;_dfbb ++;};if _becc > 0{_cfbe .Data [_egae ]=_bbff (_cfbe .Data [_egae ],_cgaa .Data [_dfbb ],_babd );
};};case PixNotSrc :for _ebgc =0;_ebgc < _fcdd ;_ebgc ++{_dfbb =_bbf +_ebgc *_cgaa .BytesPerLine ;_egae =_aaca +_ebgc *_cfbe .BytesPerLine ;for _cedb =0;_cedb < _eaffa ;_cedb ++{_cfbe .Data [_egae ]=^(_cgaa .Data [_dfbb ]);_egae ++;_dfbb ++;};if _becc > 0{_cfbe .Data [_egae ]=_bbff (_cfbe .Data [_egae ],^_cgaa .Data [_dfbb ],_babd );
};};case PixSrcOrDst :for _ebgc =0;_ebgc < _fcdd ;_ebgc ++{_dfbb =_bbf +_ebgc *_cgaa .BytesPerLine ;_egae =_aaca +_ebgc *_cfbe .BytesPerLine ;for _cedb =0;_cedb < _eaffa ;_cedb ++{_cfbe .Data [_egae ]|=_cgaa .Data [_dfbb ];_egae ++;_dfbb ++;};if _becc > 0{_cfbe .Data [_egae ]=_bbff (_cfbe .Data [_egae ],_cgaa .Data [_dfbb ]|_cfbe .Data [_egae ],_babd );
};};case PixSrcAndDst :for _ebgc =0;_ebgc < _fcdd ;_ebgc ++{_dfbb =_bbf +_ebgc *_cgaa .BytesPerLine ;_egae =_aaca +_ebgc *_cfbe .BytesPerLine ;for _cedb =0;_cedb < _eaffa ;_cedb ++{_cfbe .Data [_egae ]&=_cgaa .Data [_dfbb ];_egae ++;_dfbb ++;};if _becc > 0{_cfbe .Data [_egae ]=_bbff (_cfbe .Data [_egae ],_cgaa .Data [_dfbb ]&_cfbe .Data [_egae ],_babd );
};};case PixSrcXorDst :for _ebgc =0;_ebgc < _fcdd ;_ebgc ++{_dfbb =_bbf +_ebgc *_cgaa .BytesPerLine ;_egae =_aaca +_ebgc *_cfbe .BytesPerLine ;for _cedb =0;_cedb < _eaffa ;_cedb ++{_cfbe .Data [_egae ]^=_cgaa .Data [_dfbb ];_egae ++;_dfbb ++;};if _becc > 0{_cfbe .Data [_egae ]=_bbff (_cfbe .Data [_egae ],_cgaa .Data [_dfbb ]^_cfbe .Data [_egae ],_babd );
};};case PixNotSrcOrDst :for _ebgc =0;_ebgc < _fcdd ;_ebgc ++{_dfbb =_bbf +_ebgc *_cgaa .BytesPerLine ;_egae =_aaca +_ebgc *_cfbe .BytesPerLine ;for _cedb =0;_cedb < _eaffa ;_cedb ++{_cfbe .Data [_egae ]|=^(_cgaa .Data [_dfbb ]);_egae ++;_dfbb ++;};if _becc > 0{_cfbe .Data [_egae ]=_bbff (_cfbe .Data [_egae ],^(_cgaa .Data [_dfbb ])|_cfbe .Data [_egae ],_babd );
};};case PixNotSrcAndDst :for _ebgc =0;_ebgc < _fcdd ;_ebgc ++{_dfbb =_bbf +_ebgc *_cgaa .BytesPerLine ;_egae =_aaca +_ebgc *_cfbe .BytesPerLine ;for _cedb =0;_cedb < _eaffa ;_cedb ++{_cfbe .Data [_egae ]&=^(_cgaa .Data [_dfbb ]);_egae ++;_dfbb ++;};if _becc > 0{_cfbe .Data [_egae ]=_bbff (_cfbe .Data [_egae ],^(_cgaa .Data [_dfbb ])&_cfbe .Data [_egae ],_babd );
};};case PixSrcOrNotDst :for _ebgc =0;_ebgc < _fcdd ;_ebgc ++{_dfbb =_bbf +_ebgc *_cgaa .BytesPerLine ;_egae =_aaca +_ebgc *_cfbe .BytesPerLine ;for _cedb =0;_cedb < _eaffa ;_cedb ++{_cfbe .Data [_egae ]=_cgaa .Data [_dfbb ]|^(_cfbe .Data [_egae ]);_egae ++;
_dfbb ++;};if _becc > 0{_cfbe .Data [_egae ]=_bbff (_cfbe .Data [_egae ],_cgaa .Data [_dfbb ]|^(_cfbe .Data [_egae ]),_babd );};};case PixSrcAndNotDst :for _ebgc =0;_ebgc < _fcdd ;_ebgc ++{_dfbb =_bbf +_ebgc *_cgaa .BytesPerLine ;_egae =_aaca +_ebgc *_cfbe .BytesPerLine ;
for _cedb =0;_cedb < _eaffa ;_cedb ++{_cfbe .Data [_egae ]=_cgaa .Data [_dfbb ]&^(_cfbe .Data [_egae ]);_egae ++;_dfbb ++;};if _becc > 0{_cfbe .Data [_egae ]=_bbff (_cfbe .Data [_egae ],_cgaa .Data [_dfbb ]&^(_cfbe .Data [_egae ]),_babd );};};case PixNotPixSrcOrDst :for _ebgc =0;
_ebgc < _fcdd ;_ebgc ++{_dfbb =_bbf +_ebgc *_cgaa .BytesPerLine ;_egae =_aaca +_ebgc *_cfbe .BytesPerLine ;for _cedb =0;_cedb < _eaffa ;_cedb ++{_cfbe .Data [_egae ]=^(_cgaa .Data [_dfbb ]|_cfbe .Data [_egae ]);_egae ++;_dfbb ++;};if _becc > 0{_cfbe .Data [_egae ]=_bbff (_cfbe .Data [_egae ],^(_cgaa .Data [_dfbb ]|_cfbe .Data [_egae ]),_babd );
};};case PixNotPixSrcAndDst :for _ebgc =0;_ebgc < _fcdd ;_ebgc ++{_dfbb =_bbf +_ebgc *_cgaa .BytesPerLine ;_egae =_aaca +_ebgc *_cfbe .BytesPerLine ;for _cedb =0;_cedb < _eaffa ;_cedb ++{_cfbe .Data [_egae ]=^(_cgaa .Data [_dfbb ]&_cfbe .Data [_egae ]);
_egae ++;_dfbb ++;};if _becc > 0{_cfbe .Data [_egae ]=_bbff (_cfbe .Data [_egae ],^(_cgaa .Data [_dfbb ]&_cfbe .Data [_egae ]),_babd );};};case PixNotPixSrcXorDst :for _ebgc =0;_ebgc < _fcdd ;_ebgc ++{_dfbb =_bbf +_ebgc *_cgaa .BytesPerLine ;_egae =_aaca +_ebgc *_cfbe .BytesPerLine ;
for _cedb =0;_cedb < _eaffa ;_cedb ++{_cfbe .Data [_egae ]=^(_cgaa .Data [_dfbb ]^_cfbe .Data [_egae ]);_egae ++;_dfbb ++;};if _becc > 0{_cfbe .Data [_egae ]=_bbff (_cfbe .Data [_egae ],^(_cgaa .Data [_dfbb ]^_cfbe .Data [_egae ]),_babd );};};default:_b .Log .Debug ("\u0050\u0072ov\u0069\u0064\u0065d\u0020\u0069\u006e\u0076ali\u0064 r\u0061\u0073\u0074\u0065\u0072\u0020\u006fpe\u0072\u0061\u0074\u006f\u0072\u003a\u0020%\u0076",_aeaed );
return _g .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072");};return nil ;};var (MonochromeConverter =ConverterFunc (_aee );Gray2Converter =ConverterFunc (_daaa );Gray4Converter =ConverterFunc (_eacg );
GrayConverter =ConverterFunc (_dbedd );Gray16Converter =ConverterFunc (_bfd );NRGBA16Converter =ConverterFunc (_bbcbb );NRGBAConverter =ConverterFunc (_gcbb );NRGBA64Converter =ConverterFunc (_gbade );RGBAConverter =ConverterFunc (_befbe );CMYKConverter =ConverterFunc (_afcb );
);func (_cedd *RGBA32 )At (x ,y int )_d .Color {_edee ,_ :=_cedd .ColorAt (x ,y );return _edee };func (_ggab *NRGBA32 )Copy ()Image {return &NRGBA32 {ImageBase :_ggab .copy ()}};var _ _c .Image =&NRGBA64 {};func (_gag monochromeModel )Convert (c _d .Color )_d .Color {_egec :=_d .GrayModel .Convert (c ).(_d .Gray );
return _ffec (_egec ,_gag );};func _ggf (_bdf ,_dfg *Monochrome ,_cdda []byte ,_cgb int )(_efg error ){var (_gab ,_afc ,_dce ,_edd ,_bad ,_fca ,_edgc ,_fea int ;_fa ,_feff uint32 ;_def ,_fad byte ;_dfb uint16 ;);_begd :=make ([]byte ,4);_cab :=make ([]byte ,4);
for _dce =0;_dce < _bdf .Height -1;_dce ,_edd =_dce +2,_edd +1{_gab =_dce *_bdf .BytesPerLine ;_afc =_edd *_dfg .BytesPerLine ;for _bad ,_fca =0,0;_bad < _cgb ;_bad ,_fca =_bad +4,_fca +1{for _edgc =0;_edgc < 4;_edgc ++{_fea =_gab +_bad +_edgc ;if _fea <=len (_bdf .Data )-1&&_fea < _gab +_bdf .BytesPerLine {_begd [_edgc ]=_bdf .Data [_fea ];
}else {_begd [_edgc ]=0x00;};_fea =_gab +_bdf .BytesPerLine +_bad +_edgc ;if _fea <=len (_bdf .Data )-1&&_fea < _gab +(2*_bdf .BytesPerLine ){_cab [_edgc ]=_bdf .Data [_fea ];}else {_cab [_edgc ]=0x00;};};_fa =_fe .BigEndian .Uint32 (_begd );_feff =_fe .BigEndian .Uint32 (_cab );
_feff |=_fa ;_feff |=_feff <<1;_feff &=0xaaaaaaaa;_fa =_feff |(_feff <<7);_def =byte (_fa >>24);_fad =byte ((_fa >>8)&0xff);_fea =_afc +_fca ;if _fea +1==len (_dfg .Data )-1||_fea +1>=_afc +_dfg .BytesPerLine {_dfg .Data [_fea ]=_cdda [_def ];}else {_dfb =(uint16 (_cdda [_def ])<<8)|uint16 (_cdda [_fad ]);
if _efg =_dfg .setTwoBytes (_fea ,_dfb );_efg !=nil {return _cc .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_fea );
};_fca ++;};};};return nil ;};func _ddfe (_dceg _d .NRGBA )_d .NRGBA {_dceg .R =_dceg .R >>4|(_dceg .R >>4)<<4;_dceg .G =_dceg .G >>4|(_dceg .G >>4)<<4;_dceg .B =_dceg .B >>4|(_dceg .B >>4)<<4;return _dceg ;};func ColorAtNRGBA16 (x ,y ,width ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_d .NRGBA ,error ){_afde :=y *bytesPerLine +x *3/2;
if _afde +1>=len (data ){return _d .NRGBA {},_feb (x ,y );};const (_faf =0xf;_bdcfe =uint8 (0xff););_ecfc :=_bdcfe ;if alpha !=nil {_bgad :=y *BytesPerLine (width ,4,1);if _bgad < len (alpha ){if x %2==0{_ecfc =(alpha [_bgad ]>>uint (4))&_faf ;}else {_ecfc =alpha [_bgad ]&_faf ;
};_ecfc |=_ecfc <<4;};};var _ffcd ,_fccg ,_ecg uint8 ;if x *3%2==0{_ffcd =(data [_afde ]>>uint (4))&_faf ;_fccg =data [_afde ]&_faf ;_ecg =(data [_afde +1]>>uint (4))&_faf ;}else {_ffcd =data [_afde ]&_faf ;_fccg =(data [_afde +1]>>uint (4))&_faf ;_ecg =data [_afde +1]&_faf ;
};if len (decode )==6{_ffcd =uint8 (uint32 (LinearInterpolate (float64 (_ffcd ),0,15,decode [0],decode [1]))&0xf);_fccg =uint8 (uint32 (LinearInterpolate (float64 (_fccg ),0,15,decode [2],decode [3]))&0xf);_ecg =uint8 (uint32 (LinearInterpolate (float64 (_ecg ),0,15,decode [4],decode [5]))&0xf);
};return _d .NRGBA {R :(_ffcd <<4)|(_ffcd &0xf),G :(_fccg <<4)|(_fccg &0xf),B :(_ecg <<4)|(_ecg &0xf),A :_ecfc },nil ;};func _cdfb (_dcdf *_c .Gray ,_bgce uint8 )*_c .Gray {_cabfgb :=_dcdf .Bounds ();_aeefd :=_c .NewGray (_cabfgb );for _ccdcc :=0;_ccdcc < _cabfgb .Dx ();
_ccdcc ++{for _caec :=0;_caec < _cabfgb .Dy ();_caec ++{_agec :=_dcdf .GrayAt (_ccdcc ,_caec );_aeefd .SetGray (_ccdcc ,_caec ,_d .Gray {Y :_gada (_agec .Y ,_bgce )});};};return _aeefd ;};func _dab ()(_eeg [256]uint32 ){for _bgc :=0;_bgc < 256;_bgc ++{if _bgc &0x01!=0{_eeg [_bgc ]|=0xf;
};if _bgc &0x02!=0{_eeg [_bgc ]|=0xf0;};if _bgc &0x04!=0{_eeg [_bgc ]|=0xf00;};if _bgc &0x08!=0{_eeg [_bgc ]|=0xf000;};if _bgc &0x10!=0{_eeg [_bgc ]|=0xf0000;};if _bgc &0x20!=0{_eeg [_bgc ]|=0xf00000;};if _bgc &0x40!=0{_eeg [_bgc ]|=0xf000000;};if _bgc &0x80!=0{_eeg [_bgc ]|=0xf0000000;
};};return _eeg ;};func (_dccd *Gray16 )Base ()*ImageBase {return &_dccd .ImageBase };func (_bedc *Monochrome )GrayAt (x ,y int )_d .Gray {_efa ,_ :=ColorAtGray1BPC (x ,y ,_bedc .BytesPerLine ,_bedc .Data ,_bedc .Decode );return _efa ;};func _dbedd (_ggc _c .Image )(Image ,error ){if _daae ,_eefe :=_ggc .(*Gray8 );
_eefe {return _daae .Copy (),nil ;};_fgbf :=_ggc .Bounds ();_cae ,_dbg :=NewImage (_fgbf .Max .X ,_fgbf .Max .Y ,8,1,nil ,nil ,nil );if _dbg !=nil {return nil ,_dbg ;};_cbcbe (_ggc ,_cae ,_fgbf );return _cae ,nil ;};type CMYK32 struct{ImageBase };type Gray interface{GrayAt (_gdc ,_bae int )_d .Gray ;
SetGray (_fbff ,_gedg int ,_gbc _d .Gray );};type Monochrome struct{ImageBase ;ModelThreshold uint8 ;};const (_gegg shift =iota ;_fegc ;);func _bdfg (_baaf Gray ,_fdb CMYK ,_eadf _c .Rectangle ){for _cdb :=0;_cdb < _eadf .Max .X ;_cdb ++{for _aagg :=0;
_aagg < _eadf .Max .Y ;_aagg ++{_egbg :=_baaf .GrayAt (_cdb ,_aagg );_fdb .SetCMYK (_cdb ,_aagg ,_debc (_egbg ));};};};var _ _c .Image =&Monochrome {};func _gff ()(_acd []byte ){_acd =make ([]byte ,256);for _fgf :=0;_fgf < 256;_fgf ++{_begb :=byte (_fgf );
_acd [_begb ]=(_begb &0x01)|((_begb &0x04)>>1)|((_begb &0x10)>>2)|((_begb &0x40)>>3)|((_begb &0x02)<<3)|((_begb &0x08)<<2)|((_begb &0x20)<<1)|(_begb &0x80);};return _acd ;};func _aded (){for _ggdf :=0;_ggdf < 256;_ggdf ++{_egf [_ggdf ]=uint8 (_ggdf &0x1)+(uint8 (_ggdf >>1)&0x1)+(uint8 (_ggdf >>2)&0x1)+(uint8 (_ggdf >>3)&0x1)+(uint8 (_ggdf >>4)&0x1)+(uint8 (_ggdf >>5)&0x1)+(uint8 (_ggdf >>6)&0x1)+(uint8 (_ggdf >>7)&0x1);
};};func (_ecde *Gray4 )Copy ()Image {return &Gray4 {ImageBase :_ecde .copy ()}};func (_degd *Gray16 )Set (x ,y int ,c _d .Color ){_bcggc :=(y *_degd .BytesPerLine /2+x )*2;if _bcggc +1>=len (_degd .Data ){return ;};_efcfc :=_d .Gray16Model .Convert (c ).(_d .Gray16 );
_degd .Data [_bcggc ],_degd .Data [_bcggc +1]=uint8 (_efcfc .Y >>8),uint8 (_efcfc .Y &0xff);};func _daaa (_gdga _c .Image )(Image ,error ){if _fabdb ,_agaf :=_gdga .(*Gray2 );_agaf {return _fabdb .Copy (),nil ;};_fbfg :=_gdga .Bounds ();_cfgd ,_abfed :=NewImage (_fbfg .Max .X ,_fbfg .Max .Y ,2,1,nil ,nil ,nil );
if _abfed !=nil {return nil ,_abfed ;};_cbcbe (_gdga ,_cfgd ,_fbfg );return _cfgd ,nil ;};func _debc (_fbf _d .Gray )_d .CMYK {return _d .CMYK {K :0xff-_fbf .Y }};var _ Gray =&Gray8 {};func AutoThresholdTriangle (histogram [256]int )uint8 {var _affda ,_adec ,_cbed ,_gagd int ;
for _eggd :=0;_eggd < len (histogram );_eggd ++{if histogram [_eggd ]> 0{_affda =_eggd ;break ;};};if _affda > 0{_affda --;};for _dcce :=255;_dcce > 0;_dcce --{if histogram [_dcce ]> 0{_gagd =_dcce ;break ;};};if _gagd < 255{_gagd ++;};for _gbdb :=0;_gbdb < 256;
_gbdb ++{if histogram [_gbdb ]> _adec {_cbed =_gbdb ;_adec =histogram [_gbdb ];};};var _ceeb bool ;if (_cbed -_affda )< (_gagd -_cbed ){_ceeb =true ;var _fcfc int ;_dgbb :=255;for _fcfc < _dgbb {_gbcd :=histogram [_fcfc ];histogram [_fcfc ]=histogram [_dgbb ];
histogram [_dgbb ]=_gbcd ;_fcfc ++;_dgbb --;};_affda =255-_gagd ;_cbed =255-_cbed ;};if _affda ==_cbed {return uint8 (_affda );};_bffbe :=float64 (histogram [_cbed ]);_aadf :=float64 (_affda -_cbed );_fefcd :=_gf .Sqrt (_bffbe *_bffbe +_aadf *_aadf );_bffbe /=_fefcd ;
_aadf /=_fefcd ;_fefcd =_bffbe *float64 (_affda )+_aadf *float64 (histogram [_affda ]);_abgc :=_affda ;var _bedg float64 ;for _faafa :=_affda +1;_faafa <=_cbed ;_faafa ++{_adgb :=_bffbe *float64 (_faafa )+_aadf *float64 (histogram [_faafa ])-_fefcd ;if _adgb > _bedg {_abgc =_faafa ;
_bedg =_adgb ;};};_abgc --;if _ceeb {var _cfgb int ;_afaaf :=255;for _cfgb < _afaaf {_debe :=histogram [_cfgb ];histogram [_cfgb ]=histogram [_afaaf ];histogram [_afaaf ]=_debe ;_cfgb ++;_afaaf --;};return uint8 (255-_abgc );};return uint8 (_abgc );};func (_gadf *NRGBA32 )At (x ,y int )_d .Color {_bccb ,_ :=_gadf .ColorAt (x ,y );
return _bccb };func (_afb *Gray4 )Validate ()error {if len (_afb .Data )!=_afb .Height *_afb .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_caeg *NRGBA32 )NRGBAAt (x ,y int )_d .NRGBA {_dbff ,_ :=ColorAtNRGBA32 (x ,y ,_caeg .Width ,_caeg .Data ,_caeg .Alpha ,_caeg .Decode );
return _dbff ;};func (_ebc *CMYK32 )ColorAt (x ,y int )(_d .Color ,error ){return ColorAtCMYK (x ,y ,_ebc .Width ,_ebc .Data ,_ebc .Decode );};func (_faage *NRGBA16 )ColorModel ()_d .Model {return NRGBA16Model };func _cbec (_gbfd _c .Image ,_bdgc uint8 )*_c .Gray {_bgae :=_gbfd .Bounds ();
_bfaea :=_c .NewGray (_bgae );var (_facda _d .Color ;_adeb _d .Gray ;);for _feeg :=0;_feeg < _bgae .Max .X ;_feeg ++{for _fageb :=0;_fageb < _bgae .Max .Y ;_fageb ++{_facda =_gbfd .At (_feeg ,_fageb );_bfaea .Set (_feeg ,_fageb ,_facda );_adeb =_bfaea .GrayAt (_feeg ,_fageb );
_bfaea .SetGray (_feeg ,_fageb ,_d .Gray {Y :_gada (_adeb .Y ,_bdgc )});};};return _bfaea ;};func _dbac (_dedd _c .Image ,_gfcdf Image ,_fgcae _c .Rectangle ){if _ecb ,_cdabe :=_dedd .(SMasker );_cdabe &&_ecb .HasAlpha (){_gfcdf .(SMasker ).MakeAlpha ();
};switch _acfe :=_dedd .(type ){case Gray :_bfae (_acfe ,_gfcdf .(NRGBA ),_fgcae );case NRGBA :_ceec (_acfe ,_gfcdf .(NRGBA ),_fgcae );case *_c .NYCbCrA :_ecfa (_acfe ,_gfcdf .(NRGBA ),_fgcae );case CMYK :_ccbd (_acfe ,_gfcdf .(NRGBA ),_fgcae );case RGBA :_cbgac (_acfe ,_gfcdf .(NRGBA ),_fgcae );
case nrgba64 :_dbd (_acfe ,_gfcdf .(NRGBA ),_fgcae );default:_cabe (_dedd ,_gfcdf ,_fgcae );};};var _ _c .Image =&NRGBA16 {};func _dggf (_agfb _c .Image ,_baecd Image ,_ggfd _c .Rectangle ){if _fbgb ,_gacg :=_agfb .(SMasker );_gacg &&_fbgb .HasAlpha (){_baecd .(SMasker ).MakeAlpha ();
};switch _cfcc :=_agfb .(type ){case Gray :_fcca (_cfcc ,_baecd .(RGBA ),_ggfd );case NRGBA :_fggdc (_cfcc ,_baecd .(RGBA ),_ggfd );case *_c .NYCbCrA :_gdgdg (_cfcc ,_baecd .(RGBA ),_ggfd );case CMYK :_dbca (_cfcc ,_baecd .(RGBA ),_ggfd );case RGBA :_gdge (_cfcc ,_baecd .(RGBA ),_ggfd );
case nrgba64 :_afbbc (_cfcc ,_baecd .(RGBA ),_ggfd );default:_cabe (_agfb ,_baecd ,_ggfd );};};var _ _c .Image =&NRGBA32 {};func (_fdda *CMYK32 )Base ()*ImageBase {return &_fdda .ImageBase };func GrayHistogram (g Gray )(_fdebe [256]int ){switch _ageb :=g .(type ){case Histogramer :return _ageb .Histogram ();
case _c .Image :_fbag :=_ageb .Bounds ();for _aacfe :=0;_aacfe < _fbag .Max .X ;_aacfe ++{for _bcad :=0;_bcad < _fbag .Max .Y ;_bcad ++{_fdebe [g .GrayAt (_aacfe ,_bcad ).Y ]++;};};return _fdebe ;default:return [256]int {};};};func (_gabe *Gray8 )GrayAt (x ,y int )_d .Gray {_gcea ,_ :=ColorAtGray8BPC (x ,y ,_gabe .BytesPerLine ,_gabe .Data ,_gabe .Decode );
return _gcea ;};func (_ggdc *ImageBase )setByte (_cffc int ,_fddab byte )error {if _cffc > len (_ggdc .Data )-1{return _g .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_ggdc .Data [_cffc ]=_fddab ;return nil ;
};var _ _c .Image =&Gray8 {};func ColorAtRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_d .RGBA ,error ){_cecff :=y *width +x ;_ffag :=3*_cecff ;if _ffag +2>=len (data ){return _d .RGBA {},_cc .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_beba :=uint8 (0xff);if alpha !=nil &&len (alpha )> _cecff {_beba =alpha [_cecff ];};_gbada ,_acbd ,_ddgaa :=data [_ffag ],data [_ffag +1],data [_ffag +2];if len (decode )==6{_gbada =uint8 (uint32 (LinearInterpolate (float64 (_gbada ),0,255,decode [0],decode [1]))&0xff);
_acbd =uint8 (uint32 (LinearInterpolate (float64 (_acbd ),0,255,decode [2],decode [3]))&0xff);_ddgaa =uint8 (uint32 (LinearInterpolate (float64 (_ddgaa ),0,255,decode [4],decode [5]))&0xff);};return _d .RGBA {R :_gbada ,G :_acbd ,B :_ddgaa ,A :_beba },nil ;
};func (_cdgf *Gray2 )Bounds ()_c .Rectangle {return _c .Rectangle {Max :_c .Point {X :_cdgf .Width ,Y :_cdgf .Height }};};func (_ggeg *NRGBA32 )ColorModel ()_d .Model {return _d .NRGBAModel };var _ Image =&Gray16 {};func _cbcbe (_afef _c .Image ,_dggd Image ,_abde _c .Rectangle ){switch _aead :=_afef .(type ){case Gray :_eabe (_aead ,_dggd .(Gray ),_abde );
case NRGBA :_gcac (_aead ,_dggd .(Gray ),_abde );case CMYK :_bdbeb (_aead ,_dggd .(Gray ),_abde );case RGBA :_eafg (_aead ,_dggd .(Gray ),_abde );default:_cabe (_afef ,_dggd .(Image ),_abde );};};func LinearInterpolate (x ,xmin ,xmax ,ymin ,ymax float64 )float64 {if _gf .Abs (xmax -xmin )< 0.000001{return ymin ;
};_dcda :=ymin +(x -xmin )*(ymax -ymin )/(xmax -xmin );return _dcda ;};type nrgba64 interface{NRGBA64At (_fdcg ,_fcce int )_d .NRGBA64 ;SetNRGBA64 (_bgdc ,_afbag int ,_cdaea _d .NRGBA64 );};func MonochromeThresholdConverter (threshold uint8 )ColorConverter {return &monochromeThresholdConverter {Threshold :threshold };
};func (_ecda *NRGBA64 )Set (x ,y int ,c _d .Color ){_gcge :=(y *_ecda .Width +x )*2;_ddcd :=_gcge *3;if _ddcd +5>=len (_ecda .Data ){return ;};_beffg :=_d .NRGBA64Model .Convert (c ).(_d .NRGBA64 );_ecda .setNRGBA64 (_ddcd ,_beffg ,_gcge );};func (_caagc *RGBA32 )RGBAAt (x ,y int )_d .RGBA {_adfbb ,_ :=ColorAtRGBA32 (x ,y ,_caagc .Width ,_caagc .Data ,_caagc .Alpha ,_caagc .Decode );
return _adfbb ;};func (_faae *Monochrome )getBitAt (_fdbgd ,_egg int )bool {_bade :=_egg *_faae .BytesPerLine +(_fdbgd >>3);_aeae :=_fdbgd &0x07;_cgae :=uint (7-_aeae );if _bade > len (_faae .Data )-1{return false ;};if (_faae .Data [_bade ]>>_cgae )&0x01>=1{return true ;
};return false ;};func _geee (_gdbea *_c .Gray )bool {for _bcdd :=0;_bcdd < len (_gdbea .Pix );_bcdd ++{if !_dfdab (_gdbea .Pix [_bcdd ]){return false ;};};return true ;};var (Gray2Model =_d .ModelFunc (_fdac );Gray4Model =_d .ModelFunc (_efdc );NRGBA16Model =_d .ModelFunc (_fgec );
);func _aac (_eedf _d .Gray )_d .NRGBA {return _d .NRGBA {R :_eedf .Y ,G :_eedf .Y ,B :_eedf .Y ,A :0xff}};func InDelta (expected ,current ,delta float64 )bool {_cdfe :=expected -current ;if _cdfe <=-delta ||_cdfe >=delta {return false ;};return true ;
};var _ Gray =&Gray2 {};func (_bcead *NRGBA32 )ColorAt (x ,y int )(_d .Color ,error ){return ColorAtNRGBA32 (x ,y ,_bcead .Width ,_bcead .Data ,_bcead .Alpha ,_bcead .Decode );};func (_cfe *Gray8 )Copy ()Image {return &Gray8 {ImageBase :_cfe .copy ()}};
type SMasker interface{HasAlpha ()bool ;GetAlpha ()[]byte ;MakeAlpha ();};func _edb (_cecc _d .NRGBA )_d .CMYK {_gbg ,_cbbf ,_gdg ,_ :=_cecc .RGBA ();_dbc ,_bce ,_fbgc ,_dcc :=_d .RGBToCMYK (uint8 (_gbg >>8),uint8 (_cbbf >>8),uint8 (_gdg >>8));return _d .CMYK {C :_dbc ,M :_bce ,Y :_fbgc ,K :_dcc };
};func _gfdf (_gadgb *Monochrome ,_egbf ,_daad int ,_dacag ,_fffg int ,_aefgg RasterOperator ){var (_ffcc int ;_afcc byte ;_eacdc ,_cgbdd int ;_add int ;);_badc :=_dacag >>3;_gfbc :=_dacag &7;if _gfbc > 0{_afcc =_egca [_gfbc ];};_ffcc =_gadgb .BytesPerLine *_daad +(_egbf >>3);
switch _aefgg {case PixClr :for _eacdc =0;_eacdc < _fffg ;_eacdc ++{_add =_ffcc +_eacdc *_gadgb .BytesPerLine ;for _cgbdd =0;_cgbdd < _badc ;_cgbdd ++{_gadgb .Data [_add ]=0x0;_add ++;};if _gfbc > 0{_gadgb .Data [_add ]=_bbff (_gadgb .Data [_add ],0x0,_afcc );
};};case PixSet :for _eacdc =0;_eacdc < _fffg ;_eacdc ++{_add =_ffcc +_eacdc *_gadgb .BytesPerLine ;for _cgbdd =0;_cgbdd < _badc ;_cgbdd ++{_gadgb .Data [_add ]=0xff;_add ++;};if _gfbc > 0{_gadgb .Data [_add ]=_bbff (_gadgb .Data [_add ],0xff,_afcc );};
};case PixNotDst :for _eacdc =0;_eacdc < _fffg ;_eacdc ++{_add =_ffcc +_eacdc *_gadgb .BytesPerLine ;for _cgbdd =0;_cgbdd < _badc ;_cgbdd ++{_gadgb .Data [_add ]=^_gadgb .Data [_add ];_add ++;};if _gfbc > 0{_gadgb .Data [_add ]=_bbff (_gadgb .Data [_add ],^_gadgb .Data [_add ],_afcc );
};};};};type monochromeModel uint8 ;func (_aaed *NRGBA32 )Set (x ,y int ,c _d .Color ){_acef :=y *_aaed .Width +x ;_eda :=3*_acef ;if _eda +2>=len (_aaed .Data ){return ;};_dba :=_d .NRGBAModel .Convert (c ).(_d .NRGBA );_aaed .setRGBA (_acef ,_dba );};
var _ _c .Image =&Gray4 {};func (_deaf *Gray8 )Validate ()error {if len (_deaf .Data )!=_deaf .Height *_deaf .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_ecdb *CMYK32 )ColorModel ()_d .Model {return _d .CMYKModel };func _afbbc (_agae nrgba64 ,_ebgg RGBA ,_gdac _c .Rectangle ){for _acec :=0;
_acec < _gdac .Max .X ;_acec ++{for _ggaba :=0;_ggaba < _gdac .Max .Y ;_ggaba ++{_fefgc :=_agae .NRGBA64At (_acec ,_ggaba );_ebgg .SetRGBA (_acec ,_ggaba ,_dbcb (_fefgc ));};};};func (_fdddd *Gray8 )Bounds ()_c .Rectangle {return _c .Rectangle {Max :_c .Point {X :_fdddd .Width ,Y :_fdddd .Height }};
};func _bcbf (_fcab _d .RGBA )_d .NRGBA {switch _fcab .A {case 0xff:return _d .NRGBA {R :_fcab .R ,G :_fcab .G ,B :_fcab .B ,A :0xff};case 0x00:return _d .NRGBA {};default:_gbb ,_bdgb ,_cbab ,_facd :=_fcab .RGBA ();_gbb =(_gbb *0xffff)/_facd ;_bdgb =(_bdgb *0xffff)/_facd ;
_cbab =(_cbab *0xffff)/_facd ;return _d .NRGBA {R :uint8 (_gbb >>8),G :uint8 (_bdgb >>8),B :uint8 (_cbab >>8),A :uint8 (_facd >>8)};};};func (_faag *ImageBase )setTwoBytes (_afafb int ,_fagg uint16 )error {if _afafb +1> len (_faag .Data )-1{return _g .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_faag .Data [_afafb ]=byte ((_fagg &0xff00)>>8);_faag .Data [_afafb +1]=byte (_fagg &0xff);return nil ;};func (_cccf *Monochrome )copy ()*Monochrome {_bgf :=_dgb (_cccf .Width ,_cccf .Height );_bgf .ModelThreshold =_cccf .ModelThreshold ;_bgf .Data =make ([]byte ,len (_cccf .Data ));
copy (_bgf .Data ,_cccf .Data );if len (_cccf .Decode )!=0{_bgf .Decode =make ([]float64 ,len (_cccf .Decode ));copy (_bgf .Decode ,_cccf .Decode );};if len (_cccf .Alpha )!=0{_bgf .Alpha =make ([]byte ,len (_cccf .Alpha ));copy (_bgf .Alpha ,_cccf .Alpha );
};return _bgf ;};func IsGrayImgBlackAndWhite (i *_c .Gray )bool {return _geee (i )};func _gda (_fedf ,_bcf *Monochrome ,_dfc []byte ,_feed int )(_cdc error ){var (_gbff ,_abfe ,_feaa ,_eed ,_edc ,_eag ,_gce ,_fegga int ;_feab ,_bfg uint32 ;_ffc ,_affa byte ;
_fadg uint16 ;);_bbd :=make ([]byte ,4);_gfcg :=make ([]byte ,4);for _feaa =0;_feaa < _fedf .Height -1;_feaa ,_eed =_feaa +2,_eed +1{_gbff =_feaa *_fedf .BytesPerLine ;_abfe =_eed *_bcf .BytesPerLine ;for _edc ,_eag =0,0;_edc < _feed ;_edc ,_eag =_edc +4,_eag +1{for _gce =0;
_gce < 4;_gce ++{_fegga =_gbff +_edc +_gce ;if _fegga <=len (_fedf .Data )-1&&_fegga < _gbff +_fedf .BytesPerLine {_bbd [_gce ]=_fedf .Data [_fegga ];}else {_bbd [_gce ]=0x00;};_fegga =_gbff +_fedf .BytesPerLine +_edc +_gce ;if _fegga <=len (_fedf .Data )-1&&_fegga < _gbff +(2*_fedf .BytesPerLine ){_gfcg [_gce ]=_fedf .Data [_fegga ];
}else {_gfcg [_gce ]=0x00;};};_feab =_fe .BigEndian .Uint32 (_bbd );_bfg =_fe .BigEndian .Uint32 (_gfcg );_bfg &=_feab ;_bfg &=_bfg <<1;_bfg &=0xaaaaaaaa;_feab =_bfg |(_bfg <<7);_ffc =byte (_feab >>24);_affa =byte ((_feab >>8)&0xff);_fegga =_abfe +_eag ;
if _fegga +1==len (_bcf .Data )-1||_fegga +1>=_abfe +_bcf .BytesPerLine {_bcf .Data [_fegga ]=_dfc [_ffc ];if _cdc =_bcf .setByte (_fegga ,_dfc [_ffc ]);_cdc !=nil {return _cc .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_fegga );};}else {_fadg =(uint16 (_dfc [_ffc ])<<8)|uint16 (_dfc [_affa ]);
if _cdc =_bcf .setTwoBytes (_fegga ,_fadg );_cdc !=nil {return _cc .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_fegga );
};_eag ++;};};};return nil ;};func (_agda *Monochrome )getBit (_bafe ,_bbe int )uint8 {return _agda .Data [_bafe +(_bbe >>3)]>>uint (7-(_bbe &7))&1;};var _ Image =&CMYK32 {};func _gcac (_faef NRGBA ,_aagc Gray ,_efbd _c .Rectangle ){for _gaeeg :=0;_gaeeg < _efbd .Max .X ;
_gaeeg ++{for _dccf :=0;_dccf < _efbd .Max .Y ;_dccf ++{_dgee :=_gde (_faef .NRGBAAt (_gaeeg ,_dccf ));_aagc .SetGray (_gaeeg ,_dccf ,_dgee );};};};func _fbc (_ddc _d .RGBA )_d .Gray {_bee :=(19595*uint32 (_ddc .R )+38470*uint32 (_ddc .G )+7471*uint32 (_ddc .B )+1<<7)>>16;
return _d .Gray {Y :uint8 (_bee )};};type CMYK interface{CMYKAt (_bcgf ,_cba int )_d .CMYK ;SetCMYK (_dac ,_gffd int ,_cde _d .CMYK );};func (_gecba *RGBA32 )Validate ()error {if len (_gecba .Data )!=3*_gecba .Width *_gecba .Height {return _g .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func (_bab *Gray8 )Base ()*ImageBase {return &_bab .ImageBase };func _fggdc (_bafb NRGBA ,_bcee RGBA ,_gfea _c .Rectangle ){for _aace :=0;_aace < _gfea .Max .X ;_aace ++{for _dddb :=0;_dddb < _gfea .Max .Y ;_dddb ++{_aced :=_bafb .NRGBAAt (_aace ,_dddb );
_bcee .SetRGBA (_aace ,_dddb ,_bcfb (_aced ));};};};func _afcb (_dgebc _c .Image )(Image ,error ){if _efb ,_efd :=_dgebc .(*CMYK32 );_efd {return _efb .Copy (),nil ;};_dea :=_dgebc .Bounds ();_eab ,_eedb :=NewImage (_dea .Max .X ,_dea .Max .Y ,8,4,nil ,nil ,nil );
if _eedb !=nil {return nil ,_eedb ;};switch _bded :=_dgebc .(type ){case CMYK :_begc (_bded ,_eab .(CMYK ),_dea );case Gray :_bdfg (_bded ,_eab .(CMYK ),_dea );case NRGBA :_gee (_bded ,_eab .(CMYK ),_dea );case RGBA :_faa (_bded ,_eab .(CMYK ),_dea );default:_cabe (_dgebc ,_eab ,_dea );
};return _eab ,nil ;};func _eacg (_ebd _c .Image )(Image ,error ){if _acgg ,_bdga :=_ebd .(*Gray4 );_bdga {return _acgg .Copy (),nil ;};_egd :=_ebd .Bounds ();_eggf ,_abccd :=NewImage (_egd .Max .X ,_egd .Max .Y ,4,1,nil ,nil ,nil );if _abccd !=nil {return nil ,_abccd ;
};_cbcbe (_ebd ,_eggf ,_egd );return _eggf ,nil ;};func _dbd (_gdgd nrgba64 ,_gdaf NRGBA ,_cebae _c .Rectangle ){for _ccfeae :=0;_ccfeae < _cebae .Max .X ;_ccfeae ++{for _bacf :=0;_bacf < _cebae .Max .Y ;_bacf ++{_dgcc :=_gdgd .NRGBA64At (_ccfeae ,_bacf );
_gdaf .SetNRGBA (_ccfeae ,_bacf ,_dgbd (_dgcc ));};};};func (_bgcd *Monochrome )Validate ()error {if len (_bgcd .Data )!=_bgcd .Height *_bgcd .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_cdef *Gray2 )Copy ()Image {return &Gray2 {ImageBase :_cdef .copy ()}};
func (_eaa *Monochrome )ColorModel ()_d .Model {return MonochromeModel (_eaa .ModelThreshold )};func (_bdc *Monochrome )ScaleLow (width ,height int )(*Monochrome ,error ){if width < 0||height < 0{return nil ,_g .New ("\u0070\u0072\u006f\u0076\u0069\u0064e\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0069\u0064t\u0068\u0020\u0061\u006e\u0064\u0020\u0068e\u0069\u0067\u0068\u0074");
};_bcgg :=_dgb (width ,height );_fbac :=make ([]int ,height );_gdea :=make ([]int ,width );_fdg :=float64 (_bdc .Width )/float64 (width );_dfda :=float64 (_bdc .Height )/float64 (height );for _cdae :=0;_cdae < height ;_cdae ++{_fbac [_cdae ]=int (_gf .Min (_dfda *float64 (_cdae )+0.5,float64 (_bdc .Height -1)));
};for _dbbg :=0;_dbbg < width ;_dbbg ++{_gdea [_dbbg ]=int (_gf .Min (_fdg *float64 (_dbbg )+0.5,float64 (_bdc .Width -1)));};_dgebd :=-1;_dgfg :=byte (0);for _fdgf :=0;_fdgf < height ;_fdgf ++{_acc :=_fbac [_fdgf ]*_bdc .BytesPerLine ;_aeab :=_fdgf *_bcgg .BytesPerLine ;
for _eecc :=0;_eecc < width ;_eecc ++{_bfad :=_gdea [_eecc ];if _bfad !=_dgebd {_dgfg =_bdc .getBit (_acc ,_bfad );if _dgfg !=0{_bcgg .setBit (_aeab ,_eecc );};_dgebd =_bfad ;}else {if _dgfg !=0{_bcgg .setBit (_aeab ,_eecc );};};};};return _bcgg ,nil ;
};func (_fdfc *Monochrome )IsUnpadded ()bool {return (_fdfc .Width *_fdfc .Height )==len (_fdfc .Data )};func _bbcbb (_dfba _c .Image )(Image ,error ){if _gbdf ,_fcfbb :=_dfba .(*NRGBA16 );_fcfbb {return _gbdf .Copy (),nil ;};_fega :=_dfba .Bounds ();_cfab ,_cdab :=NewImage (_fega .Max .X ,_fega .Max .Y ,4,3,nil ,nil ,nil );
if _cdab !=nil {return nil ,_cdab ;};_dbac (_dfba ,_cfab ,_fega );return _cfab ,nil ;};func (_fddg *NRGBA32 )setRGBA (_cfgc int ,_ddabg _d .NRGBA ){_effa :=3*_cfgc ;_fddg .Data [_effa ]=_ddabg .R ;_fddg .Data [_effa +1]=_ddabg .G ;_fddg .Data [_effa +2]=_ddabg .B ;
if _cfgc < len (_fddg .Alpha ){_fddg .Alpha [_cfgc ]=_ddabg .A ;};};func (_cabec *NRGBA64 )At (x ,y int )_d .Color {_dgefd ,_ :=_cabec .ColorAt (x ,y );return _dgefd };func (_aagd *RGBA32 )SetRGBA (x ,y int ,c _d .RGBA ){_aefe :=y *_aagd .Width +x ;_bggg :=3*_aefe ;
if _bggg +2>=len (_aagd .Data ){return ;};_aagd .setRGBA (_aefe ,c );};func (_efcf *Gray4 )Base ()*ImageBase {return &_efcf .ImageBase };func _begc (_fddd ,_aegc CMYK ,_aea _c .Rectangle ){for _ggfg :=0;_ggfg < _aea .Max .X ;_ggfg ++{for _faea :=0;_faea < _aea .Max .Y ;
_faea ++{_aegc .SetCMYK (_ggfg ,_faea ,_fddd .CMYKAt (_ggfg ,_faea ));};};};func (_bfaa *Monochrome )Scale (scale float64 )(*Monochrome ,error ){var _adg bool ;_daee :=scale ;if scale < 1{_daee =1/scale ;_adg =true ;};_degb :=NextPowerOf2 (uint (_daee ));
if InDelta (float64 (_degb ),_daee ,0.001){if _adg {return _bfaa .ReduceBinary (_daee );};return _bfaa .ExpandBinary (int (_degb ));};_gcc :=int (_gf .RoundToEven (float64 (_bfaa .Width )*scale ));_ada :=int (_gf .RoundToEven (float64 (_bfaa .Height )*scale ));
return _bfaa .ScaleLow (_gcc ,_ada );};func _gaab (_cffd _d .NYCbCrA )_d .RGBA {_cda ,_cbaba ,_faee ,_gdf :=_fda (_cffd ).RGBA ();return _d .RGBA {R :uint8 (_cda >>8),G :uint8 (_cbaba >>8),B :uint8 (_faee >>8),A :uint8 (_gdf >>8)};};type RGBA32 struct{ImageBase };
func (_aebb *ImageBase )setEightFullBytes (_gbce int ,_ecee uint64 )error {if _gbce +7> len (_aebb .Data )-1{return _g .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_aebb .Data [_gbce ]=byte ((_ecee &0xff00000000000000)>>56);
_aebb .Data [_gbce +1]=byte ((_ecee &0xff000000000000)>>48);_aebb .Data [_gbce +2]=byte ((_ecee &0xff0000000000)>>40);_aebb .Data [_gbce +3]=byte ((_ecee &0xff00000000)>>32);_aebb .Data [_gbce +4]=byte ((_ecee &0xff000000)>>24);_aebb .Data [_gbce +5]=byte ((_ecee &0xff0000)>>16);
_aebb .Data [_gbce +6]=byte ((_ecee &0xff00)>>8);_aebb .Data [_gbce +7]=byte (_ecee &0xff);return nil ;};func _fdac (_ccea _d .Color )_d .Color {_eagba :=_d .GrayModel .Convert (_ccea ).(_d .Gray );return _gaaa (_eagba );};func _gde (_gdbe _d .NRGBA )_d .Gray {_abc ,_fgcc ,_ddf ,_ :=_gdbe .RGBA ();
_daa :=(19595*_abc +38470*_fgcc +7471*_ddf +1<<15)>>24;return _d .Gray {Y :uint8 (_daa )};};func RasterOperation (dest *Monochrome ,dx ,dy ,dw ,dh int ,op RasterOperator ,src *Monochrome ,sx ,sy int )error {return _daca (dest ,dx ,dy ,dw ,dh ,op ,src ,sx ,sy );
};func (_fbda *RGBA32 )Copy ()Image {return &RGBA32 {ImageBase :_fbda .copy ()}};func _caa (_bcdb *Monochrome ,_cbd ...int )(_eefa *Monochrome ,_aef error ){if _bcdb ==nil {return nil ,_g .New ("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d");
};if len (_cbd )==0{return nil ,_g .New ("\u0074h\u0065\u0072e\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0061\u0074 \u006c\u0065\u0061\u0073\u0074\u0020o\u006e\u0065\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u006f\u0066 \u0072\u0065\u0064\u0075\u0063\u0074\u0069\u006f\u006e");
};_fce :=_gff ();_eefa =_bcdb ;for _ ,_cea :=range _cbd {if _cea <=0{break ;};_eefa ,_aef =_gcf (_eefa ,_cea ,_fce );if _aef !=nil {return nil ,_aef ;};};return _eefa ,nil ;};func (_bca *ImageBase )setFourBytes (_aecb int ,_faca uint32 )error {if _aecb +3> len (_bca .Data )-1{return _cc .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006fu\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065",_aecb );
};_bca .Data [_aecb ]=byte ((_faca &0xff000000)>>24);_bca .Data [_aecb +1]=byte ((_faca &0xff0000)>>16);_bca .Data [_aecb +2]=byte ((_faca &0xff00)>>8);_bca .Data [_aecb +3]=byte (_faca &0xff);return nil ;};func (_gcgg *Gray16 )Bounds ()_c .Rectangle {return _c .Rectangle {Max :_c .Point {X :_gcgg .Width ,Y :_gcgg .Height }};
};var _ _c .Image =&Gray16 {};func ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor int ,data ,alpha []byte ,decode []float64 )(_d .Color ,error ){switch bitsPerColor {case 4:return ColorAtNRGBA16 (x ,y ,width ,bytesPerLine ,data ,alpha ,decode );
case 8:return ColorAtNRGBA32 (x ,y ,width ,data ,alpha ,decode );case 16:return ColorAtNRGBA64 (x ,y ,width ,data ,alpha ,decode );default:return nil ,_cc .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0067\u0062\u0020b\u0069\u0074\u0073\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0061\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );
};};func (_fgcd *NRGBA16 )setNRGBA (_adb ,_dgefa ,_cgd int ,_abca _d .NRGBA ){if _adb *3%2==0{_fgcd .Data [_cgd ]=(_abca .R >>4)<<4|(_abca .G >>4);_fgcd .Data [_cgd +1]=(_abca .B >>4)<<4|(_fgcd .Data [_cgd +1]&0xf);}else {_fgcd .Data [_cgd ]=(_fgcd .Data [_cgd ]&0xf0)|(_abca .R >>4);
_fgcd .Data [_cgd +1]=(_abca .G >>4)<<4|(_abca .B >>4);};if _fgcd .Alpha !=nil {_eaae :=_dgefa *BytesPerLine (_fgcd .Width ,4,1);if _eaae < len (_fgcd .Alpha ){if _adb %2==0{_fgcd .Alpha [_eaae ]=(_abca .A >>uint (4))<<uint (4)|(_fgcd .Alpha [_cgd ]&0xf);
}else {_fgcd .Alpha [_eaae ]=(_fgcd .Alpha [_eaae ]&0xf0)|(_abca .A >>uint (4));};};};};func (_eacb *Gray4 )GrayAt (x ,y int )_d .Gray {_dfff ,_ :=ColorAtGray4BPC (x ,y ,_eacb .BytesPerLine ,_eacb .Data ,_eacb .Decode );return _dfff ;};func (_bdab *Gray16 )Validate ()error {if len (_bdab .Data )!=_bdab .Height *_bdab .BytesPerLine {return ErrInvalidImage ;
};return nil ;};type Image interface{_dg .Image ;Base ()*ImageBase ;Copy ()Image ;Pix ()[]byte ;ColorAt (_fece ,_efad int )(_d .Color ,error );Validate ()error ;};