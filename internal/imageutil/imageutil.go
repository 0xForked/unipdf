//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package imageutil ;import (_bg "encoding/binary";_ac "errors";_fa "fmt";_g "github.com/unidoc/unipdf/v3/common";_fb "github.com/unidoc/unipdf/v3/internal/bitwise";_de "image";_d "image/color";_f "image/draw";_b "math";);func ScaleAlphaToMonochrome (data []byte ,width ,height int )([]byte ,error ){_c :=BytesPerLine (width ,8,1);
if len (data )< _c *height {return nil ,nil ;};_ca :=&Gray8 {NewImageBase (width ,height ,8,1,data ,nil ,nil )};_e ,_bd :=MonochromeConverter .Convert (_ca );if _bd !=nil {return nil ,_bd ;};return _e .Base ().Data ,nil ;};func (_ddaf *Gray2 )ColorAt (x ,y int )(_d .Color ,error ){return ColorAtGray2BPC (x ,y ,_ddaf .BytesPerLine ,_ddaf .Data ,_ddaf .Decode );
};func (_dbedd *Monochrome )Validate ()error {if len (_dbedd .Data )!=_dbedd .Height *_dbedd .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_eefe *Gray8 )SetGray (x ,y int ,g _d .Gray ){_edfgb :=y *_eefe .BytesPerLine +x ;if _edfgb > len (_eefe .Data )-1{return ;
};_eefe .Data [_edfgb ]=g .Y ;};func (_deee *NRGBA16 )Base ()*ImageBase {return &_deee .ImageBase };func (_abgf *Gray8 )Histogram ()(_aggf [256]int ){for _fgef :=0;_fgef < len (_abgf .Data );_fgef ++{_aggf [_abgf .Data [_fgef ]]++;};return _aggf ;};func _ga (_gd *Monochrome ,_ff int )(*Monochrome ,error ){if _gd ==nil {return nil ,_ac .New ("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064");
};if _ff ==1{return _gd .copy (),nil ;};if !IsPowerOf2 (uint (_ff )){return nil ,_fa .Errorf ("\u0070\u0072\u006fvi\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006ci\u0064 \u0065x\u0070a\u006e\u0064\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_ff );
};_cb :=_ceg (_ff );return _ed (_gd ,_ff ,_cb );};func _cda (_aae _de .Image )(Image ,error ){if _bbga ,_dag :=_aae .(*CMYK32 );_dag {return _bbga .Copy (),nil ;};_gae :=_aae .Bounds ();_fbf ,_gfdb :=NewImage (_gae .Max .X ,_gae .Max .Y ,8,4,nil ,nil ,nil );
if _gfdb !=nil {return nil ,_gfdb ;};switch _acb :=_aae .(type ){case CMYK :_gaef (_acb ,_fbf .(CMYK ),_gae );case Gray :_dfdg (_acb ,_fbf .(CMYK ),_gae );case NRGBA :_daad (_acb ,_fbf .(CMYK ),_gae );case RGBA :_cfd (_acb ,_fbf .(CMYK ),_gae );default:_fea (_aae ,_fbf ,_gae );
};return _fbf ,nil ;};func _fdab (_cga _d .NRGBA )_d .Gray {_ffgb ,_cef ,_eca ,_ :=_cga .RGBA ();_egc :=(19595*_ffgb +38470*_cef +7471*_eca +1<<15)>>24;return _d .Gray {Y :uint8 (_egc )};};func (_gadd *Gray16 )Bounds ()_de .Rectangle {return _de .Rectangle {Max :_de .Point {X :_gadd .Width ,Y :_gadd .Height }};
};func _cdeg (_fff ,_edfc *Monochrome ,_dcd []byte ,_dg int )(_eaf error ){var (_gdc ,_cede ,_cba ,_bff ,_gab ,_ead ,_bae ,_gabc int ;_cae ,_efd uint32 ;_ebf ,_gadc byte ;_aca uint16 ;);_acgb :=make ([]byte ,4);_dbg :=make ([]byte ,4);for _cba =0;_cba < _fff .Height -1;
_cba ,_bff =_cba +2,_bff +1{_gdc =_cba *_fff .BytesPerLine ;_cede =_bff *_edfc .BytesPerLine ;for _gab ,_ead =0,0;_gab < _dg ;_gab ,_ead =_gab +4,_ead +1{for _bae =0;_bae < 4;_bae ++{_gabc =_gdc +_gab +_bae ;if _gabc <=len (_fff .Data )-1&&_gabc < _gdc +_fff .BytesPerLine {_acgb [_bae ]=_fff .Data [_gabc ];
}else {_acgb [_bae ]=0x00;};_gabc =_gdc +_fff .BytesPerLine +_gab +_bae ;if _gabc <=len (_fff .Data )-1&&_gabc < _gdc +(2*_fff .BytesPerLine ){_dbg [_bae ]=_fff .Data [_gabc ];}else {_dbg [_bae ]=0x00;};};_cae =_bg .BigEndian .Uint32 (_acgb );_efd =_bg .BigEndian .Uint32 (_dbg );
_efd |=_cae ;_efd |=_efd <<1;_efd &=0xaaaaaaaa;_cae =_efd |(_efd <<7);_ebf =byte (_cae >>24);_gadc =byte ((_cae >>8)&0xff);_gabc =_cede +_ead ;if _gabc +1==len (_edfc .Data )-1||_gabc +1>=_cede +_edfc .BytesPerLine {_edfc .Data [_gabc ]=_dcd [_ebf ];}else {_aca =(uint16 (_dcd [_ebf ])<<8)|uint16 (_dcd [_gadc ]);
if _eaf =_edfc .setTwoBytes (_gabc ,_aca );_eaf !=nil {return _fa .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_gabc );
};_ead ++;};};};return nil ;};func _fcg (_be *Monochrome ,_def ...int )(_ceag *Monochrome ,_aaf error ){if _be ==nil {return nil ,_ac .New ("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d");
};if len (_def )==0{return nil ,_ac .New ("\u0074h\u0065\u0072e\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0061\u0074 \u006c\u0065\u0061\u0073\u0074\u0020o\u006e\u0065\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u006f\u0066 \u0072\u0065\u0064\u0075\u0063\u0074\u0069\u006f\u006e");
};_afb :=_dbb ();_ceag =_be ;for _ ,_baaa :=range _def {if _baaa <=0{break ;};_ceag ,_aaf =_eeb (_ceag ,_baaa ,_afb );if _aaf !=nil {return nil ,_aaf ;};};return _ceag ,nil ;};func (_gbbc *NRGBA32 )At (x ,y int )_d .Color {_eeffd ,_ :=_gbbc .ColorAt (x ,y );
return _eeffd };func LinearInterpolate (x ,xmin ,xmax ,ymin ,ymax float64 )float64 {if _b .Abs (xmax -xmin )< 0.000001{return ymin ;};_bbef :=ymin +(x -xmin )*(ymax -ymin )/(xmax -xmin );return _bbef ;};type ImageBase struct{Width ,Height int ;BitsPerComponent ,ColorComponents int ;
Data ,Alpha []byte ;Decode []float64 ;BytesPerLine int ;};func _fccba (_ffff *Monochrome ,_cedea ,_ddef int ,_gega ,_gdec int ,_fada RasterOperator ){var (_ccbg bool ;_ggcb bool ;_geeb int ;_bfef int ;_aebf int ;_aefb int ;_fgcd bool ;_edc byte ;);_baaf :=8-(_cedea &7);
_faaa :=_gfgg [_baaf ];_afbbf :=_ffff .BytesPerLine *_ddef +(_cedea >>3);if _gega < _baaf {_ccbg =true ;_faaa &=_ebca [8-_baaf +_gega ];};if !_ccbg {_geeb =(_gega -_baaf )>>3;if _geeb !=0{_ggcb =true ;_bfef =_afbbf +1;};};_aebf =(_cedea +_gega )&7;if !(_ccbg ||_aebf ==0){_fgcd =true ;
_edc =_ebca [_aebf ];_aefb =_afbbf +1+_geeb ;};var _bfgd ,_afec int ;switch _fada {case PixClr :for _bfgd =0;_bfgd < _gdec ;_bfgd ++{_ffff .Data [_afbbf ]=_dabf (_ffff .Data [_afbbf ],0x0,_faaa );_afbbf +=_ffff .BytesPerLine ;};if _ggcb {for _bfgd =0;_bfgd < _gdec ;
_bfgd ++{for _afec =0;_afec < _geeb ;_afec ++{_ffff .Data [_bfef +_afec ]=0x0;};_bfef +=_ffff .BytesPerLine ;};};if _fgcd {for _bfgd =0;_bfgd < _gdec ;_bfgd ++{_ffff .Data [_aefb ]=_dabf (_ffff .Data [_aefb ],0x0,_edc );_aefb +=_ffff .BytesPerLine ;};};
case PixSet :for _bfgd =0;_bfgd < _gdec ;_bfgd ++{_ffff .Data [_afbbf ]=_dabf (_ffff .Data [_afbbf ],0xff,_faaa );_afbbf +=_ffff .BytesPerLine ;};if _ggcb {for _bfgd =0;_bfgd < _gdec ;_bfgd ++{for _afec =0;_afec < _geeb ;_afec ++{_ffff .Data [_bfef +_afec ]=0xff;
};_bfef +=_ffff .BytesPerLine ;};};if _fgcd {for _bfgd =0;_bfgd < _gdec ;_bfgd ++{_ffff .Data [_aefb ]=_dabf (_ffff .Data [_aefb ],0xff,_edc );_aefb +=_ffff .BytesPerLine ;};};case PixNotDst :for _bfgd =0;_bfgd < _gdec ;_bfgd ++{_ffff .Data [_afbbf ]=_dabf (_ffff .Data [_afbbf ],^_ffff .Data [_afbbf ],_faaa );
_afbbf +=_ffff .BytesPerLine ;};if _ggcb {for _bfgd =0;_bfgd < _gdec ;_bfgd ++{for _afec =0;_afec < _geeb ;_afec ++{_ffff .Data [_bfef +_afec ]=^(_ffff .Data [_bfef +_afec ]);};_bfef +=_ffff .BytesPerLine ;};};if _fgcd {for _bfgd =0;_bfgd < _gdec ;_bfgd ++{_ffff .Data [_aefb ]=_dabf (_ffff .Data [_aefb ],^_ffff .Data [_aefb ],_edc );
_aefb +=_ffff .BytesPerLine ;};};};};var _ _de .Image =&Gray2 {};func (_adbc *monochromeThresholdConverter )Convert (img _de .Image )(Image ,error ){if _ggddg ,_cbba :=img .(*Monochrome );_cbba {return _ggddg .Copy (),nil ;};_bfb :=img .Bounds ();_ecfc ,_cgbd :=NewImage (_bfb .Max .X ,_bfb .Max .Y ,1,1,nil ,nil ,nil );
if _cgbd !=nil {return nil ,_cgbd ;};_ecfc .(*Monochrome ).ModelThreshold =_adbc .Threshold ;for _acad :=0;_acad < _bfb .Max .X ;_acad ++{for _eaee :=0;_eaee < _bfb .Max .Y ;_eaee ++{_afd :=img .At (_acad ,_eaee );_ecfc .Set (_acad ,_eaee ,_afd );};};return _ecfc ,nil ;
};type CMYK interface{CMYKAt (_cdd ,_dgd int )_d .CMYK ;SetCMYK (_dfcc ,_cdfd int ,_dde _d .CMYK );};func (_eada *ImageBase )newAlpha (){_dggb :=BytesPerLine (_eada .Width ,_eada .BitsPerComponent ,1);_eada .Alpha =make ([]byte ,_eada .Height *_dggb );
};func (_ecg *CMYK32 )Base ()*ImageBase {return &_ecg .ImageBase };func (_dec colorConverter )Convert (src _de .Image )(Image ,error ){return _dec ._fgd (src )};func (_fagf *Gray16 )GrayAt (x ,y int )_d .Gray {_dcca ,_ :=_fagf .ColorAt (x ,y );return _d .Gray {Y :uint8 (_dcca .(_d .Gray16 ).Y >>8)};
};func (_bfeg *NRGBA64 )Set (x ,y int ,c _d .Color ){_dccaf :=(y *_bfeg .Width +x )*2;_fddd :=_dccaf *3;if _fddd +5>=len (_bfeg .Data ){return ;};_aacb :=_d .NRGBA64Model .Convert (c ).(_d .NRGBA64 );_bfeg .setNRGBA64 (_fddd ,_aacb ,_dccaf );};func (_dbda *Gray8 )GrayAt (x ,y int )_d .Gray {_aabe ,_ :=ColorAtGray8BPC (x ,y ,_dbda .BytesPerLine ,_dbda .Data ,_dbda .Decode );
return _aabe ;};func (_cgadf *ImageBase )setEightBytes (_abbga int ,_affe uint64 )error {_efeb :=_cgadf .BytesPerLine -(_abbga %_cgadf .BytesPerLine );if _cgadf .BytesPerLine !=_cgadf .Width >>3{_efeb --;};if _efeb >=8{return _cgadf .setEightFullBytes (_abbga ,_affe );
};return _cgadf .setEightPartlyBytes (_abbga ,_efeb ,_affe );};func _eeg (_bfbc _d .Gray )_d .Gray {_bfbc .Y >>=4;_bfbc .Y |=_bfbc .Y <<4;return _bfbc };func _faafg (_abeb *_de .Gray16 ,_ggf uint8 )*_de .Gray {_edga :=_abeb .Bounds ();_ebbf :=_de .NewGray (_edga );
for _dfacd :=0;_dfacd < _edga .Dx ();_dfacd ++{for _cffce :=0;_cffce < _edga .Dy ();_cffce ++{_agge :=_abeb .Gray16At (_dfacd ,_cffce );_ebbf .SetGray (_dfacd ,_cffce ,_d .Gray {Y :_geagg (uint8 (_agge .Y /256),_ggf )});};};return _ebbf ;};func (_aeg *Gray2 )Base ()*ImageBase {return &_aeg .ImageBase };
func ColorAtNRGBA16 (x ,y ,width ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_d .NRGBA ,error ){_fbdf :=y *bytesPerLine +x *3/2;if _fbdf +1>=len (data ){return _d .NRGBA {},_gebf (x ,y );};const (_fdede =0xf;_agfbg =uint8 (0xff););_fdedd :=_agfbg ;
if alpha !=nil {_bceb :=y *BytesPerLine (width ,4,1);if _bceb < len (alpha ){if x %2==0{_fdedd =(alpha [_bceb ]>>uint (4))&_fdede ;}else {_fdedd =alpha [_bceb ]&_fdede ;};_fdedd |=_fdedd <<4;};};var _daef ,_ebd ,_gcbbb uint8 ;if x *3%2==0{_daef =(data [_fbdf ]>>uint (4))&_fdede ;
_ebd =data [_fbdf ]&_fdede ;_gcbbb =(data [_fbdf +1]>>uint (4))&_fdede ;}else {_daef =data [_fbdf ]&_fdede ;_ebd =(data [_fbdf +1]>>uint (4))&_fdede ;_gcbbb =data [_fbdf +1]&_fdede ;};if len (decode )==6{_daef =uint8 (uint32 (LinearInterpolate (float64 (_daef ),0,15,decode [0],decode [1]))&0xf);
_ebd =uint8 (uint32 (LinearInterpolate (float64 (_ebd ),0,15,decode [2],decode [3]))&0xf);_gcbbb =uint8 (uint32 (LinearInterpolate (float64 (_gcbbb ),0,15,decode [4],decode [5]))&0xf);};return _d .NRGBA {R :(_daef <<4)|(_daef &0xf),G :(_ebd <<4)|(_ebd &0xf),B :(_gcbbb <<4)|(_gcbbb &0xf),A :_fdedd },nil ;
};func (_baaac *Gray16 )ColorModel ()_d .Model {return _d .Gray16Model };func _fcb ()(_dd [256]uint32 ){for _bbg :=0;_bbg < 256;_bbg ++{if _bbg &0x01!=0{_dd [_bbg ]|=0xf;};if _bbg &0x02!=0{_dd [_bbg ]|=0xf0;};if _bbg &0x04!=0{_dd [_bbg ]|=0xf00;};if _bbg &0x08!=0{_dd [_bbg ]|=0xf000;
};if _bbg &0x10!=0{_dd [_bbg ]|=0xf0000;};if _bbg &0x20!=0{_dd [_bbg ]|=0xf00000;};if _bbg &0x40!=0{_dd [_bbg ]|=0xf000000;};if _bbg &0x80!=0{_dd [_bbg ]|=0xf0000000;};};return _dd ;};func _dcb (_fdgg *Monochrome ,_bfa ,_fgda int ,_ecbe ,_aabfd int ,_ddeb RasterOperator ,_eaedd *Monochrome ,_eacb ,_fgefa int )error {var _bccb ,_gbea ,_cbfc ,_cegd int ;
if _bfa < 0{_eacb -=_bfa ;_ecbe +=_bfa ;_bfa =0;};if _eacb < 0{_bfa -=_eacb ;_ecbe +=_eacb ;_eacb =0;};_bccb =_bfa +_ecbe -_fdgg .Width ;if _bccb > 0{_ecbe -=_bccb ;};_gbea =_eacb +_ecbe -_eaedd .Width ;if _gbea > 0{_ecbe -=_gbea ;};if _fgda < 0{_fgefa -=_fgda ;
_aabfd +=_fgda ;_fgda =0;};if _fgefa < 0{_fgda -=_fgefa ;_aabfd +=_fgefa ;_fgefa =0;};_cbfc =_fgda +_aabfd -_fdgg .Height ;if _cbfc > 0{_aabfd -=_cbfc ;};_cegd =_fgefa +_aabfd -_eaedd .Height ;if _cegd > 0{_aabfd -=_cegd ;};if _ecbe <=0||_aabfd <=0{return nil ;
};var _afad error ;switch {case _bfa &7==0&&_eacb &7==0:_afad =_gfb (_fdgg ,_bfa ,_fgda ,_ecbe ,_aabfd ,_ddeb ,_eaedd ,_eacb ,_fgefa );case _bfa &7==_eacb &7:_afad =_gdeb (_fdgg ,_bfa ,_fgda ,_ecbe ,_aabfd ,_ddeb ,_eaedd ,_eacb ,_fgefa );default:_afad =_adca (_fdgg ,_bfa ,_fgda ,_ecbe ,_aabfd ,_ddeb ,_eaedd ,_eacb ,_fgefa );
};if _afad !=nil {return _afad ;};return nil ;};func (_ccfa monochromeModel )Convert (c _d .Color )_d .Color {_dga :=_d .GrayModel .Convert (c ).(_d .Gray );return _gcf (_dga ,_ccfa );};func _feda (_eac _d .Gray )_d .NRGBA {return _d .NRGBA {R :_eac .Y ,G :_eac .Y ,B :_eac .Y ,A :0xff}};
type NRGBA16 struct{ImageBase };func _ggag (_edab _de .Image ,_ebcc Image ,_aabd _de .Rectangle ){if _fdda ,_fbaf :=_edab .(SMasker );_fbaf &&_fdda .HasAlpha (){_ebcc .(SMasker ).MakeAlpha ();};switch _gadce :=_edab .(type ){case Gray :_fbfc (_gadce ,_ebcc .(NRGBA ),_aabd );
case NRGBA :_acbg (_gadce ,_ebcc .(NRGBA ),_aabd );case *_de .NYCbCrA :_cfcef (_gadce ,_ebcc .(NRGBA ),_aabd );case CMYK :_geag (_gadce ,_ebcc .(NRGBA ),_aabd );case RGBA :_edff (_gadce ,_ebcc .(NRGBA ),_aabd );case nrgba64 :_dadc (_gadce ,_ebcc .(NRGBA ),_aabd );
default:_fea (_edab ,_ebcc ,_aabd );};};func (_eg *CMYK32 )Validate ()error {if len (_eg .Data )!=4*_eg .Width *_eg .Height {return _ac .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};type colorConverter struct{_fgd func (_acff _de .Image )(Image ,error );};func _afeg (_bdb ,_ged int )*Monochrome {return &Monochrome {ImageBase :NewImageBase (_bdb ,_ged ,1,1,nil ,nil ,nil ),ModelThreshold :0x0f};};func (_abcb *Monochrome )Set (x ,y int ,c _d .Color ){_cbgg :=y *_abcb .BytesPerLine +x >>3;
if _cbgg > len (_abcb .Data )-1{return ;};_fee :=_abcb .ColorModel ().Convert (c ).(_d .Gray );_abcb .setGray (x ,_fee ,_cbgg );};func _gdeb (_adged *Monochrome ,_fgea ,_degg ,_cbgd ,_agda int ,_afcd RasterOperator ,_dbca *Monochrome ,_gcbf ,_ddg int )error {var (_agca bool ;
_cacfd bool ;_efeba int ;_bcbd int ;_bgc int ;_acbb bool ;_dbgd byte ;_eggc int ;_ceaa int ;_aacd int ;_afef ,_gbfb int ;);_ffeae :=8-(_fgea &7);_aabg :=_gfgg [_ffeae ];_acda :=_adged .BytesPerLine *_degg +(_fgea >>3);_ffed :=_dbca .BytesPerLine *_ddg +(_gcbf >>3);
if _cbgd < _ffeae {_agca =true ;_aabg &=_ebca [8-_ffeae +_cbgd ];};if !_agca {_efeba =(_cbgd -_ffeae )>>3;if _efeba > 0{_cacfd =true ;_bcbd =_acda +1;_bgc =_ffed +1;};};_eggc =(_fgea +_cbgd )&7;if !(_agca ||_eggc ==0){_acbb =true ;_dbgd =_ebca [_eggc ];
_ceaa =_acda +1+_efeba ;_aacd =_ffed +1+_efeba ;};switch _afcd {case PixSrc :for _afef =0;_afef < _agda ;_afef ++{_adged .Data [_acda ]=_dabf (_adged .Data [_acda ],_dbca .Data [_ffed ],_aabg );_acda +=_adged .BytesPerLine ;_ffed +=_dbca .BytesPerLine ;
};if _cacfd {for _afef =0;_afef < _agda ;_afef ++{for _gbfb =0;_gbfb < _efeba ;_gbfb ++{_adged .Data [_bcbd +_gbfb ]=_dbca .Data [_bgc +_gbfb ];};_bcbd +=_adged .BytesPerLine ;_bgc +=_dbca .BytesPerLine ;};};if _acbb {for _afef =0;_afef < _agda ;_afef ++{_adged .Data [_ceaa ]=_dabf (_adged .Data [_ceaa ],_dbca .Data [_aacd ],_dbgd );
_ceaa +=_adged .BytesPerLine ;_aacd +=_dbca .BytesPerLine ;};};case PixNotSrc :for _afef =0;_afef < _agda ;_afef ++{_adged .Data [_acda ]=_dabf (_adged .Data [_acda ],^_dbca .Data [_ffed ],_aabg );_acda +=_adged .BytesPerLine ;_ffed +=_dbca .BytesPerLine ;
};if _cacfd {for _afef =0;_afef < _agda ;_afef ++{for _gbfb =0;_gbfb < _efeba ;_gbfb ++{_adged .Data [_bcbd +_gbfb ]=^_dbca .Data [_bgc +_gbfb ];};_bcbd +=_adged .BytesPerLine ;_bgc +=_dbca .BytesPerLine ;};};if _acbb {for _afef =0;_afef < _agda ;_afef ++{_adged .Data [_ceaa ]=_dabf (_adged .Data [_ceaa ],^_dbca .Data [_aacd ],_dbgd );
_ceaa +=_adged .BytesPerLine ;_aacd +=_dbca .BytesPerLine ;};};case PixSrcOrDst :for _afef =0;_afef < _agda ;_afef ++{_adged .Data [_acda ]=_dabf (_adged .Data [_acda ],_dbca .Data [_ffed ]|_adged .Data [_acda ],_aabg );_acda +=_adged .BytesPerLine ;_ffed +=_dbca .BytesPerLine ;
};if _cacfd {for _afef =0;_afef < _agda ;_afef ++{for _gbfb =0;_gbfb < _efeba ;_gbfb ++{_adged .Data [_bcbd +_gbfb ]|=_dbca .Data [_bgc +_gbfb ];};_bcbd +=_adged .BytesPerLine ;_bgc +=_dbca .BytesPerLine ;};};if _acbb {for _afef =0;_afef < _agda ;_afef ++{_adged .Data [_ceaa ]=_dabf (_adged .Data [_ceaa ],_dbca .Data [_aacd ]|_adged .Data [_ceaa ],_dbgd );
_ceaa +=_adged .BytesPerLine ;_aacd +=_dbca .BytesPerLine ;};};case PixSrcAndDst :for _afef =0;_afef < _agda ;_afef ++{_adged .Data [_acda ]=_dabf (_adged .Data [_acda ],_dbca .Data [_ffed ]&_adged .Data [_acda ],_aabg );_acda +=_adged .BytesPerLine ;_ffed +=_dbca .BytesPerLine ;
};if _cacfd {for _afef =0;_afef < _agda ;_afef ++{for _gbfb =0;_gbfb < _efeba ;_gbfb ++{_adged .Data [_bcbd +_gbfb ]&=_dbca .Data [_bgc +_gbfb ];};_bcbd +=_adged .BytesPerLine ;_bgc +=_dbca .BytesPerLine ;};};if _acbb {for _afef =0;_afef < _agda ;_afef ++{_adged .Data [_ceaa ]=_dabf (_adged .Data [_ceaa ],_dbca .Data [_aacd ]&_adged .Data [_ceaa ],_dbgd );
_ceaa +=_adged .BytesPerLine ;_aacd +=_dbca .BytesPerLine ;};};case PixSrcXorDst :for _afef =0;_afef < _agda ;_afef ++{_adged .Data [_acda ]=_dabf (_adged .Data [_acda ],_dbca .Data [_ffed ]^_adged .Data [_acda ],_aabg );_acda +=_adged .BytesPerLine ;_ffed +=_dbca .BytesPerLine ;
};if _cacfd {for _afef =0;_afef < _agda ;_afef ++{for _gbfb =0;_gbfb < _efeba ;_gbfb ++{_adged .Data [_bcbd +_gbfb ]^=_dbca .Data [_bgc +_gbfb ];};_bcbd +=_adged .BytesPerLine ;_bgc +=_dbca .BytesPerLine ;};};if _acbb {for _afef =0;_afef < _agda ;_afef ++{_adged .Data [_ceaa ]=_dabf (_adged .Data [_ceaa ],_dbca .Data [_aacd ]^_adged .Data [_ceaa ],_dbgd );
_ceaa +=_adged .BytesPerLine ;_aacd +=_dbca .BytesPerLine ;};};case PixNotSrcOrDst :for _afef =0;_afef < _agda ;_afef ++{_adged .Data [_acda ]=_dabf (_adged .Data [_acda ],^(_dbca .Data [_ffed ])|_adged .Data [_acda ],_aabg );_acda +=_adged .BytesPerLine ;
_ffed +=_dbca .BytesPerLine ;};if _cacfd {for _afef =0;_afef < _agda ;_afef ++{for _gbfb =0;_gbfb < _efeba ;_gbfb ++{_adged .Data [_bcbd +_gbfb ]|=^(_dbca .Data [_bgc +_gbfb ]);};_bcbd +=_adged .BytesPerLine ;_bgc +=_dbca .BytesPerLine ;};};if _acbb {for _afef =0;
_afef < _agda ;_afef ++{_adged .Data [_ceaa ]=_dabf (_adged .Data [_ceaa ],^(_dbca .Data [_aacd ])|_adged .Data [_ceaa ],_dbgd );_ceaa +=_adged .BytesPerLine ;_aacd +=_dbca .BytesPerLine ;};};case PixNotSrcAndDst :for _afef =0;_afef < _agda ;_afef ++{_adged .Data [_acda ]=_dabf (_adged .Data [_acda ],^(_dbca .Data [_ffed ])&_adged .Data [_acda ],_aabg );
_acda +=_adged .BytesPerLine ;_ffed +=_dbca .BytesPerLine ;};if _cacfd {for _afef =0;_afef < _agda ;_afef ++{for _gbfb =0;_gbfb < _efeba ;_gbfb ++{_adged .Data [_bcbd +_gbfb ]&=^_dbca .Data [_bgc +_gbfb ];};_bcbd +=_adged .BytesPerLine ;_bgc +=_dbca .BytesPerLine ;
};};if _acbb {for _afef =0;_afef < _agda ;_afef ++{_adged .Data [_ceaa ]=_dabf (_adged .Data [_ceaa ],^(_dbca .Data [_aacd ])&_adged .Data [_ceaa ],_dbgd );_ceaa +=_adged .BytesPerLine ;_aacd +=_dbca .BytesPerLine ;};};case PixSrcOrNotDst :for _afef =0;
_afef < _agda ;_afef ++{_adged .Data [_acda ]=_dabf (_adged .Data [_acda ],_dbca .Data [_ffed ]|^(_adged .Data [_acda ]),_aabg );_acda +=_adged .BytesPerLine ;_ffed +=_dbca .BytesPerLine ;};if _cacfd {for _afef =0;_afef < _agda ;_afef ++{for _gbfb =0;_gbfb < _efeba ;
_gbfb ++{_adged .Data [_bcbd +_gbfb ]=_dbca .Data [_bgc +_gbfb ]|^(_adged .Data [_bcbd +_gbfb ]);};_bcbd +=_adged .BytesPerLine ;_bgc +=_dbca .BytesPerLine ;};};if _acbb {for _afef =0;_afef < _agda ;_afef ++{_adged .Data [_ceaa ]=_dabf (_adged .Data [_ceaa ],_dbca .Data [_aacd ]|^(_adged .Data [_ceaa ]),_dbgd );
_ceaa +=_adged .BytesPerLine ;_aacd +=_dbca .BytesPerLine ;};};case PixSrcAndNotDst :for _afef =0;_afef < _agda ;_afef ++{_adged .Data [_acda ]=_dabf (_adged .Data [_acda ],_dbca .Data [_ffed ]&^(_adged .Data [_acda ]),_aabg );_acda +=_adged .BytesPerLine ;
_ffed +=_dbca .BytesPerLine ;};if _cacfd {for _afef =0;_afef < _agda ;_afef ++{for _gbfb =0;_gbfb < _efeba ;_gbfb ++{_adged .Data [_bcbd +_gbfb ]=_dbca .Data [_bgc +_gbfb ]&^(_adged .Data [_bcbd +_gbfb ]);};_bcbd +=_adged .BytesPerLine ;_bgc +=_dbca .BytesPerLine ;
};};if _acbb {for _afef =0;_afef < _agda ;_afef ++{_adged .Data [_ceaa ]=_dabf (_adged .Data [_ceaa ],_dbca .Data [_aacd ]&^(_adged .Data [_ceaa ]),_dbgd );_ceaa +=_adged .BytesPerLine ;_aacd +=_dbca .BytesPerLine ;};};case PixNotPixSrcOrDst :for _afef =0;
_afef < _agda ;_afef ++{_adged .Data [_acda ]=_dabf (_adged .Data [_acda ],^(_dbca .Data [_ffed ]|_adged .Data [_acda ]),_aabg );_acda +=_adged .BytesPerLine ;_ffed +=_dbca .BytesPerLine ;};if _cacfd {for _afef =0;_afef < _agda ;_afef ++{for _gbfb =0;_gbfb < _efeba ;
_gbfb ++{_adged .Data [_bcbd +_gbfb ]=^(_dbca .Data [_bgc +_gbfb ]|_adged .Data [_bcbd +_gbfb ]);};_bcbd +=_adged .BytesPerLine ;_bgc +=_dbca .BytesPerLine ;};};if _acbb {for _afef =0;_afef < _agda ;_afef ++{_adged .Data [_ceaa ]=_dabf (_adged .Data [_ceaa ],^(_dbca .Data [_aacd ]|_adged .Data [_ceaa ]),_dbgd );
_ceaa +=_adged .BytesPerLine ;_aacd +=_dbca .BytesPerLine ;};};case PixNotPixSrcAndDst :for _afef =0;_afef < _agda ;_afef ++{_adged .Data [_acda ]=_dabf (_adged .Data [_acda ],^(_dbca .Data [_ffed ]&_adged .Data [_acda ]),_aabg );_acda +=_adged .BytesPerLine ;
_ffed +=_dbca .BytesPerLine ;};if _cacfd {for _afef =0;_afef < _agda ;_afef ++{for _gbfb =0;_gbfb < _efeba ;_gbfb ++{_adged .Data [_bcbd +_gbfb ]=^(_dbca .Data [_bgc +_gbfb ]&_adged .Data [_bcbd +_gbfb ]);};_bcbd +=_adged .BytesPerLine ;_bgc +=_dbca .BytesPerLine ;
};};if _acbb {for _afef =0;_afef < _agda ;_afef ++{_adged .Data [_ceaa ]=_dabf (_adged .Data [_ceaa ],^(_dbca .Data [_aacd ]&_adged .Data [_ceaa ]),_dbgd );_ceaa +=_adged .BytesPerLine ;_aacd +=_dbca .BytesPerLine ;};};case PixNotPixSrcXorDst :for _afef =0;
_afef < _agda ;_afef ++{_adged .Data [_acda ]=_dabf (_adged .Data [_acda ],^(_dbca .Data [_ffed ]^_adged .Data [_acda ]),_aabg );_acda +=_adged .BytesPerLine ;_ffed +=_dbca .BytesPerLine ;};if _cacfd {for _afef =0;_afef < _agda ;_afef ++{for _gbfb =0;_gbfb < _efeba ;
_gbfb ++{_adged .Data [_bcbd +_gbfb ]=^(_dbca .Data [_bgc +_gbfb ]^_adged .Data [_bcbd +_gbfb ]);};_bcbd +=_adged .BytesPerLine ;_bgc +=_dbca .BytesPerLine ;};};if _acbb {for _afef =0;_afef < _agda ;_afef ++{_adged .Data [_ceaa ]=_dabf (_adged .Data [_ceaa ],^(_dbca .Data [_aacd ]^_adged .Data [_ceaa ]),_dbgd );
_ceaa +=_adged .BytesPerLine ;_aacd +=_dbca .BytesPerLine ;};};default:_g .Log .Debug ("I\u006e\u0076\u0061\u006c\u0069\u0064 \u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070e\u0072\u0061\u0074o\u0072:\u0020\u0025\u0064",_afcd );return _ac .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072");
};return nil ;};func (_gebg *Gray4 )Base ()*ImageBase {return &_gebg .ImageBase };func (_bcdf *Monochrome )ColorModel ()_d .Model {return MonochromeModel (_bcdf .ModelThreshold )};func _ef ()(_adc [256]uint16 ){for _cea :=0;_cea < 256;_cea ++{if _cea &0x01!=0{_adc [_cea ]|=0x3;
};if _cea &0x02!=0{_adc [_cea ]|=0xc;};if _cea &0x04!=0{_adc [_cea ]|=0x30;};if _cea &0x08!=0{_adc [_cea ]|=0xc0;};if _cea &0x10!=0{_adc [_cea ]|=0x300;};if _cea &0x20!=0{_adc [_cea ]|=0xc00;};if _cea &0x40!=0{_adc [_cea ]|=0x3000;};if _cea &0x80!=0{_adc [_cea ]|=0xc000;
};};return _adc ;};var ErrInvalidImage =_ac .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
type SMasker interface{HasAlpha ()bool ;GetAlpha ()[]byte ;MakeAlpha ();};func (_egce *Gray8 )At (x ,y int )_d .Color {_ffc ,_ :=_egce .ColorAt (x ,y );return _ffc };func (_fac *Monochrome )setGray (_abgb int ,_dgdgd _d .Gray ,_gcb int ){if _dgdgd .Y ==0{_fac .clearBit (_gcb ,_abgb );
}else {_fac .setGrayBit (_gcb ,_abgb );};};func (_aba *Gray4 )Copy ()Image {return &Gray4 {ImageBase :_aba .copy ()}};func (_geec *Gray16 )Copy ()Image {return &Gray16 {ImageBase :_geec .copy ()}};type ColorConverter interface{Convert (_abbg _de .Image )(Image ,error );
};func ColorAtCMYK (x ,y ,width int ,data []byte ,decode []float64 )(_d .CMYK ,error ){_fbc :=4*(y *width +x );if _fbc +3>=len (data ){return _d .CMYK {},_fa .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};C :=data [_fbc ]&0xff;M :=data [_fbc +1]&0xff;Y :=data [_fbc +2]&0xff;K :=data [_fbc +3]&0xff;if len (decode )==8{C =uint8 (uint32 (LinearInterpolate (float64 (C ),0,255,decode [0],decode [1]))&0xff);M =uint8 (uint32 (LinearInterpolate (float64 (M ),0,255,decode [2],decode [3]))&0xff);
Y =uint8 (uint32 (LinearInterpolate (float64 (Y ),0,255,decode [4],decode [5]))&0xff);K =uint8 (uint32 (LinearInterpolate (float64 (K ),0,255,decode [6],decode [7]))&0xff);};return _d .CMYK {C :C ,M :M ,Y :Y ,K :K },nil ;};func (_dgeab *NRGBA16 )At (x ,y int )_d .Color {_aagbc ,_ :=_dgeab .ColorAt (x ,y );
return _aagbc };func _fab (_bdfb _d .Gray )_d .Gray {_fcaa :=_bdfb .Y >>6;_fcaa |=_fcaa <<2;_bdfb .Y =_fcaa |_fcaa <<4;return _bdfb ;};func _cfd (_dgdg RGBA ,_bgg CMYK ,_gca _de .Rectangle ){for _ebc :=0;_ebc < _gca .Max .X ;_ebc ++{for _dgbe :=0;_dgbe < _gca .Max .Y ;
_dgbe ++{_caga :=_dgdg .RGBAAt (_ebc ,_dgbe );_bgg .SetCMYK (_ebc ,_dgbe ,_abd (_caga ));};};};func (_agbd *Monochrome )ResolveDecode ()error {if len (_agbd .Decode )!=2{return nil ;};if _agbd .Decode [0]==1&&_agbd .Decode [1]==0{if _dgg :=_agbd .InverseData ();
_dgg !=nil {return _dgg ;};_agbd .Decode =nil ;};return nil ;};func (_edda *NRGBA16 )SetNRGBA (x ,y int ,c _d .NRGBA ){_edfca :=y *_edda .BytesPerLine +x *3/2;if _edfca +1>=len (_edda .Data ){return ;};c =_gcac (c );_edda .setNRGBA (x ,y ,_edfca ,c );};
func _dgda (_cce _de .Image ,_fdbc int )(_de .Rectangle ,bool ,[]byte ){_bbda :=_cce .Bounds ();var (_fefc bool ;_eegc []byte ;);switch _ddce :=_cce .(type ){case SMasker :_fefc =_ddce .HasAlpha ();case NRGBA ,RGBA ,*_de .RGBA64 ,nrgba64 ,*_de .NYCbCrA :_eegc =make ([]byte ,_bbda .Max .X *_bbda .Max .Y *_fdbc );
case *_de .Paletted :var _gcba bool ;for _ ,_cfff :=range _ddce .Palette {_gdda ,_cbeb ,_degd ,_cgdfg :=_cfff .RGBA ();if _gdda ==0&&_cbeb ==0&&_degd ==0&&_cgdfg !=0{_gcba =true ;break ;};};if _gcba {_eegc =make ([]byte ,_bbda .Max .X *_bbda .Max .Y *_fdbc );
};};return _bbda ,_fefc ,_eegc ;};var _ Image =&CMYK32 {};func MonochromeModel (threshold uint8 )_d .Model {return monochromeModel (threshold )};func (_dggc *Gray4 )Histogram ()(_fec [256]int ){for _dbcge :=0;_dbcge < _dggc .Width ;_dbcge ++{for _agab :=0;
_agab < _dggc .Height ;_agab ++{_fec [_dggc .GrayAt (_dbcge ,_agab ).Y ]++;};};return _fec ;};func (_dcdc *NRGBA16 )ColorAt (x ,y int )(_d .Color ,error ){return ColorAtNRGBA16 (x ,y ,_dcdc .Width ,_dcdc .BytesPerLine ,_dcdc .Data ,_dcdc .Alpha ,_dcdc .Decode );
};func (_aff *Monochrome )Copy ()Image {return &Monochrome {ImageBase :_aff .ImageBase .copy (),ModelThreshold :_aff .ModelThreshold };};func init (){_afa ()};func _efad (_eceef uint )uint {var _bffbb uint ;for _eceef !=0{_eceef >>=1;_bffbb ++;};return _bffbb -1;
};var _ Image =&NRGBA32 {};func _efe (_acbc Gray ,_eeae NRGBA ,_cgag _de .Rectangle ){for _efffb :=0;_efffb < _cgag .Max .X ;_efffb ++{for _bgbe :=0;_bgbe < _cgag .Max .Y ;_bgbe ++{_dfe :=_cdee (_eeae .NRGBAAt (_efffb ,_bgbe ));_acbc .SetGray (_efffb ,_bgbe ,_dfe );
};};};func _daad (_cgcg NRGBA ,_daga CMYK ,_dcge _de .Rectangle ){for _fgb :=0;_fgb < _dcge .Max .X ;_fgb ++{for _acac :=0;_acac < _dcge .Max .Y ;_acac ++{_afbf :=_cgcg .NRGBAAt (_fgb ,_acac );_daga .SetCMYK (_fgb ,_acac ,_bcd (_afbf ));};};};func GetConverter (bitsPerComponent ,colorComponents int )(ColorConverter ,error ){switch colorComponents {case 1:switch bitsPerComponent {case 1:return MonochromeConverter ,nil ;
case 2:return Gray2Converter ,nil ;case 4:return Gray4Converter ,nil ;case 8:return GrayConverter ,nil ;case 16:return Gray16Converter ,nil ;};case 3:switch bitsPerComponent {case 4:return NRGBA16Converter ,nil ;case 8:return NRGBAConverter ,nil ;case 16:return NRGBA64Converter ,nil ;
};case 4:return CMYKConverter ,nil ;};return nil ,_fa .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0043o\u006e\u0076\u0065\u0072\u0074\u0065\u0072\u0020\u0070\u0061\u0072\u0061\u006d\u0065t\u0065\u0072\u0073\u002e\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003a\u0020\u0025\u0064\u002c\u0020\u0043\u006f\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006et\u0073\u003a \u0025\u0064",bitsPerComponent ,colorComponents );
};func (_daadf *NRGBA16 )Validate ()error {if len (_daadf .Data )!=3*_daadf .Width *_daadf .Height /2{return _ac .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};var _ _de .Image =&Gray4 {};func (_fcac *Monochrome )ColorAt (x ,y int )(_d .Color ,error ){return ColorAtGray1BPC (x ,y ,_fcac .BytesPerLine ,_fcac .Data ,_fcac .Decode );};func (_fbag *ImageBase )MakeAlpha (){_fbag .newAlpha ()};func _adf (_ccbe _d .RGBA )_d .Gray {_afee :=(19595*uint32 (_ccbe .R )+38470*uint32 (_ccbe .G )+7471*uint32 (_ccbe .B )+1<<7)>>16;
return _d .Gray {Y :uint8 (_afee )};};func (_eeed *Gray4 )setGray (_fba int ,_cada int ,_edba _d .Gray ){_dgde :=_cada *_eeed .BytesPerLine ;_ggeb :=_dgde +(_fba >>1);if _ggeb >=len (_eeed .Data ){return ;};_gcd :=_edba .Y >>4;_eeed .Data [_ggeb ]=(_eeed .Data [_ggeb ]&(^(0xf0>>uint (4*(_fba &1)))))|(_gcd <<uint (4-4*(_fba &1)));
};func RasterOperation (dest *Monochrome ,dx ,dy ,dw ,dh int ,op RasterOperator ,src *Monochrome ,sx ,sy int )error {return _feg (dest ,dx ,dy ,dw ,dh ,op ,src ,sx ,sy );};func _cbga (_bdgd *_de .Gray )bool {for _dffg :=0;_dffg < len (_bdgd .Pix );_dffg ++{if !_dcae (_bdgd .Pix [_dffg ]){return false ;
};};return true ;};func _abd (_eed _d .RGBA )_d .CMYK {_cdec ,_fbd ,_egcc ,_egg :=_d .RGBToCMYK (_eed .R ,_eed .G ,_eed .B );return _d .CMYK {C :_cdec ,M :_fbd ,Y :_egcc ,K :_egg };};func (_agdg *NRGBA32 )setRGBA (_affc int ,_bebfe _d .NRGBA ){_dcfc :=3*_affc ;
_agdg .Data [_dcfc ]=_bebfe .R ;_agdg .Data [_dcfc +1]=_bebfe .G ;_agdg .Data [_dcfc +2]=_bebfe .B ;if _affc < len (_agdg .Alpha ){_agdg .Alpha [_affc ]=_bebfe .A ;};};var _ Gray =&Gray2 {};func (_dbgf *Gray4 )Set (x ,y int ,c _d .Color ){if x >=_dbgf .Width ||y >=_dbgf .Height {return ;
};_agaf :=Gray4Model .Convert (c ).(_d .Gray );_dbgf .setGray (x ,y ,_agaf );};func (_ffag *ImageBase )setTwoBytes (_geda int ,_gcc uint16 )error {if _geda +1> len (_ffag .Data )-1{return _ac .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_ffag .Data [_geda ]=byte ((_gcc &0xff00)>>8);_ffag .Data [_geda +1]=byte (_gcc &0xff);return nil ;};func (_ebfb *Gray16 )ColorAt (x ,y int )(_d .Color ,error ){return ColorAtGray16BPC (x ,y ,_ebfb .BytesPerLine ,_ebfb .Data ,_ebfb .Decode );};func (_dba *Monochrome )Histogram ()(_dcfe [256]int ){for _ ,_eeef :=range _dba .Data {_dcfe [0xff]+=int (_baba [_dba .Data [_eeef ]]);
};return _dcfe ;};func (_bebf *Monochrome )copy ()*Monochrome {_bcb :=_afeg (_bebf .Width ,_bebf .Height );_bcb .ModelThreshold =_bebf .ModelThreshold ;_bcb .Data =make ([]byte ,len (_bebf .Data ));copy (_bcb .Data ,_bebf .Data );if len (_bebf .Decode )!=0{_bcb .Decode =make ([]float64 ,len (_bebf .Decode ));
copy (_bcb .Decode ,_bebf .Decode );};if len (_bebf .Alpha )!=0{_bcb .Alpha =make ([]byte ,len (_bebf .Alpha ));copy (_bcb .Alpha ,_bebf .Alpha );};return _bcb ;};func (_gce *Gray16 )Validate ()error {if len (_gce .Data )!=_gce .Height *_gce .BytesPerLine {return ErrInvalidImage ;
};return nil ;};func (_fcbb *NRGBA32 )SetNRGBA (x ,y int ,c _d .NRGBA ){_bafac :=y *_fcbb .Width +x ;_ccge :=3*_bafac ;if _ccge +2>=len (_fcbb .Data ){return ;};_fcbb .setRGBA (_bafac ,c );};func _efdf (_dfca _d .NYCbCrA )_d .NRGBA {_eec :=int32 (_dfca .Y )*0x10101;
_eea :=int32 (_dfca .Cb )-128;_aaa :=int32 (_dfca .Cr )-128;_eeec :=_eec +91881*_aaa ;if uint32 (_eeec )&0xff000000==0{_eeec >>=8;}else {_eeec =^(_eeec >>31)&0xffff;};_edb :=_eec -22554*_eea -46802*_aaa ;if uint32 (_edb )&0xff000000==0{_edb >>=8;}else {_edb =^(_edb >>31)&0xffff;
};_fefd :=_eec +116130*_eea ;if uint32 (_fefd )&0xff000000==0{_fefd >>=8;}else {_fefd =^(_fefd >>31)&0xffff;};return _d .NRGBA {R :uint8 (_eeec >>8),G :uint8 (_edb >>8),B :uint8 (_fefd >>8),A :_dfca .A };};func _adce (_gedb *Monochrome ,_dacb ,_fccbe ,_dcaf ,_abed int ,_aeca RasterOperator ){if _dacb < 0{_dcaf +=_dacb ;
_dacb =0;};_dgfe :=_dacb +_dcaf -_gedb .Width ;if _dgfe > 0{_dcaf -=_dgfe ;};if _fccbe < 0{_abed +=_fccbe ;_fccbe =0;};_ddeg :=_fccbe +_abed -_gedb .Height ;if _ddeg > 0{_abed -=_ddeg ;};if _dcaf <=0||_abed <=0{return ;};if (_dacb &7)==0{_fbba (_gedb ,_dacb ,_fccbe ,_dcaf ,_abed ,_aeca );
}else {_fccba (_gedb ,_dacb ,_fccbe ,_dcaf ,_abed ,_aeca );};};func (_gef *Gray2 )Set (x ,y int ,c _d .Color ){if x >=_gef .Width ||y >=_gef .Height {return ;};_cgad :=Gray2Model .Convert (c ).(_d .Gray );_bcee :=y *_gef .BytesPerLine ;_ddad :=_bcee +(x >>2);
_bgga :=_cgad .Y >>6;_gef .Data [_ddad ]=(_gef .Data [_ddad ]&(^(0xc0>>uint (2*((x )&3)))))|(_bgga <<uint (6-2*(x &3)));};func _gebgg (_edd _d .Color )_d .Color {_becb :=_d .NRGBAModel .Convert (_edd ).(_d .NRGBA );return _gcac (_becb );};func (_gaa *NRGBA16 )Set (x ,y int ,c _d .Color ){_dbbf :=y *_gaa .BytesPerLine +x *3/2;
if _dbbf +1>=len (_gaa .Data ){return ;};_agec :=NRGBA16Model .Convert (c ).(_d .NRGBA );_gaa .setNRGBA (x ,y ,_dbbf ,_agec );};var _ Image =&Gray2 {};var _ Image =&NRGBA64 {};func InDelta (expected ,current ,delta float64 )bool {_ffea :=expected -current ;
if _ffea <=-delta ||_ffea >=delta {return false ;};return true ;};func (_afega *Gray2 )SetGray (x ,y int ,gray _d .Gray ){_eba :=_fab (gray );_afg :=y *_afega .BytesPerLine ;_adgg :=_afg +(x >>2);if _adgg >=len (_afega .Data ){return ;};_acba :=_eba .Y >>6;
_afega .Data [_adgg ]=(_afega .Data [_adgg ]&(^(0xc0>>uint (2*((x )&3)))))|(_acba <<uint (6-2*(x &3)));};func (_fgg *Monochrome )RasterOperation (dx ,dy ,dw ,dh int ,op RasterOperator ,src *Monochrome ,sx ,sy int )error {return _feg (_fgg ,dx ,dy ,dw ,dh ,op ,src ,sx ,sy );
};func (_gegd *Monochrome )ReduceBinary (factor float64 )(*Monochrome ,error ){_befc :=_efad (uint (factor ));if !IsPowerOf2 (uint (factor )){_befc ++;};_feaf :=make ([]int ,_befc );for _bcf :=range _feaf {_feaf [_bcf ]=4;};_bceg ,_gabe :=_fcg (_gegd ,_feaf ...);
if _gabe !=nil {return nil ,_gabe ;};return _bceg ,nil ;};func (_ggge *Monochrome )getBitAt (_fcab ,_bac int )bool {_adafd :=_bac *_ggge .BytesPerLine +(_fcab >>3);_ddf :=_fcab &0x07;_dfbb :=uint (7-_ddf );if _adafd > len (_ggge .Data )-1{return false ;
};if (_ggge .Data [_adafd ]>>_dfbb )&0x01>=1{return true ;};return false ;};func _acc ()(_feff [256]uint64 ){for _ada :=0;_ada < 256;_ada ++{if _ada &0x01!=0{_feff [_ada ]|=0xff;};if _ada &0x02!=0{_feff [_ada ]|=0xff00;};if _ada &0x04!=0{_feff [_ada ]|=0xff0000;
};if _ada &0x08!=0{_feff [_ada ]|=0xff000000;};if _ada &0x10!=0{_feff [_ada ]|=0xff00000000;};if _ada &0x20!=0{_feff [_ada ]|=0xff0000000000;};if _ada &0x40!=0{_feff [_ada ]|=0xff000000000000;};if _ada &0x80!=0{_feff [_ada ]|=0xff00000000000000;};};return _feff ;
};func ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine int ,data []byte ,decode []float64 )(_d .Color ,error ){switch bitsPerColor {case 1:return ColorAtGray1BPC (x ,y ,bytesPerLine ,data ,decode );case 2:return ColorAtGray2BPC (x ,y ,bytesPerLine ,data ,decode );
case 4:return ColorAtGray4BPC (x ,y ,bytesPerLine ,data ,decode );case 8:return ColorAtGray8BPC (x ,y ,bytesPerLine ,data ,decode );case 16:return ColorAtGray16BPC (x ,y ,bytesPerLine ,data ,decode );default:return nil ,_fa .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0067\u0072\u0061\u0079\u0020\u0073c\u0061\u006c\u0065\u0020\u0062\u0069\u0074s\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020a\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );
};};func _cfcef (_fgdab *_de .NYCbCrA ,_aaec NRGBA ,_abdf _de .Rectangle ){for _dfced :=0;_dfced < _abdf .Max .X ;_dfced ++{for _bace :=0;_bace < _abdf .Max .Y ;_bace ++{_faed :=_fgdab .NYCbCrAAt (_dfced ,_bace );_aaec .SetNRGBA (_dfced ,_bace ,_efdf (_faed ));
};};};func (_cefac *ImageBase )HasAlpha ()bool {if _cefac .Alpha ==nil {return false ;};for _abdd :=range _cefac .Alpha {if _cefac .Alpha [_abdd ]!=0xff{return true ;};};return false ;};func (_ddc *Gray4 )At (x ,y int )_d .Color {_gded ,_ :=_ddc .ColorAt (x ,y );
return _gded };func _bbd (_eedf _de .Image ,_cfef Image ,_ffa _de .Rectangle ){switch _gbda :=_eedf .(type ){case Gray :_aeac (_gbda ,_cfef .(Gray ),_ffa );case NRGBA :_acfe (_gbda ,_cfef .(Gray ),_ffa );case CMYK :_cecf (_gbda ,_cfef .(Gray ),_ffa );case RGBA :_gba (_gbda ,_cfef .(Gray ),_ffa );
default:_fea (_eedf ,_cfef .(Image ),_ffa );};};func _bcedd (_abfa _d .Color )_d .Color {_egf :=_d .GrayModel .Convert (_abfa ).(_d .Gray );return _eeg (_egf );};func (_cbc *Gray2 )Histogram ()(_dagb [256]int ){for _bfc :=0;_bfc < _cbc .Width ;_bfc ++{for _cffe :=0;
_cffe < _cbc .Height ;_cffe ++{_dagb [_cbc .GrayAt (_bfc ,_cffe ).Y ]++;};};return _dagb ;};func (_dccg *Gray4 )ColorModel ()_d .Model {return Gray4Model };func (_cffg *Gray8 )Set (x ,y int ,c _d .Color ){_fecd :=y *_cffg .BytesPerLine +x ;if _fecd > len (_cffg .Data )-1{return ;
};_abbgf :=_d .GrayModel .Convert (c );_cffg .Data [_fecd ]=_abbgf .(_d .Gray ).Y ;};func (_gfga *Monochrome )setIndexedBit (_ecdb int ){_gfga .Data [(_ecdb >>3)]|=0x80>>uint (_ecdb &7)};func (_caea *ImageBase )getByte (_bdce int )(byte ,error ){if _bdce > len (_caea .Data )-1||_bdce < 0{return 0,_fa .Errorf ("\u0069\u006e\u0064\u0065x:\u0020\u0025\u0064\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006eg\u0065",_bdce );
};return _caea .Data [_bdce ],nil ;};func (_fccc *Gray4 )Bounds ()_de .Rectangle {return _de .Rectangle {Max :_de .Point {X :_fccc .Width ,Y :_fccc .Height }};};func (_afgb *Gray8 )Bounds ()_de .Rectangle {return _de .Rectangle {Max :_de .Point {X :_afgb .Width ,Y :_afgb .Height }};
};func (_eggf *ImageBase )setFourBytes (_abgd int ,_cgagc uint32 )error {if _abgd +3> len (_eggf .Data )-1{return _fa .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006fu\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065",_abgd );
};_eggf .Data [_abgd ]=byte ((_cgagc &0xff000000)>>24);_eggf .Data [_abgd +1]=byte ((_cgagc &0xff0000)>>16);_eggf .Data [_abgd +2]=byte ((_cgagc &0xff00)>>8);_eggf .Data [_abgd +3]=byte (_cgagc &0xff);return nil ;};func _aeac (_cge ,_dgeg Gray ,_befe _de .Rectangle ){for _cddg :=0;
_cddg < _befe .Max .X ;_cddg ++{for _dbf :=0;_dbf < _befe .Max .Y ;_dbf ++{_dgeg .SetGray (_cddg ,_dbf ,_cge .GrayAt (_cddg ,_dbf ));};};};var _ Gray =&Gray8 {};func _bdfe (_bdea *_de .Gray ,_gacc uint8 )*_de .Gray {_gdcc :=_bdea .Bounds ();_cfbg :=_de .NewGray (_gdcc );
for _gcdf :=0;_gcdf < _gdcc .Dx ();_gcdf ++{for _gaca :=0;_gaca < _gdcc .Dy ();_gaca ++{_fddab :=_bdea .GrayAt (_gcdf ,_gaca );_cfbg .SetGray (_gcdf ,_gaca ,_d .Gray {Y :_geagg (_fddab .Y ,_gacc )});};};return _cfbg ;};func NewImageBase (width int ,height int ,bitsPerComponent int ,colorComponents int ,data []byte ,alpha []byte ,decode []float64 )ImageBase {_daaf :=ImageBase {Width :width ,Height :height ,BitsPerComponent :bitsPerComponent ,ColorComponents :colorComponents ,Data :data ,Alpha :alpha ,Decode :decode ,BytesPerLine :BytesPerLine (width ,bitsPerComponent ,colorComponents )};
if data ==nil {_daaf .Data =make ([]byte ,height *_daaf .BytesPerLine );};return _daaf ;};func ColorAtGray1BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_d .Gray ,error ){_fbb :=y *bytesPerLine +x >>3;if _fbb >=len (data ){return _d .Gray {},_fa .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_badc :=data [_fbb ]>>uint (7-(x &7))&1;if len (decode )==2{_badc =uint8 (LinearInterpolate (float64 (_badc ),0.0,1.0,decode [0],decode [1]))&1;};return _d .Gray {Y :_badc *255},nil ;};func _feg (_ecb *Monochrome ,_agbdg ,_edgd ,_bfgb ,_bfcd int ,_fbe RasterOperator ,_abbge *Monochrome ,_cfeb ,_agc int )error {if _ecb ==nil {return _ac .New ("\u006e\u0069\u006c\u0020\u0027\u0064\u0065\u0073\u0074\u0027\u0020\u0042i\u0074\u006d\u0061\u0070");
};if _fbe ==PixDst {return nil ;};switch _fbe {case PixClr ,PixSet ,PixNotDst :_adce (_ecb ,_agbdg ,_edgd ,_bfgb ,_bfcd ,_fbe );return nil ;};if _abbge ==nil {_g .Log .Debug ("\u0052a\u0073\u0074e\u0072\u004f\u0070\u0065r\u0061\u0074\u0069o\u006e\u0020\u0073\u006f\u0075\u0072\u0063\u0065\u0020bi\u0074\u006d\u0061p\u0020\u0069s\u0020\u006e\u006f\u0074\u0020\u0064e\u0066\u0069n\u0065\u0064");
return _ac .New ("\u006e\u0069l\u0020\u0027\u0073r\u0063\u0027\u0020\u0062\u0069\u0074\u006d\u0061\u0070");};if _aedb :=_dcb (_ecb ,_agbdg ,_edgd ,_bfgb ,_bfcd ,_fbe ,_abbge ,_cfeb ,_agc );_aedb !=nil {return _aedb ;};return nil ;};var _ _de .Image =&Gray16 {};
func FromGoImage (i _de .Image )(Image ,error ){switch _fabb :=i .(type ){case Image :return _fabb .Copy (),nil ;case Gray :return GrayConverter .Convert (i );case *_de .Gray16 :return Gray16Converter .Convert (i );case CMYK :return CMYKConverter .Convert (i );
case *_de .NRGBA64 :return NRGBA64Converter .Convert (i );default:return NRGBAConverter .Convert (i );};};func (_dfbc *Gray16 )SetGray (x ,y int ,g _d .Gray ){_abfd :=(y *_dfbc .BytesPerLine /2+x )*2;if _abfd +1>=len (_dfbc .Data ){return ;};_dfbc .Data [_abfd ]=g .Y ;
_dfbc .Data [_abfd +1]=g .Y ;};func _cdab (_gbg _d .CMYK )_d .NRGBA {_ecgb ,_gbd ,_ffd :=_d .CMYKToRGB (_gbg .C ,_gbg .M ,_gbg .Y ,_gbg .K );return _d .NRGBA {R :_ecgb ,G :_gbd ,B :_ffd ,A :0xff};};func (_gdb *Monochrome )AddPadding ()(_gdd error ){if _fdfc :=((_gdb .Width *_gdb .Height )+7)>>3;
len (_gdb .Data )< _fdfc {return _fa .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064a\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002e\u0020\u0054\u0068\u0065\u0020\u0064\u0061t\u0061\u0020s\u0068\u006fu\u006c\u0064\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0020\u0061\u0074 l\u0065\u0061\u0073\u0074\u003a\u0020\u0027\u0025\u0064'\u0020\u0062\u0079\u0074\u0065\u0073",len (_gdb .Data ),_fdfc );
};_ecff :=_gdb .Width %8;if _ecff ==0{return nil ;};_bcdc :=_gdb .Width /8;_fdd :=_fb .NewReader (_gdb .Data );_caaf :=make ([]byte ,_gdb .Height *_gdb .BytesPerLine );_gbe :=_fb .NewWriterMSB (_caaf );_agg :=make ([]byte ,_bcdc );var (_dbeb int ;_bffc uint64 ;
);for _dbeb =0;_dbeb < _gdb .Height ;_dbeb ++{if _ ,_gdd =_fdd .Read (_agg );_gdd !=nil {return _gdd ;};if _ ,_gdd =_gbe .Write (_agg );_gdd !=nil {return _gdd ;};if _bffc ,_gdd =_fdd .ReadBits (byte (_ecff ));_gdd !=nil {return _gdd ;};if _gdd =_gbe .WriteByte (byte (_bffc )<<uint (8-_ecff ));
_gdd !=nil {return _gdd ;};};_gdb .Data =_gbe .Data ();return nil ;};func (_gebcc *Gray4 )SetGray (x ,y int ,g _d .Gray ){if x >=_gebcc .Width ||y >=_gebcc .Height {return ;};g =_eeg (g );_gebcc .setGray (x ,y ,g );};type Monochrome struct{ImageBase ;ModelThreshold uint8 ;
};var (_ebca =[]byte {0x00,0x80,0xC0,0xE0,0xF0,0xF8,0xFC,0xFE,0xFF};_gfgg =[]byte {0x00,0x01,0x03,0x07,0x0F,0x1F,0x3F,0x7F,0xFF};);func (_fgdf *NRGBA32 )Set (x ,y int ,c _d .Color ){_dfbga :=y *_fgdf .Width +x ;_fede :=3*_dfbga ;if _fede +2>=len (_fgdf .Data ){return ;
};_caaa :=_d .NRGBAModel .Convert (c ).(_d .NRGBA );_fgdf .setRGBA (_dfbga ,_caaa );};func _dcae (_ccfb uint8 )bool {if _ccfb ==0||_ccfb ==255{return true ;};return false ;};func _aea (_dbc ,_bca *Monochrome ,_gbc []byte ,_bde int )(_fgf error ){var (_bgdd ,_dfa ,_ece ,_bba ,_cec ,_ace ,_caed ,_cbbg int ;
_afbb ,_dfg uint32 ;_ffe ,_effe byte ;_edfg uint16 ;);_fed :=make ([]byte ,4);_caeg :=make ([]byte ,4);for _ece =0;_ece < _dbc .Height -1;_ece ,_bba =_ece +2,_bba +1{_bgdd =_ece *_dbc .BytesPerLine ;_dfa =_bba *_bca .BytesPerLine ;for _cec ,_ace =0,0;_cec < _bde ;
_cec ,_ace =_cec +4,_ace +1{for _caed =0;_caed < 4;_caed ++{_cbbg =_bgdd +_cec +_caed ;if _cbbg <=len (_dbc .Data )-1&&_cbbg < _bgdd +_dbc .BytesPerLine {_fed [_caed ]=_dbc .Data [_cbbg ];}else {_fed [_caed ]=0x00;};_cbbg =_bgdd +_dbc .BytesPerLine +_cec +_caed ;
if _cbbg <=len (_dbc .Data )-1&&_cbbg < _bgdd +(2*_dbc .BytesPerLine ){_caeg [_caed ]=_dbc .Data [_cbbg ];}else {_caeg [_caed ]=0x00;};};_afbb =_bg .BigEndian .Uint32 (_fed );_dfg =_bg .BigEndian .Uint32 (_caeg );_dfg &=_afbb ;_dfg &=_dfg <<1;_dfg &=0xaaaaaaaa;
_afbb =_dfg |(_dfg <<7);_ffe =byte (_afbb >>24);_effe =byte ((_afbb >>8)&0xff);_cbbg =_dfa +_ace ;if _cbbg +1==len (_bca .Data )-1||_cbbg +1>=_dfa +_bca .BytesPerLine {_bca .Data [_cbbg ]=_gbc [_ffe ];if _fgf =_bca .setByte (_cbbg ,_gbc [_ffe ]);_fgf !=nil {return _fa .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_cbbg );
};}else {_edfg =(uint16 (_gbc [_ffe ])<<8)|uint16 (_gbc [_effe ]);if _fgf =_bca .setTwoBytes (_cbbg ,_edfg );_fgf !=nil {return _fa .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_cbbg );
};_ace ++;};};};return nil ;};func NewImage (width ,height ,bitsPerComponent ,colorComponents int ,data ,alpha []byte ,decode []float64 )(Image ,error ){_ecae :=NewImageBase (width ,height ,bitsPerComponent ,colorComponents ,data ,alpha ,decode );var _dacd Image ;
switch colorComponents {case 1:switch bitsPerComponent {case 1:_dacd =&Monochrome {ImageBase :_ecae ,ModelThreshold :0x0f};case 2:_dacd =&Gray2 {ImageBase :_ecae };case 4:_dacd =&Gray4 {ImageBase :_ecae };case 8:_dacd =&Gray8 {ImageBase :_ecae };case 16:_dacd =&Gray16 {ImageBase :_ecae };
};case 3:switch bitsPerComponent {case 4:_dacd =&NRGBA16 {ImageBase :_ecae };case 8:_dacd =&NRGBA32 {ImageBase :_ecae };case 16:_dacd =&NRGBA64 {ImageBase :_ecae };};case 4:_dacd =&CMYK32 {ImageBase :_ecae };};if _dacd ==nil {return nil ,ErrInvalidImage ;
};return _dacd ,nil ;};func (_ffg *CMYK32 )ColorModel ()_d .Model {return _d .CMYKModel };var _ _de .Image =&NRGBA64 {};func (_fbed *NRGBA32 )Bounds ()_de .Rectangle {return _de .Rectangle {Max :_de .Point {X :_fbed .Width ,Y :_fbed .Height }};};func (_gdea *Monochrome )GrayAt (x ,y int )_d .Gray {_cff ,_ :=ColorAtGray1BPC (x ,y ,_gdea .BytesPerLine ,_gdea .Data ,_gdea .Decode );
return _cff ;};type Image interface{_f .Image ;Base ()*ImageBase ;Copy ()Image ;Pix ()[]byte ;ColorAt (_dabb ,_fadea int )(_d .Color ,error );Validate ()error ;};type Gray2 struct{ImageBase };func _fbba (_bcad *Monochrome ,_aabfa ,_gcfa int ,_aagb ,_ecfcb int ,_dfaa RasterOperator ){var (_ggcgc int ;
_gfc byte ;_fggb ,_gcea int ;_cebbf int ;);_dfcbd :=_aagb >>3;_dcef :=_aagb &7;if _dcef > 0{_gfc =_ebca [_dcef ];};_ggcgc =_bcad .BytesPerLine *_gcfa +(_aabfa >>3);switch _dfaa {case PixClr :for _fggb =0;_fggb < _ecfcb ;_fggb ++{_cebbf =_ggcgc +_fggb *_bcad .BytesPerLine ;
for _gcea =0;_gcea < _dfcbd ;_gcea ++{_bcad .Data [_cebbf ]=0x0;_cebbf ++;};if _dcef > 0{_bcad .Data [_cebbf ]=_dabf (_bcad .Data [_cebbf ],0x0,_gfc );};};case PixSet :for _fggb =0;_fggb < _ecfcb ;_fggb ++{_cebbf =_ggcgc +_fggb *_bcad .BytesPerLine ;for _gcea =0;
_gcea < _dfcbd ;_gcea ++{_bcad .Data [_cebbf ]=0xff;_cebbf ++;};if _dcef > 0{_bcad .Data [_cebbf ]=_dabf (_bcad .Data [_cebbf ],0xff,_gfc );};};case PixNotDst :for _fggb =0;_fggb < _ecfcb ;_fggb ++{_cebbf =_ggcgc +_fggb *_bcad .BytesPerLine ;for _gcea =0;
_gcea < _dfcbd ;_gcea ++{_bcad .Data [_cebbf ]=^_bcad .Data [_cebbf ];_cebbf ++;};if _dcef > 0{_bcad .Data [_cebbf ]=_dabf (_bcad .Data [_cebbf ],^_bcad .Data [_cebbf ],_gfc );};};};};func (_fcd *Gray4 )GrayAt (x ,y int )_d .Gray {_gge ,_ :=ColorAtGray4BPC (x ,y ,_fcd .BytesPerLine ,_fcd .Data ,_fcd .Decode );
return _gge ;};func ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor int ,data ,alpha []byte ,decode []float64 )(_d .Color ,error ){switch bitsPerColor {case 4:return ColorAtNRGBA16 (x ,y ,width ,bytesPerLine ,data ,alpha ,decode );case 8:return ColorAtNRGBA32 (x ,y ,width ,data ,alpha ,decode );
case 16:return ColorAtNRGBA64 (x ,y ,width ,data ,alpha ,decode );default:return nil ,_fa .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0067\u0062\u0020b\u0069\u0074\u0073\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0061\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );
};};func _dcf (_bgb ,_gde *Monochrome )(_gg error ){_fag :=_gde .BytesPerLine ;_cd :=_bgb .BytesPerLine ;var (_bdf byte ;_fe uint16 ;_dcc ,_gb ,_cgd ,_afe ,_bgd int ;);for _cgd =0;_cgd < _gde .Height ;_cgd ++{_dcc =_cgd *_fag ;_gb =2*_cgd *_cd ;for _afe =0;
_afe < _fag ;_afe ++{_bdf =_gde .Data [_dcc +_afe ];_fe =_eae [_bdf ];_bgd =_gb +_afe *2;if _bgb .BytesPerLine !=_gde .BytesPerLine *2&&(_afe +1)*2> _bgb .BytesPerLine {_gg =_bgb .setByte (_bgd ,byte (_fe >>8));}else {_gg =_bgb .setTwoBytes (_bgd ,_fe );
};if _gg !=nil {return _gg ;};};for _afe =0;_afe < _cd ;_afe ++{_bgd =_gb +_cd +_afe ;_bdf =_bgb .Data [_gb +_afe ];if _gg =_bgb .setByte (_bgd ,_bdf );_gg !=nil {return _gg ;};};};return nil ;};type RGBA interface{RGBAAt (_ffgc ,_dfbg int )_d .RGBA ;SetRGBA (_bafd ,_gagc int ,_ceeac _d .RGBA );
};func _bb (_ggd ,_cbb *Monochrome )(_fef error ){_dea :=_cbb .BytesPerLine ;_dfd :=_ggd .BytesPerLine ;var _aeec ,_bcg ,_cbg ,_aga ,_aa int ;for _cbg =0;_cbg < _cbb .Height ;_cbg ++{_aeec =_cbg *_dea ;_bcg =8*_cbg *_dfd ;for _aga =0;_aga < _dea ;_aga ++{if _fef =_ggd .setEightBytes (_bcg +_aga *8,_cdea [_cbb .Data [_aeec +_aga ]]);
_fef !=nil {return _fef ;};};for _aa =1;_aa < 8;_aa ++{for _aga =0;_aga < _dfd ;_aga ++{if _fef =_ggd .setByte (_bcg +_aa *_dfd +_aga ,_ggd .Data [_bcg +_aga ]);_fef !=nil {return _fef ;};};};};return nil ;};func (_gfbg *NRGBA16 )Bounds ()_de .Rectangle {return _de .Rectangle {Max :_de .Point {X :_gfbg .Width ,Y :_gfbg .Height }};
};func (_agd *ImageBase )setByte (_aef int ,_ddb byte )error {if _aef > len (_agd .Data )-1{return _ac .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_agd .Data [_aef ]=_ddb ;return nil ;};func _gebf (_fbde int ,_ebfe int )error {return _fa .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",_fbde ,_ebfe );
};func (_fce *Gray8 )Validate ()error {if len (_fce .Data )!=_fce .Height *_fce .BytesPerLine {return ErrInvalidImage ;};return nil ;};func _dabf (_gea ,_bggg ,_aadf byte )byte {return (_gea &^(_aadf ))|(_bggg &_aadf )};type CMYK32 struct{ImageBase };func (_eaed *CMYK32 )Set (x ,y int ,c _d .Color ){_fbg :=4*(y *_eaed .Width +x );
if _fbg +3>=len (_eaed .Data ){return ;};_dda :=_d .CMYKModel .Convert (c ).(_d .CMYK );_eaed .Data [_fbg ]=_dda .C ;_eaed .Data [_fbg +1]=_dda .M ;_eaed .Data [_fbg +2]=_dda .Y ;_eaed .Data [_fbg +3]=_dda .K ;};func (_aeaa *Monochrome )ScaleLow (width ,height int )(*Monochrome ,error ){if width < 0||height < 0{return nil ,_ac .New ("\u0070\u0072\u006f\u0076\u0069\u0064e\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0069\u0064t\u0068\u0020\u0061\u006e\u0064\u0020\u0068e\u0069\u0067\u0068\u0074");
};_ccf :=_afeg (width ,height );_ggdg :=make ([]int ,height );_dbd :=make ([]int ,width );_cbd :=float64 (_aeaa .Width )/float64 (width );_efce :=float64 (_aeaa .Height )/float64 (height );for _gagf :=0;_gagf < height ;_gagf ++{_ggdg [_gagf ]=int (_b .Min (_efce *float64 (_gagf )+0.5,float64 (_aeaa .Height -1)));
};for _cbda :=0;_cbda < width ;_cbda ++{_dbd [_cbda ]=int (_b .Min (_cbd *float64 (_cbda )+0.5,float64 (_aeaa .Width -1)));};_gbeg :=-1;_dge :=byte (0);for _cebb :=0;_cebb < height ;_cebb ++{_fgc :=_ggdg [_cebb ]*_aeaa .BytesPerLine ;_ffgf :=_cebb *_ccf .BytesPerLine ;
for _fade :=0;_fade < width ;_fade ++{_fcgd :=_dbd [_fade ];if _fcgd !=_gbeg {_dge =_aeaa .getBit (_fgc ,_fcgd );if _dge !=0{_ccf .setBit (_ffgf ,_fade );};_gbeg =_fcgd ;}else {if _dge !=0{_ccf .setBit (_ffgf ,_fade );};};};};return _ccf ,nil ;};func (_fdabc *Monochrome )Bounds ()_de .Rectangle {return _de .Rectangle {Max :_de .Point {X :_fdabc .Width ,Y :_fdabc .Height }};
};func (_eebd *Gray2 )At (x ,y int )_d .Color {_bdge ,_ :=_eebd .ColorAt (x ,y );return _bdge };func ColorAtNRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_d .NRGBA ,error ){_cdfaf :=y *width +x ;_gga :=3*_cdfaf ;if _gga +2>=len (data ){return _d .NRGBA {},_fa .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_fgfc :=uint8 (0xff);if alpha !=nil &&len (alpha )> _cdfaf {_fgfc =alpha [_cdfaf ];};_cbac ,_afac ,_gbcd :=data [_gga ],data [_gga +1],data [_gga +2];if len (decode )==6{_cbac =uint8 (uint32 (LinearInterpolate (float64 (_cbac ),0,255,decode [0],decode [1]))&0xff);
_afac =uint8 (uint32 (LinearInterpolate (float64 (_afac ),0,255,decode [2],decode [3]))&0xff);_gbcd =uint8 (uint32 (LinearInterpolate (float64 (_gbcd ),0,255,decode [4],decode [5]))&0xff);};return _d .NRGBA {R :_cbac ,G :_afac ,B :_gbcd ,A :_fgfc },nil ;
};type monochromeThresholdConverter struct{Threshold uint8 ;};func _bcd (_abg _d .NRGBA )_d .CMYK {_bef ,_cefa ,_ccb ,_ :=_abg .RGBA ();_adbg ,_cfb ,_adg ,_cdcg :=_d .RGBToCMYK (uint8 (_bef >>8),uint8 (_cefa >>8),uint8 (_ccb >>8));return _d .CMYK {C :_adbg ,M :_cfb ,Y :_adg ,K :_cdcg };
};func _gba (_gfac RGBA ,_bgf Gray ,_debc _de .Rectangle ){for _eced :=0;_eced < _debc .Max .X ;_eced ++{for _bagc :=0;_bagc < _debc .Max .Y ;_bagc ++{_dfgg :=_adf (_gfac .RGBAAt (_eced ,_bagc ));_bgf .SetGray (_eced ,_bagc ,_dfgg );};};};type NRGBA32 struct{ImageBase };
func _cbaaa (_eaaf []byte ,_gdeef Image )error {_facb :=true ;for _accaf :=0;_accaf < len (_eaaf );_accaf ++{if _eaaf [_accaf ]!=0xff{_facb =false ;break ;};};if _facb {switch _aaee :=_gdeef .(type ){case *NRGBA32 :_aaee .Alpha =nil ;case *NRGBA64 :_aaee .Alpha =nil ;
default:return _fa .Errorf ("i\u006ete\u0072n\u0061l\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020i\u006d\u0061\u0067\u0065\u0020s\u0068\u006f\u0075l\u0064\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0074\u0079\u0070e\u0020\u002a\u004eRGB\u0041\u0033\u0032\u0020\u006f\u0072 \u002a\u004e\u0052\u0047\u0042\u0041\u0036\u0034\u0020\u0062\u0075\u0074 \u0069s\u003a\u0020\u0025\u0054",_gdeef );
};};return nil ;};var _ Image =&NRGBA16 {};func _dfbcb (_afeb _de .Image )(Image ,error ){if _bfab ,_cffc :=_afeb .(*NRGBA64 );_cffc {return _bfab .Copy (),nil ;};_dcgc ,_dadf ,_dbdb :=_dgda (_afeb ,2);_eeabb ,_dcfca :=NewImage (_dcgc .Max .X ,_dcgc .Max .Y ,16,3,nil ,_dbdb ,nil );
if _dcfca !=nil {return nil ,_dcfca ;};_dcfg (_afeb ,_eeabb ,_dcgc );if len (_dbdb )!=0&&!_dadf {if _cbdb :=_cbaaa (_dbdb ,_eeabb );_cbdb !=nil {return nil ,_cbdb ;};};return _eeabb ,nil ;};func (_gcbb *Monochrome )setBit (_aaef ,_dgf int ){_gcbb .Data [_aaef +(_dgf >>3)]|=0x80>>uint (_dgf &7)};
func (_bcac *Gray2 )ColorModel ()_d .Model {return Gray2Model };func (_eaca *NRGBA64 )SetNRGBA64 (x ,y int ,c _d .NRGBA64 ){_aabb :=(y *_eaca .Width +x )*2;_deda :=_aabb *3;if _deda +5>=len (_eaca .Data ){return ;};_eaca .setNRGBA64 (_deda ,c ,_aabb );
};var _ Image =&Gray8 {};type RasterOperator int ;type Gray16 struct{ImageBase };func (_cfee *Monochrome )setGrayBit (_gcfb ,_fdgf int ){_cfee .Data [_gcfb ]|=0x80>>uint (_fdgf &7)};func ConverterFunc (converterFunc func (_gedg _de .Image )(Image ,error ))ColorConverter {return colorConverter {_fgd :converterFunc };
};func _dfdg (_adafg Gray ,_gdag CMYK ,_dfab _de .Rectangle ){for _cgdf :=0;_cgdf < _dfab .Max .X ;_cgdf ++{for _gggg :=0;_gggg < _dfab .Max .Y ;_gggg ++{_afcf :=_adafg .GrayAt (_cgdf ,_gggg );_gdag .SetCMYK (_cgdf ,_gggg ,_dcde (_afcf ));};};};var (Gray2Model =_d .ModelFunc (_gdgf );
Gray4Model =_d .ModelFunc (_bcedd );NRGBA16Model =_d .ModelFunc (_gebgg ););func _gfb (_cfce *Monochrome ,_gfbe ,_caggd ,_faga ,_fbbd int ,_gdee RasterOperator ,_befcc *Monochrome ,_gddgb ,_cegfd int )error {var (_feb byte ;_gcaa int ;_ceeb int ;_ffee ,_aggfb int ;
_deaf ,_cdfe int ;);_fcgcd :=_faga >>3;_dfac :=_faga &7;if _dfac > 0{_feb =_ebca [_dfac ];};_gcaa =_befcc .BytesPerLine *_cegfd +(_gddgb >>3);_ceeb =_cfce .BytesPerLine *_caggd +(_gfbe >>3);switch _gdee {case PixSrc :for _deaf =0;_deaf < _fbbd ;_deaf ++{_ffee =_gcaa +_deaf *_befcc .BytesPerLine ;
_aggfb =_ceeb +_deaf *_cfce .BytesPerLine ;for _cdfe =0;_cdfe < _fcgcd ;_cdfe ++{_cfce .Data [_aggfb ]=_befcc .Data [_ffee ];_aggfb ++;_ffee ++;};if _dfac > 0{_cfce .Data [_aggfb ]=_dabf (_cfce .Data [_aggfb ],_befcc .Data [_ffee ],_feb );};};case PixNotSrc :for _deaf =0;
_deaf < _fbbd ;_deaf ++{_ffee =_gcaa +_deaf *_befcc .BytesPerLine ;_aggfb =_ceeb +_deaf *_cfce .BytesPerLine ;for _cdfe =0;_cdfe < _fcgcd ;_cdfe ++{_cfce .Data [_aggfb ]=^(_befcc .Data [_ffee ]);_aggfb ++;_ffee ++;};if _dfac > 0{_cfce .Data [_aggfb ]=_dabf (_cfce .Data [_aggfb ],^_befcc .Data [_ffee ],_feb );
};};case PixSrcOrDst :for _deaf =0;_deaf < _fbbd ;_deaf ++{_ffee =_gcaa +_deaf *_befcc .BytesPerLine ;_aggfb =_ceeb +_deaf *_cfce .BytesPerLine ;for _cdfe =0;_cdfe < _fcgcd ;_cdfe ++{_cfce .Data [_aggfb ]|=_befcc .Data [_ffee ];_aggfb ++;_ffee ++;};if _dfac > 0{_cfce .Data [_aggfb ]=_dabf (_cfce .Data [_aggfb ],_befcc .Data [_ffee ]|_cfce .Data [_aggfb ],_feb );
};};case PixSrcAndDst :for _deaf =0;_deaf < _fbbd ;_deaf ++{_ffee =_gcaa +_deaf *_befcc .BytesPerLine ;_aggfb =_ceeb +_deaf *_cfce .BytesPerLine ;for _cdfe =0;_cdfe < _fcgcd ;_cdfe ++{_cfce .Data [_aggfb ]&=_befcc .Data [_ffee ];_aggfb ++;_ffee ++;};if _dfac > 0{_cfce .Data [_aggfb ]=_dabf (_cfce .Data [_aggfb ],_befcc .Data [_ffee ]&_cfce .Data [_aggfb ],_feb );
};};case PixSrcXorDst :for _deaf =0;_deaf < _fbbd ;_deaf ++{_ffee =_gcaa +_deaf *_befcc .BytesPerLine ;_aggfb =_ceeb +_deaf *_cfce .BytesPerLine ;for _cdfe =0;_cdfe < _fcgcd ;_cdfe ++{_cfce .Data [_aggfb ]^=_befcc .Data [_ffee ];_aggfb ++;_ffee ++;};if _dfac > 0{_cfce .Data [_aggfb ]=_dabf (_cfce .Data [_aggfb ],_befcc .Data [_ffee ]^_cfce .Data [_aggfb ],_feb );
};};case PixNotSrcOrDst :for _deaf =0;_deaf < _fbbd ;_deaf ++{_ffee =_gcaa +_deaf *_befcc .BytesPerLine ;_aggfb =_ceeb +_deaf *_cfce .BytesPerLine ;for _cdfe =0;_cdfe < _fcgcd ;_cdfe ++{_cfce .Data [_aggfb ]|=^(_befcc .Data [_ffee ]);_aggfb ++;_ffee ++;
};if _dfac > 0{_cfce .Data [_aggfb ]=_dabf (_cfce .Data [_aggfb ],^(_befcc .Data [_ffee ])|_cfce .Data [_aggfb ],_feb );};};case PixNotSrcAndDst :for _deaf =0;_deaf < _fbbd ;_deaf ++{_ffee =_gcaa +_deaf *_befcc .BytesPerLine ;_aggfb =_ceeb +_deaf *_cfce .BytesPerLine ;
for _cdfe =0;_cdfe < _fcgcd ;_cdfe ++{_cfce .Data [_aggfb ]&=^(_befcc .Data [_ffee ]);_aggfb ++;_ffee ++;};if _dfac > 0{_cfce .Data [_aggfb ]=_dabf (_cfce .Data [_aggfb ],^(_befcc .Data [_ffee ])&_cfce .Data [_aggfb ],_feb );};};case PixSrcOrNotDst :for _deaf =0;
_deaf < _fbbd ;_deaf ++{_ffee =_gcaa +_deaf *_befcc .BytesPerLine ;_aggfb =_ceeb +_deaf *_cfce .BytesPerLine ;for _cdfe =0;_cdfe < _fcgcd ;_cdfe ++{_cfce .Data [_aggfb ]=_befcc .Data [_ffee ]|^(_cfce .Data [_aggfb ]);_aggfb ++;_ffee ++;};if _dfac > 0{_cfce .Data [_aggfb ]=_dabf (_cfce .Data [_aggfb ],_befcc .Data [_ffee ]|^(_cfce .Data [_aggfb ]),_feb );
};};case PixSrcAndNotDst :for _deaf =0;_deaf < _fbbd ;_deaf ++{_ffee =_gcaa +_deaf *_befcc .BytesPerLine ;_aggfb =_ceeb +_deaf *_cfce .BytesPerLine ;for _cdfe =0;_cdfe < _fcgcd ;_cdfe ++{_cfce .Data [_aggfb ]=_befcc .Data [_ffee ]&^(_cfce .Data [_aggfb ]);
_aggfb ++;_ffee ++;};if _dfac > 0{_cfce .Data [_aggfb ]=_dabf (_cfce .Data [_aggfb ],_befcc .Data [_ffee ]&^(_cfce .Data [_aggfb ]),_feb );};};case PixNotPixSrcOrDst :for _deaf =0;_deaf < _fbbd ;_deaf ++{_ffee =_gcaa +_deaf *_befcc .BytesPerLine ;_aggfb =_ceeb +_deaf *_cfce .BytesPerLine ;
for _cdfe =0;_cdfe < _fcgcd ;_cdfe ++{_cfce .Data [_aggfb ]=^(_befcc .Data [_ffee ]|_cfce .Data [_aggfb ]);_aggfb ++;_ffee ++;};if _dfac > 0{_cfce .Data [_aggfb ]=_dabf (_cfce .Data [_aggfb ],^(_befcc .Data [_ffee ]|_cfce .Data [_aggfb ]),_feb );};};case PixNotPixSrcAndDst :for _deaf =0;
_deaf < _fbbd ;_deaf ++{_ffee =_gcaa +_deaf *_befcc .BytesPerLine ;_aggfb =_ceeb +_deaf *_cfce .BytesPerLine ;for _cdfe =0;_cdfe < _fcgcd ;_cdfe ++{_cfce .Data [_aggfb ]=^(_befcc .Data [_ffee ]&_cfce .Data [_aggfb ]);_aggfb ++;_ffee ++;};if _dfac > 0{_cfce .Data [_aggfb ]=_dabf (_cfce .Data [_aggfb ],^(_befcc .Data [_ffee ]&_cfce .Data [_aggfb ]),_feb );
};};case PixNotPixSrcXorDst :for _deaf =0;_deaf < _fbbd ;_deaf ++{_ffee =_gcaa +_deaf *_befcc .BytesPerLine ;_aggfb =_ceeb +_deaf *_cfce .BytesPerLine ;for _cdfe =0;_cdfe < _fcgcd ;_cdfe ++{_cfce .Data [_aggfb ]=^(_befcc .Data [_ffee ]^_cfce .Data [_aggfb ]);
_aggfb ++;_ffee ++;};if _dfac > 0{_cfce .Data [_aggfb ]=_dabf (_cfce .Data [_aggfb ],^(_befcc .Data [_ffee ]^_cfce .Data [_aggfb ]),_feb );};};default:_g .Log .Debug ("\u0050\u0072ov\u0069\u0064\u0065d\u0020\u0069\u006e\u0076ali\u0064 r\u0061\u0073\u0074\u0065\u0072\u0020\u006fpe\u0072\u0061\u0074\u006f\u0072\u003a\u0020%\u0076",_gdee );
return _ac .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072");};return nil ;};var (_eae =_ef ();_fc =_fcb ();_cdea =_acc (););func ImgToGray (i _de .Image )*_de .Gray {if _dbad ,_cfdd :=i .(*_de .Gray );
_cfdd {return _dbad ;};_bfd :=i .Bounds ();_cafe :=_de .NewGray (_bfd );for _afacb :=0;_afacb < _bfd .Max .X ;_afacb ++{for _defg :=0;_defg < _bfd .Max .Y ;_defg ++{_bfdg :=i .At (_afacb ,_defg );_cafe .Set (_afacb ,_defg ,_bfdg );};};return _cafe ;};func AddDataPadding (width ,height ,bitsPerComponent ,colorComponents int ,data []byte )([]byte ,error ){_gagg :=BytesPerLine (width ,bitsPerComponent ,colorComponents );
if _gagg ==width *colorComponents *bitsPerComponent /8{return data ,nil ;};_ffdc :=width *colorComponents *bitsPerComponent ;_dfea :=_gagg *8;_gdfb :=8-(_dfea -_ffdc );_aeab :=_fb .NewReader (data );_efcc :=_gagg -1;_edeb :=make ([]byte ,_efcc );_ecgf :=make ([]byte ,height *_gagg );
_cacf :=_fb .NewWriterMSB (_ecgf );var _ggcg uint64 ;var _aggd error ;for _dacg :=0;_dacg < height ;_dacg ++{_ ,_aggd =_aeab .Read (_edeb );if _aggd !=nil {return nil ,_aggd ;};_ ,_aggd =_cacf .Write (_edeb );if _aggd !=nil {return nil ,_aggd ;};_ggcg ,_aggd =_aeab .ReadBits (byte (_gdfb ));
if _aggd !=nil {return nil ,_aggd ;};_ ,_aggd =_cacf .WriteBits (_ggcg ,_gdfb );if _aggd !=nil {return nil ,_aggd ;};_cacf .FinishByte ();};return _ecgf ,nil ;};func BytesPerLine (width ,bitsPerComponent ,colorComponents int )int {return ((width *bitsPerComponent )*colorComponents +7)>>3;
};func _egd (_cefb _de .Image )(Image ,error ){if _dcgff ,_cdca :=_cefb .(*Gray4 );_cdca {return _dcgff .Copy (),nil ;};_fgee :=_cefb .Bounds ();_dgef ,_fdb :=NewImage (_fgee .Max .X ,_fgee .Max .Y ,4,1,nil ,nil ,nil );if _fdb !=nil {return nil ,_fdb ;
};_bbd (_cefb ,_dgef ,_fgee );return _dgef ,nil ;};func (_daed *Gray16 )Set (x ,y int ,c _d .Color ){_bbge :=(y *_daed .BytesPerLine /2+x )*2;if _bbge +1>=len (_daed .Data ){return ;};_dfaf :=_d .Gray16Model .Convert (c ).(_d .Gray16 );_daed .Data [_bbge ],_daed .Data [_bbge +1]=uint8 (_dfaf .Y >>8),uint8 (_dfaf .Y &0xff);
};type shift int ;func _gff (_cdcf _d .NRGBA64 )_d .NRGBA {return _d .NRGBA {R :uint8 (_cdcf .R >>8),G :uint8 (_cdcf .G >>8),B :uint8 (_cdcf .B >>8),A :uint8 (_cdcf .A >>8)};};var (MonochromeConverter =ConverterFunc (_bdfc );Gray2Converter =ConverterFunc (_gagd );
Gray4Converter =ConverterFunc (_egd );GrayConverter =ConverterFunc (_gbed );Gray16Converter =ConverterFunc (_eaae );NRGBA16Converter =ConverterFunc (_abfb );NRGBAConverter =ConverterFunc (_fcfd );NRGBA64Converter =ConverterFunc (_dfbcb );CMYKConverter =ConverterFunc (_cda );
);func (_abfg *Gray4 )ColorAt (x ,y int )(_d .Color ,error ){return ColorAtGray4BPC (x ,y ,_abfg .BytesPerLine ,_abfg .Data ,_abfg .Decode );};type Histogramer interface{Histogram ()[256]int ;};func (_cafa *Monochrome )At (x ,y int )_d .Color {_fgce ,_ :=_cafa .ColorAt (x ,y );
return _fgce };func _dadc (_bdef nrgba64 ,_cfgd NRGBA ,_eccc _de .Rectangle ){for _acaa :=0;_acaa < _eccc .Max .X ;_acaa ++{for _gafa :=0;_gafa < _eccc .Max .Y ;_gafa ++{_aggb :=_bdef .NRGBA64At (_acaa ,_gafa );_cfgd .SetNRGBA (_acaa ,_gafa ,_gff (_aggb ));
};};};func ImgToBinary (i _de .Image ,threshold uint8 )*_de .Gray {switch _fgeeb :=i .(type ){case *_de .Gray :if _cbga (_fgeeb ){return _fgeeb ;};return _bdfe (_fgeeb ,threshold );case *_de .Gray16 :return _faafg (_fgeeb ,threshold );default:return _ffbf (_fgeeb ,threshold );
};};func _geag (_gcfgf CMYK ,_eedd NRGBA ,_gaddb _de .Rectangle ){for _faae :=0;_faae < _gaddb .Max .X ;_faae ++{for _gabf :=0;_gabf < _gaddb .Max .Y ;_gabf ++{_aeecd :=_gcfgf .CMYKAt (_faae ,_gabf );_eedd .SetNRGBA (_faae ,_gabf ,_cdab (_aeecd ));};};
};func (_cbffb *NRGBA32 )NRGBAAt (x ,y int )_d .NRGBA {_bdbc ,_ :=ColorAtNRGBA32 (x ,y ,_cbffb .Width ,_cbffb .Data ,_cbffb .Alpha ,_cbffb .Decode );return _bdbc ;};func _abfb (_dff _de .Image )(Image ,error ){if _gabeb ,_dbba :=_dff .(*NRGBA16 );_dbba {return _gabeb .Copy (),nil ;
};_ddefg :=_dff .Bounds ();_ceef ,_fcabf :=NewImage (_ddefg .Max .X ,_ddefg .Max .Y ,4,3,nil ,nil ,nil );if _fcabf !=nil {return nil ,_fcabf ;};_ggag (_dff ,_ceef ,_ddefg );return _ceef ,nil ;};func AutoThresholdTriangle (histogram [256]int )uint8 {var _fdcc ,_cdg ,_fcae ,_gbaf int ;
for _ffdcc :=0;_ffdcc < len (histogram );_ffdcc ++{if histogram [_ffdcc ]> 0{_fdcc =_ffdcc ;break ;};};if _fdcc > 0{_fdcc --;};for _cggg :=255;_cggg > 0;_cggg --{if histogram [_cggg ]> 0{_gbaf =_cggg ;break ;};};if _gbaf < 255{_gbaf ++;};for _bfaga :=0;
_bfaga < 256;_bfaga ++{if histogram [_bfaga ]> _cdg {_fcae =_bfaga ;_cdg =histogram [_bfaga ];};};var _eaac bool ;if (_fcae -_fdcc )< (_gbaf -_fcae ){_eaac =true ;var _dgeb int ;_dbbbf :=255;for _dgeb < _dbbbf {_adgb :=histogram [_dgeb ];histogram [_dgeb ]=histogram [_dbbbf ];
histogram [_dbbbf ]=_adgb ;_dgeb ++;_dbbbf --;};_fdcc =255-_gbaf ;_fcae =255-_fcae ;};if _fdcc ==_fcae {return uint8 (_fdcc );};_fbcb :=float64 (histogram [_fcae ]);_bbed :=float64 (_fdcc -_fcae );_fecg :=_b .Sqrt (_fbcb *_fbcb +_bbed *_bbed );_fbcb /=_fecg ;
_bbed /=_fecg ;_fecg =_fbcb *float64 (_fdcc )+_bbed *float64 (histogram [_fdcc ]);_decf :=_fdcc ;var _fdgfd float64 ;for _dada :=_fdcc +1;_dada <=_fcae ;_dada ++{_edcb :=_fbcb *float64 (_dada )+_bbed *float64 (histogram [_dada ])-_fecg ;if _edcb > _fdgfd {_decf =_dada ;
_fdgfd =_edcb ;};};_decf --;if _eaac {var _cgfbe int ;_dbab :=255;for _cgfbe < _dbab {_fdcg :=histogram [_cgfbe ];histogram [_cgfbe ]=histogram [_dbab ];histogram [_dbab ]=_fdcg ;_cgfbe ++;_dbab --;};return uint8 (255-_decf );};return uint8 (_decf );};
func _gagd (_dfec _de .Image )(Image ,error ){if _agfba ,_ceed :=_dfec .(*Gray2 );_ceed {return _agfba .Copy (),nil ;};_eab :=_dfec .Bounds ();_edfe ,_eeeb :=NewImage (_eab .Max .X ,_eab .Max .Y ,2,1,nil ,nil ,nil );if _eeeb !=nil {return nil ,_eeeb ;};
_bbd (_dfec ,_edfe ,_eab );return _edfe ,nil ;};func (_gffg *NRGBA64 )Validate ()error {if len (_gffg .Data )!=3*2*_gffg .Width *_gffg .Height {return _ac .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func MonochromeThresholdConverter (threshold uint8 )ColorConverter {return &monochromeThresholdConverter {Threshold :threshold };};var _ _de .Image =&NRGBA16 {};func _acbg (_fgfff ,_dfecd NRGBA ,_bfeb _de .Rectangle ){for _agbe :=0;_agbe < _bfeb .Max .X ;
_agbe ++{for _bebd :=0;_bebd < _bfeb .Max .Y ;_bebd ++{_dfecd .SetNRGBA (_agbe ,_bebd ,_fgfff .NRGBAAt (_agbe ,_bebd ));};};};const (PixSrc RasterOperator =0xc;PixDst RasterOperator =0xa;PixNotSrc RasterOperator =0x3;PixNotDst RasterOperator =0x5;PixClr RasterOperator =0x0;
PixSet RasterOperator =0xf;PixSrcOrDst RasterOperator =0xe;PixSrcAndDst RasterOperator =0x8;PixSrcXorDst RasterOperator =0x6;PixNotSrcOrDst RasterOperator =0xb;PixNotSrcAndDst RasterOperator =0x2;PixSrcOrNotDst RasterOperator =0xd;PixSrcAndNotDst RasterOperator =0x4;
PixNotPixSrcOrDst RasterOperator =0x1;PixNotPixSrcAndDst RasterOperator =0x7;PixNotPixSrcXorDst RasterOperator =0x9;PixPaint =PixSrcOrDst ;PixSubtract =PixNotSrcAndDst ;PixMask =PixSrcAndDst ;);func (_cc *CMYK32 )CMYKAt (x ,y int )_d .CMYK {_fdac ,_ :=ColorAtCMYK (x ,y ,_cc .Width ,_cc .Data ,_cc .Decode );
return _fdac ;};func (_fbge *Monochrome )clearBit (_fbcf ,_dab int ){_fbge .Data [_fbcf ]&=^(0x80>>uint (_dab &7))};func _gfe (_cfdf Gray ,_bdc nrgba64 ,_bffb _de .Rectangle ){for _cad :=0;_cad < _bffb .Max .X ;_cad ++{for _fge :=0;_fge < _bffb .Max .Y ;
_fge ++{_efdb :=_acdg (_bdc .NRGBA64At (_cad ,_fge ));_cfdf .SetGray (_cad ,_fge ,_efdb );};};};func _acdg (_efg _d .NRGBA64 )_d .Gray {var _baac _d .NRGBA64 ;if _efg ==_baac {return _d .Gray {Y :0xff};};_gcad ,_gdg ,_efcg ,_ :=_efg .RGBA ();_caf :=(19595*_gcad +38470*_gdg +7471*_efcg +1<<15)>>24;
return _d .Gray {Y :uint8 (_caf )};};func (_dfdd *CMYK32 )Bounds ()_de .Rectangle {return _de .Rectangle {Max :_de .Point {X :_dfdd .Width ,Y :_dfdd .Height }};};var _ Gray =&Gray4 {};func (_bed *NRGBA32 )Base ()*ImageBase {return &_bed .ImageBase };func _ba (_bag ,_abc *Monochrome )(_ee error ){_edg :=_abc .BytesPerLine ;
_abf :=_bag .BytesPerLine ;_cf :=_abc .BytesPerLine *4-_bag .BytesPerLine ;var (_ag ,_acd byte ;_agf uint32 ;_cbf ,_bf ,_ea ,_bc ,_gfd ,_gad ,_eda int ;);for _ea =0;_ea < _abc .Height ;_ea ++{_cbf =_ea *_edg ;_bf =4*_ea *_abf ;for _bc =0;_bc < _edg ;_bc ++{_ag =_abc .Data [_cbf +_bc ];
_agf =_fc [_ag ];_gad =_bf +_bc *4;if _cf !=0&&(_bc +1)*4> _bag .BytesPerLine {for _gfd =_cf ;_gfd > 0;_gfd --{_acd =byte ((_agf >>uint (_gfd *8))&0xff);_eda =_gad +(_cf -_gfd );if _ee =_bag .setByte (_eda ,_acd );_ee !=nil {return _ee ;};};}else if _ee =_bag .setFourBytes (_gad ,_agf );
_ee !=nil {return _ee ;};if _ee =_bag .setFourBytes (_bf +_bc *4,_fc [_abc .Data [_cbf +_bc ]]);_ee !=nil {return _ee ;};};for _gfd =1;_gfd < 4;_gfd ++{for _bc =0;_bc < _abf ;_bc ++{if _ee =_bag .setByte (_bf +_gfd *_abf +_bc ,_bag .Data [_bf +_bc ]);_ee !=nil {return _ee ;
};};};};return nil ;};func _afc (_gag ,_ffb int ,_accb []byte )*Monochrome {_bdg :=_afeg (_gag ,_ffb );_bdg .Data =_accb ;return _bdg ;};func (_fafc *Monochrome )SetGray (x ,y int ,g _d .Gray ){_fdg :=y *_fafc .BytesPerLine +x >>3;if _fdg > len (_fafc .Data )-1{return ;
};g =_gcf (g ,monochromeModel (_fafc .ModelThreshold ));_fafc .setGray (x ,g ,_fdg );};func (_bbcf *NRGBA64 )Base ()*ImageBase {return &_bbcf .ImageBase };func _fg (_gac *Monochrome ,_cgc ,_fad int )(*Monochrome ,error ){if _gac ==nil {return nil ,_ac .New ("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064");
};if _cgc <=0||_fad <=0{return nil ,_ac .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0073\u0063\u0061l\u0065\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020<\u003d\u0020\u0030");};if _cgc ==_fad {if _cgc ==1{return _gac .copy (),nil ;
};if _cgc ==2||_cgc ==4||_cgc ==8{_dee ,_bce :=_ga (_gac ,_cgc );if _bce !=nil {return nil ,_bce ;};return _dee ,nil ;};};_baf :=_cgc *_gac .Width ;_acg :=_fad *_gac .Height ;_cde :=_afeg (_baf ,_acg );_cbe :=_cde .BytesPerLine ;var (_baa ,_eef ,_bgde ,_ce ,_ced int ;
_cab byte ;_ad error ;);for _eef =0;_eef < _gac .Height ;_eef ++{_baa =_fad *_eef *_cbe ;for _bgde =0;_bgde < _gac .Width ;_bgde ++{if _gfa :=_gac .getBitAt (_bgde ,_eef );_gfa {_ced =_cgc *_bgde ;for _ce =0;_ce < _cgc ;_ce ++{_cde .setIndexedBit (_baa *8+_ced +_ce );
};};};for _ce =1;_ce < _fad ;_ce ++{_acgd :=_baa +_ce *_cbe ;for _db :=0;_db < _cbe ;_db ++{if _cab ,_ad =_cde .getByte (_baa +_db );_ad !=nil {return nil ,_ad ;};if _ad =_cde .setByte (_acgd +_db ,_cab );_ad !=nil {return nil ,_ad ;};};};};return _cde ,nil ;
};type Gray interface{GrayAt (_agfb ,_gfff int )_d .Gray ;SetGray (_bcc ,_bced int ,_eaaa _d .Gray );};var _baba [256]uint8 ;func _cdee (_cbad _d .NRGBA )_d .Gray {var _dae _d .NRGBA ;if _cbad ==_dae {return _d .Gray {Y :0xff};};_fcbd ,_cca ,_gcaf ,_ :=_cbad .RGBA ();
_abe :=(19595*_fcbd +38470*_cca +7471*_gcaf +1<<15)>>24;return _d .Gray {Y :uint8 (_abe )};};var _ Image =&Monochrome {};func (_fcbc *ImageBase )Pix ()[]byte {return _fcbc .Data };func (_gade *NRGBA64 )At (x ,y int )_d .Color {_ddde ,_ :=_gade .ColorAt (x ,y );
return _ddde };func _ceg (_cdc int )[]uint {var _ge []uint ;_da :=_cdc ;_cgg :=_da /8;if _cgg !=0{for _bbf :=0;_bbf < _cgg ;_bbf ++{_ge =append (_ge ,8);};_ec :=_da %8;_da =0;if _ec !=0{_da =_ec ;};};_fd :=_da /4;if _fd !=0{for _bgbd :=0;_bgbd < _fd ;_bgbd ++{_ge =append (_ge ,4);
};_abb :=_da %4;_da =0;if _abb !=0{_da =_abb ;};};_acf :=_da /2;if _acf !=0{for _bbgc :=0;_bbgc < _acf ;_bbgc ++{_ge =append (_ge ,2);};};return _ge ;};func _fcfd (_bfag _de .Image )(Image ,error ){if _aafa ,_fgbf :=_bfag .(*NRGBA32 );_fgbf {return _aafa .Copy (),nil ;
};_egfea ,_aadd ,_accbg :=_dgda (_bfag ,1);_bebb ,_beec :=NewImage (_egfea .Max .X ,_egfea .Max .Y ,8,3,nil ,_accbg ,nil );if _beec !=nil {return nil ,_beec ;};_ggag (_bfag ,_bebb ,_egfea );if len (_accbg )!=0&&!_aadd {if _gege :=_cbaaa (_accbg ,_bebb );
_gege !=nil {return nil ,_gege ;};};return _bebb ,nil ;};func _dcde (_aabf _d .Gray )_d .CMYK {return _d .CMYK {K :0xff-_aabf .Y }};var _ Gray =&Gray16 {};func (_bgda *NRGBA64 )NRGBA64At (x ,y int )_d .NRGBA64 {_ddbd ,_ :=ColorAtNRGBA64 (x ,y ,_bgda .Width ,_bgda .Data ,_bgda .Alpha ,_bgda .Decode );
return _ddbd ;};func IsPowerOf2 (n uint )bool {return n > 0&&(n &(n -1))==0};var _ NRGBA =&NRGBA32 {};func (_cbbf *Monochrome )IsUnpadded ()bool {return (_cbbf .Width *_cbbf .Height )==len (_cbbf .Data )};func (_aacc *ImageBase )GetAlpha ()[]byte {return _aacc .Alpha };
var _ Image =&Gray4 {};func (_egfe *NRGBA32 )Validate ()error {if len (_egfe .Data )!=3*_egfe .Width *_egfe .Height {return _ac .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func (_gfcb *NRGBA64 )ColorModel ()_d .Model {return _d .NRGBA64Model };func (_efda *Gray4 )Validate ()error {if len (_efda .Data )!=_efda .Height *_efda .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_eeab *NRGBA64 )Bounds ()_de .Rectangle {return _de .Rectangle {Max :_de .Point {X :_eeab .Width ,Y :_eeab .Height }};
};func GrayHistogram (g Gray )(_aabc [256]int ){switch _dggg :=g .(type ){case Histogramer :return _dggg .Histogram ();case _de .Image :_gccg :=_dggg .Bounds ();for _eebb :=0;_eebb < _gccg .Max .X ;_eebb ++{for _dege :=0;_dege < _gccg .Max .Y ;_dege ++{_aabc [g .GrayAt (_eebb ,_dege ).Y ]++;
};};return _aabc ;default:return [256]int {};};};func (_bdcc *Monochrome )getBit (_decg ,_dbcg int )uint8 {return _bdcc .Data [_decg +(_dbcg >>3)]>>uint (7-(_dbcg &7))&1;};func _ed (_df *Monochrome ,_ab int ,_edf []uint )(*Monochrome ,error ){_ae :=_ab *_df .Width ;
_cg :=_ab *_df .Height ;_dc :=_afeg (_ae ,_cg );for _gf ,_af :=range _edf {var _aee error ;switch _af {case 2:_aee =_dcf (_dc ,_df );case 4:_aee =_ba (_dc ,_df );case 8:_aee =_bb (_dc ,_df );};if _aee !=nil {return nil ,_aee ;};if _gf !=len (_edf )-1{_df =_dc .copy ();
};};return _dc ,nil ;};func ColorAt (x ,y ,width ,bitsPerColor ,colorComponents ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_d .Color ,error ){switch colorComponents {case 1:return ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine ,data ,decode );
case 3:return ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor ,data ,alpha ,decode );case 4:return ColorAtCMYK (x ,y ,width ,data ,decode );default:return nil ,_fa .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0063o\u006c\u006f\u0072\u0020\u0063\u006f\u006dp\u006f\u006e\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0064",colorComponents );
};};func (_cege *CMYK32 )At (x ,y int )_d .Color {_cfae ,_ :=_cege .ColorAt (x ,y );return _cfae };type nrgba64 interface{NRGBA64At (_gbcg ,_becbb int )_d .NRGBA64 ;SetNRGBA64 (_dbac ,_bdfbe int ,_ceeg _d .NRGBA64 );};func _ega (_bddf _d .RGBA )_d .NRGBA {switch _bddf .A {case 0xff:return _d .NRGBA {R :_bddf .R ,G :_bddf .G ,B :_bddf .B ,A :0xff};
case 0x00:return _d .NRGBA {};default:_becd ,_edfcf ,_cgfg ,_deed :=_bddf .RGBA ();_becd =(_becd *0xffff)/_deed ;_edfcf =(_edfcf *0xffff)/_deed ;_cgfg =(_cgfg *0xffff)/_deed ;return _d .NRGBA {R :uint8 (_becd >>8),G :uint8 (_edfcf >>8),B :uint8 (_cgfg >>8),A :uint8 (_deed >>8)};
};};func (_dfaac *NRGBA64 )setNRGBA64 (_gggb int ,_fegf _d .NRGBA64 ,_aace int ){_dfaac .Data [_gggb ]=uint8 (_fegf .R >>8);_dfaac .Data [_gggb +1]=uint8 (_fegf .R &0xff);_dfaac .Data [_gggb +2]=uint8 (_fegf .G >>8);_dfaac .Data [_gggb +3]=uint8 (_fegf .G &0xff);
_dfaac .Data [_gggb +4]=uint8 (_fegf .B >>8);_dfaac .Data [_gggb +5]=uint8 (_fegf .B &0xff);if _aace +1< len (_dfaac .Alpha ){_dfaac .Alpha [_aace ]=uint8 (_fegf .A >>8);_dfaac .Alpha [_aace +1]=uint8 (_fegf .A &0xff);};};func _gdgf (_faee _d .Color )_d .Color {_gebc :=_d .GrayModel .Convert (_faee ).(_d .Gray );
return _fab (_gebc );};func (_aeacf *NRGBA32 )ColorAt (x ,y int )(_d .Color ,error ){return ColorAtNRGBA32 (x ,y ,_aeacf .Width ,_aeacf .Data ,_aeacf .Alpha ,_aeacf .Decode );};func _dbea (_dbed _d .CMYK )_d .Gray {_bfg ,_cfc ,_cabd :=_d .CMYKToRGB (_dbed .C ,_dbed .M ,_dbed .Y ,_dbed .K );
_ffeg :=(19595*uint32 (_bfg )+38470*uint32 (_cfc )+7471*uint32 (_cabd )+1<<7)>>16;return _d .Gray {Y :uint8 (_ffeg )};};func ColorAtGray8BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_d .Gray ,error ){_adcb :=y *bytesPerLine +x ;if _adcb >=len (data ){return _d .Gray {},_fa .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_ecgc :=data [_adcb ];if len (decode )==2{_ecgc =uint8 (uint32 (LinearInterpolate (float64 (_ecgc ),0,255,decode [0],decode [1]))&0xff);};return _d .Gray {Y :_ecgc },nil ;};type NRGBA64 struct{ImageBase };func _eff (_gaf ,_ggdd *Monochrome ,_bage []byte ,_edaa int )(_cag error ){var (_ecd ,_dca ,_geb ,_adaf ,_dgb ,_efc ,_aec ,_cfa int ;
_dfc ,_ddd ,_ceb ,_daa uint32 ;_fagd ,_bad byte ;_fca uint16 ;);_fda :=make ([]byte ,4);_afbg :=make ([]byte ,4);for _geb =0;_geb < _gaf .Height -1;_geb ,_adaf =_geb +2,_adaf +1{_ecd =_geb *_gaf .BytesPerLine ;_dca =_adaf *_ggdd .BytesPerLine ;for _dgb ,_efc =0,0;
_dgb < _edaa ;_dgb ,_efc =_dgb +4,_efc +1{for _aec =0;_aec < 4;_aec ++{_cfa =_ecd +_dgb +_aec ;if _cfa <=len (_gaf .Data )-1&&_cfa < _ecd +_gaf .BytesPerLine {_fda [_aec ]=_gaf .Data [_cfa ];}else {_fda [_aec ]=0x00;};_cfa =_ecd +_gaf .BytesPerLine +_dgb +_aec ;
if _cfa <=len (_gaf .Data )-1&&_cfa < _ecd +(2*_gaf .BytesPerLine ){_afbg [_aec ]=_gaf .Data [_cfa ];}else {_afbg [_aec ]=0x00;};};_dfc =_bg .BigEndian .Uint32 (_fda );_ddd =_bg .BigEndian .Uint32 (_afbg );_ceb =_dfc &_ddd ;_ceb |=_ceb <<1;_daa =_dfc |_ddd ;
_daa &=_daa <<1;_ddd =_ceb |_daa ;_ddd &=0xaaaaaaaa;_dfc =_ddd |(_ddd <<7);_fagd =byte (_dfc >>24);_bad =byte ((_dfc >>8)&0xff);_cfa =_dca +_efc ;if _cfa +1==len (_ggdd .Data )-1||_cfa +1>=_dca +_ggdd .BytesPerLine {if _cag =_ggdd .setByte (_cfa ,_bage [_fagd ]);
_cag !=nil {return _fa .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_cfa );};}else {_fca =(uint16 (_bage [_fagd ])<<8)|uint16 (_bage [_bad ]);if _cag =_ggdd .setTwoBytes (_cfa ,_fca );_cag !=nil {return _fa .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_cfa );
};_efc ++;};};};return nil ;};func _gaef (_cabg ,_gda CMYK ,_aged _de .Rectangle ){for _ecc :=0;_ecc < _aged .Max .X ;_ecc ++{for _fcf :=0;_fcf < _aged .Max .Y ;_fcf ++{_gda .SetCMYK (_ecc ,_fcf ,_cabg .CMYKAt (_ecc ,_fcf ));};};};func ColorAtGray4BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_d .Gray ,error ){_edfee :=y *bytesPerLine +x >>1;
if _edfee >=len (data ){return _d .Gray {},_fa .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_bfe :=data [_edfee ]>>uint (4-(x &1)*4)&0xf;if len (decode )==2{_bfe =uint8 (uint32 (LinearInterpolate (float64 (_bfe ),0,15,decode [0],decode [1]))&0xf);};return _d .Gray {Y :_bfe *17&0xff},nil ;};func (_faaf *NRGBA64 )ColorAt (x ,y int )(_d .Color ,error ){return ColorAtNRGBA64 (x ,y ,_faaf .Width ,_faaf .Data ,_faaf .Alpha ,_faaf .Decode );
};func (_gefe *Gray8 )ColorModel ()_d .Model {return _d .GrayModel };func (_gfbb *NRGBA32 )ColorModel ()_d .Model {return _d .NRGBAModel };func _gcf (_eacc _d .Gray ,_deb monochromeModel )_d .Gray {if _eacc .Y > uint8 (_deb ){return _d .Gray {Y :_b .MaxUint8 };
};return _d .Gray {};};func (_abfc *NRGBA16 )setNRGBA (_dgdgb ,_cdb ,_bagef int ,_gfce _d .NRGBA ){if _dgdgb *3%2==0{_abfc .Data [_bagef ]=(_gfce .R >>4)<<4|(_gfce .G >>4);_abfc .Data [_bagef +1]=(_gfce .B >>4)<<4|(_abfc .Data [_bagef +1]&0xf);}else {_abfc .Data [_bagef ]=(_abfc .Data [_bagef ]&0xf0)|(_gfce .R >>4);
_abfc .Data [_bagef +1]=(_gfce .G >>4)<<4|(_gfce .B >>4);};if _abfc .Alpha !=nil {_eefb :=_cdb *BytesPerLine (_abfc .Width ,4,1);if _eefb < len (_abfc .Alpha ){if _dgdgb %2==0{_abfc .Alpha [_eefb ]=(_gfce .A >>uint (4))<<uint (4)|(_abfc .Alpha [_bagef ]&0xf);
}else {_abfc .Alpha [_eefb ]=(_abfc .Alpha [_eefb ]&0xf0)|(_gfce .A >>uint (4));};};};};func (_deg *Monochrome )ExpandBinary (factor int )(*Monochrome ,error ){if !IsPowerOf2 (uint (factor )){return nil ,_fa .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0065\u0078\u0070\u0061\u006e\u0064\u0020b\u0069n\u0061\u0072\u0079\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",factor );
};return _ga (_deg ,factor );};func _eeb (_aab *Monochrome ,_acca int ,_eaa []byte )(_fcc *Monochrome ,_caa error ){const _ggg ="\u0072\u0065d\u0075\u0063\u0065R\u0061\u006e\u006b\u0042\u0069\u006e\u0061\u0072\u0079";if _aab ==nil {return nil ,_ac .New ("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d");
};if _acca < 1||_acca > 4{return nil ,_ac .New ("\u006c\u0065\u0076\u0065\u006c\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020\u0073e\u0074\u0020\u007b\u0031\u002c\u0032\u002c\u0033\u002c\u0034\u007d");};if _aab .Height <=1{return nil ,_ac .New ("\u0073\u006f\u0075rc\u0065\u0020\u0068\u0065\u0069\u0067\u0068\u0074\u0020m\u0075s\u0074 \u0062e\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020\u0027\u0032\u0027");
};_fcc =_afeg (_aab .Width /2,_aab .Height /2);if _eaa ==nil {_eaa =_dbb ();};_eb :=_fece (_aab .BytesPerLine ,2*_fcc .BytesPerLine );switch _acca {case 1:_caa =_cdeg (_aab ,_fcc ,_eaa ,_eb );case 2:_caa =_eff (_aab ,_fcc ,_eaa ,_eb );case 3:_caa =_cgf (_aab ,_fcc ,_eaa ,_eb );
case 4:_caa =_aea (_aab ,_fcc ,_eaa ,_eb );};if _caa !=nil {return nil ,_caa ;};return _fcc ,nil ;};func NextPowerOf2 (n uint )uint {if IsPowerOf2 (n ){return n ;};return 1<<(_efad (n )+1);};func (_cegg *Monochrome )Base ()*ImageBase {return &_cegg .ImageBase };
func (_badb *ImageBase )setEightFullBytes (_efaa int ,_fagc uint64 )error {if _efaa +7> len (_badb .Data )-1{return _ac .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_badb .Data [_efaa ]=byte ((_fagc &0xff00000000000000)>>56);
_badb .Data [_efaa +1]=byte ((_fagc &0xff000000000000)>>48);_badb .Data [_efaa +2]=byte ((_fagc &0xff0000000000)>>40);_badb .Data [_efaa +3]=byte ((_fagc &0xff00000000)>>32);_badb .Data [_efaa +4]=byte ((_fagc &0xff000000)>>24);_badb .Data [_efaa +5]=byte ((_fagc &0xff0000)>>16);
_badb .Data [_efaa +6]=byte ((_fagc &0xff00)>>8);_badb .Data [_efaa +7]=byte (_fagc &0xff);return nil ;};func (_aag *CMYK32 )SetCMYK (x ,y int ,c _d .CMYK ){_cgb :=4*(y *_aag .Width +x );if _cgb +3>=len (_aag .Data ){return ;};_aag .Data [_cgb ]=c .C ;
_aag .Data [_cgb +1]=c .M ;_aag .Data [_cgb +2]=c .Y ;_aag .Data [_cgb +3]=c .K ;};var _ NRGBA =&NRGBA16 {};var _ _de .Image =&Monochrome {};func (_ggc *Gray2 )GrayAt (x ,y int )_d .Gray {_cebg ,_ :=ColorAtGray2BPC (x ,y ,_ggc .BytesPerLine ,_ggc .Data ,_ggc .Decode );
return _cebg ;};func (_eeff *NRGBA16 )ColorModel ()_d .Model {return NRGBA16Model };type Gray8 struct{ImageBase };func (_eaaab *ImageBase )copy ()ImageBase {_gdcg :=*_eaaab ;_gdcg .Data =make ([]byte ,len (_eaaab .Data ));copy (_gdcg .Data ,_eaaab .Data );
return _gdcg ;};func (_dfb *Monochrome )Scale (scale float64 )(*Monochrome ,error ){var _befd bool ;_aafd :=scale ;if scale < 1{_aafd =1/scale ;_befd =true ;};_cegb :=NextPowerOf2 (uint (_aafd ));if InDelta (float64 (_cegb ),_aafd ,0.001){if _befd {return _dfb .ReduceBinary (_aafd );
};return _dfb .ExpandBinary (int (_cegb ));};_bece :=int (_b .RoundToEven (float64 (_dfb .Width )*scale ));_add :=int (_b .RoundToEven (float64 (_dfb .Height )*scale ));return _dfb .ScaleLow (_bece ,_add );};func ColorAtGray16BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_d .Gray16 ,error ){_afce :=(y *bytesPerLine /2+x )*2;
if _afce +1>=len (data ){return _d .Gray16 {},_fa .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_cfag :=uint16 (data [_afce ])<<8|uint16 (data [_afce +1]);if len (decode )==2{_cfag =uint16 (uint64 (LinearInterpolate (float64 (_cfag ),0,65535,decode [0],decode [1])));};return _d .Gray16 {Y :_cfag },nil ;};func _gcac (_bfca _d .NRGBA )_d .NRGBA {_bfca .R =_bfca .R >>4|(_bfca .R >>4)<<4;
_bfca .G =_bfca .G >>4|(_bfca .G >>4)<<4;_bfca .B =_bfca .B >>4|(_bfca .B >>4)<<4;return _bfca ;};func (_cdecb *NRGBA32 )Copy ()Image {return &NRGBA32 {ImageBase :_cdecb .copy ()}};func _dbb ()(_agfg []byte ){_agfg =make ([]byte ,256);for _gafg :=0;_gafg < 256;
_gafg ++{_ded :=byte (_gafg );_agfg [_ded ]=(_ded &0x01)|((_ded &0x04)>>1)|((_ded &0x10)>>2)|((_ded &0x40)>>3)|((_ded &0x02)<<3)|((_ded &0x08)<<2)|((_ded &0x20)<<1)|(_ded &0x80);};return _agfg ;};func (_gbb *Gray8 )Base ()*ImageBase {return &_gbb .ImageBase };
func _gbed (_ddfc _de .Image )(Image ,error ){if _dbbb ,_caag :=_ddfc .(*Gray8 );_caag {return _dbbb .Copy (),nil ;};_fccb :=_ddfc .Bounds ();_bdff ,_gbf :=NewImage (_fccb .Max .X ,_fccb .Max .Y ,8,1,nil ,nil ,nil );if _gbf !=nil {return nil ,_gbf ;};_bbd (_ddfc ,_bdff ,_fccb );
return _bdff ,nil ;};func (_adge *Gray16 )At (x ,y int )_d .Color {_ebeb ,_ :=_adge .ColorAt (x ,y );return _ebeb };func _cgf (_dfcb ,_dcg *Monochrome ,_bdd []byte ,_fdf int )(_gfg error ){var (_adb ,_bda ,_agb ,_cfe ,_fefb ,_bec ,_bga ,_efff int ;_gdf ,_cdf ,_adcd ,_fdc uint32 ;
_age ,_deea byte ;_bbfg uint16 ;);_cee :=make ([]byte ,4);_cdfa :=make ([]byte ,4);for _agb =0;_agb < _dfcb .Height -1;_agb ,_cfe =_agb +2,_cfe +1{_adb =_agb *_dfcb .BytesPerLine ;_bda =_cfe *_dcg .BytesPerLine ;for _fefb ,_bec =0,0;_fefb < _fdf ;_fefb ,_bec =_fefb +4,_bec +1{for _bga =0;
_bga < 4;_bga ++{_efff =_adb +_fefb +_bga ;if _efff <=len (_dfcb .Data )-1&&_efff < _adb +_dfcb .BytesPerLine {_cee [_bga ]=_dfcb .Data [_efff ];}else {_cee [_bga ]=0x00;};_efff =_adb +_dfcb .BytesPerLine +_fefb +_bga ;if _efff <=len (_dfcb .Data )-1&&_efff < _adb +(2*_dfcb .BytesPerLine ){_cdfa [_bga ]=_dfcb .Data [_efff ];
}else {_cdfa [_bga ]=0x00;};};_gdf =_bg .BigEndian .Uint32 (_cee );_cdf =_bg .BigEndian .Uint32 (_cdfa );_adcd =_gdf &_cdf ;_adcd |=_adcd <<1;_fdc =_gdf |_cdf ;_fdc &=_fdc <<1;_cdf =_adcd &_fdc ;_cdf &=0xaaaaaaaa;_gdf =_cdf |(_cdf <<7);_age =byte (_gdf >>24);
_deea =byte ((_gdf >>8)&0xff);_efff =_bda +_bec ;if _efff +1==len (_dcg .Data )-1||_efff +1>=_bda +_dcg .BytesPerLine {if _gfg =_dcg .setByte (_efff ,_bdd [_age ]);_gfg !=nil {return _fa .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_efff );};
}else {_bbfg =(uint16 (_bdd [_age ])<<8)|uint16 (_bdd [_deea ]);if _gfg =_dcg .setTwoBytes (_efff ,_bbfg );_gfg !=nil {return _fa .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_efff );
};_bec ++;};};};return nil ;};func _fea (_cabgg _de .Image ,_baea Image ,_fcgc _de .Rectangle ){for _abce :=0;_abce < _fcgc .Max .X ;_abce ++{for _fbcg :=0;_fbcg < _fcgc .Max .Y ;_fbcg ++{_gdaf :=_cabgg .At (_abce ,_fbcg );_baea .Set (_abce ,_fbcg ,_gdaf );
};};};var _ Gray =&Monochrome {};func (_cdae *Monochrome )InverseData ()error {return _cdae .RasterOperation (0,0,_cdae .Width ,_cdae .Height ,PixNotDst ,nil ,0,0);};func _cecf (_afdc CMYK ,_gagdg Gray ,_cedb _de .Rectangle ){for _ceea :=0;_ceea < _cedb .Max .X ;
_ceea ++{for _gec :=0;_gec < _cedb .Max .Y ;_gec ++{_gafd :=_dbea (_afdc .CMYKAt (_ceea ,_gec ));_gagdg .SetGray (_ceea ,_gec ,_gafd );};};};func (_dfce *Gray2 )Copy ()Image {return &Gray2 {ImageBase :_dfce .copy ()}};type Gray4 struct{ImageBase };func (_ddbc *NRGBA16 )NRGBAAt (x ,y int )_d .NRGBA {_baca ,_ :=ColorAtNRGBA16 (x ,y ,_ddbc .Width ,_ddbc .BytesPerLine ,_ddbc .Data ,_ddbc .Alpha ,_ddbc .Decode );
return _baca ;};func (_ecf *CMYK32 )Copy ()Image {return &CMYK32 {ImageBase :_ecf .copy ()}};func ColorAtGray2BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_d .Gray ,error ){_efed :=y *bytesPerLine +x >>2;if _efed >=len (data ){return _d .Gray {},_fa .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_gee :=data [_efed ]>>uint (6-(x &3)*2)&3;if len (decode )==2{_gee =uint8 (uint32 (LinearInterpolate (float64 (_gee ),0,3.0,decode [0],decode [1]))&3);};return _d .Gray {Y :_gee *85},nil ;};var _ _de .Image =&NRGBA32 {};func (_cegf *Gray2 )Validate ()error {if len (_cegf .Data )!=_cegf .Height *_cegf .BytesPerLine {return ErrInvalidImage ;
};return nil ;};func (_gebfb *NRGBA64 )Copy ()Image {return &NRGBA64 {ImageBase :_gebfb .copy ()}};var _ Image =&Gray16 {};func (_gcfg *Gray8 )ColorAt (x ,y int )(_d .Color ,error ){return ColorAtGray8BPC (x ,y ,_gcfg .BytesPerLine ,_gcfg .Data ,_gcfg .Decode );
};func ColorAtNRGBA64 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_d .NRGBA64 ,error ){_gfge :=(y *width +x )*2;_aeaab :=_gfge *3;if _aeaab +5>=len (data ){return _d .NRGBA64 {},_fa .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};const _adba =0xffff;_bagfg :=uint16 (_adba );if alpha !=nil &&len (alpha )> _gfge +1{_bagfg =uint16 (alpha [_gfge ])<<8|uint16 (alpha [_gfge +1]);};_aedg :=uint16 (data [_aeaab ])<<8|uint16 (data [_aeaab +1]);_fdaf :=uint16 (data [_aeaab +2])<<8|uint16 (data [_aeaab +3]);
_bbca :=uint16 (data [_aeaab +4])<<8|uint16 (data [_aeaab +5]);if len (decode )==6{_aedg =uint16 (uint64 (LinearInterpolate (float64 (_aedg ),0,65535,decode [0],decode [1]))&_adba );_fdaf =uint16 (uint64 (LinearInterpolate (float64 (_fdaf ),0,65535,decode [2],decode [3]))&_adba );
_bbca =uint16 (uint64 (LinearInterpolate (float64 (_bbca ),0,65535,decode [4],decode [5]))&_adba );};return _d .NRGBA64 {R :_aedg ,G :_fdaf ,B :_bbca ,A :_bagfg },nil ;};func _dcfg (_dccag _de .Image ,_dddg Image ,_fecc _de .Rectangle ){if _gfgb ,_fedd :=_dccag .(SMasker );
_fedd &&_gfgb .HasAlpha (){_dddg .(SMasker ).MakeAlpha ();};_fea (_dccag ,_dddg ,_fecc );};type monochromeModel uint8 ;func (_cbaaf *Gray16 )Base ()*ImageBase {return &_cbaaf .ImageBase };func (_aac *Gray2 )Bounds ()_de .Rectangle {return _de .Rectangle {Max :_de .Point {X :_aac .Width ,Y :_aac .Height }};
};func _edff (_ffce RGBA ,_daag NRGBA ,_adag _de .Rectangle ){for _egae :=0;_egae < _adag .Max .X ;_egae ++{for _cbdag :=0;_cbdag < _adag .Max .Y ;_cbdag ++{_bafc :=_ffce .RGBAAt (_egae ,_cbdag );_daag .SetNRGBA (_egae ,_cbdag ,_ega (_bafc ));};};};func (_ecee *Gray16 )Histogram ()(_aed [256]int ){for _fcbe :=0;
_fcbe < _ecee .Width ;_fcbe ++{for _gabb :=0;_gabb < _ecee .Height ;_gabb ++{_aed [_ecee .GrayAt (_fcbe ,_gabb ).Y ]++;};};return _aed ;};var _ _de .Image =&Gray8 {};func (_dage *Gray8 )Copy ()Image {return &Gray8 {ImageBase :_dage .copy ()}};func _fece (_adae int ,_dce int )int {if _adae < _dce {return _adae ;
};return _dce ;};type NRGBA interface{NRGBAAt (_dcaa ,_bbc int )_d .NRGBA ;SetNRGBA (_egec ,_fcge int ,_fgcg _d .NRGBA );};func IsGrayImgBlackAndWhite (i *_de .Gray )bool {return _cbga (i )};func _adca (_ebeg *Monochrome ,_eefc ,_ggb ,_dcad ,_faa int ,_bbeg RasterOperator ,_ecdc *Monochrome ,_bffd ,_bagf int )error {var (_aad bool ;
_cbcf bool ;_fdff byte ;_egca int ;_edfa int ;_aeff int ;_agac int ;_cbbad bool ;_edgec int ;_cgfd int ;_aggg int ;_gcg bool ;_afbbc byte ;_gced int ;_aggdb int ;_dbeg int ;_ebad byte ;_ccag int ;_bcdd int ;_cbae uint ;_aecd uint ;_gbeb byte ;_ceeec shift ;
_ebed bool ;_cfeeb bool ;_fcba ,_afge int ;);if _bffd &7!=0{_bcdd =8-(_bffd &7);};if _eefc &7!=0{_edfa =8-(_eefc &7);};if _bcdd ==0&&_edfa ==0{_gbeb =_gfgg [0];}else {if _edfa > _bcdd {_cbae =uint (_edfa -_bcdd );}else {_cbae =uint (8-(_bcdd -_edfa ));
};_aecd =8-_cbae ;_gbeb =_gfgg [_cbae ];};if (_eefc &7)!=0{_aad =true ;_egca =8-(_eefc &7);_fdff =_gfgg [_egca ];_aeff =_ebeg .BytesPerLine *_ggb +(_eefc >>3);_agac =_ecdc .BytesPerLine *_bagf +(_bffd >>3);_ccag =8-(_bffd &7);if _egca > _ccag {_ceeec =_bafa ;
if _dcad >=_bcdd {_ebed =true ;};}else {_ceeec =_gfdba ;};};if _dcad < _egca {_cbcf =true ;_fdff &=_ebca [8-_egca +_dcad ];};if !_cbcf {_edgec =(_dcad -_egca )>>3;if _edgec !=0{_cbbad =true ;_cgfd =_ebeg .BytesPerLine *_ggb +((_eefc +_edfa )>>3);_aggg =_ecdc .BytesPerLine *_bagf +((_bffd +_edfa )>>3);
};};_gced =(_eefc +_dcad )&7;if !(_cbcf ||_gced ==0){_gcg =true ;_afbbc =_ebca [_gced ];_aggdb =_ebeg .BytesPerLine *_ggb +((_eefc +_edfa )>>3)+_edgec ;_dbeg =_ecdc .BytesPerLine *_bagf +((_bffd +_edfa )>>3)+_edgec ;if _gced > int (_aecd ){_cfeeb =true ;
};};switch _bbeg {case PixSrc :if _aad {for _fcba =0;_fcba < _faa ;_fcba ++{if _ceeec ==_bafa {_ebad =_ecdc .Data [_agac ]<<_cbae ;if _ebed {_ebad =_dabf (_ebad ,_ecdc .Data [_agac +1]>>_aecd ,_gbeb );};}else {_ebad =_ecdc .Data [_agac ]>>_aecd ;};_ebeg .Data [_aeff ]=_dabf (_ebeg .Data [_aeff ],_ebad ,_fdff );
_aeff +=_ebeg .BytesPerLine ;_agac +=_ecdc .BytesPerLine ;};};if _cbbad {for _fcba =0;_fcba < _faa ;_fcba ++{for _afge =0;_afge < _edgec ;_afge ++{_ebad =_dabf (_ecdc .Data [_aggg +_afge ]<<_cbae ,_ecdc .Data [_aggg +_afge +1]>>_aecd ,_gbeb );_ebeg .Data [_cgfd +_afge ]=_ebad ;
};_cgfd +=_ebeg .BytesPerLine ;_aggg +=_ecdc .BytesPerLine ;};};if _gcg {for _fcba =0;_fcba < _faa ;_fcba ++{_ebad =_ecdc .Data [_dbeg ]<<_cbae ;if _cfeeb {_ebad =_dabf (_ebad ,_ecdc .Data [_dbeg +1]>>_aecd ,_gbeb );};_ebeg .Data [_aggdb ]=_dabf (_ebeg .Data [_aggdb ],_ebad ,_afbbc );
_aggdb +=_ebeg .BytesPerLine ;_dbeg +=_ecdc .BytesPerLine ;};};case PixNotSrc :if _aad {for _fcba =0;_fcba < _faa ;_fcba ++{if _ceeec ==_bafa {_ebad =_ecdc .Data [_agac ]<<_cbae ;if _ebed {_ebad =_dabf (_ebad ,_ecdc .Data [_agac +1]>>_aecd ,_gbeb );};}else {_ebad =_ecdc .Data [_agac ]>>_aecd ;
};_ebeg .Data [_aeff ]=_dabf (_ebeg .Data [_aeff ],^_ebad ,_fdff );_aeff +=_ebeg .BytesPerLine ;_agac +=_ecdc .BytesPerLine ;};};if _cbbad {for _fcba =0;_fcba < _faa ;_fcba ++{for _afge =0;_afge < _edgec ;_afge ++{_ebad =_dabf (_ecdc .Data [_aggg +_afge ]<<_cbae ,_ecdc .Data [_aggg +_afge +1]>>_aecd ,_gbeb );
_ebeg .Data [_cgfd +_afge ]=^_ebad ;};_cgfd +=_ebeg .BytesPerLine ;_aggg +=_ecdc .BytesPerLine ;};};if _gcg {for _fcba =0;_fcba < _faa ;_fcba ++{_ebad =_ecdc .Data [_dbeg ]<<_cbae ;if _cfeeb {_ebad =_dabf (_ebad ,_ecdc .Data [_dbeg +1]>>_aecd ,_gbeb );
};_ebeg .Data [_aggdb ]=_dabf (_ebeg .Data [_aggdb ],^_ebad ,_afbbc );_aggdb +=_ebeg .BytesPerLine ;_dbeg +=_ecdc .BytesPerLine ;};};case PixSrcOrDst :if _aad {for _fcba =0;_fcba < _faa ;_fcba ++{if _ceeec ==_bafa {_ebad =_ecdc .Data [_agac ]<<_cbae ;if _ebed {_ebad =_dabf (_ebad ,_ecdc .Data [_agac +1]>>_aecd ,_gbeb );
};}else {_ebad =_ecdc .Data [_agac ]>>_aecd ;};_ebeg .Data [_aeff ]=_dabf (_ebeg .Data [_aeff ],_ebad |_ebeg .Data [_aeff ],_fdff );_aeff +=_ebeg .BytesPerLine ;_agac +=_ecdc .BytesPerLine ;};};if _cbbad {for _fcba =0;_fcba < _faa ;_fcba ++{for _afge =0;
_afge < _edgec ;_afge ++{_ebad =_dabf (_ecdc .Data [_aggg +_afge ]<<_cbae ,_ecdc .Data [_aggg +_afge +1]>>_aecd ,_gbeb );_ebeg .Data [_cgfd +_afge ]|=_ebad ;};_cgfd +=_ebeg .BytesPerLine ;_aggg +=_ecdc .BytesPerLine ;};};if _gcg {for _fcba =0;_fcba < _faa ;
_fcba ++{_ebad =_ecdc .Data [_dbeg ]<<_cbae ;if _cfeeb {_ebad =_dabf (_ebad ,_ecdc .Data [_dbeg +1]>>_aecd ,_gbeb );};_ebeg .Data [_aggdb ]=_dabf (_ebeg .Data [_aggdb ],_ebad |_ebeg .Data [_aggdb ],_afbbc );_aggdb +=_ebeg .BytesPerLine ;_dbeg +=_ecdc .BytesPerLine ;
};};case PixSrcAndDst :if _aad {for _fcba =0;_fcba < _faa ;_fcba ++{if _ceeec ==_bafa {_ebad =_ecdc .Data [_agac ]<<_cbae ;if _ebed {_ebad =_dabf (_ebad ,_ecdc .Data [_agac +1]>>_aecd ,_gbeb );};}else {_ebad =_ecdc .Data [_agac ]>>_aecd ;};_ebeg .Data [_aeff ]=_dabf (_ebeg .Data [_aeff ],_ebad &_ebeg .Data [_aeff ],_fdff );
_aeff +=_ebeg .BytesPerLine ;_agac +=_ecdc .BytesPerLine ;};};if _cbbad {for _fcba =0;_fcba < _faa ;_fcba ++{for _afge =0;_afge < _edgec ;_afge ++{_ebad =_dabf (_ecdc .Data [_aggg +_afge ]<<_cbae ,_ecdc .Data [_aggg +_afge +1]>>_aecd ,_gbeb );_ebeg .Data [_cgfd +_afge ]&=_ebad ;
};_cgfd +=_ebeg .BytesPerLine ;_aggg +=_ecdc .BytesPerLine ;};};if _gcg {for _fcba =0;_fcba < _faa ;_fcba ++{_ebad =_ecdc .Data [_dbeg ]<<_cbae ;if _cfeeb {_ebad =_dabf (_ebad ,_ecdc .Data [_dbeg +1]>>_aecd ,_gbeb );};_ebeg .Data [_aggdb ]=_dabf (_ebeg .Data [_aggdb ],_ebad &_ebeg .Data [_aggdb ],_afbbc );
_aggdb +=_ebeg .BytesPerLine ;_dbeg +=_ecdc .BytesPerLine ;};};case PixSrcXorDst :if _aad {for _fcba =0;_fcba < _faa ;_fcba ++{if _ceeec ==_bafa {_ebad =_ecdc .Data [_agac ]<<_cbae ;if _ebed {_ebad =_dabf (_ebad ,_ecdc .Data [_agac +1]>>_aecd ,_gbeb );
};}else {_ebad =_ecdc .Data [_agac ]>>_aecd ;};_ebeg .Data [_aeff ]=_dabf (_ebeg .Data [_aeff ],_ebad ^_ebeg .Data [_aeff ],_fdff );_aeff +=_ebeg .BytesPerLine ;_agac +=_ecdc .BytesPerLine ;};};if _cbbad {for _fcba =0;_fcba < _faa ;_fcba ++{for _afge =0;
_afge < _edgec ;_afge ++{_ebad =_dabf (_ecdc .Data [_aggg +_afge ]<<_cbae ,_ecdc .Data [_aggg +_afge +1]>>_aecd ,_gbeb );_ebeg .Data [_cgfd +_afge ]^=_ebad ;};_cgfd +=_ebeg .BytesPerLine ;_aggg +=_ecdc .BytesPerLine ;};};if _gcg {for _fcba =0;_fcba < _faa ;
_fcba ++{_ebad =_ecdc .Data [_dbeg ]<<_cbae ;if _cfeeb {_ebad =_dabf (_ebad ,_ecdc .Data [_dbeg +1]>>_aecd ,_gbeb );};_ebeg .Data [_aggdb ]=_dabf (_ebeg .Data [_aggdb ],_ebad ^_ebeg .Data [_aggdb ],_afbbc );_aggdb +=_ebeg .BytesPerLine ;_dbeg +=_ecdc .BytesPerLine ;
};};case PixNotSrcOrDst :if _aad {for _fcba =0;_fcba < _faa ;_fcba ++{if _ceeec ==_bafa {_ebad =_ecdc .Data [_agac ]<<_cbae ;if _ebed {_ebad =_dabf (_ebad ,_ecdc .Data [_agac +1]>>_aecd ,_gbeb );};}else {_ebad =_ecdc .Data [_agac ]>>_aecd ;};_ebeg .Data [_aeff ]=_dabf (_ebeg .Data [_aeff ],^_ebad |_ebeg .Data [_aeff ],_fdff );
_aeff +=_ebeg .BytesPerLine ;_agac +=_ecdc .BytesPerLine ;};};if _cbbad {for _fcba =0;_fcba < _faa ;_fcba ++{for _afge =0;_afge < _edgec ;_afge ++{_ebad =_dabf (_ecdc .Data [_aggg +_afge ]<<_cbae ,_ecdc .Data [_aggg +_afge +1]>>_aecd ,_gbeb );_ebeg .Data [_cgfd +_afge ]|=^_ebad ;
};_cgfd +=_ebeg .BytesPerLine ;_aggg +=_ecdc .BytesPerLine ;};};if _gcg {for _fcba =0;_fcba < _faa ;_fcba ++{_ebad =_ecdc .Data [_dbeg ]<<_cbae ;if _cfeeb {_ebad =_dabf (_ebad ,_ecdc .Data [_dbeg +1]>>_aecd ,_gbeb );};_ebeg .Data [_aggdb ]=_dabf (_ebeg .Data [_aggdb ],^_ebad |_ebeg .Data [_aggdb ],_afbbc );
_aggdb +=_ebeg .BytesPerLine ;_dbeg +=_ecdc .BytesPerLine ;};};case PixNotSrcAndDst :if _aad {for _fcba =0;_fcba < _faa ;_fcba ++{if _ceeec ==_bafa {_ebad =_ecdc .Data [_agac ]<<_cbae ;if _ebed {_ebad =_dabf (_ebad ,_ecdc .Data [_agac +1]>>_aecd ,_gbeb );
};}else {_ebad =_ecdc .Data [_agac ]>>_aecd ;};_ebeg .Data [_aeff ]=_dabf (_ebeg .Data [_aeff ],^_ebad &_ebeg .Data [_aeff ],_fdff );_aeff +=_ebeg .BytesPerLine ;_agac +=_ecdc .BytesPerLine ;};};if _cbbad {for _fcba =0;_fcba < _faa ;_fcba ++{for _afge =0;
_afge < _edgec ;_afge ++{_ebad =_dabf (_ecdc .Data [_aggg +_afge ]<<_cbae ,_ecdc .Data [_aggg +_afge +1]>>_aecd ,_gbeb );_ebeg .Data [_cgfd +_afge ]&=^_ebad ;};_cgfd +=_ebeg .BytesPerLine ;_aggg +=_ecdc .BytesPerLine ;};};if _gcg {for _fcba =0;_fcba < _faa ;
_fcba ++{_ebad =_ecdc .Data [_dbeg ]<<_cbae ;if _cfeeb {_ebad =_dabf (_ebad ,_ecdc .Data [_dbeg +1]>>_aecd ,_gbeb );};_ebeg .Data [_aggdb ]=_dabf (_ebeg .Data [_aggdb ],^_ebad &_ebeg .Data [_aggdb ],_afbbc );_aggdb +=_ebeg .BytesPerLine ;_dbeg +=_ecdc .BytesPerLine ;
};};case PixSrcOrNotDst :if _aad {for _fcba =0;_fcba < _faa ;_fcba ++{if _ceeec ==_bafa {_ebad =_ecdc .Data [_agac ]<<_cbae ;if _ebed {_ebad =_dabf (_ebad ,_ecdc .Data [_agac +1]>>_aecd ,_gbeb );};}else {_ebad =_ecdc .Data [_agac ]>>_aecd ;};_ebeg .Data [_aeff ]=_dabf (_ebeg .Data [_aeff ],_ebad |^_ebeg .Data [_aeff ],_fdff );
_aeff +=_ebeg .BytesPerLine ;_agac +=_ecdc .BytesPerLine ;};};if _cbbad {for _fcba =0;_fcba < _faa ;_fcba ++{for _afge =0;_afge < _edgec ;_afge ++{_ebad =_dabf (_ecdc .Data [_aggg +_afge ]<<_cbae ,_ecdc .Data [_aggg +_afge +1]>>_aecd ,_gbeb );_ebeg .Data [_cgfd +_afge ]=_ebad |^_ebeg .Data [_cgfd +_afge ];
};_cgfd +=_ebeg .BytesPerLine ;_aggg +=_ecdc .BytesPerLine ;};};if _gcg {for _fcba =0;_fcba < _faa ;_fcba ++{_ebad =_ecdc .Data [_dbeg ]<<_cbae ;if _cfeeb {_ebad =_dabf (_ebad ,_ecdc .Data [_dbeg +1]>>_aecd ,_gbeb );};_ebeg .Data [_aggdb ]=_dabf (_ebeg .Data [_aggdb ],_ebad |^_ebeg .Data [_aggdb ],_afbbc );
_aggdb +=_ebeg .BytesPerLine ;_dbeg +=_ecdc .BytesPerLine ;};};case PixSrcAndNotDst :if _aad {for _fcba =0;_fcba < _faa ;_fcba ++{if _ceeec ==_bafa {_ebad =_ecdc .Data [_agac ]<<_cbae ;if _ebed {_ebad =_dabf (_ebad ,_ecdc .Data [_agac +1]>>_aecd ,_gbeb );
};}else {_ebad =_ecdc .Data [_agac ]>>_aecd ;};_ebeg .Data [_aeff ]=_dabf (_ebeg .Data [_aeff ],_ebad &^_ebeg .Data [_aeff ],_fdff );_aeff +=_ebeg .BytesPerLine ;_agac +=_ecdc .BytesPerLine ;};};if _cbbad {for _fcba =0;_fcba < _faa ;_fcba ++{for _afge =0;
_afge < _edgec ;_afge ++{_ebad =_dabf (_ecdc .Data [_aggg +_afge ]<<_cbae ,_ecdc .Data [_aggg +_afge +1]>>_aecd ,_gbeb );_ebeg .Data [_cgfd +_afge ]=_ebad &^_ebeg .Data [_cgfd +_afge ];};_cgfd +=_ebeg .BytesPerLine ;_aggg +=_ecdc .BytesPerLine ;};};if _gcg {for _fcba =0;
_fcba < _faa ;_fcba ++{_ebad =_ecdc .Data [_dbeg ]<<_cbae ;if _cfeeb {_ebad =_dabf (_ebad ,_ecdc .Data [_dbeg +1]>>_aecd ,_gbeb );};_ebeg .Data [_aggdb ]=_dabf (_ebeg .Data [_aggdb ],_ebad &^_ebeg .Data [_aggdb ],_afbbc );_aggdb +=_ebeg .BytesPerLine ;
_dbeg +=_ecdc .BytesPerLine ;};};case PixNotPixSrcOrDst :if _aad {for _fcba =0;_fcba < _faa ;_fcba ++{if _ceeec ==_bafa {_ebad =_ecdc .Data [_agac ]<<_cbae ;if _ebed {_ebad =_dabf (_ebad ,_ecdc .Data [_agac +1]>>_aecd ,_gbeb );};}else {_ebad =_ecdc .Data [_agac ]>>_aecd ;
};_ebeg .Data [_aeff ]=_dabf (_ebeg .Data [_aeff ],^(_ebad |_ebeg .Data [_aeff ]),_fdff );_aeff +=_ebeg .BytesPerLine ;_agac +=_ecdc .BytesPerLine ;};};if _cbbad {for _fcba =0;_fcba < _faa ;_fcba ++{for _afge =0;_afge < _edgec ;_afge ++{_ebad =_dabf (_ecdc .Data [_aggg +_afge ]<<_cbae ,_ecdc .Data [_aggg +_afge +1]>>_aecd ,_gbeb );
_ebeg .Data [_cgfd +_afge ]=^(_ebad |_ebeg .Data [_cgfd +_afge ]);};_cgfd +=_ebeg .BytesPerLine ;_aggg +=_ecdc .BytesPerLine ;};};if _gcg {for _fcba =0;_fcba < _faa ;_fcba ++{_ebad =_ecdc .Data [_dbeg ]<<_cbae ;if _cfeeb {_ebad =_dabf (_ebad ,_ecdc .Data [_dbeg +1]>>_aecd ,_gbeb );
};_ebeg .Data [_aggdb ]=_dabf (_ebeg .Data [_aggdb ],^(_ebad |_ebeg .Data [_aggdb ]),_afbbc );_aggdb +=_ebeg .BytesPerLine ;_dbeg +=_ecdc .BytesPerLine ;};};case PixNotPixSrcAndDst :if _aad {for _fcba =0;_fcba < _faa ;_fcba ++{if _ceeec ==_bafa {_ebad =_ecdc .Data [_agac ]<<_cbae ;
if _ebed {_ebad =_dabf (_ebad ,_ecdc .Data [_agac +1]>>_aecd ,_gbeb );};}else {_ebad =_ecdc .Data [_agac ]>>_aecd ;};_ebeg .Data [_aeff ]=_dabf (_ebeg .Data [_aeff ],^(_ebad &_ebeg .Data [_aeff ]),_fdff );_aeff +=_ebeg .BytesPerLine ;_agac +=_ecdc .BytesPerLine ;
};};if _cbbad {for _fcba =0;_fcba < _faa ;_fcba ++{for _afge =0;_afge < _edgec ;_afge ++{_ebad =_dabf (_ecdc .Data [_aggg +_afge ]<<_cbae ,_ecdc .Data [_aggg +_afge +1]>>_aecd ,_gbeb );_ebeg .Data [_cgfd +_afge ]=^(_ebad &_ebeg .Data [_cgfd +_afge ]);};
_cgfd +=_ebeg .BytesPerLine ;_aggg +=_ecdc .BytesPerLine ;};};if _gcg {for _fcba =0;_fcba < _faa ;_fcba ++{_ebad =_ecdc .Data [_dbeg ]<<_cbae ;if _cfeeb {_ebad =_dabf (_ebad ,_ecdc .Data [_dbeg +1]>>_aecd ,_gbeb );};_ebeg .Data [_aggdb ]=_dabf (_ebeg .Data [_aggdb ],^(_ebad &_ebeg .Data [_aggdb ]),_afbbc );
_aggdb +=_ebeg .BytesPerLine ;_dbeg +=_ecdc .BytesPerLine ;};};case PixNotPixSrcXorDst :if _aad {for _fcba =0;_fcba < _faa ;_fcba ++{if _ceeec ==_bafa {_ebad =_ecdc .Data [_agac ]<<_cbae ;if _ebed {_ebad =_dabf (_ebad ,_ecdc .Data [_agac +1]>>_aecd ,_gbeb );
};}else {_ebad =_ecdc .Data [_agac ]>>_aecd ;};_ebeg .Data [_aeff ]=_dabf (_ebeg .Data [_aeff ],^(_ebad ^_ebeg .Data [_aeff ]),_fdff );_aeff +=_ebeg .BytesPerLine ;_agac +=_ecdc .BytesPerLine ;};};if _cbbad {for _fcba =0;_fcba < _faa ;_fcba ++{for _afge =0;
_afge < _edgec ;_afge ++{_ebad =_dabf (_ecdc .Data [_aggg +_afge ]<<_cbae ,_ecdc .Data [_aggg +_afge +1]>>_aecd ,_gbeb );_ebeg .Data [_cgfd +_afge ]=^(_ebad ^_ebeg .Data [_cgfd +_afge ]);};_cgfd +=_ebeg .BytesPerLine ;_aggg +=_ecdc .BytesPerLine ;};};if _gcg {for _fcba =0;
_fcba < _faa ;_fcba ++{_ebad =_ecdc .Data [_dbeg ]<<_cbae ;if _cfeeb {_ebad =_dabf (_ebad ,_ecdc .Data [_dbeg +1]>>_aecd ,_gbeb );};_ebeg .Data [_aggdb ]=_dabf (_ebeg .Data [_aggdb ],^(_ebad ^_ebeg .Data [_aggdb ]),_afbbc );_aggdb +=_ebeg .BytesPerLine ;
_dbeg +=_ecdc .BytesPerLine ;};};default:_g .Log .Debug ("\u004f\u0070e\u0072\u0061\u0074\u0069\u006f\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006e\u006f\u0074\u0020\u0070\u0065\u0072\u006d\u0069tt\u0065\u0064",_bbeg );return _ac .New ("\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065r\u0061\u0074\u0069\u006f\u006e\u0020\u006eo\u0074\u0020\u0070\u0065\u0072\u006d\u0069\u0074\u0074\u0065\u0064");
};return nil ;};func (_cbff *NRGBA16 )Copy ()Image {return &NRGBA16 {ImageBase :_cbff .copy ()}};func _eaae (_fgfd _de .Image )(Image ,error ){if _dcdb ,_ege :=_fgfd .(*Gray16 );_ege {return _dcdb .Copy (),nil ;};_cgfb :=_fgfd .Bounds ();_dgfd ,_gbdc :=NewImage (_cgfb .Max .X ,_cgfb .Max .Y ,16,1,nil ,nil ,nil );
if _gbdc !=nil {return nil ,_gbdc ;};_bbd (_fgfd ,_dgfd ,_cgfb );return _dgfd ,nil ;};func _afa (){for _bcca :=0;_bcca < 256;_bcca ++{_baba [_bcca ]=uint8 (_bcca &0x1)+(uint8 (_bcca >>1)&0x1)+(uint8 (_bcca >>2)&0x1)+(uint8 (_bcca >>3)&0x1)+(uint8 (_bcca >>4)&0x1)+(uint8 (_bcca >>5)&0x1)+(uint8 (_bcca >>6)&0x1)+(uint8 (_bcca >>7)&0x1);
};};func _geagg (_acacd ,_bccbf uint8 )uint8 {if _acacd < _bccbf {return 255;};return 0;};func (_dbe *CMYK32 )ColorAt (x ,y int )(_d .Color ,error ){return ColorAtCMYK (x ,y ,_dbe .Width ,_dbe .Data ,_dbe .Decode );};const (_bafa shift =iota ;_gfdba ;);
func _bdfc (_beba _de .Image )(Image ,error ){if _decc ,_dbgg :=_beba .(*Monochrome );_dbgg {return _decc ,nil ;};_faf :=_beba .Bounds ();var _fde Gray ;switch _dgc :=_beba .(type ){case Gray :_fde =_dgc ;case NRGBA :_fde =&Gray8 {ImageBase :NewImageBase (_faf .Max .X ,_faf .Max .Y ,8,1,nil ,nil ,nil )};
_efe (_fde ,_dgc ,_faf );case nrgba64 :_fde =&Gray8 {ImageBase :NewImageBase (_faf .Max .X ,_faf .Max .Y ,8,1,nil ,nil ,nil )};_gfe (_fde ,_dgc ,_faf );default:_cfg ,_ddda :=GrayConverter .Convert (_beba );if _ddda !=nil {return nil ,_ddda ;};_fde =_cfg .(Gray );
};_cfdg ,_edge :=NewImage (_faf .Max .X ,_faf .Max .Y ,1,1,nil ,nil ,nil );if _edge !=nil {return nil ,_edge ;};_gbgd :=_cfdg .(*Monochrome );_agee :=AutoThresholdTriangle (GrayHistogram (_fde ));for _ccg :=0;_ccg < _faf .Max .X ;_ccg ++{for _eafe :=0;
_eafe < _faf .Max .Y ;_eafe ++{_bgbdd :=_gcf (_fde .GrayAt (_ccg ,_eafe ),monochromeModel (_agee ));_gbgd .SetGray (_ccg ,_eafe ,_bgbdd );};};return _cfdg ,nil ;};func (_gddg *ImageBase )setEightPartlyBytes (_gdga ,_feffg int ,_ceff uint64 )(_bee error ){var (_dfae byte ;
_befcb int ;);for _ede :=1;_ede <=_feffg ;_ede ++{_befcb =64-_ede *8;_dfae =byte (_ceff >>uint (_befcb )&0xff);if _bee =_gddg .setByte (_gdga +_ede -1,_dfae );_bee !=nil {return _bee ;};};_dgea :=_gddg .BytesPerLine *8-_gddg .Width ;if _dgea ==0{return nil ;
};_befcb -=8;_dfae =byte (_ceff >>uint (_befcb )&0xff)<<uint (_dgea );if _bee =_gddg .setByte (_gdga +_feffg ,_dfae );_bee !=nil {return _bee ;};return nil ;};func _ffbf (_edad _de .Image ,_fggc uint8 )*_de .Gray {_bdda :=_edad .Bounds ();_ebdd :=_de .NewGray (_bdda );
var (_bddac _d .Color ;_bebaa _d .Gray ;);for _agacb :=0;_agacb < _bdda .Max .X ;_agacb ++{for _cedba :=0;_cedba < _bdda .Max .Y ;_cedba ++{_bddac =_edad .At (_agacb ,_cedba );_ebdd .Set (_agacb ,_cedba ,_bddac );_bebaa =_ebdd .GrayAt (_agacb ,_cedba );
_ebdd .SetGray (_agacb ,_cedba ,_d .Gray {Y :_geagg (_bebaa .Y ,_fggc )});};};return _ebdd ;};func _acfe (_gcbg NRGBA ,_fdaba Gray ,_bbab _de .Rectangle ){for _afdg :=0;_afdg < _bbab .Max .X ;_afdg ++{for _bcdg :=0;_bcdg < _bbab .Max .Y ;_bcdg ++{_dac :=_fdab (_gcbg .NRGBAAt (_afdg ,_bcdg ));
_fdaba .SetGray (_afdg ,_bcdg ,_dac );};};};func _fbfc (_abaa Gray ,_gcab NRGBA ,_deeaf _de .Rectangle ){for _ddefc :=0;_ddefc < _deeaf .Max .X ;_ddefc ++{for _cega :=0;_cega < _deeaf .Max .Y ;_cega ++{_dadd :=_abaa .GrayAt (_ddefc ,_cega );_gcab .SetNRGBA (_ddefc ,_cega ,_feda (_dadd ));
};};};