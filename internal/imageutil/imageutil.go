//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package imageutil ;import (_cc "encoding/binary";_f "errors";_ccc "fmt";_ef "github.com/unidoc/unipdf/v3/common";_de "github.com/unidoc/unipdf/v3/internal/bitwise";_c "image";_d "image/color";_b "image/draw";_g "math";);func (_ecf *Gray8 )ColorModel ()_d .Model {return _d .GrayModel };
func NextPowerOf2 (n uint )uint {if IsPowerOf2 (n ){return n ;};return 1<<(_gabde (n )+1);};func _abaf (_ccb ,_dgd *Monochrome ,_ecae []byte ,_gec int )(_fgg error ){var (_ceba ,_efc ,_ebfd ,_decc ,_ebfc ,_baeb ,_dga ,_ggb int ;_afb ,_abc uint32 ;_dbcd ,_adff byte ;
_aea uint16 ;);_eabg :=make ([]byte ,4);_bed :=make ([]byte ,4);for _ebfd =0;_ebfd < _ccb .Height -1;_ebfd ,_decc =_ebfd +2,_decc +1{_ceba =_ebfd *_ccb .BytesPerLine ;_efc =_decc *_dgd .BytesPerLine ;for _ebfc ,_baeb =0,0;_ebfc < _gec ;_ebfc ,_baeb =_ebfc +4,_baeb +1{for _dga =0;
_dga < 4;_dga ++{_ggb =_ceba +_ebfc +_dga ;if _ggb <=len (_ccb .Data )-1&&_ggb < _ceba +_ccb .BytesPerLine {_eabg [_dga ]=_ccb .Data [_ggb ];}else {_eabg [_dga ]=0x00;};_ggb =_ceba +_ccb .BytesPerLine +_ebfc +_dga ;if _ggb <=len (_ccb .Data )-1&&_ggb < _ceba +(2*_ccb .BytesPerLine ){_bed [_dga ]=_ccb .Data [_ggb ];
}else {_bed [_dga ]=0x00;};};_afb =_cc .BigEndian .Uint32 (_eabg );_abc =_cc .BigEndian .Uint32 (_bed );_abc &=_afb ;_abc &=_abc <<1;_abc &=0xaaaaaaaa;_afb =_abc |(_abc <<7);_dbcd =byte (_afb >>24);_adff =byte ((_afb >>8)&0xff);_ggb =_efc +_baeb ;if _ggb +1==len (_dgd .Data )-1||_ggb +1>=_efc +_dgd .BytesPerLine {_dgd .Data [_ggb ]=_ecae [_dbcd ];
if _fgg =_dgd .setByte (_ggb ,_ecae [_dbcd ]);_fgg !=nil {return _ccc .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_ggb );};}else {_aea =(uint16 (_ecae [_dbcd ])<<8)|uint16 (_ecae [_adff ]);if _fgg =_dgd .setTwoBytes (_ggb ,_aea );_fgg !=nil {return _ccc .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_ggb );
};_baeb ++;};};};return nil ;};func (_aeed *NRGBA32 )ColorModel ()_d .Model {return _d .NRGBAModel };func _dce (_fbff RGBA ,_ebba Gray ,_efgce _c .Rectangle ){for _bgge :=0;_bgge < _efgce .Max .X ;_bgge ++{for _bbg :=0;_bbg < _efgce .Max .Y ;_bbg ++{_cae :=_baee (_fbff .RGBAAt (_bgge ,_bbg ));
_ebba .SetGray (_bgge ,_bbg ,_cae );};};};var _ _c .Image =&Monochrome {};func _bef (_eeg _d .NRGBA )_d .CMYK {_dab ,_egee ,_cebg ,_ :=_eeg .RGBA ();_cfgc ,_ebbg ,_cebaf ,_ece :=_d .RGBToCMYK (uint8 (_dab >>8),uint8 (_egee >>8),uint8 (_cebg >>8));return _d .CMYK {C :_cfgc ,M :_ebbg ,Y :_cebaf ,K :_ece };
};func _acg (_bb ,_dbcg *Monochrome ,_bga []byte ,_eaff int )(_aff error ){var (_cegc ,_bee ,_add ,_ddg ,_dcb ,_cga ,_bag ,_afcd int ;_dda ,_bfd ,_abe ,_cccb uint32 ;_gfc ,_gacg byte ;_bgc uint16 ;);_cee :=make ([]byte ,4);_bdeg :=make ([]byte ,4);for _add =0;
_add < _bb .Height -1;_add ,_ddg =_add +2,_ddg +1{_cegc =_add *_bb .BytesPerLine ;_bee =_ddg *_dbcg .BytesPerLine ;for _dcb ,_cga =0,0;_dcb < _eaff ;_dcb ,_cga =_dcb +4,_cga +1{for _bag =0;_bag < 4;_bag ++{_afcd =_cegc +_dcb +_bag ;if _afcd <=len (_bb .Data )-1&&_afcd < _cegc +_bb .BytesPerLine {_cee [_bag ]=_bb .Data [_afcd ];
}else {_cee [_bag ]=0x00;};_afcd =_cegc +_bb .BytesPerLine +_dcb +_bag ;if _afcd <=len (_bb .Data )-1&&_afcd < _cegc +(2*_bb .BytesPerLine ){_bdeg [_bag ]=_bb .Data [_afcd ];}else {_bdeg [_bag ]=0x00;};};_dda =_cc .BigEndian .Uint32 (_cee );_bfd =_cc .BigEndian .Uint32 (_bdeg );
_abe =_dda &_bfd ;_abe |=_abe <<1;_cccb =_dda |_bfd ;_cccb &=_cccb <<1;_bfd =_abe |_cccb ;_bfd &=0xaaaaaaaa;_dda =_bfd |(_bfd <<7);_gfc =byte (_dda >>24);_gacg =byte ((_dda >>8)&0xff);_afcd =_bee +_cga ;if _afcd +1==len (_dbcg .Data )-1||_afcd +1>=_bee +_dbcg .BytesPerLine {if _aff =_dbcg .setByte (_afcd ,_bga [_gfc ]);
_aff !=nil {return _ccc .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_afcd );};}else {_bgc =(uint16 (_bga [_gfc ])<<8)|uint16 (_bga [_gacg ]);if _aff =_dbcg .setTwoBytes (_afcd ,_bgc );_aff !=nil {return _ccc .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_afcd );
};_cga ++;};};};return nil ;};func _cdd (_dbe ,_ebdg *Monochrome ,_ffe []byte ,_bgfc int )(_ffc error ){var (_daga ,_fdec ,_ffb ,_egb ,_ccab ,_effg ,_ecd ,_cddc int ;_bae ,_dae ,_acf ,_edc uint32 ;_ebe ,_aef byte ;_abgd uint16 ;);_afg :=make ([]byte ,4);
_fa :=make ([]byte ,4);for _ffb =0;_ffb < _dbe .Height -1;_ffb ,_egb =_ffb +2,_egb +1{_daga =_ffb *_dbe .BytesPerLine ;_fdec =_egb *_ebdg .BytesPerLine ;for _ccab ,_effg =0,0;_ccab < _bgfc ;_ccab ,_effg =_ccab +4,_effg +1{for _ecd =0;_ecd < 4;_ecd ++{_cddc =_daga +_ccab +_ecd ;
if _cddc <=len (_dbe .Data )-1&&_cddc < _daga +_dbe .BytesPerLine {_afg [_ecd ]=_dbe .Data [_cddc ];}else {_afg [_ecd ]=0x00;};_cddc =_daga +_dbe .BytesPerLine +_ccab +_ecd ;if _cddc <=len (_dbe .Data )-1&&_cddc < _daga +(2*_dbe .BytesPerLine ){_fa [_ecd ]=_dbe .Data [_cddc ];
}else {_fa [_ecd ]=0x00;};};_bae =_cc .BigEndian .Uint32 (_afg );_dae =_cc .BigEndian .Uint32 (_fa );_acf =_bae &_dae ;_acf |=_acf <<1;_edc =_bae |_dae ;_edc &=_edc <<1;_dae =_acf &_edc ;_dae &=0xaaaaaaaa;_bae =_dae |(_dae <<7);_ebe =byte (_bae >>24);_aef =byte ((_bae >>8)&0xff);
_cddc =_fdec +_effg ;if _cddc +1==len (_ebdg .Data )-1||_cddc +1>=_fdec +_ebdg .BytesPerLine {if _ffc =_ebdg .setByte (_cddc ,_ffe [_ebe ]);_ffc !=nil {return _ccc .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_cddc );};}else {_abgd =(uint16 (_ffe [_ebe ])<<8)|uint16 (_ffe [_aef ]);
if _ffc =_ebdg .setTwoBytes (_cddc ,_abgd );_ffc !=nil {return _ccc .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_cddc );
};_effg ++;};};};return nil ;};func (_aaae *Monochrome )ExpandBinary (factor int )(*Monochrome ,error ){if !IsPowerOf2 (uint (factor )){return nil ,_ccc .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0065\u0078\u0070\u0061\u006e\u0064\u0020b\u0069n\u0061\u0072\u0079\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",factor );
};return _a (_aaae ,factor );};func (_egda *Monochrome )IsUnpadded ()bool {return (_egda .Width *_egda .Height )==len (_egda .Data )};func (_egccg *NRGBA32 )setRGBA (_bcbf int ,_bega _d .NRGBA ){_aeaf :=3*_bcbf ;_egccg .Data [_aeaf ]=_bega .R ;_egccg .Data [_aeaf +1]=_bega .G ;
_egccg .Data [_aeaf +2]=_bega .B ;if _bcbf < len (_egccg .Alpha ){_egccg .Alpha [_bcbf ]=_bega .A ;};};func (_cbg *Gray2 )Histogram ()(_geg [256]int ){for _adca :=0;_adca < _cbg .Width ;_adca ++{for _cged :=0;_cged < _cbg .Height ;_cged ++{_geg [_cbg .GrayAt (_adca ,_cged ).Y ]++;
};};return _geg ;};var _ Gray =&Gray2 {};var _ _c .Image =&NRGBA64 {};type colorConverter struct{_fedf func (_gcb _c .Image )(Image ,error );};func (_daf *NRGBA16 )At (x ,y int )_d .Color {_egfc ,_ :=_daf .ColorAt (x ,y );return _egfc };func _aefc (_gedc _c .Image )(Image ,error ){if _aadc ,_cdaa :=_gedc .(*NRGBA64 );
_cdaa {return _aadc .Copy (),nil ;};_fgbe ,_adfe ,_gfde :=_agag (_gedc ,2);_ega ,_efeaa :=NewImage (_fgbe .Max .X ,_fgbe .Max .Y ,16,3,nil ,_gfde ,nil );if _efeaa !=nil {return nil ,_efeaa ;};_cddg (_gedc ,_ega ,_fgbe );if len (_gfde )!=0&&!_adfe {if _feca :=_aaeb (_gfde ,_ega );
_feca !=nil {return nil ,_feca ;};};return _ega ,nil ;};type NRGBA interface{NRGBAAt (_gged ,_geca int )_d .NRGBA ;SetNRGBA (_cfga ,_bdfgd int ,_dgbg _d .NRGBA );};var ErrInvalidImage =_f .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
func (_cgaf *Gray4 )At (x ,y int )_d .Color {_ace ,_ :=_cgaf .ColorAt (x ,y );return _ace };func (_ccdg *Monochrome )Base ()*ImageBase {return &_ccdg .ImageBase };type Gray interface{GrayAt (_eaga ,_egdc int )_d .Gray ;SetGray (_abd ,_aae int ,_eeff _d .Gray );
};func IsPowerOf2 (n uint )bool {return n > 0&&(n &(n -1))==0};type monochromeThresholdConverter struct{Threshold uint8 ;};func (_fagb *Gray16 )Bounds ()_c .Rectangle {return _c .Rectangle {Max :_c .Point {X :_fagb .Width ,Y :_fagb .Height }};};func (_gbee *Monochrome )ResolveDecode ()error {if len (_gbee .Decode )!=2{return nil ;
};if _gbee .Decode [0]==1&&_gbee .Decode [1]==0{if _gce :=_gbee .InverseData ();_gce !=nil {return _gce ;};_gbee .Decode =nil ;};return nil ;};func (_dbed *Gray16 )Base ()*ImageBase {return &_dbed .ImageBase };func (_bfg *Gray8 )Histogram ()(_fdfa [256]int ){for _defc :=0;
_defc < len (_bfg .Data );_defc ++{_fdfa [_bfg .Data [_defc ]]++;};return _fdfa ;};func _cggg (_bgfa _d .NRGBA64 )_d .Gray {var _baga _d .NRGBA64 ;if _bgfa ==_baga {return _d .Gray {Y :0xff};};_gfeb ,_ccf ,_fcf ,_ :=_bgfa .RGBA ();_fbfd :=(19595*_gfeb +38470*_ccf +7471*_fcf +1<<15)>>24;
return _d .Gray {Y :uint8 (_fbfd )};};func _gcbf (_aaed *Monochrome ,_gace ,_bdbc int ,_ebfb ,_egfg int ,_aagb RasterOperator ,_aefe *Monochrome ,_gfaf ,_cfcb int )error {var _gbda ,_dgag ,_bda ,_ded int ;if _gace < 0{_gfaf -=_gace ;_ebfb +=_gace ;_gace =0;
};if _gfaf < 0{_gace -=_gfaf ;_ebfb +=_gfaf ;_gfaf =0;};_gbda =_gace +_ebfb -_aaed .Width ;if _gbda > 0{_ebfb -=_gbda ;};_dgag =_gfaf +_ebfb -_aefe .Width ;if _dgag > 0{_ebfb -=_dgag ;};if _bdbc < 0{_cfcb -=_bdbc ;_egfg +=_bdbc ;_bdbc =0;};if _cfcb < 0{_bdbc -=_cfcb ;
_egfg +=_cfcb ;_cfcb =0;};_bda =_bdbc +_egfg -_aaed .Height ;if _bda > 0{_egfg -=_bda ;};_ded =_cfcb +_egfg -_aefe .Height ;if _ded > 0{_egfg -=_ded ;};if _ebfb <=0||_egfg <=0{return nil ;};var _agfg error ;switch {case _gace &7==0&&_gfaf &7==0:_agfg =_eefe (_aaed ,_gace ,_bdbc ,_ebfb ,_egfg ,_aagb ,_aefe ,_gfaf ,_cfcb );
case _gace &7==_gfaf &7:_agfg =_dgcf (_aaed ,_gace ,_bdbc ,_ebfb ,_egfg ,_aagb ,_aefe ,_gfaf ,_cfcb );default:_agfg =_fdeg (_aaed ,_gace ,_bdbc ,_ebfb ,_egfg ,_aagb ,_aefe ,_gfaf ,_cfcb );};if _agfg !=nil {return _agfg ;};return nil ;};func (_edg *Gray2 )Bounds ()_c .Rectangle {return _c .Rectangle {Max :_c .Point {X :_edg .Width ,Y :_edg .Height }};
};func FromGoImage (i _c .Image )(Image ,error ){switch _efdc :=i .(type ){case Image :return _efdc .Copy (),nil ;case Gray :return GrayConverter .Convert (i );case *_c .Gray16 :return Gray16Converter .Convert (i );case CMYK :return CMYKConverter .Convert (i );
case *_c .NRGBA64 :return NRGBA64Converter .Convert (i );default:return NRGBAConverter .Convert (i );};};func (_ddbd *Monochrome )ColorModel ()_d .Model {return MonochromeModel (_ddbd .ModelThreshold )};func _cdgdd (_cdgfg _c .Image ,_fcag Image ,_caga _c .Rectangle ){if _cfab ,_bdbag :=_cdgfg .(SMasker );
_bdbag &&_cfab .HasAlpha (){_fcag .(SMasker ).MakeAlpha ();};switch _bcae :=_cdgfg .(type ){case Gray :_edab (_bcae ,_fcag .(NRGBA ),_caga );case NRGBA :_gcea (_bcae ,_fcag .(NRGBA ),_caga );case *_c .NYCbCrA :_aedf (_bcae ,_fcag .(NRGBA ),_caga );case CMYK :_bbb (_bcae ,_fcag .(NRGBA ),_caga );
case RGBA :_gcbe (_bcae ,_fcag .(NRGBA ),_caga );case nrgba64 :_aede (_bcae ,_fcag .(NRGBA ),_caga );default:_gabb (_cdgfg ,_fcag ,_caga );};};func (_fdbb *Gray2 )Set (x ,y int ,c _d .Color ){if x >=_fdbb .Width ||y >=_fdbb .Height {return ;};_bgcd :=Gray2Model .Convert (c ).(_d .Gray );
_bdfg :=y *_fdbb .BytesPerLine ;_ecef :=_bdfg +(x >>2);_aafe :=_bgcd .Y >>6;_fdbb .Data [_ecef ]=(_fdbb .Data [_ecef ]&(^(0xc0>>uint (2*((x )&3)))))|(_aafe <<uint (6-2*(x &3)));};type Gray16 struct{ImageBase };func (_fbebc *ImageBase )newAlpha (){_afgd :=BytesPerLine (_fbebc .Width ,_fbebc .BitsPerComponent ,1);
_fbebc .Alpha =make ([]byte ,_fbebc .Height *_afgd );};func _bdbcc (_afgb uint8 )bool {if _afgb ==0||_afgb ==255{return true ;};return false ;};func _ddba (_gcf _d .Gray ,_egce monochromeModel )_d .Gray {if _gcf .Y > uint8 (_egce ){return _d .Gray {Y :_g .MaxUint8 };
};return _d .Gray {};};type RGBA interface{RGBAAt (_ggef ,_agba int )_d .RGBA ;SetRGBA (_beba ,_bbfe int ,_bcad _d .RGBA );};func ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor int ,data ,alpha []byte ,decode []float64 )(_d .Color ,error ){switch bitsPerColor {case 4:return ColorAtNRGBA16 (x ,y ,width ,bytesPerLine ,data ,alpha ,decode );
case 8:return ColorAtNRGBA32 (x ,y ,width ,data ,alpha ,decode );case 16:return ColorAtNRGBA64 (x ,y ,width ,data ,alpha ,decode );default:return nil ,_ccc .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0067\u0062\u0020b\u0069\u0074\u0073\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0061\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );
};};func (_dccg *Monochrome )ReduceBinary (factor float64 )(*Monochrome ,error ){_cac :=_gabde (uint (factor ));if !IsPowerOf2 (uint (factor )){_cac ++;};_gde :=make ([]int ,_cac );for _aaee :=range _gde {_gde [_aaee ]=4;};_dgad ,_dgef :=_cgf (_dccg ,_gde ...);
if _dgef !=nil {return nil ,_dgef ;};return _dgad ,nil ;};func (_gdeg *Monochrome )getBitAt (_fab ,_baff int )bool {_dgc :=_baff *_gdeg .BytesPerLine +(_fab >>3);_dagg :=_fab &0x07;_gbgb :=uint (7-_dagg );if _dgc > len (_gdeg .Data )-1{return false ;};
if (_gdeg .Data [_dgc ]>>_gbgb )&0x01>=1{return true ;};return false ;};var _ NRGBA =&NRGBA32 {};var _ _c .Image =&NRGBA16 {};func (_gfee *Monochrome )GrayAt (x ,y int )_d .Gray {_eeda ,_ :=ColorAtGray1BPC (x ,y ,_gfee .BytesPerLine ,_gfee .Data ,_gfee .Decode );
return _eeda ;};func (_fcdbe *NRGBA16 )Validate ()error {if len (_fcdbe .Data )!=3*_fcdbe .Width *_fcdbe .Height /2{return _f .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func _eab (_dba ,_egd int )*Monochrome {return &Monochrome {ImageBase :NewImageBase (_dba ,_egd ,1,1,nil ,nil ,nil ),ModelThreshold :0x0f};};func (_eeabb *Gray4 )Histogram ()(_degg [256]int ){for _bfdd :=0;_bfdd < _eeabb .Width ;_bfdd ++{for _gcc :=0;
_gcc < _eeabb .Height ;_gcc ++{_degg [_eeabb .GrayAt (_bfdd ,_gcc ).Y ]++;};};return _degg ;};func _ddee (_bace _c .Image )(Image ,error ){if _dage ,_dbcc :=_bace .(*Gray8 );_dbcc {return _dage .Copy (),nil ;};_ebc :=_bace .Bounds ();_caf ,_dgdf :=NewImage (_ebc .Max .X ,_ebc .Max .Y ,8,1,nil ,nil ,nil );
if _dgdf !=nil {return nil ,_dgdf ;};_gbaa (_bace ,_caf ,_ebc );return _caf ,nil ;};func _cdda (_acb _d .Gray )_d .NRGBA {return _d .NRGBA {R :_acb .Y ,G :_acb .Y ,B :_acb .Y ,A :0xff}};func (_dfg *Gray4 )GrayAt (x ,y int )_d .Gray {_gaec ,_ :=ColorAtGray4BPC (x ,y ,_dfg .BytesPerLine ,_dfg .Data ,_dfg .Decode );
return _gaec ;};func (_ecgb *NRGBA32 )Base ()*ImageBase {return &_ecgb .ImageBase };func (_fcgd *Monochrome )Copy ()Image {return &Monochrome {ImageBase :_fcgd .ImageBase .copy (),ModelThreshold :_fcgd .ModelThreshold };};func GrayHistogram (g Gray )(_bbaf [256]int ){switch _egbff :=g .(type ){case Histogramer :return _egbff .Histogram ();
case _c .Image :_aaea :=_egbff .Bounds ();for _fafg :=0;_fafg < _aaea .Max .X ;_fafg ++{for _bada :=0;_bada < _aaea .Max .Y ;_bada ++{_bbaf [g .GrayAt (_fafg ,_bada ).Y ]++;};};return _bbaf ;default:return [256]int {};};};func (_cdbd *Gray4 )ColorModel ()_d .Model {return Gray4Model };
func RasterOperation (dest *Monochrome ,dx ,dy ,dw ,dh int ,op RasterOperator ,src *Monochrome ,sx ,sy int )error {return _fefb (dest ,dx ,dy ,dw ,dh ,op ,src ,sx ,sy );};func (_cfd *Monochrome )copy ()*Monochrome {_ffd :=_eab (_cfd .Width ,_cfd .Height );
_ffd .ModelThreshold =_cfd .ModelThreshold ;_ffd .Data =make ([]byte ,len (_cfd .Data ));copy (_ffd .Data ,_cfd .Data );if len (_cfd .Decode )!=0{_ffd .Decode =make ([]float64 ,len (_cfd .Decode ));copy (_ffd .Decode ,_cfd .Decode );};if len (_cfd .Alpha )!=0{_ffd .Alpha =make ([]byte ,len (_cfd .Alpha ));
copy (_ffd .Alpha ,_cfd .Alpha );};return _ffd ;};func (_efgc *Gray16 )ColorModel ()_d .Model {return _d .Gray16Model };var (_gggg =[]byte {0x00,0x80,0xC0,0xE0,0xF0,0xF8,0xFC,0xFE,0xFF};_daae =[]byte {0x00,0x01,0x03,0x07,0x0F,0x1F,0x3F,0x7F,0xFF};);func (_bggd *NRGBA16 )SetNRGBA (x ,y int ,c _d .NRGBA ){_afge :=y *_bggd .BytesPerLine +x *3/2;
if _afge +1>=len (_bggd .Data ){return ;};c =_gabe (c );_bggd .setNRGBA (x ,y ,_afge ,c );};func LinearInterpolate (x ,xmin ,xmax ,ymin ,ymax float64 )float64 {if _g .Abs (xmax -xmin )< 0.000001{return ymin ;};_gcfg :=ymin +(x -xmin )*(ymax -ymin )/(xmax -xmin );
return _gcfg ;};func _bdeb (_edf _c .Image )(Image ,error ){if _aag ,_aafc :=_edf .(*Gray2 );_aafc {return _aag .Copy (),nil ;};_gad :=_edf .Bounds ();_abad ,_fcc :=NewImage (_gad .Max .X ,_gad .Max .Y ,2,1,nil ,nil ,nil );if _fcc !=nil {return nil ,_fcc ;
};_gbaa (_edf ,_abad ,_gad );return _abad ,nil ;};func init (){_acggd ()};func (_ffce *Gray8 )Base ()*ImageBase {return &_ffce .ImageBase };type monochromeModel uint8 ;var _ _c .Image =&Gray2 {};func _eefe (_ccad *Monochrome ,_ddec ,_gcdfa ,_gefe ,_bbcc int ,_ccbb RasterOperator ,_egcea *Monochrome ,_ffcd ,_fgfg int )error {var (_aefb byte ;
_gbeb int ;_gge int ;_becb ,_bbgf int ;_geaa ,_dabf int ;);_gcaa :=_gefe >>3;_aeef :=_gefe &7;if _aeef > 0{_aefb =_gggg [_aeef ];};_gbeb =_egcea .BytesPerLine *_fgfg +(_ffcd >>3);_gge =_ccad .BytesPerLine *_gcdfa +(_ddec >>3);switch _ccbb {case PixSrc :for _geaa =0;
_geaa < _bbcc ;_geaa ++{_becb =_gbeb +_geaa *_egcea .BytesPerLine ;_bbgf =_gge +_geaa *_ccad .BytesPerLine ;for _dabf =0;_dabf < _gcaa ;_dabf ++{_ccad .Data [_bbgf ]=_egcea .Data [_becb ];_bbgf ++;_becb ++;};if _aeef > 0{_ccad .Data [_bbgf ]=_bagb (_ccad .Data [_bbgf ],_egcea .Data [_becb ],_aefb );
};};case PixNotSrc :for _geaa =0;_geaa < _bbcc ;_geaa ++{_becb =_gbeb +_geaa *_egcea .BytesPerLine ;_bbgf =_gge +_geaa *_ccad .BytesPerLine ;for _dabf =0;_dabf < _gcaa ;_dabf ++{_ccad .Data [_bbgf ]=^(_egcea .Data [_becb ]);_bbgf ++;_becb ++;};if _aeef > 0{_ccad .Data [_bbgf ]=_bagb (_ccad .Data [_bbgf ],^_egcea .Data [_becb ],_aefb );
};};case PixSrcOrDst :for _geaa =0;_geaa < _bbcc ;_geaa ++{_becb =_gbeb +_geaa *_egcea .BytesPerLine ;_bbgf =_gge +_geaa *_ccad .BytesPerLine ;for _dabf =0;_dabf < _gcaa ;_dabf ++{_ccad .Data [_bbgf ]|=_egcea .Data [_becb ];_bbgf ++;_becb ++;};if _aeef > 0{_ccad .Data [_bbgf ]=_bagb (_ccad .Data [_bbgf ],_egcea .Data [_becb ]|_ccad .Data [_bbgf ],_aefb );
};};case PixSrcAndDst :for _geaa =0;_geaa < _bbcc ;_geaa ++{_becb =_gbeb +_geaa *_egcea .BytesPerLine ;_bbgf =_gge +_geaa *_ccad .BytesPerLine ;for _dabf =0;_dabf < _gcaa ;_dabf ++{_ccad .Data [_bbgf ]&=_egcea .Data [_becb ];_bbgf ++;_becb ++;};if _aeef > 0{_ccad .Data [_bbgf ]=_bagb (_ccad .Data [_bbgf ],_egcea .Data [_becb ]&_ccad .Data [_bbgf ],_aefb );
};};case PixSrcXorDst :for _geaa =0;_geaa < _bbcc ;_geaa ++{_becb =_gbeb +_geaa *_egcea .BytesPerLine ;_bbgf =_gge +_geaa *_ccad .BytesPerLine ;for _dabf =0;_dabf < _gcaa ;_dabf ++{_ccad .Data [_bbgf ]^=_egcea .Data [_becb ];_bbgf ++;_becb ++;};if _aeef > 0{_ccad .Data [_bbgf ]=_bagb (_ccad .Data [_bbgf ],_egcea .Data [_becb ]^_ccad .Data [_bbgf ],_aefb );
};};case PixNotSrcOrDst :for _geaa =0;_geaa < _bbcc ;_geaa ++{_becb =_gbeb +_geaa *_egcea .BytesPerLine ;_bbgf =_gge +_geaa *_ccad .BytesPerLine ;for _dabf =0;_dabf < _gcaa ;_dabf ++{_ccad .Data [_bbgf ]|=^(_egcea .Data [_becb ]);_bbgf ++;_becb ++;};if _aeef > 0{_ccad .Data [_bbgf ]=_bagb (_ccad .Data [_bbgf ],^(_egcea .Data [_becb ])|_ccad .Data [_bbgf ],_aefb );
};};case PixNotSrcAndDst :for _geaa =0;_geaa < _bbcc ;_geaa ++{_becb =_gbeb +_geaa *_egcea .BytesPerLine ;_bbgf =_gge +_geaa *_ccad .BytesPerLine ;for _dabf =0;_dabf < _gcaa ;_dabf ++{_ccad .Data [_bbgf ]&=^(_egcea .Data [_becb ]);_bbgf ++;_becb ++;};if _aeef > 0{_ccad .Data [_bbgf ]=_bagb (_ccad .Data [_bbgf ],^(_egcea .Data [_becb ])&_ccad .Data [_bbgf ],_aefb );
};};case PixSrcOrNotDst :for _geaa =0;_geaa < _bbcc ;_geaa ++{_becb =_gbeb +_geaa *_egcea .BytesPerLine ;_bbgf =_gge +_geaa *_ccad .BytesPerLine ;for _dabf =0;_dabf < _gcaa ;_dabf ++{_ccad .Data [_bbgf ]=_egcea .Data [_becb ]|^(_ccad .Data [_bbgf ]);_bbgf ++;
_becb ++;};if _aeef > 0{_ccad .Data [_bbgf ]=_bagb (_ccad .Data [_bbgf ],_egcea .Data [_becb ]|^(_ccad .Data [_bbgf ]),_aefb );};};case PixSrcAndNotDst :for _geaa =0;_geaa < _bbcc ;_geaa ++{_becb =_gbeb +_geaa *_egcea .BytesPerLine ;_bbgf =_gge +_geaa *_ccad .BytesPerLine ;
for _dabf =0;_dabf < _gcaa ;_dabf ++{_ccad .Data [_bbgf ]=_egcea .Data [_becb ]&^(_ccad .Data [_bbgf ]);_bbgf ++;_becb ++;};if _aeef > 0{_ccad .Data [_bbgf ]=_bagb (_ccad .Data [_bbgf ],_egcea .Data [_becb ]&^(_ccad .Data [_bbgf ]),_aefb );};};case PixNotPixSrcOrDst :for _geaa =0;
_geaa < _bbcc ;_geaa ++{_becb =_gbeb +_geaa *_egcea .BytesPerLine ;_bbgf =_gge +_geaa *_ccad .BytesPerLine ;for _dabf =0;_dabf < _gcaa ;_dabf ++{_ccad .Data [_bbgf ]=^(_egcea .Data [_becb ]|_ccad .Data [_bbgf ]);_bbgf ++;_becb ++;};if _aeef > 0{_ccad .Data [_bbgf ]=_bagb (_ccad .Data [_bbgf ],^(_egcea .Data [_becb ]|_ccad .Data [_bbgf ]),_aefb );
};};case PixNotPixSrcAndDst :for _geaa =0;_geaa < _bbcc ;_geaa ++{_becb =_gbeb +_geaa *_egcea .BytesPerLine ;_bbgf =_gge +_geaa *_ccad .BytesPerLine ;for _dabf =0;_dabf < _gcaa ;_dabf ++{_ccad .Data [_bbgf ]=^(_egcea .Data [_becb ]&_ccad .Data [_bbgf ]);
_bbgf ++;_becb ++;};if _aeef > 0{_ccad .Data [_bbgf ]=_bagb (_ccad .Data [_bbgf ],^(_egcea .Data [_becb ]&_ccad .Data [_bbgf ]),_aefb );};};case PixNotPixSrcXorDst :for _geaa =0;_geaa < _bbcc ;_geaa ++{_becb =_gbeb +_geaa *_egcea .BytesPerLine ;_bbgf =_gge +_geaa *_ccad .BytesPerLine ;
for _dabf =0;_dabf < _gcaa ;_dabf ++{_ccad .Data [_bbgf ]=^(_egcea .Data [_becb ]^_ccad .Data [_bbgf ]);_bbgf ++;_becb ++;};if _aeef > 0{_ccad .Data [_bbgf ]=_bagb (_ccad .Data [_bbgf ],^(_egcea .Data [_becb ]^_ccad .Data [_bbgf ]),_aefb );};};default:_ef .Log .Debug ("\u0050\u0072ov\u0069\u0064\u0065d\u0020\u0069\u006e\u0076ali\u0064 r\u0061\u0073\u0074\u0065\u0072\u0020\u006fpe\u0072\u0061\u0074\u006f\u0072\u003a\u0020%\u0076",_ccbb );
return _f .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072");};return nil ;};func _cegae (_fbd CMYK ,_deccg Gray ,_adfd _c .Rectangle ){for _befc :=0;_befc < _adfd .Max .X ;
_befc ++{for _abgdb :=0;_abgdb < _adfd .Max .Y ;_abgdb ++{_fege :=_aged (_fbd .CMYKAt (_befc ,_abgdb ));_deccg .SetGray (_befc ,_abgdb ,_fege );};};};func (_fffg *Gray8 )Bounds ()_c .Rectangle {return _c .Rectangle {Max :_c .Point {X :_fffg .Width ,Y :_fffg .Height }};
};var _cebafg [256]uint8 ;func (_efd *Monochrome )Scale (scale float64 )(*Monochrome ,error ){var _afbf bool ;_fddd :=scale ;if scale < 1{_fddd =1/scale ;_afbf =true ;};_badd :=NextPowerOf2 (uint (_fddd ));if InDelta (float64 (_badd ),_fddd ,0.001){if _afbf {return _efd .ReduceBinary (_fddd );
};return _efd .ExpandBinary (int (_badd ));};_gbba :=int (_g .RoundToEven (float64 (_efd .Width )*scale ));_cbag :=int (_g .RoundToEven (float64 (_efd .Height )*scale ));return _efd .ScaleLow (_gbba ,_cbag );};func _gbaa (_bfbf _c .Image ,_gdfe Image ,_eccc _c .Rectangle ){switch _ced :=_bfbf .(type ){case Gray :_daa (_ced ,_gdfe .(Gray ),_eccc );
case NRGBA :_dgda (_ced ,_gdfe .(Gray ),_eccc );case CMYK :_cegae (_ced ,_gdfe .(Gray ),_eccc );case RGBA :_dce (_ced ,_gdfe .(Gray ),_eccc );default:_gabb (_bfbf ,_gdfe .(Image ),_eccc );};};type Gray4 struct{ImageBase };func (_ccdc *Gray4 )ColorAt (x ,y int )(_d .Color ,error ){return ColorAtGray4BPC (x ,y ,_ccdc .BytesPerLine ,_ccdc .Data ,_ccdc .Decode );
};func (_bcab *Monochrome )setIndexedBit (_eeab int ){_bcab .Data [(_eeab >>3)]|=0x80>>uint (_eeab &7)};func (_fgge *CMYK32 )CMYKAt (x ,y int )_d .CMYK {_beb ,_ :=ColorAtCMYK (x ,y ,_fgge .Width ,_fgge .Data ,_fgge .Decode );return _beb ;};func MonochromeModel (threshold uint8 )_d .Model {return monochromeModel (threshold )};
func _aedf (_dfdef *_c .NYCbCrA ,_eecd NRGBA ,_dbbe _c .Rectangle ){for _eedb :=0;_eedb < _dbbe .Max .X ;_eedb ++{for _abccb :=0;_abccb < _dbbe .Max .Y ;_abccb ++{_bbgd :=_dfdef .NYCbCrAAt (_eedb ,_abccb );_eecd .SetNRGBA (_eedb ,_abccb ,_dca (_bbgd ));
};};};func _cge ()(_gaac [256]uint64 ){for _eaf :=0;_eaf < 256;_eaf ++{if _eaf &0x01!=0{_gaac [_eaf ]|=0xff;};if _eaf &0x02!=0{_gaac [_eaf ]|=0xff00;};if _eaf &0x04!=0{_gaac [_eaf ]|=0xff0000;};if _eaf &0x08!=0{_gaac [_eaf ]|=0xff000000;};if _eaf &0x10!=0{_gaac [_eaf ]|=0xff00000000;
};if _eaf &0x20!=0{_gaac [_eaf ]|=0xff0000000000;};if _eaf &0x40!=0{_gaac [_eaf ]|=0xff000000000000;};if _eaf &0x80!=0{_gaac [_eaf ]|=0xff00000000000000;};};return _gaac ;};func _febcf (_eceg *Monochrome ,_ada ,_dcba ,_eega ,_decca int ,_fdbbf RasterOperator ){if _ada < 0{_eega +=_ada ;
_ada =0;};_dfcbcf :=_ada +_eega -_eceg .Width ;if _dfcbcf > 0{_eega -=_dfcbcf ;};if _dcba < 0{_decca +=_dcba ;_dcba =0;};_bgee :=_dcba +_decca -_eceg .Height ;if _bgee > 0{_decca -=_bgee ;};if _eega <=0||_decca <=0{return ;};if (_ada &7)==0{_dcab (_eceg ,_ada ,_dcba ,_eega ,_decca ,_fdbbf );
}else {_fbac (_eceg ,_ada ,_dcba ,_eega ,_decca ,_fdbbf );};};var (MonochromeConverter =ConverterFunc (_aeaa );Gray2Converter =ConverterFunc (_bdeb );Gray4Converter =ConverterFunc (_cdgf );GrayConverter =ConverterFunc (_ddee );Gray16Converter =ConverterFunc (_fdee );
NRGBA16Converter =ConverterFunc (_fcace );NRGBAConverter =ConverterFunc (_fcaa );NRGBA64Converter =ConverterFunc (_aefc );CMYKConverter =ConverterFunc (_ebed ););func AutoThresholdTriangle (histogram [256]int )uint8 {var _acbd ,_abgc ,_dfea ,_gfad int ;
for _cbea :=0;_cbea < len (histogram );_cbea ++{if histogram [_cbea ]> 0{_acbd =_cbea ;break ;};};if _acbd > 0{_acbd --;};for _gcac :=255;_gcac > 0;_gcac --{if histogram [_gcac ]> 0{_gfad =_gcac ;break ;};};if _gfad < 255{_gfad ++;};for _dffc :=0;_dffc < 256;
_dffc ++{if histogram [_dffc ]> _abgc {_dfea =_dffc ;_abgc =histogram [_dffc ];};};var _febea bool ;if (_dfea -_acbd )< (_gfad -_dfea ){_febea =true ;var _caagb int ;_cfad :=255;for _caagb < _cfad {_dgbgf :=histogram [_caagb ];histogram [_caagb ]=histogram [_cfad ];
histogram [_cfad ]=_dgbgf ;_caagb ++;_cfad --;};_acbd =255-_gfad ;_dfea =255-_dfea ;};if _acbd ==_dfea {return uint8 (_acbd );};_gaece :=float64 (histogram [_dfea ]);_cbfbb :=float64 (_acbd -_dfea );_ageg :=_g .Sqrt (_gaece *_gaece +_cbfbb *_cbfbb );_gaece /=_ageg ;
_cbfbb /=_ageg ;_ageg =_gaece *float64 (_acbd )+_cbfbb *float64 (histogram [_acbd ]);_acd :=_acbd ;var _dbde float64 ;for _eae :=_acbd +1;_eae <=_dfea ;_eae ++{_fcef :=_gaece *float64 (_eae )+_cbfbb *float64 (histogram [_eae ])-_ageg ;if _fcef > _dbde {_acd =_eae ;
_dbde =_fcef ;};};_acd --;if _febea {var _cbeb int ;_eeadf :=255;for _cbeb < _eeadf {_bgfcc :=histogram [_cbeb ];histogram [_cbeb ]=histogram [_eeadf ];histogram [_eeadf ]=_bgfcc ;_cbeb ++;_eeadf --;};return uint8 (255-_acd );};return uint8 (_acd );};type CMYK interface{CMYKAt (_bcd ,_df int )_d .CMYK ;
SetCMYK (_bff ,_cbc int ,_cdbb _d .CMYK );};func _dfbg (_acade _d .Gray )_d .Gray {_ddfa :=_acade .Y >>6;_ddfa |=_ddfa <<2;_acade .Y =_ddfa |_ddfa <<4;return _acade ;};var _ Image =&Gray4 {};type shift int ;func (_ddca *Monochrome )AddPadding ()(_beec error ){if _gdc :=((_ddca .Width *_ddca .Height )+7)>>3;
len (_ddca .Data )< _gdc {return _ccc .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064a\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002e\u0020\u0054\u0068\u0065\u0020\u0064\u0061t\u0061\u0020s\u0068\u006fu\u006c\u0064\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0020\u0061\u0074 l\u0065\u0061\u0073\u0074\u003a\u0020\u0027\u0025\u0064'\u0020\u0062\u0079\u0074\u0065\u0073",len (_ddca .Data ),_gdc );
};_gbdf :=_ddca .Width %8;if _gbdf ==0{return nil ;};_edce :=_ddca .Width /8;_adcb :=_de .NewReader (_ddca .Data );_dfdc :=make ([]byte ,_ddca .Height *_ddca .BytesPerLine );_beaf :=_de .NewWriterMSB (_dfdc );_bgfb :=make ([]byte ,_edce );var (_fdg int ;
_gcg uint64 ;);for _fdg =0;_fdg < _ddca .Height ;_fdg ++{if _ ,_beec =_adcb .Read (_bgfb );_beec !=nil {return _beec ;};if _ ,_beec =_beaf .Write (_bgfb );_beec !=nil {return _beec ;};if _gcg ,_beec =_adcb .ReadBits (byte (_gbdf ));_beec !=nil {return _beec ;
};if _beec =_beaf .WriteByte (byte (_gcg )<<uint (8-_gbdf ));_beec !=nil {return _beec ;};};_ddca .Data =_beaf .Data ();return nil ;};func ColorAtNRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_d .NRGBA ,error ){_gdcd :=y *width +x ;_fbab :=3*_gdcd ;
if _fbab +2>=len (data ){return _d .NRGBA {},_ccc .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_caag :=uint8 (0xff);if alpha !=nil &&len (alpha )> _gdcd {_caag =alpha [_gdcd ];};_aadd ,_eecb ,_dgcbd :=data [_fbab ],data [_fbab +1],data [_fbab +2];if len (decode )==6{_aadd =uint8 (uint32 (LinearInterpolate (float64 (_aadd ),0,255,decode [0],decode [1]))&0xff);
_eecb =uint8 (uint32 (LinearInterpolate (float64 (_eecb ),0,255,decode [2],decode [3]))&0xff);_dgcbd =uint8 (uint32 (LinearInterpolate (float64 (_dgcbd ),0,255,decode [4],decode [5]))&0xff);};return _d .NRGBA {R :_aadd ,G :_eecb ,B :_dgcbd ,A :_caag },nil ;
};func _agag (_efcg _c .Image ,_ecfb int )(_c .Rectangle ,bool ,[]byte ){_abcc :=_efcg .Bounds ();var (_egccc bool ;_cffb []byte ;);switch _adefc :=_efcg .(type ){case SMasker :_egccc =_adefc .HasAlpha ();case NRGBA ,RGBA ,*_c .RGBA64 ,nrgba64 ,*_c .NYCbCrA :_cffb =make ([]byte ,_abcc .Max .X *_abcc .Max .Y *_ecfb );
case *_c .Paletted :var _abba bool ;for _ ,_dedg :=range _adefc .Palette {_cadg ,_gadg ,_cbfb ,_gcfd :=_dedg .RGBA ();if _cadg ==0&&_gadg ==0&&_cbfb ==0&&_gcfd !=0{_abba =true ;break ;};};if _abba {_cffb =make ([]byte ,_abcc .Max .X *_abcc .Max .Y *_ecfb );
};};return _abcc ,_egccc ,_cffb ;};func _a (_dea *Monochrome ,_aa int )(*Monochrome ,error ){if _dea ==nil {return nil ,_f .New ("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064");};if _aa ==1{return _dea .copy (),nil ;
};if !IsPowerOf2 (uint (_aa )){return nil ,_ccc .Errorf ("\u0070\u0072\u006fvi\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006ci\u0064 \u0065x\u0070a\u006e\u0064\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_aa );};_bc :=_fef (_aa );
return _dg (_dea ,_aa ,_bc );};func _aged (_bcac _d .CMYK )_d .Gray {_dgg ,_feef ,_fgag :=_d .CMYKToRGB (_bcac .C ,_bcac .M ,_bcac .Y ,_bcac .K );_bcb :=(19595*uint32 (_dgg )+38470*uint32 (_feef )+7471*uint32 (_fgag )+1<<7)>>16;return _d .Gray {Y :uint8 (_bcb )};
};func (_agbcf *NRGBA64 )Copy ()Image {return &NRGBA64 {ImageBase :_agbcf .copy ()}};func (_addg *NRGBA32 )At (x ,y int )_d .Color {_ccgd ,_ :=_addg .ColorAt (x ,y );return _ccgd };var _ Image =&Gray16 {};func _cgf (_bdec *Monochrome ,_dbc ...int )(_aeg *Monochrome ,_gfa error ){if _bdec ==nil {return nil ,_f .New ("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d");
};if len (_dbc )==0{return nil ,_f .New ("\u0074h\u0065\u0072e\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0061\u0074 \u006c\u0065\u0061\u0073\u0074\u0020o\u006e\u0065\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u006f\u0066 \u0072\u0065\u0064\u0075\u0063\u0074\u0069\u006f\u006e");
};_eac :=_cebc ();_aeg =_bdec ;for _ ,_ebf :=range _dbc {if _ebf <=0{break ;};_aeg ,_gfa =_dgf (_aeg ,_ebf ,_eac );if _gfa !=nil {return nil ,_gfa ;};};return _aeg ,nil ;};func _dcca (_gcdf int ,_fggca int )int {if _gcdf < _fggca {return _gcdf ;};return _fggca ;
};func IsGrayImgBlackAndWhite (i *_c .Gray )bool {return _gbdb (i )};type NRGBA16 struct{ImageBase };func (_dfbc *ImageBase )setEightPartlyBytes (_afed ,_dbecf int ,_abac uint64 )(_gcab error ){var (_bfgf byte ;_ged int ;);for _fdc :=1;_fdc <=_dbecf ;_fdc ++{_ged =64-_fdc *8;
_bfgf =byte (_abac >>uint (_ged )&0xff);if _gcab =_dfbc .setByte (_afed +_fdc -1,_bfgf );_gcab !=nil {return _gcab ;};};_adfbd :=_dfbc .BytesPerLine *8-_dfbc .Width ;if _adfbd ==0{return nil ;};_ged -=8;_bfgf =byte (_abac >>uint (_ged )&0xff)<<uint (_adfbd );
if _gcab =_dfbc .setByte (_afed +_dbecf ,_bfgf );_gcab !=nil {return _gcab ;};return nil ;};func (_abcg *Monochrome )SetGray (x ,y int ,g _d .Gray ){_bfc :=y *_abcg .BytesPerLine +x >>3;if _bfc > len (_abcg .Data )-1{return ;};g =_ddba (g ,monochromeModel (_abcg .ModelThreshold ));
_abcg .setGray (x ,g ,_bfc );};func (_bgef *NRGBA64 )NRGBA64At (x ,y int )_d .NRGBA64 {_fbeeb ,_ :=ColorAtNRGBA64 (x ,y ,_bgef .Width ,_bgef .Data ,_bgef .Alpha ,_bgef .Decode );return _fbeeb ;};func (_gfef *NRGBA64 )At (x ,y int )_d .Color {_edfb ,_ :=_gfef .ColorAt (x ,y );
return _edfb };func _cdgf (_gbfe _c .Image )(Image ,error ){if _bcca ,_dfdca :=_gbfe .(*Gray4 );_dfdca {return _bcca .Copy (),nil ;};_dgb :=_gbfe .Bounds ();_ffg ,_ccfb :=NewImage (_dgb .Max .X ,_dgb .Max .Y ,4,1,nil ,nil ,nil );if _ccfb !=nil {return nil ,_ccfb ;
};_gbaa (_gbfe ,_ffg ,_dgb );return _ffg ,nil ;};func (_ddbag *Monochrome )Histogram ()(_cfa [256]int ){for _ ,_edag :=range _ddbag .Data {_cfa [0xff]+=int (_cebafg [_ddbag .Data [_edag ]]);};return _cfa ;};func (_edd *Monochrome )ColorAt (x ,y int )(_d .Color ,error ){return ColorAtGray1BPC (x ,y ,_edd .BytesPerLine ,_edd .Data ,_edd .Decode );
};type Gray2 struct{ImageBase };func _faga (_fda _c .Image ,_gfege uint8 )*_c .Gray {_dceb :=_fda .Bounds ();_fabf :=_c .NewGray (_dceb );var (_fbfa _d .Color ;_gccc _d .Gray ;);for _ggcb :=0;_ggcb < _dceb .Max .X ;_ggcb ++{for _gggf :=0;_gggf < _dceb .Max .Y ;
_gggf ++{_fbfa =_fda .At (_ggcb ,_gggf );_fabf .Set (_ggcb ,_gggf ,_fbfa );_gccc =_fabf .GrayAt (_ggcb ,_gggf );_fabf .SetGray (_ggcb ,_gggf ,_d .Gray {Y :_fefe (_gccc .Y ,_gfege )});};};return _fabf ;};func (_dfde colorConverter )Convert (src _c .Image )(Image ,error ){return _dfde ._fedf (src )};
var _ _c .Image =&Gray8 {};type SMasker interface{HasAlpha ()bool ;GetAlpha ()[]byte ;MakeAlpha ();};var _ _c .Image =&NRGBA32 {};func _dgcf (_cffg *Monochrome ,_bafc ,_gede ,_fceb ,_cfbd int ,_ffcf RasterOperator ,_beg *Monochrome ,_aeefe ,_edfa int )error {var (_cfde bool ;
_ddggb bool ;_gbfg int ;_cdgd int ;_eefeg int ;_egff bool ;_dbb byte ;_bfbg int ;_fgce int ;_fddg int ;_aeega ,_degf int ;);_becd :=8-(_bafc &7);_geab :=_daae [_becd ];_cbgd :=_cffg .BytesPerLine *_gede +(_bafc >>3);_edgf :=_beg .BytesPerLine *_edfa +(_aeefe >>3);
if _fceb < _becd {_cfde =true ;_geab &=_gggg [8-_becd +_fceb ];};if !_cfde {_gbfg =(_fceb -_becd )>>3;if _gbfg > 0{_ddggb =true ;_cdgd =_cbgd +1;_eefeg =_edgf +1;};};_bfbg =(_bafc +_fceb )&7;if !(_cfde ||_bfbg ==0){_egff =true ;_dbb =_gggg [_bfbg ];_fgce =_cbgd +1+_gbfg ;
_fddg =_edgf +1+_gbfg ;};switch _ffcf {case PixSrc :for _aeega =0;_aeega < _cfbd ;_aeega ++{_cffg .Data [_cbgd ]=_bagb (_cffg .Data [_cbgd ],_beg .Data [_edgf ],_geab );_cbgd +=_cffg .BytesPerLine ;_edgf +=_beg .BytesPerLine ;};if _ddggb {for _aeega =0;
_aeega < _cfbd ;_aeega ++{for _degf =0;_degf < _gbfg ;_degf ++{_cffg .Data [_cdgd +_degf ]=_beg .Data [_eefeg +_degf ];};_cdgd +=_cffg .BytesPerLine ;_eefeg +=_beg .BytesPerLine ;};};if _egff {for _aeega =0;_aeega < _cfbd ;_aeega ++{_cffg .Data [_fgce ]=_bagb (_cffg .Data [_fgce ],_beg .Data [_fddg ],_dbb );
_fgce +=_cffg .BytesPerLine ;_fddg +=_beg .BytesPerLine ;};};case PixNotSrc :for _aeega =0;_aeega < _cfbd ;_aeega ++{_cffg .Data [_cbgd ]=_bagb (_cffg .Data [_cbgd ],^_beg .Data [_edgf ],_geab );_cbgd +=_cffg .BytesPerLine ;_edgf +=_beg .BytesPerLine ;
};if _ddggb {for _aeega =0;_aeega < _cfbd ;_aeega ++{for _degf =0;_degf < _gbfg ;_degf ++{_cffg .Data [_cdgd +_degf ]=^_beg .Data [_eefeg +_degf ];};_cdgd +=_cffg .BytesPerLine ;_eefeg +=_beg .BytesPerLine ;};};if _egff {for _aeega =0;_aeega < _cfbd ;_aeega ++{_cffg .Data [_fgce ]=_bagb (_cffg .Data [_fgce ],^_beg .Data [_fddg ],_dbb );
_fgce +=_cffg .BytesPerLine ;_fddg +=_beg .BytesPerLine ;};};case PixSrcOrDst :for _aeega =0;_aeega < _cfbd ;_aeega ++{_cffg .Data [_cbgd ]=_bagb (_cffg .Data [_cbgd ],_beg .Data [_edgf ]|_cffg .Data [_cbgd ],_geab );_cbgd +=_cffg .BytesPerLine ;_edgf +=_beg .BytesPerLine ;
};if _ddggb {for _aeega =0;_aeega < _cfbd ;_aeega ++{for _degf =0;_degf < _gbfg ;_degf ++{_cffg .Data [_cdgd +_degf ]|=_beg .Data [_eefeg +_degf ];};_cdgd +=_cffg .BytesPerLine ;_eefeg +=_beg .BytesPerLine ;};};if _egff {for _aeega =0;_aeega < _cfbd ;_aeega ++{_cffg .Data [_fgce ]=_bagb (_cffg .Data [_fgce ],_beg .Data [_fddg ]|_cffg .Data [_fgce ],_dbb );
_fgce +=_cffg .BytesPerLine ;_fddg +=_beg .BytesPerLine ;};};case PixSrcAndDst :for _aeega =0;_aeega < _cfbd ;_aeega ++{_cffg .Data [_cbgd ]=_bagb (_cffg .Data [_cbgd ],_beg .Data [_edgf ]&_cffg .Data [_cbgd ],_geab );_cbgd +=_cffg .BytesPerLine ;_edgf +=_beg .BytesPerLine ;
};if _ddggb {for _aeega =0;_aeega < _cfbd ;_aeega ++{for _degf =0;_degf < _gbfg ;_degf ++{_cffg .Data [_cdgd +_degf ]&=_beg .Data [_eefeg +_degf ];};_cdgd +=_cffg .BytesPerLine ;_eefeg +=_beg .BytesPerLine ;};};if _egff {for _aeega =0;_aeega < _cfbd ;_aeega ++{_cffg .Data [_fgce ]=_bagb (_cffg .Data [_fgce ],_beg .Data [_fddg ]&_cffg .Data [_fgce ],_dbb );
_fgce +=_cffg .BytesPerLine ;_fddg +=_beg .BytesPerLine ;};};case PixSrcXorDst :for _aeega =0;_aeega < _cfbd ;_aeega ++{_cffg .Data [_cbgd ]=_bagb (_cffg .Data [_cbgd ],_beg .Data [_edgf ]^_cffg .Data [_cbgd ],_geab );_cbgd +=_cffg .BytesPerLine ;_edgf +=_beg .BytesPerLine ;
};if _ddggb {for _aeega =0;_aeega < _cfbd ;_aeega ++{for _degf =0;_degf < _gbfg ;_degf ++{_cffg .Data [_cdgd +_degf ]^=_beg .Data [_eefeg +_degf ];};_cdgd +=_cffg .BytesPerLine ;_eefeg +=_beg .BytesPerLine ;};};if _egff {for _aeega =0;_aeega < _cfbd ;_aeega ++{_cffg .Data [_fgce ]=_bagb (_cffg .Data [_fgce ],_beg .Data [_fddg ]^_cffg .Data [_fgce ],_dbb );
_fgce +=_cffg .BytesPerLine ;_fddg +=_beg .BytesPerLine ;};};case PixNotSrcOrDst :for _aeega =0;_aeega < _cfbd ;_aeega ++{_cffg .Data [_cbgd ]=_bagb (_cffg .Data [_cbgd ],^(_beg .Data [_edgf ])|_cffg .Data [_cbgd ],_geab );_cbgd +=_cffg .BytesPerLine ;
_edgf +=_beg .BytesPerLine ;};if _ddggb {for _aeega =0;_aeega < _cfbd ;_aeega ++{for _degf =0;_degf < _gbfg ;_degf ++{_cffg .Data [_cdgd +_degf ]|=^(_beg .Data [_eefeg +_degf ]);};_cdgd +=_cffg .BytesPerLine ;_eefeg +=_beg .BytesPerLine ;};};if _egff {for _aeega =0;
_aeega < _cfbd ;_aeega ++{_cffg .Data [_fgce ]=_bagb (_cffg .Data [_fgce ],^(_beg .Data [_fddg ])|_cffg .Data [_fgce ],_dbb );_fgce +=_cffg .BytesPerLine ;_fddg +=_beg .BytesPerLine ;};};case PixNotSrcAndDst :for _aeega =0;_aeega < _cfbd ;_aeega ++{_cffg .Data [_cbgd ]=_bagb (_cffg .Data [_cbgd ],^(_beg .Data [_edgf ])&_cffg .Data [_cbgd ],_geab );
_cbgd +=_cffg .BytesPerLine ;_edgf +=_beg .BytesPerLine ;};if _ddggb {for _aeega =0;_aeega < _cfbd ;_aeega ++{for _degf =0;_degf < _gbfg ;_degf ++{_cffg .Data [_cdgd +_degf ]&=^_beg .Data [_eefeg +_degf ];};_cdgd +=_cffg .BytesPerLine ;_eefeg +=_beg .BytesPerLine ;
};};if _egff {for _aeega =0;_aeega < _cfbd ;_aeega ++{_cffg .Data [_fgce ]=_bagb (_cffg .Data [_fgce ],^(_beg .Data [_fddg ])&_cffg .Data [_fgce ],_dbb );_fgce +=_cffg .BytesPerLine ;_fddg +=_beg .BytesPerLine ;};};case PixSrcOrNotDst :for _aeega =0;_aeega < _cfbd ;
_aeega ++{_cffg .Data [_cbgd ]=_bagb (_cffg .Data [_cbgd ],_beg .Data [_edgf ]|^(_cffg .Data [_cbgd ]),_geab );_cbgd +=_cffg .BytesPerLine ;_edgf +=_beg .BytesPerLine ;};if _ddggb {for _aeega =0;_aeega < _cfbd ;_aeega ++{for _degf =0;_degf < _gbfg ;_degf ++{_cffg .Data [_cdgd +_degf ]=_beg .Data [_eefeg +_degf ]|^(_cffg .Data [_cdgd +_degf ]);
};_cdgd +=_cffg .BytesPerLine ;_eefeg +=_beg .BytesPerLine ;};};if _egff {for _aeega =0;_aeega < _cfbd ;_aeega ++{_cffg .Data [_fgce ]=_bagb (_cffg .Data [_fgce ],_beg .Data [_fddg ]|^(_cffg .Data [_fgce ]),_dbb );_fgce +=_cffg .BytesPerLine ;_fddg +=_beg .BytesPerLine ;
};};case PixSrcAndNotDst :for _aeega =0;_aeega < _cfbd ;_aeega ++{_cffg .Data [_cbgd ]=_bagb (_cffg .Data [_cbgd ],_beg .Data [_edgf ]&^(_cffg .Data [_cbgd ]),_geab );_cbgd +=_cffg .BytesPerLine ;_edgf +=_beg .BytesPerLine ;};if _ddggb {for _aeega =0;_aeega < _cfbd ;
_aeega ++{for _degf =0;_degf < _gbfg ;_degf ++{_cffg .Data [_cdgd +_degf ]=_beg .Data [_eefeg +_degf ]&^(_cffg .Data [_cdgd +_degf ]);};_cdgd +=_cffg .BytesPerLine ;_eefeg +=_beg .BytesPerLine ;};};if _egff {for _aeega =0;_aeega < _cfbd ;_aeega ++{_cffg .Data [_fgce ]=_bagb (_cffg .Data [_fgce ],_beg .Data [_fddg ]&^(_cffg .Data [_fgce ]),_dbb );
_fgce +=_cffg .BytesPerLine ;_fddg +=_beg .BytesPerLine ;};};case PixNotPixSrcOrDst :for _aeega =0;_aeega < _cfbd ;_aeega ++{_cffg .Data [_cbgd ]=_bagb (_cffg .Data [_cbgd ],^(_beg .Data [_edgf ]|_cffg .Data [_cbgd ]),_geab );_cbgd +=_cffg .BytesPerLine ;
_edgf +=_beg .BytesPerLine ;};if _ddggb {for _aeega =0;_aeega < _cfbd ;_aeega ++{for _degf =0;_degf < _gbfg ;_degf ++{_cffg .Data [_cdgd +_degf ]=^(_beg .Data [_eefeg +_degf ]|_cffg .Data [_cdgd +_degf ]);};_cdgd +=_cffg .BytesPerLine ;_eefeg +=_beg .BytesPerLine ;
};};if _egff {for _aeega =0;_aeega < _cfbd ;_aeega ++{_cffg .Data [_fgce ]=_bagb (_cffg .Data [_fgce ],^(_beg .Data [_fddg ]|_cffg .Data [_fgce ]),_dbb );_fgce +=_cffg .BytesPerLine ;_fddg +=_beg .BytesPerLine ;};};case PixNotPixSrcAndDst :for _aeega =0;
_aeega < _cfbd ;_aeega ++{_cffg .Data [_cbgd ]=_bagb (_cffg .Data [_cbgd ],^(_beg .Data [_edgf ]&_cffg .Data [_cbgd ]),_geab );_cbgd +=_cffg .BytesPerLine ;_edgf +=_beg .BytesPerLine ;};if _ddggb {for _aeega =0;_aeega < _cfbd ;_aeega ++{for _degf =0;_degf < _gbfg ;
_degf ++{_cffg .Data [_cdgd +_degf ]=^(_beg .Data [_eefeg +_degf ]&_cffg .Data [_cdgd +_degf ]);};_cdgd +=_cffg .BytesPerLine ;_eefeg +=_beg .BytesPerLine ;};};if _egff {for _aeega =0;_aeega < _cfbd ;_aeega ++{_cffg .Data [_fgce ]=_bagb (_cffg .Data [_fgce ],^(_beg .Data [_fddg ]&_cffg .Data [_fgce ]),_dbb );
_fgce +=_cffg .BytesPerLine ;_fddg +=_beg .BytesPerLine ;};};case PixNotPixSrcXorDst :for _aeega =0;_aeega < _cfbd ;_aeega ++{_cffg .Data [_cbgd ]=_bagb (_cffg .Data [_cbgd ],^(_beg .Data [_edgf ]^_cffg .Data [_cbgd ]),_geab );_cbgd +=_cffg .BytesPerLine ;
_edgf +=_beg .BytesPerLine ;};if _ddggb {for _aeega =0;_aeega < _cfbd ;_aeega ++{for _degf =0;_degf < _gbfg ;_degf ++{_cffg .Data [_cdgd +_degf ]=^(_beg .Data [_eefeg +_degf ]^_cffg .Data [_cdgd +_degf ]);};_cdgd +=_cffg .BytesPerLine ;_eefeg +=_beg .BytesPerLine ;
};};if _egff {for _aeega =0;_aeega < _cfbd ;_aeega ++{_cffg .Data [_fgce ]=_bagb (_cffg .Data [_fgce ],^(_beg .Data [_fddg ]^_cffg .Data [_fgce ]),_dbb );_fgce +=_cffg .BytesPerLine ;_fddg +=_beg .BytesPerLine ;};};default:_ef .Log .Debug ("I\u006e\u0076\u0061\u006c\u0069\u0064 \u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070e\u0072\u0061\u0074o\u0072:\u0020\u0025\u0064",_ffcf );
return _f .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072");};return nil ;};func _ecdd (_bdf _d .NRGBA64 )_d .NRGBA {return _d .NRGBA {R :uint8 (_bdf .R >>8),G :uint8 (_bdf .G >>8),B :uint8 (_bdf .B >>8),A :uint8 (_bdf .A >>8)};
};func (_feag *Gray16 )SetGray (x ,y int ,g _d .Gray ){_fcdf :=(y *_feag .BytesPerLine /2+x )*2;if _fcdf +1>=len (_feag .Data ){return ;};_feag .Data [_fcdf ]=g .Y ;_feag .Data [_fcdf +1]=g .Y ;};func _dca (_dabb _d .NYCbCrA )_d .NRGBA {_daeb :=int32 (_dabb .Y )*0x10101;
_bcg :=int32 (_dabb .Cb )-128;_bbd :=int32 (_dabb .Cr )-128;_adeb :=_daeb +91881*_bbd ;if uint32 (_adeb )&0xff000000==0{_adeb >>=8;}else {_adeb =^(_adeb >>31)&0xffff;};_bdd :=_daeb -22554*_bcg -46802*_bbd ;if uint32 (_bdd )&0xff000000==0{_bdd >>=8;}else {_bdd =^(_bdd >>31)&0xffff;
};_dde :=_daeb +116130*_bcg ;if uint32 (_dde )&0xff000000==0{_dde >>=8;}else {_dde =^(_dde >>31)&0xffff;};return _d .NRGBA {R :uint8 (_adeb >>8),G :uint8 (_bdd >>8),B :uint8 (_dde >>8),A :_dabb .A };};func _dced (_edgd *_c .Gray16 ,_gade uint8 )*_c .Gray {_abae :=_edgd .Bounds ();
_fbcc :=_c .NewGray (_abae );for _ebcd :=0;_ebcd < _abae .Dx ();_ebcd ++{for _dfdg :=0;_dfdg < _abae .Dy ();_dfdg ++{_bgfbe :=_edgd .Gray16At (_ebcd ,_dfdg );_fbcc .SetGray (_ebcd ,_dfdg ,_d .Gray {Y :_fefe (uint8 (_bgfbe .Y /256),_gade )});};};return _fbcc ;
};type ColorConverter interface{Convert (_ege _c .Image )(Image ,error );};func (_eddb *Gray8 )ColorAt (x ,y int )(_d .Color ,error ){return ColorAtGray8BPC (x ,y ,_eddb .BytesPerLine ,_eddb .Data ,_eddb .Decode );};func ColorAtNRGBA64 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_d .NRGBA64 ,error ){_dfef :=(y *width +x )*2;
_fddc :=_dfef *3;if _fddc +5>=len (data ){return _d .NRGBA64 {},_ccc .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};const _efb =0xffff;_gfeeb :=uint16 (_efb );if alpha !=nil &&len (alpha )> _dfef +1{_gfeeb =uint16 (alpha [_dfef ])<<8|uint16 (alpha [_dfef +1]);};_gadb :=uint16 (data [_fddc ])<<8|uint16 (data [_fddc +1]);_abgf :=uint16 (data [_fddc +2])<<8|uint16 (data [_fddc +3]);
_ebda :=uint16 (data [_fddc +4])<<8|uint16 (data [_fddc +5]);if len (decode )==6{_gadb =uint16 (uint64 (LinearInterpolate (float64 (_gadb ),0,65535,decode [0],decode [1]))&_efb );_abgf =uint16 (uint64 (LinearInterpolate (float64 (_abgf ),0,65535,decode [2],decode [3]))&_efb );
_ebda =uint16 (uint64 (LinearInterpolate (float64 (_ebda ),0,65535,decode [4],decode [5]))&_efb );};return _d .NRGBA64 {R :_gadb ,G :_abgf ,B :_ebda ,A :_gfeeb },nil ;};func (_ddc *CMYK32 )SetCMYK (x ,y int ,c _d .CMYK ){_bdg :=4*(y *_ddc .Width +x );if _bdg +3>=len (_ddc .Data ){return ;
};_ddc .Data [_bdg ]=c .C ;_ddc .Data [_bdg +1]=c .M ;_ddc .Data [_bdg +2]=c .Y ;_ddc .Data [_bdg +3]=c .K ;};func ColorAtNRGBA16 (x ,y ,width ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_d .NRGBA ,error ){_fcab :=y *bytesPerLine +x *3/2;
if _fcab +1>=len (data ){return _d .NRGBA {},_fggd (x ,y );};const (_befd =0xf;_cgcg =uint8 (0xff););_fagbb :=_cgcg ;if alpha !=nil {_daec :=y *BytesPerLine (width ,4,1);if _daec < len (alpha ){if x %2==0{_fagbb =(alpha [_daec ]>>uint (4))&_befd ;}else {_fagbb =alpha [_daec ]&_befd ;
};_fagbb |=_fagbb <<4;};};var _aab ,_dggd ,_cece uint8 ;if x *3%2==0{_aab =(data [_fcab ]>>uint (4))&_befd ;_dggd =data [_fcab ]&_befd ;_cece =(data [_fcab +1]>>uint (4))&_befd ;}else {_aab =data [_fcab ]&_befd ;_dggd =(data [_fcab +1]>>uint (4))&_befd ;
_cece =data [_fcab +1]&_befd ;};if len (decode )==6{_aab =uint8 (uint32 (LinearInterpolate (float64 (_aab ),0,15,decode [0],decode [1]))&0xf);_dggd =uint8 (uint32 (LinearInterpolate (float64 (_dggd ),0,15,decode [2],decode [3]))&0xf);_cece =uint8 (uint32 (LinearInterpolate (float64 (_cece ),0,15,decode [4],decode [5]))&0xf);
};return _d .NRGBA {R :(_aab <<4)|(_aab &0xf),G :(_dggd <<4)|(_dggd &0xf),B :(_cece <<4)|(_cece &0xf),A :_fagbb },nil ;};func _aaeed (_afd _d .Gray )_d .Gray {_afd .Y >>=4;_afd .Y |=_afd .Y <<4;return _afd };func _dg (_fe *Monochrome ,_ccd int ,_bg []uint )(*Monochrome ,error ){_fb :=_ccd *_fe .Width ;
_cg :=_ccd *_fe .Height ;_ab :=_eab (_fb ,_cg );for _abg ,_fba :=range _bg {var _ea error ;switch _fba {case 2:_ea =_fd (_ab ,_fe );case 4:_ea =_ed (_ab ,_fe );case 8:_ea =_aca (_ab ,_fe );};if _ea !=nil {return nil ,_ea ;};if _abg !=len (_bg )-1{_fe =_ab .copy ();
};};return _ab ,nil ;};func (_aefd *Gray4 )Bounds ()_c .Rectangle {return _c .Rectangle {Max :_c .Point {X :_aefd .Width ,Y :_aefd .Height }};};func ColorAtGray16BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_d .Gray16 ,error ){_cdcf :=(y *bytesPerLine /2+x )*2;
if _cdcf +1>=len (data ){return _d .Gray16 {},_ccc .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_ddfc :=uint16 (data [_cdcf ])<<8|uint16 (data [_cdcf +1]);if len (decode )==2{_ddfc =uint16 (uint64 (LinearInterpolate (float64 (_ddfc ),0,65535,decode [0],decode [1])));};return _d .Gray16 {Y :_ddfc },nil ;};func (_ecc *Gray2 )Copy ()Image {return &Gray2 {ImageBase :_ecc .copy ()}};
func (_beecc *NRGBA64 )Bounds ()_c .Rectangle {return _c .Rectangle {Max :_c .Point {X :_beecc .Width ,Y :_beecc .Height }};};func (_aac *CMYK32 )Validate ()error {if len (_aac .Data )!=4*_aac .Width *_aac .Height {return _f .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func _acc (_aec Gray ,_caa CMYK ,_cfb _c .Rectangle ){for _edcc :=0;_edcc < _cfb .Max .X ;_edcc ++{for _gbb :=0;_gbb < _cfb .Max .Y ;_gbb ++{_ggg :=_aec .GrayAt (_edcc ,_gbb );_caa .SetCMYK (_edcc ,_gbb ,_cgb (_ggg ));};};};func _dgda (_effe NRGBA ,_eggb Gray ,_dfa _c .Rectangle ){for _fcbc :=0;
_fcbc < _dfa .Max .X ;_fcbc ++{for _dcdd :=0;_dcdd < _dfa .Max .Y ;_dcdd ++{_fbeb :=_dbcf (_effe .NRGBAAt (_fcbc ,_dcdd ));_eggb .SetGray (_fcbc ,_dcdd ,_fbeb );};};};func _ebb (_bec NRGBA ,_dfd CMYK ,_fga _c .Rectangle ){for _aefg :=0;_aefg < _fga .Max .X ;
_aefg ++{for _adbd :=0;_adbd < _fga .Max .Y ;_adbd ++{_ddd :=_bec .NRGBAAt (_aefg ,_adbd );_dfd .SetCMYK (_aefg ,_adbd ,_bef (_ddd ));};};};func (_fcdb *Gray16 )Copy ()Image {return &Gray16 {ImageBase :_fcdb .copy ()}};func _fcac (_ebgc _d .Color )_d .Color {_fcfg :=_d .NRGBAModel .Convert (_ebgc ).(_d .NRGBA );
return _gabe (_fcfg );};func (_fca *ImageBase )Pix ()[]byte {return _fca .Data };func (_eafg *Monochrome )clearBit (_ggge ,_bfcg int ){_eafg .Data [_ggge ]&=^(0x80>>uint (_bfcg &7))};func (_bgaf *Gray8 )SetGray (x ,y int ,g _d .Gray ){_edaf :=y *_bgaf .BytesPerLine +x ;
if _edaf > len (_bgaf .Data )-1{return ;};_bgaf .Data [_edaf ]=g .Y ;};func _dgf (_ebd *Monochrome ,_dcg int ,_ecg []byte )(_fcd *Monochrome ,_cbd error ){const _fedde ="\u0072\u0065d\u0075\u0063\u0065R\u0061\u006e\u006b\u0042\u0069\u006e\u0061\u0072\u0079";
if _ebd ==nil {return nil ,_f .New ("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d");};if _dcg < 1||_dcg > 4{return nil ,_f .New ("\u006c\u0065\u0076\u0065\u006c\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020\u0073e\u0074\u0020\u007b\u0031\u002c\u0032\u002c\u0033\u002c\u0034\u007d");
};if _ebd .Height <=1{return nil ,_f .New ("\u0073\u006f\u0075rc\u0065\u0020\u0068\u0065\u0069\u0067\u0068\u0074\u0020m\u0075s\u0074 \u0062e\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020\u0027\u0032\u0027");};_fcd =_eab (_ebd .Width /2,_ebd .Height /2);
if _ecg ==nil {_ecg =_cebc ();};_fg :=_dcca (_ebd .BytesPerLine ,2*_fcd .BytesPerLine );switch _dcg {case 1:_cbd =_aee (_ebd ,_fcd ,_ecg ,_fg );case 2:_cbd =_acg (_ebd ,_fcd ,_ecg ,_fg );case 3:_cbd =_cdd (_ebd ,_fcd ,_ecg ,_fg );case 4:_cbd =_abaf (_ebd ,_fcd ,_ecg ,_fg );
};if _cbd !=nil {return nil ,_cbd ;};return _fcd ,nil ;};func InDelta (expected ,current ,delta float64 )bool {_aga :=expected -current ;if _aga <=-delta ||_aga >=delta {return false ;};return true ;};var _ Image =&Monochrome {};func _fedd ()(_db [256]uint16 ){for _eea :=0;
_eea < 256;_eea ++{if _eea &0x01!=0{_db [_eea ]|=0x3;};if _eea &0x02!=0{_db [_eea ]|=0xc;};if _eea &0x04!=0{_db [_eea ]|=0x30;};if _eea &0x08!=0{_db [_eea ]|=0xc0;};if _eea &0x10!=0{_db [_eea ]|=0x300;};if _eea &0x20!=0{_db [_eea ]|=0xc00;};if _eea &0x40!=0{_db [_eea ]|=0x3000;
};if _eea &0x80!=0{_db [_eea ]|=0xc000;};};return _db ;};func (_fbef *Gray8 )Set (x ,y int ,c _d .Color ){_cgeg :=y *_fbef .BytesPerLine +x ;if _cgeg > len (_fbef .Data )-1{return ;};_fdbf :=_d .GrayModel .Convert (c );_fbef .Data [_cgeg ]=_fdbf .(_d .Gray ).Y ;
};func (_eace *Gray8 )Copy ()Image {return &Gray8 {ImageBase :_eace .copy ()}};func _fdeg (_bcgdb *Monochrome ,_dgdb ,_fggf ,_aaga ,_begc int ,_ddeec RasterOperator ,_cbfa *Monochrome ,_feddb ,_ffdg int )error {var (_fddb bool ;_ffff bool ;_aade byte ;
_bcge int ;_bfa int ;_debd int ;_fgaa int ;_acgeg bool ;_cbab int ;_badc int ;_egede int ;_bddc bool ;_gggd byte ;_dgcb int ;_ccdcb int ;_egbf int ;_fabe byte ;_bfca int ;_dgdfd int ;_ccg uint ;_ffcg uint ;_gfg byte ;_fcae shift ;_bba bool ;_bab bool ;
_cgac ,_facg int ;);if _feddb &7!=0{_dgdfd =8-(_feddb &7);};if _dgdb &7!=0{_bfa =8-(_dgdb &7);};if _dgdfd ==0&&_bfa ==0{_gfg =_daae [0];}else {if _bfa > _dgdfd {_ccg =uint (_bfa -_dgdfd );}else {_ccg =uint (8-(_dgdfd -_bfa ));};_ffcg =8-_ccg ;_gfg =_daae [_ccg ];
};if (_dgdb &7)!=0{_fddb =true ;_bcge =8-(_dgdb &7);_aade =_daae [_bcge ];_debd =_bcgdb .BytesPerLine *_fggf +(_dgdb >>3);_fgaa =_cbfa .BytesPerLine *_ffdg +(_feddb >>3);_bfca =8-(_feddb &7);if _bcge > _bfca {_fcae =_cddcg ;if _aaga >=_dgdfd {_bba =true ;
};}else {_fcae =_cadd ;};};if _aaga < _bcge {_ffff =true ;_aade &=_gggg [8-_bcge +_aaga ];};if !_ffff {_cbab =(_aaga -_bcge )>>3;if _cbab !=0{_acgeg =true ;_badc =_bcgdb .BytesPerLine *_fggf +((_dgdb +_bfa )>>3);_egede =_cbfa .BytesPerLine *_ffdg +((_feddb +_bfa )>>3);
};};_dgcb =(_dgdb +_aaga )&7;if !(_ffff ||_dgcb ==0){_bddc =true ;_gggd =_gggg [_dgcb ];_ccdcb =_bcgdb .BytesPerLine *_fggf +((_dgdb +_bfa )>>3)+_cbab ;_egbf =_cbfa .BytesPerLine *_ffdg +((_feddb +_bfa )>>3)+_cbab ;if _dgcb > int (_ffcg ){_bab =true ;};
};switch _ddeec {case PixSrc :if _fddb {for _cgac =0;_cgac < _begc ;_cgac ++{if _fcae ==_cddcg {_fabe =_cbfa .Data [_fgaa ]<<_ccg ;if _bba {_fabe =_bagb (_fabe ,_cbfa .Data [_fgaa +1]>>_ffcg ,_gfg );};}else {_fabe =_cbfa .Data [_fgaa ]>>_ffcg ;};_bcgdb .Data [_debd ]=_bagb (_bcgdb .Data [_debd ],_fabe ,_aade );
_debd +=_bcgdb .BytesPerLine ;_fgaa +=_cbfa .BytesPerLine ;};};if _acgeg {for _cgac =0;_cgac < _begc ;_cgac ++{for _facg =0;_facg < _cbab ;_facg ++{_fabe =_bagb (_cbfa .Data [_egede +_facg ]<<_ccg ,_cbfa .Data [_egede +_facg +1]>>_ffcg ,_gfg );_bcgdb .Data [_badc +_facg ]=_fabe ;
};_badc +=_bcgdb .BytesPerLine ;_egede +=_cbfa .BytesPerLine ;};};if _bddc {for _cgac =0;_cgac < _begc ;_cgac ++{_fabe =_cbfa .Data [_egbf ]<<_ccg ;if _bab {_fabe =_bagb (_fabe ,_cbfa .Data [_egbf +1]>>_ffcg ,_gfg );};_bcgdb .Data [_ccdcb ]=_bagb (_bcgdb .Data [_ccdcb ],_fabe ,_gggd );
_ccdcb +=_bcgdb .BytesPerLine ;_egbf +=_cbfa .BytesPerLine ;};};case PixNotSrc :if _fddb {for _cgac =0;_cgac < _begc ;_cgac ++{if _fcae ==_cddcg {_fabe =_cbfa .Data [_fgaa ]<<_ccg ;if _bba {_fabe =_bagb (_fabe ,_cbfa .Data [_fgaa +1]>>_ffcg ,_gfg );};}else {_fabe =_cbfa .Data [_fgaa ]>>_ffcg ;
};_bcgdb .Data [_debd ]=_bagb (_bcgdb .Data [_debd ],^_fabe ,_aade );_debd +=_bcgdb .BytesPerLine ;_fgaa +=_cbfa .BytesPerLine ;};};if _acgeg {for _cgac =0;_cgac < _begc ;_cgac ++{for _facg =0;_facg < _cbab ;_facg ++{_fabe =_bagb (_cbfa .Data [_egede +_facg ]<<_ccg ,_cbfa .Data [_egede +_facg +1]>>_ffcg ,_gfg );
_bcgdb .Data [_badc +_facg ]=^_fabe ;};_badc +=_bcgdb .BytesPerLine ;_egede +=_cbfa .BytesPerLine ;};};if _bddc {for _cgac =0;_cgac < _begc ;_cgac ++{_fabe =_cbfa .Data [_egbf ]<<_ccg ;if _bab {_fabe =_bagb (_fabe ,_cbfa .Data [_egbf +1]>>_ffcg ,_gfg );
};_bcgdb .Data [_ccdcb ]=_bagb (_bcgdb .Data [_ccdcb ],^_fabe ,_gggd );_ccdcb +=_bcgdb .BytesPerLine ;_egbf +=_cbfa .BytesPerLine ;};};case PixSrcOrDst :if _fddb {for _cgac =0;_cgac < _begc ;_cgac ++{if _fcae ==_cddcg {_fabe =_cbfa .Data [_fgaa ]<<_ccg ;
if _bba {_fabe =_bagb (_fabe ,_cbfa .Data [_fgaa +1]>>_ffcg ,_gfg );};}else {_fabe =_cbfa .Data [_fgaa ]>>_ffcg ;};_bcgdb .Data [_debd ]=_bagb (_bcgdb .Data [_debd ],_fabe |_bcgdb .Data [_debd ],_aade );_debd +=_bcgdb .BytesPerLine ;_fgaa +=_cbfa .BytesPerLine ;
};};if _acgeg {for _cgac =0;_cgac < _begc ;_cgac ++{for _facg =0;_facg < _cbab ;_facg ++{_fabe =_bagb (_cbfa .Data [_egede +_facg ]<<_ccg ,_cbfa .Data [_egede +_facg +1]>>_ffcg ,_gfg );_bcgdb .Data [_badc +_facg ]|=_fabe ;};_badc +=_bcgdb .BytesPerLine ;
_egede +=_cbfa .BytesPerLine ;};};if _bddc {for _cgac =0;_cgac < _begc ;_cgac ++{_fabe =_cbfa .Data [_egbf ]<<_ccg ;if _bab {_fabe =_bagb (_fabe ,_cbfa .Data [_egbf +1]>>_ffcg ,_gfg );};_bcgdb .Data [_ccdcb ]=_bagb (_bcgdb .Data [_ccdcb ],_fabe |_bcgdb .Data [_ccdcb ],_gggd );
_ccdcb +=_bcgdb .BytesPerLine ;_egbf +=_cbfa .BytesPerLine ;};};case PixSrcAndDst :if _fddb {for _cgac =0;_cgac < _begc ;_cgac ++{if _fcae ==_cddcg {_fabe =_cbfa .Data [_fgaa ]<<_ccg ;if _bba {_fabe =_bagb (_fabe ,_cbfa .Data [_fgaa +1]>>_ffcg ,_gfg );
};}else {_fabe =_cbfa .Data [_fgaa ]>>_ffcg ;};_bcgdb .Data [_debd ]=_bagb (_bcgdb .Data [_debd ],_fabe &_bcgdb .Data [_debd ],_aade );_debd +=_bcgdb .BytesPerLine ;_fgaa +=_cbfa .BytesPerLine ;};};if _acgeg {for _cgac =0;_cgac < _begc ;_cgac ++{for _facg =0;
_facg < _cbab ;_facg ++{_fabe =_bagb (_cbfa .Data [_egede +_facg ]<<_ccg ,_cbfa .Data [_egede +_facg +1]>>_ffcg ,_gfg );_bcgdb .Data [_badc +_facg ]&=_fabe ;};_badc +=_bcgdb .BytesPerLine ;_egede +=_cbfa .BytesPerLine ;};};if _bddc {for _cgac =0;_cgac < _begc ;
_cgac ++{_fabe =_cbfa .Data [_egbf ]<<_ccg ;if _bab {_fabe =_bagb (_fabe ,_cbfa .Data [_egbf +1]>>_ffcg ,_gfg );};_bcgdb .Data [_ccdcb ]=_bagb (_bcgdb .Data [_ccdcb ],_fabe &_bcgdb .Data [_ccdcb ],_gggd );_ccdcb +=_bcgdb .BytesPerLine ;_egbf +=_cbfa .BytesPerLine ;
};};case PixSrcXorDst :if _fddb {for _cgac =0;_cgac < _begc ;_cgac ++{if _fcae ==_cddcg {_fabe =_cbfa .Data [_fgaa ]<<_ccg ;if _bba {_fabe =_bagb (_fabe ,_cbfa .Data [_fgaa +1]>>_ffcg ,_gfg );};}else {_fabe =_cbfa .Data [_fgaa ]>>_ffcg ;};_bcgdb .Data [_debd ]=_bagb (_bcgdb .Data [_debd ],_fabe ^_bcgdb .Data [_debd ],_aade );
_debd +=_bcgdb .BytesPerLine ;_fgaa +=_cbfa .BytesPerLine ;};};if _acgeg {for _cgac =0;_cgac < _begc ;_cgac ++{for _facg =0;_facg < _cbab ;_facg ++{_fabe =_bagb (_cbfa .Data [_egede +_facg ]<<_ccg ,_cbfa .Data [_egede +_facg +1]>>_ffcg ,_gfg );_bcgdb .Data [_badc +_facg ]^=_fabe ;
};_badc +=_bcgdb .BytesPerLine ;_egede +=_cbfa .BytesPerLine ;};};if _bddc {for _cgac =0;_cgac < _begc ;_cgac ++{_fabe =_cbfa .Data [_egbf ]<<_ccg ;if _bab {_fabe =_bagb (_fabe ,_cbfa .Data [_egbf +1]>>_ffcg ,_gfg );};_bcgdb .Data [_ccdcb ]=_bagb (_bcgdb .Data [_ccdcb ],_fabe ^_bcgdb .Data [_ccdcb ],_gggd );
_ccdcb +=_bcgdb .BytesPerLine ;_egbf +=_cbfa .BytesPerLine ;};};case PixNotSrcOrDst :if _fddb {for _cgac =0;_cgac < _begc ;_cgac ++{if _fcae ==_cddcg {_fabe =_cbfa .Data [_fgaa ]<<_ccg ;if _bba {_fabe =_bagb (_fabe ,_cbfa .Data [_fgaa +1]>>_ffcg ,_gfg );
};}else {_fabe =_cbfa .Data [_fgaa ]>>_ffcg ;};_bcgdb .Data [_debd ]=_bagb (_bcgdb .Data [_debd ],^_fabe |_bcgdb .Data [_debd ],_aade );_debd +=_bcgdb .BytesPerLine ;_fgaa +=_cbfa .BytesPerLine ;};};if _acgeg {for _cgac =0;_cgac < _begc ;_cgac ++{for _facg =0;
_facg < _cbab ;_facg ++{_fabe =_bagb (_cbfa .Data [_egede +_facg ]<<_ccg ,_cbfa .Data [_egede +_facg +1]>>_ffcg ,_gfg );_bcgdb .Data [_badc +_facg ]|=^_fabe ;};_badc +=_bcgdb .BytesPerLine ;_egede +=_cbfa .BytesPerLine ;};};if _bddc {for _cgac =0;_cgac < _begc ;
_cgac ++{_fabe =_cbfa .Data [_egbf ]<<_ccg ;if _bab {_fabe =_bagb (_fabe ,_cbfa .Data [_egbf +1]>>_ffcg ,_gfg );};_bcgdb .Data [_ccdcb ]=_bagb (_bcgdb .Data [_ccdcb ],^_fabe |_bcgdb .Data [_ccdcb ],_gggd );_ccdcb +=_bcgdb .BytesPerLine ;_egbf +=_cbfa .BytesPerLine ;
};};case PixNotSrcAndDst :if _fddb {for _cgac =0;_cgac < _begc ;_cgac ++{if _fcae ==_cddcg {_fabe =_cbfa .Data [_fgaa ]<<_ccg ;if _bba {_fabe =_bagb (_fabe ,_cbfa .Data [_fgaa +1]>>_ffcg ,_gfg );};}else {_fabe =_cbfa .Data [_fgaa ]>>_ffcg ;};_bcgdb .Data [_debd ]=_bagb (_bcgdb .Data [_debd ],^_fabe &_bcgdb .Data [_debd ],_aade );
_debd +=_bcgdb .BytesPerLine ;_fgaa +=_cbfa .BytesPerLine ;};};if _acgeg {for _cgac =0;_cgac < _begc ;_cgac ++{for _facg =0;_facg < _cbab ;_facg ++{_fabe =_bagb (_cbfa .Data [_egede +_facg ]<<_ccg ,_cbfa .Data [_egede +_facg +1]>>_ffcg ,_gfg );_bcgdb .Data [_badc +_facg ]&=^_fabe ;
};_badc +=_bcgdb .BytesPerLine ;_egede +=_cbfa .BytesPerLine ;};};if _bddc {for _cgac =0;_cgac < _begc ;_cgac ++{_fabe =_cbfa .Data [_egbf ]<<_ccg ;if _bab {_fabe =_bagb (_fabe ,_cbfa .Data [_egbf +1]>>_ffcg ,_gfg );};_bcgdb .Data [_ccdcb ]=_bagb (_bcgdb .Data [_ccdcb ],^_fabe &_bcgdb .Data [_ccdcb ],_gggd );
_ccdcb +=_bcgdb .BytesPerLine ;_egbf +=_cbfa .BytesPerLine ;};};case PixSrcOrNotDst :if _fddb {for _cgac =0;_cgac < _begc ;_cgac ++{if _fcae ==_cddcg {_fabe =_cbfa .Data [_fgaa ]<<_ccg ;if _bba {_fabe =_bagb (_fabe ,_cbfa .Data [_fgaa +1]>>_ffcg ,_gfg );
};}else {_fabe =_cbfa .Data [_fgaa ]>>_ffcg ;};_bcgdb .Data [_debd ]=_bagb (_bcgdb .Data [_debd ],_fabe |^_bcgdb .Data [_debd ],_aade );_debd +=_bcgdb .BytesPerLine ;_fgaa +=_cbfa .BytesPerLine ;};};if _acgeg {for _cgac =0;_cgac < _begc ;_cgac ++{for _facg =0;
_facg < _cbab ;_facg ++{_fabe =_bagb (_cbfa .Data [_egede +_facg ]<<_ccg ,_cbfa .Data [_egede +_facg +1]>>_ffcg ,_gfg );_bcgdb .Data [_badc +_facg ]=_fabe |^_bcgdb .Data [_badc +_facg ];};_badc +=_bcgdb .BytesPerLine ;_egede +=_cbfa .BytesPerLine ;};};
if _bddc {for _cgac =0;_cgac < _begc ;_cgac ++{_fabe =_cbfa .Data [_egbf ]<<_ccg ;if _bab {_fabe =_bagb (_fabe ,_cbfa .Data [_egbf +1]>>_ffcg ,_gfg );};_bcgdb .Data [_ccdcb ]=_bagb (_bcgdb .Data [_ccdcb ],_fabe |^_bcgdb .Data [_ccdcb ],_gggd );_ccdcb +=_bcgdb .BytesPerLine ;
_egbf +=_cbfa .BytesPerLine ;};};case PixSrcAndNotDst :if _fddb {for _cgac =0;_cgac < _begc ;_cgac ++{if _fcae ==_cddcg {_fabe =_cbfa .Data [_fgaa ]<<_ccg ;if _bba {_fabe =_bagb (_fabe ,_cbfa .Data [_fgaa +1]>>_ffcg ,_gfg );};}else {_fabe =_cbfa .Data [_fgaa ]>>_ffcg ;
};_bcgdb .Data [_debd ]=_bagb (_bcgdb .Data [_debd ],_fabe &^_bcgdb .Data [_debd ],_aade );_debd +=_bcgdb .BytesPerLine ;_fgaa +=_cbfa .BytesPerLine ;};};if _acgeg {for _cgac =0;_cgac < _begc ;_cgac ++{for _facg =0;_facg < _cbab ;_facg ++{_fabe =_bagb (_cbfa .Data [_egede +_facg ]<<_ccg ,_cbfa .Data [_egede +_facg +1]>>_ffcg ,_gfg );
_bcgdb .Data [_badc +_facg ]=_fabe &^_bcgdb .Data [_badc +_facg ];};_badc +=_bcgdb .BytesPerLine ;_egede +=_cbfa .BytesPerLine ;};};if _bddc {for _cgac =0;_cgac < _begc ;_cgac ++{_fabe =_cbfa .Data [_egbf ]<<_ccg ;if _bab {_fabe =_bagb (_fabe ,_cbfa .Data [_egbf +1]>>_ffcg ,_gfg );
};_bcgdb .Data [_ccdcb ]=_bagb (_bcgdb .Data [_ccdcb ],_fabe &^_bcgdb .Data [_ccdcb ],_gggd );_ccdcb +=_bcgdb .BytesPerLine ;_egbf +=_cbfa .BytesPerLine ;};};case PixNotPixSrcOrDst :if _fddb {for _cgac =0;_cgac < _begc ;_cgac ++{if _fcae ==_cddcg {_fabe =_cbfa .Data [_fgaa ]<<_ccg ;
if _bba {_fabe =_bagb (_fabe ,_cbfa .Data [_fgaa +1]>>_ffcg ,_gfg );};}else {_fabe =_cbfa .Data [_fgaa ]>>_ffcg ;};_bcgdb .Data [_debd ]=_bagb (_bcgdb .Data [_debd ],^(_fabe |_bcgdb .Data [_debd ]),_aade );_debd +=_bcgdb .BytesPerLine ;_fgaa +=_cbfa .BytesPerLine ;
};};if _acgeg {for _cgac =0;_cgac < _begc ;_cgac ++{for _facg =0;_facg < _cbab ;_facg ++{_fabe =_bagb (_cbfa .Data [_egede +_facg ]<<_ccg ,_cbfa .Data [_egede +_facg +1]>>_ffcg ,_gfg );_bcgdb .Data [_badc +_facg ]=^(_fabe |_bcgdb .Data [_badc +_facg ]);
};_badc +=_bcgdb .BytesPerLine ;_egede +=_cbfa .BytesPerLine ;};};if _bddc {for _cgac =0;_cgac < _begc ;_cgac ++{_fabe =_cbfa .Data [_egbf ]<<_ccg ;if _bab {_fabe =_bagb (_fabe ,_cbfa .Data [_egbf +1]>>_ffcg ,_gfg );};_bcgdb .Data [_ccdcb ]=_bagb (_bcgdb .Data [_ccdcb ],^(_fabe |_bcgdb .Data [_ccdcb ]),_gggd );
_ccdcb +=_bcgdb .BytesPerLine ;_egbf +=_cbfa .BytesPerLine ;};};case PixNotPixSrcAndDst :if _fddb {for _cgac =0;_cgac < _begc ;_cgac ++{if _fcae ==_cddcg {_fabe =_cbfa .Data [_fgaa ]<<_ccg ;if _bba {_fabe =_bagb (_fabe ,_cbfa .Data [_fgaa +1]>>_ffcg ,_gfg );
};}else {_fabe =_cbfa .Data [_fgaa ]>>_ffcg ;};_bcgdb .Data [_debd ]=_bagb (_bcgdb .Data [_debd ],^(_fabe &_bcgdb .Data [_debd ]),_aade );_debd +=_bcgdb .BytesPerLine ;_fgaa +=_cbfa .BytesPerLine ;};};if _acgeg {for _cgac =0;_cgac < _begc ;_cgac ++{for _facg =0;
_facg < _cbab ;_facg ++{_fabe =_bagb (_cbfa .Data [_egede +_facg ]<<_ccg ,_cbfa .Data [_egede +_facg +1]>>_ffcg ,_gfg );_bcgdb .Data [_badc +_facg ]=^(_fabe &_bcgdb .Data [_badc +_facg ]);};_badc +=_bcgdb .BytesPerLine ;_egede +=_cbfa .BytesPerLine ;};
};if _bddc {for _cgac =0;_cgac < _begc ;_cgac ++{_fabe =_cbfa .Data [_egbf ]<<_ccg ;if _bab {_fabe =_bagb (_fabe ,_cbfa .Data [_egbf +1]>>_ffcg ,_gfg );};_bcgdb .Data [_ccdcb ]=_bagb (_bcgdb .Data [_ccdcb ],^(_fabe &_bcgdb .Data [_ccdcb ]),_gggd );_ccdcb +=_bcgdb .BytesPerLine ;
_egbf +=_cbfa .BytesPerLine ;};};case PixNotPixSrcXorDst :if _fddb {for _cgac =0;_cgac < _begc ;_cgac ++{if _fcae ==_cddcg {_fabe =_cbfa .Data [_fgaa ]<<_ccg ;if _bba {_fabe =_bagb (_fabe ,_cbfa .Data [_fgaa +1]>>_ffcg ,_gfg );};}else {_fabe =_cbfa .Data [_fgaa ]>>_ffcg ;
};_bcgdb .Data [_debd ]=_bagb (_bcgdb .Data [_debd ],^(_fabe ^_bcgdb .Data [_debd ]),_aade );_debd +=_bcgdb .BytesPerLine ;_fgaa +=_cbfa .BytesPerLine ;};};if _acgeg {for _cgac =0;_cgac < _begc ;_cgac ++{for _facg =0;_facg < _cbab ;_facg ++{_fabe =_bagb (_cbfa .Data [_egede +_facg ]<<_ccg ,_cbfa .Data [_egede +_facg +1]>>_ffcg ,_gfg );
_bcgdb .Data [_badc +_facg ]=^(_fabe ^_bcgdb .Data [_badc +_facg ]);};_badc +=_bcgdb .BytesPerLine ;_egede +=_cbfa .BytesPerLine ;};};if _bddc {for _cgac =0;_cgac < _begc ;_cgac ++{_fabe =_cbfa .Data [_egbf ]<<_ccg ;if _bab {_fabe =_bagb (_fabe ,_cbfa .Data [_egbf +1]>>_ffcg ,_gfg );
};_bcgdb .Data [_ccdcb ]=_bagb (_bcgdb .Data [_ccdcb ],^(_fabe ^_bcgdb .Data [_ccdcb ]),_gggd );_ccdcb +=_bcgdb .BytesPerLine ;_egbf +=_cbfa .BytesPerLine ;};};default:_ef .Log .Debug ("\u004f\u0070e\u0072\u0061\u0074\u0069\u006f\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006e\u006f\u0074\u0020\u0070\u0065\u0072\u006d\u0069tt\u0065\u0064",_ddeec );
return _f .New ("\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065r\u0061\u0074\u0069\u006f\u006e\u0020\u006eo\u0074\u0020\u0070\u0065\u0072\u006d\u0069\u0074\u0074\u0065\u0064");};return nil ;};func _acggd (){for _aecf :=0;_aecf < 256;_aecf ++{_cebafg [_aecf ]=uint8 (_aecf &0x1)+(uint8 (_aecf >>1)&0x1)+(uint8 (_aecf >>2)&0x1)+(uint8 (_aecf >>3)&0x1)+(uint8 (_aecf >>4)&0x1)+(uint8 (_aecf >>5)&0x1)+(uint8 (_aecf >>6)&0x1)+(uint8 (_aecf >>7)&0x1);
};};func _fdee (_abadd _c .Image )(Image ,error ){if _fdga ,_ddbf :=_abadd .(*Gray16 );_ddbf {return _fdga .Copy (),nil ;};_bacb :=_abadd .Bounds ();_eeb ,_beag :=NewImage (_bacb .Max .X ,_bacb .Max .Y ,16,1,nil ,nil ,nil );if _beag !=nil {return nil ,_beag ;
};_gbaa (_abadd ,_eeb ,_bacb );return _eeb ,nil ;};func ColorAtGray8BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_d .Gray ,error ){_bcba :=y *bytesPerLine +x ;if _bcba >=len (data ){return _d .Gray {},_ccc .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_fgc :=data [_bcba ];if len (decode )==2{_fgc =uint8 (uint32 (LinearInterpolate (float64 (_fgc ),0,255,decode [0],decode [1]))&0xff);};return _d .Gray {Y :_fgc },nil ;};func (_affe *ImageBase )setEightBytes (_fbb int ,_cbcc uint64 )error {_cccd :=_affe .BytesPerLine -(_fbb %_affe .BytesPerLine );
if _affe .BytesPerLine !=_affe .Width >>3{_cccd --;};if _cccd >=8{return _affe .setEightFullBytes (_fbb ,_cbcc );};return _affe .setEightPartlyBytes (_fbb ,_cccd ,_cbcc );};func NewImageBase (width int ,height int ,bitsPerComponent int ,colorComponents int ,data []byte ,alpha []byte ,decode []float64 )ImageBase {_fdgg :=ImageBase {Width :width ,Height :height ,BitsPerComponent :bitsPerComponent ,ColorComponents :colorComponents ,Data :data ,Alpha :alpha ,Decode :decode ,BytesPerLine :BytesPerLine (width ,bitsPerComponent ,colorComponents )};
if data ==nil {_fdgg .Data =make ([]byte ,height *_fdgg .BytesPerLine );};return _fdgg ;};func (_gga *Gray16 )GrayAt (x ,y int )_d .Gray {_bdee ,_ :=_gga .ColorAt (x ,y );return _d .Gray {Y :uint8 (_bdee .(_d .Gray16 ).Y >>8)};};func _fcace (_cacb _c .Image )(Image ,error ){if _gcbfc ,_abbe :=_cacb .(*NRGBA16 );
_abbe {return _gcbfc .Copy (),nil ;};_gbga :=_cacb .Bounds ();_efag ,_fad :=NewImage (_gbga .Max .X ,_gbga .Max .Y ,4,3,nil ,nil ,nil );if _fad !=nil {return nil ,_fad ;};_cdgdd (_cacb ,_efag ,_gbga );return _efag ,nil ;};func _aca (_eef ,_cce *Monochrome )(_bdb error ){_bad :=_cce .BytesPerLine ;
_bde :=_eef .BytesPerLine ;var _ce ,_bea ,_aaa ,_dd ,_eag int ;for _aaa =0;_aaa < _cce .Height ;_aaa ++{_ce =_aaa *_bad ;_bea =8*_aaa *_bde ;for _dd =0;_dd < _bad ;_dd ++{if _bdb =_eef .setEightBytes (_bea +_dd *8,_cad [_cce .Data [_ce +_dd ]]);_bdb !=nil {return _bdb ;
};};for _eag =1;_eag < 8;_eag ++{for _dd =0;_dd < _bde ;_dd ++{if _bdb =_eef .setByte (_bea +_eag *_bde +_dd ,_eef .Data [_bea +_dd ]);_bdb !=nil {return _bdb ;};};};};return nil ;};var (_fde =_fedd ();_bge =_gea ();_cad =_cge (););const (PixSrc RasterOperator =0xc;
PixDst RasterOperator =0xa;PixNotSrc RasterOperator =0x3;PixNotDst RasterOperator =0x5;PixClr RasterOperator =0x0;PixSet RasterOperator =0xf;PixSrcOrDst RasterOperator =0xe;PixSrcAndDst RasterOperator =0x8;PixSrcXorDst RasterOperator =0x6;PixNotSrcOrDst RasterOperator =0xb;
PixNotSrcAndDst RasterOperator =0x2;PixSrcOrNotDst RasterOperator =0xd;PixSrcAndNotDst RasterOperator =0x4;PixNotPixSrcOrDst RasterOperator =0x1;PixNotPixSrcAndDst RasterOperator =0x7;PixNotPixSrcXorDst RasterOperator =0x9;PixPaint =PixSrcOrDst ;PixSubtract =PixNotSrcAndDst ;
PixMask =PixSrcAndDst ;);func _cddg (_dddca _c .Image ,_beagd Image ,_edafe _c .Rectangle ){if _adfdd ,_bdfcf :=_dddca .(SMasker );_bdfcf &&_adfdd .HasAlpha (){_beagd .(SMasker ).MakeAlpha ();};_gabb (_dddca ,_beagd ,_edafe );};func _edab (_adgd Gray ,_beae NRGBA ,_gbag _c .Rectangle ){for _cbff :=0;
_cbff < _gbag .Max .X ;_cbff ++{for _ddgf :=0;_ddgf < _gbag .Max .Y ;_ddgf ++{_eebfc :=_adgd .GrayAt (_cbff ,_ddgf );_beae .SetNRGBA (_cbff ,_ddgf ,_cdda (_eebfc ));};};};func _gbgcd (_fbfc _d .Color )_d .Color {_dcf :=_d .GrayModel .Convert (_fbfc ).(_d .Gray );
return _aaeed (_dcf );};func ImgToBinary (i _c .Image ,threshold uint8 )*_c .Gray {switch _cfca :=i .(type ){case *_c .Gray :if _gbdb (_cfca ){return _cfca ;};return _abdb (_cfca ,threshold );case *_c .Gray16 :return _dced (_cfca ,threshold );default:return _faga (_cfca ,threshold );
};};func (_agbc *NRGBA16 )Base ()*ImageBase {return &_agbc .ImageBase };func _gabe (_ddgc _d .NRGBA )_d .NRGBA {_ddgc .R =_ddgc .R >>4|(_ddgc .R >>4)<<4;_ddgc .G =_ddgc .G >>4|(_ddgc .G >>4)<<4;_ddgc .B =_ddgc .B >>4|(_ddgc .B >>4)<<4;return _ddgc ;};func (_afgf *Gray2 )GrayAt (x ,y int )_d .Gray {_faca ,_ :=ColorAtGray2BPC (x ,y ,_afgf .BytesPerLine ,_afgf .Data ,_afgf .Decode );
return _faca ;};type CMYK32 struct{ImageBase };func (_febda *NRGBA64 )Base ()*ImageBase {return &_febda .ImageBase };func (_adgc *Gray16 )At (x ,y int )_d .Color {_bebc ,_ :=_adgc .ColorAt (x ,y );return _bebc };var _ Image =&NRGBA32 {};func (_edcg *Gray16 )ColorAt (x ,y int )(_d .Color ,error ){return ColorAtGray16BPC (x ,y ,_edcg .BytesPerLine ,_edcg .Data ,_edcg .Decode );
};var _ Image =&Gray2 {};func _aee (_gag ,_eff *Monochrome ,_efe []byte ,_bgf int )(_fgb error ){var (_fea ,_aeb ,_cfeg ,_geae ,_adg ,_afc ,_cbaa ,_fee int ;_ddf ,_fdb uint32 ;_cdca ,_ceg byte ;_gdg uint16 ;);_bgec :=make ([]byte ,4);_dcgb :=make ([]byte ,4);
for _cfeg =0;_cfeg < _gag .Height -1;_cfeg ,_geae =_cfeg +2,_geae +1{_fea =_cfeg *_gag .BytesPerLine ;_aeb =_geae *_eff .BytesPerLine ;for _adg ,_afc =0,0;_adg < _bgf ;_adg ,_afc =_adg +4,_afc +1{for _cbaa =0;_cbaa < 4;_cbaa ++{_fee =_fea +_adg +_cbaa ;
if _fee <=len (_gag .Data )-1&&_fee < _fea +_gag .BytesPerLine {_bgec [_cbaa ]=_gag .Data [_fee ];}else {_bgec [_cbaa ]=0x00;};_fee =_fea +_gag .BytesPerLine +_adg +_cbaa ;if _fee <=len (_gag .Data )-1&&_fee < _fea +(2*_gag .BytesPerLine ){_dcgb [_cbaa ]=_gag .Data [_fee ];
}else {_dcgb [_cbaa ]=0x00;};};_ddf =_cc .BigEndian .Uint32 (_bgec );_fdb =_cc .BigEndian .Uint32 (_dcgb );_fdb |=_ddf ;_fdb |=_fdb <<1;_fdb &=0xaaaaaaaa;_ddf =_fdb |(_fdb <<7);_cdca =byte (_ddf >>24);_ceg =byte ((_ddf >>8)&0xff);_fee =_aeb +_afc ;if _fee +1==len (_eff .Data )-1||_fee +1>=_aeb +_eff .BytesPerLine {_eff .Data [_fee ]=_efe [_cdca ];
}else {_gdg =(uint16 (_efe [_cdca ])<<8)|uint16 (_efe [_ceg ]);if _fgb =_eff .setTwoBytes (_fee ,_gdg );_fgb !=nil {return _ccc .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_fee );
};_afc ++;};};};return nil ;};func (_bbfg *Monochrome )InverseData ()error {return _bbfg .RasterOperation (0,0,_bbfg .Width ,_bbfg .Height ,PixNotDst ,nil ,0,0);};func (_bbe *CMYK32 )Base ()*ImageBase {return &_bbe .ImageBase };func _aed (_cdb ,_adb int ,_gab []byte )*Monochrome {_ceb :=_eab (_cdb ,_adb );
_ceb .Data =_gab ;return _ceb ;};func (_fadb *NRGBA64 )Validate ()error {if len (_fadb .Data )!=3*2*_fadb .Width *_fadb .Height {return _f .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func (_gae *monochromeThresholdConverter )Convert (img _c .Image )(Image ,error ){if _fgf ,_bdfc :=img .(*Monochrome );_bdfc {return _fgf .Copy (),nil ;};_agg :=img .Bounds ();_dac ,_afgc :=NewImage (_agg .Max .X ,_agg .Max .Y ,1,1,nil ,nil ,nil );
if _afgc !=nil {return nil ,_afgc ;};_dac .(*Monochrome ).ModelThreshold =_gae .Threshold ;for _acgg :=0;_acgg < _agg .Max .X ;_acgg ++{for _bfe :=0;_bfe < _agg .Max .Y ;_bfe ++{_acge :=img .At (_acgg ,_bfe );_dac .Set (_acgg ,_bfe ,_acge );};};return _dac ,nil ;
};func _dccd (_gbe Gray ,_def nrgba64 ,_cgeb _c .Rectangle ){for _ceeb :=0;_ceeb < _cgeb .Max .X ;_ceeb ++{for _bbdc :=0;_bbdc < _cgeb .Max .Y ;_bbdc ++{_fac :=_cggg (_def .NRGBA64At (_ceeb ,_bbdc ));_gbe .SetGray (_ceeb ,_bbdc ,_fac );};};};func (_bbed *Gray4 )Base ()*ImageBase {return &_bbed .ImageBase };
func _ffbf (_dbab ,_bdgg CMYK ,_gabf _c .Rectangle ){for _bcdf :=0;_bcdf < _gabf .Max .X ;_bcdf ++{for _cfg :=0;_cfg < _gabf .Max .Y ;_cfg ++{_bdgg .SetCMYK (_bcdf ,_cfg ,_dbab .CMYKAt (_bcdf ,_cfg ));};};};func (_ddeg *Gray4 )SetGray (x ,y int ,g _d .Gray ){if x >=_ddeg .Width ||y >=_ddeg .Height {return ;
};g =_aaeed (g );_ddeg .setGray (x ,y ,g );};func _aaeb (_ceef []byte ,_ecdgd Image )error {_fead :=true ;for _eaba :=0;_eaba < len (_ceef );_eaba ++{if _ceef [_eaba ]!=0xff{_fead =false ;break ;};};if _fead {switch _dagd :=_ecdgd .(type ){case *NRGBA32 :_dagd .Alpha =nil ;
case *NRGBA64 :_dagd .Alpha =nil ;default:return _ccc .Errorf ("i\u006ete\u0072n\u0061l\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020i\u006d\u0061\u0067\u0065\u0020s\u0068\u006f\u0075l\u0064\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0074\u0079\u0070e\u0020\u002a\u004eRGB\u0041\u0033\u0032\u0020\u006f\u0072 \u002a\u004e\u0052\u0047\u0042\u0041\u0036\u0034\u0020\u0062\u0075\u0074 \u0069s\u003a\u0020\u0025\u0054",_ecdgd );
};};return nil ;};func _ebed (_badb _c .Image )(Image ,error ){if _aeeg ,_egdg :=_badb .(*CMYK32 );_egdg {return _aeeg .Copy (),nil ;};_dcc :=_badb .Bounds ();_agc ,_bafb :=NewImage (_dcc .Max .X ,_dcc .Max .Y ,8,4,nil ,nil ,nil );if _bafb !=nil {return nil ,_bafb ;
};switch _agd :=_badb .(type ){case CMYK :_ffbf (_agd ,_agc .(CMYK ),_dcc );case Gray :_acc (_agd ,_agc .(CMYK ),_dcc );case NRGBA :_ebb (_agd ,_agc .(CMYK ),_dcc );case RGBA :_afac (_agd ,_agc .(CMYK ),_dcc );default:_gabb (_badb ,_agc ,_dcc );};return _agc ,nil ;
};func _abdb (_cffd *_c .Gray ,_cdcde uint8 )*_c .Gray {_dbcgg :=_cffd .Bounds ();_cdcfd :=_c .NewGray (_dbcgg );for _cgd :=0;_cgd < _dbcgg .Dx ();_cgd ++{for _dcec :=0;_dcec < _dbcgg .Dy ();_dcec ++{_cddaa :=_cffd .GrayAt (_cgd ,_dcec );_cdcfd .SetGray (_cgd ,_dcec ,_d .Gray {Y :_fefe (_cddaa .Y ,_cdcde )});
};};return _cdcfd ;};var _ Gray =&Gray16 {};func _aeaa (_edb _c .Image )(Image ,error ){if _bcgd ,_dbec :=_edb .(*Monochrome );_dbec {return _bcgd ,nil ;};_gbf :=_edb .Bounds ();var _ddga Gray ;switch _feb :=_edb .(type ){case Gray :_ddga =_feb ;case NRGBA :_ddga =&Gray8 {ImageBase :NewImageBase (_gbf .Max .X ,_gbf .Max .Y ,8,1,nil ,nil ,nil )};
_dgge (_ddga ,_feb ,_gbf );case nrgba64 :_ddga =&Gray8 {ImageBase :NewImageBase (_gbf .Max .X ,_gbf .Max .Y ,8,1,nil ,nil ,nil )};_dccd (_ddga ,_feb ,_gbf );default:_febc ,_dddc :=GrayConverter .Convert (_edb );if _dddc !=nil {return nil ,_dddc ;};_ddga =_febc .(Gray );
};_gef ,_ecaa :=NewImage (_gbf .Max .X ,_gbf .Max .Y ,1,1,nil ,nil ,nil );if _ecaa !=nil {return nil ,_ecaa ;};_gacb :=_gef .(*Monochrome );_geb :=AutoThresholdTriangle (GrayHistogram (_ddga ));for _bdc :=0;_bdc < _gbf .Max .X ;_bdc ++{for _fcg :=0;_fcg < _gbf .Max .Y ;
_fcg ++{_efea :=_ddba (_ddga .GrayAt (_bdc ,_fcg ),monochromeModel (_geb ));_gacb .SetGray (_bdc ,_fcg ,_efea );};};return _gef ,nil ;};func (_bce *CMYK32 )ColorModel ()_d .Model {return _d .CMYKModel };func (_cega *Gray16 )Validate ()error {if len (_cega .Data )!=_cega .Height *_cega .BytesPerLine {return ErrInvalidImage ;
};return nil ;};type Monochrome struct{ImageBase ;ModelThreshold uint8 ;};func (_ccef *ImageBase )GetAlpha ()[]byte {return _ccef .Alpha };func (_ede *Monochrome )ScaleLow (width ,height int )(*Monochrome ,error ){if width < 0||height < 0{return nil ,_f .New ("\u0070\u0072\u006f\u0076\u0069\u0064e\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0069\u0064t\u0068\u0020\u0061\u006e\u0064\u0020\u0068e\u0069\u0067\u0068\u0074");
};_acca :=_eab (width ,height );_gbfb :=make ([]int ,height );_gca :=make ([]int ,width );_cggb :=float64 (_ede .Width )/float64 (width );_fcfd :=float64 (_ede .Height )/float64 (height );for _edee :=0;_edee < height ;_edee ++{_gbfb [_edee ]=int (_g .Min (_fcfd *float64 (_edee )+0.5,float64 (_ede .Height -1)));
};for _ffba :=0;_ffba < width ;_ffba ++{_gca [_ffba ]=int (_g .Min (_cggb *float64 (_ffba )+0.5,float64 (_ede .Width -1)));};_fbcd :=-1;_egcc :=byte (0);for _edeed :=0;_edeed < height ;_edeed ++{_ggcc :=_gbfb [_edeed ]*_ede .BytesPerLine ;_baa :=_edeed *_acca .BytesPerLine ;
for _eeffdg :=0;_eeffdg < width ;_eeffdg ++{_fggc :=_gca [_eeffdg ];if _fggc !=_fbcd {_egcc =_ede .getBit (_ggcc ,_fggc );if _egcc !=0{_acca .setBit (_baa ,_eeffdg );};_fbcd =_fggc ;}else {if _egcc !=0{_acca .setBit (_baa ,_eeffdg );};};};};return _acca ,nil ;
};func (_gfbg *Monochrome )Bounds ()_c .Rectangle {return _c .Rectangle {Max :_c .Point {X :_gfbg .Width ,Y :_gfbg .Height }};};func ColorAtGray2BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_d .Gray ,error ){_agfd :=y *bytesPerLine +x >>2;
if _agfd >=len (data ){return _d .Gray {},_ccc .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_afff :=data [_agfd ]>>uint (6-(x &3)*2)&3;if len (decode )==2{_afff =uint8 (uint32 (LinearInterpolate (float64 (_afff ),0,3.0,decode [0],decode [1]))&3);};return _d .Gray {Y :_afff *85},nil ;};func _gabb (_ddbb _c .Image ,_aecc Image ,_acad _c .Rectangle ){for _fdbe :=0;
_fdbe < _acad .Max .X ;_fdbe ++{for _abb :=0;_abb < _acad .Max .Y ;_abb ++{_adc :=_ddbb .At (_fdbe ,_abb );_aecc .Set (_fdbe ,_abb ,_adc );};};};func (_bceg *CMYK32 )At (x ,y int )_d .Color {_gece ,_ :=_bceg .ColorAt (x ,y );return _gece };func (_daea *CMYK32 )ColorAt (x ,y int )(_d .Color ,error ){return ColorAtCMYK (x ,y ,_daea .Width ,_daea .Data ,_daea .Decode );
};func (_accaa *ImageBase )setTwoBytes (_gccg int ,_gbdd uint16 )error {if _gccg +1> len (_accaa .Data )-1{return _f .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_accaa .Data [_gccg ]=byte ((_gbdd &0xff00)>>8);
_accaa .Data [_gccg +1]=byte (_gbdd &0xff);return nil ;};func (_fefd *NRGBA16 )NRGBAAt (x ,y int )_d .NRGBA {_fcacf ,_ :=ColorAtNRGBA16 (x ,y ,_fefd .Width ,_fefd .BytesPerLine ,_fefd .Data ,_fefd .Alpha ,_fefd .Decode );return _fcacf ;};func (_gceg *ImageBase )HasAlpha ()bool {if _gceg .Alpha ==nil {return false ;
};for _cedf :=range _gceg .Alpha {if _gceg .Alpha [_cedf ]!=0xff{return true ;};};return false ;};var _ Image =&Gray8 {};func NewImage (width ,height ,bitsPerComponent ,colorComponents int ,data ,alpha []byte ,decode []float64 )(Image ,error ){_fge :=NewImageBase (width ,height ,bitsPerComponent ,colorComponents ,data ,alpha ,decode );
var _gcga Image ;switch colorComponents {case 1:switch bitsPerComponent {case 1:_gcga =&Monochrome {ImageBase :_fge ,ModelThreshold :0x0f};case 2:_gcga =&Gray2 {ImageBase :_fge };case 4:_gcga =&Gray4 {ImageBase :_fge };case 8:_gcga =&Gray8 {ImageBase :_fge };
case 16:_gcga =&Gray16 {ImageBase :_fge };};case 3:switch bitsPerComponent {case 4:_gcga =&NRGBA16 {ImageBase :_fge };case 8:_gcga =&NRGBA32 {ImageBase :_fge };case 16:_gcga =&NRGBA64 {ImageBase :_fge };};case 4:_gcga =&CMYK32 {ImageBase :_fge };};if _gcga ==nil {return nil ,ErrInvalidImage ;
};return _gcga ,nil ;};func _gbdb (_cbb *_c .Gray )bool {for _affg :=0;_affg < len (_cbb .Pix );_affg ++{if !_bdbcc (_cbb .Pix [_affg ]){return false ;};};return true ;};func _fggd (_bebe int ,_beafg int )error {return _ccc .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",_bebe ,_beafg );
};func _ed (_adf ,_ga *Monochrome )(_cf error ){_ge :=_ga .BytesPerLine ;_gaa :=_adf .BytesPerLine ;_eca :=_ga .BytesPerLine *4-_adf .BytesPerLine ;var (_gaf ,_deb byte ;_gf uint32 ;_bgb ,_ba ,_gb ,_ac ,_ee ,_ae ,_bd int ;);for _gb =0;_gb < _ga .Height ;
_gb ++{_bgb =_gb *_ge ;_ba =4*_gb *_gaa ;for _ac =0;_ac < _ge ;_ac ++{_gaf =_ga .Data [_bgb +_ac ];_gf =_bge [_gaf ];_ae =_ba +_ac *4;if _eca !=0&&(_ac +1)*4> _adf .BytesPerLine {for _ee =_eca ;_ee > 0;_ee --{_deb =byte ((_gf >>uint (_ee *8))&0xff);_bd =_ae +(_eca -_ee );
if _cf =_adf .setByte (_bd ,_deb );_cf !=nil {return _cf ;};};}else if _cf =_adf .setFourBytes (_ae ,_gf );_cf !=nil {return _cf ;};if _cf =_adf .setFourBytes (_ba +_ac *4,_bge [_ga .Data [_bgb +_ac ]]);_cf !=nil {return _cf ;};};for _ee =1;_ee < 4;_ee ++{for _ac =0;
_ac < _gaa ;_ac ++{if _cf =_adf .setByte (_ba +_ee *_gaa +_ac ,_adf .Data [_ba +_ac ]);_cf !=nil {return _cf ;};};};};return nil ;};func (_dbgg *Gray16 )Set (x ,y int ,c _d .Color ){_fcdg :=(y *_dbgg .BytesPerLine /2+x )*2;if _fcdg +1>=len (_dbgg .Data ){return ;
};_egfb :=_d .Gray16Model .Convert (c ).(_d .Gray16 );_dbgg .Data [_fcdg ],_dbgg .Data [_fcdg +1]=uint8 (_egfb .Y >>8),uint8 (_egfb .Y &0xff);};func (_fgfc *ImageBase )setByte (_geag int ,_fbae byte )error {if _geag > len (_fgfc .Data )-1{return _f .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_fgfc .Data [_geag ]=_fbae ;return nil ;};func (_gfff *NRGBA32 )NRGBAAt (x ,y int )_d .NRGBA {_dfgg ,_ :=ColorAtNRGBA32 (x ,y ,_gfff .Width ,_gfff .Data ,_gfff .Alpha ,_gfff .Decode );return _dfgg ;};func ColorAt (x ,y ,width ,bitsPerColor ,colorComponents ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_d .Color ,error ){switch colorComponents {case 1:return ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine ,data ,decode );
case 3:return ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor ,data ,alpha ,decode );case 4:return ColorAtCMYK (x ,y ,width ,data ,decode );default:return nil ,_ccc .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0063o\u006c\u006f\u0072\u0020\u0063\u006f\u006dp\u006f\u006e\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0064",colorComponents );
};};func _fd (_eg ,_bgg *Monochrome )(_eb error ){_fbf :=_bgg .BytesPerLine ;_ca :=_eg .BytesPerLine ;var (_af byte ;_ff uint16 ;_bcc ,_fbe ,_ag ,_be ,_ad int ;);for _ag =0;_ag < _bgg .Height ;_ag ++{_bcc =_ag *_fbf ;_fbe =2*_ag *_ca ;for _be =0;_be < _fbf ;
_be ++{_af =_bgg .Data [_bcc +_be ];_ff =_fde [_af ];_ad =_fbe +_be *2;if _eg .BytesPerLine !=_bgg .BytesPerLine *2&&(_be +1)*2> _eg .BytesPerLine {_eb =_eg .setByte (_ad ,byte (_ff >>8));}else {_eb =_eg .setTwoBytes (_ad ,_ff );};if _eb !=nil {return _eb ;
};};for _be =0;_be < _ca ;_be ++{_ad =_fbe +_ca +_be ;_af =_eg .Data [_fbe +_be ];if _eb =_eg .setByte (_ad ,_af );_eb !=nil {return _eb ;};};};return nil ;};func ColorAtCMYK (x ,y ,width int ,data []byte ,decode []float64 )(_d .CMYK ,error ){_gbgc :=4*(y *width +x );
if _gbgc +3>=len (data ){return _d .CMYK {},_ccc .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};C :=data [_gbgc ]&0xff;M :=data [_gbgc +1]&0xff;Y :=data [_gbgc +2]&0xff;K :=data [_gbgc +3]&0xff;if len (decode )==8{C =uint8 (uint32 (LinearInterpolate (float64 (C ),0,255,decode [0],decode [1]))&0xff);M =uint8 (uint32 (LinearInterpolate (float64 (M ),0,255,decode [2],decode [3]))&0xff);
Y =uint8 (uint32 (LinearInterpolate (float64 (Y ),0,255,decode [4],decode [5]))&0xff);K =uint8 (uint32 (LinearInterpolate (float64 (K ),0,255,decode [6],decode [7]))&0xff);};return _d .CMYK {C :C ,M :M ,Y :Y ,K :K },nil ;};func (_egf *Gray4 )setGray (_dfe int ,_baed int ,_fcba _d .Gray ){_dfca :=_baed *_egf .BytesPerLine ;
_bgbg :=_dfca +(_dfe >>1);if _bgbg >=len (_egf .Data ){return ;};_aad :=_fcba .Y >>4;_egf .Data [_bgbg ]=(_egf .Data [_bgbg ]&(^(0xf0>>uint (4*(_dfe &1)))))|(_aad <<uint (4-4*(_dfe &1)));};func _baee (_cbcg _d .RGBA )_d .Gray {_ggd :=(19595*uint32 (_cbcg .R )+38470*uint32 (_cbcg .G )+7471*uint32 (_cbcg .B )+1<<7)>>16;
return _d .Gray {Y :uint8 (_ggd )};};func GetConverter (bitsPerComponent ,colorComponents int )(ColorConverter ,error ){switch colorComponents {case 1:switch bitsPerComponent {case 1:return MonochromeConverter ,nil ;case 2:return Gray2Converter ,nil ;case 4:return Gray4Converter ,nil ;
case 8:return GrayConverter ,nil ;case 16:return Gray16Converter ,nil ;};case 3:switch bitsPerComponent {case 4:return NRGBA16Converter ,nil ;case 8:return NRGBAConverter ,nil ;case 16:return NRGBA64Converter ,nil ;};case 4:return CMYKConverter ,nil ;};
return nil ,_ccc .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0043o\u006e\u0076\u0065\u0072\u0074\u0065\u0072\u0020\u0070\u0061\u0072\u0061\u006d\u0065t\u0065\u0072\u0073\u002e\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003a\u0020\u0025\u0064\u002c\u0020\u0043\u006f\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006et\u0073\u003a \u0025\u0064",bitsPerComponent ,colorComponents );
};func (_dbag *CMYK32 )Copy ()Image {return &CMYK32 {ImageBase :_dbag .copy ()}};func (_fgbfa *NRGBA64 )ColorAt (x ,y int )(_d .Color ,error ){return ColorAtNRGBA64 (x ,y ,_fgbfa .Width ,_fgbfa .Data ,_fgbfa .Alpha ,_fgbfa .Decode );};func (_dgcc *Gray4 )Set (x ,y int ,c _d .Color ){if x >=_dgcc .Width ||y >=_dgcc .Height {return ;
};_fffe :=Gray4Model .Convert (c ).(_d .Gray );_dgcc .setGray (x ,y ,_fffe );};func (_cege *Monochrome )setBit (_edef ,_cbf int ){_cege .Data [_edef +(_cbf >>3)]|=0x80>>uint (_cbf &7)};func (_ebee *Gray2 )Base ()*ImageBase {return &_ebee .ImageBase };func (_dfgd *NRGBA64 )SetNRGBA64 (x ,y int ,c _d .NRGBA64 ){_faee :=(y *_dfgd .Width +x )*2;
_egca :=_faee *3;if _egca +5>=len (_dfgd .Data ){return ;};_dfgd .setNRGBA64 (_egca ,c ,_faee );};func (_gcbc *Monochrome )setGrayBit (_faf ,_ebdgd int ){_gcbc .Data [_faf ]|=0x80>>uint (_ebdgd &7)};func (_efa *Gray2 )ColorAt (x ,y int )(_d .Color ,error ){return ColorAtGray2BPC (x ,y ,_efa .BytesPerLine ,_efa .Data ,_efa .Decode );
};func (_gcfa *NRGBA16 )Set (x ,y int ,c _d .Color ){_eebfg :=y *_gcfa .BytesPerLine +x *3/2;if _eebfg +1>=len (_gcfa .Data ){return ;};_dad :=NRGBA16Model .Convert (c ).(_d .NRGBA );_gcfa .setNRGBA (x ,y ,_eebfg ,_dad );};func (_fbfdb *Monochrome )setGray (_ffab int ,_gdf _d .Gray ,_eagg int ){if _gdf .Y ==0{_fbfdb .clearBit (_eagg ,_ffab );
}else {_fbfdb .setGrayBit (_eagg ,_ffab );};};type NRGBA32 struct{ImageBase };func (_eba *ImageBase )copy ()ImageBase {_cddcf :=*_eba ;_cddcf .Data =make ([]byte ,len (_eba .Data ));copy (_cddcf .Data ,_eba .Data );return _cddcf ;};func _cgb (_cfgd _d .Gray )_d .CMYK {return _d .CMYK {K :0xff-_cfgd .Y }};
func ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine int ,data []byte ,decode []float64 )(_d .Color ,error ){switch bitsPerColor {case 1:return ColorAtGray1BPC (x ,y ,bytesPerLine ,data ,decode );case 2:return ColorAtGray2BPC (x ,y ,bytesPerLine ,data ,decode );
case 4:return ColorAtGray4BPC (x ,y ,bytesPerLine ,data ,decode );case 8:return ColorAtGray8BPC (x ,y ,bytesPerLine ,data ,decode );case 16:return ColorAtGray16BPC (x ,y ,bytesPerLine ,data ,decode );default:return nil ,_ccc .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0067\u0072\u0061\u0079\u0020\u0073c\u0061\u006c\u0065\u0020\u0062\u0069\u0074s\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020a\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );
};};func _aede (_bcabd nrgba64 ,_fgca NRGBA ,_caddd _c .Rectangle ){for _cfea :=0;_cfea < _caddd .Max .X ;_cfea ++{for _bbgb :=0;_bbgb < _caddd .Max .Y ;_bbgb ++{_adbe :=_bcabd .NRGBA64At (_cfea ,_bbgb );_fgca .SetNRGBA (_cfea ,_bbgb ,_ecdd (_adbe ));};
};};func _bagd (_afcg _d .NRGBA )_d .Gray {var _aece _d .NRGBA ;if _afcg ==_aece {return _d .Gray {Y :0xff};};_cea ,_bbf ,_eabf ,_ :=_afcg .RGBA ();_bac :=(19595*_cea +38470*_bbf +7471*_eabf +1<<15)>>24;return _d .Gray {Y :uint8 (_bac )};};type RasterOperator int ;
var _ Gray =&Monochrome {};var (Gray2Model =_d .ModelFunc (_edea );Gray4Model =_d .ModelFunc (_gbgcd );NRGBA16Model =_d .ModelFunc (_fcac ););func _daa (_faeg ,_afeb Gray ,_aggf _c .Rectangle ){for _ceac :=0;_ceac < _aggf .Max .X ;_ceac ++{for _fdeb :=0;
_fdeb < _aggf .Max .Y ;_fdeb ++{_afeb .SetGray (_ceac ,_fdeb ,_faeg .GrayAt (_ceac ,_fdeb ));};};};func _dcab (_cec *Monochrome ,_agff ,_cfdg int ,_febd ,_gbeg int ,_fafd RasterOperator ){var (_gcafd int ;_gcegg byte ;_egcg ,_gcgf int ;_gee int ;);_gff :=_febd >>3;
_agfe :=_febd &7;if _agfe > 0{_gcegg =_gggg [_agfe ];};_gcafd =_cec .BytesPerLine *_cfdg +(_agff >>3);switch _fafd {case PixClr :for _egcg =0;_egcg < _gbeg ;_egcg ++{_gee =_gcafd +_egcg *_cec .BytesPerLine ;for _gcgf =0;_gcgf < _gff ;_gcgf ++{_cec .Data [_gee ]=0x0;
_gee ++;};if _agfe > 0{_cec .Data [_gee ]=_bagb (_cec .Data [_gee ],0x0,_gcegg );};};case PixSet :for _egcg =0;_egcg < _gbeg ;_egcg ++{_gee =_gcafd +_egcg *_cec .BytesPerLine ;for _gcgf =0;_gcgf < _gff ;_gcgf ++{_cec .Data [_gee ]=0xff;_gee ++;};if _agfe > 0{_cec .Data [_gee ]=_bagb (_cec .Data [_gee ],0xff,_gcegg );
};};case PixNotDst :for _egcg =0;_egcg < _gbeg ;_egcg ++{_gee =_gcafd +_egcg *_cec .BytesPerLine ;for _gcgf =0;_gcgf < _gff ;_gcgf ++{_cec .Data [_gee ]=^_cec .Data [_gee ];_gee ++;};if _agfe > 0{_cec .Data [_gee ]=_bagb (_cec .Data [_gee ],^_cec .Data [_gee ],_gcegg );
};};};};func (_gabd *Gray2 )SetGray (x ,y int ,gray _d .Gray ){_edcea :=_dfbg (gray );_cdg :=y *_gabd .BytesPerLine ;_cegd :=_cdg +(x >>2);if _cegd >=len (_gabd .Data ){return ;};_cfeb :=_edcea .Y >>6;_gabd .Data [_cegd ]=(_gabd .Data [_cegd ]&(^(0xc0>>uint (2*((x )&3)))))|(_cfeb <<uint (6-2*(x &3)));
};func ScaleAlphaToMonochrome (data []byte ,width ,height int )([]byte ,error ){_ec :=BytesPerLine (width ,8,1);if len (data )< _ec *height {return nil ,nil ;};_fc :=&Gray8 {NewImageBase (width ,height ,8,1,data ,nil ,nil )};_gg ,_fcb :=MonochromeConverter .Convert (_fc );
if _fcb !=nil {return nil ,_fcb ;};return _gg .Base ().Data ,nil ;};func _gcbe (_fdbg RGBA ,_feaa NRGBA ,_gfcba _c .Rectangle ){for _gbgg :=0;_gbgg < _gfcba .Max .X ;_gbgg ++{for _ebff :=0;_ebff < _gfcba .Max .Y ;_ebff ++{_bbabg :=_fdbg .RGBAAt (_gbgg ,_ebff );
_feaa .SetNRGBA (_gbgg ,_ebff ,_dfb (_bbabg ));};};};var _ Image =&CMYK32 {};func (_gcad *NRGBA32 )Copy ()Image {return &NRGBA32 {ImageBase :_gcad .copy ()}};type ImageBase struct{Width ,Height int ;BitsPerComponent ,ColorComponents int ;Data ,Alpha []byte ;
Decode []float64 ;BytesPerLine int ;};func _fefe (_aadeb ,_fddga uint8 )uint8 {if _aadeb < _fddga {return 255;};return 0;};func ColorAtGray1BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_d .Gray ,error ){_dbg :=y *bytesPerLine +x >>3;if _dbg >=len (data ){return _d .Gray {},_ccc .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_feg :=data [_dbg ]>>uint (7-(x &7))&1;if len (decode )==2{_feg =uint8 (LinearInterpolate (float64 (_feg ),0.0,1.0,decode [0],decode [1]))&1;};return _d .Gray {Y :_feg *255},nil ;};func (_gecg *Gray16 )Histogram ()(_ccdd [256]int ){for _ecfc :=0;_ecfc < _gecg .Width ;
_ecfc ++{for _cgc :=0;_cgc < _gecg .Height ;_cgc ++{_ccdd [_gecg .GrayAt (_ecfc ,_cgc ).Y ]++;};};return _ccdd ;};func _fcaa (_eeffb _c .Image )(Image ,error ){if _gafb ,_ecdg :=_eeffb .(*NRGBA32 );_ecdg {return _gafb .Copy (),nil ;};_facf ,_eeffa ,_dbecb :=_agag (_eeffb ,1);
_eedg ,_fdfd :=NewImage (_facf .Max .X ,_facf .Max .Y ,8,3,nil ,_dbecb ,nil );if _fdfd !=nil {return nil ,_fdfd ;};_cdgdd (_eeffb ,_eedg ,_facf );if len (_dbecb )!=0&&!_eeffa {if _cfef :=_aaeb (_dbecb ,_eedg );_cfef !=nil {return nil ,_cfef ;};};return _eedg ,nil ;
};func _edea (_fae _d .Color )_d .Color {_aacf :=_d .GrayModel .Convert (_fae ).(_d .Gray );return _dfbg (_aacf );};func (_ffdf *Gray4 )Validate ()error {if len (_ffdf .Data )!=_ffdf .Height *_ffdf .BytesPerLine {return ErrInvalidImage ;};return nil ;};
func _dfb (_cff _d .RGBA )_d .NRGBA {switch _cff .A {case 0xff:return _d .NRGBA {R :_cff .R ,G :_cff .G ,B :_cff .B ,A :0xff};case 0x00:return _d .NRGBA {};default:_ccca ,_eggg ,_efeg ,_ccabb :=_cff .RGBA ();_ccca =(_ccca *0xffff)/_ccabb ;_eggg =(_eggg *0xffff)/_ccabb ;
_efeg =(_efeg *0xffff)/_ccabb ;return _d .NRGBA {R :uint8 (_ccca >>8),G :uint8 (_eggg >>8),B :uint8 (_efeg >>8),A :uint8 (_ccabb >>8)};};};func ImgToGray (i _c .Image )*_c .Gray {if _bfee ,_ddbff :=i .(*_c .Gray );_ddbff {return _bfee ;};_eagd :=i .Bounds ();
_dgae :=_c .NewGray (_eagd );for _gbed :=0;_gbed < _eagd .Max .X ;_gbed ++{for _gfeg :=0;_gfeg < _eagd .Max .Y ;_gfeg ++{_fgga :=i .At (_gbed ,_gfeg );_dgae .Set (_gbed ,_gfeg ,_fgga );};};return _dgae ;};func (_aecfb *NRGBA32 )Validate ()error {if len (_aecfb .Data )!=3*_aecfb .Width *_aecfb .Height {return _f .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func _bbb (_aceb CMYK ,_cdfe NRGBA ,_effgd _c .Rectangle ){for _gdgg :=0;_gdgg < _effgd .Max .X ;_gdgg ++{for _deac :=0;_deac < _effgd .Max .Y ;_deac ++{_bgba :=_aceb .CMYKAt (_gdgg ,_deac );_cdfe .SetNRGBA (_gdgg ,_deac ,_ffa (_bgba ));
};};};func _gea ()(_cfe [256]uint32 ){for _cgg :=0;_cgg < 256;_cgg ++{if _cgg &0x01!=0{_cfe [_cgg ]|=0xf;};if _cgg &0x02!=0{_cfe [_cgg ]|=0xf0;};if _cgg &0x04!=0{_cfe [_cgg ]|=0xf00;};if _cgg &0x08!=0{_cfe [_cgg ]|=0xf000;};if _cgg &0x10!=0{_cfe [_cgg ]|=0xf0000;
};if _cgg &0x20!=0{_cfe [_cgg ]|=0xf00000;};if _cgg &0x40!=0{_cfe [_cgg ]|=0xf000000;};if _cgg &0x80!=0{_cfe [_cgg ]|=0xf0000000;};};return _cfe ;};func _gcea (_cbef ,_caff NRGBA ,_accg _c .Rectangle ){for _gecb :=0;_gecb < _accg .Max .X ;_gecb ++{for _bbff :=0;
_bbff < _accg .Max .Y ;_bbff ++{_caff .SetNRGBA (_gecb ,_bbff ,_cbef .NRGBAAt (_gecb ,_bbff ));};};};const (_cddcg shift =iota ;_cadd ;);func (_aeedb *NRGBA32 )SetNRGBA (x ,y int ,c _d .NRGBA ){_cfbb :=y *_aeedb .Width +x ;_baaf :=3*_cfbb ;if _baaf +2>=len (_aeedb .Data ){return ;
};_aeedb .setRGBA (_cfbb ,c );};func (_abaa *NRGBA32 )Set (x ,y int ,c _d .Color ){_cacf :=y *_abaa .Width +x ;_eggf :=3*_cacf ;if _eggf +2>=len (_abaa .Data ){return ;};_cdfc :=_d .NRGBAModel .Convert (c ).(_d .NRGBA );_abaa .setRGBA (_cacf ,_cdfc );};
func _fefb (_afcc *Monochrome ,_daca ,_gadc ,_bfbd ,_cgga int ,_ffdc RasterOperator ,_fbee *Monochrome ,_cbaac ,_cgfb int )error {if _afcc ==nil {return _f .New ("\u006e\u0069\u006c\u0020\u0027\u0064\u0065\u0073\u0074\u0027\u0020\u0042i\u0074\u006d\u0061\u0070");
};if _ffdc ==PixDst {return nil ;};switch _ffdc {case PixClr ,PixSet ,PixNotDst :_febcf (_afcc ,_daca ,_gadc ,_bfbd ,_cgga ,_ffdc );return nil ;};if _fbee ==nil {_ef .Log .Debug ("\u0052a\u0073\u0074e\u0072\u004f\u0070\u0065r\u0061\u0074\u0069o\u006e\u0020\u0073\u006f\u0075\u0072\u0063\u0065\u0020bi\u0074\u006d\u0061p\u0020\u0069s\u0020\u006e\u006f\u0074\u0020\u0064e\u0066\u0069n\u0065\u0064");
return _f .New ("\u006e\u0069l\u0020\u0027\u0073r\u0063\u0027\u0020\u0062\u0069\u0074\u006d\u0061\u0070");};if _gcef :=_gcbf (_afcc ,_daca ,_gadc ,_bfbd ,_cgga ,_ffdc ,_fbee ,_cbaac ,_cgfb );_gcef !=nil {return _gcef ;};return nil ;};func (_bdbf *NRGBA64 )Set (x ,y int ,c _d .Color ){_eedc :=(y *_bdbf .Width +x )*2;
_gggge :=_eedc *3;if _gggge +5>=len (_bdbf .Data ){return ;};_gffg :=_d .NRGBA64Model .Convert (c ).(_d .NRGBA64 );_bdbf .setNRGBA64 (_gggge ,_gffg ,_eedc );};func (_edad *Monochrome )At (x ,y int )_d .Color {_gdec ,_ :=_edad .ColorAt (x ,y );return _gdec };
type NRGBA64 struct{ImageBase };type Gray8 struct{ImageBase };var _ Image =&NRGBA64 {};func (_ggdd *Gray2 )At (x ,y int )_d .Color {_adef ,_ :=_ggdd .ColorAt (x ,y );return _adef };func (_fce *Gray2 )Validate ()error {if len (_fce .Data )!=_fce .Height *_fce .BytesPerLine {return ErrInvalidImage ;
};return nil ;};func _cd (_cb *Monochrome ,_aba ,_dec int )(*Monochrome ,error ){if _cb ==nil {return nil ,_f .New ("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064");};if _aba <=0||_dec <=0{return nil ,_f .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0073\u0063\u0061l\u0065\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020<\u003d\u0020\u0030");
};if _aba ==_dec {if _aba ==1{return _cb .copy (),nil ;};if _aba ==2||_aba ==4||_aba ==8{_eefg ,_baf :=_a (_cb ,_aba );if _baf !=nil {return nil ,_baf ;};return _eefg ,nil ;};};_cca :=_aba *_cb .Width ;_gfd :=_dec *_cb .Height ;_cfc :=_eab (_cca ,_gfd );
_dc :=_cfc .BytesPerLine ;var (_dee ,_gac ,_fdf ,_fed ,_ccec int ;_age byte ;_cba error ;);for _gac =0;_gac < _cb .Height ;_gac ++{_dee =_dec *_gac *_dc ;for _fdf =0;_fdf < _cb .Width ;_fdf ++{if _bf :=_cb .getBitAt (_fdf ,_gac );_bf {_ccec =_aba *_fdf ;
for _fed =0;_fed < _aba ;_fed ++{_cfc .setIndexedBit (_dee *8+_ccec +_fed );};};};for _fed =1;_fed < _dec ;_fed ++{_agf :=_dee +_fed *_dc ;for _deg :=0;_deg < _dc ;_deg ++{if _age ,_cba =_cfc .getByte (_dee +_deg );_cba !=nil {return nil ,_cba ;};if _cba =_cfc .setByte (_agf +_deg ,_age );
_cba !=nil {return nil ,_cba ;};};};};return _cfc ,nil ;};func (_ebab *ImageBase )getByte (_bccg int )(byte ,error ){if _bccg > len (_ebab .Data )-1||_bccg < 0{return 0,_ccc .Errorf ("\u0069\u006e\u0064\u0065x:\u0020\u0025\u0064\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006eg\u0065",_bccg );
};return _ebab .Data [_bccg ],nil ;};type Image interface{_b .Image ;Base ()*ImageBase ;Copy ()Image ;Pix ()[]byte ;ColorAt (_dggc ,_efgg int )(_d .Color ,error );Validate ()error ;};func (_dcgd *ImageBase )setEightFullBytes (_ggae int ,_fgbf uint64 )error {if _ggae +7> len (_dcgd .Data )-1{return _f .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_dcgd .Data [_ggae ]=byte ((_fgbf &0xff00000000000000)>>56);_dcgd .Data [_ggae +1]=byte ((_fgbf &0xff000000000000)>>48);_dcgd .Data [_ggae +2]=byte ((_fgbf &0xff0000000000)>>40);_dcgd .Data [_ggae +3]=byte ((_fgbf &0xff00000000)>>32);_dcgd .Data [_ggae +4]=byte ((_fgbf &0xff000000)>>24);
_dcgd .Data [_ggae +5]=byte ((_fgbf &0xff0000)>>16);_dcgd .Data [_ggae +6]=byte ((_fgbf &0xff00)>>8);_dcgd .Data [_ggae +7]=byte (_fgbf &0xff);return nil ;};func (_ceab *Gray2 )ColorModel ()_d .Model {return Gray2Model };func (_deeb *NRGBA64 )setNRGBA64 (_ffdge int ,_eefd _d .NRGBA64 ,_gacd int ){_deeb .Data [_ffdge ]=uint8 (_eefd .R >>8);
_deeb .Data [_ffdge +1]=uint8 (_eefd .R &0xff);_deeb .Data [_ffdge +2]=uint8 (_eefd .G >>8);_deeb .Data [_ffdge +3]=uint8 (_eefd .G &0xff);_deeb .Data [_ffdge +4]=uint8 (_eefd .B >>8);_deeb .Data [_ffdge +5]=uint8 (_eefd .B &0xff);if _gacd +1< len (_deeb .Alpha ){_deeb .Alpha [_gacd ]=uint8 (_eefd .A >>8);
_deeb .Alpha [_gacd +1]=uint8 (_eefd .A &0xff);};};func _gabde (_agea uint )uint {var _acgb uint ;for _agea !=0{_agea >>=1;_acgb ++;};return _acgb -1;};func (_dbeg *NRGBA16 )setNRGBA (_ddab ,_cccf ,_egcb int ,_babd _d .NRGBA ){if _ddab *3%2==0{_dbeg .Data [_egcb ]=(_babd .R >>4)<<4|(_babd .G >>4);
_dbeg .Data [_egcb +1]=(_babd .B >>4)<<4|(_dbeg .Data [_egcb +1]&0xf);}else {_dbeg .Data [_egcb ]=(_dbeg .Data [_egcb ]&0xf0)|(_babd .R >>4);_dbeg .Data [_egcb +1]=(_babd .G >>4)<<4|(_babd .B >>4);};if _dbeg .Alpha !=nil {_edga :=_cccf *BytesPerLine (_dbeg .Width ,4,1);
if _edga < len (_dbeg .Alpha ){if _ddab %2==0{_dbeg .Alpha [_edga ]=(_babd .A >>uint (4))<<uint (4)|(_dbeg .Alpha [_egcb ]&0xf);}else {_dbeg .Alpha [_edga ]=(_dbeg .Alpha [_edga ]&0xf0)|(_babd .A >>uint (4));};};};};func BytesPerLine (width ,bitsPerComponent ,colorComponents int )int {return ((width *bitsPerComponent )*colorComponents +7)>>3;
};type nrgba64 interface{NRGBA64At (_bbeb ,_agec int )_d .NRGBA64 ;SetNRGBA64 (_ebeec ,_efab int ,_abab _d .NRGBA64 );};func _afac (_dfc RGBA ,_fgaf CMYK ,_ggc _c .Rectangle ){for _gfcb :=0;_gfcb < _ggc .Max .X ;_gfcb ++{for _dge :=0;_dge < _ggc .Max .Y ;
_dge ++{_gc :=_dfc .RGBAAt (_gfcb ,_dge );_fgaf .SetCMYK (_gfcb ,_dge ,_ddgg (_gc ));};};};func _dbcf (_egeb _d .NRGBA )_d .Gray {_gba ,_egg ,_fag ,_ :=_egeb .RGBA ();_ddda :=(19595*_gba +38470*_egg +7471*_fag +1<<15)>>24;return _d .Gray {Y :uint8 (_ddda )};
};func _bagb (_affa ,_fcdef ,_bgga byte )byte {return (_affa &^(_bgga ))|(_fcdef &_bgga )};func (_faeb *Gray4 )Copy ()Image {return &Gray4 {ImageBase :_faeb .copy ()}};type Histogramer interface{Histogram ()[256]int ;};func (_gcd *Gray8 )Validate ()error {if len (_gcd .Data )!=_gcd .Height *_gcd .BytesPerLine {return ErrInvalidImage ;
};return nil ;};func AddDataPadding (width ,height ,bitsPerComponent ,colorComponents int ,data []byte )([]byte ,error ){_eefgb :=BytesPerLine (width ,bitsPerComponent ,colorComponents );if _eefgb ==width *colorComponents *bitsPerComponent /8{return data ,nil ;
};_eebf :=width *colorComponents *bitsPerComponent ;_bcaa :=_eefgb *8;_cegf :=8-(_bcaa -_eebf );_fffeg :=_de .NewReader (data );_cgbc :=_eefgb -1;_daed :=make ([]byte ,_cgbc );_gbada :=make ([]byte ,height *_eefgb );_gbbaa :=_de .NewWriterMSB (_gbada );
var _gdgc uint64 ;var _fgfa error ;for _ggcf :=0;_ggcf < height ;_ggcf ++{_ ,_fgfa =_fffeg .Read (_daed );if _fgfa !=nil {return nil ,_fgfa ;};_ ,_fgfa =_gbbaa .Write (_daed );if _fgfa !=nil {return nil ,_fgfa ;};_gdgc ,_fgfa =_fffeg .ReadBits (byte (_cegf ));
if _fgfa !=nil {return nil ,_fgfa ;};_ ,_fgfa =_gbbaa .WriteBits (_gdgc ,_cegf );if _fgfa !=nil {return nil ,_fgfa ;};_gbbaa .FinishByte ();};return _gbada ,nil ;};func (_adcf *Monochrome )RasterOperation (dx ,dy ,dw ,dh int ,op RasterOperator ,src *Monochrome ,sx ,sy int )error {return _fefb (_adcf ,dx ,dy ,dw ,dh ,op ,src ,sx ,sy );
};func MonochromeThresholdConverter (threshold uint8 )ColorConverter {return &monochromeThresholdConverter {Threshold :threshold };};func (_gcaf *Monochrome )getBit (_fdgf ,_ccee int )uint8 {return _gcaf .Data [_fdgf +(_ccee >>3)]>>uint (7-(_ccee &7))&1;
};var _ NRGBA =&NRGBA16 {};func (_gfb *CMYK32 )Bounds ()_c .Rectangle {return _c .Rectangle {Max :_c .Point {X :_gfb .Width ,Y :_gfb .Height }};};func (_ebbe *Gray8 )At (x ,y int )_d .Color {_eead ,_ :=_ebbe .ColorAt (x ,y );return _eead };func (_debcg *NRGBA16 )ColorModel ()_d .Model {return NRGBA16Model };
func (_cbddc *NRGBA16 )Bounds ()_c .Rectangle {return _c .Rectangle {Max :_c .Point {X :_cbddc .Width ,Y :_cbddc .Height }};};func (_eeba *NRGBA32 )ColorAt (x ,y int )(_d .Color ,error ){return ColorAtNRGBA32 (x ,y ,_eeba .Width ,_eeba .Data ,_eeba .Alpha ,_eeba .Decode );
};func _fef (_da int )[]uint {var _fcbf []uint ;_dag :=_da ;_agb :=_dag /8;if _agb !=0{for _cdc :=0;_cdc < _agb ;_cdc ++{_fcbf =append (_fcbf ,8);};_acac :=_dag %8;_dag =0;if _acac !=0{_dag =_acac ;};};_gbg :=_dag /4;if _gbg !=0{for _gd :=0;_gd < _gbg ;
_gd ++{_fcbf =append (_fcbf ,4);};_gbd :=_dag %4;_dag =0;if _gbd !=0{_dag =_gbd ;};};_afa :=_dag /2;if _afa !=0{for _geaf :=0;_geaf < _afa ;_geaf ++{_fcbf =append (_fcbf ,2);};};return _fcbf ;};func (_gaeb *Gray8 )GrayAt (x ,y int )_d .Gray {_eeaa ,_ :=ColorAtGray8BPC (x ,y ,_gaeb .BytesPerLine ,_gaeb .Data ,_gaeb .Decode );
return _eeaa ;};func ColorAtGray4BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_d .Gray ,error ){_addf :=y *bytesPerLine +x >>1;if _addf >=len (data ){return _d .Gray {},_ccc .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_aaaa :=data [_addf ]>>uint (4-(x &1)*4)&0xf;if len (decode )==2{_aaaa =uint8 (uint32 (LinearInterpolate (float64 (_aaaa ),0,15,decode [0],decode [1]))&0xf);};return _d .Gray {Y :_aaaa *17&0xff},nil ;};func (_acbf *NRGBA64 )ColorModel ()_d .Model {return _d .NRGBA64Model };
var _ Gray =&Gray8 {};func (_gaag monochromeModel )Convert (c _d .Color )_d .Color {_bafg :=_d .GrayModel .Convert (c ).(_d .Gray );return _ddba (_bafg ,_gaag );};func (_cdcd *ImageBase )setFourBytes (_eafcb int ,_ggab uint32 )error {if _eafcb +3> len (_cdcd .Data )-1{return _ccc .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006fu\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065",_eafcb );
};_cdcd .Data [_eafcb ]=byte ((_ggab &0xff000000)>>24);_cdcd .Data [_eafcb +1]=byte ((_ggab &0xff0000)>>16);_cdcd .Data [_eafcb +2]=byte ((_ggab &0xff00)>>8);_cdcd .Data [_eafcb +3]=byte (_ggab &0xff);return nil ;};func ConverterFunc (converterFunc func (_fbed _c .Image )(Image ,error ))ColorConverter {return colorConverter {_fedf :converterFunc };
};func _dgge (_eafc Gray ,_agbd NRGBA ,_befa _c .Rectangle ){for _eeffd :=0;_eeffd < _befa .Max .X ;_eeffd ++{for _ffeb :=0;_ffeb < _befa .Max .Y ;_ffeb ++{_bfb :=_bagd (_agbd .NRGBAAt (_eeffd ,_ffeb ));_eafc .SetGray (_eeffd ,_ffeb ,_bfb );};};};func (_efff *NRGBA32 )Bounds ()_c .Rectangle {return _c .Rectangle {Max :_c .Point {X :_efff .Width ,Y :_efff .Height }};
};func (_degd *NRGBA16 )ColorAt (x ,y int )(_d .Color ,error ){return ColorAtNRGBA16 (x ,y ,_degd .Width ,_degd .BytesPerLine ,_degd .Data ,_degd .Alpha ,_degd .Decode );};var _ _c .Image =&Gray16 {};var _ Image =&NRGBA16 {};var _ _c .Image =&Gray4 {};
func _ddgg (_afcgb _d .RGBA )_d .CMYK {_fdd ,_debc ,_bedb ,_eged :=_d .RGBToCMYK (_afcgb .R ,_afcgb .G ,_afcgb .B );return _d .CMYK {C :_fdd ,M :_debc ,Y :_bedb ,K :_eged };};func _cebc ()(_dcd []byte ){_dcd =make ([]byte ,256);for _fbc :=0;_fbc < 256;
_fbc ++{_afga :=byte (_fbc );_dcd [_afga ]=(_afga &0x01)|((_afga &0x04)>>1)|((_afga &0x10)>>2)|((_afga &0x40)>>3)|((_afga &0x02)<<3)|((_afga &0x08)<<2)|((_afga &0x20)<<1)|(_afga &0x80);};return _dcd ;};func (_fgba *Monochrome )Validate ()error {if len (_fgba .Data )!=_fgba .Height *_fgba .BytesPerLine {return ErrInvalidImage ;
};return nil ;};var _ Gray =&Gray4 {};func (_aaf *Monochrome )Set (x ,y int ,c _d .Color ){_eec :=y *_aaf .BytesPerLine +x >>3;if _eec > len (_aaf .Data )-1{return ;};_gaga :=_aaf .ColorModel ().Convert (c ).(_d .Gray );_aaf .setGray (x ,_gaga ,_eec );
};func (_fbg *NRGBA16 )Copy ()Image {return &NRGBA16 {ImageBase :_fbg .copy ()}};func _ffa (_eed _d .CMYK )_d .NRGBA {_dfcb ,_ade ,_fec :=_d .CMYKToRGB (_eed .C ,_eed .M ,_eed .Y ,_eed .K );return _d .NRGBA {R :_dfcb ,G :_ade ,B :_fec ,A :0xff};};func _fbac (_bdegb *Monochrome ,_gbbg ,_fgfaa int ,_abbbb ,_aeac int ,_bbab RasterOperator ){var (_ggea bool ;
_gcbd bool ;_bddb int ;_aebb int ;_afbb int ;_fecd int ;_adgg bool ;_edafc byte ;);_cdf :=8-(_gbbg &7);_dbgc :=_daae [_cdf ];_cead :=_bdegb .BytesPerLine *_fgfaa +(_gbbg >>3);if _abbbb < _cdf {_ggea =true ;_dbgc &=_gggg [8-_cdf +_abbbb ];};if !_ggea {_bddb =(_abbbb -_cdf )>>3;
if _bddb !=0{_gcbd =true ;_aebb =_cead +1;};};_afbb =(_gbbg +_abbbb )&7;if !(_ggea ||_afbb ==0){_adgg =true ;_edafc =_gggg [_afbb ];_fecd =_cead +1+_bddb ;};var _cdbdg ,_bceb int ;switch _bbab {case PixClr :for _cdbdg =0;_cdbdg < _aeac ;_cdbdg ++{_bdegb .Data [_cead ]=_bagb (_bdegb .Data [_cead ],0x0,_dbgc );
_cead +=_bdegb .BytesPerLine ;};if _gcbd {for _cdbdg =0;_cdbdg < _aeac ;_cdbdg ++{for _bceb =0;_bceb < _bddb ;_bceb ++{_bdegb .Data [_aebb +_bceb ]=0x0;};_aebb +=_bdegb .BytesPerLine ;};};if _adgg {for _cdbdg =0;_cdbdg < _aeac ;_cdbdg ++{_bdegb .Data [_fecd ]=_bagb (_bdegb .Data [_fecd ],0x0,_edafc );
_fecd +=_bdegb .BytesPerLine ;};};case PixSet :for _cdbdg =0;_cdbdg < _aeac ;_cdbdg ++{_bdegb .Data [_cead ]=_bagb (_bdegb .Data [_cead ],0xff,_dbgc );_cead +=_bdegb .BytesPerLine ;};if _gcbd {for _cdbdg =0;_cdbdg < _aeac ;_cdbdg ++{for _bceb =0;_bceb < _bddb ;
_bceb ++{_bdegb .Data [_aebb +_bceb ]=0xff;};_aebb +=_bdegb .BytesPerLine ;};};if _adgg {for _cdbdg =0;_cdbdg < _aeac ;_cdbdg ++{_bdegb .Data [_fecd ]=_bagb (_bdegb .Data [_fecd ],0xff,_edafc );_fecd +=_bdegb .BytesPerLine ;};};case PixNotDst :for _cdbdg =0;
_cdbdg < _aeac ;_cdbdg ++{_bdegb .Data [_cead ]=_bagb (_bdegb .Data [_cead ],^_bdegb .Data [_cead ],_dbgc );_cead +=_bdegb .BytesPerLine ;};if _gcbd {for _cdbdg =0;_cdbdg < _aeac ;_cdbdg ++{for _bceb =0;_bceb < _bddb ;_bceb ++{_bdegb .Data [_aebb +_bceb ]=^(_bdegb .Data [_aebb +_bceb ]);
};_aebb +=_bdegb .BytesPerLine ;};};if _adgg {for _cdbdg =0;_cdbdg < _aeac ;_cdbdg ++{_bdegb .Data [_fecd ]=_bagb (_bdegb .Data [_fecd ],^_bdegb .Data [_fecd ],_edafc );_fecd +=_bdegb .BytesPerLine ;};};};};func (_ddb *CMYK32 )Set (x ,y int ,c _d .Color ){_bca :=4*(y *_ddb .Width +x );
if _bca +3>=len (_ddb .Data ){return ;};_fdbc :=_d .CMYKModel .Convert (c ).(_d .CMYK );_ddb .Data [_bca ]=_fdbc .C ;_ddb .Data [_bca +1]=_fdbc .M ;_ddb .Data [_bca +2]=_fdbc .Y ;_ddb .Data [_bca +3]=_fdbc .K ;};func (_dfcbc *ImageBase )MakeAlpha (){_dfcbc .newAlpha ()};
