//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package imageutil ;import (_f "errors";_ff "fmt";_fb "github.com/unidoc/unipdf/v3/internal/bitwise";_g "image";_e "image/color";_aa "image/draw";_a "math";);func (_abc *NRGBA16 )NRGBAAt (x ,y int )_e .NRGBA {_gcee ,_ :=ColorAtNRGBA16 (x ,y ,_abc .Width ,_abc .BytesPerLine ,_abc .Data ,_abc .Alpha ,_abc .Decode );return _gcee ;};var _ Image =&Gray4 {};func (_b *CMYK32 )Base ()*ImageBase {return &_b .ImageBase };func (_ccb *Monochrome )Bounds ()_g .Rectangle {return _g .Rectangle {Max :_g .Point {X :_ccb .Width ,Y :_ccb .Height }};};func (_adcdg *NRGBA64 )Base ()*ImageBase {return &_adcdg .ImageBase };func _bf (_eg _g .Image ,_gag Image ,_fad _g .Rectangle ){for _ded :=0;_ded < _fad .Max .X ;_ded ++{for _dbf :=0;_dbf < _fad .Max .Y ;_dbf ++{_beb :=_eg .At (_ded ,_dbf );_gag .Set (_ded ,_dbf ,_beb );};};};func (_ffgb *Monochrome )At (x ,y int )_e .Color {_afd ,_ :=_ffgb .ColorAt (x ,y );return _afd };func _cfg (_acb Gray ,_fdb CMYK ,_dag _g .Rectangle ){for _bea :=0;_bea < _dag .Max .X ;_bea ++{for _bc :=0;_bc < _dag .Max .Y ;_bc ++{_fa :=_acb .GrayAt (_bea ,_bc );_fdb .SetCMYK (_bea ,_bc ,_gfc (_fa ));};};};var _ Image =&NRGBA16 {};func (_abaa *ImageBase )copy ()ImageBase {_cfgf :=*_abaa ;_cfgf .Data =make ([]byte ,len (_abaa .Data ));copy (_cfgf .Data ,_abaa .Data );return _cfgf ;};func _facb (_fdcf _e .RGBA )_e .NRGBA {switch _fdcf .A {case 0xff:return _e .NRGBA {R :_fdcf .R ,G :_fdcf .G ,B :_fdcf .B ,A :0xff};case 0x00:return _e .NRGBA {};default:_fg ,_ggb ,_bdd ,_ggg :=_fdcf .RGBA ();_fg =(_fg *0xffff)/_ggg ;_ggb =(_ggb *0xffff)/_ggg ;_bdd =(_bdd *0xffff)/_ggg ;return _e .NRGBA {R :uint8 (_fg >>8),G :uint8 (_ggb >>8),B :uint8 (_bdd >>8),A :uint8 (_ggg >>8)};};};func _bcfa (_baec CMYK ,_bdde NRGBA ,_ebeg _g .Rectangle ){for _dga :=0;_dga < _ebeg .Max .X ;_dga ++{for _fcaf :=0;_fcaf < _ebeg .Max .Y ;_fcaf ++{_dead :=_baec .CMYKAt (_dga ,_fcaf );_bdde .SetNRGBA (_dga ,_fcaf ,_beg (_dead ));};};};type Monochrome struct{ImageBase ;ModelThreshold uint8 ;};func _fda (_efe ,_acg Gray ,_cfeb _g .Rectangle ){for _geg :=0;_geg < _cfeb .Max .X ;_geg ++{for _aac :=0;_aac < _cfeb .Max .Y ;_aac ++{_acg .SetGray (_geg ,_aac ,_efe .GrayAt (_geg ,_aac ));};};};func IsGrayImgBlackAndWhite (i *_g .Gray )bool {return _fdbe (i )};func (_bag *Monochrome )clearBit (_fed ,_gdaa int ){_bag .Data [_fed ]&=^(0x80>>uint (_gdaa &7))};func (_ecfe *Gray8 )ColorAt (x ,y int )(_e .Color ,error ){return ColorAtGray8BPC (x ,y ,_ecfe .BytesPerLine ,_ecfe .Data ,_ecfe .Decode );};func (_cddf *NRGBA32 )ColorModel ()_e .Model {return _e .NRGBAModel };var _ Gray =&Gray16 {};func (_gef *NRGBA32 )ColorAt (x ,y int )(_e .Color ,error ){return ColorAtNRGBA32 (x ,y ,_gef .Width ,_gef .Data ,_gef .Alpha ,_gef .Decode );};func (_ea *CMYK32 )Copy ()Image {return &CMYK32 {ImageBase :_ea .copy ()}};func (_bbf *Monochrome )ColorModel ()_e .Model {return MonochromeModel (_bbf .ModelThreshold )};func (_bg *CMYK32 )Validate ()error {if len (_bg .Data )!=4*_bg .Width *_bg .Height {return _f .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");};return nil ;};func (_caa *ImageBase )MakeAlpha (){_caa .newAlpha ()};func ColorAt (x ,y ,width ,bitsPerColor ,colorComponents ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_e .Color ,error ){switch colorComponents {case 1:return ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine ,data ,decode );case 3:return ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor ,data ,alpha ,decode );case 4:return ColorAtCMYK (x ,y ,width ,data ,decode );default:return nil ,_ff .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0063o\u006c\u006f\u0072\u0020\u0063\u006f\u006dp\u006f\u006e\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0064",colorComponents );};};func ColorAtNRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_e .NRGBA ,error ){_abdc :=y *width +x ;_afb :=3*_abdc ;if _afb +2>=len (data ){return _e .NRGBA {},_ff .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_ega :=uint8 (0xff);if alpha !=nil &&len (alpha )> _abdc {_ega =alpha [_abdc ];};_fee ,_aecc ,_cgg :=data [_afb ],data [_afb +1],data [_afb +2];if len (decode )==6{_fee =uint8 (uint32 (LinearInterpolate (float64 (_fee ),0,255,decode [0],decode [1]))&0xff);_aecc =uint8 (uint32 (LinearInterpolate (float64 (_aecc ),0,255,decode [2],decode [3]))&0xff);_cgg =uint8 (uint32 (LinearInterpolate (float64 (_cgg ),0,255,decode [4],decode [5]))&0xff);};return _e .NRGBA {R :_fee ,G :_aecc ,B :_cgg ,A :_ega },nil ;};func ImgToGray (i _g .Image )*_g .Gray {if _gage ,_cgb :=i .(*_g .Gray );_cgb {return _gage ;};_ccea :=i .Bounds ();_aag :=_g .NewGray (_ccea );for _baa :=0;_baa < _ccea .Max .X ;_baa ++{for _cfeca :=0;_cfeca < _ccea .Max .Y ;_cfeca ++{_fcgg :=i .At (_baa ,_cfeca );_aag .Set (_baa ,_cfeca ,_fcgg );};};return _aag ;};func (_agff *NRGBA32 )NRGBAAt (x ,y int )_e .NRGBA {_dgeag ,_ :=ColorAtNRGBA32 (x ,y ,_agff .Width ,_agff .Data ,_agff .Alpha ,_agff .Decode );return _dgeag ;};func _ec (_eag NRGBA ,_ca CMYK ,_eec _g .Rectangle ){for _dc :=0;_dc < _eec .Max .X ;_dc ++{for _gfd :=0;_gfd < _eec .Max .Y ;_gfd ++{_be :=_eag .NRGBAAt (_dc ,_gfd );_ca .SetCMYK (_dc ,_gfd ,_ae (_be ));};};};type Gray8 struct{ImageBase };func (_dbd *Gray16 )At (x ,y int )_e .Color {_ege ,_ :=_dbd .ColorAt (x ,y );return _ege };func _ddc (_adga _g .Image ,_bae Image ,_bce _g .Rectangle ){switch _cfda :=_adga .(type ){case Gray :_fda (_cfda ,_bae .(Gray ),_bce );case NRGBA :_bgcg (_cfda ,_bae .(Gray ),_bce );case CMYK :_cgf (_cfda ,_bae .(Gray ),_bce );case RGBA :_cagaa (_cfda ,_bae .(Gray ),_bce );default:_bf (_adga ,_bae .(Image ),_bce );};};func _edb (_edd _e .CMYK )_e .Gray {_bee ,_cfe ,_daa :=_e .CMYKToRGB (_edd .C ,_edd .M ,_edd .Y ,_edd .K );_fc :=(19595*uint32 (_bee )+38470*uint32 (_cfe )+7471*uint32 (_daa )+1<<7)>>16;return _e .Gray {Y :uint8 (_fc )};};func (_gca *Monochrome )setGray (_cdb int ,_eea _e .Gray ,_feb int ){if _eea .Y ==0{_gca .clearBit (_feb ,_cdb );}else {_gca .setBit (_feb ,_cdb );};};func _bcd (_cbfa _e .Gray ,_fae monochromeModel )_e .Gray {if _cbfa .Y > uint8 (_fae ){return _e .Gray {Y :_a .MaxUint8 };};return _e .Gray {};};func (_afg *Monochrome )SetGray (x ,y int ,g _e .Gray ){_beec :=y *_afg .BytesPerLine +x >>3;if _beec > len (_afg .Data )-1{return ;};g =_bcd (g ,monochromeModel (_afg .ModelThreshold ));_afg .setGray (x ,g ,_beec );};func _ecbg (_fcb _g .Image )(Image ,error ){if _bgg ,_caga :=_fcb .(*Gray8 );_caga {return _bgg .Copy (),nil ;};_gab :=_fcb .Bounds ();_gadb ,_aba :=NewImage (_gab .Max .X ,_gab .Max .Y ,8,1,nil ,nil ,nil );if _aba !=nil {return nil ,_aba ;};_ddc (_fcb ,_gadb ,_gab );return _gadb ,nil ;};func (_gcdd *ImageBase )GetAlpha ()[]byte {return _gcdd .Alpha };func NewImageBase (width int ,height int ,bitsPerComponent int ,colorComponents int ,data []byte ,alpha []byte ,decode []float64 )ImageBase {_efbge :=ImageBase {Width :width ,Height :height ,BitsPerComponent :bitsPerComponent ,ColorComponents :colorComponents ,Data :data ,Alpha :alpha ,Decode :decode ,BytesPerLine :BytesPerLine (width ,bitsPerComponent ,colorComponents )};if data ==nil {_efbge .Data =make ([]byte ,height *_efbge .BytesPerLine );};return _efbge ;};func init (){_agec ()};func FromGoImage (i _g .Image )(Image ,error ){switch _bgcfb :=i .(type ){case Image :return _bgcfb .Copy (),nil ;case Gray :return GrayConverter .Convert (i );case CMYK :return CMYKConverter .Convert (i );default:return NRGBAConverter .Convert (i );};};type NRGBA32 struct{ImageBase };func (_cea *Gray2 )GrayAt (x ,y int )_e .Gray {_bfcf ,_ :=ColorAtGray2BPC (x ,y ,_cea .BytesPerLine ,_cea .Data ,_cea .Decode );return _bfcf ;};func (_bgag *NRGBA16 )Copy ()Image {return &NRGBA16 {ImageBase :_bgag .copy ()}};func _beg (_cg _e .CMYK )_e .NRGBA {_dfbb ,_fac ,_dgg :=_e .CMYKToRGB (_cg .C ,_cg .M ,_cg .Y ,_cg .K );return _e .NRGBA {R :_dfbb ,G :_fac ,B :_dgg ,A :0xff};};func (_dgc *Gray8 )SetGray (x ,y int ,g _e .Gray ){_edc :=y *_dgc .BytesPerLine +x ;if _edc > len (_dgc .Data )-1{return ;};_dgc .Data [_edc ]=g .Y ;};func ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor int ,data ,alpha []byte ,decode []float64 )(_e .Color ,error ){switch bitsPerColor {case 4:return ColorAtNRGBA16 (x ,y ,width ,bytesPerLine ,data ,alpha ,decode );case 8:return ColorAtNRGBA32 (x ,y ,width ,data ,alpha ,decode );case 16:return ColorAtNRGBA64 (x ,y ,width ,data ,alpha ,decode );default:return nil ,_ff .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0067\u0062\u0020b\u0069\u0074\u0073\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0061\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );};};func (_gbdf *NRGBA64 )Validate ()error {if len (_gbdf .Data )!=3*2*_gbdf .Width *_gbdf .Height {return _f .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");};return nil ;};func (_gece *NRGBA32 )Copy ()Image {return &NRGBA32 {ImageBase :_gece .copy ()}};var _ NRGBA =&NRGBA16 {};func (_adb *monochromeThresholdConverter )Convert (img _g .Image )(Image ,error ){if _adcd ,_ebf :=img .(*Monochrome );_ebf {return _adcd .Copy (),nil ;};_dda :=img .Bounds ();_cbf ,_gac :=NewImage (_dda .Max .X ,_dda .Max .Y ,1,1,nil ,nil ,nil );if _gac !=nil {return nil ,_gac ;};_cbf .(*Monochrome ).ModelThreshold =_adb .Threshold ;for _cbd :=0;_cbd < _dda .Max .X ;_cbd ++{for _abb :=0;_abb < _dda .Max .Y ;_abb ++{_edg :=img .At (_cbd ,_abb );_cbf .Set (_cbd ,_abb ,_edg );};};return _cbf ,nil ;};func (_gcc *Gray4 )ColorModel ()_e .Model {return Gray4Model };func (_eaba *Gray2 )ColorAt (x ,y int )(_e .Color ,error ){return ColorAtGray2BPC (x ,y ,_eaba .BytesPerLine ,_eaba .Data ,_eaba .Decode );};func NewImage (width ,height ,bitsPerComponent ,colorComponents int ,data ,alpha []byte ,decode []float64 )(Image ,error ){_agga :=NewImageBase (width ,height ,bitsPerComponent ,colorComponents ,data ,alpha ,decode );var _bfg Image ;switch colorComponents {case 1:switch bitsPerComponent {case 1:_bfg =&Monochrome {ImageBase :_agga ,ModelThreshold :0x0f};case 2:_bfg =&Gray2 {ImageBase :_agga };case 4:_bfg =&Gray4 {ImageBase :_agga };case 8:_bfg =&Gray8 {ImageBase :_agga };case 16:_bfg =&Gray16 {ImageBase :_agga };};case 3:switch bitsPerComponent {case 4:_bfg =&NRGBA16 {ImageBase :_agga };case 8:_bfg =&NRGBA32 {ImageBase :_agga };case 16:_bfg =&NRGBA64 {ImageBase :_agga };};case 4:_bfg =&CMYK32 {ImageBase :_agga };};if _bfg ==nil {return nil ,ErrInvalidImage ;};return _bfg ,nil ;};func (_cfd *Monochrome )Validate ()error {if len (_cfd .Data )!=_cfd .Height *_cfd .BytesPerLine {return ErrInvalidImage ;};return nil ;};var ErrInvalidImage =_f .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");func BytesPerLine (width ,bitsPerComponent ,colorComponents int )int {return ((width *bitsPerComponent )*colorComponents +7)>>3;};type CMYK32 struct{ImageBase };func MonochromeThresholdConverter (threshold uint8 )ColorConverter {return &monochromeThresholdConverter {Threshold :threshold };};type monochromeModel uint8 ;func (_gdf *Gray16 )Set (x ,y int ,c _e .Color ){_cefd :=(y *_gdf .BytesPerLine /2+x )*2;if _cefd +1>=len (_gdf .Data ){return ;};_acae :=_e .Gray16Model .Convert (c ).(_e .Gray16 );_gdf .Data [_cefd ],_gdf .Data [_cefd +1]=uint8 (_acae .Y >>8),uint8 (_acae .Y &0xff);};func (_acbd *Gray16 )Copy ()Image {return &Gray16 {ImageBase :_acbd .copy ()}};func (_aafcc *Gray8 )Histogram ()(_cedb [256]int ){for _bgfc :=0;_bgfc < len (_aafcc .Data );_bgfc ++{_cedb [_aafcc .Data [_bgfc ]]++;};return _cedb ;};func GetConverter (bitsPerComponent ,colorComponents int )(ColorConverter ,error ){switch colorComponents {case 1:switch bitsPerComponent {case 1:return MonochromeConverter ,nil ;case 2:return Gray2Converter ,nil ;case 4:return Gray4Converter ,nil ;case 8:return GrayConverter ,nil ;case 16:return Gray16Converter ,nil ;};case 3:switch bitsPerComponent {case 4:return NRGBA16Converter ,nil ;case 8:return NRGBAConverter ,nil ;case 16:return NRGBA64Converter ,nil ;};case 4:return CMYKConverter ,nil ;};return nil ,_ff .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0043o\u006e\u0076\u0065\u0072\u0074\u0065\u0072\u0020\u0070\u0061\u0072\u0061\u006d\u0065t\u0065\u0072\u0073\u002e\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003a\u0020\u0025\u0064\u002c\u0020\u0043\u006f\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006et\u0073\u003a \u0025\u0064",bitsPerComponent ,colorComponents );};func (_ada monochromeModel )Convert (c _e .Color )_e .Color {_cfea :=_e .GrayModel .Convert (c ).(_e .Gray );return _bcd (_cfea ,_ada );};type Gray4 struct{ImageBase };func (_fgd *Gray16 )Histogram ()(_gbda [256]int ){for _fdcg :=0;_fdcg < _fgd .Width ;_fdcg ++{for _bgcf :=0;_bgcf < _fgd .Height ;_bgcf ++{_gbda [_fgd .GrayAt (_fdcg ,_bgcf ).Y ]++;};};return _gbda ;};var _ Gray =&Gray2 {};func (_aeg *NRGBA16 )At (x ,y int )_e .Color {_ecg ,_ :=_aeg .ColorAt (x ,y );return _ecg };func ColorAtGray1BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_e .Gray ,error ){_ceb :=y *bytesPerLine +x >>3;if _ceb >=len (data ){return _e .Gray {},_ff .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_dec :=data [_ceb ]>>uint (7-(x &7))&1;if len (decode )==2{_dec =uint8 (LinearInterpolate (float64 (_dec ),0.0,1.0,decode [0],decode [1]))&1;};return _e .Gray {Y :_dec *255},nil ;};var _ _g .Image =&Gray16 {};type RGBA interface{RGBAAt (_dfgc ,_dagb int )_e .RGBA ;SetRGBA (_cfebf ,_egca int ,_ddf _e .RGBA );};func (_bad *Gray4 )Validate ()error {if len (_bad .Data )!=_bad .Height *_bad .BytesPerLine {return ErrInvalidImage ;};return nil ;};func _ddad (_abdg uint8 )bool {if _abdg ==0||_abdg ==255{return true ;};return false ;};var (Gray2Model =_e .ModelFunc (_eaf );Gray4Model =_e .ModelFunc (_bece );NRGBA16Model =_e .ModelFunc (_acgb ););func LinearInterpolate (x ,xmin ,xmax ,ymin ,ymax float64 )float64 {if _a .Abs (xmax -xmin )< 0.000001{return ymin ;};_bge :=ymin +(x -xmin )*(ymax -ymin )/(xmax -xmin );return _bge ;};func ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine int ,data []byte ,decode []float64 )(_e .Color ,error ){switch bitsPerColor {case 1:return ColorAtGray1BPC (x ,y ,bytesPerLine ,data ,decode );case 2:return ColorAtGray2BPC (x ,y ,bytesPerLine ,data ,decode );case 4:return ColorAtGray4BPC (x ,y ,bytesPerLine ,data ,decode );case 8:return ColorAtGray8BPC (x ,y ,bytesPerLine ,data ,decode );case 16:return ColorAtGray16BPC (x ,y ,bytesPerLine ,data ,decode );default:return nil ,_ff .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0067\u0072\u0061\u0079\u0020\u0073c\u0061\u006c\u0065\u0020\u0062\u0069\u0074s\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020a\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );};};func _fef (_dbff _g .Image ,_dbca Image ,_ceba _g .Rectangle ){if _ecde ,_bbee :=_dbff .(SMasker );_bbee &&_ecde .HasAlpha (){_dbca .(SMasker ).MakeAlpha ();};switch _fbbe :=_dbff .(type ){case Gray :_gdg (_fbbe ,_dbca .(NRGBA ),_ceba );case NRGBA :_caf (_fbbe ,_dbca .(NRGBA ),_ceba );case CMYK :_bcfa (_fbbe ,_dbca .(NRGBA ),_ceba );case RGBA :_fceg (_fbbe ,_dbca .(NRGBA ),_ceba );default:_bf (_dbff ,_dbca ,_ceba );};};func _fdbe (_gcea *_g .Gray )bool {for _cagaag :=0;_cagaag < len (_gcea .Pix );_cagaag ++{if !_ddad (_gcea .Pix [_cagaag ]){return false ;};};return true ;};func (_fcga *Gray8 )GrayAt (x ,y int )_e .Gray {_ccfa ,_ :=ColorAtGray8BPC (x ,y ,_fcga .BytesPerLine ,_fcga .Data ,_fcga .Decode );return _ccfa ;};func (_bcc *NRGBA64 )ColorModel ()_e .Model {return _e .NRGBA64Model };func (_abbg *Gray4 )Base ()*ImageBase {return &_abbg .ImageBase };func (_adf *NRGBA32 )Validate ()error {if len (_adf .Data )!=3*_adf .Width *_adf .Height {return _f .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");};return nil ;};func (_acf *Gray2 )At (x ,y int )_e .Color {_fedc ,_ :=_acf .ColorAt (x ,y );return _fedc };type ImageBase struct{Width ,Height int ;BitsPerComponent ,ColorComponents int ;Data ,Alpha []byte ;Decode []float64 ;BytesPerLine int ;};var _ Image =&Gray2 {};func (_ecag *Gray2 )Copy ()Image {return &Gray2 {ImageBase :_ecag .copy ()}};func (_fagd *ImageBase )newAlpha (){_bgd :=BytesPerLine (_fagd .Width ,_fagd .BitsPerComponent ,1);_fagd .Alpha =make ([]byte ,_fagd .Height *_bgd );};func MonochromeModel (threshold uint8 )_e .Model {return monochromeModel (threshold )};func _ecf (_ceg _g .Image )(Image ,error ){if _bafc ,_dge :=_ceg .(*Monochrome );_dge {return _bafc ,nil ;};_dff ,_cfeg :=_ceg .(Gray );if !_cfeg {_dd ,_gbe :=GrayConverter .Convert (_ceg );if _gbe !=nil {return nil ,_gbe ;};_dff =_dd .(Gray );};_geb :=_ceg .Bounds ();_bda ,_dfg :=NewImage (_geb .Max .X ,_geb .Max .Y ,1,1,nil ,nil ,nil );if _dfg !=nil {return nil ,_dfg ;};_ccf :=_bda .(*Monochrome );_ggbd :=AutoThresholdTriangle (GrayHistogram (_dff ));for _dfc :=0;_dfc < _geb .Max .X ;_dfc ++{for _ggf :=0;_ggf < _geb .Max .Y ;_ggf ++{_ged :=_bcd (_dff .GrayAt (_dfc ,_ggf ),monochromeModel (_ggbd ));_ccf .SetGray (_dfc ,_ggf ,_ged );};};return _bda ,nil ;};func (_fd *CMYK32 )At (x ,y int )_e .Color {_df ,_ :=_fd .ColorAt (x ,y );return _df };func (_gecf *Gray8 )ColorModel ()_e .Model {return _e .GrayModel };func (_ga *CMYK32 )ColorAt (x ,y int )(_e .Color ,error ){return ColorAtCMYK (x ,y ,_ga .Width ,_ga .Data ,_ga .Decode );};func (_cc *CMYK32 )Bounds ()_g .Rectangle {return _g .Rectangle {Max :_g .Point {X :_cc .Width ,Y :_cc .Height }};};var _ Image =&CMYK32 {};func (_gfca *NRGBA32 )Set (x ,y int ,c _e .Color ){_gcec :=y *_gfca .Width +x ;_aaa :=3*_gcec ;if _aaa +2>=len (_gfca .Data ){return ;};_caae :=_e .NRGBAModel .Convert (c ).(_e .NRGBA );_gfca .setRGBA (_gcec ,_caae );};func (_efba *NRGBA16 )ColorAt (x ,y int )(_e .Color ,error ){return ColorAtNRGBA16 (x ,y ,_efba .Width ,_efba .BytesPerLine ,_efba .Data ,_efba .Alpha ,_efba .Decode );};func (_bfb colorConverter )Convert (src _g .Image )(Image ,error ){return _bfb ._ce (src )};func (_efbf *Gray4 )GrayAt (x ,y int )_e .Gray {_fbf ,_ :=ColorAtGray4BPC (x ,y ,_efbf .BytesPerLine ,_efbf .Data ,_efbf .Decode );return _fbf ;};func (_ef *Monochrome )setBit (_fga ,_fge int ){_ef .Data [_fga ]|=0x80>>uint (_fge &7)};func _caf (_dcdb ,_ebce NRGBA ,_ede _g .Rectangle ){for _fcea :=0;_fcea < _ede .Max .X ;_fcea ++{for _aead :=0;_aead < _ede .Max .Y ;_aead ++{_ebce .SetNRGBA (_fcea ,_aead ,_dcdb .NRGBAAt (_fcea ,_aead ));};};};func (_ebg *Gray4 )Bounds ()_g .Rectangle {return _g .Rectangle {Max :_g .Point {X :_ebg .Width ,Y :_ebg .Height }};};func (_eac *Gray8 )Set (x ,y int ,c _e .Color ){_fea :=y *_eac .BytesPerLine +x ;if _fea > len (_eac .Data )-1{return ;};_gfde :=_e .GrayModel .Convert (c );_eac .Data [_fea ]=_gfde .(_e .Gray ).Y ;};func (_gcfe *NRGBA16 )Set (x ,y int ,c _e .Color ){_dcda :=y *_gcfe .BytesPerLine +x *3/2;if _dcda +1>=len (_gcfe .Data ){return ;};_cab :=NRGBA16Model .Convert (c ).(_e .NRGBA );_gcfe .setNRGBA (x ,y ,_dcda ,_cab );};func _ggcf (_fdcfe *_g .Gray16 ,_fgbe uint8 )*_g .Gray {_fcd :=_fdcfe .Bounds ();_bbeeb :=_g .NewGray (_fcd );for _acdg :=0;_acdg < _fcd .Dx ();_acdg ++{for _dcce :=0;_dcce < _fcd .Dy ();_dcce ++{_ffc :=_fdcfe .Gray16At (_acdg ,_dcce );_bbeeb .SetGray (_acdg ,_dcce ,_e .Gray {Y :_bac (uint8 (_ffc .Y /256),_fgbe )});};};return _bbeeb ;};func (_bfbf *Gray2 )Bounds ()_g .Rectangle {return _g .Rectangle {Max :_g .Point {X :_bfbf .Width ,Y :_bfbf .Height }};};type Image interface{_aa .Image ;Base ()*ImageBase ;Copy ()Image ;Pix ()[]byte ;ColorAt (_cfac ,_agfb int )(_e .Color ,error );Validate ()error ;};func (_abda *NRGBA64 )At (x ,y int )_e .Color {_bcca ,_ :=_abda .ColorAt (x ,y );return _bcca };var _ _g .Image =&NRGBA64 {};var _ Image =&Monochrome {};type Gray16 struct{ImageBase };var _ Image =&Gray16 {};func _eaf (_efb _e .Color )_e .Color {_dca :=_e .GrayModel .Convert (_efb ).(_e .Gray );return _fgb (_dca )};var _ Image =&NRGBA32 {};func (_daae *Monochrome )Base ()*ImageBase {return &_daae .ImageBase };type ColorConverter interface{Convert (_cfc _g .Image )(Image ,error );};func (_agdf *Gray16 )Bounds ()_g .Rectangle {return _g .Rectangle {Max :_g .Point {X :_agdf .Width ,Y :_agdf .Height }};};func (_gcd *Gray4 )SetGray (x ,y int ,g _e .Gray ){if x >=_gcd .Width ||y >=_gcd .Height {return ;};g =_ecd (g );_gcd .setGray (x ,y ,g );};func (_fcf *Gray8 )Copy ()Image {return &Gray8 {ImageBase :_fcf .copy ()}};func _fcg (_bec _e .RGBA )_e .Gray {_fdc :=(19595*uint32 (_bec .R )+38470*uint32 (_bec .G )+7471*uint32 (_bec .B )+1<<7)>>16;return _e .Gray {Y :uint8 (_fdc )};};func (_bead *Gray16 )ColorModel ()_e .Model {return _e .Gray16Model };func _bcb (_gad RGBA ,_fdd CMYK ,_ecc _g .Rectangle ){for _dee :=0;_dee < _ecc .Max .X ;_dee ++{for _gd :=0;_gd < _ecc .Max .Y ;_gd ++{_ed :=_gad .RGBAAt (_dee ,_gd );_fdd .SetCMYK (_dee ,_gd ,_fce (_ed ));};};};func ColorAtGray8BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_e .Gray ,error ){_cbb :=y *bytesPerLine +x ;if _cbb >=len (data ){return _e .Gray {},_ff .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_ddab :=data [_cbb ];if len (decode )==2{_ddab =uint8 (uint32 (LinearInterpolate (float64 (_ddab ),0,255,decode [0],decode [1]))&0xff);};return _e .Gray {Y :_ddab },nil ;};func (_abad *NRGBA64 )Set (x ,y int ,c _e .Color ){_cbdf :=(y *_abad .Width +x )*2;_cddd :=_cbdf *3;if _cddd +5>=len (_abad .Data ){return ;};_gbde :=_e .NRGBA64Model .Convert (c ).(_e .NRGBA64 );_abad .setNRGBA64 (_cddd ,_gbde ,_cbdf );};type NRGBA64 struct{ImageBase };func (_bbeg *Gray4 )setGray (_bba int ,_eecg int ,_fadfg _e .Gray ){_gga :=_eecg *_bbeg .BytesPerLine ;_gba :=_gga +(_bba >>1);if _gba >=len (_bbeg .Data ){return ;};_gbba :=_fadfg .Y >>4;_bbeg .Data [_gba ]=(_bbeg .Data [_gba ]&(^(0xf0>>uint (4*(_bba &1)))))|(_gbba <<uint (4-4*(_bba &1)));};var _ NRGBA =&NRGBA32 {};func _agf (_fgbf _g .Image )(Image ,error ){if _dgf ,_ccbd :=_fgbf .(*Gray16 );_ccbd {return _dgf .Copy (),nil ;};_fbag :=_fgbf .Bounds ();_fbda ,_ffb :=NewImage (_fbag .Max .X ,_fbag .Max .Y ,16,1,nil ,nil ,nil );if _ffb !=nil {return nil ,_ffb ;};_ddc (_fgbf ,_fbda ,_fbag );return _fbda ,nil ;};func (_bbef *NRGBA64 )setNRGBA64 (_dcea int ,_fbce _e .NRGBA64 ,_bbd int ){_bbef .Data [_dcea ]=uint8 (_fbce .R >>8);_bbef .Data [_dcea +1]=uint8 (_fbce .R &0xff);_bbef .Data [_dcea +2]=uint8 (_fbce .G >>8);_bbef .Data [_dcea +3]=uint8 (_fbce .G &0xff);_bbef .Data [_dcea +4]=uint8 (_fbce .B >>8);_bbef .Data [_dcea +5]=uint8 (_fbce .B &0xff);if _bbd +1< len (_bbef .Alpha ){_bbef .Alpha [_bbd ]=uint8 (_fbce .A >>8);_bbef .Alpha [_bbd +1]=uint8 (_fbce .A &0xff);};};func (_afcd *Gray16 )ColorAt (x ,y int )(_e .Color ,error ){return ColorAtGray16BPC (x ,y ,_afcd .BytesPerLine ,_afcd .Data ,_afcd .Decode );};func ColorAtNRGBA64 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_e .NRGBA64 ,error ){_fedf :=(y *width +x )*2;_acgd :=_fedf *3;if _acgd +5>=len (data ){return _e .NRGBA64 {},_ff .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};const _ggc =0xffff;_eada :=uint16 (_ggc );if alpha !=nil &&len (alpha )> _fedf +1{_eada =uint16 (alpha [_fedf ])<<8|uint16 (alpha [_fedf +1]);};_ade :=uint16 (data [_acgd ])<<8|uint16 (data [_acgd +1]);_ceag :=uint16 (data [_acgd +2])<<8|uint16 (data [_acgd +3]);_bfcg :=uint16 (data [_acgd +4])<<8|uint16 (data [_acgd +5]);if len (decode )==6{_ade =uint16 (uint64 (LinearInterpolate (float64 (_ade ),0,65535,decode [0],decode [1]))&_ggc );_ceag =uint16 (uint64 (LinearInterpolate (float64 (_ceag ),0,65535,decode [2],decode [3]))&_ggc );_bfcg =uint16 (uint64 (LinearInterpolate (float64 (_bfcg ),0,65535,decode [4],decode [5]))&_ggc );};return _e .NRGBA64 {R :_ade ,G :_ceag ,B :_bfcg ,A :_eada },nil ;};func (_ceab *NRGBA32 )SetNRGBA (x ,y int ,c _e .NRGBA ){_egfg :=y *_ceab .Width +x ;_daabf :=3*_egfg ;if _daabf +2>=len (_ceab .Data ){return ;};_ceab .setRGBA (_egfg ,c );return ;};func _bgcg (_feag NRGBA ,_ggfd Gray ,_fdaa _g .Rectangle ){for _gfff :=0;_gfff < _fdaa .Max .X ;_gfff ++{for _dgea :=0;_dgea < _fdaa .Max .Y ;_dgea ++{_cee :=_gb (_feag .NRGBAAt (_gfff ,_dgea ));_ggfd .SetGray (_gfff ,_dgea ,_cee );};};};func _egc (_af _e .Gray )_e .NRGBA {return _e .NRGBA {R :_af .Y ,G :_af .Y ,B :_af .Y ,A :0xff}};func _dbdb (_egfe _g .Image ,_cggf uint8 )*_g .Gray {_egdc :=_egfe .Bounds ();_fdaag :=_g .NewGray (_egdc );var (_bgbe _e .Color ;_aagd _e .Gray ;);for _eeca :=0;_eeca < _egdc .Max .X ;_eeca ++{for _dece :=0;_dece < _egdc .Max .Y ;_dece ++{_bgbe =_egfe .At (_eeca ,_dece );_fdaag .Set (_eeca ,_dece ,_bgbe );_aagd =_fdaag .GrayAt (_eeca ,_dece );_fdaag .SetGray (_eeca ,_dece ,_e .Gray {Y :_bac (_aagd .Y ,_cggf )});};};return _fdaag ;};func (_gadc *Gray16 )SetGray (x ,y int ,g _e .Gray ){_ffa :=(y *_gadc .BytesPerLine /2+x )*2;if _ffa +1>=len (_gadc .Data ){return ;};_gadc .Data [_ffa ]=g .Y ;_gadc .Data [_ffa +1]=g .Y ;};func ColorAtNRGBA16 (x ,y ,width ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_e .NRGBA ,error ){_eedae :=y *bytesPerLine +x *3/2;if _eedae +1>=len (data ){return _e .NRGBA {},_ffd (x ,y );};const (_acbc =0xf;_dddba =uint8 (0xff););_fdcc :=_dddba ;if alpha !=nil {_eff :=y *BytesPerLine (width ,4,1);if _eff < len (alpha ){if x %2==0{_fdcc =(alpha [_eff ]>>uint (4))&_acbc ;}else {_fdcc =alpha [_eff ]&_acbc ;};_fdcc |=_fdcc <<4;};};var _dcc ,_dab ,_egg uint8 ;if x *3%2==0{_dcc =(data [_eedae ]>>uint (4))&_acbc ;_dab =data [_eedae ]&_acbc ;_egg =(data [_eedae +1]>>uint (4))&_acbc ;}else {_dcc =data [_eedae ]&_acbc ;_dab =(data [_eedae +1]>>uint (4))&_acbc ;_egg =data [_eedae +1]&_acbc ;};if len (decode )==6{_dcc =uint8 (uint32 (LinearInterpolate (float64 (_dcc ),0,15,decode [0],decode [1]))&0xf);_dab =uint8 (uint32 (LinearInterpolate (float64 (_dab ),0,15,decode [2],decode [3]))&0xf);_egg =uint8 (uint32 (LinearInterpolate (float64 (_egg ),0,15,decode [4],decode [5]))&0xf);};return _e .NRGBA {R :(_dcc <<4)|(_dcc &0xf),G :(_dab <<4)|(_dab &0xf),B :(_egg <<4)|(_egg &0xf),A :_fdcc },nil ;};func (_bbe *Gray2 )Base ()*ImageBase {return &_bbe .ImageBase };var _ _g .Image =&NRGBA16 {};func (_dcd *Monochrome )Histogram ()(_fbe [256]int ){for _ ,_cfcb :=range _dcd .Data {_fbe [0xff]+=int (_bef [_dcd .Data [_cfcb ]]);};return _fbe ;};func _agec (){for _aee :=0;_aee < 256;_aee ++{_bef [_aee ]=uint8 (_aee &0x1)+(uint8 (_aee >>1)&0x1)+(uint8 (_aee >>2)&0x1)+(uint8 (_aee >>3)&0x1)+(uint8 (_aee >>4)&0x1)+(uint8 (_aee >>5)&0x1)+(uint8 (_aee >>6)&0x1)+(uint8 (_aee >>7)&0x1);};};func (_gadcc *NRGBA16 )setNRGBA (_feab ,_edad ,_feg int ,_beda _e .NRGBA ){if _feab *3%2==0{_gadcc .Data [_feg ]=(_beda .R >>4)<<4|(_beda .G >>4);_gadcc .Data [_feg +1]=(_beda .B >>4)<<4|(_gadcc .Data [_feg +1]&0xf);}else {_gadcc .Data [_feg ]=(_gadcc .Data [_feg ]&0xf0)|(_beda .R >>4);_gadcc .Data [_feg +1]=(_beda .G >>4)<<4|(_beda .B >>4);};if _gadcc .Alpha !=nil {_gbec :=_edad *BytesPerLine (_gadcc .Width ,4,1);if _gbec < len (_gadcc .Alpha ){if _feab %2==0{_gadcc .Alpha [_gbec ]=(_beda .A >>uint (4))<<uint (4)|(_gadcc .Alpha [_feg ]&0xf);}else {_gadcc .Alpha [_gbec ]=(_gadcc .Alpha [_gbec ]&0xf0)|(_beda .A >>uint (4));};};};};func (_ddb *NRGBA16 )Base ()*ImageBase {return &_ddb .ImageBase };func (_effd *NRGBA64 )ColorAt (x ,y int )(_e .Color ,error ){return ColorAtNRGBA64 (x ,y ,_effd .Width ,_effd .Data ,_effd .Alpha ,_effd .Decode );};var _ _g .Image =&Gray8 {};func (_aaf *CMYK32 )ColorModel ()_e .Model {return _e .CMYKModel };func _gfc (_afe _e .Gray )_e .CMYK {return _e .CMYK {K :0xff-_afe .Y }};func _ae (_cfcf _e .NRGBA )_e .CMYK {_eadb ,_cb ,_adc ,_ :=_cfcf .RGBA ();_ecb ,_agc ,_eca ,_acd :=_e .RGBToCMYK (uint8 (_eadb >>8),uint8 (_cb >>8),uint8 (_adc >>8));return _e .CMYK {C :_ecb ,M :_agc ,Y :_eca ,K :_acd };};func (_fcgf *NRGBA32 )Bounds ()_g .Rectangle {return _g .Rectangle {Max :_g .Point {X :_fcgf .Width ,Y :_fcgf .Height }};};func (_fgf *ImageBase )HasAlpha ()bool {return _fgf .Alpha !=nil };type NRGBA16 struct{ImageBase };func _cgf (_gdb CMYK ,_daf Gray ,_agcf _g .Rectangle ){for _bded :=0;_bded < _agcf .Max .X ;_bded ++{for _gcb :=0;_gcb < _agcf .Max .Y ;_gcb ++{_bggf :=_edb (_gdb .CMYKAt (_bded ,_gcb ));_daf .SetGray (_bded ,_gcb ,_bggf );};};};func (_fadf *Gray2 )SetGray (x ,y int ,gray _e .Gray ){_gfdb :=_fgb (gray );_fgc :=y *_fadf .BytesPerLine ;_aad :=_fgc +(x >>2);if _aad >=len (_fadf .Data ){return ;};_bbg :=_gfdb .Y >>6;_fadf .Data [_aad ]=(_fadf .Data [_aad ]&(^(0xc0>>uint (2*((x )&3)))))|(_bbg <<uint (6-2*(x &3)));};func (_ddd *Gray4 )At (x ,y int )_e .Color {_ebcd ,_ :=_ddd .ColorAt (x ,y );return _ebcd };func (_bagc *NRGBA16 )ColorModel ()_e .Model {return NRGBA16Model };func (_gaf *Gray2 )ColorModel ()_e .Model {return Gray2Model };func (_gde *Gray16 )GrayAt (x ,y int )_e .Gray {_cfec ,_ :=_gde .ColorAt (x ,y );return _e .Gray {Y :uint8 (_cfec .(_e .Gray16 ).Y >>8)};};type Gray interface{GrayAt (_gff ,_ffgf int )_e .Gray ;SetGray (_dce ,_cec int ,_baf _e .Gray );};type CMYK interface{CMYKAt (_ac ,_ffg int )_e .CMYK ;SetCMYK (_ee ,_fba int ,_gc _e .CMYK );};func (_gfe *Gray8 )At (x ,y int )_e .Color {_dddb ,_ :=_gfe .ColorAt (x ,y );return _dddb };func _dad (_bgc ,_eee CMYK ,_eef _g .Rectangle ){for _ab :=0;_ab < _eef .Max .X ;_ab ++{for _ag :=0;_ag < _eef .Max .Y ;_ag ++{_eee .SetCMYK (_ab ,_ag ,_bgc .CMYKAt (_ab ,_ag ));};};};func (_aec *Gray8 )Validate ()error {if len (_aec .Data )!=_aec .Height *_aec .BytesPerLine {return ErrInvalidImage ;};return nil ;};func ColorAtGray16BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_e .Gray16 ,error ){_efbg :=(y *bytesPerLine /2+x )*2;if _efbg +1>=len (data ){return _e .Gray16 {},_ff .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_ebbe :=uint16 (data [_efbg ])<<8|uint16 (data [_efbg +1]);if len (decode )==2{_ebbe =uint16 (uint64 (LinearInterpolate (float64 (_ebbe ),0,65535,decode [0],decode [1])));};return _e .Gray16 {Y :_ebbe },nil ;};type Histogramer interface{Histogram ()[256]int ;};var _ _g .Image =&Gray2 {};func (_eab *CMYK32 )Set (x ,y int ,c _e .Color ){_d :=4*(y *_eab .Width +x );if _d +3>=len (_eab .Data ){return ;};_gf :=_e .CMYKModel .Convert (c ).(_e .CMYK );_eab .Data [_d ]=_gf .C ;_eab .Data [_d +1]=_gf .M ;_eab .Data [_d +2]=_gf .Y ;_eab .Data [_d +3]=_gf .K ;};func (_dede *Gray16 )Base ()*ImageBase {return &_dede .ImageBase };func _ecd (_dfca _e .Gray )_e .Gray {_dfca .Y >>=4;_dfca .Y |=_dfca .Y <<4;return _dfca };func (_ebe *NRGBA32 )setRGBA (_gea int ,_fadc _e .NRGBA ){_cfead :=3*_gea ;_ebe .Data [_cfead ]=_fadc .R ;_ebe .Data [_cfead +1]=_fadc .G ;_ebe .Data [_cfead +2]=_fadc .B ;if _gea < len (_ebe .Alpha ){_ebe .Alpha [_gea ]=_fadc .A ;};};func _gb (_gcf _e .NRGBA )_e .Gray {_cd ,_fbad ,_egcd ,_ :=_gcf .RGBA ();_gbb :=(19595*_cd +38470*_fbad +7471*_egcd +1<<15)>>24;return _e .Gray {Y :uint8 (_gbb )};};func _aab (_da _g .Image )(Image ,error ){if _ead ,_dbb :=_da .(*CMYK32 );_dbb {return _ead .Copy (),nil ;};_de :=_da .Bounds ();_ba ,_bde :=NewImage (_de .Max .X ,_de .Max .Y ,8,4,nil ,nil ,nil );if _bde !=nil {return nil ,_bde ;};switch _dea :=_da .(type ){case CMYK :_dad (_dea ,_ba .(CMYK ),_de );case Gray :_cfg (_dea ,_ba .(CMYK ),_de );case NRGBA :_ec (_dea ,_ba .(CMYK ),_de );case RGBA :_bcb (_dea ,_ba .(CMYK ),_de );default:_bf (_da ,_ba ,_de );};return _ba ,nil ;};func _fedg (_cfdf *_g .Gray ,_efc uint8 )*_g .Gray {_gcef :=_cfdf .Bounds ();_begf :=_g .NewGray (_gcef );for _ddfg :=0;_ddfg < _gcef .Dx ();_ddfg ++{for _ccc :=0;_ccc < _gcef .Dy ();_ccc ++{_bgab :=_cfdf .GrayAt (_ddfg ,_ccc );_begf .SetGray (_ddfg ,_ccc ,_e .Gray {Y :_bac (_bgab .Y ,_efc )});};};return _begf ;};var _ _g .Image =&Gray4 {};func (_abf *Gray4 )Histogram ()(_ggbdg [256]int ){for _cag :=0;_cag < _abf .Width ;_cag ++{for _bfa :=0;_bfa < _abf .Height ;_bfa ++{_ggbdg [_abf .GrayAt (_cag ,_bfa ).Y ]++;};};return _ggbdg ;};func _gdg (_gaae Gray ,_dbdfa NRGBA ,_adag _g .Rectangle ){for _eeafb :=0;_eeafb < _adag .Max .X ;_eeafb ++{for _egfc :=0;_egfc < _adag .Max .Y ;_egfc ++{_cfcg :=_gaae .GrayAt (_eeafb ,_egfc );_dbdfa .SetNRGBA (_eeafb ,_egfc ,_egc (_cfcg ));};};};func (_bfcc *NRGBA16 )SetNRGBA (x ,y int ,c _e .NRGBA ){_dfda :=y *_bfcc .BytesPerLine +x *3/2;if _dfda +1>=len (_bfcc .Data ){return ;};c =_dcf (c );_bfcc .setNRGBA (x ,y ,_dfda ,c );};func (_eb *CMYK32 )SetCMYK (x ,y int ,c _e .CMYK ){_db :=4*(y *_eb .Width +x );if _db +3>=len (_eb .Data ){return ;};_eb .Data [_db ]=c .C ;_eb .Data [_db +1]=c .M ;_eb .Data [_db +2]=c .Y ;_eb .Data [_db +3]=c .K ;};func (_bgga *NRGBA32 )At (x ,y int )_e .Color {_adbc ,_ :=_bgga .ColorAt (x ,y );return _adbc };type Gray2 struct{ImageBase };func ImgToBinary (i _g .Image ,threshold uint8 )*_g .Gray {switch _fbbc :=i .(type ){case *_g .Gray :if _fdbe (_fbbc ){return _fbbc ;};return _fedg (_fbbc ,threshold );case *_g .Gray16 :return _ggcf (_fbbc ,threshold );default:return _dbdb (_fbbc ,threshold );};};func _bac (_gfb ,_dfgb uint8 )uint8 {if _gfb < _dfgb {return 255;};return 0;};func (_bb *Monochrome )Set (x ,y int ,c _e .Color ){_cba :=y *_bb .BytesPerLine +x >>3;if _cba > len (_bb .Data )-1{return ;};_bgf :=_bb .ColorModel ().Convert (c ).(_e .Gray );_bb .setGray (x ,_bgf ,_cba );};var _ Gray =&Gray8 {};func ColorAtGray4BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_e .Gray ,error ){_dfd :=y *bytesPerLine +x >>1;if _dfd >=len (data ){return _e .Gray {},_ff .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_gce :=data [_dfd ]>>uint (4-(x &1)*4)&0xf;if len (decode )==2{_gce =uint8 (uint32 (LinearInterpolate (float64 (_gce ),0,15,decode [0],decode [1]))&0xf);};return _e .Gray {Y :_gce *17&0xff},nil ;};func AutoThresholdTriangle (histogram [256]int )uint8 {var _gbgf ,_cebaa ,_gbgg ,_dcdd int ;for _cfdg :=0;_cfdg < len (histogram );_cfdg ++{if histogram [_cfdg ]> 0{_gbgf =_cfdg ;break ;};};if _gbgf > 0{_gbgf --;};for _gfa :=255;_gfa > 0;_gfa --{if histogram [_gfa ]> 0{_dcdd =_gfa ;break ;};};if _dcdd < 255{_dcdd ++;};for _dgae :=0;_dgae < 256;_dgae ++{if histogram [_dgae ]> _cebaa {_gbgg =_dgae ;_cebaa =histogram [_dgae ];};};var _baeb bool ;if (_gbgg -_gbgf )< (_dcdd -_gbgg ){_baeb =true ;var _cad int ;_gfcc :=255;for _cad < _gfcc {_bedb :=histogram [_cad ];histogram [_cad ]=histogram [_gfcc ];histogram [_gfcc ]=_bedb ;_cad ++;_gfcc --;};_gbgf =255-_dcdd ;_gbgg =255-_gbgg ;};if _gbgf ==_gbgg {return uint8 (_gbgf );};_egcda :=float64 (histogram [_gbgg ]);_ccbed :=float64 (_gbgf -_gbgg );_accg :=_a .Sqrt (_egcda *_egcda +_ccbed *_ccbed );_egcda /=_accg ;_ccbed /=_accg ;_accg =_egcda *float64 (_gbgf )+_ccbed *float64 (histogram [_gbgf ]);_aegg :=_gbgf ;var _dfed float64 ;for _dfec :=_gbgf +1;_dfec <=_gbgg ;_dfec ++{_ffe :=_egcda *float64 (_dfec )+_ccbed *float64 (histogram [_dfec ])-_accg ;if _ffe > _dfed {_aegg =_dfec ;_dfed =_ffe ;};};_aegg --;if _baeb {var _egce int ;_ddce :=255;for _egce < _ddce {_ffgc :=histogram [_egce ];histogram [_egce ]=histogram [_ddce ];histogram [_ddce ]=_ffgc ;_egce ++;_ddce --;};return uint8 (255-_aegg );};return uint8 (_aegg );};func (_gdec *ImageBase )Pix ()[]byte {return _gdec .Data };var _ Gray =&Gray4 {};type colorConverter struct{_ce func (_dcb _g .Image )(Image ,error );};func (_ecdc *Gray8 )Base ()*ImageBase {return &_ecdc .ImageBase };var _ _g .Image =&NRGBA32 {};var _bef [256]uint8 ;func _ffd (_edaa int ,_ecaa int )error {return _ff .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",_edaa ,_ecaa );};var _ Image =&Gray8 {};func (_decc *Gray2 )Histogram ()(_bdf [256]int ){for _bddb :=0;_bddb < _decc .Width ;_bddb ++{for _gcag :=0;_gcag < _decc .Height ;_gcag ++{_bdf [_decc .GrayAt (_bddb ,_gcag ).Y ]++;};};return _bdf ;};func _efef (_cac _g .Image )(Image ,error ){if _bbde ,_gegb :=_cac .(*NRGBA64 );_gegb {return _bbde .Copy (),nil ;};_gdea :=_cac .Bounds ();_bcf ,_dgcc :=NewImage (_gdea .Max .X ,_gdea .Max .Y ,16,3,nil ,nil ,nil );if _dgcc !=nil {return nil ,_dgcc ;};_fef (_cac ,_bcf ,_gdea );return _bcf ,nil ;};func (_fca *NRGBA64 )Bounds ()_g .Rectangle {return _g .Rectangle {Max :_g .Point {X :_fca .Width ,Y :_fca .Height }};};func GrayHistogram (g Gray )(_bbgd [256]int ){switch _afdf :=g .(type ){case Histogramer :return _afdf .Histogram ();case _g .Image :_ece :=_afdf .Bounds ();for _ccgc :=0;_ccgc < _ece .Max .X ;_ccgc ++{for _gee :=0;_gee < _ece .Max .Y ;_gee ++{_bbgd [g .GrayAt (_ccgc ,_gee ).Y ]++;};};return _bbgd ;default:return [256]int {};};};type monochromeThresholdConverter struct{Threshold uint8 ;};var _ Image =&NRGBA64 {};func (_dfb *CMYK32 )CMYKAt (x ,y int )_e .CMYK {_bga ,_ :=ColorAtCMYK (x ,y ,_dfb .Width ,_dfb .Data ,_dfb .Decode );return _bga ;};func _bece (_fag _e .Color )_e .Color {_afc :=_e .GrayModel .Convert (_fag ).(_e .Gray );return _ecd (_afc )};func ColorAtCMYK (x ,y ,width int ,data []byte ,decode []float64 )(_e .CMYK ,error ){_cf :=4*(y *width +x );if _cf +3>=len (data ){return _e .CMYK {},_ff .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};C :=data [_cf ]&0xff;M :=data [_cf +1]&0xff;Y :=data [_cf +2]&0xff;K :=data [_cf +3]&0xff;if len (decode )==8{C =uint8 (uint32 (LinearInterpolate (float64 (C ),0,255,decode [0],decode [1]))&0xff);M =uint8 (uint32 (LinearInterpolate (float64 (M ),0,255,decode [2],decode [3]))&0xff);Y =uint8 (uint32 (LinearInterpolate (float64 (Y ),0,255,decode [4],decode [5]))&0xff);K =uint8 (uint32 (LinearInterpolate (float64 (K ),0,255,decode [6],decode [7]))&0xff);};return _e .CMYK {C :C ,M :M ,Y :Y ,K :K },nil ;};func _cdd (_aafc _g .Image )(Image ,error ){if _aeaa ,_fec :=_aafc .(*Gray4 );_fec {return _aeaa .Copy (),nil ;};_faa :=_aafc .Bounds ();_dba ,_ccbe :=NewImage (_faa .Max .X ,_faa .Max .Y ,4,1,nil ,nil ,nil );if _ccbe !=nil {return nil ,_ccbe ;};_ddc (_aafc ,_dba ,_faa );return _dba ,nil ;};func (_gbd *Gray4 )Set (x ,y int ,c _e .Color ){if x >=_gbd .Width ||y >=_gbd .Height {return ;};_bcde :=Gray4Model .Convert (c ).(_e .Gray );_gbd .setGray (x ,y ,_bcde );};type NRGBA interface{NRGBAAt (_dacc ,_dgcb int )_e .NRGBA ;SetNRGBA (_eeda ,_adbd int ,_abd _e .NRGBA );};func _cagaa (_bebg RGBA ,_cagb Gray ,_eaga _g .Rectangle ){for _ecda :=0;_ecda < _eaga .Max .X ;_ecda ++{for _eccb :=0;_eccb < _eaga .Max .Y ;_eccb ++{_cce :=_fcg (_bebg .RGBAAt (_ecda ,_eccb ));_cagb .SetGray (_ecda ,_eccb ,_cce );};};};func _cge (_bfe _g .Image )(Image ,error ){if _aeaae ,_ggfa :=_bfe .(*NRGBA32 );_ggfa {return _aeaae .Copy (),nil ;};_bbbe :=_bfe .Bounds ();_acgbe ,_ecdca :=NewImage (_bbbe .Max .X ,_bbbe .Max .Y ,8,3,nil ,nil ,nil );if _ecdca !=nil {return nil ,_ecdca ;};_fef (_bfe ,_acgbe ,_bbbe );return _acgbe ,nil ;};func (_gcbe *NRGBA64 )SetNRGBA64 (x ,y int ,c _e .NRGBA64 ){_bcdb :=(y *_gcbe .Width +x )*2;_cbfaf :=_bcdb *3;if _cbfaf +5>=len (_gcbe .Data ){return ;};_gcbe .setNRGBA64 (_cbfaf ,c ,_bcdb );};func _gge (_egd _g .Image )(Image ,error ){if _eeg ,_age :=_egd .(*Gray2 );_age {return _eeg .Copy (),nil ;};_egf :=_egd .Bounds ();_dbbf ,_eed :=NewImage (_egf .Max .X ,_egf .Max .Y ,2,1,nil ,nil ,nil );if _eed !=nil {return nil ,_eed ;};_ddc (_egd ,_dbbf ,_egf );return _dbbf ,nil ;};func (_dgbd *NRGBA16 )Validate ()error {if len (_dgbd .Data )!=3*_dgbd .Width *_dgbd .Height /2{return _f .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");};return nil ;};func ColorAtGray2BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_e .Gray ,error ){_bff :=y *bytesPerLine +x >>2;if _bff >=len (data ){return _e .Gray {},_ff .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );};_dbc :=data [_bff ]>>uint (6-(x &3)*2)&3;if len (decode )==2{_dbc =uint8 (uint32 (LinearInterpolate (float64 (_dbc ),0,3.0,decode [0],decode [1]))&3);};return _e .Gray {Y :_dbc *85},nil ;};func (_ccd *Gray4 )Copy ()Image {return &Gray4 {ImageBase :_ccd .copy ()}};func (_daaf *Gray4 )ColorAt (x ,y int )(_e .Color ,error ){return ColorAtGray4BPC (x ,y ,_daaf .BytesPerLine ,_daaf .Data ,_daaf .Decode );};func (_aca *Gray2 )Set (x ,y int ,c _e .Color ){if x >=_aca .Width ||y >=_aca .Height {return ;};_ced :=Gray2Model .Convert (c ).(_e .Gray );_agd :=y *_aca .BytesPerLine ;_ebc :=_agd +(x >>2);_gec :=_ced .Y >>6;_aca .Data [_ebc ]=(_aca .Data [_ebc ]&(^(0xc0>>uint (2*((x )&3)))))|(_gec <<uint (6-2*(x &3)));};func (_dbfd *NRGBA64 )Copy ()Image {return &NRGBA64 {ImageBase :_dbfd .copy ()}};func (_edbf *Monochrome )ColorAt (x ,y int )(_e .Color ,error ){return ColorAtGray1BPC (x ,y ,_edbf .BytesPerLine ,_edbf .Data ,_edbf .Decode );};type SMasker interface{HasAlpha ()bool ;GetAlpha ()[]byte ;MakeAlpha ();};func _fgb (_dffd _e .Gray )_e .Gray {_bgb :=_dffd .Y >>6;_bgb |=_bgb <<2;_dffd .Y =_bgb |_bgb <<4;return _dffd ;};func (_gecc *NRGBA16 )Bounds ()_g .Rectangle {return _g .Rectangle {Max :_g .Point {X :_gecc .Width ,Y :_gecc .Height }};};func (_faf *Gray8 )Bounds ()_g .Rectangle {return _g .Rectangle {Max :_g .Point {X :_faf .Width ,Y :_faf .Height }};};func _dcf (_ddde _e .NRGBA )_e .NRGBA {_ddde .R =_ddde .R >>4|(_ddde .R >>4)<<4;_ddde .G =_ddde .G >>4|(_ddde .G >>4)<<4;_ddde .B =_ddde .B >>4|(_ddde .B >>4)<<4;return _ddde ;};func _fce (_cef _e .RGBA )_e .CMYK {_gagf ,_dac ,_bfc ,_aae :=_e .RGBToCMYK (_cef .R ,_cef .G ,_cef .B );return _e .CMYK {C :_gagf ,M :_dac ,Y :_bfc ,K :_aae };};func _acgb (_cfbe _e .Color )_e .Color {_fdg :=_e .NRGBAModel .Convert (_cfbe ).(_e .NRGBA );return _dcf (_fdg );};func _ecge (_def _g .Image )(Image ,error ){if _abae ,_cfed :=_def .(*NRGBA16 );_cfed {return _abae .Copy (),nil ;};_fbea :=_def .Bounds ();_acbb ,_dfe :=NewImage (_fbea .Max .X ,_fbea .Max .Y ,4,3,nil ,nil ,nil );if _dfe !=nil {return nil ,_dfe ;};_fef (_def ,_acbb ,_fbea );return _acbb ,nil ;};var (MonochromeConverter =ConverterFunc (_ecf );Gray2Converter =ConverterFunc (_gge );Gray4Converter =ConverterFunc (_cdd );GrayConverter =ConverterFunc (_ecbg );Gray16Converter =ConverterFunc (_agf );NRGBA16Converter =ConverterFunc (_ecge );NRGBAConverter =ConverterFunc (_cge );NRGBA64Converter =ConverterFunc (_efef );CMYKConverter =ConverterFunc (_aab ););func ConverterFunc (converterFunc func (_dg _g .Image )(Image ,error ))ColorConverter {return colorConverter {_ce :converterFunc };};var _ _g .Image =&Monochrome {};func (_bed *Gray2 )Validate ()error {if len (_bed .Data )!=_bed .Height *_bed .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_faec *NRGBA64 )NRGBA64At (x ,y int )_e .NRGBA64 {_acc ,_ :=ColorAtNRGBA64 (x ,y ,_faec .Width ,_faec .Data ,_faec .Alpha ,_faec .Decode );return _acc ;};func (_ccg *Monochrome )GrayAt (x ,y int )_e .Gray {_fbc ,_ :=ColorAtGray1BPC (x ,y ,_ccg .BytesPerLine ,_ccg .Data ,_ccg .Decode );return _fbc ;};func (_fbb *Monochrome )Copy ()Image {return &Monochrome {ImageBase :_fbb .ImageBase .copy (),ModelThreshold :_fbb .ModelThreshold };};func (_bfbe *Gray16 )Validate ()error {if len (_bfbe .Data )!=_bfbe .Height *_bfbe .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_gacc *NRGBA32 )Base ()*ImageBase {return &_gacc .ImageBase };func _fceg (_cafd RGBA ,_ggff NRGBA ,_gccf _g .Rectangle ){for _cfecc :=0;_cfecc < _gccf .Max .X ;_cfecc ++{for _bab :=0;_bab < _gccf .Max .Y ;_bab ++{_gbf :=_cafd .RGBAAt (_cfecc ,_bab );_ggff .SetNRGBA (_cfecc ,_bab ,_facb (_gbf ));};};};var _ Gray =&Monochrome {};func AddDataPadding (width ,height ,bitsPerComponent ,colorComponents int ,data []byte )([]byte ,error ){_bca :=BytesPerLine (width ,bitsPerComponent ,colorComponents );if _bca ==width *colorComponents *bitsPerComponent /8{return data ,nil ;};_ccfg :=width *colorComponents *bitsPerComponent ;_eda :=_bca *8;_cfag :=8-(_eda -_ccfg );_daab :=_fb .NewReader (data );_bgff :=_bca -1;_ebbeb :=make ([]byte ,_bgff );_cca :=make ([]byte ,height *_bca );_bbea :=_fb .NewWriterMSB (_cca );var _bcbd uint64 ;var _aaeb error ;for _ecdb :=0;_ecdb < height ;_ecdb ++{_ ,_aaeb =_daab .Read (_ebbeb );if _aaeb !=nil {return nil ,_aaeb ;};_ ,_aaeb =_bbea .Write (_ebbeb );if _aaeb !=nil {return nil ,_aaeb ;};_bcbd ,_aaeb =_daab .ReadBits (byte (_cfag ));if _aaeb !=nil {return nil ,_aaeb ;};_ ,_aaeb =_bbea .WriteBits (_bcbd ,_cfag );if _aaeb !=nil {return nil ,_aaeb ;};_bbea .FinishByte ();};return _cca ,nil ;};