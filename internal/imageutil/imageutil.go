//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package imageutil ;import (_dd "encoding/binary";_d "errors";_ee "fmt";_eed "github.com/unidoc/unipdf/v3/common";_fg "github.com/unidoc/unipdf/v3/internal/bitwise";_e "image";_f "image/color";_gb "image/draw";_df "math";);func _gebf (_fbgd nrgba64 ,_bdec NRGBA ,_bbbab _e .Rectangle ){for _bfad :=0;
_bfad < _bbbab .Max .X ;_bfad ++{for _bgab :=0;_bgab < _bbbab .Max .Y ;_bgab ++{_efcc :=_fbgd .NRGBA64At (_bfad ,_bgab );_bdec .SetNRGBA (_bfad ,_bgab ,_efdg (_efcc ));};};};func _effe (_cfff uint8 )bool {if _cfff ==0||_cfff ==255{return true ;};return false ;
};func _bgff (_fef int )[]uint {var _aad []uint ;_ada :=_fef ;_bbd :=_ada /8;if _bbd !=0{for _cbf :=0;_cbf < _bbd ;_cbf ++{_aad =append (_aad ,8);};_acb :=_ada %8;_ada =0;if _acb !=0{_ada =_acb ;};};_fgd :=_ada /4;if _fgd !=0{for _afd :=0;_afd < _fgd ;
_afd ++{_aad =append (_aad ,4);};_efcb :=_ada %4;_ada =0;if _efcb !=0{_ada =_efcb ;};};_cfa :=_ada /2;if _cfa !=0{for _ff :=0;_ff < _cfa ;_ff ++{_aad =append (_aad ,2);};};return _aad ;};func (_daca *Gray8 )Bounds ()_e .Rectangle {return _e .Rectangle {Max :_e .Point {X :_daca .Width ,Y :_daca .Height }};
};func ColorAtNRGBA16 (x ,y ,width ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_f .NRGBA ,error ){_fbca :=y *bytesPerLine +x *3/2;if _fbca +1>=len (data ){return _f .NRGBA {},_abbg (x ,y );};const (_caee =0xf;_fgdg =uint8 (0xff););_ggde :=_fgdg ;
if alpha !=nil {_eac :=y *BytesPerLine (width ,4,1);if _eac < len (alpha ){if x %2==0{_ggde =(alpha [_eac ]>>uint (4))&_caee ;}else {_ggde =alpha [_eac ]&_caee ;};_ggde |=_ggde <<4;};};var _gfff ,_dbbg ,_gcda uint8 ;if x *3%2==0{_gfff =(data [_fbca ]>>uint (4))&_caee ;
_dbbg =data [_fbca ]&_caee ;_gcda =(data [_fbca +1]>>uint (4))&_caee ;}else {_gfff =data [_fbca ]&_caee ;_dbbg =(data [_fbca +1]>>uint (4))&_caee ;_gcda =data [_fbca +1]&_caee ;};if len (decode )==6{_gfff =uint8 (uint32 (LinearInterpolate (float64 (_gfff ),0,15,decode [0],decode [1]))&0xf);
_dbbg =uint8 (uint32 (LinearInterpolate (float64 (_dbbg ),0,15,decode [2],decode [3]))&0xf);_gcda =uint8 (uint32 (LinearInterpolate (float64 (_gcda ),0,15,decode [4],decode [5]))&0xf);};return _f .NRGBA {R :(_gfff <<4)|(_gfff &0xf),G :(_dbbg <<4)|(_dbbg &0xf),B :(_gcda <<4)|(_gcda &0xf),A :_ggde },nil ;
};func ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor int ,data ,alpha []byte ,decode []float64 )(_f .Color ,error ){switch bitsPerColor {case 4:return ColorAtNRGBA16 (x ,y ,width ,bytesPerLine ,data ,alpha ,decode );case 8:return ColorAtNRGBA32 (x ,y ,width ,data ,alpha ,decode );
case 16:return ColorAtNRGBA64 (x ,y ,width ,data ,alpha ,decode );default:return nil ,_ee .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0067\u0062\u0020b\u0069\u0074\u0073\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0061\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );
};};func (_bfg *CMYK32 )ColorAt (x ,y int )(_f .Color ,error ){return ColorAtCMYK (x ,y ,_bfg .Width ,_bfg .Data ,_bfg .Decode );};func (_dgbf *Monochrome )clearBit (_aeea ,_dfe int ){_dgbf .Data [_aeea ]&=^(0x80>>uint (_dfe &7))};func _adbd (_fec _e .Image )(Image ,error ){if _cad ,_cga :=_fec .(*CMYK32 );
_cga {return _cad .Copy (),nil ;};_eee :=_fec .Bounds ();_ecag ,_bfc :=NewImage (_eee .Max .X ,_eee .Max .Y ,8,4,nil ,nil ,nil );if _bfc !=nil {return nil ,_bfc ;};switch _abee :=_fec .(type ){case CMYK :_fca (_abee ,_ecag .(CMYK ),_eee );case Gray :_fbg (_abee ,_ecag .(CMYK ),_eee );
case NRGBA :_cag (_abee ,_ecag .(CMYK ),_eee );case RGBA :_eaag (_abee ,_ecag .(CMYK ),_eee );default:_egff (_fec ,_ecag ,_eee );};return _ecag ,nil ;};func (_ecac *NRGBA32 )Base ()*ImageBase {return &_ecac .ImageBase };func (_gafe *Gray2 )SetGray (x ,y int ,gray _f .Gray ){_efgd :=_agb (gray );
_dcc :=y *_gafe .BytesPerLine ;_efeb :=_dcc +(x >>2);if _efeb >=len (_gafe .Data ){return ;};_cabf :=_efgd .Y >>6;_gafe .Data [_efeb ]=(_gafe .Data [_efeb ]&(^(0xc0>>uint (2*((x )&3)))))|(_cabf <<uint (6-2*(x &3)));};func (_dcdd *NRGBA32 )Bounds ()_e .Rectangle {return _e .Rectangle {Max :_e .Point {X :_dcdd .Width ,Y :_dcdd .Height }};
};func ScaleAlphaToMonochrome (data []byte ,width ,height int )([]byte ,error ){_a :=BytesPerLine (width ,8,1);if len (data )< _a *height {return nil ,nil ;};_ac :=&Gray8 {NewImageBase (width ,height ,8,1,data ,nil ,nil )};_ga ,_gg :=MonochromeConverter .Convert (_ac );
if _gg !=nil {return nil ,_gg ;};return _ga .Base ().Data ,nil ;};func (_aggf *Monochrome )SetGray (x ,y int ,g _f .Gray ){_dfbcg :=y *_aggf .BytesPerLine +x >>3;if _dfbcg > len (_aggf .Data )-1{return ;};g =_fgg (g ,monochromeModel (_aggf .ModelThreshold ));
_aggf .setGray (x ,g ,_dfbcg );};func _cdc (_aab ,_bccf int )*Monochrome {return &Monochrome {ImageBase :NewImageBase (_aab ,_bccf ,1,1,nil ,nil ,nil ),ModelThreshold :0x0f};};func (_bcfc *Gray16 )SetGray (x ,y int ,g _f .Gray ){_ccfb :=(y *_bcfc .BytesPerLine /2+x )*2;
if _ccfb +1>=len (_bcfc .Data ){return ;};_bcfc .Data [_ccfb ]=g .Y ;_bcfc .Data [_ccfb +1]=g .Y ;};func _agge (_ebdg _e .Image ,_add Image ,_cabg _e .Rectangle ){switch _bbba :=_ebdg .(type ){case Gray :_bgcf (_bbba ,_add .(Gray ),_cabg );case NRGBA :_cdgb (_bbba ,_add .(Gray ),_cabg );
case CMYK :_ffa (_bbba ,_add .(Gray ),_cabg );case RGBA :_bgce (_bbba ,_add .(Gray ),_cabg );default:_egff (_ebdg ,_add .(Image ),_cabg );};};func FromGoImage (i _e .Image )(Image ,error ){switch _cefd :=i .(type ){case Image :return _cefd .Copy (),nil ;
case Gray :return GrayConverter .Convert (i );case *_e .Gray16 :return Gray16Converter .Convert (i );case CMYK :return CMYKConverter .Convert (i );case *_e .NRGBA64 :return NRGBA64Converter .Convert (i );default:return NRGBAConverter .Convert (i );};};
var _ _e .Image =&NRGBA32 {};func ColorAt (x ,y ,width ,bitsPerColor ,colorComponents ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_f .Color ,error ){switch colorComponents {case 1:return ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine ,data ,decode );
case 3:return ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor ,data ,alpha ,decode );case 4:return ColorAtCMYK (x ,y ,width ,data ,decode );default:return nil ,_ee .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0063o\u006c\u006f\u0072\u0020\u0063\u006f\u006dp\u006f\u006e\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0064",colorComponents );
};};func (_faa *NRGBA16 )ColorAt (x ,y int )(_f .Color ,error ){return ColorAtNRGBA16 (x ,y ,_faa .Width ,_faa .BytesPerLine ,_faa .Data ,_faa .Alpha ,_faa .Decode );};func (_agdg *Gray4 )ColorAt (x ,y int )(_f .Color ,error ){return ColorAtGray4BPC (x ,y ,_agdg .BytesPerLine ,_agdg .Data ,_agdg .Decode );
};func (_fadbb *NRGBA32 )Set (x ,y int ,c _f .Color ){_effa :=y *_fadbb .Width +x ;_feebb :=3*_effa ;if _feebb +2>=len (_fadbb .Data ){return ;};_bbca :=_f .NRGBAModel .Convert (c ).(_f .NRGBA );_fadbb .setRGBA (_effa ,_bbca );};func (_bbeb *Monochrome )ResolveDecode ()error {if len (_bbeb .Decode )!=2{return nil ;
};if _bbeb .Decode [0]==1&&_bbeb .Decode [1]==0{if _ecad :=_bbeb .InverseData ();_ecad !=nil {return _ecad ;};_bbeb .Decode =nil ;};return nil ;};func (_feda *CMYK32 )At (x ,y int )_f .Color {_cdgf ,_ :=_feda .ColorAt (x ,y );return _cdgf };func (_cagg *Gray16 )At (x ,y int )_f .Color {_bfcg ,_ :=_cagg .ColorAt (x ,y );
return _bfcg };var _ Image =&Gray16 {};type shift int ;func (_afg *Monochrome )getBit (_daeg ,_efcbc int )uint8 {return _afg .Data [_daeg +(_efcbc >>3)]>>uint (7-(_efcbc &7))&1;};var _ Gray =&Monochrome {};func _fgg (_dac _f .Gray ,_fbfac monochromeModel )_f .Gray {if _dac .Y > uint8 (_fbfac ){return _f .Gray {Y :_df .MaxUint8 };
};return _f .Gray {};};func _egff (_bfb _e .Image ,_ggba Image ,_cef _e .Rectangle ){for _fea :=0;_fea < _cef .Max .X ;_fea ++{for _cgbf :=0;_cgbf < _cef .Max .Y ;_cgbf ++{_aaf :=_bfb .At (_fea ,_cgbf );_ggba .Set (_fea ,_cgbf ,_aaf );};};};type monochromeModel uint8 ;
const (_bacf shift =iota ;_fdbb ;);func InDelta (expected ,current ,delta float64 )bool {_fgeg :=expected -current ;if _fgeg <=-delta ||_fgeg >=delta {return false ;};return true ;};func (_fgcg *ImageBase )HasAlpha ()bool {if _fgcg .Alpha ==nil {return false ;
};for _ffeg :=range _fgcg .Alpha {if _fgcg .Alpha [_ffeg ]!=0xff{return true ;};};return false ;};func (_fdbd *Monochrome )setBit (_afa ,_eeea int ){_fdbd .Data [_afa +(_eeea >>3)]|=0x80>>uint (_eeea &7);};func _agacg (_gcge *_e .Gray ,_faff uint8 )*_e .Gray {_deac :=_gcge .Bounds ();
_bagd :=_e .NewGray (_deac );for _befe :=0;_befe < _deac .Dx ();_befe ++{for _fefb :=0;_fefb < _deac .Dy ();_fefb ++{_adgb :=_gcge .GrayAt (_befe ,_fefb );_bagd .SetGray (_befe ,_fefb ,_f .Gray {Y :_fbad (_adgb .Y ,_faff )});};};return _bagd ;};func ColorAtCMYK (x ,y ,width int ,data []byte ,decode []float64 )(_f .CMYK ,error ){_fcc :=4*(y *width +x );
if _fcc +3>=len (data ){return _f .CMYK {},_ee .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};C :=data [_fcc ]&0xff;M :=data [_fcc +1]&0xff;Y :=data [_fcc +2]&0xff;K :=data [_fcc +3]&0xff;if len (decode )==8{C =uint8 (uint32 (LinearInterpolate (float64 (C ),0,255,decode [0],decode [1]))&0xff);M =uint8 (uint32 (LinearInterpolate (float64 (M ),0,255,decode [2],decode [3]))&0xff);
Y =uint8 (uint32 (LinearInterpolate (float64 (Y ),0,255,decode [4],decode [5]))&0xff);K =uint8 (uint32 (LinearInterpolate (float64 (K ),0,255,decode [6],decode [7]))&0xff);};return _f .CMYK {C :C ,M :M ,Y :Y ,K :K },nil ;};var _ NRGBA =&NRGBA16 {};func (_acf *Monochrome )IsUnpadded ()bool {return (_acf .Width *_acf .Height )==len (_acf .Data )};
var _ _e .Image =&Gray16 {};func _ggc (_ecae _e .Image )(Image ,error ){if _fegc ,_abge :=_ecae .(*Gray16 );_abge {return _fegc .Copy (),nil ;};_bbb :=_ecae .Bounds ();_ecgg ,_cdfg :=NewImage (_bbb .Max .X ,_bbb .Max .Y ,16,1,nil ,nil ,nil );if _cdfg !=nil {return nil ,_cdfg ;
};_agge (_ecae ,_ecgg ,_bbb );return _ecgg ,nil ;};func (_bdbe *Monochrome )RasterOperation (dx ,dy ,dw ,dh int ,op RasterOperator ,src *Monochrome ,sx ,sy int )error {return _bec (_bdbe ,dx ,dy ,dw ,dh ,op ,src ,sx ,sy );};var _ _e .Image =&Gray2 {};func (_bcgabg *NRGBA64 )ColorAt (x ,y int )(_f .Color ,error ){return ColorAtNRGBA64 (x ,y ,_bcgabg .Width ,_bcgabg .Data ,_bcgabg .Alpha ,_bcgabg .Decode );
};func (_cec *Gray8 )At (x ,y int )_f .Color {_cbce ,_ :=_cec .ColorAt (x ,y );return _cbce };type Gray4 struct{ImageBase };var _ Gray =&Gray8 {};func (_ffb colorConverter )Convert (src _e .Image )(Image ,error ){return _ffb ._deba (src )};var _ Image =&CMYK32 {};
func (_aecf *Gray16 )Validate ()error {if len (_aecf .Data )!=_aecf .Height *_aecf .BytesPerLine {return ErrInvalidImage ;};return nil ;};func _afda (_dgc _f .Gray )_f .CMYK {return _f .CMYK {K :0xff-_dgc .Y }};func (_aceag *Gray16 )ColorAt (x ,y int )(_f .Color ,error ){return ColorAtGray16BPC (x ,y ,_aceag .BytesPerLine ,_aceag .Data ,_aceag .Decode );
};type RasterOperator int ;func NextPowerOf2 (n uint )uint {if IsPowerOf2 (n ){return n ;};return 1<<(_bgffb (n )+1);};func ColorAtNRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_f .NRGBA ,error ){_ccfa :=y *width +x ;_ccbd :=3*_ccfa ;
if _ccbd +2>=len (data ){return _f .NRGBA {},_ee .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_fged :=uint8 (0xff);if alpha !=nil &&len (alpha )> _ccfa {_fged =alpha [_ccfa ];};_gdgb ,_daad ,_dbgf :=data [_ccbd ],data [_ccbd +1],data [_ccbd +2];if len (decode )==6{_gdgb =uint8 (uint32 (LinearInterpolate (float64 (_gdgb ),0,255,decode [0],decode [1]))&0xff);
_daad =uint8 (uint32 (LinearInterpolate (float64 (_daad ),0,255,decode [2],decode [3]))&0xff);_dbgf =uint8 (uint32 (LinearInterpolate (float64 (_dbgf ),0,255,decode [4],decode [5]))&0xff);};return _f .NRGBA {R :_gdgb ,G :_daad ,B :_dbgf ,A :_fged },nil ;
};type ColorConverter interface{Convert (_cfc _e .Image )(Image ,error );};func _faca (_bbaa *_e .Gray )bool {for _abbc :=0;_abbc < len (_bbaa .Pix );_abbc ++{if !_effe (_bbaa .Pix [_abbc ]){return false ;};};return true ;};func _cag (_ggd NRGBA ,_bda CMYK ,_bbe _e .Rectangle ){for _egf :=0;
_egf < _bbe .Max .X ;_egf ++{for _cedf :=0;_cedf < _bbe .Max .Y ;_cedf ++{_fgdb :=_ggd .NRGBAAt (_egf ,_cedf );_bda .SetCMYK (_egf ,_cedf ,_aceb (_fgdb ));};};};func GetConverter (bitsPerComponent ,colorComponents int )(ColorConverter ,error ){switch colorComponents {case 1:switch bitsPerComponent {case 1:return MonochromeConverter ,nil ;
case 2:return Gray2Converter ,nil ;case 4:return Gray4Converter ,nil ;case 8:return GrayConverter ,nil ;case 16:return Gray16Converter ,nil ;};case 3:switch bitsPerComponent {case 4:return NRGBA16Converter ,nil ;case 8:return NRGBAConverter ,nil ;case 16:return NRGBA64Converter ,nil ;
};case 4:return CMYKConverter ,nil ;};return nil ,_ee .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0043o\u006e\u0076\u0065\u0072\u0074\u0065\u0072\u0020\u0070\u0061\u0072\u0061\u006d\u0065t\u0065\u0072\u0073\u002e\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003a\u0020\u0025\u0064\u002c\u0020\u0043\u006f\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006et\u0073\u003a \u0025\u0064",bitsPerComponent ,colorComponents );
};func _eaag (_eag RGBA ,_abg CMYK ,_eabe _e .Rectangle ){for _gce :=0;_gce < _eabe .Max .X ;_gce ++{for _gdag :=0;_gdag < _eabe .Max .Y ;_gdag ++{_ecb :=_eag .RGBAAt (_gce ,_gdag );_abg .SetCMYK (_gce ,_gdag ,_bgdc (_ecb ));};};};func (_bbea *Gray2 )GrayAt (x ,y int )_f .Gray {_bgaf ,_ :=ColorAtGray2BPC (x ,y ,_bbea .BytesPerLine ,_bbea .Data ,_bbea .Decode );
return _bgaf ;};func _cbfb (_bad ,_bac *Monochrome ,_dae []byte ,_acbb int )(_bae error ){var (_gfc ,_cbg ,_fbfa ,_eabg ,_edf ,_egc ,_afff ,_adaa int ;_ceg ,_gfb uint32 ;_fdc ,_cca byte ;_gab uint16 ;);_dce :=make ([]byte ,4);_cfab :=make ([]byte ,4);for _fbfa =0;
_fbfa < _bad .Height -1;_fbfa ,_eabg =_fbfa +2,_eabg +1{_gfc =_fbfa *_bad .BytesPerLine ;_cbg =_eabg *_bac .BytesPerLine ;for _edf ,_egc =0,0;_edf < _acbb ;_edf ,_egc =_edf +4,_egc +1{for _afff =0;_afff < 4;_afff ++{_adaa =_gfc +_edf +_afff ;if _adaa <=len (_bad .Data )-1&&_adaa < _gfc +_bad .BytesPerLine {_dce [_afff ]=_bad .Data [_adaa ];
}else {_dce [_afff ]=0x00;};_adaa =_gfc +_bad .BytesPerLine +_edf +_afff ;if _adaa <=len (_bad .Data )-1&&_adaa < _gfc +(2*_bad .BytesPerLine ){_cfab [_afff ]=_bad .Data [_adaa ];}else {_cfab [_afff ]=0x00;};};_ceg =_dd .BigEndian .Uint32 (_dce );_gfb =_dd .BigEndian .Uint32 (_cfab );
_gfb &=_ceg ;_gfb &=_gfb <<1;_gfb &=0xaaaaaaaa;_ceg =_gfb |(_gfb <<7);_fdc =byte (_ceg >>24);_cca =byte ((_ceg >>8)&0xff);_adaa =_cbg +_egc ;if _adaa +1==len (_bac .Data )-1||_adaa +1>=_cbg +_bac .BytesPerLine {_bac .Data [_adaa ]=_dae [_fdc ];if _bae =_bac .setByte (_adaa ,_dae [_fdc ]);
_bae !=nil {return _ee .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_adaa );};}else {_gab =(uint16 (_dae [_fdc ])<<8)|uint16 (_dae [_cca ]);if _bae =_bac .setTwoBytes (_adaa ,_gab );_bae !=nil {return _ee .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_adaa );
};_egc ++;};};};return nil ;};func init (){_eef ()};func (_cfcb *Gray4 )Copy ()Image {return &Gray4 {ImageBase :_cfcb .copy ()}};func (_gee *ImageBase )setByte (_gbfbc int ,_ccfc byte )error {if _gbfbc > len (_gee .Data )-1{return _d .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_gee .Data [_gbfbc ]=_ccfc ;return nil ;};func (_eeg *Gray2 )Validate ()error {if len (_eeg .Data )!=_eeg .Height *_eeg .BytesPerLine {return ErrInvalidImage ;};return nil ;};func _egb (_efe *Monochrome ,_cfg int ,_ecde []byte )(_bdg *Monochrome ,_eff error ){const _aba ="\u0072\u0065d\u0075\u0063\u0065R\u0061\u006e\u006b\u0042\u0069\u006e\u0061\u0072\u0079";
if _efe ==nil {return nil ,_d .New ("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d");};if _cfg < 1||_cfg > 4{return nil ,_d .New ("\u006c\u0065\u0076\u0065\u006c\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020\u0073e\u0074\u0020\u007b\u0031\u002c\u0032\u002c\u0033\u002c\u0034\u007d");
};if _efe .Height <=1{return nil ,_d .New ("\u0073\u006f\u0075rc\u0065\u0020\u0068\u0065\u0069\u0067\u0068\u0074\u0020m\u0075s\u0074 \u0062e\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020\u0027\u0032\u0027");};_bdg =_cdc (_efe .Width /2,_efe .Height /2);
if _ecde ==nil {_ecde =_aaa ();};_fbd :=_eea (_efe .BytesPerLine ,2*_bdg .BytesPerLine );switch _cfg {case 1:_eff =_afe (_efe ,_bdg ,_ecde ,_fbd );case 2:_eff =_ggag (_efe ,_bdg ,_ecde ,_fbd );case 3:_eff =_fac (_efe ,_bdg ,_ecde ,_fbd );case 4:_eff =_cbfb (_efe ,_bdg ,_ecde ,_fbd );
};if _eff !=nil {return nil ,_eff ;};return _bdg ,nil ;};func (_cce *CMYK32 )ColorModel ()_f .Model {return _f .CMYKModel };func (_abac *NRGBA32 )ColorAt (x ,y int )(_f .Color ,error ){return ColorAtNRGBA32 (x ,y ,_abac .Width ,_abac .Data ,_abac .Alpha ,_abac .Decode );
};func IsGrayImgBlackAndWhite (i *_e .Gray )bool {return _faca (i )};func (_caed *Gray16 )Copy ()Image {return &Gray16 {ImageBase :_caed .copy ()}};func (_ebde *ImageBase )Pix ()[]byte {return _ebde .Data };type CMYK interface{CMYKAt (_gfd ,_adge int )_f .CMYK ;
SetCMYK (_adaf ,_dbc int ,_fdb _f .CMYK );};func _fac (_gbfc ,_cacf *Monochrome ,_cdd []byte ,_def int )(_fdg error ){var (_gcbg ,_fdd ,_acg ,_bcg ,_ged ,_bgd ,_agg ,_abb int ;_ccg ,_gcba ,_abc ,_cbe uint32 ;_gcac ,_bga byte ;_bde uint16 ;);_eaac :=make ([]byte ,4);
_ffg :=make ([]byte ,4);for _acg =0;_acg < _gbfc .Height -1;_acg ,_bcg =_acg +2,_bcg +1{_gcbg =_acg *_gbfc .BytesPerLine ;_fdd =_bcg *_cacf .BytesPerLine ;for _ged ,_bgd =0,0;_ged < _def ;_ged ,_bgd =_ged +4,_bgd +1{for _agg =0;_agg < 4;_agg ++{_abb =_gcbg +_ged +_agg ;
if _abb <=len (_gbfc .Data )-1&&_abb < _gcbg +_gbfc .BytesPerLine {_eaac [_agg ]=_gbfc .Data [_abb ];}else {_eaac [_agg ]=0x00;};_abb =_gcbg +_gbfc .BytesPerLine +_ged +_agg ;if _abb <=len (_gbfc .Data )-1&&_abb < _gcbg +(2*_gbfc .BytesPerLine ){_ffg [_agg ]=_gbfc .Data [_abb ];
}else {_ffg [_agg ]=0x00;};};_ccg =_dd .BigEndian .Uint32 (_eaac );_gcba =_dd .BigEndian .Uint32 (_ffg );_abc =_ccg &_gcba ;_abc |=_abc <<1;_cbe =_ccg |_gcba ;_cbe &=_cbe <<1;_gcba =_abc &_cbe ;_gcba &=0xaaaaaaaa;_ccg =_gcba |(_gcba <<7);_gcac =byte (_ccg >>24);
_bga =byte ((_ccg >>8)&0xff);_abb =_fdd +_bgd ;if _abb +1==len (_cacf .Data )-1||_abb +1>=_fdd +_cacf .BytesPerLine {if _fdg =_cacf .setByte (_abb ,_cdd [_gcac ]);_fdg !=nil {return _ee .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_abb );};}else {_bde =(uint16 (_cdd [_gcac ])<<8)|uint16 (_cdd [_bga ]);
if _fdg =_cacf .setTwoBytes (_abb ,_bde );_fdg !=nil {return _ee .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_abb );
};_bgd ++;};};};return nil ;};func (_beaf *ImageBase )GetAlpha ()[]byte {return _beaf .Alpha };func _dbe (_dbd _f .RGBA )_f .NRGBA {switch _dbd .A {case 0xff:return _f .NRGBA {R :_dbd .R ,G :_dbd .G ,B :_dbd .B ,A :0xff};case 0x00:return _f .NRGBA {};default:_dgcf ,_ebgb ,_dcd ,_cda :=_dbd .RGBA ();
_dgcf =(_dgcf *0xffff)/_cda ;_ebgb =(_ebgb *0xffff)/_cda ;_dcd =(_dcd *0xffff)/_cda ;return _f .NRGBA {R :uint8 (_dgcf >>8),G :uint8 (_ebgb >>8),B :uint8 (_dcd >>8),A :uint8 (_cda >>8)};};};func (_dbce *Monochrome )ColorAt (x ,y int )(_f .Color ,error ){return ColorAtGray1BPC (x ,y ,_dbce .BytesPerLine ,_dbce .Data ,_dbce .Decode );
};func ColorAtNRGBA64 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_f .NRGBA64 ,error ){_efea :=(y *width +x )*2;_ggfga :=_efea *3;if _ggfga +5>=len (data ){return _f .NRGBA64 {},_ee .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};const _aefg =0xffff;_gdbf :=uint16 (_aefg );if alpha !=nil &&len (alpha )> _efea +1{_gdbf =uint16 (alpha [_efea ])<<8|uint16 (alpha [_efea +1]);};_cebc :=uint16 (data [_ggfga ])<<8|uint16 (data [_ggfga +1]);_fgad :=uint16 (data [_ggfga +2])<<8|uint16 (data [_ggfga +3]);
_geeg :=uint16 (data [_ggfga +4])<<8|uint16 (data [_ggfga +5]);if len (decode )==6{_cebc =uint16 (uint64 (LinearInterpolate (float64 (_cebc ),0,65535,decode [0],decode [1]))&_aefg );_fgad =uint16 (uint64 (LinearInterpolate (float64 (_fgad ),0,65535,decode [2],decode [3]))&_aefg );
_geeg =uint16 (uint64 (LinearInterpolate (float64 (_geeg ),0,65535,decode [4],decode [5]))&_aefg );};return _f .NRGBA64 {R :_cebc ,G :_fgad ,B :_geeg ,A :_gdbf },nil ;};func (_dead *CMYK32 )Validate ()error {if len (_dead .Data )!=4*_dead .Width *_dead .Height {return _d .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};type monochromeThresholdConverter struct{Threshold uint8 ;};func (_dbgb *Monochrome )Set (x ,y int ,c _f .Color ){_bfggf :=y *_dbgb .BytesPerLine +x >>3;if _bfggf > len (_dbgb .Data )-1{return ;};_fbag :=_dbgb .ColorModel ().Convert (c ).(_f .Gray );
_dbgb .setGray (x ,_fbag ,_bfggf );};func (_cfe *Gray2 )ColorAt (x ,y int )(_f .Color ,error ){return ColorAtGray2BPC (x ,y ,_cfe .BytesPerLine ,_cfe .Data ,_cfe .Decode );};type Gray16 struct{ImageBase };type SMasker interface{HasAlpha ()bool ;GetAlpha ()[]byte ;
MakeAlpha ();};func (_cgde *CMYK32 )Set (x ,y int ,c _f .Color ){_efb :=4*(y *_cgde .Width +x );if _efb +3>=len (_cgde .Data ){return ;};_affa :=_f .CMYKModel .Convert (c ).(_f .CMYK );_cgde .Data [_efb ]=_affa .C ;_cgde .Data [_efb +1]=_affa .M ;_cgde .Data [_efb +2]=_affa .Y ;
_cgde .Data [_efb +3]=_affa .K ;};func (_ecf *Monochrome )InverseData ()error {return _ecf .RasterOperation (0,0,_ecf .Width ,_ecf .Height ,PixNotDst ,nil ,0,0);};func ColorAtGray1BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_f .Gray ,error ){_efac :=y *bytesPerLine +x >>3;
if _efac >=len (data ){return _f .Gray {},_ee .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_eagf :=data [_efac ]>>uint (7-(x &7))&1;if len (decode )==2{_eagf =uint8 (LinearInterpolate (float64 (_eagf ),0.0,1.0,decode [0],decode [1]))&1;};return _f .Gray {Y :_eagf *255},nil ;};func (_bacc *Gray4 )Histogram ()(_bgg [256]int ){for _geca :=0;_geca < _bacc .Width ;
_geca ++{for _bgc :=0;_bgc < _bacc .Height ;_bgc ++{_bgg [_bacc .GrayAt (_geca ,_bgc ).Y ]++;};};return _bgg ;};func _bec (_fafb *Monochrome ,_dacc ,_accc ,_bdgb ,_bcdd int ,_ddac RasterOperator ,_gdf *Monochrome ,_fcgb ,_effb int )error {if _fafb ==nil {return _d .New ("\u006e\u0069\u006c\u0020\u0027\u0064\u0065\u0073\u0074\u0027\u0020\u0042i\u0074\u006d\u0061\u0070");
};if _ddac ==PixDst {return nil ;};switch _ddac {case PixClr ,PixSet ,PixNotDst :_eafa (_fafb ,_dacc ,_accc ,_bdgb ,_bcdd ,_ddac );return nil ;};if _gdf ==nil {_eed .Log .Debug ("\u0052a\u0073\u0074e\u0072\u004f\u0070\u0065r\u0061\u0074\u0069o\u006e\u0020\u0073\u006f\u0075\u0072\u0063\u0065\u0020bi\u0074\u006d\u0061p\u0020\u0069s\u0020\u006e\u006f\u0074\u0020\u0064e\u0066\u0069n\u0065\u0064");
return _d .New ("\u006e\u0069l\u0020\u0027\u0073r\u0063\u0027\u0020\u0062\u0069\u0074\u006d\u0061\u0070");};if _bdga :=_dabg (_fafb ,_dacc ,_accc ,_bdgb ,_bcdd ,_ddac ,_gdf ,_fcgb ,_effb );_bdga !=nil {return _bdga ;};return nil ;};func (_dda *Monochrome )setIndexedBit (_caca int ){_dda .Data [(_caca >>3)]|=0x80>>uint (_caca &7)};
var (_aee =_bdb ();_dga =_aca ();_cg =_gbdb (););func _bgcg (_aecc *Monochrome ,_dfea ,_dcf ,_eedc ,_cdda int ,_acafd RasterOperator ,_babb *Monochrome ,_dbda ,_eaf int )error {var (_bcdg byte ;_baaa int ;_bca int ;_dbdac ,_beff int ;_bge ,_ffbb int ;);
_gedg :=_eedc >>3;_eggg :=_eedc &7;if _eggg > 0{_bcdg =_gbba [_eggg ];};_baaa =_babb .BytesPerLine *_eaf +(_dbda >>3);_bca =_aecc .BytesPerLine *_dcf +(_dfea >>3);switch _acafd {case PixSrc :for _bge =0;_bge < _cdda ;_bge ++{_dbdac =_baaa +_bge *_babb .BytesPerLine ;
_beff =_bca +_bge *_aecc .BytesPerLine ;for _ffbb =0;_ffbb < _gedg ;_ffbb ++{_aecc .Data [_beff ]=_babb .Data [_dbdac ];_beff ++;_dbdac ++;};if _eggg > 0{_aecc .Data [_beff ]=_cbcd (_aecc .Data [_beff ],_babb .Data [_dbdac ],_bcdg );};};case PixNotSrc :for _bge =0;
_bge < _cdda ;_bge ++{_dbdac =_baaa +_bge *_babb .BytesPerLine ;_beff =_bca +_bge *_aecc .BytesPerLine ;for _ffbb =0;_ffbb < _gedg ;_ffbb ++{_aecc .Data [_beff ]=^(_babb .Data [_dbdac ]);_beff ++;_dbdac ++;};if _eggg > 0{_aecc .Data [_beff ]=_cbcd (_aecc .Data [_beff ],^_babb .Data [_dbdac ],_bcdg );
};};case PixSrcOrDst :for _bge =0;_bge < _cdda ;_bge ++{_dbdac =_baaa +_bge *_babb .BytesPerLine ;_beff =_bca +_bge *_aecc .BytesPerLine ;for _ffbb =0;_ffbb < _gedg ;_ffbb ++{_aecc .Data [_beff ]|=_babb .Data [_dbdac ];_beff ++;_dbdac ++;};if _eggg > 0{_aecc .Data [_beff ]=_cbcd (_aecc .Data [_beff ],_babb .Data [_dbdac ]|_aecc .Data [_beff ],_bcdg );
};};case PixSrcAndDst :for _bge =0;_bge < _cdda ;_bge ++{_dbdac =_baaa +_bge *_babb .BytesPerLine ;_beff =_bca +_bge *_aecc .BytesPerLine ;for _ffbb =0;_ffbb < _gedg ;_ffbb ++{_aecc .Data [_beff ]&=_babb .Data [_dbdac ];_beff ++;_dbdac ++;};if _eggg > 0{_aecc .Data [_beff ]=_cbcd (_aecc .Data [_beff ],_babb .Data [_dbdac ]&_aecc .Data [_beff ],_bcdg );
};};case PixSrcXorDst :for _bge =0;_bge < _cdda ;_bge ++{_dbdac =_baaa +_bge *_babb .BytesPerLine ;_beff =_bca +_bge *_aecc .BytesPerLine ;for _ffbb =0;_ffbb < _gedg ;_ffbb ++{_aecc .Data [_beff ]^=_babb .Data [_dbdac ];_beff ++;_dbdac ++;};if _eggg > 0{_aecc .Data [_beff ]=_cbcd (_aecc .Data [_beff ],_babb .Data [_dbdac ]^_aecc .Data [_beff ],_bcdg );
};};case PixNotSrcOrDst :for _bge =0;_bge < _cdda ;_bge ++{_dbdac =_baaa +_bge *_babb .BytesPerLine ;_beff =_bca +_bge *_aecc .BytesPerLine ;for _ffbb =0;_ffbb < _gedg ;_ffbb ++{_aecc .Data [_beff ]|=^(_babb .Data [_dbdac ]);_beff ++;_dbdac ++;};if _eggg > 0{_aecc .Data [_beff ]=_cbcd (_aecc .Data [_beff ],^(_babb .Data [_dbdac ])|_aecc .Data [_beff ],_bcdg );
};};case PixNotSrcAndDst :for _bge =0;_bge < _cdda ;_bge ++{_dbdac =_baaa +_bge *_babb .BytesPerLine ;_beff =_bca +_bge *_aecc .BytesPerLine ;for _ffbb =0;_ffbb < _gedg ;_ffbb ++{_aecc .Data [_beff ]&=^(_babb .Data [_dbdac ]);_beff ++;_dbdac ++;};if _eggg > 0{_aecc .Data [_beff ]=_cbcd (_aecc .Data [_beff ],^(_babb .Data [_dbdac ])&_aecc .Data [_beff ],_bcdg );
};};case PixSrcOrNotDst :for _bge =0;_bge < _cdda ;_bge ++{_dbdac =_baaa +_bge *_babb .BytesPerLine ;_beff =_bca +_bge *_aecc .BytesPerLine ;for _ffbb =0;_ffbb < _gedg ;_ffbb ++{_aecc .Data [_beff ]=_babb .Data [_dbdac ]|^(_aecc .Data [_beff ]);_beff ++;
_dbdac ++;};if _eggg > 0{_aecc .Data [_beff ]=_cbcd (_aecc .Data [_beff ],_babb .Data [_dbdac ]|^(_aecc .Data [_beff ]),_bcdg );};};case PixSrcAndNotDst :for _bge =0;_bge < _cdda ;_bge ++{_dbdac =_baaa +_bge *_babb .BytesPerLine ;_beff =_bca +_bge *_aecc .BytesPerLine ;
for _ffbb =0;_ffbb < _gedg ;_ffbb ++{_aecc .Data [_beff ]=_babb .Data [_dbdac ]&^(_aecc .Data [_beff ]);_beff ++;_dbdac ++;};if _eggg > 0{_aecc .Data [_beff ]=_cbcd (_aecc .Data [_beff ],_babb .Data [_dbdac ]&^(_aecc .Data [_beff ]),_bcdg );};};case PixNotPixSrcOrDst :for _bge =0;
_bge < _cdda ;_bge ++{_dbdac =_baaa +_bge *_babb .BytesPerLine ;_beff =_bca +_bge *_aecc .BytesPerLine ;for _ffbb =0;_ffbb < _gedg ;_ffbb ++{_aecc .Data [_beff ]=^(_babb .Data [_dbdac ]|_aecc .Data [_beff ]);_beff ++;_dbdac ++;};if _eggg > 0{_aecc .Data [_beff ]=_cbcd (_aecc .Data [_beff ],^(_babb .Data [_dbdac ]|_aecc .Data [_beff ]),_bcdg );
};};case PixNotPixSrcAndDst :for _bge =0;_bge < _cdda ;_bge ++{_dbdac =_baaa +_bge *_babb .BytesPerLine ;_beff =_bca +_bge *_aecc .BytesPerLine ;for _ffbb =0;_ffbb < _gedg ;_ffbb ++{_aecc .Data [_beff ]=^(_babb .Data [_dbdac ]&_aecc .Data [_beff ]);_beff ++;
_dbdac ++;};if _eggg > 0{_aecc .Data [_beff ]=_cbcd (_aecc .Data [_beff ],^(_babb .Data [_dbdac ]&_aecc .Data [_beff ]),_bcdg );};};case PixNotPixSrcXorDst :for _bge =0;_bge < _cdda ;_bge ++{_dbdac =_baaa +_bge *_babb .BytesPerLine ;_beff =_bca +_bge *_aecc .BytesPerLine ;
for _ffbb =0;_ffbb < _gedg ;_ffbb ++{_aecc .Data [_beff ]=^(_babb .Data [_dbdac ]^_aecc .Data [_beff ]);_beff ++;_dbdac ++;};if _eggg > 0{_aecc .Data [_beff ]=_cbcd (_aecc .Data [_beff ],^(_babb .Data [_dbdac ]^_aecc .Data [_beff ]),_bcdg );};};default:_eed .Log .Debug ("\u0050\u0072ov\u0069\u0064\u0065d\u0020\u0069\u006e\u0076ali\u0064 r\u0061\u0073\u0074\u0065\u0072\u0020\u006fpe\u0072\u0061\u0074\u006f\u0072\u003a\u0020%\u0076",_acafd );
return _d .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072");};return nil ;};func (_dcfd *NRGBA64 )At (x ,y int )_f .Color {_ggfc ,_ :=_dcfd .ColorAt (x ,y );return _ggfc };
func _bacae (_gddg _f .NRGBA )_f .NRGBA {_gddg .R =_gddg .R >>4|(_gddg .R >>4)<<4;_gddg .G =_gddg .G >>4|(_gddg .G >>4)<<4;_gddg .B =_gddg .B >>4|(_gddg .B >>4)<<4;return _gddg ;};func (_cbfab *Gray8 )SetGray (x ,y int ,g _f .Gray ){_gdca :=y *_cbfab .BytesPerLine +x ;
if _gdca > len (_cbfab .Data )-1{return ;};_cbfab .Data [_gdca ]=g .Y ;};func _fcad (_fgbf _f .Gray )_f .Gray {_fgbf .Y >>=4;_fgbf .Y |=_fgbf .Y <<4;return _fgbf };type Gray2 struct{ImageBase };func _cdee (_eege *Monochrome ,_ebda ,_dfada int ,_fbcc ,_eegb int ,_dgfg RasterOperator ){var (_gafgb bool ;
_cfd bool ;_cbcf int ;_efgg int ;_fagf int ;_ggbbd int ;_adae bool ;_bbf byte ;);_bcfa :=8-(_ebda &7);_fcaf :=_ccga [_bcfa ];_cbfaa :=_eege .BytesPerLine *_dfada +(_ebda >>3);if _fbcc < _bcfa {_gafgb =true ;_fcaf &=_gbba [8-_bcfa +_fbcc ];};if !_gafgb {_cbcf =(_fbcc -_bcfa )>>3;
if _cbcf !=0{_cfd =true ;_efgg =_cbfaa +1;};};_fagf =(_ebda +_fbcc )&7;if !(_gafgb ||_fagf ==0){_adae =true ;_bbf =_gbba [_fagf ];_ggbbd =_cbfaa +1+_cbcf ;};var _ggagf ,_feea int ;switch _dgfg {case PixClr :for _ggagf =0;_ggagf < _eegb ;_ggagf ++{_eege .Data [_cbfaa ]=_cbcd (_eege .Data [_cbfaa ],0x0,_fcaf );
_cbfaa +=_eege .BytesPerLine ;};if _cfd {for _ggagf =0;_ggagf < _eegb ;_ggagf ++{for _feea =0;_feea < _cbcf ;_feea ++{_eege .Data [_efgg +_feea ]=0x0;};_efgg +=_eege .BytesPerLine ;};};if _adae {for _ggagf =0;_ggagf < _eegb ;_ggagf ++{_eege .Data [_ggbbd ]=_cbcd (_eege .Data [_ggbbd ],0x0,_bbf );
_ggbbd +=_eege .BytesPerLine ;};};case PixSet :for _ggagf =0;_ggagf < _eegb ;_ggagf ++{_eege .Data [_cbfaa ]=_cbcd (_eege .Data [_cbfaa ],0xff,_fcaf );_cbfaa +=_eege .BytesPerLine ;};if _cfd {for _ggagf =0;_ggagf < _eegb ;_ggagf ++{for _feea =0;_feea < _cbcf ;
_feea ++{_eege .Data [_efgg +_feea ]=0xff;};_efgg +=_eege .BytesPerLine ;};};if _adae {for _ggagf =0;_ggagf < _eegb ;_ggagf ++{_eege .Data [_ggbbd ]=_cbcd (_eege .Data [_ggbbd ],0xff,_bbf );_ggbbd +=_eege .BytesPerLine ;};};case PixNotDst :for _ggagf =0;
_ggagf < _eegb ;_ggagf ++{_eege .Data [_cbfaa ]=_cbcd (_eege .Data [_cbfaa ],^_eege .Data [_cbfaa ],_fcaf );_cbfaa +=_eege .BytesPerLine ;};if _cfd {for _ggagf =0;_ggagf < _eegb ;_ggagf ++{for _feea =0;_feea < _cbcf ;_feea ++{_eege .Data [_efgg +_feea ]=^(_eege .Data [_efgg +_feea ]);
};_efgg +=_eege .BytesPerLine ;};};if _adae {for _ggagf =0;_ggagf < _eegb ;_ggagf ++{_eege .Data [_ggbbd ]=_cbcd (_eege .Data [_ggbbd ],^_eege .Data [_ggbbd ],_bbf );_ggbbd +=_eege .BytesPerLine ;};};};};func (_ccce *ImageBase )getByte (_acfa int )(byte ,error ){if _acfa > len (_ccce .Data )-1||_acfa < 0{return 0,_ee .Errorf ("\u0069\u006e\u0064\u0065x:\u0020\u0025\u0064\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006eg\u0065",_acfa );
};return _ccce .Data [_acfa ],nil ;};var _ _e .Image =&NRGBA64 {};func ColorAtGray8BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_f .Gray ,error ){_bead :=y *bytesPerLine +x ;if _bead >=len (data ){return _f .Gray {},_ee .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_gdce :=data [_bead ];if len (decode )==2{_gdce =uint8 (uint32 (LinearInterpolate (float64 (_gdce ),0,255,decode [0],decode [1]))&0xff);};return _f .Gray {Y :_gdce },nil ;};func (_bebd *Gray4 )Set (x ,y int ,c _f .Color ){if x >=_bebd .Width ||y >=_bebd .Height {return ;
};_agc :=Gray4Model .Convert (c ).(_f .Gray );_bebd .setGray (x ,y ,_agc );};func _eef (){for _gafg :=0;_gafg < 256;_gafg ++{_cgdd [_gafg ]=uint8 (_gafg &0x1)+(uint8 (_gafg >>1)&0x1)+(uint8 (_gafg >>2)&0x1)+(uint8 (_gafg >>3)&0x1)+(uint8 (_gafg >>4)&0x1)+(uint8 (_gafg >>5)&0x1)+(uint8 (_gafg >>6)&0x1)+(uint8 (_gafg >>7)&0x1);
};};func _dcec (_gcbaa _e .Image )(Image ,error ){if _adad ,_aaff :=_gcbaa .(*Gray4 );_aaff {return _adad .Copy (),nil ;};_decc :=_gcbaa .Bounds ();_aafb ,_gecd :=NewImage (_decc .Max .X ,_decc .Max .Y ,4,1,nil ,nil ,nil );if _gecd !=nil {return nil ,_gecd ;
};_agge (_gcbaa ,_aafb ,_decc );return _aafb ,nil ;};func MonochromeThresholdConverter (threshold uint8 )ColorConverter {return &monochromeThresholdConverter {Threshold :threshold };};func (_cgef *Gray16 )Set (x ,y int ,c _f .Color ){_face :=(y *_cgef .BytesPerLine /2+x )*2;
if _face +1>=len (_cgef .Data ){return ;};_eagc :=_f .Gray16Model .Convert (c ).(_f .Gray16 );_cgef .Data [_face ],_cgef .Data [_face +1]=uint8 (_eagc .Y >>8),uint8 (_eagc .Y &0xff);};var (MonochromeConverter =ConverterFunc (_ccf );Gray2Converter =ConverterFunc (_gfeb );
Gray4Converter =ConverterFunc (_dcec );GrayConverter =ConverterFunc (_ffdd );Gray16Converter =ConverterFunc (_ggc );NRGBA16Converter =ConverterFunc (_dagf );NRGBAConverter =ConverterFunc (_baeb );NRGBA64Converter =ConverterFunc (_gfed );CMYKConverter =ConverterFunc (_adbd );
);func _fca (_abfd ,_eba CMYK ,_cbeb _e .Rectangle ){for _deb :=0;_deb < _cbeb .Max .X ;_deb ++{for _dgb :=0;_dgb < _cbeb .Max .Y ;_dgb ++{_eba .SetCMYK (_deb ,_dgb ,_abfd .CMYKAt (_deb ,_dgb ));};};};const (PixSrc RasterOperator =0xc;PixDst RasterOperator =0xa;
PixNotSrc RasterOperator =0x3;PixNotDst RasterOperator =0x5;PixClr RasterOperator =0x0;PixSet RasterOperator =0xf;PixSrcOrDst RasterOperator =0xe;PixSrcAndDst RasterOperator =0x8;PixSrcXorDst RasterOperator =0x6;PixNotSrcOrDst RasterOperator =0xb;PixNotSrcAndDst RasterOperator =0x2;
PixSrcOrNotDst RasterOperator =0xd;PixSrcAndNotDst RasterOperator =0x4;PixNotPixSrcOrDst RasterOperator =0x1;PixNotPixSrcAndDst RasterOperator =0x7;PixNotPixSrcXorDst RasterOperator =0x9;PixPaint =PixSrcOrDst ;PixSubtract =PixNotSrcAndDst ;PixMask =PixSrcAndDst ;
);func (_cbgd *Monochrome )GrayAt (x ,y int )_f .Gray {_efcbb ,_ :=ColorAtGray1BPC (x ,y ,_cbgd .BytesPerLine ,_cbgd .Data ,_cbgd .Decode );return _efcbb ;};type NRGBA32 struct{ImageBase };func (_bdd *Gray16 )GrayAt (x ,y int )_f .Gray {_dfde ,_ :=_bdd .ColorAt (x ,y );
return _f .Gray {Y :uint8 (_dfde .(_f .Gray16 ).Y >>8)};};func (_bccc *Gray4 )ColorModel ()_f .Model {return Gray4Model };func _adgga (_eegc RGBA ,_abag NRGBA ,_aagf _e .Rectangle ){for _ggdf :=0;_ggdf < _aagf .Max .X ;_ggdf ++{for _gcgc :=0;_gcgc < _aagf .Max .Y ;
_gcgc ++{_cfbbg :=_eegc .RGBAAt (_ggdf ,_gcgc );_abag .SetNRGBA (_ggdf ,_gcgc ,_dbe (_cfbbg ));};};};func (_eecb *NRGBA32 )Validate ()error {if len (_eecb .Data )!=3*_eecb .Width *_eecb .Height {return _d .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func _eafa (_cecd *Monochrome ,_efdca ,_cbbd ,_afdb ,_gfde int ,_deff RasterOperator ){if _efdca < 0{_afdb +=_efdca ;_efdca =0;};_aabe :=_efdca +_afdb -_cecd .Width ;if _aabe > 0{_afdb -=_aabe ;};if _cbbd < 0{_gfde +=_cbbd ;_cbbd =0;};_edga :=_cbbd +_gfde -_cecd .Height ;
if _edga > 0{_gfde -=_edga ;};if _afdb <=0||_gfde <=0{return ;};if (_efdca &7)==0{_cfbe (_cecd ,_efdca ,_cbbd ,_afdb ,_gfde ,_deff );}else {_cdee (_cecd ,_efdca ,_cbbd ,_afdb ,_gfde ,_deff );};};func (_gcdc *ImageBase )setEightFullBytes (_acdc int ,_dgaf uint64 )error {if _acdc +7> len (_gcdc .Data )-1{return _d .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_gcdc .Data [_acdc ]=byte ((_dgaf &0xff00000000000000)>>56);_gcdc .Data [_acdc +1]=byte ((_dgaf &0xff000000000000)>>48);_gcdc .Data [_acdc +2]=byte ((_dgaf &0xff0000000000)>>40);_gcdc .Data [_acdc +3]=byte ((_dgaf &0xff00000000)>>32);_gcdc .Data [_acdc +4]=byte ((_dgaf &0xff000000)>>24);
_gcdc .Data [_acdc +5]=byte ((_dgaf &0xff0000)>>16);_gcdc .Data [_acdc +6]=byte ((_dgaf &0xff00)>>8);_gcdc .Data [_acdc +7]=byte (_dgaf &0xff);return nil ;};func (_bcab *NRGBA16 )ColorModel ()_f .Model {return NRGBA16Model };func (_bcfad *NRGBA16 )Bounds ()_e .Rectangle {return _e .Rectangle {Max :_e .Point {X :_bcfad .Width ,Y :_bcfad .Height }};
};func (_ddga *Monochrome )Scale (scale float64 )(*Monochrome ,error ){var _deadf bool ;_fda :=scale ;if scale < 1{_fda =1/scale ;_deadf =true ;};_gacc :=NextPowerOf2 (uint (_fda ));if InDelta (float64 (_gacc ),_fda ,0.001){if _deadf {return _ddga .ReduceBinary (_fda );
};return _ddga .ExpandBinary (int (_gacc ));};_fafd :=int (_df .RoundToEven (float64 (_ddga .Width )*scale ));_bbed :=int (_df .RoundToEven (float64 (_ddga .Height )*scale ));return _ddga .ScaleLow (_fafd ,_bbed );};var _ _e .Image =&Monochrome {};func (_cbfa *Monochrome )Bounds ()_e .Rectangle {return _e .Rectangle {Max :_e .Point {X :_cbfa .Width ,Y :_cbfa .Height }};
};type Image interface{_gb .Image ;Base ()*ImageBase ;Copy ()Image ;Pix ()[]byte ;ColorAt (_ggegf ,_facd int )(_f .Color ,error );Validate ()error ;};func _cfbe (_baaag *Monochrome ,_eecf ,_cdaff int ,_dbef ,_fcbd int ,_ebee RasterOperator ){var (_abgea int ;
_eagbd byte ;_cffa ,_aadec int ;_ecbe int ;);_cgbe :=_dbef >>3;_edce :=_dbef &7;if _edce > 0{_eagbd =_gbba [_edce ];};_abgea =_baaag .BytesPerLine *_cdaff +(_eecf >>3);switch _ebee {case PixClr :for _cffa =0;_cffa < _fcbd ;_cffa ++{_ecbe =_abgea +_cffa *_baaag .BytesPerLine ;
for _aadec =0;_aadec < _cgbe ;_aadec ++{_baaag .Data [_ecbe ]=0x0;_ecbe ++;};if _edce > 0{_baaag .Data [_ecbe ]=_cbcd (_baaag .Data [_ecbe ],0x0,_eagbd );};};case PixSet :for _cffa =0;_cffa < _fcbd ;_cffa ++{_ecbe =_abgea +_cffa *_baaag .BytesPerLine ;
for _aadec =0;_aadec < _cgbe ;_aadec ++{_baaag .Data [_ecbe ]=0xff;_ecbe ++;};if _edce > 0{_baaag .Data [_ecbe ]=_cbcd (_baaag .Data [_ecbe ],0xff,_eagbd );};};case PixNotDst :for _cffa =0;_cffa < _fcbd ;_cffa ++{_ecbe =_abgea +_cffa *_baaag .BytesPerLine ;
for _aadec =0;_aadec < _cgbe ;_aadec ++{_baaag .Data [_ecbe ]=^_baaag .Data [_ecbe ];_ecbe ++;};if _edce > 0{_baaag .Data [_ecbe ]=_cbcd (_baaag .Data [_ecbe ],^_baaag .Data [_ecbe ],_eagbd );};};};};func _ede (_fbbd _f .NYCbCrA )_f .NRGBA {_adff :=int32 (_fbbd .Y )*0x10101;
_fag :=int32 (_fbbd .Cb )-128;_cdca :=int32 (_fbbd .Cr )-128;_dca :=_adff +91881*_cdca ;if uint32 (_dca )&0xff000000==0{_dca >>=8;}else {_dca =^(_dca >>31)&0xffff;};_cedb :=_adff -22554*_fag -46802*_cdca ;if uint32 (_cedb )&0xff000000==0{_cedb >>=8;}else {_cedb =^(_cedb >>31)&0xffff;
};_cdb :=_adff +116130*_fag ;if uint32 (_cdb )&0xff000000==0{_cdb >>=8;}else {_cdb =^(_cdb >>31)&0xffff;};return _f .NRGBA {R :uint8 (_dca >>8),G :uint8 (_cedb >>8),B :uint8 (_cdb >>8),A :_fbbd .A };};func (_acea *Monochrome )ScaleLow (width ,height int )(*Monochrome ,error ){if width < 0||height < 0{return nil ,_d .New ("\u0070\u0072\u006f\u0076\u0069\u0064e\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0069\u0064t\u0068\u0020\u0061\u006e\u0064\u0020\u0068e\u0069\u0067\u0068\u0074");
};_dgde :=_cdc (width ,height );_fee :=make ([]int ,height );_dafc :=make ([]int ,width );_dafa :=float64 (_acea .Width )/float64 (width );_fcd :=float64 (_acea .Height )/float64 (height );for _efa :=0;_efa < height ;_efa ++{_fee [_efa ]=int (_df .Min (_fcd *float64 (_efa )+0.5,float64 (_acea .Height -1)));
};for _eece :=0;_eece < width ;_eece ++{_dafc [_eece ]=int (_df .Min (_dafa *float64 (_eece )+0.5,float64 (_acea .Width -1)));};_gcaa :=-1;_bdf :=byte (0);for _aeac :=0;_aeac < height ;_aeac ++{_ecage :=_fee [_aeac ]*_acea .BytesPerLine ;_dfa :=_aeac *_dgde .BytesPerLine ;
for _bba :=0;_bba < width ;_bba ++{_debe :=_dafc [_bba ];if _debe !=_gcaa {_bdf =_acea .getBit (_ecage ,_debe );if _bdf !=0{_dgde .setBit (_dfa ,_bba );};_gcaa =_debe ;}else {if _bdf !=0{_dgde .setBit (_dfa ,_bba );};};};};return _dgde ,nil ;};func (_acd monochromeModel )Convert (c _f .Color )_f .Color {_eeec :=_f .GrayModel .Convert (c ).(_f .Gray );
return _fgg (_eeec ,_acd );};var _ Gray =&Gray16 {};func _fed (_geg *Monochrome ,_eg ,_fd int )(*Monochrome ,error ){if _geg ==nil {return nil ,_d .New ("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064");};if _eg <=0||_fd <=0{return nil ,_d .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0073\u0063\u0061l\u0065\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020<\u003d\u0020\u0030");
};if _eg ==_fd {if _eg ==1{return _geg .copy (),nil ;};if _eg ==2||_eg ==4||_eg ==8{_adg ,_cff :=_ea (_geg ,_eg );if _cff !=nil {return nil ,_cff ;};return _adg ,nil ;};};_gd :=_eg *_geg .Width ;_dfb :=_fd *_geg .Height ;_ce :=_cdc (_gd ,_dfb );_aef :=_ce .BytesPerLine ;
var (_dfg ,_adb ,_bg ,_dgd ,_bgf int ;_dea byte ;_adga error ;);for _adb =0;_adb < _geg .Height ;_adb ++{_dfg =_fd *_adb *_aef ;for _bg =0;_bg < _geg .Width ;_bg ++{if _gc :=_geg .getBitAt (_bg ,_adb );_gc {_bgf =_eg *_bg ;for _dgd =0;_dgd < _eg ;_dgd ++{_ce .setIndexedBit (_dfg *8+_bgf +_dgd );
};};};for _dgd =1;_dgd < _fd ;_dgd ++{_fbb :=_dfg +_dgd *_aef ;for _gga :=0;_gga < _aef ;_gga ++{if _dea ,_adga =_ce .getByte (_dfg +_gga );_adga !=nil {return nil ,_adga ;};if _adga =_ce .setByte (_fbb +_gga ,_dea );_adga !=nil {return nil ,_adga ;};};
};};return _ce ,nil ;};type CMYK32 struct{ImageBase };func _cebd (_egdc _e .Image ,_bdfb uint8 )*_e .Gray {_cgg :=_egdc .Bounds ();_bcdc :=_e .NewGray (_cgg );var (_bcfg _f .Color ;_cfbg _f .Gray ;);for _eacb :=0;_eacb < _cgg .Max .X ;_eacb ++{for _gcdd :=0;
_gcdd < _cgg .Max .Y ;_gcdd ++{_bcfg =_egdc .At (_eacb ,_gcdd );_bcdc .Set (_eacb ,_gcdd ,_bcfg );_cfbg =_bcdc .GrayAt (_eacb ,_gcdd );_bcdc .SetGray (_eacb ,_gcdd ,_f .Gray {Y :_fbad (_cfbg .Y ,_bdfb )});};};return _bcdc ;};func (_gda *CMYK32 )SetCMYK (x ,y int ,c _f .CMYK ){_ccd :=4*(y *_gda .Width +x );
if _ccd +3>=len (_gda .Data ){return ;};_gda .Data [_ccd ]=c .C ;_gda .Data [_ccd +1]=c .M ;_gda .Data [_ccd +2]=c .Y ;_gda .Data [_ccd +3]=c .K ;};func _gbdb ()(_dgf [256]uint64 ){for _ded :=0;_ded < 256;_ded ++{if _ded &0x01!=0{_dgf [_ded ]|=0xff;};if _ded &0x02!=0{_dgf [_ded ]|=0xff00;
};if _ded &0x04!=0{_dgf [_ded ]|=0xff0000;};if _ded &0x08!=0{_dgf [_ded ]|=0xff000000;};if _ded &0x10!=0{_dgf [_ded ]|=0xff00000000;};if _ded &0x20!=0{_dgf [_ded ]|=0xff0000000000;};if _ded &0x40!=0{_dgf [_ded ]|=0xff000000000000;};if _ded &0x80!=0{_dgf [_ded ]|=0xff00000000000000;
};};return _dgf ;};func (_dgfe *Gray4 )Validate ()error {if len (_dgfe .Data )!=_dgfe .Height *_dgfe .BytesPerLine {return ErrInvalidImage ;};return nil ;};func BytesPerLine (width ,bitsPerComponent ,colorComponents int )int {return ((width *bitsPerComponent )*colorComponents +7)>>3;
};type Gray interface{GrayAt (_gdg ,_ceb int )_f .Gray ;SetGray (_gcbe ,_aefda int ,_ffc _f .Gray );};func (_fdgb *ImageBase )setFourBytes (_bgdb int ,_cgfd uint32 )error {if _bgdb +3> len (_fdgb .Data )-1{return _ee .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006fu\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065",_bgdb );
};_fdgb .Data [_bgdb ]=byte ((_cgfd &0xff000000)>>24);_fdgb .Data [_bgdb +1]=byte ((_cgfd &0xff0000)>>16);_fdgb .Data [_bgdb +2]=byte ((_cgfd &0xff00)>>8);_fdgb .Data [_bgdb +3]=byte (_cgfd &0xff);return nil ;};func ConverterFunc (converterFunc func (_ddg _e .Image )(Image ,error ))ColorConverter {return colorConverter {_deba :converterFunc };
};func _afe (_eecd ,_eeb *Monochrome ,_agd []byte ,_gag int )(_gbfbe error ){var (_fbf ,_gbb ,_ced ,_ggfb ,_gac ,_dgdc ,_fae ,_ed int ;_cbaa ,_fga uint32 ;_efg ,_gbfd byte ;_eaae uint16 ;);_bce :=make ([]byte ,4);_dc :=make ([]byte ,4);for _ced =0;_ced < _eecd .Height -1;
_ced ,_ggfb =_ced +2,_ggfb +1{_fbf =_ced *_eecd .BytesPerLine ;_gbb =_ggfb *_eeb .BytesPerLine ;for _gac ,_dgdc =0,0;_gac < _gag ;_gac ,_dgdc =_gac +4,_dgdc +1{for _fae =0;_fae < 4;_fae ++{_ed =_fbf +_gac +_fae ;if _ed <=len (_eecd .Data )-1&&_ed < _fbf +_eecd .BytesPerLine {_bce [_fae ]=_eecd .Data [_ed ];
}else {_bce [_fae ]=0x00;};_ed =_fbf +_eecd .BytesPerLine +_gac +_fae ;if _ed <=len (_eecd .Data )-1&&_ed < _fbf +(2*_eecd .BytesPerLine ){_dc [_fae ]=_eecd .Data [_ed ];}else {_dc [_fae ]=0x00;};};_cbaa =_dd .BigEndian .Uint32 (_bce );_fga =_dd .BigEndian .Uint32 (_dc );
_fga |=_cbaa ;_fga |=_fga <<1;_fga &=0xaaaaaaaa;_cbaa =_fga |(_fga <<7);_efg =byte (_cbaa >>24);_gbfd =byte ((_cbaa >>8)&0xff);_ed =_gbb +_dgdc ;if _ed +1==len (_eeb .Data )-1||_ed +1>=_gbb +_eeb .BytesPerLine {_eeb .Data [_ed ]=_agd [_efg ];}else {_eaae =(uint16 (_agd [_efg ])<<8)|uint16 (_agd [_gbfd ]);
if _gbfbe =_eeb .setTwoBytes (_ed ,_eaae );_gbfbe !=nil {return _ee .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_ed );
};_dgdc ++;};};};return nil ;};func _dbdf (_beda _e .Image ,_cddd int )(_e .Rectangle ,bool ,[]byte ){_faee :=_beda .Bounds ();var (_eacg bool ;_fgeb []byte ;);switch _ffef :=_beda .(type ){case SMasker :_eacg =_ffef .HasAlpha ();case NRGBA ,RGBA ,*_e .RGBA64 ,nrgba64 ,*_e .NYCbCrA :_fgeb =make ([]byte ,_faee .Max .X *_faee .Max .Y *_cddd );
case *_e .Paletted :var _gbcd bool ;for _ ,_acfd :=range _ffef .Palette {_ebeb ,_eabd ,_afaf ,_gceb :=_acfd .RGBA ();if _ebeb ==0&&_eabd ==0&&_afaf ==0&&_gceb !=0{_gbcd =true ;break ;};};if _gbcd {_fgeb =make ([]byte ,_faee .Max .X *_faee .Max .Y *_cddd );
};};return _faee ,_eacg ,_fgeb ;};func _ea (_ggf *Monochrome ,_gge int )(*Monochrome ,error ){if _ggf ==nil {return nil ,_d .New ("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064");};if _gge ==1{return _ggf .copy (),nil ;
};if !IsPowerOf2 (uint (_gge )){return nil ,_ee .Errorf ("\u0070\u0072\u006fvi\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006ci\u0064 \u0065x\u0070a\u006e\u0064\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_gge );};_ddd :=_bgff (_gge );
return _b (_ggf ,_gge ,_ddd );};func (_deg *Gray4 )GrayAt (x ,y int )_f .Gray {_ceeg ,_ :=ColorAtGray4BPC (x ,y ,_deg .BytesPerLine ,_deg .Data ,_deg .Decode );return _ceeg ;};func (_fgae *Gray4 )SetGray (x ,y int ,g _f .Gray ){if x >=_fgae .Width ||y >=_fgae .Height {return ;
};g =_fcad (g );_fgae .setGray (x ,y ,g );};func (_gdde *Gray8 )GrayAt (x ,y int )_f .Gray {_bgca ,_ :=ColorAtGray8BPC (x ,y ,_gdde .BytesPerLine ,_gdde .Data ,_gdde .Decode );return _bgca ;};func AutoThresholdTriangle (histogram [256]int )uint8 {var _eadb ,_ffaa ,_cbdd ,_befb int ;
for _ggcdd :=0;_ggcdd < len (histogram );_ggcdd ++{if histogram [_ggcdd ]> 0{_eadb =_ggcdd ;break ;};};if _eadb > 0{_eadb --;};for _aaab :=255;_aaab > 0;_aaab --{if histogram [_aaab ]> 0{_befb =_aaab ;break ;};};if _befb < 255{_befb ++;};for _fcda :=0;
_fcda < 256;_fcda ++{if histogram [_fcda ]> _ffaa {_cbdd =_fcda ;_ffaa =histogram [_fcda ];};};var _dfeag bool ;if (_cbdd -_eadb )< (_befb -_cbdd ){_dfeag =true ;var _efdgb int ;_eddc :=255;for _efdgb < _eddc {_fggg :=histogram [_efdgb ];histogram [_efdgb ]=histogram [_eddc ];
histogram [_eddc ]=_fggg ;_efdgb ++;_eddc --;};_eadb =255-_befb ;_cbdd =255-_cbdd ;};if _eadb ==_cbdd {return uint8 (_eadb );};_dbbe :=float64 (histogram [_cbdd ]);_eeecg :=float64 (_eadb -_cbdd );_baaeb :=_df .Sqrt (_dbbe *_dbbe +_eeecg *_eeecg );_dbbe /=_baaeb ;
_eeecg /=_baaeb ;_baaeb =_dbbe *float64 (_eadb )+_eeecg *float64 (histogram [_eadb ]);_dcg :=_eadb ;var _gegcb float64 ;for _fgdba :=_eadb +1;_fgdba <=_cbdd ;_fgdba ++{_cccd :=_dbbe *float64 (_fgdba )+_eeecg *float64 (histogram [_fgdba ])-_baaeb ;if _cccd > _gegcb {_dcg =_fgdba ;
_gegcb =_cccd ;};};_dcg --;if _dfeag {var _fdge int ;_adag :=255;for _fdge < _adag {_beag :=histogram [_fdge ];histogram [_fdge ]=histogram [_adag ];histogram [_adag ]=_beag ;_fdge ++;_adag --;};return uint8 (255-_dcg );};return uint8 (_dcg );};func (_dcde *Monochrome )At (x ,y int )_f .Color {_edd ,_ :=_dcde .ColorAt (x ,y );
return _edd };func (_aggd *NRGBA64 )Copy ()Image {return &NRGBA64 {ImageBase :_aggd .copy ()}};func (_eeedd *ImageBase )setEightPartlyBytes (_febc ,_aebf int ,_aacf uint64 )(_ggg error ){var (_ceac byte ;_ggagaf int ;);for _cgcd :=1;_cgcd <=_aebf ;_cgcd ++{_ggagaf =64-_cgcd *8;
_ceac =byte (_aacf >>uint (_ggagaf )&0xff);if _ggg =_eeedd .setByte (_febc +_cgcd -1,_ceac );_ggg !=nil {return _ggg ;};};_ebdgd :=_eeedd .BytesPerLine *8-_eeedd .Width ;if _ebdgd ==0{return nil ;};_ggagaf -=8;_ceac =byte (_aacf >>uint (_ggagaf )&0xff)<<uint (_ebdgd );
if _ggg =_eeedd .setByte (_febc +_aebf ,_ceac );_ggg !=nil {return _ggg ;};return nil ;};func (_ggcd *NRGBA16 )Validate ()error {if len (_ggcd .Data )!=3*_ggcd .Width *_ggcd .Height /2{return _d .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func (_cbbf *Gray2 )Base ()*ImageBase {return &_cbbf .ImageBase };func _dagf (_bgfd _e .Image )(Image ,error ){if _fbcac ,_aabf :=_bgfd .(*NRGBA16 );_aabf {return _fbcac .Copy (),nil ;};_addg :=_bgfd .Bounds ();_dafeb ,_fcec :=NewImage (_addg .Max .X ,_addg .Max .Y ,4,3,nil ,nil ,nil );
if _fcec !=nil {return nil ,_fcec ;};_egbcf (_bgfd ,_dafeb ,_addg );return _dafeb ,nil ;};func _beb (_cgee _f .Gray )_f .NRGBA {return _f .NRGBA {R :_cgee .Y ,G :_cgee .Y ,B :_cgee .Y ,A :0xff}};func (_edg *Gray8 )ColorModel ()_f .Model {return _f .GrayModel };
var _ Gray =&Gray2 {};func _aaa ()(_bgb []byte ){_bgb =make ([]byte ,256);for _ggb :=0;_ggb < 256;_ggb ++{_ebgg :=byte (_ggb );_bgb [_ebgg ]=(_ebgg &0x01)|((_ebgg &0x04)>>1)|((_ebgg &0x10)>>2)|((_ebgg &0x40)>>3)|((_ebgg &0x02)<<3)|((_ebgg &0x08)<<2)|((_ebgg &0x20)<<1)|(_ebgg &0x80);
};return _bgb ;};func _gec (_eeef _f .NRGBA )_f .Gray {_aefd ,_bef ,_fccg ,_ :=_eeef .RGBA ();_bdbc :=(19595*_aefd +38470*_bef +7471*_fccg +1<<15)>>24;return _f .Gray {Y :uint8 (_bdbc )};};var _ Image =&NRGBA64 {};func (_eabga *Gray2 )Histogram ()(_ebe [256]int ){for _cfgcg :=0;
_cfgcg < _eabga .Width ;_cfgcg ++{for _cged :=0;_cged < _eabga .Height ;_cged ++{_ebe [_eabga .GrayAt (_cfgcg ,_cged ).Y ]++;};};return _ebe ;};type NRGBA interface{NRGBAAt (_ddcb ,_badd int )_f .NRGBA ;SetNRGBA (_gedb ,_ecab int ,_bdgae _f .NRGBA );};
func _fcgd (_bdea []byte ,_gedbg Image )error {_bgbd :=true ;for _gaaff :=0;_gaaff < len (_bdea );_gaaff ++{if _bdea [_gaaff ]!=0xff{_bgbd =false ;break ;};};if _bgbd {switch _bdee :=_gedbg .(type ){case *NRGBA32 :_bdee .Alpha =nil ;case *NRGBA64 :_bdee .Alpha =nil ;
default:return _ee .Errorf ("i\u006ete\u0072n\u0061l\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020i\u006d\u0061\u0067\u0065\u0020s\u0068\u006f\u0075l\u0064\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0074\u0079\u0070e\u0020\u002a\u004eRGB\u0041\u0033\u0032\u0020\u006f\u0072 \u002a\u004e\u0052\u0047\u0042\u0041\u0036\u0034\u0020\u0062\u0075\u0074 \u0069s\u003a\u0020\u0025\u0054",_gedbg );
};};return nil ;};func (_affb *CMYK32 )Base ()*ImageBase {return &_affb .ImageBase };func (_fgfb *ImageBase )setEightBytes (_cfgf int ,_gaba uint64 )error {_cdaf :=_fgfb .BytesPerLine -(_cfgf %_fgfb .BytesPerLine );if _fgfb .BytesPerLine !=_fgfb .Width >>3{_cdaf --;
};if _cdaf >=8{return _fgfb .setEightFullBytes (_cfgf ,_gaba );};return _fgfb .setEightPartlyBytes (_cfgf ,_cdaf ,_gaba );};func _bee (_fbe _f .NRGBA )_f .Gray {var _ebc _f .NRGBA ;if _fbe ==_ebc {return _f .Gray {Y :0xff};};_ccag ,_cdcb ,_cgba ,_ :=_fbe .RGBA ();
_eage :=(19595*_ccag +38470*_cdcb +7471*_cgba +1<<15)>>24;return _f .Gray {Y :uint8 (_eage )};};func _ffa (_caea CMYK ,_fecd Gray ,_egcec _e .Rectangle ){for _aeae :=0;_aeae < _egcec .Max .X ;_aeae ++{for _edeb :=0;_edeb < _egcec .Max .Y ;_edeb ++{_dfaa :=_aefa (_caea .CMYKAt (_aeae ,_edeb ));
_fecd .SetGray (_aeae ,_edeb ,_dfaa );};};};var _ Image =&Gray8 {};func RasterOperation (dest *Monochrome ,dx ,dy ,dw ,dh int ,op RasterOperator ,src *Monochrome ,sx ,sy int )error {return _bec (dest ,dx ,dy ,dw ,dh ,op ,src ,sx ,sy );};func (_fgee *Gray2 )Copy ()Image {return &Gray2 {ImageBase :_fgee .copy ()}};
func (_edad *Gray16 )Histogram ()(_age [256]int ){for _feg :=0;_feg < _edad .Width ;_feg ++{for _edb :=0;_edb < _edad .Height ;_edb ++{_age [_edad .GrayAt (_feg ,_edb ).Y ]++;};};return _age ;};type NRGBA64 struct{ImageBase };func _fbg (_gfdb Gray ,_ddda CMYK ,_gcf _e .Rectangle ){for _dec :=0;
_dec < _gcf .Max .X ;_dec ++{for _ggeg :=0;_ggeg < _gcf .Max .Y ;_ggeg ++{_ebba :=_gfdb .GrayAt (_dec ,_ggeg );_ddda .SetCMYK (_dec ,_ggeg ,_afda (_ebba ));};};};func (_eda *Gray8 )Validate ()error {if len (_eda .Data )!=_eda .Height *_eda .BytesPerLine {return ErrInvalidImage ;
};return nil ;};func (_afcg *Monochrome )setGrayBit (_aeag ,_gagd int ){_afcg .Data [_aeag ]|=0x80>>uint (_gagd &7)};func (_effc *Gray8 )Histogram ()(_dafe [256]int ){for _gcbd :=0;_gcbd < len (_effc .Data );_gcbd ++{_dafe [_effc .Data [_gcbd ]]++;};return _dafe ;
};func (_aaag *Gray4 )At (x ,y int )_f .Color {_egca ,_ :=_aaag .ColorAt (x ,y );return _egca };func (_aeaac *NRGBA16 )Copy ()Image {return &NRGBA16 {ImageBase :_aeaac .copy ()}};func _bgffb (_cedc uint )uint {var _ggdb uint ;for _cedc !=0{_cedc >>=1;_ggdb ++;
};return _ggdb -1;};func (_cfgc *Monochrome )copy ()*Monochrome {_gged :=_cdc (_cfgc .Width ,_cfgc .Height );_gged .ModelThreshold =_cfgc .ModelThreshold ;_gged .Data =make ([]byte ,len (_cfgc .Data ));copy (_gged .Data ,_cfgc .Data );if len (_cfgc .Decode )!=0{_gged .Decode =make ([]float64 ,len (_cfgc .Decode ));
copy (_gged .Decode ,_cfgc .Decode );};if len (_cfgc .Alpha )!=0{_gged .Alpha =make ([]byte ,len (_cfgc .Alpha ));copy (_gged .Alpha ,_cfgc .Alpha );};return _gged ;};func _dabg (_feeb *Monochrome ,_aecd ,_fbce int ,_ffddg ,_bfba int ,_afb RasterOperator ,_ecdee *Monochrome ,_dfad ,_ecdg int )error {var _aabc ,_ddf ,_gedeg ,_edbbe int ;
if _aecd < 0{_dfad -=_aecd ;_ffddg +=_aecd ;_aecd =0;};if _dfad < 0{_aecd -=_dfad ;_ffddg +=_dfad ;_dfad =0;};_aabc =_aecd +_ffddg -_feeb .Width ;if _aabc > 0{_ffddg -=_aabc ;};_ddf =_dfad +_ffddg -_ecdee .Width ;if _ddf > 0{_ffddg -=_ddf ;};if _fbce < 0{_ecdg -=_fbce ;
_bfba +=_fbce ;_fbce =0;};if _ecdg < 0{_fbce -=_ecdg ;_bfba +=_ecdg ;_ecdg =0;};_gedeg =_fbce +_bfba -_feeb .Height ;if _gedeg > 0{_bfba -=_gedeg ;};_edbbe =_ecdg +_bfba -_ecdee .Height ;if _edbbe > 0{_bfba -=_edbbe ;};if _ffddg <=0||_bfba <=0{return nil ;
};var _acaf error ;switch {case _aecd &7==0&&_dfad &7==0:_acaf =_bgcg (_feeb ,_aecd ,_fbce ,_ffddg ,_bfba ,_afb ,_ecdee ,_dfad ,_ecdg );case _aecd &7==_dfad &7:_acaf =_cceaa (_feeb ,_aecd ,_fbce ,_ffddg ,_bfba ,_afb ,_ecdee ,_dfad ,_ecdg );default:_acaf =_deag (_feeb ,_aecd ,_fbce ,_ffddg ,_bfba ,_afb ,_ecdee ,_dfad ,_ecdg );
};if _acaf !=nil {return _acaf ;};return nil ;};func _ffdd (_fadbd _e .Image )(Image ,error ){if _dfcc ,_bag :=_fadbd .(*Gray8 );_bag {return _dfcc .Copy (),nil ;};_acc :=_fadbd .Bounds ();_dfaf ,_cbbg :=NewImage (_acc .Max .X ,_acc .Max .Y ,8,1,nil ,nil ,nil );
if _cbbg !=nil {return nil ,_cbbg ;};_agge (_fadbd ,_dfaf ,_acc );return _dfaf ,nil ;};func _ccf (_bfe _e .Image )(Image ,error ){if _fba ,_cgfb :=_bfe .(*Monochrome );_cgfb {return _fba ,nil ;};_befc :=_bfe .Bounds ();var _cbc Gray ;switch _cbgf :=_bfe .(type ){case Gray :_cbc =_cbgf ;
case NRGBA :_cbc =&Gray8 {ImageBase :NewImageBase (_befc .Max .X ,_befc .Max .Y ,8,1,nil ,nil ,nil )};_gcc (_cbc ,_cbgf ,_befc );case nrgba64 :_cbc =&Gray8 {ImageBase :NewImageBase (_befc .Max .X ,_befc .Max .Y ,8,1,nil ,nil ,nil )};_bdc (_cbc ,_cbgf ,_befc );
default:_debb ,_ecg :=GrayConverter .Convert (_bfe );if _ecg !=nil {return nil ,_ecg ;};_cbc =_debb .(Gray );};_gdagg ,_debc :=NewImage (_befc .Max .X ,_befc .Max .Y ,1,1,nil ,nil ,nil );if _debc !=nil {return nil ,_debc ;};_fbab :=_gdagg .(*Monochrome );
_ccea :=AutoThresholdTriangle (GrayHistogram (_cbc ));for _faec :=0;_faec < _befc .Max .X ;_faec ++{for _fedc :=0;_fedc < _befc .Max .Y ;_fedc ++{_gdd :=_fgg (_cbc .GrayAt (_faec ,_fedc ),monochromeModel (_ccea ));_fbab .SetGray (_faec ,_fedc ,_gdd );};
};return _gdagg ,nil ;};func (_cgdb *Monochrome )getBitAt (_decb ,_gddd int )bool {_gcd :=_gddd *_cgdb .BytesPerLine +(_decb >>3);_ddcc :=_decb &0x07;_aeaa :=uint (7-_ddcc );if _gcd > len (_cgdb .Data )-1{return false ;};if (_cgdb .Data [_gcd ]>>_aeaa )&0x01>=1{return true ;
};return false ;};var _ Image =&Gray2 {};func _gfeb (_dge _e .Image )(Image ,error ){if _gbfg ,_abeg :=_dge .(*Gray2 );_abeg {return _gbfg .Copy (),nil ;};_ece :=_dge .Bounds ();_bdfd ,_ccdc :=NewImage (_ece .Max .X ,_ece .Max .Y ,2,1,nil ,nil ,nil );if _ccdc !=nil {return nil ,_ccdc ;
};_agge (_dge ,_bdfd ,_ece );return _bdfd ,nil ;};func _bdb ()(_ba [256]uint16 ){for _ebb :=0;_ebb < 256;_ebb ++{if _ebb &0x01!=0{_ba [_ebb ]|=0x3;};if _ebb &0x02!=0{_ba [_ebb ]|=0xc;};if _ebb &0x04!=0{_ba [_ebb ]|=0x30;};if _ebb &0x08!=0{_ba [_ebb ]|=0xc0;
};if _ebb &0x10!=0{_ba [_ebb ]|=0x300;};if _ebb &0x20!=0{_ba [_ebb ]|=0xc00;};if _ebb &0x40!=0{_ba [_ebb ]|=0x3000;};if _ebb &0x80!=0{_ba [_ebb ]|=0xc000;};};return _ba ;};func _efdg (_egfc _f .NRGBA64 )_f .NRGBA {return _f .NRGBA {R :uint8 (_egfc .R >>8),G :uint8 (_egfc .G >>8),B :uint8 (_egfc .B >>8),A :uint8 (_egfc .A >>8)};
};func GrayHistogram (g Gray )(_fgbb [256]int ){switch _acef :=g .(type ){case Histogramer :return _acef .Histogram ();case _e .Image :_edbg :=_acef .Bounds ();for _ggff :=0;_ggff < _edbg .Max .X ;_ggff ++{for _ceeef :=0;_ceeef < _edbg .Max .Y ;_ceeef ++{_fgbb [g .GrayAt (_ggff ,_ceeef ).Y ]++;
};};return _fgbb ;default:return [256]int {};};};func _aceb (_bbc _f .NRGBA )_f .CMYK {_bfa ,_gced ,_ega ,_ :=_bbc .RGBA ();_ccaa ,_cbb ,_egbc ,_fcf :=_f .RGBToCMYK (uint8 (_bfa >>8),uint8 (_gced >>8),uint8 (_ega >>8));return _f .CMYK {C :_ccaa ,M :_cbb ,Y :_egbc ,K :_fcf };
};func AddDataPadding (width ,height ,bitsPerComponent ,colorComponents int ,data []byte )([]byte ,error ){_fbcb :=BytesPerLine (width ,bitsPerComponent ,colorComponents );if _fbcb ==width *colorComponents *bitsPerComponent /8{return data ,nil ;};_adbde :=width *colorComponents *bitsPerComponent ;
_cebg :=_fbcb *8;_cgbce :=8-(_cebg -_adbde );_ecdeg :=_fg .NewReader (data );_edfa :=_fbcb -1;_agdgc :=make ([]byte ,_edfa );_bfgc :=make ([]byte ,height *_fbcb );_daa :=_fg .NewWriterMSB (_bfgc );var _bcgb uint64 ;var _fdce error ;for _fega :=0;_fega < height ;
_fega ++{_ ,_fdce =_ecdeg .Read (_agdgc );if _fdce !=nil {return nil ,_fdce ;};_ ,_fdce =_daa .Write (_agdgc );if _fdce !=nil {return nil ,_fdce ;};_bcgb ,_fdce =_ecdeg .ReadBits (byte (_cgbce ));if _fdce !=nil {return nil ,_fdce ;};_ ,_fdce =_daa .WriteBits (_bcgb ,_cgbce );
if _fdce !=nil {return nil ,_fdce ;};_daa .FinishByte ();};return _bfgc ,nil ;};func _dag (_aae *Monochrome ,_ab ...int )(_daf *Monochrome ,_cba error ){if _aae ==nil {return nil ,_d .New ("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d");
};if len (_ab )==0{return nil ,_d .New ("\u0074h\u0065\u0072e\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0061\u0074 \u006c\u0065\u0061\u0073\u0074\u0020o\u006e\u0065\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u006f\u0066 \u0072\u0065\u0064\u0075\u0063\u0074\u0069\u006f\u006e");
};_cgd :=_aaa ();_daf =_aae ;for _ ,_gdc :=range _ab {if _gdc <=0{break ;};_daf ,_cba =_egb (_daf ,_gdc ,_cgd );if _cba !=nil {return nil ,_cba ;};};return _daf ,nil ;};func (_beadf *ImageBase )setTwoBytes (_gceg int ,_ecfaf uint16 )error {if _gceg +1> len (_beadf .Data )-1{return _d .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_beadf .Data [_gceg ]=byte ((_ecfaf &0xff00)>>8);_beadf .Data [_gceg +1]=byte (_ecfaf &0xff);return nil ;};func _cbcd (_fcef ,_cgfdg ,_cgdf byte )byte {return (_fcef &^(_cgdf ))|(_cgfdg &_cgdf )};func _dgg (_ade _f .Color )_f .Color {_eagb :=_f .GrayModel .Convert (_ade ).(_f .Gray );
return _agb (_eagb )};func (_gfef *NRGBA64 )ColorModel ()_f .Model {return _f .NRGBA64Model };func NewImageBase (width int ,height int ,bitsPerComponent int ,colorComponents int ,data []byte ,alpha []byte ,decode []float64 )ImageBase {_bcee :=ImageBase {Width :width ,Height :height ,BitsPerComponent :bitsPerComponent ,ColorComponents :colorComponents ,Data :data ,Alpha :alpha ,Decode :decode ,BytesPerLine :BytesPerLine (width ,bitsPerComponent ,colorComponents )};
if data ==nil {_bcee .Data =make ([]byte ,height *_bcee .BytesPerLine );};return _bcee ;};var _ Image =&NRGBA16 {};func _caga (_dde _f .Color )_f .Color {_afcc :=_f .GrayModel .Convert (_dde ).(_f .Gray );return _fcad (_afcc );};func (_ggaga *Monochrome )Validate ()error {if len (_ggaga .Data )!=_ggaga .Height *_ggaga .BytesPerLine {return ErrInvalidImage ;
};return nil ;};var _ Gray =&Gray4 {};func (_fdcd *Gray2 )ColorModel ()_f .Model {return Gray2Model };func _deag (_dgccb *Monochrome ,_dgbb ,_dbaab ,_bfd ,_dfed int ,_gbdbb RasterOperator ,_dafca *Monochrome ,_cedcg ,_fgbc int )error {var (_gadd bool ;
_fdbc bool ;_feab byte ;_bgfg int ;_ggce int ;_efeg int ;_cgfbb int ;_dgca bool ;_eabed int ;_bbeg int ;_gfcd int ;_ggagd bool ;_agbf byte ;_bcfb int ;_fcba int ;_acfc int ;_fece byte ;_gafc int ;_fbea int ;_fgaf uint ;_adafc uint ;_cgcdg byte ;_dfadb shift ;
_bedc bool ;_ggab bool ;_bede ,_bcfbc int ;);if _cedcg &7!=0{_fbea =8-(_cedcg &7);};if _dgbb &7!=0{_ggce =8-(_dgbb &7);};if _fbea ==0&&_ggce ==0{_cgcdg =_ccga [0];}else {if _ggce > _fbea {_fgaf =uint (_ggce -_fbea );}else {_fgaf =uint (8-(_fbea -_ggce ));
};_adafc =8-_fgaf ;_cgcdg =_ccga [_fgaf ];};if (_dgbb &7)!=0{_gadd =true ;_bgfg =8-(_dgbb &7);_feab =_ccga [_bgfg ];_efeg =_dgccb .BytesPerLine *_dbaab +(_dgbb >>3);_cgfbb =_dafca .BytesPerLine *_fgbc +(_cedcg >>3);_gafc =8-(_cedcg &7);if _bgfg > _gafc {_dfadb =_bacf ;
if _bfd >=_fbea {_bedc =true ;};}else {_dfadb =_fdbb ;};};if _bfd < _bgfg {_fdbc =true ;_feab &=_gbba [8-_bgfg +_bfd ];};if !_fdbc {_eabed =(_bfd -_bgfg )>>3;if _eabed !=0{_dgca =true ;_bbeg =_dgccb .BytesPerLine *_dbaab +((_dgbb +_ggce )>>3);_gfcd =_dafca .BytesPerLine *_fgbc +((_cedcg +_ggce )>>3);
};};_bcfb =(_dgbb +_bfd )&7;if !(_fdbc ||_bcfb ==0){_ggagd =true ;_agbf =_gbba [_bcfb ];_fcba =_dgccb .BytesPerLine *_dbaab +((_dgbb +_ggce )>>3)+_eabed ;_acfc =_dafca .BytesPerLine *_fgbc +((_cedcg +_ggce )>>3)+_eabed ;if _bcfb > int (_adafc ){_ggab =true ;
};};switch _gbdbb {case PixSrc :if _gadd {for _bede =0;_bede < _dfed ;_bede ++{if _dfadb ==_bacf {_fece =_dafca .Data [_cgfbb ]<<_fgaf ;if _bedc {_fece =_cbcd (_fece ,_dafca .Data [_cgfbb +1]>>_adafc ,_cgcdg );};}else {_fece =_dafca .Data [_cgfbb ]>>_adafc ;
};_dgccb .Data [_efeg ]=_cbcd (_dgccb .Data [_efeg ],_fece ,_feab );_efeg +=_dgccb .BytesPerLine ;_cgfbb +=_dafca .BytesPerLine ;};};if _dgca {for _bede =0;_bede < _dfed ;_bede ++{for _bcfbc =0;_bcfbc < _eabed ;_bcfbc ++{_fece =_cbcd (_dafca .Data [_gfcd +_bcfbc ]<<_fgaf ,_dafca .Data [_gfcd +_bcfbc +1]>>_adafc ,_cgcdg );
_dgccb .Data [_bbeg +_bcfbc ]=_fece ;};_bbeg +=_dgccb .BytesPerLine ;_gfcd +=_dafca .BytesPerLine ;};};if _ggagd {for _bede =0;_bede < _dfed ;_bede ++{_fece =_dafca .Data [_acfc ]<<_fgaf ;if _ggab {_fece =_cbcd (_fece ,_dafca .Data [_acfc +1]>>_adafc ,_cgcdg );
};_dgccb .Data [_fcba ]=_cbcd (_dgccb .Data [_fcba ],_fece ,_agbf );_fcba +=_dgccb .BytesPerLine ;_acfc +=_dafca .BytesPerLine ;};};case PixNotSrc :if _gadd {for _bede =0;_bede < _dfed ;_bede ++{if _dfadb ==_bacf {_fece =_dafca .Data [_cgfbb ]<<_fgaf ;
if _bedc {_fece =_cbcd (_fece ,_dafca .Data [_cgfbb +1]>>_adafc ,_cgcdg );};}else {_fece =_dafca .Data [_cgfbb ]>>_adafc ;};_dgccb .Data [_efeg ]=_cbcd (_dgccb .Data [_efeg ],^_fece ,_feab );_efeg +=_dgccb .BytesPerLine ;_cgfbb +=_dafca .BytesPerLine ;
};};if _dgca {for _bede =0;_bede < _dfed ;_bede ++{for _bcfbc =0;_bcfbc < _eabed ;_bcfbc ++{_fece =_cbcd (_dafca .Data [_gfcd +_bcfbc ]<<_fgaf ,_dafca .Data [_gfcd +_bcfbc +1]>>_adafc ,_cgcdg );_dgccb .Data [_bbeg +_bcfbc ]=^_fece ;};_bbeg +=_dgccb .BytesPerLine ;
_gfcd +=_dafca .BytesPerLine ;};};if _ggagd {for _bede =0;_bede < _dfed ;_bede ++{_fece =_dafca .Data [_acfc ]<<_fgaf ;if _ggab {_fece =_cbcd (_fece ,_dafca .Data [_acfc +1]>>_adafc ,_cgcdg );};_dgccb .Data [_fcba ]=_cbcd (_dgccb .Data [_fcba ],^_fece ,_agbf );
_fcba +=_dgccb .BytesPerLine ;_acfc +=_dafca .BytesPerLine ;};};case PixSrcOrDst :if _gadd {for _bede =0;_bede < _dfed ;_bede ++{if _dfadb ==_bacf {_fece =_dafca .Data [_cgfbb ]<<_fgaf ;if _bedc {_fece =_cbcd (_fece ,_dafca .Data [_cgfbb +1]>>_adafc ,_cgcdg );
};}else {_fece =_dafca .Data [_cgfbb ]>>_adafc ;};_dgccb .Data [_efeg ]=_cbcd (_dgccb .Data [_efeg ],_fece |_dgccb .Data [_efeg ],_feab );_efeg +=_dgccb .BytesPerLine ;_cgfbb +=_dafca .BytesPerLine ;};};if _dgca {for _bede =0;_bede < _dfed ;_bede ++{for _bcfbc =0;
_bcfbc < _eabed ;_bcfbc ++{_fece =_cbcd (_dafca .Data [_gfcd +_bcfbc ]<<_fgaf ,_dafca .Data [_gfcd +_bcfbc +1]>>_adafc ,_cgcdg );_dgccb .Data [_bbeg +_bcfbc ]|=_fece ;};_bbeg +=_dgccb .BytesPerLine ;_gfcd +=_dafca .BytesPerLine ;};};if _ggagd {for _bede =0;
_bede < _dfed ;_bede ++{_fece =_dafca .Data [_acfc ]<<_fgaf ;if _ggab {_fece =_cbcd (_fece ,_dafca .Data [_acfc +1]>>_adafc ,_cgcdg );};_dgccb .Data [_fcba ]=_cbcd (_dgccb .Data [_fcba ],_fece |_dgccb .Data [_fcba ],_agbf );_fcba +=_dgccb .BytesPerLine ;
_acfc +=_dafca .BytesPerLine ;};};case PixSrcAndDst :if _gadd {for _bede =0;_bede < _dfed ;_bede ++{if _dfadb ==_bacf {_fece =_dafca .Data [_cgfbb ]<<_fgaf ;if _bedc {_fece =_cbcd (_fece ,_dafca .Data [_cgfbb +1]>>_adafc ,_cgcdg );};}else {_fece =_dafca .Data [_cgfbb ]>>_adafc ;
};_dgccb .Data [_efeg ]=_cbcd (_dgccb .Data [_efeg ],_fece &_dgccb .Data [_efeg ],_feab );_efeg +=_dgccb .BytesPerLine ;_cgfbb +=_dafca .BytesPerLine ;};};if _dgca {for _bede =0;_bede < _dfed ;_bede ++{for _bcfbc =0;_bcfbc < _eabed ;_bcfbc ++{_fece =_cbcd (_dafca .Data [_gfcd +_bcfbc ]<<_fgaf ,_dafca .Data [_gfcd +_bcfbc +1]>>_adafc ,_cgcdg );
_dgccb .Data [_bbeg +_bcfbc ]&=_fece ;};_bbeg +=_dgccb .BytesPerLine ;_gfcd +=_dafca .BytesPerLine ;};};if _ggagd {for _bede =0;_bede < _dfed ;_bede ++{_fece =_dafca .Data [_acfc ]<<_fgaf ;if _ggab {_fece =_cbcd (_fece ,_dafca .Data [_acfc +1]>>_adafc ,_cgcdg );
};_dgccb .Data [_fcba ]=_cbcd (_dgccb .Data [_fcba ],_fece &_dgccb .Data [_fcba ],_agbf );_fcba +=_dgccb .BytesPerLine ;_acfc +=_dafca .BytesPerLine ;};};case PixSrcXorDst :if _gadd {for _bede =0;_bede < _dfed ;_bede ++{if _dfadb ==_bacf {_fece =_dafca .Data [_cgfbb ]<<_fgaf ;
if _bedc {_fece =_cbcd (_fece ,_dafca .Data [_cgfbb +1]>>_adafc ,_cgcdg );};}else {_fece =_dafca .Data [_cgfbb ]>>_adafc ;};_dgccb .Data [_efeg ]=_cbcd (_dgccb .Data [_efeg ],_fece ^_dgccb .Data [_efeg ],_feab );_efeg +=_dgccb .BytesPerLine ;_cgfbb +=_dafca .BytesPerLine ;
};};if _dgca {for _bede =0;_bede < _dfed ;_bede ++{for _bcfbc =0;_bcfbc < _eabed ;_bcfbc ++{_fece =_cbcd (_dafca .Data [_gfcd +_bcfbc ]<<_fgaf ,_dafca .Data [_gfcd +_bcfbc +1]>>_adafc ,_cgcdg );_dgccb .Data [_bbeg +_bcfbc ]^=_fece ;};_bbeg +=_dgccb .BytesPerLine ;
_gfcd +=_dafca .BytesPerLine ;};};if _ggagd {for _bede =0;_bede < _dfed ;_bede ++{_fece =_dafca .Data [_acfc ]<<_fgaf ;if _ggab {_fece =_cbcd (_fece ,_dafca .Data [_acfc +1]>>_adafc ,_cgcdg );};_dgccb .Data [_fcba ]=_cbcd (_dgccb .Data [_fcba ],_fece ^_dgccb .Data [_fcba ],_agbf );
_fcba +=_dgccb .BytesPerLine ;_acfc +=_dafca .BytesPerLine ;};};case PixNotSrcOrDst :if _gadd {for _bede =0;_bede < _dfed ;_bede ++{if _dfadb ==_bacf {_fece =_dafca .Data [_cgfbb ]<<_fgaf ;if _bedc {_fece =_cbcd (_fece ,_dafca .Data [_cgfbb +1]>>_adafc ,_cgcdg );
};}else {_fece =_dafca .Data [_cgfbb ]>>_adafc ;};_dgccb .Data [_efeg ]=_cbcd (_dgccb .Data [_efeg ],^_fece |_dgccb .Data [_efeg ],_feab );_efeg +=_dgccb .BytesPerLine ;_cgfbb +=_dafca .BytesPerLine ;};};if _dgca {for _bede =0;_bede < _dfed ;_bede ++{for _bcfbc =0;
_bcfbc < _eabed ;_bcfbc ++{_fece =_cbcd (_dafca .Data [_gfcd +_bcfbc ]<<_fgaf ,_dafca .Data [_gfcd +_bcfbc +1]>>_adafc ,_cgcdg );_dgccb .Data [_bbeg +_bcfbc ]|=^_fece ;};_bbeg +=_dgccb .BytesPerLine ;_gfcd +=_dafca .BytesPerLine ;};};if _ggagd {for _bede =0;
_bede < _dfed ;_bede ++{_fece =_dafca .Data [_acfc ]<<_fgaf ;if _ggab {_fece =_cbcd (_fece ,_dafca .Data [_acfc +1]>>_adafc ,_cgcdg );};_dgccb .Data [_fcba ]=_cbcd (_dgccb .Data [_fcba ],^_fece |_dgccb .Data [_fcba ],_agbf );_fcba +=_dgccb .BytesPerLine ;
_acfc +=_dafca .BytesPerLine ;};};case PixNotSrcAndDst :if _gadd {for _bede =0;_bede < _dfed ;_bede ++{if _dfadb ==_bacf {_fece =_dafca .Data [_cgfbb ]<<_fgaf ;if _bedc {_fece =_cbcd (_fece ,_dafca .Data [_cgfbb +1]>>_adafc ,_cgcdg );};}else {_fece =_dafca .Data [_cgfbb ]>>_adafc ;
};_dgccb .Data [_efeg ]=_cbcd (_dgccb .Data [_efeg ],^_fece &_dgccb .Data [_efeg ],_feab );_efeg +=_dgccb .BytesPerLine ;_cgfbb +=_dafca .BytesPerLine ;};};if _dgca {for _bede =0;_bede < _dfed ;_bede ++{for _bcfbc =0;_bcfbc < _eabed ;_bcfbc ++{_fece =_cbcd (_dafca .Data [_gfcd +_bcfbc ]<<_fgaf ,_dafca .Data [_gfcd +_bcfbc +1]>>_adafc ,_cgcdg );
_dgccb .Data [_bbeg +_bcfbc ]&=^_fece ;};_bbeg +=_dgccb .BytesPerLine ;_gfcd +=_dafca .BytesPerLine ;};};if _ggagd {for _bede =0;_bede < _dfed ;_bede ++{_fece =_dafca .Data [_acfc ]<<_fgaf ;if _ggab {_fece =_cbcd (_fece ,_dafca .Data [_acfc +1]>>_adafc ,_cgcdg );
};_dgccb .Data [_fcba ]=_cbcd (_dgccb .Data [_fcba ],^_fece &_dgccb .Data [_fcba ],_agbf );_fcba +=_dgccb .BytesPerLine ;_acfc +=_dafca .BytesPerLine ;};};case PixSrcOrNotDst :if _gadd {for _bede =0;_bede < _dfed ;_bede ++{if _dfadb ==_bacf {_fece =_dafca .Data [_cgfbb ]<<_fgaf ;
if _bedc {_fece =_cbcd (_fece ,_dafca .Data [_cgfbb +1]>>_adafc ,_cgcdg );};}else {_fece =_dafca .Data [_cgfbb ]>>_adafc ;};_dgccb .Data [_efeg ]=_cbcd (_dgccb .Data [_efeg ],_fece |^_dgccb .Data [_efeg ],_feab );_efeg +=_dgccb .BytesPerLine ;_cgfbb +=_dafca .BytesPerLine ;
};};if _dgca {for _bede =0;_bede < _dfed ;_bede ++{for _bcfbc =0;_bcfbc < _eabed ;_bcfbc ++{_fece =_cbcd (_dafca .Data [_gfcd +_bcfbc ]<<_fgaf ,_dafca .Data [_gfcd +_bcfbc +1]>>_adafc ,_cgcdg );_dgccb .Data [_bbeg +_bcfbc ]=_fece |^_dgccb .Data [_bbeg +_bcfbc ];
};_bbeg +=_dgccb .BytesPerLine ;_gfcd +=_dafca .BytesPerLine ;};};if _ggagd {for _bede =0;_bede < _dfed ;_bede ++{_fece =_dafca .Data [_acfc ]<<_fgaf ;if _ggab {_fece =_cbcd (_fece ,_dafca .Data [_acfc +1]>>_adafc ,_cgcdg );};_dgccb .Data [_fcba ]=_cbcd (_dgccb .Data [_fcba ],_fece |^_dgccb .Data [_fcba ],_agbf );
_fcba +=_dgccb .BytesPerLine ;_acfc +=_dafca .BytesPerLine ;};};case PixSrcAndNotDst :if _gadd {for _bede =0;_bede < _dfed ;_bede ++{if _dfadb ==_bacf {_fece =_dafca .Data [_cgfbb ]<<_fgaf ;if _bedc {_fece =_cbcd (_fece ,_dafca .Data [_cgfbb +1]>>_adafc ,_cgcdg );
};}else {_fece =_dafca .Data [_cgfbb ]>>_adafc ;};_dgccb .Data [_efeg ]=_cbcd (_dgccb .Data [_efeg ],_fece &^_dgccb .Data [_efeg ],_feab );_efeg +=_dgccb .BytesPerLine ;_cgfbb +=_dafca .BytesPerLine ;};};if _dgca {for _bede =0;_bede < _dfed ;_bede ++{for _bcfbc =0;
_bcfbc < _eabed ;_bcfbc ++{_fece =_cbcd (_dafca .Data [_gfcd +_bcfbc ]<<_fgaf ,_dafca .Data [_gfcd +_bcfbc +1]>>_adafc ,_cgcdg );_dgccb .Data [_bbeg +_bcfbc ]=_fece &^_dgccb .Data [_bbeg +_bcfbc ];};_bbeg +=_dgccb .BytesPerLine ;_gfcd +=_dafca .BytesPerLine ;
};};if _ggagd {for _bede =0;_bede < _dfed ;_bede ++{_fece =_dafca .Data [_acfc ]<<_fgaf ;if _ggab {_fece =_cbcd (_fece ,_dafca .Data [_acfc +1]>>_adafc ,_cgcdg );};_dgccb .Data [_fcba ]=_cbcd (_dgccb .Data [_fcba ],_fece &^_dgccb .Data [_fcba ],_agbf );
_fcba +=_dgccb .BytesPerLine ;_acfc +=_dafca .BytesPerLine ;};};case PixNotPixSrcOrDst :if _gadd {for _bede =0;_bede < _dfed ;_bede ++{if _dfadb ==_bacf {_fece =_dafca .Data [_cgfbb ]<<_fgaf ;if _bedc {_fece =_cbcd (_fece ,_dafca .Data [_cgfbb +1]>>_adafc ,_cgcdg );
};}else {_fece =_dafca .Data [_cgfbb ]>>_adafc ;};_dgccb .Data [_efeg ]=_cbcd (_dgccb .Data [_efeg ],^(_fece |_dgccb .Data [_efeg ]),_feab );_efeg +=_dgccb .BytesPerLine ;_cgfbb +=_dafca .BytesPerLine ;};};if _dgca {for _bede =0;_bede < _dfed ;_bede ++{for _bcfbc =0;
_bcfbc < _eabed ;_bcfbc ++{_fece =_cbcd (_dafca .Data [_gfcd +_bcfbc ]<<_fgaf ,_dafca .Data [_gfcd +_bcfbc +1]>>_adafc ,_cgcdg );_dgccb .Data [_bbeg +_bcfbc ]=^(_fece |_dgccb .Data [_bbeg +_bcfbc ]);};_bbeg +=_dgccb .BytesPerLine ;_gfcd +=_dafca .BytesPerLine ;
};};if _ggagd {for _bede =0;_bede < _dfed ;_bede ++{_fece =_dafca .Data [_acfc ]<<_fgaf ;if _ggab {_fece =_cbcd (_fece ,_dafca .Data [_acfc +1]>>_adafc ,_cgcdg );};_dgccb .Data [_fcba ]=_cbcd (_dgccb .Data [_fcba ],^(_fece |_dgccb .Data [_fcba ]),_agbf );
_fcba +=_dgccb .BytesPerLine ;_acfc +=_dafca .BytesPerLine ;};};case PixNotPixSrcAndDst :if _gadd {for _bede =0;_bede < _dfed ;_bede ++{if _dfadb ==_bacf {_fece =_dafca .Data [_cgfbb ]<<_fgaf ;if _bedc {_fece =_cbcd (_fece ,_dafca .Data [_cgfbb +1]>>_adafc ,_cgcdg );
};}else {_fece =_dafca .Data [_cgfbb ]>>_adafc ;};_dgccb .Data [_efeg ]=_cbcd (_dgccb .Data [_efeg ],^(_fece &_dgccb .Data [_efeg ]),_feab );_efeg +=_dgccb .BytesPerLine ;_cgfbb +=_dafca .BytesPerLine ;};};if _dgca {for _bede =0;_bede < _dfed ;_bede ++{for _bcfbc =0;
_bcfbc < _eabed ;_bcfbc ++{_fece =_cbcd (_dafca .Data [_gfcd +_bcfbc ]<<_fgaf ,_dafca .Data [_gfcd +_bcfbc +1]>>_adafc ,_cgcdg );_dgccb .Data [_bbeg +_bcfbc ]=^(_fece &_dgccb .Data [_bbeg +_bcfbc ]);};_bbeg +=_dgccb .BytesPerLine ;_gfcd +=_dafca .BytesPerLine ;
};};if _ggagd {for _bede =0;_bede < _dfed ;_bede ++{_fece =_dafca .Data [_acfc ]<<_fgaf ;if _ggab {_fece =_cbcd (_fece ,_dafca .Data [_acfc +1]>>_adafc ,_cgcdg );};_dgccb .Data [_fcba ]=_cbcd (_dgccb .Data [_fcba ],^(_fece &_dgccb .Data [_fcba ]),_agbf );
_fcba +=_dgccb .BytesPerLine ;_acfc +=_dafca .BytesPerLine ;};};case PixNotPixSrcXorDst :if _gadd {for _bede =0;_bede < _dfed ;_bede ++{if _dfadb ==_bacf {_fece =_dafca .Data [_cgfbb ]<<_fgaf ;if _bedc {_fece =_cbcd (_fece ,_dafca .Data [_cgfbb +1]>>_adafc ,_cgcdg );
};}else {_fece =_dafca .Data [_cgfbb ]>>_adafc ;};_dgccb .Data [_efeg ]=_cbcd (_dgccb .Data [_efeg ],^(_fece ^_dgccb .Data [_efeg ]),_feab );_efeg +=_dgccb .BytesPerLine ;_cgfbb +=_dafca .BytesPerLine ;};};if _dgca {for _bede =0;_bede < _dfed ;_bede ++{for _bcfbc =0;
_bcfbc < _eabed ;_bcfbc ++{_fece =_cbcd (_dafca .Data [_gfcd +_bcfbc ]<<_fgaf ,_dafca .Data [_gfcd +_bcfbc +1]>>_adafc ,_cgcdg );_dgccb .Data [_bbeg +_bcfbc ]=^(_fece ^_dgccb .Data [_bbeg +_bcfbc ]);};_bbeg +=_dgccb .BytesPerLine ;_gfcd +=_dafca .BytesPerLine ;
};};if _ggagd {for _bede =0;_bede < _dfed ;_bede ++{_fece =_dafca .Data [_acfc ]<<_fgaf ;if _ggab {_fece =_cbcd (_fece ,_dafca .Data [_acfc +1]>>_adafc ,_cgcdg );};_dgccb .Data [_fcba ]=_cbcd (_dgccb .Data [_fcba ],^(_fece ^_dgccb .Data [_fcba ]),_agbf );
_fcba +=_dgccb .BytesPerLine ;_acfc +=_dafca .BytesPerLine ;};};default:_eed .Log .Debug ("\u004f\u0070e\u0072\u0061\u0074\u0069\u006f\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006e\u006f\u0074\u0020\u0070\u0065\u0072\u006d\u0069tt\u0065\u0064",_gbdbb );
return _d .New ("\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065r\u0061\u0074\u0069\u006f\u006e\u0020\u006eo\u0074\u0020\u0070\u0065\u0072\u006d\u0069\u0074\u0074\u0065\u0064");};return nil ;};func (_dgfb *NRGBA32 )SetNRGBA (x ,y int ,c _f .NRGBA ){_fccgg :=y *_dgfb .Width +x ;
_ffeb :=3*_fccgg ;if _ffeb +2>=len (_dgfb .Data ){return ;};_dgfb .setRGBA (_fccgg ,c );};func _dbb (_cc ,_bab int ,_aga []byte )*Monochrome {_bff :=_cdc (_cc ,_bab );_bff .Data =_aga ;return _bff ;};func (_dba *Gray2 )Set (x ,y int ,c _f .Color ){if x >=_dba .Width ||y >=_dba .Height {return ;
};_bgdg :=Gray2Model .Convert (c ).(_f .Gray );_bbdd :=y *_dba .BytesPerLine ;_aed :=_bbdd +(x >>2);_dgcc :=_bgdg .Y >>6;_dba .Data [_aed ]=(_dba .Data [_aed ]&(^(0xc0>>uint (2*((x )&3)))))|(_dgcc <<uint (6-2*(x &3)));};func (_gcacd *Gray16 )Bounds ()_e .Rectangle {return _e .Rectangle {Max :_e .Point {X :_gcacd .Width ,Y :_gcacd .Height }};
};func (_agff *NRGBA64 )Base ()*ImageBase {return &_agff .ImageBase };func _be (_gbf ,_bd *Monochrome )(_bcc error ){_eedd :=_bd .BytesPerLine ;_bbg :=_gbf .BytesPerLine ;_faf :=_bd .BytesPerLine *4-_gbf .BytesPerLine ;var (_gbd ,_adf byte ;_fad uint32 ;
_cb ,_bea ,_cab ,_bed ,_bcd ,_cf ,_eaa int ;);for _cab =0;_cab < _bd .Height ;_cab ++{_cb =_cab *_eedd ;_bea =4*_cab *_bbg ;for _bed =0;_bed < _eedd ;_bed ++{_gbd =_bd .Data [_cb +_bed ];_fad =_dga [_gbd ];_cf =_bea +_bed *4;if _faf !=0&&(_bed +1)*4> _gbf .BytesPerLine {for _bcd =_faf ;
_bcd > 0;_bcd --{_adf =byte ((_fad >>uint (_bcd *8))&0xff);_eaa =_cf +(_faf -_bcd );if _bcc =_gbf .setByte (_eaa ,_adf );_bcc !=nil {return _bcc ;};};}else if _bcc =_gbf .setFourBytes (_cf ,_fad );_bcc !=nil {return _bcc ;};if _bcc =_gbf .setFourBytes (_bea +_bed *4,_dga [_bd .Data [_cb +_bed ]]);
_bcc !=nil {return _bcc ;};};for _bcd =1;_bcd < 4;_bcd ++{for _bed =0;_bed < _bbg ;_bed ++{if _bcc =_gbf .setByte (_bea +_bcd *_bbg +_bed ,_gbf .Data [_bea +_bed ]);_bcc !=nil {return _bcc ;};};};};return nil ;};type colorConverter struct{_deba func (_cgf _e .Image )(Image ,error );
};func _baeb (_defd _e .Image )(Image ,error ){if _fgdf ,_gegc :=_defd .(*NRGBA32 );_gegc {return _fgdf .Copy (),nil ;};_aacfg ,_geb ,_bcabe :=_dbdf (_defd ,1);_cfbb ,_baf :=NewImage (_aacfg .Max .X ,_aacfg .Max .Y ,8,3,nil ,_bcabe ,nil );if _baf !=nil {return nil ,_baf ;
};_egbcf (_defd ,_cfbb ,_aacfg );if len (_bcabe )!=0&&!_geb {if _gfee :=_fcgd (_bcabe ,_cfbb );_gfee !=nil {return nil ,_gfee ;};};return _cfbb ,nil ;};func (_fcca *NRGBA16 )setNRGBA (_agf ,_begcf ,_edba int ,_bbec _f .NRGBA ){if _agf *3%2==0{_fcca .Data [_edba ]=(_bbec .R >>4)<<4|(_bbec .G >>4);
_fcca .Data [_edba +1]=(_bbec .B >>4)<<4|(_fcca .Data [_edba +1]&0xf);}else {_fcca .Data [_edba ]=(_fcca .Data [_edba ]&0xf0)|(_bbec .R >>4);_fcca .Data [_edba +1]=(_bbec .G >>4)<<4|(_bbec .B >>4);};if _fcca .Alpha !=nil {_cfae :=_begcf *BytesPerLine (_fcca .Width ,4,1);
if _cfae < len (_fcca .Alpha ){if _agf %2==0{_fcca .Alpha [_cfae ]=(_bbec .A >>uint (4))<<uint (4)|(_fcca .Alpha [_edba ]&0xf);}else {_fcca .Alpha [_cfae ]=(_fcca .Alpha [_cfae ]&0xf0)|(_bbec .A >>uint (4));};};};};func _ggag (_gcb ,_fc *Monochrome ,_ccb []byte ,_cac int )(_aadf error ){var (_cedg ,_egd ,_cge ,_cgb ,_abf ,_bceg ,_cdg ,_eaaa int ;
_abe ,_ffe ,_caa ,_ebd uint32 ;_gca ,_eaab byte ;_fgf uint16 ;);_gbc :=make ([]byte ,4);_fadb :=make ([]byte ,4);for _cge =0;_cge < _gcb .Height -1;_cge ,_cgb =_cge +2,_cgb +1{_cedg =_cge *_gcb .BytesPerLine ;_egd =_cgb *_fc .BytesPerLine ;for _abf ,_bceg =0,0;
_abf < _cac ;_abf ,_bceg =_abf +4,_bceg +1{for _cdg =0;_cdg < 4;_cdg ++{_eaaa =_cedg +_abf +_cdg ;if _eaaa <=len (_gcb .Data )-1&&_eaaa < _cedg +_gcb .BytesPerLine {_gbc [_cdg ]=_gcb .Data [_eaaa ];}else {_gbc [_cdg ]=0x00;};_eaaa =_cedg +_gcb .BytesPerLine +_abf +_cdg ;
if _eaaa <=len (_gcb .Data )-1&&_eaaa < _cedg +(2*_gcb .BytesPerLine ){_fadb [_cdg ]=_gcb .Data [_eaaa ];}else {_fadb [_cdg ]=0x00;};};_abe =_dd .BigEndian .Uint32 (_gbc );_ffe =_dd .BigEndian .Uint32 (_fadb );_caa =_abe &_ffe ;_caa |=_caa <<1;_ebd =_abe |_ffe ;
_ebd &=_ebd <<1;_ffe =_caa |_ebd ;_ffe &=0xaaaaaaaa;_abe =_ffe |(_ffe <<7);_gca =byte (_abe >>24);_eaab =byte ((_abe >>8)&0xff);_eaaa =_egd +_bceg ;if _eaaa +1==len (_fc .Data )-1||_eaaa +1>=_egd +_fc .BytesPerLine {if _aadf =_fc .setByte (_eaaa ,_ccb [_gca ]);
_aadf !=nil {return _ee .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_eaaa );};}else {_fgf =(uint16 (_ccb [_gca ])<<8)|uint16 (_ccb [_eaab ]);if _aadf =_fc .setTwoBytes (_eaaa ,_fgf );_aadf !=nil {return _ee .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_eaaa );
};_bceg ++;};};};return nil ;};func (_eceb *Gray4 )Base ()*ImageBase {return &_eceb .ImageBase };type NRGBA16 struct{ImageBase };func (_cdag *Gray8 )ColorAt (x ,y int )(_f .Color ,error ){return ColorAtGray8BPC (x ,y ,_cdag .BytesPerLine ,_cdag .Data ,_cdag .Decode );
};func (_gagda *NRGBA32 )NRGBAAt (x ,y int )_f .NRGBA {_affg ,_ :=ColorAtNRGBA32 (x ,y ,_gagda .Width ,_gagda .Data ,_gagda .Alpha ,_gagda .Decode );return _affg ;};func _b (_eb *Monochrome ,_fa int ,_ec []uint )(*Monochrome ,error ){_ae :=_fa *_eb .Width ;
_ad :=_fa *_eb .Height ;_c :=_cdc (_ae ,_ad );for _ace ,_fb :=range _ec {var _ge error ;switch _fb {case 2:_ge =_ebg (_c ,_eb );case 4:_ge =_be (_c ,_eb );case 8:_ge =_aa (_c ,_eb );};if _ge !=nil {return nil ,_ge ;};if _ace !=len (_ec )-1{_eb =_c .copy ();
};};return _c ,nil ;};func _bdc (_abae Gray ,_fbgf nrgba64 ,_gad _e .Rectangle ){for _bfbd :=0;_bfbd < _gad .Max .X ;_bfbd ++{for _cfbc :=0;_cfbc < _gad .Max .Y ;_cfbc ++{_efdc :=_edc (_fbgf .NRGBA64At (_bfbd ,_cfbc ));_abae .SetGray (_bfbd ,_cfbc ,_efdc );
};};};func (_baaee *monochromeThresholdConverter )Convert (img _e .Image )(Image ,error ){if _gffe ,_aeec :=img .(*Monochrome );_aeec {return _gffe .Copy (),nil ;};_cee :=img .Bounds ();_ddc ,_bbgg :=NewImage (_cee .Max .X ,_cee .Max .Y ,1,1,nil ,nil ,nil );
if _bbgg !=nil {return nil ,_bbgg ;};_ddc .(*Monochrome ).ModelThreshold =_baaee .Threshold ;for _aac :=0;_aac < _cee .Max .X ;_aac ++{for _baaf :=0;_baaf < _cee .Max .Y ;_baaf ++{_gfbc :=img .At (_aac ,_baaf );_ddc .Set (_aac ,_baaf ,_gfbc );};};return _ddc ,nil ;
};func (_gaded *NRGBA32 )ColorModel ()_f .Model {return _f .NRGBAModel };func _cceaa (_abec *Monochrome ,_baca ,_cbd ,_aaagf ,_cdcag int ,_edcg RasterOperator ,_ege *Monochrome ,_acgbd ,_bdde int )error {var (_gcg bool ;_begc bool ;_dcb int ;_geec int ;
_ffab int ;_fcfc bool ;_gbfa byte ;_ddeg int ;_cde int ;_cbaab int ;_cfgg ,_ffcf int ;);_ffgc :=8-(_baca &7);_fadc :=_ccga [_ffgc ];_bdgbd :=_abec .BytesPerLine *_cbd +(_baca >>3);_eggga :=_ege .BytesPerLine *_bdde +(_acgbd >>3);if _aaagf < _ffgc {_gcg =true ;
_fadc &=_gbba [8-_ffgc +_aaagf ];};if !_gcg {_dcb =(_aaagf -_ffgc )>>3;if _dcb > 0{_begc =true ;_geec =_bdgbd +1;_ffab =_eggga +1;};};_ddeg =(_baca +_aaagf )&7;if !(_gcg ||_ddeg ==0){_fcfc =true ;_gbfa =_gbba [_ddeg ];_cde =_bdgbd +1+_dcb ;_cbaab =_eggga +1+_dcb ;
};switch _edcg {case PixSrc :for _cfgg =0;_cfgg < _cdcag ;_cfgg ++{_abec .Data [_bdgbd ]=_cbcd (_abec .Data [_bdgbd ],_ege .Data [_eggga ],_fadc );_bdgbd +=_abec .BytesPerLine ;_eggga +=_ege .BytesPerLine ;};if _begc {for _cfgg =0;_cfgg < _cdcag ;_cfgg ++{for _ffcf =0;
_ffcf < _dcb ;_ffcf ++{_abec .Data [_geec +_ffcf ]=_ege .Data [_ffab +_ffcf ];};_geec +=_abec .BytesPerLine ;_ffab +=_ege .BytesPerLine ;};};if _fcfc {for _cfgg =0;_cfgg < _cdcag ;_cfgg ++{_abec .Data [_cde ]=_cbcd (_abec .Data [_cde ],_ege .Data [_cbaab ],_gbfa );
_cde +=_abec .BytesPerLine ;_cbaab +=_ege .BytesPerLine ;};};case PixNotSrc :for _cfgg =0;_cfgg < _cdcag ;_cfgg ++{_abec .Data [_bdgbd ]=_cbcd (_abec .Data [_bdgbd ],^_ege .Data [_eggga ],_fadc );_bdgbd +=_abec .BytesPerLine ;_eggga +=_ege .BytesPerLine ;
};if _begc {for _cfgg =0;_cfgg < _cdcag ;_cfgg ++{for _ffcf =0;_ffcf < _dcb ;_ffcf ++{_abec .Data [_geec +_ffcf ]=^_ege .Data [_ffab +_ffcf ];};_geec +=_abec .BytesPerLine ;_ffab +=_ege .BytesPerLine ;};};if _fcfc {for _cfgg =0;_cfgg < _cdcag ;_cfgg ++{_abec .Data [_cde ]=_cbcd (_abec .Data [_cde ],^_ege .Data [_cbaab ],_gbfa );
_cde +=_abec .BytesPerLine ;_cbaab +=_ege .BytesPerLine ;};};case PixSrcOrDst :for _cfgg =0;_cfgg < _cdcag ;_cfgg ++{_abec .Data [_bdgbd ]=_cbcd (_abec .Data [_bdgbd ],_ege .Data [_eggga ]|_abec .Data [_bdgbd ],_fadc );_bdgbd +=_abec .BytesPerLine ;_eggga +=_ege .BytesPerLine ;
};if _begc {for _cfgg =0;_cfgg < _cdcag ;_cfgg ++{for _ffcf =0;_ffcf < _dcb ;_ffcf ++{_abec .Data [_geec +_ffcf ]|=_ege .Data [_ffab +_ffcf ];};_geec +=_abec .BytesPerLine ;_ffab +=_ege .BytesPerLine ;};};if _fcfc {for _cfgg =0;_cfgg < _cdcag ;_cfgg ++{_abec .Data [_cde ]=_cbcd (_abec .Data [_cde ],_ege .Data [_cbaab ]|_abec .Data [_cde ],_gbfa );
_cde +=_abec .BytesPerLine ;_cbaab +=_ege .BytesPerLine ;};};case PixSrcAndDst :for _cfgg =0;_cfgg < _cdcag ;_cfgg ++{_abec .Data [_bdgbd ]=_cbcd (_abec .Data [_bdgbd ],_ege .Data [_eggga ]&_abec .Data [_bdgbd ],_fadc );_bdgbd +=_abec .BytesPerLine ;_eggga +=_ege .BytesPerLine ;
};if _begc {for _cfgg =0;_cfgg < _cdcag ;_cfgg ++{for _ffcf =0;_ffcf < _dcb ;_ffcf ++{_abec .Data [_geec +_ffcf ]&=_ege .Data [_ffab +_ffcf ];};_geec +=_abec .BytesPerLine ;_ffab +=_ege .BytesPerLine ;};};if _fcfc {for _cfgg =0;_cfgg < _cdcag ;_cfgg ++{_abec .Data [_cde ]=_cbcd (_abec .Data [_cde ],_ege .Data [_cbaab ]&_abec .Data [_cde ],_gbfa );
_cde +=_abec .BytesPerLine ;_cbaab +=_ege .BytesPerLine ;};};case PixSrcXorDst :for _cfgg =0;_cfgg < _cdcag ;_cfgg ++{_abec .Data [_bdgbd ]=_cbcd (_abec .Data [_bdgbd ],_ege .Data [_eggga ]^_abec .Data [_bdgbd ],_fadc );_bdgbd +=_abec .BytesPerLine ;_eggga +=_ege .BytesPerLine ;
};if _begc {for _cfgg =0;_cfgg < _cdcag ;_cfgg ++{for _ffcf =0;_ffcf < _dcb ;_ffcf ++{_abec .Data [_geec +_ffcf ]^=_ege .Data [_ffab +_ffcf ];};_geec +=_abec .BytesPerLine ;_ffab +=_ege .BytesPerLine ;};};if _fcfc {for _cfgg =0;_cfgg < _cdcag ;_cfgg ++{_abec .Data [_cde ]=_cbcd (_abec .Data [_cde ],_ege .Data [_cbaab ]^_abec .Data [_cde ],_gbfa );
_cde +=_abec .BytesPerLine ;_cbaab +=_ege .BytesPerLine ;};};case PixNotSrcOrDst :for _cfgg =0;_cfgg < _cdcag ;_cfgg ++{_abec .Data [_bdgbd ]=_cbcd (_abec .Data [_bdgbd ],^(_ege .Data [_eggga ])|_abec .Data [_bdgbd ],_fadc );_bdgbd +=_abec .BytesPerLine ;
_eggga +=_ege .BytesPerLine ;};if _begc {for _cfgg =0;_cfgg < _cdcag ;_cfgg ++{for _ffcf =0;_ffcf < _dcb ;_ffcf ++{_abec .Data [_geec +_ffcf ]|=^(_ege .Data [_ffab +_ffcf ]);};_geec +=_abec .BytesPerLine ;_ffab +=_ege .BytesPerLine ;};};if _fcfc {for _cfgg =0;
_cfgg < _cdcag ;_cfgg ++{_abec .Data [_cde ]=_cbcd (_abec .Data [_cde ],^(_ege .Data [_cbaab ])|_abec .Data [_cde ],_gbfa );_cde +=_abec .BytesPerLine ;_cbaab +=_ege .BytesPerLine ;};};case PixNotSrcAndDst :for _cfgg =0;_cfgg < _cdcag ;_cfgg ++{_abec .Data [_bdgbd ]=_cbcd (_abec .Data [_bdgbd ],^(_ege .Data [_eggga ])&_abec .Data [_bdgbd ],_fadc );
_bdgbd +=_abec .BytesPerLine ;_eggga +=_ege .BytesPerLine ;};if _begc {for _cfgg =0;_cfgg < _cdcag ;_cfgg ++{for _ffcf =0;_ffcf < _dcb ;_ffcf ++{_abec .Data [_geec +_ffcf ]&=^_ege .Data [_ffab +_ffcf ];};_geec +=_abec .BytesPerLine ;_ffab +=_ege .BytesPerLine ;
};};if _fcfc {for _cfgg =0;_cfgg < _cdcag ;_cfgg ++{_abec .Data [_cde ]=_cbcd (_abec .Data [_cde ],^(_ege .Data [_cbaab ])&_abec .Data [_cde ],_gbfa );_cde +=_abec .BytesPerLine ;_cbaab +=_ege .BytesPerLine ;};};case PixSrcOrNotDst :for _cfgg =0;_cfgg < _cdcag ;
_cfgg ++{_abec .Data [_bdgbd ]=_cbcd (_abec .Data [_bdgbd ],_ege .Data [_eggga ]|^(_abec .Data [_bdgbd ]),_fadc );_bdgbd +=_abec .BytesPerLine ;_eggga +=_ege .BytesPerLine ;};if _begc {for _cfgg =0;_cfgg < _cdcag ;_cfgg ++{for _ffcf =0;_ffcf < _dcb ;_ffcf ++{_abec .Data [_geec +_ffcf ]=_ege .Data [_ffab +_ffcf ]|^(_abec .Data [_geec +_ffcf ]);
};_geec +=_abec .BytesPerLine ;_ffab +=_ege .BytesPerLine ;};};if _fcfc {for _cfgg =0;_cfgg < _cdcag ;_cfgg ++{_abec .Data [_cde ]=_cbcd (_abec .Data [_cde ],_ege .Data [_cbaab ]|^(_abec .Data [_cde ]),_gbfa );_cde +=_abec .BytesPerLine ;_cbaab +=_ege .BytesPerLine ;
};};case PixSrcAndNotDst :for _cfgg =0;_cfgg < _cdcag ;_cfgg ++{_abec .Data [_bdgbd ]=_cbcd (_abec .Data [_bdgbd ],_ege .Data [_eggga ]&^(_abec .Data [_bdgbd ]),_fadc );_bdgbd +=_abec .BytesPerLine ;_eggga +=_ege .BytesPerLine ;};if _begc {for _cfgg =0;
_cfgg < _cdcag ;_cfgg ++{for _ffcf =0;_ffcf < _dcb ;_ffcf ++{_abec .Data [_geec +_ffcf ]=_ege .Data [_ffab +_ffcf ]&^(_abec .Data [_geec +_ffcf ]);};_geec +=_abec .BytesPerLine ;_ffab +=_ege .BytesPerLine ;};};if _fcfc {for _cfgg =0;_cfgg < _cdcag ;_cfgg ++{_abec .Data [_cde ]=_cbcd (_abec .Data [_cde ],_ege .Data [_cbaab ]&^(_abec .Data [_cde ]),_gbfa );
_cde +=_abec .BytesPerLine ;_cbaab +=_ege .BytesPerLine ;};};case PixNotPixSrcOrDst :for _cfgg =0;_cfgg < _cdcag ;_cfgg ++{_abec .Data [_bdgbd ]=_cbcd (_abec .Data [_bdgbd ],^(_ege .Data [_eggga ]|_abec .Data [_bdgbd ]),_fadc );_bdgbd +=_abec .BytesPerLine ;
_eggga +=_ege .BytesPerLine ;};if _begc {for _cfgg =0;_cfgg < _cdcag ;_cfgg ++{for _ffcf =0;_ffcf < _dcb ;_ffcf ++{_abec .Data [_geec +_ffcf ]=^(_ege .Data [_ffab +_ffcf ]|_abec .Data [_geec +_ffcf ]);};_geec +=_abec .BytesPerLine ;_ffab +=_ege .BytesPerLine ;
};};if _fcfc {for _cfgg =0;_cfgg < _cdcag ;_cfgg ++{_abec .Data [_cde ]=_cbcd (_abec .Data [_cde ],^(_ege .Data [_cbaab ]|_abec .Data [_cde ]),_gbfa );_cde +=_abec .BytesPerLine ;_cbaab +=_ege .BytesPerLine ;};};case PixNotPixSrcAndDst :for _cfgg =0;_cfgg < _cdcag ;
_cfgg ++{_abec .Data [_bdgbd ]=_cbcd (_abec .Data [_bdgbd ],^(_ege .Data [_eggga ]&_abec .Data [_bdgbd ]),_fadc );_bdgbd +=_abec .BytesPerLine ;_eggga +=_ege .BytesPerLine ;};if _begc {for _cfgg =0;_cfgg < _cdcag ;_cfgg ++{for _ffcf =0;_ffcf < _dcb ;_ffcf ++{_abec .Data [_geec +_ffcf ]=^(_ege .Data [_ffab +_ffcf ]&_abec .Data [_geec +_ffcf ]);
};_geec +=_abec .BytesPerLine ;_ffab +=_ege .BytesPerLine ;};};if _fcfc {for _cfgg =0;_cfgg < _cdcag ;_cfgg ++{_abec .Data [_cde ]=_cbcd (_abec .Data [_cde ],^(_ege .Data [_cbaab ]&_abec .Data [_cde ]),_gbfa );_cde +=_abec .BytesPerLine ;_cbaab +=_ege .BytesPerLine ;
};};case PixNotPixSrcXorDst :for _cfgg =0;_cfgg < _cdcag ;_cfgg ++{_abec .Data [_bdgbd ]=_cbcd (_abec .Data [_bdgbd ],^(_ege .Data [_eggga ]^_abec .Data [_bdgbd ]),_fadc );_bdgbd +=_abec .BytesPerLine ;_eggga +=_ege .BytesPerLine ;};if _begc {for _cfgg =0;
_cfgg < _cdcag ;_cfgg ++{for _ffcf =0;_ffcf < _dcb ;_ffcf ++{_abec .Data [_geec +_ffcf ]=^(_ege .Data [_ffab +_ffcf ]^_abec .Data [_geec +_ffcf ]);};_geec +=_abec .BytesPerLine ;_ffab +=_ege .BytesPerLine ;};};if _fcfc {for _cfgg =0;_cfgg < _cdcag ;_cfgg ++{_abec .Data [_cde ]=_cbcd (_abec .Data [_cde ],^(_ege .Data [_cbaab ]^_abec .Data [_cde ]),_gbfa );
_cde +=_abec .BytesPerLine ;_cbaab +=_ege .BytesPerLine ;};};default:_eed .Log .Debug ("I\u006e\u0076\u0061\u006c\u0069\u0064 \u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070e\u0072\u0061\u0074o\u0072:\u0020\u0025\u0064",_edcg );return _d .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072");
};return nil ;};func _aefa (_cae _f .CMYK )_f .Gray {_fcb ,_dfbc ,_bfgf :=_f .CMYKToRGB (_cae .C ,_cae .M ,_cae .Y ,_cae .K );_bcge :=(19595*uint32 (_fcb )+38470*uint32 (_dfbc )+7471*uint32 (_bfgf )+1<<7)>>16;return _f .Gray {Y :uint8 (_bcge )};};func _gcc (_bfggc Gray ,_gabb NRGBA ,_fbef _e .Rectangle ){for _dbg :=0;
_dbg < _fbef .Max .X ;_dbg ++{for _ffd :=0;_ffd < _fbef .Max .Y ;_ffd ++{_adggb :=_bee (_gabb .NRGBAAt (_dbg ,_ffd ));_bfggc .SetGray (_dbg ,_ffd ,_adggb );};};};func (_ggad *NRGBA32 )At (x ,y int )_f .Color {_egec ,_ :=_ggad .ColorAt (x ,y );return _egec };
func (_edef *NRGBA64 )setNRGBA64 (_bgdd int ,_dgdb _f .NRGBA64 ,_fefd int ){_edef .Data [_bgdd ]=uint8 (_dgdb .R >>8);_edef .Data [_bgdd +1]=uint8 (_dgdb .R &0xff);_edef .Data [_bgdd +2]=uint8 (_dgdb .G >>8);_edef .Data [_bgdd +3]=uint8 (_dgdb .G &0xff);
_edef .Data [_bgdd +4]=uint8 (_dgdb .B >>8);_edef .Data [_bgdd +5]=uint8 (_dgdb .B &0xff);if _fefd +1< len (_edef .Alpha ){_edef .Alpha [_fefd ]=uint8 (_dgdb .A >>8);_edef .Alpha [_fefd +1]=uint8 (_dgdb .A &0xff);};};func (_abd *Gray16 )Base ()*ImageBase {return &_abd .ImageBase };
func (_aggc *NRGBA16 )Base ()*ImageBase {return &_aggc .ImageBase };func (_gfa *Monochrome )Copy ()Image {return &Monochrome {ImageBase :_gfa .ImageBase .copy (),ModelThreshold :_gfa .ModelThreshold };};func (_aedd *NRGBA16 )NRGBAAt (x ,y int )_f .NRGBA {_bgac ,_ :=ColorAtNRGBA16 (x ,y ,_aedd .Width ,_aedd .BytesPerLine ,_aedd .Data ,_aedd .Alpha ,_aedd .Decode );
return _bgac ;};func NewImage (width ,height ,bitsPerComponent ,colorComponents int ,data ,alpha []byte ,decode []float64 )(Image ,error ){_adaac :=NewImageBase (width ,height ,bitsPerComponent ,colorComponents ,data ,alpha ,decode );var _cfbd Image ;switch colorComponents {case 1:switch bitsPerComponent {case 1:_cfbd =&Monochrome {ImageBase :_adaac ,ModelThreshold :0x0f};
case 2:_cfbd =&Gray2 {ImageBase :_adaac };case 4:_cfbd =&Gray4 {ImageBase :_adaac };case 8:_cfbd =&Gray8 {ImageBase :_adaac };case 16:_cfbd =&Gray16 {ImageBase :_adaac };};case 3:switch bitsPerComponent {case 4:_cfbd =&NRGBA16 {ImageBase :_adaac };case 8:_cfbd =&NRGBA32 {ImageBase :_adaac };
case 16:_cfbd =&NRGBA64 {ImageBase :_adaac };};case 4:_cfbd =&CMYK32 {ImageBase :_adaac };};if _cfbd ==nil {return nil ,ErrInvalidImage ;};return _cfbd ,nil ;};var (_gbba =[]byte {0x00,0x80,0xC0,0xE0,0xF0,0xF8,0xFC,0xFE,0xFF};_ccga =[]byte {0x00,0x01,0x03,0x07,0x0F,0x1F,0x3F,0x7F,0xFF};
);func (_gde *Monochrome )ExpandBinary (factor int )(*Monochrome ,error ){if !IsPowerOf2 (uint (factor )){return nil ,_ee .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0065\u0078\u0070\u0061\u006e\u0064\u0020b\u0069n\u0061\u0072\u0079\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",factor );
};return _ea (_gde ,factor );};func ColorAtGray16BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_f .Gray16 ,error ){_baccf :=(y *bytesPerLine /2+x )*2;if _baccf +1>=len (data ){return _f .Gray16 {},_ee .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_ddgac :=uint16 (data [_baccf ])<<8|uint16 (data [_baccf +1]);if len (decode )==2{_ddgac =uint16 (uint64 (LinearInterpolate (float64 (_ddgac ),0,65535,decode [0],decode [1])));};return _f .Gray16 {Y :_ddgac },nil ;};func LinearInterpolate (x ,xmin ,xmax ,ymin ,ymax float64 )float64 {if _df .Abs (xmax -xmin )< 0.000001{return ymin ;
};_dgea :=ymin +(x -xmin )*(ymax -ymin )/(xmax -xmin );return _dgea ;};func _edc (_cgbc _f .NRGBA64 )_f .Gray {var _aec _f .NRGBA64 ;if _cgbc ==_aec {return _f .Gray {Y :0xff};};_fge ,_bcce ,_adgg ,_ :=_cgbc .RGBA ();_dff :=(19595*_fge +38470*_bcce +7471*_adgg +1<<15)>>24;
return _f .Gray {Y :uint8 (_dff )};};func (_egbb *Monochrome )setGray (_dfd int ,_cgc _f .Gray ,_gbe int ){if _cgc .Y ==0{_egbb .clearBit (_gbe ,_dfd );}else {_egbb .setGrayBit (_gbe ,_dfd );};};var _ NRGBA =&NRGBA32 {};var _ Image =&NRGBA32 {};func (_adfa *NRGBA16 )SetNRGBA (x ,y int ,c _f .NRGBA ){_cfeg :=y *_adfa .BytesPerLine +x *3/2;
if _cfeg +1>=len (_adfa .Data ){return ;};c =_bacae (c );_adfa .setNRGBA (x ,y ,_cfeg ,c );};func (_gaa *CMYK32 )Bounds ()_e .Rectangle {return _e .Rectangle {Max :_e .Point {X :_gaa .Width ,Y :_gaa .Height }};};func _ccdb (_bbee CMYK ,_acfb NRGBA ,_bcfe _e .Rectangle ){for _gdae :=0;
_gdae < _bcfe .Max .X ;_gdae ++{for _babd :=0;_babd < _bcfe .Max .Y ;_babd ++{_eeae :=_bbee .CMYKAt (_gdae ,_babd );_acfb .SetNRGBA (_gdae ,_babd ,_gbbf (_eeae ));};};};func (_fce *ImageBase )MakeAlpha (){_fce .newAlpha ()};func (_dbee *NRGBA32 )setRGBA (_dgdcf int ,_abea _f .NRGBA ){_gedd :=3*_dgdcf ;
_dbee .Data [_gedd ]=_abea .R ;_dbee .Data [_gedd +1]=_abea .G ;_dbee .Data [_gedd +2]=_abea .B ;if _dgdcf < len (_dbee .Alpha ){_dbee .Alpha [_dgdcf ]=_abea .A ;};};func (_gecdb *NRGBA32 )Copy ()Image {return &NRGBA32 {ImageBase :_gecdb .copy ()}};type nrgba64 interface{NRGBA64At (_cece ,_fggd int )_f .NRGBA64 ;
SetNRGBA64 (_cfbdf ,_aagb int ,_cfec _f .NRGBA64 );};func ImgToBinary (i _e .Image ,threshold uint8 )*_e .Gray {switch _efdgg :=i .(type ){case *_e .Gray :if _faca (_efdgg ){return _efdgg ;};return _agacg (_efdgg ,threshold );case *_e .Gray16 :return _cedd (_efdgg ,threshold );
default:return _cebd (_efdgg ,threshold );};};func _gfed (_dfbe _e .Image )(Image ,error ){if _bgga ,_fcbdb :=_dfbe .(*NRGBA64 );_fcbdb {return _bgga .Copy (),nil ;};_eddg ,_ecgf ,_cdcd :=_dbdf (_dfbe ,2);_bcbe ,_ceee :=NewImage (_eddg .Max .X ,_eddg .Max .Y ,16,3,nil ,_cdcd ,nil );
if _ceee !=nil {return nil ,_ceee ;};_bbcc (_dfbe ,_bcbe ,_eddg );if len (_cdcd )!=0&&!_ecgf {if _cbbb :=_fcgd (_cdcd ,_bcbe );_cbbb !=nil {return nil ,_cbbb ;};};return _bcbe ,nil ;};func _gbbf (_gcfa _f .CMYK )_f .NRGBA {_ead ,_gede ,_fbc :=_f .CMYKToRGB (_gcfa .C ,_gcfa .M ,_gcfa .Y ,_gcfa .K );
return _f .NRGBA {R :_ead ,G :_gede ,B :_fbc ,A :0xff};};func (_ecea *NRGBA64 )Set (x ,y int ,c _f .Color ){_agcc :=(y *_ecea .Width +x )*2;_fagfe :=_agcc *3;if _fagfe +5>=len (_ecea .Data ){return ;};_cagc :=_f .NRGBA64Model .Convert (c ).(_f .NRGBA64 );
_ecea .setNRGBA64 (_fagfe ,_cagc ,_agcc );};func (_beg *CMYK32 )Copy ()Image {return &CMYK32 {ImageBase :_beg .copy ()}};func (_acbge *NRGBA64 )SetNRGBA64 (x ,y int ,c _f .NRGBA64 ){_dfcd :=(y *_acbge .Width +x )*2;_bfcgg :=_dfcd *3;if _bfcgg +5>=len (_acbge .Data ){return ;
};_acbge .setNRGBA64 (_bfcgg ,c ,_dfcd );};func _bgdc (_bdeb _f .RGBA )_f .CMYK {_dfgf ,_aea ,_gff ,_baae :=_f .RGBToCMYK (_bdeb .R ,_bdeb .G ,_bdeb .B );return _f .CMYK {C :_dfgf ,M :_aea ,Y :_gff ,K :_baae };};func (_abda *ImageBase )newAlpha (){_ceda :=BytesPerLine (_abda .Width ,_abda .BitsPerComponent ,1);
_abda .Alpha =make ([]byte ,_abda .Height *_ceda );};func (_deagb *NRGBA64 )Bounds ()_e .Rectangle {return _e .Rectangle {Max :_e .Point {X :_deagb .Width ,Y :_deagb .Height }};};var _ _e .Image =&Gray8 {};func _bgce (_bbbg RGBA ,_bbag Gray ,_fdf _e .Rectangle ){for _efdb :=0;
_efdb < _fdf .Max .X ;_efdb ++{for _aede :=0;_aede < _fdf .Max .Y ;_aede ++{_cbba :=_bcb (_bbbg .RGBAAt (_efdb ,_aede ));_bbag .SetGray (_efdb ,_aede ,_cbba );};};};func (_gbg *Monochrome )Base ()*ImageBase {return &_gbg .ImageBase };func (_ffge *ImageBase )copy ()ImageBase {_edbb :=*_ffge ;
_edbb .Data =make ([]byte ,len (_ffge .Data ));copy (_edbb .Data ,_ffge .Data );return _edbb ;};func _egbcf (_cedcf _e .Image ,_bafd Image ,_gedf _e .Rectangle ){if _cdcf ,_bgag :=_cedcf .(SMasker );_bgag &&_cdcf .HasAlpha (){_bafd .(SMasker ).MakeAlpha ();
};switch _fccgge :=_cedcf .(type ){case Gray :_ffefa (_fccgge ,_bafd .(NRGBA ),_gedf );case NRGBA :_dagc (_fccgge ,_bafd .(NRGBA ),_gedf );case *_e .NYCbCrA :_becb (_fccgge ,_bafd .(NRGBA ),_gedf );case CMYK :_ccdb (_fccgge ,_bafd .(NRGBA ),_gedf );case RGBA :_adgga (_fccgge ,_bafd .(NRGBA ),_gedf );
case nrgba64 :_gebf (_fccgge ,_bafd .(NRGBA ),_gedf );default:_egff (_cedcf ,_bafd ,_gedf );};};func _bbfb (_beea _f .Color )_f .Color {_aadd :=_f .NRGBAModel .Convert (_beea ).(_f .NRGBA );return _bacae (_aadd );};func (_gfab *Gray2 )Bounds ()_e .Rectangle {return _e .Rectangle {Max :_e .Point {X :_gfab .Width ,Y :_gfab .Height }};
};var _cgdd [256]uint8 ;var (Gray2Model =_f .ModelFunc (_dgg );Gray4Model =_f .ModelFunc (_caga );NRGBA16Model =_f .ModelFunc (_bbfb ););func _aca ()(_efc [256]uint32 ){for _cfb :=0;_cfb < 256;_cfb ++{if _cfb &0x01!=0{_efc [_cfb ]|=0xf;};if _cfb &0x02!=0{_efc [_cfb ]|=0xf0;
};if _cfb &0x04!=0{_efc [_cfb ]|=0xf00;};if _cfb &0x08!=0{_efc [_cfb ]|=0xf000;};if _cfb &0x10!=0{_efc [_cfb ]|=0xf0000;};if _cfb &0x20!=0{_efc [_cfb ]|=0xf00000;};if _cfb &0x40!=0{_efc [_cfb ]|=0xf000000;};if _cfb &0x80!=0{_efc [_cfb ]|=0xf0000000;};};
return _efc ;};func _dagc (_fecc ,_cbcfe NRGBA ,_bdeba _e .Rectangle ){for _efdd :=0;_efdd < _bdeba .Max .X ;_efdd ++{for _cffb :=0;_cffb < _bdeba .Max .Y ;_cffb ++{_cbcfe .SetNRGBA (_efdd ,_cffb ,_fecc .NRGBAAt (_efdd ,_cffb ));};};};type ImageBase struct{Width ,Height int ;
BitsPerComponent ,ColorComponents int ;Data ,Alpha []byte ;Decode []float64 ;BytesPerLine int ;};func _aa (_da ,_eec *Monochrome )(_eca error ){_gbfb :=_eec .BytesPerLine ;_gf :=_da .BytesPerLine ;var _ag ,_fe ,_dg ,_cd ,_aff int ;for _dg =0;_dg < _eec .Height ;
_dg ++{_ag =_dg *_gbfb ;_fe =8*_dg *_gf ;for _cd =0;_cd < _gbfb ;_cd ++{if _eca =_da .setEightBytes (_fe +_cd *8,_cg [_eec .Data [_ag +_cd ]]);_eca !=nil {return _eca ;};};for _aff =1;_aff < 8;_aff ++{for _cd =0;_cd < _gf ;_cd ++{if _eca =_da .setByte (_fe +_aff *_gf +_cd ,_da .Data [_fe +_cd ]);
_eca !=nil {return _eca ;};};};};return nil ;};func (_cbea *NRGBA64 )NRGBA64At (x ,y int )_f .NRGBA64 {_gfg ,_ :=ColorAtNRGBA64 (x ,y ,_cbea .Width ,_cbea .Data ,_cbea .Alpha ,_cbea .Decode );return _gfg ;};func ColorAtGray4BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_f .Gray ,error ){_begg :=y *bytesPerLine +x >>1;
if _begg >=len (data ){return _f .Gray {},_ee .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_dgda :=data [_begg ]>>uint (4-(x &1)*4)&0xf;if len (decode )==2{_dgda =uint8 (uint32 (LinearInterpolate (float64 (_dgda ),0,15,decode [0],decode [1]))&0xf);};return _f .Gray {Y :_dgda *17&0xff},nil ;};func ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine int ,data []byte ,decode []float64 )(_f .Color ,error ){switch bitsPerColor {case 1:return ColorAtGray1BPC (x ,y ,bytesPerLine ,data ,decode );
case 2:return ColorAtGray2BPC (x ,y ,bytesPerLine ,data ,decode );case 4:return ColorAtGray4BPC (x ,y ,bytesPerLine ,data ,decode );case 8:return ColorAtGray8BPC (x ,y ,bytesPerLine ,data ,decode );case 16:return ColorAtGray16BPC (x ,y ,bytesPerLine ,data ,decode );
default:return nil ,_ee .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0067\u0072\u0061\u0079\u0020\u0073c\u0061\u006c\u0065\u0020\u0062\u0069\u0074s\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020a\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );
};};func (_egcf *Monochrome )AddPadding ()(_cafb error ){if _ebgbc :=((_egcf .Width *_egcf .Height )+7)>>3;len (_egcf .Data )< _ebgbc {return _ee .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064a\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002e\u0020\u0054\u0068\u0065\u0020\u0064\u0061t\u0061\u0020s\u0068\u006fu\u006c\u0064\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0020\u0061\u0074 l\u0065\u0061\u0073\u0074\u003a\u0020\u0027\u0025\u0064'\u0020\u0062\u0079\u0074\u0065\u0073",len (_egcf .Data ),_ebgbc );
};_adc :=_egcf .Width %8;if _adc ==0{return nil ;};_cegf :=_egcf .Width /8;_fgff :=_fg .NewReader (_egcf .Data );_ggfg :=make ([]byte ,_egcf .Height *_egcf .BytesPerLine );_bgffa :=_fg .NewWriterMSB (_ggfg );_baec :=make ([]byte ,_cegf );var (_cea int ;
_cgeb uint64 ;);for _cea =0;_cea < _egcf .Height ;_cea ++{if _ ,_cafb =_fgff .Read (_baec );_cafb !=nil {return _cafb ;};if _ ,_cafb =_bgffa .Write (_baec );_cafb !=nil {return _cafb ;};if _cgeb ,_cafb =_fgff .ReadBits (byte (_adc ));_cafb !=nil {return _cafb ;
};if _cafb =_bgffa .WriteByte (byte (_cgeb )<<uint (8-_adc ));_cafb !=nil {return _cafb ;};};_egcf .Data =_bgffa .Data ();return nil ;};func _cedd (_fadce *_e .Gray16 ,_bcdgd uint8 )*_e .Gray {_gbed :=_fadce .Bounds ();_dabd :=_e .NewGray (_gbed );for _fbagd :=0;
_fbagd < _gbed .Dx ();_fbagd ++{for _gdbd :=0;_gdbd < _gbed .Dy ();_gdbd ++{_abce :=_fadce .Gray16At (_fbagd ,_gdbd );_dabd .SetGray (_fbagd ,_gdbd ,_f .Gray {Y :_fbad (uint8 (_abce .Y /256),_bcdgd )});};};return _dabd ;};func MonochromeModel (threshold uint8 )_f .Model {return monochromeModel (threshold )};
func ColorAtGray2BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_f .Gray ,error ){_ceef :=y *bytesPerLine +x >>2;if _ceef >=len (data ){return _f .Gray {},_ee .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_dfdd :=data [_ceef ]>>uint (6-(x &3)*2)&3;if len (decode )==2{_dfdd =uint8 (uint32 (LinearInterpolate (float64 (_dfdd ),0,3.0,decode [0],decode [1]))&3);};return _f .Gray {Y :_dfdd *85},nil ;};func (_febd *NRGBA64 )Validate ()error {if len (_febd .Data )!=3*2*_febd .Width *_febd .Height {return _d .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func _cdgb (_afeg NRGBA ,_cgca Gray ,_gbgc _e .Rectangle ){for _gdcf :=0;_gdcf < _gbgc .Max .X ;_gdcf ++{for _gfbg :=0;_gfbg < _gbgc .Max .Y ;_gfbg ++{_edff :=_gec (_afeg .NRGBAAt (_gdcf ,_gfbg ));_cgca .SetGray (_gdcf ,_gfbg ,_edff );};
};};func _fbad (_efbc ,_bdfde uint8 )uint8 {if _efbc < _bdfde {return 255;};return 0;};func (_agac *NRGBA16 )At (x ,y int )_f .Color {_acfe ,_ :=_agac .ColorAt (x ,y );return _acfe };func (_acgb *Gray16 )ColorModel ()_f .Model {return _f .Gray16Model };
var _ Image =&Gray4 {};func (_bccd *Monochrome )ColorModel ()_f .Model {return MonochromeModel (_bccd .ModelThreshold )};var ErrInvalidImage =_d .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
func (_cedgf *Gray4 )setGray (_bedf int ,_cgag int ,_fcg _f .Gray ){_edfg :=_cgag *_cedgf .BytesPerLine ;_dfc :=_edfg +(_bedf >>1);if _dfc >=len (_cedgf .Data ){return ;};_bcga :=_fcg .Y >>4;_cedgf .Data [_dfc ]=(_cedgf .Data [_dfc ]&(^(0xf0>>uint (4*(_bedf &1)))))|(_bcga <<uint (4-4*(_bedf &1)));
};func (_gdgad *Gray2 )At (x ,y int )_f .Color {_gbda ,_ :=_gdgad .ColorAt (x ,y );return _gbda };func (_ggfbg *CMYK32 )CMYKAt (x ,y int )_f .CMYK {_ggbb ,_ :=ColorAtCMYK (x ,y ,_ggfbg .Width ,_ggfbg .Data ,_ggfbg .Decode );return _ggbb ;};var _ _e .Image =&Gray4 {};
func _agb (_gcafc _f .Gray )_f .Gray {_fddc :=_gcafc .Y >>6;_fddc |=_fddc <<2;_gcafc .Y =_fddc |_fddc <<4;return _gcafc ;};type RGBA interface{RGBAAt (_edceb ,_eged int )_f .RGBA ;SetRGBA (_agba ,_bcgab int ,_ebdd _f .RGBA );};func _eea (_gfbb int ,_dbaa int )int {if _gfbb < _dbaa {return _gfbb ;
};return _dbaa ;};func _bbcc (_dfeda _e .Image ,_fdfab Image ,_agad _e .Rectangle ){if _fadg ,_cadb :=_dfeda .(SMasker );_cadb &&_fadg .HasAlpha (){_fdfab .(SMasker ).MakeAlpha ();};_egff (_dfeda ,_fdfab ,_agad );};func (_baag *Gray8 )Set (x ,y int ,c _f .Color ){_gagg :=y *_baag .BytesPerLine +x ;
if _gagg > len (_baag .Data )-1{return ;};_efef :=_f .GrayModel .Convert (c );_baag .Data [_gagg ]=_efef .(_f .Gray ).Y ;};func (_daeb *Gray8 )Base ()*ImageBase {return &_daeb .ImageBase };type Monochrome struct{ImageBase ;ModelThreshold uint8 ;};func _bgcf (_aabd ,_dfge Gray ,_feb _e .Rectangle ){for _eeed :=0;
_eeed < _feb .Max .X ;_eeed ++{for _agaa :=0;_agaa < _feb .Max .Y ;_agaa ++{_dfge .SetGray (_eeed ,_agaa ,_aabd .GrayAt (_eeed ,_agaa ));};};};func _ffefa (_cgbeg Gray ,_dgef NRGBA ,_gege _e .Rectangle ){for _aedb :=0;_aedb < _gege .Max .X ;_aedb ++{for _fcdb :=0;
_fcdb < _gege .Max .Y ;_fcdb ++{_bdgc :=_cgbeg .GrayAt (_aedb ,_fcdb );_dgef .SetNRGBA (_aedb ,_fcdb ,_beb (_bdgc ));};};};func (_aag *Gray8 )Copy ()Image {return &Gray8 {ImageBase :_aag .copy ()}};type Histogramer interface{Histogram ()[256]int ;};var _ _e .Image =&NRGBA16 {};
func _abbg (_dggc int ,_ecfg int )error {return _ee .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",_dggc ,_ecfg );
};func _bcb (_gfe _f .RGBA )_f .Gray {_ecdb :=(19595*uint32 (_gfe .R )+38470*uint32 (_gfe .G )+7471*uint32 (_gfe .B )+1<<7)>>16;return _f .Gray {Y :uint8 (_ecdb )};};func ImgToGray (i _e .Image )*_e .Gray {if _bcba ,_adbe :=i .(*_e .Gray );_adbe {return _bcba ;
};_fcdaf :=i .Bounds ();_gfcb :=_e .NewGray (_fcdaf );for _ebf :=0;_ebf < _fcdaf .Max .X ;_ebf ++{for _ebbc :=0;_ebbc < _fcdaf .Max .Y ;_ebbc ++{_cgdfb :=i .At (_ebf ,_ebbc );_gfcb .Set (_ebf ,_ebbc ,_cgdfb );};};return _gfcb ;};func IsPowerOf2 (n uint )bool {return n > 0&&(n &(n -1))==0};
func (_ffgf *Monochrome )ReduceBinary (factor float64 )(*Monochrome ,error ){_fgaa :=_bgffb (uint (factor ));if !IsPowerOf2 (uint (factor )){_fgaa ++;};_fgc :=make ([]int ,_fgaa );for _gade :=range _fgc {_fgc [_gade ]=4;};_bgad ,_bgbg :=_dag (_ffgf ,_fgc ...);
if _bgbg !=nil {return nil ,_bgbg ;};return _bgad ,nil ;};func (_gea *Monochrome )Histogram ()(_daef [256]int ){for _ ,_gcaf :=range _gea .Data {_daef [0xff]+=int (_cgdd [_gea .Data [_gcaf ]]);};return _daef ;};var _ Image =&Monochrome {};type Gray8 struct{ImageBase };
func (_geda *Gray4 )Bounds ()_e .Rectangle {return _e .Rectangle {Max :_e .Point {X :_geda .Width ,Y :_geda .Height }};};func _ebg (_de ,_af *Monochrome )(_eab error ){_bb :=_af .BytesPerLine ;_ecd :=_de .BytesPerLine ;var (_bf byte ;_ef uint16 ;_bc ,_afc ,_db ,_bcf ,_ca int ;
);for _db =0;_db < _af .Height ;_db ++{_bc =_db *_bb ;_afc =2*_db *_ecd ;for _bcf =0;_bcf < _bb ;_bcf ++{_bf =_af .Data [_bc +_bcf ];_ef =_aee [_bf ];_ca =_afc +_bcf *2;if _de .BytesPerLine !=_af .BytesPerLine *2&&(_bcf +1)*2> _de .BytesPerLine {_eab =_de .setByte (_ca ,byte (_ef >>8));
}else {_eab =_de .setTwoBytes (_ca ,_ef );};if _eab !=nil {return _eab ;};};for _bcf =0;_bcf < _ecd ;_bcf ++{_ca =_afc +_ecd +_bcf ;_bf =_de .Data [_afc +_bcf ];if _eab =_de .setByte (_ca ,_bf );_eab !=nil {return _eab ;};};};return nil ;};func (_adbb *NRGBA16 )Set (x ,y int ,c _f .Color ){_aacfa :=y *_adbb .BytesPerLine +x *3/2;
if _aacfa +1>=len (_adbb .Data ){return ;};_eaad :=NRGBA16Model .Convert (c ).(_f .NRGBA );_adbb .setNRGBA (x ,y ,_aacfa ,_eaad );};func _becb (_abcf *_e .NYCbCrA ,_eabgf NRGBA ,_ffcb _e .Rectangle ){for _agga :=0;_agga < _ffcb .Max .X ;_agga ++{for _eae :=0;
_eae < _ffcb .Max .Y ;_eae ++{_aage :=_abcf .NYCbCrAAt (_agga ,_eae );_eabgf .SetNRGBA (_agga ,_eae ,_ede (_aage ));};};};