//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package imageutil ;import (_g "encoding/binary";_b "errors";_db "fmt";_ca "github.com/unidoc/unipdf/v3/common";_bg "github.com/unidoc/unipdf/v3/internal/bitwise";_f "image";_c "image/color";_e "image/draw";_de "math";);func (_ecaa *NRGBA64 )ColorModel ()_c .Model {return _c .NRGBA64Model };
var _ _f .Image =&Gray2 {};func (_ddbb *CMYK32 )CMYKAt (x ,y int )_c .CMYK {_gede ,_ :=ColorAtCMYK (x ,y ,_ddbb .Width ,_ddbb .Data ,_ddbb .Decode );return _gede ;};func ColorAtNRGBA64 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_c .NRGBA64 ,error ){_gcad :=(y *width +x )*2;
_fcdef :=_gcad *3;if _fcdef +5>=len (data ){return _c .NRGBA64 {},_db .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};const _dgea =0xffff;_cefda :=uint16 (_dgea );if alpha !=nil &&len (alpha )> _gcad +1{_cefda =uint16 (alpha [_gcad ])<<8|uint16 (alpha [_gcad +1]);};_gfde :=uint16 (data [_fcdef ])<<8|uint16 (data [_fcdef +1]);_gddgb :=uint16 (data [_fcdef +2])<<8|uint16 (data [_fcdef +3]);
_cbbdb :=uint16 (data [_fcdef +4])<<8|uint16 (data [_fcdef +5]);if len (decode )==6{_gfde =uint16 (uint64 (LinearInterpolate (float64 (_gfde ),0,65535,decode [0],decode [1]))&_dgea );_gddgb =uint16 (uint64 (LinearInterpolate (float64 (_gddgb ),0,65535,decode [2],decode [3]))&_dgea );
_cbbdb =uint16 (uint64 (LinearInterpolate (float64 (_cbbdb ),0,65535,decode [4],decode [5]))&_dgea );};return _c .NRGBA64 {R :_gfde ,G :_gddgb ,B :_cbbdb ,A :_cefda },nil ;};func (_gadd *ImageBase )Pix ()[]byte {return _gadd .Data };func _ac ()(_dba [256]uint32 ){for _fdg :=0;
_fdg < 256;_fdg ++{if _fdg &0x01!=0{_dba [_fdg ]|=0xf;};if _fdg &0x02!=0{_dba [_fdg ]|=0xf0;};if _fdg &0x04!=0{_dba [_fdg ]|=0xf00;};if _fdg &0x08!=0{_dba [_fdg ]|=0xf000;};if _fdg &0x10!=0{_dba [_fdg ]|=0xf0000;};if _fdg &0x20!=0{_dba [_fdg ]|=0xf00000;
};if _fdg &0x40!=0{_dba [_fdg ]|=0xf000000;};if _fdg &0x80!=0{_dba [_fdg ]|=0xf0000000;};};return _dba ;};func ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine int ,data []byte ,decode []float64 )(_c .Color ,error ){switch bitsPerColor {case 1:return ColorAtGray1BPC (x ,y ,bytesPerLine ,data ,decode );
case 2:return ColorAtGray2BPC (x ,y ,bytesPerLine ,data ,decode );case 4:return ColorAtGray4BPC (x ,y ,bytesPerLine ,data ,decode );case 8:return ColorAtGray8BPC (x ,y ,bytesPerLine ,data ,decode );case 16:return ColorAtGray16BPC (x ,y ,bytesPerLine ,data ,decode );
default:return nil ,_db .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0067\u0072\u0061\u0079\u0020\u0073c\u0061\u006c\u0065\u0020\u0062\u0069\u0074s\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020a\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );
};};func IsGrayImgBlackAndWhite (i *_f .Gray )bool {return _dfcg (i )};func ColorAt (x ,y ,width ,bitsPerColor ,colorComponents ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_c .Color ,error ){switch colorComponents {case 1:return ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine ,data ,decode );
case 3:return ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor ,data ,alpha ,decode );case 4:return ColorAtCMYK (x ,y ,width ,data ,decode );default:return nil ,_db .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0063o\u006c\u006f\u0072\u0020\u0063\u006f\u006dp\u006f\u006e\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0064",colorComponents );
};};func (_fefg *Monochrome )Histogram ()(_afd [256]int ){for _ ,_dcfe :=range _fefg .Data {_afd [0xff]+=int (_cdd [_fefg .Data [_dcfe ]]);};return _afd ;};type Image interface{_e .Image ;Base ()*ImageBase ;Copy ()Image ;Pix ()[]byte ;ColorAt (_cbg ,_efdb int )(_c .Color ,error );
Validate ()error ;};type CMYK interface{CMYKAt (_bdeg ,_debg int )_c .CMYK ;SetCMYK (_geg ,_cce int ,_dad _c .CMYK );};func _fbb (_ebd ,_ded *Monochrome ,_aef []byte ,_gagc int )(_fbe error ){var (_acgd ,_fee ,_agf ,_gfge ,_cgb ,_aeg ,_agg ,_afaa int ;
_fae ,_fgf uint32 ;_aadd ,_cfb byte ;_feca uint16 ;);_fdgb :=make ([]byte ,4);_bafa :=make ([]byte ,4);for _agf =0;_agf < _ebd .Height -1;_agf ,_gfge =_agf +2,_gfge +1{_acgd =_agf *_ebd .BytesPerLine ;_fee =_gfge *_ded .BytesPerLine ;for _cgb ,_aeg =0,0;
_cgb < _gagc ;_cgb ,_aeg =_cgb +4,_aeg +1{for _agg =0;_agg < 4;_agg ++{_afaa =_acgd +_cgb +_agg ;if _afaa <=len (_ebd .Data )-1&&_afaa < _acgd +_ebd .BytesPerLine {_fdgb [_agg ]=_ebd .Data [_afaa ];}else {_fdgb [_agg ]=0x00;};_afaa =_acgd +_ebd .BytesPerLine +_cgb +_agg ;
if _afaa <=len (_ebd .Data )-1&&_afaa < _acgd +(2*_ebd .BytesPerLine ){_bafa [_agg ]=_ebd .Data [_afaa ];}else {_bafa [_agg ]=0x00;};};_fae =_g .BigEndian .Uint32 (_fdgb );_fgf =_g .BigEndian .Uint32 (_bafa );_fgf &=_fae ;_fgf &=_fgf <<1;_fgf &=0xaaaaaaaa;
_fae =_fgf |(_fgf <<7);_aadd =byte (_fae >>24);_cfb =byte ((_fae >>8)&0xff);_afaa =_fee +_aeg ;if _afaa +1==len (_ded .Data )-1||_afaa +1>=_fee +_ded .BytesPerLine {_ded .Data [_afaa ]=_aef [_aadd ];if _fbe =_ded .setByte (_afaa ,_aef [_aadd ]);_fbe !=nil {return _db .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_afaa );
};}else {_feca =(uint16 (_aef [_aadd ])<<8)|uint16 (_aef [_cfb ]);if _fbe =_ded .setTwoBytes (_afaa ,_feca );_fbe !=nil {return _db .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_afaa );
};_aeg ++;};};};return nil ;};func _abfa (_egge _f .Image )(Image ,error ){if _dggf ,_bcfa :=_egge .(*Gray4 );_bcfa {return _dggf .Copy (),nil ;};_fbbd :=_egge .Bounds ();_bbe ,_fcde :=NewImage (_fbbd .Max .X ,_fbbd .Max .Y ,4,1,nil ,nil ,nil );if _fcde !=nil {return nil ,_fcde ;
};_abg (_egge ,_bbe ,_fbbd );return _bbe ,nil ;};type monochromeThresholdConverter struct{Threshold uint8 ;};func _ccbc (_agcea NRGBA ,_bcdg Gray ,_cacc _f .Rectangle ){for _dgeeb :=0;_dgeeb < _cacc .Max .X ;_dgeeb ++{for _fcbbf :=0;_fcbbf < _cacc .Max .Y ;
_fcbbf ++{_aacd :=_cbca (_agcea .NRGBAAt (_dgeeb ,_fcbbf ));_bcdg .SetGray (_dgeeb ,_fcbbf ,_aacd );};};};func (_gfc *CMYK32 )Copy ()Image {return &CMYK32 {ImageBase :_gfc .copy ()}};func (_aae *Monochrome )Copy ()Image {return &Monochrome {ImageBase :_aae .ImageBase .copy (),ModelThreshold :_aae .ModelThreshold };
};func _acf (_bcg _c .RGBA )_c .NRGBA {switch _bcg .A {case 0xff:return _c .NRGBA {R :_bcg .R ,G :_bcg .G ,B :_bcg .B ,A :0xff};case 0x00:return _c .NRGBA {};default:_cfce ,_bgd ,_daf ,_ddfd :=_bcg .RGBA ();_cfce =(_cfce *0xffff)/_ddfd ;_bgd =(_bgd *0xffff)/_ddfd ;
_daf =(_daf *0xffff)/_ddfd ;return _c .NRGBA {R :uint8 (_cfce >>8),G :uint8 (_bgd >>8),B :uint8 (_daf >>8),A :uint8 (_ddfd >>8)};};};func (_affb *Monochrome )Set (x ,y int ,c _c .Color ){_dgfc :=y *_affb .BytesPerLine +x >>3;if _dgfc > len (_affb .Data )-1{return ;
};_dfb :=_affb .ColorModel ().Convert (c ).(_c .Gray );_affb .setGray (x ,_dfb ,_dgfc );};func _dfa (_bc ,_afb *Monochrome )(_bfg error ){_bfgc :=_afb .BytesPerLine ;_ag :=_bc .BytesPerLine ;var _dg ,_egf ,_bff ,_cb ,_ad int ;for _bff =0;_bff < _afb .Height ;
_bff ++{_dg =_bff *_bfgc ;_egf =8*_bff *_ag ;for _cb =0;_cb < _bfgc ;_cb ++{if _bfg =_bc .setEightBytes (_egf +_cb *8,_afbc [_afb .Data [_dg +_cb ]]);_bfg !=nil {return _bfg ;};};for _ad =1;_ad < 8;_ad ++{for _cb =0;_cb < _ag ;_cb ++{if _bfg =_bc .setByte (_egf +_ad *_ag +_cb ,_bc .Data [_egf +_cb ]);
_bfg !=nil {return _bfg ;};};};};return nil ;};func (_fde *Gray4 )SetGray (x ,y int ,g _c .Gray ){if x >=_fde .Width ||y >=_fde .Height {return ;};g =_acagg (g );_fde .setGray (x ,y ,g );};func (_gbdc *NRGBA64 )SetNRGBA64 (x ,y int ,c _c .NRGBA64 ){_dbbe :=(y *_gbdc .Width +x )*2;
_gceg :=_dbbe *3;if _gceg +5>=len (_gbdc .Data ){return ;};_gbdc .setNRGBA64 (_gceg ,c ,_dbbe );};func (_aafd monochromeModel )Convert (c _c .Color )_c .Color {_ceff :=_c .GrayModel .Convert (c ).(_c .Gray );return _ecfdb (_ceff ,_aafd );};var (_ffeae =[]byte {0x00,0x80,0xC0,0xE0,0xF0,0xF8,0xFC,0xFE,0xFF};
_ccde =[]byte {0x00,0x01,0x03,0x07,0x0F,0x1F,0x3F,0x7F,0xFF};);var _ _f .Image =&NRGBA64 {};func _babb (_aeac _c .Color )_c .Color {_bfcf :=_c .GrayModel .Convert (_aeac ).(_c .Gray );return _cbae (_bfcf );};func (_fgff *ImageBase )getByte (_fcc int )(byte ,error ){if _fcc > len (_fgff .Data )-1||_fcc < 0{return 0,_db .Errorf ("\u0069\u006e\u0064\u0065x:\u0020\u0025\u0064\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006eg\u0065",_fcc );
};return _fgff .Data [_fcc ],nil ;};func _aeef (_gcff _c .NRGBA64 )_c .NRGBA {return _c .NRGBA {R :uint8 (_gcff .R >>8),G :uint8 (_gcff .G >>8),B :uint8 (_gcff .B >>8),A :uint8 (_gcff .A >>8)};};type ColorConverter interface{Convert (_gcdc _f .Image )(Image ,error );
};func (_daaa *ImageBase )setEightBytes (_fdfb int ,_fgbbd uint64 )error {_agcdf :=_daaa .BytesPerLine -(_fdfb %_daaa .BytesPerLine );if _daaa .BytesPerLine !=_daaa .Width >>3{_agcdf --;};if _agcdf >=8{return _daaa .setEightFullBytes (_fdfb ,_fgbbd );};
return _daaa .setEightPartlyBytes (_fdfb ,_agcdf ,_fgbbd );};func GetConverter (bitsPerComponent ,colorComponents int )(ColorConverter ,error ){switch colorComponents {case 1:switch bitsPerComponent {case 1:return MonochromeConverter ,nil ;case 2:return Gray2Converter ,nil ;
case 4:return Gray4Converter ,nil ;case 8:return GrayConverter ,nil ;case 16:return Gray16Converter ,nil ;};case 3:switch bitsPerComponent {case 4:return NRGBA16Converter ,nil ;case 8:return NRGBAConverter ,nil ;case 16:return NRGBA64Converter ,nil ;};
case 4:return CMYKConverter ,nil ;};return nil ,_db .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0043o\u006e\u0076\u0065\u0072\u0074\u0065\u0072\u0020\u0070\u0061\u0072\u0061\u006d\u0065t\u0065\u0072\u0073\u002e\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003a\u0020\u0025\u0064\u002c\u0020\u0043\u006f\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006et\u0073\u003a \u0025\u0064",bitsPerComponent ,colorComponents );
};func _df (_cd ,_ged *Monochrome )(_bf error ){_ef :=_ged .BytesPerLine ;_af :=_cd .BytesPerLine ;var (_dd byte ;_geb uint16 ;_cg ,_fd ,_egg ,_eb ,_aa int ;);for _egg =0;_egg < _ged .Height ;_egg ++{_cg =_egg *_ef ;_fd =2*_egg *_af ;for _eb =0;_eb < _ef ;
_eb ++{_dd =_ged .Data [_cg +_eb ];_geb =_gfb [_dd ];_aa =_fd +_eb *2;if _cd .BytesPerLine !=_ged .BytesPerLine *2&&(_eb +1)*2> _cd .BytesPerLine {_bf =_cd .setByte (_aa ,byte (_geb >>8));}else {_bf =_cd .setTwoBytes (_aa ,_geb );};if _bf !=nil {return _bf ;
};};for _eb =0;_eb < _af ;_eb ++{_aa =_fd +_af +_eb ;_dd =_cd .Data [_fd +_eb ];if _bf =_cd .setByte (_aa ,_dd );_bf !=nil {return _bf ;};};};return nil ;};func (_gacgb *Gray8 )Copy ()Image {return &Gray8 {ImageBase :_gacgb .copy ()}};func _cbd (_aacb Gray ,_ada nrgba64 ,_aeb _f .Rectangle ){for _adge :=0;
_adge < _aeb .Max .X ;_adge ++{for _fgeg :=0;_fgeg < _aeb .Max .Y ;_fgeg ++{_ggad :=_dadd (_ada .NRGBA64At (_adge ,_fgeg ));_aacb .SetGray (_adge ,_fgeg ,_ggad );};};};var (MonochromeConverter =ConverterFunc (_fceba );Gray2Converter =ConverterFunc (_adcd );
Gray4Converter =ConverterFunc (_abfa );GrayConverter =ConverterFunc (_abd );Gray16Converter =ConverterFunc (_fage );NRGBA16Converter =ConverterFunc (_bbcgb );NRGBAConverter =ConverterFunc (_ebbg );NRGBA64Converter =ConverterFunc (_dfba );CMYKConverter =ConverterFunc (_ecbd );
);type colorConverter struct{_ebad func (_bac _f .Image )(Image ,error );};type RasterOperator int ;func (_bbbc *Gray2 )Bounds ()_f .Rectangle {return _f .Rectangle {Max :_f .Point {X :_bbbc .Width ,Y :_bbbc .Height }};};func (_fdf *CMYK32 )ColorModel ()_c .Model {return _c .CMYKModel };
func (_efcc *Monochrome )RasterOperation (dx ,dy ,dw ,dh int ,op RasterOperator ,src *Monochrome ,sx ,sy int )error {return _dffac (_efcc ,dx ,dy ,dw ,dh ,op ,src ,sx ,sy );};func (_dcfb *Gray2 )Base ()*ImageBase {return &_dcfb .ImageBase };type Gray16 struct{ImageBase };
func (_ffg *Gray2 )Histogram ()(_fefe [256]int ){for _bbgfc :=0;_bbgfc < _ffg .Width ;_bbgfc ++{for _ece :=0;_ece < _ffg .Height ;_ece ++{_fefe [_ffg .GrayAt (_bbgfc ,_ece ).Y ]++;};};return _fefe ;};var _ Gray =&Monochrome {};func _geee (_egad *Monochrome ,_gfac ,_gcde ,_ccgd ,_eadg int ,_fgbbb RasterOperator ,_fefeg *Monochrome ,_cddf ,_bda int )error {var (_cfe byte ;
_eccb int ;_gedcc int ;_cggeg ,_cffbd int ;_eccg ,_eccbg int ;);_bbgfa :=_ccgd >>3;_dgdf :=_ccgd &7;if _dgdf > 0{_cfe =_ffeae [_dgdf ];};_eccb =_fefeg .BytesPerLine *_bda +(_cddf >>3);_gedcc =_egad .BytesPerLine *_gcde +(_gfac >>3);switch _fgbbb {case PixSrc :for _eccg =0;
_eccg < _eadg ;_eccg ++{_cggeg =_eccb +_eccg *_fefeg .BytesPerLine ;_cffbd =_gedcc +_eccg *_egad .BytesPerLine ;for _eccbg =0;_eccbg < _bbgfa ;_eccbg ++{_egad .Data [_cffbd ]=_fefeg .Data [_cggeg ];_cffbd ++;_cggeg ++;};if _dgdf > 0{_egad .Data [_cffbd ]=_cdcf (_egad .Data [_cffbd ],_fefeg .Data [_cggeg ],_cfe );
};};case PixNotSrc :for _eccg =0;_eccg < _eadg ;_eccg ++{_cggeg =_eccb +_eccg *_fefeg .BytesPerLine ;_cffbd =_gedcc +_eccg *_egad .BytesPerLine ;for _eccbg =0;_eccbg < _bbgfa ;_eccbg ++{_egad .Data [_cffbd ]=^(_fefeg .Data [_cggeg ]);_cffbd ++;_cggeg ++;
};if _dgdf > 0{_egad .Data [_cffbd ]=_cdcf (_egad .Data [_cffbd ],^_fefeg .Data [_cggeg ],_cfe );};};case PixSrcOrDst :for _eccg =0;_eccg < _eadg ;_eccg ++{_cggeg =_eccb +_eccg *_fefeg .BytesPerLine ;_cffbd =_gedcc +_eccg *_egad .BytesPerLine ;for _eccbg =0;
_eccbg < _bbgfa ;_eccbg ++{_egad .Data [_cffbd ]|=_fefeg .Data [_cggeg ];_cffbd ++;_cggeg ++;};if _dgdf > 0{_egad .Data [_cffbd ]=_cdcf (_egad .Data [_cffbd ],_fefeg .Data [_cggeg ]|_egad .Data [_cffbd ],_cfe );};};case PixSrcAndDst :for _eccg =0;_eccg < _eadg ;
_eccg ++{_cggeg =_eccb +_eccg *_fefeg .BytesPerLine ;_cffbd =_gedcc +_eccg *_egad .BytesPerLine ;for _eccbg =0;_eccbg < _bbgfa ;_eccbg ++{_egad .Data [_cffbd ]&=_fefeg .Data [_cggeg ];_cffbd ++;_cggeg ++;};if _dgdf > 0{_egad .Data [_cffbd ]=_cdcf (_egad .Data [_cffbd ],_fefeg .Data [_cggeg ]&_egad .Data [_cffbd ],_cfe );
};};case PixSrcXorDst :for _eccg =0;_eccg < _eadg ;_eccg ++{_cggeg =_eccb +_eccg *_fefeg .BytesPerLine ;_cffbd =_gedcc +_eccg *_egad .BytesPerLine ;for _eccbg =0;_eccbg < _bbgfa ;_eccbg ++{_egad .Data [_cffbd ]^=_fefeg .Data [_cggeg ];_cffbd ++;_cggeg ++;
};if _dgdf > 0{_egad .Data [_cffbd ]=_cdcf (_egad .Data [_cffbd ],_fefeg .Data [_cggeg ]^_egad .Data [_cffbd ],_cfe );};};case PixNotSrcOrDst :for _eccg =0;_eccg < _eadg ;_eccg ++{_cggeg =_eccb +_eccg *_fefeg .BytesPerLine ;_cffbd =_gedcc +_eccg *_egad .BytesPerLine ;
for _eccbg =0;_eccbg < _bbgfa ;_eccbg ++{_egad .Data [_cffbd ]|=^(_fefeg .Data [_cggeg ]);_cffbd ++;_cggeg ++;};if _dgdf > 0{_egad .Data [_cffbd ]=_cdcf (_egad .Data [_cffbd ],^(_fefeg .Data [_cggeg ])|_egad .Data [_cffbd ],_cfe );};};case PixNotSrcAndDst :for _eccg =0;
_eccg < _eadg ;_eccg ++{_cggeg =_eccb +_eccg *_fefeg .BytesPerLine ;_cffbd =_gedcc +_eccg *_egad .BytesPerLine ;for _eccbg =0;_eccbg < _bbgfa ;_eccbg ++{_egad .Data [_cffbd ]&=^(_fefeg .Data [_cggeg ]);_cffbd ++;_cggeg ++;};if _dgdf > 0{_egad .Data [_cffbd ]=_cdcf (_egad .Data [_cffbd ],^(_fefeg .Data [_cggeg ])&_egad .Data [_cffbd ],_cfe );
};};case PixSrcOrNotDst :for _eccg =0;_eccg < _eadg ;_eccg ++{_cggeg =_eccb +_eccg *_fefeg .BytesPerLine ;_cffbd =_gedcc +_eccg *_egad .BytesPerLine ;for _eccbg =0;_eccbg < _bbgfa ;_eccbg ++{_egad .Data [_cffbd ]=_fefeg .Data [_cggeg ]|^(_egad .Data [_cffbd ]);
_cffbd ++;_cggeg ++;};if _dgdf > 0{_egad .Data [_cffbd ]=_cdcf (_egad .Data [_cffbd ],_fefeg .Data [_cggeg ]|^(_egad .Data [_cffbd ]),_cfe );};};case PixSrcAndNotDst :for _eccg =0;_eccg < _eadg ;_eccg ++{_cggeg =_eccb +_eccg *_fefeg .BytesPerLine ;_cffbd =_gedcc +_eccg *_egad .BytesPerLine ;
for _eccbg =0;_eccbg < _bbgfa ;_eccbg ++{_egad .Data [_cffbd ]=_fefeg .Data [_cggeg ]&^(_egad .Data [_cffbd ]);_cffbd ++;_cggeg ++;};if _dgdf > 0{_egad .Data [_cffbd ]=_cdcf (_egad .Data [_cffbd ],_fefeg .Data [_cggeg ]&^(_egad .Data [_cffbd ]),_cfe );
};};case PixNotPixSrcOrDst :for _eccg =0;_eccg < _eadg ;_eccg ++{_cggeg =_eccb +_eccg *_fefeg .BytesPerLine ;_cffbd =_gedcc +_eccg *_egad .BytesPerLine ;for _eccbg =0;_eccbg < _bbgfa ;_eccbg ++{_egad .Data [_cffbd ]=^(_fefeg .Data [_cggeg ]|_egad .Data [_cffbd ]);
_cffbd ++;_cggeg ++;};if _dgdf > 0{_egad .Data [_cffbd ]=_cdcf (_egad .Data [_cffbd ],^(_fefeg .Data [_cggeg ]|_egad .Data [_cffbd ]),_cfe );};};case PixNotPixSrcAndDst :for _eccg =0;_eccg < _eadg ;_eccg ++{_cggeg =_eccb +_eccg *_fefeg .BytesPerLine ;_cffbd =_gedcc +_eccg *_egad .BytesPerLine ;
for _eccbg =0;_eccbg < _bbgfa ;_eccbg ++{_egad .Data [_cffbd ]=^(_fefeg .Data [_cggeg ]&_egad .Data [_cffbd ]);_cffbd ++;_cggeg ++;};if _dgdf > 0{_egad .Data [_cffbd ]=_cdcf (_egad .Data [_cffbd ],^(_fefeg .Data [_cggeg ]&_egad .Data [_cffbd ]),_cfe );
};};case PixNotPixSrcXorDst :for _eccg =0;_eccg < _eadg ;_eccg ++{_cggeg =_eccb +_eccg *_fefeg .BytesPerLine ;_cffbd =_gedcc +_eccg *_egad .BytesPerLine ;for _eccbg =0;_eccbg < _bbgfa ;_eccbg ++{_egad .Data [_cffbd ]=^(_fefeg .Data [_cggeg ]^_egad .Data [_cffbd ]);
_cffbd ++;_cggeg ++;};if _dgdf > 0{_egad .Data [_cffbd ]=_cdcf (_egad .Data [_cffbd ],^(_fefeg .Data [_cggeg ]^_egad .Data [_cffbd ]),_cfe );};};default:_ca .Log .Debug ("\u0050\u0072ov\u0069\u0064\u0065d\u0020\u0069\u006e\u0076ali\u0064 r\u0061\u0073\u0074\u0065\u0072\u0020\u006fpe\u0072\u0061\u0074\u006f\u0072\u003a\u0020%\u0076",_fgbbb );
return _b .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072");};return nil ;};var _ _f .Image =&Gray4 {};func _ecbd (_bed _f .Image )(Image ,error ){if _gdg ,_cggb :=_bed .(*CMYK32 );
_cggb {return _gdg .Copy (),nil ;};_fgba :=_bed .Bounds ();_dbfc ,_bgg :=NewImage (_fgba .Max .X ,_fgba .Max .Y ,8,4,nil ,nil ,nil );if _bgg !=nil {return nil ,_bgg ;};switch _eaa :=_bed .(type ){case CMYK :_agb (_eaa ,_dbfc .(CMYK ),_fgba );case Gray :_fggf (_eaa ,_dbfc .(CMYK ),_fgba );
case NRGBA :_ddd (_eaa ,_dbfc .(CMYK ),_fgba );case RGBA :_edg (_eaa ,_dbfc .(CMYK ),_fgba );default:_dcbb (_bed ,_dbfc ,_fgba );};return _dbfc ,nil ;};func _dcb (_ecbf ,_bbgb *Monochrome ,_cdg []byte ,_gab int )(_gbc error ){var (_cdf ,_caegc ,_adf ,_edc ,_eacd ,_abc ,_gda ,_ccd int ;
_daeb ,_bdeb ,_gcc ,_cfg uint32 ;_eebb ,_bcf byte ;_cca uint16 ;);_dgc :=make ([]byte ,4);_dga :=make ([]byte ,4);for _adf =0;_adf < _ecbf .Height -1;_adf ,_edc =_adf +2,_edc +1{_cdf =_adf *_ecbf .BytesPerLine ;_caegc =_edc *_bbgb .BytesPerLine ;for _eacd ,_abc =0,0;
_eacd < _gab ;_eacd ,_abc =_eacd +4,_abc +1{for _gda =0;_gda < 4;_gda ++{_ccd =_cdf +_eacd +_gda ;if _ccd <=len (_ecbf .Data )-1&&_ccd < _cdf +_ecbf .BytesPerLine {_dgc [_gda ]=_ecbf .Data [_ccd ];}else {_dgc [_gda ]=0x00;};_ccd =_cdf +_ecbf .BytesPerLine +_eacd +_gda ;
if _ccd <=len (_ecbf .Data )-1&&_ccd < _cdf +(2*_ecbf .BytesPerLine ){_dga [_gda ]=_ecbf .Data [_ccd ];}else {_dga [_gda ]=0x00;};};_daeb =_g .BigEndian .Uint32 (_dgc );_bdeb =_g .BigEndian .Uint32 (_dga );_gcc =_daeb &_bdeb ;_gcc |=_gcc <<1;_cfg =_daeb |_bdeb ;
_cfg &=_cfg <<1;_bdeb =_gcc &_cfg ;_bdeb &=0xaaaaaaaa;_daeb =_bdeb |(_bdeb <<7);_eebb =byte (_daeb >>24);_bcf =byte ((_daeb >>8)&0xff);_ccd =_caegc +_abc ;if _ccd +1==len (_bbgb .Data )-1||_ccd +1>=_caegc +_bbgb .BytesPerLine {if _gbc =_bbgb .setByte (_ccd ,_cdg [_eebb ]);
_gbc !=nil {return _db .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_ccd );};}else {_cca =(uint16 (_cdg [_eebb ])<<8)|uint16 (_cdg [_bcf ]);if _gbc =_bbgb .setTwoBytes (_ccd ,_cca );_gbc !=nil {return _db .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_ccd );
};_abc ++;};};};return nil ;};func (_bgdb *ImageBase )MakeAlpha (){_bgdb .newAlpha ()};type Gray4 struct{ImageBase };func ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor int ,data ,alpha []byte ,decode []float64 )(_c .Color ,error ){switch bitsPerColor {case 4:return ColorAtNRGBA16 (x ,y ,width ,bytesPerLine ,data ,alpha ,decode );
case 8:return ColorAtNRGBA32 (x ,y ,width ,data ,alpha ,decode );case 16:return ColorAtNRGBA64 (x ,y ,width ,data ,alpha ,decode );default:return nil ,_db .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0067\u0062\u0020b\u0069\u0074\u0073\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0061\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );
};};type nrgba64 interface{NRGBA64At (_caad ,_acfb int )_c .NRGBA64 ;SetNRGBA64 (_gaebf ,_eccad int ,_beee _c .NRGBA64 );};func (_beb *CMYK32 )Bounds ()_f .Rectangle {return _f .Rectangle {Max :_f .Point {X :_beb .Width ,Y :_beb .Height }};};func (_acab *ImageBase )HasAlpha ()bool {if _acab .Alpha ==nil {return false ;
};for _ebbd :=range _acab .Alpha {if _acab .Alpha [_ebbd ]!=0xff{return true ;};};return false ;};func (_dfdc *Monochrome )setBit (_cccg ,_cfaa int ){_dfdc .Data [_cccg +(_cfaa >>3)]|=0x80>>uint (_cfaa &7);};func (_dbgdd *Gray16 )SetGray (x ,y int ,g _c .Gray ){_gabc :=(y *_dbgdd .BytesPerLine /2+x )*2;
if _gabc +1>=len (_dbgdd .Data ){return ;};_dbgdd .Data [_gabc ]=g .Y ;_dbgdd .Data [_gabc +1]=g .Y ;};func (_dace *Gray4 )Base ()*ImageBase {return &_dace .ImageBase };var _ Gray =&Gray8 {};func (_cbge *NRGBA32 )NRGBAAt (x ,y int )_c .NRGBA {_aadc ,_ :=ColorAtNRGBA32 (x ,y ,_cbge .Width ,_cbge .Data ,_cbge .Alpha ,_cbge .Decode );
return _aadc ;};func _fggg (_gfe *Monochrome ,_gdba ,_egagf ,_acgaa ,_gacc int ,_bcbc RasterOperator ){if _gdba < 0{_acgaa +=_gdba ;_gdba =0;};_dcea :=_gdba +_acgaa -_gfe .Width ;if _dcea > 0{_acgaa -=_dcea ;};if _egagf < 0{_gacc +=_egagf ;_egagf =0;};
_dgda :=_egagf +_gacc -_gfe .Height ;if _dgda > 0{_gacc -=_dgda ;};if _acgaa <=0||_gacc <=0{return ;};if (_gdba &7)==0{_aag (_gfe ,_gdba ,_egagf ,_acgaa ,_gacc ,_bcbc );}else {_beag (_gfe ,_gdba ,_egagf ,_acgaa ,_gacc ,_bcbc );};};func _fege (_ebdc int ,_afaf int )int {if _ebdc < _afaf {return _ebdc ;
};return _afaf ;};func AddDataPadding (width ,height ,bitsPerComponent ,colorComponents int ,data []byte )([]byte ,error ){_addf :=BytesPerLine (width ,bitsPerComponent ,colorComponents );if _addf ==width *colorComponents *bitsPerComponent /8{return data ,nil ;
};_bdff :=width *colorComponents *bitsPerComponent ;_deed :=_addf *8;_dcce :=8-(_deed -_bdff );_faac :=_bg .NewReader (data );_egbc :=_addf -1;_fdag :=make ([]byte ,_egbc );_feda :=make ([]byte ,height *_addf );_cdeg :=_bg .NewWriterMSB (_feda );var _ffbb uint64 ;
var _eegf error ;for _edfc :=0;_edfc < height ;_edfc ++{_ ,_eegf =_faac .Read (_fdag );if _eegf !=nil {return nil ,_eegf ;};_ ,_eegf =_cdeg .Write (_fdag );if _eegf !=nil {return nil ,_eegf ;};_ffbb ,_eegf =_faac .ReadBits (byte (_dcce ));if _eegf !=nil {return nil ,_eegf ;
};_ ,_eegf =_cdeg .WriteBits (_ffbb ,_dcce );if _eegf !=nil {return nil ,_eegf ;};_cdeg .FinishByte ();};return _feda ,nil ;};func (_eeeg *NRGBA32 )Copy ()Image {return &NRGBA32 {ImageBase :_eeeg .copy ()}};func init (){_aed ()};func _ddfbf (_eag ,_eaea NRGBA ,_ggg _f .Rectangle ){for _cdae :=0;
_cdae < _ggg .Max .X ;_cdae ++{for _ebgd :=0;_ebgd < _ggg .Max .Y ;_ebgd ++{_eaea .SetNRGBA (_cdae ,_ebgd ,_eag .NRGBAAt (_cdae ,_ebgd ));};};};func (_fbef *CMYK32 )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtCMYK (x ,y ,_fbef .Width ,_fbef .Data ,_fbef .Decode );
};func _gfbg (_fceb int )[]uint {var _dgd []uint ;_cf :=_fceb ;_cea :=_cf /8;if _cea !=0{for _feg :=0;_feg < _cea ;_feg ++{_dgd =append (_dgd ,8);};_eeg :=_cf %8;_cf =0;if _eeg !=0{_cf =_eeg ;};};_bde :=_cf /4;if _bde !=0{for _bcb :=0;_bcb < _bde ;_bcb ++{_dgd =append (_dgd ,4);
};_fbf :=_cf %4;_cf =0;if _fbf !=0{_cf =_fbf ;};};_edb :=_cf /2;if _edb !=0{for _gbd :=0;_gbd < _edb ;_gbd ++{_dgd =append (_dgd ,2);};};return _dgd ;};func _eadc (_gdb _c .Color )_c .Color {_gdaa :=_c .GrayModel .Convert (_gdb ).(_c .Gray );return _acagg (_gdaa );
};func _ffdf (_egfc CMYK ,_cdgg NRGBA ,_fcbg _f .Rectangle ){for _acdc :=0;_acdc < _fcbg .Max .X ;_acdc ++{for _cceda :=0;_cceda < _fcbg .Max .Y ;_cceda ++{_afec :=_egfc .CMYKAt (_acdc ,_cceda );_cdgg .SetNRGBA (_acdc ,_cceda ,_dcc (_afec ));};};};func ColorAtGray1BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_c .Gray ,error ){_cgad :=y *bytesPerLine +x >>3;
if _cgad >=len (data ){return _c .Gray {},_db .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_adbg :=data [_cgad ]>>uint (7-(x &7))&1;if len (decode )==2{_adbg =uint8 (LinearInterpolate (float64 (_adbg ),0.0,1.0,decode [0],decode [1]))&1;};return _c .Gray {Y :_adbg *255},nil ;};type Gray interface{GrayAt (_cbe ,_egd int )_c .Gray ;SetGray (_bdg ,_gaaf int ,_baae _c .Gray );
};func ColorAtGray2BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_c .Gray ,error ){_ffde :=y *bytesPerLine +x >>2;if _ffde >=len (data ){return _c .Gray {},_db .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_befg :=data [_ffde ]>>uint (6-(x &3)*2)&3;if len (decode )==2{_befg =uint8 (uint32 (LinearInterpolate (float64 (_befg ),0,3.0,decode [0],decode [1]))&3);};return _c .Gray {Y :_befg *85},nil ;};var _ NRGBA =&NRGBA32 {};func (_efcg *Gray2 )GrayAt (x ,y int )_c .Gray {_bcea ,_ :=ColorAtGray2BPC (x ,y ,_efcg .BytesPerLine ,_efcg .Data ,_efcg .Decode );
return _bcea ;};func (_fbd *Gray8 )ColorModel ()_c .Model {return _c .GrayModel };func (_adddd *Gray16 )Base ()*ImageBase {return &_adddd .ImageBase };func (_cege *Monochrome )ReduceBinary (factor float64 )(*Monochrome ,error ){_aec :=_ddbgf (uint (factor ));
if !IsPowerOf2 (uint (factor )){_aec ++;};_eaad :=make ([]int ,_aec );for _fcf :=range _eaad {_eaad [_fcf ]=4;};_gaaa ,_deca :=_bfd (_cege ,_eaad ...);if _deca !=nil {return nil ,_deca ;};return _gaaa ,nil ;};func RasterOperation (dest *Monochrome ,dx ,dy ,dw ,dh int ,op RasterOperator ,src *Monochrome ,sx ,sy int )error {return _dffac (dest ,dx ,dy ,dw ,dh ,op ,src ,sx ,sy );
};func (_bafb *Gray8 )GrayAt (x ,y int )_c .Gray {_bcd ,_ :=ColorAtGray8BPC (x ,y ,_bafb .BytesPerLine ,_bafb .Data ,_bafb .Decode );return _bcd ;};func _gddg (_dac _c .NRGBA )_c .CMYK {_acb ,_dgcc ,_ccef ,_ :=_dac .RGBA ();_bcag ,_gfd ,_abe ,_ddba :=_c .RGBToCMYK (uint8 (_acb >>8),uint8 (_dgcc >>8),uint8 (_ccef >>8));
return _c .CMYK {C :_bcag ,M :_gfd ,Y :_abe ,K :_ddba };};func _cbae (_dffa _c .Gray )_c .Gray {_egdd :=_dffa .Y >>6;_egdd |=_egdd <<2;_dffa .Y =_egdd |_egdd <<4;return _dffa ;};func _dcbb (_cacb _f .Image ,_ebac Image ,_abb _f .Rectangle ){for _dec :=0;
_dec < _abb .Max .X ;_dec ++{for _eed :=0;_eed < _abb .Max .Y ;_eed ++{_fcdg :=_cacb .At (_dec ,_eed );_ebac .Set (_dec ,_eed ,_fcdg );};};};func (_dadb *CMYK32 )At (x ,y int )_c .Color {_efb ,_ :=_dadb .ColorAt (x ,y );return _efb };func (_eccc *NRGBA64 )setNRGBA64 (_befa int ,_cegea _c .NRGBA64 ,_efag int ){_eccc .Data [_befa ]=uint8 (_cegea .R >>8);
_eccc .Data [_befa +1]=uint8 (_cegea .R &0xff);_eccc .Data [_befa +2]=uint8 (_cegea .G >>8);_eccc .Data [_befa +3]=uint8 (_cegea .G &0xff);_eccc .Data [_befa +4]=uint8 (_cegea .B >>8);_eccc .Data [_befa +5]=uint8 (_cegea .B &0xff);if _efag +1< len (_eccc .Alpha ){_eccc .Alpha [_efag ]=uint8 (_cegea .A >>8);
_eccc .Alpha [_efag +1]=uint8 (_cegea .A &0xff);};};func (_eab *monochromeThresholdConverter )Convert (img _f .Image )(Image ,error ){if _gbdd ,_aadad :=img .(*Monochrome );_aadad {return _gbdd .Copy (),nil ;};_bbd :=img .Bounds ();_ecca ,_ddfb :=NewImage (_bbd .Max .X ,_bbd .Max .Y ,1,1,nil ,nil ,nil );
if _ddfb !=nil {return nil ,_ddfb ;};_ecca .(*Monochrome ).ModelThreshold =_eab .Threshold ;for _dcg :=0;_dcg < _bbd .Max .X ;_dcg ++{for _bgc :=0;_bgc < _bbd .Max .Y ;_bgc ++{_acag :=img .At (_dcg ,_bgc );_ecca .Set (_dcg ,_bgc ,_acag );};};return _ecca ,nil ;
};type monochromeModel uint8 ;func _dbg (_fgfd _c .RGBA )_c .Gray {_efae :=(19595*uint32 (_fgfd .R )+38470*uint32 (_fgfd .G )+7471*uint32 (_fgfd .B )+1<<7)>>16;return _c .Gray {Y :uint8 (_efae )};};func (_ddbg *Monochrome )clearBit (_gfgb ,_cdfd int ){_ddbg .Data [_gfgb ]&=^(0x80>>uint (_cdfd &7))};
func _fbcc (_cgac _c .NRGBA )_c .NRGBA {_cgac .R =_cgac .R >>4|(_cgac .R >>4)<<4;_cgac .G =_cgac .G >>4|(_cgac .G >>4)<<4;_cgac .B =_cgac .B >>4|(_cgac .B >>4)<<4;return _cgac ;};var _ _f .Image =&Gray8 {};func _bfda (_eefg uint8 )bool {if _eefg ==0||_eefg ==255{return true ;
};return false ;};type shift int ;func _ddbgf (_daag uint )uint {var _eecc uint ;for _daag !=0{_daag >>=1;_eecc ++;};return _eecc -1;};func _ddfa (_dgee ,_aff *Monochrome ,_dfd []byte ,_acgb int )(_ffe error ){var (_fcga ,_gfg ,_fcd ,_bbb ,_afa ,_cdb ,_eac ,_ecfd int ;
_bca ,_aca ,_fbg ,_add uint32 ;_ceaf ,_ceg byte ;_ecd uint16 ;);_fge :=make ([]byte ,4);_gd :=make ([]byte ,4);for _fcd =0;_fcd < _dgee .Height -1;_fcd ,_bbb =_fcd +2,_bbb +1{_fcga =_fcd *_dgee .BytesPerLine ;_gfg =_bbb *_aff .BytesPerLine ;for _afa ,_cdb =0,0;
_afa < _acgb ;_afa ,_cdb =_afa +4,_cdb +1{for _eac =0;_eac < 4;_eac ++{_ecfd =_fcga +_afa +_eac ;if _ecfd <=len (_dgee .Data )-1&&_ecfd < _fcga +_dgee .BytesPerLine {_fge [_eac ]=_dgee .Data [_ecfd ];}else {_fge [_eac ]=0x00;};_ecfd =_fcga +_dgee .BytesPerLine +_afa +_eac ;
if _ecfd <=len (_dgee .Data )-1&&_ecfd < _fcga +(2*_dgee .BytesPerLine ){_gd [_eac ]=_dgee .Data [_ecfd ];}else {_gd [_eac ]=0x00;};};_bca =_g .BigEndian .Uint32 (_fge );_aca =_g .BigEndian .Uint32 (_gd );_fbg =_bca &_aca ;_fbg |=_fbg <<1;_add =_bca |_aca ;
_add &=_add <<1;_aca =_fbg |_add ;_aca &=0xaaaaaaaa;_bca =_aca |(_aca <<7);_ceaf =byte (_bca >>24);_ceg =byte ((_bca >>8)&0xff);_ecfd =_gfg +_cdb ;if _ecfd +1==len (_aff .Data )-1||_ecfd +1>=_gfg +_aff .BytesPerLine {if _ffe =_aff .setByte (_ecfd ,_dfd [_ceaf ]);
_ffe !=nil {return _db .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_ecfd );};}else {_ecd =(uint16 (_dfd [_ceaf ])<<8)|uint16 (_dfd [_ceg ]);if _ffe =_aff .setTwoBytes (_ecfd ,_ecd );_ffe !=nil {return _db .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_ecfd );
};_cdb ++;};};};return nil ;};func (_fgbc *Monochrome )AddPadding ()(_gde error ){if _efgb :=((_fgbc .Width *_fgbc .Height )+7)>>3;len (_fgbc .Data )< _efgb {return _db .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064a\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002e\u0020\u0054\u0068\u0065\u0020\u0064\u0061t\u0061\u0020s\u0068\u006fu\u006c\u0064\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0020\u0061\u0074 l\u0065\u0061\u0073\u0074\u003a\u0020\u0027\u0025\u0064'\u0020\u0062\u0079\u0074\u0065\u0073",len (_fgbc .Data ),_efgb );
};_bebc :=_fgbc .Width %8;if _bebc ==0{return nil ;};_gfcc :=_fgbc .Width /8;_ebadb :=_bg .NewReader (_fgbc .Data );_ead :=make ([]byte ,_fgbc .Height *_fgbc .BytesPerLine );_abcf :=_bg .NewWriterMSB (_ead );_cgf :=make ([]byte ,_gfcc );var (_ffeaf int ;
_cga uint64 ;);for _ffeaf =0;_ffeaf < _fgbc .Height ;_ffeaf ++{if _ ,_gde =_ebadb .Read (_cgf );_gde !=nil {return _gde ;};if _ ,_gde =_abcf .Write (_cgf );_gde !=nil {return _gde ;};if _cga ,_gde =_ebadb .ReadBits (byte (_bebc ));_gde !=nil {return _gde ;
};if _gde =_abcf .WriteByte (byte (_cga )<<uint (8-_bebc ));_gde !=nil {return _gde ;};};_fgbc .Data =_abcf .Data ();return nil ;};func _fggf (_ebc Gray ,_bad CMYK ,_age _f .Rectangle ){for _fgef :=0;_fgef < _age .Max .X ;_fgef ++{for _bge :=0;_bge < _age .Max .Y ;
_bge ++{_bbc :=_ebc .GrayAt (_fgef ,_bge );_bad .SetCMYK (_fgef ,_bge ,_bega (_bbc ));};};};func _eae ()(_deg [256]uint16 ){for _cec :=0;_cec < 256;_cec ++{if _cec &0x01!=0{_deg [_cec ]|=0x3;};if _cec &0x02!=0{_deg [_cec ]|=0xc;};if _cec &0x04!=0{_deg [_cec ]|=0x30;
};if _cec &0x08!=0{_deg [_cec ]|=0xc0;};if _cec &0x10!=0{_deg [_cec ]|=0x300;};if _cec &0x20!=0{_deg [_cec ]|=0xc00;};if _cec &0x40!=0{_deg [_cec ]|=0x3000;};if _cec &0x80!=0{_deg [_cec ]|=0xc000;};};return _deg ;};var ErrInvalidImage =_b .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
const (_adbc shift =iota ;_cced ;);func (_cfbb *Gray4 )setGray (_egag int ,_bdfd int ,_ede _c .Gray ){_dgeg :=_bdfd *_cfbb .BytesPerLine ;_deab :=_dgeg +(_egag >>1);if _deab >=len (_cfbb .Data ){return ;};_gfab :=_ede .Y >>4;_cfbb .Data [_deab ]=(_cfbb .Data [_deab ]&(^(0xf0>>uint (4*(_egag &1)))))|(_gfab <<uint (4-4*(_egag &1)));
};func (_bgfc *CMYK32 )Set (x ,y int ,c _c .Color ){_cgbb :=4*(y *_bgfc .Width +x );if _cgbb +3>=len (_bgfc .Data ){return ;};_gca :=_c .CMYKModel .Convert (c ).(_c .CMYK );_bgfc .Data [_cgbb ]=_gca .C ;_bgfc .Data [_cgbb +1]=_gca .M ;_bgfc .Data [_cgbb +2]=_gca .Y ;
_bgfc .Data [_cgbb +3]=_gca .K ;};type Monochrome struct{ImageBase ;ModelThreshold uint8 ;};var _ Image =&Monochrome {};type CMYK32 struct{ImageBase };var _ Gray =&Gray2 {};func (_edcd *Gray2 )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtGray2BPC (x ,y ,_edcd .BytesPerLine ,_edcd .Data ,_edcd .Decode );
};type Gray8 struct{ImageBase };func (_ccdc *Gray4 )Bounds ()_f .Rectangle {return _f .Rectangle {Max :_f .Point {X :_ccdc .Width ,Y :_ccdc .Height }};};var _ Gray =&Gray4 {};func (_ffdee *Gray8 )At (x ,y int )_c .Color {_def ,_ :=_ffdee .ColorAt (x ,y );
return _def };func (_ccgg *NRGBA32 )Validate ()error {if len (_ccgg .Data )!=3*_ccgg .Width *_ccgg .Height {return _b .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func (_efff *NRGBA32 )setRGBA (_gaffg int ,_dcac _c .NRGBA ){_egbce :=3*_gaffg ;_efff .Data [_egbce ]=_dcac .R ;_efff .Data [_egbce +1]=_dcac .G ;_efff .Data [_egbce +2]=_dcac .B ;if _gaffg < len (_efff .Alpha ){_efff .Alpha [_gaffg ]=_dcac .A ;
};};func _dffac (_gcag *Monochrome ,_badg ,_gbef ,_egfa ,_gge int ,_bbde RasterOperator ,_gdeb *Monochrome ,_cbac ,_gdc int )error {if _gcag ==nil {return _b .New ("\u006e\u0069\u006c\u0020\u0027\u0064\u0065\u0073\u0074\u0027\u0020\u0042i\u0074\u006d\u0061\u0070");
};if _bbde ==PixDst {return nil ;};switch _bbde {case PixClr ,PixSet ,PixNotDst :_fggg (_gcag ,_badg ,_gbef ,_egfa ,_gge ,_bbde );return nil ;};if _gdeb ==nil {_ca .Log .Debug ("\u0052a\u0073\u0074e\u0072\u004f\u0070\u0065r\u0061\u0074\u0069o\u006e\u0020\u0073\u006f\u0075\u0072\u0063\u0065\u0020bi\u0074\u006d\u0061p\u0020\u0069s\u0020\u006e\u006f\u0074\u0020\u0064e\u0066\u0069n\u0065\u0064");
return _b .New ("\u006e\u0069l\u0020\u0027\u0073r\u0063\u0027\u0020\u0062\u0069\u0074\u006d\u0061\u0070");};if _defd :=_fedc (_gcag ,_badg ,_gbef ,_egfa ,_gge ,_bbde ,_gdeb ,_cbac ,_gdc );_defd !=nil {return _defd ;};return nil ;};func (_begb *ImageBase )copy ()ImageBase {_agcf :=*_begb ;
_agcf .Data =make ([]byte ,len (_begb .Data ));copy (_agcf .Data ,_begb .Data );return _agcf ;};func (_afe *Gray8 )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtGray8BPC (x ,y ,_afe .BytesPerLine ,_afe .Data ,_afe .Decode );};type Gray2 struct{ImageBase };
func ConverterFunc (converterFunc func (_bgee _f .Image )(Image ,error ))ColorConverter {return colorConverter {_ebad :converterFunc };};func (_bfee *Gray4 )Set (x ,y int ,c _c .Color ){if x >=_bfee .Width ||y >=_bfee .Height {return ;};_egfg :=Gray4Model .Convert (c ).(_c .Gray );
_bfee .setGray (x ,y ,_egfg );};func (_fab *Gray8 )Validate ()error {if len (_fab .Data )!=_fab .Height *_fab .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_fga *Monochrome )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtGray1BPC (x ,y ,_fga .BytesPerLine ,_fga .Data ,_fga .Decode );
};func ColorAtNRGBA16 (x ,y ,width ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_c .NRGBA ,error ){_dbfd :=y *bytesPerLine +x *3/2;if _dbfd +1>=len (data ){return _c .NRGBA {},_feee (x ,y );};const (_cfd =0xf;_bgcbg =uint8 (0xff););_gafe :=_bgcbg ;
if alpha !=nil {_ggacg :=y *BytesPerLine (width ,4,1);if _ggacg < len (alpha ){if x %2==0{_gafe =(alpha [_ggacg ]>>uint (4))&_cfd ;}else {_gafe =alpha [_ggacg ]&_cfd ;};_gafe |=_gafe <<4;};};var _aggc ,_aeag ,_fcgb uint8 ;if x *3%2==0{_aggc =(data [_dbfd ]>>uint (4))&_cfd ;
_aeag =data [_dbfd ]&_cfd ;_fcgb =(data [_dbfd +1]>>uint (4))&_cfd ;}else {_aggc =data [_dbfd ]&_cfd ;_aeag =(data [_dbfd +1]>>uint (4))&_cfd ;_fcgb =data [_dbfd +1]&_cfd ;};if len (decode )==6{_aggc =uint8 (uint32 (LinearInterpolate (float64 (_aggc ),0,15,decode [0],decode [1]))&0xf);
_aeag =uint8 (uint32 (LinearInterpolate (float64 (_aeag ),0,15,decode [2],decode [3]))&0xf);_fcgb =uint8 (uint32 (LinearInterpolate (float64 (_fcgb ),0,15,decode [4],decode [5]))&0xf);};return _c .NRGBA {R :(_aggc <<4)|(_aggc &0xf),G :(_aeag <<4)|(_aeag &0xf),B :(_fcgb <<4)|(_fcgb &0xf),A :_gafe },nil ;
};func (_ggcf *Gray2 )SetGray (x ,y int ,gray _c .Gray ){_fdgbd :=_cbae (gray );_bdc :=y *_ggcf .BytesPerLine ;_fefa :=_bdc +(x >>2);if _fefa >=len (_ggcf .Data ){return ;};_ccbe :=_fdgbd .Y >>6;_ggcf .Data [_fefa ]=(_ggcf .Data [_fefa ]&(^(0xc0>>uint (2*((x )&3)))))|(_ccbe <<uint (6-2*(x &3)));
};func (_cegd *ImageBase )GetAlpha ()[]byte {return _cegd .Alpha };var _ Image =&Gray8 {};func (_dbbb *Gray8 )Base ()*ImageBase {return &_dbbb .ImageBase };func (_fba colorConverter )Convert (src _f .Image )(Image ,error ){return _fba ._ebad (src )};func (_adbef *NRGBA64 )Validate ()error {if len (_adbef .Data )!=3*2*_adbef .Width *_adbef .Height {return _b .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func (_cag *Monochrome )InverseData ()error {return _cag .RasterOperation (0,0,_cag .Width ,_cag .Height ,PixNotDst ,nil ,0,0);};func (_fda *Monochrome )setGray (_fdfd int ,_gccaf _c .Gray ,_fegg int ){if _gccaf .Y ==0{_fda .clearBit (_fegg ,_fdfd );
}else {_fda .setGrayBit (_fegg ,_fdfd );};};func (_bbgf *Monochrome )copy ()*Monochrome {_ccdd :=_deb (_bbgf .Width ,_bbgf .Height );_ccdd .ModelThreshold =_bbgf .ModelThreshold ;_ccdd .Data =make ([]byte ,len (_bbgf .Data ));copy (_ccdd .Data ,_bbgf .Data );
if len (_bbgf .Decode )!=0{_ccdd .Decode =make ([]float64 ,len (_bbgf .Decode ));copy (_ccdd .Decode ,_bbgf .Decode );};if len (_bbgf .Alpha )!=0{_ccdd .Alpha =make ([]byte ,len (_bbgf .Alpha ));copy (_ccdd .Alpha ,_bbgf .Alpha );};return _ccdd ;};func (_acaad *NRGBA64 )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtNRGBA64 (x ,y ,_acaad .Width ,_acaad .Data ,_acaad .Alpha ,_acaad .Decode );
};func (_ddbd *Gray2 )Validate ()error {if len (_ddbd .Data )!=_ddbd .Height *_ddbd .BytesPerLine {return ErrInvalidImage ;};return nil ;};var (_gfb =_eae ();_cba =_ac ();_afbc =_agcd (););func _fage (_egaa _f .Image )(Image ,error ){if _egb ,_gfgea :=_egaa .(*Gray16 );
_gfgea {return _egb .Copy (),nil ;};_aebb :=_egaa .Bounds ();_eaeb ,_gad :=NewImage (_aebb .Max .X ,_aebb .Max .Y ,16,1,nil ,nil ,nil );if _gad !=nil {return nil ,_gad ;};_abg (_egaa ,_eaeb ,_aebb );return _eaeb ,nil ;};func (_adee *Gray4 )Copy ()Image {return &Gray4 {ImageBase :_adee .copy ()}};
var _ Image =&Gray16 {};func (_cdc *Monochrome )SetGray (x ,y int ,g _c .Gray ){_dddb :=y *_cdc .BytesPerLine +x >>3;if _dddb > len (_cdc .Data )-1{return ;};g =_ecfdb (g ,monochromeModel (_cdc .ModelThreshold ));_cdc .setGray (x ,g ,_dddb );};func _fgb (_gag ,_fcb *Monochrome ,_beg []byte ,_eee int )(_dfg error ){var (_aadg ,_fad ,_aea ,_ddf ,_eef ,_aee ,_beab ,_bfgd int ;
_beae ,_acg uint32 ;_gfa ,_bfb byte ;_fgga uint16 ;);_dbd :=make ([]byte ,4);_fgbb :=make ([]byte ,4);for _aea =0;_aea < _gag .Height -1;_aea ,_ddf =_aea +2,_ddf +1{_aadg =_aea *_gag .BytesPerLine ;_fad =_ddf *_fcb .BytesPerLine ;for _eef ,_aee =0,0;_eef < _eee ;
_eef ,_aee =_eef +4,_aee +1{for _beab =0;_beab < 4;_beab ++{_bfgd =_aadg +_eef +_beab ;if _bfgd <=len (_gag .Data )-1&&_bfgd < _aadg +_gag .BytesPerLine {_dbd [_beab ]=_gag .Data [_bfgd ];}else {_dbd [_beab ]=0x00;};_bfgd =_aadg +_gag .BytesPerLine +_eef +_beab ;
if _bfgd <=len (_gag .Data )-1&&_bfgd < _aadg +(2*_gag .BytesPerLine ){_fgbb [_beab ]=_gag .Data [_bfgd ];}else {_fgbb [_beab ]=0x00;};};_beae =_g .BigEndian .Uint32 (_dbd );_acg =_g .BigEndian .Uint32 (_fgbb );_acg |=_beae ;_acg |=_acg <<1;_acg &=0xaaaaaaaa;
_beae =_acg |(_acg <<7);_gfa =byte (_beae >>24);_bfb =byte ((_beae >>8)&0xff);_bfgd =_fad +_aee ;if _bfgd +1==len (_fcb .Data )-1||_bfgd +1>=_fad +_fcb .BytesPerLine {_fcb .Data [_bfgd ]=_beg [_gfa ];}else {_fgga =(uint16 (_beg [_gfa ])<<8)|uint16 (_beg [_bfb ]);
if _dfg =_fcb .setTwoBytes (_bfgd ,_fgga );_dfg !=nil {return _db .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_bfgd );
};_aee ++;};};};return nil ;};func (_eebc *NRGBA16 )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtNRGBA16 (x ,y ,_eebc .Width ,_eebc .BytesPerLine ,_eebc .Data ,_eebc .Alpha ,_eebc .Decode );};func _eaee (_bbbca *_f .Gray ,_acbc uint8 )*_f .Gray {_edbd :=_bbbca .Bounds ();
_edfb :=_f .NewGray (_edbd );for _gfaf :=0;_gfaf < _edbd .Dx ();_gfaf ++{for _acabe :=0;_acabe < _edbd .Dy ();_acabe ++{_caca :=_bbbca .GrayAt (_gfaf ,_acabe );_edfb .SetGray (_gfaf ,_acabe ,_c .Gray {Y :_cbec (_caca .Y ,_acbc )});};};return _edfb ;};func _agcd ()(_ddc [256]uint64 ){for _gaf :=0;
_gaf < 256;_gaf ++{if _gaf &0x01!=0{_ddc [_gaf ]|=0xff;};if _gaf &0x02!=0{_ddc [_gaf ]|=0xff00;};if _gaf &0x04!=0{_ddc [_gaf ]|=0xff0000;};if _gaf &0x08!=0{_ddc [_gaf ]|=0xff000000;};if _gaf &0x10!=0{_ddc [_gaf ]|=0xff00000000;};if _gaf &0x20!=0{_ddc [_gaf ]|=0xff0000000000;
};if _gaf &0x40!=0{_ddc [_gaf ]|=0xff000000000000;};if _gaf &0x80!=0{_ddc [_gaf ]|=0xff00000000000000;};};return _ddc ;};func _bfa (_ga ,_cda *Monochrome )(_cc error ){_gg :=_cda .BytesPerLine ;_ea :=_ga .BytesPerLine ;_cgg :=_cda .BytesPerLine *4-_ga .BytesPerLine ;
var (_ae ,_gf byte ;_bfaa uint32 ;_caeg ,_gc ,_ddb ,_bbg ,_gcf ,_ebe ,_fg int ;);for _ddb =0;_ddb < _cda .Height ;_ddb ++{_caeg =_ddb *_gg ;_gc =4*_ddb *_ea ;for _bbg =0;_bbg < _gg ;_bbg ++{_ae =_cda .Data [_caeg +_bbg ];_bfaa =_cba [_ae ];_ebe =_gc +_bbg *4;
if _cgg !=0&&(_bbg +1)*4> _ga .BytesPerLine {for _gcf =_cgg ;_gcf > 0;_gcf --{_gf =byte ((_bfaa >>uint (_gcf *8))&0xff);_fg =_ebe +(_cgg -_gcf );if _cc =_ga .setByte (_fg ,_gf );_cc !=nil {return _cc ;};};}else if _cc =_ga .setFourBytes (_ebe ,_bfaa );
_cc !=nil {return _cc ;};if _cc =_ga .setFourBytes (_gc +_bbg *4,_cba [_cda .Data [_caeg +_bbg ]]);_cc !=nil {return _cc ;};};for _gcf =1;_gcf < 4;_gcf ++{for _bbg =0;_bbg < _ea ;_bbg ++{if _cc =_ga .setByte (_gc +_gcf *_ea +_bbg ,_ga .Data [_gc +_bbg ]);
_cc !=nil {return _cc ;};};};};return nil ;};func (_bcga *NRGBA32 )At (x ,y int )_c .Color {_fcdeeg ,_ :=_bcga .ColorAt (x ,y );return _fcdeeg };var _ _f .Image =&NRGBA32 {};func (_dedfa *Gray2 )Set (x ,y int ,c _c .Color ){if x >=_dedfa .Width ||y >=_dedfa .Height {return ;
};_efd :=Gray2Model .Convert (c ).(_c .Gray );_dgbc :=y *_dedfa .BytesPerLine ;_addd :=_dgbc +(x >>2);_edfg :=_efd .Y >>6;_dedfa .Data [_addd ]=(_dedfa .Data [_addd ]&(^(0xc0>>uint (2*((x )&3)))))|(_edfg <<uint (6-2*(x &3)));};const (PixSrc RasterOperator =0xc;
PixDst RasterOperator =0xa;PixNotSrc RasterOperator =0x3;PixNotDst RasterOperator =0x5;PixClr RasterOperator =0x0;PixSet RasterOperator =0xf;PixSrcOrDst RasterOperator =0xe;PixSrcAndDst RasterOperator =0x8;PixSrcXorDst RasterOperator =0x6;PixNotSrcOrDst RasterOperator =0xb;
PixNotSrcAndDst RasterOperator =0x2;PixSrcOrNotDst RasterOperator =0xd;PixSrcAndNotDst RasterOperator =0x4;PixNotPixSrcOrDst RasterOperator =0x1;PixNotPixSrcAndDst RasterOperator =0x7;PixNotPixSrcXorDst RasterOperator =0x9;PixPaint =PixSrcOrDst ;PixSubtract =PixNotSrcAndDst ;
PixMask =PixSrcAndDst ;);func ColorAtCMYK (x ,y ,width int ,data []byte ,decode []float64 )(_c .CMYK ,error ){_ddg :=4*(y *width +x );if _ddg +3>=len (data ){return _c .CMYK {},_db .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};C :=data [_ddg ]&0xff;M :=data [_ddg +1]&0xff;Y :=data [_ddg +2]&0xff;K :=data [_ddg +3]&0xff;if len (decode )==8{C =uint8 (uint32 (LinearInterpolate (float64 (C ),0,255,decode [0],decode [1]))&0xff);M =uint8 (uint32 (LinearInterpolate (float64 (M ),0,255,decode [2],decode [3]))&0xff);
Y =uint8 (uint32 (LinearInterpolate (float64 (Y ),0,255,decode [4],decode [5]))&0xff);K =uint8 (uint32 (LinearInterpolate (float64 (K ),0,255,decode [6],decode [7]))&0xff);};return _c .CMYK {C :C ,M :M ,Y :Y ,K :K },nil ;};func _aed (){for _bggg :=0;_bggg < 256;
_bggg ++{_cdd [_bggg ]=uint8 (_bggg &0x1)+(uint8 (_bggg >>1)&0x1)+(uint8 (_bggg >>2)&0x1)+(uint8 (_bggg >>3)&0x1)+(uint8 (_bggg >>4)&0x1)+(uint8 (_bggg >>5)&0x1)+(uint8 (_bggg >>6)&0x1)+(uint8 (_bggg >>7)&0x1);};};func (_daca *NRGBA16 )Validate ()error {if len (_daca .Data )!=3*_daca .Width *_daca .Height /2{return _b .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func AutoThresholdTriangle (histogram [256]int )uint8 {var _acdf ,_ffge ,_bfeaa ,_bccca int ;for _fbbg :=0;_fbbg < len (histogram );_fbbg ++{if histogram [_fbbg ]> 0{_acdf =_fbbg ;break ;};};if _acdf > 0{_acdf --;};for _abde :=255;_abde > 0;
_abde --{if histogram [_abde ]> 0{_bccca =_abde ;break ;};};if _bccca < 255{_bccca ++;};for _ecee :=0;_ecee < 256;_ecee ++{if histogram [_ecee ]> _ffge {_bfeaa =_ecee ;_ffge =histogram [_ecee ];};};var _facf bool ;if (_bfeaa -_acdf )< (_bccca -_bfeaa ){_facf =true ;
var _fbgd int ;_abdb :=255;for _fbgd < _abdb {_egagd :=histogram [_fbgd ];histogram [_fbgd ]=histogram [_abdb ];histogram [_abdb ]=_egagd ;_fbgd ++;_abdb --;};_acdf =255-_bccca ;_bfeaa =255-_bfeaa ;};if _acdf ==_bfeaa {return uint8 (_acdf );};_abcd :=float64 (histogram [_bfeaa ]);
_dgfd :=float64 (_acdf -_bfeaa );_fbfa :=_de .Sqrt (_abcd *_abcd +_dgfd *_dgfd );_abcd /=_fbfa ;_dgfd /=_fbfa ;_fbfa =_abcd *float64 (_acdf )+_dgfd *float64 (histogram [_acdf ]);_caaa :=_acdf ;var _effff float64 ;for _cdcb :=_acdf +1;_cdcb <=_bfeaa ;_cdcb ++{_feb :=_abcd *float64 (_cdcb )+_dgfd *float64 (histogram [_cdcb ])-_fbfa ;
if _feb > _effff {_caaa =_cdcb ;_effff =_feb ;};};_caaa --;if _facf {var _ebdb int ;_fdcab :=255;for _ebdb < _fdcab {_caag :=histogram [_ebdb ];histogram [_ebdb ]=histogram [_fdcab ];histogram [_fdcab ]=_caag ;_ebdb ++;_fdcab --;};return uint8 (255-_caaa );
};return uint8 (_caaa );};func (_ggc *Monochrome )GrayAt (x ,y int )_c .Gray {_gcca ,_ :=ColorAtGray1BPC (x ,y ,_ggc .BytesPerLine ,_ggc .Data ,_ggc .Decode );return _gcca ;};func _aab (_dab _c .NRGBA )_c .Gray {var _gfcg _c .NRGBA ;if _dab ==_gfcg {return _c .Gray {Y :0xff};
};_dfc ,_gdd ,_cab ,_ :=_dab .RGBA ();_ggd :=(19595*_dfc +38470*_gdd +7471*_cab +1<<15)>>24;return _c .Gray {Y :uint8 (_ggd )};};type NRGBA16 struct{ImageBase };func _beag (_fedb *Monochrome ,_cbba ,_cafg int ,_gfga ,_fadgd int ,_ggfg RasterOperator ){var (_abda bool ;
_abba bool ;_dffb int ;_cedd int ;_eacf int ;_ecga int ;_acgf bool ;_abgd byte ;);_eddf :=8-(_cbba &7);_bcdc :=_ccde [_eddf ];_gfbc :=_fedb .BytesPerLine *_cafg +(_cbba >>3);if _gfga < _eddf {_abda =true ;_bcdc &=_ffeae [8-_eddf +_gfga ];};if !_abda {_dffb =(_gfga -_eddf )>>3;
if _dffb !=0{_abba =true ;_cedd =_gfbc +1;};};_eacf =(_cbba +_gfga )&7;if !(_abda ||_eacf ==0){_acgf =true ;_abgd =_ffeae [_eacf ];_ecga =_gfbc +1+_dffb ;};var _aefc ,_gcga int ;switch _ggfg {case PixClr :for _aefc =0;_aefc < _fadgd ;_aefc ++{_fedb .Data [_gfbc ]=_cdcf (_fedb .Data [_gfbc ],0x0,_bcdc );
_gfbc +=_fedb .BytesPerLine ;};if _abba {for _aefc =0;_aefc < _fadgd ;_aefc ++{for _gcga =0;_gcga < _dffb ;_gcga ++{_fedb .Data [_cedd +_gcga ]=0x0;};_cedd +=_fedb .BytesPerLine ;};};if _acgf {for _aefc =0;_aefc < _fadgd ;_aefc ++{_fedb .Data [_ecga ]=_cdcf (_fedb .Data [_ecga ],0x0,_abgd );
_ecga +=_fedb .BytesPerLine ;};};case PixSet :for _aefc =0;_aefc < _fadgd ;_aefc ++{_fedb .Data [_gfbc ]=_cdcf (_fedb .Data [_gfbc ],0xff,_bcdc );_gfbc +=_fedb .BytesPerLine ;};if _abba {for _aefc =0;_aefc < _fadgd ;_aefc ++{for _gcga =0;_gcga < _dffb ;
_gcga ++{_fedb .Data [_cedd +_gcga ]=0xff;};_cedd +=_fedb .BytesPerLine ;};};if _acgf {for _aefc =0;_aefc < _fadgd ;_aefc ++{_fedb .Data [_ecga ]=_cdcf (_fedb .Data [_ecga ],0xff,_abgd );_ecga +=_fedb .BytesPerLine ;};};case PixNotDst :for _aefc =0;_aefc < _fadgd ;
_aefc ++{_fedb .Data [_gfbc ]=_cdcf (_fedb .Data [_gfbc ],^_fedb .Data [_gfbc ],_bcdc );_gfbc +=_fedb .BytesPerLine ;};if _abba {for _aefc =0;_aefc < _fadgd ;_aefc ++{for _gcga =0;_gcga < _dffb ;_gcga ++{_fedb .Data [_cedd +_gcga ]=^(_fedb .Data [_cedd +_gcga ]);
};_cedd +=_fedb .BytesPerLine ;};};if _acgf {for _aefc =0;_aefc < _fadgd ;_aefc ++{_fedb .Data [_ecga ]=_cdcf (_fedb .Data [_ecga ],^_fedb .Data [_ecga ],_abgd );_ecga +=_fedb .BytesPerLine ;};};};};func FromGoImage (i _f .Image )(Image ,error ){switch _afce :=i .(type ){case Image :return _afce .Copy (),nil ;
case Gray :return GrayConverter .Convert (i );case *_f .Gray16 :return Gray16Converter .Convert (i );case CMYK :return CMYKConverter .Convert (i );case *_f .NRGBA64 :return NRGBA64Converter .Convert (i );default:return NRGBAConverter .Convert (i );};};
func (_ggdb *Gray16 )GrayAt (x ,y int )_c .Gray {_ffb ,_ :=_ggdb .ColorAt (x ,y );return _c .Gray {Y :uint8 (_ffb .(_c .Gray16 ).Y >>8)};};func _bddc (_cdbf _f .Image ,_cgbae int )(_f .Rectangle ,bool ,[]byte ){_gbfb :=_cdbf .Bounds ();var (_gegg bool ;
_ggba []byte ;);switch _bdec :=_cdbf .(type ){case SMasker :_gegg =_bdec .HasAlpha ();case NRGBA ,RGBA ,*_f .RGBA64 ,nrgba64 ,*_f .NYCbCrA :_ggba =make ([]byte ,_gbfb .Max .X *_gbfb .Max .Y *_cgbae );case *_f .Paletted :var _dccg bool ;for _ ,_gade :=range _bdec .Palette {_gace ,_bbcda ,_cage ,_edfcg :=_gade .RGBA ();
if _gace ==0&&_bbcda ==0&&_cage ==0&&_edfcg !=0{_dccg =true ;break ;};};if _dccg {_ggba =make ([]byte ,_gbfb .Max .X *_gbfb .Max .Y *_cgbae );};};return _gbfb ,_gegg ,_ggba ;};func _fe (_edd *Monochrome ,_gb int )(*Monochrome ,error ){if _edd ==nil {return nil ,_b .New ("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064");
};if _gb ==1{return _edd .copy (),nil ;};if !IsPowerOf2 (uint (_gb )){return nil ,_db .Errorf ("\u0070\u0072\u006fvi\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006ci\u0064 \u0065x\u0070a\u006e\u0064\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_gb );
};_da :=_gfbg (_gb );return _cac (_edd ,_gb ,_da );};func (_gdgc *Gray16 )Validate ()error {if len (_gdgc .Data )!=_gdgc .Height *_gdgc .BytesPerLine {return ErrInvalidImage ;};return nil ;};func ColorAtGray4BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_c .Gray ,error ){_bcec :=y *bytesPerLine +x >>1;
if _bcec >=len (data ){return _c .Gray {},_db .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_ebcg :=data [_bcec ]>>uint (4-(x &1)*4)&0xf;if len (decode )==2{_ebcg =uint8 (uint32 (LinearInterpolate (float64 (_ebcg ),0,15,decode [0],decode [1]))&0xf);};return _c .Gray {Y :_ebcg *17&0xff},nil ;};func (_adad *Gray16 )At (x ,y int )_c .Color {_aaaa ,_ :=_adad .ColorAt (x ,y );
return _aaaa };func IsPowerOf2 (n uint )bool {return n > 0&&(n &(n -1))==0};func (_gagcb *Monochrome )ColorModel ()_c .Model {return MonochromeModel (_gagcb .ModelThreshold )};func (_ebf *NRGBA16 )setNRGBA (_fdca ,_dffd ,_decb int ,_gaeb _c .NRGBA ){if _fdca *3%2==0{_ebf .Data [_decb ]=(_gaeb .R >>4)<<4|(_gaeb .G >>4);
_ebf .Data [_decb +1]=(_gaeb .B >>4)<<4|(_ebf .Data [_decb +1]&0xf);}else {_ebf .Data [_decb ]=(_ebf .Data [_decb ]&0xf0)|(_gaeb .R >>4);_ebf .Data [_decb +1]=(_gaeb .G >>4)<<4|(_gaeb .B >>4);};if _ebf .Alpha !=nil {_ccea :=_dffd *BytesPerLine (_ebf .Width ,4,1);
if _ccea < len (_ebf .Alpha ){if _fdca %2==0{_ebf .Alpha [_ccea ]=(_gaeb .A >>uint (4))<<uint (4)|(_ebf .Alpha [_decb ]&0xf);}else {_ebf .Alpha [_ccea ]=(_ebf .Alpha [_ccea ]&0xf0)|(_gaeb .A >>uint (4));};};};};func (_fca *Monochrome )setGrayBit (_cfbc ,_fefc int ){_fca .Data [_cfbc ]|=0x80>>uint (_fefc &7)};
func (_bbcf *Gray4 )GrayAt (x ,y int )_c .Gray {_gece ,_ :=ColorAtGray4BPC (x ,y ,_bbcf .BytesPerLine ,_bbcf .Data ,_bbcf .Decode );return _gece ;};var (Gray2Model =_c .ModelFunc (_babb );Gray4Model =_c .ModelFunc (_eadc );NRGBA16Model =_c .ModelFunc (_aeeb );
);func _ce (_be *Monochrome ,_fec ,_ff int )(*Monochrome ,error ){if _be ==nil {return nil ,_b .New ("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064");};if _fec <=0||_ff <=0{return nil ,_b .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0073\u0063\u0061l\u0065\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020<\u003d\u0020\u0030");
};if _fec ==_ff {if _fec ==1{return _be .copy (),nil ;};if _fec ==2||_fec ==4||_fec ==8{_dfe ,_fc :=_fe (_be ,_fec );if _fc !=nil {return nil ,_fc ;};return _dfe ,nil ;};};_cad :=_fec *_be .Width ;_fdc :=_ff *_be .Height ;_aad :=_deb (_cad ,_fdc );_eaf :=_aad .BytesPerLine ;
var (_ba ,_ee ,_cdag ,_agc ,_eeb int ;_ffa byte ;_dge error ;);for _ee =0;_ee < _be .Height ;_ee ++{_ba =_ff *_ee *_eaf ;for _cdag =0;_cdag < _be .Width ;_cdag ++{if _gee :=_be .getBitAt (_cdag ,_ee );_gee {_eeb =_fec *_cdag ;for _agc =0;_agc < _fec ;_agc ++{_aad .setIndexedBit (_ba *8+_eeb +_agc );
};};};for _agc =1;_agc < _ff ;_agc ++{_fce :=_ba +_agc *_eaf ;for _bgf :=0;_bgf < _eaf ;_bgf ++{if _ffa ,_dge =_aad .getByte (_ba +_bgf );_dge !=nil {return nil ,_dge ;};if _dge =_aad .setByte (_fce +_bgf ,_ffa );_dge !=nil {return nil ,_dge ;};};};};return _aad ,nil ;
};type SMasker interface{HasAlpha ()bool ;GetAlpha ()[]byte ;MakeAlpha ();};func _bfd (_bee *Monochrome ,_cgge ...int )(_ecb *Monochrome ,_ab error ){if _bee ==nil {return nil ,_b .New ("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d");
};if len (_cgge )==0{return nil ,_b .New ("\u0074h\u0065\u0072e\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0061\u0074 \u006c\u0065\u0061\u0073\u0074\u0020o\u006e\u0065\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u006f\u0066 \u0072\u0065\u0064\u0075\u0063\u0074\u0069\u006f\u006e");
};_gae :=_dff ();_ecb =_bee ;for _ ,_fgg :=range _cgge {if _fgg <=0{break ;};_ecb ,_ab =_eba (_ecb ,_fgg ,_gae );if _ab !=nil {return nil ,_ab ;};};return _ecb ,nil ;};func _eeff (_acgad ,_fecfe Gray ,_fffb _f .Rectangle ){for _cfbcg :=0;_cfbcg < _fffb .Max .X ;
_cfbcg ++{for _deeg :=0;_deeg < _fffb .Max .Y ;_deeg ++{_fecfe .SetGray (_cfbcg ,_deeg ,_acgad .GrayAt (_cfbcg ,_deeg ));};};};func NewImage (width ,height ,bitsPerComponent ,colorComponents int ,data ,alpha []byte ,decode []float64 )(Image ,error ){_fdba :=NewImageBase (width ,height ,bitsPerComponent ,colorComponents ,data ,alpha ,decode );
var _dbbd Image ;switch colorComponents {case 1:switch bitsPerComponent {case 1:_dbbd =&Monochrome {ImageBase :_fdba ,ModelThreshold :0x0f};case 2:_dbbd =&Gray2 {ImageBase :_fdba };case 4:_dbbd =&Gray4 {ImageBase :_fdba };case 8:_dbbd =&Gray8 {ImageBase :_fdba };
case 16:_dbbd =&Gray16 {ImageBase :_fdba };};case 3:switch bitsPerComponent {case 4:_dbbd =&NRGBA16 {ImageBase :_fdba };case 8:_dbbd =&NRGBA32 {ImageBase :_fdba };case 16:_dbbd =&NRGBA64 {ImageBase :_fdba };};case 4:_dbbd =&CMYK32 {ImageBase :_fdba };};
if _dbbd ==nil {return nil ,ErrInvalidImage ;};return _dbbd ,nil ;};func MonochromeModel (threshold uint8 )_c .Model {return monochromeModel (threshold )};func GrayHistogram (g Gray )(_gcfe [256]int ){switch _bfddd :=g .(type ){case Histogramer :return _bfddd .Histogram ();
case _f .Image :_deac :=_bfddd .Bounds ();for _gdgcf :=0;_gdgcf < _deac .Max .X ;_gdgcf ++{for _gfbgd :=0;_gfbgd < _deac .Max .Y ;_gfbgd ++{_gcfe [g .GrayAt (_gdgcf ,_gfbgd ).Y ]++;};};return _gcfe ;default:return [256]int {};};};var _ Image =&NRGBA16 {};
func (_cbed *NRGBA32 )Set (x ,y int ,c _c .Color ){_gabca :=y *_cbed .Width +x ;_ccdcg :=3*_gabca ;if _ccdcg +2>=len (_cbed .Data ){return ;};_bgdd :=_c .NRGBAModel .Convert (c ).(_c .NRGBA );_cbed .setRGBA (_gabca ,_bgdd );};func _abg (_fbff _f .Image ,_bbeb Image ,_cbee _f .Rectangle ){switch _dged :=_fbff .(type ){case Gray :_eeff (_dged ,_bbeb .(Gray ),_cbee );
case NRGBA :_ccbc (_dged ,_bbeb .(Gray ),_cbee );case CMYK :_egdgc (_dged ,_bbeb .(Gray ),_cbee );case RGBA :_cde (_dged ,_bbeb .(Gray ),_cbee );default:_dcbb (_fbff ,_bbeb .(Image ),_cbee );};};func (_egdc *Gray4 )ColorModel ()_c .Model {return Gray4Model };
func LinearInterpolate (x ,xmin ,xmax ,ymin ,ymax float64 )float64 {if _de .Abs (xmax -xmin )< 0.000001{return ymin ;};_dfdb :=ymin +(x -xmin )*(ymax -ymin )/(xmax -xmin );return _dfdb ;};func (_cfbba *Gray8 )Set (x ,y int ,c _c .Color ){_bba :=y *_cfbba .BytesPerLine +x ;
if _bba > len (_cfbba .Data )-1{return ;};_fgd :=_c .GrayModel .Convert (c );_cfbba .Data [_bba ]=_fgd .(_c .Gray ).Y ;};func (_fgfe *NRGBA16 )NRGBAAt (x ,y int )_c .NRGBA {_acgg ,_ :=ColorAtNRGBA16 (x ,y ,_fgfe .Width ,_fgfe .BytesPerLine ,_fgfe .Data ,_fgfe .Alpha ,_fgfe .Decode );
return _acgg ;};func (_bgb *NRGBA16 )Base ()*ImageBase {return &_bgb .ImageBase };func (_fggc *NRGBA32 )SetNRGBA (x ,y int ,c _c .NRGBA ){_edgg :=y *_fggc .Width +x ;_cdge :=3*_edgg ;if _cdge +2>=len (_fggc .Data ){return ;};_fggc .setRGBA (_edgg ,c );
};func _ecfdb (_bce _c .Gray ,_agbb monochromeModel )_c .Gray {if _bce .Y > uint8 (_agbb ){return _c .Gray {Y :_de .MaxUint8 };};return _c .Gray {};};func _ffbcf (_bfdd RGBA ,_bgec NRGBA ,_fcgaa _f .Rectangle ){for _gbced :=0;_gbced < _fcgaa .Max .X ;_gbced ++{for _ddcc :=0;
_ddcc < _fcgaa .Max .Y ;_ddcc ++{_aafb :=_bfdd .RGBAAt (_gbced ,_ddcc );_bgec .SetNRGBA (_gbced ,_ddcc ,_acf (_aafb ));};};};func InDelta (expected ,current ,delta float64 )bool {_ddfe :=expected -current ;if _ddfe <=-delta ||_ddfe >=delta {return false ;
};return true ;};var _cdd [256]uint8 ;func _edg (_dee RGBA ,_gegb CMYK ,_cfbad _f .Rectangle ){for _gcd :=0;_gcd < _cfbad .Max .X ;_gcd ++{for _ebb :=0;_ebb < _cfbad .Max .Y ;_ebb ++{_gac :=_dee .RGBAAt (_gcd ,_ebb );_gegb .SetCMYK (_gcd ,_ebb ,_ccb (_gac ));
};};};func (_efce *Gray16 )Set (x ,y int ,c _c .Color ){_gbgf :=(y *_efce .BytesPerLine /2+x )*2;if _gbgf +1>=len (_efce .Data ){return ;};_cade :=_c .Gray16Model .Convert (c ).(_c .Gray16 );_efce .Data [_gbgf ],_efce .Data [_gbgf +1]=uint8 (_cade .Y >>8),uint8 (_cade .Y &0xff);
};func (_gfgba *Gray16 )ColorModel ()_c .Model {return _c .Gray16Model };func _dfcg (_gfegb *_f .Gray )bool {for _gafg :=0;_gafg < len (_gfegb .Pix );_gafg ++{if !_bfda (_gfegb .Pix [_gafg ]){return false ;};};return true ;};var _ Image =&CMYK32 {};func (_bffg *NRGBA16 )Set (x ,y int ,c _c .Color ){_ccbee :=y *_bffg .BytesPerLine +x *3/2;
if _ccbee +1>=len (_bffg .Data ){return ;};_ffbc :=NRGBA16Model .Convert (c ).(_c .NRGBA );_bffg .setNRGBA (x ,y ,_ccbee ,_ffbc );};func (_gce *Monochrome )ScaleLow (width ,height int )(*Monochrome ,error ){if width < 0||height < 0{return nil ,_b .New ("\u0070\u0072\u006f\u0076\u0069\u0064e\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0069\u0064t\u0068\u0020\u0061\u006e\u0064\u0020\u0068e\u0069\u0067\u0068\u0074");
};_gcgc :=_deb (width ,height );_affe :=make ([]int ,height );_agce :=make ([]int ,width );_adb :=float64 (_gce .Width )/float64 (width );_gbf :=float64 (_gce .Height )/float64 (height );for _fdb :=0;_fdb < height ;_fdb ++{_affe [_fdb ]=int (_de .Min (_gbf *float64 (_fdb )+0.5,float64 (_gce .Height -1)));
};for _adaa :=0;_adaa < width ;_adaa ++{_agce [_adaa ]=int (_de .Min (_adb *float64 (_adaa )+0.5,float64 (_gce .Width -1)));};_cacf :=-1;_gbg :=byte (0);for _gfcf :=0;_gfcf < height ;_gfcf ++{_aaa :=_affe [_gfcf ]*_gce .BytesPerLine ;_dbgc :=_gfcf *_gcgc .BytesPerLine ;
for _dcgd :=0;_dcgd < width ;_dcgd ++{_geddf :=_agce [_dcgd ];if _geddf !=_cacf {_gbg =_gce .getBit (_aaa ,_geddf );if _gbg !=0{_gcgc .setBit (_dbgc ,_dcgd );};_cacf =_geddf ;}else {if _gbg !=0{_gcgc .setBit (_dbgc ,_dcgd );};};};};return _gcgc ,nil ;};
func _agb (_eace ,_cfba CMYK ,_bef _f .Rectangle ){for _fcbb :=0;_fcbb < _bef .Max .X ;_fcbb ++{for _bddg :=0;_bddg < _bef .Max .Y ;_bddg ++{_cfba .SetCMYK (_fcbb ,_bddg ,_eace .CMYKAt (_fcbb ,_bddg ));};};};func (_fdd *NRGBA64 )NRGBA64At (x ,y int )_c .NRGBA64 {_cedc ,_ :=ColorAtNRGBA64 (x ,y ,_fdd .Width ,_fdd .Data ,_fdd .Alpha ,_fdd .Decode );
return _cedc ;};func _egdgc (_gff CMYK ,_faa Gray ,_acgbd _f .Rectangle ){for _eega :=0;_eega < _acgbd .Max .X ;_eega ++{for _gcb :=0;_gcb < _acgbd .Max .Y ;_gcb ++{_agfb :=_egea (_gff .CMYKAt (_eega ,_gcb ));_faa .SetGray (_eega ,_gcb ,_agfb );};};};type Histogramer interface{Histogram ()[256]int ;
};func ImgToBinary (i _f .Image ,threshold uint8 )*_f .Gray {switch _egfbb :=i .(type ){case *_f .Gray :if _dfcg (_egfbb ){return _egfbb ;};return _eaee (_egfbb ,threshold );case *_f .Gray16 :return _cbbdc (_egfbb ,threshold );default:return _dbgaa (_egfbb ,threshold );
};};func ScaleAlphaToMonochrome (data []byte ,width ,height int )([]byte ,error ){_ed :=BytesPerLine (width ,8,1);if len (data )< _ed *height {return nil ,nil ;};_ge :=&Gray8 {NewImageBase (width ,height ,8,1,data ,nil ,nil )};_fa ,_fb :=MonochromeConverter .Convert (_ge );
if _fb !=nil {return nil ,_fb ;};return _fa .Base ().Data ,nil ;};func (_cace *Monochrome )getBitAt (_ddfdd ,_adfde int )bool {_caf :=_adfde *_cace .BytesPerLine +(_ddfdd >>3);_cdbg :=_ddfdd &0x07;_dceg :=uint (7-_cdbg );if _caf > len (_cace .Data )-1{return false ;
};if (_cace .Data [_caf ]>>_dceg )&0x01>=1{return true ;};return false ;};var _ Image =&Gray2 {};func (_acgbc *Gray4 )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtGray4BPC (x ,y ,_acgbc .BytesPerLine ,_acgbc .Data ,_acgbc .Decode );};func _dbgaa (_gega _f .Image ,_bfad uint8 )*_f .Gray {_afcf :=_gega .Bounds ();
_ccdb :=_f .NewGray (_afcf );var (_fcgg _c .Color ;_ggdbe _c .Gray ;);for _fbbdf :=0;_fbbdf < _afcf .Max .X ;_fbbdf ++{for _ggae :=0;_ggae < _afcf .Max .Y ;_ggae ++{_fcgg =_gega .At (_fbbdf ,_ggae );_ccdb .Set (_fbbdf ,_ggae ,_fcgg );_ggdbe =_ccdb .GrayAt (_fbbdf ,_ggae );
_ccdb .SetGray (_fbbdf ,_ggae ,_c .Gray {Y :_cbec (_ggdbe .Y ,_bfad )});};};return _ccdb ;};func _dcab (_efbc *Monochrome ,_cabf ,_fabg ,_ggaa ,_dcfd int ,_dfee RasterOperator ,_dfac *Monochrome ,_gba ,_dedd int )error {var (_bccc bool ;_bbf bool ;_fbc byte ;
_dedg int ;_fffd int ;_eca int ;_fgedge int ;_cggec bool ;_fcee int ;_dcba int ;_ffcf int ;_cdaa bool ;_fcdee byte ;_ebg int ;_acgbg int ;_adac int ;_bbcg byte ;_acd int ;_egbd int ;_beed uint ;_caa uint ;_beedc byte ;_fcfg shift ;_agff bool ;_gdgce bool ;
_fcfga ,_acgc int ;);if _gba &7!=0{_egbd =8-(_gba &7);};if _cabf &7!=0{_fffd =8-(_cabf &7);};if _egbd ==0&&_fffd ==0{_beedc =_ccde [0];}else {if _fffd > _egbd {_beed =uint (_fffd -_egbd );}else {_beed =uint (8-(_egbd -_fffd ));};_caa =8-_beed ;_beedc =_ccde [_beed ];
};if (_cabf &7)!=0{_bccc =true ;_dedg =8-(_cabf &7);_fbc =_ccde [_dedg ];_eca =_efbc .BytesPerLine *_fabg +(_cabf >>3);_fgedge =_dfac .BytesPerLine *_dedd +(_gba >>3);_acd =8-(_gba &7);if _dedg > _acd {_fcfg =_adbc ;if _ggaa >=_egbd {_agff =true ;};}else {_fcfg =_cced ;
};};if _ggaa < _dedg {_bbf =true ;_fbc &=_ffeae [8-_dedg +_ggaa ];};if !_bbf {_fcee =(_ggaa -_dedg )>>3;if _fcee !=0{_cggec =true ;_dcba =_efbc .BytesPerLine *_fabg +((_cabf +_fffd )>>3);_ffcf =_dfac .BytesPerLine *_dedd +((_gba +_fffd )>>3);};};_ebg =(_cabf +_ggaa )&7;
if !(_bbf ||_ebg ==0){_cdaa =true ;_fcdee =_ffeae [_ebg ];_acgbg =_efbc .BytesPerLine *_fabg +((_cabf +_fffd )>>3)+_fcee ;_adac =_dfac .BytesPerLine *_dedd +((_gba +_fffd )>>3)+_fcee ;if _ebg > int (_caa ){_gdgce =true ;};};switch _dfee {case PixSrc :if _bccc {for _fcfga =0;
_fcfga < _dcfd ;_fcfga ++{if _fcfg ==_adbc {_bbcg =_dfac .Data [_fgedge ]<<_beed ;if _agff {_bbcg =_cdcf (_bbcg ,_dfac .Data [_fgedge +1]>>_caa ,_beedc );};}else {_bbcg =_dfac .Data [_fgedge ]>>_caa ;};_efbc .Data [_eca ]=_cdcf (_efbc .Data [_eca ],_bbcg ,_fbc );
_eca +=_efbc .BytesPerLine ;_fgedge +=_dfac .BytesPerLine ;};};if _cggec {for _fcfga =0;_fcfga < _dcfd ;_fcfga ++{for _acgc =0;_acgc < _fcee ;_acgc ++{_bbcg =_cdcf (_dfac .Data [_ffcf +_acgc ]<<_beed ,_dfac .Data [_ffcf +_acgc +1]>>_caa ,_beedc );_efbc .Data [_dcba +_acgc ]=_bbcg ;
};_dcba +=_efbc .BytesPerLine ;_ffcf +=_dfac .BytesPerLine ;};};if _cdaa {for _fcfga =0;_fcfga < _dcfd ;_fcfga ++{_bbcg =_dfac .Data [_adac ]<<_beed ;if _gdgce {_bbcg =_cdcf (_bbcg ,_dfac .Data [_adac +1]>>_caa ,_beedc );};_efbc .Data [_acgbg ]=_cdcf (_efbc .Data [_acgbg ],_bbcg ,_fcdee );
_acgbg +=_efbc .BytesPerLine ;_adac +=_dfac .BytesPerLine ;};};case PixNotSrc :if _bccc {for _fcfga =0;_fcfga < _dcfd ;_fcfga ++{if _fcfg ==_adbc {_bbcg =_dfac .Data [_fgedge ]<<_beed ;if _agff {_bbcg =_cdcf (_bbcg ,_dfac .Data [_fgedge +1]>>_caa ,_beedc );
};}else {_bbcg =_dfac .Data [_fgedge ]>>_caa ;};_efbc .Data [_eca ]=_cdcf (_efbc .Data [_eca ],^_bbcg ,_fbc );_eca +=_efbc .BytesPerLine ;_fgedge +=_dfac .BytesPerLine ;};};if _cggec {for _fcfga =0;_fcfga < _dcfd ;_fcfga ++{for _acgc =0;_acgc < _fcee ;
_acgc ++{_bbcg =_cdcf (_dfac .Data [_ffcf +_acgc ]<<_beed ,_dfac .Data [_ffcf +_acgc +1]>>_caa ,_beedc );_efbc .Data [_dcba +_acgc ]=^_bbcg ;};_dcba +=_efbc .BytesPerLine ;_ffcf +=_dfac .BytesPerLine ;};};if _cdaa {for _fcfga =0;_fcfga < _dcfd ;_fcfga ++{_bbcg =_dfac .Data [_adac ]<<_beed ;
if _gdgce {_bbcg =_cdcf (_bbcg ,_dfac .Data [_adac +1]>>_caa ,_beedc );};_efbc .Data [_acgbg ]=_cdcf (_efbc .Data [_acgbg ],^_bbcg ,_fcdee );_acgbg +=_efbc .BytesPerLine ;_adac +=_dfac .BytesPerLine ;};};case PixSrcOrDst :if _bccc {for _fcfga =0;_fcfga < _dcfd ;
_fcfga ++{if _fcfg ==_adbc {_bbcg =_dfac .Data [_fgedge ]<<_beed ;if _agff {_bbcg =_cdcf (_bbcg ,_dfac .Data [_fgedge +1]>>_caa ,_beedc );};}else {_bbcg =_dfac .Data [_fgedge ]>>_caa ;};_efbc .Data [_eca ]=_cdcf (_efbc .Data [_eca ],_bbcg |_efbc .Data [_eca ],_fbc );
_eca +=_efbc .BytesPerLine ;_fgedge +=_dfac .BytesPerLine ;};};if _cggec {for _fcfga =0;_fcfga < _dcfd ;_fcfga ++{for _acgc =0;_acgc < _fcee ;_acgc ++{_bbcg =_cdcf (_dfac .Data [_ffcf +_acgc ]<<_beed ,_dfac .Data [_ffcf +_acgc +1]>>_caa ,_beedc );_efbc .Data [_dcba +_acgc ]|=_bbcg ;
};_dcba +=_efbc .BytesPerLine ;_ffcf +=_dfac .BytesPerLine ;};};if _cdaa {for _fcfga =0;_fcfga < _dcfd ;_fcfga ++{_bbcg =_dfac .Data [_adac ]<<_beed ;if _gdgce {_bbcg =_cdcf (_bbcg ,_dfac .Data [_adac +1]>>_caa ,_beedc );};_efbc .Data [_acgbg ]=_cdcf (_efbc .Data [_acgbg ],_bbcg |_efbc .Data [_acgbg ],_fcdee );
_acgbg +=_efbc .BytesPerLine ;_adac +=_dfac .BytesPerLine ;};};case PixSrcAndDst :if _bccc {for _fcfga =0;_fcfga < _dcfd ;_fcfga ++{if _fcfg ==_adbc {_bbcg =_dfac .Data [_fgedge ]<<_beed ;if _agff {_bbcg =_cdcf (_bbcg ,_dfac .Data [_fgedge +1]>>_caa ,_beedc );
};}else {_bbcg =_dfac .Data [_fgedge ]>>_caa ;};_efbc .Data [_eca ]=_cdcf (_efbc .Data [_eca ],_bbcg &_efbc .Data [_eca ],_fbc );_eca +=_efbc .BytesPerLine ;_fgedge +=_dfac .BytesPerLine ;};};if _cggec {for _fcfga =0;_fcfga < _dcfd ;_fcfga ++{for _acgc =0;
_acgc < _fcee ;_acgc ++{_bbcg =_cdcf (_dfac .Data [_ffcf +_acgc ]<<_beed ,_dfac .Data [_ffcf +_acgc +1]>>_caa ,_beedc );_efbc .Data [_dcba +_acgc ]&=_bbcg ;};_dcba +=_efbc .BytesPerLine ;_ffcf +=_dfac .BytesPerLine ;};};if _cdaa {for _fcfga =0;_fcfga < _dcfd ;
_fcfga ++{_bbcg =_dfac .Data [_adac ]<<_beed ;if _gdgce {_bbcg =_cdcf (_bbcg ,_dfac .Data [_adac +1]>>_caa ,_beedc );};_efbc .Data [_acgbg ]=_cdcf (_efbc .Data [_acgbg ],_bbcg &_efbc .Data [_acgbg ],_fcdee );_acgbg +=_efbc .BytesPerLine ;_adac +=_dfac .BytesPerLine ;
};};case PixSrcXorDst :if _bccc {for _fcfga =0;_fcfga < _dcfd ;_fcfga ++{if _fcfg ==_adbc {_bbcg =_dfac .Data [_fgedge ]<<_beed ;if _agff {_bbcg =_cdcf (_bbcg ,_dfac .Data [_fgedge +1]>>_caa ,_beedc );};}else {_bbcg =_dfac .Data [_fgedge ]>>_caa ;};_efbc .Data [_eca ]=_cdcf (_efbc .Data [_eca ],_bbcg ^_efbc .Data [_eca ],_fbc );
_eca +=_efbc .BytesPerLine ;_fgedge +=_dfac .BytesPerLine ;};};if _cggec {for _fcfga =0;_fcfga < _dcfd ;_fcfga ++{for _acgc =0;_acgc < _fcee ;_acgc ++{_bbcg =_cdcf (_dfac .Data [_ffcf +_acgc ]<<_beed ,_dfac .Data [_ffcf +_acgc +1]>>_caa ,_beedc );_efbc .Data [_dcba +_acgc ]^=_bbcg ;
};_dcba +=_efbc .BytesPerLine ;_ffcf +=_dfac .BytesPerLine ;};};if _cdaa {for _fcfga =0;_fcfga < _dcfd ;_fcfga ++{_bbcg =_dfac .Data [_adac ]<<_beed ;if _gdgce {_bbcg =_cdcf (_bbcg ,_dfac .Data [_adac +1]>>_caa ,_beedc );};_efbc .Data [_acgbg ]=_cdcf (_efbc .Data [_acgbg ],_bbcg ^_efbc .Data [_acgbg ],_fcdee );
_acgbg +=_efbc .BytesPerLine ;_adac +=_dfac .BytesPerLine ;};};case PixNotSrcOrDst :if _bccc {for _fcfga =0;_fcfga < _dcfd ;_fcfga ++{if _fcfg ==_adbc {_bbcg =_dfac .Data [_fgedge ]<<_beed ;if _agff {_bbcg =_cdcf (_bbcg ,_dfac .Data [_fgedge +1]>>_caa ,_beedc );
};}else {_bbcg =_dfac .Data [_fgedge ]>>_caa ;};_efbc .Data [_eca ]=_cdcf (_efbc .Data [_eca ],^_bbcg |_efbc .Data [_eca ],_fbc );_eca +=_efbc .BytesPerLine ;_fgedge +=_dfac .BytesPerLine ;};};if _cggec {for _fcfga =0;_fcfga < _dcfd ;_fcfga ++{for _acgc =0;
_acgc < _fcee ;_acgc ++{_bbcg =_cdcf (_dfac .Data [_ffcf +_acgc ]<<_beed ,_dfac .Data [_ffcf +_acgc +1]>>_caa ,_beedc );_efbc .Data [_dcba +_acgc ]|=^_bbcg ;};_dcba +=_efbc .BytesPerLine ;_ffcf +=_dfac .BytesPerLine ;};};if _cdaa {for _fcfga =0;_fcfga < _dcfd ;
_fcfga ++{_bbcg =_dfac .Data [_adac ]<<_beed ;if _gdgce {_bbcg =_cdcf (_bbcg ,_dfac .Data [_adac +1]>>_caa ,_beedc );};_efbc .Data [_acgbg ]=_cdcf (_efbc .Data [_acgbg ],^_bbcg |_efbc .Data [_acgbg ],_fcdee );_acgbg +=_efbc .BytesPerLine ;_adac +=_dfac .BytesPerLine ;
};};case PixNotSrcAndDst :if _bccc {for _fcfga =0;_fcfga < _dcfd ;_fcfga ++{if _fcfg ==_adbc {_bbcg =_dfac .Data [_fgedge ]<<_beed ;if _agff {_bbcg =_cdcf (_bbcg ,_dfac .Data [_fgedge +1]>>_caa ,_beedc );};}else {_bbcg =_dfac .Data [_fgedge ]>>_caa ;};
_efbc .Data [_eca ]=_cdcf (_efbc .Data [_eca ],^_bbcg &_efbc .Data [_eca ],_fbc );_eca +=_efbc .BytesPerLine ;_fgedge +=_dfac .BytesPerLine ;};};if _cggec {for _fcfga =0;_fcfga < _dcfd ;_fcfga ++{for _acgc =0;_acgc < _fcee ;_acgc ++{_bbcg =_cdcf (_dfac .Data [_ffcf +_acgc ]<<_beed ,_dfac .Data [_ffcf +_acgc +1]>>_caa ,_beedc );
_efbc .Data [_dcba +_acgc ]&=^_bbcg ;};_dcba +=_efbc .BytesPerLine ;_ffcf +=_dfac .BytesPerLine ;};};if _cdaa {for _fcfga =0;_fcfga < _dcfd ;_fcfga ++{_bbcg =_dfac .Data [_adac ]<<_beed ;if _gdgce {_bbcg =_cdcf (_bbcg ,_dfac .Data [_adac +1]>>_caa ,_beedc );
};_efbc .Data [_acgbg ]=_cdcf (_efbc .Data [_acgbg ],^_bbcg &_efbc .Data [_acgbg ],_fcdee );_acgbg +=_efbc .BytesPerLine ;_adac +=_dfac .BytesPerLine ;};};case PixSrcOrNotDst :if _bccc {for _fcfga =0;_fcfga < _dcfd ;_fcfga ++{if _fcfg ==_adbc {_bbcg =_dfac .Data [_fgedge ]<<_beed ;
if _agff {_bbcg =_cdcf (_bbcg ,_dfac .Data [_fgedge +1]>>_caa ,_beedc );};}else {_bbcg =_dfac .Data [_fgedge ]>>_caa ;};_efbc .Data [_eca ]=_cdcf (_efbc .Data [_eca ],_bbcg |^_efbc .Data [_eca ],_fbc );_eca +=_efbc .BytesPerLine ;_fgedge +=_dfac .BytesPerLine ;
};};if _cggec {for _fcfga =0;_fcfga < _dcfd ;_fcfga ++{for _acgc =0;_acgc < _fcee ;_acgc ++{_bbcg =_cdcf (_dfac .Data [_ffcf +_acgc ]<<_beed ,_dfac .Data [_ffcf +_acgc +1]>>_caa ,_beedc );_efbc .Data [_dcba +_acgc ]=_bbcg |^_efbc .Data [_dcba +_acgc ];
};_dcba +=_efbc .BytesPerLine ;_ffcf +=_dfac .BytesPerLine ;};};if _cdaa {for _fcfga =0;_fcfga < _dcfd ;_fcfga ++{_bbcg =_dfac .Data [_adac ]<<_beed ;if _gdgce {_bbcg =_cdcf (_bbcg ,_dfac .Data [_adac +1]>>_caa ,_beedc );};_efbc .Data [_acgbg ]=_cdcf (_efbc .Data [_acgbg ],_bbcg |^_efbc .Data [_acgbg ],_fcdee );
_acgbg +=_efbc .BytesPerLine ;_adac +=_dfac .BytesPerLine ;};};case PixSrcAndNotDst :if _bccc {for _fcfga =0;_fcfga < _dcfd ;_fcfga ++{if _fcfg ==_adbc {_bbcg =_dfac .Data [_fgedge ]<<_beed ;if _agff {_bbcg =_cdcf (_bbcg ,_dfac .Data [_fgedge +1]>>_caa ,_beedc );
};}else {_bbcg =_dfac .Data [_fgedge ]>>_caa ;};_efbc .Data [_eca ]=_cdcf (_efbc .Data [_eca ],_bbcg &^_efbc .Data [_eca ],_fbc );_eca +=_efbc .BytesPerLine ;_fgedge +=_dfac .BytesPerLine ;};};if _cggec {for _fcfga =0;_fcfga < _dcfd ;_fcfga ++{for _acgc =0;
_acgc < _fcee ;_acgc ++{_bbcg =_cdcf (_dfac .Data [_ffcf +_acgc ]<<_beed ,_dfac .Data [_ffcf +_acgc +1]>>_caa ,_beedc );_efbc .Data [_dcba +_acgc ]=_bbcg &^_efbc .Data [_dcba +_acgc ];};_dcba +=_efbc .BytesPerLine ;_ffcf +=_dfac .BytesPerLine ;};};if _cdaa {for _fcfga =0;
_fcfga < _dcfd ;_fcfga ++{_bbcg =_dfac .Data [_adac ]<<_beed ;if _gdgce {_bbcg =_cdcf (_bbcg ,_dfac .Data [_adac +1]>>_caa ,_beedc );};_efbc .Data [_acgbg ]=_cdcf (_efbc .Data [_acgbg ],_bbcg &^_efbc .Data [_acgbg ],_fcdee );_acgbg +=_efbc .BytesPerLine ;
_adac +=_dfac .BytesPerLine ;};};case PixNotPixSrcOrDst :if _bccc {for _fcfga =0;_fcfga < _dcfd ;_fcfga ++{if _fcfg ==_adbc {_bbcg =_dfac .Data [_fgedge ]<<_beed ;if _agff {_bbcg =_cdcf (_bbcg ,_dfac .Data [_fgedge +1]>>_caa ,_beedc );};}else {_bbcg =_dfac .Data [_fgedge ]>>_caa ;
};_efbc .Data [_eca ]=_cdcf (_efbc .Data [_eca ],^(_bbcg |_efbc .Data [_eca ]),_fbc );_eca +=_efbc .BytesPerLine ;_fgedge +=_dfac .BytesPerLine ;};};if _cggec {for _fcfga =0;_fcfga < _dcfd ;_fcfga ++{for _acgc =0;_acgc < _fcee ;_acgc ++{_bbcg =_cdcf (_dfac .Data [_ffcf +_acgc ]<<_beed ,_dfac .Data [_ffcf +_acgc +1]>>_caa ,_beedc );
_efbc .Data [_dcba +_acgc ]=^(_bbcg |_efbc .Data [_dcba +_acgc ]);};_dcba +=_efbc .BytesPerLine ;_ffcf +=_dfac .BytesPerLine ;};};if _cdaa {for _fcfga =0;_fcfga < _dcfd ;_fcfga ++{_bbcg =_dfac .Data [_adac ]<<_beed ;if _gdgce {_bbcg =_cdcf (_bbcg ,_dfac .Data [_adac +1]>>_caa ,_beedc );
};_efbc .Data [_acgbg ]=_cdcf (_efbc .Data [_acgbg ],^(_bbcg |_efbc .Data [_acgbg ]),_fcdee );_acgbg +=_efbc .BytesPerLine ;_adac +=_dfac .BytesPerLine ;};};case PixNotPixSrcAndDst :if _bccc {for _fcfga =0;_fcfga < _dcfd ;_fcfga ++{if _fcfg ==_adbc {_bbcg =_dfac .Data [_fgedge ]<<_beed ;
if _agff {_bbcg =_cdcf (_bbcg ,_dfac .Data [_fgedge +1]>>_caa ,_beedc );};}else {_bbcg =_dfac .Data [_fgedge ]>>_caa ;};_efbc .Data [_eca ]=_cdcf (_efbc .Data [_eca ],^(_bbcg &_efbc .Data [_eca ]),_fbc );_eca +=_efbc .BytesPerLine ;_fgedge +=_dfac .BytesPerLine ;
};};if _cggec {for _fcfga =0;_fcfga < _dcfd ;_fcfga ++{for _acgc =0;_acgc < _fcee ;_acgc ++{_bbcg =_cdcf (_dfac .Data [_ffcf +_acgc ]<<_beed ,_dfac .Data [_ffcf +_acgc +1]>>_caa ,_beedc );_efbc .Data [_dcba +_acgc ]=^(_bbcg &_efbc .Data [_dcba +_acgc ]);
};_dcba +=_efbc .BytesPerLine ;_ffcf +=_dfac .BytesPerLine ;};};if _cdaa {for _fcfga =0;_fcfga < _dcfd ;_fcfga ++{_bbcg =_dfac .Data [_adac ]<<_beed ;if _gdgce {_bbcg =_cdcf (_bbcg ,_dfac .Data [_adac +1]>>_caa ,_beedc );};_efbc .Data [_acgbg ]=_cdcf (_efbc .Data [_acgbg ],^(_bbcg &_efbc .Data [_acgbg ]),_fcdee );
_acgbg +=_efbc .BytesPerLine ;_adac +=_dfac .BytesPerLine ;};};case PixNotPixSrcXorDst :if _bccc {for _fcfga =0;_fcfga < _dcfd ;_fcfga ++{if _fcfg ==_adbc {_bbcg =_dfac .Data [_fgedge ]<<_beed ;if _agff {_bbcg =_cdcf (_bbcg ,_dfac .Data [_fgedge +1]>>_caa ,_beedc );
};}else {_bbcg =_dfac .Data [_fgedge ]>>_caa ;};_efbc .Data [_eca ]=_cdcf (_efbc .Data [_eca ],^(_bbcg ^_efbc .Data [_eca ]),_fbc );_eca +=_efbc .BytesPerLine ;_fgedge +=_dfac .BytesPerLine ;};};if _cggec {for _fcfga =0;_fcfga < _dcfd ;_fcfga ++{for _acgc =0;
_acgc < _fcee ;_acgc ++{_bbcg =_cdcf (_dfac .Data [_ffcf +_acgc ]<<_beed ,_dfac .Data [_ffcf +_acgc +1]>>_caa ,_beedc );_efbc .Data [_dcba +_acgc ]=^(_bbcg ^_efbc .Data [_dcba +_acgc ]);};_dcba +=_efbc .BytesPerLine ;_ffcf +=_dfac .BytesPerLine ;};};if _cdaa {for _fcfga =0;
_fcfga < _dcfd ;_fcfga ++{_bbcg =_dfac .Data [_adac ]<<_beed ;if _gdgce {_bbcg =_cdcf (_bbcg ,_dfac .Data [_adac +1]>>_caa ,_beedc );};_efbc .Data [_acgbg ]=_cdcf (_efbc .Data [_acgbg ],^(_bbcg ^_efbc .Data [_acgbg ]),_fcdee );_acgbg +=_efbc .BytesPerLine ;
_adac +=_dfac .BytesPerLine ;};};default:_ca .Log .Debug ("\u004f\u0070e\u0072\u0061\u0074\u0069\u006f\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006e\u006f\u0074\u0020\u0070\u0065\u0072\u006d\u0069tt\u0065\u0064",_dfee );return _b .New ("\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065r\u0061\u0074\u0069\u006f\u006e\u0020\u006eo\u0074\u0020\u0070\u0065\u0072\u006d\u0069\u0074\u0074\u0065\u0064");
};return nil ;};func _cfee (_bcfaa _f .Image ,_bgae Image ,_dbgb _f .Rectangle ){if _afafb ,_gfaag :=_bcfaa .(SMasker );_gfaag &&_afafb .HasAlpha (){_bgae .(SMasker ).MakeAlpha ();};_dcbb (_bcfaa ,_bgae ,_dbgb );};func _cdcf (_afbd ,_egae ,_gbce byte )byte {return (_afbd &^(_gbce ))|(_egae &_gbce )};
func _acagg (_daa _c .Gray )_c .Gray {_daa .Y >>=4;_daa .Y |=_daa .Y <<4;return _daa };func (_egfb *Gray8 )Bounds ()_f .Rectangle {return _f .Rectangle {Max :_f .Point {X :_egfb .Width ,Y :_egfb .Height }};};func (_dag *NRGBA16 )At (x ,y int )_c .Color {_acc ,_ :=_dag .ColorAt (x ,y );
return _acc };func ColorAtGray8BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_c .Gray ,error ){_dafb :=y *bytesPerLine +x ;if _dafb >=len (data ){return _c .Gray {},_db .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_cefb :=data [_dafb ];if len (decode )==2{_cefb =uint8 (uint32 (LinearInterpolate (float64 (_cefb ),0,255,decode [0],decode [1]))&0xff);};return _c .Gray {Y :_cefb },nil ;};func _dfba (_bcce _f .Image )(Image ,error ){if _dcfef ,_aafeg :=_bcce .(*NRGBA64 );
_aafeg {return _dcfef .Copy (),nil ;};_cfffg ,_afg ,_bfea :=_bddc (_bcce ,2);_dcegd ,_efda :=NewImage (_cfffg .Max .X ,_cfffg .Max .Y ,16,3,nil ,_bfea ,nil );if _efda !=nil {return nil ,_efda ;};_cfee (_bcce ,_dcegd ,_cfffg );if len (_bfea )!=0&&!_afg {if _adag :=_agccd (_bfea ,_dcegd );
_adag !=nil {return nil ,_adag ;};};return _dcegd ,nil ;};func (_dgeda *NRGBA16 )Copy ()Image {return &NRGBA16 {ImageBase :_dgeda .copy ()}};func (_cbgb *NRGBA64 )At (x ,y int )_c .Color {_feeb ,_ :=_cbgb .ColorAt (x ,y );return _feeb };func _bbcgb (_ebdd _f .Image )(Image ,error ){if _cbbd ,_ecgb :=_ebdd .(*NRGBA16 );
_ecgb {return _cbbd .Copy (),nil ;};_dbdb :=_ebdd .Bounds ();_bfdc ,_fbea :=NewImage (_dbdb .Max .X ,_dbdb .Max .Y ,4,3,nil ,nil ,nil );if _fbea !=nil {return nil ,_fbea ;};_beedcc (_ebdd ,_bfdc ,_dbdb );return _bfdc ,nil ;};func (_bbbd *Gray16 )Bounds ()_f .Rectangle {return _f .Rectangle {Max :_f .Point {X :_bbbd .Width ,Y :_bbbd .Height }};
};func ImgToGray (i _f .Image )*_f .Gray {if _gdf ,_fecg :=i .(*_f .Gray );_fecg {return _gdf ;};_egde :=i .Bounds ();_egec :=_f .NewGray (_egde );for _gbb :=0;_gbb < _egde .Max .X ;_gbb ++{for _ccgf :=0;_ccgf < _egde .Max .Y ;_ccgf ++{_deddf :=i .At (_gbb ,_ccgf );
_egec .Set (_gbb ,_ccgf ,_deddf );};};return _egec ;};func (_efdf *NRGBA16 )Bounds ()_f .Rectangle {return _f .Rectangle {Max :_f .Point {X :_efdf .Width ,Y :_efdf .Height }};};func ColorAtGray16BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_c .Gray16 ,error ){_edeb :=(y *bytesPerLine /2+x )*2;
if _edeb +1>=len (data ){return _c .Gray16 {},_db .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_agfg :=uint16 (data [_edeb ])<<8|uint16 (data [_edeb +1]);if len (decode )==2{_agfg =uint16 (uint64 (LinearInterpolate (float64 (_agfg ),0,65535,decode [0],decode [1])));};return _c .Gray16 {Y :_agfg },nil ;};func (_bggf *NRGBA32 )Base ()*ImageBase {return &_bggf .ImageBase };
func (_dfgg *NRGBA16 )SetNRGBA (x ,y int ,c _c .NRGBA ){_dffde :=y *_dfgg .BytesPerLine +x *3/2;if _dffde +1>=len (_dfgg .Data ){return ;};c =_fbcc (c );_dfgg .setNRGBA (x ,y ,_dffde ,c );};func (_dgb *Monochrome )IsUnpadded ()bool {return (_dgb .Width *_dgb .Height )==len (_dgb .Data )};
func (_dece *Gray4 )At (x ,y int )_c .Color {_dbgd ,_ :=_dece .ColorAt (x ,y );return _dbgd };func MonochromeThresholdConverter (threshold uint8 )ColorConverter {return &monochromeThresholdConverter {Threshold :threshold };};func _cde (_aeed RGBA ,_cfab Gray ,_gaff _f .Rectangle ){for _afdb :=0;
_afdb < _gaff .Max .X ;_afdb ++{for _bgdg :=0;_bgdg < _gaff .Max .Y ;_bgdg ++{_adbe :=_dbg (_aeed .RGBAAt (_afdb ,_bgdg ));_cfab .SetGray (_afdb ,_bgdg ,_adbe );};};};func (_ggdd *Monochrome )Validate ()error {if len (_ggdd .Data )!=_ggdd .Height *_ggdd .BytesPerLine {return ErrInvalidImage ;
};return nil ;};func _beedcc (_bced _f .Image ,_fdff Image ,_aadea _f .Rectangle ){if _fcbbe ,_efagc :=_bced .(SMasker );_efagc &&_fcbbe .HasAlpha (){_fdff .(SMasker ).MakeAlpha ();};switch _aegb :=_bced .(type ){case Gray :_eada (_aegb ,_fdff .(NRGBA ),_aadea );
case NRGBA :_ddfbf (_aegb ,_fdff .(NRGBA ),_aadea );case *_f .NYCbCrA :_afdc (_aegb ,_fdff .(NRGBA ),_aadea );case CMYK :_ffdf (_aegb ,_fdff .(NRGBA ),_aadea );case RGBA :_ffbcf (_aegb ,_fdff .(NRGBA ),_aadea );case nrgba64 :_gef (_aegb ,_fdff .(NRGBA ),_aadea );
default:_dcbb (_bced ,_fdff ,_aadea );};};func (_ccc *Monochrome )Scale (scale float64 )(*Monochrome ,error ){var _fceg bool ;_abec :=scale ;if scale < 1{_abec =1/scale ;_fceg =true ;};_agd :=NextPowerOf2 (uint (_abec ));if InDelta (float64 (_agd ),_abec ,0.001){if _fceg {return _ccc .ReduceBinary (_abec );
};return _ccc .ExpandBinary (int (_agd ));};_cff :=int (_de .RoundToEven (float64 (_ccc .Width )*scale ));_bddf :=int (_de .RoundToEven (float64 (_ccc .Height )*scale ));return _ccc .ScaleLow (_cff ,_bddf );};var _ _f .Image =&Monochrome {};func (_efef *Gray16 )Histogram ()(_begc [256]int ){for _eafd :=0;
_eafd < _efef .Width ;_eafd ++{for _ffae :=0;_ffae < _efef .Height ;_ffae ++{_begc [_efef .GrayAt (_eafd ,_ffae ).Y ]++;};};return _begc ;};func (_dbga *Gray2 )ColorModel ()_c .Model {return Gray2Model };func (_efc *Monochrome )ResolveDecode ()error {if len (_efc .Decode )!=2{return nil ;
};if _efc .Decode [0]==1&&_efc .Decode [1]==0{if _ccge :=_efc .InverseData ();_ccge !=nil {return _ccge ;};_efc .Decode =nil ;};return nil ;};func _eec (_abcgb Gray ,_gfgc NRGBA ,_aabe _f .Rectangle ){for _bccb :=0;_bccb < _aabe .Max .X ;_bccb ++{for _edbg :=0;
_edbg < _aabe .Max .Y ;_edbg ++{_gddd :=_aab (_gfgc .NRGBAAt (_bccb ,_edbg ));_abcgb .SetGray (_bccb ,_edbg ,_gddd );};};};func _gedc (_ace _c .NYCbCrA )_c .NRGBA {_dgg :=int32 (_ace .Y )*0x10101;_gacg :=int32 (_ace .Cb )-128;_fbec :=int32 (_ace .Cr )-128;
_fcea :=_dgg +91881*_fbec ;if uint32 (_fcea )&0xff000000==0{_fcea >>=8;}else {_fcea =^(_fcea >>31)&0xffff;};_fea :=_dgg -22554*_gacg -46802*_fbec ;if uint32 (_fea )&0xff000000==0{_fea >>=8;}else {_fea =^(_fea >>31)&0xffff;};_bdf :=_dgg +116130*_gacg ;if uint32 (_bdf )&0xff000000==0{_bdf >>=8;
}else {_bdf =^(_bdf >>31)&0xffff;};return _c .NRGBA {R :uint8 (_fcea >>8),G :uint8 (_fea >>8),B :uint8 (_bdf >>8),A :_ace .A };};func _aag (_cfbcga *Monochrome ,_egbe ,_bfgdc int ,_fadg ,_fabf int ,_fecaa RasterOperator ){var (_ggcc int ;_agcfa byte ;_ggb ,_edde int ;
_aeede int ;);_gebc :=_fadg >>3;_dde :=_fadg &7;if _dde > 0{_agcfa =_ffeae [_dde ];};_ggcc =_cfbcga .BytesPerLine *_bfgdc +(_egbe >>3);switch _fecaa {case PixClr :for _ggb =0;_ggb < _fabf ;_ggb ++{_aeede =_ggcc +_ggb *_cfbcga .BytesPerLine ;for _edde =0;
_edde < _gebc ;_edde ++{_cfbcga .Data [_aeede ]=0x0;_aeede ++;};if _dde > 0{_cfbcga .Data [_aeede ]=_cdcf (_cfbcga .Data [_aeede ],0x0,_agcfa );};};case PixSet :for _ggb =0;_ggb < _fabf ;_ggb ++{_aeede =_ggcc +_ggb *_cfbcga .BytesPerLine ;for _edde =0;
_edde < _gebc ;_edde ++{_cfbcga .Data [_aeede ]=0xff;_aeede ++;};if _dde > 0{_cfbcga .Data [_aeede ]=_cdcf (_cfbcga .Data [_aeede ],0xff,_agcfa );};};case PixNotDst :for _ggb =0;_ggb < _fabf ;_ggb ++{_aeede =_ggcc +_ggb *_cfbcga .BytesPerLine ;for _edde =0;
_edde < _gebc ;_edde ++{_cfbcga .Data [_aeede ]=^_cfbcga .Data [_aeede ];_aeede ++;};if _dde > 0{_cfbcga .Data [_aeede ]=_cdcf (_cfbcga .Data [_aeede ],^_cfbcga .Data [_aeede ],_agcfa );};};};};func (_efcgf *NRGBA32 )Bounds ()_f .Rectangle {return _f .Rectangle {Max :_f .Point {X :_efcgf .Width ,Y :_efcgf .Height }};
};func _agccd (_fbgg []byte ,_dadbd Image )error {_acaa :=true ;for _gdge :=0;_gdge < len (_fbgg );_gdge ++{if _fbgg [_gdge ]!=0xff{_acaa =false ;break ;};};if _acaa {switch _edceb :=_dadbd .(type ){case *NRGBA32 :_edceb .Alpha =nil ;case *NRGBA64 :_edceb .Alpha =nil ;
default:return _db .Errorf ("i\u006ete\u0072n\u0061l\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020i\u006d\u0061\u0067\u0065\u0020s\u0068\u006f\u0075l\u0064\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0074\u0079\u0070e\u0020\u002a\u004eRGB\u0041\u0033\u0032\u0020\u006f\u0072 \u002a\u004e\u0052\u0047\u0042\u0041\u0036\u0034\u0020\u0062\u0075\u0074 \u0069s\u003a\u0020\u0025\u0054",_dadbd );
};};return nil ;};func NewImageBase (width int ,height int ,bitsPerComponent int ,colorComponents int ,data []byte ,alpha []byte ,decode []float64 )ImageBase {_fccc :=ImageBase {Width :width ,Height :height ,BitsPerComponent :bitsPerComponent ,ColorComponents :colorComponents ,Data :data ,Alpha :alpha ,Decode :decode ,BytesPerLine :BytesPerLine (width ,bitsPerComponent ,colorComponents )};
if data ==nil {_fccc .Data =make ([]byte ,height *_fccc .BytesPerLine );};return _fccc ;};func (_abbb *Gray8 )Histogram ()(_dbeg [256]int ){for _cbcg :=0;_cbcg < len (_abbb .Data );_cbcg ++{_dbeg [_abbb .Data [_cbcg ]]++;};return _dbeg ;};func _ccb (_cbf _c .RGBA )_c .CMYK {_bdebg ,_efg ,_afad ,_gaa :=_c .RGBToCMYK (_cbf .R ,_cbf .G ,_cbf .B );
return _c .CMYK {C :_bdebg ,M :_efg ,Y :_afad ,K :_gaa };};func (_ddcd *NRGBA64 )Set (x ,y int ,c _c .Color ){_cfbbe :=(y *_ddcd .Width +x )*2;_egbf :=_cfbbe *3;if _egbf +5>=len (_ddcd .Data ){return ;};_gfda :=_c .NRGBA64Model .Convert (c ).(_c .NRGBA64 );
_ddcd .setNRGBA64 (_egbf ,_gfda ,_cfbbe );};func _adcd (_ffad _f .Image )(Image ,error ){if _eff ,_fff :=_ffad .(*Gray2 );_fff {return _eff .Copy (),nil ;};_caba :=_ffad .Bounds ();_bgcc ,_cafb :=NewImage (_caba .Max .X ,_caba .Max .Y ,2,1,nil ,nil ,nil );
if _cafb !=nil {return nil ,_cafb ;};_abg (_ffad ,_bgcc ,_caba );return _bgcc ,nil ;};var _ _f .Image =&Gray16 {};var _ Image =&NRGBA32 {};func (_gfced *Gray2 )Copy ()Image {return &Gray2 {ImageBase :_gfced .copy ()}};func (_aecg *Gray16 )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtGray16BPC (x ,y ,_aecg .BytesPerLine ,_aecg .Data ,_aecg .Decode );
};func _dcc (_degf _c .CMYK )_c .NRGBA {_adfd ,_abf ,_fbaf :=_c .CMYKToRGB (_degf .C ,_degf .M ,_degf .Y ,_degf .K );return _c .NRGBA {R :_adfd ,G :_abf ,B :_fbaf ,A :0xff};};func (_fcdd *ImageBase )setEightFullBytes (_eggd int ,_dcaa uint64 )error {if _eggd +7> len (_fcdd .Data )-1{return _b .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_fcdd .Data [_eggd ]=byte ((_dcaa &0xff00000000000000)>>56);_fcdd .Data [_eggd +1]=byte ((_dcaa &0xff000000000000)>>48);_fcdd .Data [_eggd +2]=byte ((_dcaa &0xff0000000000)>>40);_fcdd .Data [_eggd +3]=byte ((_dcaa &0xff00000000)>>32);_fcdd .Data [_eggd +4]=byte ((_dcaa &0xff000000)>>24);
_fcdd .Data [_eggd +5]=byte ((_dcaa &0xff0000)>>16);_fcdd .Data [_eggd +6]=byte ((_dcaa &0xff00)>>8);_fcdd .Data [_eggd +7]=byte (_dcaa &0xff);return nil ;};func (_dgccd *NRGBA64 )Copy ()Image {return &NRGBA64 {ImageBase :_dgccd .copy ()}};func _cbca (_geba _c .NRGBA )_c .Gray {_ffea ,_debf ,_gfba ,_ :=_geba .RGBA ();
_ade :=(19595*_ffea +38470*_debf +7471*_gfba +1<<15)>>24;return _c .Gray {Y :uint8 (_ade )};};var _ NRGBA =&NRGBA16 {};func (_eaec *NRGBA64 )Base ()*ImageBase {return &_eaec .ImageBase };func _ebbg (_effg _f .Image )(Image ,error ){if _gcaa ,_eccbe :=_effg .(*NRGBA32 );
_eccbe {return _gcaa .Copy (),nil ;};_bbgg ,_aecgd ,_gddb :=_bddc (_effg ,1);_babd ,_eebcc :=NewImage (_bbgg .Max .X ,_bbgg .Max .Y ,8,3,nil ,_gddb ,nil );if _eebcc !=nil {return nil ,_eebcc ;};_beedcc (_effg ,_babd ,_bbgg );if len (_gddb )!=0&&!_aecgd {if _dbdc :=_agccd (_gddb ,_babd );
_dbdc !=nil {return nil ,_dbdc ;};};return _babd ,nil ;};type NRGBA interface{NRGBAAt (_ggag ,_afdg int )_c .NRGBA ;SetNRGBA (_gaec ,_fbce int ,_agfbf _c .NRGBA );};func _baa (_bea ,_fefb int ,_dc []byte )*Monochrome {_baf :=_deb (_bea ,_fefb );_baf .Data =_dc ;
return _baf ;};var _ Gray =&Gray16 {};func (_efgbg *Gray2 )At (x ,y int )_c .Color {_eadf ,_ :=_efgbg .ColorAt (x ,y );return _eadf };func (_adeb *Monochrome )At (x ,y int )_c .Color {_bab ,_ :=_adeb .ColorAt (x ,y );return _bab };func (_fecf *Monochrome )Base ()*ImageBase {return &_fecf .ImageBase };
func _dff ()(_dcf []byte ){_dcf =make ([]byte ,256);for _fcbd :=0;_fcbd < 256;_fcbd ++{_aada :=byte (_fcbd );_dcf [_aada ]=(_aada &0x01)|((_aada &0x04)>>1)|((_aada &0x10)>>2)|((_aada &0x40)>>3)|((_aada &0x02)<<3)|((_aada &0x08)<<2)|((_aada &0x20)<<1)|(_aada &0x80);
};return _dcf ;};func (_dfad *ImageBase )setTwoBytes (_acec int ,_cbdc uint16 )error {if _acec +1> len (_dfad .Data )-1{return _b .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_dfad .Data [_acec ]=byte ((_cbdc &0xff00)>>8);
_dfad .Data [_acec +1]=byte (_cbdc &0xff);return nil ;};func _gef (_ecaae nrgba64 ,_ffdfa NRGBA ,_dda _f .Rectangle ){for _bbdb :=0;_bbdb < _dda .Max .X ;_bbdb ++{for _bcdd :=0;_bcdd < _dda .Max .Y ;_bcdd ++{_gbde :=_ecaae .NRGBA64At (_bbdb ,_bcdd );_ffdfa .SetNRGBA (_bbdb ,_bcdd ,_aeef (_gbde ));
};};};func _fceba (_ega _f .Image )(Image ,error ){if _ebadf ,_fgefe :=_ega .(*Monochrome );_fgefe {return _ebadf ,nil ;};_gga :=_ega .Bounds ();var _bfdb Gray ;switch _ggac :=_ega .(type ){case Gray :_bfdb =_ggac ;case NRGBA :_bfdb =&Gray8 {ImageBase :NewImageBase (_gga .Max .X ,_gga .Max .Y ,8,1,nil ,nil ,nil )};
_eec (_bfdb ,_ggac ,_gga );case nrgba64 :_bfdb =&Gray8 {ImageBase :NewImageBase (_gga .Max .X ,_gga .Max .Y ,8,1,nil ,nil ,nil )};_cbd (_bfdb ,_ggac ,_gga );default:_dedf ,_addg :=GrayConverter .Convert (_ega );if _addg !=nil {return nil ,_addg ;};_bfdb =_dedf .(Gray );
};_cecb ,_dgf :=NewImage (_gga .Max .X ,_gga .Max .Y ,1,1,nil ,nil ,nil );if _dgf !=nil {return nil ,_dgf ;};_cef :=_cecb .(*Monochrome );_dce :=AutoThresholdTriangle (GrayHistogram (_bfdb ));for _ccf :=0;_ccf < _gga .Max .X ;_ccf ++{for _gdgf :=0;_gdgf < _gga .Max .Y ;
_gdgf ++{_eda :=_ecfdb (_bfdb .GrayAt (_ccf ,_gdgf ),monochromeModel (_dce ));_cef .SetGray (_ccf ,_gdgf ,_eda );};};return _cecb ,nil ;};func (_cbcc *NRGBA32 )ColorAt (x ,y int )(_c .Color ,error ){return ColorAtNRGBA32 (x ,y ,_cbcc .Width ,_cbcc .Data ,_cbcc .Alpha ,_cbcc .Decode );
};type ImageBase struct{Width ,Height int ;BitsPerComponent ,ColorComponents int ;Data ,Alpha []byte ;Decode []float64 ;BytesPerLine int ;};func _egea (_acga _c .CMYK )_c .Gray {_gedd ,_bedc ,_eebe :=_c .CMYKToRGB (_acga .C ,_acga .M ,_acga .Y ,_acga .K );
_bcc :=(19595*uint32 (_gedd )+38470*uint32 (_bedc )+7471*uint32 (_eebe )+1<<7)>>16;return _c .Gray {Y :uint8 (_bcc )};};func (_gea *Monochrome )ExpandBinary (factor int )(*Monochrome ,error ){if !IsPowerOf2 (uint (factor )){return nil ,_db .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0065\u0078\u0070\u0061\u006e\u0064\u0020b\u0069n\u0061\u0072\u0079\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",factor );
};return _fe (_gea ,factor );};func _cbec (_dcbag ,_cgbc uint8 )uint8 {if _dcbag < _cgbc {return 255;};return 0;};func (_cfc *CMYK32 )Base ()*ImageBase {return &_cfc .ImageBase };func _deb (_daeg ,_ege int )*Monochrome {return &Monochrome {ImageBase :NewImageBase (_daeg ,_ege ,1,1,nil ,nil ,nil ),ModelThreshold :0x0f};
};func _eba (_dea *Monochrome ,_dbf int ,_gcg []byte )(_fcg *Monochrome ,_cbc error ){const _adg ="\u0072\u0065d\u0075\u0063\u0065R\u0061\u006e\u006b\u0042\u0069\u006e\u0061\u0072\u0079";if _dea ==nil {return nil ,_b .New ("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d");
};if _dbf < 1||_dbf > 4{return nil ,_b .New ("\u006c\u0065\u0076\u0065\u006c\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020\u0073e\u0074\u0020\u007b\u0031\u002c\u0032\u002c\u0033\u002c\u0034\u007d");};if _dea .Height <=1{return nil ,_b .New ("\u0073\u006f\u0075rc\u0065\u0020\u0068\u0065\u0069\u0067\u0068\u0074\u0020m\u0075s\u0074 \u0062e\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020\u0027\u0032\u0027");
};_fcg =_deb (_dea .Width /2,_dea .Height /2);if _gcg ==nil {_gcg =_dff ();};_dae :=_fege (_dea .BytesPerLine ,2*_fcg .BytesPerLine );switch _dbf {case 1:_cbc =_fgb (_dea ,_fcg ,_gcg ,_dae );case 2:_cbc =_ddfa (_dea ,_fcg ,_gcg ,_dae );case 3:_cbc =_dcb (_dea ,_fcg ,_gcg ,_dae );
case 4:_cbc =_fbb (_dea ,_fcg ,_gcg ,_dae );};if _cbc !=nil {return nil ,_cbc ;};return _fcg ,nil ;};func (_cfff *Gray8 )SetGray (x ,y int ,g _c .Gray ){_aafe :=y *_cfff .BytesPerLine +x ;if _aafe > len (_cfff .Data )-1{return ;};_cfff .Data [_aafe ]=g .Y ;
};func _ddd (_aac NRGBA ,_eaab CMYK ,_cfa _f .Rectangle ){for _bfe :=0;_bfe < _cfa .Max .X ;_bfe ++{for _adc :=0;_adc < _cfa .Max .Y ;_adc ++{_aga :=_aac .NRGBAAt (_bfe ,_adc );_eaab .SetCMYK (_bfe ,_adc ,_gddg (_aga ));};};};func _feee (_bbec int ,_ggfa int )error {return _db .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",_bbec ,_ggfa );
};func _bega (_dgcb _c .Gray )_c .CMYK {return _c .CMYK {K :0xff-_dgcb .Y }};func (_cggd *Gray4 )Validate ()error {if len (_cggd .Data )!=_cggd .Height *_cggd .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_fggd *NRGBA32 )ColorModel ()_c .Model {return _c .NRGBAModel };
func _afdc (_abcgg *_f .NYCbCrA ,_cdfc NRGBA ,_aegg _f .Rectangle ){for _gfeg :=0;_gfeg < _aegg .Max .X ;_gfeg ++{for _bbgbe :=0;_bbgbe < _aegg .Max .Y ;_bbgbe ++{_daef :=_abcgg .NYCbCrAAt (_gfeg ,_bbgbe );_cdfc .SetNRGBA (_gfeg ,_bbgbe ,_gedc (_daef ));
};};};func _bga (_gdae *Monochrome ,_faef ,_aabg ,_edge ,_gaafd int ,_cdfg RasterOperator ,_fac *Monochrome ,_bgcb ,_aade int )error {var (_cgd bool ;_gacge bool ;_bafaa int ;_bdcc int ;_fcddf int ;_bbed bool ;_ffc byte ;_caec int ;_bcda int ;_gagf int ;
_cdfe ,_dgab int ;);_bgga :=8-(_faef &7);_fcdf :=_ccde [_bgga ];_decc :=_gdae .BytesPerLine *_aabg +(_faef >>3);_abge :=_fac .BytesPerLine *_aade +(_bgcb >>3);if _edge < _bgga {_cgd =true ;_fcdf &=_ffeae [8-_bgga +_edge ];};if !_cgd {_bafaa =(_edge -_bgga )>>3;
if _bafaa > 0{_gacge =true ;_bdcc =_decc +1;_fcddf =_abge +1;};};_caec =(_faef +_edge )&7;if !(_cgd ||_caec ==0){_bbed =true ;_ffc =_ffeae [_caec ];_bcda =_decc +1+_bafaa ;_gagf =_abge +1+_bafaa ;};switch _cdfg {case PixSrc :for _cdfe =0;_cdfe < _gaafd ;
_cdfe ++{_gdae .Data [_decc ]=_cdcf (_gdae .Data [_decc ],_fac .Data [_abge ],_fcdf );_decc +=_gdae .BytesPerLine ;_abge +=_fac .BytesPerLine ;};if _gacge {for _cdfe =0;_cdfe < _gaafd ;_cdfe ++{for _dgab =0;_dgab < _bafaa ;_dgab ++{_gdae .Data [_bdcc +_dgab ]=_fac .Data [_fcddf +_dgab ];
};_bdcc +=_gdae .BytesPerLine ;_fcddf +=_fac .BytesPerLine ;};};if _bbed {for _cdfe =0;_cdfe < _gaafd ;_cdfe ++{_gdae .Data [_bcda ]=_cdcf (_gdae .Data [_bcda ],_fac .Data [_gagf ],_ffc );_bcda +=_gdae .BytesPerLine ;_gagf +=_fac .BytesPerLine ;};};case PixNotSrc :for _cdfe =0;
_cdfe < _gaafd ;_cdfe ++{_gdae .Data [_decc ]=_cdcf (_gdae .Data [_decc ],^_fac .Data [_abge ],_fcdf );_decc +=_gdae .BytesPerLine ;_abge +=_fac .BytesPerLine ;};if _gacge {for _cdfe =0;_cdfe < _gaafd ;_cdfe ++{for _dgab =0;_dgab < _bafaa ;_dgab ++{_gdae .Data [_bdcc +_dgab ]=^_fac .Data [_fcddf +_dgab ];
};_bdcc +=_gdae .BytesPerLine ;_fcddf +=_fac .BytesPerLine ;};};if _bbed {for _cdfe =0;_cdfe < _gaafd ;_cdfe ++{_gdae .Data [_bcda ]=_cdcf (_gdae .Data [_bcda ],^_fac .Data [_gagf ],_ffc );_bcda +=_gdae .BytesPerLine ;_gagf +=_fac .BytesPerLine ;};};case PixSrcOrDst :for _cdfe =0;
_cdfe < _gaafd ;_cdfe ++{_gdae .Data [_decc ]=_cdcf (_gdae .Data [_decc ],_fac .Data [_abge ]|_gdae .Data [_decc ],_fcdf );_decc +=_gdae .BytesPerLine ;_abge +=_fac .BytesPerLine ;};if _gacge {for _cdfe =0;_cdfe < _gaafd ;_cdfe ++{for _dgab =0;_dgab < _bafaa ;
_dgab ++{_gdae .Data [_bdcc +_dgab ]|=_fac .Data [_fcddf +_dgab ];};_bdcc +=_gdae .BytesPerLine ;_fcddf +=_fac .BytesPerLine ;};};if _bbed {for _cdfe =0;_cdfe < _gaafd ;_cdfe ++{_gdae .Data [_bcda ]=_cdcf (_gdae .Data [_bcda ],_fac .Data [_gagf ]|_gdae .Data [_bcda ],_ffc );
_bcda +=_gdae .BytesPerLine ;_gagf +=_fac .BytesPerLine ;};};case PixSrcAndDst :for _cdfe =0;_cdfe < _gaafd ;_cdfe ++{_gdae .Data [_decc ]=_cdcf (_gdae .Data [_decc ],_fac .Data [_abge ]&_gdae .Data [_decc ],_fcdf );_decc +=_gdae .BytesPerLine ;_abge +=_fac .BytesPerLine ;
};if _gacge {for _cdfe =0;_cdfe < _gaafd ;_cdfe ++{for _dgab =0;_dgab < _bafaa ;_dgab ++{_gdae .Data [_bdcc +_dgab ]&=_fac .Data [_fcddf +_dgab ];};_bdcc +=_gdae .BytesPerLine ;_fcddf +=_fac .BytesPerLine ;};};if _bbed {for _cdfe =0;_cdfe < _gaafd ;_cdfe ++{_gdae .Data [_bcda ]=_cdcf (_gdae .Data [_bcda ],_fac .Data [_gagf ]&_gdae .Data [_bcda ],_ffc );
_bcda +=_gdae .BytesPerLine ;_gagf +=_fac .BytesPerLine ;};};case PixSrcXorDst :for _cdfe =0;_cdfe < _gaafd ;_cdfe ++{_gdae .Data [_decc ]=_cdcf (_gdae .Data [_decc ],_fac .Data [_abge ]^_gdae .Data [_decc ],_fcdf );_decc +=_gdae .BytesPerLine ;_abge +=_fac .BytesPerLine ;
};if _gacge {for _cdfe =0;_cdfe < _gaafd ;_cdfe ++{for _dgab =0;_dgab < _bafaa ;_dgab ++{_gdae .Data [_bdcc +_dgab ]^=_fac .Data [_fcddf +_dgab ];};_bdcc +=_gdae .BytesPerLine ;_fcddf +=_fac .BytesPerLine ;};};if _bbed {for _cdfe =0;_cdfe < _gaafd ;_cdfe ++{_gdae .Data [_bcda ]=_cdcf (_gdae .Data [_bcda ],_fac .Data [_gagf ]^_gdae .Data [_bcda ],_ffc );
_bcda +=_gdae .BytesPerLine ;_gagf +=_fac .BytesPerLine ;};};case PixNotSrcOrDst :for _cdfe =0;_cdfe < _gaafd ;_cdfe ++{_gdae .Data [_decc ]=_cdcf (_gdae .Data [_decc ],^(_fac .Data [_abge ])|_gdae .Data [_decc ],_fcdf );_decc +=_gdae .BytesPerLine ;_abge +=_fac .BytesPerLine ;
};if _gacge {for _cdfe =0;_cdfe < _gaafd ;_cdfe ++{for _dgab =0;_dgab < _bafaa ;_dgab ++{_gdae .Data [_bdcc +_dgab ]|=^(_fac .Data [_fcddf +_dgab ]);};_bdcc +=_gdae .BytesPerLine ;_fcddf +=_fac .BytesPerLine ;};};if _bbed {for _cdfe =0;_cdfe < _gaafd ;
_cdfe ++{_gdae .Data [_bcda ]=_cdcf (_gdae .Data [_bcda ],^(_fac .Data [_gagf ])|_gdae .Data [_bcda ],_ffc );_bcda +=_gdae .BytesPerLine ;_gagf +=_fac .BytesPerLine ;};};case PixNotSrcAndDst :for _cdfe =0;_cdfe < _gaafd ;_cdfe ++{_gdae .Data [_decc ]=_cdcf (_gdae .Data [_decc ],^(_fac .Data [_abge ])&_gdae .Data [_decc ],_fcdf );
_decc +=_gdae .BytesPerLine ;_abge +=_fac .BytesPerLine ;};if _gacge {for _cdfe =0;_cdfe < _gaafd ;_cdfe ++{for _dgab =0;_dgab < _bafaa ;_dgab ++{_gdae .Data [_bdcc +_dgab ]&=^_fac .Data [_fcddf +_dgab ];};_bdcc +=_gdae .BytesPerLine ;_fcddf +=_fac .BytesPerLine ;
};};if _bbed {for _cdfe =0;_cdfe < _gaafd ;_cdfe ++{_gdae .Data [_bcda ]=_cdcf (_gdae .Data [_bcda ],^(_fac .Data [_gagf ])&_gdae .Data [_bcda ],_ffc );_bcda +=_gdae .BytesPerLine ;_gagf +=_fac .BytesPerLine ;};};case PixSrcOrNotDst :for _cdfe =0;_cdfe < _gaafd ;
_cdfe ++{_gdae .Data [_decc ]=_cdcf (_gdae .Data [_decc ],_fac .Data [_abge ]|^(_gdae .Data [_decc ]),_fcdf );_decc +=_gdae .BytesPerLine ;_abge +=_fac .BytesPerLine ;};if _gacge {for _cdfe =0;_cdfe < _gaafd ;_cdfe ++{for _dgab =0;_dgab < _bafaa ;_dgab ++{_gdae .Data [_bdcc +_dgab ]=_fac .Data [_fcddf +_dgab ]|^(_gdae .Data [_bdcc +_dgab ]);
};_bdcc +=_gdae .BytesPerLine ;_fcddf +=_fac .BytesPerLine ;};};if _bbed {for _cdfe =0;_cdfe < _gaafd ;_cdfe ++{_gdae .Data [_bcda ]=_cdcf (_gdae .Data [_bcda ],_fac .Data [_gagf ]|^(_gdae .Data [_bcda ]),_ffc );_bcda +=_gdae .BytesPerLine ;_gagf +=_fac .BytesPerLine ;
};};case PixSrcAndNotDst :for _cdfe =0;_cdfe < _gaafd ;_cdfe ++{_gdae .Data [_decc ]=_cdcf (_gdae .Data [_decc ],_fac .Data [_abge ]&^(_gdae .Data [_decc ]),_fcdf );_decc +=_gdae .BytesPerLine ;_abge +=_fac .BytesPerLine ;};if _gacge {for _cdfe =0;_cdfe < _gaafd ;
_cdfe ++{for _dgab =0;_dgab < _bafaa ;_dgab ++{_gdae .Data [_bdcc +_dgab ]=_fac .Data [_fcddf +_dgab ]&^(_gdae .Data [_bdcc +_dgab ]);};_bdcc +=_gdae .BytesPerLine ;_fcddf +=_fac .BytesPerLine ;};};if _bbed {for _cdfe =0;_cdfe < _gaafd ;_cdfe ++{_gdae .Data [_bcda ]=_cdcf (_gdae .Data [_bcda ],_fac .Data [_gagf ]&^(_gdae .Data [_bcda ]),_ffc );
_bcda +=_gdae .BytesPerLine ;_gagf +=_fac .BytesPerLine ;};};case PixNotPixSrcOrDst :for _cdfe =0;_cdfe < _gaafd ;_cdfe ++{_gdae .Data [_decc ]=_cdcf (_gdae .Data [_decc ],^(_fac .Data [_abge ]|_gdae .Data [_decc ]),_fcdf );_decc +=_gdae .BytesPerLine ;
_abge +=_fac .BytesPerLine ;};if _gacge {for _cdfe =0;_cdfe < _gaafd ;_cdfe ++{for _dgab =0;_dgab < _bafaa ;_dgab ++{_gdae .Data [_bdcc +_dgab ]=^(_fac .Data [_fcddf +_dgab ]|_gdae .Data [_bdcc +_dgab ]);};_bdcc +=_gdae .BytesPerLine ;_fcddf +=_fac .BytesPerLine ;
};};if _bbed {for _cdfe =0;_cdfe < _gaafd ;_cdfe ++{_gdae .Data [_bcda ]=_cdcf (_gdae .Data [_bcda ],^(_fac .Data [_gagf ]|_gdae .Data [_bcda ]),_ffc );_bcda +=_gdae .BytesPerLine ;_gagf +=_fac .BytesPerLine ;};};case PixNotPixSrcAndDst :for _cdfe =0;_cdfe < _gaafd ;
_cdfe ++{_gdae .Data [_decc ]=_cdcf (_gdae .Data [_decc ],^(_fac .Data [_abge ]&_gdae .Data [_decc ]),_fcdf );_decc +=_gdae .BytesPerLine ;_abge +=_fac .BytesPerLine ;};if _gacge {for _cdfe =0;_cdfe < _gaafd ;_cdfe ++{for _dgab =0;_dgab < _bafaa ;_dgab ++{_gdae .Data [_bdcc +_dgab ]=^(_fac .Data [_fcddf +_dgab ]&_gdae .Data [_bdcc +_dgab ]);
};_bdcc +=_gdae .BytesPerLine ;_fcddf +=_fac .BytesPerLine ;};};if _bbed {for _cdfe =0;_cdfe < _gaafd ;_cdfe ++{_gdae .Data [_bcda ]=_cdcf (_gdae .Data [_bcda ],^(_fac .Data [_gagf ]&_gdae .Data [_bcda ]),_ffc );_bcda +=_gdae .BytesPerLine ;_gagf +=_fac .BytesPerLine ;
};};case PixNotPixSrcXorDst :for _cdfe =0;_cdfe < _gaafd ;_cdfe ++{_gdae .Data [_decc ]=_cdcf (_gdae .Data [_decc ],^(_fac .Data [_abge ]^_gdae .Data [_decc ]),_fcdf );_decc +=_gdae .BytesPerLine ;_abge +=_fac .BytesPerLine ;};if _gacge {for _cdfe =0;_cdfe < _gaafd ;
_cdfe ++{for _dgab =0;_dgab < _bafaa ;_dgab ++{_gdae .Data [_bdcc +_dgab ]=^(_fac .Data [_fcddf +_dgab ]^_gdae .Data [_bdcc +_dgab ]);};_bdcc +=_gdae .BytesPerLine ;_fcddf +=_fac .BytesPerLine ;};};if _bbed {for _cdfe =0;_cdfe < _gaafd ;_cdfe ++{_gdae .Data [_bcda ]=_cdcf (_gdae .Data [_bcda ],^(_fac .Data [_gagf ]^_gdae .Data [_bcda ]),_ffc );
_bcda +=_gdae .BytesPerLine ;_gagf +=_fac .BytesPerLine ;};};default:_ca .Log .Debug ("I\u006e\u0076\u0061\u006c\u0069\u0064 \u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070e\u0072\u0061\u0074o\u0072:\u0020\u0025\u0064",_cdfg );return _b .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072");
};return nil ;};var _ Image =&NRGBA64 {};func _fedc (_agccb *Monochrome ,_efee ,_acfg int ,_adda ,_eeed int ,_fgbg RasterOperator ,_cdfa *Monochrome ,_dfgb ,_afaag int )error {var _babe ,_cdgb ,_cgc ,_dfdd int ;if _efee < 0{_dfgb -=_efee ;_adda +=_efee ;
_efee =0;};if _dfgb < 0{_efee -=_dfgb ;_adda +=_dfgb ;_dfgb =0;};_babe =_efee +_adda -_agccb .Width ;if _babe > 0{_adda -=_babe ;};_cdgb =_dfgb +_adda -_cdfa .Width ;if _cdgb > 0{_adda -=_cdgb ;};if _acfg < 0{_afaag -=_acfg ;_eeed +=_acfg ;_acfg =0;};if _afaag < 0{_acfg -=_afaag ;
_eeed +=_afaag ;_afaag =0;};_cgc =_acfg +_eeed -_agccb .Height ;if _cgc > 0{_eeed -=_cgc ;};_dfdd =_afaag +_eeed -_cdfa .Height ;if _dfdd > 0{_eeed -=_dfdd ;};if _adda <=0||_eeed <=0{return nil ;};var _bfgg error ;switch {case _efee &7==0&&_dfgb &7==0:_bfgg =_geee (_agccb ,_efee ,_acfg ,_adda ,_eeed ,_fgbg ,_cdfa ,_dfgb ,_afaag );
case _efee &7==_dfgb &7:_bfgg =_bga (_agccb ,_efee ,_acfg ,_adda ,_eeed ,_fgbg ,_cdfa ,_dfgb ,_afaag );default:_bfgg =_dcab (_agccb ,_efee ,_acfg ,_adda ,_eeed ,_fgbg ,_cdfa ,_dfgb ,_afaag );};if _bfgg !=nil {return _bfgg ;};return nil ;};func (_edda *NRGBA64 )Bounds ()_f .Rectangle {return _f .Rectangle {Max :_f .Point {X :_edda .Width ,Y :_edda .Height }};
};func _aeeb (_begbb _c .Color )_c .Color {_dfca :=_c .NRGBAModel .Convert (_begbb ).(_c .NRGBA );return _fbcc (_dfca );};func _eada (_dddg Gray ,_cccf NRGBA ,_cdfb _f .Rectangle ){for _afed :=0;_afed < _cdfb .Max .X ;_afed ++{for _fdeg :=0;_fdeg < _cdfb .Max .Y ;
_fdeg ++{_efdab :=_dddg .GrayAt (_afed ,_fdeg );_cccf .SetNRGBA (_afed ,_fdeg ,_cge (_efdab ));};};};func (_efa *CMYK32 )Validate ()error {if len (_efa .Data )!=4*_efa .Width *_efa .Height {return _b .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};type NRGBA32 struct{ImageBase };func (_bcee *ImageBase )newAlpha (){_eaceb :=BytesPerLine (_bcee .Width ,_bcee .BitsPerComponent ,1);_bcee .Alpha =make ([]byte ,_bcee .Height *_eaceb );};func (_becd *ImageBase )setByte (_bgfg int ,_ggf byte )error {if _bgfg > len (_becd .Data )-1{return _b .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_becd .Data [_bgfg ]=_ggf ;return nil ;};func _dadd (_gabb _c .NRGBA64 )_c .Gray {var _aabc _c .NRGBA64 ;if _gabb ==_aabc {return _c .Gray {Y :0xff};};_ebcd ,_dbe ,_gagg ,_ :=_gabb .RGBA ();_gcda :=(19595*_ebcd +38470*_dbe +7471*_gagg +1<<15)>>24;return _c .Gray {Y :uint8 (_gcda )};
};func (_dcag *ImageBase )setEightPartlyBytes (_feeg ,_gaeg int ,_caccb uint64 )(_edcc error ){var (_cggc byte ;_dcef int ;);for _fgedg :=1;_fgedg <=_gaeg ;_fgedg ++{_dcef =64-_fgedg *8;_cggc =byte (_caccb >>uint (_dcef )&0xff);if _edcc =_dcag .setByte (_feeg +_fgedg -1,_cggc );
_edcc !=nil {return _edcc ;};};_cdeb :=_dcag .BytesPerLine *8-_dcag .Width ;if _cdeb ==0{return nil ;};_dcef -=8;_cggc =byte (_caccb >>uint (_dcef )&0xff)<<uint (_cdeb );if _edcc =_dcag .setByte (_feeg +_gaeg ,_cggc );_edcc !=nil {return _edcc ;};return nil ;
};func _cge (_abcg _c .Gray )_c .NRGBA {return _c .NRGBA {R :_abcg .Y ,G :_abcg .Y ,B :_abcg .Y ,A :0xff}};var _ Image =&Gray4 {};func ColorAtNRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_c .NRGBA ,error ){_fadb :=y *width +x ;_gged :=3*_fadb ;
if _gged +2>=len (data ){return _c .NRGBA {},_db .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_bfbe :=uint8 (0xff);if alpha !=nil &&len (alpha )> _fadb {_bfbe =alpha [_fadb ];};_fbbe ,_abcb ,_cbaed :=data [_gged ],data [_gged +1],data [_gged +2];if len (decode )==6{_fbbe =uint8 (uint32 (LinearInterpolate (float64 (_fbbe ),0,255,decode [0],decode [1]))&0xff);
_abcb =uint8 (uint32 (LinearInterpolate (float64 (_abcb ),0,255,decode [2],decode [3]))&0xff);_cbaed =uint8 (uint32 (LinearInterpolate (float64 (_cbaed ),0,255,decode [4],decode [5]))&0xff);};return _c .NRGBA {R :_fbbe ,G :_abcb ,B :_cbaed ,A :_bfbe },nil ;
};func _cac (_bb *Monochrome ,_a int ,_ec []uint )(*Monochrome ,error ){_fed :=_a *_bb .Width ;_cae :=_a *_bb .Height ;_fef :=_deb (_fed ,_cae );for _eg ,_bd :=range _ec {var _ecf error ;switch _bd {case 2:_ecf =_df (_fef ,_bb );case 4:_ecf =_bfa (_fef ,_bb );
case 8:_ecf =_dfa (_fef ,_bb );};if _ecf !=nil {return nil ,_ecf ;};if _eg !=len (_ec )-1{_bb =_fef .copy ();};};return _fef ,nil ;};func (_aaad *Monochrome )getBit (_gfce ,_cecf int )uint8 {return _aaad .Data [_gfce +(_cecf >>3)]>>uint (7-(_cecf &7))&1;
};func (_afc *Gray4 )Histogram ()(_egdg [256]int ){for _agcc :=0;_agcc < _afc .Width ;_agcc ++{for _edaf :=0;_edaf < _afc .Height ;_edaf ++{_egdg [_afc .GrayAt (_agcc ,_edaf ).Y ]++;};};return _egdg ;};func _abd (_aeec _f .Image )(Image ,error ){if _fecag ,_dfff :=_aeec .(*Gray8 );
_dfff {return _fecag .Copy (),nil ;};_ebdg :=_aeec .Bounds ();_aaae ,_fagc :=NewImage (_ebdg .Max .X ,_ebdg .Max .Y ,8,1,nil ,nil ,nil );if _fagc !=nil {return nil ,_fagc ;};_abg (_aeec ,_aaae ,_ebdg );return _aaae ,nil ;};func (_bdd *CMYK32 )SetCMYK (x ,y int ,c _c .CMYK ){_cbb :=4*(y *_bdd .Width +x );
if _cbb +3>=len (_bdd .Data ){return ;};_bdd .Data [_cbb ]=c .C ;_bdd .Data [_cbb +1]=c .M ;_bdd .Data [_cbb +2]=c .Y ;_bdd .Data [_cbb +3]=c .K ;};func BytesPerLine (width ,bitsPerComponent ,colorComponents int )int {return ((width *bitsPerComponent )*colorComponents +7)>>3;
};func (_ffcg *NRGBA16 )ColorModel ()_c .Model {return NRGBA16Model };func (_ggced *Gray16 )Copy ()Image {return &Gray16 {ImageBase :_ggced .copy ()}};type NRGBA64 struct{ImageBase };func (_efe *Monochrome )setIndexedBit (_dbb int ){_efe .Data [(_dbb >>3)]|=0x80>>uint (_dbb &7)};
var _ _f .Image =&NRGBA16 {};func _cbbdc (_fcddg *_f .Gray16 ,_ccee uint8 )*_f .Gray {_bbff :=_fcddg .Bounds ();_cacg :=_f .NewGray (_bbff );for _bdee :=0;_bdee < _bbff .Dx ();_bdee ++{for _dccf :=0;_dccf < _bbff .Dy ();_dccf ++{_febe :=_fcddg .Gray16At (_bdee ,_dccf );
_cacg .SetGray (_bdee ,_dccf ,_c .Gray {Y :_cbec (uint8 (_febe .Y /256),_ccee )});};};return _cacg ;};func (_cecc *Monochrome )Bounds ()_f .Rectangle {return _f .Rectangle {Max :_f .Point {X :_cecc .Width ,Y :_cecc .Height }};};type RGBA interface{RGBAAt (_dafba ,_agcb int )_c .RGBA ;
SetRGBA (_cfeb ,_bdebf int ,_ebea _c .RGBA );};func (_dca *ImageBase )setFourBytes (_dbae int ,_cgba uint32 )error {if _dbae +3> len (_dca .Data )-1{return _db .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006fu\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065",_dbae );
};_dca .Data [_dbae ]=byte ((_cgba &0xff000000)>>24);_dca .Data [_dbae +1]=byte ((_cgba &0xff0000)>>16);_dca .Data [_dbae +2]=byte ((_cgba &0xff00)>>8);_dca .Data [_dbae +3]=byte (_cgba &0xff);return nil ;};func NextPowerOf2 (n uint )uint {if IsPowerOf2 (n ){return n ;
};return 1<<(_ddbgf (n )+1);};