//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package imageutil ;import (_ef "encoding/binary";_g "errors";_bd "fmt";_eg "github.com/unidoc/unipdf/v3/common";_c "github.com/unidoc/unipdf/v3/internal/bitwise";_f "image";_b "image/color";_dd "image/draw";_d "math";);func (_bdgc *Gray2 )Bounds ()_f .Rectangle {return _f .Rectangle {Max :_f .Point {X :_bdgc .Width ,Y :_bdgc .Height }};
};func (_caba *ImageBase )copy ()ImageBase {_gcbd :=*_caba ;_gcbd .Data =make ([]byte ,len (_caba .Data ));copy (_gcbd .Data ,_caba .Data );return _gcbd ;};func _abf (_gcf _b .RGBA )_b .NRGBA {switch _gcf .A {case 0xff:return _b .NRGBA {R :_gcf .R ,G :_gcf .G ,B :_gcf .B ,A :0xff};
case 0x00:return _b .NRGBA {};default:_gagfa ,_afdf ,_cee ,_gggb :=_gcf .RGBA ();_gagfa =(_gagfa *0xffff)/_gggb ;_afdf =(_afdf *0xffff)/_gggb ;_cee =(_cee *0xffff)/_gggb ;return _b .NRGBA {R :uint8 (_gagfa >>8),G :uint8 (_afdf >>8),B :uint8 (_cee >>8),A :uint8 (_gggb >>8)};
};};func (_bged *NRGBA32 )setRGBA (_fdac int ,_ebad _b .NRGBA ){_fcgff :=3*_fdac ;_bged .Data [_fcgff ]=_ebad .R ;_bged .Data [_fcgff +1]=_ebad .G ;_bged .Data [_fcgff +2]=_ebad .B ;if _fdac < len (_bged .Alpha ){_bged .Alpha [_fdac ]=_ebad .A ;};};func (_ffea *Gray16 )ColorAt (x ,y int )(_b .Color ,error ){return ColorAtGray16BPC (x ,y ,_ffea .BytesPerLine ,_ffea .Data ,_ffea .Decode );
};func ColorAtGray1BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_b .Gray ,error ){_bbbb :=y *bytesPerLine +x >>3;if _bbbb >=len (data ){return _b .Gray {},_bd .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_fffb :=data [_bbbb ]>>uint (7-(x &7))&1;if len (decode )==2{_fffb =uint8 (LinearInterpolate (float64 (_fffb ),0.0,1.0,decode [0],decode [1]))&1;};return _b .Gray {Y :_fffb *255},nil ;};func _cffd (_bbea _b .Gray )_b .Gray {_bbea .Y >>=4;_bbea .Y |=_bbea .Y <<4;
return _bbea };func _fdeb (_gbga *Monochrome ,_addge ,_begc ,_cffc ,_aead int ,_cabce RasterOperator ,_dbfg *Monochrome ,_fdbg ,_gbd int )error {if _gbga ==nil {return _g .New ("\u006e\u0069\u006c\u0020\u0027\u0064\u0065\u0073\u0074\u0027\u0020\u0042i\u0074\u006d\u0061\u0070");
};if _cabce ==PixDst {return nil ;};switch _cabce {case PixClr ,PixSet ,PixNotDst :_begb (_gbga ,_addge ,_begc ,_cffc ,_aead ,_cabce );return nil ;};if _dbfg ==nil {_eg .Log .Debug ("\u0052a\u0073\u0074e\u0072\u004f\u0070\u0065r\u0061\u0074\u0069o\u006e\u0020\u0073\u006f\u0075\u0072\u0063\u0065\u0020bi\u0074\u006d\u0061p\u0020\u0069s\u0020\u006e\u006f\u0074\u0020\u0064e\u0066\u0069n\u0065\u0064");
return _g .New ("\u006e\u0069l\u0020\u0027\u0073r\u0063\u0027\u0020\u0062\u0069\u0074\u006d\u0061\u0070");};if _bbfa :=_ced (_gbga ,_addge ,_begc ,_cffc ,_aead ,_cabce ,_dbfg ,_fdbg ,_gbd );_bbfa !=nil {return _bbfa ;};return nil ;};func (_gagfb *NRGBA64 )At (x ,y int )_b .Color {_adfb ,_ :=_gagfb .ColorAt (x ,y );
return _adfb };func (_cgbg monochromeModel )Convert (c _b .Color )_b .Color {_fgf :=_b .GrayModel .Convert (c ).(_b .Gray );return _fdbf (_fgf ,_cgbg );};func (_dgb *CMYK32 )Validate ()error {if len (_dgb .Data )!=4*_dgb .Width *_dgb .Height {return _g .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func ColorAtGray16BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_b .Gray16 ,error ){_egbc :=(y *bytesPerLine /2+x )*2;if _egbc +1>=len (data ){return _b .Gray16 {},_bd .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_faefe :=uint16 (data [_egbc ])<<8|uint16 (data [_egbc +1]);if len (decode )==2{_faefe =uint16 (uint64 (LinearInterpolate (float64 (_faefe ),0,65535,decode [0],decode [1])));};return _b .Gray16 {Y :_faefe },nil ;};var ErrInvalidImage =_g .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
func _aagc (_fgg uint )uint {var _cdcbe uint ;for _fgg !=0{_fgg >>=1;_cdcbe ++;};return _cdcbe -1;};func (_ceeg *Monochrome )setIndexedBit (_aaca int ){_ceeg .Data [(_aaca >>3)]|=0x80>>uint (_aaca &7)};func (_aad *Gray8 )Histogram ()(_bgdb [256]int ){for _fcce :=0;
_fcce < len (_aad .Data );_fcce ++{_bgdb [_aad .Data [_fcce ]]++;};return _bgdb ;};type monochromeModel uint8 ;type ImageBase struct{Width ,Height int ;BitsPerComponent ,ColorComponents int ;Data ,Alpha []byte ;Decode []float64 ;BytesPerLine int ;};func ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine int ,data []byte ,decode []float64 )(_b .Color ,error ){switch bitsPerColor {case 1:return ColorAtGray1BPC (x ,y ,bytesPerLine ,data ,decode );
case 2:return ColorAtGray2BPC (x ,y ,bytesPerLine ,data ,decode );case 4:return ColorAtGray4BPC (x ,y ,bytesPerLine ,data ,decode );case 8:return ColorAtGray8BPC (x ,y ,bytesPerLine ,data ,decode );case 16:return ColorAtGray16BPC (x ,y ,bytesPerLine ,data ,decode );
default:return nil ,_bd .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0067\u0072\u0061\u0079\u0020\u0073c\u0061\u006c\u0065\u0020\u0062\u0069\u0074s\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020a\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );
};};func _bebb (_gbgd _b .NRGBA64 )_b .NRGBA {return _b .NRGBA {R :uint8 (_gbgd .R >>8),G :uint8 (_gbgd .G >>8),B :uint8 (_gbgd .B >>8),A :uint8 (_gbgd .A >>8)};};func (_ccbb *Monochrome )Histogram ()(_ebe [256]int ){for _ ,_cgaa :=range _ccbb .Data {_ebe [0xff]+=int (_cdac [_ccbb .Data [_cgaa ]]);
};return _ebe ;};func _fdf ()(_gae [256]uint64 ){for _fbbb :=0;_fbbb < 256;_fbbb ++{if _fbbb &0x01!=0{_gae [_fbbb ]|=0xff;};if _fbbb &0x02!=0{_gae [_fbbb ]|=0xff00;};if _fbbb &0x04!=0{_gae [_fbbb ]|=0xff0000;};if _fbbb &0x08!=0{_gae [_fbbb ]|=0xff000000;
};if _fbbb &0x10!=0{_gae [_fbbb ]|=0xff00000000;};if _fbbb &0x20!=0{_gae [_fbbb ]|=0xff0000000000;};if _fbbb &0x40!=0{_gae [_fbbb ]|=0xff000000000000;};if _fbbb &0x80!=0{_gae [_fbbb ]|=0xff00000000000000;};};return _gae ;};func (_bcff *NRGBA64 )ColorAt (x ,y int )(_b .Color ,error ){return ColorAtNRGBA64 (x ,y ,_bcff .Width ,_bcff .Data ,_bcff .Alpha ,_bcff .Decode );
};func (_dgbd *Monochrome )InverseData ()error {return _dgbd .RasterOperation (0,0,_dgbd .Width ,_dgbd .Height ,PixNotDst ,nil ,0,0);};var _ Image =&NRGBA64 {};func (_aebgb *Monochrome )Base ()*ImageBase {return &_aebgb .ImageBase };func _fddb (_aaf _b .RGBA )_b .Gray {_bgff :=(19595*uint32 (_aaf .R )+38470*uint32 (_aaf .G )+7471*uint32 (_aaf .B )+1<<7)>>16;
return _b .Gray {Y :uint8 (_bgff )};};func (_ffaa *Monochrome )setGray (_bbgc int ,_egaga _b .Gray ,_agd int ){if _egaga .Y ==0{_ffaa .clearBit (_agd ,_bbgc );}else {_ffaa .setGrayBit (_agd ,_bbgc );};};type NRGBA16 struct{ImageBase };func (_dcge *Gray4 )GrayAt (x ,y int )_b .Gray {_baf ,_ :=ColorAtGray4BPC (x ,y ,_dcge .BytesPerLine ,_dcge .Data ,_dcge .Decode );
return _baf ;};func BytesPerLine (width ,bitsPerComponent ,colorComponents int )int {return ((width *bitsPerComponent )*colorComponents +7)>>3;};func (_cecgc *NRGBA64 )Bounds ()_f .Rectangle {return _f .Rectangle {Max :_f .Point {X :_cecgc .Width ,Y :_cecgc .Height }};
};var (Gray2Model =_b .ModelFunc (_ceab );Gray4Model =_b .ModelFunc (_cdgd );NRGBA16Model =_b .ModelFunc (_geag ););func (_aced *Gray2 )Set (x ,y int ,c _b .Color ){if x >=_aced .Width ||y >=_aced .Height {return ;};_bcfd :=Gray2Model .Convert (c ).(_b .Gray );
_bdf :=y *_aced .BytesPerLine ;_cfc :=_bdf +(x >>2);_aga :=_bcfd .Y >>6;_aced .Data [_cfc ]=(_aced .Data [_cfc ]&(^(0xc0>>uint (2*((x )&3)))))|(_aga <<uint (6-2*(x &3)));};var _ Image =&Gray4 {};var _ _f .Image =&Monochrome {};func (_gffd *NRGBA32 )NRGBAAt (x ,y int )_b .NRGBA {_bega ,_ :=ColorAtNRGBA32 (x ,y ,_gffd .Width ,_gffd .Data ,_gffd .Alpha ,_gffd .Decode );
return _bega ;};func (_afed *Gray8 )GrayAt (x ,y int )_b .Gray {_egab ,_ :=ColorAtGray8BPC (x ,y ,_afed .BytesPerLine ,_afed .Data ,_afed .Decode );return _egab ;};func (_fde *Gray4 )Histogram ()(_cbdb [256]int ){for _eead :=0;_eead < _fde .Width ;_eead ++{for _fdfg :=0;
_fdfg < _fde .Height ;_fdfg ++{_cbdb [_fde .GrayAt (_eead ,_fdfg ).Y ]++;};};return _cbdb ;};func (_afac *Gray8 )Bounds ()_f .Rectangle {return _f .Rectangle {Max :_f .Point {X :_afac .Width ,Y :_afac .Height }};};func _fdbf (_bgaa _b .Gray ,_eccc monochromeModel )_b .Gray {if _bgaa .Y > uint8 (_eccc ){return _b .Gray {Y :_d .MaxUint8 };
};return _b .Gray {};};func (_acag *Monochrome )ResolveDecode ()error {if len (_acag .Decode )!=2{return nil ;};if _acag .Decode [0]==1&&_acag .Decode [1]==0{if _gcb :=_acag .InverseData ();_gcb !=nil {return _gcb ;};_acag .Decode =nil ;};return nil ;};
func AddDataPadding (width ,height ,bitsPerComponent ,colorComponents int ,data []byte )([]byte ,error ){_cbbf :=BytesPerLine (width ,bitsPerComponent ,colorComponents );if _cbbf ==width *colorComponents *bitsPerComponent /8{return data ,nil ;};_ebg :=width *colorComponents *bitsPerComponent ;
_aegb :=_cbbf *8;_gee :=8-(_aegb -_ebg );_fef :=_c .NewReader (data );_aaag :=_cbbf -1;_ccc :=make ([]byte ,_aaag );_fegb :=make ([]byte ,height *_cbbf );_ddcb :=_c .NewWriterMSB (_fegb );var _gcdf uint64 ;var _bdfd error ;for _eebb :=0;_eebb < height ;
_eebb ++{_ ,_bdfd =_fef .Read (_ccc );if _bdfd !=nil {return nil ,_bdfd ;};_ ,_bdfd =_ddcb .Write (_ccc );if _bdfd !=nil {return nil ,_bdfd ;};_gcdf ,_bdfd =_fef .ReadBits (byte (_gee ));if _bdfd !=nil {return nil ,_bdfd ;};_ ,_bdfd =_ddcb .WriteBits (_gcdf ,_gee );
if _bdfd !=nil {return nil ,_bdfd ;};_ddcb .FinishByte ();};return _fegb ,nil ;};func (_ddeb *Monochrome )Set (x ,y int ,c _b .Color ){_bfe :=y *_ddeb .BytesPerLine +x >>3;if _bfe > len (_ddeb .Data )-1{return ;};_egfd :=_ddeb .ColorModel ().Convert (c ).(_b .Gray );
_ddeb .setGray (x ,_egfd ,_bfe );};func _abccf (_dccc *Monochrome ,_eeed ,_gagd ,_ded ,_deea int ,_agg RasterOperator ,_dbdfe *Monochrome ,_eefb ,_ggfa int )error {var (_dae byte ;_daace int ;_efad int ;_ffgg ,_cbadd int ;_debc ,_ffae int ;);_gffe :=_ded >>3;
_gfcf :=_ded &7;if _gfcf > 0{_dae =_dbeb [_gfcf ];};_daace =_dbdfe .BytesPerLine *_ggfa +(_eefb >>3);_efad =_dccc .BytesPerLine *_gagd +(_eeed >>3);switch _agg {case PixSrc :for _debc =0;_debc < _deea ;_debc ++{_ffgg =_daace +_debc *_dbdfe .BytesPerLine ;
_cbadd =_efad +_debc *_dccc .BytesPerLine ;for _ffae =0;_ffae < _gffe ;_ffae ++{_dccc .Data [_cbadd ]=_dbdfe .Data [_ffgg ];_cbadd ++;_ffgg ++;};if _gfcf > 0{_dccc .Data [_cbadd ]=_cdgdg (_dccc .Data [_cbadd ],_dbdfe .Data [_ffgg ],_dae );};};case PixNotSrc :for _debc =0;
_debc < _deea ;_debc ++{_ffgg =_daace +_debc *_dbdfe .BytesPerLine ;_cbadd =_efad +_debc *_dccc .BytesPerLine ;for _ffae =0;_ffae < _gffe ;_ffae ++{_dccc .Data [_cbadd ]=^(_dbdfe .Data [_ffgg ]);_cbadd ++;_ffgg ++;};if _gfcf > 0{_dccc .Data [_cbadd ]=_cdgdg (_dccc .Data [_cbadd ],^_dbdfe .Data [_ffgg ],_dae );
};};case PixSrcOrDst :for _debc =0;_debc < _deea ;_debc ++{_ffgg =_daace +_debc *_dbdfe .BytesPerLine ;_cbadd =_efad +_debc *_dccc .BytesPerLine ;for _ffae =0;_ffae < _gffe ;_ffae ++{_dccc .Data [_cbadd ]|=_dbdfe .Data [_ffgg ];_cbadd ++;_ffgg ++;};if _gfcf > 0{_dccc .Data [_cbadd ]=_cdgdg (_dccc .Data [_cbadd ],_dbdfe .Data [_ffgg ]|_dccc .Data [_cbadd ],_dae );
};};case PixSrcAndDst :for _debc =0;_debc < _deea ;_debc ++{_ffgg =_daace +_debc *_dbdfe .BytesPerLine ;_cbadd =_efad +_debc *_dccc .BytesPerLine ;for _ffae =0;_ffae < _gffe ;_ffae ++{_dccc .Data [_cbadd ]&=_dbdfe .Data [_ffgg ];_cbadd ++;_ffgg ++;};if _gfcf > 0{_dccc .Data [_cbadd ]=_cdgdg (_dccc .Data [_cbadd ],_dbdfe .Data [_ffgg ]&_dccc .Data [_cbadd ],_dae );
};};case PixSrcXorDst :for _debc =0;_debc < _deea ;_debc ++{_ffgg =_daace +_debc *_dbdfe .BytesPerLine ;_cbadd =_efad +_debc *_dccc .BytesPerLine ;for _ffae =0;_ffae < _gffe ;_ffae ++{_dccc .Data [_cbadd ]^=_dbdfe .Data [_ffgg ];_cbadd ++;_ffgg ++;};if _gfcf > 0{_dccc .Data [_cbadd ]=_cdgdg (_dccc .Data [_cbadd ],_dbdfe .Data [_ffgg ]^_dccc .Data [_cbadd ],_dae );
};};case PixNotSrcOrDst :for _debc =0;_debc < _deea ;_debc ++{_ffgg =_daace +_debc *_dbdfe .BytesPerLine ;_cbadd =_efad +_debc *_dccc .BytesPerLine ;for _ffae =0;_ffae < _gffe ;_ffae ++{_dccc .Data [_cbadd ]|=^(_dbdfe .Data [_ffgg ]);_cbadd ++;_ffgg ++;
};if _gfcf > 0{_dccc .Data [_cbadd ]=_cdgdg (_dccc .Data [_cbadd ],^(_dbdfe .Data [_ffgg ])|_dccc .Data [_cbadd ],_dae );};};case PixNotSrcAndDst :for _debc =0;_debc < _deea ;_debc ++{_ffgg =_daace +_debc *_dbdfe .BytesPerLine ;_cbadd =_efad +_debc *_dccc .BytesPerLine ;
for _ffae =0;_ffae < _gffe ;_ffae ++{_dccc .Data [_cbadd ]&=^(_dbdfe .Data [_ffgg ]);_cbadd ++;_ffgg ++;};if _gfcf > 0{_dccc .Data [_cbadd ]=_cdgdg (_dccc .Data [_cbadd ],^(_dbdfe .Data [_ffgg ])&_dccc .Data [_cbadd ],_dae );};};case PixSrcOrNotDst :for _debc =0;
_debc < _deea ;_debc ++{_ffgg =_daace +_debc *_dbdfe .BytesPerLine ;_cbadd =_efad +_debc *_dccc .BytesPerLine ;for _ffae =0;_ffae < _gffe ;_ffae ++{_dccc .Data [_cbadd ]=_dbdfe .Data [_ffgg ]|^(_dccc .Data [_cbadd ]);_cbadd ++;_ffgg ++;};if _gfcf > 0{_dccc .Data [_cbadd ]=_cdgdg (_dccc .Data [_cbadd ],_dbdfe .Data [_ffgg ]|^(_dccc .Data [_cbadd ]),_dae );
};};case PixSrcAndNotDst :for _debc =0;_debc < _deea ;_debc ++{_ffgg =_daace +_debc *_dbdfe .BytesPerLine ;_cbadd =_efad +_debc *_dccc .BytesPerLine ;for _ffae =0;_ffae < _gffe ;_ffae ++{_dccc .Data [_cbadd ]=_dbdfe .Data [_ffgg ]&^(_dccc .Data [_cbadd ]);
_cbadd ++;_ffgg ++;};if _gfcf > 0{_dccc .Data [_cbadd ]=_cdgdg (_dccc .Data [_cbadd ],_dbdfe .Data [_ffgg ]&^(_dccc .Data [_cbadd ]),_dae );};};case PixNotPixSrcOrDst :for _debc =0;_debc < _deea ;_debc ++{_ffgg =_daace +_debc *_dbdfe .BytesPerLine ;_cbadd =_efad +_debc *_dccc .BytesPerLine ;
for _ffae =0;_ffae < _gffe ;_ffae ++{_dccc .Data [_cbadd ]=^(_dbdfe .Data [_ffgg ]|_dccc .Data [_cbadd ]);_cbadd ++;_ffgg ++;};if _gfcf > 0{_dccc .Data [_cbadd ]=_cdgdg (_dccc .Data [_cbadd ],^(_dbdfe .Data [_ffgg ]|_dccc .Data [_cbadd ]),_dae );};};case PixNotPixSrcAndDst :for _debc =0;
_debc < _deea ;_debc ++{_ffgg =_daace +_debc *_dbdfe .BytesPerLine ;_cbadd =_efad +_debc *_dccc .BytesPerLine ;for _ffae =0;_ffae < _gffe ;_ffae ++{_dccc .Data [_cbadd ]=^(_dbdfe .Data [_ffgg ]&_dccc .Data [_cbadd ]);_cbadd ++;_ffgg ++;};if _gfcf > 0{_dccc .Data [_cbadd ]=_cdgdg (_dccc .Data [_cbadd ],^(_dbdfe .Data [_ffgg ]&_dccc .Data [_cbadd ]),_dae );
};};case PixNotPixSrcXorDst :for _debc =0;_debc < _deea ;_debc ++{_ffgg =_daace +_debc *_dbdfe .BytesPerLine ;_cbadd =_efad +_debc *_dccc .BytesPerLine ;for _ffae =0;_ffae < _gffe ;_ffae ++{_dccc .Data [_cbadd ]=^(_dbdfe .Data [_ffgg ]^_dccc .Data [_cbadd ]);
_cbadd ++;_ffgg ++;};if _gfcf > 0{_dccc .Data [_cbadd ]=_cdgdg (_dccc .Data [_cbadd ],^(_dbdfe .Data [_ffgg ]^_dccc .Data [_cbadd ]),_dae );};};default:_eg .Log .Debug ("\u0050\u0072ov\u0069\u0064\u0065d\u0020\u0069\u006e\u0076ali\u0064 r\u0061\u0073\u0074\u0065\u0072\u0020\u006fpe\u0072\u0061\u0074\u006f\u0072\u003a\u0020%\u0076",_agg );
return _g .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072");};return nil ;};type NRGBA64 struct{ImageBase };func _efcb (_afcab nrgba64 ,_abaf NRGBA ,_bgca _f .Rectangle ){for _addc :=0;
_addc < _bgca .Max .X ;_addc ++{for _dafgd :=0;_dafgd < _bgca .Max .Y ;_dafgd ++{_cbcg :=_afcab .NRGBA64At (_addc ,_dafgd );_abaf .SetNRGBA (_addc ,_dafgd ,_bebb (_cbcg ));};};};type RasterOperator int ;func FromGoImage (i _f .Image )(Image ,error ){switch _bgag :=i .(type ){case Image :return _bgag .Copy (),nil ;
case Gray :return GrayConverter .Convert (i );case *_f .Gray16 :return Gray16Converter .Convert (i );case CMYK :return CMYKConverter .Convert (i );case *_f .NRGBA64 :return NRGBA64Converter .Convert (i );default:return NRGBAConverter .Convert (i );};};
func (_ceea *monochromeThresholdConverter )Convert (img _f .Image )(Image ,error ){if _aeef ,_fcaa :=img .(*Monochrome );_fcaa {return _aeef .Copy (),nil ;};_cabc :=img .Bounds ();_dfbb ,_befg :=NewImage (_cabc .Max .X ,_cabc .Max .Y ,1,1,nil ,nil ,nil );
if _befg !=nil {return nil ,_befg ;};_dfbb .(*Monochrome ).ModelThreshold =_ceea .Threshold ;for _geab :=0;_geab < _cabc .Max .X ;_geab ++{for _beacg :=0;_beacg < _cabc .Max .Y ;_beacg ++{_bcb :=img .At (_geab ,_beacg );_dfbb .Set (_geab ,_beacg ,_bcb );
};};return _dfbb ,nil ;};func (_afba *Gray16 )Copy ()Image {return &Gray16 {ImageBase :_afba .copy ()}};func _feg (_abg ,_ccf *Monochrome ,_df []byte ,_bbe int )(_bef error ){var (_gaea ,_edg ,_fea ,_bae ,_fdfc ,_gagf ,_beefe ,_egef int ;_gge ,_aebg ,_gdga ,_ebb uint32 ;
_eaf ,_beg byte ;_aec uint16 ;);_ecbf :=make ([]byte ,4);_eea :=make ([]byte ,4);for _fea =0;_fea < _abg .Height -1;_fea ,_bae =_fea +2,_bae +1{_gaea =_fea *_abg .BytesPerLine ;_edg =_bae *_ccf .BytesPerLine ;for _fdfc ,_gagf =0,0;_fdfc < _bbe ;_fdfc ,_gagf =_fdfc +4,_gagf +1{for _beefe =0;
_beefe < 4;_beefe ++{_egef =_gaea +_fdfc +_beefe ;if _egef <=len (_abg .Data )-1&&_egef < _gaea +_abg .BytesPerLine {_ecbf [_beefe ]=_abg .Data [_egef ];}else {_ecbf [_beefe ]=0x00;};_egef =_gaea +_abg .BytesPerLine +_fdfc +_beefe ;if _egef <=len (_abg .Data )-1&&_egef < _gaea +(2*_abg .BytesPerLine ){_eea [_beefe ]=_abg .Data [_egef ];
}else {_eea [_beefe ]=0x00;};};_gge =_ef .BigEndian .Uint32 (_ecbf );_aebg =_ef .BigEndian .Uint32 (_eea );_gdga =_gge &_aebg ;_gdga |=_gdga <<1;_ebb =_gge |_aebg ;_ebb &=_ebb <<1;_aebg =_gdga |_ebb ;_aebg &=0xaaaaaaaa;_gge =_aebg |(_aebg <<7);_eaf =byte (_gge >>24);
_beg =byte ((_gge >>8)&0xff);_egef =_edg +_gagf ;if _egef +1==len (_ccf .Data )-1||_egef +1>=_edg +_ccf .BytesPerLine {if _bef =_ccf .setByte (_egef ,_df [_eaf ]);_bef !=nil {return _bd .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_egef );};
}else {_aec =(uint16 (_df [_eaf ])<<8)|uint16 (_df [_beg ]);if _bef =_ccf .setTwoBytes (_egef ,_aec );_bef !=nil {return _bd .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_egef );
};_gagf ++;};};};return nil ;};func (_beaca *Gray4 )Bounds ()_f .Rectangle {return _f .Rectangle {Max :_f .Point {X :_beaca .Width ,Y :_beaca .Height }};};func _bbdf (_egad *Monochrome ,_cge ,_dcgeb ,_agf ,_baef int ,_adc RasterOperator ,_agcf *Monochrome ,_facb ,_abbd int )error {var (_gdgb bool ;
_eabca bool ;_ccfb int ;_fadb int ;_gfbf int ;_deac bool ;_efgf byte ;_efee int ;_afdc int ;_ecfb int ;_bbcge ,_dbda int ;);_effd :=8-(_cge &7);_gdcg :=_fegc [_effd ];_cacc :=_egad .BytesPerLine *_dcgeb +(_cge >>3);_agdc :=_agcf .BytesPerLine *_abbd +(_facb >>3);
if _agf < _effd {_gdgb =true ;_gdcg &=_dbeb [8-_effd +_agf ];};if !_gdgb {_ccfb =(_agf -_effd )>>3;if _ccfb > 0{_eabca =true ;_fadb =_cacc +1;_gfbf =_agdc +1;};};_efee =(_cge +_agf )&7;if !(_gdgb ||_efee ==0){_deac =true ;_efgf =_dbeb [_efee ];_afdc =_cacc +1+_ccfb ;
_ecfb =_agdc +1+_ccfb ;};switch _adc {case PixSrc :for _bbcge =0;_bbcge < _baef ;_bbcge ++{_egad .Data [_cacc ]=_cdgdg (_egad .Data [_cacc ],_agcf .Data [_agdc ],_gdcg );_cacc +=_egad .BytesPerLine ;_agdc +=_agcf .BytesPerLine ;};if _eabca {for _bbcge =0;
_bbcge < _baef ;_bbcge ++{for _dbda =0;_dbda < _ccfb ;_dbda ++{_egad .Data [_fadb +_dbda ]=_agcf .Data [_gfbf +_dbda ];};_fadb +=_egad .BytesPerLine ;_gfbf +=_agcf .BytesPerLine ;};};if _deac {for _bbcge =0;_bbcge < _baef ;_bbcge ++{_egad .Data [_afdc ]=_cdgdg (_egad .Data [_afdc ],_agcf .Data [_ecfb ],_efgf );
_afdc +=_egad .BytesPerLine ;_ecfb +=_agcf .BytesPerLine ;};};case PixNotSrc :for _bbcge =0;_bbcge < _baef ;_bbcge ++{_egad .Data [_cacc ]=_cdgdg (_egad .Data [_cacc ],^_agcf .Data [_agdc ],_gdcg );_cacc +=_egad .BytesPerLine ;_agdc +=_agcf .BytesPerLine ;
};if _eabca {for _bbcge =0;_bbcge < _baef ;_bbcge ++{for _dbda =0;_dbda < _ccfb ;_dbda ++{_egad .Data [_fadb +_dbda ]=^_agcf .Data [_gfbf +_dbda ];};_fadb +=_egad .BytesPerLine ;_gfbf +=_agcf .BytesPerLine ;};};if _deac {for _bbcge =0;_bbcge < _baef ;_bbcge ++{_egad .Data [_afdc ]=_cdgdg (_egad .Data [_afdc ],^_agcf .Data [_ecfb ],_efgf );
_afdc +=_egad .BytesPerLine ;_ecfb +=_agcf .BytesPerLine ;};};case PixSrcOrDst :for _bbcge =0;_bbcge < _baef ;_bbcge ++{_egad .Data [_cacc ]=_cdgdg (_egad .Data [_cacc ],_agcf .Data [_agdc ]|_egad .Data [_cacc ],_gdcg );_cacc +=_egad .BytesPerLine ;_agdc +=_agcf .BytesPerLine ;
};if _eabca {for _bbcge =0;_bbcge < _baef ;_bbcge ++{for _dbda =0;_dbda < _ccfb ;_dbda ++{_egad .Data [_fadb +_dbda ]|=_agcf .Data [_gfbf +_dbda ];};_fadb +=_egad .BytesPerLine ;_gfbf +=_agcf .BytesPerLine ;};};if _deac {for _bbcge =0;_bbcge < _baef ;_bbcge ++{_egad .Data [_afdc ]=_cdgdg (_egad .Data [_afdc ],_agcf .Data [_ecfb ]|_egad .Data [_afdc ],_efgf );
_afdc +=_egad .BytesPerLine ;_ecfb +=_agcf .BytesPerLine ;};};case PixSrcAndDst :for _bbcge =0;_bbcge < _baef ;_bbcge ++{_egad .Data [_cacc ]=_cdgdg (_egad .Data [_cacc ],_agcf .Data [_agdc ]&_egad .Data [_cacc ],_gdcg );_cacc +=_egad .BytesPerLine ;_agdc +=_agcf .BytesPerLine ;
};if _eabca {for _bbcge =0;_bbcge < _baef ;_bbcge ++{for _dbda =0;_dbda < _ccfb ;_dbda ++{_egad .Data [_fadb +_dbda ]&=_agcf .Data [_gfbf +_dbda ];};_fadb +=_egad .BytesPerLine ;_gfbf +=_agcf .BytesPerLine ;};};if _deac {for _bbcge =0;_bbcge < _baef ;_bbcge ++{_egad .Data [_afdc ]=_cdgdg (_egad .Data [_afdc ],_agcf .Data [_ecfb ]&_egad .Data [_afdc ],_efgf );
_afdc +=_egad .BytesPerLine ;_ecfb +=_agcf .BytesPerLine ;};};case PixSrcXorDst :for _bbcge =0;_bbcge < _baef ;_bbcge ++{_egad .Data [_cacc ]=_cdgdg (_egad .Data [_cacc ],_agcf .Data [_agdc ]^_egad .Data [_cacc ],_gdcg );_cacc +=_egad .BytesPerLine ;_agdc +=_agcf .BytesPerLine ;
};if _eabca {for _bbcge =0;_bbcge < _baef ;_bbcge ++{for _dbda =0;_dbda < _ccfb ;_dbda ++{_egad .Data [_fadb +_dbda ]^=_agcf .Data [_gfbf +_dbda ];};_fadb +=_egad .BytesPerLine ;_gfbf +=_agcf .BytesPerLine ;};};if _deac {for _bbcge =0;_bbcge < _baef ;_bbcge ++{_egad .Data [_afdc ]=_cdgdg (_egad .Data [_afdc ],_agcf .Data [_ecfb ]^_egad .Data [_afdc ],_efgf );
_afdc +=_egad .BytesPerLine ;_ecfb +=_agcf .BytesPerLine ;};};case PixNotSrcOrDst :for _bbcge =0;_bbcge < _baef ;_bbcge ++{_egad .Data [_cacc ]=_cdgdg (_egad .Data [_cacc ],^(_agcf .Data [_agdc ])|_egad .Data [_cacc ],_gdcg );_cacc +=_egad .BytesPerLine ;
_agdc +=_agcf .BytesPerLine ;};if _eabca {for _bbcge =0;_bbcge < _baef ;_bbcge ++{for _dbda =0;_dbda < _ccfb ;_dbda ++{_egad .Data [_fadb +_dbda ]|=^(_agcf .Data [_gfbf +_dbda ]);};_fadb +=_egad .BytesPerLine ;_gfbf +=_agcf .BytesPerLine ;};};if _deac {for _bbcge =0;
_bbcge < _baef ;_bbcge ++{_egad .Data [_afdc ]=_cdgdg (_egad .Data [_afdc ],^(_agcf .Data [_ecfb ])|_egad .Data [_afdc ],_efgf );_afdc +=_egad .BytesPerLine ;_ecfb +=_agcf .BytesPerLine ;};};case PixNotSrcAndDst :for _bbcge =0;_bbcge < _baef ;_bbcge ++{_egad .Data [_cacc ]=_cdgdg (_egad .Data [_cacc ],^(_agcf .Data [_agdc ])&_egad .Data [_cacc ],_gdcg );
_cacc +=_egad .BytesPerLine ;_agdc +=_agcf .BytesPerLine ;};if _eabca {for _bbcge =0;_bbcge < _baef ;_bbcge ++{for _dbda =0;_dbda < _ccfb ;_dbda ++{_egad .Data [_fadb +_dbda ]&=^_agcf .Data [_gfbf +_dbda ];};_fadb +=_egad .BytesPerLine ;_gfbf +=_agcf .BytesPerLine ;
};};if _deac {for _bbcge =0;_bbcge < _baef ;_bbcge ++{_egad .Data [_afdc ]=_cdgdg (_egad .Data [_afdc ],^(_agcf .Data [_ecfb ])&_egad .Data [_afdc ],_efgf );_afdc +=_egad .BytesPerLine ;_ecfb +=_agcf .BytesPerLine ;};};case PixSrcOrNotDst :for _bbcge =0;
_bbcge < _baef ;_bbcge ++{_egad .Data [_cacc ]=_cdgdg (_egad .Data [_cacc ],_agcf .Data [_agdc ]|^(_egad .Data [_cacc ]),_gdcg );_cacc +=_egad .BytesPerLine ;_agdc +=_agcf .BytesPerLine ;};if _eabca {for _bbcge =0;_bbcge < _baef ;_bbcge ++{for _dbda =0;
_dbda < _ccfb ;_dbda ++{_egad .Data [_fadb +_dbda ]=_agcf .Data [_gfbf +_dbda ]|^(_egad .Data [_fadb +_dbda ]);};_fadb +=_egad .BytesPerLine ;_gfbf +=_agcf .BytesPerLine ;};};if _deac {for _bbcge =0;_bbcge < _baef ;_bbcge ++{_egad .Data [_afdc ]=_cdgdg (_egad .Data [_afdc ],_agcf .Data [_ecfb ]|^(_egad .Data [_afdc ]),_efgf );
_afdc +=_egad .BytesPerLine ;_ecfb +=_agcf .BytesPerLine ;};};case PixSrcAndNotDst :for _bbcge =0;_bbcge < _baef ;_bbcge ++{_egad .Data [_cacc ]=_cdgdg (_egad .Data [_cacc ],_agcf .Data [_agdc ]&^(_egad .Data [_cacc ]),_gdcg );_cacc +=_egad .BytesPerLine ;
_agdc +=_agcf .BytesPerLine ;};if _eabca {for _bbcge =0;_bbcge < _baef ;_bbcge ++{for _dbda =0;_dbda < _ccfb ;_dbda ++{_egad .Data [_fadb +_dbda ]=_agcf .Data [_gfbf +_dbda ]&^(_egad .Data [_fadb +_dbda ]);};_fadb +=_egad .BytesPerLine ;_gfbf +=_agcf .BytesPerLine ;
};};if _deac {for _bbcge =0;_bbcge < _baef ;_bbcge ++{_egad .Data [_afdc ]=_cdgdg (_egad .Data [_afdc ],_agcf .Data [_ecfb ]&^(_egad .Data [_afdc ]),_efgf );_afdc +=_egad .BytesPerLine ;_ecfb +=_agcf .BytesPerLine ;};};case PixNotPixSrcOrDst :for _bbcge =0;
_bbcge < _baef ;_bbcge ++{_egad .Data [_cacc ]=_cdgdg (_egad .Data [_cacc ],^(_agcf .Data [_agdc ]|_egad .Data [_cacc ]),_gdcg );_cacc +=_egad .BytesPerLine ;_agdc +=_agcf .BytesPerLine ;};if _eabca {for _bbcge =0;_bbcge < _baef ;_bbcge ++{for _dbda =0;
_dbda < _ccfb ;_dbda ++{_egad .Data [_fadb +_dbda ]=^(_agcf .Data [_gfbf +_dbda ]|_egad .Data [_fadb +_dbda ]);};_fadb +=_egad .BytesPerLine ;_gfbf +=_agcf .BytesPerLine ;};};if _deac {for _bbcge =0;_bbcge < _baef ;_bbcge ++{_egad .Data [_afdc ]=_cdgdg (_egad .Data [_afdc ],^(_agcf .Data [_ecfb ]|_egad .Data [_afdc ]),_efgf );
_afdc +=_egad .BytesPerLine ;_ecfb +=_agcf .BytesPerLine ;};};case PixNotPixSrcAndDst :for _bbcge =0;_bbcge < _baef ;_bbcge ++{_egad .Data [_cacc ]=_cdgdg (_egad .Data [_cacc ],^(_agcf .Data [_agdc ]&_egad .Data [_cacc ]),_gdcg );_cacc +=_egad .BytesPerLine ;
_agdc +=_agcf .BytesPerLine ;};if _eabca {for _bbcge =0;_bbcge < _baef ;_bbcge ++{for _dbda =0;_dbda < _ccfb ;_dbda ++{_egad .Data [_fadb +_dbda ]=^(_agcf .Data [_gfbf +_dbda ]&_egad .Data [_fadb +_dbda ]);};_fadb +=_egad .BytesPerLine ;_gfbf +=_agcf .BytesPerLine ;
};};if _deac {for _bbcge =0;_bbcge < _baef ;_bbcge ++{_egad .Data [_afdc ]=_cdgdg (_egad .Data [_afdc ],^(_agcf .Data [_ecfb ]&_egad .Data [_afdc ]),_efgf );_afdc +=_egad .BytesPerLine ;_ecfb +=_agcf .BytesPerLine ;};};case PixNotPixSrcXorDst :for _bbcge =0;
_bbcge < _baef ;_bbcge ++{_egad .Data [_cacc ]=_cdgdg (_egad .Data [_cacc ],^(_agcf .Data [_agdc ]^_egad .Data [_cacc ]),_gdcg );_cacc +=_egad .BytesPerLine ;_agdc +=_agcf .BytesPerLine ;};if _eabca {for _bbcge =0;_bbcge < _baef ;_bbcge ++{for _dbda =0;
_dbda < _ccfb ;_dbda ++{_egad .Data [_fadb +_dbda ]=^(_agcf .Data [_gfbf +_dbda ]^_egad .Data [_fadb +_dbda ]);};_fadb +=_egad .BytesPerLine ;_gfbf +=_agcf .BytesPerLine ;};};if _deac {for _bbcge =0;_bbcge < _baef ;_bbcge ++{_egad .Data [_afdc ]=_cdgdg (_egad .Data [_afdc ],^(_agcf .Data [_ecfb ]^_egad .Data [_afdc ]),_efgf );
_afdc +=_egad .BytesPerLine ;_ecfb +=_agcf .BytesPerLine ;};};default:_eg .Log .Debug ("I\u006e\u0076\u0061\u006c\u0069\u0064 \u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070e\u0072\u0061\u0074o\u0072:\u0020\u0025\u0064",_adc );return _g .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072");
};return nil ;};var _ Image =&NRGBA16 {};func (_fefc *NRGBA32 )Set (x ,y int ,c _b .Color ){_acdc :=y *_fefc .Width +x ;_fega :=3*_acdc ;if _fega +2>=len (_fefc .Data ){return ;};_dagb :=_b .NRGBAModel .Convert (c ).(_b .NRGBA );_fefc .setRGBA (_acdc ,_dagb );
};func (_gccd *Gray16 )ColorModel ()_b .Model {return _b .Gray16Model };func (_aaga *Gray4 )At (x ,y int )_b .Color {_cbdf ,_ :=_aaga .ColorAt (x ,y );return _cbdf };func (_gadg *Gray2 )Histogram ()(_gafg [256]int ){for _fdfab :=0;_fdfab < _gadg .Width ;
_fdfab ++{for _bedg :=0;_bedg < _gadg .Height ;_bedg ++{_gafg [_gadg .GrayAt (_fdfab ,_bedg ).Y ]++;};};return _gafg ;};func (_accf *NRGBA16 )Validate ()error {if len (_accf .Data )!=3*_accf .Width *_accf .Height /2{return _g .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func _gd (_aee ,_bb *Monochrome )(_ed error ){_fa :=_bb .BytesPerLine ;_edb :=_aee .BytesPerLine ;var (_abc byte ;_ba uint16 ;_edbd ,_cc ,_dg ,_egd ,_ga int ;);for _dg =0;_dg < _bb .Height ;_dg ++{_edbd =_dg *_fa ;_cc =2*_dg *_edb ;for _egd =0;
_egd < _fa ;_egd ++{_abc =_bb .Data [_edbd +_egd ];_ba =_cbe [_abc ];_ga =_cc +_egd *2;if _aee .BytesPerLine !=_bb .BytesPerLine *2&&(_egd +1)*2> _aee .BytesPerLine {_ed =_aee .setByte (_ga ,byte (_ba >>8));}else {_ed =_aee .setTwoBytes (_ga ,_ba );};if _ed !=nil {return _ed ;
};};for _egd =0;_egd < _edb ;_egd ++{_ga =_cc +_edb +_egd ;_abc =_aee .Data [_cc +_egd ];if _ed =_aee .setByte (_ga ,_abc );_ed !=nil {return _ed ;};};};return nil ;};func ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor int ,data ,alpha []byte ,decode []float64 )(_b .Color ,error ){switch bitsPerColor {case 4:return ColorAtNRGBA16 (x ,y ,width ,bytesPerLine ,data ,alpha ,decode );
case 8:return ColorAtNRGBA32 (x ,y ,width ,data ,alpha ,decode );case 16:return ColorAtNRGBA64 (x ,y ,width ,data ,alpha ,decode );default:return nil ,_bd .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0067\u0062\u0020b\u0069\u0074\u0073\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0061\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );
};};func (_dbcg *NRGBA64 )ColorModel ()_b .Model {return _b .NRGBA64Model };func (_gec *ImageBase )setFourBytes (_eeae int ,_dafa uint32 )error {if _eeae +3> len (_gec .Data )-1{return _bd .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006fu\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065",_eeae );
};_gec .Data [_eeae ]=byte ((_dafa &0xff000000)>>24);_gec .Data [_eeae +1]=byte ((_dafa &0xff0000)>>16);_gec .Data [_eeae +2]=byte ((_dafa &0xff00)>>8);_gec .Data [_eeae +3]=byte (_dafa &0xff);return nil ;};func init (){_dgcf ()};func (_aba *NRGBA16 )Bounds ()_f .Rectangle {return _f .Rectangle {Max :_f .Point {X :_aba .Width ,Y :_aba .Height }};
};func (_aged *NRGBA16 )setNRGBA (_agfa ,_afae ,_dgdg int ,_face _b .NRGBA ){if _agfa *3%2==0{_aged .Data [_dgdg ]=(_face .R >>4)<<4|(_face .G >>4);_aged .Data [_dgdg +1]=(_face .B >>4)<<4|(_aged .Data [_dgdg +1]&0xf);}else {_aged .Data [_dgdg ]=(_aged .Data [_dgdg ]&0xf0)|(_face .R >>4);
_aged .Data [_dgdg +1]=(_face .G >>4)<<4|(_face .B >>4);};if _aged .Alpha !=nil {_efdg :=_afae *BytesPerLine (_aged .Width ,4,1);if _efdg < len (_aged .Alpha ){if _agfa %2==0{_aged .Alpha [_efdg ]=(_face .A >>uint (4))<<uint (4)|(_aged .Alpha [_dgdg ]&0xf);
}else {_aged .Alpha [_efdg ]=(_aged .Alpha [_efdg ]&0xf0)|(_face .A >>uint (4));};};};};type SMasker interface{HasAlpha ()bool ;GetAlpha ()[]byte ;MakeAlpha ();};var (MonochromeConverter =ConverterFunc (_beba );Gray2Converter =ConverterFunc (_bebf );Gray4Converter =ConverterFunc (_babf );
GrayConverter =ConverterFunc (_ddc );Gray16Converter =ConverterFunc (_eggd );NRGBA16Converter =ConverterFunc (_cgc );NRGBAConverter =ConverterFunc (_cged );NRGBA64Converter =ConverterFunc (_abdf );CMYKConverter =ConverterFunc (_ccb ););func (_debf *NRGBA64 )Base ()*ImageBase {return &_debf .ImageBase };
func (_ggde *Gray2 )Copy ()Image {return &Gray2 {ImageBase :_ggde .copy ()}};func (_cfb *NRGBA64 )Set (x ,y int ,c _b .Color ){_dgbda :=(y *_cfb .Width +x )*2;_dacb :=_dgbda *3;if _dacb +5>=len (_cfb .Data ){return ;};_agbda :=_b .NRGBA64Model .Convert (c ).(_b .NRGBA64 );
_cfb .setNRGBA64 (_dacb ,_agbda ,_dgbda );};func LinearInterpolate (x ,xmin ,xmax ,ymin ,ymax float64 )float64 {if _d .Abs (xmax -xmin )< 0.000001{return ymin ;};_cbeae :=ymin +(x -xmin )*(ymax -ymin )/(xmax -xmin );return _cbeae ;};func (_effe *Monochrome )GrayAt (x ,y int )_b .Gray {_ffa ,_ :=ColorAtGray1BPC (x ,y ,_effe .BytesPerLine ,_effe .Data ,_effe .Decode );
return _ffa ;};type CMYK interface{CMYKAt (_ggdc ,_acf int )_b .CMYK ;SetCMYK (_gdb ,_ccfd int ,_ffbd _b .CMYK );};func _gbed (_cdfd []byte ,_cgad Image )error {_dcb :=true ;for _ffegd :=0;_ffegd < len (_cdfd );_ffegd ++{if _cdfd [_ffegd ]!=0xff{_dcb =false ;
break ;};};if _dcb {switch _edc :=_cgad .(type ){case *NRGBA32 :_edc .Alpha =nil ;case *NRGBA64 :_edc .Alpha =nil ;default:return _bd .Errorf ("i\u006ete\u0072n\u0061l\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020i\u006d\u0061\u0067\u0065\u0020s\u0068\u006f\u0075l\u0064\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0074\u0079\u0070e\u0020\u002a\u004eRGB\u0041\u0033\u0032\u0020\u006f\u0072 \u002a\u004e\u0052\u0047\u0042\u0041\u0036\u0034\u0020\u0062\u0075\u0074 \u0069s\u003a\u0020\u0025\u0054",_cgad );
};};return nil ;};func MonochromeThresholdConverter (threshold uint8 )ColorConverter {return &monochromeThresholdConverter {Threshold :threshold };};func (_abbb *Gray2 )SetGray (x ,y int ,gray _b .Gray ){_cac :=_ffaag (gray );_fgfc :=y *_abbb .BytesPerLine ;
_bggc :=_fgfc +(x >>2);if _bggc >=len (_abbb .Data ){return ;};_ddf :=_cac .Y >>6;_abbb .Data [_bggc ]=(_abbb .Data [_bggc ]&(^(0xc0>>uint (2*((x )&3)))))|(_ddf <<uint (6-2*(x &3)));};var _ Gray =&Monochrome {};func (_aefd *Gray8 )Base ()*ImageBase {return &_aefd .ImageBase };
func (_gcdc *ImageBase )setEightPartlyBytes (_bbf ,_dfda int ,_gggbf uint64 )(_ffbb error ){var (_dfgb byte ;_ffba int ;);for _cbad :=1;_cbad <=_dfda ;_cbad ++{_ffba =64-_cbad *8;_dfgb =byte (_gggbf >>uint (_ffba )&0xff);if _ffbb =_gcdc .setByte (_bbf +_cbad -1,_dfgb );
_ffbb !=nil {return _ffbb ;};};_adaf :=_gcdc .BytesPerLine *8-_gcdc .Width ;if _adaf ==0{return nil ;};_ffba -=8;_dfgb =byte (_gggbf >>uint (_ffba )&0xff)<<uint (_adaf );if _ffbb =_gcdc .setByte (_bbf +_dfda ,_dfgb );_ffbb !=nil {return _ffbb ;};return nil ;
};func _aab (_aag *Monochrome ,_daca int ,_age []byte )(_dda *Monochrome ,_fc error ){const _dddf ="\u0072\u0065d\u0075\u0063\u0065R\u0061\u006e\u006b\u0042\u0069\u006e\u0061\u0072\u0079";if _aag ==nil {return nil ,_g .New ("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d");
};if _daca < 1||_daca > 4{return nil ,_g .New ("\u006c\u0065\u0076\u0065\u006c\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020\u0073e\u0074\u0020\u007b\u0031\u002c\u0032\u002c\u0033\u002c\u0034\u007d");};if _aag .Height <=1{return nil ,_g .New ("\u0073\u006f\u0075rc\u0065\u0020\u0068\u0065\u0069\u0067\u0068\u0074\u0020m\u0075s\u0074 \u0062e\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020\u0027\u0032\u0027");
};_dda =_edbb (_aag .Width /2,_aag .Height /2);if _age ==nil {_age =_accd ();};_dbe :=_afcf (_aag .BytesPerLine ,2*_dda .BytesPerLine );switch _daca {case 1:_fc =_ceb (_aag ,_dda ,_age ,_dbe );case 2:_fc =_feg (_aag ,_dda ,_age ,_dbe );case 3:_fc =_fcg (_aag ,_dda ,_age ,_dbe );
case 4:_fc =_gaeb (_aag ,_dda ,_age ,_dbe );};if _fc !=nil {return nil ,_fc ;};return _dda ,nil ;};func IsGrayImgBlackAndWhite (i *_f .Gray )bool {return _ggdce (i )};func (_fgafg *ImageBase )setEightBytes (_bfg int ,_fgb uint64 )error {_bcdad :=_fgafg .BytesPerLine -(_bfg %_fgafg .BytesPerLine );
if _fgafg .BytesPerLine !=_fgafg .Width >>3{_bcdad --;};if _bcdad >=8{return _fgafg .setEightFullBytes (_bfg ,_fgb );};return _fgafg .setEightPartlyBytes (_bfg ,_bcdad ,_fgb );};func _edbb (_efd ,_bgbb int )*Monochrome {return &Monochrome {ImageBase :NewImageBase (_efd ,_bgbb ,1,1,nil ,nil ,nil ),ModelThreshold :0x0f};
};type Histogramer interface{Histogram ()[256]int ;};func _fag (_cae ,_eafe CMYK ,_ffef _f .Rectangle ){for _gebd :=0;_gebd < _ffef .Max .X ;_gebd ++{for _aegc :=0;_aegc < _ffef .Max .Y ;_aegc ++{_eafe .SetCMYK (_gebd ,_aegc ,_cae .CMYKAt (_gebd ,_aegc ));
};};};func (_cdbg *Monochrome )Bounds ()_f .Rectangle {return _f .Rectangle {Max :_f .Point {X :_cdbg .Width ,Y :_cdbg .Height }};};func _dbdf (_ceag _f .Image ,_bdg Image ,_bba _f .Rectangle ){for _ddab :=0;_ddab < _bba .Max .X ;_ddab ++{for _bgc :=0;
_bgc < _bba .Max .Y ;_bgc ++{_ceg :=_ceag .At (_ddab ,_bgc );_bdg .Set (_ddab ,_bgc ,_ceg );};};};var _ _f .Image =&Gray16 {};var _ Gray =&Gray8 {};func _feee (_cfad CMYK ,_ebfd NRGBA ,_bebc _f .Rectangle ){for _abgb :=0;_abgb < _bebc .Max .X ;_abgb ++{for _cebce :=0;
_cebce < _bebc .Max .Y ;_cebce ++{_acge :=_cfad .CMYKAt (_abgb ,_cebce );_ebfd .SetNRGBA (_abgb ,_cebce ,_defc (_acge ));};};};func MonochromeModel (threshold uint8 )_b .Model {return monochromeModel (threshold )};func (_cgg *Monochrome )ScaleLow (width ,height int )(*Monochrome ,error ){if width < 0||height < 0{return nil ,_g .New ("\u0070\u0072\u006f\u0076\u0069\u0064e\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0069\u0064t\u0068\u0020\u0061\u006e\u0064\u0020\u0068e\u0069\u0067\u0068\u0074");
};_baec :=_edbb (width ,height );_bbg :=make ([]int ,height );_bgbd :=make ([]int ,width );_fae :=float64 (_cgg .Width )/float64 (width );_cfd :=float64 (_cgg .Height )/float64 (height );for _dgdfe :=0;_dgdfe < height ;_dgdfe ++{_bbg [_dgdfe ]=int (_d .Min (_cfd *float64 (_dgdfe )+0.5,float64 (_cgg .Height -1)));
};for _aabc :=0;_aabc < width ;_aabc ++{_bgbd [_aabc ]=int (_d .Min (_fae *float64 (_aabc )+0.5,float64 (_cgg .Width -1)));};_dbg :=-1;_eae :=byte (0);for _fbg :=0;_fbg < height ;_fbg ++{_fga :=_bbg [_fbg ]*_cgg .BytesPerLine ;_bfec :=_fbg *_baec .BytesPerLine ;
for _beca :=0;_beca < width ;_beca ++{_gfe :=_bgbd [_beca ];if _gfe !=_dbg {_eae =_cgg .getBit (_fga ,_gfe );if _eae !=0{_baec .setBit (_bfec ,_beca );};_dbg =_gfe ;}else {if _eae !=0{_baec .setBit (_bfec ,_beca );};};};};return _baec ,nil ;};func (_fdda *Monochrome )getBitAt (_bfea ,_eacba int )bool {_ecd :=_eacba *_fdda .BytesPerLine +(_bfea >>3);
_dcc :=_bfea &0x07;_cdce :=uint (7-_dcc );if _ecd > len (_fdda .Data )-1{return false ;};if (_fdda .Data [_ecd ]>>_cdce )&0x01>=1{return true ;};return false ;};type Gray8 struct{ImageBase };var _ Image =&Gray8 {};func ColorAtNRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_b .NRGBA ,error ){_fddf :=y *width +x ;
_fcgg :=3*_fddf ;if _fcgg +2>=len (data ){return _b .NRGBA {},_bd .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_cbcc :=uint8 (0xff);if alpha !=nil &&len (alpha )> _fddf {_cbcc =alpha [_fddf ];};_bgeb ,_gfcg ,_efeee :=data [_fcgg ],data [_fcgg +1],data [_fcgg +2];if len (decode )==6{_bgeb =uint8 (uint32 (LinearInterpolate (float64 (_bgeb ),0,255,decode [0],decode [1]))&0xff);
_gfcg =uint8 (uint32 (LinearInterpolate (float64 (_gfcg ),0,255,decode [2],decode [3]))&0xff);_efeee =uint8 (uint32 (LinearInterpolate (float64 (_efeee ),0,255,decode [4],decode [5]))&0xff);};return _b .NRGBA {R :_bgeb ,G :_gfcg ,B :_efeee ,A :_cbcc },nil ;
};func (_baea *Gray2 )GrayAt (x ,y int )_b .Gray {_addg ,_ :=ColorAtGray2BPC (x ,y ,_baea .BytesPerLine ,_baea .Data ,_baea .Decode );return _addg ;};func (_acdd *Monochrome )copy ()*Monochrome {_fed :=_edbb (_acdd .Width ,_acdd .Height );_fed .ModelThreshold =_acdd .ModelThreshold ;
_fed .Data =make ([]byte ,len (_acdd .Data ));copy (_fed .Data ,_acdd .Data );if len (_acdd .Decode )!=0{_fed .Decode =make ([]float64 ,len (_acdd .Decode ));copy (_fed .Decode ,_acdd .Decode );};if len (_acdd .Alpha )!=0{_fed .Alpha =make ([]byte ,len (_acdd .Alpha ));
copy (_fed .Alpha ,_acdd .Alpha );};return _fed ;};var _ Gray =&Gray16 {};func (_cecg *Gray8 )Set (x ,y int ,c _b .Color ){_cbae :=y *_cecg .BytesPerLine +x ;if _cbae > len (_cecg .Data )-1{return ;};_fda :=_b .GrayModel .Convert (c );_cecg .Data [_cbae ]=_fda .(_b .Gray ).Y ;
};func ScaleAlphaToMonochrome (data []byte ,width ,height int )([]byte ,error ){_fb :=BytesPerLine (width ,8,1);if len (data )< _fb *height {return nil ,nil ;};_a :=&Gray8 {NewImageBase (width ,height ,8,1,data ,nil ,nil )};_cd ,_ega :=MonochromeConverter .Convert (_a );
if _ega !=nil {return nil ,_ega ;};return _cd .Base ().Data ,nil ;};func (_becg *NRGBA16 )Set (x ,y int ,c _b .Color ){_agad :=y *_becg .BytesPerLine +x *3/2;if _agad +1>=len (_becg .Data ){return ;};_dcafd :=NRGBA16Model .Convert (c ).(_b .NRGBA );_becg .setNRGBA (x ,y ,_agad ,_dcafd );
};type colorConverter struct{_efda func (_dgce _f .Image )(Image ,error );};func _aedc (_cbga *Monochrome ,_cagf ,_aafb int ,_daegc ,_bebg int ,_daga RasterOperator ){var (_aeaa bool ;_ddac bool ;_cbag int ;_fdbd int ;_dbdfg int ;_ebfg int ;_bbfe bool ;
_bddg byte ;);_ccad :=8-(_cagf &7);_gggbe :=_fegc [_ccad ];_ebfcf :=_cbga .BytesPerLine *_aafb +(_cagf >>3);if _daegc < _ccad {_aeaa =true ;_gggbe &=_dbeb [8-_ccad +_daegc ];};if !_aeaa {_cbag =(_daegc -_ccad )>>3;if _cbag !=0{_ddac =true ;_fdbd =_ebfcf +1;
};};_dbdfg =(_cagf +_daegc )&7;if !(_aeaa ||_dbdfg ==0){_bbfe =true ;_bddg =_dbeb [_dbdfg ];_ebfg =_ebfcf +1+_cbag ;};var _bbec ,_cebb int ;switch _daga {case PixClr :for _bbec =0;_bbec < _bebg ;_bbec ++{_cbga .Data [_ebfcf ]=_cdgdg (_cbga .Data [_ebfcf ],0x0,_gggbe );
_ebfcf +=_cbga .BytesPerLine ;};if _ddac {for _bbec =0;_bbec < _bebg ;_bbec ++{for _cebb =0;_cebb < _cbag ;_cebb ++{_cbga .Data [_fdbd +_cebb ]=0x0;};_fdbd +=_cbga .BytesPerLine ;};};if _bbfe {for _bbec =0;_bbec < _bebg ;_bbec ++{_cbga .Data [_ebfg ]=_cdgdg (_cbga .Data [_ebfg ],0x0,_bddg );
_ebfg +=_cbga .BytesPerLine ;};};case PixSet :for _bbec =0;_bbec < _bebg ;_bbec ++{_cbga .Data [_ebfcf ]=_cdgdg (_cbga .Data [_ebfcf ],0xff,_gggbe );_ebfcf +=_cbga .BytesPerLine ;};if _ddac {for _bbec =0;_bbec < _bebg ;_bbec ++{for _cebb =0;_cebb < _cbag ;
_cebb ++{_cbga .Data [_fdbd +_cebb ]=0xff;};_fdbd +=_cbga .BytesPerLine ;};};if _bbfe {for _bbec =0;_bbec < _bebg ;_bbec ++{_cbga .Data [_ebfg ]=_cdgdg (_cbga .Data [_ebfg ],0xff,_bddg );_ebfg +=_cbga .BytesPerLine ;};};case PixNotDst :for _bbec =0;_bbec < _bebg ;
_bbec ++{_cbga .Data [_ebfcf ]=_cdgdg (_cbga .Data [_ebfcf ],^_cbga .Data [_ebfcf ],_gggbe );_ebfcf +=_cbga .BytesPerLine ;};if _ddac {for _bbec =0;_bbec < _bebg ;_bbec ++{for _cebb =0;_cebb < _cbag ;_cebb ++{_cbga .Data [_fdbd +_cebb ]=^(_cbga .Data [_fdbd +_cebb ]);
};_fdbd +=_cbga .BytesPerLine ;};};if _bbfe {for _bbec =0;_bbec < _bebg ;_bbec ++{_cbga .Data [_ebfg ]=_cdgdg (_cbga .Data [_ebfg ],^_cbga .Data [_ebfg ],_bddg );_ebfg +=_cbga .BytesPerLine ;};};};};var _cdac [256]uint8 ;var _ Image =&Gray16 {};func (_gbg *CMYK32 )SetCMYK (x ,y int ,c _b .CMYK ){_fcgc :=4*(y *_gbg .Width +x );
if _fcgc +3>=len (_gbg .Data ){return ;};_gbg .Data [_fcgc ]=c .C ;_gbg .Data [_fcgc +1]=c .M ;_gbg .Data [_fcgc +2]=c .Y ;_gbg .Data [_fcgc +3]=c .K ;};func _cebc (_bde _b .Gray )_b .NRGBA {return _b .NRGBA {R :_bde .Y ,G :_bde .Y ,B :_bde .Y ,A :0xff}};
var _ _f .Image =&Gray4 {};func _bebf (_dcgf _f .Image )(Image ,error ){if _daf ,_gcc :=_dcgf .(*Gray2 );_gcc {return _daf .Copy (),nil ;};_eef :=_dcgf .Bounds ();_bffe ,_aeec :=NewImage (_eef .Max .X ,_eef .Max .Y ,2,1,nil ,nil ,nil );if _aeec !=nil {return nil ,_aeec ;
};_eecd (_dcgf ,_bffe ,_eef );return _bffe ,nil ;};func (_cacf *Gray16 )GrayAt (x ,y int )_b .Gray {_beefb ,_ :=_cacf .ColorAt (x ,y );return _b .Gray {Y :uint8 (_beefb .(_b .Gray16 ).Y >>8)};};func (_eeaf *CMYK32 )ColorModel ()_b .Model {return _b .CMYKModel };
type nrgba64 interface{NRGBA64At (_cbfb ,_abee int )_b .NRGBA64 ;SetNRGBA64 (_efaf ,_bcfbbb int ,_ebcd _b .NRGBA64 );};func _abd (_ggf ,_dbf int ,_efaa []byte )*Monochrome {_ccg :=_edbb (_ggf ,_dbf );_ccg .Data =_efaa ;return _ccg ;};func ColorAt (x ,y ,width ,bitsPerColor ,colorComponents ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_b .Color ,error ){switch colorComponents {case 1:return ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine ,data ,decode );
case 3:return ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor ,data ,alpha ,decode );case 4:return ColorAtCMYK (x ,y ,width ,data ,decode );default:return nil ,_bd .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0063o\u006c\u006f\u0072\u0020\u0063\u006f\u006dp\u006f\u006e\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0064",colorComponents );
};};func (_afc *Gray4 )ColorModel ()_b .Model {return Gray4Model };func _aed (_aca ,_ccd *Monochrome )(_cgd error ){_gac :=_ccd .BytesPerLine ;_de :=_aca .BytesPerLine ;var _gaf ,_db ,_cce ,_gbbf ,_ggb int ;for _cce =0;_cce < _ccd .Height ;_cce ++{_gaf =_cce *_gac ;
_db =8*_cce *_de ;for _gbbf =0;_gbbf < _gac ;_gbbf ++{if _cgd =_aca .setEightBytes (_db +_gbbf *8,_cgb [_ccd .Data [_gaf +_gbbf ]]);_cgd !=nil {return _cgd ;};};for _ggb =1;_ggb < 8;_ggb ++{for _gbbf =0;_gbbf < _de ;_gbbf ++{if _cgd =_aca .setByte (_db +_ggb *_de +_gbbf ,_aca .Data [_db +_gbbf ]);
_cgd !=nil {return _cgd ;};};};};return nil ;};func NextPowerOf2 (n uint )uint {if IsPowerOf2 (n ){return n ;};return 1<<(_aagc (n )+1);};type Monochrome struct{ImageBase ;ModelThreshold uint8 ;};func (_gba *NRGBA16 )ColorModel ()_b .Model {return NRGBA16Model };
func (_bffed *Gray16 )Validate ()error {if len (_bffed .Data )!=_bffed .Height *_bffed .BytesPerLine {return ErrInvalidImage ;};return nil ;};func (_gbc *Gray4 )Set (x ,y int ,c _b .Color ){if x >=_gbc .Width ||y >=_gbc .Height {return ;};_cfge :=Gray4Model .Convert (c ).(_b .Gray );
_gbc .setGray (x ,y ,_cfge );};func (_cbeb *Monochrome )SetGray (x ,y int ,g _b .Gray ){_bdeb :=y *_cbeb .BytesPerLine +x >>3;if _bdeb > len (_cbeb .Data )-1{return ;};g =_fdbf (g ,monochromeModel (_cbeb .ModelThreshold ));_cbeb .setGray (x ,g ,_bdeb );
};func _bgfa (_agef NRGBA ,_gdgc CMYK ,_fdgg _f .Rectangle ){for _ccbg :=0;_ccbg < _fdgg .Max .X ;_ccbg ++{for _gaae :=0;_gaae < _fdgg .Max .Y ;_gaae ++{_cdcb :=_agef .NRGBAAt (_ccbg ,_gaae );_gdgc .SetCMYK (_ccbg ,_gaae ,_bgba (_cdcb ));};};};func _gfbb (_fbd _f .Image ,_gfea int )(_f .Rectangle ,bool ,[]byte ){_cdbd :=_fbd .Bounds ();
var (_efef bool ;_geac []byte ;);switch _dad :=_fbd .(type ){case SMasker :_efef =_dad .HasAlpha ();case NRGBA ,RGBA ,*_f .RGBA64 ,nrgba64 ,*_f .NYCbCrA :_geac =make ([]byte ,_cdbd .Max .X *_cdbd .Max .Y *_gfea );case *_f .Paletted :var _aedd bool ;for _ ,_cgee :=range _dad .Palette {_ffge ,_baaf ,_bccc ,_aeff :=_cgee .RGBA ();
if _ffge ==0&&_baaf ==0&&_bccc ==0&&_aeff !=0{_aedd =true ;break ;};};if _aedd {_geac =make ([]byte ,_cdbd .Max .X *_cdbd .Max .Y *_gfea );};};return _cdbd ,_efef ,_geac ;};func _eaca (_cbdc RGBA ,_aageg Gray ,_effbb _f .Rectangle ){for _cbaf :=0;_cbaf < _effbb .Max .X ;
_cbaf ++{for _febeg :=0;_febeg < _effbb .Max .Y ;_febeg ++{_daac :=_fddb (_cbdc .RGBAAt (_cbaf ,_febeg ));_aageg .SetGray (_cbaf ,_febeg ,_daac );};};};func _ggea (_eagd *_f .Gray ,_gbae uint8 )*_f .Gray {_gbaef :=_eagd .Bounds ();_bfde :=_f .NewGray (_gbaef );
for _ecfe :=0;_ecfe < _gbaef .Dx ();_ecfe ++{for _bffcg :=0;_bffcg < _gbaef .Dy ();_bffcg ++{_abcd :=_eagd .GrayAt (_ecfe ,_bffcg );_bfde .SetGray (_ecfe ,_bffcg ,_b .Gray {Y :_ecfd (_abcd .Y ,_gbae )});};};return _bfde ;};var _ Gray =&Gray4 {};func _dde (_fdb Gray ,_fdd CMYK ,_bcfb _f .Rectangle ){for _bdc :=0;
_bdc < _bcfb .Max .X ;_bdc ++{for _ebfc :=0;_ebfc < _bcfb .Max .Y ;_ebfc ++{_fgc :=_fdb .GrayAt (_bdc ,_ebfc );_fdd .SetCMYK (_bdc ,_ebfc ,_bed (_fgc ));};};};func (_cff *CMYK32 )CMYKAt (x ,y int )_b .CMYK {_bga ,_ :=ColorAtCMYK (x ,y ,_cff .Width ,_cff .Data ,_cff .Decode );
return _bga ;};type monochromeThresholdConverter struct{Threshold uint8 ;};func (_aecfe *NRGBA64 )setNRGBA64 (_dbfga int ,_gecf _b .NRGBA64 ,_adga int ){_aecfe .Data [_dbfga ]=uint8 (_gecf .R >>8);_aecfe .Data [_dbfga +1]=uint8 (_gecf .R &0xff);_aecfe .Data [_dbfga +2]=uint8 (_gecf .G >>8);
_aecfe .Data [_dbfga +3]=uint8 (_gecf .G &0xff);_aecfe .Data [_dbfga +4]=uint8 (_gecf .B >>8);_aecfe .Data [_dbfga +5]=uint8 (_gecf .B &0xff);if _adga +1< len (_aecfe .Alpha ){_aecfe .Alpha [_adga ]=uint8 (_gecf .A >>8);_aecfe .Alpha [_adga +1]=uint8 (_gecf .A &0xff);
};};func (_cffb *NRGBA32 )At (x ,y int )_b .Color {_fggb ,_ :=_cffb .ColorAt (x ,y );return _fggb };func _cafe (_ddfc *_f .NYCbCrA ,_ccbgb NRGBA ,_bbgca _f .Rectangle ){for _bgef :=0;_bgef < _bbgca .Max .X ;_bgef ++{for _gaga :=0;_gaga < _bbgca .Max .Y ;
_gaga ++{_gcde :=_ddfc .NYCbCrAAt (_bgef ,_gaga );_ccbgb .SetNRGBA (_bgef ,_gaga ,_deb (_gcde ));};};};func GrayHistogram (g Gray )(_gecc [256]int ){switch _fgce :=g .(type ){case Histogramer :return _fgce .Histogram ();case _f .Image :_bfdf :=_fgce .Bounds ();
for _gbgc :=0;_gbgc < _bfdf .Max .X ;_gbgc ++{for _dbeg :=0;_dbeg < _bfdf .Max .Y ;_dbeg ++{_gecc [g .GrayAt (_gbgc ,_dbeg ).Y ]++;};};return _gecc ;default:return [256]int {};};};const (_egbgg shift =iota ;_ecga ;);var _ _f .Image =&Gray8 {};func _dc (_egf *Monochrome ,_ag int )(*Monochrome ,error ){if _egf ==nil {return nil ,_g .New ("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064");
};if _ag ==1{return _egf .copy (),nil ;};if !IsPowerOf2 (uint (_ag )){return nil ,_bd .Errorf ("\u0070\u0072\u006fvi\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006ci\u0064 \u0065x\u0070a\u006e\u0064\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_ag );
};_fbf :=_ebd (_ag );return _cdc (_egf ,_ag ,_fbf );};type NRGBA32 struct{ImageBase };type Gray16 struct{ImageBase };func _bgba (_bgg _b .NRGBA )_b .CMYK {_fcf ,_abcc ,_caf ,_ :=_bgg .RGBA ();_afd ,_gdbg ,_dgdf ,_eee :=_b .RGBToCMYK (uint8 (_fcf >>8),uint8 (_abcc >>8),uint8 (_caf >>8));
return _b .CMYK {C :_afd ,M :_gdbg ,Y :_dgdf ,K :_eee };};func GetConverter (bitsPerComponent ,colorComponents int )(ColorConverter ,error ){switch colorComponents {case 1:switch bitsPerComponent {case 1:return MonochromeConverter ,nil ;case 2:return Gray2Converter ,nil ;
case 4:return Gray4Converter ,nil ;case 8:return GrayConverter ,nil ;case 16:return Gray16Converter ,nil ;};case 3:switch bitsPerComponent {case 4:return NRGBA16Converter ,nil ;case 8:return NRGBAConverter ,nil ;case 16:return NRGBA64Converter ,nil ;};
case 4:return CMYKConverter ,nil ;};return nil ,_bd .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0043o\u006e\u0076\u0065\u0072\u0074\u0065\u0072\u0020\u0070\u0061\u0072\u0061\u006d\u0065t\u0065\u0072\u0073\u002e\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003a\u0020\u0025\u0064\u002c\u0020\u0043\u006f\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006et\u0073\u003a \u0025\u0064",bitsPerComponent ,colorComponents );
};func (_bebba *Monochrome )ExpandBinary (factor int )(*Monochrome ,error ){if !IsPowerOf2 (uint (factor )){return nil ,_bd .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0065\u0078\u0070\u0061\u006e\u0064\u0020b\u0069n\u0061\u0072\u0079\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",factor );
};return _dc (_bebba ,factor );};func _ggdce (_agfd *_f .Gray )bool {for _febdc :=0;_febdc < len (_agfd .Pix );_febdc ++{if !_fcabf (_agfd .Pix [_febdc ]){return false ;};};return true ;};type RGBA interface{RGBAAt (_faea ,_bfbb int )_b .RGBA ;SetRGBA (_cebg ,_ead int ,_efec _b .RGBA );
};func (_caa *Gray16 )Set (x ,y int ,c _b .Color ){_gafea :=(y *_caa .BytesPerLine /2+x )*2;if _gafea +1>=len (_caa .Data ){return ;};_gfg :=_b .Gray16Model .Convert (c ).(_b .Gray16 );_caa .Data [_gafea ],_caa .Data [_gafea +1]=uint8 (_gfg .Y >>8),uint8 (_gfg .Y &0xff);
};func _ccda (_cecgb NRGBA ,_fdce Gray ,_gdd _f .Rectangle ){for _ddfg :=0;_ddfg < _gdd .Max .X ;_ddfg ++{for _efdc :=0;_efdc < _gdd .Max .Y ;_efdc ++{_acb :=_faf (_cecgb .NRGBAAt (_ddfg ,_efdc ));_fdce .SetGray (_ddfg ,_efdc ,_acb );};};};func _eggd (_affb _f .Image )(Image ,error ){if _febd ,_acab :=_affb .(*Gray16 );
_acab {return _febd .Copy (),nil ;};_bgda :=_affb .Bounds ();_ebbb ,_eba :=NewImage (_bgda .Max .X ,_bgda .Max .Y ,16,1,nil ,nil ,nil );if _eba !=nil {return nil ,_eba ;};_eecd (_affb ,_ebbb ,_bgda );return _ebbb ,nil ;};func (_cec *Gray4 )Validate ()error {if len (_cec .Data )!=_cec .Height *_cec .BytesPerLine {return ErrInvalidImage ;
};return nil ;};func _ced (_dff *Monochrome ,_cggb ,_fbae int ,_dab ,_feeaf int ,_fbbcf RasterOperator ,_dage *Monochrome ,_efbc ,_dfbbb int )error {var _dfgca ,_beae ,_caag ,_ffd int ;if _cggb < 0{_efbc -=_cggb ;_dab +=_cggb ;_cggb =0;};if _efbc < 0{_cggb -=_efbc ;
_dab +=_efbc ;_efbc =0;};_dfgca =_cggb +_dab -_dff .Width ;if _dfgca > 0{_dab -=_dfgca ;};_beae =_efbc +_dab -_dage .Width ;if _beae > 0{_dab -=_beae ;};if _fbae < 0{_dfbbb -=_fbae ;_feeaf +=_fbae ;_fbae =0;};if _dfbbb < 0{_fbae -=_dfbbb ;_feeaf +=_dfbbb ;
_dfbbb =0;};_caag =_fbae +_feeaf -_dff .Height ;if _caag > 0{_feeaf -=_caag ;};_ffd =_dfbbb +_feeaf -_dage .Height ;if _ffd > 0{_feeaf -=_ffd ;};if _dab <=0||_feeaf <=0{return nil ;};var _ccgeb error ;switch {case _cggb &7==0&&_efbc &7==0:_ccgeb =_abccf (_dff ,_cggb ,_fbae ,_dab ,_feeaf ,_fbbcf ,_dage ,_efbc ,_dfbbb );
case _cggb &7==_efbc &7:_ccgeb =_bbdf (_dff ,_cggb ,_fbae ,_dab ,_feeaf ,_fbbcf ,_dage ,_efbc ,_dfbbb );default:_ccgeb =_cbafb (_dff ,_cggb ,_fbae ,_dab ,_feeaf ,_fbbcf ,_dage ,_efbc ,_dfbbb );};if _ccgeb !=nil {return _ccgeb ;};return nil ;};func (_bedf *Monochrome )ColorAt (x ,y int )(_b .Color ,error ){return ColorAtGray1BPC (x ,y ,_bedf .BytesPerLine ,_bedf .Data ,_bedf .Decode );
};var _ _f .Image =&NRGBA16 {};func (_feb *CMYK32 )Base ()*ImageBase {return &_feb .ImageBase };func _dcdd (_eac _b .NRGBA )_b .Gray {var _eafb _b .NRGBA ;if _eac ==_eafb {return _b .Gray {Y :0xff};};_gfc ,_dceb ,_cga ,_ :=_eac .RGBA ();_gdbd :=(19595*_gfc +38470*_dceb +7471*_cga +1<<15)>>24;
return _b .Gray {Y :uint8 (_gdbd )};};func (_gfad *Gray8 )SetGray (x ,y int ,g _b .Gray ){_fbecf :=y *_gfad .BytesPerLine +x ;if _fbecf > len (_gfad .Data )-1{return ;};_gfad .Data [_fbecf ]=g .Y ;};func (_feae *ImageBase )Pix ()[]byte {return _feae .Data };
type NRGBA interface{NRGBAAt (_caad ,_gfgg int )_b .NRGBA ;SetNRGBA (_edgf ,_gagb int ,_dede _b .NRGBA );};func _cdgd (_ffca _b .Color )_b .Color {_fcgf :=_b .GrayModel .Convert (_ffca ).(_b .Gray );return _cffd (_fcgf );};func _ec (_bg ,_gf *Monochrome )(_gc error ){_ddd :=_gf .BytesPerLine ;
_ac :=_bg .BytesPerLine ;_aa :=_gf .BytesPerLine *4-_bg .BytesPerLine ;var (_da ,_ca byte ;_gbb uint32 ;_ecg ,_ad ,_ege ,_bgb ,_fd ,_gag ,_cb int ;);for _ege =0;_ege < _gf .Height ;_ege ++{_ecg =_ege *_ddd ;_ad =4*_ege *_ac ;for _bgb =0;_bgb < _ddd ;_bgb ++{_da =_gf .Data [_ecg +_bgb ];
_gbb =_bad [_da ];_gag =_ad +_bgb *4;if _aa !=0&&(_bgb +1)*4> _bg .BytesPerLine {for _fd =_aa ;_fd > 0;_fd --{_ca =byte ((_gbb >>uint (_fd *8))&0xff);_cb =_gag +(_aa -_fd );if _gc =_bg .setByte (_cb ,_ca );_gc !=nil {return _gc ;};};}else if _gc =_bg .setFourBytes (_gag ,_gbb );
_gc !=nil {return _gc ;};if _gc =_bg .setFourBytes (_ad +_bgb *4,_bad [_gf .Data [_ecg +_bgb ]]);_gc !=nil {return _gc ;};};for _fd =1;_fd < 4;_fd ++{for _bgb =0;_bgb < _ac ;_bgb ++{if _gc =_bg .setByte (_ad +_fd *_ac +_bgb ,_bg .Data [_ad +_bgb ]);_gc !=nil {return _gc ;
};};};};return nil ;};func _afcf (_acdg int ,_acede int )int {if _acdg < _acede {return _acdg ;};return _acede ;};func (_acae *NRGBA64 )NRGBA64At (x ,y int )_b .NRGBA64 {_bage ,_ :=ColorAtNRGBA64 (x ,y ,_acae .Width ,_acae .Data ,_acae .Alpha ,_acae .Decode );
return _bage ;};func _beba (_aac _f .Image )(Image ,error ){if _edef ,_ggce :=_aac .(*Monochrome );_ggce {return _edef ,nil ;};_edbbb :=_aac .Bounds ();var _bdcff Gray ;switch _ddg :=_aac .(type ){case Gray :_bdcff =_ddg ;case NRGBA :_bdcff =&Gray8 {ImageBase :NewImageBase (_edbbb .Max .X ,_edbbb .Max .Y ,8,1,nil ,nil ,nil )};
_ccfa (_bdcff ,_ddg ,_edbbb );case nrgba64 :_bdcff =&Gray8 {ImageBase :NewImageBase (_edbbb .Max .X ,_edbbb .Max .Y ,8,1,nil ,nil ,nil )};_fbe (_bdcff ,_ddg ,_edbbb );default:_acd ,_dga :=GrayConverter .Convert (_aac );if _dga !=nil {return nil ,_dga ;
};_bdcff =_acd .(Gray );};_acg ,_fca :=NewImage (_edbbb .Max .X ,_edbbb .Max .Y ,1,1,nil ,nil ,nil );if _fca !=nil {return nil ,_fca ;};_bgad :=_acg .(*Monochrome );_cgdb :=AutoThresholdTriangle (GrayHistogram (_bdcff ));for _bdag :=0;_bdag < _edbbb .Max .X ;
_bdag ++{for _defd :=0;_defd < _edbbb .Max .Y ;_defd ++{_dfb :=_fdbf (_bdcff .GrayAt (_bdag ,_defd ),monochromeModel (_cgdb ));_bgad .SetGray (_bdag ,_defd ,_dfb );};};return _acg ,nil ;};func (_dfc *CMYK32 )ColorAt (x ,y int )(_b .Color ,error ){return ColorAtCMYK (x ,y ,_dfc .Width ,_dfc .Data ,_dfc .Decode );
};func (_ffag *ImageBase )getByte (_ccgb int )(byte ,error ){if _ccgb > len (_ffag .Data )-1||_ccgb < 0{return 0,_bd .Errorf ("\u0069\u006e\u0064\u0065x:\u0020\u0025\u0064\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006eg\u0065",_ccgb );
};return _ffag .Data [_ccgb ],nil ;};func IsPowerOf2 (n uint )bool {return n > 0&&(n &(n -1))==0};var _ NRGBA =&NRGBA32 {};func (_bdfb *NRGBA16 )ColorAt (x ,y int )(_b .Color ,error ){return ColorAtNRGBA16 (x ,y ,_bdfb .Width ,_bdfb .BytesPerLine ,_bdfb .Data ,_bdfb .Alpha ,_bdfb .Decode );
};func _fcg (_cfe ,_dfe *Monochrome ,_aaa []byte ,_ede int )(_fbfb error ){var (_dgd ,_dbd ,_gad ,_cfg ,_egfg ,_bdd ,_gabb ,_aegf int ;_aeac ,_dce ,_fg ,_ffc uint32 ;_gdae ,_efg byte ;_dfg uint16 ;);_dacg :=make ([]byte ,4);_ccdg :=make ([]byte ,4);for _gad =0;
_gad < _cfe .Height -1;_gad ,_cfg =_gad +2,_cfg +1{_dgd =_gad *_cfe .BytesPerLine ;_dbd =_cfg *_dfe .BytesPerLine ;for _egfg ,_bdd =0,0;_egfg < _ede ;_egfg ,_bdd =_egfg +4,_bdd +1{for _gabb =0;_gabb < 4;_gabb ++{_aegf =_dgd +_egfg +_gabb ;if _aegf <=len (_cfe .Data )-1&&_aegf < _dgd +_cfe .BytesPerLine {_dacg [_gabb ]=_cfe .Data [_aegf ];
}else {_dacg [_gabb ]=0x00;};_aegf =_dgd +_cfe .BytesPerLine +_egfg +_gabb ;if _aegf <=len (_cfe .Data )-1&&_aegf < _dgd +(2*_cfe .BytesPerLine ){_ccdg [_gabb ]=_cfe .Data [_aegf ];}else {_ccdg [_gabb ]=0x00;};};_aeac =_ef .BigEndian .Uint32 (_dacg );_dce =_ef .BigEndian .Uint32 (_ccdg );
_fg =_aeac &_dce ;_fg |=_fg <<1;_ffc =_aeac |_dce ;_ffc &=_ffc <<1;_dce =_fg &_ffc ;_dce &=0xaaaaaaaa;_aeac =_dce |(_dce <<7);_gdae =byte (_aeac >>24);_efg =byte ((_aeac >>8)&0xff);_aegf =_dbd +_bdd ;if _aegf +1==len (_dfe .Data )-1||_aegf +1>=_dbd +_dfe .BytesPerLine {if _fbfb =_dfe .setByte (_aegf ,_aaa [_gdae ]);
_fbfb !=nil {return _bd .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_aegf );};}else {_dfg =(uint16 (_aaa [_gdae ])<<8)|uint16 (_aaa [_efg ]);if _fbfb =_dfe .setTwoBytes (_aegf ,_dfg );_fbfb !=nil {return _bd .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_aegf );
};_bdd ++;};};};return nil ;};func _ceb (_bab ,_ecb *Monochrome ,_fbba []byte ,_ffb int )(_cbea error ){var (_bbb ,_gff ,_gda ,_afa ,_fad ,_ea ,_bffd ,_bca int ;_adb ,_cdb uint32 ;_aabb ,_fac byte ;_efb uint16 ;);_ccdb :=make ([]byte ,4);_gef :=make ([]byte ,4);
for _gda =0;_gda < _bab .Height -1;_gda ,_afa =_gda +2,_afa +1{_bbb =_gda *_bab .BytesPerLine ;_gff =_afa *_ecb .BytesPerLine ;for _fad ,_ea =0,0;_fad < _ffb ;_fad ,_ea =_fad +4,_ea +1{for _bffd =0;_bffd < 4;_bffd ++{_bca =_bbb +_fad +_bffd ;if _bca <=len (_bab .Data )-1&&_bca < _bbb +_bab .BytesPerLine {_ccdb [_bffd ]=_bab .Data [_bca ];
}else {_ccdb [_bffd ]=0x00;};_bca =_bbb +_bab .BytesPerLine +_fad +_bffd ;if _bca <=len (_bab .Data )-1&&_bca < _bbb +(2*_bab .BytesPerLine ){_gef [_bffd ]=_bab .Data [_bca ];}else {_gef [_bffd ]=0x00;};};_adb =_ef .BigEndian .Uint32 (_ccdb );_cdb =_ef .BigEndian .Uint32 (_gef );
_cdb |=_adb ;_cdb |=_cdb <<1;_cdb &=0xaaaaaaaa;_adb =_cdb |(_cdb <<7);_aabb =byte (_adb >>24);_fac =byte ((_adb >>8)&0xff);_bca =_gff +_ea ;if _bca +1==len (_ecb .Data )-1||_bca +1>=_gff +_ecb .BytesPerLine {_ecb .Data [_bca ]=_fbba [_aabb ];}else {_efb =(uint16 (_fbba [_aabb ])<<8)|uint16 (_fbba [_fac ]);
if _cbea =_ecb .setTwoBytes (_bca ,_efb );_cbea !=nil {return _bd .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_bca );
};_ea ++;};};};return nil ;};func (_fgaf *ImageBase )HasAlpha ()bool {if _fgaf .Alpha ==nil {return false ;};for _ffaae :=range _fgaf .Alpha {if _fgaf .Alpha [_ffaae ]!=0xff{return true ;};};return false ;};func ColorAtNRGBA64 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_b .NRGBA64 ,error ){_caaf :=(y *width +x )*2;
_gage :=_caaf *3;if _gage +5>=len (data ){return _b .NRGBA64 {},_bd .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};const _cbde =0xffff;_adec :=uint16 (_cbde );if alpha !=nil &&len (alpha )> _caaf +1{_adec =uint16 (alpha [_caaf ])<<8|uint16 (alpha [_caaf +1]);};_cbbfg :=uint16 (data [_gage ])<<8|uint16 (data [_gage +1]);_bded :=uint16 (data [_gage +2])<<8|uint16 (data [_gage +3]);
_dagg :=uint16 (data [_gage +4])<<8|uint16 (data [_gage +5]);if len (decode )==6{_cbbfg =uint16 (uint64 (LinearInterpolate (float64 (_cbbfg ),0,65535,decode [0],decode [1]))&_cbde );_bded =uint16 (uint64 (LinearInterpolate (float64 (_bded ),0,65535,decode [2],decode [3]))&_cbde );
_dagg =uint16 (uint64 (LinearInterpolate (float64 (_dagg ),0,65535,decode [4],decode [5]))&_cbde );};return _b .NRGBA64 {R :_cbbfg ,G :_bded ,B :_dagg ,A :_adec },nil ;};func (_ggba *NRGBA16 )Base ()*ImageBase {return &_ggba .ImageBase };func _cdgdg (_dgab ,_cdf ,_cffe byte )byte {return (_dgab &^(_cffe ))|(_cdf &_cffe )};
func _deb (_geg _b .NYCbCrA )_b .NRGBA {_ebdc :=int32 (_geg .Y )*0x10101;_aebd :=int32 (_geg .Cb )-128;_dfd :=int32 (_geg .Cr )-128;_bdcf :=_ebdc +91881*_dfd ;if uint32 (_bdcf )&0xff000000==0{_bdcf >>=8;}else {_bdcf =^(_bdcf >>31)&0xffff;};_dbdc :=_ebdc -22554*_aebd -46802*_dfd ;
if uint32 (_dbdc )&0xff000000==0{_dbdc >>=8;}else {_dbdc =^(_dbdc >>31)&0xffff;};_ceba :=_ebdc +116130*_aebd ;if uint32 (_ceba )&0xff000000==0{_ceba >>=8;}else {_ceba =^(_ceba >>31)&0xffff;};return _b .NRGBA {R :uint8 (_bdcf >>8),G :uint8 (_dbdc >>8),B :uint8 (_ceba >>8),A :_geg .A };
};func ImgToGray (i _f .Image )*_f .Gray {if _dfff ,_aege :=i .(*_f .Gray );_aege {return _dfff ;};_dgbe :=i .Bounds ();_ggdf :=_f .NewGray (_dgbe );for _ccff :=0;_ccff < _dgbe .Max .X ;_ccff ++{for _dded :=0;_dded < _dgbe .Max .Y ;_dded ++{_agfb :=i .At (_ccff ,_dded );
_ggdf .Set (_ccff ,_dded ,_agfb );};};return _ggdf ;};func (_eabf *NRGBA16 )SetNRGBA (x ,y int ,c _b .NRGBA ){_gde :=y *_eabf .BytesPerLine +x *3/2;if _gde +1>=len (_eabf .Data ){return ;};c =_afdcg (c );_eabf .setNRGBA (x ,y ,_gde ,c );};func (_gcca *NRGBA32 )ColorModel ()_b .Model {return _b .NRGBAModel };
func ColorAtGray8BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_b .Gray ,error ){_bceb :=y *bytesPerLine +x ;if _bceb >=len (data ){return _b .Gray {},_bd .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_debg :=data [_bceb ];if len (decode )==2{_debg =uint8 (uint32 (LinearInterpolate (float64 (_debg ),0,255,decode [0],decode [1]))&0xff);};return _b .Gray {Y :_debg },nil ;};func (_fafa *Gray4 )SetGray (x ,y int ,g _b .Gray ){if x >=_fafa .Width ||y >=_fafa .Height {return ;
};g =_cffd (g );_fafa .setGray (x ,y ,g );};func (_ecee *Gray8 )ColorAt (x ,y int )(_b .Color ,error ){return ColorAtGray8BPC (x ,y ,_ecee .BytesPerLine ,_ecee .Data ,_ecee .Decode );};func (_add *Monochrome )Copy ()Image {return &Monochrome {ImageBase :_add .ImageBase .copy (),ModelThreshold :_add .ModelThreshold };
};func (_bdgg *ImageBase )setByte (_ecbfe int ,_dcaf byte )error {if _ecbfe > len (_bdgg .Data )-1{return _g .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_bdgg .Data [_ecbfe ]=_dcaf ;return nil ;};
func (_fafd *NRGBA64 )Copy ()Image {return &NRGBA64 {ImageBase :_fafd .copy ()}};func _gdeb (_bgefg _f .Image ,_gcfe uint8 )*_f .Gray {_fage :=_bgefg .Bounds ();_faaeb :=_f .NewGray (_fage );var (_ecec _b .Color ;_bagef _b .Gray ;);for _adee :=0;_adee < _fage .Max .X ;
_adee ++{for _bgage :=0;_bgage < _fage .Max .Y ;_bgage ++{_ecec =_bgefg .At (_adee ,_bgage );_faaeb .Set (_adee ,_bgage ,_ecec );_bagef =_faaeb .GrayAt (_adee ,_bgage );_faaeb .SetGray (_adee ,_bgage ,_b .Gray {Y :_ecfd (_bagef .Y ,_gcfe )});};};return _faaeb ;
};func _begb (_gcg *Monochrome ,_ggcf ,_dfcd ,_cfee ,_bgcb int ,_gfca RasterOperator ){if _ggcf < 0{_cfee +=_ggcf ;_ggcf =0;};_ffcd :=_ggcf +_cfee -_gcg .Width ;if _ffcd > 0{_cfee -=_ffcd ;};if _dfcd < 0{_bgcb +=_dfcd ;_dfcd =0;};_abdc :=_dfcd +_bgcb -_gcg .Height ;
if _abdc > 0{_bgcb -=_abdc ;};if _cfee <=0||_bgcb <=0{return ;};if (_ggcf &7)==0{_bgfe (_gcg ,_ggcf ,_dfcd ,_cfee ,_bgcb ,_gfca );}else {_aedc (_gcg ,_ggcf ,_dfcd ,_cfee ,_bgcb ,_gfca );};};func ImgToBinary (i _f .Image ,threshold uint8 )*_f .Gray {switch _cecf :=i .(type ){case *_f .Gray :if _ggdce (_cecf ){return _cecf ;
};return _ggea (_cecf ,threshold );case *_f .Gray16 :return _agaf (_cecf ,threshold );default:return _gdeb (_cecf ,threshold );};};func (_dgfg *Gray16 )Histogram ()(_gcbc [256]int ){for _ebba :=0;_ebba < _dgfg .Width ;_ebba ++{for _abdd :=0;_abdd < _dgfg .Height ;
_abdd ++{_gcbc [_dgfg .GrayAt (_ebba ,_abdd ).Y ]++;};};return _gcbc ;};func _gaeb (_fgd ,_deg *Monochrome ,_geb []byte ,_gacf int )(_ddb error ){var (_fbbc ,_bgbe ,_bffc ,_beb ,_fdc ,_fbfg ,_fff ,_cda int ;_dea ,_babc uint32 ;_cebf ,_eab byte ;_fdg uint16 ;
);_edbg :=make ([]byte ,4);_dcg :=make ([]byte ,4);for _bffc =0;_bffc < _fgd .Height -1;_bffc ,_beb =_bffc +2,_beb +1{_fbbc =_bffc *_fgd .BytesPerLine ;_bgbe =_beb *_deg .BytesPerLine ;for _fdc ,_fbfg =0,0;_fdc < _gacf ;_fdc ,_fbfg =_fdc +4,_fbfg +1{for _fff =0;
_fff < 4;_fff ++{_cda =_fbbc +_fdc +_fff ;if _cda <=len (_fgd .Data )-1&&_cda < _fbbc +_fgd .BytesPerLine {_edbg [_fff ]=_fgd .Data [_cda ];}else {_edbg [_fff ]=0x00;};_cda =_fbbc +_fgd .BytesPerLine +_fdc +_fff ;if _cda <=len (_fgd .Data )-1&&_cda < _fbbc +(2*_fgd .BytesPerLine ){_dcg [_fff ]=_fgd .Data [_cda ];
}else {_dcg [_fff ]=0x00;};};_dea =_ef .BigEndian .Uint32 (_edbg );_babc =_ef .BigEndian .Uint32 (_dcg );_babc &=_dea ;_babc &=_babc <<1;_babc &=0xaaaaaaaa;_dea =_babc |(_babc <<7);_cebf =byte (_dea >>24);_eab =byte ((_dea >>8)&0xff);_cda =_bgbe +_fbfg ;
if _cda +1==len (_deg .Data )-1||_cda +1>=_bgbe +_deg .BytesPerLine {_deg .Data [_cda ]=_geb [_cebf ];if _ddb =_deg .setByte (_cda ,_geb [_cebf ]);_ddb !=nil {return _bd .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_cda );};}else {_fdg =(uint16 (_geb [_cebf ])<<8)|uint16 (_geb [_eab ]);
if _ddb =_deg .setTwoBytes (_cda ,_fdg );_ddb !=nil {return _bd .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_cda );
};_fbfg ++;};};};return nil ;};func (_fab *Monochrome )setGrayBit (_gbf ,_feea int ){_fab .Data [_gbf ]|=0x80>>uint (_feea &7)};func (_eefa *ImageBase )newAlpha (){_fdab :=BytesPerLine (_eefa .Width ,_eefa .BitsPerComponent ,1);_eefa .Alpha =make ([]byte ,_eefa .Height *_fdab );
};var _ Image =&Gray2 {};func (_bdcd *Gray2 )At (x ,y int )_b .Color {_adf ,_ :=_bdcd .ColorAt (x ,y );return _adf };func _babf (_gdcb _f .Image )(Image ,error ){if _abfg ,_cfcg :=_gdcb .(*Gray4 );_cfcg {return _abfg .Copy (),nil ;};_cbdd :=_gdcb .Bounds ();
_cgbd ,_fgfg :=NewImage (_cbdd .Max .X ,_cbdd .Max .Y ,4,1,nil ,nil ,nil );if _fgfg !=nil {return nil ,_fgfg ;};_eecd (_gdcb ,_cgbd ,_cbdd );return _cgbd ,nil ;};func (_eaa *Gray2 )ColorModel ()_b .Model {return Gray2Model };func _fbe (_egga Gray ,_fba nrgba64 ,_egc _f .Rectangle ){for _dec :=0;
_dec < _egc .Max .X ;_dec ++{for _aeace :=0;_aeace < _egc .Max .Y ;_aeace ++{_abdg :=_ddec (_fba .NRGBA64At (_dec ,_aeace ));_egga .SetGray (_dec ,_aeace ,_abdg );};};};func (_cgf *NRGBA32 )ColorAt (x ,y int )(_b .Color ,error ){return ColorAtNRGBA32 (x ,y ,_cgf .Width ,_cgf .Data ,_cgf .Alpha ,_cgf .Decode );
};func ColorAtGray2BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_b .Gray ,error ){_feef :=y *bytesPerLine +x >>2;if _feef >=len (data ){return _b .Gray {},_bd .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_eca :=data [_feef ]>>uint (6-(x &3)*2)&3;if len (decode )==2{_eca =uint8 (uint32 (LinearInterpolate (float64 (_eca ),0,3.0,decode [0],decode [1]))&3);};return _b .Gray {Y :_eca *85},nil ;};func (_ceac *NRGBA16 )At (x ,y int )_b .Color {_fffbb ,_ :=_ceac .ColorAt (x ,y );
return _fffbb };func (_facc *Monochrome )IsUnpadded ()bool {return (_facc .Width *_facc .Height )==len (_facc .Data )};var _ NRGBA =&NRGBA16 {};func (_aede *Monochrome )Scale (scale float64 )(*Monochrome ,error ){var _ffeg bool ;_cbb :=scale ;if scale < 1{_cbb =1/scale ;
_ffeg =true ;};_dbea :=NextPowerOf2 (uint (_cbb ));if InDelta (float64 (_dbea ),_cbb ,0.001){if _ffeg {return _aede .ReduceBinary (_cbb );};return _aede .ExpandBinary (int (_dbea ));};_edab :=int (_d .RoundToEven (float64 (_aede .Width )*scale ));_dcde :=int (_d .RoundToEven (float64 (_aede .Height )*scale ));
return _aede .ScaleLow (_edab ,_dcde );};func _accd ()(_eeg []byte ){_eeg =make ([]byte ,256);for _dcd :=0;_dcd < 256;_dcd ++{_gacfa :=byte (_dcd );_eeg [_gacfa ]=(_gacfa &0x01)|((_gacfa &0x04)>>1)|((_gacfa &0x10)>>2)|((_gacfa &0x40)>>3)|((_gacfa &0x02)<<3)|((_gacfa &0x08)<<2)|((_gacfa &0x20)<<1)|(_gacfa &0x80);
};return _eeg ;};func (_dbbg *Gray4 )Base ()*ImageBase {return &_dbbg .ImageBase };func (_ebfe *Monochrome )setBit (_gcd ,_fgae int ){_ebfe .Data [_gcd +(_fgae >>3)]|=0x80>>uint (_fgae &7);};var _ _f .Image =&Gray2 {};func _ccb (_bfc _f .Image )(Image ,error ){if _eec ,_ecf :=_bfc .(*CMYK32 );
_ecf {return _eec .Copy (),nil ;};_edbga :=_bfc .Bounds ();_fbbe ,_gce :=NewImage (_edbga .Max .X ,_edbga .Max .Y ,8,4,nil ,nil ,nil );if _gce !=nil {return nil ,_gce ;};switch _egag :=_bfc .(type ){case CMYK :_fag (_egag ,_fbbe .(CMYK ),_edbga );case Gray :_dde (_egag ,_fbbe .(CMYK ),_edbga );
case NRGBA :_bgfa (_egag ,_fbbe .(CMYK ),_edbga );case RGBA :_bec (_egag ,_fbbe .(CMYK ),_edbga );default:_dbdf (_bfc ,_fbbe ,_edbga );};return _fbbe ,nil ;};type Gray interface{GrayAt (_dfce ,_fee int )_b .Gray ;SetGray (_egg ,_aeee int ,_fced _b .Gray );
};func _ddc (_befc _f .Image )(Image ,error ){if _bcbe ,_ebdg :=_befc .(*Gray8 );_ebdg {return _bcbe .Copy (),nil ;};_cggc :=_befc .Bounds ();_gefg ,_faef :=NewImage (_cggc .Max .X ,_cggc .Max .Y ,8,1,nil ,nil ,nil );if _faef !=nil {return nil ,_faef ;
};_eecd (_befc ,_gefg ,_cggc );return _gefg ,nil ;};func (_gbfc *Gray2 )ColorAt (x ,y int )(_b .Color ,error ){return ColorAtGray2BPC (x ,y ,_gbfc .BytesPerLine ,_gbfc .Data ,_gbfc .Decode );};func (_dfdg *Gray8 )At (x ,y int )_b .Color {_cefb ,_ :=_dfdg .ColorAt (x ,y );
return _cefb };func (_adg *CMYK32 )At (x ,y int )_b .Color {_abca ,_ :=_adg .ColorAt (x ,y );return _abca };func (_dece *Gray4 )Copy ()Image {return &Gray4 {ImageBase :_dece .copy ()}};func _ecfd (_adda ,_cdbdc uint8 )uint8 {if _adda < _cdbdc {return 255;
};return 0;};func _ffaag (_fcc _b .Gray )_b .Gray {_gfac :=_fcc .Y >>6;_gfac |=_gfac <<2;_fcc .Y =_gfac |_gfac <<4;return _fcc ;};func (_beefc *Gray8 )Validate ()error {if len (_beefc .Data )!=_beefc .Height *_beefc .BytesPerLine {return ErrInvalidImage ;
};return nil ;};type ColorConverter interface{Convert (_ace _f .Image )(Image ,error );};var _ Image =&Monochrome {};type Gray2 struct{ImageBase };func (_aefdc *Gray16 )Bounds ()_f .Rectangle {return _f .Rectangle {Max :_f .Point {X :_aefdc .Width ,Y :_aefdc .Height }};
};func _geag (_aebe _b .Color )_b .Color {_gfaee :=_b .NRGBAModel .Convert (_aebe ).(_b .NRGBA );return _afdcg (_gfaee );};func _bddd (_febgd _f .Image ,_dedc Image ,_edad _f .Rectangle ){if _ccga ,_beed :=_febgd .(SMasker );_beed &&_ccga .HasAlpha (){_dedc .(SMasker ).MakeAlpha ();
};switch _eag :=_febgd .(type ){case Gray :_bbeca (_eag ,_dedc .(NRGBA ),_edad );case NRGBA :_fegbc (_eag ,_dedc .(NRGBA ),_edad );case *_f .NYCbCrA :_cafe (_eag ,_dedc .(NRGBA ),_edad );case CMYK :_feee (_eag ,_dedc .(NRGBA ),_edad );case RGBA :_gcee (_eag ,_dedc .(NRGBA ),_edad );
case nrgba64 :_efcb (_eag ,_dedc .(NRGBA ),_edad );default:_dbdf (_febgd ,_dedc ,_edad );};};func AutoThresholdTriangle (histogram [256]int )uint8 {var _eacg ,_aegff ,_ggga ,_agdd int ;for _fgfd :=0;_fgfd < len (histogram );_fgfd ++{if histogram [_fgfd ]> 0{_eacg =_fgfd ;
break ;};};if _eacg > 0{_eacg --;};for _cbfe :=255;_cbfe > 0;_cbfe --{if histogram [_cbfe ]> 0{_agdd =_cbfe ;break ;};};if _agdd < 255{_agdd ++;};for _feeab :=0;_feeab < 256;_feeab ++{if histogram [_feeab ]> _aegff {_ggga =_feeab ;_aegff =histogram [_feeab ];
};};var _gfda bool ;if (_ggga -_eacg )< (_agdd -_ggga ){_gfda =true ;var _fcdc int ;_fbc :=255;for _fcdc < _fbc {_fbgc :=histogram [_fcdc ];histogram [_fcdc ]=histogram [_fbc ];histogram [_fbc ]=_fbgc ;_fcdc ++;_fbc --;};_eacg =255-_agdd ;_ggga =255-_ggga ;
};if _eacg ==_ggga {return uint8 (_eacg );};_fbdc :=float64 (histogram [_ggga ]);_afad :=float64 (_eacg -_ggga );_cedd :=_d .Sqrt (_fbdc *_fbdc +_afad *_afad );_fbdc /=_cedd ;_afad /=_cedd ;_cedd =_fbdc *float64 (_eacg )+_afad *float64 (histogram [_eacg ]);
_fdgb :=_eacg ;var _bada float64 ;for _dade :=_eacg +1;_dade <=_ggga ;_dade ++{_dgdga :=_fbdc *float64 (_dade )+_afad *float64 (histogram [_dade ])-_cedd ;if _dgdga > _bada {_fdgb =_dade ;_bada =_dgdga ;};};_fdgb --;if _gfda {var _cbeg int ;_addd :=255;
for _cbeg < _addd {_gbeab :=histogram [_cbeg ];histogram [_cbeg ]=histogram [_addd ];histogram [_addd ]=_gbeab ;_cbeg ++;_addd --;};return uint8 (255-_fdgb );};return uint8 (_fdgb );};func (_ceaa *Monochrome )Validate ()error {if len (_ceaa .Data )!=_ceaa .Height *_ceaa .BytesPerLine {return ErrInvalidImage ;
};return nil ;};func (_eecb *NRGBA32 )Validate ()error {if len (_eecb .Data )!=3*_eecb .Width *_eecb .Height {return _g .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func _dgcf (){for _dgdd :=0;_dgdd < 256;_dgdd ++{_cdac [_dgdd ]=uint8 (_dgdd &0x1)+(uint8 (_dgdd >>1)&0x1)+(uint8 (_dgdd >>2)&0x1)+(uint8 (_dgdd >>3)&0x1)+(uint8 (_dgdd >>4)&0x1)+(uint8 (_dgdd >>5)&0x1)+(uint8 (_dgdd >>6)&0x1)+(uint8 (_dgdd >>7)&0x1);
};};func _fcabf (_daef uint8 )bool {if _daef ==0||_daef ==255{return true ;};return false ;};func (_baeb *NRGBA64 )Validate ()error {if len (_baeb .Data )!=3*2*_baeb .Width *_baeb .Height {return _g .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func (_gegc *Monochrome )ReduceBinary (factor float64 )(*Monochrome ,error ){_ebcb :=_aagc (uint (factor ));if !IsPowerOf2 (uint (factor )){_ebcb ++;};_egdd :=make ([]int ,_ebcb );for _fcee :=range _egdd {_egdd [_fcee ]=4;};_cef ,_dbcf :=_beef (_gegc ,_egdd ...);
if _dbcf !=nil {return nil ,_dbcf ;};return _cef ,nil ;};func (_daec *NRGBA32 )Copy ()Image {return &NRGBA32 {ImageBase :_daec .copy ()}};func (_eff colorConverter )Convert (src _f .Image )(Image ,error ){return _eff ._efda (src )};func (_ceff *NRGBA32 )Base ()*ImageBase {return &_ceff .ImageBase };
func _cged (_cefff _f .Image )(Image ,error ){if _dced ,_agbd :=_cefff .(*NRGBA32 );_agbd {return _dced .Copy (),nil ;};_aafd ,_dbbe ,_aae :=_gfbb (_cefff ,1);_cfdd ,_fafg :=NewImage (_aafd .Max .X ,_aafd .Max .Y ,8,3,nil ,_aae ,nil );if _fafg !=nil {return nil ,_fafg ;
};_bddd (_cefff ,_cfdd ,_aafd );if len (_aae )!=0&&!_dbbe {if _abe :=_gbed (_aae ,_cfdd );_abe !=nil {return nil ,_abe ;};};return _cfdd ,nil ;};func (_eeeb *ImageBase )setEightFullBytes (_bcfbb int ,_agb uint64 )error {if _bcfbb +7> len (_eeeb .Data )-1{return _g .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_eeeb .Data [_bcfbb ]=byte ((_agb &0xff00000000000000)>>56);_eeeb .Data [_bcfbb +1]=byte ((_agb &0xff000000000000)>>48);_eeeb .Data [_bcfbb +2]=byte ((_agb &0xff0000000000)>>40);_eeeb .Data [_bcfbb +3]=byte ((_agb &0xff00000000)>>32);_eeeb .Data [_bcfbb +4]=byte ((_agb &0xff000000)>>24);
_eeeb .Data [_bcfbb +5]=byte ((_agb &0xff0000)>>16);_eeeb .Data [_bcfbb +6]=byte ((_agb &0xff00)>>8);_eeeb .Data [_bcfbb +7]=byte (_agb &0xff);return nil ;};func (_gfag *Monochrome )clearBit (_febg ,_dfbbc int ){_gfag .Data [_febg ]&=^(0x80>>uint (_dfbbc &7))};
var _ _f .Image =&NRGBA32 {};func (_dbag *NRGBA16 )Copy ()Image {return &NRGBA16 {ImageBase :_dbag .copy ()}};type Gray4 struct{ImageBase };func ColorAtNRGBA16 (x ,y ,width ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_b .NRGBA ,error ){_deeag :=y *bytesPerLine +x *3/2;
if _deeag +1>=len (data ){return _b .NRGBA {},_cfec (x ,y );};const (_bffca =0xf;_fafaf =uint8 (0xff););_geaa :=_fafaf ;if alpha !=nil {_gbag :=y *BytesPerLine (width ,4,1);if _gbag < len (alpha ){if x %2==0{_geaa =(alpha [_gbag ]>>uint (4))&_bffca ;}else {_geaa =alpha [_gbag ]&_bffca ;
};_geaa |=_geaa <<4;};};var _gca ,_fabd ,_aafbb uint8 ;if x *3%2==0{_gca =(data [_deeag ]>>uint (4))&_bffca ;_fabd =data [_deeag ]&_bffca ;_aafbb =(data [_deeag +1]>>uint (4))&_bffca ;}else {_gca =data [_deeag ]&_bffca ;_fabd =(data [_deeag +1]>>uint (4))&_bffca ;
_aafbb =data [_deeag +1]&_bffca ;};if len (decode )==6{_gca =uint8 (uint32 (LinearInterpolate (float64 (_gca ),0,15,decode [0],decode [1]))&0xf);_fabd =uint8 (uint32 (LinearInterpolate (float64 (_fabd ),0,15,decode [2],decode [3]))&0xf);_aafbb =uint8 (uint32 (LinearInterpolate (float64 (_aafbb ),0,15,decode [4],decode [5]))&0xf);
};return _b .NRGBA {R :(_gca <<4)|(_gca &0xf),G :(_fabd <<4)|(_fabd &0xf),B :(_aafbb <<4)|(_aafbb &0xf),A :_geaa },nil ;};func _cgc (_bbee _f .Image )(Image ,error ){if _dgabf ,_eegdf :=_bbee .(*NRGBA16 );_eegdf {return _dgabf .Copy (),nil ;};_dggaa :=_bbee .Bounds ();
_dafd ,_bdb :=NewImage (_dggaa .Max .X ,_dggaa .Max .Y ,4,3,nil ,nil ,nil );if _bdb !=nil {return nil ,_bdb ;};_bddd (_bbee ,_dafd ,_dggaa );return _dafd ,nil ;};func _ccfa (_becf Gray ,_aegcc NRGBA ,_eegd _f .Rectangle ){for _dee :=0;_dee < _eegd .Max .X ;
_dee ++{for _dgaf :=0;_dgaf < _eegd .Max .Y ;_dgaf ++{_edec :=_dcdd (_aegcc .NRGBAAt (_dee ,_dgaf ));_becf .SetGray (_dee ,_dgaf ,_edec );};};};var (_dbeb =[]byte {0x00,0x80,0xC0,0xE0,0xF0,0xF8,0xFC,0xFE,0xFF};_fegc =[]byte {0x00,0x01,0x03,0x07,0x0F,0x1F,0x3F,0x7F,0xFF};
);func _fegbc (_eeda ,_cfga NRGBA ,_gaaa _f .Rectangle ){for _dfcg :=0;_dfcg < _gaaa .Max .X ;_dfcg ++{for _dcad :=0;_dcad < _gaaa .Max .Y ;_dcad ++{_cfga .SetNRGBA (_dfcg ,_dcad ,_eeda .NRGBAAt (_dfcg ,_dcad ));};};};func _cdc (_ab *Monochrome ,_cdg int ,_ff []uint )(*Monochrome ,error ){_efa :=_cdg *_ab .Width ;
_ae :=_cdg *_ab .Height ;_gb :=_edbb (_efa ,_ae );for _bc ,_gg :=range _ff {var _cg error ;switch _gg {case 2:_cg =_gd (_gb ,_ab );case 4:_cg =_ec (_gb ,_ab );case 8:_cg =_aed (_gb ,_ab );};if _cg !=nil {return nil ,_cg ;};if _bc !=len (_ff )-1{_ab =_gb .copy ();
};};return _gb ,nil ;};func _dgcd (_bfb ,_cabd Gray ,_eacc _f .Rectangle ){for _befe :=0;_befe < _eacc .Max .X ;_befe ++{for _cdbe :=0;_cdbe < _eacc .Max .Y ;_cdbe ++{_cabd .SetGray (_befe ,_cdbe ,_bfb .GrayAt (_befe ,_cdbe ));};};};func (_ceae *NRGBA16 )NRGBAAt (x ,y int )_b .NRGBA {_eeec ,_ :=ColorAtNRGBA16 (x ,y ,_ceae .Width ,_ceae .BytesPerLine ,_ceae .Data ,_ceae .Alpha ,_ceae .Decode );
return _eeec ;};func _ddec (_ccfe _b .NRGBA64 )_b .Gray {var _bfcf _b .NRGBA64 ;if _ccfe ==_bfcf {return _b .Gray {Y :0xff};};_ggc ,_afee ,_efdb ,_ :=_ccfe .RGBA ();_gaec :=(19595*_ggc +38470*_afee +7471*_efdb +1<<15)>>24;return _b .Gray {Y :uint8 (_gaec )};
};func (_ffg *Gray8 )Copy ()Image {return &Gray8 {ImageBase :_ffg .copy ()}};func InDelta (expected ,current ,delta float64 )bool {_ffgd :=expected -current ;if _ffgd <=-delta ||_ffgd >=delta {return false ;};return true ;};func _dbb (_gadd _b .RGBA )_b .CMYK {_bagg ,_aeae ,_adgb ,_bcd :=_b .RGBToCMYK (_gadd .R ,_gadd .G ,_gadd .B );
return _b .CMYK {C :_bagg ,M :_aeae ,Y :_adgb ,K :_bcd };};var _ Gray =&Gray2 {};var _ Image =&NRGBA32 {};func (_adgc *Gray4 )setGray (_fdgd int ,_deed int ,_gfab _b .Gray ){_ccee :=_deed *_adgc .BytesPerLine ;_dca :=_ccee +(_fdgd >>1);if _dca >=len (_adgc .Data ){return ;
};_baae :=_gfab .Y >>4;_adgc .Data [_dca ]=(_adgc .Data [_dca ]&(^(0xf0>>uint (4*(_fdgd &1)))))|(_baae <<uint (4-4*(_fdgd &1)));};const (PixSrc RasterOperator =0xc;PixDst RasterOperator =0xa;PixNotSrc RasterOperator =0x3;PixNotDst RasterOperator =0x5;PixClr RasterOperator =0x0;
PixSet RasterOperator =0xf;PixSrcOrDst RasterOperator =0xe;PixSrcAndDst RasterOperator =0x8;PixSrcXorDst RasterOperator =0x6;PixNotSrcOrDst RasterOperator =0xb;PixNotSrcAndDst RasterOperator =0x2;PixSrcOrNotDst RasterOperator =0xd;PixSrcAndNotDst RasterOperator =0x4;
PixNotPixSrcOrDst RasterOperator =0x1;PixNotPixSrcAndDst RasterOperator =0x7;PixNotPixSrcXorDst RasterOperator =0x9;PixPaint =PixSrcOrDst ;PixSubtract =PixNotSrcAndDst ;PixMask =PixSrcAndDst ;);func (_abbg *Gray2 )Base ()*ImageBase {return &_abbg .ImageBase };
func (_daa *Monochrome )AddPadding ()(_effb error ){if _bbc :=((_daa .Width *_daa .Height )+7)>>3;len (_daa .Data )< _bbc {return _bd .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064a\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002e\u0020\u0054\u0068\u0065\u0020\u0064\u0061t\u0061\u0020s\u0068\u006fu\u006c\u0064\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0020\u0061\u0074 l\u0065\u0061\u0073\u0074\u003a\u0020\u0027\u0025\u0064'\u0020\u0062\u0079\u0074\u0065\u0073",len (_daa .Data ),_bbc );
};_febe :=_daa .Width %8;if _febe ==0{return nil ;};_bbcg :=_daa .Width /8;_efe :=_c .NewReader (_daa .Data );_gga :=make ([]byte ,_daa .Height *_daa .BytesPerLine );_eabe :=_c .NewWriterMSB (_gga );_eacb :=make ([]byte ,_bbcg );var (_bfa int ;_ddeg uint64 ;
);for _bfa =0;_bfa < _daa .Height ;_bfa ++{if _ ,_effb =_efe .Read (_eacb );_effb !=nil {return _effb ;};if _ ,_effb =_eabe .Write (_eacb );_effb !=nil {return _effb ;};if _ddeg ,_effb =_efe .ReadBits (byte (_febe ));_effb !=nil {return _effb ;};if _effb =_eabe .WriteByte (byte (_ddeg )<<uint (8-_febe ));
_effb !=nil {return _effb ;};};_daa .Data =_eabe .Data ();return nil ;};func _cf (_baa *Monochrome ,_aeb ,_efag int )(*Monochrome ,error ){if _baa ==nil {return nil ,_g .New ("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064");
};if _aeb <=0||_efag <=0{return nil ,_g .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0073\u0063\u0061l\u0065\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020<\u003d\u0020\u0030");};if _aeb ==_efag {if _aeb ==1{return _baa .copy (),nil ;
};if _aeb ==2||_aeb ==4||_aeb ==8{_ge ,_gbe :=_dc (_baa ,_aeb );if _gbe !=nil {return nil ,_gbe ;};return _ge ,nil ;};};_be :=_aeb *_baa .Width ;_dbc :=_efag *_baa .Height ;_bgf :=_edbb (_be ,_dbc );_abb :=_bgf .BytesPerLine ;var (_aeg ,_cab ,_aea ,_eb ,_gdg int ;
_dac byte ;_gab error ;);for _cab =0;_cab < _baa .Height ;_cab ++{_aeg =_efag *_cab *_abb ;for _aea =0;_aea < _baa .Width ;_aea ++{if _ce :=_baa .getBitAt (_aea ,_cab );_ce {_gdg =_aeb *_aea ;for _eb =0;_eb < _aeb ;_eb ++{_bgf .setIndexedBit (_aeg *8+_gdg +_eb );
};};};for _eb =1;_eb < _efag ;_eb ++{_gaa :=_aeg +_eb *_abb ;for _acc :=0;_acc < _abb ;_acc ++{if _dac ,_gab =_bgf .getByte (_aeg +_acc );_gab !=nil {return nil ,_gab ;};if _gab =_bgf .setByte (_gaa +_acc ,_dac );_gab !=nil {return nil ,_gab ;};};};};return _bgf ,nil ;
};func _bec (_dba RGBA ,_bgbg CMYK ,_ade _f .Rectangle ){for _bcfe :=0;_bcfe < _ade .Max .X ;_bcfe ++{for _bcfec :=0;_bcfec < _ade .Max .Y ;_bcfec ++{_gea :=_dba .RGBAAt (_bcfe ,_bcfec );_bgbg .SetCMYK (_bcfe ,_bcfec ,_dbb (_gea ));};};};func _ebd (_ebc int )[]uint {var _dgg []uint ;
_ee :=_ebc ;_bda :=_ee /8;if _bda !=0{for _bee :=0;_bee < _bda ;_bee ++{_dgg =append (_dgg ,8);};_ffe :=_ee %8;_ee =0;if _ffe !=0{_ee =_ffe ;};};_bcf :=_ee /4;if _bcf !=0{for _faa :=0;_faa < _bcf ;_faa ++{_dgg =append (_dgg ,4);};_bge :=_ee %4;_ee =0;if _bge !=0{_ee =_bge ;
};};_def :=_ee /2;if _def !=0{for _gdc :=0;_gdc < _def ;_gdc ++{_dgg =append (_dgg ,2);};};return _dgg ;};func (_cfa *Gray16 )Base ()*ImageBase {return &_cfa .ImageBase };func (_bfca *Gray8 )ColorModel ()_b .Model {return _b .GrayModel };func (_fcgb *NRGBA64 )SetNRGBA64 (x ,y int ,c _b .NRGBA64 ){_agcg :=(y *_fcgb .Width +x )*2;
_cegd :=_agcg *3;if _cegd +5>=len (_fcgb .Data ){return ;};_fcgb .setNRGBA64 (_cegd ,c ,_agcg );};func (_cdd *ImageBase )GetAlpha ()[]byte {return _cdd .Alpha };func (_gdbc *Monochrome )At (x ,y int )_b .Color {_fbec ,_ :=_gdbc .ColorAt (x ,y );return _fbec };
func NewImageBase (width int ,height int ,bitsPerComponent int ,colorComponents int ,data []byte ,alpha []byte ,decode []float64 )ImageBase {_gfd :=ImageBase {Width :width ,Height :height ,BitsPerComponent :bitsPerComponent ,ColorComponents :colorComponents ,Data :data ,Alpha :alpha ,Decode :decode ,BytesPerLine :BytesPerLine (width ,bitsPerComponent ,colorComponents )};
if data ==nil {_gfd .Data =make ([]byte ,height *_gfd .BytesPerLine );};return _gfd ;};func _cfec (_gaee int ,_eafd int )error {return _bd .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",_gaee ,_eafd );
};func (_agc *Monochrome )getBit (_efac ,_fbaf int )uint8 {return _agc .Data [_efac +(_fbaf >>3)]>>uint (7-(_fbaf &7))&1;};func (_beda *Gray16 )At (x ,y int )_b .Color {_aecf ,_ :=_beda .ColorAt (x ,y );return _aecf };func _beef (_bf *Monochrome ,_fe ...int )(_cbg *Monochrome ,_bff error ){if _bf ==nil {return nil ,_g .New ("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d");
};if len (_fe )==0{return nil ,_g .New ("\u0074h\u0065\u0072e\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0061\u0074 \u006c\u0065\u0061\u0073\u0074\u0020o\u006e\u0065\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u006f\u0066 \u0072\u0065\u0064\u0075\u0063\u0074\u0069\u006f\u006e");
};_dgc :=_accd ();_cbg =_bf ;for _ ,_ggd :=range _fe {if _ggd <=0{break ;};_cbg ,_bff =_aab (_cbg ,_ggd ,_dgc );if _bff !=nil {return nil ,_bff ;};};return _cbg ,nil ;};func (_debd *Monochrome )RasterOperation (dx ,dy ,dw ,dh int ,op RasterOperator ,src *Monochrome ,sx ,sy int )error {return _fdeb (_debd ,dx ,dy ,dw ,dh ,op ,src ,sx ,sy );
};func _cbafb (_deceg *Monochrome ,_dafg ,_bgbfe ,_agcd ,_cabde int ,_fcea RasterOperator ,_fddc *Monochrome ,_degf ,_dgda int )error {var (_bbaa bool ;_afdb bool ;_gdbgg byte ;_egec int ;_eed int ;_dcf int ;_fge int ;_bac bool ;_edfa int ;_afca int ;_dbcc int ;
_daeg bool ;_ddgd byte ;_cbcb int ;_cecgg int ;_ffcc int ;_ecfc byte ;_faae int ;_ddcd int ;_fdca uint ;_dge uint ;_dcfa byte ;_bgffd shift ;_gfae bool ;_efdf bool ;_bfd ,_cbda int ;);if _degf &7!=0{_ddcd =8-(_degf &7);};if _dafg &7!=0{_eed =8-(_dafg &7);
};if _ddcd ==0&&_eed ==0{_dcfa =_fegc [0];}else {if _eed > _ddcd {_fdca =uint (_eed -_ddcd );}else {_fdca =uint (8-(_ddcd -_eed ));};_dge =8-_fdca ;_dcfa =_fegc [_fdca ];};if (_dafg &7)!=0{_bbaa =true ;_egec =8-(_dafg &7);_gdbgg =_fegc [_egec ];_dcf =_deceg .BytesPerLine *_bgbfe +(_dafg >>3);
_fge =_fddc .BytesPerLine *_dgda +(_degf >>3);_faae =8-(_degf &7);if _egec > _faae {_bgffd =_egbgg ;if _agcd >=_ddcd {_gfae =true ;};}else {_bgffd =_ecga ;};};if _agcd < _egec {_afdb =true ;_gdbgg &=_dbeb [8-_egec +_agcd ];};if !_afdb {_edfa =(_agcd -_egec )>>3;
if _edfa !=0{_bac =true ;_afca =_deceg .BytesPerLine *_bgbfe +((_dafg +_eed )>>3);_dbcc =_fddc .BytesPerLine *_dgda +((_degf +_eed )>>3);};};_cbcb =(_dafg +_agcd )&7;if !(_afdb ||_cbcb ==0){_daeg =true ;_ddgd =_dbeb [_cbcb ];_cecgg =_deceg .BytesPerLine *_bgbfe +((_dafg +_eed )>>3)+_edfa ;
_ffcc =_fddc .BytesPerLine *_dgda +((_degf +_eed )>>3)+_edfa ;if _cbcb > int (_dge ){_efdf =true ;};};switch _fcea {case PixSrc :if _bbaa {for _bfd =0;_bfd < _cabde ;_bfd ++{if _bgffd ==_egbgg {_ecfc =_fddc .Data [_fge ]<<_fdca ;if _gfae {_ecfc =_cdgdg (_ecfc ,_fddc .Data [_fge +1]>>_dge ,_dcfa );
};}else {_ecfc =_fddc .Data [_fge ]>>_dge ;};_deceg .Data [_dcf ]=_cdgdg (_deceg .Data [_dcf ],_ecfc ,_gdbgg );_dcf +=_deceg .BytesPerLine ;_fge +=_fddc .BytesPerLine ;};};if _bac {for _bfd =0;_bfd < _cabde ;_bfd ++{for _cbda =0;_cbda < _edfa ;_cbda ++{_ecfc =_cdgdg (_fddc .Data [_dbcc +_cbda ]<<_fdca ,_fddc .Data [_dbcc +_cbda +1]>>_dge ,_dcfa );
_deceg .Data [_afca +_cbda ]=_ecfc ;};_afca +=_deceg .BytesPerLine ;_dbcc +=_fddc .BytesPerLine ;};};if _daeg {for _bfd =0;_bfd < _cabde ;_bfd ++{_ecfc =_fddc .Data [_ffcc ]<<_fdca ;if _efdf {_ecfc =_cdgdg (_ecfc ,_fddc .Data [_ffcc +1]>>_dge ,_dcfa );
};_deceg .Data [_cecgg ]=_cdgdg (_deceg .Data [_cecgg ],_ecfc ,_ddgd );_cecgg +=_deceg .BytesPerLine ;_ffcc +=_fddc .BytesPerLine ;};};case PixNotSrc :if _bbaa {for _bfd =0;_bfd < _cabde ;_bfd ++{if _bgffd ==_egbgg {_ecfc =_fddc .Data [_fge ]<<_fdca ;if _gfae {_ecfc =_cdgdg (_ecfc ,_fddc .Data [_fge +1]>>_dge ,_dcfa );
};}else {_ecfc =_fddc .Data [_fge ]>>_dge ;};_deceg .Data [_dcf ]=_cdgdg (_deceg .Data [_dcf ],^_ecfc ,_gdbgg );_dcf +=_deceg .BytesPerLine ;_fge +=_fddc .BytesPerLine ;};};if _bac {for _bfd =0;_bfd < _cabde ;_bfd ++{for _cbda =0;_cbda < _edfa ;_cbda ++{_ecfc =_cdgdg (_fddc .Data [_dbcc +_cbda ]<<_fdca ,_fddc .Data [_dbcc +_cbda +1]>>_dge ,_dcfa );
_deceg .Data [_afca +_cbda ]=^_ecfc ;};_afca +=_deceg .BytesPerLine ;_dbcc +=_fddc .BytesPerLine ;};};if _daeg {for _bfd =0;_bfd < _cabde ;_bfd ++{_ecfc =_fddc .Data [_ffcc ]<<_fdca ;if _efdf {_ecfc =_cdgdg (_ecfc ,_fddc .Data [_ffcc +1]>>_dge ,_dcfa );
};_deceg .Data [_cecgg ]=_cdgdg (_deceg .Data [_cecgg ],^_ecfc ,_ddgd );_cecgg +=_deceg .BytesPerLine ;_ffcc +=_fddc .BytesPerLine ;};};case PixSrcOrDst :if _bbaa {for _bfd =0;_bfd < _cabde ;_bfd ++{if _bgffd ==_egbgg {_ecfc =_fddc .Data [_fge ]<<_fdca ;
if _gfae {_ecfc =_cdgdg (_ecfc ,_fddc .Data [_fge +1]>>_dge ,_dcfa );};}else {_ecfc =_fddc .Data [_fge ]>>_dge ;};_deceg .Data [_dcf ]=_cdgdg (_deceg .Data [_dcf ],_ecfc |_deceg .Data [_dcf ],_gdbgg );_dcf +=_deceg .BytesPerLine ;_fge +=_fddc .BytesPerLine ;
};};if _bac {for _bfd =0;_bfd < _cabde ;_bfd ++{for _cbda =0;_cbda < _edfa ;_cbda ++{_ecfc =_cdgdg (_fddc .Data [_dbcc +_cbda ]<<_fdca ,_fddc .Data [_dbcc +_cbda +1]>>_dge ,_dcfa );_deceg .Data [_afca +_cbda ]|=_ecfc ;};_afca +=_deceg .BytesPerLine ;_dbcc +=_fddc .BytesPerLine ;
};};if _daeg {for _bfd =0;_bfd < _cabde ;_bfd ++{_ecfc =_fddc .Data [_ffcc ]<<_fdca ;if _efdf {_ecfc =_cdgdg (_ecfc ,_fddc .Data [_ffcc +1]>>_dge ,_dcfa );};_deceg .Data [_cecgg ]=_cdgdg (_deceg .Data [_cecgg ],_ecfc |_deceg .Data [_cecgg ],_ddgd );_cecgg +=_deceg .BytesPerLine ;
_ffcc +=_fddc .BytesPerLine ;};};case PixSrcAndDst :if _bbaa {for _bfd =0;_bfd < _cabde ;_bfd ++{if _bgffd ==_egbgg {_ecfc =_fddc .Data [_fge ]<<_fdca ;if _gfae {_ecfc =_cdgdg (_ecfc ,_fddc .Data [_fge +1]>>_dge ,_dcfa );};}else {_ecfc =_fddc .Data [_fge ]>>_dge ;
};_deceg .Data [_dcf ]=_cdgdg (_deceg .Data [_dcf ],_ecfc &_deceg .Data [_dcf ],_gdbgg );_dcf +=_deceg .BytesPerLine ;_fge +=_fddc .BytesPerLine ;};};if _bac {for _bfd =0;_bfd < _cabde ;_bfd ++{for _cbda =0;_cbda < _edfa ;_cbda ++{_ecfc =_cdgdg (_fddc .Data [_dbcc +_cbda ]<<_fdca ,_fddc .Data [_dbcc +_cbda +1]>>_dge ,_dcfa );
_deceg .Data [_afca +_cbda ]&=_ecfc ;};_afca +=_deceg .BytesPerLine ;_dbcc +=_fddc .BytesPerLine ;};};if _daeg {for _bfd =0;_bfd < _cabde ;_bfd ++{_ecfc =_fddc .Data [_ffcc ]<<_fdca ;if _efdf {_ecfc =_cdgdg (_ecfc ,_fddc .Data [_ffcc +1]>>_dge ,_dcfa );
};_deceg .Data [_cecgg ]=_cdgdg (_deceg .Data [_cecgg ],_ecfc &_deceg .Data [_cecgg ],_ddgd );_cecgg +=_deceg .BytesPerLine ;_ffcc +=_fddc .BytesPerLine ;};};case PixSrcXorDst :if _bbaa {for _bfd =0;_bfd < _cabde ;_bfd ++{if _bgffd ==_egbgg {_ecfc =_fddc .Data [_fge ]<<_fdca ;
if _gfae {_ecfc =_cdgdg (_ecfc ,_fddc .Data [_fge +1]>>_dge ,_dcfa );};}else {_ecfc =_fddc .Data [_fge ]>>_dge ;};_deceg .Data [_dcf ]=_cdgdg (_deceg .Data [_dcf ],_ecfc ^_deceg .Data [_dcf ],_gdbgg );_dcf +=_deceg .BytesPerLine ;_fge +=_fddc .BytesPerLine ;
};};if _bac {for _bfd =0;_bfd < _cabde ;_bfd ++{for _cbda =0;_cbda < _edfa ;_cbda ++{_ecfc =_cdgdg (_fddc .Data [_dbcc +_cbda ]<<_fdca ,_fddc .Data [_dbcc +_cbda +1]>>_dge ,_dcfa );_deceg .Data [_afca +_cbda ]^=_ecfc ;};_afca +=_deceg .BytesPerLine ;_dbcc +=_fddc .BytesPerLine ;
};};if _daeg {for _bfd =0;_bfd < _cabde ;_bfd ++{_ecfc =_fddc .Data [_ffcc ]<<_fdca ;if _efdf {_ecfc =_cdgdg (_ecfc ,_fddc .Data [_ffcc +1]>>_dge ,_dcfa );};_deceg .Data [_cecgg ]=_cdgdg (_deceg .Data [_cecgg ],_ecfc ^_deceg .Data [_cecgg ],_ddgd );_cecgg +=_deceg .BytesPerLine ;
_ffcc +=_fddc .BytesPerLine ;};};case PixNotSrcOrDst :if _bbaa {for _bfd =0;_bfd < _cabde ;_bfd ++{if _bgffd ==_egbgg {_ecfc =_fddc .Data [_fge ]<<_fdca ;if _gfae {_ecfc =_cdgdg (_ecfc ,_fddc .Data [_fge +1]>>_dge ,_dcfa );};}else {_ecfc =_fddc .Data [_fge ]>>_dge ;
};_deceg .Data [_dcf ]=_cdgdg (_deceg .Data [_dcf ],^_ecfc |_deceg .Data [_dcf ],_gdbgg );_dcf +=_deceg .BytesPerLine ;_fge +=_fddc .BytesPerLine ;};};if _bac {for _bfd =0;_bfd < _cabde ;_bfd ++{for _cbda =0;_cbda < _edfa ;_cbda ++{_ecfc =_cdgdg (_fddc .Data [_dbcc +_cbda ]<<_fdca ,_fddc .Data [_dbcc +_cbda +1]>>_dge ,_dcfa );
_deceg .Data [_afca +_cbda ]|=^_ecfc ;};_afca +=_deceg .BytesPerLine ;_dbcc +=_fddc .BytesPerLine ;};};if _daeg {for _bfd =0;_bfd < _cabde ;_bfd ++{_ecfc =_fddc .Data [_ffcc ]<<_fdca ;if _efdf {_ecfc =_cdgdg (_ecfc ,_fddc .Data [_ffcc +1]>>_dge ,_dcfa );
};_deceg .Data [_cecgg ]=_cdgdg (_deceg .Data [_cecgg ],^_ecfc |_deceg .Data [_cecgg ],_ddgd );_cecgg +=_deceg .BytesPerLine ;_ffcc +=_fddc .BytesPerLine ;};};case PixNotSrcAndDst :if _bbaa {for _bfd =0;_bfd < _cabde ;_bfd ++{if _bgffd ==_egbgg {_ecfc =_fddc .Data [_fge ]<<_fdca ;
if _gfae {_ecfc =_cdgdg (_ecfc ,_fddc .Data [_fge +1]>>_dge ,_dcfa );};}else {_ecfc =_fddc .Data [_fge ]>>_dge ;};_deceg .Data [_dcf ]=_cdgdg (_deceg .Data [_dcf ],^_ecfc &_deceg .Data [_dcf ],_gdbgg );_dcf +=_deceg .BytesPerLine ;_fge +=_fddc .BytesPerLine ;
};};if _bac {for _bfd =0;_bfd < _cabde ;_bfd ++{for _cbda =0;_cbda < _edfa ;_cbda ++{_ecfc =_cdgdg (_fddc .Data [_dbcc +_cbda ]<<_fdca ,_fddc .Data [_dbcc +_cbda +1]>>_dge ,_dcfa );_deceg .Data [_afca +_cbda ]&=^_ecfc ;};_afca +=_deceg .BytesPerLine ;_dbcc +=_fddc .BytesPerLine ;
};};if _daeg {for _bfd =0;_bfd < _cabde ;_bfd ++{_ecfc =_fddc .Data [_ffcc ]<<_fdca ;if _efdf {_ecfc =_cdgdg (_ecfc ,_fddc .Data [_ffcc +1]>>_dge ,_dcfa );};_deceg .Data [_cecgg ]=_cdgdg (_deceg .Data [_cecgg ],^_ecfc &_deceg .Data [_cecgg ],_ddgd );_cecgg +=_deceg .BytesPerLine ;
_ffcc +=_fddc .BytesPerLine ;};};case PixSrcOrNotDst :if _bbaa {for _bfd =0;_bfd < _cabde ;_bfd ++{if _bgffd ==_egbgg {_ecfc =_fddc .Data [_fge ]<<_fdca ;if _gfae {_ecfc =_cdgdg (_ecfc ,_fddc .Data [_fge +1]>>_dge ,_dcfa );};}else {_ecfc =_fddc .Data [_fge ]>>_dge ;
};_deceg .Data [_dcf ]=_cdgdg (_deceg .Data [_dcf ],_ecfc |^_deceg .Data [_dcf ],_gdbgg );_dcf +=_deceg .BytesPerLine ;_fge +=_fddc .BytesPerLine ;};};if _bac {for _bfd =0;_bfd < _cabde ;_bfd ++{for _cbda =0;_cbda < _edfa ;_cbda ++{_ecfc =_cdgdg (_fddc .Data [_dbcc +_cbda ]<<_fdca ,_fddc .Data [_dbcc +_cbda +1]>>_dge ,_dcfa );
_deceg .Data [_afca +_cbda ]=_ecfc |^_deceg .Data [_afca +_cbda ];};_afca +=_deceg .BytesPerLine ;_dbcc +=_fddc .BytesPerLine ;};};if _daeg {for _bfd =0;_bfd < _cabde ;_bfd ++{_ecfc =_fddc .Data [_ffcc ]<<_fdca ;if _efdf {_ecfc =_cdgdg (_ecfc ,_fddc .Data [_ffcc +1]>>_dge ,_dcfa );
};_deceg .Data [_cecgg ]=_cdgdg (_deceg .Data [_cecgg ],_ecfc |^_deceg .Data [_cecgg ],_ddgd );_cecgg +=_deceg .BytesPerLine ;_ffcc +=_fddc .BytesPerLine ;};};case PixSrcAndNotDst :if _bbaa {for _bfd =0;_bfd < _cabde ;_bfd ++{if _bgffd ==_egbgg {_ecfc =_fddc .Data [_fge ]<<_fdca ;
if _gfae {_ecfc =_cdgdg (_ecfc ,_fddc .Data [_fge +1]>>_dge ,_dcfa );};}else {_ecfc =_fddc .Data [_fge ]>>_dge ;};_deceg .Data [_dcf ]=_cdgdg (_deceg .Data [_dcf ],_ecfc &^_deceg .Data [_dcf ],_gdbgg );_dcf +=_deceg .BytesPerLine ;_fge +=_fddc .BytesPerLine ;
};};if _bac {for _bfd =0;_bfd < _cabde ;_bfd ++{for _cbda =0;_cbda < _edfa ;_cbda ++{_ecfc =_cdgdg (_fddc .Data [_dbcc +_cbda ]<<_fdca ,_fddc .Data [_dbcc +_cbda +1]>>_dge ,_dcfa );_deceg .Data [_afca +_cbda ]=_ecfc &^_deceg .Data [_afca +_cbda ];};_afca +=_deceg .BytesPerLine ;
_dbcc +=_fddc .BytesPerLine ;};};if _daeg {for _bfd =0;_bfd < _cabde ;_bfd ++{_ecfc =_fddc .Data [_ffcc ]<<_fdca ;if _efdf {_ecfc =_cdgdg (_ecfc ,_fddc .Data [_ffcc +1]>>_dge ,_dcfa );};_deceg .Data [_cecgg ]=_cdgdg (_deceg .Data [_cecgg ],_ecfc &^_deceg .Data [_cecgg ],_ddgd );
_cecgg +=_deceg .BytesPerLine ;_ffcc +=_fddc .BytesPerLine ;};};case PixNotPixSrcOrDst :if _bbaa {for _bfd =0;_bfd < _cabde ;_bfd ++{if _bgffd ==_egbgg {_ecfc =_fddc .Data [_fge ]<<_fdca ;if _gfae {_ecfc =_cdgdg (_ecfc ,_fddc .Data [_fge +1]>>_dge ,_dcfa );
};}else {_ecfc =_fddc .Data [_fge ]>>_dge ;};_deceg .Data [_dcf ]=_cdgdg (_deceg .Data [_dcf ],^(_ecfc |_deceg .Data [_dcf ]),_gdbgg );_dcf +=_deceg .BytesPerLine ;_fge +=_fddc .BytesPerLine ;};};if _bac {for _bfd =0;_bfd < _cabde ;_bfd ++{for _cbda =0;
_cbda < _edfa ;_cbda ++{_ecfc =_cdgdg (_fddc .Data [_dbcc +_cbda ]<<_fdca ,_fddc .Data [_dbcc +_cbda +1]>>_dge ,_dcfa );_deceg .Data [_afca +_cbda ]=^(_ecfc |_deceg .Data [_afca +_cbda ]);};_afca +=_deceg .BytesPerLine ;_dbcc +=_fddc .BytesPerLine ;};};
if _daeg {for _bfd =0;_bfd < _cabde ;_bfd ++{_ecfc =_fddc .Data [_ffcc ]<<_fdca ;if _efdf {_ecfc =_cdgdg (_ecfc ,_fddc .Data [_ffcc +1]>>_dge ,_dcfa );};_deceg .Data [_cecgg ]=_cdgdg (_deceg .Data [_cecgg ],^(_ecfc |_deceg .Data [_cecgg ]),_ddgd );_cecgg +=_deceg .BytesPerLine ;
_ffcc +=_fddc .BytesPerLine ;};};case PixNotPixSrcAndDst :if _bbaa {for _bfd =0;_bfd < _cabde ;_bfd ++{if _bgffd ==_egbgg {_ecfc =_fddc .Data [_fge ]<<_fdca ;if _gfae {_ecfc =_cdgdg (_ecfc ,_fddc .Data [_fge +1]>>_dge ,_dcfa );};}else {_ecfc =_fddc .Data [_fge ]>>_dge ;
};_deceg .Data [_dcf ]=_cdgdg (_deceg .Data [_dcf ],^(_ecfc &_deceg .Data [_dcf ]),_gdbgg );_dcf +=_deceg .BytesPerLine ;_fge +=_fddc .BytesPerLine ;};};if _bac {for _bfd =0;_bfd < _cabde ;_bfd ++{for _cbda =0;_cbda < _edfa ;_cbda ++{_ecfc =_cdgdg (_fddc .Data [_dbcc +_cbda ]<<_fdca ,_fddc .Data [_dbcc +_cbda +1]>>_dge ,_dcfa );
_deceg .Data [_afca +_cbda ]=^(_ecfc &_deceg .Data [_afca +_cbda ]);};_afca +=_deceg .BytesPerLine ;_dbcc +=_fddc .BytesPerLine ;};};if _daeg {for _bfd =0;_bfd < _cabde ;_bfd ++{_ecfc =_fddc .Data [_ffcc ]<<_fdca ;if _efdf {_ecfc =_cdgdg (_ecfc ,_fddc .Data [_ffcc +1]>>_dge ,_dcfa );
};_deceg .Data [_cecgg ]=_cdgdg (_deceg .Data [_cecgg ],^(_ecfc &_deceg .Data [_cecgg ]),_ddgd );_cecgg +=_deceg .BytesPerLine ;_ffcc +=_fddc .BytesPerLine ;};};case PixNotPixSrcXorDst :if _bbaa {for _bfd =0;_bfd < _cabde ;_bfd ++{if _bgffd ==_egbgg {_ecfc =_fddc .Data [_fge ]<<_fdca ;
if _gfae {_ecfc =_cdgdg (_ecfc ,_fddc .Data [_fge +1]>>_dge ,_dcfa );};}else {_ecfc =_fddc .Data [_fge ]>>_dge ;};_deceg .Data [_dcf ]=_cdgdg (_deceg .Data [_dcf ],^(_ecfc ^_deceg .Data [_dcf ]),_gdbgg );_dcf +=_deceg .BytesPerLine ;_fge +=_fddc .BytesPerLine ;
};};if _bac {for _bfd =0;_bfd < _cabde ;_bfd ++{for _cbda =0;_cbda < _edfa ;_cbda ++{_ecfc =_cdgdg (_fddc .Data [_dbcc +_cbda ]<<_fdca ,_fddc .Data [_dbcc +_cbda +1]>>_dge ,_dcfa );_deceg .Data [_afca +_cbda ]=^(_ecfc ^_deceg .Data [_afca +_cbda ]);};_afca +=_deceg .BytesPerLine ;
_dbcc +=_fddc .BytesPerLine ;};};if _daeg {for _bfd =0;_bfd < _cabde ;_bfd ++{_ecfc =_fddc .Data [_ffcc ]<<_fdca ;if _efdf {_ecfc =_cdgdg (_ecfc ,_fddc .Data [_ffcc +1]>>_dge ,_dcfa );};_deceg .Data [_cecgg ]=_cdgdg (_deceg .Data [_cecgg ],^(_ecfc ^_deceg .Data [_cecgg ]),_ddgd );
_cecgg +=_deceg .BytesPerLine ;_ffcc +=_fddc .BytesPerLine ;};};default:_eg .Log .Debug ("\u004f\u0070e\u0072\u0061\u0074\u0069\u006f\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006e\u006f\u0074\u0020\u0070\u0065\u0072\u006d\u0069tt\u0065\u0064",_fcea );
return _g .New ("\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065r\u0061\u0074\u0069\u006f\u006e\u0020\u006eo\u0074\u0020\u0070\u0065\u0072\u006d\u0069\u0074\u0074\u0065\u0064");};return nil ;};func ColorAtCMYK (x ,y ,width int ,data []byte ,decode []float64 )(_b .CMYK ,error ){_cea :=4*(y *width +x );
if _cea +3>=len (data ){return _b .CMYK {},_bd .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};C :=data [_cea ]&0xff;M :=data [_cea +1]&0xff;Y :=data [_cea +2]&0xff;K :=data [_cea +3]&0xff;if len (decode )==8{C =uint8 (uint32 (LinearInterpolate (float64 (C ),0,255,decode [0],decode [1]))&0xff);M =uint8 (uint32 (LinearInterpolate (float64 (M ),0,255,decode [2],decode [3]))&0xff);
Y =uint8 (uint32 (LinearInterpolate (float64 (Y ),0,255,decode [4],decode [5]))&0xff);K =uint8 (uint32 (LinearInterpolate (float64 (K ),0,255,decode [6],decode [7]))&0xff);};return _b .CMYK {C :C ,M :M ,Y :Y ,K :K },nil ;};func NewImage (width ,height ,bitsPerComponent ,colorComponents int ,data ,alpha []byte ,decode []float64 )(Image ,error ){_gdde :=NewImageBase (width ,height ,bitsPerComponent ,colorComponents ,data ,alpha ,decode );
var _bbd Image ;switch colorComponents {case 1:switch bitsPerComponent {case 1:_bbd =&Monochrome {ImageBase :_gdde ,ModelThreshold :0x0f};case 2:_bbd =&Gray2 {ImageBase :_gdde };case 4:_bbd =&Gray4 {ImageBase :_gdde };case 8:_bbd =&Gray8 {ImageBase :_gdde };
case 16:_bbd =&Gray16 {ImageBase :_gdde };};case 3:switch bitsPerComponent {case 4:_bbd =&NRGBA16 {ImageBase :_gdde };case 8:_bbd =&NRGBA32 {ImageBase :_gdde };case 16:_bbd =&NRGBA64 {ImageBase :_gdde };};case 4:_bbd =&CMYK32 {ImageBase :_gdde };};if _bbd ==nil {return nil ,ErrInvalidImage ;
};return _bbd ,nil ;};func _defc (_beac _b .CMYK )_b .NRGBA {_gfa ,_eda ,_efc :=_b .CMYKToRGB (_beac .C ,_beac .M ,_beac .Y ,_beac .K );return _b .NRGBA {R :_gfa ,G :_eda ,B :_efc ,A :0xff};};func _baaa ()(_ebf [256]uint16 ){for _bce :=0;_bce < 256;_bce ++{if _bce &0x01!=0{_ebf [_bce ]|=0x3;
};if _bce &0x02!=0{_ebf [_bce ]|=0xc;};if _bce &0x04!=0{_ebf [_bce ]|=0x30;};if _bce &0x08!=0{_ebf [_bce ]|=0xc0;};if _bce &0x10!=0{_ebf [_bce ]|=0x300;};if _bce &0x20!=0{_ebf [_bce ]|=0xc00;};if _bce &0x40!=0{_ebf [_bce ]|=0x3000;};if _bce &0x80!=0{_ebf [_bce ]|=0xc000;
};};return _ebf ;};func (_efde *ImageBase )setTwoBytes (_bedb int ,_acce uint16 )error {if _bedb +1> len (_efde .Data )-1{return _g .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_efde .Data [_bedb ]=byte ((_acce &0xff00)>>8);
_efde .Data [_bedb +1]=byte (_acce &0xff);return nil ;};func (_ecad *Gray16 )SetGray (x ,y int ,g _b .Gray ){_gccde :=(y *_ecad .BytesPerLine /2+x )*2;if _gccde +1>=len (_ecad .Data ){return ;};_ecad .Data [_gccde ]=g .Y ;_ecad .Data [_gccde +1]=g .Y ;
};func _agaf (_acfe *_f .Gray16 ,_gfbe uint8 )*_f .Gray {_caef :=_acfe .Bounds ();_fcde :=_f .NewGray (_caef );for _cafa :=0;_cafa < _caef .Dx ();_cafa ++{for _eaae :=0;_eaae < _caef .Dy ();_eaae ++{_gbfa :=_acfe .Gray16At (_cafa ,_eaae );_fcde .SetGray (_cafa ,_eaae ,_b .Gray {Y :_ecfd (uint8 (_gbfa .Y /256),_gfbe )});
};};return _fcde ;};func _ceab (_ddbc _b .Color )_b .Color {_egbg :=_b .GrayModel .Convert (_ddbc ).(_b .Gray );return _ffaag (_egbg );};func _faf (_afe _b .NRGBA )_b .Gray {_dfea ,_cde ,_fce ,_ :=_afe .RGBA ();_ggg :=(19595*_dfea +38470*_cde +7471*_fce +1<<15)>>24;
return _b .Gray {Y :uint8 (_ggg )};};type shift int ;func RasterOperation (dest *Monochrome ,dx ,dy ,dw ,dh int ,op RasterOperator ,src *Monochrome ,sx ,sy int )error {return _fdeb (dest ,dx ,dy ,dw ,dh ,op ,src ,sx ,sy );};func _bgfe (_ecda *Monochrome ,_fcd ,_eddd int ,_gcbdb ,_egbb int ,_bcaf RasterOperator ){var (_deda int ;
_cag byte ;_gcbdg ,_aedff int ;_fddba int ;);_dgga :=_gcbdb >>3;_dfdd :=_gcbdb &7;if _dfdd > 0{_cag =_dbeb [_dfdd ];};_deda =_ecda .BytesPerLine *_eddd +(_fcd >>3);switch _bcaf {case PixClr :for _gcbdg =0;_gcbdg < _egbb ;_gcbdg ++{_fddba =_deda +_gcbdg *_ecda .BytesPerLine ;
for _aedff =0;_aedff < _dgga ;_aedff ++{_ecda .Data [_fddba ]=0x0;_fddba ++;};if _dfdd > 0{_ecda .Data [_fddba ]=_cdgdg (_ecda .Data [_fddba ],0x0,_cag );};};case PixSet :for _gcbdg =0;_gcbdg < _egbb ;_gcbdg ++{_fddba =_deda +_gcbdg *_ecda .BytesPerLine ;
for _aedff =0;_aedff < _dgga ;_aedff ++{_ecda .Data [_fddba ]=0xff;_fddba ++;};if _dfdd > 0{_ecda .Data [_fddba ]=_cdgdg (_ecda .Data [_fddba ],0xff,_cag );};};case PixNotDst :for _gcbdg =0;_gcbdg < _egbb ;_gcbdg ++{_fddba =_deda +_gcbdg *_ecda .BytesPerLine ;
for _aedff =0;_aedff < _dgga ;_aedff ++{_ecda .Data [_fddba ]=^_ecda .Data [_fddba ];_fddba ++;};if _dfdd > 0{_ecda .Data [_fddba ]=_cdgdg (_ecda .Data [_fddba ],^_ecda .Data [_fddba ],_cag );};};};};type Image interface{_dd .Image ;Base ()*ImageBase ;
Copy ()Image ;Pix ()[]byte ;ColorAt (_fbgf ,_babg int )(_b .Color ,error );Validate ()error ;};func _gcee (_bcde RGBA ,_egcf NRGBA ,_cdbgd _f .Rectangle ){for _bbeg :=0;_bbeg < _cdbgd .Max .X ;_bbeg ++{for _aecfd :=0;_aecfd < _cdbgd .Max .Y ;_aecfd ++{_gfaa :=_bcde .RGBAAt (_bbeg ,_aecfd );
_egcf .SetNRGBA (_bbeg ,_aecfd ,_abf (_gfaa ));};};};func (_feeff *Gray4 )ColorAt (x ,y int )(_b .Color ,error ){return ColorAtGray4BPC (x ,y ,_feeff .BytesPerLine ,_feeff .Data ,_feeff .Decode );};func _bbeca (_gbea Gray ,_cgef NRGBA ,_ebeec _f .Rectangle ){for _beff :=0;
_beff < _ebeec .Max .X ;_beff ++{for _ecdb :=0;_ecdb < _ebeec .Max .Y ;_ecdb ++{_eafg :=_gbea .GrayAt (_beff ,_ecdb );_cgef .SetNRGBA (_beff ,_ecdb ,_cebc (_eafg ));};};};var (_cbe =_baaa ();_bad =_fbb ();_cgb =_fdf (););func _abdf (_dadf _f .Image )(Image ,error ){if _cfeg ,_fefg :=_dadf .(*NRGBA64 );
_fefg {return _cfeg .Copy (),nil ;};_afbg ,_eabd ,_dffd :=_gfbb (_dadf ,2);_gaff ,_agac :=NewImage (_afbg .Max .X ,_afbg .Max .Y ,16,3,nil ,_dffd ,nil );if _agac !=nil {return nil ,_agac ;};_dgbdc (_dadf ,_gaff ,_afbg );if len (_dffd )!=0&&!_eabd {if _ebee :=_gbed (_dffd ,_gaff );
_ebee !=nil {return nil ,_ebee ;};};return _gaff ,nil ;};var _ _f .Image =&NRGBA64 {};func _dcdf (_ecc _b .CMYK )_b .Gray {_ada ,_gefa ,_aeed :=_b .CMYKToRGB (_ecc .C ,_ecc .M ,_ecc .Y ,_ecc .K );_ccge :=(19595*uint32 (_ada )+38470*uint32 (_gefa )+7471*uint32 (_aeed )+1<<7)>>16;
return _b .Gray {Y :uint8 (_ccge )};};func _fbb ()(_af [256]uint32 ){for _edd :=0;_edd < 256;_edd ++{if _edd &0x01!=0{_af [_edd ]|=0xf;};if _edd &0x02!=0{_af [_edd ]|=0xf0;};if _edd &0x04!=0{_af [_edd ]|=0xf00;};if _edd &0x08!=0{_af [_edd ]|=0xf000;};if _edd &0x10!=0{_af [_edd ]|=0xf0000;
};if _edd &0x20!=0{_af [_edd ]|=0xf00000;};if _edd &0x40!=0{_af [_edd ]|=0xf000000;};if _edd &0x80!=0{_af [_edd ]|=0xf0000000;};};return _af ;};func _afdcg (_cffa _b .NRGBA )_b .NRGBA {_cffa .R =_cffa .R >>4|(_cffa .R >>4)<<4;_cffa .G =_cffa .G >>4|(_cffa .G >>4)<<4;
_cffa .B =_cffa .B >>4|(_cffa .B >>4)<<4;return _cffa ;};func (_ddaf *CMYK32 )Copy ()Image {return &CMYK32 {ImageBase :_ddaf .copy ()}};func (_eega *CMYK32 )Bounds ()_f .Rectangle {return _f .Rectangle {Max :_f .Point {X :_eega .Width ,Y :_eega .Height }};
};var _ Image =&CMYK32 {};func ColorAtGray4BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_b .Gray ,error ){_cdgf :=y *bytesPerLine +x >>1;if _cdgf >=len (data ){return _b .Gray {},_bd .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_ece :=data [_cdgf ]>>uint (4-(x &1)*4)&0xf;if len (decode )==2{_ece =uint8 (uint32 (LinearInterpolate (float64 (_ece ),0,15,decode [0],decode [1]))&0xf);};return _b .Gray {Y :_ece *17&0xff},nil ;};func _eecd (_ebeb _f .Image ,_acfb Image ,_ecbd _f .Rectangle ){switch _fcbe :=_ebeb .(type ){case Gray :_dgcd (_fcbe ,_acfb .(Gray ),_ecbd );
case NRGBA :_ccda (_fcbe ,_acfb .(Gray ),_ecbd );case CMYK :_abccg (_fcbe ,_acfb .(Gray ),_ecbd );case RGBA :_eaca (_fcbe ,_acfb .(Gray ),_ecbd );default:_dbdf (_ebeb ,_acfb .(Image ),_ecbd );};};func (_feed *ImageBase )MakeAlpha (){_feed .newAlpha ()};
func ConverterFunc (converterFunc func (_edf _f .Image )(Image ,error ))ColorConverter {return colorConverter {_efda :converterFunc };};func _dgbdc (_fegca _f .Image ,_egbbg Image ,_fede _f .Rectangle ){if _gebg ,_ebce :=_fegca .(SMasker );_ebce &&_gebg .HasAlpha (){_egbbg .(SMasker ).MakeAlpha ();
};_dbdf (_fegca ,_egbbg ,_fede );};func _abccg (_gegd CMYK ,_gfb Gray ,_cgdg _f .Rectangle ){for _cca :=0;_cca < _cgdg .Max .X ;_cca ++{for _bcda :=0;_bcda < _cgdg .Max .Y ;_bcda ++{_gacg :=_dcdf (_gegd .CMYKAt (_cca ,_bcda ));_gfb .SetGray (_cca ,_bcda ,_gacg );
};};};func (_aagb *Gray2 )Validate ()error {if len (_aagb .Data )!=_aagb .Height *_aagb .BytesPerLine {return ErrInvalidImage ;};return nil ;};func _bed (_bag _b .Gray )_b .CMYK {return _b .CMYK {K :0xff-_bag .Y }};func (_efba *CMYK32 )Set (x ,y int ,c _b .Color ){_bgbf :=4*(y *_efba .Width +x );
if _bgbf +3>=len (_efba .Data ){return ;};_bdde :=_b .CMYKModel .Convert (c ).(_b .CMYK );_efba .Data [_bgbf ]=_bdde .C ;_efba .Data [_bgbf +1]=_bdde .M ;_efba .Data [_bgbf +2]=_bdde .Y ;_efba .Data [_bgbf +3]=_bdde .K ;};type CMYK32 struct{ImageBase };
func (_fbab *Monochrome )ColorModel ()_b .Model {return MonochromeModel (_fbab .ModelThreshold )};func (_fccb *NRGBA32 )Bounds ()_f .Rectangle {return _f .Rectangle {Max :_f .Point {X :_fccb .Width ,Y :_fccb .Height }};};func (_gccac *NRGBA32 )SetNRGBA (x ,y int ,c _b .NRGBA ){_eegab :=y *_gccac .Width +x ;
_gcdcb :=3*_eegab ;if _gcdcb +2>=len (_gccac .Data ){return ;};_gccac .setRGBA (_eegab ,c );};