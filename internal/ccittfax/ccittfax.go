//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package ccittfax ;import (_g "errors";_d "github.com/unidoc/unipdf/v3/internal/bitwise";_gg "io";_b "math";);type code struct{Code uint16 ;BitsWritten int ;};func init (){_bg =&treeNode {_bgb :true ,_acgd :_a };_df =&treeNode {_acgd :_bfg ,_cdf :_bg };
_df ._gab =_df ;_gc =&tree {_fdg :&treeNode {}};if _bb :=_gc .fillWithNode (12,0,_df );_bb !=nil {panic (_bb .Error ());};if _cc :=_gc .fillWithNode (12,1,_bg );_cc !=nil {panic (_cc .Error ());};_ga =&tree {_fdg :&treeNode {}};for _fa :=0;_fa < len (_fe );
_fa ++{for _ab :=0;_ab < len (_fe [_fa ]);_ab ++{if _ec :=_ga .fill (_fa +2,int (_fe [_fa ][_ab ]),int (_fag [_fa ][_ab ]));_ec !=nil {panic (_ec .Error ());};};};if _fd :=_ga .fillWithNode (12,0,_df );_fd !=nil {panic (_fd .Error ());};if _fb :=_ga .fillWithNode (12,1,_bg );
_fb !=nil {panic (_fb .Error ());};_gac =&tree {_fdg :&treeNode {}};for _bd :=0;_bd < len (_cca );_bd ++{for _ca :=0;_ca < len (_cca [_bd ]);_ca ++{if _gb :=_gac .fill (_bd +4,int (_cca [_bd ][_ca ]),int (_bbg [_bd ][_ca ]));_gb !=nil {panic (_gb .Error ());
};};};if _caa :=_gac .fillWithNode (12,0,_df );_caa !=nil {panic (_caa .Error ());};if _bfb :=_gac .fillWithNode (12,1,_bg );_bfb !=nil {panic (_bfb .Error ());};_bf =&tree {_fdg :&treeNode {}};if _fab :=_bf .fill (4,1,_c );_fab !=nil {panic (_fab .Error ());
};if _dg :=_bf .fill (3,1,_e );_dg !=nil {panic (_dg .Error ());};if _ggf :=_bf .fill (1,1,0);_ggf !=nil {panic (_ggf .Error ());};if _gcc :=_bf .fill (3,3,1);_gcc !=nil {panic (_gcc .Error ());};if _bba :=_bf .fill (6,3,2);_bba !=nil {panic (_bba .Error ());
};if _ccf :=_bf .fill (7,3,3);_ccf !=nil {panic (_ccf .Error ());};if _dgd :=_bf .fill (3,2,-1);_dgd !=nil {panic (_dgd .Error ());};if _ba :=_bf .fill (6,2,-2);_ba !=nil {panic (_ba .Error ());};if _de :=_bf .fill (7,2,-3);_de !=nil {panic (_de .Error ());
};};type Decoder struct{_dge int ;_efe int ;_af int ;_ddb []byte ;_bbgg int ;_gcb bool ;_bbga bool ;_cbg bool ;_ag bool ;_ecaa bool ;_afg bool ;_fba bool ;_ac int ;_ggcc int ;_bbe []int ;_ggff []int ;_bbed int ;_ggb int ;_caaa int ;_ccfa int ;_bab *_d .Reader ;
_gaf tiffType ;_ed error ;};var _cca =[...][]uint16 {{0x7,0x8,0xb,0xc,0xe,0xf},{0x12,0x13,0x14,0x1b,0x7,0x8},{0x17,0x18,0x2a,0x2b,0x3,0x34,0x35,0x7,0x8},{0x13,0x17,0x18,0x24,0x27,0x28,0x2b,0x3,0x37,0x4,0x8,0xc},{0x12,0x13,0x14,0x15,0x16,0x17,0x1a,0x1b,0x2,0x24,0x25,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x3,0x32,0x33,0x34,0x35,0x36,0x37,0x4,0x4a,0x4b,0x5,0x52,0x53,0x54,0x55,0x58,0x59,0x5a,0x5b,0x64,0x65,0x67,0x68,0xa,0xb},{0x98,0x99,0x9a,0x9b,0xcc,0xcd,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xdb},{},{0x8,0xc,0xd},{0x12,0x13,0x14,0x15,0x16,0x17,0x1c,0x1d,0x1e,0x1f}};
func (_bada *Decoder )looseFetchEOL ()(bool ,error ){_cg ,_fcb :=_bada ._bab .ReadBits (12);if _fcb !=nil {return false ,_fcb ;};switch _cg {case 0x1:return true ,nil ;case 0x0:for {_gbgf ,_bae :=_bada ._bab .ReadBool ();if _bae !=nil {return false ,_bae ;
};if _gbgf {return true ,nil ;};};default:return false ,nil ;};};var (_bg *treeNode ;_df *treeNode ;_ga *tree ;_gac *tree ;_gc *tree ;_bf *tree ;_a =-2000;_bfg =-1000;_c =-3000;_e =-4000;);func (_cgd *Encoder )encodeG32D (_dba [][]byte )[]byte {var _dda []byte ;
var _bff int ;for _abff :=0;_abff < len (_dba );_abff +=_cgd .K {if _cgd .Rows > 0&&!_cgd .EndOfBlock &&_abff ==_cgd .Rows {break ;};_dfcd ,_bdg :=_bfbfc (_dba [_abff ],_bff ,_abf );_dda =_cgd .appendEncodedRow (_dda ,_dfcd ,_bff );if _cgd .EncodedByteAlign {_bdg =0;
};_bff =_bdg ;for _feea :=_abff +1;_feea < (_abff +_cgd .K )&&_feea < len (_dba );_feea ++{if _cgd .Rows > 0&&!_cgd .EndOfBlock &&_feea ==_cgd .Rows {break ;};_fcf ,_be :=_dfgc (nil ,_bff ,_gf );var _cgg ,_baa ,_fdf int ;_bce :=-1;for _bce < len (_dba [_feea ]){_cgg =_dbc (_dba [_feea ],_bce );
_baa =_edf (_dba [_feea ],_dba [_feea -1],_bce );_fdf =_dbc (_dba [_feea -1],_baa );if _fdf < _cgg {_fcf ,_be =_fagd (_fcf ,_be );_bce =_fdf ;}else {if _b .Abs (float64 (_baa -_cgg ))> 3{_fcf ,_be ,_bce =_dgcdd (_dba [_feea ],_fcf ,_be ,_bce ,_cgg );}else {_fcf ,_be =_abffd (_fcf ,_be ,_cgg ,_baa );
_bce =_cgg ;};};};_dda =_cgd .appendEncodedRow (_dda ,_fcf ,_bff );if _cgd .EncodedByteAlign {_be =0;};_bff =_be %8;};};if _cgd .EndOfBlock {_gdd ,_ :=_gdg (_bff );_dda =_cgd .appendEncodedRow (_dda ,_gdd ,_bff );};return _dda ;};func (_ecae *Decoder )decoderRowType41D ()error {if _ecae ._fba {_ecae ._bab .Align ();
};_ecae ._bab .Mark ();var (_efa bool ;_ff error ;);if _ecae ._ecaa {_efa ,_ff =_ecae .tryFetchEOL ();if _ff !=nil {return _ff ;};if !_efa {return _ggc ;};}else {_efa ,_ff =_ecae .looseFetchEOL ();if _ff !=nil {return _ff ;};};if !_efa {_ecae ._bab .Reset ();
};if _efa &&_ecae ._afg {_ecae ._bab .Mark ();for _bc :=0;_bc < 5;_bc ++{_efa ,_ff =_ecae .tryFetchEOL ();if _ff !=nil {if _g .Is (_ff ,_gg .EOF ){if _bc ==0{break ;};return _cd ;};};if _efa {continue ;};if _bc > 0{return _cd ;};break ;};if _efa {return _gg .EOF ;
};_ecae ._bab .Reset ();};if _ff =_ecae .decode1D ();_ff !=nil {return _ff ;};return nil ;};func init (){_dd =make (map[int ]code );_dd [0]=code {Code :13<<8|3<<6,BitsWritten :10};_dd [1]=code {Code :2<<(5+8),BitsWritten :3};_dd [2]=code {Code :3<<(6+8),BitsWritten :2};
_dd [3]=code {Code :2<<(6+8),BitsWritten :2};_dd [4]=code {Code :3<<(5+8),BitsWritten :3};_dd [5]=code {Code :3<<(4+8),BitsWritten :4};_dd [6]=code {Code :2<<(4+8),BitsWritten :4};_dd [7]=code {Code :3<<(3+8),BitsWritten :5};_dd [8]=code {Code :5<<(2+8),BitsWritten :6};
_dd [9]=code {Code :4<<(2+8),BitsWritten :6};_dd [10]=code {Code :4<<(1+8),BitsWritten :7};_dd [11]=code {Code :5<<(1+8),BitsWritten :7};_dd [12]=code {Code :7<<(1+8),BitsWritten :7};_dd [13]=code {Code :4<<8,BitsWritten :8};_dd [14]=code {Code :7<<8,BitsWritten :8};
_dd [15]=code {Code :12<<8,BitsWritten :9};_dd [16]=code {Code :5<<8|3<<6,BitsWritten :10};_dd [17]=code {Code :6<<8,BitsWritten :10};_dd [18]=code {Code :2<<8,BitsWritten :10};_dd [19]=code {Code :12<<8|7<<5,BitsWritten :11};_dd [20]=code {Code :13<<8,BitsWritten :11};
_dd [21]=code {Code :13<<8|4<<5,BitsWritten :11};_dd [22]=code {Code :6<<8|7<<5,BitsWritten :11};_dd [23]=code {Code :5<<8,BitsWritten :11};_dd [24]=code {Code :2<<8|7<<5,BitsWritten :11};_dd [25]=code {Code :3<<8,BitsWritten :11};_dd [26]=code {Code :12<<8|10<<4,BitsWritten :12};
_dd [27]=code {Code :12<<8|11<<4,BitsWritten :12};_dd [28]=code {Code :12<<8|12<<4,BitsWritten :12};_dd [29]=code {Code :12<<8|13<<4,BitsWritten :12};_dd [30]=code {Code :6<<8|8<<4,BitsWritten :12};_dd [31]=code {Code :6<<8|9<<4,BitsWritten :12};_dd [32]=code {Code :6<<8|10<<4,BitsWritten :12};
_dd [33]=code {Code :6<<8|11<<4,BitsWritten :12};_dd [34]=code {Code :13<<8|2<<4,BitsWritten :12};_dd [35]=code {Code :13<<8|3<<4,BitsWritten :12};_dd [36]=code {Code :13<<8|4<<4,BitsWritten :12};_dd [37]=code {Code :13<<8|5<<4,BitsWritten :12};_dd [38]=code {Code :13<<8|6<<4,BitsWritten :12};
_dd [39]=code {Code :13<<8|7<<4,BitsWritten :12};_dd [40]=code {Code :6<<8|12<<4,BitsWritten :12};_dd [41]=code {Code :6<<8|13<<4,BitsWritten :12};_dd [42]=code {Code :13<<8|10<<4,BitsWritten :12};_dd [43]=code {Code :13<<8|11<<4,BitsWritten :12};_dd [44]=code {Code :5<<8|4<<4,BitsWritten :12};
_dd [45]=code {Code :5<<8|5<<4,BitsWritten :12};_dd [46]=code {Code :5<<8|6<<4,BitsWritten :12};_dd [47]=code {Code :5<<8|7<<4,BitsWritten :12};_dd [48]=code {Code :6<<8|4<<4,BitsWritten :12};_dd [49]=code {Code :6<<8|5<<4,BitsWritten :12};_dd [50]=code {Code :5<<8|2<<4,BitsWritten :12};
_dd [51]=code {Code :5<<8|3<<4,BitsWritten :12};_dd [52]=code {Code :2<<8|4<<4,BitsWritten :12};_dd [53]=code {Code :3<<8|7<<4,BitsWritten :12};_dd [54]=code {Code :3<<8|8<<4,BitsWritten :12};_dd [55]=code {Code :2<<8|7<<4,BitsWritten :12};_dd [56]=code {Code :2<<8|8<<4,BitsWritten :12};
_dd [57]=code {Code :5<<8|8<<4,BitsWritten :12};_dd [58]=code {Code :5<<8|9<<4,BitsWritten :12};_dd [59]=code {Code :2<<8|11<<4,BitsWritten :12};_dd [60]=code {Code :2<<8|12<<4,BitsWritten :12};_dd [61]=code {Code :5<<8|10<<4,BitsWritten :12};_dd [62]=code {Code :6<<8|6<<4,BitsWritten :12};
_dd [63]=code {Code :6<<8|7<<4,BitsWritten :12};_eca =make (map[int ]code );_eca [0]=code {Code :53<<8,BitsWritten :8};_eca [1]=code {Code :7<<(2+8),BitsWritten :6};_eca [2]=code {Code :7<<(4+8),BitsWritten :4};_eca [3]=code {Code :8<<(4+8),BitsWritten :4};
_eca [4]=code {Code :11<<(4+8),BitsWritten :4};_eca [5]=code {Code :12<<(4+8),BitsWritten :4};_eca [6]=code {Code :14<<(4+8),BitsWritten :4};_eca [7]=code {Code :15<<(4+8),BitsWritten :4};_eca [8]=code {Code :19<<(3+8),BitsWritten :5};_eca [9]=code {Code :20<<(3+8),BitsWritten :5};
_eca [10]=code {Code :7<<(3+8),BitsWritten :5};_eca [11]=code {Code :8<<(3+8),BitsWritten :5};_eca [12]=code {Code :8<<(2+8),BitsWritten :6};_eca [13]=code {Code :3<<(2+8),BitsWritten :6};_eca [14]=code {Code :52<<(2+8),BitsWritten :6};_eca [15]=code {Code :53<<(2+8),BitsWritten :6};
_eca [16]=code {Code :42<<(2+8),BitsWritten :6};_eca [17]=code {Code :43<<(2+8),BitsWritten :6};_eca [18]=code {Code :39<<(1+8),BitsWritten :7};_eca [19]=code {Code :12<<(1+8),BitsWritten :7};_eca [20]=code {Code :8<<(1+8),BitsWritten :7};_eca [21]=code {Code :23<<(1+8),BitsWritten :7};
_eca [22]=code {Code :3<<(1+8),BitsWritten :7};_eca [23]=code {Code :4<<(1+8),BitsWritten :7};_eca [24]=code {Code :40<<(1+8),BitsWritten :7};_eca [25]=code {Code :43<<(1+8),BitsWritten :7};_eca [26]=code {Code :19<<(1+8),BitsWritten :7};_eca [27]=code {Code :36<<(1+8),BitsWritten :7};
_eca [28]=code {Code :24<<(1+8),BitsWritten :7};_eca [29]=code {Code :2<<8,BitsWritten :8};_eca [30]=code {Code :3<<8,BitsWritten :8};_eca [31]=code {Code :26<<8,BitsWritten :8};_eca [32]=code {Code :27<<8,BitsWritten :8};_eca [33]=code {Code :18<<8,BitsWritten :8};
_eca [34]=code {Code :19<<8,BitsWritten :8};_eca [35]=code {Code :20<<8,BitsWritten :8};_eca [36]=code {Code :21<<8,BitsWritten :8};_eca [37]=code {Code :22<<8,BitsWritten :8};_eca [38]=code {Code :23<<8,BitsWritten :8};_eca [39]=code {Code :40<<8,BitsWritten :8};
_eca [40]=code {Code :41<<8,BitsWritten :8};_eca [41]=code {Code :42<<8,BitsWritten :8};_eca [42]=code {Code :43<<8,BitsWritten :8};_eca [43]=code {Code :44<<8,BitsWritten :8};_eca [44]=code {Code :45<<8,BitsWritten :8};_eca [45]=code {Code :4<<8,BitsWritten :8};
_eca [46]=code {Code :5<<8,BitsWritten :8};_eca [47]=code {Code :10<<8,BitsWritten :8};_eca [48]=code {Code :11<<8,BitsWritten :8};_eca [49]=code {Code :82<<8,BitsWritten :8};_eca [50]=code {Code :83<<8,BitsWritten :8};_eca [51]=code {Code :84<<8,BitsWritten :8};
_eca [52]=code {Code :85<<8,BitsWritten :8};_eca [53]=code {Code :36<<8,BitsWritten :8};_eca [54]=code {Code :37<<8,BitsWritten :8};_eca [55]=code {Code :88<<8,BitsWritten :8};_eca [56]=code {Code :89<<8,BitsWritten :8};_eca [57]=code {Code :90<<8,BitsWritten :8};
_eca [58]=code {Code :91<<8,BitsWritten :8};_eca [59]=code {Code :74<<8,BitsWritten :8};_eca [60]=code {Code :75<<8,BitsWritten :8};_eca [61]=code {Code :50<<8,BitsWritten :8};_eca [62]=code {Code :51<<8,BitsWritten :8};_eca [63]=code {Code :52<<8,BitsWritten :8};
_aad =make (map[int ]code );_aad [64]=code {Code :3<<8|3<<6,BitsWritten :10};_aad [128]=code {Code :12<<8|8<<4,BitsWritten :12};_aad [192]=code {Code :12<<8|9<<4,BitsWritten :12};_aad [256]=code {Code :5<<8|11<<4,BitsWritten :12};_aad [320]=code {Code :3<<8|3<<4,BitsWritten :12};
_aad [384]=code {Code :3<<8|4<<4,BitsWritten :12};_aad [448]=code {Code :3<<8|5<<4,BitsWritten :12};_aad [512]=code {Code :3<<8|12<<3,BitsWritten :13};_aad [576]=code {Code :3<<8|13<<3,BitsWritten :13};_aad [640]=code {Code :2<<8|10<<3,BitsWritten :13};
_aad [704]=code {Code :2<<8|11<<3,BitsWritten :13};_aad [768]=code {Code :2<<8|12<<3,BitsWritten :13};_aad [832]=code {Code :2<<8|13<<3,BitsWritten :13};_aad [896]=code {Code :3<<8|18<<3,BitsWritten :13};_aad [960]=code {Code :3<<8|19<<3,BitsWritten :13};
_aad [1024]=code {Code :3<<8|20<<3,BitsWritten :13};_aad [1088]=code {Code :3<<8|21<<3,BitsWritten :13};_aad [1152]=code {Code :3<<8|22<<3,BitsWritten :13};_aad [1216]=code {Code :119<<3,BitsWritten :13};_aad [1280]=code {Code :2<<8|18<<3,BitsWritten :13};
_aad [1344]=code {Code :2<<8|19<<3,BitsWritten :13};_aad [1408]=code {Code :2<<8|20<<3,BitsWritten :13};_aad [1472]=code {Code :2<<8|21<<3,BitsWritten :13};_aad [1536]=code {Code :2<<8|26<<3,BitsWritten :13};_aad [1600]=code {Code :2<<8|27<<3,BitsWritten :13};
_aad [1664]=code {Code :3<<8|4<<3,BitsWritten :13};_aad [1728]=code {Code :3<<8|5<<3,BitsWritten :13};_ecc =make (map[int ]code );_ecc [64]=code {Code :27<<(3+8),BitsWritten :5};_ecc [128]=code {Code :18<<(3+8),BitsWritten :5};_ecc [192]=code {Code :23<<(2+8),BitsWritten :6};
_ecc [256]=code {Code :55<<(1+8),BitsWritten :7};_ecc [320]=code {Code :54<<8,BitsWritten :8};_ecc [384]=code {Code :55<<8,BitsWritten :8};_ecc [448]=code {Code :100<<8,BitsWritten :8};_ecc [512]=code {Code :101<<8,BitsWritten :8};_ecc [576]=code {Code :104<<8,BitsWritten :8};
_ecc [640]=code {Code :103<<8,BitsWritten :8};_ecc [704]=code {Code :102<<8,BitsWritten :9};_ecc [768]=code {Code :102<<8|1<<7,BitsWritten :9};_ecc [832]=code {Code :105<<8,BitsWritten :9};_ecc [896]=code {Code :105<<8|1<<7,BitsWritten :9};_ecc [960]=code {Code :106<<8,BitsWritten :9};
_ecc [1024]=code {Code :106<<8|1<<7,BitsWritten :9};_ecc [1088]=code {Code :107<<8,BitsWritten :9};_ecc [1152]=code {Code :107<<8|1<<7,BitsWritten :9};_ecc [1216]=code {Code :108<<8,BitsWritten :9};_ecc [1280]=code {Code :108<<8|1<<7,BitsWritten :9};_ecc [1344]=code {Code :109<<8,BitsWritten :9};
_ecc [1408]=code {Code :109<<8|1<<7,BitsWritten :9};_ecc [1472]=code {Code :76<<8,BitsWritten :9};_ecc [1536]=code {Code :76<<8|1<<7,BitsWritten :9};_ecc [1600]=code {Code :77<<8,BitsWritten :9};_ecc [1664]=code {Code :24<<(2+8),BitsWritten :6};_ecc [1728]=code {Code :77<<8|1<<7,BitsWritten :9};
_ef =make (map[int ]code );_ef [1792]=code {Code :1<<8,BitsWritten :11};_ef [1856]=code {Code :1<<8|4<<5,BitsWritten :11};_ef [1920]=code {Code :1<<8|5<<5,BitsWritten :11};_ef [1984]=code {Code :1<<8|2<<4,BitsWritten :12};_ef [2048]=code {Code :1<<8|3<<4,BitsWritten :12};
_ef [2112]=code {Code :1<<8|4<<4,BitsWritten :12};_ef [2176]=code {Code :1<<8|5<<4,BitsWritten :12};_ef [2240]=code {Code :1<<8|6<<4,BitsWritten :12};_ef [2304]=code {Code :1<<8|7<<4,BitsWritten :12};_ef [2368]=code {Code :1<<8|12<<4,BitsWritten :12};_ef [2432]=code {Code :1<<8|13<<4,BitsWritten :12};
_ef [2496]=code {Code :1<<8|14<<4,BitsWritten :12};_ef [2560]=code {Code :1<<8|15<<4,BitsWritten :12};_ddg =make (map[int ]byte );_ddg [0]=0xFF;_ddg [1]=0xFE;_ddg [2]=0xFC;_ddg [3]=0xF8;_ddg [4]=0xF0;_ddg [5]=0xE0;_ddg [6]=0xC0;_ddg [7]=0x80;_ddg [8]=0x00;
};func _ebeb (_bgeb ,_dde int )code {var _eed code ;switch _dde -_bgeb {case -1:_eed =_fbc ;case -2:_eed =_dgc ;case -3:_eed =_bbaa ;case 0:_eed =_cb ;case 1:_eed =_fg ;case 2:_eed =_ccab ;case 3:_eed =_dgf ;};return _eed ;};func (_eea *Decoder )decodeRow ()(_baba error ){if !_eea ._afg &&_eea ._efe > 0&&_eea ._efe ==_eea ._af {return _gg .EOF ;
};switch _eea ._gaf {case _fgb :_baba =_eea .decodeRowType2 ();case _aae :_baba =_eea .decodeRowType4 ();case _bge :_baba =_eea .decodeRowType6 ();};if _baba !=nil {return _baba ;};_ae :=0;_gcg :=true ;_eea ._ccfa =0;for _fge :=0;_fge < _eea ._ggb ;_fge ++{_cf :=_eea ._dge ;
if _fge !=_eea ._ggb {_cf =_eea ._ggff [_fge ];};if _cf > _eea ._dge {_cf =_eea ._dge ;};_db :=_ae /8;for _ae %8!=0&&_cf -_ae > 0{var _gcbg byte ;if !_gcg {_gcbg =1<<uint (7-(_ae %8));};_eea ._ddb [_db ]|=_gcbg ;_ae ++;};if _ae %8==0{_db =_ae /8;var _bfc byte ;
if !_gcg {_bfc =0xff;};for _cf -_ae > 7{_eea ._ddb [_db ]=_bfc ;_ae +=8;_db ++;};};for _cf -_ae > 0{if _ae %8==0{_eea ._ddb [_db ]=0;};var _edcc byte ;if !_gcg {_edcc =1<<uint (7-(_ae %8));};_eea ._ddb [_db ]|=_edcc ;_ae ++;};_gcg =!_gcg ;};if _ae !=_eea ._dge {return _g .New ("\u0073\u0075\u006d\u0020\u006f\u0066 \u0072\u0075\u006e\u002d\u006c\u0065\u006e\u0067\u0074\u0068\u0073\u0020\u0064\u006f\u0065\u0073\u0020\u006e\u006f\u0074 \u0065\u0071\u0075\u0061\u006c\u0020\u0073\u0063\u0061\u006e\u0020\u006c\u0069\u006ee\u0020w\u0069\u0064\u0074\u0068");
};_eea ._ac =(_ae +7)/8;_eea ._af ++;return nil ;};func (_fff *treeNode )set (_cgga bool ,_efec *treeNode ){if !_cgga {_fff ._gab =_efec ;}else {_fff ._cdf =_efec ;};};func _gdg (_defe int )([]byte ,int ){var _bed []byte ;for _edbd :=0;_edbd < 6;_edbd ++{_bed ,_defe =_dfgc (_bed ,_defe ,_abf );
};return _bed ,_defe %8;};func _dfcf (_ecb int )([]byte ,int ){var _dga []byte ;for _fdb :=0;_fdb < 6;_fdb ++{_dga ,_ecb =_dfgc (_dga ,_ecb ,_gbb );};return _dga ,_ecb %8;};func _ggbg (_eag int )([]byte ,int ){var _fdbd []byte ;for _dgea :=0;_dgea < 2;
_dgea ++{_fdbd ,_eag =_dfgc (_fdbd ,_eag ,_gbb );};return _fdbd ,_eag %8;};func (_ccc *Encoder )appendEncodedRow (_dbf ,_cga []byte ,_eebe int )[]byte {if len (_dbf )> 0&&_eebe !=0&&!_ccc .EncodedByteAlign {_dbf [len (_dbf )-1]=_dbf [len (_dbf )-1]|_cga [0];
_dbf =append (_dbf ,_cga [1:]...);}else {_dbf =append (_dbf ,_cga ...);};return _dbf ;};type tiffType int ;func (_fgad *Encoder )Encode (pixels [][]byte )[]byte {if _fgad .BlackIs1 {_dgb =0;_cee =1;}else {_dgb =1;_cee =0;};if _fgad .K ==0{return _fgad .encodeG31D (pixels );
};if _fgad .K > 0{return _fgad .encodeG32D (pixels );};if _fgad .K < 0{return _fgad .encodeG4 (pixels );};return nil ;};func (_feb *Decoder )decode1D ()error {var (_fdc int ;_def error ;);_gfdf :=true ;_feb ._ggb =0;for {var _deg int ;if _gfdf {_deg ,_def =_feb .decodeRun (_gac );
}else {_deg ,_def =_feb .decodeRun (_ga );};if _def !=nil {return _def ;};_fdc +=_deg ;_feb ._ggff [_feb ._ggb ]=_fdc ;_feb ._ggb ++;_gfdf =!_gfdf ;if _fdc >=_feb ._dge {break ;};};return nil ;};func (_da *Decoder )decodeRowType4 ()error {if !_da ._gcb {return _da .decoderRowType41D ();
};if _da ._fba {_da ._bab .Align ();};_da ._bab .Mark ();_cdc ,_gfd :=_da .tryFetchEOL ();if _gfd !=nil {return _gfd ;};if !_cdc &&_da ._ecaa {_da ._caaa ++;if _da ._caaa > _da ._bbgg {return _ggc ;};_da ._bab .Reset ();};if !_cdc {_da ._bab .Reset ();
};_aee ,_gfd :=_da ._bab .ReadBool ();if _gfd !=nil {return _gfd ;};if _aee {if _cdc &&_da ._afg {if _gfd =_da .tryFetchRTC2D ();_gfd !=nil {return _gfd ;};};_gfd =_da .decode1D ();}else {_gfd =_da .decode2D ();};if _gfd !=nil {return _gfd ;};return nil ;
};var _bbg =[...][]uint16 {{2,3,4,5,6,7},{128,8,9,64,10,11},{192,1664,16,17,13,14,15,1,12},{26,21,28,27,18,24,25,22,256,23,20,19},{33,34,35,36,37,38,31,32,29,53,54,39,40,41,42,43,44,30,61,62,63,0,320,384,45,59,60,46,49,50,51,52,55,56,57,58,448,512,640,576,47,48},{1472,1536,1600,1728,704,768,832,896,960,1024,1088,1152,1216,1280,1344,1408},{},{1792,1856,1920},{1984,2048,2112,2176,2240,2304,2368,2432,2496,2560}};
func (_gfe *Decoder )tryFetchEOL1 ()(bool ,error ){_gef ,_afbb :=_gfe ._bab .ReadBits (13);if _afbb !=nil {return false ,_afbb ;};return _gef ==0x3,nil ;};func _fagd (_ccad []byte ,_fbed int )([]byte ,int ){return _dfgc (_ccad ,_fbed ,_gd )};func _edf (_gebd ,_abg []byte ,_gfa int )int {_ccac :=_dbc (_abg ,_gfa );
if _ccac < len (_abg )&&(_gfa ==-1&&_abg [_ccac ]==_dgb ||_gfa >=0&&_gfa < len (_gebd )&&_gebd [_gfa ]==_abg [_ccac ]||_gfa >=len (_gebd )&&_gebd [_gfa -1]!=_abg [_ccac ]){_ccac =_dbc (_abg ,_ccac );};return _ccac ;};var _fe =[...][]uint16 {{0x2,0x3},{0x2,0x3},{0x2,0x3},{0x3},{0x4,0x5},{0x4,0x5,0x7},{0x4,0x7},{0x18},{0x17,0x18,0x37,0x8,0xf},{0x17,0x18,0x28,0x37,0x67,0x68,0x6c,0x8,0xc,0xd},{0x12,0x13,0x14,0x15,0x16,0x17,0x1c,0x1d,0x1e,0x1f,0x24,0x27,0x28,0x2b,0x2c,0x33,0x34,0x35,0x37,0x38,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x5b,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xda,0xdb},{0x4a,0x4b,0x4c,0x4d,0x52,0x53,0x54,0x55,0x5a,0x5b,0x64,0x65,0x6c,0x6d,0x72,0x73,0x74,0x75,0x76,0x77}};
func (_babae *tree )fill (_fdda ,_fgda ,_fbagd int )error {_feg :=_babae ._fdg ;for _ccd :=0;_ccd < _fdda ;_ccd ++{_aggc :=_fdda -1-_ccd ;_ecag :=((_fgda >>uint (_aggc ))&1)!=0;_gcd :=_feg .walk (_ecag );if _gcd !=nil {if _gcd ._bgb {return _g .New ("\u006e\u006f\u0064\u0065\u0020\u0069\u0073\u0020\u006c\u0065\u0061\u0066\u002c\u0020\u006eo\u0020o\u0074\u0068\u0065\u0072\u0020\u0066\u006f\u006c\u006c\u006f\u0077\u0069\u006e\u0067");
};_feg =_gcd ;continue ;};_gcd =&treeNode {};if _ccd ==_fdda -1{_gcd ._acgd =_fbagd ;_gcd ._bgb =true ;};if _fgda ==0{_gcd ._bef =true ;};_feg .set (_ecag ,_gcd );_feg =_gcd ;};return nil ;};var (_dgb byte =1;_cee byte =0;);type Encoder struct{K int ;EndOfLine bool ;
EncodedByteAlign bool ;Columns int ;Rows int ;EndOfBlock bool ;BlackIs1 bool ;DamagedRowsBeforeError int ;};func (_fc *Decoder )decodeG32D ()error {_fc ._bbed =_fc ._ggb ;_fc ._ggff ,_fc ._bbe =_fc ._bbe ,_fc ._ggff ;_eaa :=true ;var (_cfg bool ;_cbgc int ;
_ged error ;);_fc ._ggb =0;_gcgb :for _cbgc < _fc ._dge {_fac :=_bf ._fdg ;for {_cfg ,_ged =_fc ._bab .ReadBool ();if _ged !=nil {return _ged ;};_fac =_fac .walk (_cfg );if _fac ==nil {continue _gcgb ;};if !_fac ._bgb {continue ;};switch _fac ._acgd {case _e :var _dac int ;
if _eaa {_dac ,_ged =_fc .decodeRun (_gac );}else {_dac ,_ged =_fc .decodeRun (_ga );};if _ged !=nil {return _ged ;};_cbgc +=_dac ;_fc ._ggff [_fc ._ggb ]=_cbgc ;_fc ._ggb ++;if _eaa {_dac ,_ged =_fc .decodeRun (_ga );}else {_dac ,_ged =_fc .decodeRun (_gac );
};if _ged !=nil {return _ged ;};_cbgc +=_dac ;_fc ._ggff [_fc ._ggb ]=_cbgc ;_fc ._ggb ++;case _c :_acf :=_fc .getNextChangingElement (_cbgc ,_eaa )+1;if _acf >=_fc ._bbed {_cbgc =_fc ._dge ;}else {_cbgc =_fc ._bbe [_acf ];};default:_dfc :=_fc .getNextChangingElement (_cbgc ,_eaa );
if _dfc >=_fc ._bbed ||_dfc ==-1{_cbgc =_fc ._dge +_fac ._acgd ;}else {_cbgc =_fc ._bbe [_dfc ]+_fac ._acgd ;};_fc ._ggff [_fc ._ggb ]=_cbgc ;_fc ._ggb ++;_eaa =!_eaa ;};continue _gcgb ;};};return nil ;};func (_abaf *tree )fillWithNode (_dca ,_gce int ,_bcb *treeNode )error {_fgg :=_abaf ._fdg ;
for _efd :=0;_efd < _dca ;_efd ++{_dag :=uint (_dca -1-_efd );_gdef :=((_gce >>_dag )&1)!=0;_febb :=_fgg .walk (_gdef );if _febb !=nil {if _febb ._bgb {return _g .New ("\u006e\u006f\u0064\u0065\u0020\u0069\u0073\u0020\u006c\u0065\u0061\u0066\u002c\u0020\u006eo\u0020o\u0074\u0068\u0065\u0072\u0020\u0066\u006f\u006c\u006c\u006f\u0077\u0069\u006e\u0067");
};_fgg =_febb ;continue ;};if _efd ==_dca -1{_febb =_bcb ;}else {_febb =&treeNode {};};if _gce ==0{_febb ._bef =true ;};_fgg .set (_gdef ,_febb );_fgg =_febb ;};return nil ;};func _dfgc (_bbd []byte ,_dfcc int ,_cde code )([]byte ,int ){_acbf :=0;for _acbf < _cde .BitsWritten {_eee :=_dfcc /8;
_cgde :=_dfcc %8;if _eee >=len (_bbd ){_bbd =append (_bbd ,0);};_bdd :=8-_cgde ;_dab :=_cde .BitsWritten -_acbf ;if _bdd > _dab {_bdd =_dab ;};if _acbf < 8{_bbd [_eee ]=_bbd [_eee ]|byte (_cde .Code >>uint (8+_cgde -_acbf ))&_ddg [8-_bdd -_cgde ];}else {_bbd [_eee ]=_bbd [_eee ]|(byte (_cde .Code <<uint (_acbf -8))&_ddg [8-_bdd ])>>uint (_cgde );
};_dfcc +=_bdd ;_acbf +=_bdd ;};return _bbd ,_dfcc ;};var _fag =[...][]uint16 {{3,2},{1,4},{6,5},{7},{9,8},{10,11,12},{13,14},{15},{16,17,0,18,64},{24,25,23,22,19,20,21,1792,1856,1920},{1984,2048,2112,2176,2240,2304,2368,2432,2496,2560,52,55,56,59,60,320,384,448,53,54,50,51,44,45,46,47,57,58,61,256,48,49,62,63,30,31,32,33,40,41,128,192,26,27,28,29,34,35,36,37,38,39,42,43},{640,704,768,832,1280,1344,1408,1472,1536,1600,1664,1728,512,576,896,960,1024,1088,1152,1216}};
func (_fga *Decoder )Read (in []byte )(int ,error ){if _fga ._ed !=nil {return 0,_fga ._ed ;};_fae :=len (in );var (_ecd int ;_fgbe int ;);for _fae !=0{if _fga ._ggcc >=_fga ._ac {if _ad :=_fga .fetch ();_ad !=nil {_fga ._ed =_ad ;return 0,_ad ;};};if _fga ._ac ==-1{return _ecd ,_gg .EOF ;
};switch {case _fae <=_fga ._ac -_fga ._ggcc :_ge :=_fga ._ddb [_fga ._ggcc :_fga ._ggcc +_fae ];for _ ,_afc :=range _ge {if !_fga ._ag {_afc =^_afc ;};in [_fgbe ]=_afc ;_fgbe ++;};_ecd +=len (_ge );_fga ._ggcc +=len (_ge );return _ecd ,nil ;default:_ege :=_fga ._ddb [_fga ._ggcc :];
for _ ,_dfg :=range _ege {if !_fga ._ag {_dfg =^_dfg ;};in [_fgbe ]=_dfg ;_fgbe ++;};_ecd +=len (_ege );_fga ._ggcc +=len (_ege );_fae -=len (_ege );};};return _ecd ,nil ;};func (_ccaf *Encoder )encodeG4 (_febe [][]byte )[]byte {_gaga :=make ([][]byte ,len (_febe ));
copy (_gaga ,_febe );_gaga =_ggd (_gaga );var _gecb []byte ;var _bag int ;for _aggg :=1;_aggg < len (_gaga );_aggg ++{if _ccaf .Rows > 0&&!_ccaf .EndOfBlock &&_aggg ==(_ccaf .Rows +1){break ;};var _eeag []byte ;var _acfb ,_abaa ,_afbbg int ;_gcbgf :=_bag ;
_gba :=-1;for _gba < len (_gaga [_aggg ]){_acfb =_dbc (_gaga [_aggg ],_gba );_abaa =_edf (_gaga [_aggg ],_gaga [_aggg -1],_gba );_afbbg =_dbc (_gaga [_aggg -1],_abaa );if _afbbg < _acfb {_eeag ,_gcbgf =_dfgc (_eeag ,_gcbgf ,_gd );_gba =_afbbg ;}else {if _b .Abs (float64 (_abaa -_acfb ))> 3{_eeag ,_gcbgf ,_gba =_dgcdd (_gaga [_aggg ],_eeag ,_gcbgf ,_gba ,_acfb );
}else {_eeag ,_gcbgf =_abffd (_eeag ,_gcbgf ,_acfb ,_abaa );_gba =_acfb ;};};};_gecb =_ccaf .appendEncodedRow (_gecb ,_eeag ,_bag );if _ccaf .EncodedByteAlign {_gcbgf =0;};_bag =_gcbgf %8;};if _ccaf .EndOfBlock {_gda ,_ :=_ggbg (_bag );_gecb =_ccaf .appendEncodedRow (_gecb ,_gda ,_bag );
};return _gecb ;};const (_ tiffType =iota ;_fgb ;_aae ;_bge ;);func (_ffe *Decoder )tryFetchEOL ()(bool ,error ){_fbag ,_aba :=_ffe ._bab .ReadBits (12);if _aba !=nil {return false ,_aba ;};return _fbag ==0x1,nil ;};func _dbc (_ddbc []byte ,_fabb int )int {if _fabb >=len (_ddbc ){return _fabb ;
};if _fabb < -1{_fabb =-1;};var _aed byte ;if _fabb > -1{_aed =_ddbc [_fabb ];}else {_aed =_dgb ;};_gdde :=_fabb +1;for _gdde < len (_ddbc ){if _ddbc [_gdde ]!=_aed {break ;};_gdde ++;};return _gdde ;};func _ggd (_ebec [][]byte )[][]byte {_cfgf :=make ([]byte ,len (_ebec [0]));
for _cbf :=range _cfgf {_cfgf [_cbf ]=_dgb ;};_ebec =append (_ebec ,[]byte {});for _ffb :=len (_ebec )-1;_ffb > 0;_ffb --{_ebec [_ffb ]=_ebec [_ffb -1];};_ebec [0]=_cfgf ;return _ebec ;};func (_faga *Decoder )decodeRowType6 ()error {if _faga ._fba {_faga ._bab .Align ();
};if _faga ._afg {_faga ._bab .Mark ();_agg ,_gag :=_faga .tryFetchEOL ();if _gag !=nil {return _gag ;};if _agg {_agg ,_gag =_faga .tryFetchEOL ();if _gag !=nil {return _gag ;};if _agg {return _gg .EOF ;};};_faga ._bab .Reset ();};return _faga .decode2D ();
};func (_fee *Decoder )tryFetchRTC2D ()(_ddf error ){_fee ._bab .Mark ();var _ffec bool ;for _aeeb :=0;_aeeb < 5;_aeeb ++{_ffec ,_ddf =_fee .tryFetchEOL1 ();if _ddf !=nil {if _g .Is (_ddf ,_gg .EOF ){if _aeeb ==0{break ;};return _cd ;};};if _ffec {continue ;
};if _aeeb > 0{return _cd ;};break ;};if _ffec {return _gg .EOF ;};_fee ._bab .Reset ();return _ddf ;};func _bfbfc (_age []byte ,_eefg int ,_adcc code )([]byte ,int ){_bfef :=true ;var _dbb []byte ;_dbb ,_eefg =_dfgc (nil ,_eefg ,_adcc );_facb :=0;var _egd int ;
for _facb < len (_age ){_egd ,_facb =_faa (_age ,_bfef ,_facb );_dbb ,_eefg =_bfbfcd (_dbb ,_eefg ,_egd ,_bfef );_bfef =!_bfef ;};return _dbb ,_eefg %8;};func (_bfe *Decoder )getNextChangingElement (_ce int ,_acg bool )int {_gbg :=0;if !_acg {_gbg =1;};
_ced :=int (uint32 (_bfe ._ccfa )&0xFFFFFFFE)+_gbg ;if _ced > 2{_ced -=2;};if _ce ==0{return _ced ;};for _daa :=_ced ;_daa < _bfe ._bbed ;_daa +=2{if _ce < _bfe ._bbe [_daa ]{_bfe ._ccfa =_daa ;return _daa ;};};return -1;};func (_bgef *Decoder )decodeRun (_gbe *tree )(int ,error ){var _dgcd int ;
_geb :=_gbe ._fdg ;for {_gdb ,_fdd :=_bgef ._bab .ReadBool ();if _fdd !=nil {return 0,_fdd ;};_geb =_geb .walk (_gdb );if _geb ==nil {return 0,_g .New ("\u0075\u006e\u006bno\u0077\u006e\u0020\u0063\u006f\u0064\u0065\u0020\u0069n\u0020H\u0075f\u0066m\u0061\u006e\u0020\u0052\u004c\u0045\u0020\u0073\u0074\u0072\u0065\u0061\u006d");
};if _geb ._bgb {_dgcd +=_geb ._acgd ;switch {case _geb ._acgd >=64:_geb =_gbe ._fdg ;case _geb ._acgd >=0:return _dgcd ,nil ;default:return _bgef ._dge ,nil ;};};};};type DecodeOptions struct{Columns int ;Rows int ;K int ;EncodedByteAligned bool ;BlackIsOne bool ;
EndOfBlock bool ;EndOfLine bool ;DamagedRowsBeforeError int ;};func (_gedg *Decoder )decode2D ()error {_gedg ._bbed =_gedg ._ggb ;_gedg ._ggff ,_gedg ._bbe =_gedg ._bbe ,_gedg ._ggff ;_adc :=true ;var (_fec bool ;_adg int ;_gafd error ;);_gedg ._ggb =0;
_afb :for _adg < _gedg ._dge {_gcfg :=_bf ._fdg ;for {_fec ,_gafd =_gedg ._bab .ReadBool ();if _gafd !=nil {return _gafd ;};_gcfg =_gcfg .walk (_fec );if _gcfg ==nil {continue _afb ;};if !_gcfg ._bgb {continue ;};switch _gcfg ._acgd {case _e :var _bad int ;
if _adc {_bad ,_gafd =_gedg .decodeRun (_gac );}else {_bad ,_gafd =_gedg .decodeRun (_ga );};if _gafd !=nil {return _gafd ;};_adg +=_bad ;_gedg ._ggff [_gedg ._ggb ]=_adg ;_gedg ._ggb ++;if _adc {_bad ,_gafd =_gedg .decodeRun (_ga );}else {_bad ,_gafd =_gedg .decodeRun (_gac );
};if _gafd !=nil {return _gafd ;};_adg +=_bad ;_gedg ._ggff [_gedg ._ggb ]=_adg ;_gedg ._ggb ++;case _c :_acff :=_gedg .getNextChangingElement (_adg ,_adc )+1;if _acff >=_gedg ._bbed {_adg =_gedg ._dge ;}else {_adg =_gedg ._bbe [_acff ];};default:_dfcg :=_gedg .getNextChangingElement (_adg ,_adc );
if _dfcg >=_gedg ._bbed ||_dfcg ==-1{_adg =_gedg ._dge +_gcfg ._acgd ;}else {_adg =_gedg ._bbe [_dfcg ]+_gcfg ._acgd ;};_gedg ._ggff [_gedg ._ggb ]=_adg ;_gedg ._ggb ++;_adc =!_adc ;};continue _afb ;};};return nil ;};func (_eec *Encoder )encodeG31D (_cbc [][]byte )[]byte {var _eeb []byte ;
_fbe :=0;for _acca :=range _cbc {if _eec .Rows > 0&&!_eec .EndOfBlock &&_acca ==_eec .Rows {break ;};_bcd ,_acb :=_bfbfc (_cbc [_acca ],_fbe ,_gbb );_eeb =_eec .appendEncodedRow (_eeb ,_bcd ,_fbe );if _eec .EncodedByteAlign {_acb =0;};_fbe =_acb ;};if _eec .EndOfBlock {_eb ,_ :=_dfcf (_fbe );
_eeb =_eec .appendEncodedRow (_eeb ,_eb ,_fbe );};return _eeb ;};func _ebe (_dgg ,_ebde []byte ,_bgd int ,_dacb bool )int {_cedc :=_dbc (_ebde ,_bgd );if _cedc < len (_ebde )&&(_bgd ==-1&&_ebde [_cedc ]==_dgb ||_bgd >=0&&_bgd < len (_dgg )&&_dgg [_bgd ]==_ebde [_cedc ]||_bgd >=len (_dgg )&&_dacb &&_ebde [_cedc ]==_dgb ||_bgd >=len (_dgg )&&!_dacb &&_ebde [_cedc ]==_cee ){_cedc =_dbc (_ebde ,_cedc );
};return _cedc ;};var (_dd map[int ]code ;_eca map[int ]code ;_aad map[int ]code ;_ecc map[int ]code ;_ef map[int ]code ;_ddg map[int ]byte ;_gbb =code {Code :1<<4,BitsWritten :12};_abf =code {Code :3<<3,BitsWritten :13};_gf =code {Code :2<<3,BitsWritten :13};
_gd =code {Code :1<<12,BitsWritten :4};_eg =code {Code :1<<13,BitsWritten :3};_cb =code {Code :1<<15,BitsWritten :1};_fbc =code {Code :3<<13,BitsWritten :3};_dgc =code {Code :3<<10,BitsWritten :6};_bbaa =code {Code :3<<9,BitsWritten :7};_fg =code {Code :2<<13,BitsWritten :3};
_ccab =code {Code :2<<10,BitsWritten :6};_dgf =code {Code :2<<9,BitsWritten :7};);func (_eeed *treeNode )walk (_fce bool )*treeNode {if _fce {return _eeed ._cdf ;};return _eeed ._gab ;};var (_cd =_g .New ("\u0063\u0063\u0069\u0074tf\u0061\u0078\u0020\u0063\u006f\u0072\u0072\u0075\u0070\u0074\u0065\u0064\u0020\u0052T\u0043");
_ggc =_g .New ("\u0063\u0063\u0069\u0074tf\u0061\u0078\u0020\u0045\u004f\u004c\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064"););type tree struct{_fdg *treeNode };func (_gec *Decoder )decodeRowType2 ()error {if _gec ._fba {_gec ._bab .Align ();
};if _ddd :=_gec .decode1D ();_ddd !=nil {return _ddd ;};return nil ;};func _abffd (_aca []byte ,_cbb ,_cad ,_gefe int )([]byte ,int ){_gdc :=_ebeb (_cad ,_gefe );_aca ,_cbb =_dfgc (_aca ,_cbb ,_gdc );return _aca ,_cbb ;};func (_ee tiffType )String ()string {switch _ee {case _fgb :return "\u0074\u0069\u0066\u0066\u0054\u0079\u0070\u0065\u004d\u006f\u0064i\u0066\u0069\u0065\u0064\u0048\u0075\u0066\u0066\u006d\u0061n\u0052\u006c\u0065";
case _aae :return "\u0074\u0069\u0066\u0066\u0054\u0079\u0070\u0065\u0054\u0034";case _bge :return "\u0074\u0069\u0066\u0066\u0054\u0079\u0070\u0065\u0054\u0036";default:return "\u0075n\u0064\u0065\u0066\u0069\u006e\u0065d";};};func (_ea *Decoder )fetch ()error {if _ea ._ac ==-1{return nil ;
};if _ea ._ggcc < _ea ._ac {return nil ;};_ea ._ac =0;_aaee :=_ea .decodeRow ();if _aaee !=nil {if !_g .Is (_aaee ,_gg .EOF ){return _aaee ;};if _ea ._ac !=0{return _aaee ;};_ea ._ac =-1;};_ea ._ggcc =0;return nil ;};func _dgcdd (_dddc ,_acd []byte ,_bcc ,_ebf ,_eecb int )([]byte ,int ,int ){_ada :=_dbc (_dddc ,_eecb );
_afa :=_ebf >=0&&_dddc [_ebf ]==_dgb ||_ebf ==-1;_acd ,_bcc =_dfgc (_acd ,_bcc ,_eg );var _cgc int ;if _ebf > -1{_cgc =_eecb -_ebf ;}else {_cgc =_eecb -_ebf -1;};_acd ,_bcc =_bfbfcd (_acd ,_bcc ,_cgc ,_afa );_afa =!_afa ;_eceb :=_ada -_eecb ;_acd ,_bcc =_bfbfcd (_acd ,_bcc ,_eceb ,_afa );
_ebf =_ada ;return _acd ,_bcc ,_ebf ;};func _bfbfcd (_bea []byte ,_bbac int ,_gdbbd int ,_aab bool )([]byte ,int ){var (_gagc code ;_bcg bool ;);for !_bcg {_gagc ,_gdbbd ,_bcg =_ccg (_gdbbd ,_aab );_bea ,_bbac =_dfgc (_bea ,_bbac ,_gagc );};return _bea ,_bbac ;
};func NewDecoder (data []byte ,options DecodeOptions )(*Decoder ,error ){_edc :=&Decoder {_bab :_d .NewReader (data ),_dge :options .Columns ,_efe :options .Rows ,_bbgg :options .DamagedRowsBeforeError ,_ddb :make ([]byte ,(options .Columns +7)/8),_bbe :make ([]int ,options .Columns +2),_ggff :make ([]int ,options .Columns +2),_fba :options .EncodedByteAligned ,_ag :options .BlackIsOne ,_ecaa :options .EndOfLine ,_afg :options .EndOfBlock };
switch {case options .K ==0:_edc ._gaf =_aae ;if len (data )< 20{return nil ,_g .New ("\u0074o\u006f\u0020\u0073\u0068o\u0072\u0074\u0020\u0063\u0063i\u0074t\u0066a\u0078\u0020\u0073\u0074\u0072\u0065\u0061m");};_gcf :=data [:20];if _gcf [0]!=0||(_gcf [1]>>4!=1&&_gcf [1]!=1){_edc ._gaf =_fgb ;
_acc :=(uint16 (_gcf [0])<<8+uint16 (_gcf [1]&0xff))>>4;for _bfbf :=12;_bfbf < 160;_bfbf ++{_acc =(_acc <<1)+uint16 ((_gcf [_bfbf /8]>>uint16 (7-(_bfbf %8)))&0x01);if _acc &0xfff==1{_edc ._gaf =_aae ;break ;};};};case options .K < 0:_edc ._gaf =_bge ;case options .K > 0:_edc ._gaf =_aae ;
_edc ._gcb =true ;};switch _edc ._gaf {case _fgb ,_aae ,_bge :default:return nil ,_g .New ("\u0075\u006ek\u006e\u006f\u0077\u006e\u0020\u0063\u0063\u0069\u0074\u0074\u0066\u0061\u0078\u002e\u0044\u0065\u0063\u006f\u0064\u0065\u0072\u0020ty\u0070\u0065");
};return _edc ,nil ;};func _ccg (_fgd int ,_gbed bool )(code ,int ,bool ){if _fgd < 64{if _gbed {return _eca [_fgd ],0,true ;};return _dd [_fgd ],0,true ;};_ggbgc :=_fgd /64;if _ggbgc > 40{return _ef [2560],_fgd -2560,false ;};if _ggbgc > 27{return _ef [_ggbgc *64],_fgd -_ggbgc *64,false ;
};if _gbed {return _ecc [_ggbgc *64],_fgd -_ggbgc *64,false ;};return _aad [_ggbgc *64],_fgd -_ggbgc *64,false ;};func _faa (_cbd []byte ,_eda bool ,_gde int )(int ,int ){_ebd :=0;for _gde < len (_cbd ){if _eda {if _cbd [_gde ]!=_dgb {break ;};}else {if _cbd [_gde ]!=_cee {break ;
};};_ebd ++;_gde ++;};return _ebd ,_gde ;};type treeNode struct{_gab *treeNode ;_cdf *treeNode ;_acgd int ;_bef bool ;_bgb bool ;};