//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_a "encoding/binary";_g "errors";_dg "fmt";_b "github.com/unidoc/unipdf/v3/common";_de "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_d "io";);func (_aac *Writer )byteCapacity ()int {_bff :=len (_aac ._abe )-_aac ._bdf ;if _aac ._fag !=0{_bff --;
};return _bff ;};func (_gcc *BufferedWriter )expandIfNeeded (_babg int ){if !_gcc .tryGrowByReslice (_babg ){_gcc .grow (_babg );};};func (_eeb *Reader )AbsoluteLength ()uint64 {return uint64 (len (_eeb ._df ._fcd ))};func (_bbec *Writer )UseMSB ()bool {return _bbec ._dfc };
func (_def *Reader )RelativePosition ()int64 {return _def ._ad };func (_db *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _de .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );
};if len (_db ._abb )-1< _db ._gg {_db .expandIfNeeded (1);};_fdc :=_db ._gc ;if _db ._ac {_fdc =7-_db ._gc ;};_db ._abb [_db ._gg ]|=byte (uint16 (bit <<_fdc )&0xff);_db ._gc ++;if _db ._gc ==8{_db ._gg ++;_db ._gc =0;};return nil ;};func (_eg *BufferedWriter )WriteBits (bits uint64 ,number int )(_gcf int ,_bd error ){const _bab ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";
if number < 0||number > 64{return 0,_de .Errorf (_bab ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};_cg :=number /8;if _cg > 0{_ee :=number -_cg *8;for _gd :=_cg -1;_gd >=0;_gd --{_bbc :=byte ((bits >>uint (_gd *8+_ee ))&0xff);if _bd =_eg .WriteByte (_bbc );_bd !=nil {return _gcf ,_de .Wrapf (_bd ,_bab ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_cg -_gd +1);
};};number -=_cg *8;if number ==0{return _cg ,nil ;};};var _bf int ;for _aa :=0;_aa < number ;_aa ++{if _eg ._ac {_bf =int ((bits >>uint (number -1-_aa ))&0x1);}else {_bf =int (bits &0x1);bits >>=1;};if _bd =_eg .WriteBit (_bf );_bd !=nil {return _gcf ,_de .Wrapf (_bd ,_bab ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_aa );
};};return _cg ,nil ;};func (_cd *BufferedWriter )WriteByte (bt byte )error {if _cd ._gg > len (_cd ._abb )-1||(_cd ._gg ==len (_cd ._abb )-1&&_cd ._gc !=0){_cd .expandIfNeeded (1);};_cd .writeByte (bt );return nil ;};func (_ace *Writer )writeByte (_babc byte )error {if _ace ._bdf > len (_ace ._abe )-1{return _d .EOF ;
};if _ace ._bdf ==len (_ace ._abe )-1&&_ace ._fag !=0{return _d .EOF ;};if _ace ._fag ==0{_ace ._abe [_ace ._bdf ]=_babc ;_ace ._bdf ++;return nil ;};if _ace ._dfc {_ace ._abe [_ace ._bdf ]|=_babc >>_ace ._fag ;_ace ._bdf ++;_ace ._abe [_ace ._bdf ]=byte (uint16 (_babc )<<(8-_ace ._fag )&0xff);
}else {_ace ._abe [_ace ._bdf ]|=byte (uint16 (_babc )<<_ace ._fag &0xff);_ace ._bdf ++;_ace ._abe [_ace ._bdf ]=_babc >>(8-_ace ._fag );};return nil ;};func (_bag *BufferedWriter )writeShiftedBytes (_cc []byte )int {for _ ,_egg :=range _cc {_bag .writeByte (_egg );
};return len (_cc );};type readerSource struct{_fcd []byte ;_gb int ;_fb int ;};type BinaryWriter interface{BitWriter ;_d .Writer ;_d .ByteWriter ;Data ()[]byte ;};func (_dede *Reader )AbsolutePosition ()int64 {return _dede ._ad +int64 (_dede ._df ._gb )};
func (_gged *Reader )ReadBool ()(bool ,error ){return _gged .readBool ()};func (_ccb *Reader )Mark (){_ccb ._ea =_ccb ._ad ;_ccb ._fc =_ccb ._agg ;_ccb ._abc =_ccb ._cdb ;_ccb ._acfb =_ccb ._dga ;};func (_dbd *BufferedWriter )grow (_dbe int ){if _dbd ._abb ==nil &&_dbe < _f {_dbd ._abb =make ([]byte ,_dbe ,_f );
return ;};_aed :=len (_dbd ._abb );if _dbd ._gc !=0{_aed ++;};_gac :=cap (_dbd ._abb );switch {case _dbe <=_gac /2-_aed :_b .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_dbd ._abb ),cap (_dbd ._abb ),_dbe );
_b .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_gac ,_aed );copy (_dbd ._abb ,_dbd ._abb [_dbd .fullOffset ():]);
case _gac > _ab -_gac -_dbe :_b .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_acf :=make ([]byte ,2*_gac +_dbe );copy (_acf ,_dbd ._abb );_dbd ._abb =_acf ;};_dbd ._abb =_dbd ._abb [:_aed +_dbe ];
};func (_feg *Reader )ConsumeRemainingBits ()(uint64 ,error ){if _feg ._agg !=0{return _feg .ReadBits (_feg ._agg );};return 0,nil ;};func (_fd *BufferedWriter )Reset (){_fd ._abb =_fd ._abb [:0];_fd ._gg =0;_fd ._gc =0};func (_dfb *Writer )WriteBits (bits uint64 ,number int )(_gda int ,_ebe error ){const _bbf ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";
if number < 0||number > 64{return 0,_de .Errorf (_bbf ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};if number ==0{return 0,nil ;};_da :=number /8;if _da > 0{_cfe :=number -_da *8;for _dda :=_da -1;_dda >=0;_dda --{_cbfd :=byte ((bits >>uint (_dda *8+_cfe ))&0xff);if _ebe =_dfb .WriteByte (_cbfd );_ebe !=nil {return _gda ,_de .Wrapf (_ebe ,_bbf ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_da -_dda +1);
};};number -=_da *8;if number ==0{return _da ,nil ;};};var _gdb int ;for _dbg :=0;_dbg < number ;_dbg ++{if _dfb ._dfc {_gdb =int ((bits >>uint (number -1-_dbg ))&0x1);}else {_gdb =int (bits &0x1);bits >>=1;};if _ebe =_dfb .WriteBit (_gdb );_ebe !=nil {return _gda ,_de .Wrapf (_ebe ,_bbf ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_dbg );
};};return _da ,nil ;};func (_abd *Writer )SkipBits (skip int )error {const _eb ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";if skip ==0{return nil ;};_dcb :=int (_abd ._fag )+skip ;if _dcb >=0&&_dcb < 8{_abd ._fag =uint8 (_dcb );
return nil ;};_dcb =int (_abd ._fag )+_abd ._bdf *8+skip ;if _dcb < 0{return _de .Errorf (_eb ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_aca :=_dcb /8;_fdf :=_dcb %8;_b .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");
_b .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_abd ._fag ,_abd ._bdf ,int (_abd ._fag )+(_abd ._bdf )*8,len (_abd ._abe ),cap (_abd ._abe ));
_b .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_dcb ,_fdf );_abd ._fag =uint8 (_fdf );if _ggc :=_aca -_abd ._bdf ;
_ggc > 0&&len (_abd ._abe )-1< _aca {_b .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_ggc );return _de .Errorf (_eb ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_abd ._bdf =_aca ;
_b .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_abd ._fag ,_abd ._bdf );return nil ;};func (_eggb *Writer )ResetBit (){_eggb ._fag =0};
func (_ecc *Reader )NewPartialReader (offset ,length int ,relative bool )(*Reader ,error ){if offset < 0{return nil ,_g .New ("p\u0061\u0072\u0074\u0069\u0061\u006c\u0020\u0072\u0065\u0061\u0064\u0065\u0072\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062e \u006e\u0065\u0067a\u0074i\u0076\u0065");
};if relative {offset =_ecc ._df ._gb +offset ;};if length > 0{_cbd :=len (_ecc ._df ._fcd );if relative {_cbd =_ecc ._df ._fb ;};if offset +length > _cbd {return nil ,_dg .Errorf ("\u0070\u0061r\u0074\u0069\u0061l\u0020\u0072\u0065\u0061\u0064e\u0072\u0020\u006f\u0066\u0066se\u0074\u0028\u0025\u0064\u0029\u002b\u006c\u0065\u006e\u0067\u0074\u0068\u0028\u0025\u0064\u0029\u003d\u0025d\u0020i\u0073\u0020\u0067\u0072\u0065\u0061ter\u0020\u0074\u0068\u0061\u006e\u0020\u0074\u0068\u0065\u0020\u006f\u0072ig\u0069n\u0061\u006c\u0020\u0072e\u0061d\u0065r\u0020\u006ce\u006e\u0067th\u003a\u0020\u0025\u0064",offset ,length ,offset +length ,_ecc ._df ._fb );
};};if length < 0{_acfg :=len (_ecc ._df ._fcd );if relative {_acfg =_ecc ._df ._fb ;};length =_acfg -offset ;};return &Reader {_df :readerSource {_fcd :_ecc ._df ._fcd ,_fb :length ,_gb :offset }},nil ;};func (_ecf *Reader )readBool ()(_bef bool ,_cac error ){if _ecf ._agg ==0{_ecf ._cdb ,_cac =_ecf .readBufferByte ();
if _cac !=nil {return false ,_cac ;};_bef =(_ecf ._cdb &0x80)!=0;_ecf ._cdb ,_ecf ._agg =_ecf ._cdb &0x7f,7;return _bef ,nil ;};_ecf ._agg --;_bef =(_ecf ._cdb &(1<<_ecf ._agg ))!=0;_ecf ._cdb &=1<<_ecf ._agg -1;return _bef ,nil ;};func (_ecbc *Writer )writeBit (_cef uint8 )error {if len (_ecbc ._abe )-1< _ecbc ._bdf {return _d .EOF ;
};_bcge :=_ecbc ._fag ;if _ecbc ._dfc {_bcge =7-_ecbc ._fag ;};_ecbc ._abe [_ecbc ._bdf ]|=byte (uint16 (_cef <<_bcge )&0xff);_ecbc ._fag ++;if _ecbc ._fag ==8{_ecbc ._bdf ++;_ecbc ._fag =0;};return nil ;};func (_bb *BufferedWriter )Len ()int {return _bb .byteCapacity ()};
var _ _d .Writer =&BufferedWriter {};type StreamReader interface{_d .Reader ;_d .ByteReader ;_d .Seeker ;Align ()byte ;BitPosition ()int ;Mark ();Length ()uint64 ;ReadBit ()(int ,error );ReadBits (_bce byte )(uint64 ,error );ReadBool ()(bool ,error );ReadUint32 ()(uint32 ,error );
Reset ();AbsolutePosition ()int64 ;};type Writer struct{_abe []byte ;_fag uint8 ;_bdf int ;_dfc bool ;};func (_bbe *Reader )readUnalignedByte ()(_bagg byte ,_egb error ){_fgd :=_bbe ._agg ;_bagg =_bbe ._cdb <<(8-_fgd );_bbe ._cdb ,_egb =_bbe .readBufferByte ();
if _egb !=nil {return 0,_egb ;};_bagg |=_bbe ._cdb >>_fgd ;_bbe ._cdb &=1<<_fgd -1;return _bagg ,nil ;};func (_bad *Reader )BitPosition ()int {return int (_bad ._agg )};var (_ _d .Reader =&Reader {};_ _d .ByteReader =&Reader {};_ _d .Seeker =&Reader {};
_ StreamReader =&Reader {};);func (_aga *Reader )ReadByte ()(byte ,error ){if _aga ._agg ==0{return _aga .readBufferByte ();};return _aga .readUnalignedByte ();};func (_fce *Reader )Align ()(_afb byte ){_afb =_fce ._agg ;_fce ._agg =0;return _afb };const (_f =64;
_ab =int (^uint (0)>>1););var _ BinaryWriter =&Writer {};func (_gcbc *Reader )Reset (){_gcbc ._ad =_gcbc ._ea ;_gcbc ._agg =_gcbc ._fc ;_gcbc ._cdb =_gcbc ._abc ;_gcbc ._dga =_gcbc ._acfb ;};func (_dc *Reader )ReadUint32 ()(uint32 ,error ){_bfa :=make ([]byte ,4);
_ ,_ggg :=_dc .Read (_bfa );if _ggg !=nil {return 0,_ggg ;};return _a .BigEndian .Uint32 (_bfa ),nil ;};func (_egf *BufferedWriter )writeFullBytes (_fgf []byte )int {_gdf :=copy (_egf ._abb [_egf .fullOffset ():],_fgf );_egf ._gg +=_gdf ;return _gdf ;};
func (_cdg *BufferedWriter )writeByte (_ag byte ){switch {case _cdg ._gc ==0:_cdg ._abb [_cdg ._gg ]=_ag ;_cdg ._gg ++;case _cdg ._ac :_cdg ._abb [_cdg ._gg ]|=_ag >>_cdg ._gc ;_cdg ._gg ++;_cdg ._abb [_cdg ._gg ]=byte (uint16 (_ag )<<(8-_cdg ._gc )&0xff);
default:_cdg ._abb [_cdg ._gg ]|=byte (uint16 (_ag )<<_cdg ._gc &0xff);_cdg ._gg ++;_cdg ._abb [_cdg ._gg ]=_ag >>(8-_cdg ._gc );};};func (_ccg *Reader )ReadBits (n byte )(_agc uint64 ,_ccc error ){if n < _ccg ._agg {_gdd :=_ccg ._agg -n ;_agc =uint64 (_ccg ._cdb >>_gdd );
_ccg ._cdb &=1<<_gdd -1;_ccg ._agg =_gdd ;return _agc ,nil ;};if n > _ccg ._agg {if _ccg ._agg > 0{_agc =uint64 (_ccg ._cdb );n -=_ccg ._agg ;};for n >=8{_gbd ,_bdb :=_ccg .readBufferByte ();if _bdb !=nil {return 0,_bdb ;};_agc =_agc <<8+uint64 (_gbd );
n -=8;};if n > 0{if _ccg ._cdb ,_ccc =_ccg .readBufferByte ();_ccc !=nil {return 0,_ccc ;};_ded :=8-n ;_agc =_agc <<n +uint64 (_ccg ._cdb >>_ded );_ccg ._cdb &=1<<_ded -1;_ccg ._agg =_ded ;}else {_ccg ._agg =0;};return _agc ,nil ;};_ccg ._agg =0;return uint64 (_ccg ._cdb ),nil ;
};type Reader struct{_df readerSource ;_cdb byte ;_agg byte ;_ad int64 ;_dga int ;_ecb int ;_ea int64 ;_fc byte ;_abc byte ;_acfb int ;};func (_ce *Writer )WriteByte (c byte )error {return _ce .writeByte (c )};func (_ae *BufferedWriter )ResetBitIndex (){_ae ._gc =0};
func (_deg *Reader )readBufferByte ()(byte ,error ){if _deg ._ad >=int64 (_deg ._df ._fb ){return 0,_d .EOF ;};_deg ._ecb =-1;_gdfa :=_deg ._df ._fcd [int64 (_deg ._df ._gb )+_deg ._ad ];_deg ._ad ++;_deg ._dga =int (_gdfa );return _gdfa ,nil ;};func (_bg *Writer )FinishByte (){if _bg ._fag ==0{return ;
};_bg ._fag =0;_bg ._bdf ++;};func (_dgc *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;};_dee :=int (_dgc ._gc )+skip ;if _dee >=0&&_dee < 8{_dgc ._gc =uint8 (_dee );return nil ;};_dee =int (_dgc ._gc )+_dgc ._gg *8+skip ;if _dee < 0{return _de .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_ec :=_dee /8;_fa :=_dee %8;_dgc ._gc =uint8 (_fa );if _ga :=_ec -_dgc ._gg ;_ga > 0&&len (_dgc ._abb )-1< _ec {if _dgc ._gc !=0{_ga ++;};_dgc .expandIfNeeded (_ga );};_dgc ._gg =_ec ;return nil ;};func (_aee *BufferedWriter )tryGrowByReslice (_cf int )bool {if _cgb :=len (_aee ._abb );
_cf <=cap (_aee ._abb )-_cgb {_aee ._abb =_aee ._abb [:_cgb +_cf ];return true ;};return false ;};func (_be *BufferedWriter )byteCapacity ()int {_ca :=len (_be ._abb )-_be ._gg ;if _be ._gc !=0{_ca --;};return _ca ;};func (_bac *Reader )Read (p []byte )(_add int ,_fff error ){if _bac ._agg ==0{return _bac .read (p );
};for ;_add < len (p );_add ++{if p [_add ],_fff =_bac .readUnalignedByte ();_fff !=nil {return 0,_fff ;};};return _add ,nil ;};func NewReader (data []byte )*Reader {return &Reader {_df :readerSource {_fcd :data ,_fb :len (data ),_gb :0}};};func (_cbg *Writer )Data ()[]byte {return _cbg ._abe };
func NewWriterMSB (data []byte )*Writer {return &Writer {_abe :data ,_dfc :true }};func (_ge *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _ge .writeBit (uint8 (bit ));};return _de .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");
};var _ BinaryWriter =&BufferedWriter {};func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_ac :true }};func (_cdd *Writer )Write (p []byte )(int ,error ){if len (p )> _cdd .byteCapacity (){return 0,_d .EOF ;};for _ ,_faa :=range p {if _ef :=_cdd .writeByte (_faa );
_ef !=nil {return 0,_ef ;};};return len (p ),nil ;};var _ _d .ByteWriter =&BufferedWriter {};func (_cbf *BufferedWriter )fullOffset ()int {_fg :=_cbf ._gg ;if _cbf ._gc !=0{_fg ++;};return _fg ;};func (_ff *Reader )Length ()uint64 {return uint64 (_ff ._df ._fb )};
type BitWriter interface{WriteBit (_beg int )error ;WriteBits (_gge uint64 ,_ecd int )(_egfa int ,_cfa error );FinishByte ();SkipBits (_aae int )error ;};type BufferedWriter struct{_abb []byte ;_gc uint8 ;_gg int ;_ac bool ;};func (_ddg *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_ddg ._ecb =-1;
_ddg ._agg =0;_ddg ._cdb =0;_ddg ._dga =0;var _ddc int64 ;switch whence {case _d .SeekStart :_ddc =offset ;case _d .SeekCurrent :_ddc =_ddg ._ad +offset ;case _d .SeekEnd :_ddc =int64 (_ddg ._df ._fb )+offset ;default:return 0,_g .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};if _ddc < 0{return 0,_g .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");};_ddg ._ad =_ddc ;
_ddg ._agg =0;return _ddc ,nil ;};func NewWriter (data []byte )*Writer {return &Writer {_abe :data }};func (_fcb *Reader )read (_aba []byte )(int ,error ){if _fcb ._ad >=int64 (_fcb ._df ._fb ){return 0,_d .EOF ;};_fcb ._ecb =-1;_cgg :=copy (_aba ,_fcb ._df ._fcd [(int64 (_fcb ._df ._gb )+_fcb ._ad ):(_fcb ._df ._gb +_fcb ._df ._fb )]);
_fcb ._ad +=int64 (_cgg );return _cgg ,nil ;};func (_fea *Reader )ReadBit ()(_dd int ,_gf error ){_gcb ,_gf :=_fea .readBool ();if _gf !=nil {return 0,_gf ;};if _gcb {_dd =1;};return _dd ,nil ;};func (_cb *BufferedWriter )Write (d []byte )(int ,error ){_cb .expandIfNeeded (len (d ));
if _cb ._gc ==0{return _cb .writeFullBytes (d ),nil ;};return _cb .writeShiftedBytes (d ),nil ;};func (_fe *BufferedWriter )Data ()[]byte {return _fe ._abb };func (_ba *BufferedWriter )FinishByte (){if _ba ._gc ==0{return ;};_ba ._gc =0;_ba ._gg ++;};