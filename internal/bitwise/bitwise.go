//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_e "encoding/binary";_ab "errors";_g "github.com/unidoc/unipdf/v3/common";_ac "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_a "io";);func (_edg *Reader )ReadBool ()(bool ,error ){return _edg .readBool ()};var (_ _a .Reader =&Reader {};_ _a .ByteReader =&Reader {};_ _a .Seeker =&Reader {};_ StreamReader =&Reader {};);func (_aga *SubstreamReader )ReadBit ()(_cdf int ,_ff error ){_gde ,_ff :=_aga .readBool ();if _ff !=nil {return 0,_ff ;};if _gde {_cdf =1;};return _cdf ,nil ;};func (_dee *SubstreamReader )Align ()(_fdb byte ){_fdb =_dee ._bcc ;_dee ._bcc =0;return _fdb };func (_cd *BufferedWriter )tryGrowByReslice (_aaa int )bool {if _cbd :=len (_cd ._ae );_aaa <=cap (_cd ._ae )-_cbd {_cd ._ae =_cd ._ae [:_cbd +_aaa ];return true ;};return false ;};func (_bgg *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _ac .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );};if len (_bgg ._ae )-1< _bgg ._ef {_bgg .expandIfNeeded (1);};_fe :=_bgg ._b ;if _bgg ._f {_fe =7-_bgg ._b ;};_bgg ._ae [_bgg ._ef ]|=byte (uint16 (bit <<_fe )&0xff);_bgg ._b ++;if _bgg ._b ==8{_bgg ._ef ++;_bgg ._b =0;};return nil ;};func (_df *BufferedWriter )Write (d []byte )(int ,error ){_df .expandIfNeeded (len (d ));if _df ._b ==0{return _df .writeFullBytes (d ),nil ;};return _df .writeShiftedBytes (d ),nil ;};func (_d *BufferedWriter )Data ()[]byte {return _d ._ae };func (_bg *BufferedWriter )FinishByte (){if _bg ._b ==0{return ;};_bg ._b =0;_bg ._ef ++;};func (_aaf *SubstreamReader )Offset ()uint64 {return _aaf ._afa };func (_cde *SubstreamReader )fillBuffer ()error {if uint64 (_cde ._afe .StreamPosition ())!=_cde ._ddg +_cde ._afa {_ ,_fda :=_cde ._afe .Seek (int64 (_cde ._ddg +_cde ._afa ),_a .SeekStart );if _fda !=nil {return _fda ;};};_cde ._cgg =uint64 (_cde ._ddg );_baa :=_aee (uint64 (len (_cde ._afg )),_cde ._dgd -_cde ._ddg );_cccc :=make ([]byte ,_baa );_gcd ,_cbb :=_cde ._afe .Read (_cccc );if _cbb !=nil {return _cbb ;};for _fbfa :=uint64 (0);_fbfa < _baa ;_fbfa ++{_cde ._afg [_fbfa ]=_cccc [_fbfa ];};_cde ._cdg =_cde ._cgg +uint64 (_gcd );return nil ;};type BufferedWriter struct{_ae []byte ;_b uint8 ;_ef int ;_f bool ;};func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_f :true }};type BitWriter interface{WriteBit (_dc int )error ;WriteBits (_cag uint64 ,_db int )(_fbc int ,_bc error );FinishByte ();SkipBits (_egdc int )error ;};func (_fbd *Reader )ConsumeRemainingBits (){if _fbd ._eag !=0{_ ,_dfe :=_fbd .ReadBits (_fbd ._eag );if _dfe !=nil {_g .Log .Debug ("\u0043\u006f\u006e\u0073\u0075\u006d\u0065\u0052\u0065\u006da\u0069\u006e\u0069\u0067\u0042\u0069\u0074s\u0020\u0066\u0061\u0069\u006c\u0065\u0064\u003a\u0020\u0025\u0076",_dfe );};};};func (_ed *BufferedWriter )byteCapacity ()int {_aea :=len (_ed ._ae )-_ed ._ef ;if _ed ._b !=0{_aea --;};return _aea ;};func (_cg *BufferedWriter )writeFullBytes (_gbf []byte )int {_ag :=copy (_cg ._ae [_cg .fullOffset ():],_gbf );_cg ._ef +=_ag ;return _ag ;};func (_gcf *SubstreamReader )BitPosition ()int {return int (_gcf ._bcc )};type Writer struct{_bde []byte ;_cfc uint8 ;_effc int ;_dga bool ;};func (_aeaa *Reader )BitPosition ()int {return int (_aeaa ._eag )};func (_beb *Writer )ResetBit (){_beb ._cfc =0};func (_gcg *Reader )readUnalignedByte ()(_adc byte ,_cacc error ){_ead :=_gcg ._eag ;_adc =_gcg ._ga <<(8-_ead );_gcg ._ga ,_cacc =_gcg .readBufferByte ();if _cacc !=nil {return 0,_cacc ;};_adc |=_gcg ._ga >>_ead ;_gcg ._ga &=1<<_ead -1;return _adc ,nil ;};func (_bga *SubstreamReader )readBool ()(_bcd bool ,_gec error ){if _bga ._bcc ==0{_bga ._bfa ,_gec =_bga .readBufferByte ();if _gec !=nil {return false ,_gec ;};_bcd =(_bga ._bfa &0x80)!=0;_bga ._bfa ,_bga ._bcc =_bga ._bfa &0x7f,7;return _bcd ,nil ;};_bga ._bcc --;_bcd =(_bga ._bfa &(1<<_bga ._bcc ))!=0;_bga ._bfa &=1<<_bga ._bcc -1;return _bcd ,nil ;};func (_cacf *Writer )Write (p []byte )(int ,error ){if len (p )> _cacf .byteCapacity (){return 0,_a .EOF ;};for _ ,_cgf :=range p {if _dcc :=_cacf .writeByte (_cgf );_dcc !=nil {return 0,_dcc ;};};return len (p ),nil ;};var _ BinaryWriter =&BufferedWriter {};func (_bfcc *Writer )WriteByte (c byte )error {return _bfcc .writeByte (c )};func (_fg *BufferedWriter )WriteByte (bt byte )error {if _fg ._ef > len (_fg ._ae )-1||(_fg ._ef ==len (_fg ._ae )-1&&_fg ._b !=0){_fg .expandIfNeeded (1);};_fg .writeByte (bt );return nil ;};func (_dabb *SubstreamReader )Length ()uint64 {return _dabb ._dgd };func (_cb *BufferedWriter )ResetBitIndex (){_cb ._b =0};type BinaryWriter interface{BitWriter ;_a .Writer ;_a .ByteWriter ;Data ()[]byte ;};func (_ce *SubstreamReader )Seek (offset int64 ,whence int )(int64 ,error ){switch whence {case _a .SeekStart :_ce ._ddg =uint64 (offset );case _a .SeekCurrent :_ce ._ddg +=uint64 (offset );case _a .SeekEnd :_ce ._ddg =_ce ._dgd +uint64 (offset );default:return 0,_ab .New ("\u0072\u0065\u0061d\u0065\u0072\u002e\u0053\u0075\u0062\u0073\u0074\u0072\u0065\u0061\u006d\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u0020\u0069\u006e\u0076\u0061\u006ci\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");};_ce ._bcc =0;return int64 (_ce ._ddg ),nil ;};func (_cce *SubstreamReader )Reset (){_cce ._ddg =_cce ._ba ;_cce ._bcc =_cce ._bae };func (_gfa *Reader )ReadBits (n byte )(_fac uint64 ,_fdd error ){if n < _gfa ._eag {_fgb :=_gfa ._eag -n ;_fac =uint64 (_gfa ._ga >>_fgb );_gfa ._ga &=1<<_fgb -1;_gfa ._eag =_fgb ;return _fac ,nil ;};if n > _gfa ._eag {if _gfa ._eag > 0{_fac =uint64 (_gfa ._ga );n -=_gfa ._eag ;};for n >=8{_fgc ,_gd :=_gfa .readBufferByte ();if _gd !=nil {return 0,_gd ;};_fac =_fac <<8+uint64 (_fgc );n -=8;};if n > 0{if _gfa ._ga ,_fdd =_gfa .readBufferByte ();_fdd !=nil {return 0,_fdd ;};_ddb :=8-n ;_fac =_fac <<n +uint64 (_gfa ._ga >>_ddb );_gfa ._ga &=1<<_ddb -1;_gfa ._eag =_ddb ;}else {_gfa ._eag =0;};return _fac ,nil ;};_gfa ._eag =0;return uint64 (_gfa ._ga ),nil ;};func (_bb *Reader )read (_ad []byte )(int ,error ){if _bb ._bgf >=int64 (len (_bb ._bfe )){return 0,_a .EOF ;};_bb ._gbe =-1;_gag :=copy (_ad ,_bb ._bfe [_bb ._bgf :]);_bb ._bgf +=int64 (_gag );return _gag ,nil ;};func (_bggd *Reader )readBufferByte ()(byte ,error ){if _bggd ._bgf >=int64 (len (_bggd ._bfe )){return 0,_a .EOF ;};_bggd ._gbe =-1;_cfa :=_bggd ._bfe [_bggd ._bgf ];_bggd ._bgf ++;_bggd ._afb =int (_cfa );return _cfa ,nil ;};func (_abf *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;};_fcg :=int (_abf ._b )+skip ;if _fcg >=0&&_fcg < 8{_abf ._b =uint8 (_fcg );return nil ;};_fcg =int (_abf ._b )+_abf ._ef *8+skip ;if _fcg < 0{return _ac .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_dg :=_fcg /8;_ec :=_fcg %8;_abf ._b =uint8 (_ec );if _gb :=_dg -_abf ._ef ;_gb > 0&&len (_abf ._ae )-1< _dg {if _abf ._b !=0{_gb ++;};_abf .expandIfNeeded (_gb );};_abf ._ef =_dg ;return nil ;};func NewWriterMSB (data []byte )*Writer {return &Writer {_bde :data ,_dga :true }};func (_fb *BufferedWriter )Reset (){_fb ._ae =_fb ._ae [:0];_fb ._ef =0;_fb ._b =0};func (_fbcg *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _fbcg .writeBit (uint8 (bit ));};return _ac .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");};func (_dab *Reader )ReadByte ()(byte ,error ){if _dab ._eag ==0{return _dab .readBufferByte ();};return _dab .readUnalignedByte ();};func (_ccc *SubstreamReader )ReadByte ()(byte ,error ){if _ccc ._bcc ==0{return _ccc .readBufferByte ();};return _ccc .readUnalignedByte ();};type StreamReader interface{_a .Reader ;_a .ByteReader ;_a .Seeker ;Align ()byte ;BitPosition ()int ;Mark ();Length ()uint64 ;ReadBit ()(int ,error );ReadBits (_bcg byte )(uint64 ,error );ReadBool ()(bool ,error );ReadUint32 ()(uint32 ,error );Reset ();StreamPosition ()int64 ;};func (_fee *Reader )Reset (){_fee ._bgf =_fee ._dca ;_fee ._eag =_fee ._da };func (_bdg *Reader )readBool ()(_eeb bool ,_caccc error ){if _bdg ._eag ==0{_bdg ._ga ,_caccc =_bdg .readBufferByte ();if _caccc !=nil {return false ,_caccc ;};_eeb =(_bdg ._ga &0x80)!=0;_bdg ._ga ,_bdg ._eag =_bdg ._ga &0x7f,7;return _eeb ,nil ;};_bdg ._eag --;_eeb =(_bdg ._ga &(1<<_bdg ._eag ))!=0;_bdg ._ga &=1<<_bdg ._eag -1;return _eeb ,nil ;};func _aee (_ccdf ,_add uint64 )uint64 {if _ccdf < _add {return _ccdf ;};return _add ;};var _ _a .Writer =&BufferedWriter {};func (_eea *BufferedWriter )writeShiftedBytes (_cc []byte )int {for _ ,_fcc :=range _cc {_eea .writeByte (_fcc );};return len (_cc );};const (_af =64;_acf =int (^uint (0)>>1););func (_ega *Writer )WriteBits (bits uint64 ,number int )(_gab int ,_ege error ){const _cffg ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";if number < 0||number > 64{return 0,_ac .Errorf (_cffg ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );};if number ==0{return 0,nil ;};_age :=number /8;if _age > 0{_dfec :=number -_age *8;for _cfd :=_age -1;_cfd >=0;_cfd --{_eae :=byte ((bits >>uint (_cfd *8+_dfec ))&0xff);if _ege =_ega .WriteByte (_eae );_ege !=nil {return _gab ,_ac .Wrapf (_ege ,_cffg ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_age -_cfd +1);};};number -=_age *8;if number ==0{return _age ,nil ;};};var _ffe int ;for _egf :=0;_egf < number ;_egf ++{if _ega ._dga {_ffe =int ((bits >>uint (number -1-_egf ))&0x1);}else {_ffe =int (bits &0x1);bits >>=1;};if _ege =_ega .WriteBit (_ffe );_ege !=nil {return _gab ,_ac .Wrapf (_ege ,_cffg ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_egf );};};return _age ,nil ;};func (_bdc *Reader )Read (p []byte )(_eb int ,_gef error ){if _bdc ._eag ==0{return _bdc .read (p );};for ;_eb < len (p );_eb ++{if p [_eb ],_gef =_bdc .readUnalignedByte ();_gef !=nil {return 0,_gef ;};};return _eb ,nil ;};func (_deb *SubstreamReader )ReadUint32 ()(uint32 ,error ){_gba :=make ([]byte ,4);_ ,_dag :=_deb .Read (_gba );if _dag !=nil {return 0,_dag ;};return _e .BigEndian .Uint32 (_gba ),nil ;};func (_eeaf *SubstreamReader )ReadBits (n byte )(_cdb uint64 ,_gbd error ){if n < _eeaf ._bcc {_gbda :=_eeaf ._bcc -n ;_cdb =uint64 (_eeaf ._bfa >>_gbda );_eeaf ._bfa &=1<<_gbda -1;_eeaf ._bcc =_gbda ;return _cdb ,nil ;};if n > _eeaf ._bcc {if _eeaf ._bcc > 0{_cdb =uint64 (_eeaf ._bfa );n -=_eeaf ._bcc ;};var _efg byte ;for n >=8{_efg ,_gbd =_eeaf .readBufferByte ();if _gbd !=nil {return 0,_gbd ;};_cdb =_cdb <<8+uint64 (_efg );n -=8;};if n > 0{if _eeaf ._bfa ,_gbd =_eeaf .readBufferByte ();_gbd !=nil {return 0,_gbd ;};_gbdc :=8-n ;_cdb =_cdb <<n +uint64 (_eeaf ._bfa >>_gbdc );_eeaf ._bfa &=1<<_gbdc -1;_eeaf ._bcc =_gbdc ;}else {_eeaf ._bcc =0;};return _cdb ,nil ;};_eeaf ._bcc =0;return uint64 (_eeaf ._bfa ),nil ;};func (_dbda *SubstreamReader )readUnalignedByte ()(_aead byte ,_fdc error ){_aed :=_dbda ._bcc ;_aead =_dbda ._bfa <<(8-_aed );_dbda ._bfa ,_fdc =_dbda .readBufferByte ();if _fdc !=nil {return 0,_fdc ;};_aead |=_dbda ._bfa >>_aed ;_dbda ._bfa &=1<<_aed -1;return _aead ,nil ;};func (_bgga *BufferedWriter )WriteBits (bits uint64 ,number int )(_fed int ,_be error ){const _bf ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";if number < 0||number > 64{return 0,_ac .Errorf (_bf ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );};_abfd :=number /8;if _abfd > 0{_fga :=number -_abfd *8;for _fgag :=_abfd -1;_fgag >=0;_fgag --{_ee :=byte ((bits >>uint (_fgag *8+_fga ))&0xff);if _be =_bgga .WriteByte (_ee );_be !=nil {return _fed ,_ac .Wrapf (_be ,_bf ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_abfd -_fgag +1);};};number -=_abfd *8;if number ==0{return _abfd ,nil ;};};var _cf int ;for _gc :=0;_gc < number ;_gc ++{if _bgga ._f {_cf =int ((bits >>uint (number -1-_gc ))&0x1);}else {_cf =int (bits &0x1);bits >>=1;};if _be =_bgga .WriteBit (_cf );_be !=nil {return _fed ,_ac .Wrapf (_be ,_bf ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_gc );};};return _abfd ,nil ;};func (_dgb *SubstreamReader )ReadBool ()(bool ,error ){return _dgb .readBool ()};func (_acb *SubstreamReader )readBufferByte ()(byte ,error ){if _acb ._ddg >=_acb ._dgd {return 0,_a .EOF ;};if _acb ._ddg >=_acb ._cdg ||_acb ._ddg < _acb ._cgg {if _ffc :=_acb .fillBuffer ();_ffc !=nil {return 0,_ffc ;};};_egg :=_acb ._afg [_acb ._ddg -_acb ._cgg ];_acb ._ddg ++;return _egg ,nil ;};func (_fbe *BufferedWriter )writeByte (_egd byte ){switch {case _fbe ._b ==0:_fbe ._ae [_fbe ._ef ]=_egd ;_fbe ._ef ++;case _fbe ._f :_fbe ._ae [_fbe ._ef ]|=_egd >>_fbe ._b ;_fbe ._ef ++;_fbe ._ae [_fbe ._ef ]=byte (uint16 (_egd )<<(8-_fbe ._b )&0xff);default:_fbe ._ae [_fbe ._ef ]|=byte (uint16 (_egd )<<_fbe ._b &0xff);_fbe ._ef ++;_fbe ._ae [_fbe ._ef ]=_egd >>(8-_fbe ._b );};};func (_bfd *BufferedWriter )expandIfNeeded (_ged int ){if !_bfd .tryGrowByReslice (_ged ){_bfd .grow (_ged );};};func (_daf *Reader )Align ()(_dbd byte ){_dbd =_daf ._eag ;_daf ._eag =0;return _dbd };func (_bee *Writer )byteCapacity ()int {_bgge :=len (_bee ._bde )-_bee ._effc ;if _bee ._cfc !=0{_bgge --;};return _bgge ;};var _ BinaryWriter =&Writer {};func (_efa *BufferedWriter )fullOffset ()int {_cae :=_efa ._ef ;if _efa ._b !=0{_cae ++;};return _cae ;};func NewSubstreamReader (r StreamReader ,offset ,length uint64 )(*SubstreamReader ,error ){if r ==nil {return nil ,_ab .New ("\u0072o\u006ft\u0020\u0072\u0065\u0061\u0064e\u0072\u0020i\u0073\u0020\u006e\u0069\u006c");};_g .Log .Trace ("\u004e\u0065\u0077\u0053\u0075\u0062\u0073\u0074r\u0065\u0061\u006dRe\u0061\u0064\u0065\u0072\u0020\u0061t\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u003a\u0020\u0025\u0064\u0020\u0077\u0069\u0074h\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a \u0025\u0064",offset ,length );return &SubstreamReader {_afe :r ,_afa :offset ,_dgd :length ,_afg :make ([]byte ,length )},nil ;};func (_fd *Reader )Mark (){_fd ._dca =_fd ._bgf ;_fd ._da =_fd ._eag };func NewReader (data []byte )*Reader {return &Reader {_bfe :data }};func (_dea *Reader )StreamPosition ()int64 {return _dea ._bgf };func (_cac *Reader )ReadUint32 ()(uint32 ,error ){_fgd :=make ([]byte ,4);_ ,_gbb :=_cac .Read (_fgd );if _gbb !=nil {return 0,_gbb ;};return _e .BigEndian .Uint32 (_fgd ),nil ;};func (_egae *Writer )writeBit (_ecb uint8 )error {if len (_egae ._bde )-1< _egae ._effc {return _a .EOF ;};_gg :=_egae ._cfc ;if _egae ._dga {_gg =7-_egae ._cfc ;};_egae ._bde [_egae ._effc ]|=byte (uint16 (_ecb <<_gg )&0xff);_egae ._cfc ++;if _egae ._cfc ==8{_egae ._effc ++;_egae ._cfc =0;};return nil ;};func (_acff *Reader )Length ()uint64 {return uint64 (len (_acff ._bfe ))};func NewWriter (data []byte )*Writer {return &Writer {_bde :data }};func (_fc *BufferedWriter )Len ()int {return _fc .byteCapacity ()};var _ _a .ByteWriter =&BufferedWriter {};func (_edga *SubstreamReader )StreamPosition ()int64 {return int64 (_edga ._ddg )};func (_gca *SubstreamReader )Mark (){_gca ._ba =_gca ._ddg ;_gca ._bae =_gca ._bcc };func (_cff *SubstreamReader )Read (b []byte )(_ece int ,_ccd error ){if _cff ._ddg >=_cff ._dgd {_g .Log .Trace ("\u0053\u0074\u0072e\u0061\u006d\u0050\u006fs\u003a\u0020\u0027\u0025\u0064\u0027\u0020>\u003d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027",_cff ._ddg ,_cff ._dgd );return 0,_a .EOF ;};for ;_ece < len (b );_ece ++{if b [_ece ],_ccd =_cff .readUnalignedByte ();_ccd !=nil {if _ccd ==_a .EOF {return _ece ,nil ;};return 0,_ccd ;};};return _ece ,nil ;};func (_cad *Writer )FinishByte (){if _cad ._cfc ==0{return ;};_cad ._cfc =0;_cad ._effc ++;};func (_fbf *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_fbf ._gbe =-1;var _gda int64 ;switch whence {case _a .SeekStart :_gda =offset ;case _a .SeekCurrent :_gda =_fbf ._bgf +offset ;case _a .SeekEnd :_gda =int64 (len (_fbf ._bfe ))+offset ;default:return 0,_ab .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");};if _gda < 0{return 0,_ab .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");};_fbf ._bgf =_gda ;_fbf ._eag =0;return _gda ,nil ;};func (_dge *Writer )writeByte (_caed byte )error {if _dge ._effc > len (_dge ._bde )-1{return _a .EOF ;};if _dge ._effc ==len (_dge ._bde )-1&&_dge ._cfc !=0{return _a .EOF ;};if _dge ._cfc ==0{_dge ._bde [_dge ._effc ]=_caed ;_dge ._effc ++;return nil ;};if _dge ._dga {_dge ._bde [_dge ._effc ]|=_caed >>_dge ._cfc ;_dge ._effc ++;_dge ._bde [_dge ._effc ]=byte (uint16 (_caed )<<(8-_dge ._cfc )&0xff);}else {_dge ._bde [_dge ._effc ]|=byte (uint16 (_caed )<<_dge ._cfc &0xff);_dge ._effc ++;_dge ._bde [_dge ._effc ]=_caed >>(8-_dge ._cfc );};return nil ;};func (_baeg *Writer )SkipBits (skip int )error {const _bdgg ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";if skip ==0{return nil ;};_dfc :=int (_baeg ._cfc )+skip ;if _dfc >=0&&_dfc < 8{_baeg ._cfc =uint8 (_dfc );return nil ;};_dfc =int (_baeg ._cfc )+_baeg ._effc *8+skip ;if _dfc < 0{return _ac .Errorf (_bdgg ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_fdce :=_dfc /8;_geb :=_dfc %8;_g .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");_g .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_baeg ._cfc ,_baeg ._effc ,int (_baeg ._cfc )+(_baeg ._effc )*8,len (_baeg ._bde ),cap (_baeg ._bde ));_g .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_dfc ,_geb );_baeg ._cfc =uint8 (_geb );if _gcb :=_fdce -_baeg ._effc ;_gcb > 0&&len (_baeg ._bde )-1< _fdce {_g .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_gcb );return _ac .Errorf (_bdgg ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_baeg ._effc =_fdce ;_g .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_baeg ._cfc ,_baeg ._effc );return nil ;};func (_edf *BufferedWriter )grow (_eg int ){if _edf ._ae ==nil &&_eg < _af {_edf ._ae =make ([]byte ,_eg ,_af );return ;};_ea :=len (_edf ._ae );if _edf ._b !=0{_ea ++;};_aa :=cap (_edf ._ae );switch {case _eg <=_aa /2-_ea :_g .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_edf ._ae ),cap (_edf ._ae ),_eg );_g .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_aa ,_ea );copy (_edf ._ae ,_edf ._ae [_edf .fullOffset ():]);case _aa > _acf -_aa -_eg :_g .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_aff :=make ([]byte ,2*_aa +_eg );copy (_aff ,_edf ._ae );_edf ._ae =_aff ;};_edf ._ae =_edf ._ae [:_ea +_eg ];};func (_ccce *Writer )Data ()[]byte {return _ccce ._bde };type SubstreamReader struct{_ddg uint64 ;_afe StreamReader ;_afa uint64 ;_dgd uint64 ;_afg []byte ;_cgg uint64 ;_cdg uint64 ;_bfa byte ;_bcc byte ;_ba uint64 ;_bae byte ;};func (_ebc *Reader )ReadBit ()(_de int ,_gf error ){_bfc ,_gf :=_ebc .readBool ();if _gf !=nil {return 0,_gf ;};if _bfc {_de =1;};return _de ,nil ;};type Reader struct{_bfe []byte ;_ga byte ;_eag byte ;_bgf int64 ;_afb int ;_gbe int ;_dca int64 ;_da byte ;};func (_afd *Writer )UseMSB ()bool {return _afd ._dga };