//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_a "encoding/binary";_b "errors";_g "fmt";_f "github.com/unidoc/unipdf/v3/common";_gb "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_d "io";);func (_fd *BufferedWriter )grow (_gd int ){if _fd ._c ==nil &&_gd < _ab {_fd ._c =make ([]byte ,_gd ,_ab );
return ;};_gfc :=len (_fd ._c );if _fd ._fg !=0{_gfc ++;};_fa :=cap (_fd ._c );switch {case _gd <=_fa /2-_gfc :_f .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_fd ._c ),cap (_fd ._c ),_gd );
_f .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_fa ,_gfc );copy (_fd ._c ,_fd ._c [_fd .fullOffset ():]);
case _fa > _abf -_fa -_gd :_f .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_gad :=make ([]byte ,2*_fa +_gd );copy (_gad ,_fd ._c );_fd ._c =_gad ;};_fd ._c =_fd ._c [:_gfc +_gd ];
};func (_aaf *Writer )writeBit (_dad uint8 )error {if len (_aaf ._fab )-1< _aaf ._fdg {return _d .EOF ;};_fbg :=_aaf ._gcg ;if _aaf ._cdbe {_fbg =7-_aaf ._gcg ;};_aaf ._fab [_aaf ._fdg ]|=byte (uint16 (_dad <<_fbg )&0xff);_aaf ._gcg ++;if _aaf ._gcg ==8{_aaf ._fdg ++;
_aaf ._gcg =0;};return nil ;};func (_acb *Writer )WriteBits (bits uint64 ,number int )(_bdc int ,_fabc error ){const _edg ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";if number < 0||number > 64{return 0,_gb .Errorf (_edg ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};if number ==0{return 0,nil ;};_cdd :=number /8;if _cdd > 0{_aed :=number -_cdd *8;for _cdc :=_cdd -1;_cdc >=0;_cdc --{_abbg :=byte ((bits >>uint (_cdc *8+_aed ))&0xff);if _fabc =_acb .WriteByte (_abbg );_fabc !=nil {return _bdc ,_gb .Wrapf (_fabc ,_edg ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_cdd -_cdc +1);
};};number -=_cdd *8;if number ==0{return _cdd ,nil ;};};var _dbg int ;for _af :=0;_af < number ;_af ++{if _acb ._cdbe {_dbg =int ((bits >>uint (number -1-_af ))&0x1);}else {_dbg =int (bits &0x1);bits >>=1;};if _fabc =_acb .WriteBit (_dbg );_fabc !=nil {return _bdc ,_gb .Wrapf (_fabc ,_edg ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_af );
};};return _cdd ,nil ;};const (_ab =64;_abf =int (^uint (0)>>1););func (_db *Writer )FinishByte (){if _db ._gcg ==0{return ;};_db ._gcg =0;_db ._fdg ++;};func (_ac *BufferedWriter )writeFullBytes (_gga []byte )int {_fgd :=copy (_ac ._c [_ac .fullOffset ():],_gga );
_ac ._ea +=_fgd ;return _fgd ;};func (_egd *BufferedWriter )writeByte (_bbc byte ){switch {case _egd ._fg ==0:_egd ._c [_egd ._ea ]=_bbc ;_egd ._ea ++;case _egd ._bg :_egd ._c [_egd ._ea ]|=_bbc >>_egd ._fg ;_egd ._ea ++;_egd ._c [_egd ._ea ]=byte (uint16 (_bbc )<<(8-_egd ._fg )&0xff);
default:_egd ._c [_egd ._ea ]|=byte (uint16 (_bbc )<<_egd ._fg &0xff);_egd ._ea ++;_egd ._c [_egd ._ea ]=_bbc >>(8-_egd ._fg );};};func (_acf *Writer )WriteByte (c byte )error {return _acf .writeByte (c )};func (_df *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _gb .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );
};if len (_df ._c )-1< _df ._ea {_df .expandIfNeeded (1);};_bgg :=_df ._fg ;if _df ._bg {_bgg =7-_df ._fg ;};_df ._c [_df ._ea ]|=byte (uint16 (bit <<_bgg )&0xff);_df ._fg ++;if _df ._fg ==8{_df ._ea ++;_df ._fg =0;};return nil ;};func (_ecg *Reader )ReadByte ()(byte ,error ){if _ecg ._gdd ==0{return _ecg .readBufferByte ();
};return _ecg .readUnalignedByte ();};func (_acg *Reader )readBufferByte ()(byte ,error ){if _acg ._cb >=int64 (_acg ._add ._bfb ){return 0,_d .EOF ;};_acg ._agg =-1;_fga :=_acg ._add ._bbb [int64 (_acg ._add ._dgca )+_acg ._cb ];_acg ._cb ++;_acg ._ada =int (_fga );
return _fga ,nil ;};func NewReader (data []byte )*Reader {return &Reader {_add :readerSource {_bbb :data ,_bfb :len (data ),_dgca :0}};};func (_cdf *Reader )read (_bgcg []byte )(int ,error ){if _cdf ._cb >=int64 (_cdf ._add ._bfb ){return 0,_d .EOF ;};
_cdf ._agg =-1;_feb :=copy (_bgcg ,_cdf ._add ._bbb [(int64 (_cdf ._add ._dgca )+_cdf ._cb ):(_cdf ._add ._dgca +_cdf ._add ._bfb )]);_cdf ._cb +=int64 (_feb );return _feb ,nil ;};var _ _d .ByteWriter =&BufferedWriter {};func (_gg *BufferedWriter )fullOffset ()int {_dd :=_gg ._ea ;
if _gg ._fg !=0{_dd ++;};return _dd ;};func (_ed *BufferedWriter )byteCapacity ()int {_ec :=len (_ed ._c )-_ed ._ea ;if _ed ._fg !=0{_ec --;};return _ec ;};type BufferedWriter struct{_c []byte ;_fg uint8 ;_ea int ;_bg bool ;};type BitWriter interface{WriteBit (_dgc int )error ;
WriteBits (_abb uint64 ,_gbb int )(_fee int ,_gef error );FinishByte ();SkipBits (_cf int )error ;};func (_dc *BufferedWriter )WriteBits (bits uint64 ,number int )(_bad int ,_cg error ){const _bac ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";
if number < 0||number > 64{return 0,_gb .Errorf (_bac ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};_gf :=number /8;if _gf > 0{_ge :=number -_gf *8;for _bb :=_gf -1;_bb >=0;_bb --{_fc :=byte ((bits >>uint (_bb *8+_ge ))&0xff);if _cg =_dc .WriteByte (_fc );_cg !=nil {return _bad ,_gb .Wrapf (_cg ,_bac ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_gf -_bb +1);
};};number -=_gf *8;if number ==0{return _gf ,nil ;};};var _dac int ;for _ce :=0;_ce < number ;_ce ++{if _dc ._bg {_dac =int ((bits >>uint (number -1-_ce ))&0x1);}else {_dac =int (bits &0x1);bits >>=1;};if _cg =_dc .WriteBit (_dac );_cg !=nil {return _bad ,_gb .Wrapf (_cg ,_bac ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_ce );
};};return _gf ,nil ;};func NewWriterMSB (data []byte )*Writer {return &Writer {_fab :data ,_cdbe :true }};func (_bbf *Reader )ConsumeRemainingBits ()(uint64 ,error ){if _bbf ._gdd !=0{return _bbf .ReadBits (_bbf ._gdd );};return 0,nil ;};type Writer struct{_fab []byte ;
_gcg uint8 ;_fdg int ;_cdbe bool ;};func (_da *BufferedWriter )Reset (){_da ._c =_da ._c [:0];_da ._ea =0;_da ._fg =0};func (_ebd *Reader )readUnalignedByte ()(_egff byte ,_ddb error ){_egg :=_ebd ._gdd ;_egff =_ebd ._cdg <<(8-_egg );_ebd ._cdg ,_ddb =_ebd .readBufferByte ();
if _ddb !=nil {return 0,_ddb ;};_egff |=_ebd ._cdg >>_egg ;_ebd ._cdg &=1<<_egg -1;return _egff ,nil ;};var _ _d .Writer =&BufferedWriter {};func (_bc *BufferedWriter )Write (d []byte )(int ,error ){_bc .expandIfNeeded (len (d ));if _bc ._fg ==0{return _bc .writeFullBytes (d ),nil ;
};return _bc .writeShiftedBytes (d ),nil ;};func (_gaf *BufferedWriter )ResetBitIndex (){_gaf ._fg =0};func (_egc *Reader )Read (p []byte )(_ggc int ,_ggf error ){if _egc ._gdd ==0{return _egc .read (p );};for ;_ggc < len (p );_ggc ++{if p [_ggc ],_ggf =_egc .readUnalignedByte ();
_ggf !=nil {return 0,_ggf ;};};return _ggc ,nil ;};func (_aag *Writer )writeByte (_fbc byte )error {if _aag ._fdg > len (_aag ._fab )-1{return _d .EOF ;};if _aag ._fdg ==len (_aag ._fab )-1&&_aag ._gcg !=0{return _d .EOF ;};if _aag ._gcg ==0{_aag ._fab [_aag ._fdg ]=_fbc ;
_aag ._fdg ++;return nil ;};if _aag ._cdbe {_aag ._fab [_aag ._fdg ]|=_fbc >>_aag ._gcg ;_aag ._fdg ++;_aag ._fab [_aag ._fdg ]=byte (uint16 (_fbc )<<(8-_aag ._gcg )&0xff);}else {_aag ._fab [_aag ._fdg ]|=byte (uint16 (_fbc )<<_aag ._gcg &0xff);_aag ._fdg ++;
_aag ._fab [_aag ._fdg ]=_fbc >>(8-_aag ._gcg );};return nil ;};func (_agb *Reader )ReadBool ()(bool ,error ){return _agb .readBool ()};func (_age *Reader )Mark (){_age ._dde =_age ._cb ;_age ._egb =_age ._gdd ;_age ._bfa =_age ._cdg ;_age ._cbb =_age ._ada ;
};func (_dcd *Reader )Align ()(_dgf byte ){_dgf =_dcd ._gdd ;_dcd ._gdd =0;return _dgf };type BinaryWriter interface{BitWriter ;_d .Writer ;_d .ByteWriter ;Data ()[]byte ;};type readerSource struct{_bbb []byte ;_dgca int ;_bfb int ;};func (_ece *Reader )Reset (){_ece ._cb =_ece ._dde ;
_ece ._gdd =_ece ._egb ;_ece ._cdg =_ece ._bfa ;_ece ._ada =_ece ._cbb ;};func (_ecc *BufferedWriter )expandIfNeeded (_bfd int ){if !_ecc .tryGrowByReslice (_bfd ){_ecc .grow (_bfd );};};func (_de *Writer )ResetBit (){_de ._gcg =0};func (_ggbd *Reader )AbsolutePosition ()int64 {return _ggbd ._cb +int64 (_ggbd ._add ._dgca )};
func (_cgb *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _cgb .writeBit (uint8 (bit ));};return _gb .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");
};func (_fb *Writer )UseMSB ()bool {return _fb ._cdbe };var (_ _d .Reader =&Reader {};_ _d .ByteReader =&Reader {};_ _d .Seeker =&Reader {};_ StreamReader =&Reader {};);func (_cdbc *Reader )RelativePosition ()int64 {return _cdbc ._cb };func (_bd *Writer )Write (p []byte )(int ,error ){if len (p )> _bd .byteCapacity (){return 0,_d .EOF ;
};for _ ,_aa :=range p {if _bdg :=_bd .writeByte (_aa );_bdg !=nil {return 0,_bdg ;};};return len (p ),nil ;};func (_fea *Writer )SkipBits (skip int )error {const _cbgbc ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";
if skip ==0{return nil ;};_dca :=int (_fea ._gcg )+skip ;if _dca >=0&&_dca < 8{_fea ._gcg =uint8 (_dca );return nil ;};_dca =int (_fea ._gcg )+_fea ._fdg *8+skip ;if _dca < 0{return _gb .Errorf (_cbgbc ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_cbbe :=_dca /8;_ef :=_dca %8;_f .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");_f .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_fea ._gcg ,_fea ._fdg ,int (_fea ._gcg )+(_fea ._fdg )*8,len (_fea ._fab ),cap (_fea ._fab ));
_f .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_dca ,_ef );_fea ._gcg =uint8 (_ef );if _ggac :=_cbbe -_fea ._fdg ;
_ggac > 0&&len (_fea ._fab )-1< _cbbe {_f .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_ggac );return _gb .Errorf (_cbgbc ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_fea ._fdg =_cbbe ;_f .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_fea ._gcg ,_fea ._fdg );return nil ;};func (_be *BufferedWriter )FinishByte (){if _be ._fg ==0{return ;
};_be ._fg =0;_be ._ea ++;};func (_gc *BufferedWriter )Data ()[]byte {return _gc ._c };func (_cbgb *Reader )readBool ()(_bbbb bool ,_egda error ){if _cbgb ._gdd ==0{_cbgb ._cdg ,_egda =_cbgb .readBufferByte ();if _egda !=nil {return false ,_egda ;};_bbbb =(_cbgb ._cdg &0x80)!=0;
_cbgb ._cdg ,_cbgb ._gdd =_cbgb ._cdg &0x7f,7;return _bbbb ,nil ;};_cbgb ._gdd --;_bbbb =(_cbgb ._cdg &(1<<_cbgb ._gdd ))!=0;_cbgb ._cdg &=1<<_cbgb ._gdd -1;return _bbbb ,nil ;};func (_cbg *Reader )ReadBit ()(_fcc int ,_egf error ){_bfg ,_egf :=_cbg .readBool ();
if _egf !=nil {return 0,_egf ;};if _bfg {_fcc =1;};return _fcc ,nil ;};func (_bgc *Reader )ReadUint32 ()(uint32 ,error ){_geg :=make ([]byte ,4);_ ,_gce :=_bgc .Read (_geg );if _gce !=nil {return 0,_gce ;};return _a .BigEndian .Uint32 (_geg ),nil ;};func NewWriter (data []byte )*Writer {return &Writer {_fab :data }};
func (_cdb *Reader )Length ()uint64 {return uint64 (_cdb ._add ._bfb )};func (_ag *BufferedWriter )tryGrowByReslice (_ggb int )bool {if _fde :=len (_ag ._c );_ggb <=cap (_ag ._c )-_fde {_ag ._c =_ag ._c [:_fde +_ggb ];return true ;};return false ;};func (_dgg *Reader )NewPartialReader (offset ,length int ,relative bool )(*Reader ,error ){if offset < 0{return nil ,_b .New ("p\u0061\u0072\u0074\u0069\u0061\u006c\u0020\u0072\u0065\u0061\u0064\u0065\u0072\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062e \u006e\u0065\u0067a\u0074i\u0076\u0065");
};if relative {offset =_dgg ._add ._dgca +offset ;};if length > 0{_cec :=len (_dgg ._add ._bbb );if relative {_cec =_dgg ._add ._bfb ;};if offset +length > _cec {return nil ,_g .Errorf ("\u0070\u0061r\u0074\u0069\u0061l\u0020\u0072\u0065\u0061\u0064e\u0072\u0020\u006f\u0066\u0066se\u0074\u0028\u0025\u0064\u0029\u002b\u006c\u0065\u006e\u0067\u0074\u0068\u0028\u0025\u0064\u0029\u003d\u0025d\u0020i\u0073\u0020\u0067\u0072\u0065\u0061ter\u0020\u0074\u0068\u0061\u006e\u0020\u0074\u0068\u0065\u0020\u006f\u0072ig\u0069n\u0061\u006c\u0020\u0072e\u0061d\u0065r\u0020\u006ce\u006e\u0067th\u003a\u0020\u0025\u0064",offset ,length ,offset +length ,_dgg ._add ._bfb );
};};if length < 0{_adab :=len (_dgg ._add ._bbb );if relative {_adab =_dgg ._add ._bfb ;};length =_adab -offset ;};return &Reader {_add :readerSource {_bbb :_dgg ._add ._bbb ,_bfb :length ,_dgca :offset }},nil ;};func (_bggc *Writer )byteCapacity ()int {_fdc :=len (_bggc ._fab )-_bggc ._fdg ;
if _bggc ._gcg !=0{_fdc --;};return _fdc ;};func (_eef *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_eef ._agg =-1;_eef ._gdd =0;_eef ._cdg =0;_eef ._ada =0;var _aec int64 ;switch whence {case _d .SeekStart :_aec =offset ;case _d .SeekCurrent :_aec =_eef ._cb +offset ;
case _d .SeekEnd :_aec =int64 (_eef ._add ._bfb )+offset ;default:return 0,_b .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};if _aec < 0{return 0,_b .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");};_eef ._cb =_aec ;
_eef ._gdd =0;return _aec ,nil ;};type Reader struct{_add readerSource ;_cdg byte ;_gdd byte ;_cb int64 ;_ada int ;_agg int ;_dde int64 ;_egb byte ;_bfa byte ;_cbb int ;};func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_bg :true }};var _ BinaryWriter =&Writer {};
func (_fdd *Reader )BitPosition ()int {return int (_fdd ._gdd )};func (_gaa *BufferedWriter )writeShiftedBytes (_ae []byte )int {for _ ,_adg :=range _ae {_gaa .writeByte (_adg );};return len (_ae );};func (_gba *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;
};_bf :=int (_gba ._fg )+skip ;if _bf >=0&&_bf < 8{_gba ._fg =uint8 (_bf );return nil ;};_bf =int (_gba ._fg )+_gba ._ea *8+skip ;if _bf < 0{return _gb .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_beb :=_bf /8;_bfe :=_bf %8;_gba ._fg =uint8 (_bfe );if _dg :=_beb -_gba ._ea ;_dg > 0&&len (_gba ._c )-1< _beb {if _gba ._fg !=0{_dg ++;};_gba .expandIfNeeded (_dg );};_gba ._ea =_beb ;return nil ;};func (_ee *Reader )AbsoluteLength ()uint64 {return uint64 (len (_ee ._add ._bbb ))};
func (_cfb *Writer )Data ()[]byte {return _cfb ._fab };func (_ga *BufferedWriter )Len ()int {return _ga .byteCapacity ()};func (_ad *BufferedWriter )WriteByte (bt byte )error {if _ad ._ea > len (_ad ._c )-1||(_ad ._ea ==len (_ad ._c )-1&&_ad ._fg !=0){_ad .expandIfNeeded (1);
};_ad .writeByte (bt );return nil ;};type StreamReader interface{_d .Reader ;_d .ByteReader ;_d .Seeker ;Align ()byte ;BitPosition ()int ;Mark ();Length ()uint64 ;ReadBit ()(int ,error );ReadBits (_edc byte )(uint64 ,error );ReadBool ()(bool ,error );ReadUint32 ()(uint32 ,error );
Reset ();AbsolutePosition ()int64 ;};var _ BinaryWriter =&BufferedWriter {};func (_ff *Reader )ReadBits (n byte )(_fdb uint64 ,_cecc error ){if n < _ff ._gdd {_edb :=_ff ._gdd -n ;_fdb =uint64 (_ff ._cdg >>_edb );_ff ._cdg &=1<<_edb -1;_ff ._gdd =_edb ;
return _fdb ,nil ;};if n > _ff ._gdd {if _ff ._gdd > 0{_fdb =uint64 (_ff ._cdg );n -=_ff ._gdd ;};for n >=8{_fef ,_gff :=_ff .readBufferByte ();if _gff !=nil {return 0,_gff ;};_fdb =_fdb <<8+uint64 (_fef );n -=8;};if n > 0{if _ff ._cdg ,_cecc =_ff .readBufferByte ();
_cecc !=nil {return 0,_cecc ;};_cbe :=8-n ;_fdb =_fdb <<n +uint64 (_ff ._cdg >>_cbe );_ff ._cdg &=1<<_cbe -1;_ff ._gdd =_cbe ;}else {_ff ._gdd =0;};return _fdb ,nil ;};_ff ._gdd =0;return uint64 (_ff ._cdg ),nil ;};