//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_f "encoding/binary";_ea "errors";_eac "github.com/unidoc/unipdf/v3/common";_fe "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_a "io";);func NewSubstreamReader (r StreamReader ,offset ,length uint64 )(*SubstreamReader ,error ){if r ==nil {return nil ,_ea .New ("\u0072o\u006ft\u0020\u0072\u0065\u0061\u0064e\u0072\u0020i\u0073\u0020\u006e\u0069\u006c");
};_eac .Log .Trace ("\u004e\u0065\u0077\u0053\u0075\u0062\u0073\u0074r\u0065\u0061\u006dRe\u0061\u0064\u0065\u0072\u0020\u0061t\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u003a\u0020\u0025\u0064\u0020\u0077\u0069\u0074h\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a \u0025\u0064",offset ,length );
return &SubstreamReader {_ace :r ,_feb :offset ,_eba :length ,_eace :make ([]byte ,length )},nil ;};type BufferedWriter struct{_ae []byte ;_c uint8 ;_g int ;_ab bool ;};func (_bba *SubstreamReader )fillBuffer ()error {if uint64 (_bba ._ace .StreamPosition ())!=_bba ._bfac +_bba ._feb {_ ,_dcc :=_bba ._ace .Seek (int64 (_bba ._bfac +_bba ._feb ),_a .SeekStart );
if _dcc !=nil {return _dcc ;};};_bba ._bff =_bba ._bfac ;_bac :=_bcd (uint64 (len (_bba ._eace )),_bba ._eba -_bba ._bfac );_aefc :=make ([]byte ,_bac );_dcd ,_gfba :=_bba ._ace .Read (_aefc );if _gfba !=nil {return _gfba ;};for _gfbg :=uint64 (0);_gfbg < _bac ;
_gfbg ++{_bba ._eace [_gfbg ]=_aefc [_gfbg ];};_bba ._ccf =_bba ._bff +uint64 (_dcd );return nil ;};func (_afg *BufferedWriter )WriteByte (bt byte )error {if _afg ._g > len (_afg ._ae )-1||(_afg ._g ==len (_afg ._ae )-1&&_afg ._c !=0){_afg .expandIfNeeded (1);
};_afg .writeByte (bt );return nil ;};func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_ab :true }};func (_cg *BufferedWriter )Write (d []byte )(int ,error ){_cg .expandIfNeeded (len (d ));if _cg ._c ==0{return _cg .writeFullBytes (d ),nil ;
};return _cg .writeShiftedBytes (d ),nil ;};func (_bdc *Reader )Read (p []byte )(_cf int ,_dbg error ){if _bdc ._dcb ==0{return _bdc .read (p );};for ;_cf < len (p );_cf ++{if p [_cf ],_dbg =_bdc .readUnalignedByte ();_dbg !=nil {return 0,_dbg ;};};return _cf ,nil ;
};func (_gd *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;};_gc :=int (_gd ._c )+skip ;if _gc >=0&&_gc < 8{_gd ._c =uint8 (_gc );return nil ;};_gc =int (_gd ._c )+_gd ._g *8+skip ;if _gc < 0{return _fe .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_ce :=_gc /8;_bf :=_gc %8;_gd ._c =uint8 (_bf );if _fd :=_ce -_gd ._g ;_fd > 0&&len (_gd ._ae )-1< _ce {if _gd ._c !=0{_fd ++;};_gd .expandIfNeeded (_fd );};_gd ._g =_ce ;return nil ;};func (_ebad *SubstreamReader )ReadUint32 ()(uint32 ,error ){_gda :=make ([]byte ,4);
_ ,_adc :=_ebad .Read (_gda );if _adc !=nil {return 0,_adc ;};return _f .BigEndian .Uint32 (_gda ),nil ;};func (_efb *Writer )WriteByte (c byte )error {return _efb .writeByte (c )};func (_aabe *SubstreamReader )Offset ()uint64 {return _aabe ._feb };func (_abg *Reader )ReadBool ()(bool ,error ){return _abg .readBool ()};
func (_cfcd *Writer )ResetBit (){_cfcd ._fad =0};var _ BinaryWriter =&BufferedWriter {};var (_ _a .Reader =&Reader {};_ _a .ByteReader =&Reader {};_ _a .Seeker =&Reader {};_ StreamReader =&Reader {};);func (_ggg *SubstreamReader )readUnalignedByte ()(_fddb byte ,_badf error ){_da :=_ggg ._cdab ;
_fddb =_ggg ._aac <<(8-_da );_ggg ._aac ,_badf =_ggg .readBufferByte ();if _badf !=nil {return 0,_badf ;};_fddb |=_ggg ._aac >>_da ;_ggg ._aac &=1<<_da -1;return _fddb ,nil ;};func (_dfee *SubstreamReader )Mark (){_dfee ._ebe =_dfee ._bfac ;_dfee ._bdce =_dfee ._cdab };
func (_dfe *BufferedWriter )writeByte (_cc byte ){switch {case _dfe ._c ==0:_dfe ._ae [_dfe ._g ]=_cc ;_dfe ._g ++;case _dfe ._ab :_dfe ._ae [_dfe ._g ]|=_cc >>_dfe ._c ;_dfe ._g ++;_dfe ._ae [_dfe ._g ]=byte (uint16 (_cc )<<(8-_dfe ._c )&0xff);default:_dfe ._ae [_dfe ._g ]|=byte (uint16 (_cc )<<_dfe ._c &0xff);
_dfe ._g ++;_dfe ._ae [_dfe ._g ]=_cc >>(8-_dfe ._c );};};func (_cac *SubstreamReader )ReadByte ()(byte ,error ){if _cac ._cdab ==0{return _cac .readBufferByte ();};return _cac .readUnalignedByte ();};type StreamReader interface{_a .Reader ;_a .ByteReader ;
_a .Seeker ;Align ()byte ;BitPosition ()int ;Mark ();Length ()uint64 ;ReadBit ()(int ,error );ReadBits (_aff byte )(uint64 ,error );ReadBool ()(bool ,error );ReadUint32 ()(uint32 ,error );Reset ();StreamPosition ()int64 ;};func (_cafe *SubstreamReader )BitPosition ()int {return int (_cafe ._cdab )};
type SubstreamReader struct{_bfac uint64 ;_ace StreamReader ;_feb uint64 ;_eba uint64 ;_eace []byte ;_bff uint64 ;_ccf uint64 ;_aac byte ;_cdab byte ;_ebe uint64 ;_bdce byte ;};func (_gea *BufferedWriter )tryGrowByReslice (_bgf int )bool {if _ege :=len (_gea ._ae );
_bgf <=cap (_gea ._ae )-_ege {_gea ._ae =_gea ._ae [:_ege +_bgf ];return true ;};return false ;};func (_gfg *BufferedWriter )writeFullBytes (_bg []byte )int {_bfc :=copy (_gfg ._ae [_gfg .fullOffset ():],_bg );_gfg ._g +=_bfc ;return _bfc ;};func (_afa *Reader )readUnalignedByte ()(_dge byte ,_cdb error ){_fed :=_afa ._dcb ;
_dge =_afa ._dfg <<(8-_fed );_afa ._dfg ,_cdb =_afa .readBufferByte ();if _cdb !=nil {return 0,_cdb ;};_dge |=_afa ._dfg >>_fed ;_afa ._dfg &=1<<_fed -1;return _dge ,nil ;};func (_dagd *Writer )writeByte (_caa byte )error {if _dagd ._deb > len (_dagd ._gfe )-1{return _a .EOF ;
};if _dagd ._deb ==len (_dagd ._gfe )-1&&_dagd ._fad !=0{return _a .EOF ;};if _dagd ._fad ==0{_dagd ._gfe [_dagd ._deb ]=_caa ;_dagd ._deb ++;return nil ;};if _dagd ._fcd {_dagd ._gfe [_dagd ._deb ]|=_caa >>_dagd ._fad ;_dagd ._deb ++;_dagd ._gfe [_dagd ._deb ]=byte (uint16 (_caa )<<(8-_dagd ._fad )&0xff);
}else {_dagd ._gfe [_dagd ._deb ]|=byte (uint16 (_caa )<<_dagd ._fad &0xff);_dagd ._deb ++;_dagd ._gfe [_dagd ._deb ]=_caa >>(8-_dagd ._fad );};return nil ;};func (_caf *Reader )readBufferByte ()(byte ,error ){if _caf ._db >=int64 (len (_caf ._gfd )){return 0,_a .EOF ;
};_caf ._agf =-1;_aaf :=_caf ._gfd [_caf ._db ];_caf ._db ++;_caf ._ag =int (_aaf );return _aaf ,nil ;};func (_acc *Reader )BitPosition ()int {return int (_acc ._dcb )};type BitWriter interface{WriteBit (_efad int )error ;WriteBits (_ecg uint64 ,_dg int )(_bge int ,_bfd error );
FinishByte ();SkipBits (_bb int )error ;};func (_bag *SubstreamReader )readBool ()(_ee bool ,_efc error ){if _bag ._cdab ==0{_bag ._aac ,_efc =_bag .readBufferByte ();if _efc !=nil {return false ,_efc ;};_ee =(_bag ._aac &0x80)!=0;_bag ._aac ,_bag ._cdab =_bag ._aac &0x7f,7;
return _ee ,nil ;};_bag ._cdab --;_ee =(_bag ._aac &(1<<_bag ._cdab ))!=0;_bag ._aac &=1<<_bag ._cdab -1;return _ee ,nil ;};func NewWriter (data []byte )*Writer {return &Writer {_gfe :data }};func (_afe *Writer )FinishByte (){if _afe ._fad ==0{return ;
};_afe ._fad =0;_afe ._deb ++;};func (_cfa *Reader )ReadBit ()(_fb int ,_bc error ){_bgea ,_bc :=_cfa .readBool ();if _bc !=nil {return 0,_bc ;};if _bgea {_fb =1;};return _fb ,nil ;};func (_bgfd *SubstreamReader )ReadBits (n byte )(_cb uint64 ,_aee error ){if n < _bgfd ._cdab {_gdcd :=_bgfd ._cdab -n ;
_cb =uint64 (_bgfd ._aac >>_gdcd );_bgfd ._aac &=1<<_gdcd -1;_bgfd ._cdab =_gdcd ;return _cb ,nil ;};if n > _bgfd ._cdab {if _bgfd ._cdab > 0{_cb =uint64 (_bgfd ._aac );n -=_bgfd ._cdab ;};var _gce byte ;for n >=8{_gce ,_aee =_bgfd .readBufferByte ();if _aee !=nil {return 0,_aee ;
};_cb =_cb <<8+uint64 (_gce );n -=8;};if n > 0{if _bgfd ._aac ,_aee =_bgfd .readBufferByte ();_aee !=nil {return 0,_aee ;};_ffg :=8-n ;_cb =_cb <<n +uint64 (_bgfd ._aac >>_ffg );_bgfd ._aac &=1<<_ffg -1;_bgfd ._cdab =_ffg ;}else {_bgfd ._cdab =0;};return _cb ,nil ;
};_bgfd ._cdab =0;return uint64 (_bgfd ._aac ),nil ;};func (_ba *SubstreamReader )Length ()uint64 {return _ba ._eba };func (_fba *SubstreamReader )readBufferByte ()(byte ,error ){if _fba ._bfac >=_fba ._eba {return 0,_a .EOF ;};if _fba ._bfac >=_fba ._ccf ||_fba ._bfac < _fba ._bff {if _fge :=_fba .fillBuffer ();
_fge !=nil {return 0,_fge ;};};_bae :=_fba ._eace [_fba ._bfac -_fba ._bff ];_fba ._bfac ++;return _bae ,nil ;};func (_cdaf *Reader )Length ()uint64 {return uint64 (len (_cdaf ._gfd ))};func (_ed *BufferedWriter )Len ()int {return _ed .byteCapacity ()};
func (_d *BufferedWriter )FinishByte (){if _d ._c ==0{return ;};_d ._c =0;_d ._g ++;};func (_df *BufferedWriter )grow (_ca int ){if _df ._ae ==nil &&_ca < _aa {_df ._ae =make ([]byte ,_ca ,_aa );return ;};_cdf :=len (_df ._ae );if _df ._c !=0{_cdf ++;};
_efa :=cap (_df ._ae );switch {case _ca <=_efa /2-_cdf :_eac .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_df ._ae ),cap (_df ._ae ),_ca );
_eac .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_efa ,_cdf );copy (_df ._ae ,_df ._ae [_df .fullOffset ():]);
case _efa > _ec -_efa -_ca :_eac .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_cda :=make ([]byte ,2*_efa +_ca );copy (_cda ,_df ._ae );_df ._ae =_cda ;};_df ._ae =_df ._ae [:_cdf +_ca ];
};func (_fdd *SubstreamReader )Align ()(_ffc byte ){_ffc =_fdd ._cdab ;_fdd ._cdab =0;return _ffc };func (_gfb *Reader )Align ()(_ccg byte ){_ccg =_gfb ._dcb ;_gfb ._dcb =0;return _ccg };func (_dda *Writer )SkipBits (skip int )error {const _fca ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";
if skip ==0{return nil ;};_eca :=int (_dda ._fad )+skip ;if _eca >=0&&_eca < 8{_dda ._fad =uint8 (_eca );return nil ;};_eca =int (_dda ._fad )+_dda ._deb *8+skip ;if _eca < 0{return _fe .Errorf (_fca ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_bab :=_eca /8;_fada :=_eca %8;_eac .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");_eac .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_dda ._fad ,_dda ._deb ,int (_dda ._fad )+(_dda ._deb )*8,len (_dda ._gfe ),cap (_dda ._gfe ));
_eac .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_eca ,_fada );_dda ._fad =uint8 (_fada );
if _ceb :=_bab -_dda ._deb ;_ceb > 0&&len (_dda ._gfe )-1< _bab {_eac .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_ceb );return _fe .Errorf (_fca ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_dda ._deb =_bab ;_eac .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_dda ._fad ,_dda ._deb );return nil ;};func (_cab *Reader )ReadUint32 ()(uint32 ,error ){_gg :=make ([]byte ,4);
_ ,_ade :=_cab .Read (_gg );if _ade !=nil {return 0,_ade ;};return _f .BigEndian .Uint32 (_gg ),nil ;};type Reader struct{_gfd []byte ;_dfg byte ;_dcb byte ;_db int64 ;_ag int ;_agf int ;_ffe int64 ;_de byte ;};func (_bdd *Reader )ConsumeRemainingBits (){if _bdd ._dcb !=0{_ ,_ecf :=_bdd .ReadBits (_bdd ._dcb );
if _ecf !=nil {_eac .Log .Debug ("\u0043\u006f\u006e\u0073\u0075\u006d\u0065\u0052\u0065\u006da\u0069\u006e\u0069\u0067\u0042\u0069\u0074s\u0020\u0066\u0061\u0069\u006c\u0065\u0064\u003a\u0020\u0025\u0076",_ecf );};};};func (_bgbc *SubstreamReader )ReadBit ()(_adb int ,_ece error ){_cga ,_ece :=_bgbc .readBool ();
if _ece !=nil {return 0,_ece ;};if _cga {_adb =1;};return _adb ,nil ;};func (_fag *BufferedWriter )Data ()[]byte {return _fag ._ae };var _ _a .ByteWriter =&BufferedWriter {};var _ _a .Writer =&BufferedWriter {};var _ BinaryWriter =&Writer {};func (_bad *SubstreamReader )Read (b []byte )(_efaa int ,_agfd error ){if _bad ._bfac >=_bad ._eba {_eac .Log .Trace ("\u0053\u0074\u0072e\u0061\u006d\u0050\u006fs\u003a\u0020\u0027\u0025\u0064\u0027\u0020>\u003d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027",_bad ._bfac ,_bad ._eba );
return 0,_a .EOF ;};for ;_efaa < len (b );_efaa ++{if b [_efaa ],_agfd =_bad .readUnalignedByte ();_agfd !=nil {if _agfd ==_a .EOF {return _efaa ,nil ;};return 0,_agfd ;};};return _efaa ,nil ;};func (_cdae *Writer )writeBit (_dag uint8 )error {if len (_cdae ._gfe )-1< _cdae ._deb {return _a .EOF ;
};_ced :=_cdae ._fad ;if _cdae ._fcd {_ced =7-_cdae ._fad ;};_cdae ._gfe [_cdae ._deb ]|=byte (uint16 (_dag <<_ced )&0xff);_cdae ._fad ++;if _cdae ._fad ==8{_cdae ._deb ++;_cdae ._fad =0;};return nil ;};func (_dgbc *Writer )byteCapacity ()int {_cbc :=len (_dgbc ._gfe )-_dgbc ._deb ;
if _dgbc ._fad !=0{_cbc --;};return _cbc ;};func (_ga *Writer )Write (p []byte )(int ,error ){if len (p )> _ga .byteCapacity (){return 0,_a .EOF ;};for _ ,_feg :=range p {if _agfa :=_ga .writeByte (_feg );_agfa !=nil {return 0,_agfa ;};};return len (p ),nil ;
};func (_agc *Writer )WriteBits (bits uint64 ,number int )(_ggc int ,_dcdd error ){const _fga ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";if number < 0||number > 64{return 0,_fe .Errorf (_fga ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};if number ==0{return 0,nil ;};_dcaf :=number /8;if _dcaf > 0{_bbb :=number -_dcaf *8;for _agb :=_dcaf -1;_agb >=0;_agb --{_gee :=byte ((bits >>uint (_agb *8+_bbb ))&0xff);if _dcdd =_agc .WriteByte (_gee );_dcdd !=nil {return _ggc ,_fe .Wrapf (_dcdd ,_fga ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_dcaf -_agb +1);
};};number -=_dcaf *8;if number ==0{return _dcaf ,nil ;};};var _bgfa int ;for _afaa :=0;_afaa < number ;_afaa ++{if _agc ._fcd {_bgfa =int ((bits >>uint (number -1-_afaa ))&0x1);}else {_bgfa =int (bits &0x1);bits >>=1;};if _dcdd =_agc .WriteBit (_bgfa );
_dcdd !=nil {return _ggc ,_fe .Wrapf (_dcdd ,_fga ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_afaa );};};return _dcaf ,nil ;};func (_b *BufferedWriter )ResetBitIndex (){_b ._c =0};func (_ebadc *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _ebadc .writeBit (uint8 (bit ));
};return _fe .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");};func (_cef *Reader )ReadByte ()(byte ,error ){if _cef ._dcb ==0{return _cef .readBufferByte ();
};return _cef .readUnalignedByte ();};type Writer struct{_gfe []byte ;_fad uint8 ;_deb int ;_fcd bool ;};func (_ge *BufferedWriter )fullOffset ()int {_cgd :=_ge ._g ;if _ge ._c !=0{_cgd ++;};return _cgd ;};func (_bfa *Reader )readBool ()(_fg bool ,_dgb error ){if _bfa ._dcb ==0{_bfa ._dfg ,_dgb =_bfa .readBufferByte ();
if _dgb !=nil {return false ,_dgb ;};_fg =(_bfa ._dfg &0x80)!=0;_bfa ._dfg ,_bfa ._dcb =_bfa ._dfg &0x7f,7;return _fg ,nil ;};_bfa ._dcb --;_fg =(_bfa ._dfg &(1<<_bfa ._dcb ))!=0;_bfa ._dfg &=1<<_bfa ._dcb -1;return _fg ,nil ;};func (_gdg *Reader )read (_abf []byte )(int ,error ){if _gdg ._db >=int64 (len (_gdg ._gfd )){return 0,_a .EOF ;
};_gdg ._agf =-1;_cfc :=copy (_abf ,_gdg ._gfd [_gdg ._db :]);_gdg ._db +=int64 (_cfc );return _cfc ,nil ;};func (_bbd *SubstreamReader )ReadBool ()(bool ,error ){return _bbd .readBool ()};func _bcd (_age ,_ffb uint64 )uint64 {if _age < _ffb {return _age ;
};return _ffb ;};func (_aeda *SubstreamReader )Reset (){_aeda ._bfac =_aeda ._ebe ;_aeda ._cdab =_aeda ._bdce };type BinaryWriter interface{BitWriter ;_a .Writer ;_a .ByteWriter ;Data ()[]byte ;};func (_be *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _fe .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );
};if len (_be ._ae )-1< _be ._g {_be .expandIfNeeded (1);};_ef :=_be ._c ;if _be ._ab {_ef =7-_be ._c ;};_be ._ae [_be ._g ]|=byte (uint16 (bit <<_ef )&0xff);_be ._c ++;if _be ._c ==8{_be ._g ++;_be ._c =0;};return nil ;};func (_ad *BufferedWriter )writeShiftedBytes (_dd []byte )int {for _ ,_eb :=range _dd {_ad .writeByte (_eb );
};return len (_dd );};func (_fab *Writer )UseMSB ()bool {return _fab ._fcd };func (_fbg *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_fbg ._agf =-1;var _fef int64 ;switch whence {case _a .SeekStart :_fef =offset ;case _a .SeekCurrent :_fef =_fbg ._db +offset ;
case _a .SeekEnd :_fef =int64 (len (_fbg ._gfd ))+offset ;default:return 0,_ea .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};if _fef < 0{return 0,_ea .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");};_fbg ._db =_fef ;
_fbg ._dcb =0;return _fef ,nil ;};func (_dbec *SubstreamReader )StreamPosition ()int64 {return int64 (_dbec ._bfac )};const (_aa =64;_ec =int (^uint (0)>>1););func (_cfb *Reader )ReadBits (n byte )(_fbb uint64 ,_aef error ){if n < _cfb ._dcb {_ffd :=_cfb ._dcb -n ;
_fbb =uint64 (_cfb ._dfg >>_ffd );_cfb ._dfg &=1<<_ffd -1;_cfb ._dcb =_ffd ;return _fbb ,nil ;};if n > _cfb ._dcb {if _cfb ._dcb > 0{_fbb =uint64 (_cfb ._dfg );n -=_cfb ._dcb ;};for n >=8{_gb ,_ebg :=_cfb .readBufferByte ();if _ebg !=nil {return 0,_ebg ;
};_fbb =_fbb <<8+uint64 (_gb );n -=8;};if n > 0{if _cfb ._dfg ,_aef =_cfb .readBufferByte ();_aef !=nil {return 0,_aef ;};_dbe :=8-n ;_fbb =_fbb <<n +uint64 (_cfb ._dfg >>_dbe );_cfb ._dfg &=1<<_dbe -1;_cfb ._dcb =_dbe ;}else {_cfb ._dcb =0;};return _fbb ,nil ;
};_cfb ._dcb =0;return uint64 (_cfb ._dfg ),nil ;};func (_bee *SubstreamReader )Seek (offset int64 ,whence int )(int64 ,error ){switch whence {case _a .SeekStart :_bee ._bfac =uint64 (offset );case _a .SeekCurrent :_bee ._bfac +=uint64 (offset );case _a .SeekEnd :_bee ._bfac =_bee ._eba +uint64 (offset );
default:return 0,_ea .New ("\u0072\u0065\u0061d\u0065\u0072\u002e\u0053\u0075\u0062\u0073\u0074\u0072\u0065\u0061\u006d\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u0020\u0069\u006e\u0076\u0061\u006ci\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};_bee ._cdab =0;return int64 (_bee ._bfac ),nil ;};func (_acb *Reader )Mark (){_acb ._ffe =_acb ._db ;_acb ._de =_acb ._dcb };func (_bgb *Reader )Reset (){_bgb ._db =_bgb ._ffe ;_bgb ._dcb =_bgb ._de };func NewReader (data []byte )*Reader {return &Reader {_gfd :data }};
func (_dcf *Reader )StreamPosition ()int64 {return _dcf ._db };func (_gf *BufferedWriter )byteCapacity ()int {_ff :=len (_gf ._ae )-_gf ._g ;if _gf ._c !=0{_ff --;};return _ff ;};func NewWriterMSB (data []byte )*Writer {return &Writer {_gfe :data ,_fcd :true }};
func (_bed *BufferedWriter )WriteBits (bits uint64 ,number int )(_ac int ,_aab error ){const _bd ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";if number < 0||number > 64{return 0,_fe .Errorf (_bd ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};_abb :=number /8;if _abb > 0{_efg :=number -_abb *8;for _eg :=_abb -1;_eg >=0;_eg --{_cd :=byte ((bits >>uint (_eg *8+_efg ))&0xff);if _aab =_bed .WriteByte (_cd );_aab !=nil {return _ac ,_fe .Wrapf (_aab ,_bd ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_abb -_eg +1);
};};number -=_abb *8;if number ==0{return _abb ,nil ;};};var _dc int ;for _dca :=0;_dca < number ;_dca ++{if _bed ._ab {_dc =int ((bits >>uint (number -1-_dca ))&0x1);}else {_dc =int (bits &0x1);bits >>=1;};if _aab =_bed .WriteBit (_dc );_aab !=nil {return _ac ,_fe .Wrapf (_aab ,_bd ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_dca );
};};return _abb ,nil ;};func (_eab *BufferedWriter )expandIfNeeded (_gdc int ){if !_eab .tryGrowByReslice (_gdc ){_eab .grow (_gdc );};};func (_cfcf *Writer )Data ()[]byte {return _cfcf ._gfe };func (_fc *BufferedWriter )Reset (){_fc ._ae =_fc ._ae [:0];
_fc ._g =0;_fc ._c =0};