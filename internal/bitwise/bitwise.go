//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_f "encoding/binary";_d "errors";_da "github.com/unidoc/unipdf/v3/common";_b "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_g "io";);type BinaryWriter interface{BitWriter ;_g .Writer ;_g .ByteWriter ;Data ()[]byte ;};func (_dfac *Writer )FinishByte (){if _dfac ._dbaf ==0{return ;
};_dfac ._dbaf =0;_dfac ._cefc ++;};func (_fda *BufferedWriter )byteCapacity ()int {_bf :=len (_fda ._de )-_fda ._cf ;if _fda ._dg !=0{_bf --;};return _bf ;};func (_eg *BufferedWriter )ResetBitIndex (){_eg ._dg =0};func (_fcg *Writer )byteCapacity ()int {_abg :=len (_fcg ._dggb )-_fcg ._cefc ;
if _fcg ._dbaf !=0{_abg --;};return _abg ;};func (_dac *Reader )readUnalignedByte ()(_agbe byte ,_gece error ){_eda :=_dac ._ac ;_agbe =_dac ._cfb <<(8-_eda );_dac ._cfb ,_gece =_dac .readBufferByte ();if _gece !=nil {return 0,_gece ;};_agbe |=_dac ._cfb >>_eda ;
_dac ._cfb &=1<<_eda -1;return _agbe ,nil ;};func (_eab *SubstreamReader )readUnalignedByte ()(_ceca byte ,_ggg error ){_afc :=_eab ._cfbb ;_ceca =_eab ._aeb <<(8-_afc );_eab ._aeb ,_ggg =_eab .readBufferByte ();if _ggg !=nil {return 0,_ggg ;};_ceca |=_eab ._aeb >>_afc ;
_eab ._aeb &=1<<_afc -1;return _ceca ,nil ;};func (_fcc *Writer )Write (p []byte )(int ,error ){if len (p )> _fcc .byteCapacity (){return 0,_g .EOF ;};for _ ,_bae :=range p {if _faeb :=_fcc .writeByte (_bae );_faeb !=nil {return 0,_faeb ;};};return len (p ),nil ;
};func (_gcf *SubstreamReader )BitPosition ()int {return int (_gcf ._cfbb )};func (_fdc *Reader )StreamPosition ()int64 {return _fdc ._ea };func (_acd *Reader )readBool ()(_bce bool ,_cbe error ){if _acd ._ac ==0{_acd ._cfb ,_cbe =_acd .readBufferByte ();
if _cbe !=nil {return false ,_cbe ;};_bce =(_acd ._cfb &0x80)!=0;_acd ._cfb ,_acd ._ac =_acd ._cfb &0x7f,7;return _bce ,nil ;};_acd ._ac --;_bce =(_acd ._cfb &(1<<_acd ._ac ))!=0;_acd ._cfb &=1<<_acd ._ac -1;return _bce ,nil ;};func (_bgb *Writer )SkipBits (skip int )error {const _egb ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";
if skip ==0{return nil ;};_beb :=int (_bgb ._dbaf )+skip ;if _beb >=0&&_beb < 8{_bgb ._dbaf =uint8 (_beb );return nil ;};_beb =int (_bgb ._dbaf )+_bgb ._cefc *8+skip ;if _beb < 0{return _b .Errorf (_egb ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_dea :=_beb /8;_fad :=_beb %8;_da .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");_da .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_bgb ._dbaf ,_bgb ._cefc ,int (_bgb ._dbaf )+(_bgb ._cefc )*8,len (_bgb ._dggb ),cap (_bgb ._dggb ));
_da .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_beb ,_fad );_bgb ._dbaf =uint8 (_fad );if _ffb :=_dea -_bgb ._cefc ;
_ffb > 0&&len (_bgb ._dggb )-1< _dea {_da .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_ffb );return _b .Errorf (_egb ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_bgb ._cefc =_dea ;
_da .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_bgb ._dbaf ,_bgb ._cefc );return nil ;};func (_cc *Reader )ConsumeRemainingBits (){if _cc ._ac !=0{_ ,_gee :=_cc .ReadBits (_cc ._ac );
if _gee !=nil {_da .Log .Debug ("\u0043\u006f\u006e\u0073\u0075\u006d\u0065\u0052\u0065\u006da\u0069\u006e\u0069\u0067\u0042\u0069\u0074s\u0020\u0066\u0061\u0069\u006c\u0065\u0064\u003a\u0020\u0025\u0076",_gee );};};};func (_eb *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;
};_cg :=int (_eb ._dg )+skip ;if _cg >=0&&_cg < 8{_eb ._dg =uint8 (_cg );return nil ;};_cg =int (_eb ._dg )+_eb ._cf *8+skip ;if _cg < 0{return _b .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_fc :=_cg /8;_fd :=_cg %8;_eb ._dg =uint8 (_fd );if _ebb :=_fc -_eb ._cf ;_ebb > 0&&len (_eb ._de )-1< _fc {if _eb ._dg !=0{_ebb ++;};_eb .expandIfNeeded (_ebb );};_eb ._cf =_fc ;return nil ;};func (_fac *Reader )Reset (){_fac ._ea =_fac ._ef ;_fac ._ac =_fac ._df };
func (_gec *BufferedWriter )Write (d []byte )(int ,error ){_gec .expandIfNeeded (len (d ));if _gec ._dg ==0{return _gec .writeFullBytes (d ),nil ;};return _gec .writeShiftedBytes (d ),nil ;};type Writer struct{_dggb []byte ;_dbaf uint8 ;_cefc int ;_cbb bool ;
};func (_ed *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _b .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );
};if len (_ed ._de )-1< _ed ._cf {_ed .expandIfNeeded (1);};_ga :=_ed ._dg ;if _ed ._ddf {_ga =7-_ed ._dg ;};_ed ._de [_ed ._cf ]|=byte (uint16 (bit <<_ga )&0xff);_ed ._dg ++;if _ed ._dg ==8{_ed ._cf ++;_ed ._dg =0;};return nil ;};func (_geg *SubstreamReader )Read (b []byte )(_cdd int ,_efeg error ){if _geg ._cbgc >=_geg ._fbd {_da .Log .Trace ("\u0053\u0074\u0072e\u0061\u006d\u0050\u006fs\u003a\u0020\u0027\u0025\u0064\u0027\u0020>\u003d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027",_geg ._cbgc ,_geg ._fbd );
return 0,_g .EOF ;};for ;_cdd < len (b );_cdd ++{if b [_cdd ],_efeg =_geg .readUnalignedByte ();_efeg !=nil {if _efeg ==_g .EOF {return _cdd ,nil ;};return 0,_efeg ;};};return _cdd ,nil ;};func (_bgf *Reader )ReadByte ()(byte ,error ){if _bgf ._ac ==0{return _bgf .readBufferByte ();
};return _bgf .readUnalignedByte ();};func (_bga *SubstreamReader )ReadUint32 ()(uint32 ,error ){_cge :=make ([]byte ,4);_ ,_cgg :=_bga .Read (_cge );if _cgg !=nil {return 0,_cgg ;};return _f .BigEndian .Uint32 (_cge ),nil ;};func (_egg *Reader )readBufferByte ()(byte ,error ){if _egg ._ea >=int64 (len (_egg ._gdd )){return 0,_g .EOF ;
};_egg ._fab =-1;_cee :=_egg ._gdd [_egg ._ea ];_egg ._ea ++;_egg ._aea =int (_cee );return _cee ,nil ;};func (_affd *SubstreamReader )Seek (offset int64 ,whence int )(int64 ,error ){switch whence {case _g .SeekStart :_affd ._cbgc =uint64 (offset );case _g .SeekCurrent :_affd ._cbgc +=uint64 (offset );
case _g .SeekEnd :_affd ._cbgc =_affd ._fbd +uint64 (offset );default:return 0,_d .New ("\u0072\u0065\u0061d\u0065\u0072\u002e\u0053\u0075\u0062\u0073\u0074\u0072\u0065\u0061\u006d\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u0020\u0069\u006e\u0076\u0061\u006ci\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};_affd ._cfbb =0;return int64 (_affd ._cbgc ),nil ;};func (_bca *Writer )UseMSB ()bool {return _bca ._cbb };func (_gd *BufferedWriter )Data ()[]byte {return _gd ._de };func (_cbge *SubstreamReader )ReadBits (n byte )(_ad uint64 ,_ggc error ){if n < _cbge ._cfbb {_bgc :=_cbge ._cfbb -n ;
_ad =uint64 (_cbge ._aeb >>_bgc );_cbge ._aeb &=1<<_bgc -1;_cbge ._cfbb =_bgc ;return _ad ,nil ;};if n > _cbge ._cfbb {if _cbge ._cfbb > 0{_ad =uint64 (_cbge ._aeb );n -=_cbge ._cfbb ;};var _gce byte ;for n >=8{_gce ,_ggc =_cbge .readBufferByte ();if _ggc !=nil {return 0,_ggc ;
};_ad =_ad <<8+uint64 (_gce );n -=8;};if n > 0{if _cbge ._aeb ,_ggc =_cbge .readBufferByte ();_ggc !=nil {return 0,_ggc ;};_cec :=8-n ;_ad =_ad <<n +uint64 (_cbge ._aeb >>_cec );_cbge ._aeb &=1<<_cec -1;_cbge ._cfbb =_cec ;}else {_cbge ._cfbb =0;};return _ad ,nil ;
};_cbge ._cfbb =0;return uint64 (_cbge ._aeb ),nil ;};var (_ _g .Reader =&Reader {};_ _g .ByteReader =&Reader {};_ _g .Seeker =&Reader {};_ StreamReader =&Reader {};);var _ BinaryWriter =&BufferedWriter {};func (_bcg *Reader )ReadBits (n byte )(_ee uint64 ,_aed error ){if n < _bcg ._ac {_cfcg :=_bcg ._ac -n ;
_ee =uint64 (_bcg ._cfb >>_cfcg );_bcg ._cfb &=1<<_cfcg -1;_bcg ._ac =_cfcg ;return _ee ,nil ;};if n > _bcg ._ac {if _bcg ._ac > 0{_ee =uint64 (_bcg ._cfb );n -=_bcg ._ac ;};for n >=8{_eba ,_fdb :=_bcg .readBufferByte ();if _fdb !=nil {return 0,_fdb ;};
_ee =_ee <<8+uint64 (_eba );n -=8;};if n > 0{if _bcg ._cfb ,_aed =_bcg .readBufferByte ();_aed !=nil {return 0,_aed ;};_deb :=8-n ;_ee =_ee <<n +uint64 (_bcg ._cfb >>_deb );_bcg ._cfb &=1<<_deb -1;_bcg ._ac =_deb ;}else {_bcg ._ac =0;};return _ee ,nil ;
};_bcg ._ac =0;return uint64 (_bcg ._cfb ),nil ;};func (_cde *Reader )ReadBool ()(bool ,error ){return _cde .readBool ()};func (_gad *SubstreamReader )Mark (){_gad ._ffa =_gad ._cbgc ;_gad ._ece =_gad ._cfbb };const (_a =64;_c =int (^uint (0)>>1););func (_aag *SubstreamReader )Reset (){_aag ._cbgc =_aag ._ffa ;
_aag ._cfbb =_aag ._ece };func (_cefa *Writer )writeByte (_gbb byte )error {if _cefa ._cefc > len (_cefa ._dggb )-1{return _g .EOF ;};if _cefa ._cefc ==len (_cefa ._dggb )-1&&_cefa ._dbaf !=0{return _g .EOF ;};if _cefa ._dbaf ==0{_cefa ._dggb [_cefa ._cefc ]=_gbb ;
_cefa ._cefc ++;return nil ;};if _cefa ._cbb {_cefa ._dggb [_cefa ._cefc ]|=_gbb >>_cefa ._dbaf ;_cefa ._cefc ++;_cefa ._dggb [_cefa ._cefc ]=byte (uint16 (_gbb )<<(8-_cefa ._dbaf )&0xff);}else {_cefa ._dggb [_cefa ._cefc ]|=byte (uint16 (_gbb )<<_cefa ._dbaf &0xff);
_cefa ._cefc ++;_cefa ._dggb [_cefa ._cefc ]=_gbb >>(8-_cefa ._dbaf );};return nil ;};func (_bb *BufferedWriter )Len ()int {return _bb .byteCapacity ()};func (_cb *BufferedWriter )expandIfNeeded (_ag int ){if !_cb .tryGrowByReslice (_ag ){_cb .grow (_ag );
};};func (_bcef *SubstreamReader )readBool ()(_efec bool ,_bdb error ){if _bcef ._cfbb ==0{_bcef ._aeb ,_bdb =_bcef .readBufferByte ();if _bdb !=nil {return false ,_bdb ;};_efec =(_bcef ._aeb &0x80)!=0;_bcef ._aeb ,_bcef ._cfbb =_bcef ._aeb &0x7f,7;return _efec ,nil ;
};_bcef ._cfbb --;_efec =(_bcef ._aeb &(1<<_bcef ._cfbb ))!=0;_bcef ._aeb &=1<<_bcef ._cfbb -1;return _efec ,nil ;};func (_fdf *Reader )Length ()uint64 {return uint64 (len (_fdf ._gdd ))};type BitWriter interface{WriteBit (_bbf int )error ;WriteBits (_gb uint64 ,_cfc int )(_gba int ,_ae error );
FinishByte ();SkipBits (_cfa int )error ;};func (_aeg *Writer )ResetBit (){_aeg ._dbaf =0};func (_ca *BufferedWriter )Reset (){_ca ._de =_ca ._de [:0];_ca ._cf =0;_ca ._dg =0};func _deg (_dfc ,_fga uint64 )uint64 {if _dfc < _fga {return _dfc ;};return _fga ;
};func (_fbg *BufferedWriter )WriteBits (bits uint64 ,number int )(_gg int ,_ebbf error ){const _dde ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";if number < 0||number > 64{return 0,_b .Errorf (_dde ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};_fa :=number /8;if _fa > 0{_ab :=number -_fa *8;for _ebc :=_fa -1;_ebc >=0;_ebc --{_gab :=byte ((bits >>uint (_ebc *8+_ab ))&0xff);if _ebbf =_fbg .WriteByte (_gab );_ebbf !=nil {return _gg ,_b .Wrapf (_ebbf ,_dde ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_fa -_ebc +1);
};};number -=_fa *8;if number ==0{return _fa ,nil ;};};var _bg int ;for _fe :=0;_fe < number ;_fe ++{if _fbg ._ddf {_bg =int ((bits >>uint (number -1-_fe ))&0x1);}else {_bg =int (bits &0x1);bits >>=1;};if _ebbf =_fbg .WriteBit (_bg );_ebbf !=nil {return _gg ,_b .Wrapf (_ebbf ,_dde ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_fe );
};};return _fa ,nil ;};func NewSubstreamReader (r StreamReader ,offset ,length uint64 )(*SubstreamReader ,error ){if r ==nil {return nil ,_d .New ("\u0072o\u006ft\u0020\u0072\u0065\u0061\u0064e\u0072\u0020i\u0073\u0020\u006e\u0069\u006c");};_da .Log .Trace ("\u004e\u0065\u0077\u0053\u0075\u0062\u0073\u0074r\u0065\u0061\u006dRe\u0061\u0064\u0065\u0072\u0020\u0061t\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u003a\u0020\u0025\u0064\u0020\u0077\u0069\u0074h\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a \u0025\u0064",offset ,length );
return &SubstreamReader {_bcd :r ,_bdg :offset ,_fbd :length ,_ec :make ([]byte ,length )},nil ;};func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_ddf :true }};func (_acf *SubstreamReader )readBufferByte ()(byte ,error ){if _acf ._cbgc >=_acf ._fbd {return 0,_g .EOF ;
};if _acf ._cbgc >=_acf ._ff ||_acf ._cbgc < _acf ._cab {if _dfa :=_acf .fillBuffer ();_dfa !=nil {return 0,_dfa ;};};_dfg :=_acf ._ec [_acf ._cbgc -_acf ._cab ];_acf ._cbgc ++;return _dfg ,nil ;};var _ BinaryWriter =&Writer {};func NewReader (data []byte )*Reader {return &Reader {_gdd :data }};
func (_ce *BufferedWriter )WriteByte (bt byte )error {if _ce ._cf > len (_ce ._de )-1||(_ce ._cf ==len (_ce ._de )-1&&_ce ._dg !=0){_ce .expandIfNeeded (1);};_ce .writeByte (bt );return nil ;};func (_acdb *SubstreamReader )Align ()(_eee byte ){_eee =_acdb ._cfbb ;
_acdb ._cfbb =0;return _eee };func (_eeb *SubstreamReader )StreamPosition ()int64 {return int64 (_eeb ._cbgc )};func (_ba *BufferedWriter )writeFullBytes (_ede []byte )int {_bbc :=copy (_ba ._de [_ba .fullOffset ():],_ede );_ba ._cf +=_bbc ;return _bbc ;
};func NewWriterMSB (data []byte )*Writer {return &Writer {_dggb :data ,_cbb :true }};func (_aff *SubstreamReader )ReadBit ()(_bgg int ,_agce error ){_gbd ,_agce :=_aff .readBool ();if _agce !=nil {return 0,_agce ;};if _gbd {_bgg =1;};return _bgg ,nil ;
};func (_aac *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_aac ._fab =-1;var _gbe int64 ;switch whence {case _g .SeekStart :_gbe =offset ;case _g .SeekCurrent :_gbe =_aac ._ea +offset ;case _g .SeekEnd :_gbe =int64 (len (_aac ._gdd ))+offset ;
default:return 0,_d .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");};if _gbe < 0{return 0,_d .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");
};_aac ._ea =_gbe ;_aac ._ac =0;return _gbe ,nil ;};var _ _g .Writer =&BufferedWriter {};func (_bcc *Writer )WriteByte (c byte )error {return _bcc .writeByte (c )};func (_agbg *SubstreamReader )ReadBool ()(bool ,error ){return _agbg .readBool ()};func (_fce *Reader )BitPosition ()int {return int (_fce ._ac )};
func (_edec *BufferedWriter )writeShiftedBytes (_cbg []byte )int {for _ ,_ebbe :=range _cbg {_edec .writeByte (_ebbe );};return len (_cbg );};func (_aa *BufferedWriter )writeByte (_gag byte ){switch {case _aa ._dg ==0:_aa ._de [_aa ._cf ]=_gag ;_aa ._cf ++;
case _aa ._ddf :_aa ._de [_aa ._cf ]|=_gag >>_aa ._dg ;_aa ._cf ++;_aa ._de [_aa ._cf ]=byte (uint16 (_gag )<<(8-_aa ._dg )&0xff);default:_aa ._de [_aa ._cf ]|=byte (uint16 (_gag )<<_aa ._dg &0xff);_aa ._cf ++;_aa ._de [_aa ._cf ]=_gag >>(8-_aa ._dg );
};};type Reader struct{_gdd []byte ;_cfb byte ;_ac byte ;_ea int64 ;_aea int ;_fab int ;_ef int64 ;_df byte ;};type StreamReader interface{_g .Reader ;_g .ByteReader ;_g .Seeker ;Align ()byte ;BitPosition ()int ;Mark ();Length ()uint64 ;ReadBit ()(int ,error );
ReadBits (_fdg byte )(uint64 ,error );ReadBool ()(bool ,error );ReadUint32 ()(uint32 ,error );Reset ();StreamPosition ()int64 ;};func (_agc *Reader )Read (p []byte )(_fde int ,_be error ){if _agc ._ac ==0{return _agc .read (p );};for ;_fde < len (p );_fde ++{if p [_fde ],_be =_agc .readUnalignedByte ();
_be !=nil {return 0,_be ;};};return _fde ,nil ;};func (_abd *BufferedWriter )grow (_bfb int ){if _abd ._de ==nil &&_bfb < _a {_abd ._de =make ([]byte ,_bfb ,_a );return ;};_fg :=len (_abd ._de );if _abd ._dg !=0{_fg ++;};_dba :=cap (_abd ._de );switch {case _bfb <=_dba /2-_fg :_da .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_abd ._de ),cap (_abd ._de ),_bfb );
_da .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_dba ,_fg );copy (_abd ._de ,_abd ._de [_abd .fullOffset ():]);
case _dba > _c -_dba -_bfb :_da .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_agb :=make ([]byte ,2*_dba +_bfb );copy (_agb ,_abd ._de );_abd ._de =_agb ;};_abd ._de =_abd ._de [:_fg +_bfb ];
};func (_dgc *Reader )Align ()(_bc byte ){_bc =_dgc ._ac ;_dgc ._ac =0;return _bc };func (_bgbe *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _bgbe .writeBit (uint8 (bit ));};return _b .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");
};func (_cda *Writer )WriteBits (bits uint64 ,number int )(_agcd int ,_gdg error ){const _cecc ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";if number < 0||number > 64{return 0,_b .Errorf (_cecc ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};if number ==0{return 0,nil ;};_bfa :=number /8;if _bfa > 0{_gdb :=number -_bfa *8;for _aba :=_bfa -1;_aba >=0;_aba --{_bfaa :=byte ((bits >>uint (_aba *8+_gdb ))&0xff);if _gdg =_cda .WriteByte (_bfaa );_gdg !=nil {return _agcd ,_b .Wrapf (_gdg ,_cecc ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_bfa -_aba +1);
};};number -=_bfa *8;if number ==0{return _bfa ,nil ;};};var _agg int ;for _dggg :=0;_dggg < number ;_dggg ++{if _cda ._cbb {_agg =int ((bits >>uint (number -1-_dggg ))&0x1);}else {_agg =int (bits &0x1);bits >>=1;};if _gdg =_cda .WriteBit (_agg );_gdg !=nil {return _agcd ,_b .Wrapf (_gdg ,_cecc ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_dggg );
};};return _bfa ,nil ;};type BufferedWriter struct{_de []byte ;_dg uint8 ;_cf int ;_ddf bool ;};func (_cba *SubstreamReader )Offset ()uint64 {return _cba ._bdg };func (_fdag *Reader )read (_cfcd []byte )(int ,error ){if _fdag ._ea >=int64 (len (_fdag ._gdd )){return 0,_g .EOF ;
};_fdag ._fab =-1;_bbg :=copy (_cfcd ,_fdag ._gdd [_fdag ._ea :]);_fdag ._ea +=int64 (_bbg );return _bbg ,nil ;};var _ _g .ByteWriter =&BufferedWriter {};func (_fec *BufferedWriter )tryGrowByReslice (_bbe int )bool {if _af :=len (_fec ._de );_bbe <=cap (_fec ._de )-_af {_fec ._de =_fec ._de [:_af +_bbe ];
return true ;};return false ;};func (_fcd *Reader )Mark (){_fcd ._ef =_fcd ._ea ;_fcd ._df =_fcd ._ac };func (_fgg *Reader )ReadBit ()(_cad int ,_dgg error ){_ebd ,_dgg :=_fgg .readBool ();if _dgg !=nil {return 0,_dgg ;};if _ebd {_cad =1;};return _cad ,nil ;
};func (_cac *Reader )ReadUint32 ()(uint32 ,error ){_abf :=make ([]byte ,4);_ ,_fae :=_cac .Read (_abf );if _fae !=nil {return 0,_fae ;};return _f .BigEndian .Uint32 (_abf ),nil ;};func (_ecec *SubstreamReader )fillBuffer ()error {if uint64 (_ecec ._bcd .StreamPosition ())!=_ecec ._cbgc +_ecec ._bdg {_ ,_adg :=_ecec ._bcd .Seek (int64 (_ecec ._cbgc +_ecec ._bdg ),_g .SeekStart );
if _adg !=nil {return _adg ;};};_ecec ._cab =_ecec ._cbgc ;_faca :=_deg (uint64 (len (_ecec ._ec )),_ecec ._fbd -_ecec ._cbgc );_dbg :=make ([]byte ,_faca );_gga ,_gea :=_ecec ._bcd .Read (_dbg );if _gea !=nil {return _gea ;};for _ceb :=uint64 (0);_ceb < _faca ;
_ceb ++{_ecec ._ec [_ceb ]=_dbg [_ceb ];};_ecec ._ff =_ecec ._cab +uint64 (_gga );return nil ;};func (_bd *BufferedWriter )fullOffset ()int {_fef :=_bd ._cf ;if _bd ._dg !=0{_fef ++;};return _fef ;};func NewWriter (data []byte )*Writer {return &Writer {_dggb :data }};
type SubstreamReader struct{_cbgc uint64 ;_bcd StreamReader ;_bdg uint64 ;_fbd uint64 ;_ec []byte ;_cab uint64 ;_ff uint64 ;_aeb byte ;_cfbb byte ;_ffa uint64 ;_ece byte ;};func (_ge *BufferedWriter )FinishByte (){if _ge ._dg ==0{return ;};_ge ._dg =0;
_ge ._cf ++;};func (_bebd *Writer )writeBit (_edc uint8 )error {if len (_bebd ._dggb )-1< _bebd ._cefc {return _g .EOF ;};_cgc :=_bebd ._dbaf ;if _bebd ._cbb {_cgc =7-_bebd ._dbaf ;};_bebd ._dggb [_bebd ._cefc ]|=byte (uint16 (_edc <<_cgc )&0xff);_bebd ._dbaf ++;
if _bebd ._dbaf ==8{_bebd ._cefc ++;_bebd ._dbaf =0;};return nil ;};func (_daeg *SubstreamReader )ReadByte ()(byte ,error ){if _daeg ._cfbb ==0{return _daeg .readBufferByte ();};return _daeg .readUnalignedByte ();};func (_fed *Writer )Data ()[]byte {return _fed ._dggb };
func (_abfc *SubstreamReader )Length ()uint64 {return _abfc ._fbd };