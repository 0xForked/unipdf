//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_bg "encoding/binary";_a "errors";_f "github.com/unidoc/unipdf/v3/common";_fg "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_c "io";);func (_gf *BufferedWriter )writeByte (_aa byte ){switch {case _gf ._e ==0:_gf ._bc [_gf ._fa ]=_aa ;
_gf ._fa ++;case _gf ._be :_gf ._bc [_gf ._fa ]|=_aa >>_gf ._e ;_gf ._fa ++;_gf ._bc [_gf ._fa ]=byte (uint16 (_aa )<<(8-_gf ._e )&0xff);default:_gf ._bc [_gf ._fa ]|=byte (uint16 (_aa )<<_gf ._e &0xff);_gf ._fa ++;_gf ._bc [_gf ._fa ]=_aa >>(8-_gf ._e );
};};func (_efdb *BufferedWriter )byteCapacity ()int {_ag :=len (_efdb ._bc )-_efdb ._fa ;if _efdb ._e !=0{_ag --;};return _ag ;};func (_adf *Writer )SkipBits (skip int )error {const _dbea ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";
if skip ==0{return nil ;};_efdgb :=int (_adf ._ab )+skip ;if _efdgb >=0&&_efdgb < 8{_adf ._ab =uint8 (_efdgb );return nil ;};_efdgb =int (_adf ._ab )+_adf ._cdbe *8+skip ;if _efdgb < 0{return _fg .Errorf (_dbea ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_gba :=_efdgb /8;_eae :=_efdgb %8;_f .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");_f .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_adf ._ab ,_adf ._cdbe ,int (_adf ._ab )+(_adf ._cdbe )*8,len (_adf ._fbf ),cap (_adf ._fbf ));
_f .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_efdgb ,_eae );_adf ._ab =uint8 (_eae );if _adee :=_gba -_adf ._cdbe ;
_adee > 0&&len (_adf ._fbf )-1< _gba {_f .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_adee );return _fg .Errorf (_dbea ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};
_adf ._cdbe =_gba ;_f .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_adf ._ab ,_adf ._cdbe );return nil ;};func (_ecd *SubstreamReader )Read (b []byte )(_dca int ,_cfb error ){if _ecd ._fde >=_ecd ._dcc {_f .Log .Trace ("\u0053\u0074\u0072e\u0061\u006d\u0050\u006fs\u003a\u0020\u0027\u0025\u0064\u0027\u0020>\u003d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027",_ecd ._fde ,_ecd ._dcc );
return 0,_c .EOF ;};for ;_dca < len (b );_dca ++{if b [_dca ],_cfb =_ecd .readUnalignedByte ();_cfb !=nil {if _cfb ==_c .EOF {return _dca ,nil ;};return 0,_cfb ;};};return _dca ,nil ;};func (_efe *Reader )ReadUint32 ()(uint32 ,error ){_bcc :=make ([]byte ,4);
_ ,_bac :=_efe .Read (_bcc );if _bac !=nil {return 0,_bac ;};return _bg .BigEndian .Uint32 (_bcc ),nil ;};func (_deb *SubstreamReader )Align ()(_daf byte ){_daf =_deb ._eca ;_deb ._eca =0;return _daf };func (_gda *SubstreamReader )readUnalignedByte ()(_efdg byte ,_egf error ){_cbc :=_gda ._eca ;
_efdg =_gda ._add <<(8-_cbc );_gda ._add ,_egf =_gda .readBufferByte ();if _egf !=nil {return 0,_egf ;};_efdg |=_gda ._add >>_cbc ;_gda ._add &=1<<_cbc -1;return _efdg ,nil ;};func (_cc *BufferedWriter )FinishByte (){if _cc ._e ==0{return ;};_cc ._e =0;
_cc ._fa ++;};func (_aec *Reader )readBufferByte ()(byte ,error ){if _aec ._gab >=int64 (len (_aec ._ceb )){return 0,_c .EOF ;};_aec ._cf =-1;_fe :=_aec ._ceb [_aec ._gab ];_aec ._gab ++;_aec ._cdg =int (_fe );return _fe ,nil ;};var _ _c .ByteWriter =&BufferedWriter {};
func (_adg *SubstreamReader )Length ()uint64 {return _adg ._dcc };func (_ddd *SubstreamReader )readBool ()(_edf bool ,_ea error ){if _ddd ._eca ==0{_ddd ._add ,_ea =_ddd .readBufferByte ();if _ea !=nil {return false ,_ea ;};_edf =(_ddd ._add &0x80)!=0;
_ddd ._add ,_ddd ._eca =_ddd ._add &0x7f,7;return _edf ,nil ;};_ddd ._eca --;_edf =(_ddd ._add &(1<<_ddd ._eca ))!=0;_ddd ._add &=1<<_ddd ._eca -1;return _edf ,nil ;};func (_dg *BufferedWriter )ResetBitIndex (){_dg ._e =0};func NewWriter (data []byte )*Writer {return &Writer {_fbf :data }};
func NewSubstreamReader (r StreamReader ,offset ,length uint64 )(*SubstreamReader ,error ){if r ==nil {return nil ,_a .New ("\u0072o\u006ft\u0020\u0072\u0065\u0061\u0064e\u0072\u0020i\u0073\u0020\u006e\u0069\u006c");};_f .Log .Trace ("\u004e\u0065\u0077\u0053\u0075\u0062\u0073\u0074r\u0065\u0061\u006dRe\u0061\u0064\u0065\u0072\u0020\u0061t\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u003a\u0020\u0025\u0064\u0020\u0077\u0069\u0074h\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a \u0025\u0064",offset ,length );
return &SubstreamReader {_eeaf :r ,_gdb :offset ,_dcc :length ,_bda :make ([]byte ,length )},nil ;};var _ BinaryWriter =&BufferedWriter {};func (_fceg *Reader )BitPosition ()int {return int (_fceg ._dee )};type SubstreamReader struct{_fde uint64 ;_eeaf StreamReader ;
_gdb uint64 ;_dcc uint64 ;_bda []byte ;_bgf uint64 ;_bbdf uint64 ;_add byte ;_eca byte ;_fbg uint64 ;_cbge byte ;};func (_dfc *Writer )UseMSB ()bool {return _dfc ._bbgc };func (_cdge *SubstreamReader )ReadBit ()(_cfbf int ,_efed error ){_edb ,_efed :=_cdge .readBool ();
if _efed !=nil {return 0,_efed ;};if _edb {_cfbf =1;};return _cfbf ,nil ;};func (_fge *SubstreamReader )ReadBool ()(bool ,error ){return _fge .readBool ()};func (_dbe *SubstreamReader )ReadUint32 ()(uint32 ,error ){_efc :=make ([]byte ,4);_ ,_bea :=_dbe .Read (_efc );
if _bea !=nil {return 0,_bea ;};return _bg .BigEndian .Uint32 (_efc ),nil ;};type BufferedWriter struct{_bc []byte ;_e uint8 ;_fa int ;_be bool ;};func (_fbgd *SubstreamReader )Offset ()uint64 {return _fbgd ._gdb };func (_gae *SubstreamReader )BitPosition ()int {return int (_gae ._eca )};
func (_afe *Writer )writeBit (_dab uint8 )error {if len (_afe ._fbf )-1< _afe ._cdbe {return _c .EOF ;};_dda :=_afe ._ab ;if _afe ._bbgc {_dda =7-_afe ._ab ;};_afe ._fbf [_afe ._cdbe ]|=byte (uint16 (_dab <<_dda )&0xff);_afe ._ab ++;if _afe ._ab ==8{_afe ._cdbe ++;
_afe ._ab =0;};return nil ;};func (_ccf *SubstreamReader )readBufferByte ()(byte ,error ){if _ccf ._fde >=_ccf ._dcc {return 0,_c .EOF ;};if _ccf ._fde >=_ccf ._bbdf ||_ccf ._fde < _ccf ._bgf {if _bbbe :=_ccf .fillBuffer ();_bbbe !=nil {return 0,_bbbe ;
};};_fcd :=_ccf ._bda [_ccf ._fde -_ccf ._bgf ];_ccf ._fde ++;return _fcd ,nil ;};func (_cgba *Writer )WriteBits (bits uint64 ,number int )(_eda int ,_fae error ){const _cdac ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";
if number < 0||number > 64{return 0,_fg .Errorf (_cdac ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};if number ==0{return 0,nil ;};_bdb :=number /8;if _bdb > 0{_bbga :=number -_bdb *8;for _edbc :=_bdb -1;_edbc >=0;_edbc --{_gfdc :=byte ((bits >>uint (_edbc *8+_bbga ))&0xff);if _fae =_cgba .WriteByte (_gfdc );_fae !=nil {return _eda ,_fg .Wrapf (_fae ,_cdac ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_bdb -_edbc +1);
};};number -=_bdb *8;if number ==0{return _bdb ,nil ;};};var _bcd int ;for _gce :=0;_gce < number ;_gce ++{if _cgba ._bbgc {_bcd =int ((bits >>uint (number -1-_gce ))&0x1);}else {_bcd =int (bits &0x1);bits >>=1;};if _fae =_cgba .WriteBit (_bcd );_fae !=nil {return _eda ,_fg .Wrapf (_fae ,_cdac ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_gce );
};};return _bdb ,nil ;};func (_gag *Writer )Data ()[]byte {return _gag ._fbf };type Writer struct{_fbf []byte ;_ab uint8 ;_cdbe int ;_bbgc bool ;};func (_cba *Reader )StreamPosition ()int64 {return _cba ._gab };func (_bee *Reader )ReadBool ()(bool ,error ){return _bee .readBool ()};
var _ BinaryWriter =&Writer {};func (_bfa *Reader )Align ()(_af byte ){_af =_bfa ._dee ;_bfa ._dee =0;return _af };func (_cfc *Reader )ReadBit ()(_bge int ,_aaac error ){_ccc ,_aaac :=_cfc .readBool ();if _aaac !=nil {return 0,_aaac ;};if _ccc {_bge =1;
};return _bge ,nil ;};func (_dc *BufferedWriter )WriteBits (bits uint64 ,number int )(_ce int ,_acg error ){const _ae ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";if number < 0||number > 64{return 0,_fg .Errorf (_ae ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};_ga :=number /8;if _ga > 0{_ee :=number -_ga *8;for _efd :=_ga -1;_efd >=0;_efd --{_ge :=byte ((bits >>uint (_efd *8+_ee ))&0xff);if _acg =_dc .WriteByte (_ge );_acg !=nil {return _ce ,_fg .Wrapf (_acg ,_ae ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_ga -_efd +1);
};};number -=_ga *8;if number ==0{return _ga ,nil ;};};var _ca int ;for _egd :=0;_egd < number ;_egd ++{if _dc ._be {_ca =int ((bits >>uint (number -1-_egd ))&0x1);}else {_ca =int (bits &0x1);bits >>=1;};if _acg =_dc .WriteBit (_ca );_acg !=nil {return _ce ,_fg .Wrapf (_acg ,_ae ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_egd );
};};return _ga ,nil ;};func (_bbd *Reader )readUnalignedByte ()(_bbg byte ,_cfd error ){_eef :=_bbd ._dee ;_bbg =_bbd ._gfd <<(8-_eef );_bbd ._gfd ,_cfd =_bbd .readBufferByte ();if _cfd !=nil {return 0,_cfd ;};_bbg |=_bbd ._gfd >>_eef ;_bbd ._gfd &=1<<_eef -1;
return _bbg ,nil ;};func (_ac *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _fg .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );
};if len (_ac ._bc )-1< _ac ._fa {_ac .expandIfNeeded (1);};_beb :=_ac ._e ;if _ac ._be {_beb =7-_ac ._e ;};_ac ._bc [_ac ._fa ]|=byte (uint16 (bit <<_beb )&0xff);_ac ._e ++;if _ac ._e ==8{_ac ._fa ++;_ac ._e =0;};return nil ;};func (_fad *Writer )ResetBit (){_fad ._ab =0};
func (_dcb *Writer )writeByte (_age byte )error {if _dcb ._cdbe > len (_dcb ._fbf )-1{return _c .EOF ;};if _dcb ._cdbe ==len (_dcb ._fbf )-1&&_dcb ._ab !=0{return _c .EOF ;};if _dcb ._ab ==0{_dcb ._fbf [_dcb ._cdbe ]=_age ;_dcb ._cdbe ++;return nil ;};
if _dcb ._bbgc {_dcb ._fbf [_dcb ._cdbe ]|=_age >>_dcb ._ab ;_dcb ._cdbe ++;_dcb ._fbf [_dcb ._cdbe ]=byte (uint16 (_age )<<(8-_dcb ._ab )&0xff);}else {_dcb ._fbf [_dcb ._cdbe ]|=byte (uint16 (_age )<<_dcb ._ab &0xff);_dcb ._cdbe ++;_dcb ._fbf [_dcb ._cdbe ]=_age >>(8-_dcb ._ab );
};return nil ;};func (_gb *SubstreamReader )StreamPosition ()int64 {return int64 (_gb ._fde )};func (_gg *BufferedWriter )Write (d []byte )(int ,error ){_gg .expandIfNeeded (len (d ));if _gg ._e ==0{return _gg .writeFullBytes (d ),nil ;};return _gg .writeShiftedBytes (d ),nil ;
};type BinaryWriter interface{BitWriter ;_c .Writer ;_c .ByteWriter ;Data ()[]byte ;};func (_dgee *SubstreamReader )Mark (){_dgee ._fbg =_dgee ._fde ;_dgee ._cbge =_dgee ._eca };func (_fgg *BufferedWriter )writeFullBytes (_ace []byte )int {_ecb :=copy (_fgg ._bc [_fgg .fullOffset ():],_ace );
_fgg ._fa +=_ecb ;return _ecb ;};func (_eeg *Writer )Write (p []byte )(int ,error ){if len (p )> _eeg .byteCapacity (){return 0,_c .EOF ;};for _ ,_cee :=range p {if _cff :=_eeg .writeByte (_cee );_cff !=nil {return 0,_cff ;};};return len (p ),nil ;};func (_caa *SubstreamReader )fillBuffer ()error {if uint64 (_caa ._eeaf .StreamPosition ())!=_caa ._fde +_caa ._gdb {_ ,_cgc :=_caa ._eeaf .Seek (int64 (_caa ._fde +_caa ._gdb ),_c .SeekStart );
if _cgc !=nil {return _cgc ;};};_caa ._bgf =_caa ._fde ;_ade :=_aecd (uint64 (len (_caa ._bda )),_caa ._dcc -_caa ._fde );_cfcb :=make ([]byte ,_ade );_gbc ,_aad :=_caa ._eeaf .Read (_cfcb );if _aad !=nil {return _aad ;};for _fgbe :=uint64 (0);_fgbe < _ade ;
_fgbe ++{_caa ._bda [_fgbe ]=_cfcb [_fgbe ];};_caa ._bbdf =_caa ._bgf +uint64 (_gbc );return nil ;};type StreamReader interface{_c .Reader ;_c .ByteReader ;_c .Seeker ;Align ()byte ;BitPosition ()int ;Mark ();Length ()uint64 ;ReadBit ()(int ,error );ReadBits (_fce byte )(uint64 ,error );
ReadBool ()(bool ,error );ReadUint32 ()(uint32 ,error );Reset ();StreamPosition ()int64 ;};func NewWriterMSB (data []byte )*Writer {return &Writer {_fbf :data ,_bbgc :true }};func (_cd *BufferedWriter )WriteByte (bt byte )error {if _cd ._fa > len (_cd ._bc )-1||(_cd ._fa ==len (_cd ._bc )-1&&_cd ._e !=0){_cd .expandIfNeeded (1);
};_cd .writeByte (bt );return nil ;};func (_fcegb *Reader )ReadBits (n byte )(_ad uint64 ,_cdb error ){if n < _fcegb ._dee {_dge :=_fcegb ._dee -n ;_ad =uint64 (_fcegb ._gfd >>_dge );_fcegb ._gfd &=1<<_dge -1;_fcegb ._dee =_dge ;return _ad ,nil ;};if n > _fcegb ._dee {if _fcegb ._dee > 0{_ad =uint64 (_fcegb ._gfd );
n -=_fcegb ._dee ;};for n >=8{_ddf ,_fbc :=_fcegb .readBufferByte ();if _fbc !=nil {return 0,_fbc ;};_ad =_ad <<8+uint64 (_ddf );n -=8;};if n > 0{if _fcegb ._gfd ,_cdb =_fcegb .readBufferByte ();_cdb !=nil {return 0,_cdb ;};_bca :=8-n ;_ad =_ad <<n +uint64 (_fcegb ._gfd >>_bca );
_fcegb ._gfd &=1<<_bca -1;_fcegb ._dee =_bca ;}else {_fcegb ._dee =0;};return _ad ,nil ;};_fcegb ._dee =0;return uint64 (_fcegb ._gfd ),nil ;};func (_ec *BufferedWriter )fullOffset ()int {_eea :=_ec ._fa ;if _ec ._e !=0{_eea ++;};return _eea ;};func (_eb *BufferedWriter )Reset (){_eb ._bc =_eb ._bc [:0];
_eb ._fa =0;_eb ._e =0};func (_acgf *SubstreamReader )Reset (){_acgf ._fde =_acgf ._fbg ;_acgf ._eca =_acgf ._cbge };func (_cgf *SubstreamReader )ReadBits (n byte )(_ebg uint64 ,_bde error ){if n < _cgf ._eca {_dbc :=_cgf ._eca -n ;_ebg =uint64 (_cgf ._add >>_dbc );
_cgf ._add &=1<<_dbc -1;_cgf ._eca =_dbc ;return _ebg ,nil ;};if n > _cgf ._eca {if _cgf ._eca > 0{_ebg =uint64 (_cgf ._add );n -=_cgf ._eca ;};var _fec byte ;for n >=8{_fec ,_bde =_cgf .readBufferByte ();if _bde !=nil {return 0,_bde ;};_ebg =_ebg <<8+uint64 (_fec );
n -=8;};if n > 0{if _cgf ._add ,_bde =_cgf .readBufferByte ();_bde !=nil {return 0,_bde ;};_bbb :=8-n ;_ebg =_ebg <<n +uint64 (_cgf ._add >>_bbb );_cgf ._add &=1<<_bbb -1;_cgf ._eca =_bbb ;}else {_cgf ._eca =0;};return _ebg ,nil ;};_cgf ._eca =0;return uint64 (_cgf ._add ),nil ;
};func (_cbg *Reader )read (_cdeb []byte )(int ,error ){if _cbg ._gab >=int64 (len (_cbg ._ceb )){return 0,_c .EOF ;};_cbg ._cf =-1;_ecg :=copy (_cdeb ,_cbg ._ceb [_cbg ._gab :]);_cbg ._gab +=int64 (_ecg );return _ecg ,nil ;};func (_fd *BufferedWriter )expandIfNeeded (_bd int ){if !_fd .tryGrowByReslice (_bd ){_fd .grow (_bd );
};};func (_bae *Reader )ConsumeRemainingBits (){if _bae ._dee !=0{_ ,_acd :=_bae .ReadBits (_bae ._dee );if _acd !=nil {_f .Log .Debug ("\u0043\u006f\u006e\u0073\u0075\u006d\u0065\u0052\u0065\u006da\u0069\u006e\u0069\u0067\u0042\u0069\u0074s\u0020\u0066\u0061\u0069\u006c\u0065\u0064\u003a\u0020\u0025\u0076",_acd );
};};};func (_gdd *Reader )Mark (){_gdd ._cg =_gdd ._gab ;_gdd ._bdd =_gdd ._dee };func (_efg *BufferedWriter )tryGrowByReslice (_gfa int )bool {if _fcb :=len (_efg ._bc );_gfa <=cap (_efg ._bc )-_fcb {_efg ._bc =_efg ._bc [:_fcb +_gfa ];return true ;};
return false ;};const (_bb =64;_g =int (^uint (0)>>1););func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_be :true }};func (_efb *Reader )Reset (){_efb ._gab =_efb ._cg ;_efb ._dee =_efb ._bdd };func (_ef *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;
};_cb :=int (_ef ._e )+skip ;if _cb >=0&&_cb < 8{_ef ._e =uint8 (_cb );return nil ;};_cb =int (_ef ._e )+_ef ._fa *8+skip ;if _cb < 0{return _fg .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_dd :=_cb /8;_bf :=_cb %8;_ef ._e =uint8 (_bf );if _eg :=_dd -_ef ._fa ;_eg > 0&&len (_ef ._bc )-1< _dd {if _ef ._e !=0{_eg ++;};_ef .expandIfNeeded (_eg );};_ef ._fa =_dd ;return nil ;};func (_fgf *Reader )readBool ()(_bfc bool ,_fgb error ){if _fgf ._dee ==0{_fgf ._gfd ,_fgb =_fgf .readBufferByte ();
if _fgb !=nil {return false ,_fgb ;};_bfc =(_fgf ._gfd &0x80)!=0;_fgf ._gfd ,_fgf ._dee =_fgf ._gfd &0x7f,7;return _bfc ,nil ;};_fgf ._dee --;_bfc =(_fgf ._gfd &(1<<_fgf ._dee ))!=0;_fgf ._gfd &=1<<_fgf ._dee -1;return _bfc ,nil ;};func (_dac *Reader )Length ()uint64 {return uint64 (len (_dac ._ceb ))};
func (_gddb *Reader )ReadByte ()(byte ,error ){if _gddb ._dee ==0{return _gddb .readBufferByte ();};return _gddb .readUnalignedByte ();};func (_gea *Reader )Read (p []byte )(_agb int ,_ed error ){if _gea ._dee ==0{return _gea .read (p );};for ;_agb < len (p );
_agb ++{if p [_agb ],_ed =_gea .readUnalignedByte ();_ed !=nil {return 0,_ed ;};};return _agb ,nil ;};func (_ead *Writer )FinishByte (){if _ead ._ab ==0{return ;};_ead ._ab =0;_ead ._cdbe ++;};func (_gga *SubstreamReader )Seek (offset int64 ,whence int )(int64 ,error ){switch whence {case _c .SeekStart :_gga ._fde =uint64 (offset );
case _c .SeekCurrent :_gga ._fde +=uint64 (offset );case _c .SeekEnd :_gga ._fde =_gga ._dcc +uint64 (offset );default:return 0,_a .New ("\u0072\u0065\u0061d\u0065\u0072\u002e\u0053\u0075\u0062\u0073\u0074\u0072\u0065\u0061\u006d\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u0020\u0069\u006e\u0076\u0061\u006ci\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};_gga ._eca =0;return int64 (_gga ._fde ),nil ;};func (_fdg *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_fdg ._cf =-1;var _agd int64 ;switch whence {case _c .SeekStart :_agd =offset ;case _c .SeekCurrent :_agd =_fdg ._gab +offset ;case _c .SeekEnd :_agd =int64 (len (_fdg ._ceb ))+offset ;
default:return 0,_a .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");};if _agd < 0{return 0,_a .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");
};_fdg ._gab =_agd ;_fdg ._dee =0;return _agd ,nil ;};func (_cda *Writer )WriteByte (c byte )error {return _cda .writeByte (c )};func (_db *BufferedWriter )grow (_ba int ){if _db ._bc ==nil &&_ba < _bb {_db ._bc =make ([]byte ,_ba ,_bb );return ;};_fb :=len (_db ._bc );
if _db ._e !=0{_fb ++;};_gcg :=cap (_db ._bc );switch {case _ba <=_gcg /2-_fb :_f .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_db ._bc ),cap (_db ._bc ),_ba );
_f .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_gcg ,_fb );copy (_db ._bc ,_db ._bc [_db .fullOffset ():]);
case _gcg > _g -_gcg -_ba :_f .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_gca :=make ([]byte ,2*_gcg +_ba );copy (_gca ,_db ._bc );_db ._bc =_gca ;};_db ._bc =_db ._bc [:_fb +_ba ];
};func (_gd *BufferedWriter )Data ()[]byte {return _gd ._bc };var _ _c .Writer =&BufferedWriter {};func (_ccg *SubstreamReader )ReadByte ()(byte ,error ){if _ccg ._eca ==0{return _ccg .readBufferByte ();};return _ccg .readUnalignedByte ();};func (_aaa *BufferedWriter )writeShiftedBytes (_de []byte )int {for _ ,_aee :=range _de {_aaa .writeByte (_aee );
};return len (_de );};func (_adc *Writer )byteCapacity ()int {_gbb :=len (_adc ._fbf )-_adc ._cdbe ;if _adc ._ab !=0{_gbb --;};return _gbb ;};type BitWriter interface{WriteBit (_dgf int )error ;WriteBits (_bcf uint64 ,_aaaa int )(_gge int ,_cae error );
FinishByte ();SkipBits (_aeb int )error ;};func (_gc *BufferedWriter )Len ()int {return _gc .byteCapacity ()};func NewReader (data []byte )*Reader {return &Reader {_ceb :data }};func _aecd (_cgb ,_bdee uint64 )uint64 {if _cgb < _bdee {return _cgb ;};return _bdee ;
};var (_ _c .Reader =&Reader {};_ _c .ByteReader =&Reader {};_ _c .Seeker =&Reader {};_ StreamReader =&Reader {};);type Reader struct{_ceb []byte ;_gfd byte ;_dee byte ;_gab int64 ;_cdg int ;_cf int ;_cg int64 ;_bdd byte ;};func (_gaa *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _gaa .writeBit (uint8 (bit ));
};return _fg .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");};