//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_f "encoding/binary";_eb "errors";_a "github.com/unidoc/unipdf/v3/common";_b "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_ee "io";);func (_da *BufferedWriter )byteCapacity ()int {_gg :=len (_da ._ab )-_da ._ba ;if _da ._ad !=0{_gg --;
};return _gg ;};func (_bac *BufferedWriter )Data ()[]byte {return _bac ._ab };func (_acgb *SubstreamReader )StreamPosition ()int64 {return int64 (_acgb ._eab )};func (_ffe *SubstreamReader )Mark (){_ffe ._acf =_ffe ._eab ;_ffe ._cgcg =_ffe ._ag };func (_aaa *BufferedWriter )writeShiftedBytes (_bee []byte )int {for _ ,_cb :=range _bee {_aaa .writeByte (_cb );
};return len (_bee );};func (_cadg *Writer )FinishByte (){if _cadg ._aag ==0{return ;};_cadg ._aag =0;_cadg ._caa ++;};func (_afb *SubstreamReader )Length ()uint64 {return _afb ._cgb };type BinaryWriter interface{BitWriter ;_ee .Writer ;_ee .ByteWriter ;
Data ()[]byte ;};type BitWriter interface{WriteBit (_fg int )error ;WriteBits (_ac uint64 ,_gb int )(_bgb int ,_bfb error );FinishByte ();SkipBits (_ecd int )error ;};func (_fde *Writer )Data ()[]byte {return _fde ._fge };func (_gdd *BufferedWriter )WriteByte (bt byte )error {if _gdd ._ba > len (_gdd ._ab )-1||(_gdd ._ba ==len (_gdd ._ab )-1&&_gdd ._ad !=0){_gdd .expandIfNeeded (1);
};_gdd .writeByte (bt );return nil ;};func (_eaad *Reader )ConsumeRemainingBits (){if _eaad ._cd !=0{_ ,_ccb :=_eaad .ReadBits (_eaad ._cd );if _ccb !=nil {_a .Log .Debug ("\u0043\u006f\u006e\u0073\u0075\u006d\u0065\u0052\u0065\u006da\u0069\u006e\u0069\u0067\u0042\u0069\u0074s\u0020\u0066\u0061\u0069\u006c\u0065\u0064\u003a\u0020\u0025\u0076",_ccb );
};};};func (_ef *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _b .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );
};if len (_ef ._ab )-1< _ef ._ba {_ef .expandIfNeeded (1);};_eec :=_ef ._ad ;if _ef ._dc {_eec =7-_ef ._ad ;};_ef ._ab [_ef ._ba ]|=byte (uint16 (bit <<_eec )&0xff);_ef ._ad ++;if _ef ._ad ==8{_ef ._ba ++;_ef ._ad =0;};return nil ;};func (_bff *SubstreamReader )fillBuffer ()error {if uint64 (_bff ._egb .StreamPosition ())!=_bff ._eab +_bff ._fbd {_ ,_gba :=_bff ._egb .Seek (int64 (_bff ._eab +_bff ._fbd ),_ee .SeekStart );
if _gba !=nil {return _gba ;};};_bff ._adb =_bff ._eab ;_ffg :=_bab (uint64 (len (_bff ._aabc )),_bff ._cgb -_bff ._eab );_dfcf :=make ([]byte ,_ffg );_gedd ,_age :=_bff ._egb .Read (_dfcf );if _age !=nil {return _age ;};for _fdg :=uint64 (0);_fdg < _ffg ;
_fdg ++{_bff ._aabc [_fdg ]=_dfcf [_fdg ];};_bff ._gcd =_bff ._adb +uint64 (_gedd );return nil ;};func (_fac *SubstreamReader )ReadUint32 ()(uint32 ,error ){_bdf :=make ([]byte ,4);_ ,_ecee :=_fac .Read (_bdf );if _ecee !=nil {return 0,_ecee ;};return _f .BigEndian .Uint32 (_bdf ),nil ;
};func NewWriter (data []byte )*Writer {return &Writer {_fge :data }};func (_c *BufferedWriter )ResetBitIndex (){_c ._ad =0};func NewSubstreamReader (r StreamReader ,offset ,length uint64 )(*SubstreamReader ,error ){if r ==nil {return nil ,_eb .New ("\u0072o\u006ft\u0020\u0072\u0065\u0061\u0064e\u0072\u0020i\u0073\u0020\u006e\u0069\u006c");
};_a .Log .Trace ("\u004e\u0065\u0077\u0053\u0075\u0062\u0073\u0074r\u0065\u0061\u006dRe\u0061\u0064\u0065\u0072\u0020\u0061t\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u003a\u0020\u0025\u0064\u0020\u0077\u0069\u0074h\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a \u0025\u0064",offset ,length );
return &SubstreamReader {_egb :r ,_fbd :offset ,_cgb :length ,_aabc :make ([]byte ,length )},nil ;};func (_ggd *Reader )readBufferByte ()(byte ,error ){if _ggd ._afg >=int64 (len (_ggd ._eaa )){return 0,_ee .EOF ;};_ggd ._dfd =-1;_bcf :=_ggd ._eaa [_ggd ._afg ];
_ggd ._afg ++;_ggd ._gf =int (_bcf );return _bcf ,nil ;};func (_bce *Reader )Mark (){_bce ._bd =_bce ._afg ;_bce ._eg =_bce ._cd };func (_ccdc *Reader )ReadBool ()(bool ,error ){return _ccdc .readBool ()};func (_cce *BufferedWriter )tryGrowByReslice (_ggca int )bool {if _add :=len (_cce ._ab );
_ggca <=cap (_cce ._ab )-_add {_cce ._ab =_cce ._ab [:_add +_ggca ];return true ;};return false ;};type SubstreamReader struct{_eab uint64 ;_egb StreamReader ;_fbd uint64 ;_cgb uint64 ;_aabc []byte ;_adb uint64 ;_gcd uint64 ;_abd byte ;_ag byte ;_acf uint64 ;
_cgcg byte ;};type StreamReader interface{_ee .Reader ;_ee .ByteReader ;_ee .Seeker ;Align ()byte ;BitPosition ()int ;Mark ();Length ()uint64 ;ReadBit ()(int ,error );ReadBits (_eee byte )(uint64 ,error );ReadBool ()(bool ,error );ReadUint32 ()(uint32 ,error );
Reset ();StreamPosition ()int64 ;};func (_cdg *Reader )readUnalignedByte ()(_dbc byte ,_bb error ){_cca :=_cdg ._cd ;_dbc =_cdg ._def <<(8-_cca );_cdg ._def ,_bb =_cdg .readBufferByte ();if _bb !=nil {return 0,_bb ;};_dbc |=_cdg ._def >>_cca ;_cdg ._def &=1<<_cca -1;
return _dbc ,nil ;};func _bab (_aae ,_eef uint64 )uint64 {if _aae < _eef {return _aae ;};return _eef ;};func (_fba *SubstreamReader )Seek (offset int64 ,whence int )(int64 ,error ){switch whence {case _ee .SeekStart :_fba ._eab =uint64 (offset );case _ee .SeekCurrent :_fba ._eab +=uint64 (offset );
case _ee .SeekEnd :_fba ._eab =_fba ._cgb +uint64 (offset );default:return 0,_eb .New ("\u0072\u0065\u0061d\u0065\u0072\u002e\u0053\u0075\u0062\u0073\u0074\u0072\u0065\u0061\u006d\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u0020\u0069\u006e\u0076\u0061\u006ci\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};_fba ._ag =0;return int64 (_fba ._eab ),nil ;};func (_gc *Reader )BitPosition ()int {return int (_gc ._cd )};func (_gcf *Reader )ReadByte ()(byte ,error ){if _gcf ._cd ==0{return _gcf .readBufferByte ();};return _gcf .readUnalignedByte ();};func (_eag *BufferedWriter )grow (_bc int ){if _eag ._ab ==nil &&_bc < _bf {_eag ._ab =make ([]byte ,_bc ,_bf );
return ;};_fb :=len (_eag ._ab );if _eag ._ad !=0{_fb ++;};_ggc :=cap (_eag ._ab );switch {case _bc <=_ggc /2-_fb :_a .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_eag ._ab ),cap (_eag ._ab ),_bc );
_a .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_ggc ,_fb );copy (_eag ._ab ,_eag ._ab [_eag .fullOffset ():]);
case _ggc > _g -_ggc -_bc :_a .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_cf :=make ([]byte ,2*_ggc +_bc );copy (_cf ,_eag ._ab );_eag ._ab =_cf ;};_eag ._ab =_eag ._ab [:_fb +_bc ];
};func (_abb *Writer )WriteByte (c byte )error {return _abb .writeByte (c )};func (_ff *Reader )Align ()(_ggf byte ){_ggf =_ff ._cd ;_ff ._cd =0;return _ggf };func (_cag *Writer )ResetBit (){_cag ._aag =0};func (_ebe *Writer )Write (p []byte )(int ,error ){if len (p )> _ebe .byteCapacity (){return 0,_ee .EOF ;
};for _ ,_eacf :=range p {if _bea :=_ebe .writeByte (_eacf );_bea !=nil {return 0,_bea ;};};return len (p ),nil ;};func (_fdc *Reader )ReadUint32 ()(uint32 ,error ){_dca :=make ([]byte ,4);_ ,_ce :=_fdc .Read (_dca );if _ce !=nil {return 0,_ce ;};return _f .BigEndian .Uint32 (_dca ),nil ;
};func (_dgf *Reader )Read (p []byte )(_addd int ,_egc error ){if _dgf ._cd ==0{return _dgf .read (p );};for ;_addd < len (p );_addd ++{if p [_addd ],_egc =_dgf .readUnalignedByte ();_egc !=nil {return 0,_egc ;};};return _addd ,nil ;};func (_afc *Reader )read (_bge []byte )(int ,error ){if _afc ._afg >=int64 (len (_afc ._eaa )){return 0,_ee .EOF ;
};_afc ._dfd =-1;_bcb :=copy (_bge ,_afc ._eaa [_afc ._afg :]);_afc ._afg +=int64 (_bcb );return _bcb ,nil ;};func (_cfc *SubstreamReader )ReadBits (n byte )(_cafd uint64 ,_ecca error ){if n < _cfc ._ag {_aga :=_cfc ._ag -n ;_cafd =uint64 (_cfc ._abd >>_aga );
_cfc ._abd &=1<<_aga -1;_cfc ._ag =_aga ;return _cafd ,nil ;};if n > _cfc ._ag {if _cfc ._ag > 0{_cafd =uint64 (_cfc ._abd );n -=_cfc ._ag ;};var _daf byte ;for n >=8{_daf ,_ecca =_cfc .readBufferByte ();if _ecca !=nil {return 0,_ecca ;};_cafd =_cafd <<8+uint64 (_daf );
n -=8;};if n > 0{if _cfc ._abd ,_ecca =_cfc .readBufferByte ();_ecca !=nil {return 0,_ecca ;};_ged :=8-n ;_cafd =_cafd <<n +uint64 (_cfc ._abd >>_ged );_cfc ._abd &=1<<_ged -1;_cfc ._ag =_ged ;}else {_cfc ._ag =0;};return _cafd ,nil ;};_cfc ._ag =0;return uint64 (_cfc ._abd ),nil ;
};func (_acb *SubstreamReader )BitPosition ()int {return int (_acb ._ag )};func (_dgg *Reader )ReadBit ()(_cff int ,_edg error ){_eagf ,_edg :=_dgg .readBool ();if _edg !=nil {return 0,_edg ;};if _eagf {_cff =1;};return _cff ,nil ;};func (_dadg *SubstreamReader )ReadBool ()(bool ,error ){return _dadg .readBool ()};
func (_fgg *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_fgg ._dfd =-1;var _ffbe int64 ;switch whence {case _ee .SeekStart :_ffbe =offset ;case _ee .SeekCurrent :_ffbe =_fgg ._afg +offset ;case _ee .SeekEnd :_ffbe =int64 (len (_fgg ._eaa ))+offset ;
default:return 0,_eb .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");};if _ffbe < 0{return 0,_eb .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");
};_fgg ._afg =_ffbe ;_fgg ._cd =0;return _ffbe ,nil ;};func (_fc *SubstreamReader )readUnalignedByte ()(_egbf byte ,_agac error ){_dae :=_fc ._ag ;_egbf =_fc ._abd <<(8-_dae );_fc ._abd ,_agac =_fc .readBufferByte ();if _agac !=nil {return 0,_agac ;};_egbf |=_fc ._abd >>_dae ;
_fc ._abd &=1<<_dae -1;return _egbf ,nil ;};func (_ccf *BufferedWriter )writeByte (_bgg byte ){switch {case _ccf ._ad ==0:_ccf ._ab [_ccf ._ba ]=_bgg ;_ccf ._ba ++;case _ccf ._dc :_ccf ._ab [_ccf ._ba ]|=_bgg >>_ccf ._ad ;_ccf ._ba ++;_ccf ._ab [_ccf ._ba ]=byte (uint16 (_bgg )<<(8-_ccf ._ad )&0xff);
default:_ccf ._ab [_ccf ._ba ]|=byte (uint16 (_bgg )<<_ccf ._ad &0xff);_ccf ._ba ++;_ccf ._ab [_ccf ._ba ]=_bgg >>(8-_ccf ._ad );};};func (_be *BufferedWriter )Len ()int {return _be .byteCapacity ()};var _ BinaryWriter =&BufferedWriter {};type BufferedWriter struct{_ab []byte ;
_ad uint8 ;_ba int ;_dc bool ;};func (_dfe *Reader )Reset (){_dfe ._afg =_dfe ._bd ;_dfe ._cd =_dfe ._eg };func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_dc :true }};func (_bfbd *Reader )readBool ()(_gef bool ,_ggg error ){if _bfbd ._cd ==0{_bfbd ._def ,_ggg =_bfbd .readBufferByte ();
if _ggg !=nil {return false ,_ggg ;};_gef =(_bfbd ._def &0x80)!=0;_bfbd ._def ,_bfbd ._cd =_bfbd ._def &0x7f,7;return _gef ,nil ;};_bfbd ._cd --;_gef =(_bfbd ._def &(1<<_bfbd ._cd ))!=0;_bfbd ._def &=1<<_bfbd ._cd -1;return _gef ,nil ;};func (_eeg *SubstreamReader )Reset (){_eeg ._eab =_eeg ._acf ;
_eeg ._ag =_eeg ._cgcg };func (_agf *SubstreamReader )ReadBit ()(_dad int ,_acg error ){_agfa ,_acg :=_agf .readBool ();if _acg !=nil {return 0,_acg ;};if _agfa {_dad =1;};return _dad ,nil ;};func (_cbe *Reader )Length ()uint64 {return uint64 (len (_cbe ._eaa ))};
const (_bf =64;_g =int (^uint (0)>>1););var _ BinaryWriter =&Writer {};func (_dba *Writer )WriteBits (bits uint64 ,number int )(_aabe int ,_dfa error ){const _edce ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";
if number < 0||number > 64{return 0,_b .Errorf (_edce ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};if number ==0{return 0,nil ;};_fgeb :=number /8;if _fgeb > 0{_fgf :=number -_fgeb *8;for _abf :=_fgeb -1;_abf >=0;_abf --{_egbfa :=byte ((bits >>uint (_abf *8+_fgf ))&0xff);if _dfa =_dba .WriteByte (_egbfa );_dfa !=nil {return _aabe ,_b .Wrapf (_dfa ,_edce ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_fgeb -_abf +1);
};};number -=_fgeb *8;if number ==0{return _fgeb ,nil ;};};var _eabg int ;for _cae :=0;_cae < number ;_cae ++{if _dba ._efa {_eabg =int ((bits >>uint (number -1-_cae ))&0x1);}else {_eabg =int (bits &0x1);bits >>=1;};if _dfa =_dba .WriteBit (_eabg );_dfa !=nil {return _aabe ,_b .Wrapf (_dfa ,_edce ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_cae );
};};return _fgeb ,nil ;};func (_cad *BufferedWriter )expandIfNeeded (_gdf int ){if !_cad .tryGrowByReslice (_gdf ){_cad .grow (_gdf );};};type Reader struct{_eaa []byte ;_def byte ;_cd byte ;_afg int64 ;_gf int ;_dfd int ;_bd int64 ;_eg byte ;};func NewWriterMSB (data []byte )*Writer {return &Writer {_fge :data ,_efa :true }};
var _ _ee .Writer =&BufferedWriter {};func (_baa *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _baa .writeBit (uint8 (bit ));};return _b .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");
};func (_bec *SubstreamReader )Offset ()uint64 {return _bec ._fbd };func (_fgd *SubstreamReader )readBool ()(_cdc bool ,_gdec error ){if _fgd ._ag ==0{_fgd ._abd ,_gdec =_fgd .readBufferByte ();if _gdec !=nil {return false ,_gdec ;};_cdc =(_fgd ._abd &0x80)!=0;
_fgd ._abd ,_fgd ._ag =_fgd ._abd &0x7f,7;return _cdc ,nil ;};_fgd ._ag --;_cdc =(_fgd ._abd &(1<<_fgd ._ag ))!=0;_fgd ._abd &=1<<_fgd ._ag -1;return _cdc ,nil ;};func (_ccdb *BufferedWriter )writeFullBytes (_ae []byte )int {_ec :=copy (_ccdb ._ab [_ccdb .fullOffset ():],_ae );
_ccdb ._ba +=_ec ;return _ec ;};func (_aea *Reader )ReadBits (n byte )(_cgc uint64 ,_ece error ){if n < _aea ._cd {_dd :=_aea ._cd -n ;_cgc =uint64 (_aea ._def >>_dd );_aea ._def &=1<<_dd -1;_aea ._cd =_dd ;return _cgc ,nil ;};if n > _aea ._cd {if _aea ._cd > 0{_cgc =uint64 (_aea ._def );
n -=_aea ._cd ;};for n >=8{_aab ,_ffb :=_aea .readBufferByte ();if _ffb !=nil {return 0,_ffb ;};_cgc =_cgc <<8+uint64 (_aab );n -=8;};if n > 0{if _aea ._def ,_ece =_aea .readBufferByte ();_ece !=nil {return 0,_ece ;};_fa :=8-n ;_cgc =_cgc <<n +uint64 (_aea ._def >>_fa );
_aea ._def &=1<<_fa -1;_aea ._cd =_fa ;}else {_aea ._cd =0;};return _cgc ,nil ;};_aea ._cd =0;return uint64 (_aea ._def ),nil ;};func (_bgc *SubstreamReader )Align ()(_fbb byte ){_fbb =_bgc ._ag ;_bgc ._ag =0;return _fbb };func (_eeb *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;
};_aba :=int (_eeb ._ad )+skip ;if _aba >=0&&_aba < 8{_eeb ._ad =uint8 (_aba );return nil ;};_aba =int (_eeb ._ad )+_eeb ._ba *8+skip ;if _aba < 0{return _b .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_ca :=_aba /8;_ge :=_aba %8;_eeb ._ad =uint8 (_ge );if _gd :=_ca -_eeb ._ba ;_gd > 0&&len (_eeb ._ab )-1< _ca {if _eeb ._ad !=0{_gd ++;};_eeb .expandIfNeeded (_gd );};_eeb ._ba =_ca ;return nil ;};func (_bg *BufferedWriter )Write (d []byte )(int ,error ){_bg .expandIfNeeded (len (d ));
if _bg ._ad ==0{return _bg .writeFullBytes (d ),nil ;};return _bg .writeShiftedBytes (d ),nil ;};func (_bgce *SubstreamReader )ReadByte ()(byte ,error ){if _bgce ._ag ==0{return _bgce .readBufferByte ();};return _bgce .readUnalignedByte ();};func (_dff *Writer )writeBit (_dfb uint8 )error {if len (_dff ._fge )-1< _dff ._caa {return _ee .EOF ;
};_gbf :=_dff ._aag ;if _dff ._efa {_gbf =7-_dff ._aag ;};_dff ._fge [_dff ._caa ]|=byte (uint16 (_dfb <<_gbf )&0xff);_dff ._aag ++;if _dff ._aag ==8{_dff ._caa ++;_dff ._aag =0;};return nil ;};func (_cga *SubstreamReader )readBufferByte ()(byte ,error ){if _cga ._eab >=_cga ._cgb {return 0,_ee .EOF ;
};if _cga ._eab >=_cga ._gcd ||_cga ._eab < _cga ._adb {if _ddg :=_cga .fillBuffer ();_ddg !=nil {return 0,_ddg ;};};_dafg :=_cga ._aabc [_cga ._eab -_cga ._adb ];_cga ._eab ++;return _dafg ,nil ;};var _ _ee .ByteWriter =&BufferedWriter {};type Writer struct{_fge []byte ;
_aag uint8 ;_caa int ;_efa bool ;};func (_ed *BufferedWriter )FinishByte (){if _ed ._ad ==0{return ;};_ed ._ad =0;_ed ._ba ++;};func (_aa *BufferedWriter )fullOffset ()int {_dbe :=_aa ._ba ;if _aa ._ad !=0{_dbe ++;};return _dbe ;};func NewReader (data []byte )*Reader {return &Reader {_eaa :data }};
func (_de *BufferedWriter )Reset (){_de ._ab =_de ._ab [:0];_de ._ba =0;_de ._ad =0};func (_fbc *Writer )UseMSB ()bool {return _fbc ._efa };func (_dec *Reader )StreamPosition ()int64 {return _dec ._afg };func (_db *BufferedWriter )WriteBits (bits uint64 ,number int )(_df int ,_ada error ){const _dg ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";
if number < 0||number > 64{return 0,_b .Errorf (_dg ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};_cc :=number /8;if _cc > 0{_edc :=number -_cc *8;for _af :=_cc -1;_af >=0;_af --{_dfc :=byte ((bits >>uint (_af *8+_edc ))&0xff);if _ada =_db .WriteByte (_dfc );_ada !=nil {return _df ,_b .Wrapf (_ada ,_dg ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_cc -_af +1);
};};number -=_cc *8;if number ==0{return _cc ,nil ;};};var _ccd int ;for _ea :=0;_ea < number ;_ea ++{if _db ._dc {_ccd =int ((bits >>uint (number -1-_ea ))&0x1);}else {_ccd =int (bits &0x1);bits >>=1;};if _ada =_db .WriteBit (_ccd );_ada !=nil {return _df ,_b .Wrapf (_ada ,_dg ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_ea );
};};return _cc ,nil ;};var (_ _ee .Reader =&Reader {};_ _ee .ByteReader =&Reader {};_ _ee .Seeker =&Reader {};_ StreamReader =&Reader {};);func (_ggdg *Writer )writeByte (_dcaf byte )error {if _ggdg ._caa > len (_ggdg ._fge )-1{return _ee .EOF ;};if _ggdg ._caa ==len (_ggdg ._fge )-1&&_ggdg ._aag !=0{return _ee .EOF ;
};if _ggdg ._aag ==0{_ggdg ._fge [_ggdg ._caa ]=_dcaf ;_ggdg ._caa ++;return nil ;};if _ggdg ._efa {_ggdg ._fge [_ggdg ._caa ]|=_dcaf >>_ggdg ._aag ;_ggdg ._caa ++;_ggdg ._fge [_ggdg ._caa ]=byte (uint16 (_dcaf )<<(8-_ggdg ._aag )&0xff);}else {_ggdg ._fge [_ggdg ._caa ]|=byte (uint16 (_dcaf )<<_ggdg ._aag &0xff);
_ggdg ._caa ++;_ggdg ._fge [_ggdg ._caa ]=_dcaf >>(8-_ggdg ._aag );};return nil ;};func (_dfg *Writer )SkipBits (skip int )error {const _gdg ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";if skip ==0{return nil ;};_eeff :=int (_dfg ._aag )+skip ;
if _eeff >=0&&_eeff < 8{_dfg ._aag =uint8 (_eeff );return nil ;};_eeff =int (_dfg ._aag )+_dfg ._caa *8+skip ;if _eeff < 0{return _b .Errorf (_gdg ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_faf :=_eeff /8;
_ecb :=_eeff %8;_a .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");_a .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_dfg ._aag ,_dfg ._caa ,int (_dfg ._aag )+(_dfg ._caa )*8,len (_dfg ._fge ),cap (_dfg ._fge ));
_a .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_eeff ,_ecb );_dfg ._aag =uint8 (_ecb );if _ffc :=_faf -_dfg ._caa ;
_ffc > 0&&len (_dfg ._fge )-1< _faf {_a .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_ffc );return _b .Errorf (_gdg ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_dfg ._caa =_faf ;
_a .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_dfg ._aag ,_dfg ._caa );return nil ;};func (_ade *Writer )byteCapacity ()int {_bdb :=len (_ade ._fge )-_ade ._caa ;
if _ade ._aag !=0{_bdb --;};return _bdb ;};func (_ceb *SubstreamReader )Read (b []byte )(_fga int ,_cdge error ){if _ceb ._eab >=_ceb ._cgb {_a .Log .Trace ("\u0053\u0074\u0072e\u0061\u006d\u0050\u006fs\u003a\u0020\u0027\u0025\u0064\u0027\u0020>\u003d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027",_ceb ._eab ,_ceb ._cgb );
return 0,_ee .EOF ;};for ;_fga < len (b );_fga ++{if b [_fga ],_cdge =_ceb .readUnalignedByte ();_cdge !=nil {if _cdge ==_ee .EOF {return _fga ,nil ;};return 0,_cdge ;};};return _fga ,nil ;};