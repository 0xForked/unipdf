//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_c "encoding/binary";_d "errors";_cg "github.com/unidoc/unipdf/v3/common";_dc "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_ea "io";);func (_aea *Reader )ReadBool ()(bool ,error ){return _aea .readBool ()};func (_afg *Reader )ReadByte ()(byte ,error ){if _afg ._add ==0{return _afg .readBufferByte ();};return _afg .readUnalignedByte ();};func (_eed *BufferedWriter )writeShiftedBytes (_gac []byte )int {for _ ,_aa :=range _gac {_eed .writeByte (_aa );};return len (_gac );};func (_bc *BufferedWriter )FinishByte (){if _bc ._fc ==0{return ;};_bc ._fc =0;_bc ._ed ++;};func (_bbfc *BufferedWriter )byteCapacity ()int {_dce :=len (_bbfc ._eff )-_bbfc ._ed ;if _bbfc ._fc !=0{_dce --;};return _dce ;};func (_gdd *SubstreamReader )Align ()(_cgc byte ){_cgc =_gdd ._cca ;_gdd ._cca =0;return _cgc };func (_gff *BufferedWriter )WriteByte (bt byte )error {if _gff ._ed > len (_gff ._eff )-1||(_gff ._ed ==len (_gff ._eff )-1&&_gff ._fc !=0){_gff .expandIfNeeded (1);};_gff .writeByte (bt );return nil ;};func (_fcb *SubstreamReader )Length ()uint64 {return _fcb ._ecbc };func (_a *BufferedWriter )ResetBitIndex (){_a ._fc =0};var (_ _ea .Reader =&Reader {};_ _ea .ByteReader =&Reader {};_ _ea .Seeker =&Reader {};_ StreamReader =&Reader {};);func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_dcb :true }};func (_fff *SubstreamReader )ReadBool ()(bool ,error ){return _fff .readBool ()};func (_eeg *BufferedWriter )grow (_ge int ){if _eeg ._eff ==nil &&_ge < _b {_eeg ._eff =make ([]byte ,_ge ,_b );return ;};_dcea :=len (_eeg ._eff );if _eeg ._fc !=0{_dcea ++;};_fcc :=cap (_eeg ._eff );switch {case _ge <=_fcc /2-_dcea :_cg .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_eeg ._eff ),cap (_eeg ._eff ),_ge );_cg .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_fcc ,_dcea );copy (_eeg ._eff ,_eeg ._eff [_eeg .fullOffset ():]);case _fcc > _f -_fcc -_ge :_cg .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_beb :=make ([]byte ,2*_fcc +_ge );copy (_beb ,_eeg ._eff );_eeg ._eff =_beb ;};_eeg ._eff =_eeg ._eff [:_dcea +_ge ];};func (_da *SubstreamReader )Read (b []byte )(_cfe int ,_gfef error ){if _da ._cec >=_da ._ecbc {_cg .Log .Trace ("\u0053\u0074\u0072e\u0061\u006d\u0050\u006fs\u003a\u0020\u0027\u0025\u0064\u0027\u0020>\u003d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027",_da ._cec ,_da ._ecbc );return 0,_ea .EOF ;};for ;_cfe < len (b );_cfe ++{if b [_cfe ],_gfef =_da .readUnalignedByte ();_gfef !=nil {if _gfef ==_ea .EOF {return _cfe ,nil ;};return 0,_gfef ;};};return _cfe ,nil ;};func (_gdc *SubstreamReader )Offset ()uint64 {return _gdc ._bda };func (_edf *BufferedWriter )expandIfNeeded (_bg int ){if !_edf .tryGrowByReslice (_bg ){_edf .grow (_bg );};};type StreamReader interface{_ea .Reader ;_ea .ByteReader ;_ea .Seeker ;Align ()byte ;BitPosition ()int ;Mark ();Length ()uint64 ;ReadBit ()(int ,error );ReadBits (_ege byte )(uint64 ,error );ReadBool ()(bool ,error );ReadUint32 ()(uint32 ,error );Reset ();StreamPosition ()int64 ;};func (_cbc *Reader )ConsumeRemainingBits (){if _cbc ._add !=0{_ ,_gace :=_cbc .ReadBits (_cbc ._add );if _gace !=nil {_cg .Log .Debug ("\u0043\u006f\u006e\u0073\u0075\u006d\u0065\u0052\u0065\u006da\u0069\u006e\u0069\u0067\u0042\u0069\u0074s\u0020\u0066\u0061\u0069\u006c\u0065\u0064\u003a\u0020\u0025\u0076",_gace );};};};func (_bcg *Reader )readUnalignedByte ()(_deg byte ,_ccb error ){_addf :=_bcg ._add ;_deg =_bcg ._bef <<(8-_addf );_bcg ._bef ,_ccb =_bcg .readBufferByte ();if _ccb !=nil {return 0,_ccb ;};_deg |=_bcg ._bef >>_addf ;_bcg ._bef &=1<<_addf -1;return _deg ,nil ;};type SubstreamReader struct{_cec uint64 ;_aec StreamReader ;_bda uint64 ;_ecbc uint64 ;_gee []byte ;_eged uint64 ;_adbb uint64 ;_cce byte ;_cca byte ;_eag uint64 ;_baa byte ;};func (_gbe *Reader )ReadUint32 ()(uint32 ,error ){_gacc :=make ([]byte ,4);_ ,_efdd :=_gbe .Read (_gacc );if _efdd !=nil {return 0,_efdd ;};return _c .BigEndian .Uint32 (_gacc ),nil ;};func (_fbb *SubstreamReader )ReadUint32 ()(uint32 ,error ){_eae :=make ([]byte ,4);_ ,_fbd :=_fbb .Read (_eae );if _fbd !=nil {return 0,_fbd ;};return _c .BigEndian .Uint32 (_eae ),nil ;};func (_fgc *Reader )BitPosition ()int {return int (_fgc ._add )};func (_ebe *BufferedWriter )writeByte (_cgd byte ){switch {case _ebe ._fc ==0:_ebe ._eff [_ebe ._ed ]=_cgd ;_ebe ._ed ++;case _ebe ._dcb :_ebe ._eff [_ebe ._ed ]|=_cgd >>_ebe ._fc ;_ebe ._ed ++;_ebe ._eff [_ebe ._ed ]=byte (uint16 (_cgd )<<(8-_ebe ._fc )&0xff);default:_ebe ._eff [_ebe ._ed ]|=byte (uint16 (_cgd )<<_ebe ._fc &0xff);_ebe ._ed ++;_ebe ._eff [_ebe ._ed ]=_cgd >>(8-_ebe ._fc );};};var _ _ea .ByteWriter =&BufferedWriter {};func (_abc *Reader )read (_fdf []byte )(int ,error ){if _abc ._ba >=int64 (len (_abc ._ecg )){return 0,_ea .EOF ;};_abc ._adb =-1;_bca :=copy (_fdf ,_abc ._ecg [_abc ._ba :]);_abc ._ba +=int64 (_bca );return _bca ,nil ;};func (_cee *Reader )readBufferByte ()(byte ,error ){if _cee ._ba >=int64 (len (_cee ._ecg )){return 0,_ea .EOF ;};_cee ._adb =-1;_ade :=_cee ._ecg [_cee ._ba ];_cee ._ba ++;_cee ._ac =int (_ade );return _ade ,nil ;};func (_ggf *SubstreamReader )StreamPosition ()int64 {return int64 (_ggf ._cec )};func (_ff *Reader )readBool ()(_ged bool ,_acd error ){if _ff ._add ==0{_ff ._bef ,_acd =_ff .readBufferByte ();if _acd !=nil {return false ,_acd ;};_ged =(_ff ._bef &0x80)!=0;_ff ._bef ,_ff ._add =_ff ._bef &0x7f,7;return _ged ,nil ;};_ff ._add --;_ged =(_ff ._bef &(1<<_ff ._add ))!=0;_ff ._bef &=1<<_ff ._add -1;return _ged ,nil ;};func (_dcbc *SubstreamReader )readBool ()(_daf bool ,_ecfb error ){if _dcbc ._cca ==0{_dcbc ._cce ,_ecfb =_dcbc .readBufferByte ();if _ecfb !=nil {return false ,_ecfb ;};_daf =(_dcbc ._cce &0x80)!=0;_dcbc ._cce ,_dcbc ._cca =_dcbc ._cce &0x7f,7;return _daf ,nil ;};_dcbc ._cca --;_daf =(_dcbc ._cce &(1<<_dcbc ._cca ))!=0;_dcbc ._cce &=1<<_dcbc ._cca -1;return _daf ,nil ;};func (_ee *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _dc .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );};if len (_ee ._eff )-1< _ee ._ed {_ee .expandIfNeeded (1);};_dd :=_ee ._fc ;if _ee ._dcb {_dd =7-_ee ._fc ;};_ee ._eff [_ee ._ed ]|=byte (uint16 (bit <<_dd )&0xff);_ee ._fc ++;if _ee ._fc ==8{_ee ._ed ++;_ee ._fc =0;};return nil ;};func (_dcg *BufferedWriter )WriteBits (bits uint64 ,number int )(_bbf int ,_be error ){const _de ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";if number < 0||number > 64{return 0,_dc .Errorf (_de ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );};_dg :=number /8;if _dg > 0{_eg :=number -_dg *8;for _eb :=_dg -1;_eb >=0;_eb --{_gb :=byte ((bits >>uint (_eb *8+_eg ))&0xff);if _be =_dcg .WriteByte (_gb );_be !=nil {return _bbf ,_dc .Wrapf (_be ,_de ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_dg -_eb +1);};};number -=_dg *8;if number ==0{return _dg ,nil ;};};var _fb int ;for _ccc :=0;_ccc < number ;_ccc ++{if _dcg ._dcb {_fb =int ((bits >>uint (number -1-_ccc ))&0x1);}else {_fb =int (bits &0x1);bits >>=1;};if _be =_dcg .WriteBit (_fb );_be !=nil {return _bbf ,_dc .Wrapf (_be ,_de ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_ccc );};};return _dg ,nil ;};type Reader struct{_ecg []byte ;_bef byte ;_add byte ;_ba int64 ;_ac int ;_adb int ;_bge int64 ;_db byte ;};func (_bff *SubstreamReader )Seek (offset int64 ,whence int )(int64 ,error ){switch whence {case _ea .SeekStart :_bff ._cec =uint64 (offset );case _ea .SeekCurrent :_bff ._cec +=uint64 (offset );case _ea .SeekEnd :_bff ._cec =_bff ._ecbc +uint64 (offset );default:return 0,_d .New ("\u0072\u0065\u0061d\u0065\u0072\u002e\u0053\u0075\u0062\u0073\u0074\u0072\u0065\u0061\u006d\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u0020\u0069\u006e\u0076\u0061\u006ci\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");};_bff ._cca =0;return int64 (_bff ._cec ),nil ;};func (_ccfg *Writer )WriteByte (c byte )error {return _ccfg .writeByte (c )};func (_cbb *Reader )Read (p []byte )(_ccf int ,_efe error ){if _cbb ._add ==0{return _cbb .read (p );};for ;_ccf < len (p );_ccf ++{if p [_ccf ],_efe =_cbb .readUnalignedByte ();_efe !=nil {return 0,_efe ;};};return _ccf ,nil ;};func NewWriterMSB (data []byte )*Writer {return &Writer {_ddc :data ,_ccfd :true }};var _ BinaryWriter =&Writer {};func (_df *SubstreamReader )fillBuffer ()error {if uint64 (_df ._aec .StreamPosition ())!=_df ._cec +_df ._bda {_ ,_cac :=_df ._aec .Seek (int64 (_df ._cec +_df ._bda ),_ea .SeekStart );if _cac !=nil {return _cac ;};};_df ._eged =uint64 (_df ._cec );_fef :=_feb (uint64 (len (_df ._gee )),_df ._ecbc -_df ._cec );_dcbf :=make ([]byte ,_fef );_bee ,_eca :=_df ._aec .Read (_dcbf );if _eca !=nil {return _eca ;};for _fbdb :=uint64 (0);_fbdb < _fef ;_fbdb ++{_df ._gee [_fbdb ]=_dcbf [_fbdb ];};_df ._adbb =_df ._eged +uint64 (_bee );return nil ;};func (_bb *BufferedWriter )Write (d []byte )(int ,error ){_bb .expandIfNeeded (len (d ));if _bb ._fc ==0{return _bb .writeFullBytes (d ),nil ;};return _bb .writeShiftedBytes (d ),nil ;};var _ _ea .Writer =&BufferedWriter {};func (_fcba *Writer )writeBit (_cfdb uint8 )error {if len (_fcba ._ddc )-1< _fcba ._cdb {return _ea .EOF ;};_dba :=_fcba ._egc ;if _fcba ._ccfd {_dba =7-_fcba ._egc ;};_fcba ._ddc [_fcba ._cdb ]|=byte (uint16 (_cfdb <<_dba )&0xff);_fcba ._egc ++;if _fcba ._egc ==8{_fcba ._cdb ++;_fcba ._egc =0;};return nil ;};func (_cfd *BufferedWriter )tryGrowByReslice (_cb int )bool {if _gd :=len (_cfd ._eff );_cb <=cap (_cfd ._eff )-_gd {_cfd ._eff =_cfd ._eff [:_gd +_cb ];return true ;};return false ;};type Writer struct{_ddc []byte ;_egc uint8 ;_cdb int ;_ccfd bool ;};func (_fdg *Writer )Write (p []byte )(int ,error ){if len (p )> _fdg .byteCapacity (){return 0,_ea .EOF ;};for _ ,_ebg :=range p {if _fgcd :=_fdg .writeByte (_ebg );_fgcd !=nil {return 0,_fgcd ;};};return len (p ),nil ;};func (_ae *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;};_ecf :=int (_ae ._fc )+skip ;if _ecf >=0&&_ecf < 8{_ae ._fc =uint8 (_ecf );return nil ;};_ecf =int (_ae ._fc )+_ae ._ed *8+skip ;if _ecf < 0{return _dc .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_cd :=_ecf /8;_gf :=_ecf %8;_ae ._fc =uint8 (_gf );if _ga :=_cd -_ae ._ed ;_ga > 0&&len (_ae ._eff )-1< _cd {if _ae ._fc !=0{_ga ++;};_ae .expandIfNeeded (_ga );};_ae ._ed =_cd ;return nil ;};func (_ab *Reader )Length ()uint64 {return uint64 (len (_ab ._ecg ))};func (_eggg *Reader )StreamPosition ()int64 {return _eggg ._ba };func (_edbc *SubstreamReader )readUnalignedByte ()(_aga byte ,_bdd error ){_agd :=_edbc ._cca ;_aga =_edbc ._cce <<(8-_agd );_edbc ._cce ,_bdd =_edbc .readBufferByte ();if _bdd !=nil {return 0,_bdd ;};_aga |=_edbc ._cce >>_agd ;_edbc ._cce &=1<<_agd -1;return _aga ,nil ;};func (_cfgg *SubstreamReader )ReadBit ()(_gge int ,_dae error ){_afd ,_dae :=_cfgg .readBool ();if _dae !=nil {return 0,_dae ;};if _afd {_gge =1;};return _gge ,nil ;};func (_ffb *Writer )WriteBits (bits uint64 ,number int )(_cad int ,_ebf error ){const _bddd ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";if number < 0||number > 64{return 0,_dc .Errorf (_bddd ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );};if number ==0{return 0,nil ;};_gea :=number /8;if _gea > 0{_ecbe :=number -_gea *8;for _dcd :=_gea -1;_dcd >=0;_dcd --{_gfb :=byte ((bits >>uint (_dcd *8+_ecbe ))&0xff);if _ebf =_ffb .WriteByte (_gfb );_ebf !=nil {return _cad ,_dc .Wrapf (_ebf ,_bddd ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_gea -_dcd +1);};};number -=_gea *8;if number ==0{return _gea ,nil ;};};var _agg int ;for _aee :=0;_aee < number ;_aee ++{if _ffb ._ccfd {_agg =int ((bits >>uint (number -1-_aee ))&0x1);}else {_agg =int (bits &0x1);bits >>=1;};if _ebf =_ffb .WriteBit (_agg );_ebf !=nil {return _cad ,_dc .Wrapf (_ebf ,_bddd ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_aee );};};return _gea ,nil ;};const (_b =64;_f =int (^uint (0)>>1););func (_gbb *Writer )Data ()[]byte {return _gbb ._ddc };type BufferedWriter struct{_eff []byte ;_fc uint8 ;_ed int ;_dcb bool ;};func (_fgd *Writer )FinishByte (){if _fgd ._egc ==0{return ;};_fgd ._egc =0;_fgd ._cdb ++;};func NewSubstreamReader (r StreamReader ,offset ,length uint64 )(*SubstreamReader ,error ){if r ==nil {return nil ,_d .New ("\u0072o\u006ft\u0020\u0072\u0065\u0061\u0064e\u0072\u0020i\u0073\u0020\u006e\u0069\u006c");};_cg .Log .Trace ("\u004e\u0065\u0077\u0053\u0075\u0062\u0073\u0074r\u0065\u0061\u006dRe\u0061\u0064\u0065\u0072\u0020\u0061t\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u003a\u0020\u0025\u0064\u0020\u0077\u0069\u0074h\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a \u0025\u0064",offset ,length );return &SubstreamReader {_aec :r ,_bda :offset ,_ecbc :length ,_gee :make ([]byte ,length )},nil ;};func (_gdda *Writer )SkipBits (skip int )error {const _aacb ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";if skip ==0{return nil ;};_efdec :=int (_gdda ._egc )+skip ;if _efdec >=0&&_efdec < 8{_gdda ._egc =uint8 (_efdec );return nil ;};_efdec =int (_gdda ._egc )+_gdda ._cdb *8+skip ;if _efdec < 0{return _dc .Errorf (_aacb ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_cffe :=_efdec /8;_ggc :=_efdec %8;_cg .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");_cg .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_gdda ._egc ,_gdda ._cdb ,int (_gdda ._egc )+(_gdda ._cdb )*8,len (_gdda ._ddc ),cap (_gdda ._ddc ));_cg .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_efdec ,_ggc );_gdda ._egc =uint8 (_ggc );if _ggg :=_cffe -_gdda ._cdb ;_ggg > 0&&len (_gdda ._ddc )-1< _cffe {_cg .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_ggg );return _dc .Errorf (_aacb ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_gdda ._cdb =_cffe ;_cg .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_gdda ._egc ,_gdda ._cdb );return nil ;};func (_dcgb *SubstreamReader )ReadBits (n byte )(_aeb uint64 ,_dcgd error ){if n < _dcgb ._cca {_edc :=_dcgb ._cca -n ;_aeb =uint64 (_dcgb ._cce >>_edc );_dcgb ._cce &=1<<_edc -1;_dcgb ._cca =_edc ;return _aeb ,nil ;};if n > _dcgb ._cca {if _dcgb ._cca > 0{_aeb =uint64 (_dcgb ._cce );n -=_dcgb ._cca ;};var _edd byte ;for n >=8{_edd ,_dcgd =_dcgb .readBufferByte ();if _dcgd !=nil {return 0,_dcgd ;};_aeb =_aeb <<8+uint64 (_edd );n -=8;};if n > 0{if _dcgb ._cce ,_dcgd =_dcgb .readBufferByte ();_dcgd !=nil {return 0,_dcgd ;};_ag :=8-n ;_aeb =_aeb <<n +uint64 (_dcgb ._cce >>_ag );_dcgb ._cce &=1<<_ag -1;_dcgb ._cca =_ag ;}else {_dcgb ._cca =0;};return _aeb ,nil ;};_dcgb ._cca =0;return uint64 (_dcgb ._cce ),nil ;};func (_egaf *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _egaf .writeBit (uint8 (bit ));};return _dc .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");};var _ BinaryWriter =&BufferedWriter {};func (_ca *BufferedWriter )Len ()int {return _ca .byteCapacity ()};func (_cfg *Reader )Align ()(_gad byte ){_gad =_cfg ._add ;_cfg ._add =0;return _gad };func (_gbec *Writer )UseMSB ()bool {return _gbec ._ccfd };func (_ada *Writer )byteCapacity ()int {_dgaf :=len (_ada ._ddc )-_ada ._cdb ;if _ada ._egc !=0{_dgaf --;};return _dgaf ;};func (_gg *SubstreamReader )BitPosition ()int {return int (_gg ._cca )};func (_cfef *SubstreamReader )readBufferByte ()(byte ,error ){if _cfef ._cec >=_cfef ._ecbc {return 0,_ea .EOF ;};if _cfef ._cec >=_cfef ._adbb ||_cfef ._cec < _cfef ._eged {if _caf :=_cfef .fillBuffer ();_caf !=nil {return 0,_caf ;};};_fca :=_cfef ._gee [_cfef ._cec -_cfef ._eged ];_cfef ._cec ++;return _fca ,nil ;};func (_dga *SubstreamReader )Reset (){_dga ._cec =_dga ._eag ;_dga ._cca =_dga ._baa };func _feb (_cafd ,_ecac uint64 )uint64 {if _cafd < _ecac {return _cafd ;};return _ecac ;};func (_cfb *Reader )ReadBits (n byte )(_cff uint64 ,_aff error ){if n < _cfb ._add {_cge :=_cfb ._add -n ;_cff =uint64 (_cfb ._bef >>_cge );_cfb ._bef &=1<<_cge -1;_cfb ._add =_cge ;return _cff ,nil ;};if n > _cfb ._add {if _cfb ._add > 0{_cff =uint64 (_cfb ._bef );n -=_cfb ._add ;};for n >=8{_edbf ,_egg :=_cfb .readBufferByte ();if _egg !=nil {return 0,_egg ;};_cff =_cff <<8+uint64 (_edbf );n -=8;};if n > 0{if _cfb ._bef ,_aff =_cfb .readBufferByte ();_aff !=nil {return 0,_aff ;};_bd :=8-n ;_cff =_cff <<n +uint64 (_cfb ._bef >>_bd );_cfb ._bef &=1<<_bd -1;_cfb ._add =_bd ;}else {_cfb ._add =0;};return _cff ,nil ;};_cfb ._add =0;return uint64 (_cfb ._bef ),nil ;};func (_cf *BufferedWriter )writeFullBytes (_cfc []byte )int {_fg :=copy (_cf ._eff [_cf .fullOffset ():],_cfc );_cf ._ed +=_fg ;return _fg ;};type BitWriter interface{WriteBit (_bfd int )error ;WriteBits (_efd uint64 ,_ddf int )(_aef int ,_af error );FinishByte ();SkipBits (_eea int )error ;};func NewWriter (data []byte )*Writer {return &Writer {_ddc :data }};func (_fa *Reader )Reset (){_fa ._ba =_fa ._bge ;_fa ._add =_fa ._db };func (_aac *Reader )Mark (){_aac ._bge =_aac ._ba ;_aac ._db =_aac ._add };func (_ce *Reader )ReadBit ()(_gfe int ,_fdb error ){_gc ,_fdb :=_ce .readBool ();if _fdb !=nil {return 0,_fdb ;};if _gc {_gfe =1;};return _gfe ,nil ;};func (_ecfg *BufferedWriter )fullOffset ()int {_bf :=_ecfg ._ed ;if _ecfg ._fc !=0{_bf ++;};return _bf ;};type BinaryWriter interface{BitWriter ;_ea .Writer ;_ea .ByteWriter ;Data ()[]byte ;};func (_g *BufferedWriter )Reset (){_g ._eff =_g ._eff [:0];_g ._ed =0;_g ._fc =0};func NewReader (data []byte )*Reader {return &Reader {_ecg :data }};func (_ec *BufferedWriter )Data ()[]byte {return _ec ._eff };func (_fbf *Writer )ResetBit (){_fbf ._egc =0};func (_aad *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_aad ._adb =-1;var _ecb int64 ;switch whence {case _ea .SeekStart :_ecb =offset ;case _ea .SeekCurrent :_ecb =_aad ._ba +offset ;case _ea .SeekEnd :_ecb =int64 (len (_aad ._ecg ))+offset ;default:return 0,_d .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");};if _ecb < 0{return 0,_d .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");};_aad ._ba =_ecb ;_aad ._add =0;return _ecb ,nil ;};func (_gcb *SubstreamReader )ReadByte ()(byte ,error ){if _gcb ._cca ==0{return _gcb .readBufferByte ();};return _gcb .readUnalignedByte ();};func (_deb *SubstreamReader )Mark (){_deb ._eag =_deb ._cec ;_deb ._baa =_deb ._cca };func (_ceg *Writer )writeByte (_gfg byte )error {if _ceg ._cdb > len (_ceg ._ddc )-1{return _ea .EOF ;};if _ceg ._cdb ==len (_ceg ._ddc )-1&&_ceg ._egc !=0{return _ea .EOF ;};if _ceg ._egc ==0{_ceg ._ddc [_ceg ._cdb ]=_gfg ;_ceg ._cdb ++;return nil ;};if _ceg ._ccfd {_ceg ._ddc [_ceg ._cdb ]|=_gfg >>_ceg ._egc ;_ceg ._cdb ++;_ceg ._ddc [_ceg ._cdb ]=byte (uint16 (_gfg )<<(8-_ceg ._egc )&0xff);}else {_ceg ._ddc [_ceg ._cdb ]|=byte (uint16 (_gfg )<<_ceg ._egc &0xff);_ceg ._cdb ++;_ceg ._ddc [_ceg ._cdb ]=_gfg >>(8-_ceg ._egc );};return nil ;};