//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_ad "encoding/binary";_a "errors";_adc "github.com/unidoc/unipdf/v3/common";_g "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_f "io";);var _ _f .Writer =&BufferedWriter {};func (_agd *Writer )SkipBits (skip int )error {const _gfff ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";if skip ==0{return nil ;};_cacc :=int (_agd ._eeb )+skip ;if _cacc >=0&&_cacc < 8{_agd ._eeb =uint8 (_cacc );return nil ;};_cacc =int (_agd ._eeb )+_agd ._dgc *8+skip ;if _cacc < 0{return _g .Errorf (_gfff ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_cfcf :=_cacc /8;_agb :=_cacc %8;_adc .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");_adc .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_agd ._eeb ,_agd ._dgc ,int (_agd ._eeb )+(_agd ._dgc )*8,len (_agd ._deb ),cap (_agd ._deb ));_adc .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_cacc ,_agb );_agd ._eeb =uint8 (_agb );if _abf :=_cfcf -_agd ._dgc ;_abf > 0&&len (_agd ._deb )-1< _cfcf {_adc .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_abf );return _g .Errorf (_gfff ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_agd ._dgc =_cfcf ;_adc .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_agd ._eeb ,_agd ._dgc );return nil ;};type BitWriter interface{WriteBit (_ecg int )error ;WriteBits (_dcg uint64 ,_efd int )(_cff int ,_geb error );FinishByte ();SkipBits (_be int )error ;};func (_aab *SubstreamReader )ReadBool ()(bool ,error ){return _aab .readBool ()};var _ BinaryWriter =&BufferedWriter {};type Writer struct{_deb []byte ;_eeb uint8 ;_dgc int ;_ebc bool ;};func (_dc *BufferedWriter )ResetBitIndex (){_dc ._b =0};func (_ee *BufferedWriter )expandIfNeeded (_dg int ){if !_ee .tryGrowByReslice (_dg ){_ee .grow (_dg );};};func (_ff *Reader )readBool ()(_geba bool ,_baf error ){if _ff ._cgd ==0{_ff ._fa ,_baf =_ff .readBufferByte ();if _baf !=nil {return false ,_baf ;};_geba =(_ff ._fa &0x80)!=0;_ff ._fa ,_ff ._cgd =_ff ._fa &0x7f,7;return _geba ,nil ;};_ff ._cgd --;_geba =(_ff ._fa &(1<<_ff ._cgd ))!=0;_ff ._fa &=1<<_ff ._cgd -1;return _geba ,nil ;};func NewWriterMSB (data []byte )*Writer {return &Writer {_deb :data ,_ebc :true }};func (_fgfc *Writer )writeByte (_geg byte )error {if _fgfc ._dgc > len (_fgfc ._deb )-1{return _f .EOF ;};if _fgfc ._dgc ==len (_fgfc ._deb )-1&&_fgfc ._eeb !=0{return _f .EOF ;};if _fgfc ._eeb ==0{_fgfc ._deb [_fgfc ._dgc ]=_geg ;_fgfc ._dgc ++;return nil ;};if _fgfc ._ebc {_fgfc ._deb [_fgfc ._dgc ]|=_geg >>_fgfc ._eeb ;_fgfc ._dgc ++;_fgfc ._deb [_fgfc ._dgc ]=byte (uint16 (_geg )<<(8-_fgfc ._eeb )&0xff);}else {_fgfc ._deb [_fgfc ._dgc ]|=byte (uint16 (_geg )<<_fgfc ._eeb &0xff);_fgfc ._dgc ++;_fgfc ._deb [_fgfc ._dgc ]=_geg >>(8-_fgfc ._eeb );};return nil ;};func (_ceb *Writer )ResetBit (){_ceb ._eeb =0};func (_dgb *BufferedWriter )fullOffset ()int {_cc :=_dgb ._c ;if _dgb ._b !=0{_cc ++;};return _cc ;};type BufferedWriter struct{_ag []byte ;_b uint8 ;_c int ;_ca bool ;};func (_cbd *Reader )read (_cad []byte )(int ,error ){if _cbd ._cb >=int64 (len (_cbd ._fbg )){return 0,_f .EOF ;};_cbd ._bbf =-1;_dff :=copy (_cad ,_cbd ._fbg [_cbd ._cb :]);_cbd ._cb +=int64 (_dff );return _dff ,nil ;};func (_acd *SubstreamReader )Offset ()uint64 {return _acd ._gbfb };func (_gf *BufferedWriter )WriteBits (bits uint64 ,number int )(_feb int ,_ab error ){const _edb ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";if number < 0||number > 64{return 0,_g .Errorf (_edb ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );};_gg :=number /8;if _gg > 0{_ec :=number -_gg *8;for _df :=_gg -1;_df >=0;_df --{_dfd :=byte ((bits >>uint (_df *8+_ec ))&0xff);if _ab =_gf .WriteByte (_dfd );_ab !=nil {return _feb ,_g .Wrapf (_ab ,_edb ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_gg -_df +1);};};number -=_gg *8;if number ==0{return _gg ,nil ;};};var _age int ;for _ce :=0;_ce < number ;_ce ++{if _gf ._ca {_age =int ((bits >>uint (number -1-_ce ))&0x1);}else {_age =int (bits &0x1);bits >>=1;};if _ab =_gf .WriteBit (_age );_ab !=nil {return _feb ,_g .Wrapf (_ab ,_edb ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_ce );};};return _gg ,nil ;};func (_fbf *SubstreamReader )ReadByte ()(byte ,error ){if _fbf ._dac ==0{return _fbf .readBufferByte ();};return _fbf .readUnalignedByte ();};func (_gfb *Reader )ReadUint32 ()(uint32 ,error ){_eeg :=make ([]byte ,4);_ ,_febd :=_gfb .Read (_eeg );if _febd !=nil {return 0,_febd ;};return _ad .BigEndian .Uint32 (_eeg ),nil ;};func (_ed *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;};_fe :=int (_ed ._b )+skip ;if _fe >=0&&_fe < 8{_ed ._b =uint8 (_fe );return nil ;};_fe =int (_ed ._b )+_ed ._c *8+skip ;if _fe < 0{return _g .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_bb :=_fe /8;_de :=_fe %8;_ed ._b =uint8 (_de );if _dd :=_bb -_ed ._c ;_dd > 0&&len (_ed ._ag )-1< _bb {if _ed ._b !=0{_dd ++;};_ed .expandIfNeeded (_dd );};_ed ._c =_bb ;return nil ;};var _ _f .ByteWriter =&BufferedWriter {};func (_ecd *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_ecd ._bbf =-1;var _gc int64 ;switch whence {case _f .SeekStart :_gc =offset ;case _f .SeekCurrent :_gc =_ecd ._cb +offset ;case _f .SeekEnd :_gc =int64 (len (_ecd ._fbg ))+offset ;default:return 0,_a .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");};if _gc < 0{return 0,_a .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");};_ecd ._cb =_gc ;_ecd ._cgd =0;return _gc ,nil ;};func (_cf *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _g .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );};if len (_cf ._ag )-1< _cf ._c {_cf .expandIfNeeded (1);};_fd :=_cf ._b ;if _cf ._ca {_fd =7-_cf ._b ;};_cf ._ag [_cf ._c ]|=byte (uint16 (bit <<_fd )&0xff);_cf ._b ++;if _cf ._b ==8{_cf ._c ++;_cf ._b =0;};return nil ;};func (_bce *SubstreamReader )Read (b []byte )(_edg int ,_ada error ){if _bce ._gda >=_bce ._bafg {_adc .Log .Trace ("\u0053\u0074\u0072e\u0061\u006d\u0050\u006fs\u003a\u0020\u0027\u0025\u0064\u0027\u0020>\u003d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027",_bce ._gda ,_bce ._bafg );return 0,_f .EOF ;};for ;_edg < len (b );_edg ++{if b [_edg ],_ada =_bce .readUnalignedByte ();_ada !=nil {if _ada ==_f .EOF {return _edg ,nil ;};return 0,_ada ;};};return _edg ,nil ;};func (_fae *Writer )UseMSB ()bool {return _fae ._ebc };func (_agee *Reader )Reset (){_agee ._cb =_agee ._fbgc ;_agee ._cgd =_agee ._bda };func (_gef *BufferedWriter )writeByte (_ceg byte ){switch {case _gef ._b ==0:_gef ._ag [_gef ._c ]=_ceg ;_gef ._c ++;case _gef ._ca :_gef ._ag [_gef ._c ]|=_ceg >>_gef ._b ;_gef ._c ++;_gef ._ag [_gef ._c ]=byte (uint16 (_ceg )<<(8-_gef ._b )&0xff);default:_gef ._ag [_gef ._c ]|=byte (uint16 (_ceg )<<_gef ._b &0xff);_gef ._c ++;_gef ._ag [_gef ._c ]=_ceg >>(8-_gef ._b );};};func (_dda *SubstreamReader )ReadBit ()(_bae int ,_ced error ){_dcf ,_ced :=_dda .readBool ();if _ced !=nil {return 0,_ced ;};if _dcf {_bae =1;};return _bae ,nil ;};func (_gbf *Reader )Read (p []byte )(_aca int ,_ea error ){if _gbf ._cgd ==0{return _gbf .read (p );};for ;_aca < len (p );_aca ++{if p [_aca ],_ea =_gbf .readUnalignedByte ();_ea !=nil {return 0,_ea ;};};return _aca ,nil ;};func (_gaa *Reader )ReadByte ()(byte ,error ){if _gaa ._cgd ==0{return _gaa .readBufferByte ();};return _gaa .readUnalignedByte ();};func (_aac *SubstreamReader )ReadUint32 ()(uint32 ,error ){_gebaf :=make ([]byte ,4);_ ,_cfdf :=_aac .Read (_gebaf );if _cfdf !=nil {return 0,_cfdf ;};return _ad .BigEndian .Uint32 (_gebaf ),nil ;};func (_ffbb *SubstreamReader )Align ()(_gffb byte ){_gffb =_ffbb ._dac ;_ffbb ._dac =0;return _gffb };func (_dgf *Writer )writeBit (_dcd uint8 )error {if len (_dgf ._deb )-1< _dgf ._dgc {return _f .EOF ;};_abgd :=_dgf ._eeb ;if _dgf ._ebc {_abgd =7-_dgf ._eeb ;};_dgf ._deb [_dgf ._dgc ]|=byte (uint16 (_dcd <<_abgd )&0xff);_dgf ._eeb ++;if _dgf ._eeb ==8{_dgf ._dgc ++;_dgf ._eeb =0;};return nil ;};func (_fbc *BufferedWriter )byteCapacity ()int {_ef :=len (_fbc ._ag )-_fbc ._c ;if _fbc ._b !=0{_ef --;};return _ef ;};func (_eb *BufferedWriter )FinishByte (){if _eb ._b ==0{return ;};_eb ._b =0;_eb ._c ++;};func (_cd *BufferedWriter )WriteByte (bt byte )error {if _cd ._c > len (_cd ._ag )-1||(_cd ._c ==len (_cd ._ag )-1&&_cd ._b !=0){_cd .expandIfNeeded (1);};_cd .writeByte (bt );return nil ;};func (_ddg *Reader )readUnalignedByte ()(_eec byte ,_daa error ){_ba :=_ddg ._cgd ;_eec =_ddg ._fa <<(8-_ba );_ddg ._fa ,_daa =_ddg .readBufferByte ();if _daa !=nil {return 0,_daa ;};_eec |=_ddg ._fa >>_ba ;_ddg ._fa &=1<<_ba -1;return _eec ,nil ;};func (_cbb *SubstreamReader )readBool ()(_fce bool ,_edca error ){if _cbb ._dac ==0{_cbb ._gfbg ,_edca =_cbb .readBufferByte ();if _edca !=nil {return false ,_edca ;};_fce =(_cbb ._gfbg &0x80)!=0;_cbb ._gfbg ,_cbb ._dac =_cbb ._gfbg &0x7f,7;return _fce ,nil ;};_cbb ._dac --;_fce =(_cbb ._gfbg &(1<<_cbb ._dac ))!=0;_cbb ._gfbg &=1<<_cbb ._dac -1;return _fce ,nil ;};func (_cfd *Reader )StreamPosition ()int64 {return _cfd ._cb };func (_da *BufferedWriter )writeFullBytes (_gff []byte )int {_fc :=copy (_da ._ag [_da .fullOffset ():],_gff );_da ._c +=_fc ;return _fc ;};func _dag (_fba ,_bff uint64 )uint64 {if _fba < _bff {return _fba ;};return _bff ;};func (_adcg *BufferedWriter )Reset (){_adcg ._ag =_adcg ._ag [:0];_adcg ._c =0;_adcg ._b =0};func (_ge *BufferedWriter )Data ()[]byte {return _ge ._ag };func (_bfa *SubstreamReader )Seek (offset int64 ,whence int )(int64 ,error ){switch whence {case _f .SeekStart :_bfa ._gda =uint64 (offset );case _f .SeekCurrent :_bfa ._gda +=uint64 (offset );case _f .SeekEnd :_bfa ._gda =_bfa ._bafg +uint64 (offset );default:return 0,_a .New ("\u0072\u0065\u0061d\u0065\u0072\u002e\u0053\u0075\u0062\u0073\u0074\u0072\u0065\u0061\u006d\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u0020\u0069\u006e\u0076\u0061\u006ci\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");};_bfa ._dac =0;return int64 (_bfa ._gda ),nil ;};func (_efda *Reader )BitPosition ()int {return int (_efda ._cgd )};const (_aa =64;_fb =int (^uint (0)>>1););var _ BinaryWriter =&Writer {};func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_ca :true }};func (_bdf *BufferedWriter )writeShiftedBytes (_ade []byte )int {for _ ,_fdg :=range _ade {_bdf .writeByte (_fdg );};return len (_ade );};func NewWriter (data []byte )*Writer {return &Writer {_deb :data }};func (_bee *SubstreamReader )BitPosition ()int {return int (_bee ._dac )};func (_gec *Reader )Align ()(_adg byte ){_adg =_gec ._cgd ;_gec ._cgd =0;return _adg };func (_gffe *SubstreamReader )StreamPosition ()int64 {return int64 (_gffe ._gda )};func (_cgee *SubstreamReader )Mark (){_cgee ._ebd =_cgee ._gda ;_cgee ._aaa =_cgee ._dac };func (_bdb *BufferedWriter )tryGrowByReslice (_acg int )bool {if _bdd :=len (_bdb ._ag );_acg <=cap (_bdb ._ag )-_bdd {_bdb ._ag =_bdb ._ag [:_bdd +_acg ];return true ;};return false ;};func (_fcbe *SubstreamReader )readBufferByte ()(byte ,error ){if _fcbe ._gda >=_fcbe ._bafg {return 0,_f .EOF ;};if _fcbe ._gda >=_fcbe ._ffb ||_fcbe ._gda < _fcbe ._fbgf {if _acac :=_fcbe .fillBuffer ();_acac !=nil {return 0,_acac ;};};_ede :=_fcbe ._ace [_fcbe ._gda -_fcbe ._fbgf ];_fcbe ._gda ++;return _ede ,nil ;};func (_gee *SubstreamReader )fillBuffer ()error {if uint64 (_gee ._bcc .StreamPosition ())!=_gee ._gda +_gee ._gbfb {_ ,_fcb :=_gee ._bcc .Seek (int64 (_gee ._gda +_gee ._gbfb ),_f .SeekStart );if _fcb !=nil {return _fcb ;};};_gee ._fbgf =uint64 (_gee ._gda );_ffba :=_dag (uint64 (len (_gee ._ace )),_gee ._bafg -_gee ._gda );_fgcc :=make ([]byte ,_ffba );_fdf ,_bec :=_gee ._bcc .Read (_fgcc );if _bec !=nil {return _bec ;};for _fgf :=uint64 (0);_fgf < _ffba ;_fgf ++{_gee ._ace [_fgf ]=_fgcc [_fgf ];};_gee ._ffb =_gee ._fbgf +uint64 (_fdf );return nil ;};func (_geca *SubstreamReader )Reset (){_geca ._gda =_geca ._ebd ;_geca ._dac =_geca ._aaa };func (_bde *Writer )Write (p []byte )(int ,error ){if len (p )> _bde .byteCapacity (){return 0,_f .EOF ;};for _ ,_bcea :=range p {if _dgbe :=_bde .writeByte (_bcea );_dgbe !=nil {return 0,_dgbe ;};};return len (p ),nil ;};func (_dbgd *Reader )ReadBool ()(bool ,error ){return _dbgd .readBool ()};func (_fdb *SubstreamReader )readUnalignedByte ()(_eaf byte ,_fgccb error ){_acfa :=_fdb ._dac ;_eaf =_fdb ._gfbg <<(8-_acfa );_fdb ._gfbg ,_fgccb =_fdb .readBufferByte ();if _fgccb !=nil {return 0,_fgccb ;};_eaf |=_fdb ._gfbg >>_acfa ;_fdb ._gfbg &=1<<_acfa -1;return _eaf ,nil ;};func (_afe *Reader )ConsumeRemainingBits (){if _afe ._cgd !=0{_ ,_gb :=_afe .ReadBits (_afe ._cgd );if _gb !=nil {_adc .Log .Debug ("\u0043\u006f\u006e\u0073\u0075\u006d\u0065\u0052\u0065\u006da\u0069\u006e\u0069\u0067\u0042\u0069\u0074s\u0020\u0066\u0061\u0069\u006c\u0065\u0064\u003a\u0020\u0025\u0076",_gb );};};};func (_ae *Reader )ReadBits (n byte )(_gd uint64 ,_bc error ){if n < _ae ._cgd {_acf :=_ae ._cgd -n ;_gd =uint64 (_ae ._fa >>_acf );_ae ._fa &=1<<_acf -1;_ae ._cgd =_acf ;return _gd ,nil ;};if n > _ae ._cgd {if _ae ._cgd > 0{_gd =uint64 (_ae ._fa );n -=_ae ._cgd ;};for n >=8{_beb ,_dbg :=_ae .readBufferByte ();if _dbg !=nil {return 0,_dbg ;};_gd =_gd <<8+uint64 (_beb );n -=8;};if n > 0{if _ae ._fa ,_bc =_ae .readBufferByte ();_bc !=nil {return 0,_bc ;};_abg :=8-n ;_gd =_gd <<n +uint64 (_ae ._fa >>_abg );_ae ._fa &=1<<_abg -1;_ae ._cgd =_abg ;}else {_ae ._cgd =0;};return _gd ,nil ;};_ae ._cgd =0;return uint64 (_ae ._fa ),nil ;};func (_cafa *SubstreamReader )ReadBits (n byte )(_cade uint64 ,_bg error ){if n < _cafa ._dac {_aaae :=_cafa ._dac -n ;_cade =uint64 (_cafa ._gfbg >>_aaae );_cafa ._gfbg &=1<<_aaae -1;_cafa ._dac =_aaae ;return _cade ,nil ;};if n > _cafa ._dac {if _cafa ._dac > 0{_cade =uint64 (_cafa ._gfbg );n -=_cafa ._dac ;};var _bfc byte ;for n >=8{_bfc ,_bg =_cafa .readBufferByte ();if _bg !=nil {return 0,_bg ;};_cade =_cade <<8+uint64 (_bfc );n -=8;};if n > 0{if _cafa ._gfbg ,_bg =_cafa .readBufferByte ();_bg !=nil {return 0,_bg ;};_cef :=8-n ;_cade =_cade <<n +uint64 (_cafa ._gfbg >>_cef );_cafa ._gfbg &=1<<_cef -1;_cafa ._dac =_cef ;}else {_cafa ._dac =0;};return _cade ,nil ;};_cafa ._dac =0;return uint64 (_cafa ._gfbg ),nil ;};func (_aea *Writer )byteCapacity ()int {_bfaa :=len (_aea ._deb )-_aea ._dgc ;if _aea ._eeb !=0{_bfaa --;};return _bfaa ;};func (_cda *Reader )ReadBit ()(_caf int ,_efdae error ){_fed ,_efdae :=_cda .readBool ();if _efdae !=nil {return 0,_efdae ;};if _fed {_caf =1;};return _caf ,nil ;};func (_bf *SubstreamReader )Length ()uint64 {return _bf ._bafg };type StreamReader interface{_f .Reader ;_f .ByteReader ;_f .Seeker ;Align ()byte ;BitPosition ()int ;Mark ();Length ()uint64 ;ReadBit ()(int ,error );ReadBits (_ga byte )(uint64 ,error );ReadBool ()(bool ,error );ReadUint32 ()(uint32 ,error );Reset ();StreamPosition ()int64 ;};func (_cac *BufferedWriter )grow (_eda int ){if _cac ._ag ==nil &&_eda < _aa {_cac ._ag =make ([]byte ,_eda ,_aa );return ;};_fg :=len (_cac ._ag );if _cac ._b !=0{_fg ++;};_bd :=cap (_cac ._ag );switch {case _eda <=_bd /2-_fg :_adc .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_cac ._ag ),cap (_cac ._ag ),_eda );_adc .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_bd ,_fg );copy (_cac ._ag ,_cac ._ag [_cac .fullOffset ():]);case _bd > _fb -_bd -_eda :_adc .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_cgc :=make ([]byte ,2*_bd +_eda );copy (_cgc ,_cac ._ag );_cac ._ag =_cgc ;};_cac ._ag =_cac ._ag [:_fg +_eda ];};func (_feg *Writer )Data ()[]byte {return _feg ._deb };type BinaryWriter interface{BitWriter ;_f .Writer ;_f .ByteWriter ;Data ()[]byte ;};func NewSubstreamReader (r StreamReader ,offset ,length uint64 )(*SubstreamReader ,error ){if r ==nil {return nil ,_a .New ("\u0072o\u006ft\u0020\u0072\u0065\u0061\u0064e\u0072\u0020i\u0073\u0020\u006e\u0069\u006c");};_adc .Log .Trace ("\u004e\u0065\u0077\u0053\u0075\u0062\u0073\u0074r\u0065\u0061\u006dRe\u0061\u0064\u0065\u0072\u0020\u0061t\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u003a\u0020\u0025\u0064\u0020\u0077\u0069\u0074h\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a \u0025\u0064",offset ,length );return &SubstreamReader {_bcc :r ,_gbfb :offset ,_bafg :length ,_ace :make ([]byte ,length )},nil ;};var (_ _f .Reader =&Reader {};_ _f .ByteReader =&Reader {};_ _f .Seeker =&Reader {};_ StreamReader =&Reader {};);func (_fgd *Writer )FinishByte (){if _fgd ._eeb ==0{return ;};_fgd ._eeb =0;_fgd ._dgc ++;};func (_cg *BufferedWriter )Len ()int {return _cg .byteCapacity ()};func (_edc *Reader )Mark (){_edc ._fbgc =_edc ._cb ;_edc ._bda =_edc ._cgd };func (_dagc *Writer )WriteByte (c byte )error {return _dagc .writeByte (c )};func (_agg *Reader )Length ()uint64 {return uint64 (len (_agg ._fbg ))};func (_cce *Reader )readBufferByte ()(byte ,error ){if _cce ._cb >=int64 (len (_cce ._fbg )){return 0,_f .EOF ;};_cce ._bbf =-1;_gad :=_cce ._fbg [_cce ._cb ];_cce ._cb ++;_cce ._fbgg =int (_gad );return _gad ,nil ;};func (_ebg *BufferedWriter )Write (d []byte )(int ,error ){_ebg .expandIfNeeded (len (d ));if _ebg ._b ==0{return _ebg .writeFullBytes (d ),nil ;};return _ebg .writeShiftedBytes (d ),nil ;};func (_abd *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _abd .writeBit (uint8 (bit ));};return _g .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");};func (_dfb *Writer )WriteBits (bits uint64 ,number int )(_eg int ,_bgg error ){const _cafg ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";if number < 0||number > 64{return 0,_g .Errorf (_cafg ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );};if number ==0{return 0,nil ;};_egb :=number /8;if _egb > 0{_fcbf :=number -_egb *8;for _gfc :=_egb -1;_gfc >=0;_gfc --{_fbfd :=byte ((bits >>uint (_gfc *8+_fcbf ))&0xff);if _bgg =_dfb .WriteByte (_fbfd );_bgg !=nil {return _eg ,_g .Wrapf (_bgg ,_cafg ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_egb -_gfc +1);};};number -=_egb *8;if number ==0{return _egb ,nil ;};};var _ggg int ;for _bge :=0;_bge < number ;_bge ++{if _dfb ._ebc {_ggg =int ((bits >>uint (number -1-_bge ))&0x1);}else {_ggg =int (bits &0x1);bits >>=1;};if _bgg =_dfb .WriteBit (_ggg );_bgg !=nil {return _eg ,_g .Wrapf (_bgg ,_cafg ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_bge );};};return _egb ,nil ;};func NewReader (data []byte )*Reader {return &Reader {_fbg :data }};type Reader struct{_fbg []byte ;_fa byte ;_cgd byte ;_cb int64 ;_fbgg int ;_bbf int ;_fbgc int64 ;_bda byte ;};type SubstreamReader struct{_gda uint64 ;_bcc StreamReader ;_gbfb uint64 ;_bafg uint64 ;_ace []byte ;_fbgf uint64 ;_ffb uint64 ;_gfbg byte ;_dac byte ;_ebd uint64 ;_aaa byte ;};