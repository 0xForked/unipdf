//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_e "encoding/binary";_d "errors";_g "github.com/unidoc/unipdf/v3/common";_da "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_ad "io";);type StreamReader interface{_ad .Reader ;_ad .ByteReader ;_ad .Seeker ;Align ()byte ;BitPosition ()int ;
Mark ();Length ()uint64 ;ReadBit ()(int ,error );ReadBits (_adg byte )(uint64 ,error );ReadBool ()(bool ,error );ReadUint32 ()(uint32 ,error );Reset ();StreamPosition ()int64 ;};func (_aa *SubstreamReader )Mark (){_aa ._dda =_aa ._dfd ;_aa ._dee =_aa ._dfa };
func (_cag *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _cag .writeBit (uint8 (bit ));};return _da .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");
};func (_eg *BufferedWriter )writeShiftedBytes (_ge []byte )int {for _ ,_bgb :=range _ge {_eg .writeByte (_bgb );};return len (_ge );};var _ BinaryWriter =&Writer {};func (_ffb *Reader )readBool ()(_ebed bool ,_fag error ){if _ffb ._eff ==0{_ffb ._gec ,_fag =_ffb .readBufferByte ();
if _fag !=nil {return false ,_fag ;};_ebed =(_ffb ._gec &0x80)!=0;_ffb ._gec ,_ffb ._eff =_ffb ._gec &0x7f,7;return _ebed ,nil ;};_ffb ._eff --;_ebed =(_ffb ._gec &(1<<_ffb ._eff ))!=0;_ffb ._gec &=1<<_ffb ._eff -1;return _ebed ,nil ;};func (_dcc *Writer )Data ()[]byte {return _dcc ._agcd };
func (_df *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _da .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );
};if len (_df ._bd )-1< _df ._c {_df .expandIfNeeded (1);};_dad :=_df ._bc ;if _df ._f {_dad =7-_df ._bc ;};_df ._bd [_df ._c ]|=byte (uint16 (bit <<_dad )&0xff);_df ._bc ++;if _df ._bc ==8{_df ._c ++;_df ._bc =0;};return nil ;};func (_dga *Reader )Length ()uint64 {return uint64 (len (_dga ._aeg ))};
func (_adfg *Reader )readBufferByte ()(byte ,error ){if _adfg ._ega >=int64 (len (_adfg ._aeg )){return 0,_ad .EOF ;};_adfg ._deg =-1;_dcf :=_adfg ._aeg [_adfg ._ega ];_adfg ._ega ++;_adfg ._ca =int (_dcf );return _dcf ,nil ;};func (_dac *BufferedWriter )byteCapacity ()int {_aec :=len (_dac ._bd )-_dac ._c ;
if _dac ._bc !=0{_aec --;};return _aec ;};func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_f :true }};func (_ada *BufferedWriter )fullOffset ()int {_fd :=_ada ._c ;if _ada ._bc !=0{_fd ++;};return _fd ;};var (_ _ad .Reader =&Reader {};_ _ad .ByteReader =&Reader {};
_ _ad .Seeker =&Reader {};_ StreamReader =&Reader {};);func (_fda *Writer )WriteBits (bits uint64 ,number int )(_bef int ,_cgb error ){const _fdc ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";if number < 0||number > 64{return 0,_da .Errorf (_fdc ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};if number ==0{return 0,nil ;};_acb :=number /8;if _acb > 0{_bbg :=number -_acb *8;for _aea :=_acb -1;_aea >=0;_aea --{_agdg :=byte ((bits >>uint (_aea *8+_bbg ))&0xff);if _cgb =_fda .WriteByte (_agdg );_cgb !=nil {return _bef ,_da .Wrapf (_cgb ,_fdc ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_acb -_aea +1);
};};number -=_acb *8;if number ==0{return _acb ,nil ;};};var _gda int ;for _cff :=0;_cff < number ;_cff ++{if _fda ._cdbb {_gda =int ((bits >>uint (number -1-_cff ))&0x1);}else {_gda =int (bits &0x1);bits >>=1;};if _cgb =_fda .WriteBit (_gda );_cgb !=nil {return _bef ,_da .Wrapf (_cgb ,_fdc ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_cff );
};};return _acb ,nil ;};func (_ffg *SubstreamReader )readBool ()(_dfe bool ,_gdfe error ){if _ffg ._dfa ==0{_ffg ._gde ,_gdfe =_ffg .readBufferByte ();if _gdfe !=nil {return false ,_gdfe ;};_dfe =(_ffg ._gde &0x80)!=0;_ffg ._gde ,_ffg ._dfa =_ffg ._gde &0x7f,7;
return _dfe ,nil ;};_ffg ._dfa --;_dfe =(_ffg ._gde &(1<<_ffg ._dfa ))!=0;_ffg ._gde &=1<<_ffg ._dfa -1;return _dfe ,nil ;};func (_ddee *Writer )SkipBits (skip int )error {const _caae ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";
if skip ==0{return nil ;};_eec :=int (_ddee ._cfef )+skip ;if _eec >=0&&_eec < 8{_ddee ._cfef =uint8 (_eec );return nil ;};_eec =int (_ddee ._cfef )+_ddee ._fdba *8+skip ;if _eec < 0{return _da .Errorf (_caae ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_ecg :=_eec /8;_cbdd :=_eec %8;_g .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");_g .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_ddee ._cfef ,_ddee ._fdba ,int (_ddee ._cfef )+(_ddee ._fdba )*8,len (_ddee ._agcd ),cap (_ddee ._agcd ));
_g .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_eec ,_cbdd );_ddee ._cfef =uint8 (_cbdd );
if _bfc :=_ecg -_ddee ._fdba ;_bfc > 0&&len (_ddee ._agcd )-1< _ecg {_g .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_bfc );return _da .Errorf (_caae ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_ddee ._fdba =_ecg ;_g .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_ddee ._cfef ,_ddee ._fdba );return nil ;
};type BufferedWriter struct{_bd []byte ;_bc uint8 ;_c int ;_f bool ;};func (_gb *BufferedWriter )Len ()int {return _gb .byteCapacity ()};func (_aeb *Reader )Align ()(_dgf byte ){_dgf =_aeb ._eff ;_aeb ._eff =0;return _dgf };func (_ba *BufferedWriter )Reset (){_ba ._bd =_ba ._bd [:0];
_ba ._c =0;_ba ._bc =0};func (_fg *Reader )ReadBit ()(_fa int ,_gbg error ){_egf ,_gbg :=_fg .readBool ();if _gbg !=nil {return 0,_gbg ;};if _egf {_fa =1;};return _fa ,nil ;};func (_cdb *BufferedWriter )writeFullBytes (_fb []byte )int {_ed :=copy (_cdb ._bd [_cdb .fullOffset ():],_fb );
_cdb ._c +=_ed ;return _ed ;};func _adad (_afeg ,_caa uint64 )uint64 {if _afeg < _caa {return _afeg ;};return _caa ;};func (_eeb *Writer )writeBit (_gc uint8 )error {if len (_eeb ._agcd )-1< _eeb ._fdba {return _ad .EOF ;};_cad :=_eeb ._cfef ;if _eeb ._cdbb {_cad =7-_eeb ._cfef ;
};_eeb ._agcd [_eeb ._fdba ]|=byte (uint16 (_gc <<_cad )&0xff);_eeb ._cfef ++;if _eeb ._cfef ==8{_eeb ._fdba ++;_eeb ._cfef =0;};return nil ;};func NewSubstreamReader (r StreamReader ,offset ,length uint64 )(*SubstreamReader ,error ){if r ==nil {return nil ,_d .New ("\u0072o\u006ft\u0020\u0072\u0065\u0061\u0064e\u0072\u0020i\u0073\u0020\u006e\u0069\u006c");
};_g .Log .Trace ("\u004e\u0065\u0077\u0053\u0075\u0062\u0073\u0074r\u0065\u0061\u006dRe\u0061\u0064\u0065\u0072\u0020\u0061t\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u003a\u0020\u0025\u0064\u0020\u0077\u0069\u0074h\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a \u0025\u0064",offset ,length );
return &SubstreamReader {_afe :r ,_dca :offset ,_becf :length ,_aef :make ([]byte ,length )},nil ;};func (_bagd *Writer )FinishByte (){if _bagd ._cfef ==0{return ;};_bagd ._cfef =0;_bagd ._fdba ++;};func (_aedg *Reader )ReadBool ()(bool ,error ){return _aedg .readBool ()};
func NewWriter (data []byte )*Writer {return &Writer {_agcd :data }};func (_ggc *Writer )UseMSB ()bool {return _ggc ._cdbb };func (_dcb *Reader )Mark (){_dcb ._age =_dcb ._ega ;_dcb ._cc =_dcb ._eff ;_dcb ._ff =_dcb ._gec ;_dcb ._cce =_dcb ._ca ;};func (_ae *BufferedWriter )FinishByte (){if _ae ._bc ==0{return ;
};_ae ._bc =0;_ae ._c ++;};func (_adf *BufferedWriter )WriteByte (bt byte )error {if _adf ._c > len (_adf ._bd )-1||(_adf ._c ==len (_adf ._bd )-1&&_adf ._bc !=0){_adf .expandIfNeeded (1);};_adf .writeByte (bt );return nil ;};func (_ffc *Writer )ResetBit (){_ffc ._cfef =0};
type Writer struct{_agcd []byte ;_cfef uint8 ;_fdba int ;_cdbb bool ;};func (_faeg *SubstreamReader )Reset (){_faeg ._dfd =_faeg ._dda ;_faeg ._dfa =_faeg ._dee };func (_efe *SubstreamReader )ReadUint32 ()(uint32 ,error ){_fae :=make ([]byte ,4);_ ,_ccee :=_efe .Read (_fae );
if _ccee !=nil {return 0,_ccee ;};return _e .BigEndian .Uint32 (_fae ),nil ;};func (_gg *BufferedWriter )Data ()[]byte {return _gg ._bd };func (_agd *BufferedWriter )expandIfNeeded (_ef int ){if !_agd .tryGrowByReslice (_ef ){_agd .grow (_ef );};};func (_dgd *Reader )ReadUint32 ()(uint32 ,error ){_bca :=make ([]byte ,4);
_ ,_bgae :=_dgd .Read (_bca );if _bgae !=nil {return 0,_bgae ;};return _e .BigEndian .Uint32 (_bca ),nil ;};type SubstreamReader struct{_dfd uint64 ;_afe StreamReader ;_dca uint64 ;_becf uint64 ;_aef []byte ;_gdf uint64 ;_cbe uint64 ;_gde byte ;_dfa byte ;
_dda uint64 ;_dee byte ;};func (_daa *SubstreamReader )Offset ()uint64 {return _daa ._dca };func (_aecc *Writer )WriteByte (c byte )error {return _aecc .writeByte (c )};func (_eee *Reader )readUnalignedByte ()(_bdg byte ,_cef error ){_ddd :=_eee ._eff ;
_bdg =_eee ._gec <<(8-_ddd );_eee ._gec ,_cef =_eee .readBufferByte ();if _cef !=nil {return 0,_cef ;};_bdg |=_eee ._gec >>_ddd ;_eee ._gec &=1<<_ddd -1;return _bdg ,nil ;};func (_gga *SubstreamReader )ReadBits (n byte )(_baf uint64 ,_afd error ){if n < _gga ._dfa {_agc :=_gga ._dfa -n ;
_baf =uint64 (_gga ._gde >>_agc );_gga ._gde &=1<<_agc -1;_gga ._dfa =_agc ;return _baf ,nil ;};if n > _gga ._dfa {if _gga ._dfa > 0{_baf =uint64 (_gga ._gde );n -=_gga ._dfa ;};var _gbcg byte ;for n >=8{_gbcg ,_afd =_gga .readBufferByte ();if _afd !=nil {return 0,_afd ;
};_baf =_baf <<8+uint64 (_gbcg );n -=8;};if n > 0{if _gga ._gde ,_afd =_gga .readBufferByte ();_afd !=nil {return 0,_afd ;};_fdb :=8-n ;_baf =_baf <<n +uint64 (_gga ._gde >>_fdb );_gga ._gde &=1<<_fdb -1;_gga ._dfa =_fdb ;}else {_gga ._dfa =0;};return _baf ,nil ;
};_gga ._dfa =0;return uint64 (_gga ._gde ),nil ;};func (_cbd *Reader )read (_eca []byte )(int ,error ){if _cbd ._ega >=int64 (len (_cbd ._aeg )){return 0,_ad .EOF ;};_cbd ._deg =-1;_adbe :=copy (_eca ,_cbd ._aeg [_cbd ._ega :]);_cbd ._ega +=int64 (_adbe );
return _adbe ,nil ;};func (_dec *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_dec ._deg =-1;var _ddg int64 ;switch whence {case _ad .SeekStart :_ddg =offset ;case _ad .SeekCurrent :_ddg =_dec ._ega +offset ;case _ad .SeekEnd :_ddg =int64 (len (_dec ._aeg ))+offset ;
default:return 0,_d .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");};if _ddg < 0{return 0,_d .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");
};_dec ._ega =_ddg ;_dec ._eff =0;return _ddg ,nil ;};func (_cfe *Reader )Reset (){_cfe ._ega =_cfe ._age ;_cfe ._eff =_cfe ._cc ;_cfe ._gec =_cfe ._ff ;_cfe ._ca =_cfe ._cce ;};func (_deef *SubstreamReader )ReadBit ()(_fbf int ,_cdd error ){_ffad ,_cdd :=_deef .readBool ();
if _cdd !=nil {return 0,_cdd ;};if _ffad {_fbf =1;};return _fbf ,nil ;};func (_gbd *Reader )ConsumeRemainingBits ()(uint64 ,error ){if _gbd ._eff !=0{return _gbd .ReadBits (_gbd ._eff );};return 0,nil ;};func (_ffa *SubstreamReader )Align ()(_dcg byte ){_dcg =_ffa ._dfa ;
_ffa ._dfa =0;return _dcg };func (_bgg *Reader )Read (p []byte )(_egg int ,_fce error ){if _bgg ._eff ==0{return _bgg .read (p );};for ;_egg < len (p );_egg ++{if p [_egg ],_fce =_bgg .readUnalignedByte ();_fce !=nil {return 0,_fce ;};};return _egg ,nil ;
};var _ BinaryWriter =&BufferedWriter {};func NewReader (data []byte )*Reader {return &Reader {_aeg :data }};var _ _ad .ByteWriter =&BufferedWriter {};func (_cbb *SubstreamReader )StreamPosition ()int64 {return int64 (_cbb ._dfd )};func (_ecad *SubstreamReader )Length ()uint64 {return _ecad ._becf };
var _ _ad .Writer =&BufferedWriter {};func (_ac *BufferedWriter )Write (d []byte )(int ,error ){_ac .expandIfNeeded (len (d ));if _ac ._bc ==0{return _ac .writeFullBytes (d ),nil ;};return _ac .writeShiftedBytes (d ),nil ;};func (_cf *Reader )ReadByte ()(byte ,error ){if _cf ._eff ==0{return _cf .readBufferByte ();
};return _cf .readUnalignedByte ();};func (_bg *BufferedWriter )ResetBitIndex (){_bg ._bc =0};type BitWriter interface{WriteBit (_dba int )error ;WriteBits (_gae uint64 ,_gf int )(_dbg int ,_dae error );FinishByte ();SkipBits (_fcc int )error ;};func (_gbdd *Writer )byteCapacity ()int {_bcd :=len (_gbdd ._agcd )-_gbdd ._fdba ;
if _gbdd ._cfef !=0{_bcd --;};return _bcd ;};func (_gdd *SubstreamReader )readBufferByte ()(byte ,error ){if _gdd ._dfd >=_gdd ._becf {return 0,_ad .EOF ;};if _gdd ._dfd >=_gdd ._cbe ||_gdd ._dfd < _gdd ._gdf {if _efb :=_gdd .fillBuffer ();_efb !=nil {return 0,_efb ;
};};_cdab :=_gdd ._aef [_gdd ._dfd -_gdd ._gdf ];_gdd ._dfd ++;return _cdab ,nil ;};func (_afaa *SubstreamReader )ReadBool ()(bool ,error ){return _afaa .readBool ()};func (_gdb *Reader )StreamPosition ()int64 {return _gdb ._ega };func (_adb *BufferedWriter )grow (_gd int ){if _adb ._bd ==nil &&_gd < _b {_adb ._bd =make ([]byte ,_gd ,_b );
return ;};_fdf :=len (_adb ._bd );if _adb ._bc !=0{_fdf ++;};_gbc :=cap (_adb ._bd );switch {case _gd <=_gbc /2-_fdf :_g .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_adb ._bd ),cap (_adb ._bd ),_gd );
_g .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_gbc ,_fdf );copy (_adb ._bd ,_adb ._bd [_adb .fullOffset ():]);
case _gbc > _db -_gbc -_gd :_g .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_dbe :=make ([]byte ,2*_gbc +_gd );copy (_dbe ,_adb ._bd );_adb ._bd =_dbe ;};_adb ._bd =_adb ._bd [:_fdf +_gd ];
};const (_b =64;_db =int (^uint (0)>>1););func (_ebb *Writer )Write (p []byte )(int ,error ){if len (p )> _ebb .byteCapacity (){return 0,_ad .EOF ;};for _ ,_gece :=range p {if _gecg :=_ebb .writeByte (_gece );_gecg !=nil {return 0,_gecg ;};};return len (p ),nil ;
};func (_bad *SubstreamReader )BitPosition ()int {return int (_bad ._dfa )};type Reader struct{_aeg []byte ;_gec byte ;_eff byte ;_ega int64 ;_ca int ;_deg int ;_age int64 ;_cc byte ;_ff byte ;_cce int ;};func (_eac *BufferedWriter )tryGrowByReslice (_eb int )bool {if _cdc :=len (_eac ._bd );
_eb <=cap (_eac ._bd )-_cdc {_eac ._bd =_eac ._bd [:_cdc +_eb ];return true ;};return false ;};func (_beg *SubstreamReader )Seek (offset int64 ,whence int )(int64 ,error ){switch whence {case _ad .SeekStart :_beg ._dfd =uint64 (offset );case _ad .SeekCurrent :_beg ._dfd +=uint64 (offset );
case _ad .SeekEnd :_beg ._dfd =_beg ._becf +uint64 (offset );default:return 0,_d .New ("\u0072\u0065\u0061d\u0065\u0072\u002e\u0053\u0075\u0062\u0073\u0074\u0072\u0065\u0061\u006d\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u0020\u0069\u006e\u0076\u0061\u006ci\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};_beg ._dfa =0;return int64 (_beg ._dfd ),nil ;};type BinaryWriter interface{BitWriter ;_ad .Writer ;_ad .ByteWriter ;Data ()[]byte ;};func (_bf *BufferedWriter )writeByte (_afa byte ){switch {case _bf ._bc ==0:_bf ._bd [_bf ._c ]=_afa ;_bf ._c ++;case _bf ._f :_bf ._bd [_bf ._c ]|=_afa >>_bf ._bc ;
_bf ._c ++;_bf ._bd [_bf ._c ]=byte (uint16 (_afa )<<(8-_bf ._bc )&0xff);default:_bf ._bd [_bf ._c ]|=byte (uint16 (_afa )<<_bf ._bc &0xff);_bf ._c ++;_bf ._bd [_bf ._c ]=_afa >>(8-_bf ._bc );};};func (_gbf *SubstreamReader )ReadByte ()(byte ,error ){if _gbf ._dfa ==0{return _gbf .readBufferByte ();
};return _gbf .readUnalignedByte ();};func (_gbb *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;};_bab :=int (_gbb ._bc )+skip ;if _bab >=0&&_bab < 8{_gbb ._bc =uint8 (_bab );return nil ;};_bab =int (_gbb ._bc )+_gbb ._c *8+skip ;if _bab < 0{return _da .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_bga :=_bab /8;_ag :=_bab %8;_gbb ._bc =uint8 (_ag );if _fe :=_bga -_gbb ._c ;_fe > 0&&len (_gbb ._bd )-1< _bga {if _gbb ._bc !=0{_fe ++;};_gbb .expandIfNeeded (_fe );};_gbb ._c =_bga ;return nil ;};func (_gfe *SubstreamReader )readUnalignedByte ()(_cceg byte ,_gfg error ){_beb :=_gfe ._dfa ;
_cceg =_gfe ._gde <<(8-_beb );_gfe ._gde ,_gfg =_gfe .readBufferByte ();if _gfg !=nil {return 0,_gfg ;};_cceg |=_gfe ._gde >>_beb ;_gfe ._gde &=1<<_beb -1;return _cceg ,nil ;};func (_dde *SubstreamReader )Read (b []byte )(_gdfd int ,_dag error ){if _dde ._dfd >=_dde ._becf {_g .Log .Trace ("\u0053\u0074\u0072e\u0061\u006d\u0050\u006fs\u003a\u0020\u0027\u0025\u0064\u0027\u0020>\u003d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027",_dde ._dfd ,_dde ._becf );
return 0,_ad .EOF ;};for ;_gdfd < len (b );_gdfd ++{if b [_gdfd ],_dag =_dde .readUnalignedByte ();_dag !=nil {if _dag ==_ad .EOF {return _gdfd ,nil ;};return 0,_dag ;};};return _gdfd ,nil ;};func NewWriterMSB (data []byte )*Writer {return &Writer {_agcd :data ,_cdbb :true }};
func (_gdfb *Writer )writeByte (_gbcc byte )error {if _gdfb ._fdba > len (_gdfb ._agcd )-1{return _ad .EOF ;};if _gdfb ._fdba ==len (_gdfb ._agcd )-1&&_gdfb ._cfef !=0{return _ad .EOF ;};if _gdfb ._cfef ==0{_gdfb ._agcd [_gdfb ._fdba ]=_gbcc ;_gdfb ._fdba ++;
return nil ;};if _gdfb ._cdbb {_gdfb ._agcd [_gdfb ._fdba ]|=_gbcc >>_gdfb ._cfef ;_gdfb ._fdba ++;_gdfb ._agcd [_gdfb ._fdba ]=byte (uint16 (_gbcc )<<(8-_gdfb ._cfef )&0xff);}else {_gdfb ._agcd [_gdfb ._fdba ]|=byte (uint16 (_gbcc )<<_gdfb ._cfef &0xff);
_gdfb ._fdba ++;_gdfb ._agcd [_gdfb ._fdba ]=_gbcc >>(8-_gdfb ._cfef );};return nil ;};func (_ee *BufferedWriter )WriteBits (bits uint64 ,number int )(_dd int ,_fec error ){const _cd ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";
if number < 0||number > 64{return 0,_da .Errorf (_cd ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};_cb :=number /8;if _cb > 0{_dbc :=number -_cb *8;for _bb :=_cb -1;_bb >=0;_bb --{_de :=byte ((bits >>uint (_bb *8+_dbc ))&0xff);if _fec =_ee .WriteByte (_de );_fec !=nil {return _dd ,_da .Wrapf (_fec ,_cd ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_cb -_bb +1);
};};number -=_cb *8;if number ==0{return _cb ,nil ;};};var _fc int ;for _be :=0;_be < number ;_be ++{if _ee ._f {_fc =int ((bits >>uint (number -1-_be ))&0x1);}else {_fc =int (bits &0x1);bits >>=1;};if _fec =_ee .WriteBit (_fc );_fec !=nil {return _dd ,_da .Wrapf (_fec ,_cd ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_be );
};};return _cb ,nil ;};func (_dgda *SubstreamReader )fillBuffer ()error {if uint64 (_dgda ._afe .StreamPosition ())!=_dgda ._dfd +_dgda ._dca {_ ,_ceb :=_dgda ._afe .Seek (int64 (_dgda ._dfd +_dgda ._dca ),_ad .SeekStart );if _ceb !=nil {return _ceb ;};
};_dgda ._gdf =_dgda ._dfd ;_ceg :=_adad (uint64 (len (_dgda ._aef )),_dgda ._becf -_dgda ._dfd );_cfc :=make ([]byte ,_ceg );_cg ,_bcg :=_dgda ._afe .Read (_cfc );if _bcg !=nil {return _bcg ;};for _dge :=uint64 (0);_dge < _ceg ;_dge ++{_dgda ._aef [_dge ]=_cfc [_dge ];
};_dgda ._cbe =_dgda ._gdf +uint64 (_cg );return nil ;};func (_aed *Reader )ReadBits (n byte )(_bfd uint64 ,_edf error ){if n < _aed ._eff {_cda :=_aed ._eff -n ;_bfd =uint64 (_aed ._gec >>_cda );_aed ._gec &=1<<_cda -1;_aed ._eff =_cda ;return _bfd ,nil ;
};if n > _aed ._eff {if _aed ._eff > 0{_bfd =uint64 (_aed ._gec );n -=_aed ._eff ;};for n >=8{_bec ,_ebe :=_aed .readBufferByte ();if _ebe !=nil {return 0,_ebe ;};_bfd =_bfd <<8+uint64 (_bec );n -=8;};if n > 0{if _aed ._gec ,_edf =_aed .readBufferByte ();
_edf !=nil {return 0,_edf ;};_ce :=8-n ;_bfd =_bfd <<n +uint64 (_aed ._gec >>_ce );_aed ._gec &=1<<_ce -1;_aed ._eff =_ce ;}else {_aed ._eff =0;};return _bfd ,nil ;};_aed ._eff =0;return uint64 (_aed ._gec ),nil ;};func (_bgc *Reader )BitPosition ()int {return int (_bgc ._eff )};
