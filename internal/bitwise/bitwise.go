//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_e "encoding/binary";_a "errors";_c "github.com/unidoc/unipdf/v3/common";_fc "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_f "io";);func (_bcb *SubstreamReader )Reset (){_bcb ._fab =_bcb ._gg ;_bcb ._gbc =_bcb ._cde };func (_ddb *BufferedWriter )expandIfNeeded (_abg int ){if !_ddb .tryGrowByReslice (_abg ){_ddb .grow (_abg );
};};func (_bfe *Reader )ReadBool ()(bool ,error ){return _bfe .readBool ()};func (_bcff *Writer )writeByte (_cec byte )error {if _bcff ._eeg > len (_bcff ._adb )-1{return _f .EOF ;};if _bcff ._eeg ==len (_bcff ._adb )-1&&_bcff ._eggb !=0{return _f .EOF ;
};if _bcff ._eggb ==0{_bcff ._adb [_bcff ._eeg ]=_cec ;_bcff ._eeg ++;return nil ;};if _bcff ._dgg {_bcff ._adb [_bcff ._eeg ]|=_cec >>_bcff ._eggb ;_bcff ._eeg ++;_bcff ._adb [_bcff ._eeg ]=byte (uint16 (_cec )<<(8-_bcff ._eggb )&0xff);}else {_bcff ._adb [_bcff ._eeg ]|=byte (uint16 (_cec )<<_bcff ._eggb &0xff);
_bcff ._eeg ++;_bcff ._adb [_bcff ._eeg ]=_cec >>(8-_bcff ._eggb );};return nil ;};func (_ffd *Reader )StreamPosition ()int64 {return _ffd ._dcg };type StreamReader interface{_f .Reader ;_f .ByteReader ;_f .Seeker ;Align ()byte ;BitPosition ()int ;Mark ();
Length ()uint64 ;ReadBit ()(int ,error );ReadBits (_gf byte )(uint64 ,error );ReadBool ()(bool ,error );ReadUint32 ()(uint32 ,error );Reset ();StreamPosition ()int64 ;};func (_adgf *Writer )WriteBits (bits uint64 ,number int )(_gbfg int ,_bcc error ){const _febd ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";
if number < 0||number > 64{return 0,_fc .Errorf (_febd ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};if number ==0{return 0,nil ;};_cee :=number /8;if _cee > 0{_fcc :=number -_cee *8;for _dfd :=_cee -1;_dfd >=0;_dfd --{_egcb :=byte ((bits >>uint (_dfd *8+_fcc ))&0xff);if _bcc =_adgf .WriteByte (_egcb );_bcc !=nil {return _gbfg ,_fc .Wrapf (_bcc ,_febd ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_cee -_dfd +1);
};};number -=_cee *8;if number ==0{return _cee ,nil ;};};var _cged int ;for _bfbdf :=0;_bfbdf < number ;_bfbdf ++{if _adgf ._dgg {_cged =int ((bits >>uint (number -1-_bfbdf ))&0x1);}else {_cged =int (bits &0x1);bits >>=1;};if _bcc =_adgf .WriteBit (_cged );
_bcc !=nil {return _gbfg ,_fc .Wrapf (_bcc ,_febd ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_bfbdf );};};return _cee ,nil ;};func (_gfg *Reader )ReadByte ()(byte ,error ){if _gfg ._dbf ==0{return _gfg .readBufferByte ();};return _gfg .readUnalignedByte ();
};func (_fgbg *SubstreamReader )readBool ()(_gfgg bool ,_acc error ){if _fgbg ._gbc ==0{_fgbg ._cfb ,_acc =_fgbg .readBufferByte ();if _acc !=nil {return false ,_acc ;};_gfgg =(_fgbg ._cfb &0x80)!=0;_fgbg ._cfb ,_fgbg ._gbc =_fgbg ._cfb &0x7f,7;return _gfgg ,nil ;
};_fgbg ._gbc --;_gfgg =(_fgbg ._cfb &(1<<_fgbg ._gbc ))!=0;_fgbg ._cfb &=1<<_fgbg ._gbc -1;return _gfgg ,nil ;};type BinaryWriter interface{BitWriter ;_f .Writer ;_f .ByteWriter ;Data ()[]byte ;};func (_dbg *Reader )readBool ()(_ebg bool ,_fca error ){if _dbg ._dbf ==0{_dbg ._cag ,_fca =_dbg .readBufferByte ();
if _fca !=nil {return false ,_fca ;};_ebg =(_dbg ._cag &0x80)!=0;_dbg ._cag ,_dbg ._dbf =_dbg ._cag &0x7f,7;return _ebg ,nil ;};_dbg ._dbf --;_ebg =(_dbg ._cag &(1<<_dbg ._dbf ))!=0;_dbg ._cag &=1<<_dbg ._dbf -1;return _ebg ,nil ;};func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_d :true }};
type BufferedWriter struct{_ge []byte ;_gbf uint8 ;_abc int ;_d bool ;};func (_eff *BufferedWriter )grow (_bb int ){if _eff ._ge ==nil &&_bb < _b {_eff ._ge =make ([]byte ,_bb ,_b );return ;};_dab :=len (_eff ._ge );if _eff ._gbf !=0{_dab ++;};_bg :=cap (_eff ._ge );
switch {case _bb <=_bg /2-_dab :_c .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_eff ._ge ),cap (_eff ._ge ),_bb );
_c .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_bg ,_dab );copy (_eff ._ge ,_eff ._ge [_eff .fullOffset ():]);
case _bg > _ab -_bg -_bb :_c .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_ba :=make ([]byte ,2*_bg +_bb );copy (_ba ,_eff ._ge );_eff ._ge =_ba ;};_eff ._ge =_eff ._ge [:_dab +_bb ];
};func (_bad *Reader )ReadUint32 ()(uint32 ,error ){_edf :=make ([]byte ,4);_ ,_ffg :=_bad .Read (_edf );if _ffg !=nil {return 0,_ffg ;};return _e .BigEndian .Uint32 (_edf ),nil ;};func NewReader (data []byte )*Reader {return &Reader {_egc :data }};func (_daf *Reader )read (_dgaf []byte )(int ,error ){if _daf ._dcg >=int64 (len (_daf ._egc )){return 0,_f .EOF ;
};_daf ._bca =-1;_bee :=copy (_dgaf ,_daf ._egc [_daf ._dcg :]);_daf ._dcg +=int64 (_bee );return _bee ,nil ;};func (_da *BufferedWriter )Data ()[]byte {return _da ._ge };func (_cdg *Reader )ReadBits (n byte )(_dga uint64 ,_efe error ){if n < _cdg ._dbf {_dbb :=_cdg ._dbf -n ;
_dga =uint64 (_cdg ._cag >>_dbb );_cdg ._cag &=1<<_dbb -1;_cdg ._dbf =_dbb ;return _dga ,nil ;};if n > _cdg ._dbf {if _cdg ._dbf > 0{_dga =uint64 (_cdg ._cag );n -=_cdg ._dbf ;};for n >=8{_fee ,_defa :=_cdg .readBufferByte ();if _defa !=nil {return 0,_defa ;
};_dga =_dga <<8+uint64 (_fee );n -=8;};if n > 0{if _cdg ._cag ,_efe =_cdg .readBufferByte ();_efe !=nil {return 0,_efe ;};_gegc :=8-n ;_dga =_dga <<n +uint64 (_cdg ._cag >>_gegc );_cdg ._cag &=1<<_gegc -1;_cdg ._dbf =_gegc ;}else {_cdg ._dbf =0;};return _dga ,nil ;
};_cdg ._dbf =0;return uint64 (_cdg ._cag ),nil ;};func (_ed *Reader )Read (p []byte )(_eba int ,_cfg error ){if _ed ._dbf ==0{return _ed .read (p );};for ;_eba < len (p );_eba ++{if p [_eba ],_cfg =_ed .readUnalignedByte ();_cfg !=nil {return 0,_cfg ;
};};return _eba ,nil ;};func (_agc *SubstreamReader )ReadUint32 ()(uint32 ,error ){_ead :=make ([]byte ,4);_ ,_abcg :=_agc .Read (_ead );if _abcg !=nil {return 0,_abcg ;};return _e .BigEndian .Uint32 (_ead ),nil ;};func (_cd *BufferedWriter )writeShiftedBytes (_gd []byte )int {for _ ,_gec :=range _gd {_cd .writeByte (_gec );
};return len (_gd );};type Writer struct{_adb []byte ;_eggb uint8 ;_eeg int ;_dgg bool ;};func (_cg *BufferedWriter )byteCapacity ()int {_dc :=len (_cg ._ge )-_cg ._abc ;if _cg ._gbf !=0{_dc --;};return _dc ;};func (_fgc *SubstreamReader )ReadByte ()(byte ,error ){if _fgc ._gbc ==0{return _fgc .readBufferByte ();
};return _fgc .readUnalignedByte ();};func (_ga *SubstreamReader )BitPosition ()int {return int (_ga ._gbc )};var _ _f .Writer =&BufferedWriter {};func (_gag *Writer )Data ()[]byte {return _gag ._adb };func (_dcf *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_dcf ._bca =-1;
var _ddbf int64 ;switch whence {case _f .SeekStart :_ddbf =offset ;case _f .SeekCurrent :_ddbf =_dcf ._dcg +offset ;case _f .SeekEnd :_ddbf =int64 (len (_dcf ._egc ))+offset ;default:return 0,_a .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};if _ddbf < 0{return 0,_a .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");};_dcf ._dcg =_ddbf ;
_dcf ._dbf =0;return _ddbf ,nil ;};func NewSubstreamReader (r StreamReader ,offset ,length uint64 )(*SubstreamReader ,error ){if r ==nil {return nil ,_a .New ("\u0072o\u006ft\u0020\u0072\u0065\u0061\u0064e\u0072\u0020i\u0073\u0020\u006e\u0069\u006c");};
_c .Log .Trace ("\u004e\u0065\u0077\u0053\u0075\u0062\u0073\u0074r\u0065\u0061\u006dRe\u0061\u0064\u0065\u0072\u0020\u0061t\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u003a\u0020\u0025\u0064\u0020\u0077\u0069\u0074h\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a \u0025\u0064",offset ,length );
return &SubstreamReader {_afe :r ,_gdg :offset ,_cge :length ,_bag :make ([]byte ,length )},nil ;};func (_bbb *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _bbb .writeBit (uint8 (bit ));};return _fc .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");
};func (_bff *BufferedWriter )WriteByte (bt byte )error {if _bff ._abc > len (_bff ._ge )-1||(_bff ._abc ==len (_bff ._ge )-1&&_bff ._gbf !=0){_bff .expandIfNeeded (1);};_bff .writeByte (bt );return nil ;};func (_bfeb *SubstreamReader )Length ()uint64 {return _bfeb ._cge };
func _daa (_adg ,_feg uint64 )uint64 {if _adg < _feg {return _adg ;};return _feg ;};func (_cc *SubstreamReader )Read (b []byte )(_cdeg int ,_fgb error ){if _cc ._fab >=_cc ._cge {_c .Log .Trace ("\u0053\u0074\u0072e\u0061\u006d\u0050\u006fs\u003a\u0020\u0027\u0025\u0064\u0027\u0020>\u003d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027",_cc ._fab ,_cc ._cge );
return 0,_f .EOF ;};for ;_cdeg < len (b );_cdeg ++{if b [_cdeg ],_fgb =_cc .readUnalignedByte ();_fgb !=nil {if _fgb ==_f .EOF {return _cdeg ,nil ;};return 0,_fgb ;};};return _cdeg ,nil ;};const (_b =64;_ab =int (^uint (0)>>1););var _ _f .ByteWriter =&BufferedWriter {};
func (_bde *Reader )readBufferByte ()(byte ,error ){if _bde ._dcg >=int64 (len (_bde ._egc )){return 0,_f .EOF ;};_bde ._bca =-1;_bfb :=_bde ._egc [_bde ._dcg ];_bde ._dcg ++;_bde ._fce =int (_bfb );return _bfb ,nil ;};func NewWriter (data []byte )*Writer {return &Writer {_adb :data }};
func (_eaa *SubstreamReader )Mark (){_eaa ._gg =_eaa ._fab ;_eaa ._cde =_eaa ._gbc };func (_cgb *SubstreamReader )Align ()(_fbf byte ){_fbf =_cgb ._gbc ;_cgb ._gbc =0;return _fbf };func (_babf *Writer )FinishByte (){if _babf ._eggb ==0{return ;};_babf ._eggb =0;
_babf ._eeg ++;};func (_afd *Reader )readUnalignedByte ()(_ebac byte ,_cga error ){_effd :=_afd ._dbf ;_ebac =_afd ._cag <<(8-_effd );_afd ._cag ,_cga =_afd .readBufferByte ();if _cga !=nil {return 0,_cga ;};_ebac |=_afd ._cag >>_effd ;_afd ._cag &=1<<_effd -1;
return _ebac ,nil ;};func (_be *BufferedWriter )fullOffset ()int {_ee :=_be ._abc ;if _be ._gbf !=0{_ee ++;};return _ee ;};type SubstreamReader struct{_fab uint64 ;_afe StreamReader ;_gdg uint64 ;_cge uint64 ;_bag []byte ;_edff uint64 ;_df uint64 ;_cfb byte ;
_gbc byte ;_gg uint64 ;_cde byte ;};func (_bab *Reader )Mark (){_bab ._dcc =_bab ._dcg ;_bab ._fgf =_bab ._dbf };type Reader struct{_egc []byte ;_cag byte ;_dbf byte ;_dcg int64 ;_fce int ;_bca int ;_dcc int64 ;_fgf byte ;};func (_bdd *Writer )SkipBits (skip int )error {const _gab ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";
if skip ==0{return nil ;};_bcg :=int (_bdd ._eggb )+skip ;if _bcg >=0&&_bcg < 8{_bdd ._eggb =uint8 (_bcg );return nil ;};_bcg =int (_bdd ._eggb )+_bdd ._eeg *8+skip ;if _bcg < 0{return _fc .Errorf (_gab ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_fdf :=_bcg /8;_aae :=_bcg %8;_c .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");_c .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_bdd ._eggb ,_bdd ._eeg ,int (_bdd ._eggb )+(_bdd ._eeg )*8,len (_bdd ._adb ),cap (_bdd ._adb ));
_c .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_bcg ,_aae );_bdd ._eggb =uint8 (_aae );if _cgg :=_fdf -_bdd ._eeg ;
_cgg > 0&&len (_bdd ._adb )-1< _fdf {_c .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_cgg );return _fc .Errorf (_gab ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_bdd ._eeg =_fdf ;
_c .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_bdd ._eggb ,_bdd ._eeg );return nil ;};func (_aca *SubstreamReader )readBufferByte ()(byte ,error ){if _aca ._fab >=_aca ._cge {return 0,_f .EOF ;
};if _aca ._fab >=_aca ._df ||_aca ._fab < _aca ._edff {if _agb :=_aca .fillBuffer ();_agb !=nil {return 0,_agb ;};};_afac :=_aca ._bag [_aca ._fab -_aca ._edff ];_aca ._fab ++;return _afac ,nil ;};func (_bfbb *Writer )UseMSB ()bool {return _bfbb ._dgg };
func (_fag *BufferedWriter )tryGrowByReslice (_gbb int )bool {if _de :=len (_fag ._ge );_gbb <=cap (_fag ._ge )-_de {_fag ._ge =_fag ._ge [:_de +_gbb ];return true ;};return false ;};func (_fcd *SubstreamReader )readUnalignedByte ()(_ddd byte ,_bcf error ){_fcdb :=_fcd ._gbc ;
_ddd =_fcd ._cfb <<(8-_fcdb );_fcd ._cfb ,_bcf =_fcd .readBufferByte ();if _bcf !=nil {return 0,_bcf ;};_ddd |=_fcd ._cfb >>_fcdb ;_fcd ._cfb &=1<<_fcdb -1;return _ddd ,nil ;};func (_bf *BufferedWriter )Len ()int {return _bf .byteCapacity ()};func (_afa *SubstreamReader )fillBuffer ()error {if uint64 (_afa ._afe .StreamPosition ())!=_afa ._fab +_afa ._gdg {_ ,_gdf :=_afa ._afe .Seek (int64 (_afa ._fab +_afa ._gdg ),_f .SeekStart );
if _gdf !=nil {return _gdf ;};};_afa ._edff =_afa ._fab ;_gfc :=_daa (uint64 (len (_afa ._bag )),_afa ._cge -_afa ._fab );_aeb :=make ([]byte ,_gfc );_ce ,_dce :=_afa ._afe .Read (_aeb );if _dce !=nil {return _dce ;};for _dbgb :=uint64 (0);_dbgb < _gfc ;
_dbgb ++{_afa ._bag [_dbgb ]=_aeb [_dbgb ];};_afa ._df =_afa ._edff +uint64 (_ce );return nil ;};func (_egg *SubstreamReader )ReadBits (n byte )(_gde uint64 ,_ccc error ){if n < _egg ._gbc {_fea :=_egg ._gbc -n ;_gde =uint64 (_egg ._cfb >>_fea );_egg ._cfb &=1<<_fea -1;
_egg ._gbc =_fea ;return _gde ,nil ;};if n > _egg ._gbc {if _egg ._gbc > 0{_gde =uint64 (_egg ._cfb );n -=_egg ._gbc ;};var _aag byte ;for n >=8{_aag ,_ccc =_egg .readBufferByte ();if _ccc !=nil {return 0,_ccc ;};_gde =_gde <<8+uint64 (_aag );n -=8;};if n > 0{if _egg ._cfb ,_ccc =_egg .readBufferByte ();
_ccc !=nil {return 0,_ccc ;};_efg :=8-n ;_gde =_gde <<n +uint64 (_egg ._cfb >>_efg );_egg ._cfb &=1<<_efg -1;_egg ._gbc =_efg ;}else {_egg ._gbc =0;};return _gde ,nil ;};_egg ._gbc =0;return uint64 (_egg ._cfb ),nil ;};func (_fae *SubstreamReader )StreamPosition ()int64 {return int64 (_fae ._fab )};
func (_aa *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;};_ec :=int (_aa ._gbf )+skip ;if _ec >=0&&_ec < 8{_aa ._gbf =uint8 (_ec );return nil ;};_ec =int (_aa ._gbf )+_aa ._abc *8+skip ;if _ec < 0{return _fc .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_ca :=_ec /8;_eb :=_ec %8;_aa ._gbf =uint8 (_eb );if _fe :=_ca -_aa ._abc ;_fe > 0&&len (_aa ._ge )-1< _ca {if _aa ._gbf !=0{_fe ++;};_aa .expandIfNeeded (_fe );};_aa ._abc =_ca ;return nil ;};func (_age *Writer )byteCapacity ()int {_dee :=len (_age ._adb )-_age ._eeg ;
if _age ._eggb !=0{_dee --;};return _dee ;};func NewWriterMSB (data []byte )*Writer {return &Writer {_adb :data ,_dgg :true }};func (_ffb *Reader )Length ()uint64 {return uint64 (len (_ffb ._egc ))};func (_fac *Reader )ReadBit ()(_fb int ,_ac error ){_def ,_ac :=_fac .readBool ();
if _ac !=nil {return 0,_ac ;};if _def {_fb =1;};return _fb ,nil ;};func (_cdgc *Writer )WriteByte (c byte )error {return _cdgc .writeByte (c )};func (_dac *BufferedWriter )Reset (){_dac ._ge =_dac ._ge [:0];_dac ._abc =0;_dac ._gbf =0};func (_aab *BufferedWriter )writeFullBytes (_fcf []byte )int {_eec :=copy (_aab ._ge [_aab .fullOffset ():],_fcf );
_aab ._abc +=_eec ;return _eec ;};func (_abb *BufferedWriter )WriteBits (bits uint64 ,number int )(_ebb int ,_ag error ){const _dd ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";
if number < 0||number > 64{return 0,_fc .Errorf (_dd ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};_fef :=number /8;if _fef > 0{_eg :=number -_fef *8;for _ad :=_fef -1;_ad >=0;_ad --{_ff :=byte ((bits >>uint (_ad *8+_eg ))&0xff);if _ag =_abb .WriteByte (_ff );_ag !=nil {return _ebb ,_fc .Wrapf (_ag ,_dd ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_fef -_ad +1);
};};number -=_fef *8;if number ==0{return _fef ,nil ;};};var _ece int ;for _fa :=0;_fa < number ;_fa ++{if _abb ._d {_ece =int ((bits >>uint (number -1-_fa ))&0x1);}else {_ece =int (bits &0x1);bits >>=1;};if _ag =_abb .WriteBit (_ece );_ag !=nil {return _ebb ,_fc .Wrapf (_ag ,_dd ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_fa );
};};return _fef ,nil ;};var _ BinaryWriter =&BufferedWriter {};func (_cdf *SubstreamReader )Offset ()uint64 {return _cdf ._gdg };type BitWriter interface{WriteBit (_faf int )error ;WriteBits (_egb uint64 ,_eaf int )(_caf int ,_geg error );FinishByte ();
SkipBits (_ecc int )error ;};func (_bec *Reader )Align ()(_bbd byte ){_bbd =_bec ._dbf ;_bec ._dbf =0;return _bbd };func (_aed *SubstreamReader )Seek (offset int64 ,whence int )(int64 ,error ){switch whence {case _f .SeekStart :_aed ._fab =uint64 (offset );
case _f .SeekCurrent :_aed ._fab +=uint64 (offset );case _f .SeekEnd :_aed ._fab =_aed ._cge +uint64 (offset );default:return 0,_a .New ("\u0072\u0065\u0061d\u0065\u0072\u002e\u0053\u0075\u0062\u0073\u0074\u0072\u0065\u0061\u006d\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u0020\u0069\u006e\u0076\u0061\u006ci\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};_aed ._gbc =0;return int64 (_aed ._fab ),nil ;};func (_bc *BufferedWriter )writeByte (_db byte ){switch {case _bc ._gbf ==0:_bc ._ge [_bc ._abc ]=_db ;_bc ._abc ++;case _bc ._d :_bc ._ge [_bc ._abc ]|=_db >>_bc ._gbf ;_bc ._abc ++;_bc ._ge [_bc ._abc ]=byte (uint16 (_db )<<(8-_bc ._gbf )&0xff);
default:_bc ._ge [_bc ._abc ]|=byte (uint16 (_db )<<_bc ._gbf &0xff);_bc ._abc ++;_bc ._ge [_bc ._abc ]=_db >>(8-_bc ._gbf );};};func (_bffg *Writer )Write (p []byte )(int ,error ){if len (p )> _bffg .byteCapacity (){return 0,_f .EOF ;};for _ ,_eea :=range p {if _afb :=_bffg .writeByte (_eea );
_afb !=nil {return 0,_afb ;};};return len (p ),nil ;};var _ BinaryWriter =&Writer {};func (_ggb *Writer )ResetBit (){_ggb ._eggb =0};func (_bd *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _fc .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );
};if len (_bd ._ge )-1< _bd ._abc {_bd .expandIfNeeded (1);};_ae :=_bd ._gbf ;if _bd ._d {_ae =7-_bd ._gbf ;};_bd ._ge [_bd ._abc ]|=byte (uint16 (bit <<_ae )&0xff);_bd ._gbf ++;if _bd ._gbf ==8{_bd ._abc ++;_bd ._gbf =0;};return nil ;};func (_ege *Reader )BitPosition ()int {return int (_ege ._dbf )};
func (_eeb *Reader )Reset (){_eeb ._dcg =_eeb ._dcc ;_eeb ._dbf =_eeb ._fgf };func (_feag *Writer )writeBit (_aac uint8 )error {if len (_feag ._adb )-1< _feag ._eeg {return _f .EOF ;};_fad :=_feag ._eggb ;if _feag ._dgg {_fad =7-_feag ._eggb ;};_feag ._adb [_feag ._eeg ]|=byte (uint16 (_aac <<_fad )&0xff);
_feag ._eggb ++;if _feag ._eggb ==8{_feag ._eeg ++;_feag ._eggb =0;};return nil ;};func (_cbd *SubstreamReader )ReadBit ()(_ddc int ,_dfa error ){_cdb ,_dfa :=_cbd .readBool ();if _dfa !=nil {return 0,_dfa ;};if _cdb {_ddc =1;};return _ddc ,nil ;};func (_ea *BufferedWriter )FinishByte (){if _ea ._gbf ==0{return ;
};_ea ._gbf =0;_ea ._abc ++;};func (_fg *BufferedWriter )Write (d []byte )(int ,error ){_fg .expandIfNeeded (len (d ));if _fg ._gbf ==0{return _fg .writeFullBytes (d ),nil ;};return _fg .writeShiftedBytes (d ),nil ;};func (_bgg *Reader )ConsumeRemainingBits (){if _bgg ._dbf !=0{_ ,_bgf :=_bgg .ReadBits (_bgg ._dbf );
if _bgf !=nil {_c .Log .Debug ("\u0043\u006f\u006e\u0073\u0075\u006d\u0065\u0052\u0065\u006da\u0069\u006e\u0069\u0067\u0042\u0069\u0074s\u0020\u0066\u0061\u0069\u006c\u0065\u0064\u003a\u0020\u0025\u0076",_bgf );};};};func (_fba *SubstreamReader )ReadBool ()(bool ,error ){return _fba .readBool ()};
func (_ef *BufferedWriter )ResetBitIndex (){_ef ._gbf =0};var (_ _f .Reader =&Reader {};_ _f .ByteReader =&Reader {};_ _f .Seeker =&Reader {};_ StreamReader =&Reader {};);