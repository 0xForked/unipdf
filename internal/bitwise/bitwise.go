//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_bb "encoding/binary";_d "errors";_fd "github.com/unidoc/unipdf/v3/common";_e "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_b "io";);func (_g *BufferedWriter )Write (d []byte )(int ,error ){_g .expandIfNeeded (len (d ));
if _g ._ab ==0{return _g .writeFullBytes (d ),nil ;};return _g .writeShiftedBytes (d ),nil ;};var (_ _b .Reader =&Reader {};_ _b .ByteReader =&Reader {};_ _b .Seeker =&Reader {};_ StreamReader =&Reader {};);func (_gcg *BufferedWriter )tryGrowByReslice (_bca int )bool {if _agg :=len (_gcg ._eg );
_bca <=cap (_gcg ._eg )-_agg {_gcg ._eg =_gcg ._eg [:_agg +_bca ];return true ;};return false ;};func (_dbe *Reader )ReadBit ()(_dd int ,_bbfb error ){_ced ,_bbfb :=_dbe .readBool ();if _bbfb !=nil {return 0,_bbfb ;};if _ced {_dd =1;};return _dd ,nil ;
};func (_ae *BufferedWriter )FinishByte (){if _ae ._ab ==0{return ;};_ae ._ab =0;_ae ._fe ++;};func (_gdc *Reader )readBool ()(_ega bool ,_aggc error ){if _gdc ._dcc ==0{_gdc ._bad ,_aggc =_gdc .readBufferByte ();if _aggc !=nil {return false ,_aggc ;};
_ega =(_gdc ._bad &0x80)!=0;_gdc ._bad ,_gdc ._dcc =_gdc ._bad &0x7f,7;return _ega ,nil ;};_gdc ._dcc --;_ega =(_gdc ._bad &(1<<_gdc ._dcc ))!=0;_gdc ._bad &=1<<_gdc ._dcc -1;return _ega ,nil ;};func (_gdeb *Writer )WriteBits (bits uint64 ,number int )(_fda int ,_befg error ){const _afa ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";
if number < 0||number > 64{return 0,_e .Errorf (_afa ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};if number ==0{return 0,nil ;};_adbd :=number /8;if _adbd > 0{_aga :=number -_adbd *8;for _cfd :=_adbd -1;_cfd >=0;_cfd --{_cgd :=byte ((bits >>uint (_cfd *8+_aga ))&0xff);if _befg =_gdeb .WriteByte (_cgd );_befg !=nil {return _fda ,_e .Wrapf (_befg ,_afa ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_adbd -_cfd +1);
};};number -=_adbd *8;if number ==0{return _adbd ,nil ;};};var _ece int ;for _adag :=0;_adag < number ;_adag ++{if _gdeb ._gda {_ece =int ((bits >>uint (number -1-_adag ))&0x1);}else {_ece =int (bits &0x1);bits >>=1;};if _befg =_gdeb .WriteBit (_ece );
_befg !=nil {return _fda ,_e .Wrapf (_befg ,_afa ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_adag );};};return _adbd ,nil ;};type BinaryWriter interface{BitWriter ;_b .Writer ;_b .ByteWriter ;Data ()[]byte ;};func (_gc *BufferedWriter )WriteByte (bt byte )error {if _gc ._fe > len (_gc ._eg )-1||(_gc ._fe ==len (_gc ._eg )-1&&_gc ._ab !=0){_gc .expandIfNeeded (1);
};_gc .writeByte (bt );return nil ;};func (_fgg *SubstreamReader )Offset ()uint64 {return _fgg ._dae };func (_gd *BufferedWriter )expandIfNeeded (_bgd int ){if !_gd .tryGrowByReslice (_bgd ){_gd .grow (_bgd );};};func (_de *Reader )Align ()(_cga byte ){_cga =_de ._dcc ;
_de ._dcc =0;return _cga };func (_ffa *Writer )Data ()[]byte {return _ffa ._bgg };func (_c *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _e .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );
};if len (_c ._eg )-1< _c ._fe {_c .expandIfNeeded (1);};_cb :=_c ._ab ;if _c ._da {_cb =7-_c ._ab ;};_c ._eg [_c ._fe ]|=byte (uint16 (bit <<_cb )&0xff);_c ._ab ++;if _c ._ab ==8{_c ._fe ++;_c ._ab =0;};return nil ;};func (_fdcd *Reader )read (_ggf []byte )(int ,error ){if _fdcd ._aag >=int64 (len (_fdcd ._fdc )){return 0,_b .EOF ;
};_fdcd ._gea =-1;_eec :=copy (_ggf ,_fdcd ._fdc [_fdcd ._aag :]);_fdcd ._aag +=int64 (_eec );return _eec ,nil ;};func (_edc *Reader )ConsumeRemainingBits (){if _edc ._dcc !=0{_ ,_fea :=_edc .ReadBits (_edc ._dcc );if _fea !=nil {_fd .Log .Debug ("\u0043\u006f\u006e\u0073\u0075\u006d\u0065\u0052\u0065\u006da\u0069\u006e\u0069\u0067\u0042\u0069\u0074s\u0020\u0066\u0061\u0069\u006c\u0065\u0064\u003a\u0020\u0025\u0076",_fea );
};};};func (_gf *Reader )Reset (){_gf ._aag =_gf ._cce ;_gf ._dcc =_gf ._bdc };func (_fab *Reader )ReadBits (n byte )(_efa uint64 ,_gdb error ){if n < _fab ._dcc {_af :=_fab ._dcc -n ;_efa =uint64 (_fab ._bad >>_af );_fab ._bad &=1<<_af -1;_fab ._dcc =_af ;
return _efa ,nil ;};if n > _fab ._dcc {if _fab ._dcc > 0{_efa =uint64 (_fab ._bad );n -=_fab ._dcc ;};for n >=8{_bdd ,_gg :=_fab .readBufferByte ();if _gg !=nil {return 0,_gg ;};_efa =_efa <<8+uint64 (_bdd );n -=8;};if n > 0{if _fab ._bad ,_gdb =_fab .readBufferByte ();
_gdb !=nil {return 0,_gdb ;};_acf :=8-n ;_efa =_efa <<n +uint64 (_fab ._bad >>_acf );_fab ._bad &=1<<_acf -1;_fab ._dcc =_acf ;}else {_fab ._dcc =0;};return _efa ,nil ;};_fab ._dcc =0;return uint64 (_fab ._bad ),nil ;};func (_bd *BufferedWriter )writeFullBytes (_fdb []byte )int {_fdd :=copy (_bd ._eg [_bd .fullOffset ():],_fdb );
_bd ._fe +=_fdd ;return _fdd ;};func (_ff *BufferedWriter )Reset (){_ff ._eg =_ff ._eg [:0];_ff ._fe =0;_ff ._ab =0};func (_dgf *Writer )Write (p []byte )(int ,error ){if len (p )> _dgf .byteCapacity (){return 0,_b .EOF ;};for _ ,_dgca :=range p {if _cfa :=_dgf .writeByte (_dgca );
_cfa !=nil {return 0,_cfa ;};};return len (p ),nil ;};func (_aacg *SubstreamReader )Align ()(_gfc byte ){_gfc =_aacg ._bag ;_aacg ._bag =0;return _gfc };var _ BinaryWriter =&BufferedWriter {};func (_bbe *SubstreamReader )StreamPosition ()int64 {return int64 (_bbe ._dec )};
func (_eef *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_eef ._gea =-1;var _bbad int64 ;switch whence {case _b .SeekStart :_bbad =offset ;case _b .SeekCurrent :_bbad =_eef ._aag +offset ;case _b .SeekEnd :_bbad =int64 (len (_eef ._fdc ))+offset ;
default:return 0,_d .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");};if _bbad < 0{return 0,_d .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");
};_eef ._aag =_bbad ;_eef ._dcc =0;return _bbad ,nil ;};var _ _b .Writer =&BufferedWriter {};func (_cd *Reader )ReadByte ()(byte ,error ){if _cd ._dcc ==0{return _cd .readBufferByte ();};return _cd .readUnalignedByte ();};func (_ded *Writer )writeByte (_fga byte )error {if _ded ._bec > len (_ded ._bgg )-1{return _b .EOF ;
};if _ded ._bec ==len (_ded ._bgg )-1&&_ded ._daa !=0{return _b .EOF ;};if _ded ._daa ==0{_ded ._bgg [_ded ._bec ]=_fga ;_ded ._bec ++;return nil ;};if _ded ._gda {_ded ._bgg [_ded ._bec ]|=_fga >>_ded ._daa ;_ded ._bec ++;_ded ._bgg [_ded ._bec ]=byte (uint16 (_fga )<<(8-_ded ._daa )&0xff);
}else {_ded ._bgg [_ded ._bec ]|=byte (uint16 (_fga )<<_ded ._daa &0xff);_ded ._bec ++;_ded ._bgg [_ded ._bec ]=_fga >>(8-_ded ._daa );};return nil ;};func (_cgf *SubstreamReader )ReadBit ()(_eecg int ,_cgbc error ){_cfb ,_cgbc :=_cgf .readBool ();if _cgbc !=nil {return 0,_cgbc ;
};if _cfb {_eecg =1;};return _eecg ,nil ;};func (_adb *SubstreamReader )Seek (offset int64 ,whence int )(int64 ,error ){switch whence {case _b .SeekStart :_adb ._dec =uint64 (offset );case _b .SeekCurrent :_adb ._dec +=uint64 (offset );case _b .SeekEnd :_adb ._dec =_adb ._fcc +uint64 (offset );
default:return 0,_d .New ("\u0072\u0065\u0061d\u0065\u0072\u002e\u0053\u0075\u0062\u0073\u0074\u0072\u0065\u0061\u006d\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u0020\u0069\u006e\u0076\u0061\u006ci\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};_adb ._bag =0;return int64 (_adb ._dec ),nil ;};func (_gab *BufferedWriter )grow (_dcd int ){if _gab ._eg ==nil &&_dcd < _a {_gab ._eg =make ([]byte ,_dcd ,_a );return ;};_be :=len (_gab ._eg );if _gab ._ab !=0{_be ++;};_cgb :=cap (_gab ._eg );switch {case _dcd <=_cgb /2-_be :_fd .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_gab ._eg ),cap (_gab ._eg ),_dcd );
_fd .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_cgb ,_be );copy (_gab ._eg ,_gab ._eg [_gab .fullOffset ():]);
case _cgb > _bba -_cgb -_dcd :_fd .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_ge :=make ([]byte ,2*_cgb +_dcd );copy (_ge ,_gab ._eg );_gab ._eg =_ge ;};_gab ._eg =_gab ._eg [:_be +_dcd ];
};type SubstreamReader struct{_dec uint64 ;_acc StreamReader ;_dae uint64 ;_fcc uint64 ;_bab []byte ;_ggfa uint64 ;_cbb uint64 ;_gde byte ;_bag byte ;_aac uint64 ;_dgg byte ;};type StreamReader interface{_b .Reader ;_b .ByteReader ;_b .Seeker ;Align ()byte ;
BitPosition ()int ;Mark ();Length ()uint64 ;ReadBit ()(int ,error );ReadBits (_bgb byte )(uint64 ,error );ReadBool ()(bool ,error );ReadUint32 ()(uint32 ,error );Reset ();StreamPosition ()int64 ;};func (_bc *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;
};_ed :=int (_bc ._ab )+skip ;if _ed >=0&&_ed < 8{_bc ._ab =uint8 (_ed );return nil ;};_ed =int (_bc ._ab )+_bc ._fe *8+skip ;if _ed < 0{return _e .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_ea :=_ed /8;_dba :=_ed %8;_bc ._ab =uint8 (_dba );if _ad :=_ea -_bc ._fe ;_ad > 0&&len (_bc ._eg )-1< _ea {if _bc ._ab !=0{_ad ++;};_bc .expandIfNeeded (_ad );};_bc ._fe =_ea ;return nil ;};func (_dc *BufferedWriter )ResetBitIndex (){_dc ._ab =0};func (_cee *Reader )Read (p []byte )(_gcf int ,_bce error ){if _cee ._dcc ==0{return _cee .read (p );
};for ;_gcf < len (p );_gcf ++{if p [_gcf ],_bce =_cee .readUnalignedByte ();_bce !=nil {return 0,_bce ;};};return _gcf ,nil ;};const (_a =64;_bba =int (^uint (0)>>1););func (_fee *Writer )UseMSB ()bool {return _fee ._gda };func (_egf *Reader )ReadUint32 ()(uint32 ,error ){_dbc :=make ([]byte ,4);
_ ,_bbb :=_egf .Read (_dbc );if _bbb !=nil {return 0,_bbb ;};return _bb .BigEndian .Uint32 (_dbc ),nil ;};func (_bf *BufferedWriter )Data ()[]byte {return _bf ._eg };func (_bdb *Writer )WriteByte (c byte )error {return _bdb .writeByte (c )};func (_dcf *BufferedWriter )writeShiftedBytes (_cf []byte )int {for _ ,_gaa :=range _cf {_dcf .writeByte (_gaa );
};return len (_cf );};type BitWriter interface{WriteBit (_fg int )error ;WriteBits (_fdbc uint64 ,_ca int )(_geg int ,_aa error );FinishByte ();SkipBits (_ce int )error ;};func (_ef *Reader )BitPosition ()int {return int (_ef ._dcc )};func (_gcd *BufferedWriter )WriteBits (bits uint64 ,number int )(_bg int ,_fa error ){const _cc ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";
if number < 0||number > 64{return 0,_e .Errorf (_cc ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};_ac :=number /8;if _ac > 0{_ada :=number -_ac *8;for _dg :=_ac -1;_dg >=0;_dg --{_fec :=byte ((bits >>uint (_dg *8+_ada ))&0xff);if _fa =_gcd .WriteByte (_fec );_fa !=nil {return _bg ,_e .Wrapf (_fa ,_cc ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_ac -_dg +1);
};};number -=_ac *8;if number ==0{return _ac ,nil ;};};var _abc int ;for _fb :=0;_fb < number ;_fb ++{if _gcd ._da {_abc =int ((bits >>uint (number -1-_fb ))&0x1);}else {_abc =int (bits &0x1);bits >>=1;};if _fa =_gcd .WriteBit (_abc );_fa !=nil {return _bg ,_e .Wrapf (_fa ,_cc ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_fb );
};};return _ac ,nil ;};func (_bcf *BufferedWriter )byteCapacity ()int {_eac :=len (_bcf ._eg )-_bcf ._fe ;if _bcf ._ab !=0{_eac --;};return _eac ;};func (_befa *Writer )writeBit (_bgbd uint8 )error {if len (_befa ._bgg )-1< _befa ._bec {return _b .EOF ;
};_abd :=_befa ._daa ;if _befa ._gda {_abd =7-_befa ._daa ;};_befa ._bgg [_befa ._bec ]|=byte (uint16 (_bgbd <<_abd )&0xff);_befa ._daa ++;if _befa ._daa ==8{_befa ._bec ++;_befa ._daa =0;};return nil ;};func (_ffg *Writer )ResetBit (){_ffg ._daa =0};var _ _b .ByteWriter =&BufferedWriter {};
type Reader struct{_fdc []byte ;_bad byte ;_dcc byte ;_aag int64 ;_ee int ;_gea int ;_cce int64 ;_bdc byte ;};func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_da :true }};func (_ecb *SubstreamReader )readBool ()(_cede bool ,_cgaa error ){if _ecb ._bag ==0{_ecb ._gde ,_cgaa =_ecb .readBufferByte ();
if _cgaa !=nil {return false ,_cgaa ;};_cede =(_ecb ._gde &0x80)!=0;_ecb ._gde ,_ecb ._bag =_ecb ._gde &0x7f,7;return _cede ,nil ;};_ecb ._bag --;_cede =(_ecb ._gde &(1<<_ecb ._bag ))!=0;_ecb ._gde &=1<<_ecb ._bag -1;return _cede ,nil ;};func (_efb *Reader )readBufferByte ()(byte ,error ){if _efb ._aag >=int64 (len (_efb ._fdc )){return 0,_b .EOF ;
};_efb ._gea =-1;_bfe :=_efb ._fdc [_efb ._aag ];_efb ._aag ++;_efb ._ee =int (_bfe );return _bfe ,nil ;};func (_bde *SubstreamReader )BitPosition ()int {return int (_bde ._bag )};func (_gbc *Writer )FinishByte (){if _gbc ._daa ==0{return ;};_gbc ._daa =0;
_gbc ._bec ++;};func (_fcf *SubstreamReader )ReadByte ()(byte ,error ){if _fcf ._bag ==0{return _fcf .readBufferByte ();};return _fcf .readUnalignedByte ();};type BufferedWriter struct{_eg []byte ;_ab uint8 ;_fe int ;_da bool ;};func (_bff *Reader )Mark (){_bff ._cce =_bff ._aag ;
_bff ._bdc =_bff ._dcc };func (_fef *SubstreamReader )Reset (){_fef ._dec =_fef ._aac ;_fef ._bag =_fef ._dgg };func (_ede *SubstreamReader )ReadUint32 ()(uint32 ,error ){_ade :=make ([]byte ,4);_ ,_ddb :=_ede .Read (_ade );if _ddb !=nil {return 0,_ddb ;
};return _bb .BigEndian .Uint32 (_ade ),nil ;};func (_agf *SubstreamReader )readUnalignedByte ()(_cfe byte ,_bagg error ){_adac :=_agf ._bag ;_cfe =_agf ._gde <<(8-_adac );_agf ._gde ,_bagg =_agf .readBufferByte ();if _bagg !=nil {return 0,_bagg ;};_cfe |=_agf ._gde >>_adac ;
_agf ._gde &=1<<_adac -1;return _cfe ,nil ;};func (_ebf *SubstreamReader )readBufferByte ()(byte ,error ){if _ebf ._dec >=_ebf ._fcc {return 0,_b .EOF ;};if _ebf ._dec >=_ebf ._cbb ||_ebf ._dec < _ebf ._ggfa {if _df :=_ebf .fillBuffer ();_df !=nil {return 0,_df ;
};};_aef :=_ebf ._bab [_ebf ._dec -_ebf ._ggfa ];_ebf ._dec ++;return _aef ,nil ;};func NewWriterMSB (data []byte )*Writer {return &Writer {_bgg :data ,_gda :true }};func (_aae *Writer )SkipBits (skip int )error {const _fgc ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";
if skip ==0{return nil ;};_fccd :=int (_aae ._daa )+skip ;if _fccd >=0&&_fccd < 8{_aae ._daa =uint8 (_fccd );return nil ;};_fccd =int (_aae ._daa )+_aae ._bec *8+skip ;if _fccd < 0{return _e .Errorf (_fgc ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_adf :=_fccd /8;_cgee :=_fccd %8;_fd .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");_fd .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_aae ._daa ,_aae ._bec ,int (_aae ._daa )+(_aae ._bec )*8,len (_aae ._bgg ),cap (_aae ._bgg ));
_fd .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_fccd ,_cgee );_aae ._daa =uint8 (_cgee );
if _gac :=_adf -_aae ._bec ;_gac > 0&&len (_aae ._bgg )-1< _adf {_fd .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_gac );return _e .Errorf (_fgc ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_aae ._bec =_adf ;_fd .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_aae ._daa ,_aae ._bec );return nil ;};func (_aea *SubstreamReader )Length ()uint64 {return _aea ._fcc };
var _ BinaryWriter =&Writer {};func (_cg *BufferedWriter )fullOffset ()int {_faa :=_cg ._fe ;if _cg ._ab !=0{_faa ++;};return _faa ;};type Writer struct{_bgg []byte ;_daa uint8 ;_bec int ;_gda bool ;};func (_ddd *SubstreamReader )Mark (){_ddd ._aac =_ddd ._dec ;
_ddd ._dgg =_ddd ._bag };func (_db *BufferedWriter )Len ()int {return _db .byteCapacity ()};func (_ba *BufferedWriter )writeByte (_ag byte ){switch {case _ba ._ab ==0:_ba ._eg [_ba ._fe ]=_ag ;_ba ._fe ++;case _ba ._da :_ba ._eg [_ba ._fe ]|=_ag >>_ba ._ab ;
_ba ._fe ++;_ba ._eg [_ba ._fe ]=byte (uint16 (_ag )<<(8-_ba ._ab )&0xff);default:_ba ._eg [_ba ._fe ]|=byte (uint16 (_ag )<<_ba ._ab &0xff);_ba ._fe ++;_ba ._eg [_ba ._fe ]=_ag >>(8-_ba ._ab );};};func (_cea *SubstreamReader )ReadBool ()(bool ,error ){return _cea .readBool ()};
func NewReader (data []byte )*Reader {return &Reader {_fdc :data }};func NewWriter (data []byte )*Writer {return &Writer {_bgg :data }};func (_fc *Reader )StreamPosition ()int64 {return _fc ._aag };func (_bcfa *Writer )byteCapacity ()int {_cgbb :=len (_bcfa ._bgg )-_bcfa ._bec ;
if _bcfa ._daa !=0{_cgbb --;};return _cgbb ;};func _fca (_gb ,_cdf uint64 )uint64 {if _gb < _cdf {return _gb ;};return _cdf ;};func (_aec *SubstreamReader )fillBuffer ()error {if uint64 (_aec ._acc .StreamPosition ())!=_aec ._dec +_aec ._dae {_ ,_cbeb :=_aec ._acc .Seek (int64 (_aec ._dec +_aec ._dae ),_b .SeekStart );
if _cbeb !=nil {return _cbeb ;};};_aec ._ggfa =_aec ._dec ;_adc :=_fca (uint64 (len (_aec ._bab )),_aec ._fcc -_aec ._dec );_ddg :=make ([]byte ,_adc );_eab ,_eea :=_aec ._acc .Read (_ddg );if _eea !=nil {return _eea ;};for _dcfa :=uint64 (0);_dcfa < _adc ;
_dcfa ++{_aec ._bab [_dcfa ]=_ddg [_dcfa ];};_aec ._cbb =_aec ._ggfa +uint64 (_eab );return nil ;};func (_ddf *Reader )readUnalignedByte ()(_ec byte ,_edg error ){_ebd :=_ddf ._dcc ;_ec =_ddf ._bad <<(8-_ebd );_ddf ._bad ,_edg =_ddf .readBufferByte ();
if _edg !=nil {return 0,_edg ;};_ec |=_ddf ._bad >>_ebd ;_ddf ._bad &=1<<_ebd -1;return _ec ,nil ;};func (_bfed *SubstreamReader )Read (b []byte )(_cff int ,_bfb error ){if _bfed ._dec >=_bfed ._fcc {_fd .Log .Trace ("\u0053\u0074\u0072e\u0061\u006d\u0050\u006fs\u003a\u0020\u0027\u0025\u0064\u0027\u0020>\u003d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027",_bfed ._dec ,_bfed ._fcc );
return 0,_b .EOF ;};for ;_cff < len (b );_cff ++{if b [_cff ],_bfb =_bfed .readUnalignedByte ();_bfb !=nil {if _bfb ==_b .EOF {return _cff ,nil ;};return 0,_bfb ;};};return _cff ,nil ;};func NewSubstreamReader (r StreamReader ,offset ,length uint64 )(*SubstreamReader ,error ){if r ==nil {return nil ,_d .New ("\u0072o\u006ft\u0020\u0072\u0065\u0061\u0064e\u0072\u0020i\u0073\u0020\u006e\u0069\u006c");
};_fd .Log .Trace ("\u004e\u0065\u0077\u0053\u0075\u0062\u0073\u0074r\u0065\u0061\u006dRe\u0061\u0064\u0065\u0072\u0020\u0061t\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u003a\u0020\u0025\u0064\u0020\u0077\u0069\u0074h\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a \u0025\u0064",offset ,length );
return &SubstreamReader {_acc :r ,_dae :offset ,_fcc :length ,_bab :make ([]byte ,length )},nil ;};func (_eed *SubstreamReader )ReadBits (n byte )(_cbe uint64 ,_bcab error ){if n < _eed ._bag {_bef :=_eed ._bag -n ;_cbe =uint64 (_eed ._gde >>_bef );_eed ._gde &=1<<_bef -1;
_eed ._bag =_bef ;return _cbe ,nil ;};if n > _eed ._bag {if _eed ._bag > 0{_cbe =uint64 (_eed ._gde );n -=_eed ._bag ;};var _bee byte ;for n >=8{_bee ,_bcab =_eed .readBufferByte ();if _bcab !=nil {return 0,_bcab ;};_cbe =_cbe <<8+uint64 (_bee );n -=8;
};if n > 0{if _eed ._gde ,_bcab =_eed .readBufferByte ();_bcab !=nil {return 0,_bcab ;};_cgg :=8-n ;_cbe =_cbe <<n +uint64 (_eed ._gde >>_cgg );_eed ._gde &=1<<_cgg -1;_eed ._bag =_cgg ;}else {_eed ._bag =0;};return _cbe ,nil ;};_eed ._bag =0;return uint64 (_eed ._gde ),nil ;
};func (_ffb *Reader )Length ()uint64 {return uint64 (len (_ffb ._fdc ))};func (_ebg *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _ebg .writeBit (uint8 (bit ));};return _e .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");
};func (_fdbcg *Reader )ReadBool ()(bool ,error ){return _fdbcg .readBool ()};