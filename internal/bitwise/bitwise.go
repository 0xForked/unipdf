//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_a "encoding/binary";_d "errors";_fd "github.com/unidoc/unipdf/v3/common";_dg "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_b "io";);func (_cda *Reader )ReadBool ()(bool ,error ){return _cda .readBool ()};func (_gg *BufferedWriter )Write (d []byte )(int ,error ){_gg .expandIfNeeded (len (d ));
if _gg ._g ==0{return _gg .writeFullBytes (d ),nil ;};return _gg .writeShiftedBytes (d ),nil ;};func (_ce *BufferedWriter )byteCapacity ()int {_ebd :=len (_ce ._da )-_ce ._be ;if _ce ._g !=0{_ebd --;};return _ebd ;};func (_cef *Reader )ReadUint32 ()(uint32 ,error ){_bca :=make ([]byte ,4);
_ ,_aed :=_cef .Read (_bca );if _aed !=nil {return 0,_aed ;};return _a .BigEndian .Uint32 (_bca ),nil ;};func (_degf *Reader )Align ()(_ad byte ){_ad =_degf ._deg ;_degf ._deg =0;return _ad };func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_ab :true }};
func (_bfc *Reader )ReadByte ()(byte ,error ){if _bfc ._deg ==0{return _bfc .readBufferByte ();};return _bfc .readUnalignedByte ();};func (_deb *BufferedWriter )grow (_dac int ){if _deb ._da ==nil &&_dac < _c {_deb ._da =make ([]byte ,_dac ,_c );return ;
};_fb :=len (_deb ._da );if _deb ._g !=0{_fb ++;};_bd :=cap (_deb ._da );switch {case _dac <=_bd /2-_fb :_fd .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_deb ._da ),cap (_deb ._da ),_dac );
_fd .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_bd ,_fb );copy (_deb ._da ,_deb ._da [_deb .fullOffset ():]);
case _bd > _ag -_bd -_dac :_fd .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_ae :=make ([]byte ,2*_bd +_dac );copy (_ae ,_deb ._da );_deb ._da =_ae ;};_deb ._da =_deb ._da [:_fb +_dac ];
};func (_edf *SubstreamReader )ReadBool ()(bool ,error ){return _edf .readBool ()};type SubstreamReader struct{_cgg uint64 ;_dde StreamReader ;_fag uint64 ;_ebbg uint64 ;_cgbg []byte ;_ggg uint64 ;_dfa uint64 ;_bebc byte ;_bad byte ;_dacg uint64 ;_gbg byte ;
};type BinaryWriter interface{BitWriter ;_b .Writer ;_b .ByteWriter ;Data ()[]byte ;};func NewReader (data []byte )*Reader {return &Reader {_fbg :data }};func (_ecd *SubstreamReader )readUnalignedByte ()(_fgb byte ,_efg error ){_cae :=_ecd ._bad ;_fgb =_ecd ._bebc <<(8-_cae );
_ecd ._bebc ,_efg =_ecd .readBufferByte ();if _efg !=nil {return 0,_efg ;};_fgb |=_ecd ._bebc >>_cae ;_ecd ._bebc &=1<<_cae -1;return _fgb ,nil ;};func (_abfg *SubstreamReader )ReadBits (n byte )(_aef uint64 ,_ggc error ){if n < _abfg ._bad {_fgd :=_abfg ._bad -n ;
_aef =uint64 (_abfg ._bebc >>_fgd );_abfg ._bebc &=1<<_fgd -1;_abfg ._bad =_fgd ;return _aef ,nil ;};if n > _abfg ._bad {if _abfg ._bad > 0{_aef =uint64 (_abfg ._bebc );n -=_abfg ._bad ;};var _bfae byte ;for n >=8{_bfae ,_ggc =_abfg .readBufferByte ();
if _ggc !=nil {return 0,_ggc ;};_aef =_aef <<8+uint64 (_bfae );n -=8;};if n > 0{if _abfg ._bebc ,_ggc =_abfg .readBufferByte ();_ggc !=nil {return 0,_ggc ;};_ccd :=8-n ;_aef =_aef <<n +uint64 (_abfg ._bebc >>_ccd );_abfg ._bebc &=1<<_ccd -1;_abfg ._bad =_ccd ;
}else {_abfg ._bad =0;};return _aef ,nil ;};_abfg ._bad =0;return uint64 (_abfg ._bebc ),nil ;};func (_agc *SubstreamReader )ReadByte ()(byte ,error ){if _agc ._bad ==0{return _agc .readBufferByte ();};return _agc .readUnalignedByte ();};func (_bdb *SubstreamReader )Read (b []byte )(_dege int ,_bba error ){if _bdb ._cgg >=_bdb ._ebbg {_fd .Log .Trace ("\u0053\u0074\u0072e\u0061\u006d\u0050\u006fs\u003a\u0020\u0027\u0025\u0064\u0027\u0020>\u003d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027",_bdb ._cgg ,_bdb ._ebbg );
return 0,_b .EOF ;};for ;_dege < len (b );_dege ++{if b [_dege ],_bba =_bdb .readUnalignedByte ();_bba !=nil {if _bba ==_b .EOF {return _dege ,nil ;};return 0,_bba ;};};return _dege ,nil ;};func (_fgg *BufferedWriter )writeFullBytes (_cf []byte )int {_ba :=copy (_fgg ._da [_fgg .fullOffset ():],_cf );
_fgg ._be +=_ba ;return _ba ;};func (_bb *BufferedWriter )Data ()[]byte {return _bb ._da };func (_dbc *SubstreamReader )Offset ()uint64 {return _dbc ._fag };var _ _b .Writer =&BufferedWriter {};func NewSubstreamReader (r StreamReader ,offset ,length uint64 )(*SubstreamReader ,error ){if r ==nil {return nil ,_d .New ("\u0072o\u006ft\u0020\u0072\u0065\u0061\u0064e\u0072\u0020i\u0073\u0020\u006e\u0069\u006c");
};_fd .Log .Trace ("\u004e\u0065\u0077\u0053\u0075\u0062\u0073\u0074r\u0065\u0061\u006dRe\u0061\u0064\u0065\u0072\u0020\u0061t\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u003a\u0020\u0025\u0064\u0020\u0077\u0069\u0074h\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a \u0025\u0064",offset ,length );
return &SubstreamReader {_dde :r ,_fag :offset ,_ebbg :length ,_cgbg :make ([]byte ,length )},nil ;};func (_gcd *Writer )SkipBits (skip int )error {const _daag ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";if skip ==0{return nil ;
};_acd :=int (_gcd ._dcca )+skip ;if _acd >=0&&_acd < 8{_gcd ._dcca =uint8 (_acd );return nil ;};_acd =int (_gcd ._dcca )+_gcd ._bab *8+skip ;if _acd < 0{return _dg .Errorf (_daag ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_bdc :=_acd /8;_bfcb :=_acd %8;_fd .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");_fd .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_gcd ._dcca ,_gcd ._bab ,int (_gcd ._dcca )+(_gcd ._bab )*8,len (_gcd ._agf ),cap (_gcd ._agf ));
_fd .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_acd ,_bfcb );_gcd ._dcca =uint8 (_bfcb );
if _cac :=_bdc -_gcd ._bab ;_cac > 0&&len (_gcd ._agf )-1< _bdc {_fd .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_cac );return _dg .Errorf (_daag ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_gcd ._bab =_bdc ;_fd .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_gcd ._dcca ,_gcd ._bab );return nil ;};func (_cdc *Writer )byteCapacity ()int {_ece :=len (_cdc ._agf )-_cdc ._bab ;
if _cdc ._dcca !=0{_ece --;};return _ece ;};func (_bf *BufferedWriter )WriteByte (bt byte )error {if _bf ._be > len (_bf ._da )-1||(_bf ._be ==len (_bf ._da )-1&&_bf ._g !=0){_bf .expandIfNeeded (1);};_bf .writeByte (bt );return nil ;};func (_bbfa *SubstreamReader )readBufferByte ()(byte ,error ){if _bbfa ._cgg >=_bbfa ._ebbg {return 0,_b .EOF ;
};if _bbfa ._cgg >=_bbfa ._dfa ||_bbfa ._cgg < _bbfa ._ggg {if _cgcb :=_bbfa .fillBuffer ();_cgcb !=nil {return 0,_cgcb ;};};_bed :=_bbfa ._cgbg [_bbfa ._cgg -_bbfa ._ggg ];_bbfa ._cgg ++;return _bed ,nil ;};func NewWriter (data []byte )*Writer {return &Writer {_agf :data }};
func (_fab *SubstreamReader )Length ()uint64 {return _fab ._ebbg };func (_cfg *SubstreamReader )ReadBit ()(_ffg int ,_dgd error ){_gaa ,_dgd :=_cfg .readBool ();if _dgd !=nil {return 0,_dgd ;};if _gaa {_ffg =1;};return _ffg ,nil ;};func (_dc *BufferedWriter )ResetBitIndex (){_dc ._g =0};
func (_gff *Writer )writeByte (_cgf byte )error {if _gff ._bab > len (_gff ._agf )-1{return _b .EOF ;};if _gff ._bab ==len (_gff ._agf )-1&&_gff ._dcca !=0{return _b .EOF ;};if _gff ._dcca ==0{_gff ._agf [_gff ._bab ]=_cgf ;_gff ._bab ++;return nil ;};
if _gff ._gbd {_gff ._agf [_gff ._bab ]|=_cgf >>_gff ._dcca ;_gff ._bab ++;_gff ._agf [_gff ._bab ]=byte (uint16 (_cgf )<<(8-_gff ._dcca )&0xff);}else {_gff ._agf [_gff ._bab ]|=byte (uint16 (_cgf )<<_gff ._dcca &0xff);_gff ._bab ++;_gff ._agf [_gff ._bab ]=_cgf >>(8-_gff ._dcca );
};return nil ;};func (_ddg *Writer )Write (p []byte )(int ,error ){if len (p )> _ddg .byteCapacity (){return 0,_b .EOF ;};for _ ,_cee :=range p {if _beda :=_ddg .writeByte (_cee );_beda !=nil {return 0,_beda ;};};return len (p ),nil ;};func (_ggf *Reader )Read (p []byte )(_cgc int ,_aadg error ){if _ggf ._deg ==0{return _ggf .read (p );
};for ;_cgc < len (p );_cgc ++{if p [_cgc ],_aadg =_ggf .readUnalignedByte ();_aadg !=nil {return 0,_aadg ;};};return _cgc ,nil ;};func (_ddc *SubstreamReader )Align ()(_aab byte ){_aab =_ddc ._bad ;_ddc ._bad =0;return _aab };func (_ega *Writer )Data ()[]byte {return _ega ._agf };
func (_eg *BufferedWriter )expandIfNeeded (_df int ){if !_eg .tryGrowByReslice (_df ){_eg .grow (_df );};};func (_abg *BufferedWriter )Reset (){_abg ._da =_abg ._da [:0];_abg ._be =0;_abg ._g =0};type Writer struct{_agf []byte ;_dcca uint8 ;_bab int ;_gbd bool ;
};var _ BinaryWriter =&Writer {};func (_ef *SubstreamReader )Seek (offset int64 ,whence int )(int64 ,error ){switch whence {case _b .SeekStart :_ef ._cgg =uint64 (offset );case _b .SeekCurrent :_ef ._cgg +=uint64 (offset );case _b .SeekEnd :_ef ._cgg =_ef ._ebbg +uint64 (offset );
default:return 0,_d .New ("\u0072\u0065\u0061d\u0065\u0072\u002e\u0053\u0075\u0062\u0073\u0074\u0072\u0065\u0061\u006d\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u0020\u0069\u006e\u0076\u0061\u006ci\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};_ef ._bad =0;return int64 (_ef ._cgg ),nil ;};type BitWriter interface{WriteBit (_bbf int )error ;WriteBits (_dfe uint64 ,_bcff int )(_gef int ,_ee error );FinishByte ();SkipBits (_beb int )error ;};func (_cefb *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_cefb ._bde =-1;
var _dace int64 ;switch whence {case _b .SeekStart :_dace =offset ;case _b .SeekCurrent :_dace =_cefb ._cba +offset ;case _b .SeekEnd :_dace =int64 (len (_cefb ._fbg ))+offset ;default:return 0,_d .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};if _dace < 0{return 0,_d .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");};_cefb ._cba =_dace ;
_cefb ._deg =0;return _dace ,nil ;};func _gc (_afd ,_acf uint64 )uint64 {if _afd < _acf {return _afd ;};return _acf ;};func (_bg *Reader )ConsumeRemainingBits (){if _bg ._deg !=0{_ ,_egc :=_bg .ReadBits (_bg ._deg );if _egc !=nil {_fd .Log .Debug ("\u0043\u006f\u006e\u0073\u0075\u006d\u0065\u0052\u0065\u006da\u0069\u006e\u0069\u0067\u0042\u0069\u0074s\u0020\u0066\u0061\u0069\u006c\u0065\u0064\u003a\u0020\u0025\u0076",_egc );
};};};func (_eda *SubstreamReader )StreamPosition ()int64 {return int64 (_eda ._cgg )};func (_dcf *Reader )BitPosition ()int {return int (_dcf ._deg )};var (_ _b .Reader =&Reader {};_ _b .ByteReader =&Reader {};_ _b .Seeker =&Reader {};_ StreamReader =&Reader {};
);func (_aa *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;};_dge :=int (_aa ._g )+skip ;if _dge >=0&&_dge < 8{_aa ._g =uint8 (_dge );return nil ;};_dge =int (_aa ._g )+_aa ._be *8+skip ;if _dge < 0{return _dg .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_ga :=_dge /8;_fg :=_dge %8;_aa ._g =uint8 (_fg );if _ff :=_ga -_aa ._be ;_ff > 0&&len (_aa ._da )-1< _ga {if _aa ._g !=0{_ff ++;};_aa .expandIfNeeded (_ff );};_aa ._be =_ga ;return nil ;};func (_bee *Reader )ReadBits (n byte )(_dd uint64 ,_aaf error ){if n < _bee ._deg {_bfa :=_bee ._deg -n ;
_dd =uint64 (_bee ._bfg >>_bfa );_bee ._bfg &=1<<_bfa -1;_bee ._deg =_bfa ;return _dd ,nil ;};if n > _bee ._deg {if _bee ._deg > 0{_dd =uint64 (_bee ._bfg );n -=_bee ._deg ;};for n >=8{_dgcd ,_afb :=_bee .readBufferByte ();if _afb !=nil {return 0,_afb ;
};_dd =_dd <<8+uint64 (_dgcd );n -=8;};if n > 0{if _bee ._bfg ,_aaf =_bee .readBufferByte ();_aaf !=nil {return 0,_aaf ;};_age :=8-n ;_dd =_dd <<n +uint64 (_bee ._bfg >>_age );_bee ._bfg &=1<<_age -1;_bee ._deg =_age ;}else {_bee ._deg =0;};return _dd ,nil ;
};_bee ._deg =0;return uint64 (_bee ._bfg ),nil ;};func (_cd *Reader )Length ()uint64 {return uint64 (len (_cd ._fbg ))};func (_gac *Writer )FinishByte (){if _gac ._dcca ==0{return ;};_gac ._dcca =0;_gac ._bab ++;};var _ BinaryWriter =&BufferedWriter {};
func (_de *BufferedWriter )FinishByte (){if _de ._g ==0{return ;};_de ._g =0;_de ._be ++;};func (_bag *Writer )UseMSB ()bool {return _bag ._gbd };type BufferedWriter struct{_da []byte ;_g uint8 ;_be int ;_ab bool ;};func (_eb *BufferedWriter )Len ()int {return _eb .byteCapacity ()};
func (_cefe *Writer )WriteByte (c byte )error {return _cefe .writeByte (c )};func (_aad *BufferedWriter )writeByte (_fcf byte ){switch {case _aad ._g ==0:_aad ._da [_aad ._be ]=_fcf ;_aad ._be ++;case _aad ._ab :_aad ._da [_aad ._be ]|=_fcf >>_aad ._g ;
_aad ._be ++;_aad ._da [_aad ._be ]=byte (uint16 (_fcf )<<(8-_aad ._g )&0xff);default:_aad ._da [_aad ._be ]|=byte (uint16 (_fcf )<<_aad ._g &0xff);_aad ._be ++;_aad ._da [_aad ._be ]=_fcf >>(8-_aad ._g );};};func (_bcf *BufferedWriter )fullOffset ()int {_cb :=_bcf ._be ;
if _bcf ._g !=0{_cb ++;};return _cb ;};func (_gdc *Reader )readUnalignedByte ()(_dgb byte ,_edce error ){_eee :=_gdc ._deg ;_dgb =_gdc ._bfg <<(8-_eee );_gdc ._bfg ,_edce =_gdc .readBufferByte ();if _edce !=nil {return 0,_edce ;};_dgb |=_gdc ._bfg >>_eee ;
_gdc ._bfg &=1<<_eee -1;return _dgb ,nil ;};func (_gb *Reader )StreamPosition ()int64 {return _gb ._cba };func (_ea *SubstreamReader )fillBuffer ()error {if uint64 (_ea ._dde .StreamPosition ())!=_ea ._cgg +_ea ._fag {_ ,_debc :=_ea ._dde .Seek (int64 (_ea ._cgg +_ea ._fag ),_b .SeekStart );
if _debc !=nil {return _debc ;};};_ea ._ggg =_ea ._cgg ;_ada :=_gc (uint64 (len (_ea ._cgbg )),_ea ._ebbg -_ea ._cgg );_ffe :=make ([]byte ,_ada );_gea ,_gaf :=_ea ._dde .Read (_ffe );if _gaf !=nil {return _gaf ;};for _cea :=uint64 (0);_cea < _ada ;_cea ++{_ea ._cgbg [_cea ]=_ffe [_cea ];
};_ea ._dfa =_ea ._ggg +uint64 (_gea );return nil ;};func (_gdb *SubstreamReader )readBool ()(_egd bool ,_gdcg error ){if _gdb ._bad ==0{_gdb ._bebc ,_gdcg =_gdb .readBufferByte ();if _gdcg !=nil {return false ,_gdcg ;};_egd =(_gdb ._bebc &0x80)!=0;_gdb ._bebc ,_gdb ._bad =_gdb ._bebc &0x7f,7;
return _egd ,nil ;};_gdb ._bad --;_egd =(_gdb ._bebc &(1<<_gdb ._bad ))!=0;_gdb ._bebc &=1<<_gdb ._bad -1;return _egd ,nil ;};func (_gga *SubstreamReader )Mark (){_gga ._dacg =_gga ._cgg ;_gga ._gbg =_gga ._bad };func NewWriterMSB (data []byte )*Writer {return &Writer {_agf :data ,_gbd :true }};
func (_aff *Writer )writeBit (_eea uint8 )error {if len (_aff ._agf )-1< _aff ._bab {return _b .EOF ;};_bebe :=_aff ._dcca ;if _aff ._gbd {_bebe =7-_aff ._dcca ;};_aff ._agf [_aff ._bab ]|=byte (uint16 (_eea <<_bebe )&0xff);_aff ._dcca ++;if _aff ._dcca ==8{_aff ._bab ++;
_aff ._dcca =0;};return nil ;};func (_fcg *SubstreamReader )ReadUint32 ()(uint32 ,error ){_cbbc :=make ([]byte ,4);_ ,_gda :=_fcg .Read (_cbbc );if _gda !=nil {return 0,_gda ;};return _a .BigEndian .Uint32 (_cbbc ),nil ;};var _ _b .ByteWriter =&BufferedWriter {};
type StreamReader interface{_b .Reader ;_b .ByteReader ;_b .Seeker ;Align ()byte ;BitPosition ()int ;Mark ();Length ()uint64 ;ReadBit ()(int ,error );ReadBits (_ebg byte )(uint64 ,error );ReadBool ()(bool ,error );ReadUint32 ()(uint32 ,error );Reset ();
StreamPosition ()int64 ;};func (_dgg *Reader )Reset (){_dgg ._cba =_dgg ._ccg ;_dgg ._deg =_dgg ._daa };type Reader struct{_fbg []byte ;_bfg byte ;_deg byte ;_cba int64 ;_gd int ;_bde int ;_ccg int64 ;_daa byte ;};func (_dfdc *Reader )readBool ()(_fa bool ,_aec error ){if _dfdc ._deg ==0{_dfdc ._bfg ,_aec =_dfdc .readBufferByte ();
if _aec !=nil {return false ,_aec ;};_fa =(_dfdc ._bfg &0x80)!=0;_dfdc ._bfg ,_dfdc ._deg =_dfdc ._bfg &0x7f,7;return _fa ,nil ;};_dfdc ._deg --;_fa =(_dfdc ._bfg &(1<<_dfdc ._deg ))!=0;_dfdc ._bfg &=1<<_dfdc ._deg -1;return _fa ,nil ;};func (_ccc *Reader )Mark (){_ccc ._ccg =_ccc ._cba ;
_ccc ._daa =_ccc ._deg };const (_c =64;_ag =int (^uint (0)>>1););func (_cgb *BufferedWriter )WriteBits (bits uint64 ,number int )(_bc int ,_abf error ){const _edd ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";
if number < 0||number > 64{return 0,_dg .Errorf (_edd ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};_fge :=number /8;if _fge > 0{_dgc :=number -_fge *8;for _fga :=_fge -1;_fga >=0;_fga --{_ebe :=byte ((bits >>uint (_fga *8+_dgc ))&0xff);if _abf =_cgb .WriteByte (_ebe );_abf !=nil {return _bc ,_dg .Wrapf (_abf ,_edd ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_fge -_fga +1);
};};number -=_fge *8;if number ==0{return _fge ,nil ;};};var _ec int ;for _af :=0;_af < number ;_af ++{if _cgb ._ab {_ec =int ((bits >>uint (number -1-_af ))&0x1);}else {_ec =int (bits &0x1);bits >>=1;};if _abf =_cgb .WriteBit (_ec );_abf !=nil {return _bc ,_dg .Wrapf (_abf ,_edd ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_af );
};};return _fge ,nil ;};func (_fc *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _dg .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );
};if len (_fc ._da )-1< _fc ._be {_fc .expandIfNeeded (1);};_ca :=_fc ._g ;if _fc ._ab {_ca =7-_fc ._g ;};_fc ._da [_fc ._be ]|=byte (uint16 (bit <<_ca )&0xff);_fc ._g ++;if _fc ._g ==8{_fc ._be ++;_fc ._g =0;};return nil ;};func (_aadgb *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _aadgb .writeBit (uint8 (bit ));
};return _dg .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");};func (_debd *BufferedWriter )writeShiftedBytes (_cc []byte )int {for _ ,_abfb :=range _cc {_debd .writeByte (_abfb );
};return len (_cc );};func (_aee *Reader )readBufferByte ()(byte ,error ){if _aee ._cba >=int64 (len (_aee ._fbg )){return 0,_b .EOF ;};_aee ._bde =-1;_dfd :=_aee ._fbg [_aee ._cba ];_aee ._cba ++;_aee ._gd =int (_dfd );return _dfd ,nil ;};func (_abb *Reader )read (_dgec []byte )(int ,error ){if _abb ._cba >=int64 (len (_abb ._fbg )){return 0,_b .EOF ;
};_abb ._bde =-1;_egg :=copy (_dgec ,_abb ._fbg [_abb ._cba :]);_abb ._cba +=int64 (_egg );return _egg ,nil ;};func (_cgcg *SubstreamReader )BitPosition ()int {return int (_cgcg ._bad )};func (_ge *BufferedWriter )tryGrowByReslice (_gf int )bool {if _ebb :=len (_ge ._da );
_gf <=cap (_ge ._da )-_ebb {_ge ._da =_ge ._da [:_ebb +_gf ];return true ;};return false ;};func (_ddcc *Writer )WriteBits (bits uint64 ,number int )(_edcf int ,_aeca error ){const _abfa ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";
if number < 0||number > 64{return 0,_dg .Errorf (_abfa ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};if number ==0{return 0,nil ;};_beea :=number /8;if _beea > 0{_adf :=number -_beea *8;for _fcb :=_beea -1;_fcb >=0;_fcb --{_bce :=byte ((bits >>uint (_fcb *8+_adf ))&0xff);if _aeca =_ddcc .WriteByte (_bce );_aeca !=nil {return _edcf ,_dg .Wrapf (_aeca ,_abfa ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_beea -_fcb +1);
};};number -=_beea *8;if number ==0{return _beea ,nil ;};};var _cce int ;for _dff :=0;_dff < number ;_dff ++{if _ddcc ._gbd {_cce =int ((bits >>uint (number -1-_dff ))&0x1);}else {_cce =int (bits &0x1);bits >>=1;};if _aeca =_ddcc .WriteBit (_cce );_aeca !=nil {return _edcf ,_dg .Wrapf (_aeca ,_abfa ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_dff );
};};return _beea ,nil ;};func (_ac *Reader )ReadBit ()(_ebbd int ,_aac error ){_acc ,_aac :=_ac .readBool ();if _aac !=nil {return 0,_aac ;};if _acc {_ebbd =1;};return _ebbd ,nil ;};func (_gdcf *SubstreamReader )Reset (){_gdcf ._cgg =_gdcf ._dacg ;_gdcf ._bad =_gdcf ._gbg };
func (_dbe *Writer )ResetBit (){_dbe ._dcca =0};