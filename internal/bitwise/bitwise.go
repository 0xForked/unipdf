//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_f "encoding/binary";_c "errors";_g "github.com/unidoc/unipdf/v3/common";_fc "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_b "io";);func (_cec *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_cec ._eaf =-1;var _beab int64 ;switch whence {case _b .SeekStart :_beab =offset ;case _b .SeekCurrent :_beab =_cec ._acd +offset ;case _b .SeekEnd :_beab =int64 (len (_cec ._aad ))+offset ;default:return 0,_c .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");};if _beab < 0{return 0,_c .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");};_cec ._acd =_beab ;_cec ._bbd =0;return _beab ,nil ;};func (_ead *Writer )Write (p []byte )(int ,error ){if len (p )> _ead .byteCapacity (){return 0,_b .EOF ;};for _ ,_gcc :=range p {if _fgd :=_ead .writeByte (_gcc );_fgd !=nil {return 0,_fgd ;};};return len (p ),nil ;};func NewWriterMSB (data []byte )*Writer {return &Writer {_ecfa :data ,_bgd :true }};type SubstreamReader struct{_aef uint64 ;_bdg StreamReader ;_dgd uint64 ;_cfc uint64 ;_gbf []byte ;_geg uint64 ;_bga uint64 ;_eagf byte ;_egd byte ;_geab uint64 ;_bdgc byte ;};func (_ga *BufferedWriter )WriteBits (bits uint64 ,number int )(_cc int ,_bea error ){const _ff ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";if number < 0||number > 64{return 0,_fc .Errorf (_ff ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );};_gf :=number /8;if _gf > 0{_bc :=number -_gf *8;for _gb :=_gf -1;_gb >=0;_gb --{_gfa :=byte ((bits >>uint (_gb *8+_bc ))&0xff);if _bea =_ga .WriteByte (_gfa );_bea !=nil {return _cc ,_fc .Wrapf (_bea ,_ff ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_gf -_gb +1);};};number -=_gf *8;if number ==0{return _gf ,nil ;};};var _fed int ;for _bd :=0;_bd < number ;_bd ++{if _ga ._dc {_fed =int ((bits >>uint (number -1-_bd ))&0x1);}else {_fed =int (bits &0x1);bits >>=1;};if _bea =_ga .WriteBit (_fed );_bea !=nil {return _cc ,_fc .Wrapf (_bea ,_ff ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_bd );};};return _gf ,nil ;};func (_efd *Reader )ConsumeRemainingBits (){if _efd ._bbd !=0{_ ,_bee :=_efd .ReadBits (_efd ._bbd );if _bee !=nil {_g .Log .Debug ("\u0043\u006f\u006e\u0073\u0075\u006d\u0065\u0052\u0065\u006da\u0069\u006e\u0069\u0067\u0042\u0069\u0074s\u0020\u0066\u0061\u0069\u006c\u0065\u0064\u003a\u0020\u0025\u0076",_bee );};};};var _ _b .ByteWriter =&BufferedWriter {};func (_eag *Reader )ReadByte ()(byte ,error ){if _eag ._bbd ==0{return _eag .readBufferByte ();};return _eag .readUnalignedByte ();};func (_gg *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;};_eb :=int (_gg ._ce )+skip ;if _eb >=0&&_eb < 8{_gg ._ce =uint8 (_eb );return nil ;};_eb =int (_gg ._ce )+_gg ._eg *8+skip ;if _eb < 0{return _fc .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_aa :=_eb /8;_be :=_eb %8;_gg ._ce =uint8 (_be );if _fe :=_aa -_gg ._eg ;_fe > 0&&len (_gg ._fg )-1< _aa {if _gg ._ce !=0{_fe ++;};_gg .expandIfNeeded (_fe );};_gg ._eg =_aa ;return nil ;};func (_edg *BufferedWriter )writeByte (_gd byte ){switch {case _edg ._ce ==0:_edg ._fg [_edg ._eg ]=_gd ;_edg ._eg ++;case _edg ._dc :_edg ._fg [_edg ._eg ]|=_gd >>_edg ._ce ;_edg ._eg ++;_edg ._fg [_edg ._eg ]=byte (uint16 (_gd )<<(8-_edg ._ce )&0xff);default:_edg ._fg [_edg ._eg ]|=byte (uint16 (_gd )<<_edg ._ce &0xff);_edg ._eg ++;_edg ._fg [_edg ._eg ]=_gd >>(8-_edg ._ce );};};func (_dgab *Reader )readUnalignedByte ()(_gee byte ,_gde error ){_fce :=_dgab ._bbd ;_gee =_dgab ._dac <<(8-_fce );_dgab ._dac ,_gde =_dgab .readBufferByte ();if _gde !=nil {return 0,_gde ;};_gee |=_dgab ._dac >>_fce ;_dgab ._dac &=1<<_fce -1;return _gee ,nil ;};func (_ge *BufferedWriter )Len ()int {return _ge .byteCapacity ()};func (_efe *BufferedWriter )Reset (){_efe ._fg =_efe ._fg [:0];_efe ._eg =0;_efe ._ce =0};var _ BinaryWriter =&BufferedWriter {};func (_cd *BufferedWriter )writeShiftedBytes (_ea []byte )int {for _ ,_gag :=range _ea {_cd .writeByte (_gag );};return len (_ea );};func (_ec *BufferedWriter )Data ()[]byte {return _ec ._fg };func (_aae *BufferedWriter )byteCapacity ()int {_gff :=len (_aae ._fg )-_aae ._eg ;if _aae ._ce !=0{_gff --;};return _gff ;};func (_bg *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _fc .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );};if len (_bg ._fg )-1< _bg ._eg {_bg .expandIfNeeded (1);};_fa :=_bg ._ce ;if _bg ._dc {_fa =7-_bg ._ce ;};_bg ._fg [_bg ._eg ]|=byte (uint16 (bit <<_fa )&0xff);_bg ._ce ++;if _bg ._ce ==8{_bg ._eg ++;_bg ._ce =0;};return nil ;};func (_daf *Writer )UseMSB ()bool {return _daf ._bgd };func (_acfg *Writer )WriteBits (bits uint64 ,number int )(_gce int ,_feb error ){const _fb ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";if number < 0||number > 64{return 0,_fc .Errorf (_fb ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );};if number ==0{return 0,nil ;};_dcd :=number /8;if _dcd > 0{_eage :=number -_dcd *8;for _dacd :=_dcd -1;_dacd >=0;_dacd --{_cbd :=byte ((bits >>uint (_dacd *8+_eage ))&0xff);if _feb =_acfg .WriteByte (_cbd );_feb !=nil {return _gce ,_fc .Wrapf (_feb ,_fb ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_dcd -_dacd +1);};};number -=_dcd *8;if number ==0{return _dcd ,nil ;};};var _aaac int ;for _dgb :=0;_dgb < number ;_dgb ++{if _acfg ._bgd {_aaac =int ((bits >>uint (number -1-_dgb ))&0x1);}else {_aaac =int (bits &0x1);bits >>=1;};if _feb =_acfg .WriteBit (_aaac );_feb !=nil {return _gce ,_fc .Wrapf (_feb ,_fb ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_dgb );};};return _dcd ,nil ;};var _ BinaryWriter =&Writer {};func (_cbec *Reader )Length ()uint64 {return uint64 (len (_cbec ._aad ))};func (_gc *Reader )ReadBool ()(bool ,error ){return _gc .readBool ()};type BufferedWriter struct{_fg []byte ;_ce uint8 ;_eg int ;_dc bool ;};func (_ccec *Writer )WriteByte (c byte )error {return _ccec .writeByte (c )};func (_fcge *Writer )Data ()[]byte {return _fcge ._ecfa };func (_ed *BufferedWriter )WriteByte (bt byte )error {if _ed ._eg > len (_ed ._fg )-1||(_ed ._eg ==len (_ed ._fg )-1&&_ed ._ce !=0){_ed .expandIfNeeded (1);};_ed .writeByte (bt );return nil ;};func NewReader (data []byte )*Reader {return &Reader {_aad :data }};func (_bb *BufferedWriter )ResetBitIndex (){_bb ._ce =0};func (_ab *BufferedWriter )grow (_bf int ){if _ab ._fg ==nil &&_bf < _e {_ab ._fg =make ([]byte ,_bf ,_e );return ;};_cge :=len (_ab ._fg );if _ab ._ce !=0{_cge ++;};_cbg :=cap (_ab ._fg );switch {case _bf <=_cbg /2-_cge :_g .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_ab ._fg ),cap (_ab ._fg ),_bf );_g .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_cbg ,_cge );copy (_ab ._fg ,_ab ._fg [_ab .fullOffset ():]);case _cbg > _ef -_cbg -_bf :_g .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_da :=make ([]byte ,2*_cbg +_bf );copy (_da ,_ab ._fg );_ab ._fg =_da ;};_ab ._fg =_ab ._fg [:_cge +_bf ];};func (_edb *Reader )Align ()(_gfc byte ){_gfc =_edb ._bbd ;_edb ._bbd =0;return _gfc };func (_cbgd *Reader )ReadUint32 ()(uint32 ,error ){_acg :=make ([]byte ,4);_ ,_bdd :=_cbgd .Read (_acg );if _bdd !=nil {return 0,_bdd ;};return _f .BigEndian .Uint32 (_acg ),nil ;};func (_bcg *BufferedWriter )writeFullBytes (_faa []byte )int {_ad :=copy (_bcg ._fg [_bcg .fullOffset ():],_faa );_bcg ._eg +=_ad ;return _ad ;};func (_gffd *Writer )SkipBits (skip int )error {const _ggca ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";if skip ==0{return nil ;};_egb :=int (_gffd ._gdg )+skip ;if _egb >=0&&_egb < 8{_gffd ._gdg =uint8 (_egb );return nil ;};_egb =int (_gffd ._gdg )+_gffd ._aga *8+skip ;if _egb < 0{return _fc .Errorf (_ggca ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_gfcf :=_egb /8;_abdd :=_egb %8;_g .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");_g .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_gffd ._gdg ,_gffd ._aga ,int (_gffd ._gdg )+(_gffd ._aga )*8,len (_gffd ._ecfa ),cap (_gffd ._ecfa ));_g .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_egb ,_abdd );_gffd ._gdg =uint8 (_abdd );if _dec :=_gfcf -_gffd ._aga ;_dec > 0&&len (_gffd ._ecfa )-1< _gfcf {_g .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_dec );return _fc .Errorf (_ggca ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_gffd ._aga =_gfcf ;_g .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_gffd ._gdg ,_gffd ._aga );return nil ;};func (_cad *Reader )readBool ()(_ffg bool ,_fef error ){if _cad ._bbd ==0{_cad ._dac ,_fef =_cad .readBufferByte ();if _fef !=nil {return false ,_fef ;};_ffg =(_cad ._dac &0x80)!=0;_cad ._dac ,_cad ._bbd =_cad ._dac &0x7f,7;return _ffg ,nil ;};_cad ._bbd --;_ffg =(_cad ._dac &(1<<_cad ._bbd ))!=0;_cad ._dac &=1<<_cad ._bbd -1;return _ffg ,nil ;};func (_bdb *Reader )StreamPosition ()int64 {return _bdb ._acd };func (_gdeb *SubstreamReader )Reset (){_gdeb ._aef =_gdeb ._geab ;_gdeb ._egd =_gdeb ._bdgc };func (_abd *Reader )Mark (){_abd ._ca =_abd ._acd ;_abd ._bgc =_abd ._bbd };func (_ecb *SubstreamReader )BitPosition ()int {return int (_ecb ._egd )};func (_cg *BufferedWriter )expandIfNeeded (_ee int ){if !_cg .tryGrowByReslice (_ee ){_cg .grow (_ee );};};func (_adg *Reader )ReadBits (n byte )(_adb uint64 ,_addb error ){if n < _adg ._bbd {_faf :=_adg ._bbd -n ;_adb =uint64 (_adg ._dac >>_faf );_adg ._dac &=1<<_faf -1;_adg ._bbd =_faf ;return _adb ,nil ;};if n > _adg ._bbd {if _adg ._bbd > 0{_adb =uint64 (_adg ._dac );n -=_adg ._bbd ;};for n >=8{_dbd ,_fab :=_adg .readBufferByte ();if _fab !=nil {return 0,_fab ;};_adb =_adb <<8+uint64 (_dbd );n -=8;};if n > 0{if _adg ._dac ,_addb =_adg .readBufferByte ();_addb !=nil {return 0,_addb ;};_gbb :=8-n ;_adb =_adb <<n +uint64 (_adg ._dac >>_gbb );_adg ._dac &=1<<_gbb -1;_adg ._bbd =_gbb ;}else {_adg ._bbd =0;};return _adb ,nil ;};_adg ._bbd =0;return uint64 (_adg ._dac ),nil ;};func (_fafa *Reader )Reset (){_fafa ._acd =_fafa ._ca ;_fafa ._bbd =_fafa ._bgc };var (_ _b .Reader =&Reader {};_ _b .ByteReader =&Reader {};_ _b .Seeker =&Reader {};_ StreamReader =&Reader {};);func (_fac *Reader )Read (p []byte )(_bbf int ,_bded error ){if _fac ._bbd ==0{return _fac .read (p );};for ;_bbf < len (p );_bbf ++{if p [_bbf ],_bded =_fac .readUnalignedByte ();_bded !=nil {return 0,_bded ;};};return _bbf ,nil ;};func (_ebgd *Writer )writeByte (_afc byte )error {if _ebgd ._aga > len (_ebgd ._ecfa )-1{return _b .EOF ;};if _ebgd ._aga ==len (_ebgd ._ecfa )-1&&_ebgd ._gdg !=0{return _b .EOF ;};if _ebgd ._gdg ==0{_ebgd ._ecfa [_ebgd ._aga ]=_afc ;_ebgd ._aga ++;return nil ;};if _ebgd ._bgd {_ebgd ._ecfa [_ebgd ._aga ]|=_afc >>_ebgd ._gdg ;_ebgd ._aga ++;_ebgd ._ecfa [_ebgd ._aga ]=byte (uint16 (_afc )<<(8-_ebgd ._gdg )&0xff);}else {_ebgd ._ecfa [_ebgd ._aga ]|=byte (uint16 (_afc )<<_ebgd ._gdg &0xff);_ebgd ._aga ++;_ebgd ._ecfa [_ebgd ._aga ]=_afc >>(8-_ebgd ._gdg );};return nil ;};var _ _b .Writer =&BufferedWriter {};func (_ege *SubstreamReader )Mark (){_ege ._geab =_ege ._aef ;_ege ._bdgc =_ege ._egd };func NewSubstreamReader (r StreamReader ,offset ,length uint64 )(*SubstreamReader ,error ){if r ==nil {return nil ,_c .New ("\u0072o\u006ft\u0020\u0072\u0065\u0061\u0064e\u0072\u0020i\u0073\u0020\u006e\u0069\u006c");};_g .Log .Trace ("\u004e\u0065\u0077\u0053\u0075\u0062\u0073\u0074r\u0065\u0061\u006dRe\u0061\u0064\u0065\u0072\u0020\u0061t\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u003a\u0020\u0025\u0064\u0020\u0077\u0069\u0074h\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a \u0025\u0064",offset ,length );return &SubstreamReader {_bdg :r ,_dgd :offset ,_cfc :length ,_gbf :make ([]byte ,length )},nil ;};func (_cb *BufferedWriter )FinishByte (){if _cb ._ce ==0{return ;};_cb ._ce =0;_cb ._eg ++;};func (_cbf *SubstreamReader )Read (b []byte )(_abg int ,_caa error ){if _cbf ._aef >=_cbf ._cfc {_g .Log .Trace ("\u0053\u0074\u0072e\u0061\u006d\u0050\u006fs\u003a\u0020\u0027\u0025\u0064\u0027\u0020>\u003d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027",_cbf ._aef ,_cbf ._cfc );return 0,_b .EOF ;};for ;_abg < len (b );_abg ++{if b [_abg ],_caa =_cbf .readUnalignedByte ();_caa !=nil {if _caa ==_b .EOF {return _abg ,nil ;};return 0,_caa ;};};return _abg ,nil ;};func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_dc :true }};func (_aea *Writer )FinishByte (){if _aea ._gdg ==0{return ;};_aea ._gdg =0;_aea ._aga ++;};func (_geb *SubstreamReader )Seek (offset int64 ,whence int )(int64 ,error ){switch whence {case _b .SeekStart :_geb ._aef =uint64 (offset );case _b .SeekCurrent :_geb ._aef +=uint64 (offset );case _b .SeekEnd :_geb ._aef =_geb ._cfc +uint64 (offset );default:return 0,_c .New ("\u0072\u0065\u0061d\u0065\u0072\u002e\u0053\u0075\u0062\u0073\u0074\u0072\u0065\u0061\u006d\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u0020\u0069\u006e\u0076\u0061\u006ci\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");};_geb ._egd =0;return int64 (_geb ._aef ),nil ;};func (_fdd *Writer )ResetBit (){_fdd ._gdg =0};func (_fafc *Writer )writeBit (_cfg uint8 )error {if len (_fafc ._ecfa )-1< _fafc ._aga {return _b .EOF ;};_dacf :=_fafc ._gdg ;if _fafc ._bgd {_dacf =7-_fafc ._gdg ;};_fafc ._ecfa [_fafc ._aga ]|=byte (uint16 (_cfg <<_dacf )&0xff);_fafc ._gdg ++;if _fafc ._gdg ==8{_fafc ._aga ++;_fafc ._gdg =0;};return nil ;};type Writer struct{_ecfa []byte ;_gdg uint8 ;_aga int ;_bgd bool ;};func (_fca *SubstreamReader )readUnalignedByte ()(_ebb byte ,_dgdc error ){_gab :=_fca ._egd ;_ebb =_fca ._eagf <<(8-_gab );_fca ._eagf ,_dgdc =_fca .readBufferByte ();if _dgdc !=nil {return 0,_dgdc ;};_ebb |=_fca ._eagf >>_gab ;_fca ._eagf &=1<<_gab -1;return _ebb ,nil ;};func (_cf *Reader )ReadBit ()(_dga int ,_af error ){_fee ,_af :=_cf .readBool ();if _af !=nil {return 0,_af ;};if _fee {_dga =1;};return _dga ,nil ;};func (_egc *BufferedWriter )tryGrowByReslice (_ggc int )bool {if _add :=len (_egc ._fg );_ggc <=cap (_egc ._fg )-_add {_egc ._fg =_egc ._fg [:_add +_ggc ];return true ;};return false ;};func (_gda *SubstreamReader )StreamPosition ()int64 {return int64 (_gda ._aef )};func (_cdcd *Writer )byteCapacity ()int {_bce :=len (_cdcd ._ecfa )-_cdcd ._aga ;if _cdcd ._gdg !=0{_bce --;};return _bce ;};func (_cfd *SubstreamReader )Align ()(_acf byte ){_acf =_cfd ._egd ;_cfd ._egd =0;return _acf };func _fag (_babc ,_gaa uint64 )uint64 {if _babc < _gaa {return _babc ;};return _gaa ;};func (_dg *BufferedWriter )fullOffset ()int {_ac :=_dg ._eg ;if _dg ._ce !=0{_ac ++;};return _ac ;};func NewWriter (data []byte )*Writer {return &Writer {_ecfa :data }};func (_fgc *SubstreamReader )ReadByte ()(byte ,error ){if _fgc ._egd ==0{return _fgc .readBufferByte ();};return _fgc .readUnalignedByte ();};type Reader struct{_aad []byte ;_dac byte ;_bbd byte ;_acd int64 ;_cgb int ;_eaf int ;_ca int64 ;_bgc byte ;};func (_dd *SubstreamReader )ReadUint32 ()(uint32 ,error ){_dad :=make ([]byte ,4);_ ,_cfcb :=_dd .Read (_dad );if _cfcb !=nil {return 0,_cfcb ;};return _f .BigEndian .Uint32 (_dad ),nil ;};func (_feeb *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _feeb .writeBit (uint8 (bit ));};return _fc .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");};type StreamReader interface{_b .Reader ;_b .ByteReader ;_b .Seeker ;Align ()byte ;BitPosition ()int ;Mark ();Length ()uint64 ;ReadBit ()(int ,error );ReadBits (_db byte )(uint64 ,error );ReadBool ()(bool ,error );ReadUint32 ()(uint32 ,error );Reset ();StreamPosition ()int64 ;};func (_aed *Reader )BitPosition ()int {return int (_aed ._bbd )};const (_e =64;_ef =int (^uint (0)>>1););func (_bece *SubstreamReader )fillBuffer ()error {if uint64 (_bece ._bdg .StreamPosition ())!=_bece ._aef +_bece ._dgd {_ ,_bge :=_bece ._bdg .Seek (int64 (_bece ._aef +_bece ._dgd ),_b .SeekStart );if _bge !=nil {return _bge ;};};_bece ._geg =uint64 (_bece ._aef );_bdbg :=_fag (uint64 (len (_bece ._gbf )),_bece ._cfc -_bece ._aef );_gebg :=make ([]byte ,_bdbg );_dfa ,_ebg :=_bece ._bdg .Read (_gebg );if _ebg !=nil {return _ebg ;};for _geba :=uint64 (0);_geba < _bdbg ;_geba ++{_bece ._gbf [_geba ]=_gebg [_geba ];};_bece ._bga =_bece ._geg +uint64 (_dfa );return nil ;};func (_feea *SubstreamReader )Offset ()uint64 {return _feea ._dgd };func (_dfe *Reader )read (_afb []byte )(int ,error ){if _dfe ._acd >=int64 (len (_dfe ._aad )){return 0,_b .EOF ;};_dfe ._eaf =-1;_bab :=copy (_afb ,_dfe ._aad [_dfe ._acd :]);_dfe ._acd +=int64 (_bab );return _bab ,nil ;};func (_fcb *SubstreamReader )ReadBit ()(_bad int ,_abdb error ){_ged ,_abdb :=_fcb .readBool ();if _abdb !=nil {return 0,_abdb ;};if _ged {_bad =1;};return _bad ,nil ;};func (_ag *BufferedWriter )Write (d []byte )(int ,error ){_ag .expandIfNeeded (len (d ));if _ag ._ce ==0{return _ag .writeFullBytes (d ),nil ;};return _ag .writeShiftedBytes (d ),nil ;};func (_fd *SubstreamReader )ReadBool ()(bool ,error ){return _fd .readBool ()};func (_de *SubstreamReader )readBufferByte ()(byte ,error ){if _de ._aef >=_de ._cfc {return 0,_b .EOF ;};if _de ._aef >=_de ._bga ||_de ._aef < _de ._geg {if _cbeb :=_de .fillBuffer ();_cbeb !=nil {return 0,_cbeb ;};};_gedd :=_de ._gbf [_de ._aef -_de ._geg ];_de ._aef ++;return _gedd ,nil ;};type BinaryWriter interface{BitWriter ;_b .Writer ;_b .ByteWriter ;Data ()[]byte ;};func (_bfd *Reader )readBufferByte ()(byte ,error ){if _bfd ._acd >=int64 (len (_bfd ._aad )){return 0,_b .EOF ;};_bfd ._eaf =-1;_gea :=_bfd ._aad [_bfd ._acd ];_bfd ._acd ++;_bfd ._cgb =int (_gea );return _gea ,nil ;};func (_fedd *SubstreamReader )readBool ()(_dbb bool ,_ecf error ){if _fedd ._egd ==0{_fedd ._eagf ,_ecf =_fedd .readBufferByte ();if _ecf !=nil {return false ,_ecf ;};_dbb =(_fedd ._eagf &0x80)!=0;_fedd ._eagf ,_fedd ._egd =_fedd ._eagf &0x7f,7;return _dbb ,nil ;};_fedd ._egd --;_dbb =(_fedd ._eagf &(1<<_fedd ._egd ))!=0;_fedd ._eagf &=1<<_fedd ._egd -1;return _dbb ,nil ;};func (_efec *SubstreamReader )ReadBits (n byte )(_fec uint64 ,_gdea error ){if n < _efec ._egd {_gec :=_efec ._egd -n ;_fec =uint64 (_efec ._eagf >>_gec );_efec ._eagf &=1<<_gec -1;_efec ._egd =_gec ;return _fec ,nil ;};if n > _efec ._egd {if _efec ._egd > 0{_fec =uint64 (_efec ._eagf );n -=_efec ._egd ;};var _gdef byte ;for n >=8{_gdef ,_gdea =_efec .readBufferByte ();if _gdea !=nil {return 0,_gdea ;};_fec =_fec <<8+uint64 (_gdef );n -=8;};if n > 0{if _efec ._eagf ,_gdea =_efec .readBufferByte ();_gdea !=nil {return 0,_gdea ;};_bfe :=8-n ;_fec =_fec <<n +uint64 (_efec ._eagf >>_bfe );_efec ._eagf &=1<<_bfe -1;_efec ._egd =_bfe ;}else {_efec ._egd =0;};return _fec ,nil ;};_efec ._egd =0;return uint64 (_efec ._eagf ),nil ;};func (_edbc *SubstreamReader )Length ()uint64 {return _edbc ._cfc };type BitWriter interface{WriteBit (_ede int )error ;WriteBits (_cbe uint64 ,_ba int )(_cce int ,_dcg error );FinishByte ();SkipBits (_fge int )error ;};