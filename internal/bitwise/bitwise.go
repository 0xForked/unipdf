//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_d "encoding/binary";_ea "errors";_de "github.com/unidoc/unipdf/v3/common";_be "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_e "io";);func (_ag *Reader )BitPosition ()int {return int (_ag ._dab )};func (_fd *Reader )ReadUint32 ()(uint32 ,error ){_fbd :=make ([]byte ,4);
_ ,_gd :=_fd .Read (_fbd );if _gd !=nil {return 0,_gd ;};return _d .BigEndian .Uint32 (_fbd ),nil ;};func (_ffafa *SubstreamReader )fillBuffer ()error {if uint64 (_ffafa ._eee .StreamPosition ())!=_ffafa ._efe +_ffafa ._ffa {_ ,_gcb :=_ffafa ._eee .Seek (int64 (_ffafa ._efe +_ffafa ._ffa ),_e .SeekStart );
if _gcb !=nil {return _gcb ;};};_ffafa ._bdc =_ffafa ._efe ;_dba :=_eef (uint64 (len (_ffafa ._fac )),_ffafa ._fda -_ffafa ._efe );_edcc :=make ([]byte ,_dba );_cebe ,_fcb :=_ffafa ._eee .Read (_edcc );if _fcb !=nil {return _fcb ;};for _ebb :=uint64 (0);
_ebb < _dba ;_ebb ++{_ffafa ._fac [_ebb ]=_edcc [_ebb ];};_ffafa ._cab =_ffafa ._bdc +uint64 (_cebe );return nil ;};func (_bcdg *Writer )Write (p []byte )(int ,error ){if len (p )> _bcdg .byteCapacity (){return 0,_e .EOF ;};for _ ,_aca :=range p {if _fcbga :=_bcdg .writeByte (_aca );
_fcbga !=nil {return 0,_fcbga ;};};return len (p ),nil ;};type BitWriter interface{WriteBit (_bg int )error ;WriteBits (_ac uint64 ,_cdc int )(_dfca int ,_gba error );FinishByte ();SkipBits (_dcd int )error ;};const (_ef =64;_c =int (^uint (0)>>1););func (_acfa *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_acfa ._dcb =-1;
var _adb int64 ;switch whence {case _e .SeekStart :_adb =offset ;case _e .SeekCurrent :_adb =_acfa ._fg +offset ;case _e .SeekEnd :_adb =int64 (len (_acfa ._cge ))+offset ;default:return 0,_ea .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};if _adb < 0{return 0,_ea .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");};_acfa ._fg =_adb ;
_acfa ._dab =0;return _adb ,nil ;};func (_bee *SubstreamReader )Offset ()uint64 {return _bee ._ffa };func (_fb *BufferedWriter )WriteByte (bt byte )error {if _fb ._g > len (_fb ._da )-1||(_fb ._g ==len (_fb ._da )-1&&_fb ._bf !=0){_fb .expandIfNeeded (1);
};_fb .writeByte (bt );return nil ;};func (_fdac *Writer )writeBit (_dgb uint8 )error {if len (_fdac ._bfcf )-1< _fdac ._egf {return _e .EOF ;};_fcge :=_fdac ._efc ;if _fdac ._dcc {_fcge =7-_fdac ._efc ;};_fdac ._bfcf [_fdac ._egf ]|=byte (uint16 (_dgb <<_fcge )&0xff);
_fdac ._efc ++;if _fdac ._efc ==8{_fdac ._egf ++;_fdac ._efc =0;};return nil ;};func (_def *BufferedWriter )writeShiftedBytes (_fag []byte )int {for _ ,_dff :=range _fag {_def .writeByte (_dff );};return len (_fag );};func (_gg *BufferedWriter )WriteBits (bits uint64 ,number int )(_dg int ,_bcd error ){const _cf ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";
if number < 0||number > 64{return 0,_be .Errorf (_cf ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};_ba :=number /8;if _ba > 0{_cec :=number -_ba *8;for _fff :=_ba -1;_fff >=0;_fff --{_edc :=byte ((bits >>uint (_fff *8+_cec ))&0xff);if _bcd =_gg .WriteByte (_edc );_bcd !=nil {return _dg ,_be .Wrapf (_bcd ,_cf ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_ba -_fff +1);
};};number -=_ba *8;if number ==0{return _ba ,nil ;};};var _dfc int ;for _a :=0;_a < number ;_a ++{if _gg ._eb {_dfc =int ((bits >>uint (number -1-_a ))&0x1);}else {_dfc =int (bits &0x1);bits >>=1;};if _bcd =_gg .WriteBit (_dfc );_bcd !=nil {return _dg ,_be .Wrapf (_bcd ,_cf ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_a );
};};return _ba ,nil ;};func (_beg *SubstreamReader )Reset (){_beg ._efe =_beg ._dfg ;_beg ._abg =_beg ._eeg };func (_ceadc *Writer )writeByte (_ffd byte )error {if _ceadc ._egf > len (_ceadc ._bfcf )-1{return _e .EOF ;};if _ceadc ._egf ==len (_ceadc ._bfcf )-1&&_ceadc ._efc !=0{return _e .EOF ;
};if _ceadc ._efc ==0{_ceadc ._bfcf [_ceadc ._egf ]=_ffd ;_ceadc ._egf ++;return nil ;};if _ceadc ._dcc {_ceadc ._bfcf [_ceadc ._egf ]|=_ffd >>_ceadc ._efc ;_ceadc ._egf ++;_ceadc ._bfcf [_ceadc ._egf ]=byte (uint16 (_ffd )<<(8-_ceadc ._efc )&0xff);}else {_ceadc ._bfcf [_ceadc ._egf ]|=byte (uint16 (_ffd )<<_ceadc ._efc &0xff);
_ceadc ._egf ++;_ceadc ._bfcf [_ceadc ._egf ]=_ffd >>(8-_ceadc ._efc );};return nil ;};var _ _e .Writer =&BufferedWriter {};func (_fcf *SubstreamReader )Mark (){_fcf ._dfg =_fcf ._efe ;_fcf ._eeg =_fcf ._abg };func (_af *Reader )read (_cag []byte )(int ,error ){if _af ._fg >=int64 (len (_af ._cge )){return 0,_e .EOF ;
};_af ._dcb =-1;_gafg :=copy (_cag ,_af ._cge [_af ._fg :]);_af ._fg +=int64 (_gafg );return _gafg ,nil ;};func NewWriter (data []byte )*Writer {return &Writer {_bfcf :data }};var (_ _e .Reader =&Reader {};_ _e .ByteReader =&Reader {};_ _e .Seeker =&Reader {};
_ StreamReader =&Reader {};);func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_eb :true }};func (_fcff *SubstreamReader )ReadByte ()(byte ,error ){if _fcff ._abg ==0{return _fcff .readBufferByte ();};return _fcff .readUnalignedByte ();};func (_cc *SubstreamReader )Length ()uint64 {return _cc ._fda };
func NewReader (data []byte )*Reader {return &Reader {_cge :data }};func (_edb *BufferedWriter )ResetBitIndex (){_edb ._bf =0};type BinaryWriter interface{BitWriter ;_e .Writer ;_e .ByteWriter ;Data ()[]byte ;};func (_egde *Reader )ReadBits (n byte )(_fgb uint64 ,_cbf error ){if n < _egde ._dab {_bdb :=_egde ._dab -n ;
_fgb =uint64 (_egde ._ced >>_bdb );_egde ._ced &=1<<_bdb -1;_egde ._dab =_bdb ;return _fgb ,nil ;};if n > _egde ._dab {if _egde ._dab > 0{_fgb =uint64 (_egde ._ced );n -=_egde ._dab ;};for n >=8{_cef ,_ege :=_egde .readBufferByte ();if _ege !=nil {return 0,_ege ;
};_fgb =_fgb <<8+uint64 (_cef );n -=8;};if n > 0{if _egde ._ced ,_cbf =_egde .readBufferByte ();_cbf !=nil {return 0,_cbf ;};_daa :=8-n ;_fgb =_fgb <<n +uint64 (_egde ._ced >>_daa );_egde ._ced &=1<<_daa -1;_egde ._dab =_daa ;}else {_egde ._dab =0;};return _fgb ,nil ;
};_egde ._dab =0;return uint64 (_egde ._ced ),nil ;};func (_dbd *SubstreamReader )ReadBits (n byte )(_baa uint64 ,_ged error ){if n < _dbd ._abg {_bfc :=_dbd ._abg -n ;_baa =uint64 (_dbd ._cdd >>_bfc );_dbd ._cdd &=1<<_bfc -1;_dbd ._abg =_bfc ;return _baa ,nil ;
};if n > _dbd ._abg {if _dbd ._abg > 0{_baa =uint64 (_dbd ._cdd );n -=_dbd ._abg ;};var _bb byte ;for n >=8{_bb ,_ged =_dbd .readBufferByte ();if _ged !=nil {return 0,_ged ;};_baa =_baa <<8+uint64 (_bb );n -=8;};if n > 0{if _dbd ._cdd ,_ged =_dbd .readBufferByte ();
_ged !=nil {return 0,_ged ;};_decd :=8-n ;_baa =_baa <<n +uint64 (_dbd ._cdd >>_decd );_dbd ._cdd &=1<<_decd -1;_dbd ._abg =_decd ;}else {_dbd ._abg =0;};return _baa ,nil ;};_dbd ._abg =0;return uint64 (_dbd ._cdd ),nil ;};func (_fec *SubstreamReader )ReadUint32 ()(uint32 ,error ){_bcf :=make ([]byte ,4);
_ ,_bdg :=_fec .Read (_bcf );if _bdg !=nil {return 0,_bdg ;};return _d .BigEndian .Uint32 (_bcf ),nil ;};func (_gad *Reader )StreamPosition ()int64 {return _gad ._fg };func (_efb *BufferedWriter )fullOffset ()int {_cea :=_efb ._g ;if _efb ._bf !=0{_cea ++;
};return _cea ;};func (_geb *Writer )WriteByte (c byte )error {return _geb .writeByte (c )};func NewSubstreamReader (r StreamReader ,offset ,length uint64 )(*SubstreamReader ,error ){if r ==nil {return nil ,_ea .New ("\u0072o\u006ft\u0020\u0072\u0065\u0061\u0064e\u0072\u0020i\u0073\u0020\u006e\u0069\u006c");
};const _dcg =1000*1000;_egeb :=length ;if _egeb > _dcg {_egeb =_dcg ;};_de .Log .Trace ("\u004e\u0065\u0077\u0053\u0075\u0062\u0073\u0074r\u0065\u0061\u006dRe\u0061\u0064\u0065\u0072\u0020\u0061t\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u003a\u0020\u0025\u0064\u0020\u0077\u0069\u0074h\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a \u0025\u0064",offset ,length );
return &SubstreamReader {_eee :r ,_ffa :offset ,_fda :length ,_fac :make ([]byte ,_egeb )},nil ;};type StreamReader interface{_e .Reader ;_e .ByteReader ;_e .Seeker ;Align ()byte ;BitPosition ()int ;Mark ();Length ()uint64 ;ReadBit ()(int ,error );ReadBits (_gc byte )(uint64 ,error );
ReadBool ()(bool ,error );ReadUint32 ()(uint32 ,error );Reset ();StreamPosition ()int64 ;};type BufferedWriter struct{_da []byte ;_bf uint8 ;_g int ;_eb bool ;};func (_fgga *Writer )byteCapacity ()int {_ffc :=len (_fgga ._bfcf )-_fgga ._egf ;if _fgga ._efc !=0{_ffc --;
};return _ffc ;};func (_ga *BufferedWriter )Reset (){_ga ._da =_ga ._da [:0];_ga ._g =0;_ga ._bf =0};func (_daab *Writer )UseMSB ()bool {return _daab ._dcc };func (_ab *BufferedWriter )expandIfNeeded (_egc int ){if !_ab .tryGrowByReslice (_egc ){_ab .grow (_egc );
};};func _eef (_cee ,_baf uint64 )uint64 {if _cee < _baf {return _cee ;};return _baf ;};func (_dae *Reader )readUnalignedByte ()(_eaf byte ,_ebf error ){_gaec :=_dae ._dab ;_eaf =_dae ._ced <<(8-_gaec );_dae ._ced ,_ebf =_dae .readBufferByte ();if _ebf !=nil {return 0,_ebf ;
};_eaf |=_dae ._ced >>_gaec ;_dae ._ced &=1<<_gaec -1;return _eaf ,nil ;};func (_deac *Writer )ResetBit (){_deac ._efc =0};type Writer struct{_bfcf []byte ;_efc uint8 ;_egf int ;_dcc bool ;};func (_ed *BufferedWriter )FinishByte (){if _ed ._bf ==0{return ;
};_ed ._bf =0;_ed ._g ++;};func (_bbg *SubstreamReader )readBool ()(_ace bool ,_age error ){if _bbg ._abg ==0{_bbg ._cdd ,_age =_bbg .readBufferByte ();if _age !=nil {return false ,_age ;};_ace =(_bbg ._cdd &0x80)!=0;_bbg ._cdd ,_bbg ._abg =_bbg ._cdd &0x7f,7;
return _ace ,nil ;};_bbg ._abg --;_ace =(_bbg ._cdd &(1<<_bbg ._abg ))!=0;_bbg ._cdd &=1<<_bbg ._abg -1;return _ace ,nil ;};type Reader struct{_cge []byte ;_ced byte ;_dab byte ;_fg int64 ;_cfg int ;_dcb int ;_gafb int64 ;_adf byte ;_gbb byte ;_eba int ;
};func (_egd *Reader )ConsumeRemainingBits ()(uint64 ,error ){if _egd ._dab !=0{return _egd .ReadBits (_egd ._dab );};return 0,nil ;};func (_cabd *SubstreamReader )Align ()(_bfb byte ){_bfb =_cabd ._abg ;_cabd ._abg =0;return _bfb };func (_gae *Reader )Length ()uint64 {return uint64 (len (_gae ._cge ))};
func (_acf *Reader )Reset (){_acf ._fg =_acf ._gafb ;_acf ._dab =_acf ._adf ;_acf ._ced =_acf ._gbb ;_acf ._cfg =_acf ._eba ;};func (_cead *Reader )readBufferByte ()(byte ,error ){if _cead ._fg >=int64 (len (_cead ._cge )){return 0,_e .EOF ;};_cead ._dcb =-1;
_bae :=_cead ._cge [_cead ._fg ];_cead ._fg ++;_cead ._cfg =int (_bae );return _bae ,nil ;};func (_fbf *Writer )SkipBits (skip int )error {const _fed ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";if skip ==0{return nil ;
};_ecf :=int (_fbf ._efc )+skip ;if _ecf >=0&&_ecf < 8{_fbf ._efc =uint8 (_ecf );return nil ;};_ecf =int (_fbf ._efc )+_fbf ._egf *8+skip ;if _ecf < 0{return _be .Errorf (_fed ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_fcg :=_ecf /8;_gcce :=_ecf %8;_de .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");_de .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_fbf ._efc ,_fbf ._egf ,int (_fbf ._efc )+(_fbf ._egf )*8,len (_fbf ._bfcf ),cap (_fbf ._bfcf ));
_de .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_ecf ,_gcce );_fbf ._efc =uint8 (_gcce );
if _aa :=_fcg -_fbf ._egf ;_aa > 0&&len (_fbf ._bfcf )-1< _fcg {_de .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_aa );return _be .Errorf (_fed ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_fbf ._egf =_fcg ;_de .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_fbf ._efc ,_fbf ._egf );return nil ;};func (_efbd *SubstreamReader )StreamPosition ()int64 {return int64 (_efbd ._efe )};
func (_deg *Reader )Read (p []byte )(_fc int ,_dea error ){if _deg ._dab ==0{return _deg .read (p );};for ;_fc < len (p );_fc ++{if p [_fc ],_dea =_deg .readUnalignedByte ();_dea !=nil {return 0,_dea ;};};return _fc ,nil ;};func (_fafc *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _fafc .writeBit (uint8 (bit ));
};return _be .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");};var _ _e .ByteWriter =&BufferedWriter {};func (_bc *BufferedWriter )Len ()int {return _bc .byteCapacity ()};
func (_db *BufferedWriter )grow (_fa int ){if _db ._da ==nil &&_fa < _ef {_db ._da =make ([]byte ,_fa ,_ef );return ;};_gf :=len (_db ._da );if _db ._bf !=0{_gf ++;};_dd :=cap (_db ._da );switch {case _fa <=_dd /2-_gf :_de .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_db ._da ),cap (_db ._da ),_fa );
_de .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_dd ,_gf );copy (_db ._da ,_db ._da [_db .fullOffset ():]);
case _dd > _c -_dd -_fa :_de .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_ad :=make ([]byte ,2*_dd +_fa );copy (_ad ,_db ._da );_db ._da =_ad ;};_db ._da =_db ._da [:_gf +_fa ];
};func (_abc *Writer )Data ()[]byte {return _abc ._bfcf };func (_ge *BufferedWriter )tryGrowByReslice (_cfc int )bool {if _ada :=len (_ge ._da );_cfc <=cap (_ge ._da )-_ada {_ge ._da =_ge ._da [:_ada +_cfc ];return true ;};return false ;};func (_gbg *BufferedWriter )Write (d []byte )(int ,error ){_gbg .expandIfNeeded (len (d ));
if _gbg ._bf ==0{return _gbg .writeFullBytes (d ),nil ;};return _gbg .writeShiftedBytes (d ),nil ;};func (_ec *Reader )readBool ()(_cbg bool ,_eae error ){if _ec ._dab ==0{_ec ._ced ,_eae =_ec .readBufferByte ();if _eae !=nil {return false ,_eae ;};_cbg =(_ec ._ced &0x80)!=0;
_ec ._ced ,_ec ._dab =_ec ._ced &0x7f,7;return _cbg ,nil ;};_ec ._dab --;_cbg =(_ec ._ced &(1<<_ec ._dab ))!=0;_ec ._ced &=1<<_ec ._dab -1;return _cbg ,nil ;};func (_dbe *SubstreamReader )Seek (offset int64 ,whence int )(int64 ,error ){switch whence {case _e .SeekStart :_dbe ._efe =uint64 (offset );
case _e .SeekCurrent :_dbe ._efe +=uint64 (offset );case _e .SeekEnd :_dbe ._efe =_dbe ._fda +uint64 (offset );default:return 0,_ea .New ("\u0072\u0065\u0061d\u0065\u0072\u002e\u0053\u0075\u0062\u0073\u0074\u0072\u0065\u0061\u006d\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u0020\u0069\u006e\u0076\u0061\u006ci\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};_dbe ._abg =0;return int64 (_dbe ._efe ),nil ;};func NewWriterMSB (data []byte )*Writer {return &Writer {_bfcf :data ,_dcc :true }};func (_fgfa *SubstreamReader )ReadBool ()(bool ,error ){return _fgfa .readBool ()};func (_ceb *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _be .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );
};if len (_ceb ._da )-1< _ceb ._g {_ceb .expandIfNeeded (1);};_ff :=_ceb ._bf ;if _ceb ._eb {_ff =7-_ceb ._bf ;};_ceb ._da [_ceb ._g ]|=byte (uint16 (bit <<_ff )&0xff);_ceb ._bf ++;if _ceb ._bf ==8{_ceb ._g ++;_ceb ._bf =0;};return nil ;};func (_edf *Writer )WriteBits (bits uint64 ,number int )(_fca int ,_bab error ){const _dcbg ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";
if number < 0||number > 64{return 0,_be .Errorf (_dcbg ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};if number ==0{return 0,nil ;};_deb :=number /8;if _deb > 0{_cgg :=number -_deb *8;for _ede :=_deb -1;_ede >=0;_ede --{_gee :=byte ((bits >>uint (_ede *8+_cgg ))&0xff);if _bab =_edf .WriteByte (_gee );_bab !=nil {return _fca ,_be .Wrapf (_bab ,_dcbg ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_deb -_ede +1);
};};number -=_deb *8;if number ==0{return _deb ,nil ;};};var _edef int ;for _bdcf :=0;_bdcf < number ;_bdcf ++{if _edf ._dcc {_edef =int ((bits >>uint (number -1-_bdcf ))&0x1);}else {_edef =int (bits &0x1);bits >>=1;};if _bab =_edf .WriteBit (_edef );_bab !=nil {return _fca ,_be .Wrapf (_bab ,_dcbg ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_bdcf );
};};return _deb ,nil ;};func (_efg *Reader )Mark (){_efg ._gafb =_efg ._fg ;_efg ._adf =_efg ._dab ;_efg ._gbb =_efg ._ced ;_efg ._eba =_efg ._cfg ;};func (_ffg *SubstreamReader )readBufferByte ()(byte ,error ){if _ffg ._efe >=_ffg ._fda {return 0,_e .EOF ;
};if _ffg ._efe >=_ffg ._cab ||_ffg ._efe < _ffg ._bdc {if _cfa :=_ffg .fillBuffer ();_cfa !=nil {return 0,_cfa ;};};_cbfc :=_ffg ._fac [_ffg ._efe -_ffg ._bdc ];_ffg ._efe ++;return _cbfc ,nil ;};type SubstreamReader struct{_efe uint64 ;_eee StreamReader ;
_ffa uint64 ;_fda uint64 ;_fac []byte ;_bdc uint64 ;_cab uint64 ;_cdd byte ;_abg byte ;_dfg uint64 ;_eeg byte ;};func (_f *BufferedWriter )Data ()[]byte {return _f ._da };func (_bgb *Reader )Align ()(_dbc byte ){_dbc =_bgb ._dab ;_bgb ._dab =0;return _dbc };
func (_faf *Reader )ReadBool ()(bool ,error ){return _faf .readBool ()};var _ BinaryWriter =&Writer {};func (_fcbg *Writer )FinishByte (){if _fcbg ._efc ==0{return ;};_fcbg ._efc =0;_fcbg ._egf ++;};func (_edcb *SubstreamReader )readUnalignedByte ()(_ceab byte ,_ae error ){_adc :=_edcb ._abg ;
_ceab =_edcb ._cdd <<(8-_adc );_edcb ._cdd ,_ae =_edcb .readBufferByte ();if _ae !=nil {return 0,_ae ;};_ceab |=_edcb ._cdd >>_adc ;_edcb ._cdd &=1<<_adc -1;return _ceab ,nil ;};func (_fe *BufferedWriter )writeByte (_dc byte ){switch {case _fe ._bf ==0:_fe ._da [_fe ._g ]=_dc ;
_fe ._g ++;case _fe ._eb :_fe ._da [_fe ._g ]|=_dc >>_fe ._bf ;_fe ._g ++;_fe ._da [_fe ._g ]=byte (uint16 (_dc )<<(8-_fe ._bf )&0xff);default:_fe ._da [_fe ._g ]|=byte (uint16 (_dc )<<_fe ._bf &0xff);_fe ._g ++;_fe ._da [_fe ._g ]=_dc >>(8-_fe ._bf );
};};func (_fgg *SubstreamReader )BitPosition ()int {return int (_fgg ._abg )};func (_ffab *SubstreamReader )ReadBit ()(_fae int ,_cddb error ){_beec ,_cddb :=_ffab .readBool ();if _cddb !=nil {return 0,_cddb ;};if _beec {_fae =1;};return _fae ,nil ;};func (_edd *BufferedWriter )writeFullBytes (_dec []byte )int {_dad :=copy (_edd ._da [_edd .fullOffset ():],_dec );
_edd ._g +=_dad ;return _dad ;};func (_cg *BufferedWriter )byteCapacity ()int {_gaf :=len (_cg ._da )-_cg ._g ;if _cg ._bf !=0{_gaf --;};return _gaf ;};func (_ee *Reader )ReadByte ()(byte ,error ){if _ee ._dab ==0{return _ee .readBufferByte ();};return _ee .readUnalignedByte ();
};func (_dag *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;};_df :=int (_dag ._bf )+skip ;if _df >=0&&_df < 8{_dag ._bf =uint8 (_df );return nil ;};_df =int (_dag ._bf )+_dag ._g *8+skip ;if _df < 0{return _be .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_gb :=_df /8;_eg :=_df %8;_dag ._bf =uint8 (_eg );if _cd :=_gb -_dag ._g ;_cd > 0&&len (_dag ._da )-1< _gb {if _dag ._bf !=0{_cd ++;};_dag .expandIfNeeded (_cd );};_dag ._g =_gb ;return nil ;};func (_gga *Reader )ReadBit ()(_fgf int ,_cb error ){_acd ,_cb :=_gga .readBool ();
if _cb !=nil {return 0,_cb ;};if _acd {_fgf =1;};return _fgf ,nil ;};func (_gdd *SubstreamReader )Read (b []byte )(_ffaf int ,_eag error ){if _gdd ._efe >=_gdd ._fda {_de .Log .Trace ("\u0053\u0074\u0072e\u0061\u006d\u0050\u006fs\u003a\u0020\u0027\u0025\u0064\u0027\u0020>\u003d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027",_gdd ._efe ,_gdd ._fda );
return 0,_e .EOF ;};for ;_ffaf < len (b );_ffaf ++{if b [_ffaf ],_eag =_gdd .readUnalignedByte ();_eag !=nil {if _eag ==_e .EOF {return _ffaf ,nil ;};return 0,_eag ;};};return _ffaf ,nil ;};var _ BinaryWriter =&BufferedWriter {};