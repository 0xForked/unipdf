//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_be "encoding/binary";_gg "errors";_bd "github.com/unidoc/unipdf/v3/common";_f "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_g "io";);func (_fc *BufferedWriter )Len ()int {return _fc .byteCapacity ()};func (_aa *BufferedWriter )WriteByte (bt byte )error {if _aa ._gb > len (_aa ._ga )-1||(_aa ._gb ==len (_aa ._ga )-1&&_aa ._e !=0){_aa .expandIfNeeded (1);};_aa .writeByte (bt );return nil ;};func (_baf *SubstreamReader )readUnalignedByte ()(_gee byte ,_agd error ){_fabf :=_baf ._ced ;_gee =_baf ._efb <<(8-_fabf );_baf ._efb ,_agd =_baf .readBufferByte ();if _agd !=nil {return 0,_agd ;};_gee |=_baf ._efb >>_fabf ;_baf ._efb &=1<<_fabf -1;return _gee ,nil ;};var _ _g .ByteWriter =&BufferedWriter {};func (_gf *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;};_fg :=int (_gf ._e )+skip ;if _fg >=0&&_fg < 8{_gf ._e =uint8 (_fg );return nil ;};_fg =int (_gf ._e )+_gf ._gb *8+skip ;if _fg < 0{return _f .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_fb :=_fg /8;_gfe :=_fg %8;_gf ._e =uint8 (_gfe );if _ab :=_fb -_gf ._gb ;_ab > 0&&len (_gf ._ga )-1< _fb {if _gf ._e !=0{_ab ++;};_gf .expandIfNeeded (_ab );};_gf ._gb =_fb ;return nil ;};func (_fbd *SubstreamReader )ReadByte ()(byte ,error ){if _fbd ._ced ==0{return _fbd .readBufferByte ();};return _fbd .readUnalignedByte ();};func NewWriter (data []byte )*Writer {return &Writer {_ccbf :data }};func (_bfbf *Writer )WriteByte (c byte )error {return _bfbf .writeByte (c )};func (_gbg *Writer )FinishByte (){if _gbg ._ggd ==0{return ;};_gbg ._ggd =0;_gbg ._ac ++;};func (_dda *SubstreamReader )StreamPosition ()int64 {return int64 (_dda ._fag )};type BinaryWriter interface{BitWriter ;_g .Writer ;_g .ByteWriter ;Data ()[]byte ;};func (_cb *BufferedWriter )writeByte (_fa byte ){switch {case _cb ._e ==0:_cb ._ga [_cb ._gb ]=_fa ;_cb ._gb ++;case _cb ._ce :_cb ._ga [_cb ._gb ]|=_fa >>_cb ._e ;_cb ._gb ++;_cb ._ga [_cb ._gb ]=byte (uint16 (_fa )<<(8-_cb ._e )&0xff);default:_cb ._ga [_cb ._gb ]|=byte (uint16 (_fa )<<_cb ._e &0xff);_cb ._gb ++;_cb ._ga [_cb ._gb ]=_fa >>(8-_cb ._e );};};func (_bbc *SubstreamReader )readBool ()(_ddcb bool ,_cg error ){if _bbc ._ced ==0{_bbc ._efb ,_cg =_bbc .readBufferByte ();if _cg !=nil {return false ,_cg ;};_ddcb =(_bbc ._efb &0x80)!=0;_bbc ._efb ,_bbc ._ced =_bbc ._efb &0x7f,7;return _ddcb ,nil ;};_bbc ._ced --;_ddcb =(_bbc ._efb &(1<<_bbc ._ced ))!=0;_bbc ._efb &=1<<_bbc ._ced -1;return _ddcb ,nil ;};var _ _g .Writer =&BufferedWriter {};func (_ddd *SubstreamReader )ReadBool ()(bool ,error ){return _ddd .readBool ()};func (_caac *Writer )Write (p []byte )(int ,error ){if len (p )> _caac .byteCapacity (){return 0,_g .EOF ;};for _ ,_cdb :=range p {if _dcdad :=_caac .writeByte (_cdb );_dcdad !=nil {return 0,_dcdad ;};};return len (p ),nil ;};func (_dcdd *SubstreamReader )ReadUint32 ()(uint32 ,error ){_dae :=make ([]byte ,4);_ ,_ded :=_dcdd .Read (_dae );if _ded !=nil {return 0,_ded ;};return _be .BigEndian .Uint32 (_dae ),nil ;};func (_ca *BufferedWriter )WriteBits (bits uint64 ,number int )(_ed int ,_ff error ){const _df ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";if number < 0||number > 64{return 0,_f .Errorf (_df ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );};_cea :=number /8;if _cea > 0{_fcb :=number -_cea *8;for _ggb :=_cea -1;_ggb >=0;_ggb --{_fcbd :=byte ((bits >>uint (_ggb *8+_fcb ))&0xff);if _ff =_ca .WriteByte (_fcbd );_ff !=nil {return _ed ,_f .Wrapf (_ff ,_df ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_cea -_ggb +1);};};number -=_cea *8;if number ==0{return _cea ,nil ;};};var _dga int ;for _dc :=0;_dc < number ;_dc ++{if _ca ._ce {_dga =int ((bits >>uint (number -1-_dc ))&0x1);}else {_dga =int (bits &0x1);bits >>=1;};if _ff =_ca .WriteBit (_dga );_ff !=nil {return _ed ,_f .Wrapf (_ff ,_df ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_dc );};};return _cea ,nil ;};func (_dfd *SubstreamReader )BitPosition ()int {return int (_dfd ._ced )};func (_cag *Reader )ConsumeRemainingBits (){if _cag ._gca !=0{_ ,_ffc :=_cag .ReadBits (_cag ._gca );if _ffc !=nil {_bd .Log .Debug ("\u0043\u006f\u006e\u0073\u0075\u006d\u0065\u0052\u0065\u006da\u0069\u006e\u0069\u0067\u0042\u0069\u0074s\u0020\u0066\u0061\u0069\u006c\u0065\u0064\u003a\u0020\u0025\u0076",_ffc );};};};func (_db *BufferedWriter )expandIfNeeded (_abe int ){if !_db .tryGrowByReslice (_abe ){_db .grow (_abe );};};var _ BinaryWriter =&Writer {};var _ BinaryWriter =&BufferedWriter {};func (_gbdd *Reader )ReadBool ()(bool ,error ){return _gbdd .readBool ()};func (_ef *BufferedWriter )grow (_aff int ){if _ef ._ga ==nil &&_aff < _c {_ef ._ga =make ([]byte ,_aff ,_c );return ;};_bff :=len (_ef ._ga );if _ef ._e !=0{_bff ++;};_de :=cap (_ef ._ga );switch {case _aff <=_de /2-_bff :_bd .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_ef ._ga ),cap (_ef ._ga ),_aff );_bd .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_de ,_bff );copy (_ef ._ga ,_ef ._ga [_ef .fullOffset ():]);case _de > _d -_de -_aff :_bd .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_bc :=make ([]byte ,2*_de +_aff );copy (_bc ,_ef ._ga );_ef ._ga =_bc ;};_ef ._ga =_ef ._ga [:_bff +_aff ];};func (_cafa *SubstreamReader )Seek (offset int64 ,whence int )(int64 ,error ){switch whence {case _g .SeekStart :_cafa ._fag =uint64 (offset );case _g .SeekCurrent :_cafa ._fag +=uint64 (offset );case _g .SeekEnd :_cafa ._fag =_cafa ._gbe +uint64 (offset );default:return 0,_gg .New ("\u0072\u0065\u0061d\u0065\u0072\u002e\u0053\u0075\u0062\u0073\u0074\u0072\u0065\u0061\u006d\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u0020\u0069\u006e\u0076\u0061\u006ci\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");};_cafa ._ced =0;return int64 (_cafa ._fag ),nil ;};type BufferedWriter struct{_ga []byte ;_e uint8 ;_gb int ;_ce bool ;};func (_ddb *SubstreamReader )Read (b []byte )(_bge int ,_bdf error ){if _ddb ._fag >=_ddb ._gbe {_bd .Log .Trace ("\u0053\u0074\u0072e\u0061\u006d\u0050\u006fs\u003a\u0020\u0027\u0025\u0064\u0027\u0020>\u003d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027",_ddb ._fag ,_ddb ._gbe );return 0,_g .EOF ;};for ;_bge < len (b );_bge ++{if b [_bge ],_bdf =_ddb .readUnalignedByte ();_bdf !=nil {if _bdf ==_g .EOF {return _bge ,nil ;};return 0,_bdf ;};};return _bge ,nil ;};func _fbdb (_aba ,_fae uint64 )uint64 {if _aba < _fae {return _aba ;};return _fae ;};func (_cba *Writer )WriteBits (bits uint64 ,number int )(_fcbdd int ,_dbdg error ){const _gcbg ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";if number < 0||number > 64{return 0,_f .Errorf (_gcbg ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );};if number ==0{return 0,nil ;};_eed :=number /8;if _eed > 0{_aca :=number -_eed *8;for _efbb :=_eed -1;_efbb >=0;_efbb --{_fee :=byte ((bits >>uint (_efbb *8+_aca ))&0xff);if _dbdg =_cba .WriteByte (_fee );_dbdg !=nil {return _fcbdd ,_f .Wrapf (_dbdg ,_gcbg ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_eed -_efbb +1);};};number -=_eed *8;if number ==0{return _eed ,nil ;};};var _cbc int ;for _fcaf :=0;_fcaf < number ;_fcaf ++{if _cba ._eee {_cbc =int ((bits >>uint (number -1-_fcaf ))&0x1);}else {_cbc =int (bits &0x1);bits >>=1;};if _dbdg =_cba .WriteBit (_cbc );_dbdg !=nil {return _fcbdd ,_f .Wrapf (_dbdg ,_gcbg ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_fcaf );};};return _eed ,nil ;};func (_fbe *SubstreamReader )Length ()uint64 {return _fbe ._gbe };func (_eb *BufferedWriter )writeFullBytes (_gcg []byte )int {_dfgc :=copy (_eb ._ga [_eb .fullOffset ():],_gcg );_eb ._gb +=_dfgc ;return _dfgc ;};func (_gage *Reader )Mark (){_gage ._edf =_gage ._ffd ;_gage ._dcd =_gage ._gca };func (_a *BufferedWriter )Data ()[]byte {return _a ._ga };func (_fe *SubstreamReader )Reset (){_fe ._fag =_fe ._eded ;_fe ._ced =_fe ._dfgcg };func (_beef *Writer )ResetBit (){_beef ._ggd =0};const (_c =64;_d =int (^uint (0)>>1););func (_eba *Reader )Read (p []byte )(_efe int ,_gbf error ){if _eba ._gca ==0{return _eba .read (p );};for ;_efe < len (p );_efe ++{if p [_efe ],_gbf =_eba .readUnalignedByte ();_gbf !=nil {return 0,_gbf ;};};return _efe ,nil ;};type StreamReader interface{_g .Reader ;_g .ByteReader ;_g .Seeker ;Align ()byte ;BitPosition ()int ;Mark ();Length ()uint64 ;ReadBit ()(int ,error );ReadBits (_bgb byte )(uint64 ,error );ReadBool ()(bool ,error );ReadUint32 ()(uint32 ,error );Reset ();StreamPosition ()int64 ;};type SubstreamReader struct{_fag uint64 ;_eeg StreamReader ;_aac uint64 ;_gbe uint64 ;_eag []byte ;_ede uint64 ;_da uint64 ;_efb byte ;_ced byte ;_eded uint64 ;_dfgcg byte ;};func (_ee *BufferedWriter )ResetBitIndex (){_ee ._e =0};func (_bfa *SubstreamReader )Mark (){_bfa ._eded =_bfa ._fag ;_bfa ._dfgcg =_bfa ._ced };func (_ae *BufferedWriter )tryGrowByReslice (_gbd int )bool {if _deb :=len (_ae ._ga );_gbd <=cap (_ae ._ga )-_deb {_ae ._ga =_ae ._ga [:_deb +_gbd ];return true ;};return false ;};type Reader struct{_ddf []byte ;_bcc byte ;_gca byte ;_ffd int64 ;_gag int ;_cc int ;_edf int64 ;_dcd byte ;};func (_agfb *SubstreamReader )Align ()(_ffg byte ){_ffg =_agfb ._ced ;_agfb ._ced =0;return _ffg };func (_cdd *Reader )StreamPosition ()int64 {return _cdd ._ffd };func (_fabe *Writer )writeByte (_feec byte )error {if _fabe ._ac > len (_fabe ._ccbf )-1{return _g .EOF ;};if _fabe ._ac ==len (_fabe ._ccbf )-1&&_fabe ._ggd !=0{return _g .EOF ;};if _fabe ._ggd ==0{_fabe ._ccbf [_fabe ._ac ]=_feec ;_fabe ._ac ++;return nil ;};if _fabe ._eee {_fabe ._ccbf [_fabe ._ac ]|=_feec >>_fabe ._ggd ;_fabe ._ac ++;_fabe ._ccbf [_fabe ._ac ]=byte (uint16 (_feec )<<(8-_fabe ._ggd )&0xff);}else {_fabe ._ccbf [_fabe ._ac ]|=byte (uint16 (_feec )<<_fabe ._ggd &0xff);_fabe ._ac ++;_fabe ._ccbf [_fabe ._ac ]=_feec >>(8-_fabe ._ggd );};return nil ;};type Writer struct{_ccbf []byte ;_ggd uint8 ;_ac int ;_eee bool ;};func (_egb *Writer )byteCapacity ()int {_dfcg :=len (_egb ._ccbf )-_egb ._ac ;if _egb ._ggd !=0{_dfcg --;};return _dfcg ;};func (_af *BufferedWriter )Reset (){_af ._ga =_af ._ga [:0];_af ._gb =0;_af ._e =0};func (_ge *SubstreamReader )ReadBits (n byte )(_ddc uint64 ,_dfc error ){if n < _ge ._ced {_fd :=_ge ._ced -n ;_ddc =uint64 (_ge ._efb >>_fd );_ge ._efb &=1<<_fd -1;_ge ._ced =_fd ;return _ddc ,nil ;};if n > _ge ._ced {if _ge ._ced > 0{_ddc =uint64 (_ge ._efb );n -=_ge ._ced ;};var _bde byte ;for n >=8{_bde ,_dfc =_ge .readBufferByte ();if _dfc !=nil {return 0,_dfc ;};_ddc =_ddc <<8+uint64 (_bde );n -=8;};if n > 0{if _ge ._efb ,_dfc =_ge .readBufferByte ();_dfc !=nil {return 0,_dfc ;};_bee :=8-n ;_ddc =_ddc <<n +uint64 (_ge ._efb >>_bee );_ge ._efb &=1<<_bee -1;_ge ._ced =_bee ;}else {_ge ._ced =0;};return _ddc ,nil ;};_ge ._ced =0;return uint64 (_ge ._efb ),nil ;};func (_dba *SubstreamReader )fillBuffer ()error {if uint64 (_dba ._eeg .StreamPosition ())!=_dba ._fag +_dba ._aac {_ ,_cef :=_dba ._eeg .Seek (int64 (_dba ._fag +_dba ._aac ),_g .SeekStart );if _cef !=nil {return _cef ;};};_dba ._ede =uint64 (_dba ._fag );_aace :=_fbdb (uint64 (len (_dba ._eag )),_dba ._gbe -_dba ._fag );_ega :=make ([]byte ,_aace );_fgga ,_fab :=_dba ._eeg .Read (_ega );if _fab !=nil {return _fab ;};for _geg :=uint64 (0);_geg < _aace ;_geg ++{_dba ._eag [_geg ]=_ega [_geg ];};_dba ._da =_dba ._ede +uint64 (_fgga );return nil ;};func (_daef *Writer )SkipBits (skip int )error {const _gac ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";if skip ==0{return nil ;};_aaba :=int (_daef ._ggd )+skip ;if _aaba >=0&&_aaba < 8{_daef ._ggd =uint8 (_aaba );return nil ;};_aaba =int (_daef ._ggd )+_daef ._ac *8+skip ;if _aaba < 0{return _f .Errorf (_gac ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_fdf :=_aaba /8;_afe :=_aaba %8;_bd .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");_bd .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_daef ._ggd ,_daef ._ac ,int (_daef ._ggd )+(_daef ._ac )*8,len (_daef ._ccbf ),cap (_daef ._ccbf ));_bd .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_aaba ,_afe );_daef ._ggd =uint8 (_afe );if _dce :=_fdf -_daef ._ac ;_dce > 0&&len (_daef ._ccbf )-1< _fdf {_bd .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_dce );return _f .Errorf (_gac ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_daef ._ac =_fdf ;_bd .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_daef ._ggd ,_daef ._ac );return nil ;};func (_fdg *SubstreamReader )readBufferByte ()(byte ,error ){if _fdg ._fag >=_fdg ._gbe {return 0,_g .EOF ;};if _fdg ._fag >=_fdg ._da ||_fdg ._fag < _fdg ._ede {if _bcg :=_fdg .fillBuffer ();_bcg !=nil {return 0,_bcg ;};};_cae :=_fdg ._eag [_fdg ._fag -_fdg ._ede ];_fdg ._fag ++;return _cae ,nil ;};func (_fgd *Reader )BitPosition ()int {return int (_fgd ._gca )};func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_ce :true }};func (_ccc *Reader )ReadUint32 ()(uint32 ,error ){_abb :=make ([]byte ,4);_ ,_agf :=_ccc .Read (_abb );if _agf !=nil {return 0,_agf ;};return _be .BigEndian .Uint32 (_abb ),nil ;};func (_bbac *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _bbac .writeBit (uint8 (bit ));};return _f .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");};func (_dg *BufferedWriter )FinishByte (){if _dg ._e ==0{return ;};_dg ._e =0;_dg ._gb ++;};func (_gc *BufferedWriter )Write (d []byte )(int ,error ){_gc .expandIfNeeded (len (d ));if _gc ._e ==0{return _gc .writeFullBytes (d ),nil ;};return _gc .writeShiftedBytes (d ),nil ;};func (_bcb *BufferedWriter )writeShiftedBytes (_aab []byte )int {for _ ,_bgg :=range _aab {_bcb .writeByte (_bgg );};return len (_aab );};func (_gcb *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _f .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );};if len (_gcb ._ga )-1< _gcb ._gb {_gcb .expandIfNeeded (1);};_abc :=_gcb ._e ;if _gcb ._ce {_abc =7-_gcb ._e ;};_gcb ._ga [_gcb ._gb ]|=byte (uint16 (bit <<_abc )&0xff);_gcb ._e ++;if _gcb ._e ==8{_gcb ._gb ++;_gcb ._e =0;};return nil ;};func (_cbf *Reader )Reset (){_cbf ._ffd =_cbf ._edf ;_cbf ._gca =_cbf ._dcd };func NewSubstreamReader (r StreamReader ,offset ,length uint64 )(*SubstreamReader ,error ){if r ==nil {return nil ,_gg .New ("\u0072o\u006ft\u0020\u0072\u0065\u0061\u0064e\u0072\u0020i\u0073\u0020\u006e\u0069\u006c");};_bd .Log .Trace ("\u004e\u0065\u0077\u0053\u0075\u0062\u0073\u0074r\u0065\u0061\u006dRe\u0061\u0064\u0065\u0072\u0020\u0061t\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u003a\u0020\u0025\u0064\u0020\u0077\u0069\u0074h\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a \u0025\u0064",offset ,length );return &SubstreamReader {_eeg :r ,_aac :offset ,_gbe :length ,_eag :make ([]byte ,length )},nil ;};var (_ _g .Reader =&Reader {};_ _g .ByteReader =&Reader {};_ _g .Seeker =&Reader {};_ StreamReader =&Reader {};);func (_dfg *BufferedWriter )fullOffset ()int {_dbc :=_dfg ._gb ;if _dfg ._e !=0{_dbc ++;};return _dbc ;};func NewReader (data []byte )*Reader {return &Reader {_ddf :data }};func NewWriterMSB (data []byte )*Writer {return &Writer {_ccbf :data ,_eee :true }};func (_bg *BufferedWriter )byteCapacity ()int {_gd :=len (_bg ._ga )-_bg ._gb ;if _bg ._e !=0{_gd --;};return _gd ;};func (_ffe *SubstreamReader )ReadBit ()(_ec int ,_dfda error ){_ccb ,_dfda :=_ffe .readBool ();if _dfda !=nil {return 0,_dfda ;};if _ccb {_ec =1;};return _ec ,nil ;};func (_fac *SubstreamReader )Offset ()uint64 {return _fac ._aac };type BitWriter interface{WriteBit (_fcc int )error ;WriteBits (_ddg uint64 ,_ada int )(_ag int ,_affa error );FinishByte ();SkipBits (_caf int )error ;};func (_cd *Reader )ReadByte ()(byte ,error ){if _cd ._gca ==0{return _cd .readBufferByte ();};return _cd .readUnalignedByte ();};func (_eg *Reader )read (_bfb []byte )(int ,error ){if _eg ._ffd >=int64 (len (_eg ._ddf )){return 0,_g .EOF ;};_eg ._cc =-1;_dea :=copy (_bfb ,_eg ._ddf [_eg ._ffd :]);_eg ._ffd +=int64 (_dea );return _dea ,nil ;};func (_ffb *Reader )readBufferByte ()(byte ,error ){if _ffb ._ffd >=int64 (len (_ffb ._ddf )){return 0,_g .EOF ;};_ffb ._cc =-1;_dec :=_ffb ._ddf [_ffb ._ffd ];_ffb ._ffd ++;_ffb ._gag =int (_dec );return _dec ,nil ;};func (_fca *Reader )ReadBit ()(_dbb int ,_bfd error ){_dgb ,_bfd :=_fca .readBool ();if _bfd !=nil {return 0,_bfd ;};if _dgb {_dbb =1;};return _dbb ,nil ;};func (_bdef *Writer )writeBit (_gcaf uint8 )error {if len (_bdef ._ccbf )-1< _bdef ._ac {return _g .EOF ;};_cgf :=_bdef ._ggd ;if _bdef ._eee {_cgf =7-_bdef ._ggd ;};_bdef ._ccbf [_bdef ._ac ]|=byte (uint16 (_gcaf <<_cgf )&0xff);_bdef ._ggd ++;if _bdef ._ggd ==8{_bdef ._ac ++;_bdef ._ggd =0;};return nil ;};func (_ffgd *Writer )Data ()[]byte {return _ffgd ._ccbf };func (_gcc *Writer )UseMSB ()bool {return _gcc ._eee };func (_gde *Reader )Align ()(_ba byte ){_ba =_gde ._gca ;_gde ._gca =0;return _ba };func (_gfef *Reader )readUnalignedByte ()(_gaa byte ,_abgf error ){_ggbg :=_gfef ._gca ;_gaa =_gfef ._bcc <<(8-_ggbg );_gfef ._bcc ,_abgf =_gfef .readBufferByte ();if _abgf !=nil {return 0,_abgf ;};_gaa |=_gfef ._bcc >>_ggbg ;_gfef ._bcc &=1<<_ggbg -1;return _gaa ,nil ;};func (_fcf *Reader )ReadBits (n byte )(_ggc uint64 ,_aabb error ){if n < _fcf ._gca {_fgf :=_fcf ._gca -n ;_ggc =uint64 (_fcf ._bcc >>_fgf );_fcf ._bcc &=1<<_fgf -1;_fcf ._gca =_fgf ;return _ggc ,nil ;};if n > _fcf ._gca {if _fcf ._gca > 0{_ggc =uint64 (_fcf ._bcc );n -=_fcf ._gca ;};for n >=8{_dcda ,_ea :=_fcf .readBufferByte ();if _ea !=nil {return 0,_ea ;};_ggc =_ggc <<8+uint64 (_dcda );n -=8;};if n > 0{if _fcf ._bcc ,_aabb =_fcf .readBufferByte ();_aabb !=nil {return 0,_aabb ;};_gfed :=8-n ;_ggc =_ggc <<n +uint64 (_fcf ._bcc >>_gfed );_fcf ._bcc &=1<<_gfed -1;_fcf ._gca =_gfed ;}else {_fcf ._gca =0;};return _ggc ,nil ;};_fcf ._gca =0;return uint64 (_fcf ._bcc ),nil ;};func (_ddgg *Reader )Length ()uint64 {return uint64 (len (_ddgg ._ddf ))};func (_aea *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_aea ._cc =-1;var _bad int64 ;switch whence {case _g .SeekStart :_bad =offset ;case _g .SeekCurrent :_bad =_aea ._ffd +offset ;case _g .SeekEnd :_bad =int64 (len (_aea ._ddf ))+offset ;default:return 0,_gg .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");};if _bad < 0{return 0,_gg .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");};_aea ._ffd =_bad ;_aea ._gca =0;return _bad ,nil ;};func (_bba *Reader )readBool ()(_gagg bool ,_cf error ){if _bba ._gca ==0{_bba ._bcc ,_cf =_bba .readBufferByte ();if _cf !=nil {return false ,_cf ;};_gagg =(_bba ._bcc &0x80)!=0;_bba ._bcc ,_bba ._gca =_bba ._bcc &0x7f,7;return _gagg ,nil ;};_bba ._gca --;_gagg =(_bba ._bcc &(1<<_bba ._gca ))!=0;_bba ._bcc &=1<<_bba ._gca -1;return _gagg ,nil ;};