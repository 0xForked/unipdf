//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_a "encoding/binary";_e "errors";_b "github.com/unidoc/unipdf/v3/common";_ad "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_g "io";);func (_cga *SubstreamReader )ReadUint32 ()(uint32 ,error ){_ddd :=make ([]byte ,4);_ ,_eada :=_cga .Read (_ddd );
if _eada !=nil {return 0,_eada ;};return _a .BigEndian .Uint32 (_ddd ),nil ;};func (_fbbc *Reader )ReadUint32 ()(uint32 ,error ){_aeb :=make ([]byte ,4);_ ,_ac :=_fbbc .Read (_aeb );if _ac !=nil {return 0,_ac ;};return _a .BigEndian .Uint32 (_aeb ),nil ;
};func (_gg *BufferedWriter )byteCapacity ()int {_cc :=len (_gg ._fa )-_gg ._gb ;if _gg ._ae !=0{_cc --;};return _cc ;};func (_dda *SubstreamReader )ReadBits (n byte )(_ecd uint64 ,_bde error ){if n < _dda ._eec {_cae :=_dda ._eec -n ;_ecd =uint64 (_dda ._dbc >>_cae );
_dda ._dbc &=1<<_cae -1;_dda ._eec =_cae ;return _ecd ,nil ;};if n > _dda ._eec {if _dda ._eec > 0{_ecd =uint64 (_dda ._dbc );n -=_dda ._eec ;};var _faa byte ;for n >=8{_faa ,_bde =_dda .readBufferByte ();if _bde !=nil {return 0,_bde ;};_ecd =_ecd <<8+uint64 (_faa );
n -=8;};if n > 0{if _dda ._dbc ,_bde =_dda .readBufferByte ();_bde !=nil {return 0,_bde ;};_bec :=8-n ;_ecd =_ecd <<n +uint64 (_dda ._dbc >>_bec );_dda ._dbc &=1<<_bec -1;_dda ._eec =_bec ;}else {_dda ._eec =0;};return _ecd ,nil ;};_dda ._eec =0;return uint64 (_dda ._dbc ),nil ;
};const (_bg =64;_aa =int (^uint (0)>>1););var _ BinaryWriter =&BufferedWriter {};func (_cec *Writer )WriteBits (bits uint64 ,number int )(_gdf int ,_efee error ){const _eagf ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";
if number < 0||number > 64{return 0,_ad .Errorf (_eagf ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};if number ==0{return 0,nil ;};_ffdd :=number /8;if _ffdd > 0{_adb :=number -_ffdd *8;for _cce :=_ffdd -1;_cce >=0;_cce --{_edgf :=byte ((bits >>uint (_cce *8+_adb ))&0xff);if _efee =_cec .WriteByte (_edgf );_efee !=nil {return _gdf ,_ad .Wrapf (_efee ,_eagf ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_ffdd -_cce +1);
};};number -=_ffdd *8;if number ==0{return _ffdd ,nil ;};};var _cag int ;for _bdde :=0;_bdde < number ;_bdde ++{if _cec ._afg {_cag =int ((bits >>uint (number -1-_bdde ))&0x1);}else {_cag =int (bits &0x1);bits >>=1;};if _efee =_cec .WriteBit (_cag );_efee !=nil {return _gdf ,_ad .Wrapf (_efee ,_eagf ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_bdde );
};};return _ffdd ,nil ;};func (_gga *Reader )Reset (){_gga ._bfe =_gga ._bfcg ;_gga ._bdf =_gga ._bc ;_gga ._gbdg =_gga ._fg ;_gga ._aad =_gga ._ffd ;};func (_ba *SubstreamReader )Reset (){_ba ._fagc =_ba ._ab ;_ba ._eec =_ba ._dba };func (_dd *BufferedWriter )ResetBitIndex (){_dd ._ae =0};
func (_gc *Reader )ReadBit ()(_eed int ,_fafg error ){_dag ,_fafg :=_gc .readBool ();if _fafg !=nil {return 0,_fafg ;};if _dag {_eed =1;};return _eed ,nil ;};type SubstreamReader struct{_fagc uint64 ;_bbe StreamReader ;_gde uint64 ;_dbe uint64 ;_bda []byte ;
_adfd uint64 ;_gbda uint64 ;_dbc byte ;_eec byte ;_ab uint64 ;_dba byte ;};func (_edg *Writer )Data ()[]byte {return _edg ._bgg };func (_fcc *BufferedWriter )expandIfNeeded (_bbc int ){if !_fcc .tryGrowByReslice (_bbc ){_fcc .grow (_bbc );};};func (_cfa *BufferedWriter )Len ()int {return _cfa .byteCapacity ()};
func (_daa *SubstreamReader )Align ()(_ec byte ){_ec =_daa ._eec ;_daa ._eec =0;return _ec };func (_dgf *SubstreamReader )Length ()uint64 {return _dgf ._dbe };type Reader struct{_fbe []byte ;_gbdg byte ;_bdf byte ;_bfe int64 ;_aad int ;_cca int ;_bfcg int64 ;
_bc byte ;_fg byte ;_ffd int ;};type BitWriter interface{WriteBit (_ggf int )error ;WriteBits (_faf uint64 ,_efe int )(_bff int ,_bba error );FinishByte ();SkipBits (_gbd int )error ;};func (_adf *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;
};_eb :=int (_adf ._ae )+skip ;if _eb >=0&&_eb < 8{_adf ._ae =uint8 (_eb );return nil ;};_eb =int (_adf ._ae )+_adf ._gb *8+skip ;if _eb < 0{return _ad .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_ee :=_eb /8;_bf :=_eb %8;_adf ._ae =uint8 (_bf );if _dg :=_ee -_adf ._gb ;_dg > 0&&len (_adf ._fa )-1< _ee {if _adf ._ae !=0{_dg ++;};_adf .expandIfNeeded (_dg );};_adf ._gb =_ee ;return nil ;};func (_ea *BufferedWriter )writeShiftedBytes (_bbd []byte )int {for _ ,_ed :=range _bbd {_ea .writeByte (_ed );
};return len (_bbd );};func (_cb *BufferedWriter )Write (d []byte )(int ,error ){_cb .expandIfNeeded (len (d ));if _cb ._ae ==0{return _cb .writeFullBytes (d ),nil ;};return _cb .writeShiftedBytes (d ),nil ;};func (_edc *SubstreamReader )fillBuffer ()error {if uint64 (_edc ._bbe .StreamPosition ())!=_edc ._fagc +_edc ._gde {_ ,_gcg :=_edc ._bbe .Seek (int64 (_edc ._fagc +_edc ._gde ),_g .SeekStart );
if _gcg !=nil {return _gcg ;};};_edc ._adfd =_edc ._fagc ;_eca :=_bgd (uint64 (len (_edc ._bda )),_edc ._dbe -_edc ._fagc );_bfa :=make ([]byte ,_eca );_eef ,_gbee :=_edc ._bbe .Read (_bfa );if _gbee !=nil {return _gbee ;};for _bge :=uint64 (0);_bge < _eca ;
_bge ++{_edc ._bda [_bge ]=_bfa [_bge ];};_edc ._gbda =_edc ._adfd +uint64 (_eef );return nil ;};func (_fed *SubstreamReader )ReadByte ()(byte ,error ){if _fed ._eec ==0{return _fed .readBufferByte ();};return _fed .readUnalignedByte ();};func (_fgb *Reader )Read (p []byte )(_be int ,_adgd error ){if _fgb ._bdf ==0{return _fgb .read (p );
};for ;_be < len (p );_be ++{if p [_be ],_adgd =_fgb .readUnalignedByte ();_adgd !=nil {return 0,_adgd ;};};return _be ,nil ;};type StreamReader interface{_g .Reader ;_g .ByteReader ;_g .Seeker ;Align ()byte ;BitPosition ()int ;Mark ();Length ()uint64 ;
ReadBit ()(int ,error );ReadBits (_dbd byte )(uint64 ,error );ReadBool ()(bool ,error );ReadUint32 ()(uint32 ,error );Reset ();StreamPosition ()int64 ;};func (_cgf *Writer )writeBit (_aec uint8 )error {if len (_cgf ._bgg )-1< _cgf ._bfb {return _g .EOF ;
};_eefb :=_cgf ._eae ;if _cgf ._afg {_eefb =7-_cgf ._eae ;};_cgf ._bgg [_cgf ._bfb ]|=byte (uint16 (_aec <<_eefb )&0xff);_cgf ._eae ++;if _cgf ._eae ==8{_cgf ._bfb ++;_cgf ._eae =0;};return nil ;};func (_cf *BufferedWriter )FinishByte (){if _cf ._ae ==0{return ;
};_cf ._ae =0;_cf ._gb ++;};func (_bef *Writer )SkipBits (skip int )error {const _ffe ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";if skip ==0{return nil ;};_ebag :=int (_bef ._eae )+skip ;if _ebag >=0&&_ebag < 8{_bef ._eae =uint8 (_ebag );
return nil ;};_ebag =int (_bef ._eae )+_bef ._bfb *8+skip ;if _ebag < 0{return _ad .Errorf (_ffe ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_beb :=_ebag /8;_cebe :=_ebag %8;_b .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");
_b .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_bef ._eae ,_bef ._bfb ,int (_bef ._eae )+(_bef ._bfb )*8,len (_bef ._bgg ),cap (_bef ._bgg ));
_b .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_ebag ,_cebe );_bef ._eae =uint8 (_cebe );
if _baa :=_beb -_bef ._bfb ;_baa > 0&&len (_bef ._bgg )-1< _beb {_b .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_baa );return _ad .Errorf (_ffe ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_bef ._bfb =_beb ;_b .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_bef ._eae ,_bef ._bfb );return nil ;};var _ _g .ByteWriter =&BufferedWriter {};
func (_gf *Reader )ReadBits (n byte )(_ada uint64 ,_ffg error ){if n < _gf ._bdf {_fbga :=_gf ._bdf -n ;_ada =uint64 (_gf ._gbdg >>_fbga );_gf ._gbdg &=1<<_fbga -1;_gf ._bdf =_fbga ;return _ada ,nil ;};if n > _gf ._bdf {if _gf ._bdf > 0{_ada =uint64 (_gf ._gbdg );
n -=_gf ._bdf ;};for n >=8{_bbfe ,_bgf :=_gf .readBufferByte ();if _bgf !=nil {return 0,_bgf ;};_ada =_ada <<8+uint64 (_bbfe );n -=8;};if n > 0{if _gf ._gbdg ,_ffg =_gf .readBufferByte ();_ffg !=nil {return 0,_ffg ;};_ead :=8-n ;_ada =_ada <<n +uint64 (_gf ._gbdg >>_ead );
_gf ._gbdg &=1<<_ead -1;_gf ._bdf =_ead ;}else {_gf ._bdf =0;};return _ada ,nil ;};_gf ._bdf =0;return uint64 (_gf ._gbdg ),nil ;};func (_eba *BufferedWriter )writeByte (_ddg byte ){switch {case _eba ._ae ==0:_eba ._fa [_eba ._gb ]=_ddg ;_eba ._gb ++;case _eba ._d :_eba ._fa [_eba ._gb ]|=_ddg >>_eba ._ae ;
_eba ._gb ++;_eba ._fa [_eba ._gb ]=byte (uint16 (_ddg )<<(8-_eba ._ae )&0xff);default:_eba ._fa [_eba ._gb ]|=byte (uint16 (_ddg )<<_eba ._ae &0xff);_eba ._gb ++;_eba ._fa [_eba ._gb ]=_ddg >>(8-_eba ._ae );};};func (_gda *Reader )ConsumeRemainingBits ()(uint64 ,error ){if _gda ._bdf !=0{return _gda .ReadBits (_gda ._bdf );
};return 0,nil ;};type BinaryWriter interface{BitWriter ;_g .Writer ;_g .ByteWriter ;Data ()[]byte ;};func NewWriterMSB (data []byte )*Writer {return &Writer {_bgg :data ,_afg :true }};func (_cfb *SubstreamReader )Seek (offset int64 ,whence int )(int64 ,error ){switch whence {case _g .SeekStart :_cfb ._fagc =uint64 (offset );
case _g .SeekCurrent :_cfb ._fagc +=uint64 (offset );case _g .SeekEnd :_cfb ._fagc =_cfb ._dbe +uint64 (offset );default:return 0,_e .New ("\u0072\u0065\u0061d\u0065\u0072\u002e\u0053\u0075\u0062\u0073\u0074\u0072\u0065\u0061\u006d\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u0020\u0069\u006e\u0076\u0061\u006ci\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};_cfb ._eec =0;return int64 (_cfb ._fagc ),nil ;};var (_ _g .Reader =&Reader {};_ _g .ByteReader =&Reader {};_ _g .Seeker =&Reader {};_ StreamReader =&Reader {};);func (_cee *Writer )WriteByte (c byte )error {return _cee .writeByte (c )};func (_fag *Reader )read (_ddb []byte )(int ,error ){if _fag ._bfe >=int64 (len (_fag ._fbe )){return 0,_g .EOF ;
};_fag ._cca =-1;_dbb :=copy (_ddb ,_fag ._fbe [_fag ._bfe :]);_fag ._bfe +=int64 (_dbb );return _dbb ,nil ;};func (_df *SubstreamReader )Offset ()uint64 {return _df ._gde };func (_ged *SubstreamReader )StreamPosition ()int64 {return int64 (_ged ._fagc )};
func (_aadd *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_aadd ._cca =-1;var _ffb int64 ;switch whence {case _g .SeekStart :_ffb =offset ;case _g .SeekCurrent :_ffb =_aadd ._bfe +offset ;case _g .SeekEnd :_ffb =int64 (len (_aadd ._fbe ))+offset ;
default:return 0,_e .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");};if _ffb < 0{return 0,_e .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");
};_aadd ._bfe =_ffb ;_aadd ._bdf =0;return _ffb ,nil ;};func (_ga *SubstreamReader )Mark (){_ga ._ab =_ga ._fagc ;_ga ._dba =_ga ._eec };func (_bed *Reader )readBool ()(_aca bool ,_de error ){if _bed ._bdf ==0{_bed ._gbdg ,_de =_bed .readBufferByte ();
if _de !=nil {return false ,_de ;};_aca =(_bed ._gbdg &0x80)!=0;_bed ._gbdg ,_bed ._bdf =_bed ._gbdg &0x7f,7;return _aca ,nil ;};_bed ._bdf --;_aca =(_bed ._gbdg &(1<<_bed ._bdf ))!=0;_bed ._gbdg &=1<<_bed ._bdf -1;return _aca ,nil ;};func (_baf *SubstreamReader )readBool ()(_ceb bool ,_adge error ){if _baf ._eec ==0{_baf ._dbc ,_adge =_baf .readBufferByte ();
if _adge !=nil {return false ,_adge ;};_ceb =(_baf ._dbc &0x80)!=0;_baf ._dbc ,_baf ._eec =_baf ._dbc &0x7f,7;return _ceb ,nil ;};_baf ._eec --;_ceb =(_baf ._dbc &(1<<_baf ._eec ))!=0;_baf ._dbc &=1<<_baf ._eec -1;return _ceb ,nil ;};func (_caea *Writer )Write (p []byte )(int ,error ){if len (p )> _caea .byteCapacity (){return 0,_g .EOF ;
};for _ ,_bfd :=range p {if _cgb :=_caea .writeByte (_bfd );_cgb !=nil {return 0,_cgb ;};};return len (p ),nil ;};type BufferedWriter struct{_fa []byte ;_ae uint8 ;_gb int ;_d bool ;};func (_ddc *Reader )Mark (){_ddc ._bfcg =_ddc ._bfe ;_ddc ._bc =_ddc ._bdf ;
_ddc ._fg =_ddc ._gbdg ;_ddc ._ffd =_ddc ._aad ;};var _ BinaryWriter =&Writer {};func (_fgbd *Writer )writeByte (_aae byte )error {if _fgbd ._bfb > len (_fgbd ._bgg )-1{return _g .EOF ;};if _fgbd ._bfb ==len (_fgbd ._bgg )-1&&_fgbd ._eae !=0{return _g .EOF ;
};if _fgbd ._eae ==0{_fgbd ._bgg [_fgbd ._bfb ]=_aae ;_fgbd ._bfb ++;return nil ;};if _fgbd ._afg {_fgbd ._bgg [_fgbd ._bfb ]|=_aae >>_fgbd ._eae ;_fgbd ._bfb ++;_fgbd ._bgg [_fgbd ._bfb ]=byte (uint16 (_aae )<<(8-_fgbd ._eae )&0xff);}else {_fgbd ._bgg [_fgbd ._bfb ]|=byte (uint16 (_aae )<<_fgbd ._eae &0xff);
_fgbd ._bfb ++;_fgbd ._bgg [_fgbd ._bfb ]=_aae >>(8-_fgbd ._eae );};return nil ;};func (_afc *Writer )FinishByte (){if _afc ._eae ==0{return ;};_afc ._eae =0;_afc ._bfb ++;};type Writer struct{_bgg []byte ;_eae uint8 ;_bfb int ;_afg bool ;};func (_bdd *Reader )Length ()uint64 {return uint64 (len (_bdd ._fbe ))};
func (_gfa *Reader )ReadBool ()(bool ,error ){return _gfa .readBool ()};func (_eg *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _ad .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );
};if len (_eg ._fa )-1< _eg ._gb {_eg .expandIfNeeded (1);};_cba :=_eg ._ae ;if _eg ._d {_cba =7-_eg ._ae ;};_eg ._fa [_eg ._gb ]|=byte (uint16 (bit <<_cba )&0xff);_eg ._ae ++;if _eg ._ae ==8{_eg ._gb ++;_eg ._ae =0;};return nil ;};func (_af *SubstreamReader )Read (b []byte )(_dac int ,_dgff error ){if _af ._fagc >=_af ._dbe {_b .Log .Trace ("\u0053\u0074\u0072e\u0061\u006d\u0050\u006fs\u003a\u0020\u0027\u0025\u0064\u0027\u0020>\u003d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027",_af ._fagc ,_af ._dbe );
return 0,_g .EOF ;};for ;_dac < len (b );_dac ++{if b [_dac ],_dgff =_af .readUnalignedByte ();_dgff !=nil {if _dgff ==_g .EOF {return _dac ,nil ;};return 0,_dgff ;};};return _dac ,nil ;};func (_feb *BufferedWriter )fullOffset ()int {_adg :=_feb ._gb ;
if _feb ._ae !=0{_adg ++;};return _adg ;};func (_abe *SubstreamReader )ReadBool ()(bool ,error ){return _abe .readBool ()};func (_aef *Reader )StreamPosition ()int64 {return _aef ._bfe };func (_gdb *Writer )byteCapacity ()int {_bcd :=len (_gdb ._bgg )-_gdb ._bfb ;
if _gdb ._eae !=0{_bcd --;};return _bcd ;};func (_dgfb *SubstreamReader )readUnalignedByte ()(_eee byte ,_ece error ){_daga :=_dgfb ._eec ;_eee =_dgfb ._dbc <<(8-_daga );_dgfb ._dbc ,_ece =_dgfb .readBufferByte ();if _ece !=nil {return 0,_ece ;};_eee |=_dgfb ._dbc >>_daga ;
_dgfb ._dbc &=1<<_daga -1;return _eee ,nil ;};func (_fec *SubstreamReader )readBufferByte ()(byte ,error ){if _fec ._fagc >=_fec ._dbe {return 0,_g .EOF ;};if _fec ._fagc >=_fec ._gbda ||_fec ._fagc < _fec ._adfd {if _bfcd :=_fec .fillBuffer ();_bfcd !=nil {return 0,_bfcd ;
};};_fce :=_fec ._bda [_fec ._fagc -_fec ._adfd ];_fec ._fagc ++;return _fce ,nil ;};func (_cfg *Reader )readBufferByte ()(byte ,error ){if _cfg ._bfe >=int64 (len (_cfg ._fbe )){return 0,_g .EOF ;};_cfg ._cca =-1;_ced :=_cfg ._fbe [_cfg ._bfe ];_cfg ._bfe ++;
_cfg ._aad =int (_ced );return _ced ,nil ;};func (_fc *BufferedWriter )Data ()[]byte {return _fc ._fa };func NewWriter (data []byte )*Writer {return &Writer {_bgg :data }};func NewReader (data []byte )*Reader {return &Reader {_fbe :data }};func (_egg *Reader )BitPosition ()int {return int (_egg ._bdf )};
func (_gdg *Reader )readUnalignedByte ()(_gfd byte ,_aee error ){_gcd :=_gdg ._bdf ;_gfd =_gdg ._gbdg <<(8-_gcd );_gdg ._gbdg ,_aee =_gdg .readBufferByte ();if _aee !=nil {return 0,_aee ;};_gfd |=_gdg ._gbdg >>_gcd ;_gdg ._gbdg &=1<<_gcd -1;return _gfd ,nil ;
};func (_ag *SubstreamReader )ReadBit ()(_dfb int ,_bdgb error ){_ecg ,_bdgb :=_ag .readBool ();if _bdgb !=nil {return 0,_bdgb ;};if _ecg {_dfb =1;};return _dfb ,nil ;};func (_fb *BufferedWriter )writeFullBytes (_da []byte )int {_bfc :=copy (_fb ._fa [_fb .fullOffset ():],_da );
_fb ._gb +=_bfc ;return _bfc ;};func (_ff *BufferedWriter )WriteByte (bt byte )error {if _ff ._gb > len (_ff ._fa )-1||(_ff ._gb ==len (_ff ._fa )-1&&_ff ._ae !=0){_ff .expandIfNeeded (1);};_ff .writeByte (bt );return nil ;};func (_fbb *Reader )Align ()(_cfeb byte ){_cfeb =_fbb ._bdf ;
_fbb ._bdf =0;return _cfeb };func (_bbb *Reader )ReadByte ()(byte ,error ){if _bbb ._bdf ==0{return _bbb .readBufferByte ();};return _bbb .readUnalignedByte ();};func (_ddga *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _ddga .writeBit (uint8 (bit ));
};return _ad .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");};var _ _g .Writer =&BufferedWriter {};func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_d :true }};
func (_cd *BufferedWriter )grow (_bgb int ){if _cd ._fa ==nil &&_bgb < _bg {_cd ._fa =make ([]byte ,_bgb ,_bg );return ;};_db :=len (_cd ._fa );if _cd ._ae !=0{_db ++;};_cff :=cap (_cd ._fa );switch {case _bgb <=_cff /2-_db :_b .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_cd ._fa ),cap (_cd ._fa ),_bgb );
_b .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_cff ,_db );copy (_cd ._fa ,_cd ._fa [_cd .fullOffset ():]);
case _cff > _aa -_cff -_bgb :_b .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_eea :=make ([]byte ,2*_cff +_bgb );copy (_eea ,_cd ._fa );_cd ._fa =_eea ;};_cd ._fa =_cd ._fa [:_db +_bgb ];
};func NewSubstreamReader (r StreamReader ,offset ,length uint64 )(*SubstreamReader ,error ){if r ==nil {return nil ,_e .New ("\u0072o\u006ft\u0020\u0072\u0065\u0061\u0064e\u0072\u0020i\u0073\u0020\u006e\u0069\u006c");};const _egc =1000*1000;_eaa :=length ;
if _eaa > _egc {_eaa =_egc ;};_b .Log .Trace ("\u004e\u0065\u0077\u0053\u0075\u0062\u0073\u0074r\u0065\u0061\u006dRe\u0061\u0064\u0065\u0072\u0020\u0061t\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u003a\u0020\u0025\u0064\u0020\u0077\u0069\u0074h\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a \u0025\u0064",offset ,length );
return &SubstreamReader {_bbe :r ,_gde :offset ,_dbe :length ,_bda :make ([]byte ,_eaa )},nil ;};func (_aed *SubstreamReader )BitPosition ()int {return int (_aed ._eec )};func (_gbe *BufferedWriter )tryGrowByReslice (_ef int )bool {if _fbg :=len (_gbe ._fa );
_ef <=cap (_gbe ._fa )-_fbg {_gbe ._fa =_gbe ._fa [:_fbg +_ef ];return true ;};return false ;};func (_bcg *Writer )UseMSB ()bool {return _bcg ._afg };func (_cg *BufferedWriter )Reset (){_cg ._fa =_cg ._fa [:0];_cg ._gb =0;_cg ._ae =0};func _bgd (_fbgf ,_ddcb uint64 )uint64 {if _fbgf < _ddcb {return _fbgf ;
};return _ddcb ;};func (_ca *BufferedWriter )WriteBits (bits uint64 ,number int )(_ge int ,_ce error ){const _aab ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";if number < 0||number > 64{return 0,_ad .Errorf (_aab ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};_bb :=number /8;if _bb > 0{_fe :=number -_bb *8;for _cfe :=_bb -1;_cfe >=0;_cfe --{_bdg :=byte ((bits >>uint (_cfe *8+_fe ))&0xff);if _ce =_ca .WriteByte (_bdg );_ce !=nil {return _ge ,_ad .Wrapf (_ce ,_aab ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_bb -_cfe +1);
};};number -=_bb *8;if number ==0{return _bb ,nil ;};};var _fff int ;for _gd :=0;_gd < number ;_gd ++{if _ca ._d {_fff =int ((bits >>uint (number -1-_gd ))&0x1);}else {_fff =int (bits &0x1);bits >>=1;};if _ce =_ca .WriteBit (_fff );_ce !=nil {return _ge ,_ad .Wrapf (_ce ,_aab ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_gd );
};};return _bb ,nil ;};func (_ded *Writer )ResetBit (){_ded ._eae =0};