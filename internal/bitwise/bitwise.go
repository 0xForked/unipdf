//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_d "encoding/binary";_e "errors";_ac "github.com/unidoc/unipdf/v3/common";_f "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_c "io";);func (_fbg *Reader )readBool ()(_ggg bool ,_dce error ){if _fbg ._gf ==0{_fbg ._aga ,_dce =_fbg .readBufferByte ();
if _dce !=nil {return false ,_dce ;};_ggg =(_fbg ._aga &0x80)!=0;_fbg ._aga ,_fbg ._gf =_fbg ._aga &0x7f,7;return _ggg ,nil ;};_fbg ._gf --;_ggg =(_fbg ._aga &(1<<_fbg ._gf ))!=0;_fbg ._aga &=1<<_fbg ._gf -1;return _ggg ,nil ;};func (_ccd *SubstreamReader )Read (b []byte )(_fcd int ,_dde error ){if _ccd ._bed >=_ccd ._cdc {_ac .Log .Trace ("\u0053\u0074\u0072e\u0061\u006d\u0050\u006fs\u003a\u0020\u0027\u0025\u0064\u0027\u0020>\u003d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027",_ccd ._bed ,_ccd ._cdc );
return 0,_c .EOF ;};for ;_fcd < len (b );_fcd ++{if b [_fcd ],_dde =_ccd .readUnalignedByte ();_dde !=nil {if _dde ==_c .EOF {return _fcd ,nil ;};return 0,_dde ;};};return _fcd ,nil ;};func (_fad *BufferedWriter )tryGrowByReslice (_cca int )bool {if _ddd :=len (_fad ._df );
_cca <=cap (_fad ._df )-_ddd {_fad ._df =_fad ._df [:_ddd +_cca ];return true ;};return false ;};func (_faa *SubstreamReader )ReadUint32 ()(uint32 ,error ){_ggge :=make ([]byte ,4);_ ,_ced :=_faa .Read (_ggge );if _ced !=nil {return 0,_ced ;};return _d .BigEndian .Uint32 (_ggge ),nil ;
};func (_acb *Reader )ReadBool ()(bool ,error ){return _acb .readBool ()};func (_gfe *Reader )Align ()(_aeb byte ){_aeb =_gfe ._gf ;_gfe ._gf =0;return _aeb };func (_cdb *Writer )ResetBit (){_cdb ._ead =0};func (_cfgg *Writer )writeByte (_cgf byte )error {if _cfgg ._gb > len (_cfgg ._ggc )-1{return _c .EOF ;
};if _cfgg ._gb ==len (_cfgg ._ggc )-1&&_cfgg ._ead !=0{return _c .EOF ;};if _cfgg ._ead ==0{_cfgg ._ggc [_cfgg ._gb ]=_cgf ;_cfgg ._gb ++;return nil ;};if _cfgg ._gac {_cfgg ._ggc [_cfgg ._gb ]|=_cgf >>_cfgg ._ead ;_cfgg ._gb ++;_cfgg ._ggc [_cfgg ._gb ]=byte (uint16 (_cgf )<<(8-_cfgg ._ead )&0xff);
}else {_cfgg ._ggc [_cfgg ._gb ]|=byte (uint16 (_cgf )<<_cfgg ._ead &0xff);_cfgg ._gb ++;_cfgg ._ggc [_cfgg ._gb ]=_cgf >>(8-_cfgg ._ead );};return nil ;};func (_eb *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _f .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );
};if len (_eb ._df )-1< _eb ._eg {_eb .expandIfNeeded (1);};_ce :=_eb ._dca ;if _eb ._ed {_ce =7-_eb ._dca ;};_eb ._df [_eb ._eg ]|=byte (uint16 (bit <<_ce )&0xff);_eb ._dca ++;if _eb ._dca ==8{_eb ._eg ++;_eb ._dca =0;};return nil ;};func (_aec *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_aec ._gd =-1;
var _bdga int64 ;switch whence {case _c .SeekStart :_bdga =offset ;case _c .SeekCurrent :_bdga =_aec ._cbc +offset ;case _c .SeekEnd :_bdga =int64 (len (_aec ._cga ))+offset ;default:return 0,_e .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};if _bdga < 0{return 0,_e .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");};_aec ._cbc =_bdga ;
_aec ._gf =0;return _bdga ,nil ;};func (_beg *Reader )ConsumeRemainingBits ()(uint64 ,error ){if _beg ._gf !=0{return _beg .ReadBits (_beg ._gf );};return 0,nil ;};func (_gga *BufferedWriter )grow (_ga int ){if _gga ._df ==nil &&_ga < _dc {_gga ._df =make ([]byte ,_ga ,_dc );
return ;};_cf :=len (_gga ._df );if _gga ._dca !=0{_cf ++;};_ccc :=cap (_gga ._df );switch {case _ga <=_ccc /2-_cf :_ac .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_gga ._df ),cap (_gga ._df ),_ga );
_ac .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_ccc ,_cf );copy (_gga ._df ,_gga ._df [_gga .fullOffset ():]);
case _ccc > _b -_ccc -_ga :_ac .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_cg :=make ([]byte ,2*_ccc +_ga );copy (_cg ,_gga ._df );_gga ._df =_cg ;};_gga ._df =_gga ._df [:_cf +_ga ];
};func _aad (_ge ,_ffg uint64 )uint64 {if _ge < _ffg {return _ge ;};return _ffg ;};func (_bge *Writer )Data ()[]byte {return _bge ._ggc };func (_dfd *Reader )Read (p []byte )(_gcd int ,_abd error ){if _dfd ._gf ==0{return _dfd .read (p );};for ;_gcd < len (p );
_gcd ++{if p [_gcd ],_abd =_dfd .readUnalignedByte ();_abd !=nil {return 0,_abd ;};};return _gcd ,nil ;};var _ _c .Writer =&BufferedWriter {};type Writer struct{_ggc []byte ;_ead uint8 ;_gb int ;_gac bool ;};func (_aae *Writer )FinishByte (){if _aae ._ead ==0{return ;
};_aae ._ead =0;_aae ._gb ++;};func (_dbed *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _dbed .writeBit (uint8 (bit ));};return _f .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");
};func (_ca *BufferedWriter )writeByte (_acc byte ){switch {case _ca ._dca ==0:_ca ._df [_ca ._eg ]=_acc ;_ca ._eg ++;case _ca ._ed :_ca ._df [_ca ._eg ]|=_acc >>_ca ._dca ;_ca ._eg ++;_ca ._df [_ca ._eg ]=byte (uint16 (_acc )<<(8-_ca ._dca )&0xff);default:_ca ._df [_ca ._eg ]|=byte (uint16 (_acc )<<_ca ._dca &0xff);
_ca ._eg ++;_ca ._df [_ca ._eg ]=_acc >>(8-_ca ._dca );};};func (_ace *SubstreamReader )Reset (){_ace ._bed =_ace ._fea ;_ace ._aecf =_ace ._gad };func (_bf *Reader )readUnalignedByte ()(_ebge byte ,_gdb error ){_dgf :=_bf ._gf ;_ebge =_bf ._aga <<(8-_dgf );
_bf ._aga ,_gdb =_bf .readBufferByte ();if _gdb !=nil {return 0,_gdb ;};_ebge |=_bf ._aga >>_dgf ;_bf ._aga &=1<<_dgf -1;return _ebge ,nil ;};type SubstreamReader struct{_bed uint64 ;_ebe StreamReader ;_ddc uint64 ;_cdc uint64 ;_cfg []byte ;_bg uint64 ;
_ecc uint64 ;_aff byte ;_aecf byte ;_fea uint64 ;_gad byte ;};func (_ag *BufferedWriter )writeShiftedBytes (_ea []byte )int {for _ ,_fgd :=range _ea {_ag .writeByte (_fgd );};return len (_ea );};func NewSubstreamReader (r StreamReader ,offset ,length uint64 )(*SubstreamReader ,error ){if r ==nil {return nil ,_e .New ("\u0072o\u006ft\u0020\u0072\u0065\u0061\u0064e\u0072\u0020i\u0073\u0020\u006e\u0069\u006c");
};_ac .Log .Trace ("\u004e\u0065\u0077\u0053\u0075\u0062\u0073\u0074r\u0065\u0061\u006dRe\u0061\u0064\u0065\u0072\u0020\u0061t\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u003a\u0020\u0025\u0064\u0020\u0077\u0069\u0074h\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a \u0025\u0064",offset ,length );
return &SubstreamReader {_ebe :r ,_ddc :offset ,_cdc :length ,_cfg :make ([]byte ,length )},nil ;};func NewReader (data []byte )*Reader {return &Reader {_cga :data }};const (_dc =64;_b =int (^uint (0)>>1););type BitWriter interface{WriteBit (_egb int )error ;
WriteBits (_fb uint64 ,_dda int )(_bee int ,_efe error );FinishByte ();SkipBits (_aea int )error ;};func (_cde *SubstreamReader )Offset ()uint64 {return _cde ._ddc };func (_ee *BufferedWriter )Reset (){_ee ._df =_ee ._df [:0];_ee ._eg =0;_ee ._dca =0};
func (_ggga *Writer )WriteByte (c byte )error {return _ggga .writeByte (c )};func (_eed *SubstreamReader )StreamPosition ()int64 {return int64 (_eed ._bed )};var _ BinaryWriter =&BufferedWriter {};type Reader struct{_cga []byte ;_aga byte ;_gf byte ;_cbc int64 ;
_ege int ;_gd int ;_gge int64 ;_ebc byte ;_cac byte ;_ccaae int ;};func (_dec *Reader )readBufferByte ()(byte ,error ){if _dec ._cbc >=int64 (len (_dec ._cga )){return 0,_c .EOF ;};_dec ._gd =-1;_add :=_dec ._cga [_dec ._cbc ];_dec ._cbc ++;_dec ._ege =int (_add );
return _add ,nil ;};func (_cfd *SubstreamReader )readBufferByte ()(byte ,error ){if _cfd ._bed >=_cfd ._cdc {return 0,_c .EOF ;};if _cfd ._bed >=_cfd ._ecc ||_cfd ._bed < _cfd ._bg {if _ggf :=_cfd .fillBuffer ();_ggf !=nil {return 0,_ggf ;};};_bba :=_cfd ._cfg [_cfd ._bed -_cfd ._bg ];
_cfd ._bed ++;return _bba ,nil ;};func (_dgc *BufferedWriter )WriteByte (bt byte )error {if _dgc ._eg > len (_dgc ._df )-1||(_dgc ._eg ==len (_dgc ._df )-1&&_dgc ._dca !=0){_dgc .expandIfNeeded (1);};_dgc .writeByte (bt );return nil ;};func (_gg *BufferedWriter )fullOffset ()int {_fgf :=_gg ._eg ;
if _gg ._dca !=0{_fgf ++;};return _fgf ;};func (_ccf *Writer )SkipBits (skip int )error {const _efa ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";if skip ==0{return nil ;};_cgg :=int (_ccf ._ead )+skip ;if _cgg >=0&&_cgg < 8{_ccf ._ead =uint8 (_cgg );
return nil ;};_cgg =int (_ccf ._ead )+_ccf ._gb *8+skip ;if _cgg < 0{return _f .Errorf (_efa ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_adb :=_cgg /8;_aaf :=_cgg %8;_ac .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");
_ac .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_ccf ._ead ,_ccf ._gb ,int (_ccf ._ead )+(_ccf ._gb )*8,len (_ccf ._ggc ),cap (_ccf ._ggc ));
_ac .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_cgg ,_aaf );_ccf ._ead =uint8 (_aaf );if _ebgf :=_adb -_ccf ._gb ;
_ebgf > 0&&len (_ccf ._ggc )-1< _adb {_ac .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_ebgf );return _f .Errorf (_efa ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};
_ccf ._gb =_adb ;_ac .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_ccf ._ead ,_ccf ._gb );return nil ;};func (_fc *BufferedWriter )WriteBits (bits uint64 ,number int )(_fag int ,_af error ){const _dd ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";
if number < 0||number > 64{return 0,_f .Errorf (_dd ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};_fg :=number /8;if _fg > 0{_ae :=number -_fg *8;for _fe :=_fg -1;_fe >=0;_fe --{_aee :=byte ((bits >>uint (_fe *8+_ae ))&0xff);if _af =_fc .WriteByte (_aee );_af !=nil {return _fag ,_f .Wrapf (_af ,_dd ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_fg -_fe +1);
};};number -=_fg *8;if number ==0{return _fg ,nil ;};};var _bae int ;for _eea :=0;_eea < number ;_eea ++{if _fc ._ed {_bae =int ((bits >>uint (number -1-_eea ))&0x1);}else {_bae =int (bits &0x1);bits >>=1;};if _af =_fc .WriteBit (_bae );_af !=nil {return _fag ,_f .Wrapf (_af ,_dd ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_eea );
};};return _fg ,nil ;};func (_de *Reader )ReadByte ()(byte ,error ){if _de ._gf ==0{return _de .readBufferByte ();};return _de .readUnalignedByte ();};func (_aefb *Writer )UseMSB ()bool {return _aefb ._gac };type BufferedWriter struct{_df []byte ;_dca uint8 ;
_eg int ;_ed bool ;};func (_fa *BufferedWriter )FinishByte (){if _fa ._dca ==0{return ;};_fa ._dca =0;_fa ._eg ++;};func (_cbe *SubstreamReader )BitPosition ()int {return int (_cbe ._aecf )};func NewWriterMSB (data []byte )*Writer {return &Writer {_ggc :data ,_gac :true }};
func (_cee *Reader )ReadUint32 ()(uint32 ,error ){_dgb :=make ([]byte ,4);_ ,_cacb :=_cee .Read (_dgb );if _cacb !=nil {return 0,_cacb ;};return _d .BigEndian .Uint32 (_dgb ),nil ;};func (_edf *Reader )read (_gfb []byte )(int ,error ){if _edf ._cbc >=int64 (len (_edf ._cga )){return 0,_c .EOF ;
};_edf ._gd =-1;_dbe :=copy (_gfb ,_edf ._cga [_edf ._cbc :]);_edf ._cbc +=int64 (_dbe );return _dbe ,nil ;};func (_be *BufferedWriter )ResetBitIndex (){_be ._dca =0};func (_deb *SubstreamReader )Length ()uint64 {return _deb ._cdc };func (_ggda *SubstreamReader )Mark (){_ggda ._fea =_ggda ._bed ;
_ggda ._gad =_ggda ._aecf };func (_ad *BufferedWriter )Data ()[]byte {return _ad ._df };func (_aead *SubstreamReader )readUnalignedByte ()(_debf byte ,_affa error ){_cdad :=_aead ._aecf ;_debf =_aead ._aff <<(8-_cdad );_aead ._aff ,_affa =_aead .readBufferByte ();
if _affa !=nil {return 0,_affa ;};_debf |=_aead ._aff >>_cdad ;_aead ._aff &=1<<_cdad -1;return _debf ,nil ;};func (_gfeb *Writer )byteCapacity ()int {_decg :=len (_gfeb ._ggc )-_gfeb ._gb ;if _gfeb ._ead !=0{_decg --;};return _decg ;};func (_bgb *SubstreamReader )ReadBit ()(_ceg int ,_fcg error ){_cag ,_fcg :=_bgb .readBool ();
if _fcg !=nil {return 0,_fcg ;};if _cag {_ceg =1;};return _ceg ,nil ;};func (_bgea *Writer )Write (p []byte )(int ,error ){if len (p )> _bgea .byteCapacity (){return 0,_c .EOF ;};for _ ,_bfd :=range p {if _dge :=_bgea .writeByte (_bfd );_dge !=nil {return 0,_dge ;
};};return len (p ),nil ;};func (_gfg *SubstreamReader )fillBuffer ()error {if uint64 (_gfg ._ebe .StreamPosition ())!=_gfg ._bed +_gfg ._ddc {_ ,_aag :=_gfg ._ebe .Seek (int64 (_gfg ._bed +_gfg ._ddc ),_c .SeekStart );if _aag !=nil {return _aag ;};};_gfg ._bg =_gfg ._bed ;
_accd :=_aad (uint64 (len (_gfg ._cfg )),_gfg ._cdc -_gfg ._bed );_feaf :=make ([]byte ,_accd );_cdcd ,_eec :=_gfg ._ebe .Read (_feaf );if _eec !=nil {return _eec ;};for _eddg :=uint64 (0);_eddg < _accd ;_eddg ++{_gfg ._cfg [_eddg ]=_feaf [_eddg ];};_gfg ._ecc =_gfg ._bg +uint64 (_cdcd );
return nil ;};func (_cbgd *SubstreamReader )ReadBits (n byte )(_edd uint64 ,_aa error ){if n < _cbgd ._aecf {_fd :=_cbgd ._aecf -n ;_edd =uint64 (_cbgd ._aff >>_fd );_cbgd ._aff &=1<<_fd -1;_cbgd ._aecf =_fd ;return _edd ,nil ;};if n > _cbgd ._aecf {if _cbgd ._aecf > 0{_edd =uint64 (_cbgd ._aff );
n -=_cbgd ._aecf ;};var _feg byte ;for n >=8{_feg ,_aa =_cbgd .readBufferByte ();if _aa !=nil {return 0,_aa ;};_edd =_edd <<8+uint64 (_feg );n -=8;};if n > 0{if _cbgd ._aff ,_aa =_cbgd .readBufferByte ();_aa !=nil {return 0,_aa ;};_bdd :=8-n ;_edd =_edd <<n +uint64 (_cbgd ._aff >>_bdd );
_cbgd ._aff &=1<<_bdd -1;_cbgd ._aecf =_bdd ;}else {_cbgd ._aecf =0;};return _edd ,nil ;};_cbgd ._aecf =0;return uint64 (_cbgd ._aff ),nil ;};func (_aef *BufferedWriter )writeFullBytes (_gc []byte )int {_bd :=copy (_aef ._df [_aef .fullOffset ():],_gc );
_aef ._eg +=_bd ;return _bd ;};type BinaryWriter interface{BitWriter ;_c .Writer ;_c .ByteWriter ;Data ()[]byte ;};func (_febe *SubstreamReader )Seek (offset int64 ,whence int )(int64 ,error ){switch whence {case _c .SeekStart :_febe ._bed =uint64 (offset );
case _c .SeekCurrent :_febe ._bed +=uint64 (offset );case _c .SeekEnd :_febe ._bed =_febe ._cdc +uint64 (offset );default:return 0,_e .New ("\u0072\u0065\u0061d\u0065\u0072\u002e\u0053\u0075\u0062\u0073\u0074\u0072\u0065\u0061\u006d\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u0020\u0069\u006e\u0076\u0061\u006ci\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};_febe ._aecf =0;return int64 (_febe ._bed ),nil ;};func (_aefd *Reader )Reset (){_aefd ._cbc =_aefd ._gge ;_aefd ._gf =_aefd ._ebc ;_aefd ._aga =_aefd ._cac ;_aefd ._ege =_aefd ._ccaae ;};func (_cda *SubstreamReader )ReadByte ()(byte ,error ){if _cda ._aecf ==0{return _cda .readBufferByte ();
};return _cda .readUnalignedByte ();};func (_dac *Reader )Mark (){_dac ._gge =_dac ._cbc ;_dac ._ebc =_dac ._gf ;_dac ._cac =_dac ._aga ;_dac ._ccaae =_dac ._ege ;};func (_bbf *Reader )ReadBits (n byte )(_fcc uint64 ,_ccb error ){if n < _bbf ._gf {_aed :=_bbf ._gf -n ;
_fcc =uint64 (_bbf ._aga >>_aed );_bbf ._aga &=1<<_aed -1;_bbf ._gf =_aed ;return _fcc ,nil ;};if n > _bbf ._gf {if _bbf ._gf > 0{_fcc =uint64 (_bbf ._aga );n -=_bbf ._gf ;};for n >=8{_bc ,_bdg :=_bbf .readBufferByte ();if _bdg !=nil {return 0,_bdg ;};
_fcc =_fcc <<8+uint64 (_bc );n -=8;};if n > 0{if _bbf ._aga ,_ccb =_bbf .readBufferByte ();_ccb !=nil {return 0,_ccb ;};_bdgg :=8-n ;_fcc =_fcc <<n +uint64 (_bbf ._aga >>_bdgg );_bbf ._aga &=1<<_bdgg -1;_bbf ._gf =_bdgg ;}else {_bbf ._gf =0;};return _fcc ,nil ;
};_bbf ._gf =0;return uint64 (_bbf ._aga ),nil ;};func (_cgbd *Writer )writeBit (_aeaf uint8 )error {if len (_cgbd ._ggc )-1< _cgbd ._gb {return _c .EOF ;};_beb :=_cgbd ._ead ;if _cgbd ._gac {_beb =7-_cgbd ._ead ;};_cgbd ._ggc [_cgbd ._gb ]|=byte (uint16 (_aeaf <<_beb )&0xff);
_cgbd ._ead ++;if _cgbd ._ead ==8{_cgbd ._gb ++;_cgbd ._ead =0;};return nil ;};type StreamReader interface{_c .Reader ;_c .ByteReader ;_c .Seeker ;Align ()byte ;BitPosition ()int ;Mark ();Length ()uint64 ;ReadBit ()(int ,error );ReadBits (_ccaa byte )(uint64 ,error );
ReadBool ()(bool ,error );ReadUint32 ()(uint32 ,error );Reset ();StreamPosition ()int64 ;};func (_dgce *SubstreamReader )Align ()(_bbb byte ){_bbb =_dgce ._aecf ;_dgce ._aecf =0;return _bbb };func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_ed :true }};
func (_cff *SubstreamReader )ReadBool ()(bool ,error ){return _cff .readBool ()};func NewWriter (data []byte )*Writer {return &Writer {_ggc :data }};func (_cbg *Reader )Length ()uint64 {return uint64 (len (_cbg ._cga ))};func (_adf *BufferedWriter )expandIfNeeded (_ega int ){if !_adf .tryGrowByReslice (_ega ){_adf .grow (_ega );
};};func (_ddda *SubstreamReader )readBool ()(_baa bool ,_bdgac error ){if _ddda ._aecf ==0{_ddda ._aff ,_bdgac =_ddda .readBufferByte ();if _bdgac !=nil {return false ,_bdgac ;};_baa =(_ddda ._aff &0x80)!=0;_ddda ._aff ,_ddda ._aecf =_ddda ._aff &0x7f,7;
return _baa ,nil ;};_ddda ._aecf --;_baa =(_ddda ._aff &(1<<_ddda ._aecf ))!=0;_ddda ._aff &=1<<_ddda ._aecf -1;return _baa ,nil ;};func (_cb *BufferedWriter )byteCapacity ()int {_g :=len (_cb ._df )-_cb ._eg ;if _cb ._dca !=0{_g --;};return _g ;};var _ BinaryWriter =&Writer {};
var (_ _c .Reader =&Reader {};_ _c .ByteReader =&Reader {};_ _c .Seeker =&Reader {};_ StreamReader =&Reader {};);func (_fba *Writer )WriteBits (bits uint64 ,number int )(_bde int ,_cfe error ){const _cgb ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";
if number < 0||number > 64{return 0,_f .Errorf (_cgb ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};if number ==0{return 0,nil ;};_ffgg :=number /8;if _ffgg > 0{_bce :=number -_ffgg *8;for _ecd :=_ffgg -1;_ecd >=0;_ecd --{_egd :=byte ((bits >>uint (_ecd *8+_bce ))&0xff);if _cfe =_fba .WriteByte (_egd );_cfe !=nil {return _bde ,_f .Wrapf (_cfe ,_cgb ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_ffgg -_ecd +1);
};};number -=_ffgg *8;if number ==0{return _ffgg ,nil ;};};var _cagg int ;for _cae :=0;_cae < number ;_cae ++{if _fba ._gac {_cagg =int ((bits >>uint (number -1-_cae ))&0x1);}else {_cagg =int (bits &0x1);bits >>=1;};if _cfe =_fba .WriteBit (_cagg );_cfe !=nil {return _bde ,_f .Wrapf (_cfe ,_cgb ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_cae );
};};return _ffgg ,nil ;};func (_cccg *Reader )ReadBit ()(_cd int ,_ebg error ){_eac ,_ebg :=_cccg .readBool ();if _ebg !=nil {return 0,_ebg ;};if _eac {_cd =1;};return _cd ,nil ;};var _ _c .ByteWriter =&BufferedWriter {};func (_ba *BufferedWriter )Write (d []byte )(int ,error ){_ba .expandIfNeeded (len (d ));
if _ba ._dca ==0{return _ba .writeFullBytes (d ),nil ;};return _ba .writeShiftedBytes (d ),nil ;};func (_dg *BufferedWriter )Len ()int {return _dg .byteCapacity ()};func (_bbg *Reader )StreamPosition ()int64 {return _bbg ._cbc };func (_ada *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;
};_ec :=int (_ada ._dca )+skip ;if _ec >=0&&_ec < 8{_ada ._dca =uint8 (_ec );return nil ;};_ec =int (_ada ._dca )+_ada ._eg *8+skip ;if _ec < 0{return _f .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_eeg :=_ec /8;_ef :=_ec %8;_ada ._dca =uint8 (_ef );if _db :=_eeg -_ada ._eg ;_db > 0&&len (_ada ._df )-1< _eeg {if _ada ._dca !=0{_db ++;};_ada .expandIfNeeded (_db );};_ada ._eg =_eeg ;return nil ;};func (_efc *Reader )BitPosition ()int {return int (_efc ._gf )};
