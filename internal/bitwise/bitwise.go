//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_af "encoding/binary";_c "errors";_bd "fmt";_d "github.com/unidoc/unipdf/v3/common";_ba "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_a "io";);var (_ _a .Reader =&Reader {};_ _a .ByteReader =&Reader {};_ _a .Seeker =&Reader {};
_ StreamReader =&Reader {};);func (_ca *BufferedWriter )Reset (){_ca ._df =_ca ._df [:0];_ca ._ea =0;_ca ._g =0};func (_gbe *Writer )WriteBits (bits uint64 ,number int )(_egc int ,_agcga error ){const _fad ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";
if number < 0||number > 64{return 0,_ba .Errorf (_fad ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};if number ==0{return 0,nil ;};_gabb :=number /8;if _gabb > 0{_bca :=number -_gabb *8;for _dcb :=_gabb -1;_dcb >=0;_dcb --{_abd :=byte ((bits >>uint (_dcb *8+_bca ))&0xff);if _agcga =_gbe .WriteByte (_abd );_agcga !=nil {return _egc ,_ba .Wrapf (_agcga ,_fad ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_gabb -_dcb +1);
};};number -=_gabb *8;if number ==0{return _gabb ,nil ;};};var _dba int ;for _ceg :=0;_ceg < number ;_ceg ++{if _gbe ._gbd {_dba =int ((bits >>uint (number -1-_ceg ))&0x1);}else {_dba =int (bits &0x1);bits >>=1;};if _agcga =_gbe .WriteBit (_dba );_agcga !=nil {return _egc ,_ba .Wrapf (_agcga ,_fad ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_ceg );
};};return _gabb ,nil ;};func (_gc *BufferedWriter )tryGrowByReslice (_eda int )bool {if _bcg :=len (_gc ._df );_eda <=cap (_gc ._df )-_bcg {_gc ._df =_gc ._df [:_bcg +_eda ];return true ;};return false ;};func (_bf *BufferedWriter )FinishByte (){if _bf ._g ==0{return ;
};_bf ._g =0;_bf ._ea ++;};func (_gf *Reader )ReadBits (n byte )(_cbe uint64 ,_gfb error ){if n < _gf ._fff {_cef :=_gf ._fff -n ;_cbe =uint64 (_gf ._cgg >>_cef );_gf ._cgg &=1<<_cef -1;_gf ._fff =_cef ;return _cbe ,nil ;};if n > _gf ._fff {if _gf ._fff > 0{_cbe =uint64 (_gf ._cgg );
n -=_gf ._fff ;};for n >=8{_ae ,_gab :=_gf .readBufferByte ();if _gab !=nil {return 0,_gab ;};_cbe =_cbe <<8+uint64 (_ae );n -=8;};if n > 0{if _gf ._cgg ,_gfb =_gf .readBufferByte ();_gfb !=nil {return 0,_gfb ;};_ged :=8-n ;_cbe =_cbe <<n +uint64 (_gf ._cgg >>_ged );
_gf ._cgg &=1<<_ged -1;_gf ._fff =_ged ;}else {_gf ._fff =0;};return _cbe ,nil ;};_gf ._fff =0;return uint64 (_gf ._cgg ),nil ;};func (_gdc *Reader )BitPosition ()int {return int (_gdc ._fff )};func (_gef *Writer )Data ()[]byte {return _gef ._gec };var _ _a .ByteWriter =&BufferedWriter {};
var _ BinaryWriter =&BufferedWriter {};type BitWriter interface{WriteBit (_afb int )error ;WriteBits (_aac uint64 ,_ddc int )(_ab int ,_ced error );FinishByte ();SkipBits (_fb int )error ;};func (_gfd *Writer )UseMSB ()bool {return _gfd ._gbd };type readerSource struct{_afe []byte ;
_cbgd int ;_agf int ;};func (_gg *BufferedWriter )Len ()int {return _gg .byteCapacity ()};func (_ad *Writer )FinishByte (){if _ad ._bcb ==0{return ;};_ad ._bcb =0;_ad ._cfg ++;};type BinaryWriter interface{BitWriter ;_a .Writer ;_a .ByteWriter ;Data ()[]byte ;
};func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_ec :true }};var _ _a .Writer =&BufferedWriter {};func (_aa *BufferedWriter )ResetBitIndex (){_aa ._g =0};func (_afg *Reader )Read (p []byte )(_afa int ,_agc error ){if _afg ._fff ==0{return _afg .read (p );
};for ;_afa < len (p );_afa ++{if p [_afa ],_agc =_afg .readUnalignedByte ();_agc !=nil {return 0,_agc ;};};return _afa ,nil ;};type Reader struct{_egf readerSource ;_cgg byte ;_fff byte ;_edb int64 ;_bb int ;_fgc int ;_fd int64 ;_dcg byte ;_ace byte ;
_db int ;};func (_dab *Reader )NewPartialReader (offset ,length int ,relative bool )(*Reader ,error ){if offset < 0{return nil ,_c .New ("p\u0061\u0072\u0074\u0069\u0061\u006c\u0020\u0072\u0065\u0061\u0064\u0065\u0072\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062e \u006e\u0065\u0067a\u0074i\u0076\u0065");
};if relative {offset =_dab ._egf ._cbgd +offset ;};if length > 0{_fgf :=len (_dab ._egf ._afe );if relative {_fgf =_dab ._egf ._agf ;};if offset +length > _fgf {return nil ,_bd .Errorf ("\u0070\u0061r\u0074\u0069\u0061l\u0020\u0072\u0065\u0061\u0064e\u0072\u0020\u006f\u0066\u0066se\u0074\u0028\u0025\u0064\u0029\u002b\u006c\u0065\u006e\u0067\u0074\u0068\u0028\u0025\u0064\u0029\u003d\u0025d\u0020i\u0073\u0020\u0067\u0072\u0065\u0061ter\u0020\u0074\u0068\u0061\u006e\u0020\u0074\u0068\u0065\u0020\u006f\u0072ig\u0069n\u0061\u006c\u0020\u0072e\u0061d\u0065r\u0020\u006ce\u006e\u0067th\u003a\u0020\u0025\u0064",offset ,length ,offset +length ,_dab ._egf ._agf );
};};if length < 0{_dfg :=len (_dab ._egf ._afe );if relative {_dfg =_dab ._egf ._agf ;};length =_dfg -offset ;};return &Reader {_egf :readerSource {_afe :_dab ._egf ._afe ,_agf :length ,_cbgd :offset }},nil ;};func (_fgcg *Reader )ConsumeRemainingBits ()(uint64 ,error ){if _fgcg ._fff !=0{return _fgcg .ReadBits (_fgcg ._fff );
};return 0,nil ;};func NewWriterMSB (data []byte )*Writer {return &Writer {_gec :data ,_gbd :true }};func (_gd *BufferedWriter )writeFullBytes (_fa []byte )int {_fg :=copy (_gd ._df [_gd .fullOffset ():],_fa );_gd ._ea +=_fg ;return _fg ;};func (_ebd *Reader )Mark (){_ebd ._fd =_ebd ._edb ;
_ebd ._dcg =_ebd ._fff ;_ebd ._ace =_ebd ._cgg ;_ebd ._db =_ebd ._bb ;};var _ BinaryWriter =&Writer {};func (_cggd *Reader )ReadBit ()(_ef int ,_abc error ){_ddcg ,_abc :=_cggd .readBool ();if _abc !=nil {return 0,_abc ;};if _ddcg {_ef =1;};return _ef ,nil ;
};func (_agcg *Writer )SkipBits (skip int )error {const _bgfg ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";if skip ==0{return nil ;};_bfd :=int (_agcg ._bcb )+skip ;if _bfd >=0&&_bfd < 8{_agcg ._bcb =uint8 (_bfd );
return nil ;};_bfd =int (_agcg ._bcb )+_agcg ._cfg *8+skip ;if _bfd < 0{return _ba .Errorf (_bgfg ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_cfc :=_bfd /8;_aec :=_bfd %8;_d .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");
_d .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_agcg ._bcb ,_agcg ._cfg ,int (_agcg ._bcb )+(_agcg ._cfg )*8,len (_agcg ._gec ),cap (_agcg ._gec ));
_d .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_bfd ,_aec );_agcg ._bcb =uint8 (_aec );if _abfd :=_cfc -_agcg ._cfg ;
_abfd > 0&&len (_agcg ._gec )-1< _cfc {_d .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_abfd );return _ba .Errorf (_bgfg ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_agcg ._cfg =_cfc ;_d .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_agcg ._bcb ,_agcg ._cfg );return nil ;};
func (_gac *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _gac .writeBit (uint8 (bit ));};return _ba .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");
};func (_fbe *Reader )Reset (){_fbe ._edb =_fbe ._fd ;_fbe ._fff =_fbe ._dcg ;_fbe ._cgg =_fbe ._ace ;_fbe ._bb =_fbe ._db ;};func (_fcd *Reader )read (_caaa []byte )(int ,error ){if _fcd ._edb >=int64 (_fcd ._egf ._agf ){return 0,_a .EOF ;};_fcd ._fgc =-1;
_fe :=copy (_caaa ,_fcd ._egf ._afe [(int64 (_fcd ._egf ._cbgd )+_fcd ._edb ):(_fcd ._egf ._cbgd +_fcd ._egf ._agf )]);_fcd ._edb +=int64 (_fe );return _fe ,nil ;};type Writer struct{_gec []byte ;_bcb uint8 ;_cfg int ;_gbd bool ;};func NewReader (data []byte )*Reader {return &Reader {_egf :readerSource {_afe :data ,_agf :len (data ),_cbgd :0}};
};func (_bfa *Writer )writeBit (_cab uint8 )error {if len (_bfa ._gec )-1< _bfa ._cfg {return _a .EOF ;};_efa :=_bfa ._bcb ;if _bfa ._gbd {_efa =7-_bfa ._bcb ;};_bfa ._gec [_bfa ._cfg ]|=byte (uint16 (_cab <<_efa )&0xff);_bfa ._bcb ++;if _bfa ._bcb ==8{_bfa ._cfg ++;
_bfa ._bcb =0;};return nil ;};func (_bc *BufferedWriter )byteCapacity ()int {_ff :=len (_bc ._df )-_bc ._ea ;if _bc ._g !=0{_ff --;};return _ff ;};func (_gcc *Reader )Length ()uint64 {return uint64 (_gcc ._egf ._agf )};type StreamReader interface{_a .Reader ;
_a .ByteReader ;_a .Seeker ;Align ()byte ;BitPosition ()int ;Mark ();Length ()uint64 ;ReadBit ()(int ,error );ReadBits (_cge byte )(uint64 ,error );ReadBool ()(bool ,error );ReadUint32 ()(uint32 ,error );Reset ();AbsolutePosition ()int64 ;};func (_dca *Reader )readBool ()(_cde bool ,_agb error ){if _dca ._fff ==0{_dca ._cgg ,_agb =_dca .readBufferByte ();
if _agb !=nil {return false ,_agb ;};_cde =(_dca ._cgg &0x80)!=0;_dca ._cgg ,_dca ._fff =_dca ._cgg &0x7f,7;return _cde ,nil ;};_dca ._fff --;_cde =(_dca ._cgg &(1<<_dca ._fff ))!=0;_dca ._cgg &=1<<_dca ._fff -1;return _cde ,nil ;};func (_dg *Reader )readBufferByte ()(byte ,error ){if _dg ._edb >=int64 (_dg ._egf ._agf ){return 0,_a .EOF ;
};_dg ._fgc =-1;_cec :=_dg ._egf ._afe [int64 (_dg ._egf ._cbgd )+_dg ._edb ];_dg ._edb ++;_dg ._bb =int (_cec );return _cec ,nil ;};func (_fcc *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _ba .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );
};if len (_fcc ._df )-1< _fcc ._ea {_fcc .expandIfNeeded (1);};_bfe :=_fcc ._g ;if _fcc ._ec {_bfe =7-_fcc ._g ;};_fcc ._df [_fcc ._ea ]|=byte (uint16 (bit <<_bfe )&0xff);_fcc ._g ++;if _fcc ._g ==8{_fcc ._ea ++;_fcc ._g =0;};return nil ;};func (_dc *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;
};_cb :=int (_dc ._g )+skip ;if _cb >=0&&_cb < 8{_dc ._g =uint8 (_cb );return nil ;};_cb =int (_dc ._g )+_dc ._ea *8+skip ;if _cb < 0{return _ba .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_gge :=_cb /8;_ag :=_cb %8;_dc ._g =uint8 (_ag );if _fc :=_gge -_dc ._ea ;_fc > 0&&len (_dc ._df )-1< _gge {if _dc ._g !=0{_fc ++;};_dc .expandIfNeeded (_fc );};_dc ._ea =_gge ;return nil ;};func (_dgb *Writer )writeByte (_dac byte )error {if _dgb ._cfg > len (_dgb ._gec )-1{return _a .EOF ;
};if _dgb ._cfg ==len (_dgb ._gec )-1&&_dgb ._bcb !=0{return _a .EOF ;};if _dgb ._bcb ==0{_dgb ._gec [_dgb ._cfg ]=_dac ;_dgb ._cfg ++;return nil ;};if _dgb ._gbd {_dgb ._gec [_dgb ._cfg ]|=_dac >>_dgb ._bcb ;_dgb ._cfg ++;_dgb ._gec [_dgb ._cfg ]=byte (uint16 (_dac )<<(8-_dgb ._bcb )&0xff);
}else {_dgb ._gec [_dgb ._cfg ]|=byte (uint16 (_dac )<<_dgb ._bcb &0xff);_dgb ._cfg ++;_dgb ._gec [_dgb ._cfg ]=_dac >>(8-_dgb ._bcb );};return nil ;};func (_cfe *BufferedWriter )expandIfNeeded (_ffe int ){if !_cfe .tryGrowByReslice (_ffe ){_cfe .grow (_ffe );
};};func (_dce *Reader )ReadByte ()(byte ,error ){if _dce ._fff ==0{return _dce .readBufferByte ();};return _dce .readUnalignedByte ();};func (_ee *Writer )byteCapacity ()int {_fga :=len (_ee ._gec )-_ee ._cfg ;if _ee ._bcb !=0{_fga --;};return _fga ;};
func (_eg *BufferedWriter )grow (_bfg int ){if _eg ._df ==nil &&_bfg < _cg {_eg ._df =make ([]byte ,_bfg ,_cg );return ;};_aga :=len (_eg ._df );if _eg ._g !=0{_aga ++;};_fcg :=cap (_eg ._df );switch {case _bfg <=_fcg /2-_aga :_d .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_eg ._df ),cap (_eg ._df ),_bfg );
_d .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_fcg ,_aga );copy (_eg ._df ,_eg ._df [_eg .fullOffset ():]);
case _fcg > _f -_fcg -_bfg :_d .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_ed :=make ([]byte ,2*_fcg +_bfg );copy (_ed ,_eg ._df );_eg ._df =_ed ;};_eg ._df =_eg ._df [:_aga +_bfg ];
};func (_bdd *BufferedWriter )Data ()[]byte {return _bdd ._df };func (_bgf *Reader )ReadBool ()(bool ,error ){return _bgf .readBool ()};func (_ead *Writer )ResetBit (){_ead ._bcb =0};func (_agfc *Reader )AbsolutePosition ()int64 {return _agfc ._edb +int64 (_agfc ._egf ._cbgd )};
func (_cfd *BufferedWriter )writeByte (_cbg byte ){switch {case _cfd ._g ==0:_cfd ._df [_cfd ._ea ]=_cbg ;_cfd ._ea ++;case _cfd ._ec :_cfd ._df [_cfd ._ea ]|=_cbg >>_cfd ._g ;_cfd ._ea ++;_cfd ._df [_cfd ._ea ]=byte (uint16 (_cbg )<<(8-_cfd ._g )&0xff);
default:_cfd ._df [_cfd ._ea ]|=byte (uint16 (_cbg )<<_cfd ._g &0xff);_cfd ._ea ++;_cfd ._df [_cfd ._ea ]=_cbg >>(8-_cfd ._g );};};func (_bfb *Reader )RelativePosition ()int64 {return _bfb ._edb };type BufferedWriter struct{_df []byte ;_g uint8 ;_ea int ;
_ec bool ;};func (_fba *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_fba ._fgc =-1;_fba ._fff =0;_fba ._cgg =0;_fba ._bb =0;var _bbd int64 ;switch whence {case _a .SeekStart :_bbd =offset ;case _a .SeekCurrent :_bbd =_fba ._edb +offset ;case _a .SeekEnd :_bbd =int64 (_fba ._egf ._agf )+offset ;
default:return 0,_c .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");};if _bbd < 0{return 0,_c .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");
};_fba ._edb =_bbd ;_fba ._fff =0;return _bbd ,nil ;};func (_dbb *Reader )ReadUint32 ()(uint32 ,error ){_cdfa :=make ([]byte ,4);_ ,_fgfc :=_dbb .Read (_cdfa );if _fgfc !=nil {return 0,_fgfc ;};return _af .BigEndian .Uint32 (_cdfa ),nil ;};func (_cdf *Reader )AbsoluteLength ()uint64 {return uint64 (len (_cdf ._egf ._afe ))};
func NewWriter (data []byte )*Writer {return &Writer {_gec :data }};const (_cg =64;_f =int (^uint (0)>>1););func (_acc *Writer )WriteByte (c byte )error {return _acc .writeByte (c )};func (_bg *BufferedWriter )fullOffset ()int {_fccf :=_bg ._ea ;if _bg ._g !=0{_fccf ++;
};return _fccf ;};func (_ac *BufferedWriter )WriteBits (bits uint64 ,number int )(_bab int ,_aaa error ){const _ddb ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";if number < 0||number > 64{return 0,_ba .Errorf (_ddb ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};_eb :=number /8;if _eb > 0{_ga :=number -_eb *8;for _da :=_eb -1;_da >=0;_da --{_fcb :=byte ((bits >>uint (_da *8+_ga ))&0xff);if _aaa =_ac .WriteByte (_fcb );_aaa !=nil {return _bab ,_ba .Wrapf (_aaa ,_ddb ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_eb -_da +1);
};};number -=_eb *8;if number ==0{return _eb ,nil ;};};var _cf int ;for _gb :=0;_gb < number ;_gb ++{if _ac ._ec {_cf =int ((bits >>uint (number -1-_gb ))&0x1);}else {_cf =int (bits &0x1);bits >>=1;};if _aaa =_ac .WriteBit (_cf );_aaa !=nil {return _bab ,_ba .Wrapf (_aaa ,_ddb ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_gb );
};};return _eb ,nil ;};func (_ebb *Reader )readUnalignedByte ()(_be byte ,_beb error ){_abf :=_ebb ._fff ;_be =_ebb ._cgg <<(8-_abf );_ebb ._cgg ,_beb =_ebb .readBufferByte ();if _beb !=nil {return 0,_beb ;};_be |=_ebb ._cgg >>_abf ;_ebb ._cgg &=1<<_abf -1;
return _be ,nil ;};func (_dfa *BufferedWriter )writeShiftedBytes (_bde []byte )int {for _ ,_gde :=range _bde {_dfa .writeByte (_gde );};return len (_bde );};func (_ge *BufferedWriter )WriteByte (bt byte )error {if _ge ._ea > len (_ge ._df )-1||(_ge ._ea ==len (_ge ._df )-1&&_ge ._g !=0){_ge .expandIfNeeded (1);
};_ge .writeByte (bt );return nil ;};func (_dd *BufferedWriter )Write (d []byte )(int ,error ){_dd .expandIfNeeded (len (d ));if _dd ._g ==0{return _dd .writeFullBytes (d ),nil ;};return _dd .writeShiftedBytes (d ),nil ;};func (_aff *Reader )Align ()(_cd byte ){_cd =_aff ._fff ;
_aff ._fff =0;return _cd };func (_gdf *Writer )Write (p []byte )(int ,error ){if len (p )> _gdf .byteCapacity (){return 0,_a .EOF ;};for _ ,_abfdc :=range p {if _fdf :=_gdf .writeByte (_abfdc );_fdf !=nil {return 0,_fdf ;};};return len (p ),nil ;};