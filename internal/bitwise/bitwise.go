//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_b "encoding/binary";_dga "errors";_e "github.com/unidoc/unipdf/v3/common";_c "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_dg "io";);type BinaryWriter interface{BitWriter ;_dg .Writer ;_dg .ByteWriter ;Data ()[]byte ;};func (_gg *BufferedWriter )ResetBitIndex (){_gg ._bd =0};func (_bgc *SubstreamReader )StreamPosition ()int64 {return int64 (_bgc ._bfc )};func NewWriter (data []byte )*Writer {return &Writer {_faa :data }};var _ BinaryWriter =&BufferedWriter {};func (_af *BufferedWriter )Len ()int {return _af .byteCapacity ()};type SubstreamReader struct{_bfc uint64 ;_dab StreamReader ;_eac uint64 ;_ba uint64 ;_eedf []byte ;_gbbg uint64 ;_ecc uint64 ;_cfeg byte ;_gfg byte ;_edg uint64 ;_dgad byte ;};func (_dcf *SubstreamReader )Align ()(_ege byte ){_ege =_dcf ._gfg ;_dcf ._gfg =0;return _ege };func (_dcc *Reader )ConsumeRemainingBits (){if _dcc ._eag !=0{_ ,_abb :=_dcc .ReadBits (_dcc ._eag );if _abb !=nil {_e .Log .Debug ("\u0043\u006f\u006e\u0073\u0075\u006d\u0065\u0052\u0065\u006da\u0069\u006e\u0069\u0067\u0042\u0069\u0074s\u0020\u0066\u0061\u0069\u006c\u0065\u0064\u003a\u0020\u0025\u0076",_abb );};};};func (_cga *BufferedWriter )expandIfNeeded (_gda int ){if !_cga .tryGrowByReslice (_gda ){_cga .grow (_gda );};};func (_age *BufferedWriter )fullOffset ()int {_eab :=_age ._cf ;if _age ._bd !=0{_eab ++;};return _eab ;};func (_fgd *Reader )Length ()uint64 {return uint64 (len (_fgd ._gbb ))};func NewReader (data []byte )*Reader {return &Reader {_gbb :data }};func (_ecgg *SubstreamReader )Seek (offset int64 ,whence int )(int64 ,error ){switch whence {case _dg .SeekStart :_ecgg ._bfc =uint64 (offset );case _dg .SeekCurrent :_ecgg ._bfc +=uint64 (offset );case _dg .SeekEnd :_ecgg ._bfc =_ecgg ._ba +uint64 (offset );default:return 0,_dga .New ("\u0072\u0065\u0061d\u0065\u0072\u002e\u0053\u0075\u0062\u0073\u0074\u0072\u0065\u0061\u006d\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u0020\u0069\u006e\u0076\u0061\u006ci\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");};_ecgg ._gfg =0;return int64 (_ecgg ._bfc ),nil ;};func (_ged *SubstreamReader )readUnalignedByte ()(_efe byte ,_bab error ){_fbd :=_ged ._gfg ;_efe =_ged ._cfeg <<(8-_fbd );_ged ._cfeg ,_bab =_ged .readBufferByte ();if _bab !=nil {return 0,_bab ;};_efe |=_ged ._cfeg >>_fbd ;_ged ._cfeg &=1<<_fbd -1;return _efe ,nil ;};func (_dea *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_dea ._ef =-1;var _efg int64 ;switch whence {case _dg .SeekStart :_efg =offset ;case _dg .SeekCurrent :_efg =_dea ._ecga +offset ;case _dg .SeekEnd :_efg =int64 (len (_dea ._gbb ))+offset ;default:return 0,_dga .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");};if _efg < 0{return 0,_dga .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");};_dea ._ecga =_efg ;_dea ._eag =0;return _efg ,nil ;};type BitWriter interface{WriteBit (_gfa int )error ;WriteBits (_df uint64 ,_dff int )(_ca int ,_fdb error );FinishByte ();SkipBits (_eabg int )error ;};func (_aae *Reader )ReadBool ()(bool ,error ){return _aae .readBool ()};func (_dcg *BufferedWriter )Reset (){_dcg ._ab =_dcg ._ab [:0];_dcg ._cf =0;_dcg ._bd =0};func (_cfee *Reader )readBool ()(_cgd bool ,_ffb error ){if _cfee ._eag ==0{_cfee ._eed ,_ffb =_cfee .readBufferByte ();if _ffb !=nil {return false ,_ffb ;};_cgd =(_cfee ._eed &0x80)!=0;_cfee ._eed ,_cfee ._eag =_cfee ._eed &0x7f,7;return _cgd ,nil ;};_cfee ._eag --;_cgd =(_cfee ._eed &(1<<_cfee ._eag ))!=0;_cfee ._eed &=1<<_cfee ._eag -1;return _cgd ,nil ;};func (_eg *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _c .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );};if len (_eg ._ab )-1< _eg ._cf {_eg .expandIfNeeded (1);};_cfe :=_eg ._bd ;if _eg ._ag {_cfe =7-_eg ._bd ;};_eg ._ab [_eg ._cf ]|=byte (uint16 (bit <<_cfe )&0xff);_eg ._bd ++;if _eg ._bd ==8{_eg ._cf ++;_eg ._bd =0;};return nil ;};func (_dad *Reader )Reset (){_dad ._ecga =_dad ._faf ;_dad ._eag =_dad ._fef };func (_bb *BufferedWriter )tryGrowByReslice (_adf int )bool {if _aefe :=len (_bb ._ab );_adf <=cap (_bb ._ab )-_aefe {_bb ._ab =_bb ._ab [:_aefe +_adf ];return true ;};return false ;};func (_geg *SubstreamReader )BitPosition ()int {return int (_geg ._gfg )};func (_cac *SubstreamReader )readBool ()(_daf bool ,_ecgd error ){if _cac ._gfg ==0{_cac ._cfeg ,_ecgd =_cac .readBufferByte ();if _ecgd !=nil {return false ,_ecgd ;};_daf =(_cac ._cfeg &0x80)!=0;_cac ._cfeg ,_cac ._gfg =_cac ._cfeg &0x7f,7;return _daf ,nil ;};_cac ._gfg --;_daf =(_cac ._cfeg &(1<<_cac ._gfg ))!=0;_cac ._cfeg &=1<<_cac ._gfg -1;return _daf ,nil ;};func (_cc *SubstreamReader )Read (b []byte )(_fefb int ,_eaf error ){if _cc ._bfc >=_cc ._ba {_e .Log .Trace ("\u0053\u0074\u0072e\u0061\u006d\u0050\u006fs\u003a\u0020\u0027\u0025\u0064\u0027\u0020>\u003d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027",_cc ._bfc ,_cc ._ba );return 0,_dg .EOF ;};for ;_fefb < len (b );_fefb ++{if b [_fefb ],_eaf =_cc .readUnalignedByte ();_eaf !=nil {if _eaf ==_dg .EOF {return _fefb ,nil ;};return 0,_eaf ;};};return _fefb ,nil ;};func (_afda *Reader )Align ()(_dfe byte ){_dfe =_afda ._eag ;_afda ._eag =0;return _dfe };func (_ffa *SubstreamReader )ReadUint32 ()(uint32 ,error ){_fge :=make ([]byte ,4);_ ,_faff :=_ffa .Read (_fge );if _faff !=nil {return 0,_faff ;};return _b .BigEndian .Uint32 (_fge ),nil ;};func (_fdcaa *Reader )read (_abg []byte )(int ,error ){if _fdcaa ._ecga >=int64 (len (_fdcaa ._gbb )){return 0,_dg .EOF ;};_fdcaa ._ef =-1;_dcb :=copy (_abg ,_fdcaa ._gbb [_fdcaa ._ecga :]);_fdcaa ._ecga +=int64 (_dcb );return _dcb ,nil ;};type Writer struct{_faa []byte ;_cgg uint8 ;_fdbf int ;_cad bool ;};func (_cba *Reader )readUnalignedByte ()(_ead byte ,_eec error ){_bdc :=_cba ._eag ;_ead =_cba ._eed <<(8-_bdc );_cba ._eed ,_eec =_cba .readBufferByte ();if _eec !=nil {return 0,_eec ;};_ead |=_cba ._eed >>_bdc ;_cba ._eed &=1<<_bdc -1;return _ead ,nil ;};func (_ebg *Writer )Data ()[]byte {return _ebg ._faa };func (_fdca *Reader )ReadByte ()(byte ,error ){if _fdca ._eag ==0{return _fdca .readBufferByte ();};return _fdca .readUnalignedByte ();};func (_cd *SubstreamReader )Length ()uint64 {return _cd ._ba };type Reader struct{_gbb []byte ;_eed byte ;_eag byte ;_ecga int64 ;_aeb int ;_ef int ;_faf int64 ;_fef byte ;};func (_cee *Writer )ResetBit (){_cee ._cgg =0};func (_ffbf *SubstreamReader )Offset ()uint64 {return _ffbf ._eac };func (_aac *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _aac .writeBit (uint8 (bit ));};return _c .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");};func (_ec *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;};_ecg :=int (_ec ._bd )+skip ;if _ecg >=0&&_ecg < 8{_ec ._bd =uint8 (_ecg );return nil ;};_ecg =int (_ec ._bd )+_ec ._cf *8+skip ;if _ecg < 0{return _c .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_fa :=_ecg /8;_cfc :=_ecg %8;_ec ._bd =uint8 (_cfc );if _bf :=_fa -_ec ._cf ;_bf > 0&&len (_ec ._ab )-1< _fa {if _ec ._bd !=0{_bf ++;};_ec .expandIfNeeded (_bf );};_ec ._cf =_fa ;return nil ;};func (_ceg *SubstreamReader )readBufferByte ()(byte ,error ){if _ceg ._bfc >=_ceg ._ba {return 0,_dg .EOF ;};if _ceg ._bfc >=_ceg ._ecc ||_ceg ._bfc < _ceg ._gbbg {if _cca :=_ceg .fillBuffer ();_cca !=nil {return 0,_cca ;};};_dgc :=_ceg ._eedf [_ceg ._bfc -_ceg ._gbbg ];_ceg ._bfc ++;return _dgc ,nil ;};func NewSubstreamReader (r StreamReader ,offset ,length uint64 )(*SubstreamReader ,error ){if r ==nil {return nil ,_dga .New ("\u0072o\u006ft\u0020\u0072\u0065\u0061\u0064e\u0072\u0020i\u0073\u0020\u006e\u0069\u006c");};_e .Log .Trace ("\u004e\u0065\u0077\u0053\u0075\u0062\u0073\u0074r\u0065\u0061\u006dRe\u0061\u0064\u0065\u0072\u0020\u0061t\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u003a\u0020\u0025\u0064\u0020\u0077\u0069\u0074h\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a \u0025\u0064",offset ,length );return &SubstreamReader {_dab :r ,_eac :offset ,_ba :length ,_eedf :make ([]byte ,length )},nil ;};func (_cb *BufferedWriter )writeFullBytes (_fd []byte )int {_fc :=copy (_cb ._ab [_cb .fullOffset ():],_fd );_cb ._cf +=_fc ;return _fc ;};func (_ga *Writer )byteCapacity ()int {_cadg :=len (_ga ._faa )-_ga ._fdbf ;if _ga ._cgg !=0{_cadg --;};return _cadg ;};type BufferedWriter struct{_ab []byte ;_bd uint8 ;_cf int ;_ag bool ;};var _ BinaryWriter =&Writer {};func (_efd *Writer )WriteByte (c byte )error {return _efd .writeByte (c )};func (_bc *Reader )ReadBits (n byte )(_bfg uint64 ,_aa error ){if n < _bc ._eag {_ge :=_bc ._eag -n ;_bfg =uint64 (_bc ._eed >>_ge );_bc ._eed &=1<<_ge -1;_bc ._eag =_ge ;return _bfg ,nil ;};if n > _bc ._eag {if _bc ._eag > 0{_bfg =uint64 (_bc ._eed );n -=_bc ._eag ;};for n >=8{_fda ,_gdbf :=_bc .readBufferByte ();if _gdbf !=nil {return 0,_gdbf ;};_bfg =_bfg <<8+uint64 (_fda );n -=8;};if n > 0{if _bc ._eed ,_aa =_bc .readBufferByte ();_aa !=nil {return 0,_aa ;};_fb :=8-n ;_bfg =_bfg <<n +uint64 (_bc ._eed >>_fb );_bc ._eed &=1<<_fb -1;_bc ._eag =_fb ;}else {_bc ._eag =0;};return _bfg ,nil ;};_bc ._eag =0;return uint64 (_bc ._eed ),nil ;};var (_ _dg .Reader =&Reader {};_ _dg .ByteReader =&Reader {};_ _dg .Seeker =&Reader {};_ StreamReader =&Reader {};);func (_ae *BufferedWriter )grow (_gggg int ){if _ae ._ab ==nil &&_gggg < _a {_ae ._ab =make ([]byte ,_gggg ,_a );return ;};_aef :=len (_ae ._ab );if _ae ._bd !=0{_aef ++;};_afd :=cap (_ae ._ab );switch {case _gggg <=_afd /2-_aef :_e .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_ae ._ab ),cap (_ae ._ab ),_gggg );_e .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_afd ,_aef );copy (_ae ._ab ,_ae ._ab [_ae .fullOffset ():]);case _afd > _g -_afd -_gggg :_e .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_aee :=make ([]byte ,2*_afd +_gggg );copy (_aee ,_ae ._ab );_ae ._ab =_aee ;};_ae ._ab =_ae ._ab [:_aef +_gggg ];};func (_fed *SubstreamReader )fillBuffer ()error {if uint64 (_fed ._dab .StreamPosition ())!=_fed ._bfc +_fed ._eac {_ ,_bdd :=_fed ._dab .Seek (int64 (_fed ._bfc +_fed ._eac ),_dg .SeekStart );if _bdd !=nil {return _bdd ;};};_fed ._gbbg =_fed ._bfc ;_egd :=_dde (uint64 (len (_fed ._eedf )),_fed ._ba -_fed ._bfc );_bcf :=make ([]byte ,_egd );_dgg ,_afdc :=_fed ._dab .Read (_bcf );if _afdc !=nil {return _afdc ;};for _bef :=uint64 (0);_bef < _egd ;_bef ++{_fed ._eedf [_bef ]=_bcf [_bef ];};_fed ._ecc =_fed ._gbbg +uint64 (_dgg );return nil ;};func (_agf *Reader )readBufferByte ()(byte ,error ){if _agf ._ecga >=int64 (len (_agf ._gbb )){return 0,_dg .EOF ;};_agf ._ef =-1;_gbdc :=_agf ._gbb [_agf ._ecga ];_agf ._ecga ++;_agf ._aeb =int (_gbdc );return _gbdc ,nil ;};func (_gfc *BufferedWriter )writeShiftedBytes (_gbc []byte )int {for _ ,_gbd :=range _gbc {_gfc .writeByte (_gbd );};return len (_gbc );};func (_eeb *SubstreamReader )ReadBits (n byte )(_dee uint64 ,_dec error ){if n < _eeb ._gfg {_eba :=_eeb ._gfg -n ;_dee =uint64 (_eeb ._cfeg >>_eba );_eeb ._cfeg &=1<<_eba -1;_eeb ._gfg =_eba ;return _dee ,nil ;};if n > _eeb ._gfg {if _eeb ._gfg > 0{_dee =uint64 (_eeb ._cfeg );n -=_eeb ._gfg ;};var _ac byte ;for n >=8{_ac ,_dec =_eeb .readBufferByte ();if _dec !=nil {return 0,_dec ;};_dee =_dee <<8+uint64 (_ac );n -=8;};if n > 0{if _eeb ._cfeg ,_dec =_eeb .readBufferByte ();_dec !=nil {return 0,_dec ;};_aeff :=8-n ;_dee =_dee <<n +uint64 (_eeb ._cfeg >>_aeff );_eeb ._cfeg &=1<<_aeff -1;_eeb ._gfg =_aeff ;}else {_eeb ._gfg =0;};return _dee ,nil ;};_eeb ._gfg =0;return uint64 (_eeb ._cfeg ),nil ;};func _dde (_dcba ,_cgf uint64 )uint64 {if _dcba < _cgf {return _dcba ;};return _cgf ;};func (_dgf *SubstreamReader )Reset (){_dgf ._bfc =_dgf ._edg ;_dgf ._gfg =_dgf ._dgad };func (_agdf *SubstreamReader )Mark (){_agdf ._edg =_agdf ._bfc ;_agdf ._dgad =_agdf ._gfg };func (_cab *Reader )StreamPosition ()int64 {return _cab ._ecga };func (_adg *BufferedWriter )Write (d []byte )(int ,error ){_adg .expandIfNeeded (len (d ));if _adg ._bd ==0{return _adg .writeFullBytes (d ),nil ;};return _adg .writeShiftedBytes (d ),nil ;};func (_fbe *Writer )writeByte (_cda byte )error {if _fbe ._fdbf > len (_fbe ._faa )-1{return _dg .EOF ;};if _fbe ._fdbf ==len (_fbe ._faa )-1&&_fbe ._cgg !=0{return _dg .EOF ;};if _fbe ._cgg ==0{_fbe ._faa [_fbe ._fdbf ]=_cda ;_fbe ._fdbf ++;return nil ;};if _fbe ._cad {_fbe ._faa [_fbe ._fdbf ]|=_cda >>_fbe ._cgg ;_fbe ._fdbf ++;_fbe ._faa [_fbe ._fdbf ]=byte (uint16 (_cda )<<(8-_fbe ._cgg )&0xff);}else {_fbe ._faa [_fbe ._fdbf ]|=byte (uint16 (_cda )<<_fbe ._cgg &0xff);_fbe ._fdbf ++;_fbe ._faa [_fbe ._fdbf ]=_cda >>(8-_fbe ._cgg );};return nil ;};func (_bae *Writer )Write (p []byte )(int ,error ){if len (p )> _bae .byteCapacity (){return 0,_dg .EOF ;};for _ ,_ebc :=range p {if _efb :=_bae .writeByte (_ebc );_efb !=nil {return 0,_efb ;};};return len (p ),nil ;};func (_abc *BufferedWriter )writeByte (_de byte ){switch {case _abc ._bd ==0:_abc ._ab [_abc ._cf ]=_de ;_abc ._cf ++;case _abc ._ag :_abc ._ab [_abc ._cf ]|=_de >>_abc ._bd ;_abc ._cf ++;_abc ._ab [_abc ._cf ]=byte (uint16 (_de )<<(8-_abc ._bd )&0xff);default:_abc ._ab [_abc ._cf ]|=byte (uint16 (_de )<<_abc ._bd &0xff);_abc ._cf ++;_abc ._ab [_abc ._cf ]=_de >>(8-_abc ._bd );};};func (_cfcb *Writer )FinishByte (){if _cfcb ._cgg ==0{return ;};_cfcb ._cgg =0;_cfcb ._fdbf ++;};func (_dcfa *SubstreamReader )ReadBit ()(_cdg int ,_fad error ){_fcb ,_fad :=_dcfa .readBool ();if _fad !=nil {return 0,_fad ;};if _fcb {_cdg =1;};return _cdg ,nil ;};func (_ee *BufferedWriter )WriteByte (bt byte )error {if _ee ._cf > len (_ee ._ab )-1||(_ee ._cf ==len (_ee ._ab )-1&&_ee ._bd !=0){_ee .expandIfNeeded (1);};_ee .writeByte (bt );return nil ;};const (_a =64;_g =int (^uint (0)>>1););func (_dgb *Writer )SkipBits (skip int )error {const _gee ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";if skip ==0{return nil ;};_deag :=int (_dgb ._cgg )+skip ;if _deag >=0&&_deag < 8{_dgb ._cgg =uint8 (_deag );return nil ;};_deag =int (_dgb ._cgg )+_dgb ._fdbf *8+skip ;if _deag < 0{return _c .Errorf (_gee ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_fdg :=_deag /8;_egg :=_deag %8;_e .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");_e .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_dgb ._cgg ,_dgb ._fdbf ,int (_dgb ._cgg )+(_dgb ._fdbf )*8,len (_dgb ._faa ),cap (_dgb ._faa ));_e .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_deag ,_egg );_dgb ._cgg =uint8 (_egg );if _ebb :=_fdg -_dgb ._fdbf ;_ebb > 0&&len (_dgb ._faa )-1< _fdg {_e .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_ebb );return _c .Errorf (_gee ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_dgb ._fdbf =_fdg ;_e .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_dgb ._cgg ,_dgb ._fdbf );return nil ;};func (_ff *Reader )Read (p []byte )(_add int ,_da error ){if _ff ._eag ==0{return _ff .read (p );};for ;_add < len (p );_add ++{if p [_add ],_da =_ff .readUnalignedByte ();_da !=nil {return 0,_da ;};};return _add ,nil ;};func (_fdcg *Reader )ReadBit ()(_agd int ,_agde error ){_gdb ,_agde :=_fdcg .readBool ();if _agde !=nil {return 0,_agde ;};if _gdb {_agd =1;};return _agd ,nil ;};func (_dc *BufferedWriter )Data ()[]byte {return _dc ._ab };func (_gff *Writer )WriteBits (bits uint64 ,number int )(_aad int ,_dgd error ){const _gc ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";if number < 0||number > 64{return 0,_c .Errorf (_gc ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );};if number ==0{return 0,nil ;};_fec :=number /8;if _fec > 0{_dbd :=number -_fec *8;for _feeg :=_fec -1;_feeg >=0;_feeg --{_ace :=byte ((bits >>uint (_feeg *8+_dbd ))&0xff);if _dgd =_gff .WriteByte (_ace );_dgd !=nil {return _aad ,_c .Wrapf (_dgd ,_gc ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_fec -_feeg +1);};};number -=_fec *8;if number ==0{return _fec ,nil ;};};var _gddc int ;for _dbg :=0;_dbg < number ;_dbg ++{if _gff ._cad {_gddc =int ((bits >>uint (number -1-_dbg ))&0x1);}else {_gddc =int (bits &0x1);bits >>=1;};if _dgd =_gff .WriteBit (_gddc );_dgd !=nil {return _aad ,_c .Wrapf (_dgd ,_gc ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_dbg );};};return _fec ,nil ;};func (_fg *BufferedWriter )WriteBits (bits uint64 ,number int )(_gb int ,_eb error ){const _dd ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";if number < 0||number > 64{return 0,_c .Errorf (_dd ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );};_ggg :=number /8;if _ggg > 0{_gd :=number -_ggg *8;for _fe :=_ggg -1;_fe >=0;_fe --{_gbe :=byte ((bits >>uint (_fe *8+_gd ))&0xff);if _eb =_fg .WriteByte (_gbe );_eb !=nil {return _gb ,_c .Wrapf (_eb ,_dd ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_ggg -_fe +1);};};number -=_ggg *8;if number ==0{return _ggg ,nil ;};};var _gf int ;for _ebf :=0;_ebf < number ;_ebf ++{if _fg ._ag {_gf =int ((bits >>uint (number -1-_ebf ))&0x1);}else {_gf =int (bits &0x1);bits >>=1;};if _eb =_fg .WriteBit (_gf );_eb !=nil {return _gb ,_c .Wrapf (_eb ,_dd ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_ebf );};};return _ggg ,nil ;};func (_ed *Reader )Mark (){_ed ._faf =_ed ._ecga ;_ed ._fef =_ed ._eag };var _ _dg .ByteWriter =&BufferedWriter {};func (_fbf *Reader )ReadUint32 ()(uint32 ,error ){_bg :=make ([]byte ,4);_ ,_ddf :=_fbf .Read (_bg );if _ddf !=nil {return 0,_ddf ;};return _b .BigEndian .Uint32 (_bg ),nil ;};type StreamReader interface{_dg .Reader ;_dg .ByteReader ;_dg .Seeker ;Align ()byte ;BitPosition ()int ;Mark ();Length ()uint64 ;ReadBit ()(int ,error );ReadBits (_gdd byte )(uint64 ,error );ReadBool ()(bool ,error );ReadUint32 ()(uint32 ,error );Reset ();StreamPosition ()int64 ;};func (_bcg *Writer )writeBit (_bad uint8 )error {if len (_bcg ._faa )-1< _bcg ._fdbf {return _dg .EOF ;};_fbc :=_bcg ._cgg ;if _bcg ._cad {_fbc =7-_bcg ._cgg ;};_bcg ._faa [_bcg ._fdbf ]|=byte (uint16 (_bad <<_fbc )&0xff);_bcg ._cgg ++;if _bcg ._cgg ==8{_bcg ._fdbf ++;_bcg ._cgg =0;};return nil ;};func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_ag :true }};func (_acg *Writer )UseMSB ()bool {return _acg ._cad };var _ _dg .Writer =&BufferedWriter {};func (_f *BufferedWriter )FinishByte (){if _f ._bd ==0{return ;};_f ._bd =0;_f ._cf ++;};func (_dfd *SubstreamReader )ReadBool ()(bool ,error ){return _dfd .readBool ()};func (_bfa *Reader )BitPosition ()int {return int (_bfa ._eag )};func (_cff *SubstreamReader )ReadByte ()(byte ,error ){if _cff ._gfg ==0{return _cff .readBufferByte ();};return _cff .readUnalignedByte ();};func (_be *BufferedWriter )byteCapacity ()int {_fee :=len (_be ._ab )-_be ._cf ;if _be ._bd !=0{_fee --;};return _fee ;};func NewWriterMSB (data []byte )*Writer {return &Writer {_faa :data ,_cad :true }};