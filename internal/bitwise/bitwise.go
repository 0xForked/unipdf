//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_e "encoding/binary";_bc "errors";_g "github.com/unidoc/unipdf/v3/common";_ba "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_b "io";);func (_be *BufferedWriter )ResetBitIndex (){_be ._ea =0};func (_gec *Reader )ConsumeRemainingBits (){if _gec ._ged !=0{_ ,_fb :=_gec .ReadBits (_gec ._ged );if _fb !=nil {_g .Log .Debug ("\u0043\u006f\u006e\u0073\u0075\u006d\u0065\u0052\u0065\u006da\u0069\u006e\u0069\u0067\u0042\u0069\u0074s\u0020\u0066\u0061\u0069\u006c\u0065\u0064\u003a\u0020\u0025\u0076",_fb );};};};var _ _b .ByteWriter =&BufferedWriter {};func (_gg *BufferedWriter )WriteBits (bits uint64 ,number int )(_cgb int ,_cb error ){const _fff ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";if number < 0||number > 64{return 0,_ba .Errorf (_fff ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );};_db :=number /8;if _db > 0{_ggc :=number -_db *8;for _fef :=_db -1;_fef >=0;_fef --{_bf :=byte ((bits >>uint (_fef *8+_ggc ))&0xff);if _cb =_gg .WriteByte (_bf );_cb !=nil {return _cgb ,_ba .Wrapf (_cb ,_fff ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_db -_fef +1);};};number -=_db *8;if number ==0{return _db ,nil ;};};var _cdc int ;for _ae :=0;_ae < number ;_ae ++{if _gg ._a {_cdc =int ((bits >>uint (number -1-_ae ))&0x1);}else {_cdc =int (bits &0x1);bits >>=1;};if _cb =_gg .WriteBit (_cdc );_cb !=nil {return _cgb ,_ba .Wrapf (_cb ,_fff ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_ae );};};return _db ,nil ;};func (_dag *BufferedWriter )tryGrowByReslice (_cbg int )bool {if _ge :=len (_dag ._cg );_cbg <=cap (_dag ._cg )-_ge {_dag ._cg =_dag ._cg [:_ge +_cbg ];return true ;};return false ;};type Reader struct{_agd []byte ;_fd byte ;_ged byte ;_gf int64 ;_dcb int ;_cga int ;_dfc int64 ;_gd byte ;};func (_ag *BufferedWriter )fullOffset ()int {_dd :=_ag ._eb ;if _ag ._ea !=0{_dd ++;};return _dd ;};func (_adc *SubstreamReader )Read (b []byte )(_bdc int ,_ffe error ){if _adc ._cdb >=_adc ._bfgg {_g .Log .Trace ("\u0053\u0074\u0072e\u0061\u006d\u0050\u006fs\u003a\u0020\u0027\u0025\u0064\u0027\u0020>\u003d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027",_adc ._cdb ,_adc ._bfgg );return 0,_b .EOF ;};for ;_bdc < len (b );_bdc ++{if b [_bdc ],_ffe =_adc .readUnalignedByte ();_ffe !=nil {if _ffe ==_b .EOF {return _bdc ,nil ;};return 0,_ffe ;};};return _bdc ,nil ;};func (_ebd *SubstreamReader )readBool ()(_gdd bool ,_fae error ){if _ebd ._bcaa ==0{_ebd ._bac ,_fae =_ebd .readBufferByte ();if _fae !=nil {return false ,_fae ;};_gdd =(_ebd ._bac &0x80)!=0;_ebd ._bac ,_ebd ._bcaa =_ebd ._bac &0x7f,7;return _gdd ,nil ;};_ebd ._bcaa --;_gdd =(_ebd ._bac &(1<<_ebd ._bcaa ))!=0;_ebd ._bac &=1<<_ebd ._bcaa -1;return _gdd ,nil ;};const (_ga =64;_c =int (^uint (0)>>1););func (_bab *SubstreamReader )Seek (offset int64 ,whence int )(int64 ,error ){switch whence {case _b .SeekStart :_bab ._cdb =uint64 (offset );case _b .SeekCurrent :_bab ._cdb +=uint64 (offset );case _b .SeekEnd :_bab ._cdb =_bab ._bfgg +uint64 (offset );default:return 0,_bc .New ("\u0072\u0065\u0061d\u0065\u0072\u002e\u0053\u0075\u0062\u0073\u0074\u0072\u0065\u0061\u006d\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u0020\u0069\u006e\u0076\u0061\u006ci\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");};_bab ._bcaa =0;return int64 (_bab ._cdb ),nil ;};type StreamReader interface{_b .Reader ;_b .ByteReader ;_b .Seeker ;Align ()byte ;BitPosition ()int ;Mark ();Length ()uint64 ;ReadBit ()(int ,error );ReadBits (_cge byte )(uint64 ,error );ReadBool ()(bool ,error );ReadUint32 ()(uint32 ,error );Reset ();StreamPosition ()int64 ;};var _ BinaryWriter =&BufferedWriter {};func (_cab *SubstreamReader )Length ()uint64 {return _cab ._bfgg };func (_eaf *Reader )readBufferByte ()(byte ,error ){if _eaf ._gf >=int64 (len (_eaf ._agd )){return 0,_b .EOF ;};_eaf ._cga =-1;_ggf :=_eaf ._agd [_eaf ._gf ];_eaf ._gf ++;_eaf ._dcb =int (_ggf );return _ggf ,nil ;};func (_baee *Writer )WriteBits (bits uint64 ,number int )(_cca int ,_fbc error ){const _ccfb ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";if number < 0||number > 64{return 0,_ba .Errorf (_ccfb ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );};if number ==0{return 0,nil ;};_fac :=number /8;if _fac > 0{_gadc :=number -_fac *8;for _dgg :=_fac -1;_dgg >=0;_dgg --{_dbde :=byte ((bits >>uint (_dgg *8+_gadc ))&0xff);if _fbc =_baee .WriteByte (_dbde );_fbc !=nil {return _cca ,_ba .Wrapf (_fbc ,_ccfb ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_fac -_dgg +1);};};number -=_fac *8;if number ==0{return _fac ,nil ;};};var _efa int ;for _gebd :=0;_gebd < number ;_gebd ++{if _baee ._gfa {_efa =int ((bits >>uint (number -1-_gebd ))&0x1);}else {_efa =int (bits &0x1);bits >>=1;};if _fbc =_baee .WriteBit (_efa );_fbc !=nil {return _cca ,_ba .Wrapf (_fbc ,_ccfb ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_gebd );};};return _fac ,nil ;};func (_ece *SubstreamReader )readUnalignedByte ()(_fgb byte ,_bec error ){_gdc :=_ece ._bcaa ;_fgb =_ece ._bac <<(8-_gdc );_ece ._bac ,_bec =_ece .readBufferByte ();if _bec !=nil {return 0,_bec ;};_fgb |=_ece ._bac >>_gdc ;_ece ._bac &=1<<_gdc -1;return _fgb ,nil ;};func (_egce *SubstreamReader )ReadBits (n byte )(_ef uint64 ,_abc error ){if n < _egce ._bcaa {_ecc :=_egce ._bcaa -n ;_ef =uint64 (_egce ._bac >>_ecc );_egce ._bac &=1<<_ecc -1;_egce ._bcaa =_ecc ;return _ef ,nil ;};if n > _egce ._bcaa {if _egce ._bcaa > 0{_ef =uint64 (_egce ._bac );n -=_egce ._bcaa ;};var _cee byte ;for n >=8{_cee ,_abc =_egce .readBufferByte ();if _abc !=nil {return 0,_abc ;};_ef =_ef <<8+uint64 (_cee );n -=8;};if n > 0{if _egce ._bac ,_abc =_egce .readBufferByte ();_abc !=nil {return 0,_abc ;};_gcag :=8-n ;_ef =_ef <<n +uint64 (_egce ._bac >>_gcag );_egce ._bac &=1<<_gcag -1;_egce ._bcaa =_gcag ;}else {_egce ._bcaa =0;};return _ef ,nil ;};_egce ._bcaa =0;return uint64 (_egce ._bac ),nil ;};var (_ _b .Reader =&Reader {};_ _b .ByteReader =&Reader {};_ _b .Seeker =&Reader {};_ StreamReader =&Reader {};);func (_abaa *SubstreamReader )StreamPosition ()int64 {return int64 (_abaa ._cdb )};func (_afe *SubstreamReader )Align ()(_bagg byte ){_bagg =_afe ._bcaa ;_afe ._bcaa =0;return _bagg };func (_bb *BufferedWriter )writeShiftedBytes (_cf []byte )int {for _ ,_ed :=range _cf {_bb .writeByte (_ed );};return len (_cf );};func (_fe *BufferedWriter )Write (d []byte )(int ,error ){_fe .expandIfNeeded (len (d ));if _fe ._ea ==0{return _fe .writeFullBytes (d ),nil ;};return _fe .writeShiftedBytes (d ),nil ;};func (_caf *Writer )byteCapacity ()int {_cec :=len (_caf ._dg )-_caf ._bee ;if _caf ._deb !=0{_cec --;};return _cec ;};func (_de *Reader )Align ()(_aeef byte ){_aeef =_de ._ged ;_de ._ged =0;return _aeef };func (_bca *Reader )read (_fgg []byte )(int ,error ){if _bca ._gf >=int64 (len (_bca ._agd )){return 0,_b .EOF ;};_bca ._cga =-1;_bcf :=copy (_fgg ,_bca ._agd [_bca ._gf :]);_bca ._gf +=int64 (_bcf );return _bcf ,nil ;};func (_afa *Reader )ReadByte ()(byte ,error ){if _afa ._ged ==0{return _afa .readBufferByte ();};return _afa .readUnalignedByte ();};func (_ec *Reader )ReadBits (n byte )(_gcb uint64 ,_fg error ){if n < _ec ._ged {_aedb :=_ec ._ged -n ;_gcb =uint64 (_ec ._fd >>_aedb );_ec ._fd &=1<<_aedb -1;_ec ._ged =_aedb ;return _gcb ,nil ;};if n > _ec ._ged {if _ec ._ged > 0{_gcb =uint64 (_ec ._fd );n -=_ec ._ged ;};for n >=8{_bbf ,_bae :=_ec .readBufferByte ();if _bae !=nil {return 0,_bae ;};_gcb =_gcb <<8+uint64 (_bbf );n -=8;};if n > 0{if _ec ._fd ,_fg =_ec .readBufferByte ();_fg !=nil {return 0,_fg ;};_age :=8-n ;_gcb =_gcb <<n +uint64 (_ec ._fd >>_age );_ec ._fd &=1<<_age -1;_ec ._ged =_age ;}else {_ec ._ged =0;};return _gcb ,nil ;};_ec ._ged =0;return uint64 (_ec ._fd ),nil ;};func (_aaa *Writer )writeBit (_fag uint8 )error {if len (_aaa ._dg )-1< _aaa ._bee {return _b .EOF ;};_edf :=_aaa ._deb ;if _aaa ._gfa {_edf =7-_aaa ._deb ;};_aaa ._dg [_aaa ._bee ]|=byte (uint16 (_fag <<_edf )&0xff);_aaa ._deb ++;if _aaa ._deb ==8{_aaa ._bee ++;_aaa ._deb =0;};return nil ;};type BinaryWriter interface{BitWriter ;_b .Writer ;_b .ByteWriter ;Data ()[]byte ;};func (_ca *BufferedWriter )Len ()int {return _ca .byteCapacity ()};func (_agaa *Reader )ReadBit ()(_dcbd int ,_gc error ){_gea ,_gc :=_agaa .readBool ();if _gc !=nil {return 0,_gc ;};if _gea {_dcbd =1;};return _dcbd ,nil ;};func (_dc *BufferedWriter )grow (_aee int ){if _dc ._cg ==nil &&_aee < _ga {_dc ._cg =make ([]byte ,_aee ,_ga );return ;};_eab :=len (_dc ._cg );if _dc ._ea !=0{_eab ++;};_cgc :=cap (_dc ._cg );switch {case _aee <=_cgc /2-_eab :_g .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_dc ._cg ),cap (_dc ._cg ),_aee );_g .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_cgc ,_eab );copy (_dc ._cg ,_dc ._cg [_dc .fullOffset ():]);case _cgc > _c -_cgc -_aee :_g .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_dce :=make ([]byte ,2*_cgc +_aee );copy (_dce ,_dc ._cg );_dc ._cg =_dce ;};_dc ._cg =_dc ._cg [:_eab +_aee ];};func (_dab *SubstreamReader )Reset (){_dab ._cdb =_dab ._fdb ;_dab ._bcaa =_dab ._aa };func (_ada *BufferedWriter )writeByte (_bcg byte ){switch {case _ada ._ea ==0:_ada ._cg [_ada ._eb ]=_bcg ;_ada ._eb ++;case _ada ._a :_ada ._cg [_ada ._eb ]|=_bcg >>_ada ._ea ;_ada ._eb ++;_ada ._cg [_ada ._eb ]=byte (uint16 (_bcg )<<(8-_ada ._ea )&0xff);default:_ada ._cg [_ada ._eb ]|=byte (uint16 (_bcg )<<_ada ._ea &0xff);_ada ._eb ++;_ada ._cg [_ada ._eb ]=_bcg >>(8-_ada ._ea );};};func (_cfbf *Writer )WriteByte (c byte )error {return _cfbf .writeByte (c )};func NewReader (data []byte )*Reader {return &Reader {_agd :data }};func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_a :true }};func (_beg *BufferedWriter )WriteByte (bt byte )error {if _beg ._eb > len (_beg ._cg )-1||(_beg ._eb ==len (_beg ._cg )-1&&_beg ._ea !=0){_beg .expandIfNeeded (1);};_beg .writeByte (bt );return nil ;};func (_dda *SubstreamReader )readBufferByte ()(byte ,error ){if _dda ._cdb >=_dda ._bfgg {return 0,_b .EOF ;};if _dda ._cdb >=_dda ._fba ||_dda ._cdb < _dda ._cc {if _cfd :=_dda .fillBuffer ();_cfd !=nil {return 0,_cfd ;};};_bge :=_dda ._bed [_dda ._cdb -_dda ._cc ];_dda ._cdb ++;return _bge ,nil ;};func (_bd *BufferedWriter )Reset (){_bd ._cg =_bd ._cg [:0];_bd ._eb =0;_bd ._ea =0};type Writer struct{_dg []byte ;_deb uint8 ;_bee int ;_gfa bool ;};func (_bcd *Writer )Data ()[]byte {return _bcd ._dg };func NewWriterMSB (data []byte )*Writer {return &Writer {_dg :data ,_gfa :true }};func (_df *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _ba .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );};if len (_df ._cg )-1< _df ._eb {_df .expandIfNeeded (1);};_cd :=_df ._ea ;if _df ._a {_cd =7-_df ._ea ;};_df ._cg [_df ._eb ]|=byte (uint16 (bit <<_cd )&0xff);_df ._ea ++;if _df ._ea ==8{_df ._eb ++;_df ._ea =0;};return nil ;};func (_dbd *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _dbd .writeBit (uint8 (bit ));};return _ba .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");};func (_gbb *Writer )Write (p []byte )(int ,error ){if len (p )> _gbb .byteCapacity (){return 0,_b .EOF ;};for _ ,_cbge :=range p {if _dfda :=_gbb .writeByte (_cbge );_dfda !=nil {return 0,_dfda ;};};return len (p ),nil ;};func (_edd *SubstreamReader )ReadBool ()(bool ,error ){return _edd .readBool ()};type BitWriter interface{WriteBit (_ddg int )error ;WriteBits (_dac uint64 ,_ce int )(_fc int ,_aga error );FinishByte ();SkipBits (_beb int )error ;};type BufferedWriter struct{_cg []byte ;_ea uint8 ;_eb int ;_a bool ;};func (_bg *SubstreamReader )ReadUint32 ()(uint32 ,error ){_fbe :=make ([]byte ,4);_ ,_bgd :=_bg .Read (_fbe );if _bgd !=nil {return 0,_bgd ;};return _e .BigEndian .Uint32 (_fbe ),nil ;};func (_geg *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_geg ._cga =-1;var _dace int64 ;switch whence {case _b .SeekStart :_dace =offset ;case _b .SeekCurrent :_dace =_geg ._gf +offset ;case _b .SeekEnd :_dace =int64 (len (_geg ._agd ))+offset ;default:return 0,_bc .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");};if _dace < 0{return 0,_bc .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");};_geg ._gf =_dace ;_geg ._ged =0;return _dace ,nil ;};func (_abg *SubstreamReader )ReadBit ()(_gac int ,_ecg error ){_dbg ,_ecg :=_abg .readBool ();if _ecg !=nil {return 0,_ecg ;};if _dbg {_gac =1;};return _gac ,nil ;};func (_ccf *Writer )UseMSB ()bool {return _ccf ._gfa };type SubstreamReader struct{_cdb uint64 ;_geb StreamReader ;_egc uint64 ;_bfgg uint64 ;_bed []byte ;_cc uint64 ;_fba uint64 ;_bac byte ;_bcaa byte ;_fdb uint64 ;_aa byte ;};func (_gdg *Reader )Reset (){_gdg ._gf =_gdg ._dfc ;_gdg ._ged =_gdg ._gd };func (_bedg *SubstreamReader )Mark (){_bedg ._fdb =_bedg ._cdb ;_bedg ._aa =_bedg ._bcaa };var _ _b .Writer =&BufferedWriter {};func (_bbc *Writer )FinishByte (){if _bbc ._deb ==0{return ;};_bbc ._deb =0;_bbc ._bee ++;};func (_bgea *Writer )SkipBits (skip int )error {const _gba ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";if skip ==0{return nil ;};_ggb :=int (_bgea ._deb )+skip ;if _ggb >=0&&_ggb < 8{_bgea ._deb =uint8 (_ggb );return nil ;};_ggb =int (_bgea ._deb )+_bgea ._bee *8+skip ;if _ggb < 0{return _ba .Errorf (_gba ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_cdgf :=_ggb /8;_fga :=_ggb %8;_g .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");_g .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_bgea ._deb ,_bgea ._bee ,int (_bgea ._deb )+(_bgea ._bee )*8,len (_bgea ._dg ),cap (_bgea ._dg ));_g .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_ggb ,_fga );_bgea ._deb =uint8 (_fga );if _dfb :=_cdgf -_bgea ._bee ;_dfb > 0&&len (_bgea ._dg )-1< _cdgf {_g .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_dfb );return _ba .Errorf (_gba ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_bgea ._bee =_cdgf ;_g .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_bgea ._deb ,_bgea ._bee );return nil ;};func (_fbd *Reader )Length ()uint64 {return uint64 (len (_fbd ._agd ))};func (_ggcb *SubstreamReader )fillBuffer ()error {if uint64 (_ggcb ._geb .StreamPosition ())!=_ggcb ._cdb +_ggcb ._egc {_ ,_fgd :=_ggcb ._geb .Seek (int64 (_ggcb ._cdb +_ggcb ._egc ),_b .SeekStart );if _fgd !=nil {return _fgd ;};};_ggcb ._cc =_ggcb ._cdb ;_eafb :=_eecf (uint64 (len (_ggcb ._bed )),_ggcb ._bfgg -_ggcb ._cdb );_daf :=make ([]byte ,_eafb );_bcc ,_fca :=_ggcb ._geb .Read (_daf );if _fca !=nil {return _fca ;};for _gb :=uint64 (0);_gb < _eafb ;_gb ++{_ggcb ._bed [_gb ]=_daf [_gb ];};_ggcb ._fba =_ggcb ._cc +uint64 (_bcc );return nil ;};func (_cbb *BufferedWriter )writeFullBytes (_baa []byte )int {_aef :=copy (_cbb ._cg [_cbb .fullOffset ():],_baa );_cbb ._eb +=_aef ;return _aef ;};func NewSubstreamReader (r StreamReader ,offset ,length uint64 )(*SubstreamReader ,error ){if r ==nil {return nil ,_bc .New ("\u0072o\u006ft\u0020\u0072\u0065\u0061\u0064e\u0072\u0020i\u0073\u0020\u006e\u0069\u006c");};_g .Log .Trace ("\u004e\u0065\u0077\u0053\u0075\u0062\u0073\u0074r\u0065\u0061\u006dRe\u0061\u0064\u0065\u0072\u0020\u0061t\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u003a\u0020\u0025\u0064\u0020\u0077\u0069\u0074h\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a \u0025\u0064",offset ,length );return &SubstreamReader {_geb :r ,_egc :offset ,_bfgg :length ,_bed :make ([]byte ,length )},nil ;};func (_bag *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;};_ac :=int (_bag ._ea )+skip ;if _ac >=0&&_ac < 8{_bag ._ea =uint8 (_ac );return nil ;};_ac =int (_bag ._ea )+_bag ._eb *8+skip ;if _ac < 0{return _ba .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_ff :=_ac /8;_da :=_ac %8;_bag ._ea =uint8 (_da );if _ad :=_ff -_bag ._eb ;_ad > 0&&len (_bag ._cg )-1< _ff {if _bag ._ea !=0{_ad ++;};_bag .expandIfNeeded (_ad );};_bag ._eb =_ff ;return nil ;};func (_ee *BufferedWriter )FinishByte (){if _ee ._ea ==0{return ;};_ee ._ea =0;_ee ._eb ++;};func (_gab *BufferedWriter )byteCapacity ()int {_bef :=len (_gab ._cg )-_gab ._eb ;if _gab ._ea !=0{_bef --;};return _bef ;};func (_bbe *Writer )ResetBit (){_bbe ._deb =0};func (_gad *SubstreamReader )ReadByte ()(byte ,error ){if _gad ._bcaa ==0{return _gad .readBufferByte ();};return _gad .readUnalignedByte ();};func (_cea *Reader )ReadUint32 ()(uint32 ,error ){_gca :=make ([]byte ,4);_ ,_bbg :=_cea .Read (_gca );if _bbg !=nil {return 0,_bbg ;};return _e .BigEndian .Uint32 (_gca ),nil ;};func (_aed *Reader )Read (p []byte )(_ffb int ,_ede error ){if _aed ._ged ==0{return _aed .read (p );};for ;_ffb < len (p );_ffb ++{if p [_ffb ],_ede =_aed .readUnalignedByte ();_ede !=nil {return 0,_ede ;};};return _ffb ,nil ;};func (_adf *Reader )ReadBool ()(bool ,error ){return _adf .readBool ()};func NewWriter (data []byte )*Writer {return &Writer {_dg :data }};func (_bbgd *Reader )StreamPosition ()int64 {return _bbgd ._gf };func (_eg *Reader )BitPosition ()int {return int (_eg ._ged )};func (_dbf *Reader )readBool ()(_gfd bool ,_aba error ){if _dbf ._ged ==0{_dbf ._fd ,_aba =_dbf .readBufferByte ();if _aba !=nil {return false ,_aba ;};_gfd =(_dbf ._fd &0x80)!=0;_dbf ._fd ,_dbf ._ged =_dbf ._fd &0x7f,7;return _gfd ,nil ;};_dbf ._ged --;_gfd =(_dbf ._fd &(1<<_dbf ._ged ))!=0;_dbf ._fd &=1<<_dbf ._ged -1;return _gfd ,nil ;};func (_fab *SubstreamReader )BitPosition ()int {return int (_fab ._bcaa )};func (_agb *Reader )Mark (){_agb ._dfc =_agb ._gf ;_agb ._gd =_agb ._ged };var _ BinaryWriter =&Writer {};func (_egg *SubstreamReader )Offset ()uint64 {return _egg ._egc };func (_fa *BufferedWriter )Data ()[]byte {return _fa ._cg };func (_bfg *Reader )readUnalignedByte ()(_aea byte ,_edb error ){_gegd :=_bfg ._ged ;_aea =_bfg ._fd <<(8-_gegd );_bfg ._fd ,_edb =_bfg .readBufferByte ();if _edb !=nil {return 0,_edb ;};_aea |=_bfg ._fd >>_gegd ;_bfg ._fd &=1<<_gegd -1;return _aea ,nil ;};func _eecf (_ege ,_eabd uint64 )uint64 {if _ege < _eabd {return _ege ;};return _eabd ;};func (_af *BufferedWriter )expandIfNeeded (_faa int ){if !_af .tryGrowByReslice (_faa ){_af .grow (_faa );};};func (_dabe *Writer )writeByte (_baf byte )error {if _dabe ._bee > len (_dabe ._dg )-1{return _b .EOF ;};if _dabe ._bee ==len (_dabe ._dg )-1&&_dabe ._deb !=0{return _b .EOF ;};if _dabe ._deb ==0{_dabe ._dg [_dabe ._bee ]=_baf ;_dabe ._bee ++;return nil ;};if _dabe ._gfa {_dabe ._dg [_dabe ._bee ]|=_baf >>_dabe ._deb ;_dabe ._bee ++;_dabe ._dg [_dabe ._bee ]=byte (uint16 (_baf )<<(8-_dabe ._deb )&0xff);}else {_dabe ._dg [_dabe ._bee ]|=byte (uint16 (_baf )<<_dabe ._deb &0xff);_dabe ._bee ++;_dabe ._dg [_dabe ._bee ]=_baf >>(8-_dabe ._deb );};return nil ;};