//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_bg "encoding/binary";_c "errors";_a "github.com/unidoc/unipdf/v3/common";_d "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_e "io";);func (_eg *Reader )Length ()uint64 {return uint64 (len (_eg ._ddf ))};func (_fcg *BufferedWriter )WriteBits (bits uint64 ,number int )(_fe int ,_bc error ){const _faa ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";
if number < 0||number > 64{return 0,_d .Errorf (_faa ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};_fff :=number /8;if _fff > 0{_aaea :=number -_fff *8;for _acd :=_fff -1;_acd >=0;_acd --{_bcd :=byte ((bits >>uint (_acd *8+_aaea ))&0xff);if _bc =_fcg .WriteByte (_bcd );_bc !=nil {return _fe ,_d .Wrapf (_bc ,_faa ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_fff -_acd +1);
};};number -=_fff *8;if number ==0{return _fff ,nil ;};};var _cc int ;for _cb :=0;_cb < number ;_cb ++{if _fcg ._cd {_cc =int ((bits >>uint (number -1-_cb ))&0x1);}else {_cc =int (bits &0x1);bits >>=1;};if _bc =_fcg .WriteBit (_cc );_bc !=nil {return _fe ,_d .Wrapf (_bc ,_faa ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_cb );
};};return _fff ,nil ;};func (_aec *SubstreamReader )Seek (offset int64 ,whence int )(int64 ,error ){switch whence {case _e .SeekStart :_aec ._ege =uint64 (offset );case _e .SeekCurrent :_aec ._ege +=uint64 (offset );case _e .SeekEnd :_aec ._ege =_aec ._ebc +uint64 (offset );
default:return 0,_c .New ("\u0072\u0065\u0061d\u0065\u0072\u002e\u0053\u0075\u0062\u0073\u0074\u0072\u0065\u0061\u006d\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u0020\u0069\u006e\u0076\u0061\u006ci\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};_aec ._bcg =0;return int64 (_aec ._ege ),nil ;};const (_f =64;_fc =int (^uint (0)>>1););func (_gd *BufferedWriter )tryGrowByReslice (_gf int )bool {if _ad :=len (_gd ._aae );_gf <=cap (_gd ._aae )-_ad {_gd ._aae =_gd ._aae [:_ad +_gf ];return true ;};
return false ;};func (_faeb *SubstreamReader )Offset ()uint64 {return _faeb ._dgb };func (_edc *Reader )ReadBool ()(bool ,error ){return _edc .readBool ()};type BufferedWriter struct{_aae []byte ;_g uint8 ;_fb int ;_cd bool ;};type Reader struct{_ddf []byte ;
_gac byte ;_ae byte ;_dgd int64 ;_ec int ;_gfe int ;_fbb int64 ;_gdg byte ;};func (_ddfa *Writer )Data ()[]byte {return _ddfa ._bae };func (_bag *SubstreamReader )ReadBits (n byte )(_cgc uint64 ,_gcg error ){if n < _bag ._bcg {_fcda :=_bag ._bcg -n ;_cgc =uint64 (_bag ._gcd >>_fcda );
_bag ._gcd &=1<<_fcda -1;_bag ._bcg =_fcda ;return _cgc ,nil ;};if n > _bag ._bcg {if _bag ._bcg > 0{_cgc =uint64 (_bag ._gcd );n -=_bag ._bcg ;};var _eda byte ;for n >=8{_eda ,_gcg =_bag .readBufferByte ();if _gcg !=nil {return 0,_gcg ;};_cgc =_cgc <<8+uint64 (_eda );
n -=8;};if n > 0{if _bag ._gcd ,_gcg =_bag .readBufferByte ();_gcg !=nil {return 0,_gcg ;};_dcda :=8-n ;_cgc =_cgc <<n +uint64 (_bag ._gcd >>_dcda );_bag ._gcd &=1<<_dcda -1;_bag ._bcg =_dcda ;}else {_bag ._bcg =0;};return _cgc ,nil ;};_bag ._bcg =0;return uint64 (_bag ._gcd ),nil ;
};func (_gea *SubstreamReader )Read (b []byte )(_ced int ,_ega error ){if _gea ._ege >=_gea ._ebc {_a .Log .Trace ("\u0053\u0074\u0072e\u0061\u006d\u0050\u006fs\u003a\u0020\u0027\u0025\u0064\u0027\u0020>\u003d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027",_gea ._ege ,_gea ._ebc );
return 0,_e .EOF ;};for ;_ced < len (b );_ced ++{if b [_ced ],_ega =_gea .readUnalignedByte ();_ega !=nil {if _ega ==_e .EOF {return _ced ,nil ;};return 0,_ega ;};};return _ced ,nil ;};func (_dc *BufferedWriter )Len ()int {return _dc .byteCapacity ()};
func (_bgcf *SubstreamReader )Mark (){_bgcf ._bea =_bgcf ._ege ;_bgcf ._aeb =_bgcf ._bcg };func (_aee *Reader )Mark (){_aee ._fbb =_aee ._dgd ;_aee ._gdg =_aee ._ae };func (_ccd *Reader )readUnalignedByte ()(_dcg byte ,_fbfd error ){_bgfd :=_ccd ._ae ;
_dcg =_ccd ._gac <<(8-_bgfd );_ccd ._gac ,_fbfd =_ccd .readBufferByte ();if _fbfd !=nil {return 0,_fbfd ;};_dcg |=_ccd ._gac >>_bgfd ;_ccd ._gac &=1<<_bgfd -1;return _dcg ,nil ;};func (_fa *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _d .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );
};if len (_fa ._aae )-1< _fa ._fb {_fa .expandIfNeeded (1);};_fae :=_fa ._g ;if _fa ._cd {_fae =7-_fa ._g ;};_fa ._aae [_fa ._fb ]|=byte (uint16 (bit <<_fae )&0xff);_fa ._g ++;if _fa ._g ==8{_fa ._fb ++;_fa ._g =0;};return nil ;};func (_bf *BufferedWriter )Reset (){_bf ._aae =_bf ._aae [:0];
_bf ._fb =0;_bf ._g =0};func (_bfa *Reader )Align ()(_fac byte ){_fac =_bfa ._ae ;_bfa ._ae =0;return _fac };func (_fag *Writer )writeByte (_cgb byte )error {if _fag ._eef > len (_fag ._bae )-1{return _e .EOF ;};if _fag ._eef ==len (_fag ._bae )-1&&_fag ._afef !=0{return _e .EOF ;
};if _fag ._afef ==0{_fag ._bae [_fag ._eef ]=_cgb ;_fag ._eef ++;return nil ;};if _fag ._bfcd {_fag ._bae [_fag ._eef ]|=_cgb >>_fag ._afef ;_fag ._eef ++;_fag ._bae [_fag ._eef ]=byte (uint16 (_cgb )<<(8-_fag ._afef )&0xff);}else {_fag ._bae [_fag ._eef ]|=byte (uint16 (_cgb )<<_fag ._afef &0xff);
_fag ._eef ++;_fag ._bae [_fag ._eef ]=_cgb >>(8-_fag ._afef );};return nil ;};func (_dfg *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_dfg ._gfe =-1;var _bbe int64 ;switch whence {case _e .SeekStart :_bbe =offset ;case _e .SeekCurrent :_bbe =_dfg ._dgd +offset ;
case _e .SeekEnd :_bbe =int64 (len (_dfg ._ddf ))+offset ;default:return 0,_c .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};if _bbe < 0{return 0,_c .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");};_dfg ._dgd =_bbe ;
_dfg ._ae =0;return _bbe ,nil ;};var _ BinaryWriter =&Writer {};func (_fbfe *SubstreamReader )readUnalignedByte ()(_ggb byte ,_gba error ){_bffg :=_fbfe ._bcg ;_ggb =_fbfe ._gcd <<(8-_bffg );_fbfe ._gcd ,_gba =_fbfe .readBufferByte ();if _gba !=nil {return 0,_gba ;
};_ggb |=_fbfe ._gcd >>_bffg ;_fbfe ._gcd &=1<<_bffg -1;return _ggb ,nil ;};func (_fcc *BufferedWriter )WriteByte (bt byte )error {if _fcc ._fb > len (_fcc ._aae )-1||(_fcc ._fb ==len (_fcc ._aae )-1&&_fcc ._g !=0){_fcc .expandIfNeeded (1);};_fcc .writeByte (bt );
return nil ;};func (_fce *BufferedWriter )FinishByte (){if _fce ._g ==0{return ;};_fce ._g =0;_fce ._fb ++;};func (_geg *Writer )FinishByte (){if _geg ._afef ==0{return ;};_geg ._afef =0;_geg ._eef ++;};func (_df *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;
};_fd :=int (_df ._g )+skip ;if _fd >=0&&_fd < 8{_df ._g =uint8 (_fd );return nil ;};_fd =int (_df ._g )+_df ._fb *8+skip ;if _fd < 0{return _d .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_fbg :=_fd /8;_af :=_fd %8;_df ._g =uint8 (_af );if _ff :=_fbg -_df ._fb ;_ff > 0&&len (_df ._aae )-1< _fbg {if _df ._g !=0{_ff ++;};_df .expandIfNeeded (_ff );};_df ._fb =_fbg ;return nil ;};func (_ef *Reader )Reset (){_ef ._dgd =_ef ._fbb ;_ef ._ae =_ef ._gdg };
func (_bgc *Reader )read (_bgf []byte )(int ,error ){if _bgc ._dgd >=int64 (len (_bgc ._ddf )){return 0,_e .EOF ;};_bgc ._gfe =-1;_dab :=copy (_bgf ,_bgc ._ddf [_bgc ._dgd :]);_bgc ._dgd +=int64 (_dab );return _dab ,nil ;};func (_gfd *SubstreamReader )ReadUint32 ()(uint32 ,error ){_dgbd :=make ([]byte ,4);
_ ,_fba :=_gfd .Read (_dgbd );if _fba !=nil {return 0,_fba ;};return _bg .BigEndian .Uint32 (_dgbd ),nil ;};var (_ _e .Reader =&Reader {};_ _e .ByteReader =&Reader {};_ _e .Seeker =&Reader {};_ StreamReader =&Reader {};);func (_aab *Reader )ReadBits (n byte )(_fg uint64 ,_ccb error ){if n < _aab ._ae {_fbf :=_aab ._ae -n ;
_fg =uint64 (_aab ._gac >>_fbf );_aab ._gac &=1<<_fbf -1;_aab ._ae =_fbf ;return _fg ,nil ;};if n > _aab ._ae {if _aab ._ae > 0{_fg =uint64 (_aab ._gac );n -=_aab ._ae ;};for n >=8{_gce ,_eb :=_aab .readBufferByte ();if _eb !=nil {return 0,_eb ;};_fg =_fg <<8+uint64 (_gce );
n -=8;};if n > 0{if _aab ._gac ,_ccb =_aab .readBufferByte ();_ccb !=nil {return 0,_ccb ;};_abb :=8-n ;_fg =_fg <<n +uint64 (_aab ._gac >>_abb );_aab ._gac &=1<<_abb -1;_aab ._ae =_abb ;}else {_aab ._ae =0;};return _fg ,nil ;};_aab ._ae =0;return uint64 (_aab ._gac ),nil ;
};func (_fab *Writer )writeBit (_fbfee uint8 )error {if len (_fab ._bae )-1< _fab ._eef {return _e .EOF ;};_cfe :=_fab ._afef ;if _fab ._bfcd {_cfe =7-_fab ._afef ;};_fab ._bae [_fab ._eef ]|=byte (uint16 (_fbfee <<_cfe )&0xff);_fab ._afef ++;if _fab ._afef ==8{_fab ._eef ++;
_fab ._afef =0;};return nil ;};func (_cea *SubstreamReader )readBufferByte ()(byte ,error ){if _cea ._ege >=_cea ._ebc {return 0,_e .EOF ;};if _cea ._ege >=_cea ._eaf ||_cea ._ege < _cea ._ee {if _ged :=_cea .fillBuffer ();_ged !=nil {return 0,_ged ;};
};_cac :=_cea ._aed [_cea ._ege -_cea ._ee ];_cea ._ege ++;return _cac ,nil ;};func (_ac *BufferedWriter )ResetBitIndex (){_ac ._g =0};func NewSubstreamReader (r StreamReader ,offset ,length uint64 )(*SubstreamReader ,error ){if r ==nil {return nil ,_c .New ("\u0072o\u006ft\u0020\u0072\u0065\u0061\u0064e\u0072\u0020i\u0073\u0020\u006e\u0069\u006c");
};_a .Log .Trace ("\u004e\u0065\u0077\u0053\u0075\u0062\u0073\u0074r\u0065\u0061\u006dRe\u0061\u0064\u0065\u0072\u0020\u0061t\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u003a\u0020\u0025\u0064\u0020\u0077\u0069\u0074h\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a \u0025\u0064",offset ,length );
return &SubstreamReader {_gcc :r ,_dgb :offset ,_ebc :length ,_aed :make ([]byte ,length )},nil ;};func (_feg *BufferedWriter )writeByte (_dd byte ){switch {case _feg ._g ==0:_feg ._aae [_feg ._fb ]=_dd ;_feg ._fb ++;case _feg ._cd :_feg ._aae [_feg ._fb ]|=_dd >>_feg ._g ;
_feg ._fb ++;_feg ._aae [_feg ._fb ]=byte (uint16 (_dd )<<(8-_feg ._g )&0xff);default:_feg ._aae [_feg ._fb ]|=byte (uint16 (_dd )<<_feg ._g &0xff);_feg ._fb ++;_feg ._aae [_feg ._fb ]=_dd >>(8-_feg ._g );};};var _ _e .Writer =&BufferedWriter {};func NewWriterMSB (data []byte )*Writer {return &Writer {_bae :data ,_bfcd :true }};
func (_fdb *Reader )StreamPosition ()int64 {return _fdb ._dgd };func (_cfb *Writer )byteCapacity ()int {_bead :=len (_cfb ._bae )-_cfb ._eef ;if _cfb ._afef !=0{_bead --;};return _bead ;};func (_ba *Reader )ReadByte ()(byte ,error ){if _ba ._ae ==0{return _ba .readBufferByte ();
};return _ba .readUnalignedByte ();};func (_bb *Reader )ReadBit ()(_dfec int ,_faf error ){_gbe ,_faf :=_bb .readBool ();if _faf !=nil {return 0,_faf ;};if _gbe {_dfec =1;};return _dfec ,nil ;};func (_ccg *Writer )WriteByte (c byte )error {return _ccg .writeByte (c )};
func (_gg *BufferedWriter )grow (_dcdf int ){if _gg ._aae ==nil &&_dcdf < _f {_gg ._aae =make ([]byte ,_dcdf ,_f );return ;};_cg :=len (_gg ._aae );if _gg ._g !=0{_cg ++;};_gb :=cap (_gg ._aae );switch {case _dcdf <=_gb /2-_cg :_a .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_gg ._aae ),cap (_gg ._aae ),_dcdf );
_a .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_gb ,_cg );copy (_gg ._aae ,_gg ._aae [_gg .fullOffset ():]);
case _gb > _fc -_gb -_dcdf :_a .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_ea :=make ([]byte ,2*_gb +_dcdf );copy (_ea ,_gg ._aae );_gg ._aae =_ea ;};_gg ._aae =_gg ._aae [:_cg +_dcdf ];
};func (_fcd *Reader )readBufferByte ()(byte ,error ){if _fcd ._dgd >=int64 (len (_fcd ._ddf )){return 0,_e .EOF ;};_fcd ._gfe =-1;_ecg :=_fcd ._ddf [_fcd ._dgd ];_fcd ._dgd ++;_fcd ._ec =int (_ecg );return _ecg ,nil ;};func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_cd :true }};
func NewReader (data []byte )*Reader {return &Reader {_ddf :data }};type BinaryWriter interface{BitWriter ;_e .Writer ;_e .ByteWriter ;Data ()[]byte ;};func (_fbgd *BufferedWriter )writeFullBytes (_cad []byte )int {_be :=copy (_fbgd ._aae [_fbgd .fullOffset ():],_cad );
_fbgd ._fb +=_be ;return _be ;};type Writer struct{_bae []byte ;_afef uint8 ;_eef int ;_bfcd bool ;};func (_dg *BufferedWriter )Write (d []byte )(int ,error ){_dg .expandIfNeeded (len (d ));if _dg ._g ==0{return _dg .writeFullBytes (d ),nil ;};return _dg .writeShiftedBytes (d ),nil ;
};func (_cafg *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _cafg .writeBit (uint8 (bit ));};return _d .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");
};func (_gbea *SubstreamReader )readBool ()(_aaa bool ,_cdb error ){if _gbea ._bcg ==0{_gbea ._gcd ,_cdb =_gbea .readBufferByte ();if _cdb !=nil {return false ,_cdb ;};_aaa =(_gbea ._gcd &0x80)!=0;_gbea ._gcd ,_gbea ._bcg =_gbea ._gcd &0x7f,7;return _aaa ,nil ;
};_gbea ._bcg --;_aaa =(_gbea ._gcd &(1<<_gbea ._bcg ))!=0;_gbea ._gcd &=1<<_gbea ._bcg -1;return _aaa ,nil ;};func (_caf *Reader )BitPosition ()int {return int (_caf ._ae )};var _ _e .ByteWriter =&BufferedWriter {};func (_eafg *SubstreamReader )Reset (){_eafg ._ege =_eafg ._bea ;
_eafg ._bcg =_eafg ._aeb };func (_ce *Reader )ConsumeRemainingBits (){if _ce ._ae !=0{_ ,_dfb :=_ce .ReadBits (_ce ._ae );if _dfb !=nil {_a .Log .Debug ("\u0043\u006f\u006e\u0073\u0075\u006d\u0065\u0052\u0065\u006da\u0069\u006e\u0069\u0067\u0042\u0069\u0074s\u0020\u0066\u0061\u0069\u006c\u0065\u0064\u003a\u0020\u0025\u0076",_dfb );
};};};type BitWriter interface{WriteBit (_ffb int )error ;WriteBits (_ed uint64 ,_ga int )(_gfc int ,_acdg error );FinishByte ();SkipBits (_cdg int )error ;};func (_de *Reader )Read (p []byte )(_bee int ,_fdf error ){if _de ._ae ==0{return _de .read (p );
};for ;_bee < len (p );_bee ++{if p [_bee ],_fdf =_de .readUnalignedByte ();_fdf !=nil {return 0,_fdf ;};};return _bee ,nil ;};func (_fccae *Reader )readBool ()(_acc bool ,_faed error ){if _fccae ._ae ==0{_fccae ._gac ,_faed =_fccae .readBufferByte ();
if _faed !=nil {return false ,_faed ;};_acc =(_fccae ._gac &0x80)!=0;_fccae ._gac ,_fccae ._ae =_fccae ._gac &0x7f,7;return _acc ,nil ;};_fccae ._ae --;_acc =(_fccae ._gac &(1<<_fccae ._ae ))!=0;_fccae ._gac &=1<<_fccae ._ae -1;return _acc ,nil ;};func (_fcca *BufferedWriter )byteCapacity ()int {_bfc :=len (_fcca ._aae )-_fcca ._fb ;
if _fcca ._g !=0{_bfc --;};return _bfc ;};func (_eaa *SubstreamReader )StreamPosition ()int64 {return int64 (_eaa ._ege )};func (_egg *Reader )ReadUint32 ()(uint32 ,error ){_ebd :=make ([]byte ,4);_ ,_aca :=_egg .Read (_ebd );if _aca !=nil {return 0,_aca ;
};return _bg .BigEndian .Uint32 (_ebd ),nil ;};func _bfb (_abg ,_dcb uint64 )uint64 {if _abg < _dcb {return _abg ;};return _dcb ;};func (_da *BufferedWriter )Data ()[]byte {return _da ._aae };func (_cbd *Writer )UseMSB ()bool {return _cbd ._bfcd };func (_gfef *Writer )ResetBit (){_gfef ._afef =0};
func (_ceb *SubstreamReader )Align ()(_bce byte ){_bce =_ceb ._bcg ;_ceb ._bcg =0;return _bce };func (_cacf *Writer )SkipBits (skip int )error {const _fea ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";if skip ==0{return nil ;
};_bge :=int (_cacf ._afef )+skip ;if _bge >=0&&_bge < 8{_cacf ._afef =uint8 (_bge );return nil ;};_bge =int (_cacf ._afef )+_cacf ._eef *8+skip ;if _bge < 0{return _d .Errorf (_fea ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_bbc :=_bge /8;_baf :=_bge %8;_a .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");_a .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_cacf ._afef ,_cacf ._eef ,int (_cacf ._afef )+(_cacf ._eef )*8,len (_cacf ._bae ),cap (_cacf ._bae ));
_a .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_bge ,_baf );_cacf ._afef =uint8 (_baf );if _aea :=_bbc -_cacf ._eef ;
_aea > 0&&len (_cacf ._bae )-1< _bbc {_a .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_aea );return _d .Errorf (_fea ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_cacf ._eef =_bbc ;
_a .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_cacf ._afef ,_cacf ._eef );return nil ;};type SubstreamReader struct{_ege uint64 ;
_gcc StreamReader ;_dgb uint64 ;_ebc uint64 ;_aed []byte ;_ee uint64 ;_eaf uint64 ;_gcd byte ;_bcg byte ;_bea uint64 ;_aeb byte ;};var _ BinaryWriter =&BufferedWriter {};func (_bbb *SubstreamReader )ReadByte ()(byte ,error ){if _bbb ._bcg ==0{return _bbb .readBufferByte ();
};return _bbb .readUnalignedByte ();};func (_eafc *SubstreamReader )Length ()uint64 {return _eafc ._ebc };func NewWriter (data []byte )*Writer {return &Writer {_bae :data }};func (_ge *BufferedWriter )fullOffset ()int {_ab :=_ge ._fb ;if _ge ._g !=0{_ab ++;
};return _ab ;};func (_gde *SubstreamReader )ReadBit ()(_bced int ,_fccg error ){_dgdd ,_fccg :=_gde .readBool ();if _fccg !=nil {return 0,_fccg ;};if _dgdd {_bced =1;};return _bced ,nil ;};func (_ggg *BufferedWriter )writeShiftedBytes (_cgg []byte )int {for _ ,_gc :=range _cgg {_ggg .writeByte (_gc );
};return len (_cgg );};func (_eba *Writer )Write (p []byte )(int ,error ){if len (p )> _eba .byteCapacity (){return 0,_e .EOF ;};for _ ,_fgf :=range p {if _gga :=_eba .writeByte (_fgf );_gga !=nil {return 0,_gga ;};};return len (p ),nil ;};func (_dcde *Writer )WriteBits (bits uint64 ,number int )(_eee int ,_gfg error ){const _faedb ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";
if number < 0||number > 64{return 0,_d .Errorf (_faedb ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};if number ==0{return 0,nil ;};_bad :=number /8;if _bad > 0{_gcca :=number -_bad *8;for _aac :=_bad -1;_aac >=0;_aac --{_gcf :=byte ((bits >>uint (_aac *8+_gcca ))&0xff);if _gfg =_dcde .WriteByte (_gcf );_gfg !=nil {return _eee ,_d .Wrapf (_gfg ,_faedb ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_bad -_aac +1);
};};number -=_bad *8;if number ==0{return _bad ,nil ;};};var _ffe int ;for _dae :=0;_dae < number ;_dae ++{if _dcde ._bfcd {_ffe =int ((bits >>uint (number -1-_dae ))&0x1);}else {_ffe =int (bits &0x1);bits >>=1;};if _gfg =_dcde .WriteBit (_ffe );_gfg !=nil {return _eee ,_d .Wrapf (_gfg ,_faedb ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_dae );
};};return _bad ,nil ;};func (_aebf *SubstreamReader )ReadBool ()(bool ,error ){return _aebf .readBool ()};func (_ddd *SubstreamReader )fillBuffer ()error {if uint64 (_ddd ._gcc .StreamPosition ())!=_ddd ._ege +_ddd ._dgb {_ ,_dfa :=_ddd ._gcc .Seek (int64 (_ddd ._ege +_ddd ._dgb ),_e .SeekStart );
if _dfa !=nil {return _dfa ;};};_ddd ._ee =_ddd ._ege ;_ccc :=_bfb (uint64 (len (_ddd ._aed )),_ddd ._ebc -_ddd ._ege );_egf :=make ([]byte ,_ccc );_ecfb ,_ggf :=_ddd ._gcc .Read (_egf );if _ggf !=nil {return _ggf ;};for _aeg :=uint64 (0);_aeg < _ccc ;
_aeg ++{_ddd ._aed [_aeg ]=_egf [_aeg ];};_ddd ._eaf =_ddd ._ee +uint64 (_ecfb );return nil ;};func (_dcd *BufferedWriter )expandIfNeeded (_aaf int ){if !_dcd .tryGrowByReslice (_aaf ){_dcd .grow (_aaf );};};type StreamReader interface{_e .Reader ;_e .ByteReader ;
_e .Seeker ;Align ()byte ;BitPosition ()int ;Mark ();Length ()uint64 ;ReadBit ()(int ,error );ReadBits (_bd byte )(uint64 ,error );ReadBool ()(bool ,error );ReadUint32 ()(uint32 ,error );Reset ();StreamPosition ()int64 ;};func (_afe *SubstreamReader )BitPosition ()int {return int (_afe ._bcg )};
