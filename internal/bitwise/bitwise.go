//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_fb "encoding/binary";_ee "errors";_d "fmt";_fg "github.com/unidoc/unipdf/v3/common";_ff "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_e "io";);func (_fad *BufferedWriter )tryGrowByReslice (_fde int )bool {if _bdbc :=len (_fad ._gg );
_fde <=cap (_fad ._gg )-_bdbc {_fad ._gg =_fad ._gg [:_bdbc +_fde ];return true ;};return false ;};type Writer struct{_cfbfd []byte ;_dcfe uint8 ;_aad int ;_dac bool ;};var _ _e .ByteWriter =&BufferedWriter {};func (_fdf *Writer )Write (p []byte )(int ,error ){if len (p )> _fdf .byteCapacity (){return 0,_e .EOF ;
};for _ ,_adc :=range p {if _bcd :=_fdf .writeByte (_adc );_bcd !=nil {return 0,_bcd ;};};return len (p ),nil ;};func (_cfbf *Reader )BitPosition ()int {return int (_cfbf ._fbc )};func (_cffd *BufferedWriter )writeShiftedBytes (_dcg []byte )int {for _ ,_dgb :=range _dcg {_cffd .writeByte (_dgb );
};return len (_dcg );};type BitWriter interface{WriteBit (_cfd int )error ;WriteBits (_aa uint64 ,_be int )(_fgd int ,_gae error );FinishByte ();SkipBits (_bgc int )error ;};func (_fbg *Reader )ReadBits (n byte )(_ggee uint64 ,_eab error ){if n < _fbg ._fbc {_ecd :=_fbg ._fbc -n ;
_ggee =uint64 (_fbg ._fadb >>_ecd );_fbg ._fadb &=1<<_ecd -1;_fbg ._fbc =_ecd ;return _ggee ,nil ;};if n > _fbg ._fbc {if _fbg ._fbc > 0{_ggee =uint64 (_fbg ._fadb );n -=_fbg ._fbc ;};for n >=8{_ce ,_afd :=_fbg .readBufferByte ();if _afd !=nil {return 0,_afd ;
};_ggee =_ggee <<8+uint64 (_ce );n -=8;};if n > 0{if _fbg ._fadb ,_eab =_fbg .readBufferByte ();_eab !=nil {return 0,_eab ;};_cfc :=8-n ;_ggee =_ggee <<n +uint64 (_fbg ._fadb >>_cfc );_fbg ._fadb &=1<<_cfc -1;_fbg ._fbc =_cfc ;}else {_fbg ._fbc =0;};return _ggee ,nil ;
};_fbg ._fbc =0;return uint64 (_fbg ._fadb ),nil ;};func (_ag *BufferedWriter )Len ()int {return _ag .byteCapacity ()};func (_ega *Reader )readUnalignedByte ()(_gec byte ,_gcb error ){_fdcg :=_ega ._fbc ;_gec =_ega ._fadb <<(8-_fdcg );_ega ._fadb ,_gcb =_ega .readBufferByte ();
if _gcb !=nil {return 0,_gcb ;};_gec |=_ega ._fadb >>_fdcg ;_ega ._fadb &=1<<_fdcg -1;return _gec ,nil ;};var _ _e .Writer =&BufferedWriter {};func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_ga :true }};func (_cb *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _ff .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );
};if len (_cb ._gg )-1< _cb ._db {_cb .expandIfNeeded (1);};_fa :=_cb ._a ;if _cb ._ga {_fa =7-_cb ._a ;};_cb ._gg [_cb ._db ]|=byte (uint16 (bit <<_fa )&0xff);_cb ._a ++;if _cb ._a ==8{_cb ._db ++;_cb ._a =0;};return nil ;};func NewWriter (data []byte )*Writer {return &Writer {_cfbfd :data }};
func (_ac *BufferedWriter )writeFullBytes (_af []byte )int {_ef :=copy (_ac ._gg [_ac .fullOffset ():],_af );_ac ._db +=_ef ;return _ef ;};type StreamReader interface{_e .Reader ;_e .ByteReader ;_e .Seeker ;Align ()byte ;BitPosition ()int ;Mark ();Length ()uint64 ;
ReadBit ()(int ,error );ReadBits (_cdb byte )(uint64 ,error );ReadBool ()(bool ,error );ReadUint32 ()(uint32 ,error );Reset ();AbsolutePosition ()int64 ;};func (_gb *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;};_fbe :=int (_gb ._a )+skip ;
if _fbe >=0&&_fbe < 8{_gb ._a =uint8 (_fbe );return nil ;};_fbe =int (_gb ._a )+_gb ._db *8+skip ;if _fbe < 0{return _ff .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_gc :=_fbe /8;_cf :=_fbe %8;_gb ._a =uint8 (_cf );if _cc :=_gc -_gb ._db ;_cc > 0&&len (_gb ._gg )-1< _gc {if _gb ._a !=0{_cc ++;};_gb .expandIfNeeded (_cc );};_gb ._db =_gc ;return nil ;};func (_ec *BufferedWriter )WriteBits (bits uint64 ,number int )(_ba int ,_de error ){const _gd ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";
if number < 0||number > 64{return 0,_ff .Errorf (_gd ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};_ea :=number /8;if _ea > 0{_bc :=number -_ea *8;for _ed :=_ea -1;_ed >=0;_ed --{_dd :=byte ((bits >>uint (_ed *8+_bc ))&0xff);if _de =_ec .WriteByte (_dd );_de !=nil {return _ba ,_ff .Wrapf (_de ,_gd ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_ea -_ed +1);
};};number -=_ea *8;if number ==0{return _ea ,nil ;};};var _ffc int ;for _ffe :=0;_ffe < number ;_ffe ++{if _ec ._ga {_ffc =int ((bits >>uint (number -1-_ffe ))&0x1);}else {_ffc =int (bits &0x1);bits >>=1;};if _de =_ec .WriteBit (_ffc );_de !=nil {return _ba ,_ff .Wrapf (_de ,_gd ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_ffe );
};};return _ea ,nil ;};const (_b =64;_dc =int (^uint (0)>>1););func (_cfe *Reader )AbsolutePosition ()int64 {return _cfe ._bff +int64 (_cfe ._bdc ._def )};func (_bfg *BufferedWriter )writeByte (_cff byte ){switch {case _bfg ._a ==0:_bfg ._gg [_bfg ._db ]=_cff ;
_bfg ._db ++;case _bfg ._ga :_bfg ._gg [_bfg ._db ]|=_cff >>_bfg ._a ;_bfg ._db ++;_bfg ._gg [_bfg ._db ]=byte (uint16 (_cff )<<(8-_bfg ._a )&0xff);default:_bfg ._gg [_bfg ._db ]|=byte (uint16 (_cff )<<_bfg ._a &0xff);_bfg ._db ++;_bfg ._gg [_bfg ._db ]=_cff >>(8-_bfg ._a );
};};func (_bg *BufferedWriter )FinishByte (){if _bg ._a ==0{return ;};_bg ._a =0;_bg ._db ++;};func (_fe *Reader )Reset (){_fe ._bff =_fe ._eff ;_fe ._fbc =_fe ._cfb ;_fe ._fadb =_fe ._gbc ;_fe ._gaa =_fe ._dbd ;};func (_gdd *Reader )ReadUint32 ()(uint32 ,error ){_cfda :=make ([]byte ,4);
_ ,_fbeg :=_gdd .Read (_cfda );if _fbeg !=nil {return 0,_fbeg ;};return _fb .BigEndian .Uint32 (_cfda ),nil ;};func (_afdb *Writer )Data ()[]byte {return _afdb ._cfbfd };func (_aga *Reader )Align ()(_cg byte ){_cg =_aga ._fbc ;_aga ._fbc =0;return _cg };
var (_ _e .Reader =&Reader {};_ _e .ByteReader =&Reader {};_ _e .Seeker =&Reader {};_ StreamReader =&Reader {};);func NewWriterMSB (data []byte )*Writer {return &Writer {_cfbfd :data ,_dac :true }};func (_ca *Reader )readBool ()(_cec bool ,_fbee error ){if _ca ._fbc ==0{_ca ._fadb ,_fbee =_ca .readBufferByte ();
if _fbee !=nil {return false ,_fbee ;};_cec =(_ca ._fadb &0x80)!=0;_ca ._fadb ,_ca ._fbc =_ca ._fadb &0x7f,7;return _cec ,nil ;};_ca ._fbc --;_cec =(_ca ._fadb &(1<<_ca ._fbc ))!=0;_ca ._fadb &=1<<_ca ._fbc -1;return _cec ,nil ;};func (_gbe *BufferedWriter )byteCapacity ()int {_fcc :=len (_gbe ._gg )-_gbe ._db ;
if _gbe ._a !=0{_fcc --;};return _fcc ;};func (_bdb *BufferedWriter )WriteByte (bt byte )error {if _bdb ._db > len (_bdb ._gg )-1||(_bdb ._db ==len (_bdb ._gg )-1&&_bdb ._a !=0){_bdb .expandIfNeeded (1);};_bdb .writeByte (bt );return nil ;};func (_ggd *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_ggd ._cdbc =-1;
_ggd ._fbc =0;_ggd ._fadb =0;_ggd ._gaa =0;var _fccd int64 ;switch whence {case _e .SeekStart :_fccd =offset ;case _e .SeekCurrent :_fccd =_ggd ._bff +offset ;case _e .SeekEnd :_fccd =int64 (_ggd ._bdc ._cbc )+offset ;default:return 0,_ee .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};if _fccd < 0{return 0,_ee .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");};_ggd ._bff =_fccd ;
_ggd ._fbc =0;return _fccd ,nil ;};func (_bf *BufferedWriter )grow (_eec int ){if _bf ._gg ==nil &&_eec < _b {_bf ._gg =make ([]byte ,_eec ,_b );return ;};_fd :=len (_bf ._gg );if _bf ._a !=0{_fd ++;};_cfg :=cap (_bf ._gg );switch {case _eec <=_cfg /2-_fd :_fg .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_bf ._gg ),cap (_bf ._gg ),_eec );
_fg .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_cfg ,_fd );copy (_bf ._gg ,_bf ._gg [_bf .fullOffset ():]);
case _cfg > _dc -_cfg -_eec :_fg .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_gf :=make ([]byte ,2*_cfg +_eec );copy (_gf ,_bf ._gg );_bf ._gg =_gf ;};_bf ._gg =_bf ._gg [:_fd +_eec ];
};type BinaryWriter interface{BitWriter ;_e .Writer ;_e .ByteWriter ;Data ()[]byte ;};func (_fcd *Writer )ResetBit (){_fcd ._dcfe =0};func (_cd *BufferedWriter )expandIfNeeded (_dbf int ){if !_cd .tryGrowByReslice (_dbf ){_cd .grow (_dbf );};};func (_aab *Reader )ReadByte ()(byte ,error ){if _aab ._fbc ==0{return _aab .readBufferByte ();
};return _aab .readUnalignedByte ();};func (_afe *Reader )Read (p []byte )(_ad int ,_cbg error ){if _afe ._fbc ==0{return _afe .read (p );};for ;_ad < len (p );_ad ++{if p [_ad ],_cbg =_afe .readUnalignedByte ();_cbg !=nil {return 0,_cbg ;};};return _ad ,nil ;
};func (_fgc *Reader )ReadBool ()(bool ,error ){return _fgc .readBool ()};type Reader struct{_bdc readerSource ;_fadb byte ;_fbc byte ;_bff int64 ;_gaa int ;_cdbc int ;_eff int64 ;_cfb byte ;_gbc byte ;_dbd int ;};func (_agd *Reader )RelativePosition ()int64 {return _agd ._bff };
func (_bdd *Reader )readBufferByte ()(byte ,error ){if _bdd ._bff >=int64 (_bdd ._bdc ._cbc ){return 0,_e .EOF ;};_bdd ._cdbc =-1;_gcg :=_bdd ._bdc ._ccc [int64 (_bdd ._bdc ._def )+_bdd ._bff ];_bdd ._bff ++;_bdd ._gaa =int (_gcg );return _gcg ,nil ;};
func (_aaf *Writer )SkipBits (skip int )error {const _aacd ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";if skip ==0{return nil ;};_fbf :=int (_aaf ._dcfe )+skip ;if _fbf >=0&&_fbf < 8{_aaf ._dcfe =uint8 (_fbf );return nil ;
};_fbf =int (_aaf ._dcfe )+_aaf ._aad *8+skip ;if _fbf < 0{return _ff .Errorf (_aacd ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_bbd :=_fbf /8;_gbea :=_fbf %8;_fg .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");
_fg .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_aaf ._dcfe ,_aaf ._aad ,int (_aaf ._dcfe )+(_aaf ._aad )*8,len (_aaf ._cfbfd ),cap (_aaf ._cfbfd ));
_fg .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_fbf ,_gbea );_aaf ._dcfe =uint8 (_gbea );
if _fdbb :=_bbd -_aaf ._aad ;_fdbb > 0&&len (_aaf ._cfbfd )-1< _bbd {_fg .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_fdbb );return _ff .Errorf (_aacd ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_aaf ._aad =_bbd ;_fg .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_aaf ._dcfe ,_aaf ._aad );return nil ;};type readerSource struct{_ccc []byte ;
_def int ;_cbc int ;};func (_dg *BufferedWriter )ResetBitIndex (){_dg ._a =0};var _ BinaryWriter =&BufferedWriter {};var _ BinaryWriter =&Writer {};func (_gdf *Writer )FinishByte (){if _gdf ._dcfe ==0{return ;};_gdf ._dcfe =0;_gdf ._aad ++;};func NewReader (data []byte )*Reader {return &Reader {_bdc :readerSource {_ccc :data ,_cbc :len (data ),_def :0}};
};func (_dad *Writer )WriteByte (c byte )error {return _dad .writeByte (c )};func (_c *BufferedWriter )Data ()[]byte {return _c ._gg };func (_abe *Writer )UseMSB ()bool {return _abe ._dac };type BufferedWriter struct{_gg []byte ;_a uint8 ;_db int ;_ga bool ;
};func (_bce *Writer )byteCapacity ()int {_bge :=len (_bce ._cfbfd )-_bce ._aad ;if _bce ._dcfe !=0{_bge --;};return _bge ;};func (_dcf *Reader )Length ()uint64 {return uint64 (_dcf ._bdc ._cbc )};func (_ecg *Writer )writeByte (_afa byte )error {if _ecg ._aad > len (_ecg ._cfbfd )-1{return _e .EOF ;
};if _ecg ._aad ==len (_ecg ._cfbfd )-1&&_ecg ._dcfe !=0{return _e .EOF ;};if _ecg ._dcfe ==0{_ecg ._cfbfd [_ecg ._aad ]=_afa ;_ecg ._aad ++;return nil ;};if _ecg ._dac {_ecg ._cfbfd [_ecg ._aad ]|=_afa >>_ecg ._dcfe ;_ecg ._aad ++;_ecg ._cfbfd [_ecg ._aad ]=byte (uint16 (_afa )<<(8-_ecg ._dcfe )&0xff);
}else {_ecg ._cfbfd [_ecg ._aad ]|=byte (uint16 (_afa )<<_ecg ._dcfe &0xff);_ecg ._aad ++;_ecg ._cfbfd [_ecg ._aad ]=_afa >>(8-_ecg ._dcfe );};return nil ;};func (_acg *Reader )Mark (){_acg ._eff =_acg ._bff ;_acg ._cfb =_acg ._fbc ;_acg ._gbc =_acg ._fadb ;
_acg ._dbd =_acg ._gaa ;};func (_gge *BufferedWriter )Write (d []byte )(int ,error ){_gge .expandIfNeeded (len (d ));if _gge ._a ==0{return _gge .writeFullBytes (d ),nil ;};return _gge .writeShiftedBytes (d ),nil ;};func (_dec *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _dec .writeBit (uint8 (bit ));
};return _ff .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");};func (_bd *BufferedWriter )Reset (){_bd ._gg =_bd ._gg [:0];_bd ._db =0;_bd ._a =0};
func (_bbdc *Writer )writeBit (_ebc uint8 )error {if len (_bbdc ._cfbfd )-1< _bbdc ._aad {return _e .EOF ;};_bcdd :=_bbdc ._dcfe ;if _bbdc ._dac {_bcdd =7-_bbdc ._dcfe ;};_bbdc ._cfbfd [_bbdc ._aad ]|=byte (uint16 (_ebc <<_bcdd )&0xff);_bbdc ._dcfe ++;
if _bbdc ._dcfe ==8{_bbdc ._aad ++;_bbdc ._dcfe =0;};return nil ;};func (_aac *Reader )read (_bca []byte )(int ,error ){if _aac ._bff >=int64 (_aac ._bdc ._cbc ){return 0,_e .EOF ;};_aac ._cdbc =-1;_adf :=copy (_bca ,_aac ._bdc ._ccc [(int64 (_aac ._bdc ._def )+_aac ._bff ):(_aac ._bdc ._def +_aac ._bdc ._cbc )]);
_aac ._bff +=int64 (_adf );return _adf ,nil ;};func (_agg *Reader )NewPartialReader (offset ,length int ,relative bool )(*Reader ,error ){if offset < 0{return nil ,_ee .New ("p\u0061\u0072\u0074\u0069\u0061\u006c\u0020\u0072\u0065\u0061\u0064\u0065\u0072\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062e \u006e\u0065\u0067a\u0074i\u0076\u0065");
};if relative {offset =_agg ._bdc ._def +offset ;};if length > 0{_fbea :=len (_agg ._bdc ._ccc );if relative {_fbea =_agg ._bdc ._cbc ;};if offset +length > _fbea {return nil ,_d .Errorf ("\u0070\u0061r\u0074\u0069\u0061l\u0020\u0072\u0065\u0061\u0064e\u0072\u0020\u006f\u0066\u0066se\u0074\u0028\u0025\u0064\u0029\u002b\u006c\u0065\u006e\u0067\u0074\u0068\u0028\u0025\u0064\u0029\u003d\u0025d\u0020i\u0073\u0020\u0067\u0072\u0065\u0061ter\u0020\u0074\u0068\u0061\u006e\u0020\u0074\u0068\u0065\u0020\u006f\u0072ig\u0069n\u0061\u006c\u0020\u0072e\u0061d\u0065r\u0020\u006ce\u006e\u0067th\u003a\u0020\u0025\u0064",offset ,length ,offset +length ,_agg ._bdc ._cbc );
};};if length < 0{_bfc :=len (_agg ._bdc ._ccc );if relative {_bfc =_agg ._bdc ._cbc ;};length =_bfc -offset ;};return &Reader {_bdc :readerSource {_ccc :_agg ._bdc ._ccc ,_cbc :length ,_def :offset }},nil ;};func (_fgb *Writer )WriteBits (bits uint64 ,number int )(_df int ,_ceb error ){const _gca ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";
if number < 0||number > 64{return 0,_ff .Errorf (_gca ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};if number ==0{return 0,nil ;};_egd :=number /8;if _egd > 0{_beg :=number -_egd *8;for _cdg :=_egd -1;_cdg >=0;_cdg --{_bbb :=byte ((bits >>uint (_cdg *8+_beg ))&0xff);if _ceb =_fgb .WriteByte (_bbb );_ceb !=nil {return _df ,_ff .Wrapf (_ceb ,_gca ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_egd -_cdg +1);
};};number -=_egd *8;if number ==0{return _egd ,nil ;};};var _bddc int ;for _dfb :=0;_dfb < number ;_dfb ++{if _fgb ._dac {_bddc =int ((bits >>uint (number -1-_dfb ))&0x1);}else {_bddc =int (bits &0x1);bits >>=1;};if _ceb =_fgb .WriteBit (_bddc );_ceb !=nil {return _df ,_ff .Wrapf (_ceb ,_gca ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_dfb );
};};return _egd ,nil ;};func (_dcd *BufferedWriter )fullOffset ()int {_ab :=_dcd ._db ;if _dcd ._a !=0{_ab ++;};return _ab ;};func (_eg *Reader )AbsoluteLength ()uint64 {return uint64 (len (_eg ._bdc ._ccc ))};func (_gfc *Reader )ConsumeRemainingBits ()(uint64 ,error ){if _gfc ._fbc !=0{return _gfc .ReadBits (_gfc ._fbc );
};return 0,nil ;};func (_fdc *Reader )ReadBit ()(_ge int ,_edf error ){_fdb ,_edf :=_fdc .readBool ();if _edf !=nil {return 0,_edf ;};if _fdb {_ge =1;};return _ge ,nil ;};