//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_fb "encoding/binary";_e "errors";_ef "github.com/unidoc/unipdf/v3/common";_a "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_f "io";);func (_dfa *BufferedWriter )Write (d []byte )(int ,error ){_dfa .expandIfNeeded (len (d ));if _dfa ._fg ==0{return _dfa .writeFullBytes (d ),nil ;};return _dfa .writeShiftedBytes (d ),nil ;};type StreamReader interface{_f .Reader ;_f .ByteReader ;_f .Seeker ;Align ()byte ;BitPosition ()int ;Mark ();Length ()uint64 ;ReadBit ()(int ,error );ReadBits (_geb byte )(uint64 ,error );ReadBool ()(bool ,error );ReadUint32 ()(uint32 ,error );Reset ();StreamPosition ()int64 ;};func (_ag *BufferedWriter )WriteBits (bits uint64 ,number int )(_eb int ,_cc error ){const _dab ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";if number < 0||number > 64{return 0,_a .Errorf (_dab ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );};_dcf :=number /8;if _dcf > 0{_efe :=number -_dcf *8;for _af :=_dcf -1;_af >=0;_af --{_ed :=byte ((bits >>uint (_af *8+_efe ))&0xff);if _cc =_ag .WriteByte (_ed );_cc !=nil {return _eb ,_a .Wrapf (_cc ,_dab ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_dcf -_af +1);};};number -=_dcf *8;if number ==0{return _dcf ,nil ;};};var _abg int ;for _ac :=0;_ac < number ;_ac ++{if _ag ._ba {_abg =int ((bits >>uint (number -1-_ac ))&0x1);}else {_abg =int (bits &0x1);bits >>=1;};if _cc =_ag .WriteBit (_abg );_cc !=nil {return _eb ,_a .Wrapf (_cc ,_dab ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_ac );};};return _dcf ,nil ;};func (_eba *BufferedWriter )grow (_daf int ){if _eba ._df ==nil &&_daf < _d {_eba ._df =make ([]byte ,_daf ,_d );return ;};_cgg :=len (_eba ._df );if _eba ._fg !=0{_cgg ++;};_bf :=cap (_eba ._df );switch {case _daf <=_bf /2-_cgg :_ef .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_eba ._df ),cap (_eba ._df ),_daf );_ef .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_bf ,_cgg );copy (_eba ._df ,_eba ._df [_eba .fullOffset ():]);case _bf > _bg -_bf -_daf :_ef .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_gac :=make ([]byte ,2*_bf +_daf );copy (_gac ,_eba ._df );_eba ._df =_gac ;};_eba ._df =_eba ._df [:_cgg +_daf ];};func (_cfe *SubstreamReader )readBufferByte ()(byte ,error ){if _cfe ._fabg >=_cfe ._fdad {return 0,_f .EOF ;};if _cfe ._fabg >=_cfe ._dcff ||_cfe ._fabg < _cfe ._egb {if _gge :=_cfe .fillBuffer ();_gge !=nil {return 0,_gge ;};};_cbcc :=_cfe ._cec [_cfe ._fabg -_cfe ._egb ];_cfe ._fabg ++;return _cbcc ,nil ;};func NewWriter (data []byte )*Writer {return &Writer {_cce :data }};const (_d =64;_bg =int (^uint (0)>>1););func (_fc *BufferedWriter )fullOffset ()int {_ga :=_fc ._da ;if _fc ._fg !=0{_ga ++;};return _ga ;};func (_ebg *Reader )Mark (){_ebg ._aa =_ebg ._bgbe ;_ebg ._bc =_ebg ._dbf };func (_acda *SubstreamReader )readUnalignedByte ()(_gec byte ,_bb error ){_fgc :=_acda ._gb ;_gec =_acda ._fdef <<(8-_fgc );_acda ._fdef ,_bb =_acda .readBufferByte ();if _bb !=nil {return 0,_bb ;};_gec |=_acda ._fdef >>_fgc ;_acda ._fdef &=1<<_fgc -1;return _gec ,nil ;};var _ BinaryWriter =&BufferedWriter {};type BufferedWriter struct{_df []byte ;_fg uint8 ;_da int ;_ba bool ;};func (_dea *SubstreamReader )Mark (){_dea ._dff =_dea ._fabg ;_dea ._ee =_dea ._gb };type Writer struct{_cce []byte ;_gdb uint8 ;_add int ;_facd bool ;};func (_cbf *Writer )WriteByte (c byte )error {return _cbf .writeByte (c )};func NewWriterMSB (data []byte )*Writer {return &Writer {_cce :data ,_facd :true }};func (_acd *SubstreamReader )Align ()(_cae byte ){_cae =_acd ._gb ;_acd ._gb =0;return _cae };func (_afc *Writer )Write (p []byte )(int ,error ){if len (p )> _afc .byteCapacity (){return 0,_f .EOF ;};for _ ,_dde :=range p {if _agd :=_afc .writeByte (_dde );_agd !=nil {return 0,_agd ;};};return len (p ),nil ;};var _ BinaryWriter =&Writer {};func (_bbf *Writer )byteCapacity ()int {_fcaf :=len (_bbf ._cce )-_bbf ._add ;if _bbf ._gdb !=0{_fcaf --;};return _fcaf ;};type BinaryWriter interface{BitWriter ;_f .Writer ;_f .ByteWriter ;Data ()[]byte ;};func (_gd *BufferedWriter )FinishByte (){if _gd ._fg ==0{return ;};_gd ._fg =0;_gd ._da ++;};func NewSubstreamReader (r StreamReader ,offset ,length uint64 )(*SubstreamReader ,error ){if r ==nil {return nil ,_e .New ("\u0072o\u006ft\u0020\u0072\u0065\u0061\u0064e\u0072\u0020i\u0073\u0020\u006e\u0069\u006c");};_ef .Log .Trace ("\u004e\u0065\u0077\u0053\u0075\u0062\u0073\u0074r\u0065\u0061\u006dRe\u0061\u0064\u0065\u0072\u0020\u0061t\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u003a\u0020\u0025\u0064\u0020\u0077\u0069\u0074h\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a \u0025\u0064",offset ,length );return &SubstreamReader {_egd :r ,_ggae :offset ,_fdad :length ,_cec :make ([]byte ,length )},nil ;};func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_ba :true }};func (_fgg *Reader )ReadBits (n byte )(_ae uint64 ,_de error ){if n < _fgg ._dbf {_fgf :=_fgg ._dbf -n ;_ae =uint64 (_fgg ._bfd >>_fgf );_fgg ._bfd &=1<<_fgf -1;_fgg ._dbf =_fgf ;return _ae ,nil ;};if n > _fgg ._dbf {if _fgg ._dbf > 0{_ae =uint64 (_fgg ._bfd );n -=_fgg ._dbf ;};for n >=8{_dac ,_cca :=_fgg .readBufferByte ();if _cca !=nil {return 0,_cca ;};_ae =_ae <<8+uint64 (_dac );n -=8;};if n > 0{if _fgg ._bfd ,_de =_fgg .readBufferByte ();_de !=nil {return 0,_de ;};_efg :=8-n ;_ae =_ae <<n +uint64 (_fgg ._bfd >>_efg );_fgg ._bfd &=1<<_efg -1;_fgg ._dbf =_efg ;}else {_fgg ._dbf =0;};return _ae ,nil ;};_fgg ._dbf =0;return uint64 (_fgg ._bfd ),nil ;};func (_abb *Reader )readBool ()(_gfb bool ,_dbd error ){if _abb ._dbf ==0{_abb ._bfd ,_dbd =_abb .readBufferByte ();if _dbd !=nil {return false ,_dbd ;};_gfb =(_abb ._bfd &0x80)!=0;_abb ._bfd ,_abb ._dbf =_abb ._bfd &0x7f,7;return _gfb ,nil ;};_abb ._dbf --;_gfb =(_abb ._bfd &(1<<_abb ._dbf ))!=0;_abb ._bfd &=1<<_abb ._dbf -1;return _gfb ,nil ;};func (_cd *BufferedWriter )byteCapacity ()int {_cg :=len (_cd ._df )-_cd ._da ;if _cd ._fg !=0{_cg --;};return _cg ;};func (_dbc *BufferedWriter )writeShiftedBytes (_bdg []byte )int {for _ ,_gc :=range _bdg {_dbc .writeByte (_gc );};return len (_bdg );};func NewReader (data []byte )*Reader {return &Reader {_gg :data }};func (_bcb *SubstreamReader )BitPosition ()int {return int (_bcb ._gb )};func (_cgbd *Writer )FinishByte (){if _cgbd ._gdb ==0{return ;};_cgbd ._gdb =0;_cgbd ._add ++;};func (_dabb *SubstreamReader )Reset (){_dabb ._fabg =_dabb ._dff ;_dabb ._gb =_dabb ._ee };func (_bfa *Reader )ReadByte ()(byte ,error ){if _bfa ._dbf ==0{return _bfa .readBufferByte ();};return _bfa .readUnalignedByte ();};func (_ddgd *Writer )UseMSB ()bool {return _ddgd ._facd };func (_dge *SubstreamReader )ReadUint32 ()(uint32 ,error ){_bafc :=make ([]byte ,4);_ ,_ega :=_dge .Read (_bafc );if _ega !=nil {return 0,_ega ;};return _fb .BigEndian .Uint32 (_bafc ),nil ;};func (_ec *BufferedWriter )ResetBitIndex (){_ec ._fg =0};func (_beg *SubstreamReader )StreamPosition ()int64 {return int64 (_beg ._fabg )};func (_cb *BufferedWriter )expandIfNeeded (_dcg int ){if !_cb .tryGrowByReslice (_dcg ){_cb .grow (_dcg );};};func (_eg *Reader )StreamPosition ()int64 {return _eg ._bgbe };func (_edg *Writer )SkipBits (skip int )error {const _cdd ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";if skip ==0{return nil ;};_afge :=int (_edg ._gdb )+skip ;if _afge >=0&&_afge < 8{_edg ._gdb =uint8 (_afge );return nil ;};_afge =int (_edg ._gdb )+_edg ._add *8+skip ;if _afge < 0{return _a .Errorf (_cdd ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_dbg :=_afge /8;_edfb :=_afge %8;_ef .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");_ef .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_edg ._gdb ,_edg ._add ,int (_edg ._gdb )+(_edg ._add )*8,len (_edg ._cce ),cap (_edg ._cce ));_ef .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_afge ,_edfb );_edg ._gdb =uint8 (_edfb );if _egc :=_dbg -_edg ._add ;_egc > 0&&len (_edg ._cce )-1< _dbg {_ef .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_egc );return _a .Errorf (_cdd ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_edg ._add =_dbg ;_ef .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_edg ._gdb ,_edg ._add );return nil ;};type Reader struct{_gg []byte ;_bfd byte ;_dbf byte ;_bgbe int64 ;_fcf int ;_cde int ;_aa int64 ;_bc byte ;};func (_afa *SubstreamReader )Offset ()uint64 {return _afa ._ggae };type BitWriter interface{WriteBit (_fca int )error ;WriteBits (_bfge uint64 ,_fgd int )(_aba int ,_cf error );FinishByte ();SkipBits (_dd int )error ;};func (_cdeb *Writer )WriteBits (bits uint64 ,number int )(_cff int ,_bea error ){const _dgg ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";if number < 0||number > 64{return 0,_a .Errorf (_dgg ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );};if number ==0{return 0,nil ;};_gfd :=number /8;if _gfd > 0{_cdec :=number -_gfd *8;for _bfged :=_gfd -1;_bfged >=0;_bfged --{_dafg :=byte ((bits >>uint (_bfged *8+_cdec ))&0xff);if _bea =_cdeb .WriteByte (_dafg );_bea !=nil {return _cff ,_a .Wrapf (_bea ,_dgg ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_gfd -_bfged +1);};};number -=_gfd *8;if number ==0{return _gfd ,nil ;};};var _adde int ;for _gce :=0;_gce < number ;_gce ++{if _cdeb ._facd {_adde =int ((bits >>uint (number -1-_gce ))&0x1);}else {_adde =int (bits &0x1);bits >>=1;};if _bea =_cdeb .WriteBit (_adde );_bea !=nil {return _cff ,_a .Wrapf (_bea ,_dgg ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_gce );};};return _gfd ,nil ;};func (_dee *Reader )read (_bfb []byte )(int ,error ){if _dee ._bgbe >=int64 (len (_dee ._gg )){return 0,_f .EOF ;};_dee ._cde =-1;_dcgd :=copy (_bfb ,_dee ._gg [_dee ._bgbe :]);_dee ._bgbe +=int64 (_dcgd );return _dcgd ,nil ;};func (_cggd *Reader )BitPosition ()int {return int (_cggd ._dbf )};func (_ge *BufferedWriter )writeFullBytes (_fcg []byte )int {_ebag :=copy (_ge ._df [_ge .fullOffset ():],_fcg );_ge ._da +=_ebag ;return _ebag ;};func (_g *BufferedWriter )Data ()[]byte {return _g ._df };func (_fgb *BufferedWriter )writeByte (_fab byte ){switch {case _fgb ._fg ==0:_fgb ._df [_fgb ._da ]=_fab ;_fgb ._da ++;case _fgb ._ba :_fgb ._df [_fgb ._da ]|=_fab >>_fgb ._fg ;_fgb ._da ++;_fgb ._df [_fgb ._da ]=byte (uint16 (_fab )<<(8-_fgb ._fg )&0xff);default:_fgb ._df [_fgb ._da ]|=byte (uint16 (_fab )<<_fgb ._fg &0xff);_fgb ._da ++;_fgb ._df [_fgb ._da ]=_fab >>(8-_fgb ._fg );};};func (_dfd *Reader )ConsumeRemainingBits (){if _dfd ._dbf !=0{_ ,_ca :=_dfd .ReadBits (_dfd ._dbf );if _ca !=nil {_ef .Log .Debug ("\u0043\u006f\u006e\u0073\u0075\u006d\u0065\u0052\u0065\u006da\u0069\u006e\u0069\u0067\u0042\u0069\u0074s\u0020\u0066\u0061\u0069\u006c\u0065\u0064\u003a\u0020\u0025\u0076",_ca );};};};func (_dcc *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_dcc ._cde =-1;var _fde int64 ;switch whence {case _f .SeekStart :_fde =offset ;case _f .SeekCurrent :_fde =_dcc ._bgbe +offset ;case _f .SeekEnd :_fde =int64 (len (_dcc ._gg ))+offset ;default:return 0,_e .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");};if _fde < 0{return 0,_e .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");};_dcc ._bgbe =_fde ;_dcc ._dbf =0;return _fde ,nil ;};func (_abbe *SubstreamReader )Length ()uint64 {return _abbe ._fdad };func (_edbc *Writer )writeByte (_effa byte )error {if _edbc ._add > len (_edbc ._cce )-1{return _f .EOF ;};if _edbc ._add ==len (_edbc ._cce )-1&&_edbc ._gdb !=0{return _f .EOF ;};if _edbc ._gdb ==0{_edbc ._cce [_edbc ._add ]=_effa ;_edbc ._add ++;return nil ;};if _edbc ._facd {_edbc ._cce [_edbc ._add ]|=_effa >>_edbc ._gdb ;_edbc ._add ++;_edbc ._cce [_edbc ._add ]=byte (uint16 (_effa )<<(8-_edbc ._gdb )&0xff);}else {_edbc ._cce [_edbc ._add ]|=byte (uint16 (_effa )<<_edbc ._gdb &0xff);_edbc ._add ++;_edbc ._cce [_edbc ._add ]=_effa >>(8-_edbc ._gdb );};return nil ;};func (_ddg *Reader )ReadUint32 ()(uint32 ,error ){_gae :=make ([]byte ,4);_ ,_fe :=_ddg .Read (_gae );if _fe !=nil {return 0,_fe ;};return _fb .BigEndian .Uint32 (_gae ),nil ;};func (_fea *SubstreamReader )readBool ()(_abbc bool ,_eed error ){if _fea ._gb ==0{_fea ._fdef ,_eed =_fea .readBufferByte ();if _eed !=nil {return false ,_eed ;};_abbc =(_fea ._fdef &0x80)!=0;_fea ._fdef ,_fea ._gb =_fea ._fdef &0x7f,7;return _abbc ,nil ;};_fea ._gb --;_abbc =(_fea ._fdef &(1<<_fea ._gb ))!=0;_fea ._fdef &=1<<_fea ._gb -1;return _abbc ,nil ;};func (_fa *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;};_fac :=int (_fa ._fg )+skip ;if _fac >=0&&_fac < 8{_fa ._fg =uint8 (_fac );return nil ;};_fac =int (_fa ._fg )+_fa ._da *8+skip ;if _fac < 0{return _a .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_dc :=_fac /8;_ab :=_fac %8;_fa ._fg =uint8 (_ab );if _cee :=_dc -_fa ._da ;_cee > 0&&len (_fa ._df )-1< _dc {if _fa ._fg !=0{_cee ++;};_fa .expandIfNeeded (_cee );};_fa ._da =_dc ;return nil ;};func (_gbf *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _gbf .writeBit (uint8 (bit ));};return _a .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");};func (_cdf *SubstreamReader )Seek (offset int64 ,whence int )(int64 ,error ){switch whence {case _f .SeekStart :_cdf ._fabg =uint64 (offset );case _f .SeekCurrent :_cdf ._fabg +=uint64 (offset );case _f .SeekEnd :_cdf ._fabg =_cdf ._fdad +uint64 (offset );default:return 0,_e .New ("\u0072\u0065\u0061d\u0065\u0072\u002e\u0053\u0075\u0062\u0073\u0074\u0072\u0065\u0061\u006d\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u0020\u0069\u006e\u0076\u0061\u006ci\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");};_cdf ._gb =0;return int64 (_cdf ._fabg ),nil ;};var _ _f .Writer =&BufferedWriter {};func (_ce *BufferedWriter )Reset (){_ce ._df =_ce ._df [:0];_ce ._da =0;_ce ._fg =0};func (_egdd *SubstreamReader )ReadByte ()(byte ,error ){if _egdd ._gb ==0{return _egdd .readBufferByte ();};return _egdd .readUnalignedByte ();};func _gbe (_begc ,_aaa uint64 )uint64 {if _begc < _aaa {return _begc ;};return _aaa ;};func (_cab *Writer )writeBit (_ceee uint8 )error {if len (_cab ._cce )-1< _cab ._add {return _f .EOF ;};_gbc :=_cab ._gdb ;if _cab ._facd {_gbc =7-_cab ._gdb ;};_cab ._cce [_cab ._add ]|=byte (uint16 (_ceee <<_gbc )&0xff);_cab ._gdb ++;if _cab ._gdb ==8{_cab ._add ++;_cab ._gdb =0;};return nil ;};func (_gbed *Writer )Data ()[]byte {return _gbed ._cce };func (_ceb *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _a .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );};if len (_ceb ._df )-1< _ceb ._da {_ceb .expandIfNeeded (1);};_db :=_ceb ._fg ;if _ceb ._ba {_db =7-_ceb ._fg ;};_ceb ._df [_ceb ._da ]|=byte (uint16 (bit <<_db )&0xff);_ceb ._fg ++;if _ceb ._fg ==8{_ceb ._da ++;_ceb ._fg =0;};return nil ;};func (_ebab *Reader )readUnalignedByte ()(_gf byte ,_ebe error ){_agc :=_ebab ._dbf ;_gf =_ebab ._bfd <<(8-_agc );_ebab ._bfd ,_ebe =_ebab .readBufferByte ();if _ebe !=nil {return 0,_ebe ;};_gf |=_ebab ._bfd >>_agc ;_ebab ._bfd &=1<<_agc -1;return _gf ,nil ;};func (_afg *Reader )Reset (){_afg ._bgbe =_afg ._aa ;_afg ._dbf =_afg ._bc };func (_gga *Reader )Align ()(_afd byte ){_afd =_gga ._dbf ;_gga ._dbf =0;return _afd };func (_deg *SubstreamReader )fillBuffer ()error {if uint64 (_deg ._egd .StreamPosition ())!=_deg ._fabg +_deg ._ggae {_ ,_eda :=_deg ._egd .Seek (int64 (_deg ._fabg +_deg ._ggae ),_f .SeekStart );if _eda !=nil {return _eda ;};};_deg ._egb =uint64 (_deg ._fabg );_bde :=_gbe (uint64 (len (_deg ._cec )),_deg ._fdad -_deg ._fabg );_cecf :=make ([]byte ,_bde );_agf ,_ccf :=_deg ._egd .Read (_cecf );if _ccf !=nil {return _ccf ;};for _cbc :=uint64 (0);_cbc < _bde ;_cbc ++{_deg ._cec [_cbc ]=_cecf [_cbc ];};_deg ._dcff =_deg ._egb +uint64 (_agf );return nil ;};var (_ _f .Reader =&Reader {};_ _f .ByteReader =&Reader {};_ _f .Seeker =&Reader {};_ StreamReader =&Reader {};);func (_cedb *Reader )Length ()uint64 {return uint64 (len (_cedb ._gg ))};func (_cgf *Reader )ReadBit ()(_cedg int ,_ceea error ){_cge ,_ceea :=_cgf .readBool ();if _ceea !=nil {return 0,_ceea ;};if _cge {_cedg =1;};return _cedg ,nil ;};func (_cgbe *SubstreamReader )ReadBool ()(bool ,error ){return _cgbe .readBool ()};var _ _f .ByteWriter =&BufferedWriter {};func (_edc *BufferedWriter )tryGrowByReslice (_bgb int )bool {if _ad :=len (_edc ._df );_bgb <=cap (_edc ._df )-_ad {_edc ._df =_edc ._df [:_ad +_bgb ];return true ;};return false ;};func (_ecd *BufferedWriter )WriteByte (bt byte )error {if _ecd ._da > len (_ecd ._df )-1||(_ecd ._da ==len (_ecd ._df )-1&&_ecd ._fg !=0){_ecd .expandIfNeeded (1);};_ecd .writeByte (bt );return nil ;};func (_baf *SubstreamReader )ReadBits (n byte )(_bgd uint64 ,_cda error ){if n < _baf ._gb {_edb :=_baf ._gb -n ;_bgd =uint64 (_baf ._fdef >>_edb );_baf ._fdef &=1<<_edb -1;_baf ._gb =_edb ;return _bgd ,nil ;};if n > _baf ._gb {if _baf ._gb > 0{_bgd =uint64 (_baf ._fdef );n -=_baf ._gb ;};var _be byte ;for n >=8{_be ,_cda =_baf .readBufferByte ();if _cda !=nil {return 0,_cda ;};_bgd =_bgd <<8+uint64 (_be );n -=8;};if n > 0{if _baf ._fdef ,_cda =_baf .readBufferByte ();_cda !=nil {return 0,_cda ;};_bag :=8-n ;_bgd =_bgd <<n +uint64 (_baf ._fdef >>_bag );_baf ._fdef &=1<<_bag -1;_baf ._gb =_bag ;}else {_baf ._gb =0;};return _bgd ,nil ;};_baf ._gb =0;return uint64 (_baf ._fdef ),nil ;};func (_cag *SubstreamReader )Read (b []byte )(_dcb int ,_dbdg error ){if _cag ._fabg >=_cag ._fdad {_ef .Log .Trace ("\u0053\u0074\u0072e\u0061\u006d\u0050\u006fs\u003a\u0020\u0027\u0025\u0064\u0027\u0020>\u003d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027",_cag ._fabg ,_cag ._fdad );return 0,_f .EOF ;};for ;_dcb < len (b );_dcb ++{if b [_dcb ],_dbdg =_cag .readUnalignedByte ();_dbdg !=nil {if _dbdg ==_f .EOF {return _dcb ,nil ;};return 0,_dbdg ;};};return _dcb ,nil ;};func (_fd *Reader )Read (p []byte )(_cef int ,_bge error ){if _fd ._dbf ==0{return _fd .read (p );};for ;_cef < len (p );_cef ++{if p [_cef ],_bge =_fd .readUnalignedByte ();_bge !=nil {return 0,_bge ;};};return _cef ,nil ;};func (_dg *Reader )ReadBool ()(bool ,error ){return _dg .readBool ()};func (_cgb *SubstreamReader )ReadBit ()(_dccc int ,_edf error ){_eff ,_edf :=_cgb .readBool ();if _edf !=nil {return 0,_edf ;};if _eff {_dccc =1;};return _dccc ,nil ;};func (_bdgc *Writer )ResetBit (){_bdgc ._gdb =0};func (_fda *Reader )readBufferByte ()(byte ,error ){if _fda ._bgbe >=int64 (len (_fda ._gg )){return 0,_f .EOF ;};_fda ._cde =-1;_aab :=_fda ._gg [_fda ._bgbe ];_fda ._bgbe ++;_fda ._fcf =int (_aab );return _aab ,nil ;};func (_bd *BufferedWriter )Len ()int {return _bd .byteCapacity ()};type SubstreamReader struct{_fabg uint64 ;_egd StreamReader ;_ggae uint64 ;_fdad uint64 ;_cec []byte ;_egb uint64 ;_dcff uint64 ;_fdef byte ;_gb byte ;_dff uint64 ;_ee byte ;};