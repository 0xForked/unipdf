//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_a "encoding/binary";_b "errors";_be "github.com/unidoc/unipdf/v3/common";_ae "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_g "io";);func (_fd *SubstreamReader )BitPosition ()int {return int (_fd ._bbf )};func (_bfa *Reader )Length ()uint64 {return uint64 (len (_bfa ._gc ))};
func (_da *BufferedWriter )Write (d []byte )(int ,error ){_da .expandIfNeeded (len (d ));if _da ._ga ==0{return _da .writeFullBytes (d ),nil ;};return _da .writeShiftedBytes (d ),nil ;};func (_abc *SubstreamReader )fillBuffer ()error {if uint64 (_abc ._egd .StreamPosition ())!=_abc ._gag +_abc ._aad {_ ,_gec :=_abc ._egd .Seek (int64 (_abc ._gag +_abc ._aad ),_g .SeekStart );
if _gec !=nil {return _gec ;};};_abc ._ag =_abc ._gag ;_fef :=_afb (uint64 (len (_abc ._gcc )),_abc ._eggg -_abc ._gag );_dae :=make ([]byte ,_fef );_egf ,_cdb :=_abc ._egd .Read (_dae );if _cdb !=nil {return _cdb ;};for _ffaf :=uint64 (0);_ffaf < _fef ;
_ffaf ++{_abc ._gcc [_ffaf ]=_dae [_ffaf ];};_abc ._egb =_abc ._ag +uint64 (_egf );return nil ;};func (_ac *BufferedWriter )FinishByte (){if _ac ._ga ==0{return ;};_ac ._ga =0;_ac ._c ++;};func _afb (_efb ,_ecb uint64 )uint64 {if _efb < _ecb {return _efb ;
};return _ecb ;};func (_gacb *Reader )readBool ()(_eef bool ,_gfca error ){if _gacb ._bg ==0{_gacb ._cbd ,_gfca =_gacb .readBufferByte ();if _gfca !=nil {return false ,_gfca ;};_eef =(_gacb ._cbd &0x80)!=0;_gacb ._cbd ,_gacb ._bg =_gacb ._cbd &0x7f,7;return _eef ,nil ;
};_gacb ._bg --;_eef =(_gacb ._cbd &(1<<_gacb ._bg ))!=0;_gacb ._cbd &=1<<_gacb ._bg -1;return _eef ,nil ;};type BufferedWriter struct{_f []byte ;_ga uint8 ;_c int ;_af bool ;};func (_fc *BufferedWriter )writeByte (_fgf byte ){switch {case _fc ._ga ==0:_fc ._f [_fc ._c ]=_fgf ;
_fc ._c ++;case _fc ._af :_fc ._f [_fc ._c ]|=_fgf >>_fc ._ga ;_fc ._c ++;_fc ._f [_fc ._c ]=byte (uint16 (_fgf )<<(8-_fc ._ga )&0xff);default:_fc ._f [_fc ._c ]|=byte (uint16 (_fgf )<<_fc ._ga &0xff);_fc ._c ++;_fc ._f [_fc ._c ]=_fgf >>(8-_fc ._ga );
};};func NewWriterMSB (data []byte )*Writer {return &Writer {_gaa :data ,_ega :true }};func NewSubstreamReader (r StreamReader ,offset ,length uint64 )(*SubstreamReader ,error ){if r ==nil {return nil ,_b .New ("\u0072o\u006ft\u0020\u0072\u0065\u0061\u0064e\u0072\u0020i\u0073\u0020\u006e\u0069\u006c");
};_be .Log .Trace ("\u004e\u0065\u0077\u0053\u0075\u0062\u0073\u0074r\u0065\u0061\u006dRe\u0061\u0064\u0065\u0072\u0020\u0061t\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u003a\u0020\u0025\u0064\u0020\u0077\u0069\u0074h\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a \u0025\u0064",offset ,length );
return &SubstreamReader {_egd :r ,_aad :offset ,_eggg :length ,_gcc :make ([]byte ,length )},nil ;};func (_daa *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _ae .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );
};if len (_daa ._f )-1< _daa ._c {_daa .expandIfNeeded (1);};_fe :=_daa ._ga ;if _daa ._af {_fe =7-_daa ._ga ;};_daa ._f [_daa ._c ]|=byte (uint16 (bit <<_fe )&0xff);_daa ._ga ++;if _daa ._ga ==8{_daa ._c ++;_daa ._ga =0;};return nil ;};func (_gfg *Writer )writeBit (_dea uint8 )error {if len (_gfg ._gaa )-1< _gfg ._caf {return _g .EOF ;
};_befd :=_gfg ._gde ;if _gfg ._ega {_befd =7-_gfg ._gde ;};_gfg ._gaa [_gfg ._caf ]|=byte (uint16 (_dea <<_befd )&0xff);_gfg ._gde ++;if _gfg ._gde ==8{_gfg ._caf ++;_gfg ._gde =0;};return nil ;};var _ _g .ByteWriter =&BufferedWriter {};func (_dfa *BufferedWriter )tryGrowByReslice (_dfc int )bool {if _bfc :=len (_dfa ._f );
_dfc <=cap (_dfa ._f )-_bfc {_dfa ._f =_dfa ._f [:_bfc +_dfc ];return true ;};return false ;};type SubstreamReader struct{_gag uint64 ;_egd StreamReader ;_aad uint64 ;_eggg uint64 ;_gcc []byte ;_ag uint64 ;_egb uint64 ;_dfb byte ;_bbf byte ;_egc uint64 ;
_db byte ;};func (_bdb *Writer )Data ()[]byte {return _bdb ._gaa };func (_bcde *SubstreamReader )ReadBool ()(bool ,error ){return _bcde .readBool ()};var _ BinaryWriter =&Writer {};func (_bb *BufferedWriter )Len ()int {return _bb .byteCapacity ()};func NewReader (data []byte )*Reader {return &Reader {_gc :data }};
var (_ _g .Reader =&Reader {};_ _g .ByteReader =&Reader {};_ _g .Seeker =&Reader {};_ StreamReader =&Reader {};);func (_bga *Reader )ReadUint32 ()(uint32 ,error ){_cbdf :=make ([]byte ,4);_ ,_aeeb :=_bga .Read (_cbdf );if _aeeb !=nil {return 0,_aeeb ;};
return _a .BigEndian .Uint32 (_cbdf ),nil ;};func (_ca *Reader )BitPosition ()int {return int (_ca ._bg )};const (_d =64;_eg =int (^uint (0)>>1););func (_fce *Writer )byteCapacity ()int {_gee :=len (_fce ._gaa )-_fce ._caf ;if _fce ._gde !=0{_gee --;};
return _gee ;};func (_fde *SubstreamReader )StreamPosition ()int64 {return int64 (_fde ._gag )};func (_gad *SubstreamReader )ReadBits (n byte )(_fgab uint64 ,_bfb error ){if n < _gad ._bbf {_eab :=_gad ._bbf -n ;_fgab =uint64 (_gad ._dfb >>_eab );_gad ._dfb &=1<<_eab -1;
_gad ._bbf =_eab ;return _fgab ,nil ;};if n > _gad ._bbf {if _gad ._bbf > 0{_fgab =uint64 (_gad ._dfb );n -=_gad ._bbf ;};var _aeb byte ;for n >=8{_aeb ,_bfb =_gad .readBufferByte ();if _bfb !=nil {return 0,_bfb ;};_fgab =_fgab <<8+uint64 (_aeb );n -=8;
};if n > 0{if _gad ._dfb ,_bfb =_gad .readBufferByte ();_bfb !=nil {return 0,_bfb ;};_gcag :=8-n ;_fgab =_fgab <<n +uint64 (_gad ._dfb >>_gcag );_gad ._dfb &=1<<_gcag -1;_gad ._bbf =_gcag ;}else {_gad ._bbf =0;};return _fgab ,nil ;};_gad ._bbf =0;return uint64 (_gad ._dfb ),nil ;
};func (_cff *Writer )FinishByte (){if _cff ._gde ==0{return ;};_cff ._gde =0;_cff ._caf ++;};type BinaryWriter interface{BitWriter ;_g .Writer ;_g .ByteWriter ;Data ()[]byte ;};type StreamReader interface{_g .Reader ;_g .ByteReader ;_g .Seeker ;Align ()byte ;
BitPosition ()int ;Mark ();Length ()uint64 ;ReadBit ()(int ,error );ReadBits (_fa byte )(uint64 ,error );ReadBool ()(bool ,error );ReadUint32 ()(uint32 ,error );Reset ();StreamPosition ()int64 ;};func (_ebc *SubstreamReader )Offset ()uint64 {return _ebc ._aad };
var _ BinaryWriter =&BufferedWriter {};func (_bc *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;};_ggb :=int (_bc ._ga )+skip ;if _ggb >=0&&_ggb < 8{_bc ._ga =uint8 (_ggb );return nil ;};_ggb =int (_bc ._ga )+_bc ._c *8+skip ;if _ggb < 0{return _ae .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_aea :=_ggb /8;_gf :=_ggb %8;_bc ._ga =uint8 (_gf );if _dc :=_aea -_bc ._c ;_dc > 0&&len (_bc ._f )-1< _aea {if _bc ._ga !=0{_dc ++;};_bc .expandIfNeeded (_dc );};_bc ._c =_aea ;return nil ;};func (_cde *BufferedWriter )writeFullBytes (_cded []byte )int {_fedb :=copy (_cde ._f [_cde .fullOffset ():],_cded );
_cde ._c +=_fedb ;return _fedb ;};func (_cgbe *Writer )WriteByte (c byte )error {return _cgbe .writeByte (c )};func (_ffa *SubstreamReader )Mark (){_ffa ._egc =_ffa ._gag ;_ffa ._db =_ffa ._bbf };func (_eeg *BufferedWriter )writeShiftedBytes (_ab []byte )int {for _ ,_cec :=range _ab {_eeg .writeByte (_cec );
};return len (_ab );};func (_dbb *Writer )SkipBits (skip int )error {const _acf ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";if skip ==0{return nil ;};_eaa :=int (_dbb ._gde )+skip ;if _eaa >=0&&_eaa < 8{_dbb ._gde =uint8 (_eaa );
return nil ;};_eaa =int (_dbb ._gde )+_dbb ._caf *8+skip ;if _eaa < 0{return _ae .Errorf (_acf ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_agee :=_eaa /8;_ccc :=_eaa %8;_be .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");
_be .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_dbb ._gde ,_dbb ._caf ,int (_dbb ._gde )+(_dbb ._caf )*8,len (_dbb ._gaa ),cap (_dbb ._gaa ));
_be .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_eaa ,_ccc );_dbb ._gde =uint8 (_ccc );if _egea :=_agee -_dbb ._caf ;
_egea > 0&&len (_dbb ._gaa )-1< _agee {_be .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_egea );return _ae .Errorf (_acf ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_dbb ._caf =_agee ;_be .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_dbb ._gde ,_dbb ._caf );return nil ;};type Writer struct{_gaa []byte ;
_gde uint8 ;_caf int ;_ega bool ;};func (_eda *SubstreamReader )ReadUint32 ()(uint32 ,error ){_cge :=make ([]byte ,4);_ ,_gfe :=_eda .Read (_cge );if _gfe !=nil {return 0,_gfe ;};return _a .BigEndian .Uint32 (_cge ),nil ;};func (_de *Reader )Align ()(_gfc byte ){_gfc =_de ._bg ;
_de ._bg =0;return _gfc };func (_ef *BufferedWriter )Data ()[]byte {return _ef ._f };func NewWriter (data []byte )*Writer {return &Writer {_gaa :data }};func (_aade *SubstreamReader )Seek (offset int64 ,whence int )(int64 ,error ){switch whence {case _g .SeekStart :_aade ._gag =uint64 (offset );
case _g .SeekCurrent :_aade ._gag +=uint64 (offset );case _g .SeekEnd :_aade ._gag =_aade ._eggg +uint64 (offset );default:return 0,_b .New ("\u0072\u0065\u0061d\u0065\u0072\u002e\u0053\u0075\u0062\u0073\u0074\u0072\u0065\u0061\u006d\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u0020\u0069\u006e\u0076\u0061\u006ci\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};_aade ._bbf =0;return int64 (_aade ._gag ),nil ;};func (_bcd *Reader )readUnalignedByte ()(_aae byte ,_adec error ){_def :=_bcd ._bg ;_aae =_bcd ._cbd <<(8-_def );_bcd ._cbd ,_adec =_bcd .readBufferByte ();if _adec !=nil {return 0,_adec ;};_aae |=_bcd ._cbd >>_def ;
_bcd ._cbd &=1<<_def -1;return _aae ,nil ;};func (_dad *Writer )ResetBit (){_dad ._gde =0};func (_feg *SubstreamReader )readUnalignedByte ()(_aeac byte ,_edc error ){_dbg :=_feg ._bbf ;_aeac =_feg ._dfb <<(8-_dbg );_feg ._dfb ,_edc =_feg .readBufferByte ();
if _edc !=nil {return 0,_edc ;};_aeac |=_feg ._dfb >>_dbg ;_feg ._dfb &=1<<_dbg -1;return _aeac ,nil ;};func (_dbf *Writer )Write (p []byte )(int ,error ){if len (p )> _dbf .byteCapacity (){return 0,_g .EOF ;};for _ ,_ebg :=range p {if _gdef :=_dbf .writeByte (_ebg );
_gdef !=nil {return 0,_gdef ;};};return len (p ),nil ;};func (_bd *BufferedWriter )Reset (){_bd ._f =_bd ._f [:0];_bd ._c =0;_bd ._ga =0};func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_af :true }};func (_fee *Reader )ReadBits (n byte )(_ffg uint64 ,_bge error ){if n < _fee ._bg {_egg :=_fee ._bg -n ;
_ffg =uint64 (_fee ._cbd >>_egg );_fee ._cbd &=1<<_egg -1;_fee ._bg =_egg ;return _ffg ,nil ;};if n > _fee ._bg {if _fee ._bg > 0{_ffg =uint64 (_fee ._cbd );n -=_fee ._bg ;};for n >=8{_bba ,_bgeg :=_fee .readBufferByte ();if _bgeg !=nil {return 0,_bgeg ;
};_ffg =_ffg <<8+uint64 (_bba );n -=8;};if n > 0{if _fee ._cbd ,_bge =_fee .readBufferByte ();_bge !=nil {return 0,_bge ;};_ade :=8-n ;_ffg =_ffg <<n +uint64 (_fee ._cbd >>_ade );_fee ._cbd &=1<<_ade -1;_fee ._bg =_ade ;}else {_fee ._bg =0;};return _ffg ,nil ;
};_fee ._bg =0;return uint64 (_fee ._cbd ),nil ;};func (_aaf *SubstreamReader )Read (b []byte )(_gca int ,_adg error ){if _aaf ._gag >=_aaf ._eggg {_be .Log .Trace ("\u0053\u0074\u0072e\u0061\u006d\u0050\u006fs\u003a\u0020\u0027\u0025\u0064\u0027\u0020>\u003d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027",_aaf ._gag ,_aaf ._eggg );
return 0,_g .EOF ;};for ;_gca < len (b );_gca ++{if b [_gca ],_adg =_aaf .readUnalignedByte ();_adg !=nil {if _adg ==_g .EOF {return _gca ,nil ;};return 0,_adg ;};};return _gca ,nil ;};func (_bfg *Reader )ReadByte ()(byte ,error ){if _bfg ._bg ==0{return _bfg .readBufferByte ();
};return _bfg .readUnalignedByte ();};type BitWriter interface{WriteBit (_efd int )error ;WriteBits (_ea uint64 ,_ead int )(_ad int ,_eb error );FinishByte ();SkipBits (_bdfb int )error ;};type Reader struct{_gc []byte ;_cbd byte ;_bg byte ;_gcg int64 ;
_gb int ;_dg int ;_adf int64 ;_fbdg byte ;};func (_dgf *Reader )readBufferByte ()(byte ,error ){if _dgf ._gcg >=int64 (len (_dgf ._gc )){return 0,_g .EOF ;};_dgf ._dg =-1;_gge :=_dgf ._gc [_dgf ._gcg ];_dgf ._gcg ++;_dgf ._gb =int (_gge );return _gge ,nil ;
};func (_cebc *BufferedWriter )byteCapacity ()int {_fb :=len (_cebc ._f )-_cebc ._c ;if _cebc ._ga !=0{_fb --;};return _fb ;};func (_aag *Writer )writeByte (_cgec byte )error {if _aag ._caf > len (_aag ._gaa )-1{return _g .EOF ;};if _aag ._caf ==len (_aag ._gaa )-1&&_aag ._gde !=0{return _g .EOF ;
};if _aag ._gde ==0{_aag ._gaa [_aag ._caf ]=_cgec ;_aag ._caf ++;return nil ;};if _aag ._ega {_aag ._gaa [_aag ._caf ]|=_cgec >>_aag ._gde ;_aag ._caf ++;_aag ._gaa [_aag ._caf ]=byte (uint16 (_cgec )<<(8-_aag ._gde )&0xff);}else {_aag ._gaa [_aag ._caf ]|=byte (uint16 (_cgec )<<_aag ._gde &0xff);
_aag ._caf ++;_aag ._gaa [_aag ._caf ]=_cgec >>(8-_aag ._gde );};return nil ;};func (_gbf *Writer )WriteBits (bits uint64 ,number int )(_dbag int ,_ddc error ){const _ffgd ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";
if number < 0||number > 64{return 0,_ae .Errorf (_ffgd ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};if number ==0{return 0,nil ;};_cece :=number /8;if _cece > 0{_cfd :=number -_cece *8;for _ffc :=_cece -1;_ffc >=0;_ffc --{_cgd :=byte ((bits >>uint (_ffc *8+_cfd ))&0xff);if _ddc =_gbf .WriteByte (_cgd );_ddc !=nil {return _dbag ,_ae .Wrapf (_ddc ,_ffgd ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_cece -_ffc +1);
};};number -=_cece *8;if number ==0{return _cece ,nil ;};};var _fda int ;for _abe :=0;_abe < number ;_abe ++{if _gbf ._ega {_fda =int ((bits >>uint (number -1-_abe ))&0x1);}else {_fda =int (bits &0x1);bits >>=1;};if _ddc =_gbf .WriteBit (_fda );_ddc !=nil {return _dbag ,_ae .Wrapf (_ddc ,_ffgd ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_abe );
};};return _cece ,nil ;};func (_ege *SubstreamReader )readBufferByte ()(byte ,error ){if _ege ._gag >=_ege ._eggg {return 0,_g .EOF ;};if _ege ._gag >=_ege ._egb ||_ege ._gag < _ege ._ag {if _egef :=_ege .fillBuffer ();_egef !=nil {return 0,_egef ;};};
_bfd :=_ege ._gcc [_ege ._gag -_ege ._ag ];_ege ._gag ++;return _bfd ,nil ;};func (_gfcb *SubstreamReader )Reset (){_gfcb ._gag =_gfcb ._egc ;_gfcb ._bbf =_gfcb ._db };func (_fac *SubstreamReader )ReadByte ()(byte ,error ){if _fac ._bbf ==0{return _fac .readBufferByte ();
};return _fac .readUnalignedByte ();};func (_cc *SubstreamReader )ReadBit ()(_bac int ,_gceb error ){_adgb ,_gceb :=_cc .readBool ();if _gceb !=nil {return 0,_gceb ;};if _adgb {_bac =1;};return _bac ,nil ;};func (_dd *Reader )ReadBit ()(_ed int ,_ff error ){_ge ,_ff :=_dd .readBool ();
if _ff !=nil {return 0,_ff ;};if _ge {_ed =1;};return _ed ,nil ;};func (_ee *BufferedWriter )expandIfNeeded (_cbb int ){if !_ee .tryGrowByReslice (_cbb ){_ee .grow (_cbb );};};func (_cb *BufferedWriter )ResetBitIndex (){_cb ._ga =0};func (_bef *SubstreamReader )Length ()uint64 {return _bef ._eggg };
func (_aa *BufferedWriter )WriteByte (bt byte )error {if _aa ._c > len (_aa ._f )-1||(_aa ._c ==len (_aa ._f )-1&&_aa ._ga !=0){_aa .expandIfNeeded (1);};_aa .writeByte (bt );return nil ;};func (_ec *BufferedWriter )WriteBits (bits uint64 ,number int )(_fg int ,_fed error ){const _dce ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";
if number < 0||number > 64{return 0,_ae .Errorf (_dce ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};_fgb :=number /8;if _fgb > 0{_df :=number -_fgb *8;for _cg :=_fgb -1;_cg >=0;_cg --{_fgd :=byte ((bits >>uint (_cg *8+_df ))&0xff);if _fed =_ec .WriteByte (_fgd );_fed !=nil {return _fg ,_ae .Wrapf (_fed ,_dce ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_fgb -_cg +1);
};};number -=_fgb *8;if number ==0{return _fgb ,nil ;};};var _ceb int ;for _bdd :=0;_bdd < number ;_bdd ++{if _ec ._af {_ceb =int ((bits >>uint (number -1-_bdd ))&0x1);}else {_ceb =int (bits &0x1);bits >>=1;};if _fed =_ec .WriteBit (_ceb );_fed !=nil {return _fg ,_ae .Wrapf (_fed ,_dce ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_bdd );
};};return _fgb ,nil ;};func (_fgff *Reader )ConsumeRemainingBits (){if _fgff ._bg !=0{_ ,_eeag :=_fgff .ReadBits (_fgff ._bg );if _eeag !=nil {_be .Log .Debug ("\u0043\u006f\u006e\u0073\u0075\u006d\u0065\u0052\u0065\u006da\u0069\u006e\u0069\u0067\u0042\u0069\u0074s\u0020\u0066\u0061\u0069\u006c\u0065\u0064\u003a\u0020\u0025\u0076",_eeag );
};};};func (_deb *Reader )StreamPosition ()int64 {return _deb ._gcg };func (_add *Reader )Read (p []byte )(_afc int ,_bae error ){if _add ._bg ==0{return _add .read (p );};for ;_afc < len (p );_afc ++{if p [_afc ],_bae =_add .readUnalignedByte ();_bae !=nil {return 0,_bae ;
};};return _afc ,nil ;};var _ _g .Writer =&BufferedWriter {};func (_fff *Reader )Reset (){_fff ._gcg =_fff ._adf ;_fff ._bg =_fff ._fbdg };func (_eea *BufferedWriter )fullOffset ()int {_fba :=_eea ._c ;if _eea ._ga !=0{_fba ++;};return _fba ;};func (_aab *BufferedWriter )grow (_cd int ){if _aab ._f ==nil &&_cd < _d {_aab ._f =make ([]byte ,_cd ,_d );
return ;};_bdf :=len (_aab ._f );if _aab ._ga !=0{_bdf ++;};_ba :=cap (_aab ._f );switch {case _cd <=_ba /2-_bdf :_be .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_aab ._f ),cap (_aab ._f ),_cd );
_be .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_ba ,_bdf );copy (_aab ._f ,_aab ._f [_aab .fullOffset ():]);
case _ba > _eg -_ba -_cd :_be .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_bf :=make ([]byte ,2*_ba +_cd );copy (_bf ,_aab ._f );_aab ._f =_bf ;};_aab ._f =_aab ._f [:_bdf +_cd ];
};func (_cac *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_cac ._dg =-1;var _cgb int64 ;switch whence {case _g .SeekStart :_cgb =offset ;case _g .SeekCurrent :_cgb =_cac ._gcg +offset ;case _g .SeekEnd :_cgb =int64 (len (_cac ._gc ))+offset ;
default:return 0,_b .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");};if _cgb < 0{return 0,_b .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");
};_cac ._gcg =_cgb ;_cac ._bg =0;return _cgb ,nil ;};func (_gce *Reader )read (_eag []byte )(int ,error ){if _gce ._gcg >=int64 (len (_gce ._gc )){return 0,_g .EOF ;};_gce ._dg =-1;_cfe :=copy (_eag ,_gce ._gc [_gce ._gcg :]);_gce ._gcg +=int64 (_cfe );
return _cfe ,nil ;};func (_dba *SubstreamReader )Align ()(_deg byte ){_deg =_dba ._bbf ;_dba ._bbf =0;return _deg };func (_aee *Reader )Mark (){_aee ._adf =_aee ._gcg ;_aee ._fbdg =_aee ._bg };func (_gaad *Writer )UseMSB ()bool {return _gaad ._ega };func (_fec *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _fec .writeBit (uint8 (bit ));
};return _ae .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");};func (_cgf *SubstreamReader )readBool ()(_degc bool ,_fbae error ){if _cgf ._bbf ==0{_cgf ._dfb ,_fbae =_cgf .readBufferByte ();
if _fbae !=nil {return false ,_fbae ;};_degc =(_cgf ._dfb &0x80)!=0;_cgf ._dfb ,_cgf ._bbf =_cgf ._dfb &0x7f,7;return _degc ,nil ;};_cgf ._bbf --;_degc =(_cgf ._dfb &(1<<_cgf ._bbf ))!=0;_cgf ._dfb &=1<<_cgf ._bbf -1;return _degc ,nil ;};func (_cf *Reader )ReadBool ()(bool ,error ){return _cf .readBool ()};
