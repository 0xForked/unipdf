//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_b "encoding/binary";_ed "errors";_e "fmt";_ga "github.com/unidoc/unipdf/v3/common";_ec "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_c "io";);func (_gd *BufferedWriter )FinishByte (){if _gd ._fa ==0{return ;};_gd ._fa =0;
_gd ._fb ++;};func (_eea *Reader )Align ()(_egc byte ){_egc =_eea ._cbf ;_eea ._cbf =0;return _egc };func (_ef *Reader )ConsumeRemainingBits ()(uint64 ,error ){if _ef ._cbf !=0{return _ef .ReadBits (_ef ._cbf );};return 0,nil ;};func (_bcfa *Writer )WriteByte (c byte )error {return _bcfa .writeByte (c )};
func (_fdc *BufferedWriter )Len ()int {return _fdc .byteCapacity ()};func (_ffb *Reader )Length ()uint64 {return uint64 (_ffb ._abb ._ccd )};func (_efa *Writer )WriteBits (bits uint64 ,number int )(_bgb int ,_ddb error ){const _deg ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";
if number < 0||number > 64{return 0,_ec .Errorf (_deg ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};if number ==0{return 0,nil ;};_fda :=number /8;if _fda > 0{_dafg :=number -_fda *8;for _bff :=_fda -1;_bff >=0;_bff --{_efag :=byte ((bits >>uint (_bff *8+_dafg ))&0xff);if _ddb =_efa .WriteByte (_efag );_ddb !=nil {return _bgb ,_ec .Wrapf (_ddb ,_deg ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_fda -_bff +1);
};};number -=_fda *8;if number ==0{return _fda ,nil ;};};var _gde int ;for _cfc :=0;_cfc < number ;_cfc ++{if _efa ._dab {_gde =int ((bits >>uint (number -1-_cfc ))&0x1);}else {_gde =int (bits &0x1);bits >>=1;};if _ddb =_efa .WriteBit (_gde );_ddb !=nil {return _bgb ,_ec .Wrapf (_ddb ,_deg ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_cfc );
};};return _fda ,nil ;};func (_bfd *Reader )NewPartialReader (offset ,length int ,relative bool )(*Reader ,error ){if offset < 0{return nil ,_ed .New ("p\u0061\u0072\u0074\u0069\u0061\u006c\u0020\u0072\u0065\u0061\u0064\u0065\u0072\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062e \u006e\u0065\u0067a\u0074i\u0076\u0065");
};if relative {offset =_bfd ._abb ._ace +offset ;};if length > 0{_bdd :=len (_bfd ._abb ._bad );if relative {_bdd =_bfd ._abb ._ccd ;};if offset +length > _bdd {return nil ,_e .Errorf ("\u0070\u0061r\u0074\u0069\u0061l\u0020\u0072\u0065\u0061\u0064e\u0072\u0020\u006f\u0066\u0066se\u0074\u0028\u0025\u0064\u0029\u002b\u006c\u0065\u006e\u0067\u0074\u0068\u0028\u0025\u0064\u0029\u003d\u0025d\u0020i\u0073\u0020\u0067\u0072\u0065\u0061ter\u0020\u0074\u0068\u0061\u006e\u0020\u0074\u0068\u0065\u0020\u006f\u0072ig\u0069n\u0061\u006c\u0020\u0072e\u0061d\u0065r\u0020\u006ce\u006e\u0067th\u003a\u0020\u0025\u0064",offset ,length ,offset +length ,_bfd ._abb ._ccd );
};};if length < 0{_dee :=len (_bfd ._abb ._bad );if relative {_dee =_bfd ._abb ._ccd ;};length =_dee -offset ;};return &Reader {_abb :readerSource {_bad :_bfd ._abb ._bad ,_ccd :length ,_ace :offset }},nil ;};func (_bb *BufferedWriter )Data ()[]byte {return _bb ._cd };
func (_dc *BufferedWriter )Reset (){_dc ._cd =_dc ._cd [:0];_dc ._fb =0;_dc ._fa =0};func (_ge *BufferedWriter )fullOffset ()int {_dfa :=_ge ._fb ;if _ge ._fa !=0{_dfa ++;};return _dfa ;};func (_dcb *BufferedWriter )WriteBits (bits uint64 ,number int )(_fbe int ,_fed error ){const _bcb ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";
if number < 0||number > 64{return 0,_ec .Errorf (_bcb ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};_ee :=number /8;if _ee > 0{_ad :=number -_ee *8;for _fg :=_ee -1;_fg >=0;_fg --{_dcbb :=byte ((bits >>uint (_fg *8+_ad ))&0xff);if _fed =_dcb .WriteByte (_dcbb );_fed !=nil {return _fbe ,_ec .Wrapf (_fed ,_bcb ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_ee -_fg +1);
};};number -=_ee *8;if number ==0{return _ee ,nil ;};};var _de int ;for _dcc :=0;_dcc < number ;_dcc ++{if _dcb ._fe {_de =int ((bits >>uint (number -1-_dcc ))&0x1);}else {_de =int (bits &0x1);bits >>=1;};if _fed =_dcb .WriteBit (_de );_fed !=nil {return _fbe ,_ec .Wrapf (_fed ,_bcb ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_dcc );
};};return _ee ,nil ;};func NewReader (data []byte )*Reader {return &Reader {_abb :readerSource {_bad :data ,_ccd :len (data ),_ace :0}};};func (_dce *Writer )FinishByte (){if _dce ._gbb ==0{return ;};_dce ._gbb =0;_dce ._edd ++;};func (_da *Reader )ReadBits (n byte )(_bg uint64 ,_dbg error ){if n < _da ._cbf {_fec :=_da ._cbf -n ;
_bg =uint64 (_da ._ca >>_fec );_da ._ca &=1<<_fec -1;_da ._cbf =_fec ;return _bg ,nil ;};if n > _da ._cbf {if _da ._cbf > 0{_bg =uint64 (_da ._ca );n -=_da ._cbf ;};for n >=8{_dbb ,_fce :=_da .readBufferByte ();if _fce !=nil {return 0,_fce ;};_bg =_bg <<8+uint64 (_dbb );
n -=8;};if n > 0{if _da ._ca ,_dbg =_da .readBufferByte ();_dbg !=nil {return 0,_dbg ;};_acf :=8-n ;_bg =_bg <<n +uint64 (_da ._ca >>_acf );_da ._ca &=1<<_acf -1;_da ._cbf =_acf ;}else {_da ._cbf =0;};return _bg ,nil ;};_da ._cbf =0;return uint64 (_da ._ca ),nil ;
};func (_fdg *Reader )ReadByte ()(byte ,error ){if _fdg ._cbf ==0{return _fdg .readBufferByte ();};return _fdg .readUnalignedByte ();};var _ BinaryWriter =&BufferedWriter {};type StreamReader interface{_c .Reader ;_c .ByteReader ;_c .Seeker ;Align ()byte ;
BitPosition ()int ;Mark ();Length ()uint64 ;ReadBit ()(int ,error );ReadBits (_aa byte )(uint64 ,error );ReadBool ()(bool ,error );ReadUint32 ()(uint32 ,error );Reset ();AbsolutePosition ()int64 ;};func (_daf *Reader )readBufferByte ()(byte ,error ){if _daf ._ae >=int64 (_daf ._abb ._ccd ){return 0,_c .EOF ;
};_daf ._dfe =-1;_dea :=_daf ._abb ._bad [int64 (_daf ._abb ._ace )+_daf ._ae ];_daf ._ae ++;_daf ._bda =int (_dea );return _dea ,nil ;};func NewWriter (data []byte )*Writer {return &Writer {_bgf :data }};func (_be *BufferedWriter )Write (d []byte )(int ,error ){_be .expandIfNeeded (len (d ));
if _be ._fa ==0{return _be .writeFullBytes (d ),nil ;};return _be .writeShiftedBytes (d ),nil ;};func (_dg *BufferedWriter )expandIfNeeded (_gg int ){if !_dg .tryGrowByReslice (_gg ){_dg .grow (_gg );};};func (_aga *Reader )AbsoluteLength ()uint64 {return uint64 (len (_aga ._abb ._bad ))};
func (_gdc *Reader )ReadBool ()(bool ,error ){return _gdc .readBool ()};func (_feed *Reader )ReadBit ()(_ffd int ,_bbc error ){_eb ,_bbc :=_feed .readBool ();if _bbc !=nil {return 0,_bbc ;};if _eb {_ffd =1;};return _ffd ,nil ;};func (_afc *Writer )SkipBits (skip int )error {const _cee ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";
if skip ==0{return nil ;};_cda :=int (_afc ._gbb )+skip ;if _cda >=0&&_cda < 8{_afc ._gbb =uint8 (_cda );return nil ;};_cda =int (_afc ._gbb )+_afc ._edd *8+skip ;if _cda < 0{return _ec .Errorf (_cee ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_bdea :=_cda /8;_bbf :=_cda %8;_ga .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");_ga .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_afc ._gbb ,_afc ._edd ,int (_afc ._gbb )+(_afc ._edd )*8,len (_afc ._bgf ),cap (_afc ._bgf ));
_ga .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_cda ,_bbf );_afc ._gbb =uint8 (_bbf );if _eee :=_bdea -_afc ._edd ;
_eee > 0&&len (_afc ._bgf )-1< _bdea {_ga .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_eee );return _ec .Errorf (_cee ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};
_afc ._edd =_bdea ;_ga .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_afc ._gbb ,_afc ._edd );return nil ;};func (_fbg *Writer )ResetBit (){_fbg ._gbb =0};
func (_gf *Writer )UseMSB ()bool {return _gf ._dab };func (_cbe *Reader )AbsolutePosition ()int64 {return _cbe ._ae +int64 (_cbe ._abb ._ace )};func (_ab *BufferedWriter )writeFullBytes (_ag []byte )int {_fee :=copy (_ab ._cd [_ab .fullOffset ():],_ag );
_ab ._fb +=_fee ;return _fee ;};func (_acg *Reader )read (_gad []byte )(int ,error ){if _acg ._ae >=int64 (_acg ._abb ._ccd ){return 0,_c .EOF ;};_acg ._dfe =-1;_ffa :=copy (_gad ,_acg ._abb ._bad [(int64 (_acg ._abb ._ace )+_acg ._ae ):(_acg ._abb ._ace +_acg ._abb ._ccd )]);
_acg ._ae +=int64 (_ffa );return _ffa ,nil ;};func (_gdb *Reader )Reset (){_gdb ._ae =_gdb ._eae ;_gdb ._cbf =_gdb ._adf ;_gdb ._ca =_gdb ._aed ;_gdb ._bda =_gdb ._eg ;};func (_eed *BufferedWriter )writeShiftedBytes (_cce []byte )int {for _ ,_fdf :=range _cce {_eed .writeByte (_fdf );
};return len (_cce );};type Reader struct{_abb readerSource ;_ca byte ;_cbf byte ;_ae int64 ;_bda int ;_dfe int ;_eae int64 ;_adf byte ;_aed byte ;_eg int ;};type Writer struct{_bgf []byte ;_gbb uint8 ;_edd int ;_dab bool ;};func (_agge *Writer )Write (p []byte )(int ,error ){if len (p )> _agge .byteCapacity (){return 0,_c .EOF ;
};for _ ,_ebb :=range p {if _bcfb :=_agge .writeByte (_ebb );_bcfb !=nil {return 0,_bcfb ;};};return len (p ),nil ;};func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_fe :true }};func (_bea *BufferedWriter )tryGrowByReslice (_cb int )bool {if _fdce :=len (_bea ._cd );
_cb <=cap (_bea ._cd )-_fdce {_bea ._cd =_bea ._cd [:_fdce +_cb ];return true ;};return false ;};var _ _c .ByteWriter =&BufferedWriter {};func (_bdc *Reader )RelativePosition ()int64 {return _bdc ._ae };var _ BinaryWriter =&Writer {};func (_a *BufferedWriter )WriteByte (bt byte )error {if _a ._fb > len (_a ._cd )-1||(_a ._fb ==len (_a ._cd )-1&&_a ._fa !=0){_a .expandIfNeeded (1);
};_a .writeByte (bt );return nil ;};func (_ega *Reader )readBool ()(_ccdd bool ,_gba error ){if _ega ._cbf ==0{_ega ._ca ,_gba =_ega .readBufferByte ();if _gba !=nil {return false ,_gba ;};_ccdd =(_ega ._ca &0x80)!=0;_ega ._ca ,_ega ._cbf =_ega ._ca &0x7f,7;
return _ccdd ,nil ;};_ega ._cbf --;_ccdd =(_ega ._ca &(1<<_ega ._cbf ))!=0;_ega ._ca &=1<<_ega ._cbf -1;return _ccdd ,nil ;};func (_bce *BufferedWriter )byteCapacity ()int {_fgf :=len (_bce ._cd )-_bce ._fb ;if _bce ._fa !=0{_fgf --;};return _fgf ;};func (_ba *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;
};_fc :=int (_ba ._fa )+skip ;if _fc >=0&&_fc < 8{_ba ._fa =uint8 (_fc );return nil ;};_fc =int (_ba ._fa )+_ba ._fb *8+skip ;if _fc < 0{return _ec .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_ff :=_fc /8;_cc :=_fc %8;_ba ._fa =uint8 (_cc );if _gaf :=_ff -_ba ._fb ;_gaf > 0&&len (_ba ._cd )-1< _ff {if _ba ._fa !=0{_gaf ++;};_ba .expandIfNeeded (_gaf );};_ba ._fb =_ff ;return nil ;};type readerSource struct{_bad []byte ;_ace int ;_ccd int ;
};var _ _c .Writer =&BufferedWriter {};func (_ffac *Writer )byteCapacity ()int {_dge :=len (_ffac ._bgf )-_ffac ._edd ;if _ffac ._gbb !=0{_dge --;};return _dge ;};func (_ceee *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _ceee .writeBit (uint8 (bit ));
};return _ec .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");};func (_ecb *Reader )ReadUint32 ()(uint32 ,error ){_ggg :=make ([]byte ,4);_ ,_ccb :=_ecb .Read (_ggg );
if _ccb !=nil {return 0,_ccb ;};return _b .BigEndian .Uint32 (_ggg ),nil ;};func (_afb *Writer )writeBit (_fcc uint8 )error {if len (_afb ._bgf )-1< _afb ._edd {return _c .EOF ;};_agc :=_afb ._gbb ;if _afb ._dab {_agc =7-_afb ._gbb ;};_afb ._bgf [_afb ._edd ]|=byte (uint16 (_fcc <<_agc )&0xff);
_afb ._gbb ++;if _afb ._gbb ==8{_afb ._edd ++;_afb ._gbb =0;};return nil ;};var (_ _c .Reader =&Reader {};_ _c .ByteReader =&Reader {};_ _c .Seeker =&Reader {};_ StreamReader =&Reader {};);func (_bcf *Reader )BitPosition ()int {return int (_bcf ._cbf )};
func (_dgc *Writer )writeByte (_ggaf byte )error {if _dgc ._edd > len (_dgc ._bgf )-1{return _c .EOF ;};if _dgc ._edd ==len (_dgc ._bgf )-1&&_dgc ._gbb !=0{return _c .EOF ;};if _dgc ._gbb ==0{_dgc ._bgf [_dgc ._edd ]=_ggaf ;_dgc ._edd ++;return nil ;};
if _dgc ._dab {_dgc ._bgf [_dgc ._edd ]|=_ggaf >>_dgc ._gbb ;_dgc ._edd ++;_dgc ._bgf [_dgc ._edd ]=byte (uint16 (_ggaf )<<(8-_dgc ._gbb )&0xff);}else {_dgc ._bgf [_dgc ._edd ]|=byte (uint16 (_ggaf )<<_dgc ._gbb &0xff);_dgc ._edd ++;_dgc ._bgf [_dgc ._edd ]=_ggaf >>(8-_dgc ._gbb );
};return nil ;};type BinaryWriter interface{BitWriter ;_c .Writer ;_c .ByteWriter ;Data ()[]byte ;};func (_cab *Reader )readUnalignedByte ()(_ade byte ,_cad error ){_bbb :=_cab ._cbf ;_ade =_cab ._ca <<(8-_bbb );_cab ._ca ,_cad =_cab .readBufferByte ();
if _cad !=nil {return 0,_cad ;};_ade |=_cab ._ca >>_bbb ;_cab ._ca &=1<<_bbb -1;return _ade ,nil ;};func (_df *BufferedWriter )ResetBitIndex (){_df ._fa =0};func (_fef *BufferedWriter )writeByte (_ded byte ){switch {case _fef ._fa ==0:_fef ._cd [_fef ._fb ]=_ded ;
_fef ._fb ++;case _fef ._fe :_fef ._cd [_fef ._fb ]|=_ded >>_fef ._fa ;_fef ._fb ++;_fef ._cd [_fef ._fb ]=byte (uint16 (_ded )<<(8-_fef ._fa )&0xff);default:_fef ._cd [_fef ._fb ]|=byte (uint16 (_ded )<<_fef ._fa &0xff);_fef ._fb ++;_fef ._cd [_fef ._fb ]=_ded >>(8-_fef ._fa );
};};func (_bec *BufferedWriter )grow (_ecf int ){if _bec ._cd ==nil &&_ecf < _f {_bec ._cd =make ([]byte ,_ecf ,_f );return ;};_bd :=len (_bec ._cd );if _bec ._fa !=0{_bd ++;};_db :=cap (_bec ._cd );switch {case _ecf <=_db /2-_bd :_ga .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_bec ._cd ),cap (_bec ._cd ),_ecf );
_ga .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_db ,_bd );copy (_bec ._cd ,_bec ._cd [_bec .fullOffset ():]);
case _db > _d -_db -_ecf :_ga .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_gafe :=make ([]byte ,2*_db +_ecf );copy (_gafe ,_bec ._cd );_bec ._cd =_gafe ;};_bec ._cd =_bec ._cd [:_bd +_ecf ];
};func (_caa *Reader )Mark (){_caa ._eae =_caa ._ae ;_caa ._adf =_caa ._cbf ;_caa ._aed =_caa ._ca ;_caa ._eg =_caa ._bda ;};type BitWriter interface{WriteBit (_cdc int )error ;WriteBits (_ac uint64 ,_dgg int )(_faa int ,_agg error );FinishByte ();SkipBits (_ece int )error ;
};func (_eda *Reader )Read (p []byte )(_cf int ,_bde error ){if _eda ._cbf ==0{return _eda .read (p );};for ;_cf < len (p );_cf ++{if p [_cf ],_bde =_eda .readUnalignedByte ();_bde !=nil {return 0,_bde ;};};return _cf ,nil ;};func (_fea *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_fea ._dfe =-1;
_fea ._cbf =0;_fea ._ca =0;_fea ._bda =0;var _dd int64 ;switch whence {case _c .SeekStart :_dd =offset ;case _c .SeekCurrent :_dd =_fea ._ae +offset ;case _c .SeekEnd :_dd =int64 (_fea ._abb ._ccd )+offset ;default:return 0,_ed .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};if _dd < 0{return 0,_ed .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");};_fea ._ae =_dd ;_fea ._cbf =0;
return _dd ,nil ;};const (_f =64;_d =int (^uint (0)>>1););type BufferedWriter struct{_cd []byte ;_fa uint8 ;_fb int ;_fe bool ;};func (_ea *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _ec .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );
};if len (_ea ._cd )-1< _ea ._fb {_ea .expandIfNeeded (1);};_bf :=_ea ._fa ;if _ea ._fe {_bf =7-_ea ._fa ;};_ea ._cd [_ea ._fb ]|=byte (uint16 (bit <<_bf )&0xff);_ea ._fa ++;if _ea ._fa ==8{_ea ._fb ++;_ea ._fa =0;};return nil ;};func NewWriterMSB (data []byte )*Writer {return &Writer {_bgf :data ,_dab :true }};
func (_edc *Writer )Data ()[]byte {return _edc ._bgf };