//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_a "encoding/binary";_f "errors";_g "github.com/unidoc/unipdf/v3/common";_ad "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_bg "io";);func (_gab *SubstreamReader )readBool ()(_gcae bool ,_ccaa error ){if _gab ._ebc ==0{_gab ._dedg ,_ccaa =_gab .readBufferByte ();
if _ccaa !=nil {return false ,_ccaa ;};_gcae =(_gab ._dedg &0x80)!=0;_gab ._dedg ,_gab ._ebc =_gab ._dedg &0x7f,7;return _gcae ,nil ;};_gab ._ebc --;_gcae =(_gab ._dedg &(1<<_gab ._ebc ))!=0;_gab ._dedg &=1<<_gab ._ebc -1;return _gcae ,nil ;};func (_df *BufferedWriter )writeByte (_cbc byte ){switch {case _df ._bc ==0:_df ._bf [_df ._baa ]=_cbc ;
_df ._baa ++;case _df ._e :_df ._bf [_df ._baa ]|=_cbc >>_df ._bc ;_df ._baa ++;_df ._bf [_df ._baa ]=byte (uint16 (_cbc )<<(8-_df ._bc )&0xff);default:_df ._bf [_df ._baa ]|=byte (uint16 (_cbc )<<_df ._bc &0xff);_df ._baa ++;_df ._bf [_df ._baa ]=_cbc >>(8-_df ._bc );
};};func (_db *BufferedWriter )fullOffset ()int {_ffe :=_db ._baa ;if _db ._bc !=0{_ffe ++;};return _ffe ;};func (_ce *Reader )Align ()(_dfg byte ){_dfg =_ce ._daf ;_ce ._daf =0;return _dfg };const (_fd =64;_ba =int (^uint (0)>>1););func (_cdg *BufferedWriter )Write (d []byte )(int ,error ){_cdg .expandIfNeeded (len (d ));
if _cdg ._bc ==0{return _cdg .writeFullBytes (d ),nil ;};return _cdg .writeShiftedBytes (d ),nil ;};func NewWriterMSB (data []byte )*Writer {return &Writer {_fad :data ,_gabf :true }};type BufferedWriter struct{_bf []byte ;_bc uint8 ;_baa int ;_e bool ;
};func (_dbd *SubstreamReader )Read (b []byte )(_deg int ,_aag error ){if _dbd ._fdbg >=_dbd ._geg {_g .Log .Trace ("\u0053\u0074\u0072e\u0061\u006d\u0050\u006fs\u003a\u0020\u0027\u0025\u0064\u0027\u0020>\u003d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027",_dbd ._fdbg ,_dbd ._geg );
return 0,_bg .EOF ;};for ;_deg < len (b );_deg ++{if b [_deg ],_aag =_dbd .readUnalignedByte ();_aag !=nil {if _aag ==_bg .EOF {return _deg ,nil ;};return 0,_aag ;};};return _deg ,nil ;};type StreamReader interface{_bg .Reader ;_bg .ByteReader ;_bg .Seeker ;
Align ()byte ;BitPosition ()int ;Mark ();Length ()uint64 ;ReadBit ()(int ,error );ReadBits (_dbb byte )(uint64 ,error );ReadBool ()(bool ,error );ReadUint32 ()(uint32 ,error );Reset ();StreamPosition ()int64 ;};func (_eff *Reader )read (_ded []byte )(int ,error ){if _eff ._fa >=int64 (len (_eff ._daa )){return 0,_bg .EOF ;
};_eff ._aga =-1;_dgg :=copy (_ded ,_eff ._daa [_eff ._fa :]);_eff ._fa +=int64 (_dgg );return _dgg ,nil ;};func (_ee *BufferedWriter )WriteByte (bt byte )error {if _ee ._baa > len (_ee ._bf )-1||(_ee ._baa ==len (_ee ._bf )-1&&_ee ._bc !=0){_ee .expandIfNeeded (1);
};_ee .writeByte (bt );return nil ;};func (_bgfg *Reader )readBool ()(_bgfe bool ,_effe error ){if _bgfg ._daf ==0{_bgfg ._afaf ,_effe =_bgfg .readBufferByte ();if _effe !=nil {return false ,_effe ;};_bgfe =(_bgfg ._afaf &0x80)!=0;_bgfg ._afaf ,_bgfg ._daf =_bgfg ._afaf &0x7f,7;
return _bgfe ,nil ;};_bgfg ._daf --;_bgfe =(_bgfg ._afaf &(1<<_bgfg ._daf ))!=0;_bgfg ._afaf &=1<<_bgfg ._daf -1;return _bgfe ,nil ;};func (_dad *SubstreamReader )readUnalignedByte ()(_adg byte ,_ecad error ){_aaf :=_dad ._ebc ;_adg =_dad ._dedg <<(8-_aaf );
_dad ._dedg ,_ecad =_dad .readBufferByte ();if _ecad !=nil {return 0,_ecad ;};_adg |=_dad ._dedg >>_aaf ;_dad ._dedg &=1<<_aaf -1;return _adg ,nil ;};func (_ac *BufferedWriter )Len ()int {return _ac .byteCapacity ()};func (_dbdg *Writer )byteCapacity ()int {_gfga :=len (_dbdg ._fad )-_dbdg ._gae ;
if _dbdg ._cab !=0{_gfga --;};return _gfga ;};func (_ffg *Reader )Read (p []byte )(_cg int ,_cga error ){if _ffg ._daf ==0{return _ffg .read (p );};for ;_cg < len (p );_cg ++{if p [_cg ],_cga =_ffg .readUnalignedByte ();_cga !=nil {return 0,_cga ;};};return _cg ,nil ;
};func (_aea *SubstreamReader )BitPosition ()int {return int (_aea ._ebc )};func (_gb *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;};_bcb :=int (_gb ._bc )+skip ;if _bcb >=0&&_bcb < 8{_gb ._bc =uint8 (_bcb );return nil ;};_bcb =int (_gb ._bc )+_gb ._baa *8+skip ;
if _bcb < 0{return _ad .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_bae :=_bcb /8;_fcf :=_bcb %8;_gb ._bc =uint8 (_fcf );
if _cd :=_bae -_gb ._baa ;_cd > 0&&len (_gb ._bf )-1< _bae {if _gb ._bc !=0{_cd ++;};_gb .expandIfNeeded (_cd );};_gb ._baa =_bae ;return nil ;};func NewSubstreamReader (r StreamReader ,offset ,length uint64 )(*SubstreamReader ,error ){if r ==nil {return nil ,_f .New ("\u0072o\u006ft\u0020\u0072\u0065\u0061\u0064e\u0072\u0020i\u0073\u0020\u006e\u0069\u006c");
};_g .Log .Trace ("\u004e\u0065\u0077\u0053\u0075\u0062\u0073\u0074r\u0065\u0061\u006dRe\u0061\u0064\u0065\u0072\u0020\u0061t\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u003a\u0020\u0025\u0064\u0020\u0077\u0069\u0074h\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a \u0025\u0064",offset ,length );
return &SubstreamReader {_bff :r ,_dgd :offset ,_geg :length ,_gad :make ([]byte ,length )},nil ;};func (_facg *Writer )ResetBit (){_facg ._cab =0};type BinaryWriter interface{BitWriter ;_bg .Writer ;_bg .ByteWriter ;Data ()[]byte ;};func (_de *Reader )StreamPosition ()int64 {return _de ._fa };
func (_bad *BufferedWriter )expandIfNeeded (_gc int ){if !_bad .tryGrowByReslice (_gc ){_bad .grow (_gc );};};func (_dgb *SubstreamReader )Reset (){_dgb ._fdbg =_dgb ._cfe ;_dgb ._ebc =_dgb ._aba };func NewReader (data []byte )*Reader {return &Reader {_daa :data }};
func (_afb *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _afb .writeBit (uint8 (bit ));};return _ad .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");
};func (_abeb *SubstreamReader )ReadBit ()(_cef int ,_abc error ){_feb ,_abc :=_abeb .readBool ();if _abc !=nil {return 0,_abc ;};if _feb {_cef =1;};return _cef ,nil ;};func (_bfee *SubstreamReader )StreamPosition ()int64 {return int64 (_bfee ._fdbg )};
var _ BinaryWriter =&BufferedWriter {};func (_gf *Reader )Mark (){_gf ._cdf =_gf ._fa ;_gf ._cff =_gf ._daf };func (_ga *Reader )readBufferByte ()(byte ,error ){if _ga ._fa >=int64 (len (_ga ._daa )){return 0,_bg .EOF ;};_ga ._aga =-1;_aeb :=_ga ._daa [_ga ._fa ];
_ga ._fa ++;_ga ._aa =int (_aeb );return _aeb ,nil ;};func (_fabf *SubstreamReader )Length ()uint64 {return _fabf ._geg };func (_ag *BufferedWriter )WriteBits (bits uint64 ,number int )(_cc int ,_af error ){const _dg ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";
if number < 0||number > 64{return 0,_ad .Errorf (_dg ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};_cca :=number /8;if _cca > 0{_ff :=number -_cca *8;for _bb :=_cca -1;_bb >=0;_bb --{_bfe :=byte ((bits >>uint (_bb *8+_ff ))&0xff);if _af =_ag .WriteByte (_bfe );_af !=nil {return _cc ,_ad .Wrapf (_af ,_dg ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_cca -_bb +1);
};};number -=_cca *8;if number ==0{return _cca ,nil ;};};var _ec int ;for _be :=0;_be < number ;_be ++{if _ag ._e {_ec =int ((bits >>uint (number -1-_be ))&0x1);}else {_ec =int (bits &0x1);bits >>=1;};if _af =_ag .WriteBit (_ec );_af !=nil {return _cc ,_ad .Wrapf (_af ,_dg ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_be );
};};return _cca ,nil ;};func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_e :true }};func (_cbf *Reader )Reset (){_cbf ._fa =_cbf ._cdf ;_cbf ._daf =_cbf ._cff };func (_cb *BufferedWriter )Data ()[]byte {return _cb ._bf };func (_aad *SubstreamReader )Seek (offset int64 ,whence int )(int64 ,error ){switch whence {case _bg .SeekStart :_aad ._fdbg =uint64 (offset );
case _bg .SeekCurrent :_aad ._fdbg +=uint64 (offset );case _bg .SeekEnd :_aad ._fdbg =_aad ._geg +uint64 (offset );default:return 0,_f .New ("\u0072\u0065\u0061d\u0065\u0072\u002e\u0053\u0075\u0062\u0073\u0074\u0072\u0065\u0061\u006d\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u0020\u0069\u006e\u0076\u0061\u006ci\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};_aad ._ebc =0;return int64 (_aad ._fdbg ),nil ;};func (_efcg *Writer )SkipBits (skip int )error {const _ebf ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";if skip ==0{return nil ;};_eae :=int (_efcg ._cab )+skip ;
if _eae >=0&&_eae < 8{_efcg ._cab =uint8 (_eae );return nil ;};_eae =int (_efcg ._cab )+_efcg ._gae *8+skip ;if _eae < 0{return _ad .Errorf (_ebf ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_ccd :=_eae /8;
_dec :=_eae %8;_g .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");_g .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_efcg ._cab ,_efcg ._gae ,int (_efcg ._cab )+(_efcg ._gae )*8,len (_efcg ._fad ),cap (_efcg ._fad ));
_g .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_eae ,_dec );_efcg ._cab =uint8 (_dec );if _edg :=_ccd -_efcg ._gae ;
_edg > 0&&len (_efcg ._fad )-1< _ccd {_g .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_edg );return _ad .Errorf (_ebf ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_efcg ._gae =_ccd ;
_g .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_efcg ._cab ,_efcg ._gae );return nil ;};func (_ae *Reader )BitPosition ()int {return int (_ae ._daf )};
func NewWriter (data []byte )*Writer {return &Writer {_fad :data }};func (_cbg *Reader )ReadBits (n byte )(_fac uint64 ,_fcbc error ){if n < _cbg ._daf {_cbea :=_cbg ._daf -n ;_fac =uint64 (_cbg ._afaf >>_cbea );_cbg ._afaf &=1<<_cbea -1;_cbg ._daf =_cbea ;
return _fac ,nil ;};if n > _cbg ._daf {if _cbg ._daf > 0{_fac =uint64 (_cbg ._afaf );n -=_cbg ._daf ;};for n >=8{_bgg ,_abe :=_cbg .readBufferByte ();if _abe !=nil {return 0,_abe ;};_fac =_fac <<8+uint64 (_bgg );n -=8;};if n > 0{if _cbg ._afaf ,_fcbc =_cbg .readBufferByte ();
_fcbc !=nil {return 0,_fcbc ;};_acg :=8-n ;_fac =_fac <<n +uint64 (_cbg ._afaf >>_acg );_cbg ._afaf &=1<<_acg -1;_cbg ._daf =_acg ;}else {_cbg ._daf =0;};return _fac ,nil ;};_cbg ._daf =0;return uint64 (_cbg ._afaf ),nil ;};func (_baab *Reader )ConsumeRemainingBits (){if _baab ._daf !=0{_ ,_ab :=_baab .ReadBits (_baab ._daf );
if _ab !=nil {_g .Log .Debug ("\u0043\u006f\u006e\u0073\u0075\u006d\u0065\u0052\u0065\u006da\u0069\u006e\u0069\u0067\u0042\u0069\u0074s\u0020\u0066\u0061\u0069\u006c\u0065\u0064\u003a\u0020\u0025\u0076",_ab );};};};func (_fab *Reader )ReadBit ()(_cffb int ,_ebe error ){_bgf ,_ebe :=_fab .readBool ();
if _ebe !=nil {return 0,_ebe ;};if _bgf {_cffb =1;};return _cffb ,nil ;};type Reader struct{_daa []byte ;_afaf byte ;_daf byte ;_fa int64 ;_aa int ;_aga int ;_cdf int64 ;_cff byte ;};var _ BinaryWriter =&Writer {};func (_eca *Reader )Length ()uint64 {return uint64 (len (_eca ._daa ))};
func (_ggb *Writer )writeBit (_bfc uint8 )error {if len (_ggb ._fad )-1< _ggb ._gae {return _bg .EOF ;};_aac :=_ggb ._cab ;if _ggb ._gabf {_aac =7-_ggb ._cab ;};_ggb ._fad [_ggb ._gae ]|=byte (uint16 (_bfc <<_aac )&0xff);_ggb ._cab ++;if _ggb ._cab ==8{_ggb ._gae ++;
_ggb ._cab =0;};return nil ;};func (_efc *SubstreamReader )Align ()(_bdc byte ){_bdc =_efc ._ebc ;_efc ._ebc =0;return _bdc };func (_fc *BufferedWriter )Reset (){_fc ._bf =_fc ._bf [:0];_fc ._baa =0;_fc ._bc =0};type SubstreamReader struct{_fdbg uint64 ;
_bff StreamReader ;_dgd uint64 ;_geg uint64 ;_gad []byte ;_dgf uint64 ;_eaf uint64 ;_dedg byte ;_ebc byte ;_cfe uint64 ;_aba byte ;};func (_gcf *Reader )ReadBool ()(bool ,error ){return _gcf .readBool ()};func (_cda *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_cda ._aga =-1;
var _cfa int64 ;switch whence {case _bg .SeekStart :_cfa =offset ;case _bg .SeekCurrent :_cfa =_cda ._fa +offset ;case _bg .SeekEnd :_cfa =int64 (len (_cda ._daa ))+offset ;default:return 0,_f .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};if _cfa < 0{return 0,_f .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");};_cda ._fa =_cfa ;
_cda ._daf =0;return _cfa ,nil ;};func (_eb *BufferedWriter )writeShiftedBytes (_ge []byte )int {for _ ,_age :=range _ge {_eb .writeByte (_age );};return len (_ge );};func (_caf *Writer )Data ()[]byte {return _caf ._fad };func (_dfd *Writer )WriteBits (bits uint64 ,number int )(_agab int ,_gdb error ){const _abb ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";
if number < 0||number > 64{return 0,_ad .Errorf (_abb ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};if number ==0{return 0,nil ;};_gbe :=number /8;if _gbe > 0{_bbgf :=number -_gbe *8;for _ebfd :=_gbe -1;_ebfd >=0;_ebfd --{_ffc :=byte ((bits >>uint (_ebfd *8+_bbgf ))&0xff);if _gdb =_dfd .WriteByte (_ffc );_gdb !=nil {return _agab ,_ad .Wrapf (_gdb ,_abb ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_gbe -_ebfd +1);
};};number -=_gbe *8;if number ==0{return _gbe ,nil ;};};var _agd int ;for _dfbg :=0;_dfbg < number ;_dfbg ++{if _dfd ._gabf {_agd =int ((bits >>uint (number -1-_dfbg ))&0x1);}else {_agd =int (bits &0x1);bits >>=1;};if _gdb =_dfd .WriteBit (_agd );_gdb !=nil {return _agab ,_ad .Wrapf (_gdb ,_abb ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_dfbg );
};};return _gbe ,nil ;};func (_ffa *SubstreamReader )ReadByte ()(byte ,error ){if _ffa ._ebc ==0{return _ffa .readBufferByte ();};return _ffa .readUnalignedByte ();};func (_dgc *Reader )ReadUint32 ()(uint32 ,error ){_bbf :=make ([]byte ,4);_ ,_ecb :=_dgc .Read (_bbf );
if _ecb !=nil {return 0,_ecb ;};return _a .BigEndian .Uint32 (_bbf ),nil ;};var _ _bg .Writer =&BufferedWriter {};func _gecb (_fbd ,_bgfa uint64 )uint64 {if _fbd < _bgfa {return _fbd ;};return _bgfa ;};func (_fe *SubstreamReader )Mark (){_fe ._cfe =_fe ._fdbg ;
_fe ._aba =_fe ._ebc };func (_ea *BufferedWriter )byteCapacity ()int {_fdb :=len (_ea ._bf )-_ea ._baa ;if _ea ._bc !=0{_fdb --;};return _fdb ;};func (_fda *SubstreamReader )Offset ()uint64 {return _fda ._dgd };func (_dae *Writer )WriteByte (c byte )error {return _dae .writeByte (c )};
func (_afa *BufferedWriter )writeFullBytes (_fdg []byte )int {_ca :=copy (_afa ._bf [_afa .fullOffset ():],_fdg );_afa ._baa +=_ca ;return _ca ;};func (_eg *Reader )readUnalignedByte ()(_efa byte ,_dfb error ){_gec :=_eg ._daf ;_efa =_eg ._afaf <<(8-_gec );
_eg ._afaf ,_dfb =_eg .readBufferByte ();if _dfb !=nil {return 0,_dfb ;};_efa |=_eg ._afaf >>_gec ;_eg ._afaf &=1<<_gec -1;return _efa ,nil ;};var (_ _bg .Reader =&Reader {};_ _bg .ByteReader =&Reader {};_ _bg .Seeker =&Reader {};_ StreamReader =&Reader {};
);type BitWriter interface{WriteBit (_efg int )error ;WriteBits (_adc uint64 ,_da int )(_ffee int ,_ed error );FinishByte ();SkipBits (_cbe int )error ;};func (_cabg *Writer )UseMSB ()bool {return _cabg ._gabf };type Writer struct{_fad []byte ;_cab uint8 ;
_gae int ;_gabf bool ;};func (_aae *SubstreamReader )readBufferByte ()(byte ,error ){if _aae ._fdbg >=_aae ._geg {return 0,_bg .EOF ;};if _aae ._fdbg >=_aae ._eaf ||_aae ._fdbg < _aae ._dgf {if _ddc :=_aae .fillBuffer ();_ddc !=nil {return 0,_ddc ;};};
_cdd :=_aae ._gad [_aae ._fdbg -_aae ._dgf ];_aae ._fdbg ++;return _cdd ,nil ;};func (_gea *Writer )writeByte (_fbc byte )error {if _gea ._gae > len (_gea ._fad )-1{return _bg .EOF ;};if _gea ._gae ==len (_gea ._fad )-1&&_gea ._cab !=0{return _bg .EOF ;
};if _gea ._cab ==0{_gea ._fad [_gea ._gae ]=_fbc ;_gea ._gae ++;return nil ;};if _gea ._gabf {_gea ._fad [_gea ._gae ]|=_fbc >>_gea ._cab ;_gea ._gae ++;_gea ._fad [_gea ._gae ]=byte (uint16 (_fbc )<<(8-_gea ._cab )&0xff);}else {_gea ._fad [_gea ._gae ]|=byte (uint16 (_fbc )<<_gea ._cab &0xff);
_gea ._gae ++;_gea ._fad [_gea ._gae ]=_fbc >>(8-_gea ._cab );};return nil ;};func (_gde *Writer )FinishByte (){if _gde ._cab ==0{return ;};_gde ._cab =0;_gde ._gae ++;};func (_ffeee *SubstreamReader )ReadBool ()(bool ,error ){return _ffeee .readBool ()};
func (_eabe *Reader )ReadByte ()(byte ,error ){if _eabe ._daf ==0{return _eabe .readBufferByte ();};return _eabe .readUnalignedByte ();};func (_eaa *Writer )Write (p []byte )(int ,error ){if len (p )> _eaa .byteCapacity (){return 0,_bg .EOF ;};for _ ,_afe :=range p {if _gaf :=_eaa .writeByte (_afe );
_gaf !=nil {return 0,_gaf ;};};return len (p ),nil ;};func (_bd *BufferedWriter )grow (_cf int ){if _bd ._bf ==nil &&_cf < _fd {_bd ._bf =make ([]byte ,_cf ,_fd );return ;};_gg :=len (_bd ._bf );if _bd ._bc !=0{_gg ++;};_ef :=cap (_bd ._bf );switch {case _cf <=_ef /2-_gg :_g .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_bd ._bf ),cap (_bd ._bf ),_cf );
_g .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_ef ,_gg );copy (_bd ._bf ,_bd ._bf [_bd .fullOffset ():]);
case _ef > _ba -_ef -_cf :_g .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_bbe :=make ([]byte ,2*_ef +_cf );copy (_bbe ,_bd ._bf );_bd ._bf =_bbe ;};_bd ._bf =_bd ._bf [:_gg +_cf ];
};var _ _bg .ByteWriter =&BufferedWriter {};func (_add *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _ad .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );
};if len (_add ._bf )-1< _add ._baa {_add .expandIfNeeded (1);};_gbc :=_add ._bc ;if _add ._e {_gbc =7-_add ._bc ;};_add ._bf [_add ._baa ]|=byte (uint16 (bit <<_gbc )&0xff);_add ._bc ++;if _add ._bc ==8{_add ._baa ++;_add ._bc =0;};return nil ;};func (_geda *SubstreamReader )fillBuffer ()error {if uint64 (_geda ._bff .StreamPosition ())!=_geda ._fdbg +_geda ._dgd {_ ,_baae :=_geda ._bff .Seek (int64 (_geda ._fdbg +_geda ._dgd ),_bg .SeekStart );
if _baae !=nil {return _baae ;};};_geda ._dgf =_geda ._fdbg ;_gba :=_gecb (uint64 (len (_geda ._gad )),_geda ._geg -_geda ._fdbg );_bbg :=make ([]byte ,_gba );_gca ,_cae :=_geda ._bff .Read (_bbg );if _cae !=nil {return _cae ;};for _ecc :=uint64 (0);_ecc < _gba ;
_ecc ++{_geda ._gad [_ecc ]=_bbg [_ecc ];};_geda ._eaf =_geda ._dgf +uint64 (_gca );return nil ;};func (_fg *BufferedWriter )FinishByte (){if _fg ._bc ==0{return ;};_fg ._bc =0;_fg ._baa ++;};func (_eab *BufferedWriter )tryGrowByReslice (_gd int )bool {if _cdc :=len (_eab ._bf );
_gd <=cap (_eab ._bf )-_cdc {_eab ._bf =_eab ._bf [:_cdc +_gd ];return true ;};return false ;};func (_gfg *SubstreamReader )ReadBits (n byte )(_bgc uint64 ,_cfab error ){if n < _gfg ._ebc {_daaa :=_gfg ._ebc -n ;_bgc =uint64 (_gfg ._dedg >>_daaa );_gfg ._dedg &=1<<_daaa -1;
_gfg ._ebc =_daaa ;return _bgc ,nil ;};if n > _gfg ._ebc {if _gfg ._ebc > 0{_bgc =uint64 (_gfg ._dedg );n -=_gfg ._ebc ;};var _ged byte ;for n >=8{_ged ,_cfab =_gfg .readBufferByte ();if _cfab !=nil {return 0,_cfab ;};_bgc =_bgc <<8+uint64 (_ged );n -=8;
};if n > 0{if _gfg ._dedg ,_cfab =_gfg .readBufferByte ();_cfab !=nil {return 0,_cfab ;};_ecf :=8-n ;_bgc =_bgc <<n +uint64 (_gfg ._dedg >>_ecf );_gfg ._dedg &=1<<_ecf -1;_gfg ._ebc =_ecf ;}else {_gfg ._ebc =0;};return _bgc ,nil ;};_gfg ._ebc =0;return uint64 (_gfg ._dedg ),nil ;
};func (_bgd *BufferedWriter )ResetBitIndex (){_bgd ._bc =0};func (_cba *SubstreamReader )ReadUint32 ()(uint32 ,error ){_cgag :=make ([]byte ,4);_ ,_dd :=_cba .Read (_cgag );if _dd !=nil {return 0,_dd ;};return _a .BigEndian .Uint32 (_cgag ),nil ;};