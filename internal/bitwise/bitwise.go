//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_fe "encoding/binary";_f "errors";_b "github.com/unidoc/unipdf/v3/common";_bg "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_c "io";);type BinaryWriter interface{BitWriter ;_c .Writer ;_c .ByteWriter ;Data ()[]byte ;};func (_eac *SubstreamReader )ReadUint32 ()(uint32 ,error ){_cga :=make ([]byte ,4);
_ ,_adfb :=_eac .Read (_cga );if _adfb !=nil {return 0,_adfb ;};return _fe .BigEndian .Uint32 (_cga ),nil ;};func (_fbb *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_fbb ._caab =-1;var _gae int64 ;switch whence {case _c .SeekStart :_gae =offset ;
case _c .SeekCurrent :_gae =_fbb ._aa +offset ;case _c .SeekEnd :_gae =int64 (len (_fbb ._aba ))+offset ;default:return 0,_f .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};if _gae < 0{return 0,_f .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");};_fbb ._aa =_gae ;
_fbb ._bc =0;return _gae ,nil ;};func (_agg *Reader )ConsumeRemainingBits (){if _agg ._bc !=0{_ ,_bga :=_agg .ReadBits (_agg ._bc );if _bga !=nil {_b .Log .Debug ("\u0043\u006f\u006e\u0073\u0075\u006d\u0065\u0052\u0065\u006da\u0069\u006e\u0069\u0067\u0042\u0069\u0074s\u0020\u0066\u0061\u0069\u006c\u0065\u0064\u003a\u0020\u0025\u0076",_bga );
};};};type BufferedWriter struct{_fc []byte ;_ac uint8 ;_fcc int ;_cb bool ;};func (_abb *Reader )Mark (){_abb ._dgb =_abb ._aa ;_abb ._gdb =_abb ._bc };func (_bcf *SubstreamReader )Length ()uint64 {return _bcf ._cfae };func (_cbc *SubstreamReader )Reset (){_cbc ._cfa =_cbc ._ea ;
_cbc ._gf =_cbc ._ffe };func (_ceb *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _ceb .writeBit (uint8 (bit ));};return _bg .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");
};func (_cedf *Writer )ResetBit (){_cedf ._ggde =0};func (_d *BufferedWriter )FinishByte (){if _d ._ac ==0{return ;};_d ._ac =0;_d ._fcc ++;};func NewWriterMSB (data []byte )*Writer {return &Writer {_gbd :data ,_fef :true }};func NewReader (data []byte )*Reader {return &Reader {_aba :data }};
func (_ced *SubstreamReader )readUnalignedByte ()(_beg byte ,_fad error ){_gca :=_ced ._gf ;_beg =_ced ._ggc <<(8-_gca );_ced ._ggc ,_fad =_ced .readBufferByte ();if _fad !=nil {return 0,_fad ;};_beg |=_ced ._ggc >>_gca ;_ced ._ggc &=1<<_gca -1;return _beg ,nil ;
};func (_ddd *BufferedWriter )tryGrowByReslice (_gcc int )bool {if _adf :=len (_ddd ._fc );_gcc <=cap (_ddd ._fc )-_adf {_ddd ._fc =_ddd ._fc [:_adf +_gcc ];return true ;};return false ;};func (_ecgf *Writer )FinishByte (){if _ecgf ._ggde ==0{return ;};
_ecgf ._ggde =0;_ecgf ._bba ++;};func (_baf *Reader )readBool ()(_aca bool ,_beec error ){if _baf ._bc ==0{_baf ._ggd ,_beec =_baf .readBufferByte ();if _beec !=nil {return false ,_beec ;};_aca =(_baf ._ggd &0x80)!=0;_baf ._ggd ,_baf ._bc =_baf ._ggd &0x7f,7;
return _aca ,nil ;};_baf ._bc --;_aca =(_baf ._ggd &(1<<_baf ._bc ))!=0;_baf ._ggd &=1<<_baf ._bc -1;return _aca ,nil ;};var _ _c .Writer =&BufferedWriter {};func (_aae *SubstreamReader )readBufferByte ()(byte ,error ){if _aae ._cfa >=_aae ._cfae {return 0,_c .EOF ;
};if _aae ._cfa >=_aae ._ggfd ||_aae ._cfa < _aae ._gafb {if _afe :=_aae .fillBuffer ();_afe !=nil {return 0,_afe ;};};_dbg :=_aae ._bb [_aae ._cfa -_aae ._gafb ];_aae ._cfa ++;return _dbg ,nil ;};type SubstreamReader struct{_cfa uint64 ;_bdg StreamReader ;
_aeb uint64 ;_cfae uint64 ;_bb []byte ;_gafb uint64 ;_ggfd uint64 ;_ggc byte ;_gf byte ;_ea uint64 ;_ffe byte ;};func (_ggb *Reader )ReadBits (n byte )(_feee uint64 ,_ee error ){if n < _ggb ._bc {_bed :=_ggb ._bc -n ;_feee =uint64 (_ggb ._ggd >>_bed );
_ggb ._ggd &=1<<_bed -1;_ggb ._bc =_bed ;return _feee ,nil ;};if n > _ggb ._bc {if _ggb ._bc > 0{_feee =uint64 (_ggb ._ggd );n -=_ggb ._bc ;};for n >=8{_fabb ,_eb :=_ggb .readBufferByte ();if _eb !=nil {return 0,_eb ;};_feee =_feee <<8+uint64 (_fabb );
n -=8;};if n > 0{if _ggb ._ggd ,_ee =_ggb .readBufferByte ();_ee !=nil {return 0,_ee ;};_af :=8-n ;_feee =_feee <<n +uint64 (_ggb ._ggd >>_af );_ggb ._ggd &=1<<_af -1;_ggb ._bc =_af ;}else {_ggb ._bc =0;};return _feee ,nil ;};_ggb ._bc =0;return uint64 (_ggb ._ggd ),nil ;
};func (_cdc *SubstreamReader )StreamPosition ()int64 {return int64 (_cdc ._cfa )};type Reader struct{_aba []byte ;_ggd byte ;_bc byte ;_aa int64 ;_bee int ;_caab int ;_dgb int64 ;_gdb byte ;};func (_dec *Writer )writeBit (_bbf uint8 )error {if len (_dec ._gbd )-1< _dec ._bba {return _c .EOF ;
};_dcd :=_dec ._ggde ;if _dec ._fef {_dcd =7-_dec ._ggde ;};_dec ._gbd [_dec ._bba ]|=byte (uint16 (_bbf <<_dcd )&0xff);_dec ._ggde ++;if _dec ._ggde ==8{_dec ._bba ++;_dec ._ggde =0;};return nil ;};func (_dc *BufferedWriter )expandIfNeeded (_cee int ){if !_dc .tryGrowByReslice (_cee ){_dc .grow (_cee );
};};func (_eacf *Writer )Data ()[]byte {return _eacf ._gbd };func (_gdfd *Writer )SkipBits (skip int )error {const _daea ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";if skip ==0{return nil ;};_cgb :=int (_gdfd ._ggde )+skip ;
if _cgb >=0&&_cgb < 8{_gdfd ._ggde =uint8 (_cgb );return nil ;};_cgb =int (_gdfd ._ggde )+_gdfd ._bba *8+skip ;if _cgb < 0{return _bg .Errorf (_daea ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_bcd :=_cgb /8;
_dad :=_cgb %8;_b .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");_b .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_gdfd ._ggde ,_gdfd ._bba ,int (_gdfd ._ggde )+(_gdfd ._bba )*8,len (_gdfd ._gbd ),cap (_gdfd ._gbd ));
_b .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_cgb ,_dad );_gdfd ._ggde =uint8 (_dad );if _dbde :=_bcd -_gdfd ._bba ;
_dbde > 0&&len (_gdfd ._gbd )-1< _bcd {_b .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_dbde );return _bg .Errorf (_daea ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_gdfd ._bba =_bcd ;_b .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_gdfd ._ggde ,_gdfd ._bba );return nil ;};
func NewWriter (data []byte )*Writer {return &Writer {_gbd :data }};func (_baa *Reader )read (_fcbb []byte )(int ,error ){if _baa ._aa >=int64 (len (_baa ._aba )){return 0,_c .EOF ;};_baa ._caab =-1;_dab :=copy (_fcbb ,_baa ._aba [_baa ._aa :]);_baa ._aa +=int64 (_dab );
return _dab ,nil ;};func (_cea *SubstreamReader )readBool ()(_cfc bool ,_bgc error ){if _cea ._gf ==0{_cea ._ggc ,_bgc =_cea .readBufferByte ();if _bgc !=nil {return false ,_bgc ;};_cfc =(_cea ._ggc &0x80)!=0;_cea ._ggc ,_cea ._gf =_cea ._ggc &0x7f,7;return _cfc ,nil ;
};_cea ._gf --;_cfc =(_cea ._ggc &(1<<_cea ._gf ))!=0;_cea ._ggc &=1<<_cea ._gf -1;return _cfc ,nil ;};func (_ccf *Writer )byteCapacity ()int {_faf :=len (_ccf ._gbd )-_ccf ._bba ;if _ccf ._ggde !=0{_faf --;};return _faf ;};func (_ceg *SubstreamReader )Read (b []byte )(_cfb int ,_bac error ){if _ceg ._cfa >=_ceg ._cfae {_b .Log .Trace ("\u0053\u0074\u0072e\u0061\u006d\u0050\u006fs\u003a\u0020\u0027\u0025\u0064\u0027\u0020>\u003d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027",_ceg ._cfa ,_ceg ._cfae );
return 0,_c .EOF ;};for ;_cfb < len (b );_cfb ++{if b [_cfb ],_bac =_ceg .readUnalignedByte ();_bac !=nil {if _bac ==_c .EOF {return _cfb ,nil ;};return 0,_bac ;};};return _cfb ,nil ;};func (_ef *SubstreamReader )ReadBits (n byte )(_ffee uint64 ,_fce error ){if n < _ef ._gf {_ece :=_ef ._gf -n ;
_ffee =uint64 (_ef ._ggc >>_ece );_ef ._ggc &=1<<_ece -1;_ef ._gf =_ece ;return _ffee ,nil ;};if n > _ef ._gf {if _ef ._gf > 0{_ffee =uint64 (_ef ._ggc );n -=_ef ._gf ;};var _daef byte ;for n >=8{_daef ,_fce =_ef .readBufferByte ();if _fce !=nil {return 0,_fce ;
};_ffee =_ffee <<8+uint64 (_daef );n -=8;};if n > 0{if _ef ._ggc ,_fce =_ef .readBufferByte ();_fce !=nil {return 0,_fce ;};_ffa :=8-n ;_ffee =_ffee <<n +uint64 (_ef ._ggc >>_ffa );_ef ._ggc &=1<<_ffa -1;_ef ._gf =_ffa ;}else {_ef ._gf =0;};return _ffee ,nil ;
};_ef ._gf =0;return uint64 (_ef ._ggc ),nil ;};func (_cde *Reader )ReadUint32 ()(uint32 ,error ){_age :=make ([]byte ,4);_ ,_ge :=_cde .Read (_age );if _ge !=nil {return 0,_ge ;};return _fe .BigEndian .Uint32 (_age ),nil ;};type StreamReader interface{_c .Reader ;
_c .ByteReader ;_c .Seeker ;Align ()byte ;BitPosition ()int ;Mark ();Length ()uint64 ;ReadBit ()(int ,error );ReadBits (_dcc byte )(uint64 ,error );ReadBool ()(bool ,error );ReadUint32 ()(uint32 ,error );Reset ();StreamPosition ()int64 ;};func (_dbe *BufferedWriter )writeShiftedBytes (_dd []byte )int {for _ ,_dgc :=range _dd {_dbe .writeByte (_dgc );
};return len (_dd );};func (_g *BufferedWriter )Write (d []byte )(int ,error ){_g .expandIfNeeded (len (d ));if _g ._ac ==0{return _g .writeFullBytes (d ),nil ;};return _g .writeShiftedBytes (d ),nil ;};func (_acg *Reader )StreamPosition ()int64 {return _acg ._aa };
func (_adg *Reader )Reset (){_adg ._aa =_adg ._dgb ;_adg ._bc =_adg ._gdb };func (_bgfc *BufferedWriter )WriteBits (bits uint64 ,number int )(_gc int ,_bf error ){const _cd ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";
if number < 0||number > 64{return 0,_bg .Errorf (_cd ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};_cab :=number /8;if _cab > 0{_ec :=number -_cab *8;for _da :=_cab -1;_da >=0;_da --{_fae :=byte ((bits >>uint (_da *8+_ec ))&0xff);if _bf =_bgfc .WriteByte (_fae );_bf !=nil {return _gc ,_bg .Wrapf (_bf ,_cd ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_cab -_da +1);
};};number -=_cab *8;if number ==0{return _cab ,nil ;};};var _caa int ;for _gd :=0;_gd < number ;_gd ++{if _bgfc ._cb {_caa =int ((bits >>uint (number -1-_gd ))&0x1);}else {_caa =int (bits &0x1);bits >>=1;};if _bf =_bgfc .WriteBit (_caa );_bf !=nil {return _gc ,_bg .Wrapf (_bf ,_cd ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_gd );
};};return _cab ,nil ;};var _ BinaryWriter =&BufferedWriter {};func (_add *Writer )UseMSB ()bool {return _add ._fef };func NewSubstreamReader (r StreamReader ,offset ,length uint64 )(*SubstreamReader ,error ){if r ==nil {return nil ,_f .New ("\u0072o\u006ft\u0020\u0072\u0065\u0061\u0064e\u0072\u0020i\u0073\u0020\u006e\u0069\u006c");
};_b .Log .Trace ("\u004e\u0065\u0077\u0053\u0075\u0062\u0073\u0074r\u0065\u0061\u006dRe\u0061\u0064\u0065\u0072\u0020\u0061t\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u003a\u0020\u0025\u0064\u0020\u0077\u0069\u0074h\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a \u0025\u0064",offset ,length );
return &SubstreamReader {_bdg :r ,_aeb :offset ,_cfae :length ,_bb :make ([]byte ,length )},nil ;};func (_dg *BufferedWriter )writeFullBytes (_ggg []byte )int {_cabb :=copy (_dg ._fc [_dg .fullOffset ():],_ggg );_dg ._fcc +=_cabb ;return _cabb ;};type BitWriter interface{WriteBit (_bff int )error ;
WriteBits (_ceec uint64 ,_gdf int )(_fab int ,_ff error );FinishByte ();SkipBits (_ade int )error ;};func (_fegb *SubstreamReader )Offset ()uint64 {return _fegb ._aeb };func (_bafe *SubstreamReader )Seek (offset int64 ,whence int )(int64 ,error ){switch whence {case _c .SeekStart :_bafe ._cfa =uint64 (offset );
case _c .SeekCurrent :_bafe ._cfa +=uint64 (offset );case _c .SeekEnd :_bafe ._cfa =_bafe ._cfae +uint64 (offset );default:return 0,_f .New ("\u0072\u0065\u0061d\u0065\u0072\u002e\u0053\u0075\u0062\u0073\u0074\u0072\u0065\u0061\u006d\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u0020\u0069\u006e\u0076\u0061\u006ci\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};_bafe ._gf =0;return int64 (_bafe ._cfa ),nil ;};func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_cb :true }};func (_ded *SubstreamReader )fillBuffer ()error {if uint64 (_ded ._bdg .StreamPosition ())!=_ded ._cfa +_ded ._aeb {_ ,_bbd :=_ded ._bdg .Seek (int64 (_ded ._cfa +_ded ._aeb ),_c .SeekStart );
if _bbd !=nil {return _bbd ;};};_ded ._gafb =_ded ._cfa ;_aad :=_ecf (uint64 (len (_ded ._bb )),_ded ._cfae -_ded ._cfa );_dca :=make ([]byte ,_aad );_dfa ,_beeb :=_ded ._bdg .Read (_dca );if _beeb !=nil {return _beeb ;};for _ccbf :=uint64 (0);_ccbf < _aad ;
_ccbf ++{_ded ._bb [_ccbf ]=_dca [_ccbf ];};_ded ._ggfd =_ded ._gafb +uint64 (_dfa );return nil ;};func (_gb *Reader )ReadByte ()(byte ,error ){if _gb ._bc ==0{return _gb .readBufferByte ();};return _gb .readUnalignedByte ();};func (_cfdc *Writer )WriteByte (c byte )error {return _cfdc .writeByte (c )};
func (_gce *Reader )readBufferByte ()(byte ,error ){if _gce ._aa >=int64 (len (_gce ._aba )){return 0,_c .EOF ;};_gce ._caab =-1;_bffg :=_gce ._aba [_gce ._aa ];_gce ._aa ++;_gce ._bee =int (_bffg );return _bffg ,nil ;};var _ _c .ByteWriter =&BufferedWriter {};
func _ecf (_dfaf ,_aeg uint64 )uint64 {if _dfaf < _aeg {return _dfaf ;};return _aeg ;};const (_ce =64;_be =int (^uint (0)>>1););func (_dede *Writer )WriteBits (bits uint64 ,number int )(_fcd int ,_bfe error ){const _afa ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";
if number < 0||number > 64{return 0,_bg .Errorf (_afa ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};if number ==0{return 0,nil ;};_gadb :=number /8;if _gadb > 0{_fabbf :=number -_gadb *8;for _geg :=_gadb -1;_geg >=0;_geg --{_ddg :=byte ((bits >>uint (_geg *8+_fabbf ))&0xff);if _bfe =_dede .WriteByte (_ddg );_bfe !=nil {return _fcd ,_bg .Wrapf (_bfe ,_afa ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_gadb -_geg +1);
};};number -=_gadb *8;if number ==0{return _gadb ,nil ;};};var _afea int ;for _gcf :=0;_gcf < number ;_gcf ++{if _dede ._fef {_afea =int ((bits >>uint (number -1-_gcf ))&0x1);}else {_afea =int (bits &0x1);bits >>=1;};if _bfe =_dede .WriteBit (_afea );_bfe !=nil {return _fcd ,_bg .Wrapf (_bfe ,_afa ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_gcf );
};};return _gadb ,nil ;};func (_eag *SubstreamReader )ReadByte ()(byte ,error ){if _eag ._gf ==0{return _eag .readBufferByte ();};return _eag .readUnalignedByte ();};var _ BinaryWriter =&Writer {};func (_gda *SubstreamReader )ReadBool ()(bool ,error ){return _gda .readBool ()};
func (_adfd *Reader )Read (p []byte )(_bde int ,_bcb error ){if _adfd ._bc ==0{return _adfd .read (p );};for ;_bde < len (p );_bde ++{if p [_bde ],_bcb =_adfd .readUnalignedByte ();_bcb !=nil {return 0,_bcb ;};};return _bde ,nil ;};func (_agb *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _bg .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );
};if len (_agb ._fc )-1< _agb ._fcc {_agb .expandIfNeeded (1);};_cef :=_agb ._ac ;if _agb ._cb {_cef =7-_agb ._ac ;};_agb ._fc [_agb ._fcc ]|=byte (uint16 (bit <<_cef )&0xff);_agb ._ac ++;if _agb ._ac ==8{_agb ._fcc ++;_agb ._ac =0;};return nil ;};func (_gg *BufferedWriter )WriteByte (bt byte )error {if _gg ._fcc > len (_gg ._fc )-1||(_gg ._fcc ==len (_gg ._fc )-1&&_gg ._ac !=0){_gg .expandIfNeeded (1);
};_gg .writeByte (bt );return nil ;};func (_db *BufferedWriter )grow (_eg int ){if _db ._fc ==nil &&_eg < _ce {_db ._fc =make ([]byte ,_eg ,_ce );return ;};_ad :=len (_db ._fc );if _db ._ac !=0{_ad ++;};_feg :=cap (_db ._fc );switch {case _eg <=_feg /2-_ad :_b .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_db ._fc ),cap (_db ._fc ),_eg );
_b .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_feg ,_ad );copy (_db ._fc ,_db ._fc [_db .fullOffset ():]);
case _feg > _be -_feg -_eg :_b .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_ecg :=make ([]byte ,2*_feg +_eg );copy (_ecg ,_db ._fc );_db ._fc =_ecg ;};_db ._fc =_db ._fc [:_ad +_eg ];
};var (_ _c .Reader =&Reader {};_ _c .ByteReader =&Reader {};_ _c .Seeker =&Reader {};_ StreamReader =&Reader {};);func (_bgf *BufferedWriter )Reset (){_bgf ._fc =_bgf ._fc [:0];_bgf ._fcc =0;_bgf ._ac =0};func (_fg *SubstreamReader )BitPosition ()int {return int (_fg ._gf )};
func (_gbb *SubstreamReader )Align ()(_dbed byte ){_dbed =_gbb ._gf ;_gbb ._gf =0;return _dbed };func (_bd *BufferedWriter )Len ()int {return _bd .byteCapacity ()};func (_df *Reader )BitPosition ()int {return int (_df ._bc )};func (_agd *SubstreamReader )Mark (){_agd ._ea =_agd ._cfa ;
_agd ._ffe =_agd ._gf };type Writer struct{_gbd []byte ;_ggde uint8 ;_bba int ;_fef bool ;};func (_gaa *Reader )ReadBool ()(bool ,error ){return _gaa .readBool ()};func (_dcb *BufferedWriter )fullOffset ()int {_cg :=_dcb ._fcc ;if _dcb ._ac !=0{_cg ++;
};return _cg ;};func (_fee *BufferedWriter )Data ()[]byte {return _fee ._fc };func (_de *Reader )ReadBit ()(_bgb int ,_gaf error ){_agc ,_gaf :=_de .readBool ();if _gaf !=nil {return 0,_gaf ;};if _agc {_bgb =1;};return _bgb ,nil ;};func (_eced *Writer )writeByte (_eba byte )error {if _eced ._bba > len (_eced ._gbd )-1{return _c .EOF ;
};if _eced ._bba ==len (_eced ._gbd )-1&&_eced ._ggde !=0{return _c .EOF ;};if _eced ._ggde ==0{_eced ._gbd [_eced ._bba ]=_eba ;_eced ._bba ++;return nil ;};if _eced ._fef {_eced ._gbd [_eced ._bba ]|=_eba >>_eced ._ggde ;_eced ._bba ++;_eced ._gbd [_eced ._bba ]=byte (uint16 (_eba )<<(8-_eced ._ggde )&0xff);
}else {_eced ._gbd [_eced ._bba ]|=byte (uint16 (_eba )<<_eced ._ggde &0xff);_eced ._bba ++;_eced ._gbd [_eced ._bba ]=_eba >>(8-_eced ._ggde );};return nil ;};func (_abe *BufferedWriter )byteCapacity ()int {_ggf :=len (_abe ._fc )-_abe ._fcc ;if _abe ._ac !=0{_ggf --;
};return _ggf ;};func (_cbg *SubstreamReader )ReadBit ()(_cgg int ,_dfe error ){_dae ,_dfe :=_cbg .readBool ();if _dfe !=nil {return 0,_dfe ;};if _dae {_cgg =1;};return _cgg ,nil ;};func (_gab *Reader )Length ()uint64 {return uint64 (len (_gab ._aba ))};
func (_cbbd *Writer )Write (p []byte )(int ,error ){if len (p )> _cbbd .byteCapacity (){return 0,_c .EOF ;};for _ ,_eca :=range p {if _eff :=_cbbd .writeByte (_eca );_eff !=nil {return 0,_eff ;};};return len (p ),nil ;};func (_fa *BufferedWriter )ResetBitIndex (){_fa ._ac =0};
func (_bec *Reader )readUnalignedByte ()(_gad byte ,_fba error ){_acc :=_bec ._bc ;_gad =_bec ._ggd <<(8-_acc );_bec ._ggd ,_fba =_bec .readBufferByte ();if _fba !=nil {return 0,_fba ;};_gad |=_bec ._ggd >>_acc ;_bec ._ggd &=1<<_acc -1;return _gad ,nil ;
};func (_ga *BufferedWriter )writeByte (_bdf byte ){switch {case _ga ._ac ==0:_ga ._fc [_ga ._fcc ]=_bdf ;_ga ._fcc ++;case _ga ._cb :_ga ._fc [_ga ._fcc ]|=_bdf >>_ga ._ac ;_ga ._fcc ++;_ga ._fc [_ga ._fcc ]=byte (uint16 (_bdf )<<(8-_ga ._ac )&0xff);default:_ga ._fc [_ga ._fcc ]|=byte (uint16 (_bdf )<<_ga ._ac &0xff);
_ga ._fcc ++;_ga ._fc [_ga ._fcc ]=_bdf >>(8-_ga ._ac );};};func (_dbd *Reader )Align ()(_cfd byte ){_cfd =_dbd ._bc ;_dbd ._bc =0;return _cfd };func (_e *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;};_ag :=int (_e ._ac )+skip ;if _ag >=0&&_ag < 8{_e ._ac =uint8 (_ag );
return nil ;};_ag =int (_e ._ac )+_e ._fcc *8+skip ;if _ag < 0{return _bg .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_fd :=_ag /8;_fb :=_ag %8;_e ._ac =uint8 (_fb );if _ab :=_fd -_e ._fcc ;_ab > 0&&len (_e ._fc )-1< _fd {if _e ._ac !=0{_ab ++;};_e .expandIfNeeded (_ab );};_e ._fcc =_fd ;return nil ;};