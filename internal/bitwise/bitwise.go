//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_c "encoding/binary";_d "errors";_ed "github.com/unidoc/unipdf/v3/common";_ce "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_e "io";);func (_ag *BufferedWriter )ResetBitIndex (){_ag ._b =0};func (_df *Reader )Mark (){_df ._cag =_df ._gd ;_df ._afd =_df ._dcc };func (_bba *BufferedWriter )expandIfNeeded (_cd int ){if !_bba .tryGrowByReslice (_cd ){_bba .grow (_cd );};};func (_fgb *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _fgb .writeBit (uint8 (bit ));};return _ce .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");};func (_fdf *SubstreamReader )readBool ()(_dba bool ,_cgb error ){if _fdf ._gb ==0{_fdf ._eee ,_cgb =_fdf .readBufferByte ();if _cgb !=nil {return false ,_cgb ;};_dba =(_fdf ._eee &0x80)!=0;_fdf ._eee ,_fdf ._gb =_fdf ._eee &0x7f,7;return _dba ,nil ;};_fdf ._gb --;_dba =(_fdf ._eee &(1<<_fdf ._gb ))!=0;_fdf ._eee &=1<<_fdf ._gb -1;return _dba ,nil ;};func (_af *BufferedWriter )Data ()[]byte {return _af ._gg };func (_adc *Reader )ReadBit ()(_cc int ,_gee error ){_aba ,_gee :=_adc .readBool ();if _gee !=nil {return 0,_gee ;};if _aba {_cc =1;};return _cc ,nil ;};type Reader struct{_aff []byte ;_efa byte ;_dcc byte ;_gd int64 ;_acg int ;_gae int ;_cag int64 ;_afd byte ;};func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_dg :true }};func (_cbc *BufferedWriter )Reset (){_cbc ._gg =_cbc ._gg [:0];_cbc ._bb =0;_cbc ._b =0};func (_gdc *Reader )Align ()(_aaa byte ){_aaa =_gdc ._dcc ;_gdc ._dcc =0;return _aaa };func (_efdb *BufferedWriter )writeFullBytes (_dc []byte )int {_bef :=copy (_efdb ._gg [_efdb .fullOffset ():],_dc );_efdb ._bb +=_bef ;return _bef ;};func (_dcf *SubstreamReader )readBufferByte ()(byte ,error ){if _dcf ._eg >=_dcf ._efbd {return 0,_e .EOF ;};if _dcf ._eg >=_dcf ._ggf ||_dcf ._eg < _dcf ._fec {if _cgbc :=_dcf .fillBuffer ();_cgbc !=nil {return 0,_cgbc ;};};_faf :=_dcf ._cac [_dcf ._eg -_dcf ._fec ];_dcf ._eg ++;return _faf ,nil ;};func NewReader (data []byte )*Reader {return &Reader {_aff :data }};type BufferedWriter struct{_gg []byte ;_b uint8 ;_bb int ;_dg bool ;};func (_dad *Writer )WriteByte (c byte )error {return _dad .writeByte (c )};func (_efb *Reader )ReadByte ()(byte ,error ){if _efb ._dcc ==0{return _efb .readBufferByte ();};return _efb .readUnalignedByte ();};func (_ca *BufferedWriter )grow (_efd int ){if _ca ._gg ==nil &&_efd < _cb {_ca ._gg =make ([]byte ,_efd ,_cb );return ;};_fcd :=len (_ca ._gg );if _ca ._b !=0{_fcd ++;};_cab :=cap (_ca ._gg );switch {case _efd <=_cab /2-_fcd :_ed .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_ca ._gg ),cap (_ca ._gg ),_efd );_ed .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_cab ,_fcd );copy (_ca ._gg ,_ca ._gg [_ca .fullOffset ():]);case _cab > _ae -_cab -_efd :_ed .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_ab :=make ([]byte ,2*_cab +_efd );copy (_ab ,_ca ._gg );_ca ._gg =_ab ;};_ca ._gg =_ca ._gg [:_fcd +_efd ];};func (_ced *Writer )WriteBits (bits uint64 ,number int )(_gcg int ,_fbca error ){const _gfeb ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";if number < 0||number > 64{return 0,_ce .Errorf (_gfeb ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );};if number ==0{return 0,nil ;};_bgd :=number /8;if _bgd > 0{_aag :=number -_bgd *8;for _fbce :=_bgd -1;_fbce >=0;_fbce --{_aadf :=byte ((bits >>uint (_fbce *8+_aag ))&0xff);if _fbca =_ced .WriteByte (_aadf );_fbca !=nil {return _gcg ,_ce .Wrapf (_fbca ,_gfeb ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_bgd -_fbce +1);};};number -=_bgd *8;if number ==0{return _bgd ,nil ;};};var _cgd int ;for _ead :=0;_ead < number ;_ead ++{if _ced ._bee {_cgd =int ((bits >>uint (number -1-_ead ))&0x1);}else {_cgd =int (bits &0x1);bits >>=1;};if _fbca =_ced .WriteBit (_cgd );_fbca !=nil {return _gcg ,_ce .Wrapf (_fbca ,_gfeb ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_ead );};};return _bgd ,nil ;};func (_ddd *SubstreamReader )readUnalignedByte ()(_bbfc byte ,_afdf error ){_eed :=_ddd ._gb ;_bbfc =_ddd ._eee <<(8-_eed );_ddd ._eee ,_afdf =_ddd .readBufferByte ();if _afdf !=nil {return 0,_afdf ;};_bbfc |=_ddd ._eee >>_eed ;_ddd ._eee &=1<<_eed -1;return _bbfc ,nil ;};func (_dae *Writer )byteCapacity ()int {_gbf :=len (_dae ._dfd )-_dae ._caac ;if _dae ._gcf !=0{_gbf --;};return _gbf ;};type StreamReader interface{_e .Reader ;_e .ByteReader ;_e .Seeker ;Align ()byte ;BitPosition ()int ;Mark ();Length ()uint64 ;ReadBit ()(int ,error );ReadBits (_bdg byte )(uint64 ,error );ReadBool ()(bool ,error );ReadUint32 ()(uint32 ,error );Reset ();StreamPosition ()int64 ;};var _ BinaryWriter =&BufferedWriter {};func (_acc *SubstreamReader )ReadBool ()(bool ,error ){return _acc .readBool ()};func (_beeb *Writer )writeBit (_eeef uint8 )error {if len (_beeb ._dfd )-1< _beeb ._caac {return _e .EOF ;};_bbc :=_beeb ._gcf ;if _beeb ._bee {_bbc =7-_beeb ._gcf ;};_beeb ._dfd [_beeb ._caac ]|=byte (uint16 (_eeef <<_bbc )&0xff);_beeb ._gcf ++;if _beeb ._gcf ==8{_beeb ._caac ++;_beeb ._gcf =0;};return nil ;};func (_aacf *SubstreamReader )Read (b []byte )(_bdf int ,_cdd error ){if _aacf ._eg >=_aacf ._efbd {_ed .Log .Trace ("\u0053\u0074\u0072e\u0061\u006d\u0050\u006fs\u003a\u0020\u0027\u0025\u0064\u0027\u0020>\u003d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027",_aacf ._eg ,_aacf ._efbd );return 0,_e .EOF ;};for ;_bdf < len (b );_bdf ++{if b [_bdf ],_cdd =_aacf .readUnalignedByte ();_cdd !=nil {if _cdd ==_e .EOF {return _bdf ,nil ;};return 0,_cdd ;};};return _bdf ,nil ;};func (_ada *Writer )Data ()[]byte {return _ada ._dfd };func (_dd *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_dd ._gae =-1;var _fgf int64 ;switch whence {case _e .SeekStart :_fgf =offset ;case _e .SeekCurrent :_fgf =_dd ._gd +offset ;case _e .SeekEnd :_fgf =int64 (len (_dd ._aff ))+offset ;default:return 0,_d .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");};if _fgf < 0{return 0,_d .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");};_dd ._gd =_fgf ;_dd ._dcc =0;return _fgf ,nil ;};func (_fee *Reader )ReadBits (n byte )(_geb uint64 ,_cbg error ){if n < _fee ._dcc {_acbb :=_fee ._dcc -n ;_geb =uint64 (_fee ._efa >>_acbb );_fee ._efa &=1<<_acbb -1;_fee ._dcc =_acbb ;return _geb ,nil ;};if n > _fee ._dcc {if _fee ._dcc > 0{_geb =uint64 (_fee ._efa );n -=_fee ._dcc ;};for n >=8{_feef ,_aad :=_fee .readBufferByte ();if _aad !=nil {return 0,_aad ;};_geb =_geb <<8+uint64 (_feef );n -=8;};if n > 0{if _fee ._efa ,_cbg =_fee .readBufferByte ();_cbg !=nil {return 0,_cbg ;};_dgfb :=8-n ;_geb =_geb <<n +uint64 (_fee ._efa >>_dgfb );_fee ._efa &=1<<_dgfb -1;_fee ._dcc =_dgfb ;}else {_fee ._dcc =0;};return _geb ,nil ;};_fee ._dcc =0;return uint64 (_fee ._efa ),nil ;};func (_ee *BufferedWriter )writeByte (_aeb byte ){switch {case _ee ._b ==0:_ee ._gg [_ee ._bb ]=_aeb ;_ee ._bb ++;case _ee ._dg :_ee ._gg [_ee ._bb ]|=_aeb >>_ee ._b ;_ee ._bb ++;_ee ._gg [_ee ._bb ]=byte (uint16 (_aeb )<<(8-_ee ._b )&0xff);default:_ee ._gg [_ee ._bb ]|=byte (uint16 (_aeb )<<_ee ._b &0xff);_ee ._bb ++;_ee ._gg [_ee ._bb ]=_aeb >>(8-_ee ._b );};};func NewSubstreamReader (r StreamReader ,offset ,length uint64 )(*SubstreamReader ,error ){if r ==nil {return nil ,_d .New ("\u0072o\u006ft\u0020\u0072\u0065\u0061\u0064e\u0072\u0020i\u0073\u0020\u006e\u0069\u006c");};_ed .Log .Trace ("\u004e\u0065\u0077\u0053\u0075\u0062\u0073\u0074r\u0065\u0061\u006dRe\u0061\u0064\u0065\u0072\u0020\u0061t\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u003a\u0020\u0025\u0064\u0020\u0077\u0069\u0074h\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a \u0025\u0064",offset ,length );return &SubstreamReader {_aadd :r ,_ace :offset ,_efbd :length ,_cac :make ([]byte ,length )},nil ;};func (_cf *Reader )readBufferByte ()(byte ,error ){if _cf ._gd >=int64 (len (_cf ._aff )){return 0,_e .EOF ;};_cf ._gae =-1;_afc :=_cf ._aff [_cf ._gd ];_cf ._gd ++;_cf ._acg =int (_afc );return _afc ,nil ;};func (_cde *Writer )FinishByte (){if _cde ._gcf ==0{return ;};_cde ._gcf =0;_cde ._caac ++;};func (_abd *Reader )Length ()uint64 {return uint64 (len (_abd ._aff ))};func (_bd *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;};_ga :=int (_bd ._b )+skip ;if _ga >=0&&_ga < 8{_bd ._b =uint8 (_ga );return nil ;};_ga =int (_bd ._b )+_bd ._bb *8+skip ;if _ga < 0{return _ce .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_be :=_ga /8;_ad :=_ga %8;_bd ._b =uint8 (_ad );if _dgf :=_be -_bd ._bb ;_dgf > 0&&len (_bd ._gg )-1< _be {if _bd ._b !=0{_dgf ++;};_bd .expandIfNeeded (_dgf );};_bd ._bb =_be ;return nil ;};func (_gac *SubstreamReader )fillBuffer ()error {if uint64 (_gac ._aadd .StreamPosition ())!=_gac ._eg +_gac ._ace {_ ,_cce :=_gac ._aadd .Seek (int64 (_gac ._eg +_gac ._ace ),_e .SeekStart );if _cce !=nil {return _cce ;};};_gac ._fec =_gac ._eg ;_aceg :=_ggdb (uint64 (len (_gac ._cac )),_gac ._efbd -_gac ._eg );_aebe :=make ([]byte ,_aceg );_aded ,_bfa :=_gac ._aadd .Read (_aebe );if _bfa !=nil {return _bfa ;};for _egg :=uint64 (0);_egg < _aceg ;_egg ++{_gac ._cac [_egg ]=_aebe [_egg ];};_gac ._ggf =_gac ._fec +uint64 (_aded );return nil ;};func (_efbe *SubstreamReader )Seek (offset int64 ,whence int )(int64 ,error ){switch whence {case _e .SeekStart :_efbe ._eg =uint64 (offset );case _e .SeekCurrent :_efbe ._eg +=uint64 (offset );case _e .SeekEnd :_efbe ._eg =_efbe ._efbd +uint64 (offset );default:return 0,_d .New ("\u0072\u0065\u0061d\u0065\u0072\u002e\u0053\u0075\u0062\u0073\u0074\u0072\u0065\u0061\u006d\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u0020\u0069\u006e\u0076\u0061\u006ci\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");};_efbe ._gb =0;return int64 (_efbe ._eg ),nil ;};func (_fea *SubstreamReader )ReadUint32 ()(uint32 ,error ){_edd :=make ([]byte ,4);_ ,_gc :=_fea .Read (_edd );if _gc !=nil {return 0,_gc ;};return _c .BigEndian .Uint32 (_edd ),nil ;};func (_eb *BufferedWriter )fullOffset ()int {_ac :=_eb ._bb ;if _eb ._b !=0{_ac ++;};return _ac ;};func (_gbb *SubstreamReader )Length ()uint64 {return _gbb ._efbd };func (_fef *SubstreamReader )Align ()(_fbc byte ){_fbc =_fef ._gb ;_fef ._gb =0;return _fbc };func (_feed *SubstreamReader )StreamPosition ()int64 {return int64 (_feed ._eg )};func (_dbf *SubstreamReader )Reset (){_dbf ._eg =_dbf ._fbg ;_dbf ._gb =_dbf ._acgc };func (_ecg *SubstreamReader )ReadBits (n byte )(_dcb uint64 ,_cgg error ){if n < _ecg ._gb {_ebb :=_ecg ._gb -n ;_dcb =uint64 (_ecg ._eee >>_ebb );_ecg ._eee &=1<<_ebb -1;_ecg ._gb =_ebb ;return _dcb ,nil ;};if n > _ecg ._gb {if _ecg ._gb > 0{_dcb =uint64 (_ecg ._eee );n -=_ecg ._gb ;};var _ebbd byte ;for n >=8{_ebbd ,_cgg =_ecg .readBufferByte ();if _cgg !=nil {return 0,_cgg ;};_dcb =_dcb <<8+uint64 (_ebbd );n -=8;};if n > 0{if _ecg ._eee ,_cgg =_ecg .readBufferByte ();_cgg !=nil {return 0,_cgg ;};_gfec :=8-n ;_dcb =_dcb <<n +uint64 (_ecg ._eee >>_gfec );_ecg ._eee &=1<<_gfec -1;_ecg ._gb =_gfec ;}else {_ecg ._gb =0;};return _dcb ,nil ;};_ecg ._gb =0;return uint64 (_ecg ._eee ),nil ;};func (_fbd *Reader )readBool ()(_aade bool ,_gfe error ){if _fbd ._dcc ==0{_fbd ._efa ,_gfe =_fbd .readBufferByte ();if _gfe !=nil {return false ,_gfe ;};_aade =(_fbd ._efa &0x80)!=0;_fbd ._efa ,_fbd ._dcc =_fbd ._efa &0x7f,7;return _aade ,nil ;};_fbd ._dcc --;_aade =(_fbd ._efa &(1<<_fbd ._dcc ))!=0;_fbd ._efa &=1<<_fbd ._dcc -1;return _aade ,nil ;};func (_dgg *Writer )Write (p []byte )(int ,error ){if len (p )> _dgg .byteCapacity (){return 0,_e .EOF ;};for _ ,_bgcg :=range p {if _gaf :=_dgg .writeByte (_bgcg );_gaf !=nil {return 0,_gaf ;};};return len (p ),nil ;};func NewWriterMSB (data []byte )*Writer {return &Writer {_dfd :data ,_bee :true }};func (_da *Reader )BitPosition ()int {return int (_da ._dcc )};func (_bf *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _ce .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );};if len (_bf ._gg )-1< _bf ._bb {_bf .expandIfNeeded (1);};_fa :=_bf ._b ;if _bf ._dg {_fa =7-_bf ._b ;};_bf ._gg [_bf ._bb ]|=byte (uint16 (bit <<_fa )&0xff);_bf ._b ++;if _bf ._b ==8{_bf ._bb ++;_bf ._b =0;};return nil ;};func (_bg *BufferedWriter )tryGrowByReslice (_dec int )bool {if _ebf :=len (_bg ._gg );_dec <=cap (_bg ._gg )-_ebf {_bg ._gg =_bg ._gg [:_ebf +_dec ];return true ;};return false ;};func NewWriter (data []byte )*Writer {return &Writer {_dfd :data }};func (_ba *BufferedWriter )WriteByte (bt byte )error {if _ba ._bb > len (_ba ._gg )-1||(_ba ._bb ==len (_ba ._gg )-1&&_ba ._b !=0){_ba .expandIfNeeded (1);};_ba .writeByte (bt );return nil ;};type BitWriter interface{WriteBit (_ggb int )error ;WriteBits (_fcc uint64 ,_caa int )(_bc int ,_abe error );FinishByte ();SkipBits (_bgf int )error ;};func (_dgda *BufferedWriter )byteCapacity ()int {_cef :=len (_dgda ._gg )-_dgda ._bb ;if _dgda ._b !=0{_cef --;};return _cef ;};func (_dfa *SubstreamReader )Mark (){_dfa ._fbg =_dfa ._eg ;_dfa ._acgc =_dfa ._gb };func (_eff *BufferedWriter )writeShiftedBytes (_aed []byte )int {for _ ,_fae :=range _aed {_eff .writeByte (_fae );};return len (_aed );};func (_fag *Reader )read (_dag []byte )(int ,error ){if _fag ._gd >=int64 (len (_fag ._aff )){return 0,_e .EOF ;};_fag ._gae =-1;_bff :=copy (_dag ,_fag ._aff [_fag ._gd :]);_fag ._gd +=int64 (_bff );return _bff ,nil ;};func (_ggc *SubstreamReader )ReadByte ()(byte ,error ){if _ggc ._gb ==0{return _ggc .readBufferByte ();};return _ggc .readUnalignedByte ();};func (_ef *BufferedWriter )Len ()int {return _ef .byteCapacity ()};func _ggdb (_fafa ,_add uint64 )uint64 {if _fafa < _add {return _fafa ;};return _add ;};func (_gada *SubstreamReader )BitPosition ()int {return int (_gada ._gb )};func (_fbf *Reader )Reset (){_fbf ._gd =_fbf ._cag ;_fbf ._dcc =_fbf ._afd };func (_bdd *Reader )ReadUint32 ()(uint32 ,error ){_acgb :=make ([]byte ,4);_ ,_aac :=_bdd .Read (_acgb );if _aac !=nil {return 0,_aac ;};return _c .BigEndian .Uint32 (_acgb ),nil ;};const (_cb =64;_ae =int (^uint (0)>>1););var _ BinaryWriter =&Writer {};var _ _e .Writer =&BufferedWriter {};var _ _e .ByteWriter =&BufferedWriter {};func (_bddb *Writer )writeByte (_cga byte )error {if _bddb ._caac > len (_bddb ._dfd )-1{return _e .EOF ;};if _bddb ._caac ==len (_bddb ._dfd )-1&&_bddb ._gcf !=0{return _e .EOF ;};if _bddb ._gcf ==0{_bddb ._dfd [_bddb ._caac ]=_cga ;_bddb ._caac ++;return nil ;};if _bddb ._bee {_bddb ._dfd [_bddb ._caac ]|=_cga >>_bddb ._gcf ;_bddb ._caac ++;_bddb ._dfd [_bddb ._caac ]=byte (uint16 (_cga )<<(8-_bddb ._gcf )&0xff);}else {_bddb ._dfd [_bddb ._caac ]|=byte (uint16 (_cga )<<_bddb ._gcf &0xff);_bddb ._caac ++;_bddb ._dfd [_bddb ._caac ]=_cga >>(8-_bddb ._gcf );};return nil ;};var (_ _e .Reader =&Reader {};_ _e .ByteReader =&Reader {};_ _e .Seeker =&Reader {};_ StreamReader =&Reader {};);func (_ggfd *Writer )UseMSB ()bool {return _ggfd ._bee };func (_ggd *Reader )ReadBool ()(bool ,error ){return _ggd .readBool ()};type SubstreamReader struct{_eg uint64 ;_aadd StreamReader ;_ace uint64 ;_efbd uint64 ;_cac []byte ;_fec uint64 ;_ggf uint64 ;_eee byte ;_gb byte ;_fbg uint64 ;_acgc byte ;};func (_ea *Reader )ConsumeRemainingBits (){if _ea ._dcc !=0{_ ,_bgfg :=_ea .ReadBits (_ea ._dcc );if _bgfg !=nil {_ed .Log .Debug ("\u0043\u006f\u006e\u0073\u0075\u006d\u0065\u0052\u0065\u006da\u0069\u006e\u0069\u0067\u0042\u0069\u0074s\u0020\u0066\u0061\u0069\u006c\u0065\u0064\u003a\u0020\u0025\u0076",_bgfg );};};};type BinaryWriter interface{BitWriter ;_e .Writer ;_e .ByteWriter ;Data ()[]byte ;};func (_dcg *Reader )readUnalignedByte ()(_aef byte ,_bae error ){_fcg :=_dcg ._dcc ;_aef =_dcg ._efa <<(8-_fcg );_dcg ._efa ,_bae =_dcg .readBufferByte ();if _bae !=nil {return 0,_bae ;};_aef |=_dcg ._efa >>_fcg ;_dcg ._efa &=1<<_fcg -1;return _aef ,nil ;};func (_abab *Reader )StreamPosition ()int64 {return _abab ._gd };func (_bca *Reader )Read (p []byte )(_fe int ,_gf error ){if _bca ._dcc ==0{return _bca .read (p );};for ;_fe < len (p );_fe ++{if p [_fe ],_gf =_bca .readUnalignedByte ();_gf !=nil {return 0,_gf ;};};return _fe ,nil ;};func (_afa *Writer )ResetBit (){_afa ._gcf =0};func (_fd *BufferedWriter )Write (d []byte )(int ,error ){_fd .expandIfNeeded (len (d ));if _fd ._b ==0{return _fd .writeFullBytes (d ),nil ;};return _fd .writeShiftedBytes (d ),nil ;};func (_f *BufferedWriter )FinishByte (){if _f ._b ==0{return ;};_f ._b =0;_f ._bb ++;};type Writer struct{_dfd []byte ;_gcf uint8 ;_caac int ;_bee bool ;};func (_ec *SubstreamReader )ReadBit ()(_bfc int ,_edf error ){_fefe ,_edf :=_ec .readBool ();if _edf !=nil {return 0,_edf ;};if _fefe {_bfc =1;};return _bfc ,nil ;};func (_fb *BufferedWriter )WriteBits (bits uint64 ,number int )(_aa int ,_db error ){const _fc ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";if number < 0||number > 64{return 0,_ce .Errorf (_fc ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );};_fad :=number /8;if _fad > 0{_fg :=number -_fad *8;for _de :=_fad -1;_de >=0;_de --{_ade :=byte ((bits >>uint (_de *8+_fg ))&0xff);if _db =_fb .WriteByte (_ade );_db !=nil {return _aa ,_ce .Wrapf (_db ,_fc ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_fad -_de +1);};};number -=_fad *8;if number ==0{return _fad ,nil ;};};var _gad int ;for _dgd :=0;_dgd < number ;_dgd ++{if _fb ._dg {_gad =int ((bits >>uint (number -1-_dgd ))&0x1);}else {_gad =int (bits &0x1);bits >>=1;};if _db =_fb .WriteBit (_gad );_db !=nil {return _aa ,_ce .Wrapf (_db ,_fc ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_dgd );};};return _fad ,nil ;};func (_cg *SubstreamReader )Offset ()uint64 {return _cg ._ace };func (_dde *Writer )SkipBits (skip int )error {const _edfb ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";if skip ==0{return nil ;};_cae :=int (_dde ._gcf )+skip ;if _cae >=0&&_cae < 8{_dde ._gcf =uint8 (_cae );return nil ;};_cae =int (_dde ._gcf )+_dde ._caac *8+skip ;if _cae < 0{return _ce .Errorf (_edfb ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_bcg :=_cae /8;_bgc :=_cae %8;_ed .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");_ed .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_dde ._gcf ,_dde ._caac ,int (_dde ._gcf )+(_dde ._caac )*8,len (_dde ._dfd ),cap (_dde ._dfd ));_ed .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_cae ,_bgc );_dde ._gcf =uint8 (_bgc );if _fbgg :=_bcg -_dde ._caac ;_fbgg > 0&&len (_dde ._dfd )-1< _bcg {_ed .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_fbgg );return _ce .Errorf (_edfb ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_dde ._caac =_bcg ;_ed .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_dde ._gcf ,_dde ._caac );return nil ;};