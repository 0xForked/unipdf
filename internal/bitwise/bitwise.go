//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_ag "encoding/binary";_g "errors";_bc "github.com/unidoc/unipdf/v3/common";_e "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_a "io";);func (_fbc *BufferedWriter )writeShiftedBytes (_dd []byte )int {for _ ,_gc :=range _dd {_fbc .writeByte (_gc );
};return len (_dd );};type StreamReader interface{_a .Reader ;_a .ByteReader ;_a .Seeker ;Align ()byte ;BitPosition ()int ;Mark ();Length ()uint64 ;ReadBit ()(int ,error );ReadBits (_df byte )(uint64 ,error );ReadBool ()(bool ,error );ReadUint32 ()(uint32 ,error );
Reset ();StreamPosition ()int64 ;};func (_cba *Reader )readBool ()(_dad bool ,_fff error ){if _cba ._eca ==0{_cba ._cab ,_fff =_cba .readBufferByte ();if _fff !=nil {return false ,_fff ;};_dad =(_cba ._cab &0x80)!=0;_cba ._cab ,_cba ._eca =_cba ._cab &0x7f,7;
return _dad ,nil ;};_cba ._eca --;_dad =(_cba ._cab &(1<<_cba ._eca ))!=0;_cba ._cab &=1<<_cba ._eca -1;return _dad ,nil ;};func (_dg *BufferedWriter )Data ()[]byte {return _dg ._f };func (_ced *BufferedWriter )byteCapacity ()int {_bgd :=len (_ced ._f )-_ced ._c ;
if _ced ._d !=0{_bgd --;};return _bgd ;};func (_caf *Reader )BitPosition ()int {return int (_caf ._eca )};func (_ae *BufferedWriter )WriteBits (bits uint64 ,number int )(_ff int ,_def error ){const _ac ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";
if number < 0||number > 64{return 0,_e .Errorf (_ac ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};_fc :=number /8;if _fc > 0{_db :=number -_fc *8;for _cee :=_fc -1;_cee >=0;_cee --{_bgc :=byte ((bits >>uint (_cee *8+_db ))&0xff);if _def =_ae .WriteByte (_bgc );_def !=nil {return _ff ,_e .Wrapf (_def ,_ac ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_fc -_cee +1);
};};number -=_fc *8;if number ==0{return _fc ,nil ;};};var _agbb int ;for _bcc :=0;_bcc < number ;_bcc ++{if _ae ._be {_agbb =int ((bits >>uint (number -1-_bcc ))&0x1);}else {_agbb =int (bits &0x1);bits >>=1;};if _def =_ae .WriteBit (_agbb );_def !=nil {return _ff ,_e .Wrapf (_def ,_ac ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_bcc );
};};return _fc ,nil ;};func (_ed *BufferedWriter )Write (d []byte )(int ,error ){_ed .expandIfNeeded (len (d ));if _ed ._d ==0{return _ed .writeFullBytes (d ),nil ;};return _ed .writeShiftedBytes (d ),nil ;};func (_bfd *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;
};_eg :=int (_bfd ._d )+skip ;if _eg >=0&&_eg < 8{_bfd ._d =uint8 (_eg );return nil ;};_eg =int (_bfd ._d )+_bfd ._c *8+skip ;if _eg < 0{return _e .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_fb :=_eg /8;_ce :=_eg %8;_bfd ._d =uint8 (_ce );if _bed :=_fb -_bfd ._c ;_bed > 0&&len (_bfd ._f )-1< _fb {if _bfd ._d !=0{_bed ++;};_bfd .expandIfNeeded (_bed );};_bfd ._c =_fb ;return nil ;};func (_fcf *Reader )ConsumeRemainingBits ()(uint64 ,error ){if _fcf ._eca !=0{return _fcf .ReadBits (_fcf ._eca );
};return 0,nil ;};func (_ccc *SubstreamReader )StreamPosition ()int64 {return int64 (_ccc ._bdf )};var _ BinaryWriter =&BufferedWriter {};func (_dff *SubstreamReader )Offset ()uint64 {return _dff ._gdf };func (_dadd *SubstreamReader )BitPosition ()int {return int (_dadd ._gb )};
func (_bga *Writer )FinishByte (){if _bga ._dfb ==0{return ;};_bga ._dfb =0;_bga ._ddg ++;};func (_eae *BufferedWriter )writeFullBytes (_dgg []byte )int {_ee :=copy (_eae ._f [_eae .fullOffset ():],_dgg );_eae ._c +=_ee ;return _ee ;};func (_dcdf *Writer )writeByte (_gce byte )error {if _dcdf ._ddg > len (_dcdf ._gaggf )-1{return _a .EOF ;
};if _dcdf ._ddg ==len (_dcdf ._gaggf )-1&&_dcdf ._dfb !=0{return _a .EOF ;};if _dcdf ._dfb ==0{_dcdf ._gaggf [_dcdf ._ddg ]=_gce ;_dcdf ._ddg ++;return nil ;};if _dcdf ._agg {_dcdf ._gaggf [_dcdf ._ddg ]|=_gce >>_dcdf ._dfb ;_dcdf ._ddg ++;_dcdf ._gaggf [_dcdf ._ddg ]=byte (uint16 (_gce )<<(8-_dcdf ._dfb )&0xff);
}else {_dcdf ._gaggf [_dcdf ._ddg ]|=byte (uint16 (_gce )<<_dcdf ._dfb &0xff);_dcdf ._ddg ++;_dcdf ._gaggf [_dcdf ._ddg ]=_gce >>(8-_dcdf ._dfb );};return nil ;};func (_daf *Writer )Write (p []byte )(int ,error ){if len (p )> _daf .byteCapacity (){return 0,_a .EOF ;
};for _ ,_cfb :=range p {if _ceg :=_daf .writeByte (_cfb );_ceg !=nil {return 0,_ceg ;};};return len (p ),nil ;};func (_gagc *BufferedWriter )tryGrowByReslice (_ffb int )bool {if _bff :=len (_gagc ._f );_ffb <=cap (_gagc ._f )-_bff {_gagc ._f =_gagc ._f [:_bff +_ffb ];
return true ;};return false ;};func (_cge *Reader )ReadUint32 ()(uint32 ,error ){_dga :=make ([]byte ,4);_ ,_bb :=_cge .Read (_dga );if _bb !=nil {return 0,_bb ;};return _ag .BigEndian .Uint32 (_dga ),nil ;};type BitWriter interface{WriteBit (_ec int )error ;
WriteBits (_egg uint64 ,_cbf int )(_ba int ,_cc error );FinishByte ();SkipBits (_ded int )error ;};var _ _a .Writer =&BufferedWriter {};func (_dec *Reader )Align ()(_dcd byte ){_dcd =_dec ._eca ;_dec ._eca =0;return _dcd };func (_baf *Reader )readBufferByte ()(byte ,error ){if _baf ._fba >=int64 (len (_baf ._fge )){return 0,_a .EOF ;
};_baf ._aa =-1;_daa :=_baf ._fge [_baf ._fba ];_baf ._fba ++;_baf ._ddd =int (_daa );return _daa ,nil ;};func (_gd *Reader )StreamPosition ()int64 {return _gd ._fba };var _ BinaryWriter =&Writer {};func (_bfa *SubstreamReader )Seek (offset int64 ,whence int )(int64 ,error ){switch whence {case _a .SeekStart :_bfa ._bdf =uint64 (offset );
case _a .SeekCurrent :_bfa ._bdf +=uint64 (offset );case _a .SeekEnd :_bfa ._bdf =_bfa ._ggf +uint64 (offset );default:return 0,_g .New ("\u0072\u0065\u0061d\u0065\u0072\u002e\u0053\u0075\u0062\u0073\u0074\u0072\u0065\u0061\u006d\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u0020\u0069\u006e\u0076\u0061\u006ci\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};_bfa ._gb =0;return int64 (_bfa ._bdf ),nil ;};func (_agb *BufferedWriter )FinishByte (){if _agb ._d ==0{return ;};_agb ._d =0;_agb ._c ++;};func NewReader (data []byte )*Reader {return &Reader {_fge :data }};func NewWriter (data []byte )*Writer {return &Writer {_gaggf :data }};
var _ _a .ByteWriter =&BufferedWriter {};func (_bfb *SubstreamReader )Align ()(_dgf byte ){_dgf =_bfb ._gb ;_bfb ._gb =0;return _dgf };func (_abb *Reader )ReadBit ()(_af int ,_ef error ){_cac ,_ef :=_abb .readBool ();if _ef !=nil {return 0,_ef ;};if _cac {_af =1;
};return _af ,nil ;};func (_gdb *Writer )byteCapacity ()int {_efe :=len (_gdb ._gaggf )-_gdb ._ddg ;if _gdb ._dfb !=0{_efe --;};return _efe ;};func (_edf *Reader )Read (p []byte )(_bedd int ,_eac error ){if _edf ._eca ==0{return _edf .read (p );};for ;
_bedd < len (p );_bedd ++{if p [_bedd ],_eac =_edf .readUnalignedByte ();_eac !=nil {return 0,_eac ;};};return _bedd ,nil ;};func (_dc *BufferedWriter )writeByte (_adf byte ){switch {case _dc ._d ==0:_dc ._f [_dc ._c ]=_adf ;_dc ._c ++;case _dc ._be :_dc ._f [_dc ._c ]|=_adf >>_dc ._d ;
_dc ._c ++;_dc ._f [_dc ._c ]=byte (uint16 (_adf )<<(8-_dc ._d )&0xff);default:_dc ._f [_dc ._c ]|=byte (uint16 (_adf )<<_dc ._d &0xff);_dc ._c ++;_dc ._f [_dc ._c ]=_adf >>(8-_dc ._d );};};func (_bac *SubstreamReader )readUnalignedByte ()(_gdc byte ,_cf error ){_ebfc :=_bac ._gb ;
_gdc =_bac ._cgbe <<(8-_ebfc );_bac ._cgbe ,_cf =_bac .readBufferByte ();if _cf !=nil {return 0,_cf ;};_gdc |=_bac ._cgbe >>_ebfc ;_bac ._cgbe &=1<<_ebfc -1;return _gdc ,nil ;};func (_fa *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _e .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );
};if len (_fa ._f )-1< _fa ._c {_fa .expandIfNeeded (1);};_gad :=_fa ._d ;if _fa ._be {_gad =7-_fa ._d ;};_fa ._f [_fa ._c ]|=byte (uint16 (bit <<_gad )&0xff);_fa ._d ++;if _fa ._d ==8{_fa ._c ++;_fa ._d =0;};return nil ;};func (_bbg *Writer )SkipBits (skip int )error {const _cbg ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";
if skip ==0{return nil ;};_acfb :=int (_bbg ._dfb )+skip ;if _acfb >=0&&_acfb < 8{_bbg ._dfb =uint8 (_acfb );return nil ;};_acfb =int (_bbg ._dfb )+_bbg ._ddg *8+skip ;if _acfb < 0{return _e .Errorf (_cbg ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_ecc :=_acfb /8;_dea :=_acfb %8;_bc .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");_bc .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_bbg ._dfb ,_bbg ._ddg ,int (_bbg ._dfb )+(_bbg ._ddg )*8,len (_bbg ._gaggf ),cap (_bbg ._gaggf ));
_bc .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_acfb ,_dea );_bbg ._dfb =uint8 (_dea );if _dcef :=_ecc -_bbg ._ddg ;
_dcef > 0&&len (_bbg ._gaggf )-1< _ecc {_bc .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_dcef );return _e .Errorf (_cbg ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_bbg ._ddg =_ecc ;_bc .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_bbg ._dfb ,_bbg ._ddg );return nil ;};const (_bg =64;
_ga =int (^uint (0)>>1););func (_baa *SubstreamReader )readBool ()(_gdd bool ,_add error ){if _baa ._gb ==0{_baa ._cgbe ,_add =_baa .readBufferByte ();if _add !=nil {return false ,_add ;};_gdd =(_baa ._cgbe &0x80)!=0;_baa ._cgbe ,_baa ._gb =_baa ._cgbe &0x7f,7;
return _gdd ,nil ;};_baa ._gb --;_gdd =(_baa ._cgbe &(1<<_baa ._gb ))!=0;_baa ._cgbe &=1<<_baa ._gb -1;return _gdd ,nil ;};func (_gga *Writer )writeBit (_ccg uint8 )error {if len (_gga ._gaggf )-1< _gga ._ddg {return _a .EOF ;};_bfg :=_gga ._dfb ;if _gga ._agg {_bfg =7-_gga ._dfb ;
};_gga ._gaggf [_gga ._ddg ]|=byte (uint16 (_ccg <<_bfg )&0xff);_gga ._dfb ++;if _gga ._dfb ==8{_gga ._ddg ++;_gga ._dfb =0;};return nil ;};func (_ea *BufferedWriter )Reset (){_ea ._f =_ea ._f [:0];_ea ._c =0;_ea ._d =0};func (_aae *Reader )ReadByte ()(byte ,error ){if _aae ._eca ==0{return _aae .readBufferByte ();
};return _aae .readUnalignedByte ();};var (_ _a .Reader =&Reader {};_ _a .ByteReader =&Reader {};_ _a .Seeker =&Reader {};_ StreamReader =&Reader {};);func (_gag *BufferedWriter )WriteByte (bt byte )error {if _gag ._c > len (_gag ._f )-1||(_gag ._c ==len (_gag ._f )-1&&_gag ._d !=0){_gag .expandIfNeeded (1);
};_gag .writeByte (bt );return nil ;};type SubstreamReader struct{_bdf uint64 ;_cbag StreamReader ;_gdf uint64 ;_ggf uint64 ;_fdc []byte ;_gff uint64 ;_gcf uint64 ;_cgbe byte ;_gb byte ;_egge uint64 ;_fca byte ;};func (_cbe *Reader )ReadBits (n byte )(_cef uint64 ,_bcb error ){if n < _cbe ._eca {_eb :=_cbe ._eca -n ;
_cef =uint64 (_cbe ._cab >>_eb );_cbe ._cab &=1<<_eb -1;_cbe ._eca =_eb ;return _cef ,nil ;};if n > _cbe ._eca {if _cbe ._eca > 0{_cef =uint64 (_cbe ._cab );n -=_cbe ._eca ;};for n >=8{_ebd ,_gg :=_cbe .readBufferByte ();if _gg !=nil {return 0,_gg ;};_cef =_cef <<8+uint64 (_ebd );
n -=8;};if n > 0{if _cbe ._cab ,_bcb =_cbe .readBufferByte ();_bcb !=nil {return 0,_bcb ;};_gf :=8-n ;_cef =_cef <<n +uint64 (_cbe ._cab >>_gf );_cbe ._cab &=1<<_gf -1;_cbe ._eca =_gf ;}else {_cbe ._eca =0;};return _cef ,nil ;};_cbe ._eca =0;return uint64 (_cbe ._cab ),nil ;
};func (_dggf *SubstreamReader )ReadUint32 ()(uint32 ,error ){_efa :=make ([]byte ,4);_ ,_bad :=_dggf .Read (_efa );if _bad !=nil {return 0,_bad ;};return _ag .BigEndian .Uint32 (_efa ),nil ;};func (_gagg *SubstreamReader )Mark (){_gagg ._egge =_gagg ._bdf ;
_gagg ._fca =_gagg ._gb };func (_fce *SubstreamReader )ReadByte ()(byte ,error ){if _fce ._gb ==0{return _fce .readBufferByte ();};return _fce .readUnalignedByte ();};func (_dce *Reader )readUnalignedByte ()(_dggb byte ,_ge error ){_edd :=_dce ._eca ;_dggb =_dce ._cab <<(8-_edd );
_dce ._cab ,_ge =_dce .readBufferByte ();if _ge !=nil {return 0,_ge ;};_dggb |=_dce ._cab >>_edd ;_dce ._cab &=1<<_edd -1;return _dggb ,nil ;};func (_beda *SubstreamReader )ReadBool ()(bool ,error ){return _beda .readBool ()};func (_dead *Writer )WriteBits (bits uint64 ,number int )(_dac int ,_gfe error ){const _cgc ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";
if number < 0||number > 64{return 0,_e .Errorf (_cgc ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};if number ==0{return 0,nil ;};_cae :=number /8;if _cae > 0{_bbd :=number -_cae *8;for _fea :=_cae -1;_fea >=0;_fea --{_dcda :=byte ((bits >>uint (_fea *8+_bbd ))&0xff);if _gfe =_dead .WriteByte (_dcda );_gfe !=nil {return _dac ,_e .Wrapf (_gfe ,_cgc ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_cae -_fea +1);
};};number -=_cae *8;if number ==0{return _cae ,nil ;};};var _dcefe int ;for _cfa :=0;_cfa < number ;_cfa ++{if _dead ._agg {_dcefe =int ((bits >>uint (number -1-_cfa ))&0x1);}else {_dcefe =int (bits &0x1);bits >>=1;};if _gfe =_dead .WriteBit (_dcefe );
_gfe !=nil {return _dac ,_e .Wrapf (_gfe ,_cgc ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_cfa );};};return _cae ,nil ;};func (_bdg *SubstreamReader )readBufferByte ()(byte ,error ){if _bdg ._bdf >=_bdg ._ggf {return 0,_a .EOF ;};if _bdg ._bdf >=_bdg ._gcf ||_bdg ._bdf < _bdg ._gff {if _acf :=_bdg .fillBuffer ();
_acf !=nil {return 0,_acf ;};};_cede :=_bdg ._fdc [_bdg ._bdf -_bdg ._gff ];_bdg ._bdf ++;return _cede ,nil ;};type Writer struct{_gaggf []byte ;_dfb uint8 ;_ddg int ;_agg bool ;};func (_bca *Reader )read (_da []byte )(int ,error ){if _bca ._fba >=int64 (len (_bca ._fge )){return 0,_a .EOF ;
};_bca ._aa =-1;_aad :=copy (_da ,_bca ._fge [_bca ._fba :]);_bca ._fba +=int64 (_aad );return _aad ,nil ;};func (_dag *SubstreamReader )ReadBit ()(_cbaa int ,_ecf error ){_daae ,_ecf :=_dag .readBool ();if _ecf !=nil {return 0,_ecf ;};if _daae {_cbaa =1;
};return _cbaa ,nil ;};type BinaryWriter interface{BitWriter ;_a .Writer ;_a .ByteWriter ;Data ()[]byte ;};func (_afa *Reader )Reset (){_afa ._fba =_afa ._fde ;_afa ._eca =_afa ._fbag ;_afa ._cab =_afa ._ege ;_afa ._ddd =_afa ._fgg ;};func (_cca *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _cca .writeBit (uint8 (bit ));
};return _e .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");};func (_fg *BufferedWriter )fullOffset ()int {_gaa :=_fg ._c ;if _fg ._d !=0{_gaa ++;
};return _gaa ;};func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_be :true }};func (_ddge *Writer )Data ()[]byte {return _ddge ._gaggf };func (_acd *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_acd ._aa =-1;var _fdf int64 ;switch whence {case _a .SeekStart :_fdf =offset ;
case _a .SeekCurrent :_fdf =_acd ._fba +offset ;case _a .SeekEnd :_fdf =int64 (len (_acd ._fge ))+offset ;default:return 0,_g .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};if _fdf < 0{return 0,_g .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");};_acd ._fba =_fdf ;
_acd ._eca =0;return _fdf ,nil ;};func (_adg *Reader )Mark (){_adg ._fde =_adg ._fba ;_adg ._fbag =_adg ._eca ;_adg ._ege =_adg ._cab ;_adg ._fgg =_adg ._ddd ;};func NewWriterMSB (data []byte )*Writer {return &Writer {_gaggf :data ,_agg :true }};func (_abe *Writer )UseMSB ()bool {return _abe ._agg };
func (_aga *BufferedWriter )grow (_ad int ){if _aga ._f ==nil &&_ad < _bg {_aga ._f =make ([]byte ,_ad ,_bg );return ;};_gaf :=len (_aga ._f );if _aga ._d !=0{_gaf ++;};_ffc :=cap (_aga ._f );switch {case _ad <=_ffc /2-_gaf :_bc .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_aga ._f ),cap (_aga ._f ),_ad );
_bc .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_ffc ,_gaf );copy (_aga ._f ,_aga ._f [_aga .fullOffset ():]);
case _ffc > _ga -_ffc -_ad :_bc .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_ca :=make ([]byte ,2*_ffc +_ad );copy (_ca ,_aga ._f );_aga ._f =_ca ;};_aga ._f =_aga ._f [:_gaf +_ad ];
};func (_ddda *Reader )ReadBool ()(bool ,error ){return _ddda .readBool ()};func (_dfe *Writer )ResetBit (){_dfe ._dfb =0};func (_defd *SubstreamReader )Reset (){_defd ._bdf =_defd ._egge ;_defd ._gb =_defd ._fca };func (_fdb *SubstreamReader )Length ()uint64 {return _fdb ._ggf };
func (_gda *SubstreamReader )fillBuffer ()error {if uint64 (_gda ._cbag .StreamPosition ())!=_gda ._bdf +_gda ._gdf {_ ,_bfdd :=_gda ._cbag .Seek (int64 (_gda ._bdf +_gda ._gdf ),_a .SeekStart );if _bfdd !=nil {return _bfdd ;};};_gda ._gff =_gda ._bdf ;
_gbc :=_deg (uint64 (len (_gda ._fdc )),_gda ._ggf -_gda ._bdf );_fee :=make ([]byte ,_gbc );_bee ,_fcc :=_gda ._cbag .Read (_fee );if _fcc !=nil {return _fcc ;};for _bdc :=uint64 (0);_bdc < _gbc ;_bdc ++{_gda ._fdc [_bdc ]=_fee [_bdc ];};_gda ._gcf =_gda ._gff +uint64 (_bee );
return nil ;};func (_ebf *SubstreamReader )ReadBits (n byte )(_bcgd uint64 ,_eed error ){if n < _ebf ._gb {_gcg :=_ebf ._gb -n ;_bcgd =uint64 (_ebf ._cgbe >>_gcg );_ebf ._cgbe &=1<<_gcg -1;_ebf ._gb =_gcg ;return _bcgd ,nil ;};if n > _ebf ._gb {if _ebf ._gb > 0{_bcgd =uint64 (_ebf ._cgbe );
n -=_ebf ._gb ;};var _fec byte ;for n >=8{_fec ,_eed =_ebf .readBufferByte ();if _eed !=nil {return 0,_eed ;};_bcgd =_bcgd <<8+uint64 (_fec );n -=8;};if n > 0{if _ebf ._cgbe ,_eed =_ebf .readBufferByte ();_eed !=nil {return 0,_eed ;};_ffa :=8-n ;_bcgd =_bcgd <<n +uint64 (_ebf ._cgbe >>_ffa );
_ebf ._cgbe &=1<<_ffa -1;_ebf ._gb =_ffa ;}else {_ebf ._gb =0;};return _bcgd ,nil ;};_ebf ._gb =0;return uint64 (_ebf ._cgbe ),nil ;};func (_edb *BufferedWriter )expandIfNeeded (_fd int ){if !_edb .tryGrowByReslice (_fd ){_edb .grow (_fd );};};type BufferedWriter struct{_f []byte ;
_d uint8 ;_c int ;_be bool ;};func (_cb *BufferedWriter )Len ()int {return _cb .byteCapacity ()};func _deg (_cga ,_beg uint64 )uint64 {if _cga < _beg {return _cga ;};return _beg ;};func (_aeg *SubstreamReader )Read (b []byte )(_dgag int ,_cce error ){if _aeg ._bdf >=_aeg ._ggf {_bc .Log .Trace ("\u0053\u0074\u0072e\u0061\u006d\u0050\u006fs\u003a\u0020\u0027\u0025\u0064\u0027\u0020>\u003d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027",_aeg ._bdf ,_aeg ._ggf );
return 0,_a .EOF ;};for ;_dgag < len (b );_dgag ++{if b [_dgag ],_cce =_aeg .readUnalignedByte ();_cce !=nil {if _cce ==_a .EOF {return _dgag ,nil ;};return 0,_cce ;};};return _dgag ,nil ;};func NewSubstreamReader (r StreamReader ,offset ,length uint64 )(*SubstreamReader ,error ){if r ==nil {return nil ,_g .New ("\u0072o\u006ft\u0020\u0072\u0065\u0061\u0064e\u0072\u0020i\u0073\u0020\u006e\u0069\u006c");
};_bc .Log .Trace ("\u004e\u0065\u0077\u0053\u0075\u0062\u0073\u0074r\u0065\u0061\u006dRe\u0061\u0064\u0065\u0072\u0020\u0061t\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u003a\u0020\u0025\u0064\u0020\u0077\u0069\u0074h\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a \u0025\u0064",offset ,length );
return &SubstreamReader {_cbag :r ,_gdf :offset ,_ggf :length ,_fdc :make ([]byte ,length )},nil ;};func (_ab *Reader )Length ()uint64 {return uint64 (len (_ab ._fge ))};type Reader struct{_fge []byte ;_cab byte ;_eca byte ;_fba int64 ;_ddd int ;_aa int ;
_fde int64 ;_fbag byte ;_ege byte ;_fgg int ;};func (_de *BufferedWriter )ResetBitIndex (){_de ._d =0};func (_adc *Writer )WriteByte (c byte )error {return _adc .writeByte (c )};