//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_gc "encoding/binary";_gf "errors";_ff "fmt";_e "github.com/unidoc/unipdf/v3/common";_fb "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_g "io";);func (_fc *BufferedWriter )WriteBits (bits uint64 ,number int )(_gb int ,_ca error ){const _eg ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";
if number < 0||number > 64{return 0,_fb .Errorf (_eg ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};_fe :=number /8;if _fe > 0{_cg :=number -_fe *8;for _b :=_fe -1;_b >=0;_b --{_cb :=byte ((bits >>uint (_b *8+_cg ))&0xff);if _ca =_fc .WriteByte (_cb );_ca !=nil {return _gb ,_fb .Wrapf (_ca ,_eg ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_fe -_b +1);
};};number -=_fe *8;if number ==0{return _fe ,nil ;};};var _ebg int ;for _ag :=0;_ag < number ;_ag ++{if _fc ._gdd {_ebg =int ((bits >>uint (number -1-_ag ))&0x1);}else {_ebg =int (bits &0x1);bits >>=1;};if _ca =_fc .WriteBit (_ebg );_ca !=nil {return _gb ,_fb .Wrapf (_ca ,_eg ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_ag );
};};return _fe ,nil ;};type Writer struct{_db []byte ;_gdg uint8 ;_bde int ;_edg bool ;};func (_agc *Reader )ReadBit ()(_bbf int ,_fgfd error ){_edc ,_fgfd :=_agc .readBool ();if _fgfd !=nil {return 0,_fgfd ;};if _edc {_bbf =1;};return _bbf ,nil ;};func NewWriter (data []byte )*Writer {return &Writer {_db :data }};
func (_fge *BufferedWriter )byteCapacity ()int {_fbe :=len (_fge ._fg )-_fge ._gcb ;if _fge ._ac !=0{_fbe --;};return _fbe ;};func (_ebgb *Reader )read (_aaa []byte )(int ,error ){if _ebgb ._aga >=int64 (_ebgb ._bda ._fca ){return 0,_g .EOF ;};_ebgb ._edd =-1;
_dfb :=copy (_aaa ,_ebgb ._bda ._cbd [(int64 (_ebgb ._bda ._ccb )+_ebgb ._aga ):(_ebgb ._bda ._ccb +_ebgb ._bda ._fca )]);_ebgb ._aga +=int64 (_dfb );return _dfb ,nil ;};type Reader struct{_bda readerSource ;_ad byte ;_bee byte ;_aga int64 ;_dfc int ;_edd int ;
_dcf int64 ;_fec byte ;_ded byte ;_agf int ;};func (_ffc *BufferedWriter )WriteByte (bt byte )error {if _ffc ._gcb > len (_ffc ._fg )-1||(_ffc ._gcb ==len (_ffc ._fg )-1&&_ffc ._ac !=0){_ffc .expandIfNeeded (1);};_ffc .writeByte (bt );return nil ;};func (_de *BufferedWriter )tryGrowByReslice (_bb int )bool {if _fbef :=len (_de ._fg );
_bb <=cap (_de ._fg )-_fbef {_de ._fg =_de ._fg [:_fbef +_bb ];return true ;};return false ;};func (_ea *BufferedWriter )writeByte (_ebb byte ){switch {case _ea ._ac ==0:_ea ._fg [_ea ._gcb ]=_ebb ;_ea ._gcb ++;case _ea ._gdd :_ea ._fg [_ea ._gcb ]|=_ebb >>_ea ._ac ;
_ea ._gcb ++;_ea ._fg [_ea ._gcb ]=byte (uint16 (_ebb )<<(8-_ea ._ac )&0xff);default:_ea ._fg [_ea ._gcb ]|=byte (uint16 (_ebb )<<_ea ._ac &0xff);_ea ._gcb ++;_ea ._fg [_ea ._gcb ]=_ebb >>(8-_ea ._ac );};};var _ _g .ByteWriter =&BufferedWriter {};func (_cf *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _fb .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );
};if len (_cf ._fg )-1< _cf ._gcb {_cf .expandIfNeeded (1);};_fd :=_cf ._ac ;if _cf ._gdd {_fd =7-_cf ._ac ;};_cf ._fg [_cf ._gcb ]|=byte (uint16 (bit <<_fd )&0xff);_cf ._ac ++;if _cf ._ac ==8{_cf ._gcb ++;_cf ._ac =0;};return nil ;};func (_dae *Reader )Length ()uint64 {return uint64 (_dae ._bda ._fca )};
func (_fdd *Reader )AbsoluteLength ()uint64 {return uint64 (len (_fdd ._bda ._cbd ))};func (_ec *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;};_ab :=int (_ec ._ac )+skip ;if _ab >=0&&_ab < 8{_ec ._ac =uint8 (_ab );return nil ;};_ab =int (_ec ._ac )+_ec ._gcb *8+skip ;
if _ab < 0{return _fb .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_aba :=_ab /8;_eb :=_ab %8;_ec ._ac =uint8 (_eb );
if _dg :=_aba -_ec ._gcb ;_dg > 0&&len (_ec ._fg )-1< _aba {if _ec ._ac !=0{_dg ++;};_ec .expandIfNeeded (_dg );};_ec ._gcb =_aba ;return nil ;};func (_faf *BufferedWriter )Write (d []byte )(int ,error ){_faf .expandIfNeeded (len (d ));if _faf ._ac ==0{return _faf .writeFullBytes (d ),nil ;
};return _faf .writeShiftedBytes (d ),nil ;};func (_bc *Reader )AbsolutePosition ()int64 {return _bc ._aga +int64 (_bc ._bda ._ccb )};func (_ee *Reader )ReadBits (n byte )(_eff uint64 ,_bf error ){if n < _ee ._bee {_gdb :=_ee ._bee -n ;_eff =uint64 (_ee ._ad >>_gdb );
_ee ._ad &=1<<_gdb -1;_ee ._bee =_gdb ;return _eff ,nil ;};if n > _ee ._bee {if _ee ._bee > 0{_eff =uint64 (_ee ._ad );n -=_ee ._bee ;};for n >=8{_cfad ,_ega :=_ee .readBufferByte ();if _ega !=nil {return 0,_ega ;};_eff =_eff <<8+uint64 (_cfad );n -=8;
};if n > 0{if _ee ._ad ,_bf =_ee .readBufferByte ();_bf !=nil {return 0,_bf ;};_cbe :=8-n ;_eff =_eff <<n +uint64 (_ee ._ad >>_cbe );_ee ._ad &=1<<_cbe -1;_ee ._bee =_cbe ;}else {_ee ._bee =0;};return _eff ,nil ;};_ee ._bee =0;return uint64 (_ee ._ad ),nil ;
};type BinaryWriter interface{BitWriter ;_g .Writer ;_g .ByteWriter ;Data ()[]byte ;};func (_ecg *Reader )readBufferByte ()(byte ,error ){if _ecg ._aga >=int64 (_ecg ._bda ._fca ){return 0,_g .EOF ;};_ecg ._edd =-1;_cad :=_ecg ._bda ._cbd [int64 (_ecg ._bda ._ccb )+_ecg ._aga ];
_ecg ._aga ++;_ecg ._dfc =int (_cad );return _cad ,nil ;};func (_cgd *BufferedWriter )grow (_be int ){if _cgd ._fg ==nil &&_be < _a {_cgd ._fg =make ([]byte ,_be ,_a );return ;};_gfe :=len (_cgd ._fg );if _cgd ._ac !=0{_gfe ++;};_bag :=cap (_cgd ._fg );
switch {case _be <=_bag /2-_gfe :_e .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_cgd ._fg ),cap (_cgd ._fg ),_be );
_e .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_bag ,_gfe );copy (_cgd ._fg ,_cgd ._fg [_cgd .fullOffset ():]);
case _bag > _gd -_bag -_be :_e .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_bd :=make ([]byte ,2*_bag +_be );copy (_bd ,_cgd ._fg );_cgd ._fg =_bd ;};_cgd ._fg =_cgd ._fg [:_gfe +_be ];
};func (_cbf *BufferedWriter )writeFullBytes (_abag []byte )int {_da :=copy (_cbf ._fg [_cbf .fullOffset ():],_abag );_cbf ._gcb +=_da ;return _da ;};func (_bdf *Writer )Write (p []byte )(int ,error ){if len (p )> _bdf .byteCapacity (){return 0,_g .EOF ;
};for _ ,_dfd :=range p {if _ddg :=_bdf .writeByte (_dfd );_ddg !=nil {return 0,_ddg ;};};return len (p ),nil ;};func (_cfe *BufferedWriter )writeShiftedBytes (_ga []byte )int {for _ ,_cc :=range _ga {_cfe .writeByte (_cc );};return len (_ga );};var _ BinaryWriter =&Writer {};
func (_ge *Reader )BitPosition ()int {return int (_ge ._bee )};func (_dfg *Reader )readUnalignedByte ()(_cfb byte ,_bdc error ){_egg :=_dfg ._bee ;_cfb =_dfg ._ad <<(8-_egg );_dfg ._ad ,_bdc =_dfg .readBufferByte ();if _bdc !=nil {return 0,_bdc ;};_cfb |=_dfg ._ad >>_egg ;
_dfg ._ad &=1<<_egg -1;return _cfb ,nil ;};const (_a =64;_gd =int (^uint (0)>>1););func (_cdc *Writer )writeByte (_ggf byte )error {if _cdc ._bde > len (_cdc ._db )-1{return _g .EOF ;};if _cdc ._bde ==len (_cdc ._db )-1&&_cdc ._gdg !=0{return _g .EOF ;
};if _cdc ._gdg ==0{_cdc ._db [_cdc ._bde ]=_ggf ;_cdc ._bde ++;return nil ;};if _cdc ._edg {_cdc ._db [_cdc ._bde ]|=_ggf >>_cdc ._gdg ;_cdc ._bde ++;_cdc ._db [_cdc ._bde ]=byte (uint16 (_ggf )<<(8-_cdc ._gdg )&0xff);}else {_cdc ._db [_cdc ._bde ]|=byte (uint16 (_ggf )<<_cdc ._gdg &0xff);
_cdc ._bde ++;_cdc ._db [_cdc ._bde ]=_ggf >>(8-_cdc ._gdg );};return nil ;};func NewReader (data []byte )*Reader {return &Reader {_bda :readerSource {_cbd :data ,_fca :len (data ),_ccb :0}};};func (_aaag *Writer )Data ()[]byte {return _aaag ._db };func (_gdc *Reader )ReadBool ()(bool ,error ){return _gdc .readBool ()};
var _ _g .Writer =&BufferedWriter {};func (_fgfc *Writer )writeBit (_daeb uint8 )error {if len (_fgfc ._db )-1< _fgfc ._bde {return _g .EOF ;};_fcfg :=_fgfc ._gdg ;if _fgfc ._edg {_fcfg =7-_fgfc ._gdg ;};_fgfc ._db [_fgfc ._bde ]|=byte (uint16 (_daeb <<_fcfg )&0xff);
_fgfc ._gdg ++;if _fgfc ._gdg ==8{_fgfc ._bde ++;_fgfc ._gdg =0;};return nil ;};func (_eba *Reader )readBool ()(_ce bool ,_efe error ){if _eba ._bee ==0{_eba ._ad ,_efe =_eba .readBufferByte ();if _efe !=nil {return false ,_efe ;};_ce =(_eba ._ad &0x80)!=0;
_eba ._ad ,_eba ._bee =_eba ._ad &0x7f,7;return _ce ,nil ;};_eba ._bee --;_ce =(_eba ._ad &(1<<_eba ._bee ))!=0;_eba ._ad &=1<<_eba ._bee -1;return _ce ,nil ;};func (_ffcd *Reader )ReadByte ()(byte ,error ){if _ffcd ._bee ==0{return _ffcd .readBufferByte ();
};return _ffcd .readUnalignedByte ();};func (_fa *BufferedWriter )Reset (){_fa ._fg =_fa ._fg [:0];_fa ._gcb =0;_fa ._ac =0};func (_gff *Writer )UseMSB ()bool {return _gff ._edg };func (_ebgbg *Writer )SkipBits (skip int )error {const _cadb ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";
if skip ==0{return nil ;};_gbg :=int (_ebgbg ._gdg )+skip ;if _gbg >=0&&_gbg < 8{_ebgbg ._gdg =uint8 (_gbg );return nil ;};_gbg =int (_ebgbg ._gdg )+_ebgbg ._bde *8+skip ;if _gbg < 0{return _fb .Errorf (_cadb ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_daf :=_gbg /8;_bac :=_gbg %8;_e .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");_e .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_ebgbg ._gdg ,_ebgbg ._bde ,int (_ebgbg ._gdg )+(_ebgbg ._bde )*8,len (_ebgbg ._db ),cap (_ebgbg ._db ));
_e .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_gbg ,_bac );_ebgbg ._gdg =uint8 (_bac );if _effd :=_daf -_ebgbg ._bde ;
_effd > 0&&len (_ebgbg ._db )-1< _daf {_e .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_effd );return _fb .Errorf (_cadb ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_ebgbg ._bde =_daf ;_e .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_ebgbg ._gdg ,_ebgbg ._bde );return nil ;
};func (_efc *Reader )Align ()(_dca byte ){_dca =_efc ._bee ;_efc ._bee =0;return _dca };func (_bg *Writer )FinishByte (){if _bg ._gdg ==0{return ;};_bg ._gdg =0;_bg ._bde ++;};var (_ _g .Reader =&Reader {};_ _g .ByteReader =&Reader {};_ _g .Seeker =&Reader {};
_ StreamReader =&Reader {};);func (_faa *BufferedWriter )fullOffset ()int {_df :=_faa ._gcb ;if _faa ._ac !=0{_df ++;};return _df ;};func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_gdd :true }};func (_bae *Reader )Mark (){_bae ._dcf =_bae ._aga ;
_bae ._fec =_bae ._bee ;_bae ._ded =_bae ._ad ;_bae ._agf =_bae ._dfc ;};func (_cce *Writer )WriteBits (bits uint64 ,number int )(_edf int ,_ffa error ){const _abb ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";
if number < 0||number > 64{return 0,_fb .Errorf (_abb ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};if number ==0{return 0,nil ;};_agcc :=number /8;if _agcc > 0{_eaf :=number -_agcc *8;for _dcfg :=_agcc -1;_dcfg >=0;_dcfg --{_bdd :=byte ((bits >>uint (_dcfg *8+_eaf ))&0xff);if _ffa =_cce .WriteByte (_bdd );_ffa !=nil {return _edf ,_fb .Wrapf (_ffa ,_abb ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_agcc -_dcfg +1);
};};number -=_agcc *8;if number ==0{return _agcc ,nil ;};};var _fafg int ;for _cbed :=0;_cbed < number ;_cbed ++{if _cce ._edg {_fafg =int ((bits >>uint (number -1-_cbed ))&0x1);}else {_fafg =int (bits &0x1);bits >>=1;};if _ffa =_cce .WriteBit (_fafg );
_ffa !=nil {return _edf ,_fb .Wrapf (_ffa ,_abb ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_cbed );};};return _agcc ,nil ;};func NewWriterMSB (data []byte )*Writer {return &Writer {_db :data ,_edg :true }};type BitWriter interface{WriteBit (_fea int )error ;
WriteBits (_gcg uint64 ,_cfa int )(_eab int ,_ed error );FinishByte ();SkipBits (_ddc int )error ;};var _ BinaryWriter =&BufferedWriter {};func (_aab *Writer )byteCapacity ()int {_dbe :=len (_aab ._db )-_aab ._bde ;if _aab ._gdg !=0{_dbe --;};return _dbe ;
};func (_aeb *Writer )WriteByte (c byte )error {return _aeb .writeByte (c )};func (_eddg *Reader )Reset (){_eddg ._aga =_eddg ._dcf ;_eddg ._bee =_eddg ._fec ;_eddg ._ad =_eddg ._ded ;_eddg ._dfc =_eddg ._agf ;};func (_cdf *Writer )ResetBit (){_cdf ._gdg =0};
func (_gg *Reader )Read (p []byte )(_ggd int ,_cgdb error ){if _gg ._bee ==0{return _gg .read (p );};for ;_ggd < len (p );_ggd ++{if p [_ggd ],_cgdb =_gg .readUnalignedByte ();_cgdb !=nil {return 0,_cgdb ;};};return _ggd ,nil ;};func (_d *BufferedWriter )Len ()int {return _d .byteCapacity ()};
func (_fcf *Reader )NewPartialReader (offset ,length int ,relative bool )(*Reader ,error ){if offset < 0{return nil ,_gf .New ("p\u0061\u0072\u0074\u0069\u0061\u006c\u0020\u0072\u0065\u0061\u0064\u0065\u0072\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062e \u006e\u0065\u0067a\u0074i\u0076\u0065");
};if relative {offset =_fcf ._bda ._ccb +offset ;};if length > 0{_fgf :=len (_fcf ._bda ._cbd );if relative {_fgf =_fcf ._bda ._fca ;};if offset +length > _fgf {return nil ,_ff .Errorf ("\u0070\u0061r\u0074\u0069\u0061l\u0020\u0072\u0065\u0061\u0064e\u0072\u0020\u006f\u0066\u0066se\u0074\u0028\u0025\u0064\u0029\u002b\u006c\u0065\u006e\u0067\u0074\u0068\u0028\u0025\u0064\u0029\u003d\u0025d\u0020i\u0073\u0020\u0067\u0072\u0065\u0061ter\u0020\u0074\u0068\u0061\u006e\u0020\u0074\u0068\u0065\u0020\u006f\u0072ig\u0069n\u0061\u006c\u0020\u0072e\u0061d\u0065r\u0020\u006ce\u006e\u0067th\u003a\u0020\u0025\u0064",offset ,length ,offset +length ,_fcf ._bda ._fca );
};};if length < 0{_cga :=len (_fcf ._bda ._cbd );if relative {_cga =_fcf ._bda ._fca ;};length =_cga -offset ;};return &Reader {_bda :readerSource {_cbd :_fcf ._bda ._cbd ,_fca :length ,_ccb :offset }},nil ;};func (_ef *BufferedWriter )expandIfNeeded (_ba int ){if !_ef .tryGrowByReslice (_ba ){_ef .grow (_ba );
};};func (_bdg *Reader )ConsumeRemainingBits ()(uint64 ,error ){if _bdg ._bee !=0{return _bdg .ReadBits (_bdg ._bee );};return 0,nil ;};type readerSource struct{_cbd []byte ;_ccb int ;_fca int ;};func (_gcc *BufferedWriter )Data ()[]byte {return _gcc ._fg };
func (_aca *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _aca .writeBit (uint8 (bit ));};return _fb .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");
};func (_fafc *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_fafc ._edd =-1;_fafc ._bee =0;_fafc ._ad =0;_fafc ._dfc =0;var _bab int64 ;switch whence {case _g .SeekStart :_bab =offset ;case _g .SeekCurrent :_bab =_fafc ._aga +offset ;case _g .SeekEnd :_bab =int64 (_fafc ._bda ._fca )+offset ;
default:return 0,_gf .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");};if _bab < 0{return 0,_gf .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");
};_fafc ._aga =_bab ;_fafc ._bee =0;return _bab ,nil ;};func (_af *BufferedWriter )ResetBitIndex (){_af ._ac =0};func (_c *BufferedWriter )FinishByte (){if _c ._ac ==0{return ;};_c ._ac =0;_c ._gcb ++;};type StreamReader interface{_g .Reader ;_g .ByteReader ;
_g .Seeker ;Align ()byte ;BitPosition ()int ;Mark ();Length ()uint64 ;ReadBit ()(int ,error );ReadBits (_fee byte )(uint64 ,error );ReadBool ()(bool ,error );ReadUint32 ()(uint32 ,error );Reset ();AbsolutePosition ()int64 ;};func (_aed *Reader )ReadUint32 ()(uint32 ,error ){_acc :=make ([]byte ,4);
_ ,_gfb :=_aed .Read (_acc );if _gfb !=nil {return 0,_gfb ;};return _gc .BigEndian .Uint32 (_acc ),nil ;};func (_ddd *Reader )RelativePosition ()int64 {return _ddd ._aga };type BufferedWriter struct{_fg []byte ;_ac uint8 ;_gcb int ;_gdd bool ;};