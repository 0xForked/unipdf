//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_b "encoding/binary";_g "errors";_ge "github.com/unidoc/unipdf/v3/common";_f "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_dg "io";);func (_aff *SubstreamReader )fillBuffer ()error {if uint64 (_aff ._afg .StreamPosition ())!=_aff ._agg +_aff ._ddag {_ ,_acf :=_aff ._afg .Seek (int64 (_aff ._agg +_aff ._ddag ),_dg .SeekStart );
if _acf !=nil {return _acf ;};};_aff ._aeg =_aff ._agg ;_gcg :=_eafe (uint64 (len (_aff ._cfe )),_aff ._egd -_aff ._agg );_dgg :=make ([]byte ,_gcg );_gce ,_ace :=_aff ._afg .Read (_dgg );if _ace !=nil {return _ace ;};for _ccdb :=uint64 (0);_ccdb < _gcg ;
_ccdb ++{_aff ._cfe [_ccdb ]=_dgg [_ccdb ];};_aff ._bbc =_aff ._aeg +uint64 (_gce );return nil ;};func (_cgaad *SubstreamReader )ReadByte ()(byte ,error ){if _cgaad ._ceg ==0{return _cgaad .readBufferByte ();};return _cgaad .readUnalignedByte ();};func (_ggag *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _ggag .writeBit (uint8 (bit ));
};return _f .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");};func (_ab *BufferedWriter )byteCapacity ()int {_ebc :=len (_ab ._c )-_ab ._bb ;
if _ab ._dga !=0{_ebc --;};return _ebc ;};func (_aaf *SubstreamReader )StreamPosition ()int64 {return int64 (_aaf ._agg )};func (_cda *Reader )ConsumeRemainingBits ()(uint64 ,error ){if _cda ._ec !=0{return _cda .ReadBits (_cda ._ec );};return 0,nil ;};
func (_eda *Writer )WriteByte (c byte )error {return _eda .writeByte (c )};var _ _dg .Writer =&BufferedWriter {};func (_ggc *SubstreamReader )BitPosition ()int {return int (_ggc ._ceg )};func (_caf *Writer )writeByte (_gdd byte )error {if _caf ._fd > len (_caf ._acfe )-1{return _dg .EOF ;
};if _caf ._fd ==len (_caf ._acfe )-1&&_caf ._bbe !=0{return _dg .EOF ;};if _caf ._bbe ==0{_caf ._acfe [_caf ._fd ]=_gdd ;_caf ._fd ++;return nil ;};if _caf ._cba {_caf ._acfe [_caf ._fd ]|=_gdd >>_caf ._bbe ;_caf ._fd ++;_caf ._acfe [_caf ._fd ]=byte (uint16 (_gdd )<<(8-_caf ._bbe )&0xff);
}else {_caf ._acfe [_caf ._fd ]|=byte (uint16 (_gdd )<<_caf ._bbe &0xff);_caf ._fd ++;_caf ._acfe [_caf ._fd ]=_gdd >>(8-_caf ._bbe );};return nil ;};func (_dgc *Reader )ReadByte ()(byte ,error ){if _dgc ._ec ==0{return _dgc .readBufferByte ();};return _dgc .readUnalignedByte ();
};func (_ebb *BufferedWriter )fullOffset ()int {_cd :=_ebb ._bb ;if _ebb ._dga !=0{_cd ++;};return _cd ;};func (_abgb *SubstreamReader )readBool ()(_cdb bool ,_efc error ){if _abgb ._ceg ==0{_abgb ._ecb ,_efc =_abgb .readBufferByte ();if _efc !=nil {return false ,_efc ;
};_cdb =(_abgb ._ecb &0x80)!=0;_abgb ._ecb ,_abgb ._ceg =_abgb ._ecb &0x7f,7;return _cdb ,nil ;};_abgb ._ceg --;_cdb =(_abgb ._ecb &(1<<_abgb ._ceg ))!=0;_abgb ._ecb &=1<<_abgb ._ceg -1;return _cdb ,nil ;};func (_gda *Writer )ResetBit (){_gda ._bbe =0};
func (_ced *SubstreamReader )ReadBool ()(bool ,error ){return _ced .readBool ()};func (_aeb *Reader )ReadBool ()(bool ,error ){return _aeb .readBool ()};var (_ _dg .Reader =&Reader {};_ _dg .ByteReader =&Reader {};_ _dg .Seeker =&Reader {};_ StreamReader =&Reader {};
);func (_daa *Reader )Length ()uint64 {return uint64 (len (_daa ._fea ))};func (_gf *BufferedWriter )WriteBits (bits uint64 ,number int )(_fgd int ,_ff error ){const _ac ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";
if number < 0||number > 64{return 0,_f .Errorf (_ac ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};_gb :=number /8;if _gb > 0{_fgc :=number -_gb *8;for _bga :=_gb -1;_bga >=0;_bga --{_dc :=byte ((bits >>uint (_bga *8+_fgc ))&0xff);if _ff =_gf .WriteByte (_dc );_ff !=nil {return _fgd ,_f .Wrapf (_ff ,_ac ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_gb -_bga +1);
};};number -=_gb *8;if number ==0{return _gb ,nil ;};};var _de int ;for _bdb :=0;_bdb < number ;_bdb ++{if _gf ._cf {_de =int ((bits >>uint (number -1-_bdb ))&0x1);}else {_de =int (bits &0x1);bits >>=1;};if _ff =_gf .WriteBit (_de );_ff !=nil {return _fgd ,_f .Wrapf (_ff ,_ac ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_bdb );
};};return _gb ,nil ;};func (_fgbe *Writer )FinishByte (){if _fgbe ._bbe ==0{return ;};_fgbe ._bbe =0;_fgbe ._fd ++;};func (_fgg *Reader )readBufferByte ()(byte ,error ){if _fgg ._bea >=int64 (len (_fgg ._fea )){return 0,_dg .EOF ;};_fgg ._cb =-1;_bec :=_fgg ._fea [_fgg ._bea ];
_fgg ._bea ++;_fgg ._geb =int (_bec );return _bec ,nil ;};const (_e =64;_gec =int (^uint (0)>>1););func (_ca *Writer )writeBit (_ddf uint8 )error {if len (_ca ._acfe )-1< _ca ._fd {return _dg .EOF ;};_dfcg :=_ca ._bbe ;if _ca ._cba {_dfcg =7-_ca ._bbe ;
};_ca ._acfe [_ca ._fd ]|=byte (uint16 (_ddf <<_dfcg )&0xff);_ca ._bbe ++;if _ca ._bbe ==8{_ca ._fd ++;_ca ._bbe =0;};return nil ;};var _ BinaryWriter =&BufferedWriter {};func (_ee *BufferedWriter )grow (_ae int ){if _ee ._c ==nil &&_ae < _e {_ee ._c =make ([]byte ,_ae ,_e );
return ;};_fgb :=len (_ee ._c );if _ee ._dga !=0{_fgb ++;};_be :=cap (_ee ._c );switch {case _ae <=_be /2-_fgb :_ge .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_ee ._c ),cap (_ee ._c ),_ae );
_ge .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_be ,_fgb );copy (_ee ._c ,_ee ._c [_ee .fullOffset ():]);
case _be > _gec -_be -_ae :_ge .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_db :=make ([]byte ,2*_be +_ae );copy (_db ,_ee ._c );_ee ._c =_db ;};_ee ._c =_ee ._c [:_fgb +_ae ];};
func (_ba *BufferedWriter )tryGrowByReslice (_dcg int )bool {if _dbd :=len (_ba ._c );_dcg <=cap (_ba ._c )-_dbd {_ba ._c =_ba ._c [:_dbd +_dcg ];return true ;};return false ;};func (_efd *Writer )WriteBits (bits uint64 ,number int )(_cbb int ,_efg error ){const _deb ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";
if number < 0||number > 64{return 0,_f .Errorf (_deb ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};if number ==0{return 0,nil ;};_gdc :=number /8;if _gdc > 0{_cde :=number -_gdc *8;for _cef :=_gdc -1;_cef >=0;_cef --{_gece :=byte ((bits >>uint (_cef *8+_cde ))&0xff);if _efg =_efd .WriteByte (_gece );_efg !=nil {return _cbb ,_f .Wrapf (_efg ,_deb ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_gdc -_cef +1);
};};number -=_gdc *8;if number ==0{return _gdc ,nil ;};};var _bbgf int ;for _eegf :=0;_eegf < number ;_eegf ++{if _efd ._cba {_bbgf =int ((bits >>uint (number -1-_eegf ))&0x1);}else {_bbgf =int (bits &0x1);bits >>=1;};if _efg =_efd .WriteBit (_bbgf );_efg !=nil {return _cbb ,_f .Wrapf (_efg ,_deb ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_eegf );
};};return _gdc ,nil ;};func (_dfcc *SubstreamReader )ReadBits (n byte )(_bcc uint64 ,_fbd error ){if n < _dfcc ._ceg {_ffc :=_dfcc ._ceg -n ;_bcc =uint64 (_dfcc ._ecb >>_ffc );_dfcc ._ecb &=1<<_ffc -1;_dfcc ._ceg =_ffc ;return _bcc ,nil ;};if n > _dfcc ._ceg {if _dfcc ._ceg > 0{_bcc =uint64 (_dfcc ._ecb );
n -=_dfcc ._ceg ;};var _cfge byte ;for n >=8{_cfge ,_fbd =_dfcc .readBufferByte ();if _fbd !=nil {return 0,_fbd ;};_bcc =_bcc <<8+uint64 (_cfge );n -=8;};if n > 0{if _dfcc ._ecb ,_fbd =_dfcc .readBufferByte ();_fbd !=nil {return 0,_fbd ;};_fgfc :=8-n ;
_bcc =_bcc <<n +uint64 (_dfcc ._ecb >>_fgfc );_dfcc ._ecb &=1<<_fgfc -1;_dfcc ._ceg =_fgfc ;}else {_dfcc ._ceg =0;};return _bcc ,nil ;};_dfcc ._ceg =0;return uint64 (_dfcc ._ecb ),nil ;};func (_ece *SubstreamReader )Length ()uint64 {return _ece ._egd };
type BinaryWriter interface{BitWriter ;_dg .Writer ;_dg .ByteWriter ;Data ()[]byte ;};func (_gac *Reader )Read (p []byte )(_deg int ,_dab error ){if _gac ._ec ==0{return _gac .read (p );};for ;_deg < len (p );_deg ++{if p [_deg ],_dab =_gac .readUnalignedByte ();
_dab !=nil {return 0,_dab ;};};return _deg ,nil ;};func (_gg *BufferedWriter )expandIfNeeded (_fc int ){if !_gg .tryGrowByReslice (_fc ){_gg .grow (_fc );};};func (_fge *BufferedWriter )WriteByte (bt byte )error {if _fge ._bb > len (_fge ._c )-1||(_fge ._bb ==len (_fge ._c )-1&&_fge ._dga !=0){_fge .expandIfNeeded (1);
};_fge .writeByte (bt );return nil ;};func (_af *BufferedWriter )writeByte (_ea byte ){switch {case _af ._dga ==0:_af ._c [_af ._bb ]=_ea ;_af ._bb ++;case _af ._cf :_af ._c [_af ._bb ]|=_ea >>_af ._dga ;_af ._bb ++;_af ._c [_af ._bb ]=byte (uint16 (_ea )<<(8-_af ._dga )&0xff);
default:_af ._c [_af ._bb ]|=byte (uint16 (_ea )<<_af ._dga &0xff);_af ._bb ++;_af ._c [_af ._bb ]=_ea >>(8-_af ._dga );};};func (_ce *BufferedWriter )Reset (){_ce ._c =_ce ._c [:0];_ce ._bb =0;_ce ._dga =0};func (_gc *Reader )ReadUint32 ()(uint32 ,error ){_ebe :=make ([]byte ,4);
_ ,_ccd :=_gc .Read (_ebe );if _ccd !=nil {return 0,_ccd ;};return _b .BigEndian .Uint32 (_ebe ),nil ;};type StreamReader interface{_dg .Reader ;_dg .ByteReader ;_dg .Seeker ;Align ()byte ;BitPosition ()int ;Mark ();Length ()uint64 ;ReadBit ()(int ,error );
ReadBits (_bfc byte )(uint64 ,error );ReadBool ()(bool ,error );ReadUint32 ()(uint32 ,error );Reset ();StreamPosition ()int64 ;};func (_ggcc *Writer )SkipBits (skip int )error {const _ffa ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";
if skip ==0{return nil ;};_gea :=int (_ggcc ._bbe )+skip ;if _gea >=0&&_gea < 8{_ggcc ._bbe =uint8 (_gea );return nil ;};_gea =int (_ggcc ._bbe )+_ggcc ._fd *8+skip ;if _gea < 0{return _f .Errorf (_ffa ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_gde :=_gea /8;_ffg :=_gea %8;_ge .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");_ge .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_ggcc ._bbe ,_ggcc ._fd ,int (_ggcc ._bbe )+(_ggcc ._fd )*8,len (_ggcc ._acfe ),cap (_ggcc ._acfe ));
_ge .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_gea ,_ffg );_ggcc ._bbe =uint8 (_ffg );if _bbg :=_gde -_ggcc ._fd ;
_bbg > 0&&len (_ggcc ._acfe )-1< _gde {_ge .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_bbg );return _f .Errorf (_ffa ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};
_ggcc ._fd =_gde ;_ge .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_ggcc ._bbe ,_ggcc ._fd );return nil ;};func _eafe (_aca ,_dac uint64 )uint64 {if _aca < _dac {return _aca ;
};return _dac ;};func (_fga *SubstreamReader )Mark (){_fga ._ccb =_fga ._agg ;_fga ._dcgb =_fga ._ceg };type Reader struct{_fea []byte ;_ga byte ;_ec byte ;_bea int64 ;_geb int ;_cb int ;_cg int64 ;_df byte ;_fb byte ;_dfc int ;};func (_ceb *Reader )Mark (){_ceb ._cg =_ceb ._bea ;
_ceb ._df =_ceb ._ec ;_ceb ._fb =_ceb ._ga ;_ceb ._dfc =_ceb ._geb ;};func (_ed *BufferedWriter )Data ()[]byte {return _ed ._c };func (_gae *Reader )BitPosition ()int {return int (_gae ._ec )};func (_cge *SubstreamReader )Align ()(_dce byte ){_dce =_cge ._ceg ;
_cge ._ceg =0;return _dce };func (_bfa *SubstreamReader )Read (b []byte )(_fgfa int ,_gga error ){if _bfa ._agg >=_bfa ._egd {_ge .Log .Trace ("\u0053\u0074\u0072e\u0061\u006d\u0050\u006fs\u003a\u0020\u0027\u0025\u0064\u0027\u0020>\u003d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027",_bfa ._agg ,_bfa ._egd );
return 0,_dg .EOF ;};for ;_fgfa < len (b );_fgfa ++{if b [_fgfa ],_gga =_bfa .readUnalignedByte ();_gga !=nil {if _gga ==_dg .EOF {return _fgfa ,nil ;};return 0,_gga ;};};return _fgfa ,nil ;};func (_fg *BufferedWriter )Write (d []byte )(int ,error ){_fg .expandIfNeeded (len (d ));
if _fg ._dga ==0{return _fg .writeFullBytes (d ),nil ;};return _fg .writeShiftedBytes (d ),nil ;};func (_cdg *Reader )ReadBit ()(_bfd int ,_gd error ){_cfgf ,_gd :=_cdg .readBool ();if _gd !=nil {return 0,_gd ;};if _cfgf {_bfd =1;};return _bfd ,nil ;};
func (_gdb *Writer )UseMSB ()bool {return _gdb ._cba };func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_cf :true }};type Writer struct{_acfe []byte ;_bbe uint8 ;_fd int ;_cba bool ;};func (_ggb *SubstreamReader )ReadUint32 ()(uint32 ,error ){_bee :=make ([]byte ,4);
_ ,_ggge :=_ggb .Read (_bee );if _ggge !=nil {return 0,_ggge ;};return _b .BigEndian .Uint32 (_bee ),nil ;};var _ BinaryWriter =&Writer {};func (_cec *Reader )read (_bcd []byte )(int ,error ){if _cec ._bea >=int64 (len (_cec ._fea )){return 0,_dg .EOF ;
};_cec ._cb =-1;_gee :=copy (_bcd ,_cec ._fea [_cec ._bea :]);_cec ._bea +=int64 (_gee );return _gee ,nil ;};func (_dd *BufferedWriter )ResetBitIndex (){_dd ._dga =0};func (_beaa *Reader )readUnalignedByte ()(_cga byte ,_ag error ){_cgaa :=_beaa ._ec ;
_cga =_beaa ._ga <<(8-_cgaa );_beaa ._ga ,_ag =_beaa .readBufferByte ();if _ag !=nil {return 0,_ag ;};_cga |=_beaa ._ga >>_cgaa ;_beaa ._ga &=1<<_cgaa -1;return _cga ,nil ;};func (_fgf *Reader )Reset (){_fgf ._bea =_fgf ._cg ;_fgf ._ec =_fgf ._df ;_fgf ._ga =_fgf ._fb ;
_fgf ._geb =_fgf ._dfc ;};func (_agf *SubstreamReader )Reset (){_agf ._agg =_agf ._ccb ;_agf ._ceg =_agf ._dcgb };func (_cfg *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;};_bd :=int (_cfg ._dga )+skip ;if _bd >=0&&_bd < 8{_cfg ._dga =uint8 (_bd );
return nil ;};_bd =int (_cfg ._dga )+_cfg ._bb *8+skip ;if _bd < 0{return _f .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_bg :=_bd /8;_bf :=_bd %8;_cfg ._dga =uint8 (_bf );if _da :=_bg -_cfg ._bb ;_da > 0&&len (_cfg ._c )-1< _bg {if _cfg ._dga !=0{_da ++;};_cfg .expandIfNeeded (_da );};_cfg ._bb =_bg ;return nil ;};func (_edb *BufferedWriter )FinishByte (){if _edb ._dga ==0{return ;
};_edb ._dga =0;_edb ._bb ++;};func NewWriter (data []byte )*Writer {return &Writer {_acfe :data }};func (_faf *BufferedWriter )writeShiftedBytes (_eeg []byte )int {for _ ,_ffd :=range _eeg {_faf .writeByte (_ffd );};return len (_eeg );};func (_abg *Reader )ReadBits (n byte )(_eac uint64 ,_ggg error ){if n < _abg ._ec {_cfd :=_abg ._ec -n ;
_eac =uint64 (_abg ._ga >>_cfd );_abg ._ga &=1<<_cfd -1;_abg ._ec =_cfd ;return _eac ,nil ;};if n > _abg ._ec {if _abg ._ec > 0{_eac =uint64 (_abg ._ga );n -=_abg ._ec ;};for n >=8{_dfa ,_eea :=_abg .readBufferByte ();if _eea !=nil {return 0,_eea ;};_eac =_eac <<8+uint64 (_dfa );
n -=8;};if n > 0{if _abg ._ga ,_ggg =_abg .readBufferByte ();_ggg !=nil {return 0,_ggg ;};_eaf :=8-n ;_eac =_eac <<n +uint64 (_abg ._ga >>_eaf );_abg ._ga &=1<<_eaf -1;_abg ._ec =_eaf ;}else {_abg ._ec =0;};return _eac ,nil ;};_abg ._ec =0;return uint64 (_abg ._ga ),nil ;
};type BufferedWriter struct{_c []byte ;_dga uint8 ;_bb int ;_cf bool ;};func (_abc *SubstreamReader )readBufferByte ()(byte ,error ){if _abc ._agg >=_abc ._egd {return 0,_dg .EOF ;};if _abc ._agg >=_abc ._bbc ||_abc ._agg < _abc ._aeg {if _ffb :=_abc .fillBuffer ();
_ffb !=nil {return 0,_ffb ;};};_bcdf :=_abc ._cfe [_abc ._agg -_abc ._aeg ];_abc ._agg ++;return _bcdf ,nil ;};type BitWriter interface{WriteBit (_cce int )error ;WriteBits (_dcc uint64 ,_fe int )(_eef int ,_ffe error );FinishByte ();SkipBits (_dbg int )error ;
};func (_aaa *Writer )Data ()[]byte {return _aaa ._acfe };func (_ad *Writer )Write (p []byte )(int ,error ){if len (p )> _ad .byteCapacity (){return 0,_dg .EOF ;};for _ ,_eec :=range p {if _bbf :=_ad .writeByte (_eec );_bbf !=nil {return 0,_bbf ;};};return len (p ),nil ;
};func (_eee *Reader )Align ()(_gebc byte ){_gebc =_eee ._ec ;_eee ._ec =0;return _gebc };func (_fgbd *SubstreamReader )ReadBit ()(_ebba int ,_cdc error ){_bgf ,_cdc :=_fgbd .readBool ();if _cdc !=nil {return 0,_cdc ;};if _bgf {_ebba =1;};return _ebba ,nil ;
};func (_eeec *Writer )byteCapacity ()int {_abb :=len (_eeec ._acfe )-_eeec ._fd ;if _eeec ._bbe !=0{_abb --;};return _abb ;};func (_dgb *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _f .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );
};if len (_dgb ._c )-1< _dgb ._bb {_dgb .expandIfNeeded (1);};_ege :=_dgb ._dga ;if _dgb ._cf {_ege =7-_dgb ._dga ;};_dgb ._c [_dgb ._bb ]|=byte (uint16 (bit <<_ege )&0xff);_dgb ._dga ++;if _dgb ._dga ==8{_dgb ._bb ++;_dgb ._dga =0;};return nil ;};func NewWriterMSB (data []byte )*Writer {return &Writer {_acfe :data ,_cba :true }};
func (_ebd *Reader )StreamPosition ()int64 {return _ebd ._bea };func (_bda *SubstreamReader )Seek (offset int64 ,whence int )(int64 ,error ){switch whence {case _dg .SeekStart :_bda ._agg =uint64 (offset );case _dg .SeekCurrent :_bda ._agg +=uint64 (offset );
case _dg .SeekEnd :_bda ._agg =_bda ._egd +uint64 (offset );default:return 0,_g .New ("\u0072\u0065\u0061d\u0065\u0072\u002e\u0053\u0075\u0062\u0073\u0074\u0072\u0065\u0061\u006d\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u0020\u0069\u006e\u0076\u0061\u006ci\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};_bda ._ceg =0;return int64 (_bda ._agg ),nil ;};func (_gfb *SubstreamReader )Offset ()uint64 {return _gfb ._ddag };type SubstreamReader struct{_agg uint64 ;_afg StreamReader ;_ddag uint64 ;_egd uint64 ;_cfe []byte ;_aeg uint64 ;_bbc uint64 ;_ecb byte ;
_ceg byte ;_ccb uint64 ;_dcgb byte ;};func NewReader (data []byte )*Reader {return &Reader {_fea :data }};var _ _dg .ByteWriter =&BufferedWriter {};func (_dccb *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_dccb ._cb =-1;var _beb int64 ;switch whence {case _dg .SeekStart :_beb =offset ;
case _dg .SeekCurrent :_beb =_dccb ._bea +offset ;case _dg .SeekEnd :_beb =int64 (len (_dccb ._fea ))+offset ;default:return 0,_g .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};if _beb < 0{return 0,_g .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");};_dccb ._bea =_beb ;
_dccb ._ec =0;return _beb ,nil ;};func (_beg *BufferedWriter )writeFullBytes (_bc []byte )int {_ged :=copy (_beg ._c [_beg .fullOffset ():],_bc );_beg ._bb +=_ged ;return _ged ;};func (_eb *BufferedWriter )Len ()int {return _eb .byteCapacity ()};func (_cbd *Reader )readBool ()(_dda bool ,_cceb error ){if _cbd ._ec ==0{_cbd ._ga ,_cceb =_cbd .readBufferByte ();
if _cceb !=nil {return false ,_cceb ;};_dda =(_cbd ._ga &0x80)!=0;_cbd ._ga ,_cbd ._ec =_cbd ._ga &0x7f,7;return _dda ,nil ;};_cbd ._ec --;_dda =(_cbd ._ga &(1<<_cbd ._ec ))!=0;_cbd ._ga &=1<<_cbd ._ec -1;return _dda ,nil ;};func (_eefg *SubstreamReader )readUnalignedByte ()(_bgd byte ,_gcb error ){_acb :=_eefg ._ceg ;
_bgd =_eefg ._ecb <<(8-_acb );_eefg ._ecb ,_gcb =_eefg .readBufferByte ();if _gcb !=nil {return 0,_gcb ;};_bgd |=_eefg ._ecb >>_acb ;_eefg ._ecb &=1<<_acb -1;return _bgd ,nil ;};func NewSubstreamReader (r StreamReader ,offset ,length uint64 )(*SubstreamReader ,error ){if r ==nil {return nil ,_g .New ("\u0072o\u006ft\u0020\u0072\u0065\u0061\u0064e\u0072\u0020i\u0073\u0020\u006e\u0069\u006c");
};_ge .Log .Trace ("\u004e\u0065\u0077\u0053\u0075\u0062\u0073\u0074r\u0065\u0061\u006dRe\u0061\u0064\u0065\u0072\u0020\u0061t\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u003a\u0020\u0025\u0064\u0020\u0077\u0069\u0074h\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a \u0025\u0064",offset ,length );
return &SubstreamReader {_afg :r ,_ddag :offset ,_egd :length ,_cfe :make ([]byte ,length )},nil ;};