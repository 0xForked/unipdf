//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_e "encoding/binary";_a "errors";_g "github.com/unidoc/unipdf/v3/common";_gb "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_c "io";);var (_ _c .Reader =&Reader {};_ _c .ByteReader =&Reader {};_ _c .Seeker =&Reader {};_ StreamReader =&Reader {};
);func (_gc *BufferedWriter )FinishByte (){if _gc ._de ==0{return ;};_gc ._de =0;_gc ._ec ++;};func (_ceaa *SubstreamReader )readUnalignedByte ()(_fbg byte ,_gbe error ){_bfe :=_ceaa ._bcc ;_fbg =_ceaa ._gfbc <<(8-_bfe );_ceaa ._gfbc ,_gbe =_ceaa .readBufferByte ();
if _gbe !=nil {return 0,_gbe ;};_fbg |=_ceaa ._gfbc >>_bfe ;_ceaa ._gfbc &=1<<_bfe -1;return _fbg ,nil ;};func (_gca *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;};_fd :=int (_gca ._de )+skip ;if _fd >=0&&_fd < 8{_gca ._de =uint8 (_fd );
return nil ;};_fd =int (_gca ._de )+_gca ._ec *8+skip ;if _fd < 0{return _gb .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_ge :=_fd /8;_cb :=_fd %8;_gca ._de =uint8 (_cb );if _ce :=_ge -_gca ._ec ;_ce > 0&&len (_gca ._gg )-1< _ge {if _gca ._de !=0{_ce ++;};_gca .expandIfNeeded (_ce );};_gca ._ec =_ge ;return nil ;};func (_ag *BufferedWriter )writeFullBytes (_ecb []byte )int {_fb :=copy (_ag ._gg [_ag .fullOffset ():],_ecb );
_ag ._ec +=_fb ;return _fb ;};type StreamReader interface{_c .Reader ;_c .ByteReader ;_c .Seeker ;Align ()byte ;BitPosition ()int ;Mark ();Length ()uint64 ;ReadBit ()(int ,error );ReadBits (_eed byte )(uint64 ,error );ReadBool ()(bool ,error );ReadUint32 ()(uint32 ,error );
Reset ();StreamPosition ()int64 ;};func (_dbfga *Reader )readBool ()(_gfb bool ,_gga error ){if _dbfga ._cea ==0{_dbfga ._bd ,_gga =_dbfga .readBufferByte ();if _gga !=nil {return false ,_gga ;};_gfb =(_dbfga ._bd &0x80)!=0;_dbfga ._bd ,_dbfga ._cea =_dbfga ._bd &0x7f,7;
return _gfb ,nil ;};_dbfga ._cea --;_gfb =(_dbfga ._bd &(1<<_dbfga ._cea ))!=0;_dbfga ._bd &=1<<_dbfga ._cea -1;return _gfb ,nil ;};func (_b *BufferedWriter )Data ()[]byte {return _b ._gg };func NewWriter (data []byte )*Writer {return &Writer {_gaf :data }};
func (_ee *BufferedWriter )writeByte (_fe byte ){switch {case _ee ._de ==0:_ee ._gg [_ee ._ec ]=_fe ;_ee ._ec ++;case _ee ._cd :_ee ._gg [_ee ._ec ]|=_fe >>_ee ._de ;_ee ._ec ++;_ee ._gg [_ee ._ec ]=byte (uint16 (_fe )<<(8-_ee ._de )&0xff);default:_ee ._gg [_ee ._ec ]|=byte (uint16 (_fe )<<_ee ._de &0xff);
_ee ._ec ++;_ee ._gg [_ee ._ec ]=_fe >>(8-_ee ._de );};};func (_adae *Writer )WriteByte (c byte )error {return _adae .writeByte (c )};func (_fgg *Reader )StreamPosition ()int64 {return _fgg ._eeb };func (_cdg *BufferedWriter )WriteByte (bt byte )error {if _cdg ._ec > len (_cdg ._gg )-1||(_cdg ._ec ==len (_cdg ._gg )-1&&_cdg ._de !=0){_cdg .expandIfNeeded (1);
};_cdg .writeByte (bt );return nil ;};func _ageg (_cdf ,_cac uint64 )uint64 {if _cdf < _cac {return _cdf ;};return _cac ;};func (_dfb *Reader )ReadBits (n byte )(_geac uint64 ,_aeb error ){if n < _dfb ._cea {_cad :=_dfb ._cea -n ;_geac =uint64 (_dfb ._bd >>_cad );
_dfb ._bd &=1<<_cad -1;_dfb ._cea =_cad ;return _geac ,nil ;};if n > _dfb ._cea {if _dfb ._cea > 0{_geac =uint64 (_dfb ._bd );n -=_dfb ._cea ;};for n >=8{_cce ,_dgc :=_dfb .readBufferByte ();if _dgc !=nil {return 0,_dgc ;};_geac =_geac <<8+uint64 (_cce );
n -=8;};if n > 0{if _dfb ._bd ,_aeb =_dfb .readBufferByte ();_aeb !=nil {return 0,_aeb ;};_aac :=8-n ;_geac =_geac <<n +uint64 (_dfb ._bd >>_aac );_dfb ._bd &=1<<_aac -1;_dfb ._cea =_aac ;}else {_dfb ._cea =0;};return _geac ,nil ;};_dfb ._cea =0;return uint64 (_dfb ._bd ),nil ;
};func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_cd :true }};type BinaryWriter interface{BitWriter ;_c .Writer ;_c .ByteWriter ;Data ()[]byte ;};func (_gbc *SubstreamReader )Mark (){_gbc ._ecf =_gbc ._dee ;_gbc ._be =_gbc ._bcc };func (_add *Reader )Align ()(_gea byte ){_gea =_add ._cea ;
_add ._cea =0;return _gea };func (_edf *BufferedWriter )writeShiftedBytes (_gf []byte )int {for _ ,_cfb :=range _gf {_edf .writeByte (_cfb );};return len (_gf );};func (_ece *BufferedWriter )Reset (){_ece ._gg =_ece ._gg [:0];_ece ._ec =0;_ece ._de =0};
func (_eeg *SubstreamReader )Offset ()uint64 {return _eeg ._afe };type BitWriter interface{WriteBit (_ga int )error ;WriteBits (_cg uint64 ,_bbdc int )(_cdc int ,_cgg error );FinishByte ();SkipBits (_gdc int )error ;};func (_cdb *SubstreamReader )Read (b []byte )(_ffd int ,_ggg error ){if _cdb ._dee >=_cdb ._gce {_g .Log .Trace ("\u0053\u0074\u0072e\u0061\u006d\u0050\u006fs\u003a\u0020\u0027\u0025\u0064\u0027\u0020>\u003d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027",_cdb ._dee ,_cdb ._gce );
return 0,_c .EOF ;};for ;_ffd < len (b );_ffd ++{if b [_ffd ],_ggg =_cdb .readUnalignedByte ();_ggg !=nil {if _ggg ==_c .EOF {return _ffd ,nil ;};return 0,_ggg ;};};return _ffd ,nil ;};func (_ecc *SubstreamReader )Length ()uint64 {return _ecc ._gce };func (_bfcb *Writer )FinishByte (){if _bfcb ._dbb ==0{return ;
};_bfcb ._dbb =0;_bfcb ._geae ++;};func (_gcd *SubstreamReader )Align ()(_agc byte ){_agc =_gcd ._bcc ;_gcd ._bcc =0;return _agc };func (_aaf *Reader )readUnalignedByte ()(_adg byte ,_dbe error ){_bca :=_aaf ._cea ;_adg =_aaf ._bd <<(8-_bca );_aaf ._bd ,_dbe =_aaf .readBufferByte ();
if _dbe !=nil {return 0,_dbe ;};_adg |=_aaf ._bd >>_bca ;_aaf ._bd &=1<<_bca -1;return _adg ,nil ;};func (_fdf *BufferedWriter )grow (_fca int ){if _fdf ._gg ==nil &&_fca < _fg {_fdf ._gg =make ([]byte ,_fca ,_fg );return ;};_bbd :=len (_fdf ._gg );if _fdf ._de !=0{_bbd ++;
};_aa :=cap (_fdf ._gg );switch {case _fca <=_aa /2-_bbd :_g .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_fdf ._gg ),cap (_fdf ._gg ),_fca );
_g .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_aa ,_bbd );copy (_fdf ._gg ,_fdf ._gg [_fdf .fullOffset ():]);
case _aa > _d -_aa -_fca :_g .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_cec :=make ([]byte ,2*_aa +_fca );copy (_cec ,_fdf ._gg );_fdf ._gg =_cec ;};_fdf ._gg =_fdf ._gg [:_bbd +_fca ];
};type Writer struct{_gaf []byte ;_dbb uint8 ;_geae int ;_gde bool ;};func (_eggg *Writer )SkipBits (skip int )error {const _gceg ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";if skip ==0{return nil ;};_bbb :=int (_eggg ._dbb )+skip ;
if _bbb >=0&&_bbb < 8{_eggg ._dbb =uint8 (_bbb );return nil ;};_bbb =int (_eggg ._dbb )+_eggg ._geae *8+skip ;if _bbb < 0{return _gb .Errorf (_gceg ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_bbaf :=_bbb /8;
_bgg :=_bbb %8;_g .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");_g .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_eggg ._dbb ,_eggg ._geae ,int (_eggg ._dbb )+(_eggg ._geae )*8,len (_eggg ._gaf ),cap (_eggg ._gaf ));
_g .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_bbb ,_bgg );_eggg ._dbb =uint8 (_bgg );if _ab :=_bbaf -_eggg ._geae ;
_ab > 0&&len (_eggg ._gaf )-1< _bbaf {_g .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_ab );return _gb .Errorf (_gceg ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_eggg ._geae =_bbaf ;
_g .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_eggg ._dbb ,_eggg ._geae );return nil ;};func (_gdb *Writer )ResetBit (){_gdb ._dbb =0};
func (_aad *BufferedWriter )tryGrowByReslice (_aeg int )bool {if _dd :=len (_aad ._gg );_aeg <=cap (_aad ._gg )-_dd {_aad ._gg =_aad ._gg [:_dd +_aeg ];return true ;};return false ;};func (_bge *SubstreamReader )BitPosition ()int {return int (_bge ._bcc )};
func (_bda *Reader )ConsumeRemainingBits (){if _bda ._cea !=0{_ ,_cde :=_bda .ReadBits (_bda ._cea );if _cde !=nil {_g .Log .Debug ("\u0043\u006f\u006e\u0073\u0075\u006d\u0065\u0052\u0065\u006da\u0069\u006e\u0069\u0067\u0042\u0069\u0074s\u0020\u0066\u0061\u0069\u006c\u0065\u0064\u003a\u0020\u0025\u0076",_cde );
};};};func (_fbf *SubstreamReader )ReadBit ()(_eddf int ,_dgb error ){_bgd ,_dgb :=_fbf .readBool ();if _dgb !=nil {return 0,_dgb ;};if _bgd {_eddf =1;};return _eddf ,nil ;};func (_ba *Reader )read (_dfe []byte )(int ,error ){if _ba ._eeb >=int64 (len (_ba ._bbf )){return 0,_c .EOF ;
};_ba ._gfd =-1;_eggc :=copy (_dfe ,_ba ._bbf [_ba ._eeb :]);_ba ._eeb +=int64 (_eggc );return _eggc ,nil ;};func (_fde *Reader )ReadBit ()(_gef int ,_addd error ){_dbfg ,_addd :=_fde .readBool ();if _addd !=nil {return 0,_addd ;};if _dbfg {_gef =1;};return _gef ,nil ;
};func (_ddg *Writer )UseMSB ()bool {return _ddg ._gde };var _ _c .ByteWriter =&BufferedWriter {};func (_ada *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_ada ._gfd =-1;var _egg int64 ;switch whence {case _c .SeekStart :_egg =offset ;case _c .SeekCurrent :_egg =_ada ._eeb +offset ;
case _c .SeekEnd :_egg =int64 (len (_ada ._bbf ))+offset ;default:return 0,_a .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};if _egg < 0{return 0,_a .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");};_ada ._eeb =_egg ;
_ada ._cea =0;return _egg ,nil ;};var _ _c .Writer =&BufferedWriter {};const (_fg =64;_d =int (^uint (0)>>1););func (_acca *Writer )writeByte (_dgd byte )error {if _acca ._geae > len (_acca ._gaf )-1{return _c .EOF ;};if _acca ._geae ==len (_acca ._gaf )-1&&_acca ._dbb !=0{return _c .EOF ;
};if _acca ._dbb ==0{_acca ._gaf [_acca ._geae ]=_dgd ;_acca ._geae ++;return nil ;};if _acca ._gde {_acca ._gaf [_acca ._geae ]|=_dgd >>_acca ._dbb ;_acca ._geae ++;_acca ._gaf [_acca ._geae ]=byte (uint16 (_dgd )<<(8-_acca ._dbb )&0xff);}else {_acca ._gaf [_acca ._geae ]|=byte (uint16 (_dgd )<<_acca ._dbb &0xff);
_acca ._geae ++;_acca ._gaf [_acca ._geae ]=_dgd >>(8-_acca ._dbb );};return nil ;};type Reader struct{_bbf []byte ;_bd byte ;_cea byte ;_eeb int64 ;_ad int ;_gfd int ;_df int64 ;_caf byte ;};func (_fa *BufferedWriter )ResetBitIndex (){_fa ._de =0};func (_adaf *SubstreamReader )ReadBool ()(bool ,error ){return _adaf .readBool ()};
func (_dde *Reader )ReadByte ()(byte ,error ){if _dde ._cea ==0{return _dde .readBufferByte ();};return _dde .readUnalignedByte ();};func (_bcb *SubstreamReader )StreamPosition ()int64 {return int64 (_bcb ._dee )};func NewReader (data []byte )*Reader {return &Reader {_bbf :data }};
func NewSubstreamReader (r StreamReader ,offset ,length uint64 )(*SubstreamReader ,error ){if r ==nil {return nil ,_a .New ("\u0072o\u006ft\u0020\u0072\u0065\u0061\u0064e\u0072\u0020i\u0073\u0020\u006e\u0069\u006c");};_g .Log .Trace ("\u004e\u0065\u0077\u0053\u0075\u0062\u0073\u0074r\u0065\u0061\u006dRe\u0061\u0064\u0065\u0072\u0020\u0061t\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u003a\u0020\u0025\u0064\u0020\u0077\u0069\u0074h\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a \u0025\u0064",offset ,length );
return &SubstreamReader {_ccg :r ,_afe :offset ,_gce :length ,_bfc :make ([]byte ,length )},nil ;};func (_cdgb *BufferedWriter )WriteBits (bits uint64 ,number int )(_bg int ,_da error ){const _ded ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";
if number < 0||number > 64{return 0,_gb .Errorf (_ded ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};_bb :=number /8;if _bb > 0{_dae :=number -_bb *8;for _fcc :=_bb -1;_fcc >=0;_fcc --{_eg :=byte ((bits >>uint (_fcc *8+_dae ))&0xff);if _da =_cdgb .WriteByte (_eg );_da !=nil {return _bg ,_gb .Wrapf (_da ,_ded ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_bb -_fcc +1);
};};number -=_bb *8;if number ==0{return _bb ,nil ;};};var _ae int ;for _db :=0;_db < number ;_db ++{if _cdgb ._cd {_ae =int ((bits >>uint (number -1-_db ))&0x1);}else {_ae =int (bits &0x1);bits >>=1;};if _da =_cdgb .WriteBit (_ae );_da !=nil {return _bg ,_gb .Wrapf (_da ,_ded ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_db );
};};return _bb ,nil ;};func (_edg *BufferedWriter )byteCapacity ()int {_ff :=len (_edg ._gg )-_edg ._ec ;if _edg ._de !=0{_ff --;};return _ff ;};func (_dc *Reader )Read (p []byte )(_age int ,_ffe error ){if _dc ._cea ==0{return _dc .read (p );};for ;_age < len (p );
_age ++{if p [_age ],_ffe =_dc .readUnalignedByte ();_ffe !=nil {return 0,_ffe ;};};return _age ,nil ;};func (_ecee *Writer )byteCapacity ()int {_cfbe :=len (_ecee ._gaf )-_ecee ._geae ;if _ecee ._dbb !=0{_cfbe --;};return _cfbe ;};func (_bfa *SubstreamReader )readBufferByte ()(byte ,error ){if _bfa ._dee >=_bfa ._gce {return 0,_c .EOF ;
};if _bfa ._dee >=_bfa ._deb ||_bfa ._dee < _bfa ._agf {if _daac :=_bfa .fillBuffer ();_daac !=nil {return 0,_daac ;};};_bfg :=_bfa ._bfc [_bfa ._dee -_bfa ._agf ];_bfa ._dee ++;return _bfg ,nil ;};func (_ddd *SubstreamReader )ReadUint32 ()(uint32 ,error ){_fab :=make ([]byte ,4);
_ ,_cecc :=_ddd .Read (_fab );if _cecc !=nil {return 0,_cecc ;};return _e .BigEndian .Uint32 (_fab ),nil ;};func (_cba *BufferedWriter )fullOffset ()int {_bbe :=_cba ._ec ;if _cba ._de !=0{_bbe ++;};return _bbe ;};func (_bf *BufferedWriter )Write (d []byte )(int ,error ){_bf .expandIfNeeded (len (d ));
if _bf ._de ==0{return _bf .writeFullBytes (d ),nil ;};return _bf .writeShiftedBytes (d ),nil ;};func (_aed *SubstreamReader )fillBuffer ()error {if uint64 (_aed ._ccg .StreamPosition ())!=_aed ._dee +_aed ._afe {_ ,_daa :=_aed ._ccg .Seek (int64 (_aed ._dee +_aed ._afe ),_c .SeekStart );
if _daa !=nil {return _daa ;};};_aed ._agf =_aed ._dee ;_ccc :=_ageg (uint64 (len (_aed ._bfc )),_aed ._gce -_aed ._dee );_gfg :=make ([]byte ,_ccc );_fdc ,_fafc :=_aed ._ccg .Read (_gfg );if _fafc !=nil {return _fafc ;};for _eddfb :=uint64 (0);_eddfb < _ccc ;
_eddfb ++{_aed ._bfc [_eddfb ]=_gfg [_eddfb ];};_aed ._deb =_aed ._agf +uint64 (_fdc );return nil ;};func (_ced *SubstreamReader )Reset (){_ced ._dee =_ced ._ecf ;_ced ._bcc =_ced ._be };func NewWriterMSB (data []byte )*Writer {return &Writer {_gaf :data ,_gde :true }};
func (_cc *BufferedWriter )Len ()int {return _cc .byteCapacity ()};var _ BinaryWriter =&Writer {};type SubstreamReader struct{_dee uint64 ;_ccg StreamReader ;_afe uint64 ;_gce uint64 ;_bfc []byte ;_agf uint64 ;_deb uint64 ;_gfbc byte ;_bcc byte ;_ecf uint64 ;
_be byte ;};func (_gdd *Reader )Length ()uint64 {return uint64 (len (_gdd ._bbf ))};func (_eef *Reader )Mark (){_eef ._df =_eef ._eeb ;_eef ._caf =_eef ._cea };func (_ca *BufferedWriter )expandIfNeeded (_bba int ){if !_ca .tryGrowByReslice (_bba ){_ca .grow (_bba );
};};func (_bc *Reader )BitPosition ()int {return int (_bc ._cea )};func (_cedf *Writer )Data ()[]byte {return _cedf ._gaf };func (_faf *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _gb .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );
};if len (_faf ._gg )-1< _faf ._ec {_faf .expandIfNeeded (1);};_cf :=_faf ._de ;if _faf ._cd {_cf =7-_faf ._de ;};_faf ._gg [_faf ._ec ]|=byte (uint16 (bit <<_cf )&0xff);_faf ._de ++;if _faf ._de ==8{_faf ._ec ++;_faf ._de =0;};return nil ;};func (_dbgc *SubstreamReader )Seek (offset int64 ,whence int )(int64 ,error ){switch whence {case _c .SeekStart :_dbgc ._dee =uint64 (offset );
case _c .SeekCurrent :_dbgc ._dee +=uint64 (offset );case _c .SeekEnd :_dbgc ._dee =_dbgc ._gce +uint64 (offset );default:return 0,_a .New ("\u0072\u0065\u0061d\u0065\u0072\u002e\u0053\u0075\u0062\u0073\u0074\u0072\u0065\u0061\u006d\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u0020\u0069\u006e\u0076\u0061\u006ci\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};_dbgc ._bcc =0;return int64 (_dbgc ._dee ),nil ;};type BufferedWriter struct{_gg []byte ;_de uint8 ;_ec int ;_cd bool ;};func (_geb *Reader )Reset (){_geb ._eeb =_geb ._df ;_geb ._cea =_geb ._caf };func (_edd *Reader )ReadBool ()(bool ,error ){return _edd .readBool ()};
func (_ceag *Writer )writeBit (_ecca uint8 )error {if len (_ceag ._gaf )-1< _ceag ._geae {return _c .EOF ;};_dgcg :=_ceag ._dbb ;if _ceag ._gde {_dgcg =7-_ceag ._dbb ;};_ceag ._gaf [_ceag ._geae ]|=byte (uint16 (_ecca <<_dgcg )&0xff);_ceag ._dbb ++;if _ceag ._dbb ==8{_ceag ._geae ++;
_ceag ._dbb =0;};return nil ;};func (_debf *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _debf .writeBit (uint8 (bit ));};return _gb .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");
};func (_dbg *Reader )ReadUint32 ()(uint32 ,error ){_ac :=make ([]byte ,4);_ ,_egb :=_dbg .Read (_ac );if _egb !=nil {return 0,_egb ;};return _e .BigEndian .Uint32 (_ac ),nil ;};func (_eba *SubstreamReader )readBool ()(_ecd bool ,_gcc error ){if _eba ._bcc ==0{_eba ._gfbc ,_gcc =_eba .readBufferByte ();
if _gcc !=nil {return false ,_gcc ;};_ecd =(_eba ._gfbc &0x80)!=0;_eba ._gfbc ,_eba ._bcc =_eba ._gfbc &0x7f,7;return _ecd ,nil ;};_eba ._bcc --;_ecd =(_eba ._gfbc &(1<<_eba ._bcc ))!=0;_eba ._gfbc &=1<<_eba ._bcc -1;return _ecd ,nil ;};func (_fdd *SubstreamReader )ReadBits (n byte )(_ceb uint64 ,_fgc error ){if n < _fdd ._bcc {_dbee :=_fdd ._bcc -n ;
_ceb =uint64 (_fdd ._gfbc >>_dbee );_fdd ._gfbc &=1<<_dbee -1;_fdd ._bcc =_dbee ;return _ceb ,nil ;};if n > _fdd ._bcc {if _fdd ._bcc > 0{_ceb =uint64 (_fdd ._gfbc );n -=_fdd ._bcc ;};var _adddc byte ;for n >=8{_adddc ,_fgc =_fdd .readBufferByte ();if _fgc !=nil {return 0,_fgc ;
};_ceb =_ceb <<8+uint64 (_adddc );n -=8;};if n > 0{if _fdd ._gfbc ,_fgc =_fdd .readBufferByte ();_fgc !=nil {return 0,_fgc ;};_bbfb :=8-n ;_ceb =_ceb <<n +uint64 (_fdd ._gfbc >>_bbfb );_fdd ._gfbc &=1<<_bbfb -1;_fdd ._bcc =_bbfb ;}else {_fdd ._bcc =0;};
return _ceb ,nil ;};_fdd ._bcc =0;return uint64 (_fdd ._gfbc ),nil ;};var _ BinaryWriter =&BufferedWriter {};func (_bfb *Reader )readBufferByte ()(byte ,error ){if _bfb ._eeb >=int64 (len (_bfb ._bbf )){return 0,_c .EOF ;};_bfb ._gfd =-1;_acc :=_bfb ._bbf [_bfb ._eeb ];
_bfb ._eeb ++;_bfb ._ad =int (_acc );return _acc ,nil ;};func (_eebd *SubstreamReader )ReadByte ()(byte ,error ){if _eebd ._bcc ==0{return _eebd .readBufferByte ();};return _eebd .readUnalignedByte ();};func (_aga *Writer )Write (p []byte )(int ,error ){if len (p )> _aga .byteCapacity (){return 0,_c .EOF ;
};for _ ,_deg :=range p {if _ddga :=_aga .writeByte (_deg );_ddga !=nil {return 0,_ddga ;};};return len (p ),nil ;};func (_ccd *Writer )WriteBits (bits uint64 ,number int )(_gcb int ,_agcd error ){const _agcb ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";
if number < 0||number > 64{return 0,_gb .Errorf (_agcb ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};if number ==0{return 0,nil ;};_fbb :=number /8;if _fbb > 0{_aca :=number -_fbb *8;for _cdd :=_fbb -1;_cdd >=0;_cdd --{_gab :=byte ((bits >>uint (_cdd *8+_aca ))&0xff);if _agcd =_ccd .WriteByte (_gab );_agcd !=nil {return _gcb ,_gb .Wrapf (_agcd ,_agcb ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_fbb -_cdd +1);
};};number -=_fbb *8;if number ==0{return _fbb ,nil ;};};var _bbfg int ;for _ea :=0;_ea < number ;_ea ++{if _ccd ._gde {_bbfg =int ((bits >>uint (number -1-_ea ))&0x1);}else {_bbfg =int (bits &0x1);bits >>=1;};if _agcd =_ccd .WriteBit (_bbfg );_agcd !=nil {return _gcb ,_gb .Wrapf (_agcd ,_agcb ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_ea );
};};return _fbb ,nil ;};