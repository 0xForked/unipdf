//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_c "encoding/binary";_a "errors";_cc "github.com/unidoc/unipdf/v3/common";_ab "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_f "io";);func (_gbd *SubstreamReader )ReadBool ()(bool ,error ){return _gbd .readBool ()};func (_cff *SubstreamReader )Align ()(_ba byte ){_ba =_cff ._ebb ;
_cff ._ebb =0;return _ba };func (_fda *Reader )ReadUint32 ()(uint32 ,error ){_bdb :=make ([]byte ,4);_ ,_cadf :=_fda .Read (_bdb );if _cadf !=nil {return 0,_cadf ;};return _c .BigEndian .Uint32 (_bdb ),nil ;};func (_ge *BufferedWriter )WriteBits (bits uint64 ,number int )(_fg int ,_dbe error ){const _ef ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";
if number < 0||number > 64{return 0,_ab .Errorf (_ef ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};_eb :=number /8;if _eb > 0{_df :=number -_eb *8;for _ec :=_eb -1;_ec >=0;_ec --{_cca :=byte ((bits >>uint (_ec *8+_df ))&0xff);if _dbe =_ge .WriteByte (_cca );_dbe !=nil {return _fg ,_ab .Wrapf (_dbe ,_ef ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_eb -_ec +1);
};};number -=_eb *8;if number ==0{return _eb ,nil ;};};var _bc int ;for _bg :=0;_bg < number ;_bg ++{if _ge ._ag {_bc =int ((bits >>uint (number -1-_bg ))&0x1);}else {_bc =int (bits &0x1);bits >>=1;};if _dbe =_ge .WriteBit (_bc );_dbe !=nil {return _fg ,_ab .Wrapf (_dbe ,_ef ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_bg );
};};return _eb ,nil ;};func (_bd *BufferedWriter )Len ()int {return _bd .byteCapacity ()};func (_bfc *Reader )readBool ()(_bdbb bool ,_gce error ){if _bfc ._cbg ==0{_bfc ._egb ,_gce =_bfc .readBufferByte ();if _gce !=nil {return false ,_gce ;};_bdbb =(_bfc ._egb &0x80)!=0;
_bfc ._egb ,_bfc ._cbg =_bfc ._egb &0x7f,7;return _bdbb ,nil ;};_bfc ._cbg --;_bdbb =(_bfc ._egb &(1<<_bfc ._cbg ))!=0;_bfc ._egb &=1<<_bfc ._cbg -1;return _bdbb ,nil ;};func (_gg *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _ab .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );
};if len (_gg ._aa )-1< _gg ._gb {_gg .expandIfNeeded (1);};_dbg :=_gg ._cd ;if _gg ._ag {_dbg =7-_gg ._cd ;};_gg ._aa [_gg ._gb ]|=byte (uint16 (bit <<_dbg )&0xff);_gg ._cd ++;if _gg ._cd ==8{_gg ._gb ++;_gg ._cd =0;};return nil ;};func (_dcf *Reader )StreamPosition ()int64 {return _dcf ._gffg };
func NewReader (data []byte )*Reader {return &Reader {_ece :data }};type SubstreamReader struct{_bfb uint64 ;_ade StreamReader ;_dbb uint64 ;_fef uint64 ;_aec []byte ;_ff uint64 ;_da uint64 ;_abg byte ;_ebb byte ;_gbf uint64 ;_eag byte ;};func (_dc *Reader )ReadBool ()(bool ,error ){return _dc .readBool ()};
func NewWriterMSB (data []byte )*Writer {return &Writer {_deb :data ,_eeg :true }};type Writer struct{_deb []byte ;_cde uint8 ;_cggc int ;_eeg bool ;};type StreamReader interface{_f .Reader ;_f .ByteReader ;_f .Seeker ;Align ()byte ;BitPosition ()int ;
Mark ();Length ()uint64 ;ReadBit ()(int ,error );ReadBits (_cea byte )(uint64 ,error );ReadBool ()(bool ,error );ReadUint32 ()(uint32 ,error );Reset ();StreamPosition ()int64 ;};func (_eae *BufferedWriter )grow (_eg int ){if _eae ._aa ==nil &&_eg < _ac {_eae ._aa =make ([]byte ,_eg ,_ac );
return ;};_age :=len (_eae ._aa );if _eae ._cd !=0{_age ++;};_fc :=cap (_eae ._aa );switch {case _eg <=_fc /2-_age :_cc .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_eae ._aa ),cap (_eae ._aa ),_eg );
_cc .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_fc ,_age );copy (_eae ._aa ,_eae ._aa [_eae .fullOffset ():]);
case _fc > _ad -_fc -_eg :_cc .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_fb :=make ([]byte ,2*_fc +_eg );copy (_fb ,_eae ._aa );_eae ._aa =_fb ;};_eae ._aa =_eae ._aa [:_age +_eg ];
};func (_afdb *Writer )SkipBits (skip int )error {const _cab ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";if skip ==0{return nil ;};_gedg :=int (_afdb ._cde )+skip ;if _gedg >=0&&_gedg < 8{_afdb ._cde =uint8 (_gedg );
return nil ;};_gedg =int (_afdb ._cde )+_afdb ._cggc *8+skip ;if _gedg < 0{return _ab .Errorf (_cab ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_bbc :=_gedg /8;_cae :=_gedg %8;_cc .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");
_cc .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_afdb ._cde ,_afdb ._cggc ,int (_afdb ._cde )+(_afdb ._cggc )*8,len (_afdb ._deb ),cap (_afdb ._deb ));
_cc .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_gedg ,_cae );_afdb ._cde =uint8 (_cae );
if _gfb :=_bbc -_afdb ._cggc ;_gfb > 0&&len (_afdb ._deb )-1< _bbc {_cc .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_gfb );return _ab .Errorf (_cab ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_afdb ._cggc =_bbc ;_cc .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_afdb ._cde ,_afdb ._cggc );return nil ;
};func (_gfdb *Reader )ReadBits (n byte )(_fccg uint64 ,_fba error ){if n < _gfdb ._cbg {_egf :=_gfdb ._cbg -n ;_fccg =uint64 (_gfdb ._egb >>_egf );_gfdb ._egb &=1<<_egf -1;_gfdb ._cbg =_egf ;return _fccg ,nil ;};if n > _gfdb ._cbg {if _gfdb ._cbg > 0{_fccg =uint64 (_gfdb ._egb );
n -=_gfdb ._cbg ;};for n >=8{_cgf ,_gae :=_gfdb .readBufferByte ();if _gae !=nil {return 0,_gae ;};_fccg =_fccg <<8+uint64 (_cgf );n -=8;};if n > 0{if _gfdb ._egb ,_fba =_gfdb .readBufferByte ();_fba !=nil {return 0,_fba ;};_eea :=8-n ;_fccg =_fccg <<n +uint64 (_gfdb ._egb >>_eea );
_gfdb ._egb &=1<<_eea -1;_gfdb ._cbg =_eea ;}else {_gfdb ._cbg =0;};return _fccg ,nil ;};_gfdb ._cbg =0;return uint64 (_gfdb ._egb ),nil ;};func (_fdg *Writer )writeByte (_ffd byte )error {if _fdg ._cggc > len (_fdg ._deb )-1{return _f .EOF ;};if _fdg ._cggc ==len (_fdg ._deb )-1&&_fdg ._cde !=0{return _f .EOF ;
};if _fdg ._cde ==0{_fdg ._deb [_fdg ._cggc ]=_ffd ;_fdg ._cggc ++;return nil ;};if _fdg ._eeg {_fdg ._deb [_fdg ._cggc ]|=_ffd >>_fdg ._cde ;_fdg ._cggc ++;_fdg ._deb [_fdg ._cggc ]=byte (uint16 (_ffd )<<(8-_fdg ._cde )&0xff);}else {_fdg ._deb [_fdg ._cggc ]|=byte (uint16 (_ffd )<<_fdg ._cde &0xff);
_fdg ._cggc ++;_fdg ._deb [_fdg ._cggc ]=_ffd >>(8-_fdg ._cde );};return nil ;};func (_ga *BufferedWriter )writeShiftedBytes (_gc []byte )int {for _ ,_cec :=range _gc {_ga .writeByte (_cec );};return len (_gc );};func (_gdfg *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _gdfg .writeBit (uint8 (bit ));
};return _ab .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");};func (_fac *Reader )ReadBit ()(_ccb int ,_dbeb error ){_bce ,_dbeb :=_fac .readBool ();
if _dbeb !=nil {return 0,_dbeb ;};if _bce {_ccb =1;};return _ccb ,nil ;};func (_aga *Writer )writeBit (_ega uint8 )error {if len (_aga ._deb )-1< _aga ._cggc {return _f .EOF ;};_abf :=_aga ._cde ;if _aga ._eeg {_abf =7-_aga ._cde ;};_aga ._deb [_aga ._cggc ]|=byte (uint16 (_ega <<_abf )&0xff);
_aga ._cde ++;if _aga ._cde ==8{_aga ._cggc ++;_aga ._cde =0;};return nil ;};func (_gdg *BufferedWriter )Write (d []byte )(int ,error ){_gdg .expandIfNeeded (len (d ));if _gdg ._cd ==0{return _gdg .writeFullBytes (d ),nil ;};return _gdg .writeShiftedBytes (d ),nil ;
};func (_gdgc *Reader )read (_ceag []byte )(int ,error ){if _gdgc ._gffg >=int64 (len (_gdgc ._ece )){return 0,_f .EOF ;};_gdgc ._bdf =-1;_aba :=copy (_ceag ,_gdgc ._ece [_gdgc ._gffg :]);_gdgc ._gffg +=int64 (_aba );return _aba ,nil ;};func (_fgc *Reader )readUnalignedByte ()(_fccf byte ,_ccbg error ){_gcc :=_fgc ._cbg ;
_fccf =_fgc ._egb <<(8-_gcc );_fgc ._egb ,_ccbg =_fgc .readBufferByte ();if _ccbg !=nil {return 0,_ccbg ;};_fccf |=_fgc ._egb >>_gcc ;_fgc ._egb &=1<<_gcc -1;return _fccf ,nil ;};func (_ea *BufferedWriter )byteCapacity ()int {_ed :=len (_ea ._aa )-_ea ._gb ;
if _ea ._cd !=0{_ed --;};return _ed ;};func (_eaf *Writer )FinishByte (){if _eaf ._cde ==0{return ;};_eaf ._cde =0;_eaf ._cggc ++;};func (_fdb *SubstreamReader )Mark (){_fdb ._gbf =_fdb ._bfb ;_fdb ._eag =_fdb ._ebb };type Reader struct{_ece []byte ;_egb byte ;
_cbg byte ;_gffg int64 ;_dbc int ;_bdf int ;_gbg int64 ;_aab byte ;};func (_gfd *Reader )BitPosition ()int {return int (_gfd ._cbg )};func (_fed *SubstreamReader )fillBuffer ()error {if uint64 (_fed ._ade .StreamPosition ())!=_fed ._bfb +_fed ._dbb {_ ,_cgd :=_fed ._ade .Seek (int64 (_fed ._bfb +_fed ._dbb ),_f .SeekStart );
if _cgd !=nil {return _cgd ;};};_fed ._ff =_fed ._bfb ;_bed :=_abae (uint64 (len (_fed ._aec )),_fed ._fef -_fed ._bfb );_aae :=make ([]byte ,_bed );_ggb ,_bag :=_fed ._ade .Read (_aae );if _bag !=nil {return _bag ;};for _acg :=uint64 (0);_acg < _bed ;
_acg ++{_fed ._aec [_acg ]=_aae [_acg ];};_fed ._da =_fed ._ff +uint64 (_ggb );return nil ;};func (_fd *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;};_e :=int (_fd ._cd )+skip ;if _e >=0&&_e < 8{_fd ._cd =uint8 (_e );return nil ;
};_e =int (_fd ._cd )+_fd ._gb *8+skip ;if _e < 0{return _ab .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_af :=_e /8;
_db :=_e %8;_fd ._cd =uint8 (_db );if _cf :=_af -_fd ._gb ;_cf > 0&&len (_fd ._aa )-1< _af {if _fd ._cd !=0{_cf ++;};_fd .expandIfNeeded (_cf );};_fd ._gb =_af ;return nil ;};type BitWriter interface{WriteBit (_bf int )error ;WriteBits (_edb uint64 ,_gff int )(_bb int ,_fcc error );
FinishByte ();SkipBits (_ee int )error ;};type BufferedWriter struct{_aa []byte ;_cd uint8 ;_gb int ;_ag bool ;};type BinaryWriter interface{BitWriter ;_f .Writer ;_f .ByteWriter ;Data ()[]byte ;};func (_acc *SubstreamReader )Seek (offset int64 ,whence int )(int64 ,error ){switch whence {case _f .SeekStart :_acc ._bfb =uint64 (offset );
case _f .SeekCurrent :_acc ._bfb +=uint64 (offset );case _f .SeekEnd :_acc ._bfb =_acc ._fef +uint64 (offset );default:return 0,_a .New ("\u0072\u0065\u0061d\u0065\u0072\u002e\u0053\u0075\u0062\u0073\u0074\u0072\u0065\u0061\u006d\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u0020\u0069\u006e\u0076\u0061\u006ci\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};_acc ._ebb =0;return int64 (_acc ._bfb ),nil ;};func NewSubstreamReader (r StreamReader ,offset ,length uint64 )(*SubstreamReader ,error ){if r ==nil {return nil ,_a .New ("\u0072o\u006ft\u0020\u0072\u0065\u0061\u0064e\u0072\u0020i\u0073\u0020\u006e\u0069\u006c");
};_cc .Log .Trace ("\u004e\u0065\u0077\u0053\u0075\u0062\u0073\u0074r\u0065\u0061\u006dRe\u0061\u0064\u0065\u0072\u0020\u0061t\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u003a\u0020\u0025\u0064\u0020\u0077\u0069\u0074h\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a \u0025\u0064",offset ,length );
return &SubstreamReader {_ade :r ,_dbb :offset ,_fef :length ,_aec :make ([]byte ,length )},nil ;};func (_geb *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_geb ._bdf =-1;var _abe int64 ;switch whence {case _f .SeekStart :_abe =offset ;case _f .SeekCurrent :_abe =_geb ._gffg +offset ;
case _f .SeekEnd :_abe =int64 (len (_geb ._ece ))+offset ;default:return 0,_a .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};if _abe < 0{return 0,_a .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");};_geb ._gffg =_abe ;
_geb ._cbg =0;return _abe ,nil ;};func (_efb *BufferedWriter )writeFullBytes (_cbc []byte )int {_dd :=copy (_efb ._aa [_efb .fullOffset ():],_cbc );_efb ._gb +=_dd ;return _dd ;};func (_b *BufferedWriter )Data ()[]byte {return _b ._aa };const (_ac =64;
_ad =int (^uint (0)>>1););func (_ecb *SubstreamReader )ReadByte ()(byte ,error ){if _ecb ._ebb ==0{return _ecb .readBufferByte ();};return _ecb .readUnalignedByte ();};func (_fa *BufferedWriter )writeByte (_be byte ){switch {case _fa ._cd ==0:_fa ._aa [_fa ._gb ]=_be ;
_fa ._gb ++;case _fa ._ag :_fa ._aa [_fa ._gb ]|=_be >>_fa ._cd ;_fa ._gb ++;_fa ._aa [_fa ._gb ]=byte (uint16 (_be )<<(8-_fa ._cd )&0xff);default:_fa ._aa [_fa ._gb ]|=byte (uint16 (_be )<<_fa ._cd &0xff);_fa ._gb ++;_fa ._aa [_fa ._gb ]=_be >>(8-_fa ._cd );
};};func (_eef *Reader )Reset (){_eef ._gffg =_eef ._gbg ;_eef ._cbg =_eef ._aab };func (_gdf *SubstreamReader )ReadBit ()(_fdeb int ,_gfg error ){_bdd ,_gfg :=_gdf .readBool ();if _gfg !=nil {return 0,_gfg ;};if _bdd {_fdeb =1;};return _fdeb ,nil ;};func (_gfa *Reader )Align ()(_gda byte ){_gda =_gfa ._cbg ;
_gfa ._cbg =0;return _gda };func (_ce *BufferedWriter )ResetBitIndex (){_ce ._cd =0};func NewWriter (data []byte )*Writer {return &Writer {_deb :data }};func (_ca *BufferedWriter )Reset (){_ca ._aa =_ca ._aa [:0];_ca ._gb =0;_ca ._cd =0};func (_dea *SubstreamReader )readBool ()(_dcd bool ,_dcfc error ){if _dea ._ebb ==0{_dea ._abg ,_dcfc =_dea .readBufferByte ();
if _dcfc !=nil {return false ,_dcfc ;};_dcd =(_dea ._abg &0x80)!=0;_dea ._abg ,_dea ._ebb =_dea ._abg &0x7f,7;return _dcd ,nil ;};_dea ._ebb --;_dcd =(_dea ._abg &(1<<_dea ._ebb ))!=0;_dea ._abg &=1<<_dea ._ebb -1;return _dcd ,nil ;};func (_caf *Writer )byteCapacity ()int {_bdbd :=len (_caf ._deb )-_caf ._cggc ;
if _caf ._cde !=0{_bdbd --;};return _bdbd ;};func (_gcb *Writer )Write (p []byte )(int ,error ){if len (p )> _gcb .byteCapacity (){return 0,_f .EOF ;};for _ ,_gebd :=range p {if _dab :=_gcb .writeByte (_gebd );_dab !=nil {return 0,_dab ;};};return len (p ),nil ;
};var _ BinaryWriter =&Writer {};func (_ebf *SubstreamReader )StreamPosition ()int64 {return int64 (_ebf ._bfb )};func (_ffg *SubstreamReader )Offset ()uint64 {return _ffg ._dbb };func (_gd *BufferedWriter )FinishByte (){if _gd ._cd ==0{return ;};_gd ._cd =0;
_gd ._gb ++;};func (_egfc *Writer )WriteBits (bits uint64 ,number int )(_gdd int ,_caee error ){const _gbbg ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";if number < 0||number > 64{return 0,_ab .Errorf (_gbbg ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};if number ==0{return 0,nil ;};_ggd :=number /8;if _ggd > 0{_gdde :=number -_ggd *8;for _ccba :=_ggd -1;_ccba >=0;_ccba --{_ebd :=byte ((bits >>uint (_ccba *8+_gdde ))&0xff);if _caee =_egfc .WriteByte (_ebd );_caee !=nil {return _gdd ,_ab .Wrapf (_caee ,_gbbg ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_ggd -_ccba +1);
};};number -=_ggd *8;if number ==0{return _ggd ,nil ;};};var _cfc int ;for _eee :=0;_eee < number ;_eee ++{if _egfc ._eeg {_cfc =int ((bits >>uint (number -1-_eee ))&0x1);}else {_cfc =int (bits &0x1);bits >>=1;};if _caee =_egfc .WriteBit (_cfc );_caee !=nil {return _gdd ,_ab .Wrapf (_caee ,_gbbg ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_eee );
};};return _ggd ,nil ;};func (_agd *SubstreamReader )readUnalignedByte ()(_gef byte ,_cgg error ){_dga :=_agd ._ebb ;_gef =_agd ._abg <<(8-_dga );_agd ._abg ,_cgg =_agd .readBufferByte ();if _cgg !=nil {return 0,_cgg ;};_gef |=_agd ._abg >>_dga ;_agd ._abg &=1<<_dga -1;
return _gef ,nil ;};var _ _f .Writer =&BufferedWriter {};func (_fgg *Reader )Read (p []byte )(_gga int ,_bff error ){if _fgg ._cbg ==0{return _fgg .read (p );};for ;_gga < len (p );_gga ++{if p [_gga ],_bff =_fgg .readUnalignedByte ();_bff !=nil {return 0,_bff ;
};};return _gga ,nil ;};func (_ddd *Writer )Data ()[]byte {return _ddd ._deb };func (_ged *SubstreamReader )BitPosition ()int {return int (_ged ._ebb )};func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_ag :true }};func (_ede *Reader )Mark (){_ede ._gbg =_ede ._gffg ;
_ede ._aab =_ede ._cbg };func (_bee *SubstreamReader )Reset (){_bee ._bfb =_bee ._gbf ;_bee ._ebb =_bee ._eag };func (_gfaf *Writer )UseMSB ()bool {return _gfaf ._eeg };func (_ebe *Reader )Length ()uint64 {return uint64 (len (_ebe ._ece ))};func (_cgff *SubstreamReader )readBufferByte ()(byte ,error ){if _cgff ._bfb >=_cgff ._fef {return 0,_f .EOF ;
};if _cgff ._bfb >=_cgff ._da ||_cgff ._bfb < _cgff ._ff {if _gdaf :=_cgff .fillBuffer ();_gdaf !=nil {return 0,_gdaf ;};};_dbd :=_cgff ._aec [_cgff ._bfb -_cgff ._ff ];_cgff ._bfb ++;return _dbd ,nil ;};var (_ _f .Reader =&Reader {};_ _f .ByteReader =&Reader {};
_ _f .Seeker =&Reader {};_ StreamReader =&Reader {};);func (_cee *SubstreamReader )ReadBits (n byte )(_gdce uint64 ,_faa error ){if n < _cee ._ebb {_dgd :=_cee ._ebb -n ;_gdce =uint64 (_cee ._abg >>_dgd );_cee ._abg &=1<<_dgd -1;_cee ._ebb =_dgd ;return _gdce ,nil ;
};if n > _cee ._ebb {if _cee ._ebb > 0{_gdce =uint64 (_cee ._abg );n -=_cee ._ebb ;};var _fbb byte ;for n >=8{_fbb ,_faa =_cee .readBufferByte ();if _faa !=nil {return 0,_faa ;};_gdce =_gdce <<8+uint64 (_fbb );n -=8;};if n > 0{if _cee ._abg ,_faa =_cee .readBufferByte ();
_faa !=nil {return 0,_faa ;};_cecg :=8-n ;_gdce =_gdce <<n +uint64 (_cee ._abg >>_cecg );_cee ._abg &=1<<_cecg -1;_cee ._ebb =_cecg ;}else {_cee ._ebb =0;};return _gdce ,nil ;};_cee ._ebb =0;return uint64 (_cee ._abg ),nil ;};func (_afd *BufferedWriter )tryGrowByReslice (_cg int )bool {if _geg :=len (_afd ._aa );
_cg <=cap (_afd ._aa )-_geg {_afd ._aa =_afd ._aa [:_geg +_cg ];return true ;};return false ;};func (_ege *Writer )ResetBit (){_ege ._cde =0};func (_cfd *Writer )WriteByte (c byte )error {return _cfd .writeByte (c )};var _ _f .ByteWriter =&BufferedWriter {};
func (_agc *SubstreamReader )ReadUint32 ()(uint32 ,error ){_bca :=make ([]byte ,4);_ ,_fbc :=_agc .Read (_bca );if _fbc !=nil {return 0,_fbc ;};return _c .BigEndian .Uint32 (_bca ),nil ;};func (_bea *Reader )ReadByte ()(byte ,error ){if _bea ._cbg ==0{return _bea .readBufferByte ();
};return _bea .readUnalignedByte ();};func (_cad *Reader )ConsumeRemainingBits (){if _cad ._cbg !=0{_ ,_fdf :=_cad .ReadBits (_cad ._cbg );if _fdf !=nil {_cc .Log .Debug ("\u0043\u006f\u006e\u0073\u0075\u006d\u0065\u0052\u0065\u006da\u0069\u006e\u0069\u0067\u0042\u0069\u0074s\u0020\u0066\u0061\u0069\u006c\u0065\u0064\u003a\u0020\u0025\u0076",_fdf );
};};};var _ BinaryWriter =&BufferedWriter {};func (_cb *BufferedWriter )expandIfNeeded (_edc int ){if !_cb .tryGrowByReslice (_edc ){_cb .grow (_edc );};};func (_gba *BufferedWriter )WriteByte (bt byte )error {if _gba ._gb > len (_gba ._aa )-1||(_gba ._gb ==len (_gba ._aa )-1&&_gba ._cd !=0){_gba .expandIfNeeded (1);
};_gba .writeByte (bt );return nil ;};func _abae (_dbce ,_edf uint64 )uint64 {if _dbce < _edf {return _dbce ;};return _edf ;};func (_bgc *BufferedWriter )fullOffset ()int {_fde :=_bgc ._gb ;if _bgc ._cd !=0{_fde ++;};return _fde ;};func (_eed *SubstreamReader )Read (b []byte )(_dcc int ,_gab error ){if _eed ._bfb >=_eed ._fef {_cc .Log .Trace ("\u0053\u0074\u0072e\u0061\u006d\u0050\u006fs\u003a\u0020\u0027\u0025\u0064\u0027\u0020>\u003d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027",_eed ._bfb ,_eed ._fef );
return 0,_f .EOF ;};for ;_dcc < len (b );_dcc ++{if b [_dcc ],_gab =_eed .readUnalignedByte ();_gab !=nil {if _gab ==_f .EOF {return _dcc ,nil ;};return 0,_gab ;};};return _dcc ,nil ;};func (_cfa *Reader )readBufferByte ()(byte ,error ){if _cfa ._gffg >=int64 (len (_cfa ._ece )){return 0,_f .EOF ;
};_cfa ._bdf =-1;_fe :=_cfa ._ece [_cfa ._gffg ];_cfa ._gffg ++;_cfa ._dbc =int (_fe );return _fe ,nil ;};func (_fdfd *SubstreamReader )Length ()uint64 {return _fdfd ._fef };