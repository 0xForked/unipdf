//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_g "encoding/binary";_a "errors";_d "github.com/unidoc/unipdf/v3/common";_ag "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_ed "io";);func (_ega *Reader )Length ()uint64 {return uint64 (len (_ega ._deg ))};func (_dbb *Reader )ReadByte ()(byte ,error ){if _dbb ._fe ==0{return _dbb .readBufferByte ();
};return _dbb .readUnalignedByte ();};func (_feb *SubstreamReader )ReadByte ()(byte ,error ){if _feb ._cffa ==0{return _feb .readBufferByte ();};return _feb .readUnalignedByte ();};func (_dbcg *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _dbcg .writeBit (uint8 (bit ));
};return _ag .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");};func (_bd *Reader )BitPosition ()int {return int (_bd ._fe )};type Writer struct{_ggg []byte ;
_gfda uint8 ;_dbg int ;_fad bool ;};func (_da *SubstreamReader )StreamPosition ()int64 {return int64 (_da ._bda )};func (_fge *BufferedWriter )writeFullBytes (_dga []byte )int {_aee :=copy (_fge ._ad [_fge .fullOffset ():],_dga );_fge ._b +=_aee ;return _aee ;
};func (_dge *BufferedWriter )grow (_eb int ){if _dge ._ad ==nil &&_eb < _f {_dge ._ad =make ([]byte ,_eb ,_f );return ;};_gge :=len (_dge ._ad );if _dge ._gg !=0{_gge ++;};_bae :=cap (_dge ._ad );switch {case _eb <=_bae /2-_gge :_d .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_dge ._ad ),cap (_dge ._ad ),_eb );
_d .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_bae ,_gge );copy (_dge ._ad ,_dge ._ad [_dge .fullOffset ():]);
case _bae > _dg -_bae -_eb :_d .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_bg :=make ([]byte ,2*_bae +_eb );copy (_bg ,_dge ._ad );_dge ._ad =_bg ;};_dge ._ad =_dge ._ad [:_gge +_eb ];
};func (_dbc *SubstreamReader )Offset ()uint64 {return _dbc ._edf };func (_bdb *Writer )FinishByte (){if _bdb ._gfda ==0{return ;};_bdb ._gfda =0;_bdb ._dbg ++;};var _ _ed .Writer =&BufferedWriter {};func (_aad *Writer )ResetBit (){_aad ._gfda =0};func (_fb *SubstreamReader )ReadBit ()(_aagf int ,_fcf error ){_ced ,_fcf :=_fb .readBool ();
if _fcf !=nil {return 0,_fcf ;};if _ced {_aagf =1;};return _aagf ,nil ;};func (_cefa *Writer )writeByte (_agf byte )error {if _cefa ._dbg > len (_cefa ._ggg )-1{return _ed .EOF ;};if _cefa ._dbg ==len (_cefa ._ggg )-1&&_cefa ._gfda !=0{return _ed .EOF ;
};if _cefa ._gfda ==0{_cefa ._ggg [_cefa ._dbg ]=_agf ;_cefa ._dbg ++;return nil ;};if _cefa ._fad {_cefa ._ggg [_cefa ._dbg ]|=_agf >>_cefa ._gfda ;_cefa ._dbg ++;_cefa ._ggg [_cefa ._dbg ]=byte (uint16 (_agf )<<(8-_cefa ._gfda )&0xff);}else {_cefa ._ggg [_cefa ._dbg ]|=byte (uint16 (_agf )<<_cefa ._gfda &0xff);
_cefa ._dbg ++;_cefa ._ggg [_cefa ._dbg ]=_agf >>(8-_cefa ._gfda );};return nil ;};func NewWriter (data []byte )*Writer {return &Writer {_ggg :data }};func (_gdd *BufferedWriter )writeShiftedBytes (_abe []byte )int {for _ ,_cbg :=range _abe {_gdd .writeByte (_cbg );
};return len (_abe );};func (_ab *BufferedWriter )Reset (){_ab ._ad =_ab ._ad [:0];_ab ._b =0;_ab ._gg =0};func (_cfdd *SubstreamReader )Align ()(_gae byte ){_gae =_cfdd ._cffa ;_cfdd ._cffa =0;return _gae };type Reader struct{_deg []byte ;_ffg byte ;_fe byte ;
_aag int64 ;_ea int ;_bbg int ;_abed int64 ;_cga byte ;_ef byte ;_geg int ;};func (_cff *Reader )Align ()(_bgc byte ){_bgc =_cff ._fe ;_cff ._fe =0;return _bgc };func NewReader (data []byte )*Reader {return &Reader {_deg :data }};var (_ _ed .Reader =&Reader {};
_ _ed .ByteReader =&Reader {};_ _ed .Seeker =&Reader {};_ StreamReader =&Reader {};);var _ BinaryWriter =&Writer {};var _ _ed .ByteWriter =&BufferedWriter {};func NewWriterMSB (data []byte )*Writer {return &Writer {_ggg :data ,_fad :true }};func (_bfce *BufferedWriter )tryGrowByReslice (_bef int )bool {if _bec :=len (_bfce ._ad );
_bef <=cap (_bfce ._ad )-_bec {_bfce ._ad =_bfce ._ad [:_bec +_bef ];return true ;};return false ;};func (_dca *Writer )SkipBits (skip int )error {const _edd ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";if skip ==0{return nil ;
};_faeb :=int (_dca ._gfda )+skip ;if _faeb >=0&&_faeb < 8{_dca ._gfda =uint8 (_faeb );return nil ;};_faeb =int (_dca ._gfda )+_dca ._dbg *8+skip ;if _faeb < 0{return _ag .Errorf (_edd ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_dag :=_faeb /8;_adcc :=_faeb %8;_d .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");_d .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_dca ._gfda ,_dca ._dbg ,int (_dca ._gfda )+(_dca ._dbg )*8,len (_dca ._ggg ),cap (_dca ._ggg ));
_d .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_faeb ,_adcc );_dca ._gfda =uint8 (_adcc );
if _aga :=_dag -_dca ._dbg ;_aga > 0&&len (_dca ._ggg )-1< _dag {_d .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_aga );return _ag .Errorf (_edd ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_dca ._dbg =_dag ;_d .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_dca ._gfda ,_dca ._dbg );return nil ;};func (_bfd *Reader )ReadBool ()(bool ,error ){return _bfd .readBool ()};
func NewSubstreamReader (r StreamReader ,offset ,length uint64 )(*SubstreamReader ,error ){if r ==nil {return nil ,_a .New ("\u0072o\u006ft\u0020\u0072\u0065\u0061\u0064e\u0072\u0020i\u0073\u0020\u006e\u0069\u006c");};_d .Log .Trace ("\u004e\u0065\u0077\u0053\u0075\u0062\u0073\u0074r\u0065\u0061\u006dRe\u0061\u0064\u0065\u0072\u0020\u0061t\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u003a\u0020\u0025\u0064\u0020\u0077\u0069\u0074h\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a \u0025\u0064",offset ,length );
return &SubstreamReader {_gfdd :r ,_edf :offset ,_abd :length ,_cfd :make ([]byte ,length )},nil ;};func (_bfg *Writer )WriteBits (bits uint64 ,number int )(_febf int ,_bcc error ){const _bcd ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";
if number < 0||number > 64{return 0,_ag .Errorf (_bcd ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};if number ==0{return 0,nil ;};_fgg :=number /8;if _fgg > 0{_fdc :=number -_fgg *8;for _dab :=_fgg -1;_dab >=0;_dab --{_gbc :=byte ((bits >>uint (_dab *8+_fdc ))&0xff);if _bcc =_bfg .WriteByte (_gbc );_bcc !=nil {return _febf ,_ag .Wrapf (_bcc ,_bcd ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_fgg -_dab +1);
};};number -=_fgg *8;if number ==0{return _fgg ,nil ;};};var _gdb int ;for _bgdd :=0;_bgdd < number ;_bgdd ++{if _bfg ._fad {_gdb =int ((bits >>uint (number -1-_bgdd ))&0x1);}else {_gdb =int (bits &0x1);bits >>=1;};if _bcc =_bfg .WriteBit (_gdb );_bcc !=nil {return _febf ,_ag .Wrapf (_bcc ,_bcd ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_bgdd );
};};return _fgg ,nil ;};func (_cbb *Writer )byteCapacity ()int {_gddf :=len (_cbb ._ggg )-_cbb ._dbg ;if _cbb ._gfda !=0{_gddf --;};return _gddf ;};func (_bfda *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_bfda ._bbg =-1;var _abg int64 ;switch whence {case _ed .SeekStart :_abg =offset ;
case _ed .SeekCurrent :_abg =_bfda ._aag +offset ;case _ed .SeekEnd :_abg =int64 (len (_bfda ._deg ))+offset ;default:return 0,_a .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};if _abg < 0{return 0,_a .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");};_bfda ._aag =_abg ;
_bfda ._fe =0;return _abg ,nil ;};func (_dgf *BufferedWriter )Data ()[]byte {return _dgf ._ad };func (_bba *SubstreamReader )ReadUint32 ()(uint32 ,error ){_gfdb :=make ([]byte ,4);_ ,_edff :=_bba .Read (_gfdb );if _edff !=nil {return 0,_edff ;};return _g .BigEndian .Uint32 (_gfdb ),nil ;
};func (_aa *BufferedWriter )WriteBits (bits uint64 ,number int )(_fg int ,_ga error ){const _db ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";if number < 0||number > 64{return 0,_ag .Errorf (_db ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};_eg :=number /8;if _eg > 0{_eed :=number -_eg *8;for _cb :=_eg -1;_cb >=0;_cb --{_fga :=byte ((bits >>uint (_cb *8+_eed ))&0xff);if _ga =_aa .WriteByte (_fga );_ga !=nil {return _fg ,_ag .Wrapf (_ga ,_db ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_eg -_cb +1);
};};number -=_eg *8;if number ==0{return _eg ,nil ;};};var _ba int ;for _cg :=0;_cg < number ;_cg ++{if _aa ._age {_ba =int ((bits >>uint (number -1-_cg ))&0x1);}else {_ba =int (bits &0x1);bits >>=1;};if _ga =_aa .WriteBit (_ba );_ga !=nil {return _fg ,_ag .Wrapf (_ga ,_db ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_cg );
};};return _eg ,nil ;};func (_dfbc *SubstreamReader )fillBuffer ()error {if uint64 (_dfbc ._gfdd .StreamPosition ())!=_dfbc ._bda +_dfbc ._edf {_ ,_fda :=_dfbc ._gfdd .Seek (int64 (_dfbc ._bda +_dfbc ._edf ),_ed .SeekStart );if _fda !=nil {return _fda ;
};};_dfbc ._abc =_dfbc ._bda ;_gad :=_cdg (uint64 (len (_dfbc ._cfd )),_dfbc ._abd -_dfbc ._bda );_fdb :=make ([]byte ,_gad );_bc ,_fcfa :=_dfbc ._gfdd .Read (_fdb );if _fcfa !=nil {return _fcfa ;};for _dgda :=uint64 (0);_dgda < _gad ;_dgda ++{_dfbc ._cfd [_dgda ]=_fdb [_dgda ];
};_dfbc ._ggfe =_dfbc ._abc +uint64 (_bc );return nil ;};func (_dfb *Reader )Mark (){_dfb ._abed =_dfb ._aag ;_dfb ._cga =_dfb ._fe ;_dfb ._ef =_dfb ._ffg ;_dfb ._geg =_dfb ._ea ;};func (_bfced *Reader )StreamPosition ()int64 {return _bfced ._aag };func (_faa *Reader )readBufferByte ()(byte ,error ){if _faa ._aag >=int64 (len (_faa ._deg )){return 0,_ed .EOF ;
};_faa ._bbg =-1;_ege :=_faa ._deg [_faa ._aag ];_faa ._aag ++;_faa ._ea =int (_ege );return _ege ,nil ;};func (_dfg *SubstreamReader )Length ()uint64 {return _dfg ._abd };func (_acc *BufferedWriter )writeByte (_gdf byte ){switch {case _acc ._gg ==0:_acc ._ad [_acc ._b ]=_gdf ;
_acc ._b ++;case _acc ._age :_acc ._ad [_acc ._b ]|=_gdf >>_acc ._gg ;_acc ._b ++;_acc ._ad [_acc ._b ]=byte (uint16 (_gdf )<<(8-_acc ._gg )&0xff);default:_acc ._ad [_acc ._b ]|=byte (uint16 (_gdf )<<_acc ._gg &0xff);_acc ._b ++;_acc ._ad [_acc ._b ]=_gdf >>(8-_acc ._gg );
};};func (_fa *Reader )Read (p []byte )(_gec int ,_eeg error ){if _fa ._fe ==0{return _fa .read (p );};for ;_gec < len (p );_gec ++{if p [_gec ],_eeg =_fa .readUnalignedByte ();_eeg !=nil {return 0,_eeg ;};};return _gec ,nil ;};func (_agce *Writer )writeBit (_bca uint8 )error {if len (_agce ._ggg )-1< _agce ._dbg {return _ed .EOF ;
};_bgce :=_agce ._gfda ;if _agce ._fad {_bgce =7-_agce ._gfda ;};_agce ._ggg [_agce ._dbg ]|=byte (uint16 (_bca <<_bgce )&0xff);_agce ._gfda ++;if _agce ._gfda ==8{_agce ._dbg ++;_agce ._gfda =0;};return nil ;};func _cdg (_aec ,_cdgb uint64 )uint64 {if _aec < _cdgb {return _aec ;
};return _cdgb ;};func (_gaa *Writer )Data ()[]byte {return _gaa ._ggg };func (_ebea *SubstreamReader )readBufferByte ()(byte ,error ){if _ebea ._bda >=_ebea ._abd {return 0,_ed .EOF ;};if _ebea ._bda >=_ebea ._ggfe ||_ebea ._bda < _ebea ._abc {if _aaf :=_ebea .fillBuffer ();
_aaf !=nil {return 0,_aaf ;};};_cfc :=_ebea ._cfd [_ebea ._bda -_ebea ._abc ];_ebea ._bda ++;return _cfc ,nil ;};func (_efc *SubstreamReader )ReadBool ()(bool ,error ){return _efc .readBool ()};func (_bdc *SubstreamReader )BitPosition ()int {return int (_bdc ._cffa )};
func (_baa *Reader )ReadBit ()(_efb int ,_geb error ){_gee ,_geb :=_baa .readBool ();if _geb !=nil {return 0,_geb ;};if _gee {_efb =1;};return _efb ,nil ;};func (_dd *Reader )readUnalignedByte ()(_dgeg byte ,_edb error ){_gb :=_dd ._fe ;_dgeg =_dd ._ffg <<(8-_gb );
_dd ._ffg ,_edb =_dd .readBufferByte ();if _edb !=nil {return 0,_edb ;};_dgeg |=_dd ._ffg >>_gb ;_dd ._ffg &=1<<_gb -1;return _dgeg ,nil ;};func (_bfc *BufferedWriter )expandIfNeeded (_be int ){if !_bfc .tryGrowByReslice (_be ){_bfc .grow (_be );};};func (_dgd *Reader )readBool ()(_abb bool ,_cbgd error ){if _dgd ._fe ==0{_dgd ._ffg ,_cbgd =_dgd .readBufferByte ();
if _cbgd !=nil {return false ,_cbgd ;};_abb =(_dgd ._ffg &0x80)!=0;_dgd ._ffg ,_dgd ._fe =_dgd ._ffg &0x7f,7;return _abb ,nil ;};_dgd ._fe --;_abb =(_dgd ._ffg &(1<<_dgd ._fe ))!=0;_dgd ._ffg &=1<<_dgd ._fe -1;return _abb ,nil ;};func (_gff *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _ag .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );
};if len (_gff ._ad )-1< _gff ._b {_gff .expandIfNeeded (1);};_ec :=_gff ._gg ;if _gff ._age {_ec =7-_gff ._gg ;};_gff ._ad [_gff ._b ]|=byte (uint16 (bit <<_ec )&0xff);_gff ._gg ++;if _gff ._gg ==8{_gff ._b ++;_gff ._gg =0;};return nil ;};func (_fcc *SubstreamReader )Reset (){_fcc ._bda =_fcc ._feg ;
_fcc ._cffa =_fcc ._gag };func (_edef *Reader )ReadUint32 ()(uint32 ,error ){_ece :=make ([]byte ,4);_ ,_eca :=_edef .Read (_ece );if _eca !=nil {return 0,_eca ;};return _g .BigEndian .Uint32 (_ece ),nil ;};func (_abcf *SubstreamReader )readBool ()(_fbd bool ,_fbfe error ){if _abcf ._cffa ==0{_abcf ._dee ,_fbfe =_abcf .readBufferByte ();
if _fbfe !=nil {return false ,_fbfe ;};_fbd =(_abcf ._dee &0x80)!=0;_abcf ._dee ,_abcf ._cffa =_abcf ._dee &0x7f,7;return _fbd ,nil ;};_abcf ._cffa --;_fbd =(_abcf ._dee &(1<<_abcf ._cffa ))!=0;_abcf ._dee &=1<<_abcf ._cffa -1;return _fbd ,nil ;};func (_gcc *Writer )Write (p []byte )(int ,error ){if len (p )> _gcc .byteCapacity (){return 0,_ed .EOF ;
};for _ ,_agc :=range p {if _edg :=_gcc .writeByte (_agc );_edg !=nil {return 0,_edg ;};};return len (p ),nil ;};func (_gdc *Reader )read (_cd []byte )(int ,error ){if _gdc ._aag >=int64 (len (_gdc ._deg )){return 0,_ed .EOF ;};_gdc ._bbg =-1;_ce :=copy (_cd ,_gdc ._deg [_gdc ._aag :]);
_gdc ._aag +=int64 (_ce );return _ce ,nil ;};func (_cbca *SubstreamReader )readUnalignedByte ()(_gbf byte ,_dc error ){_cfdf :=_cbca ._cffa ;_gbf =_cbca ._dee <<(8-_cfdf );_cbca ._dee ,_dc =_cbca .readBufferByte ();if _dc !=nil {return 0,_dc ;};_gbf |=_cbca ._dee >>_cfdf ;
_cbca ._dee &=1<<_cfdf -1;return _gbf ,nil ;};func (_ebe *Reader )ReadBits (n byte )(_cgf uint64 ,_gfd error ){if n < _ebe ._fe {_beca :=_ebe ._fe -n ;_cgf =uint64 (_ebe ._ffg >>_beca );_ebe ._ffg &=1<<_beca -1;_ebe ._fe =_beca ;return _cgf ,nil ;};if n > _ebe ._fe {if _ebe ._fe > 0{_cgf =uint64 (_ebe ._ffg );
n -=_ebe ._fe ;};for n >=8{_gaf ,_bdf :=_ebe .readBufferByte ();if _bdf !=nil {return 0,_bdf ;};_cgf =_cgf <<8+uint64 (_gaf );n -=8;};if n > 0{if _ebe ._ffg ,_gfd =_ebe .readBufferByte ();_gfd !=nil {return 0,_gfd ;};_bgd :=8-n ;_cgf =_cgf <<n +uint64 (_ebe ._ffg >>_bgd );
_ebe ._ffg &=1<<_bgd -1;_ebe ._fe =_bgd ;}else {_ebe ._fe =0;};return _cgf ,nil ;};_ebe ._fe =0;return uint64 (_ebe ._ffg ),nil ;};type BitWriter interface{WriteBit (_cf int )error ;WriteBits (_bb uint64 ,_de int )(_fc int ,_bgb error );FinishByte ();SkipBits (_gc int )error ;
};const (_f =64;_dg =int (^uint (0)>>1););func (_add *Writer )UseMSB ()bool {return _add ._fad };func (_cbc *SubstreamReader )Read (b []byte )(_dgdf int ,_efbf error ){if _cbc ._bda >=_cbc ._abd {_d .Log .Trace ("\u0053\u0074\u0072e\u0061\u006d\u0050\u006fs\u003a\u0020\u0027\u0025\u0064\u0027\u0020>\u003d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027",_cbc ._bda ,_cbc ._abd );
return 0,_ed .EOF ;};for ;_dgdf < len (b );_dgdf ++{if b [_dgdf ],_efbf =_cbc .readUnalignedByte ();_efbf !=nil {if _efbf ==_ed .EOF {return _dgdf ,nil ;};return 0,_efbf ;};};return _dgdf ,nil ;};func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_age :true }};
func (_ae *BufferedWriter )WriteByte (bt byte )error {if _ae ._b > len (_ae ._ad )-1||(_ae ._b ==len (_ae ._ad )-1&&_ae ._gg !=0){_ae .expandIfNeeded (1);};_ae .writeByte (bt );return nil ;};func (_fd *BufferedWriter )Write (d []byte )(int ,error ){_fd .expandIfNeeded (len (d ));
if _fd ._gg ==0{return _fd .writeFullBytes (d ),nil ;};return _fd .writeShiftedBytes (d ),nil ;};func (_bbc *SubstreamReader )Mark (){_bbc ._feg =_bbc ._bda ;_bbc ._gag =_bbc ._cffa };type BufferedWriter struct{_ad []byte ;_gg uint8 ;_b int ;_age bool ;
};func (_def *Writer )WriteByte (c byte )error {return _def .writeByte (c )};func (_adc *BufferedWriter )fullOffset ()int {_dfc :=_adc ._b ;if _adc ._gg !=0{_dfc ++;};return _dfc ;};func (_bf *BufferedWriter )Len ()int {return _bf .byteCapacity ()};func (_fcd *SubstreamReader )Seek (offset int64 ,whence int )(int64 ,error ){switch whence {case _ed .SeekStart :_fcd ._bda =uint64 (offset );
case _ed .SeekCurrent :_fcd ._bda +=uint64 (offset );case _ed .SeekEnd :_fcd ._bda =_fcd ._abd +uint64 (offset );default:return 0,_a .New ("\u0072\u0065\u0061d\u0065\u0072\u002e\u0053\u0075\u0062\u0073\u0074\u0072\u0065\u0061\u006d\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u0020\u0069\u006e\u0076\u0061\u006ci\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};_fcd ._cffa =0;return int64 (_fcd ._bda ),nil ;};type StreamReader interface{_ed .Reader ;_ed .ByteReader ;_ed .Seeker ;Align ()byte ;BitPosition ()int ;Mark ();Length ()uint64 ;ReadBit ()(int ,error );ReadBits (_fca byte )(uint64 ,error );ReadBool ()(bool ,error );
ReadUint32 ()(uint32 ,error );Reset ();StreamPosition ()int64 ;};func (_bdg *Reader )Reset (){_bdg ._aag =_bdg ._abed ;_bdg ._fe =_bdg ._cga ;_bdg ._ffg =_bdg ._ef ;_bdg ._ea =_bdg ._geg ;};func (_ff *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;
};_ggb :=int (_ff ._gg )+skip ;if _ggb >=0&&_ggb < 8{_ff ._gg =uint8 (_ggb );return nil ;};_ggb =int (_ff ._gg )+_ff ._b *8+skip ;if _ggb < 0{return _ag .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_gdg :=_ggb /8;_gf :=_ggb %8;_ff ._gg =uint8 (_gf );if _c :=_gdg -_ff ._b ;_c > 0&&len (_ff ._ad )-1< _gdg {if _ff ._gg !=0{_c ++;};_ff .expandIfNeeded (_c );};_ff ._b =_gdg ;return nil ;};type SubstreamReader struct{_bda uint64 ;_gfdd StreamReader ;
_edf uint64 ;_abd uint64 ;_cfd []byte ;_abc uint64 ;_ggfe uint64 ;_dee byte ;_cffa byte ;_feg uint64 ;_gag byte ;};var _ BinaryWriter =&BufferedWriter {};func (_ee *BufferedWriter )FinishByte (){if _ee ._gg ==0{return ;};_ee ._gg =0;_ee ._b ++;};func (_bdgb *SubstreamReader )ReadBits (n byte )(_fgf uint64 ,_ebf error ){if n < _bdgb ._cffa {_cef :=_bdgb ._cffa -n ;
_fgf =uint64 (_bdgb ._dee >>_cef );_bdgb ._dee &=1<<_cef -1;_bdgb ._cffa =_cef ;return _fgf ,nil ;};if n > _bdgb ._cffa {if _bdgb ._cffa > 0{_fgf =uint64 (_bdgb ._dee );n -=_bdgb ._cffa ;};var _fbf byte ;for n >=8{_fbf ,_ebf =_bdgb .readBufferByte ();if _ebf !=nil {return 0,_ebf ;
};_fgf =_fgf <<8+uint64 (_fbf );n -=8;};if n > 0{if _bdgb ._dee ,_ebf =_bdgb .readBufferByte ();_ebf !=nil {return 0,_ebf ;};_bfcd :=8-n ;_fgf =_fgf <<n +uint64 (_bdgb ._dee >>_bfcd );_bdgb ._dee &=1<<_bfcd -1;_bdgb ._cffa =_bfcd ;}else {_bdgb ._cffa =0;
};return _fgf ,nil ;};_bdgb ._cffa =0;return uint64 (_bdgb ._dee ),nil ;};func (_aeeg *Reader )ConsumeRemainingBits ()(uint64 ,error ){if _aeeg ._fe !=0{return _aeeg .ReadBits (_aeeg ._fe );};return 0,nil ;};func (_df *BufferedWriter )ResetBitIndex (){_df ._gg =0};
type BinaryWriter interface{BitWriter ;_ed .Writer ;_ed .ByteWriter ;Data ()[]byte ;};func (_ggf *BufferedWriter )byteCapacity ()int {_dff :=len (_ggf ._ad )-_ggf ._b ;if _ggf ._gg !=0{_dff --;};return _dff ;};