//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package mmr ;import (_gb "errors";_g "fmt";_a "github.com/unidoc/unipdf/v3/common";_b "github.com/unidoc/unipdf/v3/internal/bitwise";_ae "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_gg "io";);func (_cg *Decoder )UncompressMMR ()(_deg *_ae .Bitmap ,_bdb error ){_deg =_ae .New (_cg ._gd ,_cg ._be );
_bee :=make ([]int ,_deg .Width +5);_ffe :=make ([]int ,_deg .Width +5);_ffe [0]=_deg .Width ;_cf :=1;var _fecg int ;for _edc :=0;_edc < _deg .Height ;_edc ++{_fecg ,_bdb =_cg .uncompress2d (_cg ._ag ,_ffe ,_cf ,_bee ,_deg .Width );if _bdb !=nil {return nil ,_bdb ;
};if _fecg ==EOF {break ;};if _fecg > 0{_bdb =_cg .fillBitmap (_deg ,_edc ,_bee ,_fecg );if _bdb !=nil {return nil ,_bdb ;};};_ffe ,_bee =_bee ,_ffe ;_cf =_fecg ;};if _bdb =_cg .detectAndSkipEOL ();_bdb !=nil {return nil ,_bdb ;};_cg ._ag .align ();return _deg ,nil ;
};var (_gbf =[][3]int {{4,0x1,int (_bd )},{3,0x1,int (_dc )},{1,0x1,int (_ce )},{3,0x3,int (_bb )},{6,0x3,int (_fe )},{7,0x3,int (_fb )},{3,0x2,int (_geb )},{6,0x2,int (_fd )},{7,0x2,int (_db )},{10,0xf,int (_feg )},{12,0xf,int (_ba )},{12,0x1,int (EOL )}};
_fec =[][3]int {{4,0x07,2},{4,0x08,3},{4,0x0B,4},{4,0x0C,5},{4,0x0E,6},{4,0x0F,7},{5,0x12,128},{5,0x13,8},{5,0x14,9},{5,0x1B,64},{5,0x07,10},{5,0x08,11},{6,0x17,192},{6,0x18,1664},{6,0x2A,16},{6,0x2B,17},{6,0x03,13},{6,0x34,14},{6,0x35,15},{6,0x07,1},{6,0x08,12},{7,0x13,26},{7,0x17,21},{7,0x18,28},{7,0x24,27},{7,0x27,18},{7,0x28,24},{7,0x2B,25},{7,0x03,22},{7,0x37,256},{7,0x04,23},{7,0x08,20},{7,0xC,19},{8,0x12,33},{8,0x13,34},{8,0x14,35},{8,0x15,36},{8,0x16,37},{8,0x17,38},{8,0x1A,31},{8,0x1B,32},{8,0x02,29},{8,0x24,53},{8,0x25,54},{8,0x28,39},{8,0x29,40},{8,0x2A,41},{8,0x2B,42},{8,0x2C,43},{8,0x2D,44},{8,0x03,30},{8,0x32,61},{8,0x33,62},{8,0x34,63},{8,0x35,0},{8,0x36,320},{8,0x37,384},{8,0x04,45},{8,0x4A,59},{8,0x4B,60},{8,0x5,46},{8,0x52,49},{8,0x53,50},{8,0x54,51},{8,0x55,52},{8,0x58,55},{8,0x59,56},{8,0x5A,57},{8,0x5B,58},{8,0x64,448},{8,0x65,512},{8,0x67,640},{8,0x68,576},{8,0x0A,47},{8,0x0B,48},{9,0x01,_ff },{9,0x98,1472},{9,0x99,1536},{9,0x9A,1600},{9,0x9B,1728},{9,0xCC,704},{9,0xCD,768},{9,0xD2,832},{9,0xD3,896},{9,0xD4,960},{9,0xD5,1024},{9,0xD6,1088},{9,0xD7,1152},{9,0xD8,1216},{9,0xD9,1280},{9,0xDA,1344},{9,0xDB,1408},{10,0x01,_ff },{11,0x01,_ff },{11,0x08,1792},{11,0x0C,1856},{11,0x0D,1920},{12,0x00,EOF },{12,0x01,EOL },{12,0x12,1984},{12,0x13,2048},{12,0x14,2112},{12,0x15,2176},{12,0x16,2240},{12,0x17,2304},{12,0x1C,2368},{12,0x1D,2432},{12,0x1E,2496},{12,0x1F,2560}};
_bg =[][3]int {{2,0x02,3},{2,0x03,2},{3,0x02,1},{3,0x03,4},{4,0x02,6},{4,0x03,5},{5,0x03,7},{6,0x04,9},{6,0x05,8},{7,0x04,10},{7,0x05,11},{7,0x07,12},{8,0x04,13},{8,0x07,14},{9,0x01,_ff },{9,0x18,15},{10,0x01,_ff },{10,0x17,16},{10,0x18,17},{10,0x37,0},{10,0x08,18},{10,0x0F,64},{11,0x01,_ff },{11,0x17,24},{11,0x18,25},{11,0x28,23},{11,0x37,22},{11,0x67,19},{11,0x68,20},{11,0x6C,21},{11,0x08,1792},{11,0x0C,1856},{11,0x0D,1920},{12,0x00,EOF },{12,0x01,EOL },{12,0x12,1984},{12,0x13,2048},{12,0x14,2112},{12,0x15,2176},{12,0x16,2240},{12,0x17,2304},{12,0x1C,2368},{12,0x1D,2432},{12,0x1E,2496},{12,0x1F,2560},{12,0x24,52},{12,0x27,55},{12,0x28,56},{12,0x2B,59},{12,0x2C,60},{12,0x33,320},{12,0x34,384},{12,0x35,448},{12,0x37,53},{12,0x38,54},{12,0x52,50},{12,0x53,51},{12,0x54,44},{12,0x55,45},{12,0x56,46},{12,0x57,47},{12,0x58,57},{12,0x59,58},{12,0x5A,61},{12,0x5B,256},{12,0x64,48},{12,0x65,49},{12,0x66,62},{12,0x67,63},{12,0x68,30},{12,0x69,31},{12,0x6A,32},{12,0x6B,33},{12,0x6C,40},{12,0x6D,41},{12,0xC8,128},{12,0xC9,192},{12,0xCA,26},{12,0xCB,27},{12,0xCC,28},{12,0xCD,29},{12,0xD2,34},{12,0xD3,35},{12,0xD4,36},{12,0xD5,37},{12,0xD6,38},{12,0xD7,39},{12,0xDA,42},{12,0xDB,43},{13,0x4A,640},{13,0x4B,704},{13,0x4C,768},{13,0x4D,832},{13,0x52,1280},{13,0x53,1344},{13,0x54,1408},{13,0x55,1472},{13,0x5A,1536},{13,0x5B,1600},{13,0x64,1664},{13,0x65,1728},{13,0x6C,512},{13,0x6D,576},{13,0x72,896},{13,0x73,960},{13,0x74,1024},{13,0x75,1088},{13,0x76,1152},{13,0x77,1216}};
);func _ea (_eg ,_ca int )int {if _eg < _ca {return _ca ;};return _eg ;};func _cbfc (_af ,_dg int )int {if _af > _dg {return _dg ;};return _af ;};func _d (_ge [3]int )*code {return &code {_cb :_ge [0],_e :_ge [1],_gc :_ge [2]}};const (_bd mmrCode =iota ;
_dc ;_ce ;_bb ;_fe ;_fb ;_geb ;_fd ;_db ;_feg ;_ba ;);const (EOF =-3;_ff =-2;EOL =-1;_caf =8;_ad =(1<<_caf )-1;_egd =5;_ga =(1<<_egd )-1;);type Decoder struct{_gd ,_be int ;_ag *runData ;_bda []*code ;_ec []*code ;_baa []*code ;};func New (r _b .StreamReader ,width ,height int ,dataOffset ,dataLength int64 )(*Decoder ,error ){_bab :=&Decoder {_gd :width ,_be :height };
_egg ,_de :=_b .NewSubstreamReader (r ,uint64 (dataOffset ),uint64 (dataLength ));if _de !=nil {return nil ,_de ;};_bde ,_de :=_egeb (_egg );if _de !=nil {return nil ,_de ;};_bab ._ag =_bde ;if _df :=_bab .initTables ();_df !=nil {return nil ,_df ;};return _bab ,nil ;
};const (_dfge int =1024<<7;_cee int =3;_eae uint =24;);func (_cd *Decoder )fillBitmap (_fa *_ae .Bitmap ,_gcg int ,_ddf []int ,_ege int )error {var _cdf byte ;_gbfd :=0;_bf :=_fa .GetByteIndex (_gbfd ,_gcg );for _bea :=0;_bea < _ege ;_bea ++{_cbe :=byte (1);
_agg :=_ddf [_bea ];if (_bea &1)==0{_cbe =0;};for _gbfd < _agg {_cdf =(_cdf <<1)|_cbe ;_gbfd ++;if (_gbfd &7)==0{if _dec :=_fa .SetByte (_bf ,_cdf );_dec !=nil {return _dec ;};_bf ++;_cdf =0;};};};if (_gbfd &7)!=0{_cdf <<=uint (8-(_gbfd &7));if _gbc :=_fa .SetByte (_bf ,_cdf );
_gbc !=nil {return _gbc ;};};return nil ;};func (_cagb *runData )uncompressGetCodeLittleEndian (_cbaf []*code )(*code ,error ){_beef ,_age :=_cagb .uncompressGetNextCodeLittleEndian ();if _age !=nil {_a .Log .Debug ("\u0055n\u0063\u006fm\u0070\u0072\u0065\u0073s\u0047\u0065\u0074N\u0065\u0078\u0074\u0043\u006f\u0064\u0065\u004c\u0069tt\u006c\u0065\u0045n\u0064\u0069a\u006e\u0020\u0066\u0061\u0069\u006ce\u0064\u003a \u0025\u0076",_age );
return nil ,_age ;};_beef &=0xffffff;_ef :=_beef >>(_eae -_caf );_cdd :=_cbaf [_ef ];if _cdd !=nil &&_cdd ._ed {_ef =(_beef >>(_eae -_caf -_egd ))&_ga ;_cdd =_cdd ._f [_ef ];};return _cdd ,nil ;};type mmrCode int ;func (_bc *Decoder )detectAndSkipEOL ()error {for {_cac ,_cc :=_bc ._ag .uncompressGetCode (_bc ._baa );
if _cc !=nil {return _cc ;};if _cac !=nil &&_cac ._gc ==EOL {_bc ._ag ._dfc +=_cac ._cb ;}else {return nil ;};};};func _egeb (_cgc *_b .SubstreamReader )(*runData ,error ){_ccd :=&runData {_gdc :_cgc ,_dfc :0,_gfbc :1};_aaf :=_cbfc (_ea (_cee ,int (_cgc .Length ())),_dfge );
_ccd ._cfe =make ([]byte ,_aaf );if _gad :=_ccd .fillBuffer (0);_gad !=nil {if _gad ==_gg .EOF {_ccd ._cfe =make ([]byte ,10);_a .Log .Debug ("F\u0069\u006c\u006c\u0042uf\u0066e\u0072\u0020\u0066\u0061\u0069l\u0065\u0064\u003a\u0020\u0025\u0076",_gad );
}else {return nil ,_gad ;};};return _ccd ,nil ;};func (_cbf *code )String ()string {return _g .Sprintf ("\u0025\u0064\u002f\u0025\u0064\u002f\u0025\u0064",_cbf ._cb ,_cbf ._e ,_cbf ._gc );};func (_gca *Decoder )createLittleEndianTable (_beg [][3]int )([]*code ,error ){_bdbe :=make ([]*code ,_ad +1);
for _aa :=0;_aa < len (_beg );_aa ++{_ffa :=_d (_beg [_aa ]);if _ffa ._cb <=_caf {_ecd :=_caf -_ffa ._cb ;_dd :=_ffa ._e <<uint (_ecd );for _ab :=(1<<uint (_ecd ))-1;_ab >=0;_ab --{_edf :=_dd |_ab ;_bdbe [_edf ]=_ffa ;};}else {_bbb :=_ffa ._e >>uint (_ffa ._cb -_caf );
if _bdbe [_bbb ]==nil {var _afc =_d ([3]int {});_afc ._f =make ([]*code ,_ga +1);_bdbe [_bbb ]=_afc ;};if _ffa ._cb <=_caf +_egd {_gef :=_caf +_egd -_ffa ._cb ;_cae :=(_ffa ._e <<uint (_gef ))&_ga ;_bdbe [_bbb ]._ed =true ;for _aeb :=(1<<uint (_gef ))-1;
_aeb >=0;_aeb --{_bdbe [_bbb ]._f [_cae |_aeb ]=_ffa ;};}else {return nil ,_gb .New ("\u0043\u006f\u0064\u0065\u0020\u0074a\u0062\u006c\u0065\u0020\u006f\u0076\u0065\u0072\u0066\u006c\u006f\u0077\u0020i\u006e\u0020\u004d\u004d\u0052\u0044\u0065c\u006f\u0064\u0065\u0072");
};};};return _bdbe ,nil ;};func (_eec *runData )fillBuffer (_cga int )error {_eec ._dece =_cga ;_ ,_geg :=_eec ._gdc .Seek (int64 (_cga ),_gg .SeekStart );if _geg !=nil {if _geg ==_gg .EOF {_a .Log .Debug ("\u0053\u0065\u0061\u006b\u0020\u0045\u004f\u0046");
_eec ._dea =-1;}else {return _geg ;};};if _geg ==nil {_eec ._dea ,_geg =_eec ._gdc .Read (_eec ._cfe );if _geg !=nil {if _geg ==_gg .EOF {_a .Log .Trace ("\u0052\u0065\u0061\u0064\u0020\u0045\u004f\u0046");_eec ._dea =-1;}else {return _geg ;};};};if _eec ._dea > -1&&_eec ._dea < 3{for _eec ._dea < 3{_gdg ,_baac :=_eec ._gdc .ReadByte ();
if _baac !=nil {if _baac ==_gg .EOF {_eec ._cfe [_eec ._dea ]=0;}else {return _baac ;};}else {_eec ._cfe [_eec ._dea ]=_gdg &0xFF;};_eec ._dea ++;};};_eec ._dea -=3;if _eec ._dea < 0{_eec ._cfe =make ([]byte ,len (_eec ._cfe ));_eec ._dea =len (_eec ._cfe )-3;
};return nil ;};type code struct{_cb int ;_e int ;_gc int ;_f []*code ;_ed bool ;};func (_ccf *Decoder )uncompress1d (_bgg *runData ,_dfb []int ,_gf int )(int ,error ){var (_bca =true ;_eca int ;_fbc *code ;_cad int ;_cce error ;);_agf :for _eca < _gf {_bdad :for {if _bca {_fbc ,_cce =_bgg .uncompressGetCode (_ccf ._bda );
if _cce !=nil {return 0,_cce ;};}else {_fbc ,_cce =_bgg .uncompressGetCode (_ccf ._ec );if _cce !=nil {return 0,_cce ;};};_bgg ._dfc +=_fbc ._cb ;if _fbc ._gc < 0{break _agf ;};_eca +=_fbc ._gc ;if _fbc ._gc < 64{_bca =!_bca ;_dfb [_cad ]=_eca ;_cad ++;
break _bdad ;};};};if _dfb [_cad ]!=_gf {_dfb [_cad ]=_gf ;};_ac :=EOL ;if _fbc !=nil &&_fbc ._gc !=EOL {_ac =_cad ;};return _ac ,nil ;};func (_ddc *Decoder )initTables ()(_cec error ){if _ddc ._bda ==nil {_ddc ._bda ,_cec =_ddc .createLittleEndianTable (_fec );
if _cec !=nil {return ;};_ddc ._ec ,_cec =_ddc .createLittleEndianTable (_bg );if _cec !=nil {return ;};_ddc ._baa ,_cec =_ddc .createLittleEndianTable (_gbf );if _cec !=nil {return ;};};return nil ;};func (_cag *runData )uncompressGetCode (_gbb []*code )(*code ,error ){return _cag .uncompressGetCodeLittleEndian (_gbb );
};func (_cde *runData )align (){_cde ._dfc =((_cde ._dfc +7)>>3)<<3};func (_cfg *Decoder )uncompress2d (_bff *runData ,_cba []int ,_bef int ,_fg []int ,_gfc int )(int ,error ){var (_ecc int ;_fde int ;_ee int ;_gde =true ;_fbb error ;_fc *code ;);_cba [_bef ]=_gfc ;
_cba [_bef +1]=_gfc ;_cba [_bef +2]=_gfc +1;_cba [_bef +3]=_gfc +1;_dfg :for _ee < _gfc {_fc ,_fbb =_bff .uncompressGetCode (_cfg ._baa );if _fbb !=nil {return EOL ,nil ;};if _fc ==nil {_bff ._dfc ++;break _dfg ;};_bff ._dfc +=_fc ._cb ;switch mmrCode (_fc ._gc ){case _ce :_ee =_cba [_ecc ];
case _bb :_ee =_cba [_ecc ]+1;case _geb :_ee =_cba [_ecc ]-1;case _dc :for {var _fdf []*code ;if _gde {_fdf =_cfg ._bda ;}else {_fdf =_cfg ._ec ;};_fc ,_fbb =_bff .uncompressGetCode (_fdf );if _fbb !=nil {return 0,_fbb ;};if _fc ==nil {break _dfg ;};_bff ._dfc +=_fc ._cb ;
if _fc ._gc < 64{if _fc ._gc < 0{_fg [_fde ]=_ee ;_fde ++;_fc =nil ;break _dfg ;};_ee +=_fc ._gc ;_fg [_fde ]=_ee ;_fde ++;break ;};_ee +=_fc ._gc ;};_gfb :=_ee ;_ffad :for {var _bfb []*code ;if !_gde {_bfb =_cfg ._bda ;}else {_bfb =_cfg ._ec ;};_fc ,_fbb =_bff .uncompressGetCode (_bfb );
if _fbb !=nil {return 0,_fbb ;};if _fc ==nil {break _dfg ;};_bff ._dfc +=_fc ._cb ;if _fc ._gc < 64{if _fc ._gc < 0{_fg [_fde ]=_ee ;_fde ++;break _dfg ;};_ee +=_fc ._gc ;if _ee < _gfc ||_ee !=_gfb {_fg [_fde ]=_ee ;_fde ++;};break _ffad ;};_ee +=_fc ._gc ;
};for _ee < _gfc &&_cba [_ecc ]<=_ee {_ecc +=2;};continue _dfg ;case _bd :_ecc ++;_ee =_cba [_ecc ];_ecc ++;continue _dfg ;case _fe :_ee =_cba [_ecc ]+2;case _fd :_ee =_cba [_ecc ]-2;case _fb :_ee =_cba [_ecc ]+3;case _db :_ee =_cba [_ecc ]-3;default:if _bff ._dfc ==12&&_fc ._gc ==EOL {_bff ._dfc =0;
if _ ,_fbb =_cfg .uncompress1d (_bff ,_cba ,_gfc );_fbb !=nil {return 0,_fbb ;};_bff ._dfc ++;if _ ,_fbb =_cfg .uncompress1d (_bff ,_fg ,_gfc );_fbb !=nil {return 0,_fbb ;};_afd ,_adb :=_cfg .uncompress1d (_bff ,_cba ,_gfc );if _adb !=nil {return EOF ,_adb ;
};_bff ._dfc ++;return _afd ,nil ;};_ee =_gfc ;continue _dfg ;};if _ee <=_gfc {_gde =!_gde ;_fg [_fde ]=_ee ;_fde ++;if _ecc > 0{_ecc --;}else {_ecc ++;};for _ee < _gfc &&_cba [_ecc ]<=_ee {_ecc +=2;};};};if _fg [_fde ]!=_gfc {_fg [_fde ]=_gfc ;};if _fc ==nil {return EOL ,nil ;
};return _fde ,nil ;};type runData struct{_gdc *_b .SubstreamReader ;_dfc int ;_gfbc int ;_ffadb int ;_cfe []byte ;_dece int ;_dea int ;};func (_ccb *runData )uncompressGetNextCodeLittleEndian ()(int ,error ){_bbc :=_ccb ._dfc -_ccb ._gfbc ;if _bbc < 0||_bbc > 24{_baaf :=(_ccb ._dfc >>3)-_ccb ._dece ;
if _baaf >=_ccb ._dea {_baaf +=_ccb ._dece ;if _bege :=_ccb .fillBuffer (_baaf );_bege !=nil {return 0,_bege ;};_baaf -=_ccb ._dece ;};_ged :=(uint32 (_ccb ._cfe [_baaf ]&0xFF)<<16)|(uint32 (_ccb ._cfe [_baaf +1]&0xFF)<<8)|(uint32 (_ccb ._cfe [_baaf +2]&0xFF));
_cfgf :=uint32 (_ccb ._dfc &7);_ged <<=_cfgf ;_ccb ._ffadb =int (_ged );}else {_ceg :=_ccb ._gfbc &7;_aac :=7-_ceg ;if _bbc <=_aac {_ccb ._ffadb <<=uint (_bbc );}else {_agge :=(_ccb ._gfbc >>3)+3-_ccb ._dece ;if _agge >=_ccb ._dea {_agge +=_ccb ._dece ;
if _bcc :=_ccb .fillBuffer (_agge );_bcc !=nil {return 0,_bcc ;};_agge -=_ccb ._dece ;};_ceg =8-_ceg ;for {_ccb ._ffadb <<=uint (_ceg );_ccb ._ffadb |=int (uint (_ccb ._cfe [_agge ])&0xFF);_bbc -=_ceg ;_agge ++;_ceg =8;if !(_bbc >=8){break ;};};_ccb ._ffadb <<=uint (_bbc );
};};_ccb ._gfbc =_ccb ._dfc ;return _ccb ._ffadb ,nil ;};