//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package mmr ;import (_g "errors";_e "fmt";_b "github.com/unidoc/unipdf/v3/common";_ed "github.com/unidoc/unipdf/v3/internal/bitwise";_fe "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_f "io";);func _eg (_d [3]int )*code {return &code {_fc :_d [0],_be :_d [1],_a :_d [2]}};
func (_bee *runData )align (){_bee ._bdf =((_bee ._bdf +7)>>3)<<3};const (EOF =-3;_ee =-2;EOL =-1;_gg =8;_fafb =(1<<_gg )-1;_dc =5;_bd =(1<<_dc )-1;);func (_dee *Decoder )fillBitmap (_ga *_fe .Bitmap ,_abfd int ,_cd []int ,_faa int )error {var _fge byte ;
_dddg :=0;_daee :=_ga .GetByteIndex (_dddg ,_abfd );for _bgf :=0;_bgf < _faa ;_bgf ++{_ffg :=byte (1);_add :=_cd [_bgf ];if (_bgf &1)==0{_ffg =0;};for _dddg < _add {_fge =(_fge <<1)|_ffg ;_dddg ++;if (_dddg &7)==0{if _ggb :=_ga .SetByte (_daee ,_fge );
_ggb !=nil {return _ggb ;};_daee ++;_fge =0;};};};if (_dddg &7)!=0{_fge <<=uint (8-(_dddg &7));if _bcb :=_ga .SetByte (_daee ,_fge );_bcb !=nil {return _bcb ;};};return nil ;};func (_fca *runData )uncompressGetCodeLittleEndian (_cdf []*code )(*code ,error ){_dda ,_dbf :=_fca .uncompressGetNextCodeLittleEndian ();
if _dbf !=nil {_b .Log .Debug ("\u0055n\u0063\u006fm\u0070\u0072\u0065\u0073s\u0047\u0065\u0074N\u0065\u0078\u0074\u0043\u006f\u0064\u0065\u004c\u0069tt\u006c\u0065\u0045n\u0064\u0069a\u006e\u0020\u0066\u0061\u0069\u006ce\u0064\u003a \u0025\u0076",_dbf );
return nil ,_dbf ;};_dda &=0xffffff;_cbe :=_dda >>(_bdg -_gg );_dbd :=_cdf [_cbe ];if _dbd !=nil &&_dbd ._ge {_cbe =(_dda >>(_bdg -_gg -_dc ))&_bd ;_dbd =_dbd ._bg [_cbe ];};return _dbd ,nil ;};func (_bfe *runData )uncompressGetCode (_cc []*code )(*code ,error ){return _bfe .uncompressGetCodeLittleEndian (_cc );
};func _gge (_edb *_ed .SubstreamReader )(*runData ,error ){_cbc :=&runData {_ae :_edb ,_bdf :0,_fdgb :1};_egb :=_de (_fd (_fgea ,int (_edb .Length ())),_cgd );_cbc ._bab =make ([]byte ,_egb );if _eaf :=_cbc .fillBuffer (0);_eaf !=nil {if _eaf ==_f .EOF {_cbc ._bab =make ([]byte ,10);
_b .Log .Debug ("F\u0069\u006c\u006c\u0042uf\u0066e\u0072\u0020\u0066\u0061\u0069l\u0065\u0064\u003a\u0020\u0025\u0076",_eaf );}else {return nil ,_eaf ;};};return _cbc ,nil ;};func (_bf *Decoder )UncompressMMR ()(_eaa *_fe .Bitmap ,_fb error ){_eaa =_fe .New (_bf ._abf ,_bf ._ea );
_cg :=make ([]int ,_eaa .Width +5);_gcg :=make ([]int ,_eaa .Width +5);_gcg [0]=_eaa .Width ;_fdf :=1;var _dcf int ;for _dfg :=0;_dfg < _eaa .Height ;_dfg ++{_dcf ,_fb =_bf .uncompress2d (_bf ._gga ,_gcg ,_fdf ,_cg ,_eaa .Width );if _fb !=nil {return nil ,_fb ;
};if _dcf ==EOF {break ;};if _dcf > 0{_fb =_bf .fillBitmap (_eaa ,_dfg ,_cg ,_dcf );if _fb !=nil {return nil ,_fb ;};};_gcg ,_cg =_cg ,_gcg ;_fdf =_dcf ;};if _fb =_bf .detectAndSkipEOL ();_fb !=nil {return nil ,_fb ;};_bf ._gga .align ();return _eaa ,nil ;
};type runData struct{_ae *_ed .SubstreamReader ;_bdf int ;_fdgb int ;_abfe int ;_bab []byte ;_gbd int ;_gegg int ;};func (_afe *Decoder )uncompress2d (_gee *runData ,_fba []int ,_gbg int ,_egd []int ,_ca int )(int ,error ){var (_dfa int ;_cae int ;_agb int ;
_fcb =true ;_bfb error ;_age *code ;);_fba [_gbg ]=_ca ;_fba [_gbg +1]=_ca ;_fba [_gbg +2]=_ca +1;_fba [_gbg +3]=_ca +1;_dfb :for _agb < _ca {_age ,_bfb =_gee .uncompressGetCode (_afe ._eb );if _bfb !=nil {return EOL ,nil ;};if _age ==nil {_gee ._bdf ++;
break _dfb ;};_gee ._bdf +=_age ._fc ;switch mmrCode (_age ._a ){case _efg :_agb =_fba [_dfa ];case _ad :_agb =_fba [_dfa ]+1;case _fad :_agb =_fba [_dfa ]-1;case _fa :for {var _gcb []*code ;if _fcb {_gcb =_afe ._ba ;}else {_gcb =_afe ._adg ;};_age ,_bfb =_gee .uncompressGetCode (_gcb );
if _bfb !=nil {return 0,_bfb ;};if _age ==nil {break _dfb ;};_gee ._bdf +=_age ._fc ;if _age ._a < 64{if _age ._a < 0{_egd [_cae ]=_agb ;_cae ++;_age =nil ;break _dfb ;};_agb +=_age ._a ;_egd [_cae ]=_agb ;_cae ++;break ;};_agb +=_age ._a ;};_efeg :=_agb ;
_cag :for {var _afeg []*code ;if !_fcb {_afeg =_afe ._ba ;}else {_afeg =_afe ._adg ;};_age ,_bfb =_gee .uncompressGetCode (_afeg );if _bfb !=nil {return 0,_bfb ;};if _age ==nil {break _dfb ;};_gee ._bdf +=_age ._fc ;if _age ._a < 64{if _age ._a < 0{_egd [_cae ]=_agb ;
_cae ++;break _dfb ;};_agb +=_age ._a ;if _agb < _ca ||_agb !=_efeg {_egd [_cae ]=_agb ;_cae ++;};break _cag ;};_agb +=_age ._a ;};for _agb < _ca &&_fba [_dfa ]<=_agb {_dfa +=2;};continue _dfb ;case _gd :_dfa ++;_agb =_fba [_dfa ];_dfa ++;continue _dfb ;
case _faf :_agb =_fba [_dfa ]+2;case _fda :_agb =_fba [_dfa ]-2;case _ab :_agb =_fba [_dfa ]+3;case _eda :_agb =_fba [_dfa ]-3;default:if _gee ._bdf ==12&&_age ._a ==EOL {_gee ._bdf =0;if _ ,_bfb =_afe .uncompress1d (_gee ,_fba ,_ca );_bfb !=nil {return 0,_bfb ;
};_gee ._bdf ++;if _ ,_bfb =_afe .uncompress1d (_gee ,_egd ,_ca );_bfb !=nil {return 0,_bfb ;};_bed ,_agg :=_afe .uncompress1d (_gee ,_fba ,_ca );if _agg !=nil {return EOF ,_agg ;};_gee ._bdf ++;return _bed ,nil ;};_agb =_ca ;continue _dfb ;};if _agb <=_ca {_fcb =!_fcb ;
_egd [_cae ]=_agb ;_cae ++;if _dfa > 0{_dfa --;}else {_dfa ++;};for _agb < _ca &&_fba [_dfa ]<=_agb {_dfa +=2;};};};if _egd [_cae ]!=_ca {_egd [_cae ]=_ca ;};if _age ==nil {return EOL ,nil ;};return _cae ,nil ;};func (_df *code )String ()string {return _e .Sprintf ("\u0025\u0064\u002f\u0025\u0064\u002f\u0025\u0064",_df ._fc ,_df ._be ,_df ._a );
};type code struct{_fc int ;_be int ;_a int ;_bg []*code ;_ge bool ;};func New (r _ed .StreamReader ,width ,height int ,dataOffset ,dataLength int64 )(*Decoder ,error ){_bgb :=&Decoder {_abf :width ,_ea :height };_db ,_ggae :=_ed .NewSubstreamReader (r ,uint64 (dataOffset ),uint64 (dataLength ));
if _ggae !=nil {return nil ,_ggae ;};_gf ,_ggae :=_gge (_db );if _ggae !=nil {return nil ,_ggae ;};_bgb ._gga =_gf ;if _dd :=_bgb .initTables ();_dd !=nil {return nil ,_dd ;};return _bgb ,nil ;};type Decoder struct{_abf ,_ea int ;_gga *runData ;_ba []*code ;
_adg []*code ;_eb []*code ;};var (_geg =[][3]int {{4,0x1,int (_gd )},{3,0x1,int (_fa )},{1,0x1,int (_efg )},{3,0x3,int (_ad )},{6,0x3,int (_faf )},{7,0x3,int (_ab )},{3,0x2,int (_fad )},{6,0x2,int (_fda )},{7,0x2,int (_eda )},{10,0xf,int (_acc )},{12,0xf,int (_egc )},{12,0x1,int (EOL )}};
_fdab =[][3]int {{4,0x07,2},{4,0x08,3},{4,0x0B,4},{4,0x0C,5},{4,0x0E,6},{4,0x0F,7},{5,0x12,128},{5,0x13,8},{5,0x14,9},{5,0x1B,64},{5,0x07,10},{5,0x08,11},{6,0x17,192},{6,0x18,1664},{6,0x2A,16},{6,0x2B,17},{6,0x03,13},{6,0x34,14},{6,0x35,15},{6,0x07,1},{6,0x08,12},{7,0x13,26},{7,0x17,21},{7,0x18,28},{7,0x24,27},{7,0x27,18},{7,0x28,24},{7,0x2B,25},{7,0x03,22},{7,0x37,256},{7,0x04,23},{7,0x08,20},{7,0xC,19},{8,0x12,33},{8,0x13,34},{8,0x14,35},{8,0x15,36},{8,0x16,37},{8,0x17,38},{8,0x1A,31},{8,0x1B,32},{8,0x02,29},{8,0x24,53},{8,0x25,54},{8,0x28,39},{8,0x29,40},{8,0x2A,41},{8,0x2B,42},{8,0x2C,43},{8,0x2D,44},{8,0x03,30},{8,0x32,61},{8,0x33,62},{8,0x34,63},{8,0x35,0},{8,0x36,320},{8,0x37,384},{8,0x04,45},{8,0x4A,59},{8,0x4B,60},{8,0x5,46},{8,0x52,49},{8,0x53,50},{8,0x54,51},{8,0x55,52},{8,0x58,55},{8,0x59,56},{8,0x5A,57},{8,0x5B,58},{8,0x64,448},{8,0x65,512},{8,0x67,640},{8,0x68,576},{8,0x0A,47},{8,0x0B,48},{9,0x01,_ee },{9,0x98,1472},{9,0x99,1536},{9,0x9A,1600},{9,0x9B,1728},{9,0xCC,704},{9,0xCD,768},{9,0xD2,832},{9,0xD3,896},{9,0xD4,960},{9,0xD5,1024},{9,0xD6,1088},{9,0xD7,1152},{9,0xD8,1216},{9,0xD9,1280},{9,0xDA,1344},{9,0xDB,1408},{10,0x01,_ee },{11,0x01,_ee },{11,0x08,1792},{11,0x0C,1856},{11,0x0D,1920},{12,0x00,EOF },{12,0x01,EOL },{12,0x12,1984},{12,0x13,2048},{12,0x14,2112},{12,0x15,2176},{12,0x16,2240},{12,0x17,2304},{12,0x1C,2368},{12,0x1D,2432},{12,0x1E,2496},{12,0x1F,2560}};
_efe =[][3]int {{2,0x02,3},{2,0x03,2},{3,0x02,1},{3,0x03,4},{4,0x02,6},{4,0x03,5},{5,0x03,7},{6,0x04,9},{6,0x05,8},{7,0x04,10},{7,0x05,11},{7,0x07,12},{8,0x04,13},{8,0x07,14},{9,0x01,_ee },{9,0x18,15},{10,0x01,_ee },{10,0x17,16},{10,0x18,17},{10,0x37,0},{10,0x08,18},{10,0x0F,64},{11,0x01,_ee },{11,0x17,24},{11,0x18,25},{11,0x28,23},{11,0x37,22},{11,0x67,19},{11,0x68,20},{11,0x6C,21},{11,0x08,1792},{11,0x0C,1856},{11,0x0D,1920},{12,0x00,EOF },{12,0x01,EOL },{12,0x12,1984},{12,0x13,2048},{12,0x14,2112},{12,0x15,2176},{12,0x16,2240},{12,0x17,2304},{12,0x1C,2368},{12,0x1D,2432},{12,0x1E,2496},{12,0x1F,2560},{12,0x24,52},{12,0x27,55},{12,0x28,56},{12,0x2B,59},{12,0x2C,60},{12,0x33,320},{12,0x34,384},{12,0x35,448},{12,0x37,53},{12,0x38,54},{12,0x52,50},{12,0x53,51},{12,0x54,44},{12,0x55,45},{12,0x56,46},{12,0x57,47},{12,0x58,57},{12,0x59,58},{12,0x5A,61},{12,0x5B,256},{12,0x64,48},{12,0x65,49},{12,0x66,62},{12,0x67,63},{12,0x68,30},{12,0x69,31},{12,0x6A,32},{12,0x6B,33},{12,0x6C,40},{12,0x6D,41},{12,0xC8,128},{12,0xC9,192},{12,0xCA,26},{12,0xCB,27},{12,0xCC,28},{12,0xCD,29},{12,0xD2,34},{12,0xD3,35},{12,0xD4,36},{12,0xD5,37},{12,0xD6,38},{12,0xD7,39},{12,0xDA,42},{12,0xDB,43},{13,0x4A,640},{13,0x4B,704},{13,0x4C,768},{13,0x4D,832},{13,0x52,1280},{13,0x53,1344},{13,0x54,1408},{13,0x55,1472},{13,0x5A,1536},{13,0x5B,1600},{13,0x64,1664},{13,0x65,1728},{13,0x6C,512},{13,0x6D,576},{13,0x72,896},{13,0x73,960},{13,0x74,1024},{13,0x75,1088},{13,0x76,1152},{13,0x77,1216}};
);func (_eea *Decoder )createLittleEndianTable (_ff [][3]int )([]*code ,error ){_cb :=make ([]*code ,_fafb +1);for _gb :=0;_gb < len (_ff );_gb ++{_ddd :=_eg (_ff [_gb ]);if _ddd ._fc <=_gg {_da :=_gg -_ddd ._fc ;_ffa :=_ddd ._be <<uint (_da );for _eae :=(1<<uint (_da ))-1;
_eae >=0;_eae --{_def :=_ffa |_eae ;_cb [_def ]=_ddd ;};}else {_dae :=_ddd ._be >>uint (_ddd ._fc -_gg );if _cb [_dae ]==nil {var _bc =_eg ([3]int {});_bc ._bg =make ([]*code ,_bd +1);_cb [_dae ]=_bc ;};if _ddd ._fc <=_gg +_dc {_fde :=_gg +_dc -_ddd ._fc ;
_ddg :=(_ddd ._be <<uint (_fde ))&_bd ;_cb [_dae ]._ge =true ;for _bad :=(1<<uint (_fde ))-1;_bad >=0;_bad --{_cb [_dae ]._bg [_ddg |_bad ]=_ddd ;};}else {return nil ,_g .New ("\u0043\u006f\u0064\u0065\u0020\u0074a\u0062\u006c\u0065\u0020\u006f\u0076\u0065\u0072\u0066\u006c\u006f\u0077\u0020i\u006e\u0020\u004d\u004d\u0052\u0044\u0065c\u006f\u0064\u0065\u0072");
};};};return _cb ,nil ;};const (_gd mmrCode =iota ;_fa ;_efg ;_ad ;_faf ;_ab ;_fad ;_fda ;_eda ;_acc ;_egc ;);func (_cbb *Decoder )uncompress1d (_cde *runData ,_fef []int ,_daec int )(int ,error ){var (_cf =true ;_daf int ;_bdc *code ;_acd int ;_abb error ;
);_gfg :for _daf < _daec {_edaa :for {if _cf {_bdc ,_abb =_cde .uncompressGetCode (_cbb ._ba );if _abb !=nil {return 0,_abb ;};}else {_bdc ,_abb =_cde .uncompressGetCode (_cbb ._adg );if _abb !=nil {return 0,_abb ;};};_cde ._bdf +=_bdc ._fc ;if _bdc ._a < 0{break _gfg ;
};_daf +=_bdc ._a ;if _bdc ._a < 64{_cf =!_cf ;_fef [_acd ]=_daf ;_acd ++;break _edaa ;};};};if _fef [_acd ]!=_daec {_fef [_acd ]=_daec ;};_ag :=EOL ;if _bdc !=nil &&_bdc ._a !=EOL {_ag =_acd ;};return _ag ,nil ;};type mmrCode int ;func _de (_ef ,_fg int )int {if _ef > _fg {return _fg ;
};return _ef ;};func (_aa *runData )fillBuffer (_ged int )error {_aa ._gbd =_ged ;_ ,_eec :=_aa ._ae .Seek (int64 (_ged ),_f .SeekStart );if _eec !=nil {if _eec ==_f .EOF {_b .Log .Debug ("\u0053\u0065\u0061\u006b\u0020\u0045\u004f\u0046");_aa ._gegg =-1;
}else {return _eec ;};};if _eec ==nil {_aa ._gegg ,_eec =_aa ._ae .Read (_aa ._bab );if _eec !=nil {if _eec ==_f .EOF {_b .Log .Trace ("\u0052\u0065\u0061\u0064\u0020\u0045\u004f\u0046");_aa ._gegg =-1;}else {return _eec ;};};};if _aa ._gegg > -1&&_aa ._gegg < 3{for _aa ._gegg < 3{_feg ,_ddb :=_aa ._ae .ReadByte ();
if _ddb !=nil {if _ddb ==_f .EOF {_aa ._bab [_aa ._gegg ]=0;}else {return _ddb ;};}else {_aa ._bab [_aa ._gegg ]=_feg &0xFF;};_aa ._gegg ++;};};_aa ._gegg -=3;if _aa ._gegg < 0{_aa ._bab =make ([]byte ,len (_aa ._bab ));_aa ._gegg =len (_aa ._bab )-3;};
return nil ;};func (_fac *runData )uncompressGetNextCodeLittleEndian ()(int ,error ){_dab :=_fac ._bdf -_fac ._fdgb ;if _dab < 0||_dab > 24{_beea :=(_fac ._bdf >>3)-_fac ._gbd ;if _beea >=_fac ._gegg {_beea +=_fac ._gbd ;if _bcg :=_fac .fillBuffer (_beea );
_bcg !=nil {return 0,_bcg ;};_beea -=_fac ._gbd ;};_fdb :=(uint32 (_fac ._bab [_beea ]&0xFF)<<16)|(uint32 (_fac ._bab [_beea +1]&0xFF)<<8)|(uint32 (_fac ._bab [_beea +2]&0xFF));_gdb :=uint32 (_fac ._bdf &7);_fdb <<=_gdb ;_fac ._abfe =int (_fdb );}else {_egg :=_fac ._fdgb &7;
_babd :=7-_egg ;if _dab <=_babd {_fac ._abfe <<=uint (_dab );}else {_dbc :=(_fac ._fdgb >>3)+3-_fac ._gbd ;if _dbc >=_fac ._gegg {_dbc +=_fac ._gbd ;if _accf :=_fac .fillBuffer (_dbc );_accf !=nil {return 0,_accf ;};_dbc -=_fac ._gbd ;};_egg =8-_egg ;for {_fac ._abfe <<=uint (_egg );
_fac ._abfe |=int (uint (_fac ._bab [_dbc ])&0xFF);_dab -=_egg ;_dbc ++;_egg =8;if !(_dab >=8){break ;};};_fac ._abfe <<=uint (_dab );};};_fac ._fdgb =_fac ._bdf ;return _fac ._abfe ,nil ;};func (_af *Decoder )initTables ()(_fdg error ){if _af ._ba ==nil {_af ._ba ,_fdg =_af .createLittleEndianTable (_fdab );
if _fdg !=nil {return ;};_af ._adg ,_fdg =_af .createLittleEndianTable (_efe );if _fdg !=nil {return ;};_af ._eb ,_fdg =_af .createLittleEndianTable (_geg );if _fdg !=nil {return ;};};return nil ;};func _fd (_gc ,_ac int )int {if _gc < _ac {return _ac ;
};return _gc ;};func (_fbg *Decoder )detectAndSkipEOL ()error {for {_fcf ,_gbb :=_fbg ._gga .uncompressGetCode (_fbg ._eb );if _gbb !=nil {return _gbb ;};if _fcf !=nil &&_fcf ._a ==EOL {_fbg ._gga ._bdf +=_fcf ._fc ;}else {return nil ;};};};const (_cgd int =1024<<7;
_fgea int =3;_bdg uint =24;);