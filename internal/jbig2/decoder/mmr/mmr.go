//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package mmr ;import (_d "errors";_b "fmt";_f "github.com/unidoc/unipdf/v3/common";_bf "github.com/unidoc/unipdf/v3/internal/bitwise";_fa "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_a "io";);type runData struct{_dge *_bf .SubstreamReader ;_acc int ;
_fde int ;_bdf int ;_gda []byte ;_bddf int ;_gag int ;};func (_addg *runData )fillBuffer (_gge int )error {_addg ._bddf =_gge ;_ ,_ddf :=_addg ._dge .Seek (int64 (_gge ),_a .SeekStart );if _ddf !=nil {if _ddf ==_a .EOF {_f .Log .Debug ("\u0053\u0065\u0061\u006b\u0020\u0045\u004f\u0046");
_addg ._gag =-1;}else {return _ddf ;};};if _ddf ==nil {_addg ._gag ,_ddf =_addg ._dge .Read (_addg ._gda );if _ddf !=nil {if _ddf ==_a .EOF {_f .Log .Trace ("\u0052\u0065\u0061\u0064\u0020\u0045\u004f\u0046");_addg ._gag =-1;}else {return _ddf ;};};};if _addg ._gag > -1&&_addg ._gag < 3{for _addg ._gag < 3{_fdc ,_egc :=_addg ._dge .ReadByte ();
if _egc !=nil {if _egc ==_a .EOF {_addg ._gda [_addg ._gag ]=0;}else {return _egc ;};}else {_addg ._gda [_addg ._gag ]=_fdc &0xFF;};_addg ._gag ++;};};_addg ._gag -=3;if _addg ._gag < 0{_addg ._gda =make ([]byte ,len (_addg ._gda ));_addg ._gag =len (_addg ._gda )-3;
};return nil ;};func (_ebe *Decoder )initTables ()(_bgg error ){if _ebe ._eb ==nil {_ebe ._eb ,_bgg =_ebe .createLittleEndianTable (_eg );if _bgg !=nil {return ;};_ebe ._gg ,_bgg =_ebe .createLittleEndianTable (_ee );if _bgg !=nil {return ;};_ebe ._eea ,_bgg =_ebe .createLittleEndianTable (_bde );
if _bgg !=nil {return ;};};return nil ;};const (_dbbf int =1024<<7;_egf int =3;_eadg uint =24;);func (_gef *Decoder )createLittleEndianTable (_dff [][3]int )([]*code ,error ){_adbc :=make ([]*code ,_ad +1);for _fd :=0;_fd < len (_dff );_fd ++{_ga :=_bb (_dff [_fd ]);
if _ga ._db <=_ge {_cbg :=_ge -_ga ._db ;_bdg :=_ga ._de <<uint (_cbg );for _bea :=(1<<uint (_cbg ))-1;_bea >=0;_bea --{_fca :=_bdg |_bea ;_adbc [_fca ]=_ga ;};}else {_bbb :=_ga ._de >>uint (_ga ._db -_ge );if _adbc [_bbb ]==nil {var _ba =_bb ([3]int {});
_ba ._bd =make ([]*code ,_fg +1);_adbc [_bbb ]=_ba ;};if _ga ._db <=_ge +_df {_dad :=_ge +_df -_ga ._db ;_dec :=(_ga ._de <<uint (_dad ))&_fg ;_adbc [_bbb ]._gf =true ;for _ac :=(1<<uint (_dad ))-1;_ac >=0;_ac --{_adbc [_bbb ]._bd [_dec |_ac ]=_ga ;};}else {return nil ,_d .New ("\u0043\u006f\u0064\u0065\u0020\u0074a\u0062\u006c\u0065\u0020\u006f\u0076\u0065\u0072\u0066\u006c\u006f\u0077\u0020i\u006e\u0020\u004d\u004d\u0052\u0044\u0065c\u006f\u0064\u0065\u0072");
};};};return _adbc ,nil ;};type mmrCode int ;func _accd (_gcf *_bf .SubstreamReader )(*runData ,error ){_dcb :=&runData {_dge :_gcf ,_acc :0,_fde :1};_ae :=_cd (_gff (_egf ,int (_gcf .Length ())),_dbbf );_dcb ._gda =make ([]byte ,_ae );if _ffb :=_dcb .fillBuffer (0);
_ffb !=nil {if _ffb ==_a .EOF {_dcb ._gda =make ([]byte ,10);_f .Log .Debug ("F\u0069\u006c\u006c\u0042uf\u0066e\u0072\u0020\u0066\u0061\u0069l\u0065\u0064\u003a\u0020\u0025\u0076",_ffb );}else {return nil ,_ffb ;};};return _dcb ,nil ;};func (_ea *Decoder )uncompress2d (_eae *runData ,_gac []int ,_ffd int ,_dgf []int ,_gfga int )(int ,error ){var (_gbg int ;
_adg int ;_cdfa int ;_fdb =true ;_gcc error ;_ead *code ;);_gac [_ffd ]=_gfga ;_gac [_ffd +1]=_gfga ;_gac [_ffd +2]=_gfga +1;_gac [_ffd +3]=_gfga +1;_cc :for _cdfa < _gfga {_ead ,_gcc =_eae .uncompressGetCode (_ea ._eea );if _gcc !=nil {return EOL ,nil ;
};if _ead ==nil {_eae ._acc ++;break _cc ;};_eae ._acc +=_ead ._db ;switch mmrCode (_ead ._c ){case _ca :_cdfa =_gac [_gbg ];case _bbe :_cdfa =_gac [_gbg ]+1;case _bg :_cdfa =_gac [_gbg ]-1;case _be :for {var _dcg []*code ;if _fdb {_dcg =_ea ._eb ;}else {_dcg =_ea ._gg ;
};_ead ,_gcc =_eae .uncompressGetCode (_dcg );if _gcc !=nil {return 0,_gcc ;};if _ead ==nil {break _cc ;};_eae ._acc +=_ead ._db ;if _ead ._c < 64{if _ead ._c < 0{_dgf [_adg ]=_cdfa ;_adg ++;_ead =nil ;break _cc ;};_cdfa +=_ead ._c ;_dgf [_adg ]=_cdfa ;
_adg ++;break ;};_cdfa +=_ead ._c ;};_geg :=_cdfa ;_bfc :for {var _cf []*code ;if !_fdb {_cf =_ea ._eb ;}else {_cf =_ea ._gg ;};_ead ,_gcc =_eae .uncompressGetCode (_cf );if _gcc !=nil {return 0,_gcc ;};if _ead ==nil {break _cc ;};_eae ._acc +=_ead ._db ;
if _ead ._c < 64{if _ead ._c < 0{_dgf [_adg ]=_cdfa ;_adg ++;break _cc ;};_cdfa +=_ead ._c ;if _cdfa < _gfga ||_cdfa !=_geg {_dgf [_adg ]=_cdfa ;_adg ++;};break _bfc ;};_cdfa +=_ead ._c ;};for _cdfa < _gfga &&_gac [_gbg ]<=_cdfa {_gbg +=2;};continue _cc ;
case _ed :_gbg ++;_cdfa =_gac [_gbg ];_gbg ++;continue _cc ;case _bdc :_cdfa =_gac [_gbg ]+2;case _bec :_cdfa =_gac [_gbg ]-2;case _dba :_cdfa =_gac [_gbg ]+3;case _gb :_cdfa =_gac [_gbg ]-3;default:if _eae ._acc ==12&&_ead ._c ==EOL {_eae ._acc =0;if _ ,_gcc =_ea .uncompress1d (_eae ,_gac ,_gfga );
_gcc !=nil {return 0,_gcc ;};_eae ._acc ++;if _ ,_gcc =_ea .uncompress1d (_eae ,_dgf ,_gfga );_gcc !=nil {return 0,_gcc ;};_ccc ,_fef :=_ea .uncompress1d (_eae ,_gac ,_gfga );if _fef !=nil {return EOF ,_fef ;};_eae ._acc ++;return _ccc ,nil ;};_cdfa =_gfga ;
continue _cc ;};if _cdfa <=_gfga {_fdb =!_fdb ;_dgf [_adg ]=_cdfa ;_adg ++;if _gbg > 0{_gbg --;}else {_gbg ++;};for _cdfa < _gfga &&_gac [_gbg ]<=_cdfa {_gbg +=2;};};};if _dgf [_adg ]!=_gfga {_dgf [_adg ]=_gfga ;};if _ead ==nil {return EOL ,nil ;};return _adg ,nil ;
};const (EOF =-3;_ef =-2;EOL =-1;_ge =8;_ad =(1<<_ge )-1;_df =5;_fg =(1<<_df )-1;);func (_efg *Decoder )uncompress1d (_gd *runData ,_edd []int ,_dac int )(int ,error ){var (_fae =true ;_aba int ;_gae *code ;_eee int ;_fce error ;);_dg :for _aba < _dac {_ddb :for {if _fae {_gae ,_fce =_gd .uncompressGetCode (_efg ._eb );
if _fce !=nil {return 0,_fce ;};}else {_gae ,_fce =_gd .uncompressGetCode (_efg ._gg );if _fce !=nil {return 0,_fce ;};};_gd ._acc +=_gae ._db ;if _gae ._c < 0{break _dg ;};_aba +=_gae ._c ;if _gae ._c < 64{_fae =!_fae ;_edd [_eee ]=_aba ;_eee ++;break _ddb ;
};};};if _edd [_eee ]!=_dac {_edd [_eee ]=_dac ;};_egd :=EOL ;if _gae !=nil &&_gae ._c !=EOL {_egd =_eee ;};return _egd ,nil ;};func (_eed *Decoder )UncompressMMR ()(_cdd *_fa .Bitmap ,_cg error ){_cdd =_fa .New (_eed ._cb ,_eed ._bga );_adb :=make ([]int ,_cdd .Width +5);
_dc :=make ([]int ,_cdd .Width +5);_dc [0]=_cdd .Width ;_ggb :=1;var _ab int ;for _efe :=0;_efe < _cdd .Height ;_efe ++{_ab ,_cg =_eed .uncompress2d (_eed ._fc ,_dc ,_ggb ,_adb ,_cdd .Width );if _cg !=nil {return nil ,_cg ;};if _ab ==EOF {break ;};if _ab > 0{_cg =_eed .fillBitmap (_cdd ,_efe ,_adb ,_ab );
if _cg !=nil {return nil ,_cg ;};};_dc ,_adb =_adb ,_dc ;_ggb =_ab ;};if _cg =_eed .detectAndSkipEOL ();_cg !=nil {return nil ,_cg ;};_eed ._fc .align ();return _cdd ,nil ;};type Decoder struct{_cb ,_bga int ;_fc *runData ;_eb []*code ;_gg []*code ;_eea []*code ;
};func (_dd *code )String ()string {return _b .Sprintf ("\u0025\u0064\u002f\u0025\u0064\u002f\u0025\u0064",_dd ._db ,_dd ._de ,_dd ._c );};const (_ed mmrCode =iota ;_be ;_ca ;_bbe ;_bdc ;_dba ;_bg ;_bec ;_gb ;_bbea ;_ff ;);func _bb (_ag [3]int )*code {return &code {_db :_ag [0],_de :_ag [1],_c :_ag [2]}};
func New (r _bf .StreamReader ,width ,height int ,dataOffset ,dataLength int64 )(*Decoder ,error ){_eda :=&Decoder {_cb :width ,_bga :height };_eeb ,_fe :=_bf .NewSubstreamReader (r ,uint64 (dataOffset ),uint64 (dataLength ));if _fe !=nil {return nil ,_fe ;
};_aaa ,_fe :=_accd (_eeb );if _fe !=nil {return nil ,_fe ;};_eda ._fc =_aaa ;if _da :=_eda .initTables ();_da !=nil {return nil ,_da ;};return _eda ,nil ;};func (_abb *runData )uncompressGetCodeLittleEndian (_cab []*code )(*code ,error ){_bbd ,_cbf :=_abb .uncompressGetNextCodeLittleEndian ();
if _cbf !=nil {_f .Log .Debug ("\u0055n\u0063\u006fm\u0070\u0072\u0065\u0073s\u0047\u0065\u0074N\u0065\u0078\u0074\u0043\u006f\u0064\u0065\u004c\u0069tt\u006c\u0065\u0045n\u0064\u0069a\u006e\u0020\u0066\u0061\u0069\u006ce\u0064\u003a \u0025\u0076",_cbf );
return nil ,_cbf ;};_bbd &=0xffffff;_egff :=_bbd >>(_eadg -_ge );_cef :=_cab [_egff ];if _cef !=nil &&_cef ._gf {_egff =(_bbd >>(_eadg -_ge -_df ))&_fg ;_cef =_cef ._bd [_egff ];};return _cef ,nil ;};func (_af *runData )uncompressGetCode (_eeae []*code )(*code ,error ){return _af .uncompressGetCodeLittleEndian (_eeae );
};func _gff (_bba ,_aa int )int {if _bba < _aa {return _aa ;};return _bba ;};func (_dcd *Decoder )detectAndSkipEOL ()error {for {_ce ,_bbg :=_dcd ._fc .uncompressGetCode (_dcd ._eea );if _bbg !=nil {return _bbg ;};if _ce !=nil &&_ce ._c ==EOL {_dcd ._fc ._acc +=_ce ._db ;
}else {return nil ;};};};var (_bde =[][3]int {{4,0x1,int (_ed )},{3,0x1,int (_be )},{1,0x1,int (_ca )},{3,0x3,int (_bbe )},{6,0x3,int (_bdc )},{7,0x3,int (_dba )},{3,0x2,int (_bg )},{6,0x2,int (_bec )},{7,0x2,int (_gb )},{10,0xf,int (_bbea )},{12,0xf,int (_ff )},{12,0x1,int (EOL )}};
_eg =[][3]int {{4,0x07,2},{4,0x08,3},{4,0x0B,4},{4,0x0C,5},{4,0x0E,6},{4,0x0F,7},{5,0x12,128},{5,0x13,8},{5,0x14,9},{5,0x1B,64},{5,0x07,10},{5,0x08,11},{6,0x17,192},{6,0x18,1664},{6,0x2A,16},{6,0x2B,17},{6,0x03,13},{6,0x34,14},{6,0x35,15},{6,0x07,1},{6,0x08,12},{7,0x13,26},{7,0x17,21},{7,0x18,28},{7,0x24,27},{7,0x27,18},{7,0x28,24},{7,0x2B,25},{7,0x03,22},{7,0x37,256},{7,0x04,23},{7,0x08,20},{7,0xC,19},{8,0x12,33},{8,0x13,34},{8,0x14,35},{8,0x15,36},{8,0x16,37},{8,0x17,38},{8,0x1A,31},{8,0x1B,32},{8,0x02,29},{8,0x24,53},{8,0x25,54},{8,0x28,39},{8,0x29,40},{8,0x2A,41},{8,0x2B,42},{8,0x2C,43},{8,0x2D,44},{8,0x03,30},{8,0x32,61},{8,0x33,62},{8,0x34,63},{8,0x35,0},{8,0x36,320},{8,0x37,384},{8,0x04,45},{8,0x4A,59},{8,0x4B,60},{8,0x5,46},{8,0x52,49},{8,0x53,50},{8,0x54,51},{8,0x55,52},{8,0x58,55},{8,0x59,56},{8,0x5A,57},{8,0x5B,58},{8,0x64,448},{8,0x65,512},{8,0x67,640},{8,0x68,576},{8,0x0A,47},{8,0x0B,48},{9,0x01,_ef },{9,0x98,1472},{9,0x99,1536},{9,0x9A,1600},{9,0x9B,1728},{9,0xCC,704},{9,0xCD,768},{9,0xD2,832},{9,0xD3,896},{9,0xD4,960},{9,0xD5,1024},{9,0xD6,1088},{9,0xD7,1152},{9,0xD8,1216},{9,0xD9,1280},{9,0xDA,1344},{9,0xDB,1408},{10,0x01,_ef },{11,0x01,_ef },{11,0x08,1792},{11,0x0C,1856},{11,0x0D,1920},{12,0x00,EOF },{12,0x01,EOL },{12,0x12,1984},{12,0x13,2048},{12,0x14,2112},{12,0x15,2176},{12,0x16,2240},{12,0x17,2304},{12,0x1C,2368},{12,0x1D,2432},{12,0x1E,2496},{12,0x1F,2560}};
_ee =[][3]int {{2,0x02,3},{2,0x03,2},{3,0x02,1},{3,0x03,4},{4,0x02,6},{4,0x03,5},{5,0x03,7},{6,0x04,9},{6,0x05,8},{7,0x04,10},{7,0x05,11},{7,0x07,12},{8,0x04,13},{8,0x07,14},{9,0x01,_ef },{9,0x18,15},{10,0x01,_ef },{10,0x17,16},{10,0x18,17},{10,0x37,0},{10,0x08,18},{10,0x0F,64},{11,0x01,_ef },{11,0x17,24},{11,0x18,25},{11,0x28,23},{11,0x37,22},{11,0x67,19},{11,0x68,20},{11,0x6C,21},{11,0x08,1792},{11,0x0C,1856},{11,0x0D,1920},{12,0x00,EOF },{12,0x01,EOL },{12,0x12,1984},{12,0x13,2048},{12,0x14,2112},{12,0x15,2176},{12,0x16,2240},{12,0x17,2304},{12,0x1C,2368},{12,0x1D,2432},{12,0x1E,2496},{12,0x1F,2560},{12,0x24,52},{12,0x27,55},{12,0x28,56},{12,0x2B,59},{12,0x2C,60},{12,0x33,320},{12,0x34,384},{12,0x35,448},{12,0x37,53},{12,0x38,54},{12,0x52,50},{12,0x53,51},{12,0x54,44},{12,0x55,45},{12,0x56,46},{12,0x57,47},{12,0x58,57},{12,0x59,58},{12,0x5A,61},{12,0x5B,256},{12,0x64,48},{12,0x65,49},{12,0x66,62},{12,0x67,63},{12,0x68,30},{12,0x69,31},{12,0x6A,32},{12,0x6B,33},{12,0x6C,40},{12,0x6D,41},{12,0xC8,128},{12,0xC9,192},{12,0xCA,26},{12,0xCB,27},{12,0xCC,28},{12,0xCD,29},{12,0xD2,34},{12,0xD3,35},{12,0xD4,36},{12,0xD5,37},{12,0xD6,38},{12,0xD7,39},{12,0xDA,42},{12,0xDB,43},{13,0x4A,640},{13,0x4B,704},{13,0x4C,768},{13,0x4D,832},{13,0x52,1280},{13,0x53,1344},{13,0x54,1408},{13,0x55,1472},{13,0x5A,1536},{13,0x5B,1600},{13,0x64,1664},{13,0x65,1728},{13,0x6C,512},{13,0x6D,576},{13,0x72,896},{13,0x73,960},{13,0x74,1024},{13,0x75,1088},{13,0x76,1152},{13,0x77,1216}};
);func (_bgb *Decoder )fillBitmap (_bdd *_fa .Bitmap ,_gc int ,_gfb []int ,_eebe int )error {var _add byte ;_bab :=0;_gfg :=_bdd .GetByteIndex (_bab ,_gc );for _cbe :=0;_cbe < _eebe ;_cbe ++{_dbb :=byte (1);_eebf :=_gfb [_cbe ];if (_cbe &1)==0{_dbb =0;
};for _bab < _eebf {_add =(_add <<1)|_dbb ;_bab ++;if (_bab &7)==0{if _adc :=_bdd .SetByte (_gfg ,_add );_adc !=nil {return _adc ;};_gfg ++;_add =0;};};};if (_bab &7)!=0{_add <<=uint (8-(_bab &7));if _cdf :=_bdd .SetByte (_gfg ,_add );_cdf !=nil {return _cdf ;
};};return nil ;};func (_cfa *runData )uncompressGetNextCodeLittleEndian ()(int ,error ){_adcd :=_cfa ._acc -_cfa ._fde ;if _adcd < 0||_adcd > 24{_gba :=(_cfa ._acc >>3)-_cfa ._bddf ;if _gba >=_cfa ._gag {_gba +=_cfa ._bddf ;if _dfe :=_cfa .fillBuffer (_gba );
_dfe !=nil {return 0,_dfe ;};_gba -=_cfa ._bddf ;};_bee :=(uint32 (_cfa ._gda [_gba ]&0xFF)<<16)|(uint32 (_cfa ._gda [_gba +1]&0xFF)<<8)|(uint32 (_cfa ._gda [_gba +2]&0xFF));_ccg :=uint32 (_cfa ._acc &7);_bee <<=_ccg ;_cfa ._bdf =int (_bee );}else {_dffc :=_cfa ._fde &7;
_feg :=7-_dffc ;if _adcd <=_feg {_cfa ._bdf <<=uint (_adcd );}else {_aee :=(_cfa ._fde >>3)+3-_cfa ._bddf ;if _aee >=_cfa ._gag {_aee +=_cfa ._bddf ;if _agf :=_cfa .fillBuffer (_aee );_agf !=nil {return 0,_agf ;};_aee -=_cfa ._bddf ;};_dffc =8-_dffc ;for {_cfa ._bdf <<=uint (_dffc );
_cfa ._bdf |=int (uint (_cfa ._gda [_aee ])&0xFF);_adcd -=_dffc ;_aee ++;_dffc =8;if !(_adcd >=8){break ;};};_cfa ._bdf <<=uint (_adcd );};};_cfa ._fde =_cfa ._acc ;return _cfa ._bdf ,nil ;};type code struct{_db int ;_de int ;_c int ;_bd []*code ;_gf bool ;
};func (_ec *runData )align (){_ec ._acc =((_ec ._acc +7)>>3)<<3};func _cd (_agg ,_e int )int {if _agg > _e {return _e ;};return _agg ;};