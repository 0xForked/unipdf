//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package mmr ;import (_bg "errors";_b "fmt";_bc "github.com/unidoc/unipdf/v3/common";_be "github.com/unidoc/unipdf/v3/internal/bitwise";_f "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_d "io";);func _gb (_ec [3]int )*code {return &code {_g :_ec [0],_fe :_ec [1],_fb :_ec [2]}};
func _cd (_bga ,_df int )int {if _bga > _df {return _df ;};return _bga ;};type code struct{_g int ;_fe int ;_fb int ;_e []*code ;_ef bool ;};func (_caa *Decoder )initTables ()(_fgg error ){if _caa ._ca ==nil {_caa ._ca ,_fgg =_caa .createLittleEndianTable (_ac );
if _fgg !=nil {return ;};_caa ._fg ,_fgg =_caa .createLittleEndianTable (_aa );if _fgg !=nil {return ;};_caa ._ad ,_fgg =_caa .createLittleEndianTable (_aga );if _fgg !=nil {return ;};};return nil ;};func (_fbb *Decoder )fillBitmap (_eag *_f .Bitmap ,_cga int ,_cgf []int ,_ee int )error {var _ff byte ;
_fge :=0;_bd :=_eag .GetByteIndex (_fge ,_cga );for _ba :=0;_ba < _ee ;_ba ++{_feff :=byte (1);_aag :=_cgf [_ba ];if (_ba &1)==0{_feff =0;};for _fge < _aag {_ff =(_ff <<1)|_feff ;_fge ++;if (_fge &7)==0{if _eg :=_eag .SetByte (_bd ,_ff );_eg !=nil {return _eg ;
};_bd ++;_ff =0;};};};if (_fge &7)!=0{_ff <<=uint (8-(_fge &7));if _fefe :=_eag .SetByte (_bd ,_ff );_fefe !=nil {return _fefe ;};};return nil ;};func (_baf *runData )align (){_baf ._cab =((_baf ._cab +7)>>3)<<3};func (_cbd *runData )uncompressGetCodeLittleEndian (_gdcd []*code )(*code ,error ){_afc ,_fca :=_cbd .uncompressGetNextCodeLittleEndian ();
if _fca !=nil {_bc .Log .Debug ("\u0055n\u0063\u006fm\u0070\u0072\u0065\u0073s\u0047\u0065\u0074N\u0065\u0078\u0074\u0043\u006f\u0064\u0065\u004c\u0069tt\u006c\u0065\u0045n\u0064\u0069a\u006e\u0020\u0066\u0061\u0069\u006ce\u0064\u003a \u0025\u0076",_fca );
return nil ,_fca ;};_afc &=0xffffff;_dfg :=_afc >>(_cee -_gbe );_dgg :=_gdcd [_dfg ];if _dgg !=nil &&_dgg ._ef {_dfg =(_afc >>(_cee -_gbe -_fbc ))&_bcg ;_dgg =_dgg ._e [_dfg ];};return _dgg ,nil ;};func New (r *_be .Reader ,width ,height int ,dataOffset ,dataLength int64 )(*Decoder ,error ){_dg :=&Decoder {_eb :width ,_abb :height };
_gbg ,_gga :=r .NewPartialReader (int (dataOffset ),int (dataLength ),false );if _gga !=nil {return nil ,_gga ;};_fa ,_gga :=_ace (_gbg );if _gga !=nil {return nil ,_gga ;};_ ,_gga =r .Seek (_gbg .RelativePosition (),_d .SeekCurrent );if _gga !=nil {return nil ,_gga ;
};_dg ._gcb =_fa ;if _caf :=_dg .initTables ();_caf !=nil {return nil ,_caf ;};return _dg ,nil ;};func (_cgd *runData )uncompressGetNextCodeLittleEndian ()(int ,error ){_agaf :=_cgd ._cab -_cgd ._geg ;if _agaf < 0||_agaf > 24{_gfb :=(_cgd ._cab >>3)-_cgd ._dba ;
if _gfb >=_cgd ._geb {_gfb +=_cgd ._dba ;if _ebca :=_cgd .fillBuffer (_gfb );_ebca !=nil {return 0,_ebca ;};_gfb -=_cgd ._dba ;};_bee :=(uint32 (_cgd ._ead [_gfb ]&0xFF)<<16)|(uint32 (_cgd ._ead [_gfb +1]&0xFF)<<8)|(uint32 (_cgd ._ead [_gfb +2]&0xFF));
_gaa :=uint32 (_cgd ._cab &7);_bee <<=_gaa ;_cgd ._aaa =int (_bee );}else {_cf :=_cgd ._geg &7;_cec :=7-_cf ;if _agaf <=_cec {_cgd ._aaa <<=uint (_agaf );}else {_bcc :=(_cgd ._geg >>3)+3-_cgd ._dba ;if _bcc >=_cgd ._geb {_bcc +=_cgd ._dba ;if _dga :=_cgd .fillBuffer (_bcc );
_dga !=nil {return 0,_dga ;};_bcc -=_cgd ._dba ;};_cf =8-_cf ;for {_cgd ._aaa <<=uint (_cf );_cgd ._aaa |=int (uint (_cgd ._ead [_bcc ])&0xFF);_agaf -=_cf ;_bcc ++;_cf =8;if !(_agaf >=8){break ;};};_cgd ._aaa <<=uint (_agaf );};};_cgd ._geg =_cgd ._cab ;
return _cgd ._aaa ,nil ;};func (_ceed *runData )fillBuffer (_cfd int )error {_ceed ._dba =_cfd ;_ ,_cfdf :=_ceed ._gac .Seek (int64 (_cfd ),_d .SeekStart );if _cfdf !=nil {if _cfdf ==_d .EOF {_bc .Log .Debug ("\u0053\u0065\u0061\u006b\u0020\u0045\u004f\u0046");
_ceed ._geb =-1;}else {return _cfdf ;};};if _cfdf ==nil {_ceed ._geb ,_cfdf =_ceed ._gac .Read (_ceed ._ead );if _cfdf !=nil {if _cfdf ==_d .EOF {_bc .Log .Trace ("\u0052\u0065\u0061\u0064\u0020\u0045\u004f\u0046");_ceed ._geb =-1;}else {return _cfdf ;
};};};if _ceed ._geb > -1&&_ceed ._geb < 3{for _ceed ._geb < 3{_dce ,_age :=_ceed ._gac .ReadByte ();if _age !=nil {if _age ==_d .EOF {_ceed ._ead [_ceed ._geb ]=0;}else {return _age ;};}else {_ceed ._ead [_ceed ._geb ]=_dce &0xFF;};_ceed ._geb ++;};};
_ceed ._geb -=3;if _ceed ._geb < 0{_ceed ._ead =make ([]byte ,len (_ceed ._ead ));_ceed ._geb =len (_ceed ._ead )-3;};return nil ;};type mmrCode int ;const (_db mmrCode =iota ;_gg ;_gc ;_gf ;_ea ;_ge ;_fbf ;_fbd ;_dd ;_gd ;_cg ;);const (_agcd int =1024<<7;
_cge int =3;_cee uint =24;);func (_cbc *runData )uncompressGetCode (_ae []*code )(*code ,error ){return _cbc .uncompressGetCodeLittleEndian (_ae );};var (_aga =[][3]int {{4,0x1,int (_db )},{3,0x1,int (_gg )},{1,0x1,int (_gc )},{3,0x3,int (_gf )},{6,0x3,int (_ea )},{7,0x3,int (_ge )},{3,0x2,int (_fbf )},{6,0x2,int (_fbd )},{7,0x2,int (_dd )},{10,0xf,int (_gd )},{12,0xf,int (_cg )},{12,0x1,int (EOL )}};
_ac =[][3]int {{4,0x07,2},{4,0x08,3},{4,0x0B,4},{4,0x0C,5},{4,0x0E,6},{4,0x0F,7},{5,0x12,128},{5,0x13,8},{5,0x14,9},{5,0x1B,64},{5,0x07,10},{5,0x08,11},{6,0x17,192},{6,0x18,1664},{6,0x2A,16},{6,0x2B,17},{6,0x03,13},{6,0x34,14},{6,0x35,15},{6,0x07,1},{6,0x08,12},{7,0x13,26},{7,0x17,21},{7,0x18,28},{7,0x24,27},{7,0x27,18},{7,0x28,24},{7,0x2B,25},{7,0x03,22},{7,0x37,256},{7,0x04,23},{7,0x08,20},{7,0xC,19},{8,0x12,33},{8,0x13,34},{8,0x14,35},{8,0x15,36},{8,0x16,37},{8,0x17,38},{8,0x1A,31},{8,0x1B,32},{8,0x02,29},{8,0x24,53},{8,0x25,54},{8,0x28,39},{8,0x29,40},{8,0x2A,41},{8,0x2B,42},{8,0x2C,43},{8,0x2D,44},{8,0x03,30},{8,0x32,61},{8,0x33,62},{8,0x34,63},{8,0x35,0},{8,0x36,320},{8,0x37,384},{8,0x04,45},{8,0x4A,59},{8,0x4B,60},{8,0x5,46},{8,0x52,49},{8,0x53,50},{8,0x54,51},{8,0x55,52},{8,0x58,55},{8,0x59,56},{8,0x5A,57},{8,0x5B,58},{8,0x64,448},{8,0x65,512},{8,0x67,640},{8,0x68,576},{8,0x0A,47},{8,0x0B,48},{9,0x01,_ab },{9,0x98,1472},{9,0x99,1536},{9,0x9A,1600},{9,0x9B,1728},{9,0xCC,704},{9,0xCD,768},{9,0xD2,832},{9,0xD3,896},{9,0xD4,960},{9,0xD5,1024},{9,0xD6,1088},{9,0xD7,1152},{9,0xD8,1216},{9,0xD9,1280},{9,0xDA,1344},{9,0xDB,1408},{10,0x01,_ab },{11,0x01,_ab },{11,0x08,1792},{11,0x0C,1856},{11,0x0D,1920},{12,0x00,EOF },{12,0x01,EOL },{12,0x12,1984},{12,0x13,2048},{12,0x14,2112},{12,0x15,2176},{12,0x16,2240},{12,0x17,2304},{12,0x1C,2368},{12,0x1D,2432},{12,0x1E,2496},{12,0x1F,2560}};
_aa =[][3]int {{2,0x02,3},{2,0x03,2},{3,0x02,1},{3,0x03,4},{4,0x02,6},{4,0x03,5},{5,0x03,7},{6,0x04,9},{6,0x05,8},{7,0x04,10},{7,0x05,11},{7,0x07,12},{8,0x04,13},{8,0x07,14},{9,0x01,_ab },{9,0x18,15},{10,0x01,_ab },{10,0x17,16},{10,0x18,17},{10,0x37,0},{10,0x08,18},{10,0x0F,64},{11,0x01,_ab },{11,0x17,24},{11,0x18,25},{11,0x28,23},{11,0x37,22},{11,0x67,19},{11,0x68,20},{11,0x6C,21},{11,0x08,1792},{11,0x0C,1856},{11,0x0D,1920},{12,0x00,EOF },{12,0x01,EOL },{12,0x12,1984},{12,0x13,2048},{12,0x14,2112},{12,0x15,2176},{12,0x16,2240},{12,0x17,2304},{12,0x1C,2368},{12,0x1D,2432},{12,0x1E,2496},{12,0x1F,2560},{12,0x24,52},{12,0x27,55},{12,0x28,56},{12,0x2B,59},{12,0x2C,60},{12,0x33,320},{12,0x34,384},{12,0x35,448},{12,0x37,53},{12,0x38,54},{12,0x52,50},{12,0x53,51},{12,0x54,44},{12,0x55,45},{12,0x56,46},{12,0x57,47},{12,0x58,57},{12,0x59,58},{12,0x5A,61},{12,0x5B,256},{12,0x64,48},{12,0x65,49},{12,0x66,62},{12,0x67,63},{12,0x68,30},{12,0x69,31},{12,0x6A,32},{12,0x6B,33},{12,0x6C,40},{12,0x6D,41},{12,0xC8,128},{12,0xC9,192},{12,0xCA,26},{12,0xCB,27},{12,0xCC,28},{12,0xCD,29},{12,0xD2,34},{12,0xD3,35},{12,0xD4,36},{12,0xD5,37},{12,0xD6,38},{12,0xD7,39},{12,0xDA,42},{12,0xDB,43},{13,0x4A,640},{13,0x4B,704},{13,0x4C,768},{13,0x4D,832},{13,0x52,1280},{13,0x53,1344},{13,0x54,1408},{13,0x55,1472},{13,0x5A,1536},{13,0x5B,1600},{13,0x64,1664},{13,0x65,1728},{13,0x6C,512},{13,0x6D,576},{13,0x72,896},{13,0x73,960},{13,0x74,1024},{13,0x75,1088},{13,0x76,1152},{13,0x77,1216}};
);func (_cafc *Decoder )detectAndSkipEOL ()error {for {_gbf ,_ebe :=_cafc ._gcb .uncompressGetCode (_cafc ._ad );if _ebe !=nil {return _ebe ;};if _gbf !=nil &&_gbf ._fb ==EOL {_cafc ._gcb ._cab +=_gbf ._g ;}else {return nil ;};};};func (_ga *Decoder )createLittleEndianTable (_acd [][3]int )([]*code ,error ){_cb :=make ([]*code ,_agg +1);
for _dc :=0;_dc < len (_acd );_dc ++{_ce :=_gb (_acd [_dc ]);if _ce ._g <=_gbe {_gcd :=_gbe -_ce ._g ;_efb :=_ce ._fe <<uint (_gcd );for _gbc :=(1<<uint (_gcd ))-1;_gbc >=0;_gbc --{_cbe :=_efb |_gbc ;_cb [_cbe ]=_ce ;};}else {_bce :=_ce ._fe >>uint (_ce ._g -_gbe );
if _cb [_bce ]==nil {var _fef =_gb ([3]int {});_fef ._e =make ([]*code ,_bcg +1);_cb [_bce ]=_fef ;};if _ce ._g <=_gbe +_fbc {_cde :=_gbe +_fbc -_ce ._g ;_gbd :=(_ce ._fe <<uint (_cde ))&_bcg ;_cb [_bce ]._ef =true ;for _fc :=(1<<uint (_cde ))-1;_fc >=0;
_fc --{_cb [_bce ]._e [_gbd |_fc ]=_ce ;};}else {return nil ,_bg .New ("\u0043\u006f\u0064\u0065\u0020\u0074a\u0062\u006c\u0065\u0020\u006f\u0076\u0065\u0072\u0066\u006c\u006f\u0077\u0020i\u006e\u0020\u004d\u004d\u0052\u0044\u0065c\u006f\u0064\u0065\u0072");
};};};return _cb ,nil ;};func (_gab *Decoder )uncompress2d (_agc *runData ,_fd []int ,_cded int ,_bdfa []int ,_ebc int )(int ,error ){var (_gbgg int ;_efga int ;_fec int ;_fab =true ;_bcef error ;_ege *code ;);_fd [_cded ]=_ebc ;_fd [_cded +1]=_ebc ;_fd [_cded +2]=_ebc +1;
_fd [_cded +3]=_ebc +1;_gbed :for _fec < _ebc {_ege ,_bcef =_agc .uncompressGetCode (_gab ._ad );if _bcef !=nil {return EOL ,nil ;};if _ege ==nil {_agc ._cab ++;break _gbed ;};_agc ._cab +=_ege ._g ;switch mmrCode (_ege ._fb ){case _gc :_fec =_fd [_gbgg ];
case _gf :_fec =_fd [_gbgg ]+1;case _fbf :_fec =_fd [_gbgg ]-1;case _gg :for {var _cgg []*code ;if _fab {_cgg =_gab ._ca ;}else {_cgg =_gab ._fg ;};_ege ,_bcef =_agc .uncompressGetCode (_cgg );if _bcef !=nil {return 0,_bcef ;};if _ege ==nil {break _gbed ;
};_agc ._cab +=_ege ._g ;if _ege ._fb < 64{if _ege ._fb < 0{_bdfa [_efga ]=_fec ;_efga ++;_ege =nil ;break _gbed ;};_fec +=_ege ._fb ;_bdfa [_efga ]=_fec ;_efga ++;break ;};_fec +=_ege ._fb ;};_bfc :=_fec ;_deg :for {var _fcf []*code ;if !_fab {_fcf =_gab ._ca ;
}else {_fcf =_gab ._fg ;};_ege ,_bcef =_agc .uncompressGetCode (_fcf );if _bcef !=nil {return 0,_bcef ;};if _ege ==nil {break _gbed ;};_agc ._cab +=_ege ._g ;if _ege ._fb < 64{if _ege ._fb < 0{_bdfa [_efga ]=_fec ;_efga ++;break _gbed ;};_fec +=_ege ._fb ;
if _fec < _ebc ||_fec !=_bfc {_bdfa [_efga ]=_fec ;_efga ++;};break _deg ;};_fec +=_ege ._fb ;};for _fec < _ebc &&_fd [_gbgg ]<=_fec {_gbgg +=2;};continue _gbed ;case _db :_gbgg ++;_fec =_fd [_gbgg ];_gbgg ++;continue _gbed ;case _ea :_fec =_fd [_gbgg ]+2;
case _fbd :_fec =_fd [_gbgg ]-2;case _ge :_fec =_fd [_gbgg ]+3;case _dd :_fec =_fd [_gbgg ]-3;default:if _agc ._cab ==12&&_ege ._fb ==EOL {_agc ._cab =0;if _ ,_bcef =_gab .uncompress1d (_agc ,_fd ,_ebc );_bcef !=nil {return 0,_bcef ;};_agc ._cab ++;if _ ,_bcef =_gab .uncompress1d (_agc ,_bdfa ,_ebc );
_bcef !=nil {return 0,_bcef ;};_bb ,_gcc :=_gab .uncompress1d (_agc ,_fd ,_ebc );if _gcc !=nil {return EOF ,_gcc ;};_agc ._cab ++;return _bb ,nil ;};_fec =_ebc ;continue _gbed ;};if _fec <=_ebc {_fab =!_fab ;_bdfa [_efga ]=_fec ;_efga ++;if _gbgg > 0{_gbgg --;
}else {_gbgg ++;};for _fec < _ebc &&_fd [_gbgg ]<=_fec {_gbgg +=2;};};};if _bdfa [_efga ]!=_ebc {_bdfa [_efga ]=_ebc ;};if _ege ==nil {return EOL ,nil ;};return _efga ,nil ;};func _a (_ecc ,_ag int )int {if _ecc < _ag {return _ag ;};return _ecc ;};func (_da *Decoder )UncompressMMR ()(_gce *_f .Bitmap ,_de error ){_gce =_f .New (_da ._eb ,_da ._abb );
_ged :=make ([]int ,_gce .Width +5);_dab :=make ([]int ,_gce .Width +5);_dab [0]=_gce .Width ;_geda :=1;var _efg int ;for _abc :=0;_abc < _gce .Height ;_abc ++{_efg ,_de =_da .uncompress2d (_da ._gcb ,_dab ,_geda ,_ged ,_gce .Width );if _de !=nil {return nil ,_de ;
};if _efg ==EOF {break ;};if _efg > 0{_de =_da .fillBitmap (_gce ,_abc ,_ged ,_efg );if _de !=nil {return nil ,_de ;};};_dab ,_ged =_ged ,_dab ;_geda =_efg ;};if _de =_da .detectAndSkipEOL ();_de !=nil {return nil ,_de ;};_da ._gcb .align ();return _gce ,nil ;
};const (EOF =-3;_ab =-2;EOL =-1;_gbe =8;_agg =(1<<_gbe )-1;_fbc =5;_bcg =(1<<_fbc )-1;);func (_bcd *code )String ()string {return _b .Sprintf ("\u0025\u0064\u002f\u0025\u0064\u002f\u0025\u0064",_bcd ._g ,_bcd ._fe ,_bcd ._fb );};func _ace (_bab *_be .Reader )(*runData ,error ){_cbg :=&runData {_gac :_bab ,_cab :0,_geg :1};
_egee :=_cd (_a (_cge ,int (_bab .Length ())),_agcd );_cbg ._ead =make ([]byte ,_egee );if _acb :=_cbg .fillBuffer (0);_acb !=nil {if _acb ==_d .EOF {_cbg ._ead =make ([]byte ,10);_bc .Log .Debug ("F\u0069\u006c\u006c\u0042uf\u0066e\u0072\u0020\u0066\u0061\u0069l\u0065\u0064\u003a\u0020\u0025\u0076",_acb );
}else {return nil ,_acb ;};};return _cbg ,nil ;};type Decoder struct{_eb ,_abb int ;_gcb *runData ;_ca []*code ;_fg []*code ;_ad []*code ;};type runData struct{_gac *_be .Reader ;_cab int ;_geg int ;_aaa int ;_ead []byte ;_dba int ;_geb int ;};func (_bdf *Decoder )uncompress1d (_dac *runData ,_eef []int ,_gbfg int )(int ,error ){var (_af =true ;
_ed int ;_add *code ;_gdc int ;_ecf error ;);_fea :for _ed < _gbfg {_dcc :for {if _af {_add ,_ecf =_dac .uncompressGetCode (_bdf ._ca );if _ecf !=nil {return 0,_ecf ;};}else {_add ,_ecf =_dac .uncompressGetCode (_bdf ._fg );if _ecf !=nil {return 0,_ecf ;
};};_dac ._cab +=_add ._g ;if _add ._fb < 0{break _fea ;};_ed +=_add ._fb ;if _add ._fb < 64{_af =!_af ;_eef [_gdc ]=_ed ;_gdc ++;break _dcc ;};};};if _eef [_gdc ]!=_gbfg {_eef [_gdc ]=_gbfg ;};_ceg :=EOL ;if _add !=nil &&_add ._fb !=EOL {_ceg =_gdc ;};
return _ceg ,nil ;};