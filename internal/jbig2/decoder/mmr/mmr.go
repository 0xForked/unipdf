//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package mmr ;import (_e "errors";_a "fmt";_c "github.com/unidoc/unipdf/v3/common";_ea "github.com/unidoc/unipdf/v3/internal/bitwise";_d "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_bc "io";);func _geb (_af *_ea .Reader )(*runData ,error ){_ddda :=&runData {_fadg :_af ,_acb :0,_add :1};
_fg :=_ac (_cb (_dae ,int (_af .Length ())),_gaa );_ddda ._bag =make ([]byte ,_fg );if _bgg :=_ddda .fillBuffer (0);_bgg !=nil {if _bgg ==_bc .EOF {_ddda ._bag =make ([]byte ,10);_c .Log .Debug ("F\u0069\u006c\u006c\u0042uf\u0066e\u0072\u0020\u0066\u0061\u0069l\u0065\u0064\u003a\u0020\u0025\u0076",_bgg );
}else {return nil ,_bgg ;};};return _ddda ,nil ;};func (_cg *code )String ()string {return _a .Sprintf ("\u0025\u0064\u002f\u0025\u0064\u002f\u0025\u0064",_cg ._g ,_cg ._ef ,_cg ._f );};type mmrCode int ;func _cb (_ce ,_eg int )int {if _ce < _eg {return _eg ;
};return _ce ;};func (_aad *runData )uncompressGetCode (_gaae []*code )(*code ,error ){return _aad .uncompressGetCodeLittleEndian (_gaae );};func New (r *_ea .Reader ,width ,height int ,dataOffset ,dataLength int64 )(*Decoder ,error ){_caa :=&Decoder {_fd :width ,_cf :height };
_ede ,_ag :=r .NewPartialReader (int (dataOffset ),int (dataLength ),false );if _ag !=nil {return nil ,_ag ;};_eca ,_ag :=_geb (_ede );if _ag !=nil {return nil ,_ag ;};_ ,_ag =r .Seek (_ede .RelativePosition (),_bc .SeekCurrent );if _ag !=nil {return nil ,_ag ;
};_caa ._bcd =_eca ;if _bd :=_caa .initTables ();_bd !=nil {return nil ,_bd ;};return _caa ,nil ;};type code struct{_g int ;_ef int ;_f int ;_ec []*code ;_ab bool ;};func (_fab *Decoder )UncompressMMR ()(_ead *_d .Bitmap ,_cgf error ){_ead =_d .New (_fab ._fd ,_fab ._cf );
_ccd :=make ([]int ,_ead .Width +5);_be :=make ([]int ,_ead .Width +5);_be [0]=_ead .Width ;_abe :=1;var _cbbc int ;for _ddd :=0;_ddd < _ead .Height ;_ddd ++{_cbbc ,_cgf =_fab .uncompress2d (_fab ._bcd ,_be ,_abe ,_ccd ,_ead .Width );if _cgf !=nil {return nil ,_cgf ;
};if _cbbc ==EOF {break ;};if _cbbc > 0{_cgf =_fab .fillBitmap (_ead ,_ddd ,_ccd ,_cbbc );if _cgf !=nil {return nil ,_cgf ;};};_be ,_ccd =_ccd ,_be ;_abe =_cbbc ;};if _cgf =_fab .detectAndSkipEOL ();_cgf !=nil {return nil ,_cgf ;};_fab ._bcd .align ();
return _ead ,nil ;};const (EOF =-3;_edb =-2;EOL =-1;_cd =8;_cab =(1<<_cd )-1;_cbb =5;_gf =(1<<_cbb )-1;);func (_fdca *runData )align (){_fdca ._acb =((_fdca ._acb +7)>>3)<<3};func (_ebf *Decoder )fillBitmap (_fbd *_d .Bitmap ,_abag int ,_dfb []int ,_bdg int )error {var _bgc byte ;
_gef :=0;_efc :=_fbd .GetByteIndex (_gef ,_abag );for _eda :=0;_eda < _bdg ;_eda ++{_gdb :=byte (1);_fdg :=_dfb [_eda ];if (_eda &1)==0{_gdb =0;};for _gef < _fdg {_bgc =(_bgc <<1)|_gdb ;_gef ++;if (_gef &7)==0{if _gcf :=_fbd .SetByte (_efc ,_bgc );_gcf !=nil {return _gcf ;
};_efc ++;_bgc =0;};};};if (_gef &7)!=0{_bgc <<=uint (8-(_gef &7));if _bga :=_fbd .SetByte (_efc ,_bgc );_bga !=nil {return _bga ;};};return nil ;};func _ac (_dc ,_bf int )int {if _dc > _bf {return _bf ;};return _dc ;};func (_eff *runData )uncompressGetNextCodeLittleEndian ()(int ,error ){_dbb :=_eff ._acb -_eff ._add ;
if _dbb < 0||_dbb > 24{_abgb :=(_eff ._acb >>3)-_eff ._ffc ;if _abgb >=_eff ._eed {_abgb +=_eff ._ffc ;if _fbe :=_eff .fillBuffer (_abgb );_fbe !=nil {return 0,_fbe ;};_abgb -=_eff ._ffc ;};_fec :=(uint32 (_eff ._bag [_abgb ]&0xFF)<<16)|(uint32 (_eff ._bag [_abgb +1]&0xFF)<<8)|(uint32 (_eff ._bag [_abgb +2]&0xFF));
_gde :=uint32 (_eff ._acb &7);_fec <<=_gde ;_eff ._dgb =int (_fec );}else {_bgb :=_eff ._add &7;_cegb :=7-_bgb ;if _dbb <=_cegb {_eff ._dgb <<=uint (_dbb );}else {_aff :=(_eff ._add >>3)+3-_eff ._ffc ;if _aff >=_eff ._eed {_aff +=_eff ._ffc ;if _daed :=_eff .fillBuffer (_aff );
_daed !=nil {return 0,_daed ;};_aff -=_eff ._ffc ;};_bgb =8-_bgb ;for {_eff ._dgb <<=uint (_bgb );_eff ._dgb |=int (uint (_eff ._bag [_aff ])&0xFF);_dbb -=_bgb ;_aff ++;_bgb =8;if !(_dbb >=8){break ;};};_eff ._dgb <<=uint (_dbb );};};_eff ._add =_eff ._acb ;
return _eff ._dgb ,nil ;};func (_cea *Decoder )uncompress2d (_dgc *runData ,_fdf []int ,_cef int ,_fbb []int ,_ggc int )(int ,error ){var (_gae int ;_dcf int ;_ded int ;_daa =true ;_dfg error ;_cac *code ;);_fdf [_cef ]=_ggc ;_fdf [_cef +1]=_ggc ;_fdf [_cef +2]=_ggc +1;
_fdf [_cef +3]=_ggc +1;_ega :for _ded < _ggc {_cac ,_dfg =_dgc .uncompressGetCode (_cea ._gcc );if _dfg !=nil {return EOL ,nil ;};if _cac ==nil {_dgc ._acb ++;break _ega ;};_dgc ._acb +=_cac ._g ;switch mmrCode (_cac ._f ){case _gg :_ded =_fdf [_gae ];
case _dg :_ded =_fdf [_gae ]+1;case _eb :_ded =_fdf [_gae ]-1;case _ed :for {var _cbe []*code ;if _daa {_cbe =_cea ._ge ;}else {_cbe =_cea ._gc ;};_cac ,_dfg =_dgc .uncompressGetCode (_cbe );if _dfg !=nil {return 0,_dfg ;};if _cac ==nil {break _ega ;};
_dgc ._acb +=_cac ._g ;if _cac ._f < 64{if _cac ._f < 0{_fbb [_dcf ]=_ded ;_dcf ++;_cac =nil ;break _ega ;};_ded +=_cac ._f ;_fbb [_dcf ]=_ded ;_dcf ++;break ;};_ded +=_cac ._f ;};_fcfd :=_ded ;_ad :for {var _db []*code ;if !_daa {_db =_cea ._ge ;}else {_db =_cea ._gc ;
};_cac ,_dfg =_dgc .uncompressGetCode (_db );if _dfg !=nil {return 0,_dfg ;};if _cac ==nil {break _ega ;};_dgc ._acb +=_cac ._g ;if _cac ._f < 64{if _cac ._f < 0{_fbb [_dcf ]=_ded ;_dcf ++;break _ega ;};_ded +=_cac ._f ;if _ded < _ggc ||_ded !=_fcfd {_fbb [_dcf ]=_ded ;
_dcf ++;};break _ad ;};_ded +=_cac ._f ;};for _ded < _ggc &&_fdf [_gae ]<=_ded {_gae +=2;};continue _ega ;case _ff :_gae ++;_ded =_fdf [_gae ];_gae ++;continue _ega ;case _fc :_ded =_fdf [_gae ]+2;case _ccf :_ded =_fdf [_gae ]-2;case _cc :_ded =_fdf [_gae ]+3;
case _fa :_ded =_fdf [_gae ]-3;default:if _dgc ._acb ==12&&_cac ._f ==EOL {_dgc ._acb =0;if _ ,_dfg =_cea .uncompress1d (_dgc ,_fdf ,_ggc );_dfg !=nil {return 0,_dfg ;};_dgc ._acb ++;if _ ,_dfg =_cea .uncompress1d (_dgc ,_fbb ,_ggc );_dfg !=nil {return 0,_dfg ;
};_ee ,_cfdf :=_cea .uncompress1d (_dgc ,_fdf ,_ggc );if _cfdf !=nil {return EOF ,_cfdf ;};_dgc ._acb ++;return _ee ,nil ;};_ded =_ggc ;continue _ega ;};if _ded <=_ggc {_daa =!_daa ;_fbb [_dcf ]=_ded ;_dcf ++;if _gae > 0{_gae --;}else {_gae ++;};for _ded < _ggc &&_fdf [_gae ]<=_ded {_gae +=2;
};};};if _fbb [_dcf ]!=_ggc {_fbb [_dcf ]=_ggc ;};if _cac ==nil {return EOL ,nil ;};return _dcf ,nil ;};func (_ece *Decoder )createLittleEndianTable (_fcf [][3]int )([]*code ,error ){_cfd :=make ([]*code ,_cab +1);for _abef :=0;_abef < len (_fcf );_abef ++{_fad :=_ca (_fcf [_abef ]);
if _fad ._g <=_cd {_aba :=_cd -_fad ._g ;_fdc :=_fad ._ef <<uint (_aba );for _egb :=(1<<uint (_aba ))-1;_egb >=0;_egb --{_gga :=_fdc |_egb ;_cfd [_gga ]=_fad ;};}else {_cfa :=_fad ._ef >>uint (_fad ._g -_cd );if _cfd [_cfa ]==nil {var _fac =_ca ([3]int {});
_fac ._ec =make ([]*code ,_gf +1);_cfd [_cfa ]=_fac ;};if _fad ._g <=_cd +_cbb {_fag :=_cd +_cbb -_fad ._g ;_fcfb :=(_fad ._ef <<uint (_fag ))&_gf ;_cfd [_cfa ]._ab =true ;for _gb :=(1<<uint (_fag ))-1;_gb >=0;_gb --{_cfd [_cfa ]._ec [_fcfb |_gb ]=_fad ;
};}else {return nil ,_e .New ("\u0043\u006f\u0064\u0065\u0020\u0074a\u0062\u006c\u0065\u0020\u006f\u0076\u0065\u0072\u0066\u006c\u006f\u0077\u0020i\u006e\u0020\u004d\u004d\u0052\u0044\u0065c\u006f\u0064\u0065\u0072");};};};return _cfd ,nil ;};func (_ccde *Decoder )uncompress1d (_de *runData ,_aga []int ,_gbf int )(int ,error ){var (_dde =true ;
_cgg int ;_egg *code ;_cad int ;_cdb error ;);_aa :for _cgg < _gbf {_gbg :for {if _dde {_egg ,_cdb =_de .uncompressGetCode (_ccde ._ge );if _cdb !=nil {return 0,_cdb ;};}else {_egg ,_cdb =_de .uncompressGetCode (_ccde ._gc );if _cdb !=nil {return 0,_cdb ;
};};_de ._acb +=_egg ._g ;if _egg ._f < 0{break _aa ;};_cgg +=_egg ._f ;if _egg ._f < 64{_dde =!_dde ;_aga [_cad ]=_cgg ;_cad ++;break _gbg ;};};};if _aga [_cad ]!=_gbf {_aga [_cad ]=_gbf ;};_edd :=EOL ;if _egg !=nil &&_egg ._f !=EOL {_edd =_cad ;};return _edd ,nil ;
};const (_ff mmrCode =iota ;_ed ;_gg ;_dg ;_fc ;_cc ;_eb ;_ccf ;_fa ;_dd ;_ba ;);func (_cde *runData )uncompressGetCodeLittleEndian (_acc []*code )(*code ,error ){_dedd ,_afd :=_cde .uncompressGetNextCodeLittleEndian ();if _afd !=nil {_c .Log .Debug ("\u0055n\u0063\u006fm\u0070\u0072\u0065\u0073s\u0047\u0065\u0074N\u0065\u0078\u0074\u0043\u006f\u0064\u0065\u004c\u0069tt\u006c\u0065\u0045n\u0064\u0069a\u006e\u0020\u0066\u0061\u0069\u006ce\u0064\u003a \u0025\u0076",_afd );
return nil ,_afd ;};_dedd &=0xffffff;_ceg :=_dedd >>(_dedc -_cd );_cfb :=_acc [_ceg ];if _cfb !=nil &&_cfb ._ab {_ceg =(_dedd >>(_dedc -_cd -_cbb ))&_gf ;_cfb =_cfb ._ec [_ceg ];};return _cfb ,nil ;};type Decoder struct{_fd ,_cf int ;_bcd *runData ;_ge []*code ;
_gc []*code ;_gcc []*code ;};func (_caf *runData )fillBuffer (_cbc int )error {_caf ._ffc =_cbc ;_ ,_deg :=_caf ._fadg .Seek (int64 (_cbc ),_bc .SeekStart );if _deg !=nil {if _deg ==_bc .EOF {_c .Log .Debug ("\u0053\u0065\u0061\u006b\u0020\u0045\u004f\u0046");
_caf ._eed =-1;}else {return _deg ;};};if _deg ==nil {_caf ._eed ,_deg =_caf ._fadg .Read (_caf ._bag );if _deg !=nil {if _deg ==_bc .EOF {_c .Log .Trace ("\u0052\u0065\u0061\u0064\u0020\u0045\u004f\u0046");_caf ._eed =-1;}else {return _deg ;};};};if _caf ._eed > -1&&_caf ._eed < 3{for _caf ._eed < 3{_egc ,_dddd :=_caf ._fadg .ReadByte ();
if _dddd !=nil {if _dddd ==_bc .EOF {_caf ._bag [_caf ._eed ]=0;}else {return _dddd ;};}else {_caf ._bag [_caf ._eed ]=_egc &0xFF;};_caf ._eed ++;};};_caf ._eed -=3;if _caf ._eed < 0{_caf ._bag =make ([]byte ,len (_caf ._bag ));_caf ._eed =len (_caf ._bag )-3;
};return nil ;};var (_gd =[][3]int {{4,0x1,int (_ff )},{3,0x1,int (_ed )},{1,0x1,int (_gg )},{3,0x3,int (_dg )},{6,0x3,int (_fc )},{7,0x3,int (_cc )},{3,0x2,int (_eb )},{6,0x2,int (_ccf )},{7,0x2,int (_fa )},{10,0xf,int (_dd )},{12,0xf,int (_ba )},{12,0x1,int (EOL )}};
_da =[][3]int {{4,0x07,2},{4,0x08,3},{4,0x0B,4},{4,0x0C,5},{4,0x0E,6},{4,0x0F,7},{5,0x12,128},{5,0x13,8},{5,0x14,9},{5,0x1B,64},{5,0x07,10},{5,0x08,11},{6,0x17,192},{6,0x18,1664},{6,0x2A,16},{6,0x2B,17},{6,0x03,13},{6,0x34,14},{6,0x35,15},{6,0x07,1},{6,0x08,12},{7,0x13,26},{7,0x17,21},{7,0x18,28},{7,0x24,27},{7,0x27,18},{7,0x28,24},{7,0x2B,25},{7,0x03,22},{7,0x37,256},{7,0x04,23},{7,0x08,20},{7,0xC,19},{8,0x12,33},{8,0x13,34},{8,0x14,35},{8,0x15,36},{8,0x16,37},{8,0x17,38},{8,0x1A,31},{8,0x1B,32},{8,0x02,29},{8,0x24,53},{8,0x25,54},{8,0x28,39},{8,0x29,40},{8,0x2A,41},{8,0x2B,42},{8,0x2C,43},{8,0x2D,44},{8,0x03,30},{8,0x32,61},{8,0x33,62},{8,0x34,63},{8,0x35,0},{8,0x36,320},{8,0x37,384},{8,0x04,45},{8,0x4A,59},{8,0x4B,60},{8,0x5,46},{8,0x52,49},{8,0x53,50},{8,0x54,51},{8,0x55,52},{8,0x58,55},{8,0x59,56},{8,0x5A,57},{8,0x5B,58},{8,0x64,448},{8,0x65,512},{8,0x67,640},{8,0x68,576},{8,0x0A,47},{8,0x0B,48},{9,0x01,_edb },{9,0x98,1472},{9,0x99,1536},{9,0x9A,1600},{9,0x9B,1728},{9,0xCC,704},{9,0xCD,768},{9,0xD2,832},{9,0xD3,896},{9,0xD4,960},{9,0xD5,1024},{9,0xD6,1088},{9,0xD7,1152},{9,0xD8,1216},{9,0xD9,1280},{9,0xDA,1344},{9,0xDB,1408},{10,0x01,_edb },{11,0x01,_edb },{11,0x08,1792},{11,0x0C,1856},{11,0x0D,1920},{12,0x00,EOF },{12,0x01,EOL },{12,0x12,1984},{12,0x13,2048},{12,0x14,2112},{12,0x15,2176},{12,0x16,2240},{12,0x17,2304},{12,0x1C,2368},{12,0x1D,2432},{12,0x1E,2496},{12,0x1F,2560}};
_abb =[][3]int {{2,0x02,3},{2,0x03,2},{3,0x02,1},{3,0x03,4},{4,0x02,6},{4,0x03,5},{5,0x03,7},{6,0x04,9},{6,0x05,8},{7,0x04,10},{7,0x05,11},{7,0x07,12},{8,0x04,13},{8,0x07,14},{9,0x01,_edb },{9,0x18,15},{10,0x01,_edb },{10,0x17,16},{10,0x18,17},{10,0x37,0},{10,0x08,18},{10,0x0F,64},{11,0x01,_edb },{11,0x17,24},{11,0x18,25},{11,0x28,23},{11,0x37,22},{11,0x67,19},{11,0x68,20},{11,0x6C,21},{11,0x08,1792},{11,0x0C,1856},{11,0x0D,1920},{12,0x00,EOF },{12,0x01,EOL },{12,0x12,1984},{12,0x13,2048},{12,0x14,2112},{12,0x15,2176},{12,0x16,2240},{12,0x17,2304},{12,0x1C,2368},{12,0x1D,2432},{12,0x1E,2496},{12,0x1F,2560},{12,0x24,52},{12,0x27,55},{12,0x28,56},{12,0x2B,59},{12,0x2C,60},{12,0x33,320},{12,0x34,384},{12,0x35,448},{12,0x37,53},{12,0x38,54},{12,0x52,50},{12,0x53,51},{12,0x54,44},{12,0x55,45},{12,0x56,46},{12,0x57,47},{12,0x58,57},{12,0x59,58},{12,0x5A,61},{12,0x5B,256},{12,0x64,48},{12,0x65,49},{12,0x66,62},{12,0x67,63},{12,0x68,30},{12,0x69,31},{12,0x6A,32},{12,0x6B,33},{12,0x6C,40},{12,0x6D,41},{12,0xC8,128},{12,0xC9,192},{12,0xCA,26},{12,0xCB,27},{12,0xCC,28},{12,0xCD,29},{12,0xD2,34},{12,0xD3,35},{12,0xD4,36},{12,0xD5,37},{12,0xD6,38},{12,0xD7,39},{12,0xDA,42},{12,0xDB,43},{13,0x4A,640},{13,0x4B,704},{13,0x4C,768},{13,0x4D,832},{13,0x52,1280},{13,0x53,1344},{13,0x54,1408},{13,0x55,1472},{13,0x5A,1536},{13,0x5B,1600},{13,0x64,1664},{13,0x65,1728},{13,0x6C,512},{13,0x6D,576},{13,0x72,896},{13,0x73,960},{13,0x74,1024},{13,0x75,1088},{13,0x76,1152},{13,0x77,1216}};
);func (_fcg *Decoder )initTables ()(_ga error ){if _fcg ._ge ==nil {_fcg ._ge ,_ga =_fcg .createLittleEndianTable (_da );if _ga !=nil {return ;};_fcg ._gc ,_ga =_fcg .createLittleEndianTable (_abb );if _ga !=nil {return ;};_fcg ._gcc ,_ga =_fcg .createLittleEndianTable (_gd );
if _ga !=nil {return ;};};return nil ;};type runData struct{_fadg *_ea .Reader ;_acb int ;_add int ;_dgb int ;_bag []byte ;_ffc int ;_eed int ;};func _ca (_bg [3]int )*code {return &code {_g :_bg [0],_ef :_bg [1],_f :_bg [2]}};func (_df *Decoder )detectAndSkipEOL ()error {for {_bfb ,_fb :=_df ._bcd .uncompressGetCode (_df ._gcc );
if _fb !=nil {return _fb ;};if _bfb !=nil &&_bfb ._f ==EOL {_df ._bcd ._acb +=_bfb ._g ;}else {return nil ;};};};const (_gaa int =1024<<7;_dae int =3;_dedc uint =24;);