//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package mmr ;import (_e "errors";_g "fmt";_fa "github.com/unidoc/unipdf/v3/common";_gd "github.com/unidoc/unipdf/v3/internal/bitwise";_c "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_d "io";);func (_daf *Decoder )UncompressMMR ()(_cge *_c .Bitmap ,_cd error ){_cge =_c .New (_daf ._cea ,_daf ._a );
_adb :=make ([]int ,_cge .Width +5);_fg :=make ([]int ,_cge .Width +5);_fg [0]=_cge .Width ;_af :=1;var _gef int ;for _ae :=0;_ae < _cge .Height ;_ae ++{_gef ,_cd =_daf .uncompress2d (_daf ._gc ,_fg ,_af ,_adb ,_cge .Width );if _cd !=nil {return nil ,_cd ;
};if _gef ==EOF {break ;};if _gef > 0{_cd =_daf .fillBitmap (_cge ,_ae ,_adb ,_gef );if _cd !=nil {return nil ,_cd ;};};_fg ,_adb =_adb ,_fg ;_af =_gef ;};if _cd =_daf .detectAndSkipEOL ();_cd !=nil {return nil ,_cd ;};_daf ._gc .align ();return _cge ,nil ;
};const (_aeg int =1024<<7;_gag int =3;_eegf uint =24;);func _fad (_fde ,_ee int )int {if _fde < _ee {return _ee ;};return _fde ;};type code struct{_fd int ;_ef int ;_dc int ;_b []*code ;_ba bool ;};type mmrCode int ;func New (r _gd .StreamReader ,width ,height int ,dataOffset ,dataLength int64 )(*Decoder ,error ){_gg :=&Decoder {_cea :width ,_a :height };
_efe ,_efc :=_gd .NewSubstreamReader (r ,uint64 (dataOffset ),uint64 (dataLength ));if _efc !=nil {return nil ,_efc ;};_age ,_efc :=_fbe (_efe );if _efc !=nil {return nil ,_efc ;};_gg ._gc =_age ;if _dgc :=_gg .initTables ();_dgc !=nil {return nil ,_dgc ;
};return _gg ,nil ;};func (_geb *Decoder )fillBitmap (_cce *_c .Bitmap ,_bd int ,_afc []int ,_dga int )error {var _agec byte ;_bedc :=0;_aab :=_cce .GetByteIndex (_bedc ,_bd );for _gdd :=0;_gdd < _dga ;_gdd ++{_ec :=byte (1);_ccc :=_afc [_gdd ];if (_gdd &1)==0{_ec =0;
};for _bedc < _ccc {_agec =(_agec <<1)|_ec ;_bedc ++;if (_bedc &7)==0{if _bde :=_cce .SetByte (_aab ,_agec );_bde !=nil {return _bde ;};_aab ++;_agec =0;};};};if (_bedc &7)!=0{_agec <<=uint (8-(_bedc &7));if _afa :=_cce .SetByte (_aab ,_agec );_afa !=nil {return _afa ;
};};return nil ;};func _dg (_bb [3]int )*code {return &code {_fd :_bb [0],_ef :_bb [1],_dc :_bb [2]}};var (_gdfb =[][3]int {{4,0x1,int (_dd )},{3,0x1,int (_cg )},{1,0x1,int (_ccg )},{3,0x3,int (_eeb )},{6,0x3,int (_da )},{7,0x3,int (_cf )},{3,0x2,int (_dgb )},{6,0x2,int (_bg )},{7,0x2,int (_ge )},{10,0xf,int (_gdf )},{12,0xf,int (_eb )},{12,0x1,int (EOL )}};
_fae =[][3]int {{4,0x07,2},{4,0x08,3},{4,0x0B,4},{4,0x0C,5},{4,0x0E,6},{4,0x0F,7},{5,0x12,128},{5,0x13,8},{5,0x14,9},{5,0x1B,64},{5,0x07,10},{5,0x08,11},{6,0x17,192},{6,0x18,1664},{6,0x2A,16},{6,0x2B,17},{6,0x03,13},{6,0x34,14},{6,0x35,15},{6,0x07,1},{6,0x08,12},{7,0x13,26},{7,0x17,21},{7,0x18,28},{7,0x24,27},{7,0x27,18},{7,0x28,24},{7,0x2B,25},{7,0x03,22},{7,0x37,256},{7,0x04,23},{7,0x08,20},{7,0xC,19},{8,0x12,33},{8,0x13,34},{8,0x14,35},{8,0x15,36},{8,0x16,37},{8,0x17,38},{8,0x1A,31},{8,0x1B,32},{8,0x02,29},{8,0x24,53},{8,0x25,54},{8,0x28,39},{8,0x29,40},{8,0x2A,41},{8,0x2B,42},{8,0x2C,43},{8,0x2D,44},{8,0x03,30},{8,0x32,61},{8,0x33,62},{8,0x34,63},{8,0x35,0},{8,0x36,320},{8,0x37,384},{8,0x04,45},{8,0x4A,59},{8,0x4B,60},{8,0x5,46},{8,0x52,49},{8,0x53,50},{8,0x54,51},{8,0x55,52},{8,0x58,55},{8,0x59,56},{8,0x5A,57},{8,0x5B,58},{8,0x64,448},{8,0x65,512},{8,0x67,640},{8,0x68,576},{8,0x0A,47},{8,0x0B,48},{9,0x01,_db },{9,0x98,1472},{9,0x99,1536},{9,0x9A,1600},{9,0x9B,1728},{9,0xCC,704},{9,0xCD,768},{9,0xD2,832},{9,0xD3,896},{9,0xD4,960},{9,0xD5,1024},{9,0xD6,1088},{9,0xD7,1152},{9,0xD8,1216},{9,0xD9,1280},{9,0xDA,1344},{9,0xDB,1408},{10,0x01,_db },{11,0x01,_db },{11,0x08,1792},{11,0x0C,1856},{11,0x0D,1920},{12,0x00,EOF },{12,0x01,EOL },{12,0x12,1984},{12,0x13,2048},{12,0x14,2112},{12,0x15,2176},{12,0x16,2240},{12,0x17,2304},{12,0x1C,2368},{12,0x1D,2432},{12,0x1E,2496},{12,0x1F,2560}};
_ce =[][3]int {{2,0x02,3},{2,0x03,2},{3,0x02,1},{3,0x03,4},{4,0x02,6},{4,0x03,5},{5,0x03,7},{6,0x04,9},{6,0x05,8},{7,0x04,10},{7,0x05,11},{7,0x07,12},{8,0x04,13},{8,0x07,14},{9,0x01,_db },{9,0x18,15},{10,0x01,_db },{10,0x17,16},{10,0x18,17},{10,0x37,0},{10,0x08,18},{10,0x0F,64},{11,0x01,_db },{11,0x17,24},{11,0x18,25},{11,0x28,23},{11,0x37,22},{11,0x67,19},{11,0x68,20},{11,0x6C,21},{11,0x08,1792},{11,0x0C,1856},{11,0x0D,1920},{12,0x00,EOF },{12,0x01,EOL },{12,0x12,1984},{12,0x13,2048},{12,0x14,2112},{12,0x15,2176},{12,0x16,2240},{12,0x17,2304},{12,0x1C,2368},{12,0x1D,2432},{12,0x1E,2496},{12,0x1F,2560},{12,0x24,52},{12,0x27,55},{12,0x28,56},{12,0x2B,59},{12,0x2C,60},{12,0x33,320},{12,0x34,384},{12,0x35,448},{12,0x37,53},{12,0x38,54},{12,0x52,50},{12,0x53,51},{12,0x54,44},{12,0x55,45},{12,0x56,46},{12,0x57,47},{12,0x58,57},{12,0x59,58},{12,0x5A,61},{12,0x5B,256},{12,0x64,48},{12,0x65,49},{12,0x66,62},{12,0x67,63},{12,0x68,30},{12,0x69,31},{12,0x6A,32},{12,0x6B,33},{12,0x6C,40},{12,0x6D,41},{12,0xC8,128},{12,0xC9,192},{12,0xCA,26},{12,0xCB,27},{12,0xCC,28},{12,0xCD,29},{12,0xD2,34},{12,0xD3,35},{12,0xD4,36},{12,0xD5,37},{12,0xD6,38},{12,0xD7,39},{12,0xDA,42},{12,0xDB,43},{13,0x4A,640},{13,0x4B,704},{13,0x4C,768},{13,0x4D,832},{13,0x52,1280},{13,0x53,1344},{13,0x54,1408},{13,0x55,1472},{13,0x5A,1536},{13,0x5B,1600},{13,0x64,1664},{13,0x65,1728},{13,0x6C,512},{13,0x6D,576},{13,0x72,896},{13,0x73,960},{13,0x74,1024},{13,0x75,1088},{13,0x76,1152},{13,0x77,1216}};
);func (_be *code )String ()string {return _g .Sprintf ("\u0025\u0064\u002f\u0025\u0064\u002f\u0025\u0064",_be ._fd ,_be ._ef ,_be ._dc );};func (_cef *Decoder )uncompress1d (_fgd *runData ,_ebd []int ,_dcg int )(int ,error ){var (_bec =true ;_aec int ;
_dbf *code ;_dgd int ;_bf error ;);_fgf :for _aec < _dcg {_agf :for {if _bec {_dbf ,_bf =_fgd .uncompressGetCode (_cef ._ag );if _bf !=nil {return 0,_bf ;};}else {_dbf ,_bf =_fgd .uncompressGetCode (_cef ._ad );if _bf !=nil {return 0,_bf ;};};_fgd ._dcdg +=_dbf ._fd ;
if _dbf ._dc < 0{break _fgf ;};_aec +=_dbf ._dc ;if _dbf ._dc < 64{_bec =!_bec ;_ebd [_dgd ]=_aec ;_dgd ++;break _agf ;};};};if _ebd [_dgd ]!=_dcg {_ebd [_dgd ]=_dcg ;};_adc :=EOL ;if _dbf !=nil &&_dbf ._dc !=EOL {_adc =_dgd ;};return _adc ,nil ;};func (_fgff *runData )uncompressGetCodeLittleEndian (_dfgb []*code )(*code ,error ){_dgdc ,_fabd :=_fgff .uncompressGetNextCodeLittleEndian ();
if _fabd !=nil {_fa .Log .Debug ("\u0055n\u0063\u006fm\u0070\u0072\u0065\u0073s\u0047\u0065\u0074N\u0065\u0078\u0074\u0043\u006f\u0064\u0065\u004c\u0069tt\u006c\u0065\u0045n\u0064\u0069a\u006e\u0020\u0066\u0061\u0069\u006ce\u0064\u003a \u0025\u0076",_fabd );
return nil ,_fabd ;};_dgdc &=0xffffff;_bag :=_dgdc >>(_eegf -_ebe );_abb :=_dfgb [_bag ];if _abb !=nil &&_abb ._ba {_bag =(_dgdc >>(_eegf -_ebe -_bed ))&_gf ;_abb =_abb ._b [_bag ];};return _abb ,nil ;};func (_fbb *Decoder )initTables ()(_dcd error ){if _fbb ._ag ==nil {_fbb ._ag ,_dcd =_fbb .createLittleEndianTable (_fae );
if _dcd !=nil {return ;};_fbb ._ad ,_dcd =_fbb .createLittleEndianTable (_ce );if _dcd !=nil {return ;};_fbb ._ga ,_dcd =_fbb .createLittleEndianTable (_gdfb );if _dcd !=nil {return ;};};return nil ;};type Decoder struct{_cea ,_a int ;_gc *runData ;_ag []*code ;
_ad []*code ;_ga []*code ;};func (_ab *Decoder )uncompress2d (_aabf *runData ,_fe []int ,_ac int ,_fbc []int ,_dfgf int )(int ,error ){var (_gb int ;_feg int ;_ff int ;_ccb =true ;_gdg error ;_eed *code ;);_fe [_ac ]=_dfgf ;_fe [_ac +1]=_dfgf ;_fe [_ac +2]=_dfgf +1;
_fe [_ac +3]=_dfgf +1;_agb :for _ff < _dfgf {_eed ,_gdg =_aabf .uncompressGetCode (_ab ._ga );if _gdg !=nil {return EOL ,nil ;};if _eed ==nil {_aabf ._dcdg ++;break _agb ;};_aabf ._dcdg +=_eed ._fd ;switch mmrCode (_eed ._dc ){case _ccg :_ff =_fe [_gb ];
case _eeb :_ff =_fe [_gb ]+1;case _dgb :_ff =_fe [_gb ]-1;case _cg :for {var _bab []*code ;if _ccb {_bab =_ab ._ag ;}else {_bab =_ab ._ad ;};_eed ,_gdg =_aabf .uncompressGetCode (_bab );if _gdg !=nil {return 0,_gdg ;};if _eed ==nil {break _agb ;};_aabf ._dcdg +=_eed ._fd ;
if _eed ._dc < 64{if _eed ._dc < 0{_fbc [_feg ]=_ff ;_feg ++;_eed =nil ;break _agb ;};_ff +=_eed ._dc ;_fbc [_feg ]=_ff ;_feg ++;break ;};_ff +=_eed ._dc ;};_fdc :=_ff ;_bbb :for {var _eca []*code ;if !_ccb {_eca =_ab ._ag ;}else {_eca =_ab ._ad ;};_eed ,_gdg =_aabf .uncompressGetCode (_eca );
if _gdg !=nil {return 0,_gdg ;};if _eed ==nil {break _agb ;};_aabf ._dcdg +=_eed ._fd ;if _eed ._dc < 64{if _eed ._dc < 0{_fbc [_feg ]=_ff ;_feg ++;break _agb ;};_ff +=_eed ._dc ;if _ff < _dfgf ||_ff !=_fdc {_fbc [_feg ]=_ff ;_feg ++;};break _bbb ;};_ff +=_eed ._dc ;
};for _ff < _dfgf &&_fe [_gb ]<=_ff {_gb +=2;};continue _agb ;case _dd :_gb ++;_ff =_fe [_gb ];_gb ++;continue _agb ;case _da :_ff =_fe [_gb ]+2;case _bg :_ff =_fe [_gb ]-2;case _cf :_ff =_fe [_gb ]+3;case _ge :_ff =_fe [_gb ]-3;default:if _aabf ._dcdg ==12&&_eed ._dc ==EOL {_aabf ._dcdg =0;
if _ ,_gdg =_ab .uncompress1d (_aabf ,_fe ,_dfgf );_gdg !=nil {return 0,_gdg ;};_aabf ._dcdg ++;if _ ,_gdg =_ab .uncompress1d (_aabf ,_fbc ,_dfgf );_gdg !=nil {return 0,_gdg ;};_bee ,_fab :=_ab .uncompress1d (_aabf ,_fe ,_dfgf );if _fab !=nil {return EOF ,_fab ;
};_aabf ._dcdg ++;return _bee ,nil ;};_ff =_dfgf ;continue _agb ;};if _ff <=_dfgf {_ccb =!_ccb ;_fbc [_feg ]=_ff ;_feg ++;if _gb > 0{_gb --;}else {_gb ++;};for _ff < _dfgf &&_fe [_gb ]<=_ff {_gb +=2;};};};if _fbc [_feg ]!=_dfgf {_fbc [_feg ]=_dfgf ;};if _eed ==nil {return EOL ,nil ;
};return _feg ,nil ;};func (_gdc *Decoder )createLittleEndianTable (_aed [][3]int )([]*code ,error ){_ea :=make ([]*code ,_efb +1);for _gad :=0;_gad < len (_aed );_gad ++{_aeb :=_dg (_aed [_gad ]);if _aeb ._fd <=_ebe {_eebe :=_ebe -_aeb ._fd ;_aa :=_aeb ._ef <<uint (_eebe );
for _ed :=(1<<uint (_eebe ))-1;_ed >=0;_ed --{_gfe :=_aa |_ed ;_ea [_gfe ]=_aeb ;};}else {_bef :=_aeb ._ef >>uint (_aeb ._fd -_ebe );if _ea [_bef ]==nil {var _gda =_dg ([3]int {});_gda ._b =make ([]*code ,_gf +1);_ea [_bef ]=_gda ;};if _aeb ._fd <=_ebe +_bed {_fdad :=_ebe +_bed -_aeb ._fd ;
_gdfd :=(_aeb ._ef <<uint (_fdad ))&_gf ;_ea [_bef ]._ba =true ;for _df :=(1<<uint (_fdad ))-1;_df >=0;_df --{_ea [_bef ]._b [_gdfd |_df ]=_aeb ;};}else {return nil ,_e .New ("\u0043\u006f\u0064\u0065\u0020\u0074a\u0062\u006c\u0065\u0020\u006f\u0076\u0065\u0072\u0066\u006c\u006f\u0077\u0020i\u006e\u0020\u004d\u004d\u0052\u0044\u0065c\u006f\u0064\u0065\u0072");
};};};return _ea ,nil ;};func _eeg (_fda ,_cc int )int {if _fda > _cc {return _cc ;};return _fda ;};func (_cgf *runData )align (){_cgf ._dcdg =((_cgf ._dcdg +7)>>3)<<3};func (_dfg *Decoder )detectAndSkipEOL ()error {for {_fb ,_fga :=_dfg ._gc .uncompressGetCode (_dfg ._ga );
if _fga !=nil {return _fga ;};if _fb !=nil &&_fb ._dc ==EOL {_dfg ._gc ._dcdg +=_fb ._fd ;}else {return nil ;};};};func (_eda *runData )uncompressGetCode (_ffd []*code )(*code ,error ){return _eda .uncompressGetCodeLittleEndian (_ffd );};const (_dd mmrCode =iota ;
_cg ;_ccg ;_eeb ;_da ;_cf ;_dgb ;_bg ;_ge ;_gdf ;_eb ;);func (_gec *runData )fillBuffer (_ccgg int )error {_gec ._cfb =_ccgg ;_ ,_ccd :=_gec ._dfb .Seek (int64 (_ccgg ),_d .SeekStart );if _ccd !=nil {if _ccd ==_d .EOF {_fa .Log .Debug ("\u0053\u0065\u0061\u006b\u0020\u0045\u004f\u0046");
_gec ._baa =-1;}else {return _ccd ;};};if _ccd ==nil {_gec ._baa ,_ccd =_gec ._dfb .Read (_gec ._add );if _ccd !=nil {if _ccd ==_d .EOF {_fa .Log .Trace ("\u0052\u0065\u0061\u0064\u0020\u0045\u004f\u0046");_gec ._baa =-1;}else {return _ccd ;};};};if _gec ._baa > -1&&_gec ._baa < 3{for _gec ._baa < 3{_dbb ,_aga :=_gec ._dfb .ReadByte ();
if _aga !=nil {if _aga ==_d .EOF {_gec ._add [_gec ._baa ]=0;}else {return _aga ;};}else {_gec ._add [_gec ._baa ]=_dbb &0xFF;};_gec ._baa ++;};};_gec ._baa -=3;if _gec ._baa < 0{_gec ._add =make ([]byte ,len (_gec ._add ));_gec ._baa =len (_gec ._add )-3;
};return nil ;};func (_fea *runData )uncompressGetNextCodeLittleEndian ()(int ,error ){_gac :=_fea ._dcdg -_fea ._fag ;if _gac < 0||_gac > 24{_ggb :=(_fea ._dcdg >>3)-_fea ._cfb ;if _ggb >=_fea ._baa {_ggb +=_fea ._cfb ;if _ecg :=_fea .fillBuffer (_ggb );
_ecg !=nil {return 0,_ecg ;};_ggb -=_fea ._cfb ;};_dcf :=(uint32 (_fea ._add [_ggb ]&0xFF)<<16)|(uint32 (_fea ._add [_ggb +1]&0xFF)<<8)|(uint32 (_fea ._add [_ggb +2]&0xFF));_befe :=uint32 (_fea ._dcdg &7);_dcf <<=_befe ;_fea ._aecb =int (_dcf );}else {_ddc :=_fea ._fag &7;
_dgf :=7-_ddc ;if _gac <=_dgf {_fea ._aecb <<=uint (_gac );}else {_bgc :=(_fea ._fag >>3)+3-_fea ._cfb ;if _bgc >=_fea ._baa {_bgc +=_fea ._cfb ;if _gcd :=_fea .fillBuffer (_bgc );_gcd !=nil {return 0,_gcd ;};_bgc -=_fea ._cfb ;};_ddc =8-_ddc ;for {_fea ._aecb <<=uint (_ddc );
_fea ._aecb |=int (uint (_fea ._add [_bgc ])&0xFF);_gac -=_ddc ;_bgc ++;_ddc =8;if !(_gac >=8){break ;};};_fea ._aecb <<=uint (_gac );};};_fea ._fag =_fea ._dcdg ;return _fea ._aecb ,nil ;};const (EOF =-3;_db =-2;EOL =-1;_ebe =8;_efb =(1<<_ebe )-1;_bed =5;
_gf =(1<<_bed )-1;);type runData struct{_dfb *_gd .SubstreamReader ;_dcdg int ;_fag int ;_aecb int ;_add []byte ;_cfb int ;_baa int ;};func _fbe (_acg *_gd .SubstreamReader )(*runData ,error ){_ada :=&runData {_dfb :_acg ,_dcdg :0,_fag :1};_fff :=_eeg (_fad (_gag ,int (_acg .Length ())),_aeg );
_ada ._add =make ([]byte ,_fff );if _acb :=_ada .fillBuffer (0);_acb !=nil {if _acb ==_d .EOF {_ada ._add =make ([]byte ,10);_fa .Log .Debug ("F\u0069\u006c\u006c\u0042uf\u0066e\u0072\u0020\u0066\u0061\u0069l\u0065\u0064\u003a\u0020\u0025\u0076",_acb );
}else {return nil ,_acb ;};};return _ada ,nil ;};