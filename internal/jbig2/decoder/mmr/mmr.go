//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package mmr ;import (_b "errors";_a "fmt";_bd "github.com/unidoc/unipdf/v3/common";_ac "github.com/unidoc/unipdf/v3/internal/bitwise";_f "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_ab "io";);func _ea (_gf ,_abd int )int {if _gf > _abd {return _abd ;};return _gf ;};type mmrCode int ;func (_dac *runData )fillBuffer (_cbf int )error {_dac ._ega =_cbf ;_ ,_aea :=_dac ._eg .Seek (int64 (_cbf ),_ab .SeekStart );if _aea !=nil {if _aea ==_ab .EOF {_bd .Log .Debug ("\u0053\u0065\u0061\u006b\u0020\u0045\u004f\u0046");_dac ._ge =-1;}else {return _aea ;};};if _aea ==nil {_dac ._ge ,_aea =_dac ._eg .Read (_dac ._egg );if _aea !=nil {if _aea ==_ab .EOF {_bd .Log .Trace ("\u0052\u0065\u0061\u0064\u0020\u0045\u004f\u0046");_dac ._ge =-1;}else {return _aea ;};};};if _dac ._ge > -1&&_dac ._ge < 3{for _dac ._ge < 3{_gga ,_fcd :=_dac ._eg .ReadByte ();if _fcd !=nil {if _fcd ==_ab .EOF {_dac ._egg [_dac ._ge ]=0;}else {return _fcd ;};}else {_dac ._egg [_dac ._ge ]=_gga &0xFF;};_dac ._ge ++;};};_dac ._ge -=3;if _dac ._ge < 0{_dac ._egg =make ([]byte ,len (_dac ._egg ));_dac ._ge =len (_dac ._egg )-3;};return nil ;};const (_faad int =1024<<7;_fde int =3;_afd uint =24;);var (_acg =[][3]int {{4,0x1,int (_acb )},{3,0x1,int (_cd )},{1,0x1,int (_dd )},{3,0x3,int (_eb )},{6,0x3,int (_ee )},{7,0x3,int (_ec )},{3,0x2,int (_efg )},{6,0x2,int (_ddc )},{7,0x2,int (_aca )},{10,0xf,int (_bf )},{12,0xf,int (_acae )},{12,0x1,int (EOL )}};_eca =[][3]int {{4,0x07,2},{4,0x08,3},{4,0x0B,4},{4,0x0C,5},{4,0x0E,6},{4,0x0F,7},{5,0x12,128},{5,0x13,8},{5,0x14,9},{5,0x1B,64},{5,0x07,10},{5,0x08,11},{6,0x17,192},{6,0x18,1664},{6,0x2A,16},{6,0x2B,17},{6,0x03,13},{6,0x34,14},{6,0x35,15},{6,0x07,1},{6,0x08,12},{7,0x13,26},{7,0x17,21},{7,0x18,28},{7,0x24,27},{7,0x27,18},{7,0x28,24},{7,0x2B,25},{7,0x03,22},{7,0x37,256},{7,0x04,23},{7,0x08,20},{7,0xC,19},{8,0x12,33},{8,0x13,34},{8,0x14,35},{8,0x15,36},{8,0x16,37},{8,0x17,38},{8,0x1A,31},{8,0x1B,32},{8,0x02,29},{8,0x24,53},{8,0x25,54},{8,0x28,39},{8,0x29,40},{8,0x2A,41},{8,0x2B,42},{8,0x2C,43},{8,0x2D,44},{8,0x03,30},{8,0x32,61},{8,0x33,62},{8,0x34,63},{8,0x35,0},{8,0x36,320},{8,0x37,384},{8,0x04,45},{8,0x4A,59},{8,0x4B,60},{8,0x5,46},{8,0x52,49},{8,0x53,50},{8,0x54,51},{8,0x55,52},{8,0x58,55},{8,0x59,56},{8,0x5A,57},{8,0x5B,58},{8,0x64,448},{8,0x65,512},{8,0x67,640},{8,0x68,576},{8,0x0A,47},{8,0x0B,48},{9,0x01,_bdb },{9,0x98,1472},{9,0x99,1536},{9,0x9A,1600},{9,0x9B,1728},{9,0xCC,704},{9,0xCD,768},{9,0xD2,832},{9,0xD3,896},{9,0xD4,960},{9,0xD5,1024},{9,0xD6,1088},{9,0xD7,1152},{9,0xD8,1216},{9,0xD9,1280},{9,0xDA,1344},{9,0xDB,1408},{10,0x01,_bdb },{11,0x01,_bdb },{11,0x08,1792},{11,0x0C,1856},{11,0x0D,1920},{12,0x00,EOF },{12,0x01,EOL },{12,0x12,1984},{12,0x13,2048},{12,0x14,2112},{12,0x15,2176},{12,0x16,2240},{12,0x17,2304},{12,0x1C,2368},{12,0x1D,2432},{12,0x1E,2496},{12,0x1F,2560}};_dg =[][3]int {{2,0x02,3},{2,0x03,2},{3,0x02,1},{3,0x03,4},{4,0x02,6},{4,0x03,5},{5,0x03,7},{6,0x04,9},{6,0x05,8},{7,0x04,10},{7,0x05,11},{7,0x07,12},{8,0x04,13},{8,0x07,14},{9,0x01,_bdb },{9,0x18,15},{10,0x01,_bdb },{10,0x17,16},{10,0x18,17},{10,0x37,0},{10,0x08,18},{10,0x0F,64},{11,0x01,_bdb },{11,0x17,24},{11,0x18,25},{11,0x28,23},{11,0x37,22},{11,0x67,19},{11,0x68,20},{11,0x6C,21},{11,0x08,1792},{11,0x0C,1856},{11,0x0D,1920},{12,0x00,EOF },{12,0x01,EOL },{12,0x12,1984},{12,0x13,2048},{12,0x14,2112},{12,0x15,2176},{12,0x16,2240},{12,0x17,2304},{12,0x1C,2368},{12,0x1D,2432},{12,0x1E,2496},{12,0x1F,2560},{12,0x24,52},{12,0x27,55},{12,0x28,56},{12,0x2B,59},{12,0x2C,60},{12,0x33,320},{12,0x34,384},{12,0x35,448},{12,0x37,53},{12,0x38,54},{12,0x52,50},{12,0x53,51},{12,0x54,44},{12,0x55,45},{12,0x56,46},{12,0x57,47},{12,0x58,57},{12,0x59,58},{12,0x5A,61},{12,0x5B,256},{12,0x64,48},{12,0x65,49},{12,0x66,62},{12,0x67,63},{12,0x68,30},{12,0x69,31},{12,0x6A,32},{12,0x6B,33},{12,0x6C,40},{12,0x6D,41},{12,0xC8,128},{12,0xC9,192},{12,0xCA,26},{12,0xCB,27},{12,0xCC,28},{12,0xCD,29},{12,0xD2,34},{12,0xD3,35},{12,0xD4,36},{12,0xD5,37},{12,0xD6,38},{12,0xD7,39},{12,0xDA,42},{12,0xDB,43},{13,0x4A,640},{13,0x4B,704},{13,0x4C,768},{13,0x4D,832},{13,0x52,1280},{13,0x53,1344},{13,0x54,1408},{13,0x55,1472},{13,0x5A,1536},{13,0x5B,1600},{13,0x64,1664},{13,0x65,1728},{13,0x6C,512},{13,0x6D,576},{13,0x72,896},{13,0x73,960},{13,0x74,1024},{13,0x75,1088},{13,0x76,1152},{13,0x77,1216}};);type runData struct{_eg *_ac .SubstreamReader ;_bad int ;_cdd int ;_cdg int ;_egg []byte ;_ega int ;_ge int ;};func _ef (_gdf ,_ad int )int {if _gdf < _ad {return _ad ;};return _gdf ;};func (_eeg *Decoder )createLittleEndianTable (_gdd [][3]int )([]*code ,error ){_fe :=make ([]*code ,_gc +1);for _bbe :=0;_bbe < len (_gdd );_bbe ++{_daf :=_bdc (_gdd [_bbe ]);if _daf ._c <=_abe {_df :=_abe -_daf ._c ;_ff :=_daf ._aa <<uint (_df );for _adg :=(1<<uint (_df ))-1;_adg >=0;_adg --{_efd :=_ff |_adg ;_fe [_efd ]=_daf ;};}else {_abdc :=_daf ._aa >>uint (_daf ._c -_abe );if _fe [_abdc ]==nil {var _bbfe =_bdc ([3]int {});_bbfe ._af =make ([]*code ,_dc +1);_fe [_abdc ]=_bbfe ;};if _daf ._c <=_abe +_ecc {_age :=_abe +_ecc -_daf ._c ;_ddg :=(_daf ._aa <<uint (_age ))&_dc ;_fe [_abdc ]._e =true ;for _cbg :=(1<<uint (_age ))-1;_cbg >=0;_cbg --{_fe [_abdc ]._af [_ddg |_cbg ]=_daf ;};}else {return nil ,_b .New ("\u0043\u006f\u0064\u0065\u0020\u0074a\u0062\u006c\u0065\u0020\u006f\u0076\u0065\u0072\u0066\u006c\u006f\u0077\u0020i\u006e\u0020\u004d\u004d\u0052\u0044\u0065c\u006f\u0064\u0065\u0072");};};};return _fe ,nil ;};func (_cg *runData )uncompressGetCodeLittleEndian (_dgc []*code )(*code ,error ){_eag ,_fce :=_cg .uncompressGetNextCodeLittleEndian ();if _fce !=nil {_bd .Log .Debug ("\u0055n\u0063\u006fm\u0070\u0072\u0065\u0073s\u0047\u0065\u0074N\u0065\u0078\u0074\u0043\u006f\u0064\u0065\u004c\u0069tt\u006c\u0065\u0045n\u0064\u0069a\u006e\u0020\u0066\u0061\u0069\u006ce\u0064\u003a \u0025\u0076",_fce );return nil ,_fce ;};_eag &=0xffffff;_caf :=_eag >>(_afd -_abe );_cab :=_dgc [_caf ];if _cab !=nil &&_cab ._e {_caf =(_eag >>(_afd -_abe -_ecc ))&_dc ;_cab =_cab ._af [_caf ];};return _cab ,nil ;};func New (r _ac .StreamReader ,width ,height int ,dataOffset ,dataLength int64 )(*Decoder ,error ){_faf :=&Decoder {_fa :width ,_da :height };_cdf ,_cf :=_ac .NewSubstreamReader (r ,uint64 (dataOffset ),uint64 (dataLength ));if _cf !=nil {return nil ,_cf ;};_fg ,_cf :=_beb (_cdf );if _cf !=nil {return nil ,_cf ;};_faf ._acgb =_fg ;if _bb :=_faf .initTables ();_bb !=nil {return nil ,_bb ;};return _faf ,nil ;};func (_dad *runData )uncompressGetCode (_eec []*code )(*code ,error ){return _dad .uncompressGetCodeLittleEndian (_eec );};func (_fc *Decoder )detectAndSkipEOL ()error {for {_ca ,_fb :=_fc ._acgb .uncompressGetCode (_fc ._de );if _fb !=nil {return _fb ;};if _ca !=nil &&_ca ._d ==EOL {_fc ._acgb ._bad +=_ca ._c ;}else {return nil ;};};};func (_cfg *runData )align (){_cfg ._bad =((_cfg ._bad +7)>>3)<<3};func (_db *Decoder )uncompress2d (_dbe *runData ,_ebc []int ,_cac int ,_fbb []int ,_faa int )(int ,error ){var (_gba int ;_adf int ;_cc int ;_ade =true ;_gfa error ;_bef *code ;);_ebc [_cac ]=_faa ;_ebc [_cac +1]=_faa ;_ebc [_cac +2]=_faa +1;_ebc [_cac +3]=_faa +1;_agf :for _cc < _faa {_bef ,_gfa =_dbe .uncompressGetCode (_db ._de );if _gfa !=nil {return EOL ,nil ;};if _bef ==nil {_dbe ._bad ++;break _agf ;};_dbe ._bad +=_bef ._c ;switch mmrCode (_bef ._d ){case _dd :_cc =_ebc [_gba ];case _eb :_cc =_ebc [_gba ]+1;case _efg :_cc =_ebc [_gba ]-1;case _cd :_aba :=1;for _aba > 0{var _fdf []*code ;if _ade {_fdf =_db ._cb ;}else {_fdf =_db ._be ;};_bef ,_gfa =_dbe .uncompressGetCode (_fdf );if _gfa !=nil {return 0,_gfa ;};if _bef ==nil {break _agf ;};_dbe ._bad +=_bef ._c ;if _bef ._d < 64{if _bef ._d < 0{_fbb [_adf ]=_cc ;_adf ++;_bef =nil ;break _agf ;};_cc +=_bef ._d ;_fbb [_adf ]=_cc ;_adf ++;break ;};_cc +=_bef ._d ;};_eba :=_cc ;_cca :=1;_dda :for _cca > 0{var _eea []*code ;if !_ade {_eea =_db ._cb ;}else {_eea =_db ._be ;};_bef ,_gfa =_dbe .uncompressGetCode (_eea );if _gfa !=nil {return 0,_gfa ;};if _bef ==nil {break _agf ;};_dbe ._bad +=_bef ._c ;if _bef ._d < 64{if _bef ._d < 0{_fbb [_adf ]=_cc ;_adf ++;break _agf ;};_cc +=_bef ._d ;if _cc < _faa ||_cc !=_eba {_fbb [_adf ]=_cc ;_adf ++;};break _dda ;};_cc +=_bef ._d ;};for _cc < _faa &&_ebc [_gba ]<=_cc {_gba +=2;};continue _agf ;case _acb :_gba ++;_cc =_ebc [_gba ];_gba ++;continue _agf ;case _ee :_cc =_ebc [_gba ]+2;case _ddc :_cc =_ebc [_gba ]-2;case _ec :_cc =_ebc [_gba ]+3;case _aca :_cc =_ebc [_gba ]-3;default:if _dbe ._bad ==12&&_bef ._d ==EOL {_dbe ._bad =0;if _ ,_gfa =_db .uncompress1d (_dbe ,_ebc ,_faa );_gfa !=nil {return 0,_gfa ;};_dbe ._bad ++;if _ ,_gfa =_db .uncompress1d (_dbe ,_fbb ,_faa );_gfa !=nil {return 0,_gfa ;};_aad ,_bgd :=_db .uncompress1d (_dbe ,_ebc ,_faa );if _bgd !=nil {return EOF ,_bgd ;};_dbe ._bad ++;return _aad ,nil ;};_cc =_faa ;continue _agf ;};if _cc <=_faa {_ade =!_ade ;_fbb [_adf ]=_cc ;_adf ++;if _gba > 0{_gba --;}else {_gba ++;};for _cc < _faa &&_ebc [_gba ]<=_cc {_gba +=2;};};};if _fbb [_adf ]!=_faa {_fbb [_adf ]=_faa ;};if _bef ==nil {return EOL ,nil ;};return _adf ,nil ;};type Decoder struct{_fa ,_da int ;_acgb *runData ;_cb []*code ;_be []*code ;_de []*code ;};func (_ebe *Decoder )uncompress1d (_acac *runData ,_ce []int ,_ecd int )(int ,error ){var (_ddd =true ;_aabe int ;_fd *code ;_cdfc int ;_gce error ;);_gbd :for _aabe < _ecd {_bedb :for {if _ddd {_fd ,_gce =_acac .uncompressGetCode (_ebe ._cb );if _gce !=nil {return 0,_gce ;};}else {_fd ,_gce =_acac .uncompressGetCode (_ebe ._be );if _gce !=nil {return 0,_gce ;};};_acac ._bad +=_fd ._c ;if _fd ._d < 0{break _gbd ;};_aabe +=_fd ._d ;if _fd ._d < 64{_ddd =!_ddd ;_ce [_cdfc ]=_aabe ;_cdfc ++;break _bedb ;};};};if _ce [_cdfc ]!=_ecd {_ce [_cdfc ]=_ecd ;};_eee :=EOL ;if _fd !=nil &&_fd ._d !=EOL {_eee =_cdfc ;};return _eee ,nil ;};func _beb (_ffc *_ac .SubstreamReader )(*runData ,error ){_egb :=&runData {_eg :_ffc ,_bad :0,_cdd :1};_dbd :=_ea (_ef (_fde ,int (_ffc .Length ())),_faad );_egb ._egg =make ([]byte ,_dbd );if _bea :=_egb .fillBuffer (0);_bea !=nil {if _bea ==_ab .EOF {_egb ._egg =make ([]byte ,10);_bd .Log .Debug ("F\u0069\u006c\u006c\u0042uf\u0066e\u0072\u0020\u0066\u0061\u0069l\u0065\u0064\u003a\u0020\u0025\u0076",_bea );}else {return nil ,_bea ;};};return _egb ,nil ;};const (_acb mmrCode =iota ;_cd ;_dd ;_eb ;_ee ;_ec ;_efg ;_ddc ;_aca ;_bf ;_acae ;);type code struct{_c int ;_aa int ;_d int ;_af []*code ;_e bool ;};func (_bed *Decoder )initTables ()(_afb error ){if _bed ._cb ==nil {_bed ._cb ,_afb =_bed .createLittleEndianTable (_eca );if _afb !=nil {return ;};_bed ._be ,_afb =_bed .createLittleEndianTable (_dg );if _afb !=nil {return ;};_bed ._de ,_afb =_bed .createLittleEndianTable (_acg );if _afb !=nil {return ;};};return nil ;};func (_gd *code )String ()string {return _a .Sprintf ("\u0025\u0064\u002f\u0025\u0064\u002f\u0025\u0064",_gd ._c ,_gd ._aa ,_gd ._d );};func (_bg *Decoder )UncompressMMR ()(_bbf *_f .Bitmap ,_aab error ){_bbf =_f .New (_bg ._fa ,_bg ._da );_bc :=make ([]int ,_bbf .Width +5);_dea :=make ([]int ,_bbf .Width +5);_dea [0]=_bbf .Width ;_gb :=1;var _gff int ;for _acf :=0;_acf < _bbf .Height ;_acf ++{_gff ,_aab =_bg .uncompress2d (_bg ._acgb ,_dea ,_gb ,_bc ,_bbf .Width );if _aab !=nil {return nil ,_aab ;};if _gff ==EOF {break ;};if _gff > 0{_aab =_bg .fillBitmap (_bbf ,_acf ,_bc ,_gff );if _aab !=nil {return nil ,_aab ;};};_dea ,_bc =_bc ,_dea ;_gb =_gff ;};if _aab =_bg .detectAndSkipEOL ();_aab !=nil {return nil ,_aab ;};_bg ._acgb .align ();return _bbf ,nil ;};const (EOF =-3;_bdb =-2;EOL =-1;_abe =8;_gc =(1<<_abe )-1;_ecc =5;_dc =(1<<_ecc )-1;);func (_agb *Decoder )fillBitmap (_gdb *_f .Bitmap ,_ga int ,_eed []int ,_fcc int )error {var _aae byte ;_eab :=0;_fad :=_gdb .GetByteIndex (_eab ,_ga );for _ed :=0;_ed < _fcc ;_ed ++{_bdf :=byte (1);_afg :=_eed [_ed ];if (_ed &1)==0{_bdf =0;};for _eab < _afg {_aae =(_aae <<1)|_bdf ;_eab ++;if (_eab &7)==0{if _ba :=_gdb .SetByte (_fad ,_aae );_ba !=nil {return _ba ;};_fad ++;_aae =0;};};};if (_eab &7)!=0{_aae <<=uint (8-(_eab &7));if _gag :=_gdb .SetByte (_fad ,_aae );_gag !=nil {return _gag ;};};return nil ;};func _bdc (_ag [3]int )*code {return &code {_c :_ag [0],_aa :_ag [1],_d :_ag [2]}};func (_abc *runData )uncompressGetNextCodeLittleEndian ()(int ,error ){_egbg :=_abc ._bad -_abc ._cdd ;if _egbg < 0||_egbg > 24{_ged :=(_abc ._bad >>3)-_abc ._ega ;if _ged >=_abc ._ge {_ged +=_abc ._ega ;if _fba :=_abc .fillBuffer (_ged );_fba !=nil {return 0,_fba ;};_ged -=_abc ._ega ;};_afgb :=(uint32 (_abc ._egg [_ged ]&0xFF)<<16)|(uint32 (_abc ._egg [_ged +1]&0xFF)<<8)|(uint32 (_abc ._egg [_ged +2]&0xFF));_bag :=uint32 (_abc ._bad &7);_afgb <<=_bag ;_abc ._cdg =int (_afgb );}else {_gad :=_abc ._cdd &7;_ae :=7-_gad ;if _egbg <=_ae {_abc ._cdg <<=uint (_egbg );}else {_efc :=(_abc ._cdd >>3)+3-_abc ._ega ;if _efc >=_abc ._ge {_efc +=_abc ._ega ;if _gg :=_abc .fillBuffer (_efc );_gg !=nil {return 0,_gg ;};_efc -=_abc ._ega ;};_gad =8-_gad ;for {_abc ._cdg <<=uint (_gad );_abc ._cdg |=int (uint (_abc ._egg [_efc ])&0xFF);_egbg -=_gad ;_efc ++;_gad =8;if !(_egbg >=8){break ;};};_abc ._cdg <<=uint (_egbg );};};_abc ._cdd =_abc ._bad ;return _abc ._cdg ,nil ;};