//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package mmr ;import (_b "errors";_c "fmt";_ac "github.com/unidoc/unipdf/v3/common";_a "github.com/unidoc/unipdf/v3/internal/bitwise";_g "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_eg "io";);func (_fd *Decoder )UncompressMMR ()(_ce *_g .Bitmap ,_gfd error ){_ce =_g .New (_fd ._dc ,_fd ._fba );_dcd :=make ([]int ,_ce .Width +5);_cb :=make ([]int ,_ce .Width +5);_cb [0]=_ce .Width ;_eb :=1;var _ede int ;for _ga :=0;_ga < _ce .Height ;_ga ++{_ede ,_gfd =_fd .uncompress2d (_fd ._da ,_cb ,_eb ,_dcd ,_ce .Width );if _gfd !=nil {return nil ,_gfd ;};if _ede ==EOF {break ;};if _ede > 0{_gfd =_fd .fillBitmap (_ce ,_ga ,_dcd ,_ede );if _gfd !=nil {return nil ,_gfd ;};};_cb ,_dcd =_dcd ,_cb ;_eb =_ede ;};if _gfd =_fd .detectAndSkipEOL ();_gfd !=nil {return nil ,_gfd ;};_fd ._da .align ();return _ce ,nil ;};const (_aef mmrCode =iota ;_fa ;_fb ;_ed ;_ag ;_eea ;_ba ;_ab ;_bf ;_ea ;_gd ;);func (_bca *Decoder )fillBitmap (_ef *_g .Bitmap ,_ffb int ,_ebe []int ,_faf int )error {var _bad byte ;_gfbb :=0;_ccd :=_ef .GetByteIndex (_gfbb ,_ffb );for _adb :=0;_adb < _faf ;_adb ++{_be :=byte (1);_acc :=_ebe [_adb ];if (_adb &1)==0{_be =0;};for _gfbb < _acc {_bad =(_bad <<1)|_be ;_gfbb ++;if (_gfbb &7)==0{if _ceg :=_ef .SetByte (_ccd ,_bad );_ceg !=nil {return _ceg ;};_ccd ++;_bad =0;};};};if (_gfbb &7)!=0{_bad <<=uint (8-(_gfbb &7));if _gba :=_ef .SetByte (_ccd ,_bad );_gba !=nil {return _gba ;};};return nil ;};func _ge (_ae [3]int )*code {return &code {_gb :_ae [0],_gf :_ae [1],_ee :_ae [2]}};func (_ecc *Decoder )detectAndSkipEOL ()error {for {_ff ,_fcef :=_ecc ._da .uncompressGetCode (_ecc ._bb );if _fcef !=nil {return _fcef ;};if _ff !=nil &&_ff ._ee ==EOL {_ecc ._da ._eccb +=_ff ._gb ;}else {return nil ;};};};func (_ddad *runData )uncompressGetCode (_aeg []*code )(*code ,error ){return _ddad .uncompressGetCodeLittleEndian (_aeg );};type Decoder struct{_dc ,_fba int ;_da *runData ;_de []*code ;_gc []*code ;_bb []*code ;};func (_ded *Decoder )uncompress2d (_dec *runData ,_ced []int ,_gea int ,_aedd []int ,_ged int )(int ,error ){var (_dda int ;_aba int ;_afc int ;_bba =true ;_ada error ;_abb *code ;);_ced [_gea ]=_ged ;_ced [_gea +1]=_ged ;_ced [_gea +2]=_ged +1;_ced [_gea +3]=_ged +1;_ddf :for _afc < _ged {_abb ,_ada =_dec .uncompressGetCode (_ded ._bb );if _ada !=nil {return EOL ,nil ;};if _abb ==nil {_dec ._eccb ++;break _ddf ;};_dec ._eccb +=_abb ._gb ;switch mmrCode (_abb ._ee ){case _fb :_afc =_ced [_dda ];case _ed :_afc =_ced [_dda ]+1;case _ba :_afc =_ced [_dda ]-1;case _fa :_cbd :=1;for _cbd > 0{var _efg []*code ;if _bba {_efg =_ded ._de ;}else {_efg =_ded ._gc ;};_abb ,_ada =_dec .uncompressGetCode (_efg );if _ada !=nil {return 0,_ada ;};if _abb ==nil {break _ddf ;};_dec ._eccb +=_abb ._gb ;if _abb ._ee < 64{if _abb ._ee < 0{_aedd [_aba ]=_afc ;_aba ++;_abb =nil ;break _ddf ;};_afc +=_abb ._ee ;_aedd [_aba ]=_afc ;_aba ++;break ;};_afc +=_abb ._ee ;};_efc :=_afc ;_cag :=1;_adab :for _cag > 0{var _agd []*code ;if !_bba {_agd =_ded ._de ;}else {_agd =_ded ._gc ;};_abb ,_ada =_dec .uncompressGetCode (_agd );if _ada !=nil {return 0,_ada ;};if _abb ==nil {break _ddf ;};_dec ._eccb +=_abb ._gb ;if _abb ._ee < 64{if _abb ._ee < 0{_aedd [_aba ]=_afc ;_aba ++;break _ddf ;};_afc +=_abb ._ee ;if _afc < _ged ||_afc !=_efc {_aedd [_aba ]=_afc ;_aba ++;};break _adab ;};_afc +=_abb ._ee ;};for _afc < _ged &&_ced [_dda ]<=_afc {_dda +=2;};continue _ddf ;case _aef :_dda ++;_afc =_ced [_dda ];_dda ++;continue _ddf ;case _ag :_afc =_ced [_dda ]+2;case _ab :_afc =_ced [_dda ]-2;case _eea :_afc =_ced [_dda ]+3;case _bf :_afc =_ced [_dda ]-3;default:if _dec ._eccb ==12&&_abb ._ee ==EOL {_dec ._eccb =0;if _ ,_ada =_ded .uncompress1d (_dec ,_ced ,_ged );_ada !=nil {return 0,_ada ;};_dec ._eccb ++;if _ ,_ada =_ded .uncompress1d (_dec ,_aedd ,_ged );_ada !=nil {return 0,_ada ;};_ead ,_eda :=_ded .uncompress1d (_dec ,_ced ,_ged );if _eda !=nil {return EOF ,_eda ;};_dec ._eccb ++;return _ead ,nil ;};_afc =_ged ;continue _ddf ;};if _afc <=_ged {_bba =!_bba ;_aedd [_aba ]=_afc ;_aba ++;if _dda > 0{_dda --;}else {_dda ++;};for _afc < _ged &&_ced [_dda ]<=_afc {_dda +=2;};};};if _aedd [_aba ]!=_ged {_aedd [_aba ]=_ged ;};if _abb ==nil {return EOL ,nil ;};return _aba ,nil ;};func _df (_dea *_a .SubstreamReader )(*runData ,error ){_agf :=&runData {_ecd :_dea ,_eccb :0,_dee :1};_dcc :=_d (_gg (_aag ,int (_dea .Length ())),_gca );_agf ._ccaa =make ([]byte ,_dcc );if _ddb :=_agf .fillBuffer (0);_ddb !=nil {if _ddb ==_eg .EOF {_agf ._ccaa =make ([]byte ,10);_ac .Log .Debug ("F\u0069\u006c\u006c\u0042uf\u0066e\u0072\u0020\u0066\u0061\u0069l\u0065\u0064\u003a\u0020\u0025\u0076",_ddb );}else {return nil ,_ddb ;};};return _agf ,nil ;};func (_dbb *runData )uncompressGetCodeLittleEndian (_cge []*code )(*code ,error ){_cd ,_afd :=_dbb .uncompressGetNextCodeLittleEndian ();if _afd !=nil {_ac .Log .Debug ("\u0055n\u0063\u006fm\u0070\u0072\u0065\u0073s\u0047\u0065\u0074N\u0065\u0078\u0074\u0043\u006f\u0064\u0065\u004c\u0069tt\u006c\u0065\u0045n\u0064\u0069a\u006e\u0020\u0066\u0061\u0069\u006ce\u0064\u003a \u0025\u0076",_afd );return nil ,_afd ;};_cd &=0xffffff;_fbb :=_cd >>(_fg -_egc );_ffbd :=_cge [_fbb ];if _ffbd !=nil &&_ffbd ._f {_fbb =(_cd >>(_fg -_egc -_fc ))&_cc ;_ffbd =_ffbd ._bg [_fbb ];};return _ffbd ,nil ;};type mmrCode int ;func (_gbc *code )String ()string {return _c .Sprintf ("\u0025\u0064\u002f\u0025\u0064\u002f\u0025\u0064",_gbc ._gb ,_gbc ._gf ,_gbc ._ee );};var (_feg =[][3]int {{4,0x1,int (_aef )},{3,0x1,int (_fa )},{1,0x1,int (_fb )},{3,0x3,int (_ed )},{6,0x3,int (_ag )},{7,0x3,int (_eea )},{3,0x2,int (_ba )},{6,0x2,int (_ab )},{7,0x2,int (_bf )},{10,0xf,int (_ea )},{12,0xf,int (_gd )},{12,0x1,int (EOL )}};_ad =[][3]int {{4,0x07,2},{4,0x08,3},{4,0x0B,4},{4,0x0C,5},{4,0x0E,6},{4,0x0F,7},{5,0x12,128},{5,0x13,8},{5,0x14,9},{5,0x1B,64},{5,0x07,10},{5,0x08,11},{6,0x17,192},{6,0x18,1664},{6,0x2A,16},{6,0x2B,17},{6,0x03,13},{6,0x34,14},{6,0x35,15},{6,0x07,1},{6,0x08,12},{7,0x13,26},{7,0x17,21},{7,0x18,28},{7,0x24,27},{7,0x27,18},{7,0x28,24},{7,0x2B,25},{7,0x03,22},{7,0x37,256},{7,0x04,23},{7,0x08,20},{7,0xC,19},{8,0x12,33},{8,0x13,34},{8,0x14,35},{8,0x15,36},{8,0x16,37},{8,0x17,38},{8,0x1A,31},{8,0x1B,32},{8,0x02,29},{8,0x24,53},{8,0x25,54},{8,0x28,39},{8,0x29,40},{8,0x2A,41},{8,0x2B,42},{8,0x2C,43},{8,0x2D,44},{8,0x03,30},{8,0x32,61},{8,0x33,62},{8,0x34,63},{8,0x35,0},{8,0x36,320},{8,0x37,384},{8,0x04,45},{8,0x4A,59},{8,0x4B,60},{8,0x5,46},{8,0x52,49},{8,0x53,50},{8,0x54,51},{8,0x55,52},{8,0x58,55},{8,0x59,56},{8,0x5A,57},{8,0x5B,58},{8,0x64,448},{8,0x65,512},{8,0x67,640},{8,0x68,576},{8,0x0A,47},{8,0x0B,48},{9,0x01,_aed },{9,0x98,1472},{9,0x99,1536},{9,0x9A,1600},{9,0x9B,1728},{9,0xCC,704},{9,0xCD,768},{9,0xD2,832},{9,0xD3,896},{9,0xD4,960},{9,0xD5,1024},{9,0xD6,1088},{9,0xD7,1152},{9,0xD8,1216},{9,0xD9,1280},{9,0xDA,1344},{9,0xDB,1408},{10,0x01,_aed },{11,0x01,_aed },{11,0x08,1792},{11,0x0C,1856},{11,0x0D,1920},{12,0x00,EOF },{12,0x01,EOL },{12,0x12,1984},{12,0x13,2048},{12,0x14,2112},{12,0x15,2176},{12,0x16,2240},{12,0x17,2304},{12,0x1C,2368},{12,0x1D,2432},{12,0x1E,2496},{12,0x1F,2560}};_edf =[][3]int {{2,0x02,3},{2,0x03,2},{3,0x02,1},{3,0x03,4},{4,0x02,6},{4,0x03,5},{5,0x03,7},{6,0x04,9},{6,0x05,8},{7,0x04,10},{7,0x05,11},{7,0x07,12},{8,0x04,13},{8,0x07,14},{9,0x01,_aed },{9,0x18,15},{10,0x01,_aed },{10,0x17,16},{10,0x18,17},{10,0x37,0},{10,0x08,18},{10,0x0F,64},{11,0x01,_aed },{11,0x17,24},{11,0x18,25},{11,0x28,23},{11,0x37,22},{11,0x67,19},{11,0x68,20},{11,0x6C,21},{11,0x08,1792},{11,0x0C,1856},{11,0x0D,1920},{12,0x00,EOF },{12,0x01,EOL },{12,0x12,1984},{12,0x13,2048},{12,0x14,2112},{12,0x15,2176},{12,0x16,2240},{12,0x17,2304},{12,0x1C,2368},{12,0x1D,2432},{12,0x1E,2496},{12,0x1F,2560},{12,0x24,52},{12,0x27,55},{12,0x28,56},{12,0x2B,59},{12,0x2C,60},{12,0x33,320},{12,0x34,384},{12,0x35,448},{12,0x37,53},{12,0x38,54},{12,0x52,50},{12,0x53,51},{12,0x54,44},{12,0x55,45},{12,0x56,46},{12,0x57,47},{12,0x58,57},{12,0x59,58},{12,0x5A,61},{12,0x5B,256},{12,0x64,48},{12,0x65,49},{12,0x66,62},{12,0x67,63},{12,0x68,30},{12,0x69,31},{12,0x6A,32},{12,0x6B,33},{12,0x6C,40},{12,0x6D,41},{12,0xC8,128},{12,0xC9,192},{12,0xCA,26},{12,0xCB,27},{12,0xCC,28},{12,0xCD,29},{12,0xD2,34},{12,0xD3,35},{12,0xD4,36},{12,0xD5,37},{12,0xD6,38},{12,0xD7,39},{12,0xDA,42},{12,0xDB,43},{13,0x4A,640},{13,0x4B,704},{13,0x4C,768},{13,0x4D,832},{13,0x52,1280},{13,0x53,1344},{13,0x54,1408},{13,0x55,1472},{13,0x5A,1536},{13,0x5B,1600},{13,0x64,1664},{13,0x65,1728},{13,0x6C,512},{13,0x6D,576},{13,0x72,896},{13,0x73,960},{13,0x74,1024},{13,0x75,1088},{13,0x76,1152},{13,0x77,1216}};);func (_aceb *runData )uncompressGetNextCodeLittleEndian ()(int ,error ){_ffa :=_aceb ._eccb -_aceb ._dee ;if _ffa < 0||_ffa > 24{_fde :=(_aceb ._eccb >>3)-_aceb ._bae ;if _fde >=_aceb ._gbb {_fde +=_aceb ._bae ;if _dcb :=_aceb .fillBuffer (_fde );_dcb !=nil {return 0,_dcb ;};_fde -=_aceb ._bae ;};_deg :=(uint32 (_aceb ._ccaa [_fde ]&0xFF)<<16)|(uint32 (_aceb ._ccaa [_fde +1]&0xFF)<<8)|(uint32 (_aceb ._ccaa [_fde +2]&0xFF));_efd :=uint32 (_aceb ._eccb &7);_deg <<=_efd ;_aceb ._cfg =int (_deg );}else {_ccf :=_aceb ._dee &7;_eef :=7-_ccf ;if _ffa <=_eef {_aceb ._cfg <<=uint (_ffa );}else {_gcg :=(_aceb ._dee >>3)+3-_aceb ._bae ;if _gcg >=_aceb ._gbb {_gcg +=_aceb ._bae ;if _eab :=_aceb .fillBuffer (_gcg );_eab !=nil {return 0,_eab ;};_gcg -=_aceb ._bae ;};_ccf =8-_ccf ;for {_aceb ._cfg <<=uint (_ccf );_aceb ._cfg |=int (uint (_aceb ._ccaa [_gcg ])&0xFF);_ffa -=_ccf ;_gcg ++;_ccf =8;if !(_ffa >=8){break ;};};_aceb ._cfg <<=uint (_ffa );};};_aceb ._dee =_aceb ._eccb ;return _aceb ._cfg ,nil ;};func (_bfb *Decoder )initTables ()(_gde error ){if _bfb ._de ==nil {_bfb ._de ,_gde =_bfb .createLittleEndianTable (_ad );if _gde !=nil {return ;};_bfb ._gc ,_gde =_bfb .createLittleEndianTable (_edf );if _gde !=nil {return ;};_bfb ._bb ,_gde =_bfb .createLittleEndianTable (_feg );if _gde !=nil {return ;};};return nil ;};func _gg (_aa ,_fe int )int {if _aa < _fe {return _fe ;};return _aa ;};const (_gca int =1024<<7;_aag int =3;_fg uint =24;);func (_bfd *Decoder )createLittleEndianTable (_fce [][3]int )([]*code ,error ){_dd :=make ([]*code ,_ace +1);for _edd :=0;_edd < len (_fce );_edd ++{_ec :=_ge (_fce [_edd ]);if _ec ._gb <=_egc {_db :=_egc -_ec ._gb ;_fbc :=_ec ._gf <<uint (_db );for _fbcc :=(1<<uint (_db ))-1;_fbcc >=0;_fbcc --{_eaa :=_fbc |_fbcc ;_dd [_eaa ]=_ec ;};}else {_dcf :=_ec ._gf >>uint (_ec ._gb -_egc );if _dd [_dcf ]==nil {var _gad =_ge ([3]int {});_gad ._bg =make ([]*code ,_cc +1);_dd [_dcf ]=_gad ;};if _ec ._gb <=_egc +_fc {_ca :=_egc +_fc -_ec ._gb ;_ccc :=(_ec ._gf <<uint (_ca ))&_cc ;_dd [_dcf ]._f =true ;for _acd :=(1<<uint (_ca ))-1;_acd >=0;_acd --{_dd [_dcf ]._bg [_ccc |_acd ]=_ec ;};}else {return nil ,_b .New ("\u0043\u006f\u0064\u0065\u0020\u0074a\u0062\u006c\u0065\u0020\u006f\u0076\u0065\u0072\u0066\u006c\u006f\u0077\u0020i\u006e\u0020\u004d\u004d\u0052\u0044\u0065c\u006f\u0064\u0065\u0072");};};};return _dd ,nil ;};func (_fdb *runData )fillBuffer (_eeb int )error {_fdb ._bae =_eeb ;_ ,_cdf :=_fdb ._ecd .Seek (int64 (_eeb ),_eg .SeekStart );if _cdf !=nil {if _cdf ==_eg .EOF {_ac .Log .Debug ("\u0053\u0065\u0061\u006b\u0020\u0045\u004f\u0046");_fdb ._gbb =-1;}else {return _cdf ;};};if _cdf ==nil {_fdb ._gbb ,_cdf =_fdb ._ecd .Read (_fdb ._ccaa );if _cdf !=nil {if _cdf ==_eg .EOF {_ac .Log .Trace ("\u0052\u0065\u0061\u0064\u0020\u0045\u004f\u0046");_fdb ._gbb =-1;}else {return _cdf ;};};};if _fdb ._gbb > -1&&_fdb ._gbb < 3{for _fdb ._gbb < 3{_cea ,_eebc :=_fdb ._ecd .ReadByte ();if _eebc !=nil {if _eebc ==_eg .EOF {_fdb ._ccaa [_fdb ._gbb ]=0;}else {return _eebc ;};}else {_fdb ._ccaa [_fdb ._gbb ]=_cea &0xFF;};_fdb ._gbb ++;};};_fdb ._gbb -=3;if _fdb ._gbb < 0{_fdb ._ccaa =make ([]byte ,len (_fdb ._ccaa ));_fdb ._gbb =len (_fdb ._ccaa )-3;};return nil ;};type code struct{_gb int ;_gf int ;_ee int ;_bg []*code ;_f bool ;};func New (r _a .StreamReader ,width ,height int ,dataOffset ,dataLength int64 )(*Decoder ,error ){_gbe :=&Decoder {_dc :width ,_fba :height };_gfb ,_bc :=_a .NewSubstreamReader (r ,uint64 (dataOffset ),uint64 (dataLength ));if _bc !=nil {return nil ,_bc ;};_af ,_bc :=_df (_gfb );if _bc !=nil {return nil ,_bc ;};_gbe ._da =_af ;if _ccg :=_gbe .initTables ();_ccg !=nil {return nil ,_ccg ;};return _gbe ,nil ;};type runData struct{_ecd *_a .SubstreamReader ;_eccb int ;_dee int ;_cfg int ;_ccaa []byte ;_bae int ;_gbb int ;};func (_acg *Decoder )uncompress1d (_bcb *runData ,_cf []int ,_cga int )(int ,error ){var (_dde =true ;_bff int ;_abf *code ;_eddb int ;_cca error ;);_daa :for _bff < _cga {_bd :for {if _dde {_abf ,_cca =_bcb .uncompressGetCode (_acg ._de );if _cca !=nil {return 0,_cca ;};}else {_abf ,_cca =_bcb .uncompressGetCode (_acg ._gc );if _cca !=nil {return 0,_cca ;};};_bcb ._eccb +=_abf ._gb ;if _abf ._ee < 0{break _daa ;};_bff +=_abf ._ee ;if _abf ._ee < 64{_dde =!_dde ;_cf [_eddb ]=_bff ;_eddb ++;break _bd ;};};};if _cf [_eddb ]!=_cga {_cf [_eddb ]=_cga ;};_bfg :=EOL ;if _abf !=nil &&_abf ._ee !=EOL {_bfg =_eddb ;};return _bfg ,nil ;};const (EOF =-3;_aed =-2;EOL =-1;_egc =8;_ace =(1<<_egc )-1;_fc =5;_cc =(1<<_fc )-1;);func _d (_eeg ,_cg int )int {if _eeg > _cg {return _cg ;};return _eeg ;};func (_cec *runData )align (){_cec ._eccb =((_cec ._eccb +7)>>3)<<3};