//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package mmr ;import (_g "errors";_ea "fmt";_bc "github.com/unidoc/unipdf/v3/common";_ef "github.com/unidoc/unipdf/v3/internal/bitwise";_f "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_b "io";);type code struct{_gg int ;_ba int ;_a int ;_bcb []*code ;_ga bool ;};type mmrCode int ;func _df (_c ,_bg int )int {if _c < _bg {return _bg ;};return _c ;};func _gf (_eb ,_cb int )int {if _eb > _cb {return _cb ;};return _eb ;};func (_gga *Decoder )uncompress2d (_aed *runData ,_cge []int ,_eef int ,_bdb []int ,_cggf int )(int ,error ){var (_fbg int ;_deg int ;_fff int ;_agf =true ;_fec error ;_fd *code ;);_cge [_eef ]=_cggf ;_cge [_eef +1]=_cggf ;_cge [_eef +2]=_cggf +1;_cge [_eef +3]=_cggf +1;_gffe :for _fff < _cggf {_fd ,_fec =_aed .uncompressGetCode (_gga ._edc );if _fec !=nil {return EOL ,nil ;};if _fd ==nil {_aed ._bef ++;break _gffe ;};_aed ._bef +=_fd ._gg ;switch mmrCode (_fd ._a ){case _dd :_fff =_cge [_fbg ];case _ddb :_fff =_cge [_fbg ]+1;case _eg :_fff =_cge [_fbg ]-1;case _eaa :_edg :=1;for _edg > 0{var _ged []*code ;if _agf {_ged =_gga ._cg ;}else {_ged =_gga ._ce ;};_fd ,_fec =_aed .uncompressGetCode (_ged );if _fec !=nil {return 0,_fec ;};if _fd ==nil {break _gffe ;};_aed ._bef +=_fd ._gg ;if _fd ._a < 64{if _fd ._a < 0{_bdb [_deg ]=_fff ;_deg ++;_fd =nil ;break _gffe ;};_fff +=_fd ._a ;_bdb [_deg ]=_fff ;_deg ++;break ;};_fff +=_fd ._a ;};_gcg :=_fff ;_ccg :=1;_gdc :for _ccg > 0{var _daa []*code ;if !_agf {_daa =_gga ._cg ;}else {_daa =_gga ._ce ;};_fd ,_fec =_aed .uncompressGetCode (_daa );if _fec !=nil {return 0,_fec ;};if _fd ==nil {break _gffe ;};_aed ._bef +=_fd ._gg ;if _fd ._a < 64{if _fd ._a < 0{_bdb [_deg ]=_fff ;_deg ++;break _gffe ;};_fff +=_fd ._a ;if _fff < _cggf ||_fff !=_gcg {_bdb [_deg ]=_fff ;_deg ++;};break _gdc ;};_fff +=_fd ._a ;};for _fff < _cggf &&_cge [_fbg ]<=_fff {_fbg +=2;};continue _gffe ;case _eae :_fbg ++;_fff =_cge [_fbg ];_fbg ++;continue _gffe ;case _efb :_fff =_cge [_fbg ]+2;case _bgc :_fff =_cge [_fbg ]-2;case _bdd :_fff =_cge [_fbg ]+3;case _cc :_fff =_cge [_fbg ]-3;default:if _aed ._bef ==12&&_fd ._a ==EOL {_aed ._bef =0;if _ ,_fec =_gga .uncompress1d (_aed ,_cge ,_cggf );_fec !=nil {return 0,_fec ;};_aed ._bef ++;if _ ,_fec =_gga .uncompress1d (_aed ,_bdb ,_cggf );_fec !=nil {return 0,_fec ;};_fcfg ,_eac :=_gga .uncompress1d (_aed ,_cge ,_cggf );if _eac !=nil {return EOF ,_eac ;};_aed ._bef ++;return _fcfg ,nil ;};_fff =_cggf ;continue _gffe ;};if _fff <=_cggf {_agf =!_agf ;_bdb [_deg ]=_fff ;_deg ++;if _fbg > 0{_fbg --;}else {_fbg ++;};for _fff < _cggf &&_cge [_fbg ]<=_fff {_fbg +=2;};};};if _bdb [_deg ]!=_cggf {_bdb [_deg ]=_cggf ;};if _fd ==nil {return EOL ,nil ;};return _deg ,nil ;};func (_ae *Decoder )detectAndSkipEOL ()error {for {_dgg ,_fb :=_ae ._bf .uncompressGetCode (_ae ._edc );if _fb !=nil {return _fb ;};if _dgg !=nil &&_dgg ._a ==EOL {_ae ._bf ._bef +=_dgg ._gg ;}else {return nil ;};};};func (_aba *runData )fillBuffer (_dad int )error {_aba ._dbg =_dad ;_ ,_cfg :=_aba ._db .Seek (int64 (_dad ),_b .SeekStart );if _cfg !=nil {if _cfg ==_b .EOF {_bc .Log .Debug ("\u0053\u0065\u0061\u006b\u0020\u0045\u004f\u0046");_aba ._fag =-1;}else {return _cfg ;};};if _cfg ==nil {_aba ._fag ,_cfg =_aba ._db .Read (_aba ._afc );if _cfg !=nil {if _cfg ==_b .EOF {_bc .Log .Trace ("\u0052\u0065\u0061\u0064\u0020\u0045\u004f\u0046");_aba ._fag =-1;}else {return _cfg ;};};};if _aba ._fag > -1&&_aba ._fag < 3{for _aba ._fag < 3{_degc ,_efg :=_aba ._db .ReadByte ();if _efg !=nil {if _efg ==_b .EOF {_aba ._afc [_aba ._fag ]=0;}else {return _efg ;};}else {_aba ._afc [_aba ._fag ]=_degc &0xFF;};_aba ._fag ++;};};_aba ._fag -=3;if _aba ._fag < 0{_aba ._afc =make ([]byte ,len (_aba ._afc ));_aba ._fag =len (_aba ._afc )-3;};return nil ;};type runData struct{_db *_ef .SubstreamReader ;_bef int ;_gcf int ;_bgb int ;_afc []byte ;_dbg int ;_fag int ;};var (_ca =[][3]int {{4,0x1,int (_eae )},{3,0x1,int (_eaa )},{1,0x1,int (_dd )},{3,0x3,int (_ddb )},{6,0x3,int (_efb )},{7,0x3,int (_bdd )},{3,0x2,int (_eg )},{6,0x2,int (_bgc )},{7,0x2,int (_cc )},{10,0xf,int (_dg )},{12,0xf,int (_egb )},{12,0x1,int (EOL )}};_ed =[][3]int {{4,0x07,2},{4,0x08,3},{4,0x0B,4},{4,0x0C,5},{4,0x0E,6},{4,0x0F,7},{5,0x12,128},{5,0x13,8},{5,0x14,9},{5,0x1B,64},{5,0x07,10},{5,0x08,11},{6,0x17,192},{6,0x18,1664},{6,0x2A,16},{6,0x2B,17},{6,0x03,13},{6,0x34,14},{6,0x35,15},{6,0x07,1},{6,0x08,12},{7,0x13,26},{7,0x17,21},{7,0x18,28},{7,0x24,27},{7,0x27,18},{7,0x28,24},{7,0x2B,25},{7,0x03,22},{7,0x37,256},{7,0x04,23},{7,0x08,20},{7,0xC,19},{8,0x12,33},{8,0x13,34},{8,0x14,35},{8,0x15,36},{8,0x16,37},{8,0x17,38},{8,0x1A,31},{8,0x1B,32},{8,0x02,29},{8,0x24,53},{8,0x25,54},{8,0x28,39},{8,0x29,40},{8,0x2A,41},{8,0x2B,42},{8,0x2C,43},{8,0x2D,44},{8,0x03,30},{8,0x32,61},{8,0x33,62},{8,0x34,63},{8,0x35,0},{8,0x36,320},{8,0x37,384},{8,0x04,45},{8,0x4A,59},{8,0x4B,60},{8,0x5,46},{8,0x52,49},{8,0x53,50},{8,0x54,51},{8,0x55,52},{8,0x58,55},{8,0x59,56},{8,0x5A,57},{8,0x5B,58},{8,0x64,448},{8,0x65,512},{8,0x67,640},{8,0x68,576},{8,0x0A,47},{8,0x0B,48},{9,0x01,_fg },{9,0x98,1472},{9,0x99,1536},{9,0x9A,1600},{9,0x9B,1728},{9,0xCC,704},{9,0xCD,768},{9,0xD2,832},{9,0xD3,896},{9,0xD4,960},{9,0xD5,1024},{9,0xD6,1088},{9,0xD7,1152},{9,0xD8,1216},{9,0xD9,1280},{9,0xDA,1344},{9,0xDB,1408},{10,0x01,_fg },{11,0x01,_fg },{11,0x08,1792},{11,0x0C,1856},{11,0x0D,1920},{12,0x00,EOF },{12,0x01,EOL },{12,0x12,1984},{12,0x13,2048},{12,0x14,2112},{12,0x15,2176},{12,0x16,2240},{12,0x17,2304},{12,0x1C,2368},{12,0x1D,2432},{12,0x1E,2496},{12,0x1F,2560}};_ega =[][3]int {{2,0x02,3},{2,0x03,2},{3,0x02,1},{3,0x03,4},{4,0x02,6},{4,0x03,5},{5,0x03,7},{6,0x04,9},{6,0x05,8},{7,0x04,10},{7,0x05,11},{7,0x07,12},{8,0x04,13},{8,0x07,14},{9,0x01,_fg },{9,0x18,15},{10,0x01,_fg },{10,0x17,16},{10,0x18,17},{10,0x37,0},{10,0x08,18},{10,0x0F,64},{11,0x01,_fg },{11,0x17,24},{11,0x18,25},{11,0x28,23},{11,0x37,22},{11,0x67,19},{11,0x68,20},{11,0x6C,21},{11,0x08,1792},{11,0x0C,1856},{11,0x0D,1920},{12,0x00,EOF },{12,0x01,EOL },{12,0x12,1984},{12,0x13,2048},{12,0x14,2112},{12,0x15,2176},{12,0x16,2240},{12,0x17,2304},{12,0x1C,2368},{12,0x1D,2432},{12,0x1E,2496},{12,0x1F,2560},{12,0x24,52},{12,0x27,55},{12,0x28,56},{12,0x2B,59},{12,0x2C,60},{12,0x33,320},{12,0x34,384},{12,0x35,448},{12,0x37,53},{12,0x38,54},{12,0x52,50},{12,0x53,51},{12,0x54,44},{12,0x55,45},{12,0x56,46},{12,0x57,47},{12,0x58,57},{12,0x59,58},{12,0x5A,61},{12,0x5B,256},{12,0x64,48},{12,0x65,49},{12,0x66,62},{12,0x67,63},{12,0x68,30},{12,0x69,31},{12,0x6A,32},{12,0x6B,33},{12,0x6C,40},{12,0x6D,41},{12,0xC8,128},{12,0xC9,192},{12,0xCA,26},{12,0xCB,27},{12,0xCC,28},{12,0xCD,29},{12,0xD2,34},{12,0xD3,35},{12,0xD4,36},{12,0xD5,37},{12,0xD6,38},{12,0xD7,39},{12,0xDA,42},{12,0xDB,43},{13,0x4A,640},{13,0x4B,704},{13,0x4C,768},{13,0x4D,832},{13,0x52,1280},{13,0x53,1344},{13,0x54,1408},{13,0x55,1472},{13,0x5A,1536},{13,0x5B,1600},{13,0x64,1664},{13,0x65,1728},{13,0x6C,512},{13,0x6D,576},{13,0x72,896},{13,0x73,960},{13,0x74,1024},{13,0x75,1088},{13,0x76,1152},{13,0x77,1216}};);func (_bbb *runData )uncompressGetNextCodeLittleEndian ()(int ,error ){_aaa :=_bbb ._bef -_bbb ._gcf ;if _aaa < 0||_aaa > 24{_fea :=(_bbb ._bef >>3)-_bbb ._dbg ;if _fea >=_bbb ._fag {_fea +=_bbb ._dbg ;if _bec :=_bbb .fillBuffer (_fea );_bec !=nil {return 0,_bec ;};_fea -=_bbb ._dbg ;};_aae :=(uint32 (_bbb ._afc [_fea ]&0xFF)<<16)|(uint32 (_bbb ._afc [_fea +1]&0xFF)<<8)|(uint32 (_bbb ._afc [_fea +2]&0xFF));_dbf :=uint32 (_bbb ._bef &7);_aae <<=_dbf ;_bbb ._bgb =int (_aae );}else {_fac :=_bbb ._gcf &7;_cdb :=7-_fac ;if _aaa <=_cdb {_bbb ._bgb <<=uint (_aaa );}else {_beb :=(_bbb ._gcf >>3)+3-_bbb ._dbg ;if _beb >=_bbb ._fag {_beb +=_bbb ._dbg ;if _ccd :=_bbb .fillBuffer (_beb );_ccd !=nil {return 0,_ccd ;};_beb -=_bbb ._dbg ;};_fac =8-_fac ;for {_bbb ._bgb <<=uint (_fac );_bbb ._bgb |=int (uint (_bbb ._afc [_beb ])&0xFF);_aaa -=_fac ;_beb ++;_fac =8;if !(_aaa >=8){break ;};};_bbb ._bgb <<=uint (_aaa );};};_bbb ._gcf =_bbb ._bef ;return _bbb ._bgb ,nil ;};func _d (_ge [3]int )*code {return &code {_gg :_ge [0],_ba :_ge [1],_a :_ge [2]}};type Decoder struct{_bb ,_af int ;_bf *runData ;_cg []*code ;_ce []*code ;_edc []*code ;};const (_ddbb int =1024<<7;_fgg int =3;_bed uint =24;);func (_da *Decoder )UncompressMMR ()(_gfe *_f .Bitmap ,_fc error ){_gfe =_f .New (_da ._bb ,_da ._af );_fef :=make ([]int ,_gfe .Width +5);_dgcc :=make ([]int ,_gfe .Width +5);_dgcc [0]=_gfe .Width ;_gge :=1;var _eaf int ;for _fcf :=0;_fcf < _gfe .Height ;_fcf ++{_eaf ,_fc =_da .uncompress2d (_da ._bf ,_dgcc ,_gge ,_fef ,_gfe .Width );if _fc !=nil {return nil ,_fc ;};if _eaf ==EOF {break ;};if _eaf > 0{_fc =_da .fillBitmap (_gfe ,_fcf ,_fef ,_eaf );if _fc !=nil {return nil ,_fc ;};};_dgcc ,_fef =_fef ,_dgcc ;_gge =_eaf ;};if _fc =_da .detectAndSkipEOL ();_fc !=nil {return nil ,_fc ;};_da ._bf .align ();return _gfe ,nil ;};func New (r _ef .StreamReader ,width ,height int ,dataOffset ,dataLength int64 )(*Decoder ,error ){_gcb :=&Decoder {_bb :width ,_af :height };_dgc ,_bddb :=_ef .NewSubstreamReader (r ,uint64 (dataOffset ),uint64 (dataLength ));if _bddb !=nil {return nil ,_bddb ;};_fa ,_bddb :=_aa (_dgc );if _bddb !=nil {return nil ,_bddb ;};_gcb ._bf =_fa ;if _gb :=_gcb .initTables ();_gb !=nil {return nil ,_gb ;};return _gcb ,nil ;};func _aa (_dfa *_ef .SubstreamReader )(*runData ,error ){_gfb :=&runData {_db :_dfa ,_bef :0,_gcf :1};_aca :=_gf (_df (_fgg ,int (_dfa .Length ())),_ddbb );_gfb ._afc =make ([]byte ,_aca );if _cd :=_gfb .fillBuffer (0);_cd !=nil {if _cd ==_b .EOF {_gfb ._afc =make ([]byte ,10);_bc .Log .Debug ("F\u0069\u006c\u006c\u0042uf\u0066e\u0072\u0020\u0066\u0061\u0069l\u0065\u0064\u003a\u0020\u0025\u0076",_cd );}else {return nil ,_cd ;};};return _gfb ,nil ;};const (EOF =-3;_fg =-2;EOL =-1;_cf =8;_fe =(1<<_cf )-1;_gc =5;_dfc =(1<<_gc )-1;);func (_ff *Decoder )createLittleEndianTable (_bag [][3]int )([]*code ,error ){_bcg :=make ([]*code ,_fe +1);for _cgg :=0;_cgg < len (_bag );_cgg ++{_ccc :=_d (_bag [_cgg ]);if _ccc ._gg <=_cf {_ad :=_cf -_ccc ._gg ;_ab :=_ccc ._ba <<uint (_ad );for _gae :=(1<<uint (_ad ))-1;_gae >=0;_gae --{_gd :=_ab |_gae ;_bcg [_gd ]=_ccc ;};}else {_cac :=_ccc ._ba >>uint (_ccc ._gg -_cf );if _bcg [_cac ]==nil {var _baa =_d ([3]int {});_baa ._bcb =make ([]*code ,_dfc +1);_bcg [_cac ]=_baa ;};if _ccc ._gg <=_cf +_gc {_afb :=_cf +_gc -_ccc ._gg ;_fga :=(_ccc ._ba <<uint (_afb ))&_dfc ;_bcg [_cac ]._ga =true ;for _egc :=(1<<uint (_afb ))-1;_egc >=0;_egc --{_bcg [_cac ]._bcb [_fga |_egc ]=_ccc ;};}else {return nil ,_g .New ("\u0043\u006f\u0064\u0065\u0020\u0074a\u0062\u006c\u0065\u0020\u006f\u0076\u0065\u0072\u0066\u006c\u006f\u0077\u0020i\u006e\u0020\u004d\u004d\u0052\u0044\u0065c\u006f\u0064\u0065\u0072");};};};return _bcg ,nil ;};func (_egf *runData )uncompressGetCode (_agb []*code )(*code ,error ){return _egf .uncompressGetCodeLittleEndian (_agb );};func (_ccce *runData )uncompressGetCodeLittleEndian (_dde []*code )(*code ,error ){_ddeg ,_cfd :=_ccce .uncompressGetNextCodeLittleEndian ();if _cfd !=nil {_bc .Log .Debug ("\u0055n\u0063\u006fm\u0070\u0072\u0065\u0073s\u0047\u0065\u0074N\u0065\u0078\u0074\u0043\u006f\u0064\u0065\u004c\u0069tt\u006c\u0065\u0045n\u0064\u0069a\u006e\u0020\u0066\u0061\u0069\u006ce\u0064\u003a \u0025\u0076",_cfd );return nil ,_cfd ;};_ddeg &=0xffffff;_baed :=_ddeg >>(_bed -_cf );_fdb :=_dde [_baed ];if _fdb !=nil &&_fdb ._ga {_baed =(_ddeg >>(_bed -_cf -_gc ))&_dfc ;_fdb =_fdb ._bcb [_baed ];};return _fdb ,nil ;};func (_fefd *runData )align (){_fefd ._bef =((_fefd ._bef +7)>>3)<<3};const (_eae mmrCode =iota ;_eaa ;_dd ;_ddb ;_efb ;_bdd ;_eg ;_bgc ;_cc ;_dg ;_egb ;);func (_adf *Decoder )uncompress1d (_bge *runData ,_ec []int ,_de int )(int ,error ){var (_caf =true ;_abf int ;_fcg *code ;_cad int ;_geg error ;);_ecd :for _abf < _de {_ac :for {if _caf {_fcg ,_geg =_bge .uncompressGetCode (_adf ._cg );if _geg !=nil {return 0,_geg ;};}else {_fcg ,_geg =_bge .uncompressGetCode (_adf ._ce );if _geg !=nil {return 0,_geg ;};};_bge ._bef +=_fcg ._gg ;if _fcg ._a < 0{break _ecd ;};_abf +=_fcg ._a ;if _fcg ._a < 64{_caf =!_caf ;_ec [_cad ]=_abf ;_cad ++;break _ac ;};};};if _ec [_cad ]!=_de {_ec [_cad ]=_de ;};_ece :=EOL ;if _fcg !=nil &&_fcg ._a !=EOL {_ece =_cad ;};return _ece ,nil ;};func (_bd *code )String ()string {return _ea .Sprintf ("\u0025\u0064\u002f\u0025\u0064\u002f\u0025\u0064",_bd ._gg ,_bd ._ba ,_bd ._a );};func (_dfb *Decoder )initTables ()(_gff error ){if _dfb ._cg ==nil {_dfb ._cg ,_gff =_dfb .createLittleEndianTable (_ed );if _gff !=nil {return ;};_dfb ._ce ,_gff =_dfb .createLittleEndianTable (_ega );if _gff !=nil {return ;};_dfb ._edc ,_gff =_dfb .createLittleEndianTable (_ca );if _gff !=nil {return ;};};return nil ;};func (_dge *Decoder )fillBitmap (_be *_f .Bitmap ,_aeb int ,_abe []int ,_ag int )error {var _efc byte ;_gdg :=0;_ebb :=_be .GetByteIndex (_gdg ,_aeb );for _ddbe :=0;_ddbe < _ag ;_ddbe ++{_bfe :=byte (1);_ee :=_abe [_ddbe ];if (_ddbe &1)==0{_bfe =0;};for _gdg < _ee {_efc =(_efc <<1)|_bfe ;_gdg ++;if (_gdg &7)==0{if _fgd :=_be .SetByte (_ebb ,_efc );_fgd !=nil {return _fgd ;};_ebb ++;_efc =0;};};};if (_gdg &7)!=0{_efc <<=uint (8-(_gdg &7));if _bae :=_be .SetByte (_ebb ,_efc );_bae !=nil {return _bae ;};};return nil ;};