//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package mmr ;import (_e "errors";_c "fmt";_af "github.com/unidoc/unipdf/v3/common";_a "github.com/unidoc/unipdf/v3/internal/bitwise";_cf "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_d "io";);func (_cd *Decoder )createLittleEndianTable (_dc [][3]int )([]*code ,error ){_beb :=make ([]*code ,_ed +1);
for _bc :=0;_bc < len (_dc );_bc ++{_cde :=_gb (_dc [_bc ]);if _cde ._cfa <=_fa {_fb :=_fa -_cde ._cfa ;_cda :=_cde ._b <<uint (_fb );for _faac :=(1<<uint (_fb ))-1;_faac >=0;_faac --{_bea :=_cda |_faac ;_beb [_bea ]=_cde ;};}else {_gf :=_cde ._b >>uint (_cde ._cfa -_fa );
if _beb [_gf ]==nil {var _afc =_gb ([3]int {});_afc ._eg =make ([]*code ,_ac +1);_beb [_gf ]=_afc ;};if _cde ._cfa <=_fa +_ff {_cb :=_fa +_ff -_cde ._cfa ;_fg :=(_cde ._b <<uint (_cb ))&_ac ;_beb [_gf ]._ea =true ;for _eda :=(1<<uint (_cb ))-1;_eda >=0;
_eda --{_beb [_gf ]._eg [_fg |_eda ]=_cde ;};}else {return nil ,_e .New ("\u0043\u006f\u0064\u0065\u0020\u0074a\u0062\u006c\u0065\u0020\u006f\u0076\u0065\u0072\u0066\u006c\u006f\u0077\u0020i\u006e\u0020\u004d\u004d\u0052\u0044\u0065c\u006f\u0064\u0065\u0072");
};};};return _beb ,nil ;};const (EOF =-3;_fea =-2;EOL =-1;_fa =8;_ed =(1<<_fa )-1;_ff =5;_ac =(1<<_ff )-1;);func (_dcb *Decoder )initTables ()(_eea error ){if _dcb ._ede ==nil {_dcb ._ede ,_eea =_dcb .createLittleEndianTable (_feg );if _eea !=nil {return ;
};_dcb ._dgb ,_eea =_dcb .createLittleEndianTable (_fef );if _eea !=nil {return ;};_dcb ._bb ,_eea =_dcb .createLittleEndianTable (_fad );if _eea !=nil {return ;};};return nil ;};var (_fad =[][3]int {{4,0x1,int (_fe )},{3,0x1,int (_ge )},{1,0x1,int (_gd )},{3,0x3,int (_cfd )},{6,0x3,int (_be )},{7,0x3,int (_bda )},{3,0x2,int (_eaf )},{6,0x2,int (_cfb )},{7,0x2,int (_geb )},{10,0xf,int (_df )},{12,0xf,int (_aea )},{12,0x1,int (EOL )}};
_feg =[][3]int {{4,0x07,2},{4,0x08,3},{4,0x0B,4},{4,0x0C,5},{4,0x0E,6},{4,0x0F,7},{5,0x12,128},{5,0x13,8},{5,0x14,9},{5,0x1B,64},{5,0x07,10},{5,0x08,11},{6,0x17,192},{6,0x18,1664},{6,0x2A,16},{6,0x2B,17},{6,0x03,13},{6,0x34,14},{6,0x35,15},{6,0x07,1},{6,0x08,12},{7,0x13,26},{7,0x17,21},{7,0x18,28},{7,0x24,27},{7,0x27,18},{7,0x28,24},{7,0x2B,25},{7,0x03,22},{7,0x37,256},{7,0x04,23},{7,0x08,20},{7,0xC,19},{8,0x12,33},{8,0x13,34},{8,0x14,35},{8,0x15,36},{8,0x16,37},{8,0x17,38},{8,0x1A,31},{8,0x1B,32},{8,0x02,29},{8,0x24,53},{8,0x25,54},{8,0x28,39},{8,0x29,40},{8,0x2A,41},{8,0x2B,42},{8,0x2C,43},{8,0x2D,44},{8,0x03,30},{8,0x32,61},{8,0x33,62},{8,0x34,63},{8,0x35,0},{8,0x36,320},{8,0x37,384},{8,0x04,45},{8,0x4A,59},{8,0x4B,60},{8,0x5,46},{8,0x52,49},{8,0x53,50},{8,0x54,51},{8,0x55,52},{8,0x58,55},{8,0x59,56},{8,0x5A,57},{8,0x5B,58},{8,0x64,448},{8,0x65,512},{8,0x67,640},{8,0x68,576},{8,0x0A,47},{8,0x0B,48},{9,0x01,_fea },{9,0x98,1472},{9,0x99,1536},{9,0x9A,1600},{9,0x9B,1728},{9,0xCC,704},{9,0xCD,768},{9,0xD2,832},{9,0xD3,896},{9,0xD4,960},{9,0xD5,1024},{9,0xD6,1088},{9,0xD7,1152},{9,0xD8,1216},{9,0xD9,1280},{9,0xDA,1344},{9,0xDB,1408},{10,0x01,_fea },{11,0x01,_fea },{11,0x08,1792},{11,0x0C,1856},{11,0x0D,1920},{12,0x00,EOF },{12,0x01,EOL },{12,0x12,1984},{12,0x13,2048},{12,0x14,2112},{12,0x15,2176},{12,0x16,2240},{12,0x17,2304},{12,0x1C,2368},{12,0x1D,2432},{12,0x1E,2496},{12,0x1F,2560}};
_fef =[][3]int {{2,0x02,3},{2,0x03,2},{3,0x02,1},{3,0x03,4},{4,0x02,6},{4,0x03,5},{5,0x03,7},{6,0x04,9},{6,0x05,8},{7,0x04,10},{7,0x05,11},{7,0x07,12},{8,0x04,13},{8,0x07,14},{9,0x01,_fea },{9,0x18,15},{10,0x01,_fea },{10,0x17,16},{10,0x18,17},{10,0x37,0},{10,0x08,18},{10,0x0F,64},{11,0x01,_fea },{11,0x17,24},{11,0x18,25},{11,0x28,23},{11,0x37,22},{11,0x67,19},{11,0x68,20},{11,0x6C,21},{11,0x08,1792},{11,0x0C,1856},{11,0x0D,1920},{12,0x00,EOF },{12,0x01,EOL },{12,0x12,1984},{12,0x13,2048},{12,0x14,2112},{12,0x15,2176},{12,0x16,2240},{12,0x17,2304},{12,0x1C,2368},{12,0x1D,2432},{12,0x1E,2496},{12,0x1F,2560},{12,0x24,52},{12,0x27,55},{12,0x28,56},{12,0x2B,59},{12,0x2C,60},{12,0x33,320},{12,0x34,384},{12,0x35,448},{12,0x37,53},{12,0x38,54},{12,0x52,50},{12,0x53,51},{12,0x54,44},{12,0x55,45},{12,0x56,46},{12,0x57,47},{12,0x58,57},{12,0x59,58},{12,0x5A,61},{12,0x5B,256},{12,0x64,48},{12,0x65,49},{12,0x66,62},{12,0x67,63},{12,0x68,30},{12,0x69,31},{12,0x6A,32},{12,0x6B,33},{12,0x6C,40},{12,0x6D,41},{12,0xC8,128},{12,0xC9,192},{12,0xCA,26},{12,0xCB,27},{12,0xCC,28},{12,0xCD,29},{12,0xD2,34},{12,0xD3,35},{12,0xD4,36},{12,0xD5,37},{12,0xD6,38},{12,0xD7,39},{12,0xDA,42},{12,0xDB,43},{13,0x4A,640},{13,0x4B,704},{13,0x4C,768},{13,0x4D,832},{13,0x52,1280},{13,0x53,1344},{13,0x54,1408},{13,0x55,1472},{13,0x5A,1536},{13,0x5B,1600},{13,0x64,1664},{13,0x65,1728},{13,0x6C,512},{13,0x6D,576},{13,0x72,896},{13,0x73,960},{13,0x74,1024},{13,0x75,1088},{13,0x76,1152},{13,0x77,1216}};
);func _gaf (_bcf *_a .SubstreamReader )(*runData ,error ){_cga :=&runData {_gde :_bcf ,_dca :0,_efa :1};_faf :=_eag (_fd (_eb ,int (_bcf .Length ())),_beae );_cga ._dfc =make ([]byte ,_faf );if _fgf :=_cga .fillBuffer (0);_fgf !=nil {if _fgf ==_d .EOF {_cga ._dfc =make ([]byte ,10);
_af .Log .Debug ("F\u0069\u006c\u006c\u0042uf\u0066e\u0072\u0020\u0066\u0061\u0069l\u0065\u0064\u003a\u0020\u0025\u0076",_fgf );}else {return nil ,_fgf ;};};return _cga ,nil ;};func (_afg *runData )uncompressGetCodeLittleEndian (_fec []*code )(*code ,error ){_ecg ,_gac :=_afg .uncompressGetNextCodeLittleEndian ();
if _gac !=nil {_af .Log .Debug ("\u0055n\u0063\u006fm\u0070\u0072\u0065\u0073s\u0047\u0065\u0074N\u0065\u0078\u0074\u0043\u006f\u0064\u0065\u004c\u0069tt\u006c\u0065\u0045n\u0064\u0069a\u006e\u0020\u0066\u0061\u0069\u006ce\u0064\u003a \u0025\u0076",_gac );
return nil ,_gac ;};_ecg &=0xffffff;_fdc :=_ecg >>(_fab -_fa );_agg :=_fec [_fdc ];if _agg !=nil &&_agg ._ea {_fdc =(_ecg >>(_fab -_fa -_ff ))&_ac ;_agg =_agg ._eg [_fdc ];};return _agg ,nil ;};func _fd (_dg ,_afa int )int {if _dg < _afa {return _afa ;
};return _dg ;};func New (r _a .StreamReader ,width ,height int ,dataOffset ,dataLength int64 )(*Decoder ,error ){_fed :=&Decoder {_ga :width ,_ged :height };_da ,_ee :=_a .NewSubstreamReader (r ,uint64 (dataOffset ),uint64 (dataLength ));if _ee !=nil {return nil ,_ee ;
};_de ,_ee :=_gaf (_da );if _ee !=nil {return nil ,_ee ;};_fed ._bf =_de ;if _gc :=_fed .initTables ();_gc !=nil {return nil ,_gc ;};return _fed ,nil ;};func (_f *code )String ()string {return _c .Sprintf ("\u0025\u0064\u002f\u0025\u0064\u002f\u0025\u0064",_f ._cfa ,_f ._b ,_f ._bd );
};func (_bdab *Decoder )UncompressMMR ()(_gdc *_cf .Bitmap ,_cc error ){_gdc =_cf .New (_bdab ._ga ,_bdab ._ged );_fff :=make ([]int ,_gdc .Width +5);_cg :=make ([]int ,_gdc .Width +5);_cg [0]=_gdc .Width ;_ccg :=1;var _faa int ;for _aa :=0;_aa < _gdc .Height ;
_aa ++{_faa ,_cc =_bdab .uncompress2d (_bdab ._bf ,_cg ,_ccg ,_fff ,_gdc .Width );if _cc !=nil {return nil ,_cc ;};if _faa ==EOF {break ;};if _faa > 0{_cc =_bdab .fillBitmap (_gdc ,_aa ,_fff ,_faa );if _cc !=nil {return nil ,_cc ;};};_cg ,_fff =_fff ,_cg ;
_ccg =_faa ;};if _cc =_bdab .detectAndSkipEOL ();_cc !=nil {return nil ,_cc ;};_bdab ._bf .align ();return _gdc ,nil ;};type mmrCode int ;func (_gfdb *runData )align (){_gfdb ._dca =((_gfdb ._dca +7)>>3)<<3};func (_ab *Decoder )fillBitmap (_ba *_cf .Bitmap ,_gdg int ,_fgc []int ,_ec int )error {var _bfa byte ;
_bec :=0;_cbf :=_ba .GetByteIndex (_bec ,_gdg );for _cge :=0;_cge < _ec ;_cge ++{_fba :=byte (1);_bef :=_fgc [_cge ];if (_cge &1)==0{_fba =0;};for _bec < _bef {_bfa =(_bfa <<1)|_fba ;_bec ++;if (_bec &7)==0{if _bae :=_ba .SetByte (_cbf ,_bfa );_bae !=nil {return _bae ;
};_cbf ++;_bfa =0;};};};if (_bec &7)!=0{_bfa <<=uint (8-(_bec &7));if _dce :=_ba .SetByte (_cbf ,_bfa );_dce !=nil {return _dce ;};};return nil ;};func (_fc *Decoder )detectAndSkipEOL ()error {for {_dcc ,_eeb :=_fc ._bf .uncompressGetCode (_fc ._bb );if _eeb !=nil {return _eeb ;
};if _dcc !=nil &&_dcc ._bd ==EOL {_fc ._bf ._dca +=_dcc ._cfa ;}else {return nil ;};};};const (_fe mmrCode =iota ;_ge ;_gd ;_cfd ;_be ;_bda ;_eaf ;_cfb ;_geb ;_df ;_aea ;);const (_beae int =1024<<7;_eb int =3;_fab uint =24;);func (_fbe *runData )uncompressGetNextCodeLittleEndian ()(int ,error ){_bgb :=_fbe ._dca -_fbe ._efa ;
if _bgb < 0||_bgb > 24{_aaf :=(_fbe ._dca >>3)-_fbe ._gag ;if _aaf >=_fbe ._gee {_aaf +=_fbe ._gag ;if _fde :=_fbe .fillBuffer (_aaf );_fde !=nil {return 0,_fde ;};_aaf -=_fbe ._gag ;};_cfg :=(uint32 (_fbe ._dfc [_aaf ]&0xFF)<<16)|(uint32 (_fbe ._dfc [_aaf +1]&0xFF)<<8)|(uint32 (_fbe ._dfc [_aaf +2]&0xFF));
_dad :=uint32 (_fbe ._dca &7);_cfg <<=_dad ;_fbe ._cgd =int (_cfg );}else {_bcb :=_fbe ._efa &7;_adc :=7-_bcb ;if _bgb <=_adc {_fbe ._cgd <<=uint (_bgb );}else {_bge :=(_fbe ._efa >>3)+3-_fbe ._gag ;if _bge >=_fbe ._gee {_bge +=_fbe ._gag ;if _ebea :=_fbe .fillBuffer (_bge );
_ebea !=nil {return 0,_ebea ;};_bge -=_fbe ._gag ;};_bcb =8-_bcb ;for {_fbe ._cgd <<=uint (_bcb );_fbe ._cgd |=int (uint (_fbe ._dfc [_bge ])&0xFF);_bgb -=_bcb ;_bge ++;_bcb =8;if !(_bgb >=8){break ;};};_fbe ._cgd <<=uint (_bgb );};};_fbe ._efa =_fbe ._dca ;
return _fbe ._cgd ,nil ;};type code struct{_cfa int ;_b int ;_bd int ;_eg []*code ;_ea bool ;};type Decoder struct{_ga ,_ged int ;_bf *runData ;_ede []*code ;_dgb []*code ;_bb []*code ;};func (_deg *Decoder )uncompress2d (_cfdf *runData ,_db []int ,_gfc int ,_ffd []int ,_agf int )(int ,error ){var (_ecc int ;
_gcg int ;_dda int ;_eca =true ;_fda error ;_dga *code ;);_db [_gfc ]=_agf ;_db [_gfc +1]=_agf ;_db [_gfc +2]=_agf +1;_db [_gfc +3]=_agf +1;_fbd :for _dda < _agf {_dga ,_fda =_cfdf .uncompressGetCode (_deg ._bb );if _fda !=nil {return EOL ,nil ;};if _dga ==nil {_cfdf ._dca ++;
break _fbd ;};_cfdf ._dca +=_dga ._cfa ;switch mmrCode (_dga ._bd ){case _gd :_dda =_db [_ecc ];case _cfd :_dda =_db [_ecc ]+1;case _eaf :_dda =_db [_ecc ]-1;case _ge :for {var _ddaa []*code ;if _eca {_ddaa =_deg ._ede ;}else {_ddaa =_deg ._dgb ;};_dga ,_fda =_cfdf .uncompressGetCode (_ddaa );
if _fda !=nil {return 0,_fda ;};if _dga ==nil {break _fbd ;};_cfdf ._dca +=_dga ._cfa ;if _dga ._bd < 64{if _dga ._bd < 0{_ffd [_gcg ]=_dda ;_gcg ++;_dga =nil ;break _fbd ;};_dda +=_dga ._bd ;_ffd [_gcg ]=_dda ;_gcg ++;break ;};_dda +=_dga ._bd ;};_abe :=_dda ;
_gfa :for {var _gfd []*code ;if !_eca {_gfd =_deg ._ede ;}else {_gfd =_deg ._dgb ;};_dga ,_fda =_cfdf .uncompressGetCode (_gfd );if _fda !=nil {return 0,_fda ;};if _dga ==nil {break _fbd ;};_cfdf ._dca +=_dga ._cfa ;if _dga ._bd < 64{if _dga ._bd < 0{_ffd [_gcg ]=_dda ;
_gcg ++;break _fbd ;};_dda +=_dga ._bd ;if _dda < _agf ||_dda !=_abe {_ffd [_gcg ]=_dda ;_gcg ++;};break _gfa ;};_dda +=_dga ._bd ;};for _dda < _agf &&_db [_ecc ]<=_dda {_ecc +=2;};continue _fbd ;case _fe :_ecc ++;_dda =_db [_ecc ];_ecc ++;continue _fbd ;
case _be :_dda =_db [_ecc ]+2;case _cfb :_dda =_db [_ecc ]-2;case _bda :_dda =_db [_ecc ]+3;case _geb :_dda =_db [_ecc ]-3;default:if _cfdf ._dca ==12&&_dga ._bd ==EOL {_cfdf ._dca =0;if _ ,_fda =_deg .uncompress1d (_cfdf ,_db ,_agf );_fda !=nil {return 0,_fda ;
};_cfdf ._dca ++;if _ ,_fda =_deg .uncompress1d (_cfdf ,_ffd ,_agf );_fda !=nil {return 0,_fda ;};_bg ,_ad :=_deg .uncompress1d (_cfdf ,_db ,_agf );if _ad !=nil {return EOF ,_ad ;};_cfdf ._dca ++;return _bg ,nil ;};_dda =_agf ;continue _fbd ;};if _dda <=_agf {_eca =!_eca ;
_ffd [_gcg ]=_dda ;_gcg ++;if _ecc > 0{_ecc --;}else {_ecc ++;};for _dda < _agf &&_db [_ecc ]<=_dda {_ecc +=2;};};};if _ffd [_gcg ]!=_agf {_ffd [_gcg ]=_agf ;};if _dga ==nil {return EOL ,nil ;};return _gcg ,nil ;};func _eag (_ce ,_ae int )int {if _ce > _ae {return _ae ;
};return _ce ;};func (_cac *runData )fillBuffer (_fge int )error {_cac ._gag =_fge ;_ ,_fag :=_cac ._gde .Seek (int64 (_fge ),_d .SeekStart );if _fag !=nil {if _fag ==_d .EOF {_af .Log .Debug ("\u0053\u0065\u0061\u006b\u0020\u0045\u004f\u0046");_cac ._gee =-1;
}else {return _fag ;};};if _fag ==nil {_cac ._gee ,_fag =_cac ._gde .Read (_cac ._dfc );if _fag !=nil {if _fag ==_d .EOF {_af .Log .Trace ("\u0052\u0065\u0061\u0064\u0020\u0045\u004f\u0046");_cac ._gee =-1;}else {return _fag ;};};};if _cac ._gee > -1&&_cac ._gee < 3{for _cac ._gee < 3{_edf ,_cacg :=_cac ._gde .ReadByte ();
if _cacg !=nil {if _cacg ==_d .EOF {_cac ._dfc [_cac ._gee ]=0;}else {return _cacg ;};}else {_cac ._dfc [_cac ._gee ]=_edf &0xFF;};_cac ._gee ++;};};_cac ._gee -=3;if _cac ._gee < 0{_cac ._dfc =make ([]byte ,len (_cac ._dfc ));_cac ._gee =len (_cac ._dfc )-3;
};return nil ;};func _gb (_eae [3]int )*code {return &code {_cfa :_eae [0],_b :_eae [1],_bd :_eae [2]}};type runData struct{_gde *_a .SubstreamReader ;_dca int ;_efa int ;_cgd int ;_dfc []byte ;_gag int ;_gee int ;};func (_fdd *Decoder )uncompress1d (_beg *runData ,_ag []int ,_dd int )(int ,error ){var (_bcc =true ;
_cfde int ;_ef *code ;_dcee int ;_ffa error ;);_gbf :for _cfde < _dd {_dea :for {if _bcc {_ef ,_ffa =_beg .uncompressGetCode (_fdd ._ede );if _ffa !=nil {return 0,_ffa ;};}else {_ef ,_ffa =_beg .uncompressGetCode (_fdd ._dgb );if _ffa !=nil {return 0,_ffa ;
};};_beg ._dca +=_ef ._cfa ;if _ef ._bd < 0{break _gbf ;};_cfde +=_ef ._bd ;if _ef ._bd < 64{_bcc =!_bcc ;_ag [_dcee ]=_cfde ;_dcee ++;break _dea ;};};};if _ag [_dcee ]!=_dd {_ag [_dcee ]=_dd ;};_ddd :=EOL ;if _ef !=nil &&_ef ._bd !=EOL {_ddd =_dcee ;};
return _ddd ,nil ;};func (_ebe *runData )uncompressGetCode (_ca []*code )(*code ,error ){return _ebe .uncompressGetCodeLittleEndian (_ca );};