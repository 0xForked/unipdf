//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package mmr ;import (_a "errors";_g "fmt";_f "github.com/unidoc/unipdf/v3/common";_af "github.com/unidoc/unipdf/v3/internal/bitwise";_bf "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_gd "io";);const (_cc mmrCode =iota ;_geb ;_ca ;_ec ;_gc ;_dc ;
_ef ;_gdb ;_ed ;_fc ;_efa ;);func (_dga *Decoder )uncompress1d (_fcf *runData ,_bbe []int ,_edga int )(int ,error ){var (_eg =true ;_ega int ;_dbg *code ;_cce int ;_ebb error ;);_gga :for _ega < _edga {_cad :for {if _eg {_dbg ,_ebb =_fcf .uncompressGetCode (_dga ._dcb );
if _ebb !=nil {return 0,_ebb ;};}else {_dbg ,_ebb =_fcf .uncompressGetCode (_dga ._ga );if _ebb !=nil {return 0,_ebb ;};};_fcf ._aad +=_dbg ._ad ;if _dbg ._ff < 0{break _gga ;};_ega +=_dbg ._ff ;if _dbg ._ff < 64{_eg =!_eg ;_bbe [_cce ]=_ega ;_cce ++;break _cad ;
};};};if _bbe [_cce ]!=_edga {_bbe [_cce ]=_edga ;};_cggf :=EOL ;if _dbg !=nil &&_dbg ._ff !=EOL {_cggf =_cce ;};return _cggf ,nil ;};const (EOF =-3;_fga =-2;EOL =-1;_gdf =8;_bg =(1<<_gdf )-1;_db =5;_fcc =(1<<_db )-1;);func (_ead *Decoder )uncompress2d (_gcg *runData ,_cd []int ,_fa int ,_ceg []int ,_agde int )(int ,error ){var (_dd int ;
_dgc int ;_bc int ;_dgcc =true ;_ebg error ;_dfg *code ;);_cd [_fa ]=_agde ;_cd [_fa +1]=_agde ;_cd [_fa +2]=_agde +1;_cd [_fa +3]=_agde +1;_cfg :for _bc < _agde {_dfg ,_ebg =_gcg .uncompressGetCode (_ead ._dbee );if _ebg !=nil {return EOL ,nil ;};if _dfg ==nil {_gcg ._aad ++;
break _cfg ;};_gcg ._aad +=_dfg ._ad ;switch mmrCode (_dfg ._ff ){case _ca :_bc =_cd [_dd ];case _ec :_bc =_cd [_dd ]+1;case _ef :_bc =_cd [_dd ]-1;case _geb :for {var _cdd []*code ;if _dgcc {_cdd =_ead ._dcb ;}else {_cdd =_ead ._ga ;};_dfg ,_ebg =_gcg .uncompressGetCode (_cdd );
if _ebg !=nil {return 0,_ebg ;};if _dfg ==nil {break _cfg ;};_gcg ._aad +=_dfg ._ad ;if _dfg ._ff < 64{if _dfg ._ff < 0{_ceg [_dgc ]=_bc ;_dgc ++;_dfg =nil ;break _cfg ;};_bc +=_dfg ._ff ;_ceg [_dgc ]=_bc ;_dgc ++;break ;};_bc +=_dfg ._ff ;};_bgf :=_bc ;
_fgf :for {var _gab []*code ;if !_dgcc {_gab =_ead ._dcb ;}else {_gab =_ead ._ga ;};_dfg ,_ebg =_gcg .uncompressGetCode (_gab );if _ebg !=nil {return 0,_ebg ;};if _dfg ==nil {break _cfg ;};_gcg ._aad +=_dfg ._ad ;if _dfg ._ff < 64{if _dfg ._ff < 0{_ceg [_dgc ]=_bc ;
_dgc ++;break _cfg ;};_bc +=_dfg ._ff ;if _bc < _agde ||_bc !=_bgf {_ceg [_dgc ]=_bc ;_dgc ++;};break _fgf ;};_bc +=_dfg ._ff ;};for _bc < _agde &&_cd [_dd ]<=_bc {_dd +=2;};continue _cfg ;case _cc :_dd ++;_bc =_cd [_dd ];_dd ++;continue _cfg ;case _gc :_bc =_cd [_dd ]+2;
case _gdb :_bc =_cd [_dd ]-2;case _dc :_bc =_cd [_dd ]+3;case _ed :_bc =_cd [_dd ]-3;default:if _gcg ._aad ==12&&_dfg ._ff ==EOL {_gcg ._aad =0;if _ ,_ebg =_ead .uncompress1d (_gcg ,_cd ,_agde );_ebg !=nil {return 0,_ebg ;};_gcg ._aad ++;if _ ,_ebg =_ead .uncompress1d (_gcg ,_ceg ,_agde );
_ebg !=nil {return 0,_ebg ;};_efe ,_bec :=_ead .uncompress1d (_gcg ,_cd ,_agde );if _bec !=nil {return EOF ,_bec ;};_gcg ._aad ++;return _efe ,nil ;};_bc =_agde ;continue _cfg ;};if _bc <=_agde {_dgcc =!_dgcc ;_ceg [_dgc ]=_bc ;_dgc ++;if _dd > 0{_dd --;
}else {_dd ++;};for _bc < _agde &&_cd [_dd ]<=_bc {_dd +=2;};};};if _ceg [_dgc ]!=_agde {_ceg [_dgc ]=_agde ;};if _dfg ==nil {return EOL ,nil ;};return _dgc ,nil ;};func (_eee *runData )uncompressGetNextCodeLittleEndian ()(int ,error ){_cggfd :=_eee ._aad -_eee ._acb ;
if _cggfd < 0||_cggfd > 24{_cadc :=(_eee ._aad >>3)-_eee ._adb ;if _cadc >=_eee ._cgc {_cadc +=_eee ._adb ;if _dbc :=_eee .fillBuffer (_cadc );_dbc !=nil {return 0,_dbc ;};_cadc -=_eee ._adb ;};_dac :=(uint32 (_eee ._dgca [_cadc ]&0xFF)<<16)|(uint32 (_eee ._dgca [_cadc +1]&0xFF)<<8)|(uint32 (_eee ._dgca [_cadc +2]&0xFF));
_bfe :=uint32 (_eee ._aad &7);_dac <<=_bfe ;_eee ._cab =int (_dac );}else {_aab :=_eee ._acb &7;_gca :=7-_aab ;if _cggfd <=_gca {_eee ._cab <<=uint (_cggfd );}else {_fcg :=(_eee ._acb >>3)+3-_eee ._adb ;if _fcg >=_eee ._cgc {_fcg +=_eee ._adb ;if _abe :=_eee .fillBuffer (_fcg );
_abe !=nil {return 0,_abe ;};_fcg -=_eee ._adb ;};_aab =8-_aab ;for {_eee ._cab <<=uint (_aab );_eee ._cab |=int (uint (_eee ._dgca [_fcg ])&0xFF);_cggfd -=_aab ;_fcg ++;_aab =8;if !(_cggfd >=8){break ;};};_eee ._cab <<=uint (_cggfd );};};_eee ._acb =_eee ._aad ;
return _eee ._cab ,nil ;};func (_aaa *runData )fillBuffer (_gbe int )error {_aaa ._adb =_gbe ;_ ,_dcf :=_aaa ._ded .Seek (int64 (_gbe ),_gd .SeekStart );if _dcf !=nil {if _dcf ==_gd .EOF {_f .Log .Debug ("\u0053\u0065\u0061\u006b\u0020\u0045\u004f\u0046");
_aaa ._cgc =-1;}else {return _dcf ;};};if _dcf ==nil {_aaa ._cgc ,_dcf =_aaa ._ded .Read (_aaa ._dgca );if _dcf !=nil {if _dcf ==_gd .EOF {_f .Log .Trace ("\u0052\u0065\u0061\u0064\u0020\u0045\u004f\u0046");_aaa ._cgc =-1;}else {return _dcf ;};};};if _aaa ._cgc > -1&&_aaa ._cgc < 3{for _aaa ._cgc < 3{_cege ,_fda :=_aaa ._ded .ReadByte ();
if _fda !=nil {if _fda ==_gd .EOF {_aaa ._dgca [_aaa ._cgc ]=0;}else {return _fda ;};}else {_aaa ._dgca [_aaa ._cgc ]=_cege &0xFF;};_aaa ._cgc ++;};};_aaa ._cgc -=3;if _aaa ._cgc < 0{_aaa ._dgca =make ([]byte ,len (_aaa ._dgca ));_aaa ._cgc =len (_aaa ._dgca )-3;
};return nil ;};func New (r _af .StreamReader ,width ,height int ,dataOffset ,dataLength int64 )(*Decoder ,error ){_ea :=&Decoder {_ee :width ,_ffe :height };_bb ,_gf :=_af .NewSubstreamReader (r ,uint64 (dataOffset ),uint64 (dataLength ));if _gf !=nil {return nil ,_gf ;
};_fb ,_gf :=_cede (_bb );if _gf !=nil {return nil ,_gf ;};_ea ._dbe =_fb ;if _bd :=_ea .initTables ();_bd !=nil {return nil ,_bd ;};return _ea ,nil ;};func (_eag *Decoder )detectAndSkipEOL ()error {for {_gdbg ,_aff :=_eag ._dbe .uncompressGetCode (_eag ._dbee );
if _aff !=nil {return _aff ;};if _gdbg !=nil &&_gdbg ._ff ==EOL {_eag ._dbe ._aad +=_gdbg ._ad ;}else {return nil ;};};};var (_gg =[][3]int {{4,0x1,int (_cc )},{3,0x1,int (_geb )},{1,0x1,int (_ca )},{3,0x3,int (_ec )},{6,0x3,int (_gc )},{7,0x3,int (_dc )},{3,0x2,int (_ef )},{6,0x2,int (_gdb )},{7,0x2,int (_ed )},{10,0xf,int (_fc )},{12,0xf,int (_efa )},{12,0x1,int (EOL )}};
_be =[][3]int {{4,0x07,2},{4,0x08,3},{4,0x0B,4},{4,0x0C,5},{4,0x0E,6},{4,0x0F,7},{5,0x12,128},{5,0x13,8},{5,0x14,9},{5,0x1B,64},{5,0x07,10},{5,0x08,11},{6,0x17,192},{6,0x18,1664},{6,0x2A,16},{6,0x2B,17},{6,0x03,13},{6,0x34,14},{6,0x35,15},{6,0x07,1},{6,0x08,12},{7,0x13,26},{7,0x17,21},{7,0x18,28},{7,0x24,27},{7,0x27,18},{7,0x28,24},{7,0x2B,25},{7,0x03,22},{7,0x37,256},{7,0x04,23},{7,0x08,20},{7,0xC,19},{8,0x12,33},{8,0x13,34},{8,0x14,35},{8,0x15,36},{8,0x16,37},{8,0x17,38},{8,0x1A,31},{8,0x1B,32},{8,0x02,29},{8,0x24,53},{8,0x25,54},{8,0x28,39},{8,0x29,40},{8,0x2A,41},{8,0x2B,42},{8,0x2C,43},{8,0x2D,44},{8,0x03,30},{8,0x32,61},{8,0x33,62},{8,0x34,63},{8,0x35,0},{8,0x36,320},{8,0x37,384},{8,0x04,45},{8,0x4A,59},{8,0x4B,60},{8,0x5,46},{8,0x52,49},{8,0x53,50},{8,0x54,51},{8,0x55,52},{8,0x58,55},{8,0x59,56},{8,0x5A,57},{8,0x5B,58},{8,0x64,448},{8,0x65,512},{8,0x67,640},{8,0x68,576},{8,0x0A,47},{8,0x0B,48},{9,0x01,_fga },{9,0x98,1472},{9,0x99,1536},{9,0x9A,1600},{9,0x9B,1728},{9,0xCC,704},{9,0xCD,768},{9,0xD2,832},{9,0xD3,896},{9,0xD4,960},{9,0xD5,1024},{9,0xD6,1088},{9,0xD7,1152},{9,0xD8,1216},{9,0xD9,1280},{9,0xDA,1344},{9,0xDB,1408},{10,0x01,_fga },{11,0x01,_fga },{11,0x08,1792},{11,0x0C,1856},{11,0x0D,1920},{12,0x00,EOF },{12,0x01,EOL },{12,0x12,1984},{12,0x13,2048},{12,0x14,2112},{12,0x15,2176},{12,0x16,2240},{12,0x17,2304},{12,0x1C,2368},{12,0x1D,2432},{12,0x1E,2496},{12,0x1F,2560}};
_dcg =[][3]int {{2,0x02,3},{2,0x03,2},{3,0x02,1},{3,0x03,4},{4,0x02,6},{4,0x03,5},{5,0x03,7},{6,0x04,9},{6,0x05,8},{7,0x04,10},{7,0x05,11},{7,0x07,12},{8,0x04,13},{8,0x07,14},{9,0x01,_fga },{9,0x18,15},{10,0x01,_fga },{10,0x17,16},{10,0x18,17},{10,0x37,0},{10,0x08,18},{10,0x0F,64},{11,0x01,_fga },{11,0x17,24},{11,0x18,25},{11,0x28,23},{11,0x37,22},{11,0x67,19},{11,0x68,20},{11,0x6C,21},{11,0x08,1792},{11,0x0C,1856},{11,0x0D,1920},{12,0x00,EOF },{12,0x01,EOL },{12,0x12,1984},{12,0x13,2048},{12,0x14,2112},{12,0x15,2176},{12,0x16,2240},{12,0x17,2304},{12,0x1C,2368},{12,0x1D,2432},{12,0x1E,2496},{12,0x1F,2560},{12,0x24,52},{12,0x27,55},{12,0x28,56},{12,0x2B,59},{12,0x2C,60},{12,0x33,320},{12,0x34,384},{12,0x35,448},{12,0x37,53},{12,0x38,54},{12,0x52,50},{12,0x53,51},{12,0x54,44},{12,0x55,45},{12,0x56,46},{12,0x57,47},{12,0x58,57},{12,0x59,58},{12,0x5A,61},{12,0x5B,256},{12,0x64,48},{12,0x65,49},{12,0x66,62},{12,0x67,63},{12,0x68,30},{12,0x69,31},{12,0x6A,32},{12,0x6B,33},{12,0x6C,40},{12,0x6D,41},{12,0xC8,128},{12,0xC9,192},{12,0xCA,26},{12,0xCB,27},{12,0xCC,28},{12,0xCD,29},{12,0xD2,34},{12,0xD3,35},{12,0xD4,36},{12,0xD5,37},{12,0xD6,38},{12,0xD7,39},{12,0xDA,42},{12,0xDB,43},{13,0x4A,640},{13,0x4B,704},{13,0x4C,768},{13,0x4D,832},{13,0x52,1280},{13,0x53,1344},{13,0x54,1408},{13,0x55,1472},{13,0x5A,1536},{13,0x5B,1600},{13,0x64,1664},{13,0x65,1728},{13,0x6C,512},{13,0x6D,576},{13,0x72,896},{13,0x73,960},{13,0x74,1024},{13,0x75,1088},{13,0x76,1152},{13,0x77,1216}};
);func (_fcca *runData )align (){_fcca ._aad =((_fcca ._aad +7)>>3)<<3};func (_gac *Decoder )initTables ()(_fe error ){if _gac ._dcb ==nil {_gac ._dcb ,_fe =_gac .createLittleEndianTable (_be );if _fe !=nil {return ;};_gac ._ga ,_fe =_gac .createLittleEndianTable (_dcg );
if _fe !=nil {return ;};_gac ._dbee ,_fe =_gac .createLittleEndianTable (_gg );if _fe !=nil {return ;};};return nil ;};type runData struct{_ded *_af .SubstreamReader ;_aad int ;_acb int ;_cab int ;_dgca []byte ;_adb int ;_cgc int ;};func _ag (_bfa [3]int )*code {return &code {_ad :_bfa [0],_fg :_bfa [1],_ff :_bfa [2]}};
func _afg (_ge ,_d int )int {if _ge < _d {return _d ;};return _ge ;};const (_beab int =1024<<7;_dcc int =3;_de uint =24;);func (_agdc *Decoder )fillBitmap (_aba *_bf .Bitmap ,_eca int ,_fdf []int ,_aa int )error {var _bea byte ;_ccc :=0;_cfa :=_aba .GetByteIndex (_ccc ,_eca );
for _dcd :=0;_dcd < _aa ;_dcd ++{_eddc :=byte (1);_geg :=_fdf [_dcd ];if (_dcd &1)==0{_eddc =0;};for _ccc < _geg {_bea =(_bea <<1)|_eddc ;_ccc ++;if (_ccc &7)==0{if _gb :=_aba .SetByte (_cfa ,_bea );_gb !=nil {return _gb ;};_cfa ++;_bea =0;};};};if (_ccc &7)!=0{_bea <<=uint (8-(_ccc &7));
if _gfa :=_aba .SetByte (_cfa ,_bea );_gfa !=nil {return _gfa ;};};return nil ;};func (_gff *runData )uncompressGetCode (_fbe []*code )(*code ,error ){return _gff .uncompressGetCodeLittleEndian (_fbe );};func (_dae *runData )uncompressGetCodeLittleEndian (_egg []*code )(*code ,error ){_baf ,_dee :=_dae .uncompressGetNextCodeLittleEndian ();
if _dee !=nil {_f .Log .Debug ("\u0055n\u0063\u006fm\u0070\u0072\u0065\u0073s\u0047\u0065\u0074N\u0065\u0078\u0074\u0043\u006f\u0064\u0065\u004c\u0069tt\u006c\u0065\u0045n\u0064\u0069a\u006e\u0020\u0066\u0061\u0069\u006ce\u0064\u003a \u0025\u0076",_dee );
return nil ,_dee ;};_baf &=0xffffff;_ggd :=_baf >>(_de -_gdf );_eade :=_egg [_ggd ];if _eade !=nil &&_eade ._c {_ggd =(_baf >>(_de -_gdf -_db ))&_fcc ;_eade =_eade ._ab [_ggd ];};return _eade ,nil ;};func _cede (_dfd *_af .SubstreamReader )(*runData ,error ){_dfb :=&runData {_ded :_dfd ,_aad :0,_acb :1};
_fcfa :=_e (_afg (_dcc ,int (_dfd .Length ())),_beab );_dfb ._dgca =make ([]byte ,_fcfa );if _dce :=_dfb .fillBuffer (0);_dce !=nil {if _dce ==_gd .EOF {_dfb ._dgca =make ([]byte ,10);_f .Log .Debug ("F\u0069\u006c\u006c\u0042uf\u0066e\u0072\u0020\u0066\u0061\u0069l\u0065\u0064\u003a\u0020\u0025\u0076",_dce );
}else {return nil ,_dce ;};};return _dfb ,nil ;};type mmrCode int ;func _e (_da ,_eb int )int {if _da > _eb {return _eb ;};return _da ;};type code struct{_ad int ;_fg int ;_ff int ;_ab []*code ;_c bool ;};type Decoder struct{_ee ,_ffe int ;_dbe *runData ;
_dcb []*code ;_ga []*code ;_dbee []*code ;};func (_ebe *Decoder )createLittleEndianTable (_dg [][3]int )([]*code ,error ){_cga :=make ([]*code ,_bg +1);for _fd :=0;_fd < len (_dg );_fd ++{_dbd :=_ag (_dg [_fd ]);if _dbd ._ad <=_gdf {_ebf :=_gdf -_dbd ._ad ;
_ce :=_dbd ._fg <<uint (_ebf );for _agd :=(1<<uint (_ebf ))-1;_agd >=0;_agd --{_gcb :=_ce |_agd ;_cga [_gcb ]=_dbd ;};}else {_edd :=_dbd ._fg >>uint (_dbd ._ad -_gdf );if _cga [_edd ]==nil {var _fbb =_ag ([3]int {});_fbb ._ab =make ([]*code ,_fcc +1);_cga [_edd ]=_fbb ;
};if _dbd ._ad <=_gdf +_db {_eae :=_gdf +_db -_dbd ._ad ;_ac :=(_dbd ._fg <<uint (_eae ))&_fcc ;_cga [_edd ]._c =true ;for _ced :=(1<<uint (_eae ))-1;_ced >=0;_ced --{_cga [_edd ]._ab [_ac |_ced ]=_dbd ;};}else {return nil ,_a .New ("\u0043\u006f\u0064\u0065\u0020\u0074a\u0062\u006c\u0065\u0020\u006f\u0076\u0065\u0072\u0066\u006c\u006f\u0077\u0020i\u006e\u0020\u004d\u004d\u0052\u0044\u0065c\u006f\u0064\u0065\u0072");
};};};return _cga ,nil ;};func (_bfg *Decoder )UncompressMMR ()(_df *_bf .Bitmap ,_cf error ){_df =_bf .New (_bfg ._ee ,_bfg ._ffe );_edc :=make ([]int ,_df .Width +5);_ae :=make ([]int ,_df .Width +5);_ae [0]=_df .Width ;_cgg :=1;var _cge int ;for _edg :=0;
_edg < _df .Height ;_edg ++{_cge ,_cf =_bfg .uncompress2d (_bfg ._dbe ,_ae ,_cgg ,_edc ,_df .Width );if _cf !=nil {return nil ,_cf ;};if _cge ==EOF {break ;};if _cge > 0{_cf =_bfg .fillBitmap (_df ,_edg ,_edc ,_cge );if _cf !=nil {return nil ,_cf ;};};
_ae ,_edc =_edc ,_ae ;_cgg =_cge ;};if _cf =_bfg .detectAndSkipEOL ();_cf !=nil {return nil ,_cf ;};_bfg ._dbe .align ();return _df ,nil ;};func (_cg *code )String ()string {return _g .Sprintf ("\u0025\u0064\u002f\u0025\u0064\u002f\u0025\u0064",_cg ._ad ,_cg ._fg ,_cg ._ff );
};