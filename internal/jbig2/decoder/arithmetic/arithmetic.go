//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_bg "fmt";_f "github.com/unidoc/unipdf/v3/common";_g "github.com/unidoc/unipdf/v3/internal/bitwise";_d "io";_ec "math";_b "strings";);func (_fbb *DecoderStats )setEntry (_gd int ){_gec :=byte (_gd &0x7f);_fbb ._cad [_fbb ._bee ]=_gec };func (_dcd *DecoderStats )SetIndex (index int32 ){_dcd ._bee =index };func (_gc *Decoder )DecodeBit (stats *DecoderStats )(int ,error ){var (_dc int ;_cd =_eb [stats .cx ()][0];_ee =int32 (stats .cx ()););defer func (){_gc ._da ++}();_gc ._cg -=_cd ;if (_gc ._de >>16)< uint64 (_cd ){_dc =_gc .lpsExchange (stats ,_ee ,_cd );if _fc :=_gc .renormalize ();_fc !=nil {return 0,_fc ;};}else {_gc ._de -=uint64 (_cd )<<16;if (_gc ._cg &0x8000)==0{_dc =_gc .mpsExchange (stats ,_ee );if _daa :=_gc .renormalize ();_daa !=nil {return 0,_daa ;};}else {_dc =int (stats .getMps ());};};return _dc ,nil ;};func (_aef *Decoder )renormalize ()error {for {if _aef ._dd ==0{if _bd :=_aef .readByte ();_bd !=nil {return _bd ;};};_aef ._cg <<=1;_aef ._de <<=1;_aef ._dd --;if (_aef ._cg &0x8000)!=0{break ;};};_aef ._de &=0xffffffff;return nil ;};func (_cdd *DecoderStats )Reset (){for _dac :=0;_dac < len (_cdd ._cad );_dac ++{_cdd ._cad [_dac ]=0;_cdd ._aca [_dac ]=0;};};func (_ce *Decoder )readByte ()error {if _ce ._a .StreamPosition ()> _ce ._ac {if _ ,_dab :=_ce ._a .Seek (-1,_d .SeekCurrent );_dab !=nil {return _dab ;};};_ff ,_edb :=_ce ._a .ReadByte ();if _edb !=nil {return _edb ;};_ce ._c =_ff ;if _ce ._c ==0xFF{_gb ,_cce :=_ce ._a .ReadByte ();if _cce !=nil {return _cce ;};if _gb > 0x8F{_ce ._de +=0xFF00;_ce ._dd =8;if _ ,_ge :=_ce ._a .Seek (-2,_d .SeekCurrent );_ge !=nil {return _ge ;};}else {_ce ._de +=uint64 (_gb )<<9;_ce ._dd =7;};}else {_ff ,_edb =_ce ._a .ReadByte ();if _edb !=nil {return _edb ;};_ce ._c =_ff ;_ce ._de +=uint64 (_ce ._c )<<8;_ce ._dd =8;};_ce ._de &=0xFFFFFFFFFF;return nil ;};func (_ece *Decoder )init ()error {_ece ._ac =_ece ._a .StreamPosition ();_fe ,_ae :=_ece ._a .ReadByte ();if _ae !=nil {_f .Log .Debug ("B\u0075\u0066\u0066\u0065\u0072\u0030 \u0072\u0065\u0061\u0064\u0042\u0079\u0074\u0065\u0020f\u0061\u0069\u006ce\u0064.\u0020\u0025\u0076",_ae );return _ae ;};_ece ._c =_fe ;_ece ._de =uint64 (_fe )<<16;if _ae =_ece .readByte ();_ae !=nil {return _ae ;};_ece ._de <<=7;_ece ._dd -=7;_ece ._cg =0x8000;_ece ._da ++;return nil ;};func (_fca *Decoder )lpsExchange (_ega *DecoderStats ,_aa int32 ,_bcg uint32 )int {_fb :=_ega .getMps ();if _fca ._cg < _bcg {_ega .setEntry (int (_eb [_aa ][1]));_fca ._cg =_bcg ;return int (_fb );};if _eb [_aa ][3]==1{_ega .toggleMps ();};_ega .setEntry (int (_eb [_aa ][2]));_fca ._cg =_bcg ;return int (1-_fb );};func (_cb *Decoder )mpsExchange (_ebe *DecoderStats ,_cf int32 )int {_dgb :=_ebe ._aca [_ebe ._bee ];if _cb ._cg < _eb [_cf ][0]{if _eb [_cf ][3]==1{_ebe .toggleMps ();};_ebe .setEntry (int (_eb [_cf ][2]));return int (1-_dgb );};_ebe .setEntry (int (_eb [_cf ][1]));return int (_dgb );};type DecoderStats struct{_bee int32 ;_aefb int32 ;_cad []byte ;_aca []byte ;};func NewStats (contextSize int32 ,index int32 )*DecoderStats {return &DecoderStats {_bee :index ,_aefb :contextSize ,_cad :make ([]byte ,contextSize ),_aca :make ([]byte ,contextSize )};};func (_ba *DecoderStats )Overwrite (dNew *DecoderStats ){for _gbg :=0;_gbg < len (_ba ._cad );_gbg ++{_ba ._cad [_gbg ]=dNew ._cad [_gbg ];_ba ._aca [_gbg ]=dNew ._aca [_gbg ];};};var (_eb =[][4]uint32 {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};);func (_fda *DecoderStats )cx ()byte {return _fda ._cad [_fda ._bee ]};func (_ab *Decoder )decodeIntBit (_geg *DecoderStats )(int ,error ){_geg .SetIndex (int32 (_ab ._eg ));_dea ,_df :=_ab .DecodeBit (_geg );if _df !=nil {_f .Log .Debug ("\u0041\u0072\u0069\u0074\u0068\u006d\u0065t\u0069\u0063\u0044e\u0063\u006f\u0064e\u0072\u0020'\u0064\u0065\u0063\u006f\u0064\u0065I\u006etB\u0069\u0074\u0027\u002d\u003e\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0042\u0069\u0074\u0020\u0066\u0061\u0069\u006c\u0065\u0064\u002e\u0020\u0025\u0076",_df );return _dea ,_df ;};if _ab ._eg < 256{_ab ._eg =((_ab ._eg <<uint64 (1))|int64 (_dea ))&0x1ff;}else {_ab ._eg =(((_ab ._eg <<uint64 (1)|int64 (_dea ))&511)|256)&0x1ff;};return _dea ,nil ;};func (_eff *DecoderStats )Copy ()*DecoderStats {_fea :=&DecoderStats {_aefb :_eff ._aefb ,_cad :make ([]byte ,_eff ._aefb )};for _ecf :=0;_ecf < len (_eff ._cad );_ecf ++{_fea ._cad [_ecf ]=_eff ._cad [_ecf ];};return _fea ;};func (_ag *DecoderStats )getMps ()byte {return _ag ._aca [_ag ._bee ]};func (_dg *Decoder )DecodeInt (stats *DecoderStats )(int32 ,error ){var (_ef ,_ed int32 ;_ca ,_af ,_efe int ;_caa error ;);if stats ==nil {stats =NewStats (512,1);};_dg ._eg =1;_af ,_caa =_dg .decodeIntBit (stats );if _caa !=nil {return 0,_caa ;};_ca ,_caa =_dg .decodeIntBit (stats );if _caa !=nil {return 0,_caa ;};if _ca ==1{_ca ,_caa =_dg .decodeIntBit (stats );if _caa !=nil {return 0,_caa ;};if _ca ==1{_ca ,_caa =_dg .decodeIntBit (stats );if _caa !=nil {return 0,_caa ;};if _ca ==1{_ca ,_caa =_dg .decodeIntBit (stats );if _caa !=nil {return 0,_caa ;};if _ca ==1{_ca ,_caa =_dg .decodeIntBit (stats );if _caa !=nil {return 0,_caa ;};if _ca ==1{_efe =32;_ed =4436;}else {_efe =12;_ed =340;};}else {_efe =8;_ed =84;};}else {_efe =6;_ed =20;};}else {_efe =4;_ed =4;};}else {_efe =2;_ed =0;};for _ebf :=0;_ebf < _efe ;_ebf ++{_ca ,_caa =_dg .decodeIntBit (stats );if _caa !=nil {return 0,_caa ;};_ef =(_ef <<1)|int32 (_ca );};_ef +=_ed ;if _af ==0{return _ef ,nil ;}else if _af ==1&&_ef > 0{return -_ef ,nil ;};return _ec .MaxInt32 ,nil ;};func New (r _g .StreamReader )(*Decoder ,error ){_fd :=&Decoder {_a :r ,ContextSize :[]uint32 {16,13,10,10},ReferedToContextSize :[]uint32 {13,10}};if _ga :=_fd .init ();_ga !=nil {return nil ,_ga ;};return _fd ,nil ;};func (_ddb *Decoder )DecodeIAID (codeLen uint64 ,stats *DecoderStats )(int64 ,error ){_ddb ._eg =1;var _eed uint64 ;for _eed =0;_eed < codeLen ;_eed ++{stats .SetIndex (int32 (_ddb ._eg ));_be ,_cc :=_ddb .DecodeBit (stats );if _cc !=nil {return 0,_cc ;};_ddb ._eg =(_ddb ._eg <<1)|int64 (_be );};_bc :=_ddb ._eg -(1<<codeLen );return _bc ,nil ;};func (_fef *DecoderStats )String ()string {_gbe :=&_b .Builder {};_gbe .WriteString (_bg .Sprintf ("S\u0074\u0061\u0074\u0073\u003a\u0020\u0020\u0025\u0064\u000a",len (_fef ._cad )));for _cdb ,_aed :=range _fef ._cad {if _aed !=0{_gbe .WriteString (_bg .Sprintf ("N\u006f\u0074\u0020\u007aer\u006f \u0061\u0074\u003a\u0020\u0025d\u0020\u002d\u0020\u0025\u0064\u000a",_cdb ,_aed ));};};return _gbe .String ();};type Decoder struct{ContextSize []uint32 ;ReferedToContextSize []uint32 ;_a _g .StreamReader ;_c uint8 ;_de uint64 ;_cg uint32 ;_eg int64 ;_dd int32 ;_da int32 ;_ac int64 ;};func (_cef *DecoderStats )toggleMps (){_cef ._aca [_cef ._bee ]^=1};