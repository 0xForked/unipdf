//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_bc "fmt";_a "github.com/unidoc/unipdf/v3/common";_bcb "github.com/unidoc/unipdf/v3/internal/bitwise";_f "github.com/unidoc/unipdf/v3/internal/jbig2/internal";_g "io";_be "strings";);type Decoder struct{ContextSize []uint32 ;
ReferedToContextSize []uint32 ;_fb *_bcb .Reader ;_fe uint8 ;_ac uint64 ;_bg uint32 ;_af int64 ;_c int32 ;_e int32 ;_ag int64 ;};func (_egf *DecoderStats )SetIndex (index int32 ){_egf ._eec =index };func (_ad *Decoder )DecodeInt (stats *DecoderStats )(int32 ,error ){var (_fc ,_gc int32 ;
_fa ,_ba ,_adf int ;_gg error ;);if stats ==nil {stats =NewStats (512,1);};_ad ._af =1;_ba ,_gg =_ad .decodeIntBit (stats );if _gg !=nil {return 0,_gg ;};_fa ,_gg =_ad .decodeIntBit (stats );if _gg !=nil {return 0,_gg ;};if _fa ==1{_fa ,_gg =_ad .decodeIntBit (stats );
if _gg !=nil {return 0,_gg ;};if _fa ==1{_fa ,_gg =_ad .decodeIntBit (stats );if _gg !=nil {return 0,_gg ;};if _fa ==1{_fa ,_gg =_ad .decodeIntBit (stats );if _gg !=nil {return 0,_gg ;};if _fa ==1{_fa ,_gg =_ad .decodeIntBit (stats );if _gg !=nil {return 0,_gg ;
};if _fa ==1{_adf =32;_gc =4436;}else {_adf =12;_gc =340;};}else {_adf =8;_gc =84;};}else {_adf =6;_gc =20;};}else {_adf =4;_gc =4;};}else {_adf =2;_gc =0;};for _eb :=0;_eb < _adf ;_eb ++{_fa ,_gg =_ad .decodeIntBit (stats );if _gg !=nil {return 0,_gg ;
};_fc =(_fc <<1)|int32 (_fa );};_fc +=_gc ;if _ba ==0{return _fc ,nil ;}else if _ba ==1&&_fc > 0{return -_fc ,nil ;};return 0,_f .ErrOOB ;};func (_bbf *Decoder )mpsExchange (_bd *DecoderStats ,_bfa int32 )int {_bcf :=_bd ._ce [_bd ._eec ];if _bbf ._bg < _d [_bfa ][0]{if _d [_bfa ][3]==1{_bd .toggleMps ();
};_bd .setEntry (int (_d [_bfa ][2]));return int (1-_bcf );};_bd .setEntry (int (_d [_bfa ][1]));return int (_bcf );};func (_gbe *DecoderStats )String ()string {_beg :=&_be .Builder {};_beg .WriteString (_bc .Sprintf ("S\u0074\u0061\u0074\u0073\u003a\u0020\u0020\u0025\u0064\u000a",len (_gbe ._de )));
for _faf ,_egff :=range _gbe ._de {if _egff !=0{_beg .WriteString (_bc .Sprintf ("N\u006f\u0074\u0020\u007aer\u006f \u0061\u0074\u003a\u0020\u0025d\u0020\u002d\u0020\u0025\u0064\u000a",_faf ,_egff ));};};return _beg .String ();};func (_dc *DecoderStats )Overwrite (dNew *DecoderStats ){for _ecd :=0;
_ecd < len (_dc ._de );_ecd ++{_dc ._de [_ecd ]=dNew ._de [_ecd ];_dc ._ce [_ecd ]=dNew ._ce [_ecd ];};};func (_ebb *Decoder )init ()error {_ebb ._ag =_ebb ._fb .AbsolutePosition ();_ea ,_fba :=_ebb ._fb .ReadByte ();if _fba !=nil {_a .Log .Debug ("B\u0075\u0066\u0066\u0065\u0072\u0030 \u0072\u0065\u0061\u0064\u0042\u0079\u0074\u0065\u0020f\u0061\u0069\u006ce\u0064.\u0020\u0025\u0076",_fba );
return _fba ;};_ebb ._fe =_ea ;_ebb ._ac =uint64 (_ea )<<16;if _fba =_ebb .readByte ();_fba !=nil {return _fba ;};_ebb ._ac <<=7;_ebb ._c -=7;_ebb ._bg =0x8000;_ebb ._e ++;return nil ;};func (_gbd *DecoderStats )Copy ()*DecoderStats {_df :=&DecoderStats {_bac :_gbd ._bac ,_de :make ([]byte ,_gbd ._bac )};
copy (_df ._de ,_gbd ._de );return _df ;};func (_cae *Decoder )decodeIntBit (_ge *DecoderStats )(int ,error ){_ge .SetIndex (int32 (_cae ._af ));_ec ,_gb :=_cae .DecodeBit (_ge );if _gb !=nil {_a .Log .Debug ("\u0041\u0072\u0069\u0074\u0068\u006d\u0065t\u0069\u0063\u0044e\u0063\u006f\u0064e\u0072\u0020'\u0064\u0065\u0063\u006f\u0064\u0065I\u006etB\u0069\u0074\u0027\u002d\u003e\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0042\u0069\u0074\u0020\u0066\u0061\u0069\u006c\u0065\u0064\u002e\u0020\u0025\u0076",_gb );
return _ec ,_gb ;};if _cae ._af < 256{_cae ._af =((_cae ._af <<uint64 (1))|int64 (_ec ))&0x1ff;}else {_cae ._af =(((_cae ._af <<uint64 (1)|int64 (_ec ))&511)|256)&0x1ff;};return _ec ,nil ;};func (_ca *Decoder )DecodeIAID (codeLen uint64 ,stats *DecoderStats )(int64 ,error ){_ca ._af =1;
var _fg uint64 ;for _fg =0;_fg < codeLen ;_fg ++{stats .SetIndex (int32 (_ca ._af ));_db ,_eg :=_ca .DecodeBit (stats );if _eg !=nil {return 0,_eg ;};_ca ._af =(_ca ._af <<1)|int64 (_db );};_fgg :=_ca ._af -(1<<codeLen );return _fgg ,nil ;};func (_eae *DecoderStats )getMps ()byte {return _eae ._ce [_eae ._eec ]};
func (_cb *DecoderStats )toggleMps (){_cb ._ce [_cb ._eec ]^=1};var (_d =[][4]uint32 {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
);func (_fef *Decoder )DecodeBit (stats *DecoderStats )(int ,error ){var (_fd int ;_acd =_d [stats .cx ()][0];_cc =int32 (stats .cx ()););defer func (){_fef ._e ++}();_fef ._bg -=_acd ;if (_fef ._ac >>16)< uint64 (_acd ){_fd =_fef .lpsExchange (stats ,_cc ,_acd );
if _bef :=_fef .renormalize ();_bef !=nil {return 0,_bef ;};}else {_fef ._ac -=uint64 (_acd )<<16;if (_fef ._bg &0x8000)==0{_fd =_fef .mpsExchange (stats ,_cc );if _bb :=_fef .renormalize ();_bb !=nil {return 0,_bb ;};}else {_fd =int (stats .getMps ());
};};return _fd ,nil ;};func (_ced *DecoderStats )Reset (){for _acg :=0;_acg < len (_ced ._de );_acg ++{_ced ._de [_acg ]=0;_ced ._ce [_acg ]=0;};};func (_bcg *DecoderStats )setEntry (_ggb int ){_bge :=byte (_ggb &0x7f);_bcg ._de [_bcg ._eec ]=_bge };func (_bcbb *Decoder )renormalize ()error {for {if _bcbb ._c ==0{if _fce :=_bcbb .readByte ();
_fce !=nil {return _fce ;};};_bcbb ._bg <<=1;_bcbb ._ac <<=1;_bcbb ._c --;if (_bcbb ._bg &0x8000)!=0{break ;};};_bcbb ._ac &=0xffffffff;return nil ;};func (_cfa *DecoderStats )cx ()byte {return _cfa ._de [_cfa ._eec ]};func (_fbe *Decoder )lpsExchange (_ebg *DecoderStats ,_afa int32 ,_gae uint32 )int {_dba :=_ebg .getMps ();
if _fbe ._bg < _gae {_ebg .setEntry (int (_d [_afa ][1]));_fbe ._bg =_gae ;return int (_dba );};if _d [_afa ][3]==1{_ebg .toggleMps ();};_ebg .setEntry (int (_d [_afa ][2]));_fbe ._bg =_gae ;return int (1-_dba );};type DecoderStats struct{_eec int32 ;_bac int32 ;
_de []byte ;_ce []byte ;};func New (r *_bcb .Reader )(*Decoder ,error ){_cd :=&Decoder {_fb :r ,ContextSize :[]uint32 {16,13,10,10},ReferedToContextSize :[]uint32 {13,10}};if _ee :=_cd .init ();_ee !=nil {return nil ,_ee ;};return _cd ,nil ;};func NewStats (contextSize int32 ,index int32 )*DecoderStats {return &DecoderStats {_eec :index ,_bac :contextSize ,_de :make ([]byte ,contextSize ),_ce :make ([]byte ,contextSize )};
};func (_bf *Decoder )readByte ()error {if _bf ._fb .AbsolutePosition ()> _bf ._ag {if _ ,_bbb :=_bf ._fb .Seek (-1,_g .SeekCurrent );_bbb !=nil {return _bbb ;};};_bab ,_cf :=_bf ._fb .ReadByte ();if _cf !=nil {return _cf ;};_bf ._fe =_bab ;if _bf ._fe ==0xFF{_bbd ,_caf :=_bf ._fb .ReadByte ();
if _caf !=nil {return _caf ;};if _bbd > 0x8F{_bf ._ac +=0xFF00;_bf ._c =8;if _ ,_agf :=_bf ._fb .Seek (-2,_g .SeekCurrent );_agf !=nil {return _agf ;};}else {_bf ._ac +=uint64 (_bbd )<<9;_bf ._c =7;};}else {_bab ,_cf =_bf ._fb .ReadByte ();if _cf !=nil {return _cf ;
};_bf ._fe =_bab ;_bf ._ac +=uint64 (_bf ._fe )<<8;_bf ._c =8;};_bf ._ac &=0xFFFFFFFFFF;return nil ;};