//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_b "fmt";_dcd "github.com/unidoc/unipdf/v3/common";_a "github.com/unidoc/unipdf/v3/internal/bitwise";_dc "io";_dcb "math";_g "strings";);func New (r _a .StreamReader )(*Decoder ,error ){_ce :=&Decoder {_be :r ,ContextSize :[]uint32 {16,13,10,10},ReferedToContextSize :[]uint32 {13,10}};if _bc :=_ce .init ();_bc !=nil {return nil ,_bc ;};return _ce ,nil ;};func (_bgd *DecoderStats )Overwrite (dNew *DecoderStats ){for _adec :=0;_adec < len (_bgd ._fb );_adec ++{_bgd ._fb [_adec ]=dNew ._fb [_adec ];_bgd ._ebe [_adec ]=dNew ._ebe [_adec ];};};func (_ef *Decoder )DecodeIAID (codeLen uint64 ,stats *DecoderStats )(int64 ,error ){_ef ._db =1;var _ebd uint64 ;for _ebd =0;_ebd < codeLen ;_ebd ++{stats .SetIndex (int32 (_ef ._db ));_eeg ,_acb :=_ef .DecodeBit (stats );if _acb !=nil {return 0,_acb ;};_ef ._db =(_ef ._db <<1)|int64 (_eeg );};_gf :=_ef ._db -(1<<codeLen );return _gf ,nil ;};func (_faf *DecoderStats )getMps ()byte {return _faf ._ebe [_faf ._ae ]};func (_ded *DecoderStats )String ()string {_deg :=&_g .Builder {};_deg .WriteString (_b .Sprintf ("S\u0074\u0061\u0074\u0073\u003a\u0020\u0020\u0025\u0064\u000a",len (_ded ._fb )));for _gfb ,_dbb :=range _ded ._fb {if _dbb !=0{_deg .WriteString (_b .Sprintf ("N\u006f\u0074\u0020\u007aer\u006f \u0061\u0074\u003a\u0020\u0025d\u0020\u002d\u0020\u0025\u0064\u000a",_gfb ,_dbb ));};};return _deg .String ();};func (_ade *Decoder )DecodeBit (stats *DecoderStats )(int ,error ){var (_cc int ;_dcf =_f [stats .cx ()][0];_eb =int32 (stats .cx ()););defer func (){_ade ._c ++}();_ade ._bf -=_dcf ;if (_ade ._ad >>16)< uint64 (_dcf ){_cc =_ade .lpsExchange (stats ,_eb ,_dcf );if _ceg :=_ade .renormalize ();_ceg !=nil {return 0,_ceg ;};}else {_ade ._ad -=uint64 (_dcf )<<16;if (_ade ._bf &0x8000)==0{_cc =_ade .mpsExchange (stats ,_eb );if _ff :=_ade .renormalize ();_ff !=nil {return 0,_ff ;};}else {_cc =int (stats .getMps ());};};return _cc ,nil ;};func (_bfc *Decoder )init ()error {_bfc ._ee =_bfc ._be .StreamPosition ();_fcd ,_gfc :=_bfc ._be .ReadByte ();if _gfc !=nil {_dcd .Log .Debug ("B\u0075\u0066\u0066\u0065\u0072\u0030 \u0072\u0065\u0061\u0064\u0042\u0079\u0074\u0065\u0020f\u0061\u0069\u006ce\u0064.\u0020\u0025\u0076",_gfc );return _gfc ;};_bfc ._fc =_fcd ;_bfc ._ad =uint64 (_fcd )<<16;if _gfc =_bfc .readByte ();_gfc !=nil {return _gfc ;};_bfc ._ad <<=7;_bfc ._e -=7;_bfc ._bf =0x8000;_bfc ._c ++;return nil ;};func (_ag *Decoder )DecodeInt (stats *DecoderStats )(int32 ,error ){var (_adc ,_fg int32 ;_gc ,_ccd ,_gd int ;_ac error ;);if stats ==nil {stats =NewStats (512,1);};_ag ._db =1;_ccd ,_ac =_ag .decodeIntBit (stats );if _ac !=nil {return 0,_ac ;};_gc ,_ac =_ag .decodeIntBit (stats );if _ac !=nil {return 0,_ac ;};if _gc ==1{_gc ,_ac =_ag .decodeIntBit (stats );if _ac !=nil {return 0,_ac ;};if _gc ==1{_gc ,_ac =_ag .decodeIntBit (stats );if _ac !=nil {return 0,_ac ;};if _gc ==1{_gc ,_ac =_ag .decodeIntBit (stats );if _ac !=nil {return 0,_ac ;};if _gc ==1{_gc ,_ac =_ag .decodeIntBit (stats );if _ac !=nil {return 0,_ac ;};if _gc ==1{_gd =32;_fg =4436;}else {_gd =12;_fg =340;};}else {_gd =8;_fg =84;};}else {_gd =6;_fg =20;};}else {_gd =4;_fg =4;};}else {_gd =2;_fg =0;};for _cb :=0;_cb < _gd ;_cb ++{_gc ,_ac =_ag .decodeIntBit (stats );if _ac !=nil {return 0,_ac ;};_adc =(_adc <<1)|int32 (_gc );};_adc +=_fg ;if _ccd ==0{return _adc ,nil ;}else if _ccd ==1&&_adc > 0{return -_adc ,nil ;};return _dcb .MaxInt32 ,nil ;};func (_gfg *Decoder )renormalize ()error {for {if _gfg ._e ==0{if _ba :=_gfg .readByte ();_ba !=nil {return _ba ;};};_gfg ._bf <<=1;_gfg ._ad <<=1;_gfg ._e --;if (_gfg ._bf &0x8000)!=0{break ;};};_gfg ._ad &=0xffffffff;return nil ;};func (_ab *DecoderStats )cx ()byte {return _ab ._fb [_ab ._ae ]};func (_fa *DecoderStats )Reset (){for _ge :=0;_ge < len (_fa ._fb );_ge ++{_fa ._fb [_ge ]=0;_fa ._ebe [_ge ]=0;};};func NewStats (contextSize int32 ,index int32 )*DecoderStats {return &DecoderStats {_ae :index ,_eee :contextSize ,_fb :make ([]byte ,contextSize ),_ebe :make ([]byte ,contextSize )};};func (_fga *Decoder )mpsExchange (_cce *DecoderStats ,_gfcb int32 )int {_bg :=_cce ._ebe [_cce ._ae ];if _fga ._bf < _f [_gfcb ][0]{if _f [_gfcb ][3]==1{_cce .toggleMps ();};_cce .setEntry (int (_f [_gfcb ][2]));return int (1-_bg );};_cce .setEntry (int (_f [_gfcb ][1]));return int (_bg );};func (_bad *DecoderStats )toggleMps (){_bad ._ebe [_bad ._ae ]^=1};func (_ffa *Decoder )readByte ()error {if _ffa ._be .StreamPosition ()> _ffa ._ee {if _ ,_ffc :=_ffa ._be .Seek (-1,_dc .SeekCurrent );_ffc !=nil {return _ffc ;};};_ed ,_fe :=_ffa ._be .ReadByte ();if _fe !=nil {return _fe ;};_ffa ._fc =_ed ;if _ffa ._fc ==0xFF{_bb ,_gg :=_ffa ._be .ReadByte ();if _gg !=nil {return _gg ;};if _bb > 0x8F{_ffa ._ad +=0xFF00;_ffa ._e =8;if _ ,_gb :=_ffa ._be .Seek (-2,_dc .SeekCurrent );_gb !=nil {return _gb ;};}else {_ffa ._ad +=uint64 (_bb )<<9;_ffa ._e =7;};}else {_ed ,_fe =_ffa ._be .ReadByte ();if _fe !=nil {return _fe ;};_ffa ._fc =_ed ;_ffa ._ad +=uint64 (_ffa ._fc )<<8;_ffa ._e =8;};_ffa ._ad &=0xFFFFFFFFFF;return nil ;};type Decoder struct{ContextSize []uint32 ;ReferedToContextSize []uint32 ;_be _a .StreamReader ;_fc uint8 ;_ad uint64 ;_bf uint32 ;_db int64 ;_e int32 ;_c int32 ;_ee int64 ;};func (_eeee *DecoderStats )SetIndex (index int32 ){_eeee ._ae =index };type DecoderStats struct{_ae int32 ;_eee int32 ;_fb []byte ;_ebe []byte ;};var (_f =[][4]uint32 {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};);func (_ea *DecoderStats )setEntry (_feg int ){_gfgb :=byte (_feg &0x7f);_ea ._fb [_ea ._ae ]=_gfgb };func (_baf *Decoder )lpsExchange (_bfb *DecoderStats ,_cg int32 ,_fgc uint32 )int {_eg :=_bfb .getMps ();if _baf ._bf < _fgc {_bfb .setEntry (int (_f [_cg ][1]));_baf ._bf =_fgc ;return int (_eg );};if _f [_cg ][3]==1{_bfb .toggleMps ();};_bfb .setEntry (int (_f [_cg ][2]));_baf ._bf =_fgc ;return int (1-_eg );};func (_bfa *DecoderStats )Copy ()*DecoderStats {_ege :=&DecoderStats {_eee :_bfa ._eee ,_fb :make ([]byte ,_bfa ._eee )};for _acfg :=0;_acfg < len (_bfa ._fb );_acfg ++{_ege ._fb [_acfg ]=_bfa ._fb [_acfg ];};return _ege ;};func (_acf *Decoder )decodeIntBit (_dd *DecoderStats )(int ,error ){_dd .SetIndex (int32 (_acf ._db ));_ggg ,_cf :=_acf .DecodeBit (_dd );if _cf !=nil {_dcd .Log .Debug ("\u0041\u0072\u0069\u0074\u0068\u006d\u0065t\u0069\u0063\u0044e\u0063\u006f\u0064e\u0072\u0020'\u0064\u0065\u0063\u006f\u0064\u0065I\u006etB\u0069\u0074\u0027\u002d\u003e\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0042\u0069\u0074\u0020\u0066\u0061\u0069\u006c\u0065\u0064\u002e\u0020\u0025\u0076",_cf );return _ggg ,_cf ;};if _acf ._db < 256{_acf ._db =((_acf ._db <<uint64 (1))|int64 (_ggg ))&0x1ff;}else {_acf ._db =(((_acf ._db <<uint64 (1)|int64 (_ggg ))&511)|256)&0x1ff;};return _ggg ,nil ;};