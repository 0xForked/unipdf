//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_e "fmt";_bb "github.com/unidoc/unipdf/v3/common";_c "github.com/unidoc/unipdf/v3/internal/bitwise";_gc "github.com/unidoc/unipdf/v3/internal/jbig2/internal";_a "io";_b "strings";);func (_ddc *DecoderStats )toggleMps (){_ddc ._dag [_ddc ._af ]^=1};
func New (r _c .StreamReader )(*Decoder ,error ){_d :=&Decoder {_cf :r ,ContextSize :[]uint32 {16,13,10,10},ReferedToContextSize :[]uint32 {13,10}};if _ea :=_d .init ();_ea !=nil {return nil ,_ea ;};return _d ,nil ;};func (_fae *DecoderStats )Overwrite (dNew *DecoderStats ){for _ga :=0;
_ga < len (_fae ._gge );_ga ++{_fae ._gge [_ga ]=dNew ._gge [_ga ];_fae ._dag [_ga ]=dNew ._dag [_ga ];};};func (_ag *Decoder )decodeIntBit (_ce *DecoderStats )(int ,error ){_ce .SetIndex (int32 (_ag ._bd ));_ca ,_ge :=_ag .DecodeBit (_ce );if _ge !=nil {_bb .Log .Debug ("\u0041\u0072\u0069\u0074\u0068\u006d\u0065t\u0069\u0063\u0044e\u0063\u006f\u0064e\u0072\u0020'\u0064\u0065\u0063\u006f\u0064\u0065I\u006etB\u0069\u0074\u0027\u002d\u003e\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0042\u0069\u0074\u0020\u0066\u0061\u0069\u006c\u0065\u0064\u002e\u0020\u0025\u0076",_ge );
return _ca ,_ge ;};if _ag ._bd < 256{_ag ._bd =((_ag ._bd <<uint64 (1))|int64 (_ca ))&0x1ff;}else {_ag ._bd =(((_ag ._bd <<uint64 (1)|int64 (_ca ))&511)|256)&0x1ff;};return _ca ,nil ;};func (_df *DecoderStats )Reset (){for _fbb :=0;_fbb < len (_df ._gge );
_fbb ++{_df ._gge [_fbb ]=0;_df ._dag [_fbb ]=0;};};func (_be *Decoder )DecodeIAID (codeLen uint64 ,stats *DecoderStats )(int64 ,error ){_be ._bd =1;var _cfg uint64 ;for _cfg =0;_cfg < codeLen ;_cfg ++{stats .SetIndex (int32 (_be ._bd ));_ebg ,_da :=_be .DecodeBit (stats );
if _da !=nil {return 0,_da ;};_be ._bd =(_be ._bd <<1)|int64 (_ebg );};_aea :=_be ._bd -(1<<codeLen );return _aea ,nil ;};func (_ad *Decoder )init ()error {_ad ._gf =_ad ._cf .StreamPosition ();_cfgd ,_bbcf :=_ad ._cf .ReadByte ();if _bbcf !=nil {_bb .Log .Debug ("B\u0075\u0066\u0066\u0065\u0072\u0030 \u0072\u0065\u0061\u0064\u0042\u0079\u0074\u0065\u0020f\u0061\u0069\u006ce\u0064.\u0020\u0025\u0076",_bbcf );
return _bbcf ;};_ad ._ee =_cfgd ;_ad ._bc =uint64 (_cfgd )<<16;if _bbcf =_ad .readByte ();_bbcf !=nil {return _bbcf ;};_ad ._bc <<=7;_ad ._ae -=7;_ad ._fa =0x8000;_ad ._ef ++;return nil ;};func (_cg *Decoder )DecodeBit (stats *DecoderStats )(int ,error ){var (_ff int ;
_fg =_f [stats .cx ()][0];_eb =int32 (stats .cx ()););defer func (){_cg ._ef ++}();_cg ._fa -=_fg ;if (_cg ._bc >>16)< uint64 (_fg ){_ff =_cg .lpsExchange (stats ,_eb ,_fg );if _fc :=_cg .renormalize ();_fc !=nil {return 0,_fc ;};}else {_cg ._bc -=uint64 (_fg )<<16;
if (_cg ._fa &0x8000)==0{_ff =_cg .mpsExchange (stats ,_eb );if _eec :=_cg .renormalize ();_eec !=nil {return 0,_eec ;};}else {_ff =int (stats .getMps ());};};return _ff ,nil ;};func (_fad *Decoder )readByte ()error {if _fad ._cf .StreamPosition ()> _fad ._gf {if _ ,_gg :=_fad ._cf .Seek (-1,_a .SeekCurrent );
_gg !=nil {return _gg ;};};_beg ,_cc :=_fad ._cf .ReadByte ();if _cc !=nil {return _cc ;};_fad ._ee =_beg ;if _fad ._ee ==0xFF{_ac ,_ccd :=_fad ._cf .ReadByte ();if _ccd !=nil {return _ccd ;};if _ac > 0x8F{_fad ._bc +=0xFF00;_fad ._ae =8;if _ ,_bg :=_fad ._cf .Seek (-2,_a .SeekCurrent );
_bg !=nil {return _bg ;};}else {_fad ._bc +=uint64 (_ac )<<9;_fad ._ae =7;};}else {_beg ,_cc =_fad ._cf .ReadByte ();if _cc !=nil {return _cc ;};_fad ._ee =_beg ;_fad ._bc +=uint64 (_fad ._ee )<<8;_fad ._ae =8;};_fad ._bc &=0xFFFFFFFFFF;return nil ;};func (_bge *DecoderStats )cx ()byte {return _bge ._gge [_bge ._af ]};
func (_bda *DecoderStats )SetIndex (index int32 ){_bda ._af =index };func (_bfb *DecoderStats )getMps ()byte {return _bfb ._dag [_bfb ._af ]};func (_aga *DecoderStats )Copy ()*DecoderStats {_cd :=&DecoderStats {_ggc :_aga ._ggc ,_gge :make ([]byte ,_aga ._ggc )};
for _dac :=0;_dac < len (_aga ._gge );_dac ++{_cd ._gge [_dac ]=_aga ._gge [_dac ];};return _cd ;};type Decoder struct{ContextSize []uint32 ;ReferedToContextSize []uint32 ;_cf _c .StreamReader ;_ee uint8 ;_bc uint64 ;_fa uint32 ;_bd int64 ;_ae int32 ;_ef int32 ;
_gf int64 ;};func (_fgb *Decoder )renormalize ()error {for {if _fgb ._ae ==0{if _fb :=_fgb .readByte ();_fb !=nil {return _fb ;};};_fgb ._fa <<=1;_fgb ._bc <<=1;_fgb ._ae --;if (_fgb ._fa &0x8000)!=0{break ;};};_fgb ._bc &=0xffffffff;return nil ;};func (_gd *Decoder )lpsExchange (_fgbc *DecoderStats ,_gdg int32 ,_aec uint32 )int {_fe :=_fgbc .getMps ();
if _gd ._fa < _aec {_fgbc .setEntry (int (_f [_gdg ][1]));_gd ._fa =_aec ;return int (_fe );};if _f [_gdg ][3]==1{_fgbc .toggleMps ();};_fgbc .setEntry (int (_f [_gdg ][2]));_gd ._fa =_aec ;return int (1-_fe );};func (_gb *Decoder )mpsExchange (_cgf *DecoderStats ,_faff int32 )int {_fgf :=_cgf ._dag [_cgf ._af ];
if _gb ._fa < _f [_faff ][0]{if _f [_faff ][3]==1{_cgf .toggleMps ();};_cgf .setEntry (int (_f [_faff ][2]));return int (1-_fgf );};_cgf .setEntry (int (_f [_faff ][1]));return int (_fgf );};func (_gfb *Decoder )DecodeInt (stats *DecoderStats )(int32 ,error ){var (_aa ,_bbc int32 ;
_gcb ,_ba ,_bag int ;_dd error ;);if stats ==nil {stats =NewStats (512,1);};_gfb ._bd =1;_ba ,_dd =_gfb .decodeIntBit (stats );if _dd !=nil {return 0,_dd ;};_gcb ,_dd =_gfb .decodeIntBit (stats );if _dd !=nil {return 0,_dd ;};if _gcb ==1{_gcb ,_dd =_gfb .decodeIntBit (stats );
if _dd !=nil {return 0,_dd ;};if _gcb ==1{_gcb ,_dd =_gfb .decodeIntBit (stats );if _dd !=nil {return 0,_dd ;};if _gcb ==1{_gcb ,_dd =_gfb .decodeIntBit (stats );if _dd !=nil {return 0,_dd ;};if _gcb ==1{_gcb ,_dd =_gfb .decodeIntBit (stats );if _dd !=nil {return 0,_dd ;
};if _gcb ==1{_bag =32;_bbc =4436;}else {_bag =12;_bbc =340;};}else {_bag =8;_bbc =84;};}else {_bag =6;_bbc =20;};}else {_bag =4;_bbc =4;};}else {_bag =2;_bbc =0;};for _faf :=0;_faf < _bag ;_faf ++{_gcb ,_dd =_gfb .decodeIntBit (stats );if _dd !=nil {return 0,_dd ;
};_aa =(_aa <<1)|int32 (_gcb );};_aa +=_bbc ;if _ba ==0{return _aa ,nil ;}else if _ba ==1&&_aa > 0{return -_aa ,nil ;};return 0,_gc .ErrOOB ;};func (_eed *DecoderStats )String ()string {_bga :=&_b .Builder {};_bga .WriteString (_e .Sprintf ("S\u0074\u0061\u0074\u0073\u003a\u0020\u0020\u0025\u0064\u000a",len (_eed ._gge )));
for _ec ,_de :=range _eed ._gge {if _de !=0{_bga .WriteString (_e .Sprintf ("N\u006f\u0074\u0020\u007aer\u006f \u0061\u0074\u003a\u0020\u0025d\u0020\u002d\u0020\u0025\u0064\u000a",_ec ,_de ));};};return _bga .String ();};var (_f =[][4]uint32 {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
);func (_ab *DecoderStats )setEntry (_dc int ){_ggef :=byte (_dc &0x7f);_ab ._gge [_ab ._af ]=_ggef };func NewStats (contextSize int32 ,index int32 )*DecoderStats {return &DecoderStats {_af :index ,_ggc :contextSize ,_gge :make ([]byte ,contextSize ),_dag :make ([]byte ,contextSize )};
};type DecoderStats struct{_af int32 ;_ggc int32 ;_gge []byte ;_dag []byte ;};