//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_fe "fmt";_a "github.com/unidoc/unipdf/v3/common";_g "github.com/unidoc/unipdf/v3/internal/bitwise";_e "github.com/unidoc/unipdf/v3/internal/jbig2/internal";_d "io";_f "strings";);func (_be *Decoder )DecodeInt (stats *DecoderStats )(int32 ,error ){var (_eb ,_ca int32 ;_bac ,_fd ,_ab int ;_fa error ;);if stats ==nil {stats =NewStats (512,1);};_be ._fg =1;_fd ,_fa =_be .decodeIntBit (stats );if _fa !=nil {return 0,_fa ;};_bac ,_fa =_be .decodeIntBit (stats );if _fa !=nil {return 0,_fa ;};if _bac ==1{_bac ,_fa =_be .decodeIntBit (stats );if _fa !=nil {return 0,_fa ;};if _bac ==1{_bac ,_fa =_be .decodeIntBit (stats );if _fa !=nil {return 0,_fa ;};if _bac ==1{_bac ,_fa =_be .decodeIntBit (stats );if _fa !=nil {return 0,_fa ;};if _bac ==1{_bac ,_fa =_be .decodeIntBit (stats );if _fa !=nil {return 0,_fa ;};if _bac ==1{_ab =32;_ca =4436;}else {_ab =12;_ca =340;};}else {_ab =8;_ca =84;};}else {_ab =6;_ca =20;};}else {_ab =4;_ca =4;};}else {_ab =2;_ca =0;};for _fc :=0;_fc < _ab ;_fc ++{_bac ,_fa =_be .decodeIntBit (stats );if _fa !=nil {return 0,_fa ;};_eb =(_eb <<1)|int32 (_bac );};_eb +=_ca ;if _fd ==0{return _eb ,nil ;}else if _fd ==1&&_eb > 0{return -_eb ,nil ;};return 0,_e .ErrOOB ;};func (_cae *DecoderStats )String ()string {_dab :=&_f .Builder {};_dab .WriteString (_fe .Sprintf ("S\u0074\u0061\u0074\u0073\u003a\u0020\u0020\u0025\u0064\u000a",len (_cae ._bef )));for _fb ,_add :=range _cae ._bef {if _add !=0{_dab .WriteString (_fe .Sprintf ("N\u006f\u0074\u0020\u007aer\u006f \u0061\u0074\u003a\u0020\u0025d\u0020\u002d\u0020\u0025\u0064\u000a",_fb ,_add ));};};return _dab .String ();};func (_cbd *DecoderStats )getMps ()byte {return _cbd ._acb [_cbd ._gbb ]};func (_cc *Decoder )readByte ()error {if _cc ._c .StreamPosition ()> _cc ._ec {if _ ,_dfc :=_cc ._c .Seek (-1,_d .SeekCurrent );_dfc !=nil {return _dfc ;};};_baa ,_fag :=_cc ._c .ReadByte ();if _fag !=nil {return _fag ;};_cc ._gc =_baa ;if _cc ._gc ==0xFF{_ggd ,_cd :=_cc ._c .ReadByte ();if _cd !=nil {return _cd ;};if _ggd > 0x8F{_cc ._fef +=0xFF00;_cc ._cf =8;if _ ,_agf :=_cc ._c .Seek (-2,_d .SeekCurrent );_agf !=nil {return _agf ;};}else {_cc ._fef +=uint64 (_ggd )<<9;_cc ._cf =7;};}else {_baa ,_fag =_cc ._c .ReadByte ();if _fag !=nil {return _fag ;};_cc ._gc =_baa ;_cc ._fef +=uint64 (_cc ._gc )<<8;_cc ._cf =8;};_cc ._fef &=0xFFFFFFFFFF;return nil ;};func (_bg *Decoder )DecodeIAID (codeLen uint64 ,stats *DecoderStats )(int64 ,error ){_bg ._fg =1;var _cg uint64 ;for _cg =0;_cg < codeLen ;_cg ++{stats .SetIndex (int32 (_bg ._fg ));_bea ,_ge :=_bg .DecodeBit (stats );if _ge !=nil {return 0,_ge ;};_bg ._fg =(_bg ._fg <<1)|int64 (_bea );};_bc :=_bg ._fg -(1<<codeLen );return _bc ,nil ;};func NewStats (contextSize int32 ,index int32 )*DecoderStats {return &DecoderStats {_gbb :index ,_eff :contextSize ,_bef :make ([]byte ,contextSize ),_acb :make ([]byte ,contextSize )};};func (_dfa *Decoder )init ()error {_dfa ._ec =_dfa ._c .StreamPosition ();_gb ,_gd :=_dfa ._c .ReadByte ();if _gd !=nil {_a .Log .Debug ("B\u0075\u0066\u0066\u0065\u0072\u0030 \u0072\u0065\u0061\u0064\u0042\u0079\u0074\u0065\u0020f\u0061\u0069\u006ce\u0064.\u0020\u0025\u0076",_gd );return _gd ;};_dfa ._gc =_gb ;_dfa ._fef =uint64 (_gb )<<16;if _gd =_dfa .readByte ();_gd !=nil {return _gd ;};_dfa ._fef <<=7;_dfa ._cf -=7;_dfa ._dg =0x8000;_dfa ._ce ++;return nil ;};func (_bca *DecoderStats )SetIndex (index int32 ){_bca ._gbb =index };func (_eg *Decoder )decodeIntBit (_cgb *DecoderStats )(int ,error ){_cgb .SetIndex (int32 (_eg ._fg ));_ac ,_de :=_eg .DecodeBit (_cgb );if _de !=nil {_a .Log .Debug ("\u0041\u0072\u0069\u0074\u0068\u006d\u0065t\u0069\u0063\u0044e\u0063\u006f\u0064e\u0072\u0020'\u0064\u0065\u0063\u006f\u0064\u0065I\u006etB\u0069\u0074\u0027\u002d\u003e\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0042\u0069\u0074\u0020\u0066\u0061\u0069\u006c\u0065\u0064\u002e\u0020\u0025\u0076",_de );return _ac ,_de ;};if _eg ._fg < 256{_eg ._fg =((_eg ._fg <<uint64 (1))|int64 (_ac ))&0x1ff;}else {_eg ._fg =(((_eg ._fg <<uint64 (1)|int64 (_ac ))&511)|256)&0x1ff;};return _ac ,nil ;};func (_eec *DecoderStats )Copy ()*DecoderStats {_dbc :=&DecoderStats {_eff :_eec ._eff ,_bef :make ([]byte ,_eec ._eff )};for _ecf :=0;_ecf < len (_eec ._bef );_ecf ++{_dbc ._bef [_ecf ]=_eec ._bef [_ecf ];};return _dbc ;};func (_edc *DecoderStats )setEntry (_beg int ){_gf :=byte (_beg &0x7f);_edc ._bef [_edc ._gbb ]=_gf };type Decoder struct{ContextSize []uint32 ;ReferedToContextSize []uint32 ;_c _g .StreamReader ;_gc uint8 ;_fef uint64 ;_dg uint32 ;_fg int64 ;_cf int32 ;_ce int32 ;_ec int64 ;};func (_eba *DecoderStats )Reset (){for _gef :=0;_gef < len (_eba ._bef );_gef ++{_eba ._bef [_gef ]=0;_eba ._acb [_gef ]=0;};};func (_ceg *DecoderStats )Overwrite (dNew *DecoderStats ){for _dge :=0;_dge < len (_ceg ._bef );_dge ++{_ceg ._bef [_dge ]=dNew ._bef [_dge ];_ceg ._acb [_dge ]=dNew ._acb [_dge ];};};func (_ae *Decoder )DecodeBit (stats *DecoderStats )(int ,error ){var (_gg int ;_db =_df [stats .cx ()][0];_bd =int32 (stats .cx ()););defer func (){_ae ._ce ++}();_ae ._dg -=_db ;if (_ae ._fef >>16)< uint64 (_db ){_gg =_ae .lpsExchange (stats ,_bd ,_db );if _ga :=_ae .renormalize ();_ga !=nil {return 0,_ga ;};}else {_ae ._fef -=uint64 (_db )<<16;if (_ae ._dg &0x8000)==0{_gg =_ae .mpsExchange (stats ,_bd );if _ag :=_ae .renormalize ();_ag !=nil {return 0,_ag ;};}else {_gg =int (stats .getMps ());};};return _gg ,nil ;};func (_ee *Decoder )mpsExchange (_ef *DecoderStats ,_ege int32 )int {_gde :=_ef ._acb [_ef ._gbb ];if _ee ._dg < _df [_ege ][0]{if _df [_ege ][3]==1{_ef .toggleMps ();};_ef .setEntry (int (_df [_ege ][2]));return int (1-_gde );};_ef .setEntry (int (_df [_ege ][1]));return int (_gde );};var (_df =[][4]uint32 {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};);func (_ad *Decoder )lpsExchange (_cb *DecoderStats ,_cbb int32 ,_fdg uint32 )int {_fab :=_cb .getMps ();if _ad ._dg < _fdg {_cb .setEntry (int (_df [_cbb ][1]));_ad ._dg =_fdg ;return int (_fab );};if _df [_cbb ][3]==1{_cb .toggleMps ();};_cb .setEntry (int (_df [_cbb ][2]));_ad ._dg =_fdg ;return int (1-_fab );};type DecoderStats struct{_gbb int32 ;_eff int32 ;_bef []byte ;_acb []byte ;};func (_dc *DecoderStats )toggleMps (){_dc ._acb [_dc ._gbb ]^=1};func New (r _g .StreamReader )(*Decoder ,error ){_ced :=&Decoder {_c :r ,ContextSize :[]uint32 {16,13,10,10},ReferedToContextSize :[]uint32 {13,10}};if _ba :=_ced .init ();_ba !=nil {return nil ,_ba ;};return _ced ,nil ;};func (_fgd *Decoder )renormalize ()error {for {if _fgd ._cf ==0{if _cec :=_fgd .readByte ();_cec !=nil {return _cec ;};};_fgd ._dg <<=1;_fgd ._fef <<=1;_fgd ._cf --;if (_fgd ._dg &0x8000)!=0{break ;};};_fgd ._fef &=0xffffffff;return nil ;};func (_dbe *DecoderStats )cx ()byte {return _dbe ._bef [_dbe ._gbb ]};