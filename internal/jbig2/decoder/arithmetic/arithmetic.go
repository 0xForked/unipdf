//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_de "fmt";_a "github.com/unidoc/unipdf/v3/common";_cf "github.com/unidoc/unipdf/v3/internal/bitwise";_d "io";_ded "math";_c "strings";);func (_ffe *DecoderStats )String ()string {_bae :=&_c .Builder {};_bae .WriteString (_de .Sprintf ("S\u0074\u0061\u0074\u0073\u003a\u0020\u0020\u0025\u0064\u000a",len (_ffe ._db )));for _bb ,_ede :=range _ffe ._db {if _ede !=0{_bae .WriteString (_de .Sprintf ("N\u006f\u0074\u0020\u007aer\u006f \u0061\u0074\u003a\u0020\u0025d\u0020\u002d\u0020\u0025\u0064\u000a",_bb ,_ede ));};};return _bae .String ();};func (_dea *DecoderStats )Copy ()*DecoderStats {_bde :=&DecoderStats {_gef :_dea ._gef ,_db :make ([]byte ,_dea ._gef )};for _bef :=0;_bef < len (_dea ._db );_bef ++{_bde ._db [_bef ]=_dea ._db [_bef ];};return _bde ;};func (_ga *Decoder )readByte ()error {if _ga ._g .StreamPosition ()> _ga ._f {if _ ,_ec :=_ga ._g .Seek (-1,_d .SeekCurrent );_ec !=nil {return _ec ;};};_cfa ,_ef :=_ga ._g .ReadByte ();if _ef !=nil {return _ef ;};_ga ._dg =_cfa ;if _ga ._dg ==0xFF{_dd ,_ccb :=_ga ._g .ReadByte ();if _ccb !=nil {return _ccb ;};if _dd > 0x8F{_ga ._gf +=0xFF00;_ga ._aaf =8;if _ ,_faa :=_ga ._g .Seek (-2,_d .SeekCurrent );_faa !=nil {return _faa ;};}else {_ga ._gf +=uint64 (_dd )<<9;_ga ._aaf =7;};}else {_cfa ,_ef =_ga ._g .ReadByte ();if _ef !=nil {return _ef ;};_ga ._dg =_cfa ;_ga ._gf +=uint64 (_ga ._dg )<<8;_ga ._aaf =8;};_ga ._gf &=0xFFFFFFFFFF;return nil ;};func (_bc *DecoderStats )toggleMps (){_bc ._cea [_bc ._efa ]^=1};func (_dgg *Decoder )renormalize ()error {for {if _dgg ._aaf ==0{if _eeg :=_dgg .readByte ();_eeg !=nil {return _eeg ;};};_dgg ._ag <<=1;_dgg ._gf <<=1;_dgg ._aaf --;if (_dgg ._ag &0x8000)!=0{break ;};};_dgg ._gf &=0xffffffff;return nil ;};func (_ccfa *DecoderStats )Reset (){for _cfg :=0;_cfg < len (_ccfa ._db );_cfg ++{_ccfa ._db [_cfg ]=0;_ccfa ._cea [_cfg ]=0;};};func (_ac *Decoder )init ()error {_ac ._f =_ac ._g .StreamPosition ();_cfc ,_dga :=_ac ._g .ReadByte ();if _dga !=nil {_a .Log .Debug ("B\u0075\u0066\u0066\u0065\u0072\u0030 \u0072\u0065\u0061\u0064\u0042\u0079\u0074\u0065\u0020f\u0061\u0069\u006ce\u0064.\u0020\u0025\u0076",_dga );return _dga ;};_ac ._dg =_cfc ;_ac ._gf =uint64 (_cfc )<<16;if _dga =_ac .readByte ();_dga !=nil {return _dga ;};_ac ._gf <<=7;_ac ._aaf -=7;_ac ._ag =0x8000;_ac ._ee ++;return nil ;};func New (r _cf .StreamReader )(*Decoder ,error ){_agc :=&Decoder {_g :r ,ContextSize :[]uint32 {16,13,10,10},ReferedToContextSize :[]uint32 {13,10}};if _b :=_agc .init ();_b !=nil {return nil ,_b ;};return _agc ,nil ;};type DecoderStats struct{_efa int32 ;_gef int32 ;_db []byte ;_cea []byte ;};func (_eef *DecoderStats )Overwrite (dNew *DecoderStats ){for _bdg :=0;_bdg < len (_eef ._db );_bdg ++{_eef ._db [_bdg ]=dNew ._db [_bdg ];_eef ._cea [_bdg ]=dNew ._cea [_bdg ];};};type Decoder struct{ContextSize []uint32 ;ReferedToContextSize []uint32 ;_g _cf .StreamReader ;_dg uint8 ;_gf uint64 ;_ag uint32 ;_gd int64 ;_aaf int32 ;_ee int32 ;_f int64 ;};func (_feb *DecoderStats )setEntry (_ggg int ){_fbf :=byte (_ggg &0x7f);_feb ._db [_feb ._efa ]=_fbf };func (_gb *Decoder )lpsExchange (_cfce *DecoderStats ,_fb int32 ,_gfa uint32 )int {_gde :=_cfce .getMps ();if _gb ._ag < _gfa {_cfce .setEntry (int (_aa [_fb ][1]));_gb ._ag =_gfa ;return int (_gde );};if _aa [_fb ][3]==1{_cfce .toggleMps ();};_cfce .setEntry (int (_aa [_fb ][2]));_gb ._ag =_gfa ;return int (1-_gde );};func (_cde *Decoder )DecodeInt (stats *DecoderStats )(int32 ,error ){var (_ed ,_af int32 ;_egb ,_dgc ,_aab int ;_gg error ;);if stats ==nil {stats =NewStats (512,1);};_cde ._gd =1;_dgc ,_gg =_cde .decodeIntBit (stats );if _gg !=nil {return 0,_gg ;};_egb ,_gg =_cde .decodeIntBit (stats );if _gg !=nil {return 0,_gg ;};if _egb ==1{_egb ,_gg =_cde .decodeIntBit (stats );if _gg !=nil {return 0,_gg ;};if _egb ==1{_egb ,_gg =_cde .decodeIntBit (stats );if _gg !=nil {return 0,_gg ;};if _egb ==1{_egb ,_gg =_cde .decodeIntBit (stats );if _gg !=nil {return 0,_gg ;};if _egb ==1{_egb ,_gg =_cde .decodeIntBit (stats );if _gg !=nil {return 0,_gg ;};if _egb ==1{_aab =32;_af =4436;}else {_aab =12;_af =340;};}else {_aab =8;_af =84;};}else {_aab =6;_af =20;};}else {_aab =4;_af =4;};}else {_aab =2;_af =0;};for _aabf :=0;_aabf < _aab ;_aabf ++{_egb ,_gg =_cde .decodeIntBit (stats );if _gg !=nil {return 0,_gg ;};_ed =(_ed <<1)|int32 (_egb );};_ed +=_af ;if _dgc ==0{return _ed ,nil ;}else if _dgc ==1&&_ed > 0{return -_ed ,nil ;};return _ded .MaxInt32 ,nil ;};func NewStats (contextSize int32 ,index int32 )*DecoderStats {return &DecoderStats {_efa :index ,_gef :contextSize ,_db :make ([]byte ,contextSize ),_cea :make ([]byte ,contextSize )};};func (_bd *Decoder )DecodeBit (stats *DecoderStats )(int ,error ){var (_cd int ;_cb =_aa [stats .cx ()][0];_ce =int32 (stats .cx ()););defer func (){_bd ._ee ++}();_bd ._ag -=_cb ;if (_bd ._gf >>16)< uint64 (_cb ){_cd =_bd .lpsExchange (stats ,_ce ,_cb );if _eg :=_bd .renormalize ();_eg !=nil {return 0,_eg ;};}else {_bd ._gf -=uint64 (_cb )<<16;if (_bd ._ag &0x8000)==0{_cd =_bd .mpsExchange (stats ,_ce );if _bf :=_bd .renormalize ();_bf !=nil {return 0,_bf ;};}else {_cd =int (stats .getMps ());};};return _cd ,nil ;};func (_fe *Decoder )decodeIntBit (_gfd *DecoderStats )(int ,error ){_gfd .SetIndex (int32 (_fe ._gd ));_fc ,_ba :=_fe .DecodeBit (_gfd );if _ba !=nil {_a .Log .Debug ("\u0041\u0072\u0069\u0074\u0068\u006d\u0065t\u0069\u0063\u0044e\u0063\u006f\u0064e\u0072\u0020'\u0064\u0065\u0063\u006f\u0064\u0065I\u006etB\u0069\u0074\u0027\u002d\u003e\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0042\u0069\u0074\u0020\u0066\u0061\u0069\u006c\u0065\u0064\u002e\u0020\u0025\u0076",_ba );return _fc ,_ba ;};if _fe ._gd < 256{_fe ._gd =((_fe ._gd <<uint64 (1))|int64 (_fc ))&0x1ff;}else {_fe ._gd =(((_fe ._gd <<uint64 (1)|int64 (_fc ))&511)|256)&0x1ff;};return _fc ,nil ;};func (_ea *DecoderStats )cx ()byte {return _ea ._db [_ea ._efa ]};func (_ge *Decoder )DecodeIAID (codeLen uint64 ,stats *DecoderStats )(int64 ,error ){_ge ._gd =1;var _cc uint64 ;for _cc =0;_cc < codeLen ;_cc ++{stats .SetIndex (int32 (_ge ._gd ));_fa ,_ccf :=_ge .DecodeBit (stats );if _ccf !=nil {return 0,_ccf ;};_ge ._gd =(_ge ._gd <<1)|int64 (_fa );};_afd :=_ge ._gd -(1<<codeLen );return _afd ,nil ;};func (_aaa *DecoderStats )getMps ()byte {return _aaa ._cea [_aaa ._efa ]};func (_egc *Decoder )mpsExchange (_fg *DecoderStats ,_fab int32 )int {_ab :=_fg ._cea [_fg ._efa ];if _egc ._ag < _aa [_fab ][0]{if _aa [_fab ][3]==1{_fg .toggleMps ();};_fg .setEntry (int (_aa [_fab ][2]));return int (1-_ab );};_fg .setEntry (int (_aa [_fab ][1]));return int (_ab );};var (_aa =[][4]uint32 {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};);func (_cbf *DecoderStats )SetIndex (index int32 ){_cbf ._efa =index };