//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_db "fmt";_a "github.com/unidoc/unipdf/v3/common";_b "github.com/unidoc/unipdf/v3/internal/bitwise";_dd "github.com/unidoc/unipdf/v3/internal/jbig2/internal";_d "io";_g "strings";);func (_baa *DecoderStats )cx ()byte {return _baa ._ea [_baa ._ed ]};
func (_fae *DecoderStats )toggleMps (){_fae ._deb [_fae ._ed ]^=1};func (_gf *DecoderStats )Overwrite (dNew *DecoderStats ){for _cad :=0;_cad < len (_gf ._ea );_cad ++{_gf ._ea [_cad ]=dNew ._ea [_cad ];_gf ._deb [_cad ]=dNew ._deb [_cad ];};};func (_bcf *DecoderStats )Copy ()*DecoderStats {_cgb :=&DecoderStats {_fba :_bcf ._fba ,_ea :make ([]byte ,_bcf ._fba )};
copy (_cgb ._ea ,_bcf ._ea );return _cgb ;};var (_gb =[][4]uint32 {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
);func (_cea *DecoderStats )SetIndex (index int32 ){_cea ._ed =index };func (_bb *Decoder )init ()error {_bb ._ca =_bb ._bd .AbsolutePosition ();_ee ,_af :=_bb ._bd .ReadByte ();if _af !=nil {_a .Log .Debug ("B\u0075\u0066\u0066\u0065\u0072\u0030 \u0072\u0065\u0061\u0064\u0042\u0079\u0074\u0065\u0020f\u0061\u0069\u006ce\u0064.\u0020\u0025\u0076",_af );
return _af ;};_bb ._cg =_ee ;_bb ._gd =uint64 (_ee )<<16;if _af =_bb .readByte ();_af !=nil {return _af ;};_bb ._gd <<=7;_bb ._gbf -=7;_bb ._bc =0x8000;_bb ._ad ++;return nil ;};func (_cd *Decoder )decodeIntBit (_ffd *DecoderStats )(int ,error ){_ffd .SetIndex (int32 (_cd ._df ));
_fa ,_dbad :=_cd .DecodeBit (_ffd );if _dbad !=nil {_a .Log .Debug ("\u0041\u0072\u0069\u0074\u0068\u006d\u0065t\u0069\u0063\u0044e\u0063\u006f\u0064e\u0072\u0020'\u0064\u0065\u0063\u006f\u0064\u0065I\u006etB\u0069\u0074\u0027\u002d\u003e\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0042\u0069\u0074\u0020\u0066\u0061\u0069\u006c\u0065\u0064\u002e\u0020\u0025\u0076",_dbad );
return _fa ,_dbad ;};if _cd ._df < 256{_cd ._df =((_cd ._df <<uint64 (1))|int64 (_fa ))&0x1ff;}else {_cd ._df =(((_cd ._df <<uint64 (1)|int64 (_fa ))&511)|256)&0x1ff;};return _fa ,nil ;};func (_cag *DecoderStats )getMps ()byte {return _cag ._deb [_cag ._ed ]};
type DecoderStats struct{_ed int32 ;_fba int32 ;_ea []byte ;_deb []byte ;};func (_cc *Decoder )readByte ()error {if _cc ._bd .AbsolutePosition ()> _cc ._ca {if _ ,_bbf :=_cc ._bd .Seek (-1,_d .SeekCurrent );_bbf !=nil {return _bbf ;};};_fc ,_eg :=_cc ._bd .ReadByte ();
if _eg !=nil {return _eg ;};_cc ._cg =_fc ;if _cc ._cg ==0xFF{_gc ,_ec :=_cc ._bd .ReadByte ();if _ec !=nil {return _ec ;};if _gc > 0x8F{_cc ._gd +=0xFF00;_cc ._gbf =8;if _ ,_ac :=_cc ._bd .Seek (-2,_d .SeekCurrent );_ac !=nil {return _ac ;};}else {_cc ._gd +=uint64 (_gc )<<9;
_cc ._gbf =7;};}else {_fc ,_eg =_cc ._bd .ReadByte ();if _eg !=nil {return _eg ;};_cc ._cg =_fc ;_cc ._gd +=uint64 (_cc ._cg )<<8;_cc ._gbf =8;};_cc ._gd &=0xFFFFFFFFFF;return nil ;};func (_ba *Decoder )DecodeInt (stats *DecoderStats )(int32 ,error ){var (_ce ,_ade int32 ;
_gbg ,_degf ,_fe int ;_dba error ;);if stats ==nil {stats =NewStats (512,1);};_ba ._df =1;_degf ,_dba =_ba .decodeIntBit (stats );if _dba !=nil {return 0,_dba ;};_gbg ,_dba =_ba .decodeIntBit (stats );if _dba !=nil {return 0,_dba ;};if _gbg ==1{_gbg ,_dba =_ba .decodeIntBit (stats );
if _dba !=nil {return 0,_dba ;};if _gbg ==1{_gbg ,_dba =_ba .decodeIntBit (stats );if _dba !=nil {return 0,_dba ;};if _gbg ==1{_gbg ,_dba =_ba .decodeIntBit (stats );if _dba !=nil {return 0,_dba ;};if _gbg ==1{_gbg ,_dba =_ba .decodeIntBit (stats );if _dba !=nil {return 0,_dba ;
};if _gbg ==1{_fe =32;_ade =4436;}else {_fe =12;_ade =340;};}else {_fe =8;_ade =84;};}else {_fe =6;_ade =20;};}else {_fe =4;_ade =4;};}else {_fe =2;_ade =0;};for _bcg :=0;_bcg < _fe ;_bcg ++{_gbg ,_dba =_ba .decodeIntBit (stats );if _dba !=nil {return 0,_dba ;
};_ce =(_ce <<1)|int32 (_gbg );};_ce +=_ade ;if _degf ==0{return _ce ,nil ;}else if _degf ==1&&_ce > 0{return -_ce ,nil ;};return 0,_dd .ErrOOB ;};func (_eebf *DecoderStats )String ()string {_ece :=&_g .Builder {};_ece .WriteString (_db .Sprintf ("S\u0074\u0061\u0074\u0073\u003a\u0020\u0020\u0025\u0064\u000a",len (_eebf ._ea )));
for _geb ,_gbe :=range _eebf ._ea {if _gbe !=0{_ece .WriteString (_db .Sprintf ("N\u006f\u0074\u0020\u007aer\u006f \u0061\u0074\u003a\u0020\u0025d\u0020\u002d\u0020\u0025\u0064\u000a",_geb ,_gbe ));};};return _ece .String ();};func (_f *Decoder )DecodeBit (stats *DecoderStats )(int ,error ){var (_de int ;
_fb =_gb [stats .cx ()][0];_da =int32 (stats .cx ()););defer func (){_f ._ad ++}();_f ._bc -=_fb ;if (_f ._gd >>16)< uint64 (_fb ){_de =_f .lpsExchange (stats ,_da ,_fb );if _deg :=_f .renormalize ();_deg !=nil {return 0,_deg ;};}else {_f ._gd -=uint64 (_fb )<<16;
if (_f ._bc &0x8000)==0{_de =_f .mpsExchange (stats ,_da );if _ge :=_f .renormalize ();_ge !=nil {return 0,_ge ;};}else {_de =int (stats .getMps ());};};return _de ,nil ;};type Decoder struct{ContextSize []uint32 ;ReferedToContextSize []uint32 ;_bd *_b .Reader ;
_cg uint8 ;_gd uint64 ;_bc uint32 ;_df int64 ;_gbf int32 ;_ad int32 ;_ca int64 ;};func (_ddg *Decoder )lpsExchange (_dae *DecoderStats ,_gce int32 ,_daf uint32 )int {_eeb :=_dae .getMps ();if _ddg ._bc < _daf {_dae .setEntry (int (_gb [_gce ][1]));_ddg ._bc =_daf ;
return int (_eeb );};if _gb [_gce ][3]==1{_dae .toggleMps ();};_dae .setEntry (int (_gb [_gce ][2]));_ddg ._bc =_daf ;return int (1-_eeb );};func (_bdd *Decoder )renormalize ()error {for {if _bdd ._gbf ==0{if _gge :=_bdd .readByte ();_gge !=nil {return _gge ;
};};_bdd ._bc <<=1;_bdd ._gd <<=1;_bdd ._gbf --;if (_bdd ._bc &0x8000)!=0{break ;};};_bdd ._gd &=0xffffffff;return nil ;};func (_fee *Decoder )mpsExchange (_bdc *DecoderStats ,_ced int32 )int {_dbd :=_bdc ._deb [_bdc ._ed ];if _fee ._bc < _gb [_ced ][0]{if _gb [_ced ][3]==1{_bdc .toggleMps ();
};_bdc .setEntry (int (_gb [_ced ][2]));return int (1-_dbd );};_bdc .setEntry (int (_gb [_ced ][1]));return int (_dbd );};func (_faa *DecoderStats )Reset (){for _bf :=0;_bf < len (_faa ._ea );_bf ++{_faa ._ea [_bf ]=0;_faa ._deb [_bf ]=0;};};func (_bfc *DecoderStats )setEntry (_cb int ){_dg :=byte (_cb &0x7f);
_bfc ._ea [_bfc ._ed ]=_dg };func (_ab *Decoder )DecodeIAID (codeLen uint64 ,stats *DecoderStats )(int64 ,error ){_ab ._df =1;var _gg uint64 ;for _gg =0;_gg < codeLen ;_gg ++{stats .SetIndex (int32 (_ab ._df ));_dc ,_cac :=_ab .DecodeBit (stats );if _cac !=nil {return 0,_cac ;
};_ab ._df =(_ab ._df <<1)|int64 (_dc );};_ff :=_ab ._df -(1<<codeLen );return _ff ,nil ;};func NewStats (contextSize int32 ,index int32 )*DecoderStats {return &DecoderStats {_ed :index ,_fba :contextSize ,_ea :make ([]byte ,contextSize ),_deb :make ([]byte ,contextSize )};
};func New (r *_b .Reader )(*Decoder ,error ){_ada :=&Decoder {_bd :r ,ContextSize :[]uint32 {16,13,10,10},ReferedToContextSize :[]uint32 {13,10}};if _e :=_ada .init ();_e !=nil {return nil ,_e ;};return _ada ,nil ;};