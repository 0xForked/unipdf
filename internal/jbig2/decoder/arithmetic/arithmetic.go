//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_d "fmt";_da "github.com/unidoc/unipdf/v3/common";_g "github.com/unidoc/unipdf/v3/internal/bitwise";_ge "github.com/unidoc/unipdf/v3/internal/jbig2/internal";_b "io";_a "strings";);func (_af *DecoderStats )Overwrite (dNew *DecoderStats ){for _fef :=0;
_fef < len (_af ._aae );_fef ++{_af ._aae [_fef ]=dNew ._aae [_fef ];_af ._eg [_fef ]=dNew ._eg [_fef ];};};func (_geg *Decoder )DecodeIAID (codeLen uint64 ,stats *DecoderStats )(int64 ,error ){_geg ._eb =1;var _ec uint64 ;for _ec =0;_ec < codeLen ;_ec ++{stats .SetIndex (int32 (_geg ._eb ));
_bd ,_ae :=_geg .DecodeBit (stats );if _ae !=nil {return 0,_ae ;};_geg ._eb =(_geg ._eb <<1)|int64 (_bd );};_dc :=_geg ._eb -(1<<codeLen );return _dc ,nil ;};func (_ccc *DecoderStats )cx ()byte {return _ccc ._aae [_ccc ._ecg ]};func (_ag *DecoderStats )Copy ()*DecoderStats {_dba :=&DecoderStats {_fg :_ag ._fg ,_aae :make ([]byte ,_ag ._fg )};
for _bcb :=0;_bcb < len (_ag ._aae );_bcb ++{_dba ._aae [_bcb ]=_ag ._aae [_bcb ];};return _dba ;};func (_dca *Decoder )readByte ()error {if _dca ._db .StreamPosition ()> _dca ._df {if _ ,_ac :=_dca ._db .Seek (-1,_b .SeekCurrent );_ac !=nil {return _ac ;
};};_bae ,_bbc :=_dca ._db .ReadByte ();if _bbc !=nil {return _bbc ;};_dca ._dg =_bae ;if _dca ._dg ==0xFF{_be ,_bad :=_dca ._db .ReadByte ();if _bad !=nil {return _bad ;};if _be > 0x8F{_dca ._ed +=0xFF00;_dca ._fc =8;if _ ,_aef :=_dca ._db .Seek (-2,_b .SeekCurrent );
_aef !=nil {return _aef ;};}else {_dca ._ed +=uint64 (_be )<<9;_dca ._fc =7;};}else {_bae ,_bbc =_dca ._db .ReadByte ();if _bbc !=nil {return _bbc ;};_dca ._dg =_bae ;_dca ._ed +=uint64 (_dca ._dg )<<8;_dca ._fc =8;};_dca ._ed &=0xFFFFFFFFFF;return nil ;
};func (_faa *Decoder )decodeIntBit (_dbd *DecoderStats )(int ,error ){_dbd .SetIndex (int32 (_faa ._eb ));_gbe ,_cbef :=_faa .DecodeBit (_dbd );if _cbef !=nil {_da .Log .Debug ("\u0041\u0072\u0069\u0074\u0068\u006d\u0065t\u0069\u0063\u0044e\u0063\u006f\u0064e\u0072\u0020'\u0064\u0065\u0063\u006f\u0064\u0065I\u006etB\u0069\u0074\u0027\u002d\u003e\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0042\u0069\u0074\u0020\u0066\u0061\u0069\u006c\u0065\u0064\u002e\u0020\u0025\u0076",_cbef );
return _gbe ,_cbef ;};if _faa ._eb < 256{_faa ._eb =((_faa ._eb <<uint64 (1))|int64 (_gbe ))&0x1ff;}else {_faa ._eb =(((_faa ._eb <<uint64 (1)|int64 (_gbe ))&511)|256)&0x1ff;};return _gbe ,nil ;};func (_ce *Decoder )init ()error {_ce ._df =_ce ._db .StreamPosition ();
_fce ,_fae :=_ce ._db .ReadByte ();if _fae !=nil {_da .Log .Debug ("B\u0075\u0066\u0066\u0065\u0072\u0030 \u0072\u0065\u0061\u0064\u0042\u0079\u0074\u0065\u0020f\u0061\u0069\u006ce\u0064.\u0020\u0025\u0076",_fae );return _fae ;};_ce ._dg =_fce ;_ce ._ed =uint64 (_fce )<<16;
if _fae =_ce .readByte ();_fae !=nil {return _fae ;};_ce ._ed <<=7;_ce ._fc -=7;_ce ._f =0x8000;_ce ._bf ++;return nil ;};func (_dcd *Decoder )lpsExchange (_dag *DecoderStats ,_dad int32 ,_cef uint32 )int {_cefa :=_dag .getMps ();if _dcd ._f < _cef {_dag .setEntry (int (_bc [_dad ][1]));
_dcd ._f =_cef ;return int (_cefa );};if _bc [_dad ][3]==1{_dag .toggleMps ();};_dag .setEntry (int (_bc [_dad ][2]));_dcd ._f =_cef ;return int (1-_cefa );};type DecoderStats struct{_ecg int32 ;_fg int32 ;_aae []byte ;_eg []byte ;};func (_fcfg *DecoderStats )String ()string {_cbb :=&_a .Builder {};
_cbb .WriteString (_d .Sprintf ("S\u0074\u0061\u0074\u0073\u003a\u0020\u0020\u0025\u0064\u000a",len (_fcfg ._aae )));for _gda ,_acg :=range _fcfg ._aae {if _acg !=0{_cbb .WriteString (_d .Sprintf ("N\u006f\u0074\u0020\u007aer\u006f \u0061\u0074\u003a\u0020\u0025d\u0020\u002d\u0020\u0025\u0064\u000a",_gda ,_acg ));
};};return _cbb .String ();};func (_aa *Decoder )renormalize ()error {for {if _aa ._fc ==0{if _fe :=_aa .readByte ();_fe !=nil {return _fe ;};};_aa ._f <<=1;_aa ._ed <<=1;_aa ._fc --;if (_aa ._f &0x8000)!=0{break ;};};_aa ._ed &=0xffffffff;return nil ;
};type Decoder struct{ContextSize []uint32 ;ReferedToContextSize []uint32 ;_db _g .StreamReader ;_dg uint8 ;_ed uint64 ;_f uint32 ;_eb int64 ;_fc int32 ;_bf int32 ;_df int64 ;};func NewStats (contextSize int32 ,index int32 )*DecoderStats {return &DecoderStats {_ecg :index ,_fg :contextSize ,_aae :make ([]byte ,contextSize ),_eg :make ([]byte ,contextSize )};
};func (_baa *DecoderStats )Reset (){for _gf :=0;_gf < len (_baa ._aae );_gf ++{_baa ._aae [_gf ]=0;_baa ._eg [_gf ]=0;};};func (_bea *DecoderStats )setEntry (_gg int ){_ccae :=byte (_gg &0x7f);_bea ._aae [_bea ._ecg ]=_ccae };func (_fa *Decoder )DecodeInt (stats *DecoderStats )(int32 ,error ){var (_ba ,_cb int32 ;
_ffa ,_dd ,_cc int ;_cca error ;);if stats ==nil {stats =NewStats (512,1);};_fa ._eb =1;_dd ,_cca =_fa .decodeIntBit (stats );if _cca !=nil {return 0,_cca ;};_ffa ,_cca =_fa .decodeIntBit (stats );if _cca !=nil {return 0,_cca ;};if _ffa ==1{_ffa ,_cca =_fa .decodeIntBit (stats );
if _cca !=nil {return 0,_cca ;};if _ffa ==1{_ffa ,_cca =_fa .decodeIntBit (stats );if _cca !=nil {return 0,_cca ;};if _ffa ==1{_ffa ,_cca =_fa .decodeIntBit (stats );if _cca !=nil {return 0,_cca ;};if _ffa ==1{_ffa ,_cca =_fa .decodeIntBit (stats );if _cca !=nil {return 0,_cca ;
};if _ffa ==1{_cc =32;_cb =4436;}else {_cc =12;_cb =340;};}else {_cc =8;_cb =84;};}else {_cc =6;_cb =20;};}else {_cc =4;_cb =4;};}else {_cc =2;_cb =0;};for _cbe :=0;_cbe < _cc ;_cbe ++{_ffa ,_cca =_fa .decodeIntBit (stats );if _cca !=nil {return 0,_cca ;
};_ba =(_ba <<1)|int32 (_ffa );};_ba +=_cb ;if _dd ==0{return _ba ,nil ;}else if _dd ==1&&_ba > 0{return -_ba ,nil ;};return 0,_ge .ErrOOB ;};var (_bc =[][4]uint32 {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
);func New (r _g .StreamReader )(*Decoder ,error ){_bb :=&Decoder {_db :r ,ContextSize :[]uint32 {16,13,10,10},ReferedToContextSize :[]uint32 {13,10}};if _gc :=_bb .init ();_gc !=nil {return nil ,_gc ;};return _bb ,nil ;};func (_gb *Decoder )DecodeBit (stats *DecoderStats )(int ,error ){var (_bfa int ;
_ff =_bc [stats .cx ()][0];_gbb =int32 (stats .cx ()););defer func (){_gb ._bf ++}();_gb ._f -=_ff ;if (_gb ._ed >>16)< uint64 (_ff ){_bfa =_gb .lpsExchange (stats ,_gbb ,_ff );if _edf :=_gb .renormalize ();_edf !=nil {return 0,_edf ;};}else {_gb ._ed -=uint64 (_ff )<<16;
if (_gb ._f &0x8000)==0{_bfa =_gb .mpsExchange (stats ,_gbb );if _c :=_gb .renormalize ();_c !=nil {return 0,_c ;};}else {_bfa =int (stats .getMps ());};};return _bfa ,nil ;};func (_dfc *DecoderStats )SetIndex (index int32 ){_dfc ._ecg =index };func (_ebd *DecoderStats )toggleMps (){_ebd ._eg [_ebd ._ecg ]^=1};
func (_gbbf *DecoderStats )getMps ()byte {return _gbbf ._eg [_gbbf ._ecg ]};func (_dcc *Decoder )mpsExchange (_aefb *DecoderStats ,_fcf int32 )int {_gd :=_aefb ._eg [_aefb ._ecg ];if _dcc ._f < _bc [_fcf ][0]{if _bc [_fcf ][3]==1{_aefb .toggleMps ();};
_aefb .setEntry (int (_bc [_fcf ][2]));return int (1-_gd );};_aefb .setEntry (int (_bc [_fcf ][1]));return int (_gd );};