//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_g "fmt";_a "github.com/unidoc/unipdf/v3/common";_b "github.com/unidoc/unipdf/v3/internal/bitwise";_bb "github.com/unidoc/unipdf/v3/internal/jbig2/internal";_c "io";_d "strings";);type DecoderStats struct{_bf int32 ;_gf int32 ;
_cad []byte ;_de []byte ;};func (_bg *Decoder )mpsExchange (_afb *DecoderStats ,_bab int32 )int {_dg :=_afb ._de [_afb ._bf ];if _bg ._ag < _eb [_bab ][0]{if _eb [_bab ][3]==1{_afb .toggleMps ();};_afb .setEntry (int (_eb [_bab ][2]));return int (1-_dg );
};_afb .setEntry (int (_eb [_bab ][1]));return int (_dg );};var (_eb =[][4]uint32 {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
);func (_adb *DecoderStats )toggleMps (){_adb ._de [_adb ._bf ]^=1};func NewStats (contextSize int32 ,index int32 )*DecoderStats {return &DecoderStats {_bf :index ,_gf :contextSize ,_cad :make ([]byte ,contextSize ),_de :make ([]byte ,contextSize )};};
func (_dd *Decoder )DecodeBit (stats *DecoderStats )(int ,error ){var (_ca int ;_cd =_eb [stats .cx ()][0];_dde =int32 (stats .cx ()););defer func (){_dd ._bc ++}();_dd ._ag -=_cd ;if (_dd ._gc >>16)< uint64 (_cd ){_ca =_dd .lpsExchange (stats ,_dde ,_cd );
if _fb :=_dd .renormalize ();_fb !=nil {return 0,_fb ;};}else {_dd ._gc -=uint64 (_cd )<<16;if (_dd ._ag &0x8000)==0{_ca =_dd .mpsExchange (stats ,_dde );if _ab :=_dd .renormalize ();_ab !=nil {return 0,_ab ;};}else {_ca =int (stats .getMps ());};};return _ca ,nil ;
};func (_cg *Decoder )init ()error {_cg ._ac =_cg ._f .StreamPosition ();_cf ,_fd :=_cg ._f .ReadByte ();if _fd !=nil {_a .Log .Debug ("B\u0075\u0066\u0066\u0065\u0072\u0030 \u0072\u0065\u0061\u0064\u0042\u0079\u0074\u0065\u0020f\u0061\u0069\u006ce\u0064.\u0020\u0025\u0076",_fd );
return _fd ;};_cg ._ge =_cf ;_cg ._gc =uint64 (_cf )<<16;if _fd =_cg .readByte ();_fd !=nil {return _fd ;};_cg ._gc <<=7;_cg ._aa -=7;_cg ._ag =0x8000;_cg ._bc ++;return nil ;};func (_bdb *DecoderStats )Copy ()*DecoderStats {_agb :=&DecoderStats {_gf :_bdb ._gf ,_cad :make ([]byte ,_bdb ._gf )};
copy (_agb ._cad ,_bdb ._cad );return _agb ;};func (_eac *Decoder )lpsExchange (_eacb *DecoderStats ,_fbd int32 ,_cdc uint32 )int {_fce :=_eacb .getMps ();if _eac ._ag < _cdc {_eacb .setEntry (int (_eb [_fbd ][1]));_eac ._ag =_cdc ;return int (_fce );};
if _eb [_fbd ][3]==1{_eacb .toggleMps ();};_eacb .setEntry (int (_eb [_fbd ][2]));_eac ._ag =_cdc ;return int (1-_fce );};func (_dbg *Decoder )decodeIntBit (_ddc *DecoderStats )(int ,error ){_ddc .SetIndex (int32 (_dbg ._ce ));_afd ,_be :=_dbg .DecodeBit (_ddc );
if _be !=nil {_a .Log .Debug ("\u0041\u0072\u0069\u0074\u0068\u006d\u0065t\u0069\u0063\u0044e\u0063\u006f\u0064e\u0072\u0020'\u0064\u0065\u0063\u006f\u0064\u0065I\u006etB\u0069\u0074\u0027\u002d\u003e\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0042\u0069\u0074\u0020\u0066\u0061\u0069\u006c\u0065\u0064\u002e\u0020\u0025\u0076",_be );
return _afd ,_be ;};if _dbg ._ce < 256{_dbg ._ce =((_dbg ._ce <<uint64 (1))|int64 (_afd ))&0x1ff;}else {_dbg ._ce =(((_dbg ._ce <<uint64 (1)|int64 (_afd ))&511)|256)&0x1ff;};return _afd ,nil ;};func (_ecd *DecoderStats )Reset (){for _ege :=0;_ege < len (_ecd ._cad );
_ege ++{_ecd ._cad [_ege ]=0;_ecd ._de [_ege ]=0;};};func (_aac *DecoderStats )getMps ()byte {return _aac ._de [_aac ._bf ]};func (_bce *Decoder )DecodeInt (stats *DecoderStats )(int32 ,error ){var (_ed ,_fbg int32 ;_bd ,_bcea ,_dc int ;_fc error ;);if stats ==nil {stats =NewStats (512,1);
};_bce ._ce =1;_bcea ,_fc =_bce .decodeIntBit (stats );if _fc !=nil {return 0,_fc ;};_bd ,_fc =_bce .decodeIntBit (stats );if _fc !=nil {return 0,_fc ;};if _bd ==1{_bd ,_fc =_bce .decodeIntBit (stats );if _fc !=nil {return 0,_fc ;};if _bd ==1{_bd ,_fc =_bce .decodeIntBit (stats );
if _fc !=nil {return 0,_fc ;};if _bd ==1{_bd ,_fc =_bce .decodeIntBit (stats );if _fc !=nil {return 0,_fc ;};if _bd ==1{_bd ,_fc =_bce .decodeIntBit (stats );if _fc !=nil {return 0,_fc ;};if _bd ==1{_dc =32;_fbg =4436;}else {_dc =12;_fbg =340;};}else {_dc =8;
_fbg =84;};}else {_dc =6;_fbg =20;};}else {_dc =4;_fbg =4;};}else {_dc =2;_fbg =0;};for _ga :=0;_ga < _dc ;_ga ++{_bd ,_fc =_bce .decodeIntBit (stats );if _fc !=nil {return 0,_fc ;};_ed =(_ed <<1)|int32 (_bd );};_ed +=_fbg ;if _bcea ==0{return _ed ,nil ;
}else if _bcea ==1&&_ed > 0{return -_ed ,nil ;};return 0,_bb .ErrOOB ;};func (_gag *DecoderStats )cx ()byte {return _gag ._cad [_gag ._bf ]};func (_dda *Decoder )renormalize ()error {for {if _dda ._aa ==0{if _eag :=_dda .readByte ();_eag !=nil {return _eag ;
};};_dda ._ag <<=1;_dda ._gc <<=1;_dda ._aa --;if (_dda ._ag &0x8000)!=0{break ;};};_dda ._gc &=0xffffffff;return nil ;};func (_ec *DecoderStats )Overwrite (dNew *DecoderStats ){for _caa :=0;_caa < len (_ec ._cad );_caa ++{_ec ._cad [_caa ]=dNew ._cad [_caa ];
_ec ._de [_caa ]=dNew ._de [_caa ];};};func (_bed *DecoderStats )SetIndex (index int32 ){_bed ._bf =index };func (_fg *Decoder )readByte ()error {if _fg ._f .StreamPosition ()> _fg ._ac {if _ ,_cc :=_fg ._f .Seek (-1,_c .SeekCurrent );_cc !=nil {return _cc ;
};};_ba ,_fbgg :=_fg ._f .ReadByte ();if _fbgg !=nil {return _fbgg ;};_fg ._ge =_ba ;if _fg ._ge ==0xFF{_af ,_eg :=_fg ._f .ReadByte ();if _eg !=nil {return _eg ;};if _af > 0x8F{_fg ._gc +=0xFF00;_fg ._aa =8;if _ ,_ff :=_fg ._f .Seek (-2,_c .SeekCurrent );
_ff !=nil {return _ff ;};}else {_fg ._gc +=uint64 (_af )<<9;_fg ._aa =7;};}else {_ba ,_fbgg =_fg ._f .ReadByte ();if _fbgg !=nil {return _fbgg ;};_fg ._ge =_ba ;_fg ._gc +=uint64 (_fg ._ge )<<8;_fg ._aa =8;};_fg ._gc &=0xFFFFFFFFFF;return nil ;};func (_ea *Decoder )DecodeIAID (codeLen uint64 ,stats *DecoderStats )(int64 ,error ){_ea ._ce =1;
var _cab uint64 ;for _cab =0;_cab < codeLen ;_cab ++{stats .SetIndex (int32 (_ea ._ce ));_da ,_fe :=_ea .DecodeBit (stats );if _fe !=nil {return 0,_fe ;};_ea ._ce =(_ea ._ce <<1)|int64 (_da );};_ad :=_ea ._ce -(1<<codeLen );return _ad ,nil ;};type Decoder struct{ContextSize []uint32 ;
ReferedToContextSize []uint32 ;_f _b .StreamReader ;_ge uint8 ;_gc uint64 ;_ag uint32 ;_ce int64 ;_aa int32 ;_bc int32 ;_ac int64 ;};func (_ccf *DecoderStats )setEntry (_egc int ){_abb :=byte (_egc &0x7f);_ccf ._cad [_ccf ._bf ]=_abb };func New (r _b .StreamReader )(*Decoder ,error ){_acc :=&Decoder {_f :r ,ContextSize :[]uint32 {16,13,10,10},ReferedToContextSize :[]uint32 {13,10}};
if _gb :=_acc .init ();_gb !=nil {return nil ,_gb ;};return _acc ,nil ;};func (_gd *DecoderStats )String ()string {_ccb :=&_d .Builder {};_ccb .WriteString (_g .Sprintf ("S\u0074\u0061\u0074\u0073\u003a\u0020\u0020\u0025\u0064\u000a",len (_gd ._cad )));
for _bde ,_gdb :=range _gd ._cad {if _gdb !=0{_ccb .WriteString (_g .Sprintf ("N\u006f\u0074\u0020\u007aer\u006f \u0061\u0074\u003a\u0020\u0025d\u0020\u002d\u0020\u0025\u0064\u000a",_bde ,_gdb ));};};return _ccb .String ();};