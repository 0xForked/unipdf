//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_df "fmt";_c "github.com/unidoc/unipdf/v3/common";_f "github.com/unidoc/unipdf/v3/internal/bitwise";_cf "github.com/unidoc/unipdf/v3/internal/jbig2/internal";_d "io";_e "strings";);func (_fa *Decoder )decodeIntBit (_ae *DecoderStats )(int ,error ){_ae .SetIndex (int32 (_fa ._bc ));_eac ,_eb :=_fa .DecodeBit (_ae );if _eb !=nil {_c .Log .Debug ("\u0041\u0072\u0069\u0074\u0068\u006d\u0065t\u0069\u0063\u0044e\u0063\u006f\u0064e\u0072\u0020'\u0064\u0065\u0063\u006f\u0064\u0065I\u006etB\u0069\u0074\u0027\u002d\u003e\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0042\u0069\u0074\u0020\u0066\u0061\u0069\u006c\u0065\u0064\u002e\u0020\u0025\u0076",_eb );return _eac ,_eb ;};if _fa ._bc < 256{_fa ._bc =((_fa ._bc <<uint64 (1))|int64 (_eac ))&0x1ff;}else {_fa ._bc =(((_fa ._bc <<uint64 (1)|int64 (_eac ))&511)|256)&0x1ff;};return _eac ,nil ;};func (_aa *Decoder )DecodeBit (stats *DecoderStats )(int ,error ){var (_ab int ;_dd =_a [stats .cx ()][0];_acc =int32 (stats .cx ()););defer func (){_aa ._gc ++}();_aa ._cd -=_dd ;if (_aa ._g >>16)< uint64 (_dd ){_ab =_aa .lpsExchange (stats ,_acc ,_dd );if _ca :=_aa .renormalize ();_ca !=nil {return 0,_ca ;};}else {_aa ._g -=uint64 (_dd )<<16;if (_aa ._cd &0x8000)==0{_ab =_aa .mpsExchange (stats ,_acc );if _eef :=_aa .renormalize ();_eef !=nil {return 0,_eef ;};}else {_ab =int (stats .getMps ());};};return _ab ,nil ;};func (_dfc *Decoder )DecodeIAID (codeLen uint64 ,stats *DecoderStats )(int64 ,error ){_dfc ._bc =1;var _bca uint64 ;for _bca =0;_bca < codeLen ;_bca ++{stats .SetIndex (int32 (_dfc ._bc ));_ace ,_ba :=_dfc .DecodeBit (stats );if _ba !=nil {return 0,_ba ;};_dfc ._bc =(_dfc ._bc <<1)|int64 (_ace );};_cae :=_dfc ._bc -(1<<codeLen );return _cae ,nil ;};func (_cca *Decoder )renormalize ()error {for {if _cca ._ac ==0{if _bab :=_cca .readByte ();_bab !=nil {return _bab ;};};_cca ._cd <<=1;_cca ._g <<=1;_cca ._ac --;if (_cca ._cd &0x8000)!=0{break ;};};_cca ._g &=0xffffffff;return nil ;};func (_be *DecoderStats )Reset (){for _ccae :=0;_ccae < len (_be ._ccg );_ccae ++{_be ._ccg [_ccae ]=0;_be ._ecb [_ccae ]=0;};};func (_age *Decoder )DecodeInt (stats *DecoderStats )(int32 ,error ){var (_bcg ,_fe int32 ;_agb ,_ec ,_cc int ;_cfb error ;);if stats ==nil {stats =NewStats (512,1);};_age ._bc =1;_ec ,_cfb =_age .decodeIntBit (stats );if _cfb !=nil {return 0,_cfb ;};_agb ,_cfb =_age .decodeIntBit (stats );if _cfb !=nil {return 0,_cfb ;};if _agb ==1{_agb ,_cfb =_age .decodeIntBit (stats );if _cfb !=nil {return 0,_cfb ;};if _agb ==1{_agb ,_cfb =_age .decodeIntBit (stats );if _cfb !=nil {return 0,_cfb ;};if _agb ==1{_agb ,_cfb =_age .decodeIntBit (stats );if _cfb !=nil {return 0,_cfb ;};if _agb ==1{_agb ,_cfb =_age .decodeIntBit (stats );if _cfb !=nil {return 0,_cfb ;};if _agb ==1{_cc =32;_fe =4436;}else {_cc =12;_fe =340;};}else {_cc =8;_fe =84;};}else {_cc =6;_fe =20;};}else {_cc =4;_fe =4;};}else {_cc =2;_fe =0;};for _ff :=0;_ff < _cc ;_ff ++{_agb ,_cfb =_age .decodeIntBit (stats );if _cfb !=nil {return 0,_cfb ;};_bcg =(_bcg <<1)|int32 (_agb );};_bcg +=_fe ;if _ec ==0{return _bcg ,nil ;}else if _ec ==1&&_bcg > 0{return -_bcg ,nil ;};return 0,_cf .ErrOOB ;};func (_agee *Decoder )init ()error {_agee ._ea =_agee ._da .StreamPosition ();_agc ,_cfe :=_agee ._da .ReadByte ();if _cfe !=nil {_c .Log .Debug ("B\u0075\u0066\u0066\u0065\u0072\u0030 \u0072\u0065\u0061\u0064\u0042\u0079\u0074\u0065\u0020f\u0061\u0069\u006ce\u0064.\u0020\u0025\u0076",_cfe );return _cfe ;};_agee ._ag =_agc ;_agee ._g =uint64 (_agc )<<16;if _cfe =_agee .readByte ();_cfe !=nil {return _cfe ;};_agee ._g <<=7;_agee ._ac -=7;_agee ._cd =0x8000;_agee ._gc ++;return nil ;};func (_bbf *DecoderStats )Copy ()*DecoderStats {_ad :=&DecoderStats {_aaa :_bbf ._aaa ,_ccg :make ([]byte ,_bbf ._aaa )};for _dcf :=0;_dcf < len (_bbf ._ccg );_dcf ++{_ad ._ccg [_dcf ]=_bbf ._ccg [_dcf ];};return _ad ;};type DecoderStats struct{_bd int32 ;_aaa int32 ;_ccg []byte ;_ecb []byte ;};func (_ged *DecoderStats )toggleMps (){_ged ._ecb [_ged ._bd ]^=1};func NewStats (contextSize int32 ,index int32 )*DecoderStats {return &DecoderStats {_bd :index ,_aaa :contextSize ,_ccg :make ([]byte ,contextSize ),_ecb :make ([]byte ,contextSize )};};func (_ega *Decoder )lpsExchange (_dc *DecoderStats ,_gb int32 ,_abg uint32 )int {_ge :=_dc .getMps ();if _ega ._cd < _abg {_dc .setEntry (int (_a [_gb ][1]));_ega ._cd =_abg ;return int (_ge );};if _a [_gb ][3]==1{_dc .toggleMps ();};_dc .setEntry (int (_a [_gb ][2]));_ega ._cd =_abg ;return int (1-_ge );};func (_gbg *DecoderStats )Overwrite (dNew *DecoderStats ){for _bcb :=0;_bcb < len (_gbg ._ccg );_bcb ++{_gbg ._ccg [_bcb ]=dNew ._ccg [_bcb ];_gbg ._ecb [_bcb ]=dNew ._ecb [_bcb ];};};func New (r _f .StreamReader )(*Decoder ,error ){_ee :=&Decoder {_da :r ,ContextSize :[]uint32 {16,13,10,10},ReferedToContextSize :[]uint32 {13,10}};if _cfg :=_ee .init ();_cfg !=nil {return nil ,_cfg ;};return _ee ,nil ;};func (_db *Decoder )readByte ()error {if _db ._da .StreamPosition ()> _db ._ea {if _ ,_bb :=_db ._da .Seek (-1,_d .SeekCurrent );_bb !=nil {return _bb ;};};_acg ,_af :=_db ._da .ReadByte ();if _af !=nil {return _af ;};_db ._ag =_acg ;if _db ._ag ==0xFF{_fd ,_cb :=_db ._da .ReadByte ();if _cb !=nil {return _cb ;};if _fd > 0x8F{_db ._g +=0xFF00;_db ._ac =8;if _ ,_eg :=_db ._da .Seek (-2,_d .SeekCurrent );_eg !=nil {return _eg ;};}else {_db ._g +=uint64 (_fd )<<9;_db ._ac =7;};}else {_acg ,_af =_db ._da .ReadByte ();if _af !=nil {return _af ;};_db ._ag =_acg ;_db ._g +=uint64 (_db ._ag )<<8;_db ._ac =8;};_db ._g &=0xFFFFFFFFFF;return nil ;};var (_a =[][4]uint32 {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};);func (_cdd *DecoderStats )SetIndex (index int32 ){_cdd ._bd =index };func (_dca *DecoderStats )cx ()byte {return _dca ._ccg [_dca ._bd ]};func (_cfef *Decoder )mpsExchange (_cffc *DecoderStats ,_aab int32 )int {_dbe :=_cffc ._ecb [_cffc ._bd ];if _cfef ._cd < _a [_aab ][0]{if _a [_aab ][3]==1{_cffc .toggleMps ();};_cffc .setEntry (int (_a [_aab ][2]));return int (1-_dbe );};_cffc .setEntry (int (_a [_aab ][1]));return int (_dbe );};func (_dg *DecoderStats )setEntry (_dad int ){_aee :=byte (_dad &0x7f);_dg ._ccg [_dg ._bd ]=_aee };func (_bdg *DecoderStats )String ()string {_bf :=&_e .Builder {};_bf .WriteString (_df .Sprintf ("S\u0074\u0061\u0074\u0073\u003a\u0020\u0020\u0025\u0064\u000a",len (_bdg ._ccg )));for _cde ,_fad :=range _bdg ._ccg {if _fad !=0{_bf .WriteString (_df .Sprintf ("N\u006f\u0074\u0020\u007aer\u006f \u0061\u0074\u003a\u0020\u0025d\u0020\u002d\u0020\u0025\u0064\u000a",_cde ,_fad ));};};return _bf .String ();};type Decoder struct{ContextSize []uint32 ;ReferedToContextSize []uint32 ;_da _f .StreamReader ;_ag uint8 ;_g uint64 ;_cd uint32 ;_bc int64 ;_ac int32 ;_gc int32 ;_ea int64 ;};func (_ffd *DecoderStats )getMps ()byte {return _ffd ._ecb [_ffd ._bd ]};