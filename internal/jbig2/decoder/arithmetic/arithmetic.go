//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_e "fmt";_ef "github.com/unidoc/unipdf/v3/common";_f "github.com/unidoc/unipdf/v3/internal/bitwise";_d "github.com/unidoc/unipdf/v3/internal/jbig2/internal";_af "io";_g "strings";);var (_ee =[][4]uint32 {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
);type Decoder struct{ContextSize []uint32 ;ReferedToContextSize []uint32 ;_gb *_f .Reader ;_gf uint8 ;_c uint64 ;_da uint32 ;_gd int64 ;_ag int32 ;_cc int32 ;_cd int64 ;};func (_dcb *Decoder )decodeIntBit (_df *DecoderStats )(int ,error ){_df .SetIndex (int32 (_dcb ._gd ));
_eed ,_fd :=_dcb .DecodeBit (_df );if _fd !=nil {_ef .Log .Debug ("\u0041\u0072\u0069\u0074\u0068\u006d\u0065t\u0069\u0063\u0044e\u0063\u006f\u0064e\u0072\u0020'\u0064\u0065\u0063\u006f\u0064\u0065I\u006etB\u0069\u0074\u0027\u002d\u003e\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0042\u0069\u0074\u0020\u0066\u0061\u0069\u006c\u0065\u0064\u002e\u0020\u0025\u0076",_fd );
return _eed ,_fd ;};if _dcb ._gd < 256{_dcb ._gd =((_dcb ._gd <<uint64 (1))|int64 (_eed ))&0x1ff;}else {_dcb ._gd =(((_dcb ._gd <<uint64 (1)|int64 (_eed ))&511)|256)&0x1ff;};return _eed ,nil ;};func (_eee *DecoderStats )cx ()byte {return _eee ._be [_eee ._bfb ]};
func (_cde *DecoderStats )setEntry (_daa int ){_ecf :=byte (_daa &0x7f);_cde ._be [_cde ._bfb ]=_ecf };func (_fa *Decoder )DecodeInt (stats *DecoderStats )(int32 ,error ){var (_ge ,_cg int32 ;_age ,_bd ,_gg int ;_db error ;);if stats ==nil {stats =NewStats (512,1);
};_fa ._gd =1;_bd ,_db =_fa .decodeIntBit (stats );if _db !=nil {return 0,_db ;};_age ,_db =_fa .decodeIntBit (stats );if _db !=nil {return 0,_db ;};if _age ==1{_age ,_db =_fa .decodeIntBit (stats );if _db !=nil {return 0,_db ;};if _age ==1{_age ,_db =_fa .decodeIntBit (stats );
if _db !=nil {return 0,_db ;};if _age ==1{_age ,_db =_fa .decodeIntBit (stats );if _db !=nil {return 0,_db ;};if _age ==1{_age ,_db =_fa .decodeIntBit (stats );if _db !=nil {return 0,_db ;};if _age ==1{_gg =32;_cg =4436;}else {_gg =12;_cg =340;};}else {_gg =8;
_cg =84;};}else {_gg =6;_cg =20;};}else {_gg =4;_cg =4;};}else {_gg =2;_cg =0;};for _cf :=0;_cf < _gg ;_cf ++{_age ,_db =_fa .decodeIntBit (stats );if _db !=nil {return 0,_db ;};_ge =(_ge <<1)|int32 (_age );};_ge +=_cg ;if _bd ==0{return _ge ,nil ;}else if _bd ==1&&_ge > 0{return -_ge ,nil ;
};return 0,_d .ErrOOB ;};func (_bf *Decoder )init ()error {_bf ._cd =_bf ._gb .AbsolutePosition ();_bda ,_afa :=_bf ._gb .ReadByte ();if _afa !=nil {_ef .Log .Debug ("B\u0075\u0066\u0066\u0065\u0072\u0030 \u0072\u0065\u0061\u0064\u0042\u0079\u0074\u0065\u0020f\u0061\u0069\u006ce\u0064.\u0020\u0025\u0076",_afa );
return _afa ;};_bf ._gf =_bda ;_bf ._c =uint64 (_bda )<<16;if _afa =_bf .readByte ();_afa !=nil {return _afa ;};_bf ._c <<=7;_bf ._ag -=7;_bf ._da =0x8000;_bf ._cc ++;return nil ;};func (_ada *Decoder )mpsExchange (_fcc *DecoderStats ,_dbb int32 )int {_ba :=_fcc ._dae [_fcc ._bfb ];
if _ada ._da < _ee [_dbb ][0]{if _ee [_dbb ][3]==1{_fcc .toggleMps ();};_fcc .setEntry (int (_ee [_dbb ][2]));return int (1-_ba );};_fcc .setEntry (int (_ee [_dbb ][1]));return int (_ba );};func (_ebg *DecoderStats )Reset (){for _gdf :=0;_gdf < len (_ebg ._be );
_gdf ++{_ebg ._be [_gdf ]=0;_ebg ._dae [_gdf ]=0;};};func (_daf *Decoder )readByte ()error {if _daf ._gb .AbsolutePosition ()> _daf ._cd {if _ ,_fb :=_daf ._gb .Seek (-1,_af .SeekCurrent );_fb !=nil {return _fb ;};};_ac ,_dc :=_daf ._gb .ReadByte ();if _dc !=nil {return _dc ;
};_daf ._gf =_ac ;if _daf ._gf ==0xFF{_ec ,_gdc :=_daf ._gb .ReadByte ();if _gdc !=nil {return _gdc ;};if _ec > 0x8F{_daf ._c +=0xFF00;_daf ._ag =8;if _ ,_gbg :=_daf ._gb .Seek (-2,_af .SeekCurrent );_gbg !=nil {return _gbg ;};}else {_daf ._c +=uint64 (_ec )<<9;
_daf ._ag =7;};}else {_ac ,_dc =_daf ._gb .ReadByte ();if _dc !=nil {return _dc ;};_daf ._gf =_ac ;_daf ._c +=uint64 (_daf ._gf )<<8;_daf ._ag =8;};_daf ._c &=0xFFFFFFFFFF;return nil ;};func (_gga *Decoder )lpsExchange (_bb *DecoderStats ,_ab int32 ,_gde uint32 )int {_fe :=_bb .getMps ();
if _gga ._da < _gde {_bb .setEntry (int (_ee [_ab ][1]));_gga ._da =_gde ;return int (_fe );};if _ee [_ab ][3]==1{_bb .toggleMps ();};_bb .setEntry (int (_ee [_ab ][2]));_gga ._da =_gde ;return int (1-_fe );};func (_efa *Decoder )DecodeBit (stats *DecoderStats )(int ,error ){var (_b int ;
_eg =_ee [stats .cx ()][0];_ca =int32 (stats .cx ()););defer func (){_efa ._cc ++}();_efa ._da -=_eg ;if (_efa ._c >>16)< uint64 (_eg ){_b =_efa .lpsExchange (stats ,_ca ,_eg );if _ae :=_efa .renormalize ();_ae !=nil {return 0,_ae ;};}else {_efa ._c -=uint64 (_eg )<<16;
if (_efa ._da &0x8000)==0{_b =_efa .mpsExchange (stats ,_ca );if _cac :=_efa .renormalize ();_cac !=nil {return 0,_cac ;};}else {_b =int (stats .getMps ());};};return _b ,nil ;};type DecoderStats struct{_bfb int32 ;_fg int32 ;_be []byte ;_dae []byte ;};
func NewStats (contextSize int32 ,index int32 )*DecoderStats {return &DecoderStats {_bfb :index ,_fg :contextSize ,_be :make ([]byte ,contextSize ),_dae :make ([]byte ,contextSize )};};func (_geb *DecoderStats )Copy ()*DecoderStats {_ce :=&DecoderStats {_fg :_geb ._fg ,_be :make ([]byte ,_geb ._fg )};
copy (_ce ._be ,_geb ._be );return _ce ;};func (_eba *Decoder )renormalize ()error {for {if _eba ._ag ==0{if _acd :=_eba .readByte ();_acd !=nil {return _acd ;};};_eba ._da <<=1;_eba ._c <<=1;_eba ._ag --;if (_eba ._da &0x8000)!=0{break ;};};_eba ._c &=0xffffffff;
return nil ;};func (_bdc *DecoderStats )toggleMps (){_bdc ._dae [_bdc ._bfb ]^=1};func New (r *_f .Reader )(*Decoder ,error ){_eb :=&Decoder {_gb :r ,ContextSize :[]uint32 {16,13,10,10},ReferedToContextSize :[]uint32 {13,10}};if _ff :=_eb .init ();_ff !=nil {return nil ,_ff ;
};return _eb ,nil ;};func (_cgd *DecoderStats )getMps ()byte {return _cgd ._dae [_cgd ._bfb ]};func (_geg *DecoderStats )SetIndex (index int32 ){_geg ._bfb =index };func (_cag *DecoderStats )String ()string {_ged :=&_g .Builder {};_ged .WriteString (_e .Sprintf ("S\u0074\u0061\u0074\u0073\u003a\u0020\u0020\u0025\u0064\u000a",len (_cag ._be )));
for _acg ,_ea :=range _cag ._be {if _ea !=0{_ged .WriteString (_e .Sprintf ("N\u006f\u0074\u0020\u007aer\u006f \u0061\u0074\u003a\u0020\u0025d\u0020\u002d\u0020\u0025\u0064\u000a",_acg ,_ea ));};};return _ged .String ();};func (_dag *Decoder )DecodeIAID (codeLen uint64 ,stats *DecoderStats )(int64 ,error ){_dag ._gd =1;
var _ad uint64 ;for _ad =0;_ad < codeLen ;_ad ++{stats .SetIndex (int32 (_dag ._gd ));_efe ,_faf :=_dag .DecodeBit (stats );if _faf !=nil {return 0,_faf ;};_dag ._gd =(_dag ._gd <<1)|int64 (_efe );};_fc :=_dag ._gd -(1<<codeLen );return _fc ,nil ;};func (_bdf *DecoderStats )Overwrite (dNew *DecoderStats ){for _ed :=0;
_ed < len (_bdf ._be );_ed ++{_bdf ._be [_ed ]=dNew ._be [_ed ];_bdf ._dae [_ed ]=dNew ._dae [_ed ];};};