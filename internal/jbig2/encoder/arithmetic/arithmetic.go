//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_gd "bytes";_gc "github.com/unidoc/unipdf/v3/common";_c "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_gcb "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_e "io";);func (_ccd *Encoder )rBlock (){if _ccd ._af >=0{_ccd .emit ();};_ccd ._af ++;_ccd ._cd =uint8 (_ccd ._ga >>20);_ccd ._ga &=0xfffff;_ccd ._fb =7;};func (_gdg *Encoder )flush (){_gdg .setBits ();_gdg ._ga <<=_gdg ._fb ;_gdg .byteOut ();_gdg ._ga <<=_gdg ._fb ;_gdg .byteOut ();_gdg .emit ();if _gdg ._cd !=0xff{_gdg ._af ++;_gdg ._cd =0xff;_gdg .emit ();};_gdg ._af ++;_gdg ._cd =0xac;_gdg ._af ++;_gdg .emit ();};func (_cab *Encoder )Final (){_cab .flush ()};func (_ggd *Encoder )code0 (_age *codingContext ,_bd uint32 ,_gfa uint16 ,_bda byte ){if _age .mps (_bd )==0{_ggd .codeMPS (_age ,_bd ,_gfa ,_bda );}else {_ggd .codeLPS (_age ,_bd ,_gfa ,_bda );};};func (_ed *Encoder )byteOut (){if _ed ._cd ==0xff{_ed .rBlock ();return ;};if _ed ._ga < 0x8000000{_ed .lBlock ();return ;};_ed ._cd ++;if _ed ._cd !=0xff{_ed .lBlock ();return ;};_ed ._ga &=0x7ffffff;_ed .rBlock ();};func New ()*Encoder {_efe :=&Encoder {};_efe .Init ();return _efe };func (_fe *Encoder )EncodeBitmap (bm *_c .Bitmap ,duplicateLineRemoval bool )error {_gc .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );var (_fee ,_ee uint8 ;_acd ,_acdb ,_ec uint16 ;_ea ,_df ,_ge byte ;_gge ,_ffc ,_gf int ;_be ,_ccf []byte ;);for _cbg :=0;_cbg < bm .Height ;_cbg ++{_ea ,_df =0,0;if _cbg >=2{_ea =bm .Data [(_cbg -2)*bm .RowStride ];};if _cbg >=1{_df =bm .Data [(_cbg -1)*bm .RowStride ];if duplicateLineRemoval {_ffc =_cbg *bm .RowStride ;_be =bm .Data [_ffc :_ffc +bm .RowStride ];_gf =(_cbg -1)*bm .RowStride ;_ccf =bm .Data [_gf :_gf +bm .RowStride ];if _gd .Equal (_be ,_ccf ){_ee =_fee ^1;_fee =1;}else {_ee =_fee ;_fee =0;};};};if duplicateLineRemoval {if _ab :=_fe .encodeBit (_fe ._egb ,_bg ,_ee );_ab !=nil {return _ab ;};if _fee !=0{continue ;};};_ge =bm .Data [_cbg *bm .RowStride ];_acd =uint16 (_ea >>5);_acdb =uint16 (_df >>4);_ea <<=3;_df <<=4;_ec =0;for _gge =0;_gge < bm .Width ;_gge ++{_afa :=uint32 (_acd <<11|_acdb <<4|_ec );_egf :=(_ge &0x80)>>7;_ceb :=_fe .encodeBit (_fe ._egb ,_afa ,_egf );if _ceb !=nil {return _ceb ;};_acd <<=1;_acdb <<=1;_ec <<=1;_acd |=uint16 ((_ea &0x80)>>7);_acdb |=uint16 ((_df &0x80)>>7);_ec |=uint16 (_egf );_dfg :=_gge %8;_cbgc :=_gge /8+1;if _dfg ==4&&_cbg >=2{_ea =0;if _cbgc < bm .RowStride {_ea =bm .Data [(_cbg -2)*bm .RowStride +_cbgc ];};}else {_ea <<=1;};if _dfg ==3&&_cbg >=1{_df =0;if _cbgc < bm .RowStride {_df =bm .Data [(_cbg -1)*bm .RowStride +_cbgc ];};}else {_df <<=1;};if _dfg ==7{_ge =0;if _cbgc < bm .RowStride {_ge =bm .Data [_cbg *bm .RowStride +_cbgc ];};}else {_ge <<=1;};_acd &=31;_acdb &=127;_ec &=15;};};return nil ;};func (_gg *Encoder )DataSize ()int {return _gg .dataSize ()};func (_eb Class )String ()string {switch _eb {case IAAI :return "\u0049\u0041\u0041\u0049";case IADH :return "\u0049\u0041\u0044\u0048";case IADS :return "\u0049\u0041\u0044\u0053";case IADT :return "\u0049\u0041\u0044\u0054";case IADW :return "\u0049\u0041\u0044\u0057";case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";case IAIT :return "\u0049\u0041\u0049\u0054";case IARDH :return "\u0049\u0041\u0052D\u0048";case IARDW :return "\u0049\u0041\u0052D\u0057";case IARDX :return "\u0049\u0041\u0052D\u0058";case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";};};func (_ac *codingContext )flipMps (_ef uint32 ){_ac ._ebe [_ef ]=1-_ac ._ebe [_ef ]};func (_gag *Encoder )encodeIAID (_ffd ,_gfag int )error {if _gag ._ae ==nil {_gag ._ae =_bb (1<<uint (_ffd ));};_degb :=uint32 (1<<uint32 (_ffd +1))-1;_gfag <<=uint (32-_ffd );_gaf :=uint32 (1);for _geb :=0;_geb < _ffd ;_geb ++{_da :=_gaf &_degb ;_ebaa :=uint8 ((uint32 (_gfag )&0x80000000)>>31);if _afbc :=_gag .encodeBit (_gag ._ae ,_da ,_ebaa );_afbc !=nil {return _afbc ;};_gaf =(_gaf <<1)|uint32 (_ebaa );_gfag <<=1;};return nil ;};func (_gbd *Encoder )encodeOOB (_gce Class )error {_feee :=_gbd ._bfb [_gce ];_ccbb :=_gbd .encodeBit (_feee ,1,1);if _ccbb !=nil {return _ccbb ;};_ccbb =_gbd .encodeBit (_feee ,3,0);if _ccbb !=nil {return _ccbb ;};_ccbb =_gbd .encodeBit (_feee ,6,0);if _ccbb !=nil {return _ccbb ;};_ccbb =_gbd .encodeBit (_feee ,12,0);if _ccbb !=nil {return _ccbb ;};return nil ;};const _bg =0x9b25;func (_afaa *Encoder )renormalize (){for {_afaa ._cg <<=1;_afaa ._ga <<=1;_afaa ._fb --;if _afaa ._fb ==0{_afaa .byteOut ();};if (_afaa ._cg &0x8000)!=0{break ;};};};func (_cbc *Encoder )EncodeOOB (proc Class )(_gb error ){_gc .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );if _gb =_cbc .encodeOOB (proc );_gb !=nil {return _gcb .Wrap (_gb ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};func (_fgg *Encoder )setBits (){_db :=_fgg ._ga +uint32 (_fgg ._cg );_fgg ._ga |=0xffff;if _fgg ._ga >=_db {_fgg ._ga -=0x8000;};};func (_abe *Encoder )emit (){if _abe ._bf ==_fac {_abe ._ca =append (_abe ._ca ,_abe ._ff );_abe ._ff =make ([]byte ,_fac );_abe ._bf =0;};_abe ._ff [_abe ._bf ]=_abe ._cd ;_abe ._bf ++;};type state struct{_ceed uint16 ;_cgb ,_bfc uint8 ;_bff uint8 ;};func (_gfg *Encoder )EncodeInteger (proc Class ,value int )(_gcd error ){_gc .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );if _gcd =_gfg .encodeInteger (proc ,value );_gcd !=nil {return _gcb .Wrap (_gcd ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};func (_eba *Encoder )dataSize ()int {return _fac *len (_eba ._ca )+_eba ._bf };func (_cac *Encoder )lBlock (){if _cac ._af >=0{_cac .emit ();};_cac ._af ++;_cac ._cd =uint8 (_cac ._ga >>19);_cac ._ga &=0x7ffff;_cac ._fb =8;};func (_bfa *Encoder )WriteTo (w _e .Writer )(int64 ,error ){const _ccfd ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";var _geg int64 ;for _fa ,_cee :=range _bfa ._ca {_gfbg ,_fbd :=w .Write (_cee );if _fbd !=nil {return 0,_gcb .Wrapf (_fbd ,_ccfd ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_fa );};_geg +=int64 (_gfbg );};_bfa ._ff =_bfa ._ff [:_bfa ._bf ];_bfaf ,_gaba :=w .Write (_bfa ._ff );if _gaba !=nil {return 0,_gcb .Wrap (_gaba ,_ccfd ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_geg +=int64 (_bfaf );return _geg ,nil ;};func (_dc *codingContext )mps (_b uint32 )int {return int (_dc ._ebe [_b ])};func (_ggb *Encoder )Refine (iTemp ,iTarget *_c .Bitmap ,ox ,oy int )error {for _ag :=0;_ag < iTarget .Height ;_ag ++{var _egc int ;_ggg :=_ag +oy ;var (_ccfa ,_deg ,_cbf ,_fbb ,_aeg uint16 ;_bc ,_efb ,_abd ,_ebd ,_fbc byte ;);if _ggg >=1&&(_ggg -1)< iTemp .Height {_bc =iTemp .Data [(_ggg -1)*iTemp .RowStride ];};if _ggg >=0&&_ggg < iTemp .Height {_efb =iTemp .Data [_ggg *iTemp .RowStride ];};if _ggg >=-1&&_ggg +1< iTemp .Height {_abd =iTemp .Data [(_ggg +1)*iTemp .RowStride ];};if _ag >=1{_ebd =iTarget .Data [(_ag -1)*iTarget .RowStride ];};_fbc =iTarget .Data [_ag *iTarget .RowStride ];_cba :=uint (6+ox );_ccfa =uint16 (_bc >>_cba );_deg =uint16 (_efb >>_cba );_cbf =uint16 (_abd >>_cba );_fbb =uint16 (_ebd >>6);_gca :=uint (2-ox );_bc <<=_gca ;_efb <<=_gca ;_abd <<=_gca ;_ebd <<=2;for _egc =0;_egc < iTarget .Width ;_egc ++{_eec :=(_ccfa <<10)|(_deg <<7)|(_cbf <<4)|(_fbb <<1)|_aeg ;_afg :=_fbc >>7;_gfd :=_ggb .encodeBit (_ggb ._egb ,uint32 (_eec ),_afg );if _gfd !=nil {return _gfd ;};_ccfa <<=1;_deg <<=1;_cbf <<=1;_fbb <<=1;_ccfa |=uint16 (_bc >>7);_deg |=uint16 (_efb >>7);_cbf |=uint16 (_abd >>7);_fbb |=uint16 (_ebd >>7);_aeg =uint16 (_afg );_gab :=_egc %8;_fea :=_egc /8+1;if _gab ==5+ox {_bc ,_efb ,_abd =0,0,0;if _fea < iTemp .RowStride &&_ggg >=1&&(_ggg -1)< iTemp .Height {_bc =iTemp .Data [(_ggg -1)*iTemp .RowStride +_fea ];};if _fea < iTemp .RowStride &&_ggg >=0&&_ggg < iTemp .Height {_efb =iTemp .Data [_ggg *iTemp .RowStride +_fea ];};if _fea < iTemp .RowStride &&_ggg >=-1&&(_ggg +1)< iTemp .Height {_abd =iTemp .Data [(_ggg +1)*iTemp .RowStride +_fea ];};}else {_bc <<=1;_efb <<=1;_abd <<=1;};if _gab ==5&&_ag >=1{_ebd =0;if _fea < iTarget .RowStride {_ebd =iTarget .Data [(_ag -1)*iTarget .RowStride +_fea ];};}else {_ebd <<=1;};if _gab ==7{_fbc =0;if _fea < iTarget .RowStride {_fbc =iTarget .Data [_ag *iTarget .RowStride +_fea ];};}else {_fbc <<=1;};_ccfa &=7;_deg &=7;_cbf &=7;_fbb &=7;};};return nil ;};func (_gfb *Encoder )Flush (){_gfb ._bf =0;_gfb ._ca =nil ;_gfb ._af =-1};func (_gac *Encoder )EncodeIAID (symbolCodeLength ,value int )(_dd error ){_gc .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );if _dd =_gac .encodeIAID (symbolCodeLength ,value );_dd !=nil {return _gcb .Wrap (_dd ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};func _bb (_eg int )*codingContext {return &codingContext {_de :make ([]byte ,_eg ),_ebe :make ([]byte ,_eg )};};func (_bbe *Encoder )code1 (_acc *codingContext ,_dfb uint32 ,_dce uint16 ,_gabc byte ){if _acc .mps (_dfb )==1{_bbe .codeMPS (_acc ,_dfb ,_dce ,_gabc );}else {_bbe .codeLPS (_acc ,_dfb ,_dce ,_gabc );};};var _ _e .WriterTo =&Encoder {};type intEncRangeS struct{_d ,_f int ;_a ,_cb uint8 ;_cf uint16 ;_cc uint8 ;};func (_eggf *Encoder )encodeInteger (_ebg Class ,_aa int )error {const _cea ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";if _aa > 2000000000||_aa < -2000000000{return _gcb .Errorf (_cea ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_aa );};_fff :=_eggf ._bfb [_ebg ];_gdfe :=uint32 (1);var _cgf int ;for ;;_cgf ++{if _gdf [_cgf ]._d <=_aa &&_gdf [_cgf ]._f >=_aa {break ;};};if _aa < 0{_aa =-_aa ;};_aa -=int (_gdf [_cgf ]._cf );_eff :=_gdf [_cgf ]._a ;for _fba :=uint8 (0);_fba < _gdf [_cgf ]._cb ;_fba ++{_eega :=_eff &1;if _cce :=_eggf .encodeBit (_fff ,_gdfe ,_eega );_cce !=nil {return _gcb .Wrap (_cce ,_cea ,"");};_eff >>=1;if _gdfe &0x100> 0{_gdfe =(((_gdfe <<1)|uint32 (_eega ))&0x1ff)|0x100;}else {_gdfe =(_gdfe <<1)|uint32 (_eega );};};_aa <<=32-_gdf [_cgf ]._cc ;for _afae :=uint8 (0);_afae < _gdf [_cgf ]._cc ;_afae ++{_bfe :=uint8 ((uint32 (_aa )&0x80000000)>>31);if _gcfg :=_eggf .encodeBit (_fff ,_gdfe ,_bfe );_gcfg !=nil {return _gcb .Wrap (_gcfg ,_cea ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");};_aa <<=1;if _gdfe &0x100!=0{_gdfe =(((_gdfe <<1)|uint32 (_bfe ))&0x1ff)|0x100;}else {_gdfe =(_gdfe <<1)|uint32 (_bfe );};};return nil ;};var _fc =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};func (_ceg *Encoder )Reset (){_ceg ._cg =0x8000;_ceg ._ga =0;_ceg ._fb =12;_ceg ._af =-1;_ceg ._cd =0;_ceg ._ae =nil ;_ceg ._egb =_bb (_aea );};func (_fbf *Encoder )codeMPS (_efc *codingContext ,_ggda uint32 ,_cbe uint16 ,_dda byte ){_fbf ._cg -=_cbe ;if _fbf ._cg &0x8000!=0{_fbf ._ga +=uint32 (_cbe );return ;};if _fbf ._cg < _cbe {_fbf ._cg =_cbe ;}else {_fbf ._ga +=uint32 (_cbe );};_efc ._de [_ggda ]=_fc [_dda ]._cgb ;_fbf .renormalize ();};type Encoder struct{_ga uint32 ;_cg uint16 ;_fb ,_cd uint8 ;_af int ;_gcf int ;_ca [][]byte ;_ff []byte ;_bf int ;_egb *codingContext ;_bfb [13]*codingContext ;_ae *codingContext ;};var _gdf =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};const (IAAI Class =iota ;IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);func (_dg *Encoder )Init (){_dg ._egb =_bb (_aea );_dg ._cg =0x8000;_dg ._ga =0;_dg ._fb =12;_dg ._af =-1;_dg ._cd =0;_dg ._bf =0;_dg ._ff =make ([]byte ,_fac );for _ce :=0;_ce < len (_dg ._bfb );_ce ++{_dg ._bfb [_ce ]=_bb (512);};_dg ._ae =nil ;};type codingContext struct{_de []byte ;_ebe []byte ;};const (_aea =65536;_fac =20*1024;);func (_bge *Encoder )codeLPS (_ggbb *codingContext ,_ba uint32 ,_ccb uint16 ,_afb byte ){_bge ._cg -=_ccb ;if _bge ._cg < _ccb {_bge ._ga +=uint32 (_ccb );}else {_bge ._cg =_ccb ;};if _fc [_afb ]._bff ==1{_ggbb .flipMps (_ba );};_ggbb ._de [_ba ]=_fc [_afb ]._bfc ;_bge .renormalize ();};func (_ebaf *Encoder )encodeBit (_fd *codingContext ,_fg uint32 ,_gbc uint8 )error {const _ggbg ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";_ebaf ._gcf ++;if _fg >=uint32 (len (_fd ._de )){return _gcb .Errorf (_ggbg ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_fg );};_egg :=_fd ._de [_fg ];_efa :=_fd .mps (_fg );_gcfd :=_fc [_egg ]._ceed ;_gc .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_ebaf ._gcf ,_gbc ,_egg ,_efa ,_gcfd ,_ebaf ._cg ,_ebaf ._ga ,_ebaf ._fb ,_ebaf ._cd ,_ebaf ._af );if _gbc ==0{_ebaf .code0 (_fd ,_fg ,_gcfd ,_egg );}else {_ebaf .code1 (_fd ,_fg ,_gcfd ,_egg );};return nil ;};type Class int ;