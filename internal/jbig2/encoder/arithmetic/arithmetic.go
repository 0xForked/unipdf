//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_e "bytes";_g "github.com/unidoc/unipdf/v3/common";_a "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_aa "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_ea "io";);func (_dff *Encoder )encodeInteger (_gdg Class ,_eff int )error {const _cbg ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";
if _eff > 2000000000||_eff < -2000000000{return _aa .Errorf (_cbg ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_eff );
};_ceb :=_dff ._fece [_gdg ];_agc :=uint32 (1);var _fgc int ;for ;;_fgc ++{if _gf [_fgc ]._b <=_eff &&_gf [_fgc ]._f >=_eff {break ;};};if _eff < 0{_eff =-_eff ;};_eff -=int (_gf [_fgc ]._df );_fcf :=_gf [_fgc ]._bf ;for _ccb :=uint8 (0);_ccb < _gf [_fgc ]._aaga ;
_ccb ++{_ecdf :=_fcf &1;if _gba :=_dff .encodeBit (_ceb ,_agc ,_ecdf );_gba !=nil {return _aa .Wrap (_gba ,_cbg ,"");};_fcf >>=1;if _agc &0x100> 0{_agc =(((_agc <<1)|uint32 (_ecdf ))&0x1ff)|0x100;}else {_agc =(_agc <<1)|uint32 (_ecdf );};};_eff <<=32-_gf [_fgc ]._eg ;
for _ddc :=uint8 (0);_ddc < _gf [_fgc ]._eg ;_ddc ++{_fdc :=uint8 ((uint32 (_eff )&0x80000000)>>31);if _bea :=_dff .encodeBit (_ceb ,_agc ,_fdc );_bea !=nil {return _aa .Wrap (_bea ,_cbg ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");
};_eff <<=1;if _agc &0x100!=0{_agc =(((_agc <<1)|uint32 (_fdc ))&0x1ff)|0x100;}else {_agc =(_agc <<1)|uint32 (_fdc );};};return nil ;};var _cea =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
func (_fgg *Encoder )WriteTo (w _ea .Writer )(int64 ,error ){const _deb ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";var _adc int64 ;for _egf ,_fca :=range _fgg ._ec {_fd ,_db :=w .Write (_fca );if _db !=nil {return 0,_aa .Wrapf (_db ,_deb ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_egf );
};_adc +=int64 (_fd );};_fgg ._bg =_fgg ._bg [:_fgg ._cd ];_ebgf ,_dgb :=w .Write (_fgg ._bg );if _dgb !=nil {return 0,_aa .Wrap (_dgb ,_deb ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_adc +=int64 (_ebgf );return _adc ,nil ;
};func (_ac *Encoder )codeLPS (_ede *codingContext ,_debd uint32 ,_baf uint16 ,_bfa byte ){_ac ._cb -=_baf ;if _ac ._cb < _baf {_ac ._ad +=uint32 (_baf );}else {_ac ._cb =_baf ;};if _cea [_bfa ]._cgf ==1{_ede .flipMps (_debd );};_ede ._fe [_debd ]=_cea [_bfa ]._edd ;
_ac .renormalize ();};func (_cc *codingContext )flipMps (_dc uint32 ){_cc ._bc [_dc ]=1-_cc ._bc [_dc ]};func (_bag *Encoder )renormalize (){for {_bag ._cb <<=1;_bag ._ad <<=1;_bag ._eb --;if _bag ._eb ==0{_bag .byteOut ();};if (_bag ._cb &0x8000)!=0{break ;
};};};func (_ee *Encoder )dataSize ()int {return _ffd *len (_ee ._ec )+_ee ._cd };type codingContext struct{_fe []byte ;_bc []byte ;};type Encoder struct{_ad uint32 ;_cb uint16 ;_eb ,_bce uint8 ;_ba int ;_ca int ;_ec [][]byte ;_bg []byte ;_cd int ;_dcb *codingContext ;
_fece [13]*codingContext ;_cdg *codingContext ;};func (_ed *Encoder )code1 (_bfb *codingContext ,_egb uint32 ,_ded uint16 ,_bdc byte ){if _bfb .mps (_egb )==1{_ed .codeMPS (_bfb ,_egb ,_ded ,_bdc );}else {_ed .codeLPS (_bfb ,_egb ,_ded ,_bdc );};};func (_gb *Encoder )Final (){_gb .flush ()};
func (_cab *Encoder )Reset (){_cab ._cb =0x8000;_cab ._ad =0;_cab ._eb =12;_cab ._ba =-1;_cab ._bce =0;_cab ._cdg =nil ;_cab ._dcb =_fec (_ced );};func (_bff *Encoder )byteOut (){if _bff ._bce ==0xff{_bff .rBlock ();return ;};if _bff ._ad < 0x8000000{_bff .lBlock ();
return ;};_bff ._bce ++;if _bff ._bce !=0xff{_bff .lBlock ();return ;};_bff ._ad &=0x7ffffff;_bff .rBlock ();};func (_gefd *Encoder )EncodeOOB (proc Class )(_dg error ){_g .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );
if _dg =_gefd .encodeOOB (proc );_dg !=nil {return _aa .Wrap (_dg ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};func (_bgf *Encoder )flush (){_bgf .setBits ();_bgf ._ad <<=_bgf ._eb ;_bgf .byteOut ();_bgf ._ad <<=_bgf ._eb ;_bgf .byteOut ();
_bgf .emit ();if _bgf ._bce !=0xff{_bgf ._ba ++;_bgf ._bce =0xff;_bgf .emit ();};_bgf ._ba ++;_bgf ._bce =0xac;_bgf ._ba ++;_bgf .emit ();};const (_ced =65536;_ffd =20*1024;);const (IAAI Class =iota ;IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;
IARDX ;IARDY ;IARI ;);func (_ged *Encoder )Flush (){_ged ._cd =0;_ged ._ec =nil ;_ged ._ba =-1};func (_fa *Encoder )EncodeBitmap (bm *_a .Bitmap ,duplicateLineRemoval bool )error {_g .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );
var (_da ,_ge uint8 ;_fae ,_gef ,_ga uint16 ;_ff ,_fbd ,_fecd byte ;_bge ,_dd ,_ef int ;_ecd ,_feg []byte ;);for _caa :=0;_caa < bm .Height ;_caa ++{_ff ,_fbd =0,0;if _caa >=2{_ff =bm .Data [(_caa -2)*bm .RowStride ];};if _caa >=1{_fbd =bm .Data [(_caa -1)*bm .RowStride ];
if duplicateLineRemoval {_dd =_caa *bm .RowStride ;_ecd =bm .Data [_dd :_dd +bm .RowStride ];_ef =(_caa -1)*bm .RowStride ;_feg =bm .Data [_ef :_ef +bm .RowStride ];if _e .Equal (_ecd ,_feg ){_ge =_da ^1;_da =1;}else {_ge =_da ;_da =0;};};};if duplicateLineRemoval {if _de :=_fa .encodeBit (_fa ._dcb ,_fg ,_ge );
_de !=nil {return _de ;};if _da !=0{continue ;};};_fecd =bm .Data [_caa *bm .RowStride ];_fae =uint16 (_ff >>5);_gef =uint16 (_fbd >>4);_ff <<=3;_fbd <<=4;_ga =0;for _bge =0;_bge < bm .Width ;_bge ++{_be :=uint32 (_fae <<11|_gef <<4|_ga );_ebg :=(_fecd &0x80)>>7;
_bceb :=_fa .encodeBit (_fa ._dcb ,_be ,_ebg );if _bceb !=nil {return _bceb ;};_fae <<=1;_gef <<=1;_ga <<=1;_fae |=uint16 ((_ff &0x80)>>7);_gef |=uint16 ((_fbd &0x80)>>7);_ga |=uint16 (_ebg );_af :=_bge %8;_gd :=_bge /8+1;if _af ==4&&_caa >=2{_ff =0;if _gd < bm .RowStride {_ff =bm .Data [(_caa -2)*bm .RowStride +_gd ];
};}else {_ff <<=1;};if _af ==3&&_caa >=1{_fbd =0;if _gd < bm .RowStride {_fbd =bm .Data [(_caa -1)*bm .RowStride +_gd ];};}else {_fbd <<=1;};if _af ==7{_fecd =0;if _gd < bm .RowStride {_fecd =bm .Data [_caa *bm .RowStride +_gd ];};}else {_fecd <<=1;};_fae &=31;
_gef &=127;_ga &=15;};};return nil ;};var _gf =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};
func (_ae *Encoder )DataSize ()int {return _ae .dataSize ()};type intEncRangeS struct{_b ,_f int ;_bf ,_aaga uint8 ;_df uint16 ;_eg uint8 ;};func (_dfa *codingContext )mps (_c uint32 )int {return int (_dfa ._bc [_c ])};func (_bad *Encoder )Refine (iTemp ,iTarget *_a .Bitmap ,ox ,oy int )error {for _abb :=0;
_abb < iTarget .Height ;_abb ++{var _bee int ;_cf :=_abb +oy ;var (_gde ,_fbc ,_ebf ,_efa ,_ag uint16 ;_geg ,_abg ,_gedd ,_bd ,_eca byte ;);if _cf >=1&&(_cf -1)< iTemp .Height {_geg =iTemp .Data [(_cf -1)*iTemp .RowStride ];};if _cf >=0&&_cf < iTemp .Height {_abg =iTemp .Data [_cf *iTemp .RowStride ];
};if _cf >=-1&&_cf +1< iTemp .Height {_gedd =iTemp .Data [(_cf +1)*iTemp .RowStride ];};if _abb >=1{_bd =iTarget .Data [(_abb -1)*iTarget .RowStride ];};_eca =iTarget .Data [_abb *iTarget .RowStride ];_dcg :=uint (6+ox );_gde =uint16 (_geg >>_dcg );_fbc =uint16 (_abg >>_dcg );
_ebf =uint16 (_gedd >>_dcg );_efa =uint16 (_bd >>6);_gfb :=uint (2-ox );_geg <<=_gfb ;_abg <<=_gfb ;_gedd <<=_gfb ;_bd <<=2;for _bee =0;_bee < iTarget .Width ;_bee ++{_fbf :=(_gde <<10)|(_fbc <<7)|(_ebf <<4)|(_efa <<1)|_ag ;_fac :=_eca >>7;_bbc :=_bad .encodeBit (_bad ._dcb ,uint32 (_fbf ),_fac );
if _bbc !=nil {return _bbc ;};_gde <<=1;_fbc <<=1;_ebf <<=1;_efa <<=1;_gde |=uint16 (_geg >>7);_fbc |=uint16 (_abg >>7);_ebf |=uint16 (_gedd >>7);_efa |=uint16 (_bd >>7);_ag =uint16 (_fac );_abbb :=_bee %8;_ece :=_bee /8+1;if _abbb ==5+ox {_geg ,_abg ,_gedd =0,0,0;
if _ece < iTemp .RowStride &&_cf >=1&&(_cf -1)< iTemp .Height {_geg =iTemp .Data [(_cf -1)*iTemp .RowStride +_ece ];};if _ece < iTemp .RowStride &&_cf >=0&&_cf < iTemp .Height {_abg =iTemp .Data [_cf *iTemp .RowStride +_ece ];};if _ece < iTemp .RowStride &&_cf >=-1&&(_cf +1)< iTemp .Height {_gedd =iTemp .Data [(_cf +1)*iTemp .RowStride +_ece ];
};}else {_geg <<=1;_abg <<=1;_gedd <<=1;};if _abbb ==5&&_abb >=1{_bd =0;if _ece < iTarget .RowStride {_bd =iTarget .Data [(_abb -1)*iTarget .RowStride +_ece ];};}else {_bd <<=1;};if _abbb ==7{_eca =0;if _ece < iTarget .RowStride {_eca =iTarget .Data [_abb *iTarget .RowStride +_ece ];
};}else {_eca <<=1;};_gde &=7;_fbc &=7;_ebf &=7;_efa &=7;};};return nil ;};type state struct{_ddb uint16 ;_adf ,_edd uint8 ;_cgf uint8 ;};func (_bcfa *Encoder )lBlock (){if _bcfa ._ba >=0{_bcfa .emit ();};_bcfa ._ba ++;_bcfa ._bce =uint8 (_bcfa ._ad >>19);
_bcfa ._ad &=0x7ffff;_bcfa ._eb =8;};func _fec (_eac int )*codingContext {return &codingContext {_fe :make ([]byte ,_eac ),_bc :make ([]byte ,_eac )};};func (_bab *Encoder )encodeBit (_gdf *codingContext ,_aef uint32 ,_gg uint8 )error {const _deg ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";
_bab ._ca ++;if _aef >=uint32 (len (_gdf ._fe )){return _aa .Errorf (_deg ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_aef );
};_cg :=_gdf ._fe [_aef ];_aec :=_gdf .mps (_aef );_bcf :=_cea [_cg ]._ddb ;_g .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_bab ._ca ,_gg ,_cg ,_aec ,_bcf ,_bab ._cb ,_bab ._ad ,_bab ._eb ,_bab ._bce ,_bab ._ba );
if _gg ==0{_bab .code0 (_gdf ,_aef ,_bcf ,_cg );}else {_bab .code1 (_gdf ,_aef ,_bcf ,_cg );};return nil ;};func (_dac *Encoder )code0 (_ce *codingContext ,_bgd uint32 ,_fcd uint16 ,_bec byte ){if _ce .mps (_bgd )==0{_dac .codeMPS (_ce ,_bgd ,_fcd ,_bec );
}else {_dac .codeLPS (_ce ,_bgd ,_fcd ,_bec );};};func (_gbd *Encoder )emit (){if _gbd ._cd ==_ffd {_gbd ._ec =append (_gbd ._ec ,_gbd ._bg );_gbd ._bg =make ([]byte ,_ffd );_gbd ._cd =0;};_gbd ._bg [_gbd ._cd ]=_gbd ._bce ;_gbd ._cd ++;};func (_aag Class )String ()string {switch _aag {case IAAI :return "\u0049\u0041\u0041\u0049";
case IADH :return "\u0049\u0041\u0044\u0048";case IADS :return "\u0049\u0041\u0044\u0053";case IADT :return "\u0049\u0041\u0044\u0054";case IADW :return "\u0049\u0041\u0044\u0057";case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";
case IAIT :return "\u0049\u0041\u0049\u0054";case IARDH :return "\u0049\u0041\u0052D\u0048";case IARDW :return "\u0049\u0041\u0052D\u0057";case IARDX :return "\u0049\u0041\u0052D\u0058";case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";
default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";};};func (_fb *Encoder )Init (){_fb ._dcb =_fec (_ced );_fb ._cb =0x8000;_fb ._ad =0;_fb ._eb =12;_fb ._ba =-1;_fb ._bce =0;_fb ._cd =0;_fb ._bg =make ([]byte ,_ffd );for _ab :=0;_ab < len (_fb ._fece );
_ab ++{_fb ._fece [_ab ]=_fec (512);};_fb ._cdg =nil ;};func (_cde *Encoder )setBits (){_effe :=_cde ._ad +uint32 (_cde ._cb );_cde ._ad |=0xffff;if _cde ._ad >=_effe {_cde ._ad -=0x8000;};};const _fg =0x9b25;func (_ega *Encoder )EncodeInteger (proc Class ,value int )(_fc error ){_g .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );
if _fc =_ega .encodeInteger (proc ,value );_fc !=nil {return _aa .Wrap (_fc ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};func (_fbb *Encoder )encodeOOB (_bfbc Class )error {_baa :=_fbb ._fece [_bfbc ];
_bbcf :=_fbb .encodeBit (_baa ,1,1);if _bbcf !=nil {return _bbcf ;};_bbcf =_fbb .encodeBit (_baa ,3,0);if _bbcf !=nil {return _bbcf ;};_bbcf =_fbb .encodeBit (_baa ,6,0);if _bbcf !=nil {return _bbcf ;};_bbcf =_fbb .encodeBit (_baa ,12,0);if _bbcf !=nil {return _bbcf ;
};return nil ;};type Class int ;func (_abf *Encoder )codeMPS (_bdg *codingContext ,_dce uint32 ,_bcd uint16 ,_aaf byte ){_abf ._cb -=_bcd ;if _abf ._cb &0x8000!=0{_abf ._ad +=uint32 (_bcd );return ;};if _abf ._cb < _bcd {_abf ._cb =_bcd ;}else {_abf ._ad +=uint32 (_bcd );
};_bdg ._fe [_dce ]=_cea [_aaf ]._adf ;_abf .renormalize ();};var _ _ea .WriterTo =&Encoder {};func New ()*Encoder {_bb :=&Encoder {};_bb .Init ();return _bb };func (_gab *Encoder )EncodeIAID (symbolCodeLength ,value int )(_fge error ){_g .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );
if _fge =_gab .encodeIAID (symbolCodeLength ,value );_fge !=nil {return _aa .Wrap (_fge ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};func (_cad *Encoder )rBlock (){if _cad ._ba >=0{_cad .emit ();};_cad ._ba ++;_cad ._bce =uint8 (_cad ._ad >>20);
_cad ._ad &=0xfffff;_cad ._eb =7;};func (_cfb *Encoder )encodeIAID (_edb ,_gegb int )error {if _cfb ._cdg ==nil {_cfb ._cdg =_fec (1<<uint (_edb ));};_bba :=uint32 (1<<uint32 (_edb +1))-1;_gegb <<=uint (32-_edb );_cag :=uint32 (1);for _dceb :=0;_dceb < _edb ;
_dceb ++{_dag :=_cag &_bba ;_ecb :=uint8 ((uint32 (_gegb )&0x80000000)>>31);if _ffg :=_cfb .encodeBit (_cfb ._cdg ,_dag ,_ecb );_ffg !=nil {return _ffg ;};_cag =(_cag <<1)|uint32 (_ecb );_gegb <<=1;};return nil ;};