//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_b "bytes";_da "github.com/unidoc/unipdf/v3/common";_c "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_g "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_d "io";);func (_efa *Encoder )EncodeOOB (proc Class )(_ag error ){_da .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );if _ag =_efa .encodeOOB (proc );_ag !=nil {return _g .Wrap (_ag ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};type state struct{_fbd uint16 ;_bea ,_bagd uint8 ;_fdb uint8 ;};func (_eag *Encoder )Final (){_eag .flush ()};func _df (_gc int )*codingContext {return &codingContext {_eg :make ([]byte ,_gc ),_gf :make ([]byte ,_gc )};};func (_bf *codingContext )mps (_db uint32 )int {return int (_bf ._gf [_db ])};func (_fd *Encoder )Reset (){_fd ._cc =0x8000;_fd ._cf =0;_fd ._dac =12;_fd ._gg =-1;_fd ._dd =0;_fd ._cca =nil ;_fd ._ffc =_df (_ccd );};func (_gb *Encoder )Flush (){_gb ._ff =0;_gb ._gcc =nil ;_gb ._gg =-1};func (_ggb *Encoder )Init (){_ggb ._ffc =_df (_ccd );_ggb ._cc =0x8000;_ggb ._cf =0;_ggb ._dac =12;_ggb ._gg =-1;_ggb ._dd =0;_ggb ._ff =0;_ggb ._bfe =make ([]byte ,_ffd );for _ad :=0;_ad < len (_ggb ._ec );_ad ++{_ggb ._ec [_ad ]=_df (512);};_ggb ._cca =nil ;};var _eef =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};type Encoder struct{_cf uint32 ;_cc uint16 ;_dac ,_dd uint8 ;_gg int ;_dde int ;_gcc [][]byte ;_bfe []byte ;_ff int ;_ffc *codingContext ;_ec [13]*codingContext ;_cca *codingContext ;};func (_fef *Encoder )EncodeInteger (proc Class ,value int )(_fa error ){_da .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );if _fa =_fef .encodeInteger (proc ,value );_fa !=nil {return _g .Wrap (_fa ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};type Class int ;func (_gcf *Encoder )encodeInteger (_cgd Class ,_ggg int )error {const _ecc ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";if _ggg > 2000000000||_ggg < -2000000000{return _g .Errorf (_ecc ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_ggg );};_efb :=_gcf ._ec [_cgd ];_afd :=uint32 (1);var _ca int ;for ;;_ca ++{if _ce [_ca ]._dg <=_ggg &&_ce [_ca ]._a >=_ggg {break ;};};if _ggg < 0{_ggg =-_ggg ;};_ggg -=int (_ce [_ca ]._ef );_dcf :=_ce [_ca ]._be ;for _cbgd :=uint8 (0);_cbgd < _ce [_ca ]._ae ;_cbgd ++{_dad :=_dcf &1;if _dacd :=_gcf .encodeBit (_efb ,_afd ,_dad );_dacd !=nil {return _g .Wrap (_dacd ,_ecc ,"");};_dcf >>=1;if _afd &0x100> 0{_afd =(((_afd <<1)|uint32 (_dad ))&0x1ff)|0x100;}else {_afd =(_afd <<1)|uint32 (_dad );};};_ggg <<=32-_ce [_ca ]._fe ;for _bfgc :=uint8 (0);_bfgc < _ce [_ca ]._fe ;_bfgc ++{_fbgb :=uint8 ((uint32 (_ggg )&0x80000000)>>31);if _dgf :=_gcf .encodeBit (_efb ,_afd ,_fbgb );_dgf !=nil {return _g .Wrap (_dgf ,_ecc ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");};_ggg <<=1;if _afd &0x100!=0{_afd =(((_afd <<1)|uint32 (_fbgb ))&0x1ff)|0x100;}else {_afd =(_afd <<1)|uint32 (_fbgb );};};return nil ;};func (_fg *codingContext )flipMps (_dga uint32 ){_fg ._gf [_dga ]=1-_fg ._gf [_dga ]};const (_ccd =65536;_ffd =20*1024;);func New ()*Encoder {_ba :=&Encoder {};_ba .Init ();return _ba };func (_agf *Encoder )dataSize ()int {return _ffd *len (_agf ._gcc )+_agf ._ff };func (_e Class )String ()string {switch _e {case IAAI :return "\u0049\u0041\u0041\u0049";case IADH :return "\u0049\u0041\u0044\u0048";case IADS :return "\u0049\u0041\u0044\u0053";case IADT :return "\u0049\u0041\u0044\u0054";case IADW :return "\u0049\u0041\u0044\u0057";case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";case IAIT :return "\u0049\u0041\u0049\u0054";case IARDH :return "\u0049\u0041\u0052D\u0048";case IARDW :return "\u0049\u0041\u0052D\u0057";case IARDX :return "\u0049\u0041\u0052D\u0058";case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";};};func (_ee *Encoder )byteOut (){if _ee ._dd ==0xff{_ee .rBlock ();return ;};if _ee ._cf < 0x8000000{_ee .lBlock ();return ;};_ee ._dd ++;if _ee ._dd !=0xff{_ee .lBlock ();return ;};_ee ._cf &=0x7ffffff;_ee .rBlock ();};var _ce =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};func (_bda *Encoder )Refine (iTemp ,iTarget *_c .Bitmap ,ox ,oy int )error {for _dc :=0;_dc < iTarget .Height ;_dc ++{var _dba int ;_ggba :=_dc +oy ;var (_cg ,_ded ,_bfg ,_efd ,_bcc uint16 ;_dfe ,_eb ,_bed ,_dfec ,_ecgb byte ;);if _ggba >=1&&(_ggba -1)< iTemp .Height {_dfe =iTemp .Data [(_ggba -1)*iTemp .RowStride ];};if _ggba >=0&&_ggba < iTemp .Height {_eb =iTemp .Data [_ggba *iTemp .RowStride ];};if _ggba >=-1&&_ggba +1< iTemp .Height {_bed =iTemp .Data [(_ggba +1)*iTemp .RowStride ];};if _dc >=1{_dfec =iTarget .Data [(_dc -1)*iTarget .RowStride ];};_ecgb =iTarget .Data [_dc *iTarget .RowStride ];_fgf :=uint (6+ox );_cg =uint16 (_dfe >>_fgf );_ded =uint16 (_eb >>_fgf );_bfg =uint16 (_bed >>_fgf );_efd =uint16 (_dfec >>6);_fbe :=uint (2-ox );_dfe <<=_fbe ;_eb <<=_fbe ;_bed <<=_fbe ;_dfec <<=2;for _dba =0;_dba < iTarget .Width ;_dba ++{_bb :=(_cg <<10)|(_ded <<7)|(_bfg <<4)|(_efd <<1)|_bcc ;_def :=_ecgb >>7;_bag :=_bda .encodeBit (_bda ._ffc ,uint32 (_bb ),_def );if _bag !=nil {return _bag ;};_cg <<=1;_ded <<=1;_bfg <<=1;_efd <<=1;_cg |=uint16 (_dfe >>7);_ded |=uint16 (_eb >>7);_bfg |=uint16 (_bed >>7);_efd |=uint16 (_dfec >>7);_bcc =uint16 (_def );_aac :=_dba %8;_feb :=_dba /8+1;if _aac ==5+ox {_dfe ,_eb ,_bed =0,0,0;if _feb < iTemp .RowStride &&_ggba >=1&&(_ggba -1)< iTemp .Height {_dfe =iTemp .Data [(_ggba -1)*iTemp .RowStride +_feb ];};if _feb < iTemp .RowStride &&_ggba >=0&&_ggba < iTemp .Height {_eb =iTemp .Data [_ggba *iTemp .RowStride +_feb ];};if _feb < iTemp .RowStride &&_ggba >=-1&&(_ggba +1)< iTemp .Height {_bed =iTemp .Data [(_ggba +1)*iTemp .RowStride +_feb ];};}else {_dfe <<=1;_eb <<=1;_bed <<=1;};if _aac ==5&&_dc >=1{_dfec =0;if _feb < iTarget .RowStride {_dfec =iTarget .Data [(_dc -1)*iTarget .RowStride +_feb ];};}else {_dfec <<=1;};if _aac ==7{_ecgb =0;if _feb < iTarget .RowStride {_ecgb =iTarget .Data [_dc *iTarget .RowStride +_feb ];};}else {_ecgb <<=1;};_cg &=7;_ded &=7;_bfg &=7;_efd &=7;};};return nil ;};func (_adc *Encoder )WriteTo (w _d .Writer )(int64 ,error ){const _bdf ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";var _ffb int64 ;for _fff ,_ade :=range _adc ._gcc {_abcf ,_bce :=w .Write (_ade );if _bce !=nil {return 0,_g .Wrapf (_bce ,_bdf ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_fff );};_ffb +=int64 (_abcf );};_adc ._bfe =_adc ._bfe [:_adc ._ff ];_aeg ,_febc :=w .Write (_adc ._bfe );if _febc !=nil {return 0,_g .Wrap (_febc ,_bdf ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_ffb +=int64 (_aeg );return _ffb ,nil ;};func (_bfd *Encoder )lBlock (){if _bfd ._gg >=0{_bfd .emit ();};_bfd ._gg ++;_bfd ._dd =uint8 (_bfd ._cf >>19);_bfd ._cf &=0x7ffff;_bfd ._dac =8;};func (_fb *Encoder )EncodeBitmap (bm *_c .Bitmap ,duplicateLineRemoval bool )error {_da .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );var (_bfa ,_bd uint8 ;_af ,_eda ,_ecg uint16 ;_egb ,_ege ,_edd byte ;_ede ,_gccc ,_cff int ;_ddeg ,_de []byte ;);for _bc :=0;_bc < bm .Height ;_bc ++{_egb ,_ege =0,0;if _bc >=2{_egb =bm .Data [(_bc -2)*bm .RowStride ];};if _bc >=1{_ege =bm .Data [(_bc -1)*bm .RowStride ];if duplicateLineRemoval {_gccc =_bc *bm .RowStride ;_ddeg =bm .Data [_gccc :_gccc +bm .RowStride ];_cff =(_bc -1)*bm .RowStride ;_de =bm .Data [_cff :_cff +bm .RowStride ];if _b .Equal (_ddeg ,_de ){_bd =_bfa ^1;_bfa =1;}else {_bd =_bfa ;_bfa =0;};};};if duplicateLineRemoval {if _ab :=_fb .encodeBit (_fb ._ffc ,_ea ,_bd );_ab !=nil {return _ab ;};if _bfa !=0{continue ;};};_edd =bm .Data [_bc *bm .RowStride ];_af =uint16 (_egb >>5);_eda =uint16 (_ege >>4);_egb <<=3;_ege <<=4;_ecg =0;for _ede =0;_ede < bm .Width ;_ede ++{_cb :=uint32 (_af <<11|_eda <<4|_ecg );_aa :=(_edd &0x80)>>7;_bg :=_fb .encodeBit (_fb ._ffc ,_cb ,_aa );if _bg !=nil {return _bg ;};_af <<=1;_eda <<=1;_ecg <<=1;_af |=uint16 ((_egb &0x80)>>7);_eda |=uint16 ((_ege &0x80)>>7);_ecg |=uint16 (_aa );_bcd :=_ede %8;_dec :=_ede /8+1;if _bcd ==4&&_bc >=2{_egb =0;if _dec < bm .RowStride {_egb =bm .Data [(_bc -2)*bm .RowStride +_dec ];};}else {_egb <<=1;};if _bcd ==3&&_bc >=1{_ege =0;if _dec < bm .RowStride {_ege =bm .Data [(_bc -1)*bm .RowStride +_dec ];};}else {_ege <<=1;};if _bcd ==7{_edd =0;if _dec < bm .RowStride {_edd =bm .Data [_bc *bm .RowStride +_dec ];};}else {_edd <<=1;};_af &=31;_eda &=127;_ecg &=15;};};return nil ;};func (_eeb *Encoder )rBlock (){if _eeb ._gg >=0{_eeb .emit ();};_eeb ._gg ++;_eeb ._dd =uint8 (_eeb ._cf >>20);_eeb ._cf &=0xfffff;_eeb ._dac =7;};func (_ed *Encoder )DataSize ()int {return _ed .dataSize ()};func (_bgf *Encoder )encodeOOB (_dagad Class )error {_gfc :=_bgf ._ec [_dagad ];_gbd :=_bgf .encodeBit (_gfc ,1,1);if _gbd !=nil {return _gbd ;};_gbd =_bgf .encodeBit (_gfc ,3,0);if _gbd !=nil {return _gbd ;};_gbd =_bgf .encodeBit (_gfc ,6,0);if _gbd !=nil {return _gbd ;};_gbd =_bgf .encodeBit (_gfc ,12,0);if _gbd !=nil {return _gbd ;};return nil ;};func (_dag *Encoder )emit (){if _dag ._ff ==_ffd {_dag ._gcc =append (_dag ._gcc ,_dag ._bfe );_dag ._bfe =make ([]byte ,_ffd );_dag ._ff =0;};_dag ._bfe [_dag ._ff ]=_dag ._dd ;_dag ._ff ++;};func (_baa *Encoder )flush (){_baa .setBits ();_baa ._cf <<=_baa ._dac ;_baa .byteOut ();_baa ._cf <<=_baa ._dac ;_baa .byteOut ();_baa .emit ();if _baa ._dd !=0xff{_baa ._gg ++;_baa ._dd =0xff;_baa .emit ();};_baa ._gg ++;_baa ._dd =0xac;_baa ._gg ++;_baa .emit ();};var _ _d .WriterTo =&Encoder {};type intEncRangeS struct{_dg ,_a int ;_be ,_ae uint8 ;_ef uint16 ;_fe uint8 ;};const (IAAI Class =iota ;IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);func (_eae *Encoder )renormalize (){for {_eae ._cc <<=1;_eae ._cf <<=1;_eae ._dac --;if _eae ._dac ==0{_eae .byteOut ();};if (_eae ._cc &0x8000)!=0{break ;};};};func (_ggdg *Encoder )encodeBit (_gga *codingContext ,_fbb uint32 ,_bae uint8 )error {const _dge ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";_ggdg ._dde ++;if _fbb >=uint32 (len (_gga ._eg )){return _g .Errorf (_dge ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_fbb );};_aag :=_gga ._eg [_fbb ];_cd :=_gga .mps (_fbb );_daga :=_eef [_aag ]._fbd ;_da .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_ggdg ._dde ,_bae ,_aag ,_cd ,_daga ,_ggdg ._cc ,_ggdg ._cf ,_ggdg ._dac ,_ggdg ._dd ,_ggdg ._gg );if _bae ==0{_ggdg .code0 (_gga ,_fbb ,_daga ,_aag );}else {_ggdg .code1 (_gga ,_fbb ,_daga ,_aag );};return nil ;};func (_dbg *Encoder )setBits (){_gbg :=_dbg ._cf +uint32 (_dbg ._cc );_dbg ._cf |=0xffff;if _dbg ._cf >=_gbg {_dbg ._cf -=0x8000;};};type codingContext struct{_eg []byte ;_gf []byte ;};func (_ggd *Encoder )code1 (_eab *codingContext ,_dede uint32 ,_abe uint16 ,_eca byte ){if _eab .mps (_dede )==1{_ggd .codeMPS (_eab ,_dede ,_abe ,_eca );}else {_ggd .codeLPS (_eab ,_dede ,_abe ,_eca );};};func (_fgc *Encoder )code0 (_ega *codingContext ,_edf uint32 ,_aae uint16 ,_cfg byte ){if _ega .mps (_edf )==0{_fgc .codeMPS (_ega ,_edf ,_aae ,_cfg );}else {_fgc .codeLPS (_ega ,_edf ,_aae ,_cfg );};};func (_fba *Encoder )codeMPS (_ccc *codingContext ,_ggc uint32 ,_deg uint16 ,_cbg byte ){_fba ._cc -=_deg ;if _fba ._cc &0x8000!=0{_fba ._cf +=uint32 (_deg );return ;};if _fba ._cc < _deg {_fba ._cc =_deg ;}else {_fba ._cf +=uint32 (_deg );};_ccc ._eg [_ggc ]=_eef [_cbg ]._bea ;_fba .renormalize ();};const _ea =0x9b25;func (_bfb *Encoder )codeLPS (_eddf *codingContext ,_ccf uint32 ,_gba uint16 ,_fbg byte ){_bfb ._cc -=_gba ;if _bfb ._cc < _gba {_bfb ._cf +=uint32 (_gba );}else {_bfb ._cc =_gba ;};if _eef [_fbg ]._fdb ==1{_eddf .flipMps (_ccf );};_eddf ._eg [_ccf ]=_eef [_fbg ]._bagd ;_bfb .renormalize ();};func (_gff *Encoder )encodeIAID (_bceg ,_ebc int )error {if _gff ._cca ==nil {_gff ._cca =_df (1<<uint (_bceg ));};_edfe :=uint32 (1<<uint32 (_bceg +1))-1;_ebc <<=uint (32-_bceg );_bbe :=uint32 (1);for _bbd :=0;_bbd < _bceg ;_bbd ++{_bec :=_bbe &_edfe ;_bge :=uint8 ((uint32 (_ebc )&0x80000000)>>31);if _fgd :=_gff .encodeBit (_gff ._cca ,_bec ,_bge );_fgd !=nil {return _fgd ;};_bbe =(_bbe <<1)|uint32 (_bge );_ebc <<=1;};return nil ;};func (_abc *Encoder )EncodeIAID (symbolCodeLength ,value int )(_bde error ){_da .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );if _bde =_abc .encodeIAID (symbolCodeLength ,value );_bde !=nil {return _g .Wrap (_bde ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};