//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_e "bytes";_gd "github.com/unidoc/unipdf/v3/common";_b "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_ec "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_d "io";);func (_abb *Encoder )EncodeInteger (proc Class ,value int )(_aca error ){_gd .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );
if _aca =_abb .encodeInteger (proc ,value );_aca !=nil {return _ec .Wrap (_aca ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};func New ()*Encoder {_cec :=&Encoder {};_cec .Init ();return _cec };type Encoder struct{_fc uint32 ;
_ea uint16 ;_eaa ,_ce uint8 ;_df int ;_db int ;_gdb [][]byte ;_cg []byte ;_cc int ;_geb *codingContext ;_gdgb [13]*codingContext ;_bf *codingContext ;};func (_bgg *Encoder )encodeInteger (_bgb Class ,_fae int )error {const _gacc ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";
if _fae > 2000000000||_fae < -2000000000{return _ec .Errorf (_gacc ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_fae );
};_gfa :=_bgg ._gdgb [_bgb ];_da :=uint32 (1);var _gef int ;for ;;_gef ++{if _ab [_gef ]._fe <=_fae &&_ab [_gef ]._bg >=_fae {break ;};};if _fae < 0{_fae =-_fae ;};_fae -=int (_ab [_gef ]._ed );_dgdf :=_ab [_gef ]._a ;for _gba :=uint8 (0);_gba < _ab [_gef ]._fee ;
_gba ++{_eee :=_dgdf &1;if _bfg :=_bgg .encodeBit (_gfa ,_da ,_eee );_bfg !=nil {return _ec .Wrap (_bfg ,_gacc ,"");};_dgdf >>=1;if _da &0x100> 0{_da =(((_da <<1)|uint32 (_eee ))&0x1ff)|0x100;}else {_da =(_da <<1)|uint32 (_eee );};};_fae <<=32-_ab [_gef ]._fa ;
for _cdf :=uint8 (0);_cdf < _ab [_gef ]._fa ;_cdf ++{_feaf :=uint8 ((uint32 (_fae )&0x80000000)>>31);if _ffe :=_bgg .encodeBit (_gfa ,_da ,_feaf );_ffe !=nil {return _ec .Wrap (_ffe ,_gacc ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");
};_fae <<=1;if _da &0x100!=0{_da =(((_da <<1)|uint32 (_feaf ))&0x1ff)|0x100;}else {_da =(_da <<1)|uint32 (_feaf );};};return nil ;};func (_gaf *Encoder )Flush (){_gaf ._cc =0;_gaf ._gdb =nil ;_gaf ._df =-1};func (_fdd *Encoder )Refine (iTemp ,iTarget *_b .Bitmap ,ox ,oy int )error {for _ccc :=0;
_ccc < iTarget .Height ;_ccc ++{var _edc int ;_ae :=_ccc +oy ;var (_edf ,_dbc ,_bfa ,_eec ,_ceca uint16 ;_dec ,_gf ,_eef ,_gfg ,_fbe byte ;);if _ae >=1&&(_ae -1)< iTemp .Height {_dec =iTemp .Data [(_ae -1)*iTemp .RowStride ];};if _ae >=0&&_ae < iTemp .Height {_gf =iTemp .Data [_ae *iTemp .RowStride ];
};if _ae >=-1&&_ae +1< iTemp .Height {_eef =iTemp .Data [(_ae +1)*iTemp .RowStride ];};if _ccc >=1{_gfg =iTarget .Data [(_ccc -1)*iTarget .RowStride ];};_fbe =iTarget .Data [_ccc *iTarget .RowStride ];_bb :=uint (6+ox );_edf =uint16 (_dec >>_bb );_dbc =uint16 (_gf >>_bb );
_bfa =uint16 (_eef >>_bb );_eec =uint16 (_gfg >>6);_cgac :=uint (2-ox );_dec <<=_cgac ;_gf <<=_cgac ;_eef <<=_cgac ;_gfg <<=2;for _edc =0;_edc < iTarget .Width ;_edc ++{_gea :=(_edf <<10)|(_dbc <<7)|(_bfa <<4)|(_eec <<1)|_ceca ;_dgf :=_fbe >>7;_aa :=_fdd .encodeBit (_fdd ._geb ,uint32 (_gea ),_dgf );
if _aa !=nil {return _aa ;};_edf <<=1;_dbc <<=1;_bfa <<=1;_eec <<=1;_edf |=uint16 (_dec >>7);_dbc |=uint16 (_gf >>7);_bfa |=uint16 (_eef >>7);_eec |=uint16 (_gfg >>7);_ceca =uint16 (_dgf );_gc :=_edc %8;_dc :=_edc /8+1;if _gc ==5+ox {_dec ,_gf ,_eef =0,0,0;
if _dc < iTemp .RowStride &&_ae >=1&&(_ae -1)< iTemp .Height {_dec =iTemp .Data [(_ae -1)*iTemp .RowStride +_dc ];};if _dc < iTemp .RowStride &&_ae >=0&&_ae < iTemp .Height {_gf =iTemp .Data [_ae *iTemp .RowStride +_dc ];};if _dc < iTemp .RowStride &&_ae >=-1&&(_ae +1)< iTemp .Height {_eef =iTemp .Data [(_ae +1)*iTemp .RowStride +_dc ];
};}else {_dec <<=1;_gf <<=1;_eef <<=1;};if _gc ==5&&_ccc >=1{_gfg =0;if _dc < iTarget .RowStride {_gfg =iTarget .Data [(_ccc -1)*iTarget .RowStride +_dc ];};}else {_gfg <<=1;};if _gc ==7{_fbe =0;if _dc < iTarget .RowStride {_fbe =iTarget .Data [_ccc *iTarget .RowStride +_dc ];
};}else {_fbe <<=1;};_edf &=7;_dbc &=7;_bfa &=7;_eec &=7;};};return nil ;};type state struct{_fafd uint16 ;_bcdb ,_ddf uint8 ;_fdad uint8 ;};func (_eb *Encoder )Init (){_eb ._geb =_dd (_edfb );_eb ._ea =0x8000;_eb ._fc =0;_eb ._eaa =12;_eb ._df =-1;_eb ._ce =0;
_eb ._cc =0;_eb ._cg =make ([]byte ,_dbcb );for _fba :=0;_fba < len (_eb ._gdgb );_fba ++{_eb ._gdgb [_fba ]=_dd (512);};_eb ._bf =nil ;};func (_eg *Encoder )Final (){_eg .flush ()};func (_geg *Encoder )byteOut (){if _geg ._ce ==0xff{_geg .rBlock ();return ;
};if _geg ._fc < 0x8000000{_geg .lBlock ();return ;};_geg ._ce ++;if _geg ._ce !=0xff{_geg .lBlock ();return ;};_geg ._fc &=0x7ffffff;_geg .rBlock ();};var _agd =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
func (_fda *Encoder )setBits (){_dgg :=_fda ._fc +uint32 (_fda ._ea );_fda ._fc |=0xffff;if _fda ._fc >=_dgg {_fda ._fc -=0x8000;};};func (_bc *Encoder )EncodeBitmap (bm *_b .Bitmap ,duplicateLineRemoval bool )error {_gd .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );
var (_gg ,_dfc uint8 ;_dg ,_cee ,_cgd uint16 ;_de ,_ced ,_ddg byte ;_cgc ,_ade ,_gb int ;_eae ,_ccf []byte ;);for _ff :=0;_ff < bm .Height ;_ff ++{_de ,_ced =0,0;if _ff >=2{_de =bm .Data [(_ff -2)*bm .RowStride ];};if _ff >=1{_ced =bm .Data [(_ff -1)*bm .RowStride ];
if duplicateLineRemoval {_ade =_ff *bm .RowStride ;_eae =bm .Data [_ade :_ade +bm .RowStride ];_gb =(_ff -1)*bm .RowStride ;_ccf =bm .Data [_gb :_gb +bm .RowStride ];if _e .Equal (_eae ,_ccf ){_dfc =_gg ^1;_gg =1;}else {_dfc =_gg ;_gg =0;};};};if duplicateLineRemoval {if _af :=_bc .encodeBit (_bc ._geb ,_fd ,_dfc );
_af !=nil {return _af ;};if _gg !=0{continue ;};};_ddg =bm .Data [_ff *bm .RowStride ];_dg =uint16 (_de >>5);_cee =uint16 (_ced >>4);_de <<=3;_ced <<=4;_cgd =0;for _cgc =0;_cgc < bm .Width ;_cgc ++{_cga :=uint32 (_dg <<11|_cee <<4|_cgd );_bcf :=(_ddg &0x80)>>7;
_ac :=_bc .encodeBit (_bc ._geb ,_cga ,_bcf );if _ac !=nil {return _ac ;};_dg <<=1;_cee <<=1;_cgd <<=1;_dg |=uint16 ((_de &0x80)>>7);_cee |=uint16 ((_ced &0x80)>>7);_cgd |=uint16 (_bcf );_ebg :=_cgc %8;_ga :=_cgc /8+1;if _ebg ==4&&_ff >=2{_de =0;if _ga < bm .RowStride {_de =bm .Data [(_ff -2)*bm .RowStride +_ga ];
};}else {_de <<=1;};if _ebg ==3&&_ff >=1{_ced =0;if _ga < bm .RowStride {_ced =bm .Data [(_ff -1)*bm .RowStride +_ga ];};}else {_ced <<=1;};if _ebg ==7{_ddg =0;if _ga < bm .RowStride {_ddg =bm .Data [_ff *bm .RowStride +_ga ];};}else {_ddg <<=1;};_dg &=31;
_cee &=127;_cgd &=15;};};return nil ;};func (_faf *Encoder )codeLPS (_ca *codingContext ,_bcd uint32 ,_bad uint16 ,_bec byte ){_faf ._ea -=_bad ;if _faf ._ea < _bad {_faf ._fc +=uint32 (_bad );}else {_faf ._ea =_bad ;};if _agd [_bec ]._fdad ==1{_ca .flipMps (_bcd );
};_ca ._c [_bcd ]=_agd [_bec ]._ddf ;_faf .renormalize ();};func (_fb *codingContext )mps (_gdg uint32 )int {return int (_fb ._ge [_gdg ])};func (_fbab *Encoder )EncodeOOB (proc Class )(_cca error ){_gd .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );
if _cca =_fbab .encodeOOB (proc );_cca !=nil {return _ec .Wrap (_cca ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};const _fd =0x9b25;func (_bbg *Encoder )dataSize ()int {return _dbcb *len (_bbg ._gdb )+_bbg ._cc };func (_gbc *Encoder )EncodeIAID (symbolCodeLength ,value int )(_ecd error ){_gd .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );
if _ecd =_gbc .encodeIAID (symbolCodeLength ,value );_ecd !=nil {return _ec .Wrap (_ecd ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};func (_fea *Encoder )WriteTo (w _d .Writer )(int64 ,error ){const _dbf ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";
var _edg int64 ;for _deb ,_dff :=range _fea ._gdb {_ece ,_aaa :=w .Write (_dff );if _aaa !=nil {return 0,_ec .Wrapf (_aaa ,_dbf ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_deb );
};_edg +=int64 (_ece );};_fea ._cg =_fea ._cg [:_fea ._cc ];_gbg ,_ag :=w .Write (_fea ._cg );if _ag !=nil {return 0,_ec .Wrap (_ag ,_dbf ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_edg +=int64 (_gbg );return _edg ,nil ;
};var _ab =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};
func (_afe *Encoder )code1 (_bcg *codingContext ,_bce uint32 ,_gac uint16 ,_be byte ){if _bcg .mps (_bce )==1{_afe .codeMPS (_bcg ,_bce ,_gac ,_be );}else {_afe .codeLPS (_bcg ,_bce ,_gac ,_be );};};func (_ee *Encoder )DataSize ()int {return _ee .dataSize ()};
type codingContext struct{_c []byte ;_ge []byte ;};func (_bfae *Encoder )encodeIAID (_gfd ,_cgdg int )error {if _bfae ._bf ==nil {_bfae ._bf =_dd (1<<uint (_gfd ));};_gab :=uint32 (1<<uint32 (_gfd +1))-1;_cgdg <<=uint (32-_gfd );_feeb :=uint32 (1);for _fag :=0;
_fag < _gfd ;_fag ++{_bcdc :=_feeb &_gab ;_bae :=uint8 ((uint32 (_cgdg )&0x80000000)>>31);if _fadfc :=_bfae .encodeBit (_bfae ._bf ,_bcdc ,_bae );_fadfc !=nil {return _fadfc ;};_feeb =(_feeb <<1)|uint32 (_bae );_cgdg <<=1;};return nil ;};const (_edfb =65536;
_dbcb =20*1024;);func (_cece *Encoder )encodeBit (_gdd *codingContext ,_fdg uint32 ,_cd uint8 )error {const _ebe ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";_cece ._db ++;if _fdg >=uint32 (len (_gdd ._c )){return _ec .Errorf (_ebe ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_fdg );
};_ddb :=_gdd ._c [_fdg ];_eaf :=_gdd .mps (_fdg );_bbc :=_agd [_ddb ]._fafd ;_gd .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_cece ._db ,_cd ,_ddb ,_eaf ,_bbc ,_cece ._ea ,_cece ._fc ,_cece ._eaa ,_cece ._ce ,_cece ._df );
if _cd ==0{_cece .code0 (_gdd ,_fdg ,_bbc ,_ddb );}else {_cece .code1 (_gdd ,_fdg ,_bbc ,_ddb );};return nil ;};func _dd (_ad int )*codingContext {return &codingContext {_c :make ([]byte ,_ad ),_ge :make ([]byte ,_ad )};};const (IAAI Class =iota ;IADH ;
IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);func (_fg *Encoder )rBlock (){if _fg ._df >=0{_fg .emit ();};_fg ._df ++;_fg ._ce =uint8 (_fg ._fc >>20);_fg ._fc &=0xfffff;_fg ._eaa =7;};func (_afed *Encoder )lBlock (){if _afed ._df >=0{_afed .emit ();
};_afed ._df ++;_afed ._ce =uint8 (_afed ._fc >>19);_afed ._fc &=0x7ffff;_afed ._eaa =8;};var _ _d .WriterTo =&Encoder {};func (_age *Encoder )flush (){_age .setBits ();_age ._fc <<=_age ._eaa ;_age .byteOut ();_age ._fc <<=_age ._eaa ;_age .byteOut ();
_age .emit ();if _age ._ce !=0xff{_age ._df ++;_age ._ce =0xff;_age .emit ();};_age ._df ++;_age ._ce =0xac;_age ._df ++;_age .emit ();};func (_dgd *Encoder )code0 (_dee *codingContext ,_cf uint32 ,_gdf uint16 ,_deg byte ){if _dee .mps (_cf )==0{_dgd .codeMPS (_dee ,_cf ,_gdf ,_deg );
}else {_dgd .codeLPS (_dee ,_cf ,_gdf ,_deg );};};func (_fcb *Encoder )renormalize (){for {_fcb ._ea <<=1;_fcb ._fc <<=1;_fcb ._eaa --;if _fcb ._eaa ==0{_fcb .byteOut ();};if (_fcb ._ea &0x8000)!=0{break ;};};};func (_fad *codingContext )flipMps (_ba uint32 ){_fad ._ge [_ba ]=1-_fad ._ge [_ba ]};
func (_aea *Encoder )emit (){if _aea ._cc ==_dbcb {_aea ._gdb =append (_aea ._gdb ,_aea ._cg );_aea ._cg =make ([]byte ,_dbcb );_aea ._cc =0;};_aea ._cg [_aea ._cc ]=_aea ._ce ;_aea ._cc ++;};func (_cde *Encoder )encodeOOB (_ddc Class )error {_ddcc :=_cde ._gdgb [_ddc ];
_bcb :=_cde .encodeBit (_ddcc ,1,1);if _bcb !=nil {return _bcb ;};_bcb =_cde .encodeBit (_ddcc ,3,0);if _bcb !=nil {return _bcb ;};_bcb =_cde .encodeBit (_ddcc ,6,0);if _bcb !=nil {return _bcb ;};_bcb =_cde .encodeBit (_ddcc ,12,0);if _bcb !=nil {return _bcb ;
};return nil ;};type Class int ;func (_f Class )String ()string {switch _f {case IAAI :return "\u0049\u0041\u0041\u0049";case IADH :return "\u0049\u0041\u0044\u0048";case IADS :return "\u0049\u0041\u0044\u0053";case IADT :return "\u0049\u0041\u0044\u0054";
case IADW :return "\u0049\u0041\u0044\u0057";case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";case IAIT :return "\u0049\u0041\u0049\u0054";case IARDH :return "\u0049\u0041\u0052D\u0048";case IARDW :return "\u0049\u0041\u0052D\u0057";
case IARDX :return "\u0049\u0041\u0052D\u0058";case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";};};func (_fadf *Encoder )Reset (){_fadf ._ea =0x8000;_fadf ._fc =0;
_fadf ._eaa =12;_fadf ._df =-1;_fadf ._ce =0;_fadf ._bf =nil ;_fadf ._geb =_dd (_edfb );};type intEncRangeS struct{_fe ,_bg int ;_a ,_fee uint8 ;_ed uint16 ;_fa uint8 ;};func (_geae *Encoder )codeMPS (_beb *codingContext ,_gbd uint32 ,_cb uint16 ,_faa byte ){_geae ._ea -=_cb ;
if _geae ._ea &0x8000!=0{_geae ._fc +=uint32 (_cb );return ;};if _geae ._ea < _cb {_geae ._ea =_cb ;}else {_geae ._fc +=uint32 (_cb );};_beb ._c [_gbd ]=_agd [_faa ]._bcdb ;_geae .renormalize ();};