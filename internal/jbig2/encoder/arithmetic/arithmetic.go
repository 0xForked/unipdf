//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_a "bytes";_f "github.com/unidoc/unipdf/v3/common";_ff "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_g "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_cc "io";);func (_gef *Encoder )code0 (_gbb *codingContext ,_gcd uint32 ,_bgb uint16 ,_fdb byte ){if _gbb .mps (_gcd )==0{_gef .codeMPS (_gbb ,_gcd ,_bgb ,_fdb );
}else {_gef .codeLPS (_gbb ,_gcd ,_bgb ,_fdb );};};func (_daa *Encoder )codeMPS (_fbdf *codingContext ,_cfe uint32 ,_fef uint16 ,_gf byte ){_daa ._bf -=_fef ;if _daa ._bf &0x8000!=0{_daa ._ca +=uint32 (_fef );return ;};if _daa ._bf < _fef {_daa ._bf =_fef ;
}else {_daa ._ca +=uint32 (_fef );};_fbdf ._ag [_cfe ]=_ebb [_gf ]._dfde ;_daa .renormalize ();};func (_dda *Encoder )lBlock (){if _dda ._dc >=0{_dda .emit ();};_dda ._dc ++;_dda ._fb =uint8 (_dda ._ca >>19);_dda ._ca &=0x7ffff;_dda ._ga =8;};func (_cgeb *Encoder )EncodeBitmap (bm *_ff .Bitmap ,duplicateLineRemoval bool )error {_f .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );
var (_df ,_aeg uint8 ;_dfe ,_gca ,_gb uint16 ;_gcf ,_ecf ,_af byte ;_de ,_ea ,_gcb int ;_eaa ,_ba []byte ;);for _dec :=0;_dec < bm .Height ;_dec ++{_gcf ,_ecf =0,0;if _dec >=2{_gcf =bm .Data [(_dec -2)*bm .RowStride ];};if _dec >=1{_ecf =bm .Data [(_dec -1)*bm .RowStride ];
if duplicateLineRemoval {_ea =_dec *bm .RowStride ;_eaa =bm .Data [_ea :_ea +bm .RowStride ];_gcb =(_dec -1)*bm .RowStride ;_ba =bm .Data [_gcb :_gcb +bm .RowStride ];if _a .Equal (_eaa ,_ba ){_aeg =_df ^1;_df =1;}else {_aeg =_df ;_df =0;};};};if duplicateLineRemoval {if _aegg :=_cgeb .encodeBit (_cgeb ._ccd ,_fca ,_aeg );
_aegg !=nil {return _aegg ;};if _df !=0{continue ;};};_af =bm .Data [_dec *bm .RowStride ];_dfe =uint16 (_gcf >>5);_gca =uint16 (_ecf >>4);_gcf <<=3;_ecf <<=4;_gb =0;for _de =0;_de < bm .Width ;_de ++{_fad :=uint32 (_dfe <<11|_gca <<4|_gb );_fd :=(_af &0x80)>>7;
_bfg :=_cgeb .encodeBit (_cgeb ._ccd ,_fad ,_fd );if _bfg !=nil {return _bfg ;};_dfe <<=1;_gca <<=1;_gb <<=1;_dfe |=uint16 ((_gcf &0x80)>>7);_gca |=uint16 ((_ecf &0x80)>>7);_gb |=uint16 (_fd );_bc :=_de %8;_cfd :=_de /8+1;if _bc ==4&&_dec >=2{_gcf =0;if _cfd < bm .RowStride {_gcf =bm .Data [(_dec -2)*bm .RowStride +_cfd ];
};}else {_gcf <<=1;};if _bc ==3&&_dec >=1{_ecf =0;if _cfd < bm .RowStride {_ecf =bm .Data [(_dec -1)*bm .RowStride +_cfd ];};}else {_ecf <<=1;};if _bc ==7{_af =0;if _cfd < bm .RowStride {_af =bm .Data [_dec *bm .RowStride +_cfd ];};}else {_af <<=1;};_dfe &=31;
_gca &=127;_gb &=15;};};return nil ;};func (_eaf *Encoder )dataSize ()int {return _gd *len (_eaf ._da )+_eaf ._gce };func (_fcf *Encoder )encodeBit (_aac *codingContext ,_decd uint32 ,_dde uint8 )error {const _be ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";
_fcf ._gac ++;if _decd >=uint32 (len (_aac ._ag )){return _g .Errorf (_be ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_decd );
};_dfb :=_aac ._ag [_decd ];_cfg :=_aac .mps (_decd );_gbed :=_ebb [_dfb ]._egba ;_f .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_fcf ._gac ,_dde ,_dfb ,_cfg ,_gbed ,_fcf ._bf ,_fcf ._ca ,_fcf ._ga ,_fcf ._fb ,_fcf ._dc );
if _dde ==0{_fcf .code0 (_aac ,_decd ,_gbed ,_dfb );}else {_fcf .code1 (_aac ,_decd ,_gbed ,_dfb );};return nil ;};type Class int ;func (_egb *Encoder )emit (){if _egb ._gce ==_gd {_egb ._da =append (_egb ._da ,_egb ._bg );_egb ._bg =make ([]byte ,_gd );
_egb ._gce =0;};_egb ._bg [_egb ._gce ]=_egb ._fb ;_egb ._gce ++;};func _ce (_ef int )*codingContext {return &codingContext {_ag :make ([]byte ,_ef ),_cd :make ([]byte ,_ef )};};func (_gc *codingContext )flipMps (_fg uint32 ){_gc ._cd [_fg ]=1-_gc ._cd [_fg ]};
func (_cgea *Encoder )WriteTo (w _cc .Writer )(int64 ,error ){const _ab ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";var _aeba int64 ;for _eaaa ,_eb :=range _cgea ._da {_fgd ,_bfef :=w .Write (_eb );if _bfef !=nil {return 0,_g .Wrapf (_bfef ,_ab ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_eaaa );
};_aeba +=int64 (_fgd );};_cgea ._bg =_cgea ._bg [:_cgea ._gce ];_ced ,_fbde :=w .Write (_cgea ._bg );if _fbde !=nil {return 0,_g .Wrap (_fbde ,_ab ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_aeba +=int64 (_ced );
return _aeba ,nil ;};func (_bga *Encoder )rBlock (){if _bga ._dc >=0{_bga .emit ();};_bga ._dc ++;_bga ._fb =uint8 (_bga ._ca >>20);_bga ._ca &=0xfffff;_bga ._ga =7;};func (_d Class )String ()string {switch _d {case IAAI :return "\u0049\u0041\u0041\u0049";
case IADH :return "\u0049\u0041\u0044\u0048";case IADS :return "\u0049\u0041\u0044\u0053";case IADT :return "\u0049\u0041\u0044\u0054";case IADW :return "\u0049\u0041\u0044\u0057";case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";
case IAIT :return "\u0049\u0041\u0049\u0054";case IARDH :return "\u0049\u0041\u0052D\u0048";case IARDW :return "\u0049\u0041\u0052D\u0057";case IARDX :return "\u0049\u0041\u0052D\u0058";case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";
default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";};};const (IAAI Class =iota ;IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);func (_beg *Encoder )setBits (){_ad :=_beg ._ca +uint32 (_beg ._bf );_beg ._ca |=0xffff;if _beg ._ca >=_ad {_beg ._ca -=0x8000;
};};var _ebb =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
func (_aed *Encoder )byteOut (){if _aed ._fb ==0xff{_aed .rBlock ();return ;};if _aed ._ca < 0x8000000{_aed .lBlock ();return ;};_aed ._fb ++;if _aed ._fb !=0xff{_aed .lBlock ();return ;};_aed ._ca &=0x7ffffff;_aed .rBlock ();};func (_ed *Encoder )Init (){_ed ._ccd =_ce (_bbd );
_ed ._bf =0x8000;_ed ._ca =0;_ed ._ga =12;_ed ._dc =-1;_ed ._fb =0;_ed ._gce =0;_ed ._bg =make ([]byte ,_gd );for _cge :=0;_cge < len (_ed ._ae );_cge ++{_ed ._ae [_cge ]=_ce (512);};_ed ._fc =nil ;};func New ()*Encoder {_aeb :=&Encoder {};_aeb .Init ();
return _aeb };func (_edc *Encoder )EncodeIAID (symbolCodeLength ,value int )(_gba error ){_f .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );
if _gba =_edc .encodeIAID (symbolCodeLength ,value );_gba !=nil {return _g .Wrap (_gba ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};func (_fbd *Encoder )EncodeOOB (proc Class )(_bfe error ){_f .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );
if _bfe =_fbd .encodeOOB (proc );_bfe !=nil {return _g .Wrap (_bfe ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};func (_bbe *Encoder )Refine (iTemp ,iTarget *_ff .Bitmap ,ox ,oy int )error {for _ecb :=0;_ecb < iTarget .Height ;_ecb ++{var _efa int ;
_dbe :=_ecb +oy ;var (_egf ,_ecbg ,_gg ,_fe ,_ecg uint16 ;_cec ,_fed ,_bff ,_bd ,_fcb byte ;);if _dbe >=1&&(_dbe -1)< iTemp .Height {_cec =iTemp .Data [(_dbe -1)*iTemp .RowStride ];};if _dbe >=0&&_dbe < iTemp .Height {_fed =iTemp .Data [_dbe *iTemp .RowStride ];
};if _dbe >=-1&&_dbe +1< iTemp .Height {_bff =iTemp .Data [(_dbe +1)*iTemp .RowStride ];};if _ecb >=1{_bd =iTarget .Data [(_ecb -1)*iTarget .RowStride ];};_fcb =iTarget .Data [_ecb *iTarget .RowStride ];_dfd :=uint (6+ox );_egf =uint16 (_cec >>_dfd );_ecbg =uint16 (_fed >>_dfd );
_gg =uint16 (_bff >>_dfd );_fe =uint16 (_bd >>6);_gee :=uint (2-ox );_cec <<=_gee ;_fed <<=_gee ;_bff <<=_gee ;_bd <<=2;for _efa =0;_efa < iTarget .Width ;_efa ++{_dca :=(_egf <<10)|(_ecbg <<7)|(_gg <<4)|(_fe <<1)|_ecg ;_cac :=_fcb >>7;_dg :=_bbe .encodeBit (_bbe ._ccd ,uint32 (_dca ),_cac );
if _dg !=nil {return _dg ;};_egf <<=1;_ecbg <<=1;_gg <<=1;_fe <<=1;_egf |=uint16 (_cec >>7);_ecbg |=uint16 (_fed >>7);_gg |=uint16 (_bff >>7);_fe |=uint16 (_bd >>7);_ecg =uint16 (_cac );_cdc :=_efa %8;_dd :=_efa /8+1;if _cdc ==5+ox {_cec ,_fed ,_bff =0,0,0;
if _dd < iTemp .RowStride &&_dbe >=1&&(_dbe -1)< iTemp .Height {_cec =iTemp .Data [(_dbe -1)*iTemp .RowStride +_dd ];};if _dd < iTemp .RowStride &&_dbe >=0&&_dbe < iTemp .Height {_fed =iTemp .Data [_dbe *iTemp .RowStride +_dd ];};if _dd < iTemp .RowStride &&_dbe >=-1&&(_dbe +1)< iTemp .Height {_bff =iTemp .Data [(_dbe +1)*iTemp .RowStride +_dd ];
};}else {_cec <<=1;_fed <<=1;_bff <<=1;};if _cdc ==5&&_ecb >=1{_bd =0;if _dd < iTarget .RowStride {_bd =iTarget .Data [(_ecb -1)*iTarget .RowStride +_dd ];};}else {_bd <<=1;};if _cdc ==7{_fcb =0;if _dd < iTarget .RowStride {_fcb =iTarget .Data [_ecb *iTarget .RowStride +_dd ];
};}else {_fcb <<=1;};_egf &=7;_ecbg &=7;_gg &=7;_fe &=7;};};return nil ;};type codingContext struct{_ag []byte ;_cd []byte ;};type Encoder struct{_ca uint32 ;_bf uint16 ;_ga ,_fb uint8 ;_dc int ;_gac int ;_da [][]byte ;_bg []byte ;_gce int ;_ccd *codingContext ;
_ae [13]*codingContext ;_fc *codingContext ;};func (_ged *Encoder )encodeIAID (_ece ,_aae int )error {if _ged ._fc ==nil {_ged ._fc =_ce (1<<uint (_ece ));};_gge :=uint32 (1<<uint32 (_ece +1))-1;_aae <<=uint (32-_ece );_bag :=uint32 (1);for _cff :=0;_cff < _ece ;
_cff ++{_ffa :=_bag &_gge ;_geg :=uint8 ((uint32 (_aae )&0x80000000)>>31);if _cfdf :=_ged .encodeBit (_ged ._fc ,_ffa ,_geg );_cfdf !=nil {return _cfdf ;};_bag =(_bag <<1)|uint32 (_geg );_aae <<=1;};return nil ;};func (_ecea *Encoder )encodeOOB (_abf Class )error {_ead :=_ecea ._ae [_abf ];
_fec :=_ecea .encodeBit (_ead ,1,1);if _fec !=nil {return _fec ;};_fec =_ecea .encodeBit (_ead ,3,0);if _fec !=nil {return _fec ;};_fec =_ecea .encodeBit (_ead ,6,0);if _fec !=nil {return _fec ;};_fec =_ecea .encodeBit (_ead ,12,0);if _fec !=nil {return _fec ;
};return nil ;};func (_dgb *Encoder )encodeInteger (_eca Class ,_cfee int )error {const _bac ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";if _cfee > 2000000000||_cfee < -2000000000{return _g .Errorf (_bac ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_cfee );
};_bca :=_dgb ._ae [_eca ];_dfg :=uint32 (1);var _dac int ;for ;;_dac ++{if _bb [_dac ]._ge <=_cfee &&_bb [_dac ]._cb >=_cfee {break ;};};if _cfee < 0{_cfee =-_cfee ;};_cfee -=int (_bb [_dac ]._e );_bdc :=_bb [_dac ]._cg ;for _daca :=uint8 (0);_daca < _bb [_dac ]._cf ;
_daca ++{_cdd :=_bdc &1;if _feg :=_dgb .encodeBit (_bca ,_dfg ,_cdd );_feg !=nil {return _g .Wrap (_feg ,_bac ,"");};_bdc >>=1;if _dfg &0x100> 0{_dfg =(((_dfg <<1)|uint32 (_cdd ))&0x1ff)|0x100;}else {_dfg =(_dfg <<1)|uint32 (_cdd );};};_cfee <<=32-_bb [_dac ]._b ;
for _faba :=uint8 (0);_faba < _bb [_dac ]._b ;_faba ++{_edf :=uint8 ((uint32 (_cfee )&0x80000000)>>31);if _abe :=_dgb .encodeBit (_bca ,_dfg ,_edf );_abe !=nil {return _g .Wrap (_abe ,_bac ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");
};_cfee <<=1;if _dfg &0x100!=0{_dfg =(((_dfg <<1)|uint32 (_edf ))&0x1ff)|0x100;}else {_dfg =(_dfg <<1)|uint32 (_edf );};};return nil ;};const _fca =0x9b25;func (_dbf *Encoder )Reset (){_dbf ._bf =0x8000;_dbf ._ca =0;_dbf ._ga =12;_dbf ._dc =-1;_dbf ._fb =0;
_dbf ._fc =nil ;_dbf ._ccd =_ce (_bbd );};func (_caa *Encoder )renormalize (){for {_caa ._bf <<=1;_caa ._ca <<=1;_caa ._ga --;if _caa ._ga ==0{_caa .byteOut ();};if (_caa ._bf &0x8000)!=0{break ;};};};type intEncRangeS struct{_ge ,_cb int ;_cg ,_cf uint8 ;
_e uint16 ;_b uint8 ;};func (_ccb *Encoder )flush (){_ccb .setBits ();_ccb ._ca <<=_ccb ._ga ;_ccb .byteOut ();_ccb ._ca <<=_ccb ._ga ;_ccb .byteOut ();_ccb .emit ();if _ccb ._fb !=0xff{_ccb ._dc ++;_ccb ._fb =0xff;_ccb .emit ();};_ccb ._dc ++;_ccb ._fb =0xac;
_ccb ._dc ++;_ccb .emit ();};var _ _cc .WriterTo =&Encoder {};var _bb =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};
func (_bfd *Encoder )code1 (_gbe *codingContext ,_fab uint32 ,_cecc uint16 ,_ggb byte ){if _gbe .mps (_fab )==1{_bfd .codeMPS (_gbe ,_fab ,_cecc ,_ggb );}else {_bfd .codeLPS (_gbe ,_fab ,_cecc ,_ggb );};};const (_bbd =65536;_gd =20*1024;);func (_ee *Encoder )Flush (){_ee ._gce =0;
_ee ._da =nil ;_ee ._dc =-1};func (_fa *Encoder )DataSize ()int {return _fa .dataSize ()};func (_eg *codingContext )mps (_ec uint32 )int {return int (_eg ._cd [_ec ])};func (_db *Encoder )Final (){_db .flush ()};type state struct{_egba uint16 ;_dfde ,_gaa uint8 ;
_cgg uint8 ;};func (_cba *Encoder )EncodeInteger (proc Class ,value int )(_aa error ){_f .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );
if _aa =_cba .encodeInteger (proc ,value );_aa !=nil {return _g .Wrap (_aa ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};func (_dfa *Encoder )codeLPS (_cad *codingContext ,_egfg uint32 ,_fabd uint16 ,_gcfg byte ){_dfa ._bf -=_fabd ;
if _dfa ._bf < _fabd {_dfa ._ca +=uint32 (_fabd );}else {_dfa ._bf =_fabd ;};if _ebb [_gcfg ]._cgg ==1{_cad .flipMps (_egfg );};_cad ._ag [_egfg ]=_ebb [_gcfg ]._gaa ;_dfa .renormalize ();};