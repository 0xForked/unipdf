//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_c "bytes";_a "github.com/unidoc/unipdf/v3/common";_fg "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_g "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_e "io";);type state struct{_gbd uint16 ;_cdg ,_ace uint8 ;_agga uint8 ;
};func (_bef *Encoder )rBlock (){if _bef ._ag >=0{_bef .emit ();};_bef ._ag ++;_bef ._gb =uint8 (_bef ._b >>20);_bef ._b &=0xfffff;_bef ._ba =7;};var _cf =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};
func (_gcg *Encoder )flush (){_gcg .setBits ();_gcg ._b <<=_gcg ._ba ;_gcg .byteOut ();_gcg ._b <<=_gcg ._ba ;_gcg .byteOut ();_gcg .emit ();if _gcg ._gb !=0xff{_gcg ._ag ++;_gcg ._gb =0xff;_gcg .emit ();};_gcg ._ag ++;_gcg ._gb =0xac;_gcg ._ag ++;_gcg .emit ();
};func (_bfdb *Encoder )EncodeBitmap (bm *_fg .Bitmap ,duplicateLineRemoval bool )error {_a .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );
var (_agf ,_edc uint8 ;_gc ,_df ,_fbb uint16 ;_ee ,_fde ,_gee byte ;_bd ,_ad ,_de int ;_gfb ,_gcf []byte ;);for _cda :=0;_cda < bm .Height ;_cda ++{_ee ,_fde =0,0;if _cda >=2{_ee =bm .Data [(_cda -2)*bm .RowStride ];};if _cda >=1{_fde =bm .Data [(_cda -1)*bm .RowStride ];
if duplicateLineRemoval {_ad =_cda *bm .RowStride ;_gfb =bm .Data [_ad :_ad +bm .RowStride ];_de =(_cda -1)*bm .RowStride ;_gcf =bm .Data [_de :_de +bm .RowStride ];if _c .Equal (_gfb ,_gcf ){_edc =_agf ^1;_agf =1;}else {_edc =_agf ;_agf =0;};};};if duplicateLineRemoval {if _ede :=_bfdb .encodeBit (_bfdb ._ge ,_fc ,_edc );
_ede !=nil {return _ede ;};if _agf !=0{continue ;};};_gee =bm .Data [_cda *bm .RowStride ];_gc =uint16 (_ee >>5);_df =uint16 (_fde >>4);_ee <<=3;_fde <<=4;_fbb =0;for _bd =0;_bd < bm .Width ;_bd ++{_dfa :=uint32 (_gc <<11|_df <<4|_fbb );_agda :=(_gee &0x80)>>7;
_feg :=_bfdb .encodeBit (_bfdb ._ge ,_dfa ,_agda );if _feg !=nil {return _feg ;};_gc <<=1;_df <<=1;_fbb <<=1;_gc |=uint16 ((_ee &0x80)>>7);_df |=uint16 ((_fde &0x80)>>7);_fbb |=uint16 (_agda );_eea :=_bd %8;_fa :=_bd /8+1;if _eea ==4&&_cda >=2{_ee =0;if _fa < bm .RowStride {_ee =bm .Data [(_cda -2)*bm .RowStride +_fa ];
};}else {_ee <<=1;};if _eea ==3&&_cda >=1{_fde =0;if _fa < bm .RowStride {_fde =bm .Data [(_cda -1)*bm .RowStride +_fa ];};}else {_fde <<=1;};if _eea ==7{_gee =0;if _fa < bm .RowStride {_gee =bm .Data [_cda *bm .RowStride +_fa ];};}else {_gee <<=1;};_gc &=31;
_df &=127;_fbb &=15;};};return nil ;};func New ()*Encoder {_bfd :=&Encoder {};_bfd .Init ();return _bfd };func _ea (_cg int )*codingContext {return &codingContext {_dab :make ([]byte ,_cg ),_gd :make ([]byte ,_cg )};};func (_egg *Encoder )setBits (){_eebf :=_egg ._b +uint32 (_egg ._cd );
_egg ._b |=0xffff;if _egg ._b >=_eebf {_egg ._b -=0x8000;};};const (_bed =65536;_dfda =20*1024;);func (_daa *Encoder )code0 (_eed *codingContext ,_bfde uint32 ,_acf uint16 ,_feggf byte ){if _eed .mps (_bfde )==0{_daa .codeMPS (_eed ,_bfde ,_acf ,_feggf );
}else {_daa .codeLPS (_eed ,_bfde ,_acf ,_feggf );};};func (_fce *Encoder )codeLPS (_bag *codingContext ,_eab uint32 ,_gfbb uint16 ,_daae byte ){_fce ._cd -=_gfbb ;if _fce ._cd < _gfbb {_fce ._b +=uint32 (_gfbb );}else {_fce ._cd =_gfbb ;};if _dgcb [_daae ]._agga ==1{_bag .flipMps (_eab );
};_bag ._dab [_eab ]=_dgcb [_daae ]._ace ;_fce .renormalize ();};func (_ga *Encoder )EncodeOOB (proc Class )(_afb error ){_a .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );
if _afb =_ga .encodeOOB (proc );_afb !=nil {return _g .Wrap (_afb ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};func (_bdc *Encoder )WriteTo (w _e .Writer )(int64 ,error ){const _edgg ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";
var _bff int64 ;for _ddd ,_ff :=range _bdc ._gf {_beg ,_cgc :=w .Write (_ff );if _cgc !=nil {return 0,_g .Wrapf (_cgc ,_edgg ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_ddd );
};_bff +=int64 (_beg );};_bdc ._caad =_bdc ._caad [:_bdc ._fd ];_afc ,_bc :=w .Write (_bdc ._caad );if _bc !=nil {return 0,_g .Wrap (_bc ,_edgg ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_bff +=int64 (_afc );
return _bff ,nil ;};func (_db *Encoder )emit (){if _db ._fd ==_dfda {_db ._gf =append (_db ._gf ,_db ._caad );_db ._caad =make ([]byte ,_dfda );_db ._fd =0;};_db ._caad [_db ._fd ]=_db ._gb ;_db ._fd ++;};type Class int ;func (_aff *Encoder )EncodeInteger (proc Class ,value int )(_cfg error ){_a .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );
if _cfg =_aff .encodeInteger (proc ,value );_cfg !=nil {return _g .Wrap (_cfg ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};func (_d Class )String ()string {switch _d {case IAAI :return "\u0049\u0041\u0041\u0049";
case IADH :return "\u0049\u0041\u0044\u0048";case IADS :return "\u0049\u0041\u0044\u0053";case IADT :return "\u0049\u0041\u0044\u0054";case IADW :return "\u0049\u0041\u0044\u0057";case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";
case IAIT :return "\u0049\u0041\u0049\u0054";case IARDH :return "\u0049\u0041\u0052D\u0048";case IARDW :return "\u0049\u0041\u0052D\u0057";case IARDX :return "\u0049\u0041\u0052D\u0058";case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";
default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";};};func (_caa *codingContext )flipMps (_fed uint32 ){_caa ._gd [_fed ]=1-_caa ._gd [_fed ]};type codingContext struct{_dab []byte ;_gd []byte ;};var _ _e .WriterTo =&Encoder {};func (_ceb *Encoder )encodeInteger (_eeb Class ,_cba int )error {const _gea ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";
if _cba > 2000000000||_cba < -2000000000{return _g .Errorf (_gea ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_cba );
};_acfa :=_ceb ._edg [_eeb ];_gbf :=uint32 (1);var _dfd int ;for ;;_dfd ++{if _cf [_dfd ]._da <=_cba &&_cf [_dfd ]._dc >=_cba {break ;};};if _cba < 0{_cba =-_cba ;};_cba -=int (_cf [_dfd ]._ed );_dcg :=_cf [_dfd ]._ca ;for _ec :=uint8 (0);_ec < _cf [_dfd ]._fe ;
_ec ++{_gec :=_dcg &1;if _bcd :=_ceb .encodeBit (_acfa ,_gbf ,_gec );_bcd !=nil {return _g .Wrap (_bcd ,_gea ,"");};_dcg >>=1;if _gbf &0x100> 0{_gbf =(((_gbf <<1)|uint32 (_gec ))&0x1ff)|0x100;}else {_gbf =(_gbf <<1)|uint32 (_gec );};};_cba <<=32-_cf [_dfd ]._fb ;
for _cge :=uint8 (0);_cge < _cf [_dfd ]._fb ;_cge ++{_edec :=uint8 ((uint32 (_cba )&0x80000000)>>31);if _ebe :=_ceb .encodeBit (_acfa ,_gbf ,_edec );_ebe !=nil {return _g .Wrap (_ebe ,_gea ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");
};_cba <<=1;if _gbf &0x100!=0{_gbf =(((_gbf <<1)|uint32 (_edec ))&0x1ff)|0x100;}else {_gbf =(_gbf <<1)|uint32 (_edec );};};return nil ;};func (_bdea *Encoder )encodeIAID (_bdcd ,_cgec int )error {if _bdea ._bf ==nil {_bdea ._bf =_ea (1<<uint (_bdcd ));
};_ffg :=uint32 (1<<uint32 (_bdcd +1))-1;_cgec <<=uint (32-_bdcd );_bec :=uint32 (1);for _agg :=0;_agg < _bdcd ;_agg ++{_cgd :=_bec &_ffg ;_fac :=uint8 ((uint32 (_cgec )&0x80000000)>>31);if _bcc :=_bdea .encodeBit (_bdea ._bf ,_cgd ,_fac );_bcc !=nil {return _bcc ;
};_bec =(_bec <<1)|uint32 (_fac );_cgec <<=1;};return nil ;};func (_fba *Encoder )DataSize ()int {return _fba .dataSize ()};const (IAAI Class =iota ;IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);func (_dfe *Encoder )Flush (){_dfe ._fd =0;
_dfe ._gf =nil ;_dfe ._ag =-1};func (_egb *Encoder )lBlock (){if _egb ._ag >=0{_egb .emit ();};_egb ._ag ++;_egb ._gb =uint8 (_egb ._b >>19);_egb ._b &=0x7ffff;_egb ._ba =8;};func (_dea *Encoder )dataSize ()int {return _dfda *len (_dea ._gf )+_dea ._fd };
type Encoder struct{_b uint32 ;_cd uint16 ;_ba ,_gb uint8 ;_ag int ;_dg int ;_gf [][]byte ;_caad []byte ;_fd int ;_ge *codingContext ;_edg [13]*codingContext ;_bf *codingContext ;};func (_bde *Encoder )codeMPS (_dge *codingContext ,_dgb uint32 ,_baa uint16 ,_fge byte ){_bde ._cd -=_baa ;
if _bde ._cd &0x8000!=0{_bde ._b +=uint32 (_baa );return ;};if _bde ._cd < _baa {_bde ._cd =_baa ;}else {_bde ._b +=uint32 (_baa );};_dge ._dab [_dgb ]=_dgcb [_fge ]._cdg ;_bde .renormalize ();};func (_eeda *Encoder )encodeBit (_eb *codingContext ,_ebg uint32 ,_fdd uint8 )error {const _bfc ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";
_eeda ._dg ++;if _ebg >=uint32 (len (_eb ._dab )){return _g .Errorf (_bfc ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_ebg );
};_fff :=_eb ._dab [_ebg ];_daaf :=_eb .mps (_ebg );_cfgf :=_dgcb [_fff ]._gbd ;_a .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_eeda ._dg ,_fdd ,_fff ,_daaf ,_cfgf ,_eeda ._cd ,_eeda ._b ,_eeda ._ba ,_eeda ._gb ,_eeda ._ag );
if _fdd ==0{_eeda .code0 (_eb ,_ebg ,_cfgf ,_fff );}else {_eeda .code1 (_eb ,_ebg ,_cfgf ,_fff );};return nil ;};const _fc =0x9b25;func (_bb *Encoder )encodeOOB (_eda Class )error {_aaa :=_bb ._edg [_eda ];_fedg :=_bb .encodeBit (_aaa ,1,1);if _fedg !=nil {return _fedg ;
};_fedg =_bb .encodeBit (_aaa ,3,0);if _fedg !=nil {return _fedg ;};_fedg =_bb .encodeBit (_aaa ,6,0);if _fedg !=nil {return _fedg ;};_fedg =_bb .encodeBit (_aaa ,12,0);if _fedg !=nil {return _fedg ;};return nil ;};func (_fdg *Encoder )Reset (){_fdg ._cd =0x8000;
_fdg ._b =0;_fdg ._ba =12;_fdg ._ag =-1;_fdg ._gb =0;_fdg ._bf =nil ;_fdg ._ge =_ea (_bed );};func (_fegg *Encoder )Final (){_fegg .flush ()};type intEncRangeS struct{_da ,_dc int ;_ca ,_fe uint8 ;_ed uint16 ;_fb uint8 ;};func (_ddg *Encoder )code1 (_febd *codingContext ,_cae uint32 ,_fdeg uint16 ,_fdc byte ){if _febd .mps (_cae )==1{_ddg .codeMPS (_febd ,_cae ,_fdeg ,_fdc );
}else {_ddg .codeLPS (_febd ,_cae ,_fdeg ,_fdc );};};func (_gg *Encoder )Refine (iTemp ,iTarget *_fg .Bitmap ,ox ,oy int )error {for _dd :=0;_dd < iTarget .Height ;_dd ++{var _ac int ;_fbab :=_dd +oy ;var (_bdf ,_fad ,_ada ,_be ,_dgc uint16 ;_bae ,_feb ,_gdg ,_fab ,_dfea byte ;
);if _fbab >=1&&(_fbab -1)< iTemp .Height {_bae =iTemp .Data [(_fbab -1)*iTemp .RowStride ];};if _fbab >=0&&_fbab < iTemp .Height {_feb =iTemp .Data [_fbab *iTemp .RowStride ];};if _fbab >=-1&&_fbab +1< iTemp .Height {_gdg =iTemp .Data [(_fbab +1)*iTemp .RowStride ];
};if _dd >=1{_fab =iTarget .Data [(_dd -1)*iTarget .RowStride ];};_dfea =iTarget .Data [_dd *iTarget .RowStride ];_aa :=uint (6+ox );_bdf =uint16 (_bae >>_aa );_fad =uint16 (_feb >>_aa );_ada =uint16 (_gdg >>_aa );_be =uint16 (_fab >>6);_gac :=uint (2-ox );
_bae <<=_gac ;_feb <<=_gac ;_gdg <<=_gac ;_fab <<=2;for _ac =0;_ac < iTarget .Width ;_ac ++{_ce :=(_bdf <<10)|(_fad <<7)|(_ada <<4)|(_be <<1)|_dgc ;_geee :=_dfea >>7;_add :=_gg .encodeBit (_gg ._ge ,uint32 (_ce ),_geee );if _add !=nil {return _add ;};_bdf <<=1;
_fad <<=1;_ada <<=1;_be <<=1;_bdf |=uint16 (_bae >>7);_fad |=uint16 (_feb >>7);_ada |=uint16 (_gdg >>7);_be |=uint16 (_fab >>7);_dgc =uint16 (_geee );_gda :=_ac %8;_fcd :=_ac /8+1;if _gda ==5+ox {_bae ,_feb ,_gdg =0,0,0;if _fcd < iTemp .RowStride &&_fbab >=1&&(_fbab -1)< iTemp .Height {_bae =iTemp .Data [(_fbab -1)*iTemp .RowStride +_fcd ];
};if _fcd < iTemp .RowStride &&_fbab >=0&&_fbab < iTemp .Height {_feb =iTemp .Data [_fbab *iTemp .RowStride +_fcd ];};if _fcd < iTemp .RowStride &&_fbab >=-1&&(_fbab +1)< iTemp .Height {_gdg =iTemp .Data [(_fbab +1)*iTemp .RowStride +_fcd ];};}else {_bae <<=1;
_feb <<=1;_gdg <<=1;};if _gda ==5&&_dd >=1{_fab =0;if _fcd < iTarget .RowStride {_fab =iTarget .Data [(_dd -1)*iTarget .RowStride +_fcd ];};}else {_fab <<=1;};if _gda ==7{_dfea =0;if _fcd < iTarget .RowStride {_dfea =iTarget .Data [_dd *iTarget .RowStride +_fcd ];
};}else {_dfea <<=1;};_bdf &=7;_fad &=7;_ada &=7;_be &=7;};};return nil ;};func (_eaa *Encoder )renormalize (){for {_eaa ._cd <<=1;_eaa ._b <<=1;_eaa ._ba --;if _eaa ._ba ==0{_eaa .byteOut ();};if (_eaa ._cd &0x8000)!=0{break ;};};};func (_febg *Encoder )byteOut (){if _febg ._gb ==0xff{_febg .rBlock ();
return ;};if _febg ._b < 0x8000000{_febg .lBlock ();return ;};_febg ._gb ++;if _febg ._gb !=0xff{_febg .lBlock ();return ;};_febg ._b &=0x7ffffff;_febg .rBlock ();};var _dgcb =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
func (_ae *codingContext )mps (_cb uint32 )int {return int (_ae ._gd [_cb ])};func (_eg *Encoder )EncodeIAID (symbolCodeLength ,value int )(_af error ){_a .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );
if _af =_eg .encodeIAID (symbolCodeLength ,value );_af !=nil {return _g .Wrap (_af ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};func (_geg *Encoder )Init (){_geg ._ge =_ea (_bed );_geg ._cd =0x8000;_geg ._b =0;_geg ._ba =12;
_geg ._ag =-1;_geg ._gb =0;_geg ._fd =0;_geg ._caad =make ([]byte ,_dfda );for _agd :=0;_agd < len (_geg ._edg );_agd ++{_geg ._edg [_agd ]=_ea (512);};_geg ._bf =nil ;};