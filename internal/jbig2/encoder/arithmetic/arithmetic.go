//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_c "bytes";_b "github.com/unidoc/unipdf/v3/common";_cf "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_ba "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_af "io";);func (_ae *codingContext )mps (_cg uint32 )int {return int (_ae ._ea [_cg ])};
func (_bg Class )String ()string {switch _bg {case IAAI :return "\u0049\u0041\u0041\u0049";case IADH :return "\u0049\u0041\u0044\u0048";case IADS :return "\u0049\u0041\u0044\u0053";case IADT :return "\u0049\u0041\u0044\u0054";case IADW :return "\u0049\u0041\u0044\u0057";
case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";case IAIT :return "\u0049\u0041\u0049\u0054";case IARDH :return "\u0049\u0041\u0052D\u0048";case IARDW :return "\u0049\u0041\u0052D\u0057";case IARDX :return "\u0049\u0041\u0052D\u0058";
case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";};};func (_dff *Encoder )Flush (){_dff ._feg =0;_dff ._gc =nil ;_dff ._ge =-1};func (_cac *Encoder )encodeIAID (_adg ,_bbc int )error {if _cac ._fc ==nil {_cac ._fc =_cc (1<<uint (_adg ));
};_afd :=uint32 (1<<uint32 (_adg +1))-1;_bbc <<=uint (32-_adg );_cd :=uint32 (1);for _bfcf :=0;_bfcf < _adg ;_bfcf ++{_fga :=_cd &_afd ;_afb :=uint8 ((uint32 (_bbc )&0x80000000)>>31);if _ebb :=_cac .encodeBit (_cac ._fc ,_fga ,_afb );_ebb !=nil {return _ebb ;
};_cd =(_cd <<1)|uint32 (_afb );_bbc <<=1;};return nil ;};type state struct{_bgd uint16 ;_egg ,_cff uint8 ;_deg uint8 ;};func (_df *Encoder )EncodeBitmap (bm *_cf .Bitmap ,duplicateLineRemoval bool )error {_b .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );
var (_feea ,_dg uint8 ;_cba ,_dcg ,_fega uint16 ;_bb ,_eg ,_cbag byte ;_ca ,_gcd ,_fb int ;_bc ,_aa []byte ;);for _bfe :=0;_bfe < bm .Height ;_bfe ++{_bb ,_eg =0,0;if _bfe >=2{_bb =bm .Data [(_bfe -2)*bm .RowStride ];};if _bfe >=1{_eg =bm .Data [(_bfe -1)*bm .RowStride ];
if duplicateLineRemoval {_gcd =_bfe *bm .RowStride ;_bc =bm .Data [_gcd :_gcd +bm .RowStride ];_fb =(_bfe -1)*bm .RowStride ;_aa =bm .Data [_fb :_fb +bm .RowStride ];if _c .Equal (_bc ,_aa ){_dg =_feea ^1;_feea =1;}else {_dg =_feea ;_feea =0;};};};if duplicateLineRemoval {if _eb :=_df .encodeBit (_df ._bf ,_gga ,_dg );
_eb !=nil {return _eb ;};if _feea !=0{continue ;};};_cbag =bm .Data [_bfe *bm .RowStride ];_cba =uint16 (_bb >>5);_dcg =uint16 (_eg >>4);_bb <<=3;_eg <<=4;_fega =0;for _ca =0;_ca < bm .Width ;_ca ++{_ffa :=uint32 (_cba <<11|_dcg <<4|_fega );_gf :=(_cbag &0x80)>>7;
_egc :=_df .encodeBit (_df ._bf ,_ffa ,_gf );if _egc !=nil {return _egc ;};_cba <<=1;_dcg <<=1;_fega <<=1;_cba |=uint16 ((_bb &0x80)>>7);_dcg |=uint16 ((_eg &0x80)>>7);_fega |=uint16 (_gf );_ega :=_ca %8;_abg :=_ca /8+1;if _ega ==4&&_bfe >=2{_bb =0;if _abg < bm .RowStride {_bb =bm .Data [(_bfe -2)*bm .RowStride +_abg ];
};}else {_bb <<=1;};if _ega ==3&&_bfe >=1{_eg =0;if _abg < bm .RowStride {_eg =bm .Data [(_bfe -1)*bm .RowStride +_abg ];};}else {_eg <<=1;};if _ega ==7{_cbag =0;if _abg < bm .RowStride {_cbag =bm .Data [_bfe *bm .RowStride +_abg ];};}else {_cbag <<=1;
};_cba &=31;_dcg &=127;_fega &=15;};};return nil ;};var _ _af .WriterTo =&Encoder {};func (_bgb *Encoder )code0 (_ebf *codingContext ,_eba uint32 ,_afg uint16 ,_ege byte ){if _ebf .mps (_eba )==0{_bgb .codeMPS (_ebf ,_eba ,_afg ,_ege );}else {_bgb .codeLPS (_ebf ,_eba ,_afg ,_ege );
};};type codingContext struct{_cb []byte ;_ea []byte ;};func (_ga *Encoder )Refine (iTemp ,iTarget *_cf .Bitmap ,ox ,oy int )error {for _cfa :=0;_cfa < iTarget .Height ;_cfa ++{var _bfc int ;_aea :=_cfa +oy ;var (_cbd ,_eeg ,_bcb ,_db ,_fd uint16 ;_ce ,_bd ,_ggf ,_gd ,_ef byte ;
);if _aea >=1&&(_aea -1)< iTemp .Height {_ce =iTemp .Data [(_aea -1)*iTemp .RowStride ];};if _aea >=0&&_aea < iTemp .Height {_bd =iTemp .Data [_aea *iTemp .RowStride ];};if _aea >=-1&&_aea +1< iTemp .Height {_ggf =iTemp .Data [(_aea +1)*iTemp .RowStride ];
};if _cfa >=1{_gd =iTarget .Data [(_cfa -1)*iTarget .RowStride ];};_ef =iTarget .Data [_cfa *iTarget .RowStride ];_ec :=uint (6+ox );_cbd =uint16 (_ce >>_ec );_eeg =uint16 (_bd >>_ec );_bcb =uint16 (_ggf >>_ec );_db =uint16 (_gd >>6);_fbg :=uint (2-ox );
_ce <<=_fbg ;_bd <<=_fbg ;_ggf <<=_fbg ;_gd <<=2;for _bfc =0;_bfc < iTarget .Width ;_bfc ++{_fac :=(_cbd <<10)|(_eeg <<7)|(_bcb <<4)|(_db <<1)|_fd ;_ffb :=_ef >>7;_cec :=_ga .encodeBit (_ga ._bf ,uint32 (_fac ),_ffb );if _cec !=nil {return _cec ;};_cbd <<=1;
_eeg <<=1;_bcb <<=1;_db <<=1;_cbd |=uint16 (_ce >>7);_eeg |=uint16 (_bd >>7);_bcb |=uint16 (_ggf >>7);_db |=uint16 (_gd >>7);_fd =uint16 (_ffb );_ffbd :=_bfc %8;_fcd :=_bfc /8+1;if _ffbd ==5+ox {_ce ,_bd ,_ggf =0,0,0;if _fcd < iTemp .RowStride &&_aea >=1&&(_aea -1)< iTemp .Height {_ce =iTemp .Data [(_aea -1)*iTemp .RowStride +_fcd ];
};if _fcd < iTemp .RowStride &&_aea >=0&&_aea < iTemp .Height {_bd =iTemp .Data [_aea *iTemp .RowStride +_fcd ];};if _fcd < iTemp .RowStride &&_aea >=-1&&(_aea +1)< iTemp .Height {_ggf =iTemp .Data [(_aea +1)*iTemp .RowStride +_fcd ];};}else {_ce <<=1;
_bd <<=1;_ggf <<=1;};if _ffbd ==5&&_cfa >=1{_gd =0;if _fcd < iTarget .RowStride {_gd =iTarget .Data [(_cfa -1)*iTarget .RowStride +_fcd ];};}else {_gd <<=1;};if _ffbd ==7{_ef =0;if _fcd < iTarget .RowStride {_ef =iTarget .Data [_cfa *iTarget .RowStride +_fcd ];
};}else {_ef <<=1;};_cbd &=7;_eeg &=7;_bcb &=7;_db &=7;};};return nil ;};type Encoder struct{_ff uint32 ;_dc uint16 ;_ab ,_aba uint8 ;_ge int ;_fee int ;_gc [][]byte ;_be []byte ;_feg int ;_bf *codingContext ;_dd [13]*codingContext ;_fc *codingContext ;
};func (_fcg *Encoder )setBits (){_abd :=_fcg ._ff +uint32 (_fcg ._dc );_fcg ._ff |=0xffff;if _fcg ._ff >=_abd {_fcg ._ff -=0x8000;};};func (_fa *codingContext )flipMps (_d uint32 ){_fa ._ea [_d ]=1-_fa ._ea [_d ]};func (_fde *Encoder )codeLPS (_dfg *codingContext ,_fbe uint32 ,_ad uint16 ,_beg byte ){_fde ._dc -=_ad ;
if _fde ._dc < _ad {_fde ._ff +=uint32 (_ad );}else {_fde ._dc =_ad ;};if _fcgb [_beg ]._deg ==1{_dfg .flipMps (_fbe );};_dfg ._cb [_fbe ]=_fcgb [_beg ]._cff ;_fde .renormalize ();};func (_dag *Encoder )DataSize ()int {return _dag .dataSize ()};const (_fea =65536;
_cfb =20*1024;);func (_cfg *Encoder )EncodeInteger (proc Class ,value int )(_fg error ){_b .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );
if _fg =_cfg .encodeInteger (proc ,value );_fg !=nil {return _ba .Wrap (_fg ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};func (_gdc *Encoder )encodeBit (_eac *codingContext ,_gdf uint32 ,_cbdd uint8 )error {const _cea ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";
_gdc ._fee ++;if _gdf >=uint32 (len (_eac ._cb )){return _ba .Errorf (_cea ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_gdf );
};_ceb :=_eac ._cb [_gdf ];_daa :=_eac .mps (_gdf );_ccb :=_fcgb [_ceb ]._bgd ;_b .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_gdc ._fee ,_cbdd ,_ceb ,_daa ,_ccb ,_gdc ._dc ,_gdc ._ff ,_gdc ._ab ,_gdc ._aba ,_gdc ._ge );
if _cbdd ==0{_gdc .code0 (_eac ,_gdf ,_ccb ,_ceb );}else {_gdc .code1 (_eac ,_gdf ,_ccb ,_ceb );};return nil ;};func (_faa *Encoder )EncodeOOB (proc Class )(_ccf error ){_b .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );
if _ccf =_faa .encodeOOB (proc );_ccf !=nil {return _ba .Wrap (_ccf ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};type intEncRangeS struct{_g ,_e int ;_f ,_gb uint8 ;_ee uint16 ;_afe uint8 ;};func (_egf *Encoder )WriteTo (w _af .Writer )(int64 ,error ){const _ccd ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";
var _bca int64 ;for _ged ,_aee :=range _egf ._gc {_dgb ,_eag :=w .Write (_aee );if _eag !=nil {return 0,_ba .Wrapf (_eag ,_ccd ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_ged );
};_bca +=int64 (_dgb );};_egf ._be =_egf ._be [:_egf ._feg ];_ead ,_dfd :=w .Write (_egf ._be );if _dfd !=nil {return 0,_ba .Wrap (_dfd ,_ccd ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_bca +=int64 (_ead );return _bca ,nil ;
};func (_bda *Encoder )renormalize (){for {_bda ._dc <<=1;_bda ._ff <<=1;_bda ._ab --;if _bda ._ab ==0{_bda .byteOut ();};if (_bda ._dc &0x8000)!=0{break ;};};};func (_gce *Encoder )encodeOOB (_fce Class )error {_fbeb :=_gce ._dd [_fce ];_fgf :=_gce .encodeBit (_fbeb ,1,1);
if _fgf !=nil {return _fgf ;};_fgf =_gce .encodeBit (_fbeb ,3,0);if _fgf !=nil {return _fgf ;};_fgf =_gce .encodeBit (_fbeb ,6,0);if _fgf !=nil {return _fgf ;};_fgf =_gce .encodeBit (_fbeb ,12,0);if _fgf !=nil {return _fgf ;};return nil ;};func (_dad *Encoder )Reset (){_dad ._dc =0x8000;
_dad ._ff =0;_dad ._ab =12;_dad ._ge =-1;_dad ._aba =0;_dad ._fc =nil ;_dad ._bf =_cc (_fea );};func (_dab *Encoder )byteOut (){if _dab ._aba ==0xff{_dab .rBlock ();return ;};if _dab ._ff < 0x8000000{_dab .lBlock ();return ;};_dab ._aba ++;if _dab ._aba !=0xff{_dab .lBlock ();
return ;};_dab ._ff &=0x7ffffff;_dab .rBlock ();};func (_ac *Encoder )codeMPS (_cbaf *codingContext ,_ebd uint32 ,_acf uint16 ,_egcg byte ){_ac ._dc -=_acf ;if _ac ._dc &0x8000!=0{_ac ._ff +=uint32 (_acf );return ;};if _ac ._dc < _acf {_ac ._dc =_acf ;
}else {_ac ._ff +=uint32 (_acf );};_cbaf ._cb [_ebd ]=_fcgb [_egcg ]._egg ;_ac .renormalize ();};const _gga =0x9b25;func New ()*Encoder {_da :=&Encoder {};_da .Init ();return _da };func _cc (_cbc int )*codingContext {return &codingContext {_cb :make ([]byte ,_cbc ),_ea :make ([]byte ,_cbc )};
};var _fcgb =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
func (_dabc *Encoder )encodeInteger (_cbf Class ,_dde int )error {const _bed ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";if _dde > 2000000000||_dde < -2000000000{return _ba .Errorf (_bed ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_dde );
};_aeea :=_dabc ._dd [_cbf ];_cfgb :=uint32 (1);var _bdf int ;for ;;_bdf ++{if _fe [_bdf ]._g <=_dde &&_fe [_bdf ]._e >=_dde {break ;};};if _dde < 0{_dde =-_dde ;};_dde -=int (_fe [_bdf ]._ee );_fca :=_fe [_bdf ]._f ;for _eea :=uint8 (0);_eea < _fe [_bdf ]._gb ;
_eea ++{_gea :=_fca &1;if _gaa :=_dabc .encodeBit (_aeea ,_cfgb ,_gea );_gaa !=nil {return _ba .Wrap (_gaa ,_bed ,"");};_fca >>=1;if _cfgb &0x100> 0{_cfgb =(((_cfgb <<1)|uint32 (_gea ))&0x1ff)|0x100;}else {_cfgb =(_cfgb <<1)|uint32 (_gea );};};_dde <<=32-_fe [_bdf ]._afe ;
for _fbd :=uint8 (0);_fbd < _fe [_bdf ]._afe ;_fbd ++{_abgd :=uint8 ((uint32 (_dde )&0x80000000)>>31);if _gfd :=_dabc .encodeBit (_aeea ,_cfgb ,_abgd );_gfd !=nil {return _ba .Wrap (_gfd ,_bed ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");
};_dde <<=1;if _cfgb &0x100!=0{_cfgb =(((_cfgb <<1)|uint32 (_abgd ))&0x1ff)|0x100;}else {_cfgb =(_cfgb <<1)|uint32 (_abgd );};};return nil ;};func (_dfc *Encoder )Final (){_dfc .flush ()};func (_de *Encoder )dataSize ()int {return _cfb *len (_de ._gc )+_de ._feg };
func (_dge *Encoder )EncodeIAID (symbolCodeLength ,value int )(_fcc error ){_b .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );
if _fcc =_dge .encodeIAID (symbolCodeLength ,value );_fcc !=nil {return _ba .Wrap (_fcc ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};func (_aag *Encoder )emit (){if _aag ._feg ==_cfb {_aag ._gc =append (_aag ._gc ,_aag ._be );
_aag ._be =make ([]byte ,_cfb );_aag ._feg =0;};_aag ._be [_aag ._feg ]=_aag ._aba ;_aag ._feg ++;};func (_fdd *Encoder )flush (){_fdd .setBits ();_fdd ._ff <<=_fdd ._ab ;_fdd .byteOut ();_fdd ._ff <<=_fdd ._ab ;_fdd .byteOut ();_fdd .emit ();if _fdd ._aba !=0xff{_fdd ._ge ++;
_fdd ._aba =0xff;_fdd .emit ();};_fdd ._ge ++;_fdd ._aba =0xac;_fdd ._ge ++;_fdd .emit ();};func (_dgg *Encoder )code1 (_fbf *codingContext ,_ffbg uint32 ,_abgf uint16 ,_dcb byte ){if _fbf .mps (_ffbg )==1{_dgg .codeMPS (_fbf ,_ffbg ,_abgf ,_dcb );}else {_dgg .codeLPS (_fbf ,_ffbg ,_abgf ,_dcb );
};};const (IAAI Class =iota ;IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);var _fe =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};
func (_cbcc *Encoder )rBlock (){if _cbcc ._ge >=0{_cbcc .emit ();};_cbcc ._ge ++;_cbcc ._aba =uint8 (_cbcc ._ff >>20);_cbcc ._ff &=0xfffff;_cbcc ._ab =7;};func (_bfb *Encoder )Init (){_bfb ._bf =_cc (_fea );_bfb ._dc =0x8000;_bfb ._ff =0;_bfb ._ab =12;
_bfb ._ge =-1;_bfb ._aba =0;_bfb ._feg =0;_bfb ._be =make ([]byte ,_cfb );for _gg :=0;_gg < len (_bfb ._dd );_gg ++{_bfb ._dd [_gg ]=_cc (512);};_bfb ._fc =nil ;};func (_eada *Encoder )lBlock (){if _eada ._ge >=0{_eada .emit ();};_eada ._ge ++;_eada ._aba =uint8 (_eada ._ff >>19);
_eada ._ff &=0x7ffff;_eada ._ab =8;};type Class int ;