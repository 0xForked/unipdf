//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_b "bytes";_e "github.com/unidoc/unipdf/v3/common";_c "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_g "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_f "io";);const (IAAI Class =iota ;IADH ;IADS ;IADT ;IADW ;IAEX ;
IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);func (_cdd *Encoder )DataSize ()int {return _cdd .dataSize ()};func _cf (_gee int )*codingContext {return &codingContext {_fe :make ([]byte ,_gee ),_fed :make ([]byte ,_gee )};};func (_ebd *Encoder )Reset (){_ebd ._fbc =0x8000;
_ebd ._gcc =0;_ebd ._gd =12;_ebd ._cda =-1;_ebd ._af =0;_ebd ._ecb =nil ;_ebd ._cg =_cf (_egga );};type state struct{_gdcd uint16 ;_gafg ,_eeg uint8 ;_egd uint8 ;};func (_cdad *Encoder )dataSize ()int {return _ece *len (_cdad ._ad )+_cdad ._be };func (_dcea *Encoder )encodeOOB (_eggb Class )error {_gfd :=_dcea ._fd [_eggb ];
_cfc :=_dcea .encodeBit (_gfd ,1,1);if _cfc !=nil {return _cfc ;};_cfc =_dcea .encodeBit (_gfd ,3,0);if _cfc !=nil {return _cfc ;};_cfc =_dcea .encodeBit (_gfd ,6,0);if _cfc !=nil {return _cfc ;};_cfc =_dcea .encodeBit (_gfd ,12,0);if _cfc !=nil {return _cfc ;
};return nil ;};func (_acf *Encoder )EncodeIAID (symbolCodeLength ,value int )(_bedf error ){_e .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );
if _bedf =_acf .encodeIAID (symbolCodeLength ,value );_bedf !=nil {return _g .Wrap (_bedf ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};func (_gab *Encoder )encodeInteger (_cce Class ,_dg int )error {const _deb ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";
if _dg > 2000000000||_dg < -2000000000{return _g .Errorf (_deb ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_dg );
};_ddb :=_gab ._fd [_cce ];_aad :=uint32 (1);var _dbe int ;for ;;_dbe ++{if _fa [_dbe ]._fc <=_dg &&_fa [_dbe ]._fg >=_dg {break ;};};if _dg < 0{_dg =-_dg ;};_dg -=int (_fa [_dbe ]._ec );_gff :=_fa [_dbe ]._a ;for _bfde :=uint8 (0);_bfde < _fa [_dbe ]._fb ;
_bfde ++{_eec :=_gff &1;if _dgd :=_gab .encodeBit (_ddb ,_aad ,_eec );_dgd !=nil {return _g .Wrap (_dgd ,_deb ,"");};_gff >>=1;if _aad &0x100> 0{_aad =(((_aad <<1)|uint32 (_eec ))&0x1ff)|0x100;}else {_aad =(_aad <<1)|uint32 (_eec );};};_dg <<=32-_fa [_dbe ]._ge ;
for _cbf :=uint8 (0);_cbf < _fa [_dbe ]._ge ;_cbf ++{_gabc :=uint8 ((uint32 (_dg )&0x80000000)>>31);if _cgd :=_gab .encodeBit (_ddb ,_aad ,_gabc );_cgd !=nil {return _g .Wrap (_cgd ,_deb ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");
};_dg <<=1;if _aad &0x100!=0{_aad =(((_aad <<1)|uint32 (_gabc ))&0x1ff)|0x100;}else {_aad =(_aad <<1)|uint32 (_gabc );};};return nil ;};func (_egc *Encoder )renormalize (){for {_egc ._fbc <<=1;_egc ._gcc <<=1;_egc ._gd --;if _egc ._gd ==0{_egc .byteOut ();
};if (_egc ._fbc &0x8000)!=0{break ;};};};func (_faa *Encoder )EncodeOOB (proc Class )(_eae error ){_e .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );
if _eae =_faa .encodeOOB (proc );_eae !=nil {return _g .Wrap (_eae ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};func (_gea *Encoder )code1 (_eff *codingContext ,_ffe uint32 ,_acc uint16 ,_egg byte ){if _eff .mps (_ffe )==1{_gea .codeMPS (_eff ,_ffe ,_acc ,_egg );
}else {_gea .codeLPS (_eff ,_ffe ,_acc ,_egg );};};const _ef =0x9b25;func New ()*Encoder {_dbc :=&Encoder {};_dbc .Init ();return _dbc };func (_gbf *Encoder )codeLPS (_fedb *codingContext ,_ebf uint32 ,_aag uint16 ,_ceg byte ){_gbf ._fbc -=_aag ;if _gbf ._fbc < _aag {_gbf ._gcc +=uint32 (_aag );
}else {_gbf ._fbc =_aag ;};if _dab [_ceg ]._egd ==1{_fedb .flipMps (_ebf );};_fedb ._fe [_ebf ]=_dab [_ceg ]._eeg ;_gbf .renormalize ();};var _dab =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
func (_bd Class )String ()string {switch _bd {case IAAI :return "\u0049\u0041\u0041\u0049";case IADH :return "\u0049\u0041\u0044\u0048";case IADS :return "\u0049\u0041\u0044\u0053";case IADT :return "\u0049\u0041\u0044\u0054";case IADW :return "\u0049\u0041\u0044\u0057";
case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";case IAIT :return "\u0049\u0041\u0049\u0054";case IARDH :return "\u0049\u0041\u0052D\u0048";case IARDW :return "\u0049\u0041\u0052D\u0057";case IARDX :return "\u0049\u0041\u0052D\u0058";
case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";};};func (_cgcg *Encoder )codeMPS (_aac *codingContext ,_dc uint32 ,_eea uint16 ,_abac byte ){_cgcg ._fbc -=_eea ;
if _cgcg ._fbc &0x8000!=0{_cgcg ._gcc +=uint32 (_eea );return ;};if _cgcg ._fbc < _eea {_cgcg ._fbc =_eea ;}else {_cgcg ._gcc +=uint32 (_eea );};_aac ._fe [_dc ]=_dab [_abac ]._gafg ;_cgcg .renormalize ();};type codingContext struct{_fe []byte ;_fed []byte ;
};func (_bfdbc *Encoder )flush (){_bfdbc .setBits ();_bfdbc ._gcc <<=_bfdbc ._gd ;_bfdbc .byteOut ();_bfdbc ._gcc <<=_bfdbc ._gd ;_bfdbc .byteOut ();_bfdbc .emit ();if _bfdbc ._af !=0xff{_bfdbc ._cda ++;_bfdbc ._af =0xff;_bfdbc .emit ();};_bfdbc ._cda ++;
_bfdbc ._af =0xac;_bfdbc ._cda ++;_bfdbc .emit ();};func (_ddg *Encoder )byteOut (){if _ddg ._af ==0xff{_ddg .rBlock ();return ;};if _ddg ._gcc < 0x8000000{_ddg .lBlock ();return ;};_ddg ._af ++;if _ddg ._af !=0xff{_ddg .lBlock ();return ;};_ddg ._gcc &=0x7ffffff;
_ddg .rBlock ();};type intEncRangeS struct{_fc ,_fg int ;_a ,_fb uint8 ;_ec uint16 ;_ge uint8 ;};func (_afc *Encoder )EncodeBitmap (bm *_c .Bitmap ,duplicateLineRemoval bool )error {_e .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );
var (_bed ,_ab uint8 ;_df ,_gec ,_ae uint16 ;_eb ,_ac ,_gb byte ;_bge ,_beda ,_bb int ;_cc ,_gg []byte ;);for _bea :=0;_bea < bm .Height ;_bea ++{_eb ,_ac =0,0;if _bea >=2{_eb =bm .Data [(_bea -2)*bm .RowStride ];};if _bea >=1{_ac =bm .Data [(_bea -1)*bm .RowStride ];
if duplicateLineRemoval {_beda =_bea *bm .RowStride ;_cc =bm .Data [_beda :_beda +bm .RowStride ];_bb =(_bea -1)*bm .RowStride ;_gg =bm .Data [_bb :_bb +bm .RowStride ];if _b .Equal (_cc ,_gg ){_ab =_bed ^1;_bed =1;}else {_ab =_bed ;_bed =0;};};};if duplicateLineRemoval {if _bedd :=_afc .encodeBit (_afc ._cg ,_ef ,_ab );
_bedd !=nil {return _bedd ;};if _bed !=0{continue ;};};_gb =bm .Data [_bea *bm .RowStride ];_df =uint16 (_eb >>5);_gec =uint16 (_ac >>4);_eb <<=3;_ac <<=4;_ae =0;for _bge =0;_bge < bm .Width ;_bge ++{_bf :=uint32 (_df <<11|_gec <<4|_ae );_gf :=(_gb &0x80)>>7;
_fab :=_afc .encodeBit (_afc ._cg ,_bf ,_gf );if _fab !=nil {return _fab ;};_df <<=1;_gec <<=1;_ae <<=1;_df |=uint16 ((_eb &0x80)>>7);_gec |=uint16 ((_ac &0x80)>>7);_ae |=uint16 (_gf );_gdc :=_bge %8;_aba :=_bge /8+1;if _gdc ==4&&_bea >=2{_eb =0;if _aba < bm .RowStride {_eb =bm .Data [(_bea -2)*bm .RowStride +_aba ];
};}else {_eb <<=1;};if _gdc ==3&&_bea >=1{_ac =0;if _aba < bm .RowStride {_ac =bm .Data [(_bea -1)*bm .RowStride +_aba ];};}else {_ac <<=1;};if _gdc ==7{_gb =0;if _aba < bm .RowStride {_gb =bm .Data [_bea *bm .RowStride +_aba ];};}else {_gb <<=1;};_df &=31;
_gec &=127;_ae &=15;};};return nil ;};const (_egga =65536;_ece =20*1024;);func (_cfb *Encoder )Flush (){_cfb ._be =0;_cfb ._ad =nil ;_cfb ._cda =-1};func (_caa *Encoder )rBlock (){if _caa ._cda >=0{_caa .emit ();};_caa ._cda ++;_caa ._af =uint8 (_caa ._gcc >>20);
_caa ._gcc &=0xfffff;_caa ._gd =7;};type Class int ;func (_ade *Encoder )lBlock (){if _ade ._cda >=0{_ade .emit ();};_ade ._cda ++;_ade ._af =uint8 (_ade ._gcc >>19);_ade ._gcc &=0x7ffff;_ade ._gd =8;};func (_gge *Encoder )EncodeInteger (proc Class ,value int )(_bfd error ){_e .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );
if _bfd =_gge .encodeInteger (proc ,value );_bfd !=nil {return _g .Wrap (_bfd ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};var _ _f .WriterTo =&Encoder {};func (_dce *Encoder )encodeBit (_dfg *codingContext ,_dec uint32 ,_dceg uint8 )error {const _gbfc ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";
_dce ._ea ++;if _dec >=uint32 (len (_dfg ._fe )){return _g .Errorf (_gbfc ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_dec );
};_fec :=_dfg ._fe [_dec ];_egge :=_dfg .mps (_dec );_bec :=_dab [_fec ]._gdcd ;_e .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_dce ._ea ,_dceg ,_fec ,_egge ,_bec ,_dce ._fbc ,_dce ._gcc ,_dce ._gd ,_dce ._af ,_dce ._cda );
if _dceg ==0{_dce .code0 (_dfg ,_dec ,_bec ,_fec );}else {_dce .code1 (_dfg ,_dec ,_bec ,_fec );};return nil ;};func (_de *Encoder )WriteTo (w _f .Writer )(int64 ,error ){const _fca ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";
var _cfd int64 ;for _agc ,_acb :=range _de ._ad {_cgc ,_agd :=w .Write (_acb );if _agd !=nil {return 0,_g .Wrapf (_agd ,_fca ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_agc );
};_cfd +=int64 (_cgc );};_de ._ce =_de ._ce [:_de ._be ];_cfeb ,_fcf :=w .Write (_de ._ce );if _fcf !=nil {return 0,_g .Wrap (_fcf ,_fca ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_cfd +=int64 (_cfeb );return _cfd ,nil ;
};func (_aab *Encoder )code0 (_bfdb *codingContext ,_ba uint32 ,_gaf uint16 ,_ced byte ){if _bfdb .mps (_ba )==0{_aab .codeMPS (_bfdb ,_ba ,_gaf ,_ced );}else {_aab .codeLPS (_bfdb ,_ba ,_gaf ,_ced );};};func (_feg *Encoder )emit (){if _feg ._be ==_ece {_feg ._ad =append (_feg ._ad ,_feg ._ce );
_feg ._ce =make ([]byte ,_ece );_feg ._be =0;};_feg ._ce [_feg ._be ]=_feg ._af ;_feg ._be ++;};func (_bg *Encoder )Init (){_bg ._cg =_cf (_egga );_bg ._fbc =0x8000;_bg ._gcc =0;_bg ._gd =12;_bg ._cda =-1;_bg ._af =0;_bg ._be =0;_bg ._ce =make ([]byte ,_ece );
for _da :=0;_da < len (_bg ._fd );_da ++{_bg ._fd [_da ]=_cf (512);};_bg ._ecb =nil ;};func (_bdb *Encoder )Refine (iTemp ,iTarget *_c .Bitmap ,ox ,oy int )error {for _ggea :=0;_ggea < iTarget .Height ;_ggea ++{var _gecc int ;_dad :=_ggea +oy ;var (_cfe ,_ee ,_aa ,_ga ,_ca uint16 ;
_gdg ,_dd ,_fdd ,_ff ,_bfb byte ;);if _dad >=1&&(_dad -1)< iTemp .Height {_gdg =iTemp .Data [(_dad -1)*iTemp .RowStride ];};if _dad >=0&&_dad < iTemp .Height {_dd =iTemp .Data [_dad *iTemp .RowStride ];};if _dad >=-1&&_dad +1< iTemp .Height {_fdd =iTemp .Data [(_dad +1)*iTemp .RowStride ];
};if _ggea >=1{_ff =iTarget .Data [(_ggea -1)*iTarget .RowStride ];};_bfb =iTarget .Data [_ggea *iTarget .RowStride ];_afd :=uint (6+ox );_cfe =uint16 (_gdg >>_afd );_ee =uint16 (_dd >>_afd );_aa =uint16 (_fdd >>_afd );_ga =uint16 (_ff >>6);_eab :=uint (2-ox );
_gdg <<=_eab ;_dd <<=_eab ;_fdd <<=_eab ;_ff <<=2;for _gecc =0;_gecc < iTarget .Width ;_gecc ++{_gbb :=(_cfe <<10)|(_ee <<7)|(_aa <<4)|(_ga <<1)|_ca ;_bfa :=_bfb >>7;_fda :=_bdb .encodeBit (_bdb ._cg ,uint32 (_gbb ),_bfa );if _fda !=nil {return _fda ;};
_cfe <<=1;_ee <<=1;_aa <<=1;_ga <<=1;_cfe |=uint16 (_gdg >>7);_ee |=uint16 (_dd >>7);_aa |=uint16 (_fdd >>7);_ga |=uint16 (_ff >>7);_ca =uint16 (_bfa );_dbg :=_gecc %8;_bbg :=_gecc /8+1;if _dbg ==5+ox {_gdg ,_dd ,_fdd =0,0,0;if _bbg < iTemp .RowStride &&_dad >=1&&(_dad -1)< iTemp .Height {_gdg =iTemp .Data [(_dad -1)*iTemp .RowStride +_bbg ];
};if _bbg < iTemp .RowStride &&_dad >=0&&_dad < iTemp .Height {_dd =iTemp .Data [_dad *iTemp .RowStride +_bbg ];};if _bbg < iTemp .RowStride &&_dad >=-1&&(_dad +1)< iTemp .Height {_fdd =iTemp .Data [(_dad +1)*iTemp .RowStride +_bbg ];};}else {_gdg <<=1;
_dd <<=1;_fdd <<=1;};if _dbg ==5&&_ggea >=1{_ff =0;if _bbg < iTarget .RowStride {_ff =iTarget .Data [(_ggea -1)*iTarget .RowStride +_bbg ];};}else {_ff <<=1;};if _dbg ==7{_bfb =0;if _bbg < iTarget .RowStride {_bfb =iTarget .Data [_ggea *iTarget .RowStride +_bbg ];
};}else {_bfb <<=1;};_cfe &=7;_ee &=7;_aa &=7;_ga &=7;};};return nil ;};func (_cd *codingContext )flipMps (_cb uint32 ){_cd ._fed [_cb ]=1-_cd ._fed [_cb ]};func (_ddd *Encoder )setBits (){_agca :=_ddd ._gcc +uint32 (_ddd ._fbc );_ddd ._gcc |=0xffff;if _ddd ._gcc >=_agca {_ddd ._gcc -=0x8000;
};};func (_eg *Encoder )Final (){_eg .flush ()};var _fa =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};
func (_db *codingContext )mps (_gc uint32 )int {return int (_db ._fed [_gc ])};type Encoder struct{_gcc uint32 ;_fbc uint16 ;_gd ,_af uint8 ;_cda int ;_ea int ;_ad [][]byte ;_ce []byte ;_be int ;_cg *codingContext ;_fd [13]*codingContext ;_ecb *codingContext ;
};func (_ffd *Encoder )encodeIAID (_efa ,_dfgg int )error {if _ffd ._ecb ==nil {_ffd ._ecb =_cf (1<<uint (_efa ));};_bfg :=uint32 (1<<uint32 (_efa +1))-1;_dfgg <<=uint (32-_efa );_def :=uint32 (1);for _cac :=0;_cac < _efa ;_cac ++{_ecbf :=_def &_bfg ;_agf :=uint8 ((uint32 (_dfgg )&0x80000000)>>31);
if _cddc :=_ffd .encodeBit (_ffd ._ecb ,_ecbf ,_agf );_cddc !=nil {return _cddc ;};_def =(_def <<1)|uint32 (_agf );_dfgg <<=1;};return nil ;};