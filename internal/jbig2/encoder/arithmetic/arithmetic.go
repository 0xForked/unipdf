//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_d "bytes";_c "github.com/unidoc/unipdf/v3/common";_b "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_a "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_e "io";);func (_gacf *Encoder )Refine (iTemp ,iTarget *_b .Bitmap ,ox ,oy int )error {for _eg :=0;_eg < iTarget .Height ;_eg ++{var _dfd int ;_gag :=_eg +oy ;var (_aed ,_eada ,_bf ,_egd ,_aca uint16 ;_fec ,_cae ,_acad ,_ec ,_eec byte ;);if _gag >=1&&(_gag -1)< iTemp .Height {_fec =iTemp .Data [(_gag -1)*iTemp .RowStride ];};if _gag >=0&&_gag < iTemp .Height {_cae =iTemp .Data [_gag *iTemp .RowStride ];};if _gag >=-1&&_gag +1< iTemp .Height {_acad =iTemp .Data [(_gag +1)*iTemp .RowStride ];};if _eg >=1{_ec =iTarget .Data [(_eg -1)*iTarget .RowStride ];};_eec =iTarget .Data [_eg *iTarget .RowStride ];_fg :=uint (6+ox );_aed =uint16 (_fec >>_fg );_eada =uint16 (_cae >>_fg );_bf =uint16 (_acad >>_fg );_egd =uint16 (_ec >>6);_gd :=uint (2-ox );_fec <<=_gd ;_cae <<=_gd ;_acad <<=_gd ;_ec <<=2;for _dfd =0;_dfd < iTarget .Width ;_dfd ++{_gge :=(_aed <<10)|(_eada <<7)|(_bf <<4)|(_egd <<1)|_aca ;_aga :=_eec >>7;_cef :=_gacf .encodeBit (_gacf ._db ,uint32 (_gge ),_aga );if _cef !=nil {return _cef ;};_aed <<=1;_eada <<=1;_bf <<=1;_egd <<=1;_aed |=uint16 (_fec >>7);_eada |=uint16 (_cae >>7);_bf |=uint16 (_acad >>7);_egd |=uint16 (_ec >>7);_aca =uint16 (_aga );_dcb :=_dfd %8;_caa :=_dfd /8+1;if _dcb ==5+ox {_fec ,_cae ,_acad =0,0,0;if _caa < iTemp .RowStride &&_gag >=1&&(_gag -1)< iTemp .Height {_fec =iTemp .Data [(_gag -1)*iTemp .RowStride +_caa ];};if _caa < iTemp .RowStride &&_gag >=0&&_gag < iTemp .Height {_cae =iTemp .Data [_gag *iTemp .RowStride +_caa ];};if _caa < iTemp .RowStride &&_gag >=-1&&(_gag +1)< iTemp .Height {_acad =iTemp .Data [(_gag +1)*iTemp .RowStride +_caa ];};}else {_fec <<=1;_cae <<=1;_acad <<=1;};if _dcb ==5&&_eg >=1{_ec =0;if _caa < iTarget .RowStride {_ec =iTarget .Data [(_eg -1)*iTarget .RowStride +_caa ];};}else {_ec <<=1;};if _dcb ==7{_eec =0;if _caa < iTarget .RowStride {_eec =iTarget .Data [_eg *iTarget .RowStride +_caa ];};}else {_eec <<=1;};_aed &=7;_eada &=7;_bf &=7;_egd &=7;};};return nil ;};func (_fecb *Encoder )encodeIAID (_dca ,_eacg int )error {if _fecb ._ee ==nil {_fecb ._ee =_ag (1<<uint (_dca ));};_fgg :=uint32 (1<<uint32 (_dca +1))-1;_eacg <<=uint (32-_dca );_fgf :=uint32 (1);for _fea :=0;_fea < _dca ;_fea ++{_acdd :=_fgf &_fgg ;_add :=uint8 ((uint32 (_eacg )&0x80000000)>>31);if _ece :=_fecb .encodeBit (_fecb ._ee ,_acdd ,_add );_ece !=nil {return _ece ;};_fgf =(_fgf <<1)|uint32 (_add );_eacg <<=1;};return nil ;};func (_cec *codingContext )flipMps (_bd uint32 ){_cec ._ea [_bd ]=1-_cec ._ea [_bd ]};func (_af *codingContext )mps (_cb uint32 )int {return int (_af ._ea [_cb ])};func (_acd *Encoder )codeMPS (_ggcc *codingContext ,_edf uint32 ,_bbd uint16 ,_beab byte ){_acd ._cf -=_bbd ;if _acd ._cf &0x8000!=0{_acd ._gc +=uint32 (_bbd );return ;};if _acd ._cf < _bbd {_acd ._cf =_bbd ;}else {_acd ._gc +=uint32 (_bbd );};_ggcc ._dc [_edf ]=_fd [_beab ]._edg ;_acd .renormalize ();};func (_dgc *Encoder )code1 (_ffa *codingContext ,_gae uint32 ,_ceag uint16 ,_dd byte ){if _ffa .mps (_gae )==1{_dgc .codeMPS (_ffa ,_gae ,_ceag ,_dd );}else {_dgc .codeLPS (_ffa ,_gae ,_ceag ,_dd );};};const _eac =0x9b25;type Encoder struct{_gc uint32 ;_cf uint16 ;_dcg ,_ae uint8 ;_cfc int ;_afb int ;_ead [][]byte ;_f []byte ;_be int ;_db *codingContext ;_ab [13]*codingContext ;_ee *codingContext ;};func New ()*Encoder {_dae :=&Encoder {};_dae .Init ();return _dae };func (_daf *Encoder )EncodeBitmap (bm *_b .Bitmap ,duplicateLineRemoval bool )error {_c .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );var (_bee ,_fc uint8 ;_agb ,_bg ,_ded uint16 ;_age ,_afbb ,_ca byte ;_deda ,_gac ,_fe int ;_ffe ,_eb []byte ;);for _gef :=0;_gef < bm .Height ;_gef ++{_age ,_afbb =0,0;if _gef >=2{_age =bm .Data [(_gef -2)*bm .RowStride ];};if _gef >=1{_afbb =bm .Data [(_gef -1)*bm .RowStride ];if duplicateLineRemoval {_gac =_gef *bm .RowStride ;_ffe =bm .Data [_gac :_gac +bm .RowStride ];_fe =(_gef -1)*bm .RowStride ;_eb =bm .Data [_fe :_fe +bm .RowStride ];if _d .Equal (_ffe ,_eb ){_fc =_bee ^1;_bee =1;}else {_fc =_bee ;_bee =0;};};};if duplicateLineRemoval {if _agg :=_daf .encodeBit (_daf ._db ,_eac ,_fc );_agg !=nil {return _agg ;};if _bee !=0{continue ;};};_ca =bm .Data [_gef *bm .RowStride ];_agb =uint16 (_age >>5);_bg =uint16 (_afbb >>4);_age <<=3;_afbb <<=4;_ded =0;for _deda =0;_deda < bm .Width ;_deda ++{_adc :=uint32 (_agb <<11|_bg <<4|_ded );_dag :=(_ca &0x80)>>7;_dede :=_daf .encodeBit (_daf ._db ,_adc ,_dag );if _dede !=nil {return _dede ;};_agb <<=1;_bg <<=1;_ded <<=1;_agb |=uint16 ((_age &0x80)>>7);_bg |=uint16 ((_afbb &0x80)>>7);_ded |=uint16 (_dag );_ceea :=_deda %8;_df :=_deda /8+1;if _ceea ==4&&_gef >=2{_age =0;if _df < bm .RowStride {_age =bm .Data [(_gef -2)*bm .RowStride +_df ];};}else {_age <<=1;};if _ceea ==3&&_gef >=1{_afbb =0;if _df < bm .RowStride {_afbb =bm .Data [(_gef -1)*bm .RowStride +_df ];};}else {_afbb <<=1;};if _ceea ==7{_ca =0;if _df < bm .RowStride {_ca =bm .Data [_gef *bm .RowStride +_df ];};}else {_ca <<=1;};_agb &=31;_bg &=127;_ded &=15;};};return nil ;};func _ag (_ge int )*codingContext {return &codingContext {_dc :make ([]byte ,_ge ),_ea :make ([]byte ,_ge )};};const (IAAI Class =iota ;IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);func (_fce *Encoder )Final (){_fce .flush ()};func (_accc *Encoder )encodeOOB (_dgcf Class )error {_aa :=_accc ._ab [_dgcf ];_cfb :=_accc .encodeBit (_aa ,1,1);if _cfb !=nil {return _cfb ;};_cfb =_accc .encodeBit (_aa ,3,0);if _cfb !=nil {return _cfb ;};_cfb =_accc .encodeBit (_aa ,6,0);if _cfb !=nil {return _cfb ;};_cfb =_accc .encodeBit (_aa ,12,0);if _cfb !=nil {return _cfb ;};return nil ;};type intEncRangeS struct{_ga ,_ad int ;_ac ,_gg uint8 ;_ce uint16 ;_ef uint8 ;};func (_cecd *Encoder )EncodeInteger (proc Class ,value int )(_acc error ){_c .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );if _acc =_cecd .encodeInteger (proc ,value );_acc !=nil {return _a .Wrap (_acc ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};type state struct{_deec uint16 ;_edg ,_ddf uint8 ;_bef uint8 ;};func (_bed *Encoder )EncodeOOB (proc Class )(_ceb error ){_c .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );if _ceb =_bed .encodeOOB (proc );_ceb !=nil {return _a .Wrap (_ceb ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};func (_eeb *Encoder )Init (){_eeb ._db =_ag (_ada );_eeb ._cf =0x8000;_eeb ._gc =0;_eeb ._dcg =12;_eeb ._cfc =-1;_eeb ._ae =0;_eeb ._be =0;_eeb ._f =make ([]byte ,_dbg );for _ff :=0;_ff < len (_eeb ._ab );_ff ++{_eeb ._ab [_ff ]=_ag (512);};_eeb ._ee =nil ;};func (_dfc *Encoder )setBits (){_dcbe :=_dfc ._gc +uint32 (_dfc ._cf );_dfc ._gc |=0xffff;if _dfc ._gc >=_dcbe {_dfc ._gc -=0x8000;};};func (_gbg *Encoder )rBlock (){if _gbg ._cfc >=0{_gbg .emit ();};_gbg ._cfc ++;_gbg ._ae =uint8 (_gbg ._gc >>20);_gbg ._gc &=0xfffff;_gbg ._dcg =7;};func (_fa *Encoder )encodeBit (_gaee *codingContext ,_bca uint32 ,_dee uint8 )error {const _eaf ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";_fa ._afb ++;if _bca >=uint32 (len (_gaee ._dc )){return _a .Errorf (_eaf ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_bca );};_gff :=_gaee ._dc [_bca ];_afd :=_gaee .mps (_bca );_dfa :=_fd [_gff ]._deec ;_c .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_fa ._afb ,_dee ,_gff ,_afd ,_dfa ,_fa ._cf ,_fa ._gc ,_fa ._dcg ,_fa ._ae ,_fa ._cfc );if _dee ==0{_fa .code0 (_gaee ,_bca ,_dfa ,_gff );}else {_fa .code1 (_gaee ,_bca ,_dfa ,_gff );};return nil ;};func (_ggc *Encoder )code0 (_bea *codingContext ,_eaa uint32 ,_gcc uint16 ,_ed byte ){if _bea .mps (_eaa )==0{_ggc .codeMPS (_bea ,_eaa ,_gcc ,_ed );}else {_ggc .codeLPS (_bea ,_eaa ,_gcc ,_ed );};};func (_da Class )String ()string {switch _da {case IAAI :return "\u0049\u0041\u0041\u0049";case IADH :return "\u0049\u0041\u0044\u0048";case IADS :return "\u0049\u0041\u0044\u0053";case IADT :return "\u0049\u0041\u0044\u0054";case IADW :return "\u0049\u0041\u0044\u0057";case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";case IAIT :return "\u0049\u0041\u0049\u0054";case IARDH :return "\u0049\u0041\u0052D\u0048";case IARDW :return "\u0049\u0041\u0052D\u0057";case IARDX :return "\u0049\u0041\u0052D\u0058";case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";};};func (_abd *Encoder )WriteTo (w _e .Writer )(int64 ,error ){const _gf ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";var _efa int64 ;for _feg ,_gad :=range _abd ._ead {_dg ,_eca :=w .Write (_gad );if _eca !=nil {return 0,_a .Wrapf (_eca ,_gf ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_feg );};_efa +=int64 (_dg );};_abd ._f =_abd ._f [:_abd ._be ];_egb ,_dgg :=w .Write (_abd ._f );if _dgg !=nil {return 0,_a .Wrap (_dgg ,_gf ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_efa +=int64 (_egb );return _efa ,nil ;};func (_aff *Encoder )codeLPS (_cecb *codingContext ,_agbf uint32 ,_efaf uint16 ,_fb byte ){_aff ._cf -=_efaf ;if _aff ._cf < _efaf {_aff ._gc +=uint32 (_efaf );}else {_aff ._cf =_efaf ;};if _fd [_fb ]._bef ==1{_cecb .flipMps (_agbf );};_cecb ._dc [_agbf ]=_fd [_fb ]._ddf ;_aff .renormalize ();};func (_cee *Encoder )DataSize ()int {return _cee .dataSize ()};const (_ada =65536;_dbg =20*1024;);func (_def *Encoder )emit (){if _def ._be ==_dbg {_def ._ead =append (_def ._ead ,_def ._f );_def ._f =make ([]byte ,_dbg );_def ._be =0;};_def ._f [_def ._be ]=_def ._ae ;_def ._be ++;};func (_bfc *Encoder )byteOut (){if _bfc ._ae ==0xff{_bfc .rBlock ();return ;};if _bfc ._gc < 0x8000000{_bfc .lBlock ();return ;};_bfc ._ae ++;if _bfc ._ae !=0xff{_bfc .lBlock ();return ;};_bfc ._gc &=0x7ffffff;_bfc .rBlock ();};type Class int ;func (_cea *Encoder )EncodeIAID (symbolCodeLength ,value int )(_bgg error ){_c .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );if _bgg =_cea .encodeIAID (symbolCodeLength ,value );_bgg !=nil {return _a .Wrap (_bgg ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};var _ _e .WriterTo =&Encoder {};type codingContext struct{_dc []byte ;_ea []byte ;};var _fd =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};func (_fca *Encoder )Flush (){_fca ._be =0;_fca ._ead =nil ;_fca ._cfc =-1};var _de =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};func (_gba *Encoder )flush (){_gba .setBits ();_gba ._gc <<=_gba ._dcg ;_gba .byteOut ();_gba ._gc <<=_gba ._dcg ;_gba .byteOut ();_gba .emit ();if _gba ._ae !=0xff{_gba ._cfc ++;_gba ._ae =0xff;_gba .emit ();};_gba ._cfc ++;_gba ._ae =0xac;_gba ._cfc ++;_gba .emit ();};func (_cbe *Encoder )renormalize (){for {_cbe ._cf <<=1;_cbe ._gc <<=1;_cbe ._dcg --;if _cbe ._dcg ==0{_cbe .byteOut ();};if (_cbe ._cf &0x8000)!=0{break ;};};};func (_cba *Encoder )lBlock (){if _cba ._cfc >=0{_cba .emit ();};_cba ._cfc ++;_cba ._ae =uint8 (_cba ._gc >>19);_cba ._gc &=0x7ffff;_cba ._dcg =8;};func (_bc *Encoder )dataSize ()int {return _dbg *len (_bc ._ead )+_bc ._be };func (_accd *Encoder )Reset (){_accd ._cf =0x8000;_accd ._gc =0;_accd ._dcg =12;_accd ._cfc =-1;_accd ._ae =0;_accd ._ee =nil ;_accd ._db =_ag (_ada );};func (_ebg *Encoder )encodeInteger (_cag Class ,_gb int )error {const _fceb ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";if _gb > 2000000000||_gb < -2000000000{return _a .Errorf (_fceb ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_gb );};_edc :=_ebg ._ab [_cag ];_fcf :=uint32 (1);var _cc int ;for ;;_cc ++{if _de [_cc ]._ga <=_gb &&_de [_cc ]._ad >=_gb {break ;};};if _gb < 0{_gb =-_gb ;};_gb -=int (_de [_cc ]._ce );_ffc :=_de [_cc ]._ac ;for _ebf :=uint8 (0);_ebf < _de [_cc ]._gg ;_ebf ++{_cagd :=_ffc &1;if _feca :=_ebg .encodeBit (_edc ,_fcf ,_cagd );_feca !=nil {return _a .Wrap (_feca ,_fceb ,"");};_ffc >>=1;if _fcf &0x100> 0{_fcf =(((_fcf <<1)|uint32 (_cagd ))&0x1ff)|0x100;}else {_fcf =(_fcf <<1)|uint32 (_cagd );};};_gb <<=32-_de [_cc ]._ef ;for _ceg :=uint8 (0);_ceg < _de [_cc ]._ef ;_ceg ++{_cg :=uint8 ((uint32 (_gb )&0x80000000)>>31);if _eade :=_ebg .encodeBit (_edc ,_fcf ,_cg );_eade !=nil {return _a .Wrap (_eade ,_fceb ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");};_gb <<=1;if _fcf &0x100!=0{_fcf =(((_fcf <<1)|uint32 (_cg ))&0x1ff)|0x100;}else {_fcf =(_fcf <<1)|uint32 (_cg );};};return nil ;};