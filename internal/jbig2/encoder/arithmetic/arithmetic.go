//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_c "bytes";_dd "github.com/unidoc/unipdf/v3/common";_g "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_aa "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_a "io";);func (_cbb *Encoder )WriteTo (w _a .Writer )(int64 ,error ){const _abc ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";
var _df int64 ;for _gc ,_gefb :=range _cbb ._dc {_geff ,_eda :=w .Write (_gefb );if _eda !=nil {return 0,_aa .Wrapf (_eda ,_abc ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_gc );
};_df +=int64 (_geff );};_cbb ._gde =_cbb ._gde [:_cbb ._ag ];_gfg ,_fc :=w .Write (_cbb ._gde );if _fc !=nil {return 0,_aa .Wrap (_fc ,_abc ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_df +=int64 (_gfg );return _df ,nil ;
};func (_fb *Encoder )Init (){_fb ._eg =_cf (_dadd );_fb ._adg =0x8000;_fb ._ed =0;_fb ._fd =12;_fb ._ee =-1;_fb ._cg =0;_fb ._ag =0;_fb ._gde =make ([]byte ,_dfd );for _ce :=0;_ce < len (_fb ._dcb );_ce ++{_fb ._dcb [_ce ]=_cf (512);};_fb ._ba =nil ;};
type state struct{_ebg uint16 ;_bbgb ,_edc uint8 ;_fdd uint8 ;};type intEncRangeS struct{_f ,_b int ;_bg ,_cb uint8 ;_e uint16 ;_cbc uint8 ;};func (_dbd *Encoder )EncodeIAID (symbolCodeLength ,value int )(_gb error ){_dd .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );
if _gb =_dbd .encodeIAID (symbolCodeLength ,value );_gb !=nil {return _aa .Wrap (_gb ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};func (_ab *Encoder )Final (){_ab .flush ()};func (_ga *Encoder )DataSize ()int {return _ga .dataSize ()};
func (_dae *Encoder )Reset (){_dae ._adg =0x8000;_dae ._ed =0;_dae ._fd =12;_dae ._ee =-1;_dae ._cg =0;_dae ._ba =nil ;_dae ._eg =_cf (_dadd );};var _ _a .WriterTo =&Encoder {};func (_bfd *Encoder )lBlock (){if _bfd ._ee >=0{_bfd .emit ();};_bfd ._ee ++;
_bfd ._cg =uint8 (_bfd ._ed >>19);_bfd ._ed &=0x7ffff;_bfd ._fd =8;};func (_ccd *Encoder )dataSize ()int {return _dfd *len (_ccd ._dc )+_ccd ._ag };func (_ege *Encoder )Refine (iTemp ,iTarget *_g .Bitmap ,ox ,oy int )error {for _abf :=0;_abf < iTarget .Height ;
_abf ++{var _ebd int ;_bbf :=_abf +oy ;var (_ff ,_gf ,_ffb ,_aaa ,_afg uint16 ;_ef ,_ea ,_afa ,_dg ,_bbfa byte ;);if _bbf >=1&&(_bbf -1)< iTemp .Height {_ef =iTemp .Data [(_bbf -1)*iTemp .RowStride ];};if _bbf >=0&&_bbf < iTemp .Height {_ea =iTemp .Data [_bbf *iTemp .RowStride ];
};if _bbf >=-1&&_bbf +1< iTemp .Height {_afa =iTemp .Data [(_bbf +1)*iTemp .RowStride ];};if _abf >=1{_dg =iTarget .Data [(_abf -1)*iTarget .RowStride ];};_bbfa =iTarget .Data [_abf *iTarget .RowStride ];_bc :=uint (6+ox );_ff =uint16 (_ef >>_bc );_gf =uint16 (_ea >>_bc );
_ffb =uint16 (_afa >>_bc );_aaa =uint16 (_dg >>6);_ceg :=uint (2-ox );_ef <<=_ceg ;_ea <<=_ceg ;_afa <<=_ceg ;_dg <<=2;for _ebd =0;_ebd < iTarget .Width ;_ebd ++{_aae :=(_ff <<10)|(_gf <<7)|(_ffb <<4)|(_aaa <<1)|_afg ;_eba :=_bbfa >>7;_dgg :=_ege .encodeBit (_ege ._eg ,uint32 (_aae ),_eba );
if _dgg !=nil {return _dgg ;};_ff <<=1;_gf <<=1;_ffb <<=1;_aaa <<=1;_ff |=uint16 (_ef >>7);_gf |=uint16 (_ea >>7);_ffb |=uint16 (_afa >>7);_aaa |=uint16 (_dg >>7);_afg =uint16 (_eba );_cbcd :=_ebd %8;_abfa :=_ebd /8+1;if _cbcd ==5+ox {_ef ,_ea ,_afa =0,0,0;
if _abfa < iTemp .RowStride &&_bbf >=1&&(_bbf -1)< iTemp .Height {_ef =iTemp .Data [(_bbf -1)*iTemp .RowStride +_abfa ];};if _abfa < iTemp .RowStride &&_bbf >=0&&_bbf < iTemp .Height {_ea =iTemp .Data [_bbf *iTemp .RowStride +_abfa ];};if _abfa < iTemp .RowStride &&_bbf >=-1&&(_bbf +1)< iTemp .Height {_afa =iTemp .Data [(_bbf +1)*iTemp .RowStride +_abfa ];
};}else {_ef <<=1;_ea <<=1;_afa <<=1;};if _cbcd ==5&&_abf >=1{_dg =0;if _abfa < iTarget .RowStride {_dg =iTarget .Data [(_abf -1)*iTarget .RowStride +_abfa ];};}else {_dg <<=1;};if _cbcd ==7{_bbfa =0;if _abfa < iTarget .RowStride {_bbfa =iTarget .Data [_abf *iTarget .RowStride +_abfa ];
};}else {_bbfa <<=1;};_ff &=7;_gf &=7;_ffb &=7;_aaa &=7;};};return nil ;};func (_cca *Encoder )code1 (_fgc *codingContext ,_cdb uint32 ,_bbfd uint16 ,_abg byte ){if _fgc .mps (_cdb )==1{_cca .codeMPS (_fgc ,_cdb ,_bbfd ,_abg );}else {_cca .codeLPS (_fgc ,_cdb ,_bbfd ,_abg );
};};const _gab =0x9b25;func (_dfc *Encoder )code0 (_ebaa *codingContext ,_ffd uint32 ,_dgb uint16 ,_daa byte ){if _ebaa .mps (_ffd )==0{_dfc .codeMPS (_ebaa ,_ffd ,_dgb ,_daa );}else {_dfc .codeLPS (_ebaa ,_ffd ,_dgb ,_daa );};};func (_cde *Encoder )setBits (){_afe :=_cde ._ed +uint32 (_cde ._adg );
_cde ._ed |=0xffff;if _cde ._ed >=_afe {_cde ._ed -=0x8000;};};func (_cc *codingContext )flipMps (_daf uint32 ){_cc ._fg [_daf ]=1-_cc ._fg [_daf ]};func (_dbb *Encoder )flush (){_dbb .setBits ();_dbb ._ed <<=_dbb ._fd ;_dbb .byteOut ();_dbb ._ed <<=_dbb ._fd ;
_dbb .byteOut ();_dbb .emit ();if _dbb ._cg !=0xff{_dbb ._ee ++;_dbb ._cg =0xff;_dbb .emit ();};_dbb ._ee ++;_dbb ._cg =0xac;_dbb ._ee ++;_dbb .emit ();};func (_bda *Encoder )codeMPS (_aee *codingContext ,_cfg uint32 ,_age uint16 ,_egb byte ){_bda ._adg -=_age ;
if _bda ._adg &0x8000!=0{_bda ._ed +=uint32 (_age );return ;};if _bda ._adg < _age {_bda ._adg =_age ;}else {_bda ._ed +=uint32 (_age );};_aee ._da [_cfg ]=_ggb [_egb ]._bbgb ;_bda .renormalize ();};func (_ecg *Encoder )byteOut (){if _ecg ._cg ==0xff{_ecg .rBlock ();
return ;};if _ecg ._ed < 0x8000000{_ecg .lBlock ();return ;};_ecg ._cg ++;if _ecg ._cg !=0xff{_ecg .lBlock ();return ;};_ecg ._ed &=0x7ffffff;_ecg .rBlock ();};const (_dadd =65536;_dfd =20*1024;);func (_cd *Encoder )EncodeOOB (proc Class )(_eea error ){_dd .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );
if _eea =_cd .encodeOOB (proc );_eea !=nil {return _aa .Wrap (_eea ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};func (_adf *Encoder )encodeIAID (_gbc ,_bge int )error {if _adf ._ba ==nil {_adf ._ba =_cf (1<<uint (_gbc ));};_gg :=uint32 (1<<uint32 (_gbc +1))-1;
_bge <<=uint (32-_gbc );_aaf :=uint32 (1);for _bce :=0;_bce < _gbc ;_bce ++{_bcb :=_aaf &_gg ;_ggg :=uint8 ((uint32 (_bge )&0x80000000)>>31);if _aed :=_adf .encodeBit (_adf ._ba ,_bcb ,_ggg );_aed !=nil {return _aed ;};_aaf =(_aaf <<1)|uint32 (_ggg );_bge <<=1;
};return nil ;};func (_afd *Encoder )encodeOOB (_gdee Class )error {_bgd :=_afd ._dcb [_gdee ];_deba :=_afd .encodeBit (_bgd ,1,1);if _deba !=nil {return _deba ;};_deba =_afd .encodeBit (_bgd ,3,0);if _deba !=nil {return _deba ;};_deba =_afd .encodeBit (_bgd ,6,0);
if _deba !=nil {return _deba ;};_deba =_afd .encodeBit (_bgd ,12,0);if _deba !=nil {return _deba ;};return nil ;};func _cf (_ec int )*codingContext {return &codingContext {_da :make ([]byte ,_ec ),_fg :make ([]byte ,_ec )};};var _gd =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};
const (IAAI Class =iota ;IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);type Encoder struct{_ed uint32 ;_adg uint16 ;_fd ,_cg uint8 ;_ee int ;_bf int ;_dc [][]byte ;_gde []byte ;_ag int ;_eg *codingContext ;_dcb [13]*codingContext ;
_ba *codingContext ;};func (_bbb *Encoder )encodeBit (_gbe *codingContext ,_bbg uint32 ,_gec uint8 )error {const _add ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";_bbb ._bf ++;if _bbg >=uint32 (len (_gbe ._da )){return _aa .Errorf (_add ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_bbg );
};_dbf :=_gbe ._da [_bbg ];_fbe :=_gbe .mps (_bbg );_gae :=_ggb [_dbf ]._ebg ;_dd .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_bbb ._bf ,_gec ,_dbf ,_fbe ,_gae ,_bbb ._adg ,_bbb ._ed ,_bbb ._fd ,_bbb ._cg ,_bbb ._ee );
if _gec ==0{_bbb .code0 (_gbe ,_bbg ,_gae ,_dbf );}else {_bbb .code1 (_gbe ,_bbg ,_gae ,_dbf );};return nil ;};func (_bde *Encoder )encodeInteger (_ddb Class ,_addd int )error {const _ecb ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";
if _addd > 2000000000||_addd < -2000000000{return _aa .Errorf (_ecb ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_addd );
};_fbg :=_bde ._dcb [_ddb ];_dbe :=uint32 (1);var _gbed int ;for ;;_gbed ++{if _gd [_gbed ]._f <=_addd &&_gd [_gbed ]._b >=_addd {break ;};};if _addd < 0{_addd =-_addd ;};_addd -=int (_gd [_gbed ]._e );_aec :=_gd [_gbed ]._bg ;for _fbge :=uint8 (0);_fbge < _gd [_gbed ]._cb ;
_fbge ++{_fbc :=_aec &1;if _cfd :=_bde .encodeBit (_fbg ,_dbe ,_fbc );_cfd !=nil {return _aa .Wrap (_cfd ,_ecb ,"");};_aec >>=1;if _dbe &0x100> 0{_dbe =(((_dbe <<1)|uint32 (_fbc ))&0x1ff)|0x100;}else {_dbe =(_dbe <<1)|uint32 (_fbc );};};_addd <<=32-_gd [_gbed ]._cbc ;
for _cef :=uint8 (0);_cef < _gd [_gbed ]._cbc ;_cef ++{_edf :=uint8 ((uint32 (_addd )&0x80000000)>>31);if _fa :=_bde .encodeBit (_fbg ,_dbe ,_edf );_fa !=nil {return _aa .Wrap (_fa ,_ecb ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");
};_addd <<=1;if _dbe &0x100!=0{_dbe =(((_dbe <<1)|uint32 (_edf ))&0x1ff)|0x100;}else {_dbe =(_dbe <<1)|uint32 (_edf );};};return nil ;};func (_af *Encoder )EncodeInteger (proc Class ,value int )(_cgg error ){_dd .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );
if _cgg =_af .encodeInteger (proc ,value );_cgg !=nil {return _aa .Wrap (_cgg ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};func (_def *Encoder )renormalize (){for {_def ._adg <<=1;_def ._ed <<=1;
_def ._fd --;if _def ._fd ==0{_def .byteOut ();};if (_def ._adg &0x8000)!=0{break ;};};};type Class int ;func (_fdb *Encoder )rBlock (){if _fdb ._ee >=0{_fdb .emit ();};_fdb ._ee ++;_fdb ._cg =uint8 (_fdb ._ed >>20);_fdb ._ed &=0xfffff;_fdb ._fd =7;};type codingContext struct{_da []byte ;
_fg []byte ;};func (_ccc *Encoder )emit (){if _ccc ._ag ==_dfd {_ccc ._dc =append (_ccc ._dc ,_ccc ._gde );_ccc ._gde =make ([]byte ,_dfd );_ccc ._ag =0;};_ccc ._gde [_ccc ._ag ]=_ccc ._cg ;_ccc ._ag ++;};func (_cgc *Encoder )EncodeBitmap (bm *_g .Bitmap ,duplicateLineRemoval bool )error {_dd .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );
var (_de ,_dad uint8 ;_db ,_cge ,_bb uint16 ;_ceb ,_deb ,_ae byte ;_eb ,_egc ,_ada int ;_egcd ,_eeg []byte ;);for _ecc :=0;_ecc < bm .Height ;_ecc ++{_ceb ,_deb =0,0;if _ecc >=2{_ceb =bm .Data [(_ecc -2)*bm .RowStride ];};if _ecc >=1{_deb =bm .Data [(_ecc -1)*bm .RowStride ];
if duplicateLineRemoval {_egc =_ecc *bm .RowStride ;_egcd =bm .Data [_egc :_egc +bm .RowStride ];_ada =(_ecc -1)*bm .RowStride ;_eeg =bm .Data [_ada :_ada +bm .RowStride ];if _c .Equal (_egcd ,_eeg ){_dad =_de ^1;_de =1;}else {_dad =_de ;_de =0;};};};if duplicateLineRemoval {if _gef :=_cgc .encodeBit (_cgc ._eg ,_gab ,_dad );
_gef !=nil {return _gef ;};if _de !=0{continue ;};};_ae =bm .Data [_ecc *bm .RowStride ];_db =uint16 (_ceb >>5);_cge =uint16 (_deb >>4);_ceb <<=3;_deb <<=4;_bb =0;for _eb =0;_eb < bm .Width ;_eb ++{_ac :=uint32 (_db <<11|_cge <<4|_bb );_fbf :=(_ae &0x80)>>7;
_cba :=_cgc .encodeBit (_cgc ._eg ,_ac ,_fbf );if _cba !=nil {return _cba ;};_db <<=1;_cge <<=1;_bb <<=1;_db |=uint16 ((_ceb &0x80)>>7);_cge |=uint16 ((_deb &0x80)>>7);_bb |=uint16 (_fbf );_fgb :=_eb %8;_baf :=_eb /8+1;if _fgb ==4&&_ecc >=2{_ceb =0;if _baf < bm .RowStride {_ceb =bm .Data [(_ecc -2)*bm .RowStride +_baf ];
};}else {_ceb <<=1;};if _fgb ==3&&_ecc >=1{_deb =0;if _baf < bm .RowStride {_deb =bm .Data [(_ecc -1)*bm .RowStride +_baf ];};}else {_deb <<=1;};if _fgb ==7{_ae =0;if _baf < bm .RowStride {_ae =bm .Data [_ecc *bm .RowStride +_baf ];};}else {_ae <<=1;};
_db &=31;_cge &=127;_bb &=15;};};return nil ;};func (_bdg *Encoder )codeLPS (_aeeb *codingContext ,_bfa uint32 ,_abge uint16 ,_fga byte ){_bdg ._adg -=_abge ;if _bdg ._adg < _abge {_bdg ._ed +=uint32 (_abge );}else {_bdg ._adg =_abge ;};if _ggb [_fga ]._fdd ==1{_aeeb .flipMps (_bfa );
};_aeeb ._da [_bfa ]=_ggb [_fga ]._edc ;_bdg .renormalize ();};func (_ge *codingContext )mps (_bd uint32 )int {return int (_ge ._fg [_bd ])};func (_ad Class )String ()string {switch _ad {case IAAI :return "\u0049\u0041\u0041\u0049";case IADH :return "\u0049\u0041\u0044\u0048";
case IADS :return "\u0049\u0041\u0044\u0053";case IADT :return "\u0049\u0041\u0044\u0054";case IADW :return "\u0049\u0041\u0044\u0057";case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";case IAIT :return "\u0049\u0041\u0049\u0054";
case IARDH :return "\u0049\u0041\u0052D\u0048";case IARDW :return "\u0049\u0041\u0052D\u0057";case IARDX :return "\u0049\u0041\u0052D\u0058";case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";
};};func (_bba *Encoder )Flush (){_bba ._ag =0;_bba ._dc =nil ;_bba ._ee =-1};var _ggb =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
func New ()*Encoder {_fe :=&Encoder {};_fe .Init ();return _fe };