//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_b "bytes";_cf "github.com/unidoc/unipdf/v3/common";_ca "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_e "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_d "io";);func (_eb *Encoder )Reset (){_eb ._ef =0x8000;_eb ._cbc =0;
_eb ._bgd =12;_eb ._dfbc =-1;_eb ._bd =0;_eb ._cag =nil ;_eb ._eebd =_f (_eedf );};func (_cc Class )String ()string {switch _cc {case IAAI :return "\u0049\u0041\u0041\u0049";case IADH :return "\u0049\u0041\u0044\u0048";case IADS :return "\u0049\u0041\u0044\u0053";
case IADT :return "\u0049\u0041\u0044\u0054";case IADW :return "\u0049\u0041\u0044\u0057";case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";case IAIT :return "\u0049\u0041\u0049\u0054";case IARDH :return "\u0049\u0041\u0052D\u0048";
case IARDW :return "\u0049\u0041\u0052D\u0057";case IARDX :return "\u0049\u0041\u0052D\u0058";case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";};};func (_eee *Encoder )DataSize ()int {return _eee .dataSize ()};
func (_fgdc *Encoder )encodeIAID (_faf ,_ggge int )error {if _fgdc ._cag ==nil {_fgdc ._cag =_f (1<<uint (_faf ));};_cfcg :=uint32 (1<<uint32 (_faf +1))-1;_ggge <<=uint (32-_faf );_aece :=uint32 (1);for _ffd :=0;_ffd < _faf ;_ffd ++{_gcf :=_aece &_cfcg ;
_fac :=uint8 ((uint32 (_ggge )&0x80000000)>>31);if _dcff :=_fgdc .encodeBit (_fgdc ._cag ,_gcf ,_fac );_dcff !=nil {return _dcff ;};_aece =(_aece <<1)|uint32 (_fac );_ggge <<=1;};return nil ;};func (_be *Encoder )rBlock (){if _be ._dfbc >=0{_be .emit ();
};_be ._dfbc ++;_be ._bd =uint8 (_be ._cbc >>20);_be ._cbc &=0xfffff;_be ._bgd =7;};func (_cfe *Encoder )EncodeBitmap (bm *_ca .Bitmap ,duplicateLineRemoval bool )error {_cf .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );
var (_dc ,_bcg uint8 ;_db ,_ab ,_bb uint16 ;_gca ,_dbd ,_gf byte ;_efd ,_ff ,_ge int ;_fg ,_gg []byte ;);for _abf :=0;_abf < bm .Height ;_abf ++{_gca ,_dbd =0,0;if _abf >=2{_gca =bm .Data [(_abf -2)*bm .RowStride ];};if _abf >=1{_dbd =bm .Data [(_abf -1)*bm .RowStride ];
if duplicateLineRemoval {_ff =_abf *bm .RowStride ;_fg =bm .Data [_ff :_ff +bm .RowStride ];_ge =(_abf -1)*bm .RowStride ;_gg =bm .Data [_ge :_ge +bm .RowStride ];if _b .Equal (_fg ,_gg ){_bcg =_dc ^1;_dc =1;}else {_bcg =_dc ;_dc =0;};};};if duplicateLineRemoval {if _eeeb :=_cfe .encodeBit (_cfe ._eebd ,_gc ,_bcg );
_eeeb !=nil {return _eeeb ;};if _dc !=0{continue ;};};_gf =bm .Data [_abf *bm .RowStride ];_db =uint16 (_gca >>5);_ab =uint16 (_dbd >>4);_gca <<=3;_dbd <<=4;_bb =0;for _efd =0;_efd < bm .Width ;_efd ++{_gfa :=uint32 (_db <<11|_ab <<4|_bb );_caf :=(_gf &0x80)>>7;
_bbd :=_cfe .encodeBit (_cfe ._eebd ,_gfa ,_caf );if _bbd !=nil {return _bbd ;};_db <<=1;_ab <<=1;_bb <<=1;_db |=uint16 ((_gca &0x80)>>7);_ab |=uint16 ((_dbd &0x80)>>7);_bb |=uint16 (_caf );_fgd :=_efd %8;_aab :=_efd /8+1;if _fgd ==4&&_abf >=2{_gca =0;
if _aab < bm .RowStride {_gca =bm .Data [(_abf -2)*bm .RowStride +_aab ];};}else {_gca <<=1;};if _fgd ==3&&_abf >=1{_dbd =0;if _aab < bm .RowStride {_dbd =bm .Data [(_abf -1)*bm .RowStride +_aab ];};}else {_dbd <<=1;};if _fgd ==7{_gf =0;if _aab < bm .RowStride {_gf =bm .Data [_abf *bm .RowStride +_aab ];
};}else {_gf <<=1;};_db &=31;_ab &=127;_bb &=15;};};return nil ;};func (_ad *Encoder )Final (){_ad .flush ()};func (_cb *codingContext )mps (_ee uint32 )int {return int (_cb ._aa [_ee ])};var _ _d .WriterTo =&Encoder {};func (_eeg *Encoder )code1 (_fcb *codingContext ,_dfa uint32 ,_gec uint16 ,_ade byte ){if _fcb .mps (_dfa )==1{_eeg .codeMPS (_fcb ,_dfa ,_gec ,_ade );
}else {_eeg .codeLPS (_fcb ,_dfa ,_gec ,_ade );};};var _bg =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};
func (_bce *Encoder )encodeOOB (_cea Class )error {_efb :=_bce ._gb [_cea ];_cab :=_bce .encodeBit (_efb ,1,1);if _cab !=nil {return _cab ;};_cab =_bce .encodeBit (_efb ,3,0);if _cab !=nil {return _cab ;};_cab =_bce .encodeBit (_efb ,6,0);if _cab !=nil {return _cab ;
};_cab =_bce .encodeBit (_efb ,12,0);if _cab !=nil {return _cab ;};return nil ;};func (_cdf *Encoder )dataSize ()int {return _cafb *len (_cdf ._da )+_cdf ._fa };type intEncRangeS struct{_de ,_g int ;_dd ,_ea uint8 ;_a uint16 ;_ae uint8 ;};func (_eed *Encoder )EncodeIAID (symbolCodeLength ,value int )(_eg error ){_cf .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );
if _eg =_eed .encodeIAID (symbolCodeLength ,value );_eg !=nil {return _e .Wrap (_eg ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};func (_dfg *Encoder )codeMPS (_ac *codingContext ,_dff uint32 ,_fab uint16 ,_agec byte ){_dfg ._ef -=_fab ;
if _dfg ._ef &0x8000!=0{_dfg ._cbc +=uint32 (_fab );return ;};if _dfg ._ef < _fab {_dfg ._ef =_fab ;}else {_dfg ._cbc +=uint32 (_fab );};_ac ._gd [_dff ]=_bcfg [_agec ]._bcf ;_dfg .renormalize ();};func (_ggc *Encoder )codeLPS (_efdg *codingContext ,_eef uint32 ,_bdc uint16 ,_ddb byte ){_ggc ._ef -=_bdc ;
if _ggc ._ef < _bdc {_ggc ._cbc +=uint32 (_bdc );}else {_ggc ._ef =_bdc ;};if _bcfg [_ddb ]._bga ==1{_efdg .flipMps (_eef );};_efdg ._gd [_eef ]=_bcfg [_ddb ]._egf ;_ggc .renormalize ();};func _f (_dfb int )*codingContext {return &codingContext {_gd :make ([]byte ,_dfb ),_aa :make ([]byte ,_dfb )};
};func (_gdg *Encoder )code0 (_bfa *codingContext ,_gge uint32 ,_age uint16 ,_fe byte ){if _bfa .mps (_gge )==0{_gdg .codeMPS (_bfa ,_gge ,_age ,_fe );}else {_gdg .codeLPS (_bfa ,_gge ,_age ,_fe );};};const (IAAI Class =iota ;IADH ;IADS ;IADT ;IADW ;IAEX ;
IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);const (_eedf =65536;_cafb =20*1024;);func (_dbc *Encoder )EncodeInteger (proc Class ,value int )(_dg error ){_cf .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );
if _dg =_dbc .encodeInteger (proc ,value );_dg !=nil {return _e .Wrap (_dg ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};type codingContext struct{_gd []byte ;_aa []byte ;};func (_caa *Encoder )Init (){_caa ._eebd =_f (_eedf );
_caa ._ef =0x8000;_caa ._cbc =0;_caa ._bgd =12;_caa ._dfbc =-1;_caa ._bd =0;_caa ._fa =0;_caa ._cff =make ([]byte ,_cafb );for _bc :=0;_bc < len (_caa ._gb );_bc ++{_caa ._gb [_bc ]=_f (512);};_caa ._cag =nil ;};func (_bdg *Encoder )flush (){_bdg .setBits ();
_bdg ._cbc <<=_bdg ._bgd ;_bdg .byteOut ();_bdg ._cbc <<=_bdg ._bgd ;_bdg .byteOut ();_bdg .emit ();if _bdg ._bd !=0xff{_bdg ._dfbc ++;_bdg ._bd =0xff;_bdg .emit ();};_bdg ._dfbc ++;_bdg ._bd =0xac;_bdg ._dfbc ++;_bdg .emit ();};const _gc =0x9b25;func (_ag *codingContext )flipMps (_df uint32 ){_ag ._aa [_df ]=1-_ag ._aa [_df ]};
type Class int ;func (_ce *Encoder )Flush (){_ce ._fa =0;_ce ._da =nil ;_ce ._dfbc =-1};func (_efa *Encoder )emit (){if _efa ._fa ==_cafb {_efa ._da =append (_efa ._da ,_efa ._cff );_efa ._cff =make ([]byte ,_cafb );_efa ._fa =0;};_efa ._cff [_efa ._fa ]=_efa ._bd ;
_efa ._fa ++;};type state struct{_ffef uint16 ;_bcf ,_egf uint8 ;_bga uint8 ;};func (_gdgc *Encoder )renormalize (){for {_gdgc ._ef <<=1;_gdgc ._cbc <<=1;_gdgc ._bgd --;if _gdgc ._bgd ==0{_gdgc .byteOut ();};if (_gdgc ._ef &0x8000)!=0{break ;};};};func (_aga *Encoder )setBits (){_cabe :=_aga ._cbc +uint32 (_aga ._ef );
_aga ._cbc |=0xffff;if _aga ._cbc >=_cabe {_aga ._cbc -=0x8000;};};func (_abc *Encoder )Refine (iTemp ,iTarget *_ca .Bitmap ,ox ,oy int )error {for _ffe :=0;_ffe < iTarget .Height ;_ffe ++{var _adb int ;_fc :=_ffe +oy ;var (_ec ,_gde ,_dea ,_efeg ,_cac uint16 ;
_ggg ,_bge ,_dge ,_bba ,_cdg byte ;);if _fc >=1&&(_fc -1)< iTemp .Height {_ggg =iTemp .Data [(_fc -1)*iTemp .RowStride ];};if _fc >=0&&_fc < iTemp .Height {_bge =iTemp .Data [_fc *iTemp .RowStride ];};if _fc >=-1&&_fc +1< iTemp .Height {_dge =iTemp .Data [(_fc +1)*iTemp .RowStride ];
};if _ffe >=1{_bba =iTarget .Data [(_ffe -1)*iTarget .RowStride ];};_cdg =iTarget .Data [_ffe *iTarget .RowStride ];_cfc :=uint (6+ox );_ec =uint16 (_ggg >>_cfc );_gde =uint16 (_bge >>_cfc );_dea =uint16 (_dge >>_cfc );_efeg =uint16 (_bba >>6);_dfd :=uint (2-ox );
_ggg <<=_dfd ;_bge <<=_dfd ;_dge <<=_dfd ;_bba <<=2;for _adb =0;_adb < iTarget .Width ;_adb ++{_ecd :=(_ec <<10)|(_gde <<7)|(_dea <<4)|(_efeg <<1)|_cac ;_af :=_cdg >>7;_dga :=_abc .encodeBit (_abc ._eebd ,uint32 (_ecd ),_af );if _dga !=nil {return _dga ;
};_ec <<=1;_gde <<=1;_dea <<=1;_efeg <<=1;_ec |=uint16 (_ggg >>7);_gde |=uint16 (_bge >>7);_dea |=uint16 (_dge >>7);_efeg |=uint16 (_bba >>7);_cac =uint16 (_af );_ceg :=_adb %8;_dca :=_adb /8+1;if _ceg ==5+ox {_ggg ,_bge ,_dge =0,0,0;if _dca < iTemp .RowStride &&_fc >=1&&(_fc -1)< iTemp .Height {_ggg =iTemp .Data [(_fc -1)*iTemp .RowStride +_dca ];
};if _dca < iTemp .RowStride &&_fc >=0&&_fc < iTemp .Height {_bge =iTemp .Data [_fc *iTemp .RowStride +_dca ];};if _dca < iTemp .RowStride &&_fc >=-1&&(_fc +1)< iTemp .Height {_dge =iTemp .Data [(_fc +1)*iTemp .RowStride +_dca ];};}else {_ggg <<=1;_bge <<=1;
_dge <<=1;};if _ceg ==5&&_ffe >=1{_bba =0;if _dca < iTarget .RowStride {_bba =iTarget .Data [(_ffe -1)*iTarget .RowStride +_dca ];};}else {_bba <<=1;};if _ceg ==7{_cdg =0;if _dca < iTarget .RowStride {_cdg =iTarget .Data [_ffe *iTarget .RowStride +_dca ];
};}else {_cdg <<=1;};_ec &=7;_gde &=7;_dea &=7;_efeg &=7;};};return nil ;};func (_acg *Encoder )encodeInteger (_ed Class ,_aff int )error {const _fcbf ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";
if _aff > 2000000000||_aff < -2000000000{return _e .Errorf (_fcbf ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_aff );
};_fb :=_acg ._gb [_ed ];_gfd :=uint32 (1);var _fcdd int ;for ;;_fcdd ++{if _bg [_fcdd ]._de <=_aff &&_bg [_fcdd ]._g >=_aff {break ;};};if _aff < 0{_aff =-_aff ;};_aff -=int (_bg [_fcdd ]._a );_def :=_bg [_fcdd ]._dd ;for _dcf :=uint8 (0);_dcf < _bg [_fcdd ]._ea ;
_dcf ++{_cdb :=_def &1;if _aeb :=_acg .encodeBit (_fb ,_gfd ,_cdb );_aeb !=nil {return _e .Wrap (_aeb ,_fcbf ,"");};_def >>=1;if _gfd &0x100> 0{_gfd =(((_gfd <<1)|uint32 (_cdb ))&0x1ff)|0x100;}else {_gfd =(_gfd <<1)|uint32 (_cdb );};};_aff <<=32-_bg [_fcdd ]._ae ;
for _aed :=uint8 (0);_aed < _bg [_fcdd ]._ae ;_aed ++{_fae :=uint8 ((uint32 (_aff )&0x80000000)>>31);if _fea :=_acg .encodeBit (_fb ,_gfd ,_fae );_fea !=nil {return _e .Wrap (_fea ,_fcbf ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");
};_aff <<=1;if _gfd &0x100!=0{_gfd =(((_gfd <<1)|uint32 (_fae ))&0x1ff)|0x100;}else {_gfd =(_gfd <<1)|uint32 (_fae );};};return nil ;};func (_adc *Encoder )lBlock (){if _adc ._dfbc >=0{_adc .emit ();};_adc ._dfbc ++;_adc ._bd =uint8 (_adc ._cbc >>19);_adc ._cbc &=0x7ffff;
_adc ._bgd =8;};func New ()*Encoder {_efe :=&Encoder {};_efe .Init ();return _efe };func (_fcd *Encoder )encodeBit (_ddd *codingContext ,_bcd uint32 ,_aeca uint8 )error {const _afg ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";
_fcd ._eeb ++;if _bcd >=uint32 (len (_ddd ._gd )){return _e .Errorf (_afg ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_bcd );
};_ced :=_ddd ._gd [_bcd ];_bbag :=_ddd .mps (_bcd );_gfg :=_bcfg [_ced ]._ffef ;_cf .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_fcd ._eeb ,_aeca ,_ced ,_bbag ,_gfg ,_fcd ._ef ,_fcd ._cbc ,_fcd ._bgd ,_fcd ._bd ,_fcd ._dfbc );
if _aeca ==0{_fcd .code0 (_ddd ,_bcd ,_gfg ,_ced );}else {_fcd .code1 (_ddd ,_bcd ,_gfg ,_ced );};return nil ;};func (_gcb *Encoder )EncodeOOB (proc Class )(_cd error ){_cf .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );
if _cd =_gcb .encodeOOB (proc );_cd !=nil {return _e .Wrap (_cd ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};func (_eaa *Encoder )byteOut (){if _eaa ._bd ==0xff{_eaa .rBlock ();return ;};if _eaa ._cbc < 0x8000000{_eaa .lBlock ();
return ;};_eaa ._bd ++;if _eaa ._bd !=0xff{_eaa .lBlock ();return ;};_eaa ._cbc &=0x7ffffff;_eaa .rBlock ();};type Encoder struct{_cbc uint32 ;_ef uint16 ;_bgd ,_bd uint8 ;_dfbc int ;_eeb int ;_da [][]byte ;_cff []byte ;_fa int ;_eebd *codingContext ;_gb [13]*codingContext ;
_cag *codingContext ;};var _bcfg =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
func (_ba *Encoder )WriteTo (w _d .Writer )(int64 ,error ){const _ddf ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";var _fcg int64 ;for _ffa ,_adf :=range _ba ._da {_aec ,_aac :=w .Write (_adf );if _aac !=nil {return 0,_e .Wrapf (_aac ,_ddf ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_ffa );
};_fcg +=int64 (_aec );};_ba ._cff =_ba ._cff [:_ba ._fa ];_gggc ,_bf :=w .Write (_ba ._cff );if _bf !=nil {return 0,_e .Wrap (_bf ,_ddf ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_fcg +=int64 (_gggc );return _fcg ,nil ;
};