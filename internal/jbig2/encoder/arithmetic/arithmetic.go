//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_cf "bytes";_b "github.com/unidoc/unipdf/v3/common";_e "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_g "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_a "io";);func (_efa *Encoder )EncodeBitmap (bm *_e .Bitmap ,duplicateLineRemoval bool )error {_b .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );
var (_eb ,_eafc uint8 ;_bef ,_cd ,_efc uint16 ;_ffg ,_ecd ,_ccb byte ;_cfc ,_cef ,_gc int ;_ge ,_geb []byte ;);for _dd :=0;_dd < bm .Height ;_dd ++{_ffg ,_ecd =0,0;if _dd >=2{_ffg =bm .Data [(_dd -2)*bm .RowStride ];};if _dd >=1{_ecd =bm .Data [(_dd -1)*bm .RowStride ];
if duplicateLineRemoval {_cef =_dd *bm .RowStride ;_ge =bm .Data [_cef :_cef +bm .RowStride ];_gc =(_dd -1)*bm .RowStride ;_geb =bm .Data [_gc :_gc +bm .RowStride ];if _cf .Equal (_ge ,_geb ){_eafc =_eb ^1;_eb =1;}else {_eafc =_eb ;_eb =0;};};};if duplicateLineRemoval {if _ee :=_efa .encodeBit (_efa ._gd ,_gdd ,_eafc );
_ee !=nil {return _ee ;};if _eb !=0{continue ;};};_ccb =bm .Data [_dd *bm .RowStride ];_bef =uint16 (_ffg >>5);_cd =uint16 (_ecd >>4);_ffg <<=3;_ecd <<=4;_efc =0;for _cfc =0;_cfc < bm .Width ;_cfc ++{_gbe :=uint32 (_bef <<11|_cd <<4|_efc );_fbg :=(_ccb &0x80)>>7;
_db :=_efa .encodeBit (_efa ._gd ,_gbe ,_fbg );if _db !=nil {return _db ;};_bef <<=1;_cd <<=1;_efc <<=1;_bef |=uint16 ((_ffg &0x80)>>7);_cd |=uint16 ((_ecd &0x80)>>7);_efc |=uint16 (_fbg );_add :=_cfc %8;_de :=_cfc /8+1;if _add ==4&&_dd >=2{_ffg =0;if _de < bm .RowStride {_ffg =bm .Data [(_dd -2)*bm .RowStride +_de ];
};}else {_ffg <<=1;};if _add ==3&&_dd >=1{_ecd =0;if _de < bm .RowStride {_ecd =bm .Data [(_dd -1)*bm .RowStride +_de ];};}else {_ecd <<=1;};if _add ==7{_ccb =0;if _de < bm .RowStride {_ccb =bm .Data [_dd *bm .RowStride +_de ];};}else {_ccb <<=1;};_bef &=31;
_cd &=127;_efc &=15;};};return nil ;};func (_dgb *Encoder )codeMPS (_cab *codingContext ,_bde uint32 ,_cce uint16 ,_aff byte ){_dgb ._ff -=_cce ;if _dgb ._ff &0x8000!=0{_dgb ._fb +=uint32 (_cce );return ;};if _dgb ._ff < _cce {_dgb ._ff =_cce ;}else {_dgb ._fb +=uint32 (_cce );
};_cab ._gb [_bde ]=_eee [_aff ]._eeb ;_dgb .renormalize ();};const (_befg =65536;_ddb =20*1024;);type codingContext struct{_gb []byte ;_gg []byte ;};func (_fdc *Encoder )Refine (iTemp ,iTarget *_e .Bitmap ,ox ,oy int )error {for _ggc :=0;_ggc < iTarget .Height ;
_ggc ++{var _df int ;_fc :=_ggc +oy ;var (_af ,_ga ,_ded ,_dfg ,_ead uint16 ;_ca ,_ccf ,_dcf ,_dfd ,_dcd byte ;);if _fc >=1&&(_fc -1)< iTemp .Height {_ca =iTemp .Data [(_fc -1)*iTemp .RowStride ];};if _fc >=0&&_fc < iTemp .Height {_ccf =iTemp .Data [_fc *iTemp .RowStride ];
};if _fc >=-1&&_fc +1< iTemp .Height {_dcf =iTemp .Data [(_fc +1)*iTemp .RowStride ];};if _ggc >=1{_dfd =iTarget .Data [(_ggc -1)*iTarget .RowStride ];};_dcd =iTarget .Data [_ggc *iTarget .RowStride ];_bcf :=uint (6+ox );_af =uint16 (_ca >>_bcf );_ga =uint16 (_ccf >>_bcf );
_ded =uint16 (_dcf >>_bcf );_dfg =uint16 (_dfd >>6);_ccg :=uint (2-ox );_ca <<=_ccg ;_ccf <<=_ccg ;_dcf <<=_ccg ;_dfd <<=2;for _df =0;_df < iTarget .Width ;_df ++{_dbe :=(_af <<10)|(_ga <<7)|(_ded <<4)|(_dfg <<1)|_ead ;_gbf :=_dcd >>7;_bd :=_fdc .encodeBit (_fdc ._gd ,uint32 (_dbe ),_gbf );
if _bd !=nil {return _bd ;};_af <<=1;_ga <<=1;_ded <<=1;_dfg <<=1;_af |=uint16 (_ca >>7);_ga |=uint16 (_ccf >>7);_ded |=uint16 (_dcf >>7);_dfg |=uint16 (_dfd >>7);_ead =uint16 (_gbf );_acf :=_df %8;_cdf :=_df /8+1;if _acf ==5+ox {_ca ,_ccf ,_dcf =0,0,0;
if _cdf < iTemp .RowStride &&_fc >=1&&(_fc -1)< iTemp .Height {_ca =iTemp .Data [(_fc -1)*iTemp .RowStride +_cdf ];};if _cdf < iTemp .RowStride &&_fc >=0&&_fc < iTemp .Height {_ccf =iTemp .Data [_fc *iTemp .RowStride +_cdf ];};if _cdf < iTemp .RowStride &&_fc >=-1&&(_fc +1)< iTemp .Height {_dcf =iTemp .Data [(_fc +1)*iTemp .RowStride +_cdf ];
};}else {_ca <<=1;_ccf <<=1;_dcf <<=1;};if _acf ==5&&_ggc >=1{_dfd =0;if _cdf < iTarget .RowStride {_dfd =iTarget .Data [(_ggc -1)*iTarget .RowStride +_cdf ];};}else {_dfd <<=1;};if _acf ==7{_dcd =0;if _cdf < iTarget .RowStride {_dcd =iTarget .Data [_ggc *iTarget .RowStride +_cdf ];
};}else {_dcd <<=1;};_af &=7;_ga &=7;_ded &=7;_dfg &=7;};};return nil ;};type intEncRangeS struct{_d ,_f int ;_eaf ,_dg uint8 ;_bf uint16 ;_be uint8 ;};func (_ea Class )String ()string {switch _ea {case IAAI :return "\u0049\u0041\u0041\u0049";case IADH :return "\u0049\u0041\u0044\u0048";
case IADS :return "\u0049\u0041\u0044\u0053";case IADT :return "\u0049\u0041\u0044\u0054";case IADW :return "\u0049\u0041\u0044\u0057";case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";case IAIT :return "\u0049\u0041\u0049\u0054";
case IARDH :return "\u0049\u0041\u0052D\u0048";case IARDW :return "\u0049\u0041\u0052D\u0057";case IARDX :return "\u0049\u0041\u0052D\u0058";case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";
};};type Encoder struct{_fb uint32 ;_ff uint16 ;_cc ,_gbd uint8 ;_da int ;_cff int ;_ad [][]byte ;_fdb []byte ;_bee int ;_gd *codingContext ;_fbf [13]*codingContext ;_cb *codingContext ;};func (_dgg *Encoder )EncodeOOB (proc Class )(_fgf error ){_b .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );
if _fgf =_dgg .encodeOOB (proc );_fgf !=nil {return _g .Wrap (_fgf ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};func (_ec *codingContext )mps (_aa uint32 )int {return int (_ec ._gg [_aa ])};func (_bb *Encoder )WriteTo (w _a .Writer )(int64 ,error ){const _bfa ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";
var _bed int64 ;for _eff ,_dgd :=range _bb ._ad {_acb ,_ccgd :=w .Write (_dgd );if _ccgd !=nil {return 0,_g .Wrapf (_ccgd ,_bfa ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_eff );
};_bed +=int64 (_acb );};_bb ._fdb =_bb ._fdb [:_bb ._bee ];_gca ,_gbb :=w .Write (_bb ._fdb );if _gbb !=nil {return 0,_g .Wrap (_gbb ,_bfa ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_bed +=int64 (_gca );return _bed ,nil ;
};func New ()*Encoder {_fba :=&Encoder {};_fba .Init ();return _fba };func _ac (_bce int )*codingContext {return &codingContext {_gb :make ([]byte ,_bce ),_gg :make ([]byte ,_bce )};};func (_dfb *Encoder )Reset (){_dfb ._ff =0x8000;_dfb ._fb =0;_dfb ._cc =12;
_dfb ._da =-1;_dfb ._gbd =0;_dfb ._cb =nil ;_dfb ._gd =_ac (_befg );};func (_dc *Encoder )Final (){_dc .flush ()};func (_ceg *Encoder )flush (){_ceg .setBits ();_ceg ._fb <<=_ceg ._cc ;_ceg .byteOut ();_ceg ._fb <<=_ceg ._cc ;_ceg .byteOut ();_ceg .emit ();
if _ceg ._gbd !=0xff{_ceg ._da ++;_ceg ._gbd =0xff;_ceg .emit ();};_ceg ._da ++;_ceg ._gbd =0xac;_ceg ._da ++;_ceg .emit ();};const _gdd =0x9b25;func (_bfe *Encoder )encodeBit (_dfgg *codingContext ,_bba uint32 ,_ba uint8 )error {const _ag ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";
_bfe ._cff ++;if _bba >=uint32 (len (_dfgg ._gb )){return _g .Errorf (_ag ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_bba );
};_ddg :=_dfgg ._gb [_bba ];_gae :=_dfgg .mps (_bba );_cfg :=_eee [_ddg ]._dba ;_b .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_bfe ._cff ,_ba ,_ddg ,_gae ,_cfg ,_bfe ._ff ,_bfe ._fb ,_bfe ._cc ,_bfe ._gbd ,_bfe ._da );
if _ba ==0{_bfe .code0 (_dfgg ,_bba ,_cfg ,_ddg );}else {_bfe .code1 (_dfgg ,_bba ,_cfg ,_ddg );};return nil ;};func (_fa *Encoder )dataSize ()int {return _ddb *len (_fa ._ad )+_fa ._bee };type state struct{_dba uint16 ;_eeb ,_cabc uint8 ;_cdcd uint8 ;
};const (IAAI Class =iota ;IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);func (_bbf *Encoder )code1 (_dfdf *codingContext ,_ed uint32 ,_gga uint16 ,_def byte ){if _dfdf .mps (_ed )==1{_bbf .codeMPS (_dfdf ,_ed ,_gga ,_def );
}else {_bbf .codeLPS (_dfdf ,_ed ,_gga ,_def );};};func (_edf *Encoder )encodeOOB (_cfd Class )error {_dcdg :=_edf ._fbf [_cfd ];_cbfb :=_edf .encodeBit (_dcdg ,1,1);if _cbfb !=nil {return _cbfb ;};_cbfb =_edf .encodeBit (_dcdg ,3,0);if _cbfb !=nil {return _cbfb ;
};_cbfb =_edf .encodeBit (_dcdg ,6,0);if _cbfb !=nil {return _cbfb ;};_cbfb =_edf .encodeBit (_dcdg ,12,0);if _cbfb !=nil {return _cbfb ;};return nil ;};var _ef =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};
func (_ccd *Encoder )Init (){_ccd ._gd =_ac (_befg );_ccd ._ff =0x8000;_ccd ._fb =0;_ccd ._cc =12;_ccd ._da =-1;_ccd ._gbd =0;_ccd ._bee =0;_ccd ._fdb =make ([]byte ,_ddb );for _ce :=0;_ce < len (_ccd ._fbf );_ce ++{_ccd ._fbf [_ce ]=_ac (512);};_ccd ._cb =nil ;
};func (_bfb *Encoder )DataSize ()int {return _bfb .dataSize ()};func (_ffc *Encoder )encodeInteger (_bfed Class ,_cfcd int )error {const _bcd ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";if _cfcd > 2000000000||_cfcd < -2000000000{return _g .Errorf (_bcd ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_cfcd );
};_cgc :=_ffc ._fbf [_bfed ];_agb :=uint32 (1);var _fef int ;for ;;_fef ++{if _ef [_fef ]._d <=_cfcd &&_ef [_fef ]._f >=_cfcd {break ;};};if _cfcd < 0{_cfcd =-_cfcd ;};_cfcd -=int (_ef [_fef ]._bf );_ae :=_ef [_fef ]._eaf ;for _eg :=uint8 (0);_eg < _ef [_fef ]._dg ;
_eg ++{_gcag :=_ae &1;if _ebg :=_ffc .encodeBit (_cgc ,_agb ,_gcag );_ebg !=nil {return _g .Wrap (_ebg ,_bcd ,"");};_ae >>=1;if _agb &0x100> 0{_agb =(((_agb <<1)|uint32 (_gcag ))&0x1ff)|0x100;}else {_agb =(_agb <<1)|uint32 (_gcag );};};_cfcd <<=32-_ef [_fef ]._be ;
for _dca :=uint8 (0);_dca < _ef [_fef ]._be ;_dca ++{_ddf :=uint8 ((uint32 (_cfcd )&0x80000000)>>31);if _bea :=_ffc .encodeBit (_cgc ,_agb ,_ddf );_bea !=nil {return _g .Wrap (_bea ,_bcd ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");
};_cfcd <<=1;if _agb &0x100!=0{_agb =(((_agb <<1)|uint32 (_ddf ))&0x1ff)|0x100;}else {_agb =(_agb <<1)|uint32 (_ddf );};};return nil ;};func (_adc *Encoder )Flush (){_adc ._bee =0;_adc ._ad =nil ;_adc ._da =-1};var _eee =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
func (_dff *Encoder )code0 (_dfa *codingContext ,_gbg uint32 ,_dfdc uint16 ,_aaa byte ){if _dfa .mps (_gbg )==0{_dff .codeMPS (_dfa ,_gbg ,_dfdc ,_aaa );}else {_dff .codeLPS (_dfa ,_gbg ,_dfdc ,_aaa );};};func (_daf *Encoder )renormalize (){for {_daf ._ff <<=1;
_daf ._fb <<=1;_daf ._cc --;if _daf ._cc ==0{_daf .byteOut ();};if (_daf ._ff &0x8000)!=0{break ;};};};func (_bc *codingContext )flipMps (_fd uint32 ){_bc ._gg [_fd ]=1-_bc ._gg [_fd ]};var _ _a .WriterTo =&Encoder {};func (_afa *Encoder )emit (){if _afa ._bee ==_ddb {_afa ._ad =append (_afa ._ad ,_afa ._fdb );
_afa ._fdb =make ([]byte ,_ddb );_afa ._bee =0;};_afa ._fdb [_afa ._bee ]=_afa ._gbd ;_afa ._bee ++;};func (_aef *Encoder )lBlock (){if _aef ._da >=0{_aef .emit ();};_aef ._da ++;_aef ._gbd =uint8 (_aef ._fb >>19);_aef ._fb &=0x7ffff;_aef ._cc =8;};func (_efcg *Encoder )byteOut (){if _efcg ._gbd ==0xff{_efcg .rBlock ();
return ;};if _efcg ._fb < 0x8000000{_efcg .lBlock ();return ;};_efcg ._gbd ++;if _efcg ._gbd !=0xff{_efcg .lBlock ();return ;};_efcg ._fb &=0x7ffffff;_efcg .rBlock ();};func (_dedb *Encoder )setBits (){_cad :=_dedb ._fb +uint32 (_dedb ._ff );_dedb ._fb |=0xffff;
if _dedb ._fb >=_cad {_dedb ._fb -=0x8000;};};func (_egd *Encoder )encodeIAID (_egf ,_acfd int )error {if _egd ._cb ==nil {_egd ._cb =_ac (1<<uint (_egf ));};_cbf :=uint32 (1<<uint32 (_egf +1))-1;_acfd <<=uint (32-_egf );_gf :=uint32 (1);for _eag :=0;_eag < _egf ;
_eag ++{_ebb :=_gf &_cbf ;_cdc :=uint8 ((uint32 (_acfd )&0x80000000)>>31);if _bac :=_egd .encodeBit (_egd ._cb ,_ebb ,_cdc );_bac !=nil {return _bac ;};_gf =(_gf <<1)|uint32 (_cdc );_acfd <<=1;};return nil ;};func (_fed *Encoder )codeLPS (_gcg *codingContext ,_ffe uint32 ,_gbbb uint16 ,_bec byte ){_fed ._ff -=_gbbb ;
if _fed ._ff < _gbbb {_fed ._fb +=uint32 (_gbbb );}else {_fed ._ff =_gbbb ;};if _eee [_bec ]._cdcd ==1{_gcg .flipMps (_ffe );};_gcg ._gb [_ffe ]=_eee [_bec ]._cabc ;_fed .renormalize ();};type Class int ;func (_fe *Encoder )EncodeIAID (symbolCodeLength ,value int )(_fg error ){_b .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );
if _fg =_fe .encodeIAID (symbolCodeLength ,value );_fg !=nil {return _g .Wrap (_fg ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};func (_fbc *Encoder )rBlock (){if _fbc ._da >=0{_fbc .emit ();};_fbc ._da ++;_fbc ._gbd =uint8 (_fbc ._fb >>20);
_fbc ._fb &=0xfffff;_fbc ._cc =7;};func (_ab *Encoder )EncodeInteger (proc Class ,value int )(_cg error ){_b .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );
if _cg =_ab .encodeInteger (proc ,value );_cg !=nil {return _g .Wrap (_cg ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};