//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_a "bytes";_f "github.com/unidoc/unipdf/v3/common";_fd "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_ff "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_e "io";);var _ffc =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};
func (_dba *Encoder )lBlock (){if _dba ._cbg >=0{_dba .emit ();};_dba ._cbg ++;_dba ._fab =uint8 (_dba ._d >>19);_dba ._d &=0x7ffff;_dba ._fa =8;};func (_c Class )String ()string {switch _c {case IAAI :return "\u0049\u0041\u0041\u0049";case IADH :return "\u0049\u0041\u0044\u0048";
case IADS :return "\u0049\u0041\u0044\u0053";case IADT :return "\u0049\u0041\u0044\u0054";case IADW :return "\u0049\u0041\u0044\u0057";case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";case IAIT :return "\u0049\u0041\u0049\u0054";
case IARDH :return "\u0049\u0041\u0052D\u0048";case IARDW :return "\u0049\u0041\u0052D\u0057";case IARDX :return "\u0049\u0041\u0052D\u0058";case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";
};};func (_abg *codingContext )flipMps (_bc uint32 ){_abg ._gef [_bc ]=1-_abg ._gef [_bc ]};func (_cdb *Encoder )EncodeIAID (symbolCodeLength ,value int )(_eea error ){_f .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );
if _eea =_cdb .encodeIAID (symbolCodeLength ,value );_eea !=nil {return _ff .Wrap (_eea ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};type intEncRangeS struct{_b ,_cf int ;_bd ,_ge uint8 ;_cb uint16 ;_ab uint8 ;};func New ()*Encoder {_eg :=&Encoder {};
_eg .Init ();return _eg };const _dbe =0x9b25;func _ga (_cd int )*codingContext {return &codingContext {_gc :make ([]byte ,_cd ),_gef :make ([]byte ,_cd )};};func (_bagg *Encoder )codeMPS (_dgc *codingContext ,_cae uint32 ,_cbe uint16 ,_fadb byte ){_bagg ._ae -=_cbe ;
if _bagg ._ae &0x8000!=0{_bagg ._d +=uint32 (_cbe );return ;};if _bagg ._ae < _cbe {_bagg ._ae =_cbe ;}else {_bagg ._d +=uint32 (_cbe );};_dgc ._gc [_cae ]=_gag [_fadb ]._cea ;_bagg .renormalize ();};func (_bef *Encoder )setBits (){_dfcd :=_bef ._d +uint32 (_bef ._ae );
_bef ._d |=0xffff;if _bef ._d >=_dfcd {_bef ._d -=0x8000;};};func (_ebc *Encoder )codeLPS (_gefc *codingContext ,_fdab uint32 ,_agc uint16 ,_bab byte ){_ebc ._ae -=_agc ;if _ebc ._ae < _agc {_ebc ._d +=uint32 (_agc );}else {_ebc ._ae =_agc ;};if _gag [_bab ]._dbega ==1{_gefc .flipMps (_fdab );
};_gefc ._gc [_fdab ]=_gag [_bab ]._afa ;_ebc .renormalize ();};func (_aefc *Encoder )encodeInteger (_edaf Class ,_fbda int )error {const _aba ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";if _fbda > 2000000000||_fbda < -2000000000{return _ff .Errorf (_aba ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_fbda );
};_eae :=_aefc ._gd [_edaf ];_ebaa :=uint32 (1);var _cec int ;for ;;_cec ++{if _ffc [_cec ]._b <=_fbda &&_ffc [_cec ]._cf >=_fbda {break ;};};if _fbda < 0{_fbda =-_fbda ;};_fbda -=int (_ffc [_cec ]._cb );_babd :=_ffc [_cec ]._bd ;for _ccf :=uint8 (0);_ccf < _ffc [_cec ]._ge ;
_ccf ++{_ccb :=_babd &1;if _fec :=_aefc .encodeBit (_eae ,_ebaa ,_ccb );_fec !=nil {return _ff .Wrap (_fec ,_aba ,"");};_babd >>=1;if _ebaa &0x100> 0{_ebaa =(((_ebaa <<1)|uint32 (_ccb ))&0x1ff)|0x100;}else {_ebaa =(_ebaa <<1)|uint32 (_ccb );};};_fbda <<=32-_ffc [_cec ]._ab ;
for _gbe :=uint8 (0);_gbe < _ffc [_cec ]._ab ;_gbe ++{_aaf :=uint8 ((uint32 (_fbda )&0x80000000)>>31);if _adg :=_aefc .encodeBit (_eae ,_ebaa ,_aaf );_adg !=nil {return _ff .Wrap (_adg ,_aba ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");
};_fbda <<=1;if _ebaa &0x100!=0{_ebaa =(((_ebaa <<1)|uint32 (_aaf ))&0x1ff)|0x100;}else {_ebaa =(_ebaa <<1)|uint32 (_aaf );};};return nil ;};func (_fdd *Encoder )Flush (){_fdd ._df =0;_fdd ._dc =nil ;_fdd ._cbg =-1};func (_fdf *Encoder )flush (){_fdf .setBits ();
_fdf ._d <<=_fdf ._fa ;_fdf .byteOut ();_fdf ._d <<=_fdf ._fa ;_fdf .byteOut ();_fdf .emit ();if _fdf ._fab !=0xff{_fdf ._cbg ++;_fdf ._fab =0xff;_fdf .emit ();};_fdf ._cbg ++;_fdf ._fab =0xac;_fdf ._cbg ++;_fdf .emit ();};func (_baa *Encoder )code1 (_cde *codingContext ,_fddd uint32 ,_cbb uint16 ,_cfc byte ){if _cde .mps (_fddd )==1{_baa .codeMPS (_cde ,_fddd ,_cbb ,_cfc );
}else {_baa .codeLPS (_cde ,_fddd ,_cbb ,_cfc );};};func (_bda *Encoder )code0 (_cfb *codingContext ,_cdbf uint32 ,_fga uint16 ,_cfg byte ){if _cfb .mps (_cdbf )==0{_bda .codeMPS (_cfb ,_cdbf ,_fga ,_cfg );}else {_bda .codeLPS (_cfb ,_cdbf ,_fga ,_cfg );
};};func (_edf *Encoder )encodeOOB (_gbf Class )error {_dbd :=_edf ._gd [_gbf ];_aae :=_edf .encodeBit (_dbd ,1,1);if _aae !=nil {return _aae ;};_aae =_edf .encodeBit (_dbd ,3,0);if _aae !=nil {return _aae ;};_aae =_edf .encodeBit (_dbd ,6,0);if _aae !=nil {return _aae ;
};_aae =_edf .encodeBit (_dbd ,12,0);if _aae !=nil {return _aae ;};return nil ;};func (_db *Encoder )DataSize ()int {return _db .dataSize ()};var _ _e .WriterTo =&Encoder {};func (_gada *Encoder )byteOut (){if _gada ._fab ==0xff{_gada .rBlock ();return ;
};if _gada ._d < 0x8000000{_gada .lBlock ();return ;};_gada ._fab ++;if _gada ._fab !=0xff{_gada .lBlock ();return ;};_gada ._d &=0x7ffffff;_gada .rBlock ();};func (_af *Encoder )Reset (){_af ._ae =0x8000;_af ._d =0;_af ._fa =12;_af ._cbg =-1;_af ._fab =0;
_af ._ad =nil ;_af ._fe =_ga (_fac );};func (_eda *Encoder )dataSize ()int {return _feca *len (_eda ._dc )+_eda ._df };type codingContext struct{_gc []byte ;_gef []byte ;};func (_gea *Encoder )encodeIAID (_beg ,_bdf int )error {if _gea ._ad ==nil {_gea ._ad =_ga (1<<uint (_beg ));
};_afe :=uint32 (1<<uint32 (_beg +1))-1;_bdf <<=uint (32-_beg );_dbeg :=uint32 (1);for _eec :=0;_eec < _beg ;_eec ++{_cef :=_dbeg &_afe ;_fcb :=uint8 ((uint32 (_bdf )&0x80000000)>>31);if _bac :=_gea .encodeBit (_gea ._ad ,_cef ,_fcb );_bac !=nil {return _bac ;
};_dbeg =(_dbeg <<1)|uint32 (_fcb );_bdf <<=1;};return nil ;};func (_faba *Encoder )Init (){_faba ._fe =_ga (_fac );_faba ._ae =0x8000;_faba ._d =0;_faba ._fa =12;_faba ._cbg =-1;_faba ._fab =0;_faba ._df =0;_faba ._aa =make ([]byte ,_feca );for _dfa :=0;
_dfa < len (_faba ._gd );_dfa ++{_faba ._gd [_dfa ]=_ga (512);};_faba ._ad =nil ;};func (_fcg *Encoder )emit (){if _fcg ._df ==_feca {_fcg ._dc =append (_fcg ._dc ,_fcg ._aa );_fcg ._aa =make ([]byte ,_feca );_fcg ._df =0;};_fcg ._aa [_fcg ._df ]=_fcg ._fab ;
_fcg ._df ++;};func (_edc *Encoder )WriteTo (w _e .Writer )(int64 ,error ){const _aced ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";var _fda int64 ;for _adbc ,_egb :=range _edc ._dc {_cab ,_ba :=w .Write (_egb );if _ba !=nil {return 0,_ff .Wrapf (_ba ,_aced ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_adbc );
};_fda +=int64 (_cab );};_edc ._aa =_edc ._aa [:_edc ._df ];_aeb ,_bag :=w .Write (_edc ._aa );if _bag !=nil {return 0,_ff .Wrap (_bag ,_aced ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_fda +=int64 (_aeb );return _fda ,nil ;
};func (_dag *Encoder )encodeBit (_fabe *codingContext ,_bde uint32 ,_edg uint8 )error {const _aec ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";_dag ._gg ++;if _bde >=uint32 (len (_fabe ._gc )){return _ff .Errorf (_aec ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_bde );
};_ece :=_fabe ._gc [_bde ];_aef :=_fabe .mps (_bde );_fbd :=_gag [_ece ]._eef ;_f .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_dag ._gg ,_edg ,_ece ,_aef ,_fbd ,_dag ._ae ,_dag ._d ,_dag ._fa ,_dag ._fab ,_dag ._cbg );
if _edg ==0{_dag .code0 (_fabe ,_bde ,_fbd ,_ece );}else {_dag .code1 (_fabe ,_bde ,_fbd ,_ece );};return nil ;};func (_fg *Encoder )Refine (iTemp ,iTarget *_fd .Bitmap ,ox ,oy int )error {for _gb :=0;_gb < iTarget .Height ;_gb ++{var _eb int ;_ca :=_gb +oy ;
var (_dfc ,_bbg ,_ec ,_agg ,_cbc uint16 ;_ddb ,_eba ,_bbgc ,_bf ,_gad byte ;);if _ca >=1&&(_ca -1)< iTemp .Height {_ddb =iTemp .Data [(_ca -1)*iTemp .RowStride ];};if _ca >=0&&_ca < iTemp .Height {_eba =iTemp .Data [_ca *iTemp .RowStride ];};if _ca >=-1&&_ca +1< iTemp .Height {_bbgc =iTemp .Data [(_ca +1)*iTemp .RowStride ];
};if _gb >=1{_bf =iTarget .Data [(_gb -1)*iTarget .RowStride ];};_gad =iTarget .Data [_gb *iTarget .RowStride ];_ace :=uint (6+ox );_dfc =uint16 (_ddb >>_ace );_bbg =uint16 (_eba >>_ace );_ec =uint16 (_bbgc >>_ace );_agg =uint16 (_bf >>6);_cc :=uint (2-ox );
_ddb <<=_cc ;_eba <<=_cc ;_bbgc <<=_cc ;_bf <<=2;for _eb =0;_eb < iTarget .Width ;_eb ++{_bcd :=(_dfc <<10)|(_bbg <<7)|(_ec <<4)|(_agg <<1)|_cbc ;_ed :=_gad >>7;_da :=_fg .encodeBit (_fg ._fe ,uint32 (_bcd ),_ed );if _da !=nil {return _da ;};_dfc <<=1;
_bbg <<=1;_ec <<=1;_agg <<=1;_dfc |=uint16 (_ddb >>7);_bbg |=uint16 (_eba >>7);_ec |=uint16 (_bbgc >>7);_agg |=uint16 (_bf >>7);_cbc =uint16 (_ed );_faf :=_eb %8;_ffcd :=_eb /8+1;if _faf ==5+ox {_ddb ,_eba ,_bbgc =0,0,0;if _ffcd < iTemp .RowStride &&_ca >=1&&(_ca -1)< iTemp .Height {_ddb =iTemp .Data [(_ca -1)*iTemp .RowStride +_ffcd ];
};if _ffcd < iTemp .RowStride &&_ca >=0&&_ca < iTemp .Height {_eba =iTemp .Data [_ca *iTemp .RowStride +_ffcd ];};if _ffcd < iTemp .RowStride &&_ca >=-1&&(_ca +1)< iTemp .Height {_bbgc =iTemp .Data [(_ca +1)*iTemp .RowStride +_ffcd ];};}else {_ddb <<=1;
_eba <<=1;_bbgc <<=1;};if _faf ==5&&_gb >=1{_bf =0;if _ffcd < iTarget .RowStride {_bf =iTarget .Data [(_gb -1)*iTarget .RowStride +_ffcd ];};}else {_bf <<=1;};if _faf ==7{_gad =0;if _ffcd < iTarget .RowStride {_gad =iTarget .Data [_gb *iTarget .RowStride +_ffcd ];
};}else {_gad <<=1;};_dfc &=7;_bbg &=7;_ec &=7;_agg &=7;};};return nil ;};type Encoder struct{_d uint32 ;_ae uint16 ;_fa ,_fab uint8 ;_cbg int ;_gg int ;_dc [][]byte ;_aa []byte ;_df int ;_fe *codingContext ;_gd [13]*codingContext ;_ad *codingContext ;
};type state struct{_eef uint16 ;_cea ,_afa uint8 ;_dbega uint8 ;};const (IAAI Class =iota ;IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);type Class int ;func (_aefa *Encoder )renormalize (){for {_aefa ._ae <<=1;_aefa ._d <<=1;
_aefa ._fa --;if _aefa ._fa ==0{_aefa .byteOut ();};if (_aefa ._ae &0x8000)!=0{break ;};};};func (_ag *Encoder )Final (){_ag .flush ()};func (_gf *Encoder )EncodeInteger (proc Class ,value int )(_abgc error ){_f .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );
if _abgc =_gf .encodeInteger (proc ,value );_abgc !=nil {return _ff .Wrap (_abgc ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};var _gag =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
func (_bgg *Encoder )EncodeBitmap (bm *_fd .Bitmap ,duplicateLineRemoval bool )error {_f .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );
var (_ggf ,_adb uint8 ;_fdg ,_bgc ,_aee uint16 ;_ac ,_dd ,_ee byte ;_bb ,_ce ,_aac int ;_fc ,_bbd []byte ;);for _eeb :=0;_eeb < bm .Height ;_eeb ++{_ac ,_dd =0,0;if _eeb >=2{_ac =bm .Data [(_eeb -2)*bm .RowStride ];};if _eeb >=1{_dd =bm .Data [(_eeb -1)*bm .RowStride ];
if duplicateLineRemoval {_ce =_eeb *bm .RowStride ;_fc =bm .Data [_ce :_ce +bm .RowStride ];_aac =(_eeb -1)*bm .RowStride ;_bbd =bm .Data [_aac :_aac +bm .RowStride ];if _a .Equal (_fc ,_bbd ){_adb =_ggf ^1;_ggf =1;}else {_adb =_ggf ;_ggf =0;};};};if duplicateLineRemoval {if _fad :=_bgg .encodeBit (_bgg ._fe ,_dbe ,_adb );
_fad !=nil {return _fad ;};if _ggf !=0{continue ;};};_ee =bm .Data [_eeb *bm .RowStride ];_fdg =uint16 (_ac >>5);_bgc =uint16 (_dd >>4);_ac <<=3;_dd <<=4;_aee =0;for _bb =0;_bb < bm .Width ;_bb ++{_fb :=uint32 (_fdg <<11|_bgc <<4|_aee );_cfa :=(_ee &0x80)>>7;
_fdb :=_bgg .encodeBit (_bgg ._fe ,_fb ,_cfa );if _fdb !=nil {return _fdb ;};_fdg <<=1;_bgc <<=1;_aee <<=1;_fdg |=uint16 ((_ac &0x80)>>7);_bgc |=uint16 ((_dd &0x80)>>7);_aee |=uint16 (_cfa );_dda :=_bb %8;_ea :=_bb /8+1;if _dda ==4&&_eeb >=2{_ac =0;if _ea < bm .RowStride {_ac =bm .Data [(_eeb -2)*bm .RowStride +_ea ];
};}else {_ac <<=1;};if _dda ==3&&_eeb >=1{_dd =0;if _ea < bm .RowStride {_dd =bm .Data [(_eeb -1)*bm .RowStride +_ea ];};}else {_dd <<=1;};if _dda ==7{_ee =0;if _ea < bm .RowStride {_ee =bm .Data [_eeb *bm .RowStride +_ea ];};}else {_ee <<=1;};_fdg &=31;
_bgc &=127;_aee &=15;};};return nil ;};func (_fde *Encoder )rBlock (){if _fde ._cbg >=0{_fde .emit ();};_fde ._cbg ++;_fde ._fab =uint8 (_fde ._d >>20);_fde ._d &=0xfffff;_fde ._fa =7;};const (_fac =65536;_feca =20*1024;);func (_dca *Encoder )EncodeOOB (proc Class )(_dfaf error ){_f .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );
if _dfaf =_dca .encodeOOB (proc );_dfaf !=nil {return _ff .Wrap (_dfaf ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};func (_be *codingContext )mps (_bg uint32 )int {return int (_be ._gef [_bg ])};