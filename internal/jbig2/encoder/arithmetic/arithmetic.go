//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_e "bytes";_c "github.com/unidoc/unipdf/v3/common";_a "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_d "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_b "io";);func (_cb *codingContext )flipMps (_dd uint32 ){_cb ._f [_dd ]=1-_cb ._f [_dd ]};
func (_cagf *Encoder )encodeIAID (_ecf ,_efe int )error {if _cagf ._ac ==nil {_cagf ._ac =_cbb (1<<uint (_ecf ));};_gebe :=uint32 (1<<uint32 (_ecf +1))-1;_efe <<=uint (32-_ecf );_cdf :=uint32 (1);for _bgae :=0;_bgae < _ecf ;_bgae ++{_gcbg :=_cdf &_gebe ;
_dcf :=uint8 ((uint32 (_efe )&0x80000000)>>31);if _dde :=_cagf .encodeBit (_cagf ._ac ,_gcbg ,_dcf );_dde !=nil {return _dde ;};_cdf =(_cdf <<1)|uint32 (_dcf );_efe <<=1;};return nil ;};var _ _b .WriterTo =&Encoder {};type Class int ;func (_ef *Encoder )encodeInteger (_ggf Class ,_aaag int )error {const _gbf ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";
if _aaag > 2000000000||_aaag < -2000000000{return _d .Errorf (_gbf ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_aaag );
};_bdf :=_ef ._dg [_ggf ];_aef :=uint32 (1);var _ebg int ;for ;;_ebg ++{if _ad [_ebg ]._bf <=_aaag &&_ad [_ebg ]._ab >=_aaag {break ;};};if _aaag < 0{_aaag =-_aaag ;};_aaag -=int (_ad [_ebg ]._gd );_ada :=_ad [_ebg ]._ga ;for _bgb :=uint8 (0);_bgb < _ad [_ebg ]._cg ;
_bgb ++{_dbcc :=_ada &1;if _cbd :=_ef .encodeBit (_bdf ,_aef ,_dbcc );_cbd !=nil {return _d .Wrap (_cbd ,_gbf ,"");};_ada >>=1;if _aef &0x100> 0{_aef =(((_aef <<1)|uint32 (_dbcc ))&0x1ff)|0x100;}else {_aef =(_aef <<1)|uint32 (_dbcc );};};_aaag <<=32-_ad [_ebg ]._bc ;
for _def :=uint8 (0);_def < _ad [_ebg ]._bc ;_def ++{_ebf :=uint8 ((uint32 (_aaag )&0x80000000)>>31);if _defg :=_ef .encodeBit (_bdf ,_aef ,_ebf );_defg !=nil {return _d .Wrap (_defg ,_gbf ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");
};_aaag <<=1;if _aef &0x100!=0{_aef =(((_aef <<1)|uint32 (_ebf ))&0x1ff)|0x100;}else {_aef =(_aef <<1)|uint32 (_ebf );};};return nil ;};func (_cba *Encoder )Refine (iTemp ,iTarget *_a .Bitmap ,ox ,oy int )error {for _bfa :=0;_bfa < iTarget .Height ;_bfa ++{var _bfd int ;
_cgg :=_bfa +oy ;var (_gded ,_bea ,_gbb ,_fd ,_eed uint16 ;_gcb ,_beaf ,_fcb ,_dad ,_aebd byte ;);if _cgg >=1&&(_cgg -1)< iTemp .Height {_gcb =iTemp .Data [(_cgg -1)*iTemp .RowStride ];};if _cgg >=0&&_cgg < iTemp .Height {_beaf =iTemp .Data [_cgg *iTemp .RowStride ];
};if _cgg >=-1&&_cgg +1< iTemp .Height {_fcb =iTemp .Data [(_cgg +1)*iTemp .RowStride ];};if _bfa >=1{_dad =iTarget .Data [(_bfa -1)*iTarget .RowStride ];};_aebd =iTarget .Data [_bfa *iTarget .RowStride ];_ed :=uint (6+ox );_gded =uint16 (_gcb >>_ed );
_bea =uint16 (_beaf >>_ed );_gbb =uint16 (_fcb >>_ed );_fd =uint16 (_dad >>6);_bgac :=uint (2-ox );_gcb <<=_bgac ;_beaf <<=_bgac ;_fcb <<=_bgac ;_dad <<=2;for _bfd =0;_bfd < iTarget .Width ;_bfd ++{_cfe :=(_gded <<10)|(_bea <<7)|(_gbb <<4)|(_fd <<1)|_eed ;
_age :=_aebd >>7;_fe :=_cba .encodeBit (_cba ._ee ,uint32 (_cfe ),_age );if _fe !=nil {return _fe ;};_gded <<=1;_bea <<=1;_gbb <<=1;_fd <<=1;_gded |=uint16 (_gcb >>7);_bea |=uint16 (_beaf >>7);_gbb |=uint16 (_fcb >>7);_fd |=uint16 (_dad >>7);_eed =uint16 (_age );
_gdc :=_bfd %8;_gag :=_bfd /8+1;if _gdc ==5+ox {_gcb ,_beaf ,_fcb =0,0,0;if _gag < iTemp .RowStride &&_cgg >=1&&(_cgg -1)< iTemp .Height {_gcb =iTemp .Data [(_cgg -1)*iTemp .RowStride +_gag ];};if _gag < iTemp .RowStride &&_cgg >=0&&_cgg < iTemp .Height {_beaf =iTemp .Data [_cgg *iTemp .RowStride +_gag ];
};if _gag < iTemp .RowStride &&_cgg >=-1&&(_cgg +1)< iTemp .Height {_fcb =iTemp .Data [(_cgg +1)*iTemp .RowStride +_gag ];};}else {_gcb <<=1;_beaf <<=1;_fcb <<=1;};if _gdc ==5&&_bfa >=1{_dad =0;if _gag < iTarget .RowStride {_dad =iTarget .Data [(_bfa -1)*iTarget .RowStride +_gag ];
};}else {_dad <<=1;};if _gdc ==7{_aebd =0;if _gag < iTarget .RowStride {_aebd =iTarget .Data [_bfa *iTarget .RowStride +_gag ];};}else {_aebd <<=1;};_gded &=7;_bea &=7;_gbb &=7;_fd &=7;};};return nil ;};func (_ebd *Encoder )flush (){_ebd .setBits ();_ebd ._ff <<=_ebd ._gde ;
_ebd .byteOut ();_ebd ._ff <<=_ebd ._gde ;_ebd .byteOut ();_ebd .emit ();if _ebd ._gc !=0xff{_ebd ._cf ++;_ebd ._gc =0xff;_ebd .emit ();};_ebd ._cf ++;_ebd ._gc =0xac;_ebd ._cf ++;_ebd .emit ();};func (_fa *Encoder )EncodeInteger (proc Class ,value int )(_gbd error ){_c .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );
if _gbd =_fa .encodeInteger (proc ,value );_gbd !=nil {return _d .Wrap (_gbd ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};func (_aa Class )String ()string {switch _aa {case IAAI :return "\u0049\u0041\u0041\u0049";
case IADH :return "\u0049\u0041\u0044\u0048";case IADS :return "\u0049\u0041\u0044\u0053";case IADT :return "\u0049\u0041\u0044\u0054";case IADW :return "\u0049\u0041\u0044\u0057";case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";
case IAIT :return "\u0049\u0041\u0049\u0054";case IARDH :return "\u0049\u0041\u0052D\u0048";case IARDW :return "\u0049\u0041\u0052D\u0057";case IARDX :return "\u0049\u0041\u0052D\u0058";case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";
default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";};};func (_dc *codingContext )mps (_ba uint32 )int {return int (_dc ._f [_ba ])};func (_adb *Encoder )code1 (_edd *codingContext ,_dcc uint32 ,_agg uint16 ,_eedg byte ){if _edd .mps (_dcc )==1{_adb .codeMPS (_edd ,_dcc ,_agg ,_eedg );
}else {_adb .codeLPS (_edd ,_dcc ,_agg ,_eedg );};};func (_gad *Encoder )EncodeBitmap (bm *_a .Bitmap ,duplicateLineRemoval bool )error {_c .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );
var (_aec ,_db uint8 ;_bg ,_fg ,_bga uint16 ;_agc ,_fc ,_aaa byte ;_bge ,_acd ,_abd int ;_aeb ,_ce []byte ;);for _de :=0;_de < bm .Height ;_de ++{_agc ,_fc =0,0;if _de >=2{_agc =bm .Data [(_de -2)*bm .RowStride ];};if _de >=1{_fc =bm .Data [(_de -1)*bm .RowStride ];
if duplicateLineRemoval {_acd =_de *bm .RowStride ;_aeb =bm .Data [_acd :_acd +bm .RowStride ];_abd =(_de -1)*bm .RowStride ;_ce =bm .Data [_abd :_abd +bm .RowStride ];if _e .Equal (_aeb ,_ce ){_db =_aec ^1;_aec =1;}else {_db =_aec ;_aec =0;};};};if duplicateLineRemoval {if _fcc :=_gad .encodeBit (_gad ._ee ,_da ,_db );
_fcc !=nil {return _fcc ;};if _aec !=0{continue ;};};_aaa =bm .Data [_de *bm .RowStride ];_bg =uint16 (_agc >>5);_fg =uint16 (_fc >>4);_agc <<=3;_fc <<=4;_bga =0;for _bge =0;_bge < bm .Width ;_bge ++{_be :=uint32 (_bg <<11|_fg <<4|_bga );_aea :=(_aaa &0x80)>>7;
_acc :=_gad .encodeBit (_gad ._ee ,_be ,_aea );if _acc !=nil {return _acc ;};_bg <<=1;_fg <<=1;_bga <<=1;_bg |=uint16 ((_agc &0x80)>>7);_fg |=uint16 ((_fc &0x80)>>7);_bga |=uint16 (_aea );_cag :=_bge %8;_gaa :=_bge /8+1;if _cag ==4&&_de >=2{_agc =0;if _gaa < bm .RowStride {_agc =bm .Data [(_de -2)*bm .RowStride +_gaa ];
};}else {_agc <<=1;};if _cag ==3&&_de >=1{_fc =0;if _gaa < bm .RowStride {_fc =bm .Data [(_de -1)*bm .RowStride +_gaa ];};}else {_fc <<=1;};if _cag ==7{_aaa =0;if _gaa < bm .RowStride {_aaa =bm .Data [_de *bm .RowStride +_gaa ];};}else {_aaa <<=1;};_bg &=31;
_fg &=127;_bga &=15;};};return nil ;};func New ()*Encoder {_df :=&Encoder {};_df .Init ();return _df };var _fac =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
func (_adg *Encoder )Flush (){_adg ._ca =0;_adg ._ddc =nil ;_adg ._cf =-1};func (_gf *Encoder )Final (){_gf .flush ()};func (_acf *Encoder )emit (){if _acf ._ca ==_cc {_acf ._ddc =append (_acf ._ddc ,_acf ._aaf );_acf ._aaf =make ([]byte ,_cc );_acf ._ca =0;
};_acf ._aaf [_acf ._ca ]=_acf ._gc ;_acf ._ca ++;};func (_dbd *Encoder )code0 (_eg *codingContext ,_ffb uint32 ,_ged uint16 ,_ea byte ){if _eg .mps (_ffb )==0{_dbd .codeMPS (_eg ,_ffb ,_ged ,_ea );}else {_dbd .codeLPS (_eg ,_ffb ,_ged ,_ea );};};func (_abf *Encoder )EncodeIAID (symbolCodeLength ,value int )(_gg error ){_c .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );
if _gg =_abf .encodeIAID (symbolCodeLength ,value );_gg !=nil {return _d .Wrap (_gg ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};func (_dcaf *Encoder )rBlock (){if _dcaf ._cf >=0{_dcaf .emit ();};_dcaf ._cf ++;_dcaf ._gc =uint8 (_dcaf ._ff >>20);
_dcaf ._ff &=0xfffff;_dcaf ._gde =7;};func (_gb *Encoder )DataSize ()int {return _gb .dataSize ()};const _da =0x9b25;func (_bag *Encoder )WriteTo (w _b .Writer )(int64 ,error ){const _ffd ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";
var _bgd int64 ;for _caf ,_cd :=range _bag ._ddc {_geb ,_dda :=w .Write (_cd );if _dda !=nil {return 0,_d .Wrapf (_dda ,_ffd ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_caf );
};_bgd +=int64 (_geb );};_bag ._aaf =_bag ._aaf [:_bag ._ca ];_ec ,_eb :=w .Write (_bag ._aaf );if _eb !=nil {return 0,_d .Wrap (_eb ,_ffd ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_bgd +=int64 (_ec );return _bgd ,nil ;
};func (_daf *Encoder )codeLPS (_aac *codingContext ,_cddf uint32 ,_dca uint16 ,_aae byte ){_daf ._ge -=_dca ;if _daf ._ge < _dca {_daf ._ff +=uint32 (_dca );}else {_daf ._ge =_dca ;};if _fac [_aae ]._bad ==1{_aac .flipMps (_cddf );};_aac ._ae [_cddf ]=_fac [_aae ]._eag ;
_daf .renormalize ();};type Encoder struct{_ff uint32 ;_ge uint16 ;_gde ,_gc uint8 ;_cf int ;_bb int ;_ddc [][]byte ;_aaf []byte ;_ca int ;_ee *codingContext ;_dg [13]*codingContext ;_ac *codingContext ;};type intEncRangeS struct{_bf ,_ab int ;_ga ,_cg uint8 ;
_gd uint16 ;_bc uint8 ;};func (_cgga *Encoder )codeMPS (_cga *codingContext ,_gcc uint32 ,_cdd uint16 ,_fae byte ){_cgga ._ge -=_cdd ;if _cgga ._ge &0x8000!=0{_cgga ._ff +=uint32 (_cdd );return ;};if _cgga ._ge < _cdd {_cgga ._ge =_cdd ;}else {_cgga ._ff +=uint32 (_cdd );
};_cga ._ae [_gcc ]=_fac [_fae ]._cgc ;_cgga .renormalize ();};type codingContext struct{_ae []byte ;_f []byte ;};func (_dbc *Encoder )EncodeOOB (proc Class )(_bdg error ){_c .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );
if _bdg =_dbc .encodeOOB (proc );_bdg !=nil {return _d .Wrap (_bdg ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};func _cbb (_ag int )*codingContext {return &codingContext {_ae :make ([]byte ,_ag ),_f :make ([]byte ,_ag )};};var _ad =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};
func (_eee *Encoder )lBlock (){if _eee ._cf >=0{_eee .emit ();};_eee ._cf ++;_eee ._gc =uint8 (_eee ._ff >>19);_eee ._ff &=0x7ffff;_eee ._gde =8;};func (_fb *Encoder )renormalize (){for {_fb ._ge <<=1;_fb ._ff <<=1;_fb ._gde --;if _fb ._gde ==0{_fb .byteOut ();
};if (_fb ._ge &0x8000)!=0{break ;};};};const (IAAI Class =iota ;IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);func (_cec *Encoder )encodeBit (_beg *codingContext ,_eda uint32 ,_fed uint8 )error {const _fdd ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";
_cec ._bb ++;if _eda >=uint32 (len (_beg ._ae )){return _d .Errorf (_fdd ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_eda );
};_bcc :=_beg ._ae [_eda ];_gdg :=_beg .mps (_eda );_bdgg :=_fac [_bcc ]._cbg ;_c .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_cec ._bb ,_fed ,_bcc ,_gdg ,_bdgg ,_cec ._ge ,_cec ._ff ,_cec ._gde ,_cec ._gc ,_cec ._cf );
if _fed ==0{_cec .code0 (_beg ,_eda ,_bdgg ,_bcc );}else {_cec .code1 (_beg ,_eda ,_bdgg ,_bcc );};return nil ;};func (_acdb *Encoder )dataSize ()int {return _cc *len (_acdb ._ddc )+_acdb ._ca };const (_gcg =65536;_cc =20*1024;);func (_bdb *Encoder )byteOut (){if _bdb ._gc ==0xff{_bdb .rBlock ();
return ;};if _bdb ._ff < 0x8000000{_bdb .lBlock ();return ;};_bdb ._gc ++;if _bdb ._gc !=0xff{_bdb .lBlock ();return ;};_bdb ._ff &=0x7ffffff;_bdb .rBlock ();};func (_bd *Encoder )Init (){_bd ._ee =_cbb (_gcg );_bd ._ge =0x8000;_bd ._ff =0;_bd ._gde =12;
_bd ._cf =-1;_bd ._gc =0;_bd ._ca =0;_bd ._aaf =make ([]byte ,_cc );for _acb :=0;_acb < len (_bd ._dg );_acb ++{_bd ._dg [_acb ]=_cbb (512);};_bd ._ac =nil ;};type state struct{_cbg uint16 ;_cgc ,_eag uint8 ;_bad uint8 ;};func (_gac *Encoder )encodeOOB (_agge Class )error {_ggb :=_gac ._dg [_agge ];
_faa :=_gac .encodeBit (_ggb ,1,1);if _faa !=nil {return _faa ;};_faa =_gac .encodeBit (_ggb ,3,0);if _faa !=nil {return _faa ;};_faa =_gac .encodeBit (_ggb ,6,0);if _faa !=nil {return _faa ;};_faa =_gac .encodeBit (_ggb ,12,0);if _faa !=nil {return _faa ;
};return nil ;};func (_gbe *Encoder )Reset (){_gbe ._ge =0x8000;_gbe ._ff =0;_gbe ._gde =12;_gbe ._cf =-1;_gbe ._gc =0;_gbe ._ac =nil ;_gbe ._ee =_cbb (_gcg );};func (_cgae *Encoder )setBits (){_edaa :=_cgae ._ff +uint32 (_cgae ._ge );_cgae ._ff |=0xffff;
if _cgae ._ff >=_edaa {_cgae ._ff -=0x8000;};};