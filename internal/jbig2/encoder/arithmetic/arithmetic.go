//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_b "bytes";_a "github.com/unidoc/unipdf/v3/common";_f "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_cg "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_cc "io";);const _ce =0x9b25;func (_bbga *Encoder )byteOut (){if _bbga ._ec ==0xff{_bbga .rBlock ();
return ;};if _bbga ._fe < 0x8000000{_bbga .lBlock ();return ;};_bbga ._ec ++;if _bbga ._ec !=0xff{_bbga .lBlock ();return ;};_bbga ._fe &=0x7ffffff;_bbga .rBlock ();};func (_bcc *codingContext )flipMps (_dc uint32 ){_bcc ._bc [_dc ]=1-_bcc ._bc [_dc ]};
func (_bgf *Encoder )flush (){_bgf .setBits ();_bgf ._fe <<=_bgf ._acb ;_bgf .byteOut ();_bgf ._fe <<=_bgf ._acb ;_bgf .byteOut ();_bgf .emit ();if _bgf ._ec !=0xff{_bgf ._ece ++;_bgf ._ec =0xff;_bgf .emit ();};_bgf ._ece ++;_bgf ._ec =0xac;_bgf ._ece ++;
_bgf .emit ();};type intEncRangeS struct{_e ,_cgc int ;_d ,_bd uint8 ;_fg uint16 ;_bg uint8 ;};const (_fab =65536;_bcdf =20*1024;);func (_gg *Encoder )encodeInteger (_fec Class ,_def int )error {const _ggb ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";
if _def > 2000000000||_def < -2000000000{return _cg .Errorf (_ggb ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_def );
};_ga :=_gg ._ee [_fec ];_aecc :=uint32 (1);var _gcdc int ;for ;;_gcdc ++{if _ab [_gcdc ]._e <=_def &&_ab [_gcdc ]._cgc >=_def {break ;};};if _def < 0{_def =-_def ;};_def -=int (_ab [_gcdc ]._fg );_ebd :=_ab [_gcdc ]._d ;for _efa :=uint8 (0);_efa < _ab [_gcdc ]._bd ;
_efa ++{_eef :=_ebd &1;if _bdda :=_gg .encodeBit (_ga ,_aecc ,_eef );_bdda !=nil {return _cg .Wrap (_bdda ,_ggb ,"");};_ebd >>=1;if _aecc &0x100> 0{_aecc =(((_aecc <<1)|uint32 (_eef ))&0x1ff)|0x100;}else {_aecc =(_aecc <<1)|uint32 (_eef );};};_def <<=32-_ab [_gcdc ]._bg ;
for _aed :=uint8 (0);_aed < _ab [_gcdc ]._bg ;_aed ++{_gfe :=uint8 ((uint32 (_def )&0x80000000)>>31);if _fdff :=_gg .encodeBit (_ga ,_aecc ,_gfe );_fdff !=nil {return _cg .Wrap (_fdff ,_ggb ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");
};_def <<=1;if _aecc &0x100!=0{_aecc =(((_aecc <<1)|uint32 (_gfe ))&0x1ff)|0x100;}else {_aecc =(_aecc <<1)|uint32 (_gfe );};};return nil ;};func New ()*Encoder {_fb :=&Encoder {};_fb .Init ();return _fb };func (_daa *Encoder )lBlock (){if _daa ._ece >=0{_daa .emit ();
};_daa ._ece ++;_daa ._ec =uint8 (_daa ._fe >>19);_daa ._fe &=0x7ffff;_daa ._acb =8;};func (_dbb *Encoder )EncodeInteger (proc Class ,value int )(_ba error ){_a .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );
if _ba =_dbb .encodeInteger (proc ,value );_ba !=nil {return _cg .Wrap (_ba ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};func (_ccc *Encoder )EncodeOOB (proc Class )(_bf error ){_a .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );
if _bf =_ccc .encodeOOB (proc );_bf !=nil {return _cg .Wrap (_bf ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};var _ _cc .WriterTo =&Encoder {};func (_abd *Encoder )emit (){if _abd ._ad ==_bcdf {_abd ._gc =append (_abd ._gc ,_abd ._dg );
_abd ._dg =make ([]byte ,_bcdf );_abd ._ad =0;};_abd ._dg [_abd ._ad ]=_abd ._ec ;_abd ._ad ++;};func (_eea *Encoder )Reset (){_eea ._cb =0x8000;_eea ._fe =0;_eea ._acb =12;_eea ._ece =-1;_eea ._ec =0;_eea ._cd =nil ;_eea ._eb =_da (_fab );};const (IAAI Class =iota ;
IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);func (_bed *Encoder )rBlock (){if _bed ._ece >=0{_bed .emit ();};_bed ._ece ++;_bed ._ec =uint8 (_bed ._fe >>20);_bed ._fe &=0xfffff;_bed ._acb =7;};func (_fd *codingContext )mps (_gd uint32 )int {return int (_fd ._bc [_gd ])};
func (_afb *Encoder )Refine (iTemp ,iTarget *_f .Bitmap ,ox ,oy int )error {for _cbf :=0;_cbf < iTarget .Height ;_cbf ++{var _ef int ;_fbe :=_cbf +oy ;var (_ae ,_cede ,_dbc ,_dfb ,_de uint16 ;_cgf ,_eff ,_cfa ,_agf ,_bgb byte ;);if _fbe >=1&&(_fbe -1)< iTemp .Height {_cgf =iTemp .Data [(_fbe -1)*iTemp .RowStride ];
};if _fbe >=0&&_fbe < iTemp .Height {_eff =iTemp .Data [_fbe *iTemp .RowStride ];};if _fbe >=-1&&_fbe +1< iTemp .Height {_cfa =iTemp .Data [(_fbe +1)*iTemp .RowStride ];};if _cbf >=1{_agf =iTarget .Data [(_cbf -1)*iTarget .RowStride ];};_bgb =iTarget .Data [_cbf *iTarget .RowStride ];
_fc :=uint (6+ox );_ae =uint16 (_cgf >>_fc );_cede =uint16 (_eff >>_fc );_dbc =uint16 (_cfa >>_fc );_dfb =uint16 (_agf >>6);_dgd :=uint (2-ox );_cgf <<=_dgd ;_eff <<=_dgd ;_cfa <<=_dgd ;_agf <<=2;for _ef =0;_ef < iTarget .Width ;_ef ++{_afc :=(_ae <<10)|(_cede <<7)|(_dbc <<4)|(_dfb <<1)|_de ;
_bccf :=_bgb >>7;_dfg :=_afb .encodeBit (_afb ._eb ,uint32 (_afc ),_bccf );if _dfg !=nil {return _dfg ;};_ae <<=1;_cede <<=1;_dbc <<=1;_dfb <<=1;_ae |=uint16 (_cgf >>7);_cede |=uint16 (_eff >>7);_dbc |=uint16 (_cfa >>7);_dfb |=uint16 (_agf >>7);_de =uint16 (_bccf );
_afa :=_ef %8;_ecb :=_ef /8+1;if _afa ==5+ox {_cgf ,_eff ,_cfa =0,0,0;if _ecb < iTemp .RowStride &&_fbe >=1&&(_fbe -1)< iTemp .Height {_cgf =iTemp .Data [(_fbe -1)*iTemp .RowStride +_ecb ];};if _ecb < iTemp .RowStride &&_fbe >=0&&_fbe < iTemp .Height {_eff =iTemp .Data [_fbe *iTemp .RowStride +_ecb ];
};if _ecb < iTemp .RowStride &&_fbe >=-1&&(_fbe +1)< iTemp .Height {_cfa =iTemp .Data [(_fbe +1)*iTemp .RowStride +_ecb ];};}else {_cgf <<=1;_eff <<=1;_cfa <<=1;};if _afa ==5&&_cbf >=1{_agf =0;if _ecb < iTarget .RowStride {_agf =iTarget .Data [(_cbf -1)*iTarget .RowStride +_ecb ];
};}else {_agf <<=1;};if _afa ==7{_bgb =0;if _ecb < iTarget .RowStride {_bgb =iTarget .Data [_cbf *iTarget .RowStride +_ecb ];};}else {_bgb <<=1;};_ae &=7;_cede &=7;_dbc &=7;_dfb &=7;};};return nil ;};type codingContext struct{_fgf []byte ;_bc []byte ;};
type Encoder struct{_fe uint32 ;_cb uint16 ;_acb ,_ec uint8 ;_ece int ;_fed int ;_gc [][]byte ;_dg []byte ;_ad int ;_eb *codingContext ;_ee [13]*codingContext ;_cd *codingContext ;};func (_aff *Encoder )code1 (_fdf *codingContext ,_dagc uint32 ,_gfc uint16 ,_cdf byte ){if _fdf .mps (_dagc )==1{_aff .codeMPS (_fdf ,_dagc ,_gfc ,_cdf );
}else {_aff .codeLPS (_fdf ,_dagc ,_gfc ,_cdf );};};func (_cfb *Encoder )codeMPS (_ca *codingContext ,_dab uint32 ,_cfg uint16 ,_deb byte ){_cfb ._cb -=_cfg ;if _cfb ._cb &0x8000!=0{_cfb ._fe +=uint32 (_cfg );return ;};if _cfb ._cb < _cfg {_cfb ._cb =_cfg ;
}else {_cfb ._fe +=uint32 (_cfg );};_ca ._fgf [_dab ]=_aede [_deb ]._ebde ;_cfb .renormalize ();};func (_dgf *Encoder )dataSize ()int {return _bcdf *len (_dgf ._gc )+_dgf ._ad };func (_dag *Encoder )DataSize ()int {return _dag .dataSize ()};func _da (_ac int )*codingContext {return &codingContext {_fgf :make ([]byte ,_ac ),_bc :make ([]byte ,_ac )};
};type state struct{_ff uint16 ;_ebde ,_dfgg uint8 ;_dfgd uint8 ;};func (_eab *Encoder )Flush (){_eab ._ad =0;_eab ._gc =nil ;_eab ._ece =-1};var _ab =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};
func (_aba *Encoder )codeLPS (_bcd *codingContext ,_afab uint32 ,_bbd uint16 ,_ceb byte ){_aba ._cb -=_bbd ;if _aba ._cb < _bbd {_aba ._fe +=uint32 (_bbd );}else {_aba ._cb =_bbd ;};if _aede [_ceb ]._dfgd ==1{_bcd .flipMps (_afab );};_bcd ._fgf [_afab ]=_aede [_ceb ]._dfgg ;
_aba .renormalize ();};func (_cgd *Encoder )Final (){_cgd .flush ()};func (_aec *Encoder )WriteTo (w _cc .Writer )(int64 ,error ){const _gca ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";var _deg int64 ;for _cgg ,_bbg :=range _aec ._gc {_bdaa ,_efe :=w .Write (_bbg );
if _efe !=nil {return 0,_cg .Wrapf (_efe ,_gca ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_cgg );};_deg +=int64 (_bdaa );};_aec ._dg =_aec ._dg [:_aec ._ad ];
_cef ,_fee :=w .Write (_aec ._dg );if _fee !=nil {return 0,_cg .Wrap (_fee ,_gca ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_deg +=int64 (_cef );return _deg ,nil ;};func (_ced *Encoder )EncodeBitmap (bm *_f .Bitmap ,duplicateLineRemoval bool )error {_a .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );
var (_dd ,_adc uint8 ;_df ,_fdc ,_bb uint16 ;_db ,_bda ,_ccb byte ;_af ,_gcd ,_ccg int ;_gcb ,_cedb []byte ;);for _ea :=0;_ea < bm .Height ;_ea ++{_db ,_bda =0,0;if _ea >=2{_db =bm .Data [(_ea -2)*bm .RowStride ];};if _ea >=1{_bda =bm .Data [(_ea -1)*bm .RowStride ];
if duplicateLineRemoval {_gcd =_ea *bm .RowStride ;_gcb =bm .Data [_gcd :_gcd +bm .RowStride ];_ccg =(_ea -1)*bm .RowStride ;_cedb =bm .Data [_ccg :_ccg +bm .RowStride ];if _b .Equal (_gcb ,_cedb ){_adc =_dd ^1;_dd =1;}else {_adc =_dd ;_dd =0;};};};if duplicateLineRemoval {if _bgd :=_ced .encodeBit (_ced ._eb ,_ce ,_adc );
_bgd !=nil {return _bgd ;};if _dd !=0{continue ;};};_ccb =bm .Data [_ea *bm .RowStride ];_df =uint16 (_db >>5);_fdc =uint16 (_bda >>4);_db <<=3;_bda <<=4;_bb =0;for _af =0;_af < bm .Width ;_af ++{_gcg :=uint32 (_df <<11|_fdc <<4|_bb );_cee :=(_ccb &0x80)>>7;
_gce :=_ced .encodeBit (_ced ._eb ,_gcg ,_cee );if _gce !=nil {return _gce ;};_df <<=1;_fdc <<=1;_bb <<=1;_df |=uint16 ((_db &0x80)>>7);_fdc |=uint16 ((_bda &0x80)>>7);_bb |=uint16 (_cee );_cf :=_af %8;_fa :=_af /8+1;if _cf ==4&&_ea >=2{_db =0;if _fa < bm .RowStride {_db =bm .Data [(_ea -2)*bm .RowStride +_fa ];
};}else {_db <<=1;};if _cf ==3&&_ea >=1{_bda =0;if _fa < bm .RowStride {_bda =bm .Data [(_ea -1)*bm .RowStride +_fa ];};}else {_bda <<=1;};if _cf ==7{_ccb =0;if _fa < bm .RowStride {_ccb =bm .Data [_ea *bm .RowStride +_fa ];};}else {_ccb <<=1;};_df &=31;
_fdc &=127;_bb &=15;};};return nil ;};func (_gf *Encoder )Init (){_gf ._eb =_da (_fab );_gf ._cb =0x8000;_gf ._fe =0;_gf ._acb =12;_gf ._ece =-1;_gf ._ec =0;_gf ._ad =0;_gf ._dg =make ([]byte ,_bcdf );for _bdd :=0;_bdd < len (_gf ._ee );_bdd ++{_gf ._ee [_bdd ]=_da (512);
};_gf ._cd =nil ;};func (_bcf *Encoder )encodeBit (_dbe *codingContext ,_bgc uint32 ,_eeb uint8 )error {const _bdb ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";_bcf ._fed ++;if _bgc >=uint32 (len (_dbe ._fgf )){return _cg .Errorf (_bdb ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_bgc );
};_efed :=_dbe ._fgf [_bgc ];_gcc :=_dbe .mps (_bgc );_ddfg :=_aede [_efed ]._ff ;_a .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_bcf ._fed ,_eeb ,_efed ,_gcc ,_ddfg ,_bcf ._cb ,_bcf ._fe ,_bcf ._acb ,_bcf ._ec ,_bcf ._ece );
if _eeb ==0{_bcf .code0 (_dbe ,_bgc ,_ddfg ,_efed );}else {_bcf .code1 (_dbe ,_bgc ,_ddfg ,_efed );};return nil ;};func (_gfb *Encoder )encodeOOB (_cde Class )error {_egb :=_gfb ._ee [_cde ];_be :=_gfb .encodeBit (_egb ,1,1);if _be !=nil {return _be ;};
_be =_gfb .encodeBit (_egb ,3,0);if _be !=nil {return _be ;};_be =_gfb .encodeBit (_egb ,6,0);if _be !=nil {return _be ;};_be =_gfb .encodeBit (_egb ,12,0);if _be !=nil {return _be ;};return nil ;};func (_gfee *Encoder )setBits (){_dac :=_gfee ._fe +uint32 (_gfee ._cb );
_gfee ._fe |=0xffff;if _gfee ._fe >=_dac {_gfee ._fe -=0x8000;};};type Class int ;func (_g Class )String ()string {switch _g {case IAAI :return "\u0049\u0041\u0041\u0049";case IADH :return "\u0049\u0041\u0044\u0048";case IADS :return "\u0049\u0041\u0044\u0053";
case IADT :return "\u0049\u0041\u0044\u0054";case IADW :return "\u0049\u0041\u0044\u0057";case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";case IAIT :return "\u0049\u0041\u0049\u0054";case IARDH :return "\u0049\u0041\u0052D\u0048";
case IARDW :return "\u0049\u0041\u0052D\u0057";case IARDX :return "\u0049\u0041\u0052D\u0058";case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";};};var _aede =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
func (_eba *Encoder )EncodeIAID (symbolCodeLength ,value int )(_ag error ){_a .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );
if _ag =_eba .encodeIAID (symbolCodeLength ,value );_ag !=nil {return _cg .Wrap (_ag ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};func (_ecd *Encoder )renormalize (){for {_ecd ._cb <<=1;_ecd ._fe <<=1;_ecd ._acb --;
if _ecd ._acb ==0{_ecd .byteOut ();};if (_ecd ._cb &0x8000)!=0{break ;};};};func (_acbf *Encoder )encodeIAID (_bba ,_gae int )error {if _acbf ._cd ==nil {_acbf ._cd =_da (1<<uint (_bba ));};_ace :=uint32 (1<<uint32 (_bba +1))-1;_gae <<=uint (32-_bba );
_effe :=uint32 (1);for _gb :=0;_gb < _bba ;_gb ++{_afag :=_effe &_ace ;_cdd :=uint8 ((uint32 (_gae )&0x80000000)>>31);if _ggd :=_acbf .encodeBit (_acbf ._cd ,_afag ,_cdd );_ggd !=nil {return _ggd ;};_effe =(_effe <<1)|uint32 (_cdd );_gae <<=1;};return nil ;
};func (_dfga *Encoder )code0 (_cgga *codingContext ,_ddf uint32 ,_eg uint16 ,_bfe byte ){if _cgga .mps (_ddf )==0{_dfga .codeMPS (_cgga ,_ddf ,_eg ,_bfe );}else {_dfga .codeLPS (_cgga ,_ddf ,_eg ,_bfe );};};