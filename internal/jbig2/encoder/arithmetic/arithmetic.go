//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_d "bytes";_g "github.com/unidoc/unipdf/v3/common";_ag "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_f "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_b "io";);func (_gga *Encoder )EncodeIAID (symbolCodeLength ,value int )(_bea error ){_g .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );
if _bea =_gga .encodeIAID (symbolCodeLength ,value );_bea !=nil {return _f .Wrap (_bea ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};func (_af *Encoder )Refine (iTemp ,iTarget *_ag .Bitmap ,ox ,oy int )error {for _ce :=0;
_ce < iTarget .Height ;_ce ++{var _gba int ;_ecd :=_ce +oy ;var (_agb ,_fg ,_efe ,_gf ,_ede uint16 ;_dg ,_ee ,_dgg ,_abe ,_cae byte ;);if _ecd >=1&&(_ecd -1)< iTemp .Height {_dg =iTemp .Data [(_ecd -1)*iTemp .RowStride ];};if _ecd >=0&&_ecd < iTemp .Height {_ee =iTemp .Data [_ecd *iTemp .RowStride ];
};if _ecd >=-1&&_ecd +1< iTemp .Height {_dgg =iTemp .Data [(_ecd +1)*iTemp .RowStride ];};if _ce >=1{_abe =iTarget .Data [(_ce -1)*iTarget .RowStride ];};_cae =iTarget .Data [_ce *iTarget .RowStride ];_cde :=uint (6+ox );_agb =uint16 (_dg >>_cde );_fg =uint16 (_ee >>_cde );
_efe =uint16 (_dgg >>_cde );_gf =uint16 (_abe >>6);_efa :=uint (2-ox );_dg <<=_efa ;_ee <<=_efa ;_dgg <<=_efa ;_abe <<=2;for _gba =0;_gba < iTarget .Width ;_gba ++{_aae :=(_agb <<10)|(_fg <<7)|(_efe <<4)|(_gf <<1)|_ede ;_cf :=_cae >>7;_aec :=_af .encodeBit (_af ._ab ,uint32 (_aae ),_cf );
if _aec !=nil {return _aec ;};_agb <<=1;_fg <<=1;_efe <<=1;_gf <<=1;_agb |=uint16 (_dg >>7);_fg |=uint16 (_ee >>7);_efe |=uint16 (_dgg >>7);_gf |=uint16 (_abe >>7);_ede =uint16 (_cf );_de :=_gba %8;_dbd :=_gba /8+1;if _de ==5+ox {_dg ,_ee ,_dgg =0,0,0;
if _dbd < iTemp .RowStride &&_ecd >=1&&(_ecd -1)< iTemp .Height {_dg =iTemp .Data [(_ecd -1)*iTemp .RowStride +_dbd ];};if _dbd < iTemp .RowStride &&_ecd >=0&&_ecd < iTemp .Height {_ee =iTemp .Data [_ecd *iTemp .RowStride +_dbd ];};if _dbd < iTemp .RowStride &&_ecd >=-1&&(_ecd +1)< iTemp .Height {_dgg =iTemp .Data [(_ecd +1)*iTemp .RowStride +_dbd ];
};}else {_dg <<=1;_ee <<=1;_dgg <<=1;};if _de ==5&&_ce >=1{_abe =0;if _dbd < iTarget .RowStride {_abe =iTarget .Data [(_ce -1)*iTarget .RowStride +_dbd ];};}else {_abe <<=1;};if _de ==7{_cae =0;if _dbd < iTarget .RowStride {_cae =iTarget .Data [_ce *iTarget .RowStride +_dbd ];
};}else {_cae <<=1;};_agb &=7;_fg &=7;_efe &=7;_gf &=7;};};return nil ;};func (_abgc *Encoder )encodeBit (_egc *codingContext ,_acg uint32 ,_dae uint8 )error {const _gab ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";
_abgc ._cc ++;if _acg >=uint32 (len (_egc ._ba )){return _f .Errorf (_gab ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_acg );
};_bee :=_egc ._ba [_acg ];_bed :=_egc .mps (_acg );_bdc :=_gea [_bee ]._fgf ;_g .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_abgc ._cc ,_dae ,_bee ,_bed ,_bdc ,_abgc ._cd ,_abgc ._dc ,_abgc ._fcb ,_abgc ._eg ,_abgc ._gbg );
if _dae ==0{_abgc .code0 (_egc ,_acg ,_bdc ,_bee );}else {_abgc .code1 (_egc ,_acg ,_bdc ,_bee );};return nil ;};func (_agg *codingContext )mps (_c uint32 )int {return int (_agg ._aa [_c ])};func (_da *codingContext )flipMps (_ea uint32 ){_da ._aa [_ea ]=1-_da ._aa [_ea ]};
type Class int ;func (_fef *Encoder )flush (){_fef .setBits ();_fef ._dc <<=_fef ._fcb ;_fef .byteOut ();_fef ._dc <<=_fef ._fcb ;_fef .byteOut ();_fef .emit ();if _fef ._eg !=0xff{_fef ._gbg ++;_fef ._eg =0xff;_fef .emit ();};_fef ._gbg ++;_fef ._eg =0xac;
_fef ._gbg ++;_fef .emit ();};func (_bdd *Encoder )WriteTo (w _b .Writer )(int64 ,error ){const _bad ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";var _aad int64 ;for _ceb ,_dec :=range _bdd ._ef {_agec ,_egb :=w .Write (_dec );
if _egb !=nil {return 0,_f .Wrapf (_egb ,_bad ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_ceb );};_aad +=int64 (_agec );};_bdd ._fd =_bdd ._fd [:_bdd ._df ];
_adb ,_fe :=w .Write (_bdd ._fd );if _fe !=nil {return 0,_f .Wrap (_fe ,_bad ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_aad +=int64 (_adb );return _aad ,nil ;};type state struct{_fgf uint16 ;_dda ,_fec uint8 ;
_gae uint8 ;};func (_fac *Encoder )codeLPS (_eec *codingContext ,_aee uint32 ,_dbe uint16 ,_bfg byte ){_fac ._cd -=_dbe ;if _fac ._cd < _dbe {_fac ._dc +=uint32 (_dbe );}else {_fac ._cd =_dbe ;};if _gea [_bfg ]._gae ==1{_eec .flipMps (_aee );};_eec ._ba [_aee ]=_gea [_bfg ]._fec ;
_fac .renormalize ();};func (_ded *Encoder )code0 (_fa *codingContext ,_fee uint32 ,_fcbe uint16 ,_gd byte ){if _fa .mps (_fee )==0{_ded .codeMPS (_fa ,_fee ,_fcbe ,_gd );}else {_ded .codeLPS (_fa ,_fee ,_fcbe ,_gd );};};func (_bcg *Encoder )setBits (){_fgb :=_bcg ._dc +uint32 (_bcg ._cd );
_bcg ._dc |=0xffff;if _bcg ._dc >=_fgb {_bcg ._dc -=0x8000;};};func (_abf *Encoder )byteOut (){if _abf ._eg ==0xff{_abf .rBlock ();return ;};if _abf ._dc < 0x8000000{_abf .lBlock ();return ;};_abf ._eg ++;if _abf ._eg !=0xff{_abf .lBlock ();return ;};_abf ._dc &=0x7ffffff;
_abf .rBlock ();};func (_ff *Encoder )EncodeBitmap (bm *_ag .Bitmap ,duplicateLineRemoval bool )error {_g .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );
var (_bf ,_bd uint8 ;_eca ,_ecag ,_db uint16 ;_ead ,_bg ,_bdg byte ;_ad ,_abc ,_ae int ;_bcde ,_be []byte ;);for _bab :=0;_bab < bm .Height ;_bab ++{_ead ,_bg =0,0;if _bab >=2{_ead =bm .Data [(_bab -2)*bm .RowStride ];};if _bab >=1{_bg =bm .Data [(_bab -1)*bm .RowStride ];
if duplicateLineRemoval {_abc =_bab *bm .RowStride ;_bcde =bm .Data [_abc :_abc +bm .RowStride ];_ae =(_bab -1)*bm .RowStride ;_be =bm .Data [_ae :_ae +bm .RowStride ];if _d .Equal (_bcde ,_be ){_bd =_bf ^1;_bf =1;}else {_bd =_bf ;_bf =0;};};};if duplicateLineRemoval {if _age :=_ff .encodeBit (_ff ._ab ,_bcd ,_bd );
_age !=nil {return _age ;};if _bf !=0{continue ;};};_bdg =bm .Data [_bab *bm .RowStride ];_eca =uint16 (_ead >>5);_ecag =uint16 (_bg >>4);_ead <<=3;_bg <<=4;_db =0;for _ad =0;_ad < bm .Width ;_ad ++{_fde :=uint32 (_eca <<11|_ecag <<4|_db );_fb :=(_bdg &0x80)>>7;
_ge :=_ff .encodeBit (_ff ._ab ,_fde ,_fb );if _ge !=nil {return _ge ;};_eca <<=1;_ecag <<=1;_db <<=1;_eca |=uint16 ((_ead &0x80)>>7);_ecag |=uint16 ((_bg &0x80)>>7);_db |=uint16 (_fb );_cgf :=_ad %8;_ed :=_ad /8+1;if _cgf ==4&&_bab >=2{_ead =0;if _ed < bm .RowStride {_ead =bm .Data [(_bab -2)*bm .RowStride +_ed ];
};}else {_ead <<=1;};if _cgf ==3&&_bab >=1{_bg =0;if _ed < bm .RowStride {_bg =bm .Data [(_bab -1)*bm .RowStride +_ed ];};}else {_bg <<=1;};if _cgf ==7{_bdg =0;if _ed < bm .RowStride {_bdg =bm .Data [_bab *bm .RowStride +_ed ];};}else {_bdg <<=1;};_eca &=31;
_ecag &=127;_db &=15;};};return nil ;};func (_abg *Encoder )Flush (){_abg ._df =0;_abg ._ef =nil ;_abg ._gbg =-1};func (_efaf *Encoder )dataSize ()int {return _deda *len (_efaf ._ef )+_efaf ._df };type codingContext struct{_ba []byte ;_aa []byte ;};func (_dcb *Encoder )Reset (){_dcb ._cd =0x8000;
_dcb ._dc =0;_dcb ._fcb =12;_dcb ._gbg =-1;_dcb ._eg =0;_dcb ._dag =nil ;_dcb ._ab =_cg (_fcc );};func New ()*Encoder {_dd :=&Encoder {};_dd .Init ();return _dd };func (_ccd *Encoder )encodeOOB (_ade Class )error {_eeb :=_ccd ._ege [_ade ];_daf :=_ccd .encodeBit (_eeb ,1,1);
if _daf !=nil {return _daf ;};_daf =_ccd .encodeBit (_eeb ,3,0);if _daf !=nil {return _daf ;};_daf =_ccd .encodeBit (_eeb ,6,0);if _daf !=nil {return _daf ;};_daf =_ccd .encodeBit (_eeb ,12,0);if _daf !=nil {return _daf ;};return nil ;};var _gb =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};
func (_daa *Encoder )encodeInteger (_feg Class ,_cb int )error {const _ebd ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";if _cb > 2000000000||_cb < -2000000000{return _f .Errorf (_ebd ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_cb );
};_faf :=_daa ._ege [_feg ];_ddg :=uint32 (1);var _edc int ;for ;;_edc ++{if _gb [_edc ]._bb <=_cb &&_gb [_edc ]._ac >=_cb {break ;};};if _cb < 0{_cb =-_cb ;};_cb -=int (_gb [_edc ]._bbg );_ffb :=_gb [_edc ]._e ;for _bcb :=uint8 (0);_bcb < _gb [_edc ]._gg ;
_bcb ++{_fcf :=_ffb &1;if _cdeb :=_daa .encodeBit (_faf ,_ddg ,_fcf );_cdeb !=nil {return _f .Wrap (_cdeb ,_ebd ,"");};_ffb >>=1;if _ddg &0x100> 0{_ddg =(((_ddg <<1)|uint32 (_fcf ))&0x1ff)|0x100;}else {_ddg =(_ddg <<1)|uint32 (_fcf );};};_cb <<=32-_gb [_edc ]._fc ;
for _geg :=uint8 (0);_geg < _gb [_edc ]._fc ;_geg ++{_bdgd :=uint8 ((uint32 (_cb )&0x80000000)>>31);if _fafa :=_daa .encodeBit (_faf ,_ddg ,_bdgd );_fafa !=nil {return _f .Wrap (_fafa ,_ebd ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");
};_cb <<=1;if _ddg &0x100!=0{_ddg =(((_ddg <<1)|uint32 (_bdgd ))&0x1ff)|0x100;}else {_ddg =(_ddg <<1)|uint32 (_bdgd );};};return nil ;};func (_adf *Encoder )encodeIAID (_adg ,_efab int )error {if _adf ._dag ==nil {_adf ._dag =_cg (1<<uint (_adg ));};_ebc :=uint32 (1<<uint32 (_adg +1))-1;
_efab <<=uint (32-_adg );_fegd :=uint32 (1);for _ced :=0;_ced < _adg ;_ced ++{_eae :=_fegd &_ebc ;_fbb :=uint8 ((uint32 (_efab )&0x80000000)>>31);if _ffbf :=_adf .encodeBit (_adf ._dag ,_eae ,_fbb );_ffbf !=nil {return _ffbf ;};_fegd =(_fegd <<1)|uint32 (_fbb );
_efab <<=1;};return nil ;};type Encoder struct{_dc uint32 ;_cd uint16 ;_fcb ,_eg uint8 ;_gbg int ;_cc int ;_ef [][]byte ;_fd []byte ;_df int ;_ab *codingContext ;_ege [13]*codingContext ;_dag *codingContext ;};var _gea =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
func (_fbd *Encoder )renormalize (){for {_fbd ._cd <<=1;_fbd ._dc <<=1;_fbd ._fcb --;if _fbd ._fcb ==0{_fbd .byteOut ();};if (_fbd ._cd &0x8000)!=0{break ;};};};func (_gbf *Encoder )codeMPS (_cfd *codingContext ,_gag uint32 ,_ddd uint16 ,_gbd byte ){_gbf ._cd -=_ddd ;
if _gbf ._cd &0x8000!=0{_gbf ._dc +=uint32 (_ddd );return ;};if _gbf ._cd < _ddd {_gbf ._cd =_ddd ;}else {_gbf ._dc +=uint32 (_ddd );};_cfd ._ba [_gag ]=_gea [_gbd ]._dda ;_gbf .renormalize ();};func (_bc Class )String ()string {switch _bc {case IAAI :return "\u0049\u0041\u0041\u0049";
case IADH :return "\u0049\u0041\u0044\u0048";case IADS :return "\u0049\u0041\u0044\u0053";case IADT :return "\u0049\u0041\u0044\u0054";case IADW :return "\u0049\u0041\u0044\u0057";case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";
case IAIT :return "\u0049\u0041\u0049\u0054";case IARDH :return "\u0049\u0041\u0052D\u0048";case IARDW :return "\u0049\u0041\u0052D\u0057";case IARDX :return "\u0049\u0041\u0052D\u0058";case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";
default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";};};var _ _b .WriterTo =&Encoder {};func (_gaf *Encoder )code1 (_bcdf *codingContext ,_eaa uint32 ,_ggc uint16 ,_bcf byte ){if _bcdf .mps (_eaa )==1{_gaf .codeMPS (_bcdf ,_eaa ,_ggc ,_bcf );}else {_gaf .codeLPS (_bcdf ,_eaa ,_ggc ,_bcf );
};};func (_eda *Encoder )Final (){_eda .flush ()};func (_fgd *Encoder )lBlock (){if _fgd ._gbg >=0{_fgd .emit ();};_fgd ._gbg ++;_fgd ._eg =uint8 (_fgd ._dc >>19);_fgd ._dc &=0x7ffff;_fgd ._fcb =8;};func (_bbgc *Encoder )emit (){if _bbgc ._df ==_deda {_bbgc ._ef =append (_bbgc ._ef ,_bbgc ._fd );
_bbgc ._fd =make ([]byte ,_deda );_bbgc ._df =0;};_bbgc ._fd [_bbgc ._df ]=_bbgc ._eg ;_bbgc ._df ++;};const (IAAI Class =iota ;IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);func (_ddb *Encoder )DataSize ()int {return _ddb .dataSize ()};
func _cg (_ec int )*codingContext {return &codingContext {_ba :make ([]byte ,_ec ),_aa :make ([]byte ,_ec )};};func (_ga *Encoder )Init (){_ga ._ab =_cg (_fcc );_ga ._cd =0x8000;_ga ._dc =0;_ga ._fcb =12;_ga ._gbg =-1;_ga ._eg =0;_ga ._df =0;_ga ._fd =make ([]byte ,_deda );
for _eb :=0;_eb < len (_ga ._ege );_eb ++{_ga ._ege [_eb ]=_cg (512);};_ga ._dag =nil ;};type intEncRangeS struct{_bb ,_ac int ;_e ,_gg uint8 ;_bbg uint16 ;_fc uint8 ;};func (_ccg *Encoder )rBlock (){if _ccg ._gbg >=0{_ccg .emit ();};_ccg ._gbg ++;_ccg ._eg =uint8 (_ccg ._dc >>20);
_ccg ._dc &=0xfffff;_ccg ._fcb =7;};const (_fcc =65536;_deda =20*1024;);const _bcd =0x9b25;func (_ddbf *Encoder )EncodeInteger (proc Class ,value int )(_beg error ){_g .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );
if _beg =_ddbf .encodeInteger (proc ,value );_beg !=nil {return _f .Wrap (_beg ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};func (_ca *Encoder )EncodeOOB (proc Class )(_egg error ){_g .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );
if _egg =_ca .encodeOOB (proc );_egg !=nil {return _f .Wrap (_egg ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};