//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_b "bytes";_fa "github.com/unidoc/unipdf/v3/common";_bf "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_e "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_f "io";);func (_cgd *Encoder )code0 (_dcg *codingContext ,_gbf uint32 ,_ff uint16 ,_fed byte ){if _dcg .mps (_gbf )==0{_cgd .codeMPS (_dcg ,_gbf ,_ff ,_fed );
}else {_cgd .codeLPS (_dcg ,_gbf ,_ff ,_fed );};};func New ()*Encoder {_fb :=&Encoder {};_fb .Init ();return _fb };func (_ead *Encoder )lBlock (){if _ead ._de >=0{_ead .emit ();};_ead ._de ++;_ead ._abe =uint8 (_ead ._gc >>19);_ead ._gc &=0x7ffff;_ead ._eg =8;
};const (IAAI Class =iota ;IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);const _ee =0x9b25;func (_ag *Encoder )code1 (_fba *codingContext ,_eef uint32 ,_aed uint16 ,_bagg byte ){if _fba .mps (_eef )==1{_ag .codeMPS (_fba ,_eef ,_aed ,_bagg );
}else {_ag .codeLPS (_fba ,_eef ,_aed ,_bagg );};};func (_dc *Encoder )Reset (){_dc ._ge =0x8000;_dc ._gc =0;_dc ._eg =12;_dc ._de =-1;_dc ._abe =0;_dc ._cd =nil ;_dc ._def =_g (_cgb );};func (_gf *Encoder )EncodeBitmap (bm *_bf .Bitmap ,duplicateLineRemoval bool )error {_fa .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );
var (_fg ,_dg uint8 ;_abd ,_gb ,_aef uint16 ;_fae ,_cc ,_ga byte ;_fdf ,_ccb ,_cfc int ;_bfb ,_ea []byte ;);for _bbf :=0;_bbf < bm .Height ;_bbf ++{_fae ,_cc =0,0;if _bbf >=2{_fae =bm .Data [(_bbf -2)*bm .RowStride ];};if _bbf >=1{_cc =bm .Data [(_bbf -1)*bm .RowStride ];
if duplicateLineRemoval {_ccb =_bbf *bm .RowStride ;_bfb =bm .Data [_ccb :_ccb +bm .RowStride ];_cfc =(_bbf -1)*bm .RowStride ;_ea =bm .Data [_cfc :_cfc +bm .RowStride ];if _b .Equal (_bfb ,_ea ){_dg =_fg ^1;_fg =1;}else {_dg =_fg ;_fg =0;};};};if duplicateLineRemoval {if _fdc :=_gf .encodeBit (_gf ._def ,_ee ,_dg );
_fdc !=nil {return _fdc ;};if _fg !=0{continue ;};};_ga =bm .Data [_bbf *bm .RowStride ];_abd =uint16 (_fae >>5);_gb =uint16 (_cc >>4);_fae <<=3;_cc <<=4;_aef =0;for _fdf =0;_fdf < bm .Width ;_fdf ++{_bab :=uint32 (_abd <<11|_gb <<4|_aef );_faa :=(_ga &0x80)>>7;
_cfca :=_gf .encodeBit (_gf ._def ,_bab ,_faa );if _cfca !=nil {return _cfca ;};_abd <<=1;_gb <<=1;_aef <<=1;_abd |=uint16 ((_fae &0x80)>>7);_gb |=uint16 ((_cc &0x80)>>7);_aef |=uint16 (_faa );_gd :=_fdf %8;_cg :=_fdf /8+1;if _gd ==4&&_bbf >=2{_fae =0;
if _cg < bm .RowStride {_fae =bm .Data [(_bbf -2)*bm .RowStride +_cg ];};}else {_fae <<=1;};if _gd ==3&&_bbf >=1{_cc =0;if _cg < bm .RowStride {_cc =bm .Data [(_bbf -1)*bm .RowStride +_cg ];};}else {_cc <<=1;};if _gd ==7{_ga =0;if _cg < bm .RowStride {_ga =bm .Data [_bbf *bm .RowStride +_cg ];
};}else {_ga <<=1;};_abd &=31;_gb &=127;_aef &=15;};};return nil ;};var _bce =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
func (_da *codingContext )mps (_ab uint32 )int {return int (_da ._dbf [_ab ])};func (_abg *Encoder )DataSize ()int {return _abg .dataSize ()};func (_ega *Encoder )EncodeOOB (proc Class )(_fef error ){_fa .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );
if _fef =_ega .encodeOOB (proc );_fef !=nil {return _e .Wrap (_fef ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};const (_cgb =65536;_fcg =20*1024;);func (_cb *Encoder )codeMPS (_efd *codingContext ,_gee uint32 ,_egd uint16 ,_fbc byte ){_cb ._ge -=_egd ;
if _cb ._ge &0x8000!=0{_cb ._gc +=uint32 (_egd );return ;};if _cb ._ge < _egd {_cb ._ge =_egd ;}else {_cb ._gc +=uint32 (_egd );};_efd ._db [_gee ]=_bce [_fbc ]._bdd ;_cb .renormalize ();};func (_gaa *Encoder )WriteTo (w _f .Writer )(int64 ,error ){const _adc ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";
var _ebf int64 ;for _defge ,_gef :=range _gaa ._cfb {_fcb ,_add :=w .Write (_gef );if _add !=nil {return 0,_e .Wrapf (_add ,_adc ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_defge );
};_ebf +=int64 (_fcb );};_gaa ._ba =_gaa ._ba [:_gaa ._bb ];_fce ,_gbb :=w .Write (_gaa ._ba );if _gbb !=nil {return 0,_e .Wrap (_gbb ,_adc ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_ebf +=int64 (_fce );return _ebf ,nil ;
};func (_bag *Encoder )EncodeInteger (proc Class ,value int )(_gdd error ){_fa .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );
if _gdd =_bag .encodeInteger (proc ,value );_gdd !=nil {return _e .Wrap (_gdd ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};func (_fbe *Encoder )Refine (iTemp ,iTarget *_bf .Bitmap ,ox ,oy int )error {for _fee :=0;
_fee < iTarget .Height ;_fee ++{var _aee int ;_defg :=_fee +oy ;var (_fcf ,_eee ,_eac ,_dgf ,_gba uint16 ;_gg ,_egg ,_fcc ,_bd ,_bba byte ;);if _defg >=1&&(_defg -1)< iTemp .Height {_gg =iTemp .Data [(_defg -1)*iTemp .RowStride ];};if _defg >=0&&_defg < iTemp .Height {_egg =iTemp .Data [_defg *iTemp .RowStride ];
};if _defg >=-1&&_defg +1< iTemp .Height {_fcc =iTemp .Data [(_defg +1)*iTemp .RowStride ];};if _fee >=1{_bd =iTarget .Data [(_fee -1)*iTarget .RowStride ];};_bba =iTarget .Data [_fee *iTarget .RowStride ];_gfg :=uint (6+ox );_fcf =uint16 (_gg >>_gfg );
_eee =uint16 (_egg >>_gfg );_eac =uint16 (_fcc >>_gfg );_dgf =uint16 (_bd >>6);_eggd :=uint (2-ox );_gg <<=_eggd ;_egg <<=_eggd ;_fcc <<=_eggd ;_bd <<=2;for _aee =0;_aee < iTarget .Width ;_aee ++{_cfd :=(_fcf <<10)|(_eee <<7)|(_eac <<4)|(_dgf <<1)|_gba ;
_acc :=_bba >>7;_aba :=_fbe .encodeBit (_fbe ._def ,uint32 (_cfd ),_acc );if _aba !=nil {return _aba ;};_fcf <<=1;_eee <<=1;_eac <<=1;_dgf <<=1;_fcf |=uint16 (_gg >>7);_eee |=uint16 (_egg >>7);_eac |=uint16 (_fcc >>7);_dgf |=uint16 (_bd >>7);_gba =uint16 (_acc );
_ca :=_aee %8;_df :=_aee /8+1;if _ca ==5+ox {_gg ,_egg ,_fcc =0,0,0;if _df < iTemp .RowStride &&_defg >=1&&(_defg -1)< iTemp .Height {_gg =iTemp .Data [(_defg -1)*iTemp .RowStride +_df ];};if _df < iTemp .RowStride &&_defg >=0&&_defg < iTemp .Height {_egg =iTemp .Data [_defg *iTemp .RowStride +_df ];
};if _df < iTemp .RowStride &&_defg >=-1&&(_defg +1)< iTemp .Height {_fcc =iTemp .Data [(_defg +1)*iTemp .RowStride +_df ];};}else {_gg <<=1;_egg <<=1;_fcc <<=1;};if _ca ==5&&_fee >=1{_bd =0;if _df < iTarget .RowStride {_bd =iTarget .Data [(_fee -1)*iTarget .RowStride +_df ];
};}else {_bd <<=1;};if _ca ==7{_bba =0;if _df < iTarget .RowStride {_bba =iTarget .Data [_fee *iTarget .RowStride +_df ];};}else {_bba <<=1;};_fcf &=7;_eee &=7;_eac &=7;_dgf &=7;};};return nil ;};func (_gac *Encoder )dataSize ()int {return _fcg *len (_gac ._cfb )+_gac ._bb };
type state struct{_gffb uint16 ;_bdd ,_aga uint8 ;_cfdg uint8 ;};func (_dfe *Encoder )codeLPS (_gab *codingContext ,_ggb uint32 ,_afc uint16 ,_fda byte ){_dfe ._ge -=_afc ;if _dfe ._ge < _afc {_dfe ._gc +=uint32 (_afc );}else {_dfe ._ge =_afc ;};if _bce [_fda ]._cfdg ==1{_gab .flipMps (_ggb );
};_gab ._db [_ggb ]=_bce [_fda ]._aga ;_dfe .renormalize ();};func (_cac *Encoder )renormalize (){for {_cac ._ge <<=1;_cac ._gc <<=1;_cac ._eg --;if _cac ._eg ==0{_cac .byteOut ();};if (_cac ._ge &0x8000)!=0{break ;};};};func (_dbe *Encoder )setBits (){_bac :=_dbe ._gc +uint32 (_dbe ._ge );
_dbe ._gc |=0xffff;if _dbe ._gc >=_bac {_dbe ._gc -=0x8000;};};func (_fad Class )String ()string {switch _fad {case IAAI :return "\u0049\u0041\u0041\u0049";case IADH :return "\u0049\u0041\u0044\u0048";case IADS :return "\u0049\u0041\u0044\u0053";case IADT :return "\u0049\u0041\u0044\u0054";
case IADW :return "\u0049\u0041\u0044\u0057";case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";case IAIT :return "\u0049\u0041\u0049\u0054";case IARDH :return "\u0049\u0041\u0052D\u0048";case IARDW :return "\u0049\u0041\u0052D\u0057";
case IARDX :return "\u0049\u0041\u0052D\u0058";case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";};};func (_ffd *Encoder )flush (){_ffd .setBits ();_ffd ._gc <<=_ffd ._eg ;
_ffd .byteOut ();_ffd ._gc <<=_ffd ._eg ;_ffd .byteOut ();_ffd .emit ();if _ffd ._abe !=0xff{_ffd ._de ++;_ffd ._abe =0xff;_ffd .emit ();};_ffd ._de ++;_ffd ._abe =0xac;_ffd ._de ++;_ffd .emit ();};func (_abab *Encoder )encodeBit (_ggc *codingContext ,_eff uint32 ,_dcc uint8 )error {const _be ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";
_abab ._aca ++;if _eff >=uint32 (len (_ggc ._db )){return _e .Errorf (_be ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_eff );
};_bff :=_ggc ._db [_eff ];_dcb :=_ggc .mps (_eff );_efc :=_bce [_bff ]._gffb ;_fa .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_abab ._aca ,_dcc ,_bff ,_dcb ,_efc ,_abab ._ge ,_abab ._gc ,_abab ._eg ,_abab ._abe ,_abab ._de );
if _dcc ==0{_abab .code0 (_ggc ,_eff ,_efc ,_bff );}else {_abab .code1 (_ggc ,_eff ,_efc ,_bff );};return nil ;};type intEncRangeS struct{_c ,_ce int ;_d ,_ad uint8 ;_ac uint16 ;_cf uint8 ;};func _g (_fe int )*codingContext {return &codingContext {_db :make ([]byte ,_fe ),_dbf :make ([]byte ,_fe )};
};func (_fd *Encoder )Init (){_fd ._def =_g (_cgb );_fd ._ge =0x8000;_fd ._gc =0;_fd ._eg =12;_fd ._de =-1;_fd ._abe =0;_fd ._bb =0;_fd ._ba =make ([]byte ,_fcg );for _dae :=0;_dae < len (_fd ._bg );_dae ++{_fd ._bg [_dae ]=_g (512);};_fd ._cd =nil ;};
func (_fc *codingContext )flipMps (_ae uint32 ){_fc ._dbf [_ae ]=1-_fc ._dbf [_ae ]};func (_dgd *Encoder )encodeInteger (_gefb Class ,_gbag int )error {const _efdb ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";
if _gbag > 2000000000||_gbag < -2000000000{return _e .Errorf (_efdb ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_gbag );
};_ddb :=_dgd ._bg [_gefb ];_beb :=uint32 (1);var _gff int ;for ;;_gff ++{if _dd [_gff ]._c <=_gbag &&_dd [_gff ]._ce >=_gbag {break ;};};if _gbag < 0{_gbag =-_gbag ;};_gbag -=int (_dd [_gff ]._ac );_cdg :=_dd [_gff ]._d ;for _afce :=uint8 (0);_afce < _dd [_gff ]._ad ;
_afce ++{_bfff :=_cdg &1;if _fgf :=_dgd .encodeBit (_ddb ,_beb ,_bfff );_fgf !=nil {return _e .Wrap (_fgf ,_efdb ,"");};_cdg >>=1;if _beb &0x100> 0{_beb =(((_beb <<1)|uint32 (_bfff ))&0x1ff)|0x100;}else {_beb =(_beb <<1)|uint32 (_bfff );};};_gbag <<=32-_dd [_gff ]._cf ;
for _bfc :=uint8 (0);_bfc < _dd [_gff ]._cf ;_bfc ++{_gfd :=uint8 ((uint32 (_gbag )&0x80000000)>>31);if _ec :=_dgd .encodeBit (_ddb ,_beb ,_gfd );_ec !=nil {return _e .Wrap (_ec ,_efdb ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");
};_gbag <<=1;if _beb &0x100!=0{_beb =(((_beb <<1)|uint32 (_gfd ))&0x1ff)|0x100;}else {_beb =(_beb <<1)|uint32 (_gfd );};};return nil ;};type Encoder struct{_gc uint32 ;_ge uint16 ;_eg ,_abe uint8 ;_de int ;_aca int ;_cfb [][]byte ;_ba []byte ;_bb int ;
_def *codingContext ;_bg [13]*codingContext ;_cd *codingContext ;};func (_efg *Encoder )encodeIAID (_ecg ,_ed int )error {if _efg ._cd ==nil {_efg ._cd =_g (1<<uint (_ecg ));};_bga :=uint32 (1<<uint32 (_ecg +1))-1;_ed <<=uint (32-_ecg );_fcfg :=uint32 (1);
for _egac :=0;_egac < _ecg ;_egac ++{_gag :=_fcfg &_bga ;_fcba :=uint8 ((uint32 (_ed )&0x80000000)>>31);if _eeg :=_efg .encodeBit (_efg ._cd ,_gag ,_fcba );_eeg !=nil {return _eeg ;};_fcfg =(_fcfg <<1)|uint32 (_fcba );_ed <<=1;};return nil ;};var _ _f .WriterTo =&Encoder {};
func (_cbg *Encoder )emit (){if _cbg ._bb ==_fcg {_cbg ._cfb =append (_cbg ._cfb ,_cbg ._ba );_cbg ._ba =make ([]byte ,_fcg );_cbg ._bb =0;};_cbg ._ba [_cbg ._bb ]=_cbg ._abe ;_cbg ._bb ++;};type Class int ;func (_af *Encoder )byteOut (){if _af ._abe ==0xff{_af .rBlock ();
return ;};if _af ._gc < 0x8000000{_af .lBlock ();return ;};_af ._abe ++;if _af ._abe !=0xff{_af .lBlock ();return ;};_af ._gc &=0x7ffffff;_af .rBlock ();};func (_bbc *Encoder )rBlock (){if _bbc ._de >=0{_bbc .emit ();};_bbc ._de ++;_bbc ._abe =uint8 (_bbc ._gc >>20);
_bbc ._gc &=0xfffff;_bbc ._eg =7;};func (_feb *Encoder )Final (){_feb .flush ()};type codingContext struct{_db []byte ;_dbf []byte ;};func (_eb *Encoder )EncodeIAID (symbolCodeLength ,value int )(_ef error ){_fa .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );
if _ef =_eb .encodeIAID (symbolCodeLength ,value );_ef !=nil {return _e .Wrap (_ef ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};var _dd =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};
func (_bbd *Encoder )Flush (){_bbd ._bb =0;_bbd ._cfb =nil ;_bbd ._de =-1};func (_bfd *Encoder )encodeOOB (_aeg Class )error {_cca :=_bfd ._bg [_aeg ];_eda :=_bfd .encodeBit (_cca ,1,1);if _eda !=nil {return _eda ;};_eda =_bfd .encodeBit (_cca ,3,0);if _eda !=nil {return _eda ;
};_eda =_bfd .encodeBit (_cca ,6,0);if _eda !=nil {return _eda ;};_eda =_bfd .encodeBit (_cca ,12,0);if _eda !=nil {return _eda ;};return nil ;};