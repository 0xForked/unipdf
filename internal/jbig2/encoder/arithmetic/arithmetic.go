//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_f "bytes";_e "github.com/unidoc/unipdf/v3/common";_ea "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_cd "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_fb "io";);type Encoder struct{_edaa uint32 ;_dd uint16 ;_gaa ,_bc uint8 ;_gga int ;_cga int ;_aa [][]byte ;_eg []byte ;_ega int ;_fbd *codingContext ;_ac [13]*codingContext ;_ab *codingContext ;};func (_afbe *Encoder )encodeIAID (_cde ,_ecg int )error {if _afbe ._ab ==nil {_afbe ._ab =_ae (1<<uint (_cde ));};_aag :=uint32 (1<<uint32 (_cde +1))-1;_ecg <<=uint (32-_cde );_bd :=uint32 (1);for _aga :=0;_aga < _cde ;_aga ++{_gda :=_bd &_aag ;_bae :=uint8 ((uint32 (_ecg )&0x80000000)>>31);if _fea :=_afbe .encodeBit (_afbe ._ab ,_gda ,_bae );_fea !=nil {return _fea ;};_bd =(_bd <<1)|uint32 (_bae );_ecg <<=1;};return nil ;};func (_ebd *Encoder )byteOut (){if _ebd ._bc ==0xff{_ebd .rBlock ();return ;};if _ebd ._edaa < 0x8000000{_ebd .lBlock ();return ;};_ebd ._bc ++;if _ebd ._bc !=0xff{_ebd .lBlock ();return ;};_ebd ._edaa &=0x7ffffff;_ebd .rBlock ();};func (_dgd *Encoder )codeLPS (_abf *codingContext ,_ggdd uint32 ,_dbf uint16 ,_affg byte ){_dgd ._dd -=_dbf ;if _dgd ._dd < _dbf {_dgd ._edaa +=uint32 (_dbf );}else {_dgd ._dd =_dbf ;};if _bca [_affg ]._egfd ==1{_abf .flipMps (_ggdd );};_abf ._cg [_ggdd ]=_bca [_affg ]._ggbc ;_dgd .renormalize ();};func (_eb *Encoder )DataSize ()int {return _eb .dataSize ()};const (_add =65536;_beac =20*1024;);func _ae (_gg int )*codingContext {return &codingContext {_cg :make ([]byte ,_gg ),_ead :make ([]byte ,_gg )};};func (_acd *Encoder )EncodeInteger (proc Class ,value int )(_cgb error ){_e .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );if _cgb =_acd .encodeInteger (proc ,value );_cgb !=nil {return _cd .Wrap (_cgb ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};var _g =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};func (_bbd *Encoder )emit (){if _bbd ._ega ==_beac {_bbd ._aa =append (_bbd ._aa ,_bbd ._eg );_bbd ._eg =make ([]byte ,_beac );_bbd ._ega =0;};_bbd ._eg [_bbd ._ega ]=_bbd ._bc ;_bbd ._ega ++;};func (_ccg *Encoder )code0 (_aaeg *codingContext ,_afbb uint32 ,_ec uint16 ,_fef byte ){if _aaeg .mps (_afbb )==0{_ccg .codeMPS (_aaeg ,_afbb ,_ec ,_fef );}else {_ccg .codeLPS (_aaeg ,_afbb ,_ec ,_fef );};};func (_ga *codingContext )flipMps (_b uint32 ){_ga ._ead [_b ]=1-_ga ._ead [_b ]};func (_eee *Encoder )encodeInteger (_dac Class ,_ebg int )error {const _bbg ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";if _ebg > 2000000000||_ebg < -2000000000{return _cd .Errorf (_bbg ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_ebg );};_ddg :=_eee ._ac [_dac ];_ceg :=uint32 (1);var _abd int ;for ;;_abd ++{if _g [_abd ]._ed <=_ebg &&_g [_abd ]._eda >=_ebg {break ;};};if _ebg < 0{_ebg =-_ebg ;};_ebg -=int (_g [_abd ]._da );_dff :=_g [_abd ]._cdg ;for _cfe :=uint8 (0);_cfe < _g [_abd ]._fbf ;_cfe ++{_aca :=_dff &1;if _gef :=_eee .encodeBit (_ddg ,_ceg ,_aca );_gef !=nil {return _cd .Wrap (_gef ,_bbg ,"");};_dff >>=1;if _ceg &0x100> 0{_ceg =(((_ceg <<1)|uint32 (_aca ))&0x1ff)|0x100;}else {_ceg =(_ceg <<1)|uint32 (_aca );};};_ebg <<=32-_g [_abd ]._cc ;for _faa :=uint8 (0);_faa < _g [_abd ]._cc ;_faa ++{_fac :=uint8 ((uint32 (_ebg )&0x80000000)>>31);if _eeb :=_eee .encodeBit (_ddg ,_ceg ,_fac );_eeb !=nil {return _cd .Wrap (_eeb ,_bbg ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");};_ebg <<=1;if _ceg &0x100!=0{_ceg =(((_ceg <<1)|uint32 (_fac ))&0x1ff)|0x100;}else {_ceg =(_ceg <<1)|uint32 (_fac );};};return nil ;};func (_egfg *Encoder )Flush (){_egfg ._ega =0;_egfg ._aa =nil ;_egfg ._gga =-1};type intEncRangeS struct{_ed ,_eda int ;_cdg ,_fbf uint8 ;_da uint16 ;_cc uint8 ;};func (_af *Encoder )Refine (iTemp ,iTarget *_ea .Bitmap ,ox ,oy int )error {for _df :=0;_df < iTarget .Height ;_df ++{var _fc int ;_gd :=_df +oy ;var (_cgbf ,_fde ,_afc ,_fa ,_afb uint16 ;_aff ,_cba ,_edd ,_gae ,_ddf byte ;);if _gd >=1&&(_gd -1)< iTemp .Height {_aff =iTemp .Data [(_gd -1)*iTemp .RowStride ];};if _gd >=0&&_gd < iTemp .Height {_cba =iTemp .Data [_gd *iTemp .RowStride ];};if _gd >=-1&&_gd +1< iTemp .Height {_edd =iTemp .Data [(_gd +1)*iTemp .RowStride ];};if _df >=1{_gae =iTarget .Data [(_df -1)*iTarget .RowStride ];};_ddf =iTarget .Data [_df *iTarget .RowStride ];_fbg :=uint (6+ox );_cgbf =uint16 (_aff >>_fbg );_fde =uint16 (_cba >>_fbg );_afc =uint16 (_edd >>_fbg );_fa =uint16 (_gae >>6);_dbe :=uint (2-ox );_aff <<=_dbe ;_cba <<=_dbe ;_edd <<=_dbe ;_gae <<=2;for _fc =0;_fc < iTarget .Width ;_fc ++{_ba :=(_cgbf <<10)|(_fde <<7)|(_afc <<4)|(_fa <<1)|_afb ;_ccd :=_ddf >>7;_bbf :=_af .encodeBit (_af ._fbd ,uint32 (_ba ),_ccd );if _bbf !=nil {return _bbf ;};_cgbf <<=1;_fde <<=1;_afc <<=1;_fa <<=1;_cgbf |=uint16 (_aff >>7);_fde |=uint16 (_cba >>7);_afc |=uint16 (_edd >>7);_fa |=uint16 (_gae >>7);_afb =uint16 (_ccd );_ged :=_fc %8;_fda :=_fc /8+1;if _ged ==5+ox {_aff ,_cba ,_edd =0,0,0;if _fda < iTemp .RowStride &&_gd >=1&&(_gd -1)< iTemp .Height {_aff =iTemp .Data [(_gd -1)*iTemp .RowStride +_fda ];};if _fda < iTemp .RowStride &&_gd >=0&&_gd < iTemp .Height {_cba =iTemp .Data [_gd *iTemp .RowStride +_fda ];};if _fda < iTemp .RowStride &&_gd >=-1&&(_gd +1)< iTemp .Height {_edd =iTemp .Data [(_gd +1)*iTemp .RowStride +_fda ];};}else {_aff <<=1;_cba <<=1;_edd <<=1;};if _ged ==5&&_df >=1{_gae =0;if _fda < iTarget .RowStride {_gae =iTarget .Data [(_df -1)*iTarget .RowStride +_fda ];};}else {_gae <<=1;};if _ged ==7{_ddf =0;if _fda < iTarget .RowStride {_ddf =iTarget .Data [_df *iTarget .RowStride +_fda ];};}else {_ddf <<=1;};_cgbf &=7;_fde &=7;_afc &=7;_fa &=7;};};return nil ;};type codingContext struct{_cg []byte ;_ead []byte ;};func (_dbfc *Encoder )dataSize ()int {return _beac *len (_dbfc ._aa )+_dbfc ._ega };func (_cceb *Encoder )renormalize (){for {_cceb ._dd <<=1;_cceb ._edaa <<=1;_cceb ._gaa --;if _cceb ._gaa ==0{_cceb .byteOut ();};if (_cceb ._dd &0x8000)!=0{break ;};};};func (_acfg *Encoder )WriteTo (w _fb .Writer )(int64 ,error ){const _ce ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";var _acb int64 ;for _ddc ,_bea :=range _acfg ._aa {_edc ,_de :=w .Write (_bea );if _de !=nil {return 0,_cd .Wrapf (_de ,_ce ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_ddc );};_acb +=int64 (_edc );};_acfg ._eg =_acfg ._eg [:_acfg ._ega ];_gc ,_aab :=w .Write (_acfg ._eg );if _aab !=nil {return 0,_cd .Wrap (_aab ,_ce ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_acb +=int64 (_gc );return _acb ,nil ;};func (_d Class )String ()string {switch _d {case IAAI :return "\u0049\u0041\u0041\u0049";case IADH :return "\u0049\u0041\u0044\u0048";case IADS :return "\u0049\u0041\u0044\u0053";case IADT :return "\u0049\u0041\u0044\u0054";case IADW :return "\u0049\u0041\u0044\u0057";case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";case IAIT :return "\u0049\u0041\u0049\u0054";case IARDH :return "\u0049\u0041\u0052D\u0048";case IARDW :return "\u0049\u0041\u0052D\u0057";case IARDX :return "\u0049\u0041\u0052D\u0058";case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";};};func (_dfe *Encoder )encodeBit (_ecc *codingContext ,_gea uint32 ,_dga uint8 )error {const _fbb ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";_dfe ._cga ++;if _gea >=uint32 (len (_ecc ._cg )){return _cd .Errorf (_fbb ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_gea );};_egaf :=_ecc ._cg [_gea ];_bfd :=_ecc .mps (_gea );_ffe :=_bca [_egaf ]._dfb ;_e .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_dfe ._cga ,_dga ,_egaf ,_bfd ,_ffe ,_dfe ._dd ,_dfe ._edaa ,_dfe ._gaa ,_dfe ._bc ,_dfe ._gga );if _dga ==0{_dfe .code0 (_ecc ,_gea ,_ffe ,_egaf );}else {_dfe .code1 (_ecc ,_gea ,_ffe ,_egaf );};return nil ;};func (_dg *Encoder )EncodeIAID (symbolCodeLength ,value int )(_dda error ){_e .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );if _dda =_dg .encodeIAID (symbolCodeLength ,value );_dda !=nil {return _cd .Wrap (_dda ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};func (_ge *codingContext )mps (_a uint32 )int {return int (_ge ._ead [_a ])};const _gf =0x9b25;type state struct{_dfb uint16 ;_cbe ,_ggbc uint8 ;_egfd uint8 ;};func (_cbad *Encoder )lBlock (){if _cbad ._gga >=0{_cbad .emit ();};_cbad ._gga ++;_cbad ._bc =uint8 (_cbad ._edaa >>19);_cbad ._edaa &=0x7ffff;_cbad ._gaa =8;};func (_fdg *Encoder )Final (){_fdg .flush ()};func (_cf *Encoder )EncodeOOB (proc Class )(_bcf error ){_e .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );if _bcf =_cf .encodeOOB (proc );_bcf !=nil {return _cd .Wrap (_bcf ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};func (_ecb *Encoder )setBits (){_egg :=_ecb ._edaa +uint32 (_ecb ._dd );_ecb ._edaa |=0xffff;if _ecb ._edaa >=_egg {_ecb ._edaa -=0x8000;};};func New ()*Encoder {_ef :=&Encoder {};_ef .Init ();return _ef };func (_acdf *Encoder )encodeOOB (_ggb Class )error {_aef :=_acdf ._ac [_ggb ];_cfc :=_acdf .encodeBit (_aef ,1,1);if _cfc !=nil {return _cfc ;};_cfc =_acdf .encodeBit (_aef ,3,0);if _cfc !=nil {return _cfc ;};_cfc =_acdf .encodeBit (_aef ,6,0);if _cfc !=nil {return _cfc ;};_cfc =_acdf .encodeBit (_aef ,12,0);if _cfc !=nil {return _cfc ;};return nil ;};func (_edg *Encoder )Reset (){_edg ._dd =0x8000;_edg ._edaa =0;_edg ._gaa =12;_edg ._gga =-1;_edg ._bc =0;_edg ._ab =nil ;_edg ._fbd =_ae (_add );};func (_bcc *Encoder )rBlock (){if _bcc ._gga >=0{_bcc .emit ();};_bcc ._gga ++;_bcc ._bc =uint8 (_bcc ._edaa >>20);_bcc ._edaa &=0xfffff;_bcc ._gaa =7;};func (_ad *Encoder )flush (){_ad .setBits ();_ad ._edaa <<=_ad ._gaa ;_ad .byteOut ();_ad ._edaa <<=_ad ._gaa ;_ad .byteOut ();_ad .emit ();if _ad ._bc !=0xff{_ad ._gga ++;_ad ._bc =0xff;_ad .emit ();};_ad ._gga ++;_ad ._bc =0xac;_ad ._gga ++;_ad .emit ();};type Class int ;func (_dea *Encoder )code1 (_fdc *codingContext ,_edb uint32 ,_egd uint16 ,_ag byte ){if _fdc .mps (_edb )==1{_dea .codeMPS (_fdc ,_edb ,_egd ,_ag );}else {_dea .codeLPS (_fdc ,_edb ,_egd ,_ag );};};var _bca =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};func (_acf *Encoder )EncodeBitmap (bm *_ea .Bitmap ,duplicateLineRemoval bool )error {_e .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );var (_gee ,_bb uint8 ;_be ,_bf ,_efg uint16 ;_dc ,_bff ,_edf byte ;_fdd ,_aae ,_bg int ;_fg ,_efb []byte ;);for _fgg :=0;_fgg < bm .Height ;_fgg ++{_dc ,_bff =0,0;if _fgg >=2{_dc =bm .Data [(_fgg -2)*bm .RowStride ];};if _fgg >=1{_bff =bm .Data [(_fgg -1)*bm .RowStride ];if duplicateLineRemoval {_aae =_fgg *bm .RowStride ;_fg =bm .Data [_aae :_aae +bm .RowStride ];_bg =(_fgg -1)*bm .RowStride ;_efb =bm .Data [_bg :_bg +bm .RowStride ];if _f .Equal (_fg ,_efb ){_bb =_gee ^1;_gee =1;}else {_bb =_gee ;_gee =0;};};};if duplicateLineRemoval {if _ccf :=_acf .encodeBit (_acf ._fbd ,_gf ,_bb );_ccf !=nil {return _ccf ;};if _gee !=0{continue ;};};_edf =bm .Data [_fgg *bm .RowStride ];_be =uint16 (_dc >>5);_bf =uint16 (_bff >>4);_dc <<=3;_bff <<=4;_efg =0;for _fdd =0;_fdd < bm .Width ;_fdd ++{_egf :=uint32 (_be <<11|_bf <<4|_efg );_ff :=(_edf &0x80)>>7;_gad :=_acf .encodeBit (_acf ._fbd ,_egf ,_ff );if _gad !=nil {return _gad ;};_be <<=1;_bf <<=1;_efg <<=1;_be |=uint16 ((_dc &0x80)>>7);_bf |=uint16 ((_bff &0x80)>>7);_efg |=uint16 (_ff );_db :=_fdd %8;_cb :=_fdd /8+1;if _db ==4&&_fgg >=2{_dc =0;if _cb < bm .RowStride {_dc =bm .Data [(_fgg -2)*bm .RowStride +_cb ];};}else {_dc <<=1;};if _db ==3&&_fgg >=1{_bff =0;if _cb < bm .RowStride {_bff =bm .Data [(_fgg -1)*bm .RowStride +_cb ];};}else {_bff <<=1;};if _db ==7{_edf =0;if _cb < bm .RowStride {_edf =bm .Data [_fgg *bm .RowStride +_cb ];};}else {_edf <<=1;};_be &=31;_bf &=127;_efg &=15;};};return nil ;};const (IAAI Class =iota ;IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);var _ _fb .WriterTo =&Encoder {};func (_fefc *Encoder )codeMPS (_cce *codingContext ,_gcb uint32 ,_fab uint16 ,_ggd byte ){_fefc ._dd -=_fab ;if _fefc ._dd &0x8000!=0{_fefc ._edaa +=uint32 (_fab );return ;};if _fefc ._dd < _fab {_fefc ._dd =_fab ;}else {_fefc ._edaa +=uint32 (_fab );};_cce ._cg [_gcb ]=_bca [_ggd ]._cbe ;_fefc .renormalize ();};func (_fe *Encoder )Init (){_fe ._fbd =_ae (_add );_fe ._dd =0x8000;_fe ._edaa =0;_fe ._gaa =12;_fe ._gga =-1;_fe ._bc =0;_fe ._ega =0;_fe ._eg =make ([]byte ,_beac );for _fd :=0;_fd < len (_fe ._ac );_fd ++{_fe ._ac [_fd ]=_ae (512);};_fe ._ab =nil ;};