//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_g "bytes";_b "github.com/unidoc/unipdf/v3/common";_e "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_f "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_cg "io";);func (_ede *Encoder )codeMPS (_gdf *codingContext ,_fec uint32 ,_dbg uint16 ,_dba byte ){_ede ._gb -=_dbg ;if _ede ._gb &0x8000!=0{_ede ._gf +=uint32 (_dbg );return ;};if _ede ._gb < _dbg {_ede ._gb =_dbg ;}else {_ede ._gf +=uint32 (_dbg );};_gdf ._dg [_fec ]=_cgc [_dba ]._aef ;_ede .renormalize ();};func (_a Class )String ()string {switch _a {case IAAI :return "\u0049\u0041\u0041\u0049";case IADH :return "\u0049\u0041\u0044\u0048";case IADS :return "\u0049\u0041\u0044\u0053";case IADT :return "\u0049\u0041\u0044\u0054";case IADW :return "\u0049\u0041\u0044\u0057";case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";case IAIT :return "\u0049\u0041\u0049\u0054";case IARDH :return "\u0049\u0041\u0052D\u0048";case IARDW :return "\u0049\u0041\u0052D\u0057";case IARDX :return "\u0049\u0041\u0052D\u0058";case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";};};func (_adf *Encoder )encodeOOB (_gea Class )error {_adbf :=_adf ._eg [_gea ];_deda :=_adf .encodeBit (_adbf ,1,1);if _deda !=nil {return _deda ;};_deda =_adf .encodeBit (_adbf ,3,0);if _deda !=nil {return _deda ;};_deda =_adf .encodeBit (_adbf ,6,0);if _deda !=nil {return _deda ;};_deda =_adf .encodeBit (_adbf ,12,0);if _deda !=nil {return _deda ;};return nil ;};func (_dbb *Encoder )encodeIAID (_bcg ,_ccbe int )error {if _dbb ._gg ==nil {_dbb ._gg =_ff (1<<uint (_bcg ));};_gba :=uint32 (1<<uint32 (_bcg +1))-1;_ccbe <<=uint (32-_bcg );_gac :=uint32 (1);for _eea :=0;_eea < _bcg ;_eea ++{_egfg :=_gac &_gba ;_eae :=uint8 ((uint32 (_ccbe )&0x80000000)>>31);if _beg :=_dbb .encodeBit (_dbb ._gg ,_egfg ,_eae );_beg !=nil {return _beg ;};_gac =(_gac <<1)|uint32 (_eae );_ccbe <<=1;};return nil ;};func New ()*Encoder {_bce :=&Encoder {};_bce .Init ();return _bce };func (_eb *codingContext )flipMps (_ab uint32 ){_eb ._cd [_ab ]=1-_eb ._cd [_ab ]};func (_fg *Encoder )Init (){_fg ._ffg =_ff (_ebf );_fg ._gb =0x8000;_fg ._gf =0;_fg ._abd =12;_fg ._ag =-1;_fg ._bc =0;_fg ._fc =0;_fg ._aa =make ([]byte ,_bgb );for _gbe :=0;_gbe < len (_fg ._eg );_gbe ++{_fg ._eg [_gbe ]=_ff (512);};_fg ._gg =nil ;};var _ccb =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};func (_cbg *Encoder )renormalize (){for {_cbg ._gb <<=1;_cbg ._gf <<=1;_cbg ._abd --;if _cbg ._abd ==0{_cbg .byteOut ();};if (_cbg ._gb &0x8000)!=0{break ;};};};func (_fa *Encoder )EncodeInteger (proc Class ,value int )(_bdd error ){_b .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );if _bdd =_fa .encodeInteger (proc ,value );_bdd !=nil {return _f .Wrap (_bdd ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};func (_cdf *Encoder )EncodeOOB (proc Class )(_ed error ){_b .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );if _ed =_cdf .encodeOOB (proc );_ed !=nil {return _f .Wrap (_ed ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};func (_dec *Encoder )EncodeIAID (symbolCodeLength ,value int )(_age error ){_b .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );if _age =_dec .encodeIAID (symbolCodeLength ,value );_age !=nil {return _f .Wrap (_age ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};type Encoder struct{_gf uint32 ;_gb uint16 ;_abd ,_bc uint8 ;_ag int ;_gd int ;_bg [][]byte ;_aa []byte ;_fc int ;_ffg *codingContext ;_eg [13]*codingContext ;_gg *codingContext ;};func (_ebc *Encoder )encodeInteger (_efd Class ,_bbf int )error {const _acc ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";if _bbf > 2000000000||_bbf < -2000000000{return _f .Errorf (_acc ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_bbf );};_cae :=_ebc ._eg [_efd ];_gcc :=uint32 (1);var _bfb int ;for ;;_bfb ++{if _ccb [_bfb ]._bf <=_bbf &&_ccb [_bfb ]._ga >=_bbf {break ;};};if _bbf < 0{_bbf =-_bbf ;};_bbf -=int (_ccb [_bfb ]._cf );_geb :=_ccb [_bfb ]._bd ;for _eef :=uint8 (0);_eef < _ccb [_bfb ]._d ;_eef ++{_dcc :=_geb &1;if _df :=_ebc .encodeBit (_cae ,_gcc ,_dcc );_df !=nil {return _f .Wrap (_df ,_acc ,"");};_geb >>=1;if _gcc &0x100> 0{_gcc =(((_gcc <<1)|uint32 (_dcc ))&0x1ff)|0x100;}else {_gcc =(_gcc <<1)|uint32 (_dcc );};};_bbf <<=32-_ccb [_bfb ]._cc ;for _dbdc :=uint8 (0);_dbdc < _ccb [_bfb ]._cc ;_dbdc ++{_ggf :=uint8 ((uint32 (_bbf )&0x80000000)>>31);if _bdg :=_ebc .encodeBit (_cae ,_gcc ,_ggf );_bdg !=nil {return _f .Wrap (_bdg ,_acc ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");};_bbf <<=1;if _gcc &0x100!=0{_gcc =(((_gcc <<1)|uint32 (_ggf ))&0x1ff)|0x100;}else {_gcc =(_gcc <<1)|uint32 (_ggf );};};return nil ;};func (_cfe *Encoder )emit (){if _cfe ._fc ==_bgb {_cfe ._bg =append (_cfe ._bg ,_cfe ._aa );_cfe ._aa =make ([]byte ,_bgb );_cfe ._fc =0;};_cfe ._aa [_cfe ._fc ]=_cfe ._bc ;_cfe ._fc ++;};func (_egf *Encoder )Reset (){_egf ._gb =0x8000;_egf ._gf =0;_egf ._abd =12;_egf ._ag =-1;_egf ._bc =0;_egf ._gg =nil ;_egf ._ffg =_ff (_ebf );};func (_agc *Encoder )Refine (iTemp ,iTarget *_e .Bitmap ,ox ,oy int )error {for _ggc :=0;_ggc < iTarget .Height ;_ggc ++{var _cfc int ;_cgd :=_ggc +oy ;var (_dgf ,_ded ,_be ,_gbc ,_fac uint16 ;_ge ,_dgc ,_cgg ,_ade ,_bde byte ;);if _cgd >=1&&(_cgd -1)< iTemp .Height {_ge =iTemp .Data [(_cgd -1)*iTemp .RowStride ];};if _cgd >=0&&_cgd < iTemp .Height {_dgc =iTemp .Data [_cgd *iTemp .RowStride ];};if _cgd >=-1&&_cgd +1< iTemp .Height {_cgg =iTemp .Data [(_cgd +1)*iTemp .RowStride ];};if _ggc >=1{_ade =iTarget .Data [(_ggc -1)*iTarget .RowStride ];};_bde =iTarget .Data [_ggc *iTarget .RowStride ];_ada :=uint (6+ox );_dgf =uint16 (_ge >>_ada );_ded =uint16 (_dgc >>_ada );_be =uint16 (_cgg >>_ada );_gbc =uint16 (_ade >>6);_def :=uint (2-ox );_ge <<=_def ;_dgc <<=_def ;_cgg <<=_def ;_ade <<=2;for _cfc =0;_cfc < iTarget .Width ;_cfc ++{_dbd :=(_dgf <<10)|(_ded <<7)|(_be <<4)|(_gbc <<1)|_fac ;_bb :=_bde >>7;_ffa :=_agc .encodeBit (_agc ._ffg ,uint32 (_dbd ),_bb );if _ffa !=nil {return _ffa ;};_dgf <<=1;_ded <<=1;_be <<=1;_gbc <<=1;_dgf |=uint16 (_ge >>7);_ded |=uint16 (_dgc >>7);_be |=uint16 (_cgg >>7);_gbc |=uint16 (_ade >>7);_fac =uint16 (_bb );_cb :=_cfc %8;_cgf :=_cfc /8+1;if _cb ==5+ox {_ge ,_dgc ,_cgg =0,0,0;if _cgf < iTemp .RowStride &&_cgd >=1&&(_cgd -1)< iTemp .Height {_ge =iTemp .Data [(_cgd -1)*iTemp .RowStride +_cgf ];};if _cgf < iTemp .RowStride &&_cgd >=0&&_cgd < iTemp .Height {_dgc =iTemp .Data [_cgd *iTemp .RowStride +_cgf ];};if _cgf < iTemp .RowStride &&_cgd >=-1&&(_cgd +1)< iTemp .Height {_cgg =iTemp .Data [(_cgd +1)*iTemp .RowStride +_cgf ];};}else {_ge <<=1;_dgc <<=1;_cgg <<=1;};if _cb ==5&&_ggc >=1{_ade =0;if _cgf < iTarget .RowStride {_ade =iTarget .Data [(_ggc -1)*iTarget .RowStride +_cgf ];};}else {_ade <<=1;};if _cb ==7{_bde =0;if _cgf < iTarget .RowStride {_bde =iTarget .Data [_ggc *iTarget .RowStride +_cgf ];};}else {_bde <<=1;};_dgf &=7;_ded &=7;_be &=7;_gbc &=7;};};return nil ;};func (_bcde *Encoder )flush (){_bcde .setBits ();_bcde ._gf <<=_bcde ._abd ;_bcde .byteOut ();_bcde ._gf <<=_bcde ._abd ;_bcde .byteOut ();_bcde .emit ();if _bcde ._bc !=0xff{_bcde ._ag ++;_bcde ._bc =0xff;_bcde .emit ();};_bcde ._ag ++;_bcde ._bc =0xac;_bcde ._ag ++;_bcde .emit ();};type intEncRangeS struct{_bf ,_ga int ;_bd ,_d uint8 ;_cf uint16 ;_cc uint8 ;};func (_bdb *Encoder )lBlock (){if _bdb ._ag >=0{_bdb .emit ();};_bdb ._ag ++;_bdb ._bc =uint8 (_bdb ._gf >>19);_bdb ._gf &=0x7ffff;_bdb ._abd =8;};const (IAAI Class =iota ;IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);func _ff (_dc int )*codingContext {return &codingContext {_dg :make ([]byte ,_dc ),_cd :make ([]byte ,_dc )};};func (_agb *Encoder )code0 (_gc *codingContext ,_cab uint32 ,_bec uint16 ,_egb byte ){if _gc .mps (_cab )==0{_agb .codeMPS (_gc ,_cab ,_bec ,_egb );}else {_agb .codeLPS (_gc ,_cab ,_bec ,_egb );};};func (_gaba *Encoder )setBits (){_bdc :=_gaba ._gf +uint32 (_gaba ._gb );_gaba ._gf |=0xffff;if _gaba ._gf >=_bdc {_gaba ._gf -=0x8000;};};func (_eda *Encoder )WriteTo (w _cg .Writer )(int64 ,error ){const _agf ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";var _fd int64 ;for _gee ,_dce :=range _eda ._bg {_ecc ,_dd :=w .Write (_dce );if _dd !=nil {return 0,_f .Wrapf (_dd ,_agf ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_gee );};_fd +=int64 (_ecc );};_eda ._aa =_eda ._aa [:_eda ._fc ];_fb ,_cdfg :=w .Write (_eda ._aa );if _cdfg !=nil {return 0,_f .Wrap (_cdfg ,_agf ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_fd +=int64 (_fb );return _fd ,nil ;};type Class int ;func (_fga *Encoder )DataSize ()int {return _fga .dataSize ()};const (_ebf =65536;_bgb =20*1024;);func (_ddc *Encoder )byteOut (){if _ddc ._bc ==0xff{_ddc .rBlock ();return ;};if _ddc ._gf < 0x8000000{_ddc .lBlock ();return ;};_ddc ._bc ++;if _ddc ._bc !=0xff{_ddc .lBlock ();return ;};_ddc ._gf &=0x7ffffff;_ddc .rBlock ();};func (_afe *Encoder )Final (){_afe .flush ()};const _fff =0x9b25;func (_ef *Encoder )Flush (){_ef ._fc =0;_ef ._bg =nil ;_ef ._ag =-1};func (_ec *Encoder )EncodeBitmap (bm *_e .Bitmap ,duplicateLineRemoval bool )error {_b .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );var (_af ,_aac uint8 ;_bca ,_adb ,_cge uint16 ;_db ,_dga ,_gab byte ;_ca ,_ac ,_agd int ;_da ,_de []byte ;);for _gff :=0;_gff < bm .Height ;_gff ++{_db ,_dga =0,0;if _gff >=2{_db =bm .Data [(_gff -2)*bm .RowStride ];};if _gff >=1{_dga =bm .Data [(_gff -1)*bm .RowStride ];if duplicateLineRemoval {_ac =_gff *bm .RowStride ;_da =bm .Data [_ac :_ac +bm .RowStride ];_agd =(_gff -1)*bm .RowStride ;_de =bm .Data [_agd :_agd +bm .RowStride ];if _g .Equal (_da ,_de ){_aac =_af ^1;_af =1;}else {_aac =_af ;_af =0;};};};if duplicateLineRemoval {if _bcd :=_ec .encodeBit (_ec ._ffg ,_fff ,_aac );_bcd !=nil {return _bcd ;};if _af !=0{continue ;};};_gab =bm .Data [_gff *bm .RowStride ];_bca =uint16 (_db >>5);_adb =uint16 (_dga >>4);_db <<=3;_dga <<=4;_cge =0;for _ca =0;_ca < bm .Width ;_ca ++{_cda :=uint32 (_bca <<11|_adb <<4|_cge );_gbf :=(_gab &0x80)>>7;_ae :=_ec .encodeBit (_ec ._ffg ,_cda ,_gbf );if _ae !=nil {return _ae ;};_bca <<=1;_adb <<=1;_cge <<=1;_bca |=uint16 ((_db &0x80)>>7);_adb |=uint16 ((_dga &0x80)>>7);_cge |=uint16 (_gbf );_fgc :=_ca %8;_ffff :=_ca /8+1;if _fgc ==4&&_gff >=2{_db =0;if _ffff < bm .RowStride {_db =bm .Data [(_gff -2)*bm .RowStride +_ffff ];};}else {_db <<=1;};if _fgc ==3&&_gff >=1{_dga =0;if _ffff < bm .RowStride {_dga =bm .Data [(_gff -1)*bm .RowStride +_ffff ];};}else {_dga <<=1;};if _fgc ==7{_gab =0;if _ffff < bm .RowStride {_gab =bm .Data [_gff *bm .RowStride +_ffff ];};}else {_gab <<=1;};_bca &=31;_adb &=127;_cge &=15;};};return nil ;};var _cgc =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};func (_ea *Encoder )code1 (_fge *codingContext ,_edab uint32 ,_gcf uint16 ,_aacd byte ){if _fge .mps (_edab )==1{_ea .codeMPS (_fge ,_edab ,_gcf ,_aacd );}else {_ea .codeLPS (_fge ,_edab ,_gcf ,_aacd );};};var _ _cg .WriterTo =&Encoder {};func (_fe *codingContext )mps (_ad uint32 )int {return int (_fe ._cd [_ad ])};func (_ead *Encoder )codeLPS (_edd *codingContext ,_dea uint32 ,_agdd uint16 ,_eff byte ){_ead ._gb -=_agdd ;if _ead ._gb < _agdd {_ead ._gf +=uint32 (_agdd );}else {_ead ._gb =_agdd ;};if _cgc [_eff ]._add ==1{_edd .flipMps (_dea );};_edd ._dg [_dea ]=_cgc [_eff ]._dca ;_ead .renormalize ();};func (_ee *Encoder )encodeBit (_bba *codingContext ,_agcd uint32 ,_dee uint8 )error {const _gfd ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";_ee ._gd ++;if _agcd >=uint32 (len (_bba ._dg )){return _f .Errorf (_gfd ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_agcd );};_fcd :=_bba ._dg [_agcd ];_eddg :=_bba .mps (_agcd );_decg :=_cgc [_fcd ]._egc ;_b .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_ee ._gd ,_dee ,_fcd ,_eddg ,_decg ,_ee ._gb ,_ee ._gf ,_ee ._abd ,_ee ._bc ,_ee ._ag );if _dee ==0{_ee .code0 (_bba ,_agcd ,_decg ,_fcd );}else {_ee .code1 (_bba ,_agcd ,_decg ,_fcd );};return nil ;};type codingContext struct{_dg []byte ;_cd []byte ;};func (_dgg *Encoder )rBlock (){if _dgg ._ag >=0{_dgg .emit ();};_dgg ._ag ++;_dgg ._bc =uint8 (_dgg ._gf >>20);_dgg ._gf &=0xfffff;_dgg ._abd =7;};func (_ecb *Encoder )dataSize ()int {return _bgb *len (_ecb ._bg )+_ecb ._fc };type state struct{_egc uint16 ;_aef ,_dca uint8 ;_add uint8 ;};