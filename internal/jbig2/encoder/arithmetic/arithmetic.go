//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_a "bytes";_ag "github.com/unidoc/unipdf/v3/common";_ab "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_e "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_bc "io";);func (_fdd *Encoder )encodeInteger (_def Class ,_eag int )error {const _bcb ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";
if _eag > 2000000000||_eag < -2000000000{return _e .Errorf (_bcb ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_eag );
};_dgg :=_fdd ._cb [_def ];_geg :=uint32 (1);var _dbg int ;for ;;_dbg ++{if _f [_dbg ]._g <=_eag &&_f [_dbg ]._d >=_eag {break ;};};if _eag < 0{_eag =-_eag ;};_eag -=int (_f [_dbg ]._c );_dfff :=_f [_dbg ]._eg ;for _bfc :=uint8 (0);_bfc < _f [_dbg ]._gg ;
_bfc ++{_ddg :=_dfff &1;if _cg :=_fdd .encodeBit (_dgg ,_geg ,_ddg );_cg !=nil {return _e .Wrap (_cg ,_bcb ,"");};_dfff >>=1;if _geg &0x100> 0{_geg =(((_geg <<1)|uint32 (_ddg ))&0x1ff)|0x100;}else {_geg =(_geg <<1)|uint32 (_ddg );};};_eag <<=32-_f [_dbg ]._ac ;
for _gdd :=uint8 (0);_gdd < _f [_dbg ]._ac ;_gdd ++{_dcb :=uint8 ((uint32 (_eag )&0x80000000)>>31);if _geb :=_fdd .encodeBit (_dgg ,_geg ,_dcb );_geb !=nil {return _e .Wrap (_geb ,_bcb ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");
};_eag <<=1;if _geg &0x100!=0{_geg =(((_geg <<1)|uint32 (_dcb ))&0x1ff)|0x100;}else {_geg =(_geg <<1)|uint32 (_dcb );};};return nil ;};func (_ee *Encoder )code0 (_af *codingContext ,_cba uint32 ,_dgf uint16 ,_abe byte ){if _af .mps (_cba )==0{_ee .codeMPS (_af ,_cba ,_dgf ,_abe );
}else {_ee .codeLPS (_af ,_cba ,_dgf ,_abe );};};func (_gc *Encoder )Init (){_gc ._bdf =_ef (_cef );_gc ._abf =0x8000;_gc ._fg =0;_gc ._fdg =12;_gc ._fe =-1;_gc ._de =0;_gc ._bd =0;_gc ._gd =make ([]byte ,_gaec );for _baf :=0;_baf < len (_gc ._cb );_baf ++{_gc ._cb [_baf ]=_ef (512);
};_gc ._eff =nil ;};func (_efff *Encoder )Refine (iTemp ,iTarget *_ab .Bitmap ,ox ,oy int )error {for _ccg :=0;_ccg < iTarget .Height ;_ccg ++{var _gde int ;_faeg :=_ccg +oy ;var (_dd ,_abb ,_cbe ,_efcf ,_aae uint16 ;_gae ,_gf ,_gbc ,_ece ,_bcgc byte ;
);if _faeg >=1&&(_faeg -1)< iTemp .Height {_gae =iTemp .Data [(_faeg -1)*iTemp .RowStride ];};if _faeg >=0&&_faeg < iTemp .Height {_gf =iTemp .Data [_faeg *iTemp .RowStride ];};if _faeg >=-1&&_faeg +1< iTemp .Height {_gbc =iTemp .Data [(_faeg +1)*iTemp .RowStride ];
};if _ccg >=1{_ece =iTarget .Data [(_ccg -1)*iTarget .RowStride ];};_bcgc =iTarget .Data [_ccg *iTarget .RowStride ];_badf :=uint (6+ox );_dd =uint16 (_gae >>_badf );_abb =uint16 (_gf >>_badf );_cbe =uint16 (_gbc >>_badf );_efcf =uint16 (_ece >>6);_fad :=uint (2-ox );
_gae <<=_fad ;_gf <<=_fad ;_gbc <<=_fad ;_ece <<=2;for _gde =0;_gde < iTarget .Width ;_gde ++{_gdb :=(_dd <<10)|(_abb <<7)|(_cbe <<4)|(_efcf <<1)|_aae ;_da :=_bcgc >>7;_cea :=_efff .encodeBit (_efff ._bdf ,uint32 (_gdb ),_da );if _cea !=nil {return _cea ;
};_dd <<=1;_abb <<=1;_cbe <<=1;_efcf <<=1;_dd |=uint16 (_gae >>7);_abb |=uint16 (_gf >>7);_cbe |=uint16 (_gbc >>7);_efcf |=uint16 (_ece >>7);_aae =uint16 (_da );_cfc :=_gde %8;_ggb :=_gde /8+1;if _cfc ==5+ox {_gae ,_gf ,_gbc =0,0,0;if _ggb < iTemp .RowStride &&_faeg >=1&&(_faeg -1)< iTemp .Height {_gae =iTemp .Data [(_faeg -1)*iTemp .RowStride +_ggb ];
};if _ggb < iTemp .RowStride &&_faeg >=0&&_faeg < iTemp .Height {_gf =iTemp .Data [_faeg *iTemp .RowStride +_ggb ];};if _ggb < iTemp .RowStride &&_faeg >=-1&&(_faeg +1)< iTemp .Height {_gbc =iTemp .Data [(_faeg +1)*iTemp .RowStride +_ggb ];};}else {_gae <<=1;
_gf <<=1;_gbc <<=1;};if _cfc ==5&&_ccg >=1{_ece =0;if _ggb < iTarget .RowStride {_ece =iTarget .Data [(_ccg -1)*iTarget .RowStride +_ggb ];};}else {_ece <<=1;};if _cfc ==7{_bcgc =0;if _ggb < iTarget .RowStride {_bcgc =iTarget .Data [_ccg *iTarget .RowStride +_ggb ];
};}else {_bcgc <<=1;};_dd &=7;_abb &=7;_cbe &=7;_efcf &=7;};};return nil ;};func _ef (_ea int )*codingContext {return &codingContext {_bb :make ([]byte ,_ea ),_ega :make ([]byte ,_ea )};};func (_ccd *Encoder )encodeOOB (_ebd Class )error {_bef :=_ccd ._cb [_ebd ];
_ad :=_ccd .encodeBit (_bef ,1,1);if _ad !=nil {return _ad ;};_ad =_ccd .encodeBit (_bef ,3,0);if _ad !=nil {return _ad ;};_ad =_ccd .encodeBit (_bef ,6,0);if _ad !=nil {return _ad ;};_ad =_ccd .encodeBit (_bef ,12,0);if _ad !=nil {return _ad ;};return nil ;
};func (_cfg *Encoder )emit (){if _cfg ._bd ==_gaec {_cfg ._abg =append (_cfg ._abg ,_cfg ._gd );_cfg ._gd =make ([]byte ,_gaec );_cfg ._bd =0;};_cfg ._gd [_cfg ._bd ]=_cfg ._de ;_cfg ._bd ++;};func (_efd *Encoder )EncodeBitmap (bm *_ab .Bitmap ,duplicateLineRemoval bool )error {_ag .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );
var (_fb ,_bcg uint8 ;_bf ,_aa ,_ace uint16 ;_fgd ,_db ,_gef byte ;_bad ,_gb ,_feg int ;_ga ,_eae []byte ;);for _ec :=0;_ec < bm .Height ;_ec ++{_fgd ,_db =0,0;if _ec >=2{_fgd =bm .Data [(_ec -2)*bm .RowStride ];};if _ec >=1{_db =bm .Data [(_ec -1)*bm .RowStride ];
if duplicateLineRemoval {_gb =_ec *bm .RowStride ;_ga =bm .Data [_gb :_gb +bm .RowStride ];_feg =(_ec -1)*bm .RowStride ;_eae =bm .Data [_feg :_feg +bm .RowStride ];if _a .Equal (_ga ,_eae ){_bcg =_fb ^1;_fb =1;}else {_bcg =_fb ;_fb =0;};};};if duplicateLineRemoval {if _efc :=_efd .encodeBit (_efd ._bdf ,_bcc ,_bcg );
_efc !=nil {return _efc ;};if _fb !=0{continue ;};};_gef =bm .Data [_ec *bm .RowStride ];_bf =uint16 (_fgd >>5);_aa =uint16 (_db >>4);_fgd <<=3;_db <<=4;_ace =0;for _bad =0;_bad < bm .Width ;_bad ++{_fc :=uint32 (_bf <<11|_aa <<4|_ace );_ce :=(_gef &0x80)>>7;
_aced :=_efd .encodeBit (_efd ._bdf ,_fc ,_ce );if _aced !=nil {return _aced ;};_bf <<=1;_aa <<=1;_ace <<=1;_bf |=uint16 ((_fgd &0x80)>>7);_aa |=uint16 ((_db &0x80)>>7);_ace |=uint16 (_ce );_fa :=_bad %8;_fgg :=_bad /8+1;if _fa ==4&&_ec >=2{_fgd =0;if _fgg < bm .RowStride {_fgd =bm .Data [(_ec -2)*bm .RowStride +_fgg ];
};}else {_fgd <<=1;};if _fa ==3&&_ec >=1{_db =0;if _fgg < bm .RowStride {_db =bm .Data [(_ec -1)*bm .RowStride +_fgg ];};}else {_db <<=1;};if _fa ==7{_gef =0;if _fgg < bm .RowStride {_gef =bm .Data [_ec *bm .RowStride +_fgg ];};}else {_gef <<=1;};_bf &=31;
_aa &=127;_ace &=15;};};return nil ;};const (_cef =65536;_gaec =20*1024;);type state struct{_gff uint16 ;_fdfc ,_ggf uint8 ;_fec uint8 ;};func (_dab *Encoder )setBits (){_eba :=_dab ._fg +uint32 (_dab ._abf );_dab ._fg |=0xffff;if _dab ._fg >=_eba {_dab ._fg -=0x8000;
};};func (_efdg *Encoder )encodeBit (_be *codingContext ,_afb uint32 ,_gee uint8 )error {const _cdb ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";_efdg ._fdf ++;if _afb >=uint32 (len (_be ._bb )){return _e .Errorf (_cdb ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_afb );
};_dee :=_be ._bb [_afb ];_bfgd :=_be .mps (_afb );_dffc :=_eaee [_dee ]._gff ;_ag .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_efdg ._fdf ,_gee ,_dee ,_bfgd ,_dffc ,_efdg ._abf ,_efdg ._fg ,_efdg ._fdg ,_efdg ._de ,_efdg ._fe );
if _gee ==0{_efdg .code0 (_be ,_afb ,_dffc ,_dee );}else {_efdg .code1 (_be ,_afb ,_dffc ,_dee );};return nil ;};var _eaee =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
func (_ff *Encoder )codeLPS (_efa *codingContext ,_age uint32 ,_gab uint16 ,_aab byte ){_ff ._abf -=_gab ;if _ff ._abf < _gab {_ff ._fg +=uint32 (_gab );}else {_ff ._abf =_gab ;};if _eaee [_aab ]._fec ==1{_efa .flipMps (_age );};_efa ._bb [_age ]=_eaee [_aab ]._ggf ;
_ff .renormalize ();};func (_ged *Encoder )EncodeInteger (proc Class ,value int )(_dc error ){_ag .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );
if _dc =_ged .encodeInteger (proc ,value );_dc !=nil {return _e .Wrap (_dc ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};func (_eb *Encoder )codeMPS (_abfd *codingContext ,_ggc uint32 ,_bg uint16 ,_aeb byte ){_eb ._abf -=_bg ;
if _eb ._abf &0x8000!=0{_eb ._fg +=uint32 (_bg );return ;};if _eb ._abf < _bg {_eb ._abf =_bg ;}else {_eb ._fg +=uint32 (_bg );};_abfd ._bb [_ggc ]=_eaee [_aeb ]._fdfc ;_eb .renormalize ();};const _bcc =0x9b25;func (_gefc *Encoder )Final (){_gefc .flush ()};
type Class int ;func (_fbg *Encoder )byteOut (){if _fbg ._de ==0xff{_fbg .rBlock ();return ;};if _fbg ._fg < 0x8000000{_fbg .lBlock ();return ;};_fbg ._de ++;if _fbg ._de !=0xff{_fbg .lBlock ();return ;};_fbg ._fg &=0x7ffffff;_fbg .rBlock ();};func (_bbb *codingContext )mps (_fd uint32 )int {return int (_bbb ._ega [_fd ])};
func (_dg *Encoder )EncodeOOB (proc Class )(_fae error ){_ag .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );if _fae =_dg .encodeOOB (proc );
_fae !=nil {return _e .Wrap (_fae ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};func (_deb *Encoder )Flush (){_deb ._bd =0;_deb ._abg =nil ;_deb ._fe =-1};func (_acb *Encoder )flush (){_acb .setBits ();_acb ._fg <<=_acb ._fdg ;_acb .byteOut ();
_acb ._fg <<=_acb ._fdg ;_acb .byteOut ();_acb .emit ();if _acb ._de !=0xff{_acb ._fe ++;_acb ._de =0xff;_acb .emit ();};_acb ._fe ++;_acb ._de =0xac;_acb ._fe ++;_acb .emit ();};type intEncRangeS struct{_g ,_d int ;_eg ,_gg uint8 ;_c uint16 ;_ac uint8 ;
};func (_cc *Encoder )EncodeIAID (symbolCodeLength ,value int )(_df error ){_ag .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );
if _df =_cc .encodeIAID (symbolCodeLength ,value );_df !=nil {return _e .Wrap (_df ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};func (_ca *Encoder )DataSize ()int {return _ca .dataSize ()};func (_fca *Encoder )renormalize (){for {_fca ._abf <<=1;
_fca ._fg <<=1;_fca ._fdg --;if _fca ._fdg ==0{_fca .byteOut ();};if (_fca ._abf &0x8000)!=0{break ;};};};var _f =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};
func (_dff *Encoder )dataSize ()int {return _gaec *len (_dff ._abg )+_dff ._bd };func (_fee *Encoder )WriteTo (w _bc .Writer )(int64 ,error ){const _gda ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";var _cfb int64 ;
for _bfg ,_fcg :=range _fee ._abg {_gbce ,_ccc :=w .Write (_fcg );if _ccc !=nil {return 0,_e .Wrapf (_ccc ,_gda ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_bfg );
};_cfb +=int64 (_gbce );};_fee ._gd =_fee ._gd [:_fee ._bd ];_cbf ,_cd :=w .Write (_fee ._gd );if _cd !=nil {return 0,_e .Wrap (_cd ,_gda ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_cfb +=int64 (_cbf );return _cfb ,nil ;
};type codingContext struct{_bb []byte ;_ega []byte ;};type Encoder struct{_fg uint32 ;_abf uint16 ;_fdg ,_de uint8 ;_fe int ;_fdf int ;_abg [][]byte ;_gd []byte ;_bd int ;_bdf *codingContext ;_cb [13]*codingContext ;_eff *codingContext ;};func (_cf *codingContext )flipMps (_ae uint32 ){_cf ._ega [_ae ]=1-_cf ._ega [_ae ]};
func (_cfe *Encoder )lBlock (){if _cfe ._fe >=0{_cfe .emit ();};_cfe ._fe ++;_cfe ._de =uint8 (_cfe ._fg >>19);_cfe ._fg &=0x7ffff;_cfe ._fdg =8;};func (_eaf *Encoder )encodeIAID (_ed ,_ddd int )error {if _eaf ._eff ==nil {_eaf ._eff =_ef (1<<uint (_ed ));
};_ggbg :=uint32 (1<<uint32 (_ed +1))-1;_ddd <<=uint (32-_ed );_fbe :=uint32 (1);for _gad :=0;_gad < _ed ;_gad ++{_fcc :=_fbe &_ggbg ;_cfd :=uint8 ((uint32 (_ddd )&0x80000000)>>31);if _bde :=_eaf .encodeBit (_eaf ._eff ,_fcc ,_cfd );_bde !=nil {return _bde ;
};_fbe =(_fbe <<1)|uint32 (_cfd );_ddd <<=1;};return nil ;};func New ()*Encoder {_ge :=&Encoder {};_ge .Init ();return _ge };func (_fcd *Encoder )code1 (_dba *codingContext ,_dgb uint32 ,_fcf uint16 ,_fge byte ){if _dba .mps (_dgb )==1{_fcd .codeMPS (_dba ,_dgb ,_fcf ,_fge );
}else {_fcd .codeLPS (_dba ,_dgb ,_fcf ,_fge );};};var _ _bc .WriterTo =&Encoder {};func (_ba Class )String ()string {switch _ba {case IAAI :return "\u0049\u0041\u0041\u0049";case IADH :return "\u0049\u0041\u0044\u0048";case IADS :return "\u0049\u0041\u0044\u0053";
case IADT :return "\u0049\u0041\u0044\u0054";case IADW :return "\u0049\u0041\u0044\u0057";case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";case IAIT :return "\u0049\u0041\u0049\u0054";case IARDH :return "\u0049\u0041\u0052D\u0048";
case IARDW :return "\u0049\u0041\u0052D\u0057";case IARDX :return "\u0049\u0041\u0052D\u0058";case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";};};const (IAAI Class =iota ;
IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);func (_dag *Encoder )rBlock (){if _dag ._fe >=0{_dag .emit ();};_dag ._fe ++;_dag ._de =uint8 (_dag ._fg >>20);_dag ._fg &=0xfffff;_dag ._fdg =7;};func (_egd *Encoder )Reset (){_egd ._abf =0x8000;
_egd ._fg =0;_egd ._fdg =12;_egd ._fe =-1;_egd ._de =0;_egd ._eff =nil ;_egd ._bdf =_ef (_cef );};