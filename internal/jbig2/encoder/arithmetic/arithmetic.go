//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_d "bytes";_aa "github.com/unidoc/unipdf/v3/common";_dd "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_e "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_f "io";);func (_dcee *Encoder )flush (){_dcee .setBits ();_dcee ._ca <<=_dcee ._fb ;
_dcee .byteOut ();_dcee ._ca <<=_dcee ._fb ;_dcee .byteOut ();_dcee .emit ();if _dcee ._ae !=0xff{_dcee ._gg ++;_dcee ._ae =0xff;_dcee .emit ();};_dcee ._gg ++;_dcee ._ae =0xac;_dcee ._gg ++;_dcee .emit ();};type state struct{_cbf uint16 ;_fae ,_ead uint8 ;
_bab uint8 ;};var _ _f .WriterTo =&Encoder {};func (_ac *Encoder )EncodeBitmap (bm *_dd .Bitmap ,duplicateLineRemoval bool )error {_aa .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );
var (_agc ,_gfbf uint8 ;_efa ,_edg ,_cab uint16 ;_fe ,_dc ,_ee byte ;_ccg ,_abe ,_aea int ;_dce ,_ga []byte ;);for _aed :=0;_aed < bm .Height ;_aed ++{_fe ,_dc =0,0;if _aed >=2{_fe =bm .Data [(_aed -2)*bm .RowStride ];};if _aed >=1{_dc =bm .Data [(_aed -1)*bm .RowStride ];
if duplicateLineRemoval {_abe =_aed *bm .RowStride ;_dce =bm .Data [_abe :_abe +bm .RowStride ];_aea =(_aed -1)*bm .RowStride ;_ga =bm .Data [_aea :_aea +bm .RowStride ];if _d .Equal (_dce ,_ga ){_gfbf =_agc ^1;_agc =1;}else {_gfbf =_agc ;_agc =0;};};};
if duplicateLineRemoval {if _ge :=_ac .encodeBit (_ac ._caa ,_gfb ,_gfbf );_ge !=nil {return _ge ;};if _agc !=0{continue ;};};_ee =bm .Data [_aed *bm .RowStride ];_efa =uint16 (_fe >>5);_edg =uint16 (_dc >>4);_fe <<=3;_dc <<=4;_cab =0;for _ccg =0;_ccg < bm .Width ;
_ccg ++{_bee :=uint32 (_efa <<11|_edg <<4|_cab );_da :=(_ee &0x80)>>7;_ggc :=_ac .encodeBit (_ac ._caa ,_bee ,_da );if _ggc !=nil {return _ggc ;};_efa <<=1;_edg <<=1;_cab <<=1;_efa |=uint16 ((_fe &0x80)>>7);_edg |=uint16 ((_dc &0x80)>>7);_cab |=uint16 (_da );
_ebf :=_ccg %8;_aba :=_ccg /8+1;if _ebf ==4&&_aed >=2{_fe =0;if _aba < bm .RowStride {_fe =bm .Data [(_aed -2)*bm .RowStride +_aba ];};}else {_fe <<=1;};if _ebf ==3&&_aed >=1{_dc =0;if _aba < bm .RowStride {_dc =bm .Data [(_aed -1)*bm .RowStride +_aba ];
};}else {_dc <<=1;};if _ebf ==7{_ee =0;if _aba < bm .RowStride {_ee =bm .Data [_aed *bm .RowStride +_aba ];};}else {_ee <<=1;};_efa &=31;_edg &=127;_cab &=15;};};return nil ;};func (_fd *Encoder )setBits (){_agac :=_fd ._ca +uint32 (_fd ._dda );_fd ._ca |=0xffff;
if _fd ._ca >=_agac {_fd ._ca -=0x8000;};};func (_gb *Encoder )EncodeOOB (proc Class )(_dcf error ){_aa .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );
if _dcf =_gb .encodeOOB (proc );_dcf !=nil {return _e .Wrap (_dcf ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};const (IAAI Class =iota ;IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);func (_c Class )String ()string {switch _c {case IAAI :return "\u0049\u0041\u0041\u0049";
case IADH :return "\u0049\u0041\u0044\u0048";case IADS :return "\u0049\u0041\u0044\u0053";case IADT :return "\u0049\u0041\u0044\u0054";case IADW :return "\u0049\u0041\u0044\u0057";case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";
case IAIT :return "\u0049\u0041\u0049\u0054";case IARDH :return "\u0049\u0041\u0052D\u0048";case IARDW :return "\u0049\u0041\u0052D\u0057";case IARDX :return "\u0049\u0041\u0052D\u0058";case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";
default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";};};func (_baa *Encoder )Reset (){_baa ._dda =0x8000;_baa ._ca =0;_baa ._fb =12;_baa ._gg =-1;_baa ._ae =0;_baa ._dbg =nil ;_baa ._caa =_cd (_fce );};func (_gc *Encoder )codeMPS (_agd *codingContext ,_aec uint32 ,_ddfa uint16 ,_gba byte ){_gc ._dda -=_ddfa ;
if _gc ._dda &0x8000!=0{_gc ._ca +=uint32 (_ddfa );return ;};if _gc ._dda < _ddfa {_gc ._dda =_ddfa ;}else {_gc ._ca +=uint32 (_ddfa );};_agd ._ef [_aec ]=_gcg [_gba ]._fae ;_gc .renormalize ();};func (_fff *Encoder )renormalize (){for {_fff ._dda <<=1;
_fff ._ca <<=1;_fff ._fb --;if _fff ._fb ==0{_fff .byteOut ();};if (_fff ._dda &0x8000)!=0{break ;};};};var _b =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};
func (_bf *Encoder )code0 (_ad *codingContext ,_cbc uint32 ,_bfb uint16 ,_aad byte ){if _ad .mps (_cbc )==0{_bf .codeMPS (_ad ,_cbc ,_bfb ,_aad );}else {_bf .codeLPS (_ad ,_cbc ,_bfb ,_aad );};};func (_dbdd *Encoder )rBlock (){if _dbdd ._gg >=0{_dbdd .emit ();
};_dbdd ._gg ++;_dbdd ._ae =uint8 (_dbdd ._ca >>20);_dbdd ._ca &=0xfffff;_dbdd ._fb =7;};func (_dgd *Encoder )dataSize ()int {return _ccf *len (_dgd ._be )+_dgd ._ecc };func (_dcb *Encoder )Flush (){_dcb ._ecc =0;_dcb ._be =nil ;_dcb ._gg =-1};func (_eg *Encoder )WriteTo (w _f .Writer )(int64 ,error ){const _ebd ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";
var _gfe int64 ;for _eea ,_aeac :=range _eg ._be {_fag ,_bea :=w .Write (_aeac );if _bea !=nil {return 0,_e .Wrapf (_bea ,_ebd ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_eea );
};_gfe +=int64 (_fag );};_eg ._aga =_eg ._aga [:_eg ._ecc ];_gfa ,_de :=w .Write (_eg ._aga );if _de !=nil {return 0,_e .Wrap (_de ,_ebd ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_gfe +=int64 (_gfa );return _gfe ,nil ;
};func (_cce *Encoder )Refine (iTemp ,iTarget *_dd .Bitmap ,ox ,oy int )error {for _dbgc :=0;_dbgc < iTarget .Height ;_dbgc ++{var _gd int ;_ffe :=_dbgc +oy ;var (_ggb ,_ace ,_bg ,_ddc ,_ccef uint16 ;_fea ,_cca ,_aee ,_cg ,_agg byte ;);if _ffe >=1&&(_ffe -1)< iTemp .Height {_fea =iTemp .Data [(_ffe -1)*iTemp .RowStride ];
};if _ffe >=0&&_ffe < iTemp .Height {_cca =iTemp .Data [_ffe *iTemp .RowStride ];};if _ffe >=-1&&_ffe +1< iTemp .Height {_aee =iTemp .Data [(_ffe +1)*iTemp .RowStride ];};if _dbgc >=1{_cg =iTarget .Data [(_dbgc -1)*iTarget .RowStride ];};_agg =iTarget .Data [_dbgc *iTarget .RowStride ];
_acc :=uint (6+ox );_ggb =uint16 (_fea >>_acc );_ace =uint16 (_cca >>_acc );_bg =uint16 (_aee >>_acc );_ddc =uint16 (_cg >>6);_dg :=uint (2-ox );_fea <<=_dg ;_cca <<=_dg ;_aee <<=_dg ;_cg <<=2;for _gd =0;_gd < iTarget .Width ;_gd ++{_dgb :=(_ggb <<10)|(_ace <<7)|(_bg <<4)|(_ddc <<1)|_ccef ;
_cdac :=_agg >>7;_eafd :=_cce .encodeBit (_cce ._caa ,uint32 (_dgb ),_cdac );if _eafd !=nil {return _eafd ;};_ggb <<=1;_ace <<=1;_bg <<=1;_ddc <<=1;_ggb |=uint16 (_fea >>7);_ace |=uint16 (_cca >>7);_bg |=uint16 (_aee >>7);_ddc |=uint16 (_cg >>7);_ccef =uint16 (_cdac );
_cf :=_gd %8;_edb :=_gd /8+1;if _cf ==5+ox {_fea ,_cca ,_aee =0,0,0;if _edb < iTemp .RowStride &&_ffe >=1&&(_ffe -1)< iTemp .Height {_fea =iTemp .Data [(_ffe -1)*iTemp .RowStride +_edb ];};if _edb < iTemp .RowStride &&_ffe >=0&&_ffe < iTemp .Height {_cca =iTemp .Data [_ffe *iTemp .RowStride +_edb ];
};if _edb < iTemp .RowStride &&_ffe >=-1&&(_ffe +1)< iTemp .Height {_aee =iTemp .Data [(_ffe +1)*iTemp .RowStride +_edb ];};}else {_fea <<=1;_cca <<=1;_aee <<=1;};if _cf ==5&&_dbgc >=1{_cg =0;if _edb < iTarget .RowStride {_cg =iTarget .Data [(_dbgc -1)*iTarget .RowStride +_edb ];
};}else {_cg <<=1;};if _cf ==7{_agg =0;if _edb < iTarget .RowStride {_agg =iTarget .Data [_dbgc *iTarget .RowStride +_edb ];};}else {_agg <<=1;};_ggb &=7;_ace &=7;_bg &=7;_ddc &=7;};};return nil ;};func (_dbd *Encoder )EncodeIAID (symbolCodeLength ,value int )(_fa error ){_aa .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );
if _fa =_dbd .encodeIAID (symbolCodeLength ,value );_fa !=nil {return _e .Wrap (_fa ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};type intEncRangeS struct{_ab ,_g int ;_gf ,_cc uint8 ;_aag uint16 ;_db uint8 ;};func (_cda *Encoder )Final (){_cda .flush ()};
func (_acb *Encoder )encodeInteger (_cabc Class ,_ffd int )error {const _fee ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";if _ffd > 2000000000||_ffd < -2000000000{return _e .Errorf (_fee ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_ffd );
};_bcg :=_acb ._cae [_cabc ];_abab :=uint32 (1);var _ce int ;for ;;_ce ++{if _b [_ce ]._ab <=_ffd &&_b [_ce ]._g >=_ffd {break ;};};if _ffd < 0{_ffd =-_ffd ;};_ffd -=int (_b [_ce ]._aag );_dac :=_b [_ce ]._gf ;for _def :=uint8 (0);_def < _b [_ce ]._cc ;
_def ++{_bae :=_dac &1;if _bd :=_acb .encodeBit (_bcg ,_abab ,_bae );_bd !=nil {return _e .Wrap (_bd ,_fee ,"");};_dac >>=1;if _abab &0x100> 0{_abab =(((_abab <<1)|uint32 (_bae ))&0x1ff)|0x100;}else {_abab =(_abab <<1)|uint32 (_bae );};};_ffd <<=32-_b [_ce ]._db ;
for _adb :=uint8 (0);_adb < _b [_ce ]._db ;_adb ++{_ggd :=uint8 ((uint32 (_ffd )&0x80000000)>>31);if _edbb :=_acb .encodeBit (_bcg ,_abab ,_ggd );_edbb !=nil {return _e .Wrap (_edbb ,_fee ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");
};_ffd <<=1;if _abab &0x100!=0{_abab =(((_abab <<1)|uint32 (_ggd ))&0x1ff)|0x100;}else {_abab =(_abab <<1)|uint32 (_ggd );};};return nil ;};type codingContext struct{_ef []byte ;_ed []byte ;};type Encoder struct{_ca uint32 ;_dda uint16 ;_fb ,_ae uint8 ;
_gg int ;_fc int ;_be [][]byte ;_aga []byte ;_ecc int ;_caa *codingContext ;_cae [13]*codingContext ;_dbg *codingContext ;};func (_daf *Encoder )emit (){if _daf ._ecc ==_ccf {_daf ._be =append (_daf ._be ,_daf ._aga );_daf ._aga =make ([]byte ,_ccf );_daf ._ecc =0;
};_daf ._aga [_daf ._ecc ]=_daf ._ae ;_daf ._ecc ++;};func (_ffa *Encoder )codeLPS (_eff *codingContext ,_cfg uint32 ,_aab uint16 ,_abb byte ){_ffa ._dda -=_aab ;if _ffa ._dda < _aab {_ffa ._ca +=uint32 (_aab );}else {_ffa ._dda =_aab ;};if _gcg [_abb ]._bab ==1{_eff .flipMps (_cfg );
};_eff ._ef [_cfg ]=_gcg [_abb ]._ead ;_ffa .renormalize ();};func (_ffag *Encoder )lBlock (){if _ffag ._gg >=0{_ffag .emit ();};_ffag ._gg ++;_ffag ._ae =uint8 (_ffag ._ca >>19);_ffag ._ca &=0x7ffff;_ffag ._fb =8;};func (_gdb *Encoder )encodeIAID (_afg ,_deb int )error {if _gdb ._dbg ==nil {_gdb ._dbg =_cd (1<<uint (_afg ));
};_accc :=uint32 (1<<uint32 (_afg +1))-1;_deb <<=uint (32-_afg );_edc :=uint32 (1);for _gaac :=0;_gaac < _afg ;_gaac ++{_df :=_edc &_accc ;_ebfe :=uint8 ((uint32 (_deb )&0x80000000)>>31);if _bgf :=_gdb .encodeBit (_gdb ._dbg ,_df ,_ebfe );_bgf !=nil {return _bgf ;
};_edc =(_edc <<1)|uint32 (_ebfe );_deb <<=1;};return nil ;};func (_gad *Encoder )byteOut (){if _gad ._ae ==0xff{_gad .rBlock ();return ;};if _gad ._ca < 0x8000000{_gad .lBlock ();return ;};_gad ._ae ++;if _gad ._ae !=0xff{_gad .lBlock ();return ;};_gad ._ca &=0x7ffffff;
_gad .rBlock ();};func (_cb *codingContext )flipMps (_ec uint32 ){_cb ._ed [_ec ]=1-_cb ._ed [_ec ]};func (_ff *Encoder )EncodeInteger (proc Class ,value int )(_bce error ){_aa .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );
if _bce =_ff .encodeInteger (proc ,value );_bce !=nil {return _e .Wrap (_bce ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};func (_ba *Encoder )Init (){_ba ._caa =_cd (_fce );_ba ._dda =0x8000;_ba ._ca =0;
_ba ._fb =12;_ba ._gg =-1;_ba ._ae =0;_ba ._ecc =0;_ba ._aga =make ([]byte ,_ccf );for _eaf :=0;_eaf < len (_ba ._cae );_eaf ++{_ba ._cae [_eaf ]=_cd (512);};_ba ._dbg =nil ;};func (_cbb *Encoder )encodeOOB (_dbf Class )error {_fed :=_cbb ._cae [_dbf ];
_cdf :=_cbb .encodeBit (_fed ,1,1);if _cdf !=nil {return _cdf ;};_cdf =_cbb .encodeBit (_fed ,3,0);if _cdf !=nil {return _cdf ;};_cdf =_cbb .encodeBit (_fed ,6,0);if _cdf !=nil {return _cdf ;};_cdf =_cbb .encodeBit (_fed ,12,0);if _cdf !=nil {return _cdf ;
};return nil ;};func (_bc *Encoder )DataSize ()int {return _bc .dataSize ()};const _gfb =0x9b25;type Class int ;func New ()*Encoder {_ea :=&Encoder {};_ea .Init ();return _ea };func (_fg *Encoder )code1 (_ddb *codingContext ,_fca uint32 ,_ddf uint16 ,_gaa byte ){if _ddb .mps (_fca )==1{_fg .codeMPS (_ddb ,_fca ,_ddf ,_gaa );
}else {_fg .codeLPS (_ddb ,_fca ,_ddf ,_gaa );};};var _gcg =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
const (_fce =65536;_ccf =20*1024;);func (_af *codingContext )mps (_ag uint32 )int {return int (_af ._ed [_ag ])};func _cd (_eb int )*codingContext {return &codingContext {_ef :make ([]byte ,_eb ),_ed :make ([]byte ,_eb )};};func (_aggc *Encoder )encodeBit (_gac *codingContext ,_bfc uint32 ,_geb uint8 )error {const _gbf ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";
_aggc ._fc ++;if _bfc >=uint32 (len (_gac ._ef )){return _e .Errorf (_gbf ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_bfc );
};_edba :=_gac ._ef [_bfc ];_fbc :=_gac .mps (_bfc );_cbg :=_gcg [_edba ]._cbf ;_aa .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_aggc ._fc ,_geb ,_edba ,_fbc ,_cbg ,_aggc ._dda ,_aggc ._ca ,_aggc ._fb ,_aggc ._ae ,_aggc ._gg );
if _geb ==0{_aggc .code0 (_gac ,_bfc ,_cbg ,_edba );}else {_aggc .code1 (_gac ,_bfc ,_cbg ,_edba );};return nil ;};