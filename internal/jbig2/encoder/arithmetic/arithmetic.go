//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_a "bytes";_d "github.com/unidoc/unipdf/v3/common";_e "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_dg "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_c "io";);var _bbd =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
func (_dgg *Encoder )Init (){_dgg ._agc =_ac (_dgf );_dgg ._eef =0x8000;_dgg ._ee =0;_dgg ._fe =12;_dgg ._ccc =-1;_dgg ._gf =0;_dgg ._gdd =0;_dgg ._gd =make ([]byte ,_cgda );for _dfc :=0;_dfc < len (_dgg ._gddg );_dfc ++{_dgg ._gddg [_dfc ]=_ac (512);};
_dgg ._bc =nil ;};func (_edbg *Encoder )Reset (){_edbg ._eef =0x8000;_edbg ._ee =0;_edbg ._fe =12;_edbg ._ccc =-1;_edbg ._gf =0;_edbg ._bc =nil ;_edbg ._agc =_ac (_dgf );};func (_dggf *Encoder )DataSize ()int {return _dggf .dataSize ()};func (_ea *Encoder )EncodeIAID (symbolCodeLength ,value int )(_gdf error ){_d .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );
if _gdf =_ea .encodeIAID (symbolCodeLength ,value );_gdf !=nil {return _dg .Wrap (_gdf ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};func (_bcff *Encoder )WriteTo (w _c .Writer )(int64 ,error ){const _abg ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";
var _gdg int64 ;for _dfd ,_gce :=range _bcff ._ce {_fbf ,_dcf :=w .Write (_gce );if _dcf !=nil {return 0,_dg .Wrapf (_dcf ,_abg ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_dfd );
};_gdg +=int64 (_fbf );};_bcff ._gd =_bcff ._gd [:_bcff ._gdd ];_abb ,_eed :=w .Write (_bcff ._gd );if _eed !=nil {return 0,_dg .Wrap (_eed ,_abg ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_gdg +=int64 (_abb );
return _gdg ,nil ;};func (_fbfe *Encoder )code0 (_gcg *codingContext ,_cbf uint32 ,_fcde uint16 ,_ae byte ){if _gcg .mps (_cbf )==0{_fbfe .codeMPS (_gcg ,_cbf ,_fcde ,_ae );}else {_fbfe .codeLPS (_gcg ,_cbf ,_fcde ,_ae );};};func (_gbe *Encoder )Flush (){_gbe ._gdd =0;
_gbe ._ce =nil ;_gbe ._ccc =-1};func (_gfe *Encoder )EncodeInteger (proc Class ,value int )(_fbeb error ){_d .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );
if _fbeb =_gfe .encodeInteger (proc ,value );_fbeb !=nil {return _dg .Wrap (_fbeb ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};func (_dag *Encoder )encodeIAID (_agbg ,_fgg int )error {if _dag ._bc ==nil {_dag ._bc =_ac (1<<uint (_agbg ));
};_bfg :=uint32 (1<<uint32 (_agbg +1))-1;_fgg <<=uint (32-_agbg );_bgg :=uint32 (1);for _gcd :=0;_gcd < _agbg ;_gcd ++{_faa :=_bgg &_bfg ;_gega :=uint8 ((uint32 (_fgg )&0x80000000)>>31);if _cdd :=_dag .encodeBit (_dag ._bc ,_faa ,_gega );_cdd !=nil {return _cdd ;
};_bgg =(_bgg <<1)|uint32 (_gega );_fgg <<=1;};return nil ;};func (_cf *Encoder )codeLPS (_aca *codingContext ,_feg uint32 ,_fgf uint16 ,_gg byte ){_cf ._eef -=_fgf ;if _cf ._eef < _fgf {_cf ._ee +=uint32 (_fgf );}else {_cf ._eef =_fgf ;};if _bbd [_gg ]._dee ==1{_aca .flipMps (_feg );
};_aca ._fb [_feg ]=_bbd [_gg ]._deb ;_cf .renormalize ();};var _eb =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};
type intEncRangeS struct{_ed ,_fg int ;_g ,_fa uint8 ;_df uint16 ;_db uint8 ;};const (_dgf =65536;_cgda =20*1024;);type Encoder struct{_ee uint32 ;_eef uint16 ;_fe ,_gf uint8 ;_ccc int ;_gb int ;_ce [][]byte ;_gd []byte ;_gdd int ;_agc *codingContext ;
_gddg [13]*codingContext ;_bc *codingContext ;};func (_gbad *Encoder )Final (){_gbad .flush ()};func (_fbfa *Encoder )codeMPS (_gbeg *codingContext ,_bcd uint32 ,_deg uint16 ,_agb byte ){_fbfa ._eef -=_deg ;if _fbfa ._eef &0x8000!=0{_fbfa ._ee +=uint32 (_deg );
return ;};if _fbfa ._eef < _deg {_fbfa ._eef =_deg ;}else {_fbfa ._ee +=uint32 (_deg );};_gbeg ._fb [_bcd ]=_bbd [_agb ]._febf ;_fbfa .renormalize ();};func (_gbg *Encoder )encodeBit (_acfa *codingContext ,_gac uint32 ,_gcge uint8 )error {const _ebe ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";
_gbg ._gb ++;if _gac >=uint32 (len (_acfa ._fb )){return _dg .Errorf (_ebe ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_gac );
};_bcffg :=_acfa ._fb [_gac ];_ggc :=_acfa .mps (_gac );_ccge :=_bbd [_bcffg ]._dda ;_d .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_gbg ._gb ,_gcge ,_bcffg ,_ggc ,_ccge ,_gbg ._eef ,_gbg ._ee ,_gbg ._fe ,_gbg ._gf ,_gbg ._ccc );
if _gcge ==0{_gbg .code0 (_acfa ,_gac ,_ccge ,_bcffg );}else {_gbg .code1 (_acfa ,_gac ,_ccge ,_bcffg );};return nil ;};func (_bda *Encoder )renormalize (){for {_bda ._eef <<=1;_bda ._ee <<=1;_bda ._fe --;if _bda ._fe ==0{_bda .byteOut ();};if (_bda ._eef &0x8000)!=0{break ;
};};};func (_gbc *Encoder )EncodeOOB (proc Class )(_gda error ){_d .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );if _gda =_gbc .encodeOOB (proc );
_gda !=nil {return _dg .Wrap (_gda ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};func (_adc *Encoder )encodeOOB (_ffc Class )error {_efgf :=_adc ._gddg [_ffc ];_ccb :=_adc .encodeBit (_efgf ,1,1);if _ccb !=nil {return _ccb ;};_ccb =_adc .encodeBit (_efgf ,3,0);
if _ccb !=nil {return _ccb ;};_ccb =_adc .encodeBit (_efgf ,6,0);if _ccb !=nil {return _ccb ;};_ccb =_adc .encodeBit (_efgf ,12,0);if _ccb !=nil {return _ccb ;};return nil ;};type codingContext struct{_fb []byte ;_fbe []byte ;};var _ _c .WriterTo =&Encoder {};
func (_gdfc *Encoder )lBlock (){if _gdfc ._ccc >=0{_gdfc .emit ();};_gdfc ._ccc ++;_gdfc ._gf =uint8 (_gdfc ._ee >>19);_gdfc ._ee &=0x7ffff;_gdfc ._fe =8;};func (_cdc *Encoder )rBlock (){if _cdc ._ccc >=0{_cdc .emit ();};_cdc ._ccc ++;_cdc ._gf =uint8 (_cdc ._ee >>20);
_cdc ._ee &=0xfffff;_cdc ._fe =7;};const (IAAI Class =iota ;IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);func (_f Class )String ()string {switch _f {case IAAI :return "\u0049\u0041\u0041\u0049";case IADH :return "\u0049\u0041\u0044\u0048";
case IADS :return "\u0049\u0041\u0044\u0053";case IADT :return "\u0049\u0041\u0044\u0054";case IADW :return "\u0049\u0041\u0044\u0057";case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";case IAIT :return "\u0049\u0041\u0049\u0054";
case IARDH :return "\u0049\u0041\u0052D\u0048";case IARDW :return "\u0049\u0041\u0052D\u0057";case IARDX :return "\u0049\u0041\u0052D\u0058";case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";
};};func (_baaf *Encoder )emit (){if _baaf ._gdd ==_cgda {_baaf ._ce =append (_baaf ._ce ,_baaf ._gd );_baaf ._gd =make ([]byte ,_cgda );_baaf ._gdd =0;};_baaf ._gd [_baaf ._gdd ]=_baaf ._gf ;_baaf ._gdd ++;};func (_dc *codingContext )flipMps (_ba uint32 ){_dc ._fbe [_ba ]=1-_dc ._fbe [_ba ]};
func (_bdc *Encoder )byteOut (){if _bdc ._gf ==0xff{_bdc .rBlock ();return ;};if _bdc ._ee < 0x8000000{_bdc .lBlock ();return ;};_bdc ._gf ++;if _bdc ._gf !=0xff{_bdc .lBlock ();return ;};_bdc ._ee &=0x7ffffff;_bdc .rBlock ();};func New ()*Encoder {_dd :=&Encoder {};
_dd .Init ();return _dd };func (_dgc *Encoder )encodeInteger (_ccdf Class ,_bg int )error {const _ecd ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";if _bg > 2000000000||_bg < -2000000000{return _dg .Errorf (_ecd ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_bg );
};_efgg :=_dgc ._gddg [_ccdf ];_cee :=uint32 (1);var _eeb int ;for ;;_eeb ++{if _eb [_eeb ]._ed <=_bg &&_eb [_eeb ]._fg >=_bg {break ;};};if _bg < 0{_bg =-_bg ;};_bg -=int (_eb [_eeb ]._df );_cag :=_eb [_eeb ]._g ;for _cbb :=uint8 (0);_cbb < _eb [_eeb ]._fa ;
_cbb ++{_aeb :=_cag &1;if _ffb :=_dgc .encodeBit (_efgg ,_cee ,_aeb );_ffb !=nil {return _dg .Wrap (_ffb ,_ecd ,"");};_cag >>=1;if _cee &0x100> 0{_cee =(((_cee <<1)|uint32 (_aeb ))&0x1ff)|0x100;}else {_cee =(_cee <<1)|uint32 (_aeb );};};_bg <<=32-_eb [_eeb ]._db ;
for _bea :=uint8 (0);_bea < _eb [_eeb ]._db ;_bea ++{_gdfe :=uint8 ((uint32 (_bg )&0x80000000)>>31);if _bdg :=_dgc .encodeBit (_efgg ,_cee ,_gdfe );_bdg !=nil {return _dg .Wrap (_bdg ,_ecd ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");
};_bg <<=1;if _cee &0x100!=0{_cee =(((_cee <<1)|uint32 (_gdfe ))&0x1ff)|0x100;}else {_cee =(_cee <<1)|uint32 (_gdfe );};};return nil ;};type state struct{_dda uint16 ;_febf ,_deb uint8 ;_dee uint8 ;};func (_edb *Encoder )EncodeBitmap (bm *_e .Bitmap ,duplicateLineRemoval bool )error {_d .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );
var (_aa ,_ccg uint8 ;_fc ,_bcf ,_de uint16 ;_ad ,_da ,_cdf byte ;_fcd ,_ge ,_baa int ;_fag ,_cgd []byte ;);for _ga :=0;_ga < bm .Height ;_ga ++{_ad ,_da =0,0;if _ga >=2{_ad =bm .Data [(_ga -2)*bm .RowStride ];};if _ga >=1{_da =bm .Data [(_ga -1)*bm .RowStride ];
if duplicateLineRemoval {_ge =_ga *bm .RowStride ;_fag =bm .Data [_ge :_ge +bm .RowStride ];_baa =(_ga -1)*bm .RowStride ;_cgd =bm .Data [_baa :_baa +bm .RowStride ];if _a .Equal (_fag ,_cgd ){_ccg =_aa ^1;_aa =1;}else {_ccg =_aa ;_aa =0;};};};if duplicateLineRemoval {if _bd :=_edb .encodeBit (_edb ._agc ,_cg ,_ccg );
_bd !=nil {return _bd ;};if _aa !=0{continue ;};};_cdf =bm .Data [_ga *bm .RowStride ];_fc =uint16 (_ad >>5);_bcf =uint16 (_da >>4);_ad <<=3;_da <<=4;_de =0;for _fcd =0;_fcd < bm .Width ;_fcd ++{_ccd :=uint32 (_fc <<11|_bcf <<4|_de );_gba :=(_cdf &0x80)>>7;
_cb :=_edb .encodeBit (_edb ._agc ,_ccd ,_gba );if _cb !=nil {return _cb ;};_fc <<=1;_bcf <<=1;_de <<=1;_fc |=uint16 ((_ad &0x80)>>7);_bcf |=uint16 ((_da &0x80)>>7);_de |=uint16 (_gba );_ccf :=_fcd %8;_fbb :=_fcd /8+1;if _ccf ==4&&_ga >=2{_ad =0;if _fbb < bm .RowStride {_ad =bm .Data [(_ga -2)*bm .RowStride +_fbb ];
};}else {_ad <<=1;};if _ccf ==3&&_ga >=1{_da =0;if _fbb < bm .RowStride {_da =bm .Data [(_ga -1)*bm .RowStride +_fbb ];};}else {_da <<=1;};if _ccf ==7{_cdf =0;if _fbb < bm .RowStride {_cdf =bm .Data [_ga *bm .RowStride +_fbb ];};}else {_cdf <<=1;};_fc &=31;
_bcf &=127;_de &=15;};};return nil ;};func (_ca *Encoder )Refine (iTemp ,iTarget *_e .Bitmap ,ox ,oy int )error {for _feb :=0;_feb < iTarget .Height ;_feb ++{var _ab int ;_gdad :=_feb +oy ;var (_edd ,_gab ,_fee ,_ef ,_eg uint16 ;_geg ,_acf ,_gdc ,_gc ,_faf byte ;
);if _gdad >=1&&(_gdad -1)< iTemp .Height {_geg =iTemp .Data [(_gdad -1)*iTemp .RowStride ];};if _gdad >=0&&_gdad < iTemp .Height {_acf =iTemp .Data [_gdad *iTemp .RowStride ];};if _gdad >=-1&&_gdad +1< iTemp .Height {_gdc =iTemp .Data [(_gdad +1)*iTemp .RowStride ];
};if _feb >=1{_gc =iTarget .Data [(_feb -1)*iTarget .RowStride ];};_faf =iTarget .Data [_feb *iTarget .RowStride ];_bf :=uint (6+ox );_edd =uint16 (_geg >>_bf );_gab =uint16 (_acf >>_bf );_fee =uint16 (_gdc >>_bf );_ef =uint16 (_gc >>6);_bb :=uint (2-ox );
_geg <<=_bb ;_acf <<=_bb ;_gdc <<=_bb ;_gc <<=2;for _ab =0;_ab < iTarget .Width ;_ab ++{_age :=(_edd <<10)|(_gab <<7)|(_fee <<4)|(_ef <<1)|_eg ;_be :=_faf >>7;_egg :=_ca .encodeBit (_ca ._agc ,uint32 (_age ),_be );if _egg !=nil {return _egg ;};_edd <<=1;
_gab <<=1;_fee <<=1;_ef <<=1;_edd |=uint16 (_geg >>7);_gab |=uint16 (_acf >>7);_fee |=uint16 (_gdc >>7);_ef |=uint16 (_gc >>7);_eg =uint16 (_be );_bbe :=_ab %8;_fae :=_ab /8+1;if _bbe ==5+ox {_geg ,_acf ,_gdc =0,0,0;if _fae < iTemp .RowStride &&_gdad >=1&&(_gdad -1)< iTemp .Height {_geg =iTemp .Data [(_gdad -1)*iTemp .RowStride +_fae ];
};if _fae < iTemp .RowStride &&_gdad >=0&&_gdad < iTemp .Height {_acf =iTemp .Data [_gdad *iTemp .RowStride +_fae ];};if _fae < iTemp .RowStride &&_gdad >=-1&&(_gdad +1)< iTemp .Height {_gdc =iTemp .Data [(_gdad +1)*iTemp .RowStride +_fae ];};}else {_geg <<=1;
_acf <<=1;_gdc <<=1;};if _bbe ==5&&_feb >=1{_gc =0;if _fae < iTarget .RowStride {_gc =iTarget .Data [(_feb -1)*iTarget .RowStride +_fae ];};}else {_gc <<=1;};if _bbe ==7{_faf =0;if _fae < iTarget .RowStride {_faf =iTarget .Data [_feb *iTarget .RowStride +_fae ];
};}else {_faf <<=1;};_edd &=7;_gab &=7;_fee &=7;_ef &=7;};};return nil ;};func _ac (_cd int )*codingContext {return &codingContext {_fb :make ([]byte ,_cd ),_fbe :make ([]byte ,_cd )};};type Class int ;func (_acd *Encoder )dataSize ()int {return _cgda *len (_acd ._ce )+_acd ._gdd };
func (_bcb *Encoder )flush (){_bcb .setBits ();_bcb ._ee <<=_bcb ._fe ;_bcb .byteOut ();_bcb ._ee <<=_bcb ._fe ;_bcb .byteOut ();_bcb .emit ();if _bcb ._gf !=0xff{_bcb ._ccc ++;_bcb ._gf =0xff;_bcb .emit ();};_bcb ._ccc ++;_bcb ._gf =0xac;_bcb ._ccc ++;
_bcb .emit ();};func (_gfef *Encoder )setBits (){_eaf :=_gfef ._ee +uint32 (_gfef ._eef );_gfef ._ee |=0xffff;if _gfef ._ee >=_eaf {_gfef ._ee -=0x8000;};};const _cg =0x9b25;func (_efg *Encoder )code1 (_ff *codingContext ,_eaa uint32 ,_ec uint16 ,_eedb byte ){if _ff .mps (_eaa )==1{_efg .codeMPS (_ff ,_eaa ,_ec ,_eedb );
}else {_efg .codeLPS (_ff ,_eaa ,_ec ,_eedb );};};func (_ag *codingContext )mps (_cc uint32 )int {return int (_ag ._fbe [_cc ])};