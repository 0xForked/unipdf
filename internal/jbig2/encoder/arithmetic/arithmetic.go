//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_b "bytes";_db "github.com/unidoc/unipdf/v3/common";_df "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_a "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_d "io";);func (_cbg *Encoder )code1 (_gac *codingContext ,_dgg uint32 ,_aaa uint16 ,_cdg byte ){if _gac .mps (_dgg )==1{_cbg .codeMPS (_gac ,_dgg ,_aaa ,_cdg );
}else {_cbg .codeLPS (_gac ,_dgg ,_aaa ,_cdg );};};const (IAAI Class =iota ;IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);var _bcd =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
func (_ab *Encoder )EncodeInteger (proc Class ,value int )(_fcg error ){_db .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );
if _fcg =_ab .encodeInteger (proc ,value );_fcg !=nil {return _a .Wrap (_fcg ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};func (_ecf *Encoder )dataSize ()int {return _ffa *len (_ecf ._fg )+_ecf ._dc };
func (_ccf *Encoder )Refine (iTemp ,iTarget *_df .Bitmap ,ox ,oy int )error {for _dcad :=0;_dcad < iTarget .Height ;_dcad ++{var _ag int ;_bfa :=_dcad +oy ;var (_gaf ,_adf ,_gfg ,_eab ,_dd uint16 ;_cba ,_fbg ,_eeb ,_aca ,_cdc byte ;);if _bfa >=1&&(_bfa -1)< iTemp .Height {_cba =iTemp .Data [(_bfa -1)*iTemp .RowStride ];
};if _bfa >=0&&_bfa < iTemp .Height {_fbg =iTemp .Data [_bfa *iTemp .RowStride ];};if _bfa >=-1&&_bfa +1< iTemp .Height {_eeb =iTemp .Data [(_bfa +1)*iTemp .RowStride ];};if _dcad >=1{_aca =iTarget .Data [(_dcad -1)*iTarget .RowStride ];};_cdc =iTarget .Data [_dcad *iTarget .RowStride ];
_fdd :=uint (6+ox );_gaf =uint16 (_cba >>_fdd );_adf =uint16 (_fbg >>_fdd );_gfg =uint16 (_eeb >>_fdd );_eab =uint16 (_aca >>6);_ccg :=uint (2-ox );_cba <<=_ccg ;_fbg <<=_ccg ;_eeb <<=_ccg ;_aca <<=2;for _ag =0;_ag < iTarget .Width ;_ag ++{_abd :=(_gaf <<10)|(_adf <<7)|(_gfg <<4)|(_eab <<1)|_dd ;
_cca :=_cdc >>7;_fbf :=_ccf .encodeBit (_ccf ._gg ,uint32 (_abd ),_cca );if _fbf !=nil {return _fbf ;};_gaf <<=1;_adf <<=1;_gfg <<=1;_eab <<=1;_gaf |=uint16 (_cba >>7);_adf |=uint16 (_fbg >>7);_gfg |=uint16 (_eeb >>7);_eab |=uint16 (_aca >>7);_dd =uint16 (_cca );
_gc :=_ag %8;_bd :=_ag /8+1;if _gc ==5+ox {_cba ,_fbg ,_eeb =0,0,0;if _bd < iTemp .RowStride &&_bfa >=1&&(_bfa -1)< iTemp .Height {_cba =iTemp .Data [(_bfa -1)*iTemp .RowStride +_bd ];};if _bd < iTemp .RowStride &&_bfa >=0&&_bfa < iTemp .Height {_fbg =iTemp .Data [_bfa *iTemp .RowStride +_bd ];
};if _bd < iTemp .RowStride &&_bfa >=-1&&(_bfa +1)< iTemp .Height {_eeb =iTemp .Data [(_bfa +1)*iTemp .RowStride +_bd ];};}else {_cba <<=1;_fbg <<=1;_eeb <<=1;};if _gc ==5&&_dcad >=1{_aca =0;if _bd < iTarget .RowStride {_aca =iTarget .Data [(_dcad -1)*iTarget .RowStride +_bd ];
};}else {_aca <<=1;};if _gc ==7{_cdc =0;if _bd < iTarget .RowStride {_cdc =iTarget .Data [_dcad *iTarget .RowStride +_bd ];};}else {_cdc <<=1;};_gaf &=7;_adf &=7;_gfg &=7;_eab &=7;};};return nil ;};func (_fbe *Encoder )encodeIAID (_bgf ,_gcga int )error {if _fbe ._cc ==nil {_fbe ._cc =_cd (1<<uint (_bgf ));
};_ebbf :=uint32 (1<<uint32 (_bgf +1))-1;_gcga <<=uint (32-_bgf );_fca :=uint32 (1);for _aef :=0;_aef < _bgf ;_aef ++{_agg :=_fca &_ebbf ;_agaf :=uint8 ((uint32 (_gcga )&0x80000000)>>31);if _afcd :=_fbe .encodeBit (_fbe ._cc ,_agg ,_agaf );_afcd !=nil {return _afcd ;
};_fca =(_fca <<1)|uint32 (_agaf );_gcga <<=1;};return nil ;};type Encoder struct{_ef uint32 ;_eg uint16 ;_ce ,_eb uint8 ;_cg int ;_dba int ;_fg [][]byte ;_ca []byte ;_dc int ;_gg *codingContext ;_cee [13]*codingContext ;_cc *codingContext ;};func _cd (_gf int )*codingContext {return &codingContext {_fe :make ([]byte ,_gf ),_ga :make ([]byte ,_gf )};
};func (_ece *Encoder )byteOut (){if _ece ._eb ==0xff{_ece .rBlock ();return ;};if _ece ._ef < 0x8000000{_ece .lBlock ();return ;};_ece ._eb ++;if _ece ._eb !=0xff{_ece .lBlock ();return ;};_ece ._ef &=0x7ffffff;_ece .rBlock ();};func (_ceb *Encoder )WriteTo (w _d .Writer )(int64 ,error ){const _agc ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";
var _geg int64 ;for _beg ,_eebf :=range _ceb ._fg {_gb ,_cfe :=w .Write (_eebf );if _cfe !=nil {return 0,_a .Wrapf (_cfe ,_agc ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_beg );
};_geg +=int64 (_gb );};_ceb ._ca =_ceb ._ca [:_ceb ._dc ];_ded ,_ec :=w .Write (_ceb ._ca );if _ec !=nil {return 0,_a .Wrap (_ec ,_agc ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_geg +=int64 (_ded );return _geg ,nil ;
};func (_aff *Encoder )Final (){_aff .flush ()};func (_egc *Encoder )Flush (){_egc ._dc =0;_egc ._fg =nil ;_egc ._cg =-1};func (_bg *Encoder )code0 (_dg *codingContext ,_dge uint32 ,_afe uint16 ,_abe byte ){if _dg .mps (_dge )==0{_bg .codeMPS (_dg ,_dge ,_afe ,_abe );
}else {_bg .codeLPS (_dg ,_dge ,_afe ,_abe );};};func (_bcc *Encoder )encodeBit (_bbf *codingContext ,_dbaa uint32 ,_cebd uint8 )error {const _dbe ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";_bcc ._dba ++;
if _dbaa >=uint32 (len (_bbf ._fe )){return _a .Errorf (_dbe ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_dbaa );
};_bae :=_bbf ._fe [_dbaa ];_fa :=_bbf .mps (_dbaa );_eaf :=_bcd [_bae ]._gfd ;_db .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_bcc ._dba ,_cebd ,_bae ,_fa ,_eaf ,_bcc ._eg ,_bcc ._ef ,_bcc ._ce ,_bcc ._eb ,_bcc ._cg );
if _cebd ==0{_bcc .code0 (_bbf ,_dbaa ,_eaf ,_bae );}else {_bcc .code1 (_bbf ,_dbaa ,_eaf ,_bae );};return nil ;};func (_af *codingContext )flipMps (_dfd uint32 ){_af ._ga [_dfd ]=1-_af ._ga [_dfd ]};func (_ege *Encoder )codeMPS (_cgd *codingContext ,_ged uint32 ,_gfc uint16 ,_bee byte ){_ege ._eg -=_gfc ;
if _ege ._eg &0x8000!=0{_ege ._ef +=uint32 (_gfc );return ;};if _ege ._eg < _gfc {_ege ._eg =_gfc ;}else {_ege ._ef +=uint32 (_gfc );};_cgd ._fe [_ged ]=_bcd [_bee ]._cac ;_ege .renormalize ();};type codingContext struct{_fe []byte ;_ga []byte ;};var _e =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};
func (_gcbg *Encoder )encodeOOB (_eed Class )error {_gee :=_gcbg ._cee [_eed ];_gcc :=_gcbg .encodeBit (_gee ,1,1);if _gcc !=nil {return _gcc ;};_gcc =_gcbg .encodeBit (_gee ,3,0);if _gcc !=nil {return _gcc ;};_gcc =_gcbg .encodeBit (_gee ,6,0);if _gcc !=nil {return _gcc ;
};_gcc =_gcbg .encodeBit (_gee ,12,0);if _gcc !=nil {return _gcc ;};return nil ;};func (_def *Encoder )setBits (){_egd :=_def ._ef +uint32 (_def ._eg );_def ._ef |=0xffff;if _def ._ef >=_egd {_def ._ef -=0x8000;};};func (_eff *Encoder )emit (){if _eff ._dc ==_ffa {_eff ._fg =append (_eff ._fg ,_eff ._ca );
_eff ._ca =make ([]byte ,_ffa );_eff ._dc =0;};_eff ._ca [_eff ._dc ]=_eff ._eb ;_eff ._dc ++;};type intEncRangeS struct{_gd ,_ba int ;_bb ,_be uint8 ;_ad uint16 ;_c uint8 ;};func (_cbe *Encoder )flush (){_cbe .setBits ();_cbe ._ef <<=_cbe ._ce ;_cbe .byteOut ();
_cbe ._ef <<=_cbe ._ce ;_cbe .byteOut ();_cbe .emit ();if _cbe ._eb !=0xff{_cbe ._cg ++;_cbe ._eb =0xff;_cbe .emit ();};_cbe ._cg ++;_cbe ._eb =0xac;_cbe ._cg ++;_cbe .emit ();};func (_ggg *Encoder )EncodeOOB (proc Class )(_aec error ){_db .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );
if _aec =_ggg .encodeOOB (proc );_aec !=nil {return _a .Wrap (_aec ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};func (_gef *Encoder )codeLPS (_caf *codingContext ,_ede uint32 ,_bc uint16 ,_ggb byte ){_gef ._eg -=_bc ;if _gef ._eg < _bc {_gef ._ef +=uint32 (_bc );
}else {_gef ._eg =_bc ;};if _bcd [_ggb ]._bdd ==1{_caf .flipMps (_ede );};_caf ._fe [_ede ]=_bcd [_ggb ]._afcdb ;_gef .renormalize ();};func (_ac *Encoder )EncodeIAID (symbolCodeLength ,value int )(_ed error ){_db .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );
if _ed =_ac .encodeIAID (symbolCodeLength ,value );_ed !=nil {return _a .Wrap (_ed ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};func New ()*Encoder {_ea :=&Encoder {};_ea .Init ();return _ea };func (_agag *Encoder )encodeInteger (_gcg Class ,_gcb int )error {const _cddf ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";
if _gcb > 2000000000||_gcb < -2000000000{return _a .Errorf (_cddf ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_gcb );
};_gff :=_agag ._cee [_gcg ];_dab :=uint32 (1);var _bdg int ;for ;;_bdg ++{if _e [_bdg ]._gd <=_gcb &&_e [_bdg ]._ba >=_gcb {break ;};};if _gcb < 0{_gcb =-_gcb ;};_gcb -=int (_e [_bdg ]._ad );_baf :=_e [_bdg ]._bb ;for _bff :=uint8 (0);_bff < _e [_bdg ]._be ;
_bff ++{_gcd :=_baf &1;if _bfc :=_agag .encodeBit (_gff ,_dab ,_gcd );_bfc !=nil {return _a .Wrap (_bfc ,_cddf ,"");};_baf >>=1;if _dab &0x100> 0{_dab =(((_dab <<1)|uint32 (_gcd ))&0x1ff)|0x100;}else {_dab =(_dab <<1)|uint32 (_gcd );};};_gcb <<=32-_e [_bdg ]._c ;
for _abf :=uint8 (0);_abf < _e [_bdg ]._c ;_abf ++{_ff :=uint8 ((uint32 (_gcb )&0x80000000)>>31);if _dfa :=_agag .encodeBit (_gff ,_dab ,_ff );_dfa !=nil {return _a .Wrap (_dfa ,_cddf ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");
};_gcb <<=1;if _dab &0x100!=0{_dab =(((_dab <<1)|uint32 (_ff ))&0x1ff)|0x100;}else {_dab =(_dab <<1)|uint32 (_ff );};};return nil ;};func (_ceba *Encoder )lBlock (){if _ceba ._cg >=0{_ceba .emit ();};_ceba ._cg ++;_ceba ._eb =uint8 (_ceba ._ef >>19);_ceba ._ef &=0x7ffff;
_ceba ._ce =8;};func (_f Class )String ()string {switch _f {case IAAI :return "\u0049\u0041\u0041\u0049";case IADH :return "\u0049\u0041\u0044\u0048";case IADS :return "\u0049\u0041\u0044\u0053";case IADT :return "\u0049\u0041\u0044\u0054";case IADW :return "\u0049\u0041\u0044\u0057";
case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";case IAIT :return "\u0049\u0041\u0049\u0054";case IARDH :return "\u0049\u0041\u0052D\u0048";case IARDW :return "\u0049\u0041\u0052D\u0057";case IARDX :return "\u0049\u0041\u0052D\u0058";
case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";};};func (_dbb *Encoder )rBlock (){if _dbb ._cg >=0{_dbb .emit ();};_dbb ._cg ++;_dbb ._eb =uint8 (_dbb ._ef >>20);
_dbb ._ef &=0xfffff;_dbb ._ce =7;};func (_bgb *Encoder )renormalize (){for {_bgb ._eg <<=1;_bgb ._ef <<=1;_bgb ._ce --;if _bgb ._ce ==0{_bgb .byteOut ();};if (_bgb ._eg &0x8000)!=0{break ;};};};type state struct{_gfd uint16 ;_cac ,_afcdb uint8 ;_bdd uint8 ;
};func (_dee *Encoder )DataSize ()int {return _dee .dataSize ()};var _ _d .WriterTo =&Encoder {};func (_ggc *Encoder )EncodeBitmap (bm *_df .Bitmap ,duplicateLineRemoval bool )error {_db .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );
var (_da ,_fbb uint8 ;_bf ,_aa ,_dca uint16 ;_deb ,_aac ,_bba byte ;_fd ,_fbba ,_cdd int ;_fc ,_ebb []byte ;);for _ge :=0;_ge < bm .Height ;_ge ++{_deb ,_aac =0,0;if _ge >=2{_deb =bm .Data [(_ge -2)*bm .RowStride ];};if _ge >=1{_aac =bm .Data [(_ge -1)*bm .RowStride ];
if duplicateLineRemoval {_fbba =_ge *bm .RowStride ;_fc =bm .Data [_fbba :_fbba +bm .RowStride ];_cdd =(_ge -1)*bm .RowStride ;_ebb =bm .Data [_cdd :_cdd +bm .RowStride ];if _b .Equal (_fc ,_ebb ){_fbb =_da ^1;_da =1;}else {_fbb =_da ;_da =0;};};};if duplicateLineRemoval {if _ada :=_ggc .encodeBit (_ggc ._gg ,_afc ,_fbb );
_ada !=nil {return _ada ;};if _da !=0{continue ;};};_bba =bm .Data [_ge *bm .RowStride ];_bf =uint16 (_deb >>5);_aa =uint16 (_aac >>4);_deb <<=3;_aac <<=4;_dca =0;for _fd =0;_fd < bm .Width ;_fd ++{_cb :=uint32 (_bf <<11|_aa <<4|_dca );_ee :=(_bba &0x80)>>7;
_gda :=_ggc .encodeBit (_ggc ._gg ,_cb ,_ee );if _gda !=nil {return _gda ;};_bf <<=1;_aa <<=1;_dca <<=1;_bf |=uint16 ((_deb &0x80)>>7);_aa |=uint16 ((_aac &0x80)>>7);_dca |=uint16 (_ee );_ae :=_fd %8;_cf :=_fd /8+1;if _ae ==4&&_ge >=2{_deb =0;if _cf < bm .RowStride {_deb =bm .Data [(_ge -2)*bm .RowStride +_cf ];
};}else {_deb <<=1;};if _ae ==3&&_ge >=1{_aac =0;if _cf < bm .RowStride {_aac =bm .Data [(_ge -1)*bm .RowStride +_cf ];};}else {_aac <<=1;};if _ae ==7{_bba =0;if _cf < bm .RowStride {_bba =bm .Data [_ge *bm .RowStride +_cf ];};}else {_bba <<=1;};_bf &=31;
_aa &=127;_dca &=15;};};return nil ;};func (_aga *Encoder )Reset (){_aga ._eg =0x8000;_aga ._ef =0;_aga ._ce =12;_aga ._cg =-1;_aga ._eb =0;_aga ._cc =nil ;_aga ._gg =_cd (_beeg );};type Class int ;const (_beeg =65536;_ffa =20*1024;);const _afc =0x9b25;
func (_fef *codingContext )mps (_de uint32 )int {return int (_fef ._ga [_de ])};func (_fb *Encoder )Init (){_fb ._gg =_cd (_beeg );_fb ._eg =0x8000;_fb ._ef =0;_fb ._ce =12;_fb ._cg =-1;_fb ._eb =0;_fb ._dc =0;_fb ._ca =make ([]byte ,_ffa );for _fgf :=0;
_fgf < len (_fb ._cee );_fgf ++{_fb ._cee [_fgf ]=_cd (512);};_fb ._cc =nil ;};