//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_a "bytes";_cc "github.com/unidoc/unipdf/v3/common";_bc "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_e "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_b "io";);func (_dd *Encoder )Final (){_dd .flush ()};type intEncRangeS struct{_g ,_ag int ;_ccb ,_bcb uint8 ;_agg uint16 ;_gf uint8 ;};func (_dag *Encoder )lBlock (){if _dag ._dab >=0{_dag .emit ();};_dag ._dab ++;_dag ._da =uint8 (_dag ._db >>19);_dag ._db &=0x7ffff;_dag ._bgc =8;};func (_aea *Encoder )encodeBit (_bab *codingContext ,_ca uint32 ,_bad uint8 )error {const _egc ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";_aea ._ba ++;if _ca >=uint32 (len (_bab ._ed )){return _e .Errorf (_egc ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_ca );};_faa :=_bab ._ed [_ca ];_dbdd :=_bab .mps (_ca );_aac :=_gcb [_faa ]._daa ;_cc .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_aea ._ba ,_bad ,_faa ,_dbdd ,_aac ,_aea ._bg ,_aea ._db ,_aea ._bgc ,_aea ._da ,_aea ._dab );if _bad ==0{_aea .code0 (_bab ,_ca ,_aac ,_faa );}else {_aea .code1 (_bab ,_ca ,_aac ,_faa );};return nil ;};func (_ebd *Encoder )Init (){_ebd ._eeb =_d (_cdd );_ebd ._bg =0x8000;_ebd ._db =0;_ebd ._bgc =12;_ebd ._dab =-1;_ebd ._da =0;_ebd ._ff =0;_ebd ._cf =make ([]byte ,_gaea );for _ad :=0;_ad < len (_ebd ._fe );_ad ++{_ebd ._fe [_ad ]=_d (512);};_ebd ._eeg =nil ;};var _ee =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};type Class int ;func (_gfg *Encoder )WriteTo (w _b .Writer )(int64 ,error ){const _df ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";var _ccbg int64 ;for _bda ,_bfd :=range _gfg ._ec {_ddb ,_ccbdc :=w .Write (_bfd );if _ccbdc !=nil {return 0,_e .Wrapf (_ccbdc ,_df ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_bda );};_ccbg +=int64 (_ddb );};_gfg ._cf =_gfg ._cf [:_gfg ._ff ];_fd ,_eca :=w .Write (_gfg ._cf );if _eca !=nil {return 0,_e .Wrap (_eca ,_df ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_ccbg +=int64 (_fd );return _ccbg ,nil ;};func (_gbab *Encoder )encodeInteger (_dcf Class ,_ddc int )error {const _bgf ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";if _ddc > 2000000000||_ddc < -2000000000{return _e .Errorf (_bgf ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_ddc );};_egca :=_gbab ._fe [_dcf ];_add :=uint32 (1);var _cb int ;for ;;_cb ++{if _ee [_cb ]._g <=_ddc &&_ee [_cb ]._ag >=_ddc {break ;};};if _ddc < 0{_ddc =-_ddc ;};_ddc -=int (_ee [_cb ]._agg );_dg :=_ee [_cb ]._ccb ;for _cff :=uint8 (0);_cff < _ee [_cb ]._bcb ;_cff ++{_cgb :=_dg &1;if _edc :=_gbab .encodeBit (_egca ,_add ,_cgb );_edc !=nil {return _e .Wrap (_edc ,_bgf ,"");};_dg >>=1;if _add &0x100> 0{_add =(((_add <<1)|uint32 (_cgb ))&0x1ff)|0x100;}else {_add =(_add <<1)|uint32 (_cgb );};};_ddc <<=32-_ee [_cb ]._gf ;for _gdf :=uint8 (0);_gdf < _ee [_cb ]._gf ;_gdf ++{_adb :=uint8 ((uint32 (_ddc )&0x80000000)>>31);if _cgf :=_gbab .encodeBit (_egca ,_add ,_adb );_cgf !=nil {return _e .Wrap (_cgf ,_bgf ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");};_ddc <<=1;if _add &0x100!=0{_add =(((_add <<1)|uint32 (_adb ))&0x1ff)|0x100;}else {_add =(_add <<1)|uint32 (_adb );};};return nil ;};type state struct{_daa uint16 ;_fge ,_dcb uint8 ;_ebg uint8 ;};type Encoder struct{_db uint32 ;_bg uint16 ;_bgc ,_da uint8 ;_dab int ;_ba int ;_ec [][]byte ;_cf []byte ;_ff int ;_eeb *codingContext ;_fe [13]*codingContext ;_eeg *codingContext ;};func (_bac *Encoder )EncodeOOB (proc Class )(_bbc error ){_cc .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );if _bbc =_bac .encodeOOB (proc );_bbc !=nil {return _e .Wrap (_bbc ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};func (_gbd *Encoder )DataSize ()int {return _gbd .dataSize ()};func (_cae *Encoder )renormalize (){for {_cae ._bg <<=1;_cae ._db <<=1;_cae ._bgc --;if _cae ._bgc ==0{_cae .byteOut ();};if (_cae ._bg &0x8000)!=0{break ;};};};func (_bd *Encoder )EncodeBitmap (bm *_bc .Bitmap ,duplicateLineRemoval bool )error {_cc .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );var (_fb ,_bgcc uint8 ;_ac ,_cd ,_gg uint16 ;_ge ,_fbg ,_aa byte ;_bdb ,_dc ,_dbd int ;_gba ,_be []byte ;);for _cdb :=0;_cdb < bm .Height ;_cdb ++{_ge ,_fbg =0,0;if _cdb >=2{_ge =bm .Data [(_cdb -2)*bm .RowStride ];};if _cdb >=1{_fbg =bm .Data [(_cdb -1)*bm .RowStride ];if duplicateLineRemoval {_dc =_cdb *bm .RowStride ;_gba =bm .Data [_dc :_dc +bm .RowStride ];_dbd =(_cdb -1)*bm .RowStride ;_be =bm .Data [_dbd :_dbd +bm .RowStride ];if _a .Equal (_gba ,_be ){_bgcc =_fb ^1;_fb =1;}else {_bgcc =_fb ;_fb =0;};};};if duplicateLineRemoval {if _ebf :=_bd .encodeBit (_bd ._eeb ,_agc ,_bgcc );_ebf !=nil {return _ebf ;};if _fb !=0{continue ;};};_aa =bm .Data [_cdb *bm .RowStride ];_ac =uint16 (_ge >>5);_cd =uint16 (_fbg >>4);_ge <<=3;_fbg <<=4;_gg =0;for _bdb =0;_bdb < bm .Width ;_bdb ++{_ecb :=uint32 (_ac <<11|_cd <<4|_gg );_gfa :=(_aa &0x80)>>7;_gbb :=_bd .encodeBit (_bd ._eeb ,_ecb ,_gfa );if _gbb !=nil {return _gbb ;};_ac <<=1;_cd <<=1;_gg <<=1;_ac |=uint16 ((_ge &0x80)>>7);_cd |=uint16 ((_fbg &0x80)>>7);_gg |=uint16 (_gfa );_bb :=_bdb %8;_dcg :=_bdb /8+1;if _bb ==4&&_cdb >=2{_ge =0;if _dcg < bm .RowStride {_ge =bm .Data [(_cdb -2)*bm .RowStride +_dcg ];};}else {_ge <<=1;};if _bb ==3&&_cdb >=1{_fbg =0;if _dcg < bm .RowStride {_fbg =bm .Data [(_cdb -1)*bm .RowStride +_dcg ];};}else {_fbg <<=1;};if _bb ==7{_aa =0;if _dcg < bm .RowStride {_aa =bm .Data [_cdb *bm .RowStride +_dcg ];};}else {_aa <<=1;};_ac &=31;_cd &=127;_gg &=15;};};return nil ;};func (_ab *Encoder )Refine (iTemp ,iTarget *_bc .Bitmap ,ox ,oy int )error {for _eg :=0;_eg < iTarget .Height ;_eg ++{var _bdf int ;_fec :=_eg +oy ;var (_bea ,_egf ,_ae ,_fba ,_beaa uint16 ;_ea ,_bed ,_eac ,_baa ,_bf byte ;);if _fec >=1&&(_fec -1)< iTemp .Height {_ea =iTemp .Data [(_fec -1)*iTemp .RowStride ];};if _fec >=0&&_fec < iTemp .Height {_bed =iTemp .Data [_fec *iTemp .RowStride ];};if _fec >=-1&&_fec +1< iTemp .Height {_eac =iTemp .Data [(_fec +1)*iTemp .RowStride ];};if _eg >=1{_baa =iTarget .Data [(_eg -1)*iTarget .RowStride ];};_bf =iTarget .Data [_eg *iTarget .RowStride ];_cfd :=uint (6+ox );_bea =uint16 (_ea >>_cfd );_egf =uint16 (_bed >>_cfd );_ae =uint16 (_eac >>_cfd );_fba =uint16 (_baa >>6);_gd :=uint (2-ox );_ea <<=_gd ;_bed <<=_gd ;_eac <<=_gd ;_baa <<=2;for _bdf =0;_bdf < iTarget .Width ;_bdf ++{_bca :=(_bea <<10)|(_egf <<7)|(_ae <<4)|(_fba <<1)|_beaa ;_gdc :=_bf >>7;_aeb :=_ab .encodeBit (_ab ._eeb ,uint32 (_bca ),_gdc );if _aeb !=nil {return _aeb ;};_bea <<=1;_egf <<=1;_ae <<=1;_fba <<=1;_bea |=uint16 (_ea >>7);_egf |=uint16 (_bed >>7);_ae |=uint16 (_eac >>7);_fba |=uint16 (_baa >>7);_beaa =uint16 (_gdc );_bgcg :=_bdf %8;_dbe :=_bdf /8+1;if _bgcg ==5+ox {_ea ,_bed ,_eac =0,0,0;if _dbe < iTemp .RowStride &&_fec >=1&&(_fec -1)< iTemp .Height {_ea =iTemp .Data [(_fec -1)*iTemp .RowStride +_dbe ];};if _dbe < iTemp .RowStride &&_fec >=0&&_fec < iTemp .Height {_bed =iTemp .Data [_fec *iTemp .RowStride +_dbe ];};if _dbe < iTemp .RowStride &&_fec >=-1&&(_fec +1)< iTemp .Height {_eac =iTemp .Data [(_fec +1)*iTemp .RowStride +_dbe ];};}else {_ea <<=1;_bed <<=1;_eac <<=1;};if _bgcg ==5&&_eg >=1{_baa =0;if _dbe < iTarget .RowStride {_baa =iTarget .Data [(_eg -1)*iTarget .RowStride +_dbe ];};}else {_baa <<=1;};if _bgcg ==7{_bf =0;if _dbe < iTarget .RowStride {_bf =iTarget .Data [_eg *iTarget .RowStride +_dbe ];};}else {_bf <<=1;};_bea &=7;_egf &=7;_ae &=7;_fba &=7;};};return nil ;};func (_acf *Encoder )code0 (_bfc *codingContext ,_dba uint32 ,_ddg uint16 ,_cdba byte ){if _bfc .mps (_dba )==0{_acf .codeMPS (_bfc ,_dba ,_ddg ,_cdba );}else {_acf .codeLPS (_bfc ,_dba ,_ddg ,_cdba );};};func (_egg *Encoder )codeMPS (_edb *codingContext ,_fab uint32 ,_gca uint16 ,_ffe byte ){_egg ._bg -=_gca ;if _egg ._bg &0x8000!=0{_egg ._db +=uint32 (_gca );return ;};if _egg ._bg < _gca {_egg ._bg =_gca ;}else {_egg ._db +=uint32 (_gca );};_edb ._ed [_fab ]=_gcb [_ffe ]._fge ;_egg .renormalize ();};func (_edd *Encoder )Reset (){_edd ._bg =0x8000;_edd ._db =0;_edd ._bgc =12;_edd ._dab =-1;_edd ._da =0;_edd ._eeg =nil ;_edd ._eeb =_d (_cdd );};var _ _b .WriterTo =&Encoder {};func (_cg Class )String ()string {switch _cg {case IAAI :return "\u0049\u0041\u0041\u0049";case IADH :return "\u0049\u0041\u0044\u0048";case IADS :return "\u0049\u0041\u0044\u0053";case IADT :return "\u0049\u0041\u0044\u0054";case IADW :return "\u0049\u0041\u0044\u0057";case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";case IAIT :return "\u0049\u0041\u0049\u0054";case IARDH :return "\u0049\u0041\u0052D\u0048";case IARDW :return "\u0049\u0041\u0052D\u0057";case IARDX :return "\u0049\u0041\u0052D\u0058";case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";};};func _d (_eb int )*codingContext {return &codingContext {_ed :make ([]byte ,_eb ),_ccbd :make ([]byte ,_eb )};};func (_f *codingContext )mps (_fa uint32 )int {return int (_f ._ccbd [_fa ])};func (_gdce *Encoder )rBlock (){if _gdce ._dab >=0{_gdce .emit ();};_gdce ._dab ++;_gdce ._da =uint8 (_gdce ._db >>20);_gdce ._db &=0xfffff;_gdce ._bgc =7;};func (_fg *Encoder )Flush (){_fg ._ff =0;_fg ._ec =nil ;_fg ._dab =-1};func (_dfeg *Encoder )dataSize ()int {return _gaea *len (_dfeg ._ec )+_dfeg ._ff };var _gcb =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};func (_eegf *Encoder )code1 (_ga *codingContext ,_fc uint32 ,_bdc uint16 ,_ef byte ){if _ga .mps (_fc )==1{_eegf .codeMPS (_ga ,_fc ,_bdc ,_ef );}else {_eegf .codeLPS (_ga ,_fc ,_bdc ,_ef );};};func (_gbc *Encoder )EncodeIAID (symbolCodeLength ,value int )(_cfb error ){_cc .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );if _cfb =_gbc .encodeIAID (symbolCodeLength ,value );_cfb !=nil {return _e .Wrap (_cfb ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};func (_gcaa *Encoder )encodeIAID (_cge ,_gbdf int )error {if _gcaa ._eeg ==nil {_gcaa ._eeg =_d (1<<uint (_cge ));};_geb :=uint32 (1<<uint32 (_cge +1))-1;_gbdf <<=uint (32-_cge );_bec :=uint32 (1);for _fbad :=0;_fbad < _cge ;_fbad ++{_bef :=_bec &_geb ;_efdd :=uint8 ((uint32 (_gbdf )&0x80000000)>>31);if _cfe :=_gcaa .encodeBit (_gcaa ._eeg ,_bef ,_efdd );_cfe !=nil {return _cfe ;};_bec =(_bec <<1)|uint32 (_efdd );_gbdf <<=1;};return nil ;};func (_bgce *Encoder )byteOut (){if _bgce ._da ==0xff{_bgce .rBlock ();return ;};if _bgce ._db < 0x8000000{_bgce .lBlock ();return ;};_bgce ._da ++;if _bgce ._da !=0xff{_bgce .lBlock ();return ;};_bgce ._db &=0x7ffffff;_bgce .rBlock ();};func (_bcf *codingContext )flipMps (_eec uint32 ){_bcf ._ccbd [_eec ]=1-_bcf ._ccbd [_eec ]};func (_acb *Encoder )EncodeInteger (proc Class ,value int )(_bge error ){_cc .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );if _bge =_acb .encodeInteger (proc ,value );_bge !=nil {return _e .Wrap (_bge ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};const (_cdd =65536;_gaea =20*1024;);const (IAAI Class =iota ;IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);func (_bdd *Encoder )encodeOOB (_ddf Class )error {_af :=_bdd ._fe [_ddf ];_gae :=_bdd .encodeBit (_af ,1,1);if _gae !=nil {return _gae ;};_gae =_bdd .encodeBit (_af ,3,0);if _gae !=nil {return _gae ;};_gae =_bdd .encodeBit (_af ,6,0);if _gae !=nil {return _gae ;};_gae =_bdd .encodeBit (_af ,12,0);if _gae !=nil {return _gae ;};return nil ;};const _agc =0x9b25;type codingContext struct{_ed []byte ;_ccbd []byte ;};func (_aaa *Encoder )codeLPS (_dcd *codingContext ,_dfe uint32 ,_efd uint16 ,_cca byte ){_aaa ._bg -=_efd ;if _aaa ._bg < _efd {_aaa ._db +=uint32 (_efd );}else {_aaa ._bg =_efd ;};if _gcb [_cca ]._ebg ==1{_dcd .flipMps (_dfe );};_dcd ._ed [_dfe ]=_gcb [_cca ]._dcb ;_aaa .renormalize ();};func (_gaa *Encoder )setBits (){_ggc :=_gaa ._db +uint32 (_gaa ._bg );_gaa ._db |=0xffff;if _gaa ._db >=_ggc {_gaa ._db -=0x8000;};};func (_cab *Encoder )flush (){_cab .setBits ();_cab ._db <<=_cab ._bgc ;_cab .byteOut ();_cab ._db <<=_cab ._bgc ;_cab .byteOut ();_cab .emit ();if _cab ._da !=0xff{_cab ._dab ++;_cab ._da =0xff;_cab .emit ();};_cab ._dab ++;_cab ._da =0xac;_cab ._dab ++;_cab .emit ();};func New ()*Encoder {_gb :=&Encoder {};_gb .Init ();return _gb };func (_cgg *Encoder )emit (){if _cgg ._ff ==_gaea {_cgg ._ec =append (_cgg ._ec ,_cgg ._cf );_cgg ._cf =make ([]byte ,_gaea );_cgg ._ff =0;};_cgg ._cf [_cgg ._ff ]=_cgg ._da ;_cgg ._ff ++;};