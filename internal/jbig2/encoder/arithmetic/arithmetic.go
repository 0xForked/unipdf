//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_a "bytes";_g "github.com/unidoc/unipdf/v3/common";_b "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_gb "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_c "io";);func (_dbc *Encoder )renormalize (){for {_dbc ._ad <<=1;_dbc ._dc <<=1;_dbc ._ef --;if _dbc ._ef ==0{_dbc .byteOut ();};if (_dbc ._ad &0x8000)!=0{break ;};};};func (_ada *Encoder )code0 (_fdfb *codingContext ,_fdd uint32 ,_dcd uint16 ,_aaf byte ){if _fdfb .mps (_fdd )==0{_ada .codeMPS (_fdfb ,_fdd ,_dcd ,_aaf );}else {_ada .codeLPS (_fdfb ,_fdd ,_dcd ,_aaf );};};func (_cee *Encoder )codeLPS (_cfb *codingContext ,_ggd uint32 ,_dbe uint16 ,_aac byte ){_cee ._ad -=_dbe ;if _cee ._ad < _dbe {_cee ._dc +=uint32 (_dbe );}else {_cee ._ad =_dbe ;};if _dd [_aac ]._ebg ==1{_cfb .flipMps (_ggd );};_cfb ._eb [_ggd ]=_dd [_aac ]._cdg ;_cee .renormalize ();};func (_fc *codingContext )mps (_fd uint32 )int {return int (_fc ._df [_fd ])};func (_cc Class )String ()string {switch _cc {case IAAI :return "\u0049\u0041\u0041\u0049";case IADH :return "\u0049\u0041\u0044\u0048";case IADS :return "\u0049\u0041\u0044\u0053";case IADT :return "\u0049\u0041\u0044\u0054";case IADW :return "\u0049\u0041\u0044\u0057";case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";case IAIT :return "\u0049\u0041\u0049\u0054";case IARDH :return "\u0049\u0041\u0052D\u0048";case IARDW :return "\u0049\u0041\u0052D\u0057";case IARDX :return "\u0049\u0041\u0052D\u0058";case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";};};func _ec (_af int )*codingContext {return &codingContext {_eb :make ([]byte ,_af ),_df :make ([]byte ,_af )};};func (_gea *Encoder )setBits (){_cggc :=_gea ._dc +uint32 (_gea ._ad );_gea ._dc |=0xffff;if _gea ._dc >=_cggc {_gea ._dc -=0x8000;};};func (_gdd *Encoder )Init (){_gdd ._fa =_ec (_ecbf );_gdd ._ad =0x8000;_gdd ._dc =0;_gdd ._ef =12;_gdd ._fdf =-1;_gdd ._gfa =0;_gdd ._dg =0;_gdd ._ee =make ([]byte ,_gbf );for _dgd :=0;_dgd < len (_gdd ._fb );_dgd ++{_gdd ._fb [_dgd ]=_ec (512);};_gdd ._ac =nil ;};type codingContext struct{_eb []byte ;_df []byte ;};func (_bfe *Encoder )Refine (iTemp ,iTarget *_b .Bitmap ,ox ,oy int )error {for _dac :=0;_dac < iTarget .Height ;_dac ++{var _abgf int ;_fg :=_dac +oy ;var (_gbcd ,_be ,_dgb ,_ead ,_eaf uint16 ;_eafb ,_eff ,_ccc ,_gfd ,_fcg byte ;);if _fg >=1&&(_fg -1)< iTemp .Height {_eafb =iTemp .Data [(_fg -1)*iTemp .RowStride ];};if _fg >=0&&_fg < iTemp .Height {_eff =iTemp .Data [_fg *iTemp .RowStride ];};if _fg >=-1&&_fg +1< iTemp .Height {_ccc =iTemp .Data [(_fg +1)*iTemp .RowStride ];};if _dac >=1{_gfd =iTarget .Data [(_dac -1)*iTarget .RowStride ];};_fcg =iTarget .Data [_dac *iTarget .RowStride ];_aga :=uint (6+ox );_gbcd =uint16 (_eafb >>_aga );_be =uint16 (_eff >>_aga );_dgb =uint16 (_ccc >>_aga );_ead =uint16 (_gfd >>6);_dcf :=uint (2-ox );_eafb <<=_dcf ;_eff <<=_dcf ;_ccc <<=_dcf ;_gfd <<=2;for _abgf =0;_abgf < iTarget .Width ;_abgf ++{_aa :=(_gbcd <<10)|(_be <<7)|(_dgb <<4)|(_ead <<1)|_eaf ;_eafbb :=_fcg >>7;_eeb :=_bfe .encodeBit (_bfe ._fa ,uint32 (_aa ),_eafbb );if _eeb !=nil {return _eeb ;};_gbcd <<=1;_be <<=1;_dgb <<=1;_ead <<=1;_gbcd |=uint16 (_eafb >>7);_be |=uint16 (_eff >>7);_dgb |=uint16 (_ccc >>7);_ead |=uint16 (_gfd >>7);_eaf =uint16 (_eafbb );_bdd :=_abgf %8;_dcb :=_abgf /8+1;if _bdd ==5+ox {_eafb ,_eff ,_ccc =0,0,0;if _dcb < iTemp .RowStride &&_fg >=1&&(_fg -1)< iTemp .Height {_eafb =iTemp .Data [(_fg -1)*iTemp .RowStride +_dcb ];};if _dcb < iTemp .RowStride &&_fg >=0&&_fg < iTemp .Height {_eff =iTemp .Data [_fg *iTemp .RowStride +_dcb ];};if _dcb < iTemp .RowStride &&_fg >=-1&&(_fg +1)< iTemp .Height {_ccc =iTemp .Data [(_fg +1)*iTemp .RowStride +_dcb ];};}else {_eafb <<=1;_eff <<=1;_ccc <<=1;};if _bdd ==5&&_dac >=1{_gfd =0;if _dcb < iTarget .RowStride {_gfd =iTarget .Data [(_dac -1)*iTarget .RowStride +_dcb ];};}else {_gfd <<=1;};if _bdd ==7{_fcg =0;if _dcb < iTarget .RowStride {_fcg =iTarget .Data [_dac *iTarget .RowStride +_dcb ];};}else {_fcg <<=1;};_gbcd &=7;_be &=7;_dgb &=7;_ead &=7;};};return nil ;};func (_cea *Encoder )rBlock (){if _cea ._fdf >=0{_cea .emit ();};_cea ._fdf ++;_cea ._gfa =uint8 (_cea ._dc >>20);_cea ._dc &=0xfffff;_cea ._ef =7;};func (_fgf *Encoder )encodeInteger (_aeb Class ,_dce int )error {const _ceeg ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";if _dce > 2000000000||_dce < -2000000000{return _gb .Errorf (_ceeg ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_dce );};_gegg :=_fgf ._fb [_aeb ];_dab :=uint32 (1);var _ebf int ;for ;;_ebf ++{if _gf [_ebf ]._d <=_dce &&_gf [_ebf ]._e >=_dce {break ;};};if _dce < 0{_dce =-_dce ;};_dce -=int (_gf [_ebf ]._ge );_bc :=_gf [_ebf ]._bd ;for _abf :=uint8 (0);_abf < _gf [_ebf ]._eg ;_abf ++{_abfc :=_bc &1;if _fgfd :=_fgf .encodeBit (_gegg ,_dab ,_abfc );_fgfd !=nil {return _gb .Wrap (_fgfd ,_ceeg ,"");};_bc >>=1;if _dab &0x100> 0{_dab =(((_dab <<1)|uint32 (_abfc ))&0x1ff)|0x100;}else {_dab =(_dab <<1)|uint32 (_abfc );};};_dce <<=32-_gf [_ebf ]._ca ;for _ggg :=uint8 (0);_ggg < _gf [_ebf ]._ca ;_ggg ++{_dga :=uint8 ((uint32 (_dce )&0x80000000)>>31);if _acg :=_fgf .encodeBit (_gegg ,_dab ,_dga );_acg !=nil {return _gb .Wrap (_acg ,_ceeg ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");};_dce <<=1;if _dab &0x100!=0{_dab =(((_dab <<1)|uint32 (_dga ))&0x1ff)|0x100;}else {_dab =(_dab <<1)|uint32 (_dga );};};return nil ;};func (_adb *Encoder )EncodeBitmap (bm *_b .Bitmap ,duplicateLineRemoval bool )error {_g .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );var (_ag ,_ab uint8 ;_cd ,_gba ,_aef uint16 ;_caf ,_dgc ,_efa byte ;_cg ,_efd ,_cff int ;_fda ,_gee []byte ;);for _abg :=0;_abg < bm .Height ;_abg ++{_caf ,_dgc =0,0;if _abg >=2{_caf =bm .Data [(_abg -2)*bm .RowStride ];};if _abg >=1{_dgc =bm .Data [(_abg -1)*bm .RowStride ];if duplicateLineRemoval {_efd =_abg *bm .RowStride ;_fda =bm .Data [_efd :_efd +bm .RowStride ];_cff =(_abg -1)*bm .RowStride ;_gee =bm .Data [_cff :_cff +bm .RowStride ];if _a .Equal (_fda ,_gee ){_ab =_ag ^1;_ag =1;}else {_ab =_ag ;_ag =0;};};};if duplicateLineRemoval {if _ea :=_adb .encodeBit (_adb ._fa ,_cf ,_ab );_ea !=nil {return _ea ;};if _ag !=0{continue ;};};_efa =bm .Data [_abg *bm .RowStride ];_cd =uint16 (_caf >>5);_gba =uint16 (_dgc >>4);_caf <<=3;_dgc <<=4;_aef =0;for _cg =0;_cg < bm .Width ;_cg ++{_cge :=uint32 (_cd <<11|_gba <<4|_aef );_gc :=(_efa &0x80)>>7;_de :=_adb .encodeBit (_adb ._fa ,_cge ,_gc );if _de !=nil {return _de ;};_cd <<=1;_gba <<=1;_aef <<=1;_cd |=uint16 ((_caf &0x80)>>7);_gba |=uint16 ((_dgc &0x80)>>7);_aef |=uint16 (_gc );_bde :=_cg %8;_ce :=_cg /8+1;if _bde ==4&&_abg >=2{_caf =0;if _ce < bm .RowStride {_caf =bm .Data [(_abg -2)*bm .RowStride +_ce ];};}else {_caf <<=1;};if _bde ==3&&_abg >=1{_dgc =0;if _ce < bm .RowStride {_dgc =bm .Data [(_abg -1)*bm .RowStride +_ce ];};}else {_dgc <<=1;};if _bde ==7{_efa =0;if _ce < bm .RowStride {_efa =bm .Data [_abg *bm .RowStride +_ce ];};}else {_efa <<=1;};_cd &=31;_gba &=127;_aef &=15;};};return nil ;};func (_fbf *Encoder )codeMPS (_bfa *codingContext ,_cgg uint32 ,_bb uint16 ,_fea byte ){_fbf ._ad -=_bb ;if _fbf ._ad &0x8000!=0{_fbf ._dc +=uint32 (_bb );return ;};if _fbf ._ad < _bb {_fbf ._ad =_bb ;}else {_fbf ._dc +=uint32 (_bb );};_bfa ._eb [_cgg ]=_dd [_fea ]._eac ;_fbf .renormalize ();};func (_geg *Encoder )DataSize ()int {return _geg .dataSize ()};var _ _c .WriterTo =&Encoder {};func (_effe *Encoder )Reset (){_effe ._ad =0x8000;_effe ._dc =0;_effe ._ef =12;_effe ._fdf =-1;_effe ._gfa =0;_effe ._ac =nil ;_effe ._fa =_ec (_ecbf );};func (_cfg *Encoder )emit (){if _cfg ._dg ==_gbf {_cfg ._gbc =append (_cfg ._gbc ,_cfg ._ee );_cfg ._ee =make ([]byte ,_gbf );_cfg ._dg =0;};_cfg ._ee [_cfg ._dg ]=_cfg ._gfa ;_cfg ._dg ++;};func (_fe *Encoder )EncodeInteger (proc Class ,value int )(_cafd error ){_g .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );if _cafd =_fe .encodeInteger (proc ,value );_cafd !=nil {return _gb .Wrap (_cafd ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};func (_afb *Encoder )Flush (){_afb ._dg =0;_afb ._gbc =nil ;_afb ._fdf =-1};type Class int ;func (_bgb *Encoder )dataSize ()int {return _gbf *len (_bgb ._gbc )+_bgb ._dg };const _cf =0x9b25;var _dd =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};func (_deb *Encoder )byteOut (){if _deb ._gfa ==0xff{_deb .rBlock ();return ;};if _deb ._dc < 0x8000000{_deb .lBlock ();return ;};_deb ._gfa ++;if _deb ._gfa !=0xff{_deb .lBlock ();return ;};_deb ._dc &=0x7ffffff;_deb .rBlock ();};const (IAAI Class =iota ;IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);func (_efb *Encoder )encodeOOB (_eeed Class )error {_acgb :=_efb ._fb [_eeed ];_ade :=_efb .encodeBit (_acgb ,1,1);if _ade !=nil {return _ade ;};_ade =_efb .encodeBit (_acgb ,3,0);if _ade !=nil {return _ade ;};_ade =_efb .encodeBit (_acgb ,6,0);if _ade !=nil {return _ade ;};_ade =_efb .encodeBit (_acgb ,12,0);if _ade !=nil {return _ade ;};return nil ;};var _gf =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};func (_ecb *Encoder )code1 (_ece *codingContext ,_fcc uint32 ,_gcf uint16 ,_eeg byte ){if _ece .mps (_fcc )==1{_ecb .codeMPS (_ece ,_fcc ,_gcf ,_eeg );}else {_ecb .codeLPS (_ece ,_fcc ,_gcf ,_eeg );};};func (_acf *Encoder )Final (){_acf .flush ()};func (_gg *Encoder )EncodeIAID (symbolCodeLength ,value int )(_gdb error ){_g .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );if _gdb =_gg .encodeIAID (symbolCodeLength ,value );_gdb !=nil {return _gb .Wrap (_gdb ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};type Encoder struct{_dc uint32 ;_ad uint16 ;_ef ,_gfa uint8 ;_fdf int ;_gd int ;_gbc [][]byte ;_ee []byte ;_dg int ;_fa *codingContext ;_fb [13]*codingContext ;_ac *codingContext ;};func (_ga *Encoder )encodeIAID (_fag ,_acb int )error {if _ga ._ac ==nil {_ga ._ac =_ec (1<<uint (_fag ));};_gfc :=uint32 (1<<uint32 (_fag +1))-1;_acb <<=uint (32-_fag );_edc :=uint32 (1);for _caa :=0;_caa < _fag ;_caa ++{_agd :=_edc &_gfc ;_fbb :=uint8 ((uint32 (_acb )&0x80000000)>>31);if _aace :=_ga .encodeBit (_ga ._ac ,_agd ,_fbb );_aace !=nil {return _aace ;};_edc =(_edc <<1)|uint32 (_fbb );_acb <<=1;};return nil ;};type intEncRangeS struct{_d ,_e int ;_bd ,_eg uint8 ;_ge uint16 ;_ca uint8 ;};func New ()*Encoder {_bf :=&Encoder {};_bf .Init ();return _bf };type state struct{_bce uint16 ;_eac ,_cdg uint8 ;_ebg uint8 ;};func (_dag *Encoder )lBlock (){if _dag ._fdf >=0{_dag .emit ();};_dag ._fdf ++;_dag ._gfa =uint8 (_dag ._dc >>19);_dag ._dc &=0x7ffff;_dag ._ef =8;};const (_ecbf =65536;_gbf =20*1024;);func (_bg *codingContext )flipMps (_ae uint32 ){_bg ._df [_ae ]=1-_bg ._df [_ae ]};func (_da *Encoder )EncodeOOB (proc Class )(_db error ){_g .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );if _db =_da .encodeOOB (proc );_db !=nil {return _gb .Wrap (_db ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};func (_edd *Encoder )encodeBit (_dgdg *codingContext ,_efda uint32 ,_fbfe uint8 )error {const _gdc ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";_edd ._gd ++;if _efda >=uint32 (len (_dgdg ._eb )){return _gb .Errorf (_gdc ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_efda );};_ccb :=_dgdg ._eb [_efda ];_cffe :=_dgdg .mps (_efda );_cffg :=_dd [_ccb ]._bce ;_g .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_edd ._gd ,_fbfe ,_ccb ,_cffe ,_cffg ,_edd ._ad ,_edd ._dc ,_edd ._ef ,_edd ._gfa ,_edd ._fdf );if _fbfe ==0{_edd .code0 (_dgdg ,_efda ,_cffg ,_ccb );}else {_edd .code1 (_dgdg ,_efda ,_cffg ,_ccb );};return nil ;};func (_ba *Encoder )flush (){_ba .setBits ();_ba ._dc <<=_ba ._ef ;_ba .byteOut ();_ba ._dc <<=_ba ._ef ;_ba .byteOut ();_ba .emit ();if _ba ._gfa !=0xff{_ba ._fdf ++;_ba ._gfa =0xff;_ba .emit ();};_ba ._fdf ++;_ba ._gfa =0xac;_ba ._fdf ++;_ba .emit ();};func (_eee *Encoder )WriteTo (w _c .Writer )(int64 ,error ){const _ebc ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";var _dea int64 ;for _fad ,_adc :=range _eee ._gbc {_ed ,_deg :=w .Write (_adc );if _deg !=nil {return 0,_gb .Wrapf (_deg ,_ebc ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_fad );};_dea +=int64 (_ed );};_eee ._ee =_eee ._ee [:_eee ._dg ];_ccg ,_aee :=w .Write (_eee ._ee );if _aee !=nil {return 0,_gb .Wrap (_aee ,_ebc ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_dea +=int64 (_ccg );return _dea ,nil ;};