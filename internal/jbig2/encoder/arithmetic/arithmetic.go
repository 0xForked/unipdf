//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_b "bytes";_ab "github.com/unidoc/unipdf/v3/common";_d "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_dg "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_ad "io";);func (_gged *Encoder )encodeIAID (_fcb ,_aab int )error {if _gged ._ga ==nil {_gged ._ga =_fb (1<<uint (_fcb ));
};_aabe :=uint32 (1<<uint32 (_fcb +1))-1;_aab <<=uint (32-_fcb );_gdd :=uint32 (1);for _fee :=0;_fee < _fcb ;_fee ++{_cfb :=_gdd &_aabe ;_egf :=uint8 ((uint32 (_aab )&0x80000000)>>31);if _gfg :=_gged .encodeBit (_gged ._ga ,_cfb ,_egf );_gfg !=nil {return _gfg ;
};_gdd =(_gdd <<1)|uint32 (_egf );_aab <<=1;};return nil ;};func (_aec *Encoder )EncodeOOB (proc Class )(_aa error ){_ab .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );
if _aa =_aec .encodeOOB (proc );_aa !=nil {return _dg .Wrap (_aa ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};type Encoder struct{_ae uint32 ;_dgg uint16 ;_ac ,_aea uint8 ;_adgg int ;_bc int ;_ce [][]byte ;_gd []byte ;_ef int ;_dgb *codingContext ;
_fc [13]*codingContext ;_ga *codingContext ;};func (_agg *Encoder )WriteTo (w _ad .Writer )(int64 ,error ){const _aae ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";var _cfc int64 ;for _bba ,_cfce :=range _agg ._ce {_cddg ,_gfc :=w .Write (_cfce );
if _gfc !=nil {return 0,_dg .Wrapf (_gfc ,_aae ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_bba );};_cfc +=int64 (_cddg );};_agg ._gd =_agg ._gd [:_agg ._ef ];
_eaa ,_ff :=w .Write (_agg ._gd );if _ff !=nil {return 0,_dg .Wrap (_ff ,_aae ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_cfc +=int64 (_eaa );return _cfc ,nil ;};func (_fgc *Encoder )Init (){_fgc ._dgb =_fb (_aef );
_fgc ._dgg =0x8000;_fgc ._ae =0;_fgc ._ac =12;_fgc ._adgg =-1;_fgc ._aea =0;_fgc ._ef =0;_fgc ._gd =make ([]byte ,_dcce );for _fde :=0;_fde < len (_fgc ._fc );_fde ++{_fgc ._fc [_fde ]=_fb (512);};_fgc ._ga =nil ;};func (_egb *Encoder )flush (){_egb .setBits ();
_egb ._ae <<=_egb ._ac ;_egb .byteOut ();_egb ._ae <<=_egb ._ac ;_egb .byteOut ();_egb .emit ();if _egb ._aea !=0xff{_egb ._adgg ++;_egb ._aea =0xff;_egb .emit ();};_egb ._adgg ++;_egb ._aea =0xac;_egb ._adgg ++;_egb .emit ();};func (_ba *Encoder )EncodeIAID (symbolCodeLength ,value int )(_ec error ){_ab .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );
if _ec =_ba .encodeIAID (symbolCodeLength ,value );_ec !=nil {return _dg .Wrap (_ec ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};type state struct{_acf uint16 ;_efe ,_gebc uint8 ;_cgd uint8 ;};var _fd =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};
func (_gfcg *Encoder )encodeInteger (_gefa Class ,_debe int )error {const _gcf ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";if _debe > 2000000000||_debe < -2000000000{return _dg .Errorf (_gcf ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_debe );
};_gee :=_gfcg ._fc [_gefa ];_dacd :=uint32 (1);var _gbg int ;for ;;_gbg ++{if _fd [_gbg ]._de <=_debe &&_fd [_gbg ]._f >=_debe {break ;};};if _debe < 0{_debe =-_debe ;};_debe -=int (_fd [_gbg ]._c );_fec :=_fd [_gbg ]._af ;for _baa :=uint8 (0);_baa < _fd [_gbg ]._fg ;
_baa ++{_ggaa :=_fec &1;if _bbc :=_gfcg .encodeBit (_gee ,_dacd ,_ggaa );_bbc !=nil {return _dg .Wrap (_bbc ,_gcf ,"");};_fec >>=1;if _dacd &0x100> 0{_dacd =(((_dacd <<1)|uint32 (_ggaa ))&0x1ff)|0x100;}else {_dacd =(_dacd <<1)|uint32 (_ggaa );};};_debe <<=32-_fd [_gbg ]._adg ;
for _eba :=uint8 (0);_eba < _fd [_gbg ]._adg ;_eba ++{_fdd :=uint8 ((uint32 (_debe )&0x80000000)>>31);if _fbdg :=_gfcg .encodeBit (_gee ,_dacd ,_fdd );_fbdg !=nil {return _dg .Wrap (_fbdg ,_gcf ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");
};_debe <<=1;if _dacd &0x100!=0{_dacd =(((_dacd <<1)|uint32 (_fdd ))&0x1ff)|0x100;}else {_dacd =(_dacd <<1)|uint32 (_fdd );};};return nil ;};func (_dgc *Encoder )lBlock (){if _dgc ._adgg >=0{_dgc .emit ();};_dgc ._adgg ++;_dgc ._aea =uint8 (_dgc ._ae >>19);
_dgc ._ae &=0x7ffff;_dgc ._ac =8;};func (_bab *Encoder )code0 (_bea *codingContext ,_afe uint32 ,_cec uint16 ,_db byte ){if _bea .mps (_afe )==0{_bab .codeMPS (_bea ,_afe ,_cec ,_db );}else {_bab .codeLPS (_bea ,_afe ,_cec ,_db );};};func (_fcd *Encoder )EncodeInteger (proc Class ,value int )(_gcg error ){_ab .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );
if _gcg =_fcd .encodeInteger (proc ,value );_gcg !=nil {return _dg .Wrap (_gcg ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};func (_dab *Encoder )setBits (){_fgcc :=_dab ._ae +uint32 (_dab ._dgg );
_dab ._ae |=0xffff;if _dab ._ae >=_fgcc {_dab ._ae -=0x8000;};};func New ()*Encoder {_fe :=&Encoder {};_fe .Init ();return _fe };func (_aad *Encoder )encodeOOB (_bge Class )error {_beg :=_aad ._fc [_bge ];_bfd :=_aad .encodeBit (_beg ,1,1);if _bfd !=nil {return _bfd ;
};_bfd =_aad .encodeBit (_beg ,3,0);if _bfd !=nil {return _bfd ;};_bfd =_aad .encodeBit (_beg ,6,0);if _bfd !=nil {return _bfd ;};_bfd =_aad .encodeBit (_beg ,12,0);if _bfd !=nil {return _bfd ;};return nil ;};func (_eg *Encoder )Final (){_eg .flush ()};
func (_ceb *Encoder )rBlock (){if _ceb ._adgg >=0{_ceb .emit ();};_ceb ._adgg ++;_ceb ._aea =uint8 (_ceb ._ae >>20);_ceb ._ae &=0xfffff;_ceb ._ac =7;};const (_aef =65536;_dcce =20*1024;);func (_gbc *Encoder )renormalize (){for {_gbc ._dgg <<=1;_gbc ._ae <<=1;
_gbc ._ac --;if _gbc ._ac ==0{_gbc .byteOut ();};if (_gbc ._dgg &0x8000)!=0{break ;};};};func _fb (_ea int )*codingContext {return &codingContext {_e :make ([]byte ,_ea ),_cg :make ([]byte ,_ea )};};func (_gf *Encoder )DataSize ()int {return _gf .dataSize ()};
func (_bgd *Encoder )codeLPS (_cga *codingContext ,_deb uint32 ,_bec uint16 ,_eag byte ){_bgd ._dgg -=_bec ;if _bgd ._dgg < _bec {_bgd ._ae +=uint32 (_bec );}else {_bgd ._dgg =_bec ;};if _cag [_eag ]._cgd ==1{_cga .flipMps (_deb );};_cga ._e [_deb ]=_cag [_eag ]._gebc ;
_bgd .renormalize ();};func (_fdg *Encoder )dataSize ()int {return _dcce *len (_fdg ._ce )+_fdg ._ef };func (_be *Encoder )EncodeBitmap (bm *_d .Bitmap ,duplicateLineRemoval bool )error {_ab .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );
var (_cbe ,_gg uint8 ;_dd ,_afb ,_cf uint16 ;_cd ,_ed ,_gdg byte ;_gaa ,_dde ,_gge int ;_gb ,_fa []byte ;);for _gc :=0;_gc < bm .Height ;_gc ++{_cd ,_ed =0,0;if _gc >=2{_cd =bm .Data [(_gc -2)*bm .RowStride ];};if _gc >=1{_ed =bm .Data [(_gc -1)*bm .RowStride ];
if duplicateLineRemoval {_dde =_gc *bm .RowStride ;_gb =bm .Data [_dde :_dde +bm .RowStride ];_gge =(_gc -1)*bm .RowStride ;_fa =bm .Data [_gge :_gge +bm .RowStride ];if _b .Equal (_gb ,_fa ){_gg =_cbe ^1;_cbe =1;}else {_gg =_cbe ;_cbe =0;};};};if duplicateLineRemoval {if _deg :=_be .encodeBit (_be ._dgb ,_agf ,_gg );
_deg !=nil {return _deg ;};if _cbe !=0{continue ;};};_gdg =bm .Data [_gc *bm .RowStride ];_dd =uint16 (_cd >>5);_afb =uint16 (_ed >>4);_cd <<=3;_ed <<=4;_cf =0;for _gaa =0;_gaa < bm .Width ;_gaa ++{_ge :=uint32 (_dd <<11|_afb <<4|_cf );_fbc :=(_gdg &0x80)>>7;
_cdd :=_be .encodeBit (_be ._dgb ,_ge ,_fbc );if _cdd !=nil {return _cdd ;};_dd <<=1;_afb <<=1;_cf <<=1;_dd |=uint16 ((_cd &0x80)>>7);_afb |=uint16 ((_ed &0x80)>>7);_cf |=uint16 (_fbc );_gab :=_gaa %8;_efd :=_gaa /8+1;if _gab ==4&&_gc >=2{_cd =0;if _efd < bm .RowStride {_cd =bm .Data [(_gc -2)*bm .RowStride +_efd ];
};}else {_cd <<=1;};if _gab ==3&&_gc >=1{_ed =0;if _efd < bm .RowStride {_ed =bm .Data [(_gc -1)*bm .RowStride +_efd ];};}else {_ed <<=1;};if _gab ==7{_gdg =0;if _efd < bm .RowStride {_gdg =bm .Data [_gc *bm .RowStride +_efd ];};}else {_gdg <<=1;};_dd &=31;
_afb &=127;_cf &=15;};};return nil ;};const (IAAI Class =iota ;IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);func (_g *codingContext )flipMps (_eb uint32 ){_g ._cg [_eb ]=1-_g ._cg [_eb ]};func (_cef *Encoder )emit (){if _cef ._ef ==_dcce {_cef ._ce =append (_cef ._ce ,_cef ._gd );
_cef ._gd =make ([]byte ,_dcce );_cef ._ef =0;};_cef ._gd [_cef ._ef ]=_cef ._aea ;_cef ._ef ++;};func (_ddd *Encoder )code1 (_dcg *codingContext ,_bbd uint32 ,_gfd uint16 ,_ecb byte ){if _dcg .mps (_bbd )==1{_ddd .codeMPS (_dcg ,_bbd ,_gfd ,_ecb );}else {_ddd .codeLPS (_dcg ,_bbd ,_gfd ,_ecb );
};};var _ _ad .WriterTo =&Encoder {};func (_ggg *Encoder )Flush (){_ggg ._ef =0;_ggg ._ce =nil ;_ggg ._adgg =-1};type Class int ;func (_eab *Encoder )Reset (){_eab ._dgg =0x8000;_eab ._ae =0;_eab ._ac =12;_eab ._adgg =-1;_eab ._aea =0;_eab ._ga =nil ;_eab ._dgb =_fb (_aef );
};func (_ggb *Encoder )byteOut (){if _ggb ._aea ==0xff{_ggb .rBlock ();return ;};if _ggb ._ae < 0x8000000{_ggb .lBlock ();return ;};_ggb ._aea ++;if _ggb ._aea !=0xff{_ggb .lBlock ();return ;};_ggb ._ae &=0x7ffffff;_ggb .rBlock ();};type codingContext struct{_e []byte ;
_cg []byte ;};var _cag =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
func (_aee *Encoder )encodeBit (_gef *codingContext ,_dcc uint32 ,_dfd uint8 )error {const _geb ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";_aee ._bc ++;if _dcc >=uint32 (len (_gef ._e )){return _dg .Errorf (_geb ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_dcc );
};_fba :=_gef ._e [_dcc ];_ddeg :=_gef .mps (_dcc );_gcc :=_cag [_fba ]._acf ;_ab .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_aee ._bc ,_dfd ,_fba ,_ddeg ,_gcc ,_aee ._dgg ,_aee ._ae ,_aee ._ac ,_aee ._aea ,_aee ._adgg );
if _dfd ==0{_aee .code0 (_gef ,_dcc ,_gcc ,_fba );}else {_aee .code1 (_gef ,_dcc ,_gcc ,_fba );};return nil ;};func (_bce *Encoder )codeMPS (_df *codingContext ,_ca uint32 ,_aaa uint16 ,_cecg byte ){_bce ._dgg -=_aaa ;if _bce ._dgg &0x8000!=0{_bce ._ae +=uint32 (_aaa );
return ;};if _bce ._dgg < _aaa {_bce ._dgg =_aaa ;}else {_bce ._ae +=uint32 (_aaa );};_df ._e [_ca ]=_cag [_cecg ]._efe ;_bce .renormalize ();};const _agf =0x9b25;func (_cb *codingContext )mps (_cgb uint32 )int {return int (_cb ._cg [_cgb ])};type intEncRangeS struct{_de ,_f int ;
_af ,_fg uint8 ;_c uint16 ;_adg uint8 ;};func (_ecg *Encoder )Refine (iTemp ,iTarget *_d .Bitmap ,ox ,oy int )error {for _bf :=0;_bf < iTarget .Height ;_bf ++{var _da int ;_abc :=_bf +oy ;var (_abd ,_dac ,_bb ,_fdeg ,_gcd uint16 ;_dc ,_aac ,_bd ,_bg ,_dgga byte ;
);if _abc >=1&&(_abc -1)< iTemp .Height {_dc =iTemp .Data [(_abc -1)*iTemp .RowStride ];};if _abc >=0&&_abc < iTemp .Height {_aac =iTemp .Data [_abc *iTemp .RowStride ];};if _abc >=-1&&_abc +1< iTemp .Height {_bd =iTemp .Data [(_abc +1)*iTemp .RowStride ];
};if _bf >=1{_bg =iTarget .Data [(_bf -1)*iTarget .RowStride ];};_dgga =iTarget .Data [_bf *iTarget .RowStride ];_gga :=uint (6+ox );_abd =uint16 (_dc >>_gga );_dac =uint16 (_aac >>_gga );_bb =uint16 (_bd >>_gga );_fdeg =uint16 (_bg >>6);_cdc :=uint (2-ox );
_dc <<=_cdc ;_aac <<=_cdc ;_bd <<=_cdc ;_bg <<=2;for _da =0;_da < iTarget .Width ;_da ++{_ee :=(_abd <<10)|(_dac <<7)|(_bb <<4)|(_fdeg <<1)|_gcd ;_gde :=_dgga >>7;_eca :=_ecg .encodeBit (_ecg ._dgb ,uint32 (_ee ),_gde );if _eca !=nil {return _eca ;};_abd <<=1;
_dac <<=1;_bb <<=1;_fdeg <<=1;_abd |=uint16 (_dc >>7);_dac |=uint16 (_aac >>7);_bb |=uint16 (_bd >>7);_fdeg |=uint16 (_bg >>7);_gcd =uint16 (_gde );_fbd :=_da %8;_cgf :=_da /8+1;if _fbd ==5+ox {_dc ,_aac ,_bd =0,0,0;if _cgf < iTemp .RowStride &&_abc >=1&&(_abc -1)< iTemp .Height {_dc =iTemp .Data [(_abc -1)*iTemp .RowStride +_cgf ];
};if _cgf < iTemp .RowStride &&_abc >=0&&_abc < iTemp .Height {_aac =iTemp .Data [_abc *iTemp .RowStride +_cgf ];};if _cgf < iTemp .RowStride &&_abc >=-1&&(_abc +1)< iTemp .Height {_bd =iTemp .Data [(_abc +1)*iTemp .RowStride +_cgf ];};}else {_dc <<=1;
_aac <<=1;_bd <<=1;};if _fbd ==5&&_bf >=1{_bg =0;if _cgf < iTarget .RowStride {_bg =iTarget .Data [(_bf -1)*iTarget .RowStride +_cgf ];};}else {_bg <<=1;};if _fbd ==7{_dgga =0;if _cgf < iTarget .RowStride {_dgga =iTarget .Data [_bf *iTarget .RowStride +_cgf ];
};}else {_dgga <<=1;};_abd &=7;_dac &=7;_bb &=7;_fdeg &=7;};};return nil ;};func (_ag Class )String ()string {switch _ag {case IAAI :return "\u0049\u0041\u0041\u0049";case IADH :return "\u0049\u0041\u0044\u0048";case IADS :return "\u0049\u0041\u0044\u0053";
case IADT :return "\u0049\u0041\u0044\u0054";case IADW :return "\u0049\u0041\u0044\u0057";case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";case IAIT :return "\u0049\u0041\u0049\u0054";case IARDH :return "\u0049\u0041\u0052D\u0048";
case IARDW :return "\u0049\u0041\u0052D\u0057";case IARDX :return "\u0049\u0041\u0052D\u0058";case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";};};