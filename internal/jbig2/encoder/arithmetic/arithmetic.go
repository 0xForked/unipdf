//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_f "bytes";_df "github.com/unidoc/unipdf/v3/common";_g "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_b "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_a "io";);func (_eba *Encoder )setBits (){_fb :=_eba ._fa +uint32 (_eba ._dg );
_eba ._fa |=0xffff;if _eba ._fa >=_fb {_eba ._fa -=0x8000;};};type Class int ;type codingContext struct{_c []byte ;_dfe []byte ;};func (_agfe *Encoder )EncodeOOB (proc Class )(_baf error ){_df .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );
if _baf =_agfe .encodeOOB (proc );_baf !=nil {return _b .Wrap (_baf ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};func (_aad *Encoder )EncodeBitmap (bm *_g .Bitmap ,duplicateLineRemoval bool )error {_df .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );
var (_fg ,_ag uint8 ;_dec ,_ab ,_bc uint16 ;_fac ,_bag ,_abb byte ;_ffc ,_dgb ,_deg int ;_agf ,_baa []byte ;);for _gc :=0;_gc < bm .Height ;_gc ++{_fac ,_bag =0,0;if _gc >=2{_fac =bm .Data [(_gc -2)*bm .RowStride ];};if _gc >=1{_bag =bm .Data [(_gc -1)*bm .RowStride ];
if duplicateLineRemoval {_dgb =_gc *bm .RowStride ;_agf =bm .Data [_dgb :_dgb +bm .RowStride ];_deg =(_gc -1)*bm .RowStride ;_baa =bm .Data [_deg :_deg +bm .RowStride ];if _f .Equal (_agf ,_baa ){_ag =_fg ^1;_fg =1;}else {_ag =_fg ;_fg =0;};};};if duplicateLineRemoval {if _ecg :=_aad .encodeBit (_aad ._cg ,_beg ,_ag );
_ecg !=nil {return _ecg ;};if _fg !=0{continue ;};};_abb =bm .Data [_gc *bm .RowStride ];_dec =uint16 (_fac >>5);_ab =uint16 (_bag >>4);_fac <<=3;_bag <<=4;_bc =0;for _ffc =0;_ffc < bm .Width ;_ffc ++{_abbf :=uint32 (_dec <<11|_ab <<4|_bc );_ad :=(_abb &0x80)>>7;
_cb :=_aad .encodeBit (_aad ._cg ,_abbf ,_ad );if _cb !=nil {return _cb ;};_dec <<=1;_ab <<=1;_bc <<=1;_dec |=uint16 ((_fac &0x80)>>7);_ab |=uint16 ((_bag &0x80)>>7);_bc |=uint16 (_ad );_ae :=_ffc %8;_cbb :=_ffc /8+1;if _ae ==4&&_gc >=2{_fac =0;if _cbb < bm .RowStride {_fac =bm .Data [(_gc -2)*bm .RowStride +_cbb ];
};}else {_fac <<=1;};if _ae ==3&&_gc >=1{_bag =0;if _cbb < bm .RowStride {_bag =bm .Data [(_gc -1)*bm .RowStride +_cbb ];};}else {_bag <<=1;};if _ae ==7{_abb =0;if _cbb < bm .RowStride {_abb =bm .Data [_gc *bm .RowStride +_cbb ];};}else {_abb <<=1;};_dec &=31;
_ab &=127;_bc &=15;};};return nil ;};func (_gfc *Encoder )byteOut (){if _gfc ._ff ==0xff{_gfc .rBlock ();return ;};if _gfc ._fa < 0x8000000{_gfc .lBlock ();return ;};_gfc ._ff ++;if _gfc ._ff !=0xff{_gfc .lBlock ();return ;};_gfc ._fa &=0x7ffffff;_gfc .rBlock ();
};func (_gcg *Encoder )Refine (iTemp ,iTarget *_g .Bitmap ,ox ,oy int )error {for _agd :=0;_agd < iTarget .Height ;_agd ++{var _bf int ;_agdb :=_agd +oy ;var (_aga ,_gb ,_fgb ,_eb ,_fe uint16 ;_egg ,_faf ,_ef ,_bb ,_ebe byte ;);if _agdb >=1&&(_agdb -1)< iTemp .Height {_egg =iTemp .Data [(_agdb -1)*iTemp .RowStride ];
};if _agdb >=0&&_agdb < iTemp .Height {_faf =iTemp .Data [_agdb *iTemp .RowStride ];};if _agdb >=-1&&_agdb +1< iTemp .Height {_ef =iTemp .Data [(_agdb +1)*iTemp .RowStride ];};if _agd >=1{_bb =iTarget .Data [(_agd -1)*iTarget .RowStride ];};_ebe =iTarget .Data [_agd *iTarget .RowStride ];
_bcf :=uint (6+ox );_aga =uint16 (_egg >>_bcf );_gb =uint16 (_faf >>_bcf );_fgb =uint16 (_ef >>_bcf );_eb =uint16 (_bb >>6);_degb :=uint (2-ox );_egg <<=_degb ;_faf <<=_degb ;_ef <<=_degb ;_bb <<=2;for _bf =0;_bf < iTarget .Width ;_bf ++{_ca :=(_aga <<10)|(_gb <<7)|(_fgb <<4)|(_eb <<1)|_fe ;
_ebb :=_ebe >>7;_gbb :=_gcg .encodeBit (_gcg ._cg ,uint32 (_ca ),_ebb );if _gbb !=nil {return _gbb ;};_aga <<=1;_gb <<=1;_fgb <<=1;_eb <<=1;_aga |=uint16 (_egg >>7);_gb |=uint16 (_faf >>7);_fgb |=uint16 (_ef >>7);_eb |=uint16 (_bb >>7);_fe =uint16 (_ebb );
_dbd :=_bf %8;_da :=_bf /8+1;if _dbd ==5+ox {_egg ,_faf ,_ef =0,0,0;if _da < iTemp .RowStride &&_agdb >=1&&(_agdb -1)< iTemp .Height {_egg =iTemp .Data [(_agdb -1)*iTemp .RowStride +_da ];};if _da < iTemp .RowStride &&_agdb >=0&&_agdb < iTemp .Height {_faf =iTemp .Data [_agdb *iTemp .RowStride +_da ];
};if _da < iTemp .RowStride &&_agdb >=-1&&(_agdb +1)< iTemp .Height {_ef =iTemp .Data [(_agdb +1)*iTemp .RowStride +_da ];};}else {_egg <<=1;_faf <<=1;_ef <<=1;};if _dbd ==5&&_agd >=1{_bb =0;if _da < iTarget .RowStride {_bb =iTarget .Data [(_agd -1)*iTarget .RowStride +_da ];
};}else {_bb <<=1;};if _dbd ==7{_ebe =0;if _da < iTarget .RowStride {_ebe =iTarget .Data [_agd *iTarget .RowStride +_da ];};}else {_ebe <<=1;};_aga &=7;_gb &=7;_fgb &=7;_eb &=7;};};return nil ;};type state struct{_ebed uint16 ;_ebg ,_ddb uint8 ;_bffb uint8 ;
};func (_fd *Encoder )emit (){if _fd ._bg ==_eae {_fd ._cf =append (_fd ._cf ,_fd ._ba );_fd ._ba =make ([]byte ,_eae );_fd ._bg =0;};_fd ._ba [_fd ._bg ]=_fd ._ff ;_fd ._bg ++;};func (_cdeg *Encoder )renormalize (){for {_cdeg ._dg <<=1;_cdeg ._fa <<=1;
_cdeg ._ege --;if _cdeg ._ege ==0{_cdeg .byteOut ();};if (_cdeg ._dg &0x8000)!=0{break ;};};};type intEncRangeS struct{_gf ,_de int ;_e ,_aa uint8 ;_ea uint16 ;_eg uint8 ;};func (_db *Encoder )EncodeIAID (symbolCodeLength ,value int )(_ffb error ){_df .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );
if _ffb =_db .encodeIAID (symbolCodeLength ,value );_ffb !=nil {return _b .Wrap (_ffb ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};func (_eca *Encoder )dataSize ()int {return _eae *len (_eca ._cf )+_eca ._bg };const _beg =0x9b25;
func (_dag *Encoder )rBlock (){if _dag ._dd >=0{_dag .emit ();};_dag ._dd ++;_dag ._ff =uint8 (_dag ._fa >>20);_dag ._fa &=0xfffff;_dag ._ege =7;};func (_bed *Encoder )encodeOOB (_eea Class )error {_efg :=_bed ._cdd [_eea ];_daeg :=_bed .encodeBit (_efg ,1,1);
if _daeg !=nil {return _daeg ;};_daeg =_bed .encodeBit (_efg ,3,0);if _daeg !=nil {return _daeg ;};_daeg =_bed .encodeBit (_efg ,6,0);if _daeg !=nil {return _daeg ;};_daeg =_bed .encodeBit (_efg ,12,0);if _daeg !=nil {return _daeg ;};return nil ;};func _cd (_gg int )*codingContext {return &codingContext {_c :make ([]byte ,_gg ),_dfe :make ([]byte ,_gg )};
};const (_bdb =65536;_eae =20*1024;);func (_abc *Encoder )flush (){_abc .setBits ();_abc ._fa <<=_abc ._ege ;_abc .byteOut ();_abc ._fa <<=_abc ._ege ;_abc .byteOut ();_abc .emit ();if _abc ._ff !=0xff{_abc ._dd ++;_abc ._ff =0xff;_abc .emit ();};_abc ._dd ++;
_abc ._ff =0xac;_abc ._dd ++;_abc .emit ();};func (_bega *Encoder )lBlock (){if _bega ._dd >=0{_bega .emit ();};_bega ._dd ++;_bega ._ff =uint8 (_bega ._fa >>19);_bega ._fa &=0x7ffff;_bega ._ege =8;};func (_cc *Encoder )Reset (){_cc ._dg =0x8000;_cc ._fa =0;
_cc ._ege =12;_cc ._dd =-1;_cc ._ff =0;_cc ._cdc =nil ;_cc ._cg =_cd (_bdb );};func (_fga *Encoder )EncodeInteger (proc Class ,value int )(_fgd error ){_df .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );
if _fgd =_fga .encodeInteger (proc ,value );_fgd !=nil {return _b .Wrap (_fgd ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};func New ()*Encoder {_ec :=&Encoder {};_ec .Init ();return _ec };func (_bcc *Encoder )Final (){_bcc .flush ()};
func (_dba *Encoder )codeLPS (_bee *codingContext ,_gba uint32 ,_bff uint16 ,_ddd byte ){_dba ._dg -=_bff ;if _dba ._dg < _bff {_dba ._fa +=uint32 (_bff );}else {_dba ._dg =_bff ;};if _cdcc [_ddd ]._bffb ==1{_bee .flipMps (_gba );};_bee ._c [_gba ]=_cdcc [_ddd ]._ddb ;
_dba .renormalize ();};func (_gd *Encoder )Init (){_gd ._cg =_cd (_bdb );_gd ._dg =0x8000;_gd ._fa =0;_gd ._ege =12;_gd ._dd =-1;_gd ._ff =0;_gd ._bg =0;_gd ._ba =make ([]byte ,_eae );for _bd :=0;_bd < len (_gd ._cdd );_bd ++{_gd ._cdd [_bd ]=_cd (512);
};_gd ._cdc =nil ;};func (_bfe *Encoder )WriteTo (w _a .Writer )(int64 ,error ){const _bce ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";var _adg int64 ;for _fcb ,_dab :=range _bfe ._cf {_eaf ,_gag :=w .Write (_dab );
if _gag !=nil {return 0,_b .Wrapf (_gag ,_bce ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_fcb );};_adg +=int64 (_eaf );};_bfe ._ba =_bfe ._ba [:_bfe ._bg ];
_dae ,_ed :=w .Write (_bfe ._ba );if _ed !=nil {return 0,_b .Wrap (_ed ,_bce ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_adg +=int64 (_dae );return _adg ,nil ;};func (_aaf *Encoder )encodeInteger (_gda Class ,_aafg int )error {const _baad ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";
if _aafg > 2000000000||_aafg < -2000000000{return _b .Errorf (_baad ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_aafg );
};_gaa :=_aaf ._cdd [_gda ];_cgd :=uint32 (1);var _agac int ;for ;;_agac ++{if _aag [_agac ]._gf <=_aafg &&_aag [_agac ]._de >=_aafg {break ;};};if _aafg < 0{_aafg =-_aafg ;};_aafg -=int (_aag [_agac ]._ea );_dfg :=_aag [_agac ]._e ;for _ee :=uint8 (0);
_ee < _aag [_agac ]._aa ;_ee ++{_caa :=_dfg &1;if _ggbg :=_aaf .encodeBit (_gaa ,_cgd ,_caa );_ggbg !=nil {return _b .Wrap (_ggbg ,_baad ,"");};_dfg >>=1;if _cgd &0x100> 0{_cgd =(((_cgd <<1)|uint32 (_caa ))&0x1ff)|0x100;}else {_cgd =(_cgd <<1)|uint32 (_caa );
};};_aafg <<=32-_aag [_agac ]._eg ;for _ffd :=uint8 (0);_ffd < _aag [_agac ]._eg ;_ffd ++{_dff :=uint8 ((uint32 (_aafg )&0x80000000)>>31);if _dfd :=_aaf .encodeBit (_gaa ,_cgd ,_dff );_dfd !=nil {return _b .Wrap (_dfd ,_baad ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");
};_aafg <<=1;if _cgd &0x100!=0{_cgd =(((_cgd <<1)|uint32 (_dff ))&0x1ff)|0x100;}else {_cgd =(_cgd <<1)|uint32 (_dff );};};return nil ;};func (_cga *Encoder )codeMPS (_gbe *codingContext ,_aca uint32 ,_ce uint16 ,_ggb byte ){_cga ._dg -=_ce ;if _cga ._dg &0x8000!=0{_cga ._fa +=uint32 (_ce );
return ;};if _cga ._dg < _ce {_cga ._dg =_ce ;}else {_cga ._fa +=uint32 (_ce );};_gbe ._c [_aca ]=_cdcc [_ggb ]._ebg ;_cga .renormalize ();};var _cdcc =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
type Encoder struct{_fa uint32 ;_dg uint16 ;_ege ,_ff uint8 ;_dd int ;_ga int ;_cf [][]byte ;_ba []byte ;_bg int ;_cg *codingContext ;_cdd [13]*codingContext ;_cdc *codingContext ;};func (_egd *Encoder )encodeBit (_febe *codingContext ,_af uint32 ,_egb uint8 )error {const _dggd ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";
_egd ._ga ++;if _af >=uint32 (len (_febe ._c )){return _b .Errorf (_dggd ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_af );
};_cdce :=_febe ._c [_af ];_fcba :=_febe .mps (_af );_dad :=_cdcc [_cdce ]._ebed ;_df .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_egd ._ga ,_egb ,_cdce ,_fcba ,_dad ,_egd ._dg ,_egd ._fa ,_egd ._ege ,_egd ._ff ,_egd ._dd );
if _egb ==0{_egd .code0 (_febe ,_af ,_dad ,_cdce );}else {_egd .code1 (_febe ,_af ,_dad ,_cdce );};return nil ;};func (_cgae *Encoder )encodeIAID (_afd ,_beb int )error {if _cgae ._cdc ==nil {_cgae ._cdc =_cd (1<<uint (_afd ));};_cba :=uint32 (1<<uint32 (_afd +1))-1;
_beb <<=uint (32-_afd );_bdc :=uint32 (1);for _dbe :=0;_dbe < _afd ;_dbe ++{_ggg :=_bdc &_cba ;_acb :=uint8 ((uint32 (_beb )&0x80000000)>>31);if _ecge :=_cgae .encodeBit (_cgae ._cdc ,_ggg ,_acb );_ecge !=nil {return _ecge ;};_bdc =(_bdc <<1)|uint32 (_acb );
_beb <<=1;};return nil ;};func (_bba *Encoder )code1 (_dge *codingContext ,_fgg uint32 ,_feb uint16 ,_ebeb byte ){if _dge .mps (_fgg )==1{_bba .codeMPS (_dge ,_fgg ,_feb ,_ebeb );}else {_bba .codeLPS (_dge ,_fgg ,_feb ,_ebeb );};};func (_def *Encoder )Flush (){_def ._bg =0;
_def ._cf =nil ;_def ._dd =-1};func (_fc *codingContext )flipMps (_acc uint32 ){_fc ._dfe [_acc ]=1-_fc ._dfe [_acc ]};func (_ac *codingContext )mps (_dee uint32 )int {return int (_ac ._dfe [_dee ])};func (_adb *Encoder )code0 (_gdc *codingContext ,_dgg uint32 ,_ccg uint16 ,_bgd byte ){if _gdc .mps (_dgg )==0{_adb .codeMPS (_gdc ,_dgg ,_ccg ,_bgd );
}else {_adb .codeLPS (_gdc ,_dgg ,_ccg ,_bgd );};};var _aag =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};
func (_be Class )String ()string {switch _be {case IAAI :return "\u0049\u0041\u0041\u0049";case IADH :return "\u0049\u0041\u0044\u0048";case IADS :return "\u0049\u0041\u0044\u0053";case IADT :return "\u0049\u0041\u0044\u0054";case IADW :return "\u0049\u0041\u0044\u0057";
case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";case IAIT :return "\u0049\u0041\u0049\u0054";case IARDH :return "\u0049\u0041\u0052D\u0048";case IARDW :return "\u0049\u0041\u0052D\u0057";case IARDX :return "\u0049\u0041\u0052D\u0058";
case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";};};var _ _a .WriterTo =&Encoder {};const (IAAI Class =iota ;IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;
IARDW ;IARDX ;IARDY ;IARI ;);func (_cde *Encoder )DataSize ()int {return _cde .dataSize ()};