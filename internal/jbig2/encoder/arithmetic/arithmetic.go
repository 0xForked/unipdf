//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_b "bytes";_ba "github.com/unidoc/unipdf/v3/common";_cf "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_be "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_c "io";);func (_aa *Encoder )Init (){_aa ._fd =_bd (_fad );_aa ._cd =0x8000;_aa ._cbd =0;_aa ._gda =12;_aa ._ge =-1;_aa ._ag =0;_aa ._bg =0;_aa ._af =make ([]byte ,_fbd );for _eb :=0;_eb < len (_aa ._ff );_eb ++{_aa ._ff [_eb ]=_bd (512);};_aa ._bc =nil ;};var _ed =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};type codingContext struct{_cb []byte ;_gg []byte ;};func (_bea *Encoder )code1 (_dcc *codingContext ,_ef uint32 ,_gff uint16 ,_gfg byte ){if _dcc .mps (_ef )==1{_bea .codeMPS (_dcc ,_ef ,_gff ,_gfg );}else {_bea .codeLPS (_dcc ,_ef ,_gff ,_gfg );};};func (_bff *Encoder )encodeInteger (_fce Class ,_gde int )error {const _fag ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";if _gde > 2000000000||_gde < -2000000000{return _be .Errorf (_fag ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_gde );};_baf :=_bff ._ff [_fce ];_ggg :=uint32 (1);var _ccf int ;for ;;_ccf ++{if _ed [_ccf ]._e <=_gde &&_ed [_ccf ]._fe >=_gde {break ;};};if _gde < 0{_gde =-_gde ;};_gde -=int (_ed [_ccf ]._gd );_gbd :=_ed [_ccf ]._a ;for _fcea :=uint8 (0);_fcea < _ed [_ccf ]._d ;_fcea ++{_cdf :=_gbd &1;if _bffc :=_bff .encodeBit (_baf ,_ggg ,_cdf );_bffc !=nil {return _be .Wrap (_bffc ,_fag ,"");};_gbd >>=1;if _ggg &0x100> 0{_ggg =(((_ggg <<1)|uint32 (_cdf ))&0x1ff)|0x100;}else {_ggg =(_ggg <<1)|uint32 (_cdf );};};_gde <<=32-_ed [_ccf ]._ab ;for _beaf :=uint8 (0);_beaf < _ed [_ccf ]._ab ;_beaf ++{_aea :=uint8 ((uint32 (_gde )&0x80000000)>>31);if _bdc :=_bff .encodeBit (_baf ,_ggg ,_aea );_bdc !=nil {return _be .Wrap (_bdc ,_fag ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");};_gde <<=1;if _ggg &0x100!=0{_ggg =(((_ggg <<1)|uint32 (_aea ))&0x1ff)|0x100;}else {_ggg =(_ggg <<1)|uint32 (_aea );};};return nil ;};func (_bab *Encoder )setBits (){_dfd :=_bab ._cbd +uint32 (_bab ._cd );_bab ._cbd |=0xffff;if _bab ._cbd >=_dfd {_bab ._cbd -=0x8000;};};func (_cac *Encoder )EncodeInteger (proc Class ,value int )(_feg error ){_ba .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );if _feg =_cac .encodeInteger (proc ,value );_feg !=nil {return _be .Wrap (_feg ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};func (_bad *Encoder )Refine (iTemp ,iTarget *_cf .Bitmap ,ox ,oy int )error {for _gba :=0;_gba < iTarget .Height ;_gba ++{var _eba int ;_gga :=_gba +oy ;var (_df ,_fbb ,_ggf ,_aec ,_ffd uint16 ;_fcb ,_eda ,_bfe ,_fab ,_bee byte ;);if _gga >=1&&(_gga -1)< iTemp .Height {_fcb =iTemp .Data [(_gga -1)*iTemp .RowStride ];};if _gga >=0&&_gga < iTemp .Height {_eda =iTemp .Data [_gga *iTemp .RowStride ];};if _gga >=-1&&_gga +1< iTemp .Height {_bfe =iTemp .Data [(_gga +1)*iTemp .RowStride ];};if _gba >=1{_fab =iTarget .Data [(_gba -1)*iTarget .RowStride ];};_bee =iTarget .Data [_gba *iTarget .RowStride ];_afe :=uint (6+ox );_df =uint16 (_fcb >>_afe );_fbb =uint16 (_eda >>_afe );_ggf =uint16 (_bfe >>_afe );_aec =uint16 (_fab >>6);_ecd :=uint (2-ox );_fcb <<=_ecd ;_eda <<=_ecd ;_bfe <<=_ecd ;_fab <<=2;for _eba =0;_eba < iTarget .Width ;_eba ++{_gea :=(_df <<10)|(_fbb <<7)|(_ggf <<4)|(_aec <<1)|_ffd ;_ga :=_bee >>7;_da :=_bad .encodeBit (_bad ._fd ,uint32 (_gea ),_ga );if _da !=nil {return _da ;};_df <<=1;_fbb <<=1;_ggf <<=1;_aec <<=1;_df |=uint16 (_fcb >>7);_fbb |=uint16 (_eda >>7);_ggf |=uint16 (_bfe >>7);_aec |=uint16 (_fab >>7);_ffd =uint16 (_ga );_cbb :=_eba %8;_gae :=_eba /8+1;if _cbb ==5+ox {_fcb ,_eda ,_bfe =0,0,0;if _gae < iTemp .RowStride &&_gga >=1&&(_gga -1)< iTemp .Height {_fcb =iTemp .Data [(_gga -1)*iTemp .RowStride +_gae ];};if _gae < iTemp .RowStride &&_gga >=0&&_gga < iTemp .Height {_eda =iTemp .Data [_gga *iTemp .RowStride +_gae ];};if _gae < iTemp .RowStride &&_gga >=-1&&(_gga +1)< iTemp .Height {_bfe =iTemp .Data [(_gga +1)*iTemp .RowStride +_gae ];};}else {_fcb <<=1;_eda <<=1;_bfe <<=1;};if _cbb ==5&&_gba >=1{_fab =0;if _gae < iTarget .RowStride {_fab =iTarget .Data [(_gba -1)*iTarget .RowStride +_gae ];};}else {_fab <<=1;};if _cbb ==7{_bee =0;if _gae < iTarget .RowStride {_bee =iTarget .Data [_gba *iTarget .RowStride +_gae ];};}else {_bee <<=1;};_df &=7;_fbb &=7;_ggf &=7;_aec &=7;};};return nil ;};func (_fbc *Encoder )emit (){if _fbc ._bg ==_fbd {_fbc ._dc =append (_fbc ._dc ,_fbc ._af );_fbc ._af =make ([]byte ,_fbd );_fbc ._bg =0;};_fbc ._af [_fbc ._bg ]=_fbc ._ag ;_fbc ._bg ++;};func (_bdd *Encoder )codeMPS (_gdaef *codingContext ,_bdbf uint32 ,_bdg uint16 ,_aef byte ){_bdd ._cd -=_bdg ;if _bdd ._cd &0x8000!=0{_bdd ._cbd +=uint32 (_bdg );return ;};if _bdd ._cd < _bdg {_bdd ._cd =_bdg ;}else {_bdd ._cbd +=uint32 (_bdg );};_gdaef ._cb [_bdbf ]=_fbe [_aef ]._dg ;_bdd .renormalize ();};func (_gcd *Encoder )encodeBit (_fcg *codingContext ,_dff uint32 ,_efa uint8 )error {const _bada ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";_gcd ._aba ++;if _dff >=uint32 (len (_fcg ._cb )){return _be .Errorf (_bada ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_dff );};_de :=_fcg ._cb [_dff ];_aeca :=_fcg .mps (_dff );_ega :=_fbe [_de ]._ecc ;_ba .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_gcd ._aba ,_efa ,_de ,_aeca ,_ega ,_gcd ._cd ,_gcd ._cbd ,_gcd ._gda ,_gcd ._ag ,_gcd ._ge );if _efa ==0{_gcd .code0 (_fcg ,_dff ,_ega ,_de );}else {_gcd .code1 (_fcg ,_dff ,_ega ,_de );};return nil ;};type Encoder struct{_cbd uint32 ;_cd uint16 ;_gda ,_ag uint8 ;_ge int ;_aba int ;_dc [][]byte ;_af []byte ;_bg int ;_fd *codingContext ;_ff [13]*codingContext ;_bc *codingContext ;};func (_gcb *Encoder )code0 (_adf *codingContext ,_bdb uint32 ,_caa uint16 ,_bfc byte ){if _adf .mps (_bdb )==0{_gcb .codeMPS (_adf ,_bdb ,_caa ,_bfc );}else {_gcb .codeLPS (_adf ,_bdb ,_caa ,_bfc );};};func (_edf *Encoder )EncodeBitmap (bm *_cf .Bitmap ,duplicateLineRemoval bool )error {_ba .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );var (_db ,_gdf uint8 ;_cda ,_fa ,_dbc uint16 ;_gc ,_dd ,_cdd byte ;_fc ,_fb ,_aac int ;_dda ,_bf []byte ;);for _aacf :=0;_aacf < bm .Height ;_aacf ++{_gc ,_dd =0,0;if _aacf >=2{_gc =bm .Data [(_aacf -2)*bm .RowStride ];};if _aacf >=1{_dd =bm .Data [(_aacf -1)*bm .RowStride ];if duplicateLineRemoval {_fb =_aacf *bm .RowStride ;_dda =bm .Data [_fb :_fb +bm .RowStride ];_aac =(_aacf -1)*bm .RowStride ;_bf =bm .Data [_aac :_aac +bm .RowStride ];if _b .Equal (_dda ,_bf ){_gdf =_db ^1;_db =1;}else {_gdf =_db ;_db =0;};};};if duplicateLineRemoval {if _ca :=_edf .encodeBit (_edf ._fd ,_ec ,_gdf );_ca !=nil {return _ca ;};if _db !=0{continue ;};};_cdd =bm .Data [_aacf *bm .RowStride ];_cda =uint16 (_gc >>5);_fa =uint16 (_dd >>4);_gc <<=3;_dd <<=4;_dbc =0;for _fc =0;_fc < bm .Width ;_fc ++{_afa :=uint32 (_cda <<11|_fa <<4|_dbc );_ae :=(_cdd &0x80)>>7;_ebf :=_edf .encodeBit (_edf ._fd ,_afa ,_ae );if _ebf !=nil {return _ebf ;};_cda <<=1;_fa <<=1;_dbc <<=1;_cda |=uint16 ((_gc &0x80)>>7);_fa |=uint16 ((_dd &0x80)>>7);_dbc |=uint16 (_ae );_abf :=_fc %8;_gf :=_fc /8+1;if _abf ==4&&_aacf >=2{_gc =0;if _gf < bm .RowStride {_gc =bm .Data [(_aacf -2)*bm .RowStride +_gf ];};}else {_gc <<=1;};if _abf ==3&&_aacf >=1{_dd =0;if _gf < bm .RowStride {_dd =bm .Data [(_aacf -1)*bm .RowStride +_gf ];};}else {_dd <<=1;};if _abf ==7{_cdd =0;if _gf < bm .RowStride {_cdd =bm .Data [_aacf *bm .RowStride +_gf ];};}else {_cdd <<=1;};_cda &=31;_fa &=127;_dbc &=15;};};return nil ;};func (_g Class )String ()string {switch _g {case IAAI :return "\u0049\u0041\u0041\u0049";case IADH :return "\u0049\u0041\u0044\u0048";case IADS :return "\u0049\u0041\u0044\u0053";case IADT :return "\u0049\u0041\u0044\u0054";case IADW :return "\u0049\u0041\u0044\u0057";case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";case IAIT :return "\u0049\u0041\u0049\u0054";case IARDH :return "\u0049\u0041\u0052D\u0048";case IARDW :return "\u0049\u0041\u0052D\u0057";case IARDX :return "\u0049\u0041\u0052D\u0058";case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";};};const (_fad =65536;_fbd =20*1024;);func (_gbe *Encoder )codeLPS (_cgd *codingContext ,_cff uint32 ,_abad uint16 ,_aecc byte ){_gbe ._cd -=_abad ;if _gbe ._cd < _abad {_gbe ._cbd +=uint32 (_abad );}else {_gbe ._cd =_abad ;};if _fbe [_aecc ]._gdc ==1{_cgd .flipMps (_cff );};_cgd ._cb [_cff ]=_fbe [_aecc ]._gge ;_gbe .renormalize ();};func (_cc *Encoder )EncodeIAID (symbolCodeLength ,value int )(_fg error ){_ba .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );if _fg =_cc .encodeIAID (symbolCodeLength ,value );_fg !=nil {return _be .Wrap (_fg ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};func (_gbc *Encoder )encodeIAID (_ggb ,_gfd int )error {if _gbc ._bc ==nil {_gbc ._bc =_bd (1<<uint (_ggb ));};_ebee :=uint32 (1<<uint32 (_ggb +1))-1;_gfd <<=uint (32-_ggb );_agb :=uint32 (1);for _ce :=0;_ce < _ggb ;_ce ++{_gbeg :=_agb &_ebee ;_cba :=uint8 ((uint32 (_gfd )&0x80000000)>>31);if _agf :=_gbc .encodeBit (_gbc ._bc ,_gbeg ,_cba );_agf !=nil {return _agf ;};_agb =(_agb <<1)|uint32 (_cba );_gfd <<=1;};return nil ;};type intEncRangeS struct{_e ,_fe int ;_a ,_d uint8 ;_gd uint16 ;_ab uint8 ;};func (_ade *Encoder )Reset (){_ade ._cd =0x8000;_ade ._cbd =0;_ade ._gda =12;_ade ._ge =-1;_ade ._ag =0;_ade ._bc =nil ;_ade ._fd =_bd (_fad );};const _ec =0x9b25;func (_bef *Encoder )renormalize (){for {_bef ._cd <<=1;_bef ._cbd <<=1;_bef ._gda --;if _bef ._gda ==0{_bef .byteOut ();};if (_bef ._cd &0x8000)!=0{break ;};};};func (_aag *Encoder )byteOut (){if _aag ._ag ==0xff{_aag .rBlock ();return ;};if _aag ._cbd < 0x8000000{_aag .lBlock ();return ;};_aag ._ag ++;if _aag ._ag !=0xff{_aag .lBlock ();return ;};_aag ._cbd &=0x7ffffff;_aag .rBlock ();};func (_ad *Encoder )EncodeOOB (proc Class )(_gdae error ){_ba .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );if _gdae =_ad .encodeOOB (proc );_gdae !=nil {return _be .Wrap (_gdae ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};func (_aeb *Encoder )WriteTo (w _c .Writer )(int64 ,error ){const _cbe ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";var _fggg int64 ;for _cad ,_ccg :=range _aeb ._dc {_edc ,_cbeb :=w .Write (_ccg );if _cbeb !=nil {return 0,_be .Wrapf (_cbeb ,_cbe ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_cad );};_fggg +=int64 (_edc );};_aeb ._af =_aeb ._af [:_aeb ._bg ];_gdab ,_fdd :=w .Write (_aeb ._af );if _fdd !=nil {return 0,_be .Wrap (_fdd ,_cbe ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_fggg +=int64 (_gdab );return _fggg ,nil ;};func _bd (_cbf int )*codingContext {return &codingContext {_cb :make ([]byte ,_cbf ),_gg :make ([]byte ,_cbf )};};func (_cg *codingContext )mps (_gb uint32 )int {return int (_cg ._gg [_gb ])};type state struct{_ecc uint16 ;_dg ,_gge uint8 ;_gdc uint8 ;};type Class int ;const (IAAI Class =iota ;IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);func (_fgd *Encoder )flush (){_fgd .setBits ();_fgd ._cbd <<=_fgd ._gda ;_fgd .byteOut ();_fgd ._cbd <<=_fgd ._gda ;_fgd .byteOut ();_fgd .emit ();if _fgd ._ag !=0xff{_fgd ._ge ++;_fgd ._ag =0xff;_fgd .emit ();};_fgd ._ge ++;_fgd ._ag =0xac;_fgd ._ge ++;_fgd .emit ();};func (_fgg *Encoder )Final (){_fgg .flush ()};func (_eg *codingContext )flipMps (_ac uint32 ){_eg ._gg [_ac ]=1-_eg ._gg [_ac ]};func New ()*Encoder {_bgd :=&Encoder {};_bgd .Init ();return _bgd };func (_egb *Encoder )Flush (){_egb ._bg =0;_egb ._dc =nil ;_egb ._ge =-1};func (_ee *Encoder )lBlock (){if _ee ._ge >=0{_ee .emit ();};_ee ._ge ++;_ee ._ag =uint8 (_ee ._cbd >>19);_ee ._cbd &=0x7ffff;_ee ._gda =8;};var _ _c .WriterTo =&Encoder {};func (_aad *Encoder )DataSize ()int {return _aad .dataSize ()};func (_ea *Encoder )encodeOOB (_ggfc Class )error {_eaa :=_ea ._ff [_ggfc ];_ddb :=_ea .encodeBit (_eaa ,1,1);if _ddb !=nil {return _ddb ;};_ddb =_ea .encodeBit (_eaa ,3,0);if _ddb !=nil {return _ddb ;};_ddb =_ea .encodeBit (_eaa ,6,0);if _ddb !=nil {return _ddb ;};_ddb =_ea .encodeBit (_eaa ,12,0);if _ddb !=nil {return _ddb ;};return nil ;};func (_edca *Encoder )rBlock (){if _edca ._ge >=0{_edca .emit ();};_edca ._ge ++;_edca ._ag =uint8 (_edca ._cbd >>20);_edca ._cbd &=0xfffff;_edca ._gda =7;};var _fbe =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};func (_ebe *Encoder )dataSize ()int {return _fbd *len (_ebe ._dc )+_ebe ._bg };