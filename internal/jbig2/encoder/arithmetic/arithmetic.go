//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_e "bytes";_b "github.com/unidoc/unipdf/v3/common";_gb "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_a "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_g "io";);func (_ece *Encoder )EncodeBitmap (bm *_gb .Bitmap ,duplicateLineRemoval bool )error {_b .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );var (_dfg ,_eba uint8 ;_ga ,_gdb ,_cg uint16 ;_adf ,_edf ,_fgg byte ;_fe ,_eag ,_fa int ;_dc ,_fd []byte ;);for _ddde :=0;_ddde < bm .Height ;_ddde ++{_adf ,_edf =0,0;if _ddde >=2{_adf =bm .Data [(_ddde -2)*bm .RowStride ];};if _ddde >=1{_edf =bm .Data [(_ddde -1)*bm .RowStride ];if duplicateLineRemoval {_eag =_ddde *bm .RowStride ;_dc =bm .Data [_eag :_eag +bm .RowStride ];_fa =(_ddde -1)*bm .RowStride ;_fd =bm .Data [_fa :_fa +bm .RowStride ];if _e .Equal (_dc ,_fd ){_eba =_dfg ^1;_dfg =1;}else {_eba =_dfg ;_dfg =0;};};};if duplicateLineRemoval {if _eff :=_ece .encodeBit (_ece ._cc ,_dfa ,_eba );_eff !=nil {return _eff ;};if _dfg !=0{continue ;};};_fgg =bm .Data [_ddde *bm .RowStride ];_ga =uint16 (_adf >>5);_gdb =uint16 (_edf >>4);_adf <<=3;_edf <<=4;_cg =0;for _fe =0;_fe < bm .Width ;_fe ++{_fc :=uint32 (_ga <<11|_gdb <<4|_cg );_gdd :=(_fgg &0x80)>>7;_ge :=_ece .encodeBit (_ece ._cc ,_fc ,_gdd );if _ge !=nil {return _ge ;};_ga <<=1;_gdb <<=1;_cg <<=1;_ga |=uint16 ((_adf &0x80)>>7);_gdb |=uint16 ((_edf &0x80)>>7);_cg |=uint16 (_gdd );_ce :=_fe %8;_dcc :=_fe /8+1;if _ce ==4&&_ddde >=2{_adf =0;if _dcc < bm .RowStride {_adf =bm .Data [(_ddde -2)*bm .RowStride +_dcc ];};}else {_adf <<=1;};if _ce ==3&&_ddde >=1{_edf =0;if _dcc < bm .RowStride {_edf =bm .Data [(_ddde -1)*bm .RowStride +_dcc ];};}else {_edf <<=1;};if _ce ==7{_fgg =0;if _dcc < bm .RowStride {_fgg =bm .Data [_ddde *bm .RowStride +_dcc ];};}else {_fgg <<=1;};_ga &=31;_gdb &=127;_cg &=15;};};return nil ;};func (_eab *Encoder )EncodeInteger (proc Class ,value int )(_fcb error ){_b .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );if _fcb =_eab .encodeInteger (proc ,value );_fcb !=nil {return _a .Wrap (_fcb ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};type codingContext struct{_dg []byte ;_eb []byte ;};func (_gec *Encoder )encodeOOB (_dee Class )error {_fac :=_gec ._cdd [_dee ];_ffd :=_gec .encodeBit (_fac ,1,1);if _ffd !=nil {return _ffd ;};_ffd =_gec .encodeBit (_fac ,3,0);if _ffd !=nil {return _ffd ;};_ffd =_gec .encodeBit (_fac ,6,0);if _ffd !=nil {return _ffd ;};_ffd =_gec .encodeBit (_fac ,12,0);if _ffd !=nil {return _ffd ;};return nil ;};func (_ee Class )String ()string {switch _ee {case IAAI :return "\u0049\u0041\u0041\u0049";case IADH :return "\u0049\u0041\u0044\u0048";case IADS :return "\u0049\u0041\u0044\u0053";case IADT :return "\u0049\u0041\u0044\u0054";case IADW :return "\u0049\u0041\u0044\u0057";case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";case IAIT :return "\u0049\u0041\u0049\u0054";case IARDH :return "\u0049\u0041\u0052D\u0048";case IARDW :return "\u0049\u0041\u0052D\u0057";case IARDX :return "\u0049\u0041\u0052D\u0058";case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";};};func (_eca *Encoder )EncodeOOB (proc Class )(_feb error ){_b .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );if _feb =_eca .encodeOOB (proc );_feb !=nil {return _a .Wrap (_feb ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};func (_gbad *Encoder )WriteTo (w _g .Writer )(int64 ,error ){const _fge ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";var _cef int64 ;for _gcf ,_cbd :=range _gbad ._cd {_bc ,_dfe :=w .Write (_cbd );if _dfe !=nil {return 0,_a .Wrapf (_dfe ,_fge ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_gcf );};_cef +=int64 (_bc );};_gbad ._ed =_gbad ._ed [:_gbad ._dgd ];_ebfd ,_age :=w .Write (_gbad ._ed );if _age !=nil {return 0,_a .Wrap (_age ,_fge ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_cef +=int64 (_ebfd );return _cef ,nil ;};func (_fb *Encoder )dataSize ()int {return _bdd *len (_fb ._cd )+_fb ._dgd };func (_dbfg *Encoder )encodeIAID (_cf ,_bde int )error {if _dbfg ._ad ==nil {_dbfg ._ad =_df (1<<uint (_cf ));};_gbe :=uint32 (1<<uint32 (_cf +1))-1;_bde <<=uint (32-_cf );_fef :=uint32 (1);for _ff :=0;_ff < _cf ;_ff ++{_cga :=_fef &_gbe ;_fgd :=uint8 ((uint32 (_bde )&0x80000000)>>31);if _acb :=_dbfg .encodeBit (_dbfg ._ad ,_cga ,_fgd );_acb !=nil {return _acb ;};_fef =(_fef <<1)|uint32 (_fgd );_bde <<=1;};return nil ;};func (_gfc *Encoder )code1 (_de *codingContext ,_fec uint32 ,_adfd uint16 ,_cbe byte ){if _de .mps (_fec )==1{_gfc .codeMPS (_de ,_fec ,_adfd ,_cbe );}else {_gfc .codeLPS (_de ,_fec ,_adfd ,_cbe );};};func (_cddg *Encoder )emit (){if _cddg ._dgd ==_bdd {_cddg ._cd =append (_cddg ._cd ,_cddg ._ed );_cddg ._ed =make ([]byte ,_bdd );_cddg ._dgd =0;};_cddg ._ed [_cddg ._dgd ]=_cddg ._ef ;_cddg ._dgd ++;};func (_gbd *Encoder )DataSize ()int {return _gbd .dataSize ()};type Class int ;func (_aaa *Encoder )Reset (){_aaa ._ba =0x8000;_aaa ._bf =0;_aaa ._ddb =12;_aaa ._ac =-1;_aaa ._ef =0;_aaa ._ad =nil ;_aaa ._cc =_df (_eceb );};func (_ebf *Encoder )Final (){_ebf .flush ()};var _ _g .WriterTo =&Encoder {};const _dfa =0x9b25;var _gbc =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};func (_ecb *Encoder )EncodeIAID (symbolCodeLength ,value int )(_gf error ){_b .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );if _gf =_ecb .encodeIAID (symbolCodeLength ,value );_gf !=nil {return _a .Wrap (_gf ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};func New ()*Encoder {_fg :=&Encoder {};_fg .Init ();return _fg };func (_af *Encoder )codeLPS (_adc *codingContext ,_dda uint32 ,_aeg uint16 ,_ccc byte ){_af ._ba -=_aeg ;if _af ._ba < _aeg {_af ._bf +=uint32 (_aeg );}else {_af ._ba =_aeg ;};if _bbd [_ccc ]._affg ==1{_adc .flipMps (_dda );};_adc ._dg [_dda ]=_bbd [_ccc ]._deg ;_af .renormalize ();};type state struct{_ede uint16 ;_cacb ,_deg uint8 ;_affg uint8 ;};func (_dgcd *Encoder )setBits (){_fff :=_dgcd ._bf +uint32 (_dgcd ._ba );_dgcd ._bf |=0xffff;if _dgcd ._bf >=_fff {_dgcd ._bf -=0x8000;};};func (_ace *Encoder )renormalize (){for {_ace ._ba <<=1;_ace ._bf <<=1;_ace ._ddb --;if _ace ._ddb ==0{_ace .byteOut ();};if (_ace ._ba &0x8000)!=0{break ;};};};type intEncRangeS struct{_ea ,_d int ;_dd ,_be uint8 ;_gc uint16 ;_ae uint8 ;};type Encoder struct{_bf uint32 ;_ba uint16 ;_ddb ,_ef uint8 ;_ac int ;_ag int ;_cd [][]byte ;_ed []byte ;_dgd int ;_cc *codingContext ;_cdd [13]*codingContext ;_ad *codingContext ;};func (_ec *codingContext )flipMps (_ab uint32 ){_ec ._eb [_ab ]=1-_ec ._eb [_ab ]};func (_cda *Encoder )Init (){_cda ._cc =_df (_eceb );_cda ._ba =0x8000;_cda ._bf =0;_cda ._ddb =12;_cda ._ac =-1;_cda ._ef =0;_cda ._dgd =0;_cda ._ed =make ([]byte ,_bdd );for _dfd :=0;_dfd < len (_cda ._cdd );_dfd ++{_cda ._cdd [_dfd ]=_df (512);};_cda ._ad =nil ;};func (_cfa *Encoder )rBlock (){if _cfa ._ac >=0{_cfa .emit ();};_cfa ._ac ++;_cfa ._ef =uint8 (_cfa ._bf >>20);_cfa ._bf &=0xfffff;_cfa ._ddb =7;};func _df (_c int )*codingContext {return &codingContext {_dg :make ([]byte ,_c ),_eb :make ([]byte ,_c )}};func (_agee *Encoder )lBlock (){if _agee ._ac >=0{_agee .emit ();};_agee ._ac ++;_agee ._ef =uint8 (_agee ._bf >>19);_agee ._bf &=0x7ffff;_agee ._ddb =8;};func (_eef *Encoder )byteOut (){if _eef ._ef ==0xff{_eef .rBlock ();return ;};if _eef ._bf < 0x8000000{_eef .lBlock ();return ;};_eef ._ef ++;if _eef ._ef !=0xff{_eef .lBlock ();return ;};_eef ._bf &=0x7ffffff;_eef .rBlock ();};func (_gae *Encoder )encodeBit (_da *codingContext ,_aff uint32 ,_geg uint8 )error {const _dbf ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";_gae ._ag ++;if _aff >=uint32 (len (_da ._dg )){return _a .Errorf (_dbf ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_aff );};_bae :=_da ._dg [_aff ];_acd :=_da .mps (_aff );_aef :=_bbd [_bae ]._ede ;_b .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_gae ._ag ,_geg ,_bae ,_acd ,_aef ,_gae ._ba ,_gae ._bf ,_gae ._ddb ,_gae ._ef ,_gae ._ac );if _geg ==0{_gae .code0 (_da ,_aff ,_aef ,_bae );}else {_gae .code1 (_da ,_aff ,_aef ,_bae );};return nil ;};func (_eea *Encoder )code0 (_fde *codingContext ,_abe uint32 ,_eae uint16 ,_fea byte ){if _fde .mps (_abe )==0{_eea .codeMPS (_fde ,_abe ,_eae ,_fea );}else {_eea .codeLPS (_fde ,_abe ,_eae ,_fea );};};func (_cee *Encoder )codeMPS (_fae *codingContext ,_bd uint32 ,_eg uint16 ,_cdae byte ){_cee ._ba -=_eg ;if _cee ._ba &0x8000!=0{_cee ._bf +=uint32 (_eg );return ;};if _cee ._ba < _eg {_cee ._ba =_eg ;}else {_cee ._bf +=uint32 (_eg );};_fae ._dg [_bd ]=_bbd [_cdae ]._cacb ;_cee .renormalize ();};const (_eceb =65536;_bdd =20*1024;);func (_ddd *codingContext )mps (_gd uint32 )int {return int (_ddd ._eb [_gd ])};const (IAAI Class =iota ;IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);func (_dgc *Encoder )encodeInteger (_cab Class ,_gdf int )error {const _bba ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";if _gdf > 2000000000||_gdf < -2000000000{return _a .Errorf (_bba ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_gdf );};_fcbc :=_dgc ._cdd [_cab ];_deb :=uint32 (1);var _bcb int ;for ;;_bcb ++{if _gbc [_bcb ]._ea <=_gdf &&_gbc [_bcb ]._d >=_gdf {break ;};};if _gdf < 0{_gdf =-_gdf ;};_gdf -=int (_gbc [_bcb ]._gc );_bce :=_gbc [_bcb ]._dd ;for _fce :=uint8 (0);_fce < _gbc [_bcb ]._be ;_fce ++{_gaef :=_bce &1;if _cgd :=_dgc .encodeBit (_fcbc ,_deb ,_gaef );_cgd !=nil {return _a .Wrap (_cgd ,_bba ,"");};_bce >>=1;if _deb &0x100> 0{_deb =(((_deb <<1)|uint32 (_gaef ))&0x1ff)|0x100;}else {_deb =(_deb <<1)|uint32 (_gaef );};};_gdf <<=32-_gbc [_bcb ]._ae ;for _bef :=uint8 (0);_bef < _gbc [_bcb ]._ae ;_bef ++{_eed :=uint8 ((uint32 (_gdf )&0x80000000)>>31);if _geag :=_dgc .encodeBit (_fcbc ,_deb ,_eed );_geag !=nil {return _a .Wrap (_geag ,_bba ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");};_gdf <<=1;if _deb &0x100!=0{_deb =(((_deb <<1)|uint32 (_eed ))&0x1ff)|0x100;}else {_deb =(_deb <<1)|uint32 (_eed );};};return nil ;};func (_bb *Encoder )Refine (iTemp ,iTarget *_gb .Bitmap ,ox ,oy int )error {for _ca :=0;_ca < iTarget .Height ;_ca ++{var _cb int ;_eeb :=_ca +oy ;var (_eac ,_ecaa ,_cag ,_abg ,_gcd uint16 ;_ead ,_db ,_acg ,_dga ,_gea byte ;);if _eeb >=1&&(_eeb -1)< iTemp .Height {_ead =iTemp .Data [(_eeb -1)*iTemp .RowStride ];};if _eeb >=0&&_eeb < iTemp .Height {_db =iTemp .Data [_eeb *iTemp .RowStride ];};if _eeb >=-1&&_eeb +1< iTemp .Height {_acg =iTemp .Data [(_eeb +1)*iTemp .RowStride ];};if _ca >=1{_dga =iTarget .Data [(_ca -1)*iTarget .RowStride ];};_gea =iTarget .Data [_ca *iTarget .RowStride ];_cac :=uint (6+ox );_eac =uint16 (_ead >>_cac );_ecaa =uint16 (_db >>_cac );_cag =uint16 (_acg >>_cac );_abg =uint16 (_dga >>6);_cgf :=uint (2-ox );_ead <<=_cgf ;_db <<=_cgf ;_acg <<=_cgf ;_dga <<=2;for _cb =0;_cb < iTarget .Width ;_cb ++{_fdc :=(_eac <<10)|(_ecaa <<7)|(_cag <<4)|(_abg <<1)|_gcd ;_ecc :=_gea >>7;_faa :=_bb .encodeBit (_bb ._cc ,uint32 (_fdc ),_ecc );if _faa !=nil {return _faa ;};_eac <<=1;_ecaa <<=1;_cag <<=1;_abg <<=1;_eac |=uint16 (_ead >>7);_ecaa |=uint16 (_db >>7);_cag |=uint16 (_acg >>7);_abg |=uint16 (_dga >>7);_gcd =uint16 (_ecc );_aa :=_cb %8;_gca :=_cb /8+1;if _aa ==5+ox {_ead ,_db ,_acg =0,0,0;if _gca < iTemp .RowStride &&_eeb >=1&&(_eeb -1)< iTemp .Height {_ead =iTemp .Data [(_eeb -1)*iTemp .RowStride +_gca ];};if _gca < iTemp .RowStride &&_eeb >=0&&_eeb < iTemp .Height {_db =iTemp .Data [_eeb *iTemp .RowStride +_gca ];};if _gca < iTemp .RowStride &&_eeb >=-1&&(_eeb +1)< iTemp .Height {_acg =iTemp .Data [(_eeb +1)*iTemp .RowStride +_gca ];};}else {_ead <<=1;_db <<=1;_acg <<=1;};if _aa ==5&&_ca >=1{_dga =0;if _gca < iTarget .RowStride {_dga =iTarget .Data [(_ca -1)*iTarget .RowStride +_gca ];};}else {_dga <<=1;};if _aa ==7{_gea =0;if _gca < iTarget .RowStride {_gea =iTarget .Data [_ca *iTarget .RowStride +_gca ];};}else {_gea <<=1;};_eac &=7;_ecaa &=7;_cag &=7;_abg &=7;};};return nil ;};func (_efc *Encoder )Flush (){_efc ._dgd =0;_efc ._cd =nil ;_efc ._ac =-1};var _bbd =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};func (_gg *Encoder )flush (){_gg .setBits ();_gg ._bf <<=_gg ._ddb ;_gg .byteOut ();_gg ._bf <<=_gg ._ddb ;_gg .byteOut ();_gg .emit ();if _gg ._ef !=0xff{_gg ._ac ++;_gg ._ef =0xff;_gg .emit ();};_gg ._ac ++;_gg ._ef =0xac;_gg ._ac ++;_gg .emit ();};