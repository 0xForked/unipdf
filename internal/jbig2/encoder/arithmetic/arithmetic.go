//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_d "bytes";_a "github.com/unidoc/unipdf/v3/common";_fe "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_e "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_c "io";);func (_aag *Encoder )encodeInteger (_eb Class ,_dbb int )error {const _cadc ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";if _dbb > 2000000000||_dbb < -2000000000{return _e .Errorf (_cadc ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_dbb );};_gbaf :=_aag ._ddd [_eb ];_cfd :=uint32 (1);var _cgb int ;for ;;_cgb ++{if _ea [_cgb ]._b <=_dbb &&_ea [_cgb ]._g >=_dbb {break ;};};if _dbb < 0{_dbb =-_dbb ;};_dbb -=int (_ea [_cgb ]._ef );_edd :=_ea [_cgb ]._gg ;for _gaf :=uint8 (0);_gaf < _ea [_cgb ]._bf ;_gaf ++{_bbe :=_edd &1;if _gef :=_aag .encodeBit (_gbaf ,_cfd ,_bbe );_gef !=nil {return _e .Wrap (_gef ,_cadc ,"");};_edd >>=1;if _cfd &0x100> 0{_cfd =(((_cfd <<1)|uint32 (_bbe ))&0x1ff)|0x100;}else {_cfd =(_cfd <<1)|uint32 (_bbe );};};_dbb <<=32-_ea [_cgb ]._ca ;for _edda :=uint8 (0);_edda < _ea [_cgb ]._ca ;_edda ++{_bba :=uint8 ((uint32 (_dbb )&0x80000000)>>31);if _cgd :=_aag .encodeBit (_gbaf ,_cfd ,_bba );_cgd !=nil {return _e .Wrap (_cgd ,_cadc ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");};_dbb <<=1;if _cfd &0x100!=0{_cfd =(((_cfd <<1)|uint32 (_bba ))&0x1ff)|0x100;}else {_cfd =(_cfd <<1)|uint32 (_bba );};};return nil ;};func New ()*Encoder {_dea :=&Encoder {};_dea .Init ();return _dea };const (IAAI Class =iota ;IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);func (_ab *Encoder )EncodeBitmap (bm *_fe .Bitmap ,duplicateLineRemoval bool )error {_a .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );var (_afd ,_cce uint8 ;_ddf ,_fbd ,_bc uint16 ;_fa ,_gba ,_ga byte ;_fbb ,_bea ,_gbaa int ;_dg ,_cb []byte ;);for _fd :=0;_fd < bm .Height ;_fd ++{_fa ,_gba =0,0;if _fd >=2{_fa =bm .Data [(_fd -2)*bm .RowStride ];};if _fd >=1{_gba =bm .Data [(_fd -1)*bm .RowStride ];if duplicateLineRemoval {_bea =_fd *bm .RowStride ;_dg =bm .Data [_bea :_bea +bm .RowStride ];_gbaa =(_fd -1)*bm .RowStride ;_cb =bm .Data [_gbaa :_gbaa +bm .RowStride ];if _d .Equal (_dg ,_cb ){_cce =_afd ^1;_afd =1;}else {_cce =_afd ;_afd =0;};};};if duplicateLineRemoval {if _dgb :=_ab .encodeBit (_ab ._bd ,_ggb ,_cce );_dgb !=nil {return _dgb ;};if _afd !=0{continue ;};};_ga =bm .Data [_fd *bm .RowStride ];_ddf =uint16 (_fa >>5);_fbd =uint16 (_gba >>4);_fa <<=3;_gba <<=4;_bc =0;for _fbb =0;_fbb < bm .Width ;_fbb ++{_fdf :=uint32 (_ddf <<11|_fbd <<4|_bc );_bcb :=(_ga &0x80)>>7;_ge :=_ab .encodeBit (_ab ._bd ,_fdf ,_bcb );if _ge !=nil {return _ge ;};_ddf <<=1;_fbd <<=1;_bc <<=1;_ddf |=uint16 ((_fa &0x80)>>7);_fbd |=uint16 ((_gba &0x80)>>7);_bc |=uint16 (_bcb );_bcf :=_fbb %8;_bbg :=_fbb /8+1;if _bcf ==4&&_fd >=2{_fa =0;if _bbg < bm .RowStride {_fa =bm .Data [(_fd -2)*bm .RowStride +_bbg ];};}else {_fa <<=1;};if _bcf ==3&&_fd >=1{_gba =0;if _bbg < bm .RowStride {_gba =bm .Data [(_fd -1)*bm .RowStride +_bbg ];};}else {_gba <<=1;};if _bcf ==7{_ga =0;if _bbg < bm .RowStride {_ga =bm .Data [_fd *bm .RowStride +_bbg ];};}else {_ga <<=1;};_ddf &=31;_fbd &=127;_bc &=15;};};return nil ;};func (_cd Class )String ()string {switch _cd {case IAAI :return "\u0049\u0041\u0041\u0049";case IADH :return "\u0049\u0041\u0044\u0048";case IADS :return "\u0049\u0041\u0044\u0053";case IADT :return "\u0049\u0041\u0044\u0054";case IADW :return "\u0049\u0041\u0044\u0057";case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";case IAIT :return "\u0049\u0041\u0049\u0054";case IARDH :return "\u0049\u0041\u0052D\u0048";case IARDW :return "\u0049\u0041\u0052D\u0057";case IARDX :return "\u0049\u0041\u0052D\u0058";case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";};};func (_fga *Encoder )emit (){if _fga ._be ==_caf {_fga ._gbf =append (_fga ._gbf ,_fga ._af );_fga ._af =make ([]byte ,_caf );_fga ._be =0;};_fga ._af [_fga ._be ]=_fga ._fb ;_fga ._be ++;};func (_beg *Encoder )code0 (_cdb *codingContext ,_db uint32 ,_gbb uint16 ,_cf byte ){if _cdb .mps (_db )==0{_beg .codeMPS (_cdb ,_db ,_gbb ,_cf );}else {_beg .codeLPS (_cdb ,_db ,_gbb ,_cf );};};func (_eef *Encoder )DataSize ()int {return _eef .dataSize ()};func (_cab *Encoder )byteOut (){if _cab ._fb ==0xff{_cab .rBlock ();return ;};if _cab ._bfe < 0x8000000{_cab .lBlock ();return ;};_cab ._fb ++;if _cab ._fb !=0xff{_cab .lBlock ();return ;};_cab ._bfe &=0x7ffffff;_cab .rBlock ();};type state struct{_gdb uint16 ;_dfbg ,_afa uint8 ;_fdc uint8 ;};func (_ddde *Encoder )encodeBit (_aaa *codingContext ,_edad uint32 ,_cead uint8 )error {const _gecc ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";_ddde ._de ++;if _edad >=uint32 (len (_aaa ._ed )){return _e .Errorf (_gecc ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_edad );};_ead :=_aaa ._ed [_edad ];_cdba :=_aaa .mps (_edad );_gbfa :=_eadf [_ead ]._gdb ;_a .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_ddde ._de ,_cead ,_ead ,_cdba ,_gbfa ,_ddde ._ec ,_ddde ._bfe ,_ddde ._gb ,_ddde ._fb ,_ddde ._ee );if _cead ==0{_ddde .code0 (_aaa ,_edad ,_gbfa ,_ead );}else {_ddde .code1 (_aaa ,_edad ,_gbfa ,_ead );};return nil ;};func (_ecf *Encoder )EncodeIAID (symbolCodeLength ,value int )(_fdg error ){_a .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );if _fdg =_ecf .encodeIAID (symbolCodeLength ,value );_fdg !=nil {return _e .Wrap (_fdg ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};var _ _c .WriterTo =&Encoder {};type Class int ;func (_dgf *Encoder )Reset (){_dgf ._ec =0x8000;_dgf ._bfe =0;_dgf ._gb =12;_dgf ._ee =-1;_dgf ._fb =0;_dgf ._dec =nil ;_dgf ._bd =_cc (_cgg );};type intEncRangeS struct{_b ,_g int ;_gg ,_bf uint8 ;_ef uint16 ;_ca uint8 ;};const (_cgg =65536;_caf =20*1024;);func (_ba *Encoder )code1 (_bge *codingContext ,_dfb uint32 ,_dddg uint16 ,_cee byte ){if _bge .mps (_dfb )==1{_ba .codeMPS (_bge ,_dfb ,_dddg ,_cee );}else {_ba .codeLPS (_bge ,_dfb ,_dddg ,_cee );};};func (_ce *Encoder )EncodeInteger (proc Class ,value int )(_fea error ){_a .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );if _fea =_ce .encodeInteger (proc ,value );_fea !=nil {return _e .Wrap (_fea ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};func (_cag *Encoder )Refine (iTemp ,iTarget *_fe .Bitmap ,ox ,oy int )error {for _ecd :=0;_ecd < iTarget .Height ;_ecd ++{var _gbc int ;_fbbg :=_ecd +oy ;var (_bga ,_bcbe ,_agd ,_cg ,_fag uint16 ;_fed ,_cdd ,_feac ,_gae ,_eed byte ;);if _fbbg >=1&&(_fbbg -1)< iTemp .Height {_fed =iTemp .Data [(_fbbg -1)*iTemp .RowStride ];};if _fbbg >=0&&_fbbg < iTemp .Height {_cdd =iTemp .Data [_fbbg *iTemp .RowStride ];};if _fbbg >=-1&&_fbbg +1< iTemp .Height {_feac =iTemp .Data [(_fbbg +1)*iTemp .RowStride ];};if _ecd >=1{_gae =iTarget .Data [(_ecd -1)*iTarget .RowStride ];};_eed =iTarget .Data [_ecd *iTarget .RowStride ];_aa :=uint (6+ox );_bga =uint16 (_fed >>_aa );_bcbe =uint16 (_cdd >>_aa );_agd =uint16 (_feac >>_aa );_cg =uint16 (_gae >>6);_abe :=uint (2-ox );_fed <<=_abe ;_cdd <<=_abe ;_feac <<=_abe ;_gae <<=2;for _gbc =0;_gbc < iTarget .Width ;_gbc ++{_gbe :=(_bga <<10)|(_bcbe <<7)|(_agd <<4)|(_cg <<1)|_fag ;_df :=_eed >>7;_cad :=_cag .encodeBit (_cag ._bd ,uint32 (_gbe ),_df );if _cad !=nil {return _cad ;};_bga <<=1;_bcbe <<=1;_agd <<=1;_cg <<=1;_bga |=uint16 (_fed >>7);_bcbe |=uint16 (_cdd >>7);_agd |=uint16 (_feac >>7);_cg |=uint16 (_gae >>7);_fag =uint16 (_df );_fbc :=_gbc %8;_bcg :=_gbc /8+1;if _fbc ==5+ox {_fed ,_cdd ,_feac =0,0,0;if _bcg < iTemp .RowStride &&_fbbg >=1&&(_fbbg -1)< iTemp .Height {_fed =iTemp .Data [(_fbbg -1)*iTemp .RowStride +_bcg ];};if _bcg < iTemp .RowStride &&_fbbg >=0&&_fbbg < iTemp .Height {_cdd =iTemp .Data [_fbbg *iTemp .RowStride +_bcg ];};if _bcg < iTemp .RowStride &&_fbbg >=-1&&(_fbbg +1)< iTemp .Height {_feac =iTemp .Data [(_fbbg +1)*iTemp .RowStride +_bcg ];};}else {_fed <<=1;_cdd <<=1;_feac <<=1;};if _fbc ==5&&_ecd >=1{_gae =0;if _bcg < iTarget .RowStride {_gae =iTarget .Data [(_ecd -1)*iTarget .RowStride +_bcg ];};}else {_gae <<=1;};if _fbc ==7{_eed =0;if _bcg < iTarget .RowStride {_eed =iTarget .Data [_ecd *iTarget .RowStride +_bcg ];};}else {_eed <<=1;};_bga &=7;_bcbe &=7;_agd &=7;_cg &=7;};};return nil ;};func (_efb *Encoder )Final (){_efb .flush ()};func (_feb *Encoder )encodeOOB (_eegb Class )error {_dcg :=_feb ._ddd [_eegb ];_eac :=_feb .encodeBit (_dcg ,1,1);if _eac !=nil {return _eac ;};_eac =_feb .encodeBit (_dcg ,3,0);if _eac !=nil {return _eac ;};_eac =_feb .encodeBit (_dcg ,6,0);if _eac !=nil {return _eac ;};_eac =_feb .encodeBit (_dcg ,12,0);if _eac !=nil {return _eac ;};return nil ;};func (_adc *Encoder )Init (){_adc ._bd =_cc (_cgg );_adc ._ec =0x8000;_adc ._bfe =0;_adc ._gb =12;_adc ._ee =-1;_adc ._fb =0;_adc ._be =0;_adc ._af =make ([]byte ,_caf );for _eae :=0;_eae < len (_adc ._ddd );_eae ++{_adc ._ddd [_eae ]=_cc (512);};_adc ._dec =nil ;};func (_bad *Encoder )codeMPS (_gec *codingContext ,_ccf uint32 ,_ded uint16 ,_eda byte ){_bad ._ec -=_ded ;if _bad ._ec &0x8000!=0{_bad ._bfe +=uint32 (_ded );return ;};if _bad ._ec < _ded {_bad ._ec =_ded ;}else {_bad ._bfe +=uint32 (_ded );};_gec ._ed [_ccf ]=_eadf [_eda ]._dfbg ;_bad .renormalize ();};const _ggb =0x9b25;type codingContext struct{_ed []byte ;_dd []byte ;};func (_ag *codingContext )mps (_bg uint32 )int {return int (_ag ._dd [_bg ])};var _eadf =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};func (_deg *Encoder )lBlock (){if _deg ._ee >=0{_deg .emit ();};_deg ._ee ++;_deg ._fb =uint8 (_deg ._bfe >>19);_deg ._bfe &=0x7ffff;_deg ._gb =8;};func (_dfd *Encoder )flush (){_dfd .setBits ();_dfd ._bfe <<=_dfd ._gb ;_dfd .byteOut ();_dfd ._bfe <<=_dfd ._gb ;_dfd .byteOut ();_dfd .emit ();if _dfd ._fb !=0xff{_dfd ._ee ++;_dfd ._fb =0xff;_dfd .emit ();};_dfd ._ee ++;_dfd ._fb =0xac;_dfd ._ee ++;_dfd .emit ();};func (_acg *Encoder )Flush (){_acg ._be =0;_acg ._gbf =nil ;_acg ._ee =-1};func _cc (_ad int )*codingContext {return &codingContext {_ed :make ([]byte ,_ad ),_dd :make ([]byte ,_ad )};};func (_dga *Encoder )WriteTo (w _c .Writer )(int64 ,error ){const _cea ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";var _fg int64 ;for _gbec ,_fad :=range _dga ._gbf {_agc ,_fgb :=w .Write (_fad );if _fgb !=nil {return 0,_e .Wrapf (_fgb ,_cea ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_gbec );};_fg +=int64 (_agc );};_dga ._af =_dga ._af [:_dga ._be ];_cced ,_fde :=w .Write (_dga ._af );if _fde !=nil {return 0,_e .Wrap (_fde ,_cea ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_fg +=int64 (_cced );return _fg ,nil ;};func (_ebb *Encoder )rBlock (){if _ebb ._ee >=0{_ebb .emit ();};_ebb ._ee ++;_ebb ._fb =uint8 (_ebb ._bfe >>20);_ebb ._bfe &=0xfffff;_ebb ._gb =7;};func (_gac *Encoder )encodeIAID (_bef ,_fac int )error {if _gac ._dec ==nil {_gac ._dec =_cc (1<<uint (_bef ));};_cef :=uint32 (1<<uint32 (_bef +1))-1;_fac <<=uint (32-_bef );_eab :=uint32 (1);for _bcge :=0;_bcge < _bef ;_bcge ++{_gd :=_eab &_cef ;_fede :=uint8 ((uint32 (_fac )&0x80000000)>>31);if _gbbd :=_gac .encodeBit (_gac ._dec ,_gd ,_fede );_gbbd !=nil {return _gbbd ;};_eab =(_eab <<1)|uint32 (_fede );_fac <<=1;};return nil ;};func (_bbb *Encoder )setBits (){_efbf :=_bbb ._bfe +uint32 (_bbb ._ec );_bbb ._bfe |=0xffff;if _bbb ._bfe >=_efbf {_bbb ._bfe -=0x8000;};};func (_bfed *Encoder )renormalize (){for {_bfed ._ec <<=1;_bfed ._bfe <<=1;_bfed ._gb --;if _bfed ._gb ==0{_bfed .byteOut ();};if (_bfed ._ec &0x8000)!=0{break ;};};};func (_bb *codingContext )flipMps (_gf uint32 ){_bb ._dd [_gf ]=1-_bb ._dd [_gf ]};func (_ac *Encoder )EncodeOOB (proc Class )(_bgc error ){_a .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );if _bgc =_ac .encodeOOB (proc );_bgc !=nil {return _e .Wrap (_bgc ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};type Encoder struct{_bfe uint32 ;_ec uint16 ;_gb ,_fb uint8 ;_ee int ;_de int ;_gbf [][]byte ;_af []byte ;_be int ;_bd *codingContext ;_ddd [13]*codingContext ;_dec *codingContext ;};func (_dc *Encoder )codeLPS (_eeg *codingContext ,_bee uint32 ,_afc uint16 ,_afe byte ){_dc ._ec -=_afc ;if _dc ._ec < _afc {_dc ._bfe +=uint32 (_afc );}else {_dc ._ec =_afc ;};if _eadf [_afe ]._fdc ==1{_eeg .flipMps (_bee );};_eeg ._ed [_bee ]=_eadf [_afe ]._afa ;_dc .renormalize ();};func (_beed *Encoder )dataSize ()int {return _caf *len (_beed ._gbf )+_beed ._be };var _ea =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};