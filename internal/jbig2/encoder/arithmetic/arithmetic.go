//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_g "bytes";_gc "github.com/unidoc/unipdf/v3/common";_gb "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_ge "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_b "io";);func (_gfd *Encoder )code1 (_gcbd *codingContext ,_dae uint32 ,_aaa uint16 ,_gbc byte ){if _gcbd .mps (_dae )==1{_gfd .codeMPS (_gcbd ,_dae ,_aaa ,_gbc );
}else {_gfd .codeLPS (_gcbd ,_dae ,_aaa ,_gbc );};};func (_ded *Encoder )Flush (){_ded ._gcb =0;_ded ._eb =nil ;_ded ._efc =-1};func New ()*Encoder {_bbg :=&Encoder {};_bbg .Init ();return _bbg };func (_dfd *Encoder )emit (){if _dfd ._gcb ==_ecd {_dfd ._eb =append (_dfd ._eb ,_dfd ._gbg );
_dfd ._gbg =make ([]byte ,_ecd );_dfd ._gcb =0;};_dfd ._gbg [_dfd ._gcb ]=_dfd ._cgf ;_dfd ._gcb ++;};func (_beca *Encoder )byteOut (){if _beca ._cgf ==0xff{_beca .rBlock ();return ;};if _beca ._gf < 0x8000000{_beca .lBlock ();return ;};_beca ._cgf ++;
if _beca ._cgf !=0xff{_beca .lBlock ();return ;};_beca ._gf &=0x7ffffff;_beca .rBlock ();};type state struct{_efg uint16 ;_gag ,_beb uint8 ;_fbg uint8 ;};type codingContext struct{_c []byte ;_geb []byte ;};func (_fg *Encoder )EncodeInteger (proc Class ,value int )(_bcb error ){_gc .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );
if _bcb =_fg .encodeInteger (proc ,value );_bcb !=nil {return _ge .Wrap (_bcb ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};func (_ed *Encoder )Refine (iTemp ,iTarget *_gb .Bitmap ,ox ,oy int )error {for _gaa :=0;
_gaa < iTarget .Height ;_gaa ++{var _aa int ;_af :=_gaa +oy ;var (_cc ,_bg ,_def ,_fb ,_cb uint16 ;_ece ,_cgb ,_gd ,_bbgb ,_bed byte ;);if _af >=1&&(_af -1)< iTemp .Height {_ece =iTemp .Data [(_af -1)*iTemp .RowStride ];};if _af >=0&&_af < iTemp .Height {_cgb =iTemp .Data [_af *iTemp .RowStride ];
};if _af >=-1&&_af +1< iTemp .Height {_gd =iTemp .Data [(_af +1)*iTemp .RowStride ];};if _gaa >=1{_bbgb =iTarget .Data [(_gaa -1)*iTarget .RowStride ];};_bed =iTarget .Data [_gaa *iTarget .RowStride ];_bge :=uint (6+ox );_cc =uint16 (_ece >>_bge );_bg =uint16 (_cgb >>_bge );
_def =uint16 (_gd >>_bge );_fb =uint16 (_bbgb >>6);_efb :=uint (2-ox );_ece <<=_efb ;_cgb <<=_efb ;_gd <<=_efb ;_bbgb <<=2;for _aa =0;_aa < iTarget .Width ;_aa ++{_gad :=(_cc <<10)|(_bg <<7)|(_def <<4)|(_fb <<1)|_cb ;_cde :=_bed >>7;_bce :=_ed .encodeBit (_ed ._bf ,uint32 (_gad ),_cde );
if _bce !=nil {return _bce ;};_cc <<=1;_bg <<=1;_def <<=1;_fb <<=1;_cc |=uint16 (_ece >>7);_bg |=uint16 (_cgb >>7);_def |=uint16 (_gd >>7);_fb |=uint16 (_bbgb >>7);_cb =uint16 (_cde );_bd :=_aa %8;_fd :=_aa /8+1;if _bd ==5+ox {_ece ,_cgb ,_gd =0,0,0;if _fd < iTemp .RowStride &&_af >=1&&(_af -1)< iTemp .Height {_ece =iTemp .Data [(_af -1)*iTemp .RowStride +_fd ];
};if _fd < iTemp .RowStride &&_af >=0&&_af < iTemp .Height {_cgb =iTemp .Data [_af *iTemp .RowStride +_fd ];};if _fd < iTemp .RowStride &&_af >=-1&&(_af +1)< iTemp .Height {_gd =iTemp .Data [(_af +1)*iTemp .RowStride +_fd ];};}else {_ece <<=1;_cgb <<=1;
_gd <<=1;};if _bd ==5&&_gaa >=1{_bbgb =0;if _fd < iTarget .RowStride {_bbgb =iTarget .Data [(_gaa -1)*iTarget .RowStride +_fd ];};}else {_bbgb <<=1;};if _bd ==7{_bed =0;if _fd < iTarget .RowStride {_bed =iTarget .Data [_gaa *iTarget .RowStride +_fd ];};
}else {_bed <<=1;};_cc &=7;_bg &=7;_def &=7;_fb &=7;};};return nil ;};func (_gfaa *Encoder )renormalize (){for {_gfaa ._f <<=1;_gfaa ._gf <<=1;_gfaa ._ga --;if _gfaa ._ga ==0{_gfaa .byteOut ();};if (_gfaa ._f &0x8000)!=0{break ;};};};func (_bgef *Encoder )encodeBit (_dca *codingContext ,_caeg uint32 ,_gfdc uint8 )error {const _ebc ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";
_bgef ._ecg ++;if _caeg >=uint32 (len (_dca ._c )){return _ge .Errorf (_ebc ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_caeg );
};_age :=_dca ._c [_caeg ];_fbd :=_dca .mps (_caeg );_caea :=_becg [_age ]._efg ;_gc .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_bgef ._ecg ,_gfdc ,_age ,_fbd ,_caea ,_bgef ._f ,_bgef ._gf ,_bgef ._ga ,_bgef ._cgf ,_bgef ._efc );
if _gfdc ==0{_bgef .code0 (_dca ,_caeg ,_caea ,_age );}else {_bgef .code1 (_dca ,_caeg ,_caea ,_age );};return nil ;};type Class int ;func (_gfb *Encoder )encodeIAID (_aeea ,_ega int )error {if _gfb ._ff ==nil {_gfb ._ff =_ee (1<<uint (_aeea ));};_fbdg :=uint32 (1<<uint32 (_aeea +1))-1;
_ega <<=uint (32-_aeea );_ccd :=uint32 (1);for _adc :=0;_adc < _aeea ;_adc ++{_cec :=_ccd &_fbdg ;_cce :=uint8 ((uint32 (_ega )&0x80000000)>>31);if _fdg :=_gfb .encodeBit (_gfb ._ff ,_cec ,_cce );_fdg !=nil {return _fdg ;};_ccd =(_ccd <<1)|uint32 (_cce );
_ega <<=1;};return nil ;};const _de =0x9b25;func (_deda *Encoder )encodeInteger (_bba Class ,_gaad int )error {const _dgb ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";if _gaad > 2000000000||_gaad < -2000000000{return _ge .Errorf (_dgb ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_gaad );
};_fef :=_deda ._dg [_bba ];_ac :=uint32 (1);var _bdff int ;for ;;_bdff ++{if _ef [_bdff ]._d <=_gaad &&_ef [_bdff ]._be >=_gaad {break ;};};if _gaad < 0{_gaad =-_gaad ;};_gaad -=int (_ef [_bdff ]._ae );_aee :=_ef [_bdff ]._eg ;for _aeaf :=uint8 (0);_aeaf < _ef [_bdff ]._bb ;
_aeaf ++{_eeb :=_aee &1;if _aga :=_deda .encodeBit (_fef ,_ac ,_eeb );_aga !=nil {return _ge .Wrap (_aga ,_dgb ,"");};_aee >>=1;if _ac &0x100> 0{_ac =(((_ac <<1)|uint32 (_eeb ))&0x1ff)|0x100;}else {_ac =(_ac <<1)|uint32 (_eeb );};};_gaad <<=32-_ef [_bdff ]._ec ;
for _cfd :=uint8 (0);_cfd < _ef [_bdff ]._ec ;_cfd ++{_efcb :=uint8 ((uint32 (_gaad )&0x80000000)>>31);if _ffc :=_deda .encodeBit (_fef ,_ac ,_efcb );_ffc !=nil {return _ge .Wrap (_ffc ,_dgb ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");
};_gaad <<=1;if _ac &0x100!=0{_ac =(((_ac <<1)|uint32 (_efcb ))&0x1ff)|0x100;}else {_ac =(_ac <<1)|uint32 (_efcb );};};return nil ;};var _ _b .WriterTo =&Encoder {};func (_ecb *Encoder )EncodeBitmap (bm *_gb .Bitmap ,duplicateLineRemoval bool )error {_gc .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );
var (_fe ,_bec uint8 ;_deg ,_fee ,_fea uint16 ;_ca ,_cae ,_cd byte ;_aea ,_bbgc ,_ebg int ;_gcad ,_dc []byte ;);for _ea :=0;_ea < bm .Height ;_ea ++{_ca ,_cae =0,0;if _ea >=2{_ca =bm .Data [(_ea -2)*bm .RowStride ];};if _ea >=1{_cae =bm .Data [(_ea -1)*bm .RowStride ];
if duplicateLineRemoval {_bbgc =_ea *bm .RowStride ;_gcad =bm .Data [_bbgc :_bbgc +bm .RowStride ];_ebg =(_ea -1)*bm .RowStride ;_dc =bm .Data [_ebg :_ebg +bm .RowStride ];if _g .Equal (_gcad ,_dc ){_bec =_fe ^1;_fe =1;}else {_bec =_fe ;_fe =0;};};};if duplicateLineRemoval {if _ebf :=_ecb .encodeBit (_ecb ._bf ,_de ,_bec );
_ebf !=nil {return _ebf ;};if _fe !=0{continue ;};};_cd =bm .Data [_ea *bm .RowStride ];_deg =uint16 (_ca >>5);_fee =uint16 (_cae >>4);_ca <<=3;_cae <<=4;_fea =0;for _aea =0;_aea < bm .Width ;_aea ++{_gfa :=uint32 (_deg <<11|_fee <<4|_fea );_ba :=(_cd &0x80)>>7;
_eeg :=_ecb .encodeBit (_ecb ._bf ,_gfa ,_ba );if _eeg !=nil {return _eeg ;};_deg <<=1;_fee <<=1;_fea <<=1;_deg |=uint16 ((_ca &0x80)>>7);_fee |=uint16 ((_cae &0x80)>>7);_fea |=uint16 (_ba );_gg :=_aea %8;_gcg :=_aea /8+1;if _gg ==4&&_ea >=2{_ca =0;if _gcg < bm .RowStride {_ca =bm .Data [(_ea -2)*bm .RowStride +_gcg ];
};}else {_ca <<=1;};if _gg ==3&&_ea >=1{_cae =0;if _gcg < bm .RowStride {_cae =bm .Data [(_ea -1)*bm .RowStride +_gcg ];};}else {_cae <<=1;};if _gg ==7{_cd =0;if _gcg < bm .RowStride {_cd =bm .Data [_ea *bm .RowStride +_gcg ];};}else {_cd <<=1;};_deg &=31;
_fee &=127;_fea &=15;};};return nil ;};func (_ebgb *Encoder )WriteTo (w _b .Writer )(int64 ,error ){const _gac ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";var _bdd int64 ;for _ebff ,_ab :=range _ebgb ._eb {_ffb ,_ad :=w .Write (_ab );
if _ad !=nil {return 0,_ge .Wrapf (_ad ,_gac ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_ebff );};_bdd +=int64 (_ffb );};_ebgb ._gbg =_ebgb ._gbg [:_ebgb ._gcb ];
_gbe ,_bfg :=w .Write (_ebgb ._gbg );if _bfg !=nil {return 0,_ge .Wrap (_bfg ,_gac ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_bdd +=int64 (_gbe );return _bdd ,nil ;};type Encoder struct{_gf uint32 ;_f uint16 ;
_ga ,_cgf uint8 ;_efc int ;_ecg int ;_eb [][]byte ;_gbg []byte ;_gcb int ;_bf *codingContext ;_dg [13]*codingContext ;_ff *codingContext ;};func (_edb *Encoder )codeMPS (_bddb *codingContext ,_cgff uint32 ,_cf uint16 ,_aab byte ){_edb ._f -=_cf ;if _edb ._f &0x8000!=0{_edb ._gf +=uint32 (_cf );
return ;};if _edb ._f < _cf {_edb ._f =_cf ;}else {_edb ._gf +=uint32 (_cf );};_bddb ._c [_cgff ]=_becg [_aab ]._gag ;_edb .renormalize ();};var _becg =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
func (_ag *Encoder )DataSize ()int {return _ag .dataSize ()};func (_daa *Encoder )dataSize ()int {return _ecd *len (_daa ._eb )+_daa ._gcb };func (_gbd *Encoder )flush (){_gbd .setBits ();_gbd ._gf <<=_gbd ._ga ;_gbd .byteOut ();_gbd ._gf <<=_gbd ._ga ;
_gbd .byteOut ();_gbd .emit ();if _gbd ._cgf !=0xff{_gbd ._efc ++;_gbd ._cgf =0xff;_gbd .emit ();};_gbd ._efc ++;_gbd ._cgf =0xac;_gbd ._efc ++;_gbd .emit ();};func (_bc *codingContext )mps (_gca uint32 )int {return int (_bc ._geb [_gca ])};func (_agc *Encoder )EncodeIAID (symbolCodeLength ,value int )(_bcc error ){_gc .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );
if _bcc =_agc .encodeIAID (symbolCodeLength ,value );_bcc !=nil {return _ge .Wrap (_bcc ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};func (_gbf *Encoder )rBlock (){if _gbf ._efc >=0{_gbf .emit ();};_gbf ._efc ++;_gbf ._cgf =uint8 (_gbf ._gf >>20);
_gbf ._gf &=0xfffff;_gbf ._ga =7;};func (_gcd *codingContext )flipMps (_db uint32 ){_gcd ._geb [_db ]=1-_gcd ._geb [_db ]};const (IAAI Class =iota ;IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);type intEncRangeS struct{_d ,_be int ;
_eg ,_bb uint8 ;_ae uint16 ;_ec uint8 ;};func (_adcg *Encoder )encodeOOB (_eaf Class )error {_bbb :=_adcg ._dg [_eaf ];_cga :=_adcg .encodeBit (_bbb ,1,1);if _cga !=nil {return _cga ;};_cga =_adcg .encodeBit (_bbb ,3,0);if _cga !=nil {return _cga ;};_cga =_adcg .encodeBit (_bbb ,6,0);
if _cga !=nil {return _cga ;};_cga =_adcg .encodeBit (_bbb ,12,0);if _cga !=nil {return _cga ;};return nil ;};const (_agd =65536;_ecd =20*1024;);func (_ddb *Encoder )setBits (){_ffdf :=_ddb ._gf +uint32 (_ddb ._f );_ddb ._gf |=0xffff;if _ddb ._gf >=_ffdf {_ddb ._gf -=0x8000;
};};func (_eec *Encoder )Reset (){_eec ._f =0x8000;_eec ._gf =0;_eec ._ga =12;_eec ._efc =-1;_eec ._cgf =0;_eec ._ff =nil ;_eec ._bf =_ee (_agd );};func (_e Class )String ()string {switch _e {case IAAI :return "\u0049\u0041\u0041\u0049";case IADH :return "\u0049\u0041\u0044\u0048";
case IADS :return "\u0049\u0041\u0044\u0053";case IADT :return "\u0049\u0041\u0044\u0054";case IADW :return "\u0049\u0041\u0044\u0057";case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";case IAIT :return "\u0049\u0041\u0049\u0054";
case IARDH :return "\u0049\u0041\u0052D\u0048";case IARDW :return "\u0049\u0041\u0052D\u0057";case IARDX :return "\u0049\u0041\u0052D\u0058";case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";
};};func (_dd *Encoder )Init (){_dd ._bf =_ee (_agd );_dd ._f =0x8000;_dd ._gf =0;_dd ._ga =12;_dd ._efc =-1;_dd ._cgf =0;_dd ._gcb =0;_dd ._gbg =make ([]byte ,_ecd );for _fa :=0;_fa < len (_dd ._dg );_fa ++{_dd ._dg [_fa ]=_ee (512);};_dd ._ff =nil ;};
var _ef =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};
func (_afa *Encoder )codeLPS (_fge *codingContext ,_cad uint32 ,_dba uint16 ,_gdd byte ){_afa ._f -=_dba ;if _afa ._f < _dba {_afa ._gf +=uint32 (_dba );}else {_afa ._f =_dba ;};if _becg [_gdd ]._fbg ==1{_fge .flipMps (_cad );};_fge ._c [_cad ]=_becg [_gdd ]._beb ;
_afa .renormalize ();};func _ee (_cg int )*codingContext {return &codingContext {_c :make ([]byte ,_cg ),_geb :make ([]byte ,_cg )};};func (_ffd *Encoder )EncodeOOB (proc Class )(_df error ){_gc .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );
if _df =_ffd .encodeOOB (proc );_df !=nil {return _ge .Wrap (_df ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};func (_bdf *Encoder )code0 (_ffdg *codingContext ,_ede uint32 ,_da uint16 ,_ddc byte ){if _ffdg .mps (_ede )==0{_bdf .codeMPS (_ffdg ,_ede ,_da ,_ddc );
}else {_bdf .codeLPS (_ffdg ,_ede ,_da ,_ddc );};};func (_ce *Encoder )Final (){_ce .flush ()};func (_aad *Encoder )lBlock (){if _aad ._efc >=0{_aad .emit ();};_aad ._efc ++;_aad ._cgf =uint8 (_aad ._gf >>19);_aad ._gf &=0x7ffff;_aad ._ga =8;};