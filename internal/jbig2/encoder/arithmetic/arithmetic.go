//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_e "bytes";_ee "github.com/unidoc/unipdf/v3/common";_ag "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_c "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_d "io";);func New ()*Encoder {_bab :=&Encoder {};_bab .Init ();return _bab };func (_gd *Encoder )lBlock (){if _gd ._ce >=0{_gd .emit ();};_gd ._ce ++;_gd ._bf =uint8 (_gd ._bd >>19);_gd ._bd &=0x7ffff;_gd ._ebd =8;};func (_abe *Encoder )encodeOOB (_dgfc Class )error {_dec :=_abe ._ba [_dgfc ];_gbf :=_abe .encodeBit (_dec ,1,1);if _gbf !=nil {return _gbf ;};_gbf =_abe .encodeBit (_dec ,3,0);if _gbf !=nil {return _gbf ;};_gbf =_abe .encodeBit (_dec ,6,0);if _gbf !=nil {return _gbf ;};_gbf =_abe .encodeBit (_dec ,12,0);if _gbf !=nil {return _gbf ;};return nil ;};const _af =0x9b25;func (_dce *Encoder )encodeInteger (_dad Class ,_gg int )error {const _fdb ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";if _gg > 2000000000||_gg < -2000000000{return _c .Errorf (_fdb ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_gg );};_bce :=_dce ._ba [_dad ];_fca :=uint32 (1);var _eae int ;for ;;_eae ++{if _ad [_eae ]._ca <=_gg &&_ad [_eae ]._ec >=_gg {break ;};};if _gg < 0{_gg =-_gg ;};_gg -=int (_ad [_eae ]._cab );_fdba :=_ad [_eae ]._dg ;for _egc :=uint8 (0);_egc < _ad [_eae ]._eb ;_egc ++{_fcb :=_fdba &1;if _aee :=_dce .encodeBit (_bce ,_fca ,_fcb );_aee !=nil {return _c .Wrap (_aee ,_fdb ,"");};_fdba >>=1;if _fca &0x100> 0{_fca =(((_fca <<1)|uint32 (_fcb ))&0x1ff)|0x100;}else {_fca =(_fca <<1)|uint32 (_fcb );};};_gg <<=32-_ad [_eae ]._g ;for _ggb :=uint8 (0);_ggb < _ad [_eae ]._g ;_ggb ++{_aea :=uint8 ((uint32 (_gg )&0x80000000)>>31);if _gfa :=_dce .encodeBit (_bce ,_fca ,_aea );_gfa !=nil {return _c .Wrap (_gfa ,_fdb ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");};_gg <<=1;if _fca &0x100!=0{_fca =(((_fca <<1)|uint32 (_aea ))&0x1ff)|0x100;}else {_fca =(_fca <<1)|uint32 (_aea );};};return nil ;};func (_dcd *Encoder )code0 (_gcb *codingContext ,_fgd uint32 ,_dgcf uint16 ,_add byte ){if _gcb .mps (_fgd )==0{_dcd .codeMPS (_gcb ,_fgd ,_dgcf ,_add );}else {_dcd .codeLPS (_gcb ,_fgd ,_dgcf ,_add );};};func (_bfc *Encoder )encodeBit (_bae *codingContext ,_ece uint32 ,_gfd uint8 )error {const _gbg ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";_bfc ._eg ++;if _ece >=uint32 (len (_bae ._gf )){return _c .Errorf (_gbg ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_ece );};_efg :=_bae ._gf [_ece ];_dbe :=_bae .mps (_ece );_gec :=_cbfd [_efg ]._dcg ;_ee .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_bfc ._eg ,_gfd ,_efg ,_dbe ,_gec ,_bfc ._cb ,_bfc ._bd ,_bfc ._ebd ,_bfc ._bf ,_bfc ._ce );if _gfd ==0{_bfc .code0 (_bae ,_ece ,_gec ,_efg );}else {_bfc .code1 (_bae ,_ece ,_gec ,_efg );};return nil ;};func (_dba *Encoder )Refine (iTemp ,iTarget *_ag .Bitmap ,ox ,oy int )error {for _acd :=0;_acd < iTarget .Height ;_acd ++{var _dgc int ;_dgg :=_acd +oy ;var (_bc ,_ebeb ,_dbc ,_eed ,_eede uint16 ;_aef ,_cea ,_bdb ,_efc ,_dac byte ;);if _dgg >=1&&(_dgg -1)< iTemp .Height {_aef =iTemp .Data [(_dgg -1)*iTemp .RowStride ];};if _dgg >=0&&_dgg < iTemp .Height {_cea =iTemp .Data [_dgg *iTemp .RowStride ];};if _dgg >=-1&&_dgg +1< iTemp .Height {_bdb =iTemp .Data [(_dgg +1)*iTemp .RowStride ];};if _acd >=1{_efc =iTarget .Data [(_acd -1)*iTarget .RowStride ];};_dac =iTarget .Data [_acd *iTarget .RowStride ];_edf :=uint (6+ox );_bc =uint16 (_aef >>_edf );_ebeb =uint16 (_cea >>_edf );_dbc =uint16 (_bdb >>_edf );_eed =uint16 (_efc >>6);_bagg :=uint (2-ox );_aef <<=_bagg ;_cea <<=_bagg ;_bdb <<=_bagg ;_efc <<=2;for _dgc =0;_dgc < iTarget .Width ;_dgc ++{_gb :=(_bc <<10)|(_ebeb <<7)|(_dbc <<4)|(_eed <<1)|_eede ;_bee :=_dac >>7;_baa :=_dba .encodeBit (_dba ._da ,uint32 (_gb ),_bee );if _baa !=nil {return _baa ;};_bc <<=1;_ebeb <<=1;_dbc <<=1;_eed <<=1;_bc |=uint16 (_aef >>7);_ebeb |=uint16 (_cea >>7);_dbc |=uint16 (_bdb >>7);_eed |=uint16 (_efc >>7);_eede =uint16 (_bee );_daa :=_dgc %8;_beb :=_dgc /8+1;if _daa ==5+ox {_aef ,_cea ,_bdb =0,0,0;if _beb < iTemp .RowStride &&_dgg >=1&&(_dgg -1)< iTemp .Height {_aef =iTemp .Data [(_dgg -1)*iTemp .RowStride +_beb ];};if _beb < iTemp .RowStride &&_dgg >=0&&_dgg < iTemp .Height {_cea =iTemp .Data [_dgg *iTemp .RowStride +_beb ];};if _beb < iTemp .RowStride &&_dgg >=-1&&(_dgg +1)< iTemp .Height {_bdb =iTemp .Data [(_dgg +1)*iTemp .RowStride +_beb ];};}else {_aef <<=1;_cea <<=1;_bdb <<=1;};if _daa ==5&&_acd >=1{_efc =0;if _beb < iTarget .RowStride {_efc =iTarget .Data [(_acd -1)*iTarget .RowStride +_beb ];};}else {_efc <<=1;};if _daa ==7{_dac =0;if _beb < iTarget .RowStride {_dac =iTarget .Data [_acd *iTarget .RowStride +_beb ];};}else {_dac <<=1;};_bc &=7;_ebeb &=7;_dbc &=7;_eed &=7;};};return nil ;};func (_ac Class )String ()string {switch _ac {case IAAI :return "\u0049\u0041\u0041\u0049";case IADH :return "\u0049\u0041\u0044\u0048";case IADS :return "\u0049\u0041\u0044\u0053";case IADT :return "\u0049\u0041\u0044\u0054";case IADW :return "\u0049\u0041\u0044\u0057";case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";case IAIT :return "\u0049\u0041\u0049\u0054";case IARDH :return "\u0049\u0041\u0052D\u0048";case IARDW :return "\u0049\u0041\u0052D\u0057";case IARDX :return "\u0049\u0041\u0052D\u0058";case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";};};type state struct{_dcg uint16 ;_edfe ,_baea uint8 ;_cef uint8 ;};const (IAAI Class =iota ;IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);type codingContext struct{_gf []byte ;_ade []byte ;};func (_cg *Encoder )byteOut (){if _cg ._bf ==0xff{_cg .rBlock ();return ;};if _cg ._bd < 0x8000000{_cg .lBlock ();return ;};_cg ._bf ++;if _cg ._bf !=0xff{_cg .lBlock ();return ;};_cg ._bd &=0x7ffffff;_cg .rBlock ();};func _b (_fa int )*codingContext {return &codingContext {_gf :make ([]byte ,_fa ),_ade :make ([]byte ,_fa )};};func (_cbe *Encoder )EncodeInteger (proc Class ,value int )(_afa error ){_ee .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );if _afa =_cbe .encodeInteger (proc ,value );_afa !=nil {return _c .Wrap (_afa ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};func (_fef *Encoder )rBlock (){if _fef ._ce >=0{_fef .emit ();};_fef ._ce ++;_fef ._bf =uint8 (_fef ._bd >>20);_fef ._bd &=0xfffff;_fef ._ebd =7;};const (_cdd =65536;_fbf =20*1024;);func (_ege *Encoder )encodeIAID (_eef ,_caa int )error {if _ege ._ed ==nil {_ege ._ed =_b (1<<uint (_eef ));};_gad :=uint32 (1<<uint32 (_eef +1))-1;_caa <<=uint (32-_eef );_gbb :=uint32 (1);for _cca :=0;_cca < _eef ;_cca ++{_def :=_gbb &_gad ;_bcd :=uint8 ((uint32 (_caa )&0x80000000)>>31);if _eaa :=_ege .encodeBit (_ege ._ed ,_def ,_bcd );_eaa !=nil {return _eaa ;};_gbb =(_gbb <<1)|uint32 (_bcd );_caa <<=1;};return nil ;};func (_bag *Encoder )EncodeIAID (symbolCodeLength ,value int )(_fg error ){_ee .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );if _fg =_bag .encodeIAID (symbolCodeLength ,value );_fg !=nil {return _c .Wrap (_fg ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};func (_abf *Encoder )setBits (){_defc :=_abf ._bd +uint32 (_abf ._cb );_abf ._bd |=0xffff;if _abf ._bd >=_defc {_abf ._bd -=0x8000;};};func (_gecb *Encoder )renormalize (){for {_gecb ._cb <<=1;_gecb ._bd <<=1;_gecb ._ebd --;if _gecb ._ebd ==0{_gecb .byteOut ();};if (_gecb ._cb &0x8000)!=0{break ;};};};func (_ge *Encoder )Init (){_ge ._da =_b (_cdd );_ge ._cb =0x8000;_ge ._bd =0;_ge ._ebd =12;_ge ._ce =-1;_ge ._bf =0;_ge ._ga =0;_ge ._cf =make ([]byte ,_fbf );for _gab :=0;_gab < len (_ge ._ba );_gab ++{_ge ._ba [_gab ]=_b (512);};_ge ._ed =nil ;};func (_cc *Encoder )DataSize ()int {return _cc .dataSize ()};var _ad =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};func (_gaa *Encoder )codeLPS (_fbg *codingContext ,_bdg uint32 ,_bcg uint16 ,_cdg byte ){_gaa ._cb -=_bcg ;if _gaa ._cb < _bcg {_gaa ._bd +=uint32 (_bcg );}else {_gaa ._cb =_bcg ;};if _cbfd [_cdg ]._cef ==1{_fbg .flipMps (_bdg );};_fbg ._gf [_bdg ]=_cbfd [_cdg ]._baea ;_gaa .renormalize ();};func (_gff *Encoder )codeMPS (_ced *codingContext ,_gba uint32 ,_fcf uint16 ,_cde byte ){_gff ._cb -=_fcf ;if _gff ._cb &0x8000!=0{_gff ._bd +=uint32 (_fcf );return ;};if _gff ._cb < _fcf {_gff ._cb =_fcf ;}else {_gff ._bd +=uint32 (_fcf );};_ced ._gf [_gba ]=_cbfd [_cde ]._edfe ;_gff .renormalize ();};func (_de *Encoder )code1 (_gca *codingContext ,_fdf uint32 ,_baga uint16 ,_fe byte ){if _gca .mps (_fdf )==1{_de .codeMPS (_gca ,_fdf ,_baga ,_fe );}else {_de .codeLPS (_gca ,_fdf ,_baga ,_fe );};};func (_eec *Encoder )WriteTo (w _d .Writer )(int64 ,error ){const _fag ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";var _fdg int64 ;for _ab ,_cda :=range _eec ._df {_bb ,_baac :=w .Write (_cda );if _baac !=nil {return 0,_c .Wrapf (_baac ,_fag ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_ab );};_fdg +=int64 (_bb );};_eec ._cf =_eec ._cf [:_eec ._ga ];_ffa ,_dgf :=w .Write (_eec ._cf );if _dgf !=nil {return 0,_c .Wrap (_dgf ,_fag ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_fdg +=int64 (_ffa );return _fdg ,nil ;};func (_eeb *Encoder )EncodeBitmap (bm *_ag .Bitmap ,duplicateLineRemoval bool )error {_ee .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );var (_fc ,_db uint8 ;_gc ,_ega ,_cbc uint16 ;_ff ,_fd ,_cbf byte ;_ea ,_fff ,_ged int ;_cd ,_eeg []byte ;);for _ae :=0;_ae < bm .Height ;_ae ++{_ff ,_fd =0,0;if _ae >=2{_ff =bm .Data [(_ae -2)*bm .RowStride ];};if _ae >=1{_fd =bm .Data [(_ae -1)*bm .RowStride ];if duplicateLineRemoval {_fff =_ae *bm .RowStride ;_cd =bm .Data [_fff :_fff +bm .RowStride ];_ged =(_ae -1)*bm .RowStride ;_eeg =bm .Data [_ged :_ged +bm .RowStride ];if _e .Equal (_cd ,_eeg ){_db =_fc ^1;_fc =1;}else {_db =_fc ;_fc =0;};};};if duplicateLineRemoval {if _afd :=_eeb .encodeBit (_eeb ._da ,_af ,_db );_afd !=nil {return _afd ;};if _fc !=0{continue ;};};_cbf =bm .Data [_ae *bm .RowStride ];_gc =uint16 (_ff >>5);_ega =uint16 (_fd >>4);_ff <<=3;_fd <<=4;_cbc =0;for _ea =0;_ea < bm .Width ;_ea ++{_be :=uint32 (_gc <<11|_ega <<4|_cbc );_dcc :=(_cbf &0x80)>>7;_gcg :=_eeb .encodeBit (_eeb ._da ,_be ,_dcc );if _gcg !=nil {return _gcg ;};_gc <<=1;_ega <<=1;_cbc <<=1;_gc |=uint16 ((_ff &0x80)>>7);_ega |=uint16 ((_fd &0x80)>>7);_cbc |=uint16 (_dcc );_afc :=_ea %8;_ccd :=_ea /8+1;if _afc ==4&&_ae >=2{_ff =0;if _ccd < bm .RowStride {_ff =bm .Data [(_ae -2)*bm .RowStride +_ccd ];};}else {_ff <<=1;};if _afc ==3&&_ae >=1{_fd =0;if _ccd < bm .RowStride {_fd =bm .Data [(_ae -1)*bm .RowStride +_ccd ];};}else {_fd <<=1;};if _afc ==7{_cbf =0;if _ccd < bm .RowStride {_cbf =bm .Data [_ae *bm .RowStride +_ccd ];};}else {_cbf <<=1;};_gc &=31;_ega &=127;_cbc &=15;};};return nil ;};type Class int ;func (_eab *Encoder )emit (){if _eab ._ga ==_fbf {_eab ._df =append (_eab ._df ,_eab ._cf );_eab ._cf =make ([]byte ,_fbf );_eab ._ga =0;};_eab ._cf [_eab ._ga ]=_eab ._bf ;_eab ._ga ++;};func (_dc *codingContext )flipMps (_fb uint32 ){_dc ._ade [_fb ]=1-_dc ._ade [_fb ]};func (_fgde *Encoder )dataSize ()int {return _fbf *len (_fgde ._df )+_fgde ._ga };func (_fgc *Encoder )Final (){_fgc .flush ()};type Encoder struct{_bd uint32 ;_cb uint16 ;_ebd ,_bf uint8 ;_ce int ;_eg int ;_df [][]byte ;_cf []byte ;_ga int ;_da *codingContext ;_ba [13]*codingContext ;_ed *codingContext ;};func (_eegf *Encoder )Flush (){_eegf ._ga =0;_eegf ._df =nil ;_eegf ._ce =-1};type intEncRangeS struct{_ca ,_ec int ;_dg ,_eb uint8 ;_cab uint16 ;_g uint8 ;};func (_bea *Encoder )flush (){_bea .setBits ();_bea ._bd <<=_bea ._ebd ;_bea .byteOut ();_bea ._bd <<=_bea ._ebd ;_bea .byteOut ();_bea .emit ();if _bea ._bf !=0xff{_bea ._ce ++;_bea ._bf =0xff;_bea .emit ();};_bea ._ce ++;_bea ._bf =0xac;_bea ._ce ++;_bea .emit ();};var _ _d .WriterTo =&Encoder {};func (_f *codingContext )mps (_ecd uint32 )int {return int (_f ._ade [_ecd ])};func (_ef *Encoder )EncodeOOB (proc Class )(_ebe error ){_ee .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );if _ebe =_ef .encodeOOB (proc );_ebe !=nil {return _c .Wrap (_ebe ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};func (_egd *Encoder )Reset (){_egd ._cb =0x8000;_egd ._bd =0;_egd ._ebd =12;_egd ._ce =-1;_egd ._bf =0;_egd ._ed =nil ;_egd ._da =_b (_cdd );};var _cbfd =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};