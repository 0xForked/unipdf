//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_b "bytes";_g "github.com/unidoc/unipdf/v3/common";_a "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_ae "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_fd "io";);func (_ed *Encoder )codeMPS (_edb *codingContext ,_bca uint32 ,_ac uint16 ,_gde byte ){_ed ._ca -=_ac ;
if _ed ._ca &0x8000!=0{_ed ._cd +=uint32 (_ac );return ;};if _ed ._ca < _ac {_ed ._ca =_ac ;}else {_ed ._cd +=uint32 (_ac );};_edb ._ea [_bca ]=_feea [_gde ]._cbd ;_ed .renormalize ();};func (_bgc *Encoder )flush (){_bgc .setBits ();_bgc ._cd <<=_bgc ._ce ;
_bgc .byteOut ();_bgc ._cd <<=_bgc ._ce ;_bgc .byteOut ();_bgc .emit ();if _bgc ._be !=0xff{_bgc ._d ++;_bgc ._be =0xff;_bgc .emit ();};_bgc ._d ++;_bgc ._be =0xac;_bgc ._d ++;_bgc .emit ();};type Encoder struct{_cd uint32 ;_ca uint16 ;_ce ,_be uint8 ;
_d int ;_ee int ;_feb [][]byte ;_bg []byte ;_dd int ;_aa *codingContext ;_eg [13]*codingContext ;_bgd *codingContext ;};func (_cgb *Encoder )encodeInteger (_dcc Class ,_acg int )error {const _ffd ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";
if _acg > 2000000000||_acg < -2000000000{return _ae .Errorf (_ffd ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_acg );
};_ged :=_cgb ._eg [_dcc ];_add :=uint32 (1);var _fed int ;for ;;_fed ++{if _bb [_fed ]._c <=_acg &&_bb [_fed ]._e >=_acg {break ;};};if _acg < 0{_acg =-_acg ;};_acg -=int (_bb [_fed ]._cc );_fedg :=_bb [_fed ]._ff ;for _ddc :=uint8 (0);_ddc < _bb [_fed ]._cb ;
_ddc ++{_ecb :=_fedg &1;if _bcd :=_cgb .encodeBit (_ged ,_add ,_ecb );_bcd !=nil {return _ae .Wrap (_bcd ,_ffd ,"");};_fedg >>=1;if _add &0x100> 0{_add =(((_add <<1)|uint32 (_ecb ))&0x1ff)|0x100;}else {_add =(_add <<1)|uint32 (_ecb );};};_acg <<=32-_bb [_fed ]._cf ;
for _egd :=uint8 (0);_egd < _bb [_fed ]._cf ;_egd ++{_ebc :=uint8 ((uint32 (_acg )&0x80000000)>>31);if _geda :=_cgb .encodeBit (_ged ,_add ,_ebc );_geda !=nil {return _ae .Wrap (_geda ,_ffd ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");
};_acg <<=1;if _add &0x100!=0{_add =(((_add <<1)|uint32 (_ebc ))&0x1ff)|0x100;}else {_add =(_add <<1)|uint32 (_ebc );};};return nil ;};func (_fe Class )String ()string {switch _fe {case IAAI :return "\u0049\u0041\u0041\u0049";case IADH :return "\u0049\u0041\u0044\u0048";
case IADS :return "\u0049\u0041\u0044\u0053";case IADT :return "\u0049\u0041\u0044\u0054";case IADW :return "\u0049\u0041\u0044\u0057";case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";case IAIT :return "\u0049\u0041\u0049\u0054";
case IARDH :return "\u0049\u0041\u0052D\u0048";case IARDW :return "\u0049\u0041\u0052D\u0057";case IARDX :return "\u0049\u0041\u0052D\u0058";case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";
};};func (_ggg *Encoder )code0 (_def *codingContext ,_cegc uint32 ,_gf uint16 ,_bdg byte ){if _def .mps (_cegc )==0{_ggg .codeMPS (_def ,_cegc ,_gf ,_bdg );}else {_ggg .codeLPS (_def ,_cegc ,_gf ,_bdg );};};func (_ab *codingContext )flipMps (_gd uint32 ){_ab ._bbc [_gd ]=1-_ab ._bbc [_gd ]};
var _feea =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
func (_ceg *Encoder )DataSize ()int {return _ceg .dataSize ()};type state struct{_cgc uint16 ;_cbd ,_bbd uint8 ;_aee uint8 ;};type Class int ;func (_ecg *Encoder )rBlock (){if _ecg ._d >=0{_ecg .emit ();};_ecg ._d ++;_ecg ._be =uint8 (_ecg ._cd >>20);_ecg ._cd &=0xfffff;
_ecg ._ce =7;};func (_gaf *Encoder )Reset (){_gaf ._ca =0x8000;_gaf ._cd =0;_gaf ._ce =12;_gaf ._d =-1;_gaf ._be =0;_gaf ._bgd =nil ;_gaf ._aa =_ag (_agee );};type codingContext struct{_ea []byte ;_bbc []byte ;};type intEncRangeS struct{_c ,_e int ;_ff ,_cb uint8 ;
_cc uint16 ;_cf uint8 ;};func (_ccca *Encoder )WriteTo (w _fd .Writer )(int64 ,error ){const _ade ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";var _cfe int64 ;for _fab ,_fcb :=range _ccca ._feb {_ada ,_cad :=w .Write (_fcb );
if _cad !=nil {return 0,_ae .Wrapf (_cad ,_ade ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_fab );};_cfe +=int64 (_ada );};_ccca ._bg =_ccca ._bg [:_ccca ._dd ];
_gbb ,_dac :=w .Write (_ccca ._bg );if _dac !=nil {return 0,_ae .Wrap (_dac ,_ade ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_cfe +=int64 (_gbb );return _cfe ,nil ;};const _gb =0x9b25;const (IAAI Class =iota ;
IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);func (_ga *Encoder )Refine (iTemp ,iTarget *_a .Bitmap ,ox ,oy int )error {for _dg :=0;_dg < iTarget .Height ;_dg ++{var _afc int ;_fa :=_dg +oy ;var (_gc ,_eb ,_aff ,_ec ,_fbf uint16 ;
_fac ,_cbg ,_fga ,_gaa ,_geb byte ;);if _fa >=1&&(_fa -1)< iTemp .Height {_fac =iTemp .Data [(_fa -1)*iTemp .RowStride ];};if _fa >=0&&_fa < iTemp .Height {_cbg =iTemp .Data [_fa *iTemp .RowStride ];};if _fa >=-1&&_fa +1< iTemp .Height {_fga =iTemp .Data [(_fa +1)*iTemp .RowStride ];
};if _dg >=1{_gaa =iTarget .Data [(_dg -1)*iTarget .RowStride ];};_geb =iTarget .Data [_dg *iTarget .RowStride ];_db :=uint (6+ox );_gc =uint16 (_fac >>_db );_eb =uint16 (_cbg >>_db );_aff =uint16 (_fga >>_db );_ec =uint16 (_gaa >>6);_dea :=uint (2-ox );
_fac <<=_dea ;_cbg <<=_dea ;_fga <<=_dea ;_gaa <<=2;for _afc =0;_afc < iTarget .Width ;_afc ++{_ef :=(_gc <<10)|(_eb <<7)|(_aff <<4)|(_ec <<1)|_fbf ;_bec :=_geb >>7;_bba :=_ga .encodeBit (_ga ._aa ,uint32 (_ef ),_bec );if _bba !=nil {return _bba ;};_gc <<=1;
_eb <<=1;_aff <<=1;_ec <<=1;_gc |=uint16 (_fac >>7);_eb |=uint16 (_cbg >>7);_aff |=uint16 (_fga >>7);_ec |=uint16 (_gaa >>7);_fbf =uint16 (_bec );_affg :=_afc %8;_gba :=_afc /8+1;if _affg ==5+ox {_fac ,_cbg ,_fga =0,0,0;if _gba < iTemp .RowStride &&_fa >=1&&(_fa -1)< iTemp .Height {_fac =iTemp .Data [(_fa -1)*iTemp .RowStride +_gba ];
};if _gba < iTemp .RowStride &&_fa >=0&&_fa < iTemp .Height {_cbg =iTemp .Data [_fa *iTemp .RowStride +_gba ];};if _gba < iTemp .RowStride &&_fa >=-1&&(_fa +1)< iTemp .Height {_fga =iTemp .Data [(_fa +1)*iTemp .RowStride +_gba ];};}else {_fac <<=1;_cbg <<=1;
_fga <<=1;};if _affg ==5&&_dg >=1{_gaa =0;if _gba < iTarget .RowStride {_gaa =iTarget .Data [(_dg -1)*iTarget .RowStride +_gba ];};}else {_gaa <<=1;};if _affg ==7{_geb =0;if _gba < iTarget .RowStride {_geb =iTarget .Data [_dg *iTarget .RowStride +_gba ];
};}else {_geb <<=1;};_gc &=7;_eb &=7;_aff &=7;_ec &=7;};};return nil ;};func (_dagg *Encoder )lBlock (){if _dagg ._d >=0{_dagg .emit ();};_dagg ._d ++;_dagg ._be =uint8 (_dagg ._cd >>19);_dagg ._cd &=0x7ffff;_dagg ._ce =8;};func (_aed *Encoder )EncodeInteger (proc Class ,value int )(_fg error ){_g .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );
if _fg =_aed .encodeInteger (proc ,value );_fg !=nil {return _ae .Wrap (_fg ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};func (_cdf *Encoder )setBits (){_bfc :=_cdf ._cd +uint32 (_cdf ._ca );_cdf ._cd |=0xffff;
if _cdf ._cd >=_bfc {_cdf ._cd -=0x8000;};};func (_bd *Encoder )EncodeBitmap (bm *_a .Bitmap ,duplicateLineRemoval bool )error {_g .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );
var (_dab ,_af uint8 ;_de ,_bdd ,_fdg uint16 ;_fca ,_afb ,_ge byte ;_dag ,_gda ,_ccc int ;_cde ,_bc []byte ;);for _dc :=0;_dc < bm .Height ;_dc ++{_fca ,_afb =0,0;if _dc >=2{_fca =bm .Data [(_dc -2)*bm .RowStride ];};if _dc >=1{_afb =bm .Data [(_dc -1)*bm .RowStride ];
if duplicateLineRemoval {_gda =_dc *bm .RowStride ;_cde =bm .Data [_gda :_gda +bm .RowStride ];_ccc =(_dc -1)*bm .RowStride ;_bc =bm .Data [_ccc :_ccc +bm .RowStride ];if _b .Equal (_cde ,_bc ){_af =_dab ^1;_dab =1;}else {_af =_dab ;_dab =0;};};};if duplicateLineRemoval {if _ffa :=_bd .encodeBit (_bd ._aa ,_gb ,_af );
_ffa !=nil {return _ffa ;};if _dab !=0{continue ;};};_ge =bm .Data [_dc *bm .RowStride ];_de =uint16 (_fca >>5);_bdd =uint16 (_afb >>4);_fca <<=3;_afb <<=4;_fdg =0;for _dag =0;_dag < bm .Width ;_dag ++{_afe :=uint32 (_de <<11|_bdd <<4|_fdg );_daf :=(_ge &0x80)>>7;
_aef :=_bd .encodeBit (_bd ._aa ,_afe ,_daf );if _aef !=nil {return _aef ;};_de <<=1;_bdd <<=1;_fdg <<=1;_de |=uint16 ((_fca &0x80)>>7);_bdd |=uint16 ((_afb &0x80)>>7);_fdg |=uint16 (_daf );_fb :=_dag %8;_cg :=_dag /8+1;if _fb ==4&&_dc >=2{_fca =0;if _cg < bm .RowStride {_fca =bm .Data [(_dc -2)*bm .RowStride +_cg ];
};}else {_fca <<=1;};if _fb ==3&&_dc >=1{_afb =0;if _cg < bm .RowStride {_afb =bm .Data [(_dc -1)*bm .RowStride +_cg ];};}else {_afb <<=1;};if _fb ==7{_ge =0;if _cg < bm .RowStride {_ge =bm .Data [_dc *bm .RowStride +_cg ];};}else {_ge <<=1;};_de &=31;
_bdd &=127;_fdg &=15;};};return nil ;};func New ()*Encoder {_fde :=&Encoder {};_fde .Init ();return _fde };func (_fff *codingContext )mps (_fc uint32 )int {return int (_fff ._bbc [_fc ])};var _ _fd .WriterTo =&Encoder {};func (_fbb *Encoder )code1 (_bf *codingContext ,_dgf uint32 ,_ebg uint16 ,_fcbe byte ){if _bf .mps (_dgf )==1{_fbb .codeMPS (_bf ,_dgf ,_ebg ,_fcbe );
}else {_fbb .codeLPS (_bf ,_dgf ,_ebg ,_fcbe );};};func (_fgd *Encoder )codeLPS (_eeb *codingContext ,_bdb uint32 ,_aad uint16 ,_ba byte ){_fgd ._ca -=_aad ;if _fgd ._ca < _aad {_fgd ._cd +=uint32 (_aad );}else {_fgd ._ca =_aad ;};if _feea [_ba ]._aee ==1{_eeb .flipMps (_bdb );
};_eeb ._ea [_bdb ]=_feea [_ba ]._bbd ;_fgd .renormalize ();};func (_bgf *Encoder )renormalize (){for {_bgf ._ca <<=1;_bgf ._cd <<=1;_bgf ._ce --;if _bgf ._ce ==0{_bgf .byteOut ();};if (_bgf ._ca &0x8000)!=0{break ;};};};func (_ad *Encoder )Flush (){_ad ._dd =0;
_ad ._feb =nil ;_ad ._d =-1};func (_bef *Encoder )EncodeIAID (symbolCodeLength ,value int )(_bcg error ){_g .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );
if _bcg =_bef .encodeIAID (symbolCodeLength ,value );_bcg !=nil {return _ae .Wrap (_bcg ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};func _ag (_cba int )*codingContext {return &codingContext {_ea :make ([]byte ,_cba ),_bbc :make ([]byte ,_cba )};
};func (_da *Encoder )Init (){_da ._aa =_ag (_agee );_da ._ca =0x8000;_da ._cd =0;_da ._ce =12;_da ._d =-1;_da ._be =0;_da ._dd =0;_da ._bg =make ([]byte ,_fdea );for _cdd :=0;_cdd < len (_da ._eg );_cdd ++{_da ._eg [_cdd ]=_ag (512);};_da ._bgd =nil ;
};func (_afbb *Encoder )encodeOOB (_dcdc Class )error {_dfe :=_afbb ._eg [_dcdc ];_cee :=_afbb .encodeBit (_dfe ,1,1);if _cee !=nil {return _cee ;};_cee =_afbb .encodeBit (_dfe ,3,0);if _cee !=nil {return _cee ;};_cee =_afbb .encodeBit (_dfe ,6,0);if _cee !=nil {return _cee ;
};_cee =_afbb .encodeBit (_dfe ,12,0);if _cee !=nil {return _cee ;};return nil ;};func (_eebc *Encoder )dataSize ()int {return _fdea *len (_eebc ._feb )+_eebc ._dd };func (_age *Encoder )EncodeOOB (proc Class )(_fba error ){_g .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );
if _fba =_age .encodeOOB (proc );_fba !=nil {return _ae .Wrap (_fba ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};func (_bge *Encoder )encodeBit (_dcd *codingContext ,_fee uint32 ,_ead uint8 )error {const _efc ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";
_bge ._ee ++;if _fee >=uint32 (len (_dcd ._ea )){return _ae .Errorf (_efc ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_fee );
};_efe :=_dcd ._ea [_fee ];_efa :=_dcd .mps (_fee );_gea :=_feea [_efe ]._cgc ;_g .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_bge ._ee ,_ead ,_efe ,_efa ,_gea ,_bge ._ca ,_bge ._cd ,_bge ._ce ,_bge ._be ,_bge ._d );
if _ead ==0{_bge .code0 (_dcd ,_fee ,_gea ,_efe );}else {_bge .code1 (_dcd ,_fee ,_gea ,_efe );};return nil ;};func (_gg *Encoder )byteOut (){if _gg ._be ==0xff{_gg .rBlock ();return ;};if _gg ._cd < 0x8000000{_gg .lBlock ();return ;};_gg ._be ++;if _gg ._be !=0xff{_gg .lBlock ();
return ;};_gg ._cd &=0x7ffffff;_gg .rBlock ();};func (_df *Encoder )encodeIAID (_eab ,_agf int )error {if _df ._bgd ==nil {_df ._bgd =_ag (1<<uint (_eab ));};_eda :=uint32 (1<<uint32 (_eab +1))-1;_agf <<=uint (32-_eab );_ggge :=uint32 (1);for _ebd :=0;
_ebd < _eab ;_ebd ++{_fbbb :=_ggge &_eda ;_gef :=uint8 ((uint32 (_agf )&0x80000000)>>31);if _gcb :=_df .encodeBit (_df ._bgd ,_fbbb ,_gef );_gcb !=nil {return _gcb ;};_ggge =(_ggge <<1)|uint32 (_gef );_agf <<=1;};return nil ;};const (_agee =65536;_fdea =20*1024;
);func (_agc *Encoder )emit (){if _agc ._dd ==_fdea {_agc ._feb =append (_agc ._feb ,_agc ._bg );_agc ._bg =make ([]byte ,_fdea );_agc ._dd =0;};_agc ._bg [_agc ._dd ]=_agc ._be ;_agc ._dd ++;};func (_aea *Encoder )Final (){_aea .flush ()};var _bb =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};
