//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_fb "bytes";_a "github.com/unidoc/unipdf/v3/common";_b "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_fe "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_d "io";);func (_gee *Encoder )EncodeInteger (proc Class ,value int )(_ecg error ){_a .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );
if _ecg =_gee .encodeInteger (proc ,value );_ecg !=nil {return _fe .Wrap (_ecg ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};type Class int ;func (_ad *Encoder )flush (){_ad .setBits ();_ad ._cg <<=_ad ._ec ;
_ad .byteOut ();_ad ._cg <<=_ad ._ec ;_ad .byteOut ();_ad .emit ();if _ad ._fa !=0xff{_ad ._fg ++;_ad ._fa =0xff;_ad .emit ();};_ad ._fg ++;_ad ._fa =0xac;_ad ._fg ++;_ad .emit ();};type intEncRangeS struct{_da ,_bc int ;_g ,_ea uint8 ;_c uint16 ;_ga uint8 ;
};type Encoder struct{_cg uint32 ;_bcf uint16 ;_ec ,_fa uint8 ;_fg int ;_ead int ;_ce [][]byte ;_bb []byte ;_cf int ;_df *codingContext ;_bg [13]*codingContext ;_ed *codingContext ;};func (_gf *codingContext )mps (_cc uint32 )int {return int (_gf ._ff [_cc ])};
func New ()*Encoder {_gad :=&Encoder {};_gad .Init ();return _gad };func (_eaa *Encoder )Init (){_eaa ._df =_dg (_eabb );_eaa ._bcf =0x8000;_eaa ._cg =0;_eaa ._ec =12;_eaa ._fg =-1;_eaa ._fa =0;_eaa ._cf =0;_eaa ._bb =make ([]byte ,_dcd );for _gbe :=0;
_gbe < len (_eaa ._bg );_gbe ++{_eaa ._bg [_gbe ]=_dg (512);};_eaa ._ed =nil ;};func (_ccg *Encoder )code0 (_eabd *codingContext ,_gcc uint32 ,_fgd uint16 ,_cfe byte ){if _eabd .mps (_gcc )==0{_ccg .codeMPS (_eabd ,_gcc ,_fgd ,_cfe );}else {_ccg .codeLPS (_eabd ,_gcc ,_fgd ,_cfe );
};};var _eg =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};
func (_fege *Encoder )encodeOOB (_fgbd Class )error {_gef :=_fege ._bg [_fgbd ];_ffe :=_fege .encodeBit (_gef ,1,1);if _ffe !=nil {return _ffe ;};_ffe =_fege .encodeBit (_gef ,3,0);if _ffe !=nil {return _ffe ;};_ffe =_fege .encodeBit (_gef ,6,0);if _ffe !=nil {return _ffe ;
};_ffe =_fege .encodeBit (_gef ,12,0);if _ffe !=nil {return _ffe ;};return nil ;};func (_eccc *Encoder )encodeInteger (_gadb Class ,_aba int )error {const _edd ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";
if _aba > 2000000000||_aba < -2000000000{return _fe .Errorf (_edd ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_aba );
};_ddaf :=_eccc ._bg [_gadb ];_fbfd :=uint32 (1);var _eee int ;for ;;_eee ++{if _eg [_eee ]._da <=_aba &&_eg [_eee ]._bc >=_aba {break ;};};if _aba < 0{_aba =-_aba ;};_aba -=int (_eg [_eee ]._c );_bgc :=_eg [_eee ]._g ;for _ae :=uint8 (0);_ae < _eg [_eee ]._ea ;
_ae ++{_egd :=_bgc &1;if _dfg :=_eccc .encodeBit (_ddaf ,_fbfd ,_egd );_dfg !=nil {return _fe .Wrap (_dfg ,_edd ,"");};_bgc >>=1;if _fbfd &0x100> 0{_fbfd =(((_fbfd <<1)|uint32 (_egd ))&0x1ff)|0x100;}else {_fbfd =(_fbfd <<1)|uint32 (_egd );};};_aba <<=32-_eg [_eee ]._ga ;
for _dgc :=uint8 (0);_dgc < _eg [_eee ]._ga ;_dgc ++{_bcg :=uint8 ((uint32 (_aba )&0x80000000)>>31);if _ca :=_eccc .encodeBit (_ddaf ,_fbfd ,_bcg );_ca !=nil {return _fe .Wrap (_ca ,_edd ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");
};_aba <<=1;if _fbfd &0x100!=0{_fbfd =(((_fbfd <<1)|uint32 (_bcg ))&0x1ff)|0x100;}else {_fbfd =(_fbfd <<1)|uint32 (_bcg );};};return nil ;};const (_eabb =65536;_dcd =20*1024;);func (_gfg *Encoder )Flush (){_gfg ._cf =0;_gfg ._ce =nil ;_gfg ._fg =-1};func (_cdd *Encoder )Final (){_cdd .flush ()};
func (_cb *Encoder )encodeBit (_gge *codingContext ,_be uint32 ,_bdfe uint8 )error {const _ded ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";_cb ._ead ++;if _be >=uint32 (len (_gge ._ge )){return _fe .Errorf (_ded ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_be );
};_egg :=_gge ._ge [_be ];_dfa :=_gge .mps (_be );_eda :=_gbbb [_egg ]._aaf ;_a .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_cb ._ead ,_bdfe ,_egg ,_dfa ,_eda ,_cb ._bcf ,_cb ._cg ,_cb ._ec ,_cb ._fa ,_cb ._fg );
if _bdfe ==0{_cb .code0 (_gge ,_be ,_eda ,_egg );}else {_cb .code1 (_gge ,_be ,_eda ,_egg );};return nil ;};func (_efa *Encoder )WriteTo (w _d .Writer )(int64 ,error ){const _cee ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";
var _bcc int64 ;for _gfa ,_af :=range _efa ._ce {_edc ,_dda :=w .Write (_af );if _dda !=nil {return 0,_fe .Wrapf (_dda ,_cee ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_gfa );
};_bcc +=int64 (_edc );};_efa ._bb =_efa ._bb [:_efa ._cf ];_dgb ,_dfd :=w .Write (_efa ._bb );if _dfd !=nil {return 0,_fe .Wrap (_dfd ,_cee ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_bcc +=int64 (_dgb );return _bcc ,nil ;
};func (_cec *Encoder )Refine (iTemp ,iTarget *_b .Bitmap ,ox ,oy int )error {for _ee :=0;_ee < iTarget .Height ;_ee ++{var _dc int ;_fad :=_ee +oy ;var (_eea ,_edf ,_aa ,_dgg ,_cge uint16 ;_ab ,_gaa ,_db ,_ecc ,_cgee byte ;);if _fad >=1&&(_fad -1)< iTemp .Height {_ab =iTemp .Data [(_fad -1)*iTemp .RowStride ];
};if _fad >=0&&_fad < iTemp .Height {_gaa =iTemp .Data [_fad *iTemp .RowStride ];};if _fad >=-1&&_fad +1< iTemp .Height {_db =iTemp .Data [(_fad +1)*iTemp .RowStride ];};if _ee >=1{_ecc =iTarget .Data [(_ee -1)*iTarget .RowStride ];};_cgee =iTarget .Data [_ee *iTarget .RowStride ];
_gae :=uint (6+ox );_eea =uint16 (_ab >>_gae );_edf =uint16 (_gaa >>_gae );_aa =uint16 (_db >>_gae );_dgg =uint16 (_ecc >>6);_feg :=uint (2-ox );_ab <<=_feg ;_gaa <<=_feg ;_db <<=_feg ;_ecc <<=2;for _dc =0;_dc < iTarget .Width ;_dc ++{_de :=(_eea <<10)|(_edf <<7)|(_aa <<4)|(_dgg <<1)|_cge ;
_dd :=_cgee >>7;_bgd :=_cec .encodeBit (_cec ._df ,uint32 (_de ),_dd );if _bgd !=nil {return _bgd ;};_eea <<=1;_edf <<=1;_aa <<=1;_dgg <<=1;_eea |=uint16 (_ab >>7);_edf |=uint16 (_gaa >>7);_aa |=uint16 (_db >>7);_dgg |=uint16 (_ecc >>7);_cge =uint16 (_dd );
_fbad :=_dc %8;_fga :=_dc /8+1;if _fbad ==5+ox {_ab ,_gaa ,_db =0,0,0;if _fga < iTemp .RowStride &&_fad >=1&&(_fad -1)< iTemp .Height {_ab =iTemp .Data [(_fad -1)*iTemp .RowStride +_fga ];};if _fga < iTemp .RowStride &&_fad >=0&&_fad < iTemp .Height {_gaa =iTemp .Data [_fad *iTemp .RowStride +_fga ];
};if _fga < iTemp .RowStride &&_fad >=-1&&(_fad +1)< iTemp .Height {_db =iTemp .Data [(_fad +1)*iTemp .RowStride +_fga ];};}else {_ab <<=1;_gaa <<=1;_db <<=1;};if _fbad ==5&&_ee >=1{_ecc =0;if _fga < iTarget .RowStride {_ecc =iTarget .Data [(_ee -1)*iTarget .RowStride +_fga ];
};}else {_ecc <<=1;};if _fbad ==7{_cgee =0;if _fga < iTarget .RowStride {_cgee =iTarget .Data [_ee *iTarget .RowStride +_fga ];};}else {_cgee <<=1;};_eea &=7;_edf &=7;_aa &=7;_dgg &=7;};};return nil ;};func (_fea *Encoder )EncodeBitmap (bm *_b .Bitmap ,duplicateLineRemoval bool )error {_a .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );
var (_edb ,_cfd uint8 ;_cea ,_gag ,_fbf uint16 ;_eac ,_dgd ,_cgf byte ;_cd ,_eab ,_gbf int ;_cfc ,_fef []byte ;);for _cgd :=0;_cgd < bm .Height ;_cgd ++{_eac ,_dgd =0,0;if _cgd >=2{_eac =bm .Data [(_cgd -2)*bm .RowStride ];};if _cgd >=1{_dgd =bm .Data [(_cgd -1)*bm .RowStride ];
if duplicateLineRemoval {_eab =_cgd *bm .RowStride ;_cfc =bm .Data [_eab :_eab +bm .RowStride ];_gbf =(_cgd -1)*bm .RowStride ;_fef =bm .Data [_gbf :_gbf +bm .RowStride ];if _fb .Equal (_cfc ,_fef ){_cfd =_edb ^1;_edb =1;}else {_cfd =_edb ;_edb =0;};};
};if duplicateLineRemoval {if _gc :=_fea .encodeBit (_fea ._df ,_gbb ,_cfd );_gc !=nil {return _gc ;};if _edb !=0{continue ;};};_cgf =bm .Data [_cgd *bm .RowStride ];_cea =uint16 (_eac >>5);_gag =uint16 (_dgd >>4);_eac <<=3;_dgd <<=4;_fbf =0;for _cd =0;
_cd < bm .Width ;_cd ++{_egc :=uint32 (_cea <<11|_gag <<4|_fbf );_fca :=(_cgf &0x80)>>7;_eabg :=_fea .encodeBit (_fea ._df ,_egc ,_fca );if _eabg !=nil {return _eabg ;};_cea <<=1;_gag <<=1;_fbf <<=1;_cea |=uint16 ((_eac &0x80)>>7);_gag |=uint16 ((_dgd &0x80)>>7);
_fbf |=uint16 (_fca );_bd :=_cd %8;_cde :=_cd /8+1;if _bd ==4&&_cgd >=2{_eac =0;if _cde < bm .RowStride {_eac =bm .Data [(_cgd -2)*bm .RowStride +_cde ];};}else {_eac <<=1;};if _bd ==3&&_cgd >=1{_dgd =0;if _cde < bm .RowStride {_dgd =bm .Data [(_cgd -1)*bm .RowStride +_cde ];
};}else {_dgd <<=1;};if _bd ==7{_cgf =0;if _cde < bm .RowStride {_cgf =bm .Data [_cgd *bm .RowStride +_cde ];};}else {_cgf <<=1;};_cea &=31;_gag &=127;_fbf &=15;};};return nil ;};func (_ef *Encoder )DataSize ()int {return _ef .dataSize ()};func (_bf *Encoder )codeLPS (_bad *codingContext ,_ede uint32 ,_def uint16 ,_ega byte ){_bf ._bcf -=_def ;
if _bf ._bcf < _def {_bf ._cg +=uint32 (_def );}else {_bf ._bcf =_def ;};if _gbbb [_ega ]._abc ==1{_bad .flipMps (_ede );};_bad ._ge [_ede ]=_gbbb [_ega ]._fecc ;_bf .renormalize ();};func (_ac *Encoder )byteOut (){if _ac ._fa ==0xff{_ac .rBlock ();return ;
};if _ac ._cg < 0x8000000{_ac .lBlock ();return ;};_ac ._fa ++;if _ac ._fa !=0xff{_ac .lBlock ();return ;};_ac ._cg &=0x7ffffff;_ac .rBlock ();};func (_gebc *Encoder )renormalize (){for {_gebc ._bcf <<=1;_gebc ._cg <<=1;_gebc ._ec --;if _gebc ._ec ==0{_gebc .byteOut ();
};if (_gebc ._bcf &0x8000)!=0{break ;};};};const _gbb =0x9b25;func (_e Class )String ()string {switch _e {case IAAI :return "\u0049\u0041\u0041\u0049";case IADH :return "\u0049\u0041\u0044\u0048";case IADS :return "\u0049\u0041\u0044\u0053";case IADT :return "\u0049\u0041\u0044\u0054";
case IADW :return "\u0049\u0041\u0044\u0057";case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";case IAIT :return "\u0049\u0041\u0049\u0054";case IARDH :return "\u0049\u0041\u0052D\u0048";case IARDW :return "\u0049\u0041\u0052D\u0057";
case IARDX :return "\u0049\u0041\u0052D\u0058";case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";};};func (_bee *Encoder )setBits (){_aag :=_bee ._cg +uint32 (_bee ._bcf );
_bee ._cg |=0xffff;if _bee ._cg >=_aag {_bee ._cg -=0x8000;};};func (_gb *codingContext )flipMps (_fc uint32 ){_gb ._ff [_fc ]=1-_gb ._ff [_fc ]};func (_bdc *Encoder )encodeIAID (_fgb ,_gaf int )error {if _bdc ._ed ==nil {_bdc ._ed =_dg (1<<uint (_fgb ));
};_eff :=uint32 (1<<uint32 (_fgb +1))-1;_gaf <<=uint (32-_fgb );_gagb :=uint32 (1);for _gd :=0;_gd < _fgb ;_gd ++{_fab :=_gagb &_eff ;_efe :=uint8 ((uint32 (_gaf )&0x80000000)>>31);if _cbg :=_bdc .encodeBit (_bdc ._ed ,_fab ,_efe );_cbg !=nil {return _cbg ;
};_gagb =(_gagb <<1)|uint32 (_efe );_gaf <<=1;};return nil ;};func (_bdf *Encoder )code1 (_age *codingContext ,_geb uint32 ,_fcg uint16 ,_eag byte ){if _age .mps (_geb )==1{_bdf .codeMPS (_age ,_geb ,_fcg ,_eag );}else {_bdf .codeLPS (_age ,_geb ,_fcg ,_eag );
};};func (_gdf *Encoder )rBlock (){if _gdf ._fg >=0{_gdf .emit ();};_gdf ._fg ++;_gdf ._fa =uint8 (_gdf ._cg >>20);_gdf ._cg &=0xfffff;_gdf ._ec =7;};func (_ffb *Encoder )emit (){if _ffb ._cf ==_dcd {_ffb ._ce =append (_ffb ._ce ,_ffb ._bb );_ffb ._bb =make ([]byte ,_dcd );
_ffb ._cf =0;};_ffb ._bb [_ffb ._cf ]=_ffb ._fa ;_ffb ._cf ++;};var _ _d .WriterTo =&Encoder {};type state struct{_aaf uint16 ;_bcgc ,_fecc uint8 ;_abc uint8 ;};const (IAAI Class =iota ;IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;
IARI ;);func (_caf *Encoder )lBlock (){if _caf ._fg >=0{_caf .emit ();};_caf ._fg ++;_caf ._fa =uint8 (_caf ._cg >>19);_caf ._cg &=0x7ffff;_caf ._ec =8;};func (_bdd *Encoder )dataSize ()int {return _dcd *len (_bdd ._ce )+_bdd ._cf };func _dg (_dge int )*codingContext {return &codingContext {_ge :make ([]byte ,_dge ),_ff :make ([]byte ,_dge )};
};type codingContext struct{_ge []byte ;_ff []byte ;};func (_gcb *Encoder )Reset (){_gcb ._bcf =0x8000;_gcb ._cg =0;_gcb ._ec =12;_gcb ._fg =-1;_gcb ._fa =0;_gcb ._ed =nil ;_gcb ._df =_dg (_eabb );};func (_ag *Encoder )EncodeOOB (proc Class )(_fbff error ){_a .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );
if _fbff =_ag .encodeOOB (proc );_fbff !=nil {return _fe .Wrap (_fbff ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};func (_ba *Encoder )EncodeIAID (symbolCodeLength ,value int )(_fba error ){_a .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );
if _fba =_ba .encodeIAID (symbolCodeLength ,value );_fba !=nil {return _fe .Wrap (_fba ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};func (_gbd *Encoder )codeMPS (_fec *codingContext ,_deb uint32 ,_cfdg uint16 ,_gfc byte ){_gbd ._bcf -=_cfdg ;
if _gbd ._bcf &0x8000!=0{_gbd ._cg +=uint32 (_cfdg );return ;};if _gbd ._bcf < _cfdg {_gbd ._bcf =_cfdg ;}else {_gbd ._cg +=uint32 (_cfdg );};_fec ._ge [_deb ]=_gbbb [_gfc ]._bcgc ;_gbd .renormalize ();};var _gbbb =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
