//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_b "bytes";_ea "github.com/unidoc/unipdf/v3/common";_gb "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_gc "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_e "io";);func (_gbb *Encoder )EncodeOOB (proc Class )(_bga error ){_ea .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );
if _bga =_gbb .encodeOOB (proc );_bga !=nil {return _gc .Wrap (_bga ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};func (_d Class )String ()string {switch _d {case IAAI :return "\u0049\u0041\u0041\u0049";case IADH :return "\u0049\u0041\u0044\u0048";
case IADS :return "\u0049\u0041\u0044\u0053";case IADT :return "\u0049\u0041\u0044\u0054";case IADW :return "\u0049\u0041\u0044\u0057";case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";case IAIT :return "\u0049\u0041\u0049\u0054";
case IARDH :return "\u0049\u0041\u0052D\u0048";case IARDW :return "\u0049\u0041\u0052D\u0057";case IARDX :return "\u0049\u0041\u0052D\u0058";case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";
};};func (_dce *Encoder )Final (){_dce .flush ()};func _gf (_ad int )*codingContext {return &codingContext {_dfd :make ([]byte ,_ad ),_bf :make ([]byte ,_ad )};};func (_bdc *Encoder )lBlock (){if _bdc ._gd >=0{_bdc .emit ();};_bdc ._gd ++;_bdc ._fdec =uint8 (_bdc ._ba >>19);
_bdc ._ba &=0x7ffff;_bdc ._dd =8;};type state struct{_fg uint16 ;_cbed ,_cddd uint8 ;_ccg uint8 ;};func (_bdd *Encoder )rBlock (){if _bdd ._gd >=0{_bdd .emit ();};_bdd ._gd ++;_bdd ._fdec =uint8 (_bdd ._ba >>20);_bdd ._ba &=0xfffff;_bdd ._dd =7;};func (_afad *Encoder )Refine (iTemp ,iTarget *_gb .Bitmap ,ox ,oy int )error {for _eff :=0;
_eff < iTarget .Height ;_eff ++{var _eb int ;_cfd :=_eff +oy ;var (_adb ,_gdcb ,_gcc ,_gdb ,_ecf uint16 ;_gfe ,_aee ,_ge ,_bff ,_fcc byte ;);if _cfd >=1&&(_cfd -1)< iTemp .Height {_gfe =iTemp .Data [(_cfd -1)*iTemp .RowStride ];};if _cfd >=0&&_cfd < iTemp .Height {_aee =iTemp .Data [_cfd *iTemp .RowStride ];
};if _cfd >=-1&&_cfd +1< iTemp .Height {_ge =iTemp .Data [(_cfd +1)*iTemp .RowStride ];};if _eff >=1{_bff =iTarget .Data [(_eff -1)*iTarget .RowStride ];};_fcc =iTarget .Data [_eff *iTarget .RowStride ];_cbg :=uint (6+ox );_adb =uint16 (_gfe >>_cbg );_gdcb =uint16 (_aee >>_cbg );
_gcc =uint16 (_ge >>_cbg );_gdb =uint16 (_bff >>6);_dced :=uint (2-ox );_gfe <<=_dced ;_aee <<=_dced ;_ge <<=_dced ;_bff <<=2;for _eb =0;_eb < iTarget .Width ;_eb ++{_dg :=(_adb <<10)|(_gdcb <<7)|(_gcc <<4)|(_gdb <<1)|_ecf ;_ac :=_fcc >>7;_gfea :=_afad .encodeBit (_afad ._da ,uint32 (_dg ),_ac );
if _gfea !=nil {return _gfea ;};_adb <<=1;_gdcb <<=1;_gcc <<=1;_gdb <<=1;_adb |=uint16 (_gfe >>7);_gdcb |=uint16 (_aee >>7);_gcc |=uint16 (_ge >>7);_gdb |=uint16 (_bff >>7);_ecf =uint16 (_ac );_bae :=_eb %8;_ebe :=_eb /8+1;if _bae ==5+ox {_gfe ,_aee ,_ge =0,0,0;
if _ebe < iTemp .RowStride &&_cfd >=1&&(_cfd -1)< iTemp .Height {_gfe =iTemp .Data [(_cfd -1)*iTemp .RowStride +_ebe ];};if _ebe < iTemp .RowStride &&_cfd >=0&&_cfd < iTemp .Height {_aee =iTemp .Data [_cfd *iTemp .RowStride +_ebe ];};if _ebe < iTemp .RowStride &&_cfd >=-1&&(_cfd +1)< iTemp .Height {_ge =iTemp .Data [(_cfd +1)*iTemp .RowStride +_ebe ];
};}else {_gfe <<=1;_aee <<=1;_ge <<=1;};if _bae ==5&&_eff >=1{_bff =0;if _ebe < iTarget .RowStride {_bff =iTarget .Data [(_eff -1)*iTarget .RowStride +_ebe ];};}else {_bff <<=1;};if _bae ==7{_fcc =0;if _ebe < iTarget .RowStride {_fcc =iTarget .Data [_eff *iTarget .RowStride +_ebe ];
};}else {_fcc <<=1;};_adb &=7;_gdcb &=7;_gcc &=7;_gdb &=7;};};return nil ;};type Encoder struct{_ba uint32 ;_fde uint16 ;_dd ,_fdec uint8 ;_gd int ;_gfg int ;_fe [][]byte ;_fb []byte ;_ca int ;_da *codingContext ;_add [13]*codingContext ;_gdf *codingContext ;
};func (_dcc *Encoder )dataSize ()int {return _aef *len (_dcc ._fe )+_dcc ._ca };var _fd =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};
func (_bac *Encoder )setBits (){_dceg :=_bac ._ba +uint32 (_bac ._fde );_bac ._ba |=0xffff;if _bac ._ba >=_dceg {_bac ._ba -=0x8000;};};func (_fc *Encoder )Flush (){_fc ._ca =0;_fc ._fe =nil ;_fc ._gd =-1};func (_deg *Encoder )emit (){if _deg ._ca ==_aef {_deg ._fe =append (_deg ._fe ,_deg ._fb );
_deg ._fb =make ([]byte ,_aef );_deg ._ca =0;};_deg ._fb [_deg ._ca ]=_deg ._fdec ;_deg ._ca ++;};func (_bca *Encoder )encodeIAID (_gee ,_ggad int )error {if _bca ._gdf ==nil {_bca ._gdf =_gf (1<<uint (_gee ));};_bgd :=uint32 (1<<uint32 (_gee +1))-1;_ggad <<=uint (32-_gee );
_fcg :=uint32 (1);for _abba :=0;_abba < _gee ;_abba ++{_cddc :=_fcg &_bgd ;_dca :=uint8 ((uint32 (_ggad )&0x80000000)>>31);if _aad :=_bca .encodeBit (_bca ._gdf ,_cddc ,_dca );_aad !=nil {return _aad ;};_fcg =(_fcg <<1)|uint32 (_dca );_ggad <<=1;};return nil ;
};var _cg =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
func (_gcd *codingContext )mps (_aa uint32 )int {return int (_gcd ._bf [_aa ])};func (_dda *Encoder )encodeBit (_dag *codingContext ,_eea uint32 ,_dba uint8 )error {const _gfead ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";
_dda ._gfg ++;if _eea >=uint32 (len (_dag ._dfd )){return _gc .Errorf (_gfead ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_eea );
};_aag :=_dag ._dfd [_eea ];_acfd :=_dag .mps (_eea );_bdf :=_cg [_aag ]._fg ;_ea .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_dda ._gfg ,_dba ,_aag ,_acfd ,_bdf ,_dda ._fde ,_dda ._ba ,_dda ._dd ,_dda ._fdec ,_dda ._gd );
if _dba ==0{_dda .code0 (_dag ,_eea ,_bdf ,_aag );}else {_dda .code1 (_dag ,_eea ,_bdf ,_aag );};return nil ;};func New ()*Encoder {_cd :=&Encoder {};_cd .Init ();return _cd };func (_abb *Encoder )code1 (_ccf *codingContext ,_ada uint32 ,_eccc uint16 ,_ggd byte ){if _ccf .mps (_ada )==1{_abb .codeMPS (_ccf ,_ada ,_eccc ,_ggd );
}else {_abb .codeLPS (_ccf ,_ada ,_eccc ,_ggd );};};func (_cdd *Encoder )codeMPS (_dcec *codingContext ,_ffg uint32 ,_gcf uint16 ,_bd byte ){_cdd ._fde -=_gcf ;if _cdd ._fde &0x8000!=0{_cdd ._ba +=uint32 (_gcf );return ;};if _cdd ._fde < _gcf {_cdd ._fde =_gcf ;
}else {_cdd ._ba +=uint32 (_gcf );};_dcec ._dfd [_ffg ]=_cg [_bd ]._cbed ;_cdd .renormalize ();};const _adg =0x9b25;func (_aac *Encoder )byteOut (){if _aac ._fdec ==0xff{_aac .rBlock ();return ;};if _aac ._ba < 0x8000000{_aac .lBlock ();return ;};_aac ._fdec ++;
if _aac ._fdec !=0xff{_aac .lBlock ();return ;};_aac ._ba &=0x7ffffff;_aac .rBlock ();};type intEncRangeS struct{_df ,_bc int ;_a ,_f uint8 ;_c uint16 ;_bb uint8 ;};func (_fa *Encoder )encodeOOB (_cff Class )error {_beg :=_fa ._add [_cff ];_ebb :=_fa .encodeBit (_beg ,1,1);
if _ebb !=nil {return _ebb ;};_ebb =_fa .encodeBit (_beg ,3,0);if _ebb !=nil {return _ebb ;};_ebb =_fa .encodeBit (_beg ,6,0);if _ebb !=nil {return _ebb ;};_ebb =_fa .encodeBit (_beg ,12,0);if _ebb !=nil {return _ebb ;};return nil ;};var _ _e .WriterTo =&Encoder {};
func (_eg *Encoder )codeLPS (_ggb *codingContext ,_gae uint32 ,_feg uint16 ,_fdd byte ){_eg ._fde -=_feg ;if _eg ._fde < _feg {_eg ._ba +=uint32 (_feg );}else {_eg ._fde =_feg ;};if _cg [_fdd ]._ccg ==1{_ggb .flipMps (_gae );};_ggb ._dfd [_gae ]=_cg [_fdd ]._cddd ;
_eg .renormalize ();};type Class int ;type codingContext struct{_dfd []byte ;_bf []byte ;};func (_gaa *Encoder )renormalize (){for {_gaa ._fde <<=1;_gaa ._ba <<=1;_gaa ._dd --;if _gaa ._dd ==0{_gaa .byteOut ();};if (_gaa ._fde &0x8000)!=0{break ;};};};
func (_bbg *Encoder )EncodeBitmap (bm *_gb .Bitmap ,duplicateLineRemoval bool )error {_ea .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );
var (_ec ,_cb uint8 ;_db ,_de ,_ef uint16 ;_adc ,_gdd ,_cc byte ;_ecc ,_bg ,_gg int ;_afa ,_cfb []byte ;);for _ab :=0;_ab < bm .Height ;_ab ++{_adc ,_gdd =0,0;if _ab >=2{_adc =bm .Data [(_ab -2)*bm .RowStride ];};if _ab >=1{_gdd =bm .Data [(_ab -1)*bm .RowStride ];
if duplicateLineRemoval {_bg =_ab *bm .RowStride ;_afa =bm .Data [_bg :_bg +bm .RowStride ];_gg =(_ab -1)*bm .RowStride ;_cfb =bm .Data [_gg :_gg +bm .RowStride ];if _b .Equal (_afa ,_cfb ){_cb =_ec ^1;_ec =1;}else {_cb =_ec ;_ec =0;};};};if duplicateLineRemoval {if _gdc :=_bbg .encodeBit (_bbg ._da ,_adg ,_cb );
_gdc !=nil {return _gdc ;};if _ec !=0{continue ;};};_cc =bm .Data [_ab *bm .RowStride ];_db =uint16 (_adc >>5);_de =uint16 (_gdd >>4);_adc <<=3;_gdd <<=4;_ef =0;for _ecc =0;_ecc < bm .Width ;_ecc ++{_bfg :=uint32 (_db <<11|_de <<4|_ef );_ae :=(_cc &0x80)>>7;
_ga :=_bbg .encodeBit (_bbg ._da ,_bfg ,_ae );if _ga !=nil {return _ga ;};_db <<=1;_de <<=1;_ef <<=1;_db |=uint16 ((_adc &0x80)>>7);_de |=uint16 ((_gdd &0x80)>>7);_ef |=uint16 (_ae );_dac :=_ecc %8;_ee :=_ecc /8+1;if _dac ==4&&_ab >=2{_adc =0;if _ee < bm .RowStride {_adc =bm .Data [(_ab -2)*bm .RowStride +_ee ];
};}else {_adc <<=1;};if _dac ==3&&_ab >=1{_gdd =0;if _ee < bm .RowStride {_gdd =bm .Data [(_ab -1)*bm .RowStride +_ee ];};}else {_gdd <<=1;};if _dac ==7{_cc =0;if _ee < bm .RowStride {_cc =bm .Data [_ab *bm .RowStride +_ee ];};}else {_cc <<=1;};_db &=31;
_de &=127;_ef &=15;};};return nil ;};func (_acb *Encoder )flush (){_acb .setBits ();_acb ._ba <<=_acb ._dd ;_acb .byteOut ();_acb ._ba <<=_acb ._dd ;_acb .byteOut ();_acb .emit ();if _acb ._fdec !=0xff{_acb ._gd ++;_acb ._fdec =0xff;_acb .emit ();};_acb ._gd ++;
_acb ._fdec =0xac;_acb ._gd ++;_acb .emit ();};func (_abae *Encoder )WriteTo (w _e .Writer )(int64 ,error ){const _ff ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";var _be int64 ;for _cfdc ,_bfb :=range _abae ._fe {_fda ,_efd :=w .Write (_bfb );
if _efd !=nil {return 0,_gc .Wrapf (_efd ,_ff ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_cfdc );};_be +=int64 (_fda );};_abae ._fb =_abae ._fb [:_abae ._ca ];
_acc ,_dgf :=w .Write (_abae ._fb );if _dgf !=nil {return 0,_gc .Wrap (_dgf ,_ff ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_be +=int64 (_acc );return _be ,nil ;};func (_eec *Encoder )EncodeIAID (symbolCodeLength ,value int )(_dbe error ){_ea .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );
if _dbe =_eec .encodeIAID (symbolCodeLength ,value );_dbe !=nil {return _gc .Wrap (_dbe ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};func (_ag *Encoder )DataSize ()int {return _ag .dataSize ()};func (_cde *Encoder )EncodeInteger (proc Class ,value int )(_cbe error ){_ea .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );
if _cbe =_cde .encodeInteger (proc ,value );_cbe !=nil {return _gc .Wrap (_cbe ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};const (_gfgb =65536;_aef =20*1024;);func (_dfg *codingContext )flipMps (_af uint32 ){_dfg ._bf [_af ]=1-_dfg ._bf [_af ]};
func (_bdb *Encoder )encodeInteger (_gbba Class ,_fea int )error {const _ded ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";if _fea > 2000000000||_fea < -2000000000{return _gc .Errorf (_ded ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_fea );
};_aagb :=_bdb ._add [_gbba ];_dedg :=uint32 (1);var _efc int ;for ;;_efc ++{if _fd [_efc ]._df <=_fea &&_fd [_efc ]._bc >=_fea {break ;};};if _fea < 0{_fea =-_fea ;};_fea -=int (_fd [_efc ]._c );_gga :=_fd [_efc ]._a ;for _ecb :=uint8 (0);_ecb < _fd [_efc ]._f ;
_ecb ++{_fbb :=_gga &1;if _ebg :=_bdb .encodeBit (_aagb ,_dedg ,_fbb );_ebg !=nil {return _gc .Wrap (_ebg ,_ded ,"");};_gga >>=1;if _dedg &0x100> 0{_dedg =(((_dedg <<1)|uint32 (_fbb ))&0x1ff)|0x100;}else {_dedg =(_dedg <<1)|uint32 (_fbb );};};_fea <<=32-_fd [_efc ]._bb ;
for _caa :=uint8 (0);_caa < _fd [_efc ]._bb ;_caa ++{_ce :=uint8 ((uint32 (_fea )&0x80000000)>>31);if _cce :=_bdb .encodeBit (_aagb ,_dedg ,_ce );_cce !=nil {return _gc .Wrap (_cce ,_ded ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");
};_fea <<=1;if _dedg &0x100!=0{_dedg =(((_dedg <<1)|uint32 (_ce ))&0x1ff)|0x100;}else {_dedg =(_dedg <<1)|uint32 (_ce );};};return nil ;};func (_aba *Encoder )Reset (){_aba ._fde =0x8000;_aba ._ba =0;_aba ._dd =12;_aba ._gd =-1;_aba ._fdec =0;_aba ._gdf =nil ;
_aba ._da =_gf (_gfgb );};func (_cf *Encoder )Init (){_cf ._da =_gf (_gfgb );_cf ._fde =0x8000;_cf ._ba =0;_cf ._dd =12;_cf ._gd =-1;_cf ._fdec =0;_cf ._ca =0;_cf ._fb =make ([]byte ,_aef );for _dc :=0;_dc < len (_cf ._add );_dc ++{_cf ._add [_dc ]=_gf (512);
};_cf ._gdf =nil ;};const (IAAI Class =iota ;IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);func (_fef *Encoder )code0 (_dge *codingContext ,_bgf uint32 ,_dfe uint16 ,_dcedg byte ){if _dge .mps (_bgf )==0{_fef .codeMPS (_dge ,_bgf ,_dfe ,_dcedg );
}else {_fef .codeLPS (_dge ,_bgf ,_dfe ,_dcedg );};};