//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_d "fmt";_g "github.com/unidoc/unipdf/v3/common";_b "math";);func (_acab *Matrix )Unrealistic ()bool {_eg ,_df ,_ec ,_cgc :=_b .Abs (_acab [0]),_b .Abs (_acab [1]),_b .Abs (_acab [3]),_b .Abs (_acab [4]);_bc :=_eg > _aef &&_cgc > _aef ;_bab :=_df > _aef &&_ec > _aef ;return !(_bc ||_bab );};type Matrix [9]float64 ;func (_ga *Matrix )ScalingFactorY ()float64 {return _b .Hypot (_ga [3],_ga [4])};func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};func (_de *Matrix )Clone ()Matrix {return NewMatrix (_de [0],_de [1],_de [3],_de [4],_de [6],_de [7])};func (_ab Point )Distance (b Point )float64 {return _b .Hypot (_ab .X -b .X ,_ab .Y -b .Y )};func (_bf Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_bf .X +t *b .X ,Y :(1-t )*_bf .Y +t *b .Y };};type Point struct{X float64 ;Y float64 ;};func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};func (_ag *Matrix )ScalingFactorX ()float64 {return _b .Hypot (_ag [0],_ag [1])};func (_fce Point )Displace (delta Point )Point {return Point {_fce .X +delta .X ,_fce .Y +delta .Y }};func (_ba *Matrix )Shear (x ,y float64 ){_ba .Concat (ShearMatrix (x ,y ))};func (_gc *Matrix )Rotate (angle float64 ){_gc .Concat (RotationMatrix (angle ))};func (_aa *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_aa [0],_aa [1]=a ,b ;_aa [3],_aa [4]=c ,d ;_aa [6],_aa [7]=tx ,ty ;_aa .clampRange ();};func (_bcg *Point )transformByMatrix (_fg Matrix ){_bcg .X ,_bcg .Y =_fg .Transform (_bcg .X ,_bcg .Y )};func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};const _cd =1.0e-6;func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_ad :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};_ad .clampRange ();return _ad ;};func (_fc *Point )Set (x ,y float64 ){_fc .X ,_fc .Y =x ,y };func (_fe *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_dd :=NewMatrix (a ,b ,c ,d ,tx ,ty );_fe .transformByMatrix (_dd );};func RotationMatrix (angle float64 )Matrix {_gg :=_b .Cos (angle );_ggb :=_b .Sin (angle );return NewMatrix (_gg ,_ggb ,-_ggb ,_gg ,0,0);};const _ff =1e9;func (_bg Point )String ()string {return _d .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_bg .X ,_bg .Y );};func (_bd *Matrix )clampRange (){for _cfb ,_aca :=range _bd {if _aca > _ff {_g .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_aca ,_ff );_bd [_cfb ]=_ff ;}else if _aca < -_ff {_g .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_aca ,-_ff );_bd [_cfb ]=-_ff ;};};};func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};func (_edd *Matrix )Angle ()float64 {_fd :=_b .Atan2 (-_edd [1],_edd [0]);if _fd < 0.0{_fd +=2*_b .Pi ;};return _fd /_b .Pi *180.0;};func (_e *Matrix )Concat (b Matrix ){*_e =Matrix {b [0]*_e [0]+b [1]*_e [3],b [0]*_e [1]+b [1]*_e [4],0,b [3]*_e [0]+b [4]*_e [3],b [3]*_e [1]+b [4]*_e [4],0,b [6]*_e [0]+b [7]*_e [3]+_e [6],b [6]*_e [1]+b [7]*_e [4]+_e [7],1};_e .clampRange ();};func (_ac Matrix )Mult (b Matrix )Matrix {_ac .Concat (b );return _ac };func (_f Matrix )String ()string {_ae ,_fb ,_c ,_cg ,_ce ,_dg :=_f [0],_f [1],_f [3],_f [4],_f [6],_f [7];return _d .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_ae ,_fb ,_c ,_cg ,_ce ,_dg );};func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};const _aef =1e-6;func (_ed *Matrix )Scale (x ,y float64 ){_ed .Concat (ScaleMatrix (x ,y ))};func (_cgf *Matrix )Translation ()(float64 ,float64 ){return _cgf [6],_cgf [7]};func (_da *Matrix )Translate (x ,y float64 ){_da .Concat (TranslationMatrix (x ,y ))};func (_eda Point )Rotate (theta float64 )Point {_dc :=_b .Hypot (_eda .X ,_eda .Y );_cgg :=_b .Atan2 (_eda .Y ,_eda .X );_gb ,_fef :=_b .Sincos (_cgg +theta /180.0*_b .Pi );return Point {_dc *_fef ,_dc *_gb };};func (_ea *Matrix )Transform (x ,y float64 )(float64 ,float64 ){_cc :=x *_ea [0]+y *_ea [1]+_ea [6];_cf :=x *_ea [3]+y *_ea [4]+_ea [7];return _cc ,_cf ;};