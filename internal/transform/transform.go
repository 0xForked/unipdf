//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_e "fmt";_ab "github.com/unidoc/unipdf/v3/common";_b "math";);const _bge =1e-6;type Point struct{X float64 ;Y float64 ;};func (_cab Matrix )ScalingFactorY ()float64 {return _b .Hypot (_cab [3],_cab [4])};const _fe =1e9;func (_c Matrix )Identity ()bool {return _c [0]==1&&_c [1]==0&&_c [2]==0&&_c [3]==0&&_c [4]==1&&_c [5]==0&&_c [6]==0&&_c [7]==0&&_c [8]==1;};func (_ec Matrix )Transform (x ,y float64 )(float64 ,float64 ){_eag :=x *_ec [0]+y *_ec [3]+_ec [6];_aec :=x *_ec [1]+y *_ec [4]+_ec [7];return _eag ,_aec ;};func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};func (_ba *Matrix )Shear (x ,y float64 ){_ba .Concat (ShearMatrix (x ,y ))};func (_gd Matrix )Singular ()bool {return _b .Abs (_gd [0]*_gd [4]-_gd [1]*_gd [3])< _ede };const _ede =1e-10;func (_baf Matrix )Unrealistic ()bool {_bef ,_cfg ,_ef ,_bbd :=_b .Abs (_baf [0]),_b .Abs (_baf [1]),_b .Abs (_baf [3]),_b .Abs (_baf [4]);_bfe :=_bef > _bge &&_bbd > _bge ;_gde :=_cfg > _bge &&_ef > _bge ;return !(_bfe ||_gde );};func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_eg :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};_eg .clampRange ();return _eg ;};func (_abbe Matrix )Mult (b Matrix )Matrix {_abbe .Concat (b );return _abbe };func (_bb Matrix )Angle ()float64 {_bf :=_b .Atan2 (-_bb [1],_bb [0]);if _bf < 0.0{_bf +=2*_b .Pi ;};return _bf /_b .Pi *180.0;};func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};func (_ad Matrix )Translation ()(float64 ,float64 ){return _ad [6],_ad [7]};func (_abbc Matrix )Scale (xScale ,yScale float64 )Matrix {return _abbc .Mult (NewMatrix (xScale ,0,0,yScale ,0,0));};func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};func (_ccd Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_ccd .X +t *b .X ,Y :(1-t )*_ccd .Y +t *b .Y };};func (_cfgf *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_efa :=NewMatrix (a ,b ,c ,d ,tx ,ty );_cfgf .transformByMatrix (_efa );};func (_cf *Matrix )clampRange (){for _bd ,_cgg :=range _cf {if _cgg > _fe {_ab .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_cgg ,_fe );_cf [_bd ]=_fe ;}else if _cgg < -_fe {_ab .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_cgg ,-_fe );_cf [_bd ]=-_fe ;};};};func (_eaf Matrix )ScalingFactorX ()float64 {return _b .Hypot (_eaf [0],_eaf [1])};func (_dga Point )Displace (delta Point )Point {return Point {_dga .X +delta .X ,_dga .Y +delta .Y }};type Matrix [9]float64 ;func (_dd *Matrix )Clone ()Matrix {return NewMatrix (_dd [0],_dd [1],_dd [3],_dd [4],_dd [6],_dd [7])};func (_aaf Matrix )Inverse ()(Matrix ,bool ){_bg ,_be :=_aaf [0],_aaf [1];_edb ,_aef :=_aaf [3],_aaf [4];_aeb ,_afb :=_aaf [6],_aaf [7];_db :=_bg *_aef -_be *_edb ;if _b .Abs (_db )< _fbb {return Matrix {},false ;};_cc ,_ga :=_aef /_db ,-_be /_db ;_df ,_ege :=-_edb /_db ,_bg /_db ;_ebc :=-(_cc *_aeb +_df *_afb );_dc :=-(_ga *_aeb +_ege *_afb );return NewMatrix (_cc ,_ga ,_df ,_ege ,_ebc ,_dc ),true ;};const _fbb =1.0e-6;func (_ed Matrix )Translate (tx ,ty float64 )Matrix {return NewMatrix (_ed [0],_ed [1],_ed [3],_ed [4],_ed [6]+tx ,_ed [7]+ty );};func (_dg *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_dg [0],_dg [1]=a ,b ;_dg [3],_dg [4]=c ,d ;_dg [6],_dg [7]=tx ,ty ;_dg .clampRange ();};func (_g Matrix )Round (precision float64 )Matrix {for _ea :=range _g {_g [_ea ]=_b .Round (_g [_ea ]/precision )*precision ;};return _g ;};func (_f Matrix )Rotate (theta float64 )Matrix {_fb ,_eb :=_b .Sincos (theta /180.0*_b .Pi );return _f .Mult (NewMatrix (_eb ,-_fb ,_fb ,_eb ,0,0));};func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );};func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};func (_cfc Point )Rotate (theta float64 )Point {_aag :=_b .Hypot (_cfc .X ,_cfc .Y );_geg :=_b .Atan2 (_cfc .Y ,_cfc .X );_egeb ,_cfe :=_b .Sincos (_geg +theta /180.0*_b .Pi );return Point {_aag *_cfe ,_aag *_egeb };};func (_cg *Matrix )Concat (b Matrix ){*_cg =Matrix {b [0]*_cg [0]+b [1]*_cg [3],b [0]*_cg [1]+b [1]*_cg [4],0,b [3]*_cg [0]+b [4]*_cg [3],b [3]*_cg [1]+b [4]*_cg [4],0,b [6]*_cg [0]+b [7]*_cg [3]+_cg [6],b [6]*_cg [1]+b [7]*_cg [4]+_cg [7],1};_cg .clampRange ();};func (_fg *Point )Set (x ,y float64 ){_fg .X ,_fg .Y =x ,y };func (_d Matrix )String ()string {_aa ,_ae ,_ge ,_abb ,_abd ,_ca :=_d [0],_d [1],_d [3],_d [4],_d [6],_d [7];return _e .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_aa ,_ae ,_ge ,_abb ,_abd ,_ca );};func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};func (_aafg Point )String ()string {return _e .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_aafg .X ,_aafg .Y );};func (_gda Point )Distance (b Point )float64 {return _b .Hypot (_gda .X -b .X ,_gda .Y -b .Y )};func (_ddc *Point )transformByMatrix (_bfg Matrix ){_ddc .X ,_ddc .Y =_bfg .Transform (_ddc .X ,_ddc .Y )};func RotationMatrix (angle float64 )Matrix {_cb :=_b .Cos (angle );_af :=_b .Sin (angle );return NewMatrix (_cb ,_af ,-_af ,_cb ,0,0);};