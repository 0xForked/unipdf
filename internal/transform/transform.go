//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_g "fmt";_c "github.com/unidoc/unipdf/v3/common";_ed "math";);func (_cgc *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_cfe :=NewMatrix (a ,b ,c ,d ,tx ,ty );_cgc .transformByMatrix (_cfe );};func (_gfc *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_gfc [0],_gfc [1]=a ,b ;_gfc [3],_gfc [4]=c ,d ;_gfc [6],_gfc [7]=tx ,ty ;_gfc .clampRange ();};func (_ege Matrix )ScalingFactorY ()float64 {return _ed .Hypot (_ege [3],_ege [4])};func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};func (_ae Matrix )Scale (xScale ,yScale float64 )Matrix {return _ae .Mult (NewMatrix (xScale ,0,0,yScale ,0,0));};func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );};func (_cb *Matrix )Shear (x ,y float64 ){_cb .Concat (ShearMatrix (x ,y ))};func (_ad *Matrix )Concat (b Matrix ){*_ad =Matrix {b [0]*_ad [0]+b [1]*_ad [3],b [0]*_ad [1]+b [1]*_ad [4],0,b [3]*_ad [0]+b [4]*_ad [3],b [3]*_ad [1]+b [4]*_ad [4],0,b [6]*_ad [0]+b [7]*_ad [3]+_ad [6],b [6]*_ad [1]+b [7]*_ad [4]+_ad [7],1};_ad .clampRange ();};func (_cfc Matrix )Singular ()bool {return _ed .Abs (_cfc [0]*_cfc [4]-_cfc [1]*_cfc [3])< _eg };func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_b :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};_b .clampRange ();return _b ;};func (_fe Matrix )Rotate (theta float64 )Matrix {_fb ,_aad :=_ed .Sincos (theta /180.0*_ed .Pi );return _fe .Mult (NewMatrix (_aad ,-_fb ,_fb ,_aad ,0,0));};func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};func (_ab Matrix )Translate (tx ,ty float64 )Matrix {return NewMatrix (_ab [0],_ab [1],_ab [3],_ab [4],_ab [6]+tx ,_ab [7]+ty );};func (_eee Matrix )Unrealistic ()bool {_bef ,_gga ,_cgd ,_fgb :=_ed .Abs (_eee [0]),_ed .Abs (_eee [1]),_ed .Abs (_eee [3]),_ed .Abs (_eee [4]);_cbf :=_bef > _gb &&_fgb > _gb ;_bed :=_gga > _gb &&_cgd > _gb ;return !(_cbf ||_bed );};func (_ec *Point )Set (x ,y float64 ){_ec .X ,_ec .Y =x ,y };func (_af Matrix )Angle ()float64 {_ce :=_ed .Atan2 (-_af [1],_af [0]);if _ce < 0.0{_ce +=2*_ed .Pi ;};return _ce /_ed .Pi *180.0;};func (_aaf *Matrix )Clone ()Matrix {return NewMatrix (_aaf [0],_aaf [1],_aaf [3],_aaf [4],_aaf [6],_aaf [7]);};func (_be *Matrix )clampRange (){for _beb ,_bf :=range _be {if _bf > _gaa {_c .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_bf ,_gaa );_be [_beb ]=_gaa ;}else if _bf < -_gaa {_c .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_bf ,-_gaa );_be [_beb ]=-_gaa ;};};};func (_aec Point )Rotate (theta float64 )Point {_ag :=_ed .Hypot (_aec .X ,_aec .Y );_fd :=_ed .Atan2 (_aec .Y ,_aec .X );_afc ,_agg :=_ed .Sincos (_fd +theta /180.0*_ed .Pi );return Point {_ag *_agg ,_ag *_afc };};func (_abf Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_abf .X +t *b .X ,Y :(1-t )*_abf .Y +t *b .Y };};func (_gd Matrix )Round (precision float64 )Matrix {for _gf :=range _gd {_gd [_gf ]=_ed .Round (_gd [_gf ]/precision )*precision ;};return _gd ;};type Matrix [9]float64 ;func (_cbb Matrix )Inverse ()(Matrix ,bool ){_dg ,_db :=_cbb [0],_cbb [1];_ge ,_bb :=_cbb [3],_cbb [4];_cg ,_bc :=_cbb [6],_cbb [7];_dgd :=_dg *_bb -_db *_ge ;if _ed .Abs (_dgd )< _bcb {return Matrix {},false ;};_fg ,_ddf :=_bb /_dgd ,-_db /_dgd ;_eba ,_cc :=-_ge /_dgd ,_dg /_dgd ;_ggc :=-(_fg *_cg +_eba *_bc );_egf :=-(_ddf *_cg +_cc *_bc );return NewMatrix (_fg ,_ddf ,_eba ,_cc ,_ggc ,_egf ),true ;};const _gb =1e-6;func (_de Point )Distance (b Point )float64 {return _ed .Hypot (_de .X -b .X ,_de .Y -b .Y )};func (_ea Point )Displace (delta Point )Point {return Point {_ea .X +delta .X ,_ea .Y +delta .Y }};func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};func (_bg Matrix )String ()string {_d ,_gde ,_aa ,_gdb ,_dc ,_ga :=_bg [0],_bg [1],_bg [3],_bg [4],_bg [6],_bg [7];return _g .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_d ,_gde ,_aa ,_gdb ,_dc ,_ga );};func (_ead *Point )transformByMatrix (_ba Matrix ){_ead .X ,_ead .Y =_ba .Transform (_ead .X ,_ead .Y )};func (_eb Matrix )ScalingFactorX ()float64 {return _ed .Hypot (_eb [0],_eb [1])};func (_dd Matrix )Transform (x ,y float64 )(float64 ,float64 ){_aada :=x *_dd [0]+y *_dd [3]+_dd [6];_cf :=x *_dd [1]+y *_dd [4]+_dd [7];return _aada ,_cf ;};func RotationMatrix (angle float64 )Matrix {_eda :=_ed .Cos (angle );_a :=_ed .Sin (angle );return NewMatrix (_eda ,_a ,-_a ,_eda ,0,0);};func (_ee Matrix )Mult (b Matrix )Matrix {_ee .Concat (b );return _ee };func (_f Matrix )Identity ()bool {return _f [0]==1&&_f [1]==0&&_f [2]==0&&_f [3]==0&&_f [4]==1&&_f [5]==0&&_f [6]==0&&_f [7]==0&&_f [8]==1;};func (_adg Point )String ()string {return _g .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_adg .X ,_adg .Y );};const _gaa =1e9;const _bcb =1.0e-6;func (_gg Matrix )Translation ()(float64 ,float64 ){return _gg [6],_gg [7]};const _eg =1e-10;func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};type Point struct{X float64 ;Y float64 ;};