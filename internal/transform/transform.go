//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_a "fmt";_b "github.com/unidoc/unipdf/v3/common";_f "math";);func (_fa Matrix )Round (precision float64 )Matrix {for _fd :=range _fa {_fa [_fd ]=_f .Round (_fa [_fd ]/precision )*precision ;};return _fa ;};func (_ddb *Point )transformByMatrix (_dde Matrix ){_ddb .X ,_ddb .Y =_dde .Transform (_ddb .X ,_ddb .Y )};
func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};func (_gb Matrix )Angle ()float64 {_fgc :=_f .Atan2 (-_gb [1],_gb [0]);if _fgc < 0.0{_fgc +=2*_f .Pi ;};return _fgc /_f .Pi *180.0;};const _beec =1e9;func RotationMatrix (angle float64 )Matrix {_bd :=_f .Cos (angle );
_c :=_f .Sin (angle );return NewMatrix (_bd ,_c ,-_c ,_bd ,0,0);};func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};func (_ggb Matrix )Singular ()bool {return _f .Abs (_ggb [0]*_ggb [4]-_ggb [1]*_ggb [3])< _dc };
func (_gge Matrix )Translate (tx ,ty float64 )Matrix {return _gge .Mult (TranslationMatrix (tx ,ty ))};func (_fdd *Matrix )Clone ()Matrix {return NewMatrix (_fdd [0],_fdd [1],_fdd [3],_fdd [4],_fdd [6],_fdd [7]);};func (_g Matrix )Identity ()bool {return _g [0]==1&&_g [1]==0&&_g [2]==0&&_g [3]==0&&_g [4]==1&&_g [5]==0&&_g [6]==0&&_g [7]==0&&_g [8]==1;
};const _ebad =1e-6;func (_ed Matrix )Inverse ()(Matrix ,bool ){_gfe ,_fddf :=_ed [0],_ed [1];_dd ,_ae :=_ed [3],_ed [4];_ge ,_cc :=_ed [6],_ed [7];_eba :=_gfe *_ae -_fddf *_dd ;if _f .Abs (_eba )< _gc {return Matrix {},false ;};_ede ,_abf :=_ae /_eba ,-_fddf /_eba ;
_ef ,_edd :=-_dd /_eba ,_gfe /_eba ;_cb :=-(_ede *_ge +_ef *_cc );_ebc :=-(_abf *_ge +_edd *_cc );return NewMatrix (_ede ,_abf ,_ef ,_edd ,_cb ,_ebc ),true ;};func (_bc *Matrix )Concat (b Matrix ){*_bc =Matrix {b [0]*_bc [0]+b [1]*_bc [3],b [0]*_bc [1]+b [1]*_bc [4],0,b [3]*_bc [0]+b [4]*_bc [3],b [3]*_bc [1]+b [4]*_bc [4],0,b [6]*_bc [0]+b [7]*_bc [3]+_bc [6],b [6]*_bc [1]+b [7]*_bc [4]+_bc [7],1};
_bc .clampRange ();};func (_ec Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_ec .X +t *b .X ,Y :(1-t )*_ec .Y +t *b .Y };};func (_faa Matrix )Mult (b Matrix )Matrix {_faa .Concat (b );return _faa };func (_fcb Point )Distance (b Point )float64 {return _f .Hypot (_fcb .X -b .X ,_fcb .Y -b .Y )};
func (_eb *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_eb [0],_eb [1]=a ,b ;_eb [3],_eb [4]=c ,d ;_eb [6],_eb [7]=tx ,ty ;_eb .clampRange ();};func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );
};func (_faae Point )Rotate (theta float64 )Point {_fda :=_f .Hypot (_faae .X ,_faae .Y );_efa :=_f .Atan2 (_faae .Y ,_faae .X );_dac ,_gd :=_f .Sincos (_efa +theta /180.0*_f .Pi );return Point {_fda *_gd ,_fda *_dac };};type Matrix [9]float64 ;func (_cg Matrix )Scale (xScale ,yScale float64 )Matrix {return _cg .Mult (ScaleMatrix (xScale ,yScale ))};
func (_ab Matrix )ScalingFactorY ()float64 {return _f .Hypot (_ab [3],_ab [4])};func (_db Matrix )Rotate (theta float64 )Matrix {return _db .Mult (RotationMatrix (theta ))};func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};func (_fac Matrix )Translation ()(float64 ,float64 ){return _fac [6],_fac [7]};
func (_fge Point )String ()string {return _a .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_fge .X ,_fge .Y );};func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_da :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};_da .clampRange ();
return _da ;};type Point struct{X float64 ;Y float64 ;};func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};func (_gf Matrix )ScalingFactorX ()float64 {return _f .Hypot (_gf [0],_gf [1])};const _dc =1e-10;func (_fc *Matrix )clampRange (){for _bef ,_eded :=range _fc {if _eded > _beec {_b .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_eded ,_beec );
_fc [_bef ]=_beec ;}else if _eded < -_beec {_b .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_eded ,-_beec );_fc [_bef ]=-_beec ;};};};func (_gbg Point )Displace (delta Point )Point {return Point {_gbg .X +delta .X ,_gbg .Y +delta .Y }};
func (_ebf *Point )Set (x ,y float64 ){_ebf .X ,_ebf .Y =x ,y };func (_dg *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_efb :=NewMatrix (a ,b ,c ,d ,tx ,ty );_dg .transformByMatrix (_efb );};func (_ca Matrix )String ()string {_cf ,_fg ,_fdg ,_ba ,_e ,_gg :=_ca [0],_ca [1],_ca [3],_ca [4],_ca [6],_ca [7];
return _a .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_cf ,_fg ,_fdg ,_ba ,_e ,_gg );};
const _gc =1.0e-6;func (_de Matrix )Transform (x ,y float64 )(float64 ,float64 ){_be :=x *_de [0]+y *_de [3]+_de [6];_df :=x *_de [1]+y *_de [4]+_de [7];return _be ,_df ;};func (_cfe *Matrix )Shear (x ,y float64 ){_cfe .Concat (ShearMatrix (x ,y ))};func (_bcb Matrix )Unrealistic ()bool {_geb ,_gec ,_bdg ,_aeb :=_f .Abs (_bcb [0]),_f .Abs (_bcb [1]),_f .Abs (_bcb [3]),_f .Abs (_bcb [4]);
_bee :=_geb > _ebad &&_aeb > _ebad ;_gbd :=_gec > _ebad &&_bdg > _ebad ;return !(_bee ||_gbd );};