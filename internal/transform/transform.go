//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_bb "fmt";_ba "github.com/unidoc/unipdf/v3/common";_a "math";);func (_gg *Matrix )Translation ()(float64 ,float64 ){return _gg [6],_gg [7]};func (_cgc *Matrix )clampRange (){for _af ,_gfa :=range _cgc {if _gfa > _dbf {_ba .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_gfa ,_dbf );_cgc [_af ]=_dbf ;}else if _gfa < -_dbf {_ba .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_gfa ,-_dbf );_cgc [_af ]=-_dbf ;};};};const _dbf =1e9;type Point struct{X float64 ;Y float64 ;};func (_ac *Point )transformByMatrix (_fd Matrix ){_ac .X ,_ac .Y =_fd .Transform (_ac .X ,_ac .Y )};func (_fca *Matrix )Clone ()Matrix {return NewMatrix (_fca [0],_fca [1],_fca [3],_fca [4],_fca [6],_fca [7]);};func RotationMatrix (angle float64 )Matrix {_ae :=_a .Cos (angle );_e :=_a .Sin (angle );return NewMatrix (_ae ,_e ,-_e ,_ae ,0,0);};func (_cfa *Matrix )Angle ()float64 {_ee :=_a .Atan2 (-_cfa [1],_cfa [0]);if _ee < 0.0{_ee +=2*_a .Pi ;};return _ee /_a .Pi *180.0;};func (_cf *Matrix )Translate (x ,y float64 ){_cf .Concat (TranslationMatrix (x ,y ))};func (_ecb *Matrix )Unrealistic ()bool {_afg ,_ggd ,_eg ,_db :=_a .Abs (_ecb [0]),_a .Abs (_ecb [1]),_a .Abs (_ecb [3]),_a .Abs (_ecb [4]);_bc :=_afg > _daa &&_db > _daa ;_fcf :=_ggd > _daa &&_eg > _daa ;return !(_bc ||_fcf );};func (_ag *Matrix )Shear (x ,y float64 ){_ag .Concat (ShearMatrix (x ,y ))};func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};type Matrix [9]float64 ;func (_ec *Matrix )Scale (x ,y float64 ){_ec .Concat (ScaleMatrix (x ,y ))};func (_dd Point )Displace (delta Point )Point {return Point {_dd .X +delta .X ,_dd .Y +delta .Y }};func (_aea *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_gde :=NewMatrix (a ,b ,c ,d ,tx ,ty );_aea .transformByMatrix (_gde );};func (_c Matrix )String ()string {_eb ,_g ,_cg ,_gd ,_gc ,_aa :=_c [0],_c [1],_c [3],_c [4],_c [6],_c [7];return _bb .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_eb ,_g ,_cg ,_gd ,_gc ,_aa );};func (_df *Matrix )ScalingFactorY ()float64 {return _a .Hypot (_df [3],_df [4])};func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};const _fa =1.0e-6;func (_gab Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_gab .X +t *b .X ,Y :(1-t )*_gab .Y +t *b .Y };};func (_da *Matrix )Transform (x ,y float64 )(float64 ,float64 ){_gdc :=x *_da [0]+y *_da [1]+_da [6];_agg :=x *_da [3]+y *_da [4]+_da [7];return _gdc ,_agg ;};const _daa =1e-6;func (_bf Matrix )Mult (b Matrix )Matrix {_bf .Concat (b );return _bf };func (_gf *Matrix )ScalingFactorX ()float64 {return _a .Hypot (_gf [0],_gf [1])};func (_aggc Point )String ()string {return _bb .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_aggc .X ,_aggc .Y );};func (_d *Matrix )Concat (b Matrix ){*_d =Matrix {b [0]*_d [0]+b [1]*_d [3],b [0]*_d [1]+b [1]*_d [4],0,b [3]*_d [0]+b [4]*_d [3],b [3]*_d [1]+b [4]*_d [4],0,b [6]*_d [0]+b [7]*_d [3]+_d [6],b [6]*_d [1]+b [7]*_d [4]+_d [7],1};_d .clampRange ();};func (_ed *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_ed [0],_ed [1]=a ,b ;_ed [3],_ed [4]=c ,d ;_ed [6],_ed [7]=tx ,ty ;_ed .clampRange ();};func (_ga Point )Distance (b Point )float64 {return _a .Hypot (_ga .X -b .X ,_ga .Y -b .Y )};func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};func (_ggc Point )Rotate (theta float64 )Point {_gga :=_a .Hypot (_ggc .X ,_ggc .Y );_ef :=_a .Atan2 (_ggc .Y ,_ggc .X );_bab ,_ce :=_a .Sincos (_ef +theta /180.0*_a .Pi );return Point {_gga *_ce ,_gga *_bab };};func (_fc *Matrix )Rotate (angle float64 ){_fc .Concat (RotationMatrix (angle ))};func (_fg *Point )Set (x ,y float64 ){_fg .X ,_fg .Y =x ,y };func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_f :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};_f .clampRange ();return _f ;};func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};