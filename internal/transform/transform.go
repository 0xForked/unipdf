//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_e "fmt";_a "github.com/unidoc/unipdf/v3/common";_f "math";);func (_gfd *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_cdf :=NewMatrix (a ,b ,c ,d ,tx ,ty );_gfd .transformByMatrix (_cdf );};type Point struct{X float64 ;Y float64 ;
};func (_egg Point )Displace (delta Point )Point {return Point {_egg .X +delta .X ,_egg .Y +delta .Y }};const _ca =1e-6;const _gbd =1e-10;func (_cgb *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_cgb [0],_cgb [1]=a ,b ;_cgb [3],_cgb [4]=c ,d ;_cgb [6],_cgb [7]=tx ,ty ;
_cgb .clampRange ();};func (_deb Matrix )ScalingFactorY ()float64 {return _f .Hypot (_deb [3],_deb [4])};func (_ea Matrix )Inverse ()(Matrix ,bool ){_bd ,_gc :=_ea [0],_ea [1];_eg ,_ece :=_ea [3],_ea [4];_be ,_ae :=_ea [6],_ea [7];_ce :=_bd *_ece -_gc *_eg ;
if _f .Abs (_ce )< _cbc {return Matrix {},false ;};_aag ,_aea :=_ece /_ce ,-_gc /_ce ;_bbb ,_fd :=-_eg /_ce ,_bd /_ce ;_eb :=-(_aag *_be +_bbb *_ae );_gce :=-(_aea *_be +_fd *_ae );return NewMatrix (_aag ,_aea ,_bbb ,_fd ,_eb ,_gce ),true ;};func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};
func (_cea *Point )Set (x ,y float64 ){_cea .X ,_cea .Y =x ,y };func (_bb Matrix )Translation ()(float64 ,float64 ){return _bb [6],_bb [7]};func (_fg *Point )transformByMatrix (_cef Matrix ){_fg .X ,_fg .Y =_cef .Transform (_fg .X ,_fg .Y )};func (_bfea *Matrix )Shear (x ,y float64 ){_bfea .Concat (ShearMatrix (x ,y ))};
func (_g Matrix )Identity ()bool {return _g [0]==1&&_g [1]==0&&_g [2]==0&&_g [3]==0&&_g [4]==1&&_g [5]==0&&_g [6]==0&&_g [7]==0&&_g [8]==1;};func (_de Matrix )Mult (b Matrix )Matrix {_de .Concat (b );return _de };func (_bdd Point )Rotate (theta float64 )Point {_gcec :=_f .Hypot (_bdd .X ,_bdd .Y );
_fde :=_f .Atan2 (_bdd .Y ,_bdd .X );_gbf ,_abd :=_f .Sincos (_fde +theta /180.0*_f .Pi );return Point {_gcec *_abd ,_gcec *_gbf };};func (_cd Matrix )Rotate (theta float64 )Matrix {return _cd .Mult (RotationMatrix (theta ))};const _cbc =1.0e-6;func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );
};func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};func (_feb Point )String ()string {return _e .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_feb .X ,_feb .Y );};func (_cbe *Matrix )Clone ()Matrix {return NewMatrix (_cbe [0],_cbe [1],_cbe [3],_cbe [4],_cbe [6],_cbe [7]);
};func (_ab *Matrix )clampRange (){for _ef ,_gfe :=range _ab {if _gfe > _efc {_a .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_gfe ,_efc );_ab [_ef ]=_efc ;}else if _gfe < -_efc {_a .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_gfe ,-_efc );
_ab [_ef ]=-_efc ;};};};func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};func (_ff Matrix )Angle ()float64 {_ffg :=_f .Atan2 (-_ff [1],_ff [0]);if _ffg < 0.0{_ffg +=2*_f .Pi ;
};return _ffg /_f .Pi *180.0;};func (_cc Matrix )Round (precision float64 )Matrix {for _d :=range _cc {_cc [_d ]=_f .Round (_cc [_d ]/precision )*precision ;};return _cc ;};func (_ec Matrix )ScalingFactorX ()float64 {return _f .Hypot (_ec [0],_ec [1])};
func (_bc Matrix )Scale (xScale ,yScale float64 )Matrix {return _bc .Mult (ScaleMatrix (xScale ,yScale ))};func (_gba Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_gba .X +t *b .X ,Y :(1-t )*_gba .Y +t *b .Y };};func (_eab Point )Distance (b Point )float64 {return _f .Hypot (_eab .X -b .X ,_eab .Y -b .Y )};
func (_ge Matrix )Unrealistic ()bool {_bba ,_gfg ,_fag ,_ed :=_f .Abs (_ge [0]),_f .Abs (_ge [1]),_f .Abs (_ge [3]),_f .Abs (_ge [4]);_dde :=_bba > _ca &&_ed > _ca ;_ddd :=_gfg > _ca &&_fag > _ca ;return !(_dde ||_ddd );};func (_fc Matrix )String ()string {_b ,_cg ,_fe ,_bf ,_cb ,_fa :=_fc [0],_fc [1],_fc [3],_fc [4],_fc [6],_fc [7];
return _e .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_b ,_cg ,_fe ,_bf ,_cb ,_fa );};
func (_aa *Matrix )Concat (b Matrix ){*_aa =Matrix {b [0]*_aa [0]+b [1]*_aa [3],b [0]*_aa [1]+b [1]*_aa [4],0,b [3]*_aa [0]+b [4]*_aa [3],b [3]*_aa [1]+b [4]*_aa [4],0,b [6]*_aa [0]+b [7]*_aa [3]+_aa [6],b [6]*_aa [1]+b [7]*_aa [4]+_aa [7],1};_aa .clampRange ();
};const _efc =1e9;func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_gb :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};_gb .clampRange ();return _gb ;};func (_ac Matrix )Transform (x ,y float64 )(float64 ,float64 ){_ba :=x *_ac [0]+y *_ac [3]+_ac [6];_fb :=x *_ac [1]+y *_ac [4]+_ac [7];
return _ba ,_fb ;};func (_dd Matrix )Singular ()bool {return _f .Abs (_dd [0]*_dd [4]-_dd [1]*_dd [3])< _gbd };func (_bfe Matrix )Translate (tx ,ty float64 )Matrix {return _bfe .Mult (TranslationMatrix (tx ,ty ))};func RotationMatrix (angle float64 )Matrix {_gf :=_f .Cos (angle );
_ccd :=_f .Sin (angle );return NewMatrix (_gf ,_ccd ,-_ccd ,_gf ,0,0);};func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};type Matrix [9]float64 ;