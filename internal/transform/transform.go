//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_b "fmt";_a "github.com/unidoc/unipdf/v3/common";_g "math";);const _agd =1e-6;func (_ccd Matrix )Translation ()(float64 ,float64 ){return _ccd [6],_ccd [7]};func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );
};func (_eaf *Matrix )Shear (x ,y float64 ){_eaf .Concat (ShearMatrix (x ,y ))};func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_ee :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};_ee .clampRange ();return _ee ;};func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};
func (_fab Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_fab .X +t *b .X ,Y :(1-t )*_fab .Y +t *b .Y };};func (_gd Matrix )Angle ()float64 {_efb :=_g .Atan2 (-_gd [1],_gd [0]);if _efb < 0.0{_efb +=2*_g .Pi ;};return _efb /_g .Pi *180.0;
};func (_bgf Matrix )Scale (xScale ,yScale float64 )Matrix {return _bgf .Mult (ScaleMatrix (xScale ,yScale ));};func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};func (_ce Point )Displace (delta Point )Point {return Point {_ce .X +delta .X ,_ce .Y +delta .Y }};
func (_ef Matrix )Mult (b Matrix )Matrix {_ef .Concat (b );return _ef };type Matrix [9]float64 ;func (_ea Matrix )Identity ()bool {return _ea [0]==1&&_ea [1]==0&&_ea [2]==0&&_ea [3]==0&&_ea [4]==1&&_ea [5]==0&&_ea [6]==0&&_ea [7]==0&&_ea [8]==1;};func (_bgc *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_df :=NewMatrix (a ,b ,c ,d ,tx ,ty );
_bgc .transformByMatrix (_df );};const _ad =1e-10;func (_fe *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_fe [0],_fe [1]=a ,b ;_fe [3],_fe [4]=c ,d ;_fe [6],_fe [7]=tx ,ty ;_fe .clampRange ();};type Point struct{X float64 ;Y float64 ;};func (_gf *Point )Set (x ,y float64 ){_gf .X ,_gf .Y =x ,y };
func (_fg Matrix )String ()string {_aa ,_ace ,_c ,_cc ,_eec ,_bg :=_fg [0],_fg [1],_fg [3],_fg [4],_fg [6],_fg [7];return _b .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_aa ,_ace ,_c ,_cc ,_eec ,_bg );
};func RotationMatrix (angle float64 )Matrix {_eaa :=_g .Cos (angle );_ac :=_g .Sin (angle );return NewMatrix (_eaa ,_ac ,-_ac ,_eaa ,0,0);};func (_fge Point )Distance (b Point )float64 {return _g .Hypot (_fge .X -b .X ,_fge .Y -b .Y )};func (_cf Matrix )ScalingFactorY ()float64 {return _g .Hypot (_cf [3],_cf [4])};
func (_fb Matrix )Unrealistic ()bool {_aed ,_af ,_eece ,_agb :=_g .Abs (_fb [0]),_g .Abs (_fb [1]),_g .Abs (_fb [3]),_g .Abs (_fb [4]);_dbf :=_aed > _agd &&_agb > _agd ;_dec :=_af > _agd &&_eece > _agd ;return !(_dbf ||_dec );};func (_fgb Matrix )Transform (x ,y float64 )(float64 ,float64 ){_bga :=x *_fgb [0]+y *_fgb [3]+_fgb [6];
_fga :=x *_fgb [1]+y *_fgb [4]+_fgb [7];return _bga ,_fga ;};func (_ebe *Matrix )clampRange (){for _ff ,_ba :=range _ebe {if _ba > _cbb {_a .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_ba ,_cbb );_ebe [_ff ]=_cbb ;
}else if _ba < -_cbb {_a .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_ba ,-_cbb );_ebe [_ff ]=-_cbb ;};};};const _cbb =1e9;func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};
func (_ed *Matrix )Concat (b Matrix ){*_ed =Matrix {b [0]*_ed [0]+b [1]*_ed [3],b [0]*_ed [1]+b [1]*_ed [4],0,b [3]*_ed [0]+b [4]*_ed [3],b [3]*_ed [1]+b [4]*_ed [4],0,b [6]*_ed [0]+b [7]*_ed [3]+_ed [6],b [6]*_ed [1]+b [7]*_ed [4]+_ed [7],1};_ed .clampRange ();
};func (_ae Matrix )Inverse ()(Matrix ,bool ){_gg ,_db :=_ae [0],_ae [1];_ggg ,_ga :=_ae [3],_ae [4];_eb ,_aad :=_ae [6],_ae [7];_bc :=_gg *_ga -_db *_ggg ;if _g .Abs (_bc )< _fda {return Matrix {},false ;};_cb ,_ag :=_ga /_bc ,-_db /_bc ;_ccg ,_de :=-_ggg /_bc ,_gg /_bc ;
_gc :=-(_cb *_eb +_ccg *_aad );_ge :=-(_ag *_eb +_de *_aad );return NewMatrix (_cb ,_ag ,_ccg ,_de ,_gc ,_ge ),true ;};func (_fd Matrix )Singular ()bool {return _g .Abs (_fd [0]*_fd [4]-_fd [1]*_fd [3])< _ad };func (_fa Matrix )ScalingFactorX ()float64 {return _g .Hypot (_fa [0],_fa [1])};
func (_ca *Matrix )Clone ()Matrix {return NewMatrix (_ca [0],_ca [1],_ca [3],_ca [4],_ca [6],_ca [7])};func (_aceg Matrix )Translate (tx ,ty float64 )Matrix {return _aceg .Mult (TranslationMatrix (tx ,ty ))};func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};
func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};func (_aaa Matrix )Rotate (theta float64 )Matrix {return _aaa .Mult (RotationMatrix (theta ))};func (_aaag Point )Rotate (theta float64 )Point {_fgc :=_g .Hypot (_aaag .X ,_aaag .Y );
_fac :=_g .Atan2 (_aaag .Y ,_aaag .X );_cef ,_bcd :=_g .Sincos (_fac +theta /180.0*_g .Pi );return Point {_fgc *_bcd ,_fgc *_cef };};func (_d Matrix )Round (precision float64 )Matrix {for _e :=range _d {_d [_e ]=_g .Round (_d [_e ]/precision )*precision ;
};return _d ;};const _fda =1.0e-6;func (_gdb Point )String ()string {return _b .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_gdb .X ,_gdb .Y );};func (_fgg *Point )transformByMatrix (_efbg Matrix ){_fgg .X ,_fgg .Y =_efbg .Transform (_fgg .X ,_fgg .Y )};
