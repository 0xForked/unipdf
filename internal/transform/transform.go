//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_b "fmt";_ba "github.com/unidoc/unipdf/v3/common";_bg "math";);func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};func (_de Matrix )Transform (x ,y float64 )(float64 ,float64 ){_fca :=x *_de [0]+y *_de [3]+_de [6];
_eb :=x *_de [1]+y *_de [4]+_de [7];return _fca ,_eb ;};func (_eg *Matrix )Concat (b Matrix ){*_eg =Matrix {b [0]*_eg [0]+b [1]*_eg [3],b [0]*_eg [1]+b [1]*_eg [4],0,b [3]*_eg [0]+b [4]*_eg [3],b [3]*_eg [1]+b [4]*_eg [4],0,b [6]*_eg [0]+b [7]*_eg [3]+_eg [6],b [6]*_eg [1]+b [7]*_eg [4]+_eg [7],1};
_eg .clampRange ();};func (_dd Matrix )Translate (tx ,ty float64 )Matrix {return _dd .Mult (TranslationMatrix (tx ,ty ))};func (_bd *Matrix )Shear (x ,y float64 ){_bd .Concat (ShearMatrix (x ,y ))};func (_agb Matrix )Singular ()bool {return _bg .Abs (_agb [0]*_agb [4]-_agb [1]*_agb [3])< _ffb };
func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};const _ce =1e9;func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_df :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};_df .clampRange ();
return _df ;};type Matrix [9]float64 ;func (_d Matrix )Round (precision float64 )Matrix {for _fe :=range _d {_d [_fe ]=_bg .Round (_d [_fe ]/precision )*precision ;};return _d ;};func (_fc Matrix )Mult (b Matrix )Matrix {_fc .Concat (b );return _fc };func (_e Matrix )String ()string {_bga ,_bgb ,_c ,_cf ,_bab ,_ff :=_e [0],_e [1],_e [3],_e [4],_e [6],_e [7];
return _b .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_bga ,_bgb ,_c ,_cf ,_bab ,_ff );
};func (_cge Matrix )Unrealistic ()bool {_fd ,_cgc ,_ef ,_gfe :=_bg .Abs (_cge [0]),_bg .Abs (_cge [1]),_bg .Abs (_cge [3]),_bg .Abs (_cge [4]);_ea :=_fd > _dgg &&_gfe > _dgg ;_bgbd :=_cgc > _dgg &&_ef > _dgg ;return !(_ea ||_bgbd );};func (_gc Matrix )Angle ()float64 {_bf :=_bg .Atan2 (-_gc [1],_gc [0]);
if _bf < 0.0{_bf +=2*_bg .Pi ;};return _bf /_bg .Pi *180.0;};func (_eba Matrix )Inverse ()(Matrix ,bool ){_fg ,_ge :=_eba [0],_eba [1];_cg ,_fgf :=_eba [3],_eba [4];_gef ,_gf :=_eba [6],_eba [7];_dgc :=_fg *_fgf -_ge *_cg ;if _bg .Abs (_dgc )< _ae {return Matrix {},false ;
};_gfb ,_ede :=_fgf /_dgc ,-_ge /_dgc ;_fea ,_bc :=-_cg /_dgc ,_fg /_dgc ;_cga :=-(_gfb *_gef +_fea *_gf );_gga :=-(_ede *_gef +_bc *_gf );return NewMatrix (_gfb ,_ede ,_fea ,_bc ,_cga ,_gga ),true ;};func (_a Matrix )Rotate (theta float64 )Matrix {return _a .Mult (RotationMatrix (theta ))};
func (_ed *Matrix )Clone ()Matrix {return NewMatrix (_ed [0],_ed [1],_ed [3],_ed [4],_ed [6],_ed [7])};func (_bgd *Point )transformByMatrix (_eae Matrix ){_bgd .X ,_bgd .Y =_eae .Transform (_bgd .X ,_bgd .Y )};func (_db *Matrix )clampRange (){for _cd ,_ee :=range _db {if _ee > _ce {_ba .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_ee ,_ce );
_db [_cd ]=_ce ;}else if _ee < -_ce {_ba .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_ee ,-_ce );_db [_cd ]=-_ce ;};};};const _ae =1.0e-6;type Point struct{X float64 ;Y float64 ;};func (_bgc *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_bgc [0],_bgc [1]=a ,b ;
_bgc [3],_bgc [4]=c ,d ;_bgc [6],_bgc [7]=tx ,ty ;_bgc .clampRange ();};func (_baa Point )Displace (delta Point )Point {return Point {_baa .X +delta .X ,_baa .Y +delta .Y }};func (_dg Matrix )ScalingFactorY ()float64 {return _bg .Hypot (_dg [3],_dg [4])};
func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};func RotationMatrix (angle float64 )Matrix {_g :=_bg .Cos (angle );_gg :=_bg .Sin (angle );return NewMatrix (_g ,_gg ,-_gg ,_g ,0,0);};func (_ag Matrix )Translation ()(float64 ,float64 ){return _ag [6],_ag [7]};
func (_egd Matrix )ScalingFactorX ()float64 {return _bg .Hypot (_egd [0],_egd [1])};func (_bb Matrix )Scale (xScale ,yScale float64 )Matrix {return _bb .Mult (ScaleMatrix (xScale ,yScale ))};func (_gcf Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_gcf .X +t *b .X ,Y :(1-t )*_gcf .Y +t *b .Y };
};func (_cde Point )Rotate (theta float64 )Point {_age :=_bg .Hypot (_cde .X ,_cde .Y );_bgg :=_bg .Atan2 (_cde .Y ,_cde .X );_agd ,_eec :=_bg .Sincos (_bgg +theta /180.0*_bg .Pi );return Point {_age *_eec ,_age *_agd };};func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );
};func (_fga *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_gff :=NewMatrix (a ,b ,c ,d ,tx ,ty );_fga .transformByMatrix (_gff );};const _ffb =1e-10;func (_ad Point )String ()string {return _b .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_ad .X ,_ad .Y );
};func (_ebf Point )Distance (b Point )float64 {return _bg .Hypot (_ebf .X -b .X ,_ebf .Y -b .Y )};func (_aec *Point )Set (x ,y float64 ){_aec .X ,_aec .Y =x ,y };func (_fb Matrix )Identity ()bool {return _fb [0]==1&&_fb [1]==0&&_fb [2]==0&&_fb [3]==0&&_fb [4]==1&&_fb [5]==0&&_fb [6]==0&&_fb [7]==0&&_fb [8]==1;
};func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};const _dgg =1e-6;