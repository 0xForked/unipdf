//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_a "fmt";_df "github.com/unidoc/unipdf/v3/common";_b "math";);func (_fbfg Matrix )Angle ()float64 {_cg :=_b .Atan2 (-_fbfg [1],_fbfg [0]);if _cg < 0.0{_cg +=2*_b .Pi ;};return _cg /_b .Pi *180.0;};func (_cc *Matrix )Shear (x ,y float64 ){_cc .Concat (ShearMatrix (x ,y ))};func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};func (_egbf *Point )transformByMatrix (_eba Matrix ){_egbf .X ,_egbf .Y =_eba .Transform (_egbf .X ,_egbf .Y );};func (_ed Point )Rotate (theta float64 )Point {_ba :=_b .Hypot (_ed .X ,_ed .Y );_abb :=_b .Atan2 (_ed .Y ,_ed .X );_edf ,_fda :=_b .Sincos (_abb +theta /180.0*_b .Pi );return Point {_ba *_fda ,_ba *_edf };};func (_f Matrix )Scale (xScale ,yScale float64 )Matrix {return _f .Mult (NewMatrix (xScale ,0,0,yScale ,0,0));};func (_cgg Matrix )Unrealistic ()bool {_feg ,_fd ,_ce ,_cag :=_b .Abs (_cgg [0]),_b .Abs (_cgg [1]),_b .Abs (_cgg [3]),_b .Abs (_cgg [4]);_gce :=_feg > _aff &&_cag > _aff ;_agg :=_fd > _aff &&_ce > _aff ;return !(_gce ||_agg );};func (_egb *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_gbd :=NewMatrix (a ,b ,c ,d ,tx ,ty );_egb .transformByMatrix (_gbd );};func (_ga *Matrix )Clone ()Matrix {return NewMatrix (_ga [0],_ga [1],_ga [3],_ga [4],_ga [6],_ga [7])};func (_fc Matrix )Mult (b Matrix )Matrix {_fc .Concat (b );return _fc };func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_eb :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};_eb .clampRange ();return _eb ;};func (_dbd *Matrix )clampRange (){for _be ,_dea :=range _dbd {if _dea > _ef {_df .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_dea ,_ef );_dbd [_be ]=_ef ;}else if _dea < -_ef {_df .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_dea ,-_ef );_dbd [_be ]=-_ef ;};};};func (_fa Matrix )ScalingFactorY ()float64 {return _b .Hypot (_fa [3],_fa [4])};func (_efe Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_efe .X +t *b .X ,Y :(1-t )*_efe .Y +t *b .Y };};type Point struct{X float64 ;Y float64 ;};const _cd =1.0e-6;func (_fbb Point )Displace (delta Point )Point {return Point {_fbb .X +delta .X ,_fbb .Y +delta .Y }};func (_fbf *Matrix )Concat (b Matrix ){*_fbf =Matrix {b [0]*_fbf [0]+b [1]*_fbf [3],b [0]*_fbf [1]+b [1]*_fbf [4],0,b [3]*_fbf [0]+b [4]*_fbf [3],b [3]*_fbf [1]+b [4]*_fbf [4],0,b [6]*_fbf [0]+b [7]*_fbf [3]+_fbf [6],b [6]*_fbf [1]+b [7]*_fbf [4]+_fbf [7],1};_fbf .clampRange ();};func (_bc Matrix )ScalingFactorX ()float64 {return _b .Hypot (_bc [0],_bc [1])};func (_ebf *Point )Set (x ,y float64 ){_ebf .X ,_ebf .Y =x ,y };func (_c Matrix )String ()string {_ge ,_gea ,_cf ,_cfb ,_gc ,_gec :=_c [0],_c [1],_c [3],_c [4],_c [6],_c [7];return _a .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_ge ,_gea ,_cf ,_cfb ,_gc ,_gec );};func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};func (_afc Matrix )Inverse ()(Matrix ,bool ){_ab ,_eg :=_afc [0],_afc [1];_dc ,_bcf :=_afc [3],_afc [4];_bd ,_da :=_afc [6],_afc [7];_gebb :=_ab *_bcf -_eg *_dc ;if _b .Abs (_gebb )< _cd {return Matrix {},false ;};_ega ,_fe :=_bcf /_gebb ,-_eg /_gebb ;_egd ,_db :=-_dc /_gebb ,_ab /_gebb ;_gb :=-(_ega *_bd +_egd *_da );_bdd :=-(_fe *_bd +_db *_da );return NewMatrix (_ega ,_fe ,_egd ,_db ,_gb ,_bdd ),true ;};type Matrix [9]float64 ;func (_faa Point )String ()string {return _a .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_faa .X ,_faa .Y );};func RotationMatrix (angle float64 )Matrix {_e :=_b .Cos (angle );_g :=_b .Sin (angle );return NewMatrix (_e ,_g ,-_g ,_e ,0,0);};func (_dd Matrix )Rotate (theta float64 )Matrix {_de ,_ag :=_b .Sincos (theta /180.0*_b .Pi );return _dd .Mult (NewMatrix (_ag ,-_de ,_de ,_ag ,0,0));};func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};const _aff =1e-6;const _ef =1e9;func (_af Matrix )Translation ()(float64 ,float64 ){return _af [6],_af [7]};func (_fb *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_fb [0],_fb [1]=a ,b ;_fb [3],_fb [4]=c ,d ;_fb [6],_fb [7]=tx ,ty ;_fb .clampRange ();};func (_gcc Point )Distance (b Point )float64 {return _b .Hypot (_gcc .X -b .X ,_gcc .Y -b .Y )};func (_geb Matrix )Transform (x ,y float64 )(float64 ,float64 ){_bf :=x *_geb [0]+y *_geb [3]+_geb [6];_ca :=x *_geb [1]+y *_geb [4]+_geb [7];return _bf ,_ca ;};func (_bb Matrix )Translate (tx ,ty float64 )Matrix {return NewMatrix (_bb [0],_bb [1],_bb [3],_bb [4],_bb [6]+tx ,_bb [7]+ty );};func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );};func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};