//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_b "fmt";_f "github.com/unidoc/unipdf/v3/common";_d "math";);func (_efb *Point )transformByMatrix (_gdfg Matrix ){_efb .X ,_efb .Y =_gdfg .Transform (_efb .X ,_efb .Y )};func (_a Matrix )Round (precision float64 )Matrix {for _bd :=range _a {_a [_bd ]=_d .Round (_a [_bd ]/precision )*precision ;};return _a ;};func RotationMatrix (angle float64 )Matrix {_g :=_d .Cos (angle );_be :=_d .Sin (angle );return NewMatrix (_g ,_be ,-_be ,_g ,0,0);};func (_aa Matrix )Mult (b Matrix )Matrix {_aa .Concat (b );return _aa };func (_gd Matrix )Translation ()(float64 ,float64 ){return _gd [6],_gd [7]};const _eff =1e9;func (_cbe Matrix )Unrealistic ()bool {_gfd ,_bgd ,_ab ,_bdg :=_d .Abs (_cbe [0]),_d .Abs (_cbe [1]),_d .Abs (_cbe [3]),_d .Abs (_cbe [4]);_ff :=_gfd > _bcc &&_bdg > _bcc ;_dae :=_bgd > _bcc &&_ab > _bcc ;return !(_ff ||_dae );};func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_bg :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};_bg .clampRange ();return _bg ;};func (_ged *Point )Set (x ,y float64 ){_ged .X ,_ged .Y =x ,y };func (_da *Matrix )Clone ()Matrix {return NewMatrix (_da [0],_da [1],_da [3],_da [4],_da [6],_da [7])};func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};const _bcc =1e-6;func (_fd Point )String ()string {return _b .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_fd .X ,_fd .Y );};func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};func (_fb Matrix )ScalingFactorX ()float64 {return _d .Hypot (_fb [0],_fb [1])};func (_ecc Point )Displace (delta Point )Point {return Point {_ecc .X +delta .X ,_ecc .Y +delta .Y }};func (_gdf Matrix )Angle ()float64 {_ec :=_d .Atan2 (-_gdf [1],_gdf [0]);if _ec < 0.0{_ec +=2*_d .Pi ;};return _ec /_d .Pi *180.0;};type Point struct{X float64 ;Y float64 ;};func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};func (_cf Matrix )Transform (x ,y float64 )(float64 ,float64 ){_gff :=x *_cf [0]+y *_cf [3]+_cf [6];_fg :=x *_cf [1]+y *_cf [4]+_cf [7];return _gff ,_fg ;};const _fce =1.0e-6;func (_cbd Point )Rotate (theta float64 )Point {_gcc :=_d .Hypot (_cbd .X ,_cbd .Y );_ebe :=_d .Atan2 (_cbd .Y ,_cbd .X );_ebc ,_bfa :=_d .Sincos (_ebe +theta /180.0*_d .Pi );return Point {_gcc *_bfa ,_gcc *_ebc };};func (_gf *Matrix )Concat (b Matrix ){*_gf =Matrix {b [0]*_gf [0]+b [1]*_gf [3],b [0]*_gf [1]+b [1]*_gf [4],0,b [3]*_gf [0]+b [4]*_gf [3],b [3]*_gf [1]+b [4]*_gf [4],0,b [6]*_gf [0]+b [7]*_gf [3]+_gf [6],b [6]*_gf [1]+b [7]*_gf [4]+_gf [7],1};_gf .clampRange ();};func (_cfg *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_edd :=NewMatrix (a ,b ,c ,d ,tx ,ty );_cfg .transformByMatrix (_edd );};type Matrix [9]float64 ;func (_cfa *Matrix )clampRange (){for _ge ,_eg :=range _cfa {if _eg > _eff {_f .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_eg ,_eff );_cfa [_ge ]=_eff ;}else if _eg < -_eff {_f .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_eg ,-_eff );_cfa [_ge ]=-_eff ;};};};func (_db *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_db [0],_db [1]=a ,b ;_db [3],_db [4]=c ,d ;_db [6],_db [7]=tx ,ty ;_db .clampRange ();};func (_bf Matrix )String ()string {_dd ,_dg ,_bc ,_ce ,_cb ,_fa :=_bf [0],_bf [1],_bf [3],_bf [4],_bf [6],_bf [7];return _b .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_dd ,_dg ,_bc ,_ce ,_cb ,_fa );};func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );};func (_fe Matrix )Scale (xScale ,yScale float64 )Matrix {return _fe .Mult (NewMatrix (xScale ,0,0,yScale ,0,0));};func (_gg Point )Distance (b Point )float64 {return _d .Hypot (_gg .X -b .X ,_gg .Y -b .Y )};func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};const _dc =1e-10;func (_gb Matrix )Singular ()bool {return _d .Abs (_gb [0]*_gb [4]-_gb [1]*_gb [3])< _dc };func (_ef *Matrix )Shear (x ,y float64 ){_ef .Concat (ShearMatrix (x ,y ))};func (_ca Matrix )Inverse ()(Matrix ,bool ){_ad ,_gcf :=_ca [0],_ca [1];_gcd ,_fc :=_ca [3],_ca [4];_cfd ,_ece :=_ca [6],_ca [7];_fba :=_ad *_fc -_gcf *_gcd ;if _d .Abs (_fba )< _fce {return Matrix {},false ;};_gbb ,_fec :=_fc /_fba ,-_gcf /_fba ;_ed ,_adc :=-_gcd /_fba ,_ad /_fba ;_cd :=-(_gbb *_cfd +_ed *_ece );_daa :=-(_fec *_cfd +_adc *_ece );return NewMatrix (_gbb ,_fec ,_ed ,_adc ,_cd ,_daa ),true ;};func (_eb Matrix )Translate (tx ,ty float64 )Matrix {return NewMatrix (_eb [0],_eb [1],_eb [3],_eb [4],_eb [6]+tx ,_eb [7]+ty );};func (_cg Matrix )ScalingFactorY ()float64 {return _d .Hypot (_cg [3],_cg [4])};func (_fge Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_fge .X +t *b .X ,Y :(1-t )*_fge .Y +t *b .Y };};func (_bdc Matrix )Rotate (theta float64 )Matrix {_e ,_gc :=_d .Sincos (theta /180.0*_d .Pi );return _bdc .Mult (NewMatrix (_gc ,-_e ,_e ,_gc ,0,0));};func (_bb Matrix )Identity ()bool {return _bb [0]==1&&_bb [1]==0&&_bb [2]==0&&_bb [3]==0&&_bb [4]==1&&_bb [5]==0&&_bb [6]==0&&_bb [7]==0&&_bb [8]==1;};