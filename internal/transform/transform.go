//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_gf "fmt";_e "github.com/unidoc/unipdf/v3/common";_c "math";);const _cgb =1e9;func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};func (_fg Matrix )ScalingFactorY ()float64 {return _c .Hypot (_fg [3],_fg [4])};
func (_da Matrix )Mult (b Matrix )Matrix {_da .Concat (b );return _da };func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};func (_df *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_df [0],_df [1]=a ,b ;_df [3],_df [4]=c ,d ;_df [6],_df [7]=tx ,ty ;
_df .clampRange ();};func (_ad Matrix )Angle ()float64 {_fe :=_c .Atan2 (-_ad [1],_ad [0]);if _fe < 0.0{_fe +=2*_c .Pi ;};return _fe /_c .Pi *180.0;};func (_gb *Matrix )Shear (x ,y float64 ){_gb .Concat (ShearMatrix (x ,y ))};func (_db Matrix )ScalingFactorX ()float64 {return _c .Hypot (_db [0],_db [1])};
func (_dfg Matrix )Translation ()(float64 ,float64 ){return _dfg [6],_dfg [7]};func (_gfc *Matrix )clampRange (){for _agd ,_bfe :=range _gfc {if _bfe > _cgb {_e .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_bfe ,_cgb );
_gfc [_agd ]=_cgb ;}else if _bfe < -_cgb {_e .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_bfe ,-_cgb );_gfc [_agd ]=-_cgb ;};};};func (_dc *Matrix )Clone ()Matrix {return NewMatrix (_dc [0],_dc [1],_dc [3],_dc [4],_dc [6],_dc [7])};
func (_dfd Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_dfd .X +t *b .X ,Y :(1-t )*_dfd .Y +t *b .Y };};func (_ga Matrix )Singular ()bool {return _c .Abs (_ga [0]*_ga [4]-_ga [1]*_ga [3])< _dfe };func (_bb *Matrix )Concat (b Matrix ){*_bb =Matrix {b [0]*_bb [0]+b [1]*_bb [3],b [0]*_bb [1]+b [1]*_bb [4],0,b [3]*_bb [0]+b [4]*_bb [3],b [3]*_bb [1]+b [4]*_bb [4],0,b [6]*_bb [0]+b [7]*_bb [3]+_bb [6],b [6]*_bb [1]+b [7]*_bb [4]+_bb [7],1};
_bb .clampRange ();};const _dfe =1e-10;func (_cfg Matrix )Inverse ()(Matrix ,bool ){_ce ,_cc :=_cfg [0],_cfg [1];_cg ,_ae :=_cfg [3],_cfg [4];_ab ,_ff :=_cfg [6],_cfg [7];_bae :=_ce *_ae -_cc *_cg ;if _c .Abs (_bae )< _bcf {return Matrix {},false ;};_fag ,_aeb :=_ae /_bae ,-_cc /_bae ;
_dd ,_ggb :=-_cg /_bae ,_ce /_bae ;_ca :=-(_fag *_ab +_dd *_ff );_bfae :=-(_aeb *_ab +_ggb *_ff );return NewMatrix (_fag ,_aeb ,_dd ,_ggb ,_ca ,_bfae ),true ;};func (_cec *Point )transformByMatrix (_gd Matrix ){_cec .X ,_cec .Y =_gd .Transform (_cec .X ,_cec .Y )};
func (_gbc Matrix )Unrealistic ()bool {_bc ,_gfa ,_dag ,_gae :=_c .Abs (_gbc [0]),_c .Abs (_gbc [1]),_c .Abs (_gbc [3]),_c .Abs (_gbc [4]);_fee :=_bc > _bd &&_gae > _bd ;_aag :=_gfa > _bd &&_dag > _bd ;return !(_fee ||_aag );};func (_agb Point )Displace (delta Point )Point {return Point {_agb .X +delta .X ,_agb .Y +delta .Y }};
func (_af *Point )Set (x ,y float64 ){_af .X ,_af .Y =x ,y };func (_bfc Matrix )String ()string {_a ,_d ,_ef ,_bfa ,_efd ,_ba :=_bfc [0],_bfc [1],_bfc [3],_bfc [4],_bfc [6],_bfc [7];return _gf .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_a ,_d ,_ef ,_bfa ,_efd ,_ba );
};func (_aa Matrix )Transform (x ,y float64 )(float64 ,float64 ){_fa :=x *_aa [0]+y *_aa [3]+_aa [6];_gg :=x *_aa [1]+y *_aa [4]+_aa [7];return _fa ,_gg ;};func (_dfc *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_aea :=NewMatrix (a ,b ,c ,d ,tx ,ty );
_dfc .transformByMatrix (_aea );};func (_efb Matrix )Rotate (theta float64 )Matrix {return _efb .Mult (RotationMatrix (theta ))};type Point struct{X float64 ;Y float64 ;};func (_fd Point )Rotate (theta float64 )Point {_bdg :=_c .Hypot (_fd .X ,_fd .Y );
_cfga :=_c .Atan2 (_fd .Y ,_fd .X );_gfd ,_bff :=_c .Sincos (_cfga +theta /180.0*_c .Pi );return Point {_bdg *_bff ,_bdg *_gfd };};func (_ag Matrix )Translate (tx ,ty float64 )Matrix {return _ag .Mult (TranslationMatrix (tx ,ty ))};func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};
func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );};func (_bgg Matrix )Identity ()bool {return _bgg [0]==1&&_bgg [1]==0&&_bgg [2]==0&&_bgg [3]==0&&_bgg [4]==1&&_bgg [5]==0&&_bgg [6]==0&&_bgg [7]==0&&_bgg [8]==1;
};func (_ec Point )Distance (b Point )float64 {return _c .Hypot (_ec .X -b .X ,_ec .Y -b .Y )};func (_b Matrix )Round (precision float64 )Matrix {for _bg :=range _b {_b [_bg ]=_c .Round (_b [_bg ]/precision )*precision ;};return _b ;};func (_cfb Point )String ()string {return _gf .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_cfb .X ,_cfb .Y );
};const _bcf =1.0e-6;func RotationMatrix (angle float64 )Matrix {_cf :=_c .Cos (angle );_f :=_c .Sin (angle );return NewMatrix (_cf ,_f ,-_f ,_cf ,0,0);};const _bd =1e-6;type Matrix [9]float64 ;func (_cb Matrix )Scale (xScale ,yScale float64 )Matrix {return _cb .Mult (ScaleMatrix (xScale ,yScale ))};
func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_bf :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};_bf .clampRange ();return _bf ;};