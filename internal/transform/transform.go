//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_d "fmt";_f "github.com/unidoc/unipdf/v3/common";_ee "math";);type Matrix [9]float64 ;func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_eg :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};
_eg .clampRange ();return _eg ;};func (_ff Matrix )ScalingFactorY ()float64 {return _ee .Hypot (_ff [3],_ff [4])};func (_agb *Matrix )Concat (b Matrix ){*_agb =Matrix {b [0]*_agb [0]+b [1]*_agb [3],b [0]*_agb [1]+b [1]*_agb [4],0,b [3]*_agb [0]+b [4]*_agb [3],b [3]*_agb [1]+b [4]*_agb [4],0,b [6]*_agb [0]+b [7]*_agb [3]+_agb [6],b [6]*_agb [1]+b [7]*_agb [4]+_agb [7],1};
_agb .clampRange ();};func (_cgf Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_cgf .X +t *b .X ,Y :(1-t )*_cgf .Y +t *b .Y };};func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};func (_ec Matrix )Angle ()float64 {_gd :=_ee .Atan2 (-_ec [1],_ec [0]);
if _gd < 0.0{_gd +=2*_ee .Pi ;};return _gd /_ee .Pi *180.0;};func (_gb *Matrix )Clone ()Matrix {return NewMatrix (_gb [0],_gb [1],_gb [3],_gb [4],_gb [6],_gb [7])};const _gf =1e-6;func (_fd Matrix )Translate (tx ,ty float64 )Matrix {return _fd .Mult (TranslationMatrix (tx ,ty ))};
func (_faa Matrix )ScalingFactorX ()float64 {return _ee .Hypot (_faa [0],_faa [1])};func (_be *Matrix )Shear (x ,y float64 ){_be .Concat (ShearMatrix (x ,y ))};type Point struct{X float64 ;Y float64 ;};const _ebc =1e-10;func RotationMatrix (angle float64 )Matrix {_fa :=_ee .Cos (angle );
_b :=_ee .Sin (angle );return NewMatrix (_fa ,_b ,-_b ,_fa ,0,0);};func (_dfga *Point )transformByMatrix (_gg Matrix ){_dfga .X ,_dfga .Y =_gg .Transform (_dfga .X ,_dfga .Y )};func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );
};func (_dbd Point )Rotate (theta float64 )Point {_fbb :=_ee .Hypot (_dbd .X ,_dbd .Y );_bgb :=_ee .Atan2 (_dbd .Y ,_dbd .X );_dff ,_fbg :=_ee .Sincos (_bgb +theta /180.0*_ee .Pi );return Point {_fbb *_fbg ,_fbb *_dff };};func (_a Matrix )Round (precision float64 )Matrix {for _ad :=range _a {_a [_ad ]=_ee .Round (_a [_ad ]/precision )*precision ;
};return _a ;};func (_cc Matrix )Unrealistic ()bool {_ceb ,_ebb ,_bga ,_gbd :=_ee .Abs (_cc [0]),_ee .Abs (_cc [1]),_ee .Abs (_cc [3]),_ee .Abs (_cc [4]);_ga :=_ceb > _gf &&_gbd > _gf ;_ddd :=_ebb > _gf &&_bga > _gf ;return !(_ga ||_ddd );};func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};
func (_df Matrix )Rotate (theta float64 )Matrix {return _df .Mult (RotationMatrix (theta ))};func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};func (_da Matrix )Mult (b Matrix )Matrix {_da .Concat (b );return _da };func (_fe Matrix )Singular ()bool {return _ee .Abs (_fe [0]*_fe [4]-_fe [1]*_fe [3])< _ebc };
func (_cd Matrix )Scale (xScale ,yScale float64 )Matrix {return _cd .Mult (ScaleMatrix (xScale ,yScale ))};func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};func (_ccf *Point )Set (x ,y float64 ){_ccf .X ,_ccf .Y =x ,y };func (_aa Matrix )Inverse ()(Matrix ,bool ){_ca ,_dd :=_aa [0],_aa [1];
_ce ,_fg :=_aa [3],_aa [4];_feb ,_fb :=_aa [6],_aa [7];_bg :=_ca *_fg -_dd *_ce ;if _ee .Abs (_bg )< _ac {return Matrix {},false ;};_ada ,_dg :=_fg /_bg ,-_dd /_bg ;_bea ,_eeb :=-_ce /_bg ,_ca /_bg ;_fdc :=-(_ada *_feb +_bea *_fb );_dbg :=-(_dg *_feb +_eeb *_fb );
return NewMatrix (_ada ,_dg ,_bea ,_eeb ,_fdc ,_dbg ),true ;};func (_g Matrix )String ()string {_ba ,_ag ,_c ,_agg ,_db ,_ea :=_g [0],_g [1],_g [3],_g [4],_g [6],_g [7];return _d .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_ba ,_ag ,_c ,_agg ,_db ,_ea );
};func (_ecf *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_fc :=NewMatrix (a ,b ,c ,d ,tx ,ty );_ecf .transformByMatrix (_fc );};func (_dae Point )Displace (delta Point )Point {return Point {_dae .X +delta .X ,_dae .Y +delta .Y }};func (_eb Matrix )Identity ()bool {return _eb [0]==1&&_eb [1]==0&&_eb [2]==0&&_eb [3]==0&&_eb [4]==1&&_eb [5]==0&&_eb [6]==0&&_eb [7]==0&&_eb [8]==1;
};func (_egb Matrix )Translation ()(float64 ,float64 ){return _egb [6],_egb [7]};const _ac =1.0e-6;func (_ecg Point )String ()string {return _d .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_ecg .X ,_ecg .Y );};func (_dc Matrix )Transform (x ,y float64 )(float64 ,float64 ){_cg :=x *_dc [0]+y *_dc [3]+_dc [6];
_bef :=x *_dc [1]+y *_dc [4]+_dc [7];return _cg ,_bef ;};const _afg =1e9;func (_af *Matrix )clampRange (){for _add ,_dfg :=range _af {if _dfg > _afg {_f .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_dfg ,_afg );
_af [_add ]=_afg ;}else if _dfg < -_afg {_f .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_dfg ,-_afg );_af [_add ]=-_afg ;};};};func (_ae *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_ae [0],_ae [1]=a ,b ;
_ae [3],_ae [4]=c ,d ;_ae [6],_ae [7]=tx ,ty ;_ae .clampRange ();};func (_fdcf Point )Distance (b Point )float64 {return _ee .Hypot (_fdcf .X -b .X ,_fdcf .Y -b .Y )};