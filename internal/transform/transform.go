//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_cb "fmt";_a "github.com/unidoc/unipdf/v3/common";_g "math";);func (_gc *Matrix )Shear (x ,y float64 ){_gc .Concat (ShearMatrix (x ,y ))};func (_ad *Matrix )Scale (x ,y float64 ){_ad .Concat (ScaleMatrix (x ,y ))};func (_cc Point )Displace (delta Point )Point {return Point {_cc .X +delta .X ,_cc .Y +delta .Y }};func (_eafg *Point )Set (x ,y float64 ){_eafg .X ,_eafg .Y =x ,y };func (_db *Point )transformByMatrix (_fff Matrix ){_db .X ,_db .Y =_fff .Transform (_db .X ,_db .Y )};func (_bg Point )String ()string {return _cb .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_bg .X ,_bg .Y );};type Point struct{X float64 ;Y float64 ;};func (_ge *Matrix )Translation ()(float64 ,float64 ){return _ge [6],_ge [7]};func (_ac *Matrix )Concat (b Matrix ){*_ac =Matrix {b [0]*_ac [0]+b [1]*_ac [3],b [0]*_ac [1]+b [1]*_ac [4],0,b [3]*_ac [0]+b [4]*_ac [3],b [3]*_ac [1]+b [4]*_ac [4],0,b [6]*_ac [0]+b [7]*_ac [3]+_ac [6],b [6]*_ac [1]+b [7]*_ac [4]+_ac [7],1};_ac .clampRange ();};func (_geg *Matrix )ScalingFactorX ()float64 {return _g .Hypot (_geg [0],_geg [1])};func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};func (_ca *Matrix )Translate (x ,y float64 ){_ca .Concat (TranslationMatrix (x ,y ))};func (_df *Matrix )clampRange (){for _dd ,_caf :=range _df {if _caf > _ce {_a .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_caf ,_ce );_df [_dd ]=_ce ;}else if _caf < -_ce {_a .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_caf ,-_ce );_df [_dd ]=-_ce ;};};};func (_fb *Matrix )Angle ()float64 {_eaf :=_g .Atan2 (-_fb [1],_fb [0]);if _eaf < 0.0{_eaf +=2*_g .Pi ;};return _eaf /_g .Pi *180.0;};func (_fe *Matrix )Transform (x ,y float64 )(float64 ,float64 ){_ab :=x *_fe [0]+y *_fe [1]+_fe [6];_adb :=x *_fe [3]+y *_fe [4]+_fe [7];return _ab ,_adb ;};func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};const _ggf =1.0e-6;func (_be *Matrix )Clone ()Matrix {return NewMatrix (_be [0],_be [1],_be [3],_be [4],_be [6],_be [7])};type Matrix [9]float64 ;func (_gcd Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_gcd .X +t *b .X ,Y :(1-t )*_gcd .Y +t *b .Y };};func (_ff *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_ff [0],_ff [1]=a ,b ;_ff [3],_ff [4]=c ,d ;_ff [6],_ff [7]=tx ,ty ;_ff .clampRange ();};func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_cg :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};_cg .clampRange ();return _cg ;};func (_ga *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_gbd :=NewMatrix (a ,b ,c ,d ,tx ,ty );_ga .transformByMatrix (_gbd );};const _ce =1e9;func (_af Point )Distance (b Point )float64 {return _g .Hypot (_af .X -b .X ,_af .Y -b .Y )};func (_ced Point )Rotate (theta float64 )Point {_fa :=_g .Hypot (_ced .X ,_ced .Y );_ba :=_g .Atan2 (_ced .Y ,_ced .X );_dae ,_dad :=_g .Sincos (_ba +theta /180.0*_g .Pi );return Point {_fa *_dad ,_fa *_dae };};func (_d Matrix )String ()string {_ea ,_cgd ,_f ,_fd ,_fg ,_ee :=_d [0],_d [1],_d [3],_d [4],_d [6],_d [7];return _cb .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_ea ,_cgd ,_f ,_fd ,_fg ,_ee );};func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};const _cba =1e-6;func (_b *Matrix )Rotate (angle float64 ){_b .Concat (RotationMatrix (angle ))};func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};func (_dfb *Matrix )Unrealistic ()bool {_da ,_gg ,_fga ,_bd :=_g .Abs (_dfb [0]),_g .Abs (_dfb [1]),_g .Abs (_dfb [3]),_g .Abs (_dfb [4]);_ddc :=_da > _cba &&_bd > _cba ;_ed :=_gg > _cba &&_fga > _cba ;return !(_ddc ||_ed );};func RotationMatrix (angle float64 )Matrix {_e :=_g .Cos (angle );_ae :=_g .Sin (angle );return NewMatrix (_e ,_ae ,-_ae ,_e ,0,0);};func (_gb *Matrix )ScalingFactorY ()float64 {return _g .Hypot (_gb [3],_gb [4])};func (_dg Matrix )Mult (b Matrix )Matrix {_dg .Concat (b );return _dg };func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};