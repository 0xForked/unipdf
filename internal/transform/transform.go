//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_d "fmt";_da "github.com/unidoc/unipdf/v3/common";_c "math";);func (_fb Matrix )Mult (b Matrix )Matrix {_fb .Concat (b );return _fb };func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};func (_fac Matrix )Transform (x ,y float64 )(float64 ,float64 ){_ad :=x *_fac [0]+y *_fac [3]+_fac [6];
_bg :=x *_fac [1]+y *_fac [4]+_fac [7];return _ad ,_bg ;};type Point struct{X float64 ;Y float64 ;};func (_cc *Matrix )Concat (b Matrix ){*_cc =Matrix {b [0]*_cc [0]+b [1]*_cc [3],b [0]*_cc [1]+b [1]*_cc [4],0,b [3]*_cc [0]+b [4]*_cc [3],b [3]*_cc [1]+b [4]*_cc [4],0,b [6]*_cc [0]+b [7]*_cc [3]+_cc [6],b [6]*_cc [1]+b [7]*_cc [4]+_cc [7],1};
_cc .clampRange ();};func (_gf Matrix )Singular ()bool {return _c .Abs (_gf [0]*_gf [4]-_gf [1]*_gf [3])< _fcf };func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};func (_bgc *Matrix )clampRange (){for _be ,_gfb :=range _bgc {if _gfb > _ga {_da .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_gfb ,_ga );
_bgc [_be ]=_ga ;}else if _gfb < -_ga {_da .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_gfb ,-_ga );_bgc [_be ]=-_ga ;};};};func (_f Matrix )Identity ()bool {return _f [0]==1&&_f [1]==0&&_f [2]==0&&_f [3]==0&&_f [4]==1&&_f [5]==0&&_f [6]==0&&_f [7]==0&&_f [8]==1;
};func (_bdf Matrix )ScalingFactorX ()float64 {return _c .Hypot (_bdf [0],_bdf [1])};func RotationMatrix (angle float64 )Matrix {_fe :=_c .Cos (angle );_gd :=_c .Sin (angle );return NewMatrix (_fe ,_gd ,-_gd ,_fe ,0,0);};func (_ca *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_de :=NewMatrix (a ,b ,c ,d ,tx ,ty );
_ca .transformByMatrix (_de );};func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};func (_fea Matrix )String ()string {_eg ,_cf ,_fa ,_fc ,_a ,_ce :=_fea [0],_fea [1],_fea [3],_fea [4],_fea [6],_fea [7];return _d .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_eg ,_cf ,_fa ,_fc ,_a ,_ce );
};func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_b :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};_b .clampRange ();return _b ;};func (_bd *Matrix )Shear (x ,y float64 ){_bd .Concat (ShearMatrix (x ,y ))};const _bgcd =1e-6;func (_ggg Matrix )Inverse ()(Matrix ,bool ){_bc ,_gc :=_ggg [0],_ggg [1];
_dc ,_ac :=_ggg [3],_ggg [4];_cfc ,_ggb :=_ggg [6],_ggg [7];_bge :=_bc *_ac -_gc *_dc ;if _c .Abs (_bge )< _fag {return Matrix {},false ;};_af ,_fbd :=_ac /_bge ,-_gc /_bge ;_cec ,_dg :=-_dc /_bge ,_bc /_bge ;_eb :=-(_af *_cfc +_cec *_ggb );_bab :=-(_fbd *_cfc +_dg *_ggb );
return NewMatrix (_af ,_fbd ,_cec ,_dg ,_eb ,_bab ),true ;};func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};func (_abc *Point )transformByMatrix (_eea Matrix ){_abc .X ,_abc .Y =_eea .Transform (_abc .X ,_abc .Y )};type Matrix [9]float64 ;
func (_ee *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_ee [0],_ee [1]=a ,b ;_ee [3],_ee [4]=c ,d ;_ee [6],_ee [7]=tx ,ty ;_ee .clampRange ();};func (_bee Matrix )Unrealistic ()bool {_ae ,_ff ,_gff ,_ceg :=_c .Abs (_bee [0]),_c .Abs (_bee [1]),_c .Abs (_bee [3]),_c .Abs (_bee [4]);
_fef :=_ae > _bgcd &&_ceg > _bgcd ;_fce :=_ff > _bgcd &&_gff > _bgcd ;return !(_fef ||_fce );};func (_ea Matrix )Translate (tx ,ty float64 )Matrix {return _ea .Mult (TranslationMatrix (tx ,ty ))};const _ga =1e9;func (_ade *Point )Set (x ,y float64 ){_ade .X ,_ade .Y =x ,y };
func (_cdg Matrix )ScalingFactorY ()float64 {return _c .Hypot (_cdg [3],_cdg [4])};const _fag =1.0e-6;func (_ge Point )Rotate (theta float64 )Point {_acd :=_c .Hypot (_ge .X ,_ge .Y );_ega :=_c .Atan2 (_ge .Y ,_ge .X );_ab ,_dce :=_c .Sincos (_ega +theta /180.0*_c .Pi );
return Point {_acd *_dce ,_acd *_ab };};func (_ed Matrix )Translation ()(float64 ,float64 ){return _ed [6],_ed [7]};func (_e Matrix )Round (precision float64 )Matrix {for _cd :=range _e {_e [_cd ]=_c .Round (_e [_cd ]/precision )*precision ;};return _e ;
};func (_ec Matrix )Rotate (theta float64 )Matrix {return _ec .Mult (RotationMatrix (theta ))};func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );
};func (_ba Matrix )Angle ()float64 {_gg :=_c .Atan2 (-_ba [1],_ba [0]);if _gg < 0.0{_gg +=2*_c .Pi ;};return _gg /_c .Pi *180.0;};func (_bb *Matrix )Clone ()Matrix {return NewMatrix (_bb [0],_bb [1],_bb [3],_bb [4],_bb [6],_bb [7])};func (_bdc Point )Displace (delta Point )Point {return Point {_bdc .X +delta .X ,_bdc .Y +delta .Y }};
func (_cb Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_cb .X +t *b .X ,Y :(1-t )*_cb .Y +t *b .Y };};func (_fed Matrix )Scale (xScale ,yScale float64 )Matrix {return _fed .Mult (ScaleMatrix (xScale ,yScale ));};func (_df Point )Distance (b Point )float64 {return _c .Hypot (_df .X -b .X ,_df .Y -b .Y )};
const _fcf =1e-10;func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};func (_afa Point )String ()string {return _d .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_afa .X ,_afa .Y );};