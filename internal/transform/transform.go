//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_e "fmt";_d "github.com/unidoc/unipdf/v3/common";_b "math";);func (_bag Point )Displace (delta Point )Point {return Point {_bag .X +delta .X ,_bag .Y +delta .Y }};func (_g Matrix )Round (precision float64 )Matrix {for _dg :=range _g {_g [_dg ]=_b .Round (_g [_dg ]/precision )*precision ;};return _g ;};func RotationMatrix (angle float64 )Matrix {_a :=_b .Cos (angle );_fg :=_b .Sin (angle );return NewMatrix (_a ,_fg ,-_fg ,_a ,0,0);};func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};func (_df *Matrix )Clone ()Matrix {return NewMatrix (_df [0],_df [1],_df [3],_df [4],_df [6],_df [7])};func (_eed Matrix )Translation ()(float64 ,float64 ){return _eed [6],_eed [7]};func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};const _cb =1e-6;const _beg =1e9;func (_caf Matrix )Unrealistic ()bool {_fbe ,_acf ,_dca ,_faf :=_b .Abs (_caf [0]),_b .Abs (_caf [1]),_b .Abs (_caf [3]),_b .Abs (_caf [4]);_bf :=_fbe > _cb &&_faf > _cb ;_egc :=_acf > _cb &&_dca > _cb ;return !(_bf ||_egc );};func (_bgd Matrix )ScalingFactorY ()float64 {return _b .Hypot (_bgd [3],_bgd [4])};func (_fb Matrix )Angle ()float64 {_ab :=_b .Atan2 (-_fb [1],_fb [0]);if _ab < 0.0{_ab +=2*_b .Pi ;};return _ab /_b .Pi *180.0;};func (_be Matrix )Inverse ()(Matrix ,bool ){_gd ,_ba :=_be [0],_be [1];_fa ,_fgd :=_be [3],_be [4];_de ,_ae :=_be [6],_be [7];_aab :=_gd *_fgd -_ba *_fa ;if _b .Abs (_aab )< _fe {return Matrix {},false ;};_dae ,_dc :=_fgd /_aab ,-_ba /_aab ;_db ,_ace :=-_fa /_aab ,_gd /_aab ;_bec :=-(_dae *_de +_db *_ae );_cc :=-(_dc *_de +_ace *_ae );return NewMatrix (_dae ,_dc ,_db ,_ace ,_bec ,_cc ),true ;};const _fe =1.0e-6;func (_aed *Point )Set (x ,y float64 ){_aed .X ,_aed .Y =x ,y };type Point struct{X float64 ;Y float64 ;};func (_ac Matrix )Scale (xScale ,yScale float64 )Matrix {return _ac .Mult (NewMatrix (xScale ,0,0,yScale ,0,0));};func (_gdf *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_abc :=NewMatrix (a ,b ,c ,d ,tx ,ty );_gdf .transformByMatrix (_abc );};type Matrix [9]float64 ;func (_da *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_da [0],_da [1]=a ,b ;_da [3],_da [4]=c ,d ;_da [6],_da [7]=tx ,ty ;_da .clampRange ();};func (_ce Matrix )Singular ()bool {return _b .Abs (_ce [0]*_ce [4]-_ce [1]*_ce [3])< _gf };func (_dfd Matrix )Transform (x ,y float64 )(float64 ,float64 ){_fga :=x *_dfd [0]+y *_dfd [3]+_dfd [6];_eb :=x *_dfd [1]+y *_dfd [4]+_dfd [7];return _fga ,_eb ;};func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};func (_fc Matrix )String ()string {_ga ,_ee ,_cfc ,_cd ,_ca ,_eg :=_fc [0],_fc [1],_fc [3],_fc [4],_fc [6],_fc [7];return _e .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_ga ,_ee ,_cfc ,_cd ,_ca ,_eg );};func (_ag Matrix )Translate (tx ,ty float64 )Matrix {return NewMatrix (_ag [0],_ag [1],_ag [3],_ag [4],_ag [6]+tx ,_ag [7]+ty );};func (_eeg Point )String ()string {return _e .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_eeg .X ,_eeg .Y );};func (_dba Point )Distance (b Point )float64 {return _b .Hypot (_dba .X -b .X ,_dba .Y -b .Y )};func (_gg *Matrix )Shear (x ,y float64 ){_gg .Concat (ShearMatrix (x ,y ))};func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};func (_eea *Matrix )Concat (b Matrix ){*_eea =Matrix {b [0]*_eea [0]+b [1]*_eea [3],b [0]*_eea [1]+b [1]*_eea [4],0,b [3]*_eea [0]+b [4]*_eea [3],b [3]*_eea [1]+b [4]*_eea [4],0,b [6]*_eea [0]+b [7]*_eea [3]+_eea [6],b [6]*_eea [1]+b [7]*_eea [4]+_eea [7],1};_eea .clampRange ();};func (_fd *Matrix )clampRange (){for _dfa ,_dd :=range _fd {if _dd > _beg {_d .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_dd ,_beg );_fd [_dfa ]=_beg ;}else if _dd < -_beg {_d .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_dd ,-_beg );_fd [_dfa ]=-_beg ;};};};func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_cf :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};_cf .clampRange ();return _cf ;};func (_fdbg Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_fdbg .X +t *b .X ,Y :(1-t )*_fdbg .Y +t *b .Y };};func (_fdb Point )Rotate (theta float64 )Point {_dda :=_b .Hypot (_fdb .X ,_fdb .Y );_bc :=_b .Atan2 (_fdb .Y ,_fdb .X );_ceg ,_fdg :=_b .Sincos (_bc +theta /180.0*_b .Pi );return Point {_dda *_fdg ,_dda *_ceg };};func (_cdf Matrix )Mult (b Matrix )Matrix {_cdf .Concat (b );return _cdf };func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );};func (_aa Matrix )ScalingFactorX ()float64 {return _b .Hypot (_aa [0],_aa [1])};func (_bd Matrix )Rotate (theta float64 )Matrix {_ge ,_bg :=_b .Sincos (theta /180.0*_b .Pi );return _bd .Mult (NewMatrix (_bg ,-_ge ,_ge ,_bg ,0,0));};const _gf =1e-10;func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};func (_ef *Point )transformByMatrix (_ddd Matrix ){_ef .X ,_ef .Y =_ddd .Transform (_ef .X ,_ef .Y )};func (_f Matrix )Identity ()bool {return _f [0]==1&&_f [1]==0&&_f [2]==0&&_f [3]==0&&_f [4]==1&&_f [5]==0&&_f [6]==0&&_f [7]==0&&_f [8]==1;};