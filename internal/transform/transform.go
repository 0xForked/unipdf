//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_f "fmt";_e "github.com/unidoc/unipdf/v3/common";_a "math";);func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};func (_fb *Matrix )Shear (x ,y float64 ){_fb .Concat (ShearMatrix (x ,y ))};func (_da Point )Rotate (theta float64 )Point {_dbc :=_a .Hypot (_da .X ,_da .Y );_adg :=_a .Atan2 (_da .Y ,_da .X );_acc ,_ge :=_a .Sincos (_adg +theta /180.0*_a .Pi );return Point {_dbc *_ge ,_dbc *_acc };};const _efa =1.0e-6;func (_ae Matrix )Rotate (theta float64 )Matrix {_fe ,_gg :=_a .Sincos (theta /180.0*_a .Pi );return _ae .Mult (NewMatrix (_gg ,-_fe ,_fe ,_gg ,0,0));};func (_ege Matrix )ScalingFactorX ()float64 {return _a .Hypot (_ege [0],_ege [1])};func (_bfd Matrix )Singular ()bool {return _a .Abs (_bfd [0]*_bfd [4]-_bfd [1]*_bfd [3])< _db };func (_bc Matrix )Mult (b Matrix )Matrix {_bc .Concat (b );return _bc };const _db =1e-10;func RotationMatrix (angle float64 )Matrix {_eg :=_a .Cos (angle );_ed :=_a .Sin (angle );return NewMatrix (_eg ,_ed ,-_ed ,_eg ,0,0);};func (_ab Matrix )Inverse ()(Matrix ,bool ){_bg ,_efef :=_ab [0],_ab [1];_ad ,_ebd :=_ab [3],_ab [4];_gcg ,_de :=_ab [6],_ab [7];_dc :=_bg *_ebd -_efef *_ad ;if _a .Abs (_dc )< _efa {return Matrix {},false ;};_aed ,_gae :=_ebd /_dc ,-_efef /_dc ;_cf ,_gad :=-_ad /_dc ,_bg /_dc ;_bb :=-(_aed *_gcg +_cf *_de );_ea :=-(_gae *_gcg +_gad *_de );return NewMatrix (_aed ,_gae ,_cf ,_gad ,_bb ,_ea ),true ;};func (_dcg *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_agf :=NewMatrix (a ,b ,c ,d ,tx ,ty );_dcg .transformByMatrix (_agf );};func (_ggd Matrix )Unrealistic ()bool {_cd ,_fc ,_ca ,_cc :=_a .Abs (_ggd [0]),_a .Abs (_ggd [1]),_a .Abs (_ggd [3]),_a .Abs (_ggd [4]);_af :=_cd > _bca &&_cc > _bca ;_bd :=_fc > _bca &&_ca > _bca ;return !(_af ||_bd );};func (_cb *Matrix )clampRange (){for _bff ,_ee :=range _cb {if _ee > _agg {_e .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_ee ,_agg );_cb [_bff ]=_agg ;}else if _ee < -_agg {_e .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_ee ,-_agg );_cb [_bff ]=-_agg ;};};};func (_fa Matrix )Transform (x ,y float64 )(float64 ,float64 ){_bcf :=x *_fa [0]+y *_fa [3]+_fa [6];_gaa :=x *_fa [1]+y *_fa [4]+_fa [7];return _bcf ,_gaa ;};func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );};func (_eea *Point )Set (x ,y float64 ){_eea .X ,_eea .Y =x ,y };func (_cbb Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_cbb .X +t *b .X ,Y :(1-t )*_cbb .Y +t *b .Y };};type Point struct{X float64 ;Y float64 ;};func (_acg Point )String ()string {return _f .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_acg .X ,_acg .Y );};func (_ac *Matrix )Concat (b Matrix ){*_ac =Matrix {b [0]*_ac [0]+b [1]*_ac [3],b [0]*_ac [1]+b [1]*_ac [4],0,b [3]*_ac [0]+b [4]*_ac [3],b [3]*_ac [1]+b [4]*_ac [4],0,b [6]*_ac [0]+b [7]*_ac [3]+_ac [6],b [6]*_ac [1]+b [7]*_ac [4]+_ac [7],1};_ac .clampRange ();};func (_ba *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_ba [0],_ba [1]=a ,b ;_ba [3],_ba [4]=c ,d ;_ba [6],_ba [7]=tx ,ty ;_ba .clampRange ();};func (_gab *Point )transformByMatrix (_abe Matrix ){_gab .X ,_gab .Y =_abe .Transform (_gab .X ,_gab .Y )};const _agg =1e9;func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};func (_dad Point )Distance (b Point )float64 {return _a .Hypot (_dad .X -b .X ,_dad .Y -b .Y )};func (_bf Matrix )Translate (tx ,ty float64 )Matrix {return NewMatrix (_bf [0],_bf [1],_bf [3],_bf [4],_bf [6]+tx ,_bf [7]+ty );};func (_g Matrix )String ()string {_ef ,_gb ,_eb ,_b ,_efg ,_ga :=_g [0],_g [1],_g [3],_g [4],_g [6],_g [7];return _f .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_ef ,_gb ,_eb ,_b ,_efg ,_ga );};func (_cdd Point )Displace (delta Point )Point {return Point {_cdd .X +delta .X ,_cdd .Y +delta .Y }};func (_ec Matrix )Scale (xScale ,yScale float64 )Matrix {return _ec .Mult (NewMatrix (xScale ,0,0,yScale ,0,0));};const _bca =1e-6;type Matrix [9]float64 ;func (_aa *Matrix )Clone ()Matrix {return NewMatrix (_aa [0],_aa [1],_aa [3],_aa [4],_aa [6],_aa [7])};func (_d Matrix )Translation ()(float64 ,float64 ){return _d [6],_d [7]};func (_bcb Matrix )Angle ()float64 {_gc :=_a .Atan2 (-_bcb [1],_bcb [0]);if _gc < 0.0{_gc +=2*_a .Pi ;};return _gc /_a .Pi *180.0;};func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};func (_efe Matrix )ScalingFactorY ()float64 {return _a .Hypot (_efe [3],_efe [4])};func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_ag :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};_ag .clampRange ();return _ag ;};