//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_g "fmt";_a "github.com/unidoc/unipdf/v3/common";_e "math";);const _ece =1e9;func (_bfb *Point )transformByMatrix (_bba Matrix ){_bfb .X ,_bfb .Y =_bba .Transform (_bfb .X ,_bfb .Y )};func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};func (_gaf Point )Rotate (theta float64 )Point {_fadd :=_e .Hypot (_gaf .X ,_gaf .Y );_dgb :=_e .Atan2 (_gaf .Y ,_gaf .X );_dbg ,_gca :=_e .Sincos (_dgb +theta /180.0*_e .Pi );return Point {_fadd *_gca ,_fadd *_dbg };};func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};func (_ac Matrix )String ()string {_f ,_gc ,_gf ,_b ,_bb ,_ge :=_ac [0],_ac [1],_ac [3],_ac [4],_ac [6],_ac [7];return _g .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_f ,_gc ,_gf ,_b ,_bb ,_ge );};func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};func (_bf Matrix )Translation ()(float64 ,float64 ){return _bf [6],_bf [7]};func (_gfdc Point )String ()string {return _g .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_gfdc .X ,_gfdc .Y );};func (_gd Matrix )Mult (b Matrix )Matrix {_gd .Concat (b );return _gd };func (_gcd Point )Displace (delta Point )Point {return Point {_gcd .X +delta .X ,_gcd .Y +delta .Y }};func (_cgf *Matrix )clampRange (){for _fee ,_ecb :=range _cgf {if _ecb > _ece {_a .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_ecb ,_ece );_cgf [_fee ]=_ece ;}else if _ecb < -_ece {_a .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_ecb ,-_ece );_cgf [_fee ]=-_ece ;};};};type Point struct{X float64 ;Y float64 ;};func (_ad *Matrix )Clone ()Matrix {return NewMatrix (_ad [0],_ad [1],_ad [3],_ad [4],_ad [6],_ad [7])};func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};const _aag =1.0e-6;func (_cg Matrix )Scale (xScale ,yScale float64 )Matrix {return _cg .Mult (NewMatrix (xScale ,0,0,yScale ,0,0));};func (_bd Matrix )ScalingFactorY ()float64 {return _e .Hypot (_bd [3],_bd [4])};func (_bgd *Point )Set (x ,y float64 ){_bgd .X ,_bgd .Y =x ,y };func (_fc Matrix )ScalingFactorX ()float64 {return _e .Hypot (_fc [0],_fc [1])};type Matrix [9]float64 ;func (_eff Matrix )Unrealistic ()bool {_be ,_ga ,_dgg ,_fad :=_e .Abs (_eff [0]),_e .Abs (_eff [1]),_e .Abs (_eff [3]),_e .Abs (_eff [4]);_gfd :=_be > _ddf &&_fad > _ddf ;_bc :=_ga > _ddf &&_dgg > _ddf ;return !(_gfd ||_bc );};func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );};func (_dgc Point )Distance (b Point )float64 {return _e .Hypot (_dgc .X -b .X ,_dgc .Y -b .Y )};func RotationMatrix (angle float64 )Matrix {_ab :=_e .Cos (angle );_dg :=_e .Sin (angle );return NewMatrix (_ab ,_dg ,-_dg ,_ab ,0,0);};func (_cd *Matrix )Concat (b Matrix ){*_cd =Matrix {b [0]*_cd [0]+b [1]*_cd [3],b [0]*_cd [1]+b [1]*_cd [4],0,b [3]*_cd [0]+b [4]*_cd [3],b [3]*_cd [1]+b [4]*_cd [4],0,b [6]*_cd [0]+b [7]*_cd [3]+_cd [6],b [6]*_cd [1]+b [7]*_cd [4]+_cd [7],1};_cd .clampRange ();};func (_fga Matrix )Angle ()float64 {_bg :=_e .Atan2 (-_fga [1],_fga [0]);if _bg < 0.0{_bg +=2*_e .Pi ;};return _bg /_e .Pi *180.0;};func (_dcb Matrix )Transform (x ,y float64 )(float64 ,float64 ){_df :=x *_dcb [0]+y *_dcb [3]+_dcb [6];_abe :=x *_dcb [1]+y *_dcb [4]+_dcb [7];return _df ,_abe ;};const _ddf =1e-6;func (_aa Matrix )Translate (tx ,ty float64 )Matrix {return NewMatrix (_aa [0],_aa [1],_aa [3],_aa [4],_aa [6]+tx ,_aa [7]+ty );};func (_dc Matrix )Rotate (theta float64 )Matrix {_fe ,_dgd :=_e .Sincos (theta /180.0*_e .Pi );return _dc .Mult (NewMatrix (_dgd ,-_fe ,_fe ,_dgd ,0,0));};func (_ea Matrix )Inverse ()(Matrix ,bool ){_dd ,_adg :=_ea [0],_ea [1];_cf ,_bdb :=_ea [3],_ea [4];_cb ,_fbe :=_ea [6],_ea [7];_cdc :=_dd *_bdb -_adg *_cf ;if _e .Abs (_cdc )< _aag {return Matrix {},false ;};_ec ,_fa :=_bdb /_cdc ,-_adg /_cdc ;_abed ,_de :=-_cf /_cdc ,_dd /_cdc ;_ef :=-(_ec *_cb +_abed *_fbe );_af :=-(_fa *_cb +_de *_fbe );return NewMatrix (_ec ,_fa ,_abed ,_de ,_ef ,_af ),true ;};func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_c :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};_c .clampRange ();return _c ;};func (_db *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_eg :=NewMatrix (a ,b ,c ,d ,tx ,ty );_db .transformByMatrix (_eg );};func (_dff Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_dff .X +t *b .X ,Y :(1-t )*_dff .Y +t *b .Y };};func (_fg *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_fg [0],_fg [1]=a ,b ;_fg [3],_fg [4]=c ,d ;_fg [6],_fg [7]=tx ,ty ;_fg .clampRange ();};func (_fb *Matrix )Shear (x ,y float64 ){_fb .Concat (ShearMatrix (x ,y ))};