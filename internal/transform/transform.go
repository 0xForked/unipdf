//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_bb "fmt";_bbf "github.com/unidoc/unipdf/v3/common";_bf "math";);func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};func (_bdf *Point )Set (x ,y float64 ){_bdf .X ,_bdf .Y =x ,y };func (_cbe Matrix )Angle ()float64 {_dag :=_bf .Atan2 (-_cbe [1],_cbe [0]);
if _dag < 0.0{_dag +=2*_bf .Pi ;};return _dag /_bf .Pi *180.0;};func (_gdfd Point )String ()string {return _bb .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_gdfd .X ,_gdfd .Y );};const _be =1e9;func (_dc Point )Distance (b Point )float64 {return _bf .Hypot (_dc .X -b .X ,_dc .Y -b .Y )};
func (_fdf Matrix )Rotate (theta float64 )Matrix {return _fdf .Mult (RotationMatrix (theta ))};func (_gdg Matrix )Translation ()(float64 ,float64 ){return _gdg [6],_gdg [7]};func (_daa *Matrix )Clone ()Matrix {return NewMatrix (_daa [0],_daa [1],_daa [3],_daa [4],_daa [6],_daa [7]);
};func (_g Matrix )Round (precision float64 )Matrix {for _e :=range _g {_g [_e ]=_bf .Round (_g [_e ]/precision )*precision ;};return _g ;};const _gb =1e-10;const _cg =1.0e-6;func (_ec *Matrix )clampRange (){for _ed ,_ce :=range _ec {if _ce > _be {_bbf .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_ce ,_be );
_ec [_ed ]=_be ;}else if _ce < -_be {_bbf .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_ce ,-_be );_ec [_ed ]=-_be ;};};};func (_eg Matrix )Identity ()bool {return _eg [0]==1&&_eg [1]==0&&_eg [2]==0&&_eg [3]==0&&_eg [4]==1&&_eg [5]==0&&_eg [6]==0&&_eg [7]==0&&_eg [8]==1;
};func (_ab Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_ab .X +t *b .X ,Y :(1-t )*_ab .Y +t *b .Y };};func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );
};func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_ef :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};_ef .clampRange ();return _ef ;};func (_ea Point )Displace (delta Point )Point {return Point {_ea .X +delta .X ,_ea .Y +delta .Y }};func (_gcg *Point )transformByMatrix (_ced Matrix ){_gcg .X ,_gcg .Y =_ced .Transform (_gcg .X ,_gcg .Y )};
func (_fg Matrix )Singular ()bool {return _bf .Abs (_fg [0]*_fg [4]-_fg [1]*_fg [3])< _gb };func (_efa Matrix )Inverse ()(Matrix ,bool ){_cad ,_gbc :=_efa [0],_efa [1];_bd ,_bde :=_efa [3],_efa [4];_bg ,_bc :=_efa [6],_efa [7];_dbf :=_cad *_bde -_gbc *_bd ;
if _bf .Abs (_dbf )< _cg {return Matrix {},false ;};_dbb ,_bge :=_bde /_dbf ,-_gbc /_dbf ;_ega ,_aa :=-_bd /_dbf ,_cad /_dbf ;_dbfc :=-(_dbb *_bg +_ega *_bc );_egd :=-(_bge *_bg +_aa *_bc );return NewMatrix (_dbb ,_bge ,_ega ,_aa ,_dbfc ,_egd ),true ;};
func (_ceg *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_eged :=NewMatrix (a ,b ,c ,d ,tx ,ty );_ceg .transformByMatrix (_eged );};func (_edb Point )Rotate (theta float64 )Point {_ge :=_bf .Hypot (_edb .X ,_edb .Y );_aeg :=_bf .Atan2 (_edb .Y ,_edb .X );
_caa ,_gc :=_bf .Sincos (_aeg +theta /180.0*_bf .Pi );return Point {_ge *_gc ,_ge *_caa };};func (_df *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_df [0],_df [1]=a ,b ;_df [3],_df [4]=c ,d ;_df [6],_df [7]=tx ,ty ;_df .clampRange ();};type Point struct{X float64 ;
Y float64 ;};func (_bfg Matrix )ScalingFactorY ()float64 {return _bf .Hypot (_bfg [3],_bfg [4])};func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};func (_gd Matrix )Mult (b Matrix )Matrix {_gd .Concat (b );return _gd };
const _cc =1e-6;func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};func (_gf Matrix )Scale (xScale ,yScale float64 )Matrix {return _gf .Mult (ScaleMatrix (xScale ,yScale ))};func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};
func (_ba *Matrix )Shear (x ,y float64 ){_ba .Concat (ShearMatrix (x ,y ))};func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};func (_cb Matrix )Translate (tx ,ty float64 )Matrix {return _cb .Mult (TranslationMatrix (tx ,ty ))};func (_ff Matrix )ScalingFactorX ()float64 {return _bf .Hypot (_ff [0],_ff [1])};
func (_da Matrix )String ()string {_bbfg ,_c ,_fd ,_db ,_ga ,_ee :=_da [0],_da [1],_da [3],_da [4],_da [6],_da [7];return _bb .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_bbfg ,_c ,_fd ,_db ,_ga ,_ee );
};func (_ca Matrix )Transform (x ,y float64 )(float64 ,float64 ){_gdf :=x *_ca [0]+y *_ca [3]+_ca [6];_af :=x *_ca [1]+y *_ca [4]+_ca [7];return _gdf ,_af ;};func (_a *Matrix )Concat (b Matrix ){*_a =Matrix {b [0]*_a [0]+b [1]*_a [3],b [0]*_a [1]+b [1]*_a [4],0,b [3]*_a [0]+b [4]*_a [3],b [3]*_a [1]+b [4]*_a [4],0,b [6]*_a [0]+b [7]*_a [3]+_a [6],b [6]*_a [1]+b [7]*_a [4]+_a [7],1};
_a .clampRange ();};type Matrix [9]float64 ;func (_ege Matrix )Unrealistic ()bool {_ae ,_fgb ,_eb ,_ag :=_bf .Abs (_ege [0]),_bf .Abs (_ege [1]),_bf .Abs (_ege [3]),_bf .Abs (_ege [4]);_ad :=_ae > _cc &&_ag > _cc ;_bgf :=_fgb > _cc &&_eb > _cc ;return !(_ad ||_bgf );
};func RotationMatrix (angle float64 )Matrix {_f :=_bf .Cos (angle );_d :=_bf .Sin (angle );return NewMatrix (_f ,_d ,-_d ,_f ,0,0);};