//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_d "fmt";_fc "github.com/unidoc/unipdf/v3/common";_f "math";);func (_cgf Matrix )Translate (tx ,ty float64 )Matrix {return _cgf .Mult (TranslationMatrix (tx ,ty ))};func (_bb Matrix )Unrealistic ()bool {_gdc ,_cge ,_df ,_ed :=_f .Abs (_bb [0]),_f .Abs (_bb [1]),_f .Abs (_bb [3]),_f .Abs (_bb [4]);
_cgfc :=_gdc > _edb &&_ed > _edb ;_fce :=_cge > _edb &&_df > _edb ;return !(_cgfc ||_fce );};func (_fcd *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_aca :=NewMatrix (a ,b ,c ,d ,tx ,ty );_fcd .transformByMatrix (_aca );};func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};
func (_e Matrix )Round (precision float64 )Matrix {for _a :=range _e {_e [_a ]=_f .Round (_e [_a ]/precision )*precision ;};return _e ;};func RotationMatrix (angle float64 )Matrix {_b :=_f .Cos (angle );_fg :=_f .Sin (angle );return NewMatrix (_b ,_fg ,-_fg ,_b ,0,0);
};func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};type Matrix [9]float64 ;func (_faa Matrix )String ()string {_ee ,_eb ,_ac ,_g ,_bg ,_ba :=_faa [0],_faa [1],_faa [3],_faa [4],_faa [6],_faa [7];
return _d .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_ee ,_eb ,_ac ,_g ,_bg ,_ba );};
func (_ggf *Point )transformByMatrix (_cgd Matrix ){_ggf .X ,_ggf .Y =_cgd .Transform (_ggf .X ,_ggf .Y )};func (_cc Matrix )Scale (xScale ,yScale float64 )Matrix {return _cc .Mult (ScaleMatrix (xScale ,yScale ))};func (_ad Matrix )Rotate (theta float64 )Matrix {return _ad .Mult (RotationMatrix (theta ))};
func (_eg *Matrix )Concat (b Matrix ){*_eg =Matrix {b [0]*_eg [0]+b [1]*_eg [3],b [0]*_eg [1]+b [1]*_eg [4],0,b [3]*_eg [0]+b [4]*_eg [3],b [3]*_eg [1]+b [4]*_eg [4],0,b [6]*_eg [0]+b [7]*_eg [3]+_eg [6],b [6]*_eg [1]+b [7]*_eg [4]+_eg [7],1};_eg .clampRange ();
};func (_cd Matrix )Inverse ()(Matrix ,bool ){_bd ,_dc :=_cd [0],_cd [1];_ec ,_cec :=_cd [3],_cd [4];_ff ,_ebf :=_cd [6],_cd [7];_aeg :=_bd *_cec -_dc *_ec ;if _f .Abs (_aeg )< _fge {return Matrix {},false ;};_cb ,_ab :=_cec /_aeg ,-_dc /_aeg ;_cf ,_cff :=-_ec /_aeg ,_bd /_aeg ;
_dcc :=-(_cb *_ff +_cf *_ebf );_gcf :=-(_ab *_ff +_cff *_ebf );return NewMatrix (_cb ,_ab ,_cf ,_cff ,_dcc ,_gcf ),true ;};const _gdcf =1e9;func (_abd Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_abd .X +t *b .X ,Y :(1-t )*_abd .Y +t *b .Y };
};func (_ce Matrix )Singular ()bool {return _f .Abs (_ce [0]*_ce [4]-_ce [1]*_ce [3])< _ddg };func (_gbb Matrix )Angle ()float64 {_gc :=_f .Atan2 (-_gbb [1],_gbb [0]);if _gc < 0.0{_gc +=2*_f .Pi ;};return _gc /_f .Pi *180.0;};const _ddg =1e-10;type Point struct{X float64 ;
Y float64 ;};func (_fcf Point )Distance (b Point )float64 {return _f .Hypot (_fcf .X -b .X ,_fcf .Y -b .Y )};func (_cga Matrix )ScalingFactorY ()float64 {return _f .Hypot (_cga [3],_cga [4])};func (_dd Matrix )Mult (b Matrix )Matrix {_dd .Concat (b );return _dd };
func (_cee Point )Rotate (theta float64 )Point {_abf :=_f .Hypot (_cee .X ,_cee .Y );_cdg :=_f .Atan2 (_cee .Y ,_cee .X );_db ,_ede :=_f .Sincos (_cdg +theta /180.0*_f .Pi );return Point {_abf *_ede ,_abf *_db };};func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};
func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );};func (_ef Matrix )Transform (x ,y float64 )(float64 ,float64 ){_ebg :=x *_ef [0]+y *_ef [3]+_ef [6];
_ca :=x *_ef [1]+y *_ef [4]+_ef [7];return _ebg ,_ca ;};func (_egd Point )Displace (delta Point )Point {return Point {_egd .X +delta .X ,_egd .Y +delta .Y }};func (_ece Point )String ()string {return _d .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_ece .X ,_ece .Y );
};func (_gg *Point )Set (x ,y float64 ){_gg .X ,_gg .Y =x ,y };const _fge =1.0e-6;func (_cg *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_cg [0],_cg [1]=a ,b ;_cg [3],_cg [4]=c ,d ;_cg [6],_cg [7]=tx ,ty ;_cg .clampRange ();};func (_ddb *Matrix )Clone ()Matrix {return NewMatrix (_ddb [0],_ddb [1],_ddb [3],_ddb [4],_ddb [6],_ddb [7]);
};const _edb =1e-6;func (_fe Matrix )Translation ()(float64 ,float64 ){return _fe [6],_fe [7]};func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_ae :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};_ae .clampRange ();return _ae ;};func (_fa Matrix )Identity ()bool {return _fa [0]==1&&_fa [1]==0&&_fa [2]==0&&_fa [3]==0&&_fa [4]==1&&_fa [5]==0&&_fa [6]==0&&_fa [7]==0&&_fa [8]==1;
};func (_cdc *Matrix )clampRange (){for _af ,_gdg :=range _cdc {if _gdg > _gdcf {_fc .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_gdg ,_gdcf );_cdc [_af ]=_gdcf ;}else if _gdg < -_gdcf {_fc .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_gdg ,-_gdcf );
_cdc [_af ]=-_gdcf ;};};};func (_gb Matrix )ScalingFactorX ()float64 {return _f .Hypot (_gb [0],_gb [1])};func (_gd *Matrix )Shear (x ,y float64 ){_gd .Concat (ShearMatrix (x ,y ))};