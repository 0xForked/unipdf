//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_c "fmt";_ca "github.com/unidoc/unipdf/v3/common";_b "math";);func (_cf Matrix )Identity ()bool {return _cf [0]==1&&_cf [1]==0&&_cf [2]==0&&_cf [3]==0&&_cf [4]==1&&_cf [5]==0&&_cf [6]==0&&_cf [7]==0&&_cf [8]==1;};func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};
func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};func (_cg *Point )Set (x ,y float64 ){_cg .X ,_cg .Y =x ,y };const _feb =1e9;func (_gg *Matrix )Clone ()Matrix {return NewMatrix (_gg [0],_gg [1],_gg [3],_gg [4],_gg [6],_gg [7])};
func (_fd *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_fd [0],_fd [1]=a ,b ;_fd [3],_fd [4]=c ,d ;_fd [6],_fd [7]=tx ,ty ;_fd .clampRange ();};func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};const _ce =1e-10;func (_fagf Matrix )Angle ()float64 {_ec :=_b .Atan2 (-_fagf [1],_fagf [0]);
if _ec < 0.0{_ec +=2*_b .Pi ;};return _ec /_b .Pi *180.0;};func (_fab Matrix )ScalingFactorX ()float64 {return _b .Hypot (_fab [0],_fab [1])};func RotationMatrix (angle float64 )Matrix {_cb :=_b .Cos (angle );_be :=_b .Sin (angle );return NewMatrix (_cb ,_be ,-_be ,_cb ,0,0);
};func (_cdc Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_cdc .X +t *b .X ,Y :(1-t )*_cdc .Y +t *b .Y };};func (_bf Point )Displace (delta Point )Point {return Point {_bf .X +delta .X ,_bf .Y +delta .Y }};func (_ef Matrix )Scale (xScale ,yScale float64 )Matrix {return _ef .Mult (ScaleMatrix (xScale ,yScale ))};
func (_da Matrix )Unrealistic ()bool {_gc ,_dee ,_daf ,_bb :=_b .Abs (_da [0]),_b .Abs (_da [1]),_b .Abs (_da [3]),_b .Abs (_da [4]);_ga :=_gc > _gbc &&_bb > _gbc ;_gbg :=_dee > _gbc &&_daf > _gbc ;return !(_ga ||_gbg );};func (_fda Matrix )Mult (b Matrix )Matrix {_fda .Concat (b );
return _fda };func (_gb *Matrix )clampRange (){for _ae ,_dg :=range _gb {if _dg > _feb {_ca .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_dg ,_feb );_gb [_ae ]=_feb ;}else if _dg < -_feb {_ca .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_dg ,-_feb );
_gb [_ae ]=-_feb ;};};};func (_fe Matrix )ScalingFactorY ()float64 {return _b .Hypot (_fe [3],_fe [4])};func (_ab Matrix )Transform (x ,y float64 )(float64 ,float64 ){_d :=x *_ab [0]+y *_ab [3]+_ab [6];_dc :=x *_ab [1]+y *_ab [4]+_ab [7];return _d ,_dc ;
};func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};func (_bdg *Matrix )Concat (b Matrix ){*_bdg =Matrix {b [0]*_bdg [0]+b [1]*_bdg [3],b [0]*_bdg [1]+b [1]*_bdg [4],0,b [3]*_bdg [0]+b [4]*_bdg [3],b [3]*_bdg [1]+b [4]*_bdg [4],0,b [6]*_bdg [0]+b [7]*_bdg [3]+_bdg [6],b [6]*_bdg [1]+b [7]*_bdg [4]+_bdg [7],1};
_bdg .clampRange ();};func (_eff Point )Rotate (theta float64 )Point {_cbfd :=_b .Hypot (_eff .X ,_eff .Y );_bae :=_b .Atan2 (_eff .Y ,_eff .X );_efd ,_bcf :=_b .Sincos (_bae +theta /180.0*_b .Pi );return Point {_cbfd *_bcf ,_cbfd *_efd };};func (_cgb Point )String ()string {return _c .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_cgb .X ,_cgb .Y );
};func (_efc Matrix )Rotate (theta float64 )Matrix {return _efc .Mult (RotationMatrix (theta ))};func (_db *Point )transformByMatrix (_bec Matrix ){_db .X ,_db .Y =_bec .Transform (_db .X ,_db .Y )};const _gce =1.0e-6;type Matrix [9]float64 ;type Point struct{X float64 ;
Y float64 ;};func (_cea *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_fg :=NewMatrix (a ,b ,c ,d ,tx ,ty );_cea .transformByMatrix (_fg );};func (_cfc Point )Distance (b Point )float64 {return _b .Hypot (_cfc .X -b .X ,_cfc .Y -b .Y )};func (_f Matrix )Round (precision float64 )Matrix {for _cc :=range _f {_f [_cc ]=_b .Round (_f [_cc ]/precision )*precision ;
};return _f ;};const _gbc =1e-6;func (_ba Matrix )Translate (tx ,ty float64 )Matrix {return _ba .Mult (TranslationMatrix (tx ,ty ))};func (_ac Matrix )Singular ()bool {return _b .Abs (_ac [0]*_ac [4]-_ac [1]*_ac [3])< _ce };func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};
func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );};func (_ff Matrix )String ()string {_fa ,_bd ,_eg ,_a ,_g ,_fag :=_ff [0],_ff [1],_ff [3],_ff [4],_ff [6],_ff [7];
return _c .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_fa ,_bd ,_eg ,_a ,_g ,_fag );};
func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_cbf :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};_cbf .clampRange ();return _cbf ;};func (_egd Matrix )Inverse ()(Matrix ,bool ){_ge ,_ed :=_egd [0],_egd [1];_gd ,_dd :=_egd [3],_egd [4];_cfd ,_edc :=_egd [6],_egd [7];
_dce :=_ge *_dd -_ed *_gd ;if _b .Abs (_dce )< _gce {return Matrix {},false ;};_aa ,_cd :=_dd /_dce ,-_ed /_dce ;_ggg ,_gge :=-_gd /_dce ,_ge /_dce ;_de :=-(_aa *_cfd +_ggg *_edc );_bdd :=-(_cd *_cfd +_gge *_edc );return NewMatrix (_aa ,_cd ,_ggg ,_gge ,_de ,_bdd ),true ;
};func (_bee *Matrix )Shear (x ,y float64 ){_bee .Concat (ShearMatrix (x ,y ))};func (_bc Matrix )Translation ()(float64 ,float64 ){return _bc [6],_bc [7]};