//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_d "fmt";_a "github.com/unidoc/unipdf/v3/common";_f "math";);func (_ec Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_ec .X +t *b .X ,Y :(1-t )*_ec .Y +t *b .Y };};func (_c Matrix )Scale (xScale ,yScale float64 )Matrix {return _c .Mult (ScaleMatrix (xScale ,yScale ))};
const _eab =1.0e-6;func (_fb *Matrix )Concat (b Matrix ){*_fb =Matrix {b [0]*_fb [0]+b [1]*_fb [3],b [0]*_fb [1]+b [1]*_fb [4],0,b [3]*_fb [0]+b [4]*_fb [3],b [3]*_fb [1]+b [4]*_fb [4],0,b [6]*_fb [0]+b [7]*_fb [3]+_fb [6],b [6]*_fb [1]+b [7]*_fb [4]+_fb [7],1};
_fb .clampRange ();};func (_bac Point )Distance (b Point )float64 {return _f .Hypot (_bac .X -b .X ,_bac .Y -b .Y )};func (_gd Matrix )Singular ()bool {return _f .Abs (_gd [0]*_gd [4]-_gd [1]*_gd [3])< _ga };func RotationMatrix (angle float64 )Matrix {_ag :=_f .Cos (angle );
_da :=_f .Sin (angle );return NewMatrix (_ag ,_da ,-_da ,_ag ,0,0);};func (_dc *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_bbe :=NewMatrix (a ,b ,c ,d ,tx ,ty );_dc .transformByMatrix (_bbe );};func (_bea Matrix )Transform (x ,y float64 )(float64 ,float64 ){_ce :=x *_bea [0]+y *_bea [3]+_bea [6];
_ge :=x *_bea [1]+y *_bea [4]+_bea [7];return _ce ,_ge ;};func (_ff Matrix )ScalingFactorX ()float64 {return _f .Hypot (_ff [0],_ff [1])};func (_aa Matrix )Translate (tx ,ty float64 )Matrix {return _aa .Mult (TranslationMatrix (tx ,ty ))};func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_be :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};
_be .clampRange ();return _be ;};func (_aaf Point )Displace (delta Point )Point {return Point {_aaf .X +delta .X ,_aaf .Y +delta .Y }};func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};func (_ffg *Matrix )clampRange (){for _gc ,_def :=range _ffg {if _def > _fgc {_a .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_def ,_fgc );
_ffg [_gc ]=_fgc ;}else if _def < -_fgc {_a .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_def ,-_fgc );_ffg [_gc ]=-_fgc ;};};};func (_ac Matrix )Identity ()bool {return _ac [0]==1&&_ac [1]==0&&_ac [2]==0&&_ac [3]==0&&_ac [4]==1&&_ac [5]==0&&_ac [6]==0&&_ac [7]==0&&_ac [8]==1;
};func (_bd Matrix )String ()string {_e ,_db ,_ea ,_fgg ,_ba ,_dg :=_bd [0],_bd [1],_bd [3],_bd [4],_bd [6],_bd [7];return _d .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_e ,_db ,_ea ,_fgg ,_ba ,_dg );
};func (_bdb Matrix )Angle ()float64 {_fc :=_f .Atan2 (-_bdb [1],_bdb [0]);if _fc < 0.0{_fc +=2*_f .Pi ;};return _fc /_f .Pi *180.0;};func (_eaf Matrix )Mult (b Matrix )Matrix {_eaf .Concat (b );return _eaf };type Point struct{X float64 ;Y float64 ;};func (_ab Matrix )Translation ()(float64 ,float64 ){return _ab [6],_ab [7]};
const _gf =1e-6;func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};func (_eaa Matrix )ScalingFactorY ()float64 {return _f .Hypot (_eaa [3],_eaa [4])};func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};
func (_dbg Matrix )Inverse ()(Matrix ,bool ){_cde ,_ca :=_dbg [0],_dbg [1];_dbe ,_af :=_dbg [3],_dbg [4];_bg ,_cf :=_dbg [6],_dbg [7];_bda :=_cde *_af -_ca *_dbe ;if _f .Abs (_bda )< _eab {return Matrix {},false ;};_gae ,_cg :=_af /_bda ,-_ca /_bda ;_bf ,_fd :=-_dbe /_bda ,_cde /_bda ;
_acc :=-(_gae *_bg +_bf *_cf );_de :=-(_cg *_bg +_fd *_cf );return NewMatrix (_gae ,_cg ,_bf ,_fd ,_acc ,_de ),true ;};func (_g Matrix )Rotate (theta float64 )Matrix {return _g .Mult (RotationMatrix (theta ))};func (_cd *Matrix )Clone ()Matrix {return NewMatrix (_cd [0],_cd [1],_cd [3],_cd [4],_cd [6],_cd [7])};
func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};type Matrix [9]float64 ;func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};func (_fga *Point )transformByMatrix (_fgb Matrix ){_fga .X ,_fga .Y =_fgb .Transform (_fga .X ,_fga .Y )};
func (_bgd Matrix )Unrealistic ()bool {_bc ,_adg ,_bb ,_dba :=_f .Abs (_bgd [0]),_f .Abs (_bgd [1]),_f .Abs (_bgd [3]),_f .Abs (_bgd [4]);_cae :=_bc > _gf &&_dba > _gf ;_aff :=_adg > _gf &&_bb > _gf ;return !(_cae ||_aff );};func (_ad Matrix )Round (precision float64 )Matrix {for _fg :=range _ad {_ad [_fg ]=_f .Round (_ad [_fg ]/precision )*precision ;
};return _ad ;};const _fgc =1e9;const _ga =1e-10;func (_bad *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_bad [0],_bad [1]=a ,b ;_bad [3],_bad [4]=c ,d ;_bad [6],_bad [7]=tx ,ty ;_bad .clampRange ();};func (_gb *Matrix )Shear (x ,y float64 ){_gb .Concat (ShearMatrix (x ,y ))};
func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );};func (_gce Point )String ()string {return _d .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_gce .X ,_gce .Y );
};func (_aca Point )Rotate (theta float64 )Point {_cab :=_f .Hypot (_aca .X ,_aca .Y );_baa :=_f .Atan2 (_aca .Y ,_aca .X );_gbc ,_fdf :=_f .Sincos (_baa +theta /180.0*_f .Pi );return Point {_cab *_fdf ,_cab *_gbc };};func (_eb *Point )Set (x ,y float64 ){_eb .X ,_eb .Y =x ,y };
