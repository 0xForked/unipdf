//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_f "fmt";_c "github.com/unidoc/unipdf/v3/common";_b "math";);const _cac =1e-6;const _cfg =1.0e-6;func (_ee *Matrix )clampRange (){for _acff ,_dfb :=range _ee {if _dfb > _gc {_c .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_dfb ,_gc );
_ee [_acff ]=_gc ;}else if _dfb < -_gc {_c .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_dfb ,-_gc );_ee [_acff ]=-_gc ;};};};func (_fc Matrix )Singular ()bool {return _b .Abs (_fc [0]*_fc [4]-_fc [1]*_fc [3])< _gb };
func (_fe Matrix )Rotate (theta float64 )Matrix {return _fe .Mult (RotationMatrix (theta ))};func (_bff Matrix )Unrealistic ()bool {_dc ,_gdf ,_cgc ,_dg :=_b .Abs (_bff [0]),_b .Abs (_bff [1]),_b .Abs (_bff [3]),_b .Abs (_bff [4]);_cbb :=_dc > _cac &&_dg > _cac ;
_bfg :=_gdf > _cac &&_cgc > _cac ;return !(_cbb ||_bfg );};func (_cfc Point )Displace (delta Point )Point {return Point {_cfc .X +delta .X ,_cfc .Y +delta .Y }};func (_ef Matrix )Round (precision float64 )Matrix {for _g :=range _ef {_ef [_g ]=_b .Round (_ef [_g ]/precision )*precision ;
};return _ef ;};func RotationMatrix (angle float64 )Matrix {_a :=_b .Cos (angle );_cb :=_b .Sin (angle );return NewMatrix (_a ,_cb ,-_cb ,_a ,0,0);};func (_fge Point )String ()string {return _f .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_fge .X ,_fge .Y );
};func (_ga Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_ga .X +t *b .X ,Y :(1-t )*_ga .Y +t *b .Y };};type Matrix [9]float64 ;func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_d :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};_d .clampRange ();
return _d ;};func (_ba *Matrix )Concat (b Matrix ){*_ba =Matrix {b [0]*_ba [0]+b [1]*_ba [3],b [0]*_ba [1]+b [1]*_ba [4],0,b [3]*_ba [0]+b [4]*_ba [3],b [3]*_ba [1]+b [4]*_ba [4],0,b [6]*_ba [0]+b [7]*_ba [3]+_ba [6],b [6]*_ba [1]+b [7]*_ba [4]+_ba [7],1};
_ba .clampRange ();};func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};func (_dac *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_bfa :=NewMatrix (a ,b ,c ,d ,tx ,ty );
_dac .transformByMatrix (_bfa );};func (_bfc *Point )transformByMatrix (_aag Matrix ){_bfc .X ,_bfc .Y =_aag .Transform (_bfc .X ,_bfc .Y )};func (_gf Matrix )Mult (b Matrix )Matrix {_gf .Concat (b );return _gf };func (_fa *Matrix )Shear (x ,y float64 ){_fa .Concat (ShearMatrix (x ,y ))};
func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );};func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};func (_fg Matrix )Identity ()bool {return _fg [0]==1&&_fg [1]==0&&_fg [2]==0&&_fg [3]==0&&_fg [4]==1&&_fg [5]==0&&_fg [6]==0&&_fg [7]==0&&_fg [8]==1;
};func (_cc *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_cc [0],_cc [1]=a ,b ;_cc [3],_cc [4]=c ,d ;_cc [6],_cc [7]=tx ,ty ;_cc .clampRange ();};const _gc =1e9;func (_db Matrix )ScalingFactorX ()float64 {return _b .Hypot (_db [0],_db [1])};func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};
func (_ea Matrix )String ()string {_bg ,_ae ,_de ,_af ,_gd ,_ca :=_ea [0],_ea [1],_ea [3],_ea [4],_ea [6],_ea [7];return _f .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_bg ,_ae ,_de ,_af ,_gd ,_ca );
};func (_gbe Point )Rotate (theta float64 )Point {_cfe :=_b .Hypot (_gbe .X ,_gbe .Y );_gbg :=_b .Atan2 (_gbe .Y ,_gbe .X );_cff ,_ge :=_b .Sincos (_gbg +theta /180.0*_b .Pi );return Point {_cfe *_ge ,_cfe *_cff };};const _gb =1e-10;func (_df Matrix )Translate (tx ,ty float64 )Matrix {return _df .Mult (TranslationMatrix (tx ,ty ))};
func (_gg Matrix )Scale (xScale ,yScale float64 )Matrix {return _gg .Mult (ScaleMatrix (xScale ,yScale ))};func (_aa *Matrix )Clone ()Matrix {return NewMatrix (_aa [0],_aa [1],_aa [3],_aa [4],_aa [6],_aa [7])};func (_eba Point )Distance (b Point )float64 {return _b .Hypot (_eba .X -b .X ,_eba .Y -b .Y )};
type Point struct{X float64 ;Y float64 ;};func (_baf Matrix )Translation ()(float64 ,float64 ){return _baf [6],_baf [7]};func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};func (_da Matrix )Inverse ()(Matrix ,bool ){_dbg ,_ac :=_da [0],_da [1];
_acf ,_aaf :=_da [3],_da [4];_ab ,_cf :=_da [6],_da [7];_gfb :=_dbg *_aaf -_ac *_acf ;if _b .Abs (_gfb )< _cfg {return Matrix {},false ;};_cd ,_fb :=_aaf /_gfb ,-_ac /_gfb ;_cdg ,_ed :=-_acf /_gfb ,_dbg /_gfb ;_cg :=-(_cd *_ab +_cdg *_cf );_eag :=-(_fb *_ab +_ed *_cf );
return NewMatrix (_cd ,_fb ,_cdg ,_ed ,_cg ,_eag ),true ;};func (_eb Matrix )ScalingFactorY ()float64 {return _b .Hypot (_eb [3],_eb [4])};func (_fac Matrix )Angle ()float64 {_bf :=_b .Atan2 (-_fac [1],_fac [0]);if _bf < 0.0{_bf +=2*_b .Pi ;};return _bf /_b .Pi *180.0;
};func (_ebf *Point )Set (x ,y float64 ){_ebf .X ,_ebf .Y =x ,y };func (_fec Matrix )Transform (x ,y float64 )(float64 ,float64 ){_fgb :=x *_fec [0]+y *_fec [3]+_fec [6];_afc :=x *_fec [1]+y *_fec [4]+_fec [7];return _fgb ,_afc ;};