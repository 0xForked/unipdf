//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_c "fmt";_ce "github.com/unidoc/unipdf/v3/common";_b "math";);func (_bd Matrix )Round (precision float64 )Matrix {for _e :=range _bd {_bd [_e ]=_b .Round (_bd [_e ]/precision )*precision ;};return _bd ;};func (_eca Point )Rotate (theta float64 )Point {_gc :=_b .Hypot (_eca .X ,_eca .Y );
_gbge :=_b .Atan2 (_eca .Y ,_eca .X );_egf ,_cfed :=_b .Sincos (_gbge +theta /180.0*_b .Pi );return Point {_gc *_cfed ,_gc *_egf };};func (_dbg Matrix )ScalingFactorX ()float64 {return _b .Hypot (_dbg [0],_dbg [1])};func (_ea Matrix )ScalingFactorY ()float64 {return _b .Hypot (_ea [3],_ea [4])};
func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};func (_be Matrix )Unrealistic ()bool {_dg ,_ab ,_edf ,_bca :=_b .Abs (_be [0]),_b .Abs (_be [1]),_b .Abs (_be [3]),_b .Abs (_be [4]);_gbg :=_dg > _adf &&_bca > _adf ;_ecf :=_ab > _adf &&_edf > _adf ;
return !(_gbg ||_ecf );};func (_dd Matrix )Identity ()bool {return _dd [0]==1&&_dd [1]==0&&_dd [2]==0&&_dd [3]==0&&_dd [4]==1&&_dd [5]==0&&_dd [6]==0&&_dd [7]==0&&_dd [8]==1;};func (_bc *Matrix )Shear (x ,y float64 ){_bc .Concat (ShearMatrix (x ,y ))};
func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );};func (_db *Matrix )Clone ()Matrix {return NewMatrix (_db [0],_db [1],_db [3],_db [4],_db [6],_db [7])};
func (_fgd *Point )Set (x ,y float64 ){_fgd .X ,_fgd .Y =x ,y };func (_ff Matrix )Translate (tx ,ty float64 )Matrix {return _ff .Mult (TranslationMatrix (tx ,ty ))};func (_cfc Matrix )Angle ()float64 {_eba :=_b .Atan2 (-_cfc [1],_cfc [0]);if _eba < 0.0{_eba +=2*_b .Pi ;
};return _eba /_b .Pi *180.0;};func (_fd Matrix )Scale (xScale ,yScale float64 )Matrix {return _fd .Mult (ScaleMatrix (xScale ,yScale ))};func (_cd Matrix )Inverse ()(Matrix ,bool ){_gb ,_ga :=_cd [0],_cd [1];_cb ,_cfe :=_cd [3],_cd [4];_eed ,_gg :=_cd [6],_cd [7];
_ec :=_gb *_cfe -_ga *_cb ;if _b .Abs (_ec )< _gf {return Matrix {},false ;};_aa ,_fg :=_cfe /_ec ,-_ga /_ec ;_add ,_gde :=-_cb /_ec ,_gb /_ec ;_fdf :=-(_aa *_eed +_add *_gg );_ecb :=-(_fg *_eed +_gde *_gg );return NewMatrix (_aa ,_fg ,_add ,_gde ,_fdf ,_ecb ),true ;
};func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};func (_fe *Matrix )clampRange (){for _fa ,_ae :=range _fe {if _ae > _adg {_ce .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_ae ,_adg );
_fe [_fa ]=_adg ;}else if _ae < -_adg {_ce .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_ae ,-_adg );_fe [_fa ]=-_adg ;};};};func (_cdb *Point )transformByMatrix (_gbf Matrix ){_cdb .X ,_cdb .Y =_gbf .Transform (_cdb .X ,_cdb .Y )};
type Matrix [9]float64 ;func (_ebb Matrix )Rotate (theta float64 )Matrix {return _ebb .Mult (RotationMatrix (theta ))};func (_ac Matrix )Mult (b Matrix )Matrix {_ac .Concat (b );return _ac };const _gf =1.0e-6;func (_f Matrix )String ()string {_eg ,_fc ,_eb ,_gdd ,_ed ,_fb :=_f [0],_f [1],_f [3],_f [4],_f [6],_f [7];
return _c .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_eg ,_fc ,_eb ,_gdd ,_ed ,_fb );
};type Point struct{X float64 ;Y float64 ;};func (_bdb Matrix )Transform (x ,y float64 )(float64 ,float64 ){_bb :=x *_bdb [0]+y *_bdb [3]+_bdb [6];_dae :=x *_bdb [1]+y *_bdb [4]+_bdb [7];return _bb ,_dae ;};const _adf =1e-6;func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_gd :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};
_gd .clampRange ();return _gd ;};func (_bde Point )Displace (delta Point )Point {return Point {_bde .X +delta .X ,_bde .Y +delta .Y }};func RotationMatrix (angle float64 )Matrix {_g :=_b .Cos (angle );_a :=_b .Sin (angle );return NewMatrix (_g ,_a ,-_a ,_g ,0,0);
};func (_dc Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_dc .X +t *b .X ,Y :(1-t )*_dc .Y +t *b .Y };};func (_dbe Matrix )Singular ()bool {return _b .Abs (_dbe [0]*_dbe [4]-_dbe [1]*_dbe [3])< _ee };func (_cf *Matrix )Concat (b Matrix ){*_cf =Matrix {b [0]*_cf [0]+b [1]*_cf [3],b [0]*_cf [1]+b [1]*_cf [4],0,b [3]*_cf [0]+b [4]*_cf [3],b [3]*_cf [1]+b [4]*_cf [4],0,b [6]*_cf [0]+b [7]*_cf [3]+_cf [6],b [6]*_cf [1]+b [7]*_cf [4]+_cf [7],1};
_cf .clampRange ();};func (_da Matrix )Translation ()(float64 ,float64 ){return _da [6],_da [7]};func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};const _ee =1e-10;func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};func (_cfd Point )Distance (b Point )float64 {return _b .Hypot (_cfd .X -b .X ,_cfd .Y -b .Y )};
func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};func (_fga Point )String ()string {return _c .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_fga .X ,_fga .Y );};func (_ad *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_ad [0],_ad [1]=a ,b ;
_ad [3],_ad [4]=c ,d ;_ad [6],_ad [7]=tx ,ty ;_ad .clampRange ();};func (_dbb *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_fad :=NewMatrix (a ,b ,c ,d ,tx ,ty );_dbb .transformByMatrix (_fad );};const _adg =1e9;