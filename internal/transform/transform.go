//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_a "fmt";_g "github.com/unidoc/unipdf/v3/common";_c "math";);func (_ac *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_ac [0],_ac [1]=a ,b ;_ac [3],_ac [4]=c ,d ;_ac [6],_ac [7]=tx ,ty ;_ac .clampRange ();};func (_be Matrix )Inverse ()(Matrix ,bool ){_bd ,_bda :=_be [0],_be [1];
_dfc ,_fae :=_be [3],_be [4];_ba ,_bee :=_be [6],_be [7];_cg :=_bd *_fae -_bda *_dfc ;if _c .Abs (_cg )< _ea {return Matrix {},false ;};_fb ,_cbb :=_fae /_cg ,-_bda /_cg ;_ca ,_fe :=-_dfc /_cg ,_bd /_cg ;_ab :=-(_fb *_ba +_ca *_bee );_aa :=-(_cbb *_ba +_fe *_bee );
return NewMatrix (_fb ,_cbb ,_ca ,_fe ,_ab ,_aa ),true ;};func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};func (_ecb *Matrix )Shear (x ,y float64 ){_ecb .Concat (ShearMatrix (x ,y ))};func (_ce Matrix )Identity ()bool {return _ce [0]==1&&_ce [1]==0&&_ce [2]==0&&_ce [3]==0&&_ce [4]==1&&_ce [5]==0&&_ce [6]==0&&_ce [7]==0&&_ce [8]==1;
};func (_de Matrix )Round (precision float64 )Matrix {for _cc :=range _de {_de [_cc ]=_c .Round (_de [_cc ]/precision )*precision ;};return _de ;};const _ad =1e-10;func (_cb *Matrix )Clone ()Matrix {return NewMatrix (_cb [0],_cb [1],_cb [3],_cb [4],_cb [6],_cb [7])};
func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};func (_efa Matrix )Unrealistic ()bool {_gde ,_fag ,_cbba ,_dea :=_c .Abs (_efa [0]),_c .Abs (_efa [1]),_c .Abs (_efa [3]),_c .Abs (_efa [4]);_gf :=_gde > _cf &&_dea > _cf ;_add :=_fag > _cf &&_cbba > _cf ;
return !(_gf ||_add );};func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_b :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};_b .clampRange ();return _b ;};func (_ced Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_ced .X +t *b .X ,Y :(1-t )*_ced .Y +t *b .Y };
};func (_eb *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_ffc :=NewMatrix (a ,b ,c ,d ,tx ,ty );_eb .transformByMatrix (_ffc );};func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );
};func (_ffd Point )Rotate (theta float64 )Point {_eee :=_c .Hypot (_ffd .X ,_ffd .Y );_ag :=_c .Atan2 (_ffd .Y ,_ffd .X );_eeg ,_bag :=_c .Sincos (_ag +theta /180.0*_c .Pi );return Point {_eee *_bag ,_eee *_eeg };};func (_fd Matrix )Singular ()bool {return _c .Abs (_fd [0]*_fd [4]-_fd [1]*_fd [3])< _ad };
func (_gg Matrix )Rotate (theta float64 )Matrix {return _gg .Mult (RotationMatrix (theta ))};func (_acf Point )Distance (b Point )float64 {return _c .Hypot (_acf .X -b .X ,_acf .Y -b .Y )};func (_ecd Point )Displace (delta Point )Point {return Point {_ecd .X +delta .X ,_ecd .Y +delta .Y }};
func (_dff Point )String ()string {return _a .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_dff .X ,_dff .Y );};func (_dd *Matrix )Concat (b Matrix ){*_dd =Matrix {b [0]*_dd [0]+b [1]*_dd [3],b [0]*_dd [1]+b [1]*_dd [4],0,b [3]*_dd [0]+b [4]*_dd [3],b [3]*_dd [1]+b [4]*_dd [4],0,b [6]*_dd [0]+b [7]*_dd [3]+_dd [6],b [6]*_dd [1]+b [7]*_dd [4]+_dd [7],1};
_dd .clampRange ();};func (_fc Matrix )Transform (x ,y float64 )(float64 ,float64 ){_fa :=x *_fc [0]+y *_fc [3]+_fc [6];_df :=x *_fc [1]+y *_fc [4]+_fc [7];return _fa ,_df ;};const _fg =1e9;func (_deg Matrix )Translate (tx ,ty float64 )Matrix {return _deg .Mult (TranslationMatrix (tx ,ty ))};
func (_gfg *Point )transformByMatrix (_gfe Matrix ){_gfg .X ,_gfg .Y =_gfe .Transform (_gfg .X ,_gfg .Y )};func (_bga *Point )Set (x ,y float64 ){_bga .X ,_bga .Y =x ,y };func (_gda Matrix )Scale (xScale ,yScale float64 )Matrix {return _gda .Mult (ScaleMatrix (xScale ,yScale ));
};func (_dbg *Matrix )clampRange (){for _cga ,_cdf :=range _dbg {if _cdf > _fg {_g .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_cdf ,_fg );_dbg [_cga ]=_fg ;}else if _cdf < -_fg {_g .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_cdf ,-_fg );
_dbg [_cga ]=-_fg ;};};};func RotationMatrix (angle float64 )Matrix {_db :=_c .Cos (angle );_da :=_c .Sin (angle );return NewMatrix (_db ,_da ,-_da ,_db ,0,0);};func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};
func (_bc Matrix )ScalingFactorX ()float64 {return _c .Hypot (_bc [0],_bc [1])};func (_ff Matrix )Mult (b Matrix )Matrix {_ff .Concat (b );return _ff };type Matrix [9]float64 ;func (_gc Matrix )Angle ()float64 {_cd :=_c .Atan2 (-_gc [1],_gc [0]);if _cd < 0.0{_cd +=2*_c .Pi ;
};return _cd /_c .Pi *180.0;};const _cf =1e-6;type Point struct{X float64 ;Y float64 ;};func (_ec Matrix )Translation ()(float64 ,float64 ){return _ec [6],_ec [7]};const _ea =1.0e-6;func (_e Matrix )String ()string {_gd ,_ee ,_ge ,_ef ,_f ,_gb :=_e [0],_e [1],_e [3],_e [4],_e [6],_e [7];
return _a .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_gd ,_ee ,_ge ,_ef ,_f ,_gb );};
func (_bg Matrix )ScalingFactorY ()float64 {return _c .Hypot (_bg [3],_bg [4])};