//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_a "fmt";_b "github.com/unidoc/unipdf/v3/common";_c "math";);func (_fb *Matrix )Concat (b Matrix ){*_fb =Matrix {b [0]*_fb [0]+b [1]*_fb [3],b [0]*_fb [1]+b [1]*_fb [4],0,b [3]*_fb [0]+b [4]*_fb [3],b [3]*_fb [1]+b [4]*_fb [4],0,b [6]*_fb [0]+b [7]*_fb [3]+_fb [6],b [6]*_fb [1]+b [7]*_fb [4]+_fb [7],1};
_fb .clampRange ();};func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};func (_ae Matrix )Rotate (theta float64 )Matrix {return _ae .Mult (RotationMatrix (theta ))};func (_ac Matrix )Round (precision float64 )Matrix {for _f :=range _ac {_ac [_f ]=_c .Round (_ac [_f ]/precision )*precision ;
};return _ac ;};func (_gc Matrix )String ()string {_bb ,_aa ,_cc ,_cd ,_bbd ,_bf :=_gc [0],_gc [1],_gc [3],_gc [4],_gc [6],_gc [7];return _a .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_bb ,_aa ,_cc ,_cd ,_bbd ,_bf );
};func (_fd Matrix )Translation ()(float64 ,float64 ){return _fd [6],_fd [7]};const _dda =1e9;func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};func (_agg Point )Rotate (theta float64 )Point {_bfd :=_c .Hypot (_agg .X ,_agg .Y );
_bcf :=_c .Atan2 (_agg .Y ,_agg .X );_daa ,_gde :=_c .Sincos (_bcf +theta /180.0*_c .Pi );return Point {_bfd *_gde ,_bfd *_daa };};func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};func (_bc Matrix )Scale (xScale ,yScale float64 )Matrix {return _bc .Mult (ScaleMatrix (xScale ,yScale ))};
func (_eb Matrix )ScalingFactorY ()float64 {return _c .Hypot (_eb [3],_eb [4])};func (_acc Matrix )Angle ()float64 {_be :=_c .Atan2 (-_acc [1],_acc [0]);if _be < 0.0{_be +=2*_c .Pi ;};return _be /_c .Pi *180.0;};func (_ccc Matrix )Inverse ()(Matrix ,bool ){_gd ,_dbgb :=_ccc [0],_ccc [1];
_bfb ,_ad :=_ccc [3],_ccc [4];_ag ,_dag :=_ccc [6],_ccc [7];_fe :=_gd *_ad -_dbgb *_bfb ;if _c .Abs (_fe )< _ea {return Matrix {},false ;};_fce ,_aee :=_ad /_fe ,-_dbgb /_fe ;_gdc ,_bd :=-_bfb /_fe ,_gd /_fe ;_cb :=-(_fce *_ag +_gdc *_dag );_af :=-(_aee *_ag +_bd *_dag );
return NewMatrix (_fce ,_aee ,_gdc ,_bd ,_cb ,_af ),true ;};func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};func (_cdd Matrix )ScalingFactorX ()float64 {return _c .Hypot (_cdd [0],_cdd [1])};func (_dbg Matrix )Singular ()bool {return _c .Abs (_dbg [0]*_dbg [4]-_dbg [1]*_dbg [3])< _fcf };
func (_fa Point )Distance (b Point )float64 {return _c .Hypot (_fa .X -b .X ,_fa .Y -b .Y )};func RotationMatrix (angle float64 )Matrix {_g :=_c .Cos (angle );_db :=_c .Sin (angle );return NewMatrix (_g ,_db ,-_db ,_g ,0,0);};func (_bfe Point )Displace (delta Point )Point {return Point {_bfe .X +delta .X ,_bfe .Y +delta .Y }};
type Matrix [9]float64 ;func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );};func (_ega Point )String ()string {return _a .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_ega .X ,_ega .Y );
};func (_dce *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_ec :=NewMatrix (a ,b ,c ,d ,tx ,ty );_dce .transformByMatrix (_ec );};func (_dd Matrix )Identity ()bool {return _dd [0]==1&&_dd [1]==0&&_dd [2]==0&&_dd [3]==0&&_dd [4]==1&&_dd [5]==0&&_dd [6]==0&&_dd [7]==0&&_dd [8]==1;
};func (_ga Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_ga .X +t *b .X ,Y :(1-t )*_ga .Y +t *b .Y };};func (_bg *Point )Set (x ,y float64 ){_bg .X ,_bg .Y =x ,y };func (_cae *Point )transformByMatrix (_ege Matrix ){_cae .X ,_cae .Y =_ege .Transform (_cae .X ,_cae .Y )};
func (_cg *Matrix )clampRange (){for _fg ,_dbge :=range _cg {if _dbge > _dda {_b .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_dbge ,_dda );_cg [_fg ]=_dda ;}else if _dbge < -_dda {_b .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_dbge ,-_dda );
_cg [_fg ]=-_dda ;};};};func (_fc *Matrix )Clone ()Matrix {return NewMatrix (_fc [0],_fc [1],_fc [3],_fc [4],_fc [6],_fc [7])};func (_ca Matrix )Mult (b Matrix )Matrix {_ca .Concat (b );return _ca };func (_e *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_e [0],_e [1]=a ,b ;
_e [3],_e [4]=c ,d ;_e [6],_e [7]=tx ,ty ;_e .clampRange ();};func (_da *Matrix )Shear (x ,y float64 ){_da .Concat (ShearMatrix (x ,y ))};func (_ed Matrix )Unrealistic ()bool {_ce ,_dc ,_dg ,_cbd :=_c .Abs (_ed [0]),_c .Abs (_ed [1]),_c .Abs (_ed [3]),_c .Abs (_ed [4]);
_abb :=_ce > _eg &&_cbd > _eg ;_gcg :=_dc > _eg &&_dg > _eg ;return !(_abb ||_gcg );};func (_ff Matrix )Translate (tx ,ty float64 )Matrix {return _ff .Mult (TranslationMatrix (tx ,ty ))};func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_ab :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};
_ab .clampRange ();return _ab ;};func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};type Point struct{X float64 ;Y float64 ;};const _fcf =1e-10;const _eg =1e-6;func (_ef Matrix )Transform (x ,y float64 )(float64 ,float64 ){_gf :=x *_ef [0]+y *_ef [3]+_ef [6];
_gcd :=x *_ef [1]+y *_ef [4]+_ef [7];return _gf ,_gcd ;};const _ea =1.0e-6;