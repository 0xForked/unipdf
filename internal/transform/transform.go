//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_dc "fmt";_g "github.com/unidoc/unipdf/v3/common";_b "math";);func (_ba *Matrix )Concat (b Matrix ){*_ba =Matrix {b [0]*_ba [0]+b [1]*_ba [3],b [0]*_ba [1]+b [1]*_ba [4],0,b [3]*_ba [0]+b [4]*_ba [3],b [3]*_ba [1]+b [4]*_ba [4],0,b [6]*_ba [0]+b [7]*_ba [3]+_ba [6],b [6]*_ba [1]+b [7]*_ba [4]+_ba [7],1};
_ba .clampRange ();};func (_cd *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_cd [0],_cd [1]=a ,b ;_cd [3],_cd [4]=c ,d ;_cd [6],_cd [7]=tx ,ty ;_cd .clampRange ();};func (_bc *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_eab :=NewMatrix (a ,b ,c ,d ,tx ,ty );
_bc .transformByMatrix (_eab );};func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};const _dba =1.0e-6;func (_gc Matrix )ScalingFactorY ()float64 {return _b .Hypot (_gc [3],_gc [4])};const _bab =1e-6;func (_af Point )Rotate (theta float64 )Point {_gce :=_b .Hypot (_af .X ,_af .Y );
_cfd :=_b .Atan2 (_af .Y ,_af .X );_fgd ,_eag :=_b .Sincos (_cfd +theta /180.0*_b .Pi );return Point {_gce *_eag ,_gce *_fgd };};func (_eae *Matrix )clampRange (){for _fc ,_fgf :=range _eae {if _fgf > _cb {_g .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_fgf ,_cb );
_eae [_fc ]=_cb ;}else if _fgf < -_cb {_g .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_fgf ,-_cb );_eae [_fc ]=-_cb ;};};};func RotationMatrix (angle float64 )Matrix {_df :=_b .Cos (angle );_f :=_b .Sin (angle );
return NewMatrix (_df ,_f ,-_f ,_df ,0,0);};func (_bag Matrix )Singular ()bool {return _b .Abs (_bag [0]*_bag [4]-_bag [1]*_bag [3])< _eef };func (_e Matrix )Round (precision float64 )Matrix {for _ed :=range _e {_e [_ed ]=_b .Round (_e [_ed ]/precision )*precision ;
};return _e ;};func (_fg Matrix )Translate (tx ,ty float64 )Matrix {return _fg .Mult (TranslationMatrix (tx ,ty ))};func (_dbaf *Point )transformByMatrix (_gbg Matrix ){_dbaf .X ,_dbaf .Y =_gbg .Transform (_dbaf .X ,_dbaf .Y );};func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );
};func (_a Matrix )Angle ()float64 {_ae :=_b .Atan2 (-_a [1],_a [0]);if _ae < 0.0{_ae +=2*_b .Pi ;};return _ae /_b .Pi *180.0;};func (_dda Matrix )Unrealistic ()bool {_gdb ,_fa ,_eba ,_dg :=_b .Abs (_dda [0]),_b .Abs (_dda [1]),_b .Abs (_dda [3]),_b .Abs (_dda [4]);
_dde :=_gdb > _bab &&_dg > _bab ;_gcd :=_fa > _bab &&_eba > _bab ;return !(_dde ||_gcd );};func (_gd Matrix )Translation ()(float64 ,float64 ){return _gd [6],_gd [7]};func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};
func (_egb Point )String ()string {return _dc .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_egb .X ,_egb .Y );};func (_ce Matrix )Scale (xScale ,yScale float64 )Matrix {return _ce .Mult (ScaleMatrix (xScale ,yScale ))};func (_bac Matrix )ScalingFactorX ()float64 {return _b .Hypot (_bac [0],_bac [1])};
type Point struct{X float64 ;Y float64 ;};func (_cc Matrix )Inverse ()(Matrix ,bool ){_ga ,_ac :=_cc [0],_cc [1];_bd ,_eac :=_cc [3],_cc [4];_fba ,_eg :=_cc [6],_cc [7];_bb :=_ga *_eac -_ac *_bd ;if _b .Abs (_bb )< _dba {return Matrix {},false ;};_ceb ,_ad :=_eac /_bb ,-_ac /_bb ;
_ab ,_cf :=-_bd /_bb ,_ga /_bb ;_bg :=-(_ceb *_fba +_ab *_eg );_dce :=-(_ad *_fba +_cf *_eg );return NewMatrix (_ceb ,_ad ,_ab ,_cf ,_bg ,_dce ),true ;};type Matrix [9]float64 ;func (_fe Point )Distance (b Point )float64 {return _b .Hypot (_fe .X -b .X ,_fe .Y -b .Y )};
func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};func (_dge Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_dge .X +t *b .X ,Y :(1-t )*_dge .Y +t *b .Y };};func (_eb *Matrix )Clone ()Matrix {return NewMatrix (_eb [0],_eb [1],_eb [3],_eb [4],_eb [6],_eb [7])};
func (_gad Point )Displace (delta Point )Point {return Point {_gad .X +delta .X ,_gad .Y +delta .Y }};func (_aed *Point )Set (x ,y float64 ){_aed .X ,_aed .Y =x ,y };func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_dcc :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};
_dcc .clampRange ();return _dcc ;};const _cb =1e9;func (_dea Matrix )Transform (x ,y float64 )(float64 ,float64 ){_dd :=x *_dea [0]+y *_dea [3]+_dea [6];_gbcb :=x *_dea [1]+y *_dea [4]+_dea [7];return _dd ,_gbcb ;};func (_db *Matrix )Shear (x ,y float64 ){_db .Concat (ShearMatrix (x ,y ))};
func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};func (_fb Matrix )String ()string {_c ,_ge ,_gb ,_gbc ,_ee ,_ff :=_fb [0],_fb [1],_fb [3],_fb [4],_fb [6],_fb [7];return _dc .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_c ,_ge ,_gb ,_gbc ,_ee ,_ff );
};func (_ea Matrix )Rotate (theta float64 )Matrix {return _ea .Mult (RotationMatrix (theta ))};func (_de Matrix )Mult (b Matrix )Matrix {_de .Concat (b );return _de };const _eef =1e-10;func (_ef Matrix )Identity ()bool {return _ef [0]==1&&_ef [1]==0&&_ef [2]==0&&_ef [3]==0&&_ef [4]==1&&_ef [5]==0&&_ef [6]==0&&_ef [7]==0&&_ef [8]==1;
};