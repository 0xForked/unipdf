//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_g "fmt";_c "github.com/unidoc/unipdf/v3/common";_e "math";);func (_cedc Point )Distance (b Point )float64 {return _e .Hypot (_cedc .X -b .X ,_cedc .Y -b .Y )};func (_fc Matrix )Rotate (theta float64 )Matrix {return _fc .Mult (RotationMatrix (theta ))};
func (_be Matrix )Identity ()bool {return _be [0]==1&&_be [1]==0&&_be [2]==0&&_be [3]==0&&_be [4]==1&&_be [5]==0&&_be [6]==0&&_be [7]==0&&_be [8]==1;};const _gcd =1e-6;func (_fd Matrix )Mult (b Matrix )Matrix {_fd .Concat (b );return _fd };func (_bf Matrix )String ()string {_fe ,_cc ,_bfg ,_da ,_eg ,_a :=_bf [0],_bf [1],_bf [3],_bf [4],_bf [6],_bf [7];
return _g .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_fe ,_cc ,_bfg ,_da ,_eg ,_a );};
func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};func (_fgd Matrix )Angle ()float64 {_gg :=_e .Atan2 (-_fgd [1],_fgd [0]);if _gg < 0.0{_gg +=2*_e .Pi ;};return _gg /_e .Pi *180.0;};func (_bb Point )String ()string {return _g .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_bb .X ,_bb .Y );
};const _ceg =1e-10;type Matrix [9]float64 ;const _dac =1.0e-6;func (_ea *Matrix )Concat (b Matrix ){*_ea =Matrix {b [0]*_ea [0]+b [1]*_ea [3],b [0]*_ea [1]+b [1]*_ea [4],0,b [3]*_ea [0]+b [4]*_ea [3],b [3]*_ea [1]+b [4]*_ea [4],0,b [6]*_ea [0]+b [7]*_ea [3]+_ea [6],b [6]*_ea [1]+b [7]*_ea [4]+_ea [7],1};
_ea .clampRange ();};func (_ecg *Point )Set (x ,y float64 ){_ecg .X ,_ecg .Y =x ,y };func (_gga *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_fdb :=NewMatrix (a ,b ,c ,d ,tx ,ty );_gga .transformByMatrix (_fdb );};func (_ffb Matrix )Singular ()bool {return _e .Abs (_ffb [0]*_ffb [4]-_ffb [1]*_ffb [3])< _ceg };
func RotationMatrix (angle float64 )Matrix {_ff :=_e .Cos (angle );_ge :=_e .Sin (angle );return NewMatrix (_ff ,_ge ,-_ge ,_ff ,0,0);};func (_ba Matrix )Translate (tx ,ty float64 )Matrix {return _ba .Mult (TranslationMatrix (tx ,ty ))};func (_daa Point )Rotate (theta float64 )Point {_cfd :=_e .Hypot (_daa .X ,_daa .Y );
_cca :=_e .Atan2 (_daa .Y ,_daa .X );_agg ,_egd :=_e .Sincos (_cca +theta /180.0*_e .Pi );return Point {_cfd *_egd ,_cfd *_agg };};func (_fgb Matrix )Unrealistic ()bool {_gc ,_edc ,_gb ,_ffe :=_e .Abs (_fgb [0]),_e .Abs (_fgb [1]),_e .Abs (_fgb [3]),_e .Abs (_fgb [4]);
_eb :=_gc > _gcd &&_ffe > _gcd ;_ccgd :=_edc > _gcd &&_gb > _gcd ;return !(_eb ||_ccgd );};func (_d Matrix )Round (precision float64 )Matrix {for _f :=range _d {_d [_f ]=_e .Round (_d [_f ]/precision )*precision ;};return _d ;};const _cac =1e9;func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );
};func (_ag *Matrix )Clone ()Matrix {return NewMatrix (_ag [0],_ag [1],_ag [3],_ag [4],_ag [6],_ag [7])};func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};func (_cg Matrix )Scale (xScale ,yScale float64 )Matrix {return _cg .Mult (ScaleMatrix (xScale ,yScale ))};
func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};func (_dbf *Point )transformByMatrix (_ege Matrix ){_dbf .X ,_dbf .Y =_ege .Transform (_dbf .X ,_dbf .Y )};func (_fce *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_fce [0],_fce [1]=a ,b ;
_fce [3],_fce [4]=c ,d ;_fce [6],_fce [7]=tx ,ty ;_fce .clampRange ();};func (_gbb Point )Displace (delta Point )Point {return Point {_gbb .X +delta .X ,_gbb .Y +delta .Y }};func (_ced *Matrix )clampRange (){for _dg ,_cee :=range _ced {if _cee > _cac {_c .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_cee ,_cac );
_ced [_dg ]=_cac ;}else if _cee < -_cac {_c .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_cee ,-_cac );_ced [_dg ]=-_cac ;};};};type Point struct{X float64 ;Y float64 ;};func (_ca Matrix )ScalingFactorY ()float64 {return _e .Hypot (_ca [3],_ca [4])};
func (_ec Matrix )Transform (x ,y float64 )(float64 ,float64 ){_cb :=x *_ec [0]+y *_ec [3]+_ec [6];_eca :=x *_ec [1]+y *_ec [4]+_ec [7];return _cb ,_eca ;};func (_fg Matrix )Translation ()(float64 ,float64 ){return _fg [6],_fg [7]};func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};
func (_cegb Matrix )ScalingFactorX ()float64 {return _e .Hypot (_cegb [0],_cegb [1])};func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_ce :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};_ce .clampRange ();return _ce ;};func (_cf Matrix )Inverse ()(Matrix ,bool ){_db ,_gd :=_cf [0],_cf [1];
_ee ,_fa :=_cf [3],_cf [4];_ac ,_dc :=_cf [6],_cf [7];_cd :=_db *_fa -_gd *_ee ;if _e .Abs (_cd )< _dac {return Matrix {},false ;};_ef ,_ccg :=_fa /_cd ,-_gd /_cd ;_cad ,_ed :=-_ee /_cd ,_db /_cd ;_bc :=-(_ef *_ac +_cad *_dc );_bfgc :=-(_ccg *_ac +_ed *_dc );
return NewMatrix (_ef ,_ccg ,_cad ,_ed ,_bc ,_bfgc ),true ;};func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};func (_fed Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_fed .X +t *b .X ,Y :(1-t )*_fed .Y +t *b .Y };
};func (_df *Matrix )Shear (x ,y float64 ){_df .Concat (ShearMatrix (x ,y ))};