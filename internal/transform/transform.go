//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_ag "fmt";_g "github.com/unidoc/unipdf/v3/common";_b "math";);func (_cba Point )String ()string {return _ag .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_cba .X ,_cba .Y );};func (_fg Matrix )String ()string {_d ,_bf ,_ab ,_e ,_fc ,_be :=_fg [0],_fg [1],_fg [3],_fg [4],_fg [6],_fg [7];return _ag .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_d ,_bf ,_ab ,_e ,_fc ,_be );};func (_gd Matrix )Transform (x ,y float64 )(float64 ,float64 ){_def :=x *_gd [0]+y *_gd [3]+_gd [6];_ba :=x *_gd [1]+y *_gd [4]+_gd [7];return _def ,_ba ;};func (_ef Matrix )ScalingFactorX ()float64 {return _b .Hypot (_ef [0],_ef [1])};func (_df *Matrix )clampRange (){for _fd ,_dba :=range _df {if _dba > _ad {_g .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_dba ,_ad );_df [_fd ]=_ad ;}else if _dba < -_ad {_g .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_dba ,-_ad );_df [_fd ]=-_ad ;};};};func (_dd Matrix )Rotate (theta float64 )Matrix {_bfe ,_agf :=_b .Sincos (theta /180.0*_b .Pi );return _dd .Mult (NewMatrix (_agf ,-_bfe ,_bfe ,_agf ,0,0));};func (_de *Matrix )Concat (b Matrix ){*_de =Matrix {b [0]*_de [0]+b [1]*_de [3],b [0]*_de [1]+b [1]*_de [4],0,b [3]*_de [0]+b [4]*_de [3],b [3]*_de [1]+b [4]*_de [4],0,b [6]*_de [0]+b [7]*_de [3]+_de [6],b [6]*_de [1]+b [7]*_de [4]+_de [7],1};_de .clampRange ();};func (_ddc Point )Rotate (theta float64 )Point {_fcf :=_b .Hypot (_ddc .X ,_ddc .Y );_fac :=_b .Atan2 (_ddc .Y ,_ddc .X );_bcg ,_gec :=_b .Sincos (_fac +theta /180.0*_b .Pi );return Point {_fcf *_gec ,_fcf *_bcg };};func (_fb Point )Distance (b Point )float64 {return _b .Hypot (_fb .X -b .X ,_fb .Y -b .Y )};func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};func (_cf Matrix )ScalingFactorY ()float64 {return _b .Hypot (_cf [3],_cf [4])};const _adg =1.0e-6;func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};func (_ff Matrix )Angle ()float64 {_bb :=_b .Atan2 (-_ff [1],_ff [0]);if _bb < 0.0{_bb +=2*_b .Pi ;};return _bb /_b .Pi *180.0;};const _cd =1e-10;func (_fa *Matrix )Shear (x ,y float64 ){_fa .Concat (ShearMatrix (x ,y ))};func (_dg Matrix )Inverse ()(Matrix ,bool ){_ee ,_eb :=_dg [0],_dg [1];_agc ,_abe :=_dg [3],_dg [4];_cb ,_dc :=_dg [6],_dg [7];_ffg :=_ee *_abe -_eb *_agc ;if _b .Abs (_ffg )< _adg {return Matrix {},false ;};_ac ,_ga :=_abe /_ffg ,-_eb /_ffg ;_fff ,_ge :=-_agc /_ffg ,_ee /_ffg ;_bd :=-(_ac *_cb +_fff *_dc );_agb :=-(_ga *_cb +_ge *_dc );return NewMatrix (_ac ,_ga ,_fff ,_ge ,_bd ,_agb ),true ;};func (_c *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_c [0],_c [1]=a ,b ;_c [3],_c [4]=c ,d ;_c [6],_c [7]=tx ,ty ;_c .clampRange ();};func (_age Matrix )Translate (tx ,ty float64 )Matrix {return NewMatrix (_age [0],_age [1],_age [3],_age [4],_age [6]+tx ,_age [7]+ty );};const _ddg =1e-6;func (_bc Matrix )Translation ()(float64 ,float64 ){return _bc [6],_bc [7]};func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};func (_cae *Point )Set (x ,y float64 ){_cae .X ,_cae .Y =x ,y };func (_fe Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_fe .X +t *b .X ,Y :(1-t )*_fe .Y +t *b .Y };};func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_agg :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};_agg .clampRange ();return _agg ;};func RotationMatrix (angle float64 )Matrix {_f :=_b .Cos (angle );_af :=_b .Sin (angle );return NewMatrix (_f ,_af ,-_af ,_f ,0,0);};func (_bca *Point )transformByMatrix (_fcd Matrix ){_bca .X ,_bca .Y =_fcd .Transform (_bca .X ,_bca .Y )};func (_db Matrix )Mult (b Matrix )Matrix {_db .Concat (b );return _db };type Matrix [9]float64 ;const _ad =1e9;func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};func (_ca *Matrix )Clone ()Matrix {return NewMatrix (_ca [0],_ca [1],_ca [3],_ca [4],_ca [6],_ca [7])};func (_gc Matrix )Scale (xScale ,yScale float64 )Matrix {return _gc .Mult (NewMatrix (xScale ,0,0,yScale ,0,0));};func (_afc Point )Displace (delta Point )Point {return Point {_afc .X +delta .X ,_afc .Y +delta .Y }};func (_ce Matrix )Singular ()bool {return _b .Abs (_ce [0]*_ce [4]-_ce [1]*_ce [3])< _cd };func (_bbd *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_deg :=NewMatrix (a ,b ,c ,d ,tx ,ty );_bbd .transformByMatrix (_deg );};func (_gb Matrix )Unrealistic ()bool {_bg ,_aa ,_gbf ,_cg :=_b .Abs (_gb [0]),_b .Abs (_gb [1]),_b .Abs (_gb [3]),_b .Abs (_gb [4]);_abd :=_bg > _ddg &&_cg > _ddg ;_dca :=_aa > _ddg &&_gbf > _ddg ;return !(_abd ||_dca );};func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );};type Point struct{X float64 ;Y float64 ;};