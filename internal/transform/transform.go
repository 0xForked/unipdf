//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_b "fmt";_e "github.com/unidoc/unipdf/v3/common";_f "math";);func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_gc :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};_gc .clampRange ();return _gc ;};func (_bg *Matrix )Concat (b Matrix ){*_bg =Matrix {b [0]*_bg [0]+b [1]*_bg [3],b [0]*_bg [1]+b [1]*_bg [4],0,b [3]*_bg [0]+b [4]*_bg [3],b [3]*_bg [1]+b [4]*_bg [4],0,b [6]*_bg [0]+b [7]*_bg [3]+_bg [6],b [6]*_bg [1]+b [7]*_bg [4]+_bg [7],1};
_bg .clampRange ();};func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};func RotationMatrix (angle float64 )Matrix {_fc :=_f .Cos (angle );_gd :=_f .Sin (angle );return NewMatrix (_fc ,_gd ,-_gd ,_fc ,0,0);};func (_cd *Matrix )Clone ()Matrix {return NewMatrix (_cd [0],_cd [1],_cd [3],_cd [4],_cd [6],_cd [7])};
func (_fe *Point )Set (x ,y float64 ){_fe .X ,_fe .Y =x ,y };func (_dgf Matrix )ScalingFactorX ()float64 {return _f .Hypot (_dgf [0],_dgf [1])};func (_eeg Matrix )Angle ()float64 {_bb :=_f .Atan2 (-_eeg [1],_eeg [0]);if _bb < 0.0{_bb +=2*_f .Pi ;};return _bb /_f .Pi *180.0;
};const _acd =1e9;func (_deg Matrix )Rotate (theta float64 )Matrix {return _deg .Mult (RotationMatrix (theta ))};func (_eb *Matrix )clampRange (){for _abe ,_cf :=range _eb {if _cf > _acd {_e .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_cf ,_acd );
_eb [_abe ]=_acd ;}else if _cf < -_acd {_e .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_cf ,-_acd );_eb [_abe ]=-_acd ;};};};func (_gcb Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_gcb .X +t *b .X ,Y :(1-t )*_gcb .Y +t *b .Y };
};func (_ad *Point )transformByMatrix (_dgb Matrix ){_ad .X ,_ad .Y =_dgb .Transform (_ad .X ,_ad .Y )};func (_eae Matrix )Transform (x ,y float64 )(float64 ,float64 ){_ab :=x *_eae [0]+y *_eae [3]+_eae [6];_dee :=x *_eae [1]+y *_eae [4]+_eae [7];return _ab ,_dee ;
};func (_fgd Matrix )Unrealistic ()bool {_be ,_ebd ,_fba ,_cae :=_f .Abs (_fgd [0]),_f .Abs (_fgd [1]),_f .Abs (_fgd [3]),_f .Abs (_fgd [4]);_ge :=_be > _dca &&_cae > _dca ;_fbd :=_ebd > _dca &&_fba > _dca ;return !(_ge ||_fbd );};func (_fb Matrix )Identity ()bool {return _fb [0]==1&&_fb [1]==0&&_fb [2]==0&&_fb [3]==0&&_fb [4]==1&&_fb [5]==0&&_fb [6]==0&&_fb [7]==0&&_fb [8]==1;
};func (_cfe *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_bad :=NewMatrix (a ,b ,c ,d ,tx ,ty );_cfe .transformByMatrix (_bad );};func (_dg Matrix )Scale (xScale ,yScale float64 )Matrix {return _dg .Mult (ScaleMatrix (xScale ,yScale ))};func (_dfb Point )String ()string {return _b .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_dfb .X ,_dfb .Y );
};const _fcf =1.0e-6;func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};func (_ac *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_ac [0],_ac [1]=a ,b ;_ac [3],_ac [4]=c ,d ;_ac [6],_ac [7]=tx ,ty ;_ac .clampRange ();};func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};
func (_gf Point )Rotate (theta float64 )Point {_fa :=_f .Hypot (_gf .X ,_gf .Y );_dcd :=_f .Atan2 (_gf .Y ,_gf .X );_ec ,_gg :=_f .Sincos (_dcd +theta /180.0*_f .Pi );return Point {_fa *_gg ,_fa *_ec };};func (_ba *Matrix )Shear (x ,y float64 ){_ba .Concat (ShearMatrix (x ,y ))};
func (_ga Matrix )Translate (tx ,ty float64 )Matrix {return _ga .Mult (TranslationMatrix (tx ,ty ))};func (_ca Matrix )ScalingFactorY ()float64 {return _f .Hypot (_ca [3],_ca [4])};func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};
func (_ee Matrix )Singular ()bool {return _f .Abs (_ee [0]*_ee [4]-_ee [1]*_ee [3])< _gaa };func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );
};func (_df Matrix )Mult (b Matrix )Matrix {_df .Concat (b );return _df };func (_ef Matrix )String ()string {_d ,_ea ,_de ,_gcc ,_c ,_eg :=_ef [0],_ef [1],_ef [3],_ef [4],_ef [6],_ef [7];return _b .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_d ,_ea ,_de ,_gcc ,_c ,_eg );
};func (_fcd Point )Displace (delta Point )Point {return Point {_fcd .X +delta .X ,_fcd .Y +delta .Y }};func (_bf Point )Distance (b Point )float64 {return _f .Hypot (_bf .X -b .X ,_bf .Y -b .Y )};func (_fg Matrix )Translation ()(float64 ,float64 ){return _fg [6],_fg [7]};
const _gaa =1e-10;func (_a Matrix )Round (precision float64 )Matrix {for _ff :=range _a {_a [_ff ]=_f .Round (_a [_ff ]/precision )*precision ;};return _a ;};const _dca =1e-6;type Point struct{X float64 ;Y float64 ;};func (_cc Matrix )Inverse ()(Matrix ,bool ){_da ,_eec :=_cc [0],_cc [1];
_dd ,_cdc :=_cc [3],_cc [4];_dc ,_ddf :=_cc [6],_cc [7];_bgd :=_da *_cdc -_eec *_dd ;if _f .Abs (_bgd )< _fcf {return Matrix {},false ;};_cde ,_abg :=_cdc /_bgd ,-_eec /_bgd ;_aca ,_fga :=-_dd /_bgd ,_da /_bgd ;_ace :=-(_cde *_dc +_aca *_ddf );_deb :=-(_abg *_dc +_fga *_ddf );
return NewMatrix (_cde ,_abg ,_aca ,_fga ,_ace ,_deb ),true ;};func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};type Matrix [9]float64 ;