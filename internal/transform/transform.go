//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_e "fmt";_fg "github.com/unidoc/unipdf/v3/common";_b "math";);func (_fd Matrix )Scale (xScale ,yScale float64 )Matrix {return _fd .Mult (ScaleMatrix (xScale ,yScale ))};const _ecf =1e-10;func (_cga Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_cga .X +t *b .X ,Y :(1-t )*_cga .Y +t *b .Y };
};func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};func (_abe Matrix )ScalingFactorX ()float64 {return _b .Hypot (_abe [0],_abe [1])};func (_fbb Matrix )Inverse ()(Matrix ,bool ){_fgc ,_dd :=_fbb [0],_fbb [1];_bag ,_bdb :=_fbb [3],_fbb [4];
_ace ,_fea :=_fbb [6],_fbb [7];_cc :=_fgc *_bdb -_dd *_bag ;if _b .Abs (_cc )< _eff {return Matrix {},false ;};_bda ,_g :=_bdb /_cc ,-_dd /_cc ;_ecc ,_ecff :=-_bag /_cc ,_fgc /_cc ;_eag :=-(_bda *_ace +_ecc *_fea );_gb :=-(_g *_ace +_ecff *_fea );return NewMatrix (_bda ,_g ,_ecc ,_ecff ,_eag ,_gb ),true ;
};const _deg =1e9;func (_bfc Matrix )Angle ()float64 {_ea :=_b .Atan2 (-_bfc [1],_bfc [0]);if _ea < 0.0{_ea +=2*_b .Pi ;};return _ea /_b .Pi *180.0;};func (_effb Point )String ()string {return _e .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_effb .X ,_effb .Y );
};func (_ecg Matrix )Singular ()bool {return _b .Abs (_ecg [0]*_ecg [4]-_ecg [1]*_ecg [3])< _ecf };func (_be Matrix )Transform (x ,y float64 )(float64 ,float64 ){_bac :=x *_be [0]+y *_be [3]+_be [6];_bd :=x *_be [1]+y *_be [4]+_be [7];return _bac ,_bd ;
};const _eff =1.0e-6;func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};const _cgd =1e-6;func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};func (_ee Matrix )Round (precision float64 )Matrix {for _c :=range _ee {_ee [_c ]=_b .Round (_ee [_c ]/precision )*precision ;
};return _ee ;};func (_eeg Matrix )Translate (tx ,ty float64 )Matrix {return _eeg .Mult (TranslationMatrix (tx ,ty ))};func (_bfca Point )Rotate (theta float64 )Point {_eac :=_b .Hypot (_bfca .X ,_bfca .Y );_bc :=_b .Atan2 (_bfca .Y ,_bfca .X );_gbg ,_da :=_b .Sincos (_bc +theta /180.0*_b .Pi );
return Point {_eac *_da ,_eac *_gbg };};func (_bgg Matrix )Unrealistic ()bool {_fgd ,_ce ,_ed ,_cg :=_b .Abs (_bgg [0]),_b .Abs (_bgg [1]),_b .Abs (_bgg [3]),_b .Abs (_bgg [4]);_gbb :=_fgd > _cgd &&_cg > _cgd ;_ccf :=_ce > _cgd &&_ed > _cgd ;return !(_gbb ||_ccf );
};func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};func (_ac *Matrix )Shear (x ,y float64 ){_ac .Concat (ShearMatrix (x ,y ))};type Point struct{X float64 ;Y float64 ;};func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_aa :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};
_aa .clampRange ();return _aa ;};func (_ab Matrix )Rotate (theta float64 )Matrix {return _ab .Mult (RotationMatrix (theta ))};func (_fb Matrix )String ()string {_aaa ,_bf ,_ef ,_ffc ,_dc ,_bg :=_fb [0],_fb [1],_fb [3],_fb [4],_fb [6],_fb [7];return _e .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_aaa ,_bf ,_ef ,_ffc ,_dc ,_bg );
};func (_ag *Matrix )clampRange (){for _ae ,_abf :=range _ag {if _abf > _deg {_fg .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_abf ,_deg );_ag [_ae ]=_deg ;}else if _abf < -_deg {_fg .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_abf ,-_deg );
_ag [_ae ]=-_deg ;};};};func (_aga *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_fef :=NewMatrix (a ,b ,c ,d ,tx ,ty );_aga .transformByMatrix (_fef );};func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );
};func (_cf *Matrix )Concat (b Matrix ){*_cf =Matrix {b [0]*_cf [0]+b [1]*_cf [3],b [0]*_cf [1]+b [1]*_cf [4],0,b [3]*_cf [0]+b [4]*_cf [3],b [3]*_cf [1]+b [4]*_cf [4],0,b [6]*_cf [0]+b [7]*_cf [3]+_cf [6],b [6]*_cf [1]+b [7]*_cf [4]+_cf [7],1};_cf .clampRange ();
};func (_d Matrix )Identity ()bool {return _d [0]==1&&_d [1]==0&&_d [2]==0&&_d [3]==0&&_d [4]==1&&_d [5]==0&&_d [6]==0&&_d [7]==0&&_d [8]==1;};func (_ec Matrix )Translation ()(float64 ,float64 ){return _ec [6],_ec [7]};func (_gd Point )Distance (b Point )float64 {return _b .Hypot (_gd .X -b .X ,_gd .Y -b .Y )};
func (_fda *Point )Set (x ,y float64 ){_fda .X ,_fda .Y =x ,y };func RotationMatrix (angle float64 )Matrix {_ff :=_b .Cos (angle );_a :=_b .Sin (angle );return NewMatrix (_ff ,_a ,-_a ,_ff ,0,0);};type Matrix [9]float64 ;func (_abg Matrix )ScalingFactorY ()float64 {return _b .Hypot (_abg [3],_abg [4])};
func (_age *Point )transformByMatrix (_ge Matrix ){_age .X ,_age .Y =_ge .Transform (_age .X ,_age .Y )};func (_de *Matrix )Clone ()Matrix {return NewMatrix (_de [0],_de [1],_de [3],_de [4],_de [6],_de [7])};func (_ba Matrix )Mult (b Matrix )Matrix {_ba .Concat (b );
return _ba };func (_fe *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_fe [0],_fe [1]=a ,b ;_fe [3],_fe [4]=c ,d ;_fe [6],_fe [7]=tx ,ty ;_fe .clampRange ();};func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};func (_fdc Point )Displace (delta Point )Point {return Point {_fdc .X +delta .X ,_fdc .Y +delta .Y }};
