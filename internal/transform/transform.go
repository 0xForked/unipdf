//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_e "fmt";_f "github.com/unidoc/unipdf/v3/common";_c "math";);const _gc =1e-10;func (_ddd Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_ddd .X +t *b .X ,Y :(1-t )*_ddd .Y +t *b .Y };};type Matrix [9]float64 ;
func (_egd *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_dfg :=NewMatrix (a ,b ,c ,d ,tx ,ty );_egd .transformByMatrix (_dfg );};func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_eb :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};_eb .clampRange ();return _eb ;
};func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};func (_fg Matrix )Scale (xScale ,yScale float64 )Matrix {return _fg .Mult (ScaleMatrix (xScale ,yScale ))};func (_ce Matrix )Singular ()bool {return _c .Abs (_ce [0]*_ce [4]-_ce [1]*_ce [3])< _gc };
func (_dfd Point )Displace (delta Point )Point {return Point {_dfd .X +delta .X ,_dfd .Y +delta .Y }};func (_ef Matrix )Identity ()bool {return _ef [0]==1&&_ef [1]==0&&_ef [2]==0&&_ef [3]==0&&_ef [4]==1&&_ef [5]==0&&_ef [6]==0&&_ef [7]==0&&_ef [8]==1;};
func (_daf *Point )transformByMatrix (_cad Matrix ){_daf .X ,_daf .Y =_cad .Transform (_daf .X ,_daf .Y )};func (_gg Matrix )Translation ()(float64 ,float64 ){return _gg [6],_gg [7]};func (_ced Point )Distance (b Point )float64 {return _c .Hypot (_ced .X -b .X ,_ced .Y -b .Y )};
func (_bc Point )String ()string {return _e .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_bc .X ,_bc .Y );};const _ged =1e9;func (_fd *Matrix )Clone ()Matrix {return NewMatrix (_fd [0],_fd [1],_fd [3],_fd [4],_fd [6],_fd [7])};
func (_bf Point )Rotate (theta float64 )Point {_ee :=_c .Hypot (_bf .X ,_bf .Y );_aa :=_c .Atan2 (_bf .Y ,_bf .X );_dff ,_ega :=_c .Sincos (_aa +theta /180.0*_c .Pi );return Point {_ee *_ega ,_ee *_dff };};func (_eff *Matrix )Concat (b Matrix ){*_eff =Matrix {b [0]*_eff [0]+b [1]*_eff [3],b [0]*_eff [1]+b [1]*_eff [4],0,b [3]*_eff [0]+b [4]*_eff [3],b [3]*_eff [1]+b [4]*_eff [4],0,b [6]*_eff [0]+b [7]*_eff [3]+_eff [6],b [6]*_eff [1]+b [7]*_eff [4]+_eff [7],1};
_eff .clampRange ();};func (_dd Matrix )ScalingFactorX ()float64 {return _c .Hypot (_dd [0],_dd [1])};func (_bg Matrix )Angle ()float64 {_dc :=_c .Atan2 (-_bg [1],_bg [0]);if _dc < 0.0{_dc +=2*_c .Pi ;};return _dc /_c .Pi *180.0;};func (_eg Matrix )Unrealistic ()bool {_gce ,_effg ,_df ,_cea :=_c .Abs (_eg [0]),_c .Abs (_eg [1]),_c .Abs (_eg [3]),_c .Abs (_eg [4]);
_effgg :=_gce > _dgd &&_cea > _dgd ;_cd :=_effg > _dgd &&_df > _dgd ;return !(_effgg ||_cd );};func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};func (_gd *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_gd [0],_gd [1]=a ,b ;_gd [3],_gd [4]=c ,d ;
_gd [6],_gd [7]=tx ,ty ;_gd .clampRange ();};func (_gb Matrix )Translate (tx ,ty float64 )Matrix {return _gb .Mult (TranslationMatrix (tx ,ty ))};func (_ec Matrix )Transform (x ,y float64 )(float64 ,float64 ){_fdg :=x *_ec [0]+y *_ec [3]+_ec [6];_fec :=x *_ec [1]+y *_ec [4]+_ec [7];
return _fdg ,_fec ;};func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};func (_ad Matrix )ScalingFactorY ()float64 {return _c .Hypot (_ad [3],_ad [4])};func RotationMatrix (angle float64 )Matrix {_b :=_c .Cos (angle );_fa :=_c .Sin (angle );
return NewMatrix (_b ,_fa ,-_fa ,_b ,0,0);};const _bbe =1.0e-6;func (_bb *Matrix )Shear (x ,y float64 ){_bb .Concat (ShearMatrix (x ,y ))};type Point struct{X float64 ;Y float64 ;};func (_fb Matrix )Round (precision float64 )Matrix {for _ca :=range _fb {_fb [_ca ]=_c .Round (_fb [_ca ]/precision )*precision ;
};return _fb ;};func (_da Matrix )String ()string {_efd ,_g ,_ba ,_ea ,_dac ,_fe :=_da [0],_da [1],_da [3],_da [4],_da [6],_da [7];return _e .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_efd ,_g ,_ba ,_ea ,_dac ,_fe );
};func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};func (_de *Point )Set (x ,y float64 ){_de .X ,_de .Y =x ,y };func (_a Matrix )Rotate (theta float64 )Matrix {return _a .Mult (RotationMatrix (theta ))};func (_cc *Matrix )clampRange (){for _bbb ,_aca :=range _cc {if _aca > _ged {_f .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_aca ,_ged );
_cc [_bbb ]=_ged ;}else if _aca < -_ged {_f .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_aca ,-_ged );_cc [_bbb ]=-_ged ;};};};func (_ge Matrix )Inverse ()(Matrix ,bool ){_ac ,_fc :=_ge [0],_ge [1];_ggg ,_dbf :=_ge [3],_ge [4];
_dg ,_ae :=_ge [6],_ge [7];_ecg :=_ac *_dbf -_fc *_ggg ;if _c .Abs (_ecg )< _bbe {return Matrix {},false ;};_gga ,_bgd :=_dbf /_ecg ,-_fc /_ecg ;_fce ,_bgb :=-_ggg /_ecg ,_ac /_ecg ;_ga :=-(_gga *_dg +_fce *_ae );_fbc :=-(_bgd *_dg +_bgb *_ae );return NewMatrix (_gga ,_bgd ,_fce ,_bgb ,_ga ,_fbc ),true ;
};func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );};func (_db Matrix )Mult (b Matrix )Matrix {_db .Concat (b );
return _db };const _dgd =1e-6;