//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_g "fmt";_b "github.com/unidoc/unipdf/v3/common";_d "math";);func (_bc Matrix )Round (precision float64 )Matrix {for _a :=range _bc {_bc [_a ]=_d .Round (_bc [_a ]/precision )*precision ;};return _bc ;};func (_ff Matrix )Angle ()float64 {_gd :=_d .Atan2 (-_ff [1],_ff [0]);
if _gd < 0.0{_gd +=2*_d .Pi ;};return _gd /_d .Pi *180.0;};func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};func (_ad *Point )transformByMatrix (_edg Matrix ){_ad .X ,_ad .Y =_edg .Transform (_ad .X ,_ad .Y )};const _fgc =1e-6;func (_af Matrix )Singular ()bool {return _d .Abs (_af [0]*_af [4]-_af [1]*_af [3])< _eb };
func (_cb *Matrix )Clone ()Matrix {return NewMatrix (_cb [0],_cb [1],_cb [3],_cb [4],_cb [6],_cb [7])};func (_beed *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_fgf :=NewMatrix (a ,b ,c ,d ,tx ,ty );_beed .transformByMatrix (_fgf );};const _eb =1e-10;
const _gbe =1.0e-6;func (_cd *Point )Set (x ,y float64 ){_cd .X ,_cd .Y =x ,y };func (_ddg Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_ddg .X +t *b .X ,Y :(1-t )*_ddg .Y +t *b .Y };};func (_cc *Matrix )Concat (b Matrix ){*_cc =Matrix {b [0]*_cc [0]+b [1]*_cc [3],b [0]*_cc [1]+b [1]*_cc [4],0,b [3]*_cc [0]+b [4]*_cc [3],b [3]*_cc [1]+b [4]*_cc [4],0,b [6]*_cc [0]+b [7]*_cc [3]+_cc [6],b [6]*_cc [1]+b [7]*_cc [4]+_cc [7],1};
_cc .clampRange ();};type Matrix [9]float64 ;func (_ea Matrix )Translation ()(float64 ,float64 ){return _ea [6],_ea [7]};func (_ge Point )String ()string {return _g .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_ge .X ,_ge .Y );
};func (_bd Point )Displace (delta Point )Point {return Point {_bd .X +delta .X ,_bd .Y +delta .Y }};func (_ed *Matrix )clampRange (){for _dafb ,_db :=range _ed {if _db > _fb {_b .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_db ,_fb );
_ed [_dafb ]=_fb ;}else if _db < -_fb {_b .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_db ,-_fb );_ed [_dafb ]=-_fb ;};};};func (_df *Matrix )Shear (x ,y float64 ){_df .Concat (ShearMatrix (x ,y ))};func (_fadf Point )Rotate (theta float64 )Point {_gfa :=_d .Hypot (_fadf .X ,_fadf .Y );
_bed :=_d .Atan2 (_fadf .Y ,_fadf .X );_bfc ,_efg :=_d .Sincos (_bed +theta /180.0*_d .Pi );return Point {_gfa *_efg ,_gfa *_bfc };};type Point struct{X float64 ;Y float64 ;};func (_bff Matrix )Inverse ()(Matrix ,bool ){_eg ,_gc :=_bff [0],_bff [1];_afc ,_eba :=_bff [3],_bff [4];
_ce ,_gb :=_bff [6],_bff [7];_cgg :=_eg *_eba -_gc *_afc ;if _d .Abs (_cgg )< _gbe {return Matrix {},false ;};_cee ,_daf :=_eba /_cgg ,-_gc /_cgg ;_bee ,_ffd :=-_afc /_cgg ,_eg /_cgg ;_fae :=-(_cee *_ce +_bee *_gb );_fd :=-(_daf *_ce +_ffd *_gb );return NewMatrix (_cee ,_daf ,_bee ,_ffd ,_fae ,_fd ),true ;
};func (_dca Matrix )Rotate (theta float64 )Matrix {return _dca .Mult (RotationMatrix (theta ))};func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};
func (_cg Matrix )Translate (tx ,ty float64 )Matrix {return _cg .Mult (TranslationMatrix (tx ,ty ))};func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );
};func (_bcd Matrix )ScalingFactorX ()float64 {return _d .Hypot (_bcd [0],_bcd [1])};func (_gfe Matrix )Mult (b Matrix )Matrix {_gfe .Concat (b );return _gfe };func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_e :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};
_e .clampRange ();return _e ;};func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};func (_gf *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_gf [0],_gf [1]=a ,b ;_gf [3],_gf [4]=c ,d ;_gf [6],_gf [7]=tx ,ty ;_gf .clampRange ();};func (_dda Point )Distance (b Point )float64 {return _d .Hypot (_dda .X -b .X ,_dda .Y -b .Y )};
func (_bfd Matrix )ScalingFactorY ()float64 {return _d .Hypot (_bfd [3],_bfd [4])};func RotationMatrix (angle float64 )Matrix {_da :=_d .Cos (angle );_fe :=_d .Sin (angle );return NewMatrix (_da ,_fe ,-_fe ,_da ,0,0);};func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};
func (_be Matrix )String ()string {_c ,_dc ,_de ,_ae ,_dac ,_bf :=_be [0],_be [1],_be [3],_be [4],_be [6],_be [7];return _g .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_c ,_dc ,_de ,_ae ,_dac ,_bf );
};func (_ef Matrix )Scale (xScale ,yScale float64 )Matrix {return _ef .Mult (ScaleMatrix (xScale ,yScale ))};func (_efd Matrix )Transform (x ,y float64 )(float64 ,float64 ){_fg :=x *_efd [0]+y *_efd [3]+_efd [6];_dea :=x *_efd [1]+y *_efd [4]+_efd [7];
return _fg ,_dea ;};func (_fa Matrix )Identity ()bool {return _fa [0]==1&&_fa [1]==0&&_fa [2]==0&&_fa [3]==0&&_fa [4]==1&&_fa [5]==0&&_fa [6]==0&&_fa [7]==0&&_fa [8]==1;};const _fb =1e9;func (_ab Matrix )Unrealistic ()bool {_fad ,_eac ,_dcd ,_ca :=_d .Abs (_ab [0]),_d .Abs (_ab [1]),_d .Abs (_ab [3]),_d .Abs (_ab [4]);
_dd :=_fad > _fgc &&_ca > _fgc ;_fga :=_eac > _fgc &&_dcd > _fgc ;return !(_dd ||_fga );};