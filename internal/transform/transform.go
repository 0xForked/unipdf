//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_f "fmt";_e "github.com/unidoc/unipdf/v3/common";_d "math";);func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );};
func (_a *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_a [0],_a [1]=a ,b ;_a [3],_a [4]=c ,d ;_a [6],_a [7]=tx ,ty ;_a .clampRange ();};const _afd =1.0e-6;func (_ad Matrix )Inverse ()(Matrix ,bool ){_cbf ,_bag :=_ad [0],_ad [1];_bgf ,_ege :=_ad [3],_ad [4];
_dg ,_ece :=_ad [6],_ad [7];_fe :=_cbf *_ege -_bag *_bgf ;if _d .Abs (_fe )< _afd {return Matrix {},false ;};_efa ,_ce :=_ege /_fe ,-_bag /_fe ;_bde ,_cfa :=-_bgf /_fe ,_cbf /_fe ;_bcf :=-(_efa *_dg +_bde *_ece );_ga :=-(_ce *_dg +_cfa *_ece );return NewMatrix (_efa ,_ce ,_bde ,_cfa ,_bcf ,_ga ),true ;
};func (_cgb Matrix )Transform (x ,y float64 )(float64 ,float64 ){_af :=x *_cgb [0]+y *_cgb [3]+_cgb [6];_fce :=x *_cgb [1]+y *_cgb [4]+_cgb [7];return _af ,_fce ;};func (_bc Matrix )Singular ()bool {return _d .Abs (_bc [0]*_bc [4]-_bc [1]*_bc [3])< _ef };
func (_eg *Matrix )Clone ()Matrix {return NewMatrix (_eg [0],_eg [1],_eg [3],_eg [4],_eg [6],_eg [7])};func (_da Matrix )ScalingFactorX ()float64 {return _d .Hypot (_da [0],_da [1])};func (_gd Matrix )Translation ()(float64 ,float64 ){return _gd [6],_gd [7]};
const _ef =1e-10;const _add =1e-6;func (_gf Matrix )Mult (b Matrix )Matrix {_gf .Concat (b );return _gf };func RotationMatrix (angle float64 )Matrix {_gb :=_d .Cos (angle );_b :=_d .Sin (angle );return NewMatrix (_gb ,_b ,-_b ,_gb ,0,0);};func (_fec Point )Rotate (theta float64 )Point {_eba :=_d .Hypot (_fec .X ,_fec .Y );
_gfc :=_d .Atan2 (_fec .Y ,_fec .X );_ebg ,_dgb :=_d .Sincos (_gfc +theta /180.0*_d .Pi );return Point {_eba *_dgb ,_eba *_ebg };};const _dd =1e9;func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};func (_cg *Matrix )Shear (x ,y float64 ){_cg .Concat (ShearMatrix (x ,y ))};
func (_gfg Point )String ()string {return _f .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_gfg .X ,_gfg .Y );};func (_ea Matrix )String ()string {_be ,_bd ,_bg ,_bgd ,_bb ,_ba :=_ea [0],_ea [1],_ea [3],_ea [4],_ea [6],_ea [7];
return _f .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_be ,_bd ,_bg ,_bgd ,_bb ,_ba );
};func (_efb Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_efb .X +t *b .X ,Y :(1-t )*_efb .Y +t *b .Y };};func (_ec Matrix )Scale (xScale ,yScale float64 )Matrix {return _ec .Mult (ScaleMatrix (xScale ,yScale ))};func (_gbe *Point )transformByMatrix (_ega Matrix ){_gbe .X ,_gbe .Y =_ega .Transform (_gbe .X ,_gbe .Y )};
func (_ca *Matrix )Concat (b Matrix ){*_ca =Matrix {b [0]*_ca [0]+b [1]*_ca [3],b [0]*_ca [1]+b [1]*_ca [4],0,b [3]*_ca [0]+b [4]*_ca [3],b [3]*_ca [1]+b [4]*_ca [4],0,b [6]*_ca [0]+b [7]*_ca [3]+_ca [6],b [6]*_ca [1]+b [7]*_ca [4]+_ca [7],1};_ca .clampRange ();
};func (_bf *Point )Set (x ,y float64 ){_bf .X ,_bf .Y =x ,y };func (_fa Matrix )Identity ()bool {return _fa [0]==1&&_fa [1]==0&&_fa [2]==0&&_fa [3]==0&&_fa [4]==1&&_fa [5]==0&&_fa [6]==0&&_fa [7]==0&&_fa [8]==1;};func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};
func (_bgb Matrix )Unrealistic ()bool {_fd ,_fb ,_eb ,_cfaa :=_d .Abs (_bgb [0]),_d .Abs (_bgb [1]),_d .Abs (_bgb [3]),_d .Abs (_bgb [4]);_adc :=_fd > _add &&_cfaa > _add ;_gfd :=_fb > _add &&_eb > _add ;return !(_adc ||_gfd );};func (_ed *Matrix )clampRange (){for _agf ,_adb :=range _ed {if _adb > _dd {_e .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_adb ,_dd );
_ed [_agf ]=_dd ;}else if _adb < -_dd {_e .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_adb ,-_dd );_ed [_agf ]=-_dd ;};};};func (_df Point )Displace (delta Point )Point {return Point {_df .X +delta .X ,_df .Y +delta .Y }};
func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};func (_fc Matrix )Rotate (theta float64 )Matrix {return _fc .Mult (RotationMatrix (theta ))};func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};
func (_c Matrix )Round (precision float64 )Matrix {for _db :=range _c {_c [_db ]=_d .Round (_c [_db ]/precision )*precision ;};return _c ;};func (_afa *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_ee :=NewMatrix (a ,b ,c ,d ,tx ,ty );_afa .transformByMatrix (_ee );
};func (_cf Matrix )Angle ()float64 {_bgc :=_d .Atan2 (-_cf [1],_cf [0]);if _bgc < 0.0{_bgc +=2*_d .Pi ;};return _bgc /_d .Pi *180.0;};type Matrix [9]float64 ;func (_ag Matrix )Translate (tx ,ty float64 )Matrix {return _ag .Mult (TranslationMatrix (tx ,ty ))};
func (_cb Matrix )ScalingFactorY ()float64 {return _d .Hypot (_cb [3],_cb [4])};type Point struct{X float64 ;Y float64 ;};func (_ada Point )Distance (b Point )float64 {return _d .Hypot (_ada .X -b .X ,_ada .Y -b .Y )};func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_fg :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};
_fg .clampRange ();return _fg ;};