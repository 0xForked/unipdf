//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package sighandler implements digital signature handlers for PDF signature validation and signing.
package sighandler ;import (_f "bytes";_e "crypto";_aab "crypto/rand";_dd "crypto/rsa";_cc "crypto/x509";_g "crypto/x509/pkix";_aa "encoding/asn1";_cf "errors";_eg "fmt";_cfb "github.com/unidoc/pkcs7";_dc "github.com/unidoc/timestamp";_dcb "github.com/unidoc/unipdf/v3/core";_b "github.com/unidoc/unipdf/v3/model";_ca "hash";_c "io";_fg "io/ioutil";_ae "net/http";_a "time";);

// InitSignature initialises the PdfSignature.
func (_bf *adobePKCS7Detached )InitSignature (sig *_b .PdfSignature )error {if !_bf ._ba {if _bf ._bd ==nil {return _cf .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");};if _bf ._ge ==nil {return _cf .New ("\u0070\u0072\u0069\u0076\u0061\u0074\u0065\u004b\u0065\u0079\u0020m\u0075\u0073\u0074\u0020\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c");};};_de :=*_bf ;sig .Handler =&_de ;sig .Filter =_dcb .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");sig .SubFilter =_dcb .MakeName ("\u0061\u0064\u0062\u0065.p\u006b\u0063\u0073\u0037\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064");sig .Reference =nil ;_eb ,_egb :=_de .NewDigest (sig );if _egb !=nil {return _egb ;};_eb .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));return _de .Sign (sig ,_eb );};func (_baf *adobePKCS7Detached )getCertificate (_aeb *_b .PdfSignature )(*_cc .Certificate ,error ){if _baf ._bd !=nil {return _baf ._bd ,nil ;};var _cb []byte ;switch _fe :=_aeb .Cert .(type ){case *_dcb .PdfObjectString :_cb =_fe .Bytes ();case *_dcb .PdfObjectArray :if _fe .Len ()==0{return nil ,_cf .New ("\u006e\u006f\u0020s\u0069\u0067\u006e\u0061t\u0075\u0072\u0065\u0020\u0063\u0065\u0072t\u0069\u0066\u0069\u0063\u0061\u0074\u0065\u0073\u0020\u0066\u006f\u0075\u006e\u0064");};for _ ,_da :=range _fe .Elements (){_af ,_cfbc :=_dcb .GetString (_da );if !_cfbc {return nil ,_eg .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0065\u0072\u0074\u0069\u0066\u0069\u0063\u0061\u0074\u0065\u0020\u006f\u0062j\u0065\u0063\u0074\u0020\u0074\u0079p\u0065\u0020\u0069\u006e\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065 \u0063\u0065r\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u0063h\u0061\u0069\u006e\u003a\u0020\u0025\u0054",_da );};_cb =append (_cb ,_af .Bytes ()...);};default:return nil ,_eg .Errorf ("\u0069n\u0076\u0061l\u0069\u0064\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072e\u0020\u0063\u0065\u0072\u0074\u0069f\u0069\u0063\u0061\u0074\u0065\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054",_fe );};_bad ,_dce :=_cc .ParseCertificates (_cb );if _dce !=nil {return nil ,_dce ;};return _bad [0],nil ;};type docTimeStamp struct{_ecc string ;_bbc _e .Hash ;};

// NewDigest creates a new digest.
func (_bdc *adobePKCS7Detached )NewDigest (sig *_b .PdfSignature )(_b .Hasher ,error ){return _f .NewBuffer (nil ),nil ;};type timestampInfo struct{Version int ;Policy _aa .RawValue ;MessageImprint struct{HashAlgorithm _g .AlgorithmIdentifier ;HashedMessage []byte ;};SerialNumber _aa .RawValue ;GeneralizedTime _a .Time ;};type adobePKCS7Detached struct{_ge *_dd .PrivateKey ;_bd *_cc .Certificate ;_ba bool ;_ad int ;};

// Validate validates PdfSignature.
func (_ff *adobeX509RSASHA1 )Validate (sig *_b .PdfSignature ,digest _b .Hasher )(_b .SignatureValidationResult ,error ){_gc ,_dee :=_ff .getCertificate (sig );if _dee !=nil {return _b .SignatureValidationResult {},_dee ;};_bdd :=sig .Contents .Bytes ();var _cce []byte ;if _ ,_cceb :=_aa .Unmarshal (_bdd ,&_cce );_cceb !=nil {return _b .SignatureValidationResult {},_cceb ;};_fega ,_gd :=digest .(_ca .Hash );if !_gd {return _b .SignatureValidationResult {},_cf .New ("\u0068a\u0073h\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_bec ,_ :=_fede (_gc .SignatureAlgorithm );if _cbc :=_dd .VerifyPKCS1v15 (_gc .PublicKey .(*_dd .PublicKey ),_bec ,_fega .Sum (nil ),_cce );_cbc !=nil {return _b .SignatureValidationResult {},_cbc ;};return _b .SignatureValidationResult {IsSigned :true ,IsVerified :true },nil ;};

// NewDigest creates a new digest.
func (_efc *docTimeStamp )NewDigest (sig *_b .PdfSignature )(_b .Hasher ,error ){return _f .NewBuffer (nil ),nil ;};

// NewDigest creates a new digest.
func (_dag *adobeX509RSASHA1 )NewDigest (sig *_b .PdfSignature )(_b .Hasher ,error ){_gec ,_dbd :=_dag .getCertificate (sig );if _dbd !=nil {return nil ,_dbd ;};_ecf ,_ :=_fede (_gec .SignatureAlgorithm );return _ecf .New (),nil ;};

// Sign sets the Contents fields for the PdfSignature.
func (_cfe *docTimeStamp )Sign (sig *_b .PdfSignature ,digest _b .Hasher )error {_ddc :=digest .(*_f .Buffer );_ceef :=_cfe ._bbc .New ();if _ ,_ecb :=_c .Copy (_ceef ,_ddc );_ecb !=nil {return _ecb ;};_bc :=_ceef .Sum (nil );_edd :=_dc .Request {HashAlgorithm :_cfe ._bbc ,HashedMessage :_bc ,Certificates :true ,Extensions :nil ,ExtraExtensions :nil };_ea ,_dcf :=_edd .Marshal ();if _dcf !=nil {return _dcf ;};_ac ,_dcf :=_ae .Post (_cfe ._ecc ,"a\u0070\u0070\u006c\u0069\u0063\u0061t\u0069\u006f\u006e\u002f\u0074\u0069\u006d\u0065\u0073t\u0061\u006d\u0070-\u0071u\u0065\u0072\u0079",_f .NewBuffer (_ea ));if _dcf !=nil {return _dcf ;};defer _ac .Body .Close ();_gfe ,_dcf :=_fg .ReadAll (_ac .Body );if _dcf !=nil {return _dcf ;};if _ac .StatusCode !=_ae .StatusOK {return _eg .Errorf ("\u0068\u0074\u0074\u0070\u0020\u0073\u0074\u0061\u0074\u0075\u0073\u0020\u0063\u006f\u0064e\u0020n\u006f\u0074\u0020\u006f\u006b\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0064\u0029",_ac .StatusCode );};var _adf struct{Version _aa .RawValue ;Content _aa .RawValue ;};_ ,_dcf =_aa .Unmarshal (_gfe ,&_adf );if _dcf !=nil {return _dcf ;};sig .Contents =_dcb .MakeHexString (string (_adf .Content .FullBytes ));return nil ;};

// SignFunc represents a custom signing function. The function should return
// the computed signature.
type SignFunc func (_ebc *_b .PdfSignature ,_gb _b .Hasher )([]byte ,error );

// Validate validates PdfSignature.
func (_fgaa *docTimeStamp )Validate (sig *_b .PdfSignature ,digest _b .Hasher )(_b .SignatureValidationResult ,error ){_cfbb :=sig .Contents .Bytes ();_gee ,_abf :=_cfb .Parse (_cfbb );if _abf !=nil {return _b .SignatureValidationResult {},_abf ;};if _abf =_gee .Verify ();_abf !=nil {return _b .SignatureValidationResult {},_abf ;};var _gafg timestampInfo ;_ ,_abf =_aa .Unmarshal (_gee .Content ,&_gafg );if _abf !=nil {return _b .SignatureValidationResult {},_abf ;};_bfb ,_abf :=_gagc (_gafg .MessageImprint .HashAlgorithm .Algorithm );if _abf !=nil {return _b .SignatureValidationResult {},_abf ;};_bbd :=_bfb .New ();_beg :=digest .(*_f .Buffer );_bbd .Write (_beg .Bytes ());_cee :=_bbd .Sum (nil );_cac :=_b .SignatureValidationResult {IsSigned :true ,IsVerified :_f .Equal (_cee ,_gafg .MessageImprint .HashedMessage ),GeneralizedTime :_gafg .GeneralizedTime };return _cac ,nil ;};func _fede (_feg _cc .SignatureAlgorithm )(_e .Hash ,bool ){return _e .SHA1 ,true };

// Sign sets the Contents fields for the PdfSignature.
func (_ebd *adobeX509RSASHA1 )Sign (sig *_b .PdfSignature ,digest _b .Hasher )error {var _cef []byte ;var _baa error ;if _ebd ._gac !=nil {_cef ,_baa =_ebd ._gac (sig ,digest );if _baa !=nil {return _baa ;};}else {_ceb ,_caa :=digest .(_ca .Hash );if !_caa {return _cf .New ("\u0068a\u0073h\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_afd ,_ :=_fede (_ebd ._gag .SignatureAlgorithm );_cef ,_baa =_dd .SignPKCS1v15 (_aab .Reader ,_ebd ._ab ,_afd ,_ceb .Sum (nil ));if _baa !=nil {return _baa ;};};_cef ,_baa =_aa .Marshal (_cef );if _baa !=nil {return _baa ;};sig .Contents =_dcb .MakeHexString (string (_cef ));return nil ;};func (_fd *docTimeStamp )getCertificate (_fec *_b .PdfSignature )(*_cc .Certificate ,error ){var _gf []byte ;switch _bdcf :=_fec .Cert .(type ){case *_dcb .PdfObjectString :_gf =_bdcf .Bytes ();case *_dcb .PdfObjectArray :if _bdcf .Len ()==0{return nil ,_cf .New ("\u006e\u006f\u0020s\u0069\u0067\u006e\u0061t\u0075\u0072\u0065\u0020\u0063\u0065\u0072t\u0069\u0066\u0069\u0063\u0061\u0074\u0065\u0073\u0020\u0066\u006f\u0075\u006e\u0064");};for _ ,_geg :=range _bdcf .Elements (){_ebgd ,_dg :=_dcb .GetString (_geg );if !_dg {return nil ,_eg .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0065\u0072\u0074\u0069\u0066\u0069\u0063\u0061\u0074\u0065\u0020\u006f\u0062j\u0065\u0063\u0074\u0020\u0074\u0079p\u0065\u0020\u0069\u006e\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065 \u0063\u0065r\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u0063h\u0061\u0069\u006e\u003a\u0020\u0025\u0054",_geg );};_gf =append (_gf ,_ebgd .Bytes ()...);};default:return nil ,_eg .Errorf ("\u0069n\u0076\u0061l\u0069\u0064\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072e\u0020\u0063\u0065\u0072\u0074\u0069f\u0069\u0063\u0061\u0074\u0065\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054",_bdcf );};_cg ,_cfa :=_cc .ParseCertificates (_gf );if _cfa !=nil {return nil ,_cfa ;};return _cg [0],nil ;};

// Sign sets the Contents fields.
func (_fa *adobePKCS7Detached )Sign (sig *_b .PdfSignature ,digest _b .Hasher )error {if _fa ._ba {_fed :=_fa ._ad ;if _fed <=0{_fed =8192;};sig .Contents =_dcb .MakeHexString (string (make ([]byte ,_fed )));return nil ;};_ga :=digest .(*_f .Buffer );_adg ,_ebg :=_cfb .NewSignedData (_ga .Bytes ());if _ebg !=nil {return _ebg ;};if _gae :=_adg .AddSigner (_fa ._bd ,_fa ._ge ,_cfb .SignerInfoConfig {});_gae !=nil {return _gae ;};_adg .Detach ();_ed ,_ebg :=_adg .Finish ();if _ebg !=nil {return _ebg ;};_cec :=make ([]byte ,8192);copy (_cec ,_ed );sig .Contents =_dcb .MakeHexString (string (_cec ));return nil ;};

// NewAdobeX509RSASHA1Custom creates a new Adobe.PPKMS/Adobe.PPKLite adbe.x509.rsa_sha1 signature handler
// with a custom signing function. Both parameters may be nil for the signature validation.
func NewAdobeX509RSASHA1Custom (certificate *_cc .Certificate ,signFunc SignFunc )(_b .SignatureHandler ,error ){return &adobeX509RSASHA1 {_gag :certificate ,_gac :signFunc },nil ;};

// NewEmptyAdobePKCS7Detached creates a new Adobe.PPKMS/Adobe.PPKLite adbe.pkcs7.detached
// signature handler. The generated signature is empty and of size signatureLen.
// The signatureLen parameter can be 0 for the signature validation.
func NewEmptyAdobePKCS7Detached (signatureLen int )(_b .SignatureHandler ,error ){return &adobePKCS7Detached {_ba :true ,_ad :signatureLen },nil ;};

// Validate validates PdfSignature.
func (_ce *adobePKCS7Detached )Validate (sig *_b .PdfSignature ,digest _b .Hasher )(_b .SignatureValidationResult ,error ){_df :=sig .Contents .Bytes ();_ef ,_bfc :=_cfb .Parse (_df );if _bfc !=nil {return _b .SignatureValidationResult {},_bfc ;};_afg :=digest .(*_f .Buffer );_ef .Content =_afg .Bytes ();if _bfc =_ef .Verify ();_bfc !=nil {return _b .SignatureValidationResult {},_bfc ;};return _b .SignatureValidationResult {IsSigned :true ,IsVerified :true },nil ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature
func (_dcc *adobePKCS7Detached )IsApplicable (sig *_b .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0061\u0064\u0062\u0065.p\u006b\u0063\u0073\u0037\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064";};

// NewAdobePKCS7Detached creates a new Adobe.PPKMS/Adobe.PPKLite adbe.pkcs7.detached signature handler.
// Both parameters may be nil for the signature validation.
func NewAdobePKCS7Detached (privateKey *_dd .PrivateKey ,certificate *_cc .Certificate )(_b .SignatureHandler ,error ){return &adobePKCS7Detached {_bd :certificate ,_ge :privateKey },nil ;};

// NewAdobeX509RSASHA1 creates a new Adobe.PPKMS/Adobe.PPKLite adbe.x509.rsa_sha1 signature handler.
// Both parameters may be nil for the signature validation.
func NewAdobeX509RSASHA1 (privateKey *_dd .PrivateKey ,certificate *_cc .Certificate )(_b .SignatureHandler ,error ){return &adobeX509RSASHA1 {_gag :certificate ,_ab :privateKey },nil ;};func _gagc (_fc _aa .ObjectIdentifier )(_e .Hash ,error ){switch {case _fc .Equal (_cfb .OIDDigestAlgorithmSHA1 ),_fc .Equal (_cfb .OIDDigestAlgorithmECDSASHA1 ),_fc .Equal (_cfb .OIDDigestAlgorithmDSA ),_fc .Equal (_cfb .OIDDigestAlgorithmDSASHA1 ),_fc .Equal (_cfb .OIDEncryptionAlgorithmRSA ):return _e .SHA1 ,nil ;case _fc .Equal (_cfb .OIDDigestAlgorithmSHA256 ),_fc .Equal (_cfb .OIDDigestAlgorithmECDSASHA256 ):return _e .SHA256 ,nil ;case _fc .Equal (_cfb .OIDDigestAlgorithmSHA384 ),_fc .Equal (_cfb .OIDDigestAlgorithmECDSASHA384 ):return _e .SHA384 ,nil ;case _fc .Equal (_cfb .OIDDigestAlgorithmSHA512 ),_fc .Equal (_cfb .OIDDigestAlgorithmECDSASHA512 ):return _e .SHA512 ,nil ;};return _e .Hash (0),_cfb .ErrUnsupportedAlgorithm ;};

// NewDocTimeStamp creates a new DocTimeStamp signature handler.
// The timestampServerURL parameter can be empty string for the signature validation.
// The hashAlgorithm parameter can be crypto.SHA1, crypto.SHA256, crypto.SHA384, crypto.SHA512.
func NewDocTimeStamp (timestampServerURL string ,hashAlgorithm _e .Hash )(_b .SignatureHandler ,error ){return &docTimeStamp {_ecc :timestampServerURL ,_bbc :hashAlgorithm },nil ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_eef *adobeX509RSASHA1 )IsApplicable (sig *_b .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0061d\u0062e\u002e\u0078\u0035\u0030\u0039.\u0072\u0073a\u005f\u0073\u0068\u0061\u0031";};func (_ec *adobeX509RSASHA1 )getCertificate (_cfg *_b .PdfSignature )(*_cc .Certificate ,error ){if _ec ._gag !=nil {return _ec ._gag ,nil ;};var _gaf []byte ;switch _fgg :=_cfg .Cert .(type ){case *_dcb .PdfObjectString :_gaf =_fgg .Bytes ();case *_dcb .PdfObjectArray :if _fgg .Len ()==0{return nil ,_cf .New ("\u006e\u006f\u0020s\u0069\u0067\u006e\u0061t\u0075\u0072\u0065\u0020\u0063\u0065\u0072t\u0069\u0066\u0069\u0063\u0061\u0074\u0065\u0073\u0020\u0066\u006f\u0075\u006e\u0064");};for _ ,_db :=range _fgg .Elements (){_gbe ,_gagg :=_dcb .GetString (_db );if !_gagg {return nil ,_eg .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0065\u0072\u0074\u0069\u0066\u0069\u0063\u0061\u0074\u0065\u0020\u006f\u0062j\u0065\u0063\u0074\u0020\u0074\u0079p\u0065\u0020\u0069\u006e\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065 \u0063\u0065r\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u0063h\u0061\u0069\u006e\u003a\u0020\u0025\u0054",_db );};_gaf =append (_gaf ,_gbe .Bytes ()...);};default:return nil ,_eg .Errorf ("\u0069n\u0076\u0061l\u0069\u0064\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072e\u0020\u0063\u0065\u0072\u0074\u0069f\u0069\u0063\u0061\u0074\u0065\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054",_fgg );};_ee ,_bg :=_cc .ParseCertificates (_gaf );if _bg !=nil {return nil ,_bg ;};return _ee [0],nil ;};type adobeX509RSASHA1 struct{_ab *_dd .PrivateKey ;_gag *_cc .Certificate ;_gac SignFunc ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_fef *docTimeStamp )IsApplicable (sig *_b .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0045\u0054\u0053I\u002e\u0052\u0046\u0043\u0033\u0031\u0036\u0031";};

// InitSignature initialises the PdfSignature.
func (_cecd *adobeX509RSASHA1 )InitSignature (sig *_b .PdfSignature )error {if _cecd ._gag ==nil {return _cf .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");};if _cecd ._ab ==nil &&_cecd ._gac ==nil {return _cf .New ("\u006d\u0075\u0073\u0074\u0020\u0070\u0072o\u0076\u0069\u0064e\u0020\u0065\u0069t\u0068\u0065r\u0020\u0061\u0020\u0070\u0072\u0069v\u0061te\u0020\u006b\u0065\u0079\u0020\u006f\u0072\u0020\u0061\u0020\u0073\u0069\u0067\u006e\u0069\u006e\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e");};_bb :=*_cecd ;sig .Handler =&_bb ;sig .Filter =_dcb .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");sig .SubFilter =_dcb .MakeName ("\u0061d\u0062e\u002e\u0078\u0035\u0030\u0039.\u0072\u0073a\u005f\u0073\u0068\u0061\u0031");sig .Cert =_dcb .MakeString (string (_bb ._gag .Raw ));sig .Reference =nil ;_ced ,_aaa :=_bb .NewDigest (sig );if _aaa !=nil {return _aaa ;};_ced .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));return _bb .Sign (sig ,_ced );};

// InitSignature initialises the PdfSignature.
func (_abe *docTimeStamp )InitSignature (sig *_b .PdfSignature )error {_fb :=*_abe ;sig .Handler =&_fb ;sig .Filter =_dcb .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");sig .SubFilter =_dcb .MakeName ("\u0045\u0054\u0053I\u002e\u0052\u0046\u0043\u0033\u0031\u0036\u0031");sig .Reference =nil ;_dae ,_afe :=_abe .NewDigest (sig );if _afe !=nil {return _afe ;};_dae .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));return _fb .Sign (sig ,_dae );};