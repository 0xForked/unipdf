//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package sighandler implements digital signature handlers for PDF signature validation and signing.
package sighandler ;import (_eb "bytes";_eg "crypto";_af "crypto/rand";_ec "crypto/rsa";_gg "crypto/x509";_fc "crypto/x509/pkix";_aa "encoding/asn1";_ff "errors";_bg "fmt";_ggf "github.com/unidoc/pkcs7";_bgb "github.com/unidoc/timestamp";_d "github.com/unidoc/unipdf/v3/core";_fb "github.com/unidoc/unipdf/v3/model";_g "hash";_f "io";_bb "io/ioutil";_b "net/http";_a "time";);

// NewEmptyAdobePKCS7Detached creates a new Adobe.PPKMS/Adobe.PPKLite adbe.pkcs7.detached
// signature handler. The generated signature is empty and of size signatureLen.
// The signatureLen parameter can be 0 for the signature validation.
func NewEmptyAdobePKCS7Detached (signatureLen int )(_fb .SignatureHandler ,error ){return &adobePKCS7Detached {_c :true ,_aaf :signatureLen },nil ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature
func (_ag *adobePKCS7Detached )IsApplicable (sig *_fb .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0061\u0064\u0062\u0065.p\u006b\u0063\u0073\u0037\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064";};

// NewDocTimeStamp creates a new DocTimeStamp signature handler.
// Both the timestamp server URL and the hash algorithm can be empty for the
// signature validation.
// The following hash algorithms are supported:
// crypto.SHA1, crypto.SHA256, crypto.SHA384, crypto.SHA512.
// NOTE: the handler will do a mock Sign when initializing the signature
// in order to estimate the signature size. Use NewDocTimeStampWithOpts
// for providing the signature size.
func NewDocTimeStamp (timestampServerURL string ,hashAlgorithm _eg .Hash )(_fb .SignatureHandler ,error ){return &docTimeStamp {_fbgb :timestampServerURL ,_ceb :hashAlgorithm },nil ;};

// NewDigest creates a new digest.
func (_dfb *docTimeStamp )NewDigest (sig *_fb .PdfSignature )(_fb .Hasher ,error ){return _eb .NewBuffer (nil ),nil ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_gca *adobeX509RSASHA1 )IsApplicable (sig *_fb .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0061d\u0062e\u002e\u0078\u0035\u0030\u0039.\u0072\u0073a\u005f\u0073\u0068\u0061\u0031";};

// Sign sets the Contents fields.
func (_ca *adobePKCS7Detached )Sign (sig *_fb .PdfSignature ,digest _fb .Hasher )error {if _ca ._c {_cc :=_ca ._aaf ;if _cc <=0{_cc =8192;};sig .Contents =_d .MakeHexString (string (make ([]byte ,_cc )));return nil ;};_ged :=digest .(*_eb .Buffer );_fd ,_ee :=_ggf .NewSignedData (_ged .Bytes ());if _ee !=nil {return _ee ;};if _cf :=_fd .AddSigner (_ca ._da ,_ca ._aaa ,_ggf .SignerInfoConfig {});_cf !=nil {return _cf ;};_fd .Detach ();_fe ,_ee :=_fd .Finish ();if _ee !=nil {return _ee ;};_daa :=make ([]byte ,8192);copy (_daa ,_fe );sig .Contents =_d .MakeHexString (string (_daa ));return nil ;};

// Validate validates PdfSignature.
func (_ga *adobePKCS7Detached )Validate (sig *_fb .PdfSignature ,digest _fb .Hasher )(_fb .SignatureValidationResult ,error ){_eca :=sig .Contents .Bytes ();_dg ,_fgc :=_ggf .Parse (_eca );if _fgc !=nil {return _fb .SignatureValidationResult {},_fgc ;};_ba :=digest .(*_eb .Buffer );_dg .Content =_ba .Bytes ();if _fgc =_dg .Verify ();_fgc !=nil {return _fb .SignatureValidationResult {},_fgc ;};return _fb .SignatureValidationResult {IsSigned :true ,IsVerified :true },nil ;};

// DocTimeStampOpts defines options for configuring the timestamp handler.
type DocTimeStampOpts struct{

// SignatureSize is the estimated size of the signature contents in bytes.
// If not provided, a default signature size of 4192 is used.
// The signing process will report the model.ErrSignNotEnoughSpace error
// if the estimated signature size is smaller than the actual size of the
// signature.
SignatureSize int ;};

// InitSignature initialises the PdfSignature.
func (_fdb *adobeX509RSASHA1 )InitSignature (sig *_fb .PdfSignature )error {if _fdb ._bad ==nil {return _ff .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");};if _fdb ._fa ==nil &&_fdb ._df ==nil {return _ff .New ("\u006d\u0075\u0073\u0074\u0020\u0070\u0072o\u0076\u0069\u0064e\u0020\u0065\u0069t\u0068\u0065r\u0020\u0061\u0020\u0070\u0072\u0069v\u0061te\u0020\u006b\u0065\u0079\u0020\u006f\u0072\u0020\u0061\u0020\u0073\u0069\u0067\u006e\u0069\u006e\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e");};_fbb :=*_fdb ;sig .Handler =&_fbb ;sig .Filter =_d .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");sig .SubFilter =_d .MakeName ("\u0061d\u0062e\u002e\u0078\u0035\u0030\u0039.\u0072\u0073a\u005f\u0073\u0068\u0061\u0031");sig .Cert =_d .MakeString (string (_fbb ._bad .Raw ));sig .Reference =nil ;_ae ,_dd :=_fbb .NewDigest (sig );if _dd !=nil {return _dd ;};_ae .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));return _fbb .Sign (sig ,_ae );};type docTimeStamp struct{_fbgb string ;_ceb _eg .Hash ;_bab int ;};

// NewAdobeX509RSASHA1Custom creates a new Adobe.PPKMS/Adobe.PPKLite adbe.x509.rsa_sha1 signature handler
// with a custom signing function. Both parameters may be nil for the signature validation.
func NewAdobeX509RSASHA1Custom (certificate *_gg .Certificate ,signFunc SignFunc )(_fb .SignatureHandler ,error ){return &adobeX509RSASHA1 {_bad :certificate ,_df :signFunc },nil ;};

// InitSignature initialises the PdfSignature.
func (_ffa *adobePKCS7Detached )InitSignature (sig *_fb .PdfSignature )error {if !_ffa ._c {if _ffa ._da ==nil {return _ff .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");};if _ffa ._aaa ==nil {return _ff .New ("\u0070\u0072\u0069\u0076\u0061\u0074\u0065\u004b\u0065\u0079\u0020m\u0075\u0073\u0074\u0020\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c");};};_cg :=*_ffa ;sig .Handler =&_cg ;sig .Filter =_d .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");sig .SubFilter =_d .MakeName ("\u0061\u0064\u0062\u0065.p\u006b\u0063\u0073\u0037\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064");sig .Reference =nil ;_gc ,_fbg :=_cg .NewDigest (sig );if _fbg !=nil {return _fbg ;};_gc .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));return _cg .Sign (sig ,_gc );};type adobePKCS7Detached struct{_aaa *_ec .PrivateKey ;_da *_gg .Certificate ;_c bool ;_aaf int ;};

// Validate validates PdfSignature.
func (_eed *docTimeStamp )Validate (sig *_fb .PdfSignature ,digest _fb .Hasher )(_fb .SignatureValidationResult ,error ){_gbg :=sig .Contents .Bytes ();_fdga ,_gfg :=_ggf .Parse (_gbg );if _gfg !=nil {return _fb .SignatureValidationResult {},_gfg ;};if _gfg =_fdga .Verify ();_gfg !=nil {return _fb .SignatureValidationResult {},_gfg ;};var _ecg timestampInfo ;_ ,_gfg =_aa .Unmarshal (_fdga .Content ,&_ecg );if _gfg !=nil {return _fb .SignatureValidationResult {},_gfg ;};_cd ,_gfg :=_afd (_ecg .MessageImprint .HashAlgorithm .Algorithm );if _gfg !=nil {return _fb .SignatureValidationResult {},_gfg ;};_aac :=_cd .New ();_cgd :=digest .(*_eb .Buffer );_aac .Write (_cgd .Bytes ());_aag :=_aac .Sum (nil );_ccb :=_fb .SignatureValidationResult {IsSigned :true ,IsVerified :_eb .Equal (_aag ,_ecg .MessageImprint .HashedMessage ),GeneralizedTime :_ecg .GeneralizedTime };return _ccb ,nil ;};type adobeX509RSASHA1 struct{_fa *_ec .PrivateKey ;_bad *_gg .Certificate ;_df SignFunc ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_caa *docTimeStamp )IsApplicable (sig *_fb .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0045\u0054\u0053I\u002e\u0052\u0046\u0043\u0033\u0031\u0036\u0031";};func (_ac *docTimeStamp )getCertificate (_gcb *_fb .PdfSignature )(*_gg .Certificate ,error ){var _fde []byte ;switch _ebc :=_gcb .Cert .(type ){case *_d .PdfObjectString :_fde =_ebc .Bytes ();case *_d .PdfObjectArray :if _ebc .Len ()==0{return nil ,_ff .New ("\u006e\u006f\u0020s\u0069\u0067\u006e\u0061t\u0075\u0072\u0065\u0020\u0063\u0065\u0072t\u0069\u0066\u0069\u0063\u0061\u0074\u0065\u0073\u0020\u0066\u006f\u0075\u006e\u0064");};for _ ,_gbc :=range _ebc .Elements (){_bgc ,_daf :=_d .GetString (_gbc );if !_daf {return nil ,_bg .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0065\u0072\u0074\u0069\u0066\u0069\u0063\u0061\u0074\u0065\u0020\u006f\u0062j\u0065\u0063\u0074\u0020\u0074\u0079p\u0065\u0020\u0069\u006e\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065 \u0063\u0065r\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u0063h\u0061\u0069\u006e\u003a\u0020\u0025\u0054",_gbc );};_fde =append (_fde ,_bgc .Bytes ()...);};default:return nil ,_bg .Errorf ("\u0069n\u0076\u0061l\u0069\u0064\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072e\u0020\u0063\u0065\u0072\u0074\u0069f\u0069\u0063\u0061\u0074\u0065\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054",_ebc );};_gee ,_fbge :=_gg .ParseCertificates (_fde );if _fbge !=nil {return nil ,_fbge ;};return _gee [0],nil ;};

// SignFunc represents a custom signing function. The function should return
// the computed signature.
type SignFunc func (_bf *_fb .PdfSignature ,_aga _fb .Hasher )([]byte ,error );

// NewAdobePKCS7Detached creates a new Adobe.PPKMS/Adobe.PPKLite adbe.pkcs7.detached signature handler.
// Both parameters may be nil for the signature validation.
func NewAdobePKCS7Detached (privateKey *_ec .PrivateKey ,certificate *_gg .Certificate )(_fb .SignatureHandler ,error ){return &adobePKCS7Detached {_da :certificate ,_aaa :privateKey },nil ;};

// NewDocTimeStampWithOpts returns a new DocTimeStamp configured using the
// specified options. If no options are provided, default options will be used.
// Both the timestamp server URL and the hash algorithm can be empty for the
// signature validation.
// The following hash algorithms are supported:
// crypto.SHA1, crypto.SHA256, crypto.SHA384, crypto.SHA512.
func NewDocTimeStampWithOpts (timestampServerURL string ,hashAlgorithm _eg .Hash ,opts *DocTimeStampOpts )(_fb .SignatureHandler ,error ){if opts ==nil {opts =&DocTimeStampOpts {};};if opts .SignatureSize <=0{opts .SignatureSize =4192;};return &docTimeStamp {_fbgb :timestampServerURL ,_ceb :hashAlgorithm ,_bab :opts .SignatureSize },nil ;};

// NewDigest creates a new digest.
func (_bdc *adobeX509RSASHA1 )NewDigest (sig *_fb .PdfSignature )(_fb .Hasher ,error ){_eee ,_ega :=_bdc .getCertificate (sig );if _ega !=nil {return nil ,_ega ;};_ddf ,_ :=_ebe (_eee .SignatureAlgorithm );return _ddf .New (),nil ;};

// Validate validates PdfSignature.
func (_dba *adobeX509RSASHA1 )Validate (sig *_fb .PdfSignature ,digest _fb .Hasher )(_fb .SignatureValidationResult ,error ){_bfc ,_ebeg :=_dba .getCertificate (sig );if _ebeg !=nil {return _fb .SignatureValidationResult {},_ebeg ;};_cag :=sig .Contents .Bytes ();var _fcb []byte ;if _ ,_ffb :=_aa .Unmarshal (_cag ,&_fcb );_ffb !=nil {return _fb .SignatureValidationResult {},_ffb ;};_fdf ,_dae :=digest .(_g .Hash );if !_dae {return _fb .SignatureValidationResult {},_ff .New ("\u0068a\u0073h\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_ea ,_ :=_ebe (_bfc .SignatureAlgorithm );if _ce :=_ec .VerifyPKCS1v15 (_bfc .PublicKey .(*_ec .PublicKey ),_ea ,_fdf .Sum (nil ),_fcb );_ce !=nil {return _fb .SignatureValidationResult {},_ce ;};return _fb .SignatureValidationResult {IsSigned :true ,IsVerified :true },nil ;};func (_cb *adobeX509RSASHA1 )getCertificate (_ed *_fb .PdfSignature )(*_gg .Certificate ,error ){if _cb ._bad !=nil {return _cb ._bad ,nil ;};var _bfe []byte ;switch _fbc :=_ed .Cert .(type ){case *_d .PdfObjectString :_bfe =_fbc .Bytes ();case *_d .PdfObjectArray :if _fbc .Len ()==0{return nil ,_ff .New ("\u006e\u006f\u0020s\u0069\u0067\u006e\u0061t\u0075\u0072\u0065\u0020\u0063\u0065\u0072t\u0069\u0066\u0069\u0063\u0061\u0074\u0065\u0073\u0020\u0066\u006f\u0075\u006e\u0064");};for _ ,_gcd :=range _fbc .Elements (){_dbc ,_gf :=_d .GetString (_gcd );if !_gf {return nil ,_bg .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0065\u0072\u0074\u0069\u0066\u0069\u0063\u0061\u0074\u0065\u0020\u006f\u0062j\u0065\u0063\u0074\u0020\u0074\u0079p\u0065\u0020\u0069\u006e\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065 \u0063\u0065r\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u0063h\u0061\u0069\u006e\u003a\u0020\u0025\u0054",_gcd );};_bfe =append (_bfe ,_dbc .Bytes ()...);};default:return nil ,_bg .Errorf ("\u0069n\u0076\u0061l\u0069\u0064\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072e\u0020\u0063\u0065\u0072\u0074\u0069f\u0069\u0063\u0061\u0074\u0065\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054",_fbc );};_gfc ,_gbb :=_gg .ParseCertificates (_bfe );if _gbb !=nil {return nil ,_gbb ;};return _gfc [0],nil ;};func _afd (_aef _aa .ObjectIdentifier )(_eg .Hash ,error ){switch {case _aef .Equal (_ggf .OIDDigestAlgorithmSHA1 ),_aef .Equal (_ggf .OIDDigestAlgorithmECDSASHA1 ),_aef .Equal (_ggf .OIDDigestAlgorithmDSA ),_aef .Equal (_ggf .OIDDigestAlgorithmDSASHA1 ),_aef .Equal (_ggf .OIDEncryptionAlgorithmRSA ):return _eg .SHA1 ,nil ;case _aef .Equal (_ggf .OIDDigestAlgorithmSHA256 ),_aef .Equal (_ggf .OIDDigestAlgorithmECDSASHA256 ):return _eg .SHA256 ,nil ;case _aef .Equal (_ggf .OIDDigestAlgorithmSHA384 ),_aef .Equal (_ggf .OIDDigestAlgorithmECDSASHA384 ):return _eg .SHA384 ,nil ;case _aef .Equal (_ggf .OIDDigestAlgorithmSHA512 ),_aef .Equal (_ggf .OIDDigestAlgorithmECDSASHA512 ):return _eg .SHA512 ,nil ;};return _eg .Hash (0),_ggf .ErrUnsupportedAlgorithm ;};

// NewAdobeX509RSASHA1 creates a new Adobe.PPKMS/Adobe.PPKLite adbe.x509.rsa_sha1 signature handler.
// Both parameters may be nil for the signature validation.
func NewAdobeX509RSASHA1 (privateKey *_ec .PrivateKey ,certificate *_gg .Certificate )(_fb .SignatureHandler ,error ){return &adobeX509RSASHA1 {_bad :certificate ,_fa :privateKey },nil ;};type timestampInfo struct{Version int ;Policy _aa .RawValue ;MessageImprint struct{HashAlgorithm _fc .AlgorithmIdentifier ;HashedMessage []byte ;};SerialNumber _aa .RawValue ;GeneralizedTime _a .Time ;};func _ebe (_age _gg .SignatureAlgorithm )(_eg .Hash ,bool ){var _fef _eg .Hash ;switch _age {case _gg .SHA1WithRSA :_fef =_eg .SHA1 ;case _gg .SHA256WithRSA :_fef =_eg .SHA256 ;case _gg .SHA384WithRSA :_fef =_eg .SHA384 ;case _gg .SHA512WithRSA :_fef =_eg .SHA512 ;default:return _eg .SHA1 ,false ;};return _fef ,true ;};

// Sign sets the Contents fields for the PdfSignature.
func (_agc *docTimeStamp )Sign (sig *_fb .PdfSignature ,digest _fb .Hasher )error {_bbe :=digest .(*_eb .Buffer );_aca :=_agc ._ceb .New ();if _ ,_bgd :=_f .Copy (_aca ,_bbe );_bgd !=nil {return _bgd ;};_egag :=_bgb .Request {HashAlgorithm :_agc ._ceb ,HashedMessage :_aca .Sum (nil ),Certificates :true ,Extensions :nil ,ExtraExtensions :nil };_gbe ,_eff :=_egag .Marshal ();if _eff !=nil {return _eff ;};_ffba ,_eff :=_b .Post (_agc ._fbgb ,"a\u0070\u0070\u006c\u0069\u0063\u0061t\u0069\u006f\u006e\u002f\u0074\u0069\u006d\u0065\u0073t\u0061\u006d\u0070-\u0071u\u0065\u0072\u0079",_eb .NewBuffer (_gbe ));if _eff !=nil {return _eff ;};defer _ffba .Body .Close ();_cbf ,_eff :=_bb .ReadAll (_ffba .Body );if _eff !=nil {return _eff ;};if _ffba .StatusCode !=_b .StatusOK {return _bg .Errorf ("\u0068\u0074\u0074\u0070\u0020\u0073\u0074\u0061\u0074\u0075\u0073\u0020\u0063\u006f\u0064e\u0020n\u006f\u0074\u0020\u006f\u006b\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0064\u0029",_ffba .StatusCode );};var _acg struct{Version _aa .RawValue ;Content _aa .RawValue ;};if _ ,_eff =_aa .Unmarshal (_cbf ,&_acg );_eff !=nil {return _eff ;};_bgcg :=len (_acg .Content .FullBytes );if _agc ._bab > 0&&_bgcg > _agc ._bab {return _fb .ErrSignNotEnoughSpace ;};if _bgcg > 0{_agc ._bab =_bgcg +128;};sig .Contents =_d .MakeHexString (string (_acg .Content .FullBytes ));return nil ;};

// Sign sets the Contents fields for the PdfSignature.
func (_cfb *adobeX509RSASHA1 )Sign (sig *_fb .PdfSignature ,digest _fb .Hasher )error {var _bbd []byte ;var _dgd error ;if _cfb ._df !=nil {_bbd ,_dgd =_cfb ._df (sig ,digest );if _dgd !=nil {return _dgd ;};}else {_ede ,_fdg :=digest .(_g .Hash );if !_fdg {return _ff .New ("\u0068a\u0073h\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_fbd ,_ :=_ebe (_cfb ._bad .SignatureAlgorithm );_bbd ,_dgd =_ec .SignPKCS1v15 (_af .Reader ,_cfb ._fa ,_fbd ,_ede .Sum (nil ));if _dgd !=nil {return _dgd ;};};_bbd ,_dgd =_aa .Marshal (_bbd );if _dgd !=nil {return _dgd ;};sig .Contents =_d .MakeHexString (string (_bbd ));return nil ;};

// InitSignature initialises the PdfSignature.
func (_ef *docTimeStamp )InitSignature (sig *_fb .PdfSignature )error {_edg :=*_ef ;sig .Handler =&_edg ;sig .Filter =_d .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");sig .SubFilter =_d .MakeName ("\u0045\u0054\u0053I\u002e\u0052\u0046\u0043\u0033\u0031\u0036\u0031");sig .Reference =nil ;if _ef ._bab > 0{sig .Contents =_d .MakeHexString (string (make ([]byte ,_ef ._bab )));}else {_bdf ,_bgf :=_ef .NewDigest (sig );if _bgf !=nil {return _bgf ;};_bdf .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));if _bgf =_edg .Sign (sig ,_bdf );_bgf !=nil {return _bgf ;};_ef ._bab =_edg ._bab ;};return nil ;};func (_bc *adobePKCS7Detached )getCertificate (_egb *_fb .PdfSignature )(*_gg .Certificate ,error ){if _bc ._da !=nil {return _bc ._da ,nil ;};var _fg []byte ;switch _gb :=_egb .Cert .(type ){case *_d .PdfObjectString :_fg =_gb .Bytes ();case *_d .PdfObjectArray :if _gb .Len ()==0{return nil ,_ff .New ("\u006e\u006f\u0020s\u0069\u0067\u006e\u0061t\u0075\u0072\u0065\u0020\u0063\u0065\u0072t\u0069\u0066\u0069\u0063\u0061\u0074\u0065\u0073\u0020\u0066\u006f\u0075\u006e\u0064");};for _ ,_ad :=range _gb .Elements (){_dc ,_gd :=_d .GetString (_ad );if !_gd {return nil ,_bg .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0065\u0072\u0074\u0069\u0066\u0069\u0063\u0061\u0074\u0065\u0020\u006f\u0062j\u0065\u0063\u0074\u0020\u0074\u0079p\u0065\u0020\u0069\u006e\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065 \u0063\u0065r\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u0063h\u0061\u0069\u006e\u003a\u0020\u0025\u0054",_ad );};_fg =append (_fg ,_dc .Bytes ()...);};default:return nil ,_bg .Errorf ("\u0069n\u0076\u0061l\u0069\u0064\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072e\u0020\u0063\u0065\u0072\u0074\u0069f\u0069\u0063\u0061\u0074\u0065\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054",_gb );};_dcd ,_dcdb :=_gg .ParseCertificates (_fg );if _dcdb !=nil {return nil ,_dcdb ;};return _dcd [0],nil ;};

// NewDigest creates a new digest.
func (_ge *adobePKCS7Detached )NewDigest (sig *_fb .PdfSignature )(_fb .Hasher ,error ){return _eb .NewBuffer (nil ),nil ;};