//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package sighandler implements digital signature handlers for PDF signature validation and signing.
package sighandler ;import (_cb "bytes";_da "crypto";_acg "crypto/rand";_b "crypto/rsa";_c "crypto/x509";_dac "crypto/x509/pkix";_ac "encoding/asn1";_d "errors";_gc "fmt";_be "github.com/unidoc/pkcs7";_eb "github.com/unidoc/timestamp";_fg "github.com/unidoc/unipdf/v3/core";
_dg "github.com/unidoc/unipdf/v3/model";_ge "github.com/unidoc/unipdf/v3/model/mdp";_fa "github.com/unidoc/unipdf/v3/model/sigutil";_g "hash";_f "math/big";_a "time";);

// NewDigest creates a new digest.
func (_fe *DocMDPHandler )NewDigest (sig *_dg .PdfSignature )(_dg .Hasher ,error ){return _fe ._dd .NewDigest (sig );};type docTimeStamp struct{_adb string ;_fedf _da .Hash ;_dbg int ;_bdga *_fa .TimestampClient ;};

// Sign sets the Contents fields for the PdfSignature.
func (_deg *docTimeStamp )Sign (sig *_dg .PdfSignature ,digest _dg .Hasher )error {_faf ,_egde :=_fa .NewTimestampRequest (digest .(*_cb .Buffer ),&_eb .RequestOptions {Hash :_deg ._fedf ,Certificates :true });if _egde !=nil {return _egde ;};_bgga :=_deg ._bdga ;
if _bgga ==nil {_bgga =_fa .NewTimestampClient ();};_egg ,_egde :=_bgga .GetEncodedToken (_deg ._adb ,_faf );if _egde !=nil {return _egde ;};_gae :=len (_egg );if _deg ._dbg > 0&&_gae > _deg ._dbg {return _dg .ErrSignNotEnoughSpace ;};if _gae > 0{_deg ._dbg =_gae +128;
};if sig .Contents !=nil {_cae :=sig .Contents .Bytes ();copy (_cae ,_egg );_egg =_cae ;};sig .Contents =_fg .MakeHexString (string (_egg ));return nil ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature
func (_fdfbe *adobePKCS7Detached )IsApplicable (sig *_dg .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0061\u0064\u0062\u0065.p\u006b\u0063\u0073\u0037\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064";
};func (_ffe *adobeX509RSASHA1 )sign (_dgg *_dg .PdfSignature ,_ga _dg .Hasher ,_ddd bool )error {if !_ddd {return _ffe .Sign (_dgg ,_ga );};_cfd ,_eabc :=_ffe ._egc .PublicKey .(*_b .PublicKey );if !_eabc {return _gc .Errorf ("i\u006e\u0076\u0061\u006c\u0069\u0064 \u0070\u0075\u0062\u006c\u0069\u0063\u0020\u006b\u0065y\u0020\u0074\u0079p\u0065:\u0020\u0025\u0054",_cfd );
};_egd ,_fdc :=_ac .Marshal (make ([]byte ,_cfd .Size ()));if _fdc !=nil {return _fdc ;};_dgg .Contents =_fg .MakeHexString (string (_egd ));return nil ;};

// NewAdobeX509RSASHA1Custom creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler with a custom signing function. Both the
// certificate and the sign function can be nil for the signature validation.
// NOTE: the handler will do a mock Sign when initializing the signature in
// order to estimate the signature size. Use NewAdobeX509RSASHA1CustomWithOpts
// for configuring the handler to estimate the signature size.
func NewAdobeX509RSASHA1Custom (certificate *_c .Certificate ,signFunc SignFunc )(_dg .SignatureHandler ,error ){return &adobeX509RSASHA1 {_egc :certificate ,_bfgc :signFunc },nil ;};

// ValidateWithOpts validates a PDF signature by checking PdfReader or PdfParser by the DiffPolicy
// params describes parameters for the DocMDP checks.
func (_ea *DocMDPHandler )ValidateWithOpts (sig *_dg .PdfSignature ,digest _dg .Hasher ,params _dg .SignatureHandlerDocMDPParams )(_dg .SignatureValidationResult ,error ){_df ,_bd :=_ea ._dd .Validate (sig ,digest );if _bd !=nil {return _df ,_bd ;};_bfg :=params .Parser ;
if _bfg ==nil {return _dg .SignatureValidationResult {},_d .New ("p\u0061r\u0073\u0065\u0072\u0020\u0063\u0061\u006e\u0027t\u0020\u0062\u0065\u0020nu\u006c\u006c");};if !_df .IsVerified {return _df ,nil ;};_gce :=params .DiffPolicy ;if _gce ==nil {_gce =_ge .NewDefaultDiffPolicy ();
};for _fd :=0;_fd <=_bfg .GetRevisionNumber ();_fd ++{_ba ,_gg :=_bfg .GetRevision (_fd );if _gg !=nil {return _dg .SignatureValidationResult {},_gg ;};_ec :=_ba .GetTrailer ();if _ec ==nil {return _dg .SignatureValidationResult {},_d .New ("\u0075\u006e\u0064\u0065f\u0069\u006e\u0065\u0064\u0020\u0074\u0068\u0065\u0020\u0074r\u0061i\u006c\u0065\u0072\u0020\u006f\u0062\u006ae\u0063\u0074");
};_gd ,_bg :=_fg .GetDict (_ec .Get ("\u0052\u006f\u006f\u0074"));if !_bg {return _dg .SignatureValidationResult {},_d .New ("\u0075n\u0064\u0065\u0066\u0069n\u0065\u0064\u0020\u0074\u0068e\u0020r\u006fo\u0074\u0020\u006f\u0062\u006a\u0065\u0063t");};_ced ,_bg :=_fg .GetDict (_gd .Get ("\u0041\u0063\u0072\u006f\u0046\u006f\u0072\u006d"));
if !_bg {continue ;};_fdf ,_bg :=_fg .GetArray (_ced .Get ("\u0046\u0069\u0065\u006c\u0064\u0073"));if !_bg {continue ;};for _ ,_bdg :=range _fdf .Elements (){_gf ,_cfb :=_fg .GetDict (_bdg );if !_cfb {continue ;};_gcb ,_cfb :=_fg .GetDict (_gf .Get ("\u0056"));
if !_cfb {continue ;};if _fg .EqualObjects (_gcb .Get ("\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"),sig .Contents ){_df .DiffResults ,_gg =_gce .ReviewFile (_ba ,_bfg ,&_ge .MDPParameters {DocMDPLevel :_ea .Permission });if _gg !=nil {return _dg .SignatureValidationResult {},_gg ;
};_df .IsVerified =_df .DiffResults .IsPermitted ();return _df ,nil ;};};};return _dg .SignatureValidationResult {},_d .New ("\u0064\u006f\u006e\u0027\u0074\u0020\u0066o\u0075\u006e\u0064 \u0074\u0068\u0069\u0073 \u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0069\u006e\u0020\u0074\u0068\u0065\u0020\u0072\u0065\u0076\u0069\u0073\u0069\u006f\u006e\u0073");
};

// InitSignature initialises the PdfSignature.
func (_ffc *adobePKCS7Detached )InitSignature (sig *_dg .PdfSignature )error {if !_ffc ._dca {if _ffc ._de ==nil {return _d .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");
};if _ffc ._ae ==nil {return _d .New ("\u0070\u0072\u0069\u0076\u0061\u0074\u0065\u004b\u0065\u0079\u0020m\u0075\u0073\u0074\u0020\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c");};};_fdfb :=*_ffc ;sig .Handler =&_fdfb ;sig .Filter =_fg .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");
sig .SubFilter =_fg .MakeName ("\u0061\u0064\u0062\u0065.p\u006b\u0063\u0073\u0037\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064");sig .Reference =nil ;_ag ,_cc :=_fdfb .NewDigest (sig );if _cc !=nil {return _cc ;};_ag .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));
return _fdfb .Sign (sig ,_ag );};

// AdobeX509RSASHA1Opts defines options for configuring the adbe.x509.rsa_sha1
// signature handler.
type AdobeX509RSASHA1Opts struct{

// EstimateSize specifies whether the size of the signature contents
// should be estimated based on the modulus size of the public key
// extracted from the signing certificate. If set to false, a mock Sign
// call is made in order to estimate the size of the signature contents.
EstimateSize bool ;

// Algorithm specifies the algorithm used for performing signing.
// If not specified, defaults to SHA1.
Algorithm _da .Hash ;};

// NewAdobeX509RSASHA1 creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler. Both the private key and the
// certificate can be nil for the signature validation.
func NewAdobeX509RSASHA1 (privateKey *_b .PrivateKey ,certificate *_c .Certificate )(_dg .SignatureHandler ,error ){return &adobeX509RSASHA1 {_egc :certificate ,_dee :privateKey },nil ;};

// Validate validates PdfSignature.
func (_ffd *docTimeStamp )Validate (sig *_dg .PdfSignature ,digest _dg .Hasher )(_dg .SignatureValidationResult ,error ){_daf :=sig .Contents .Bytes ();_dbb ,_gaa :=_be .Parse (_daf );if _gaa !=nil {return _dg .SignatureValidationResult {},_gaa ;};if _gaa =_dbb .Verify ();
_gaa !=nil {return _dg .SignatureValidationResult {},_gaa ;};var _aaa timestampInfo ;_ ,_gaa =_ac .Unmarshal (_dbb .Content ,&_aaa );if _gaa !=nil {return _dg .SignatureValidationResult {},_gaa ;};_bad ,_gaa :=_cbeb (_aaa .MessageImprint .HashAlgorithm .Algorithm );
if _gaa !=nil {return _dg .SignatureValidationResult {},_gaa ;};_ggb :=_bad .New ();_gdc :=digest .(*_cb .Buffer );_ggb .Write (_gdc .Bytes ());_bfb :=_ggb .Sum (nil );_bdgf :=_dg .SignatureValidationResult {IsSigned :true ,IsVerified :_cb .Equal (_bfb ,_aaa .MessageImprint .HashedMessage ),GeneralizedTime :_aaa .GeneralizedTime };
return _bdgf ,nil ;};

// NewDocTimeStampWithOpts returns a new DocTimeStamp configured using the
// specified options. If no options are provided, default options will be used.
// Both the timestamp server URL and the hash algorithm can be empty for the
// signature validation.
// The following hash algorithms are supported:
// crypto.SHA1, crypto.SHA256, crypto.SHA384, crypto.SHA512.
func NewDocTimeStampWithOpts (timestampServerURL string ,hashAlgorithm _da .Hash ,opts *DocTimeStampOpts )(_dg .SignatureHandler ,error ){if opts ==nil {opts =&DocTimeStampOpts {};};if opts .SignatureSize <=0{opts .SignatureSize =4192;};return &docTimeStamp {_adb :timestampServerURL ,_fedf :hashAlgorithm ,_dbg :opts .SignatureSize ,_bdga :opts .Client },nil ;
};

// NewDocMDPHandler returns the new DocMDP handler with the specific DocMDP restriction level.
func NewDocMDPHandler (handler _dg .SignatureHandler ,permission _ge .DocMDPPermission )(_dg .SignatureHandler ,error ){return &DocMDPHandler {_dd :handler ,Permission :permission },nil ;};

// Sign sets the Contents fields.
func (_ddc *adobePKCS7Detached )Sign (sig *_dg .PdfSignature ,digest _dg .Hasher )error {if _ddc ._dca {_bbc :=_ddc ._fb ;if _bbc <=0{_bbc =8192;};sig .Contents =_fg .MakeHexString (string (make ([]byte ,_bbc )));return nil ;};_bagb :=digest .(*_cb .Buffer );
_fbg ,_fag :=_be .NewSignedData (_bagb .Bytes ());if _fag !=nil {return _fag ;};if _edda :=_fbg .AddSigner (_ddc ._de ,_ddc ._ae ,_be .SignerInfoConfig {});_edda !=nil {return _edda ;};_fbg .Detach ();_ead ,_fag :=_fbg .Finish ();if _fag !=nil {return _fag ;
};_ega :=make ([]byte ,8192);copy (_ega ,_ead );sig .Contents =_fg .MakeHexString (string (_ega ));return nil ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_acf *adobeX509RSASHA1 )IsApplicable (sig *_dg .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0061d\u0062e\u002e\u0078\u0035\u0030\u0039.\u0072\u0073a\u005f\u0073\u0068\u0061\u0031";
};func _bbg (_bdfa []byte ,_edb int )(_bcd []byte ){_bedd :=len (_bdfa );if _bedd > _edb {_bedd =_edb ;};_bcd =make ([]byte ,_edb );copy (_bcd [len (_bcd )-_bedd :],_bdfa );return ;};

// DocMDPHandler describes handler for the DocMDP realization.
type DocMDPHandler struct{_dd _dg .SignatureHandler ;Permission _ge .DocMDPPermission ;};

// NewDigest creates a new digest.
func (_cd *adobePKCS7Detached )NewDigest (sig *_dg .PdfSignature )(_dg .Hasher ,error ){return _cb .NewBuffer (nil ),nil ;};

// Sign sets the Contents fields for the PdfSignature.
func (_dcbb *adobeX509RSASHA1 )Sign (sig *_dg .PdfSignature ,digest _dg .Hasher )error {var _ddb []byte ;var _fbbb error ;if _dcbb ._bfgc !=nil {_ddb ,_fbbb =_dcbb ._bfgc (sig ,digest );if _fbbb !=nil {return _fbbb ;};}else {_ffcb ,_efg :=digest .(_g .Hash );
if !_efg {return _d .New ("\u0068a\u0073h\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_fed :=_fdd ;if _dcbb ._bgg !=0{_fed =_dcbb ._bgg ;};_ddb ,_fbbb =_b .SignPKCS1v15 (_acg .Reader ,_dcbb ._dee ,_fed ,_ffcb .Sum (nil ));if _fbbb !=nil {return _fbbb ;
};};_ddb ,_fbbb =_ac .Marshal (_ddb );if _fbbb !=nil {return _fbbb ;};sig .Contents =_fg .MakeHexString (string (_ddb ));return nil ;};

// Sign adds a new reference to signature's references array.
func (_cg *DocMDPHandler )Sign (sig *_dg .PdfSignature ,digest _dg .Hasher )error {return _cg ._dd .Sign (sig ,digest );};func (_eab *adobeX509RSASHA1 )getHashAlgorithm (_egf *_dg .PdfSignature )(_da .Hash ,error ){_cge ,_fbb :=_eab .getCertificate (_egf );
if _fbb !=nil {if _eab ._bgg !=0{return _eab ._bgg ,nil ;};return _fdd ,_fbb ;};if _egf .Contents !=nil {_fab :=_egf .Contents .Bytes ();var _dda []byte ;if _ ,_gfd :=_ac .Unmarshal (_fab ,&_dda );_gfd ==nil {_eddf :=_afd (_cge .PublicKey .(*_b .PublicKey ),_dda );
if _eddf > 0{return _eddf ,nil ;};};};if _eab ._bgg !=0{return _eab ._bgg ,nil ;};return _fdd ,nil ;};

// NewDigest creates a new digest.
func (_ggf *adobeX509RSASHA1 )NewDigest (sig *_dg .PdfSignature )(_dg .Hasher ,error ){if _ebg ,_dcb :=_ggf .getHashAlgorithm (sig );_ebg !=0&&_dcb ==nil {return _ebg .New (),nil ;};return _fdd .New (),nil ;};func (_af *adobeX509RSASHA1 )getCertificate (_cbb *_dg .PdfSignature )(*_c .Certificate ,error ){if _af ._egc !=nil {return _af ._egc ,nil ;
};_fde ,_dcc :=_cbb .GetCerts ();if _dcc !=nil {return nil ,_dcc ;};return _fde [0],nil ;};

// Validate validates PdfSignature.
func (_bag *adobePKCS7Detached )Validate (sig *_dg .PdfSignature ,digest _dg .Hasher )(_dg .SignatureValidationResult ,error ){_cgb :=sig .Contents .Bytes ();_dec ,_bdf :=_be .Parse (_cgb );if _bdf !=nil {return _dg .SignatureValidationResult {},_bdf ;
};_ecb :=digest .(*_cb .Buffer );_dec .Content =_ecb .Bytes ();if _bdf =_dec .Verify ();_bdf !=nil {return _dg .SignatureValidationResult {},_bdf ;};return _dg .SignatureValidationResult {IsSigned :true ,IsVerified :true },nil ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_dfa *docTimeStamp )IsApplicable (sig *_dg .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0045\u0054\u0053I\u002e\u0052\u0046\u0043\u0033\u0031\u0036\u0031";
};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_ed *DocMDPHandler )IsApplicable (sig *_dg .PdfSignature )bool {_ab :=false ;for _ ,_ee :=range sig .Reference .Elements (){if _bc ,_edd :=_fg .GetDict (_ee );_edd {if _bb ,_ce :=_fg .GetNameVal (_bc .Get ("\u0054r\u0061n\u0073\u0066\u006f\u0072\u006d\u004d\u0065\u0074\u0068\u006f\u0064"));
_ce {if _bb !="\u0044\u006f\u0063\u004d\u0044\u0050"{return false ;};if _db ,_ff :=_fg .GetDict (_bc .Get ("\u0054r\u0061n\u0073\u0066\u006f\u0072\u006d\u0050\u0061\u0072\u0061\u006d\u0073"));_ff {_ ,_bf :=_fg .GetNumberAsInt64 (_db .Get ("\u0050"));if _bf !=nil {return false ;
};_ab =true ;break ;};};};};return _ab &&_ed ._dd .IsApplicable (sig );};

// NewEmptyAdobePKCS7Detached creates a new Adobe.PPKMS/Adobe.PPKLite adbe.pkcs7.detached
// signature handler. The generated signature is empty and of size signatureLen.
// The signatureLen parameter can be 0 for the signature validation.
func NewEmptyAdobePKCS7Detached (signatureLen int )(_dg .SignatureHandler ,error ){return &adobePKCS7Detached {_dca :true ,_fb :signatureLen },nil ;};func (_fbc *adobePKCS7Detached )getCertificate (_gdb *_dg .PdfSignature )(*_c .Certificate ,error ){if _fbc ._de !=nil {return _fbc ._de ,nil ;
};_aa ,_aad :=_gdb .GetCerts ();if _aad !=nil {return nil ,_aad ;};return _aa [0],nil ;};

// NewAdobeX509RSASHA1CustomWithOpts creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler with a custom signing function. The
// handler is configured based on the provided options. If no options are
// provided, default options will be used. Both the certificate and the sign
// function can be nil for the signature validation.
func NewAdobeX509RSASHA1CustomWithOpts (certificate *_c .Certificate ,signFunc SignFunc ,opts *AdobeX509RSASHA1Opts )(_dg .SignatureHandler ,error ){if opts ==nil {opts =&AdobeX509RSASHA1Opts {};};return &adobeX509RSASHA1 {_egc :certificate ,_bfgc :signFunc ,_fc :opts .EstimateSize ,_bgg :opts .Algorithm },nil ;
};

// DocTimeStampOpts defines options for configuring the timestamp handler.
type DocTimeStampOpts struct{

// SignatureSize is the estimated size of the signature contents in bytes.
// If not provided, a default signature size of 4192 is used.
// The signing process will report the model.ErrSignNotEnoughSpace error
// if the estimated signature size is smaller than the actual size of the
// signature.
SignatureSize int ;

// Client is the timestamp client used to make the signature request.
// If no client is provided, a default one is used.
Client *_fa .TimestampClient ;};

// SignFunc represents a custom signing function. The function should return
// the computed signature.
type SignFunc func (_ca *_dg .PdfSignature ,_ef _dg .Hasher )([]byte ,error );const _fdd =_da .SHA1 ;

// Validate implementation of the SignatureHandler interface
// This check is impossible without checking the document's content.
// Please, use ValidateWithOpts with the PdfParser.
func (_eg *DocMDPHandler )Validate (sig *_dg .PdfSignature ,digest _dg .Hasher )(_dg .SignatureValidationResult ,error ){return _dg .SignatureValidationResult {},_d .New ("i\u006d\u0070\u006f\u0073\u0073\u0069b\u006c\u0065\u0020\u0076\u0061\u006ci\u0064\u0061\u0074\u0069\u006f\u006e\u0020w\u0069\u0074\u0068\u006f\u0075\u0074\u0020\u0070\u0061\u0072s\u0065");
};type adobePKCS7Detached struct{_ae *_b .PrivateKey ;_de *_c .Certificate ;_dca bool ;_fb int ;};type adobeX509RSASHA1 struct{_dee *_b .PrivateKey ;_egc *_c .Certificate ;_bfgc SignFunc ;_fc bool ;_bgg _da .Hash ;};

// InitSignature initialization of the DocMDP signature.
func (_baf *DocMDPHandler )InitSignature (sig *_dg .PdfSignature )error {_dc :=_baf ._dd .InitSignature (sig );if _dc !=nil {return _dc ;};sig .Handler =_baf ;if sig .Reference ==nil {sig .Reference =_fg .MakeArray ();};sig .Reference .Append (_dg .NewPdfSignatureReferenceDocMDP (_dg .NewPdfTransformParamsDocMDP (_baf .Permission )).ToPdfObject ());
return nil ;};func _afd (_ad *_b .PublicKey ,_ebd []byte )_da .Hash {_edg :=_ad .Size ();if _edg !=len (_ebd ){return 0;};_bcc :=func (_aed *_f .Int ,_cca *_b .PublicKey ,_dfd *_f .Int )*_f .Int {_agf :=_f .NewInt (int64 (_cca .E ));_aed .Exp (_dfd ,_agf ,_cca .N );
return _aed ;};_gdd :=new (_f .Int ).SetBytes (_ebd );_efb :=_bcc (new (_f .Int ),_ad ,_gdd );_afc :=_bbg (_efb .Bytes (),_edg );if _afc [0]!=0||_afc [1]!=1{return 0;};_bafg :=[]struct{Hash _da .Hash ;Prefix []byte ;}{{Hash :_da .SHA1 ,Prefix :[]byte {0x30,0x21,0x30,0x09,0x06,0x05,0x2b,0x0e,0x03,0x02,0x1a,0x05,0x00,0x04,0x14}},{Hash :_da .SHA256 ,Prefix :[]byte {0x30,0x31,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x01,0x05,0x00,0x04,0x20}},{Hash :_da .SHA384 ,Prefix :[]byte {0x30,0x41,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x02,0x05,0x00,0x04,0x30}},{Hash :_da .SHA512 ,Prefix :[]byte {0x30,0x51,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x03,0x05,0x00,0x04,0x40}},{Hash :_da .RIPEMD160 ,Prefix :[]byte {0x30,0x20,0x30,0x08,0x06,0x06,0x28,0xcf,0x06,0x03,0x00,0x31,0x04,0x14}}};
for _ ,_bed :=range _bafg {_gb :=_bed .Hash .Size ();_bgf :=len (_bed .Prefix )+_gb ;if _cb .Equal (_afc [_edg -_bgf :_edg -_gb ],_bed .Prefix ){return _bed .Hash ;};};return 0;};type timestampInfo struct{Version int ;Policy _ac .RawValue ;MessageImprint struct{HashAlgorithm _dac .AlgorithmIdentifier ;
HashedMessage []byte ;};SerialNumber _ac .RawValue ;GeneralizedTime _a .Time ;};func (_afcc *docTimeStamp )getCertificate (_dgb *_dg .PdfSignature )(*_c .Certificate ,error ){_daa ,_dfb :=_dgb .GetCerts ();if _dfb !=nil {return nil ,_dfb ;};return _daa [0],nil ;
};

// NewAdobePKCS7Detached creates a new Adobe.PPKMS/Adobe.PPKLite adbe.pkcs7.detached signature handler.
// Both parameters may be nil for the signature validation.
func NewAdobePKCS7Detached (privateKey *_b .PrivateKey ,certificate *_c .Certificate )(_dg .SignatureHandler ,error ){return &adobePKCS7Detached {_de :certificate ,_ae :privateKey },nil ;};func _cbeb (_dad _ac .ObjectIdentifier )(_da .Hash ,error ){switch {case _dad .Equal (_be .OIDDigestAlgorithmSHA1 ),_dad .Equal (_be .OIDDigestAlgorithmECDSASHA1 ),_dad .Equal (_be .OIDDigestAlgorithmDSA ),_dad .Equal (_be .OIDDigestAlgorithmDSASHA1 ),_dad .Equal (_be .OIDEncryptionAlgorithmRSA ):return _da .SHA1 ,nil ;
case _dad .Equal (_be .OIDDigestAlgorithmSHA256 ),_dad .Equal (_be .OIDDigestAlgorithmECDSASHA256 ):return _da .SHA256 ,nil ;case _dad .Equal (_be .OIDDigestAlgorithmSHA384 ),_dad .Equal (_be .OIDDigestAlgorithmECDSASHA384 ):return _da .SHA384 ,nil ;case _dad .Equal (_be .OIDDigestAlgorithmSHA512 ),_dad .Equal (_be .OIDDigestAlgorithmECDSASHA512 ):return _da .SHA512 ,nil ;
};return _da .Hash (0),_be .ErrUnsupportedAlgorithm ;};

// InitSignature initialises the PdfSignature.
func (_cedf *docTimeStamp )InitSignature (sig *_dg .PdfSignature )error {_gfcg :=*_cedf ;sig .Handler =&_gfcg ;sig .Filter =_fg .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");sig .SubFilter =_fg .MakeName ("\u0045\u0054\u0053I\u002e\u0052\u0046\u0043\u0033\u0031\u0036\u0031");
sig .Reference =nil ;if _cedf ._dbg > 0{sig .Contents =_fg .MakeHexString (string (make ([]byte ,_cedf ._dbg )));}else {_ggff ,_bfc :=_cedf .NewDigest (sig );if _bfc !=nil {return _bfc ;};_ggff .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));
if _bfc =_gfcg .Sign (sig ,_ggff );_bfc !=nil {return _bfc ;};_cedf ._dbg =_gfcg ._dbg ;};return nil ;};

// InitSignature initialises the PdfSignature.
func (_cbe *adobeX509RSASHA1 )InitSignature (sig *_dg .PdfSignature )error {if _cbe ._egc ==nil {return _d .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");
};if _cbe ._dee ==nil &&_cbe ._bfgc ==nil {return _d .New ("\u006d\u0075\u0073\u0074\u0020\u0070\u0072o\u0076\u0069\u0064e\u0020\u0065\u0069t\u0068\u0065r\u0020\u0061\u0020\u0070\u0072\u0069v\u0061te\u0020\u006b\u0065\u0079\u0020\u006f\u0072\u0020\u0061\u0020\u0073\u0069\u0067\u006e\u0069\u006e\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e");
};_gfc :=*_cbe ;sig .Handler =&_gfc ;sig .Filter =_fg .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");sig .SubFilter =_fg .MakeName ("\u0061d\u0062e\u002e\u0078\u0035\u0030\u0039.\u0072\u0073a\u005f\u0073\u0068\u0061\u0031");
sig .Cert =_fg .MakeString (string (_gfc ._egc .Raw ));sig .Reference =nil ;_egac ,_aac :=_gfc .NewDigest (sig );if _aac !=nil {return _aac ;};_egac .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));
return _gfc .sign (sig ,_egac ,_cbe ._fc );};

// NewDigest creates a new digest.
func (_bdbd *docTimeStamp )NewDigest (sig *_dg .PdfSignature )(_dg .Hasher ,error ){return _cb .NewBuffer (nil ),nil ;};

// NewDocTimeStamp creates a new DocTimeStamp signature handler.
// Both the timestamp server URL and the hash algorithm can be empty for the
// signature validation.
// The following hash algorithms are supported:
// crypto.SHA1, crypto.SHA256, crypto.SHA384, crypto.SHA512.
// NOTE: the handler will do a mock Sign when initializing the signature
// in order to estimate the signature size. Use NewDocTimeStampWithOpts
// for providing the signature size.
func NewDocTimeStamp (timestampServerURL string ,hashAlgorithm _da .Hash )(_dg .SignatureHandler ,error ){return &docTimeStamp {_adb :timestampServerURL ,_fedf :hashAlgorithm },nil ;};

// Validate validates PdfSignature.
func (_afe *adobeX509RSASHA1 )Validate (sig *_dg .PdfSignature ,digest _dg .Hasher )(_dg .SignatureValidationResult ,error ){_ecd ,_gdf :=_afe .getCertificate (sig );if _gdf !=nil {return _dg .SignatureValidationResult {},_gdf ;};_cag :=sig .Contents .Bytes ();
var _aff []byte ;if _ ,_abg :=_ac .Unmarshal (_cag ,&_aff );_abg !=nil {return _dg .SignatureValidationResult {},_abg ;};_fgf ,_ace :=digest .(_g .Hash );if !_ace {return _dg .SignatureValidationResult {},_d .New ("\u0068a\u0073h\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_acd ,_ :=_afe .getHashAlgorithm (sig );if _acd ==0{_acd =_fdd ;};if _dga :=_b .VerifyPKCS1v15 (_ecd .PublicKey .(*_b .PublicKey ),_acd ,_fgf .Sum (nil ),_aff );_dga !=nil {return _dg .SignatureValidationResult {},_dga ;};return _dg .SignatureValidationResult {IsSigned :true ,IsVerified :true },nil ;
};