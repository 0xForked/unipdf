//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package sighandler implements digital signature handlers for PDF signature validation and signing.
package sighandler ;import (_g "bytes";_d "crypto";_da "crypto/rand";_gdc "crypto/rsa";_bg "crypto/x509";_b "crypto/x509/pkix";_f "encoding/asn1";_dg "errors";_c "fmt";_e "github.com/unidoc/pkcs7";_ga "github.com/unidoc/timestamp";_fg "github.com/unidoc/unipdf/v3/core";
_cb "github.com/unidoc/unipdf/v3/model";_ca "github.com/unidoc/unipdf/v3/model/sigutil";_gd "hash";_af "time";);

// InitSignature initialises the PdfSignature.
func (_dfb *adobePKCS7Detached )InitSignature (sig *_cb .PdfSignature )error {if !_dfb ._df {if _dfb ._gb ==nil {return _dg .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");
};if _dfb ._bgb ==nil {return _dg .New ("\u0070\u0072\u0069\u0076\u0061\u0074\u0065\u004b\u0065\u0079\u0020m\u0075\u0073\u0074\u0020\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c");};};_fb :=*_dfb ;sig .Handler =&_fb ;sig .Filter =_fg .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");
sig .SubFilter =_fg .MakeName ("\u0061\u0064\u0062\u0065.p\u006b\u0063\u0073\u0037\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064");sig .Reference =nil ;_gc ,_fa :=_fb .NewDigest (sig );if _fa !=nil {return _fa ;};_gc .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));
return _fb .Sign (sig ,_gc );};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_gafa *adobeX509RSASHA1 )IsApplicable (sig *_cb .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0061d\u0062e\u002e\u0078\u0035\u0030\u0039.\u0072\u0073a\u005f\u0073\u0068\u0061\u0031";
};type timestampInfo struct{Version int ;Policy _f .RawValue ;MessageImprint struct{HashAlgorithm _b .AlgorithmIdentifier ;HashedMessage []byte ;};SerialNumber _f .RawValue ;GeneralizedTime _af .Time ;};

// NewDocTimeStampWithOpts returns a new DocTimeStamp configured using the
// specified options. If no options are provided, default options will be used.
// Both the timestamp server URL and the hash algorithm can be empty for the
// signature validation.
// The following hash algorithms are supported:
// crypto.SHA1, crypto.SHA256, crypto.SHA384, crypto.SHA512.
func NewDocTimeStampWithOpts (timestampServerURL string ,hashAlgorithm _d .Hash ,opts *DocTimeStampOpts )(_cb .SignatureHandler ,error ){if opts ==nil {opts =&DocTimeStampOpts {};};if opts .SignatureSize <=0{opts .SignatureSize =4192;};return &docTimeStamp {_faa :timestampServerURL ,_fgfc :hashAlgorithm ,_gaa :opts .SignatureSize },nil ;
};

// NewDigest creates a new digest.
func (_gad *docTimeStamp )NewDigest (sig *_cb .PdfSignature )(_cb .Hasher ,error ){return _g .NewBuffer (nil ),nil ;};

// Sign sets the Contents fields for the PdfSignature.
func (_db *adobeX509RSASHA1 )Sign (sig *_cb .PdfSignature ,digest _cb .Hasher )error {var _dba []byte ;var _ge error ;if _db ._eaa !=nil {_dba ,_ge =_db ._eaa (sig ,digest );if _ge !=nil {return _ge ;};}else {_cccb ,_ebb :=digest .(_gd .Hash );if !_ebb {return _dg .New ("\u0068a\u0073h\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_gce ,_ :=_ecf (_db ._bcf .SignatureAlgorithm );_dba ,_ge =_gdc .SignPKCS1v15 (_da .Reader ,_db ._fc ,_gce ,_cccb .Sum (nil ));if _ge !=nil {return _ge ;};};_dba ,_ge =_f .Marshal (_dba );if _ge !=nil {return _ge ;};sig .Contents =_fg .MakeHexString (string (_dba ));
return nil ;};func (_ag *adobePKCS7Detached )getCertificate (_ae *_cb .PdfSignature )(*_bg .Certificate ,error ){if _ag ._gb !=nil {return _ag ._gb ,nil ;};_cf ,_ef :=_ae .GetCerts ();if _ef !=nil {return nil ,_ef ;};return _cf [0],nil ;};

// Sign sets the Contents fields.
func (_ac *adobePKCS7Detached )Sign (sig *_cb .PdfSignature ,digest _cb .Hasher )error {if _ac ._df {_ea :=_ac ._cbg ;if _ea <=0{_ea =8192;};sig .Contents =_fg .MakeHexString (string (make ([]byte ,_ea )));return nil ;};_dc :=digest .(*_g .Buffer );_gcg ,_cc :=_e .NewSignedData (_dc .Bytes ());
if _cc !=nil {return _cc ;};if _cd :=_gcg .AddSigner (_ac ._gb ,_ac ._bgb ,_e .SignerInfoConfig {});_cd !=nil {return _cd ;};_gcg .Detach ();_ccf ,_cc :=_gcg .Finish ();if _cc !=nil {return _cc ;};_ec :=make ([]byte ,8192);copy (_ec ,_ccf );sig .Contents =_fg .MakeHexString (string (_ec ));
return nil ;};type adobeX509RSASHA1 struct{_fc *_gdc .PrivateKey ;_bcf *_bg .Certificate ;_eaa SignFunc ;_fae bool ;};

// NewAdobeX509RSASHA1 creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler. Both the private key and the
// certificate can be nil for the signature validation.
func NewAdobeX509RSASHA1 (privateKey *_gdc .PrivateKey ,certificate *_bg .Certificate )(_cb .SignatureHandler ,error ){return &adobeX509RSASHA1 {_bcf :certificate ,_fc :privateKey },nil ;};func (_fcb *adobeX509RSASHA1 )getCertificate (_fbb *_cb .PdfSignature )(*_bg .Certificate ,error ){if _fcb ._bcf !=nil {return _fcb ._bcf ,nil ;
};_bd ,_afe :=_fbb .GetCerts ();if _afe !=nil {return nil ,_afe ;};return _bd [0],nil ;};func (_aga *adobeX509RSASHA1 )sign (_gef *_cb .PdfSignature ,_eg _cb .Hasher ,_dd bool )error {if !_dd {return _aga .Sign (_gef ,_eg );};_dfd ,_adg :=_aga ._bcf .PublicKey .(*_gdc .PublicKey );
if !_adg {return _c .Errorf ("i\u006e\u0076\u0061\u006c\u0069\u0064 \u0070\u0075\u0062\u006c\u0069\u0063\u0020\u006b\u0065y\u0020\u0074\u0079p\u0065:\u0020\u0025\u0054",_dfd );};_cce ,_aba :=_f .Marshal (make ([]byte ,_dfd .Size ()));if _aba !=nil {return _aba ;
};_gef .Contents =_fg .MakeHexString (string (_cce ));return nil ;};func _ecf (_afg _bg .SignatureAlgorithm )(_d .Hash ,bool ){var _beb _d .Hash ;switch _afg {case _bg .SHA1WithRSA :_beb =_d .SHA1 ;case _bg .SHA256WithRSA :_beb =_d .SHA256 ;case _bg .SHA384WithRSA :_beb =_d .SHA384 ;
case _bg .SHA512WithRSA :_beb =_d .SHA512 ;default:return _d .SHA1 ,false ;};return _beb ,true ;};func _abg (_edc _f .ObjectIdentifier )(_d .Hash ,error ){switch {case _edc .Equal (_e .OIDDigestAlgorithmSHA1 ),_edc .Equal (_e .OIDDigestAlgorithmECDSASHA1 ),_edc .Equal (_e .OIDDigestAlgorithmDSA ),_edc .Equal (_e .OIDDigestAlgorithmDSASHA1 ),_edc .Equal (_e .OIDEncryptionAlgorithmRSA ):return _d .SHA1 ,nil ;
case _edc .Equal (_e .OIDDigestAlgorithmSHA256 ),_edc .Equal (_e .OIDDigestAlgorithmECDSASHA256 ):return _d .SHA256 ,nil ;case _edc .Equal (_e .OIDDigestAlgorithmSHA384 ),_edc .Equal (_e .OIDDigestAlgorithmECDSASHA384 ):return _d .SHA384 ,nil ;case _edc .Equal (_e .OIDDigestAlgorithmSHA512 ),_edc .Equal (_e .OIDDigestAlgorithmECDSASHA512 ):return _d .SHA512 ,nil ;
};return _d .Hash (0),_e .ErrUnsupportedAlgorithm ;};

// Validate validates PdfSignature.
func (_gaf *adobePKCS7Detached )Validate (sig *_cb .PdfSignature ,digest _cb .Hasher )(_cb .SignatureValidationResult ,error ){_bc :=sig .Contents .Bytes ();_cg ,_be :=_e .Parse (_bc );if _be !=nil {return _cb .SignatureValidationResult {},_be ;};_gf :=digest .(*_g .Buffer );
_cg .Content =_gf .Bytes ();if _be =_cg .Verify ();_be !=nil {return _cb .SignatureValidationResult {},_be ;};return _cb .SignatureValidationResult {IsSigned :true ,IsVerified :true },nil ;};

// NewAdobeX509RSASHA1Custom creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler with a custom signing function. Both the
// certificate and the sign function can be nil for the signature validation.
// NOTE: the handler will do a mock Sign when initializing the signature in
// order to estimate the signature size. Use NewAdobeX509RSASHA1CustomWithOpts
// for configuring the handler to estimate the signature size.
func NewAdobeX509RSASHA1Custom (certificate *_bg .Certificate ,signFunc SignFunc )(_cb .SignatureHandler ,error ){return &adobeX509RSASHA1 {_bcf :certificate ,_eaa :signFunc },nil ;};

// Sign sets the Contents fields for the PdfSignature.
func (_fe *docTimeStamp )Sign (sig *_cb .PdfSignature ,digest _cb .Hasher )error {_fcc ,_dfbg :=_ca .NewTimestampRequest (digest .(*_g .Buffer ),&_ga .RequestOptions {Hash :_fe ._fgfc ,Certificates :true });if _dfbg !=nil {return _dfbg ;};_aa :=_ca .NewTimestampClient ();
_ggf ,_dfbg :=_aa .GetEncodedToken (_fe ._faa ,_fcc );if _dfbg !=nil {return _dfbg ;};_ceg :=len (_ggf );if _fe ._gaa > 0&&_ceg > _fe ._gaa {return _cb .ErrSignNotEnoughSpace ;};if _ceg > 0{_fe ._gaa =_ceg +128;};sig .Contents =_fg .MakeHexString (string (_ggf ));
return nil ;};

// AdobeX509RSASHA1Opts defines options for configuring the adbe.x509.rsa_sha1
// signature handler.
type AdobeX509RSASHA1Opts struct{

// EstimateSize specifies whether the size of the signature contents
// should be estimated based on the modulus size of the public key
// extracted from the signing certificate. If set to false, a mock Sign
// call is made in order to estimate the size of the signature contents.
EstimateSize bool ;};

// InitSignature initialises the PdfSignature.
func (_bdc *docTimeStamp )InitSignature (sig *_cb .PdfSignature )error {_dff :=*_bdc ;sig .Handler =&_dff ;sig .Filter =_fg .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");sig .SubFilter =_fg .MakeName ("\u0045\u0054\u0053I\u002e\u0052\u0046\u0043\u0033\u0031\u0036\u0031");
sig .Reference =nil ;if _bdc ._gaa > 0{sig .Contents =_fg .MakeHexString (string (make ([]byte ,_bdc ._gaa )));}else {_dcd ,_eac :=_bdc .NewDigest (sig );if _eac !=nil {return _eac ;};_dcd .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));
if _eac =_dff .Sign (sig ,_dcd );_eac !=nil {return _eac ;};_bdc ._gaa =_dff ._gaa ;};return nil ;};

// SignFunc represents a custom signing function. The function should return
// the computed signature.
type SignFunc func (_eb *_cb .PdfSignature ,_fgf _cb .Hasher )([]byte ,error );

// NewAdobePKCS7Detached creates a new Adobe.PPKMS/Adobe.PPKLite adbe.pkcs7.detached signature handler.
// Both parameters may be nil for the signature validation.
func NewAdobePKCS7Detached (privateKey *_gdc .PrivateKey ,certificate *_bg .Certificate )(_cb .SignatureHandler ,error ){return &adobePKCS7Detached {_gb :certificate ,_bgb :privateKey },nil ;};

// NewAdobeX509RSASHA1CustomWithOpts creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler with a custom signing function. The
// handler is configured based on the provided options. If no options are
// provided, default options will be used. Both the certificate and the sign
// function can be nil for the signature validation.
func NewAdobeX509RSASHA1CustomWithOpts (certificate *_bg .Certificate ,signFunc SignFunc ,opts *AdobeX509RSASHA1Opts )(_cb .SignatureHandler ,error ){if opts ==nil {opts =&AdobeX509RSASHA1Opts {};};return &adobeX509RSASHA1 {_bcf :certificate ,_eaa :signFunc ,_fae :opts .EstimateSize },nil ;
};func (_bf *docTimeStamp )getCertificate (_ed *_cb .PdfSignature )(*_bg .Certificate ,error ){_eca ,_bee :=_ed .GetCerts ();if _bee !=nil {return nil ,_bee ;};return _eca [0],nil ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature
func (_afc *adobePKCS7Detached )IsApplicable (sig *_cb .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0061\u0064\u0062\u0065.p\u006b\u0063\u0073\u0037\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064";
};

// NewDocTimeStamp creates a new DocTimeStamp signature handler.
// Both the timestamp server URL and the hash algorithm can be empty for the
// signature validation.
// The following hash algorithms are supported:
// crypto.SHA1, crypto.SHA256, crypto.SHA384, crypto.SHA512.
// NOTE: the handler will do a mock Sign when initializing the signature
// in order to estimate the signature size. Use NewDocTimeStampWithOpts
// for providing the signature size.
func NewDocTimeStamp (timestampServerURL string ,hashAlgorithm _d .Hash )(_cb .SignatureHandler ,error ){return &docTimeStamp {_faa :timestampServerURL ,_fgfc :hashAlgorithm },nil ;};type adobePKCS7Detached struct{_bgb *_gdc .PrivateKey ;_gb *_bg .Certificate ;
_df bool ;_cbg int ;};type docTimeStamp struct{_faa string ;_fgfc _d .Hash ;_gaa int ;};

// InitSignature initialises the PdfSignature.
func (_bgg *adobeX509RSASHA1 )InitSignature (sig *_cb .PdfSignature )error {if _bgg ._bcf ==nil {return _dg .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");
};if _bgg ._fc ==nil &&_bgg ._eaa ==nil {return _dg .New ("\u006d\u0075\u0073\u0074\u0020\u0070\u0072o\u0076\u0069\u0064e\u0020\u0065\u0069t\u0068\u0065r\u0020\u0061\u0020\u0070\u0072\u0069v\u0061te\u0020\u006b\u0065\u0079\u0020\u006f\u0072\u0020\u0061\u0020\u0073\u0069\u0067\u006e\u0069\u006e\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e");
};_afcg :=*_bgg ;sig .Handler =&_afcg ;sig .Filter =_fg .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");sig .SubFilter =_fg .MakeName ("\u0061d\u0062e\u002e\u0078\u0035\u0030\u0039.\u0072\u0073a\u005f\u0073\u0068\u0061\u0031");
sig .Cert =_fg .MakeString (string (_afcg ._bcf .Raw ));sig .Reference =nil ;_bca ,_dfg :=_afcg .NewDigest (sig );if _dfg !=nil {return _dfg ;};_bca .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));
return _afcg .sign (sig ,_bca ,_bgg ._fae );};

// NewEmptyAdobePKCS7Detached creates a new Adobe.PPKMS/Adobe.PPKLite adbe.pkcs7.detached
// signature handler. The generated signature is empty and of size signatureLen.
// The signatureLen parameter can be 0 for the signature validation.
func NewEmptyAdobePKCS7Detached (signatureLen int )(_cb .SignatureHandler ,error ){return &adobePKCS7Detached {_df :true ,_cbg :signatureLen },nil ;};

// NewDigest creates a new digest.
func (_gab *adobePKCS7Detached )NewDigest (sig *_cb .PdfSignature )(_cb .Hasher ,error ){return _g .NewBuffer (nil ),nil ;};

// DocTimeStampOpts defines options for configuring the timestamp handler.
type DocTimeStampOpts struct{

// SignatureSize is the estimated size of the signature contents in bytes.
// If not provided, a default signature size of 4192 is used.
// The signing process will report the model.ErrSignNotEnoughSpace error
// if the estimated signature size is smaller than the actual size of the
// signature.
SignatureSize int ;};

// Validate validates PdfSignature.
func (_ab *adobeX509RSASHA1 )Validate (sig *_cb .PdfSignature ,digest _cb .Hasher )(_cb .SignatureValidationResult ,error ){_gg ,_ce :=_ab .getCertificate (sig );if _ce !=nil {return _cb .SignatureValidationResult {},_ce ;};_ccc :=sig .Contents .Bytes ();
var _fd []byte ;if _ ,_fac :=_f .Unmarshal (_ccc ,&_fd );_fac !=nil {return _cb .SignatureValidationResult {},_fac ;};_dfe ,_ee :=digest .(_gd .Hash );if !_ee {return _cb .SignatureValidationResult {},_dg .New ("\u0068a\u0073h\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_gfg ,_ :=_ecf (_gg .SignatureAlgorithm );if _bgc :=_gdc .VerifyPKCS1v15 (_gg .PublicKey .(*_gdc .PublicKey ),_gfg ,_dfe .Sum (nil ),_fd );_bgc !=nil {return _cb .SignatureValidationResult {},_bgc ;};return _cb .SignatureValidationResult {IsSigned :true ,IsVerified :true },nil ;
};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_egf *docTimeStamp )IsApplicable (sig *_cb .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0045\u0054\u0053I\u002e\u0052\u0046\u0043\u0033\u0031\u0036\u0031";
};

// NewDigest creates a new digest.
func (_ad *adobeX509RSASHA1 )NewDigest (sig *_cb .PdfSignature )(_cb .Hasher ,error ){_acf ,_gba :=_ad .getCertificate (sig );if _gba !=nil {return nil ,_gba ;};_cfa ,_ :=_ecf (_acf .SignatureAlgorithm );return _cfa .New (),nil ;};

// Validate validates PdfSignature.
func (_acg *docTimeStamp )Validate (sig *_cb .PdfSignature ,digest _cb .Hasher )(_cb .SignatureValidationResult ,error ){_eeb :=sig .Contents .Bytes ();_aea ,_cgc :=_e .Parse (_eeb );if _cgc !=nil {return _cb .SignatureValidationResult {},_cgc ;};if _cgc =_aea .Verify ();
_cgc !=nil {return _cb .SignatureValidationResult {},_cgc ;};var _ade timestampInfo ;_ ,_cgc =_f .Unmarshal (_aea .Content ,&_ade );if _cgc !=nil {return _cb .SignatureValidationResult {},_cgc ;};_gcc ,_cgc :=_abg (_ade .MessageImprint .HashAlgorithm .Algorithm );
if _cgc !=nil {return _cb .SignatureValidationResult {},_cgc ;};_bef :=_gcc .New ();_cbd :=digest .(*_g .Buffer );_bef .Write (_cbd .Bytes ());_dae :=_bef .Sum (nil );_cde :=_cb .SignatureValidationResult {IsSigned :true ,IsVerified :_g .Equal (_dae ,_ade .MessageImprint .HashedMessage ),GeneralizedTime :_ade .GeneralizedTime };
return _cde ,nil ;};