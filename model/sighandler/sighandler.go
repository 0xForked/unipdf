//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package sighandler implements digital signature handlers for PDF signature validation and signing.
package sighandler ;import (_e "bytes";_fe "crypto";_ad "crypto/rand";_fg "crypto/rsa";_dc "crypto/x509";_fa "crypto/x509/pkix";_dg "encoding/asn1";_de "errors";_g "fmt";_c "github.com/unidoc/pkcs7";_edb "github.com/unidoc/timestamp";_b "github.com/unidoc/unipdf/v3/core";_cg "github.com/unidoc/unipdf/v3/model";_a "hash";_ed "io";_f "io/ioutil";_dd "net/http";_eb "time";);

// IsApplicable returns true if the signature handler is applicable for the PdfSignature
func (_fbd *adobePKCS7Detached )IsApplicable (sig *_cg .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0061\u0064\u0062\u0065.p\u006b\u0063\u0073\u0037\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064";};

// DocTimeStampOpts defines options for configuring the timestamp handler.
type DocTimeStampOpts struct{

// SignatureSize is the estimated size of the signature contents in bytes.
// If not provided, a default signature size of 4192 is used.
// The signing process will report the model.ErrSignNotEnoughSpace error
// if the estimated signature size is smaller than the actual size of the
// signature.
SignatureSize int ;};

// InitSignature initialises the PdfSignature.
func (_ec *adobePKCS7Detached )InitSignature (sig *_cg .PdfSignature )error {if !_ec ._dgc {if _ec ._ga ==nil {return _de .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");};if _ec ._fgf ==nil {return _de .New ("\u0070\u0072\u0069\u0076\u0061\u0074\u0065\u004b\u0065\u0079\u0020m\u0075\u0073\u0074\u0020\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c");};};_ff :=*_ec ;sig .Handler =&_ff ;sig .Filter =_b .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");sig .SubFilter =_b .MakeName ("\u0061\u0064\u0062\u0065.p\u006b\u0063\u0073\u0037\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064");sig .Reference =nil ;_cgb ,_ef :=_ff .NewDigest (sig );if _ef !=nil {return _ef ;};_cgb .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));return _ff .Sign (sig ,_cgb );};func (_dee *adobePKCS7Detached )getCertificate (_gd *_cg .PdfSignature )(*_dc .Certificate ,error ){if _dee ._ga !=nil {return _dee ._ga ,nil ;};_eca ,_gag :=_gd .GetCerts ();if _gag !=nil {return nil ,_gag ;};return _eca [0],nil ;};

// Validate validates PdfSignature.
func (_cff *adobeX509RSASHA1 )Validate (sig *_cg .PdfSignature ,digest _cg .Hasher )(_cg .SignatureValidationResult ,error ){_fed ,_ea :=_cff .getCertificate (sig );if _ea !=nil {return _cg .SignatureValidationResult {},_ea ;};_edbg :=sig .Contents .Bytes ();var _gfa []byte ;if _ ,_ffd :=_dg .Unmarshal (_edbg ,&_gfa );_ffd !=nil {return _cg .SignatureValidationResult {},_ffd ;};_bde ,_efb :=digest .(_a .Hash );if !_efb {return _cg .SignatureValidationResult {},_de .New ("\u0068a\u0073h\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_aca ,_ :=_fgb (_fed .SignatureAlgorithm );if _ca :=_fg .VerifyPKCS1v15 (_fed .PublicKey .(*_fg .PublicKey ),_aca ,_bde .Sum (nil ),_gfa );_ca !=nil {return _cg .SignatureValidationResult {},_ca ;};return _cg .SignatureValidationResult {IsSigned :true ,IsVerified :true },nil ;};

// NewDigest creates a new digest.
func (_gf *adobePKCS7Detached )NewDigest (sig *_cg .PdfSignature )(_cg .Hasher ,error ){return _e .NewBuffer (nil ),nil ;};

// AdobeX509RSASHA1Opts defines options for configuring the adbe.x509.rsa_sha1
// signature handler.
type AdobeX509RSASHA1Opts struct{

// EstimateSize specifies whether the size of the signature contents
// should be estimated based on the modulus size of the public key
// extracted from the signing certificate. If set to false, a mock Sign
// call is made in order to estimate the size of the signature contents.
EstimateSize bool ;};

// NewDocTimeStampWithOpts returns a new DocTimeStamp configured using the
// specified options. If no options are provided, default options will be used.
// Both the timestamp server URL and the hash algorithm can be empty for the
// signature validation.
// The following hash algorithms are supported:
// crypto.SHA1, crypto.SHA256, crypto.SHA384, crypto.SHA512.
func NewDocTimeStampWithOpts (timestampServerURL string ,hashAlgorithm _fe .Hash ,opts *DocTimeStampOpts )(_cg .SignatureHandler ,error ){if opts ==nil {opts =&DocTimeStampOpts {};};if opts .SignatureSize <=0{opts .SignatureSize =4192;};return &docTimeStamp {_abe :timestampServerURL ,_cb :hashAlgorithm ,_bf :opts .SignatureSize },nil ;};

// SignFunc represents a custom signing function. The function should return
// the computed signature.
type SignFunc func (_cd *_cg .PdfSignature ,_af _cg .Hasher )([]byte ,error );type adobePKCS7Detached struct{_fgf *_fg .PrivateKey ;_ga *_dc .Certificate ;_dgc bool ;_db int ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_fggg *docTimeStamp )IsApplicable (sig *_cg .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0045\u0054\u0053I\u002e\u0052\u0046\u0043\u0033\u0031\u0036\u0031";};type docTimeStamp struct{_abe string ;_cb _fe .Hash ;_bf int ;};

// NewDocTimeStamp creates a new DocTimeStamp signature handler.
// Both the timestamp server URL and the hash algorithm can be empty for the
// signature validation.
// The following hash algorithms are supported:
// crypto.SHA1, crypto.SHA256, crypto.SHA384, crypto.SHA512.
// NOTE: the handler will do a mock Sign when initializing the signature
// in order to estimate the signature size. Use NewDocTimeStampWithOpts
// for providing the signature size.
func NewDocTimeStamp (timestampServerURL string ,hashAlgorithm _fe .Hash )(_cg .SignatureHandler ,error ){return &docTimeStamp {_abe :timestampServerURL ,_cb :hashAlgorithm },nil ;};

// Validate validates PdfSignature.
func (_fef *adobePKCS7Detached )Validate (sig *_cg .PdfSignature ,digest _cg .Hasher )(_cg .SignatureValidationResult ,error ){_ade :=sig .Contents .Bytes ();_fb ,_gb :=_c .Parse (_ade );if _gb !=nil {return _cg .SignatureValidationResult {},_gb ;};_gfe :=digest .(*_e .Buffer );_fb .Content =_gfe .Bytes ();if _gb =_fb .Verify ();_gb !=nil {return _cg .SignatureValidationResult {},_gb ;};return _cg .SignatureValidationResult {IsSigned :true ,IsVerified :true },nil ;};

// Validate validates PdfSignature.
func (_dge *docTimeStamp )Validate (sig *_cg .PdfSignature ,digest _cg .Hasher )(_cg .SignatureValidationResult ,error ){_fgg :=sig .Contents .Bytes ();_eae ,_gfc :=_c .Parse (_fgg );if _gfc !=nil {return _cg .SignatureValidationResult {},_gfc ;};if _gfc =_eae .Verify ();_gfc !=nil {return _cg .SignatureValidationResult {},_gfc ;};var _ag timestampInfo ;_ ,_gfc =_dg .Unmarshal (_eae .Content ,&_ag );if _gfc !=nil {return _cg .SignatureValidationResult {},_gfc ;};_bfa ,_gfc :=_ecb (_ag .MessageImprint .HashAlgorithm .Algorithm );if _gfc !=nil {return _cg .SignatureValidationResult {},_gfc ;};_gbb :=_bfa .New ();_afce :=digest .(*_e .Buffer );_gbb .Write (_afce .Bytes ());_fbdg :=_gbb .Sum (nil );_cee :=_cg .SignatureValidationResult {IsSigned :true ,IsVerified :_e .Equal (_fbdg ,_ag .MessageImprint .HashedMessage ),GeneralizedTime :_ag .GeneralizedTime };return _cee ,nil ;};

// NewAdobeX509RSASHA1CustomWithOpts creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler with a custom signing function. The
// handler is configured based on the provided options. If no options are
// provided, default options will be used. Both the certificate and the sign
// function can be nil for the signature validation.
func NewAdobeX509RSASHA1CustomWithOpts (certificate *_dc .Certificate ,signFunc SignFunc ,opts *AdobeX509RSASHA1Opts )(_cg .SignatureHandler ,error ){if opts ==nil {opts =&AdobeX509RSASHA1Opts {};};return &adobeX509RSASHA1 {_fd :certificate ,_afc :signFunc ,_gdb :opts .EstimateSize },nil ;};type timestampInfo struct{Version int ;Policy _dg .RawValue ;MessageImprint struct{HashAlgorithm _fa .AlgorithmIdentifier ;HashedMessage []byte ;};SerialNumber _dg .RawValue ;GeneralizedTime _eb .Time ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_ffa *adobeX509RSASHA1 )IsApplicable (sig *_cg .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0061d\u0062e\u002e\u0078\u0035\u0030\u0039.\u0072\u0073a\u005f\u0073\u0068\u0061\u0031";};type adobeX509RSASHA1 struct{_gdc *_fg .PrivateKey ;_fd *_dc .Certificate ;_afc SignFunc ;_gdb bool ;};

// NewAdobeX509RSASHA1Custom creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler with a custom signing function. Both the
// certificate and the sign function can be nil for the signature validation.
// NOTE: the handler will do a mock Sign when initializing the signature in
// order to estimate the signature size. Use NewAdobeX509RSASHA1CustomWithOpts
// for configuring the handler to estimate the signature size.
func NewAdobeX509RSASHA1Custom (certificate *_dc .Certificate ,signFunc SignFunc )(_cg .SignatureHandler ,error ){return &adobeX509RSASHA1 {_fd :certificate ,_afc :signFunc },nil ;};

// NewAdobePKCS7Detached creates a new Adobe.PPKMS/Adobe.PPKLite adbe.pkcs7.detached signature handler.
// Both parameters may be nil for the signature validation.
func NewAdobePKCS7Detached (privateKey *_fg .PrivateKey ,certificate *_dc .Certificate )(_cg .SignatureHandler ,error ){return &adobePKCS7Detached {_ga :certificate ,_fgf :privateKey },nil ;};func (_gce *adobeX509RSASHA1 )getCertificate (_df *_cg .PdfSignature )(*_dc .Certificate ,error ){if _gce ._fd !=nil {return _gce ._fd ,nil ;};_dec ,_cda :=_df .GetCerts ();if _cda !=nil {return nil ,_cda ;};return _dec [0],nil ;};

// NewDigest creates a new digest.
func (_bd *adobeX509RSASHA1 )NewDigest (sig *_cg .PdfSignature )(_cg .Hasher ,error ){_bcg ,_ac :=_bd .getCertificate (sig );if _ac !=nil {return nil ,_ac ;};_ffg ,_ :=_fgb (_bcg .SignatureAlgorithm );return _ffg .New (),nil ;};

// InitSignature initialises the PdfSignature.
func (_ffae *docTimeStamp )InitSignature (sig *_cg .PdfSignature )error {_fgc :=*_ffae ;sig .Handler =&_fgc ;sig .Filter =_b .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");sig .SubFilter =_b .MakeName ("\u0045\u0054\u0053I\u002e\u0052\u0046\u0043\u0033\u0031\u0036\u0031");sig .Reference =nil ;if _ffae ._bf > 0{sig .Contents =_b .MakeHexString (string (make ([]byte ,_ffae ._bf )));}else {_fefa ,_fcda :=_ffae .NewDigest (sig );if _fcda !=nil {return _fcda ;};_fefa .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));if _fcda =_fgc .Sign (sig ,_fefa );_fcda !=nil {return _fcda ;};_ffae ._bf =_fgc ._bf ;};return nil ;};func _ecb (_eaf _dg .ObjectIdentifier )(_fe .Hash ,error ){switch {case _eaf .Equal (_c .OIDDigestAlgorithmSHA1 ),_eaf .Equal (_c .OIDDigestAlgorithmECDSASHA1 ),_eaf .Equal (_c .OIDDigestAlgorithmDSA ),_eaf .Equal (_c .OIDDigestAlgorithmDSASHA1 ),_eaf .Equal (_c .OIDEncryptionAlgorithmRSA ):return _fe .SHA1 ,nil ;case _eaf .Equal (_c .OIDDigestAlgorithmSHA256 ),_eaf .Equal (_c .OIDDigestAlgorithmECDSASHA256 ):return _fe .SHA256 ,nil ;case _eaf .Equal (_c .OIDDigestAlgorithmSHA384 ),_eaf .Equal (_c .OIDDigestAlgorithmECDSASHA384 ):return _fe .SHA384 ,nil ;case _eaf .Equal (_c .OIDDigestAlgorithmSHA512 ),_eaf .Equal (_c .OIDDigestAlgorithmECDSASHA512 ):return _fe .SHA512 ,nil ;};return _fe .Hash (0),_c .ErrUnsupportedAlgorithm ;};

// InitSignature initialises the PdfSignature.
func (_cc *adobeX509RSASHA1 )InitSignature (sig *_cg .PdfSignature )error {if _cc ._fd ==nil {return _de .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");};if _cc ._gdc ==nil &&_cc ._afc ==nil {return _de .New ("\u006d\u0075\u0073\u0074\u0020\u0070\u0072o\u0076\u0069\u0064e\u0020\u0065\u0069t\u0068\u0065r\u0020\u0061\u0020\u0070\u0072\u0069v\u0061te\u0020\u006b\u0065\u0079\u0020\u006f\u0072\u0020\u0061\u0020\u0073\u0069\u0067\u006e\u0069\u006e\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e");};_eg :=*_cc ;sig .Handler =&_eg ;sig .Filter =_b .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");sig .SubFilter =_b .MakeName ("\u0061d\u0062e\u002e\u0078\u0035\u0030\u0039.\u0072\u0073a\u005f\u0073\u0068\u0061\u0031");sig .Cert =_b .MakeString (string (_eg ._fd .Raw ));sig .Reference =nil ;_cf ,_abg :=_eg .NewDigest (sig );if _abg !=nil {return _abg ;};_cf .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));return _eg .sign (sig ,_cf ,_cc ._gdb );};

// NewAdobeX509RSASHA1 creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler. Both the private key and the
// certificate can be nil for the signature validation.
func NewAdobeX509RSASHA1 (privateKey *_fg .PrivateKey ,certificate *_dc .Certificate )(_cg .SignatureHandler ,error ){return &adobeX509RSASHA1 {_fd :certificate ,_gdc :privateKey },nil ;};

// NewDigest creates a new digest.
func (_cfc *docTimeStamp )NewDigest (sig *_cg .PdfSignature )(_cg .Hasher ,error ){return _e .NewBuffer (nil ),nil ;};

// Sign sets the Contents fields.
func (_ab *adobePKCS7Detached )Sign (sig *_cg .PdfSignature ,digest _cg .Hasher )error {if _ab ._dgc {_ge :=_ab ._db ;if _ge <=0{_ge =8192;};sig .Contents =_b .MakeHexString (string (make ([]byte ,_ge )));return nil ;};_dea :=digest .(*_e .Buffer );_bc ,_efg :=_c .NewSignedData (_dea .Bytes ());if _efg !=nil {return _efg ;};if _dga :=_bc .AddSigner (_ab ._ga ,_ab ._fgf ,_c .SignerInfoConfig {});_dga !=nil {return _dga ;};_bc .Detach ();_gdf ,_efg :=_bc .Finish ();if _efg !=nil {return _efg ;};_ba :=make ([]byte ,8192);copy (_ba ,_gdf );sig .Contents =_b .MakeHexString (string (_ba ));return nil ;};

// NewEmptyAdobePKCS7Detached creates a new Adobe.PPKMS/Adobe.PPKLite adbe.pkcs7.detached
// signature handler. The generated signature is empty and of size signatureLen.
// The signatureLen parameter can be 0 for the signature validation.
func NewEmptyAdobePKCS7Detached (signatureLen int )(_cg .SignatureHandler ,error ){return &adobePKCS7Detached {_dgc :true ,_db :signatureLen },nil ;};func (_bcgc *adobeX509RSASHA1 )sign (_gdd *_cg .PdfSignature ,_gff _cg .Hasher ,_gac bool )error {if !_gac {return _bcgc .Sign (_gdd ,_gff );};_ce ,_ebg :=_bcgc ._fd .PublicKey .(*_fg .PublicKey );if !_ebg {return _g .Errorf ("i\u006e\u0076\u0061\u006c\u0069\u0064 \u0070\u0075\u0062\u006c\u0069\u0063\u0020\u006b\u0065y\u0020\u0074\u0079p\u0065:\u0020\u0025\u0054",_ce );};_bce ,_gcd :=_dg .Marshal (make ([]byte ,_ce .Size ()));if _gcd !=nil {return _gcd ;};_gdd .Contents =_b .MakeHexString (string (_bce ));return nil ;};

// Sign sets the Contents fields for the PdfSignature.
func (_dbe *adobeX509RSASHA1 )Sign (sig *_cg .PdfSignature ,digest _cg .Hasher )error {var _bb []byte ;var _fc error ;if _dbe ._afc !=nil {_bb ,_fc =_dbe ._afc (sig ,digest );if _fc !=nil {return _fc ;};}else {_caa ,_gcc :=digest .(_a .Hash );if !_gcc {return _de .New ("\u0068a\u0073h\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_fdg ,_ :=_fgb (_dbe ._fd .SignatureAlgorithm );_bb ,_fc =_fg .SignPKCS1v15 (_ad .Reader ,_dbe ._gdc ,_fdg ,_caa .Sum (nil ));if _fc !=nil {return _fc ;};};_bb ,_fc =_dg .Marshal (_bb );if _fc !=nil {return _fc ;};sig .Contents =_b .MakeHexString (string (_bb ));return nil ;};

// Sign sets the Contents fields for the PdfSignature.
func (_gef *docTimeStamp )Sign (sig *_cg .PdfSignature ,digest _cg .Hasher )error {_efbf :=digest .(*_e .Buffer );_aeg :=_gef ._cb .New ();if _ ,_aba :=_ed .Copy (_aeg ,_efbf );_aba !=nil {return _aba ;};_cbe :=_edb .Request {HashAlgorithm :_gef ._cb ,HashedMessage :_aeg .Sum (nil ),Certificates :true ,Extensions :nil ,ExtraExtensions :nil };_dgg ,_cbg :=_cbe .Marshal ();if _cbg !=nil {return _cbg ;};_acc ,_cbg :=_dd .Post (_gef ._abe ,"a\u0070\u0070\u006c\u0069\u0063\u0061t\u0069\u006f\u006e\u002f\u0074\u0069\u006d\u0065\u0073t\u0061\u006d\u0070-\u0071u\u0065\u0072\u0079",_e .NewBuffer (_dgg ));if _cbg !=nil {return _cbg ;};defer _acc .Body .Close ();_cdg ,_cbg :=_f .ReadAll (_acc .Body );if _cbg !=nil {return _cbg ;};if _acc .StatusCode !=_dd .StatusOK {return _g .Errorf ("\u0068\u0074\u0074\u0070\u0020\u0073\u0074\u0061\u0074\u0075\u0073\u0020\u0063\u006f\u0064e\u0020n\u006f\u0074\u0020\u006f\u006b\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0064\u0029",_acc .StatusCode );};var _deeb struct{Version _dg .RawValue ;Content _dg .RawValue ;};if _ ,_cbg =_dg .Unmarshal (_cdg ,&_deeb );_cbg !=nil {return _cbg ;};_aed :=len (_deeb .Content .FullBytes );if _gef ._bf > 0&&_aed > _gef ._bf {return _cg .ErrSignNotEnoughSpace ;};if _aed > 0{_gef ._bf =_aed +128;};sig .Contents =_b .MakeHexString (string (_deeb .Content .FullBytes ));return nil ;};func (_bfg *docTimeStamp )getCertificate (_ece *_cg .PdfSignature )(*_dc .Certificate ,error ){_fgd ,_ede :=_ece .GetCerts ();if _ede !=nil {return nil ,_ede ;};return _fgd [0],nil ;};func _fgb (_ae _dc .SignatureAlgorithm )(_fe .Hash ,bool ){var _gc _fe .Hash ;switch _ae {case _dc .SHA1WithRSA :_gc =_fe .SHA1 ;case _dc .SHA256WithRSA :_gc =_fe .SHA256 ;case _dc .SHA384WithRSA :_gc =_fe .SHA384 ;case _dc .SHA512WithRSA :_gc =_fe .SHA512 ;default:return _fe .SHA1 ,false ;};return _gc ,true ;};