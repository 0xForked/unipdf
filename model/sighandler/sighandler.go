//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package sighandler implements digital signature handlers for PDF signature validation and signing.
package sighandler ;import (_g "bytes";_cb "crypto";_bg "crypto/rand";_ba "crypto/rsa";_e "crypto/x509";_c "crypto/x509/pkix";_bb "encoding/asn1";_fd "encoding/hex";_a "errors";_da "fmt";_bf "github.com/unidoc/pkcs7";_gf "github.com/unidoc/timestamp";_eb "github.com/unidoc/unipdf/v3/common";
_fc "github.com/unidoc/unipdf/v3/core";_ad "github.com/unidoc/unipdf/v3/model";_eg "github.com/unidoc/unipdf/v3/model/mdp";_ee "github.com/unidoc/unipdf/v3/model/sigutil";_fa "hash";_d "math/big";_b "strings";_fae "time";);func _ggd (_gcfg *_ba .PublicKey ,_gadd []byte )_cb .Hash {_gdb :=_gcfg .Size ();
if _gdb !=len (_gadd ){return 0;};_gdca :=func (_agb *_d .Int ,_eafed *_ba .PublicKey ,_dbc *_d .Int )*_d .Int {_gfd :=_d .NewInt (int64 (_eafed .E ));_agb .Exp (_dbc ,_gfd ,_eafed .N );return _agb ;};_fbd :=new (_d .Int ).SetBytes (_gadd );_cgfg :=_gdca (new (_d .Int ),_gcfg ,_fbd );
_egd :=_bgc (_cgfg .Bytes (),_gdb );if _egd [0]!=0||_egd [1]!=1{return 0;};_efb :=[]struct{Hash _cb .Hash ;Prefix []byte ;}{{Hash :_cb .SHA1 ,Prefix :[]byte {0x30,0x21,0x30,0x09,0x06,0x05,0x2b,0x0e,0x03,0x02,0x1a,0x05,0x00,0x04,0x14}},{Hash :_cb .SHA256 ,Prefix :[]byte {0x30,0x31,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x01,0x05,0x00,0x04,0x20}},{Hash :_cb .SHA384 ,Prefix :[]byte {0x30,0x41,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x02,0x05,0x00,0x04,0x30}},{Hash :_cb .SHA512 ,Prefix :[]byte {0x30,0x51,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x03,0x05,0x00,0x04,0x40}},{Hash :_cb .RIPEMD160 ,Prefix :[]byte {0x30,0x20,0x30,0x08,0x06,0x06,0x28,0xcf,0x06,0x03,0x00,0x31,0x04,0x14}}};
for _ ,_ecef :=range _efb {_begg :=_ecef .Hash .Size ();_gdbf :=len (_ecef .Prefix )+_begg ;if _g .Equal (_egd [_gdb -_gdbf :_gdb -_begg ],_ecef .Prefix ){return _ecef .Hash ;};};return 0;};

// InitSignature initialises the PdfSignature.
func (_ade *docTimeStamp )InitSignature (sig *_ad .PdfSignature )error {_gaa :=*_ade ;sig .Type =_fc .MakeName ("\u0044\u006f\u0063T\u0069\u006d\u0065\u0053\u0074\u0061\u006d\u0070");sig .Handler =&_gaa ;sig .Filter =_fc .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");
sig .SubFilter =_fc .MakeName ("\u0045\u0054\u0053I\u002e\u0052\u0046\u0043\u0033\u0031\u0036\u0031");sig .Reference =nil ;if _ade ._ecf > 0{sig .Contents =_fc .MakeHexString (string (make ([]byte ,_ade ._ecf )));}else {_dggb ,_bfg :=_ade .NewDigest (sig );
if _bfg !=nil {return _bfg ;};_dggb .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));if _bfg =_gaa .Sign (sig ,_dggb );
_bfg !=nil {return _bfg ;};_ade ._ecf =_gaa ._ecf ;};return nil ;};

// DocTimeStampOpts defines options for configuring the timestamp handler.
type DocTimeStampOpts struct{

// SignatureSize is the estimated size of the signature contents in bytes.
// If not provided, a default signature size of 4192 is used.
// The signing process will report the model.ErrSignNotEnoughSpace error
// if the estimated signature size is smaller than the actual size of the
// signature.
SignatureSize int ;

// Client is the timestamp client used to make the signature request.
// If no client is provided, a default one is used.
Client *_ee .TimestampClient ;};

// Sign sets the Contents fields for the PdfSignature.
func (_gbcc *adobeX509RSASHA1 )Sign (sig *_ad .PdfSignature ,digest _ad .Hasher )error {var _efc []byte ;var _aea error ;if _gbcc ._gbbb !=nil {_efc ,_aea =_gbcc ._gbbb (sig ,digest );if _aea !=nil {return _aea ;};}else {_cfe ,_abab :=digest .(_fa .Hash );
if !_abab {return _a .New ("\u0068a\u0073h\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_fgc :=_fdb ;if _gbcc ._cba !=0{_fgc =_gbcc ._cba ;};_efc ,_aea =_ba .SignPKCS1v15 (_bg .Reader ,_gbcc ._aef ,_fgc ,_cfe .Sum (nil ));if _aea !=nil {return _aea ;
};};_efc ,_aea =_bb .Marshal (_efc );if _aea !=nil {return _aea ;};sig .Contents =_fc .MakeHexString (string (_efc ));return nil ;};

// NewAdobeX509RSASHA1 creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler. Both the private key and the
// certificate can be nil for the signature validation.
func NewAdobeX509RSASHA1 (privateKey *_ba .PrivateKey ,certificate *_e .Certificate )(_ad .SignatureHandler ,error ){return &adobeX509RSASHA1 {_fdc :certificate ,_aef :privateKey },nil ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_cc *DocMDPHandler )IsApplicable (sig *_ad .PdfSignature )bool {_fdd :=false ;for _ ,_ge :=range sig .Reference .Elements (){if _fde ,_fb :=_fc .GetDict (_ge );_fb {if _gd ,_fbc :=_fc .GetNameVal (_fde .Get ("\u0054r\u0061n\u0073\u0066\u006f\u0072\u006d\u004d\u0065\u0074\u0068\u006f\u0064"));
_fbc {if _gd !="\u0044\u006f\u0063\u004d\u0044\u0050"{return false ;};if _bge ,_af :=_fc .GetDict (_fde .Get ("\u0054r\u0061n\u0073\u0066\u006f\u0072\u006d\u0050\u0061\u0072\u0061\u006d\u0073"));_af {_ ,_ebd :=_fc .GetNumberAsInt64 (_bge .Get ("\u0050"));
if _ebd !=nil {return false ;};_fdd =true ;break ;};};};};return _fdd &&_cc ._df .IsApplicable (sig );};

// ValidateWithOpts validates a PDF signature by checking PdfReader or PdfParser by the DiffPolicy
// params describes parameters for the DocMDP checks.
func (_ab *DocMDPHandler )ValidateWithOpts (sig *_ad .PdfSignature ,digest _ad .Hasher ,params _ad .SignatureHandlerDocMDPParams )(_ad .SignatureValidationResult ,error ){_baa ,_dfb :=_ab ._df .Validate (sig ,digest );if _dfb !=nil {return _baa ,_dfb ;
};_cg :=params .Parser ;if _cg ==nil {return _ad .SignatureValidationResult {},_a .New ("p\u0061r\u0073\u0065\u0072\u0020\u0063\u0061\u006e\u0027t\u0020\u0062\u0065\u0020nu\u006c\u006c");};if !_baa .IsVerified {return _baa ,nil ;};_gc :=params .DiffPolicy ;
if _gc ==nil {_gc =_eg .NewDefaultDiffPolicy ();};for _gcf :=0;_gcf <=_cg .GetRevisionNumber ();_gcf ++{_dfd ,_dfa :=_cg .GetRevision (_gcf );if _dfa !=nil {return _ad .SignatureValidationResult {},_dfa ;};_fcd :=_dfd .GetTrailer ();if _fcd ==nil {return _ad .SignatureValidationResult {},_a .New ("\u0075\u006e\u0064\u0065f\u0069\u006e\u0065\u0064\u0020\u0074\u0068\u0065\u0020\u0074r\u0061i\u006c\u0065\u0072\u0020\u006f\u0062\u006ae\u0063\u0074");
};_ce ,_gg :=_fc .GetDict (_fcd .Get ("\u0052\u006f\u006f\u0074"));if !_gg {return _ad .SignatureValidationResult {},_a .New ("\u0075n\u0064\u0065\u0066\u0069n\u0065\u0064\u0020\u0074\u0068e\u0020r\u006fo\u0074\u0020\u006f\u0062\u006a\u0065\u0063t");};
_bc ,_gg :=_fc .GetDict (_ce .Get ("\u0041\u0063\u0072\u006f\u0046\u006f\u0072\u006d"));if !_gg {continue ;};_db ,_gg :=_fc .GetArray (_bc .Get ("\u0046\u0069\u0065\u006c\u0064\u0073"));if !_gg {continue ;};for _ ,_cbg :=range _db .Elements (){_dag ,_ege :=_fc .GetDict (_cbg );
if !_ege {continue ;};_cbgb ,_ege :=_fc .GetDict (_dag .Get ("\u0056"));if !_ege {continue ;};if _fc .EqualObjects (_cbgb .Get ("\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"),sig .Contents ){_baa .DiffResults ,_dfa =_gc .ReviewFile (_dfd ,_cg ,&_eg .MDPParameters {DocMDPLevel :_ab .Permission });
if _dfa !=nil {return _ad .SignatureValidationResult {},_dfa ;};_baa .IsVerified =_baa .DiffResults .IsPermitted ();return _baa ,nil ;};};};return _ad .SignatureValidationResult {},_a .New ("\u0064\u006f\u006e\u0027\u0074\u0020\u0066o\u0075\u006e\u0064 \u0074\u0068\u0069\u0073 \u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0069\u006e\u0020\u0074\u0068\u0065\u0020\u0072\u0065\u0076\u0069\u0073\u0069\u006f\u006e\u0073");
};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_fee *docTimeStamp )IsApplicable (sig *_ad .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0045\u0054\u0053I\u002e\u0052\u0046\u0043\u0033\u0031\u0036\u0031";
};

// NewDocTimeStampWithOpts returns a new DocTimeStamp configured using the
// specified options. If no options are provided, default options will be used.
// Both the timestamp server URL and the hash algorithm can be empty for the
// signature validation.
// The following hash algorithms are supported:
// crypto.SHA1, crypto.SHA256, crypto.SHA384, crypto.SHA512.
func NewDocTimeStampWithOpts (timestampServerURL string ,hashAlgorithm _cb .Hash ,opts *DocTimeStampOpts )(_ad .SignatureHandler ,error ){if opts ==nil {opts =&DocTimeStampOpts {};};if opts .SignatureSize <=0{opts .SignatureSize =4192;};return &docTimeStamp {_gef :timestampServerURL ,_edb :hashAlgorithm ,_ecf :opts .SignatureSize ,_bbe :opts .Client },nil ;
};func _acgb (_gde _bb .ObjectIdentifier )(_cb .Hash ,error ){switch {case _gde .Equal (_bf .OIDDigestAlgorithmSHA1 ),_gde .Equal (_bf .OIDDigestAlgorithmECDSASHA1 ),_gde .Equal (_bf .OIDDigestAlgorithmDSA ),_gde .Equal (_bf .OIDDigestAlgorithmDSASHA1 ),_gde .Equal (_bf .OIDEncryptionAlgorithmRSA ):return _cb .SHA1 ,nil ;
case _gde .Equal (_bf .OIDDigestAlgorithmSHA256 ),_gde .Equal (_bf .OIDDigestAlgorithmECDSASHA256 ):return _cb .SHA256 ,nil ;case _gde .Equal (_bf .OIDDigestAlgorithmSHA384 ),_gde .Equal (_bf .OIDDigestAlgorithmECDSASHA384 ):return _cb .SHA384 ,nil ;case _gde .Equal (_bf .OIDDigestAlgorithmSHA512 ),_gde .Equal (_bf .OIDDigestAlgorithmECDSASHA512 ):return _cb .SHA512 ,nil ;
};return _cb .Hash (0),_bf .ErrUnsupportedAlgorithm ;};

// Validate validates PdfSignature.
func (_bgef *adobePKCS7Detached )Validate (sig *_ad .PdfSignature ,digest _ad .Hasher )(_ad .SignatureValidationResult ,error ){_gadc :=sig .Contents .Bytes ();_gbb ,_beg :=_bf .Parse (_gadc );if _beg !=nil {return _ad .SignatureValidationResult {},_beg ;
};_eaef ,_aee :=digest .(*_g .Buffer );if !_aee {return _ad .SignatureValidationResult {},_da .Errorf ("c\u0061s\u0074\u0020\u0074\u006f\u0020\u0062\u0075\u0066f\u0065\u0072\u0020\u0066ai\u006c\u0073");};_gbb .Content =_eaef .Bytes ();if _beg =_gbb .Verify ();
_beg !=nil {return _ad .SignatureValidationResult {},_beg ;};return _ad .SignatureValidationResult {IsSigned :true ,IsVerified :true },nil ;};

// NewAdobeX509RSASHA1CustomWithOpts creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler with a custom signing function. The
// handler is configured based on the provided options. If no options are
// provided, default options will be used. Both the certificate and the sign
// function can be nil for the signature validation.
func NewAdobeX509RSASHA1CustomWithOpts (certificate *_e .Certificate ,signFunc SignFunc ,opts *AdobeX509RSASHA1Opts )(_ad .SignatureHandler ,error ){if opts ==nil {opts =&AdobeX509RSASHA1Opts {};};return &adobeX509RSASHA1 {_fdc :certificate ,_gbbb :signFunc ,_eefb :opts .EstimateSize ,_cba :opts .Algorithm },nil ;
};type etsiPAdES struct{_ea *_ba .PrivateKey ;_bbg *_e .Certificate ;_dc bool ;_bcb bool ;_acb *_e .Certificate ;_eaf string ;

// CertClient is the client used to retrieve certificates.
CertClient *_ee .CertClient ;

// OCSPClient is the client used to retrieve OCSP validation information.
OCSPClient *_ee .OCSPClient ;

// CRLClient is the client used to retrieve CRL validation information.
CRLClient *_ee .CRLClient ;_faec *_ad .PdfAppender ;_adg *_ad .DSS ;};

// DocMDPHandler describes handler for the DocMDP realization.
type DocMDPHandler struct{_df _ad .SignatureHandler ;Permission _eg .DocMDPPermission ;};

// InitSignature initialises the PdfSignature.
func (_aa *etsiPAdES )InitSignature (sig *_ad .PdfSignature )error {if !_aa ._dc {if _aa ._bbg ==nil {return _a .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");
};if _aa ._ea ==nil {return _a .New ("\u0070\u0072\u0069\u0076\u0061\u0074\u0065\u004b\u0065\u0079\u0020m\u0075\u0073\u0074\u0020\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c");};};_dd :=*_aa ;sig .Handler =&_dd ;sig .Filter =_fc .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");
sig .SubFilter =_fc .MakeName ("\u0045\u0054\u0053\u0049.C\u0041\u0064\u0045\u0053\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064");sig .Reference =nil ;_ddc ,_cf :=_dd .NewDigest (sig );if _cf !=nil {return _cf ;};_ ,_cf =_ddc .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));
if _cf !=nil {return _cf ;};_dd ._bcb =true ;_cf =_dd .Sign (sig ,_ddc );_dd ._bcb =false ;return _cf ;};

// NewEmptyAdobePKCS7Detached creates a new Adobe.PPKMS/Adobe.PPKLite adbe.pkcs7.detached
// signature handler. The generated signature is empty and of size signatureLen.
// The signatureLen parameter can be 0 for the signature validation.
func NewEmptyAdobePKCS7Detached (signatureLen int )(_ad .SignatureHandler ,error ){return &adobePKCS7Detached {_edd :true ,_ffde :signatureLen },nil ;};

// NewDigest creates a new digest.
func (_adff *DocMDPHandler )NewDigest (sig *_ad .PdfSignature )(_ad .Hasher ,error ){return _adff ._df .NewDigest (sig );};

// InitSignature initialises the PdfSignature.
func (_gcg *adobePKCS7Detached )InitSignature (sig *_ad .PdfSignature )error {if !_gcg ._edd {if _gcg ._eea ==nil {return _a .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");
};if _gcg ._cdb ==nil {return _a .New ("\u0070\u0072\u0069\u0076\u0061\u0074\u0065\u004b\u0065\u0079\u0020m\u0075\u0073\u0074\u0020\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c");};};_aab :=*_gcg ;sig .Handler =&_aab ;sig .Filter =_fc .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");
sig .SubFilter =_fc .MakeName ("\u0061\u0064\u0062\u0065.p\u006b\u0063\u0073\u0037\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064");sig .Reference =nil ;_efa ,_ggf :=_aab .NewDigest (sig );if _ggf !=nil {return _ggf ;};_efa .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));
return _aab .Sign (sig ,_efa );};

// Validate validates PdfSignature.
func (_fdgc *docTimeStamp )Validate (sig *_ad .PdfSignature ,digest _ad .Hasher )(_ad .SignatureValidationResult ,error ){_eadg :=sig .Contents .Bytes ();_bgcf ,_gdg :=_bf .Parse (_eadg );if _gdg !=nil {return _ad .SignatureValidationResult {},_gdg ;};
if _gdg =_bgcf .Verify ();_gdg !=nil {return _ad .SignatureValidationResult {},_gdg ;};var _cda timestampInfo ;_ ,_gdg =_bb .Unmarshal (_bgcf .Content ,&_cda );if _gdg !=nil {return _ad .SignatureValidationResult {},_gdg ;};_dgbb ,_gdg :=_acgb (_cda .MessageImprint .HashAlgorithm .Algorithm );
if _gdg !=nil {return _ad .SignatureValidationResult {},_gdg ;};_eaa :=_dgbb .New ();_bgg ,_fef :=digest .(*_g .Buffer );if !_fef {return _ad .SignatureValidationResult {},_da .Errorf ("c\u0061s\u0074\u0020\u0074\u006f\u0020\u0062\u0075\u0066f\u0065\u0072\u0020\u0066ai\u006c\u0073");
};_eaa .Write (_bgg .Bytes ());_bedb :=_eaa .Sum (nil );_ebe :=_ad .SignatureValidationResult {IsSigned :true ,IsVerified :_g .Equal (_bedb ,_cda .MessageImprint .HashedMessage ),GeneralizedTime :_cda .GeneralizedTime };return _ebe ,nil ;};func (_dgf *adobePKCS7Detached )getCertificate (_eae *_ad .PdfSignature )(*_e .Certificate ,error ){if _dgf ._eea !=nil {return _dgf ._eea ,nil ;
};_gca ,_dagb :=_eae .GetCerts ();if _dagb !=nil {return nil ,_dagb ;};return _gca [0],nil ;};

// InitSignature initialises the PdfSignature.
func (_cgff *adobeX509RSASHA1 )InitSignature (sig *_ad .PdfSignature )error {if _cgff ._fdc ==nil {return _a .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");
};if _cgff ._aef ==nil &&_cgff ._gbbb ==nil {return _a .New ("\u006d\u0075\u0073\u0074\u0020\u0070\u0072o\u0076\u0069\u0064e\u0020\u0065\u0069t\u0068\u0065r\u0020\u0061\u0020\u0070\u0072\u0069v\u0061te\u0020\u006b\u0065\u0079\u0020\u006f\u0072\u0020\u0061\u0020\u0073\u0069\u0067\u006e\u0069\u006e\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e");
};_bdb :=*_cgff ;sig .Handler =&_bdb ;sig .Filter =_fc .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");sig .SubFilter =_fc .MakeName ("\u0061d\u0062e\u002e\u0078\u0035\u0030\u0039.\u0072\u0073a\u005f\u0073\u0068\u0061\u0031");
sig .Cert =_fc .MakeString (string (_bdb ._fdc .Raw ));sig .Reference =nil ;_bdf ,_dcge :=_bdb .NewDigest (sig );if _dcge !=nil {return _dcge ;};_bdf .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));
return _bdb .sign (sig ,_bdf ,_cgff ._eefb );};

// NewDigest creates a new digest.
func (_bfd *adobePKCS7Detached )NewDigest (sig *_ad .PdfSignature )(_ad .Hasher ,error ){return _g .NewBuffer (nil ),nil ;};func (_eda *adobeX509RSASHA1 )getHashAlgorithm (_eedc *_ad .PdfSignature )(_cb .Hash ,error ){_dgcb ,_cgfc :=_eda .getCertificate (_eedc );
if _cgfc !=nil {if _eda ._cba !=0{return _eda ._cba ,nil ;};return _fdb ,_cgfc ;};if _eedc .Contents !=nil {_dbgc :=_eedc .Contents .Bytes ();var _bfbe []byte ;if _ ,_caf :=_bb .Unmarshal (_dbgc ,&_bfbe );_caf ==nil {_dce :=_ggd (_dgcb .PublicKey .(*_ba .PublicKey ),_bfbe );
if _dce > 0{return _dce ,nil ;};};};if _eda ._cba !=0{return _eda ._cba ,nil ;};return _fdb ,nil ;};

// NewEtsiPAdESLevelT creates a new Adobe.PPKLite ETSI.CAdES.detached Level T signature handler.
func NewEtsiPAdESLevelT (privateKey *_ba .PrivateKey ,certificate *_e .Certificate ,caCert *_e .Certificate ,certificateTimestampServerURL string )(_ad .SignatureHandler ,error ){return &etsiPAdES {_bbg :certificate ,_ea :privateKey ,_acb :caCert ,_eaf :certificateTimestampServerURL },nil ;
};func (_be *etsiPAdES )getCRLs (_bfe []*_e .Certificate )([][]byte ,error ){_dad :=make ([][]byte ,0,len (_bfe ));for _ ,_gbc :=range _bfe {for _ ,_ec :=range _gbc .CRLDistributionPoints {if _be .CertClient .IsCA (_gbc ){continue ;};_bdg ,_age :=_be .CRLClient .MakeRequest (_ec ,_gbc );
if _age !=nil {_eb .Log .Debug ("W\u0041\u0052\u004e\u003a\u0020\u0043R\u004c\u0020\u0072\u0065\u0071\u0075\u0065\u0073\u0074 \u0065\u0072\u0072o\u0072:\u0020\u0025\u0076",_age );continue ;};_dad =append (_dad ,_bdg );};};return _dad ,nil ;};type timestampInfo struct{Version int ;
Policy _bb .RawValue ;MessageImprint struct{HashAlgorithm _c .AlgorithmIdentifier ;HashedMessage []byte ;};SerialNumber _bb .RawValue ;GeneralizedTime _fae .Time ;};

// NewEtsiPAdESLevelLT creates a new Adobe.PPKLite ETSI.CAdES.detached Level LT signature handler.
func NewEtsiPAdESLevelLT (privateKey *_ba .PrivateKey ,certificate *_e .Certificate ,caCert *_e .Certificate ,certificateTimestampServerURL string ,appender *_ad .PdfAppender )(_ad .SignatureHandler ,error ){_ag :=appender .Reader .DSS ;if _ag ==nil {_ag =_ad .NewDSS ();
};if _bgec :=_ag .GenerateHashMaps ();_bgec !=nil {return nil ,_bgec ;};return &etsiPAdES {_bbg :certificate ,_ea :privateKey ,_acb :caCert ,_eaf :certificateTimestampServerURL ,CertClient :_ee .NewCertClient (),OCSPClient :_ee .NewOCSPClient (),CRLClient :_ee .NewCRLClient (),_faec :appender ,_adg :_ag },nil ;
};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_cegd *etsiPAdES )IsApplicable (sig *_ad .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0045\u0054\u0053\u0049.C\u0041\u0064\u0045\u0053\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064";
};func (_ed *etsiPAdES )buildCertChain (_eef ,_egb []*_e .Certificate )([]*_e .Certificate ,map[string ]*_e .Certificate ,error ){_gbd :=map[string ]*_e .Certificate {};for _ ,_ffd :=range _eef {_gbd [_ffd .Subject .CommonName ]=_ffd ;};_edc :=_eef ;for _ ,_aad :=range _egb {_dcc :=_aad .Subject .CommonName ;
if _ ,_fdf :=_gbd [_dcc ];_fdf {continue ;};_gbd [_dcc ]=_aad ;_edc =append (_edc ,_aad );};if len (_edc )==0{return nil ,nil ,_ad .ErrSignNoCertificates ;};var _ede error ;for _ece :=_edc [0];_ece !=nil &&!_ed .CertClient .IsCA (_ece );{var _cgb *_e .Certificate ;
_ ,_dcd :=_gbd [_ece .Issuer .CommonName ];if !_dcd {if _cgb ,_ede =_ed .CertClient .GetIssuer (_ece );_ede !=nil {_eb .Log .Debug ("W\u0041\u0052\u004e\u003a\u0020\u0043\u006f\u0075\u006cd\u0020\u006e\u006f\u0074\u0020\u0072\u0065tr\u0069\u0065\u0076\u0065 \u0063\u0065\u0072\u0074\u0069\u0066\u0069\u0063\u0061te\u0020\u0069s\u0073\u0075\u0065\u0072\u003a\u0020\u0025\u0076",_ede );
break ;};_gbd [_ece .Issuer .CommonName ]=_cgb ;_edc =append (_edc ,_cgb );}else {break ;};_ece =_cgb ;};return _edc ,_gbd ,nil ;};

// Sign adds a new reference to signature's references array.
func (_eeg *DocMDPHandler )Sign (sig *_ad .PdfSignature ,digest _ad .Hasher )error {return _eeg ._df .Sign (sig ,digest );};

// NewAdobeX509RSASHA1Custom creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler with a custom signing function. Both the
// certificate and the sign function can be nil for the signature validation.
// NOTE: the handler will do a mock Sign when initializing the signature in
// order to estimate the signature size. Use NewAdobeX509RSASHA1CustomWithOpts
// for configuring the handler to estimate the signature size.
func NewAdobeX509RSASHA1Custom (certificate *_e .Certificate ,signFunc SignFunc )(_ad .SignatureHandler ,error ){return &adobeX509RSASHA1 {_fdc :certificate ,_gbbb :signFunc },nil ;};

// Sign sets the Contents fields for the PdfSignature.
func (_cbgg *etsiPAdES )Sign (sig *_ad .PdfSignature ,digest _ad .Hasher )error {_gff ,_fdff :=digest .(*_g .Buffer );if !_fdff {return _da .Errorf ("c\u0061s\u0074\u0020\u0074\u006f\u0020\u0062\u0075\u0066f\u0065\u0072\u0020\u0066ai\u006c\u0073");};_ef ,_fbbe :=_bf .NewSignedData (_gff .Bytes ());
if _fbbe !=nil {return _fbbe ;};_ef .SetDigestAlgorithm (_bf .OIDDigestAlgorithmSHA256 );_cag :=_bf .SignerInfoConfig {};_ebg :=_cb .SHA256 .New ();_ebg .Write (_cbgg ._bbg .Raw );var _babf struct{Seq struct{Seq struct{Value []byte ;};};};_babf .Seq .Seq .Value =_ebg .Sum (nil );
var _aac []*_e .Certificate ;var _dg []*_e .Certificate ;if _cbgg ._acb !=nil {_dg =[]*_e .Certificate {_cbgg ._acb };};_aag :=RevocationInfoArchival {Crl :[]_bb .RawValue {},Ocsp :[]_bb .RawValue {},OtherRevInfo :[]_bb .RawValue {}};_faeb :=0;if _cbgg ._faec !=nil &&len (_cbgg ._eaf )> 0{_bgd ,_eag :=_cbgg .makeTimestampRequest (_cbgg ._eaf ,([]byte )(""));
if _eag !=nil {return _eag ;};_cef ,_eag :=_gf .Parse (_bgd .FullBytes );if _eag !=nil {return _eag ;};_aac =append (_aac ,_cef .Certificates ...);};if _cbgg ._faec !=nil {_bac ,_ga :=_cbgg .addDss ([]*_e .Certificate {_cbgg ._bbg },_dg ,&_aag );if _ga !=nil {return _ga ;
};_faeb +=_bac ;if len (_aac )> 0{_bac ,_ga =_cbgg .addDss (_aac ,nil ,&_aag );if _ga !=nil {return _ga ;};_faeb +=_bac ;};if !_cbgg ._bcb {_cbgg ._faec .SetDSS (_cbgg ._adg );};};_cag .ExtraSignedAttributes =append (_cag .ExtraSignedAttributes ,_bf .Attribute {Type :_bf .OIDAttributeSigningCertificateV2 ,Value :_babf },_bf .Attribute {Type :_bf .OIDAttributeAdobeRevocation ,Value :_aag });
if _eeb :=_ef .AddSignerChainPAdES (_cbgg ._bbg ,_cbgg ._ea ,_dg ,_cag );_eeb !=nil {return _eeb ;};_ef .Detach ();if len (_cbgg ._eaf )> 0{_aca :=_ef .GetSignedData ().SignerInfos [0].EncryptedDigest ;_de ,_cfa :=_cbgg .makeTimestampRequest (_cbgg ._eaf ,_aca );
if _cfa !=nil {return _cfa ;};_cfa =_ef .AddTimestampTokenToSigner (0,_de .FullBytes );if _cfa !=nil {return _cfa ;};};_eac ,_fbbe :=_ef .Finish ();if _fbbe !=nil {return _fbbe ;};_bafb :=make ([]byte ,len (_eac )+1024*2+_faeb );copy (_bafb ,_eac );sig .Contents =_fc .MakeHexString (string (_bafb ));
if !_cbgg ._bcb &&_cbgg ._adg !=nil {_ebg =_cb .SHA1 .New ();_ebg .Write (_bafb );_bbdd :=_b .ToUpper (_fd .EncodeToString (_ebg .Sum (nil )));if _bbdd !=""{_cbgg ._adg .VRI [_bbdd ]=&_ad .VRI {Cert :_cbgg ._adg .Certs ,OCSP :_cbgg ._adg .OCSPs ,CRL :_cbgg ._adg .CRLs };
};_cbgg ._faec .SetDSS (_cbgg ._adg );};return nil ;};type docTimeStamp struct{_gef string ;_edb _cb .Hash ;_ecf int ;_bbe *_ee .TimestampClient ;};func (_aacg *docTimeStamp )getCertificate (_dgb *_ad .PdfSignature )(*_e .Certificate ,error ){_eebe ,_gege :=_dgb .GetCerts ();
if _gege !=nil {return nil ,_gege ;};return _eebe [0],nil ;};func (_bcbg *etsiPAdES )makeTimestampRequest (_cd string ,_bba []byte )(_bb .RawValue ,error ){_acg :=_cb .SHA512 .New ();_acg .Write (_bba );_gfg :=_acg .Sum (nil );_gb :=_gf .Request {HashAlgorithm :_cb .SHA512 ,HashedMessage :_gfg ,Certificates :true ,Extensions :nil ,ExtraExtensions :nil };
_ega :=_ee .NewTimestampClient ();_bbf ,_abb :=_ega .GetEncodedToken (_cd ,&_gb );if _abb !=nil {return _bb .NullRawValue ,_abb ;};return _bb .RawValue {FullBytes :_bbf },nil ;};

// Validate validates PdfSignature.
func (_cad *etsiPAdES )Validate (sig *_ad .PdfSignature ,digest _ad .Hasher )(_ad .SignatureValidationResult ,error ){_gcfc :=sig .Contents .Bytes ();_gad ,_cfc :=_bf .Parse (_gcfc );if _cfc !=nil {return _ad .SignatureValidationResult {},_cfc ;};_agfa ,_geg :=digest .(*_g .Buffer );
if !_geg {return _ad .SignatureValidationResult {},_da .Errorf ("c\u0061s\u0074\u0020\u0074\u006f\u0020\u0062\u0075\u0066f\u0065\u0072\u0020\u0066ai\u006c\u0073");};_gad .Content =_agfa .Bytes ();if _cfc =_gad .Verify ();_cfc !=nil {return _ad .SignatureValidationResult {},_cfc ;
};_aff :=false ;_cbf :=false ;var _fgb _fae .Time ;for _ ,_babg :=range _gad .Signers {_fddg :=_babg .EncryptedDigest ;var _fec RevocationInfoArchival ;_cfc =_gad .UnmarshalSignedAttribute (_bf .OIDAttributeAdobeRevocation ,&_fec );if _cfc ==nil {if len (_fec .Crl )> 0{_cbf =true ;
};if len (_fec .Ocsp )> 0{_aff =true ;};};for _ ,_baag :=range _babg .UnauthenticatedAttributes {if _baag .Type .Equal (_bf .OIDAttributeTimeStampToken ){_cfge ,_bff :=_gf .Parse (_baag .Value .Bytes );if _bff !=nil {return _ad .SignatureValidationResult {},_bff ;
};_fgb =_cfge .Time ;_agg :=_cfge .HashAlgorithm .New ();_agg .Write (_fddg );if !_g .Equal (_agg .Sum (nil ),_cfge .HashedMessage ){return _ad .SignatureValidationResult {},_da .Errorf ("\u0048\u0061\u0073\u0068\u0020i\u006e\u0020\u0074\u0069\u006d\u0065\u0073\u0074\u0061\u006d\u0070\u0020\u0069s\u0020\u0064\u0069\u0066\u0066\u0065\u0072\u0065\u006e\u0074\u0020\u0066\u0072\u006f\u006d\u0020\u0070\u006b\u0063\u0073\u0037");
};break ;};};};_acd :=_ad .SignatureValidationResult {IsSigned :true ,IsVerified :true ,IsCrlFound :_cbf ,IsOcspFound :_aff ,GeneralizedTime :_fgb };return _acd ,nil ;};

// SignFunc represents a custom signing function. The function should return
// the computed signature.
type SignFunc func (_eafe *_ad .PdfSignature ,_fdg _ad .Hasher )([]byte ,error );

// RevocationInfoArchival is OIDAttributeAdobeRevocation attribute.
type RevocationInfoArchival struct{Crl []_bb .RawValue `asn1:"explicit,tag:0,optional"`;Ocsp []_bb .RawValue `asn1:"explicit,tag:1,optional"`;OtherRevInfo []_bb .RawValue `asn1:"explicit,tag:2,optional"`;};

// NewEtsiPAdESLevelB creates a new Adobe.PPKLite ETSI.CAdES.detached Level B signature handler.
func NewEtsiPAdESLevelB (privateKey *_ba .PrivateKey ,certificate *_e .Certificate ,caCert *_e .Certificate )(_ad .SignatureHandler ,error ){return &etsiPAdES {_bbg :certificate ,_ea :privateKey ,_acb :caCert },nil ;};func (_cfg *etsiPAdES )getOCSPs (_bbd []*_e .Certificate ,_ca map[string ]*_e .Certificate )([][]byte ,error ){_bfb :=make ([][]byte ,0,len (_bbd ));
for _ ,_afa :=range _bbd {for _ ,_eed :=range _afa .OCSPServer {if _cfg .CertClient .IsCA (_afa ){continue ;};_bdd ,_fad :=_ca [_afa .Issuer .CommonName ];if !_fad {_eb .Log .Debug ("\u0057\u0041\u0052\u004e:\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067 \u004f\u0043\u0053\u0050\u0020\u0072\u0065\u0071\u0075\u0065\u0073\u0074\u003a\u0020\u0069\u0073\u0073\u0075e\u0072\u0020\u0063\u0065\u0072t\u0069\u0066\u0069\u0063\u0061\u0074\u0065\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");
continue ;};_ ,_ceg ,_cca :=_cfg .OCSPClient .MakeRequest (_eed ,_afa ,_bdd );if _cca !=nil {_eb .Log .Debug ("\u0057\u0041\u0052\u004e:\u0020\u004f\u0043\u0053\u0050\u0020\u0072\u0065\u0071\u0075e\u0073t\u0020\u0065\u0072\u0072\u006f\u0072\u003a \u0025\u0076",_cca );
continue ;};_bfb =append (_bfb ,_ceg );};};return _bfb ,nil ;};func (_dcg *etsiPAdES )addDss (_agf ,_dgc []*_e .Certificate ,_gcb *RevocationInfoArchival )(int ,error ){_ebc ,_bbc ,_cea :=_dcg .buildCertChain (_agf ,_dgc );if _cea !=nil {return 0,_cea ;
};_eced ,_cea :=_dcg .getCerts (_ebc );if _cea !=nil {return 0,_cea ;};var _eedd ,_acae [][]byte ;if _dcg .OCSPClient !=nil {_eedd ,_cea =_dcg .getOCSPs (_ebc ,_bbc );if _cea !=nil {return 0,_cea ;};};if _dcg .CRLClient !=nil {_acae ,_cea =_dcg .getCRLs (_ebc );
if _cea !=nil {return 0,_cea ;};};if !_dcg ._bcb {_ ,_cea =_dcg ._adg .AddCerts (_eced );if _cea !=nil {return 0,_cea ;};_ ,_cea =_dcg ._adg .AddOCSPs (_eedd );if _cea !=nil {return 0,_cea ;};_ ,_cea =_dcg ._adg .AddCRLs (_acae );if _cea !=nil {return 0,_cea ;
};};_ebgb :=0;for _ ,_cac :=range _acae {_ebgb +=len (_cac );_gcb .Crl =append (_gcb .Crl ,_bb .RawValue {FullBytes :_cac });};for _ ,_bag :=range _eedd {_ebgb +=len (_bag );_gcb .Ocsp =append (_gcb .Ocsp ,_bb .RawValue {FullBytes :_bag });};return _ebgb ,nil ;
};

// NewDigest creates a new digest.
func (_gfeg *docTimeStamp )NewDigest (sig *_ad .PdfSignature )(_ad .Hasher ,error ){return _g .NewBuffer (nil ),nil ;};

// AdobeX509RSASHA1Opts defines options for configuring the adbe.x509.rsa_sha1
// signature handler.
type AdobeX509RSASHA1Opts struct{

// EstimateSize specifies whether the size of the signature contents
// should be estimated based on the modulus size of the public key
// extracted from the signing certificate. If set to false, a mock Sign
// call is made in order to estimate the size of the signature contents.
EstimateSize bool ;

// Algorithm specifies the algorithm used for performing signing.
// If not specified, defaults to SHA1.
Algorithm _cb .Hash ;};func (_bec *adobeX509RSASHA1 )getCertificate (_aace *_ad .PdfSignature )(*_e .Certificate ,error ){if _bec ._fdc !=nil {return _bec ._fdc ,nil ;};_bbb ,_bgf :=_aace .GetCerts ();if _bgf !=nil {return nil ,_bgf ;};return _bbb [0],nil ;
};

// NewDigest creates a new digest.
func (_efg *adobeX509RSASHA1 )NewDigest (sig *_ad .PdfSignature )(_ad .Hasher ,error ){if _gbcg ,_edcc :=_efg .getHashAlgorithm (sig );_gbcg !=0&&_edcc ==nil {return _gbcg .New (),nil ;};return _fdb .New (),nil ;};

// NewDocTimeStamp creates a new DocTimeStamp signature handler.
// Both the timestamp server URL and the hash algorithm can be empty for the
// signature validation.
// The following hash algorithms are supported:
// crypto.SHA1, crypto.SHA256, crypto.SHA384, crypto.SHA512.
// NOTE: the handler will do a mock Sign when initializing the signature
// in order to estimate the signature size. Use NewDocTimeStampWithOpts
// for providing the signature size.
func NewDocTimeStamp (timestampServerURL string ,hashAlgorithm _cb .Hash )(_ad .SignatureHandler ,error ){return &docTimeStamp {_gef :timestampServerURL ,_edb :hashAlgorithm },nil ;};const _fdb =_cb .SHA1 ;

// Validate implementation of the SignatureHandler interface
// This check is impossible without checking the document's content.
// Please, use ValidateWithOpts with the PdfParser.
func (_ac *DocMDPHandler )Validate (sig *_ad .PdfSignature ,digest _ad .Hasher )(_ad .SignatureValidationResult ,error ){return _ad .SignatureValidationResult {},_a .New ("i\u006d\u0070\u006f\u0073\u0073\u0069b\u006c\u0065\u0020\u0076\u0061\u006ci\u0064\u0061\u0074\u0069\u006f\u006e\u0020w\u0069\u0074\u0068\u006f\u0075\u0074\u0020\u0070\u0061\u0072s\u0065");
};

// NewDocMDPHandler returns the new DocMDP handler with the specific DocMDP restriction level.
func NewDocMDPHandler (handler _ad .SignatureHandler ,permission _eg .DocMDPPermission )(_ad .SignatureHandler ,error ){return &DocMDPHandler {_df :handler ,Permission :permission },nil ;};func _bgc (_afab []byte ,_bbcd int )(_bfa []byte ){_edcf :=len (_afab );
if _edcf > _bbcd {_edcf =_bbcd ;};_bfa =make ([]byte ,_bbcd );copy (_bfa [len (_bfa )-_edcf :],_afab );return ;};type adobeX509RSASHA1 struct{_aef *_ba .PrivateKey ;_fdc *_e .Certificate ;_gbbb SignFunc ;_eefb bool ;_cba _cb .Hash ;};type adobePKCS7Detached struct{_cdb *_ba .PrivateKey ;
_eea *_e .Certificate ;_edd bool ;_ffde int ;};

// Sign sets the Contents fields.
func (_cbc *adobePKCS7Detached )Sign (sig *_ad .PdfSignature ,digest _ad .Hasher )error {if _cbc ._edd {_dbg :=_cbc ._ffde ;if _dbg <=0{_dbg =8192;};sig .Contents =_fc .MakeHexString (string (make ([]byte ,_dbg )));return nil ;};_dade ,_cbe :=digest .(*_g .Buffer );
if !_cbe {return _da .Errorf ("c\u0061s\u0074\u0020\u0074\u006f\u0020\u0062\u0075\u0066f\u0065\u0072\u0020\u0066ai\u006c\u0073");};_egg ,_egc :=_bf .NewSignedData (_dade .Bytes ());if _egc !=nil {return _egc ;};if _gba :=_egg .AddSigner (_cbc ._eea ,_cbc ._cdb ,_bf .SignerInfoConfig {});
_gba !=nil {return _gba ;};_egg .Detach ();_gedg ,_egc :=_egg .Finish ();if _egc !=nil {return _egc ;};_gfe :=make ([]byte ,8192);copy (_gfe ,_gedg );sig .Contents =_fc .MakeHexString (string (_gfe ));return nil ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_eaeg *adobeX509RSASHA1 )IsApplicable (sig *_ad .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0061d\u0062e\u002e\u0078\u0035\u0030\u0039.\u0072\u0073a\u005f\u0073\u0068\u0061\u0031";
};

// Sign sets the Contents fields for the PdfSignature.
func (_efcc *docTimeStamp )Sign (sig *_ad .PdfSignature ,digest _ad .Hasher )error {_cacf ,_afec :=_ee .NewTimestampRequest (digest .(*_g .Buffer ),&_gf .RequestOptions {Hash :_efcc ._edb ,Certificates :true });if _afec !=nil {return _afec ;};_deg :=_efcc ._bbe ;
if _deg ==nil {_deg =_ee .NewTimestampClient ();};_gbce ,_afec :=_deg .GetEncodedToken (_efcc ._gef ,_cacf );if _afec !=nil {return _afec ;};_gdae :=len (_gbce );if _efcc ._ecf > 0&&_gdae > _efcc ._ecf {return _ad .ErrSignNotEnoughSpace ;};if _gdae > 0{_efcc ._ecf =_gdae +128;
};if sig .Contents !=nil {_bcc :=sig .Contents .Bytes ();copy (_bcc ,_gbce );_gbce =_bcc ;};sig .Contents =_fc .MakeHexString (string (_gbce ));return nil ;};func (_fadg *adobeX509RSASHA1 )sign (_ddg *_ad .PdfSignature ,_ead _ad .Hasher ,_dgg bool )error {if !_dgg {return _fadg .Sign (_ddg ,_ead );
};_gcc ,_ebf :=_fadg ._fdc .PublicKey .(*_ba .PublicKey );if !_ebf {return _da .Errorf ("i\u006e\u0076\u0061\u006c\u0069\u0064 \u0070\u0075\u0062\u006c\u0069\u0063\u0020\u006b\u0065y\u0020\u0074\u0079p\u0065:\u0020\u0025\u0054",_gcc );};_edee ,_dceb :=_bb .Marshal (make ([]byte ,_gcc .Size ()));
if _dceb !=nil {return _dceb ;};_ddg .Contents =_fc .MakeHexString (string (_edee ));return nil ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature
func (_cdbd *adobePKCS7Detached )IsApplicable (sig *_ad .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0061\u0064\u0062\u0065.p\u006b\u0063\u0073\u0037\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064";
};

// NewAdobePKCS7Detached creates a new Adobe.PPKMS/Adobe.PPKLite adbe.pkcs7.detached signature handler.
// Both parameters may be nil for the signature validation.
func NewAdobePKCS7Detached (privateKey *_ba .PrivateKey ,certificate *_e .Certificate )(_ad .SignatureHandler ,error ){return &adobePKCS7Detached {_eea :certificate ,_cdb :privateKey },nil ;};func (_afb *etsiPAdES )getCerts (_gcd []*_e .Certificate )([][]byte ,error ){_cae :=make ([][]byte ,0,len (_gcd ));
for _ ,_afe :=range _gcd {_cae =append (_cae ,_afe .Raw );};return _cae ,nil ;};

// Validate validates PdfSignature.
func (_gda *adobeX509RSASHA1 )Validate (sig *_ad .PdfSignature ,digest _ad .Hasher )(_ad .SignatureValidationResult ,error ){_bdge ,_bgda :=_gda .getCertificate (sig );if _bgda !=nil {return _ad .SignatureValidationResult {},_bgda ;};_cff :=sig .Contents .Bytes ();
var _cffa []byte ;if _ ,_bcg :=_bb .Unmarshal (_cff ,&_cffa );_bcg !=nil {return _ad .SignatureValidationResult {},_bcg ;};_cfd ,_fca :=digest .(_fa .Hash );if !_fca {return _ad .SignatureValidationResult {},_a .New ("\u0068a\u0073h\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_caga ,_ :=_gda .getHashAlgorithm (sig );if _caga ==0{_caga =_fdb ;};if _beb :=_ba .VerifyPKCS1v15 (_bdge .PublicKey .(*_ba .PublicKey ),_caga ,_cfd .Sum (nil ),_cffa );_beb !=nil {return _ad .SignatureValidationResult {},_beb ;};return _ad .SignatureValidationResult {IsSigned :true ,IsVerified :true },nil ;
};

// NewDigest creates a new digest.
func (_cfad *etsiPAdES )NewDigest (_ *_ad .PdfSignature )(_ad .Hasher ,error ){return _g .NewBuffer (nil ),nil ;};

// InitSignature initialization of the DocMDP signature.
func (_gdc *DocMDPHandler )InitSignature (sig *_ad .PdfSignature )error {_bab :=_gdc ._df .InitSignature (sig );if _bab !=nil {return _bab ;};sig .Handler =_gdc ;if sig .Reference ==nil {sig .Reference =_fc .MakeArray ();};sig .Reference .Append (_ad .NewPdfSignatureReferenceDocMDP (_ad .NewPdfTransformParamsDocMDP (_gdc .Permission )).ToPdfObject ());
return nil ;};