//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package sighandler implements digital signature handlers for PDF signature validation and signing.
package sighandler ;import (_gd "bytes";_cb "crypto";_dd "crypto/rand";_f "crypto/rsa";_dce "crypto/x509";_gc "crypto/x509/pkix";_dc "encoding/asn1";_d "errors";_c "fmt";_gg "github.com/unidoc/pkcs7";_bb "github.com/unidoc/timestamp";_bae "github.com/unidoc/unipdf/v3/core";
_bg "github.com/unidoc/unipdf/v3/model";_gca "github.com/unidoc/unipdf/v3/model/mdp";_ae "github.com/unidoc/unipdf/v3/model/sigutil";_g "hash";_ba "math/big";_b "time";);

// DocTimeStampOpts defines options for configuring the timestamp handler.
type DocTimeStampOpts struct{

// SignatureSize is the estimated size of the signature contents in bytes.
// If not provided, a default signature size of 4192 is used.
// The signing process will report the model.ErrSignNotEnoughSpace error
// if the estimated signature size is smaller than the actual size of the
// signature.
SignatureSize int ;};

// InitSignature initialises the PdfSignature.
func (_afc *adobePKCS7Detached )InitSignature (sig *_bg .PdfSignature )error {if !_afc ._gcc {if _afc ._df ==nil {return _d .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");
};if _afc ._fe ==nil {return _d .New ("\u0070\u0072\u0069\u0076\u0061\u0074\u0065\u004b\u0065\u0079\u0020m\u0075\u0073\u0074\u0020\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c");};};_fba :=*_afc ;sig .Handler =&_fba ;sig .Filter =_bae .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");
sig .SubFilter =_bae .MakeName ("\u0061\u0064\u0062\u0065.p\u006b\u0063\u0073\u0037\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064");sig .Reference =nil ;_ce ,_bgd :=_fba .NewDigest (sig );if _bgd !=nil {return _bgd ;};_ce .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));
return _fba .Sign (sig ,_ce );};func (_cda *adobeX509RSASHA1 )getCertificate (_dcb *_bg .PdfSignature )(*_dce .Certificate ,error ){if _cda ._bgf !=nil {return _cda ._bgf ,nil ;};_fge ,_acg :=_dcb .GetCerts ();if _acg !=nil {return nil ,_acg ;};return _fge [0],nil ;
};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_ad *docTimeStamp )IsApplicable (sig *_bg .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0045\u0054\u0053I\u002e\u0052\u0046\u0043\u0033\u0031\u0036\u0031";
};

// AdobeX509RSASHA1Opts defines options for configuring the adbe.x509.rsa_sha1
// signature handler.
type AdobeX509RSASHA1Opts struct{

// EstimateSize specifies whether the size of the signature contents
// should be estimated based on the modulus size of the public key
// extracted from the signing certificate. If set to false, a mock Sign
// call is made in order to estimate the size of the signature contents.
EstimateSize bool ;

// Algorithm specifies the algorithm used for performing signing.
// If not specified, defaults to SHA1.
Algorithm _cb .Hash ;};

// NewAdobeX509RSASHA1Custom creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler with a custom signing function. Both the
// certificate and the sign function can be nil for the signature validation.
// NOTE: the handler will do a mock Sign when initializing the signature in
// order to estimate the signature size. Use NewAdobeX509RSASHA1CustomWithOpts
// for configuring the handler to estimate the signature size.
func NewAdobeX509RSASHA1Custom (certificate *_dce .Certificate ,signFunc SignFunc )(_bg .SignatureHandler ,error ){return &adobeX509RSASHA1 {_bgf :certificate ,_beb :signFunc },nil ;};

// InitSignature initialises the PdfSignature.
func (_dgc *adobeX509RSASHA1 )InitSignature (sig *_bg .PdfSignature )error {if _dgc ._bgf ==nil {return _d .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");
};if _dgc ._fdc ==nil &&_dgc ._beb ==nil {return _d .New ("\u006d\u0075\u0073\u0074\u0020\u0070\u0072o\u0076\u0069\u0064e\u0020\u0065\u0069t\u0068\u0065r\u0020\u0061\u0020\u0070\u0072\u0069v\u0061te\u0020\u006b\u0065\u0079\u0020\u006f\u0072\u0020\u0061\u0020\u0073\u0069\u0067\u006e\u0069\u006e\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e");
};_decc :=*_dgc ;sig .Handler =&_decc ;sig .Filter =_bae .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");sig .SubFilter =_bae .MakeName ("\u0061d\u0062e\u002e\u0078\u0035\u0030\u0039.\u0072\u0073a\u005f\u0073\u0068\u0061\u0031");
sig .Cert =_bae .MakeString (string (_decc ._bgf .Raw ));sig .Reference =nil ;_gcca ,_fbd :=_decc .NewDigest (sig );if _fbd !=nil {return _fbd ;};_gcca .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));
return _decc .sign (sig ,_gcca ,_dgc ._bgc );};func _cca (_fac []byte ,_bcg int )(_bdg []byte ){_edf :=len (_fac );if _edf > _bcg {_edf =_bcg ;};_bdg =make ([]byte ,_bcg );copy (_bdg [len (_bdg )-_edf :],_fac );return ;};

// NewAdobePKCS7Detached creates a new Adobe.PPKMS/Adobe.PPKLite adbe.pkcs7.detached signature handler.
// Both parameters may be nil for the signature validation.
func NewAdobePKCS7Detached (privateKey *_f .PrivateKey ,certificate *_dce .Certificate )(_bg .SignatureHandler ,error ){return &adobePKCS7Detached {_df :certificate ,_fe :privateKey },nil ;};

// Sign adds a new reference to signature's references array.
func (_fdd *DocMDPHandler )Sign (sig *_bg .PdfSignature ,digest _bg .Hasher )error {return _fdd ._fb .Sign (sig ,digest );};type adobePKCS7Detached struct{_fe *_f .PrivateKey ;_df *_dce .Certificate ;_gcc bool ;_cga int ;};type docTimeStamp struct{_edc string ;
_fea _cb .Hash ;_afcf int ;};

// Validate implementation of the SignatureHandler interface
// This check is impossible without checking the document's content.
// Please, use ValidateWithOpts with the PdfParser.
func (_af *DocMDPHandler )Validate (sig *_bg .PdfSignature ,digest _bg .Hasher )(_bg .SignatureValidationResult ,error ){return _bg .SignatureValidationResult {},_d .New ("i\u006d\u0070\u006f\u0073\u0073\u0069b\u006c\u0065\u0020\u0076\u0061\u006ci\u0064\u0061\u0074\u0069\u006f\u006e\u0020w\u0069\u0074\u0068\u006f\u0075\u0074\u0020\u0070\u0061\u0072s\u0065");
};

// NewAdobeX509RSASHA1CustomWithOpts creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler with a custom signing function. The
// handler is configured based on the provided options. If no options are
// provided, default options will be used. Both the certificate and the sign
// function can be nil for the signature validation.
func NewAdobeX509RSASHA1CustomWithOpts (certificate *_dce .Certificate ,signFunc SignFunc ,opts *AdobeX509RSASHA1Opts )(_bg .SignatureHandler ,error ){if opts ==nil {opts =&AdobeX509RSASHA1Opts {};};return &adobeX509RSASHA1 {_bgf :certificate ,_beb :signFunc ,_bgc :opts .EstimateSize ,_cc :opts .Algorithm },nil ;
};

// NewDocMDPHandler returns the new DocMDP handler with the specific DocMDP restriction level.
func NewDocMDPHandler (handler _bg .SignatureHandler ,permission _gca .DocMDPPermission )(_bg .SignatureHandler ,error ){return &DocMDPHandler {_fb :handler ,Permission :permission },nil ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_cg *DocMDPHandler )IsApplicable (sig *_bg .PdfSignature )bool {_ac :=false ;for _ ,_ca :=range sig .Reference .Elements (){if _ge ,_gea :=_bae .GetDict (_ca );_gea {if _cad ,_db :=_bae .GetNameVal (_ge .Get ("\u0054r\u0061n\u0073\u0066\u006f\u0072\u006d\u004d\u0065\u0074\u0068\u006f\u0064"));
_db {if _cad !="\u0044\u006f\u0063\u004d\u0044\u0050"{return false ;};if _e ,_ea :=_bae .GetDict (_ge .Get ("\u0054r\u0061n\u0073\u0066\u006f\u0072\u006d\u0050\u0061\u0072\u0061\u006d\u0073"));_ea {_ ,_cd :=_bae .GetNumberAsInt64 (_e .Get ("\u0050"));if _cd !=nil {return false ;
};_ac =true ;break ;};};};};return _ac &&_cg ._fb .IsApplicable (sig );};type adobeX509RSASHA1 struct{_fdc *_f .PrivateKey ;_bgf *_dce .Certificate ;_beb SignFunc ;_bgc bool ;_cc _cb .Hash ;};func _gag (_gfd *_f .PublicKey ,_ffg []byte )_cb .Hash {_dceb :=_gfd .Size ();
if _dceb !=len (_ffg ){return 0;};_ggd :=func (_daggf *_ba .Int ,_daff *_f .PublicKey ,_edg *_ba .Int )*_ba .Int {_efc :=_ba .NewInt (int64 (_daff .E ));_daggf .Exp (_edg ,_efc ,_daff .N );return _daggf ;};_ece :=new (_ba .Int ).SetBytes (_ffg );_bcd :=_ggd (new (_ba .Int ),_gfd ,_ece );
_fae :=_cca (_bcd .Bytes (),_dceb );if _fae [0]!=0||_fae [1]!=1{return 0;};_fga :=[]struct{Hash _cb .Hash ;Prefix []byte ;}{{Hash :_cb .SHA1 ,Prefix :[]byte {0x30,0x21,0x30,0x09,0x06,0x05,0x2b,0x0e,0x03,0x02,0x1a,0x05,0x00,0x04,0x14}},{Hash :_cb .SHA256 ,Prefix :[]byte {0x30,0x31,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x01,0x05,0x00,0x04,0x20}},{Hash :_cb .SHA384 ,Prefix :[]byte {0x30,0x41,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x02,0x05,0x00,0x04,0x30}},{Hash :_cb .SHA512 ,Prefix :[]byte {0x30,0x51,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x03,0x05,0x00,0x04,0x40}},{Hash :_cb .RIPEMD160 ,Prefix :[]byte {0x30,0x20,0x30,0x08,0x06,0x06,0x28,0xcf,0x06,0x03,0x00,0x31,0x04,0x14}}};
for _ ,_dge :=range _fga {_bf :=_dge .Hash .Size ();_ddf :=len (_dge .Prefix )+_bf ;if _gd .Equal (_fae [_dceb -_ddf :_dceb -_bf ],_dge .Prefix ){return _dge .Hash ;};};return 0;};

// Validate validates PdfSignature.
func (_ccf *docTimeStamp )Validate (sig *_bg .PdfSignature ,digest _bg .Hasher )(_bg .SignatureValidationResult ,error ){_eaa :=sig .Contents .Bytes ();_ceea ,_dde :=_gg .Parse (_eaa );if _dde !=nil {return _bg .SignatureValidationResult {},_dde ;};if _dde =_ceea .Verify ();
_dde !=nil {return _bg .SignatureValidationResult {},_dde ;};var _fce timestampInfo ;_ ,_dde =_dc .Unmarshal (_ceea .Content ,&_fce );if _dde !=nil {return _bg .SignatureValidationResult {},_dde ;};_cbdg ,_dde :=_bef (_fce .MessageImprint .HashAlgorithm .Algorithm );
if _dde !=nil {return _bg .SignatureValidationResult {},_dde ;};_ffb :=_cbdg .New ();_bcf :=digest .(*_gd .Buffer );_ffb .Write (_bcf .Bytes ());_bbae :=_ffb .Sum (nil );_daa :=_bg .SignatureValidationResult {IsSigned :true ,IsVerified :_gd .Equal (_bbae ,_fce .MessageImprint .HashedMessage ),GeneralizedTime :_fce .GeneralizedTime };
return _daa ,nil ;};

// NewDocTimeStamp creates a new DocTimeStamp signature handler.
// Both the timestamp server URL and the hash algorithm can be empty for the
// signature validation.
// The following hash algorithms are supported:
// crypto.SHA1, crypto.SHA256, crypto.SHA384, crypto.SHA512.
// NOTE: the handler will do a mock Sign when initializing the signature
// in order to estimate the signature size. Use NewDocTimeStampWithOpts
// for providing the signature size.
func NewDocTimeStamp (timestampServerURL string ,hashAlgorithm _cb .Hash )(_bg .SignatureHandler ,error ){return &docTimeStamp {_edc :timestampServerURL ,_fea :hashAlgorithm },nil ;};func (_dfe *docTimeStamp )getCertificate (_bbab *_bg .PdfSignature )(*_dce .Certificate ,error ){_gaf ,_ebc :=_bbab .GetCerts ();
if _ebc !=nil {return nil ,_ebc ;};return _gaf [0],nil ;};

// SignFunc represents a custom signing function. The function should return
// the computed signature.
type SignFunc func (_fff *_bg .PdfSignature ,_gec _bg .Hasher )([]byte ,error );

// NewAdobeX509RSASHA1 creates a new Adobe.PPKMS/Adobe.PPKLite
// adbe.x509.rsa_sha1 signature handler. Both the private key and the
// certificate can be nil for the signature validation.
func NewAdobeX509RSASHA1 (privateKey *_f .PrivateKey ,certificate *_dce .Certificate )(_bg .SignatureHandler ,error ){return &adobeX509RSASHA1 {_bgf :certificate ,_fdc :privateKey },nil ;};

// Sign sets the Contents fields for the PdfSignature.
func (_dcg *adobeX509RSASHA1 )Sign (sig *_bg .PdfSignature ,digest _bg .Hasher )error {var _fc []byte ;var _eg error ;if _dcg ._beb !=nil {_fc ,_eg =_dcg ._beb (sig ,digest );if _eg !=nil {return _eg ;};}else {_ceb ,_fbff :=digest .(_g .Hash );if !_fbff {return _d .New ("\u0068a\u0073h\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_gdg :=_dec ;if _dcg ._cc !=0{_gdg =_dcg ._cc ;};_fc ,_eg =_f .SignPKCS1v15 (_dd .Reader ,_dcg ._fdc ,_gdg ,_ceb .Sum (nil ));if _eg !=nil {return _eg ;};};_fc ,_eg =_dc .Marshal (_fc );if _eg !=nil {return _eg ;};sig .Contents =_bae .MakeHexString (string (_fc ));
return nil ;};type timestampInfo struct{Version int ;Policy _dc .RawValue ;MessageImprint struct{HashAlgorithm _gc .AlgorithmIdentifier ;HashedMessage []byte ;};SerialNumber _dc .RawValue ;GeneralizedTime _b .Time ;};const _dec =_cb .SHA1 ;

// InitSignature initialises the PdfSignature.
func (_gead *docTimeStamp )InitSignature (sig *_bg .PdfSignature )error {_ab :=*_gead ;sig .Handler =&_ab ;sig .Filter =_bae .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");sig .SubFilter =_bae .MakeName ("\u0045\u0054\u0053I\u002e\u0052\u0046\u0043\u0033\u0031\u0036\u0031");
sig .Reference =nil ;if _gead ._afcf > 0{sig .Contents =_bae .MakeHexString (string (make ([]byte ,_gead ._afcf )));}else {_gbc ,_abd :=_gead .NewDigest (sig );if _abd !=nil {return _abd ;};_gbc .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));
if _abd =_ab .Sign (sig ,_gbc );_abd !=nil {return _abd ;};_gead ._afcf =_ab ._afcf ;};return nil ;};

// ValidateWithOpts validates a PDF signature by checking PdfReader or PdfParser by the DiffPolicy
// params describes parameters for the DocMDP checks.
func (_ag *DocMDPHandler )ValidateWithOpts (sig *_bg .PdfSignature ,digest _bg .Hasher ,params _bg .SignatureHandlerDocMDPParams )(_bg .SignatureValidationResult ,error ){_cabb ,_da :=_ag ._fb .Validate (sig ,digest );if _da !=nil {return _cabb ,_da ;};
_aga :=params .Parser ;if _aga ==nil {return _bg .SignatureValidationResult {},_d .New ("p\u0061r\u0073\u0065\u0072\u0020\u0063\u0061\u006e\u0027t\u0020\u0062\u0065\u0020nu\u006c\u006c");};if !_cabb .IsVerified {return _cabb ,nil ;};_dbb :=params .DiffPolicy ;
if _dbb ==nil {_dbb =_gca .NewDefaultDiffPolicy ();};for _bd :=0;_bd <=_aga .GetRevisionNumber ();_bd ++{_ee ,_fbf :=_aga .GetRevision (_bd );if _fbf !=nil {return _bg .SignatureValidationResult {},_fbf ;};_gda :=_ee .GetTrailer ();if _gda ==nil {return _bg .SignatureValidationResult {},_d .New ("\u0075\u006e\u0064\u0065f\u0069\u006e\u0065\u0064\u0020\u0074\u0068\u0065\u0020\u0074r\u0061i\u006c\u0065\u0072\u0020\u006f\u0062\u006ae\u0063\u0074");
};_ddb ,_gdd :=_bae .GetDict (_gda .Get ("\u0052\u006f\u006f\u0074"));if !_gdd {return _bg .SignatureValidationResult {},_d .New ("\u0075n\u0064\u0065\u0066\u0069n\u0065\u0064\u0020\u0074\u0068e\u0020r\u006fo\u0074\u0020\u006f\u0062\u006a\u0065\u0063t");
};_fd ,_gdd :=_bae .GetDict (_ddb .Get ("\u0041\u0063\u0072\u006f\u0046\u006f\u0072\u006d"));if !_gdd {continue ;};_cf ,_gdd :=_bae .GetArray (_fd .Get ("\u0046\u0069\u0065\u006c\u0064\u0073"));if !_gdd {continue ;};for _ ,_de :=range _cf .Elements (){_dag ,_gcaf :=_bae .GetDict (_de );
if !_gcaf {continue ;};_dee ,_gcaf :=_bae .GetDict (_dag .Get ("\u0056"));if !_gcaf {continue ;};if _bae .EqualObjects (_dee .Get ("\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"),sig .Contents ){_cabb .DiffResults ,_fbf =_dbb .ReviewFile (_ee ,_aga ,&_gca .MDPParameters {DocMDPLevel :_ag .Permission });
if _fbf !=nil {return _bg .SignatureValidationResult {},_fbf ;};_cabb .IsVerified =_cabb .DiffResults .IsPermitted ();return _cabb ,nil ;};};};return _bg .SignatureValidationResult {},_d .New ("\u0064\u006f\u006e\u0027\u0074\u0020\u0066o\u0075\u006e\u0064 \u0074\u0068\u0069\u0073 \u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0069\u006e\u0020\u0074\u0068\u0065\u0020\u0072\u0065\u0076\u0069\u0073\u0069\u006f\u006e\u0073");
};

// Sign sets the Contents fields for the PdfSignature.
func (_cdb *docTimeStamp )Sign (sig *_bg .PdfSignature ,digest _bg .Hasher )error {_aee ,_eecc :=_ae .NewTimestampRequest (digest .(*_gd .Buffer ),&_bb .RequestOptions {Hash :_cdb ._fea ,Certificates :true });if _eecc !=nil {return _eecc ;};_cbdc :=_ae .NewTimestampClient ();
_fbe ,_eecc :=_cbdc .GetEncodedToken (_cdb ._edc ,_aee );if _eecc !=nil {return _eecc ;};_bbf :=len (_fbe );if _cdb ._afcf > 0&&_bbf > _cdb ._afcf {return _bg .ErrSignNotEnoughSpace ;};if _bbf > 0{_cdb ._afcf =_bbf +128;};sig .Contents =_bae .MakeHexString (string (_fbe ));
return nil ;};

// Validate validates PdfSignature.
func (_dagg *adobePKCS7Detached )Validate (sig *_bg .PdfSignature ,digest _bg .Hasher )(_bg .SignatureValidationResult ,error ){_eb :=sig .Contents .Bytes ();_gf ,_be :=_gg .Parse (_eb );if _be !=nil {return _bg .SignatureValidationResult {},_be ;};_dg :=digest .(*_gd .Buffer );
_gf .Content =_dg .Bytes ();if _be =_gf .Verify ();_be !=nil {return _bg .SignatureValidationResult {},_be ;};return _bg .SignatureValidationResult {IsSigned :true ,IsVerified :true },nil ;};

// NewDigest creates a new digest.
func (_ff *DocMDPHandler )NewDigest (sig *_bg .PdfSignature )(_bg .Hasher ,error ){return _ff ._fb .NewDigest (sig );};func _bef (_dagf _dc .ObjectIdentifier )(_cb .Hash ,error ){switch {case _dagf .Equal (_gg .OIDDigestAlgorithmSHA1 ),_dagf .Equal (_gg .OIDDigestAlgorithmECDSASHA1 ),_dagf .Equal (_gg .OIDDigestAlgorithmDSA ),_dagf .Equal (_gg .OIDDigestAlgorithmDSASHA1 ),_dagf .Equal (_gg .OIDEncryptionAlgorithmRSA ):return _cb .SHA1 ,nil ;
case _dagf .Equal (_gg .OIDDigestAlgorithmSHA256 ),_dagf .Equal (_gg .OIDDigestAlgorithmECDSASHA256 ):return _cb .SHA256 ,nil ;case _dagf .Equal (_gg .OIDDigestAlgorithmSHA384 ),_dagf .Equal (_gg .OIDDigestAlgorithmECDSASHA384 ):return _cb .SHA384 ,nil ;
case _dagf .Equal (_gg .OIDDigestAlgorithmSHA512 ),_dagf .Equal (_gg .OIDDigestAlgorithmECDSASHA512 ):return _cb .SHA512 ,nil ;};return _cb .Hash (0),_gg .ErrUnsupportedAlgorithm ;};

// NewDigest creates a new digest.
func (_daf *adobeX509RSASHA1 )NewDigest (sig *_bg .PdfSignature )(_bg .Hasher ,error ){if _fdb ,_gcad :=_daf .getHashAlgorithm (sig );_fdb !=0&&_gcad ==nil {return _fdb .New (),nil ;};return _dec .New (),nil ;};

// Validate validates PdfSignature.
func (_faa *adobeX509RSASHA1 )Validate (sig *_bg .PdfSignature ,digest _bg .Hasher )(_bg .SignatureValidationResult ,error ){_ead ,_fbfa :=_faa .getCertificate (sig );if _fbfa !=nil {return _bg .SignatureValidationResult {},_fbfa ;};_gfa :=sig .Contents .Bytes ();
var _dda []byte ;if _ ,_ebf :=_dc .Unmarshal (_gfa ,&_dda );_ebf !=nil {return _bg .SignatureValidationResult {},_ebf ;};_dgf ,_ef :=digest .(_g .Hash );if !_ef {return _bg .SignatureValidationResult {},_d .New ("\u0068a\u0073h\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_efg ,_ :=_faa .getHashAlgorithm (sig );if _efg ==0{_efg =_dec ;};if _gef :=_f .VerifyPKCS1v15 (_ead .PublicKey .(*_f .PublicKey ),_efg ,_dgf .Sum (nil ),_dda );_gef !=nil {return _bg .SignatureValidationResult {},_gef ;};return _bg .SignatureValidationResult {IsSigned :true ,IsVerified :true },nil ;
};

// NewDigest creates a new digest.
func (_cee *docTimeStamp )NewDigest (sig *_bg .PdfSignature )(_bg .Hasher ,error ){return _gd .NewBuffer (nil ),nil ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature
func (_cba *adobePKCS7Detached )IsApplicable (sig *_bg .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0061\u0064\u0062\u0065.p\u006b\u0063\u0073\u0037\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064";
};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_gga *adobeX509RSASHA1 )IsApplicable (sig *_bg .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0061d\u0062e\u002e\u0078\u0035\u0030\u0039.\u0072\u0073a\u005f\u0073\u0068\u0061\u0031";
};

// InitSignature initialization of the DocMDP signature.
func (_cgg *DocMDPHandler )InitSignature (sig *_bg .PdfSignature )error {_agg :=_cgg ._fb .InitSignature (sig );if _agg !=nil {return _agg ;};sig .Handler =_cgg ;if sig .Reference ==nil {sig .Reference =_bae .MakeArray ();};sig .Reference .Append (_bg .NewPdfSignatureReferenceDocMDP (_bg .NewPdfTransformParamsDocMDP (_cgg .Permission )).ToPdfObject ());
return nil ;};

// Sign sets the Contents fields.
func (_cfg *adobePKCS7Detached )Sign (sig *_bg .PdfSignature ,digest _bg .Hasher )error {if _cfg ._gcc {_ed :=_cfg ._cga ;if _ed <=0{_ed =8192;};sig .Contents =_bae .MakeHexString (string (make ([]byte ,_ed )));return nil ;};_ffd :=digest .(*_gd .Buffer );
_bba ,_cdd :=_gg .NewSignedData (_ffd .Bytes ());if _cdd !=nil {return _cdd ;};if _cbd :=_bba .AddSigner (_cfg ._df ,_cfg ._fe ,_gg .SignerInfoConfig {});_cbd !=nil {return _cbd ;};_bba .Detach ();_ec ,_cdd :=_bba .Finish ();if _cdd !=nil {return _cdd ;
};_fgf :=make ([]byte ,8192);copy (_fgf ,_ec );sig .Contents =_bae .MakeHexString (string (_fgf ));return nil ;};

// NewEmptyAdobePKCS7Detached creates a new Adobe.PPKMS/Adobe.PPKLite adbe.pkcs7.detached
// signature handler. The generated signature is empty and of size signatureLen.
// The signatureLen parameter can be 0 for the signature validation.
func NewEmptyAdobePKCS7Detached (signatureLen int )(_bg .SignatureHandler ,error ){return &adobePKCS7Detached {_gcc :true ,_cga :signatureLen },nil ;};func (_fa *adobeX509RSASHA1 )getHashAlgorithm (_bec *_bg .PdfSignature )(_cb .Hash ,error ){_fgg ,_ged :=_fa .getCertificate (_bec );
if _ged !=nil {if _fa ._cc !=0{return _fa ._cc ,nil ;};return _dec ,_ged ;};if _bec .Contents !=nil {_geg :=_bec .Contents .Bytes ();var _cge []byte ;if _ ,_eec :=_dc .Unmarshal (_geg ,&_cge );_eec ==nil {_cfa :=_gag (_fgg .PublicKey .(*_f .PublicKey ),_cge );
if _cfa > 0{return _cfa ,nil ;};};};if _fa ._cc !=0{return _fa ._cc ,nil ;};return _dec ,nil ;};

// NewDigest creates a new digest.
func (_fg *adobePKCS7Detached )NewDigest (sig *_bg .PdfSignature )(_bg .Hasher ,error ){return _gd .NewBuffer (nil ),nil ;};func (_fag *adobeX509RSASHA1 )sign (_ffe *_bg .PdfSignature ,_fbb _bg .Hasher ,_gb bool )error {if !_gb {return _fag .Sign (_ffe ,_fbb );
};_afb ,_ga :=_fag ._bgf .PublicKey .(*_f .PublicKey );if !_ga {return _c .Errorf ("i\u006e\u0076\u0061\u006c\u0069\u0064 \u0070\u0075\u0062\u006c\u0069\u0063\u0020\u006b\u0065y\u0020\u0074\u0079p\u0065:\u0020\u0025\u0054",_afb );};_cde ,_eee :=_dc .Marshal (make ([]byte ,_afb .Size ()));
if _eee !=nil {return _eee ;};_ffe .Contents =_bae .MakeHexString (string (_cde ));return nil ;};func (_gdf *adobePKCS7Detached )getCertificate (_cbb *_bg .PdfSignature )(*_dce .Certificate ,error ){if _gdf ._df !=nil {return _gdf ._df ,nil ;};_bbc ,_cac :=_cbb .GetCerts ();
if _cac !=nil {return nil ,_cac ;};return _bbc [0],nil ;};

// DocMDPHandler describes handler for the DocMDP realization.
type DocMDPHandler struct{_fb _bg .SignatureHandler ;Permission _gca .DocMDPPermission ;};

// NewDocTimeStampWithOpts returns a new DocTimeStamp configured using the
// specified options. If no options are provided, default options will be used.
// Both the timestamp server URL and the hash algorithm can be empty for the
// signature validation.
// The following hash algorithms are supported:
// crypto.SHA1, crypto.SHA256, crypto.SHA384, crypto.SHA512.
func NewDocTimeStampWithOpts (timestampServerURL string ,hashAlgorithm _cb .Hash ,opts *DocTimeStampOpts )(_bg .SignatureHandler ,error ){if opts ==nil {opts =&DocTimeStampOpts {};};if opts .SignatureSize <=0{opts .SignatureSize =4192;};return &docTimeStamp {_edc :timestampServerURL ,_fea :hashAlgorithm ,_afcf :opts .SignatureSize },nil ;
};