//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package sighandler implements digital signature handlers for PDF signature validation and signing.
package sighandler ;import (_g "bytes";_e "crypto";_ea "crypto/rand";_b "crypto/rsa";_add "crypto/x509";_ec "crypto/x509/pkix";_aa "encoding/asn1";_dd "errors";_af "fmt";_adf "github.com/unidoc/pkcs7";_ba "github.com/unidoc/timestamp";_ge "github.com/unidoc/unipdf/v3/core";_ecd "github.com/unidoc/unipdf/v3/model";_cb "hash";_c "io";_ad "io/ioutil";_a "net/http";_f "time";);

// Sign sets the Contents fields.
func (_cf *adobePKCS7Detached )Sign (sig *_ecd .PdfSignature ,digest _ecd .Hasher )error {if _cf ._eab {_gg :=_cf ._bf ;if _gg <=0{_gg =8192;};sig .Contents =_ge .MakeHexString (string (make ([]byte ,_gg )));return nil ;};_ac :=digest .(*_g .Buffer );_fg ,_ag :=_adf .NewSignedData (_ac .Bytes ());if _ag !=nil {return _ag ;};if _dg :=_fg .AddSigner (_cf ._fb ,_cf ._bc ,_adf .SignerInfoConfig {});_dg !=nil {return _dg ;};_fg .Detach ();_aae ,_ag :=_fg .Finish ();if _ag !=nil {return _ag ;};_feg :=make ([]byte ,8192);copy (_feg ,_aae );sig .Contents =_ge .MakeHexString (string (_feg ));return nil ;};func (_cbf *adobeX509RSASHA1 )getCertificate (_bag *_ecd .PdfSignature )(*_add .Certificate ,error ){if _cbf ._acc !=nil {return _cbf ._acc ,nil ;};var _fag []byte ;switch _dgg :=_bag .Cert .(type ){case *_ge .PdfObjectString :_fag =_dgg .Bytes ();case *_ge .PdfObjectArray :if _dgg .Len ()==0{return nil ,_dd .New ("\u006e\u006f\u0020s\u0069\u0067\u006e\u0061t\u0075\u0072\u0065\u0020\u0063\u0065\u0072t\u0069\u0066\u0069\u0063\u0061\u0074\u0065\u0073\u0020\u0066\u006f\u0075\u006e\u0064");};for _ ,_fc :=range _dgg .Elements (){_ecc ,_eaa :=_ge .GetString (_fc );if !_eaa {return nil ,_af .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0065\u0072\u0074\u0069\u0066\u0069\u0063\u0061\u0074\u0065\u0020\u006f\u0062j\u0065\u0063\u0074\u0020\u0074\u0079p\u0065\u0020\u0069\u006e\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065 \u0063\u0065r\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u0063h\u0061\u0069\u006e\u003a\u0020\u0025\u0054",_fc );};_fag =append (_fag ,_ecc .Bytes ()...);};default:return nil ,_af .Errorf ("\u0069n\u0076\u0061l\u0069\u0064\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072e\u0020\u0063\u0065\u0072\u0074\u0069f\u0069\u0063\u0061\u0074\u0065\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054",_dgg );};_caa ,_efe :=_add .ParseCertificates (_fag );if _efe !=nil {return nil ,_efe ;};return _caa [0],nil ;};

// SignFunc represents a custom signing function. The function should return
// the computed signature.
type SignFunc func (_dc *_ecd .PdfSignature ,_de _ecd .Hasher )([]byte ,error );

// InitSignature initialises the PdfSignature.
func (_acf *adobeX509RSASHA1 )InitSignature (sig *_ecd .PdfSignature )error {if _acf ._acc ==nil {return _dd .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");};if _acf ._ada ==nil &&_acf ._cfd ==nil {return _dd .New ("\u006d\u0075\u0073\u0074\u0020\u0070\u0072o\u0076\u0069\u0064e\u0020\u0065\u0069t\u0068\u0065r\u0020\u0061\u0020\u0070\u0072\u0069v\u0061te\u0020\u006b\u0065\u0079\u0020\u006f\u0072\u0020\u0061\u0020\u0073\u0069\u0067\u006e\u0069\u006e\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e");};_dcb :=*_acf ;sig .Handler =&_dcb ;sig .Filter =_ge .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");sig .SubFilter =_ge .MakeName ("\u0061d\u0062e\u002e\u0078\u0035\u0030\u0039.\u0072\u0073a\u005f\u0073\u0068\u0061\u0031");sig .Cert =_ge .MakeString (string (_dcb ._acc .Raw ));sig .Reference =nil ;_fa ,_bcc :=_dcb .NewDigest (sig );if _bcc !=nil {return _bcc ;};_fa .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));return _dcb .Sign (sig ,_fa );};func (_baab *docTimeStamp )getCertificate (_cbfd *_ecd .PdfSignature )(*_add .Certificate ,error ){var _bfe []byte ;switch _efa :=_cbfd .Cert .(type ){case *_ge .PdfObjectString :_bfe =_efa .Bytes ();case *_ge .PdfObjectArray :if _efa .Len ()==0{return nil ,_dd .New ("\u006e\u006f\u0020s\u0069\u0067\u006e\u0061t\u0075\u0072\u0065\u0020\u0063\u0065\u0072t\u0069\u0066\u0069\u0063\u0061\u0074\u0065\u0073\u0020\u0066\u006f\u0075\u006e\u0064");};for _ ,_edf :=range _efa .Elements (){_fd ,_aeb :=_ge .GetString (_edf );if !_aeb {return nil ,_af .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0065\u0072\u0074\u0069\u0066\u0069\u0063\u0061\u0074\u0065\u0020\u006f\u0062j\u0065\u0063\u0074\u0020\u0074\u0079p\u0065\u0020\u0069\u006e\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065 \u0063\u0065r\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u0063h\u0061\u0069\u006e\u003a\u0020\u0025\u0054",_edf );};_bfe =append (_bfe ,_fd .Bytes ()...);};default:return nil ,_af .Errorf ("\u0069n\u0076\u0061l\u0069\u0064\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072e\u0020\u0063\u0065\u0072\u0074\u0069f\u0069\u0063\u0061\u0074\u0065\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054",_efa );};_dfd ,_bfc :=_add .ParseCertificates (_bfe );if _bfc !=nil {return nil ,_bfc ;};return _dfd [0],nil ;};

// NewDigest creates a new digest.
func (_gc *docTimeStamp )NewDigest (sig *_ecd .PdfSignature )(_ecd .Hasher ,error ){return _g .NewBuffer (nil ),nil ;};

// NewAdobeX509RSASHA1Custom creates a new Adobe.PPKMS/Adobe.PPKLite adbe.x509.rsa_sha1 signature handler
// with a custom signing function. Both parameters may be nil for the signature validation.
func NewAdobeX509RSASHA1Custom (certificate *_add .Certificate ,signFunc SignFunc )(_ecd .SignatureHandler ,error ){return &adobeX509RSASHA1 {_acc :certificate ,_cfd :signFunc },nil ;};

// DocTimeStampOpts defines options for configuring the timestamp handler.
type DocTimeStampOpts struct{

// SignatureSize is the estimated size of the signature contents in bytes.
// If not provided, a default signature size of 4192 is used.
// The signing process will report the model.ErrSignNotEnoughSpace error
// if the estimated signature size is smaller than the actual size of the
// signature.
SignatureSize int ;};

// NewDigest creates a new digest.
func (_baa *adobePKCS7Detached )NewDigest (sig *_ecd .PdfSignature )(_ecd .Hasher ,error ){return _g .NewBuffer (nil ),nil ;};

// InitSignature initialises the PdfSignature.
func (_afd *adobePKCS7Detached )InitSignature (sig *_ecd .PdfSignature )error {if !_afd ._eab {if _afd ._fb ==nil {return _dd .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");};if _afd ._bc ==nil {return _dd .New ("\u0070\u0072\u0069\u0076\u0061\u0074\u0065\u004b\u0065\u0079\u0020m\u0075\u0073\u0074\u0020\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c");};};_bd :=*_afd ;sig .Handler =&_bd ;sig .Filter =_ge .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");sig .SubFilter =_ge .MakeName ("\u0061\u0064\u0062\u0065.p\u006b\u0063\u0073\u0037\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064");sig .Reference =nil ;_cba ,_ca :=_bd .NewDigest (sig );if _ca !=nil {return _ca ;};_cba .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));return _bd .Sign (sig ,_cba );};

// NewDocTimeStampWithOpts returns a new DocTimeStamp configured using the
// specified options. If no options are provided, default options will be used.
// Both the timestamp server URL and the hash algorithm can be empty for the
// signature validation.
// The following hash algorithms are supported:
// crypto.SHA1, crypto.SHA256, crypto.SHA384, crypto.SHA512.
func NewDocTimeStampWithOpts (timestampServerURL string ,hashAlgorithm _e .Hash ,opts *DocTimeStampOpts )(_ecd .SignatureHandler ,error ){if opts ==nil {opts =&DocTimeStampOpts {};};if opts .SignatureSize <=0{opts .SignatureSize =4192;};return &docTimeStamp {_bcg :timestampServerURL ,_fec :hashAlgorithm ,_faa :opts .SignatureSize },nil ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature
func (_ee *adobePKCS7Detached )IsApplicable (sig *_ecd .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0061\u0064\u0062\u0065.p\u006b\u0063\u0073\u0037\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064";};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_cbc *adobeX509RSASHA1 )IsApplicable (sig *_ecd .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0061d\u0062e\u002e\u0078\u0035\u0030\u0039.\u0072\u0073a\u005f\u0073\u0068\u0061\u0031";};

// Sign sets the Contents fields for the PdfSignature.
func (_ae *adobeX509RSASHA1 )Sign (sig *_ecd .PdfSignature ,digest _ecd .Hasher )error {var _eef []byte ;var _ded error ;if _ae ._cfd !=nil {_eef ,_ded =_ae ._cfd (sig ,digest );if _ded !=nil {return _ded ;};}else {_acd ,_dde :=digest .(_cb .Hash );if !_dde {return _dd .New ("\u0068a\u0073h\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_cgc ,_ :=_ead (_ae ._acc .SignatureAlgorithm );_eef ,_ded =_b .SignPKCS1v15 (_ea .Reader ,_ae ._ada ,_cgc ,_acd .Sum (nil ));if _ded !=nil {return _ded ;};};_eef ,_ded =_aa .Marshal (_eef );if _ded !=nil {return _ded ;};sig .Contents =_ge .MakeHexString (string (_eef ));return nil ;};

// NewDigest creates a new digest.
func (_fbe *adobeX509RSASHA1 )NewDigest (sig *_ecd .PdfSignature )(_ecd .Hasher ,error ){_fbc ,_dca :=_fbe .getCertificate (sig );if _dca !=nil {return nil ,_dca ;};_bcf ,_ :=_ead (_fbc .SignatureAlgorithm );return _bcf .New (),nil ;};

// NewAdobeX509RSASHA1 creates a new Adobe.PPKMS/Adobe.PPKLite adbe.x509.rsa_sha1 signature handler.
// Both parameters may be nil for the signature validation.
func NewAdobeX509RSASHA1 (privateKey *_b .PrivateKey ,certificate *_add .Certificate )(_ecd .SignatureHandler ,error ){return &adobeX509RSASHA1 {_acc :certificate ,_ada :privateKey },nil ;};

// InitSignature initialises the PdfSignature.
func (_cga *docTimeStamp )InitSignature (sig *_ecd .PdfSignature )error {_aca :=*_cga ;sig .Handler =&_aca ;sig .Filter =_ge .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");sig .SubFilter =_ge .MakeName ("\u0045\u0054\u0053I\u002e\u0052\u0046\u0043\u0033\u0031\u0036\u0031");sig .Reference =nil ;if _cga ._faa > 0{sig .Contents =_ge .MakeHexString (string (make ([]byte ,_cga ._faa )));}else {_agb ,_ceb :=_cga .NewDigest (sig );if _ceb !=nil {return _ceb ;};_agb .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));if _ceb =_aca .Sign (sig ,_agb );_ceb !=nil {return _ceb ;};_cga ._faa =_aca ._faa ;};return nil ;};func _ead (_dcg _add .SignatureAlgorithm )(_e .Hash ,bool ){var _aad _e .Hash ;switch _dcg {case _add .SHA1WithRSA :_aad =_e .SHA1 ;case _add .SHA256WithRSA :_aad =_e .SHA256 ;case _add .SHA384WithRSA :_aad =_e .SHA384 ;case _add .SHA512WithRSA :_aad =_e .SHA512 ;default:return _e .SHA1 ,false ;};return _aad ,true ;};

// NewAdobePKCS7Detached creates a new Adobe.PPKMS/Adobe.PPKLite adbe.pkcs7.detached signature handler.
// Both parameters may be nil for the signature validation.
func NewAdobePKCS7Detached (privateKey *_b .PrivateKey ,certificate *_add .Certificate )(_ecd .SignatureHandler ,error ){return &adobePKCS7Detached {_fb :certificate ,_bc :privateKey },nil ;};

// NewDocTimeStamp creates a new DocTimeStamp signature handler.
// Both the timestamp server URL and the hash algorithm can be empty for the
// signature validation.
// The following hash algorithms are supported:
// crypto.SHA1, crypto.SHA256, crypto.SHA384, crypto.SHA512.
// NOTE: the handler will do a mock Sign when initializing the signature
// in order to estimate the signature size. Use NewDocTimeStampWithOpts
// for providing the signature size.
func NewDocTimeStamp (timestampServerURL string ,hashAlgorithm _e .Hash )(_ecd .SignatureHandler ,error ){return &docTimeStamp {_bcg :timestampServerURL ,_fec :hashAlgorithm },nil ;};

// Validate validates PdfSignature.
func (_gb *adobeX509RSASHA1 )Validate (sig *_ecd .PdfSignature ,digest _ecd .Hasher )(_ecd .SignatureValidationResult ,error ){_fgb ,_bb :=_gb .getCertificate (sig );if _bb !=nil {return _ecd .SignatureValidationResult {},_bb ;};_gd :=sig .Contents .Bytes ();var _ce []byte ;if _ ,_db :=_aa .Unmarshal (_gd ,&_ce );_db !=nil {return _ecd .SignatureValidationResult {},_db ;};_bfd ,_aadc :=digest .(_cb .Hash );if !_aadc {return _ecd .SignatureValidationResult {},_dd .New ("\u0068a\u0073h\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_ff ,_ :=_ead (_fgb .SignatureAlgorithm );if _cee :=_b .VerifyPKCS1v15 (_fgb .PublicKey .(*_b .PublicKey ),_ff ,_bfd .Sum (nil ),_ce );_cee !=nil {return _ecd .SignatureValidationResult {},_cee ;};return _ecd .SignatureValidationResult {IsSigned :true ,IsVerified :true },nil ;};type docTimeStamp struct{_bcg string ;_fec _e .Hash ;_faa int ;};func (_ef *adobePKCS7Detached )getCertificate (_df *_ecd .PdfSignature )(*_add .Certificate ,error ){if _ef ._fb !=nil {return _ef ._fb ,nil ;};var _da []byte ;switch _cd :=_df .Cert .(type ){case *_ge .PdfObjectString :_da =_cd .Bytes ();case *_ge .PdfObjectArray :if _cd .Len ()==0{return nil ,_dd .New ("\u006e\u006f\u0020s\u0069\u0067\u006e\u0061t\u0075\u0072\u0065\u0020\u0063\u0065\u0072t\u0069\u0066\u0069\u0063\u0061\u0074\u0065\u0073\u0020\u0066\u006f\u0075\u006e\u0064");};for _ ,_baf :=range _cd .Elements (){_daa ,_cg :=_ge .GetString (_baf );if !_cg {return nil ,_af .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0065\u0072\u0074\u0069\u0066\u0069\u0063\u0061\u0074\u0065\u0020\u006f\u0062j\u0065\u0063\u0074\u0020\u0074\u0079p\u0065\u0020\u0069\u006e\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065 \u0063\u0065r\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u0063h\u0061\u0069\u006e\u003a\u0020\u0025\u0054",_baf );};_da =append (_da ,_daa .Bytes ()...);};default:return nil ,_af .Errorf ("\u0069n\u0076\u0061l\u0069\u0064\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072e\u0020\u0063\u0065\u0072\u0074\u0069f\u0069\u0063\u0061\u0074\u0065\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054",_cd );};_aaa ,_dad :=_add .ParseCertificates (_da );if _dad !=nil {return nil ,_dad ;};return _aaa [0],nil ;};

// Validate validates PdfSignature.
func (_cgce *docTimeStamp )Validate (sig *_ecd .PdfSignature ,digest _ecd .Hasher )(_ecd .SignatureValidationResult ,error ){_adb :=sig .Contents .Bytes ();_eed ,_efb :=_adf .Parse (_adb );if _efb !=nil {return _ecd .SignatureValidationResult {},_efb ;};if _efb =_eed .Verify ();_efb !=nil {return _ecd .SignatureValidationResult {},_efb ;};var _fde timestampInfo ;_ ,_efb =_aa .Unmarshal (_eed .Content ,&_fde );if _efb !=nil {return _ecd .SignatureValidationResult {},_efb ;};_cfc ,_efb :=_bg (_fde .MessageImprint .HashAlgorithm .Algorithm );if _efb !=nil {return _ecd .SignatureValidationResult {},_efb ;};_bbb :=_cfc .New ();_fdf :=digest .(*_g .Buffer );_bbb .Write (_fdf .Bytes ());_adg :=_bbb .Sum (nil );_eb :=_ecd .SignatureValidationResult {IsSigned :true ,IsVerified :_g .Equal (_adg ,_fde .MessageImprint .HashedMessage ),GeneralizedTime :_fde .GeneralizedTime };return _eb ,nil ;};

// Sign sets the Contents fields for the PdfSignature.
func (_baaf *docTimeStamp )Sign (sig *_ecd .PdfSignature ,digest _ecd .Hasher )error {_gca :=digest .(*_g .Buffer );_ffg :=_baaf ._fec .New ();if _ ,_cbcb :=_c .Copy (_ffg ,_gca );_cbcb !=nil {return _cbcb ;};_efc :=_ba .Request {HashAlgorithm :_baaf ._fec ,HashedMessage :_ffg .Sum (nil ),Certificates :true ,Extensions :nil ,ExtraExtensions :nil };_ebe ,_feec :=_efc .Marshal ();if _feec !=nil {return _feec ;};_aee ,_feec :=_a .Post (_baaf ._bcg ,"a\u0070\u0070\u006c\u0069\u0063\u0061t\u0069\u006f\u006e\u002f\u0074\u0069\u006d\u0065\u0073t\u0061\u006d\u0070-\u0071u\u0065\u0072\u0079",_g .NewBuffer (_ebe ));if _feec !=nil {return _feec ;};defer _aee .Body .Close ();_dcgb ,_feec :=_ad .ReadAll (_aee .Body );if _feec !=nil {return _feec ;};if _aee .StatusCode !=_a .StatusOK {return _af .Errorf ("\u0068\u0074\u0074\u0070\u0020\u0073\u0074\u0061\u0074\u0075\u0073\u0020\u0063\u006f\u0064e\u0020n\u006f\u0074\u0020\u006f\u006b\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0064\u0029",_aee .StatusCode );};var _dge struct{Version _aa .RawValue ;Content _aa .RawValue ;};if _ ,_feec =_aa .Unmarshal (_dcgb ,&_dge );_feec !=nil {return _feec ;};_gbd :=len (_dge .Content .FullBytes );if _baaf ._faa > 0&&_gbd > _baaf ._faa {return _ecd .ErrSignNotEnoughSpace ;};if _gbd > 0{_baaf ._faa =_gbd +128;};sig .Contents =_ge .MakeHexString (string (_dge .Content .FullBytes ));return nil ;};type adobeX509RSASHA1 struct{_ada *_b .PrivateKey ;_acc *_add .Certificate ;_cfd SignFunc ;};type timestampInfo struct{Version int ;Policy _aa .RawValue ;MessageImprint struct{HashAlgorithm _ec .AlgorithmIdentifier ;HashedMessage []byte ;};SerialNumber _aa .RawValue ;GeneralizedTime _f .Time ;};func _bg (_eae _aa .ObjectIdentifier )(_e .Hash ,error ){switch {case _eae .Equal (_adf .OIDDigestAlgorithmSHA1 ),_eae .Equal (_adf .OIDDigestAlgorithmECDSASHA1 ),_eae .Equal (_adf .OIDDigestAlgorithmDSA ),_eae .Equal (_adf .OIDDigestAlgorithmDSASHA1 ),_eae .Equal (_adf .OIDEncryptionAlgorithmRSA ):return _e .SHA1 ,nil ;case _eae .Equal (_adf .OIDDigestAlgorithmSHA256 ),_eae .Equal (_adf .OIDDigestAlgorithmECDSASHA256 ):return _e .SHA256 ,nil ;case _eae .Equal (_adf .OIDDigestAlgorithmSHA384 ),_eae .Equal (_adf .OIDDigestAlgorithmECDSASHA384 ):return _e .SHA384 ,nil ;case _eae .Equal (_adf .OIDDigestAlgorithmSHA512 ),_eae .Equal (_adf .OIDDigestAlgorithmECDSASHA512 ):return _e .SHA512 ,nil ;};return _e .Hash (0),_adf .ErrUnsupportedAlgorithm ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_dea *docTimeStamp )IsApplicable (sig *_ecd .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0045\u0054\u0053I\u002e\u0052\u0046\u0043\u0033\u0031\u0036\u0031";};

// NewEmptyAdobePKCS7Detached creates a new Adobe.PPKMS/Adobe.PPKLite adbe.pkcs7.detached
// signature handler. The generated signature is empty and of size signatureLen.
// The signatureLen parameter can be 0 for the signature validation.
func NewEmptyAdobePKCS7Detached (signatureLen int )(_ecd .SignatureHandler ,error ){return &adobePKCS7Detached {_eab :true ,_bf :signatureLen },nil ;};

// Validate validates PdfSignature.
func (_adfg *adobePKCS7Detached )Validate (sig *_ecd .PdfSignature ,digest _ecd .Hasher )(_ecd .SignatureValidationResult ,error ){_ed :=sig .Contents .Bytes ();_fe ,_fee :=_adf .Parse (_ed );if _fee !=nil {return _ecd .SignatureValidationResult {},_fee ;};_bae :=digest .(*_g .Buffer );_fe .Content =_bae .Bytes ();if _fee =_fe .Verify ();_fee !=nil {return _ecd .SignatureValidationResult {},_fee ;};return _ecd .SignatureValidationResult {IsSigned :true ,IsVerified :true },nil ;};type adobePKCS7Detached struct{_bc *_b .PrivateKey ;_fb *_add .Certificate ;_eab bool ;_bf int ;};