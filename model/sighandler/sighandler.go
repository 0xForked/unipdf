//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package sighandler implements digital signature handlers for PDF signature validation and signing.
package sighandler ;import (_d "bytes";_ae "crypto";_ga "crypto/rand";_ac "crypto/rsa";_dd "crypto/x509";_aa "crypto/x509/pkix";_cb "encoding/asn1";_f "errors";_db "fmt";_gc "github.com/unidoc/pkcs7";_ca "github.com/unidoc/timestamp";_aeg "github.com/unidoc/unipdf/v3/core";_cc "github.com/unidoc/unipdf/v3/model";_eg "hash";_c "io";_ed "io/ioutil";_g "net/http";_e "time";);type adobeX509RSASHA1 struct{_cca *_ac .PrivateKey ;_gad *_dd .Certificate ;_ce SignFunc ;};func (_agf *docTimeStamp )getCertificate (_ebcc *_cc .PdfSignature )(*_dd .Certificate ,error ){var _bfab []byte ;switch _ef :=_ebcc .Cert .(type ){case *_aeg .PdfObjectString :_bfab =_ef .Bytes ();case *_aeg .PdfObjectArray :if _ef .Len ()==0{return nil ,_f .New ("\u006e\u006f\u0020s\u0069\u0067\u006e\u0061t\u0075\u0072\u0065\u0020\u0063\u0065\u0072t\u0069\u0066\u0069\u0063\u0061\u0074\u0065\u0073\u0020\u0066\u006f\u0075\u006e\u0064");};for _ ,_ada :=range _ef .Elements (){_abae ,_dda :=_aeg .GetString (_ada );if !_dda {return nil ,_db .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0065\u0072\u0074\u0069\u0066\u0069\u0063\u0061\u0074\u0065\u0020\u006f\u0062j\u0065\u0063\u0074\u0020\u0074\u0079p\u0065\u0020\u0069\u006e\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065 \u0063\u0065r\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u0063h\u0061\u0069\u006e\u003a\u0020\u0025\u0054",_ada );};_bfab =append (_bfab ,_abae .Bytes ()...);};default:return nil ,_db .Errorf ("\u0069n\u0076\u0061l\u0069\u0064\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072e\u0020\u0063\u0065\u0072\u0074\u0069f\u0069\u0063\u0061\u0074\u0065\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054",_ef );};_ddbd ,_cad :=_dd .ParseCertificates (_bfab );if _cad !=nil {return nil ,_cad ;};return _ddbd [0],nil ;};

// NewDigest creates a new digest.
func (_dc *adobePKCS7Detached )NewDigest (sig *_cc .PdfSignature )(_cc .Hasher ,error ){return _d .NewBuffer (nil ),nil ;};

// NewDigest creates a new digest.
func (_cbef *docTimeStamp )NewDigest (sig *_cc .PdfSignature )(_cc .Hasher ,error ){return _d .NewBuffer (nil ),nil ;};func _dad (_ddca _cb .ObjectIdentifier )(_ae .Hash ,error ){switch {case _ddca .Equal (_gc .OIDDigestAlgorithmSHA1 ),_ddca .Equal (_gc .OIDDigestAlgorithmECDSASHA1 ),_ddca .Equal (_gc .OIDDigestAlgorithmDSA ),_ddca .Equal (_gc .OIDDigestAlgorithmDSASHA1 ),_ddca .Equal (_gc .OIDEncryptionAlgorithmRSA ):return _ae .SHA1 ,nil ;case _ddca .Equal (_gc .OIDDigestAlgorithmSHA256 ),_ddca .Equal (_gc .OIDDigestAlgorithmECDSASHA256 ):return _ae .SHA256 ,nil ;case _ddca .Equal (_gc .OIDDigestAlgorithmSHA384 ),_ddca .Equal (_gc .OIDDigestAlgorithmECDSASHA384 ):return _ae .SHA384 ,nil ;case _ddca .Equal (_gc .OIDDigestAlgorithmSHA512 ),_ddca .Equal (_gc .OIDDigestAlgorithmECDSASHA512 ):return _ae .SHA512 ,nil ;};return _ae .Hash (0),_gc .ErrUnsupportedAlgorithm ;};

// Validate validates PdfSignature.
func (_ede *adobePKCS7Detached )Validate (sig *_cc .PdfSignature ,digest _cc .Hasher )(_cc .SignatureValidationResult ,error ){_bg :=sig .Contents .Bytes ();_cab ,_ad :=_gc .Parse (_bg );if _ad !=nil {return _cc .SignatureValidationResult {},_ad ;};_gdd :=digest .(*_d .Buffer );_cab .Content =_gdd .Bytes ();if _ad =_cab .Verify ();_ad !=nil {return _cc .SignatureValidationResult {},_ad ;};return _cc .SignatureValidationResult {IsSigned :true ,IsVerified :true },nil ;};

// SignFunc represents a custom signing function. The function should return
// the computed signature.
type SignFunc func (_aaf *_cc .PdfSignature ,_dg _cc .Hasher )([]byte ,error );

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_bedb *docTimeStamp )IsApplicable (sig *_cc .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0045\u0054\u0053I\u002e\u0052\u0046\u0043\u0033\u0031\u0036\u0031";};

// NewAdobeX509RSASHA1Custom creates a new Adobe.PPKMS/Adobe.PPKLite adbe.x509.rsa_sha1 signature handler
// with a custom signing function. Both parameters may be nil for the signature validation.
func NewAdobeX509RSASHA1Custom (certificate *_dd .Certificate ,signFunc SignFunc )(_cc .SignatureHandler ,error ){return &adobeX509RSASHA1 {_gad :certificate ,_ce :signFunc },nil ;};func (_b *adobePKCS7Detached )getCertificate (_fg *_cc .PdfSignature )(*_dd .Certificate ,error ){if _b ._gd !=nil {return _b ._gd ,nil ;};var _ee []byte ;switch _aca :=_fg .Cert .(type ){case *_aeg .PdfObjectString :_ee =_aca .Bytes ();case *_aeg .PdfObjectArray :if _aca .Len ()==0{return nil ,_f .New ("\u006e\u006f\u0020s\u0069\u0067\u006e\u0061t\u0075\u0072\u0065\u0020\u0063\u0065\u0072t\u0069\u0066\u0069\u0063\u0061\u0074\u0065\u0073\u0020\u0066\u006f\u0075\u006e\u0064");};for _ ,_bc :=range _aca .Elements (){_gf ,_de :=_aeg .GetString (_bc );if !_de {return nil ,_db .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0065\u0072\u0074\u0069\u0066\u0069\u0063\u0061\u0074\u0065\u0020\u006f\u0062j\u0065\u0063\u0074\u0020\u0074\u0079p\u0065\u0020\u0069\u006e\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065 \u0063\u0065r\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u0063h\u0061\u0069\u006e\u003a\u0020\u0025\u0054",_bc );};_ee =append (_ee ,_gf .Bytes ()...);};default:return nil ,_db .Errorf ("\u0069n\u0076\u0061l\u0069\u0064\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072e\u0020\u0063\u0065\u0072\u0074\u0069f\u0069\u0063\u0061\u0074\u0065\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054",_aca );};_gdg ,_be :=_dd .ParseCertificates (_ee );if _be !=nil {return nil ,_be ;};return _gdg [0],nil ;};

// InitSignature initialises the PdfSignature.
func (_bgc *docTimeStamp )InitSignature (sig *_cc .PdfSignature )error {_gg :=*_bgc ;sig .Handler =&_gg ;sig .Filter =_aeg .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");sig .SubFilter =_aeg .MakeName ("\u0045\u0054\u0053I\u002e\u0052\u0046\u0043\u0033\u0031\u0036\u0031");sig .Reference =nil ;_gda ,_dfb :=_bgc .NewDigest (sig );if _dfb !=nil {return _dfb ;};_gda .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));return _gg .Sign (sig ,_gda );};

// NewAdobeX509RSASHA1 creates a new Adobe.PPKMS/Adobe.PPKLite adbe.x509.rsa_sha1 signature handler.
// Both parameters may be nil for the signature validation.
func NewAdobeX509RSASHA1 (privateKey *_ac .PrivateKey ,certificate *_dd .Certificate )(_cc .SignatureHandler ,error ){return &adobeX509RSASHA1 {_gad :certificate ,_cca :privateKey },nil ;};

// NewDigest creates a new digest.
func (_ace *adobeX509RSASHA1 )NewDigest (sig *_cc .PdfSignature )(_cc .Hasher ,error ){_agg ,_bfa :=_ace .getCertificate (sig );if _bfa !=nil {return nil ,_bfa ;};_aag ,_ :=_bfc (_agg .SignatureAlgorithm );return _aag .New (),nil ;};type docTimeStamp struct{_ffb string ;_ebd _ae .Hash ;};

// Validate validates PdfSignature.
func (_fb *docTimeStamp )Validate (sig *_cc .PdfSignature ,digest _cc .Hasher )(_cc .SignatureValidationResult ,error ){_bee :=sig .Contents .Bytes ();_cd ,_becg :=_gc .Parse (_bee );if _becg !=nil {return _cc .SignatureValidationResult {},_becg ;};if _becg =_cd .Verify ();_becg !=nil {return _cc .SignatureValidationResult {},_becg ;};var _bed timestampInfo ;_ ,_becg =_cb .Unmarshal (_cd .Content ,&_bed );if _becg !=nil {return _cc .SignatureValidationResult {},_becg ;};_fc ,_becg :=_dad (_bed .MessageImprint .HashAlgorithm .Algorithm );if _becg !=nil {return _cc .SignatureValidationResult {},_becg ;};_ceb :=_fc .New ();_edef :=digest .(*_d .Buffer );_ceb .Write (_edef .Bytes ());_ddcg :=_ceb .Sum (nil );_cebg :=_cc .SignatureValidationResult {IsSigned :true ,IsVerified :_d .Equal (_ddcg ,_bed .MessageImprint .HashedMessage ),GeneralizedTime :_bed .GeneralizedTime };return _cebg ,nil ;};

// Validate validates PdfSignature.
func (_ba *adobeX509RSASHA1 )Validate (sig *_cc .PdfSignature ,digest _cc .Hasher )(_cc .SignatureValidationResult ,error ){_bb ,_gea :=_ba .getCertificate (sig );if _gea !=nil {return _cc .SignatureValidationResult {},_gea ;};_aed :=sig .Contents .Bytes ();var _fgd []byte ;if _ ,_geg :=_cb .Unmarshal (_aed ,&_fgd );_geg !=nil {return _cc .SignatureValidationResult {},_geg ;};_ffc ,_age :=digest .(_eg .Hash );if !_age {return _cc .SignatureValidationResult {},_f .New ("\u0068a\u0073h\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_adb ,_ :=_bfc (_bb .SignatureAlgorithm );if _ebe :=_ac .VerifyPKCS1v15 (_bb .PublicKey .(*_ac .PublicKey ),_adb ,_ffc .Sum (nil ),_fgd );_ebe !=nil {return _cc .SignatureValidationResult {},_ebe ;};return _cc .SignatureValidationResult {IsSigned :true ,IsVerified :true },nil ;};

// InitSignature initialises the PdfSignature.
func (_gfc *adobeX509RSASHA1 )InitSignature (sig *_cc .PdfSignature )error {if _gfc ._gad ==nil {return _f .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");};if _gfc ._cca ==nil &&_gfc ._ce ==nil {return _f .New ("\u006d\u0075\u0073\u0074\u0020\u0070\u0072o\u0076\u0069\u0064e\u0020\u0065\u0069t\u0068\u0065r\u0020\u0061\u0020\u0070\u0072\u0069v\u0061te\u0020\u006b\u0065\u0079\u0020\u006f\u0072\u0020\u0061\u0020\u0073\u0069\u0067\u006e\u0069\u006e\u0067\u0020\u0066\u0075\u006e\u0063\u0074\u0069\u006f\u006e");};_ccg :=*_gfc ;sig .Handler =&_ccg ;sig .Filter =_aeg .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");sig .SubFilter =_aeg .MakeName ("\u0061d\u0062e\u002e\u0078\u0035\u0030\u0039.\u0072\u0073a\u005f\u0073\u0068\u0061\u0031");sig .Cert =_aeg .MakeString (string (_ccg ._gad .Raw ));sig .Reference =nil ;_dgf ,_df :=_ccg .NewDigest (sig );if _df !=nil {return _df ;};_dgf .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));return _ccg .Sign (sig ,_dgf );};

// NewAdobePKCS7Detached creates a new Adobe.PPKMS/Adobe.PPKLite adbe.pkcs7.detached signature handler.
// Both parameters may be nil for the signature validation.
func NewAdobePKCS7Detached (privateKey *_ac .PrivateKey ,certificate *_dd .Certificate )(_cc .SignatureHandler ,error ){return &adobePKCS7Detached {_gd :certificate ,_ec :privateKey },nil ;};

// InitSignature initialises the PdfSignature.
func (_ag *adobePKCS7Detached )InitSignature (sig *_cc .PdfSignature )error {if !_ag ._fe {if _ag ._gd ==nil {return _f .New ("c\u0065\u0072\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u006d\u0075\u0073\u0074\u0020n\u006f\u0074\u0020b\u0065 \u006e\u0069\u006c");};if _ag ._ec ==nil {return _f .New ("\u0070\u0072\u0069\u0076\u0061\u0074\u0065\u004b\u0065\u0079\u0020m\u0075\u0073\u0074\u0020\u006e\u006f\u0074\u0020\u0062\u0065 \u006e\u0069\u006c");};};_gdf :=*_ag ;sig .Handler =&_gdf ;sig .Filter =_aeg .MakeName ("\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065");sig .SubFilter =_aeg .MakeName ("\u0061\u0064\u0062\u0065.p\u006b\u0063\u0073\u0037\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064");sig .Reference =nil ;_dbg ,_gdfa :=_gdf .NewDigest (sig );if _gdfa !=nil {return _gdfa ;};_dbg .Write ([]byte ("\u0063\u0061\u006c\u0063\u0075\u006ca\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0043\u006f\u006e\u0074\u0065\u006et\u0073\u0020\u0066\u0069\u0065\u006c\u0064 \u0073\u0069\u007a\u0065"));return _gdf .Sign (sig ,_dbg );};func (_cf *adobeX509RSASHA1 )getCertificate (_ddb *_cc .PdfSignature )(*_dd .Certificate ,error ){if _cf ._gad !=nil {return _cf ._gad ,nil ;};var _ge []byte ;switch _ddcd :=_ddb .Cert .(type ){case *_aeg .PdfObjectString :_ge =_ddcd .Bytes ();case *_aeg .PdfObjectArray :if _ddcd .Len ()==0{return nil ,_f .New ("\u006e\u006f\u0020s\u0069\u0067\u006e\u0061t\u0075\u0072\u0065\u0020\u0063\u0065\u0072t\u0069\u0066\u0069\u0063\u0061\u0074\u0065\u0073\u0020\u0066\u006f\u0075\u006e\u0064");};for _ ,_eeg :=range _ddcd .Elements (){_gb ,_ff :=_aeg .GetString (_eeg );if !_ff {return nil ,_db .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0065\u0072\u0074\u0069\u0066\u0069\u0063\u0061\u0074\u0065\u0020\u006f\u0062j\u0065\u0063\u0074\u0020\u0074\u0079p\u0065\u0020\u0069\u006e\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065 \u0063\u0065r\u0074\u0069\u0066\u0069c\u0061\u0074\u0065\u0020\u0063h\u0061\u0069\u006e\u003a\u0020\u0025\u0054",_eeg );};_ge =append (_ge ,_gb .Bytes ()...);};default:return nil ,_db .Errorf ("\u0069n\u0076\u0061l\u0069\u0064\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072e\u0020\u0063\u0065\u0072\u0074\u0069f\u0069\u0063\u0061\u0074\u0065\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054",_ddcd );};_dgc ,_daa :=_dd .ParseCertificates (_ge );if _daa !=nil {return nil ,_daa ;};return _dgc [0],nil ;};

// Sign sets the Contents fields for the PdfSignature.
func (_gga *docTimeStamp )Sign (sig *_cc .PdfSignature ,digest _cc .Hasher )error {_egf :=digest .(*_d .Buffer );_bef :=_gga ._ebd .New ();if _ ,_aedf :=_c .Copy (_bef ,_egf );_aedf !=nil {return _aedf ;};_gbg :=_bef .Sum (nil );_adf :=_ca .Request {HashAlgorithm :_gga ._ebd ,HashedMessage :_gbg ,Certificates :true ,Extensions :nil ,ExtraExtensions :nil };_gfe ,_efc :=_adf .Marshal ();if _efc !=nil {return _efc ;};_adbd ,_efc :=_g .Post (_gga ._ffb ,"a\u0070\u0070\u006c\u0069\u0063\u0061t\u0069\u006f\u006e\u002f\u0074\u0069\u006d\u0065\u0073t\u0061\u006d\u0070-\u0071u\u0065\u0072\u0079",_d .NewBuffer (_gfe ));if _efc !=nil {return _efc ;};defer _adbd .Body .Close ();_acc ,_efc :=_ed .ReadAll (_adbd .Body );if _efc !=nil {return _efc ;};if _adbd .StatusCode !=_g .StatusOK {return _db .Errorf ("\u0068\u0074\u0074\u0070\u0020\u0073\u0074\u0061\u0074\u0075\u0073\u0020\u0063\u006f\u0064e\u0020n\u006f\u0074\u0020\u006f\u006b\u0020\u0028\u0067\u006f\u0074\u0020\u0025\u0064\u0029",_adbd .StatusCode );};var _egd struct{Version _cb .RawValue ;Content _cb .RawValue ;};_ ,_efc =_cb .Unmarshal (_acc ,&_egd );if _efc !=nil {return _efc ;};sig .Contents =_aeg .MakeHexString (string (_egd .Content .FullBytes ));return nil ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature.
func (_cbe *adobeX509RSASHA1 )IsApplicable (sig *_cc .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0061d\u0062e\u002e\u0078\u0035\u0030\u0039.\u0072\u0073a\u005f\u0073\u0068\u0061\u0031";};

// Sign sets the Contents fields for the PdfSignature.
func (_gcd *adobeX509RSASHA1 )Sign (sig *_cc .PdfSignature ,digest _cc .Hasher )error {var _bff []byte ;var _fd error ;if _gcd ._ce !=nil {_bff ,_fd =_gcd ._ce (sig ,digest );if _fd !=nil {return _fd ;};}else {_bfaf ,_gca :=digest .(_eg .Hash );if !_gca {return _f .New ("\u0068a\u0073h\u0020\u0074\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_aba ,_ :=_bfc (_gcd ._gad .SignatureAlgorithm );_bff ,_fd =_ac .SignPKCS1v15 (_ga .Reader ,_gcd ._cca ,_aba ,_bfaf .Sum (nil ));if _fd !=nil {return _fd ;};};_bff ,_fd =_cb .Marshal (_bff );if _fd !=nil {return _fd ;};sig .Contents =_aeg .MakeHexString (string (_bff ));return nil ;};type timestampInfo struct{Version int ;Policy _cb .RawValue ;MessageImprint struct{HashAlgorithm _aa .AlgorithmIdentifier ;HashedMessage []byte ;};SerialNumber _cb .RawValue ;GeneralizedTime _e .Time ;};

// IsApplicable returns true if the signature handler is applicable for the PdfSignature
func (_ddc *adobePKCS7Detached )IsApplicable (sig *_cc .PdfSignature )bool {if sig ==nil ||sig .Filter ==nil ||sig .SubFilter ==nil {return false ;};return (*sig .Filter =="A\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004d\u0053"||*sig .Filter =="\u0041\u0064\u006f\u0062\u0065\u002e\u0050\u0050\u004b\u004c\u0069\u0074\u0065")&&*sig .SubFilter =="\u0061\u0064\u0062\u0065.p\u006b\u0063\u0073\u0037\u002e\u0064\u0065\u0074\u0061\u0063\u0068\u0065\u0064";};type adobePKCS7Detached struct{_ec *_ac .PrivateKey ;_gd *_dd .Certificate ;_fe bool ;_dbd int ;};func _bfc (_acdb _dd .SignatureAlgorithm )(_ae .Hash ,bool ){return _ae .SHA1 ,true };

// NewDocTimeStamp creates a new DocTimeStamp signature handler.
// The timestampServerURL parameter can be empty string for the signature validation.
// The hashAlgorithm parameter can be crypto.SHA1, crypto.SHA256, crypto.SHA384, crypto.SHA512.
func NewDocTimeStamp (timestampServerURL string ,hashAlgorithm _ae .Hash )(_cc .SignatureHandler ,error ){return &docTimeStamp {_ffb :timestampServerURL ,_ebd :hashAlgorithm },nil ;};

// Sign sets the Contents fields.
func (_bd *adobePKCS7Detached )Sign (sig *_cc .PdfSignature ,digest _cc .Hasher )error {if _bd ._fe {_acd :=_bd ._dbd ;if _acd <=0{_acd =8192;};sig .Contents =_aeg .MakeHexString (string (make ([]byte ,_acd )));return nil ;};_gfd :=digest .(*_d .Buffer );_ab ,_bdf :=_gc .NewSignedData (_gfd .Bytes ());if _bdf !=nil {return _bdf ;};if _fa :=_ab .AddSigner (_bd ._gd ,_bd ._ec ,_gc .SignerInfoConfig {});_fa !=nil {return _fa ;};_ab .Detach ();_bf ,_bdf :=_ab .Finish ();if _bdf !=nil {return _bdf ;};_da :=make ([]byte ,8192);copy (_da ,_bf );sig .Contents =_aeg .MakeHexString (string (_da ));return nil ;};

// NewEmptyAdobePKCS7Detached creates a new Adobe.PPKMS/Adobe.PPKLite adbe.pkcs7.detached
// signature handler. The generated signature is empty and of size signatureLen.
// The signatureLen parameter can be 0 for the signature validation.
func NewEmptyAdobePKCS7Detached (signatureLen int )(_cc .SignatureHandler ,error ){return &adobePKCS7Detached {_fe :true ,_dbd :signatureLen },nil ;};