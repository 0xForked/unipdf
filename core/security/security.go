//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package security ;import (_b "bytes";_gf "crypto/aes";_d "crypto/cipher";_dga "crypto/md5";_dc "crypto/rand";_ab "crypto/rc4";_g "crypto/sha256";_c "crypto/sha512";_cc "encoding/binary";_e "errors";_gd "fmt";_ec "github.com/unidoc/unipdf/v3/common";_a "hash";
_dg "io";_abb "math";);func _cac (_fb _d .Block )_d .BlockMode {return (*ecbEncrypter )(_gg (_fb ))};func (_bb *ecbDecrypter )CryptBlocks (dst ,src []byte ){if len (src )%_bb ._ee !=0{_ec .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_ec .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0064\u0065\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_bb ._ca .Decrypt (dst ,src [:_bb ._ee ]);src =src [_bb ._ee :];dst =dst [_bb ._ee :];};};const (PermOwner =Permissions (_abb .MaxUint32 );PermPrinting =Permissions (1<<2);PermModify =Permissions (1<<3);PermExtractGraphics =Permissions (1<<4);
PermAnnotate =Permissions (1<<5);PermFillForms =Permissions (1<<8);PermDisabilityExtract =Permissions (1<<9);PermRotateInsert =Permissions (1<<10);PermFullPrintQuality =Permissions (1<<11););func (_ac *ecbEncrypter )BlockSize ()int {return _ac ._ee };type stdHandlerR6 struct{};
func _bd (_de _d .Block )_d .BlockMode {return (*ecbDecrypter )(_gg (_de ))};const _af ="\x28\277\116\136\x4e\x75\x8a\x41\x64\000\x4e\x56\377"+"\xfa\001\010\056\x2e\x00\xb6\xd0\x68\076\x80\x2f\014"+"\251\xfe\x64\x53\x69\172";type ecbEncrypter ecb ;type errInvalidField struct{Func string ;
Field string ;Exp int ;Got int ;};func _cb (_cf ,_ecf string ,_ge int ,_ef []byte )error {if len (_ef )< _ge {return errInvalidField {Func :_cf ,Field :_ecf ,Exp :_ge ,Got :len (_ef )};};return nil ;};

// StdHandler is an interface for standard security handlers.
type StdHandler interface{

// GenerateParams uses owner and user passwords to set encryption parameters and generate an encryption key.
// It assumes that R, P and EncryptMetadata are already set.
GenerateParams (_ce *StdEncryptDict ,_cad ,_db []byte )([]byte ,error );

// Authenticate uses encryption dictionary parameters and the password to calculate
// the document encryption key. It also returns permissions that should be granted to a user.
// In case of failed authentication, it returns empty key and zero permissions with no error.
Authenticate (_acd *StdEncryptDict ,_ded []byte )([]byte ,Permissions ,error );};func _gg (_gfa _d .Block )*ecb {return &ecb {_ca :_gfa ,_ee :_gfa .BlockSize ()}};func (_bgdf stdHandlerR6 )alg11 (_dfgb *StdEncryptDict ,_afdd []byte )([]byte ,error ){if _baa :=_cb ("\u0061\u006c\u00671\u0031","\u0055",48,_dfgb .U );
_baa !=nil {return nil ,_baa ;};_beg :=make ([]byte ,len (_afdd )+8);_dagg :=copy (_beg ,_afdd );_dagg +=copy (_beg [_dagg :],_dfgb .U [32:40]);_cdd ,_becf :=_bgdf .alg2b (_dfgb .R ,_beg ,_afdd ,nil );if _becf !=nil {return nil ,_becf ;};_cdd =_cdd [:32];
if !_b .Equal (_cdd ,_dfgb .U [:32]){return nil ,nil ;};return _cdd ,nil ;};func (_bec stdHandlerR4 )alg5 (_gdae []byte ,_bee []byte )([]byte ,error ){_fac :=_dga .New ();_fac .Write ([]byte (_af ));_fac .Write ([]byte (_bec .ID0 ));_fg :=_fac .Sum (nil );
_ec .Log .Trace ("\u0061\u006c\u0067\u0035");_ec .Log .Trace ("\u0065k\u0065\u0079\u003a\u0020\u0025\u0020x",_gdae );_ec .Log .Trace ("\u0049D\u003a\u0020\u0025\u0020\u0078",_bec .ID0 );if len (_fg )!=16{return nil ,_e .New ("\u0068a\u0073\u0068\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074\u0020\u0031\u0036\u0020\u0062\u0079\u0074\u0065\u0073");
};_bg ,_caf :=_ab .NewCipher (_gdae );if _caf !=nil {return nil ,_e .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_bfd :=make ([]byte ,16);_bg .XORKeyStream (_bfd ,_fg );_fbf :=make ([]byte ,len (_gdae ));for _fcg :=0;
_fcg < 19;_fcg ++{for _fbg :=0;_fbg < len (_gdae );_fbg ++{_fbf [_fbg ]=_gdae [_fbg ]^byte (_fcg +1);};_bg ,_caf =_ab .NewCipher (_fbf );if _caf !=nil {return nil ,_e .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_bg .XORKeyStream (_bfd ,_bfd );_ec .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u002c\u0020\u0065\u006b\u0065\u0079:\u0020\u0025\u0020\u0078",_fcg ,_fbf );_ec .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0020\u0078",_fcg ,_bfd );
};_eff :=make ([]byte ,32);for _bed :=0;_bed < 16;_bed ++{_eff [_bed ]=_bfd [_bed ];};_ ,_caf =_dc .Read (_eff [16:32]);if _caf !=nil {return nil ,_e .New ("\u0066a\u0069\u006c\u0065\u0064 \u0074\u006f\u0020\u0067\u0065n\u0020r\u0061n\u0064\u0020\u006e\u0075\u006d\u0062\u0065r");
};return _eff ,nil ;};func (_gfg stdHandlerR6 )alg2a (_ddb *StdEncryptDict ,_agb []byte )([]byte ,Permissions ,error ){if _dec :=_cb ("\u0061\u006c\u00672\u0061","\u004f",48,_ddb .O );_dec !=nil {return nil ,0,_dec ;};if _eea :=_cb ("\u0061\u006c\u00672\u0061","\u0055",48,_ddb .U );
_eea !=nil {return nil ,0,_eea ;};if len (_agb )> 127{_agb =_agb [:127];};_ea ,_dfb :=_gfg .alg12 (_ddb ,_agb );if _dfb !=nil {return nil ,0,_dfb ;};var (_ccg []byte ;_cbd []byte ;_gad []byte ;);var _ffa Permissions ;if len (_ea )!=0{_ffa =PermOwner ;_ede :=make ([]byte ,len (_agb )+8+48);
_cbb :=copy (_ede ,_agb );_cbb +=copy (_ede [_cbb :],_ddb .O [40:48]);copy (_ede [_cbb :],_ddb .U [0:48]);_ccg =_ede ;_cbd =_ddb .OE ;_gad =_ddb .U [0:48];}else {_ea ,_dfb =_gfg .alg11 (_ddb ,_agb );if _dfb ==nil &&len (_ea )==0{_ea ,_dfb =_gfg .alg11 (_ddb ,[]byte (""));
};if _dfb !=nil {return nil ,0,_dfb ;}else if len (_ea )==0{return nil ,0,nil ;};_ffa =_ddb .P ;_dad :=make ([]byte ,len (_agb )+8);_dfg :=copy (_dad ,_agb );copy (_dad [_dfg :],_ddb .U [40:48]);_ccg =_dad ;_cbd =_ddb .UE ;_gad =nil ;};if _cgcb :=_cb ("\u0061\u006c\u00672\u0061","\u004b\u0065\u0079",32,_cbd );
_cgcb !=nil {return nil ,0,_cgcb ;};_cbd =_cbd [:32];_gdaf ,_dfb :=_gfg .alg2b (_ddb .R ,_ccg ,_agb ,_gad );if _dfb !=nil {return nil ,0,_dfb ;};_ggf ,_dfb :=_gf .NewCipher (_gdaf [:32]);if _dfb !=nil {return nil ,0,_dfb ;};_ccdc :=make ([]byte ,_gf .BlockSize );
_ecgc :=_d .NewCBCDecrypter (_ggf ,_ccdc );_dac :=make ([]byte ,32);_ecgc .CryptBlocks (_dac ,_cbd );if _ddb .R ==5{return _dac ,_ffa ,nil ;};_dfb =_gfg .alg13 (_ddb ,_dac );if _dfb !=nil {return nil ,0,_dfb ;};return _dac ,_ffa ,nil ;};func (_gae stdHandlerR6 )alg10 (_fgc *StdEncryptDict ,_cgf []byte )error {if _cgfd :=_cb ("\u0061\u006c\u00671\u0030","\u004b\u0065\u0079",32,_cgf );
_cgfd !=nil {return _cgfd ;};_aagd :=uint64 (uint32 (_fgc .P ))|(_abb .MaxUint32 <<32);Perms :=make ([]byte ,16);_cc .LittleEndian .PutUint64 (Perms [:8],_aagd );if _fgc .EncryptMetadata {Perms [8]='T';}else {Perms [8]='F';};copy (Perms [9:12],"\u0061\u0064\u0062");
if _ ,_gaea :=_dg .ReadFull (_dc .Reader ,Perms [12:16]);_gaea !=nil {return _gaea ;};_fdd ,_ebd :=_ae (_cgf [:32]);if _ebd !=nil {return _ebd ;};_ega :=_cac (_fdd );_ega .CryptBlocks (Perms ,Perms );_fgc .Perms =Perms [:16];return nil ;};

// Allowed checks if a set of permissions can be granted.
func (_cg Permissions )Allowed (p2 Permissions )bool {return _cg &p2 ==p2 };

// GenerateParams generates and sets O and U parameters for the encryption dictionary.
// It expects R, P and EncryptMetadata fields to be set.
func (_ed stdHandlerR4 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){O ,_aag :=_ed .alg3 (d .R ,upass ,opass );if _aag !=nil {_ec .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_aag );
return nil ,_aag ;};d .O =O ;_ec .Log .Trace ("\u0067\u0065\u006e\u0020\u004f\u003a\u0020\u0025\u0020\u0078",O );_gb :=_ed .alg2 (d ,upass );U ,_aag :=_ed .alg5 (_gb ,upass );if _aag !=nil {_ec .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_aag );
return nil ,_aag ;};d .U =U ;_ec .Log .Trace ("\u0067\u0065\u006e\u0020\u0055\u003a\u0020\u0025\u0020\u0078",U );return _gb ,nil ;};func (_ga stdHandlerR4 )alg3Key (R int ,_eb []byte )[]byte {_fd :=_dga .New ();_geg :=_ga .paddedPass (_eb );_fd .Write (_geg );
if R >=3{for _gdb :=0;_gdb < 50;_gdb ++{_ceeb :=_fd .Sum (nil );_fd =_dga .New ();_fd .Write (_ceeb );};};_gee :=_fd .Sum (nil );if R ==2{_gee =_gee [0:5];}else {_gee =_gee [0:_ga .Length /8];};return _gee ;};func _cfe (_gcc []byte )([]byte ,error ){_bfc :=_g .New ();
_bfc .Write (_gcc );return _bfc .Sum (nil ),nil };

// AuthEvent is an event type that triggers authentication.
type AuthEvent string ;func (_bgd stdHandlerR4 )alg6 (_eeg *StdEncryptDict ,_bgb []byte )([]byte ,error ){var (_gebb []byte ;_bea error ;);_fde :=_bgd .alg2 (_eeg ,_bgb );if _eeg .R ==2{_gebb ,_bea =_bgd .alg4 (_fde ,_bgb );}else if _eeg .R >=3{_gebb ,_bea =_bgd .alg5 (_fde ,_bgb );
}else {return nil ,_e .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};if _bea !=nil {return nil ,_bea ;};_ec .Log .Trace ("\u0063\u0068\u0065\u0063k:\u0020\u0025\u0020\u0078\u0020\u003d\u003d\u0020\u0025\u0020\u0078\u0020\u003f",string (_gebb ),string (_eeg .U ));
_eef :=_gebb ;_dgbb :=_eeg .U ;if _eeg .R >=3{if len (_eef )> 16{_eef =_eef [0:16];};if len (_dgbb )> 16{_dgbb =_dgbb [0:16];};};if !_b .Equal (_eef ,_dgbb ){return nil ,nil ;};return _fde ,nil ;};

// StdEncryptDict is a set of additional fields used in standard encryption dictionary.
type StdEncryptDict struct{R int ;P Permissions ;EncryptMetadata bool ;O ,U []byte ;OE ,UE []byte ;Perms []byte ;};const (EventDocOpen =AuthEvent ("\u0044o\u0063\u004f\u0070\u0065\u006e");EventEFOpen =AuthEvent ("\u0045\u0046\u004f\u0070\u0065\u006e");
);func (_ebc stdHandlerR6 )alg2b (R int ,_gdf ,_ecab ,_gbc []byte )([]byte ,error ){if R ==5{return _cfe (_gdf );};return _ade (_gdf ,_ecab ,_gbc );};func (_cdc stdHandlerR6 )alg13 (_fec *StdEncryptDict ,_gdbd []byte )error {if _cff :=_cb ("\u0061\u006c\u00671\u0033","\u004b\u0065\u0079",32,_gdbd );
_cff !=nil {return _cff ;};if _cab :=_cb ("\u0061\u006c\u00671\u0033","\u0050\u0065\u0072m\u0073",16,_fec .Perms );_cab !=nil {return _cab ;};_gfgf :=make ([]byte ,16);copy (_gfgf ,_fec .Perms [:16]);_ebfc ,_cafg :=_gf .NewCipher (_gdbd [:32]);if _cafg !=nil {return _cafg ;
};_fea :=_bd (_ebfc );_fea .CryptBlocks (_gfgf ,_gfgf );if !_b .Equal (_gfgf [9:12],[]byte ("\u0061\u0064\u0062")){return _e .New ("\u0064\u0065\u0063o\u0064\u0065\u0064\u0020p\u0065\u0072\u006d\u0069\u0073\u0073\u0069o\u006e\u0073\u0020\u0061\u0072\u0065\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};_dba :=Permissions (_cc .LittleEndian .Uint32 (_gfgf [0:4]));if _dba !=_fec .P {return _e .New ("\u0070\u0065r\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066\u0061il\u0065\u0064");
};var _ddbd bool ;if _gfgf [8]=='T'{_ddbd =true ;}else if _gfgf [8]=='F'{_ddbd =false ;}else {return _e .New ("\u0064\u0065\u0063\u006f\u0064\u0065\u0064 \u006d\u0065\u0074a\u0064\u0061\u0074\u0061 \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u006c\u0061\u0067\u0020\u0069\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};if _ddbd !=_fec .EncryptMetadata {return _e .New ("\u006d\u0065t\u0061\u0064\u0061\u0074a\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e \u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066a\u0069\u006c\u0065\u0064");
};return nil ;};

// Authenticate implements StdHandler interface.
func (_fag stdHandlerR4 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){_ec .Log .Trace ("\u0044\u0065b\u0075\u0067\u0067\u0069n\u0067\u0020a\u0075\u0074\u0068\u0065\u006e\u0074\u0069\u0063a\u0074\u0069\u006f\u006e\u0020\u002d\u0020\u006f\u0077\u006e\u0065\u0072 \u0070\u0061\u0073\u0073");
_afd ,_ecg :=_fag .alg7 (d ,pass );if _ecg !=nil {return nil ,0,_ecg ;};if _afd !=nil {_ec .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _afd ,PermOwner ,nil ;
};_ec .Log .Trace ("\u0044\u0065bu\u0067\u0067\u0069n\u0067\u0020\u0061\u0075the\u006eti\u0063\u0061\u0074\u0069\u006f\u006e\u0020- \u0075\u0073\u0065\u0072\u0020\u0070\u0061s\u0073");_afd ,_ecg =_fag .alg6 (d ,pass );if _ecg !=nil {return nil ,0,_ecg ;
};if _afd !=nil {_ec .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _afd ,d .P ,nil ;};return nil ,0,nil ;};func _ae (_dd []byte )(_d .Block ,error ){_gc ,_da :=_gf .NewCipher (_dd );
if _da !=nil {_ec .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0063\u0072\u0065\u0061\u0074\u0065\u0020A\u0045\u0053\u0020\u0063\u0069p\u0068\u0065r\u003a\u0020\u0025\u0076",_da );
return nil ,_da ;};return _gc ,nil ;};func _ade (_egb ,_fgf ,_def []byte )([]byte ,error ){var (_fba ,_beb ,_fcgc _a .Hash ;);_fba =_g .New ();_fcd :=make ([]byte ,64);_bfg :=_fba ;_bfg .Write (_egb );K :=_bfg .Sum (_fcd [:0]);_ebf :=make ([]byte ,64*(127+64+48));
_edb :=func (_dcge int )([]byte ,error ){_ffc :=len (_fgf )+len (K )+len (_def );_fdg :=_ebf [:_ffc ];_aee :=copy (_fdg ,_fgf );_aee +=copy (_fdg [_aee :],K [:]);_aee +=copy (_fdg [_aee :],_def );if _aee !=_ffc {_ec .Log .Error ("E\u0052\u0052\u004f\u0052\u003a\u0020u\u006e\u0065\u0078\u0070\u0065\u0063t\u0065\u0064\u0020\u0072\u006f\u0075\u006ed\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0073\u0069\u007ae\u002e");
return nil ,_e .New ("\u0077\u0072\u006f\u006e\u0067\u0020\u0073\u0069\u007a\u0065");};K1 :=_ebf [:_ffc *64];_ad (K1 ,_ffc );_fcag ,_dedb :=_ae (K [0:16]);if _dedb !=nil {return nil ,_dedb ;};_ggb :=_d .NewCBCEncrypter (_fcag ,K [16:32]);_ggb .CryptBlocks (K1 ,K1 );
E :=K1 ;_dag :=0;for _dfbc :=0;_dfbc < 16;_dfbc ++{_dag +=int (E [_dfbc ]%3);};var _ggd _a .Hash ;switch _dag %3{case 0:_ggd =_fba ;case 1:if _beb ==nil {_beb =_c .New384 ();};_ggd =_beb ;case 2:if _fcgc ==nil {_fcgc =_c .New ();};_ggd =_fcgc ;};_ggd .Reset ();
_ggd .Write (E );K =_ggd .Sum (_fcd [:0]);return E ,nil ;};for _cba :=0;;{E ,_dgad :=_edb (_cba );if _dgad !=nil {return nil ,_dgad ;};_abbf :=E [len (E )-1];_cba ++;if _cba >=64&&_abbf <=uint8 (_cba -32){break ;};};return K [:32],nil ;};func (_bgf stdHandlerR4 )alg7 (_efe *StdEncryptDict ,_bef []byte )([]byte ,error ){_age :=_bgf .alg3Key (_efe .R ,_bef );
_ff :=make ([]byte ,len (_efe .O ));if _efe .R ==2{_bgc ,_dfa :=_ab .NewCipher (_age );if _dfa !=nil {return nil ,_e .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_bgc .XORKeyStream (_ff ,_efe .O );}else if _efe .R >=3{_aae :=append ([]byte {},_efe .O ...);
for _bfe :=0;_bfe < 20;_bfe ++{_dcgc :=append ([]byte {},_age ...);for _dgg :=0;_dgg < len (_age );_dgg ++{_dcgc [_dgg ]^=byte (19-_bfe );};_dcba ,_dbg :=_ab .NewCipher (_dcgc );if _dbg !=nil {return nil ,_e .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");
};_dcba .XORKeyStream (_ff ,_aae );_aae =append ([]byte {},_ff ...);};}else {return nil ,_e .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};_fad ,_ccc :=_bgf .alg6 (_efe ,_ff );if _ccc !=nil {return nil ,nil ;};return _fad ,nil ;};type ecb struct{_ca _d .Block ;
_ee int ;};var _ StdHandler =stdHandlerR6 {};func (_dgb *ecbEncrypter )CryptBlocks (dst ,src []byte ){if len (src )%_dgb ._ee !=0{_ec .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_ec .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_dgb ._ca .Encrypt (dst ,src [:_dgb ._ee ]);src =src [_dgb ._ee :];dst =dst [_dgb ._ee :];};};

// NewHandlerR6 creates a new standard security handler for R=5 and R=6.
func NewHandlerR6 ()StdHandler {return stdHandlerR6 {}};type ecbDecrypter ecb ;type stdHandlerR4 struct{Length int ;ID0 string ;};func (_eg stdHandlerR4 )alg2 (_aa *StdEncryptDict ,_ecc []byte )[]byte {_ec .Log .Trace ("\u0061\u006c\u0067\u0032");_eca :=_eg .paddedPass (_ecc );
_geb :=_dga .New ();_geb .Write (_eca );_geb .Write (_aa .O );var _fc [4]byte ;_cc .LittleEndian .PutUint32 (_fc [:],uint32 (_aa .P ));_geb .Write (_fc [:]);_ec .Log .Trace ("\u0067o\u0020\u0050\u003a\u0020\u0025\u0020x",_fc );_geb .Write ([]byte (_eg .ID0 ));
_ec .Log .Trace ("\u0074\u0068\u0069\u0073\u002e\u0052\u0020\u003d\u0020\u0025d\u0020\u0065\u006e\u0063\u0072\u0079\u0070t\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061\u0020\u0025\u0076",_aa .R ,_aa .EncryptMetadata );if (_aa .R >=4)&&!_aa .EncryptMetadata {_geb .Write ([]byte {0xff,0xff,0xff,0xff});
};_dgc :=_geb .Sum (nil );if _aa .R >=3{_geb =_dga .New ();for _fa :=0;_fa < 50;_fa ++{_geb .Reset ();_geb .Write (_dgc [0:_eg .Length /8]);_dgc =_geb .Sum (nil );};};if _aa .R >=3{return _dgc [0:_eg .Length /8];};return _dgc [0:5];};func (_fca stdHandlerR4 )alg4 (_bf []byte ,_gda []byte )([]byte ,error ){_fe ,_bbf :=_ab .NewCipher (_bf );
if _bbf !=nil {return nil ,_e .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_gdd :=[]byte (_af );_dbc :=make ([]byte ,len (_gdd ));_fe .XORKeyStream (_dbc ,_gdd );return _dbc ,nil ;};func (stdHandlerR4 )paddedPass (_be []byte )[]byte {_cee :=make ([]byte ,32);
_dgbe :=copy (_cee ,_be );for ;_dgbe < 32;_dgbe ++{_cee [_dgbe ]=_af [_dgbe -len (_be )];};return _cee ;};func (_dbca stdHandlerR6 )alg12 (_cafd *StdEncryptDict ,_gef []byte )([]byte ,error ){if _bc :=_cb ("\u0061\u006c\u00671\u0032","\u0055",48,_cafd .U );
_bc !=nil {return nil ,_bc ;};if _bde :=_cb ("\u0061\u006c\u00671\u0032","\u004f",48,_cafd .O );_bde !=nil {return nil ,_bde ;};_baab :=make ([]byte ,len (_gef )+8+48);_cdg :=copy (_baab ,_gef );_cdg +=copy (_baab [_cdg :],_cafd .O [32:40]);_cdg +=copy (_baab [_cdg :],_cafd .U [0:48]);
_dff ,_ffag :=_dbca .alg2b (_cafd .R ,_baab ,_gef ,_cafd .U [0:48]);if _ffag !=nil {return nil ,_ffag ;};_dff =_dff [:32];if !_b .Equal (_dff ,_cafd .O [:32]){return nil ,nil ;};return _dff ,nil ;};func (_ced stdHandlerR6 )alg8 (_gbb *StdEncryptDict ,_daca []byte ,_eed []byte )error {if _eee :=_cb ("\u0061\u006c\u0067\u0038","\u004b\u0065\u0079",32,_daca );
_eee !=nil {return _eee ;};var _abbb [16]byte ;if _ ,_cgg :=_dg .ReadFull (_dc .Reader ,_abbb [:]);_cgg !=nil {return _cgg ;};_gce :=_abbb [0:8];_cbe :=_abbb [8:16];_bgdc :=make ([]byte ,len (_eed )+len (_gce ));_aed :=copy (_bgdc ,_eed );copy (_bgdc [_aed :],_gce );
_fcc ,_eeb :=_ced .alg2b (_gbb .R ,_bgdc ,_eed ,nil );if _eeb !=nil {return _eeb ;};U :=make ([]byte ,len (_fcc )+len (_gce )+len (_cbe ));_aed =copy (U ,_fcc [:32]);_aed +=copy (U [_aed :],_gce );copy (U [_aed :],_cbe );_gbb .U =U ;_aed =len (_eed );copy (_bgdc [_aed :],_cbe );
_fcc ,_eeb =_ced .alg2b (_gbb .R ,_bgdc ,_eed ,nil );if _eeb !=nil {return _eeb ;};_ada ,_eeb :=_ae (_fcc [:32]);if _eeb !=nil {return _eeb ;};_eae :=make ([]byte ,_gf .BlockSize );_eeeg :=_d .NewCBCEncrypter (_ada ,_eae );UE :=make ([]byte ,32);_eeeg .CryptBlocks (UE ,_daca [:32]);
_gbb .UE =UE ;return nil ;};var _ StdHandler =stdHandlerR4 {};func (_cd stdHandlerR4 )alg3 (R int ,_cgc ,_ag []byte )([]byte ,error ){var _bdb []byte ;if len (_ag )> 0{_bdb =_cd .alg3Key (R ,_ag );}else {_bdb =_cd .alg3Key (R ,_cgc );};_df ,_fbe :=_ab .NewCipher (_bdb );
if _fbe !=nil {return nil ,_e .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_acb :=_cd .paddedPass (_cgc );_ceg :=make ([]byte ,len (_acb ));_df .XORKeyStream (_ceg ,_acb );if R >=3{_ccd :=make ([]byte ,len (_bdb ));
for _cfb :=0;_cfb < 19;_cfb ++{for _ecce :=0;_ecce < len (_bdb );_ecce ++{_ccd [_ecce ]=_bdb [_ecce ]^byte (_cfb +1);};_ged ,_ba :=_ab .NewCipher (_ccd );if _ba !=nil {return nil ,_e .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_ged .XORKeyStream (_ceg ,_ceg );};};return _ceg ,nil ;};

// GenerateParams is the algorithm opposite to alg2a (R>=5).
// It generates U,O,UE,OE,Perms fields using AESv3 encryption.
// There is no algorithm number assigned to this function in the spec.
// It expects R, P and EncryptMetadata fields to be set.
func (_caga stdHandlerR6 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){_dbb :=make ([]byte ,32);if _ ,_abf :=_dg .ReadFull (_dc .Reader ,_dbb );_abf !=nil {return nil ,_abf ;};d .U =nil ;d .O =nil ;d .UE =nil ;d .OE =nil ;d .Perms =nil ;
if len (upass )> 127{upass =upass [:127];};if len (opass )> 127{opass =opass [:127];};if _gfag :=_caga .alg8 (d ,_dbb ,upass );_gfag !=nil {return nil ,_gfag ;};if _fed :=_caga .alg9 (d ,_dbb ,opass );_fed !=nil {return nil ,_fed ;};if d .R ==5{return _dbb ,nil ;
};if _ddc :=_caga .alg10 (d ,_dbb );_ddc !=nil {return nil ,_ddc ;};return _dbb ,nil ;};func _ad (_abg []byte ,_deg int ){_cag :=_deg ;for _cag < len (_abg ){copy (_abg [_cag :],_abg [:_cag ]);_cag *=2;};};func (_dcb errInvalidField )Error ()string {return _gd .Sprintf ("\u0025s\u003a\u0020e\u0078\u0070\u0065\u0063t\u0065\u0064\u0020%\u0073\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0074o \u0062\u0065\u0020%\u0064\u0020b\u0079\u0074\u0065\u0073\u002c\u0020g\u006f\u0074 \u0025\u0064",_dcb .Func ,_dcb .Field ,_dcb .Exp ,_dcb .Got );
};func (_aec stdHandlerR6 )alg9 (_eeba *StdEncryptDict ,_eccee []byte ,_acc []byte )error {if _dcd :=_cb ("\u0061\u006c\u0067\u0039","\u004b\u0065\u0079",32,_eccee );_dcd !=nil {return _dcd ;};if _bgcf :=_cb ("\u0061\u006c\u0067\u0039","\u0055",48,_eeba .U );
_bgcf !=nil {return _bgcf ;};var _gca [16]byte ;if _ ,_bged :=_dg .ReadFull (_dc .Reader ,_gca [:]);_bged !=nil {return _bged ;};_bac :=_gca [0:8];_bdbf :=_gca [8:16];_bgea :=_eeba .U [:48];_fgb :=make ([]byte ,len (_acc )+len (_bac )+len (_bgea ));_gab :=copy (_fgb ,_acc );
_gab +=copy (_fgb [_gab :],_bac );_gab +=copy (_fgb [_gab :],_bgea );_cge ,_fge :=_aec .alg2b (_eeba .R ,_fgb ,_acc ,_bgea );if _fge !=nil {return _fge ;};O :=make ([]byte ,len (_cge )+len (_bac )+len (_bdbf ));_gab =copy (O ,_cge [:32]);_gab +=copy (O [_gab :],_bac );
_gab +=copy (O [_gab :],_bdbf );_eeba .O =O ;_gab =len (_acc );_gab +=copy (_fgb [_gab :],_bdbf );_cge ,_fge =_aec .alg2b (_eeba .R ,_fgb ,_acc ,_bgea );if _fge !=nil {return _fge ;};_edbf ,_fge :=_ae (_cge [:32]);if _fge !=nil {return _fge ;};_ceeba :=make ([]byte ,_gf .BlockSize );
_cae :=_d .NewCBCEncrypter (_edbf ,_ceeba );OE :=make ([]byte ,32);_cae .CryptBlocks (OE ,_eccee [:32]);_eeba .OE =OE ;return nil ;};

// NewHandlerR4 creates a new standard security handler for R<=4.
func NewHandlerR4 (id0 string ,length int )StdHandler {return stdHandlerR4 {ID0 :id0 ,Length :length }};

// Authenticate implements StdHandler interface.
func (_caea stdHandlerR6 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){return _caea .alg2a (d ,pass );};func (_gfe *ecbDecrypter )BlockSize ()int {return _gfe ._ee };

// Permissions is a bitmask of access permissions for a PDF file.
type Permissions uint32 ;