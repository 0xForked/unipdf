//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package security ;import (_fc "bytes";_ec "crypto/aes";_ea "crypto/cipher";_ed "crypto/md5";_c "crypto/rand";_ge "crypto/rc4";_gf "crypto/sha256";_f "crypto/sha512";_fe "encoding/binary";_b "errors";_ba "fmt";_ga "github.com/unidoc/unipdf/v3/common";_gd "hash";
_g "io";_cg "math";);func (_fee stdHandlerR6 )alg13 (_adb *StdEncryptDict ,_fgcd []byte )error {if _fddc :=_bbe ("\u0061\u006c\u00671\u0033","\u004b\u0065\u0079",32,_fgcd );_fddc !=nil {return _fddc ;};if _dbbb :=_bbe ("\u0061\u006c\u00671\u0033","\u0050\u0065\u0072m\u0073",16,_adb .Perms );
_dbbb !=nil {return _dbbb ;};_cac :=make ([]byte ,16);copy (_cac ,_adb .Perms [:16]);_cbd ,_cab :=_ec .NewCipher (_fgcd [:32]);if _cab !=nil {return _cab ;};_bgc :=_gfc (_cbd );_bgc .CryptBlocks (_cac ,_cac );if !_fc .Equal (_cac [9:12],[]byte ("\u0061\u0064\u0062")){return _b .New ("\u0064\u0065\u0063o\u0064\u0065\u0064\u0020p\u0065\u0072\u006d\u0069\u0073\u0073\u0069o\u006e\u0073\u0020\u0061\u0072\u0065\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};_dbde :=Permissions (_fe .LittleEndian .Uint32 (_cac [0:4]));if _dbde !=_adb .P {return _b .New ("\u0070\u0065r\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066\u0061il\u0065\u0064");
};var _eca bool ;if _cac [8]=='T'{_eca =true ;}else if _cac [8]=='F'{_eca =false ;}else {return _b .New ("\u0064\u0065\u0063\u006f\u0064\u0065\u0064 \u006d\u0065\u0074a\u0064\u0061\u0074\u0061 \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u006c\u0061\u0067\u0020\u0069\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};if _eca !=_adb .EncryptMetadata {return _b .New ("\u006d\u0065t\u0061\u0064\u0061\u0074a\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e \u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066a\u0069\u006c\u0065\u0064");
};return nil ;};func _gef (_ce _ea .Block )_ea .BlockMode {return (*ecbEncrypter )(_fa (_ce ))};type ecbEncrypter ecb ;

// Allowed checks if a set of permissions can be granted.
func (_gbd Permissions )Allowed (p2 Permissions )bool {return _gbd &p2 ==p2 };func (_fgb stdHandlerR4 )alg2 (_be *StdEncryptDict ,_gfad []byte )[]byte {_ga .Log .Trace ("\u0061\u006c\u0067\u0032");_bfg :=_fgb .paddedPass (_gfad );_bd :=_ed .New ();_bd .Write (_bfg );
_bd .Write (_be .O );var _gda [4]byte ;_fe .LittleEndian .PutUint32 (_gda [:],uint32 (_be .P ));_bd .Write (_gda [:]);_ga .Log .Trace ("\u0067o\u0020\u0050\u003a\u0020\u0025\u0020x",_gda );_bd .Write ([]byte (_fgb .ID0 ));_ga .Log .Trace ("\u0074\u0068\u0069\u0073\u002e\u0052\u0020\u003d\u0020\u0025d\u0020\u0065\u006e\u0063\u0072\u0079\u0070t\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061\u0020\u0025\u0076",_be .R ,_be .EncryptMetadata );
if (_be .R >=4)&&!_be .EncryptMetadata {_bd .Write ([]byte {0xff,0xff,0xff,0xff});};_ae :=_bd .Sum (nil );if _be .R >=3{_bd =_ed .New ();for _fcg :=0;_fcg < 50;_fcg ++{_bd .Reset ();_bd .Write (_ae [0:_fgb .Length /8]);_ae =_bd .Sum (nil );};};if _be .R >=3{return _ae [0:_fgb .Length /8];
};return _ae [0:5];};func (_cbf errInvalidField )Error ()string {return _ba .Sprintf ("\u0025s\u003a\u0020e\u0078\u0070\u0065\u0063t\u0065\u0064\u0020%\u0073\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0074o \u0062\u0065\u0020%\u0064\u0020b\u0079\u0074\u0065\u0073\u002c\u0020g\u006f\u0074 \u0025\u0064",_cbf .Func ,_cbf .Field ,_cbf .Exp ,_cbf .Got );
};const _bg ="\x28\277\116\136\x4e\x75\x8a\x41\x64\000\x4e\x56\377"+"\xfa\001\010\056\x2e\x00\xb6\xd0\x68\076\x80\x2f\014"+"\251\xfe\x64\x53\x69\172";

// StdEncryptDict is a set of additional fields used in standard encryption dictionary.
type StdEncryptDict struct{R int ;P Permissions ;EncryptMetadata bool ;O ,U []byte ;OE ,UE []byte ;Perms []byte ;};func (_eed stdHandlerR4 )alg6 (_cef *StdEncryptDict ,_aa []byte )([]byte ,error ){var (_afa []byte ;_ab error ;);_fbg :=_eed .alg2 (_cef ,_aa );
if _cef .R ==2{_afa ,_ab =_eed .alg4 (_fbg ,_aa );}else if _cef .R >=3{_afa ,_ab =_eed .alg5 (_fbg ,_aa );}else {return nil ,_b .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};if _ab !=nil {return nil ,_ab ;};_ga .Log .Trace ("\u0063\u0068\u0065\u0063k:\u0020\u0025\u0020\u0078\u0020\u003d\u003d\u0020\u0025\u0020\u0078\u0020\u003f",string (_afa ),string (_cef .U ));
_ca :=_afa ;_ffb :=_cef .U ;if _cef .R >=3{if len (_ca )> 16{_ca =_ca [0:16];};if len (_ffb )> 16{_ffb =_ffb [0:16];};};if !_fc .Equal (_ca ,_ffb ){return nil ,nil ;};return _fbg ,nil ;};

// Permissions is a bitmask of access permissions for a PDF file.
type Permissions uint32 ;func (_ggb stdHandlerR6 )alg9 (_gdf *StdEncryptDict ,_cea []byte ,_cfc []byte )error {if _gace :=_bbe ("\u0061\u006c\u0067\u0039","\u004b\u0065\u0079",32,_cea );_gace !=nil {return _gace ;};if _abf :=_bbe ("\u0061\u006c\u0067\u0039","\u0055",48,_gdf .U );
_abf !=nil {return _abf ;};var _dgb [16]byte ;if _ ,_abe :=_g .ReadFull (_c .Reader ,_dgb [:]);_abe !=nil {return _abe ;};_gab :=_dgb [0:8];_dad :=_dgb [8:16];_acg :=_gdf .U [:48];_edd :=make ([]byte ,len (_cfc )+len (_gab )+len (_acg ));_dcd :=copy (_edd ,_cfc );
_dcd +=copy (_edd [_dcd :],_gab );_dcd +=copy (_edd [_dcd :],_acg );_fea ,_cffce :=_ggb .alg2b (_gdf .R ,_edd ,_cfc ,_acg );if _cffce !=nil {return _cffce ;};O :=make ([]byte ,len (_fea )+len (_gab )+len (_dad ));_dcd =copy (O ,_fea [:32]);_dcd +=copy (O [_dcd :],_gab );
_dcd +=copy (O [_dcd :],_dad );_gdf .O =O ;_dcd =len (_cfc );_dcd +=copy (_edd [_dcd :],_dad );_fea ,_cffce =_ggb .alg2b (_gdf .R ,_edd ,_cfc ,_acg );if _cffce !=nil {return _cffce ;};_gddb ,_cffce :=_fdf (_fea [:32]);if _cffce !=nil {return _cffce ;};
_ffa :=make ([]byte ,_ec .BlockSize );_gabg :=_ea .NewCBCEncrypter (_gddb ,_ffa );OE :=make ([]byte ,32);_gabg .CryptBlocks (OE ,_cea [:32]);_gdf .OE =OE ;return nil ;};func _gfc (_cf _ea .Block )_ea .BlockMode {return (*ecbDecrypter )(_fa (_cf ))};func (_ddf stdHandlerR6 )alg8 (_cffb *StdEncryptDict ,_geec []byte ,_aaa []byte )error {if _def :=_bbe ("\u0061\u006c\u0067\u0038","\u004b\u0065\u0079",32,_geec );
_def !=nil {return _def ;};var _bcc [16]byte ;if _ ,_fcgd :=_g .ReadFull (_c .Reader ,_bcc [:]);_fcgd !=nil {return _fcgd ;};_cffc :=_bcc [0:8];_bfa :=_bcc [8:16];_gaca :=make ([]byte ,len (_aaa )+len (_cffc ));_cedg :=copy (_gaca ,_aaa );copy (_gaca [_cedg :],_cffc );
_cda ,_gefg :=_ddf .alg2b (_cffb .R ,_gaca ,_aaa ,nil );if _gefg !=nil {return _gefg ;};U :=make ([]byte ,len (_cda )+len (_cffc )+len (_bfa ));_cedg =copy (U ,_cda [:32]);_cedg +=copy (U [_cedg :],_cffc );copy (U [_cedg :],_bfa );_cffb .U =U ;_cedg =len (_aaa );
copy (_gaca [_cedg :],_bfa );_cda ,_gefg =_ddf .alg2b (_cffb .R ,_gaca ,_aaa ,nil );if _gefg !=nil {return _gefg ;};_cbcc ,_gefg :=_fdf (_cda [:32]);if _gefg !=nil {return _gefg ;};_ebf :=make ([]byte ,_ec .BlockSize );_fgc :=_ea .NewCBCEncrypter (_cbcc ,_ebf );
UE :=make ([]byte ,32);_fgc .CryptBlocks (UE ,_geec [:32]);_cffb .UE =UE ;return nil ;};

// AuthEvent is an event type that triggers authentication.
type AuthEvent string ;func (_cfd stdHandlerR6 )alg12 (_ccf *StdEncryptDict ,_gbc []byte )([]byte ,error ){if _abea :=_bbe ("\u0061\u006c\u00671\u0032","\u0055",48,_ccf .U );_abea !=nil {return nil ,_abea ;};if _aab :=_bbe ("\u0061\u006c\u00671\u0032","\u004f",48,_ccf .O );
_aab !=nil {return nil ,_aab ;};_eedg :=make ([]byte ,len (_gbc )+8+48);_dge :=copy (_eedg ,_gbc );_dge +=copy (_eedg [_dge :],_ccf .O [32:40]);_dge +=copy (_eedg [_dge :],_ccf .U [0:48]);_beg ,_fda :=_cfd .alg2b (_ccf .R ,_eedg ,_gbc ,_ccf .U [0:48]);
if _fda !=nil {return nil ,_fda ;};_beg =_beg [:32];if !_fc .Equal (_beg ,_ccf .O [:32]){return nil ,nil ;};return _beg ,nil ;};func _gbg (_abd ,_bgg ,_abg []byte )([]byte ,error ){var (_cffg ,_gbe ,_dae _gd .Hash ;);_cffg =_gf .New ();_fdgg :=make ([]byte ,64);
_dcb :=_cffg ;_dcb .Write (_abd );K :=_dcb .Sum (_fdgg [:0]);_bfe :=make ([]byte ,64*(127+64+48));_aed :=func (_gebe int )([]byte ,error ){_dea :=len (_bgg )+len (K )+len (_abg );_dbd :=_bfe [:_dea ];_efb :=copy (_dbd ,_bgg );_efb +=copy (_dbd [_efb :],K [:]);
_efb +=copy (_dbd [_efb :],_abg );if _efb !=_dea {_ga .Log .Error ("E\u0052\u0052\u004f\u0052\u003a\u0020u\u006e\u0065\u0078\u0070\u0065\u0063t\u0065\u0064\u0020\u0072\u006f\u0075\u006ed\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0073\u0069\u007ae\u002e");
return nil ,_b .New ("\u0077\u0072\u006f\u006e\u0067\u0020\u0073\u0069\u007a\u0065");};K1 :=_bfe [:_dea *64];_fbb (K1 ,_dea );_dcbe ,_gcf :=_fdf (K [0:16]);if _gcf !=nil {return nil ,_gcf ;};_dbb :=_ea .NewCBCEncrypter (_dcbe ,K [16:32]);_dbb .CryptBlocks (K1 ,K1 );
E :=K1 ;_edea :=0;for _febd :=0;_febd < 16;_febd ++{_edea +=int (E [_febd ]%3);};var _cce _gd .Hash ;switch _edea %3{case 0:_cce =_cffg ;case 1:if _gbe ==nil {_gbe =_f .New384 ();};_cce =_gbe ;case 2:if _dae ==nil {_dae =_f .New ();};_cce =_dae ;};_cce .Reset ();
_cce .Write (E );K =_cce .Sum (_fdgg [:0]);return E ,nil ;};for _eef :=0;;{E ,_fdd :=_aed (_eef );if _fdd !=nil {return nil ,_fdd ;};_fcgb :=E [len (E )-1];_eef ++;if _eef >=64&&_fcgb <=uint8 (_eef -32){break ;};};return K [:32],nil ;};var _ StdHandler =stdHandlerR6 {};
type ecbDecrypter ecb ;func _fa (_bf _ea .Block )*ecb {return &ecb {_gb :_bf ,_bb :_bf .BlockSize ()}};func _ef (_ege []byte )([]byte ,error ){_bbee :=_gf .New ();_bbee .Write (_ege );return _bbee .Sum (nil ),nil ;};

// Authenticate implements StdHandler interface.
func (_ccg stdHandlerR4 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){_ga .Log .Trace ("\u0044\u0065b\u0075\u0067\u0067\u0069n\u0067\u0020a\u0075\u0074\u0068\u0065\u006e\u0074\u0069\u0063a\u0074\u0069\u006f\u006e\u0020\u002d\u0020\u006f\u0077\u006e\u0065\u0072 \u0070\u0061\u0073\u0073");
_ced ,_bfgg :=_ccg .alg7 (d ,pass );if _bfgg !=nil {return nil ,0,_bfgg ;};if _ced !=nil {_ga .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _ced ,PermOwner ,nil ;
};_ga .Log .Trace ("\u0044\u0065bu\u0067\u0067\u0069n\u0067\u0020\u0061\u0075the\u006eti\u0063\u0061\u0074\u0069\u006f\u006e\u0020- \u0075\u0073\u0065\u0072\u0020\u0070\u0061s\u0073");_ced ,_bfgg =_ccg .alg6 (d ,pass );if _bfgg !=nil {return nil ,0,_bfgg ;
};if _ced !=nil {_ga .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _ced ,d .P ,nil ;};return nil ,0,nil ;};func (_fga stdHandlerR6 )alg2b (R int ,_ade ,_gee ,_cgfe []byte )([]byte ,error ){if R ==5{return _ef (_ade );
};return _gbg (_ade ,_gee ,_cgfe );};func (_bcd stdHandlerR4 )alg4 (_fcgc []byte ,_bde []byte )([]byte ,error ){_gg ,_acb :=_ge .NewCipher (_fcgc );if _acb !=nil {return nil ,_b .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_fd :=[]byte (_bg );_cfe :=make ([]byte ,len (_fd ));_gg .XORKeyStream (_cfe ,_fd );return _cfe ,nil ;};func (_ff *ecbEncrypter )CryptBlocks (dst ,src []byte ){if len (src )%_ff ._bb !=0{_ga .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_ga .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_ff ._gb .Encrypt (dst ,src [:_ff ._bb ]);src =src [_ff ._bb :];dst =dst [_ff ._bb :];};};func (_dbc stdHandlerR6 )alg11 (_adc *StdEncryptDict ,_gaf []byte )([]byte ,error ){if _gafa :=_bbe ("\u0061\u006c\u00671\u0031","\u0055",48,_adc .U );
_gafa !=nil {return nil ,_gafa ;};_agc :=make ([]byte ,len (_gaf )+8);_gebf :=copy (_agc ,_gaf );_gebf +=copy (_agc [_gebf :],_adc .U [32:40]);_gffd ,_gba :=_dbc .alg2b (_adc .R ,_agc ,_gaf ,nil );if _gba !=nil {return nil ,_gba ;};_gffd =_gffd [:32];if !_fc .Equal (_gffd ,_adc .U [:32]){return nil ,nil ;
};return _gffd ,nil ;};type stdHandlerR4 struct{Length int ;ID0 string ;};func (_a *ecbDecrypter )BlockSize ()int {return _a ._bb };func (_df stdHandlerR4 )alg3Key (R int ,_ee []byte )[]byte {_bc :=_ed .New ();_da :=_df .paddedPass (_ee );_bc .Write (_da );
if R >=3{for _gbdg :=0;_gbdg < 50;_gbdg ++{_edb :=_bc .Sum (nil );_bc =_ed .New ();_bc .Write (_edb );};};_baa :=_bc .Sum (nil );if R ==2{_baa =_baa [0:5];}else {_baa =_baa [0:_df .Length /8];};return _baa ;};

// GenerateParams is the algorithm opposite to alg2a (R>=5).
// It generates U,O,UE,OE,Perms fields using AESv3 encryption.
// There is no algorithm number assigned to this function in the spec.
// It expects R, P and EncryptMetadata fields to be set.
func (_cfce stdHandlerR6 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){_bab :=make ([]byte ,32);if _ ,_edf :=_g .ReadFull (_c .Reader ,_bab );_edf !=nil {return nil ,_edf ;};d .U =nil ;d .O =nil ;d .UE =nil ;d .OE =nil ;d .Perms =nil ;
if len (upass )> 127{upass =upass [:127];};if len (opass )> 127{opass =opass [:127];};if _cde :=_cfce .alg8 (d ,_bab ,upass );_cde !=nil {return nil ,_cde ;};if _caa :=_cfce .alg9 (d ,_bab ,opass );_caa !=nil {return nil ,_caa ;};if d .R ==5{return _bab ,nil ;
};if _gce :=_cfce .alg10 (d ,_bab );_gce !=nil {return nil ,_gce ;};return _bab ,nil ;};func (_ecef stdHandlerR6 )alg10 (_gaab *StdEncryptDict ,_fegd []byte )error {if _cad :=_bbe ("\u0061\u006c\u00671\u0030","\u004b\u0065\u0079",32,_fegd );_cad !=nil {return _cad ;
};_faed :=uint64 (uint32 (_gaab .P ))|(_cg .MaxUint32 <<32);Perms :=make ([]byte ,16);_fe .LittleEndian .PutUint64 (Perms [:8],_faed );if _gaab .EncryptMetadata {Perms [8]='T';}else {Perms [8]='F';};copy (Perms [9:12],"\u0061\u0064\u0062");if _ ,_deb :=_g .ReadFull (_c .Reader ,Perms [12:16]);
_deb !=nil {return _deb ;};_dcgg ,_ebe :=_fdf (_fegd [:32]);if _ebe !=nil {return _ebe ;};_fdfe :=_gef (_dcgg );_fdfe .CryptBlocks (Perms ,Perms );_gaab .Perms =Perms [:16];return nil ;};func (_bcf stdHandlerR6 )alg2a (_faf *StdEncryptDict ,_cefg []byte )([]byte ,Permissions ,error ){if _cdf :=_bbe ("\u0061\u006c\u00672\u0061","\u004f",48,_faf .O );
_cdf !=nil {return nil ,0,_cdf ;};if _ecf :=_bbe ("\u0061\u006c\u00672\u0061","\u0055",48,_faf .U );_ecf !=nil {return nil ,0,_ecf ;};if len (_cefg )> 127{_cefg =_cefg [:127];};_ebb ,_gff :=_bcf .alg12 (_faf ,_cefg );if _gff !=nil {return nil ,0,_gff ;
};var (_fgba []byte ;_bca []byte ;_fcf []byte ;);var _aga Permissions ;if len (_ebb )!=0{_aga =PermOwner ;_ebbf :=make ([]byte ,len (_cefg )+8+48);_eg :=copy (_ebbf ,_cefg );_eg +=copy (_ebbf [_eg :],_faf .O [40:48]);copy (_ebbf [_eg :],_faf .U [0:48]);
_fgba =_ebbf ;_bca =_faf .OE ;_fcf =_faf .U [0:48];}else {_ebb ,_gff =_bcf .alg11 (_faf ,_cefg );if _gff ==nil &&len (_ebb )==0{_ebb ,_gff =_bcf .alg11 (_faf ,[]byte (""));};if _gff !=nil {return nil ,0,_gff ;}else if len (_ebb )==0{return nil ,0,nil ;
};_aga =_faf .P ;_gefa :=make ([]byte ,len (_cefg )+8);_cgf :=copy (_gefa ,_cefg );copy (_gefa [_cgf :],_faf .U [40:48]);_fgba =_gefa ;_bca =_faf .UE ;_fcf =nil ;};if _dcc :=_bbe ("\u0061\u006c\u00672\u0061","\u004b\u0065\u0079",32,_bca );_dcc !=nil {return nil ,0,_dcc ;
};_bca =_bca [:32];_ega ,_gff :=_bcf .alg2b (_faf .R ,_fgba ,_cefg ,_fcf );if _gff !=nil {return nil ,0,_gff ;};_age ,_gff :=_ec .NewCipher (_ega [:32]);if _gff !=nil {return nil ,0,_gff ;};_cfeg :=make ([]byte ,_ec .BlockSize );_feg :=_ea .NewCBCDecrypter (_age ,_cfeg );
_dccb :=make ([]byte ,32);_feg .CryptBlocks (_dccb ,_bca );if _faf .R ==5{return _dccb ,_aga ,nil ;};_gff =_bcf .alg13 (_faf ,_dccb );if _gff !=nil {return nil ,0,_gff ;};return _dccb ,_aga ,nil ;};func (_fdb stdHandlerR4 )alg7 (_gdaf *StdEncryptDict ,_gc []byte )([]byte ,error ){_bed :=_fdb .alg3Key (_gdaf .R ,_gc );
_de :=make ([]byte ,len (_gdaf .O ));if _gdaf .R ==2{_bbc ,_cggd :=_ge .NewCipher (_bed );if _cggd !=nil {return nil ,_b .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_bbc .XORKeyStream (_de ,_gdaf .O );}else if _gdaf .R >=3{_ccc :=append ([]byte {},_gdaf .O ...);
for _cbg :=0;_cbg < 20;_cbg ++{_abb :=append ([]byte {},_bed ...);for _bbg :=0;_bbg < len (_bed );_bbg ++{_abb [_bbg ]^=byte (19-_cbg );};_eb ,_aef :=_ge .NewCipher (_abb );if _aef !=nil {return nil ,_b .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");
};_eb .XORKeyStream (_de ,_ccc );_ccc =append ([]byte {},_de ...);};}else {return nil ,_b .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};_dd ,_fbf :=_fdb .alg6 (_gdaf ,_de );if _fbf !=nil {return nil ,nil ;};return _dd ,nil ;};var _ StdHandler =stdHandlerR4 {};
func (_cgg stdHandlerR4 )alg3 (R int ,_af ,_db []byte )([]byte ,error ){var _cc []byte ;if len (_db )> 0{_cc =_cgg .alg3Key (R ,_db );}else {_cc =_cgg .alg3Key (R ,_af );};_cbe ,_fcd :=_ge .NewCipher (_cc );if _fcd !=nil {return nil ,_b .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_fgbd :=_cgg .paddedPass (_af );_ecc :=make ([]byte ,len (_fgbd ));_cbe .XORKeyStream (_ecc ,_fgbd );if R >=3{_fae :=make ([]byte ,len (_cc ));for _aeg :=0;_aeg < 19;_aeg ++{for _dc :=0;_dc < len (_cc );_dc ++{_fae [_dc ]=_cc [_dc ]^byte (_aeg +1);};
_aeb ,_gac :=_ge .NewCipher (_fae );if _gac !=nil {return nil ,_b .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_aeb .XORKeyStream (_ecc ,_ecc );};};return _ecc ,nil ;};const (PermOwner =Permissions (_cg .MaxUint32 );
PermPrinting =Permissions (1<<2);PermModify =Permissions (1<<3);PermExtractGraphics =Permissions (1<<4);PermAnnotate =Permissions (1<<5);PermFillForms =Permissions (1<<8);PermDisabilityExtract =Permissions (1<<9);PermRotateInsert =Permissions (1<<10);PermFullPrintQuality =Permissions (1<<11);
);

// NewHandlerR4 creates a new standard security handler for R<=4.
func NewHandlerR4 (id0 string ,length int )StdHandler {return stdHandlerR4 {ID0 :id0 ,Length :length }};type errInvalidField struct{Func string ;Field string ;Exp int ;Got int ;};func _fbb (_ede []byte ,_cfg int ){_dgd :=_cfg ;for _dgd < len (_ede ){copy (_ede [_dgd :],_ede [:_dgd ]);
_dgd *=2;};};func (_gdd *ecbDecrypter )CryptBlocks (dst ,src []byte ){if len (src )%_gdd ._bb !=0{_ga .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_ga .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0064\u0065\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_gdd ._gb .Decrypt (dst ,src [:_gdd ._bb ]);src =src [_gdd ._bb :];dst =dst [_gdd ._bb :];};};func _fdf (_gded []byte )(_ea .Block ,error ){_cgd ,_ccb :=_ec .NewCipher (_gded );if _ccb !=nil {_ga .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0063\u0072\u0065\u0061\u0074\u0065\u0020A\u0045\u0053\u0020\u0063\u0069p\u0068\u0065r\u003a\u0020\u0025\u0076",_ccb );
return nil ,_ccb ;};return _cgd ,nil ;};const (EventDocOpen =AuthEvent ("\u0044o\u0063\u004f\u0070\u0065\u006e");EventEFOpen =AuthEvent ("\u0045\u0046\u004f\u0070\u0065\u006e"););func (_ece *ecbEncrypter )BlockSize ()int {return _ece ._bb };

// StdHandler is an interface for standard security handlers.
type StdHandler interface{

// GenerateParams uses owner and user passwords to set encryption parameters and generate an encryption key.
// It assumes that R, P and EncryptMetadata are already set.
GenerateParams (_cb *StdEncryptDict ,_ffe ,_fg []byte )([]byte ,error );

// Authenticate uses encryption dictionary parameters and the password to calculate
// the document encryption key. It also returns permissions that should be granted to a user.
// In case of failed authentication, it returns empty key and zero permissions with no error.
Authenticate (_ag *StdEncryptDict ,_cd []byte )([]byte ,Permissions ,error );};func (_dga stdHandlerR4 )alg5 (_fde []byte ,_gddg []byte )([]byte ,error ){_gde :=_ed .New ();_gde .Write ([]byte (_bg ));_gde .Write ([]byte (_dga .ID0 ));_gfb :=_gde .Sum (nil );
_ga .Log .Trace ("\u0061\u006c\u0067\u0035");_ga .Log .Trace ("\u0065k\u0065\u0079\u003a\u0020\u0025\u0020x",_fde );_ga .Log .Trace ("\u0049D\u003a\u0020\u0025\u0020\u0078",_dga .ID0 );if len (_gfb )!=16{return nil ,_b .New ("\u0068a\u0073\u0068\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074\u0020\u0031\u0036\u0020\u0062\u0079\u0074\u0065\u0073");
};_cee ,_feb :=_ge .NewCipher (_fde );if _feb !=nil {return nil ,_b .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_fb :=make ([]byte ,16);_cee .XORKeyStream (_fb ,_gfb );_geb :=make ([]byte ,len (_fde ));for _eaf :=0;
_eaf < 19;_eaf ++{for _bdf :=0;_bdf < len (_fde );_bdf ++{_geb [_bdf ]=_fde [_bdf ]^byte (_eaf +1);};_cee ,_feb =_ge .NewCipher (_geb );if _feb !=nil {return nil ,_b .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_cee .XORKeyStream (_fb ,_fb );_ga .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u002c\u0020\u0065\u006b\u0065\u0079:\u0020\u0025\u0020\u0078",_eaf ,_geb );_ga .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0020\u0078",_eaf ,_fb );
};_fdg :=make ([]byte ,32);for _geff :=0;_geff < 16;_geff ++{_fdg [_geff ]=_fb [_geff ];};_ ,_feb =_c .Read (_fdg [16:32]);if _feb !=nil {return nil ,_b .New ("\u0066a\u0069\u006c\u0065\u0064 \u0074\u006f\u0020\u0067\u0065n\u0020r\u0061n\u0064\u0020\u006e\u0075\u006d\u0062\u0065r");
};return _fdg ,nil ;};

// NewHandlerR6 creates a new standard security handler for R=5 and R=6.
func NewHandlerR6 ()StdHandler {return stdHandlerR6 {}};type ecb struct{_gb _ea .Block ;_bb int ;};func _bbe (_gfa ,_fgg string ,_cbc int ,_fgf []byte )error {if len (_fgf )< _cbc {return errInvalidField {Func :_gfa ,Field :_fgg ,Exp :_cbc ,Got :len (_fgf )};
};return nil ;};

// Authenticate implements StdHandler interface.
func (_gacc stdHandlerR6 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){return _gacc .alg2a (d ,pass );};

// GenerateParams generates and sets O and U parameters for the encryption dictionary.
// It expects R, P and EncryptMetadata fields to be set.
func (_cff stdHandlerR4 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){O ,_cgc :=_cff .alg3 (d .R ,upass ,opass );if _cgc !=nil {_ga .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_cgc );
return nil ,_cgc ;};d .O =O ;_ga .Log .Trace ("\u0067\u0065\u006e\u0020\u004f\u003a\u0020\u0025\u0020\u0078",O );_gca :=_cff .alg2 (d ,upass );U ,_cgc :=_cff .alg5 (_gca ,upass );if _cgc !=nil {_ga .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_cgc );
return nil ,_cgc ;};d .U =U ;_ga .Log .Trace ("\u0067\u0065\u006e\u0020\u0055\u003a\u0020\u0025\u0020\u0078",U );return _gca ,nil ;};type stdHandlerR6 struct{};func (stdHandlerR4 )paddedPass (_d []byte )[]byte {_dg :=make ([]byte ,32);_ad :=copy (_dg ,_d );
for ;_ad < 32;_ad ++{_dg [_ad ]=_bg [_ad -len (_d )];};return _dg ;};