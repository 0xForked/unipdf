//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package security ;import (_ae "bytes";_ga "crypto/aes";_a "crypto/cipher";_b "crypto/md5";_ge "crypto/rand";_af "crypto/rc4";_d "crypto/sha256";_gg "crypto/sha512";_ab "encoding/binary";_f "errors";_df "fmt";_fd "github.com/unidoc/unipdf/v3/common";_c "hash";
_g "io";_de "math";);

// AuthEvent is an event type that triggers authentication.
type AuthEvent string ;func (stdHandlerR4 )paddedPass (_da []byte )[]byte {_ca :=make ([]byte ,32);_ag :=copy (_ca ,_da );for ;_ag < 32;_ag ++{_ca [_ag ]=_cdc [_ag -len (_da )];};return _ca ;};func (_gfa stdHandlerR6 )alg10 (_fdd *StdEncryptDict ,_cec []byte )error {if _eec :=_ee ("\u0061\u006c\u00671\u0030","\u004b\u0065\u0079",32,_cec );
_eec !=nil {return _eec ;};_gdb :=uint64 (uint32 (_fdd .P ))|(_de .MaxUint32 <<32);Perms :=make ([]byte ,16);_ab .LittleEndian .PutUint64 (Perms [:8],_gdb );if _fdd .EncryptMetadata {Perms [8]='T';}else {Perms [8]='F';};copy (Perms [9:12],"\u0061\u0064\u0062");
if _ ,_eee :=_g .ReadFull (_ge .Reader ,Perms [12:16]);_eee !=nil {return _eee ;};_cgee ,_acc :=_bg (_cec [:32]);if _acc !=nil {return _acc ;};_gce :=_ff (_cgee );_gce .CryptBlocks (Perms ,Perms );_fdd .Perms =Perms [:16];return nil ;};

// StdEncryptDict is a set of additional fields used in standard encryption dictionary.
type StdEncryptDict struct{R int ;P Permissions ;EncryptMetadata bool ;O ,U []byte ;OE ,UE []byte ;Perms []byte ;};type ecbDecrypter ecb ;func _ee (_gbb ,_gec string ,_gd int ,_bd []byte )error {if len (_bd )< _gd {return errInvalidField {Func :_gbb ,Field :_gec ,Exp :_gd ,Got :len (_bd )};
};return nil ;};var _ StdHandler =stdHandlerR6 {};

// GenerateParams is the algorithm opposite to alg2a (R>=5).
// It generates U,O,UE,OE,Perms fields using AESv3 encryption.
// There is no algorithm number assigned to this function in the spec.
// It expects R, P and EncryptMetadata fields to be set.
func (_gcec stdHandlerR6 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){_gge :=make ([]byte ,32);if _ ,_agab :=_g .ReadFull (_ge .Reader ,_gge );_agab !=nil {return nil ,_agab ;};d .U =nil ;d .O =nil ;d .UE =nil ;d .OE =nil ;
d .Perms =nil ;if len (upass )> 127{upass =upass [:127];};if len (opass )> 127{opass =opass [:127];};if _gcf :=_gcec .alg8 (d ,_gge ,upass );_gcf !=nil {return nil ,_gcf ;};if _agad :=_gcec .alg9 (d ,_gge ,opass );_agad !=nil {return nil ,_agad ;};if d .R ==5{return _gge ,nil ;
};if _fbe :=_gcec .alg10 (d ,_gge );_fbe !=nil {return nil ,_fbe ;};return _gge ,nil ;};func _ff (_dea _a .Block )_a .BlockMode {return (*ecbEncrypter )(_fg (_dea ))};func (_be *ecbEncrypter )BlockSize ()int {return _be ._bc };func (_fbf stdHandlerR4 )alg6 (_eddg *StdEncryptDict ,_cac []byte )([]byte ,error ){var (_deb []byte ;
_gca error ;);_gff :=_fbf .alg2 (_eddg ,_cac );if _eddg .R ==2{_deb ,_gca =_fbf .alg4 (_gff ,_cac );}else if _eddg .R >=3{_deb ,_gca =_fbf .alg5 (_gff ,_cac );}else {return nil ,_f .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};if _gca !=nil {return nil ,_gca ;
};_fd .Log .Trace ("\u0063\u0068\u0065\u0063k:\u0020\u0025\u0020\u0078\u0020\u003d\u003d\u0020\u0025\u0020\u0078\u0020\u003f",string (_deb ),string (_eddg .U ));_ffa :=_deb ;_fbd :=_eddg .U ;if _eddg .R >=3{if len (_ffa )> 16{_ffa =_ffa [0:16];};if len (_fbd )> 16{_fbd =_fbd [0:16];
};};if !_ae .Equal (_ffa ,_fbd ){return nil ,nil ;};return _gff ,nil ;};

// StdHandler is an interface for standard security handlers.
type StdHandler interface{

// GenerateParams uses owner and user passwords to set encryption parameters and generate an encryption key.
// It assumes that R, P and EncryptMetadata are already set.
GenerateParams (_gea *StdEncryptDict ,_gabc ,_afb []byte )([]byte ,error );

// Authenticate uses encryption dictionary parameters and the password to calculate
// the document encryption key. It also returns permissions that should be granted to a user.
// In case of failed authentication, it returns empty key and zero permissions with no error.
Authenticate (_gc *StdEncryptDict ,_gf []byte )([]byte ,Permissions ,error );};func (_gab *ecbEncrypter )CryptBlocks (dst ,src []byte ){if len (src )%_gab ._bc !=0{_fd .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_fd .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_gab ._gb .Encrypt (dst ,src [:_gab ._bc ]);src =src [_gab ._bc :];dst =dst [_gab ._bc :];};};func _bg (_gefb []byte )(_a .Block ,error ){_ddc ,_ffc :=_ga .NewCipher (_gefb );if _ffc !=nil {_fd .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0063\u0072\u0065\u0061\u0074\u0065\u0020A\u0045\u0053\u0020\u0063\u0069p\u0068\u0065r\u003a\u0020\u0025\u0076",_ffc );
return nil ,_ffc ;};return _ddc ,nil ;};type stdHandlerR6 struct{};type ecbEncrypter ecb ;func (_aed *ecbDecrypter )BlockSize ()int {return _aed ._bc };func (_abc stdHandlerR4 )alg3 (R int ,_edf ,_ebd []byte )([]byte ,error ){var _ega []byte ;if len (_ebd )> 0{_ega =_abc .alg3Key (R ,_ebd );
}else {_ega =_abc .alg3Key (R ,_edf );};_dc ,_gef :=_af .NewCipher (_ega );if _gef !=nil {return nil ,_f .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_gdg :=_abc .paddedPass (_edf );_ged :=make ([]byte ,len (_gdg ));
_dc .XORKeyStream (_ged ,_gdg );if R >=3{_egb :=make ([]byte ,len (_ega ));for _agc :=0;_agc < 19;_agc ++{for _gdd :=0;_gdd < len (_ega );_gdd ++{_egb [_gdd ]=_ega [_gdd ]^byte (_agc +1);};_gdgg ,_gdc :=_af .NewCipher (_egb );if _gdc !=nil {return nil ,_f .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_gdgg .XORKeyStream (_ged ,_ged );};};return _ged ,nil ;};func (_edfd stdHandlerR4 )alg7 (_bda *StdEncryptDict ,_edb []byte )([]byte ,error ){_fe :=_edfd .alg3Key (_bda .R ,_edb );_ffad :=make ([]byte ,len (_bda .O ));if _bda .R ==2{_fdf ,_ggc :=_af .NewCipher (_fe );
if _ggc !=nil {return nil ,_f .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_fdf .XORKeyStream (_ffad ,_bda .O );}else if _bda .R >=3{_fge :=append ([]byte {},_bda .O ...);for _eddd :=0;_eddd < 20;_eddd ++{_aea :=append ([]byte {},_fe ...);
for _gdf :=0;_gdf < len (_fe );_gdf ++{_aea [_gdf ]^=byte (19-_eddd );};_gac ,_gfg :=_af .NewCipher (_aea );if _gfg !=nil {return nil ,_f .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_gac .XORKeyStream (_ffad ,_fge );
_fge =append ([]byte {},_ffad ...);};}else {return nil ,_f .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};_dcf ,_ced :=_edfd .alg6 (_bda ,_ffad );if _ced !=nil {return nil ,nil ;};return _dcf ,nil ;};

// Authenticate implements StdHandler interface.
func (_fec stdHandlerR4 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){_fd .Log .Trace ("\u0044\u0065b\u0075\u0067\u0067\u0069n\u0067\u0020a\u0075\u0074\u0068\u0065\u006e\u0074\u0069\u0063a\u0074\u0069\u006f\u006e\u0020\u002d\u0020\u006f\u0077\u006e\u0065\u0072 \u0070\u0061\u0073\u0073");
_gbe ,_dge :=_fec .alg7 (d ,pass );if _dge !=nil {return nil ,0,_dge ;};if _gbe !=nil {_fd .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _gbe ,PermOwner ,nil ;
};_fd .Log .Trace ("\u0044\u0065bu\u0067\u0067\u0069n\u0067\u0020\u0061\u0075the\u006eti\u0063\u0061\u0074\u0069\u006f\u006e\u0020- \u0075\u0073\u0065\u0072\u0020\u0070\u0061s\u0073");_gbe ,_dge =_fec .alg6 (d ,pass );if _dge !=nil {return nil ,0,_dge ;
};if _gbe !=nil {_fd .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _gbe ,d .P ,nil ;};return nil ,0,nil ;};const (EventDocOpen =AuthEvent ("\u0044o\u0063\u004f\u0070\u0065\u006e");
EventEFOpen =AuthEvent ("\u0045\u0046\u004f\u0070\u0065\u006e"););

// Allowed checks if a set of permissions can be granted.
func (_cd Permissions )Allowed (p2 Permissions )bool {return _cd &p2 ==p2 };func (_ddd stdHandlerR6 )alg11 (_gfb *StdEncryptDict ,_edc []byte )([]byte ,error ){if _dgbd :=_ee ("\u0061\u006c\u00671\u0031","\u0055",48,_gfb .U );_dgbd !=nil {return nil ,_dgbd ;
};_ffda :=make ([]byte ,len (_edc )+8);_edfa :=copy (_ffda ,_edc );_edfa +=copy (_ffda [_edfa :],_gfb .U [32:40]);_eac ,_abg :=_ddd .alg2b (_gfb .R ,_ffda ,_edc ,nil );if _abg !=nil {return nil ,_abg ;};_eac =_eac [:32];if !_ae .Equal (_eac ,_gfb .U [:32]){return nil ,nil ;
};return _eac ,nil ;};const _cdc ="\x28\277\116\136\x4e\x75\x8a\x41\x64\000\x4e\x56\377"+"\xfa\001\010\056\x2e\x00\xb6\xd0\x68\076\x80\x2f\014"+"\251\xfe\x64\x53\x69\172";

// Authenticate implements StdHandler interface.
func (_eeb stdHandlerR6 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){return _eeb .alg2a (d ,pass );};type errInvalidField struct{Func string ;Field string ;Exp int ;Got int ;};func (_dga stdHandlerR6 )alg12 (_aa *StdEncryptDict ,_fgb []byte )([]byte ,error ){if _eed :=_ee ("\u0061\u006c\u00671\u0032","\u0055",48,_aa .U );
_eed !=nil {return nil ,_eed ;};if _cdd :=_ee ("\u0061\u006c\u00671\u0032","\u004f",48,_aa .O );_cdd !=nil {return nil ,_cdd ;};_bdd :=make ([]byte ,len (_fgb )+8+48);_dgeb :=copy (_bdd ,_fgb );_dgeb +=copy (_bdd [_dgeb :],_aa .O [32:40]);_dgeb +=copy (_bdd [_dgeb :],_aa .U [0:48]);
_egbd ,_efgf :=_dga .alg2b (_aa .R ,_bdd ,_fgb ,_aa .U [0:48]);if _efgf !=nil {return nil ,_efgf ;};_egbd =_egbd [:32];if !_ae .Equal (_egbd ,_aa .O [:32]){return nil ,nil ;};return _egbd ,nil ;};func _cga (_cfe []byte ,_dfb int ){_ffcc :=_dfb ;for _ffcc < len (_cfe ){copy (_cfe [_ffcc :],_cfe [:_ffcc ]);
_ffcc *=2;};};

// GenerateParams generates and sets O and U parameters for the encryption dictionary.
// It expects R, P and EncryptMetadata fields to be set.
func (_gecc stdHandlerR4 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){O ,_dfg :=_gecc .alg3 (d .R ,upass ,opass );if _dfg !=nil {_fd .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_dfg );
return nil ,_dfg ;};d .O =O ;_fd .Log .Trace ("\u0067\u0065\u006e\u0020\u004f\u003a\u0020\u0025\u0020\u0078",O );_fdc :=_gecc .alg2 (d ,upass );U ,_dfg :=_gecc .alg5 (_fdc ,upass );if _dfg !=nil {_fd .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_dfg );
return nil ,_dfg ;};d .U =U ;_fd .Log .Trace ("\u0067\u0065\u006e\u0020\u0055\u003a\u0020\u0025\u0020\u0078",U );return _fdc ,nil ;};func (_ded stdHandlerR6 )alg8 (_deg *StdEncryptDict ,_cgb []byte ,_gae []byte )error {if _cce :=_ee ("\u0061\u006c\u0067\u0038","\u004b\u0065\u0079",32,_cgb );
_cce !=nil {return _cce ;};var _eeg [16]byte ;if _ ,_geed :=_g .ReadFull (_ge .Reader ,_eeg [:]);_geed !=nil {return _geed ;};_dgb :=_eeg [0:8];_cede :=_eeg [8:16];_fdfg :=make ([]byte ,len (_gae )+len (_dgb ));_gbf :=copy (_fdfg ,_gae );copy (_fdfg [_gbf :],_dgb );
_aedd ,_acde :=_ded .alg2b (_deg .R ,_fdfg ,_gae ,nil );if _acde !=nil {return _acde ;};U :=make ([]byte ,len (_aedd )+len (_dgb )+len (_cede ));_gbf =copy (U ,_aedd [:32]);_gbf +=copy (U [_gbf :],_dgb );copy (U [_gbf :],_cede );_deg .U =U ;_gbf =len (_gae );
copy (_fdfg [_gbf :],_cede );_aedd ,_acde =_ded .alg2b (_deg .R ,_fdfg ,_gae ,nil );if _acde !=nil {return _acde ;};_ggg ,_acde :=_bg (_aedd [:32]);if _acde !=nil {return _acde ;};_aedb :=make ([]byte ,_ga .BlockSize );_dec :=_a .NewCBCEncrypter (_ggg ,_aedb );
UE :=make ([]byte ,32);_dec .CryptBlocks (UE ,_cgb [:32]);_deg .UE =UE ;return nil ;};type stdHandlerR4 struct{Length int ;ID0 string ;};func (_deae stdHandlerR4 )alg4 (_cf []byte ,_bad []byte )([]byte ,error ){_ce ,_age :=_af .NewCipher (_cf );if _age !=nil {return nil ,_f .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_eae :=[]byte (_cdc );_fb :=make ([]byte ,len (_eae ));_ce .XORKeyStream (_fb ,_eae );return _fb ,nil ;};

// NewHandlerR6 creates a new standard security handler for R=5 and R=6.
func NewHandlerR6 ()StdHandler {return stdHandlerR6 {}};func (_acb stdHandlerR6 )alg9 (_eegb *StdEncryptDict ,_fdfc []byte ,_gaf []byte )error {if _faa :=_ee ("\u0061\u006c\u0067\u0039","\u004b\u0065\u0079",32,_fdfc );_faa !=nil {return _faa ;};if _ebdf :=_ee ("\u0061\u006c\u0067\u0039","\u0055",48,_eegb .U );
_ebdf !=nil {return _ebdf ;};var _efg [16]byte ;if _ ,_cca :=_g .ReadFull (_ge .Reader ,_efg [:]);_cca !=nil {return _cca ;};_cgg :=_efg [0:8];_eda :=_efg [8:16];_bbd :=_eegb .U [:48];_gbee :=make ([]byte ,len (_gaf )+len (_cgg )+len (_bbd ));_ccf :=copy (_gbee ,_gaf );
_ccf +=copy (_gbee [_ccf :],_cgg );_ccf +=copy (_gbee [_ccf :],_bbd );_fgg ,_aca :=_acb .alg2b (_eegb .R ,_gbee ,_gaf ,_bbd );if _aca !=nil {return _aca ;};O :=make ([]byte ,len (_fgg )+len (_cgg )+len (_eda ));_ccf =copy (O ,_fgg [:32]);_ccf +=copy (O [_ccf :],_cgg );
_ccf +=copy (O [_ccf :],_eda );_eegb .O =O ;_ccf =len (_gaf );_ccf +=copy (_gbee [_ccf :],_eda );_fgg ,_aca =_acb .alg2b (_eegb .R ,_gbee ,_gaf ,_bbd );if _aca !=nil {return _aca ;};_fgf ,_aca :=_bg (_fgg [:32]);if _aca !=nil {return _aca ;};_cef :=make ([]byte ,_ga .BlockSize );
_aba :=_a .NewCBCEncrypter (_fgf ,_cef );OE :=make ([]byte ,32);_aba .CryptBlocks (OE ,_fdfc [:32]);_eegb .OE =OE ;return nil ;};type ecb struct{_gb _a .Block ;_bc int ;};

// NewHandlerR4 creates a new standard security handler for R<=4.
func NewHandlerR4 (id0 string ,length int )StdHandler {return stdHandlerR4 {ID0 :id0 ,Length :length }};func (_fdcd stdHandlerR6 )alg13 (_gdca *StdEncryptDict ,_cfec []byte )error {if _bebc :=_ee ("\u0061\u006c\u00671\u0033","\u004b\u0065\u0079",32,_cfec );
_bebc !=nil {return _bebc ;};if _ede :=_ee ("\u0061\u006c\u00671\u0033","\u0050\u0065\u0072m\u0073",16,_gdca .Perms );_ede !=nil {return _ede ;};_gag :=make ([]byte ,16);copy (_gag ,_gdca .Perms [:16]);_aef ,_gdbc :=_ga .NewCipher (_cfec [:32]);if _gdbc !=nil {return _gdbc ;
};_fae :=_beb (_aef );_fae .CryptBlocks (_gag ,_gag );if !_ae .Equal (_gag [9:12],[]byte ("\u0061\u0064\u0062")){return _f .New ("\u0064\u0065\u0063o\u0064\u0065\u0064\u0020p\u0065\u0072\u006d\u0069\u0073\u0073\u0069o\u006e\u0073\u0020\u0061\u0072\u0065\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};_ffab :=Permissions (_ab .LittleEndian .Uint32 (_gag [0:4]));if _ffab !=_gdca .P {return _f .New ("\u0070\u0065r\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066\u0061il\u0065\u0064");
};var _dffd bool ;if _gag [8]=='T'{_dffd =true ;}else if _gag [8]=='F'{_dffd =false ;}else {return _f .New ("\u0064\u0065\u0063\u006f\u0064\u0065\u0064 \u006d\u0065\u0074a\u0064\u0061\u0074\u0061 \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u006c\u0061\u0067\u0020\u0069\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};if _dffd !=_gdca .EncryptMetadata {return _f .New ("\u006d\u0065t\u0061\u0064\u0061\u0074a\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e \u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066a\u0069\u006c\u0065\u0064");
};return nil ;};var _ StdHandler =stdHandlerR4 {};const (PermOwner =Permissions (_de .MaxUint32 );PermPrinting =Permissions (1<<2);PermModify =Permissions (1<<3);PermExtractGraphics =Permissions (1<<4);PermAnnotate =Permissions (1<<5);PermFillForms =Permissions (1<<8);
PermDisabilityExtract =Permissions (1<<9);PermRotateInsert =Permissions (1<<10);PermFullPrintQuality =Permissions (1<<11););func (_aga stdHandlerR4 )alg3Key (R int ,_aeg []byte )[]byte {_fc :=_b .New ();_dff :=_aga .paddedPass (_aeg );_fc .Write (_dff );
if R >=3{for _ba :=0;_ba < 50;_ba ++{_gee :=_fc .Sum (nil );_fc =_b .New ();_fc .Write (_gee );};};_ggb :=_fc .Sum (nil );if R ==2{_ggb =_ggb [0:5];}else {_ggb =_ggb [0:_aga .Length /8];};return _ggb ;};func _gcg (_dbbd []byte )([]byte ,error ){_cad :=_d .New ();
_cad .Write (_dbbd );return _cad .Sum (nil ),nil ;};func _beb (_bcd _a .Block )_a .BlockMode {return (*ecbDecrypter )(_fg (_bcd ))};func (_abcc stdHandlerR4 )alg5 (_edd []byte ,_abd []byte )([]byte ,error ){_fa :=_b .New ();_fa .Write ([]byte (_cdc ));
_fa .Write ([]byte (_abcc .ID0 ));_ac :=_fa .Sum (nil );_fd .Log .Trace ("\u0061\u006c\u0067\u0035");_fd .Log .Trace ("\u0065k\u0065\u0079\u003a\u0020\u0025\u0020x",_edd );_fd .Log .Trace ("\u0049D\u003a\u0020\u0025\u0020\u0078",_abcc .ID0 );if len (_ac )!=16{return nil ,_f .New ("\u0068a\u0073\u0068\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074\u0020\u0031\u0036\u0020\u0062\u0079\u0074\u0065\u0073");
};_bb ,_ebb :=_af .NewCipher (_edd );if _ebb !=nil {return nil ,_f .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_gad :=make ([]byte ,16);_bb .XORKeyStream (_gad ,_ac );_bbg :=make ([]byte ,len (_edd ));for _dca :=0;
_dca < 19;_dca ++{for _ebe :=0;_ebe < len (_edd );_ebe ++{_bbg [_ebe ]=_edd [_ebe ]^byte (_dca +1);};_bb ,_ebb =_af .NewCipher (_bbg );if _ebb !=nil {return nil ,_f .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_bb .XORKeyStream (_gad ,_gad );_fd .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u002c\u0020\u0065\u006b\u0065\u0079:\u0020\u0025\u0020\u0078",_dca ,_bbg );_fd .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0020\u0078",_dca ,_gad );
};_gfd :=make ([]byte ,32);for _dfc :=0;_dfc < 16;_dfc ++{_gfd [_dfc ]=_gad [_dfc ];};_ ,_ebb =_ge .Read (_gfd [16:32]);if _ebb !=nil {return nil ,_f .New ("\u0066a\u0069\u006c\u0065\u0064 \u0074\u006f\u0020\u0067\u0065n\u0020r\u0061n\u0064\u0020\u006e\u0075\u006d\u0062\u0065r");
};return _gfd ,nil ;};func (_egf stdHandlerR6 )alg2a (_ef *StdEncryptDict ,_eea []byte )([]byte ,Permissions ,error ){if _afa :=_ee ("\u0061\u006c\u00672\u0061","\u004f",48,_ef .O );_afa !=nil {return nil ,0,_afa ;};if _fgeg :=_ee ("\u0061\u006c\u00672\u0061","\u0055",48,_ef .U );
_fgeg !=nil {return nil ,0,_fgeg ;};if len (_eea )> 127{_eea =_eea [:127];};_fad ,_cea :=_egf .alg12 (_ef ,_eea );if _cea !=nil {return nil ,0,_cea ;};var (_cgfa []byte ;_aec []byte ;_edda []byte ;);var _gbd Permissions ;if len (_fad )!=0{_gbd =PermOwner ;
_fda :=make ([]byte ,len (_eea )+8+48);_bfd :=copy (_fda ,_eea );_bfd +=copy (_fda [_bfd :],_ef .O [40:48]);copy (_fda [_bfd :],_ef .U [0:48]);_cgfa =_fda ;_aec =_ef .OE ;_edda =_ef .U [0:48];}else {_fad ,_cea =_egf .alg11 (_ef ,_eea );if _cea ==nil &&len (_fad )==0{_fad ,_cea =_egf .alg11 (_ef ,[]byte (""));
};if _cea !=nil {return nil ,0,_cea ;}else if len (_fad )==0{return nil ,0,nil ;};_gbd =_ef .P ;_dbb :=make ([]byte ,len (_eea )+8);_eaf :=copy (_dbb ,_eea );copy (_dbb [_eaf :],_ef .U [40:48]);_cgfa =_dbb ;_aec =_ef .UE ;_edda =nil ;};if _dbbb :=_ee ("\u0061\u006c\u00672\u0061","\u004b\u0065\u0079",32,_aec );
_dbbb !=nil {return nil ,0,_dbbb ;};_aec =_aec [:32];_afc ,_cea :=_egf .alg2b (_ef .R ,_cgfa ,_eea ,_edda );if _cea !=nil {return nil ,0,_cea ;};_ceae ,_cea :=_ga .NewCipher (_afc [:32]);if _cea !=nil {return nil ,0,_cea ;};_dde :=make ([]byte ,_ga .BlockSize );
_fcf :=_a .NewCBCDecrypter (_ceae ,_dde );_acg :=make ([]byte ,32);_fcf .CryptBlocks (_acg ,_aec );if _ef .R ==5{return _acg ,_gbd ,nil ;};_cea =_egf .alg13 (_ef ,_acg );if _cea !=nil {return nil ,0,_cea ;};return _acg ,_gbd ,nil ;};func (_eg *ecbDecrypter )CryptBlocks (dst ,src []byte ){if len (src )%_eg ._bc !=0{_fd .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_fd .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0064\u0065\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_eg ._gb .Decrypt (dst ,src [:_eg ._bc ]);src =src [_eg ._bc :];dst =dst [_eg ._bc :];};};func (_ec errInvalidField )Error ()string {return _df .Sprintf ("\u0025s\u003a\u0020e\u0078\u0070\u0065\u0063t\u0065\u0064\u0020%\u0073\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0074o \u0062\u0065\u0020%\u0064\u0020b\u0079\u0074\u0065\u0073\u002c\u0020g\u006f\u0074 \u0025\u0064",_ec .Func ,_ec .Field ,_ec .Exp ,_ec .Got );
};func (_ea stdHandlerR4 )alg2 (_cc *StdEncryptDict ,_dae []byte )[]byte {_fd .Log .Trace ("\u0061\u006c\u0067\u0032");_cg :=_ea .paddedPass (_dae );_ed :=_b .New ();_ed .Write (_cg );_ed .Write (_cc .O );var _cgf [4]byte ;_ab .LittleEndian .PutUint32 (_cgf [:],uint32 (_cc .P ));
_ed .Write (_cgf [:]);_fd .Log .Trace ("\u0067o\u0020\u0050\u003a\u0020\u0025\u0020x",_cgf );_ed .Write ([]byte (_ea .ID0 ));_fd .Log .Trace ("\u0074\u0068\u0069\u0073\u002e\u0052\u0020\u003d\u0020\u0025d\u0020\u0065\u006e\u0063\u0072\u0079\u0070t\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061\u0020\u0025\u0076",_cc .R ,_cc .EncryptMetadata );
if (_cc .R >=4)&&!_cc .EncryptMetadata {_ed .Write ([]byte {0xff,0xff,0xff,0xff});};_dg :=_ed .Sum (nil );if _cc .R >=3{_ed =_b .New ();for _bf :=0;_bf < 50;_bf ++{_ed .Reset ();_ed .Write (_dg [0:_ea .Length /8]);_dg =_ed .Sum (nil );};};if _cc .R >=3{return _dg [0:_ea .Length /8];
};return _dg [0:5];};

// Permissions is a bitmask of access permissions for a PDF file.
type Permissions uint32 ;func (_ddb stdHandlerR6 )alg2b (R int ,_bfb ,_ddbd ,_fcc []byte )([]byte ,error ){if R ==5{return _gcg (_bfb );};return _gbg (_bfb ,_ddbd ,_fcc );};func _gbg (_cb ,_ggbb ,_cgc []byte )([]byte ,error ){var (_debc ,_fdae ,_dbbe _c .Hash ;
);_debc =_d .New ();_ffb :=make ([]byte ,64);_fbb :=_debc ;_fbb .Write (_cb );K :=_fbb .Sum (_ffb [:0]);_aead :=make ([]byte ,64*(127+64+48));_bca :=func (_bgc int )([]byte ,error ){_cgca :=len (_ggbb )+len (K )+len (_cgc );_bab :=_aead [:_cgca ];_egff :=copy (_bab ,_ggbb );
_egff +=copy (_bab [_egff :],K [:]);_egff +=copy (_bab [_egff :],_cgc );if _egff !=_cgca {_fd .Log .Error ("E\u0052\u0052\u004f\u0052\u003a\u0020u\u006e\u0065\u0078\u0070\u0065\u0063t\u0065\u0064\u0020\u0072\u006f\u0075\u006ed\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0073\u0069\u007ae\u002e");
return nil ,_f .New ("\u0077\u0072\u006f\u006e\u0067\u0020\u0073\u0069\u007a\u0065");};K1 :=_aead [:_cgca *64];_cga (K1 ,_cgca );_gefc ,_efb :=_bg (K [0:16]);if _efb !=nil {return nil ,_efb ;};_daa :=_a .NewCBCEncrypter (_gefc ,K [16:32]);_daa .CryptBlocks (K1 ,K1 );
E :=K1 ;_gffa :=0;for _ffd :=0;_ffd < 16;_ffd ++{_gffa +=int (E [_ffd ]%3);};var _cge _c .Hash ;switch _gffa %3{case 0:_cge =_debc ;case 1:if _fdae ==nil {_fdae =_gg .New384 ();};_cge =_fdae ;case 2:if _dbbe ==nil {_dbbe =_gg .New ();};_cge =_dbbe ;};_cge .Reset ();
_cge .Write (E );K =_cge .Sum (_ffb [:0]);return E ,nil ;};for _beba :=0;;{E ,_ffae :=_bca (_beba );if _ffae !=nil {return nil ,_ffae ;};_ffe :=E [len (E )-1];_beba ++;if _beba >=64&&_ffe <=uint8 (_beba -32){break ;};};return K [:32],nil ;};func _fg (_eb _a .Block )*ecb {return &ecb {_gb :_eb ,_bc :_eb .BlockSize ()}};
