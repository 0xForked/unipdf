//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package security ;import (_ca "bytes";_d "crypto/aes";_b "crypto/cipher";_db "crypto/md5";_f "crypto/rand";_cg "crypto/rc4";_be "crypto/sha256";_gc "crypto/sha512";_gd "encoding/binary";_cd "errors";_bg "fmt";_cb "github.com/unidoc/unipdf/v3/common";_g "hash";_a "io";_dg "math";);func _ga (_fg ,_ee string ,_bf int ,_ace []byte )error {if len (_ace )< _bf {return errInvalidField {Func :_fg ,Field :_ee ,Exp :_bf ,Got :len (_ace )};};return nil ;};type stdHandlerR4 struct{Length int ;ID0 string ;};func _ddd (_faed []byte )([]byte ,error ){_effb :=_be .New ();_effb .Write (_faed );return _effb .Sum (nil ),nil ;};func _dc (_ff _b .Block )_b .BlockMode {return (*ecbEncrypter )(_cbg (_ff ))};

// NewHandlerR6 creates a new standard security handler for R=5 and R=6.
func NewHandlerR6 ()StdHandler {return stdHandlerR6 {}};

// NewHandlerR4 creates a new standard security handler for R<=4.
func NewHandlerR4 (id0 string ,length int )StdHandler {return stdHandlerR4 {ID0 :id0 ,Length :length }};func (_bd *ecbEncrypter )CryptBlocks (dst ,src []byte ){if len (src )%_bd ._cc !=0{_cb .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");return ;};if len (dst )< len (src ){_cb .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");return ;};for len (src )> 0{_bd ._da .Encrypt (dst ,src [:_bd ._cc ]);src =src [_bd ._cc :];dst =dst [_bd ._cc :];};};type ecbDecrypter ecb ;func (_bac stdHandlerR4 )alg5 (_caf []byte ,_eec []byte )([]byte ,error ){_deb :=_db .New ();_deb .Write ([]byte (_de ));_deb .Write ([]byte (_bac .ID0 ));_bfd :=_deb .Sum (nil );_cb .Log .Trace ("\u0061\u006c\u0067\u0035");_cb .Log .Trace ("\u0065k\u0065\u0079\u003a\u0020\u0025\u0020x",_caf );_cb .Log .Trace ("\u0049D\u003a\u0020\u0025\u0020\u0078",_bac .ID0 );if len (_bfd )!=16{return nil ,_cd .New ("\u0068a\u0073\u0068\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074\u0020\u0031\u0036\u0020\u0062\u0079\u0074\u0065\u0073");};_bbd ,_fcd :=_cg .NewCipher (_caf );if _fcd !=nil {return nil ,_cd .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_bdf :=make ([]byte ,16);_bbd .XORKeyStream (_bdf ,_bfd );_gfa :=make ([]byte ,len (_caf ));for _af :=0;_af < 19;_af ++{for _bacc :=0;_bacc < len (_caf );_bacc ++{_gfa [_bacc ]=_caf [_bacc ]^byte (_af +1);};_bbd ,_fcd =_cg .NewCipher (_gfa );if _fcd !=nil {return nil ,_cd .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_bbd .XORKeyStream (_bdf ,_bdf );_cb .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u002c\u0020\u0065\u006b\u0065\u0079:\u0020\u0025\u0020\u0078",_af ,_gfa );_cb .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0020\u0078",_af ,_bdf );};_eea :=make ([]byte ,32);for _ea :=0;_ea < 16;_ea ++{_eea [_ea ]=_bdf [_ea ];};_ ,_fcd =_f .Read (_eea [16:32]);if _fcd !=nil {return nil ,_cd .New ("\u0066a\u0069\u006c\u0065\u0064 \u0074\u006f\u0020\u0067\u0065n\u0020r\u0061n\u0064\u0020\u006e\u0075\u006d\u0062\u0065r");};return _eea ,nil ;};func (_bff stdHandlerR4 )alg7 (_eee *StdEncryptDict ,_dfe []byte )([]byte ,error ){_cag :=_bff .alg3Key (_eee .R ,_dfe );_dffb :=make ([]byte ,len (_eee .O ));if _eee .R ==2{_ed ,_efg :=_cg .NewCipher (_cag );if _efg !=nil {return nil ,_cd .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_ed .XORKeyStream (_dffb ,_eee .O );}else if _eee .R >=3{_fccb :=append ([]byte {},_eee .O ...);for _gfc :=0;_gfc < 20;_gfc ++{_gb :=append ([]byte {},_cag ...);for _dfd :=0;_dfd < len (_cag );_dfd ++{_gb [_dfd ]^=byte (19-_gfc );};_bc ,_ffe :=_cg .NewCipher (_gb );if _ffe !=nil {return nil ,_cd .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_bc .XORKeyStream (_dffb ,_fccb );_fccb =append ([]byte {},_dffb ...);};}else {return nil ,_cd .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};_ffg ,_gdcf :=_bff .alg6 (_eee ,_dffb );if _gdcf !=nil {return nil ,nil ;};return _ffg ,nil ;};func (_bba stdHandlerR6 )alg2a (_gbb *StdEncryptDict ,_cee []byte )([]byte ,Permissions ,error ){if _cbf :=_ga ("\u0061\u006c\u00672\u0061","\u004f",48,_gbb .O );_cbf !=nil {return nil ,0,_cbf ;};if _fcbf :=_ga ("\u0061\u006c\u00672\u0061","\u0055",48,_gbb .U );_fcbf !=nil {return nil ,0,_fcbf ;};if len (_cee )> 127{_cee =_cee [:127];};_ceb ,_cac :=_bba .alg12 (_gbb ,_cee );if _cac !=nil {return nil ,0,_cac ;};var (_fee []byte ;_cfc []byte ;_ece []byte ;);var _eg Permissions ;if len (_ceb )!=0{_eg =PermOwner ;_edc :=make ([]byte ,len (_cee )+8+48);_cbc :=copy (_edc ,_cee );_cbc +=copy (_edc [_cbc :],_gbb .O [40:48]);_cbc +=copy (_edc [_cbc :],_gbb .U [0:48]);_fee =_edc ;_cfc =_gbb .OE ;_ece =_gbb .U [0:48];}else {_ceb ,_cac =_bba .alg11 (_gbb ,_cee );if _cac ==nil &&len (_ceb )==0{_ceb ,_cac =_bba .alg11 (_gbb ,[]byte (""));};if _cac !=nil {return nil ,0,_cac ;}else if len (_ceb )==0{return nil ,0,nil ;};_eg =_gbb .P ;_edg :=make ([]byte ,len (_cee )+8);_ced :=copy (_edg ,_cee );_ced +=copy (_edg [_ced :],_gbb .U [40:48]);_fee =_edg ;_cfc =_gbb .UE ;_ece =nil ;};if _bde :=_ga ("\u0061\u006c\u00672\u0061","\u004b\u0065\u0079",32,_cfc );_bde !=nil {return nil ,0,_bde ;};_cfc =_cfc [:32];_dab ,_cac :=_bba .alg2b (_gbb .R ,_fee ,_cee ,_ece );if _cac !=nil {return nil ,0,_cac ;};_eeb ,_cac :=_d .NewCipher (_dab [:32]);if _cac !=nil {return nil ,0,_cac ;};_gdd :=make ([]byte ,_d .BlockSize );_dec :=_b .NewCBCDecrypter (_eeb ,_gdd );_aeb :=make ([]byte ,32);_dec .CryptBlocks (_aeb ,_cfc );if _gbb .R ==5{return _aeb ,_eg ,nil ;};_cac =_bba .alg13 (_gbb ,_aeb );if _cac !=nil {return nil ,0,_cac ;};return _aeb ,_eg ,nil ;};func (_ded stdHandlerR6 )alg10 (_ccg *StdEncryptDict ,_cafd []byte )error {if _ceac :=_ga ("\u0061\u006c\u00671\u0030","\u004b\u0065\u0079",32,_cafd );_ceac !=nil {return _ceac ;};_ggb :=uint64 (uint32 (_ccg .P ))|(_dg .MaxUint32 <<32);Perms :=make ([]byte ,16);_gd .LittleEndian .PutUint64 (Perms [:8],_ggb );if _ccg .EncryptMetadata {Perms [8]='T';}else {Perms [8]='F';};copy (Perms [9:12],"\u0061\u0064\u0062");if _ ,_decb :=_a .ReadFull (_f .Reader ,Perms [12:16]);_decb !=nil {return _decb ;};_bgf ,_cdd :=_edd (_cafd [:32]);if _cdd !=nil {return _cdd ;};_aaa :=_dc (_bgf );_aaa .CryptBlocks (Perms ,Perms );_ccg .Perms =Perms [:16];return nil ;};type ecbEncrypter ecb ;func (_deg stdHandlerR4 )alg6 (_baed *StdEncryptDict ,_daf []byte )([]byte ,error ){var (_cga []byte ;_cgaa error ;);_fac :=_deg .alg2 (_baed ,_daf );if _baed .R ==2{_cga ,_cgaa =_deg .alg4 (_fac ,_daf );}else if _baed .R >=3{_cga ,_cgaa =_deg .alg5 (_fac ,_daf );}else {return nil ,_cd .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};if _cgaa !=nil {return nil ,_cgaa ;};_cb .Log .Trace ("\u0063\u0068\u0065\u0063k:\u0020\u0025\u0020\u0078\u0020\u003d\u003d\u0020\u0025\u0020\u0078\u0020\u003f",string (_cga ),string (_baed .U ));_fcc :=_cga ;_dcde :=_baed .U ;if _baed .R >=3{if len (_fcc )> 16{_fcc =_fcc [0:16];};if len (_dcde )> 16{_dcde =_dcde [0:16];};};if !_ca .Equal (_fcc ,_dcde ){return nil ,nil ;};return _fac ,nil ;};

// GenerateParams generates and sets O and U parameters for the encryption dictionary.
// It expects R, P and EncryptMetadata fields to be set.
func (_gdef stdHandlerR4 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){O ,_ecd :=_gdef .alg3 (d .R ,upass ,opass );if _ecd !=nil {_cb .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_ecd );return nil ,_ecd ;};d .O =O ;_cb .Log .Trace ("\u0067\u0065\u006e\u0020\u004f\u003a\u0020\u0025\u0020\u0078",O );_acg :=_gdef .alg2 (d ,upass );U ,_ecd :=_gdef .alg5 (_acg ,upass );if _ecd !=nil {_cb .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_ecd );return nil ,_ecd ;};d .U =U ;_cb .Log .Trace ("\u0067\u0065\u006e\u0020\u0055\u003a\u0020\u0025\u0020\u0078",U );return _acg ,nil ;};func (_efb stdHandlerR6 )alg8 (_dgf *StdEncryptDict ,_acd []byte ,_caga []byte )error {if _aafd :=_ga ("\u0061\u006c\u0067\u0038","\u004b\u0065\u0079",32,_acd );_aafd !=nil {return _aafd ;};var _cbaf [16]byte ;if _ ,_geb :=_a .ReadFull (_f .Reader ,_cbaf [:]);_geb !=nil {return _geb ;};_dbe :=_cbaf [0:8];_gea :=_cbaf [8:16];_bab :=make ([]byte ,len (_caga )+len (_dbe ));_aab :=copy (_bab ,_caga );_aab +=copy (_bab [_aab :],_dbe );_fcf ,_aea :=_efb .alg2b (_dgf .R ,_bab ,_caga ,nil );if _aea !=nil {return _aea ;};U :=make ([]byte ,len (_fcf )+len (_dbe )+len (_gea ));_aab =copy (U ,_fcf [:32]);_aab +=copy (U [_aab :],_dbe );_aab +=copy (U [_aab :],_gea );_dgf .U =U ;_aab =len (_caga );_aab +=copy (_bab [_aab :],_gea );_fcf ,_aea =_efb .alg2b (_dgf .R ,_bab ,_caga ,nil );if _aea !=nil {return _aea ;};_bgd ,_aea :=_edd (_fcf [:32]);if _aea !=nil {return _aea ;};_fbb :=make ([]byte ,_d .BlockSize );_eafg :=_b .NewCBCEncrypter (_bgd ,_fbb );UE :=make ([]byte ,32);_eafg .CryptBlocks (UE ,_acd [:32]);_dgf .UE =UE ;return nil ;};type errInvalidField struct{Func string ;Field string ;Exp int ;Got int ;};

// Authenticate implements StdHandler interface.
func (_acc stdHandlerR6 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){return _acc .alg2a (d ,pass );};func _bebd (_dda []byte ,_acabc int ){_dag :=_acabc ;for _dag < len (_dda ){copy (_dda [_dag :],_dda [:_dag ]);_dag *=2;};};const (EventDocOpen =AuthEvent ("\u0044o\u0063\u004f\u0070\u0065\u006e");EventEFOpen =AuthEvent ("\u0045\u0046\u004f\u0070\u0065\u006e"););

// AuthEvent is an event type that triggers authentication.
type AuthEvent string ;func _bdd (_ac _b .Block )_b .BlockMode {return (*ecbDecrypter )(_cbg (_ac ))};var _ StdHandler =stdHandlerR4 {};

// StdHandler is an interface for standard security handlers.
type StdHandler interface{

// GenerateParams uses owner and user passwords to set encryption parameters and generate an encryption key.
// It assumes that R, P and EncryptMetadata are already set.
GenerateParams (_e *StdEncryptDict ,_gca ,_dba []byte )([]byte ,error );

// Authenticate uses encryption dictionary parameters and the password to calculate
// the document encryption key. It also returns permissions that should be granted to a user.
// In case of failed authentication, it returns empty key and zero permissions with no error.
Authenticate (_gg *StdEncryptDict ,_ae []byte )([]byte ,Permissions ,error );};func (_cf *ecbDecrypter )CryptBlocks (dst ,src []byte ){if len (src )%_cf ._cc !=0{_cb .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");return ;};if len (dst )< len (src ){_cb .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0064\u0065\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");return ;};for len (src )> 0{_cf ._da .Decrypt (dst ,src [:_cf ._cc ]);src =src [_cf ._cc :];dst =dst [_cf ._cc :];};};func _dffc (_cdeg ,_cfda ,_eaf []byte )([]byte ,error ){var (_bgc ,_ffc ,_gec _g .Hash ;);_bgc =_be .New ();_dbf :=make ([]byte ,64);_defg :=_bgc ;_defg .Write (_cdeg );K :=_defg .Sum (_dbf [:0]);_bgb :=make ([]byte ,64*(127+64+48));_fcbfb :=func (_deba int )([]byte ,error ){_dac :=len (_cfda )+len (K )+len (_eaf );_bga :=_bgb [:_dac ];_acae :=copy (_bga ,_cfda );_acae +=copy (_bga [_acae :],K [:]);_acae +=copy (_bga [_acae :],_eaf );if _acae !=_dac {_cb .Log .Error ("E\u0052\u0052\u004f\u0052\u003a\u0020u\u006e\u0065\u0078\u0070\u0065\u0063t\u0065\u0064\u0020\u0072\u006f\u0075\u006ed\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0073\u0069\u007ae\u002e");return nil ,_cd .New ("\u0077\u0072\u006f\u006e\u0067\u0020\u0073\u0069\u007a\u0065");};K1 :=_bgb [:_dac *64];_bebd (K1 ,_dac );_fbf ,_feef :=_edd (K [0:16]);if _feef !=nil {return nil ,_feef ;};_eag :=_b .NewCBCEncrypter (_fbf ,K [16:32]);_eag .CryptBlocks (K1 ,K1 );E :=K1 ;_bgcc :=0;for _cea :=0;_cea < 16;_cea ++{_bgcc +=int (E [_cea ]%3);};var _ecg _g .Hash ;switch _bgcc %3{case 0:_ecg =_bgc ;case 1:if _ffc ==nil {_ffc =_gc .New384 ();};_ecg =_ffc ;case 2:if _gec ==nil {_gec =_gc .New ();};_ecg =_gec ;};_ecg .Reset ();_ecg .Write (E );K =_ecg .Sum (_dbf [:0]);return E ,nil ;};for _cdf :=0;;{E ,_dabg :=_fcbfb (_cdf );if _dabg !=nil {return nil ,_dabg ;};_afa :=uint8 (E [len (E )-1]);_cdf ++;if _cdf >=64&&_afa <=uint8 (_cdf -32){break ;};};return K [:32],nil ;};func (_cec stdHandlerR6 )alg2b (R int ,_dfeb ,_cff ,_ebd []byte )([]byte ,error ){if R ==5{return _ddd (_dfeb );};return _dffc (_dfeb ,_cff ,_ebd );};

// Authenticate implements StdHandler interface.
func (_bcg stdHandlerR4 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){_cb .Log .Trace ("\u0044\u0065b\u0075\u0067\u0067\u0069n\u0067\u0020a\u0075\u0074\u0068\u0065\u006e\u0074\u0069\u0063a\u0074\u0069\u006f\u006e\u0020\u002d\u0020\u006f\u0077\u006e\u0065\u0072 \u0070\u0061\u0073\u0073");_cba ,_eeeb :=_bcg .alg7 (d ,pass );if _eeeb !=nil {return nil ,0,_eeeb ;};if _cba !=nil {_cb .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _cba ,PermOwner ,nil ;};_cb .Log .Trace ("\u0044\u0065bu\u0067\u0067\u0069n\u0067\u0020\u0061\u0075the\u006eti\u0063\u0061\u0074\u0069\u006f\u006e\u0020- \u0075\u0073\u0065\u0072\u0020\u0070\u0061s\u0073");_cba ,_eeeb =_bcg .alg6 (d ,pass );if _eeeb !=nil {return nil ,0,_eeeb ;};if _cba !=nil {_cb .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _cba ,d .P ,nil ;};return nil ,0,nil ;};func (_ba *ecbEncrypter )BlockSize ()int {return _ba ._cc };func (_aca stdHandlerR4 )alg3Key (R int ,_def []byte )[]byte {_eb :=_db .New ();_ce :=_aca .paddedPass (_def );_eb .Write (_ce );if R >=3{for _fa :=0;_fa < 50;_fa ++{_gdc :=_eb .Sum (nil );_eb =_db .New ();_eb .Write (_gdc );};};_fae :=_eb .Sum (nil );if R ==2{_fae =_fae [0:5];}else {_fae =_fae [0:_aca .Length /8];};return _fae ;};type ecb struct{_da _b .Block ;_cc int ;};type stdHandlerR6 struct{};func _edd (_aff []byte )(_b .Block ,error ){_fca ,_feg :=_d .NewCipher (_aff );if _feg !=nil {_cb .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0063\u0072\u0065\u0061\u0074\u0065\u0020A\u0045\u0053\u0020\u0063\u0069p\u0068\u0065r\u003a\u0020\u0025\u0076",_feg );return nil ,_feg ;};return _fca ,nil ;};func (_dd stdHandlerR4 )alg4 (_dcd []byte ,_fab []byte )([]byte ,error ){_eff ,_aec :=_cg .NewCipher (_dcd );if _aec !=nil {return nil ,_cd .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_cgd :=[]byte (_de );_bfg :=make ([]byte ,len (_cgd ));_eff .XORKeyStream (_bfg ,_cgd );return _bfg ,nil ;};

// Permissions is a bitmask of access permissions for a PDF file.
type Permissions uint32 ;func (_fff stdHandlerR6 )alg9 (_cgaaa *StdEncryptDict ,_bcc []byte ,_ag []byte )error {if _ffeg :=_ga ("\u0061\u006c\u0067\u0039","\u004b\u0065\u0079",32,_bcc );_ffeg !=nil {return _ffeg ;};if _baa :=_ga ("\u0061\u006c\u0067\u0039","\u0055",48,_cgaaa .U );_baa !=nil {return _baa ;};var _aee [16]byte ;if _ ,_efc :=_a .ReadFull (_f .Reader ,_aee [:]);_efc !=nil {return _efc ;};_agb :=_aee [0:8];_baac :=_aee [8:16];_agd :=_cgaaa .U [:48];_fgg :=make ([]byte ,len (_ag )+len (_agb )+len (_agd ));_cbff :=copy (_fgg ,_ag );_cbff +=copy (_fgg [_cbff :],_agb );_cbff +=copy (_fgg [_cbff :],_agd );_egd ,_dfg :=_fff .alg2b (_cgaaa .R ,_fgg ,_ag ,_agd );if _dfg !=nil {return _dfg ;};O :=make ([]byte ,len (_egd )+len (_agb )+len (_baac ));_cbff =copy (O ,_egd [:32]);_cbff +=copy (O [_cbff :],_agb );_cbff +=copy (O [_cbff :],_baac );_cgaaa .O =O ;_cbff =len (_ag );_cbff +=copy (_fgg [_cbff :],_baac );_egd ,_dfg =_fff .alg2b (_cgaaa .R ,_fgg ,_ag ,_agd );if _dfg !=nil {return _dfg ;};_gga ,_dfg :=_edd (_egd [:32]);if _dfg !=nil {return _dfg ;};_gad :=make ([]byte ,_d .BlockSize );_gef :=_b .NewCBCEncrypter (_gga ,_gad );OE :=make ([]byte ,32);_gef .CryptBlocks (OE ,_bcc [:32]);_cgaaa .OE =OE ;return nil ;};func (_aa *ecbDecrypter )BlockSize ()int {return _aa ._cc };func (_gab stdHandlerR6 )alg12 (_dbb *StdEncryptDict ,_ccf []byte )([]byte ,error ){if _gcaf :=_ga ("\u0061\u006c\u00671\u0032","\u0055",48,_dbb .U );_gcaf !=nil {return nil ,_gcaf ;};if _beg :=_ga ("\u0061\u006c\u00671\u0032","\u004f",48,_dbb .O );_beg !=nil {return nil ,_beg ;};_agf :=make ([]byte ,len (_ccf )+8+48);_ggaf :=copy (_agf ,_ccf );_ggaf +=copy (_agf [_ggaf :],_dbb .O [32:40]);_ggaf +=copy (_agf [_ggaf :],_dbb .U [0:48]);_gdg ,_dege :=_gab .alg2b (_dbb .R ,_agf ,_ccf ,_dbb .U [0:48]);if _dege !=nil {return nil ,_dege ;};_gdg =_gdg [:32];if !_ca .Equal (_gdg ,_dbb .O [:32]){return nil ,nil ;};return _gdg ,nil ;};const (PermOwner =Permissions (_dg .MaxUint32 );PermPrinting =Permissions (1<<2);PermModify =Permissions (1<<3);PermExtractGraphics =Permissions (1<<4);PermAnnotate =Permissions (1<<5);PermFillForms =Permissions (1<<8);PermDisabilityExtract =Permissions (1<<9);PermRotateInsert =Permissions (1<<10);PermFullPrintQuality =Permissions (1<<11););var _ StdHandler =stdHandlerR6 {};func (_dbc stdHandlerR4 )alg2 (_fcb *StdEncryptDict ,_cde []byte )[]byte {_cb .Log .Trace ("\u0061\u006c\u0067\u0032");_dgb :=_dbc .paddedPass (_cde );_df :=_db .New ();_df .Write (_dgb );_df .Write (_fcb .O );var _aed [4]byte ;_gd .LittleEndian .PutUint32 (_aed [:],uint32 (_fcb .P ));_df .Write (_aed [:]);_cb .Log .Trace ("\u0067o\u0020\u0050\u003a\u0020\u0025\u0020x",_aed );_df .Write ([]byte (_dbc .ID0 ));_cb .Log .Trace ("\u0074\u0068\u0069\u0073\u002e\u0052\u0020\u003d\u0020\u0025d\u0020\u0065\u006e\u0063\u0072\u0079\u0070t\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061\u0020\u0025\u0076",_fcb .R ,_fcb .EncryptMetadata );if (_fcb .R >=4)&&!_fcb .EncryptMetadata {_df .Write ([]byte {0xff,0xff,0xff,0xff});};_ef :=_df .Sum (nil );if _fcb .R >=3{_df =_db .New ();for _aad :=0;_aad < 50;_aad ++{_df .Reset ();_df .Write (_ef [0:_dbc .Length /8]);_ef =_df .Sum (nil );};};if _fcb .R >=3{return _ef [0:_dbc .Length /8];};return _ef [0:5];};func (_fb errInvalidField )Error ()string {return _bg .Sprintf ("\u0025s\u003a\u0020e\u0078\u0070\u0065\u0063t\u0065\u0064\u0020%\u0073\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0074o \u0062\u0065\u0020%\u0064\u0020b\u0079\u0074\u0065\u0073\u002c\u0020g\u006f\u0074 \u0025\u0064",_fb .Func ,_fb .Field ,_fb .Exp ,_fb .Got );};

// GenerateParams is the algorithm opposite to alg2a (R>=5).
// It generates U,O,UE,OE,Perms fields using AESv3 encryption.
// There is no algorithm number assigned to this function in the spec.
// It expects R, P and EncryptMetadata fields to be set.
func (_ggbe stdHandlerR6 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){_dffe :=make ([]byte ,32);if _ ,_edb :=_a .ReadFull (_f .Reader ,_dffe );_edb !=nil {return nil ,_edb ;};d .U =nil ;d .O =nil ;d .UE =nil ;d .OE =nil ;d .Perms =nil ;if len (upass )> 127{upass =upass [:127];};if len (opass )> 127{opass =opass [:127];};if _bgae :=_ggbe .alg8 (d ,_dffe ,upass );_bgae !=nil {return nil ,_bgae ;};if _ecef :=_ggbe .alg9 (d ,_dffe ,opass );_ecef !=nil {return nil ,_ecef ;};if d .R ==5{return _dffe ,nil ;};if _fcaf :=_ggbe .alg10 (d ,_dffe );_fcaf !=nil {return nil ,_fcaf ;};return _dffe ,nil ;};const _de ="\x28\277\116\136\x4e\x75\x8a\x41\x64\000\x4e\x56\377"+"\xfa\001\010\056\x2e\x00\xb6\xd0\x68\076\x80\x2f\014"+"\251\xfe\x64\x53\x69\172";func (_ab stdHandlerR6 )alg11 (_bbdd *StdEncryptDict ,_dad []byte )([]byte ,error ){if _gbg :=_ga ("\u0061\u006c\u00671\u0031","\u0055",48,_bbdd .U );_gbg !=nil {return nil ,_gbg ;};_cgc :=make ([]byte ,len (_dad )+8);_fcg :=copy (_cgc ,_dad );_fcg +=copy (_cgc [_fcg :],_bbdd .U [32:40]);_cca ,_gebc :=_ab .alg2b (_bbdd .R ,_cgc ,_dad ,nil );if _gebc !=nil {return nil ,_gebc ;};_cca =_cca [:32];if !_ca .Equal (_cca ,_bbdd .U [:32]){return nil ,nil ;};return _cca ,nil ;};

// Allowed checks if a set of permissions can be granted.
func (_bddb Permissions )Allowed (p2 Permissions )bool {return _bddb &p2 ==p2 };func (_beb stdHandlerR4 )alg3 (R int ,_gf ,_ec []byte )([]byte ,error ){var _fe []byte ;if len (_ec )> 0{_fe =_beb .alg3Key (R ,_ec );}else {_fe =_beb .alg3Key (R ,_gf );};_gde ,_acab :=_cg .NewCipher (_fe );if _acab !=nil {return nil ,_cd .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_dff :=_beb .paddedPass (_gf );_cfd :=make ([]byte ,len (_dff ));_gde .XORKeyStream (_cfd ,_dff );if R >=3{_ad :=make ([]byte ,len (_fe ));for _dfb :=0;_dfb < 19;_dfb ++{for _bb :=0;_bb < len (_fe );_bb ++{_ad [_bb ]=_fe [_bb ]^byte (_dfb +1);};_bae ,_cdb :=_cg .NewCipher (_ad );if _cdb !=nil {return nil ,_cd .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_bae .XORKeyStream (_cfd ,_cfd );};};return _cfd ,nil ;};func (stdHandlerR4 )paddedPass (_ge []byte )[]byte {_aaf :=make ([]byte ,32);_aae :=copy (_aaf ,_ge );for ;_aae < 32;_aae ++{_aaf [_aae ]=_de [_aae -len (_ge )];};return _aaf ;};func (_cbdd stdHandlerR6 )alg13 (_cdbd *StdEncryptDict ,_baccc []byte )error {if _fba :=_ga ("\u0061\u006c\u00671\u0033","\u004b\u0065\u0079",32,_baccc );_fba !=nil {return _fba ;};if _bbe :=_ga ("\u0061\u006c\u00671\u0033","\u0050\u0065\u0072m\u0073",16,_cdbd .Perms );_bbe !=nil {return _bbe ;};_dde :=make ([]byte ,16);copy (_dde ,_cdbd .Perms [:16]);_aeab ,_bbf :=_d .NewCipher (_baccc [:32]);if _bbf !=nil {return _bbf ;};_eab :=_bdd (_aeab );_eab .CryptBlocks (_dde ,_dde );if !_ca .Equal (_dde [9:12],[]byte ("\u0061\u0064\u0062")){return _cd .New ("\u0064\u0065\u0063o\u0064\u0065\u0064\u0020p\u0065\u0072\u006d\u0069\u0073\u0073\u0069o\u006e\u0073\u0020\u0061\u0072\u0065\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_adc :=Permissions (_gd .LittleEndian .Uint32 (_dde [0:4]));if _adc !=_cdbd .P {return _cd .New ("\u0070\u0065r\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066\u0061il\u0065\u0064");};_fegd :=true ;if _dde [8]=='T'{_fegd =true ;}else if _dde [8]=='F'{_fegd =false ;}else {return _cd .New ("\u0064\u0065\u0063\u006f\u0064\u0065\u0064 \u006d\u0065\u0074a\u0064\u0061\u0074\u0061 \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u006c\u0061\u0067\u0020\u0069\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};if _fegd !=_cdbd .EncryptMetadata {return _cd .New ("\u006d\u0065t\u0061\u0064\u0061\u0074a\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e \u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066a\u0069\u006c\u0065\u0064");};return nil ;};

// StdEncryptDict is a set of additional fields used in standard encryption dictionary.
type StdEncryptDict struct{R int ;P Permissions ;EncryptMetadata bool ;O ,U []byte ;OE ,UE []byte ;Perms []byte ;};func _cbg (_gce _b .Block )*ecb {return &ecb {_da :_gce ,_cc :_gce .BlockSize ()}};