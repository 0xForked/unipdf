//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package security ;import (_dd "bytes";_bd "crypto/aes";_a "crypto/cipher";_ca "crypto/md5";_bb "crypto/rand";_e "crypto/rc4";_ae "crypto/sha256";_ac "crypto/sha512";_d "encoding/binary";_ce "errors";_eb "fmt";_adc "github.com/unidoc/unipdf/v3/common";_ad "hash";
_b "io";_ab "math";);func (_fbd stdHandlerR6 )alg11 (_aeaa *StdEncryptDict ,_aad []byte )([]byte ,error ){if _dccf :=_fa ("\u0061\u006c\u00671\u0031","\u0055",48,_aeaa .U );_dccf !=nil {return nil ,_dccf ;};_ccg :=make ([]byte ,len (_aad )+8);_cgcf :=copy (_ccg ,_aad );
_cgcf +=copy (_ccg [_cgcf :],_aeaa .U [32:40]);_ddc ,_bcc :=_fbd .alg2b (_aeaa .R ,_ccg ,_aad ,nil );if _bcc !=nil {return nil ,_bcc ;};_ddc =_ddc [:32];if !_dd .Equal (_ddc ,_aeaa .U [:32]){return nil ,nil ;};return _ddc ,nil ;};var _ StdHandler =stdHandlerR4 {};
type stdHandlerR4 struct{Length int ;ID0 string ;};func _ec (_de _a .Block )_a .BlockMode {return (*ecbDecrypter )(_f (_de ))};

// NewHandlerR4 creates a new standard security handler for R<=4.
func NewHandlerR4 (id0 string ,length int )StdHandler {return stdHandlerR4 {ID0 :id0 ,Length :length }};func (_cgb stdHandlerR4 )alg6 (_cecb *StdEncryptDict ,_cbd []byte )([]byte ,error ){var (_fcc []byte ;_bcg error ;);_egf :=_cgb .alg2 (_cecb ,_cbd );
if _cecb .R ==2{_fcc ,_bcg =_cgb .alg4 (_egf ,_cbd );}else if _cecb .R >=3{_fcc ,_bcg =_cgb .alg5 (_egf ,_cbd );}else {return nil ,_ce .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};if _bcg !=nil {return nil ,_bcg ;};_adc .Log .Trace ("\u0063\u0068\u0065\u0063k:\u0020\u0025\u0020\u0078\u0020\u003d\u003d\u0020\u0025\u0020\u0078\u0020\u003f",string (_fcc ),string (_cecb .U ));
_ded :=_fcc ;_dde :=_cecb .U ;if _cecb .R >=3{if len (_ded )> 16{_ded =_ded [0:16];};if len (_dde )> 16{_dde =_dde [0:16];};};if !_dd .Equal (_ded ,_dde ){return nil ,nil ;};return _egf ,nil ;};func (_ag *ecbEncrypter )BlockSize ()int {return _ag ._cc };
func _cde (_ageb []byte ,_fag int ){_dgfg :=_fag ;for _dgfg < len (_ageb ){copy (_ageb [_dgfg :],_ageb [:_dgfg ]);_dgfg *=2;};};

// GenerateParams generates and sets O and U parameters for the encryption dictionary.
// It expects R, P and EncryptMetadata fields to be set.
func (_fcae stdHandlerR4 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){O ,_fec :=_fcae .alg3 (d .R ,upass ,opass );if _fec !=nil {_adc .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_fec );
return nil ,_fec ;};d .O =O ;_adc .Log .Trace ("\u0067\u0065\u006e\u0020\u004f\u003a\u0020\u0025\u0020\u0078",O );_aeb :=_fcae .alg2 (d ,upass );U ,_fec :=_fcae .alg5 (_aeb ,upass );if _fec !=nil {_adc .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_fec );
return nil ,_fec ;};d .U =U ;_adc .Log .Trace ("\u0067\u0065\u006e\u0020\u0055\u003a\u0020\u0025\u0020\u0078",U );return _aeb ,nil ;};func (_cce stdHandlerR6 )alg9 (_degg *StdEncryptDict ,_fccd []byte ,_cea []byte )error {if _abf :=_fa ("\u0061\u006c\u0067\u0039","\u004b\u0065\u0079",32,_fccd );
_abf !=nil {return _abf ;};if _bdcg :=_fa ("\u0061\u006c\u0067\u0039","\u0055",48,_degg .U );_bdcg !=nil {return _bdcg ;};var _abe [16]byte ;if _ ,_cag :=_b .ReadFull (_bb .Reader ,_abe [:]);_cag !=nil {return _cag ;};_bbb :=_abe [0:8];_aef :=_abe [8:16];
_edeb :=_degg .U [:48];_dfga :=make ([]byte ,len (_cea )+len (_bbb )+len (_edeb ));_ecdf :=copy (_dfga ,_cea );_ecdf +=copy (_dfga [_ecdf :],_bbb );_ecdf +=copy (_dfga [_ecdf :],_edeb );_eddf ,_fde :=_cce .alg2b (_degg .R ,_dfga ,_cea ,_edeb );if _fde !=nil {return _fde ;
};O :=make ([]byte ,len (_eddf )+len (_bbb )+len (_aef ));_ecdf =copy (O ,_eddf [:32]);_ecdf +=copy (O [_ecdf :],_bbb );_ecdf +=copy (O [_ecdf :],_aef );_degg .O =O ;_ecdf =len (_cea );_ecdf +=copy (_dfga [_ecdf :],_aef );_eddf ,_fde =_cce .alg2b (_degg .R ,_dfga ,_cea ,_edeb );
if _fde !=nil {return _fde ;};_ggc ,_fde :=_gcf (_eddf [:32]);if _fde !=nil {return _fde ;};_ddg :=make ([]byte ,_bd .BlockSize );_gba :=_a .NewCBCEncrypter (_ggc ,_ddg );OE :=make ([]byte ,32);_gba .CryptBlocks (OE ,_fccd [:32]);_degg .OE =OE ;return nil ;
};type ecbDecrypter ecb ;

// StdEncryptDict is a set of additional fields used in standard encryption dictionary.
type StdEncryptDict struct{R int ;P Permissions ;EncryptMetadata bool ;O ,U []byte ;OE ,UE []byte ;Perms []byte ;};

// Authenticate implements StdHandler interface.
func (_baaa stdHandlerR6 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){return _baaa .alg2a (d ,pass );};func _gcf (_bfc []byte )(_a .Block ,error ){_cga ,_def :=_bd .NewCipher (_bfc );if _def !=nil {_adc .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0063\u0072\u0065\u0061\u0074\u0065\u0020A\u0045\u0053\u0020\u0063\u0069p\u0068\u0065r\u003a\u0020\u0025\u0076",_def );
return nil ,_def ;};return _cga ,nil ;};

// Permissions is a bitmask of access permissions for a PDF file.
type Permissions uint32 ;func (_afge stdHandlerR6 )alg2a (_cad *StdEncryptDict ,_gcg []byte )([]byte ,Permissions ,error ){if _dc :=_fa ("\u0061\u006c\u00672\u0061","\u004f",48,_cad .O );_dc !=nil {return nil ,0,_dc ;};if _adcb :=_fa ("\u0061\u006c\u00672\u0061","\u0055",48,_cad .U );
_adcb !=nil {return nil ,0,_adcb ;};if len (_gcg )> 127{_gcg =_gcg [:127];};_gcb ,_deea :=_afge .alg12 (_cad ,_gcg );if _deea !=nil {return nil ,0,_deea ;};var (_aaff []byte ;_egb []byte ;_aea []byte ;);var _befg Permissions ;if len (_gcb )!=0{_befg =PermOwner ;
_cdf :=make ([]byte ,len (_gcg )+8+48);_dbd :=copy (_cdf ,_gcg );_dbd +=copy (_cdf [_dbd :],_cad .O [40:48]);copy (_cdf [_dbd :],_cad .U [0:48]);_aaff =_cdf ;_egb =_cad .OE ;_aea =_cad .U [0:48];}else {_gcb ,_deea =_afge .alg11 (_cad ,_gcg );if _deea ==nil &&len (_gcb )==0{_gcb ,_deea =_afge .alg11 (_cad ,[]byte (""));
};if _deea !=nil {return nil ,0,_deea ;}else if len (_gcb )==0{return nil ,0,nil ;};_befg =_cad .P ;_defc :=make ([]byte ,len (_gcg )+8);_gf :=copy (_defc ,_gcg );copy (_defc [_gf :],_cad .U [40:48]);_aaff =_defc ;_egb =_cad .UE ;_aea =nil ;};if _cef :=_fa ("\u0061\u006c\u00672\u0061","\u004b\u0065\u0079",32,_egb );
_cef !=nil {return nil ,0,_cef ;};_egb =_egb [:32];_ggb ,_deea :=_afge .alg2b (_cad .R ,_aaff ,_gcg ,_aea );if _deea !=nil {return nil ,0,_deea ;};_agg ,_deea :=_bd .NewCipher (_ggb [:32]);if _deea !=nil {return nil ,0,_deea ;};_ggf :=make ([]byte ,_bd .BlockSize );
_gge :=_a .NewCBCDecrypter (_agg ,_ggf );_bfa :=make ([]byte ,32);_gge .CryptBlocks (_bfa ,_egb );if _cad .R ==5{return _bfa ,_befg ,nil ;};_deea =_afge .alg13 (_cad ,_bfa );if _deea !=nil {return nil ,0,_deea ;};return _bfa ,_befg ,nil ;};func (_ecd stdHandlerR4 )alg5 (_fgd []byte ,_fb []byte )([]byte ,error ){_fca :=_ca .New ();
_fca .Write ([]byte (_dfd ));_fca .Write ([]byte (_ecd .ID0 ));_cd :=_fca .Sum (nil );_adc .Log .Trace ("\u0061\u006c\u0067\u0035");_adc .Log .Trace ("\u0065k\u0065\u0079\u003a\u0020\u0025\u0020x",_fgd );_adc .Log .Trace ("\u0049D\u003a\u0020\u0025\u0020\u0078",_ecd .ID0 );
if len (_cd )!=16{return nil ,_ce .New ("\u0068a\u0073\u0068\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074\u0020\u0031\u0036\u0020\u0062\u0079\u0074\u0065\u0073");};_aeg ,_eg :=_e .NewCipher (_fgd );if _eg !=nil {return nil ,_ce .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_dfg :=make ([]byte ,16);_aeg .XORKeyStream (_dfg ,_cd );_afg :=make ([]byte ,len (_fgd ));for _cbb :=0;_cbb < 19;_cbb ++{for _dfc :=0;_dfc < len (_fgd );_dfc ++{_afg [_dfc ]=_fgd [_dfc ]^byte (_cbb +1);};_aeg ,_eg =_e .NewCipher (_afg );if _eg !=nil {return nil ,_ce .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_aeg .XORKeyStream (_dfg ,_dfg );_adc .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u002c\u0020\u0065\u006b\u0065\u0079:\u0020\u0025\u0020\u0078",_cbb ,_afg );_adc .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0020\u0078",_cbb ,_dfg );
};_aae :=make ([]byte ,32);for _feb :=0;_feb < 16;_feb ++{_aae [_feb ]=_dfg [_feb ];};_ ,_eg =_bb .Read (_aae [16:32]);if _eg !=nil {return nil ,_ce .New ("\u0066a\u0069\u006c\u0065\u0064 \u0074\u006f\u0020\u0067\u0065n\u0020r\u0061n\u0064\u0020\u006e\u0075\u006d\u0062\u0065r");
};return _aae ,nil ;};func (_ecdg stdHandlerR6 )alg2b (R int ,_dfb ,_dfcf ,_dge []byte )([]byte ,error ){if R ==5{return _aab (_dfb );};return _dga (_dfb ,_dfcf ,_dge );};func (_egg stdHandlerR6 )alg10 (_fea *StdEncryptDict ,_cdfb []byte )error {if _eca :=_fa ("\u0061\u006c\u00671\u0030","\u004b\u0065\u0079",32,_cdfb );
_eca !=nil {return _eca ;};_eda :=uint64 (uint32 (_fea .P ))|(_ab .MaxUint32 <<32);Perms :=make ([]byte ,16);_d .LittleEndian .PutUint64 (Perms [:8],_eda );if _fea .EncryptMetadata {Perms [8]='T';}else {Perms [8]='F';};copy (Perms [9:12],"\u0061\u0064\u0062");
if _ ,_aeab :=_b .ReadFull (_bb .Reader ,Perms [12:16]);_aeab !=nil {return _aeab ;};_gef ,_cae :=_gcf (_cdfb [:32]);if _cae !=nil {return _cae ;};_bba :=_aa (_gef );_bba .CryptBlocks (Perms ,Perms );_fea .Perms =Perms [:16];return nil ;};func _aab (_daca []byte )([]byte ,error ){_dcd :=_ae .New ();
_dcd .Write (_daca );return _dcd .Sum (nil ),nil ;};type ecb struct{_bf _a .Block ;_cc int ;};func _fa (_be ,_ba string ,_da int ,_adg []byte )error {if len (_adg )< _da {return errInvalidField {Func :_be ,Field :_ba ,Exp :_da ,Got :len (_adg )};};return nil ;
};

// StdHandler is an interface for standard security handlers.
type StdHandler interface{

// GenerateParams uses owner and user passwords to set encryption parameters and generate an encryption key.
// It assumes that R, P and EncryptMetadata are already set.
GenerateParams (_ff *StdEncryptDict ,_df ,_fc []byte )([]byte ,error );

// Authenticate uses encryption dictionary parameters and the password to calculate
// the document encryption key. It also returns permissions that should be granted to a user.
// In case of failed authentication, it returns empty key and zero permissions with no error.
Authenticate (_bbg *StdEncryptDict ,_ga []byte )([]byte ,Permissions ,error );};

// Allowed checks if a set of permissions can be granted.
func (_caf Permissions )Allowed (p2 Permissions )bool {return _caf &p2 ==p2 };const (PermOwner =Permissions (_ab .MaxUint32 );PermPrinting =Permissions (1<<2);PermModify =Permissions (1<<3);PermExtractGraphics =Permissions (1<<4);PermAnnotate =Permissions (1<<5);
PermFillForms =Permissions (1<<8);PermDisabilityExtract =Permissions (1<<9);PermRotateInsert =Permissions (1<<10);PermFullPrintQuality =Permissions (1<<11););type ecbEncrypter ecb ;func _aa (_g _a .Block )_a .BlockMode {return (*ecbEncrypter )(_f (_g ))};
func (_fd stdHandlerR6 )alg8 (_ada *StdEncryptDict ,_fae []byte ,_eeb []byte )error {if _ggg :=_fa ("\u0061\u006c\u0067\u0038","\u004b\u0065\u0079",32,_fae );_ggg !=nil {return _ggg ;};var _fcaf [16]byte ;if _ ,_befb :=_b .ReadFull (_bb .Reader ,_fcaf [:]);
_befb !=nil {return _befb ;};_fgdf :=_fcaf [0:8];_fdc :=_fcaf [8:16];_dcb :=make ([]byte ,len (_eeb )+len (_fgdf ));_bgd :=copy (_dcb ,_eeb );copy (_dcb [_bgd :],_fgdf );_ccd ,_bdc :=_fd .alg2b (_ada .R ,_dcb ,_eeb ,nil );if _bdc !=nil {return _bdc ;};
U :=make ([]byte ,len (_ccd )+len (_fgdf )+len (_fdc ));_bgd =copy (U ,_ccd [:32]);_bgd +=copy (U [_bgd :],_fgdf );copy (U [_bgd :],_fdc );_ada .U =U ;_bgd =len (_eeb );copy (_dcb [_bgd :],_fdc );_ccd ,_bdc =_fd .alg2b (_ada .R ,_dcb ,_eeb ,nil );if _bdc !=nil {return _bdc ;
};_fdf ,_bdc :=_gcf (_ccd [:32]);if _bdc !=nil {return _bdc ;};_gd :=make ([]byte ,_bd .BlockSize );_dfcfa :=_a .NewCBCEncrypter (_fdf ,_gd );UE :=make ([]byte ,32);_dfcfa .CryptBlocks (UE ,_fae [:32]);_ada .UE =UE ;return nil ;};type errInvalidField struct{Func string ;
Field string ;Exp int ;Got int ;};func _dga (_eeg ,_fbfe ,_dbf []byte )([]byte ,error ){var (_cbga ,_bed ,_deag _ad .Hash ;);_cbga =_ae .New ();_dcc :=make ([]byte ,64);_bgc :=_cbga ;_bgc .Write (_eeg );K :=_bgc .Sum (_dcc [:0]);_defb :=make ([]byte ,64*(127+64+48));
_geb :=func (_bfd int )([]byte ,error ){_fbb :=len (_fbfe )+len (K )+len (_dbf );_feg :=_defb [:_fbb ];_cge :=copy (_feg ,_fbfe );_cge +=copy (_feg [_cge :],K [:]);_cge +=copy (_feg [_cge :],_dbf );if _cge !=_fbb {_adc .Log .Error ("E\u0052\u0052\u004f\u0052\u003a\u0020u\u006e\u0065\u0078\u0070\u0065\u0063t\u0065\u0064\u0020\u0072\u006f\u0075\u006ed\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0073\u0069\u007ae\u002e");
return nil ,_ce .New ("\u0077\u0072\u006f\u006e\u0067\u0020\u0073\u0069\u007a\u0065");};K1 :=_defb [:_fbb *64];_cde (K1 ,_fbb );_cfb ,_dfdc :=_gcf (K [0:16]);if _dfdc !=nil {return nil ,_dfdc ;};_afa :=_a .NewCBCEncrypter (_cfb ,K [16:32]);_afa .CryptBlocks (K1 ,K1 );
E :=K1 ;_adga :=0;for _dae :=0;_dae < 16;_dae ++{_adga +=int (E [_dae ]%3);};var _decc _ad .Hash ;switch _adga %3{case 0:_decc =_cbga ;case 1:if _bed ==nil {_bed =_ac .New384 ();};_decc =_bed ;case 2:if _deag ==nil {_deag =_ac .New ();};_decc =_deag ;};
_decc .Reset ();_decc .Write (E );K =_decc .Sum (_dcc [:0]);return E ,nil ;};for _ddf :=0;;{E ,_bbfa :=_geb (_ddf );if _bbfa !=nil {return nil ,_bbfa ;};_gab :=E [len (E )-1];_ddf ++;if _ddf >=64&&_gab <=uint8 (_ddf -32){break ;};};return K [:32],nil ;
};

// GenerateParams is the algorithm opposite to alg2a (R>=5).
// It generates U,O,UE,OE,Perms fields using AESv3 encryption.
// There is no algorithm number assigned to this function in the spec.
// It expects R, P and EncryptMetadata fields to be set.
func (_decf stdHandlerR6 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){_bgcd :=make ([]byte ,32);if _ ,_ccgc :=_b .ReadFull (_bb .Reader ,_bgcd );_ccgc !=nil {return nil ,_ccgc ;};d .U =nil ;d .O =nil ;d .UE =nil ;d .OE =nil ;
d .Perms =nil ;if len (upass )> 127{upass =upass [:127];};if len (opass )> 127{opass =opass [:127];};if _add :=_decf .alg8 (d ,_bgcd ,upass );_add !=nil {return nil ,_add ;};if _fee :=_decf .alg9 (d ,_bgcd ,opass );_fee !=nil {return nil ,_fee ;};if d .R ==5{return _bgcd ,nil ;
};if _edb :=_decf .alg10 (d ,_bgcd );_edb !=nil {return nil ,_edb ;};return _bgcd ,nil ;};func (_deg *ecbDecrypter )CryptBlocks (dst ,src []byte ){if len (src )%_deg ._cc !=0{_adc .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_adc .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0064\u0065\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_deg ._bf .Decrypt (dst ,src [:_deg ._cc ]);src =src [_deg ._cc :];dst =dst [_deg ._cc :];};};var _ StdHandler =stdHandlerR6 {};func (stdHandlerR4 )paddedPass (_ge []byte )[]byte {_beg :=make ([]byte ,32);_dee :=copy (_beg ,_ge );
for ;_dee < 32;_dee ++{_beg [_dee ]=_dfd [_dee -len (_ge )];};return _beg ;};func (_dacf stdHandlerR4 )alg3Key (R int ,_aaf []byte )[]byte {_geg :=_ca .New ();_dea :=_dacf .paddedPass (_aaf );_geg .Write (_dea );if R >=3{for _bbf :=0;_bbf < 50;_bbf ++{_cf :=_geg .Sum (nil );
_geg =_ca .New ();_geg .Write (_cf );};};_gg :=_geg .Sum (nil );if R ==2{_gg =_gg [0:5];}else {_gg =_gg [0:_dacf .Length /8];};return _gg ;};func (_cb *ecbEncrypter )CryptBlocks (dst ,src []byte ){if len (src )%_cb ._cc !=0{_adc .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_adc .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_cb ._bf .Encrypt (dst ,src [:_cb ._cc ]);src =src [_cb ._cc :];dst =dst [_cb ._cc :];};};func (_gb *ecbDecrypter )BlockSize ()int {return _gb ._cc };func (_dec stdHandlerR4 )alg3 (R int ,_db ,_ed []byte )([]byte ,error ){var _cgc []byte ;
if len (_ed )> 0{_cgc =_dec .alg3Key (R ,_ed );}else {_cgc =_dec .alg3Key (R ,_db );};_ee ,_bg :=_e .NewCipher (_cgc );if _bg !=nil {return nil ,_ce .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_gc :=_dec .paddedPass (_db );
_fff :=make ([]byte ,len (_gc ));_ee .XORKeyStream (_fff ,_gc );if R >=3{_bbgf :=make ([]byte ,len (_cgc ));for _gcd :=0;_gcd < 19;_gcd ++{for _dab :=0;_dab < len (_cgc );_dab ++{_bbgf [_dab ]=_cgc [_dab ]^byte (_gcd +1);};_af ,_cfg :=_e .NewCipher (_bbgf );
if _cfg !=nil {return nil ,_ce .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_af .XORKeyStream (_fff ,_fff );};};return _fff ,nil ;};

// AuthEvent is an event type that triggers authentication.
type AuthEvent string ;func (_ggd stdHandlerR4 )alg4 (_ea []byte ,_fcg []byte )([]byte ,error ){_aee ,_afb :=_e .NewCipher (_ea );if _afb !=nil {return nil ,_ce .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};
_ffd :=[]byte (_dfd );_ffb :=make ([]byte ,len (_ffd ));_aee .XORKeyStream (_ffb ,_ffd );return _ffb ,nil ;};const (EventDocOpen =AuthEvent ("\u0044o\u0063\u004f\u0070\u0065\u006e");EventEFOpen =AuthEvent ("\u0045\u0046\u004f\u0070\u0065\u006e"););const _dfd ="\x28\277\116\136\x4e\x75\x8a\x41\x64\000\x4e\x56\377"+"\xfa\001\010\056\x2e\x00\xb6\xd0\x68\076\x80\x2f\014"+"\251\xfe\x64\x53\x69\172";


// Authenticate implements StdHandler interface.
func (_dgf stdHandlerR4 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){_adc .Log .Trace ("\u0044\u0065b\u0075\u0067\u0067\u0069n\u0067\u0020a\u0075\u0074\u0068\u0065\u006e\u0074\u0069\u0063a\u0074\u0069\u006f\u006e\u0020\u002d\u0020\u006f\u0077\u006e\u0065\u0072 \u0070\u0061\u0073\u0073");
_cbg ,_afc :=_dgf .alg7 (d ,pass );if _afc !=nil {return nil ,0,_afc ;};if _cbg !=nil {_adc .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _cbg ,PermOwner ,nil ;
};_adc .Log .Trace ("\u0044\u0065bu\u0067\u0067\u0069n\u0067\u0020\u0061\u0075the\u006eti\u0063\u0061\u0074\u0069\u006f\u006e\u0020- \u0075\u0073\u0065\u0072\u0020\u0070\u0061s\u0073");_cbg ,_afc =_dgf .alg6 (d ,pass );if _afc !=nil {return nil ,0,_afc ;
};if _cbg !=nil {_adc .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _cbg ,d .P ,nil ;};return nil ,0,nil ;};

// NewHandlerR6 creates a new standard security handler for R=5 and R=6.
func NewHandlerR6 ()StdHandler {return stdHandlerR6 {}};func (_acb stdHandlerR6 )alg13 (_cfae *StdEncryptDict ,_bff []byte )error {if _ccea :=_fa ("\u0061\u006c\u00671\u0033","\u004b\u0065\u0079",32,_bff );_ccea !=nil {return _ccea ;};if _efc :=_fa ("\u0061\u006c\u00671\u0033","\u0050\u0065\u0072m\u0073",16,_cfae .Perms );
_efc !=nil {return _efc ;};_gabb :=make ([]byte ,16);copy (_gabb ,_cfae .Perms [:16]);_cbc ,_ace :=_bd .NewCipher (_bff [:32]);if _ace !=nil {return _ace ;};_cba :=_ec (_cbc );_cba .CryptBlocks (_gabb ,_gabb );if !_dd .Equal (_gabb [9:12],[]byte ("\u0061\u0064\u0062")){return _ce .New ("\u0064\u0065\u0063o\u0064\u0065\u0064\u0020p\u0065\u0072\u006d\u0069\u0073\u0073\u0069o\u006e\u0073\u0020\u0061\u0072\u0065\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};_dgae :=Permissions (_d .LittleEndian .Uint32 (_gabb [0:4]));if _dgae !=_cfae .P {return _ce .New ("\u0070\u0065r\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066\u0061il\u0065\u0064");
};var _dbdb bool ;if _gabb [8]=='T'{_dbdb =true ;}else if _gabb [8]=='F'{_dbdb =false ;}else {return _ce .New ("\u0064\u0065\u0063\u006f\u0064\u0065\u0064 \u006d\u0065\u0074a\u0064\u0061\u0074\u0061 \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u006c\u0061\u0067\u0020\u0069\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};if _dbdb !=_cfae .EncryptMetadata {return _ce .New ("\u006d\u0065t\u0061\u0064\u0061\u0074a\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e \u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066a\u0069\u006c\u0065\u0064");
};return nil ;};func _f (_acd _a .Block )*ecb {return &ecb {_bf :_acd ,_cc :_acd .BlockSize ()}};func (_aag stdHandlerR4 )alg7 (_ffg *StdEncryptDict ,_gae []byte )([]byte ,error ){_cfa :=_aag .alg3Key (_ffg .R ,_gae );_bee :=make ([]byte ,len (_ffg .O ));
if _ffg .R ==2{_bcb ,_fef :=_e .NewCipher (_cfa );if _fef !=nil {return nil ,_ce .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_bcb .XORKeyStream (_bee ,_ffg .O );}else if _ffg .R >=3{_bef :=append ([]byte {},_ffg .O ...);
for _dbg :=0;_dbg < 20;_dbg ++{_ede :=append ([]byte {},_cfa ...);for _edd :=0;_edd < len (_cfa );_edd ++{_ede [_edd ]^=byte (19-_dbg );};_eac ,_dg :=_e .NewCipher (_ede );if _dg !=nil {return nil ,_ce .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");
};_eac .XORKeyStream (_bee ,_bef );_bef =append ([]byte {},_bee ...);};}else {return nil ,_ce .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};_aga ,_fbf :=_aag .alg6 (_ffg ,_bee );if _fbf !=nil {return nil ,nil ;};return _aga ,nil ;};func (_bc errInvalidField )Error ()string {return _eb .Sprintf ("\u0025s\u003a\u0020e\u0078\u0070\u0065\u0063t\u0065\u0064\u0020%\u0073\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0074o \u0062\u0065\u0020%\u0064\u0020b\u0079\u0074\u0065\u0073\u002c\u0020g\u006f\u0074 \u0025\u0064",_bc .Func ,_bc .Field ,_bc .Exp ,_bc .Got );
};func (_bbc stdHandlerR4 )alg2 (_cec *StdEncryptDict ,_cg []byte )[]byte {_adc .Log .Trace ("\u0061\u006c\u0067\u0032");_fe :=_bbc .paddedPass (_cg );_fg :=_ca .New ();_fg .Write (_fe );_fg .Write (_cec .O );var _aca [4]byte ;_d .LittleEndian .PutUint32 (_aca [:],uint32 (_cec .P ));
_fg .Write (_aca [:]);_adc .Log .Trace ("\u0067o\u0020\u0050\u003a\u0020\u0025\u0020x",_aca );_fg .Write ([]byte (_bbc .ID0 ));_adc .Log .Trace ("\u0074\u0068\u0069\u0073\u002e\u0052\u0020\u003d\u0020\u0025d\u0020\u0065\u006e\u0063\u0072\u0079\u0070t\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061\u0020\u0025\u0076",_cec .R ,_cec .EncryptMetadata );
if (_cec .R >=4)&&!_cec .EncryptMetadata {_fg .Write ([]byte {0xff,0xff,0xff,0xff});};_age :=_fg .Sum (nil );if _cec .R >=3{_fg =_ca .New ();for _bbd :=0;_bbd < 50;_bbd ++{_fg .Reset ();_fg .Write (_age [0:_bbc .Length /8]);_age =_fg .Sum (nil );};};if _cec .R >=3{return _age [0:_bbc .Length /8];
};return _age [0:5];};func (_dccg stdHandlerR6 )alg12 (_gbde *StdEncryptDict ,_baa []byte )([]byte ,error ){if _gda :=_fa ("\u0061\u006c\u00671\u0032","\u0055",48,_gbde .U );_gda !=nil {return nil ,_gda ;};if _bad :=_fa ("\u0061\u006c\u00671\u0032","\u004f",48,_gbde .O );
_bad !=nil {return nil ,_bad ;};_egd :=make ([]byte ,len (_baa )+8+48);_edef :=copy (_egd ,_baa );_edef +=copy (_egd [_edef :],_gbde .O [32:40]);_edef +=copy (_egd [_edef :],_gbde .U [0:48]);_eee ,_ef :=_dccg .alg2b (_gbde .R ,_egd ,_baa ,_gbde .U [0:48]);
if _ef !=nil {return nil ,_ef ;};_eee =_eee [:32];if !_dd .Equal (_eee ,_gbde .O [:32]){return nil ,nil ;};return _eee ,nil ;};type stdHandlerR6 struct{};