//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package security ;import (_fd "bytes";_e "crypto/aes";_b "crypto/cipher";_gd "crypto/md5";_a "crypto/rand";_cg "crypto/rc4";_bc "crypto/sha256";_bf "crypto/sha512";_f "encoding/binary";_cb "errors";_eg "fmt";_ge "github.com/unidoc/unipdf/v3/common";_g "hash";
_ca "io";_af "math";);func (_afc *ecbEncrypter )CryptBlocks (dst ,src []byte ){if len (src )%_afc ._dc !=0{_ge .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_ge .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_afc ._d .Encrypt (dst ,src [:_afc ._dc ]);src =src [_afc ._dc :];dst =dst [_afc ._dc :];};};func (_dfdc stdHandlerR4 )alg4 (_bfe []byte ,_ccf []byte )([]byte ,error ){_bac ,_bfee :=_cg .NewCipher (_bfe );if _bfee !=nil {return nil ,_cb .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_bb :=[]byte (_eff );_ac :=make ([]byte ,len (_bb ));_bac .XORKeyStream (_ac ,_bb );return _ac ,nil ;};func (_de stdHandlerR4 )alg3Key (R int ,_fa []byte )[]byte {_caa :=_gd .New ();_edg :=_de .paddedPass (_fa );_caa .Write (_edg );if R >=3{for _edaf :=0;
_edaf < 50;_edaf ++{_bg :=_caa .Sum (nil );_caa =_gd .New ();_caa .Write (_bg );};};_aad :=_caa .Sum (nil );if R ==2{_aad =_aad [0:5];}else {_aad =_aad [0:_de .Length /8];};return _aad ;};func _fda (_fdgf []byte )([]byte ,error ){_cce :=_bc .New ();_cce .Write (_fdgf );
return _cce .Sum (nil ),nil ;};func _ggc (_ffe []byte )(_b .Block ,error ){_cge ,_eea :=_e .NewCipher (_ffe );if _eea !=nil {_ge .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0063\u0072\u0065\u0061\u0074\u0065\u0020A\u0045\u0053\u0020\u0063\u0069p\u0068\u0065r\u003a\u0020\u0025\u0076",_eea );
return nil ,_eea ;};return _cge ,nil ;};

// GenerateParams generates and sets O and U parameters for the encryption dictionary.
// It expects R, P and EncryptMetadata fields to be set.
func (_eb stdHandlerR4 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){O ,_aaa :=_eb .alg3 (d .R ,upass ,opass );if _aaa !=nil {_ge .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_aaa );
return nil ,_aaa ;};d .O =O ;_ge .Log .Trace ("\u0067\u0065\u006e\u0020\u004f\u003a\u0020\u0025\u0020\u0078",O );_dg :=_eb .alg2 (d ,upass );U ,_aaa :=_eb .alg5 (_dg ,upass );if _aaa !=nil {_ge .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_aaa );
return nil ,_aaa ;};d .U =U ;_ge .Log .Trace ("\u0067\u0065\u006e\u0020\u0055\u003a\u0020\u0025\u0020\u0078",U );return _dg ,nil ;};func _ba (_bd _b .Block )_b .BlockMode {return (*ecbDecrypter )(_df (_bd ))};type ecbEncrypter ecb ;func (_fe *ecbDecrypter )BlockSize ()int {return _fe ._dc };
var _ StdHandler =stdHandlerR6 {};func (_ec errInvalidField )Error ()string {return _eg .Sprintf ("\u0025s\u003a\u0020e\u0078\u0070\u0065\u0063t\u0065\u0064\u0020%\u0073\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0074o \u0062\u0065\u0020%\u0064\u0020b\u0079\u0074\u0065\u0073\u002c\u0020g\u006f\u0074 \u0025\u0064",_ec .Func ,_ec .Field ,_ec .Exp ,_ec .Got );
};func (_adf stdHandlerR4 )alg5 (_eabf []byte ,_cf []byte )([]byte ,error ){_fae :=_gd .New ();_fae .Write ([]byte (_eff ));_fae .Write ([]byte (_adf .ID0 ));_fec :=_fae .Sum (nil );_ge .Log .Trace ("\u0061\u006c\u0067\u0035");_ge .Log .Trace ("\u0065k\u0065\u0079\u003a\u0020\u0025\u0020x",_eabf );
_ge .Log .Trace ("\u0049D\u003a\u0020\u0025\u0020\u0078",_adf .ID0 );if len (_fec )!=16{return nil ,_cb .New ("\u0068a\u0073\u0068\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074\u0020\u0031\u0036\u0020\u0062\u0079\u0074\u0065\u0073");};_cff ,_ff :=_cg .NewCipher (_eabf );
if _ff !=nil {return nil ,_cb .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_fbaf :=make ([]byte ,16);_cff .XORKeyStream (_fbaf ,_fec );_gg :=make ([]byte ,len (_eabf ));for _ecf :=0;_ecf < 19;_ecf ++{for _efg :=0;
_efg < len (_eabf );_efg ++{_gg [_efg ]=_eabf [_efg ]^byte (_ecf +1);};_cff ,_ff =_cg .NewCipher (_gg );if _ff !=nil {return nil ,_cb .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_cff .XORKeyStream (_fbaf ,_fbaf );
_ge .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u002c\u0020\u0065\u006b\u0065\u0079:\u0020\u0025\u0020\u0078",_ecf ,_gg );_ge .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0020\u0078",_ecf ,_fbaf );};_gf :=make ([]byte ,32);
for _db :=0;_db < 16;_db ++{_gf [_db ]=_fbaf [_db ];};_ ,_ff =_a .Read (_gf [16:32]);if _ff !=nil {return nil ,_cb .New ("\u0066a\u0069\u006c\u0065\u0064 \u0074\u006f\u0020\u0067\u0065n\u0020r\u0061n\u0064\u0020\u006e\u0075\u006d\u0062\u0065r");};return _gf ,nil ;
};func _ee (_cbe ,_dfdb string ,_egf int ,_ef []byte )error {if len (_ef )< _egf {return errInvalidField {Func :_cbe ,Field :_dfdb ,Exp :_egf ,Got :len (_ef )};};return nil ;};

// Permissions is a bitmask of access permissions for a PDF file.
type Permissions uint32 ;func (_edbc stdHandlerR6 )alg10 (_bbe *StdEncryptDict ,_gbg []byte )error {if _aca :=_ee ("\u0061\u006c\u00671\u0030","\u004b\u0065\u0079",32,_gbg );_aca !=nil {return _aca ;};_ceaf :=uint64 (uint32 (_bbe .P ))|(_af .MaxUint32 <<32);
Perms :=make ([]byte ,16);_f .LittleEndian .PutUint64 (Perms [:8],_ceaf );if _bbe .EncryptMetadata {Perms [8]='T';}else {Perms [8]='F';};copy (Perms [9:12],"\u0061\u0064\u0062");if _ ,_edfg :=_ca .ReadFull (_a .Reader ,Perms [12:16]);_edfg !=nil {return _edfg ;
};_bge ,_effe :=_ggc (_gbg [:32]);if _effe !=nil {return _effe ;};_ffa :=_ab (_bge );_ffa .CryptBlocks (Perms ,Perms );_bbe .Perms =Perms [:16];return nil ;};

// GenerateParams is the algorithm opposite to alg2a (R>=5).
// It generates U,O,UE,OE,Perms fields using AESv3 encryption.
// There is no algorithm number assigned to this function in the spec.
// It expects R, P and EncryptMetadata fields to be set.
func (_dddb stdHandlerR6 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){_ddb :=make ([]byte ,32);if _ ,_gdg :=_ca .ReadFull (_a .Reader ,_ddb );_gdg !=nil {return nil ,_gdg ;};d .U =nil ;d .O =nil ;d .UE =nil ;d .OE =nil ;d .Perms =nil ;
if len (upass )> 127{upass =upass [:127];};if len (opass )> 127{opass =opass [:127];};if _ffcg :=_dddb .alg8 (d ,_ddb ,upass );_ffcg !=nil {return nil ,_ffcg ;};if _cbde :=_dddb .alg9 (d ,_ddb ,opass );_cbde !=nil {return nil ,_cbde ;};if d .R ==5{return _ddb ,nil ;
};if _efc :=_dddb .alg10 (d ,_ddb );_efc !=nil {return nil ,_efc ;};return _ddb ,nil ;};

// AuthEvent is an event type that triggers authentication.
type AuthEvent string ;func (_cegg stdHandlerR4 )alg7 (_bbb *StdEncryptDict ,_ecg []byte )([]byte ,error ){_dag :=_cegg .alg3Key (_bbb .R ,_ecg );_dfg :=make ([]byte ,len (_bbb .O ));if _bbb .R ==2{_cffa ,_aaf :=_cg .NewCipher (_dag );if _aaf !=nil {return nil ,_cb .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");
};_cffa .XORKeyStream (_dfg ,_bbb .O );}else if _bbb .R >=3{_gea :=append ([]byte {},_bbb .O ...);for _gga :=0;_gga < 20;_gga ++{_afg :=append ([]byte {},_dag ...);for _acg :=0;_acg < len (_dag );_acg ++{_afg [_acg ]^=byte (19-_gga );};_dd ,_cde :=_cg .NewCipher (_afg );
if _cde !=nil {return nil ,_cb .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_dd .XORKeyStream (_dfg ,_gea );_gea =append ([]byte {},_dfg ...);};}else {return nil ,_cb .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");
};_bfc ,_gc :=_cegg .alg6 (_bbb ,_dfg );if _gc !=nil {return nil ,nil ;};return _bfc ,nil ;};

// Authenticate implements StdHandler interface.
func (_egfa stdHandlerR4 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){_ge .Log .Trace ("\u0044\u0065b\u0075\u0067\u0067\u0069n\u0067\u0020a\u0075\u0074\u0068\u0065\u006e\u0074\u0069\u0063a\u0074\u0069\u006f\u006e\u0020\u002d\u0020\u006f\u0077\u006e\u0065\u0072 \u0070\u0061\u0073\u0073");
_edf ,_edb :=_egfa .alg7 (d ,pass );if _edb !=nil {return nil ,0,_edb ;};if _edf !=nil {_ge .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _edf ,PermOwner ,nil ;
};_ge .Log .Trace ("\u0044\u0065bu\u0067\u0067\u0069n\u0067\u0020\u0061\u0075the\u006eti\u0063\u0061\u0074\u0069\u006f\u006e\u0020- \u0075\u0073\u0065\u0072\u0020\u0070\u0061s\u0073");_edf ,_edb =_egfa .alg6 (d ,pass );if _edb !=nil {return nil ,0,_edb ;
};if _edf !=nil {_ge .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _edf ,d .P ,nil ;};return nil ,0,nil ;};

// NewHandlerR4 creates a new standard security handler for R<=4.
func NewHandlerR4 (id0 string ,length int )StdHandler {return stdHandlerR4 {ID0 :id0 ,Length :length }};func (stdHandlerR4 )paddedPass (_baf []byte )[]byte {_ae :=make ([]byte ,32);_ecb :=copy (_ae ,_baf );for ;_ecb < 32;_ecb ++{_ae [_ecb ]=_eff [_ecb -len (_baf )];
};return _ae ;};func (_gbga stdHandlerR6 )alg12 (_aadg *StdEncryptDict ,_cbc []byte )([]byte ,error ){if _faf :=_ee ("\u0061\u006c\u00671\u0032","\u0055",48,_aadg .U );_faf !=nil {return nil ,_faf ;};if _agb :=_ee ("\u0061\u006c\u00671\u0032","\u004f",48,_aadg .O );
_agb !=nil {return nil ,_agb ;};_fbg :=make ([]byte ,len (_cbc )+8+48);_ccd :=copy (_fbg ,_cbc );_ccd +=copy (_fbg [_ccd :],_aadg .O [32:40]);_ccd +=copy (_fbg [_ccd :],_aadg .U [0:48]);_bfb ,_bfg :=_gbga .alg2b (_aadg .R ,_fbg ,_cbc ,_aadg .U [0:48]);
if _bfg !=nil {return nil ,_bfg ;};_bfb =_bfb [:32];if !_fd .Equal (_bfb ,_aadg .O [:32]){return nil ,nil ;};return _bfb ,nil ;};func (_bag *ecbDecrypter )CryptBlocks (dst ,src []byte ){if len (src )%_bag ._dc !=0{_ge .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_ge .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0064\u0065\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_bag ._d .Decrypt (dst ,src [:_bag ._dc ]);src =src [_bag ._dc :];dst =dst [_bag ._dc :];};};const (PermOwner =Permissions (_af .MaxUint32 );PermPrinting =Permissions (1<<2);PermModify =Permissions (1<<3);PermExtractGraphics =Permissions (1<<4);
PermAnnotate =Permissions (1<<5);PermFillForms =Permissions (1<<8);PermDisabilityExtract =Permissions (1<<9);PermRotateInsert =Permissions (1<<10);PermFullPrintQuality =Permissions (1<<11););func (_ag stdHandlerR4 )alg6 (_edgb *StdEncryptDict ,_deff []byte )([]byte ,error ){var (_geg []byte ;
_daf error ;);_bef :=_ag .alg2 (_edgb ,_deff );if _edgb .R ==2{_geg ,_daf =_ag .alg4 (_bef ,_deff );}else if _edgb .R >=3{_geg ,_daf =_ag .alg5 (_bef ,_deff );}else {return nil ,_cb .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};if _daf !=nil {return nil ,_daf ;
};_ge .Log .Trace ("\u0063\u0068\u0065\u0063k:\u0020\u0025\u0020\u0078\u0020\u003d\u003d\u0020\u0025\u0020\u0078\u0020\u003f",string (_geg ),string (_edgb .U ));_edc :=_geg ;_ggd :=_edgb .U ;if _edgb .R >=3{if len (_edc )> 16{_edc =_edc [0:16];};if len (_ggd )> 16{_ggd =_ggd [0:16];
};};if !_fd .Equal (_edc ,_ggd ){return nil ,nil ;};return _bef ,nil ;};var _ StdHandler =stdHandlerR4 {};func (_fdd stdHandlerR6 )alg11 (_bad *StdEncryptDict ,_gead []byte )([]byte ,error ){if _ebg :=_ee ("\u0061\u006c\u00671\u0031","\u0055",48,_bad .U );
_ebg !=nil {return nil ,_ebg ;};_age :=make ([]byte ,len (_gead )+8);_fggb :=copy (_age ,_gead );_fggb +=copy (_age [_fggb :],_bad .U [32:40]);_cef ,_ade :=_fdd .alg2b (_bad .R ,_age ,_gead ,nil );if _ade !=nil {return nil ,_ade ;};_cef =_cef [:32];if !_fd .Equal (_cef ,_bad .U [:32]){return nil ,nil ;
};return _cef ,nil ;};func _ab (_ce _b .Block )_b .BlockMode {return (*ecbEncrypter )(_df (_ce ))};const (EventDocOpen =AuthEvent ("\u0044o\u0063\u004f\u0070\u0065\u006e");EventEFOpen =AuthEvent ("\u0045\u0046\u004f\u0070\u0065\u006e"););type stdHandlerR6 struct{};
type stdHandlerR4 struct{Length int ;ID0 string ;};

// Allowed checks if a set of permissions can be granted.
func (_fb Permissions )Allowed (p2 Permissions )bool {return _fb &p2 ==p2 };type ecb struct{_d _b .Block ;_dc int ;};func (_bddd stdHandlerR6 )alg9 (_fef *StdEncryptDict ,_ddd []byte ,_cagd []byte )error {if _dab :=_ee ("\u0061\u006c\u0067\u0039","\u004b\u0065\u0079",32,_ddd );
_dab !=nil {return _dab ;};if _cbgb :=_ee ("\u0061\u006c\u0067\u0039","\u0055",48,_fef .U );_cbgb !=nil {return _cbgb ;};var _ffb [16]byte ;if _ ,_effg :=_ca .ReadFull (_a .Reader ,_ffb [:]);_effg !=nil {return _effg ;};_fc :=_ffb [0:8];_cfc :=_ffb [8:16];
_fcg :=_fef .U [:48];_cdf :=make ([]byte ,len (_cagd )+len (_fc )+len (_fcg ));_aag :=copy (_cdf ,_cagd );_aag +=copy (_cdf [_aag :],_fc );_aag +=copy (_cdf [_aag :],_fcg );_fad ,_acf :=_bddd .alg2b (_fef .R ,_cdf ,_cagd ,_fcg );if _acf !=nil {return _acf ;
};O :=make ([]byte ,len (_fad )+len (_fc )+len (_cfc ));_aag =copy (O ,_fad [:32]);_aag +=copy (O [_aag :],_fc );_aag +=copy (O [_aag :],_cfc );_fef .O =O ;_aag =len (_cagd );_aag +=copy (_cdf [_aag :],_cfc );_fad ,_acf =_bddd .alg2b (_fef .R ,_cdf ,_cagd ,_fcg );
if _acf !=nil {return _acf ;};_cad ,_acf :=_ggc (_fad [:32]);if _acf !=nil {return _acf ;};_gda :=make ([]byte ,_e .BlockSize );_dcg :=_b .NewCBCEncrypter (_cad ,_gda );OE :=make ([]byte ,32);_dcg .CryptBlocks (OE ,_ddd [:32]);_fef .OE =OE ;return nil ;
};func _df (_dfd _b .Block )*ecb {return &ecb {_d :_dfd ,_dc :_dfd .BlockSize ()}};func (_cca stdHandlerR6 )alg2b (R int ,_bgf ,_gcd ,_bca []byte )([]byte ,error ){if R ==5{return _fda (_bgf );};return _ddf (_bgf ,_gcd ,_bca );};func (_ea *ecbEncrypter )BlockSize ()int {return _ea ._dc };


// NewHandlerR6 creates a new standard security handler for R=5 and R=6.
func NewHandlerR6 ()StdHandler {return stdHandlerR6 {}};

// Authenticate implements StdHandler interface.
func (_eeb stdHandlerR6 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){return _eeb .alg2a (d ,pass );};

// StdEncryptDict is a set of additional fields used in standard encryption dictionary.
type StdEncryptDict struct{R int ;P Permissions ;EncryptMetadata bool ;O ,U []byte ;OE ,UE []byte ;Perms []byte ;};func (_eda stdHandlerR4 )alg2 (_ede *StdEncryptDict ,_fdb []byte )[]byte {_ge .Log .Trace ("\u0061\u006c\u0067\u0032");_cga :=_eda .paddedPass (_fdb );
_afb :=_gd .New ();_afb .Write (_cga );_afb .Write (_ede .O );var _aa [4]byte ;_f .LittleEndian .PutUint32 (_aa [:],uint32 (_ede .P ));_afb .Write (_aa [:]);_ge .Log .Trace ("\u0067o\u0020\u0050\u003a\u0020\u0025\u0020x",_aa );_afb .Write ([]byte (_eda .ID0 ));
_ge .Log .Trace ("\u0074\u0068\u0069\u0073\u002e\u0052\u0020\u003d\u0020\u0025d\u0020\u0065\u006e\u0063\u0072\u0079\u0070t\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061\u0020\u0025\u0076",_ede .R ,_ede .EncryptMetadata );if (_ede .R >=4)&&!_ede .EncryptMetadata {_afb .Write ([]byte {0xff,0xff,0xff,0xff});
};_bab :=_afb .Sum (nil );if _ede .R >=3{_afb =_gd .New ();for _be :=0;_be < 50;_be ++{_afb .Reset ();_afb .Write (_bab [0:_eda .Length /8]);_bab =_afb .Sum (nil );};};if _ede .R >=3{return _bab [0:_eda .Length /8];};return _bab [0:5];};func _gba (_fea []byte ,_ffd int ){_gcg :=_ffd ;
for _gcg < len (_fea ){copy (_fea [_gcg :],_fea [:_gcg ]);_gcg *=2;};};

// StdHandler is an interface for standard security handlers.
type StdHandler interface{

// GenerateParams uses owner and user passwords to set encryption parameters and generate an encryption key.
// It assumes that R, P and EncryptMetadata are already set.
GenerateParams (_ad *StdEncryptDict ,_ceb ,_eab []byte )([]byte ,error );

// Authenticate uses encryption dictionary parameters and the password to calculate
// the document encryption key. It also returns permissions that should be granted to a user.
// In case of failed authentication, it returns empty key and zero permissions with no error.
Authenticate (_geb *StdEncryptDict ,_cc []byte )([]byte ,Permissions ,error );};func _ddf (_gcf ,_cag ,_dcf []byte )([]byte ,error ){var (_eead ,_aab ,_ced _g .Hash ;);_eead =_bc .New ();_dac :=make ([]byte ,64);_ga :=_eead ;_ga .Write (_gcf );K :=_ga .Sum (_dac [:0]);
_ebe :=make ([]byte ,64*(127+64+48));_eac :=func (_add int )([]byte ,error ){_beb :=len (_cag )+len (K )+len (_dcf );_gbf :=_ebe [:_beb ];_aeg :=copy (_gbf ,_cag );_aeg +=copy (_gbf [_aeg :],K [:]);_aeg +=copy (_gbf [_aeg :],_dcf );if _aeg !=_beb {_ge .Log .Error ("E\u0052\u0052\u004f\u0052\u003a\u0020u\u006e\u0065\u0078\u0070\u0065\u0063t\u0065\u0064\u0020\u0072\u006f\u0075\u006ed\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0073\u0069\u007ae\u002e");
return nil ,_cb .New ("\u0077\u0072\u006f\u006e\u0067\u0020\u0073\u0069\u007a\u0065");};K1 :=_ebe [:_beb *64];_gba (K1 ,_beb );_cbd ,_bgc :=_ggc (K [0:16]);if _bgc !=nil {return nil ,_bgc ;};_ece :=_b .NewCBCEncrypter (_cbd ,K [16:32]);_ece .CryptBlocks (K1 ,K1 );
E :=K1 ;_edd :=0;for _cea :=0;_cea < 16;_cea ++{_edd +=int (E [_cea ]%3);};var _bddc _g .Hash ;switch _edd %3{case 0:_bddc =_eead ;case 1:if _aab ==nil {_aab =_bf .New384 ();};_bddc =_aab ;case 2:if _ced ==nil {_ced =_bf .New ();};_bddc =_ced ;};_bddc .Reset ();
_bddc .Write (E );K =_bddc .Sum (_dac [:0]);return E ,nil ;};for _ebb :=0;;{E ,_ecgb :=_eac (_ebb );if _ecgb !=nil {return nil ,_ecgb ;};_fac :=E [len (E )-1];_ebb ++;if _ebb >=64&&_fac <=uint8 (_ebb -32){break ;};};return K [:32],nil ;};func (_fg stdHandlerR6 )alg8 (_fbf *StdEncryptDict ,_cda []byte ,_edce []byte )error {if _bae :=_ee ("\u0061\u006c\u0067\u0038","\u004b\u0065\u0079",32,_cda );
_bae !=nil {return _bae ;};var _acc [16]byte ;if _ ,_cbg :=_ca .ReadFull (_a .Reader ,_acc [:]);_cbg !=nil {return _cbg ;};_bed :=_acc [0:8];_fgg :=_acc [8:16];_cgb :=make ([]byte ,len (_edce )+len (_bed ));_cdd :=copy (_cgb ,_edce );copy (_cgb [_cdd :],_bed );
_dge ,_fbe :=_fg .alg2b (_fbf .R ,_cgb ,_edce ,nil );if _fbe !=nil {return _fbe ;};U :=make ([]byte ,len (_dge )+len (_bed )+len (_fgg ));_cdd =copy (U ,_dge [:32]);_cdd +=copy (U [_cdd :],_bed );copy (U [_cdd :],_fgg );_fbf .U =U ;_cdd =len (_edce );copy (_cgb [_cdd :],_fgg );
_dge ,_fbe =_fg .alg2b (_fbf .R ,_cgb ,_edce ,nil );if _fbe !=nil {return _fbe ;};_ebd ,_fbe :=_ggc (_dge [:32]);if _fbe !=nil {return _fbe ;};_gcge :=make ([]byte ,_e .BlockSize );_cba :=_b .NewCBCEncrypter (_ebd ,_gcge );UE :=make ([]byte ,32);_cba .CryptBlocks (UE ,_cda [:32]);
_fbf .UE =UE ;return nil ;};const _eff ="\x28\277\116\136\x4e\x75\x8a\x41\x64\000\x4e\x56\377"+"\xfa\001\010\056\x2e\x00\xb6\xd0\x68\076\x80\x2f\014"+"\251\xfe\x64\x53\x69\172";type ecbDecrypter ecb ;func (_bfd stdHandlerR4 )alg3 (R int ,_da ,_cgc []byte )([]byte ,error ){var _fba []byte ;
if len (_cgc )> 0{_fba =_bfd .alg3Key (R ,_cgc );}else {_fba =_bfd .alg3Key (R ,_da );};_bdd ,_ceg :=_cg .NewCipher (_fba );if _ceg !=nil {return nil ,_cb .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_edee :=_bfd .paddedPass (_da );
_dfe :=make ([]byte ,len (_edee ));_bdd .XORKeyStream (_dfe ,_edee );if R >=3{_ege :=make ([]byte ,len (_fba ));for _gdf :=0;_gdf < 19;_gdf ++{for _cd :=0;_cd < len (_fba );_cd ++{_ege [_cd ]=_fba [_cd ]^byte (_gdf +1);};_def ,_eec :=_cg .NewCipher (_ege );
if _eec !=nil {return nil ,_cb .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_def .XORKeyStream (_dfe ,_dfe );};};return _dfe ,nil ;};type errInvalidField struct{Func string ;Field string ;Exp int ;Got int ;
};func (_gb stdHandlerR6 )alg2a (_fdg *StdEncryptDict ,_ebf []byte )([]byte ,Permissions ,error ){if _faee :=_ee ("\u0061\u006c\u00672\u0061","\u004f",48,_fdg .O );_faee !=nil {return nil ,0,_faee ;};if _ada :=_ee ("\u0061\u006c\u00672\u0061","\u0055",48,_fdg .U );
_ada !=nil {return nil ,0,_ada ;};if len (_ebf )> 127{_ebf =_ebf [:127];};_eed ,_gec :=_gb .alg12 (_fdg ,_ebf );if _gec !=nil {return nil ,0,_gec ;};var (_gef []byte ;_bgg []byte ;_dce []byte ;);var _ggdb Permissions ;if len (_eed )!=0{_ggdb =PermOwner ;
_ggf :=make ([]byte ,len (_ebf )+8+48);_dgc :=copy (_ggf ,_ebf );_dgc +=copy (_ggf [_dgc :],_fdg .O [40:48]);copy (_ggf [_dgc :],_fdg .U [0:48]);_gef =_ggf ;_bgg =_fdg .OE ;_dce =_fdg .U [0:48];}else {_eed ,_gec =_gb .alg11 (_fdg ,_ebf );if _gec ==nil &&len (_eed )==0{_eed ,_gec =_gb .alg11 (_fdg ,[]byte (""));
};if _gec !=nil {return nil ,0,_gec ;}else if len (_eed )==0{return nil ,0,nil ;};_ggdb =_fdg .P ;_dfeg :=make ([]byte ,len (_ebf )+8);_bgb :=copy (_dfeg ,_ebf );copy (_dfeg [_bgb :],_fdg .U [40:48]);_gef =_dfeg ;_bgg =_fdg .UE ;_dce =nil ;};if _bec :=_ee ("\u0061\u006c\u00672\u0061","\u004b\u0065\u0079",32,_bgg );
_bec !=nil {return nil ,0,_bec ;};_bgg =_bgg [:32];_fdc ,_gec :=_gb .alg2b (_fdg .R ,_gef ,_ebf ,_dce );if _gec !=nil {return nil ,0,_gec ;};_dea ,_gec :=_e .NewCipher (_fdc [:32]);if _gec !=nil {return nil ,0,_gec ;};_dba :=make ([]byte ,_e .BlockSize );
_egd :=_b .NewCBCDecrypter (_dea ,_dba );_gefc :=make ([]byte ,32);_egd .CryptBlocks (_gefc ,_bgg );if _fdg .R ==5{return _gefc ,_ggdb ,nil ;};_gec =_gb .alg13 (_fdg ,_gefc );if _gec !=nil {return nil ,0,_gec ;};return _gefc ,_ggdb ,nil ;};func (_eba stdHandlerR6 )alg13 (_gdc *StdEncryptDict ,_ddda []byte )error {if _eddc :=_ee ("\u0061\u006c\u00671\u0033","\u004b\u0065\u0079",32,_ddda );
_eddc !=nil {return _eddc ;};if _ace :=_ee ("\u0061\u006c\u00671\u0033","\u0050\u0065\u0072m\u0073",16,_gdc .Perms );_ace !=nil {return _ace ;};_fdf :=make ([]byte ,16);copy (_fdf ,_gdc .Perms [:16]);_adea ,_bebc :=_e .NewCipher (_ddda [:32]);if _bebc !=nil {return _bebc ;
};_becd :=_ba (_adea );_becd .CryptBlocks (_fdf ,_fdf );if !_fd .Equal (_fdf [9:12],[]byte ("\u0061\u0064\u0062")){return _cb .New ("\u0064\u0065\u0063o\u0064\u0065\u0064\u0020p\u0065\u0072\u006d\u0069\u0073\u0073\u0069o\u006e\u0073\u0020\u0061\u0072\u0065\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};_efd :=Permissions (_f .LittleEndian .Uint32 (_fdf [0:4]));if _efd !=_gdc .P {return _cb .New ("\u0070\u0065r\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066\u0061il\u0065\u0064");
};var _gdb bool ;if _fdf [8]=='T'{_gdb =true ;}else if _fdf [8]=='F'{_gdb =false ;}else {return _cb .New ("\u0064\u0065\u0063\u006f\u0064\u0065\u0064 \u006d\u0065\u0074a\u0064\u0061\u0074\u0061 \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u006c\u0061\u0067\u0020\u0069\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};if _gdb !=_gdc .EncryptMetadata {return _cb .New ("\u006d\u0065t\u0061\u0064\u0061\u0074a\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e \u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066a\u0069\u006c\u0065\u0064");
};return nil ;};