//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package security ;import (_ae "bytes";_bg "crypto/aes";_g "crypto/cipher";_ed "crypto/md5";_bf "crypto/rand";_ad "crypto/rc4";_e "crypto/sha256";_a "crypto/sha512";_gf "encoding/binary";_d "errors";_gd "fmt";_bgg "github.com/unidoc/unipdf/v3/common";_b "hash";
_gg "io";_fb "math";);

// NewHandlerR4 creates a new standard security handler for R<=4.
func NewHandlerR4 (id0 string ,length int )StdHandler {return stdHandlerR4 {ID0 :id0 ,Length :length }};

// GenerateParams is the algorithm opposite to alg2a (R>=5).
// It generates U,O,UE,OE,Perms fields using AESv3 encryption.
// There is no algorithm number assigned to this function in the spec.
// It expects R, P and EncryptMetadata fields to be set.
func (_cff stdHandlerR6 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){_bgf :=make ([]byte ,32);if _ ,_fbf :=_gg .ReadFull (_bf .Reader ,_bgf );_fbf !=nil {return nil ,_fbf ;};d .U =nil ;d .O =nil ;d .UE =nil ;d .OE =nil ;d .Perms =nil ;
if len (upass )> 127{upass =upass [:127];};if len (opass )> 127{opass =opass [:127];};if _fff :=_cff .alg8 (d ,_bgf ,upass );_fff !=nil {return nil ,_fff ;};if _dacde :=_cff .alg9 (d ,_bgf ,opass );_dacde !=nil {return nil ,_dacde ;};if d .R ==5{return _bgf ,nil ;
};if _cba :=_cff .alg10 (d ,_bgf );_cba !=nil {return nil ,_cba ;};return _bgf ,nil ;};func (_fcg stdHandlerR6 )alg2a (_cd *StdEncryptDict ,_bac []byte )([]byte ,Permissions ,error ){if _dfe :=_cc ("\u0061\u006c\u00672\u0061","\u004f",48,_cd .O );_dfe !=nil {return nil ,0,_dfe ;
};if _gaa :=_cc ("\u0061\u006c\u00672\u0061","\u0055",48,_cd .U );_gaa !=nil {return nil ,0,_gaa ;};if len (_bac )> 127{_bac =_bac [:127];};_bbgc ,_bafe :=_fcg .alg12 (_cd ,_bac );if _bafe !=nil {return nil ,0,_bafe ;};var (_bfbe []byte ;_baa []byte ;_fab []byte ;
);var _dac Permissions ;if len (_bbgc )!=0{_dac =PermOwner ;_dec :=make ([]byte ,len (_bac )+8+48);_ded :=copy (_dec ,_bac );_ded +=copy (_dec [_ded :],_cd .O [40:48]);copy (_dec [_ded :],_cd .U [0:48]);_bfbe =_dec ;_baa =_cd .OE ;_fab =_cd .U [0:48];}else {_bbgc ,_bafe =_fcg .alg11 (_cd ,_bac );
if _bafe ==nil &&len (_bbgc )==0{_bbgc ,_bafe =_fcg .alg11 (_cd ,[]byte (""));};if _bafe !=nil {return nil ,0,_bafe ;}else if len (_bbgc )==0{return nil ,0,nil ;};_dac =_cd .P ;_cab :=make ([]byte ,len (_bac )+8);_dbc :=copy (_cab ,_bac );copy (_cab [_dbc :],_cd .U [40:48]);
_bfbe =_cab ;_baa =_cd .UE ;_fab =nil ;};if _bab :=_cc ("\u0061\u006c\u00672\u0061","\u004b\u0065\u0079",32,_baa );_bab !=nil {return nil ,0,_bab ;};_baa =_baa [:32];_dbdc ,_bafe :=_fcg .alg2b (_cd .R ,_bfbe ,_bac ,_fab );if _bafe !=nil {return nil ,0,_bafe ;
};_fg ,_bafe :=_bg .NewCipher (_dbdc [:32]);if _bafe !=nil {return nil ,0,_bafe ;};_ff :=make ([]byte ,_bg .BlockSize );_dfdf :=_g .NewCBCDecrypter (_fg ,_ff );_bdf :=make ([]byte ,32);_dfdf .CryptBlocks (_bdf ,_baa );if _cd .R ==5{return _bdf ,_dac ,nil ;
};_bafe =_fcg .alg13 (_cd ,_bdf );if _bafe !=nil {return nil ,0,_bafe ;};return _bdf ,_dac ,nil ;};type stdHandlerR4 struct{Length int ;ID0 string ;};func _cc (_ggg ,_ede string ,_aa int ,_ba []byte )error {if len (_ba )< _aa {return errInvalidField {Func :_ggg ,Field :_ede ,Exp :_aa ,Got :len (_ba )};
};return nil ;};func (_bfgd errInvalidField )Error ()string {return _gd .Sprintf ("\u0025s\u003a\u0020e\u0078\u0070\u0065\u0063t\u0065\u0064\u0020%\u0073\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0074o \u0062\u0065\u0020%\u0064\u0020b\u0079\u0074\u0065\u0073\u002c\u0020g\u006f\u0074 \u0025\u0064",_bfgd .Func ,_bfgd .Field ,_bfgd .Exp ,_bfgd .Got );
};type ecbEncrypter ecb ;type ecb struct{_eg _g .Block ;_df int ;};

// AuthEvent is an event type that triggers authentication.
type AuthEvent string ;func _fba (_c _g .Block )*ecb {return &ecb {_eg :_c ,_df :_c .BlockSize ()}};func _ga (_dg _g .Block )_g .BlockMode {return (*ecbDecrypter )(_fba (_dg ))};

// Authenticate implements StdHandler interface.
func (_af stdHandlerR4 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){_bgg .Log .Trace ("\u0044\u0065b\u0075\u0067\u0067\u0069n\u0067\u0020a\u0075\u0074\u0068\u0065\u006e\u0074\u0069\u0063a\u0074\u0069\u006f\u006e\u0020\u002d\u0020\u006f\u0077\u006e\u0065\u0072 \u0070\u0061\u0073\u0073");
_gcg ,_gff :=_af .alg7 (d ,pass );if _gff !=nil {return nil ,0,_gff ;};if _gcg !=nil {_bgg .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _gcg ,PermOwner ,nil ;
};_bgg .Log .Trace ("\u0044\u0065bu\u0067\u0067\u0069n\u0067\u0020\u0061\u0075the\u006eti\u0063\u0061\u0074\u0069\u006f\u006e\u0020- \u0075\u0073\u0065\u0072\u0020\u0070\u0061s\u0073");_gcg ,_gff =_af .alg6 (d ,pass );if _gff !=nil {return nil ,0,_gff ;
};if _gcg !=nil {_bgg .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _gcg ,d .P ,nil ;};return nil ,0,nil ;};type errInvalidField struct{Func string ;Field string ;
Exp int ;Got int ;};func (_eab stdHandlerR4 )alg6 (_dbd *StdEncryptDict ,_ada []byte )([]byte ,error ){var (_caab []byte ;_cac error ;);_edeb :=_eab .alg2 (_dbd ,_ada );if _dbd .R ==2{_caab ,_cac =_eab .alg4 (_edeb ,_ada );}else if _dbd .R >=3{_caab ,_cac =_eab .alg5 (_edeb ,_ada );
}else {return nil ,_d .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};if _cac !=nil {return nil ,_cac ;};_bgg .Log .Trace ("\u0063\u0068\u0065\u0063k:\u0020\u0025\u0020\u0078\u0020\u003d\u003d\u0020\u0025\u0020\u0078\u0020\u003f",string (_caab ),string (_dbd .U ));
_ebf :=_caab ;_ccb :=_dbd .U ;if _dbd .R >=3{if len (_ebf )> 16{_ebf =_ebf [0:16];};if len (_ccb )> 16{_ccb =_ccb [0:16];};};if !_ae .Equal (_ebf ,_ccb ){return nil ,nil ;};return _edeb ,nil ;};const (EventDocOpen =AuthEvent ("\u0044o\u0063\u004f\u0070\u0065\u006e");
EventEFOpen =AuthEvent ("\u0045\u0046\u004f\u0070\u0065\u006e"););func (_dc stdHandlerR6 )alg9 (_bag *StdEncryptDict ,_ecge []byte ,_beg []byte )error {if _baba :=_cc ("\u0061\u006c\u0067\u0039","\u004b\u0065\u0079",32,_ecge );_baba !=nil {return _baba ;
};if _bbce :=_cc ("\u0061\u006c\u0067\u0039","\u0055",48,_bag .U );_bbce !=nil {return _bbce ;};var _bgbe [16]byte ;if _ ,_gccf :=_gg .ReadFull (_bf .Reader ,_bgbe [:]);_gccf !=nil {return _gccf ;};_ceg :=_bgbe [0:8];_cacd :=_bgbe [8:16];_eag :=_bag .U [:48];
_bde :=make ([]byte ,len (_beg )+len (_ceg )+len (_eag ));_baca :=copy (_bde ,_beg );_baca +=copy (_bde [_baca :],_ceg );_baca +=copy (_bde [_baca :],_eag );_dea ,_feca :=_dc .alg2b (_bag .R ,_bde ,_beg ,_eag );if _feca !=nil {return _feca ;};O :=make ([]byte ,len (_dea )+len (_ceg )+len (_cacd ));
_baca =copy (O ,_dea [:32]);_baca +=copy (O [_baca :],_ceg );_baca +=copy (O [_baca :],_cacd );_bag .O =O ;_baca =len (_beg );_baca +=copy (_bde [_baca :],_cacd );_dea ,_feca =_dc .alg2b (_bag .R ,_bde ,_beg ,_eag );if _feca !=nil {return _feca ;};_fcga ,_feca :=_eegc (_dea [:32]);
if _feca !=nil {return _feca ;};_ebcb :=make ([]byte ,_bg .BlockSize );_aag :=_g .NewCBCEncrypter (_fcga ,_ebcb );OE :=make ([]byte ,32);_aag .CryptBlocks (OE ,_ecge [:32]);_bag .OE =OE ;return nil ;};func (_bd *ecbDecrypter )CryptBlocks (dst ,src []byte ){if len (src )%_bd ._df !=0{_bgg .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_bgg .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0064\u0065\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_bd ._eg .Decrypt (dst ,src [:_bd ._df ]);src =src [_bd ._df :];dst =dst [_bd ._df :];};};

// GenerateParams generates and sets O and U parameters for the encryption dictionary.
// It expects R, P and EncryptMetadata fields to be set.
func (_cf stdHandlerR4 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){O ,_gad :=_cf .alg3 (d .R ,upass ,opass );if _gad !=nil {_bgg .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_gad );
return nil ,_gad ;};d .O =O ;_bgg .Log .Trace ("\u0067\u0065\u006e\u0020\u004f\u003a\u0020\u0025\u0020\u0078",O );_fa :=_cf .alg2 (d ,upass );U ,_gad :=_cf .alg5 (_fa ,upass );if _gad !=nil {_bgg .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_gad );
return nil ,_gad ;};d .U =U ;_bgg .Log .Trace ("\u0067\u0065\u006e\u0020\u0055\u003a\u0020\u0025\u0020\u0078",U );return _fa ,nil ;};func (stdHandlerR4 )paddedPass (_baf []byte )[]byte {_fe :=make ([]byte ,32);_ggga :=copy (_fe ,_baf );for ;_ggga < 32;
_ggga ++{_fe [_ggga ]=_fbb [_ggga -len (_baf )];};return _fe ;};func _ab (_bff ,_bbad ,_bfgg []byte )([]byte ,error ){var (_ggf ,_cdb ,_ffa _b .Hash ;);_ggf =_e .New ();_bcb :=make ([]byte ,64);_dacd :=_ggf ;_dacd .Write (_bff );K :=_dacd .Sum (_bcb [:0]);
_gfa :=make ([]byte ,64*(127+64+48));_bec :=func (_fac int )([]byte ,error ){_gggc :=len (_bbad )+len (K )+len (_bfgg );_cbg :=_gfa [:_gggc ];_fcc :=copy (_cbg ,_bbad );_fcc +=copy (_cbg [_fcc :],K [:]);_fcc +=copy (_cbg [_fcc :],_bfgg );if _fcc !=_gggc {_bgg .Log .Error ("E\u0052\u0052\u004f\u0052\u003a\u0020u\u006e\u0065\u0078\u0070\u0065\u0063t\u0065\u0064\u0020\u0072\u006f\u0075\u006ed\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0073\u0069\u007ae\u002e");
return nil ,_d .New ("\u0077\u0072\u006f\u006e\u0067\u0020\u0073\u0069\u007a\u0065");};K1 :=_gfa [:_gggc *64];_bfe (K1 ,_gggc );_dgf ,_bgd :=_eegc (K [0:16]);if _bgd !=nil {return nil ,_bgd ;};_abg :=_g .NewCBCEncrypter (_dgf ,K [16:32]);_abg .CryptBlocks (K1 ,K1 );
E :=K1 ;_gca :=0;for _dbfd :=0;_dbfd < 16;_dbfd ++{_gca +=int (E [_dbfd ]%3);};var _caf _b .Hash ;switch _gca %3{case 0:_caf =_ggf ;case 1:if _cdb ==nil {_cdb =_a .New384 ();};_caf =_cdb ;case 2:if _ffa ==nil {_ffa =_a .New ();};_caf =_ffa ;};_caf .Reset ();
_caf .Write (E );K =_caf .Sum (_bcb [:0]);return E ,nil ;};for _agaa :=0;;{E ,_eaac :=_bec (_agaa );if _eaac !=nil {return nil ,_eaac ;};_eega :=E [len (E )-1];_agaa ++;if _agaa >=64&&_eega <=uint8 (_agaa -32){break ;};};return K [:32],nil ;};var _ StdHandler =stdHandlerR4 {};
func (_dfd stdHandlerR4 )alg7 (_acf *StdEncryptDict ,_aef []byte )([]byte ,error ){_aeff :=_dfd .alg3Key (_acf .R ,_aef );_gaff :=make ([]byte ,len (_acf .O ));if _acf .R ==2{_fd ,_eaa :=_ad .NewCipher (_aeff );if _eaa !=nil {return nil ,_d .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");
};_fd .XORKeyStream (_gaff ,_acf .O );}else if _acf .R >=3{_ecg :=append ([]byte {},_acf .O ...);for _fbg :=0;_fbg < 20;_fbg ++{_cgf :=append ([]byte {},_aeff ...);for _bbg :=0;_bbg < len (_aeff );_bbg ++{_cgf [_bbg ]^=byte (19-_fbg );};_dafa ,_dgge :=_ad .NewCipher (_cgf );
if _dgge !=nil {return nil ,_d .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_dafa .XORKeyStream (_gaff ,_ecg );_ecg =append ([]byte {},_gaff ...);};}else {return nil ,_d .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");
};_ddc ,_ebc :=_dfd .alg6 (_acf ,_gaff );if _ebc !=nil {return nil ,nil ;};return _ddc ,nil ;};var _ StdHandler =stdHandlerR6 {};func (_dae stdHandlerR4 )alg4 (_gge []byte ,_egg []byte )([]byte ,error ){_gaf ,_bc :=_ad .NewCipher (_gge );if _bc !=nil {return nil ,_d .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_ead :=[]byte (_fbb );_ebb :=make ([]byte ,len (_ead ));_gaf .XORKeyStream (_ebb ,_ead );return _ebb ,nil ;};func (_eec stdHandlerR6 )alg11 (_cbf *StdEncryptDict ,_dcc []byte )([]byte ,error ){if _aab :=_cc ("\u0061\u006c\u00671\u0031","\u0055",48,_cbf .U );
_aab !=nil {return nil ,_aab ;};_gagb :=make ([]byte ,len (_dcc )+8);_adaa :=copy (_gagb ,_dcc );_adaa +=copy (_gagb [_adaa :],_cbf .U [32:40]);_gged ,_ccbb :=_eec .alg2b (_cbf .R ,_gagb ,_dcc ,nil );if _ccbb !=nil {return nil ,_ccbb ;};_gged =_gged [:32];
if !_ae .Equal (_gged ,_cbf .U [:32]){return nil ,nil ;};return _gged ,nil ;};const _fbb ="\x28\277\116\136\x4e\x75\x8a\x41\x64\000\x4e\x56\377"+"\xfa\001\010\056\x2e\x00\xb6\xd0\x68\076\x80\x2f\014"+"\251\xfe\x64\x53\x69\172";func (_ggcd stdHandlerR6 )alg2b (R int ,_eff ,_ddb ,_bbc []byte )([]byte ,error ){if R ==5{return _bba (_eff );
};return _ab (_eff ,_ddb ,_bbc );};func (_ca *ecbEncrypter )CryptBlocks (dst ,src []byte ){if len (src )%_ca ._df !=0{_bgg .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_bgg .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_ca ._eg .Encrypt (dst ,src [:_ca ._df ]);src =src [_ca ._df :];dst =dst [_ca ._df :];};};func _bba (_ddg []byte )([]byte ,error ){_eaf :=_e .New ();_eaf .Write (_ddg );return _eaf .Sum (nil ),nil };func (_dd *ecbEncrypter )BlockSize ()int {return _dd ._df };
func (_dbf stdHandlerR4 )alg3 (R int ,_gc ,_gbd []byte )([]byte ,error ){var _aedb []byte ;if len (_gbd )> 0{_aedb =_dbf .alg3Key (R ,_gbd );}else {_aedb =_dbf .alg3Key (R ,_gc );};_dge ,_caa :=_ad .NewCipher (_aedb );if _caa !=nil {return nil ,_d .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_cb :=_dbf .paddedPass (_gc );_fea :=make ([]byte ,len (_cb ));_dge .XORKeyStream (_fea ,_cb );if R >=3{_ef :=make ([]byte ,len (_aedb ));for _bb :=0;_bb < 19;_bb ++{for _feg :=0;_feg < len (_aedb );_feg ++{_ef [_feg ]=_aedb [_feg ]^byte (_bb +1);};_gdf ,_daf :=_ad .NewCipher (_ef );
if _daf !=nil {return nil ,_d .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_gdf .XORKeyStream (_fea ,_fea );};};return _fea ,nil ;};

// NewHandlerR6 creates a new standard security handler for R=5 and R=6.
func NewHandlerR6 ()StdHandler {return stdHandlerR6 {}};func (_edea stdHandlerR6 )alg13 (_aefe *StdEncryptDict ,_cdf []byte )error {if _abe :=_cc ("\u0061\u006c\u00671\u0033","\u004b\u0065\u0079",32,_cdf );_abe !=nil {return _abe ;};if _bdc :=_cc ("\u0061\u006c\u00671\u0033","\u0050\u0065\u0072m\u0073",16,_aefe .Perms );
_bdc !=nil {return _bdc ;};_fdb :=make ([]byte ,16);copy (_fdb ,_aefe .Perms [:16]);_bgdg ,_ade :=_bg .NewCipher (_cdf [:32]);if _ade !=nil {return _ade ;};_cfc :=_ga (_bgdg );_cfc .CryptBlocks (_fdb ,_fdb );if !_ae .Equal (_fdb [9:12],[]byte ("\u0061\u0064\u0062")){return _d .New ("\u0064\u0065\u0063o\u0064\u0065\u0064\u0020p\u0065\u0072\u006d\u0069\u0073\u0073\u0069o\u006e\u0073\u0020\u0061\u0072\u0065\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};_acg :=Permissions (_gf .LittleEndian .Uint32 (_fdb [0:4]));if _acg !=_aefe .P {return _d .New ("\u0070\u0065r\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066\u0061il\u0065\u0064");
};var _bfgdg bool ;if _fdb [8]=='T'{_bfgdg =true ;}else if _fdb [8]=='F'{_bfgdg =false ;}else {return _d .New ("\u0064\u0065\u0063\u006f\u0064\u0065\u0064 \u006d\u0065\u0074a\u0064\u0061\u0074\u0061 \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u006c\u0061\u0067\u0020\u0069\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};if _bfgdg !=_aefe .EncryptMetadata {return _d .New ("\u006d\u0065t\u0061\u0064\u0061\u0074a\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e \u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066a\u0069\u006c\u0065\u0064");
};return nil ;};func (_eabc stdHandlerR6 )alg8 (_bffa *StdEncryptDict ,_ecd []byte ,_dbdf []byte )error {if _ace :=_cc ("\u0061\u006c\u0067\u0038","\u004b\u0065\u0079",32,_ecd );_ace !=nil {return _ace ;};var _gag [16]byte ;if _ ,_fcgc :=_gg .ReadFull (_bf .Reader ,_gag [:]);
_fcgc !=nil {return _fcgc ;};_acff :=_gag [0:8];_cbd :=_gag [8:16];_ged :=make ([]byte ,len (_dbdf )+len (_acff ));_cacb :=copy (_ged ,_dbdf );copy (_ged [_cacb :],_acff );_ega ,_ddf :=_eabc .alg2b (_bffa .R ,_ged ,_dbdf ,nil );if _ddf !=nil {return _ddf ;
};U :=make ([]byte ,len (_ega )+len (_acff )+len (_cbd ));_cacb =copy (U ,_ega [:32]);_cacb +=copy (U [_cacb :],_acff );copy (U [_cacb :],_cbd );_bffa .U =U ;_cacb =len (_dbdf );copy (_ged [_cacb :],_cbd );_ega ,_ddf =_eabc .alg2b (_bffa .R ,_ged ,_dbdf ,nil );
if _ddf !=nil {return _ddf ;};_ecgb ,_ddf :=_eegc (_ega [:32]);if _ddf !=nil {return _ddf ;};_feaf :=make ([]byte ,_bg .BlockSize );_ccd :=_g .NewCBCEncrypter (_ecgb ,_feaf );UE :=make ([]byte ,32);_ccd .CryptBlocks (UE ,_ecd [:32]);_bffa .UE =UE ;return nil ;
};type stdHandlerR6 struct{};

// Permissions is a bitmask of access permissions for a PDF file.
type Permissions uint32 ;func (_aggg stdHandlerR6 )alg10 (_ffac *StdEncryptDict ,_efb []byte )error {if _bad :=_cc ("\u0061\u006c\u00671\u0030","\u004b\u0065\u0079",32,_efb );_bad !=nil {return _bad ;};_aec :=uint64 (uint32 (_ffac .P ))|(_fb .MaxUint32 <<32);
Perms :=make ([]byte ,16);_gf .LittleEndian .PutUint64 (Perms [:8],_aec );if _ffac .EncryptMetadata {Perms [8]='T';}else {Perms [8]='F';};copy (Perms [9:12],"\u0061\u0064\u0062");if _ ,_dbb :=_gg .ReadFull (_bf .Reader ,Perms [12:16]);_dbb !=nil {return _dbb ;
};_def ,_gdg :=_eegc (_efb [:32]);if _gdg !=nil {return _gdg ;};_fbad :=_bfb (_def );_fbad .CryptBlocks (Perms ,Perms );_ffac .Perms =Perms [:16];return nil ;};

// Authenticate implements StdHandler interface.
func (_cgd stdHandlerR6 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){return _cgd .alg2a (d ,pass );};

// StdHandler is an interface for standard security handlers.
type StdHandler interface{

// GenerateParams uses owner and user passwords to set encryption parameters and generate an encryption key.
// It assumes that R, P and EncryptMetadata are already set.
GenerateParams (_aed *StdEncryptDict ,_ac ,_ag []byte )([]byte ,error );

// Authenticate uses encryption dictionary parameters and the password to calculate
// the document encryption key. It also returns permissions that should be granted to a user.
// In case of failed authentication, it returns empty key and zero permissions with no error.
Authenticate (_edf *StdEncryptDict ,_bfg []byte )([]byte ,Permissions ,error );};const (PermOwner =Permissions (_fb .MaxUint32 );PermPrinting =Permissions (1<<2);PermModify =Permissions (1<<3);PermExtractGraphics =Permissions (1<<4);PermAnnotate =Permissions (1<<5);
PermFillForms =Permissions (1<<8);PermDisabilityExtract =Permissions (1<<9);PermRotateInsert =Permissions (1<<10);PermFullPrintQuality =Permissions (1<<11););func (_de stdHandlerR4 )alg5 (_ggc []byte ,_bfba []byte )([]byte ,error ){_bbd :=_ed .New ();_bbd .Write ([]byte (_fbb ));
_bbd .Write ([]byte (_de .ID0 ));_caad :=_bbd .Sum (nil );_bgg .Log .Trace ("\u0061\u006c\u0067\u0035");_bgg .Log .Trace ("\u0065k\u0065\u0079\u003a\u0020\u0025\u0020x",_ggc );_bgg .Log .Trace ("\u0049D\u003a\u0020\u0025\u0020\u0078",_de .ID0 );if len (_caad )!=16{return nil ,_d .New ("\u0068a\u0073\u0068\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074\u0020\u0031\u0036\u0020\u0062\u0079\u0074\u0065\u0073");
};_cbe ,_add :=_ad .NewCipher (_ggc );if _add !=nil {return nil ,_d .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_ce :=make ([]byte ,16);_cbe .XORKeyStream (_ce ,_caad );_fbc :=make ([]byte ,len (_ggc ));for _bae :=0;
_bae < 19;_bae ++{for _fc :=0;_fc < len (_ggc );_fc ++{_fbc [_fc ]=_ggc [_fc ]^byte (_bae +1);};_cbe ,_add =_ad .NewCipher (_fbc );if _add !=nil {return nil ,_d .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};
_cbe .XORKeyStream (_ce ,_ce );_bgg .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u002c\u0020\u0065\u006b\u0065\u0079:\u0020\u0025\u0020\u0078",_bae ,_fbc );_bgg .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0020\u0078",_bae ,_ce );
};_gcc :=make ([]byte ,32);for _cg :=0;_cg < 16;_cg ++{_gcc [_cg ]=_ce [_cg ];};_ ,_add =_bf .Read (_gcc [16:32]);if _add !=nil {return nil ,_d .New ("\u0066a\u0069\u006c\u0065\u0064 \u0074\u006f\u0020\u0067\u0065n\u0020r\u0061n\u0064\u0020\u006e\u0075\u006d\u0062\u0065r");
};return _gcc ,nil ;};func _bfb (_db _g .Block )_g .BlockMode {return (*ecbEncrypter )(_fba (_db ))};func (_dgg *ecbDecrypter )BlockSize ()int {return _dgg ._df };func (_ge stdHandlerR4 )alg3Key (R int ,_ecf []byte )[]byte {_ece :=_ed .New ();_da :=_ge .paddedPass (_ecf );
_ece .Write (_da );if R >=3{for _eeg :=0;_eeg < 50;_eeg ++{_beb :=_ece .Sum (nil );_ece =_ed .New ();_ece .Write (_beb );};};_ea :=_ece .Sum (nil );if R ==2{_ea =_ea [0:5];}else {_ea =_ea [0:_ge .Length /8];};return _ea ;};func _eegc (_agg []byte )(_g .Block ,error ){_aeb ,_eaae :=_bg .NewCipher (_agg );
if _eaae !=nil {_bgg .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0063\u0072\u0065\u0061\u0074\u0065\u0020A\u0045\u0053\u0020\u0063\u0069p\u0068\u0065r\u003a\u0020\u0025\u0076",_eaae );
return nil ,_eaae ;};return _aeb ,nil ;};func (_ec stdHandlerR4 )alg2 (_adb *StdEncryptDict ,_acb []byte )[]byte {_bgg .Log .Trace ("\u0061\u006c\u0067\u0032");_aga :=_ec .paddedPass (_acb );_be :=_ed .New ();_be .Write (_aga );_be .Write (_adb .O );var _gb [4]byte ;
_gf .LittleEndian .PutUint32 (_gb [:],uint32 (_adb .P ));_be .Write (_gb [:]);_bgg .Log .Trace ("\u0067o\u0020\u0050\u003a\u0020\u0025\u0020x",_gb );_be .Write ([]byte (_ec .ID0 ));_bgg .Log .Trace ("\u0074\u0068\u0069\u0073\u002e\u0052\u0020\u003d\u0020\u0025d\u0020\u0065\u006e\u0063\u0072\u0079\u0070t\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061\u0020\u0025\u0076",_adb .R ,_adb .EncryptMetadata );
if (_adb .R >=4)&&!_adb .EncryptMetadata {_be .Write ([]byte {0xff,0xff,0xff,0xff});};_eb :=_be .Sum (nil );if _adb .R >=3{_be =_ed .New ();for _fec :=0;_fec < 50;_fec ++{_be .Reset ();_be .Write (_eb [0:_ec .Length /8]);_eb =_be .Sum (nil );};};if _adb .R >=3{return _eb [0:_ec .Length /8];
};return _eb [0:5];};func _bfe (_bgb []byte ,_fce int ){_faa :=_fce ;for _faa < len (_bgb ){copy (_bgb [_faa :],_bgb [:_faa ]);_faa *=2;};};func (_ffc stdHandlerR6 )alg12 (_ggeg *StdEncryptDict ,_bdb []byte )([]byte ,error ){if _ebcc :=_cc ("\u0061\u006c\u00671\u0032","\u0055",48,_ggeg .U );
_ebcc !=nil {return nil ,_ebcc ;};if _cec :=_cc ("\u0061\u006c\u00671\u0032","\u004f",48,_ggeg .O );_cec !=nil {return nil ,_cec ;};_aaa :=make ([]byte ,len (_bdb )+8+48);_bgdf :=copy (_aaa ,_bdb );_bgdf +=copy (_aaa [_bgdf :],_ggeg .O [32:40]);_bgdf +=copy (_aaa [_bgdf :],_ggeg .U [0:48]);
_fda ,_agb :=_ffc .alg2b (_ggeg .R ,_aaa ,_bdb ,_ggeg .U [0:48]);if _agb !=nil {return nil ,_agb ;};_fda =_fda [:32];if !_ae .Equal (_fda ,_ggeg .O [:32]){return nil ,nil ;};return _fda ,nil ;};

// StdEncryptDict is a set of additional fields used in standard encryption dictionary.
type StdEncryptDict struct{R int ;P Permissions ;EncryptMetadata bool ;O ,U []byte ;OE ,UE []byte ;Perms []byte ;};

// Allowed checks if a set of permissions can be granted.
func (_ee Permissions )Allowed (p2 Permissions )bool {return _ee &p2 ==p2 };type ecbDecrypter ecb ;