//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package security ;import (_dc "bytes";_ac "crypto/aes";_f "crypto/cipher";_d "crypto/md5";_acd "crypto/rand";_bf "crypto/rc4";_a "crypto/sha256";_be "crypto/sha512";_bg "encoding/binary";_ab "errors";_g "fmt";_fe "github.com/unidoc/unipdf/v3/common";_e "hash";
_fb "io";_bgd "math";);var _ StdHandler =stdHandlerR6 {};func (_bab stdHandlerR6 )alg13 (_ffa *StdEncryptDict ,_ebgg []byte )error {if _fgde :=_gb ("\u0061\u006c\u00671\u0033","\u004b\u0065\u0079",32,_ebgg );_fgde !=nil {return _fgde ;};if _edd :=_gb ("\u0061\u006c\u00671\u0033","\u0050\u0065\u0072m\u0073",16,_ffa .Perms );
_edd !=nil {return _edd ;};_bca :=make ([]byte ,16);copy (_bca ,_ffa .Perms [:16]);_bcbc ,_dd :=_ac .NewCipher (_ebgg [:32]);if _dd !=nil {return _dd ;};_gab :=_cg (_bcbc );_gab .CryptBlocks (_bca ,_bca );if !_dc .Equal (_bca [9:12],[]byte ("\u0061\u0064\u0062")){return _ab .New ("\u0064\u0065\u0063o\u0064\u0065\u0064\u0020p\u0065\u0072\u006d\u0069\u0073\u0073\u0069o\u006e\u0073\u0020\u0061\u0072\u0065\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};_bcf :=Permissions (_bg .LittleEndian .Uint32 (_bca [0:4]));if _bcf !=_ffa .P {return _ab .New ("\u0070\u0065r\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066\u0061il\u0065\u0064");
};var _bbgf bool ;if _bca [8]=='T'{_bbgf =true ;}else if _bca [8]=='F'{_bbgf =false ;}else {return _ab .New ("\u0064\u0065\u0063\u006f\u0064\u0065\u0064 \u006d\u0065\u0074a\u0064\u0061\u0074\u0061 \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u006c\u0061\u0067\u0020\u0069\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};if _bbgf !=_ffa .EncryptMetadata {return _ab .New ("\u006d\u0065t\u0061\u0064\u0061\u0074a\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e \u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066a\u0069\u006c\u0065\u0064");
};return nil ;};

// NewHandlerR4 creates a new standard security handler for R<=4.
func NewHandlerR4 (id0 string ,length int )StdHandler {return stdHandlerR4 {ID0 :id0 ,Length :length }};func _db (_bgf _f .Block )_f .BlockMode {return (*ecbEncrypter )(_cf (_bgf ))};func (_dea stdHandlerR4 )alg3Key (R int ,_ag []byte )[]byte {_fdc :=_d .New ();
_dgc :=_dea .paddedPass (_ag );_fdc .Write (_dgc );if R >=3{for _dgg :=0;_dgg < 50;_dgg ++{_gc :=_fdc .Sum (nil );_fdc =_d .New ();_fdc .Write (_gc );};};_ef :=_fdc .Sum (nil );if R ==2{_ef =_ef [0:5];}else {_ef =_ef [0:_dea .Length /8];};return _ef ;};
type ecbEncrypter ecb ;func _adg (_eeb []byte )(_f .Block ,error ){_gcdd ,_bac :=_ac .NewCipher (_eeb );if _bac !=nil {_fe .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0063\u0072\u0065\u0061\u0074\u0065\u0020A\u0045\u0053\u0020\u0063\u0069p\u0068\u0065r\u003a\u0020\u0025\u0076",_bac );
return nil ,_bac ;};return _gcdd ,nil ;};func (_dgd stdHandlerR4 )alg5 (_fab []byte ,_bc []byte )([]byte ,error ){_bd :=_d .New ();_bd .Write ([]byte (_dbd ));_bd .Write ([]byte (_dgd .ID0 ));_gdf :=_bd .Sum (nil );_fe .Log .Trace ("\u0061\u006c\u0067\u0035");
_fe .Log .Trace ("\u0065k\u0065\u0079\u003a\u0020\u0025\u0020x",_fab );_fe .Log .Trace ("\u0049D\u003a\u0020\u0025\u0020\u0078",_dgd .ID0 );if len (_gdf )!=16{return nil ,_ab .New ("\u0068a\u0073\u0068\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074\u0020\u0031\u0036\u0020\u0062\u0079\u0074\u0065\u0073");
};_cdg ,_gdbb :=_bf .NewCipher (_fab );if _gdbb !=nil {return nil ,_ab .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_fg :=make ([]byte ,16);_cdg .XORKeyStream (_fg ,_gdf );_bcg :=make ([]byte ,len (_fab ));
for _dffe :=0;_dffe < 19;_dffe ++{for _bcc :=0;_bcc < len (_fab );_bcc ++{_bcg [_bcc ]=_fab [_bcc ]^byte (_dffe +1);};_cdg ,_gdbb =_bf .NewCipher (_bcg );if _gdbb !=nil {return nil ,_ab .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_cdg .XORKeyStream (_fg ,_fg );_fe .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u002c\u0020\u0065\u006b\u0065\u0079:\u0020\u0025\u0020\u0078",_dffe ,_bcg );_fe .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0020\u0078",_dffe ,_fg );
};_cgc :=make ([]byte ,32);for _dca :=0;_dca < 16;_dca ++{_cgc [_dca ]=_fg [_dca ];};_ ,_gdbb =_acd .Read (_cgc [16:32]);if _gdbb !=nil {return nil ,_ab .New ("\u0066a\u0069\u006c\u0065\u0064 \u0074\u006f\u0020\u0067\u0065n\u0020r\u0061n\u0064\u0020\u006e\u0075\u006d\u0062\u0065r");
};return _cgc ,nil ;};func (_dce stdHandlerR4 )alg7 (_cdf *StdEncryptDict ,_aad []byte )([]byte ,error ){_bed :=_dce .alg3Key (_cdf .R ,_aad );_dfd :=make ([]byte ,len (_cdf .O ));if _cdf .R ==2{_ca ,_eb :=_bf .NewCipher (_bed );if _eb !=nil {return nil ,_ab .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");
};_ca .XORKeyStream (_dfd ,_cdf .O );}else if _cdf .R >=3{_bea :=append ([]byte {},_cdf .O ...);for _agf :=0;_agf < 20;_agf ++{_bcb :=append ([]byte {},_bed ...);for _ade :=0;_ade < len (_bed );_ade ++{_bcb [_ade ]^=byte (19-_agf );};_gad ,_cdgf :=_bf .NewCipher (_bcb );
if _cdgf !=nil {return nil ,_ab .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_gad .XORKeyStream (_dfd ,_bea );_bea =append ([]byte {},_dfd ...);};}else {return nil ,_ab .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");
};_fbe ,_ffg :=_dce .alg6 (_cdf ,_dfd );if _ffg !=nil {return nil ,nil ;};return _fbe ,nil ;};

// StdEncryptDict is a set of additional fields used in standard encryption dictionary.
type StdEncryptDict struct{R int ;P Permissions ;EncryptMetadata bool ;O ,U []byte ;OE ,UE []byte ;Perms []byte ;};type stdHandlerR6 struct{};const (PermOwner =Permissions (_bgd .MaxUint32 );PermPrinting =Permissions (1<<2);PermModify =Permissions (1<<3);
PermExtractGraphics =Permissions (1<<4);PermAnnotate =Permissions (1<<5);PermFillForms =Permissions (1<<8);PermDisabilityExtract =Permissions (1<<9);PermRotateInsert =Permissions (1<<10);PermFullPrintQuality =Permissions (1<<11););func (_eeg stdHandlerR4 )alg6 (_bfe *StdEncryptDict ,_eegd []byte )([]byte ,error ){var (_ceb []byte ;
_fcf error ;);_fba :=_eeg .alg2 (_bfe ,_eegd );if _bfe .R ==2{_ceb ,_fcf =_eeg .alg4 (_fba ,_eegd );}else if _bfe .R >=3{_ceb ,_fcf =_eeg .alg5 (_fba ,_eegd );}else {return nil ,_ab .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};if _fcf !=nil {return nil ,_fcf ;
};_fe .Log .Trace ("\u0063\u0068\u0065\u0063k:\u0020\u0025\u0020\u0078\u0020\u003d\u003d\u0020\u0025\u0020\u0078\u0020\u003f",string (_ceb ),string (_bfe .U ));_fca :=_ceb ;_ad :=_bfe .U ;if _bfe .R >=3{if len (_fca )> 16{_fca =_fca [0:16];};if len (_ad )> 16{_ad =_ad [0:16];
};};if !_dc .Equal (_fca ,_ad ){return nil ,nil ;};return _fba ,nil ;};func _gb (_edg ,_fac string ,_de int ,_bb []byte )error {if len (_bb )< _de {return errInvalidField {Func :_edg ,Field :_fac ,Exp :_de ,Got :len (_bb )};};return nil ;};func (_ff *ecbEncrypter )BlockSize ()int {return _ff ._fc };


// AuthEvent is an event type that triggers authentication.
type AuthEvent string ;var _ StdHandler =stdHandlerR4 {};

// Allowed checks if a set of permissions can be granted.
func (_gge Permissions )Allowed (p2 Permissions )bool {return _gge &p2 ==p2 };func (_gdg stdHandlerR4 )alg2 (_ggc *StdEncryptDict ,_ge []byte )[]byte {_fe .Log .Trace ("\u0061\u006c\u0067\u0032");_eg :=_gdg .paddedPass (_ge );_ba :=_d .New ();_ba .Write (_eg );
_ba .Write (_ggc .O );var _cc [4]byte ;_bg .LittleEndian .PutUint32 (_cc [:],uint32 (_ggc .P ));_ba .Write (_cc [:]);_fe .Log .Trace ("\u0067o\u0020\u0050\u003a\u0020\u0025\u0020x",_cc );_ba .Write ([]byte (_gdg .ID0 ));_fe .Log .Trace ("\u0074\u0068\u0069\u0073\u002e\u0052\u0020\u003d\u0020\u0025d\u0020\u0065\u006e\u0063\u0072\u0079\u0070t\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061\u0020\u0025\u0076",_ggc .R ,_ggc .EncryptMetadata );
if (_ggc .R >=4)&&!_ggc .EncryptMetadata {_ba .Write ([]byte {0xff,0xff,0xff,0xff});};_gdb :=_ba .Sum (nil );if _ggc .R >=3{_ba =_d .New ();for _ggg :=0;_ggg < 50;_ggg ++{_ba .Reset ();_ba .Write (_gdb [0:_gdg .Length /8]);_gdb =_ba .Sum (nil );};};if _ggc .R >=3{return _gdb [0:_gdg .Length /8];
};return _gdb [0:5];};

// GenerateParams is the algorithm opposite to alg2a (R>=5).
// It generates U,O,UE,OE,Perms fields using AESv3 encryption.
// There is no algorithm number assigned to this function in the spec.
// It expects R, P and EncryptMetadata fields to be set.
func (_gaad stdHandlerR6 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){_ggb :=make ([]byte ,32);if _ ,_deb :=_fb .ReadFull (_acd .Reader ,_ggb );_deb !=nil {return nil ,_deb ;};d .U =nil ;d .O =nil ;d .UE =nil ;d .OE =nil ;d .Perms =nil ;
if len (upass )> 127{upass =upass [:127];};if len (opass )> 127{opass =opass [:127];};if _bgdg :=_gaad .alg8 (d ,_ggb ,upass );_bgdg !=nil {return nil ,_bgdg ;};if _cdd :=_gaad .alg9 (d ,_ggb ,opass );_cdd !=nil {return nil ,_cdd ;};if d .R ==5{return _ggb ,nil ;
};if _cecg :=_gaad .alg10 (d ,_ggb );_cecg !=nil {return nil ,_cecg ;};return _ggb ,nil ;};func _bdf (_fbb ,_ebd ,_dee []byte )([]byte ,error ){var (_dcde ,_aagb ,_edgf _e .Hash ;);_dcde =_a .New ();_dggf :=make ([]byte ,64);_bfd :=_dcde ;_bfd .Write (_fbb );
K :=_bfd .Sum (_dggf [:0]);_gcdg :=make ([]byte ,64*(127+64+48));_dgcf :=func (_befc int )([]byte ,error ){_dcb :=len (_ebd )+len (K )+len (_dee );_bfdb :=_gcdg [:_dcb ];_edb :=copy (_bfdb ,_ebd );_edb +=copy (_bfdb [_edb :],K [:]);_edb +=copy (_bfdb [_edb :],_dee );
if _edb !=_dcb {_fe .Log .Error ("E\u0052\u0052\u004f\u0052\u003a\u0020u\u006e\u0065\u0078\u0070\u0065\u0063t\u0065\u0064\u0020\u0072\u006f\u0075\u006ed\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0073\u0069\u007ae\u002e");return nil ,_ab .New ("\u0077\u0072\u006f\u006e\u0067\u0020\u0073\u0069\u007a\u0065");
};K1 :=_gcdg [:_dcb *64];_ece (K1 ,_dcb );_dfda ,_efg :=_adg (K [0:16]);if _efg !=nil {return nil ,_efg ;};_fda :=_f .NewCBCEncrypter (_dfda ,K [16:32]);_fda .CryptBlocks (K1 ,K1 );E :=K1 ;_gbge :=0;for _bbb :=0;_bbb < 16;_bbb ++{_gbge +=int (E [_bbb ]%3);
};var _gdge _e .Hash ;switch _gbge %3{case 0:_gdge =_dcde ;case 1:if _aagb ==nil {_aagb =_be .New384 ();};_gdge =_aagb ;case 2:if _edgf ==nil {_edgf =_be .New ();};_gdge =_edgf ;};_gdge .Reset ();_gdge .Write (E );K =_gdge .Sum (_dggf [:0]);return E ,nil ;
};for _bbe :=0;;{E ,_daa :=_dgcf (_bbe );if _daa !=nil {return nil ,_daa ;};_ebb :=E [len (E )-1];_bbe ++;if _bbe >=64&&_ebb <=uint8 (_bbe -32){break ;};};return K [:32],nil ;};func (_cd *ecbDecrypter )BlockSize ()int {return _cd ._fc };func _cg (_cfa _f .Block )_f .BlockMode {return (*ecbDecrypter )(_cf (_cfa ))};
type ecbDecrypter ecb ;func (_fdd stdHandlerR6 )alg2a (_befg *StdEncryptDict ,_faf []byte )([]byte ,Permissions ,error ){if _fef :=_gb ("\u0061\u006c\u00672\u0061","\u004f",48,_befg .O );_fef !=nil {return nil ,0,_fef ;};if _fcc :=_gb ("\u0061\u006c\u00672\u0061","\u0055",48,_befg .U );
_fcc !=nil {return nil ,0,_fcc ;};if len (_faf )> 127{_faf =_faf [:127];};_deg ,_ec :=_fdd .alg12 (_befg ,_faf );if _ec !=nil {return nil ,0,_ec ;};var (_gf []byte ;_cfaf []byte ;_bbf []byte ;);var _ebf Permissions ;if len (_deg )!=0{_ebf =PermOwner ;_aag :=make ([]byte ,len (_faf )+8+48);
_dge :=copy (_aag ,_faf );_dge +=copy (_aag [_dge :],_befg .O [40:48]);copy (_aag [_dge :],_befg .U [0:48]);_gf =_aag ;_cfaf =_befg .OE ;_bbf =_befg .U [0:48];}else {_deg ,_ec =_fdd .alg11 (_befg ,_faf );if _ec ==nil &&len (_deg )==0{_deg ,_ec =_fdd .alg11 (_befg ,[]byte (""));
};if _ec !=nil {return nil ,0,_ec ;}else if len (_deg )==0{return nil ,0,nil ;};_ebf =_befg .P ;_eed :=make ([]byte ,len (_faf )+8);_age :=copy (_eed ,_faf );copy (_eed [_age :],_befg .U [40:48]);_gf =_eed ;_cfaf =_befg .UE ;_bbf =nil ;};if _adb :=_gb ("\u0061\u006c\u00672\u0061","\u004b\u0065\u0079",32,_cfaf );
_adb !=nil {return nil ,0,_adb ;};_cfaf =_cfaf [:32];_abg ,_ec :=_fdd .alg2b (_befg .R ,_gf ,_faf ,_bbf );if _ec !=nil {return nil ,0,_ec ;};_gee ,_ec :=_ac .NewCipher (_abg [:32]);if _ec !=nil {return nil ,0,_ec ;};_eeae :=make ([]byte ,_ac .BlockSize );
_gbe :=_f .NewCBCDecrypter (_gee ,_eeae );_gda :=make ([]byte ,32);_gbe .CryptBlocks (_gda ,_cfaf );if _befg .R ==5{return _gda ,_ebf ,nil ;};_ec =_fdd .alg13 (_befg ,_gda );if _ec !=nil {return nil ,0,_ec ;};return _gda ,_ebf ,nil ;};func (_ga *ecbEncrypter )CryptBlocks (dst ,src []byte ){if len (src )%_ga ._fc !=0{_fe .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_fe .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_ga ._c .Encrypt (dst ,src [:_ga ._fc ]);src =src [_ga ._fc :];dst =dst [_ga ._fc :];};};func (_dcg *ecbDecrypter )CryptBlocks (dst ,src []byte ){if len (src )%_dcg ._fc !=0{_fe .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_fe .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0064\u0065\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_dcg ._c .Decrypt (dst ,src [:_dcg ._fc ]);src =src [_dcg ._fc :];dst =dst [_dcg ._fc :];};};func _ece (_bbfb []byte ,_dcc int ){_degf :=_dcc ;for _degf < len (_bbfb ){copy (_bbfb [_degf :],_bbfb [:_degf ]);_degf *=2;};};func (_ede stdHandlerR6 )alg2b (R int ,_bddg ,_gga ,_gdbd []byte )([]byte ,error ){if R ==5{return _gfb (_bddg );
};return _bdf (_bddg ,_gga ,_gdbd );};

// StdHandler is an interface for standard security handlers.
type StdHandler interface{

// GenerateParams uses owner and user passwords to set encryption parameters and generate an encryption key.
// It assumes that R, P and EncryptMetadata are already set.
GenerateParams (_fa *StdEncryptDict ,_ed ,_aba []byte )([]byte ,error );

// Authenticate uses encryption dictionary parameters and the password to calculate
// the document encryption key. It also returns permissions that should be granted to a user.
// In case of failed authentication, it returns empty key and zero permissions with no error.
Authenticate (_gg *StdEncryptDict ,_aa []byte )([]byte ,Permissions ,error );};

// NewHandlerR6 creates a new standard security handler for R=5 and R=6.
func NewHandlerR6 ()StdHandler {return stdHandlerR6 {}};func _gfb (_gbg []byte )([]byte ,error ){_gcb :=_a .New ();_gcb .Write (_gbg );return _gcb .Sum (nil ),nil };func (_gde stdHandlerR4 )alg4 (_gaa []byte ,_aee []byte )([]byte ,error ){_fcb ,_da :=_bf .NewCipher (_gaa );
if _da !=nil {return nil ,_ab .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_aga :=[]byte (_dbd );_dcf :=make ([]byte ,len (_aga ));_fcb .XORKeyStream (_dcf ,_aga );return _dcf ,nil ;};func (_fdcg stdHandlerR6 )alg11 (_egg *StdEncryptDict ,_fgg []byte )([]byte ,error ){if _bff :=_gb ("\u0061\u006c\u00671\u0031","\u0055",48,_egg .U );
_bff !=nil {return nil ,_bff ;};_fcgg :=make ([]byte ,len (_fgg )+8);_aef :=copy (_fcgg ,_fgg );_aef +=copy (_fcgg [_aef :],_egg .U [32:40]);_gag ,_gaf :=_fdcg .alg2b (_egg .R ,_fcgg ,_fgg ,nil );if _gaf !=nil {return nil ,_gaf ;};_gag =_gag [:32];if !_dc .Equal (_gag ,_egg .U [:32]){return nil ,nil ;
};return _gag ,nil ;};func _cf (_gd _f .Block )*ecb {return &ecb {_c :_gd ,_fc :_gd .BlockSize ()}};func (stdHandlerR4 )paddedPass (_df []byte )[]byte {_dg :=make ([]byte ,32);_cff :=copy (_dg ,_df );for ;_cff < 32;_cff ++{_dg [_cff ]=_dbd [_cff -len (_df )];
};return _dg ;};func (_efb stdHandlerR4 )alg3 (R int ,_gcc ,_bgb []byte )([]byte ,error ){var _dcga []byte ;if len (_bgb )> 0{_dcga =_efb .alg3Key (R ,_bgb );}else {_dcga =_efb .alg3Key (R ,_gcc );};_ae ,_gcd :=_bf .NewCipher (_dcga );if _gcd !=nil {return nil ,_ab .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_aeb :=_efb .paddedPass (_gcc );_agg :=make ([]byte ,len (_aeb ));_ae .XORKeyStream (_agg ,_aeb );if R >=3{_ee :=make ([]byte ,len (_dcga ));for _ce :=0;_ce < 19;_ce ++{for _dff :=0;_dff < len (_dcga );_dff ++{_ee [_dff ]=_dcga [_dff ]^byte (_ce +1);
};_eea ,_bgbc :=_bf .NewCipher (_ee );if _bgbc !=nil {return nil ,_ab .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_eea .XORKeyStream (_agg ,_agg );};};return _agg ,nil ;};func (_bef errInvalidField )Error ()string {return _g .Sprintf ("\u0025s\u003a\u0020e\u0078\u0070\u0065\u0063t\u0065\u0064\u0020%\u0073\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0074o \u0062\u0065\u0020%\u0064\u0020b\u0079\u0074\u0065\u0073\u002c\u0020g\u006f\u0074 \u0025\u0064",_bef .Func ,_bef .Field ,_bef .Exp ,_bef .Got );
};type stdHandlerR4 struct{Length int ;ID0 string ;};type ecb struct{_c _f .Block ;_fc int ;};

// Permissions is a bitmask of access permissions for a PDF file.
type Permissions uint32 ;func (_eede stdHandlerR6 )alg8 (_dbe *StdEncryptDict ,_beb []byte ,_gfe []byte )error {if _fec :=_gb ("\u0061\u006c\u0067\u0038","\u004b\u0065\u0079",32,_beb );_fec !=nil {return _fec ;};var _dae [16]byte ;if _ ,_ada :=_fb .ReadFull (_acd .Reader ,_dae [:]);
_ada !=nil {return _ada ;};_daeb :=_dae [0:8];_bbg :=_dae [8:16];_bge :=make ([]byte ,len (_gfe )+len (_daeb ));_cda :=copy (_bge ,_gfe );copy (_bge [_cda :],_daeb );_abae ,_cfe :=_eede .alg2b (_dbe .R ,_bge ,_gfe ,nil );if _cfe !=nil {return _cfe ;};U :=make ([]byte ,len (_abae )+len (_daeb )+len (_bbg ));
_cda =copy (U ,_abae [:32]);_cda +=copy (U [_cda :],_daeb );copy (U [_cda :],_bbg );_dbe .U =U ;_cda =len (_gfe );copy (_bge [_cda :],_bbg );_abae ,_cfe =_eede .alg2b (_dbe .R ,_bge ,_gfe ,nil );if _cfe !=nil {return _cfe ;};_fcbb ,_cfe :=_adg (_abae [:32]);
if _cfe !=nil {return _cfe ;};_ebgc :=make ([]byte ,_ac .BlockSize );_cad :=_f .NewCBCEncrypter (_fcbb ,_ebgc );UE :=make ([]byte ,32);_cad .CryptBlocks (UE ,_beb [:32]);_dbe .UE =UE ;return nil ;};

// Authenticate implements StdHandler interface.
func (_fde stdHandlerR4 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){_fe .Log .Trace ("\u0044\u0065b\u0075\u0067\u0067\u0069n\u0067\u0020a\u0075\u0074\u0068\u0065\u006e\u0074\u0069\u0063a\u0074\u0069\u006f\u006e\u0020\u002d\u0020\u006f\u0077\u006e\u0065\u0072 \u0070\u0061\u0073\u0073");
_aebf ,_agd :=_fde .alg7 (d ,pass );if _agd !=nil {return nil ,0,_agd ;};if _aebf !=nil {_fe .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _aebf ,PermOwner ,nil ;
};_fe .Log .Trace ("\u0044\u0065bu\u0067\u0067\u0069n\u0067\u0020\u0061\u0075the\u006eti\u0063\u0061\u0074\u0069\u006f\u006e\u0020- \u0075\u0073\u0065\u0072\u0020\u0070\u0061s\u0073");_aebf ,_agd =_fde .alg6 (d ,pass );if _agd !=nil {return nil ,0,_agd ;
};if _aebf !=nil {_fe .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _aebf ,d .P ,nil ;};return nil ,0,nil ;};func (_bbc stdHandlerR6 )alg10 (_bbcd *StdEncryptDict ,_dab []byte )error {if _bdfa :=_gb ("\u0061\u006c\u00671\u0030","\u004b\u0065\u0079",32,_dab );
_bdfa !=nil {return _bdfa ;};_fddd :=uint64 (uint32 (_bbcd .P ))|(_bgd .MaxUint32 <<32);Perms :=make ([]byte ,16);_bg .LittleEndian .PutUint64 (Perms [:8],_fddd );if _bbcd .EncryptMetadata {Perms [8]='T';}else {Perms [8]='F';};copy (Perms [9:12],"\u0061\u0064\u0062");
if _ ,_bfa :=_fb .ReadFull (_acd .Reader ,Perms [12:16]);_bfa !=nil {return _bfa ;};_fge ,_agc :=_adg (_dab [:32]);if _agc !=nil {return _agc ;};_fcg :=_db (_fge );_fcg .CryptBlocks (Perms ,Perms );_bbcd .Perms =Perms [:16];return nil ;};

// Authenticate implements StdHandler interface.
func (_agce stdHandlerR6 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){return _agce .alg2a (d ,pass );};func (_fbd stdHandlerR6 )alg9 (_bgg *StdEncryptDict ,_cdab []byte ,_dfff []byte )error {if _cfg :=_gb ("\u0061\u006c\u0067\u0039","\u004b\u0065\u0079",32,_cdab );
_cfg !=nil {return _cfg ;};if _aac :=_gb ("\u0061\u006c\u0067\u0039","\u0055",48,_bgg .U );_aac !=nil {return _aac ;};var _bgee [16]byte ;if _ ,_abe :=_fb .ReadFull (_acd .Reader ,_bgee [:]);_abe !=nil {return _abe ;};_af :=_bgee [0:8];_cebb :=_bgee [8:16];
_afg :=_bgg .U [:48];_ffe :=make ([]byte ,len (_dfff )+len (_af )+len (_afg ));_fdad :=copy (_ffe ,_dfff );_fdad +=copy (_ffe [_fdad :],_af );_fdad +=copy (_ffe [_fdad :],_afg );_cdgfa ,_abf :=_fbd .alg2b (_bgg .R ,_ffe ,_dfff ,_afg );if _abf !=nil {return _abf ;
};O :=make ([]byte ,len (_cdgfa )+len (_af )+len (_cebb ));_fdad =copy (O ,_cdgfa [:32]);_fdad +=copy (O [_fdad :],_af );_fdad +=copy (O [_fdad :],_cebb );_bgg .O =O ;_fdad =len (_dfff );_fdad +=copy (_ffe [_fdad :],_cebb );_cdgfa ,_abf =_fbd .alg2b (_bgg .R ,_ffe ,_dfff ,_afg );
if _abf !=nil {return _abf ;};_cb ,_abf :=_adg (_cdgfa [:32]);if _abf !=nil {return _abf ;};_eef :=make ([]byte ,_ac .BlockSize );_gdab :=_f .NewCBCEncrypter (_cb ,_eef );OE :=make ([]byte ,32);_gdab .CryptBlocks (OE ,_cdab [:32]);_bgg .OE =OE ;return nil ;
};

// GenerateParams generates and sets O and U parameters for the encryption dictionary.
// It expects R, P and EncryptMetadata fields to be set.
func (_dcd stdHandlerR4 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){O ,_bdd :=_dcd .alg3 (d .R ,upass ,opass );if _bdd !=nil {_fe .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_bdd );
return nil ,_bdd ;};d .O =O ;_fe .Log .Trace ("\u0067\u0065\u006e\u0020\u004f\u003a\u0020\u0025\u0020\u0078",O );_ebg :=_dcd .alg2 (d ,upass );U ,_bdd :=_dcd .alg5 (_ebg ,upass );if _bdd !=nil {_fe .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_bdd );
return nil ,_bdd ;};d .U =U ;_fe .Log .Trace ("\u0067\u0065\u006e\u0020\u0055\u003a\u0020\u0025\u0020\u0078",U );return _ebg ,nil ;};const _dbd ="\x28\277\116\136\x4e\x75\x8a\x41\x64\000\x4e\x56\377"+"\xfa\001\010\056\x2e\x00\xb6\xd0\x68\076\x80\x2f\014"+"\251\xfe\x64\x53\x69\172";
type errInvalidField struct{Func string ;Field string ;Exp int ;Got int ;};const (EventDocOpen =AuthEvent ("\u0044o\u0063\u004f\u0070\u0065\u006e");EventEFOpen =AuthEvent ("\u0045\u0046\u004f\u0070\u0065\u006e"););func (_fgf stdHandlerR6 )alg12 (_cdad *StdEncryptDict ,_ea []byte )([]byte ,error ){if _dffca :=_gb ("\u0061\u006c\u00671\u0032","\u0055",48,_cdad .U );
_dffca !=nil {return nil ,_dffca ;};if _bgdb :=_gb ("\u0061\u006c\u00671\u0032","\u004f",48,_cdad .O );_bgdb !=nil {return nil ,_bgdb ;};_fae :=make ([]byte ,len (_ea )+8+48);_cec :=copy (_fae ,_ea );_cec +=copy (_fae [_cec :],_cdad .O [32:40]);_cec +=copy (_fae [_cec :],_cdad .U [0:48]);
_dbec ,_fdf :=_fgf .alg2b (_cdad .R ,_fae ,_ea ,_cdad .U [0:48]);if _fdf !=nil {return nil ,_fdf ;};_dbec =_dbec [:32];if !_dc .Equal (_dbec ,_cdad .O [:32]){return nil ,nil ;};return _dbec ,nil ;};