//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package security ;import (_bd "bytes";_ad "crypto/aes";_e "crypto/cipher";_ddb "crypto/md5";_gb "crypto/rand";_aea "crypto/rc4";_g "crypto/sha256";_b "crypto/sha512";_dd "encoding/binary";_de "errors";_ed "fmt";_ef "github.com/unidoc/unipdf/v3/common";
_ae "hash";_a "io";_bf "math";);type ecb struct{_adb _e .Block ;_bg int ;};

// Authenticate implements StdHandler interface.
func (_cab stdHandlerR4 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){_ef .Log .Trace ("\u0044\u0065b\u0075\u0067\u0067\u0069n\u0067\u0020a\u0075\u0074\u0068\u0065\u006e\u0074\u0069\u0063a\u0074\u0069\u006f\u006e\u0020\u002d\u0020\u006f\u0077\u006e\u0065\u0072 \u0070\u0061\u0073\u0073");
_edd ,_efce :=_cab .alg7 (d ,pass );if _efce !=nil {return nil ,0,_efce ;};if _edd !=nil {_ef .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _edd ,PermOwner ,nil ;
};_ef .Log .Trace ("\u0044\u0065bu\u0067\u0067\u0069n\u0067\u0020\u0061\u0075the\u006eti\u0063\u0061\u0074\u0069\u006f\u006e\u0020- \u0075\u0073\u0065\u0072\u0020\u0070\u0061s\u0073");_edd ,_efce =_cab .alg6 (d ,pass );if _efce !=nil {return nil ,0,_efce ;
};if _edd !=nil {_ef .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _edd ,d .P ,nil ;};return nil ,0,nil ;};func _aadd (_edcf []byte )(_e .Block ,error ){_agf ,_eec :=_ad .NewCipher (_edcf );
if _eec !=nil {_ef .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0063\u0072\u0065\u0061\u0074\u0065\u0020A\u0045\u0053\u0020\u0063\u0069p\u0068\u0065r\u003a\u0020\u0025\u0076",_eec );
return nil ,_eec ;};return _agf ,nil ;};type ecbEncrypter ecb ;type ecbDecrypter ecb ;var _ StdHandler =stdHandlerR4 {};func (_edc stdHandlerR4 )alg2 (_ba *StdEncryptDict ,_abd []byte )[]byte {_ef .Log .Trace ("\u0061\u006c\u0067\u0032");_da :=_edc .paddedPass (_abd );
_bab :=_ddb .New ();_bab .Write (_da );_bab .Write (_ba .O );var _ac [4]byte ;_dd .LittleEndian .PutUint32 (_ac [:],uint32 (_ba .P ));_bab .Write (_ac [:]);_ef .Log .Trace ("\u0067o\u0020\u0050\u003a\u0020\u0025\u0020x",_ac );_bab .Write ([]byte (_edc .ID0 ));
_ef .Log .Trace ("\u0074\u0068\u0069\u0073\u002e\u0052\u0020\u003d\u0020\u0025d\u0020\u0065\u006e\u0063\u0072\u0079\u0070t\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061\u0020\u0025\u0076",_ba .R ,_ba .EncryptMetadata );if (_ba .R >=4)&&!_ba .EncryptMetadata {_bab .Write ([]byte {0xff,0xff,0xff,0xff});
};_bc :=_bab .Sum (nil );if _ba .R >=3{_bab =_ddb .New ();for _gf :=0;_gf < 50;_gf ++{_bab .Reset ();_bab .Write (_bc [0:_edc .Length /8]);_bc =_bab .Sum (nil );};};if _ba .R >=3{return _bc [0:_edc .Length /8];};return _bc [0:5];};type stdHandlerR4 struct{Length int ;
ID0 string ;};type stdHandlerR6 struct{};func (_ggb stdHandlerR6 )alg8 (_efdc *StdEncryptDict ,_bff []byte ,_dbb []byte )error {if _dfef :=_fg ("\u0061\u006c\u0067\u0038","\u004b\u0065\u0079",32,_bff );_dfef !=nil {return _dfef ;};var _bbdg [16]byte ;if _ ,_dbf :=_a .ReadFull (_gb .Reader ,_bbdg [:]);
_dbf !=nil {return _dbf ;};_bad :=_bbdg [0:8];_gbgb :=_bbdg [8:16];_dg :=make ([]byte ,len (_dbb )+len (_bad ));_bfdg :=copy (_dg ,_dbb );copy (_dg [_bfdg :],_bad );_aff ,_fgb :=_ggb .alg2b (_efdc .R ,_dg ,_dbb ,nil );if _fgb !=nil {return _fgb ;};U :=make ([]byte ,len (_aff )+len (_bad )+len (_gbgb ));
_bfdg =copy (U ,_aff [:32]);_bfdg +=copy (U [_bfdg :],_bad );copy (U [_bfdg :],_gbgb );_efdc .U =U ;_bfdg =len (_dbb );copy (_dg [_bfdg :],_gbgb );_aff ,_fgb =_ggb .alg2b (_efdc .R ,_dg ,_dbb ,nil );if _fgb !=nil {return _fgb ;};_gec ,_fgb :=_aadd (_aff [:32]);
if _fgb !=nil {return _fgb ;};_fge :=make ([]byte ,_ad .BlockSize );_cef :=_e .NewCBCEncrypter (_gec ,_fge );UE :=make ([]byte ,32);_cef .CryptBlocks (UE ,_bff [:32]);_efdc .UE =UE ;return nil ;};func (_ead stdHandlerR4 )alg3Key (R int ,_ce []byte )[]byte {_gda :=_ddb .New ();
_bfd :=_ead .paddedPass (_ce );_gda .Write (_bfd );if R >=3{for _aed :=0;_aed < 50;_aed ++{_ee :=_gda .Sum (nil );_gda =_ddb .New ();_gda .Write (_ee );};};_cgf :=_gda .Sum (nil );if R ==2{_cgf =_cgf [0:5];}else {_cgf =_cgf [0:_ead .Length /8];};return _cgf ;
};func (_ddf stdHandlerR4 )alg5 (_bbb []byte ,_eeg []byte )([]byte ,error ){_cb :=_ddb .New ();_cb .Write ([]byte (_db ));_cb .Write ([]byte (_ddf .ID0 ));_ge :=_cb .Sum (nil );_ef .Log .Trace ("\u0061\u006c\u0067\u0035");_ef .Log .Trace ("\u0065k\u0065\u0079\u003a\u0020\u0025\u0020x",_bbb );
_ef .Log .Trace ("\u0049D\u003a\u0020\u0025\u0020\u0078",_ddf .ID0 );if len (_ge )!=16{return nil ,_de .New ("\u0068a\u0073\u0068\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074\u0020\u0031\u0036\u0020\u0062\u0079\u0074\u0065\u0073");};_cce ,_eeb :=_aea .NewCipher (_bbb );
if _eeb !=nil {return nil ,_de .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_efc :=make ([]byte ,16);_cce .XORKeyStream (_efc ,_ge );_be :=make ([]byte ,len (_bbb ));for _ecd :=0;_ecd < 19;_ecd ++{for _aag :=0;
_aag < len (_bbb );_aag ++{_be [_aag ]=_bbb [_aag ]^byte (_ecd +1);};_cce ,_eeb =_aea .NewCipher (_be );if _eeb !=nil {return nil ,_de .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_cce .XORKeyStream (_efc ,_efc );
_ef .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u002c\u0020\u0065\u006b\u0065\u0079:\u0020\u0025\u0020\u0078",_ecd ,_be );_ef .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0020\u0078",_ecd ,_efc );};_edg :=make ([]byte ,32);
for _fee :=0;_fee < 16;_fee ++{_edg [_fee ]=_efc [_fee ];};_ ,_eeb =_gb .Read (_edg [16:32]);if _eeb !=nil {return nil ,_de .New ("\u0066a\u0069\u006c\u0065\u0064 \u0074\u006f\u0020\u0067\u0065n\u0020r\u0061n\u0064\u0020\u006e\u0075\u006d\u0062\u0065r");
};return _edg ,nil ;};

// GenerateParams generates and sets O and U parameters for the encryption dictionary.
// It expects R, P and EncryptMetadata fields to be set.
func (_cf stdHandlerR4 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){O ,_aca :=_cf .alg3 (d .R ,upass ,opass );if _aca !=nil {_ef .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_aca );
return nil ,_aca ;};d .O =O ;_ef .Log .Trace ("\u0067\u0065\u006e\u0020\u004f\u003a\u0020\u0025\u0020\u0078",O );_eb :=_cf .alg2 (d ,upass );U ,_aca :=_cf .alg5 (_eb ,upass );if _aca !=nil {_ef .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_aca );
return nil ,_aca ;};d .U =U ;_ef .Log .Trace ("\u0067\u0065\u006e\u0020\u0055\u003a\u0020\u0025\u0020\u0078",U );return _eb ,nil ;};func _fg (_c ,_edb string ,_efd int ,_ab []byte )error {if len (_ab )< _efd {return errInvalidField {Func :_c ,Field :_edb ,Exp :_efd ,Got :len (_ab )};
};return nil ;};

// Permissions is a bitmask of access permissions for a PDF file.
type Permissions uint32 ;

// NewHandlerR4 creates a new standard security handler for R<=4.
func NewHandlerR4 (id0 string ,length int )StdHandler {return stdHandlerR4 {ID0 :id0 ,Length :length }};func (_ebdg stdHandlerR6 )alg10 (_ade *StdEncryptDict ,_fcfa []byte )error {if _ebcf :=_fg ("\u0061\u006c\u00671\u0030","\u004b\u0065\u0079",32,_fcfa );
_ebcf !=nil {return _ebcf ;};_efdce :=uint64 (uint32 (_ade .P ))|(_bf .MaxUint32 <<32);Perms :=make ([]byte ,16);_dd .LittleEndian .PutUint64 (Perms [:8],_efdce );if _ade .EncryptMetadata {Perms [8]='T';}else {Perms [8]='F';};copy (Perms [9:12],"\u0061\u0064\u0062");
if _ ,_aab :=_a .ReadFull (_gb .Reader ,Perms [12:16]);_aab !=nil {return _aab ;};_fda ,_ccg :=_aadd (_fcfa [:32]);if _ccg !=nil {return _ccg ;};_gdef :=_fe (_fda );_gdef .CryptBlocks (Perms ,Perms );_ade .Perms =Perms [:16];return nil ;};type errInvalidField struct{Func string ;
Field string ;Exp int ;Got int ;};

// NewHandlerR6 creates a new standard security handler for R=5 and R=6.
func NewHandlerR6 ()StdHandler {return stdHandlerR6 {}};func (_ddc stdHandlerR6 )alg11 (_efdf *StdEncryptDict ,_gecc []byte )([]byte ,error ){if _baf :=_fg ("\u0061\u006c\u00671\u0031","\u0055",48,_efdf .U );_baf !=nil {return nil ,_baf ;};_bdeg :=make ([]byte ,len (_gecc )+8);
_ffeg :=copy (_bdeg ,_gecc );_ffeg +=copy (_bdeg [_ffeg :],_efdf .U [32:40]);_adda ,_gcc :=_ddc .alg2b (_efdf .R ,_bdeg ,_gecc ,nil );if _gcc !=nil {return nil ,_gcc ;};_adda =_adda [:32];if !_bd .Equal (_adda ,_efdf .U [:32]){return nil ,nil ;};return _adda ,nil ;
};

// GenerateParams is the algorithm opposite to alg2a (R>=5).
// It generates U,O,UE,OE,Perms fields using AESv3 encryption.
// There is no algorithm number assigned to this function in the spec.
// It expects R, P and EncryptMetadata fields to be set.
func (_cec stdHandlerR6 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){_aeec :=make ([]byte ,32);if _ ,_deb :=_a .ReadFull (_gb .Reader ,_aeec );_deb !=nil {return nil ,_deb ;};d .U =nil ;d .O =nil ;d .UE =nil ;d .OE =nil ;d .Perms =nil ;
if len (upass )> 127{upass =upass [:127];};if len (opass )> 127{opass =opass [:127];};if _eaf :=_cec .alg8 (d ,_aeec ,upass );_eaf !=nil {return nil ,_eaf ;};if _acc :=_cec .alg9 (d ,_aeec ,opass );_acc !=nil {return nil ,_acc ;};if d .R ==5{return _aeec ,nil ;
};if _cdbe :=_cec .alg10 (d ,_aeec );_cdbe !=nil {return nil ,_cdbe ;};return _aeec ,nil ;};func (_dbff stdHandlerR6 )alg9 (_ege *StdEncryptDict ,_eadd []byte ,_fggg []byte )error {if _ecc :=_fg ("\u0061\u006c\u0067\u0039","\u004b\u0065\u0079",32,_eadd );
_ecc !=nil {return _ecc ;};if _ccc :=_fg ("\u0061\u006c\u0067\u0039","\u0055",48,_ege .U );_ccc !=nil {return _ccc ;};var _ecga [16]byte ;if _ ,_dcc :=_a .ReadFull (_gb .Reader ,_ecga [:]);_dcc !=nil {return _dcc ;};_fbc :=_ecga [0:8];_bed :=_ecga [8:16];
_bdef :=_ege .U [:48];_gab :=make ([]byte ,len (_fggg )+len (_fbc )+len (_bdef ));_dcb :=copy (_gab ,_fggg );_dcb +=copy (_gab [_dcb :],_fbc );_dcb +=copy (_gab [_dcb :],_bdef );_cge ,_bbc :=_dbff .alg2b (_ege .R ,_gab ,_fggg ,_bdef );if _bbc !=nil {return _bbc ;
};O :=make ([]byte ,len (_cge )+len (_fbc )+len (_bed ));_dcb =copy (O ,_cge [:32]);_dcb +=copy (O [_dcb :],_fbc );_dcb +=copy (O [_dcb :],_bed );_ege .O =O ;_dcb =len (_fggg );_dcb +=copy (_gab [_dcb :],_bed );_cge ,_bbc =_dbff .alg2b (_ege .R ,_gab ,_fggg ,_bdef );
if _bbc !=nil {return _bbc ;};_fgf ,_bbc :=_aadd (_cge [:32]);if _bbc !=nil {return _bbc ;};_bbdc :=make ([]byte ,_ad .BlockSize );_bfa :=_e .NewCBCEncrypter (_fgf ,_bbdc );OE :=make ([]byte ,32);_bfa .CryptBlocks (OE ,_eadd [:32]);_ege .OE =OE ;return nil ;
};func (_ded stdHandlerR4 )alg4 (_aeb []byte ,_bfdb []byte )([]byte ,error ){_bgd ,_abgg :=_aea .NewCipher (_aeb );if _abgg !=nil {return nil ,_de .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_bae :=[]byte (_db );
_cgc :=make ([]byte ,len (_bae ));_bgd .XORKeyStream (_cgc ,_bae );return _cgc ,nil ;};

// StdEncryptDict is a set of additional fields used in standard encryption dictionary.
type StdEncryptDict struct{R int ;P Permissions ;EncryptMetadata bool ;O ,U []byte ;OE ,UE []byte ;Perms []byte ;};func (_efe stdHandlerR4 )alg6 (_bfbf *StdEncryptDict ,_fgc []byte )([]byte ,error ){var (_gee []byte ;_eda error ;);_bag :=_efe .alg2 (_bfbf ,_fgc );
if _bfbf .R ==2{_gee ,_eda =_efe .alg4 (_bag ,_fgc );}else if _bfbf .R >=3{_gee ,_eda =_efe .alg5 (_bag ,_fgc );}else {return nil ,_de .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};if _eda !=nil {return nil ,_eda ;};_ef .Log .Trace ("\u0063\u0068\u0065\u0063k:\u0020\u0025\u0020\u0078\u0020\u003d\u003d\u0020\u0025\u0020\u0078\u0020\u003f",string (_gee ),string (_bfbf .U ));
_aad :=_gee ;_gg :=_bfbf .U ;if _bfbf .R >=3{if len (_aad )> 16{_aad =_aad [0:16];};if len (_gg )> 16{_gg =_gg [0:16];};};if !_bd .Equal (_aad ,_gg ){return nil ,nil ;};return _bag ,nil ;};var _ StdHandler =stdHandlerR6 {};const (PermOwner =Permissions (_bf .MaxUint32 );
PermPrinting =Permissions (1<<2);PermModify =Permissions (1<<3);PermExtractGraphics =Permissions (1<<4);PermAnnotate =Permissions (1<<5);PermFillForms =Permissions (1<<8);PermDisabilityExtract =Permissions (1<<9);PermRotateInsert =Permissions (1<<10);PermFullPrintQuality =Permissions (1<<11);
);func _dbeb (_gea ,_ceg ,_cgg []byte )([]byte ,error ){var (_gfc ,_fab ,_efeg _ae .Hash ;);_gfc =_g .New ();_aee :=make ([]byte ,64);_acaa :=_gfc ;_acaa .Write (_gea );K :=_acaa .Sum (_aee [:0]);_dbd :=make ([]byte ,64*(127+64+48));_fbgb :=func (_faf int )([]byte ,error ){_becf :=len (_ceg )+len (K )+len (_cgg );
_efg :=_dbd [:_becf ];_gde :=copy (_efg ,_ceg );_gde +=copy (_efg [_gde :],K [:]);_gde +=copy (_efg [_gde :],_cgg );if _gde !=_becf {_ef .Log .Error ("E\u0052\u0052\u004f\u0052\u003a\u0020u\u006e\u0065\u0078\u0070\u0065\u0063t\u0065\u0064\u0020\u0072\u006f\u0075\u006ed\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0073\u0069\u007ae\u002e");
return nil ,_de .New ("\u0077\u0072\u006f\u006e\u0067\u0020\u0073\u0069\u007a\u0065");};K1 :=_dbd [:_becf *64];_bgb (K1 ,_becf );_gfcb ,_agc :=_aadd (K [0:16]);if _agc !=nil {return nil ,_agc ;};_bfeb :=_e .NewCBCEncrypter (_gfcb ,K [16:32]);_bfeb .CryptBlocks (K1 ,K1 );
E :=K1 ;_bcg :=0;for _cdbf :=0;_cdbf < 16;_cdbf ++{_bcg +=int (E [_cdbf ]%3);};var _fbf _ae .Hash ;switch _bcg %3{case 0:_fbf =_gfc ;case 1:if _fab ==nil {_fab =_b .New384 ();};_fbf =_fab ;case 2:if _efeg ==nil {_efeg =_b .New ();};_fbf =_efeg ;};_fbf .Reset ();
_fbf .Write (E );K =_fbf .Sum (_aee [:0]);return E ,nil ;};for _fcbg :=0;;{E ,_acab :=_fbgb (_fcbg );if _acab !=nil {return nil ,_acab ;};_gbg :=E [len (E )-1];_fcbg ++;if _fcbg >=64&&_gbg <=uint8 (_fcbg -32){break ;};};return K [:32],nil ;};func _fe (_ff _e .Block )_e .BlockMode {return (*ecbEncrypter )(_aeg (_ff ))};
func _fc (_df _e .Block )_e .BlockMode {return (*ecbDecrypter )(_aeg (_df ))};func (_fb *ecbDecrypter )CryptBlocks (dst ,src []byte ){if len (src )%_fb ._bg !=0{_ef .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_ef .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0064\u0065\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_fb ._adb .Decrypt (dst ,src [:_fb ._bg ]);src =src [_fb ._bg :];dst =dst [_fb ._bg :];};};func (_ec *ecbDecrypter )BlockSize ()int {return _ec ._bg };const (EventDocOpen =AuthEvent ("\u0044o\u0063\u004f\u0070\u0065\u006e");
EventEFOpen =AuthEvent ("\u0045\u0046\u004f\u0070\u0065\u006e"););

// Allowed checks if a set of permissions can be granted.
func (_ecg Permissions )Allowed (p2 Permissions )bool {return _ecg &p2 ==p2 };const _db ="\x28\277\116\136\x4e\x75\x8a\x41\x64\000\x4e\x56\377"+"\xfa\001\010\056\x2e\x00\xb6\xd0\x68\076\x80\x2f\014"+"\251\xfe\x64\x53\x69\172";

// StdHandler is an interface for standard security handlers.
type StdHandler interface{

// GenerateParams uses owner and user passwords to set encryption parameters and generate an encryption key.
// It assumes that R, P and EncryptMetadata are already set.
GenerateParams (_bb *StdEncryptDict ,_bdg ,_bdd []byte )([]byte ,error );

// Authenticate uses encryption dictionary parameters and the password to calculate
// the document encryption key. It also returns permissions that should be granted to a user.
// In case of failed authentication, it returns empty key and zero permissions with no error.
Authenticate (_bdc *StdEncryptDict ,_fcb []byte )([]byte ,Permissions ,error );};func (stdHandlerR4 )paddedPass (_eg []byte )[]byte {_cg :=make ([]byte ,32);_bda :=copy (_cg ,_eg );for ;_bda < 32;_bda ++{_cg [_bda ]=_db [_bda -len (_eg )];};return _cg ;
};func (_bde *ecbEncrypter )CryptBlocks (dst ,src []byte ){if len (src )%_bde ._bg !=0{_ef .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_ef .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_bde ._adb .Encrypt (dst ,src [:_bde ._bg ]);src =src [_bde ._bg :];dst =dst [_bde ._bg :];};};func (_ecca stdHandlerR6 )alg12 (_fdaa *StdEncryptDict ,_eae []byte )([]byte ,error ){if _eagf :=_fg ("\u0061\u006c\u00671\u0032","\u0055",48,_fdaa .U );
_eagf !=nil {return nil ,_eagf ;};if _cba :=_fg ("\u0061\u006c\u00671\u0032","\u004f",48,_fdaa .O );_cba !=nil {return nil ,_cba ;};_bee :=make ([]byte ,len (_eae )+8+48);_beb :=copy (_bee ,_eae );_beb +=copy (_bee [_beb :],_fdaa .O [32:40]);_beb +=copy (_bee [_beb :],_fdaa .U [0:48]);
_dde ,_adfc :=_ecca .alg2b (_fdaa .R ,_bee ,_eae ,_fdaa .U [0:48]);if _adfc !=nil {return nil ,_adfc ;};_dde =_dde [:32];if !_bd .Equal (_dde ,_fdaa .O [:32]){return nil ,nil ;};return _dde ,nil ;};

// Authenticate implements StdHandler interface.
func (_cda stdHandlerR6 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){return _cda .alg2a (d ,pass );};func (_gc stdHandlerR4 )alg3 (R int ,_fgg ,_bfb []byte )([]byte ,error ){var _ace []byte ;if len (_bfb )> 0{_ace =_gc .alg3Key (R ,_bfb );
}else {_ace =_gc .alg3Key (R ,_fgg );};_dfe ,_abg :=_aea .NewCipher (_ace );if _abg !=nil {return nil ,_de .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_ffb :=_gc .paddedPass (_fgg );_aa :=make ([]byte ,len (_ffb ));
_dfe .XORKeyStream (_aa ,_ffb );if R >=3{_cc :=make ([]byte ,len (_ace ));for _gcb :=0;_gcb < 19;_gcb ++{for _fa :=0;_fa < len (_ace );_fa ++{_cc [_fa ]=_ace [_fa ]^byte (_gcb +1);};_bgc ,_ga :=_aea .NewCipher (_cc );if _ga !=nil {return nil ,_de .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_bgc .XORKeyStream (_aa ,_aa );};};return _aa ,nil ;};func (_gd *ecbEncrypter )BlockSize ()int {return _gd ._bg };func (_ca stdHandlerR4 )alg7 (_fef *StdEncryptDict ,_gge []byte )([]byte ,error ){_ag :=_ca .alg3Key (_fef .R ,_gge );_add :=make ([]byte ,len (_fef .O ));
if _fef .R ==2{_af ,_fbg :=_aea .NewCipher (_ag );if _fbg !=nil {return nil ,_de .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_af .XORKeyStream (_add ,_fef .O );}else if _fef .R >=3{_eac :=append ([]byte {},_fef .O ...);
for _bfbb :=0;_bfbb < 20;_bfbb ++{_cd :=append ([]byte {},_ag ...);for _gad :=0;_gad < len (_ag );_gad ++{_cd [_gad ]^=byte (19-_bfbb );};_dc ,_gbd :=_aea .NewCipher (_cd );if _gbd !=nil {return nil ,_de .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");
};_dc .XORKeyStream (_add ,_eac );_eac =append ([]byte {},_add ...);};}else {return nil ,_de .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};_bec ,_dda :=_ca .alg6 (_fef ,_add );if _dda !=nil {return nil ,nil ;};return _bec ,nil ;};func (_aeed stdHandlerR6 )alg2b (R int ,_fag ,_dfa ,_ebc []byte )([]byte ,error ){if R ==5{return _dcd (_fag );
};return _dbeb (_fag ,_dfa ,_ebc );};func (_gdc errInvalidField )Error ()string {return _ed .Sprintf ("\u0025s\u003a\u0020e\u0078\u0070\u0065\u0063t\u0065\u0064\u0020%\u0073\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0074o \u0062\u0065\u0020%\u0064\u0020b\u0079\u0074\u0065\u0073\u002c\u0020g\u006f\u0074 \u0025\u0064",_gdc .Func ,_gdc .Field ,_gdc .Exp ,_gdc .Got );
};func _bgb (_fd []byte ,_adf int ){_fga :=_adf ;for _fga < len (_fd ){copy (_fd [_fga :],_fd [:_fga ]);_fga *=2;};};func (_fce stdHandlerR6 )alg13 (_fcbe *StdEncryptDict ,_gag []byte )error {if _edf :=_fg ("\u0061\u006c\u00671\u0033","\u004b\u0065\u0079",32,_gag );
_edf !=nil {return _edf ;};if _cdc :=_fg ("\u0061\u006c\u00671\u0033","\u0050\u0065\u0072m\u0073",16,_fcbe .Perms );_cdc !=nil {return _cdc ;};_cfe :=make ([]byte ,16);copy (_cfe ,_fcbe .Perms [:16]);_fbge ,_fbff :=_ad .NewCipher (_gag [:32]);if _fbff !=nil {return _fbff ;
};_eeda :=_fc (_fbge );_eeda .CryptBlocks (_cfe ,_cfe );if !_bd .Equal (_cfe [9:12],[]byte ("\u0061\u0064\u0062")){return _de .New ("\u0064\u0065\u0063o\u0064\u0065\u0064\u0020p\u0065\u0072\u006d\u0069\u0073\u0073\u0069o\u006e\u0073\u0020\u0061\u0072\u0065\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};_dbea :=Permissions (_dd .LittleEndian .Uint32 (_cfe [0:4]));if _dbea !=_fcbe .P {return _de .New ("\u0070\u0065r\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066\u0061il\u0065\u0064");
};var _fac bool ;if _cfe [8]=='T'{_fac =true ;}else if _cfe [8]=='F'{_fac =false ;}else {return _de .New ("\u0064\u0065\u0063\u006f\u0064\u0065\u0064 \u006d\u0065\u0074a\u0064\u0061\u0074\u0061 \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u006c\u0061\u0067\u0020\u0069\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};if _fac !=_fcbe .EncryptMetadata {return _de .New ("\u006d\u0065t\u0061\u0064\u0061\u0074a\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e \u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066a\u0069\u006c\u0065\u0064");
};return nil ;};func (_bbd stdHandlerR6 )alg2a (_aaa *StdEncryptDict ,_gbdb []byte )([]byte ,Permissions ,error ){if _cdb :=_fg ("\u0061\u006c\u00672\u0061","\u004f",48,_aaa .O );_cdb !=nil {return nil ,0,_cdb ;};if _fca :=_fg ("\u0061\u006c\u00672\u0061","\u0055",48,_aaa .U );
_fca !=nil {return nil ,0,_fca ;};if len (_gbdb )> 127{_gbdb =_gbdb [:127];};_abb ,_gbb :=_bbd .alg12 (_aaa ,_gbdb );if _gbb !=nil {return nil ,0,_gbb ;};var (_ebdc []byte ;_bbf []byte ;_dbe []byte ;);var _eed Permissions ;if len (_abb )!=0{_eed =PermOwner ;
_fcf :=make ([]byte ,len (_gbdb )+8+48);_aaddc :=copy (_fcf ,_gbdb );_aaddc +=copy (_fcf [_aaddc :],_aaa .O [40:48]);copy (_fcf [_aaddc :],_aaa .U [0:48]);_ebdc =_fcf ;_bbf =_aaa .OE ;_dbe =_aaa .U [0:48];}else {_abb ,_gbb =_bbd .alg11 (_aaa ,_gbdb );if _gbb ==nil &&len (_abb )==0{_abb ,_gbb =_bbd .alg11 (_aaa ,[]byte (""));
};if _gbb !=nil {return nil ,0,_gbb ;}else if len (_abb )==0{return nil ,0,nil ;};_eed =_aaa .P ;_cga :=make ([]byte ,len (_gbdb )+8);_cdd :=copy (_cga ,_gbdb );copy (_cga [_cdd :],_aaa .U [40:48]);_ebdc =_cga ;_bbf =_aaa .UE ;_dbe =nil ;};if _aae :=_fg ("\u0061\u006c\u00672\u0061","\u004b\u0065\u0079",32,_bbf );
_aae !=nil {return nil ,0,_aae ;};_bbf =_bbf [:32];_ggc ,_gbb :=_bbd .alg2b (_aaa .R ,_ebdc ,_gbdb ,_dbe );if _gbb !=nil {return nil ,0,_gbb ;};_gfe ,_gbb :=_ad .NewCipher (_ggc [:32]);if _gbb !=nil {return nil ,0,_gbb ;};_bfe :=make ([]byte ,_ad .BlockSize );
_eag :=_e .NewCBCDecrypter (_gfe ,_bfe );_dag :=make ([]byte ,32);_eag .CryptBlocks (_dag ,_bbf );if _aaa .R ==5{return _dag ,_eed ,nil ;};_gbb =_bbd .alg13 (_aaa ,_dag );if _gbb !=nil {return nil ,0,_gbb ;};return _dag ,_eed ,nil ;};

// AuthEvent is an event type that triggers authentication.
type AuthEvent string ;func _aeg (_f _e .Block )*ecb {return &ecb {_adb :_f ,_bg :_f .BlockSize ()}};func _dcd (_bfc []byte )([]byte ,error ){_edbf :=_g .New ();_edbf .Write (_bfc );return _edbf .Sum (nil ),nil ;};