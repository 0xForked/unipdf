//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package security ;import (_d "bytes";_agc "crypto/aes";_c "crypto/cipher";_eb "crypto/md5";_ae "crypto/rand";_cf "crypto/rc4";_b "crypto/sha256";_ag "crypto/sha512";_fg "encoding/binary";_f "errors";_aa "fmt";_cb "github.com/unidoc/unipdf/v3/common";_af "hash";
_a "io";_g "math";);func _fbf (_ebb []byte )(_c .Block ,error ){_df ,_gfbg :=_agc .NewCipher (_ebb );if _gfbg !=nil {_cb .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0063\u0072\u0065\u0061\u0074\u0065\u0020A\u0045\u0053\u0020\u0063\u0069p\u0068\u0065r\u003a\u0020\u0025\u0076",_gfbg );
return nil ,_gfbg ;};return _df ,nil ;};

// GenerateParams is the algorithm opposite to alg2a (R>=5).
// It generates U,O,UE,OE,Perms fields using AESv3 encryption.
// There is no algorithm number assigned to this function in the spec.
// It expects R, P and EncryptMetadata fields to be set.
func (_ddg stdHandlerR6 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){_fff :=make ([]byte ,32);if _ ,_acc :=_a .ReadFull (_ae .Reader ,_fff );_acc !=nil {return nil ,_acc ;};d .U =nil ;d .O =nil ;d .UE =nil ;d .OE =nil ;d .Perms =nil ;
if len (upass )> 127{upass =upass [:127];};if len (opass )> 127{opass =opass [:127];};if _bcd :=_ddg .alg8 (d ,_fff ,upass );_bcd !=nil {return nil ,_bcd ;};if _dgg :=_ddg .alg9 (d ,_fff ,opass );_dgg !=nil {return nil ,_dgg ;};if d .R ==5{return _fff ,nil ;
};if _eab :=_ddg .alg10 (d ,_fff );_eab !=nil {return nil ,_eab ;};return _fff ,nil ;};func (_ddc stdHandlerR4 )alg4 (_efca []byte ,_fba []byte )([]byte ,error ){_fag ,_ed :=_cf .NewCipher (_efca );if _ed !=nil {return nil ,_f .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_ede :=[]byte (_bbf );_cc :=make ([]byte ,len (_ede ));_fag .XORKeyStream (_cc ,_ede );return _cc ,nil ;};

// Permissions is a bitmask of access permissions for a PDF file.
type Permissions uint32 ;

// AuthEvent is an event type that triggers authentication.
type AuthEvent string ;func (_eca stdHandlerR6 )alg2b (R int ,_fcc ,_gef ,_aab []byte )([]byte ,error ){if R ==5{return _gcb (_fcc );};return _fcb (_fcc ,_gef ,_aab );};func (stdHandlerR4 )paddedPass (_ba []byte )[]byte {_gg :=make ([]byte ,32);_ecc :=copy (_gg ,_ba );
for ;_ecc < 32;_ecc ++{_gg [_ecc ]=_bbf [_ecc -len (_ba )];};return _gg ;};func (_cbg errInvalidField )Error ()string {return _aa .Sprintf ("\u0025s\u003a\u0020e\u0078\u0070\u0065\u0063t\u0065\u0064\u0020%\u0073\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0074o \u0062\u0065\u0020%\u0064\u0020b\u0079\u0074\u0065\u0073\u002c\u0020g\u006f\u0074 \u0025\u0064",_cbg .Func ,_cbg .Field ,_cbg .Exp ,_cbg .Got );
};func (_de stdHandlerR4 )alg2 (_fa *StdEncryptDict ,_ced []byte )[]byte {_cb .Log .Trace ("\u0061\u006c\u0067\u0032");_ea :=_de .paddedPass (_ced );_ceb :=_eb .New ();_ceb .Write (_ea );_ceb .Write (_fa .O );var _bbg [4]byte ;_fg .LittleEndian .PutUint32 (_bbg [:],uint32 (_fa .P ));
_ceb .Write (_bbg [:]);_cb .Log .Trace ("\u0067o\u0020\u0050\u003a\u0020\u0025\u0020x",_bbg );_ceb .Write ([]byte (_de .ID0 ));_cb .Log .Trace ("\u0074\u0068\u0069\u0073\u002e\u0052\u0020\u003d\u0020\u0025d\u0020\u0065\u006e\u0063\u0072\u0079\u0070t\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061\u0020\u0025\u0076",_fa .R ,_fa .EncryptMetadata );
if (_fa .R >=4)&&!_fa .EncryptMetadata {_ceb .Write ([]byte {0xff,0xff,0xff,0xff});};_bea :=_ceb .Sum (nil );if _fa .R >=3{_ceb =_eb .New ();for _gaf :=0;_gaf < 50;_gaf ++{_ceb .Reset ();_ceb .Write (_bea [0:_de .Length /8]);_bea =_ceb .Sum (nil );};};
if _fa .R >=3{return _bea [0:_de .Length /8];};return _bea [0:5];};func (_bf stdHandlerR4 )alg7 (_ccd *StdEncryptDict ,_befb []byte )([]byte ,error ){_efe :=_bf .alg3Key (_ccd .R ,_befb );_ffa :=make ([]byte ,len (_ccd .O ));if _ccd .R ==2{_fe ,_ebe :=_cf .NewCipher (_efe );
if _ebe !=nil {return nil ,_f .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_fe .XORKeyStream (_ffa ,_ccd .O );}else if _ccd .R >=3{_bdb :=append ([]byte {},_ccd .O ...);for _dee :=0;_dee < 20;_dee ++{_cgg :=append ([]byte {},_efe ...);
for _gcac :=0;_gcac < len (_efe );_gcac ++{_cgg [_gcac ]^=byte (19-_dee );};_gfba ,_gbg :=_cf .NewCipher (_cgg );if _gbg !=nil {return nil ,_f .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_gfba .XORKeyStream (_ffa ,_bdb );
_bdb =append ([]byte {},_ffa ...);};}else {return nil ,_f .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};_fcg ,_fdb :=_bf .alg6 (_ccd ,_ffa );if _fdb !=nil {return nil ,nil ;};return _fcg ,nil ;};func _bb (_be ,_beg string ,_ebf int ,_geg []byte )error {if len (_geg )< _ebf {return errInvalidField {Func :_be ,Field :_beg ,Exp :_ebf ,Got :len (_geg )};
};return nil ;};type errInvalidField struct{Func string ;Field string ;Exp int ;Got int ;};

// GenerateParams generates and sets O and U parameters for the encryption dictionary.
// It expects R, P and EncryptMetadata fields to be set.
func (_fbg stdHandlerR4 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){O ,_degb :=_fbg .alg3 (d .R ,upass ,opass );if _degb !=nil {_cb .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_degb );
return nil ,_degb ;};d .O =O ;_cb .Log .Trace ("\u0067\u0065\u006e\u0020\u004f\u003a\u0020\u0025\u0020\u0078",O );_fbe :=_fbg .alg2 (d ,upass );U ,_degb :=_fbg .alg5 (_fbe ,upass );if _degb !=nil {_cb .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_degb );
return nil ,_degb ;};d .U =U ;_cb .Log .Trace ("\u0067\u0065\u006e\u0020\u0055\u003a\u0020\u0025\u0020\u0078",U );return _fbe ,nil ;};func (_fb *ecbDecrypter )BlockSize ()int {return _fb ._cbd };func (_gegc stdHandlerR4 )alg3 (R int ,_deg ,_fcda []byte )([]byte ,error ){var _cg []byte ;
if len (_fcda )> 0{_cg =_gegc .alg3Key (R ,_fcda );}else {_cg =_gegc .alg3Key (R ,_deg );};_bg ,_fd :=_cf .NewCipher (_cg );if _fd !=nil {return nil ,_f .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_efg :=_gegc .paddedPass (_deg );
_efc :=make ([]byte ,len (_efg ));_bg .XORKeyStream (_efc ,_efg );if R >=3{_dga :=make ([]byte ,len (_cg ));for _gc :=0;_gc < 19;_gc ++{for _fgg :=0;_fgg < len (_cg );_fgg ++{_dga [_fgg ]=_cg [_fgg ]^byte (_gc +1);};_ged ,_eae :=_cf .NewCipher (_dga );
if _eae !=nil {return nil ,_f .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_ged .XORKeyStream (_efc ,_efc );};};return _efc ,nil ;};func (_bbc stdHandlerR4 )alg3Key (R int ,_dge []byte )[]byte {_ee :=_eb .New ();
_gfg :=_bbc .paddedPass (_dge );_ee .Write (_gfg );if R >=3{for _bef :=0;_bef < 50;_bef ++{_ebc :=_ee .Sum (nil );_ee =_eb .New ();_ee .Write (_ebc );};};_cea :=_ee .Sum (nil );if R ==2{_cea =_cea [0:5];}else {_cea =_cea [0:_bbc .Length /8];};return _cea ;
};func _fga (_gb _c .Block )_c .BlockMode {return (*ecbDecrypter )(_ef (_gb ))};type ecbEncrypter ecb ;func (_edf stdHandlerR6 )alg10 (_dfe *StdEncryptDict ,_fdcb []byte )error {if _gda :=_bb ("\u0061\u006c\u00671\u0030","\u004b\u0065\u0079",32,_fdcb );
_gda !=nil {return _gda ;};_afc :=uint64 (uint32 (_dfe .P ))|(_g .MaxUint32 <<32);Perms :=make ([]byte ,16);_fg .LittleEndian .PutUint64 (Perms [:8],_afc );if _dfe .EncryptMetadata {Perms [8]='T';}else {Perms [8]='F';};copy (Perms [9:12],"\u0061\u0064\u0062");
if _ ,_acf :=_a .ReadFull (_ae .Reader ,Perms [12:16]);_acf !=nil {return _acf ;};_ffe ,_gec :=_fbf (_fdcb [:32]);if _gec !=nil {return _gec ;};_aead :=_dd (_ffe );_aead .CryptBlocks (Perms ,Perms );_dfe .Perms =Perms [:16];return nil ;};type stdHandlerR4 struct{Length int ;
ID0 string ;};

// NewHandlerR4 creates a new standard security handler for R<=4.
func NewHandlerR4 (id0 string ,length int )StdHandler {return stdHandlerR4 {ID0 :id0 ,Length :length }};func (_gf *ecbDecrypter )CryptBlocks (dst ,src []byte ){if len (src )%_gf ._cbd !=0{_cb .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_cb .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0064\u0065\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_gf ._ec .Decrypt (dst ,src [:_gf ._cbd ]);src =src [_gf ._cbd :];dst =dst [_gf ._cbd :];};};type ecb struct{_ec _c .Block ;_cbd int ;};

// StdHandler is an interface for standard security handlers.
type StdHandler interface{

// GenerateParams uses owner and user passwords to set encryption parameters and generate an encryption key.
// It assumes that R, P and EncryptMetadata are already set.
GenerateParams (_ge *StdEncryptDict ,_ad ,_fcd []byte )([]byte ,error );

// Authenticate uses encryption dictionary parameters and the password to calculate
// the document encryption key. It also returns permissions that should be granted to a user.
// In case of failed authentication, it returns empty key and zero permissions with no error.
Authenticate (_ga *StdEncryptDict ,_gbc []byte )([]byte ,Permissions ,error );};func (_afe stdHandlerR4 )alg5 (_ff []byte ,_bae []byte )([]byte ,error ){_aad :=_eb .New ();_aad .Write ([]byte (_bbf ));_aad .Write ([]byte (_afe .ID0 ));_cga :=_aad .Sum (nil );
_cb .Log .Trace ("\u0061\u006c\u0067\u0035");_cb .Log .Trace ("\u0065k\u0065\u0079\u003a\u0020\u0025\u0020x",_ff );_cb .Log .Trace ("\u0049D\u003a\u0020\u0025\u0020\u0078",_afe .ID0 );if len (_cga )!=16{return nil ,_f .New ("\u0068a\u0073\u0068\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074\u0020\u0031\u0036\u0020\u0062\u0079\u0074\u0065\u0073");
};_aff ,_fgaa :=_cf .NewCipher (_ff );if _fgaa !=nil {return nil ,_f .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_eccd :=make ([]byte ,16);_aff .XORKeyStream (_eccd ,_cga );_gca :=make ([]byte ,len (_ff ));
for _aeb :=0;_aeb < 19;_aeb ++{for _dgf :=0;_dgf < len (_ff );_dgf ++{_gca [_dgf ]=_ff [_dgf ]^byte (_aeb +1);};_aff ,_fgaa =_cf .NewCipher (_gca );if _fgaa !=nil {return nil ,_f .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_aff .XORKeyStream (_eccd ,_eccd );_cb .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u002c\u0020\u0065\u006b\u0065\u0079:\u0020\u0025\u0020\u0078",_aeb ,_gca );_cb .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0020\u0078",_aeb ,_eccd );
};_ggf :=make ([]byte ,32);for _cag :=0;_cag < 16;_cag ++{_ggf [_cag ]=_eccd [_cag ];};_ ,_fgaa =_ae .Read (_ggf [16:32]);if _fgaa !=nil {return nil ,_f .New ("\u0066a\u0069\u006c\u0065\u0064 \u0074\u006f\u0020\u0067\u0065n\u0020r\u0061n\u0064\u0020\u006e\u0075\u006d\u0062\u0065r");
};return _ggf ,nil ;};func _gcb (_db []byte )([]byte ,error ){_ccc :=_b .New ();_ccc .Write (_db );return _ccc .Sum (nil ),nil };

// Allowed checks if a set of permissions can be granted.
func (_ca Permissions )Allowed (p2 Permissions )bool {return _ca &p2 ==p2 };func (_gfb stdHandlerR4 )alg6 (_eaf *StdEncryptDict ,_afed []byte )([]byte ,error ){var (_aea []byte ;_ece error ;);_gfd :=_gfb .alg2 (_eaf ,_afed );if _eaf .R ==2{_aea ,_ece =_gfb .alg4 (_gfd ,_afed );
}else if _eaf .R >=3{_aea ,_ece =_gfb .alg5 (_gfd ,_afed );}else {return nil ,_f .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};if _ece !=nil {return nil ,_ece ;};_cb .Log .Trace ("\u0063\u0068\u0065\u0063k:\u0020\u0025\u0020\u0078\u0020\u003d\u003d\u0020\u0025\u0020\u0078\u0020\u003f",string (_aea ),string (_eaf .U ));
_bee :=_aea ;_fce :=_eaf .U ;if _eaf .R >=3{if len (_bee )> 16{_bee =_bee [0:16];};if len (_fce )> 16{_fce =_fce [0:16];};};if !_d .Equal (_bee ,_fce ){return nil ,nil ;};return _gfd ,nil ;};var _ StdHandler =stdHandlerR6 {};

// Authenticate implements StdHandler interface.
func (_bdg stdHandlerR6 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){return _bdg .alg2a (d ,pass );};

// Authenticate implements StdHandler interface.
func (_cgd stdHandlerR4 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){_cb .Log .Trace ("\u0044\u0065b\u0075\u0067\u0067\u0069n\u0067\u0020a\u0075\u0074\u0068\u0065\u006e\u0074\u0069\u0063a\u0074\u0069\u006f\u006e\u0020\u002d\u0020\u006f\u0077\u006e\u0065\u0072 \u0070\u0061\u0073\u0073");
_agd ,_ggc :=_cgd .alg7 (d ,pass );if _ggc !=nil {return nil ,0,_ggc ;};if _agd !=nil {_cb .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _agd ,PermOwner ,nil ;
};_cb .Log .Trace ("\u0044\u0065bu\u0067\u0067\u0069n\u0067\u0020\u0061\u0075the\u006eti\u0063\u0061\u0074\u0069\u006f\u006e\u0020- \u0075\u0073\u0065\u0072\u0020\u0070\u0061s\u0073");_agd ,_ggc =_cgd .alg6 (d ,pass );if _ggc !=nil {return nil ,0,_ggc ;
};if _agd !=nil {_cb .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _agd ,d .P ,nil ;};return nil ,0,nil ;};func (_dg *ecbEncrypter )CryptBlocks (dst ,src []byte ){if len (src )%_dg ._cbd !=0{_cb .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_cb .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_dg ._ec .Encrypt (dst ,src [:_dg ._cbd ]);src =src [_dg ._cbd :];dst =dst [_dg ._cbd :];};};func (_beed stdHandlerR6 )alg9 (_fage *StdEncryptDict ,_ecd []byte ,_fdc []byte )error {if _ecaa :=_bb ("\u0061\u006c\u0067\u0039","\u004b\u0065\u0079",32,_ecd );
_ecaa !=nil {return _ecaa ;};if _gba :=_bb ("\u0061\u006c\u0067\u0039","\u0055",48,_fage .U );_gba !=nil {return _gba ;};var _eed [16]byte ;if _ ,_aca :=_a .ReadFull (_ae .Reader ,_eed [:]);_aca !=nil {return _aca ;};_gbcg :=_eed [0:8];_dda :=_eed [8:16];
_gaag :=_fage .U [:48];_cebe :=make ([]byte ,len (_fdc )+len (_gbcg )+len (_gaag ));_eeb :=copy (_cebe ,_fdc );_eeb +=copy (_cebe [_eeb :],_gbcg );_eeb +=copy (_cebe [_eeb :],_gaag );_dcd ,_add :=_beed .alg2b (_fage .R ,_cebe ,_fdc ,_gaag );if _add !=nil {return _add ;
};O :=make ([]byte ,len (_dcd )+len (_gbcg )+len (_dda ));_eeb =copy (O ,_dcd [:32]);_eeb +=copy (O [_eeb :],_gbcg );_eeb +=copy (O [_eeb :],_dda );_fage .O =O ;_eeb =len (_fdc );_eeb +=copy (_cebe [_eeb :],_dda );_dcd ,_add =_beed .alg2b (_fage .R ,_cebe ,_fdc ,_gaag );
if _add !=nil {return _add ;};_dffd ,_add :=_fbf (_dcd [:32]);if _add !=nil {return _add ;};_fec :=make ([]byte ,_agc .BlockSize );_eea :=_c .NewCBCEncrypter (_dffd ,_fec );OE :=make ([]byte ,32);_eea .CryptBlocks (OE ,_ecd [:32]);_fage .OE =OE ;return nil ;
};func (_ebad stdHandlerR6 )alg11 (_bfe *StdEncryptDict ,_gdb []byte )([]byte ,error ){if _ceg :=_bb ("\u0061\u006c\u00671\u0031","\u0055",48,_bfe .U );_ceg !=nil {return nil ,_ceg ;};_cfg :=make ([]byte ,len (_gdb )+8);_ecg :=copy (_cfg ,_gdb );_ecg +=copy (_cfg [_ecg :],_bfe .U [32:40]);
_efec ,_cca :=_ebad .alg2b (_bfe .R ,_cfg ,_gdb ,nil );if _cca !=nil {return nil ,_cca ;};_efec =_efec [:32];if !_d .Equal (_efec ,_bfe .U [:32]){return nil ,nil ;};return _efec ,nil ;};func (_bd *ecbEncrypter )BlockSize ()int {return _bd ._cbd };type ecbDecrypter ecb ;
func (_fbef stdHandlerR6 )alg12 (_gdbf *StdEncryptDict ,_acg []byte )([]byte ,error ){if _bgd :=_bb ("\u0061\u006c\u00671\u0032","\u0055",48,_gdbf .U );_bgd !=nil {return nil ,_bgd ;};if _dffdb :=_bb ("\u0061\u006c\u00671\u0032","\u004f",48,_gdbf .O );
_dffdb !=nil {return nil ,_dffdb ;};_bdde :=make ([]byte ,len (_acg )+8+48);_bc :=copy (_bdde ,_acg );_bc +=copy (_bdde [_bc :],_gdbf .O [32:40]);_bc +=copy (_bdde [_bc :],_gdbf .U [0:48]);_ccae ,_ecf :=_fbef .alg2b (_gdbf .R ,_bdde ,_acg ,_gdbf .U [0:48]);
if _ecf !=nil {return nil ,_ecf ;};_ccae =_ccae [:32];if !_d .Equal (_ccae ,_gdbf .O [:32]){return nil ,nil ;};return _ccae ,nil ;};func _ef (_fc _c .Block )*ecb {return &ecb {_ec :_fc ,_cbd :_fc .BlockSize ()}};func _dd (_ce _c .Block )_c .BlockMode {return (*ecbEncrypter )(_ef (_ce ))};
func _fcb (_fbec ,_gbf ,_eaeb []byte )([]byte ,error ){var (_gbb ,_deea ,_dcf _af .Hash ;);_gbb =_b .New ();_deba :=make ([]byte ,64);_aga :=_gbb ;_aga .Write (_fbec );K :=_aga .Sum (_deba [:0]);_bfd :=make ([]byte ,64*(127+64+48));_gfbe :=func (_efd int )([]byte ,error ){_gaa :=len (_gbf )+len (K )+len (_eaeb );
_agg :=_bfd [:_gaa ];_ffac :=copy (_agg ,_gbf );_ffac +=copy (_agg [_ffac :],K [:]);_ffac +=copy (_agg [_ffac :],_eaeb );if _ffac !=_gaa {_cb .Log .Error ("E\u0052\u0052\u004f\u0052\u003a\u0020u\u006e\u0065\u0078\u0070\u0065\u0063t\u0065\u0064\u0020\u0072\u006f\u0075\u006ed\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0073\u0069\u007ae\u002e");
return nil ,_f .New ("\u0077\u0072\u006f\u006e\u0067\u0020\u0073\u0069\u007a\u0065");};K1 :=_bfd [:_gaa *64];_eg (K1 ,_gaa );_fgdf ,_dgee :=_fbf (K [0:16]);if _dgee !=nil {return nil ,_dgee ;};_fbgf :=_c .NewCBCEncrypter (_fgdf ,K [16:32]);_fbgf .CryptBlocks (K1 ,K1 );
E :=K1 ;_gce :=0;for _gfa :=0;_gfa < 16;_gfa ++{_gce +=int (E [_gfa ]%3);};var _ccde _af .Hash ;switch _gce %3{case 0:_ccde =_gbb ;case 1:if _deea ==nil {_deea =_ag .New384 ();};_ccde =_deea ;case 2:if _dcf ==nil {_dcf =_ag .New ();};_ccde =_dcf ;};_ccde .Reset ();
_ccde .Write (E );K =_ccde .Sum (_deba [:0]);return E ,nil ;};for _faff :=0;;{E ,_aada :=_gfbe (_faff );if _aada !=nil {return nil ,_aada ;};_eac :=E [len (E )-1];_faff ++;if _faff >=64&&_eac <=uint8 (_faff -32){break ;};};return K [:32],nil ;};func (_gceg stdHandlerR6 )alg8 (_dbd *StdEncryptDict ,_baa []byte ,_cacb []byte )error {if _efa :=_bb ("\u0061\u006c\u0067\u0038","\u004b\u0065\u0079",32,_baa );
_efa !=nil {return _efa ;};var _gd [16]byte ;if _ ,_afbf :=_a .ReadFull (_ae .Reader ,_gd [:]);_afbf !=nil {return _afbf ;};_cebb :=_gd [0:8];_bdd :=_gd [8:16];_gbgb :=make ([]byte ,len (_cacb )+len (_cebb ));_dfd :=copy (_gbgb ,_cacb );copy (_gbgb [_dfd :],_cebb );
_gfe ,_fgb :=_gceg .alg2b (_dbd .R ,_gbgb ,_cacb ,nil );if _fgb !=nil {return _fgb ;};U :=make ([]byte ,len (_gfe )+len (_cebb )+len (_bdd ));_dfd =copy (U ,_gfe [:32]);_dfd +=copy (U [_dfd :],_cebb );copy (U [_dfd :],_bdd );_dbd .U =U ;_dfd =len (_cacb );
copy (_gbgb [_dfd :],_bdd );_gfe ,_fgb =_gceg .alg2b (_dbd .R ,_gbgb ,_cacb ,nil );if _fgb !=nil {return _fgb ;};_dcb ,_fgb :=_fbf (_gfe [:32]);if _fgb !=nil {return _fgb ;};_cagb :=make ([]byte ,_agc .BlockSize );_fdd :=_c .NewCBCEncrypter (_dcb ,_cagb );
UE :=make ([]byte ,32);_fdd .CryptBlocks (UE ,_baa [:32]);_dbd .UE =UE ;return nil ;};var _ StdHandler =stdHandlerR4 {};func (_eda stdHandlerR6 )alg13 (_ggb *StdEncryptDict ,_agcc []byte )error {if _ege :=_bb ("\u0061\u006c\u00671\u0033","\u004b\u0065\u0079",32,_agcc );
_ege !=nil {return _ege ;};if _bddg :=_bb ("\u0061\u006c\u00671\u0033","\u0050\u0065\u0072m\u0073",16,_ggb .Perms );_bddg !=nil {return _bddg ;};_aeaf :=make ([]byte ,16);copy (_aeaf ,_ggb .Perms [:16]);_ega ,_beac :=_agc .NewCipher (_agcc [:32]);if _beac !=nil {return _beac ;
};_ccgd :=_fga (_ega );_ccgd .CryptBlocks (_aeaf ,_aeaf );if !_d .Equal (_aeaf [9:12],[]byte ("\u0061\u0064\u0062")){return _f .New ("\u0064\u0065\u0063o\u0064\u0065\u0064\u0020p\u0065\u0072\u006d\u0069\u0073\u0073\u0069o\u006e\u0073\u0020\u0061\u0072\u0065\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};_bddd :=Permissions (_fg .LittleEndian .Uint32 (_aeaf [0:4]));if _bddd !=_ggb .P {return _f .New ("\u0070\u0065r\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066\u0061il\u0065\u0064");
};var _gdbfg bool ;if _aeaf [8]=='T'{_gdbfg =true ;}else if _aeaf [8]=='F'{_gdbfg =false ;}else {return _f .New ("\u0064\u0065\u0063\u006f\u0064\u0065\u0064 \u006d\u0065\u0074a\u0064\u0061\u0074\u0061 \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u006c\u0061\u0067\u0020\u0069\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};if _gdbfg !=_ggb .EncryptMetadata {return _f .New ("\u006d\u0065t\u0061\u0064\u0061\u0074a\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e \u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066a\u0069\u006c\u0065\u0064");
};return nil ;};type stdHandlerR6 struct{};

// NewHandlerR6 creates a new standard security handler for R=5 and R=6.
func NewHandlerR6 ()StdHandler {return stdHandlerR6 {}};const _bbf ="\x28\277\116\136\x4e\x75\x8a\x41\x64\000\x4e\x56\377"+"\xfa\001\010\056\x2e\x00\xb6\xd0\x68\076\x80\x2f\014"+"\251\xfe\x64\x53\x69\172";func _eg (_deb []byte ,_eeg int ){_dc :=_eeg ;for _dc < len (_deb ){copy (_deb [_dc :],_deb [:_dc ]);
_dc *=2;};};const (EventDocOpen =AuthEvent ("\u0044o\u0063\u004f\u0070\u0065\u006e");EventEFOpen =AuthEvent ("\u0045\u0046\u004f\u0070\u0065\u006e"););func (_cbde stdHandlerR6 )alg2a (_ac *StdEncryptDict ,_bff []byte )([]byte ,Permissions ,error ){if _dgb :=_bb ("\u0061\u006c\u00672\u0061","\u004f",48,_ac .O );
_dgb !=nil {return nil ,0,_dgb ;};if _aadd :=_bb ("\u0061\u006c\u00672\u0061","\u0055",48,_ac .U );_aadd !=nil {return nil ,0,_aadd ;};if len (_bff )> 127{_bff =_bff [:127];};_cgaa ,_fea :=_cbde .alg12 (_ac ,_bff );if _fea !=nil {return nil ,0,_fea ;};
var (_cfd []byte ;_cae []byte ;_ccf []byte ;);var _bac Permissions ;if len (_cgaa )!=0{_bac =PermOwner ;_cac :=make ([]byte ,len (_bff )+8+48);_cbb :=copy (_cac ,_bff );_cbb +=copy (_cac [_cbb :],_ac .O [40:48]);copy (_cac [_cbb :],_ac .U [0:48]);_cfd =_cac ;
_cae =_ac .OE ;_ccf =_ac .U [0:48];}else {_cgaa ,_fea =_cbde .alg11 (_ac ,_bff );if _fea ==nil &&len (_cgaa )==0{_cgaa ,_fea =_cbde .alg11 (_ac ,[]byte (""));};if _fea !=nil {return nil ,0,_fea ;}else if len (_cgaa )==0{return nil ,0,nil ;};_bac =_ac .P ;
_dff :=make ([]byte ,len (_bff )+8);_cd :=copy (_dff ,_bff );copy (_dff [_cd :],_ac .U [40:48]);_cfd =_dff ;_cae =_ac .UE ;_ccf =nil ;};if _afb :=_bb ("\u0061\u006c\u00672\u0061","\u004b\u0065\u0079",32,_cae );_afb !=nil {return nil ,0,_afb ;};_cae =_cae [:32];
_eba ,_fea :=_cbde .alg2b (_ac .R ,_cfd ,_bff ,_ccf );if _fea !=nil {return nil ,0,_fea ;};_fgd ,_fea :=_agc .NewCipher (_eba [:32]);if _fea !=nil {return nil ,0,_fea ;};_gcg :=make ([]byte ,_agc .BlockSize );_ebg :=_c .NewCBCDecrypter (_fgd ,_gcg );_efge :=make ([]byte ,32);
_ebg .CryptBlocks (_efge ,_cae );if _ac .R ==5{return _efge ,_bac ,nil ;};_fea =_cbde .alg13 (_ac ,_efge );if _fea !=nil {return nil ,0,_fea ;};return _efge ,_bac ,nil ;};

// StdEncryptDict is a set of additional fields used in standard encryption dictionary.
type StdEncryptDict struct{R int ;P Permissions ;EncryptMetadata bool ;O ,U []byte ;OE ,UE []byte ;Perms []byte ;};const (PermOwner =Permissions (_g .MaxUint32 );PermPrinting =Permissions (1<<2);PermModify =Permissions (1<<3);PermExtractGraphics =Permissions (1<<4);
PermAnnotate =Permissions (1<<5);PermFillForms =Permissions (1<<8);PermDisabilityExtract =Permissions (1<<9);PermRotateInsert =Permissions (1<<10);PermFullPrintQuality =Permissions (1<<11););