//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package security ;import (_c "bytes";_aa "crypto/aes";_d "crypto/cipher";_ge "crypto/md5";_ea "crypto/rand";_g "crypto/rc4";_f "crypto/sha256";_ab "crypto/sha512";_b "encoding/binary";_fd "errors";_fc "fmt";_fb "github.com/unidoc/unipdf/v3/common";_ef "hash";_e "io";_gee "math";);

// GenerateParams generates and sets O and U parameters for the encryption dictionary.
// It expects R, P and EncryptMetadata fields to be set.
func (_cbde stdHandlerR4 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){O ,_dca :=_cbde .alg3 (d .R ,upass ,opass );if _dca !=nil {_fb .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_dca );return nil ,_dca ;};d .O =O ;_fb .Log .Trace ("\u0067\u0065\u006e\u0020\u004f\u003a\u0020\u0025\u0020\u0078",O );_edf :=_cbde .alg2 (d ,upass );U ,_dca :=_cbde .alg5 (_edf ,upass );if _dca !=nil {_fb .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_dca );return nil ,_dca ;};d .U =U ;_fb .Log .Trace ("\u0067\u0065\u006e\u0020\u0055\u003a\u0020\u0025\u0020\u0078",U );return _edf ,nil ;};

// GenerateParams is the algorithm opposite to alg2a (R>=5).
// It generates U,O,UE,OE,Perms fields using AESv3 encryption.
// There is no algorithm number assigned to this function in the spec.
// It expects R, P and EncryptMetadata fields to be set.
func (_ddce stdHandlerR6 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){_fag :=make ([]byte ,32);if _ ,_daa :=_e .ReadFull (_ea .Reader ,_fag );_daa !=nil {return nil ,_daa ;};d .U =nil ;d .O =nil ;d .UE =nil ;d .OE =nil ;d .Perms =nil ;if len (upass )> 127{upass =upass [:127];};if len (opass )> 127{opass =opass [:127];};if _cad :=_ddce .alg8 (d ,_fag ,upass );_cad !=nil {return nil ,_cad ;};if _dfa :=_ddce .alg9 (d ,_fag ,opass );_dfa !=nil {return nil ,_dfa ;};if d .R ==5{return _fag ,nil ;};if _eaf :=_ddce .alg10 (d ,_fag );_eaf !=nil {return nil ,_eaf ;};return _fag ,nil ;};func (_dge stdHandlerR6 )alg13 (_bcde *StdEncryptDict ,_dddc []byte )error {if _bbb :=_ag ("\u0061\u006c\u00671\u0033","\u004b\u0065\u0079",32,_dddc );_bbb !=nil {return _bbb ;};if _cfa :=_ag ("\u0061\u006c\u00671\u0033","\u0050\u0065\u0072m\u0073",16,_bcde .Perms );_cfa !=nil {return _cfa ;};_fdag :=make ([]byte ,16);copy (_fdag ,_bcde .Perms [:16]);_dcad ,_gdd :=_aa .NewCipher (_dddc [:32]);if _gdd !=nil {return _gdd ;};_adf :=_fbe (_dcad );_adf .CryptBlocks (_fdag ,_fdag );if !_c .Equal (_fdag [9:12],[]byte ("\u0061\u0064\u0062")){return _fd .New ("\u0064\u0065\u0063o\u0064\u0065\u0064\u0020p\u0065\u0072\u006d\u0069\u0073\u0073\u0069o\u006e\u0073\u0020\u0061\u0072\u0065\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_cfda :=Permissions (_b .LittleEndian .Uint32 (_fdag [0:4]));if _cfda !=_bcde .P {return _fd .New ("\u0070\u0065r\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066\u0061il\u0065\u0064");};_dee :=true ;if _fdag [8]=='T'{_dee =true ;}else if _fdag [8]=='F'{_dee =false ;}else {return _fd .New ("\u0064\u0065\u0063\u006f\u0064\u0065\u0064 \u006d\u0065\u0074a\u0064\u0061\u0074\u0061 \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u006c\u0061\u0067\u0020\u0069\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};if _dee !=_bcde .EncryptMetadata {return _fd .New ("\u006d\u0065t\u0061\u0064\u0061\u0074a\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e \u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066a\u0069\u006c\u0065\u0064");};return nil ;};func (_ffd stdHandlerR6 )alg2a (_fbbe *StdEncryptDict ,_fa []byte )([]byte ,Permissions ,error ){if _bcd :=_ag ("\u0061\u006c\u00672\u0061","\u004f",48,_fbbe .O );_bcd !=nil {return nil ,0,_bcd ;};if _ceg :=_ag ("\u0061\u006c\u00672\u0061","\u0055",48,_fbbe .U );_ceg !=nil {return nil ,0,_ceg ;};if len (_fa )> 127{_fa =_fa [:127];};_gdfa ,_gda :=_ffd .alg12 (_fbbe ,_fa );if _gda !=nil {return nil ,0,_gda ;};var (_bfg []byte ;_dbbf []byte ;_aee []byte ;);var _eefc Permissions ;if len (_gdfa )!=0{_eefc =PermOwner ;_ddada :=make ([]byte ,len (_fa )+8+48);_dfbb :=copy (_ddada ,_fa );_dfbb +=copy (_ddada [_dfbb :],_fbbe .O [40:48]);_dfbb +=copy (_ddada [_dfbb :],_fbbe .U [0:48]);_bfg =_ddada ;_dbbf =_fbbe .OE ;_aee =_fbbe .U [0:48];}else {_gdfa ,_gda =_ffd .alg11 (_fbbe ,_fa );if _gda ==nil &&len (_gdfa )==0{_gdfa ,_gda =_ffd .alg11 (_fbbe ,[]byte (""));};if _gda !=nil {return nil ,0,_gda ;}else if len (_gdfa )==0{return nil ,0,nil ;};_eefc =_fbbe .P ;_gdg :=make ([]byte ,len (_fa )+8);_gdea :=copy (_gdg ,_fa );_gdea +=copy (_gdg [_gdea :],_fbbe .U [40:48]);_bfg =_gdg ;_dbbf =_fbbe .UE ;_aee =nil ;};if _dbbd :=_ag ("\u0061\u006c\u00672\u0061","\u004b\u0065\u0079",32,_dbbf );_dbbd !=nil {return nil ,0,_dbbd ;};_dbbf =_dbbf [:32];_cag ,_gda :=_ffd .alg2b (_fbbe .R ,_bfg ,_fa ,_aee );if _gda !=nil {return nil ,0,_gda ;};_ccb ,_gda :=_aa .NewCipher (_cag [:32]);if _gda !=nil {return nil ,0,_gda ;};_fgc :=make ([]byte ,_aa .BlockSize );_dde :=_d .NewCBCDecrypter (_ccb ,_fgc );_cce :=make ([]byte ,32);_dde .CryptBlocks (_cce ,_dbbf );if _fbbe .R ==5{return _cce ,_eefc ,nil ;};_gda =_ffd .alg13 (_fbbe ,_cce );if _gda !=nil {return nil ,0,_gda ;};return _cce ,_eefc ,nil ;};

// Authenticate implements StdHandler interface.
func (_bbdba stdHandlerR6 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){return _bbdba .alg2a (d ,pass );};

// Authenticate implements StdHandler interface.
func (_fbg stdHandlerR4 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){_fb .Log .Trace ("\u0044\u0065b\u0075\u0067\u0067\u0069n\u0067\u0020a\u0075\u0074\u0068\u0065\u006e\u0074\u0069\u0063a\u0074\u0069\u006f\u006e\u0020\u002d\u0020\u006f\u0077\u006e\u0065\u0072 \u0070\u0061\u0073\u0073");_eff ,_egd :=_fbg .alg7 (d ,pass );if _egd !=nil {return nil ,0,_egd ;};if _eff !=nil {_fb .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _eff ,PermOwner ,nil ;};_fb .Log .Trace ("\u0044\u0065bu\u0067\u0067\u0069n\u0067\u0020\u0061\u0075the\u006eti\u0063\u0061\u0074\u0069\u006f\u006e\u0020- \u0075\u0073\u0065\u0072\u0020\u0070\u0061s\u0073");_eff ,_egd =_fbg .alg6 (d ,pass );if _egd !=nil {return nil ,0,_egd ;};if _eff !=nil {_fb .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _eff ,d .P ,nil ;};return nil ,0,nil ;};type errInvalidField struct{Func string ;Field string ;Exp int ;Got int ;};func (_abaf stdHandlerR6 )alg10 (_ade *StdEncryptDict ,_caa []byte )error {if _gag :=_ag ("\u0061\u006c\u00671\u0030","\u004b\u0065\u0079",32,_caa );_gag !=nil {return _gag ;};_eag :=uint64 (uint32 (_ade .P ))|(_gee .MaxUint32 <<32);Perms :=make ([]byte ,16);_b .LittleEndian .PutUint64 (Perms [:8],_eag );if _ade .EncryptMetadata {Perms [8]='T';}else {Perms [8]='F';};copy (Perms [9:12],"\u0061\u0064\u0062");if _ ,_dgg :=_e .ReadFull (_ea .Reader ,Perms [12:16]);_dgg !=nil {return _dgg ;};_cgc ,_abd :=_abag (_caa [:32]);if _abd !=nil {return _abd ;};_gba :=_ed (_cgc );_gba .CryptBlocks (Perms ,Perms );_ade .Perms =Perms [:16];return nil ;};

// Permissions is a bitmask of access permissions for a PDF file.
type Permissions uint32 ;func (_bg *ecbDecrypter )BlockSize ()int {return _bg ._af };func (_bbd stdHandlerR4 )alg2 (_dfb *StdEncryptDict ,_fcf []byte )[]byte {_fb .Log .Trace ("\u0061\u006c\u0067\u0032");_bab :=_bbd .paddedPass (_fcf );_gff :=_ge .New ();_gff .Write (_bab );_gff .Write (_dfb .O );var _dda [4]byte ;_b .LittleEndian .PutUint32 (_dda [:],uint32 (_dfb .P ));_gff .Write (_dda [:]);_fb .Log .Trace ("\u0067o\u0020\u0050\u003a\u0020\u0025\u0020x",_dda );_gff .Write ([]byte (_bbd .ID0 ));_fb .Log .Trace ("\u0074\u0068\u0069\u0073\u002e\u0052\u0020\u003d\u0020\u0025d\u0020\u0065\u006e\u0063\u0072\u0079\u0070t\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061\u0020\u0025\u0076",_dfb .R ,_dfb .EncryptMetadata );if (_dfb .R >=4)&&!_dfb .EncryptMetadata {_gff .Write ([]byte {0xff,0xff,0xff,0xff});};_abe :=_gff .Sum (nil );if _dfb .R >=3{_gff =_ge .New ();for _dbb :=0;_dbb < 50;_dbb ++{_gff .Reset ();_gff .Write (_abe [0:_bbd .Length /8]);_abe =_gff .Sum (nil );};};if _dfb .R >=3{return _abe [0:_bbd .Length /8];};return _abe [0:5];};func (_ac *ecbDecrypter )CryptBlocks (dst ,src []byte ){if len (src )%_ac ._af !=0{_fb .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");return ;};if len (dst )< len (src ){_fb .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0064\u0065\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");return ;};for len (src )> 0{_ac ._dd .Decrypt (dst ,src [:_ac ._af ]);src =src [_ac ._af :];dst =dst [_ac ._af :];};};func _abag (_beg []byte )(_d .Block ,error ){_baa ,_aeg :=_aa .NewCipher (_beg );if _aeg !=nil {_fb .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0063\u0072\u0065\u0061\u0074\u0065\u0020A\u0045\u0053\u0020\u0063\u0069p\u0068\u0065r\u003a\u0020\u0025\u0076",_aeg );return nil ,_aeg ;};return _baa ,nil ;};func (_ba *ecbEncrypter )CryptBlocks (dst ,src []byte ){if len (src )%_ba ._af !=0{_fb .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");return ;};if len (dst )< len (src ){_fb .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");return ;};for len (src )> 0{_ba ._dd .Encrypt (dst ,src [:_ba ._af ]);src =src [_ba ._af :];dst =dst [_ba ._af :];};};func (_ege stdHandlerR6 )alg9 (_fdd *StdEncryptDict ,_def []byte ,_gedb []byte )error {if _bfga :=_ag ("\u0061\u006c\u0067\u0039","\u004b\u0065\u0079",32,_def );_bfga !=nil {return _bfga ;};if _fae :=_ag ("\u0061\u006c\u0067\u0039","\u0055",48,_fdd .U );_fae !=nil {return _fae ;};var _edac [16]byte ;if _ ,_ad :=_e .ReadFull (_ea .Reader ,_edac [:]);_ad !=nil {return _ad ;};_fad :=_edac [0:8];_bbe :=_edac [8:16];_eege :=_fdd .U [:48];_edb :=make ([]byte ,len (_gedb )+len (_fad )+len (_eege ));_cfd :=copy (_edb ,_gedb );_cfd +=copy (_edb [_cfd :],_fad );_cfd +=copy (_edb [_cfd :],_eege );_cdg ,_bbf :=_ege .alg2b (_fdd .R ,_edb ,_gedb ,_eege );if _bbf !=nil {return _bbf ;};O :=make ([]byte ,len (_cdg )+len (_fad )+len (_bbe ));_cfd =copy (O ,_cdg [:32]);_cfd +=copy (O [_cfd :],_fad );_cfd +=copy (O [_cfd :],_bbe );_fdd .O =O ;_cfd =len (_gedb );_cfd +=copy (_edb [_cfd :],_bbe );_cdg ,_bbf =_ege .alg2b (_fdd .R ,_edb ,_gedb ,_eege );if _bbf !=nil {return _bbf ;};_cega ,_bbf :=_abag (_cdg [:32]);if _bbf !=nil {return _bbf ;};_gbd :=make ([]byte ,_aa .BlockSize );_fbgg :=_d .NewCBCEncrypter (_cega ,_gbd );OE :=make ([]byte ,32);_fbgg .CryptBlocks (OE ,_def [:32]);_fdd .OE =OE ;return nil ;};type ecb struct{_dd _d .Block ;_af int ;};func (_eef stdHandlerR4 )alg6 (_bbdb *StdEncryptDict ,_cbdd []byte )([]byte ,error ){var (_gebg []byte ;_gcd error ;);_edd :=_eef .alg2 (_bbdb ,_cbdd );if _bbdb .R ==2{_gebg ,_gcd =_eef .alg4 (_edd ,_cbdd );}else if _bbdb .R >=3{_gebg ,_gcd =_eef .alg5 (_edd ,_cbdd );}else {return nil ,_fd .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};if _gcd !=nil {return nil ,_gcd ;};_fb .Log .Trace ("\u0063\u0068\u0065\u0063k:\u0020\u0025\u0020\u0078\u0020\u003d\u003d\u0020\u0025\u0020\u0078\u0020\u003f",string (_gebg ),string (_bbdb .U ));_ffcb :=_gebg ;_eec :=_bbdb .U ;if _bbdb .R >=3{if len (_ffcb )> 16{_ffcb =_ffcb [0:16];};if len (_eec )> 16{_eec =_eec [0:16];};};if !_c .Equal (_ffcb ,_eec ){return nil ,nil ;};return _edd ,nil ;};func _bb (_bc _d .Block )*ecb {return &ecb {_dd :_bc ,_af :_bc .BlockSize ()}};func (_decc stdHandlerR4 )alg5 (_dffe []byte ,_dc []byte )([]byte ,error ){_dcc :=_ge .New ();_dcc .Write ([]byte (_dff ));_dcc .Write ([]byte (_decc .ID0 ));_geb :=_dcc .Sum (nil );_fb .Log .Trace ("\u0061\u006c\u0067\u0035");_fb .Log .Trace ("\u0065k\u0065\u0079\u003a\u0020\u0025\u0020x",_dffe );_fb .Log .Trace ("\u0049D\u003a\u0020\u0025\u0020\u0078",_decc .ID0 );if len (_geb )!=16{return nil ,_fd .New ("\u0068a\u0073\u0068\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074\u0020\u0031\u0036\u0020\u0062\u0079\u0074\u0065\u0073");};_fbb ,_eg :=_g .NewCipher (_dffe );if _eg !=nil {return nil ,_fd .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_ggc :=make ([]byte ,16);_fbb .XORKeyStream (_ggc ,_geb );_gde :=make ([]byte ,len (_dffe ));for _dcb :=0;_dcb < 19;_dcb ++{for _aba :=0;_aba < len (_dffe );_aba ++{_gde [_aba ]=_dffe [_aba ]^byte (_dcb +1);};_fbb ,_eg =_g .NewCipher (_gde );if _eg !=nil {return nil ,_fd .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_fbb .XORKeyStream (_ggc ,_ggc );_fb .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u002c\u0020\u0065\u006b\u0065\u0079:\u0020\u0025\u0020\u0078",_dcb ,_gde );_fb .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0020\u0078",_dcb ,_ggc );};_ffg :=make ([]byte ,32);for _ffc :=0;_ffc < 16;_ffc ++{_ffg [_ffc ]=_ggc [_ffc ];};_ ,_eg =_ea .Read (_ffg [16:32]);if _eg !=nil {return nil ,_fd .New ("\u0066a\u0069\u006c\u0065\u0064 \u0074\u006f\u0020\u0067\u0065n\u0020r\u0061n\u0064\u0020\u006e\u0075\u006d\u0062\u0065r");};return _ffg ,nil ;};var _ StdHandler =stdHandlerR6 {};func _bdb (_fbdc ,_ebc ,_edge []byte )([]byte ,error ){var (_cd ,_eeb ,_dbf _ef .Hash ;);_cd =_f .New ();_ddd :=make ([]byte ,64);_fgb :=_cd ;_fgb .Write (_fbdc );K :=_fgb .Sum (_ddd [:0]);_bge :=make ([]byte ,64*(127+64+48));_ebcf :=func (_agbf int )([]byte ,error ){_bbc :=len (_ebc )+len (K )+len (_edge );_fcc :=_bge [:_bbc ];_fbc :=copy (_fcc ,_ebc );_fbc +=copy (_fcc [_fbc :],K [:]);_fbc +=copy (_fcc [_fbc :],_edge );if _fbc !=_bbc {_fb .Log .Error ("E\u0052\u0052\u004f\u0052\u003a\u0020u\u006e\u0065\u0078\u0070\u0065\u0063t\u0065\u0064\u0020\u0072\u006f\u0075\u006ed\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0073\u0069\u007ae\u002e");return nil ,_fd .New ("\u0077\u0072\u006f\u006e\u0067\u0020\u0073\u0069\u007a\u0065");};K1 :=_bge [:_bbc *64];_edg (K1 ,_bbc );_gae ,_aae :=_abag (K [0:16]);if _aae !=nil {return nil ,_aae ;};_bed :=_d .NewCBCEncrypter (_gae ,K [16:32]);_bed .CryptBlocks (K1 ,K1 );E :=K1 ;_efg :=0;for _dcaa :=0;_dcaa < 16;_dcaa ++{_efg +=int (E [_dcaa ]%3);};var _bdc _ef .Hash ;switch _efg %3{case 0:_bdc =_cd ;case 1:if _eeb ==nil {_eeb =_ab .New384 ();};_bdc =_eeb ;case 2:if _dbf ==nil {_dbf =_ab .New ();};_bdc =_dbf ;};_bdc .Reset ();_bdc .Write (E );K =_bdc .Sum (_ddd [:0]);return E ,nil ;};for _dce :=0;;{E ,_ced :=_ebcf (_dce );if _ced !=nil {return nil ,_ced ;};_afa :=uint8 (E [len (E )-1]);_dce ++;if _dce >=64&&_afa <=uint8 (_dce -32){break ;};};return K [:32],nil ;};var _ StdHandler =stdHandlerR4 {};func (_ff stdHandlerR4 )alg3Key (R int ,_efc []byte )[]byte {_eb :=_ge .New ();_agb :=_ff .paddedPass (_efc );_eb .Write (_agb );if R >=3{for _ee :=0;_ee < 50;_ee ++{_fe :=_eb .Sum (nil );_eb =_ge .New ();_eb .Write (_fe );};};_ga :=_eb .Sum (nil );if R ==2{_ga =_ga [0:5];}else {_ga =_ga [0:_ff .Length /8];};return _ga ;};func (_bda stdHandlerR4 )alg7 (_ddc *StdEncryptDict ,_ec []byte )([]byte ,error ){_ae :=_bda .alg3Key (_ddc .R ,_ec );_bgb :=make ([]byte ,len (_ddc .O ));if _ddc .R ==2{_fgd ,_bde :=_g .NewCipher (_ae );if _bde !=nil {return nil ,_fd .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_fgd .XORKeyStream (_bgb ,_ddc .O );}else if _ddc .R >=3{_gge :=append ([]byte {},_ddc .O ...);for _gbe :=0;_gbe < 20;_gbe ++{_ce :=append ([]byte {},_ae ...);for _gfb :=0;_gfb < len (_ae );_gfb ++{_ce [_gfb ]^=byte (19-_gbe );};_cc ,_gdf :=_g .NewCipher (_ce );if _gdf !=nil {return nil ,_fd .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_cc .XORKeyStream (_bgb ,_gge );_gge =append ([]byte {},_bgb ...);};}else {return nil ,_fd .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};_da ,_gdb :=_bda .alg6 (_ddc ,_bgb );if _gdb !=nil {return nil ,nil ;};return _da ,nil ;};func (_ca stdHandlerR4 )alg4 (_fda []byte ,_beb []byte )([]byte ,error ){_cab ,_acf :=_g .NewCipher (_fda );if _acf !=nil {return nil ,_fd .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_ebe :=[]byte (_dff );_gb :=make ([]byte ,len (_ebe ));_cab .XORKeyStream (_gb ,_ebe );return _gb ,nil ;};

// StdHandler is an interface for standard security handlers.
type StdHandler interface{

// GenerateParams uses owner and user passwords to set encryption parameters and generate an encryption key.
// It assumes that R, P and EncryptMetadata are already set.
GenerateParams (_fbd *StdEncryptDict ,_bgf ,_df []byte )([]byte ,error );

// Authenticate uses encryption dictionary parameters and the password to calculate
// the document encryption key. It also returns permissions that should be granted to a user.
// In case of failed authentication, it returns empty key and zero permissions with no error.
Authenticate (_gf *StdEncryptDict ,_cg []byte )([]byte ,Permissions ,error );};const (EventDocOpen =AuthEvent ("\u0044o\u0063\u004f\u0070\u0065\u006e");EventEFOpen =AuthEvent ("\u0045\u0046\u004f\u0070\u0065\u006e"););type ecbDecrypter ecb ;func (_cga errInvalidField )Error ()string {return _fc .Sprintf ("\u0025s\u003a\u0020e\u0078\u0070\u0065\u0063t\u0065\u0064\u0020%\u0073\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0074o \u0062\u0065\u0020%\u0064\u0020b\u0079\u0074\u0065\u0073\u002c\u0020g\u006f\u0074 \u0025\u0064",_cga .Func ,_cga .Field ,_cga .Exp ,_cga .Got );};func _eeg (_eda []byte )([]byte ,error ){_cff :=_f .New ();_cff .Write (_eda );return _cff .Sum (nil ),nil };type ecbEncrypter ecb ;

// AuthEvent is an event type that triggers authentication.
type AuthEvent string ;func (stdHandlerR4 )paddedPass (_fg []byte )[]byte {_cgaa :=make ([]byte ,32);_gc :=copy (_cgaa ,_fg );for ;_gc < 32;_gc ++{_cgaa [_gc ]=_dff [_gc -len (_fg )];};return _cgaa ;};

// Allowed checks if a set of permissions can be granted.
func (_fca Permissions )Allowed (p2 Permissions )bool {return _fca &p2 ==p2 };

// StdEncryptDict is a set of additional fields used in standard encryption dictionary.
type StdEncryptDict struct{R int ;P Permissions ;EncryptMetadata bool ;O ,U []byte ;OE ,UE []byte ;Perms []byte ;};func _fbe (_de _d .Block )_d .BlockMode {return (*ecbDecrypter )(_bb (_de ))};type stdHandlerR6 struct{};func (_aec stdHandlerR6 )alg11 (_eefe *StdEncryptDict ,_fddf []byte )([]byte ,error ){if _efe :=_ag ("\u0061\u006c\u00671\u0031","\u0055",48,_eefe .U );_efe !=nil {return nil ,_efe ;};_cba :=make ([]byte ,len (_fddf )+8);_bede :=copy (_cba ,_fddf );_bede +=copy (_cba [_bede :],_eefe .U [32:40]);_ffge ,_effc :=_aec .alg2b (_eefe .R ,_cba ,_fddf ,nil );if _effc !=nil {return nil ,_effc ;};_ffge =_ffge [:32];if !_c .Equal (_ffge ,_eefe .U [:32]){return nil ,nil ;};return _ffge ,nil ;};func (_bac stdHandlerR6 )alg12 (_ccg *StdEncryptDict ,_eeff []byte )([]byte ,error ){if _fbdcg :=_ag ("\u0061\u006c\u00671\u0032","\u0055",48,_ccg .U );_fbdcg !=nil {return nil ,_fbdcg ;};if _baf :=_ag ("\u0061\u006c\u00671\u0032","\u004f",48,_ccg .O );_baf !=nil {return nil ,_baf ;};_gdge :=make ([]byte ,len (_eeff )+8+48);_faf :=copy (_gdge ,_eeff );_faf +=copy (_gdge [_faf :],_ccg .O [32:40]);_faf +=copy (_gdge [_faf :],_ccg .U [0:48]);_dgb ,_bfe :=_bac .alg2b (_ccg .R ,_gdge ,_eeff ,_ccg .U [0:48]);if _bfe !=nil {return nil ,_bfe ;};_dgb =_dgb [:32];if !_c .Equal (_dgb ,_ccg .O [:32]){return nil ,nil ;};return _dgb ,nil ;};

// NewHandlerR6 creates a new standard security handler for R=5 and R=6.
func NewHandlerR6 ()StdHandler {return stdHandlerR6 {}};func (_edfc stdHandlerR6 )alg2b (R int ,_eea ,_fcfa ,_fbed []byte )([]byte ,error ){if R ==5{return _eeg (_eea );};return _bdb (_eea ,_fcfa ,_fbed );};func (_gcdd stdHandlerR6 )alg8 (_fcg *StdEncryptDict ,_dg []byte ,_bgea []byte )error {if _acb :=_ag ("\u0061\u006c\u0067\u0038","\u004b\u0065\u0079",32,_dg );_acb !=nil {return _acb ;};var _dbbc [16]byte ;if _ ,_cgg :=_e .ReadFull (_ea .Reader ,_dbbc [:]);_cgg !=nil {return _cgg ;};_cfe :=_dbbc [0:8];_fccd :=_dbbc [8:16];_babd :=make ([]byte ,len (_bgea )+len (_cfe ));_decg :=copy (_babd ,_bgea );_decg +=copy (_babd [_decg :],_cfe );_gfa ,_gac :=_gcdd .alg2b (_fcg .R ,_babd ,_bgea ,nil );if _gac !=nil {return _gac ;};U :=make ([]byte ,len (_gfa )+len (_cfe )+len (_fccd ));_decg =copy (U ,_gfa [:32]);_decg +=copy (U [_decg :],_cfe );_decg +=copy (U [_decg :],_fccd );_fcg .U =U ;_decg =len (_bgea );_decg +=copy (_babd [_decg :],_fccd );_gfa ,_gac =_gcdd .alg2b (_fcg .R ,_babd ,_bgea ,nil );if _gac !=nil {return _gac ;};_fbdf ,_gac :=_abag (_gfa [:32]);if _gac !=nil {return _gac ;};_gab :=make ([]byte ,_aa .BlockSize );_fcge :=_d .NewCBCEncrypter (_fbdf ,_gab );UE :=make ([]byte ,32);_fcge .CryptBlocks (UE ,_dg [:32]);_fcg .UE =UE ;return nil ;};

// NewHandlerR4 creates a new standard security handler for R<=4.
func NewHandlerR4 (id0 string ,length int )StdHandler {return stdHandlerR4 {ID0 :id0 ,Length :length }};const _dff ="\x28\277\116\136\x4e\x75\x8a\x41\x64\000\x4e\x56\377"+"\xfa\001\010\056\x2e\x00\xb6\xd0\x68\076\x80\x2f\014"+"\251\xfe\x64\x53\x69\172";func (_db *ecbEncrypter )BlockSize ()int {return _db ._af };func _ag (_gd ,_cb string ,_cgf int ,_bad []byte )error {if len (_bad )< _cgf {return errInvalidField {Func :_gd ,Field :_cb ,Exp :_cgf ,Got :len (_bad )};};return nil ;};func _edg (_bcg []byte ,_egf int ){_dcf :=_egf ;for _dcf < len (_bcg ){copy (_bcg [_dcf :],_bcg [:_dcf ]);_dcf *=2;};};func _ed (_be _d .Block )_d .BlockMode {return (*ecbEncrypter )(_bb (_be ))};type stdHandlerR4 struct{Length int ;ID0 string ;};const (PermOwner =Permissions (_gee .MaxUint32 );PermPrinting =Permissions (1<<2);PermModify =Permissions (1<<3);PermExtractGraphics =Permissions (1<<4);PermAnnotate =Permissions (1<<5);PermFillForms =Permissions (1<<8);PermDisabilityExtract =Permissions (1<<9);PermRotateInsert =Permissions (1<<10);PermFullPrintQuality =Permissions (1<<11););func (_cf stdHandlerR4 )alg3 (R int ,_cbd ,_ddad []byte )([]byte ,error ){var _bf []byte ;if len (_ddad )> 0{_bf =_cf .alg3Key (R ,_ddad );}else {_bf =_cf .alg3Key (R ,_cbd );};_bgff ,_fge :=_g .NewCipher (_bf );if _fge !=nil {return nil ,_fd .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_agg :=_cf .paddedPass (_cbd );_dec :=make ([]byte ,len (_agg ));_bgff .XORKeyStream (_dec ,_agg );if R >=3{_bd :=make ([]byte ,len (_bf ));for _bca :=0;_bca < 19;_bca ++{for _ged :=0;_ged < len (_bf );_ged ++{_bd [_ged ]=_bf [_ged ]^byte (_bca +1);};_gaa ,_gg :=_g .NewCipher (_bd );if _gg !=nil {return nil ,_fd .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_gaa .XORKeyStream (_dec ,_dec );};};return _dec ,nil ;};