//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package security ;import (_gc "bytes";_g "crypto/aes";_f "crypto/cipher";_a "crypto/md5";_da "crypto/rand";_fc "crypto/rc4";_db "crypto/sha256";_bb "crypto/sha512";_ce "encoding/binary";_gf "errors";_bc "fmt";_fb "github.com/unidoc/unipdf/v3/common";_b "hash";
_d "io";_af "math";);func (_ggge stdHandlerR6 )alg13 (_cgd *StdEncryptDict ,_adg []byte )error {if _edcf :=_aa ("\u0061\u006c\u00671\u0033","\u004b\u0065\u0079",32,_adg );_edcf !=nil {return _edcf ;};if _bed :=_aa ("\u0061\u006c\u00671\u0033","\u0050\u0065\u0072m\u0073",16,_cgd .Perms );
_bed !=nil {return _bed ;};_gddg :=make ([]byte ,16);copy (_gddg ,_cgd .Perms [:16]);_dge ,_cab :=_g .NewCipher (_adg [:32]);if _cab !=nil {return _cab ;};_aedf :=_cg (_dge );_aedf .CryptBlocks (_gddg ,_gddg );if !_gc .Equal (_gddg [9:12],[]byte ("\u0061\u0064\u0062")){return _gf .New ("\u0064\u0065\u0063o\u0064\u0065\u0064\u0020p\u0065\u0072\u006d\u0069\u0073\u0073\u0069o\u006e\u0073\u0020\u0061\u0072\u0065\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};_gdf :=Permissions (_ce .LittleEndian .Uint32 (_gddg [0:4]));if _gdf !=_cgd .P {return _gf .New ("\u0070\u0065r\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066\u0061il\u0065\u0064");
};var _bfde bool ;if _gddg [8]=='T'{_bfde =true ;}else if _gddg [8]=='F'{_bfde =false ;}else {return _gf .New ("\u0064\u0065\u0063\u006f\u0064\u0065\u0064 \u006d\u0065\u0074a\u0064\u0061\u0074\u0061 \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u006c\u0061\u0067\u0020\u0069\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};if _bfde !=_cgd .EncryptMetadata {return _gf .New ("\u006d\u0065t\u0061\u0064\u0061\u0074a\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e \u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066a\u0069\u006c\u0065\u0064");
};return nil ;};func (_ef *ecbEncrypter )CryptBlocks (dst ,src []byte ){if len (src )%_ef ._e !=0{_fb .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_fb .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_ef ._cef .Encrypt (dst ,src [:_ef ._e ]);src =src [_ef ._e :];dst =dst [_ef ._e :];};};func (_edc stdHandlerR6 )alg10 (_eegfe *StdEncryptDict ,_acd []byte )error {if _abcf :=_aa ("\u0061\u006c\u00671\u0030","\u004b\u0065\u0079",32,_acd );
_abcf !=nil {return _abcf ;};_gdab :=uint64 (uint32 (_eegfe .P ))|(_af .MaxUint32 <<32);Perms :=make ([]byte ,16);_ce .LittleEndian .PutUint64 (Perms [:8],_gdab );if _eegfe .EncryptMetadata {Perms [8]='T';}else {Perms [8]='F';};copy (Perms [9:12],"\u0061\u0064\u0062");
if _ ,_gbee :=_d .ReadFull (_da .Reader ,Perms [12:16]);_gbee !=nil {return _gbee ;};_deg ,_bag :=_ggg (_acd [:32]);if _bag !=nil {return _bag ;};_bbac :=_df (_deg );_bbac .CryptBlocks (Perms ,Perms );_eegfe .Perms =Perms [:16];return nil ;};const _edd ="\x28\277\116\136\x4e\x75\x8a\x41\x64\000\x4e\x56\377"+"\xfa\001\010\056\x2e\x00\xb6\xd0\x68\076\x80\x2f\014"+"\251\xfe\x64\x53\x69\172";
type ecb struct{_cef _f .Block ;_e int ;};

// Authenticate implements StdHandler interface.
func (_ac stdHandlerR4 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){_fb .Log .Trace ("\u0044\u0065b\u0075\u0067\u0067\u0069n\u0067\u0020a\u0075\u0074\u0068\u0065\u006e\u0074\u0069\u0063a\u0074\u0069\u006f\u006e\u0020\u002d\u0020\u006f\u0077\u006e\u0065\u0072 \u0070\u0061\u0073\u0073");
_fee ,_adc :=_ac .alg7 (d ,pass );if _adc !=nil {return nil ,0,_adc ;};if _fee !=nil {_fb .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _fee ,PermOwner ,nil ;
};_fb .Log .Trace ("\u0044\u0065bu\u0067\u0067\u0069n\u0067\u0020\u0061\u0075the\u006eti\u0063\u0061\u0074\u0069\u006f\u006e\u0020- \u0075\u0073\u0065\u0072\u0020\u0070\u0061s\u0073");_fee ,_adc =_ac .alg6 (d ,pass );if _adc !=nil {return nil ,0,_adc ;
};if _fee !=nil {_fb .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _fee ,d .P ,nil ;};return nil ,0,nil ;};

// NewHandlerR6 creates a new standard security handler for R=5 and R=6.
func NewHandlerR6 ()StdHandler {return stdHandlerR6 {}};var _ StdHandler =stdHandlerR4 {};func _aa (_ag ,_cd string ,_ceg int ,_ge []byte )error {if len (_ge )< _ceg {return errInvalidField {Func :_ag ,Field :_cd ,Exp :_ceg ,Got :len (_ge )};};return nil ;
};

// StdHandler is an interface for standard security handlers.
type StdHandler interface{

// GenerateParams uses owner and user passwords to set encryption parameters and generate an encryption key.
// It assumes that R, P and EncryptMetadata are already set.
GenerateParams (_gg *StdEncryptDict ,_gca ,_fbf []byte )([]byte ,error );

// Authenticate uses encryption dictionary parameters and the password to calculate
// the document encryption key. It also returns permissions that should be granted to a user.
// In case of failed authentication, it returns empty key and zero permissions with no error.
Authenticate (_fbb *StdEncryptDict ,_daa []byte )([]byte ,Permissions ,error );};func _df (_cb _f .Block )_f .BlockMode {return (*ecbEncrypter )(_gb (_cb ))};func (_eee stdHandlerR4 )alg4 (_dff []byte ,_gcg []byte )([]byte ,error ){_geb ,_fdd :=_fc .NewCipher (_dff );
if _fdd !=nil {return nil ,_gf .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_ced :=[]byte (_edd );_cde :=make ([]byte ,len (_ced ));_geb .XORKeyStream (_cde ,_ced );return _cde ,nil ;};func (stdHandlerR4 )paddedPass (_ga []byte )[]byte {_ff :=make ([]byte ,32);
_ba :=copy (_ff ,_ga );for ;_ba < 32;_ba ++{_ff [_ba ]=_edd [_ba -len (_ga )];};return _ff ;};type ecbEncrypter ecb ;var _ StdHandler =stdHandlerR6 {};func _cg (_bg _f .Block )_f .BlockMode {return (*ecbDecrypter )(_gb (_bg ))};func (_eea stdHandlerR4 )alg3 (R int ,_bcd ,_cf []byte )([]byte ,error ){var _dce []byte ;
if len (_cf )> 0{_dce =_eea .alg3Key (R ,_cf );}else {_dce =_eea .alg3Key (R ,_bcd );};_ecd ,_dceb :=_fc .NewCipher (_dce );if _dceb !=nil {return nil ,_gf .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_fea :=_eea .paddedPass (_bcd );
_fdf :=make ([]byte ,len (_fea ));_ecd .XORKeyStream (_fdf ,_fea );if R >=3{_bab :=make ([]byte ,len (_dce ));for _edg :=0;_edg < 19;_edg ++{for _ab :=0;_ab < len (_dce );_ab ++{_bab [_ab ]=_dce [_ab ]^byte (_edg +1);};_eed ,_dfb :=_fc .NewCipher (_bab );
if _dfb !=nil {return nil ,_gf .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_eed .XORKeyStream (_fdf ,_fdf );};};return _fdf ,nil ;};func (_bfe stdHandlerR6 )alg2b (R int ,_dgd ,_ebg ,_egg []byte )([]byte ,error ){if R ==5{return _ebf (_dgd );
};return _ffec (_dgd ,_ebg ,_egg );};func (_ae stdHandlerR4 )alg2 (_ec *StdEncryptDict ,_ee []byte )[]byte {_fb .Log .Trace ("\u0061\u006c\u0067\u0032");_aff :=_ae .paddedPass (_ee );_bcb :=_a .New ();_bcb .Write (_aff );_bcb .Write (_ec .O );var _fd [4]byte ;
_ce .LittleEndian .PutUint32 (_fd [:],uint32 (_ec .P ));_bcb .Write (_fd [:]);_fb .Log .Trace ("\u0067o\u0020\u0050\u003a\u0020\u0025\u0020x",_fd );_bcb .Write ([]byte (_ae .ID0 ));_fb .Log .Trace ("\u0074\u0068\u0069\u0073\u002e\u0052\u0020\u003d\u0020\u0025d\u0020\u0065\u006e\u0063\u0072\u0079\u0070t\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061\u0020\u0025\u0076",_ec .R ,_ec .EncryptMetadata );
if (_ec .R >=4)&&!_ec .EncryptMetadata {_bcb .Write ([]byte {0xff,0xff,0xff,0xff});};_eddc :=_bcb .Sum (nil );if _ec .R >=3{_bcb =_a .New ();for _gd :=0;_gd < 50;_gd ++{_bcb .Reset ();_bcb .Write (_eddc [0:_ae .Length /8]);_eddc =_bcb .Sum (nil );};};if _ec .R >=3{return _eddc [0:_ae .Length /8];
};return _eddc [0:5];};func _ggg (_cbc []byte )(_f .Block ,error ){_egd ,_bbg :=_g .NewCipher (_cbc );if _bbg !=nil {_fb .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0063\u0072\u0065\u0061\u0074\u0065\u0020A\u0045\u0053\u0020\u0063\u0069p\u0068\u0065r\u003a\u0020\u0025\u0076",_bbg );
return nil ,_bbg ;};return _egd ,nil ;};type ecbDecrypter ecb ;func _ecc (_bga []byte ,_gdd int ){_dfg :=_gdd ;for _dfg < len (_bga ){copy (_bga [_dfg :],_bga [:_dfg ]);_dfg *=2;};};

// GenerateParams generates and sets O and U parameters for the encryption dictionary.
// It expects R, P and EncryptMetadata fields to be set.
func (_dba stdHandlerR4 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){O ,_bbf :=_dba .alg3 (d .R ,upass ,opass );if _bbf !=nil {_fb .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_bbf );
return nil ,_bbf ;};d .O =O ;_fb .Log .Trace ("\u0067\u0065\u006e\u0020\u004f\u003a\u0020\u0025\u0020\u0078",O );_eddf :=_dba .alg2 (d ,upass );U ,_bbf :=_dba .alg5 (_eddf ,upass );if _bbf !=nil {_fb .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_bbf );
return nil ,_bbf ;};d .U =U ;_fb .Log .Trace ("\u0067\u0065\u006e\u0020\u0055\u003a\u0020\u0025\u0020\u0078",U );return _eddf ,nil ;};

// StdEncryptDict is a set of additional fields used in standard encryption dictionary.
type StdEncryptDict struct{R int ;P Permissions ;EncryptMetadata bool ;O ,U []byte ;OE ,UE []byte ;Perms []byte ;};

// Allowed checks if a set of permissions can be granted.
func (_fe Permissions )Allowed (p2 Permissions )bool {return _fe &p2 ==p2 };type stdHandlerR6 struct{};func (_fgdg stdHandlerR4 )alg7 (_dg *StdEncryptDict ,_agd []byte )([]byte ,error ){_aac :=_fgdg .alg3Key (_dg .R ,_agd );_dcb :=make ([]byte ,len (_dg .O ));
if _dg .R ==2{_eedf ,_ggc :=_fc .NewCipher (_aac );if _ggc !=nil {return nil ,_gf .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_eedf .XORKeyStream (_dcb ,_dg .O );}else if _dg .R >=3{_gbb :=append ([]byte {},_dg .O ...);
for _gae :=0;_gae < 20;_gae ++{_baf :=append ([]byte {},_aac ...);for _dfc :=0;_dfc < len (_aac );_dfc ++{_baf [_dfc ]^=byte (19-_gae );};_cgf ,_gaa :=_fc .NewCipher (_baf );if _gaa !=nil {return nil ,_gf .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");
};_cgf .XORKeyStream (_dcb ,_gbb );_gbb =append ([]byte {},_dcb ...);};}else {return nil ,_gf .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};_fba ,_bba :=_fgdg .alg6 (_dg ,_dcb );if _bba !=nil {return nil ,nil ;};return _fba ,nil ;};const (EventDocOpen =AuthEvent ("\u0044o\u0063\u004f\u0070\u0065\u006e");
EventEFOpen =AuthEvent ("\u0045\u0046\u004f\u0070\u0065\u006e"););func (_bgg errInvalidField )Error ()string {return _bc .Sprintf ("\u0025s\u003a\u0020e\u0078\u0070\u0065\u0063t\u0065\u0064\u0020%\u0073\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0074o \u0062\u0065\u0020%\u0064\u0020b\u0079\u0074\u0065\u0073\u002c\u0020g\u006f\u0074 \u0025\u0064",_bgg .Func ,_bgg .Field ,_bgg .Exp ,_bgg .Got );
};func (_daf *ecbEncrypter )BlockSize ()int {return _daf ._e };func (_cee stdHandlerR6 )alg11 (_gad *StdEncryptDict ,_dgf []byte )([]byte ,error ){if _eceb :=_aa ("\u0061\u006c\u00671\u0031","\u0055",48,_gad .U );_eceb !=nil {return nil ,_eceb ;};_aab :=make ([]byte ,len (_dgf )+8);
_efd :=copy (_aab ,_dgf );_efd +=copy (_aab [_efd :],_gad .U [32:40]);_aed ,_fgc :=_cee .alg2b (_gad .R ,_aab ,_dgf ,nil );if _fgc !=nil {return nil ,_fgc ;};_aed =_aed [:32];if !_gc .Equal (_aed ,_gad .U [:32]){return nil ,nil ;};return _aed ,nil ;};func (_ebe stdHandlerR6 )alg9 (_cdd *StdEncryptDict ,_gcgc []byte ,_bdc []byte )error {if _aec :=_aa ("\u0061\u006c\u0067\u0039","\u004b\u0065\u0079",32,_gcgc );
_aec !=nil {return _aec ;};if _fcca :=_aa ("\u0061\u006c\u0067\u0039","\u0055",48,_cdd .U );_fcca !=nil {return _fcca ;};var _bfd [16]byte ;if _ ,_egb :=_d .ReadFull (_da .Reader ,_bfd [:]);_egb !=nil {return _egb ;};_ded :=_bfd [0:8];_cbgf :=_bfd [8:16];
_aee :=_cdd .U [:48];_gda :=make ([]byte ,len (_bdc )+len (_ded )+len (_aee ));_fge :=copy (_gda ,_bdc );_fge +=copy (_gda [_fge :],_ded );_fge +=copy (_gda [_fge :],_aee );_bgf ,_ega :=_ebe .alg2b (_cdd .R ,_gda ,_bdc ,_aee );if _ega !=nil {return _ega ;
};O :=make ([]byte ,len (_bgf )+len (_ded )+len (_cbgf ));_fge =copy (O ,_bgf [:32]);_fge +=copy (O [_fge :],_ded );_fge +=copy (O [_fge :],_cbgf );_cdd .O =O ;_fge =len (_bdc );_fge +=copy (_gda [_fge :],_cbgf );_bgf ,_ega =_ebe .alg2b (_cdd .R ,_gda ,_bdc ,_aee );
if _ega !=nil {return _ega ;};_faec ,_ega :=_ggg (_bgf [:32]);if _ega !=nil {return _ega ;};_edbf :=make ([]byte ,_g .BlockSize );_ca :=_f .NewCBCEncrypter (_faec ,_edbf );OE :=make ([]byte ,32);_ca .CryptBlocks (OE ,_gcgc [:32]);_cdd .OE =OE ;return nil ;
};type errInvalidField struct{Func string ;Field string ;Exp int ;Got int ;};func (_agb stdHandlerR6 )alg8 (_fddf *StdEncryptDict ,_eeg []byte ,_dac []byte )error {if _ggca :=_aa ("\u0061\u006c\u0067\u0038","\u004b\u0065\u0079",32,_eeg );_ggca !=nil {return _ggca ;
};var _eac [16]byte ;if _ ,_efe :=_d .ReadFull (_da .Reader ,_eac [:]);_efe !=nil {return _efe ;};_bfc :=_eac [0:8];_ggae :=_eac [8:16];_cc :=make ([]byte ,len (_dac )+len (_bfc ));_eaf :=copy (_cc ,_dac );copy (_cc [_eaf :],_bfc );_fca ,_cbg :=_agb .alg2b (_fddf .R ,_cc ,_dac ,nil );
if _cbg !=nil {return _cbg ;};U :=make ([]byte ,len (_fca )+len (_bfc )+len (_ggae ));_eaf =copy (U ,_fca [:32]);_eaf +=copy (U [_eaf :],_bfc );copy (U [_eaf :],_ggae );_fddf .U =U ;_eaf =len (_dac );copy (_cc [_eaf :],_ggae );_fca ,_cbg =_agb .alg2b (_fddf .R ,_cc ,_dac ,nil );
if _cbg !=nil {return _cbg ;};_eegf ,_cbg :=_ggg (_fca [:32]);if _cbg !=nil {return _cbg ;};_ccf :=make ([]byte ,_g .BlockSize );_ecf :=_f .NewCBCEncrypter (_eegf ,_ccf );UE :=make ([]byte ,32);_ecf .CryptBlocks (UE ,_eeg [:32]);_fddf .UE =UE ;return nil ;
};func _ffec (_def ,_ffg ,_bce []byte )([]byte ,error ){var (_bbe ,_gbe ,_fdc _b .Hash ;);_bbe =_db .New ();_baa :=make ([]byte ,64);_ged :=_bbe ;_ged .Write (_def );K :=_ged .Sum (_baa [:0]);_ggbc :=make ([]byte ,64*(127+64+48));_efg :=func (_gebb int )([]byte ,error ){_gdg :=len (_ffg )+len (K )+len (_bce );
_cfc :=_ggbc [:_gdg ];_bgef :=copy (_cfc ,_ffg );_bgef +=copy (_cfc [_bgef :],K [:]);_bgef +=copy (_cfc [_bgef :],_bce );if _bgef !=_gdg {_fb .Log .Error ("E\u0052\u0052\u004f\u0052\u003a\u0020u\u006e\u0065\u0078\u0070\u0065\u0063t\u0065\u0064\u0020\u0072\u006f\u0075\u006ed\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0073\u0069\u007ae\u002e");
return nil ,_gf .New ("\u0077\u0072\u006f\u006e\u0067\u0020\u0073\u0069\u007a\u0065");};K1 :=_ggbc [:_gdg *64];_ecc (K1 ,_gdg );_gebf ,_fdba :=_ggg (K [0:16]);if _fdba !=nil {return nil ,_fdba ;};_bfb :=_f .NewCBCEncrypter (_gebf ,K [16:32]);_bfb .CryptBlocks (K1 ,K1 );
E :=K1 ;_cfb :=0;for _ege :=0;_ege < 16;_ege ++{_cfb +=int (E [_ege ]%3);};var _fae _b .Hash ;switch _cfb %3{case 0:_fae =_bbe ;case 1:if _gbe ==nil {_gbe =_bb .New384 ();};_fae =_gbe ;case 2:if _fdc ==nil {_fdc =_bb .New ();};_fae =_fdc ;};_fae .Reset ();
_fae .Write (E );K =_fae .Sum (_baa [:0]);return E ,nil ;};for _abab :=0;;{E ,_bcdb :=_efg (_abab );if _bcdb !=nil {return nil ,_bcdb ;};_gab :=E [len (E )-1];_abab ++;if _abab >=64&&_gab <=uint8 (_abab -32){break ;};};return K [:32],nil ;};func (_gcf stdHandlerR4 )alg5 (_dca []byte ,_ece []byte )([]byte ,error ){_dfa :=_a .New ();
_dfa .Write ([]byte (_edd ));_dfa .Write ([]byte (_gcf .ID0 ));_gga :=_dfa .Sum (nil );_fb .Log .Trace ("\u0061\u006c\u0067\u0035");_fb .Log .Trace ("\u0065k\u0065\u0079\u003a\u0020\u0025\u0020x",_dca );_fb .Log .Trace ("\u0049D\u003a\u0020\u0025\u0020\u0078",_gcf .ID0 );
if len (_gga )!=16{return nil ,_gf .New ("\u0068a\u0073\u0068\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074\u0020\u0031\u0036\u0020\u0062\u0079\u0074\u0065\u0073");};_de ,_fef :=_fc .NewCipher (_dca );if _fef !=nil {return nil ,_gf .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_deb :=make ([]byte ,16);_de .XORKeyStream (_deb ,_gga );_fg :=make ([]byte ,len (_dca ));for _abc :=0;_abc < 19;_abc ++{for _bge :=0;_bge < len (_dca );_bge ++{_fg [_bge ]=_dca [_bge ]^byte (_abc +1);};_de ,_fef =_fc .NewCipher (_fg );if _fef !=nil {return nil ,_gf .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_de .XORKeyStream (_deb ,_deb );_fb .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u002c\u0020\u0065\u006b\u0065\u0079:\u0020\u0025\u0020\u0078",_abc ,_fg );_fb .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0020\u0078",_abc ,_deb );
};_cefg :=make ([]byte ,32);for _fgd :=0;_fgd < 16;_fgd ++{_cefg [_fgd ]=_deb [_fgd ];};_ ,_fef =_da .Read (_cefg [16:32]);if _fef !=nil {return nil ,_gf .New ("\u0066a\u0069\u006c\u0065\u0064 \u0074\u006f\u0020\u0067\u0065n\u0020r\u0061n\u0064\u0020\u006e\u0075\u006d\u0062\u0065r");
};return _cefg ,nil ;};func (_ffbb stdHandlerR6 )alg12 (_caa *StdEncryptDict ,_eag []byte )([]byte ,error ){if _affg :=_aa ("\u0061\u006c\u00671\u0032","\u0055",48,_caa .U );_affg !=nil {return nil ,_affg ;};if _dgc :=_aa ("\u0061\u006c\u00671\u0032","\u004f",48,_caa .O );
_dgc !=nil {return nil ,_dgc ;};_ggac :=make ([]byte ,len (_eag )+8+48);_dcee :=copy (_ggac ,_eag );_dcee +=copy (_ggac [_dcee :],_caa .O [32:40]);_dcee +=copy (_ggac [_dcee :],_caa .U [0:48]);_gge ,_cegc :=_ffbb .alg2b (_caa .R ,_ggac ,_eag ,_caa .U [0:48]);
if _cegc !=nil {return nil ,_cegc ;};_gge =_gge [:32];if !_gc .Equal (_gge ,_caa .O [:32]){return nil ,nil ;};return _gge ,nil ;};func (_ad stdHandlerR4 )alg6 (_edb *StdEncryptDict ,_aba []byte )([]byte ,error ){var (_ffe []byte ;_ggb error ;);_fa :=_ad .alg2 (_edb ,_aba );
if _edb .R ==2{_ffe ,_ggb =_ad .alg4 (_fa ,_aba );}else if _edb .R >=3{_ffe ,_ggb =_ad .alg5 (_fa ,_aba );}else {return nil ,_gf .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};if _ggb !=nil {return nil ,_ggb ;};_fb .Log .Trace ("\u0063\u0068\u0065\u0063k:\u0020\u0025\u0020\u0078\u0020\u003d\u003d\u0020\u0025\u0020\u0078\u0020\u003f",string (_ffe ),string (_edb .U ));
_ea :=_ffe ;_bgd :=_edb .U ;if _edb .R >=3{if len (_ea )> 16{_ea =_ea [0:16];};if len (_bgd )> 16{_bgd =_bgd [0:16];};};if !_gc .Equal (_ea ,_bgd ){return nil ,nil ;};return _fa ,nil ;};func (_ffb stdHandlerR6 )alg2a (_ecdg *StdEncryptDict ,_aea []byte )([]byte ,Permissions ,error ){if _faa :=_aa ("\u0061\u006c\u00672\u0061","\u004f",48,_ecdg .O );
_faa !=nil {return nil ,0,_faa ;};if _dee :=_aa ("\u0061\u006c\u00672\u0061","\u0055",48,_ecdg .U );_dee !=nil {return nil ,0,_dee ;};if len (_aea )> 127{_aea =_aea [:127];};_bcf ,_fcc :=_ffb .alg12 (_ecdg ,_aea );if _fcc !=nil {return nil ,0,_fcc ;};var (_ddg []byte ;
_cdb []byte ;_eb []byte ;);var _fdb Permissions ;if len (_bcf )!=0{_fdb =PermOwner ;_cba :=make ([]byte ,len (_aea )+8+48);_eeag :=copy (_cba ,_aea );_eeag +=copy (_cba [_eeag :],_ecdg .O [40:48]);copy (_cba [_eeag :],_ecdg .U [0:48]);_ddg =_cba ;_cdb =_ecdg .OE ;
_eb =_ecdg .U [0:48];}else {_bcf ,_fcc =_ffb .alg11 (_ecdg ,_aea );if _fcc ==nil &&len (_bcf )==0{_bcf ,_fcc =_ffb .alg11 (_ecdg ,[]byte (""));};if _fcc !=nil {return nil ,0,_fcc ;}else if len (_bcf )==0{return nil ,0,nil ;};_fdb =_ecdg .P ;_gbbg :=make ([]byte ,len (_aea )+8);
_ecdf :=copy (_gbbg ,_aea );copy (_gbbg [_ecdf :],_ecdg .U [40:48]);_ddg =_gbbg ;_cdb =_ecdg .UE ;_eb =nil ;};if _bgee :=_aa ("\u0061\u006c\u00672\u0061","\u004b\u0065\u0079",32,_cdb );_bgee !=nil {return nil ,0,_bgee ;};_cdb =_cdb [:32];_dfbd ,_fcc :=_ffb .alg2b (_ecdg .R ,_ddg ,_aea ,_eb );
if _fcc !=nil {return nil ,0,_fcc ;};_bgc ,_fcc :=_g .NewCipher (_dfbd [:32]);if _fcc !=nil {return nil ,0,_fcc ;};_acb :=make ([]byte ,_g .BlockSize );_bd :=_f .NewCBCDecrypter (_bgc ,_acb );_bfg :=make ([]byte ,32);_bd .CryptBlocks (_bfg ,_cdb );if _ecdg .R ==5{return _bfg ,_fdb ,nil ;
};_fcc =_ffb .alg13 (_ecdg ,_bfg );if _fcc !=nil {return nil ,0,_fcc ;};return _bfg ,_fdb ,nil ;};

// Permissions is a bitmask of access permissions for a PDF file.
type Permissions uint32 ;func _gb (_ed _f .Block )*ecb {return &ecb {_cef :_ed ,_e :_ed .BlockSize ()}};

// NewHandlerR4 creates a new standard security handler for R<=4.
func NewHandlerR4 (id0 string ,length int )StdHandler {return stdHandlerR4 {ID0 :id0 ,Length :length }};const (PermOwner =Permissions (_af .MaxUint32 );PermPrinting =Permissions (1<<2);PermModify =Permissions (1<<3);PermExtractGraphics =Permissions (1<<4);
PermAnnotate =Permissions (1<<5);PermFillForms =Permissions (1<<8);PermDisabilityExtract =Permissions (1<<9);PermRotateInsert =Permissions (1<<10);PermFullPrintQuality =Permissions (1<<11););

// GenerateParams is the algorithm opposite to alg2a (R>=5).
// It generates U,O,UE,OE,Perms fields using AESv3 encryption.
// There is no algorithm number assigned to this function in the spec.
// It expects R, P and EncryptMetadata fields to be set.
func (_cfe stdHandlerR6 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){_gedg :=make ([]byte ,32);if _ ,_aga :=_d .ReadFull (_da .Reader ,_gedg );_aga !=nil {return nil ,_aga ;};d .U =nil ;d .O =nil ;d .UE =nil ;d .OE =nil ;d .Perms =nil ;
if len (upass )> 127{upass =upass [:127];};if len (opass )> 127{opass =opass [:127];};if _eff :=_cfe .alg8 (d ,_gedg ,upass );_eff !=nil {return nil ,_eff ;};if _ccd :=_cfe .alg9 (d ,_gedg ,opass );_ccd !=nil {return nil ,_ccd ;};if d .R ==5{return _gedg ,nil ;
};if _cac :=_cfe .alg10 (d ,_gedg );_cac !=nil {return nil ,_cac ;};return _gedg ,nil ;};func (_dc *ecbDecrypter )CryptBlocks (dst ,src []byte ){if len (src )%_dc ._e !=0{_fb .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_fb .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0064\u0065\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_dc ._cef .Decrypt (dst ,src [:_dc ._e ]);src =src [_dc ._e :];dst =dst [_dc ._e :];};};func (_eg *ecbDecrypter )BlockSize ()int {return _eg ._e };

// Authenticate implements StdHandler interface.
func (_dcd stdHandlerR6 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){return _dcd .alg2a (d ,pass );};func _ebf (_bda []byte )([]byte ,error ){_fec :=_db .New ();_fec .Write (_bda );return _fec .Sum (nil ),nil ;};

// AuthEvent is an event type that triggers authentication.
type AuthEvent string ;type stdHandlerR4 struct{Length int ;ID0 string ;};func (_bbc stdHandlerR4 )alg3Key (R int ,_gba []byte )[]byte {_be :=_a .New ();_bf :=_bbc .paddedPass (_gba );_be .Write (_bf );if R >=3{for _dd :=0;_dd < 50;_dd ++{_cbd :=_be .Sum (nil );
_be =_a .New ();_be .Write (_cbd );};};_gfb :=_be .Sum (nil );if R ==2{_gfb =_gfb [0:5];}else {_gfb =_gfb [0:_bbc .Length /8];};return _gfb ;};