//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package security ;import (_ga "bytes";_de "crypto/aes";_g "crypto/cipher";_gg "crypto/md5";_cf "crypto/rand";_c "crypto/rc4";_af "crypto/sha256";_a "crypto/sha512";_b "encoding/binary";_ec "errors";_ba "fmt";_fb "github.com/unidoc/unipdf/v3/common";_d "hash";
_f "io";_ab "math";);func (_gde stdHandlerR4 )alg6 (_agc *StdEncryptDict ,_gdae []byte )([]byte ,error ){var (_db []byte ;_dba error ;);_baeg :=_gde .alg2 (_agc ,_gdae );if _agc .R ==2{_db ,_dba =_gde .alg4 (_baeg ,_gdae );}else if _agc .R >=3{_db ,_dba =_gde .alg5 (_baeg ,_gdae );
}else {return nil ,_ec .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};if _dba !=nil {return nil ,_dba ;};_fb .Log .Trace ("\u0063\u0068\u0065\u0063k:\u0020\u0025\u0020\u0078\u0020\u003d\u003d\u0020\u0025\u0020\u0078\u0020\u003f",string (_db ),string (_agc .U ));
_gabg :=_db ;_cdc :=_agc .U ;if _agc .R >=3{if len (_gabg )> 16{_gabg =_gabg [0:16];};if len (_cdc )> 16{_cdc =_cdc [0:16];};};if !_ga .Equal (_gabg ,_cdc ){return nil ,nil ;};return _baeg ,nil ;};func (_caf stdHandlerR6 )alg13 (_dgg *StdEncryptDict ,_fcg []byte )error {if _fca :=_dg ("\u0061\u006c\u00671\u0033","\u004b\u0065\u0079",32,_fcg );
_fca !=nil {return _fca ;};if _eeg :=_dg ("\u0061\u006c\u00671\u0033","\u0050\u0065\u0072m\u0073",16,_dgg .Perms );_eeg !=nil {return _eeg ;};_gea :=make ([]byte ,16);copy (_gea ,_dgg .Perms [:16]);_ffdd ,_eab :=_de .NewCipher (_fcg [:32]);if _eab !=nil {return _eab ;
};_ffda :=_gge (_ffdd );_ffda .CryptBlocks (_gea ,_gea );if !_ga .Equal (_gea [9:12],[]byte ("\u0061\u0064\u0062")){return _ec .New ("\u0064\u0065\u0063o\u0064\u0065\u0064\u0020p\u0065\u0072\u006d\u0069\u0073\u0073\u0069o\u006e\u0073\u0020\u0061\u0072\u0065\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};_edea :=Permissions (_b .LittleEndian .Uint32 (_gea [0:4]));if _edea !=_dgg .P {return _ec .New ("\u0070\u0065r\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066\u0061il\u0065\u0064");
};var _aee bool ;if _gea [8]=='T'{_aee =true ;}else if _gea [8]=='F'{_aee =false ;}else {return _ec .New ("\u0064\u0065\u0063\u006f\u0064\u0065\u0064 \u006d\u0065\u0074a\u0064\u0061\u0074\u0061 \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u006c\u0061\u0067\u0020\u0069\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};if _aee !=_dgg .EncryptMetadata {return _ec .New ("\u006d\u0065t\u0061\u0064\u0061\u0074a\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e \u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066a\u0069\u006c\u0065\u0064");
};return nil ;};func (_afd errInvalidField )Error ()string {return _ba .Sprintf ("\u0025s\u003a\u0020e\u0078\u0070\u0065\u0063t\u0065\u0064\u0020%\u0073\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0074o \u0062\u0065\u0020%\u0064\u0020b\u0079\u0074\u0065\u0073\u002c\u0020g\u006f\u0074 \u0025\u0064",_afd .Func ,_afd .Field ,_afd .Exp ,_afd .Got );
};

// StdEncryptDict is a set of additional fields used in standard encryption dictionary.
type StdEncryptDict struct{R int ;P Permissions ;EncryptMetadata bool ;O ,U []byte ;OE ,UE []byte ;Perms []byte ;};func (_geba stdHandlerR6 )alg10 (_ggec *StdEncryptDict ,_gcb []byte )error {if _eed :=_dg ("\u0061\u006c\u00671\u0030","\u004b\u0065\u0079",32,_gcb );
_eed !=nil {return _eed ;};_beb :=uint64 (uint32 (_ggec .P ))|(_ab .MaxUint32 <<32);Perms :=make ([]byte ,16);_b .LittleEndian .PutUint64 (Perms [:8],_beb );if _ggec .EncryptMetadata {Perms [8]='T';}else {Perms [8]='F';};copy (Perms [9:12],"\u0061\u0064\u0062");
if _ ,_dbc :=_f .ReadFull (_cf .Reader ,Perms [12:16]);_dbc !=nil {return _dbc ;};_deg ,_dfbb :=_bgba (_gcb [:32]);if _dfbb !=nil {return _dfbb ;};_gaed :=_ee (_deg );_gaed .CryptBlocks (Perms ,Perms );_ggec .Perms =Perms [:16];return nil ;};func (_da stdHandlerR6 )alg2a (_cfa *StdEncryptDict ,_dab []byte )([]byte ,Permissions ,error ){if _bce :=_dg ("\u0061\u006c\u00672\u0061","\u004f",48,_cfa .O );
_bce !=nil {return nil ,0,_bce ;};if _ac :=_dg ("\u0061\u006c\u00672\u0061","\u0055",48,_cfa .U );_ac !=nil {return nil ,0,_ac ;};if len (_dab )> 127{_dab =_dab [:127];};_dge ,_geg :=_da .alg12 (_cfa ,_dab );if _geg !=nil {return nil ,0,_geg ;};var (_gfb []byte ;
_baf []byte ;_eafg []byte ;);var _acg Permissions ;if len (_dge )!=0{_acg =PermOwner ;_eg :=make ([]byte ,len (_dab )+8+48);_dbd :=copy (_eg ,_dab );_dbd +=copy (_eg [_dbd :],_cfa .O [40:48]);copy (_eg [_dbd :],_cfa .U [0:48]);_gfb =_eg ;_baf =_cfa .OE ;
_eafg =_cfa .U [0:48];}else {_dge ,_geg =_da .alg11 (_cfa ,_dab );if _geg ==nil &&len (_dge )==0{_dge ,_geg =_da .alg11 (_cfa ,[]byte (""));};if _geg !=nil {return nil ,0,_geg ;}else if len (_dge )==0{return nil ,0,nil ;};_acg =_cfa .P ;_cfe :=make ([]byte ,len (_dab )+8);
_cdca :=copy (_cfe ,_dab );copy (_cfe [_cdca :],_cfa .U [40:48]);_gfb =_cfe ;_baf =_cfa .UE ;_eafg =nil ;};if _bcg :=_dg ("\u0061\u006c\u00672\u0061","\u004b\u0065\u0079",32,_baf );_bcg !=nil {return nil ,0,_bcg ;};_baf =_baf [:32];_fc ,_geg :=_da .alg2b (_cfa .R ,_gfb ,_dab ,_eafg );
if _geg !=nil {return nil ,0,_geg ;};_fgc ,_geg :=_de .NewCipher (_fc [:32]);if _geg !=nil {return nil ,0,_geg ;};_ebf :=make ([]byte ,_de .BlockSize );_ceg :=_g .NewCBCDecrypter (_fgc ,_ebf );_fad :=make ([]byte ,32);_ceg .CryptBlocks (_fad ,_baf );if _cfa .R ==5{return _fad ,_acg ,nil ;
};_geg =_da .alg13 (_cfa ,_fad );if _geg !=nil {return nil ,0,_geg ;};return _fad ,_acg ,nil ;};type stdHandlerR4 struct{Length int ;ID0 string ;};func _dg (_bb ,_afg string ,_bgd int ,_df []byte )error {if len (_df )< _bgd {return errInvalidField {Func :_bb ,Field :_afg ,Exp :_bgd ,Got :len (_df )};
};return nil ;};func _bg (_dd _g .Block )*ecb {return &ecb {_ea :_dd ,_be :_dd .BlockSize ()}};func (_bae *ecbEncrypter )CryptBlocks (dst ,src []byte ){if len (src )%_bae ._be !=0{_fb .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_fb .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_bae ._ea .Encrypt (dst ,src [:_bae ._be ]);src =src [_bae ._be :];dst =dst [_bae ._be :];};};func (_eaa stdHandlerR4 )alg4 (_fg []byte ,_bf []byte )([]byte ,error ){_aab ,_cfdf :=_c .NewCipher (_fg );if _cfdf !=nil {return nil ,_ec .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_bgb :=[]byte (_dc );_dffb :=make ([]byte ,len (_bgb ));_aab .XORKeyStream (_dffb ,_bgb );return _dffb ,nil ;};type ecbDecrypter ecb ;type errInvalidField struct{Func string ;Field string ;Exp int ;Got int ;};

// Authenticate implements StdHandler interface.
func (_cdgd stdHandlerR6 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){return _cdgd .alg2a (d ,pass );};

// Allowed checks if a set of permissions can be granted.
func (_ecb Permissions )Allowed (p2 Permissions )bool {return _ecb &p2 ==p2 };func (_eaf stdHandlerR4 )alg3Key (R int ,_gd []byte )[]byte {_gda :=_gg .New ();_dfb :=_eaf .paddedPass (_gd );_gda .Write (_dfb );if R >=3{for _agd :=0;_agd < 50;_agd ++{_cfd :=_gda .Sum (nil );
_gda =_gg .New ();_gda .Write (_cfd );};};_aac :=_gda .Sum (nil );if R ==2{_aac =_aac [0:5];}else {_aac =_aac [0:_eaf .Length /8];};return _aac ;};

// Authenticate implements StdHandler interface.
func (_ccd stdHandlerR4 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){_fb .Log .Trace ("\u0044\u0065b\u0075\u0067\u0067\u0069n\u0067\u0020a\u0075\u0074\u0068\u0065\u006e\u0074\u0069\u0063a\u0074\u0069\u006f\u006e\u0020\u002d\u0020\u006f\u0077\u006e\u0065\u0072 \u0070\u0061\u0073\u0073");
_ebg ,_gaa :=_ccd .alg7 (d ,pass );if _gaa !=nil {return nil ,0,_gaa ;};if _ebg !=nil {_fb .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _ebg ,PermOwner ,nil ;
};_fb .Log .Trace ("\u0044\u0065bu\u0067\u0067\u0069n\u0067\u0020\u0061\u0075the\u006eti\u0063\u0061\u0074\u0069\u006f\u006e\u0020- \u0075\u0073\u0065\u0072\u0020\u0070\u0061s\u0073");_ebg ,_gaa =_ccd .alg6 (d ,pass );if _gaa !=nil {return nil ,0,_gaa ;
};if _ebg !=nil {_fb .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _ebg ,d .P ,nil ;};return nil ,0,nil ;};type stdHandlerR6 struct{};

// StdHandler is an interface for standard security handlers.
type StdHandler interface{

// GenerateParams uses owner and user passwords to set encryption parameters and generate an encryption key.
// It assumes that R, P and EncryptMetadata are already set.
GenerateParams (_cg *StdEncryptDict ,_cc ,_ggb []byte )([]byte ,error );

// Authenticate uses encryption dictionary parameters and the password to calculate
// the document encryption key. It also returns permissions that should be granted to a user.
// In case of failed authentication, it returns empty key and zero permissions with no error.
Authenticate (_ag *StdEncryptDict ,_ccf []byte )([]byte ,Permissions ,error );};const (PermOwner =Permissions (_ab .MaxUint32 );PermPrinting =Permissions (1<<2);PermModify =Permissions (1<<3);PermExtractGraphics =Permissions (1<<4);PermAnnotate =Permissions (1<<5);
PermFillForms =Permissions (1<<8);PermDisabilityExtract =Permissions (1<<9);PermRotateInsert =Permissions (1<<10);PermFullPrintQuality =Permissions (1<<11););

// AuthEvent is an event type that triggers authentication.
type AuthEvent string ;func (stdHandlerR4 )paddedPass (_afc []byte )[]byte {_dff :=make ([]byte ,32);_gc :=copy (_dff ,_afc );for ;_gc < 32;_gc ++{_dff [_gc ]=_dc [_gc -len (_afc )];};return _dff ;};func _ecd (_geb ,_acd ,_ecee []byte )([]byte ,error ){var (_gbg ,_bga ,_gac _d .Hash ;
);_gbg =_af .New ();_fbgg :=make ([]byte ,64);_dcf :=_gbg ;_dcf .Write (_geb );K :=_dcf .Sum (_fbgg [:0]);_cba :=make ([]byte ,64*(127+64+48));_bcgg :=func (_cca int )([]byte ,error ){_acb :=len (_acd )+len (K )+len (_ecee );_gega :=_cba [:_acb ];_gegg :=copy (_gega ,_acd );
_gegg +=copy (_gega [_gegg :],K [:]);_gegg +=copy (_gega [_gegg :],_ecee );if _gegg !=_acb {_fb .Log .Error ("E\u0052\u0052\u004f\u0052\u003a\u0020u\u006e\u0065\u0078\u0070\u0065\u0063t\u0065\u0064\u0020\u0072\u006f\u0075\u006ed\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0073\u0069\u007ae\u002e");
return nil ,_ec .New ("\u0077\u0072\u006f\u006e\u0067\u0020\u0073\u0069\u007a\u0065");};K1 :=_cba [:_acb *64];_bagf (K1 ,_acb );_cdea ,_dbae :=_bgba (K [0:16]);if _dbae !=nil {return nil ,_dbae ;};_efc :=_g .NewCBCEncrypter (_cdea ,K [16:32]);_efc .CryptBlocks (K1 ,K1 );
E :=K1 ;_fed :=0;for _bfe :=0;_bfe < 16;_bfe ++{_fed +=int (E [_bfe ]%3);};var _egg _d .Hash ;switch _fed %3{case 0:_egg =_gbg ;case 1:if _bga ==nil {_bga =_a .New384 ();};_egg =_bga ;case 2:if _gac ==nil {_gac =_a .New ();};_egg =_gac ;};_egg .Reset ();
_egg .Write (E );K =_egg .Sum (_fbgg [:0]);return E ,nil ;};for _fgd :=0;;{E ,_ggd :=_bcgg (_fgd );if _ggd !=nil {return nil ,_ggd ;};_fdf :=E [len (E )-1];_fgd ++;if _fgd >=64&&_fdf <=uint8 (_fgd -32){break ;};};return K [:32],nil ;};type ecbEncrypter ecb ;


// GenerateParams generates and sets O and U parameters for the encryption dictionary.
// It expects R, P and EncryptMetadata fields to be set.
func (_bac stdHandlerR4 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){O ,_efb :=_bac .alg3 (d .R ,upass ,opass );if _efb !=nil {_fb .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_efb );
return nil ,_efb ;};d .O =O ;_fb .Log .Trace ("\u0067\u0065\u006e\u0020\u004f\u003a\u0020\u0025\u0020\u0078",O );_ggg :=_bac .alg2 (d ,upass );U ,_efb :=_bac .alg5 (_ggg ,upass );if _efb !=nil {_fb .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_efb );
return nil ,_efb ;};d .U =U ;_fb .Log .Trace ("\u0067\u0065\u006e\u0020\u0055\u003a\u0020\u0025\u0020\u0078",U );return _ggg ,nil ;};func (_fee *ecbDecrypter )BlockSize ()int {return _fee ._be };func _gge (_ge _g .Block )_g .BlockMode {return (*ecbDecrypter )(_bg (_ge ))};
func (_dgb stdHandlerR4 )alg2 (_ef *StdEncryptDict ,_eff []byte )[]byte {_fb .Log .Trace ("\u0061\u006c\u0067\u0032");_gab :=_dgb .paddedPass (_eff );_ggf :=_gg .New ();_ggf .Write (_gab );_ggf .Write (_ef .O );var _aa [4]byte ;_b .LittleEndian .PutUint32 (_aa [:],uint32 (_ef .P ));
_ggf .Write (_aa [:]);_fb .Log .Trace ("\u0067o\u0020\u0050\u003a\u0020\u0025\u0020x",_aa );_ggf .Write ([]byte (_dgb .ID0 ));_fb .Log .Trace ("\u0074\u0068\u0069\u0073\u002e\u0052\u0020\u003d\u0020\u0025d\u0020\u0065\u006e\u0063\u0072\u0079\u0070t\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061\u0020\u0025\u0076",_ef .R ,_ef .EncryptMetadata );
if (_ef .R >=4)&&!_ef .EncryptMetadata {_ggf .Write ([]byte {0xff,0xff,0xff,0xff});};_bag :=_ggf .Sum (nil );if _ef .R >=3{_ggf =_gg .New ();for _aae :=0;_aae < 50;_aae ++{_ggf .Reset ();_ggf .Write (_bag [0:_dgb .Length /8]);_bag =_ggf .Sum (nil );};};
if _ef .R >=3{return _bag [0:_dgb .Length /8];};return _bag [0:5];};var _ StdHandler =stdHandlerR4 {};

// Permissions is a bitmask of access permissions for a PDF file.
type Permissions uint32 ;func (_dde *ecbDecrypter )CryptBlocks (dst ,src []byte ){if len (src )%_dde ._be !=0{_fb .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_fb .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0064\u0065\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_dde ._ea .Decrypt (dst ,src [:_dde ._be ]);src =src [_dde ._be :];dst =dst [_dde ._be :];};};func (_gcf stdHandlerR4 )alg7 (_ccfc *StdEncryptDict ,_aga []byte )([]byte ,error ){_gb :=_gcf .alg3Key (_ccfc .R ,_aga );_dea :=make ([]byte ,len (_ccfc .O ));
if _ccfc .R ==2{_gcd ,_fa :=_c .NewCipher (_gb );if _fa !=nil {return nil ,_ec .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_gcd .XORKeyStream (_dea ,_ccfc .O );}else if _ccfc .R >=3{_abg :=append ([]byte {},_ccfc .O ...);
for _cbb :=0;_cbb < 20;_cbb ++{_efa :=append ([]byte {},_gb ...);for _fd :=0;_fd < len (_gb );_fd ++{_efa [_fd ]^=byte (19-_cbb );};_def ,_aff :=_c .NewCipher (_efa );if _aff !=nil {return nil ,_ec .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");
};_def .XORKeyStream (_dea ,_abg );_abg =append ([]byte {},_dea ...);};}else {return nil ,_ec .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};_ddge ,_ebc :=_gcf .alg6 (_ccfc ,_dea );if _ebc !=nil {return nil ,nil ;};return _ddge ,nil ;};const (EventDocOpen =AuthEvent ("\u0044o\u0063\u004f\u0070\u0065\u006e");
EventEFOpen =AuthEvent ("\u0045\u0046\u004f\u0070\u0065\u006e"););func _ee (_fe _g .Block )_g .BlockMode {return (*ecbEncrypter )(_bg (_fe ))};

// NewHandlerR4 creates a new standard security handler for R<=4.
func NewHandlerR4 (id0 string ,length int )StdHandler {return stdHandlerR4 {ID0 :id0 ,Length :length }};func (_eeb stdHandlerR6 )alg8 (_gdea *StdEncryptDict ,_ede []byte ,_aaa []byte )error {if _eca :=_dg ("\u0061\u006c\u0067\u0038","\u004b\u0065\u0079",32,_ede );
_eca !=nil {return _eca ;};var _dcg [16]byte ;if _ ,_bed :=_f .ReadFull (_cf .Reader ,_dcg [:]);_bed !=nil {return _bed ;};_bee :=_dcg [0:8];_bgab :=_dcg [8:16];_ddd :=make ([]byte ,len (_aaa )+len (_bee ));_bef :=copy (_ddd ,_aaa );copy (_ddd [_bef :],_bee );
_fcb ,_dbb :=_eeb .alg2b (_gdea .R ,_ddd ,_aaa ,nil );if _dbb !=nil {return _dbb ;};U :=make ([]byte ,len (_fcb )+len (_bee )+len (_bgab ));_bef =copy (U ,_fcb [:32]);_bef +=copy (U [_bef :],_bee );copy (U [_bef :],_bgab );_gdea .U =U ;_bef =len (_aaa );
copy (_ddd [_bef :],_bgab );_fcb ,_dbb =_eeb .alg2b (_gdea .R ,_ddd ,_aaa ,nil );if _dbb !=nil {return _dbb ;};_dag ,_dbb :=_bgba (_fcb [:32]);if _dbb !=nil {return _dbb ;};_dbda :=make ([]byte ,_de .BlockSize );_bacf :=_g .NewCBCEncrypter (_dag ,_dbda );
UE :=make ([]byte ,32);_bacf .CryptBlocks (UE ,_ede [:32]);_gdea .UE =UE ;return nil ;};func (_ae stdHandlerR6 )alg2b (R int ,_gfg ,_bcad ,_ggga []byte )([]byte ,error ){if R ==5{return _abf (_gfg );};return _ecd (_gfg ,_bcad ,_ggga );};func _bagf (_adc []byte ,_gef int ){_fge :=_gef ;
for _fge < len (_adc ){copy (_adc [_fge :],_adc [:_fge ]);_fge *=2;};};type ecb struct{_ea _g .Block ;_be int ;};func (_bdf stdHandlerR6 )alg12 (_fdeb *StdEncryptDict ,_dbab []byte )([]byte ,error ){if _cdg :=_dg ("\u0061\u006c\u00671\u0032","\u0055",48,_fdeb .U );
_cdg !=nil {return nil ,_cdg ;};if _dgf :=_dg ("\u0061\u006c\u00671\u0032","\u004f",48,_fdeb .O );_dgf !=nil {return nil ,_dgf ;};_eded :=make ([]byte ,len (_dbab )+8+48);_dbe :=copy (_eded ,_dbab );_dbe +=copy (_eded [_dbe :],_fdeb .O [32:40]);_dbe +=copy (_eded [_dbe :],_fdeb .U [0:48]);
_fadg ,_edd :=_bdf .alg2b (_fdeb .R ,_eded ,_dbab ,_fdeb .U [0:48]);if _edd !=nil {return nil ,_edd ;};_fadg =_fadg [:32];if !_ga .Equal (_fadg ,_fdeb .O [:32]){return nil ,nil ;};return _fadg ,nil ;};func (_ebfc stdHandlerR6 )alg11 (_bfef *StdEncryptDict ,_daf []byte )([]byte ,error ){if _abge :=_dg ("\u0061\u006c\u00671\u0031","\u0055",48,_bfef .U );
_abge !=nil {return nil ,_abge ;};_cga :=make ([]byte ,len (_daf )+8);_aaag :=copy (_cga ,_daf );_aaag +=copy (_cga [_aaag :],_bfef .U [32:40]);_dcfa ,_agg :=_ebfc .alg2b (_bfef .R ,_cga ,_daf ,nil );if _agg !=nil {return nil ,_agg ;};_dcfa =_dcfa [:32];
if !_ga .Equal (_dcfa ,_bfef .U [:32]){return nil ,nil ;};return _dcfa ,nil ;};const _dc ="\x28\277\116\136\x4e\x75\x8a\x41\x64\000\x4e\x56\377"+"\xfa\001\010\056\x2e\x00\xb6\xd0\x68\076\x80\x2f\014"+"\251\xfe\x64\x53\x69\172";func (_gcc stdHandlerR6 )alg9 (_gbd *StdEncryptDict ,_agab []byte ,_cbba []byte )error {if _bad :=_dg ("\u0061\u006c\u0067\u0039","\u004b\u0065\u0079",32,_agab );
_bad !=nil {return _bad ;};if _cbaa :=_dg ("\u0061\u006c\u0067\u0039","\u0055",48,_gbd .U );_cbaa !=nil {return _cbaa ;};var _fde [16]byte ;if _ ,_cgc :=_f .ReadFull (_cf .Reader ,_fde [:]);_cgc !=nil {return _cgc ;};_faf :=_fde [0:8];_gba :=_fde [8:16];
_gbe :=_gbd .U [:48];_bcga :=make ([]byte ,len (_cbba )+len (_faf )+len (_gbe ));_gad :=copy (_bcga ,_cbba );_gad +=copy (_bcga [_gad :],_faf );_gad +=copy (_bcga [_gad :],_gbe );_cbg ,_ded :=_gcc .alg2b (_gbd .R ,_bcga ,_cbba ,_gbe );if _ded !=nil {return _ded ;
};O :=make ([]byte ,len (_cbg )+len (_faf )+len (_gba ));_gad =copy (O ,_cbg [:32]);_gad +=copy (O [_gad :],_faf );_gad +=copy (O [_gad :],_gba );_gbd .O =O ;_gad =len (_cbba );_gad +=copy (_bcga [_gad :],_gba );_cbg ,_ded =_gcc .alg2b (_gbd .R ,_bcga ,_cbba ,_gbe );
if _ded !=nil {return _ded ;};_eag ,_ded :=_bgba (_cbg [:32]);if _ded !=nil {return _ded ;};_gdf :=make ([]byte ,_de .BlockSize );_cgf :=_g .NewCBCEncrypter (_eag ,_gdf );OE :=make ([]byte ,32);_cgf .CryptBlocks (OE ,_agab [:32]);_gbd .OE =OE ;return nil ;
};func (_ddg stdHandlerR4 )alg3 (R int ,_ed ,_ce []byte )([]byte ,error ){var _bbc []byte ;if len (_ce )> 0{_bbc =_ddg .alg3Key (R ,_ce );}else {_bbc =_ddg .alg3Key (R ,_ed );};_bc ,_fbg :=_c .NewCipher (_bbc );if _fbg !=nil {return nil ,_ec .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_dda :=_ddg .paddedPass (_ed );_ca :=make ([]byte ,len (_dda ));_bc .XORKeyStream (_ca ,_dda );if R >=3{_ff :=make ([]byte ,len (_bbc ));for _gdd :=0;_gdd < 19;_gdd ++{for _gga :=0;_gga < len (_bbc );_gga ++{_ff [_gga ]=_bbc [_gga ]^byte (_gdd +1);};
_cb ,_aag :=_c .NewCipher (_ff );if _aag !=nil {return nil ,_ec .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_cb .XORKeyStream (_ca ,_ca );};};return _ca ,nil ;};func (_ad stdHandlerR4 )alg5 (_fbf []byte ,_dffc []byte )([]byte ,error ){_bgc :=_gg .New ();
_bgc .Write ([]byte (_dc ));_bgc .Write ([]byte (_ad .ID0 ));_ggbb :=_bgc .Sum (nil );_fb .Log .Trace ("\u0061\u006c\u0067\u0035");_fb .Log .Trace ("\u0065k\u0065\u0079\u003a\u0020\u0025\u0020x",_fbf );_fb .Log .Trace ("\u0049D\u003a\u0020\u0025\u0020\u0078",_ad .ID0 );
if len (_ggbb )!=16{return nil ,_ec .New ("\u0068a\u0073\u0068\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074\u0020\u0031\u0036\u0020\u0062\u0079\u0074\u0065\u0073");};_gf ,_cd :=_c .NewCipher (_fbf );if _cd !=nil {return nil ,_ec .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_eb :=make ([]byte ,16);_gf .XORKeyStream (_eb ,_ggbb );_bec :=make ([]byte ,len (_fbf ));for _ecf :=0;_ecf < 19;_ecf ++{for _cde :=0;_cde < len (_fbf );_cde ++{_bec [_cde ]=_fbf [_cde ]^byte (_ecf +1);};_gf ,_cd =_c .NewCipher (_bec );if _cd !=nil {return nil ,_ec .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_gf .XORKeyStream (_eb ,_eb );_fb .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u002c\u0020\u0065\u006b\u0065\u0079:\u0020\u0025\u0020\u0078",_ecf ,_bec );_fb .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0020\u0078",_ecf ,_eb );
};_adf :=make ([]byte ,32);for _efg :=0;_efg < 16;_efg ++{_adf [_efg ]=_eb [_efg ];};_ ,_cd =_cf .Read (_adf [16:32]);if _cd !=nil {return nil ,_ec .New ("\u0066a\u0069\u006c\u0065\u0064 \u0074\u006f\u0020\u0067\u0065n\u0020r\u0061n\u0064\u0020\u006e\u0075\u006d\u0062\u0065r");
};return _adf ,nil ;};func (_ecg *ecbEncrypter )BlockSize ()int {return _ecg ._be };var _ StdHandler =stdHandlerR6 {};

// NewHandlerR6 creates a new standard security handler for R=5 and R=6.
func NewHandlerR6 ()StdHandler {return stdHandlerR6 {}};func _abf (_efd []byte )([]byte ,error ){_dad :=_af .New ();_dad .Write (_efd );return _dad .Sum (nil ),nil ;};func _bgba (_eae []byte )(_g .Block ,error ){_ffd ,_gae :=_de .NewCipher (_eae );if _gae !=nil {_fb .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0063\u0072\u0065\u0061\u0074\u0065\u0020A\u0045\u0053\u0020\u0063\u0069p\u0068\u0065r\u003a\u0020\u0025\u0076",_gae );
return nil ,_gae ;};return _ffd ,nil ;};

// GenerateParams is the algorithm opposite to alg2a (R>=5).
// It generates U,O,UE,OE,Perms fields using AESv3 encryption.
// There is no algorithm number assigned to this function in the spec.
// It expects R, P and EncryptMetadata fields to be set.
func (_eee stdHandlerR6 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){_cbd :=make ([]byte ,32);if _ ,_cbf :=_f .ReadFull (_cf .Reader ,_cbd );_cbf !=nil {return nil ,_cbf ;};d .U =nil ;d .O =nil ;d .UE =nil ;d .OE =nil ;d .Perms =nil ;
if len (upass )> 127{upass =upass [:127];};if len (opass )> 127{opass =opass [:127];};if _feeg :=_eee .alg8 (d ,_cbd ,upass );_feeg !=nil {return nil ,_feeg ;};if _gggb :=_eee .alg9 (d ,_cbd ,opass );_gggb !=nil {return nil ,_gggb ;};if d .R ==5{return _cbd ,nil ;
};if _cdf :=_eee .alg10 (d ,_cbd );_cdf !=nil {return nil ,_cdf ;};return _cbd ,nil ;};