//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package security ;import (_cf "bytes";_gf "crypto/aes";_e "crypto/cipher";_de "crypto/md5";_fb "crypto/rand";_a "crypto/rc4";_d "crypto/sha256";_ff "crypto/sha512";_cd "encoding/binary";_gff "errors";_cg "fmt";_eb "github.com/unidoc/unipdf/v3/common";_g "hash";_c "io";_fg "math";);func _fa (_gg _e .Block )_e .BlockMode {return (*ecbDecrypter )(_fd (_gg ))};func _cdf (_ce _e .Block )_e .BlockMode {return (*ecbEncrypter )(_fd (_ce ))};const (EventDocOpen =AuthEvent ("\u0044o\u0063\u004f\u0070\u0065\u006e");EventEFOpen =AuthEvent ("\u0045\u0046\u004f\u0070\u0065\u006e"););func (_efe stdHandlerR4 )alg7 (_baa *StdEncryptDict ,_dbf []byte )([]byte ,error ){_cc :=_efe .alg3Key (_baa .R ,_dbf );_afc :=make ([]byte ,len (_baa .O ));if _baa .R ==2{_cbfe ,_ecg :=_a .NewCipher (_cc );if _ecg !=nil {return nil ,_gff .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_cbfe .XORKeyStream (_afc ,_baa .O );}else if _baa .R >=3{_dcf :=append ([]byte {},_baa .O ...);for _ceb :=0;_ceb < 20;_ceb ++{_dg :=append ([]byte {},_cc ...);for _dgb :=0;_dgb < len (_cc );_dgb ++{_dg [_dgb ]^=byte (19-_ceb );};_cde ,_fbf :=_a .NewCipher (_dg );if _fbf !=nil {return nil ,_gff .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_cde .XORKeyStream (_afc ,_dcf );_dcf =append ([]byte {},_afc ...);};}else {return nil ,_gff .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};_baf ,_ceg :=_efe .alg6 (_baa ,_afc );if _ceg !=nil {return nil ,nil ;};return _baf ,nil ;};const (PermOwner =Permissions (_fg .MaxUint32 );PermPrinting =Permissions (1<<2);PermModify =Permissions (1<<3);PermExtractGraphics =Permissions (1<<4);PermAnnotate =Permissions (1<<5);PermFillForms =Permissions (1<<8);PermDisabilityExtract =Permissions (1<<9);PermRotateInsert =Permissions (1<<10);PermFullPrintQuality =Permissions (1<<11););type ecb struct{_cb _e .Block ;_ec int ;};

// Authenticate implements StdHandler interface.
func (_dcc stdHandlerR4 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){_eb .Log .Trace ("\u0044\u0065b\u0075\u0067\u0067\u0069n\u0067\u0020a\u0075\u0074\u0068\u0065\u006e\u0074\u0069\u0063a\u0074\u0069\u006f\u006e\u0020\u002d\u0020\u006f\u0077\u006e\u0065\u0072 \u0070\u0061\u0073\u0073");_bfg ,_ede :=_dcc .alg7 (d ,pass );if _ede !=nil {return nil ,0,_ede ;};if _bfg !=nil {_eb .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _bfg ,PermOwner ,nil ;};_eb .Log .Trace ("\u0044\u0065bu\u0067\u0067\u0069n\u0067\u0020\u0061\u0075the\u006eti\u0063\u0061\u0074\u0069\u006f\u006e\u0020- \u0075\u0073\u0065\u0072\u0020\u0070\u0061s\u0073");_bfg ,_ede =_dcc .alg6 (d ,pass );if _ede !=nil {return nil ,0,_ede ;};if _bfg !=nil {_eb .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _bfg ,d .P ,nil ;};return nil ,0,nil ;};func (_aaf stdHandlerR6 )alg8 (_dae *StdEncryptDict ,_gde []byte ,_ebcf []byte )error {if _cbb :=_cbf ("\u0061\u006c\u0067\u0038","\u004b\u0065\u0079",32,_gde );_cbb !=nil {return _cbb ;};var _gcb [16]byte ;if _ ,_fgce :=_c .ReadFull (_fb .Reader ,_gcb [:]);_fgce !=nil {return _fgce ;};_ccd :=_gcb [0:8];_gffb :=_gcb [8:16];_baff :=make ([]byte ,len (_ebcf )+len (_ccd ));_afd :=copy (_baff ,_ebcf );copy (_baff [_afd :],_ccd );_cdfgd ,_dfgg :=_aaf .alg2b (_dae .R ,_baff ,_ebcf ,nil );if _dfgg !=nil {return _dfgg ;};U :=make ([]byte ,len (_cdfgd )+len (_ccd )+len (_gffb ));_afd =copy (U ,_cdfgd [:32]);_afd +=copy (U [_afd :],_ccd );copy (U [_afd :],_gffb );_dae .U =U ;_afd =len (_ebcf );copy (_baff [_afd :],_gffb );_cdfgd ,_dfgg =_aaf .alg2b (_dae .R ,_baff ,_ebcf ,nil );if _dfgg !=nil {return _dfgg ;};_cff ,_dfgg :=_cfa (_cdfgd [:32]);if _dfgg !=nil {return _dfgg ;};_aef :=make ([]byte ,_gf .BlockSize );_aga :=_e .NewCBCEncrypter (_cff ,_aef );UE :=make ([]byte ,32);_aga .CryptBlocks (UE ,_gde [:32]);_dae .UE =UE ;return nil ;};func (_dc *ecbEncrypter )CryptBlocks (dst ,src []byte ){if len (src )%_dc ._ec !=0{_eb .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");return ;};if len (dst )< len (src ){_eb .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");return ;};for len (src )> 0{_dc ._cb .Encrypt (dst ,src [:_dc ._ec ]);src =src [_dc ._ec :];dst =dst [_dc ._ec :];};};

// Authenticate implements StdHandler interface.
func (_ecbe stdHandlerR6 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){return _ecbe .alg2a (d ,pass );};func (_ece stdHandlerR6 )alg12 (_cbe *StdEncryptDict ,_ebdcc []byte )([]byte ,error ){if _aec :=_cbf ("\u0061\u006c\u00671\u0032","\u0055",48,_cbe .U );_aec !=nil {return nil ,_aec ;};if _gbfb :=_cbf ("\u0061\u006c\u00671\u0032","\u004f",48,_cbe .O );_gbfb !=nil {return nil ,_gbfb ;};_bfab :=make ([]byte ,len (_ebdcc )+8+48);_bcb :=copy (_bfab ,_ebdcc );_bcb +=copy (_bfab [_bcb :],_cbe .O [32:40]);_bcb +=copy (_bfab [_bcb :],_cbe .U [0:48]);_cgd ,_ccc :=_ece .alg2b (_cbe .R ,_bfab ,_ebdcc ,_cbe .U [0:48]);if _ccc !=nil {return nil ,_ccc ;};_cgd =_cgd [:32];if !_cf .Equal (_cgd ,_cbe .O [:32]){return nil ,nil ;};return _cgd ,nil ;};

// StdHandler is an interface for standard security handlers.
type StdHandler interface{

// GenerateParams uses owner and user passwords to set encryption parameters and generate an encryption key.
// It assumes that R, P and EncryptMetadata are already set.
GenerateParams (_gfg *StdEncryptDict ,_bd ,_bb []byte )([]byte ,error );

// Authenticate uses encryption dictionary parameters and the password to calculate
// the document encryption key. It also returns permissions that should be granted to a user.
// In case of failed authentication, it returns empty key and zero permissions with no error.
Authenticate (_ebc *StdEncryptDict ,_deg []byte )([]byte ,Permissions ,error );};func (_gegf stdHandlerR6 )alg10 (_fece *StdEncryptDict ,_bbc []byte )error {if _ddg :=_cbf ("\u0061\u006c\u00671\u0030","\u004b\u0065\u0079",32,_bbc );_ddg !=nil {return _ddg ;};_fadf :=uint64 (uint32 (_fece .P ))|(_fg .MaxUint32 <<32);Perms :=make ([]byte ,16);_cd .LittleEndian .PutUint64 (Perms [:8],_fadf );if _fece .EncryptMetadata {Perms [8]='T';}else {Perms [8]='F';};copy (Perms [9:12],"\u0061\u0064\u0062");if _ ,_defb :=_c .ReadFull (_fb .Reader ,Perms [12:16]);_defb !=nil {return _defb ;};_aed ,_gda :=_cfa (_bbc [:32]);if _gda !=nil {return _gda ;};_fba :=_cdf (_aed );_fba .CryptBlocks (Perms ,Perms );_fece .Perms =Perms [:16];return nil ;};

// NewHandlerR6 creates a new standard security handler for R=5 and R=6.
func NewHandlerR6 ()StdHandler {return stdHandlerR6 {}};

// NewHandlerR4 creates a new standard security handler for R<=4.
func NewHandlerR4 (id0 string ,length int )StdHandler {return stdHandlerR4 {ID0 :id0 ,Length :length }};func (_fcc stdHandlerR4 )alg5 (_gefe []byte ,_ebg []byte )([]byte ,error ){_cfc :=_de .New ();_cfc .Write ([]byte (_da ));_cfc .Write ([]byte (_fcc .ID0 ));_aac :=_cfc .Sum (nil );_eb .Log .Trace ("\u0061\u006c\u0067\u0035");_eb .Log .Trace ("\u0065k\u0065\u0079\u003a\u0020\u0025\u0020x",_gefe );_eb .Log .Trace ("\u0049D\u003a\u0020\u0025\u0020\u0078",_fcc .ID0 );if len (_aac )!=16{return nil ,_gff .New ("\u0068a\u0073\u0068\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074\u0020\u0031\u0036\u0020\u0062\u0079\u0074\u0065\u0073");};_dfg ,_dcg :=_a .NewCipher (_gefe );if _dcg !=nil {return nil ,_gff .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_gaa :=make ([]byte ,16);_dfg .XORKeyStream (_gaa ,_aac );_gbd :=make ([]byte ,len (_gefe ));for _ebd :=0;_ebd < 19;_ebd ++{for _fcd :=0;_fcd < len (_gefe );_fcd ++{_gbd [_fcd ]=_gefe [_fcd ]^byte (_ebd +1);};_dfg ,_dcg =_a .NewCipher (_gbd );if _dcg !=nil {return nil ,_gff .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_dfg .XORKeyStream (_gaa ,_gaa );_eb .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u002c\u0020\u0065\u006b\u0065\u0079:\u0020\u0025\u0020\u0078",_ebd ,_gbd );_eb .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0020\u0078",_ebd ,_gaa );};_dde :=make ([]byte ,32);for _acc :=0;_acc < 16;_acc ++{_dde [_acc ]=_gaa [_acc ];};_ ,_dcg =_fb .Read (_dde [16:32]);if _dcg !=nil {return nil ,_gff .New ("\u0066a\u0069\u006c\u0065\u0064 \u0074\u006f\u0020\u0067\u0065n\u0020r\u0061n\u0064\u0020\u006e\u0075\u006d\u0062\u0065r");};return _dde ,nil ;};func _fgc (_cbc []byte )([]byte ,error ){_def :=_d .New ();_def .Write (_cbc );return _def .Sum (nil ),nil };var _ StdHandler =stdHandlerR6 {};func _dcce (_afe []byte ,_dga int ){_gcd :=_dga ;for _gcd < len (_afe ){copy (_afe [_gcd :],_afe [:_gcd ]);_gcd *=2;};};type stdHandlerR4 struct{Length int ;ID0 string ;};func (_bag stdHandlerR6 )alg13 (_fga *StdEncryptDict ,_cdfd []byte )error {if _cfd :=_cbf ("\u0061\u006c\u00671\u0033","\u004b\u0065\u0079",32,_cdfd );_cfd !=nil {return _cfd ;};if _eba :=_cbf ("\u0061\u006c\u00671\u0033","\u0050\u0065\u0072m\u0073",16,_fga .Perms );_eba !=nil {return _eba ;};_aff :=make ([]byte ,16);copy (_aff ,_fga .Perms [:16]);_dgc ,_gcbf :=_gf .NewCipher (_cdfd [:32]);if _gcbf !=nil {return _gcbf ;};_degc :=_fa (_dgc );_degc .CryptBlocks (_aff ,_aff );if !_cf .Equal (_aff [9:12],[]byte ("\u0061\u0064\u0062")){return _gff .New ("\u0064\u0065\u0063o\u0064\u0065\u0064\u0020p\u0065\u0072\u006d\u0069\u0073\u0073\u0069o\u006e\u0073\u0020\u0061\u0072\u0065\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_geaa :=Permissions (_cd .LittleEndian .Uint32 (_aff [0:4]));if _geaa !=_fga .P {return _gff .New ("\u0070\u0065r\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066\u0061il\u0065\u0064");};var _bfaf bool ;if _aff [8]=='T'{_bfaf =true ;}else if _aff [8]=='F'{_bfaf =false ;}else {return _gff .New ("\u0064\u0065\u0063\u006f\u0064\u0065\u0064 \u006d\u0065\u0074a\u0064\u0061\u0074\u0061 \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u006c\u0061\u0067\u0020\u0069\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};if _bfaf !=_fga .EncryptMetadata {return _gff .New ("\u006d\u0065t\u0061\u0064\u0061\u0074a\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e \u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066a\u0069\u006c\u0065\u0064");};return nil ;};func (_bg stdHandlerR4 )alg4 (_gdd []byte ,_acg []byte )([]byte ,error ){_gcc ,_ad :=_a .NewCipher (_gdd );if _ad !=nil {return nil ,_gff .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_eed :=[]byte (_da );_gef :=make ([]byte ,len (_eed ));_gcc .XORKeyStream (_gef ,_eed );return _gef ,nil ;};const _da ="\x28\277\116\136\x4e\x75\x8a\x41\x64\000\x4e\x56\377"+"\xfa\001\010\056\x2e\x00\xb6\xd0\x68\076\x80\x2f\014"+"\251\xfe\x64\x53\x69\172";

// StdEncryptDict is a set of additional fields used in standard encryption dictionary.
type StdEncryptDict struct{R int ;P Permissions ;EncryptMetadata bool ;O ,U []byte ;OE ,UE []byte ;Perms []byte ;};func (_ac errInvalidField )Error ()string {return _cg .Sprintf ("\u0025s\u003a\u0020e\u0078\u0070\u0065\u0063t\u0065\u0064\u0020%\u0073\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0074o \u0062\u0065\u0020%\u0064\u0020b\u0079\u0074\u0065\u0073\u002c\u0020g\u006f\u0074 \u0025\u0064",_ac .Func ,_ac .Field ,_ac .Exp ,_ac .Got );};type ecbDecrypter ecb ;func (_ef *ecbDecrypter )BlockSize ()int {return _ef ._ec };func _cbf (_db ,_gd string ,_fc int ,_dd []byte )error {if len (_dd )< _fc {return errInvalidField {Func :_db ,Field :_gd ,Exp :_fc ,Got :len (_dd )};};return nil ;};type stdHandlerR6 struct{};func _fd (_fdg _e .Block )*ecb {return &ecb {_cb :_fdg ,_ec :_fdg .BlockSize ()}};type ecbEncrypter ecb ;

// Permissions is a bitmask of access permissions for a PDF file.
type Permissions uint32 ;

// AuthEvent is an event type that triggers authentication.
type AuthEvent string ;func (_cgc stdHandlerR6 )alg2a (_fec *StdEncryptDict ,_dac []byte )([]byte ,Permissions ,error ){if _dad :=_cbf ("\u0061\u006c\u00672\u0061","\u004f",48,_fec .O );_dad !=nil {return nil ,0,_dad ;};if _ced :=_cbf ("\u0061\u006c\u00672\u0061","\u0055",48,_fec .U );_ced !=nil {return nil ,0,_ced ;};if len (_dac )> 127{_dac =_dac [:127];};_cdc ,_efd :=_cgc .alg12 (_fec ,_dac );if _efd !=nil {return nil ,0,_efd ;};var (_ffg []byte ;_fgb []byte ;_ecgc []byte ;);var _ccb Permissions ;if len (_cdc )!=0{_ccb =PermOwner ;_dfc :=make ([]byte ,len (_dac )+8+48);_bga :=copy (_dfc ,_dac );_bga +=copy (_dfc [_bga :],_fec .O [40:48]);copy (_dfc [_bga :],_fec .U [0:48]);_ffg =_dfc ;_fgb =_fec .OE ;_ecgc =_fec .U [0:48];}else {_cdc ,_efd =_cgc .alg11 (_fec ,_dac );if _efd ==nil &&len (_cdc )==0{_cdc ,_efd =_cgc .alg11 (_fec ,[]byte (""));};if _efd !=nil {return nil ,0,_efd ;}else if len (_cdc )==0{return nil ,0,nil ;};_ccb =_fec .P ;_ace :=make ([]byte ,len (_dac )+8);_efc :=copy (_ace ,_dac );copy (_ace [_efc :],_fec .U [40:48]);_ffg =_ace ;_fgb =_fec .UE ;_ecgc =nil ;};if _bfga :=_cbf ("\u0061\u006c\u00672\u0061","\u004b\u0065\u0079",32,_fgb );_bfga !=nil {return nil ,0,_bfga ;};_fgb =_fgb [:32];_abe ,_efd :=_cgc .alg2b (_fec .R ,_ffg ,_dac ,_ecgc );if _efd !=nil {return nil ,0,_efd ;};_cba ,_efd :=_gf .NewCipher (_abe [:32]);if _efd !=nil {return nil ,0,_efd ;};_dgbf :=make ([]byte ,_gf .BlockSize );_gggg :=_e .NewCBCDecrypter (_cba ,_dgbf );_aca :=make ([]byte ,32);_gggg .CryptBlocks (_aca ,_fgb );if _fec .R ==5{return _aca ,_ccb ,nil ;};_efd =_cgc .alg13 (_fec ,_aca );if _efd !=nil {return nil ,0,_efd ;};return _aca ,_ccb ,nil ;};func (_ed stdHandlerR4 )alg2 (_aa *StdEncryptDict ,_af []byte )[]byte {_eb .Log .Trace ("\u0061\u006c\u0067\u0032");_fad :=_ed .paddedPass (_af );_ecb :=_de .New ();_ecb .Write (_fad );_ecb .Write (_aa .O );var _fe [4]byte ;_cd .LittleEndian .PutUint32 (_fe [:],uint32 (_aa .P ));_ecb .Write (_fe [:]);_eb .Log .Trace ("\u0067o\u0020\u0050\u003a\u0020\u0025\u0020x",_fe );_ecb .Write ([]byte (_ed .ID0 ));_eb .Log .Trace ("\u0074\u0068\u0069\u0073\u002e\u0052\u0020\u003d\u0020\u0025d\u0020\u0065\u006e\u0063\u0072\u0079\u0070t\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061\u0020\u0025\u0076",_aa .R ,_aa .EncryptMetadata );if (_aa .R >=4)&&!_aa .EncryptMetadata {_ecb .Write ([]byte {0xff,0xff,0xff,0xff});};_gdg :=_ecb .Sum (nil );if _aa .R >=3{_ecb =_de .New ();for _dcb :=0;_dcb < 50;_dcb ++{_ecb .Reset ();_ecb .Write (_gdg [0:_ed .Length /8]);_gdg =_ecb .Sum (nil );};};if _aa .R >=3{return _gdg [0:_ed .Length /8];};return _gdg [0:5];};func (_ggg stdHandlerR4 )alg3Key (R int ,_ab []byte )[]byte {_gc :=_de .New ();_ge :=_ggg .paddedPass (_ab );_gc .Write (_ge );if R >=3{for _caa :=0;_caa < 50;_caa ++{_ae :=_gc .Sum (nil );_gc =_de .New ();_gc .Write (_ae );};};_bdb :=_gc .Sum (nil );if R ==2{_bdb =_bdb [0:5];}else {_bdb =_bdb [0:_ggg .Length /8];};return _bdb ;};

// GenerateParams generates and sets O and U parameters for the encryption dictionary.
// It expects R, P and EncryptMetadata fields to be set.
func (_gebf stdHandlerR4 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){O ,_dea :=_gebf .alg3 (d .R ,upass ,opass );if _dea !=nil {_eb .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_dea );return nil ,_dea ;};d .O =O ;_eb .Log .Trace ("\u0067\u0065\u006e\u0020\u004f\u003a\u0020\u0025\u0020\u0078",O );_geba :=_gebf .alg2 (d ,upass );U ,_dea :=_gebf .alg5 (_geba ,upass );if _dea !=nil {_eb .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_dea );return nil ,_dea ;};d .U =U ;_eb .Log .Trace ("\u0067\u0065\u006e\u0020\u0055\u003a\u0020\u0025\u0020\u0078",U );return _geba ,nil ;};func (_egc stdHandlerR4 )alg6 (_gae *StdEncryptDict ,_babb []byte )([]byte ,error ){var (_ea []byte ;_cfcb error ;);_agd :=_egc .alg2 (_gae ,_babb );if _gae .R ==2{_ea ,_cfcb =_egc .alg4 (_agd ,_babb );}else if _gae .R >=3{_ea ,_cfcb =_egc .alg5 (_agd ,_babb );}else {return nil ,_gff .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};if _cfcb !=nil {return nil ,_cfcb ;};_eb .Log .Trace ("\u0063\u0068\u0065\u0063k:\u0020\u0025\u0020\u0078\u0020\u003d\u003d\u0020\u0025\u0020\u0078\u0020\u003f",string (_ea ),string (_gae .U ));_fdge :=_ea ;_feb :=_gae .U ;if _gae .R >=3{if len (_fdge )> 16{_fdge =_fdge [0:16];};if len (_feb )> 16{_feb =_feb [0:16];};};if !_cf .Equal (_fdge ,_feb ){return nil ,nil ;};return _agd ,nil ;};func (_gcae stdHandlerR6 )alg11 (_aabe *StdEncryptDict ,_aba []byte )([]byte ,error ){if _dgag :=_cbf ("\u0061\u006c\u00671\u0031","\u0055",48,_aabe .U );_dgag !=nil {return nil ,_dgag ;};_dge :=make ([]byte ,len (_aba )+8);_efef :=copy (_dge ,_aba );_efef +=copy (_dge [_efef :],_aabe .U [32:40]);_cgg ,_gbb :=_gcae .alg2b (_aabe .R ,_dge ,_aba ,nil );if _gbb !=nil {return nil ,_gbb ;};_cgg =_cgg [:32];if !_cf .Equal (_cgg ,_aabe .U [:32]){return nil ,nil ;};return _cgg ,nil ;};type errInvalidField struct{Func string ;Field string ;Exp int ;Got int ;};func (_gca stdHandlerR6 )alg9 (_fed *StdEncryptDict ,_gfe []byte ,_cdb []byte )error {if _bfa :=_cbf ("\u0061\u006c\u0067\u0039","\u004b\u0065\u0079",32,_gfe );_bfa !=nil {return _bfa ;};if _ageb :=_cbf ("\u0061\u006c\u0067\u0039","\u0055",48,_fed .U );_ageb !=nil {return _ageb ;};var _ccf [16]byte ;if _ ,_gga :=_c .ReadFull (_fb .Reader ,_ccf [:]);_gga !=nil {return _gga ;};_aea :=_ccf [0:8];_gac :=_ccf [8:16];_febd :=_fed .U [:48];_agcg :=make ([]byte ,len (_cdb )+len (_aea )+len (_febd ));_edea :=copy (_agcg ,_cdb );_edea +=copy (_agcg [_edea :],_aea );_edea +=copy (_agcg [_edea :],_febd );_gbdg ,_ebe :=_gca .alg2b (_fed .R ,_agcg ,_cdb ,_febd );if _ebe !=nil {return _ebe ;};O :=make ([]byte ,len (_gbdg )+len (_aea )+len (_gac ));_edea =copy (O ,_gbdg [:32]);_edea +=copy (O [_edea :],_aea );_edea +=copy (O [_edea :],_gac );_fed .O =O ;_edea =len (_cdb );_edea +=copy (_agcg [_edea :],_gac );_gbdg ,_ebe =_gca .alg2b (_fed .R ,_agcg ,_cdb ,_febd );if _ebe !=nil {return _ebe ;};_aab ,_ebe :=_cfa (_gbdg [:32]);if _ebe !=nil {return _ebe ;};_edec :=make ([]byte ,_gf .BlockSize );_gbc :=_e .NewCBCEncrypter (_aab ,_edec );OE :=make ([]byte ,32);_gbc .CryptBlocks (OE ,_gfe [:32]);_fed .OE =OE ;return nil ;};func (_bf stdHandlerR4 )alg3 (R int ,_bbg ,_geb []byte )([]byte ,error ){var _ggf []byte ;if len (_geb )> 0{_ggf =_bf .alg3Key (R ,_geb );}else {_ggf =_bf .alg3Key (R ,_bbg );};_eg ,_fag :=_a .NewCipher (_ggf );if _fag !=nil {return nil ,_gff .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_cdfg :=_bf .paddedPass (_bbg );_ag :=make ([]byte ,len (_cdfg ));_eg .XORKeyStream (_ag ,_cdfg );if R >=3{_df :=make ([]byte ,len (_ggf ));for _dca :=0;_dca < 19;_dca ++{for _deb :=0;_deb < len (_ggf );_deb ++{_df [_deb ]=_ggf [_deb ]^byte (_dca +1);};_bc ,_gb :=_a .NewCipher (_df );if _gb !=nil {return nil ,_gff .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_bc .XORKeyStream (_ag ,_ag );};};return _ag ,nil ;};func _febg (_efed ,_fbg ,_gce []byte )([]byte ,error ){var (_gcef ,_cda ,_gfgg _g .Hash ;);_gcef =_d .New ();_fbc :=make ([]byte ,64);_be :=_gcef ;_be .Write (_efed );K :=_be .Sum (_fbc [:0]);_cad :=make ([]byte ,64*(127+64+48));_gea :=func (_ffea int )([]byte ,error ){_cded :=len (_fbg )+len (K )+len (_gce );_geg :=_cad [:_cded ];_cca :=copy (_geg ,_fbg );_cca +=copy (_geg [_cca :],K [:]);_cca +=copy (_geg [_cca :],_gce );if _cca !=_cded {_eb .Log .Error ("E\u0052\u0052\u004f\u0052\u003a\u0020u\u006e\u0065\u0078\u0070\u0065\u0063t\u0065\u0064\u0020\u0072\u006f\u0075\u006ed\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0073\u0069\u007ae\u002e");return nil ,_gff .New ("\u0077\u0072\u006f\u006e\u0067\u0020\u0073\u0069\u007a\u0065");};K1 :=_cad [:_cded *64];_dcce (K1 ,_cded );_faa ,_efb :=_cfa (K [0:16]);if _efb !=nil {return nil ,_efb ;};_dec :=_e .NewCBCEncrypter (_faa ,K [16:32]);_dec .CryptBlocks (K1 ,K1 );E :=K1 ;_ggc :=0;for _bgae :=0;_bgae < 16;_bgae ++{_ggc +=int (E [_bgae ]%3);};var _fbe _g .Hash ;switch _ggc %3{case 0:_fbe =_gcef ;case 1:if _cda ==nil {_cda =_ff .New384 ();};_fbe =_cda ;case 2:if _gfgg ==nil {_gfgg =_ff .New ();};_fbe =_gfgg ;};_fbe .Reset ();_fbe .Write (E );K =_fbe .Sum (_fbc [:0]);return E ,nil ;};for _fbd :=0;;{E ,_acb :=_gea (_fbd );if _acb !=nil {return nil ,_acb ;};_fdd :=E [len (E )-1];_fbd ++;if _fbd >=64&&_fdd <=uint8 (_fbd -32){break ;};};return K [:32],nil ;};var _ StdHandler =stdHandlerR4 {};

// GenerateParams is the algorithm opposite to alg2a (R>=5).
// It generates U,O,UE,OE,Perms fields using AESv3 encryption.
// There is no algorithm number assigned to this function in the spec.
// It expects R, P and EncryptMetadata fields to be set.
func (_faf stdHandlerR6 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){_gacd :=make ([]byte ,32);if _ ,_bdc :=_c .ReadFull (_fb .Reader ,_gacd );_bdc !=nil {return nil ,_bdc ;};d .U =nil ;d .O =nil ;d .UE =nil ;d .OE =nil ;d .Perms =nil ;if len (upass )> 127{upass =upass [:127];};if len (opass )> 127{opass =opass [:127];};if _efg :=_faf .alg8 (d ,_gacd ,upass );_efg !=nil {return nil ,_efg ;};if _abf :=_faf .alg9 (d ,_gacd ,opass );_abf !=nil {return nil ,_abf ;};if d .R ==5{return _gacd ,nil ;};if _cef :=_faf .alg10 (d ,_gacd );_cef !=nil {return nil ,_cef ;};return _gacd ,nil ;};func (stdHandlerR4 )paddedPass (_ee []byte )[]byte {_ffe :=make ([]byte ,32);_ca :=copy (_ffe ,_ee );for ;_ca < 32;_ca ++{_ffe [_ca ]=_da [_ca -len (_ee )];};return _ffe ;};

// Allowed checks if a set of permissions can be granted.
func (_ga Permissions )Allowed (p2 Permissions )bool {return _ga &p2 ==p2 };func _cfa (_ddd []byte )(_e .Block ,error ){_fcde ,_agc :=_gf .NewCipher (_ddd );if _agc !=nil {_eb .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0063\u0072\u0065\u0061\u0074\u0065\u0020A\u0045\u0053\u0020\u0063\u0069p\u0068\u0065r\u003a\u0020\u0025\u0076",_agc );return nil ,_agc ;};return _fcde ,nil ;};func (_ged stdHandlerR6 )alg2b (R int ,_gbf ,_fee ,_age []byte )([]byte ,error ){if R ==5{return _fgc (_gbf );};return _febg (_gbf ,_fee ,_age );};func (_ba *ecbDecrypter )CryptBlocks (dst ,src []byte ){if len (src )%_ba ._ec !=0{_eb .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");return ;};if len (dst )< len (src ){_eb .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0064\u0065\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");return ;};for len (src )> 0{_ba ._cb .Decrypt (dst ,src [:_ba ._ec ]);src =src [_ba ._ec :];dst =dst [_ba ._ec :];};};func (_b *ecbEncrypter )BlockSize ()int {return _b ._ec };