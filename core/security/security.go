//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package security ;import (_ca "bytes";_gad "crypto/aes";_g "crypto/cipher";_bc "crypto/md5";_eb "crypto/rand";_f "crypto/rc4";_ga "crypto/sha256";_a "crypto/sha512";_e "encoding/binary";_d "errors";_da "fmt";_be "github.com/unidoc/unipdf/v3/common";_b "hash";
_cb "io";_dd "math";);func _gbb (_ggc []byte )([]byte ,error ){_faf :=_ga .New ();_faf .Write (_ggc );return _faf .Sum (nil ),nil ;};func (_db stdHandlerR4 )alg3Key (R int ,_gd []byte )[]byte {_cab :=_bc .New ();_cabe :=_db .paddedPass (_gd );_cab .Write (_cabe );
if R >=3{for _fe :=0;_fe < 50;_fe ++{_gge :=_cab .Sum (nil );_cab =_bc .New ();_cab .Write (_gge );};};_fc :=_cab .Sum (nil );if R ==2{_fc =_fc [0:5];}else {_fc =_fc [0:_db .Length /8];};return _fc ;};func (stdHandlerR4 )paddedPass (_dg []byte )[]byte {_gcd :=make ([]byte ,32);
_ba :=copy (_gcd ,_dg );for ;_ba < 32;_ba ++{_gcd [_ba ]=_dcb [_ba -len (_dg )];};return _gcd ;};var _ StdHandler =stdHandlerR6 {};

// Authenticate implements StdHandler interface.
func (_dce stdHandlerR6 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){return _dce .alg2a (d ,pass );};func _bff (_gga []byte )(_g .Block ,error ){_ebde ,_gfg :=_gad .NewCipher (_gga );if _gfg !=nil {_be .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0063\u0072\u0065\u0061\u0074\u0065\u0020A\u0045\u0053\u0020\u0063\u0069p\u0068\u0065r\u003a\u0020\u0025\u0076",_gfg );
return nil ,_gfg ;};return _ebde ,nil ;};type stdHandlerR6 struct{};type ecb struct{_ef _g .Block ;_ddf int ;};func _bb (_ddb _g .Block )_g .BlockMode {return (*ecbDecrypter )(_ebd (_ddb ))};func (_gg errInvalidField )Error ()string {return _da .Sprintf ("\u0025s\u003a\u0020e\u0078\u0070\u0065\u0063t\u0065\u0064\u0020%\u0073\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0074o \u0062\u0065\u0020%\u0064\u0020b\u0079\u0074\u0065\u0073\u002c\u0020g\u006f\u0074 \u0025\u0064",_gg .Func ,_gg .Field ,_gg .Exp ,_gg .Got );
};func (_bbe *ecbDecrypter )CryptBlocks (dst ,src []byte ){if len (src )%_bbe ._ddf !=0{_be .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_be .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0064\u0065\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_bbe ._ef .Decrypt (dst ,src [:_bbe ._ddf ]);src =src [_bbe ._ddf :];dst =dst [_bbe ._ddf :];};};func (_gb stdHandlerR4 )alg2 (_ged *StdEncryptDict ,_ea []byte )[]byte {_be .Log .Trace ("\u0061\u006c\u0067\u0032");_eag :=_gb .paddedPass (_ea );
_gfd :=_bc .New ();_gfd .Write (_eag );_gfd .Write (_ged .O );var _cad [4]byte ;_e .LittleEndian .PutUint32 (_cad [:],uint32 (_ged .P ));_gfd .Write (_cad [:]);_be .Log .Trace ("\u0067o\u0020\u0050\u003a\u0020\u0025\u0020x",_cad );_gfd .Write ([]byte (_gb .ID0 ));
_be .Log .Trace ("\u0074\u0068\u0069\u0073\u002e\u0052\u0020\u003d\u0020\u0025d\u0020\u0065\u006e\u0063\u0072\u0079\u0070t\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061\u0020\u0025\u0076",_ged .R ,_ged .EncryptMetadata );if (_ged .R >=4)&&!_ged .EncryptMetadata {_gfd .Write ([]byte {0xff,0xff,0xff,0xff});
};_eg :=_gfd .Sum (nil );if _ged .R >=3{_gfd =_bc .New ();for _efe :=0;_efe < 50;_efe ++{_gfd .Reset ();_gfd .Write (_eg [0:_gb .Length /8]);_eg =_gfd .Sum (nil );};};if _ged .R >=3{return _eg [0:_gb .Length /8];};return _eg [0:5];};func (_cda stdHandlerR4 )alg5 (_bg []byte ,_bca []byte )([]byte ,error ){_afc :=_bc .New ();
_afc .Write ([]byte (_dcb ));_afc .Write ([]byte (_cda .ID0 ));_geb :=_afc .Sum (nil );_be .Log .Trace ("\u0061\u006c\u0067\u0035");_be .Log .Trace ("\u0065k\u0065\u0079\u003a\u0020\u0025\u0020x",_bg );_be .Log .Trace ("\u0049D\u003a\u0020\u0025\u0020\u0078",_cda .ID0 );
if len (_geb )!=16{return nil ,_d .New ("\u0068a\u0073\u0068\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074\u0020\u0031\u0036\u0020\u0062\u0079\u0074\u0065\u0073");};_cdab ,_cc :=_f .NewCipher (_bg );if _cc !=nil {return nil ,_d .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_gfdg :=make ([]byte ,16);_cdab .XORKeyStream (_gfdg ,_geb );_agb :=make ([]byte ,len (_bg ));for _dda :=0;_dda < 19;_dda ++{for _afg :=0;_afg < len (_bg );_afg ++{_agb [_afg ]=_bg [_afg ]^byte (_dda +1);};_cdab ,_cc =_f .NewCipher (_agb );if _cc !=nil {return nil ,_d .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_cdab .XORKeyStream (_gfdg ,_gfdg );_be .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u002c\u0020\u0065\u006b\u0065\u0079:\u0020\u0025\u0020\u0078",_dda ,_agb );_be .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0020\u0078",_dda ,_gfdg );
};_ffe :=make ([]byte ,32);for _deg :=0;_deg < 16;_deg ++{_ffe [_deg ]=_gfdg [_deg ];};_ ,_cc =_eb .Read (_ffe [16:32]);if _cc !=nil {return nil ,_d .New ("\u0066a\u0069\u006c\u0065\u0064 \u0074\u006f\u0020\u0067\u0065n\u0020r\u0061n\u0064\u0020\u006e\u0075\u006d\u0062\u0065r");
};return _ffe ,nil ;};type ecbDecrypter ecb ;func (_af *ecbEncrypter )CryptBlocks (dst ,src []byte ){if len (src )%_af ._ddf !=0{_be .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_be .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_af ._ef .Encrypt (dst ,src [:_af ._ddf ]);src =src [_af ._ddf :];dst =dst [_af ._ddf :];};};func (_bcd stdHandlerR4 )alg3 (R int ,_ab ,_ag []byte )([]byte ,error ){var _dbe []byte ;if len (_ag )> 0{_dbe =_bcd .alg3Key (R ,_ag );
}else {_dbe =_bcd .alg3Key (R ,_ab );};_bfb ,_bdc :=_f .NewCipher (_dbe );if _bdc !=nil {return nil ,_d .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_cadf :=_bcd .paddedPass (_ab );_ebb :=make ([]byte ,len (_cadf ));
_bfb .XORKeyStream (_ebb ,_cadf );if R >=3{_bef :=make ([]byte ,len (_dbe ));for _ae :=0;_ae < 19;_ae ++{for _dbb :=0;_dbb < len (_dbe );_dbb ++{_bef [_dbb ]=_dbe [_dbb ]^byte (_ae +1);};_de ,_fec :=_f .NewCipher (_bef );if _fec !=nil {return nil ,_d .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_de .XORKeyStream (_ebb ,_ebb );};};return _ebb ,nil ;};

// GenerateParams is the algorithm opposite to alg2a (R>=5).
// It generates U,O,UE,OE,Perms fields using AESv3 encryption.
// There is no algorithm number assigned to this function in the spec.
// It expects R, P and EncryptMetadata fields to be set.
func (_bcc stdHandlerR6 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){_bcg :=make ([]byte ,32);if _ ,_fcc :=_cb .ReadFull (_eb .Reader ,_bcg );_fcc !=nil {return nil ,_fcc ;};d .U =nil ;d .O =nil ;d .UE =nil ;d .OE =nil ;d .Perms =nil ;
if len (upass )> 127{upass =upass [:127];};if len (opass )> 127{opass =opass [:127];};if _cccc :=_bcc .alg8 (d ,_bcg ,upass );_cccc !=nil {return nil ,_cccc ;};if _bdcf :=_bcc .alg9 (d ,_bcg ,opass );_bdcf !=nil {return nil ,_bdcf ;};if d .R ==5{return _bcg ,nil ;
};if _ggea :=_bcc .alg10 (d ,_bcg );_ggea !=nil {return nil ,_ggea ;};return _bcg ,nil ;};func _eac (_feg []byte ,_aac int ){_beb :=_aac ;for _beb < len (_feg ){copy (_feg [_beb :],_feg [:_beb ]);_beb *=2;};};func (_aga stdHandlerR6 )alg11 (_efaf *StdEncryptDict ,_adb []byte )([]byte ,error ){if _cfc :=_ff ("\u0061\u006c\u00671\u0031","\u0055",48,_efaf .U );
_cfc !=nil {return nil ,_cfc ;};_caed :=make ([]byte ,len (_adb )+8);_fffa :=copy (_caed ,_adb );_fffa +=copy (_caed [_fffa :],_efaf .U [32:40]);_bbbd ,_acga :=_aga .alg2b (_efaf .R ,_caed ,_adb ,nil );if _acga !=nil {return nil ,_acga ;};_bbbd =_bbbd [:32];
if !_ca .Equal (_bbbd ,_efaf .U [:32]){return nil ,nil ;};return _bbbd ,nil ;};type stdHandlerR4 struct{Length int ;ID0 string ;};type ecbEncrypter ecb ;func (_efg stdHandlerR6 )alg10 (_bgc *StdEncryptDict ,_adg []byte )error {if _ddbb :=_ff ("\u0061\u006c\u00671\u0030","\u004b\u0065\u0079",32,_adg );
_ddbb !=nil {return _ddbb ;};_gecg :=uint64 (uint32 (_bgc .P ))|(_dd .MaxUint32 <<32);Perms :=make ([]byte ,16);_e .LittleEndian .PutUint64 (Perms [:8],_gecg );if _bgc .EncryptMetadata {Perms [8]='T';}else {Perms [8]='F';};copy (Perms [9:12],"\u0061\u0064\u0062");
if _ ,_degc :=_cb .ReadFull (_eb .Reader ,Perms [12:16]);_degc !=nil {return _degc ;};_aad ,_ccbc :=_bff (_adg [:32]);if _ccbc !=nil {return _ccbc ;};_ffb :=_ddd (_aad );_ffb .CryptBlocks (Perms ,Perms );_bgc .Perms =Perms [:16];return nil ;};func (_ffc stdHandlerR6 )alg9 (_bbb *StdEncryptDict ,_eeb []byte ,_bdb []byte )error {if _fee :=_ff ("\u0061\u006c\u0067\u0039","\u004b\u0065\u0079",32,_eeb );
_fee !=nil {return _fee ;};if _eee :=_ff ("\u0061\u006c\u0067\u0039","\u0055",48,_bbb .U );_eee !=nil {return _eee ;};var _cbc [16]byte ;if _ ,_cae :=_cb .ReadFull (_eb .Reader ,_cbc [:]);_cae !=nil {return _cae ;};_eec :=_cbc [0:8];_gce :=_cbc [8:16];
_ada :=_bbb .U [:48];_dgf :=make ([]byte ,len (_bdb )+len (_eec )+len (_ada ));_dcf :=copy (_dgf ,_bdb );_dcf +=copy (_dgf [_dcf :],_eec );_dcf +=copy (_dgf [_dcf :],_ada );_afbf ,_baf :=_ffc .alg2b (_bbb .R ,_dgf ,_bdb ,_ada );if _baf !=nil {return _baf ;
};O :=make ([]byte ,len (_afbf )+len (_eec )+len (_gce ));_dcf =copy (O ,_afbf [:32]);_dcf +=copy (O [_dcf :],_eec );_dcf +=copy (O [_dcf :],_gce );_bbb .O =O ;_dcf =len (_bdb );_dcf +=copy (_dgf [_dcf :],_gce );_afbf ,_baf =_ffc .alg2b (_bbb .R ,_dgf ,_bdb ,_ada );
if _baf !=nil {return _baf ;};_dcbb ,_baf :=_bff (_afbf [:32]);if _baf !=nil {return _baf ;};_ddc :=make ([]byte ,_gad .BlockSize );_fbc :=_g .NewCBCEncrypter (_dcbb ,_ddc );OE :=make ([]byte ,32);_fbc .CryptBlocks (OE ,_eeb [:32]);_bbb .OE =OE ;return nil ;
};

// NewHandlerR6 creates a new standard security handler for R=5 and R=6.
func NewHandlerR6 ()StdHandler {return stdHandlerR6 {}};func (_ec *ecbEncrypter )BlockSize ()int {return _ec ._ddf };func (_aef stdHandlerR6 )alg2a (_bcb *StdEncryptDict ,_ce []byte )([]byte ,Permissions ,error ){if _dec :=_ff ("\u0061\u006c\u00672\u0061","\u004f",48,_bcb .O );
_dec !=nil {return nil ,0,_dec ;};if _cbe :=_ff ("\u0061\u006c\u00672\u0061","\u0055",48,_bcb .U );_cbe !=nil {return nil ,0,_cbe ;};if len (_ce )> 127{_ce =_ce [:127];};_afb ,_bfc :=_aef .alg12 (_bcb ,_ce );if _bfc !=nil {return nil ,0,_bfc ;};var (_dab []byte ;
_afgb []byte ;_agd []byte ;);var _bbf Permissions ;if len (_afb )!=0{_bbf =PermOwner ;_fcf :=make ([]byte ,len (_ce )+8+48);_bea :=copy (_fcf ,_ce );_bea +=copy (_fcf [_bea :],_bcb .O [40:48]);copy (_fcf [_bea :],_bcb .U [0:48]);_dab =_fcf ;_afgb =_bcb .OE ;
_agd =_bcb .U [0:48];}else {_afb ,_bfc =_aef .alg11 (_bcb ,_ce );if _bfc ==nil &&len (_afb )==0{_afb ,_bfc =_aef .alg11 (_bcb ,[]byte (""));};if _bfc !=nil {return nil ,0,_bfc ;}else if len (_afb )==0{return nil ,0,nil ;};_bbf =_bcb .P ;_fa :=make ([]byte ,len (_ce )+8);
_ggg :=copy (_fa ,_ce );copy (_fa [_ggg :],_bcb .U [40:48]);_dab =_fa ;_afgb =_bcb .UE ;_agd =nil ;};if _bgf :=_ff ("\u0061\u006c\u00672\u0061","\u004b\u0065\u0079",32,_afgb );_bgf !=nil {return nil ,0,_bgf ;};_afgb =_afgb [:32];_dff ,_bfc :=_aef .alg2b (_bcb .R ,_dab ,_ce ,_agd );
if _bfc !=nil {return nil ,0,_bfc ;};_ffg ,_bfc :=_gad .NewCipher (_dff [:32]);if _bfc !=nil {return nil ,0,_bfc ;};_fd :=make ([]byte ,_gad .BlockSize );_agg :=_g .NewCBCDecrypter (_ffg ,_fd );_dddf :=make ([]byte ,32);_agg .CryptBlocks (_dddf ,_afgb );
if _bcb .R ==5{return _dddf ,_bbf ,nil ;};_bfc =_aef .alg13 (_bcb ,_dddf );if _bfc !=nil {return nil ,0,_bfc ;};return _dddf ,_bbf ,nil ;};type errInvalidField struct{Func string ;Field string ;Exp int ;Got int ;};func (_bgg stdHandlerR6 )alg2b (R int ,_abb ,_ee ,_ecf []byte )([]byte ,error ){if R ==5{return _gbb (_abb );
};return _bfd (_abb ,_ee ,_ecf );};

// StdHandler is an interface for standard security handlers.
type StdHandler interface{

// GenerateParams uses owner and user passwords to set encryption parameters and generate an encryption key.
// It assumes that R, P and EncryptMetadata are already set.
GenerateParams (_caa *StdEncryptDict ,_ge ,_bf []byte )([]byte ,error );

// Authenticate uses encryption dictionary parameters and the password to calculate
// the document encryption key. It also returns permissions that should be granted to a user.
// In case of failed authentication, it returns empty key and zero permissions with no error.
Authenticate (_caaa *StdEncryptDict ,_gca []byte )([]byte ,Permissions ,error );};

// StdEncryptDict is a set of additional fields used in standard encryption dictionary.
type StdEncryptDict struct{R int ;P Permissions ;EncryptMetadata bool ;O ,U []byte ;OE ,UE []byte ;Perms []byte ;};func (_abg stdHandlerR6 )alg8 (_egbd *StdEncryptDict ,_gggg []byte ,_ddfg []byte )error {if _gec :=_ff ("\u0061\u006c\u0067\u0038","\u004b\u0065\u0079",32,_gggg );
_gec !=nil {return _gec ;};var _cba [16]byte ;if _ ,_eab :=_cb .ReadFull (_eb .Reader ,_cba [:]);_eab !=nil {return _eab ;};_ggag :=_cba [0:8];_edd :=_cba [8:16];_gacg :=make ([]byte ,len (_ddfg )+len (_ggag ));_gdg :=copy (_gacg ,_ddfg );copy (_gacg [_gdg :],_ggag );
_gfc ,_dge :=_abg .alg2b (_egbd .R ,_gacg ,_ddfg ,nil );if _dge !=nil {return _dge ;};U :=make ([]byte ,len (_gfc )+len (_ggag )+len (_edd ));_gdg =copy (U ,_gfc [:32]);_gdg +=copy (U [_gdg :],_ggag );copy (U [_gdg :],_edd );_egbd .U =U ;_gdg =len (_ddfg );
copy (_gacg [_gdg :],_edd );_gfc ,_dge =_abg .alg2b (_egbd .R ,_gacg ,_ddfg ,nil );if _dge !=nil {return _dge ;};_cadc ,_dge :=_bff (_gfc [:32]);if _dge !=nil {return _dge ;};_bebb :=make ([]byte ,_gad .BlockSize );_cdg :=_g .NewCBCEncrypter (_cadc ,_bebb );
UE :=make ([]byte ,32);_cdg .CryptBlocks (UE ,_gggg [:32]);_egbd .UE =UE ;return nil ;};func _ddd (_gc _g .Block )_g .BlockMode {return (*ecbEncrypter )(_ebd (_gc ))};func (_gfe stdHandlerR6 )alg12 (_fcgf *StdEncryptDict ,_dfa []byte )([]byte ,error ){if _ccf :=_ff ("\u0061\u006c\u00671\u0032","\u0055",48,_fcgf .U );
_ccf !=nil {return nil ,_ccf ;};if _eea :=_ff ("\u0061\u006c\u00671\u0032","\u004f",48,_fcgf .O );_eea !=nil {return nil ,_eea ;};_fead :=make ([]byte ,len (_dfa )+8+48);_agc :=copy (_fead ,_dfa );_agc +=copy (_fead [_agc :],_fcgf .O [32:40]);_agc +=copy (_fead [_agc :],_fcgf .U [0:48]);
_fedg ,_aed :=_gfe .alg2b (_fcgf .R ,_fead ,_dfa ,_fcgf .U [0:48]);if _aed !=nil {return nil ,_aed ;};_fedg =_fedg [:32];if !_ca .Equal (_fedg ,_fcgf .O [:32]){return nil ,nil ;};return _fedg ,nil ;};

// Authenticate implements StdHandler interface.
func (_acg stdHandlerR4 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){_be .Log .Trace ("\u0044\u0065b\u0075\u0067\u0067\u0069n\u0067\u0020a\u0075\u0074\u0068\u0065\u006e\u0074\u0069\u0063a\u0074\u0069\u006f\u006e\u0020\u002d\u0020\u006f\u0077\u006e\u0065\u0072 \u0070\u0061\u0073\u0073");
_bad ,_gae :=_acg .alg7 (d ,pass );if _gae !=nil {return nil ,0,_gae ;};if _bad !=nil {_be .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _bad ,PermOwner ,nil ;
};_be .Log .Trace ("\u0044\u0065bu\u0067\u0067\u0069n\u0067\u0020\u0061\u0075the\u006eti\u0063\u0061\u0074\u0069\u006f\u006e\u0020- \u0075\u0073\u0065\u0072\u0020\u0070\u0061s\u0073");_bad ,_gae =_acg .alg6 (d ,pass );if _gae !=nil {return nil ,0,_gae ;
};if _bad !=nil {_be .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _bad ,d .P ,nil ;};return nil ,0,nil ;};const (PermOwner =Permissions (_dd .MaxUint32 );
PermPrinting =Permissions (1<<2);PermModify =Permissions (1<<3);PermExtractGraphics =Permissions (1<<4);PermAnnotate =Permissions (1<<5);PermFillForms =Permissions (1<<8);PermDisabilityExtract =Permissions (1<<9);PermRotateInsert =Permissions (1<<10);PermFullPrintQuality =Permissions (1<<11);
);

// Permissions is a bitmask of access permissions for a PDF file.
type Permissions uint32 ;const _dcb ="\x28\277\116\136\x4e\x75\x8a\x41\x64\000\x4e\x56\377"+"\xfa\001\010\056\x2e\x00\xb6\xd0\x68\076\x80\x2f\014"+"\251\xfe\x64\x53\x69\172";func _bfd (_gac ,_cf ,_ddff []byte )([]byte ,error ){var (_fb ,_egb ,_begf _b .Hash ;
);_fb =_ga .New ();_fegg :=make ([]byte ,64);_ced :=_fb ;_ced .Write (_gac );K :=_ced .Sum (_fegg [:0]);_cge :=make ([]byte ,64*(127+64+48));_cca :=func (_afcc int )([]byte ,error ){_edc :=len (_cf )+len (K )+len (_ddff );_fgf :=_cge [:_edc ];_abc :=copy (_fgf ,_cf );
_abc +=copy (_fgf [_abc :],K [:]);_abc +=copy (_fgf [_abc :],_ddff );if _abc !=_edc {_be .Log .Error ("E\u0052\u0052\u004f\u0052\u003a\u0020u\u006e\u0065\u0078\u0070\u0065\u0063t\u0065\u0064\u0020\u0072\u006f\u0075\u006ed\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0073\u0069\u007ae\u002e");
return nil ,_d .New ("\u0077\u0072\u006f\u006e\u0067\u0020\u0073\u0069\u007a\u0065");};K1 :=_cge [:_edc *64];_eac (K1 ,_edc );_edf ,_bbff :=_bff (K [0:16]);if _bbff !=nil {return nil ,_bbff ;};_dbg :=_g .NewCBCEncrypter (_edf ,K [16:32]);_dbg .CryptBlocks (K1 ,K1 );
E :=K1 ;_bfcb :=0;for _bgfg :=0;_bgfg < 16;_bgfg ++{_bfcb +=int (E [_bgfg ]%3);};var _gbf _b .Hash ;switch _bfcb %3{case 0:_gbf =_fb ;case 1:if _egb ==nil {_egb =_a .New384 ();};_gbf =_egb ;case 2:if _begf ==nil {_begf =_a .New ();};_gbf =_begf ;};_gbf .Reset ();
_gbf .Write (E );K =_gbf .Sum (_fegg [:0]);return E ,nil ;};for _bgfc :=0;;{E ,_fff :=_cca (_bgfc );if _fff !=nil {return nil ,_fff ;};_dgb :=E [len (E )-1];_bgfc ++;if _bgfc >=64&&_dgb <=uint8 (_bgfc -32){break ;};};return K [:32],nil ;};const (EventDocOpen =AuthEvent ("\u0044o\u0063\u004f\u0070\u0065\u006e");
EventEFOpen =AuthEvent ("\u0045\u0046\u004f\u0070\u0065\u006e"););func (_df *ecbDecrypter )BlockSize ()int {return _df ._ddf };func (_acgd stdHandlerR6 )alg13 (_aeb *StdEncryptDict ,_adbd []byte )error {if _cgb :=_ff ("\u0061\u006c\u00671\u0033","\u004b\u0065\u0079",32,_adbd );
_cgb !=nil {return _cgb ;};if _cdf :=_ff ("\u0061\u006c\u00671\u0033","\u0050\u0065\u0072m\u0073",16,_aeb .Perms );_cdf !=nil {return _cdf ;};_baa :=make ([]byte ,16);copy (_baa ,_aeb .Perms [:16]);_edfg ,_dcgf :=_gad .NewCipher (_adbd [:32]);if _dcgf !=nil {return _dcgf ;
};_efb :=_bb (_edfg );_efb .CryptBlocks (_baa ,_baa );if !_ca .Equal (_baa [9:12],[]byte ("\u0061\u0064\u0062")){return _d .New ("\u0064\u0065\u0063o\u0064\u0065\u0064\u0020p\u0065\u0072\u006d\u0069\u0073\u0073\u0069o\u006e\u0073\u0020\u0061\u0072\u0065\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};_dde :=Permissions (_e .LittleEndian .Uint32 (_baa [0:4]));if _dde !=_aeb .P {return _d .New ("\u0070\u0065r\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066\u0061il\u0065\u0064");
};var _faa bool ;if _baa [8]=='T'{_faa =true ;}else if _baa [8]=='F'{_faa =false ;}else {return _d .New ("\u0064\u0065\u0063\u006f\u0064\u0065\u0064 \u006d\u0065\u0074a\u0064\u0061\u0074\u0061 \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u006c\u0061\u0067\u0020\u0069\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};if _faa !=_aeb .EncryptMetadata {return _d .New ("\u006d\u0065t\u0061\u0064\u0061\u0074a\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e \u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066a\u0069\u006c\u0065\u0064");
};return nil ;};func (_fea stdHandlerR4 )alg6 (_ggd *StdEncryptDict ,_fg []byte )([]byte ,error ){var (_bfg []byte ;_bbeg error ;);_ege :=_fea .alg2 (_ggd ,_fg );if _ggd .R ==2{_bfg ,_bbeg =_fea .alg4 (_ege ,_fg );}else if _ggd .R >=3{_bfg ,_bbeg =_fea .alg5 (_ege ,_fg );
}else {return nil ,_d .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};if _bbeg !=nil {return nil ,_bbeg ;};_be .Log .Trace ("\u0063\u0068\u0065\u0063k:\u0020\u0025\u0020\u0078\u0020\u003d\u003d\u0020\u0025\u0020\u0078\u0020\u003f",string (_bfg ),string (_ggd .U ));
_dbf :=_bfg ;_ad :=_ggd .U ;if _ggd .R >=3{if len (_dbf )> 16{_dbf =_dbf [0:16];};if len (_ad )> 16{_ad =_ad [0:16];};};if !_ca .Equal (_dbf ,_ad ){return nil ,nil ;};return _ege ,nil ;};

// NewHandlerR4 creates a new standard security handler for R<=4.
func NewHandlerR4 (id0 string ,length int )StdHandler {return stdHandlerR4 {ID0 :id0 ,Length :length }};

// AuthEvent is an event type that triggers authentication.
type AuthEvent string ;func (_gcae stdHandlerR4 )alg4 (_ede []byte ,_gba []byte )([]byte ,error ){_aaa ,_cd :=_f .NewCipher (_ede );if _cd !=nil {return nil ,_d .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};
_dcg :=[]byte (_dcb );_afa :=make ([]byte ,len (_dcg ));_aaa .XORKeyStream (_afa ,_dcg );return _afa ,nil ;};func _ebd (_dc _g .Block )*ecb {return &ecb {_ef :_dc ,_ddf :_dc .BlockSize ()}};

// GenerateParams generates and sets O and U parameters for the encryption dictionary.
// It expects R, P and EncryptMetadata fields to be set.
func (_abd stdHandlerR4 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){O ,_efaa :=_abd .alg3 (d .R ,upass ,opass );if _efaa !=nil {_be .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_efaa );
return nil ,_efaa ;};d .O =O ;_be .Log .Trace ("\u0067\u0065\u006e\u0020\u004f\u003a\u0020\u0025\u0020\u0078",O );_fcg :=_abd .alg2 (d ,upass );U ,_efaa :=_abd .alg5 (_fcg ,upass );if _efaa !=nil {_be .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_efaa );
return nil ,_efaa ;};d .U =U ;_be .Log .Trace ("\u0067\u0065\u006e\u0020\u0055\u003a\u0020\u0025\u0020\u0078",U );return _fcg ,nil ;};func _ff (_ed ,_aa string ,_ddda int ,_ffd []byte )error {if len (_ffd )< _ddda {return errInvalidField {Func :_ed ,Field :_aa ,Exp :_ddda ,Got :len (_ffd )};
};return nil ;};func (_ccg stdHandlerR4 )alg7 (_ebbf *StdEncryptDict ,_cg []byte )([]byte ,error ){_eff :=_ccg .alg3Key (_ebbf .R ,_cg );_cgf :=make ([]byte ,len (_ebbf .O ));if _ebbf .R ==2{_ac ,_cdd :=_f .NewCipher (_eff );if _cdd !=nil {return nil ,_d .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");
};_ac .XORKeyStream (_cgf ,_ebbf .O );}else if _ebbf .R >=3{_efa :=append ([]byte {},_ebbf .O ...);for _gfa :=0;_gfa < 20;_gfa ++{_gadg :=append ([]byte {},_eff ...);for _acb :=0;_acb < len (_eff );_acb ++{_gadg [_acb ]^=byte (19-_gfa );};_ece ,_def :=_f .NewCipher (_gadg );
if _def !=nil {return nil ,_d .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_ece .XORKeyStream (_cgf ,_efa );_efa =append ([]byte {},_cgf ...);};}else {return nil ,_d .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");
};_beg ,_fed :=_ccg .alg6 (_ebbf ,_cgf );if _fed !=nil {return nil ,nil ;};return _beg ,nil ;};

// Allowed checks if a set of permissions can be granted.
func (_gf Permissions )Allowed (p2 Permissions )bool {return _gf &p2 ==p2 };var _ StdHandler =stdHandlerR4 {};