//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package security ;import (_ba "bytes";_bf "crypto/aes";_g "crypto/cipher";_ff "crypto/md5";_ee "crypto/rand";_fa "crypto/rc4";_ed "crypto/sha256";_b "crypto/sha512";_gf "encoding/binary";_f "errors";_da "fmt";_gc "github.com/unidoc/unipdf/v3/common";_dc "hash";_e "io";_dcf "math";);const _eae ="\x28\277\116\136\x4e\x75\x8a\x41\x64\000\x4e\x56\377"+"\xfa\001\010\056\x2e\x00\xb6\xd0\x68\076\x80\x2f\014"+"\251\xfe\x64\x53\x69\172";func (_gcg stdHandlerR4 )alg5 (_fga []byte ,_bg []byte )([]byte ,error ){_gebg :=_ff .New ();_gebg .Write ([]byte (_eae ));_gebg .Write ([]byte (_gcg .ID0 ));_cgf :=_gebg .Sum (nil );_gc .Log .Trace ("\u0061\u006c\u0067\u0035");_gc .Log .Trace ("\u0065k\u0065\u0079\u003a\u0020\u0025\u0020x",_fga );_gc .Log .Trace ("\u0049D\u003a\u0020\u0025\u0020\u0078",_gcg .ID0 );if len (_cgf )!=16{return nil ,_f .New ("\u0068a\u0073\u0068\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074\u0020\u0031\u0036\u0020\u0062\u0079\u0074\u0065\u0073");};_eaee ,_cb :=_fa .NewCipher (_fga );if _cb !=nil {return nil ,_f .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_ddd :=make ([]byte ,16);_eaee .XORKeyStream (_ddd ,_cgf );_feg :=make ([]byte ,len (_fga ));for _ab :=0;_ab < 19;_ab ++{for _cd :=0;_cd < len (_fga );_cd ++{_feg [_cd ]=_fga [_cd ]^byte (_ab +1);};_eaee ,_cb =_fa .NewCipher (_feg );if _cb !=nil {return nil ,_f .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_eaee .XORKeyStream (_ddd ,_ddd );_gc .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u002c\u0020\u0065\u006b\u0065\u0079:\u0020\u0025\u0020\u0078",_ab ,_feg );_gc .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0020\u0078",_ab ,_ddd );};_eccf :=make ([]byte ,32);for _fgg :=0;_fgg < 16;_fgg ++{_eccf [_fgg ]=_ddd [_fgg ];};_ ,_cb =_ee .Read (_eccf [16:32]);if _cb !=nil {return nil ,_f .New ("\u0066a\u0069\u006c\u0065\u0064 \u0074\u006f\u0020\u0067\u0065n\u0020r\u0061n\u0064\u0020\u006e\u0075\u006d\u0062\u0065r");};return _eccf ,nil ;};

// AuthEvent is an event type that triggers authentication.
type AuthEvent string ;func (stdHandlerR4 )paddedPass (_eb []byte )[]byte {_be :=make ([]byte ,32);_de :=copy (_be ,_eb );for ;_de < 32;_de ++{_be [_de ]=_eae [_de -len (_eb )];};return _be ;};func _fgf (_dfgd []byte )([]byte ,error ){_cfbe :=_ed .New ();_cfbe .Write (_dfgd );return _cfbe .Sum (nil ),nil ;};type ecbDecrypter ecb ;func (_cc stdHandlerR4 )alg3Key (R int ,_ffd []byte )[]byte {_dff :=_ff .New ();_eeg :=_cc .paddedPass (_ffd );_dff .Write (_eeg );if R >=3{for _geb :=0;_geb < 50;_geb ++{_bc :=_dff .Sum (nil );_dff =_ff .New ();_dff .Write (_bc );};};_fbg :=_dff .Sum (nil );if R ==2{_fbg =_fbg [0:5];}else {_fbg =_fbg [0:_cc .Length /8];};return _fbg ;};func _gaf (_dfg []byte )(_g .Block ,error ){_dcg ,_bbe :=_bf .NewCipher (_dfg );if _bbe !=nil {_gc .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0063\u0072\u0065\u0061\u0074\u0065\u0020A\u0045\u0053\u0020\u0063\u0069p\u0068\u0065r\u003a\u0020\u0025\u0076",_bbe );return nil ,_bbe ;};return _dcg ,nil ;};func (_gfg stdHandlerR4 )alg3 (R int ,_fgb ,_fcg []byte )([]byte ,error ){var _dfb []byte ;if len (_fcg )> 0{_dfb =_gfg .alg3Key (R ,_fcg );}else {_dfb =_gfg .alg3Key (R ,_fgb );};_faa ,_ecg :=_fa .NewCipher (_dfb );if _ecg !=nil {return nil ,_f .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_gbf :=_gfg .paddedPass (_fgb );_bd :=make ([]byte ,len (_gbf ));_faa .XORKeyStream (_bd ,_gbf );if R >=3{_cg :=make ([]byte ,len (_dfb ));for _gcf :=0;_gcf < 19;_gcf ++{for _deb :=0;_deb < len (_dfb );_deb ++{_cg [_deb ]=_dfb [_deb ]^byte (_gcf +1);};_baf ,_db :=_fa .NewCipher (_cg );if _db !=nil {return nil ,_f .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_baf .XORKeyStream (_bd ,_bd );};};return _bd ,nil ;};

// NewHandlerR4 creates a new standard security handler for R<=4.
func NewHandlerR4 (id0 string ,length int )StdHandler {return stdHandlerR4 {ID0 :id0 ,Length :length }};type errInvalidField struct{Func string ;Field string ;Exp int ;Got int ;};func (_edd *ecbDecrypter )BlockSize ()int {return _edd ._c };func _agc (_dge ,_dbg ,_begg []byte )([]byte ,error ){var (_ecf ,_eec ,_ecb _dc .Hash ;);_ecf =_ed .New ();_bce :=make ([]byte ,64);_gbg :=_ecf ;_gbg .Write (_dge );K :=_gbg .Sum (_bce [:0]);_gac :=make ([]byte ,64*(127+64+48));_bcg :=func (_fcd int )([]byte ,error ){_aea :=len (_dbg )+len (K )+len (_begg );_bdc :=_gac [:_aea ];_egf :=copy (_bdc ,_dbg );_egf +=copy (_bdc [_egf :],K [:]);_egf +=copy (_bdc [_egf :],_begg );if _egf !=_aea {_gc .Log .Error ("E\u0052\u0052\u004f\u0052\u003a\u0020u\u006e\u0065\u0078\u0070\u0065\u0063t\u0065\u0064\u0020\u0072\u006f\u0075\u006ed\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0073\u0069\u007ae\u002e");return nil ,_f .New ("\u0077\u0072\u006f\u006e\u0067\u0020\u0073\u0069\u007a\u0065");};K1 :=_gac [:_aea *64];_egd (K1 ,_aea );_ebaf ,_bfd :=_gaf (K [0:16]);if _bfd !=nil {return nil ,_bfd ;};_gacc :=_g .NewCBCEncrypter (_ebaf ,K [16:32]);_gacc .CryptBlocks (K1 ,K1 );E :=K1 ;_aac :=0;for _eeb :=0;_eeb < 16;_eeb ++{_aac +=int (E [_eeb ]%3);};var _ca _dc .Hash ;switch _aac %3{case 0:_ca =_ecf ;case 1:if _eec ==nil {_eec =_b .New384 ();};_ca =_eec ;case 2:if _ecb ==nil {_ecb =_b .New ();};_ca =_ecb ;};_ca .Reset ();_ca .Write (E );K =_ca .Sum (_bce [:0]);return E ,nil ;};for _cce :=0;;{E ,_gcd :=_bcg (_cce );if _gcd !=nil {return nil ,_gcd ;};_daee :=uint8 (E [len (E )-1]);_cce ++;if _cce >=64&&_daee <=uint8 (_cce -32){break ;};};return K [:32],nil ;};const (EventDocOpen =AuthEvent ("\u0044o\u0063\u004f\u0070\u0065\u006e");EventEFOpen =AuthEvent ("\u0045\u0046\u004f\u0070\u0065\u006e"););

// Authenticate implements StdHandler interface.
func (_gfd stdHandlerR4 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){_gc .Log .Trace ("\u0044\u0065b\u0075\u0067\u0067\u0069n\u0067\u0020a\u0075\u0074\u0068\u0065\u006e\u0074\u0069\u0063a\u0074\u0069\u006f\u006e\u0020\u002d\u0020\u006f\u0077\u006e\u0065\u0072 \u0070\u0061\u0073\u0073");_gfe ,_bdf :=_gfd .alg7 (d ,pass );if _bdf !=nil {return nil ,0,_bdf ;};if _gfe !=nil {_gc .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _gfe ,PermOwner ,nil ;};_gc .Log .Trace ("\u0044\u0065bu\u0067\u0067\u0069n\u0067\u0020\u0061\u0075the\u006eti\u0063\u0061\u0074\u0069\u006f\u006e\u0020- \u0075\u0073\u0065\u0072\u0020\u0070\u0061s\u0073");_gfe ,_bdf =_gfd .alg6 (d ,pass );if _bdf !=nil {return nil ,0,_bdf ;};if _gfe !=nil {_gc .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _gfe ,d .P ,nil ;};return nil ,0,nil ;};func (_bdb stdHandlerR6 )alg10 (_fab *StdEncryptDict ,_egdg []byte )error {if _dcc :=_dd ("\u0061\u006c\u00671\u0030","\u004b\u0065\u0079",32,_egdg );_dcc !=nil {return _dcc ;};_ffe :=uint64 (uint32 (_fab .P ))|(_dcf .MaxUint32 <<32);Perms :=make ([]byte ,16);_gf .LittleEndian .PutUint64 (Perms [:8],_ffe );if _fab .EncryptMetadata {Perms [8]='T';}else {Perms [8]='F';};copy (Perms [9:12],"\u0061\u0064\u0062");if _ ,_eedg :=_e .ReadFull (_ee .Reader ,Perms [12:16]);_eedg !=nil {return _eedg ;};_fd ,_bgc :=_gaf (_egdg [:32]);if _bgc !=nil {return _bgc ;};_dbb :=_ec (_fd );_dbb .CryptBlocks (Perms ,Perms );_fab .Perms =Perms [:16];return nil ;};type stdHandlerR6 struct{};const (PermOwner =Permissions (_dcf .MaxUint32 );PermPrinting =Permissions (1<<2);PermModify =Permissions (1<<3);PermExtractGraphics =Permissions (1<<4);PermAnnotate =Permissions (1<<5);PermFillForms =Permissions (1<<8);PermDisabilityExtract =Permissions (1<<9);PermRotateInsert =Permissions (1<<10);PermFullPrintQuality =Permissions (1<<11););type ecb struct{_eef _g .Block ;_c int ;};var _ StdHandler =stdHandlerR4 {};func (_eff stdHandlerR6 )alg8 (_dbfe *StdEncryptDict ,_cbc []byte ,_fag []byte )error {if _fgge :=_dd ("\u0061\u006c\u0067\u0038","\u004b\u0065\u0079",32,_cbc );_fgge !=nil {return _fgge ;};var _dgf [16]byte ;if _ ,_cfg :=_e .ReadFull (_ee .Reader ,_dgf [:]);_cfg !=nil {return _cfg ;};_dffe :=_dgf [0:8];_fffc :=_dgf [8:16];_ce :=make ([]byte ,len (_fag )+len (_dffe ));_fee :=copy (_ce ,_fag );_fee +=copy (_ce [_fee :],_dffe );_bfa ,_bcea :=_eff .alg2b (_dbfe .R ,_ce ,_fag ,nil );if _bcea !=nil {return _bcea ;};U :=make ([]byte ,len (_bfa )+len (_dffe )+len (_fffc ));_fee =copy (U ,_bfa [:32]);_fee +=copy (U [_fee :],_dffe );_fee +=copy (U [_fee :],_fffc );_dbfe .U =U ;_fee =len (_fag );_fee +=copy (_ce [_fee :],_fffc );_bfa ,_bcea =_eff .alg2b (_dbfe .R ,_ce ,_fag ,nil );if _bcea !=nil {return _bcea ;};_cdc ,_bcea :=_gaf (_bfa [:32]);if _bcea !=nil {return _bcea ;};_ebc :=make ([]byte ,_bf .BlockSize );_gbe :=_g .NewCBCEncrypter (_cdc ,_ebc );UE :=make ([]byte ,32);_gbe .CryptBlocks (UE ,_cbc [:32]);_dbfe .UE =UE ;return nil ;};func (_ag stdHandlerR6 )alg2a (_efa *StdEncryptDict ,_cgc []byte )([]byte ,Permissions ,error ){if _dac :=_dd ("\u0061\u006c\u00672\u0061","\u004f",48,_efa .O );_dac !=nil {return nil ,0,_dac ;};if _aae :=_dd ("\u0061\u006c\u00672\u0061","\u0055",48,_efa .U );_aae !=nil {return nil ,0,_aae ;};if len (_cgc )> 127{_cgc =_cgc [:127];};_dgg ,_efaf :=_ag .alg12 (_efa ,_cgc );if _efaf !=nil {return nil ,0,_efaf ;};var (_cfd []byte ;_dacd []byte ;_fce []byte ;);var _bff Permissions ;if len (_dgg )!=0{_bff =PermOwner ;_dea :=make ([]byte ,len (_cgc )+8+48);_aca :=copy (_dea ,_cgc );_aca +=copy (_dea [_aca :],_efa .O [40:48]);_aca +=copy (_dea [_aca :],_efa .U [0:48]);_cfd =_dea ;_dacd =_efa .OE ;_fce =_efa .U [0:48];}else {_dgg ,_efaf =_ag .alg11 (_efa ,_cgc );if _efaf ==nil &&len (_dgg )==0{_dgg ,_efaf =_ag .alg11 (_efa ,[]byte (""));};if _efaf !=nil {return nil ,0,_efaf ;}else if len (_dgg )==0{return nil ,0,nil ;};_bff =_efa .P ;_bec :=make ([]byte ,len (_cgc )+8);_gag :=copy (_bec ,_cgc );_gag +=copy (_bec [_gag :],_efa .U [40:48]);_cfd =_bec ;_dacd =_efa .UE ;_fce =nil ;};if _cfb :=_dd ("\u0061\u006c\u00672\u0061","\u004b\u0065\u0079",32,_dacd );_cfb !=nil {return nil ,0,_cfb ;};_dacd =_dacd [:32];_bag ,_efaf :=_ag .alg2b (_efa .R ,_cfd ,_cgc ,_fce );if _efaf !=nil {return nil ,0,_efaf ;};_dbf ,_efaf :=_bf .NewCipher (_bag [:32]);if _efaf !=nil {return nil ,0,_efaf ;};_fbc :=make ([]byte ,_bf .BlockSize );_efb :=_g .NewCBCDecrypter (_dbf ,_fbc );_afb :=make ([]byte ,32);_efb .CryptBlocks (_afb ,_dacd );if _efa .R ==5{return _afb ,_bff ,nil ;};_efaf =_ag .alg13 (_efa ,_afb );if _efaf !=nil {return nil ,0,_efaf ;};return _afb ,_bff ,nil ;};

// StdEncryptDict is a set of additional fields used in standard encryption dictionary.
type StdEncryptDict struct{R int ;P Permissions ;EncryptMetadata bool ;O ,U []byte ;OE ,UE []byte ;Perms []byte ;};

// StdHandler is an interface for standard security handlers.
type StdHandler interface{

// GenerateParams uses owner and user passwords to set encryption parameters and generate an encryption key.
// It assumes that R, P and EncryptMetadata are already set.
GenerateParams (_ge *StdEncryptDict ,_gb ,_af []byte )([]byte ,error );

// Authenticate uses encryption dictionary parameters and the password to calculate
// the document encryption key. It also returns permissions that should be granted to a user.
// In case of failed authentication, it returns empty key and zero permissions with no error.
Authenticate (_eed *StdEncryptDict ,_fb []byte )([]byte ,Permissions ,error );};

// GenerateParams generates and sets O and U parameters for the encryption dictionary.
// It expects R, P and EncryptMetadata fields to be set.
func (_fae stdHandlerR4 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){O ,_fff :=_fae .alg3 (d .R ,upass ,opass );if _fff !=nil {_gc .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_fff );return nil ,_fff ;};d .O =O ;_gc .Log .Trace ("\u0067\u0065\u006e\u0020\u004f\u003a\u0020\u0025\u0020\u0078",O );_eaa :=_fae .alg2 (d ,upass );U ,_fff :=_fae .alg5 (_eaa ,upass );if _fff !=nil {_gc .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_fff );return nil ,_fff ;};d .U =U ;_gc .Log .Trace ("\u0067\u0065\u006e\u0020\u0055\u003a\u0020\u0025\u0020\u0078",U );return _eaa ,nil ;};func (_afag stdHandlerR6 )alg9 (_cab *StdEncryptDict ,_dce []byte ,_ecd []byte )error {if _cbd :=_dd ("\u0061\u006c\u0067\u0039","\u004b\u0065\u0079",32,_dce );_cbd !=nil {return _cbd ;};if _dceb :=_dd ("\u0061\u006c\u0067\u0039","\u0055",48,_cab .U );_dceb !=nil {return _dceb ;};var _ffg [16]byte ;if _ ,_egg :=_e .ReadFull (_ee .Reader ,_ffg [:]);_egg !=nil {return _egg ;};_def :=_ffg [0:8];_dbgf :=_ffg [8:16];_ggf :=_cab .U [:48];_aed :=make ([]byte ,len (_ecd )+len (_def )+len (_ggf ));_dda :=copy (_aed ,_ecd );_dda +=copy (_aed [_dda :],_def );_dda +=copy (_aed [_dda :],_ggf );_gea ,_aded :=_afag .alg2b (_cab .R ,_aed ,_ecd ,_ggf );if _aded !=nil {return _aded ;};O :=make ([]byte ,len (_gea )+len (_def )+len (_dbgf ));_dda =copy (O ,_gea [:32]);_dda +=copy (O [_dda :],_def );_dda +=copy (O [_dda :],_dbgf );_cab .O =O ;_dda =len (_ecd );_dda +=copy (_aed [_dda :],_dbgf );_gea ,_aded =_afag .alg2b (_cab .R ,_aed ,_ecd ,_ggf );if _aded !=nil {return _aded ;};_ged ,_aded :=_gaf (_gea [:32]);if _aded !=nil {return _aded ;};_begf :=make ([]byte ,_bf .BlockSize );_dgfc :=_g .NewCBCEncrypter (_ged ,_begf );OE :=make ([]byte ,32);_dgfc .CryptBlocks (OE ,_dce [:32]);_cab .OE =OE ;return nil ;};type stdHandlerR4 struct{Length int ;ID0 string ;};func _egd (_gbff []byte ,_bfcb int ){_dae :=_bfcb ;for _dae < len (_gbff ){copy (_gbff [_dae :],_gbff [:_dae ]);_dae *=2;};};func (_eaeg stdHandlerR4 )alg6 (_bae *StdEncryptDict ,_ac []byte )([]byte ,error ){var (_cgfa []byte ;_adg error ;);_gec :=_eaeg .alg2 (_bae ,_ac );if _bae .R ==2{_cgfa ,_adg =_eaeg .alg4 (_gec ,_ac );}else if _bae .R >=3{_cgfa ,_adg =_eaeg .alg5 (_gec ,_ac );}else {return nil ,_f .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};if _adg !=nil {return nil ,_adg ;};_gc .Log .Trace ("\u0063\u0068\u0065\u0063k:\u0020\u0025\u0020\u0078\u0020\u003d\u003d\u0020\u0025\u0020\u0078\u0020\u003f",string (_cgfa ),string (_bae .U ));_bgb :=_cgfa ;_bea :=_bae .U ;if _bae .R >=3{if len (_bgb )> 16{_bgb =_bgb [0:16];};if len (_bea )> 16{_bea =_bea [0:16];};};if !_ba .Equal (_bgb ,_bea ){return nil ,nil ;};return _gec ,nil ;};func (_bb stdHandlerR4 )alg4 (_ebg []byte ,_efd []byte )([]byte ,error ){_gde ,_fe :=_fa .NewCipher (_ebg );if _fe !=nil {return nil ,_f .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_adf :=[]byte (_eae );_gca :=make ([]byte ,len (_adf ));_gde .XORKeyStream (_gca ,_adf );return _gca ,nil ;};var _ StdHandler =stdHandlerR6 {};func (_debf stdHandlerR6 )alg2b (R int ,_cag ,_bceg ,_ffad []byte )([]byte ,error ){if R ==5{return _fgf (_cag );};return _agc (_cag ,_bceg ,_ffad );};func _cf (_ea _g .Block )_g .BlockMode {return (*ecbDecrypter )(_a (_ea ))};func (_cfe stdHandlerR6 )alg11 (_geg *StdEncryptDict ,_faag []byte )([]byte ,error ){if _debb :=_dd ("\u0061\u006c\u00671\u0031","\u0055",48,_geg .U );_debb !=nil {return nil ,_debb ;};_eag :=make ([]byte ,len (_faag )+8);_deff :=copy (_eag ,_faag );_deff +=copy (_eag [_deff :],_geg .U [32:40]);_dceba ,_fffcd :=_cfe .alg2b (_geg .R ,_eag ,_faag ,nil );if _fffcd !=nil {return nil ,_fffcd ;};_dceba =_dceba [:32];if !_ba .Equal (_dceba ,_geg .U [:32]){return nil ,nil ;};return _dceba ,nil ;};type ecbEncrypter ecb ;func (_fcf errInvalidField )Error ()string {return _da .Sprintf ("\u0025s\u003a\u0020e\u0078\u0070\u0065\u0063t\u0065\u0064\u0020%\u0073\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0074o \u0062\u0065\u0020%\u0064\u0020b\u0079\u0074\u0065\u0073\u002c\u0020g\u006f\u0074 \u0025\u0064",_fcf .Func ,_fcf .Field ,_fcf .Exp ,_fcf .Got );};func (_ecc *ecbDecrypter )CryptBlocks (dst ,src []byte ){if len (src )%_ecc ._c !=0{_gc .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");return ;};if len (dst )< len (src ){_gc .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0064\u0065\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");return ;};for len (src )> 0{_ecc ._eef .Decrypt (dst ,src [:_ecc ._c ]);src =src [_ecc ._c :];dst =dst [_ecc ._c :];};};func (_deg stdHandlerR6 )alg13 (_efe *StdEncryptDict ,_egb []byte )error {if _add :=_dd ("\u0061\u006c\u00671\u0033","\u004b\u0065\u0079",32,_egb );_add !=nil {return _add ;};if _acb :=_dd ("\u0061\u006c\u00671\u0033","\u0050\u0065\u0072m\u0073",16,_efe .Perms );_acb !=nil {return _acb ;};_bef :=make ([]byte ,16);copy (_bef ,_efe .Perms [:16]);_cagb ,_dcaf :=_bf .NewCipher (_egb [:32]);if _dcaf !=nil {return _dcaf ;};_cabb :=_cf (_cagb );_cabb .CryptBlocks (_bef ,_bef );if !_ba .Equal (_bef [9:12],[]byte ("\u0061\u0064\u0062")){return _f .New ("\u0064\u0065\u0063o\u0064\u0065\u0064\u0020p\u0065\u0072\u006d\u0069\u0073\u0073\u0069o\u006e\u0073\u0020\u0061\u0072\u0065\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_fec :=Permissions (_gf .LittleEndian .Uint32 (_bef [0:4]));if _fec !=_efe .P {return _f .New ("\u0070\u0065r\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066\u0061il\u0065\u0064");};_cagbf :=true ;if _bef [8]=='T'{_cagbf =true ;}else if _bef [8]=='F'{_cagbf =false ;}else {return _f .New ("\u0064\u0065\u0063\u006f\u0064\u0065\u0064 \u006d\u0065\u0074a\u0064\u0061\u0074\u0061 \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u006c\u0061\u0067\u0020\u0069\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};if _cagbf !=_efe .EncryptMetadata {return _f .New ("\u006d\u0065t\u0061\u0064\u0061\u0074a\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e \u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066a\u0069\u006c\u0065\u0064");};return nil ;};func _ec (_fg _g .Block )_g .BlockMode {return (*ecbEncrypter )(_a (_fg ))};

// Authenticate implements StdHandler interface.
func (_bcd stdHandlerR6 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){return _bcd .alg2a (d ,pass );};func _a (_dg _g .Block )*ecb {return &ecb {_eef :_dg ,_c :_dg .BlockSize ()}};func (_ga *ecbEncrypter )CryptBlocks (dst ,src []byte ){if len (src )%_ga ._c !=0{_gc .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");return ;};if len (dst )< len (src ){_gc .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");return ;};for len (src )> 0{_ga ._eef .Encrypt (dst ,src [:_ga ._c ]);src =src [_ga ._c :];dst =dst [_ga ._c :];};};func (_bcf stdHandlerR6 )alg12 (_gfbb *StdEncryptDict ,_baa []byte )([]byte ,error ){if _ccd :=_dd ("\u0061\u006c\u00671\u0032","\u0055",48,_gfbb .U );_ccd !=nil {return nil ,_ccd ;};if _dbc :=_dd ("\u0061\u006c\u00671\u0032","\u004f",48,_gfbb .O );_dbc !=nil {return nil ,_dbc ;};_abf :=make ([]byte ,len (_baa )+8+48);_cbg :=copy (_abf ,_baa );_cbg +=copy (_abf [_cbg :],_gfbb .O [32:40]);_cbg +=copy (_abf [_cbg :],_gfbb .U [0:48]);_gcaf ,_bac :=_bcf .alg2b (_gfbb .R ,_abf ,_baa ,_gfbb .U [0:48]);if _bac !=nil {return nil ,_bac ;};_gcaf =_gcaf [:32];if !_ba .Equal (_gcaf ,_gfbb .O [:32]){return nil ,nil ;};return _gcaf ,nil ;};

// Permissions is a bitmask of access permissions for a PDF file.
type Permissions uint32 ;

// NewHandlerR6 creates a new standard security handler for R=5 and R=6.
func NewHandlerR6 ()StdHandler {return stdHandlerR6 {}};func (_fc *ecbEncrypter )BlockSize ()int {return _fc ._c };func (_afg stdHandlerR4 )alg7 (_beg *StdEncryptDict ,_afa []byte )([]byte ,error ){_gae :=_afg .alg3Key (_beg .R ,_afa );_dca :=make ([]byte ,len (_beg .O ));if _beg .R ==2{_gfb ,_afc :=_fa .NewCipher (_gae );if _afc !=nil {return nil ,_f .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_gfb .XORKeyStream (_dca ,_beg .O );}else if _beg .R >=3{_abb :=append ([]byte {},_beg .O ...);for _acg :=0;_acg < 20;_acg ++{_edg :=append ([]byte {},_gae ...);for _dag :=0;_dag < len (_gae );_dag ++{_edg [_dag ]^=byte (19-_acg );};_eba ,_geef :=_fa .NewCipher (_edg );if _geef !=nil {return nil ,_f .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_eba .XORKeyStream (_dca ,_abb );_abb =append ([]byte {},_dca ...);};}else {return nil ,_f .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};_bfc ,_fega :=_afg .alg6 (_beg ,_dca );if _fega !=nil {return nil ,nil ;};return _bfc ,nil ;};func _dd (_bab ,_gee string ,_ffa int ,_gd []byte )error {if len (_gd )< _ffa {return errInvalidField {Func :_bab ,Field :_gee ,Exp :_ffa ,Got :len (_gd )};};return nil ;};

// GenerateParams is the algorithm opposite to alg2a (R>=5).
// It generates U,O,UE,OE,Perms fields using AESv3 encryption.
// There is no algorithm number assigned to this function in the spec.
// It expects R, P and EncryptMetadata fields to be set.
func (_fdd stdHandlerR6 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){_ece :=make ([]byte ,32);if _ ,_cde :=_e .ReadFull (_ee .Reader ,_ece );_cde !=nil {return nil ,_cde ;};d .U =nil ;d .O =nil ;d .UE =nil ;d .OE =nil ;d .Perms =nil ;if len (upass )> 127{upass =upass [:127];};if len (opass )> 127{opass =opass [:127];};if _cced :=_fdd .alg8 (d ,_ece ,upass );_cced !=nil {return nil ,_cced ;};if _acd :=_fdd .alg9 (d ,_ece ,opass );_acd !=nil {return nil ,_acd ;};if d .R ==5{return _ece ,nil ;};if _bfb :=_fdd .alg10 (d ,_ece );_bfb !=nil {return nil ,_bfb ;};return _ece ,nil ;};func (_gg stdHandlerR4 )alg2 (_ad *StdEncryptDict ,_aa []byte )[]byte {_gc .Log .Trace ("\u0061\u006c\u0067\u0032");_eg :=_gg .paddedPass (_aa );_fgc :=_ff .New ();_fgc .Write (_eg );_fgc .Write (_ad .O );var _gda [4]byte ;_gf .LittleEndian .PutUint32 (_gda [:],uint32 (_ad .P ));_fgc .Write (_gda [:]);_gc .Log .Trace ("\u0067o\u0020\u0050\u003a\u0020\u0025\u0020x",_gda );_fgc .Write ([]byte (_gg .ID0 ));_gc .Log .Trace ("\u0074\u0068\u0069\u0073\u002e\u0052\u0020\u003d\u0020\u0025d\u0020\u0065\u006e\u0063\u0072\u0079\u0070t\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061\u0020\u0025\u0076",_ad .R ,_ad .EncryptMetadata );if (_ad .R >=4)&&!_ad .EncryptMetadata {_fgc .Write ([]byte {0xff,0xff,0xff,0xff});};_ef :=_fgc .Sum (nil );if _ad .R >=3{_fgc =_ff .New ();for _ade :=0;_ade < 50;_ade ++{_fgc .Reset ();_fgc .Write (_ef [0:_gg .Length /8]);_ef =_fgc .Sum (nil );};};if _ad .R >=3{return _ef [0:_gg .Length /8];};return _ef [0:5];};

// Allowed checks if a set of permissions can be granted.
func (_df Permissions )Allowed (p2 Permissions )bool {return _df &p2 ==p2 };