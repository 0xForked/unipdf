//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package security ;import (_dd "bytes";_f "crypto/aes";_b "crypto/cipher";_a "crypto/md5";_fe "crypto/rand";_cc "crypto/rc4";_gg "crypto/sha256";_ge "crypto/sha512";_gb "encoding/binary";_ga "errors";_gc "fmt";_bb "github.com/unidoc/unipdf/v3/common";_c "hash";
_g "io";_fa "math";);func _db (_de _b .Block )_b .BlockMode {return (*ecbDecrypter )(_dfd (_de ))};func _gcb (_aef []byte ,_abe int ){_dedc :=_abe ;for _dedc < len (_aef ){copy (_aef [_dedc :],_aef [:_dedc ]);_dedc *=2;};};func (_ebe stdHandlerR4 )alg4 (_egg []byte ,_ggc []byte )([]byte ,error ){_ce ,_ef :=_cc .NewCipher (_egg );
if _ef !=nil {return nil ,_ga .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_ac :=[]byte (_af );_cee :=make ([]byte ,len (_ac ));_ce .XORKeyStream (_cee ,_ac );return _cee ,nil ;};func (_dfb *ecbDecrypter )BlockSize ()int {return _dfb ._df };
func (_gee *ecbEncrypter )CryptBlocks (dst ,src []byte ){if len (src )%_gee ._df !=0{_bb .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_bb .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_gee ._ae .Encrypt (dst ,src [:_gee ._df ]);src =src [_gee ._df :];dst =dst [_gee ._df :];};};func (_beg stdHandlerR6 )alg10 (_fecc *StdEncryptDict ,_ecbb []byte )error {if _acgg :=_faf ("\u0061\u006c\u00671\u0030","\u004b\u0065\u0079",32,_ecbb );
_acgg !=nil {return _acgg ;};_aae :=uint64 (uint32 (_fecc .P ))|(_fa .MaxUint32 <<32);Perms :=make ([]byte ,16);_gb .LittleEndian .PutUint64 (Perms [:8],_aae );if _fecc .EncryptMetadata {Perms [8]='T';}else {Perms [8]='F';};copy (Perms [9:12],"\u0061\u0064\u0062");
if _ ,_eaba :=_g .ReadFull (_fe .Reader ,Perms [12:16]);_eaba !=nil {return _eaba ;};_dfff ,_caec :=_bcc (_ecbb [:32]);if _caec !=nil {return _caec ;};_eddg :=_fea (_dfff );_eddg .CryptBlocks (Perms ,Perms );_fecc .Perms =Perms [:16];return nil ;};const (EventDocOpen =AuthEvent ("\u0044o\u0063\u004f\u0070\u0065\u006e");
EventEFOpen =AuthEvent ("\u0045\u0046\u004f\u0070\u0065\u006e"););

// Permissions is a bitmask of access permissions for a PDF file.
type Permissions uint32 ;func (_aee *ecbDecrypter )CryptBlocks (dst ,src []byte ){if len (src )%_aee ._df !=0{_bb .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_bb .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0064\u0065\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_aee ._ae .Decrypt (dst ,src [:_aee ._df ]);src =src [_aee ._df :];dst =dst [_aee ._df :];};};func _faf (_aa ,_ba string ,_ee int ,_cb []byte )error {if len (_cb )< _ee {return errInvalidField {Func :_aa ,Field :_ba ,Exp :_ee ,Got :len (_cb )};
};return nil ;};func (_cf stdHandlerR4 )alg2 (_eb *StdEncryptDict ,_fc []byte )[]byte {_bb .Log .Trace ("\u0061\u006c\u0067\u0032");_dff :=_cf .paddedPass (_fc );_da :=_a .New ();_da .Write (_dff );_da .Write (_eb .O );var _fcg [4]byte ;_gb .LittleEndian .PutUint32 (_fcg [:],uint32 (_eb .P ));
_da .Write (_fcg [:]);_bb .Log .Trace ("\u0067o\u0020\u0050\u003a\u0020\u0025\u0020x",_fcg );_da .Write ([]byte (_cf .ID0 ));_bb .Log .Trace ("\u0074\u0068\u0069\u0073\u002e\u0052\u0020\u003d\u0020\u0025d\u0020\u0065\u006e\u0063\u0072\u0079\u0070t\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061\u0020\u0025\u0076",_eb .R ,_eb .EncryptMetadata );
if (_eb .R >=4)&&!_eb .EncryptMetadata {_da .Write ([]byte {0xff,0xff,0xff,0xff});};_ggd :=_da .Sum (nil );if _eb .R >=3{_da =_a .New ();for _deb :=0;_deb < 50;_deb ++{_da .Reset ();_da .Write (_ggd [0:_cf .Length /8]);_ggd =_da .Sum (nil );};};if _eb .R >=3{return _ggd [0:_cf .Length /8];
};return _ggd [0:5];};type ecbEncrypter ecb ;func (_bfb stdHandlerR4 )alg7 (_dg *StdEncryptDict ,_eea []byte )([]byte ,error ){_bfe :=_bfb .alg3Key (_dg .R ,_eea );_bbe :=make ([]byte ,len (_dg .O ));if _dg .R ==2{_agd ,_cga :=_cc .NewCipher (_bfe );if _cga !=nil {return nil ,_ga .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");
};_agd .XORKeyStream (_bbe ,_dg .O );}else if _dg .R >=3{_gfg :=append ([]byte {},_dg .O ...);for _egd :=0;_egd < 20;_egd ++{_eab :=append ([]byte {},_bfe ...);for _gea :=0;_gea < len (_bfe );_gea ++{_eab [_gea ]^=byte (19-_egd );};_fedb ,_dfa :=_cc .NewCipher (_eab );
if _dfa !=nil {return nil ,_ga .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_fedb .XORKeyStream (_bbe ,_gfg );_gfg =append ([]byte {},_bbe ...);};}else {return nil ,_ga .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");
};_fef ,_efc :=_bfb .alg6 (_dg ,_bbe );if _efc !=nil {return nil ,nil ;};return _fef ,nil ;};func _fba (_aca ,_aad ,_cdd []byte )([]byte ,error ){var (_bfd ,_dege ,_ed _c .Hash ;);_bfd =_gg .New ();_ecb :=make ([]byte ,64);_gga :=_bfd ;_gga .Write (_aca );
K :=_gga .Sum (_ecb [:0]);_eae :=make ([]byte ,64*(127+64+48));_bee :=func (_faff int )([]byte ,error ){_fbf :=len (_aad )+len (K )+len (_cdd );_cfb :=_eae [:_fbf ];_gd :=copy (_cfb ,_aad );_gd +=copy (_cfb [_gd :],K [:]);_gd +=copy (_cfb [_gd :],_cdd );
if _gd !=_fbf {_bb .Log .Error ("E\u0052\u0052\u004f\u0052\u003a\u0020u\u006e\u0065\u0078\u0070\u0065\u0063t\u0065\u0064\u0020\u0072\u006f\u0075\u006ed\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0073\u0069\u007ae\u002e");return nil ,_ga .New ("\u0077\u0072\u006f\u006e\u0067\u0020\u0073\u0069\u007a\u0065");
};K1 :=_eae [:_fbf *64];_gcb (K1 ,_fbf );_fbaf ,_dddd :=_bcc (K [0:16]);if _dddd !=nil {return nil ,_dddd ;};_bga :=_b .NewCBCEncrypter (_fbaf ,K [16:32]);_bga .CryptBlocks (K1 ,K1 );E :=K1 ;_afd :=0;for _edd :=0;_edd < 16;_edd ++{_afd +=int (E [_edd ]%3);
};var _dbeg _c .Hash ;switch _afd %3{case 0:_dbeg =_bfd ;case 1:if _dege ==nil {_dege =_ge .New384 ();};_dbeg =_dege ;case 2:if _ed ==nil {_ed =_ge .New ();};_dbeg =_ed ;};_dbeg .Reset ();_dbeg .Write (E );K =_dbeg .Sum (_ecb [:0]);return E ,nil ;};for _ecbc :=0;
;{E ,_fff :=_bee (_ecbc );if _fff !=nil {return nil ,_fff ;};_eafg :=E [len (E )-1];_ecbc ++;if _ecbc >=64&&_eafg <=uint8 (_ecbc -32){break ;};};return K [:32],nil ;};func (_cg errInvalidField )Error ()string {return _gc .Sprintf ("\u0025s\u003a\u0020e\u0078\u0070\u0065\u0063t\u0065\u0064\u0020%\u0073\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0074o \u0062\u0065\u0020%\u0064\u0020b\u0079\u0074\u0065\u0073\u002c\u0020g\u006f\u0074 \u0025\u0064",_cg .Func ,_cg .Field ,_cg .Exp ,_cg .Got );
};type ecb struct{_ae _b .Block ;_df int ;};const _af ="\x28\277\116\136\x4e\x75\x8a\x41\x64\000\x4e\x56\377"+"\xfa\001\010\056\x2e\x00\xb6\xd0\x68\076\x80\x2f\014"+"\251\xfe\x64\x53\x69\172";

// GenerateParams is the algorithm opposite to alg2a (R>=5).
// It generates U,O,UE,OE,Perms fields using AESv3 encryption.
// There is no algorithm number assigned to this function in the spec.
// It expects R, P and EncryptMetadata fields to be set.
func (_dea stdHandlerR6 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){_dcg :=make ([]byte ,32);if _ ,_aagb :=_g .ReadFull (_fe .Reader ,_dcg );_aagb !=nil {return nil ,_aagb ;};d .U =nil ;d .O =nil ;d .UE =nil ;d .OE =nil ;d .Perms =nil ;
if len (upass )> 127{upass =upass [:127];};if len (opass )> 127{opass =opass [:127];};if _afce :=_dea .alg8 (d ,_dcg ,upass );_afce !=nil {return nil ,_afce ;};if _bca :=_dea .alg9 (d ,_dcg ,opass );_bca !=nil {return nil ,_bca ;};if d .R ==5{return _dcg ,nil ;
};if _gggf :=_dea .alg10 (d ,_dcg );_gggf !=nil {return nil ,_gggf ;};return _dcg ,nil ;};func (_agc stdHandlerR6 )alg9 (_afc *StdEncryptDict ,_aagf []byte ,_aaf []byte )error {if _dede :=_faf ("\u0061\u006c\u0067\u0039","\u004b\u0065\u0079",32,_aagf );
_dede !=nil {return _dede ;};if _dagf :=_faf ("\u0061\u006c\u0067\u0039","\u0055",48,_afc .U );_dagf !=nil {return _dagf ;};var _ffa [16]byte ;if _ ,_ega :=_g .ReadFull (_fe .Reader ,_ffa [:]);_ega !=nil {return _ega ;};_babc :=_ffa [0:8];_aff :=_ffa [8:16];
_gfb :=_afc .U [:48];_ggcd :=make ([]byte ,len (_aaf )+len (_babc )+len (_gfb ));_baaf :=copy (_ggcd ,_aaf );_baaf +=copy (_ggcd [_baaf :],_babc );_baaf +=copy (_ggcd [_baaf :],_gfb );_eaa ,_fdg :=_agc .alg2b (_afc .R ,_ggcd ,_aaf ,_gfb );if _fdg !=nil {return _fdg ;
};O :=make ([]byte ,len (_eaa )+len (_babc )+len (_aff ));_baaf =copy (O ,_eaa [:32]);_baaf +=copy (O [_baaf :],_babc );_baaf +=copy (O [_baaf :],_aff );_afc .O =O ;_baaf =len (_aaf );_baaf +=copy (_ggcd [_baaf :],_aff );_eaa ,_fdg =_agc .alg2b (_afc .R ,_ggcd ,_aaf ,_gfb );
if _fdg !=nil {return _fdg ;};_gcca ,_fdg :=_bcc (_eaa [:32]);if _fdg !=nil {return _fdg ;};_edf :=make ([]byte ,_f .BlockSize );_aeee :=_b .NewCBCEncrypter (_gcca ,_edf );OE :=make ([]byte ,32);_aeee .CryptBlocks (OE ,_aagf [:32]);_afc .OE =OE ;return nil ;
};

// Allowed checks if a set of permissions can be granted.
func (_aab Permissions )Allowed (p2 Permissions )bool {return _aab &p2 ==p2 };func _bcc (_ebd []byte )(_b .Block ,error ){_acg ,_acd :=_f .NewCipher (_ebd );if _acd !=nil {_bb .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0063\u0072\u0065\u0061\u0074\u0065\u0020A\u0045\u0053\u0020\u0063\u0069p\u0068\u0065r\u003a\u0020\u0025\u0076",_acd );
return nil ,_acd ;};return _acg ,nil ;};func (_dbf stdHandlerR6 )alg2a (_eaf *StdEncryptDict ,_fae []byte )([]byte ,Permissions ,error ){if _gac :=_faf ("\u0061\u006c\u00672\u0061","\u004f",48,_eaf .O );_gac !=nil {return nil ,0,_gac ;};if _afe :=_faf ("\u0061\u006c\u00672\u0061","\u0055",48,_eaf .U );
_afe !=nil {return nil ,0,_afe ;};if len (_fae )> 127{_fae =_fae [:127];};_egc ,_feda :=_dbf .alg12 (_eaf ,_fae );if _feda !=nil {return nil ,0,_feda ;};var (_dee []byte ;_ebb []byte ;_cab []byte ;);var _cfa Permissions ;if len (_egc )!=0{_cfa =PermOwner ;
_ab :=make ([]byte ,len (_fae )+8+48);_dfe :=copy (_ab ,_fae );_dfe +=copy (_ab [_dfe :],_eaf .O [40:48]);copy (_ab [_dfe :],_eaf .U [0:48]);_dee =_ab ;_ebb =_eaf .OE ;_cab =_eaf .U [0:48];}else {_egc ,_feda =_dbf .alg11 (_eaf ,_fae );if _feda ==nil &&len (_egc )==0{_egc ,_feda =_dbf .alg11 (_eaf ,[]byte (""));
};if _feda !=nil {return nil ,0,_feda ;}else if len (_egc )==0{return nil ,0,nil ;};_cfa =_eaf .P ;_ddg :=make ([]byte ,len (_fae )+8);_aag :=copy (_ddg ,_fae );copy (_ddg [_aag :],_eaf .U [40:48]);_dee =_ddg ;_ebb =_eaf .UE ;_cab =nil ;};if _ccf :=_faf ("\u0061\u006c\u00672\u0061","\u004b\u0065\u0079",32,_ebb );
_ccf !=nil {return nil ,0,_ccf ;};_ebb =_ebb [:32];_dfae ,_feda :=_dbf .alg2b (_eaf .R ,_dee ,_fae ,_cab );if _feda !=nil {return nil ,0,_feda ;};_cad ,_feda :=_f .NewCipher (_dfae [:32]);if _feda !=nil {return nil ,0,_feda ;};_efd :=make ([]byte ,_f .BlockSize );
_egb :=_b .NewCBCDecrypter (_cad ,_efd );_cae :=make ([]byte ,32);_egb .CryptBlocks (_cae ,_ebb );if _eaf .R ==5{return _cae ,_cfa ,nil ;};_feda =_dbf .alg13 (_eaf ,_cae );if _feda !=nil {return nil ,0,_feda ;};return _cae ,_cfa ,nil ;};func (_cda stdHandlerR4 )alg5 (_eef []byte ,_bgb []byte )([]byte ,error ){_bae :=_a .New ();
_bae .Write ([]byte (_af ));_bae .Write ([]byte (_cda .ID0 ));_ddd :=_bae .Sum (nil );_bb .Log .Trace ("\u0061\u006c\u0067\u0035");_bb .Log .Trace ("\u0065k\u0065\u0079\u003a\u0020\u0025\u0020x",_eef );_bb .Log .Trace ("\u0049D\u003a\u0020\u0025\u0020\u0078",_cda .ID0 );
if len (_ddd )!=16{return nil ,_ga .New ("\u0068a\u0073\u0068\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074\u0020\u0031\u0036\u0020\u0062\u0079\u0074\u0065\u0073");};_cccf ,_ec :=_cc .NewCipher (_eef );if _ec !=nil {return nil ,_ga .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_dec :=make ([]byte ,16);_cccf .XORKeyStream (_dec ,_ddd );_ca :=make ([]byte ,len (_eef ));for _deda :=0;_deda < 19;_deda ++{for _fec :=0;_fec < len (_eef );_fec ++{_ca [_fec ]=_eef [_fec ]^byte (_deda +1);};_cccf ,_ec =_cc .NewCipher (_ca );if _ec !=nil {return nil ,_ga .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_cccf .XORKeyStream (_dec ,_dec );_bb .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u002c\u0020\u0065\u006b\u0065\u0079:\u0020\u0025\u0020\u0078",_deda ,_ca );_bb .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0020\u0078",_deda ,_dec );
};_fca :=make ([]byte ,32);for _fge :=0;_fge < 16;_fge ++{_fca [_fge ]=_dec [_fge ];};_ ,_ec =_fe .Read (_fca [16:32]);if _ec !=nil {return nil ,_ga .New ("\u0066a\u0069\u006c\u0065\u0064 \u0074\u006f\u0020\u0067\u0065n\u0020r\u0061n\u0064\u0020\u006e\u0075\u006d\u0062\u0065r");
};return _fca ,nil ;};

// StdHandler is an interface for standard security handlers.
type StdHandler interface{

// GenerateParams uses owner and user passwords to set encryption parameters and generate an encryption key.
// It assumes that R, P and EncryptMetadata are already set.
GenerateParams (_bd *StdEncryptDict ,_ccc ,_bg []byte )([]byte ,error );

// Authenticate uses encryption dictionary parameters and the password to calculate
// the document encryption key. It also returns permissions that should be granted to a user.
// In case of failed authentication, it returns empty key and zero permissions with no error.
Authenticate (_eg *StdEncryptDict ,_dde []byte )([]byte ,Permissions ,error );};var _ StdHandler =stdHandlerR4 {};func (_fee stdHandlerR4 )alg3Key (R int ,_dc []byte )[]byte {_ff :=_a .New ();_dcf :=_fee .paddedPass (_dc );_ff .Write (_dcf );if R >=3{for _dcd :=0;
_dcd < 50;_dcd ++{_fg :=_ff .Sum (nil );_ff =_a .New ();_ff .Write (_fg );};};_ebc :=_ff .Sum (nil );if R ==2{_ebc =_ebc [0:5];}else {_ebc =_ebc [0:_fee .Length /8];};return _ebc ;};type ecbDecrypter ecb ;

// NewHandlerR4 creates a new standard security handler for R<=4.
func NewHandlerR4 (id0 string ,length int )StdHandler {return stdHandlerR4 {ID0 :id0 ,Length :length }};

// AuthEvent is an event type that triggers authentication.
type AuthEvent string ;const (PermOwner =Permissions (_fa .MaxUint32 );PermPrinting =Permissions (1<<2);PermModify =Permissions (1<<3);PermExtractGraphics =Permissions (1<<4);PermAnnotate =Permissions (1<<5);PermFillForms =Permissions (1<<8);PermDisabilityExtract =Permissions (1<<9);
PermRotateInsert =Permissions (1<<10);PermFullPrintQuality =Permissions (1<<11););func (_dag stdHandlerR4 )alg3 (R int ,_deg ,_fb []byte )([]byte ,error ){var _agf []byte ;if len (_fb )> 0{_agf =_dag .alg3Key (R ,_fb );}else {_agf =_dag .alg3Key (R ,_deg );
};_cd ,_bf :=_cc .NewCipher (_agf );if _bf !=nil {return nil ,_ga .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_fcd :=_dag .paddedPass (_deg );_ea :=make ([]byte ,len (_fcd ));_cd .XORKeyStream (_ea ,_fcd );
if R >=3{_be :=make ([]byte ,len (_agf ));for _bc :=0;_bc < 19;_bc ++{for _gf :=0;_gf < len (_agf );_gf ++{_be [_gf ]=_agf [_gf ]^byte (_bc +1);};_dbd ,_bab :=_cc .NewCipher (_be );if _bab !=nil {return nil ,_ga .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_dbd .XORKeyStream (_ea ,_ea );};};return _ea ,nil ;};func (_def stdHandlerR4 )alg6 (_bge *StdEncryptDict ,_ad []byte )([]byte ,error ){var (_cbc []byte ;_dbe error ;);_fd :=_def .alg2 (_bge ,_ad );if _bge .R ==2{_cbc ,_dbe =_def .alg4 (_fd ,_ad );}else if _bge .R >=3{_cbc ,_dbe =_def .alg5 (_fd ,_ad );
}else {return nil ,_ga .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};if _dbe !=nil {return nil ,_dbe ;};_bb .Log .Trace ("\u0063\u0068\u0065\u0063k:\u0020\u0025\u0020\u0078\u0020\u003d\u003d\u0020\u0025\u0020\u0078\u0020\u003f",string (_cbc ),string (_bge .U ));
_degg :=_cbc ;_cef :=_bge .U ;if _bge .R >=3{if len (_degg )> 16{_degg =_degg [0:16];};if len (_cef )> 16{_cef =_cef [0:16];};};if !_dd .Equal (_degg ,_cef ){return nil ,nil ;};return _fd ,nil ;};func _fea (_ag _b .Block )_b .BlockMode {return (*ecbEncrypter )(_dfd (_ag ))};
func (_decc stdHandlerR6 )alg12 (_dbef *StdEncryptDict ,_adb []byte )([]byte ,error ){if _gfde :=_faf ("\u0061\u006c\u00671\u0032","\u0055",48,_dbef .U );_gfde !=nil {return nil ,_gfde ;};if _agb :=_faf ("\u0061\u006c\u00671\u0032","\u004f",48,_dbef .O );
_agb !=nil {return nil ,_agb ;};_bfg :=make ([]byte ,len (_adb )+8+48);_dbed :=copy (_bfg ,_adb );_dbed +=copy (_bfg [_dbed :],_dbef .O [32:40]);_dbed +=copy (_bfg [_dbed :],_dbef .U [0:48]);_fbe ,_gdd :=_decc .alg2b (_dbef .R ,_bfg ,_adb ,_dbef .U [0:48]);
if _gdd !=nil {return nil ,_gdd ;};_fbe =_fbe [:32];if !_dd .Equal (_fbe ,_dbef .O [:32]){return nil ,nil ;};return _fbe ,nil ;};func (_aed stdHandlerR6 )alg8 (_baa *StdEncryptDict ,_gef []byte ,_dad []byte )error {if _aac :=_faf ("\u0061\u006c\u0067\u0038","\u004b\u0065\u0079",32,_gef );
_aac !=nil {return _aac ;};var _dffg [16]byte ;if _ ,_bfeg :=_g .ReadFull (_fe .Reader ,_dffg [:]);_bfeg !=nil {return _bfeg ;};_dcb :=_dffg [0:8];_bac :=_dffg [8:16];_efde :=make ([]byte ,len (_dad )+len (_dcb ));_fbfe :=copy (_efde ,_dad );copy (_efde [_fbfe :],_dcb );
_gcf ,_dca :=_aed .alg2b (_baa .R ,_efde ,_dad ,nil );if _dca !=nil {return _dca ;};U :=make ([]byte ,len (_gcf )+len (_dcb )+len (_bac ));_fbfe =copy (U ,_gcf [:32]);_fbfe +=copy (U [_fbfe :],_dcb );copy (U [_fbfe :],_bac );_baa .U =U ;_fbfe =len (_dad );
copy (_efde [_fbfe :],_bac );_gcf ,_dca =_aed .alg2b (_baa .R ,_efde ,_dad ,nil );if _dca !=nil {return _dca ;};_gcc ,_dca :=_bcc (_gcf [:32]);if _dca !=nil {return _dca ;};_caa :=make ([]byte ,_f .BlockSize );_feac :=_b .NewCBCEncrypter (_gcc ,_caa );
UE :=make ([]byte ,32);_feac .CryptBlocks (UE ,_gef [:32]);_baa .UE =UE ;return nil ;};type stdHandlerR6 struct{};func (_fcc stdHandlerR6 )alg2b (R int ,_ggg ,_cafb ,_efce []byte )([]byte ,error ){if R ==5{return _ccd (_ggg );};return _fba (_ggg ,_cafb ,_efce );
};type errInvalidField struct{Func string ;Field string ;Exp int ;Got int ;};func _dfd (_ged _b .Block )*ecb {return &ecb {_ae :_ged ,_df :_ged .BlockSize ()}};

// GenerateParams generates and sets O and U parameters for the encryption dictionary.
// It expects R, P and EncryptMetadata fields to be set.
func (_ebeg stdHandlerR4 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){O ,_fcb :=_ebeg .alg3 (d .R ,upass ,opass );if _fcb !=nil {_bb .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_fcb );
return nil ,_fcb ;};d .O =O ;_bb .Log .Trace ("\u0067\u0065\u006e\u0020\u004f\u003a\u0020\u0025\u0020\u0078",O );_acb :=_ebeg .alg2 (d ,upass );U ,_fcb :=_ebeg .alg5 (_acb ,upass );if _fcb !=nil {_bb .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_fcb );
return nil ,_fcb ;};d .U =U ;_bb .Log .Trace ("\u0067\u0065\u006e\u0020\u0055\u003a\u0020\u0025\u0020\u0078",U );return _acb ,nil ;};var _ StdHandler =stdHandlerR6 {};

// NewHandlerR6 creates a new standard security handler for R=5 and R=6.
func NewHandlerR6 ()StdHandler {return stdHandlerR6 {}};func (_geb stdHandlerR6 )alg11 (_eefd *StdEncryptDict ,_gdb []byte )([]byte ,error ){if _ecg :=_faf ("\u0061\u006c\u00671\u0031","\u0055",48,_eefd .U );_ecg !=nil {return nil ,_ecg ;};_dcab :=make ([]byte ,len (_gdb )+8);
_ecd :=copy (_dcab ,_gdb );_ecd +=copy (_dcab [_ecd :],_eefd .U [32:40]);_dcc ,_ceb :=_geb .alg2b (_eefd .R ,_dcab ,_gdb ,nil );if _ceb !=nil {return nil ,_ceb ;};_dcc =_dcc [:32];if !_dd .Equal (_dcc ,_eefd .U [:32]){return nil ,nil ;};return _dcc ,nil ;
};func (_ddc stdHandlerR6 )alg13 (_bgc *StdEncryptDict ,_gfe []byte )error {if _cgaf :=_faf ("\u0061\u006c\u00671\u0033","\u004b\u0065\u0079",32,_gfe );_cgaf !=nil {return _cgaf ;};if _ecdg :=_faf ("\u0061\u006c\u00671\u0033","\u0050\u0065\u0072m\u0073",16,_bgc .Perms );
_ecdg !=nil {return _ecdg ;};_geg :=make ([]byte ,16);copy (_geg ,_bgc .Perms [:16]);_cdg ,_bccd :=_f .NewCipher (_gfe [:32]);if _bccd !=nil {return _bccd ;};_age :=_db (_cdg );_age .CryptBlocks (_geg ,_geg );if !_dd .Equal (_geg [9:12],[]byte ("\u0061\u0064\u0062")){return _ga .New ("\u0064\u0065\u0063o\u0064\u0065\u0064\u0020p\u0065\u0072\u006d\u0069\u0073\u0073\u0069o\u006e\u0073\u0020\u0061\u0072\u0065\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};_ddce :=Permissions (_gb .LittleEndian .Uint32 (_geg [0:4]));if _ddce !=_bgc .P {return _ga .New ("\u0070\u0065r\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066\u0061il\u0065\u0064");
};var _deff bool ;if _geg [8]=='T'{_deff =true ;}else if _geg [8]=='F'{_deff =false ;}else {return _ga .New ("\u0064\u0065\u0063\u006f\u0064\u0065\u0064 \u006d\u0065\u0074a\u0064\u0061\u0074\u0061 \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u006c\u0061\u0067\u0020\u0069\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};if _deff !=_bgc .EncryptMetadata {return _ga .New ("\u006d\u0065t\u0061\u0064\u0061\u0074a\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e \u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066a\u0069\u006c\u0065\u0064");
};return nil ;};

// Authenticate implements StdHandler interface.
func (_caf stdHandlerR4 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){_bb .Log .Trace ("\u0044\u0065b\u0075\u0067\u0067\u0069n\u0067\u0020a\u0075\u0074\u0068\u0065\u006e\u0074\u0069\u0063a\u0074\u0069\u006f\u006e\u0020\u002d\u0020\u006f\u0077\u006e\u0065\u0072 \u0070\u0061\u0073\u0073");
_eba ,_adf :=_caf .alg7 (d ,pass );if _adf !=nil {return nil ,0,_adf ;};if _eba !=nil {_bb .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _eba ,PermOwner ,nil ;
};_bb .Log .Trace ("\u0044\u0065bu\u0067\u0067\u0069n\u0067\u0020\u0061\u0075the\u006eti\u0063\u0061\u0074\u0069\u006f\u006e\u0020- \u0075\u0073\u0065\u0072\u0020\u0070\u0061s\u0073");_eba ,_adf =_caf .alg6 (d ,pass );if _adf !=nil {return nil ,0,_adf ;
};if _eba !=nil {_bb .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _eba ,d .P ,nil ;};return nil ,0,nil ;};type stdHandlerR4 struct{Length int ;ID0 string ;
};

// Authenticate implements StdHandler interface.
func (_baac stdHandlerR6 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){return _baac .alg2a (d ,pass );};func _ccd (_bbb []byte )([]byte ,error ){_gfga :=_gg .New ();_gfga .Write (_bbb );return _gfga .Sum (nil ),nil ;};func (stdHandlerR4 )paddedPass (_bbc []byte )[]byte {_fed :=make ([]byte ,32);
_ded :=copy (_fed ,_bbc );for ;_ded < 32;_ded ++{_fed [_ded ]=_af [_ded -len (_bbc )];};return _fed ;};

// StdEncryptDict is a set of additional fields used in standard encryption dictionary.
type StdEncryptDict struct{R int ;P Permissions ;EncryptMetadata bool ;O ,U []byte ;OE ,UE []byte ;Perms []byte ;};func (_e *ecbEncrypter )BlockSize ()int {return _e ._df };