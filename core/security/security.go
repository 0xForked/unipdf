//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package security ;import (_be "bytes";_c "crypto/aes";_a "crypto/cipher";_dd "crypto/md5";_cc "crypto/rand";_ga "crypto/rc4";_b "crypto/sha256";_ab "crypto/sha512";_g "encoding/binary";_ag "errors";_ba "fmt";_f "github.com/unidoc/unipdf/v3/common";_e "hash";_da "io";_aa "math";);type stdHandlerR4 struct{Length int ;ID0 string ;};type ecbEncrypter ecb ;func (_gbg stdHandlerR4 )alg5 (_bag []byte ,_ccb []byte )([]byte ,error ){_fd :=_dd .New ();_fd .Write ([]byte (_eec ));_fd .Write ([]byte (_gbg .ID0 ));_efd :=_fd .Sum (nil );_f .Log .Trace ("\u0061\u006c\u0067\u0035");_f .Log .Trace ("\u0065k\u0065\u0079\u003a\u0020\u0025\u0020x",_bag );_f .Log .Trace ("\u0049D\u003a\u0020\u0025\u0020\u0078",_gbg .ID0 );if len (_efd )!=16{return nil ,_ag .New ("\u0068a\u0073\u0068\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074\u0020\u0031\u0036\u0020\u0062\u0079\u0074\u0065\u0073");};_fbf ,_efa :=_ga .NewCipher (_bag );if _efa !=nil {return nil ,_ag .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_ddg :=make ([]byte ,16);_fbf .XORKeyStream (_ddg ,_efd );_aad :=make ([]byte ,len (_bag ));for _bac :=0;_bac < 19;_bac ++{for _dab :=0;_dab < len (_bag );_dab ++{_aad [_dab ]=_bag [_dab ]^byte (_bac +1);};_fbf ,_efa =_ga .NewCipher (_aad );if _efa !=nil {return nil ,_ag .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_fbf .XORKeyStream (_ddg ,_ddg );_f .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u002c\u0020\u0065\u006b\u0065\u0079:\u0020\u0025\u0020\u0078",_bac ,_aad );_f .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0020\u0078",_bac ,_ddg );};_fc :=make ([]byte ,32);for _cf :=0;_cf < 16;_cf ++{_fc [_cf ]=_ddg [_cf ];};_ ,_efa =_cc .Read (_fc [16:32]);if _efa !=nil {return nil ,_ag .New ("\u0066a\u0069\u006c\u0065\u0064 \u0074\u006f\u0020\u0067\u0065n\u0020r\u0061n\u0064\u0020\u006e\u0075\u006d\u0062\u0065r");};return _fc ,nil ;};func _eb (_bd _a .Block )_a .BlockMode {return (*ecbEncrypter )(_ee (_bd ))};const (PermOwner =Permissions (_aa .MaxUint32 );PermPrinting =Permissions (1<<2);PermModify =Permissions (1<<3);PermExtractGraphics =Permissions (1<<4);PermAnnotate =Permissions (1<<5);PermFillForms =Permissions (1<<8);PermDisabilityExtract =Permissions (1<<9);PermRotateInsert =Permissions (1<<10);PermFullPrintQuality =Permissions (1<<11););const (EventDocOpen =AuthEvent ("\u0044o\u0063\u004f\u0070\u0065\u006e");EventEFOpen =AuthEvent ("\u0045\u0046\u004f\u0070\u0065\u006e"););

// NewHandlerR4 creates a new standard security handler for R<=4.
func NewHandlerR4 (id0 string ,length int )StdHandler {return stdHandlerR4 {ID0 :id0 ,Length :length }};func (_aaa stdHandlerR4 )alg2 (_ac *StdEncryptDict ,_cba []byte )[]byte {_f .Log .Trace ("\u0061\u006c\u0067\u0032");_gc :=_aaa .paddedPass (_cba );_ec :=_dd .New ();_ec .Write (_gc );_ec .Write (_ac .O );var _fad [4]byte ;_g .LittleEndian .PutUint32 (_fad [:],uint32 (_ac .P ));_ec .Write (_fad [:]);_f .Log .Trace ("\u0067o\u0020\u0050\u003a\u0020\u0025\u0020x",_fad );_ec .Write ([]byte (_aaa .ID0 ));_f .Log .Trace ("\u0074\u0068\u0069\u0073\u002e\u0052\u0020\u003d\u0020\u0025d\u0020\u0065\u006e\u0063\u0072\u0079\u0070t\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061\u0020\u0025\u0076",_ac .R ,_ac .EncryptMetadata );if (_ac .R >=4)&&!_ac .EncryptMetadata {_ec .Write ([]byte {0xff,0xff,0xff,0xff});};_cdc :=_ec .Sum (nil );if _ac .R >=3{_ec =_dd .New ();for _gda :=0;_gda < 50;_gda ++{_ec .Reset ();_ec .Write (_cdc [0:_aaa .Length /8]);_cdc =_ec .Sum (nil );};};if _ac .R >=3{return _cdc [0:_aaa .Length /8];};return _cdc [0:5];};

// Authenticate implements StdHandler interface.
func (_dbf stdHandlerR4 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){_f .Log .Trace ("\u0044\u0065b\u0075\u0067\u0067\u0069n\u0067\u0020a\u0075\u0074\u0068\u0065\u006e\u0074\u0069\u0063a\u0074\u0069\u006f\u006e\u0020\u002d\u0020\u006f\u0077\u006e\u0065\u0072 \u0070\u0061\u0073\u0073");_ddfg ,_abf :=_dbf .alg7 (d ,pass );if _abf !=nil {return nil ,0,_abf ;};if _ddfg !=nil {_f .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _ddfg ,PermOwner ,nil ;};_f .Log .Trace ("\u0044\u0065bu\u0067\u0067\u0069n\u0067\u0020\u0061\u0075the\u006eti\u0063\u0061\u0074\u0069\u006f\u006e\u0020- \u0075\u0073\u0065\u0072\u0020\u0070\u0061s\u0073");_ddfg ,_abf =_dbf .alg6 (d ,pass );if _abf !=nil {return nil ,0,_abf ;};if _ddfg !=nil {_f .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _ddfg ,d .P ,nil ;};return nil ,0,nil ;};func (_fab stdHandlerR4 )alg7 (_dbb *StdEncryptDict ,_eda []byte )([]byte ,error ){_bad :=_fab .alg3Key (_dbb .R ,_eda );_eac :=make ([]byte ,len (_dbb .O ));if _dbb .R ==2{_bab ,_cec :=_ga .NewCipher (_bad );if _cec !=nil {return nil ,_ag .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_bab .XORKeyStream (_eac ,_dbb .O );}else if _dbb .R >=3{_cda :=append ([]byte {},_dbb .O ...);for _ecg :=0;_ecg < 20;_ecg ++{_fadc :=append ([]byte {},_bad ...);for _cfe :=0;_cfe < len (_bad );_cfe ++{_fadc [_cfe ]^=byte (19-_ecg );};_gce ,_edaa :=_ga .NewCipher (_fadc );if _edaa !=nil {return nil ,_ag .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_gce .XORKeyStream (_eac ,_cda );_cda =append ([]byte {},_eac ...);};}else {return nil ,_ag .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};_cbaa ,_dac :=_fab .alg6 (_dbb ,_eac );if _dac !=nil {return nil ,nil ;};return _cbaa ,nil ;};

// StdEncryptDict is a set of additional fields used in standard encryption dictionary.
type StdEncryptDict struct{R int ;P Permissions ;EncryptMetadata bool ;O ,U []byte ;OE ,UE []byte ;Perms []byte ;};type stdHandlerR6 struct{};

// AuthEvent is an event type that triggers authentication.
type AuthEvent string ;func (_afdc stdHandlerR4 )alg3 (R int ,_fb ,_ddf []byte )([]byte ,error ){var _eg []byte ;if len (_ddf )> 0{_eg =_afdc .alg3Key (R ,_ddf );}else {_eg =_afdc .alg3Key (R ,_fb );};_agec ,_aae :=_ga .NewCipher (_eg );if _aae !=nil {return nil ,_ag .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_efb :=_afdc .paddedPass (_fb );_cbab :=make ([]byte ,len (_efb ));_agec .XORKeyStream (_cbab ,_efb );if R >=3{_gg :=make ([]byte ,len (_eg ));for _fed :=0;_fed < 19;_fed ++{for _bdg :=0;_bdg < len (_eg );_bdg ++{_gg [_bdg ]=_eg [_bdg ]^byte (_fed +1);};_aca ,_gb :=_ga .NewCipher (_gg );if _gb !=nil {return nil ,_ag .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_aca .XORKeyStream (_cbab ,_cbab );};};return _cbab ,nil ;};var _ StdHandler =stdHandlerR6 {};func _gab (_ecee ,_cdab ,_bfc []byte )([]byte ,error ){var (_bge ,_aff ,_fde _e .Hash ;);_bge =_b .New ();_ged :=make ([]byte ,64);_gag :=_bge ;_gag .Write (_ecee );K :=_gag .Sum (_ged [:0]);_cdce :=make ([]byte ,64*(127+64+48));_dbe :=func (_bgf int )([]byte ,error ){_gbb :=len (_cdab )+len (K )+len (_bfc );_dacc :=_cdce [:_gbb ];_adf :=copy (_dacc ,_cdab );_adf +=copy (_dacc [_adf :],K [:]);_adf +=copy (_dacc [_adf :],_bfc );if _adf !=_gbb {_f .Log .Error ("E\u0052\u0052\u004f\u0052\u003a\u0020u\u006e\u0065\u0078\u0070\u0065\u0063t\u0065\u0064\u0020\u0072\u006f\u0075\u006ed\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0073\u0069\u007ae\u002e");return nil ,_ag .New ("\u0077\u0072\u006f\u006e\u0067\u0020\u0073\u0069\u007a\u0065");};K1 :=_cdce [:_gbb *64];_beg (K1 ,_gbb );_dga ,_ggb :=_gf (K [0:16]);if _ggb !=nil {return nil ,_ggb ;};_abg :=_a .NewCBCEncrypter (_dga ,K [16:32]);_abg .CryptBlocks (K1 ,K1 );E :=K1 ;_ebg :=0;for _efg :=0;_efg < 16;_efg ++{_ebg +=int (E [_efg ]%3);};var _acd _e .Hash ;switch _ebg %3{case 0:_acd =_bge ;case 1:if _aff ==nil {_aff =_ab .New384 ();};_acd =_aff ;case 2:if _fde ==nil {_fde =_ab .New ();};_acd =_fde ;};_acd .Reset ();_acd .Write (E );K =_acd .Sum (_ged [:0]);return E ,nil ;};for _baf :=0;;{E ,_cbf :=_dbe (_baf );if _cbf !=nil {return nil ,_cbf ;};_dcf :=E [len (E )-1];_baf ++;if _baf >=64&&_dcf <=uint8 (_baf -32){break ;};};return K [:32],nil ;};func (_cd *ecbEncrypter )CryptBlocks (dst ,src []byte ){if len (src )%_cd ._gd !=0{_f .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");return ;};if len (dst )< len (src ){_f .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");return ;};for len (src )> 0{_cd ._ea .Encrypt (dst ,src [:_cd ._gd ]);src =src [_cd ._gd :];dst =dst [_cd ._gd :];};};func _ffe (_bef []byte )([]byte ,error ){_cef :=_b .New ();_cef .Write (_bef );return _cef .Sum (nil ),nil };type ecb struct{_ea _a .Block ;_gd int ;};func (_dbbd stdHandlerR6 )alg2a (_cfd *StdEncryptDict ,_cfb []byte )([]byte ,Permissions ,error ){if _aac :=_age ("\u0061\u006c\u00672\u0061","\u004f",48,_cfd .O );_aac !=nil {return nil ,0,_aac ;};if _agc :=_age ("\u0061\u006c\u00672\u0061","\u0055",48,_cfd .U );_agc !=nil {return nil ,0,_agc ;};if len (_cfb )> 127{_cfb =_cfb [:127];};_bdd ,_dee :=_dbbd .alg12 (_cfd ,_cfb );if _dee !=nil {return nil ,0,_dee ;};var (_afb []byte ;_dfde []byte ;_bbbc []byte ;);var _cg Permissions ;if len (_bdd )!=0{_cg =PermOwner ;_fae :=make ([]byte ,len (_cfb )+8+48);_acb :=copy (_fae ,_cfb );_acb +=copy (_fae [_acb :],_cfd .O [40:48]);copy (_fae [_acb :],_cfd .U [0:48]);_afb =_fae ;_dfde =_cfd .OE ;_bbbc =_cfd .U [0:48];}else {_bdd ,_dee =_dbbd .alg11 (_cfd ,_cfb );if _dee ==nil &&len (_bdd )==0{_bdd ,_dee =_dbbd .alg11 (_cfd ,[]byte (""));};if _dee !=nil {return nil ,0,_dee ;}else if len (_bdd )==0{return nil ,0,nil ;};_cg =_cfd .P ;_baae :=make ([]byte ,len (_cfb )+8);_ecc :=copy (_baae ,_cfb );copy (_baae [_ecc :],_cfd .U [40:48]);_afb =_baae ;_dfde =_cfd .UE ;_bbbc =nil ;};if _acf :=_age ("\u0061\u006c\u00672\u0061","\u004b\u0065\u0079",32,_dfde );_acf !=nil {return nil ,0,_acf ;};_dfde =_dfde [:32];_aab ,_dee :=_dbbd .alg2b (_cfd .R ,_afb ,_cfb ,_bbbc );if _dee !=nil {return nil ,0,_dee ;};_acg ,_dee :=_c .NewCipher (_aab [:32]);if _dee !=nil {return nil ,0,_dee ;};_geg :=make ([]byte ,_c .BlockSize );_agd :=_a .NewCBCDecrypter (_acg ,_geg );_ccd :=make ([]byte ,32);_agd .CryptBlocks (_ccd ,_dfde );if _cfd .R ==5{return _ccd ,_cg ,nil ;};_dee =_dbbd .alg13 (_cfd ,_ccd );if _dee !=nil {return nil ,0,_dee ;};return _ccd ,_cg ,nil ;};func (_ge *ecbEncrypter )BlockSize ()int {return _ge ._gd };func _ee (_cb _a .Block )*ecb {return &ecb {_ea :_cb ,_gd :_cb .BlockSize ()}};func (_aba *ecbDecrypter )CryptBlocks (dst ,src []byte ){if len (src )%_aba ._gd !=0{_f .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");return ;};if len (dst )< len (src ){_f .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0064\u0065\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");return ;};for len (src )> 0{_aba ._ea .Decrypt (dst ,src [:_aba ._gd ]);src =src [_aba ._gd :];dst =dst [_aba ._gd :];};};

// GenerateParams generates and sets O and U parameters for the encryption dictionary.
// It expects R, P and EncryptMetadata fields to be set.
func (_geb stdHandlerR4 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){O ,_bba :=_geb .alg3 (d .R ,upass ,opass );if _bba !=nil {_f .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_bba );return nil ,_bba ;};d .O =O ;_f .Log .Trace ("\u0067\u0065\u006e\u0020\u004f\u003a\u0020\u0025\u0020\u0078",O );_bda :=_geb .alg2 (d ,upass );U ,_bba :=_geb .alg5 (_bda ,upass );if _bba !=nil {_f .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_bba );return nil ,_bba ;};d .U =U ;_f .Log .Trace ("\u0067\u0065\u006e\u0020\u0055\u003a\u0020\u0025\u0020\u0078",U );return _bda ,nil ;};

// NewHandlerR6 creates a new standard security handler for R=5 and R=6.
func NewHandlerR6 ()StdHandler {return stdHandlerR6 {}};func (_ce errInvalidField )Error ()string {return _ba .Sprintf ("\u0025s\u003a\u0020e\u0078\u0070\u0065\u0063t\u0065\u0064\u0020%\u0073\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0074o \u0062\u0065\u0020%\u0064\u0020b\u0079\u0074\u0065\u0073\u002c\u0020g\u006f\u0074 \u0025\u0064",_ce .Func ,_ce .Field ,_ce .Exp ,_ce .Got );};func (_efc stdHandlerR6 )alg13 (_afgf *StdEncryptDict ,_dge []byte )error {if _aabb :=_age ("\u0061\u006c\u00671\u0033","\u004b\u0065\u0079",32,_dge );_aabb !=nil {return _aabb ;};if _bged :=_age ("\u0061\u006c\u00671\u0033","\u0050\u0065\u0072m\u0073",16,_afgf .Perms );_bged !=nil {return _bged ;};_edg :=make ([]byte ,16);copy (_edg ,_afgf .Perms [:16]);_ae ,_fda :=_c .NewCipher (_dge [:32]);if _fda !=nil {return _fda ;};_gddf :=_ef (_ae );_gddf .CryptBlocks (_edg ,_edg );if !_be .Equal (_edg [9:12],[]byte ("\u0061\u0064\u0062")){return _ag .New ("\u0064\u0065\u0063o\u0064\u0065\u0064\u0020p\u0065\u0072\u006d\u0069\u0073\u0073\u0069o\u006e\u0073\u0020\u0061\u0072\u0065\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_dfdb :=Permissions (_g .LittleEndian .Uint32 (_edg [0:4]));if _dfdb !=_afgf .P {return _ag .New ("\u0070\u0065r\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066\u0061il\u0065\u0064");};var _fbcd bool ;if _edg [8]=='T'{_fbcd =true ;}else if _edg [8]=='F'{_fbcd =false ;}else {return _ag .New ("\u0064\u0065\u0063\u006f\u0064\u0065\u0064 \u006d\u0065\u0074a\u0064\u0061\u0074\u0061 \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u006c\u0061\u0067\u0020\u0069\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};if _fbcd !=_afgf .EncryptMetadata {return _ag .New ("\u006d\u0065t\u0061\u0064\u0061\u0074a\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e \u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066a\u0069\u006c\u0065\u0064");};return nil ;};func (_ece stdHandlerR4 )alg4 (_eaa []byte ,_cdd []byte )([]byte ,error ){_caf ,_deb :=_ga .NewCipher (_eaa );if _deb !=nil {return nil ,_ag .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_bdb :=[]byte (_eec );_baab :=make ([]byte ,len (_bdb ));_caf .XORKeyStream (_baab ,_bdb );return _baab ,nil ;};type ecbDecrypter ecb ;func (_eae stdHandlerR6 )alg11 (_cga *StdEncryptDict ,_gbba []byte )([]byte ,error ){if _afbf :=_age ("\u0061\u006c\u00671\u0031","\u0055",48,_cga .U );_afbf !=nil {return nil ,_afbf ;};_fcc :=make ([]byte ,len (_gbba )+8);_eea :=copy (_fcc ,_gbba );_eea +=copy (_fcc [_eea :],_cga .U [32:40]);_gba ,_bga :=_eae .alg2b (_cga .R ,_fcc ,_gbba ,nil );if _bga !=nil {return nil ,_bga ;};_gba =_gba [:32];if !_be .Equal (_gba ,_cga .U [:32]){return nil ,nil ;};return _gba ,nil ;};type errInvalidField struct{Func string ;Field string ;Exp int ;Got int ;};func (_cad stdHandlerR6 )alg8 (_ecb *StdEncryptDict ,_afga []byte ,_ffa []byte )error {if _ead :=_age ("\u0061\u006c\u0067\u0038","\u004b\u0065\u0079",32,_afga );_ead !=nil {return _ead ;};var _egb [16]byte ;if _ ,_fdef :=_da .ReadFull (_cc .Reader ,_egb [:]);_fdef !=nil {return _fdef ;};_caa :=_egb [0:8];_ddc :=_egb [8:16];_gdd :=make ([]byte ,len (_ffa )+len (_caa ));_efbc :=copy (_gdd ,_ffa );copy (_gdd [_efbc :],_caa );_dbd ,_ggg :=_cad .alg2b (_ecb .R ,_gdd ,_ffa ,nil );if _ggg !=nil {return _ggg ;};U :=make ([]byte ,len (_dbd )+len (_caa )+len (_ddc ));_efbc =copy (U ,_dbd [:32]);_efbc +=copy (U [_efbc :],_caa );copy (U [_efbc :],_ddc );_ecb .U =U ;_efbc =len (_ffa );copy (_gdd [_efbc :],_ddc );_dbd ,_ggg =_cad .alg2b (_ecb .R ,_gdd ,_ffa ,nil );if _ggg !=nil {return _ggg ;};_deg ,_ggg :=_gf (_dbd [:32]);if _ggg !=nil {return _ggg ;};_aag :=make ([]byte ,_c .BlockSize );_adb :=_a .NewCBCEncrypter (_deg ,_aag );UE :=make ([]byte ,32);_adb .CryptBlocks (UE ,_afga [:32]);_ecb .UE =UE ;return nil ;};func (_gabg stdHandlerR6 )alg12 (_fga *StdEncryptDict ,_eace []byte )([]byte ,error ){if _fef :=_age ("\u0061\u006c\u00671\u0032","\u0055",48,_fga .U );_fef !=nil {return nil ,_fef ;};if _acc :=_age ("\u0061\u006c\u00671\u0032","\u004f",48,_fga .O );_acc !=nil {return nil ,_acc ;};_ffaf :=make ([]byte ,len (_eace )+8+48);_dgg :=copy (_ffaf ,_eace );_dgg +=copy (_ffaf [_dgg :],_fga .O [32:40]);_dgg +=copy (_ffaf [_dgg :],_fga .U [0:48]);_deeg ,_dbdd :=_gabg .alg2b (_fga .R ,_ffaf ,_eace ,_fga .U [0:48]);if _dbdd !=nil {return nil ,_dbdd ;};_deeg =_deeg [:32];if !_be .Equal (_deeg ,_fga .O [:32]){return nil ,nil ;};return _deeg ,nil ;};func _gf (_egg []byte )(_a .Block ,error ){_cca ,_bdaf :=_c .NewCipher (_egg );if _bdaf !=nil {_f .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0063\u0072\u0065\u0061\u0074\u0065\u0020A\u0045\u0053\u0020\u0063\u0069p\u0068\u0065r\u003a\u0020\u0025\u0076",_bdaf );return nil ,_bdaf ;};return _cca ,nil ;};func _ef (_ad _a .Block )_a .BlockMode {return (*ecbDecrypter )(_ee (_ad ))};

// Allowed checks if a set of permissions can be granted.
func (_bf Permissions )Allowed (p2 Permissions )bool {return _bf &p2 ==p2 };

// Permissions is a bitmask of access permissions for a PDF file.
type Permissions uint32 ;func (_af *ecbDecrypter )BlockSize ()int {return _af ._gd };func (_eca stdHandlerR4 )alg6 (_fbc *StdEncryptDict ,_dg []byte )([]byte ,error ){var (_dfd []byte ;_fbe error ;);_cbb :=_eca .alg2 (_fbc ,_dg );if _fbc .R ==2{_dfd ,_fbe =_eca .alg4 (_cbb ,_dg );}else if _fbc .R >=3{_dfd ,_fbe =_eca .alg5 (_cbb ,_dg );}else {return nil ,_ag .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};if _fbe !=nil {return nil ,_fbe ;};_f .Log .Trace ("\u0063\u0068\u0065\u0063k:\u0020\u0025\u0020\u0078\u0020\u003d\u003d\u0020\u0025\u0020\u0078\u0020\u003f",string (_dfd ),string (_fbc .U ));_edf :=_dfd ;_bbb :=_fbc .U ;if _fbc .R >=3{if len (_edf )> 16{_edf =_edf [0:16];};if len (_bbb )> 16{_bbb =_bbb [0:16];};};if !_be .Equal (_edf ,_bbb ){return nil ,nil ;};return _cbb ,nil ;};func _age (_fg ,_ed string ,_ca int ,_bb []byte )error {if len (_bb )< _ca {return errInvalidField {Func :_fg ,Field :_ed ,Exp :_ca ,Got :len (_bb )};};return nil ;};func (_afg stdHandlerR6 )alg2b (R int ,_bafb ,_ggd ,_eece []byte )([]byte ,error ){if R ==5{return _ffe (_bafb );};return _gab (_bafb ,_ggd ,_eece );};const _eec ="\x28\277\116\136\x4e\x75\x8a\x41\x64\000\x4e\x56\377"+"\xfa\001\010\056\x2e\x00\xb6\xd0\x68\076\x80\x2f\014"+"\251\xfe\x64\x53\x69\172";var _ StdHandler =stdHandlerR4 {};func (stdHandlerR4 )paddedPass (_afd []byte )[]byte {_df :=make ([]byte ,32);_fgg :=copy (_df ,_afd );for ;_fgg < 32;_fgg ++{_df [_fgg ]=_eec [_fgg -len (_afd )];};return _df ;};func (_gfb stdHandlerR6 )alg10 (_add *StdEncryptDict ,_cde []byte )error {if _bgd :=_age ("\u0061\u006c\u00671\u0030","\u004b\u0065\u0079",32,_cde );_bgd !=nil {return _bgd ;};_bdc :=uint64 (uint32 (_add .P ))|(_aa .MaxUint32 <<32);Perms :=make ([]byte ,16);_g .LittleEndian .PutUint64 (Perms [:8],_bdc );if _add .EncryptMetadata {Perms [8]='T';}else {Perms [8]='F';};copy (Perms [9:12],"\u0061\u0064\u0062");if _ ,_fgeb :=_da .ReadFull (_cc .Reader ,Perms [12:16]);_fgeb !=nil {return _fgeb ;};_agb ,_ddd :=_gf (_cde [:32]);if _ddd !=nil {return _ddd ;};_dbbe :=_eb (_agb );_dbbe .CryptBlocks (Perms ,Perms );_add .Perms =Perms [:16];return nil ;};func (_fee stdHandlerR6 )alg9 (_ccg *StdEncryptDict ,_gaba []byte ,_eadc []byte )error {if _gbgg :=_age ("\u0061\u006c\u0067\u0039","\u004b\u0065\u0079",32,_gaba );_gbgg !=nil {return _gbgg ;};if _fce :=_age ("\u0061\u006c\u0067\u0039","\u0055",48,_ccg .U );_fce !=nil {return _fce ;};var _aagg [16]byte ;if _ ,_cbae :=_da .ReadFull (_cc .Reader ,_aagg [:]);_cbae !=nil {return _cbae ;};_bdf :=_aagg [0:8];_bfd :=_aagg [8:16];_ecge :=_ccg .U [:48];_bfce :=make ([]byte ,len (_eadc )+len (_bdf )+len (_ecge ));_gdb :=copy (_bfce ,_eadc );_gdb +=copy (_bfce [_gdb :],_bdf );_gdb +=copy (_bfce [_gdb :],_ecge );_gcgg ,_cac :=_fee .alg2b (_ccg .R ,_bfce ,_eadc ,_ecge );if _cac !=nil {return _cac ;};O :=make ([]byte ,len (_gcgg )+len (_bdf )+len (_bfd ));_gdb =copy (O ,_gcgg [:32]);_gdb +=copy (O [_gdb :],_bdf );_gdb +=copy (O [_gdb :],_bfd );_ccg .O =O ;_gdb =len (_eadc );_gdb +=copy (_bfce [_gdb :],_bfd );_gcgg ,_cac =_fee .alg2b (_ccg .R ,_bfce ,_eadc ,_ecge );if _cac !=nil {return _cac ;};_ccaf ,_cac :=_gf (_gcgg [:32]);if _cac !=nil {return _cac ;};_bed :=make ([]byte ,_c .BlockSize );_cgf :=_a .NewCBCEncrypter (_ccaf ,_bed );OE :=make ([]byte ,32);_cgf .CryptBlocks (OE ,_gaba [:32]);_ccg .OE =OE ;return nil ;};

// StdHandler is an interface for standard security handlers.
type StdHandler interface{

// GenerateParams uses owner and user passwords to set encryption parameters and generate an encryption key.
// It assumes that R, P and EncryptMetadata are already set.
GenerateParams (_ff *StdEncryptDict ,_de ,_bg []byte )([]byte ,error );

// Authenticate uses encryption dictionary parameters and the password to calculate
// the document encryption key. It also returns permissions that should be granted to a user.
// In case of failed authentication, it returns empty key and zero permissions with no error.
Authenticate (_fa *StdEncryptDict ,_ffb []byte )([]byte ,Permissions ,error );};func (_cag stdHandlerR4 )alg3Key (R int ,_dc []byte )[]byte {_gcg :=_dd .New ();_abc :=_cag .paddedPass (_dc );_gcg .Write (_abc );if R >=3{for _fge :=0;_fge < 50;_fge ++{_fe :=_gcg .Sum (nil );_gcg =_dd .New ();_gcg .Write (_fe );};};_baa :=_gcg .Sum (nil );if R ==2{_baa =_baa [0:5];}else {_baa =_baa [0:_cag .Length /8];};return _baa ;};

// Authenticate implements StdHandler interface.
func (_ded stdHandlerR6 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){return _ded .alg2a (d ,pass );};func _beg (_geba []byte ,_bc int ){_fec :=_bc ;for _fec < len (_geba ){copy (_geba [_fec :],_geba [:_fec ]);_fec *=2;};};

// GenerateParams is the algorithm opposite to alg2a (R>=5).
// It generates U,O,UE,OE,Perms fields using AESv3 encryption.
// There is no algorithm number assigned to this function in the spec.
// It expects R, P and EncryptMetadata fields to be set.
func (_ffg stdHandlerR6 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){_efde :=make ([]byte ,32);if _ ,_bee :=_da .ReadFull (_cc .Reader ,_efde );_bee !=nil {return nil ,_bee ;};d .U =nil ;d .O =nil ;d .UE =nil ;d .OE =nil ;d .Perms =nil ;if len (upass )> 127{upass =upass [:127];};if len (opass )> 127{opass =opass [:127];};if _dff :=_ffg .alg8 (d ,_efde ,upass );_dff !=nil {return nil ,_dff ;};if _fcg :=_ffg .alg9 (d ,_efde ,opass );_fcg !=nil {return nil ,_fcg ;};if d .R ==5{return _efde ,nil ;};if _eeg :=_ffg .alg10 (d ,_efde );_eeg !=nil {return nil ,_eeg ;};return _efde ,nil ;};