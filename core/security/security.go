//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package security ;import (_eb "bytes";_ce "crypto/aes";_g "crypto/cipher";_da "crypto/md5";_eg "crypto/rand";_cgg "crypto/rc4";_dd "crypto/sha256";_a "crypto/sha512";_ca "encoding/binary";_cg "errors";_b "fmt";_f "github.com/unidoc/unipdf/v3/common";_c "hash";
_d "io";_df "math";);func _gbff (_bec []byte ,_dde int ){_aaf :=_dde ;for _aaf < len (_bec ){copy (_bec [_aaf :],_bec [:_aaf ]);_aaf *=2;};};func _af (_aa _g .Block )*ecb {return &ecb {_ag :_aa ,_dda :_aa .BlockSize ()}};func (_fc stdHandlerR4 )alg5 (_ceg []byte ,_egc []byte )([]byte ,error ){_deb :=_da .New ();
_deb .Write ([]byte (_db ));_deb .Write ([]byte (_fc .ID0 ));_dbf :=_deb .Sum (nil );_f .Log .Trace ("\u0061\u006c\u0067\u0035");_f .Log .Trace ("\u0065k\u0065\u0079\u003a\u0020\u0025\u0020x",_ceg );_f .Log .Trace ("\u0049D\u003a\u0020\u0025\u0020\u0078",_fc .ID0 );
if len (_dbf )!=16{return nil ,_cg .New ("\u0068a\u0073\u0068\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074\u0020\u0031\u0036\u0020\u0062\u0079\u0074\u0065\u0073");};_dbd ,_eba :=_cgg .NewCipher (_ceg );if _eba !=nil {return nil ,_cg .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_dag :=make ([]byte ,16);_dbd .XORKeyStream (_dag ,_dbf );_bbf :=make ([]byte ,len (_ceg ));for _ebe :=0;_ebe < 19;_ebe ++{for _aaa :=0;_aaa < len (_ceg );_aaa ++{_bbf [_aaa ]=_ceg [_aaa ]^byte (_ebe +1);};_dbd ,_eba =_cgg .NewCipher (_bbf );if _eba !=nil {return nil ,_cg .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_dbd .XORKeyStream (_dag ,_dag );_f .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u002c\u0020\u0065\u006b\u0065\u0079:\u0020\u0025\u0020\u0078",_ebe ,_bbf );_f .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0020\u0078",_ebe ,_dag );
};_fee :=make ([]byte ,32);for _cfg :=0;_cfg < 16;_cfg ++{_fee [_cfg ]=_dag [_cfg ];};_ ,_eba =_eg .Read (_fee [16:32]);if _eba !=nil {return nil ,_cg .New ("\u0066a\u0069\u006c\u0065\u0064 \u0074\u006f\u0020\u0067\u0065n\u0020r\u0061n\u0064\u0020\u006e\u0075\u006d\u0062\u0065r");
};return _fee ,nil ;};type ecb struct{_ag _g .Block ;_dda int ;};

// StdEncryptDict is a set of additional fields used in standard encryption dictionary.
type StdEncryptDict struct{R int ;P Permissions ;EncryptMetadata bool ;O ,U []byte ;OE ,UE []byte ;Perms []byte ;};type stdHandlerR6 struct{};func (_cd *ecbEncrypter )BlockSize ()int {return _cd ._dda };func _cba (_gbf []byte )([]byte ,error ){_aac :=_dd .New ();
_aac .Write (_gbf );return _aac .Sum (nil ),nil ;};

// AuthEvent is an event type that triggers authentication.
type AuthEvent string ;func (_ef stdHandlerR4 )alg3 (R int ,_edgd ,_egf []byte )([]byte ,error ){var _eeg []byte ;if len (_egf )> 0{_eeg =_ef .alg3Key (R ,_egf );}else {_eeg =_ef .alg3Key (R ,_edgd );};_fe ,_eac :=_cgg .NewCipher (_eeg );if _eac !=nil {return nil ,_cg .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_fed :=_ef .paddedPass (_edgd );_ac :=make ([]byte ,len (_fed ));_fe .XORKeyStream (_ac ,_fed );if R >=3{_bcb :=make ([]byte ,len (_eeg ));for _fff :=0;_fff < 19;_fff ++{for _cad :=0;_cad < len (_eeg );_cad ++{_bcb [_cad ]=_eeg [_cad ]^byte (_fff +1);
};_bb ,_dg :=_cgg .NewCipher (_bcb );if _dg !=nil {return nil ,_cg .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_bb .XORKeyStream (_ac ,_ac );};};return _ac ,nil ;};func (_de stdHandlerR4 )alg2 (_cc *StdEncryptDict ,_fbg []byte )[]byte {_f .Log .Trace ("\u0061\u006c\u0067\u0032");
_fbe :=_de .paddedPass (_fbg );_fbb :=_da .New ();_fbb .Write (_fbe );_fbb .Write (_cc .O );var _gc [4]byte ;_ca .LittleEndian .PutUint32 (_gc [:],uint32 (_cc .P ));_fbb .Write (_gc [:]);_f .Log .Trace ("\u0067o\u0020\u0050\u003a\u0020\u0025\u0020x",_gc );
_fbb .Write ([]byte (_de .ID0 ));_f .Log .Trace ("\u0074\u0068\u0069\u0073\u002e\u0052\u0020\u003d\u0020\u0025d\u0020\u0065\u006e\u0063\u0072\u0079\u0070t\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061\u0020\u0025\u0076",_cc .R ,_cc .EncryptMetadata );
if (_cc .R >=4)&&!_cc .EncryptMetadata {_fbb .Write ([]byte {0xff,0xff,0xff,0xff});};_gea :=_fbb .Sum (nil );if _cc .R >=3{_fbb =_da .New ();for _gebe :=0;_gebe < 50;_gebe ++{_fbb .Reset ();_fbb .Write (_gea [0:_de .Length /8]);_gea =_fbb .Sum (nil );};
};if _cc .R >=3{return _gea [0:_de .Length /8];};return _gea [0:5];};type stdHandlerR4 struct{Length int ;ID0 string ;};

// Authenticate implements StdHandler interface.
func (_edb stdHandlerR6 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){return _edb .alg2a (d ,pass );};

// NewHandlerR6 creates a new standard security handler for R=5 and R=6.
func NewHandlerR6 ()StdHandler {return stdHandlerR6 {}};func (_fedc stdHandlerR6 )alg2a (_eag *StdEncryptDict ,_dff []byte )([]byte ,Permissions ,error ){if _abc :=_ge ("\u0061\u006c\u00672\u0061","\u004f",48,_eag .O );_abc !=nil {return nil ,0,_abc ;};
if _be :=_ge ("\u0061\u006c\u00672\u0061","\u0055",48,_eag .U );_be !=nil {return nil ,0,_be ;};if len (_dff )> 127{_dff =_dff [:127];};_bbfc ,_bee :=_fedc .alg12 (_eag ,_dff );if _bee !=nil {return nil ,0,_bee ;};var (_caa []byte ;_gbg []byte ;_age []byte ;
);var _gag Permissions ;if len (_bbfc )!=0{_gag =PermOwner ;_ebg :=make ([]byte ,len (_dff )+8+48);_gef :=copy (_ebg ,_dff );_gef +=copy (_ebg [_gef :],_eag .O [40:48]);copy (_ebg [_gef :],_eag .U [0:48]);_caa =_ebg ;_gbg =_eag .OE ;_age =_eag .U [0:48];
}else {_bbfc ,_bee =_fedc .alg11 (_eag ,_dff );if _bee ==nil &&len (_bbfc )==0{_bbfc ,_bee =_fedc .alg11 (_eag ,[]byte (""));};if _bee !=nil {return nil ,0,_bee ;}else if len (_bbfc )==0{return nil ,0,nil ;};_gag =_eag .P ;_edgdd :=make ([]byte ,len (_dff )+8);
_bce :=copy (_edgdd ,_dff );copy (_edgdd [_bce :],_eag .U [40:48]);_caa =_edgdd ;_gbg =_eag .UE ;_age =nil ;};if _bgf :=_ge ("\u0061\u006c\u00672\u0061","\u004b\u0065\u0079",32,_gbg );_bgf !=nil {return nil ,0,_bgf ;};_gbg =_gbg [:32];_eacg ,_bee :=_fedc .alg2b (_eag .R ,_caa ,_dff ,_age );
if _bee !=nil {return nil ,0,_bee ;};_bgg ,_bee :=_ce .NewCipher (_eacg [:32]);if _bee !=nil {return nil ,0,_bee ;};_abe :=make ([]byte ,_ce .BlockSize );_cggf :=_g .NewCBCDecrypter (_bgg ,_abe );_bad :=make ([]byte ,32);_cggf .CryptBlocks (_bad ,_gbg );
if _eag .R ==5{return _bad ,_gag ,nil ;};_bee =_fedc .alg13 (_eag ,_bad );if _bee !=nil {return nil ,0,_bee ;};return _bad ,_gag ,nil ;};var _ StdHandler =stdHandlerR6 {};const (EventDocOpen =AuthEvent ("\u0044o\u0063\u004f\u0070\u0065\u006e");EventEFOpen =AuthEvent ("\u0045\u0046\u004f\u0070\u0065\u006e");
);

// Allowed checks if a set of permissions can be granted.
func (_fb Permissions )Allowed (p2 Permissions )bool {return _fb &p2 ==p2 };var _ StdHandler =stdHandlerR4 {};func (_dfe errInvalidField )Error ()string {return _b .Sprintf ("\u0025s\u003a\u0020e\u0078\u0070\u0065\u0063t\u0065\u0064\u0020%\u0073\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0074o \u0062\u0065\u0020%\u0064\u0020b\u0079\u0074\u0065\u0073\u002c\u0020g\u006f\u0074 \u0025\u0064",_dfe .Func ,_dfe .Field ,_dfe .Exp ,_dfe .Got );
};type ecbEncrypter ecb ;func _ded (_bbd ,_ege ,_ad []byte )([]byte ,error ){var (_cdd ,_geg ,_gfgg _c .Hash ;);_cdd =_dd .New ();_aef :=make ([]byte ,64);_eff :=_cdd ;_eff .Write (_bbd );K :=_eff .Sum (_aef [:0]);_egfb :=make ([]byte ,64*(127+64+48));
_cde :=func (_eae int )([]byte ,error ){_daf :=len (_ege )+len (K )+len (_ad );_bcba :=_egfb [:_daf ];_abef :=copy (_bcba ,_ege );_abef +=copy (_bcba [_abef :],K [:]);_abef +=copy (_bcba [_abef :],_ad );if _abef !=_daf {_f .Log .Error ("E\u0052\u0052\u004f\u0052\u003a\u0020u\u006e\u0065\u0078\u0070\u0065\u0063t\u0065\u0064\u0020\u0072\u006f\u0075\u006ed\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0073\u0069\u007ae\u002e");
return nil ,_cg .New ("\u0077\u0072\u006f\u006e\u0067\u0020\u0073\u0069\u007a\u0065");};K1 :=_egfb [:_daf *64];_gbff (K1 ,_daf );_eaa ,_bgc :=_aea (K [0:16]);if _bgc !=nil {return nil ,_bgc ;};_cec :=_g .NewCBCEncrypter (_eaa ,K [16:32]);_cec .CryptBlocks (K1 ,K1 );
E :=K1 ;_eagc :=0;for _egd :=0;_egd < 16;_egd ++{_eagc +=int (E [_egd ]%3);};var _ced _c .Hash ;switch _eagc %3{case 0:_ced =_cdd ;case 1:if _geg ==nil {_geg =_a .New384 ();};_ced =_geg ;case 2:if _gfgg ==nil {_gfgg =_a .New ();};_ced =_gfgg ;};_ced .Reset ();
_ced .Write (E );K =_ced .Sum (_aef [:0]);return E ,nil ;};for _ecf :=0;;{E ,_fdf :=_cde (_ecf );if _fdf !=nil {return nil ,_fdf ;};_ebeb :=E [len (E )-1];_ecf ++;if _ecf >=64&&_ebeb <=uint8 (_ecf -32){break ;};};return K [:32],nil ;};type errInvalidField struct{Func string ;
Field string ;Exp int ;Got int ;};const _db ="\x28\277\116\136\x4e\x75\x8a\x41\x64\000\x4e\x56\377"+"\xfa\001\010\056\x2e\x00\xb6\xd0\x68\076\x80\x2f\014"+"\251\xfe\x64\x53\x69\172";func (_bcea stdHandlerR6 )alg12 (_aeb *StdEncryptDict ,_gba []byte )([]byte ,error ){if _cafe :=_ge ("\u0061\u006c\u00671\u0032","\u0055",48,_aeb .U );
_cafe !=nil {return nil ,_cafe ;};if _gage :=_ge ("\u0061\u006c\u00671\u0032","\u004f",48,_aeb .O );_gage !=nil {return nil ,_gage ;};_cafb :=make ([]byte ,len (_gba )+8+48);_cgb :=copy (_cafb ,_gba );_cgb +=copy (_cafb [_cgb :],_aeb .O [32:40]);_cgb +=copy (_cafb [_cgb :],_aeb .U [0:48]);
_aebg ,_eeb :=_bcea .alg2b (_aeb .R ,_cafb ,_gba ,_aeb .U [0:48]);if _eeb !=nil {return nil ,_eeb ;};_aebg =_aebg [:32];if !_eb .Equal (_aebg ,_aeb .O [:32]){return nil ,nil ;};return _aebg ,nil ;};func (_dfef stdHandlerR4 )alg4 (_fbee []byte ,_bg []byte )([]byte ,error ){_ebb ,_fg :=_cgg .NewCipher (_fbee );
if _fg !=nil {return nil ,_cg .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_bdb :=[]byte (_db );_ae :=make ([]byte ,len (_bdb ));_ebb .XORKeyStream (_ae ,_bdb );return _ae ,nil ;};func (_ddae stdHandlerR4 )alg3Key (R int ,_dec []byte )[]byte {_fa :=_da .New ();
_gfg :=_ddae .paddedPass (_dec );_fa .Write (_gfg );if R >=3{for _ba :=0;_ba < 50;_ba ++{_ec :=_fa .Sum (nil );_fa =_da .New ();_fa .Write (_ec );};};_ea :=_fa .Sum (nil );if R ==2{_ea =_ea [0:5];}else {_ea =_ea [0:_ddae .Length /8];};return _ea ;};

// Authenticate implements StdHandler interface.
func (_bdf stdHandlerR4 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){_f .Log .Trace ("\u0044\u0065b\u0075\u0067\u0067\u0069n\u0067\u0020a\u0075\u0074\u0068\u0065\u006e\u0074\u0069\u0063a\u0074\u0069\u006f\u006e\u0020\u002d\u0020\u006f\u0077\u006e\u0065\u0072 \u0070\u0061\u0073\u0073");
_fedg ,_acd :=_bdf .alg7 (d ,pass );if _acd !=nil {return nil ,0,_acd ;};if _fedg !=nil {_f .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _fedg ,PermOwner ,nil ;
};_f .Log .Trace ("\u0044\u0065bu\u0067\u0067\u0069n\u0067\u0020\u0061\u0075the\u006eti\u0063\u0061\u0074\u0069\u006f\u006e\u0020- \u0075\u0073\u0065\u0072\u0020\u0070\u0061s\u0073");_fedg ,_acd =_bdf .alg6 (d ,pass );if _acd !=nil {return nil ,0,_acd ;
};if _fedg !=nil {_f .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _fedg ,d .P ,nil ;};return nil ,0,nil ;};func (_eec stdHandlerR6 )alg9 (_dfb *StdEncryptDict ,_eege []byte ,_ccaa []byte )error {if _ada :=_ge ("\u0061\u006c\u0067\u0039","\u004b\u0065\u0079",32,_eege );
_ada !=nil {return _ada ;};if _bdfb :=_ge ("\u0061\u006c\u0067\u0039","\u0055",48,_dfb .U );_bdfb !=nil {return _bdfb ;};var _bbc [16]byte ;if _ ,_gbef :=_d .ReadFull (_eg .Reader ,_bbc [:]);_gbef !=nil {return _gbef ;};_bff :=_bbc [0:8];_cdb :=_bbc [8:16];
_acdc :=_dfb .U [:48];_deaf :=make ([]byte ,len (_ccaa )+len (_bff )+len (_acdc ));_adad :=copy (_deaf ,_ccaa );_adad +=copy (_deaf [_adad :],_bff );_adad +=copy (_deaf [_adad :],_acdc );_effc ,_ebbf :=_eec .alg2b (_dfb .R ,_deaf ,_ccaa ,_acdc );if _ebbf !=nil {return _ebbf ;
};O :=make ([]byte ,len (_effc )+len (_bff )+len (_cdb ));_adad =copy (O ,_effc [:32]);_adad +=copy (O [_adad :],_bff );_adad +=copy (O [_adad :],_cdb );_dfb .O =O ;_adad =len (_ccaa );_adad +=copy (_deaf [_adad :],_cdb );_effc ,_ebbf =_eec .alg2b (_dfb .R ,_deaf ,_ccaa ,_acdc );
if _ebbf !=nil {return _ebbf ;};_gead ,_ebbf :=_aea (_effc [:32]);if _ebbf !=nil {return _ebbf ;};_adc :=make ([]byte ,_ce .BlockSize );_bde :=_g .NewCBCEncrypter (_gead ,_adc );OE :=make ([]byte ,32);_bde .CryptBlocks (OE ,_eege [:32]);_dfb .OE =OE ;return nil ;
};

// NewHandlerR4 creates a new standard security handler for R<=4.
func NewHandlerR4 (id0 string ,length int )StdHandler {return stdHandlerR4 {ID0 :id0 ,Length :length }};func (_egfee stdHandlerR6 )alg10 (_dfbf *StdEncryptDict ,_cdbe []byte )error {if _cef :=_ge ("\u0061\u006c\u00671\u0030","\u004b\u0065\u0079",32,_cdbe );
_cef !=nil {return _cef ;};_bbdb :=uint64 (uint32 (_dfbf .P ))|(_df .MaxUint32 <<32);Perms :=make ([]byte ,16);_ca .LittleEndian .PutUint64 (Perms [:8],_bbdb );if _dfbf .EncryptMetadata {Perms [8]='T';}else {Perms [8]='F';};copy (Perms [9:12],"\u0061\u0064\u0062");
if _ ,_gcga :=_d .ReadFull (_eg .Reader ,Perms [12:16]);_gcga !=nil {return _gcga ;};_afe ,_febe :=_aea (_cdbe [:32]);if _febe !=nil {return _febe ;};_aae :=_ff (_afe );_aae .CryptBlocks (Perms ,Perms );_dfbf .Perms =Perms [:16];return nil ;};

// Permissions is a bitmask of access permissions for a PDF file.
type Permissions uint32 ;type ecbDecrypter ecb ;func (_cb *ecbDecrypter )BlockSize ()int {return _cb ._dda };func _ge (_gfd ,_dc string ,_caf int ,_edg []byte )error {if len (_edg )< _caf {return errInvalidField {Func :_gfd ,Field :_dc ,Exp :_caf ,Got :len (_edg )};
};return nil ;};func (_ede stdHandlerR6 )alg11 (_bag *StdEncryptDict ,_ebac []byte )([]byte ,error ){if _egdc :=_ge ("\u0061\u006c\u00671\u0031","\u0055",48,_bag .U );_egdc !=nil {return nil ,_egdc ;};_efb :=make ([]byte ,len (_ebac )+8);_ade :=copy (_efb ,_ebac );
_ade +=copy (_efb [_ade :],_bag .U [32:40]);_dbc ,_edc :=_ede .alg2b (_bag .R ,_efb ,_ebac ,nil );if _edc !=nil {return nil ,_edc ;};_dbc =_dbc [:32];if !_eb .Equal (_dbc ,_bag .U [:32]){return nil ,nil ;};return _dbc ,nil ;};func _ebc (_bd _g .Block )_g .BlockMode {return (*ecbDecrypter )(_af (_bd ))};
func (_dgd stdHandlerR6 )alg2b (R int ,_bcg ,_afg ,_gbe []byte )([]byte ,error ){if R ==5{return _cba (_bcg );};return _ded (_bcg ,_afg ,_gbe );};func (_fd *ecbEncrypter )CryptBlocks (dst ,src []byte ){if len (src )%_fd ._dda !=0{_f .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_f .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_fd ._ag .Encrypt (dst ,src [:_fd ._dda ]);src =src [_fd ._dda :];dst =dst [_fd ._dda :];};};

// StdHandler is an interface for standard security handlers.
type StdHandler interface{

// GenerateParams uses owner and user passwords to set encryption parameters and generate an encryption key.
// It assumes that R, P and EncryptMetadata are already set.
GenerateParams (_ddag *StdEncryptDict ,_bda ,_gf []byte )([]byte ,error );

// Authenticate uses encryption dictionary parameters and the password to calculate
// the document encryption key. It also returns permissions that should be granted to a user.
// In case of failed authentication, it returns empty key and zero permissions with no error.
Authenticate (_cab *StdEncryptDict ,_ab []byte )([]byte ,Permissions ,error );};

// GenerateParams generates and sets O and U parameters for the encryption dictionary.
// It expects R, P and EncryptMetadata fields to be set.
func (_edff stdHandlerR4 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){O ,_gb :=_edff .alg3 (d .R ,upass ,opass );if _gb !=nil {_f .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_gb );
return nil ,_gb ;};d .O =O ;_f .Log .Trace ("\u0067\u0065\u006e\u0020\u004f\u003a\u0020\u0025\u0020\u0078",O );_gac :=_edff .alg2 (d ,upass );U ,_gb :=_edff .alg5 (_gac ,upass );if _gb !=nil {_f .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_gb );
return nil ,_gb ;};d .U =U ;_f .Log .Trace ("\u0067\u0065\u006e\u0020\u0055\u003a\u0020\u0025\u0020\u0078",U );return _gac ,nil ;};func (stdHandlerR4 )paddedPass (_cf []byte )[]byte {_geb :=make ([]byte ,32);_edf :=copy (_geb ,_cf );for ;_edf < 32;_edf ++{_geb [_edf ]=_db [_edf -len (_cf )];
};return _geb ;};func (_feba stdHandlerR6 )alg13 (_gd *StdEncryptDict ,_eggd []byte )error {if _bbg :=_ge ("\u0061\u006c\u00671\u0033","\u004b\u0065\u0079",32,_eggd );_bbg !=nil {return _bbg ;};if _ebaf :=_ge ("\u0061\u006c\u00671\u0033","\u0050\u0065\u0072m\u0073",16,_gd .Perms );
_ebaf !=nil {return _ebaf ;};_ggb :=make ([]byte ,16);copy (_ggb ,_gd .Perms [:16]);_gcf ,_cgbe :=_ce .NewCipher (_eggd [:32]);if _cgbe !=nil {return _cgbe ;};_gegc :=_ebc (_gcf );_gegc .CryptBlocks (_ggb ,_ggb );if !_eb .Equal (_ggb [9:12],[]byte ("\u0061\u0064\u0062")){return _cg .New ("\u0064\u0065\u0063o\u0064\u0065\u0064\u0020p\u0065\u0072\u006d\u0069\u0073\u0073\u0069o\u006e\u0073\u0020\u0061\u0072\u0065\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};_bgbc :=Permissions (_ca .LittleEndian .Uint32 (_ggb [0:4]));if _bgbc !=_gd .P {return _cg .New ("\u0070\u0065r\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066\u0061il\u0065\u0064");
};var _aee bool ;if _ggb [8]=='T'{_aee =true ;}else if _ggb [8]=='F'{_aee =false ;}else {return _cg .New ("\u0064\u0065\u0063\u006f\u0064\u0065\u0064 \u006d\u0065\u0074a\u0064\u0061\u0074\u0061 \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u006c\u0061\u0067\u0020\u0069\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};if _aee !=_gd .EncryptMetadata {return _cg .New ("\u006d\u0065t\u0061\u0064\u0061\u0074a\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e \u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066a\u0069\u006c\u0065\u0064");
};return nil ;};func (_ead stdHandlerR4 )alg6 (_fce *StdEncryptDict ,_dae []byte )([]byte ,error ){var (_ccc []byte ;_egfe error ;);_gg :=_ead .alg2 (_fce ,_dae );if _fce .R ==2{_ccc ,_egfe =_ead .alg4 (_gg ,_dae );}else if _fce .R >=3{_ccc ,_egfe =_ead .alg5 (_gg ,_dae );
}else {return nil ,_cg .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};if _egfe !=nil {return nil ,_egfe ;};_f .Log .Trace ("\u0063\u0068\u0065\u0063k:\u0020\u0025\u0020\u0078\u0020\u003d\u003d\u0020\u0025\u0020\u0078\u0020\u003f",string (_ccc ),string (_fce .U ));
_gcg :=_ccc ;_gfa :=_fce .U ;if _fce .R >=3{if len (_gcg )> 16{_gcg =_gcg [0:16];};if len (_gfa )> 16{_gfa =_gfa [0:16];};};if !_eb .Equal (_gcg ,_gfa ){return nil ,nil ;};return _gg ,nil ;};const (PermOwner =Permissions (_df .MaxUint32 );PermPrinting =Permissions (1<<2);
PermModify =Permissions (1<<3);PermExtractGraphics =Permissions (1<<4);PermAnnotate =Permissions (1<<5);PermFillForms =Permissions (1<<8);PermDisabilityExtract =Permissions (1<<9);PermRotateInsert =Permissions (1<<10);PermFullPrintQuality =Permissions (1<<11);
);func _ff (_ed _g .Block )_g .BlockMode {return (*ecbEncrypter )(_af (_ed ))};

// GenerateParams is the algorithm opposite to alg2a (R>=5).
// It generates U,O,UE,OE,Perms fields using AESv3 encryption.
// There is no algorithm number assigned to this function in the spec.
// It expects R, P and EncryptMetadata fields to be set.
func (_ecg stdHandlerR6 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){_gae :=make ([]byte ,32);if _ ,_cbg :=_d .ReadFull (_eg .Reader ,_gae );_cbg !=nil {return nil ,_cbg ;};d .U =nil ;d .O =nil ;d .UE =nil ;d .OE =nil ;d .Perms =nil ;
if len (upass )> 127{upass =upass [:127];};if len (opass )> 127{opass =opass [:127];};if _bba :=_ecg .alg8 (d ,_gae ,upass );_bba !=nil {return nil ,_bba ;};if _eadg :=_ecg .alg9 (d ,_gae ,opass );_eadg !=nil {return nil ,_eadg ;};if d .R ==5{return _gae ,nil ;
};if _dac :=_ecg .alg10 (d ,_gae );_dac !=nil {return nil ,_dac ;};return _gae ,nil ;};func _aea (_fac []byte )(_g .Block ,error ){_fae ,_bbb :=_ce .NewCipher (_fac );if _bbb !=nil {_f .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0063\u0072\u0065\u0061\u0074\u0065\u0020A\u0045\u0053\u0020\u0063\u0069p\u0068\u0065r\u003a\u0020\u0025\u0076",_bbb );
return nil ,_bbb ;};return _fae ,nil ;};func (_gcgg stdHandlerR6 )alg8 (_dbda *StdEncryptDict ,_bcc []byte ,_ecae []byte )error {if _egcg :=_ge ("\u0061\u006c\u0067\u0038","\u004b\u0065\u0079",32,_bcc );_egcg !=nil {return _egcg ;};var _feg [16]byte ;if _ ,_gaf :=_d .ReadFull (_eg .Reader ,_feg [:]);
_gaf !=nil {return _gaf ;};_aaaf :=_feg [0:8];_dad :=_feg [8:16];_dcca :=make ([]byte ,len (_ecae )+len (_aaaf ));_ffb :=copy (_dcca ,_ecae );copy (_dcca [_ffb :],_aaaf );_gaa ,_dgc :=_gcgg .alg2b (_dbda .R ,_dcca ,_ecae ,nil );if _dgc !=nil {return _dgc ;
};U :=make ([]byte ,len (_gaa )+len (_aaaf )+len (_dad ));_ffb =copy (U ,_gaa [:32]);_ffb +=copy (U [_ffb :],_aaaf );copy (U [_ffb :],_dad );_dbda .U =U ;_ffb =len (_ecae );copy (_dcca [_ffb :],_dad );_gaa ,_dgc =_gcgg .alg2b (_dbda .R ,_dcca ,_ecae ,nil );
if _dgc !=nil {return _dgc ;};_fcb ,_dgc :=_aea (_gaa [:32]);if _dgc !=nil {return _dgc ;};_eea :=make ([]byte ,_ce .BlockSize );_dea :=_g .NewCBCEncrypter (_fcb ,_eea );UE :=make ([]byte ,32);_dea .CryptBlocks (UE ,_bcc [:32]);_dbda .UE =UE ;return nil ;
};func (_ee *ecbDecrypter )CryptBlocks (dst ,src []byte ){if len (src )%_ee ._dda !=0{_f .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_f .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0064\u0065\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_ee ._ag .Decrypt (dst ,src [:_ee ._dda ]);src =src [_ee ._dda :];dst =dst [_ee ._dda :];};};func (_dcc stdHandlerR4 )alg7 (_feb *StdEncryptDict ,_ga []byte )([]byte ,error ){_cca :=_dcc .alg3Key (_feb .R ,_ga );_efc :=make ([]byte ,len (_feb .O ));
if _feb .R ==2{_ffd ,_cbd :=_cgg .NewCipher (_cca );if _cbd !=nil {return nil ,_cg .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_ffd .XORKeyStream (_efc ,_feb .O );}else if _feb .R >=3{_dcce :=append ([]byte {},_feb .O ...);
for _egg :=0;_egg < 20;_egg ++{_agd :=append ([]byte {},_cca ...);for _cag :=0;_cag < len (_cca );_cag ++{_agd [_cag ]^=byte (19-_egg );};_gge ,_bf :=_cgg .NewCipher (_agd );if _bf !=nil {return nil ,_cg .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");
};_gge .XORKeyStream (_efc ,_dcce );_dcce =append ([]byte {},_efc ...);};}else {return nil ,_cg .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};_cac ,_eca :=_dcc .alg6 (_feb ,_efc );if _eca !=nil {return nil ,nil ;};return _cac ,nil ;};