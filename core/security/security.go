//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package security ;import (_cb "bytes";_ab "crypto/aes";_c "crypto/cipher";_b "crypto/md5";_ee "crypto/rand";_fg "crypto/rc4";_ag "crypto/sha256";_f "crypto/sha512";_cf "encoding/binary";_fb "errors";_bf "fmt";_fa "github.com/unidoc/unipdf/v3/common";_d "hash";_a "io";_eg "math";);func (_gag stdHandlerR4 )alg3Key (R int ,_bcc []byte )[]byte {_cg :=_b .New ();_bca :=_gag .paddedPass (_bcc );_cg .Write (_bca );if R >=3{for _eed :=0;_eed < 50;_eed ++{_dge :=_cg .Sum (nil );_cg =_b .New ();_cg .Write (_dge );};};_bgd :=_cg .Sum (nil );if R ==2{_bgd =_bgd [0:5];}else {_bgd =_bgd [0:_gag .Length /8];};return _bgd ;};type ecb struct{_g _c .Block ;_cc int ;};func _fd (_abe ,_fae string ,_fdf int ,_bd []byte )error {if len (_bd )< _fdf {return errInvalidField {Func :_abe ,Field :_fae ,Exp :_fdf ,Got :len (_bd )};};return nil ;};

// AuthEvent is an event type that triggers authentication.
type AuthEvent string ;func (_fce stdHandlerR4 )alg7 (_ecd *StdEncryptDict ,_ccg []byte )([]byte ,error ){_ddb :=_fce .alg3Key (_ecd .R ,_ccg );_egf :=make ([]byte ,len (_ecd .O ));if _ecd .R ==2{_dcg ,_fdg :=_fg .NewCipher (_ddb );if _fdg !=nil {return nil ,_fb .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_dcg .XORKeyStream (_egf ,_ecd .O );}else if _ecd .R >=3{_faafb :=append ([]byte {},_ecd .O ...);for _bfa :=0;_bfa < 20;_bfa ++{_ddg :=append ([]byte {},_ddb ...);for _aae :=0;_aae < len (_ddb );_aae ++{_ddg [_aae ]^=byte (19-_bfa );};_ede ,_bgg :=_fg .NewCipher (_ddg );if _bgg !=nil {return nil ,_fb .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_ede .XORKeyStream (_egf ,_faafb );_faafb =append ([]byte {},_egf ...);};}else {return nil ,_fb .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};_de ,_cbe :=_fce .alg6 (_ecd ,_egf );if _cbe !=nil {return nil ,nil ;};return _de ,nil ;};

// Allowed checks if a set of permissions can be granted.
func (_df Permissions )Allowed (p2 Permissions )bool {return _df &p2 ==p2 };var _ StdHandler =stdHandlerR4 {};

// StdHandler is an interface for standard security handlers.
type StdHandler interface{

// GenerateParams uses owner and user passwords to set encryption parameters and generate an encryption key.
// It assumes that R, P and EncryptMetadata are already set.
GenerateParams (_aa *StdEncryptDict ,_gd ,_gae []byte )([]byte ,error );

// Authenticate uses encryption dictionary parameters and the password to calculate
// the document encryption key. It also returns permissions that should be granted to a user.
// In case of failed authentication, it returns empty key and zero permissions with no error.
Authenticate (_gc *StdEncryptDict ,_cd []byte )([]byte ,Permissions ,error );};func (_ggce stdHandlerR6 )alg2b (R int ,_bcd ,_ccfc ,_cbfe []byte )([]byte ,error ){if R ==5{return _ebf (_bcd );};return _fbde (_bcd ,_ccfc ,_cbfe );};func _bbe (_ffe []byte )(_c .Block ,error ){_dcd ,_cdf :=_ab .NewCipher (_ffe );if _cdf !=nil {_fa .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0063\u0072\u0065\u0061\u0074\u0065\u0020A\u0045\u0053\u0020\u0063\u0069p\u0068\u0065r\u003a\u0020\u0025\u0076",_cdf );return nil ,_cdf ;};return _dcd ,nil ;};

// Authenticate implements StdHandler interface.
func (_cedd stdHandlerR6 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){return _cedd .alg2a (d ,pass );};

// Permissions is a bitmask of access permissions for a PDF file.
type Permissions uint32 ;func (_bbf stdHandlerR4 )alg5 (_cga []byte ,_dd []byte )([]byte ,error ){_dde :=_b .New ();_dde .Write ([]byte (_agc ));_dde .Write ([]byte (_bbf .ID0 ));_gdd :=_dde .Sum (nil );_fa .Log .Trace ("\u0061\u006c\u0067\u0035");_fa .Log .Trace ("\u0065k\u0065\u0079\u003a\u0020\u0025\u0020x",_cga );_fa .Log .Trace ("\u0049D\u003a\u0020\u0025\u0020\u0078",_bbf .ID0 );if len (_gdd )!=16{return nil ,_fb .New ("\u0068a\u0073\u0068\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074\u0020\u0031\u0036\u0020\u0062\u0079\u0074\u0065\u0073");};_gg ,_cfe :=_fg .NewCipher (_cga );if _cfe !=nil {return nil ,_fb .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_gfb :=make ([]byte ,16);_gg .XORKeyStream (_gfb ,_gdd );_dfb :=make ([]byte ,len (_cga ));for _ba :=0;_ba < 19;_ba ++{for _ac :=0;_ac < len (_cga );_ac ++{_dfb [_ac ]=_cga [_ac ]^byte (_ba +1);};_gg ,_cfe =_fg .NewCipher (_dfb );if _cfe !=nil {return nil ,_fb .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_gg .XORKeyStream (_gfb ,_gfb );_fa .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u002c\u0020\u0065\u006b\u0065\u0079:\u0020\u0025\u0020\u0078",_ba ,_dfb );_fa .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0020\u0078",_ba ,_gfb );};_bdb :=make ([]byte ,32);for _ccfb :=0;_ccfb < 16;_ccfb ++{_bdb [_ccfb ]=_gfb [_ccfb ];};_ ,_cfe =_ee .Read (_bdb [16:32]);if _cfe !=nil {return nil ,_fb .New ("\u0066a\u0069\u006c\u0065\u0064 \u0074\u006f\u0020\u0067\u0065n\u0020r\u0061n\u0064\u0020\u006e\u0075\u006d\u0062\u0065r");};return _bdb ,nil ;};func _fbde (_feg ,_adb ,_ebg []byte )([]byte ,error ){var (_cba ,_ggb ,_bgga _d .Hash ;);_cba =_ag .New ();_ea :=make ([]byte ,64);_fcag :=_cba ;_fcag .Write (_feg );K :=_fcag .Sum (_ea [:0]);_abee :=make ([]byte ,64*(127+64+48));_efd :=func (_cdc int )([]byte ,error ){_dce :=len (_adb )+len (K )+len (_ebg );_ggc :=_abee [:_dce ];_gea :=copy (_ggc ,_adb );_gea +=copy (_ggc [_gea :],K [:]);_gea +=copy (_ggc [_gea :],_ebg );if _gea !=_dce {_fa .Log .Error ("E\u0052\u0052\u004f\u0052\u003a\u0020u\u006e\u0065\u0078\u0070\u0065\u0063t\u0065\u0064\u0020\u0072\u006f\u0075\u006ed\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0073\u0069\u007ae\u002e");return nil ,_fb .New ("\u0077\u0072\u006f\u006e\u0067\u0020\u0073\u0069\u007a\u0065");};K1 :=_abee [:_dce *64];_aab (K1 ,_dce );_bbfd ,_gagf :=_bbe (K [0:16]);if _gagf !=nil {return nil ,_gagf ;};_egb :=_c .NewCBCEncrypter (_bbfd ,K [16:32]);_egb .CryptBlocks (K1 ,K1 );E :=K1 ;_cgf :=0;for _ggf :=0;_ggf < 16;_ggf ++{_cgf +=int (E [_ggf ]%3);};var _dfd _d .Hash ;switch _cgf %3{case 0:_dfd =_cba ;case 1:if _ggb ==nil {_ggb =_f .New384 ();};_dfd =_ggb ;case 2:if _bgga ==nil {_bgga =_f .New ();};_dfd =_bgga ;};_dfd .Reset ();_dfd .Write (E );K =_dfd .Sum (_ea [:0]);return E ,nil ;};for _gef :=0;;{E ,_fgb :=_efd (_gef );if _fgb !=nil {return nil ,_fgb ;};_egff :=E [len (E )-1];_gef ++;if _gef >=64&&_egff <=uint8 (_gef -32){break ;};};return K [:32],nil ;};func (_dad stdHandlerR6 )alg10 (_bdbc *StdEncryptDict ,_bbeb []byte )error {if _eef :=_fd ("\u0061\u006c\u00671\u0030","\u004b\u0065\u0079",32,_bbeb );_eef !=nil {return _eef ;};_fcd :=uint64 (uint32 (_bdbc .P ))|(_eg .MaxUint32 <<32);Perms :=make ([]byte ,16);_cf .LittleEndian .PutUint64 (Perms [:8],_fcd );if _bdbc .EncryptMetadata {Perms [8]='T';}else {Perms [8]='F';};copy (Perms [9:12],"\u0061\u0064\u0062");if _ ,_faec :=_a .ReadFull (_ee .Reader ,Perms [12:16]);_faec !=nil {return _faec ;};_gbgc ,_ced :=_bbe (_bbeb [:32]);if _ced !=nil {return _ced ;};_edc :=_ff (_gbgc );_edc .CryptBlocks (Perms ,Perms );_bdbc .Perms =Perms [:16];return nil ;};func _ae (_ec _c .Block )_c .BlockMode {return (*ecbDecrypter )(_ef (_ec ))};func _aab (_cde []byte ,_dga int ){_gdf :=_dga ;for _gdf < len (_cde ){copy (_cde [_gdf :],_cde [:_gdf ]);_gdf *=2;};};type stdHandlerR4 struct{Length int ;ID0 string ;};func _ff (_faa _c .Block )_c .BlockMode {return (*ecbEncrypter )(_ef (_faa ))};var _ StdHandler =stdHandlerR6 {};func (stdHandlerR4 )paddedPass (_gcb []byte )[]byte {_fdd :=make ([]byte ,32);_fe :=copy (_fdd ,_gcb );for ;_fe < 32;_fe ++{_fdd [_fe ]=_agc [_fe -len (_gcb )];};return _fdd ;};func (_fdfg stdHandlerR4 )alg3 (R int ,_age ,_gaf []byte )([]byte ,error ){var _eb []byte ;if len (_gaf )> 0{_eb =_fdfg .alg3Key (R ,_gaf );}else {_eb =_fdfg .alg3Key (R ,_age );};_dc ,_dfg :=_fg .NewCipher (_eb );if _dfg !=nil {return nil ,_fb .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_ad :=_fdfg .paddedPass (_age );_aef :=make ([]byte ,len (_ad ));_dc .XORKeyStream (_aef ,_ad );if R >=3{_af :=make ([]byte ,len (_eb ));for _bde :=0;_bde < 19;_bde ++{for _fbd :=0;_fbd < len (_eb );_fbd ++{_af [_fbd ]=_eb [_fbd ]^byte (_bde +1);};_gb ,_db :=_fg .NewCipher (_af );if _db !=nil {return nil ,_fb .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_gb .XORKeyStream (_aef ,_aef );};};return _aef ,nil ;};const (EventDocOpen =AuthEvent ("\u0044o\u0063\u004f\u0070\u0065\u006e");EventEFOpen =AuthEvent ("\u0045\u0046\u004f\u0070\u0065\u006e"););func (_aba *ecbDecrypter )CryptBlocks (dst ,src []byte ){if len (src )%_aba ._cc !=0{_fa .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");return ;};if len (dst )< len (src ){_fa .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0064\u0065\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");return ;};for len (src )> 0{_aba ._g .Decrypt (dst ,src [:_aba ._cc ]);src =src [_aba ._cc :];dst =dst [_aba ._cc :];};};const _agc ="\x28\277\116\136\x4e\x75\x8a\x41\x64\000\x4e\x56\377"+"\xfa\001\010\056\x2e\x00\xb6\xd0\x68\076\x80\x2f\014"+"\251\xfe\x64\x53\x69\172";func (_gbc stdHandlerR4 )alg4 (_bb []byte ,_ed []byte )([]byte ,error ){_gfa ,_cbf :=_fg .NewCipher (_bb );if _cbf !=nil {return nil ,_fb .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_fag :=[]byte (_agc );_dgc :=make ([]byte ,len (_fag ));_gfa .XORKeyStream (_dgc ,_fag );return _dgc ,nil ;};func _ef (_be _c .Block )*ecb {return &ecb {_g :_be ,_cc :_be .BlockSize ()}};func (_gaed stdHandlerR4 )alg2 (_fgd *StdEncryptDict ,_bc []byte )[]byte {_fa .Log .Trace ("\u0061\u006c\u0067\u0032");_ge :=_gaed .paddedPass (_bc );_gf :=_b .New ();_gf .Write (_ge );_gf .Write (_fgd .O );var _ccf [4]byte ;_cf .LittleEndian .PutUint32 (_ccf [:],uint32 (_fgd .P ));_gf .Write (_ccf [:]);_fa .Log .Trace ("\u0067o\u0020\u0050\u003a\u0020\u0025\u0020x",_ccf );_gf .Write ([]byte (_gaed .ID0 ));_fa .Log .Trace ("\u0074\u0068\u0069\u0073\u002e\u0052\u0020\u003d\u0020\u0025d\u0020\u0065\u006e\u0063\u0072\u0079\u0070t\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061\u0020\u0025\u0076",_fgd .R ,_fgd .EncryptMetadata );if (_fgd .R >=4)&&!_fgd .EncryptMetadata {_gf .Write ([]byte {0xff,0xff,0xff,0xff});};_gab :=_gf .Sum (nil );if _fgd .R >=3{_gf =_b .New ();for _fc :=0;_fc < 50;_fc ++{_gf .Reset ();_gf .Write (_gab [0:_gaed .Length /8]);_gab =_gf .Sum (nil );};};if _fgd .R >=3{return _gab [0:_gaed .Length /8];};return _gab [0:5];};func _ebf (_gbe []byte )([]byte ,error ){_cbb :=_ag .New ();_cbb .Write (_gbe );return _cbb .Sum (nil ),nil ;};func (_agb stdHandlerR4 )alg6 (_cbff *StdEncryptDict ,_fgf []byte )([]byte ,error ){var (_gbg []byte ;_bac error ;);_cda :=_agb .alg2 (_cbff ,_fgf );if _cbff .R ==2{_gbg ,_bac =_agb .alg4 (_cda ,_fgf );}else if _cbff .R >=3{_gbg ,_bac =_agb .alg5 (_cda ,_fgf );}else {return nil ,_fb .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};if _bac !=nil {return nil ,_bac ;};_fa .Log .Trace ("\u0063\u0068\u0065\u0063k:\u0020\u0025\u0020\u0078\u0020\u003d\u003d\u0020\u0025\u0020\u0078\u0020\u003f",string (_gbg ),string (_cbff .U ));_ece :=_gbg ;_gfba :=_cbff .U ;if _cbff .R >=3{if len (_ece )> 16{_ece =_ece [0:16];};if len (_gfba )> 16{_gfba =_gfba [0:16];};};if !_cb .Equal (_ece ,_gfba ){return nil ,nil ;};return _cda ,nil ;};func (_faaf errInvalidField )Error ()string {return _bf .Sprintf ("\u0025s\u003a\u0020e\u0078\u0070\u0065\u0063t\u0065\u0064\u0020%\u0073\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0074o \u0062\u0065\u0020%\u0064\u0020b\u0079\u0074\u0065\u0073\u002c\u0020g\u006f\u0074 \u0025\u0064",_faaf .Func ,_faaf .Field ,_faaf .Exp ,_faaf .Got );};func (_abb stdHandlerR6 )alg8 (_gfbc *StdEncryptDict ,_gaee []byte ,_aefc []byte )error {if _gcbd :=_fd ("\u0061\u006c\u0067\u0038","\u004b\u0065\u0079",32,_gaee );_gcbd !=nil {return _gcbd ;};var _geg [16]byte ;if _ ,_ggd :=_a .ReadFull (_ee .Reader ,_geg [:]);_ggd !=nil {return _ggd ;};_ca :=_geg [0:8];_geb :=_geg [8:16];_dgcf :=make ([]byte ,len (_aefc )+len (_ca ));_dcgb :=copy (_dgcf ,_aefc );copy (_dgcf [_dcgb :],_ca );_cea ,_da :=_abb .alg2b (_gfbc .R ,_dgcf ,_aefc ,nil );if _da !=nil {return _da ;};U :=make ([]byte ,len (_cea )+len (_ca )+len (_geb ));_dcgb =copy (U ,_cea [:32]);_dcgb +=copy (U [_dcgb :],_ca );copy (U [_dcgb :],_geb );_gfbc .U =U ;_dcgb =len (_aefc );copy (_dgcf [_dcgb :],_geb );_cea ,_da =_abb .alg2b (_gfbc .R ,_dgcf ,_aefc ,nil );if _da !=nil {return _da ;};_ggcg ,_da :=_bbe (_cea [:32]);if _da !=nil {return _da ;};_eca :=make ([]byte ,_ab .BlockSize );_cdce :=_c .NewCBCEncrypter (_ggcg ,_eca );UE :=make ([]byte ,32);_cdce .CryptBlocks (UE ,_gaee [:32]);_gfbc .UE =UE ;return nil ;};func (_ccb stdHandlerR6 )alg12 (_fege *StdEncryptDict ,_bcf []byte )([]byte ,error ){if _egfg :=_fd ("\u0061\u006c\u00671\u0032","\u0055",48,_fege .U );_egfg !=nil {return nil ,_egfg ;};if _cag :=_fd ("\u0061\u006c\u00671\u0032","\u004f",48,_fege .O );_cag !=nil {return nil ,_cag ;};_dcf :=make ([]byte ,len (_bcf )+8+48);_cgg :=copy (_dcf ,_bcf );_cgg +=copy (_dcf [_cgg :],_fege .O [32:40]);_cgg +=copy (_dcf [_cgg :],_fege .U [0:48]);_edg ,_bfc :=_ccb .alg2b (_fege .R ,_dcf ,_bcf ,_fege .U [0:48]);if _bfc !=nil {return nil ,_bfc ;};_edg =_edg [:32];if !_cb .Equal (_edg ,_fege .O [:32]){return nil ,nil ;};return _edg ,nil ;};

// NewHandlerR6 creates a new standard security handler for R=5 and R=6.
func NewHandlerR6 ()StdHandler {return stdHandlerR6 {}};

// GenerateParams is the algorithm opposite to alg2a (R>=5).
// It generates U,O,UE,OE,Perms fields using AESv3 encryption.
// There is no algorithm number assigned to this function in the spec.
// It expects R, P and EncryptMetadata fields to be set.
func (_dgcg stdHandlerR6 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){_bfag :=make ([]byte ,32);if _ ,_fff :=_a .ReadFull (_ee .Reader ,_bfag );_fff !=nil {return nil ,_fff ;};d .U =nil ;d .O =nil ;d .UE =nil ;d .OE =nil ;d .Perms =nil ;if len (upass )> 127{upass =upass [:127];};if len (opass )> 127{opass =opass [:127];};if _befc :=_dgcg .alg8 (d ,_bfag ,upass );_befc !=nil {return nil ,_befc ;};if _cfc :=_dgcg .alg9 (d ,_bfag ,opass );_cfc !=nil {return nil ,_cfc ;};if d .R ==5{return _bfag ,nil ;};if _ffff :=_dgcg .alg10 (d ,_bfag );_ffff !=nil {return nil ,_ffff ;};return _bfag ,nil ;};func (_dg *ecbEncrypter )CryptBlocks (dst ,src []byte ){if len (src )%_dg ._cc !=0{_fa .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");return ;};if len (dst )< len (src ){_fa .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");return ;};for len (src )> 0{_dg ._g .Encrypt (dst ,src [:_dg ._cc ]);src =src [_dg ._cc :];dst =dst [_dg ._cc :];};};func (_fcba stdHandlerR6 )alg11 (_bdcd *StdEncryptDict ,_eee []byte )([]byte ,error ){if _bfaf :=_fd ("\u0061\u006c\u00671\u0031","\u0055",48,_bdcd .U );_bfaf !=nil {return nil ,_bfaf ;};_abed :=make ([]byte ,len (_eee )+8);_aad :=copy (_abed ,_eee );_aad +=copy (_abed [_aad :],_bdcd .U [32:40]);_bfbfa ,_gfec :=_fcba .alg2b (_bdcd .R ,_abed ,_eee ,nil );if _gfec !=nil {return nil ,_gfec ;};_bfbfa =_bfbfa [:32];if !_cb .Equal (_bfbfa ,_bdcd .U [:32]){return nil ,nil ;};return _bfbfa ,nil ;};const (PermOwner =Permissions (_eg .MaxUint32 );PermPrinting =Permissions (1<<2);PermModify =Permissions (1<<3);PermExtractGraphics =Permissions (1<<4);PermAnnotate =Permissions (1<<5);PermFillForms =Permissions (1<<8);PermDisabilityExtract =Permissions (1<<9);PermRotateInsert =Permissions (1<<10);PermFullPrintQuality =Permissions (1<<11););type ecbDecrypter ecb ;func (_bfbd stdHandlerR6 )alg9 (_gca *StdEncryptDict ,_gaff []byte ,_acf []byte )error {if _dcb :=_fd ("\u0061\u006c\u0067\u0039","\u004b\u0065\u0079",32,_gaff );_dcb !=nil {return _dcb ;};if _fbb :=_fd ("\u0061\u006c\u0067\u0039","\u0055",48,_gca .U );_fbb !=nil {return _fbb ;};var _bba [16]byte ;if _ ,_bcdf :=_a .ReadFull (_ee .Reader ,_bba [:]);_bcdf !=nil {return _bcdf ;};_gfe :=_bba [0:8];_dgb :=_bba [8:16];_ebd :=_gca .U [:48];_cab :=make ([]byte ,len (_acf )+len (_gfe )+len (_ebd ));_efcf :=copy (_cab ,_acf );_efcf +=copy (_cab [_efcf :],_gfe );_efcf +=copy (_cab [_efcf :],_ebd );_faaa ,_fab :=_bfbd .alg2b (_gca .R ,_cab ,_acf ,_ebd );if _fab !=nil {return _fab ;};O :=make ([]byte ,len (_faaa )+len (_gfe )+len (_dgb ));_efcf =copy (O ,_faaa [:32]);_efcf +=copy (O [_efcf :],_gfe );_efcf +=copy (O [_efcf :],_dgb );_gca .O =O ;_efcf =len (_acf );_efcf +=copy (_cab [_efcf :],_dgb );_faaa ,_fab =_bfbd .alg2b (_gca .R ,_cab ,_acf ,_ebd );if _fab !=nil {return _fab ;};_efcc ,_fab :=_bbe (_faaa [:32]);if _fab !=nil {return _fab ;};_ggcf :=make ([]byte ,_ab .BlockSize );_eeg :=_c .NewCBCEncrypter (_efcc ,_ggcf );OE :=make ([]byte ,32);_eeg .CryptBlocks (OE ,_gaff [:32]);_gca .OE =OE ;return nil ;};func (_ga *ecbDecrypter )BlockSize ()int {return _ga ._cc };

// Authenticate implements StdHandler interface.
func (_ddf stdHandlerR4 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){_fa .Log .Trace ("\u0044\u0065b\u0075\u0067\u0067\u0069n\u0067\u0020a\u0075\u0074\u0068\u0065\u006e\u0074\u0069\u0063a\u0074\u0069\u006f\u006e\u0020\u002d\u0020\u006f\u0077\u006e\u0065\u0072 \u0070\u0061\u0073\u0073");_ce ,_fgg :=_ddf .alg7 (d ,pass );if _fgg !=nil {return nil ,0,_fgg ;};if _ce !=nil {_fa .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _ce ,PermOwner ,nil ;};_fa .Log .Trace ("\u0044\u0065bu\u0067\u0067\u0069n\u0067\u0020\u0061\u0075the\u006eti\u0063\u0061\u0074\u0069\u006f\u006e\u0020- \u0075\u0073\u0065\u0072\u0020\u0070\u0061s\u0073");_ce ,_fgg =_ddf .alg6 (d ,pass );if _fgg !=nil {return nil ,0,_fgg ;};if _ce !=nil {_fa .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _ce ,d .P ,nil ;};return nil ,0,nil ;};type errInvalidField struct{Func string ;Field string ;Exp int ;Got int ;};type stdHandlerR6 struct{};func (_bg *ecbEncrypter )BlockSize ()int {return _bg ._cc };func (_bff stdHandlerR6 )alg2a (_afb *StdEncryptDict ,_acc []byte )([]byte ,Permissions ,error ){if _gafg :=_fd ("\u0061\u006c\u00672\u0061","\u004f",48,_afb .O );_gafg !=nil {return nil ,0,_gafg ;};if _ebe :=_fd ("\u0061\u006c\u00672\u0061","\u0055",48,_afb .U );_ebe !=nil {return nil ,0,_ebe ;};if len (_acc )> 127{_acc =_acc [:127];};_bfbf ,_bdc :=_bff .alg12 (_afb ,_acc );if _bdc !=nil {return nil ,0,_bdc ;};var (_dbe []byte ;_fdc []byte ;_bef []byte ;);var _aeg Permissions ;if len (_bfbf )!=0{_aeg =PermOwner ;_fca :=make ([]byte ,len (_acc )+8+48);_gafa :=copy (_fca ,_acc );_gafa +=copy (_fca [_gafa :],_afb .O [40:48]);copy (_fca [_gafa :],_afb .U [0:48]);_dbe =_fca ;_fdc =_afb .OE ;_bef =_afb .U [0:48];}else {_bfbf ,_bdc =_bff .alg11 (_afb ,_acc );if _bdc ==nil &&len (_bfbf )==0{_bfbf ,_bdc =_bff .alg11 (_afb ,[]byte (""));};if _bdc !=nil {return nil ,0,_bdc ;}else if len (_bfbf )==0{return nil ,0,nil ;};_aeg =_afb .P ;_ddba :=make ([]byte ,len (_acc )+8);_dee :=copy (_ddba ,_acc );copy (_ddba [_dee :],_afb .U [40:48]);_dbe =_ddba ;_fdc =_afb .UE ;_bef =nil ;};if _fcf :=_fd ("\u0061\u006c\u00672\u0061","\u004b\u0065\u0079",32,_fdc );_fcf !=nil {return nil ,0,_fcf ;};_fdc =_fdc [:32];_bgf ,_bdc :=_bff .alg2b (_afb .R ,_dbe ,_acc ,_bef );if _bdc !=nil {return nil ,0,_bdc ;};_cdd ,_bdc :=_ab .NewCipher (_bgf [:32]);if _bdc !=nil {return nil ,0,_bdc ;};_fcb :=make ([]byte ,_ab .BlockSize );_bbc :=_c .NewCBCDecrypter (_cdd ,_fcb );_cef :=make ([]byte ,32);_bbc .CryptBlocks (_cef ,_fdc );if _afb .R ==5{return _cef ,_aeg ,nil ;};_bdc =_bff .alg13 (_afb ,_cef );if _bdc !=nil {return nil ,0,_bdc ;};return _cef ,_aeg ,nil ;};

// NewHandlerR4 creates a new standard security handler for R<=4.
func NewHandlerR4 (id0 string ,length int )StdHandler {return stdHandlerR4 {ID0 :id0 ,Length :length }};func (_dcbg stdHandlerR6 )alg13 (_gcag *StdEncryptDict ,_dgef []byte )error {if _aabe :=_fd ("\u0061\u006c\u00671\u0033","\u004b\u0065\u0079",32,_dgef );_aabe !=nil {return _aabe ;};if _geac :=_fd ("\u0061\u006c\u00671\u0033","\u0050\u0065\u0072m\u0073",16,_gcag .Perms );_geac !=nil {return _geac ;};_geab :=make ([]byte ,16);copy (_geab ,_gcag .Perms [:16]);_bgb ,_eaf :=_ab .NewCipher (_dgef [:32]);if _eaf !=nil {return _eaf ;};_egc :=_ae (_bgb );_egc .CryptBlocks (_geab ,_geab );if !_cb .Equal (_geab [9:12],[]byte ("\u0061\u0064\u0062")){return _fb .New ("\u0064\u0065\u0063o\u0064\u0065\u0064\u0020p\u0065\u0072\u006d\u0069\u0073\u0073\u0069o\u006e\u0073\u0020\u0061\u0072\u0065\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_edf :=Permissions (_cf .LittleEndian .Uint32 (_geab [0:4]));if _edf !=_gcag .P {return _fb .New ("\u0070\u0065r\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066\u0061il\u0065\u0064");};var _cad bool ;if _geab [8]=='T'{_cad =true ;}else if _geab [8]=='F'{_cad =false ;}else {return _fb .New ("\u0064\u0065\u0063\u006f\u0064\u0065\u0064 \u006d\u0065\u0074a\u0064\u0061\u0074\u0061 \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u006c\u0061\u0067\u0020\u0069\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};if _cad !=_gcag .EncryptMetadata {return _fb .New ("\u006d\u0065t\u0061\u0064\u0061\u0074a\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e \u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066a\u0069\u006c\u0065\u0064");};return nil ;};

// GenerateParams generates and sets O and U parameters for the encryption dictionary.
// It expects R, P and EncryptMetadata fields to be set.
func (_bfb stdHandlerR4 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){O ,_ddd :=_bfb .alg3 (d .R ,upass ,opass );if _ddd !=nil {_fa .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_ddd );return nil ,_ddd ;};d .O =O ;_fa .Log .Trace ("\u0067\u0065\u006e\u0020\u004f\u003a\u0020\u0025\u0020\u0078",O );_efc :=_bfb .alg2 (d ,upass );U ,_ddd :=_bfb .alg5 (_efc ,upass );if _ddd !=nil {_fa .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_ddd );return nil ,_ddd ;};d .U =U ;_fa .Log .Trace ("\u0067\u0065\u006e\u0020\u0055\u003a\u0020\u0025\u0020\u0078",U );return _efc ,nil ;};type ecbEncrypter ecb ;

// StdEncryptDict is a set of additional fields used in standard encryption dictionary.
type StdEncryptDict struct{R int ;P Permissions ;EncryptMetadata bool ;O ,U []byte ;OE ,UE []byte ;Perms []byte ;};