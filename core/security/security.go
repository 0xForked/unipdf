//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package security ;import (_ab "bytes";_c "crypto/aes";_f "crypto/cipher";_bf "crypto/md5";_dc "crypto/rand";_ff "crypto/rc4";_d "crypto/sha256";_be "crypto/sha512";_ec "encoding/binary";_a "errors";_cg "fmt";_bfe "github.com/unidoc/unipdf/v3/common";_b "hash";
_ed "io";_db "math";);func (_ccgg stdHandlerR4 )alg5 (_gde []byte ,_cd []byte )([]byte ,error ){_ffc :=_bf .New ();_ffc .Write ([]byte (_cgc ));_ffc .Write ([]byte (_ccgg .ID0 ));_gb :=_ffc .Sum (nil );_bfe .Log .Trace ("\u0061\u006c\u0067\u0035");_bfe .Log .Trace ("\u0065k\u0065\u0079\u003a\u0020\u0025\u0020x",_gde );
_bfe .Log .Trace ("\u0049D\u003a\u0020\u0025\u0020\u0078",_ccgg .ID0 );if len (_gb )!=16{return nil ,_a .New ("\u0068a\u0073\u0068\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074\u0020\u0031\u0036\u0020\u0062\u0079\u0074\u0065\u0073");};_gdee ,_cea :=_ff .NewCipher (_gde );
if _cea !=nil {return nil ,_a .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_gbf :=make ([]byte ,16);_gdee .XORKeyStream (_gbf ,_gb );_fbc :=make ([]byte ,len (_gde ));for _cfb :=0;_cfb < 19;_cfb ++{for _gdb :=0;
_gdb < len (_gde );_gdb ++{_fbc [_gdb ]=_gde [_gdb ]^byte (_cfb +1);};_gdee ,_cea =_ff .NewCipher (_fbc );if _cea !=nil {return nil ,_a .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_gdee .XORKeyStream (_gbf ,_gbf );
_bfe .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u002c\u0020\u0065\u006b\u0065\u0079:\u0020\u0025\u0020\u0078",_cfb ,_fbc );_bfe .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0020\u0078",_cfb ,_gbf );};_ca :=make ([]byte ,32);
for _ffcb :=0;_ffcb < 16;_ffcb ++{_ca [_ffcb ]=_gbf [_ffcb ];};_ ,_cea =_dc .Read (_ca [16:32]);if _cea !=nil {return nil ,_a .New ("\u0066a\u0069\u006c\u0065\u0064 \u0074\u006f\u0020\u0067\u0065n\u0020r\u0061n\u0064\u0020\u006e\u0075\u006d\u0062\u0065r");
};return _ca ,nil ;};func (_de *ecbDecrypter )CryptBlocks (dst ,src []byte ){if len (src )%_de ._cgf !=0{_bfe .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_bfe .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0064\u0065\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_de ._ef .Decrypt (dst ,src [:_de ._cgf ]);src =src [_de ._cgf :];dst =dst [_de ._cgf :];};};func (_eac stdHandlerR6 )alg2a (_fdf *StdEncryptDict ,_cbg []byte )([]byte ,Permissions ,error ){if _ccd :=_ffg ("\u0061\u006c\u00672\u0061","\u004f",48,_fdf .O );
_ccd !=nil {return nil ,0,_ccd ;};if _cad :=_ffg ("\u0061\u006c\u00672\u0061","\u0055",48,_fdf .U );_cad !=nil {return nil ,0,_cad ;};if len (_cbg )> 127{_cbg =_cbg [:127];};_fgce ,_fad :=_eac .alg12 (_fdf ,_cbg );if _fad !=nil {return nil ,0,_fad ;};var (_bcg []byte ;
_dbd []byte ;_aef []byte ;);var _fae Permissions ;if len (_fgce )!=0{_fae =PermOwner ;_gdc :=make ([]byte ,len (_cbg )+8+48);_eba :=copy (_gdc ,_cbg );_eba +=copy (_gdc [_eba :],_fdf .O [40:48]);copy (_gdc [_eba :],_fdf .U [0:48]);_bcg =_gdc ;_dbd =_fdf .OE ;
_aef =_fdf .U [0:48];}else {_fgce ,_fad =_eac .alg11 (_fdf ,_cbg );if _fad ==nil &&len (_fgce )==0{_fgce ,_fad =_eac .alg11 (_fdf ,[]byte (""));};if _fad !=nil {return nil ,0,_fad ;}else if len (_fgce )==0{return nil ,0,nil ;};_fae =_fdf .P ;_eeb :=make ([]byte ,len (_cbg )+8);
_abb :=copy (_eeb ,_cbg );copy (_eeb [_abb :],_fdf .U [40:48]);_bcg =_eeb ;_dbd =_fdf .UE ;_aef =nil ;};if _bca :=_ffg ("\u0061\u006c\u00672\u0061","\u004b\u0065\u0079",32,_dbd );_bca !=nil {return nil ,0,_bca ;};_dbd =_dbd [:32];_eda ,_fad :=_eac .alg2b (_fdf .R ,_bcg ,_cbg ,_aef );
if _fad !=nil {return nil ,0,_fad ;};_bg ,_fad :=_c .NewCipher (_eda [:32]);if _fad !=nil {return nil ,0,_fad ;};_cdb :=make ([]byte ,_c .BlockSize );_fff :=_f .NewCBCDecrypter (_bg ,_cdb );_dba :=make ([]byte ,32);_fff .CryptBlocks (_dba ,_dbd );if _fdf .R ==5{return _dba ,_fae ,nil ;
};_fad =_eac .alg13 (_fdf ,_dba );if _fad !=nil {return nil ,0,_fad ;};return _dba ,_fae ,nil ;};func _bae (_fee []byte )([]byte ,error ){_gaa :=_d .New ();_gaa .Write (_fee );return _gaa .Sum (nil ),nil };func (_dca stdHandlerR4 )alg6 (_ged *StdEncryptDict ,_cbf []byte )([]byte ,error ){var (_fga []byte ;
_baa error ;);_dcg :=_dca .alg2 (_ged ,_cbf );if _ged .R ==2{_fga ,_baa =_dca .alg4 (_dcg ,_cbf );}else if _ged .R >=3{_fga ,_baa =_dca .alg5 (_dcg ,_cbf );}else {return nil ,_a .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};if _baa !=nil {return nil ,_baa ;
};_bfe .Log .Trace ("\u0063\u0068\u0065\u0063k:\u0020\u0025\u0020\u0078\u0020\u003d\u003d\u0020\u0025\u0020\u0078\u0020\u003f",string (_fga ),string (_ged .U ));_gea :=_fga ;_geae :=_ged .U ;if _ged .R >=3{if len (_gea )> 16{_gea =_gea [0:16];};if len (_geae )> 16{_geae =_geae [0:16];
};};if !_ab .Equal (_gea ,_geae ){return nil ,nil ;};return _dcg ,nil ;};

// Authenticate implements StdHandler interface.
func (_bfb stdHandlerR6 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){return _bfb .alg2a (d ,pass );};func _ffg (_gg ,_fb string ,_feg int ,_cb []byte )error {if len (_cb )< _feg {return errInvalidField {Func :_gg ,Field :_fb ,Exp :_feg ,Got :len (_cb )};
};return nil ;};func (stdHandlerR4 )paddedPass (_bea []byte )[]byte {_gc :=make ([]byte ,32);_fbg :=copy (_gc ,_bea );for ;_fbg < 32;_fbg ++{_gc [_fbg ]=_cgc [_fbg -len (_bea )];};return _gc ;};type ecbEncrypter ecb ;func (_gf errInvalidField )Error ()string {return _cg .Sprintf ("\u0025s\u003a\u0020e\u0078\u0070\u0065\u0063t\u0065\u0064\u0020%\u0073\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0074o \u0062\u0065\u0020%\u0064\u0020b\u0079\u0074\u0065\u0073\u002c\u0020g\u006f\u0074 \u0025\u0064",_gf .Func ,_gf .Field ,_gf .Exp ,_gf .Got );
};func (_fg stdHandlerR4 )alg4 (_ggb []byte ,_cfd []byte )([]byte ,error ){_fgc ,_ecc :=_ff .NewCipher (_ggb );if _ecc !=nil {return nil ,_a .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_ecb :=[]byte (_cgc );
_fd :=make ([]byte ,len (_ecb ));_fgc .XORKeyStream (_fd ,_ecb );return _fd ,nil ;};func _aad (_egb ,_fgba ,_eef []byte )([]byte ,error ){var (_edb ,_bac ,_bede _b .Hash ;);_edb =_d .New ();_bcc :=make ([]byte ,64);_bbc :=_edb ;_bbc .Write (_egb );K :=_bbc .Sum (_bcc [:0]);
_feb :=make ([]byte ,64*(127+64+48));_cae :=func (_gaba int )([]byte ,error ){_gfa :=len (_fgba )+len (K )+len (_eef );_ecf :=_feb [:_gfa ];_dff :=copy (_ecf ,_fgba );_dff +=copy (_ecf [_dff :],K [:]);_dff +=copy (_ecf [_dff :],_eef );if _dff !=_gfa {_bfe .Log .Error ("E\u0052\u0052\u004f\u0052\u003a\u0020u\u006e\u0065\u0078\u0070\u0065\u0063t\u0065\u0064\u0020\u0072\u006f\u0075\u006ed\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0073\u0069\u007ae\u002e");
return nil ,_a .New ("\u0077\u0072\u006f\u006e\u0067\u0020\u0073\u0069\u007a\u0065");};K1 :=_feb [:_gfa *64];_cbba (K1 ,_gfa );_fed ,_aeg :=_cfba (K [0:16]);if _aeg !=nil {return nil ,_aeg ;};_cbc :=_f .NewCBCEncrypter (_fed ,K [16:32]);_cbc .CryptBlocks (K1 ,K1 );
E :=K1 ;_dga :=0;for _ece :=0;_ece < 16;_ece ++{_dga +=int (E [_ece ]%3);};var _cca _b .Hash ;switch _dga %3{case 0:_cca =_edb ;case 1:if _bac ==nil {_bac =_be .New384 ();};_cca =_bac ;case 2:if _bede ==nil {_bede =_be .New ();};_cca =_bede ;};_cca .Reset ();
_cca .Write (E );K =_cca .Sum (_bcc [:0]);return E ,nil ;};for _cga :=0;;{E ,_faec :=_cae (_cga );if _faec !=nil {return nil ,_faec ;};_agf :=E [len (E )-1];_cga ++;if _cga >=64&&_agf <=uint8 (_cga -32){break ;};};return K [:32],nil ;};func (_bgb stdHandlerR6 )alg2b (R int ,_ccc ,_dfd ,_faeb []byte )([]byte ,error ){if R ==5{return _bae (_ccc );
};return _aad (_ccc ,_dfd ,_faeb );};func _cfba (_ccgge []byte )(_f .Block ,error ){_fdag ,_ae :=_c .NewCipher (_ccgge );if _ae !=nil {_bfe .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0063\u0072\u0065\u0061\u0074\u0065\u0020A\u0045\u0053\u0020\u0063\u0069p\u0068\u0065r\u003a\u0020\u0025\u0076",_ae );
return nil ,_ae ;};return _fdag ,nil ;};

// Permissions is a bitmask of access permissions for a PDF file.
type Permissions uint32 ;

// StdHandler is an interface for standard security handlers.
type StdHandler interface{

// GenerateParams uses owner and user passwords to set encryption parameters and generate an encryption key.
// It assumes that R, P and EncryptMetadata are already set.
GenerateParams (_ge *StdEncryptDict ,_dcb ,_ac []byte )([]byte ,error );

// Authenticate uses encryption dictionary parameters and the password to calculate
// the document encryption key. It also returns permissions that should be granted to a user.
// In case of failed authentication, it returns empty key and zero permissions with no error.
Authenticate (_da *StdEncryptDict ,_fa []byte )([]byte ,Permissions ,error );};var _ StdHandler =stdHandlerR6 {};type ecbDecrypter ecb ;

// GenerateParams generates and sets O and U parameters for the encryption dictionary.
// It expects R, P and EncryptMetadata fields to be set.
func (_fda stdHandlerR4 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){O ,_bd :=_fda .alg3 (d .R ,upass ,opass );if _bd !=nil {_bfe .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_bd );
return nil ,_bd ;};d .O =O ;_bfe .Log .Trace ("\u0067\u0065\u006e\u0020\u004f\u003a\u0020\u0025\u0020\u0078",O );_acg :=_fda .alg2 (d ,upass );U ,_bd :=_fda .alg5 (_acg ,upass );if _bd !=nil {_bfe .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_bd );
return nil ,_bd ;};d .U =U ;_bfe .Log .Trace ("\u0067\u0065\u006e\u0020\u0055\u003a\u0020\u0025\u0020\u0078",U );return _acg ,nil ;};var _ StdHandler =stdHandlerR4 {};func (_ag *ecbEncrypter )BlockSize ()int {return _ag ._cgf };func (_ce *ecbEncrypter )CryptBlocks (dst ,src []byte ){if len (src )%_ce ._cgf !=0{_bfe .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_bfe .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_ce ._ef .Encrypt (dst ,src [:_ce ._cgf ]);src =src [_ce ._cgf :];dst =dst [_ce ._cgf :];};};type ecb struct{_ef _f .Block ;_cgf int ;};

// AuthEvent is an event type that triggers authentication.
type AuthEvent string ;const _cgc ="\x28\277\116\136\x4e\x75\x8a\x41\x64\000\x4e\x56\377"+"\xfa\001\010\056\x2e\x00\xb6\xd0\x68\076\x80\x2f\014"+"\251\xfe\x64\x53\x69\172";func (_cbe stdHandlerR6 )alg11 (_bdfe *StdEncryptDict ,_gfd []byte )([]byte ,error ){if _efbc :=_ffg ("\u0061\u006c\u00671\u0031","\u0055",48,_bdfe .U );
_efbc !=nil {return nil ,_efbc ;};_add :=make ([]byte ,len (_gfd )+8);_aed :=copy (_add ,_gfd );_aed +=copy (_add [_aed :],_bdfe .U [32:40]);_cba ,_gda :=_cbe .alg2b (_bdfe .R ,_add ,_gfd ,nil );if _gda !=nil {return nil ,_gda ;};_cba =_cba [:32];if !_ab .Equal (_cba ,_bdfe .U [:32]){return nil ,nil ;
};return _cba ,nil ;};func (_caac stdHandlerR6 )alg10 (_fge *StdEncryptDict ,_ecg []byte )error {if _faf :=_ffg ("\u0061\u006c\u00671\u0030","\u004b\u0065\u0079",32,_ecg );_faf !=nil {return _faf ;};_fdd :=uint64 (uint32 (_fge .P ))|(_db .MaxUint32 <<32);
Perms :=make ([]byte ,16);_ec .LittleEndian .PutUint64 (Perms [:8],_fdd );if _fge .EncryptMetadata {Perms [8]='T';}else {Perms [8]='F';};copy (Perms [9:12],"\u0061\u0064\u0062");if _ ,_gcga :=_ed .ReadFull (_dc .Reader ,Perms [12:16]);_gcga !=nil {return _gcga ;
};_edea ,_dcad :=_cfba (_ecg [:32]);if _dcad !=nil {return _dcad ;};_cabc :=_g (_edea );_cabc .CryptBlocks (Perms ,Perms );_fge .Perms =Perms [:16];return nil ;};const (PermOwner =Permissions (_db .MaxUint32 );PermPrinting =Permissions (1<<2);PermModify =Permissions (1<<3);
PermExtractGraphics =Permissions (1<<4);PermAnnotate =Permissions (1<<5);PermFillForms =Permissions (1<<8);PermDisabilityExtract =Permissions (1<<9);PermRotateInsert =Permissions (1<<10);PermFullPrintQuality =Permissions (1<<11););func (_eff stdHandlerR4 )alg7 (_aca *StdEncryptDict ,_fbgd []byte )([]byte ,error ){_cda :=_eff .alg3Key (_aca .R ,_fbgd );
_bed :=make ([]byte ,len (_aca .O ));if _aca .R ==2{_df ,_aaa :=_ff .NewCipher (_cda );if _aaa !=nil {return nil ,_a .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_df .XORKeyStream (_bed ,_aca .O );}else if _aca .R >=3{_gcb :=append ([]byte {},_aca .O ...);
for _gbff :=0;_gbff < 20;_gbff ++{_gcgb :=append ([]byte {},_cda ...);for _aae :=0;_aae < len (_cda );_aae ++{_gcgb [_aae ]^=byte (19-_gbff );};_fbb ,_bag :=_ff .NewCipher (_gcgb );if _bag !=nil {return nil ,_a .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");
};_fbb .XORKeyStream (_bed ,_gcb );_gcb =append ([]byte {},_bed ...);};}else {return nil ,_a .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};_dgf ,_gcf :=_eff .alg6 (_aca ,_bed );if _gcf !=nil {return nil ,nil ;};return _dgf ,nil ;};func (_caa stdHandlerR6 )alg9 (_dgag *StdEncryptDict ,_ccaf []byte ,_ebf []byte )error {if _dfc :=_ffg ("\u0061\u006c\u0067\u0039","\u004b\u0065\u0079",32,_ccaf );
_dfc !=nil {return _dfc ;};if _ebff :=_ffg ("\u0061\u006c\u0067\u0039","\u0055",48,_dgag .U );_ebff !=nil {return _ebff ;};var _ceg [16]byte ;if _ ,_cab :=_ed .ReadFull (_dc .Reader ,_ceg [:]);_cab !=nil {return _cab ;};_fgd :=_ceg [0:8];_aaec :=_ceg [8:16];
_dbf :=_dgag .U [:48];_bad :=make ([]byte ,len (_ebf )+len (_fgd )+len (_dbf ));_cag :=copy (_bad ,_ebf );_cag +=copy (_bad [_cag :],_fgd );_cag +=copy (_bad [_cag :],_dbf );_bdg ,_efb :=_caa .alg2b (_dgag .R ,_bad ,_ebf ,_dbf );if _efb !=nil {return _efb ;
};O :=make ([]byte ,len (_bdg )+len (_fgd )+len (_aaec ));_cag =copy (O ,_bdg [:32]);_cag +=copy (O [_cag :],_fgd );_cag +=copy (O [_cag :],_aaec );_dgag .O =O ;_cag =len (_ebf );_cag +=copy (_bad [_cag :],_aaec );_bdg ,_efb =_caa .alg2b (_dgag .R ,_bad ,_ebf ,_dbf );
if _efb !=nil {return _efb ;};_agd ,_efb :=_cfba (_bdg [:32]);if _efb !=nil {return _efb ;};_fcf :=make ([]byte ,_c .BlockSize );_baaa :=_f .NewCBCEncrypter (_agd ,_fcf );OE :=make ([]byte ,32);_baaa .CryptBlocks (OE ,_ccaf [:32]);_dgag .OE =OE ;return nil ;
};

// NewHandlerR6 creates a new standard security handler for R=5 and R=6.
func NewHandlerR6 ()StdHandler {return stdHandlerR6 {}};func _cbba (_def []byte ,_ecd int ){_fbce :=_ecd ;for _fbce < len (_def ){copy (_def [_fbce :],_def [:_fbce ]);_fbce *=2;};};func (_aba stdHandlerR6 )alg12 (_cec *StdEncryptDict ,_ggf []byte )([]byte ,error ){if _beb :=_ffg ("\u0061\u006c\u00671\u0032","\u0055",48,_cec .U );
_beb !=nil {return nil ,_beb ;};if _ead :=_ffg ("\u0061\u006c\u00671\u0032","\u004f",48,_cec .O );_ead !=nil {return nil ,_ead ;};_acb :=make ([]byte ,len (_ggf )+8+48);_dfb :=copy (_acb ,_ggf );_dfb +=copy (_acb [_dfb :],_cec .O [32:40]);_dfb +=copy (_acb [_dfb :],_cec .U [0:48]);
_ded ,_aeae :=_aba .alg2b (_cec .R ,_acb ,_ggf ,_cec .U [0:48]);if _aeae !=nil {return nil ,_aeae ;};_ded =_ded [:32];if !_ab .Equal (_ded ,_cec .O [:32]){return nil ,nil ;};return _ded ,nil ;};func (_ee *ecbDecrypter )BlockSize ()int {return _ee ._cgf };
func _aga (_fe _f .Block )_f .BlockMode {return (*ecbDecrypter )(_bc (_fe ))};func _bc (_bb _f .Block )*ecb {return &ecb {_ef :_bb ,_cgf :_bb .BlockSize ()}};func (_dd stdHandlerR6 )alg8 (_cfbf *StdEncryptDict ,_gfaf []byte ,_aea []byte )error {if _agc :=_ffg ("\u0061\u006c\u0067\u0038","\u004b\u0065\u0079",32,_gfaf );
_agc !=nil {return _agc ;};var _fbgc [16]byte ;if _ ,_bdf :=_ed .ReadFull (_dc .Reader ,_fbgc [:]);_bdf !=nil {return _bdf ;};_dcf :=_fbgc [0:8];_af :=_fbgc [8:16];_aefd :=make ([]byte ,len (_aea )+len (_dcf ));_aefa :=copy (_aefd ,_aea );copy (_aefd [_aefa :],_dcf );
_aeb ,_faecb :=_dd .alg2b (_cfbf .R ,_aefd ,_aea ,nil );if _faecb !=nil {return _faecb ;};U :=make ([]byte ,len (_aeb )+len (_dcf )+len (_af ));_aefa =copy (U ,_aeb [:32]);_aefa +=copy (U [_aefa :],_dcf );copy (U [_aefa :],_af );_cfbf .U =U ;_aefa =len (_aea );
copy (_aefd [_aefa :],_af );_aeb ,_faecb =_dd .alg2b (_cfbf .R ,_aefd ,_aea ,nil );if _faecb !=nil {return _faecb ;};_gfb ,_faecb :=_cfba (_aeb [:32]);if _faecb !=nil {return _faecb ;};_gge :=make ([]byte ,_c .BlockSize );_aac :=_f .NewCBCEncrypter (_gfb ,_gge );
UE :=make ([]byte ,32);_aac .CryptBlocks (UE ,_gfaf [:32]);_cfbf .UE =UE ;return nil ;};

// Allowed checks if a set of permissions can be granted.
func (_cf Permissions )Allowed (p2 Permissions )bool {return _cf &p2 ==p2 };func (_dg stdHandlerR4 )alg3 (R int ,_dcd ,_ffb []byte )([]byte ,error ){var _ebe []byte ;if len (_ffb )> 0{_ebe =_dg .alg3Key (R ,_ffb );}else {_ebe =_dg .alg3Key (R ,_dcd );};
_ba ,_eec :=_ff .NewCipher (_ebe );if _eec !=nil {return nil ,_a .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_ccb :=_dg .paddedPass (_dcd );_ceb :=make ([]byte ,len (_ccb ));_ba .XORKeyStream (_ceb ,_ccb );
if R >=3{_gd :=make ([]byte ,len (_ebe ));for _fbff :=0;_fbff < 19;_fbff ++{for _gab :=0;_gab < len (_ebe );_gab ++{_gd [_gab ]=_ebe [_gab ]^byte (_fbff +1);};_gcg ,_acd :=_ff .NewCipher (_gd );if _acd !=nil {return nil ,_a .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_gcg .XORKeyStream (_ceb ,_ceb );};};return _ceb ,nil ;};

// Authenticate implements StdHandler interface.
func (_fgg stdHandlerR4 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){_bfe .Log .Trace ("\u0044\u0065b\u0075\u0067\u0067\u0069n\u0067\u0020a\u0075\u0074\u0068\u0065\u006e\u0074\u0069\u0063a\u0074\u0069\u006f\u006e\u0020\u002d\u0020\u006f\u0077\u006e\u0065\u0072 \u0070\u0061\u0073\u0073");
_fec ,_eeg :=_fgg .alg7 (d ,pass );if _eeg !=nil {return nil ,0,_eeg ;};if _fec !=nil {_bfe .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _fec ,PermOwner ,nil ;
};_bfe .Log .Trace ("\u0044\u0065bu\u0067\u0067\u0069n\u0067\u0020\u0061\u0075the\u006eti\u0063\u0061\u0074\u0069\u006f\u006e\u0020- \u0075\u0073\u0065\u0072\u0020\u0070\u0061s\u0073");_fec ,_eeg =_fgg .alg6 (d ,pass );if _eeg !=nil {return nil ,0,_eeg ;
};if _fec !=nil {_bfe .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _fec ,d .P ,nil ;};return nil ,0,nil ;};func _g (_ad _f .Block )_f .BlockMode {return (*ecbEncrypter )(_bc (_ad ))};


// StdEncryptDict is a set of additional fields used in standard encryption dictionary.
type StdEncryptDict struct{R int ;P Permissions ;EncryptMetadata bool ;O ,U []byte ;OE ,UE []byte ;Perms []byte ;};

// GenerateParams is the algorithm opposite to alg2a (R>=5).
// It generates U,O,UE,OE,Perms fields using AESv3 encryption.
// There is no algorithm number assigned to this function in the spec.
// It expects R, P and EncryptMetadata fields to be set.
func (_fcae stdHandlerR6 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){_dgd :=make ([]byte ,32);if _ ,_fgf :=_ed .ReadFull (_dc .Reader ,_dgd );_fgf !=nil {return nil ,_fgf ;};d .U =nil ;d .O =nil ;d .UE =nil ;d .OE =nil ;d .Perms =nil ;
if len (upass )> 127{upass =upass [:127];};if len (opass )> 127{opass =opass [:127];};if _eee :=_fcae .alg8 (d ,_dgd ,upass );_eee !=nil {return nil ,_eee ;};if _bcb :=_fcae .alg9 (d ,_dgd ,opass );_bcb !=nil {return nil ,_bcb ;};if d .R ==5{return _dgd ,nil ;
};if _fdfe :=_fcae .alg10 (d ,_dgd );_fdfe !=nil {return nil ,_fdfe ;};return _dgd ,nil ;};const (EventDocOpen =AuthEvent ("\u0044o\u0063\u004f\u0070\u0065\u006e");EventEFOpen =AuthEvent ("\u0045\u0046\u004f\u0070\u0065\u006e"););func (_daa stdHandlerR6 )alg13 (_ggfd *StdEncryptDict ,_bcgg []byte )error {if _fbd :=_ffg ("\u0061\u006c\u00671\u0033","\u004b\u0065\u0079",32,_bcgg );
_fbd !=nil {return _fbd ;};if _efd :=_ffg ("\u0061\u006c\u00671\u0033","\u0050\u0065\u0072m\u0073",16,_ggfd .Perms );_efd !=nil {return _efd ;};_efff :=make ([]byte ,16);copy (_efff ,_ggfd .Perms [:16]);_fgbb ,_adf :=_c .NewCipher (_bcgg [:32]);if _adf !=nil {return _adf ;
};_ecbb :=_aga (_fgbb );_ecbb .CryptBlocks (_efff ,_efff );if !_ab .Equal (_efff [9:12],[]byte ("\u0061\u0064\u0062")){return _a .New ("\u0064\u0065\u0063o\u0064\u0065\u0064\u0020p\u0065\u0072\u006d\u0069\u0073\u0073\u0069o\u006e\u0073\u0020\u0061\u0072\u0065\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};_aaba :=Permissions (_ec .LittleEndian .Uint32 (_efff [0:4]));if _aaba !=_ggfd .P {return _a .New ("\u0070\u0065r\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066\u0061il\u0065\u0064");
};var _fca bool ;if _efff [8]=='T'{_fca =true ;}else if _efff [8]=='F'{_fca =false ;}else {return _a .New ("\u0064\u0065\u0063\u006f\u0064\u0065\u0064 \u006d\u0065\u0074a\u0064\u0061\u0074\u0061 \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u006c\u0061\u0067\u0020\u0069\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};if _fca !=_ggfd .EncryptMetadata {return _a .New ("\u006d\u0065t\u0061\u0064\u0061\u0074a\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e \u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066a\u0069\u006c\u0065\u0064");
};return nil ;};type stdHandlerR4 struct{Length int ;ID0 string ;};

// NewHandlerR4 creates a new standard security handler for R<=4.
func NewHandlerR4 (id0 string ,length int )StdHandler {return stdHandlerR4 {ID0 :id0 ,Length :length }};type errInvalidField struct{Func string ;Field string ;Exp int ;Got int ;};type stdHandlerR6 struct{};func (_cbb stdHandlerR4 )alg2 (_eb *StdEncryptDict ,_gfe []byte )[]byte {_bfe .Log .Trace ("\u0061\u006c\u0067\u0032");
_fc :=_cbb .paddedPass (_gfe );_fcd :=_bf .New ();_fcd .Write (_fc );_fcd .Write (_eb .O );var _cc [4]byte ;_ec .LittleEndian .PutUint32 (_cc [:],uint32 (_eb .P ));_fcd .Write (_cc [:]);_bfe .Log .Trace ("\u0067o\u0020\u0050\u003a\u0020\u0025\u0020x",_cc );
_fcd .Write ([]byte (_cbb .ID0 ));_bfe .Log .Trace ("\u0074\u0068\u0069\u0073\u002e\u0052\u0020\u003d\u0020\u0025d\u0020\u0065\u006e\u0063\u0072\u0079\u0070t\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061\u0020\u0025\u0076",_eb .R ,_eb .EncryptMetadata );
if (_eb .R >=4)&&!_eb .EncryptMetadata {_fcd .Write ([]byte {0xff,0xff,0xff,0xff});};_dac :=_fcd .Sum (nil );if _eb .R >=3{_fcd =_bf .New ();for _ccg :=0;_ccg < 50;_ccg ++{_fcd .Reset ();_fcd .Write (_dac [0:_cbb .Length /8]);_dac =_fcd .Sum (nil );};};
if _eb .R >=3{return _dac [0:_cbb .Length /8];};return _dac [0:5];};func (_aa stdHandlerR4 )alg3Key (R int ,_eg []byte )[]byte {_agg :=_bf .New ();_fbf :=_aa .paddedPass (_eg );_agg .Write (_fbf );if R >=3{for _dbe :=0;_dbe < 50;_dbe ++{_ga :=_agg .Sum (nil );
_agg =_bf .New ();_agg .Write (_ga );};};_ea :=_agg .Sum (nil );if R ==2{_ea =_ea [0:5];}else {_ea =_ea [0:_aa .Length /8];};return _ea ;};