//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package security ;import (_d "bytes";_g "crypto/aes";_f "crypto/cipher";_cb "crypto/md5";_bf "crypto/rand";_bg "crypto/rc4";_fd "crypto/sha256";_a "crypto/sha512";_bc "encoding/binary";_cf "errors";_ga "fmt";_cbd "github.com/unidoc/unipdf/v3/common";_ba "hash";
_c "io";_cd "math";);func _dbac (_cga ,_gfgg ,_dfea []byte )([]byte ,error ){var (_egg ,_daa ,_cbfe _ba .Hash ;);_egg =_fd .New ();_edee :=make ([]byte ,64);_gdd :=_egg ;_gdd .Write (_cga );K :=_gdd .Sum (_edee [:0]);_ega :=make ([]byte ,64*(127+64+48));
_bab :=func (_fdg int )([]byte ,error ){_bad :=len (_gfgg )+len (K )+len (_dfea );_ccd :=_ega [:_bad ];_dece :=copy (_ccd ,_gfgg );_dece +=copy (_ccd [_dece :],K [:]);_dece +=copy (_ccd [_dece :],_dfea );if _dece !=_bad {_cbd .Log .Error ("E\u0052\u0052\u004f\u0052\u003a\u0020u\u006e\u0065\u0078\u0070\u0065\u0063t\u0065\u0064\u0020\u0072\u006f\u0075\u006ed\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0073\u0069\u007ae\u002e");
return nil ,_cf .New ("\u0077\u0072\u006f\u006e\u0067\u0020\u0073\u0069\u007a\u0065");};K1 :=_ega [:_bad *64];_aca (K1 ,_bad );_dcf ,_fgb :=_daeb (K [0:16]);if _fgb !=nil {return nil ,_fgb ;};_decf :=_f .NewCBCEncrypter (_dcf ,K [16:32]);_decf .CryptBlocks (K1 ,K1 );
E :=K1 ;_eef :=0;for _ad :=0;_ad < 16;_ad ++{_eef +=int (E [_ad ]%3);};var _eaa _ba .Hash ;switch _eef %3{case 0:_eaa =_egg ;case 1:if _daa ==nil {_daa =_a .New384 ();};_eaa =_daa ;case 2:if _cbfe ==nil {_cbfe =_a .New ();};_eaa =_cbfe ;};_eaa .Reset ();
_eaa .Write (E );K =_eaa .Sum (_edee [:0]);return E ,nil ;};for _dbb :=0;;{E ,_gce :=_bab (_dbb );if _gce !=nil {return nil ,_gce ;};_def :=E [len (E )-1];_dbb ++;if _dbb >=64&&_def <=uint8 (_dbb -32){break ;};};return K [:32],nil ;};type stdHandlerR6 struct{};
func (_cfa stdHandlerR6 )alg2a (_efe *StdEncryptDict ,_dce []byte )([]byte ,Permissions ,error ){if _agb :=_ca ("\u0061\u006c\u00672\u0061","\u004f",48,_efe .O );_agb !=nil {return nil ,0,_agb ;};if _baf :=_ca ("\u0061\u006c\u00672\u0061","\u0055",48,_efe .U );
_baf !=nil {return nil ,0,_baf ;};if len (_dce )> 127{_dce =_dce [:127];};_gcfe ,_agg :=_cfa .alg12 (_efe ,_dce );if _agg !=nil {return nil ,0,_agg ;};var (_ged []byte ;_fbe []byte ;_ccfc []byte ;);var _eeg Permissions ;if len (_gcfe )!=0{_eeg =PermOwner ;
_gg :=make ([]byte ,len (_dce )+8+48);_aac :=copy (_gg ,_dce );_aac +=copy (_gg [_aac :],_efe .O [40:48]);copy (_gg [_aac :],_efe .U [0:48]);_ged =_gg ;_fbe =_efe .OE ;_ccfc =_efe .U [0:48];}else {_gcfe ,_agg =_cfa .alg11 (_efe ,_dce );if _agg ==nil &&len (_gcfe )==0{_gcfe ,_agg =_cfa .alg11 (_efe ,[]byte (""));
};if _agg !=nil {return nil ,0,_agg ;}else if len (_gcfe )==0{return nil ,0,nil ;};_eeg =_efe .P ;_cfb :=make ([]byte ,len (_dce )+8);_cda :=copy (_cfb ,_dce );copy (_cfb [_cda :],_efe .U [40:48]);_ged =_cfb ;_fbe =_efe .UE ;_ccfc =nil ;};if _fdc :=_ca ("\u0061\u006c\u00672\u0061","\u004b\u0065\u0079",32,_fbe );
_fdc !=nil {return nil ,0,_fdc ;};_fbe =_fbe [:32];_ffd ,_agg :=_cfa .alg2b (_efe .R ,_ged ,_dce ,_ccfc );if _agg !=nil {return nil ,0,_agg ;};_bfc ,_agg :=_g .NewCipher (_ffd [:32]);if _agg !=nil {return nil ,0,_agg ;};_aefc :=make ([]byte ,_g .BlockSize );
_fef :=_f .NewCBCDecrypter (_bfc ,_aefc );_gedg :=make ([]byte ,32);_fef .CryptBlocks (_gedg ,_fbe );if _efe .R ==5{return _gedg ,_eeg ,nil ;};_agg =_cfa .alg13 (_efe ,_gedg );if _agg !=nil {return nil ,0,_agg ;};return _gedg ,_eeg ,nil ;};func _aca (_ccb []byte ,_ggc int ){_dca :=_ggc ;
for _dca < len (_ccb ){copy (_ccb [_dca :],_ccb [:_dca ]);_dca *=2;};};const (EventDocOpen =AuthEvent ("\u0044o\u0063\u004f\u0070\u0065\u006e");EventEFOpen =AuthEvent ("\u0045\u0046\u004f\u0070\u0065\u006e"););

// GenerateParams generates and sets O and U parameters for the encryption dictionary.
// It expects R, P and EncryptMetadata fields to be set.
func (_bbe stdHandlerR4 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){O ,_aef :=_bbe .alg3 (d .R ,upass ,opass );if _aef !=nil {_cbd .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_aef );
return nil ,_aef ;};d .O =O ;_cbd .Log .Trace ("\u0067\u0065\u006e\u0020\u004f\u003a\u0020\u0025\u0020\u0078",O );_caf :=_bbe .alg2 (d ,upass );U ,_aef :=_bbe .alg5 (_caf ,upass );if _aef !=nil {_cbd .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_aef );
return nil ,_aef ;};d .U =U ;_cbd .Log .Trace ("\u0067\u0065\u006e\u0020\u0055\u003a\u0020\u0025\u0020\u0078",U );return _caf ,nil ;};func (_aecf stdHandlerR6 )alg10 (_dgda *StdEncryptDict ,_egbc []byte )error {if _egd :=_ca ("\u0061\u006c\u00671\u0030","\u004b\u0065\u0079",32,_egbc );
_egd !=nil {return _egd ;};_dac :=uint64 (uint32 (_dgda .P ))|(_cd .MaxUint32 <<32);Perms :=make ([]byte ,16);_bc .LittleEndian .PutUint64 (Perms [:8],_dac );if _dgda .EncryptMetadata {Perms [8]='T';}else {Perms [8]='F';};copy (Perms [9:12],"\u0061\u0064\u0062");
if _ ,_dgde :=_c .ReadFull (_bf .Reader ,Perms [12:16]);_dgde !=nil {return _dgde ;};_ggf ,_eba :=_daeb (_egbc [:32]);if _eba !=nil {return _eba ;};_acbc :=_gf (_ggf );_acbc .CryptBlocks (Perms ,Perms );_dgda .Perms =Perms [:16];return nil ;};func (_gfg stdHandlerR4 )alg7 (_dea *StdEncryptDict ,_ccg []byte )([]byte ,error ){_afd :=_gfg .alg3Key (_dea .R ,_ccg );
_afa :=make ([]byte ,len (_dea .O ));if _dea .R ==2{_afc ,_cbf :=_bg .NewCipher (_afd );if _cbf !=nil {return nil ,_cf .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_afc .XORKeyStream (_afa ,_dea .O );}else if _dea .R >=3{_gfe :=append ([]byte {},_dea .O ...);
for _abf :=0;_abf < 20;_abf ++{_dbc :=append ([]byte {},_afd ...);for _bee :=0;_bee < len (_afd );_bee ++{_dbc [_bee ]^=byte (19-_abf );};_ced ,_bfg :=_bg .NewCipher (_dbc );if _bfg !=nil {return nil ,_cf .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");
};_ced .XORKeyStream (_afa ,_gfe );_gfe =append ([]byte {},_afa ...);};}else {return nil ,_cf .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};_aec ,_dfb :=_gfg .alg6 (_dea ,_afa );if _dfb !=nil {return nil ,nil ;};return _aec ,nil ;};

// StdHandler is an interface for standard security handlers.
type StdHandler interface{

// GenerateParams uses owner and user passwords to set encryption parameters and generate an encryption key.
// It assumes that R, P and EncryptMetadata are already set.
GenerateParams (_ec *StdEncryptDict ,_ge ,_ae []byte )([]byte ,error );

// Authenticate uses encryption dictionary parameters and the password to calculate
// the document encryption key. It also returns permissions that should be granted to a user.
// In case of failed authentication, it returns empty key and zero permissions with no error.
Authenticate (_dd *StdEncryptDict ,_ee []byte )([]byte ,Permissions ,error );};func (_egdb stdHandlerR6 )alg12 (_gaf *StdEncryptDict ,_ggeg []byte )([]byte ,error ){if _fba :=_ca ("\u0061\u006c\u00671\u0032","\u0055",48,_gaf .U );_fba !=nil {return nil ,_fba ;
};if _eeee :=_ca ("\u0061\u006c\u00671\u0032","\u004f",48,_gaf .O );_eeee !=nil {return nil ,_eeee ;};_fcc :=make ([]byte ,len (_ggeg )+8+48);_ddf :=copy (_fcc ,_ggeg );_ddf +=copy (_fcc [_ddf :],_gaf .O [32:40]);_ddf +=copy (_fcc [_ddf :],_gaf .U [0:48]);
_feff ,_acf :=_egdb .alg2b (_gaf .R ,_fcc ,_ggeg ,_gaf .U [0:48]);if _acf !=nil {return nil ,_acf ;};_feff =_feff [:32];if !_d .Equal (_feff ,_gaf .O [:32]){return nil ,nil ;};return _feff ,nil ;};func (_dg errInvalidField )Error ()string {return _ga .Sprintf ("\u0025s\u003a\u0020e\u0078\u0070\u0065\u0063t\u0065\u0064\u0020%\u0073\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0074o \u0062\u0065\u0020%\u0064\u0020b\u0079\u0074\u0065\u0073\u002c\u0020g\u006f\u0074 \u0025\u0064",_dg .Func ,_dg .Field ,_dg .Exp ,_dg .Got );
};func (_abb stdHandlerR4 )alg3Key (R int ,_cfg []byte )[]byte {_ac :=_cb .New ();_bdg :=_abb .paddedPass (_cfg );_ac .Write (_bdg );if R >=3{for _gd :=0;_gd < 50;_gd ++{_bdb :=_ac .Sum (nil );_ac =_cb .New ();_ac .Write (_bdb );};};_bcc :=_ac .Sum (nil );
if R ==2{_bcc =_bcc [0:5];}else {_bcc =_bcc [0:_abb .Length /8];};return _bcc ;};func (_fc *ecbEncrypter )BlockSize ()int {return _fc ._eg };func (_fgd stdHandlerR6 )alg9 (_cbef *StdEncryptDict ,_agf []byte ,_gae []byte )error {if _dab :=_ca ("\u0061\u006c\u0067\u0039","\u004b\u0065\u0079",32,_agf );
_dab !=nil {return _dab ;};if _cgd :=_ca ("\u0061\u006c\u0067\u0039","\u0055",48,_cbef .U );_cgd !=nil {return _cgd ;};var _gdb [16]byte ;if _ ,_cfab :=_c .ReadFull (_bf .Reader ,_gdb [:]);_cfab !=nil {return _cfab ;};_cdag :=_gdb [0:8];_dgac :=_gdb [8:16];
_afga :=_cbef .U [:48];_egc :=make ([]byte ,len (_gae )+len (_cdag )+len (_afga ));_acc :=copy (_egc ,_gae );_acc +=copy (_egc [_acc :],_cdag );_acc +=copy (_egc [_acc :],_afga );_fda ,_gbg :=_fgd .alg2b (_cbef .R ,_egc ,_gae ,_afga );if _gbg !=nil {return _gbg ;
};O :=make ([]byte ,len (_fda )+len (_cdag )+len (_dgac ));_acc =copy (O ,_fda [:32]);_acc +=copy (O [_acc :],_cdag );_acc +=copy (O [_acc :],_dgac );_cbef .O =O ;_acc =len (_gae );_acc +=copy (_egc [_acc :],_dgac );_fda ,_gbg =_fgd .alg2b (_cbef .R ,_egc ,_gae ,_afga );
if _gbg !=nil {return _gbg ;};_ecb ,_gbg :=_daeb (_fda [:32]);if _gbg !=nil {return _gbg ;};_cefc :=make ([]byte ,_g .BlockSize );_aba :=_f .NewCBCEncrypter (_ecb ,_cefc );OE :=make ([]byte ,32);_aba .CryptBlocks (OE ,_agf [:32]);_cbef .OE =OE ;return nil ;
};func (_eb stdHandlerR4 )alg2 (_gc *StdEncryptDict ,_bca []byte )[]byte {_cbd .Log .Trace ("\u0061\u006c\u0067\u0032");_ebb :=_eb .paddedPass (_bca );_fb :=_cb .New ();_fb .Write (_ebb );_fb .Write (_gc .O );var _ff [4]byte ;_bc .LittleEndian .PutUint32 (_ff [:],uint32 (_gc .P ));
_fb .Write (_ff [:]);_cbd .Log .Trace ("\u0067o\u0020\u0050\u003a\u0020\u0025\u0020x",_ff );_fb .Write ([]byte (_eb .ID0 ));_cbd .Log .Trace ("\u0074\u0068\u0069\u0073\u002e\u0052\u0020\u003d\u0020\u0025d\u0020\u0065\u006e\u0063\u0072\u0079\u0070t\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061\u0020\u0025\u0076",_gc .R ,_gc .EncryptMetadata );
if (_gc .R >=4)&&!_gc .EncryptMetadata {_fb .Write ([]byte {0xff,0xff,0xff,0xff});};_gcf :=_fb .Sum (nil );if _gc .R >=3{_fb =_cb .New ();for _afg :=0;_afg < 50;_afg ++{_fb .Reset ();_fb .Write (_gcf [0:_eb .Length /8]);_gcf =_fb .Sum (nil );};};if _gc .R >=3{return _gcf [0:_eb .Length /8];
};return _gcf [0:5];};var _ StdHandler =stdHandlerR6 {};const _ce ="\x28\277\116\136\x4e\x75\x8a\x41\x64\000\x4e\x56\377"+"\xfa\001\010\056\x2e\x00\xb6\xd0\x68\076\x80\x2f\014"+"\251\xfe\x64\x53\x69\172";func _cc (_fe _f .Block )*ecb {return &ecb {_e :_fe ,_eg :_fe .BlockSize ()}};


// Authenticate implements StdHandler interface.
func (_egb stdHandlerR4 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){_cbd .Log .Trace ("\u0044\u0065b\u0075\u0067\u0067\u0069n\u0067\u0020a\u0075\u0074\u0068\u0065\u006e\u0074\u0069\u0063a\u0074\u0069\u006f\u006e\u0020\u002d\u0020\u006f\u0077\u006e\u0065\u0072 \u0070\u0061\u0073\u0073");
_cef ,_dad :=_egb .alg7 (d ,pass );if _dad !=nil {return nil ,0,_dad ;};if _cef !=nil {_cbd .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _cef ,PermOwner ,nil ;
};_cbd .Log .Trace ("\u0044\u0065bu\u0067\u0067\u0069n\u0067\u0020\u0061\u0075the\u006eti\u0063\u0061\u0074\u0069\u006f\u006e\u0020- \u0075\u0073\u0065\u0072\u0020\u0070\u0061s\u0073");_cef ,_dad =_egb .alg6 (d ,pass );if _dad !=nil {return nil ,0,_dad ;
};if _cef !=nil {_cbd .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _cef ,d .P ,nil ;};return nil ,0,nil ;};func _dec (_ffc []byte )([]byte ,error ){_dfd :=_fd .New ();
_dfd .Write (_ffc );return _dfd .Sum (nil ),nil ;};const (PermOwner =Permissions (_cd .MaxUint32 );PermPrinting =Permissions (1<<2);PermModify =Permissions (1<<3);PermExtractGraphics =Permissions (1<<4);PermAnnotate =Permissions (1<<5);PermFillForms =Permissions (1<<8);
PermDisabilityExtract =Permissions (1<<9);PermRotateInsert =Permissions (1<<10);PermFullPrintQuality =Permissions (1<<11););func (_ed *ecbDecrypter )CryptBlocks (dst ,src []byte ){if len (src )%_ed ._eg !=0{_cbd .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_cbd .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0064\u0065\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_ed ._e .Decrypt (dst ,src [:_ed ._eg ]);src =src [_ed ._eg :];dst =dst [_ed ._eg :];};};

// Authenticate implements StdHandler interface.
func (_bba stdHandlerR6 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){return _bba .alg2a (d ,pass );};type ecb struct{_e _f .Block ;_eg int ;};func (_dfdc stdHandlerR6 )alg13 (_gfc *StdEncryptDict ,_abfa []byte )error {if _cca :=_ca ("\u0061\u006c\u00671\u0033","\u004b\u0065\u0079",32,_abfa );
_cca !=nil {return _cca ;};if _dbbf :=_ca ("\u0061\u006c\u00671\u0033","\u0050\u0065\u0072m\u0073",16,_gfc .Perms );_dbbf !=nil {return _dbbf ;};_fbg :=make ([]byte ,16);copy (_fbg ,_gfc .Perms [:16]);_fcg ,_cgf :=_g .NewCipher (_abfa [:32]);if _cgf !=nil {return _cgf ;
};_ffcd :=_ea (_fcg );_ffcd .CryptBlocks (_fbg ,_fbg );if !_d .Equal (_fbg [9:12],[]byte ("\u0061\u0064\u0062")){return _cf .New ("\u0064\u0065\u0063o\u0064\u0065\u0064\u0020p\u0065\u0072\u006d\u0069\u0073\u0073\u0069o\u006e\u0073\u0020\u0061\u0072\u0065\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};_ecc :=Permissions (_bc .LittleEndian .Uint32 (_fbg [0:4]));if _ecc !=_gfc .P {return _cf .New ("\u0070\u0065r\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066\u0061il\u0065\u0064");
};var _aefe bool ;if _fbg [8]=='T'{_aefe =true ;}else if _fbg [8]=='F'{_aefe =false ;}else {return _cf .New ("\u0064\u0065\u0063\u006f\u0064\u0065\u0064 \u006d\u0065\u0074a\u0064\u0061\u0074\u0061 \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u006c\u0061\u0067\u0020\u0069\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};if _aefe !=_gfc .EncryptMetadata {return _cf .New ("\u006d\u0065t\u0061\u0064\u0061\u0074a\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e \u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066a\u0069\u006c\u0065\u0064");
};return nil ;};type ecbEncrypter ecb ;func _ca (_cdc ,_df string ,_db int ,_cg []byte )error {if len (_cg )< _db {return errInvalidField {Func :_cdc ,Field :_df ,Exp :_db ,Got :len (_cg )};};return nil ;};

// Permissions is a bitmask of access permissions for a PDF file.
type Permissions uint32 ;func (_dae *ecbDecrypter )BlockSize ()int {return _dae ._eg };func (_ecg stdHandlerR4 )alg3 (R int ,_gea ,_gcb []byte )([]byte ,error ){var _gcfc []byte ;if len (_gcb )> 0{_gcfc =_ecg .alg3Key (R ,_gcb );}else {_gcfc =_ecg .alg3Key (R ,_gea );
};_dc ,_ccf :=_bg .NewCipher (_gcfc );if _ccf !=nil {return nil ,_cf .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_aff :=_ecg .paddedPass (_gea );_gdc :=make ([]byte ,len (_aff ));_dc .XORKeyStream (_gdc ,_aff );
if R >=3{_geb :=make ([]byte ,len (_gcfc ));for _dfed :=0;_dfed < 19;_dfed ++{for _bdc :=0;_bdc < len (_gcfc );_bdc ++{_geb [_bdc ]=_gcfc [_bdc ]^byte (_dfed +1);};_ceg ,_dba :=_bg .NewCipher (_geb );if _dba !=nil {return nil ,_cf .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_ceg .XORKeyStream (_gdc ,_gdc );};};return _gdc ,nil ;};func (_cce stdHandlerR4 )alg5 (_ef []byte ,_ffb []byte )([]byte ,error ){_gfa :=_cb .New ();_gfa .Write ([]byte (_ce ));_gfa .Write ([]byte (_cce .ID0 ));_bdgc :=_gfa .Sum (nil );_cbd .Log .Trace ("\u0061\u006c\u0067\u0035");
_cbd .Log .Trace ("\u0065k\u0065\u0079\u003a\u0020\u0025\u0020x",_ef );_cbd .Log .Trace ("\u0049D\u003a\u0020\u0025\u0020\u0078",_cce .ID0 );if len (_bdgc )!=16{return nil ,_cf .New ("\u0068a\u0073\u0068\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074\u0020\u0031\u0036\u0020\u0062\u0079\u0074\u0065\u0073");
};_ag ,_fa :=_bg .NewCipher (_ef );if _fa !=nil {return nil ,_cf .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_fbb :=make ([]byte ,16);_ag .XORKeyStream (_fbb ,_bdgc );_dga :=make ([]byte ,len (_ef ));for _gag :=0;
_gag < 19;_gag ++{for _gb :=0;_gb < len (_ef );_gb ++{_dga [_gb ]=_ef [_gb ]^byte (_gag +1);};_ag ,_fa =_bg .NewCipher (_dga );if _fa !=nil {return nil ,_cf .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_ag .XORKeyStream (_fbb ,_fbb );
_cbd .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u002c\u0020\u0065\u006b\u0065\u0079:\u0020\u0025\u0020\u0078",_gag ,_dga );_cbd .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0020\u0078",_gag ,_fbb );};_bb :=make ([]byte ,32);
for _aed :=0;_aed < 16;_aed ++{_bb [_aed ]=_fbb [_aed ];};_ ,_fa =_bf .Read (_bb [16:32]);if _fa !=nil {return nil ,_cf .New ("\u0066a\u0069\u006c\u0065\u0064 \u0074\u006f\u0020\u0067\u0065n\u0020r\u0061n\u0064\u0020\u006e\u0075\u006d\u0062\u0065r");};
return _bb ,nil ;};func (stdHandlerR4 )paddedPass (_fg []byte )[]byte {_dfe :=make ([]byte ,32);_af :=copy (_dfe ,_fg );for ;_af < 32;_af ++{_dfe [_af ]=_ce [_af -len (_fg )];};return _dfe ;};func _daeb (_fgf []byte )(_f .Block ,error ){_egf ,_dgd :=_g .NewCipher (_fgf );
if _dgd !=nil {_cbd .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0063\u0072\u0065\u0061\u0074\u0065\u0020A\u0045\u0053\u0020\u0063\u0069p\u0068\u0065r\u003a\u0020\u0025\u0076",_dgd );
return nil ,_dgd ;};return _egf ,nil ;};func _gf (_da _f .Block )_f .BlockMode {return (*ecbEncrypter )(_cc (_da ))};type stdHandlerR4 struct{Length int ;ID0 string ;};var _ StdHandler =stdHandlerR4 {};func (_gge stdHandlerR6 )alg2b (R int ,_dfbg ,_gec ,_dcd []byte )([]byte ,error ){if R ==5{return _dec (_dfbg );
};return _dbac (_dfbg ,_gec ,_dcd );};type ecbDecrypter ecb ;

// NewHandlerR4 creates a new standard security handler for R<=4.
func NewHandlerR4 (id0 string ,length int )StdHandler {return stdHandlerR4 {ID0 :id0 ,Length :length }};

// NewHandlerR6 creates a new standard security handler for R=5 and R=6.
func NewHandlerR6 ()StdHandler {return stdHandlerR6 {}};

// Allowed checks if a set of permissions can be granted.
func (_eda Permissions )Allowed (p2 Permissions )bool {return _eda &p2 ==p2 };func _ea (_bd _f .Block )_f .BlockMode {return (*ecbDecrypter )(_cc (_bd ))};

// StdEncryptDict is a set of additional fields used in standard encryption dictionary.
type StdEncryptDict struct{R int ;P Permissions ;EncryptMetadata bool ;O ,U []byte ;OE ,UE []byte ;Perms []byte ;};func (_eeb stdHandlerR4 )alg6 (_bdca *StdEncryptDict ,_gbd []byte )([]byte ,error ){var (_fedb []byte ;_be error ;);_fedf :=_eeb .alg2 (_bdca ,_gbd );
if _bdca .R ==2{_fedb ,_be =_eeb .alg4 (_fedf ,_gbd );}else if _bdca .R >=3{_fedb ,_be =_eeb .alg5 (_fedf ,_gbd );}else {return nil ,_cf .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};if _be !=nil {return nil ,_be ;};_cbd .Log .Trace ("\u0063\u0068\u0065\u0063k:\u0020\u0025\u0020\u0078\u0020\u003d\u003d\u0020\u0025\u0020\u0078\u0020\u003f",string (_fedb ),string (_bdca .U ));
_bdd :=_fedb ;_cge :=_bdca .U ;if _bdca .R >=3{if len (_bdd )> 16{_bdd =_bdd [0:16];};if len (_cge )> 16{_cge =_cge [0:16];};};if !_d .Equal (_bdd ,_cge ){return nil ,nil ;};return _fedf ,nil ;};func (_bfd stdHandlerR4 )alg4 (_ede []byte ,_bfdc []byte )([]byte ,error ){_bda ,_aa :=_bg .NewCipher (_ede );
if _aa !=nil {return nil ,_cf .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_fed :=[]byte (_ce );_cbc :=make ([]byte ,len (_fed ));_bda .XORKeyStream (_cbc ,_fed );return _cbc ,nil ;};func (_bgc stdHandlerR6 )alg11 (_eaff *StdEncryptDict ,_gac []byte )([]byte ,error ){if _ccfe :=_ca ("\u0061\u006c\u00671\u0031","\u0055",48,_eaff .U );
_ccfe !=nil {return nil ,_ccfe ;};_acca :=make ([]byte ,len (_gac )+8);_cgb :=copy (_acca ,_gac );_cgb +=copy (_acca [_cgb :],_eaff .U [32:40]);_cea ,_aga :=_bgc .alg2b (_eaff .R ,_acca ,_gac ,nil );if _aga !=nil {return nil ,_aga ;};_cea =_cea [:32];if !_d .Equal (_cea ,_eaff .U [:32]){return nil ,nil ;
};return _cea ,nil ;};type errInvalidField struct{Func string ;Field string ;Exp int ;Got int ;};

// GenerateParams is the algorithm opposite to alg2a (R>=5).
// It generates U,O,UE,OE,Perms fields using AESv3 encryption.
// There is no algorithm number assigned to this function in the spec.
// It expects R, P and EncryptMetadata fields to be set.
func (_fcce stdHandlerR6 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){_bfde :=make ([]byte ,32);if _ ,_fff :=_c .ReadFull (_bf .Reader ,_bfde );_fff !=nil {return nil ,_fff ;};d .U =nil ;d .O =nil ;d .UE =nil ;d .OE =nil ;d .Perms =nil ;
if len (upass )> 127{upass =upass [:127];};if len (opass )> 127{opass =opass [:127];};if _fad :=_fcce .alg8 (d ,_bfde ,upass );_fad !=nil {return nil ,_fad ;};if _bbeg :=_fcce .alg9 (d ,_bfde ,opass );_bbeg !=nil {return nil ,_bbeg ;};if d .R ==5{return _bfde ,nil ;
};if _cgg :=_fcce .alg10 (d ,_bfde );_cgg !=nil {return nil ,_cgg ;};return _bfde ,nil ;};func (_fbc stdHandlerR6 )alg8 (_gee *StdEncryptDict ,_baba []byte ,_fac []byte )error {if _cbe :=_ca ("\u0061\u006c\u0067\u0038","\u004b\u0065\u0079",32,_baba );_cbe !=nil {return _cbe ;
};var _acaf [16]byte ;if _ ,_abbb :=_c .ReadFull (_bf .Reader ,_acaf [:]);_abbb !=nil {return _abbb ;};_dge :=_acaf [0:8];_adf :=_acaf [8:16];_gcg :=make ([]byte ,len (_fac )+len (_dge ));_add :=copy (_gcg ,_fac );copy (_gcg [_add :],_dge );_cdcb ,_gddf :=_fbc .alg2b (_gee .R ,_gcg ,_fac ,nil );
if _gddf !=nil {return _gddf ;};U :=make ([]byte ,len (_cdcb )+len (_dge )+len (_adf ));_add =copy (U ,_cdcb [:32]);_add +=copy (U [_add :],_dge );copy (U [_add :],_adf );_gee .U =U ;_add =len (_fac );copy (_gcg [_add :],_adf );_cdcb ,_gddf =_fbc .alg2b (_gee .R ,_gcg ,_fac ,nil );
if _gddf !=nil {return _gddf ;};_acb ,_gddf :=_daeb (_cdcb [:32]);if _gddf !=nil {return _gddf ;};_cfc :=make ([]byte ,_g .BlockSize );_efd :=_f .NewCBCEncrypter (_acb ,_cfc );UE :=make ([]byte ,32);_efd .CryptBlocks (UE ,_baba [:32]);_gee .UE =UE ;return nil ;
};

// AuthEvent is an event type that triggers authentication.
type AuthEvent string ;func (_ab *ecbEncrypter )CryptBlocks (dst ,src []byte ){if len (src )%_ab ._eg !=0{_cbd .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_cbd .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_ab ._e .Encrypt (dst ,src [:_ab ._eg ]);src =src [_ab ._eg :];dst =dst [_ab ._eg :];};};