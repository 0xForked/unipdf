//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package security ;import (_gcc "bytes";_ab "crypto/aes";_c "crypto/cipher";_fd "crypto/md5";_gd "crypto/rand";_bf "crypto/rc4";_b "crypto/sha256";_g "crypto/sha512";_f "encoding/binary";_gc "errors";_ba "fmt";_fbd "github.com/unidoc/unipdf/v3/common";_ac "hash";_a "io";_fb "math";);func _aa (_ff _c .Block )*ecb {return &ecb {_baa :_ff ,_acg :_ff .BlockSize ()}};

// StdEncryptDict is a set of additional fields used in standard encryption dictionary.
type StdEncryptDict struct{R int ;P Permissions ;EncryptMetadata bool ;O ,U []byte ;OE ,UE []byte ;Perms []byte ;};func (_abc stdHandlerR6 )alg2b (R int ,_bfe ,_acdg ,_fba []byte )([]byte ,error ){if R ==5{return _be (_bfe );};return _ccd (_bfe ,_acdg ,_fba );};

// StdHandler is an interface for standard security handlers.
type StdHandler interface{

// GenerateParams uses owner and user passwords to set encryption parameters and generate an encryption key.
// It assumes that R, P and EncryptMetadata are already set.
GenerateParams (_ed *StdEncryptDict ,_dg ,_da []byte )([]byte ,error );

// Authenticate uses encryption dictionary parameters and the password to calculate
// the document encryption key. It also returns permissions that should be granted to a user.
// In case of failed authentication, it returns empty key and zero permissions with no error.
Authenticate (_bg *StdEncryptDict ,_aee []byte )([]byte ,Permissions ,error );};type stdHandlerR4 struct{Length int ;ID0 string ;};func (_ebe stdHandlerR6 )alg8 (_bba *StdEncryptDict ,_deb []byte ,_bea []byte )error {if _ddag :=_dd ("\u0061\u006c\u0067\u0038","\u004b\u0065\u0079",32,_deb );_ddag !=nil {return _ddag ;};var _cfed [16]byte ;if _ ,_bfga :=_a .ReadFull (_gd .Reader ,_cfed [:]);_bfga !=nil {return _bfga ;};_cdgd :=_cfed [0:8];_afb :=_cfed [8:16];_fbe :=make ([]byte ,len (_bea )+len (_cdgd ));_bae :=copy (_fbe ,_bea );copy (_fbe [_bae :],_cdgd );_cggd ,_gcbg :=_ebe .alg2b (_bba .R ,_fbe ,_bea ,nil );if _gcbg !=nil {return _gcbg ;};U :=make ([]byte ,len (_cggd )+len (_cdgd )+len (_afb ));_bae =copy (U ,_cggd [:32]);_bae +=copy (U [_bae :],_cdgd );copy (U [_bae :],_afb );_bba .U =U ;_bae =len (_bea );copy (_fbe [_bae :],_afb );_cggd ,_gcbg =_ebe .alg2b (_bba .R ,_fbe ,_bea ,nil );if _gcbg !=nil {return _gcbg ;};_faff ,_gcbg :=_gad (_cggd [:32]);if _gcbg !=nil {return _gcbg ;};_dcd :=make ([]byte ,_ab .BlockSize );_fcc :=_c .NewCBCEncrypter (_faff ,_dcd );UE :=make ([]byte ,32);_fcc .CryptBlocks (UE ,_deb [:32]);_bba .UE =UE ;return nil ;};type stdHandlerR6 struct{};func _dd (_fe ,_dac string ,_fdg int ,_dc []byte )error {if len (_dc )< _fdg {return errInvalidField {Func :_fe ,Field :_dac ,Exp :_fdg ,Got :len (_dc )};};return nil ;};

// Permissions is a bitmask of access permissions for a PDF file.
type Permissions uint32 ;const _fa ="\x28\277\116\136\x4e\x75\x8a\x41\x64\000\x4e\x56\377"+"\xfa\001\010\056\x2e\x00\xb6\xd0\x68\076\x80\x2f\014"+"\251\xfe\x64\x53\x69\172";func (_ae *ecbDecrypter )BlockSize ()int {return _ae ._acg };

// NewHandlerR6 creates a new standard security handler for R=5 and R=6.
func NewHandlerR6 ()StdHandler {return stdHandlerR6 {}};

// NewHandlerR4 creates a new standard security handler for R<=4.
func NewHandlerR4 (id0 string ,length int )StdHandler {return stdHandlerR4 {ID0 :id0 ,Length :length }};func _df (_ad _c .Block )_c .BlockMode {return (*ecbEncrypter )(_aa (_ad ))};func (_ee stdHandlerR4 )alg3Key (R int ,_dab []byte )[]byte {_faf :=_fd .New ();_aed :=_ee .paddedPass (_dab );_faf .Write (_aed );if R >=3{for _ca :=0;_ca < 50;_ca ++{_cc :=_faf .Sum (nil );_faf =_fd .New ();_faf .Write (_cc );};};_fff :=_faf .Sum (nil );if R ==2{_fff =_fff [0:5];}else {_fff =_fff [0:_ee .Length /8];};return _fff ;};type ecb struct{_baa _c .Block ;_acg int ;};func (_ccf stdHandlerR6 )alg13 (_aba *StdEncryptDict ,_ffg []byte )error {if _bcga :=_dd ("\u0061\u006c\u00671\u0033","\u004b\u0065\u0079",32,_ffg );_bcga !=nil {return _bcga ;};if _agaf :=_dd ("\u0061\u006c\u00671\u0033","\u0050\u0065\u0072m\u0073",16,_aba .Perms );_agaf !=nil {return _agaf ;};_dgfd :=make ([]byte ,16);copy (_dgfd ,_aba .Perms [:16]);_bbag ,_fea :=_ab .NewCipher (_ffg [:32]);if _fea !=nil {return _fea ;};_bbac :=_e (_bbag );_bbac .CryptBlocks (_dgfd ,_dgfd );if !_gcc .Equal (_dgfd [9:12],[]byte ("\u0061\u0064\u0062")){return _gc .New ("\u0064\u0065\u0063o\u0064\u0065\u0064\u0020p\u0065\u0072\u006d\u0069\u0073\u0073\u0069o\u006e\u0073\u0020\u0061\u0072\u0065\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_fffa :=Permissions (_f .LittleEndian .Uint32 (_dgfd [0:4]));if _fffa !=_aba .P {return _gc .New ("\u0070\u0065r\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066\u0061il\u0065\u0064");};var _dfa bool ;if _dgfd [8]=='T'{_dfa =true ;}else if _dgfd [8]=='F'{_dfa =false ;}else {return _gc .New ("\u0064\u0065\u0063\u006f\u0064\u0065\u0064 \u006d\u0065\u0074a\u0064\u0061\u0074\u0061 \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u006c\u0061\u0067\u0020\u0069\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};if _dfa !=_aba .EncryptMetadata {return _gc .New ("\u006d\u0065t\u0061\u0064\u0061\u0074a\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e \u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066a\u0069\u006c\u0065\u0064");};return nil ;};

// GenerateParams is the algorithm opposite to alg2a (R>=5).
// It generates U,O,UE,OE,Perms fields using AESv3 encryption.
// There is no algorithm number assigned to this function in the spec.
// It expects R, P and EncryptMetadata fields to be set.
func (_fffad stdHandlerR6 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){_abcc :=make ([]byte ,32);if _ ,_aeea :=_a .ReadFull (_gd .Reader ,_abcc );_aeea !=nil {return nil ,_aeea ;};d .U =nil ;d .O =nil ;d .UE =nil ;d .OE =nil ;d .Perms =nil ;if len (upass )> 127{upass =upass [:127];};if len (opass )> 127{opass =opass [:127];};if _gcga :=_fffad .alg8 (d ,_abcc ,upass );_gcga !=nil {return nil ,_gcga ;};if _bbae :=_fffad .alg9 (d ,_abcc ,opass );_bbae !=nil {return nil ,_bbae ;};if d .R ==5{return _abcc ,nil ;};if _eddg :=_fffad .alg10 (d ,_abcc );_eddg !=nil {return nil ,_eddg ;};return _abcc ,nil ;};func (_fbg stdHandlerR4 )alg5 (_ddc []byte ,_acgg []byte )([]byte ,error ){_agc :=_fd .New ();_agc .Write ([]byte (_fa ));_agc .Write ([]byte (_fbg .ID0 ));_ea :=_agc .Sum (nil );_fbd .Log .Trace ("\u0061\u006c\u0067\u0035");_fbd .Log .Trace ("\u0065k\u0065\u0079\u003a\u0020\u0025\u0020x",_ddc );_fbd .Log .Trace ("\u0049D\u003a\u0020\u0025\u0020\u0078",_fbg .ID0 );if len (_ea )!=16{return nil ,_gc .New ("\u0068a\u0073\u0068\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074\u0020\u0031\u0036\u0020\u0062\u0079\u0074\u0065\u0073");};_fc ,_dce :=_bf .NewCipher (_ddc );if _dce !=nil {return nil ,_gc .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_cd :=make ([]byte ,16);_fc .XORKeyStream (_cd ,_ea );_baf :=make ([]byte ,len (_ddc ));for _cab :=0;_cab < 19;_cab ++{for _dgf :=0;_dgf < len (_ddc );_dgf ++{_baf [_dgf ]=_ddc [_dgf ]^byte (_cab +1);};_fc ,_dce =_bf .NewCipher (_baf );if _dce !=nil {return nil ,_gc .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_fc .XORKeyStream (_cd ,_cd );_fbd .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u002c\u0020\u0065\u006b\u0065\u0079:\u0020\u0025\u0020\u0078",_cab ,_baf );_fbd .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0020\u0078",_cab ,_cd );};_fg :=make ([]byte ,32);for _fdb :=0;_fdb < 16;_fdb ++{_fg [_fdb ]=_cd [_fdb ];};_ ,_dce =_gd .Read (_fg [16:32]);if _dce !=nil {return nil ,_gc .New ("\u0066a\u0069\u006c\u0065\u0064 \u0074\u006f\u0020\u0067\u0065n\u0020r\u0061n\u0064\u0020\u006e\u0075\u006d\u0062\u0065r");};return _fg ,nil ;};func (_ge stdHandlerR4 )alg2 (_db *StdEncryptDict ,_cb []byte )[]byte {_fbd .Log .Trace ("\u0061\u006c\u0067\u0032");_eb :=_ge .paddedPass (_cb );_dbf :=_fd .New ();_dbf .Write (_eb );_dbf .Write (_db .O );var _bgb [4]byte ;_f .LittleEndian .PutUint32 (_bgb [:],uint32 (_db .P ));_dbf .Write (_bgb [:]);_fbd .Log .Trace ("\u0067o\u0020\u0050\u003a\u0020\u0025\u0020x",_bgb );_dbf .Write ([]byte (_ge .ID0 ));_fbd .Log .Trace ("\u0074\u0068\u0069\u0073\u002e\u0052\u0020\u003d\u0020\u0025d\u0020\u0065\u006e\u0063\u0072\u0079\u0070t\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061\u0020\u0025\u0076",_db .R ,_db .EncryptMetadata );if (_db .R >=4)&&!_db .EncryptMetadata {_dbf .Write ([]byte {0xff,0xff,0xff,0xff});};_cf :=_dbf .Sum (nil );if _db .R >=3{_dbf =_fd .New ();for _aab :=0;_aab < 50;_aab ++{_dbf .Reset ();_dbf .Write (_cf [0:_ge .Length /8]);_cf =_dbf .Sum (nil );};};if _db .R >=3{return _cf [0:_ge .Length /8];};return _cf [0:5];};func (_gfe stdHandlerR6 )alg10 (_eac *StdEncryptDict ,_acdb []byte )error {if _egf :=_dd ("\u0061\u006c\u00671\u0030","\u004b\u0065\u0079",32,_acdb );_egf !=nil {return _egf ;};_caea :=uint64 (uint32 (_eac .P ))|(_fb .MaxUint32 <<32);Perms :=make ([]byte ,16);_f .LittleEndian .PutUint64 (Perms [:8],_caea );if _eac .EncryptMetadata {Perms [8]='T';}else {Perms [8]='F';};copy (Perms [9:12],"\u0061\u0064\u0062");if _ ,_ddcf :=_a .ReadFull (_gd .Reader ,Perms [12:16]);_ddcf !=nil {return _ddcf ;};_ddb ,_cbdb :=_gad (_acdb [:32]);if _cbdb !=nil {return _cbdb ;};_feb :=_df (_ddb );_feb .CryptBlocks (Perms ,Perms );_eac .Perms =Perms [:16];return nil ;};func (_cfa stdHandlerR6 )alg2a (_bbd *StdEncryptDict ,_dacf []byte )([]byte ,Permissions ,error ){if _cbd :=_dd ("\u0061\u006c\u00672\u0061","\u004f",48,_bbd .O );_cbd !=nil {return nil ,0,_cbd ;};if _gcg :=_dd ("\u0061\u006c\u00672\u0061","\u0055",48,_bbd .U );_gcg !=nil {return nil ,0,_gcg ;};if len (_dacf )> 127{_dacf =_dacf [:127];};_ecd ,_dgb :=_cfa .alg12 (_bbd ,_dacf );if _dgb !=nil {return nil ,0,_dgb ;};var (_gcf []byte ;_bdb []byte ;_cabd []byte ;);var _agcb Permissions ;if len (_ecd )!=0{_agcb =PermOwner ;_aeee :=make ([]byte ,len (_dacf )+8+48);_dee :=copy (_aeee ,_dacf );_dee +=copy (_aeee [_dee :],_bbd .O [40:48]);copy (_aeee [_dee :],_bbd .U [0:48]);_gcf =_aeee ;_bdb =_bbd .OE ;_cabd =_bbd .U [0:48];}else {_ecd ,_dgb =_cfa .alg11 (_bbd ,_dacf );if _dgb ==nil &&len (_ecd )==0{_ecd ,_dgb =_cfa .alg11 (_bbd ,[]byte (""));};if _dgb !=nil {return nil ,0,_dgb ;}else if len (_ecd )==0{return nil ,0,nil ;};_agcb =_bbd .P ;_edc :=make ([]byte ,len (_dacf )+8);_dca :=copy (_edc ,_dacf );copy (_edc [_dca :],_bbd .U [40:48]);_gcf =_edc ;_bdb =_bbd .UE ;_cabd =nil ;};if _gee :=_dd ("\u0061\u006c\u00672\u0061","\u004b\u0065\u0079",32,_bdb );_gee !=nil {return nil ,0,_gee ;};_bdb =_bdb [:32];_ffb ,_dgb :=_cfa .alg2b (_bbd .R ,_gcf ,_dacf ,_cabd );if _dgb !=nil {return nil ,0,_dgb ;};_bfg ,_dgb :=_ab .NewCipher (_ffb [:32]);if _dgb !=nil {return nil ,0,_dgb ;};_gaf :=make ([]byte ,_ab .BlockSize );_bda :=_c .NewCBCDecrypter (_bfg ,_gaf );_bga :=make ([]byte ,32);_bda .CryptBlocks (_bga ,_bdb );if _bbd .R ==5{return _bga ,_agcb ,nil ;};_dgb =_cfa .alg13 (_bbd ,_bga );if _dgb !=nil {return nil ,0,_dgb ;};return _bga ,_agcb ,nil ;};func (_bc errInvalidField )Error ()string {return _ba .Sprintf ("\u0025s\u003a\u0020e\u0078\u0070\u0065\u0063t\u0065\u0064\u0020%\u0073\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0074o \u0062\u0065\u0020%\u0064\u0020b\u0079\u0074\u0065\u0073\u002c\u0020g\u006f\u0074 \u0025\u0064",_bc .Func ,_bc .Field ,_bc .Exp ,_bc .Got );};func (_cgd stdHandlerR6 )alg9 (_def *StdEncryptDict ,_aabg []byte ,_edgd []byte )error {if _ccc :=_dd ("\u0061\u006c\u0067\u0039","\u004b\u0065\u0079",32,_aabg );_ccc !=nil {return _ccc ;};if _fad :=_dd ("\u0061\u006c\u0067\u0039","\u0055",48,_def .U );_fad !=nil {return _fad ;};var _ebdd [16]byte ;if _ ,_ecf :=_a .ReadFull (_gd .Reader ,_ebdd [:]);_ecf !=nil {return _ecf ;};_efb :=_ebdd [0:8];_bbb :=_ebdd [8:16];_eab :=_def .U [:48];_eag :=make ([]byte ,len (_edgd )+len (_efb )+len (_eab ));_bef :=copy (_eag ,_edgd );_bef +=copy (_eag [_bef :],_efb );_bef +=copy (_eag [_bef :],_eab );_aec ,_dea :=_cgd .alg2b (_def .R ,_eag ,_edgd ,_eab );if _dea !=nil {return _dea ;};O :=make ([]byte ,len (_aec )+len (_efb )+len (_bbb ));_bef =copy (O ,_aec [:32]);_bef +=copy (O [_bef :],_efb );_bef +=copy (O [_bef :],_bbb );_def .O =O ;_bef =len (_edgd );_bef +=copy (_eag [_bef :],_bbb );_aec ,_dea =_cgd .alg2b (_def .R ,_eag ,_edgd ,_eab );if _dea !=nil {return _dea ;};_afbd ,_dea :=_gad (_aec [:32]);if _dea !=nil {return _dea ;};_cda :=make ([]byte ,_ab .BlockSize );_ace :=_c .NewCBCEncrypter (_afbd ,_cda );OE :=make ([]byte ,32);_ace .CryptBlocks (OE ,_aabg [:32]);_def .OE =OE ;return nil ;};func (_dba stdHandlerR6 )alg12 (_afbb *StdEncryptDict ,_gbc []byte )([]byte ,error ){if _fcba :=_dd ("\u0061\u006c\u00671\u0032","\u0055",48,_afbb .U );_fcba !=nil {return nil ,_fcba ;};if _bff :=_dd ("\u0061\u006c\u00671\u0032","\u004f",48,_afbb .O );_bff !=nil {return nil ,_bff ;};_gfa :=make ([]byte ,len (_gbc )+8+48);_dbfc :=copy (_gfa ,_gbc );_dbfc +=copy (_gfa [_dbfc :],_afbb .O [32:40]);_dbfc +=copy (_gfa [_dbfc :],_afbb .U [0:48]);_ffdb ,_gec :=_dba .alg2b (_afbb .R ,_gfa ,_gbc ,_afbb .U [0:48]);if _gec !=nil {return nil ,_gec ;};_ffdb =_ffdb [:32];if !_gcc .Equal (_ffdb ,_afbb .O [:32]){return nil ,nil ;};return _ffdb ,nil ;};func (_dbfg stdHandlerR4 )alg3 (R int ,_dfc ,_cff []byte )([]byte ,error ){var _ebg []byte ;if len (_cff )> 0{_ebg =_dbfg .alg3Key (R ,_cff );}else {_ebg =_dbfg .alg3Key (R ,_dfc );};_agd ,_bbf :=_bf .NewCipher (_ebg );if _bbf !=nil {return nil ,_gc .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_dae :=_dbfg .paddedPass (_dfc );_dfe :=make ([]byte ,len (_dae ));_agd .XORKeyStream (_dfe ,_dae );if R >=3{_ddg :=make ([]byte ,len (_ebg ));for _ebf :=0;_ebf < 19;_ebf ++{for _fbb :=0;_fbb < len (_ebg );_fbb ++{_ddg [_fbb ]=_ebg [_fbb ]^byte (_ebf +1);};_fef ,_edg :=_bf .NewCipher (_ddg );if _edg !=nil {return nil ,_gc .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_fef .XORKeyStream (_dfe ,_dfe );};};return _dfe ,nil ;};func (_ga stdHandlerR4 )alg6 (_fcb *StdEncryptDict ,_gb []byte )([]byte ,error ){var (_dfec []byte ;_dbd error ;);_cfe :=_ga .alg2 (_fcb ,_gb );if _fcb .R ==2{_dfec ,_dbd =_ga .alg4 (_cfe ,_gb );}else if _fcb .R >=3{_dfec ,_dbd =_ga .alg5 (_cfe ,_gb );}else {return nil ,_gc .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};if _dbd !=nil {return nil ,_dbd ;};_fbd .Log .Trace ("\u0063\u0068\u0065\u0063k:\u0020\u0025\u0020\u0078\u0020\u003d\u003d\u0020\u0025\u0020\u0078\u0020\u003f",string (_dfec ),string (_fcb .U ));_acd :=_dfec ;_de :=_fcb .U ;if _fcb .R >=3{if len (_acd )> 16{_acd =_acd [0:16];};if len (_de )> 16{_de =_de [0:16];};};if !_gcc .Equal (_acd ,_de ){return nil ,nil ;};return _cfe ,nil ;};func _ccd (_cgf ,_eff ,_gf []byte )([]byte ,error ){var (_ddce ,_dec ,_ead _ac .Hash ;);_ddce =_b .New ();_ggf :=make ([]byte ,64);_cbc :=_ddce ;_cbc .Write (_cgf );K :=_cbc .Sum (_ggf [:0]);_fbde :=make ([]byte ,64*(127+64+48));_ddaf :=func (_cga int )([]byte ,error ){_dffe :=len (_eff )+len (K )+len (_gf );_cgg :=_fbde [:_dffe ];_ced :=copy (_cgg ,_eff );_ced +=copy (_cgg [_ced :],K [:]);_ced +=copy (_cgg [_ced :],_gf );if _ced !=_dffe {_fbd .Log .Error ("E\u0052\u0052\u004f\u0052\u003a\u0020u\u006e\u0065\u0078\u0070\u0065\u0063t\u0065\u0064\u0020\u0072\u006f\u0075\u006ed\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0073\u0069\u007ae\u002e");return nil ,_gc .New ("\u0077\u0072\u006f\u006e\u0067\u0020\u0073\u0069\u007a\u0065");};K1 :=_fbde [:_dffe *64];_ddd (K1 ,_dffe );_bbe ,_eeb :=_gad (K [0:16]);if _eeb !=nil {return nil ,_eeb ;};_edd :=_c .NewCBCEncrypter (_bbe ,K [16:32]);_edd .CryptBlocks (K1 ,K1 );E :=K1 ;_ega :=0;for _fgg :=0;_fgg < 16;_fgg ++{_ega +=int (E [_fgg ]%3);};var _dfb _ac .Hash ;switch _ega %3{case 0:_dfb =_ddce ;case 1:if _dec ==nil {_dec =_g .New384 ();};_dfb =_dec ;case 2:if _ead ==nil {_ead =_g .New ();};_dfb =_ead ;};_dfb .Reset ();_dfb .Write (E );K =_dfb .Sum (_ggf [:0]);return E ,nil ;};for _gdg :=0;;{E ,_bbea :=_ddaf (_gdg );if _bbea !=nil {return nil ,_bbea ;};_gef :=E [len (E )-1];_gdg ++;if _gdg >=64&&_gef <=uint8 (_gdg -32){break ;};};return K [:32],nil ;};

// Authenticate implements StdHandler interface.
func (_gaa stdHandlerR4 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){_fbd .Log .Trace ("\u0044\u0065b\u0075\u0067\u0067\u0069n\u0067\u0020a\u0075\u0074\u0068\u0065\u006e\u0074\u0069\u0063a\u0074\u0069\u006f\u006e\u0020\u002d\u0020\u006f\u0077\u006e\u0065\u0072 \u0070\u0061\u0073\u0073");_bafg ,_gccd :=_gaa .alg7 (d ,pass );if _gccd !=nil {return nil ,0,_gccd ;};if _bafg !=nil {_fbd .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _bafg ,PermOwner ,nil ;};_fbd .Log .Trace ("\u0044\u0065bu\u0067\u0067\u0069n\u0067\u0020\u0061\u0075the\u006eti\u0063\u0061\u0074\u0069\u006f\u006e\u0020- \u0075\u0073\u0065\u0072\u0020\u0070\u0061s\u0073");_bafg ,_gccd =_gaa .alg6 (d ,pass );if _gccd !=nil {return nil ,0,_gccd ;};if _bafg !=nil {_fbd .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _bafg ,d .P ,nil ;};return nil ,0,nil ;};var _ StdHandler =stdHandlerR4 {};func (_dff stdHandlerR4 )alg7 (_gcb *StdEncryptDict ,_bbgg []byte )([]byte ,error ){_bbgb :=_dff .alg3Key (_gcb .R ,_bbgg );_bcg :=make ([]byte ,len (_gcb .O ));if _gcb .R ==2{_aaa ,_ec :=_bf .NewCipher (_bbgb );if _ec !=nil {return nil ,_gc .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_aaa .XORKeyStream (_bcg ,_gcb .O );}else if _gcb .R >=3{_gbg :=append ([]byte {},_gcb .O ...);for _cdb :=0;_cdb < 20;_cdb ++{_af :=append ([]byte {},_bbgb ...);for _bd :=0;_bd < len (_bbgb );_bd ++{_af [_bd ]^=byte (19-_cdb );};_fac ,_gdd :=_bf .NewCipher (_af );if _gdd !=nil {return nil ,_gc .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_fac .XORKeyStream (_bcg ,_gbg );_gbg =append ([]byte {},_bcg ...);};}else {return nil ,_gc .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};_feg ,_fbf :=_dff .alg6 (_gcb ,_bcg );if _fbf !=nil {return nil ,nil ;};return _feg ,nil ;};func (stdHandlerR4 )paddedPass (_bab []byte )[]byte {_ag :=make ([]byte ,32);_fbdd :=copy (_ag ,_bab );for ;_fbdd < 32;_fbdd ++{_ag [_fbdd ]=_fa [_fbdd -len (_bab )];};return _ag ;};func _gad (_cdg []byte )(_c .Block ,error ){_eg ,_caf :=_ab .NewCipher (_cdg );if _caf !=nil {_fbd .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0063\u0072\u0065\u0061\u0074\u0065\u0020A\u0045\u0053\u0020\u0063\u0069p\u0068\u0065r\u003a\u0020\u0025\u0076",_caf );return nil ,_caf ;};return _eg ,nil ;};

// Allowed checks if a set of permissions can be granted.
func (_edb Permissions )Allowed (p2 Permissions )bool {return _edb &p2 ==p2 };type ecbEncrypter ecb ;type ecbDecrypter ecb ;func (_gccb *ecbEncrypter )BlockSize ()int {return _gccb ._acg };const (PermOwner =Permissions (_fb .MaxUint32 );PermPrinting =Permissions (1<<2);PermModify =Permissions (1<<3);PermExtractGraphics =Permissions (1<<4);PermAnnotate =Permissions (1<<5);PermFillForms =Permissions (1<<8);PermDisabilityExtract =Permissions (1<<9);PermRotateInsert =Permissions (1<<10);PermFullPrintQuality =Permissions (1<<11););

// GenerateParams generates and sets O and U parameters for the encryption dictionary.
// It expects R, P and EncryptMetadata fields to be set.
func (_bbga stdHandlerR4 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){O ,_eca :=_bbga .alg3 (d .R ,upass ,opass );if _eca !=nil {_fbd .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_eca );return nil ,_eca ;};d .O =O ;_fbd .Log .Trace ("\u0067\u0065\u006e\u0020\u004f\u003a\u0020\u0025\u0020\u0078",O );_cae :=_bbga .alg2 (d ,upass );U ,_eca :=_bbga .alg5 (_cae ,upass );if _eca !=nil {_fbd .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_eca );return nil ,_eca ;};d .U =U ;_fbd .Log .Trace ("\u0067\u0065\u006e\u0020\u0055\u003a\u0020\u0025\u0020\u0078",U );return _cae ,nil ;};func (_bgg stdHandlerR4 )alg4 (_aedc []byte ,_ce []byte )([]byte ,error ){_dde ,_ffc :=_bf .NewCipher (_aedc );if _ffc !=nil {return nil ,_gc .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_cg :=[]byte (_fa );_ebga :=make ([]byte ,len (_cg ));_dde .XORKeyStream (_ebga ,_cg );return _ebga ,nil ;};func (_bb *ecbEncrypter )CryptBlocks (dst ,src []byte ){if len (src )%_bb ._acg !=0{_fbd .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");return ;};if len (dst )< len (src ){_fbd .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");return ;};for len (src )> 0{_bb ._baa .Encrypt (dst ,src [:_bb ._acg ]);src =src [_bb ._acg :];dst =dst [_bb ._acg :];};};type errInvalidField struct{Func string ;Field string ;Exp int ;Got int ;};func _ddd (_dda []byte ,_ffd int ){_bdd :=_ffd ;for _bdd < len (_dda ){copy (_dda [_bdd :],_dda [:_bdd ]);_bdd *=2;};};func (_adf *ecbDecrypter )CryptBlocks (dst ,src []byte ){if len (src )%_adf ._acg !=0{_fbd .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");return ;};if len (dst )< len (src ){_fbd .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0064\u0065\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");return ;};for len (src )> 0{_adf ._baa .Decrypt (dst ,src [:_adf ._acg ]);src =src [_adf ._acg :];dst =dst [_adf ._acg :];};};func (_beb stdHandlerR6 )alg11 (_gdb *StdEncryptDict ,_febb []byte )([]byte ,error ){if _fccf :=_dd ("\u0061\u006c\u00671\u0031","\u0055",48,_gdb .U );_fccf !=nil {return nil ,_fccf ;};_bgc :=make ([]byte ,len (_febb )+8);_fbaf :=copy (_bgc ,_febb );_fbaf +=copy (_bgc [_fbaf :],_gdb .U [32:40]);_ecb ,_cdc :=_beb .alg2b (_gdb .R ,_bgc ,_febb ,nil );if _cdc !=nil {return nil ,_cdc ;};_ecb =_ecb [:32];if !_gcc .Equal (_ecb ,_gdb .U [:32]){return nil ,nil ;};return _ecb ,nil ;};const (EventDocOpen =AuthEvent ("\u0044o\u0063\u004f\u0070\u0065\u006e");EventEFOpen =AuthEvent ("\u0045\u0046\u004f\u0070\u0065\u006e"););func _be (_ebd []byte )([]byte ,error ){_ef :=_b .New ();_ef .Write (_ebd );return _ef .Sum (nil ),nil };

// AuthEvent is an event type that triggers authentication.
type AuthEvent string ;var _ StdHandler =stdHandlerR6 {};func _e (_adb _c .Block )_c .BlockMode {return (*ecbDecrypter )(_aa (_adb ))};

// Authenticate implements StdHandler interface.
func (_gdc stdHandlerR6 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){return _gdc .alg2a (d ,pass );};