//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package security ;import (_ec "bytes";_bc "crypto/aes";_f "crypto/cipher";_fde "crypto/md5";_ffc "crypto/rand";_ff "crypto/rc4";_fd "crypto/sha256";_e "crypto/sha512";_d "encoding/binary";_be "errors";_fbd "fmt";_fa "github.com/unidoc/unipdf/v3/common";
_bf "hash";_g "io";_fb "math";);func (_fg stdHandlerR4 )alg2 (_eg *StdEncryptDict ,_ea []byte )[]byte {_fa .Log .Trace ("\u0061\u006c\u0067\u0032");_gd :=_fg .paddedPass (_ea );_fac :=_fde .New ();_fac .Write (_gd );_fac .Write (_eg .O );var _gf [4]byte ;
_d .LittleEndian .PutUint32 (_gf [:],uint32 (_eg .P ));_fac .Write (_gf [:]);_fa .Log .Trace ("\u0067o\u0020\u0050\u003a\u0020\u0025\u0020x",_gf );_fac .Write ([]byte (_fg .ID0 ));_fa .Log .Trace ("\u0074\u0068\u0069\u0073\u002e\u0052\u0020\u003d\u0020\u0025d\u0020\u0065\u006e\u0063\u0072\u0079\u0070t\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061\u0020\u0025\u0076",_eg .R ,_eg .EncryptMetadata );
if (_eg .R >=4)&&!_eg .EncryptMetadata {_fac .Write ([]byte {0xff,0xff,0xff,0xff});};_df :=_fac .Sum (nil );if _eg .R >=3{_fac =_fde .New ();for _ac :=0;_ac < 50;_ac ++{_fac .Reset ();_fac .Write (_df [0:_fg .Length /8]);_df =_fac .Sum (nil );};};if _eg .R >=3{return _df [0:_fg .Length /8];
};return _df [0:5];};func (_eea stdHandlerR4 )alg6 (_bfa *StdEncryptDict ,_fgd []byte )([]byte ,error ){var (_ddf []byte ;_beab error ;);_ggf :=_eea .alg2 (_bfa ,_fgd );if _bfa .R ==2{_ddf ,_beab =_eea .alg4 (_ggf ,_fgd );}else if _bfa .R >=3{_ddf ,_beab =_eea .alg5 (_ggf ,_fgd );
}else {return nil ,_be .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};if _beab !=nil {return nil ,_beab ;};_fa .Log .Trace ("\u0063\u0068\u0065\u0063k:\u0020\u0025\u0020\u0078\u0020\u003d\u003d\u0020\u0025\u0020\u0078\u0020\u003f",string (_ddf ),string (_bfa .U ));
_fdf :=_ddf ;_cb :=_bfa .U ;if _bfa .R >=3{if len (_fdf )> 16{_fdf =_fdf [0:16];};if len (_cb )> 16{_cb =_cb [0:16];};};if !_ec .Equal (_fdf ,_cb ){return nil ,nil ;};return _ggf ,nil ;};

// NewHandlerR6 creates a new standard security handler for R=5 and R=6.
func NewHandlerR6 ()StdHandler {return stdHandlerR6 {}};const (PermOwner =Permissions (_fb .MaxUint32 );PermPrinting =Permissions (1<<2);PermModify =Permissions (1<<3);PermExtractGraphics =Permissions (1<<4);PermAnnotate =Permissions (1<<5);PermFillForms =Permissions (1<<8);
PermDisabilityExtract =Permissions (1<<9);PermRotateInsert =Permissions (1<<10);PermFullPrintQuality =Permissions (1<<11););

// GenerateParams generates and sets O and U parameters for the encryption dictionary.
// It expects R, P and EncryptMetadata fields to be set.
func (_eae stdHandlerR4 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){O ,_eag :=_eae .alg3 (d .R ,upass ,opass );if _eag !=nil {_fa .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_eag );
return nil ,_eag ;};d .O =O ;_fa .Log .Trace ("\u0067\u0065\u006e\u0020\u004f\u003a\u0020\u0025\u0020\u0078",O );_cf :=_eae .alg2 (d ,upass );U ,_eag :=_eae .alg5 (_cf ,upass );if _eag !=nil {_fa .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_eag );
return nil ,_eag ;};d .U =U ;_fa .Log .Trace ("\u0067\u0065\u006e\u0020\u0055\u003a\u0020\u0025\u0020\u0078",U );return _cf ,nil ;};func _ce (_begg []byte )(_f .Block ,error ){_abef ,_bb :=_bc .NewCipher (_begg );if _bb !=nil {_fa .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0063\u0072\u0065\u0061\u0074\u0065\u0020A\u0045\u0053\u0020\u0063\u0069p\u0068\u0065r\u003a\u0020\u0025\u0076",_bb );
return nil ,_bb ;};return _abef ,nil ;};type ecbDecrypter ecb ;func (_cba stdHandlerR6 )alg2a (_aca *StdEncryptDict ,_bdf []byte )([]byte ,Permissions ,error ){if _bee :=_ef ("\u0061\u006c\u00672\u0061","\u004f",48,_aca .O );_bee !=nil {return nil ,0,_bee ;
};if _cge :=_ef ("\u0061\u006c\u00672\u0061","\u0055",48,_aca .U );_cge !=nil {return nil ,0,_cge ;};if len (_bdf )> 127{_bdf =_bdf [:127];};_bcb ,_cea :=_cba .alg12 (_aca ,_bdf );if _cea !=nil {return nil ,0,_cea ;};var (_gfab []byte ;_ged []byte ;_ebac []byte ;
);var _eeg Permissions ;if len (_bcb )!=0{_eeg =PermOwner ;_dfd :=make ([]byte ,len (_bdf )+8+48);_ffce :=copy (_dfd ,_bdf );_ffce +=copy (_dfd [_ffce :],_aca .O [40:48]);copy (_dfd [_ffce :],_aca .U [0:48]);_gfab =_dfd ;_ged =_aca .OE ;_ebac =_aca .U [0:48];
}else {_bcb ,_cea =_cba .alg11 (_aca ,_bdf );if _cea ==nil &&len (_bcb )==0{_bcb ,_cea =_cba .alg11 (_aca ,[]byte (""));};if _cea !=nil {return nil ,0,_cea ;}else if len (_bcb )==0{return nil ,0,nil ;};_eeg =_aca .P ;_gdg :=make ([]byte ,len (_bdf )+8);
_bde :=copy (_gdg ,_bdf );copy (_gdg [_bde :],_aca .U [40:48]);_gfab =_gdg ;_ged =_aca .UE ;_ebac =nil ;};if _gaef :=_ef ("\u0061\u006c\u00672\u0061","\u004b\u0065\u0079",32,_ged );_gaef !=nil {return nil ,0,_gaef ;};_ged =_ged [:32];_gcc ,_cea :=_cba .alg2b (_aca .R ,_gfab ,_bdf ,_ebac );
if _cea !=nil {return nil ,0,_cea ;};_cag ,_cea :=_bc .NewCipher (_gcc [:32]);if _cea !=nil {return nil ,0,_cea ;};_fbdbc :=make ([]byte ,_bc .BlockSize );_bcc :=_f .NewCBCDecrypter (_cag ,_fbdbc );_fdfd :=make ([]byte ,32);_bcc .CryptBlocks (_fdfd ,_ged );
if _aca .R ==5{return _fdfd ,_eeg ,nil ;};_cea =_cba .alg13 (_aca ,_fdfd );if _cea !=nil {return nil ,0,_cea ;};return _fdfd ,_eeg ,nil ;};func (_fdff stdHandlerR6 )alg8 (_ead *StdEncryptDict ,_dbda []byte ,_ad []byte )error {if _fdee :=_ef ("\u0061\u006c\u0067\u0038","\u004b\u0065\u0079",32,_dbda );
_fdee !=nil {return _fdee ;};var _egd [16]byte ;if _ ,_acb :=_g .ReadFull (_ffc .Reader ,_egd [:]);_acb !=nil {return _acb ;};_ade :=_egd [0:8];_aad :=_egd [8:16];_eca :=make ([]byte ,len (_ad )+len (_ade ));_eda :=copy (_eca ,_ad );copy (_eca [_eda :],_ade );
_gga ,_bce :=_fdff .alg2b (_ead .R ,_eca ,_ad ,nil );if _bce !=nil {return _bce ;};U :=make ([]byte ,len (_gga )+len (_ade )+len (_aad ));_eda =copy (U ,_gga [:32]);_eda +=copy (U [_eda :],_ade );copy (U [_eda :],_aad );_ead .U =U ;_eda =len (_ad );copy (_eca [_eda :],_aad );
_gga ,_bce =_fdff .alg2b (_ead .R ,_eca ,_ad ,nil );if _bce !=nil {return _bce ;};_bfdf ,_bce :=_ce (_gga [:32]);if _bce !=nil {return _bce ;};_daa :=make ([]byte ,_bc .BlockSize );_gbfe :=_f .NewCBCEncrypter (_bfdf ,_daa );UE :=make ([]byte ,32);_gbfe .CryptBlocks (UE ,_dbda [:32]);
_ead .UE =UE ;return nil ;};func _gbb (_dg _f .Block )_f .BlockMode {return (*ecbEncrypter )(_a (_dg ))};type stdHandlerR6 struct{};func (_ga stdHandlerR4 )alg4 (_gbd []byte ,_egb []byte )([]byte ,error ){_abe ,_dgg :=_ff .NewCipher (_gbd );if _dgg !=nil {return nil ,_be .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_aag :=[]byte (_aed );_bae :=make ([]byte ,len (_aag ));_abe .XORKeyStream (_bae ,_aag );return _bae ,nil ;};type stdHandlerR4 struct{Length int ;ID0 string ;};func _ebe (_baed []byte )([]byte ,error ){_bcf :=_fd .New ();_bcf .Write (_baed );return _bcf .Sum (nil ),nil ;
};func (_cd *ecbDecrypter )CryptBlocks (dst ,src []byte ){if len (src )%_cd ._gg !=0{_fa .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_fa .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0064\u0065\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_cd ._gb .Decrypt (dst ,src [:_cd ._gg ]);src =src [_cd ._gg :];dst =dst [_cd ._gg :];};};

// Authenticate implements StdHandler interface.
func (_bfaf stdHandlerR6 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){return _bfaf .alg2a (d ,pass );};func (_bgc stdHandlerR4 )alg3 (R int ,_aaf ,_bfc []byte )([]byte ,error ){var _bd []byte ;if len (_bfc )> 0{_bd =_bgc .alg3Key (R ,_bfc );
}else {_bd =_bgc .alg3Key (R ,_aaf );};_bec ,_dbb :=_ff .NewCipher (_bd );if _dbb !=nil {return nil ,_be .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_cdf :=_bgc .paddedPass (_aaf );_dgf :=make ([]byte ,len (_cdf ));
_bec .XORKeyStream (_dgf ,_cdf );if R >=3{_dea :=make ([]byte ,len (_bd ));for _cda :=0;_cda < 19;_cda ++{for _efd :=0;_efd < len (_bd );_efd ++{_dea [_efd ]=_bd [_efd ]^byte (_cda +1);};_eac ,_fab :=_ff .NewCipher (_dea );if _fab !=nil {return nil ,_be .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_eac .XORKeyStream (_dgf ,_dgf );};};return _dgf ,nil ;};var _ StdHandler =stdHandlerR4 {};func (_dbd stdHandlerR6 )alg2b (R int ,_gbcf ,_bff ,_bca []byte )([]byte ,error ){if R ==5{return _ebe (_gbcf );};return _eff (_gbcf ,_bff ,_bca );};type ecb struct{_gb _f .Block ;
_gg int ;};func (_ege stdHandlerR4 )alg3Key (R int ,_abg []byte )[]byte {_ba :=_fde .New ();_gfa :=_ege .paddedPass (_abg );_ba .Write (_gfa );if R >=3{for _def :=0;_def < 50;_def ++{_ecc :=_ba .Sum (nil );_ba =_fde .New ();_ba .Write (_ecc );};};_gbc :=_ba .Sum (nil );
if R ==2{_gbc =_gbc [0:5];}else {_gbc =_gbc [0:_ege .Length /8];};return _gbc ;};func (_ecag stdHandlerR6 )alg11 (_dff *StdEncryptDict ,_cbc []byte )([]byte ,error ){if _eccd :=_ef ("\u0061\u006c\u00671\u0031","\u0055",48,_dff .U );_eccd !=nil {return nil ,_eccd ;
};_bfb :=make ([]byte ,len (_cbc )+8);_baa :=copy (_bfb ,_cbc );_baa +=copy (_bfb [_baa :],_dff .U [32:40]);_dcf ,_eeab :=_ecag .alg2b (_dff .R ,_bfb ,_cbc ,nil );if _eeab !=nil {return nil ,_eeab ;};_dcf =_dcf [:32];if !_ec .Equal (_dcf ,_dff .U [:32]){return nil ,nil ;
};return _dcf ,nil ;};func _a (_c _f .Block )*ecb {return &ecb {_gb :_c ,_gg :_c .BlockSize ()}};func _fcc (_eagd []byte ,_bfd int ){_aeb :=_bfd ;for _aeb < len (_eagd ){copy (_eagd [_aeb :],_eagd [:_aeb ]);_aeb *=2;};};const (EventDocOpen =AuthEvent ("\u0044o\u0063\u004f\u0070\u0065\u006e");
EventEFOpen =AuthEvent ("\u0045\u0046\u004f\u0070\u0065\u006e"););func (_fbf stdHandlerR6 )alg13 (_bfag *StdEncryptDict ,_caad []byte )error {if _bad :=_ef ("\u0061\u006c\u00671\u0033","\u004b\u0065\u0079",32,_caad );_bad !=nil {return _bad ;};if _acd :=_ef ("\u0061\u006c\u00671\u0033","\u0050\u0065\u0072m\u0073",16,_bfag .Perms );
_acd !=nil {return _acd ;};_aeg :=make ([]byte ,16);copy (_aeg ,_bfag .Perms [:16]);_ebg ,_afd :=_bc .NewCipher (_caad [:32]);if _afd !=nil {return _afd ;};_gde :=_eb (_ebg );_gde .CryptBlocks (_aeg ,_aeg );if !_ec .Equal (_aeg [9:12],[]byte ("\u0061\u0064\u0062")){return _be .New ("\u0064\u0065\u0063o\u0064\u0065\u0064\u0020p\u0065\u0072\u006d\u0069\u0073\u0073\u0069o\u006e\u0073\u0020\u0061\u0072\u0065\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};_beed :=Permissions (_d .LittleEndian .Uint32 (_aeg [0:4]));if _beed !=_bfag .P {return _be .New ("\u0070\u0065r\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066\u0061il\u0065\u0064");
};var _aff bool ;if _aeg [8]=='T'{_aff =true ;}else if _aeg [8]=='F'{_aff =false ;}else {return _be .New ("\u0064\u0065\u0063\u006f\u0064\u0065\u0064 \u006d\u0065\u0074a\u0064\u0061\u0074\u0061 \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u006c\u0061\u0067\u0020\u0069\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};if _aff !=_bfag .EncryptMetadata {return _be .New ("\u006d\u0065t\u0061\u0064\u0061\u0074a\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e \u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066a\u0069\u006c\u0065\u0064");
};return nil ;};type ecbEncrypter ecb ;func (_cg *ecbEncrypter )BlockSize ()int {return _cg ._gg };func (stdHandlerR4 )paddedPass (_bg []byte )[]byte {_cgb :=make ([]byte ,32);_da :=copy (_cgb ,_bg );for ;_da < 32;_da ++{_cgb [_da ]=_aed [_da -len (_bg )];
};return _cgb ;};const _aed ="\x28\277\116\136\x4e\x75\x8a\x41\x64\000\x4e\x56\377"+"\xfa\001\010\056\x2e\x00\xb6\xd0\x68\076\x80\x2f\014"+"\251\xfe\x64\x53\x69\172";

// StdEncryptDict is a set of additional fields used in standard encryption dictionary.
type StdEncryptDict struct{R int ;P Permissions ;EncryptMetadata bool ;O ,U []byte ;OE ,UE []byte ;Perms []byte ;};

// Authenticate implements StdHandler interface.
func (_abeb stdHandlerR4 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){_fa .Log .Trace ("\u0044\u0065b\u0075\u0067\u0067\u0069n\u0067\u0020a\u0075\u0074\u0068\u0065\u006e\u0074\u0069\u0063a\u0074\u0069\u006f\u006e\u0020\u002d\u0020\u006f\u0077\u006e\u0065\u0072 \u0070\u0061\u0073\u0073");
_fgb ,_egc :=_abeb .alg7 (d ,pass );if _egc !=nil {return nil ,0,_egc ;};if _fgb !=nil {_fa .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _fgb ,PermOwner ,nil ;
};_fa .Log .Trace ("\u0044\u0065bu\u0067\u0067\u0069n\u0067\u0020\u0061\u0075the\u006eti\u0063\u0061\u0074\u0069\u006f\u006e\u0020- \u0075\u0073\u0065\u0072\u0020\u0070\u0061s\u0073");_fgb ,_egc =_abeb .alg6 (d ,pass );if _egc !=nil {return nil ,0,_egc ;
};if _fgb !=nil {_fa .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _fgb ,d .P ,nil ;};return nil ,0,nil ;};

// StdHandler is an interface for standard security handlers.
type StdHandler interface{

// GenerateParams uses owner and user passwords to set encryption parameters and generate an encryption key.
// It assumes that R, P and EncryptMetadata are already set.
GenerateParams (_de *StdEncryptDict ,_ae ,_bea []byte )([]byte ,error );

// Authenticate uses encryption dictionary parameters and the password to calculate
// the document encryption key. It also returns permissions that should be granted to a user.
// In case of failed authentication, it returns empty key and zero permissions with no error.
Authenticate (_fe *StdEncryptDict ,_eba []byte )([]byte ,Permissions ,error );};

// NewHandlerR4 creates a new standard security handler for R<=4.
func NewHandlerR4 (id0 string ,length int )StdHandler {return stdHandlerR4 {ID0 :id0 ,Length :length }};var _ StdHandler =stdHandlerR6 {};func (_fdd stdHandlerR4 )alg5 (_ecg []byte ,_dd []byte )([]byte ,error ){_ge :=_fde .New ();_ge .Write ([]byte (_aed ));
_ge .Write ([]byte (_fdd .ID0 ));_dgd :=_ge .Sum (nil );_fa .Log .Trace ("\u0061\u006c\u0067\u0035");_fa .Log .Trace ("\u0065k\u0065\u0079\u003a\u0020\u0025\u0020x",_ecg );_fa .Log .Trace ("\u0049D\u003a\u0020\u0025\u0020\u0078",_fdd .ID0 );if len (_dgd )!=16{return nil ,_be .New ("\u0068a\u0073\u0068\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074\u0020\u0031\u0036\u0020\u0062\u0079\u0074\u0065\u0073");
};_ega ,_beg :=_ff .NewCipher (_ecg );if _beg !=nil {return nil ,_be .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_gbf :=make ([]byte ,16);_ega .XORKeyStream (_gbf ,_dgd );_fca :=make ([]byte ,len (_ecg ));
for _ee :=0;_ee < 19;_ee ++{for _ebd :=0;_ebd < len (_ecg );_ebd ++{_fca [_ebd ]=_ecg [_ebd ]^byte (_ee +1);};_ega ,_beg =_ff .NewCipher (_fca );if _beg !=nil {return nil ,_be .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_ega .XORKeyStream (_gbf ,_gbf );_fa .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u002c\u0020\u0065\u006b\u0065\u0079:\u0020\u0025\u0020\u0078",_ee ,_fca );_fa .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0020\u0078",_ee ,_gbf );
};_ebag :=make ([]byte ,32);for _gae :=0;_gae < 16;_gae ++{_ebag [_gae ]=_gbf [_gae ];};_ ,_beg =_ffc .Read (_ebag [16:32]);if _beg !=nil {return nil ,_be .New ("\u0066a\u0069\u006c\u0065\u0064 \u0074\u006f\u0020\u0067\u0065n\u0020r\u0061n\u0064\u0020\u006e\u0075\u006d\u0062\u0065r");
};return _ebag ,nil ;};

// AuthEvent is an event type that triggers authentication.
type AuthEvent string ;func (_aa *ecbEncrypter )CryptBlocks (dst ,src []byte ){if len (src )%_aa ._gg !=0{_fa .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_fa .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_aa ._gb .Encrypt (dst ,src [:_aa ._gg ]);src =src [_aa ._gg :];dst =dst [_aa ._gg :];};};func (_gc *ecbDecrypter )BlockSize ()int {return _gc ._gg };func (_daf stdHandlerR6 )alg12 (_ece *StdEncryptDict ,_aacd []byte )([]byte ,error ){if _gcf :=_ef ("\u0061\u006c\u00671\u0032","\u0055",48,_ece .U );
_gcf !=nil {return nil ,_gcf ;};if _adc :=_ef ("\u0061\u006c\u00671\u0032","\u004f",48,_ece .O );_adc !=nil {return nil ,_adc ;};_egf :=make ([]byte ,len (_aacd )+8+48);_gca :=copy (_egf ,_aacd );_gca +=copy (_egf [_gca :],_ece .O [32:40]);_gca +=copy (_egf [_gca :],_ece .U [0:48]);
_fge ,_ggad :=_daf .alg2b (_ece .R ,_egf ,_aacd ,_ece .U [0:48]);if _ggad !=nil {return nil ,_ggad ;};_fge =_fge [:32];if !_ec .Equal (_fge ,_ece .O [:32]){return nil ,nil ;};return _fge ,nil ;};func (_ddae stdHandlerR6 )alg9 (_bda *StdEncryptDict ,_eee []byte ,_aac []byte )error {if _ecb :=_ef ("\u0061\u006c\u0067\u0039","\u004b\u0065\u0079",32,_eee );
_ecb !=nil {return _ecb ;};if _cae :=_ef ("\u0061\u006c\u0067\u0039","\u0055",48,_bda .U );_cae !=nil {return _cae ;};var _cfc [16]byte ;if _ ,_beef :=_g .ReadFull (_ffc .Reader ,_cfc [:]);_beef !=nil {return _beef ;};_gea :=_cfc [0:8];_ceb :=_cfc [8:16];
_bebd :=_bda .U [:48];_dee :=make ([]byte ,len (_aac )+len (_gea )+len (_bebd ));_ddg :=copy (_dee ,_aac );_ddg +=copy (_dee [_ddg :],_gea );_ddg +=copy (_dee [_ddg :],_bebd );_egaf ,_geb :=_ddae .alg2b (_bda .R ,_dee ,_aac ,_bebd );if _geb !=nil {return _geb ;
};O :=make ([]byte ,len (_egaf )+len (_gea )+len (_ceb ));_ddg =copy (O ,_egaf [:32]);_ddg +=copy (O [_ddg :],_gea );_ddg +=copy (O [_ddg :],_ceb );_bda .O =O ;_ddg =len (_aac );_ddg +=copy (_dee [_ddg :],_ceb );_egaf ,_geb =_ddae .alg2b (_bda .R ,_dee ,_aac ,_bebd );
if _geb !=nil {return _geb ;};_becf ,_geb :=_ce (_egaf [:32]);if _geb !=nil {return _geb ;};_gbg :=make ([]byte ,_bc .BlockSize );_dec :=_f .NewCBCEncrypter (_becf ,_gbg );OE :=make ([]byte ,32);_dec .CryptBlocks (OE ,_eee [:32]);_bda .OE =OE ;return nil ;
};

// GenerateParams is the algorithm opposite to alg2a (R>=5).
// It generates U,O,UE,OE,Perms fields using AESv3 encryption.
// There is no algorithm number assigned to this function in the spec.
// It expects R, P and EncryptMetadata fields to be set.
func (_fea stdHandlerR6 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){_dcg :=make ([]byte ,32);if _ ,_ada :=_g .ReadFull (_ffc .Reader ,_dcg );_ada !=nil {return nil ,_ada ;};d .U =nil ;d .O =nil ;d .UE =nil ;d .OE =nil ;d .Perms =nil ;
if len (upass )> 127{upass =upass [:127];};if len (opass )> 127{opass =opass [:127];};if _dga :=_fea .alg8 (d ,_dcg ,upass );_dga !=nil {return nil ,_dga ;};if _gfe :=_fea .alg9 (d ,_dcg ,opass );_gfe !=nil {return nil ,_gfe ;};if d .R ==5{return _dcg ,nil ;
};if _gebd :=_fea .alg10 (d ,_dcg );_gebd !=nil {return nil ,_gebd ;};return _dcg ,nil ;};func _eb (_faf _f .Block )_f .BlockMode {return (*ecbDecrypter )(_a (_faf ))};func (_cgf stdHandlerR6 )alg10 (_cgfc *StdEncryptDict ,_gbfd []byte )error {if _egae :=_ef ("\u0061\u006c\u00671\u0030","\u004b\u0065\u0079",32,_gbfd );
_egae !=nil {return _egae ;};_gbe :=uint64 (uint32 (_cgfc .P ))|(_fb .MaxUint32 <<32);Perms :=make ([]byte ,16);_d .LittleEndian .PutUint64 (Perms [:8],_gbe );if _cgfc .EncryptMetadata {Perms [8]='T';}else {Perms [8]='F';};copy (Perms [9:12],"\u0061\u0064\u0062");
if _ ,_dc :=_g .ReadFull (_ffc .Reader ,Perms [12:16]);_dc !=nil {return _dc ;};_eeb ,_dfddb :=_ce (_gbfd [:32]);if _dfddb !=nil {return _dfddb ;};_fef :=_gbb (_eeb );_fef .CryptBlocks (Perms ,Perms );_cgfc .Perms =Perms [:16];return nil ;};type errInvalidField struct{Func string ;
Field string ;Exp int ;Got int ;};func (_fbdb errInvalidField )Error ()string {return _fbd .Sprintf ("\u0025s\u003a\u0020e\u0078\u0070\u0065\u0063t\u0065\u0064\u0020%\u0073\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0074o \u0062\u0065\u0020%\u0064\u0020b\u0079\u0074\u0065\u0073\u002c\u0020g\u006f\u0074 \u0025\u0064",_fbdb .Func ,_fbdb .Field ,_fbdb .Exp ,_fbdb .Got );
};func _ef (_beb ,_cdg string ,_aab int ,_fc []byte )error {if len (_fc )< _aab {return errInvalidField {Func :_beb ,Field :_cdg ,Exp :_aab ,Got :len (_fc )};};return nil ;};

// Allowed checks if a set of permissions can be granted.
func (_ab Permissions )Allowed (p2 Permissions )bool {return _ab &p2 ==p2 };func (_ded stdHandlerR4 )alg7 (_cbg *StdEncryptDict ,_gdd []byte )([]byte ,error ){_fbb :=_ded .alg3Key (_cbg .R ,_gdd );_cc :=make ([]byte ,len (_cbg .O ));if _cbg .R ==2{_fbbe ,_af :=_ff .NewCipher (_fbb );
if _af !=nil {return nil ,_be .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_fbbe .XORKeyStream (_cc ,_cbg .O );}else if _cbg .R >=3{_cdd :=append ([]byte {},_cbg .O ...);for _geg :=0;_geg < 20;_geg ++{_aage :=append ([]byte {},_fbb ...);
for _gad :=0;_gad < len (_fbb );_gad ++{_aage [_gad ]^=byte (19-_geg );};_ca ,_fcd :=_ff .NewCipher (_aage );if _fcd !=nil {return nil ,_be .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_ca .XORKeyStream (_cc ,_cdd );
_cdd =append ([]byte {},_cc ...);};}else {return nil ,_be .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};_fdb ,_eaa :=_ded .alg6 (_cbg ,_cc );if _eaa !=nil {return nil ,nil ;};return _fdb ,nil ;};func _eff (_ffe ,_caf ,_fdea []byte )([]byte ,error ){var (_dfdd ,_baeda ,_dda _bf .Hash ;
);_dfdd =_fd .New ();_cfa :=make ([]byte ,64);_fgbb :=_dfdd ;_fgbb .Write (_ffe );K :=_fgbb .Sum (_cfa [:0]);_eef :=make ([]byte ,64*(127+64+48));_ed :=func (_dgb int )([]byte ,error ){_cfag :=len (_caf )+len (K )+len (_fdea );_eage :=_eef [:_cfag ];_ccf :=copy (_eage ,_caf );
_ccf +=copy (_eage [_ccf :],K [:]);_ccf +=copy (_eage [_ccf :],_fdea );if _ccf !=_cfag {_fa .Log .Error ("E\u0052\u0052\u004f\u0052\u003a\u0020u\u006e\u0065\u0078\u0070\u0065\u0063t\u0065\u0064\u0020\u0072\u006f\u0075\u006ed\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0073\u0069\u007ae\u002e");
return nil ,_be .New ("\u0077\u0072\u006f\u006e\u0067\u0020\u0073\u0069\u007a\u0065");};K1 :=_eef [:_cfag *64];_fcc (K1 ,_cfag );_ggd ,_ecd :=_ce (K [0:16]);if _ecd !=nil {return nil ,_ecd ;};_baf :=_f .NewCBCEncrypter (_ggd ,K [16:32]);_baf .CryptBlocks (K1 ,K1 );
E :=K1 ;_dbbc :=0;for _fbdd :=0;_fbdd < 16;_fbdd ++{_dbbc +=int (E [_fbdd ]%3);};var _fgdc _bf .Hash ;switch _dbbc %3{case 0:_fgdc =_dfdd ;case 1:if _baeda ==nil {_baeda =_e .New384 ();};_fgdc =_baeda ;case 2:if _dda ==nil {_dda =_e .New ();};_fgdc =_dda ;
};_fgdc .Reset ();_fgdc .Write (E );K =_fgdc .Sum (_cfa [:0]);return E ,nil ;};for _dgfb :=0;;{E ,_gcd :=_ed (_dgfb );if _gcd !=nil {return nil ,_gcd ;};_afa :=E [len (E )-1];_dgfb ++;if _dgfb >=64&&_afa <=uint8 (_dgfb -32){break ;};};return K [:32],nil ;
};

// Permissions is a bitmask of access permissions for a PDF file.
type Permissions uint32 ;