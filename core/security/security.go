//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package security ;import (_bf "bytes";_f "crypto/aes";_b "crypto/cipher";_a "crypto/md5";_gg "crypto/rand";_fb "crypto/rc4";_be "crypto/sha256";_e "crypto/sha512";_cg "encoding/binary";_c "errors";_fc "fmt";_ea "github.com/unidoc/unipdf/v3/common";_bd "hash";
_g "io";_ef "math";);func (_geeb stdHandlerR6 )alg12 (_daf *StdEncryptDict ,_geea []byte )([]byte ,error ){if _eda :=_dg ("\u0061\u006c\u00671\u0032","\u0055",48,_daf .U );_eda !=nil {return nil ,_eda ;};if _egb :=_dg ("\u0061\u006c\u00671\u0032","\u004f",48,_daf .O );
_egb !=nil {return nil ,_egb ;};_deb :=make ([]byte ,len (_geea )+8+48);_eca :=copy (_deb ,_geea );_eca +=copy (_deb [_eca :],_daf .O [32:40]);_eca +=copy (_deb [_eca :],_daf .U [0:48]);_agfb ,_ecd :=_geeb .alg2b (_daf .R ,_deb ,_geea ,_daf .U [0:48]);
if _ecd !=nil {return nil ,_ecd ;};_agfb =_agfb [:32];if !_bf .Equal (_agfb ,_daf .O [:32]){return nil ,nil ;};return _agfb ,nil ;};func _dg (_fa ,_db string ,_gbc int ,_fba []byte )error {if len (_fba )< _gbc {return errInvalidField {Func :_fa ,Field :_db ,Exp :_gbc ,Got :len (_fba )};
};return nil ;};func (_ca stdHandlerR4 )alg3Key (R int ,_cd []byte )[]byte {_abd :=_a .New ();_bfb :=_ca .paddedPass (_cd );_abd .Write (_bfb );if R >=3{for _gea :=0;_gea < 50;_gea ++{_bc :=_abd .Sum (nil );_abd =_a .New ();_abd .Write (_bc );};};_fd :=_abd .Sum (nil );
if R ==2{_fd =_fd [0:5];}else {_fd =_fd [0:_ca .Length /8];};return _fd ;};const (PermOwner =Permissions (_ef .MaxUint32 );PermPrinting =Permissions (1<<2);PermModify =Permissions (1<<3);PermExtractGraphics =Permissions (1<<4);PermAnnotate =Permissions (1<<5);
PermFillForms =Permissions (1<<8);PermDisabilityExtract =Permissions (1<<9);PermRotateInsert =Permissions (1<<10);PermFullPrintQuality =Permissions (1<<11););func (_aaa stdHandlerR4 )alg2 (_dfb *StdEncryptDict ,_ba []byte )[]byte {_ea .Log .Trace ("\u0061\u006c\u0067\u0032");
_faf :=_aaa .paddedPass (_ba );_dee :=_a .New ();_dee .Write (_faf );_dee .Write (_dfb .O );var _bfe [4]byte ;_cg .LittleEndian .PutUint32 (_bfe [:],uint32 (_dfb .P ));_dee .Write (_bfe [:]);_ea .Log .Trace ("\u0067o\u0020\u0050\u003a\u0020\u0025\u0020x",_bfe );
_dee .Write ([]byte (_aaa .ID0 ));_ea .Log .Trace ("\u0074\u0068\u0069\u0073\u002e\u0052\u0020\u003d\u0020\u0025d\u0020\u0065\u006e\u0063\u0072\u0079\u0070t\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061\u0020\u0025\u0076",_dfb .R ,_dfb .EncryptMetadata );
if (_dfb .R >=4)&&!_dfb .EncryptMetadata {_dee .Write ([]byte {0xff,0xff,0xff,0xff});};_ded :=_dee .Sum (nil );if _dfb .R >=3{_dee =_a .New ();for _ge :=0;_ge < 50;_ge ++{_dee .Reset ();_dee .Write (_ded [0:_aaa .Length /8]);_ded =_dee .Sum (nil );};};
if _dfb .R >=3{return _ded [0:_aaa .Length /8];};return _ded [0:5];};func (_fgc stdHandlerR6 )alg8 (_fag *StdEncryptDict ,_ace []byte ,_cdb []byte )error {if _ege :=_dg ("\u0061\u006c\u0067\u0038","\u004b\u0065\u0079",32,_ace );_ege !=nil {return _ege ;
};var _eddg [16]byte ;if _ ,_bca :=_g .ReadFull (_gg .Reader ,_eddg [:]);_bca !=nil {return _bca ;};_fbec :=_eddg [0:8];_adf :=_eddg [8:16];_gdg :=make ([]byte ,len (_cdb )+len (_fbec ));_bga :=copy (_gdg ,_cdb );copy (_gdg [_bga :],_fbec );_ced ,_aggg :=_fgc .alg2b (_fag .R ,_gdg ,_cdb ,nil );
if _aggg !=nil {return _aggg ;};U :=make ([]byte ,len (_ced )+len (_fbec )+len (_adf ));_bga =copy (U ,_ced [:32]);_bga +=copy (U [_bga :],_fbec );copy (U [_bga :],_adf );_fag .U =U ;_bga =len (_cdb );copy (_gdg [_bga :],_adf );_ced ,_aggg =_fgc .alg2b (_fag .R ,_gdg ,_cdb ,nil );
if _aggg !=nil {return _aggg ;};_aee ,_aggg :=_cba (_ced [:32]);if _aggg !=nil {return _aggg ;};_bbb :=make ([]byte ,_f .BlockSize );_fdd :=_b .NewCBCEncrypter (_aee ,_bbb );UE :=make ([]byte ,32);_fdd .CryptBlocks (UE ,_ace [:32]);_fag .UE =UE ;return nil ;
};type errInvalidField struct{Func string ;Field string ;Exp int ;Got int ;};func (_ad stdHandlerR4 )alg6 (_aaca *StdEncryptDict ,_gbf []byte )([]byte ,error ){var (_eddd []byte ;_edf error ;);_bg :=_ad .alg2 (_aaca ,_gbf );if _aaca .R ==2{_eddd ,_edf =_ad .alg4 (_bg ,_gbf );
}else if _aaca .R >=3{_eddd ,_edf =_ad .alg5 (_bg ,_gbf );}else {return nil ,_c .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};if _edf !=nil {return nil ,_edf ;};_ea .Log .Trace ("\u0063\u0068\u0065\u0063k:\u0020\u0025\u0020\u0078\u0020\u003d\u003d\u0020\u0025\u0020\u0078\u0020\u003f",string (_eddd ),string (_aaca .U ));
_fge :=_eddd ;_bdf :=_aaca .U ;if _aaca .R >=3{if len (_fge )> 16{_fge =_fge [0:16];};if len (_bdf )> 16{_bdf =_bdf [0:16];};};if !_bf .Equal (_fge ,_bdf ){return nil ,nil ;};return _bg ,nil ;};type stdHandlerR4 struct{Length int ;ID0 string ;};

// StdHandler is an interface for standard security handlers.
type StdHandler interface{

// GenerateParams uses owner and user passwords to set encryption parameters and generate an encryption key.
// It assumes that R, P and EncryptMetadata are already set.
GenerateParams (_ed *StdEncryptDict ,_bb ,_aag []byte )([]byte ,error );

// Authenticate uses encryption dictionary parameters and the password to calculate
// the document encryption key. It also returns permissions that should be granted to a user.
// In case of failed authentication, it returns empty key and zero permissions with no error.
Authenticate (_df *StdEncryptDict ,_abb []byte )([]byte ,Permissions ,error );};func _cc (_fee []byte )([]byte ,error ){_ddf :=_be .New ();_ddf .Write (_fee );return _ddf .Sum (nil ),nil };func (_bad stdHandlerR4 )alg7 (_deee *StdEncryptDict ,_bcd []byte )([]byte ,error ){_gd :=_bad .alg3Key (_deee .R ,_bcd );
_edc :=make ([]byte ,len (_deee .O ));if _deee .R ==2{_gee ,_add :=_fb .NewCipher (_gd );if _add !=nil {return nil ,_c .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_gee .XORKeyStream (_edc ,_deee .O );}else if _deee .R >=3{_ag :=append ([]byte {},_deee .O ...);
for _bfea :=0;_bfea < 20;_bfea ++{_dce :=append ([]byte {},_gd ...);for _eee :=0;_eee < len (_gd );_eee ++{_dce [_eee ]^=byte (19-_bfea );};_gge ,_ceag :=_fb .NewCipher (_dce );if _ceag !=nil {return nil ,_c .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");
};_gge .XORKeyStream (_edc ,_ag );_ag =append ([]byte {},_edc ...);};}else {return nil ,_c .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};_cda ,_dde :=_bad .alg6 (_deee ,_edc );if _dde !=nil {return nil ,nil ;};return _cda ,nil ;};func (_ae *ecbDecrypter )BlockSize ()int {return _ae ._de };


// Authenticate implements StdHandler interface.
func (_efbf stdHandlerR6 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){return _efbf .alg2a (d ,pass );};func (_abbf stdHandlerR6 )alg9 (_cdae *StdEncryptDict ,_ddfc []byte ,_agb []byte )error {if _gdb :=_dg ("\u0061\u006c\u0067\u0039","\u004b\u0065\u0079",32,_ddfc );
_gdb !=nil {return _gdb ;};if _bge :=_dg ("\u0061\u006c\u0067\u0039","\u0055",48,_cdae .U );_bge !=nil {return _bge ;};var _fad [16]byte ;if _ ,_fda :=_g .ReadFull (_gg .Reader ,_fad [:]);_fda !=nil {return _fda ;};_fbc :=_fad [0:8];_gff :=_fad [8:16];
_afb :=_cdae .U [:48];_bcag :=make ([]byte ,len (_agb )+len (_fbc )+len (_afb ));_ffb :=copy (_bcag ,_agb );_ffb +=copy (_bcag [_ffb :],_fbc );_ffb +=copy (_bcag [_ffb :],_afb );_aab ,_gfe :=_abbf .alg2b (_cdae .R ,_bcag ,_agb ,_afb );if _gfe !=nil {return _gfe ;
};O :=make ([]byte ,len (_aab )+len (_fbc )+len (_gff ));_ffb =copy (O ,_aab [:32]);_ffb +=copy (O [_ffb :],_fbc );_ffb +=copy (O [_ffb :],_gff );_cdae .O =O ;_ffb =len (_agb );_ffb +=copy (_bcag [_ffb :],_gff );_aab ,_gfe =_abbf .alg2b (_cdae .R ,_bcag ,_agb ,_afb );
if _gfe !=nil {return _gfe ;};_caa ,_gfe :=_cba (_aab [:32]);if _gfe !=nil {return _gfe ;};_adg :=make ([]byte ,_f .BlockSize );_dbc :=_b .NewCBCEncrypter (_caa ,_adg );OE :=make ([]byte ,32);_dbc .CryptBlocks (OE ,_ddfc [:32]);_cdae .OE =OE ;return nil ;
};func (stdHandlerR4 )paddedPass (_dfd []byte )[]byte {_edd :=make ([]byte ,32);_ac :=copy (_edd ,_dfd );for ;_ac < 32;_ac ++{_edd [_ac ]=_cea [_ac -len (_dfd )];};return _edd ;};func _cge (_fe _b .Block )_b .BlockMode {return (*ecbDecrypter )(_ce (_fe ))};
func (_acg stdHandlerR6 )alg2b (R int ,_agg ,_eaf ,_efd []byte )([]byte ,error ){if R ==5{return _cc (_agg );};return _cfbf (_agg ,_eaf ,_efd );};

// NewHandlerR6 creates a new standard security handler for R=5 and R=6.
func NewHandlerR6 ()StdHandler {return stdHandlerR6 {}};func (_ebff stdHandlerR6 )alg10 (_eegf *StdEncryptDict ,_afgab []byte )error {if _dga :=_dg ("\u0061\u006c\u00671\u0030","\u004b\u0065\u0079",32,_afgab );_dga !=nil {return _dga ;};_cbf :=uint64 (uint32 (_eegf .P ))|(_ef .MaxUint32 <<32);
Perms :=make ([]byte ,16);_cg .LittleEndian .PutUint64 (Perms [:8],_cbf );if _eegf .EncryptMetadata {Perms [8]='T';}else {Perms [8]='F';};copy (Perms [9:12],"\u0061\u0064\u0062");if _ ,_fbfa :=_g .ReadFull (_gg .Reader ,Perms [12:16]);_fbfa !=nil {return _fbfa ;
};_gdgf ,_abed :=_cba (_afgab [:32]);if _abed !=nil {return _abed ;};_fgeg :=_efb (_gdgf );_fgeg .CryptBlocks (Perms ,Perms );_eegf .Perms =Perms [:16];return nil ;};func (_aa *ecbEncrypter )CryptBlocks (dst ,src []byte ){if len (src )%_aa ._de !=0{_ea .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_ea .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_aa ._dc .Encrypt (dst ,src [:_aa ._de ]);src =src [_aa ._de :];dst =dst [_aa ._de :];};};type ecbDecrypter ecb ;

// GenerateParams is the algorithm opposite to alg2a (R>=5).
// It generates U,O,UE,OE,Perms fields using AESv3 encryption.
// There is no algorithm number assigned to this function in the spec.
// It expects R, P and EncryptMetadata fields to be set.
func (_bgef stdHandlerR6 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){_afgf :=make ([]byte ,32);if _ ,_aaaf :=_g .ReadFull (_gg .Reader ,_afgf );_aaaf !=nil {return nil ,_aaaf ;};d .U =nil ;d .O =nil ;d .UE =nil ;d .OE =nil ;
d .Perms =nil ;if len (upass )> 127{upass =upass [:127];};if len (opass )> 127{opass =opass [:127];};if _gfef :=_bgef .alg8 (d ,_afgf ,upass );_gfef !=nil {return nil ,_gfef ;};if _cfa :=_bgef .alg9 (d ,_afgf ,opass );_cfa !=nil {return nil ,_cfa ;};if d .R ==5{return _afgf ,nil ;
};if _aff :=_bgef .alg10 (d ,_afgf );_aff !=nil {return nil ,_aff ;};return _afgf ,nil ;};func (_eag stdHandlerR6 )alg13 (_fgee *StdEncryptDict ,_cae []byte )error {if _ddec :=_dg ("\u0061\u006c\u00671\u0033","\u004b\u0065\u0079",32,_cae );_ddec !=nil {return _ddec ;
};if _cbg :=_dg ("\u0061\u006c\u00671\u0033","\u0050\u0065\u0072m\u0073",16,_fgee .Perms );_cbg !=nil {return _cbg ;};_cbdc :=make ([]byte ,16);copy (_cbdc ,_fgee .Perms [:16]);_dfdc ,_agd :=_f .NewCipher (_cae [:32]);if _agd !=nil {return _agd ;};_bfa :=_cge (_dfdc );
_bfa .CryptBlocks (_cbdc ,_cbdc );if !_bf .Equal (_cbdc [9:12],[]byte ("\u0061\u0064\u0062")){return _c .New ("\u0064\u0065\u0063o\u0064\u0065\u0064\u0020p\u0065\u0072\u006d\u0069\u0073\u0073\u0069o\u006e\u0073\u0020\u0061\u0072\u0065\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};_cbaa :=Permissions (_cg .LittleEndian .Uint32 (_cbdc [0:4]));if _cbaa !=_fgee .P {return _c .New ("\u0070\u0065r\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066\u0061il\u0065\u0064");
};var _cbge bool ;if _cbdc [8]=='T'{_cbge =true ;}else if _cbdc [8]=='F'{_cbge =false ;}else {return _c .New ("\u0064\u0065\u0063\u006f\u0064\u0065\u0064 \u006d\u0065\u0074a\u0064\u0061\u0074\u0061 \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u006c\u0061\u0067\u0020\u0069\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};if _cbge !=_fgee .EncryptMetadata {return _c .New ("\u006d\u0065t\u0061\u0064\u0061\u0074a\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e \u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066a\u0069\u006c\u0065\u0064");
};return nil ;};func (_dbb stdHandlerR4 )alg3 (R int ,_abe ,_fbd []byte )([]byte ,error ){var _aac []byte ;if len (_fbd )> 0{_aac =_dbb .alg3Key (R ,_fbd );}else {_aac =_dbb .alg3Key (R ,_abe );};_cad ,_abf :=_fb .NewCipher (_aac );if _abf !=nil {return nil ,_c .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_bcg :=_dbb .paddedPass (_abe );_ggg :=make ([]byte ,len (_bcg ));_cad .XORKeyStream (_ggg ,_bcg );if R >=3{_fac :=make ([]byte ,len (_aac ));for _ff :=0;_ff < 19;_ff ++{for _cb :=0;_cb < len (_aac );_cb ++{_fac [_cb ]=_aac [_cb ]^byte (_ff +1);};_ee ,_bcb :=_fb .NewCipher (_fac );
if _bcb !=nil {return nil ,_c .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_ee .XORKeyStream (_ggg ,_ggg );};};return _ggg ,nil ;};func (_fecf stdHandlerR6 )alg11 (_fcd *StdEncryptDict ,_egg []byte )([]byte ,error ){if _efdg :=_dg ("\u0061\u006c\u00671\u0031","\u0055",48,_fcd .U );
_efdg !=nil {return nil ,_efdg ;};_cgf :=make ([]byte ,len (_egg )+8);_fgd :=copy (_cgf ,_egg );_fgd +=copy (_cgf [_fgd :],_fcd .U [32:40]);_dfa ,_ega :=_fecf .alg2b (_fcd .R ,_cgf ,_egg ,nil );if _ega !=nil {return nil ,_ega ;};_dfa =_dfa [:32];if !_bf .Equal (_dfa ,_fcd .U [:32]){return nil ,nil ;
};return _dfa ,nil ;};func (_af *ecbEncrypter )BlockSize ()int {return _af ._de };func (_ceab stdHandlerR6 )alg2a (_adc *StdEncryptDict ,_edca []byte )([]byte ,Permissions ,error ){if _gca :=_dg ("\u0061\u006c\u00672\u0061","\u004f",48,_adc .O );_gca !=nil {return nil ,0,_gca ;
};if _fec :=_dg ("\u0061\u006c\u00672\u0061","\u0055",48,_adc .U );_fec !=nil {return nil ,0,_fec ;};if len (_edca )> 127{_edca =_edca [:127];};_cadf ,_cfb :=_ceab .alg12 (_adc ,_edca );if _cfb !=nil {return nil ,0,_cfb ;};var (_ggf []byte ;_dbbe []byte ;
_dfe []byte ;);var _aaf Permissions ;if len (_cadf )!=0{_aaf =PermOwner ;_dcb :=make ([]byte ,len (_edca )+8+48);_cbc :=copy (_dcb ,_edca );_cbc +=copy (_dcb [_cbc :],_adc .O [40:48]);copy (_dcb [_cbc :],_adc .U [0:48]);_ggf =_dcb ;_dbbe =_adc .OE ;_dfe =_adc .U [0:48];
}else {_cadf ,_cfb =_ceab .alg11 (_adc ,_edca );if _cfb ==nil &&len (_cadf )==0{_cadf ,_cfb =_ceab .alg11 (_adc ,[]byte (""));};if _cfb !=nil {return nil ,0,_cfb ;}else if len (_cadf )==0{return nil ,0,nil ;};_aaf =_adc .P ;_eg :=make ([]byte ,len (_edca )+8);
_bfd :=copy (_eg ,_edca );copy (_eg [_bfd :],_adc .U [40:48]);_ggf =_eg ;_dbbe =_adc .UE ;_dfe =nil ;};if _gef :=_dg ("\u0061\u006c\u00672\u0061","\u004b\u0065\u0079",32,_dbbe );_gef !=nil {return nil ,0,_gef ;};_dbbe =_dbbe [:32];_bec ,_cfb :=_ceab .alg2b (_adc .R ,_ggf ,_edca ,_dfe );
if _cfb !=nil {return nil ,0,_cfb ;};_fecb ,_cfb :=_f .NewCipher (_bec [:32]);if _cfb !=nil {return nil ,0,_cfb ;};_agc :=make ([]byte ,_f .BlockSize );_gcf :=_b .NewCBCDecrypter (_fecb ,_agc );_bfee :=make ([]byte ,32);_gcf .CryptBlocks (_bfee ,_dbbe );
if _adc .R ==5{return _bfee ,_aaf ,nil ;};_cfb =_ceab .alg13 (_adc ,_bfee );if _cfb !=nil {return nil ,0,_cfb ;};return _bfee ,_aaf ,nil ;};type stdHandlerR6 struct{};func _efb (_ab _b .Block )_b .BlockMode {return (*ecbEncrypter )(_ce (_ab ))};

// StdEncryptDict is a set of additional fields used in standard encryption dictionary.
type StdEncryptDict struct{R int ;P Permissions ;EncryptMetadata bool ;O ,U []byte ;OE ,UE []byte ;Perms []byte ;};func (_da errInvalidField )Error ()string {return _fc .Sprintf ("\u0025s\u003a\u0020e\u0078\u0070\u0065\u0063t\u0065\u0064\u0020%\u0073\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0074o \u0062\u0065\u0020%\u0064\u0020b\u0079\u0074\u0065\u0073\u002c\u0020g\u006f\u0074 \u0025\u0064",_da .Func ,_da .Field ,_da .Exp ,_da .Got );
};func (_gc stdHandlerR4 )alg5 (_dad []byte ,_ffg []byte )([]byte ,error ){_eeg :=_a .New ();_eeg .Write ([]byte (_cea ));_eeg .Write ([]byte (_gc .ID0 ));_gf :=_eeg .Sum (nil );_ea .Log .Trace ("\u0061\u006c\u0067\u0035");_ea .Log .Trace ("\u0065k\u0065\u0079\u003a\u0020\u0025\u0020x",_dad );
_ea .Log .Trace ("\u0049D\u003a\u0020\u0025\u0020\u0078",_gc .ID0 );if len (_gf )!=16{return nil ,_c .New ("\u0068a\u0073\u0068\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074\u0020\u0031\u0036\u0020\u0062\u0079\u0074\u0065\u0073");};_cdf ,_dd :=_fb .NewCipher (_dad );
if _dd !=nil {return nil ,_c .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_bae :=make ([]byte ,16);_cdf .XORKeyStream (_bae ,_gf );_eb :=make ([]byte ,len (_dad ));for _ggd :=0;_ggd < 19;_ggd ++{for _cgb :=0;
_cgb < len (_dad );_cgb ++{_eb [_cgb ]=_dad [_cgb ]^byte (_ggd +1);};_cdf ,_dd =_fb .NewCipher (_eb );if _dd !=nil {return nil ,_c .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_cdf .XORKeyStream (_bae ,_bae );
_ea .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u002c\u0020\u0065\u006b\u0065\u0079:\u0020\u0025\u0020\u0078",_ggd ,_eb );_ea .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0020\u0078",_ggd ,_bae );};_afga :=make ([]byte ,32);
for _ebf :=0;_ebf < 16;_ebf ++{_afga [_ebf ]=_bae [_ebf ];};_ ,_dd =_gg .Read (_afga [16:32]);if _dd !=nil {return nil ,_c .New ("\u0066a\u0069\u006c\u0065\u0064 \u0074\u006f\u0020\u0067\u0065n\u0020r\u0061n\u0064\u0020\u006e\u0075\u006d\u0062\u0065r");
};return _afga ,nil ;};

// GenerateParams generates and sets O and U parameters for the encryption dictionary.
// It expects R, P and EncryptMetadata fields to be set.
func (_geg stdHandlerR4 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){O ,_aeda :=_geg .alg3 (d .R ,upass ,opass );if _aeda !=nil {_ea .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_aeda );
return nil ,_aeda ;};d .O =O ;_ea .Log .Trace ("\u0067\u0065\u006e\u0020\u004f\u003a\u0020\u0025\u0020\u0078",O );_cgc :=_geg .alg2 (d ,upass );U ,_aeda :=_geg .alg5 (_cgc ,upass );if _aeda !=nil {_ea .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_aeda );
return nil ,_aeda ;};d .U =U ;_ea .Log .Trace ("\u0067\u0065\u006e\u0020\u0055\u003a\u0020\u0025\u0020\u0078",U );return _cgc ,nil ;};

// AuthEvent is an event type that triggers authentication.
type AuthEvent string ;func _gbd (_gfa []byte ,_fafg int ){_gfd :=_fafg ;for _gfd < len (_gfa ){copy (_gfa [_gfd :],_gfa [:_gfd ]);_gfd *=2;};};func _cba (_geac []byte )(_b .Block ,error ){_abc ,_edb :=_f .NewCipher (_geac );if _edb !=nil {_ea .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0063\u0072\u0065\u0061\u0074\u0065\u0020A\u0045\u0053\u0020\u0063\u0069p\u0068\u0065r\u003a\u0020\u0025\u0076",_edb );
return nil ,_edb ;};return _abc ,nil ;};func (_gb *ecbDecrypter )CryptBlocks (dst ,src []byte ){if len (src )%_gb ._de !=0{_ea .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_ea .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0064\u0065\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_gb ._dc .Decrypt (dst ,src [:_gb ._de ]);src =src [_gb ._de :];dst =dst [_gb ._de :];};};

// Allowed checks if a set of permissions can be granted.
func (_fg Permissions )Allowed (p2 Permissions )bool {return _fg &p2 ==p2 };var _ StdHandler =stdHandlerR6 {};

// Authenticate implements StdHandler interface.
func (_baf stdHandlerR4 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){_ea .Log .Trace ("\u0044\u0065b\u0075\u0067\u0067\u0069n\u0067\u0020a\u0075\u0074\u0068\u0065\u006e\u0074\u0069\u0063a\u0074\u0069\u006f\u006e\u0020\u002d\u0020\u006f\u0077\u006e\u0065\u0072 \u0070\u0061\u0073\u0073");
_agf ,_acc :=_baf .alg7 (d ,pass );if _acc !=nil {return nil ,0,_acc ;};if _agf !=nil {_ea .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _agf ,PermOwner ,nil ;
};_ea .Log .Trace ("\u0044\u0065bu\u0067\u0067\u0069n\u0067\u0020\u0061\u0075the\u006eti\u0063\u0061\u0074\u0069\u006f\u006e\u0020- \u0075\u0073\u0065\u0072\u0020\u0070\u0061s\u0073");_agf ,_acc =_baf .alg6 (d ,pass );if _acc !=nil {return nil ,0,_acc ;
};if _agf !=nil {_ea .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _agf ,d .P ,nil ;};return nil ,0,nil ;};func _cfbf (_geb ,_fff ,_cbd []byte )([]byte ,error ){var (_acb ,_dfg ,_fdc _bd .Hash ;
);_acb =_be .New ();_fcg :=make ([]byte ,64);_gdf :=_acb ;_gdf .Write (_geb );K :=_gdf .Sum (_fcg [:0]);_ebb :=make ([]byte ,64*(127+64+48));_ggee :=func (_cca int )([]byte ,error ){_fged :=len (_fff )+len (K )+len (_cbd );_aaac :=_ebb [:_fged ];_bfbg :=copy (_aaac ,_fff );
_bfbg +=copy (_aaac [_bfbg :],K [:]);_bfbg +=copy (_aaac [_bfbg :],_cbd );if _bfbg !=_fged {_ea .Log .Error ("E\u0052\u0052\u004f\u0052\u003a\u0020u\u006e\u0065\u0078\u0070\u0065\u0063t\u0065\u0064\u0020\u0072\u006f\u0075\u006ed\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0073\u0069\u007ae\u002e");
return nil ,_c .New ("\u0077\u0072\u006f\u006e\u0067\u0020\u0073\u0069\u007a\u0065");};K1 :=_ebb [:_fged *64];_gbd (K1 ,_fged );_fbaa ,_fbe :=_cba (K [0:16]);if _fbe !=nil {return nil ,_fbe ;};_fgb :=_b .NewCBCEncrypter (_fbaa ,K [16:32]);_fgb .CryptBlocks (K1 ,K1 );
E :=K1 ;_dec :=0;for _bcdd :=0;_bcdd < 16;_bcdd ++{_dec +=int (E [_bcdd ]%3);};var _ddeg _bd .Hash ;switch _dec %3{case 0:_ddeg =_acb ;case 1:if _dfg ==nil {_dfg =_e .New384 ();};_ddeg =_dfg ;case 2:if _fdc ==nil {_fdc =_e .New ();};_ddeg =_fdc ;};_ddeg .Reset ();
_ddeg .Write (E );K =_ddeg .Sum (_fcg [:0]);return E ,nil ;};for _bfc :=0;;{E ,_bdc :=_ggee (_bfc );if _bdc !=nil {return nil ,_bdc ;};_fbf :=E [len (E )-1];_bfc ++;if _bfc >=64&&_fbf <=uint8 (_bfc -32){break ;};};return K [:32],nil ;};type ecbEncrypter ecb ;
func (_ggb stdHandlerR4 )alg4 (_bac []byte ,_afg []byte )([]byte ,error ){_abfb ,_bda :=_fb .NewCipher (_bac );if _bda !=nil {return nil ,_c .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_gba :=[]byte (_cea );
_ec :=make ([]byte ,len (_gba ));_abfb .XORKeyStream (_ec ,_gba );return _ec ,nil ;};func _ce (_cf _b .Block )*ecb {return &ecb {_dc :_cf ,_de :_cf .BlockSize ()}};

// NewHandlerR4 creates a new standard security handler for R<=4.
func NewHandlerR4 (id0 string ,length int )StdHandler {return stdHandlerR4 {ID0 :id0 ,Length :length }};var _ StdHandler =stdHandlerR4 {};type ecb struct{_dc _b .Block ;_de int ;};const (EventDocOpen =AuthEvent ("\u0044o\u0063\u004f\u0070\u0065\u006e");
EventEFOpen =AuthEvent ("\u0045\u0046\u004f\u0070\u0065\u006e"););

// Permissions is a bitmask of access permissions for a PDF file.
type Permissions uint32 ;const _cea ="\x28\277\116\136\x4e\x75\x8a\x41\x64\000\x4e\x56\377"+"\xfa\001\010\056\x2e\x00\xb6\xd0\x68\076\x80\x2f\014"+"\251\xfe\x64\x53\x69\172";