//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package security ;import (_df "bytes";_fe "crypto/aes";_f "crypto/cipher";_ge "crypto/md5";_g "crypto/rand";_fg "crypto/rc4";_cb "crypto/sha256";_c "crypto/sha512";_ae "encoding/binary";_ff "errors";_dff "fmt";_aac "github.com/unidoc/unipdf/v3/common";
_d "hash";_aa "io";_cbe "math";);

// StdHandler is an interface for standard security handlers.
type StdHandler interface{

// GenerateParams uses owner and user passwords to set encryption parameters and generate an encryption key.
// It assumes that R, P and EncryptMetadata are already set.
GenerateParams (_gg *StdEncryptDict ,_cbg ,_fb []byte )([]byte ,error );

// Authenticate uses encryption dictionary parameters and the password to calculate
// the document encryption key. It also returns permissions that should be granted to a user.
// In case of failed authentication, it returns empty key and zero permissions with no error.
Authenticate (_gf *StdEncryptDict ,_baf []byte )([]byte ,Permissions ,error );};func (_eedf stdHandlerR6 )alg11 (_ccda *StdEncryptDict ,_bbb []byte )([]byte ,error ){if _cbc :=_ca ("\u0061\u006c\u00671\u0031","\u0055",48,_ccda .U );_cbc !=nil {return nil ,_cbc ;
};_eee :=make ([]byte ,len (_bbb )+8);_ade :=copy (_eee ,_bbb );_ade +=copy (_eee [_ade :],_ccda .U [32:40]);_edcb ,_efgd :=_eedf .alg2b (_ccda .R ,_eee ,_bbb ,nil );if _efgd !=nil {return nil ,_efgd ;};_edcb =_edcb [:32];if !_df .Equal (_edcb ,_ccda .U [:32]){return nil ,nil ;
};return _edcb ,nil ;};

// GenerateParams generates and sets O and U parameters for the encryption dictionary.
// It expects R, P and EncryptMetadata fields to be set.
func (_gef stdHandlerR4 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){O ,_cae :=_gef .alg3 (d .R ,upass ,opass );if _cae !=nil {_aac .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_cae );
return nil ,_cae ;};d .O =O ;_aac .Log .Trace ("\u0067\u0065\u006e\u0020\u004f\u003a\u0020\u0025\u0020\u0078",O );_geb :=_gef .alg2 (d ,upass );U ,_cae :=_gef .alg5 (_geb ,upass );if _cae !=nil {_aac .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_cae );
return nil ,_cae ;};d .U =U ;_aac .Log .Trace ("\u0067\u0065\u006e\u0020\u0055\u003a\u0020\u0025\u0020\u0078",U );return _geb ,nil ;};func (_fge stdHandlerR4 )alg2 (_ee *StdEncryptDict ,_gcgc []byte )[]byte {_aac .Log .Trace ("\u0061\u006c\u0067\u0032");
_dd :=_fge .paddedPass (_gcgc );_bae :=_ge .New ();_bae .Write (_dd );_bae .Write (_ee .O );var _bd [4]byte ;_ae .LittleEndian .PutUint32 (_bd [:],uint32 (_ee .P ));_bae .Write (_bd [:]);_aac .Log .Trace ("\u0067o\u0020\u0050\u003a\u0020\u0025\u0020x",_bd );
_bae .Write ([]byte (_fge .ID0 ));_aac .Log .Trace ("\u0074\u0068\u0069\u0073\u002e\u0052\u0020\u003d\u0020\u0025d\u0020\u0065\u006e\u0063\u0072\u0079\u0070t\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061\u0020\u0025\u0076",_ee .R ,_ee .EncryptMetadata );
if (_ee .R >=4)&&!_ee .EncryptMetadata {_bae .Write ([]byte {0xff,0xff,0xff,0xff});};_ced :=_bae .Sum (nil );if _ee .R >=3{_bae =_ge .New ();for _cd :=0;_cd < 50;_cd ++{_bae .Reset ();_bae .Write (_ced [0:_fge .Length /8]);_ced =_bae .Sum (nil );};};if _ee .R >=3{return _ced [0:_fge .Length /8];
};return _ced [0:5];};func _gc (_e _f .Block )_f .BlockMode {return (*ecbEncrypter )(_ce (_e ))};func (_dcbe stdHandlerR4 )alg4 (_eaa []byte ,_gab []byte )([]byte ,error ){_cg ,_cee :=_fg .NewCipher (_eaa );if _cee !=nil {return nil ,_ff .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_bad :=[]byte (_fga );_cba :=make ([]byte ,len (_bad ));_cg .XORKeyStream (_cba ,_bad );return _cba ,nil ;};func _bdf (_gbd []byte )(_f .Block ,error ){_egc ,_cgb :=_fe .NewCipher (_gbd );if _cgb !=nil {_aac .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0063\u0072\u0065\u0061\u0074\u0065\u0020A\u0045\u0053\u0020\u0063\u0069p\u0068\u0065r\u003a\u0020\u0025\u0076",_cgb );
return nil ,_cgb ;};return _egc ,nil ;};const _fga ="\x28\277\116\136\x4e\x75\x8a\x41\x64\000\x4e\x56\377"+"\xfa\001\010\056\x2e\x00\xb6\xd0\x68\076\x80\x2f\014"+"\251\xfe\x64\x53\x69\172";

// Allowed checks if a set of permissions can be granted.
func (_cc Permissions )Allowed (p2 Permissions )bool {return _cc &p2 ==p2 };func (_af *ecbDecrypter )CryptBlocks (dst ,src []byte ){if len (src )%_af ._b !=0{_aac .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_aac .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0064\u0065\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_af ._db .Decrypt (dst ,src [:_af ._b ]);src =src [_af ._b :];dst =dst [_af ._b :];};};

// NewHandlerR6 creates a new standard security handler for R=5 and R=6.
func NewHandlerR6 ()StdHandler {return stdHandlerR6 {}};func _ca (_be ,_bg string ,_feb int ,_gcg []byte )error {if len (_gcg )< _feb {return errInvalidField {Func :_be ,Field :_bg ,Exp :_feb ,Got :len (_gcg )};};return nil ;};func (_cfc stdHandlerR6 )alg8 (_gda *StdEncryptDict ,_ddb []byte ,_fgg []byte )error {if _eede :=_ca ("\u0061\u006c\u0067\u0038","\u004b\u0065\u0079",32,_ddb );
_eede !=nil {return _eede ;};var _bf [16]byte ;if _ ,_ebd :=_aa .ReadFull (_g .Reader ,_bf [:]);_ebd !=nil {return _ebd ;};_gcc :=_bf [0:8];_eba :=_bf [8:16];_fcb :=make ([]byte ,len (_fgg )+len (_gcc ));_dbgb :=copy (_fcb ,_fgg );copy (_fcb [_dbgb :],_gcc );
_ccc ,_cga :=_cfc .alg2b (_gda .R ,_fcb ,_fgg ,nil );if _cga !=nil {return _cga ;};U :=make ([]byte ,len (_ccc )+len (_gcc )+len (_eba ));_dbgb =copy (U ,_ccc [:32]);_dbgb +=copy (U [_dbgb :],_gcc );copy (U [_dbgb :],_eba );_gda .U =U ;_dbgb =len (_fgg );
copy (_fcb [_dbgb :],_eba );_ccc ,_cga =_cfc .alg2b (_gda .R ,_fcb ,_fgg ,nil );if _cga !=nil {return _cga ;};_dffa ,_cga :=_bdf (_ccc [:32]);if _cga !=nil {return _cga ;};_ccd :=make ([]byte ,_fe .BlockSize );_dgc :=_f .NewCBCEncrypter (_dffa ,_ccd );
UE :=make ([]byte ,32);_dgc .CryptBlocks (UE ,_ddb [:32]);_gda .UE =UE ;return nil ;};

// Permissions is a bitmask of access permissions for a PDF file.
type Permissions uint32 ;func _eg (_ea _f .Block )_f .BlockMode {return (*ecbDecrypter )(_ce (_ea ))};func (_dbg stdHandlerR4 )alg3Key (R int ,_dg []byte )[]byte {_aab :=_ge .New ();_dbe :=_dbg .paddedPass (_dg );_aab .Write (_dbe );if R >=3{for _eb :=0;
_eb < 50;_eb ++{_cdc :=_aab .Sum (nil );_aab =_ge .New ();_aab .Write (_cdc );};};_fa :=_aab .Sum (nil );if R ==2{_fa =_fa [0:5];}else {_fa =_fa [0:_dbg .Length /8];};return _fa ;};func (_bbc stdHandlerR4 )alg6 (_dbb *StdEncryptDict ,_cf []byte )([]byte ,error ){var (_aeg []byte ;
_febd error ;);_bge :=_bbc .alg2 (_dbb ,_cf );if _dbb .R ==2{_aeg ,_febd =_bbc .alg4 (_bge ,_cf );}else if _dbb .R >=3{_aeg ,_febd =_bbc .alg5 (_bge ,_cf );}else {return nil ,_ff .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};if _febd !=nil {return nil ,_febd ;
};_aac .Log .Trace ("\u0063\u0068\u0065\u0063k:\u0020\u0025\u0020\u0078\u0020\u003d\u003d\u0020\u0025\u0020\u0078\u0020\u003f",string (_aeg ),string (_dbb .U ));_afb :=_aeg ;_cfg :=_dbb .U ;if _dbb .R >=3{if len (_afb )> 16{_afb =_afb [0:16];};if len (_cfg )> 16{_cfg =_cfg [0:16];
};};if !_df .Equal (_afb ,_cfg ){return nil ,nil ;};return _bge ,nil ;};var _ StdHandler =stdHandlerR4 {};func (stdHandlerR4 )paddedPass (_edf []byte )[]byte {_fc :=make ([]byte ,32);_baa :=copy (_fc ,_edf );for ;_baa < 32;_baa ++{_fc [_baa ]=_fga [_baa -len (_edf )];
};return _fc ;};func (_cdaa stdHandlerR6 )alg10 (_eag *StdEncryptDict ,_eeb []byte )error {if _aegf :=_ca ("\u0061\u006c\u00671\u0030","\u004b\u0065\u0079",32,_eeb );_aegf !=nil {return _aegf ;};_dcg :=uint64 (uint32 (_eag .P ))|(_cbe .MaxUint32 <<32);
Perms :=make ([]byte ,16);_ae .LittleEndian .PutUint64 (Perms [:8],_dcg );if _eag .EncryptMetadata {Perms [8]='T';}else {Perms [8]='F';};copy (Perms [9:12],"\u0061\u0064\u0062");if _ ,_gac :=_aa .ReadFull (_g .Reader ,Perms [12:16]);_gac !=nil {return _gac ;
};_ggbbf ,_dce :=_bdf (_eeb [:32]);if _dce !=nil {return _dce ;};_dba :=_gc (_ggbbf );_dba .CryptBlocks (Perms ,Perms );_eag .Perms =Perms [:16];return nil ;};func _dae (_cgee []byte )([]byte ,error ){_ace :=_cb .New ();_ace .Write (_cgee );return _ace .Sum (nil ),nil ;
};

// Authenticate implements StdHandler interface.
func (_daf stdHandlerR6 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){return _daf .alg2a (d ,pass );};func (_ffe *ecbEncrypter )BlockSize ()int {return _ffe ._b };func (_cbee stdHandlerR6 )alg9 (_bfd *StdEncryptDict ,_acb []byte ,_cda []byte )error {if _efc :=_ca ("\u0061\u006c\u0067\u0039","\u004b\u0065\u0079",32,_acb );
_efc !=nil {return _efc ;};if _dad :=_ca ("\u0061\u006c\u0067\u0039","\u0055",48,_bfd .U );_dad !=nil {return _dad ;};var _gbef [16]byte ;if _ ,_efgb :=_aa .ReadFull (_g .Reader ,_gbef [:]);_efgb !=nil {return _efgb ;};_edc :=_gbef [0:8];_dcf :=_gbef [8:16];
_add :=_bfd .U [:48];_ccb :=make ([]byte ,len (_cda )+len (_edc )+len (_add ));_gbea :=copy (_ccb ,_cda );_gbea +=copy (_ccb [_gbea :],_edc );_gbea +=copy (_ccb [_gbea :],_add );_cfe ,_caa :=_cbee .alg2b (_bfd .R ,_ccb ,_cda ,_add );if _caa !=nil {return _caa ;
};O :=make ([]byte ,len (_cfe )+len (_edc )+len (_dcf ));_gbea =copy (O ,_cfe [:32]);_gbea +=copy (O [_gbea :],_edc );_gbea +=copy (O [_gbea :],_dcf );_bfd .O =O ;_gbea =len (_cda );_gbea +=copy (_ccb [_gbea :],_dcf );_cfe ,_caa =_cbee .alg2b (_bfd .R ,_ccb ,_cda ,_add );
if _caa !=nil {return _caa ;};_efb ,_caa :=_bdf (_cfe [:32]);if _caa !=nil {return _caa ;};_dfg :=make ([]byte ,_fe .BlockSize );_dgcc :=_f .NewCBCEncrypter (_efb ,_dfg );OE :=make ([]byte ,32);_dgcc .CryptBlocks (OE ,_acb [:32]);_bfd .OE =OE ;return nil ;
};func (_ecdf stdHandlerR6 )alg12 (_fedc *StdEncryptDict ,_eff []byte )([]byte ,error ){if _afa :=_ca ("\u0061\u006c\u00671\u0032","\u0055",48,_fedc .U );_afa !=nil {return nil ,_afa ;};if _gafg :=_ca ("\u0061\u006c\u00671\u0032","\u004f",48,_fedc .O );
_gafg !=nil {return nil ,_gafg ;};_aba :=make ([]byte ,len (_eff )+8+48);_cef :=copy (_aba ,_eff );_cef +=copy (_aba [_cef :],_fedc .O [32:40]);_cef +=copy (_aba [_cef :],_fedc .U [0:48]);_agf ,_afg :=_ecdf .alg2b (_fedc .R ,_aba ,_eff ,_fedc .U [0:48]);
if _afg !=nil {return nil ,_afg ;};_agf =_agf [:32];if !_df .Equal (_agf ,_fedc .O [:32]){return nil ,nil ;};return _agf ,nil ;};

// StdEncryptDict is a set of additional fields used in standard encryption dictionary.
type StdEncryptDict struct{R int ;P Permissions ;EncryptMetadata bool ;O ,U []byte ;OE ,UE []byte ;Perms []byte ;};type ecb struct{_db _f .Block ;_b int ;};type ecbDecrypter ecb ;func (_fd stdHandlerR4 )alg3 (R int ,_ebc ,_ddg []byte )([]byte ,error ){var _ga []byte ;
if len (_ddg )> 0{_ga =_fd .alg3Key (R ,_ddg );}else {_ga =_fd .alg3Key (R ,_ebc );};_dfc ,_cbgb :=_fg .NewCipher (_ga );if _cbgb !=nil {return nil ,_ff .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_fde :=_fd .paddedPass (_ebc );
_bdd :=make ([]byte ,len (_fde ));_dfc .XORKeyStream (_bdd ,_fde );if R >=3{_dcb :=make ([]byte ,len (_ga ));for _bab :=0;_bab < 19;_bab ++{for _gff :=0;_gff < len (_ga );_gff ++{_dcb [_gff ]=_ga [_gff ]^byte (_bab +1);};_ef ,_bb :=_fg .NewCipher (_dcb );
if _bb !=nil {return nil ,_ff .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_ef .XORKeyStream (_bdd ,_bdd );};};return _bdd ,nil ;};

// NewHandlerR4 creates a new standard security handler for R<=4.
func NewHandlerR4 (id0 string ,length int )StdHandler {return stdHandlerR4 {ID0 :id0 ,Length :length }};func (_cea stdHandlerR6 )alg13 (_dfa *StdEncryptDict ,_acf []byte )error {if _adg :=_ca ("\u0061\u006c\u00671\u0033","\u004b\u0065\u0079",32,_acf );
_adg !=nil {return _adg ;};if _edgf :=_ca ("\u0061\u006c\u00671\u0033","\u0050\u0065\u0072m\u0073",16,_dfa .Perms );_edgf !=nil {return _edgf ;};_gabf :=make ([]byte ,16);copy (_gabf ,_dfa .Perms [:16]);_fedcd ,_ffa :=_fe .NewCipher (_acf [:32]);if _ffa !=nil {return _ffa ;
};_ged :=_eg (_fedcd );_ged .CryptBlocks (_gabf ,_gabf );if !_df .Equal (_gabf [9:12],[]byte ("\u0061\u0064\u0062")){return _ff .New ("\u0064\u0065\u0063o\u0064\u0065\u0064\u0020p\u0065\u0072\u006d\u0069\u0073\u0073\u0069o\u006e\u0073\u0020\u0061\u0072\u0065\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};_ccf :=Permissions (_ae .LittleEndian .Uint32 (_gabf [0:4]));if _ccf !=_dfa .P {return _ff .New ("\u0070\u0065r\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066\u0061il\u0065\u0064");
};var _cgd bool ;if _gabf [8]=='T'{_cgd =true ;}else if _gabf [8]=='F'{_cgd =false ;}else {return _ff .New ("\u0064\u0065\u0063\u006f\u0064\u0065\u0064 \u006d\u0065\u0074a\u0064\u0061\u0074\u0061 \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u006c\u0061\u0067\u0020\u0069\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};if _cgd !=_dfa .EncryptMetadata {return _ff .New ("\u006d\u0065t\u0061\u0064\u0061\u0074a\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e \u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066a\u0069\u006c\u0065\u0064");
};return nil ;};type errInvalidField struct{Func string ;Field string ;Exp int ;Got int ;};type ecbEncrypter ecb ;func _gbe (_fgd []byte ,_fdc int ){_def :=_fdc ;for _def < len (_fgd ){copy (_fgd [_def :],_fgd [:_def ]);_def *=2;};};func (_bed stdHandlerR4 )alg7 (_dgb *StdEncryptDict ,_cbb []byte )([]byte ,error ){_ab :=_bed .alg3Key (_dgb .R ,_cbb );
_fgf :=make ([]byte ,len (_dgb .O ));if _dgb .R ==2{_ebf ,_aaa :=_fg .NewCipher (_ab );if _aaa !=nil {return nil ,_ff .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_ebf .XORKeyStream (_fgf ,_dgb .O );}else if _dgb .R >=3{_fcg :=append ([]byte {},_dgb .O ...);
for _fgb :=0;_fgb < 20;_fgb ++{_bcg :=append ([]byte {},_ab ...);for _aef :=0;_aef < len (_ab );_aef ++{_bcg [_aef ]^=byte (19-_fgb );};_eed ,_gb :=_fg .NewCipher (_bcg );if _gb !=nil {return nil ,_ff .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");
};_eed .XORKeyStream (_fgf ,_fcg );_fcg =append ([]byte {},_fgf ...);};}else {return nil ,_ff .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};_ac ,_ecb :=_bed .alg6 (_dgb ,_fgf );if _ecb !=nil {return nil ,nil ;};return _ac ,nil ;};const (PermOwner =Permissions (_cbe .MaxUint32 );
PermPrinting =Permissions (1<<2);PermModify =Permissions (1<<3);PermExtractGraphics =Permissions (1<<4);PermAnnotate =Permissions (1<<5);PermFillForms =Permissions (1<<8);PermDisabilityExtract =Permissions (1<<9);PermRotateInsert =Permissions (1<<10);PermFullPrintQuality =Permissions (1<<11);
);func _ce (_ba _f .Block )*ecb {return &ecb {_db :_ba ,_b :_ba .BlockSize ()}};func (_eaf stdHandlerR4 )alg5 (_ceb []byte ,_gd []byte )([]byte ,error ){_edg :=_ge .New ();_edg .Write ([]byte (_fga ));_edg .Write ([]byte (_eaf .ID0 ));_dbc :=_edg .Sum (nil );
_aac .Log .Trace ("\u0061\u006c\u0067\u0035");_aac .Log .Trace ("\u0065k\u0065\u0079\u003a\u0020\u0025\u0020x",_ceb );_aac .Log .Trace ("\u0049D\u003a\u0020\u0025\u0020\u0078",_eaf .ID0 );if len (_dbc )!=16{return nil ,_ff .New ("\u0068a\u0073\u0068\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074\u0020\u0031\u0036\u0020\u0062\u0079\u0074\u0065\u0073");
};_bda ,_gcb :=_fg .NewCipher (_ceb );if _gcb !=nil {return nil ,_ff .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_gdc :=make ([]byte ,16);_bda .XORKeyStream (_gdc ,_dbc );_eda :=make ([]byte ,len (_ceb ));
for _bgd :=0;_bgd < 19;_bgd ++{for _febb :=0;_febb < len (_ceb );_febb ++{_eda [_febb ]=_ceb [_febb ]^byte (_bgd +1);};_bda ,_gcb =_fg .NewCipher (_eda );if _gcb !=nil {return nil ,_ff .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_bda .XORKeyStream (_gdc ,_gdc );_aac .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u002c\u0020\u0065\u006b\u0065\u0079:\u0020\u0025\u0020\u0078",_bgd ,_eda );_aac .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0020\u0078",_bgd ,_gdc );
};_adc :=make ([]byte ,32);for _ec :=0;_ec < 16;_ec ++{_adc [_ec ]=_gdc [_ec ];};_ ,_gcb =_g .Read (_adc [16:32]);if _gcb !=nil {return nil ,_ff .New ("\u0066a\u0069\u006c\u0065\u0064 \u0074\u006f\u0020\u0067\u0065n\u0020r\u0061n\u0064\u0020\u006e\u0075\u006d\u0062\u0065r");
};return _adc ,nil ;};func _edag (_fbe ,_fab ,_beec []byte )([]byte ,error ){var (_ggc ,_fgbg ,_cce _d .Hash ;);_ggc =_cb .New ();_dfe :=make ([]byte ,64);_bcf :=_ggc ;_bcf .Write (_fbe );K :=_bcf .Sum (_dfe [:0]);_gfa :=make ([]byte ,64*(127+64+48));_fda :=func (_bbf int )([]byte ,error ){_dab :=len (_fab )+len (K )+len (_beec );
_egd :=_gfa [:_dab ];_fbg :=copy (_egd ,_fab );_fbg +=copy (_egd [_fbg :],K [:]);_fbg +=copy (_egd [_fbg :],_beec );if _fbg !=_dab {_aac .Log .Error ("E\u0052\u0052\u004f\u0052\u003a\u0020u\u006e\u0065\u0078\u0070\u0065\u0063t\u0065\u0064\u0020\u0072\u006f\u0075\u006ed\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0073\u0069\u007ae\u002e");
return nil ,_ff .New ("\u0077\u0072\u006f\u006e\u0067\u0020\u0073\u0069\u007a\u0065");};K1 :=_gfa [:_dab *64];_gbe (K1 ,_dab );_fbgd ,_fefg :=_bdf (K [0:16]);if _fefg !=nil {return nil ,_fefg ;};_efg :=_f .NewCBCEncrypter (_fbgd ,K [16:32]);_efg .CryptBlocks (K1 ,K1 );
E :=K1 ;_gfb :=0;for _ag :=0;_ag < 16;_ag ++{_gfb +=int (E [_ag ]%3);};var _beef _d .Hash ;switch _gfb %3{case 0:_beef =_ggc ;case 1:if _fgbg ==nil {_fgbg =_c .New384 ();};_beef =_fgbg ;case 2:if _cce ==nil {_cce =_c .New ();};_beef =_cce ;};_beef .Reset ();
_beef .Write (E );K =_beef .Sum (_dfe [:0]);return E ,nil ;};for _dabe :=0;;{E ,_fbc :=_fda (_dabe );if _fbc !=nil {return nil ,_fbc ;};_ece :=E [len (E )-1];_dabe ++;if _dabe >=64&&_ece <=uint8 (_dabe -32){break ;};};return K [:32],nil ;};func (_de stdHandlerR6 )alg2a (_bddd *StdEncryptDict ,_ggb []byte )([]byte ,Permissions ,error ){if _fee :=_ca ("\u0061\u006c\u00672\u0061","\u004f",48,_bddd .O );
_fee !=nil {return nil ,0,_fee ;};if _dcbf :=_ca ("\u0061\u006c\u00672\u0061","\u0055",48,_bddd .U );_dcbf !=nil {return nil ,0,_dcbf ;};if len (_ggb )> 127{_ggb =_ggb [:127];};_fef ,_cge :=_de .alg12 (_bddd ,_ggb );if _cge !=nil {return nil ,0,_cge ;};
var (_ggbb []byte ;_dea []byte ;_da []byte ;);var _fdf Permissions ;if len (_fef )!=0{_fdf =PermOwner ;_gdg :=make ([]byte ,len (_ggb )+8+48);_cbbc :=copy (_gdg ,_ggb );_cbbc +=copy (_gdg [_cbbc :],_bddd .O [40:48]);copy (_gdg [_cbbc :],_bddd .U [0:48]);
_ggbb =_gdg ;_dea =_bddd .OE ;_da =_bddd .U [0:48];}else {_fef ,_cge =_de .alg11 (_bddd ,_ggb );if _cge ==nil &&len (_fef )==0{_fef ,_cge =_de .alg11 (_bddd ,[]byte (""));};if _cge !=nil {return nil ,0,_cge ;}else if len (_fef )==0{return nil ,0,nil ;};
_fdf =_bddd .P ;_gaf :=make ([]byte ,len (_ggb )+8);_dca :=copy (_gaf ,_ggb );copy (_gaf [_dca :],_bddd .U [40:48]);_ggbb =_gaf ;_dea =_bddd .UE ;_da =nil ;};if _ecbg :=_ca ("\u0061\u006c\u00672\u0061","\u004b\u0065\u0079",32,_dea );_ecbg !=nil {return nil ,0,_ecbg ;
};_dea =_dea [:32];_ebbf ,_cge :=_de .alg2b (_bddd .R ,_ggbb ,_ggb ,_da );if _cge !=nil {return nil ,0,_cge ;};_fdd ,_cge :=_fe .NewCipher (_ebbf [:32]);if _cge !=nil {return nil ,0,_cge ;};_bee :=make ([]byte ,_fe .BlockSize );_gcf :=_f .NewCBCDecrypter (_fdd ,_bee );
_ffd :=make ([]byte ,32);_gcf .CryptBlocks (_ffd ,_dea );if _bddd .R ==5{return _ffd ,_fdf ,nil ;};_cge =_de .alg13 (_bddd ,_ffd );if _cge !=nil {return nil ,0,_cge ;};return _ffd ,_fdf ,nil ;};func (_fed errInvalidField )Error ()string {return _dff .Sprintf ("\u0025s\u003a\u0020e\u0078\u0070\u0065\u0063t\u0065\u0064\u0020%\u0073\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0074o \u0062\u0065\u0020%\u0064\u0020b\u0079\u0074\u0065\u0073\u002c\u0020g\u006f\u0074 \u0025\u0064",_fed .Func ,_fed .Field ,_fed .Exp ,_fed .Got );
};const (EventDocOpen =AuthEvent ("\u0044o\u0063\u004f\u0070\u0065\u006e");EventEFOpen =AuthEvent ("\u0045\u0046\u004f\u0070\u0065\u006e"););

// GenerateParams is the algorithm opposite to alg2a (R>=5).
// It generates U,O,UE,OE,Perms fields using AESv3 encryption.
// There is no algorithm number assigned to this function in the spec.
// It expects R, P and EncryptMetadata fields to be set.
func (_bbbd stdHandlerR6 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){_cde :=make ([]byte ,32);if _ ,_fbeb :=_aa .ReadFull (_g .Reader ,_cde );_fbeb !=nil {return nil ,_fbeb ;};d .U =nil ;d .O =nil ;d .UE =nil ;d .OE =nil ;
d .Perms =nil ;if len (upass )> 127{upass =upass [:127];};if len (opass )> 127{opass =opass [:127];};if _cbce :=_bbbd .alg8 (d ,_cde ,upass );_cbce !=nil {return nil ,_cbce ;};if _dbad :=_bbbd .alg9 (d ,_cde ,opass );_dbad !=nil {return nil ,_dbad ;};if d .R ==5{return _cde ,nil ;
};if _babc :=_bbbd .alg10 (d ,_cde );_babc !=nil {return nil ,_babc ;};return _cde ,nil ;};type stdHandlerR6 struct{};func (_ed *ecbEncrypter )CryptBlocks (dst ,src []byte ){if len (src )%_ed ._b !=0{_aac .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_aac .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_ed ._db .Encrypt (dst ,src [:_ed ._b ]);src =src [_ed ._b :];dst =dst [_ed ._b :];};};func (_dc *ecbDecrypter )BlockSize ()int {return _dc ._b };type stdHandlerR4 struct{Length int ;ID0 string ;};

// Authenticate implements StdHandler interface.
func (_gbb stdHandlerR4 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){_aac .Log .Trace ("\u0044\u0065b\u0075\u0067\u0067\u0069n\u0067\u0020a\u0075\u0074\u0068\u0065\u006e\u0074\u0069\u0063a\u0074\u0069\u006f\u006e\u0020\u002d\u0020\u006f\u0077\u006e\u0065\u0072 \u0070\u0061\u0073\u0073");
_gcbd ,_ecd :=_gbb .alg7 (d ,pass );if _ecd !=nil {return nil ,0,_ecd ;};if _gcbd !=nil {_aac .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _gcbd ,PermOwner ,nil ;
};_aac .Log .Trace ("\u0044\u0065bu\u0067\u0067\u0069n\u0067\u0020\u0061\u0075the\u006eti\u0063\u0061\u0074\u0069\u006f\u006e\u0020- \u0075\u0073\u0065\u0072\u0020\u0070\u0061s\u0073");_gcbd ,_ecd =_gbb .alg6 (d ,pass );if _ecd !=nil {return nil ,0,_ecd ;
};if _gcbd !=nil {_aac .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _gcbd ,d .P ,nil ;};return nil ,0,nil ;};var _ StdHandler =stdHandlerR6 {};

// AuthEvent is an event type that triggers authentication.
type AuthEvent string ;func (_ffg stdHandlerR6 )alg2b (R int ,_ffeg ,_aefe ,_cbd []byte )([]byte ,error ){if R ==5{return _dae (_ffeg );};return _edag (_ffeg ,_aefe ,_cbd );};