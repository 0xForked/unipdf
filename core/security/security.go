//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package security ;import (_ag "bytes";_ga "crypto/aes";_c "crypto/cipher";_e "crypto/md5";_gg "crypto/rand";_bc "crypto/rc4";_a "crypto/sha256";_b "crypto/sha512";_cf "encoding/binary";_ac "errors";_cae "fmt";_bcb "github.com/unidoc/unipdf/v3/common";_g "hash";_ca "io";_ed "math";);func (_bgac stdHandlerR4 )alg5 (_dge []byte ,_eea []byte )([]byte ,error ){_da :=_e .New ();_da .Write ([]byte (_cde ));_da .Write ([]byte (_bgac .ID0 ));_dab :=_da .Sum (nil );_bcb .Log .Trace ("\u0061\u006c\u0067\u0035");_bcb .Log .Trace ("\u0065k\u0065\u0079\u003a\u0020\u0025\u0020x",_dge );_bcb .Log .Trace ("\u0049D\u003a\u0020\u0025\u0020\u0078",_bgac .ID0 );if len (_dab )!=16{return nil ,_ac .New ("\u0068a\u0073\u0068\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074\u0020\u0031\u0036\u0020\u0062\u0079\u0074\u0065\u0073");};_fba ,_bgd :=_bc .NewCipher (_dge );if _bgd !=nil {return nil ,_ac .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_ddf :=make ([]byte ,16);_fba .XORKeyStream (_ddf ,_dab );_gad :=make ([]byte ,len (_dge ));for _gb :=0;_gb < 19;_gb ++{for _ec :=0;_ec < len (_dge );_ec ++{_gad [_ec ]=_dge [_ec ]^byte (_gb +1);};_fba ,_bgd =_bc .NewCipher (_gad );if _bgd !=nil {return nil ,_ac .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_fba .XORKeyStream (_ddf ,_ddf );_bcb .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u002c\u0020\u0065\u006b\u0065\u0079:\u0020\u0025\u0020\u0078",_gb ,_gad );_bcb .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0020\u0078",_gb ,_ddf );};_bag :=make ([]byte ,32);for _gga :=0;_gga < 16;_gga ++{_bag [_gga ]=_ddf [_gga ];};_ ,_bgd =_gg .Read (_bag [16:32]);if _bgd !=nil {return nil ,_ac .New ("\u0066a\u0069\u006c\u0065\u0064 \u0074\u006f\u0020\u0067\u0065n\u0020r\u0061n\u0064\u0020\u006e\u0075\u006d\u0062\u0065r");};return _bag ,nil ;};

// Permissions is a bitmask of access permissions for a PDF file.
type Permissions uint32 ;

// GenerateParams generates and sets O and U parameters for the encryption dictionary.
// It expects R, P and EncryptMetadata fields to be set.
func (_gf stdHandlerR4 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){O ,_ddb :=_gf .alg3 (d .R ,upass ,opass );if _ddb !=nil {_bcb .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_ddb );return nil ,_ddb ;};d .O =O ;_bcb .Log .Trace ("\u0067\u0065\u006e\u0020\u004f\u003a\u0020\u0025\u0020\u0078",O );_dff :=_gf .alg2 (d ,upass );U ,_ddb :=_gf .alg5 (_dff ,upass );if _ddb !=nil {_bcb .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_ddb );return nil ,_ddb ;};d .U =U ;_bcb .Log .Trace ("\u0067\u0065\u006e\u0020\u0055\u003a\u0020\u0025\u0020\u0078",U );return _dff ,nil ;};func (_df *ecbEncrypter )BlockSize ()int {return _df ._aa };const _cde ="\x28\277\116\136\x4e\x75\x8a\x41\x64\000\x4e\x56\377"+"\xfa\001\010\056\x2e\x00\xb6\xd0\x68\076\x80\x2f\014"+"\251\xfe\x64\x53\x69\172";func (_bfd stdHandlerR4 )alg3 (R int ,_fcg ,_aebf []byte )([]byte ,error ){var _ggb []byte ;if len (_aebf )> 0{_ggb =_bfd .alg3Key (R ,_aebf );}else {_ggb =_bfd .alg3Key (R ,_fcg );};_bcf ,_abc :=_bc .NewCipher (_ggb );if _abc !=nil {return nil ,_ac .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_ff :=_bfd .paddedPass (_fcg );_gc :=make ([]byte ,len (_ff ));_bcf .XORKeyStream (_gc ,_ff );if R >=3{_dd :=make ([]byte ,len (_ggb ));for _caee :=0;_caee < 19;_caee ++{for _aab :=0;_aab < len (_ggb );_aab ++{_dd [_aab ]=_ggb [_aab ]^byte (_caee +1);};_dda ,_gde :=_bc .NewCipher (_dd );if _gde !=nil {return nil ,_ac .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_dda .XORKeyStream (_gc ,_gc );};};return _gc ,nil ;};func (_fdf stdHandlerR6 )alg11 (_afg *StdEncryptDict ,_dcd []byte )([]byte ,error ){if _fedd :=_cgg ("\u0061\u006c\u00671\u0031","\u0055",48,_afg .U );_fedd !=nil {return nil ,_fedd ;};_dac :=make ([]byte ,len (_dcd )+8);_bff :=copy (_dac ,_dcd );_bff +=copy (_dac [_bff :],_afg .U [32:40]);_bfg ,_bdef :=_fdf .alg2b (_afg .R ,_dac ,_dcd ,nil );if _bdef !=nil {return nil ,_bdef ;};_bfg =_bfg [:32];if !_ag .Equal (_bfg ,_afg .U [:32]){return nil ,nil ;};return _bfg ,nil ;};var _ StdHandler =stdHandlerR6 {};const (PermOwner =Permissions (_ed .MaxUint32 );PermPrinting =Permissions (1<<2);PermModify =Permissions (1<<3);PermExtractGraphics =Permissions (1<<4);PermAnnotate =Permissions (1<<5);PermFillForms =Permissions (1<<8);PermDisabilityExtract =Permissions (1<<9);PermRotateInsert =Permissions (1<<10);PermFullPrintQuality =Permissions (1<<11););

// Authenticate implements StdHandler interface.
func (_eeb stdHandlerR4 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){_bcb .Log .Trace ("\u0044\u0065b\u0075\u0067\u0067\u0069n\u0067\u0020a\u0075\u0074\u0068\u0065\u006e\u0074\u0069\u0063a\u0074\u0069\u006f\u006e\u0020\u002d\u0020\u006f\u0077\u006e\u0065\u0072 \u0070\u0061\u0073\u0073");_gbe ,_fg :=_eeb .alg7 (d ,pass );if _fg !=nil {return nil ,0,_fg ;};if _gbe !=nil {_bcb .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _gbe ,PermOwner ,nil ;};_bcb .Log .Trace ("\u0044\u0065bu\u0067\u0067\u0069n\u0067\u0020\u0061\u0075the\u006eti\u0063\u0061\u0074\u0069\u006f\u006e\u0020- \u0075\u0073\u0065\u0072\u0020\u0070\u0061s\u0073");_gbe ,_fg =_eeb .alg6 (d ,pass );if _fg !=nil {return nil ,0,_fg ;};if _gbe !=nil {_bcb .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _gbe ,d .P ,nil ;};return nil ,0,nil ;};

// NewHandlerR4 creates a new standard security handler for R<=4.
func NewHandlerR4 (id0 string ,length int )StdHandler {return stdHandlerR4 {ID0 :id0 ,Length :length }};var _ StdHandler =stdHandlerR4 {};

// AuthEvent is an event type that triggers authentication.
type AuthEvent string ;

// Authenticate implements StdHandler interface.
func (_bb stdHandlerR6 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){return _bb .alg2a (d ,pass );};

// NewHandlerR6 creates a new standard security handler for R=5 and R=6.
func NewHandlerR6 ()StdHandler {return stdHandlerR6 {}};type ecbEncrypter ecb ;func (_cd *ecbEncrypter )CryptBlocks (dst ,src []byte ){if len (src )%_cd ._aa !=0{_bcb .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");return ;};if len (dst )< len (src ){_bcb .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");return ;};for len (src )> 0{_cd ._f .Encrypt (dst ,src [:_cd ._aa ]);src =src [_cd ._aa :];dst =dst [_cd ._aa :];};};func (_af stdHandlerR6 )alg2b (R int ,_db ,_cbd ,_beg []byte )([]byte ,error ){if R ==5{return _agc (_db );};return _gada (_db ,_cbd ,_beg );};func (_gce stdHandlerR4 )alg7 (_bd *StdEncryptDict ,_aeaf []byte )([]byte ,error ){_dfdb :=_gce .alg3Key (_bd .R ,_aeaf );_ccb :=make ([]byte ,len (_bd .O ));if _bd .R ==2{_edaa ,_eg :=_bc .NewCipher (_dfdb );if _eg !=nil {return nil ,_ac .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_edaa .XORKeyStream (_ccb ,_bd .O );}else if _bd .R >=3{_cea :=append ([]byte {},_bd .O ...);for _fe :=0;_fe < 20;_fe ++{_gadf :=append ([]byte {},_dfdb ...);for _geb :=0;_geb < len (_dfdb );_geb ++{_gadf [_geb ]^=byte (19-_fe );};_ggf ,_gab :=_bc .NewCipher (_gadf );if _gab !=nil {return nil ,_ac .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_ggf .XORKeyStream (_ccb ,_cea );_cea =append ([]byte {},_ccb ...);};}else {return nil ,_ac .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};_bdd ,_ffb :=_gce .alg6 (_bd ,_ccb );if _ffb !=nil {return nil ,nil ;};return _bdd ,nil ;};func (_cbf stdHandlerR4 )alg6 (_cbe *StdEncryptDict ,_cga []byte )([]byte ,error ){var (_dc []byte ;_ggd error ;);_cfc :=_cbf .alg2 (_cbe ,_cga );if _cbe .R ==2{_dc ,_ggd =_cbf .alg4 (_cfc ,_cga );}else if _cbe .R >=3{_dc ,_ggd =_cbf .alg5 (_cfc ,_cga );}else {return nil ,_ac .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};if _ggd !=nil {return nil ,_ggd ;};_bcb .Log .Trace ("\u0063\u0068\u0065\u0063k:\u0020\u0025\u0020\u0078\u0020\u003d\u003d\u0020\u0025\u0020\u0078\u0020\u003f",string (_dc ),string (_cbe .U ));_eb :=_dc ;_baf :=_cbe .U ;if _cbe .R >=3{if len (_eb )> 16{_eb =_eb [0:16];};if len (_baf )> 16{_baf =_baf [0:16];};};if !_ag .Equal (_eb ,_baf ){return nil ,nil ;};return _cfc ,nil ;};func (_ae *ecbDecrypter )BlockSize ()int {return _ae ._aa };func (_caa stdHandlerR4 )alg2 (_cb *StdEncryptDict ,_gd []byte )[]byte {_bcb .Log .Trace ("\u0061\u006c\u0067\u0032");_ead :=_caa .paddedPass (_gd );_bg :=_e .New ();_bg .Write (_ead );_bg .Write (_cb .O );var _bga [4]byte ;_cf .LittleEndian .PutUint32 (_bga [:],uint32 (_cb .P ));_bg .Write (_bga [:]);_bcb .Log .Trace ("\u0067o\u0020\u0050\u003a\u0020\u0025\u0020x",_bga );_bg .Write ([]byte (_caa .ID0 ));_bcb .Log .Trace ("\u0074\u0068\u0069\u0073\u002e\u0052\u0020\u003d\u0020\u0025d\u0020\u0065\u006e\u0063\u0072\u0079\u0070t\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061\u0020\u0025\u0076",_cb .R ,_cb .EncryptMetadata );if (_cb .R >=4)&&!_cb .EncryptMetadata {_bg .Write ([]byte {0xff,0xff,0xff,0xff});};_aea :=_bg .Sum (nil );if _cb .R >=3{_bg =_e .New ();for _cdef :=0;_cdef < 50;_cdef ++{_bg .Reset ();_bg .Write (_aea [0:_caa .Length /8]);_aea =_bg .Sum (nil );};};if _cb .R >=3{return _aea [0:_caa .Length /8];};return _aea [0:5];};func (_aaa *ecbDecrypter )CryptBlocks (dst ,src []byte ){if len (src )%_aaa ._aa !=0{_bcb .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");return ;};if len (dst )< len (src ){_bcb .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0064\u0065\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");return ;};for len (src )> 0{_aaa ._f .Decrypt (dst ,src [:_aaa ._aa ]);src =src [_aaa ._aa :];dst =dst [_aaa ._aa :];};};type errInvalidField struct{Func string ;Field string ;Exp int ;Got int ;};type ecbDecrypter ecb ;func (_adea stdHandlerR6 )alg9 (_fa *StdEncryptDict ,_aaf []byte ,_bee []byte )error {if _cdde :=_cgg ("\u0061\u006c\u0067\u0039","\u004b\u0065\u0079",32,_aaf );_cdde !=nil {return _cdde ;};if _ebg :=_cgg ("\u0061\u006c\u0067\u0039","\u0055",48,_fa .U );_ebg !=nil {return _ebg ;};var _fecg [16]byte ;if _ ,_acb :=_ca .ReadFull (_gg .Reader ,_fecg [:]);_acb !=nil {return _acb ;};_bfb :=_fecg [0:8];_abad :=_fecg [8:16];_bcfe :=_fa .U [:48];_dga :=make ([]byte ,len (_bee )+len (_bfb )+len (_bcfe ));_daa :=copy (_dga ,_bee );_daa +=copy (_dga [_daa :],_bfb );_daa +=copy (_dga [_daa :],_bcfe );_ccc ,_bgcb :=_adea .alg2b (_fa .R ,_dga ,_bee ,_bcfe );if _bgcb !=nil {return _bgcb ;};O :=make ([]byte ,len (_ccc )+len (_bfb )+len (_abad ));_daa =copy (O ,_ccc [:32]);_daa +=copy (O [_daa :],_bfb );_daa +=copy (O [_daa :],_abad );_fa .O =O ;_daa =len (_bee );_daa +=copy (_dga [_daa :],_abad );_ccc ,_bgcb =_adea .alg2b (_fa .R ,_dga ,_bee ,_bcfe );if _bgcb !=nil {return _bgcb ;};_cdc ,_bgcb :=_ddfc (_ccc [:32]);if _bgcb !=nil {return _bgcb ;};_bfbf :=make ([]byte ,_ga .BlockSize );_ebf :=_c .NewCBCEncrypter (_cdc ,_bfbf );OE :=make ([]byte ,32);_ebf .CryptBlocks (OE ,_aaf [:32]);_fa .OE =OE ;return nil ;};const (EventDocOpen =AuthEvent ("\u0044o\u0063\u004f\u0070\u0065\u006e");EventEFOpen =AuthEvent ("\u0045\u0046\u004f\u0070\u0065\u006e"););func _bae (_cdg _c .Block )_c .BlockMode {return (*ecbDecrypter )(_fc (_cdg ))};func (_dbee stdHandlerR6 )alg13 (_eead *StdEncryptDict ,_fdcg []byte )error {if _cdcd :=_cgg ("\u0061\u006c\u00671\u0033","\u004b\u0065\u0079",32,_fdcg );_cdcd !=nil {return _cdcd ;};if _dde :=_cgg ("\u0061\u006c\u00671\u0033","\u0050\u0065\u0072m\u0073",16,_eead .Perms );_dde !=nil {return _dde ;};_fge :=make ([]byte ,16);copy (_fge ,_eead .Perms [:16]);_bca ,_ecf :=_ga .NewCipher (_fdcg [:32]);if _ecf !=nil {return _ecf ;};_dae :=_bae (_bca );_dae .CryptBlocks (_fge ,_fge );if !_ag .Equal (_fge [9:12],[]byte ("\u0061\u0064\u0062")){return _ac .New ("\u0064\u0065\u0063o\u0064\u0065\u0064\u0020p\u0065\u0072\u006d\u0069\u0073\u0073\u0069o\u006e\u0073\u0020\u0061\u0072\u0065\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_bfbc :=Permissions (_cf .LittleEndian .Uint32 (_fge [0:4]));if _bfbc !=_eead .P {return _ac .New ("\u0070\u0065r\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066\u0061il\u0065\u0064");};_edc :=true ;if _fge [8]=='T'{_edc =true ;}else if _fge [8]=='F'{_edc =false ;}else {return _ac .New ("\u0064\u0065\u0063\u006f\u0064\u0065\u0064 \u006d\u0065\u0074a\u0064\u0061\u0074\u0061 \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u006c\u0061\u0067\u0020\u0069\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};if _edc !=_eead .EncryptMetadata {return _ac .New ("\u006d\u0065t\u0061\u0064\u0061\u0074a\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e \u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066a\u0069\u006c\u0065\u0064");};return nil ;};

// Allowed checks if a set of permissions can be granted.
func (_bf Permissions )Allowed (p2 Permissions )bool {return _bf &p2 ==p2 };func (_ee stdHandlerR4 )alg3Key (R int ,_be []byte )[]byte {_dgd :=_e .New ();_bad :=_ee .paddedPass (_be );_dgd .Write (_bad );if R >=3{for _ge :=0;_ge < 50;_ge ++{_dfd :=_dgd .Sum (nil );_dgd =_e .New ();_dgd .Write (_dfd );};};_ce :=_dgd .Sum (nil );if R ==2{_ce =_ce [0:5];}else {_ce =_ce [0:_ee .Length /8];};return _ce ;};type ecb struct{_f _c .Block ;_aa int ;};func _gcg (_caac []byte ,_bfc int ){_bdf :=_bfc ;for _bdf < len (_caac ){copy (_caac [_bdf :],_caac [:_bdf ]);_bdf *=2;};};func (_eae stdHandlerR4 )alg4 (_adg []byte ,_cfg []byte )([]byte ,error ){_ccd ,_cag :=_bc .NewCipher (_adg );if _cag !=nil {return nil ,_ac .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_cagb :=[]byte (_cde );_aec :=make ([]byte ,len (_cagb ));_ccd .XORKeyStream (_aec ,_cagb );return _aec ,nil ;};func _fc (_ad _c .Block )*ecb {return &ecb {_f :_ad ,_aa :_ad .BlockSize ()}};type stdHandlerR6 struct{};

// StdEncryptDict is a set of additional fields used in standard encryption dictionary.
type StdEncryptDict struct{R int ;P Permissions ;EncryptMetadata bool ;O ,U []byte ;OE ,UE []byte ;Perms []byte ;};func _cgg (_fbf ,_dg string ,_aebg int ,_ea []byte )error {if len (_ea )< _aebg {return errInvalidField {Func :_fbf ,Field :_dg ,Exp :_aebg ,Got :len (_ea )};};return nil ;};func _ddfc (_dcg []byte )(_c .Block ,error ){_fed ,_acf :=_ga .NewCipher (_dcg );if _acf !=nil {_bcb .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0063\u0072\u0065\u0061\u0074\u0065\u0020A\u0045\u0053\u0020\u0063\u0069p\u0068\u0065r\u003a\u0020\u0025\u0076",_acf );return nil ,_acf ;};return _fed ,nil ;};func (stdHandlerR4 )paddedPass (_cc []byte )[]byte {_cca :=make ([]byte ,32);_dgf :=copy (_cca ,_cc );for ;_dgf < 32;_dgf ++{_cca [_dgf ]=_cde [_dgf -len (_cc )];};return _cca ;};func (_adb stdHandlerR6 )alg8 (_fcbf *StdEncryptDict ,_bfe []byte ,_aeadb []byte )error {if _fgf :=_cgg ("\u0061\u006c\u0067\u0038","\u004b\u0065\u0079",32,_bfe );_fgf !=nil {return _fgf ;};var _fdef [16]byte ;if _ ,_cef :=_ca .ReadFull (_gg .Reader ,_fdef [:]);_cef !=nil {return _cef ;};_fbb :=_fdef [0:8];_aecf :=_fdef [8:16];_dag :=make ([]byte ,len (_aeadb )+len (_fbb ));_eef :=copy (_dag ,_aeadb );_eef +=copy (_dag [_eef :],_fbb );_gaa ,_ffbe :=_adb .alg2b (_fcbf .R ,_dag ,_aeadb ,nil );if _ffbe !=nil {return _ffbe ;};U :=make ([]byte ,len (_gaa )+len (_fbb )+len (_aecf ));_eef =copy (U ,_gaa [:32]);_eef +=copy (U [_eef :],_fbb );_eef +=copy (U [_eef :],_aecf );_fcbf .U =U ;_eef =len (_aeadb );_eef +=copy (_dag [_eef :],_aecf );_gaa ,_ffbe =_adb .alg2b (_fcbf .R ,_dag ,_aeadb ,nil );if _ffbe !=nil {return _ffbe ;};_fgfd ,_ffbe :=_ddfc (_gaa [:32]);if _ffbe !=nil {return _ffbe ;};_gdd :=make ([]byte ,_ga .BlockSize );_ggg :=_c .NewCBCEncrypter (_fgfd ,_gdd );UE :=make ([]byte ,32);_ggg .CryptBlocks (UE ,_bfe [:32]);_fcbf .UE =UE ;return nil ;};func (_de errInvalidField )Error ()string {return _cae .Sprintf ("\u0025s\u003a\u0020e\u0078\u0070\u0065\u0063t\u0065\u0064\u0020%\u0073\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0074o \u0062\u0065\u0020%\u0064\u0020b\u0079\u0074\u0065\u0073\u002c\u0020g\u006f\u0074 \u0025\u0064",_de .Func ,_de .Field ,_de .Exp ,_de .Got );};type stdHandlerR4 struct{Length int ;ID0 string ;};func (_eadf stdHandlerR6 )alg12 (_bce *StdEncryptDict ,_edae []byte )([]byte ,error ){if _dgddd :=_cgg ("\u0061\u006c\u00671\u0032","\u0055",48,_bce .U );_dgddd !=nil {return nil ,_dgddd ;};if _bafa :=_cgg ("\u0061\u006c\u00671\u0032","\u004f",48,_bce .O );_bafa !=nil {return nil ,_bafa ;};_gag :=make ([]byte ,len (_edae )+8+48);_ef :=copy (_gag ,_edae );_ef +=copy (_gag [_ef :],_bce .O [32:40]);_ef +=copy (_gag [_ef :],_bce .U [0:48]);_dbe ,_bdeg :=_eadf .alg2b (_bce .R ,_gag ,_edae ,_bce .U [0:48]);if _bdeg !=nil {return nil ,_bdeg ;};_dbe =_dbe [:32];if !_ag .Equal (_dbe ,_bce .O [:32]){return nil ,nil ;};return _dbe ,nil ;};func _ba (_fb _c .Block )_c .BlockMode {return (*ecbEncrypter )(_fc (_fb ))};

// GenerateParams is the algorithm opposite to alg2a (R>=5).
// It generates U,O,UE,OE,Perms fields using AESv3 encryption.
// There is no algorithm number assigned to this function in the spec.
// It expects R, P and EncryptMetadata fields to be set.
func (_ggac stdHandlerR6 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){_gbg :=make ([]byte ,32);if _ ,_ege :=_ca .ReadFull (_gg .Reader ,_gbg );_ege !=nil {return nil ,_ege ;};d .U =nil ;d .O =nil ;d .UE =nil ;d .OE =nil ;d .Perms =nil ;if len (upass )> 127{upass =upass [:127];};if len (opass )> 127{opass =opass [:127];};if _ddee :=_ggac .alg8 (d ,_gbg ,upass );_ddee !=nil {return nil ,_ddee ;};if _ega :=_ggac .alg9 (d ,_gbg ,opass );_ega !=nil {return nil ,_ega ;};if d .R ==5{return _gbg ,nil ;};if _fbg :=_ggac .alg10 (d ,_gbg );_fbg !=nil {return nil ,_fbg ;};return _gbg ,nil ;};func (_ceb stdHandlerR6 )alg2a (_fec *StdEncryptDict ,_caaf []byte )([]byte ,Permissions ,error ){if _ade :=_cgg ("\u0061\u006c\u00672\u0061","\u004f",48,_fec .O );_ade !=nil {return nil ,0,_ade ;};if _gebd :=_cgg ("\u0061\u006c\u00672\u0061","\u0055",48,_fec .U );_gebd !=nil {return nil ,0,_gebd ;};if len (_caaf )> 127{_caaf =_caaf [:127];};_fdc ,_dea :=_ceb .alg12 (_fec ,_caaf );if _dea !=nil {return nil ,0,_dea ;};var (_fcd []byte ;_dce []byte ;_aag []byte ;);var _fde Permissions ;if len (_fdc )!=0{_fde =PermOwner ;_dfdc :=make ([]byte ,len (_caaf )+8+48);_dgc :=copy (_dfdc ,_caaf );_dgc +=copy (_dfdc [_dgc :],_fec .O [40:48]);_dgc +=copy (_dfdc [_dgc :],_fec .U [0:48]);_fcd =_dfdc ;_dce =_fec .OE ;_aag =_fec .U [0:48];}else {_fdc ,_dea =_ceb .alg11 (_fec ,_caaf );if _dea ==nil &&len (_fdc )==0{_fdc ,_dea =_ceb .alg11 (_fec ,[]byte (""));};if _dea !=nil {return nil ,0,_dea ;}else if len (_fdc )==0{return nil ,0,nil ;};_fde =_fec .P ;_fcb :=make ([]byte ,len (_caaf )+8);_aae :=copy (_fcb ,_caaf );_aae +=copy (_fcb [_aae :],_fec .U [40:48]);_fcd =_fcb ;_dce =_fec .UE ;_aag =nil ;};if _ebe :=_cgg ("\u0061\u006c\u00672\u0061","\u004b\u0065\u0079",32,_dce );_ebe !=nil {return nil ,0,_ebe ;};_dce =_dce [:32];_eeae ,_dea :=_ceb .alg2b (_fec .R ,_fcd ,_caaf ,_aag );if _dea !=nil {return nil ,0,_dea ;};_edg ,_dea :=_ga .NewCipher (_eeae [:32]);if _dea !=nil {return nil ,0,_dea ;};_dgdd :=make ([]byte ,_ga .BlockSize );_aeg :=_c .NewCBCDecrypter (_edg ,_dgdd );_bge :=make ([]byte ,32);_aeg .CryptBlocks (_bge ,_dce );if _fec .R ==5{return _bge ,_fde ,nil ;};_dea =_ceb .alg13 (_fec ,_bge );if _dea !=nil {return nil ,0,_dea ;};return _bge ,_fde ,nil ;};func (_gbea stdHandlerR6 )alg10 (_bcbe *StdEncryptDict ,_cfgg []byte )error {if _dcf :=_cgg ("\u0061\u006c\u00671\u0030","\u004b\u0065\u0079",32,_cfgg );_dcf !=nil {return _dcf ;};_fcda :=uint64 (uint32 (_bcbe .P ))|(_ed .MaxUint32 <<32);Perms :=make ([]byte ,16);_cf .LittleEndian .PutUint64 (Perms [:8],_fcda );if _bcbe .EncryptMetadata {Perms [8]='T';}else {Perms [8]='F';};copy (Perms [9:12],"\u0061\u0064\u0062");if _ ,_ebgc :=_ca .ReadFull (_gg .Reader ,Perms [12:16]);_ebgc !=nil {return _ebgc ;};_fdg ,_aebgd :=_ddfc (_cfgg [:32]);if _aebgd !=nil {return _aebgd ;};_dba :=_ba (_fdg );_dba .CryptBlocks (Perms ,Perms );_bcbe .Perms =Perms [:16];return nil ;};func _agc (_ccad []byte )([]byte ,error ){_aead :=_a .New ();_aead .Write (_ccad );return _aead .Sum (nil ),nil ;};func _gada (_dec ,_fcgd ,_caf []byte )([]byte ,error ){var (_gebdf ,_bcc ,_cdea _g .Hash ;);_gebdf =_a .New ();_def :=make ([]byte ,64);_dabe :=_gebdf ;_dabe .Write (_dec );K :=_dabe .Sum (_def [:0]);_cdd :=make ([]byte ,64*(127+64+48));_aba :=func (_cgge int )([]byte ,error ){_aad :=len (_fcgd )+len (K )+len (_caf );_baea :=_cdd [:_aad ];_agg :=copy (_baea ,_fcgd );_agg +=copy (_baea [_agg :],K [:]);_agg +=copy (_baea [_agg :],_caf );if _agg !=_aad {_bcb .Log .Error ("E\u0052\u0052\u004f\u0052\u003a\u0020u\u006e\u0065\u0078\u0070\u0065\u0063t\u0065\u0064\u0020\u0072\u006f\u0075\u006ed\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0073\u0069\u007ae\u002e");return nil ,_ac .New ("\u0077\u0072\u006f\u006e\u0067\u0020\u0073\u0069\u007a\u0065");};K1 :=_cdd [:_aad *64];_gcg (K1 ,_aad );_ddbd ,_gae :=_ddfc (K [0:16]);if _gae !=nil {return nil ,_gae ;};_bde :=_c .NewCBCEncrypter (_ddbd ,K [16:32]);_bde .CryptBlocks (K1 ,K1 );E :=K1 ;_bdg :=0;for _cbb :=0;_cbb < 16;_cbb ++{_bdg +=int (E [_cbb ]%3);};var _ceg _g .Hash ;switch _bdg %3{case 0:_ceg =_gebdf ;case 1:if _bcc ==nil {_bcc =_b .New384 ();};_ceg =_bcc ;case 2:if _cdea ==nil {_cdea =_b .New ();};_ceg =_cdea ;};_ceg .Reset ();_ceg .Write (E );K =_ceg .Sum (_def [:0]);return E ,nil ;};for _caaa :=0;;{E ,_dgcd :=_aba (_caaa );if _dgcd !=nil {return nil ,_dgcd ;};_agga :=uint8 (E [len (E )-1]);_caaa ++;if _caaa >=64&&_agga <=uint8 (_caaa -32){break ;};};return K [:32],nil ;};

// StdHandler is an interface for standard security handlers.
type StdHandler interface{

// GenerateParams uses owner and user passwords to set encryption parameters and generate an encryption key.
// It assumes that R, P and EncryptMetadata are already set.
GenerateParams (_dfe *StdEncryptDict ,_cg ,_aeb []byte )([]byte ,error );

// Authenticate uses encryption dictionary parameters and the password to calculate
// the document encryption key. It also returns permissions that should be granted to a user.
// In case of failed authentication, it returns empty key and zero permissions with no error.
Authenticate (_eda *StdEncryptDict ,_ab []byte )([]byte ,Permissions ,error );};