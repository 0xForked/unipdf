//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package security ;import (_gb "bytes";_d "crypto/aes";_c "crypto/cipher";_eg "crypto/md5";_g "crypto/rand";_b "crypto/rc4";_ed "crypto/sha256";_f "crypto/sha512";_cb "encoding/binary";_ac "errors";_ab "fmt";_eca "github.com/unidoc/unipdf/v3/common";_a "hash";
_ec "io";_dc "math";);func (_cg *ecbEncrypter )CryptBlocks (dst ,src []byte ){if len (src )%_cg ._gba !=0{_eca .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_eca .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_cg ._aa .Encrypt (dst ,src [:_cg ._gba ]);src =src [_cg ._gba :];dst =dst [_cg ._gba :];};};func _cbf (_fd _c .Block )_c .BlockMode {return (*ecbEncrypter )(_ge (_fd ))};func (_bge stdHandlerR6 )alg11 (_feb *StdEncryptDict ,_gff []byte )([]byte ,error ){if _gfe :=_fdf ("\u0061\u006c\u00671\u0031","\u0055",48,_feb .U );
_gfe !=nil {return nil ,_gfe ;};_cgc :=make ([]byte ,len (_gff )+8);_fad :=copy (_cgc ,_gff );_fad +=copy (_cgc [_fad :],_feb .U [32:40]);_dbce ,_aca :=_bge .alg2b (_feb .R ,_cgc ,_gff ,nil );if _aca !=nil {return nil ,_aca ;};_dbce =_dbce [:32];if !_gb .Equal (_dbce ,_feb .U [:32]){return nil ,nil ;
};return _dbce ,nil ;};func (_fce stdHandlerR6 )alg10 (_gdba *StdEncryptDict ,_ecbd []byte )error {if _fabe :=_fdf ("\u0061\u006c\u00671\u0030","\u004b\u0065\u0079",32,_ecbd );_fabe !=nil {return _fabe ;};_cea :=uint64 (uint32 (_gdba .P ))|(_dc .MaxUint32 <<32);
Perms :=make ([]byte ,16);_cb .LittleEndian .PutUint64 (Perms [:8],_cea );if _gdba .EncryptMetadata {Perms [8]='T';}else {Perms [8]='F';};copy (Perms [9:12],"\u0061\u0064\u0062");if _ ,_ggc :=_ec .ReadFull (_g .Reader ,Perms [12:16]);_ggc !=nil {return _ggc ;
};_aac ,_fba :=_edb (_ecbd [:32]);if _fba !=nil {return _fba ;};_beb :=_cbf (_aac );_beb .CryptBlocks (Perms ,Perms );_gdba .Perms =Perms [:16];return nil ;};

// StdHandler is an interface for standard security handlers.
type StdHandler interface{

// GenerateParams uses owner and user passwords to set encryption parameters and generate an encryption key.
// It assumes that R, P and EncryptMetadata are already set.
GenerateParams (_gg *StdEncryptDict ,_ca ,_ae []byte )([]byte ,error );

// Authenticate uses encryption dictionary parameters and the password to calculate
// the document encryption key. It also returns permissions that should be granted to a user.
// In case of failed authentication, it returns empty key and zero permissions with no error.
Authenticate (_ba *StdEncryptDict ,_cab []byte )([]byte ,Permissions ,error );};func (_cbg stdHandlerR6 )alg13 (_bdbb *StdEncryptDict ,_aea []byte )error {if _cbe :=_fdf ("\u0061\u006c\u00671\u0033","\u004b\u0065\u0079",32,_aea );_cbe !=nil {return _cbe ;
};if _cbgg :=_fdf ("\u0061\u006c\u00671\u0033","\u0050\u0065\u0072m\u0073",16,_bdbb .Perms );_cbgg !=nil {return _cbgg ;};_acdc :=make ([]byte ,16);copy (_acdc ,_bdbb .Perms [:16]);_ecf ,_deb :=_d .NewCipher (_aea [:32]);if _deb !=nil {return _deb ;};_ccf :=_dbd (_ecf );
_ccf .CryptBlocks (_acdc ,_acdc );if !_gb .Equal (_acdc [9:12],[]byte ("\u0061\u0064\u0062")){return _ac .New ("\u0064\u0065\u0063o\u0064\u0065\u0064\u0020p\u0065\u0072\u006d\u0069\u0073\u0073\u0069o\u006e\u0073\u0020\u0061\u0072\u0065\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};_dfc :=Permissions (_cb .LittleEndian .Uint32 (_acdc [0:4]));if _dfc !=_bdbb .P {return _ac .New ("\u0070\u0065r\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066\u0061il\u0065\u0064");
};var _bgec bool ;if _acdc [8]=='T'{_bgec =true ;}else if _acdc [8]=='F'{_bgec =false ;}else {return _ac .New ("\u0064\u0065\u0063\u006f\u0064\u0065\u0064 \u006d\u0065\u0074a\u0064\u0061\u0074\u0061 \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u006c\u0061\u0067\u0020\u0069\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");
};if _bgec !=_bdbb .EncryptMetadata {return _ac .New ("\u006d\u0065t\u0061\u0064\u0061\u0074a\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e \u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066a\u0069\u006c\u0065\u0064");
};return nil ;};func (_aef stdHandlerR6 )alg2a (_dg *StdEncryptDict ,_bafa []byte )([]byte ,Permissions ,error ){if _aeff :=_fdf ("\u0061\u006c\u00672\u0061","\u004f",48,_dg .O );_aeff !=nil {return nil ,0,_aeff ;};if _egcb :=_fdf ("\u0061\u006c\u00672\u0061","\u0055",48,_dg .U );
_egcb !=nil {return nil ,0,_egcb ;};if len (_bafa )> 127{_bafa =_bafa [:127];};_aga ,_dda :=_aef .alg12 (_dg ,_bafa );if _dda !=nil {return nil ,0,_dda ;};var (_cdd []byte ;_gca []byte ;_dff []byte ;);var _ff Permissions ;if len (_aga )!=0{_ff =PermOwner ;
_adb :=make ([]byte ,len (_bafa )+8+48);_dcg :=copy (_adb ,_bafa );_dcg +=copy (_adb [_dcg :],_dg .O [40:48]);copy (_adb [_dcg :],_dg .U [0:48]);_cdd =_adb ;_gca =_dg .OE ;_dff =_dg .U [0:48];}else {_aga ,_dda =_aef .alg11 (_dg ,_bafa );if _dda ==nil &&len (_aga )==0{_aga ,_dda =_aef .alg11 (_dg ,[]byte (""));
};if _dda !=nil {return nil ,0,_dda ;}else if len (_aga )==0{return nil ,0,nil ;};_ff =_dg .P ;_afd :=make ([]byte ,len (_bafa )+8);_ddb :=copy (_afd ,_bafa );copy (_afd [_ddb :],_dg .U [40:48]);_cdd =_afd ;_gca =_dg .UE ;_dff =nil ;};if _fgd :=_fdf ("\u0061\u006c\u00672\u0061","\u004b\u0065\u0079",32,_gca );
_fgd !=nil {return nil ,0,_fgd ;};_gca =_gca [:32];_dfe ,_dda :=_aef .alg2b (_dg .R ,_cdd ,_bafa ,_dff );if _dda !=nil {return nil ,0,_dda ;};_bfe ,_dda :=_d .NewCipher (_dfe [:32]);if _dda !=nil {return nil ,0,_dda ;};_gef :=make ([]byte ,_d .BlockSize );
_acb :=_c .NewCBCDecrypter (_bfe ,_gef );_abgg :=make ([]byte ,32);_acb .CryptBlocks (_abgg ,_gca );if _dg .R ==5{return _abgg ,_ff ,nil ;};_dda =_aef .alg13 (_dg ,_abgg );if _dda !=nil {return nil ,0,_dda ;};return _abgg ,_ff ,nil ;};func _fgc (_cca ,_efg ,_ccd []byte )([]byte ,error ){var (_bdf ,_beg ,_afb _a .Hash ;
);_bdf =_ed .New ();_dbc :=make ([]byte ,64);_fgcb :=_bdf ;_fgcb .Write (_cca );K :=_fgcb .Sum (_dbc [:0]);_agf :=make ([]byte ,64*(127+64+48));_eaa :=func (_adce int )([]byte ,error ){_gdb :=len (_efg )+len (K )+len (_ccd );_gbc :=_agf [:_gdb ];_fcf :=copy (_gbc ,_efg );
_fcf +=copy (_gbc [_fcf :],K [:]);_fcf +=copy (_gbc [_fcf :],_ccd );if _fcf !=_gdb {_eca .Log .Error ("E\u0052\u0052\u004f\u0052\u003a\u0020u\u006e\u0065\u0078\u0070\u0065\u0063t\u0065\u0064\u0020\u0072\u006f\u0075\u006ed\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0073\u0069\u007ae\u002e");
return nil ,_ac .New ("\u0077\u0072\u006f\u006e\u0067\u0020\u0073\u0069\u007a\u0065");};K1 :=_agf [:_gdb *64];_acd (K1 ,_gdb );_cda ,_gbg :=_edb (K [0:16]);if _gbg !=nil {return nil ,_gbg ;};_aae :=_c .NewCBCEncrypter (_cda ,K [16:32]);_aae .CryptBlocks (K1 ,K1 );
E :=K1 ;_cgde :=0;for _gdf :=0;_gdf < 16;_gdf ++{_cgde +=int (E [_gdf ]%3);};var _cddf _a .Hash ;switch _cgde %3{case 0:_cddf =_bdf ;case 1:if _beg ==nil {_beg =_f .New384 ();};_cddf =_beg ;case 2:if _afb ==nil {_afb =_f .New ();};_cddf =_afb ;};_cddf .Reset ();
_cddf .Write (E );K =_cddf .Sum (_dbc [:0]);return E ,nil ;};for _dge :=0;;{E ,_bfa :=_eaa (_dge );if _bfa !=nil {return nil ,_bfa ;};_aed :=E [len (E )-1];_dge ++;if _dge >=64&&_aed <=uint8 (_dge -32){break ;};};return K [:32],nil ;};func (_fg *ecbDecrypter )CryptBlocks (dst ,src []byte ){if len (src )%_fg ._gba !=0{_eca .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");
return ;};if len (dst )< len (src ){_eca .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0064\u0065\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");
return ;};for len (src )> 0{_fg ._aa .Decrypt (dst ,src [:_fg ._gba ]);src =src [_fg ._gba :];dst =dst [_fg ._gba :];};};func (_efb stdHandlerR6 )alg9 (_aeea *StdEncryptDict ,_bg []byte ,_aece []byte )error {if _ece :=_fdf ("\u0061\u006c\u0067\u0039","\u004b\u0065\u0079",32,_bg );
_ece !=nil {return _ece ;};if _cgg :=_fdf ("\u0061\u006c\u0067\u0039","\u0055",48,_aeea .U );_cgg !=nil {return _cgg ;};var _fea [16]byte ;if _ ,_ddg :=_ec .ReadFull (_g .Reader ,_fea [:]);_ddg !=nil {return _ddg ;};_ffc :=_fea [0:8];_adceb :=_fea [8:16];
_ged :=_aeea .U [:48];_feab :=make ([]byte ,len (_aece )+len (_ffc )+len (_ged ));_faa :=copy (_feab ,_aece );_faa +=copy (_feab [_faa :],_ffc );_faa +=copy (_feab [_faa :],_ged );_cce ,_cfe :=_efb .alg2b (_aeea .R ,_feab ,_aece ,_ged );if _cfe !=nil {return _cfe ;
};O :=make ([]byte ,len (_cce )+len (_ffc )+len (_adceb ));_faa =copy (O ,_cce [:32]);_faa +=copy (O [_faa :],_ffc );_faa +=copy (O [_faa :],_adceb );_aeea .O =O ;_faa =len (_aece );_faa +=copy (_feab [_faa :],_adceb );_cce ,_cfe =_efb .alg2b (_aeea .R ,_feab ,_aece ,_ged );
if _cfe !=nil {return _cfe ;};_ebf ,_cfe :=_edb (_cce [:32]);if _cfe !=nil {return _cfe ;};_eabb :=make ([]byte ,_d .BlockSize );_cfg :=_c .NewCBCEncrypter (_ebf ,_eabb );OE :=make ([]byte ,32);_cfg .CryptBlocks (OE ,_bg [:32]);_aeea .OE =OE ;return nil ;
};func _ge (_abg _c .Block )*ecb {return &ecb {_aa :_abg ,_gba :_abg .BlockSize ()}};func (_fcg stdHandlerR4 )alg3Key (R int ,_daa []byte )[]byte {_edcg :=_eg .New ();_aab :=_fcg .paddedPass (_daa );_edcg .Write (_aab );if R >=3{for _ga :=0;_ga < 50;_ga ++{_ef :=_edcg .Sum (nil );
_edcg =_eg .New ();_edcg .Write (_ef );};};_dd :=_edcg .Sum (nil );if R ==2{_dd =_dd [0:5];}else {_dd =_dd [0:_fcg .Length /8];};return _dd ;};

// GenerateParams generates and sets O and U parameters for the encryption dictionary.
// It expects R, P and EncryptMetadata fields to be set.
func (_ebc stdHandlerR4 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){O ,_ecbf :=_ebc .alg3 (d .R ,upass ,opass );if _ecbf !=nil {_eca .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_ecbf );
return nil ,_ecbf ;};d .O =O ;_eca .Log .Trace ("\u0067\u0065\u006e\u0020\u004f\u003a\u0020\u0025\u0020\u0078",O );_baff :=_ebc .alg2 (d ,upass );U ,_ecbf :=_ebc .alg5 (_baff ,upass );if _ecbf !=nil {_eca .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_ecbf );
return nil ,_ecbf ;};d .U =U ;_eca .Log .Trace ("\u0067\u0065\u006e\u0020\u0055\u003a\u0020\u0025\u0020\u0078",U );return _baff ,nil ;};const (PermOwner =Permissions (_dc .MaxUint32 );PermPrinting =Permissions (1<<2);PermModify =Permissions (1<<3);PermExtractGraphics =Permissions (1<<4);
PermAnnotate =Permissions (1<<5);PermFillForms =Permissions (1<<8);PermDisabilityExtract =Permissions (1<<9);PermRotateInsert =Permissions (1<<10);PermFullPrintQuality =Permissions (1<<11););func (_db *ecbEncrypter )BlockSize ()int {return _db ._gba };
type stdHandlerR4 struct{Length int ;ID0 string ;};func _fdf (_ega ,_cabg string ,_abd int ,_ede []byte )error {if len (_ede )< _abd {return errInvalidField {Func :_ega ,Field :_cabg ,Exp :_abd ,Got :len (_ede )};};return nil ;};var _ StdHandler =stdHandlerR4 {};
func (_fb *ecbDecrypter )BlockSize ()int {return _fb ._gba };const _fc ="\x28\277\116\136\x4e\x75\x8a\x41\x64\000\x4e\x56\377"+"\xfa\001\010\056\x2e\x00\xb6\xd0\x68\076\x80\x2f\014"+"\251\xfe\x64\x53\x69\172";

// Authenticate implements StdHandler interface.
func (_dgb stdHandlerR6 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){return _dgb .alg2a (d ,pass );};func (_eb stdHandlerR4 )alg3 (R int ,_ad ,_cbb []byte )([]byte ,error ){var _bb []byte ;if len (_cbb )> 0{_bb =_eb .alg3Key (R ,_cbb );
}else {_bb =_eb .alg3Key (R ,_ad );};_dbb ,_ebd :=_b .NewCipher (_bb );if _ebd !=nil {return nil ,_ac .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_dcd :=_eb .paddedPass (_ad );_dae :=make ([]byte ,len (_dcd ));
_dbb .XORKeyStream (_dae ,_dcd );if R >=3{_fde :=make ([]byte ,len (_bb ));for _ddf :=0;_ddf < 19;_ddf ++{for _gd :=0;_gd < len (_bb );_gd ++{_fde [_gd ]=_bb [_gd ]^byte (_ddf +1);};_bef ,_baf :=_b .NewCipher (_fde );if _baf !=nil {return nil ,_ac .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_bef .XORKeyStream (_dae ,_dae );};};return _dae ,nil ;};func (_bd stdHandlerR4 )alg2 (_da *StdEncryptDict ,_fe []byte )[]byte {_eca .Log .Trace ("\u0061\u006c\u0067\u0032");_be :=_bd .paddedPass (_fe );_cc :=_eg .New ();_cc .Write (_be );_cc .Write (_da .O );
var _caf [4]byte ;_cb .LittleEndian .PutUint32 (_caf [:],uint32 (_da .P ));_cc .Write (_caf [:]);_eca .Log .Trace ("\u0067o\u0020\u0050\u003a\u0020\u0025\u0020x",_caf );_cc .Write ([]byte (_bd .ID0 ));_eca .Log .Trace ("\u0074\u0068\u0069\u0073\u002e\u0052\u0020\u003d\u0020\u0025d\u0020\u0065\u006e\u0063\u0072\u0079\u0070t\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061\u0020\u0025\u0076",_da .R ,_da .EncryptMetadata );
if (_da .R >=4)&&!_da .EncryptMetadata {_cc .Write ([]byte {0xff,0xff,0xff,0xff});};_bc :=_cc .Sum (nil );if _da .R >=3{_cc =_eg .New ();for _egb :=0;_egb < 50;_egb ++{_cc .Reset ();_cc .Write (_bc [0:_bd .Length /8]);_bc =_cc .Sum (nil );};};if _da .R >=3{return _bc [0:_bd .Length /8];
};return _bc [0:5];};

// NewHandlerR4 creates a new standard security handler for R<=4.
func NewHandlerR4 (id0 string ,length int )StdHandler {return stdHandlerR4 {ID0 :id0 ,Length :length }};

// Permissions is a bitmask of access permissions for a PDF file.
type Permissions uint32 ;func _dbd (_cf _c .Block )_c .BlockMode {return (*ecbDecrypter )(_ge (_cf ))};

// NewHandlerR6 creates a new standard security handler for R=5 and R=6.
func NewHandlerR6 ()StdHandler {return stdHandlerR6 {}};func (_de stdHandlerR4 )alg6 (_ag *StdEncryptDict ,_fdeg []byte )([]byte ,error ){var (_bec []byte ;_fbce error ;);_fcb :=_de .alg2 (_ag ,_fdeg );if _ag .R ==2{_bec ,_fbce =_de .alg4 (_fcb ,_fdeg );
}else if _ag .R >=3{_bec ,_fbce =_de .alg5 (_fcb ,_fdeg );}else {return nil ,_ac .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};if _fbce !=nil {return nil ,_fbce ;};_eca .Log .Trace ("\u0063\u0068\u0065\u0063k:\u0020\u0025\u0020\u0078\u0020\u003d\u003d\u0020\u0025\u0020\u0078\u0020\u003f",string (_bec ),string (_ag .U ));
_ecb :=_bec ;_eba :=_ag .U ;if _ag .R >=3{if len (_ecb )> 16{_ecb =_ecb [0:16];};if len (_eba )> 16{_eba =_eba [0:16];};};if !_gb .Equal (_ecb ,_eba ){return nil ,nil ;};return _fcb ,nil ;};type ecbEncrypter ecb ;func (_aec stdHandlerR4 )alg4 (_ebg []byte ,_fef []byte )([]byte ,error ){_cac ,_adc :=_b .NewCipher (_ebg );
if _adc !=nil {return nil ,_ac .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_edd :=[]byte (_fc );_acc :=make ([]byte ,len (_edd ));_cac .XORKeyStream (_acc ,_edd );return _acc ,nil ;};func (_cec stdHandlerR6 )alg12 (_ade *StdEncryptDict ,_ddge []byte )([]byte ,error ){if _bfd :=_fdf ("\u0061\u006c\u00671\u0032","\u0055",48,_ade .U );
_bfd !=nil {return nil ,_bfd ;};if _bcbf :=_fdf ("\u0061\u006c\u00671\u0032","\u004f",48,_ade .O );_bcbf !=nil {return nil ,_bcbf ;};_cgdec :=make ([]byte ,len (_ddge )+8+48);_geb :=copy (_cgdec ,_ddge );_geb +=copy (_cgdec [_geb :],_ade .O [32:40]);_geb +=copy (_cgdec [_geb :],_ade .U [0:48]);
_bbeb ,_gcae :=_cec .alg2b (_ade .R ,_cgdec ,_ddge ,_ade .U [0:48]);if _gcae !=nil {return nil ,_gcae ;};_bbeb =_bbeb [:32];if !_gb .Equal (_bbeb ,_ade .O [:32]){return nil ,nil ;};return _bbeb ,nil ;};func _gf (_dab []byte )([]byte ,error ){_bbe :=_ed .New ();
_bbe .Write (_dab );return _bbe .Sum (nil ),nil };

// StdEncryptDict is a set of additional fields used in standard encryption dictionary.
type StdEncryptDict struct{R int ;P Permissions ;EncryptMetadata bool ;O ,U []byte ;OE ,UE []byte ;Perms []byte ;};func (stdHandlerR4 )paddedPass (_df []byte )[]byte {_dce :=make ([]byte ,32);_edc :=copy (_dce ,_df );for ;_edc < 32;_edc ++{_dce [_edc ]=_fc [_edc -len (_df )];
};return _dce ;};type ecb struct{_aa _c .Block ;_gba int ;};func _acd (_gcf []byte ,_bcd int ){_ffa :=_bcd ;for _ffa < len (_gcf ){copy (_gcf [_ffa :],_gcf [:_ffa ]);_ffa *=2;};};

// GenerateParams is the algorithm opposite to alg2a (R>=5).
// It generates U,O,UE,OE,Perms fields using AESv3 encryption.
// There is no algorithm number assigned to this function in the spec.
// It expects R, P and EncryptMetadata fields to be set.
func (_efgf stdHandlerR6 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){_gfa :=make ([]byte ,32);if _ ,_bae :=_ec .ReadFull (_g .Reader ,_gfa );_bae !=nil {return nil ,_bae ;};d .U =nil ;d .O =nil ;d .UE =nil ;d .OE =nil ;d .Perms =nil ;
if len (upass )> 127{upass =upass [:127];};if len (opass )> 127{opass =opass [:127];};if _bgd :=_efgf .alg8 (d ,_gfa ,upass );_bgd !=nil {return nil ,_bgd ;};if _bbf :=_efgf .alg9 (d ,_gfa ,opass );_bbf !=nil {return nil ,_bbf ;};if d .R ==5{return _gfa ,nil ;
};if _ebdf :=_efgf .alg10 (d ,_gfa );_ebdf !=nil {return nil ,_ebdf ;};return _gfa ,nil ;};

// Allowed checks if a set of permissions can be granted.
func (_cge Permissions )Allowed (p2 Permissions )bool {return _cge &p2 ==p2 };func (_ecag errInvalidField )Error ()string {return _ab .Sprintf ("\u0025s\u003a\u0020e\u0078\u0070\u0065\u0063t\u0065\u0064\u0020%\u0073\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0074o \u0062\u0065\u0020%\u0064\u0020b\u0079\u0074\u0065\u0073\u002c\u0020g\u006f\u0074 \u0025\u0064",_ecag .Func ,_ecag .Field ,_ecag .Exp ,_ecag .Got );
};func (_dad stdHandlerR6 )alg8 (_eab *StdEncryptDict ,_abb []byte ,_fbg []byte )error {if _ead :=_fdf ("\u0061\u006c\u0067\u0038","\u004b\u0065\u0079",32,_abb );_ead !=nil {return _ead ;};var _dgc [16]byte ;if _ ,_eea :=_ec .ReadFull (_g .Reader ,_dgc [:]);
_eea !=nil {return _eea ;};_ccb :=_dgc [0:8];_ebgb :=_dgc [8:16];_efde :=make ([]byte ,len (_fbg )+len (_ccb ));_eddg :=copy (_efde ,_fbg );copy (_efde [_eddg :],_ccb );_dcef ,_aee :=_dad .alg2b (_eab .R ,_efde ,_fbg ,nil );if _aee !=nil {return _aee ;
};U :=make ([]byte ,len (_dcef )+len (_ccb )+len (_ebgb ));_eddg =copy (U ,_dcef [:32]);_eddg +=copy (U [_eddg :],_ccb );copy (U [_eddg :],_ebgb );_eab .U =U ;_eddg =len (_fbg );copy (_efde [_eddg :],_ebgb );_dcef ,_aee =_dad .alg2b (_eab .R ,_efde ,_fbg ,nil );
if _aee !=nil {return _aee ;};_gde ,_aee :=_edb (_dcef [:32]);if _aee !=nil {return _aee ;};_dfb :=make ([]byte ,_d .BlockSize );_bdfc :=_c .NewCBCEncrypter (_gde ,_dfb );UE :=make ([]byte ,32);_bdfc .CryptBlocks (UE ,_abb [:32]);_eab .UE =UE ;return nil ;
};var _ StdHandler =stdHandlerR6 {};func (_dgd stdHandlerR6 )alg2b (R int ,_ccc ,_egg ,_afdb []byte )([]byte ,error ){if R ==5{return _gf (_ccc );};return _fgc (_ccc ,_egg ,_afdb );};

// AuthEvent is an event type that triggers authentication.
type AuthEvent string ;const (EventDocOpen =AuthEvent ("\u0044o\u0063\u004f\u0070\u0065\u006e");EventEFOpen =AuthEvent ("\u0045\u0046\u004f\u0070\u0065\u006e"););func (_ege stdHandlerR4 )alg5 (_ecg []byte ,_bf []byte )([]byte ,error ){_aba :=_eg .New ();
_aba .Write ([]byte (_fc ));_aba .Write ([]byte (_ege .ID0 ));_fefg :=_aba .Sum (nil );_eca .Log .Trace ("\u0061\u006c\u0067\u0035");_eca .Log .Trace ("\u0065k\u0065\u0079\u003a\u0020\u0025\u0020x",_ecg );_eca .Log .Trace ("\u0049D\u003a\u0020\u0025\u0020\u0078",_ege .ID0 );
if len (_fefg )!=16{return nil ,_ac .New ("\u0068a\u0073\u0068\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074\u0020\u0031\u0036\u0020\u0062\u0079\u0074\u0065\u0073");};_ce ,_fee :=_b .NewCipher (_ecg );if _fee !=nil {return nil ,_ac .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_edeg :=make ([]byte ,16);_ce .XORKeyStream (_edeg ,_fefg );_ea :=make ([]byte ,len (_ecg ));for _fbc :=0;_fbc < 19;_fbc ++{for _bac :=0;_bac < len (_ecg );_bac ++{_ea [_bac ]=_ecg [_bac ]^byte (_fbc +1);};_ce ,_fee =_b .NewCipher (_ea );if _fee !=nil {return nil ,_ac .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");
};_ce .XORKeyStream (_edeg ,_edeg );_eca .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u002c\u0020\u0065\u006b\u0065\u0079:\u0020\u0025\u0020\u0078",_fbc ,_ea );_eca .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0020\u0078",_fbc ,_edeg );
};_fa :=make ([]byte ,32);for _cd :=0;_cd < 16;_cd ++{_fa [_cd ]=_edeg [_cd ];};_ ,_fee =_g .Read (_fa [16:32]);if _fee !=nil {return nil ,_ac .New ("\u0066a\u0069\u006c\u0065\u0064 \u0074\u006f\u0020\u0067\u0065n\u0020r\u0061n\u0064\u0020\u006e\u0075\u006d\u0062\u0065r");
};return _fa ,nil ;};type errInvalidField struct{Func string ;Field string ;Exp int ;Got int ;};

// Authenticate implements StdHandler interface.
func (_daef stdHandlerR4 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){_eca .Log .Trace ("\u0044\u0065b\u0075\u0067\u0067\u0069n\u0067\u0020a\u0075\u0074\u0068\u0065\u006e\u0074\u0069\u0063a\u0074\u0069\u006f\u006e\u0020\u002d\u0020\u006f\u0077\u006e\u0065\u0072 \u0070\u0061\u0073\u0073");
_daf ,_cgee :=_daef .alg7 (d ,pass );if _cgee !=nil {return nil ,0,_cgee ;};if _daf !=nil {_eca .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _daf ,PermOwner ,nil ;
};_eca .Log .Trace ("\u0044\u0065bu\u0067\u0067\u0069n\u0067\u0020\u0061\u0075the\u006eti\u0063\u0061\u0074\u0069\u006f\u006e\u0020- \u0075\u0073\u0065\u0072\u0020\u0070\u0061s\u0073");_daf ,_cgee =_daef .alg6 (d ,pass );if _cgee !=nil {return nil ,0,_cgee ;
};if _daf !=nil {_eca .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _daf ,d .P ,nil ;};return nil ,0,nil ;};type ecbDecrypter ecb ;type stdHandlerR6 struct{};
func _edb (_ace []byte )(_c .Block ,error ){_daad ,_dcc :=_d .NewCipher (_ace );if _dcc !=nil {_eca .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0063\u0072\u0065\u0061\u0074\u0065\u0020A\u0045\u0053\u0020\u0063\u0069p\u0068\u0065r\u003a\u0020\u0025\u0076",_dcc );
return nil ,_dcc ;};return _daad ,nil ;};func (_befg stdHandlerR4 )alg7 (_dcb *StdEncryptDict ,_eff []byte )([]byte ,error ){_bag :=_befg .alg3Key (_dcb .R ,_eff );_gc :=make ([]byte ,len (_dcb .O ));if _dcb .R ==2{_bde ,_adcc :=_b .NewCipher (_bag );if _adcc !=nil {return nil ,_ac .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");
};_bde .XORKeyStream (_gc ,_dcb .O );}else if _dcb .R >=3{_bdb :=append ([]byte {},_dcb .O ...);for _efd :=0;_efd < 20;_efd ++{_ee :=append ([]byte {},_bag ...);for _dag :=0;_dag < len (_bag );_dag ++{_ee [_dag ]^=byte (19-_efd );};_fab ,_ecgg :=_b .NewCipher (_ee );
if _ecgg !=nil {return nil ,_ac .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_fab .XORKeyStream (_gc ,_bdb );_bdb =append ([]byte {},_gc ...);};}else {return nil ,_ac .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");
};_acf ,_cgd :=_befg .alg6 (_dcb ,_gc );if _cgd !=nil {return nil ,nil ;};return _acf ,nil ;};