//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package security ;import (_gf "bytes";_g "crypto/aes";_c "crypto/cipher";_afg "crypto/md5";_af "crypto/rand";_ca "crypto/rc4";_bd "crypto/sha256";_d "crypto/sha512";_bdc "encoding/binary";_ge "errors";_e "fmt";_aa "github.com/unidoc/unipdf/v3/common";_b "hash";_ce "io";_da "math";);const _abg ="\x28\277\116\136\x4e\x75\x8a\x41\x64\000\x4e\x56\377"+"\xfa\001\010\056\x2e\x00\xb6\xd0\x68\076\x80\x2f\014"+"\251\xfe\x64\x53\x69\172";type stdHandlerR4 struct{Length int ;ID0 string ;};func (_eag stdHandlerR6 )alg13 (_fcf *StdEncryptDict ,_dffa []byte )error {if _cfe :=_fg ("\u0061\u006c\u00671\u0033","\u004b\u0065\u0079",32,_dffa );_cfe !=nil {return _cfe ;};if _agef :=_fg ("\u0061\u006c\u00671\u0033","\u0050\u0065\u0072m\u0073",16,_fcf .Perms );_agef !=nil {return _agef ;};_fgd :=make ([]byte ,16);copy (_fgd ,_fcf .Perms [:16]);_bcf ,_bfa :=_g .NewCipher (_dffa [:32]);if _bfa !=nil {return _bfa ;};_bfag :=_ef (_bcf );_bfag .CryptBlocks (_fgd ,_fgd );if !_gf .Equal (_fgd [9:12],[]byte ("\u0061\u0064\u0062")){return _ge .New ("\u0064\u0065\u0063o\u0064\u0065\u0064\u0020p\u0065\u0072\u006d\u0069\u0073\u0073\u0069o\u006e\u0073\u0020\u0061\u0072\u0065\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_ccd :=Permissions (_bdc .LittleEndian .Uint32 (_fgd [0:4]));if _ccd !=_fcf .P {return _ge .New ("\u0070\u0065r\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066\u0061il\u0065\u0064");};_bgg :=true ;if _fgd [8]=='T'{_bgg =true ;}else if _fgd [8]=='F'{_bgg =false ;}else {return _ge .New ("\u0064\u0065\u0063\u006f\u0064\u0065\u0064 \u006d\u0065\u0074a\u0064\u0061\u0074\u0061 \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u006c\u0061\u0067\u0020\u0069\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};if _bgg !=_fcf .EncryptMetadata {return _ge .New ("\u006d\u0065t\u0061\u0064\u0061\u0074a\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e \u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0066a\u0069\u006c\u0065\u0064");};return nil ;};func (_ec stdHandlerR4 )alg3 (R int ,_ddg ,_gb []byte )([]byte ,error ){var _gcc []byte ;if len (_gb )> 0{_gcc =_ec .alg3Key (R ,_gb );}else {_gcc =_ec .alg3Key (R ,_ddg );};_ba ,_fea :=_ca .NewCipher (_gcc );if _fea !=nil {return nil ,_ge .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_gcdf :=_ec .paddedPass (_ddg );_ceae :=make ([]byte ,len (_gcdf ));_ba .XORKeyStream (_ceae ,_gcdf );if R >=3{_bg :=make ([]byte ,len (_gcc ));for _bb :=0;_bb < 19;_bb ++{for _ecc :=0;_ecc < len (_gcc );_ecc ++{_bg [_ecc ]=_gcc [_ecc ]^byte (_bb +1);};_gfcg ,_fec :=_ca .NewCipher (_bg );if _fec !=nil {return nil ,_ge .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_gfcg .XORKeyStream (_ceae ,_ceae );};};return _ceae ,nil ;};func (_efc stdHandlerR4 )alg7 (_afge *StdEncryptDict ,_ggf []byte )([]byte ,error ){_ae :=_efc .alg3Key (_afge .R ,_ggf );_ged :=make ([]byte ,len (_afge .O ));if _afge .R ==2{_acb ,_gfe :=_ca .NewCipher (_ae );if _gfe !=nil {return nil ,_ge .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_acb .XORKeyStream (_ged ,_afge .O );}else if _afge .R >=3{_ccga :=append ([]byte {},_afge .O ...);for _cbg :=0;_cbg < 20;_cbg ++{_efe :=append ([]byte {},_ae ...);for _gda :=0;_gda < len (_ae );_gda ++{_efe [_gda ]^=byte (19-_cbg );};_cag ,_ccbc :=_ca .NewCipher (_efe );if _ccbc !=nil {return nil ,_ge .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0063\u0069\u0070\u0068\u0065\u0072");};_cag .XORKeyStream (_ged ,_ccga );_ccga =append ([]byte {},_ged ...);};}else {return nil ,_ge .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};_fbc ,_gde :=_efc .alg6 (_afge ,_ged );if _gde !=nil {return nil ,nil ;};return _fbc ,nil ;};

// GenerateParams is the algorithm opposite to alg2a (R>=5).
// It generates U,O,UE,OE,Perms fields using AESv3 encryption.
// There is no algorithm number assigned to this function in the spec.
// It expects R, P and EncryptMetadata fields to be set.
func (_afe stdHandlerR6 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){_ddaf :=make ([]byte ,32);if _ ,_cced :=_ce .ReadFull (_af .Reader ,_ddaf );_cced !=nil {return nil ,_cced ;};d .U =nil ;d .O =nil ;d .UE =nil ;d .OE =nil ;d .Perms =nil ;if len (upass )> 127{upass =upass [:127];};if len (opass )> 127{opass =opass [:127];};if _ffaa :=_afe .alg8 (d ,_ddaf ,upass );_ffaa !=nil {return nil ,_ffaa ;};if _acf :=_afe .alg9 (d ,_ddaf ,opass );_acf !=nil {return nil ,_acf ;};if d .R ==5{return _ddaf ,nil ;};if _cdf :=_afe .alg10 (d ,_ddaf );_cdf !=nil {return nil ,_cdf ;};return _ddaf ,nil ;};func (_gddc stdHandlerR6 )alg10 (_cce *StdEncryptDict ,_agg []byte )error {if _ggge :=_fg ("\u0061\u006c\u00671\u0030","\u004b\u0065\u0079",32,_agg );_ggge !=nil {return _ggge ;};_fag :=uint64 (uint32 (_cce .P ))|(_da .MaxUint32 <<32);Perms :=make ([]byte ,16);_bdc .LittleEndian .PutUint64 (Perms [:8],_fag );if _cce .EncryptMetadata {Perms [8]='T';}else {Perms [8]='F';};copy (Perms [9:12],"\u0061\u0064\u0062");if _ ,_afga :=_ce .ReadFull (_af .Reader ,Perms [12:16]);_afga !=nil {return _afga ;};_ffe ,_dafe :=_eg (_agg [:32]);if _dafe !=nil {return _dafe ;};_ddd :=_fe (_ffe );_ddd .CryptBlocks (Perms ,Perms );_cce .Perms =Perms [:16];return nil ;};var _ StdHandler =stdHandlerR6 {};func _dgc (_ddf ,_cbe ,_cec []byte )([]byte ,error ){var (_ddb ,_ggg ,_bbc _b .Hash ;);_ddb =_bd .New ();_aab :=make ([]byte ,64);_bcbg :=_ddb ;_bcbg .Write (_ddf );K :=_bcbg .Sum (_aab [:0]);_gdff :=make ([]byte ,64*(127+64+48));_aec :=func (_fcb int )([]byte ,error ){_abf :=len (_cbe )+len (K )+len (_cec );_ced :=_gdff [:_abf ];_eeb :=copy (_ced ,_cbe );_eeb +=copy (_ced [_eeb :],K [:]);_eeb +=copy (_ced [_eeb :],_cec );if _eeb !=_abf {_aa .Log .Error ("E\u0052\u0052\u004f\u0052\u003a\u0020u\u006e\u0065\u0078\u0070\u0065\u0063t\u0065\u0064\u0020\u0072\u006f\u0075\u006ed\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0073\u0069\u007ae\u002e");return nil ,_ge .New ("\u0077\u0072\u006f\u006e\u0067\u0020\u0073\u0069\u007a\u0065");};K1 :=_gdff [:_abf *64];_egb (K1 ,_abf );_dgb ,_feba :=_eg (K [0:16]);if _feba !=nil {return nil ,_feba ;};_aaa :=_c .NewCBCEncrypter (_dgb ,K [16:32]);_aaa .CryptBlocks (K1 ,K1 );E :=K1 ;_ead :=0;for _geg :=0;_geg < 16;_geg ++{_ead +=int (E [_geg ]%3);};var _fdc _b .Hash ;switch _ead %3{case 0:_fdc =_ddb ;case 1:if _ggg ==nil {_ggg =_d .New384 ();};_fdc =_ggg ;case 2:if _bbc ==nil {_bbc =_d .New ();};_fdc =_bbc ;};_fdc .Reset ();_fdc .Write (E );K =_fdc .Sum (_aab [:0]);return E ,nil ;};for _ebeg :=0;;{E ,_dcg :=_aec (_ebeg );if _dcg !=nil {return nil ,_dcg ;};_edg :=uint8 (E [len (E )-1]);_ebeg ++;if _ebeg >=64&&_edg <=uint8 (_ebeg -32){break ;};};return K [:32],nil ;};func (_ccb stdHandlerR4 )alg6 (_eb *StdEncryptDict ,_agb []byte )([]byte ,error ){var (_cfg []byte ;_abc error ;);_fbd :=_ccb .alg2 (_eb ,_agb );if _eb .R ==2{_cfg ,_abc =_ccb .alg4 (_fbd ,_agb );}else if _eb .R >=3{_cfg ,_abc =_ccb .alg5 (_fbd ,_agb );}else {return nil ,_ge .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020R");};if _abc !=nil {return nil ,_abc ;};_aa .Log .Trace ("\u0063\u0068\u0065\u0063k:\u0020\u0025\u0020\u0078\u0020\u003d\u003d\u0020\u0025\u0020\u0078\u0020\u003f",string (_cfg ),string (_eb .U ));_ff :=_cfg ;_dda :=_eb .U ;if _eb .R >=3{if len (_ff )> 16{_ff =_ff [0:16];};if len (_dda )> 16{_dda =_dda [0:16];};};if !_gf .Equal (_ff ,_dda ){return nil ,nil ;};return _fbd ,nil ;};type ecbDecrypter ecb ;func (_gg *ecbEncrypter )CryptBlocks (dst ,src []byte ){if len (src )%_gg ._f !=0{_aa .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");return ;};if len (dst )< len (src ){_aa .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");return ;};for len (src )> 0{_gg ._ea .Encrypt (dst ,src [:_gg ._f ]);src =src [_gg ._f :];dst =dst [_gg ._f :];};};func (stdHandlerR4 )paddedPass (_fa []byte )[]byte {_age :=make ([]byte ,32);_dd :=copy (_age ,_fa );for ;_dd < 32;_dd ++{_age [_dd ]=_abg [_dd -len (_fa )];};return _age ;};

// AuthEvent is an event type that triggers authentication.
type AuthEvent string ;

// NewHandlerR4 creates a new standard security handler for R<=4.
func NewHandlerR4 (id0 string ,length int )StdHandler {return stdHandlerR4 {ID0 :id0 ,Length :length }};type stdHandlerR6 struct{};func (_ggfe stdHandlerR6 )alg2b (R int ,_gdfe ,_cd ,_gea []byte )([]byte ,error ){if R ==5{return _egc (_gdfe );};return _dgc (_gdfe ,_cd ,_gea );};

// StdHandler is an interface for standard security handlers.
type StdHandler interface{

// GenerateParams uses owner and user passwords to set encryption parameters and generate an encryption key.
// It assumes that R, P and EncryptMetadata are already set.
GenerateParams (_ag *StdEncryptDict ,_bc ,_dc []byte )([]byte ,error );

// Authenticate uses encryption dictionary parameters and the password to calculate
// the document encryption key. It also returns permissions that should be granted to a user.
// In case of failed authentication, it returns empty key and zero permissions with no error.
Authenticate (_bce *StdEncryptDict ,_gc []byte )([]byte ,Permissions ,error );};

// Authenticate implements StdHandler interface.
func (_fca stdHandlerR6 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){return _fca .alg2a (d ,pass );};func _fg (_bf ,_cc string ,_de int ,_ee []byte )error {if len (_ee )< _de {return errInvalidField {Func :_bf ,Field :_cc ,Exp :_de ,Got :len (_ee )};};return nil ;};func (_eab *ecbDecrypter )BlockSize ()int {return _eab ._f };func (_ab *ecbDecrypter )CryptBlocks (dst ,src []byte ){if len (src )%_ab ._f !=0{_aa .Log .Error ("\u0045\u0052\u0052\u004f\u0052:\u0020\u0045\u0043\u0042\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u003a \u0069\u006e\u0070\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u0075\u006c\u006c\u0020\u0062\u006c\u006f\u0063\u006b\u0073");return ;};if len (dst )< len (src ){_aa .Log .Error ("\u0045R\u0052\u004fR\u003a\u0020\u0045C\u0042\u0020\u0064\u0065\u0063\u0072\u0079p\u0074\u003a\u0020\u006f\u0075\u0074p\u0075\u0074\u0020\u0073\u006d\u0061\u006c\u006c\u0065\u0072\u0020t\u0068\u0061\u006e\u0020\u0069\u006e\u0070\u0075\u0074");return ;};for len (src )> 0{_ab ._ea .Decrypt (dst ,src [:_ab ._f ]);src =src [_ab ._f :];dst =dst [_ab ._f :];};};func (_bdf stdHandlerR4 )alg4 (_fef []byte ,_eccg []byte )([]byte ,error ){_cf ,_eed :=_ca .NewCipher (_fef );if _eed !=nil {return nil ,_ge .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_ecb :=[]byte (_abg );_feb :=make ([]byte ,len (_ecb ));_cf .XORKeyStream (_feb ,_ecb );return _feb ,nil ;};func (_dea stdHandlerR6 )alg12 (_ebd *StdEncryptDict ,_dff []byte )([]byte ,error ){if _dafd :=_fg ("\u0061\u006c\u00671\u0032","\u0055",48,_ebd .U );_dafd !=nil {return nil ,_dafd ;};if _cbaf :=_fg ("\u0061\u006c\u00671\u0032","\u004f",48,_ebd .O );_cbaf !=nil {return nil ,_cbaf ;};_dagd :=make ([]byte ,len (_dff )+8+48);_be :=copy (_dagd ,_dff );_be +=copy (_dagd [_be :],_ebd .O [32:40]);_be +=copy (_dagd [_be :],_ebd .U [0:48]);_gfa ,_abd :=_dea .alg2b (_ebd .R ,_dagd ,_dff ,_ebd .U [0:48]);if _abd !=nil {return nil ,_abd ;};_gfa =_gfa [:32];if !_gf .Equal (_gfa ,_ebd .O [:32]){return nil ,nil ;};return _gfa ,nil ;};type errInvalidField struct{Func string ;Field string ;Exp int ;Got int ;};func (_dfb stdHandlerR6 )alg2a (_aea *StdEncryptDict ,_gfb []byte )([]byte ,Permissions ,error ){if _afd :=_fg ("\u0061\u006c\u00672\u0061","\u004f",48,_aea .O );_afd !=nil {return nil ,0,_afd ;};if _fee :=_fg ("\u0061\u006c\u00672\u0061","\u0055",48,_aea .U );_fee !=nil {return nil ,0,_fee ;};if len (_gfb )> 127{_gfb =_gfb [:127];};_ceb ,_cadd :=_dfb .alg12 (_aea ,_gfb );if _cadd !=nil {return nil ,0,_cadd ;};var (_gbc []byte ;_aee []byte ;_db []byte ;);var _cfc Permissions ;if len (_ceb )!=0{_cfc =PermOwner ;_bbg :=make ([]byte ,len (_gfb )+8+48);_ecga :=copy (_bbg ,_gfb );_ecga +=copy (_bbg [_ecga :],_aea .O [40:48]);_ecga +=copy (_bbg [_ecga :],_aea .U [0:48]);_gbc =_bbg ;_aee =_aea .OE ;_db =_aea .U [0:48];}else {_ceb ,_cadd =_dfb .alg11 (_aea ,_gfb );if _cadd ==nil &&len (_ceb )==0{_ceb ,_cadd =_dfb .alg11 (_aea ,[]byte (""));};if _cadd !=nil {return nil ,0,_cadd ;}else if len (_ceb )==0{return nil ,0,nil ;};_cfc =_aea .P ;_ade :=make ([]byte ,len (_gfb )+8);_dec :=copy (_ade ,_gfb );_dec +=copy (_ade [_dec :],_aea .U [40:48]);_gbc =_ade ;_aee =_aea .UE ;_db =nil ;};if _aaf :=_fg ("\u0061\u006c\u00672\u0061","\u004b\u0065\u0079",32,_aee );_aaf !=nil {return nil ,0,_aaf ;};_aee =_aee [:32];_dg ,_cadd :=_dfb .alg2b (_aea .R ,_gbc ,_gfb ,_db );if _cadd !=nil {return nil ,0,_cadd ;};_gfd ,_cadd :=_g .NewCipher (_dg [:32]);if _cadd !=nil {return nil ,0,_cadd ;};_abcb :=make ([]byte ,_g .BlockSize );_fda :=_c .NewCBCDecrypter (_gfd ,_abcb );_baf :=make ([]byte ,32);_fda .CryptBlocks (_baf ,_aee );if _aea .R ==5{return _baf ,_cfc ,nil ;};_cadd =_dfb .alg13 (_aea ,_baf );if _cadd !=nil {return nil ,0,_cadd ;};return _baf ,_cfc ,nil ;};

// GenerateParams generates and sets O and U parameters for the encryption dictionary.
// It expects R, P and EncryptMetadata fields to be set.
func (_bfe stdHandlerR4 )GenerateParams (d *StdEncryptDict ,opass ,upass []byte )([]byte ,error ){O ,_fdb :=_bfe .alg3 (d .R ,upass ,opass );if _fdb !=nil {_aa .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_fdb );return nil ,_fdb ;};d .O =O ;_aa .Log .Trace ("\u0067\u0065\u006e\u0020\u004f\u003a\u0020\u0025\u0020\u0078",O );_gca :=_bfe .alg2 (d ,upass );U ,_fdb :=_bfe .alg5 (_gca ,upass );if _fdb !=nil {_aa .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0045r\u0072\u006f\u0072\u0020\u0067\u0065\u006ee\u0072\u0061\u0074\u0069\u006e\u0067 \u004f\u0020\u0066\u006f\u0072\u0020\u0065\u006e\u0063\u0072\u0079p\u0074\u0069\u006f\u006e\u0020\u0028\u0025\u0073\u0029",_fdb );return nil ,_fdb ;};d .U =U ;_aa .Log .Trace ("\u0067\u0065\u006e\u0020\u0055\u003a\u0020\u0025\u0020\u0078",U );return _gca ,nil ;};type ecbEncrypter ecb ;func (_cda stdHandlerR6 )alg11 (_ffa *StdEncryptDict ,_aae []byte )([]byte ,error ){if _dgca :=_fg ("\u0061\u006c\u00671\u0031","\u0055",48,_ffa .U );_dgca !=nil {return nil ,_dgca ;};_efee :=make ([]byte ,len (_aae )+8);_decba :=copy (_efee ,_aae );_decba +=copy (_efee [_decba :],_ffa .U [32:40]);_adb ,_ffb :=_cda .alg2b (_ffa .R ,_efee ,_aae ,nil );if _ffb !=nil {return nil ,_ffb ;};_adb =_adb [:32];if !_gf .Equal (_adb ,_ffa .U [:32]){return nil ,nil ;};return _adb ,nil ;};func _gd (_aag _c .Block )*ecb {return &ecb {_ea :_aag ,_f :_aag .BlockSize ()}};func _egc (_bcg []byte )([]byte ,error ){_ebe :=_bd .New ();_ebe .Write (_bcg );return _ebe .Sum (nil ),nil ;};type ecb struct{_ea _c .Block ;_f int ;};func (_gfea stdHandlerR6 )alg8 (_bbf *StdEncryptDict ,_bcea []byte ,_ddc []byte )error {if _ddcb :=_fg ("\u0061\u006c\u0067\u0038","\u004b\u0065\u0079",32,_bcea );_ddcb !=nil {return _ddcb ;};var _efd [16]byte ;if _ ,_fbf :=_ce .ReadFull (_af .Reader ,_efd [:]);_fbf !=nil {return _fbf ;};_dac :=_efd [0:8];_adf :=_efd [8:16];_ebb :=make ([]byte ,len (_ddc )+len (_dac ));_ede :=copy (_ebb ,_ddc );_ede +=copy (_ebb [_ede :],_dac );_ccbg ,_eec :=_gfea .alg2b (_bbf .R ,_ebb ,_ddc ,nil );if _eec !=nil {return _eec ;};U :=make ([]byte ,len (_ccbg )+len (_dac )+len (_adf ));_ede =copy (U ,_ccbg [:32]);_ede +=copy (U [_ede :],_dac );_ede +=copy (U [_ede :],_adf );_bbf .U =U ;_ede =len (_ddc );_ede +=copy (_ebb [_ede :],_adf );_ccbg ,_eec =_gfea .alg2b (_bbf .R ,_ebb ,_ddc ,nil );if _eec !=nil {return _eec ;};_dbd ,_eec :=_eg (_ccbg [:32]);if _eec !=nil {return _eec ;};_gdda :=make ([]byte ,_g .BlockSize );_cfge :=_c .NewCBCEncrypter (_dbd ,_gdda );UE :=make ([]byte ,32);_cfge .CryptBlocks (UE ,_bcea [:32]);_bbf .UE =UE ;return nil ;};

// StdEncryptDict is a set of additional fields used in standard encryption dictionary.
type StdEncryptDict struct{R int ;P Permissions ;EncryptMetadata bool ;O ,U []byte ;OE ,UE []byte ;Perms []byte ;};

// NewHandlerR6 creates a new standard security handler for R=5 and R=6.
func NewHandlerR6 ()StdHandler {return stdHandlerR6 {}};

// Authenticate implements StdHandler interface.
func (_ccge stdHandlerR4 )Authenticate (d *StdEncryptDict ,pass []byte )([]byte ,Permissions ,error ){_aa .Log .Trace ("\u0044\u0065b\u0075\u0067\u0067\u0069n\u0067\u0020a\u0075\u0074\u0068\u0065\u006e\u0074\u0069\u0063a\u0074\u0069\u006f\u006e\u0020\u002d\u0020\u006f\u0077\u006e\u0065\u0072 \u0070\u0061\u0073\u0073");_gedd ,_bfd :=_ccge .alg7 (d ,pass );if _bfd !=nil {return nil ,0,_bfd ;};if _gedd !=nil {_aa .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _gedd ,PermOwner ,nil ;};_aa .Log .Trace ("\u0044\u0065bu\u0067\u0067\u0069n\u0067\u0020\u0061\u0075the\u006eti\u0063\u0061\u0074\u0069\u006f\u006e\u0020- \u0075\u0073\u0065\u0072\u0020\u0070\u0061s\u0073");_gedd ,_bfd =_ccge .alg6 (d ,pass );if _bfd !=nil {return nil ,0,_bfd ;};if _gedd !=nil {_aa .Log .Trace ("\u0074h\u0069\u0073\u002e\u0061u\u0074\u0068\u0065\u006e\u0074i\u0063a\u0074e\u0064\u0020\u003d\u0020\u0054\u0072\u0075e");return _gedd ,d .P ,nil ;};return nil ,0,nil ;};func _eg (_ecg []byte )(_c .Block ,error ){_daga ,_dfd :=_g .NewCipher (_ecg );if _dfd !=nil {_aa .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0063\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0063\u0072\u0065\u0061\u0074\u0065\u0020A\u0045\u0053\u0020\u0063\u0069p\u0068\u0065r\u003a\u0020\u0025\u0076",_dfd );return nil ,_dfd ;};return _daga ,nil ;};func (_cea stdHandlerR4 )alg2 (_eae *StdEncryptDict ,_fgc []byte )[]byte {_aa .Log .Trace ("\u0061\u006c\u0067\u0032");_gcd :=_cea .paddedPass (_fgc );_cgc :=_afg .New ();_cgc .Write (_gcd );_cgc .Write (_eae .O );var _gfc [4]byte ;_bdc .LittleEndian .PutUint32 (_gfc [:],uint32 (_eae .P ));_cgc .Write (_gfc [:]);_aa .Log .Trace ("\u0067o\u0020\u0050\u003a\u0020\u0025\u0020x",_gfc );_cgc .Write ([]byte (_cea .ID0 ));_aa .Log .Trace ("\u0074\u0068\u0069\u0073\u002e\u0052\u0020\u003d\u0020\u0025d\u0020\u0065\u006e\u0063\u0072\u0079\u0070t\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061\u0020\u0025\u0076",_eae .R ,_eae .EncryptMetadata );if (_eae .R >=4)&&!_eae .EncryptMetadata {_cgc .Write ([]byte {0xff,0xff,0xff,0xff});};_ad :=_cgc .Sum (nil );if _eae .R >=3{_cgc =_afg .New ();for _ac :=0;_ac < 50;_ac ++{_cgc .Reset ();_cgc .Write (_ad [0:_cea .Length /8]);_ad =_cgc .Sum (nil );};};if _eae .R >=3{return _ad [0:_cea .Length /8];};return _ad [0:5];};func _fe (_cb _c .Block )_c .BlockMode {return (*ecbEncrypter )(_gd (_cb ))};const (EventDocOpen =AuthEvent ("\u0044o\u0063\u004f\u0070\u0065\u006e");EventEFOpen =AuthEvent ("\u0045\u0046\u004f\u0070\u0065\u006e"););func _egb (_dbc []byte ,_cbd int ){_dga :=_cbd ;for _dga < len (_dbc ){copy (_dbc [_dga :],_dbc [:_dga ]);_dga *=2;};};var _ StdHandler =stdHandlerR4 {};func (_ffc stdHandlerR6 )alg9 (_cab *StdEncryptDict ,_dcc []byte ,_bdb []byte )error {if _ecd :=_fg ("\u0061\u006c\u0067\u0039","\u004b\u0065\u0079",32,_dcc );_ecd !=nil {return _ecd ;};if _cge :=_fg ("\u0061\u006c\u0067\u0039","\u0055",48,_cab .U );_cge !=nil {return _cge ;};var _eff [16]byte ;if _ ,_eee :=_ce .ReadFull (_af .Reader ,_eff [:]);_eee !=nil {return _eee ;};_decb :=_eff [0:8];_cedb :=_eff [8:16];_bcbc :=_cab .U [:48];_fgge :=make ([]byte ,len (_bdb )+len (_decb )+len (_bcbc ));_cba :=copy (_fgge ,_bdb );_cba +=copy (_fgge [_cba :],_decb );_cba +=copy (_fgge [_cba :],_bcbc );_gdaa ,_dge :=_ffc .alg2b (_cab .R ,_fgge ,_bdb ,_bcbc );if _dge !=nil {return _dge ;};O :=make ([]byte ,len (_gdaa )+len (_decb )+len (_cedb ));_cba =copy (O ,_gdaa [:32]);_cba +=copy (O [_cba :],_decb );_cba +=copy (O [_cba :],_cedb );_cab .O =O ;_cba =len (_bdb );_cba +=copy (_fgge [_cba :],_cedb );_gdaa ,_dge =_ffc .alg2b (_cab .R ,_fgge ,_bdb ,_bcbc );if _dge !=nil {return _dge ;};_eeca ,_dge :=_eg (_gdaa [:32]);if _dge !=nil {return _dge ;};_afb :=make ([]byte ,_g .BlockSize );_gedc :=_c .NewCBCEncrypter (_eeca ,_afb );OE :=make ([]byte ,32);_gedc .CryptBlocks (OE ,_dcc [:32]);_cab .OE =OE ;return nil ;};func (_ed *ecbEncrypter )BlockSize ()int {return _ed ._f };

// Allowed checks if a set of permissions can be granted.
func (_fcc Permissions )Allowed (p2 Permissions )bool {return _fcc &p2 ==p2 };func (_fac stdHandlerR4 )alg3Key (R int ,_cgb []byte )[]byte {_bcb :=_afg .New ();_bdg :=_fac .paddedPass (_cgb );_bcb .Write (_bdg );if R >=3{for _fge :=0;_fge < 50;_fge ++{_fcd :=_bcb .Sum (nil );_bcb =_afg .New ();_bcb .Write (_fcd );};};_bcd :=_bcb .Sum (nil );if R ==2{_bcd =_bcd [0:5];}else {_bcd =_bcd [0:_fac .Length /8];};return _bcd ;};func _ef (_fc _c .Block )_c .BlockMode {return (*ecbDecrypter )(_gd (_fc ))};func (_cca errInvalidField )Error ()string {return _e .Sprintf ("\u0025s\u003a\u0020e\u0078\u0070\u0065\u0063t\u0065\u0064\u0020%\u0073\u0020\u0066\u0069\u0065\u006c\u0064\u0020\u0074o \u0062\u0065\u0020%\u0064\u0020b\u0079\u0074\u0065\u0073\u002c\u0020g\u006f\u0074 \u0025\u0064",_cca .Func ,_cca .Field ,_cca .Exp ,_cca .Got );};

// Permissions is a bitmask of access permissions for a PDF file.
type Permissions uint32 ;func (_bda stdHandlerR4 )alg5 (_fb []byte ,_cga []byte )([]byte ,error ){_cad :=_afg .New ();_cad .Write ([]byte (_abg ));_cad .Write ([]byte (_bda .ID0 ));_fgg :=_cad .Sum (nil );_aa .Log .Trace ("\u0061\u006c\u0067\u0035");_aa .Log .Trace ("\u0065k\u0065\u0079\u003a\u0020\u0025\u0020x",_fb );_aa .Log .Trace ("\u0049D\u003a\u0020\u0025\u0020\u0078",_bda .ID0 );if len (_fgg )!=16{return nil ,_ge .New ("\u0068a\u0073\u0068\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u006eo\u0074\u0020\u0031\u0036\u0020\u0062\u0079\u0074\u0065\u0073");};_fbb ,_daf :=_ca .NewCipher (_fb );if _daf !=nil {return nil ,_ge .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_ccg :=make ([]byte ,16);_fbb .XORKeyStream (_ccg ,_fgg );_dag :=make ([]byte ,len (_fb ));for _ageg :=0;_ageg < 19;_ageg ++{for _df :=0;_df < len (_fb );_df ++{_dag [_df ]=_fb [_df ]^byte (_ageg +1);};_fbb ,_daf =_ca .NewCipher (_dag );if _daf !=nil {return nil ,_ge .New ("\u0066a\u0069l\u0065\u0064\u0020\u0072\u0063\u0034\u0020\u0063\u0069\u0070\u0068");};_fbb .XORKeyStream (_ccg ,_ccg );_aa .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u002c\u0020\u0065\u006b\u0065\u0079:\u0020\u0025\u0020\u0078",_ageg ,_dag );_aa .Log .Trace ("\u0069\u0020\u003d\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0020\u0078",_ageg ,_ccg );};_gdf :=make ([]byte ,32);for _ecf :=0;_ecf < 16;_ecf ++{_gdf [_ecf ]=_ccg [_ecf ];};_ ,_daf =_af .Read (_gdf [16:32]);if _daf !=nil {return nil ,_ge .New ("\u0066a\u0069\u006c\u0065\u0064 \u0074\u006f\u0020\u0067\u0065n\u0020r\u0061n\u0064\u0020\u006e\u0075\u006d\u0062\u0065r");};return _gdf ,nil ;};const (PermOwner =Permissions (_da .MaxUint32 );PermPrinting =Permissions (1<<2);PermModify =Permissions (1<<3);PermExtractGraphics =Permissions (1<<4);PermAnnotate =Permissions (1<<5);PermFillForms =Permissions (1<<8);PermDisabilityExtract =Permissions (1<<9);PermRotateInsert =Permissions (1<<10);PermFullPrintQuality =Permissions (1<<11););