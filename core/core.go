//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package core defines and implements the primitive PDF object types in golang, and provides functionality
// for parsing those from a PDF file stream. This includes I/O handling, cross references, repairs, encryption,
// encoding and other core capabilities.
package core ;import (_bd "bufio";_fd "bytes";_fa "compress/lzw";_eb "compress/zlib";_gd "crypto/md5";_ac "crypto/rand";_bg "encoding/hex";_g "errors";_be "fmt";_fg "github.com/unidoc/unipdf/v3/common";_bda "github.com/unidoc/unipdf/v3/core/security";_ed "github.com/unidoc/unipdf/v3/core/security/crypt";
_bc "github.com/unidoc/unipdf/v3/internal/ccittfax";_da "github.com/unidoc/unipdf/v3/internal/imageutil";_gg "github.com/unidoc/unipdf/v3/internal/jbig2";_bga "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_ecg "github.com/unidoc/unipdf/v3/internal/jbig2/decoder";
_ef "github.com/unidoc/unipdf/v3/internal/jbig2/document";_bb "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_gf "github.com/unidoc/unipdf/v3/internal/strutils";_de "golang.org/x/image/tiff/lzw";_ec "golang.org/x/xerrors";_fc "image";_e "image/color";
_ee "image/jpeg";_c "io";_ga "reflect";_ab "regexp";_f "sort";_b "strconv";_ff "strings";_ae "sync";_d "time";);const (JB2Generic JBIG2CompressionType =iota ;JB2SymbolCorrelation ;JB2SymbolRankHaus ;);

// UpdateParams updates the parameter values of the encoder.
func (_bcaa *JPXEncoder )UpdateParams (params *PdfObjectDictionary ){};

// IsDecimalDigit checks if the character is a part of a decimal number string.
func IsDecimalDigit (c byte )bool {return '0'<=c &&c <='9'};func (_edcf *FlateEncoder )postDecodePredict (_fabg []byte )([]byte ,error ){if _edcf .Predictor > 1{if _edcf .Predictor ==2{_fg .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");
_fg .Log .Trace ("\u0043\u006f\u006c\u006f\u0072\u0073\u003a\u0020\u0025\u0064",_edcf .Colors );_defgd :=_edcf .Columns *_edcf .Colors ;if _defgd < 1{return []byte {},nil ;};_fbge :=len (_fabg )/_defgd ;if len (_fabg )%_defgd !=0{_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");
return nil ,_be .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_fabg ),_defgd );};if _defgd %_edcf .Colors !=0{return nil ,_be .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_defgd ,_edcf .Colors );
};if _defgd > len (_fabg ){_fg .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_defgd ,len (_fabg ));
return nil ,_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_fg .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_fabg ),_fabg );
_gebg :=_fd .NewBuffer (nil );for _ebe :=0;_ebe < _fbge ;_ebe ++{_abea :=_fabg [_defgd *_ebe :_defgd *(_ebe +1)];for _fbe :=_edcf .Colors ;_fbe < _defgd ;_fbe ++{_abea [_fbe ]+=_abea [_fbe -_edcf .Colors ];};_gebg .Write (_abea );};_ded :=_gebg .Bytes ();
_fg .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_ded ),_ded );return _ded ,nil ;}else if _edcf .Predictor >=10&&_edcf .Predictor <=15{_fg .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");
_aeec :=_edcf .Columns *_edcf .Colors +1;_edcd :=len (_fabg )/_aeec ;if len (_fabg )%_aeec !=0{return nil ,_be .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_fabg ),_aeec );
};if _aeec > len (_fabg ){_fg .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_aeec ,len (_fabg ));
return nil ,_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_cgcf :=_fd .NewBuffer (nil );_fg .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_edcf .Columns );
_fg .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_fabg ),_aeec ,_edcd );_cgd :=make ([]byte ,_aeec );for _dda :=0;_dda < _aeec ;_dda ++{_cgd [_dda ]=0;};_ddce :=_edcf .Colors ;
for _cge :=0;_cge < _edcd ;_cge ++{_afbc :=_fabg [_aeec *_cge :_aeec *(_cge +1)];_dbfde :=_afbc [0];switch _dbfde {case _aace :case _cee :for _gdad :=1+_ddce ;_gdad < _aeec ;_gdad ++{_afbc [_gdad ]+=_afbc [_gdad -_ddce ];};case _defc :for _deg :=1;_deg < _aeec ;
_deg ++{_afbc [_deg ]+=_cgd [_deg ];};case _gcc :for _dcbe :=1;_dcbe < _ddce +1;_dcbe ++{_afbc [_dcbe ]+=_cgd [_dcbe ]/2;};for _bdac :=_ddce +1;_bdac < _aeec ;_bdac ++{_afbc [_bdac ]+=byte ((int (_afbc [_bdac -_ddce ])+int (_cgd [_bdac ]))/2);};case _accd :for _gaed :=1;
_gaed < _aeec ;_gaed ++{var _adc ,_cgg ,_bcca byte ;_cgg =_cgd [_gaed ];if _gaed >=_ddce +1{_adc =_afbc [_gaed -_ddce ];_bcca =_cgd [_gaed -_ddce ];};_afbc [_gaed ]+=_bebf (_adc ,_cgg ,_bcca );};default:_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029\u0020\u0040\u0072o\u0077\u0020\u0025\u0064",_dbfde ,_cge );
return nil ,_be .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_dbfde );};copy (_cgd ,_afbc );_cgcf .Write (_afbc [1:]);};_bdfg :=_cgcf .Bytes ();return _bdfg ,nil ;
}else {_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_edcf .Predictor );return nil ,_be .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_edcf .Predictor );
};};return _fabg ,nil ;};type objectCache map[int ]PdfObject ;

// DecodeBytes decodes a multi-encoded slice of bytes by passing it through the
// DecodeBytes method of the underlying encoders.
func (_ced *MultiEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_acde :=encoded ;var _eagf error ;for _ ,_cdfc :=range _ced ._feab {_fg .Log .Trace ("\u004du\u006c\u0074i\u0020\u0045\u006e\u0063o\u0064\u0065\u0072 \u0044\u0065\u0063\u006f\u0064\u0065\u003a\u0020\u0041pp\u006c\u0079\u0069n\u0067\u0020F\u0069\u006c\u0074\u0065\u0072\u003a \u0025\u0076 \u0025\u0054",_cdfc ,_cdfc );
_acde ,_eagf =_cdfc .DecodeBytes (_acde );if _eagf !=nil {return nil ,_eagf ;};};return _acde ,nil ;};

// NewRawEncoder returns a new instace of RawEncoder.
func NewRawEncoder ()*RawEncoder {return &RawEncoder {}};

// DecodeStream implements ASCII hex decoding.
func (_eggc *ASCIIHexEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _eggc .DecodeBytes (streamObj .Stream );};

// GoImageToJBIG2 creates a binary image on the base of 'i' golang image.Image.
// If the image is not a black/white image then the function converts provided input into
// JBIG2Image with 1bpp. For non grayscale images the function performs the conversion to the grayscale temp image.
// Then it checks the value of the gray image value if it's within bounds of the black white threshold.
// This 'bwThreshold' value should be in range (0.0, 1.0). The threshold checks if the grayscale pixel (uint) value
// is greater or smaller than 'bwThreshold' * 255. Pixels inside the range will be white, and the others will be black.
// If the 'bwThreshold' is equal to -1.0 - JB2ImageAutoThreshold then it's value would be set on the base of
// it's histogram using Triangle method. For more information go to:
// 	https://www.mathworks.com/matlabcentral/fileexchange/28047-gray-image-thresholding-using-the-triangle-method
func GoImageToJBIG2 (i _fc .Image ,bwThreshold float64 )(*JBIG2Image ,error ){const _egbg ="\u0047\u006f\u0049\u006d\u0061\u0067\u0065\u0054\u006fJ\u0042\u0049\u0047\u0032";if i ==nil {return nil ,_bb .Error (_egbg ,"i\u006d\u0061\u0067\u0065 '\u0069'\u0020\u006e\u006f\u0074\u0020d\u0065\u0066\u0069\u006e\u0065\u0064");
};var (_cfe uint8 ;_gcfg _da .Image ;_edfge error ;);if bwThreshold ==JB2ImageAutoThreshold {_gcfg ,_edfge =_da .MonochromeConverter .Convert (i );}else if bwThreshold > 1.0||bwThreshold < 0.0{return nil ,_bb .Error (_egbg ,"p\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074h\u0072\u0065\u0073\u0068\u006f\u006c\u0064 i\u0073\u0020\u006e\u006ft\u0020\u0069\u006e\u0020\u0061\u0020\u0072\u0061\u006ege\u0020\u007b0\u002e\u0030\u002c\u0020\u0031\u002e\u0030\u007d");
}else {_cfe =uint8 (255*bwThreshold );_gcfg ,_edfge =_da .MonochromeThresholdConverter (_cfe ).Convert (i );};if _edfge !=nil {return nil ,_edfge ;};return _efge (_gcfg ),nil ;};

// UpdateParams updates the parameter values of the encoder.
// Implements StreamEncoder interface.
func (_aafe *JBIG2Encoder )UpdateParams (params *PdfObjectDictionary ){_abbc ,_dedf :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _dedf ==nil {_aafe .BitsPerComponent =int (_abbc );
};_fgac ,_dedf :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _dedf ==nil {_aafe .Width =int (_fgac );};_eagc ,_dedf :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _dedf ==nil {_aafe .Height =int (_eagc );
};_gecf ,_dedf :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _dedf ==nil {_aafe .ColorComponents =int (_gecf );};};

// Validate validates the page settings for the JBIG2 encoder.
func (_gaedd JBIG2EncoderSettings )Validate ()error {const _eecg ="\u0076a\u006ci\u0064\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065\u0072";if _gaedd .Threshold < 0||_gaedd .Threshold > 1.0{return _bb .Errorf (_eecg ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074\u0068\u0072\u0065\u0073\u0068\u006f\u006c\u0064\u0020\u0076a\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0076\u0027 \u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0069\u006e\u0020\u0072\u0061n\u0067\u0065\u0020\u005b\u0030\u002e0\u002c\u0020\u0031.\u0030\u005d",_gaedd .Threshold );
};if _gaedd .ResolutionX < 0{return _bb .Errorf (_eecg ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0078\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_gaedd .ResolutionX );
};if _gaedd .ResolutionY < 0{return _bb .Errorf (_eecg ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0079\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_gaedd .ResolutionY );
};if _gaedd .DefaultPixelValue !=0&&_gaedd .DefaultPixelValue !=1{return _bb .Errorf (_eecg ,"de\u0066\u0061u\u006c\u0074\u0020\u0070\u0069\u0078\u0065\u006c\u0020v\u0061\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0066o\u0072 \u0074\u0068\u0065\u0020\u0062\u0069\u0074\u003a \u007b0\u002c\u0031}",_gaedd .DefaultPixelValue );
};if _gaedd .Compression !=JB2Generic {return _bb .Errorf (_eecg ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065d\u0020\u0063\u006fm\u0070\u0072\u0065\u0073s\u0069\u006f\u006e\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
};return nil ;};func (_ecd *PdfCrypt )isDecrypted (_cbf PdfObject )bool {_ ,_bgcf :=_ecd ._ffe [_cbf ];if _bgcf {_fg .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0064\u0065\u0063\u0072y\u0070\u0074\u0065\u0064");return true ;};switch _ccf :=_cbf .(type ){case *PdfObjectStream :if _ecd ._aea .R !=5{if _cae ,_gabc :=_ccf .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );
_gabc &&*_cae =="\u0058\u0052\u0065\u0066"{return true ;};};case *PdfIndirectObject :if _ ,_bgcf =_ecd ._bcg [int (_ccf .ObjectNumber )];_bgcf {return true ;};switch _bece :=_ccf .PdfObject .(type ){case *PdfObjectDictionary :_bef :=true ;for _ ,_bceg :=range _cfae {if _bece .Get (_bceg )==nil {_bef =false ;
break ;};};if _bef {return true ;};};};_fg .Log .Trace ("\u004e\u006f\u0074\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");return false ;};const _baeb ="\u0053\u0074\u0064C\u0046";func _efge (_gdbeb _da .Image )*JBIG2Image {_ffbbe :=_gdbeb .Base ();
return &JBIG2Image {Data :_ffbbe .Data ,Width :_ffbbe .Width ,Height :_ffbbe .Height ,HasPadding :true };};

// DecodeStream decodes a multi-encoded stream by passing it through the
// DecodeStream method of the underlying encoders.
func (_acbe *MultiEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _acbe .DecodeBytes (streamObj .Stream );};

// GetXrefOffset returns the offset of the xref table.
func (_gddc *PdfParser )GetXrefOffset ()int64 {return _gddc ._agba };

// GetFloatVal returns the float64 value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetFloatVal (obj PdfObject )(_cedc float64 ,_cegdg bool ){_fcdfd ,_cegdg :=TraceToDirectObject (obj ).(*PdfObjectFloat );if _cegdg {return float64 (*_fcdfd ),true ;};return 0,false ;};const (_aace =0;_cee =1;_defc =2;_gcc =3;_accd =4;);

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_efb *ASCIIHexEncoder )MakeStreamDict ()*PdfObjectDictionary {_ffdb :=MakeDict ();_ffdb .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_efb .GetFilterName ()));return _ffdb ;};

// GetFilterName returns the name of the encoding filter.
func (_fcb *ASCII85Encoder )GetFilterName ()string {return StreamEncodingFilterNameASCII85 };

// JBIG2EncoderSettings contains the parameters and settings used by the JBIG2Encoder.
// Current version works only on JB2Generic compression.
type JBIG2EncoderSettings struct{

// FileMode defines if the jbig2 encoder should return full jbig2 file instead of
// shortened pdf mode. This adds the file header to the jbig2 definition.
FileMode bool ;

// Compression is the setting that defines the compression type used for encoding the page.
Compression JBIG2CompressionType ;

// DuplicatedLinesRemoval code generic region in a way such that if the lines are duplicated the encoder
// doesn't store it twice.
DuplicatedLinesRemoval bool ;

// DefaultPixelValue is the bit value initial for every pixel in the page.
DefaultPixelValue uint8 ;

// ResolutionX optional setting that defines the 'x' axis input image resolution - used for single page encoding.
ResolutionX int ;

// ResolutionY optional setting that defines the 'y' axis input image resolution - used for single page encoding.
ResolutionY int ;

// Threshold defines the threshold of the image correlation for
// non Generic compression.
// User only for JB2SymbolCorrelation and JB2SymbolRankHaus methods.
// Best results in range [0.7 - 0.98] - the less the better the compression would be
// but the more lossy.
// Default value: 0.95
Threshold float64 ;};

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_dcec *RunLengthEncoder )EncodeBytes (data []byte )([]byte ,error ){_dgcga :=_fd .NewReader (data );var _cacd []byte ;var _cabb []byte ;_eafe ,_bbcf :=_dgcga .ReadByte ();if _bbcf ==_c .EOF {return []byte {},nil ;}else if _bbcf !=nil {return nil ,_bbcf ;
};_dafaa :=1;for {_becef ,_fgd :=_dgcga .ReadByte ();if _fgd ==_c .EOF {break ;}else if _fgd !=nil {return nil ,_fgd ;};if _becef ==_eafe {if len (_cabb )> 0{_cabb =_cabb [:len (_cabb )-1];if len (_cabb )> 0{_cacd =append (_cacd ,byte (len (_cabb )-1));
_cacd =append (_cacd ,_cabb ...);};_dafaa =1;_cabb =[]byte {};};_dafaa ++;if _dafaa >=127{_cacd =append (_cacd ,byte (257-_dafaa ),_eafe );_dafaa =0;};}else {if _dafaa > 0{if _dafaa ==1{_cabb =[]byte {_eafe };}else {_cacd =append (_cacd ,byte (257-_dafaa ),_eafe );
};_dafaa =0;};_cabb =append (_cabb ,_becef );if len (_cabb )>=127{_cacd =append (_cacd ,byte (len (_cabb )-1));_cacd =append (_cacd ,_cabb ...);_cabb =[]byte {};};};_eafe =_becef ;};if len (_cabb )> 0{_cacd =append (_cacd ,byte (len (_cabb )-1));_cacd =append (_cacd ,_cabb ...);
}else if _dafaa > 0{_cacd =append (_cacd ,byte (257-_dafaa ),_eafe );};_cacd =append (_cacd ,128);return _cacd ,nil ;};

// GetFilterName returns the name of the encoding filter.
func (_egaa *LZWEncoder )GetFilterName ()string {return StreamEncodingFilterNameLZW };

// MakeBool creates a PdfObjectBool from a bool value.
func MakeBool (val bool )*PdfObjectBool {_fgdd :=PdfObjectBool (val );return &_fgdd };

// PdfObjectStream represents the primitive PDF Object stream.
type PdfObjectStream struct{PdfObjectReference ;*PdfObjectDictionary ;Stream []byte ;};func (_gaec *PdfObjectInteger )String ()string {return _be .Sprintf ("\u0025\u0064",*_gaec )};

// WriteString outputs the object as it is to be written to file.
func (_adfa *PdfIndirectObject )WriteString ()string {var _gcfga _ff .Builder ;_gcfga .WriteString (_b .FormatInt (_adfa .ObjectNumber ,10));_gcfga .WriteString ("\u0020\u0030\u0020\u0052");return _gcfga .String ();};

// GetFilterName returns the name of the encoding filter.
func (_aacd *FlateEncoder )GetFilterName ()string {return StreamEncodingFilterNameFlate };func (_beba *PdfParser )skipSpaces ()(int ,error ){_cfdc :=0;for {_fedc ,_bdda :=_beba ._eeaf .ReadByte ();if _bdda !=nil {return 0,_bdda ;};if IsWhiteSpace (_fedc ){_cfdc ++;
}else {_beba ._eeaf .UnreadByte ();break ;};};return _cfdc ,nil ;};

// Append appends PdfObject(s) to the array.
func (_abbab *PdfObjectArray )Append (objects ...PdfObject ){if _abbab ==nil {_fg .Log .Debug ("\u0057\u0061\u0072\u006e\u0020\u002d\u0020\u0041\u0074\u0074\u0065\u006d\u0070t\u0020\u0074\u006f\u0020\u0061\u0070p\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020a\u0072\u0072\u0061\u0079");
return ;};_abbab ._eadg =append (_abbab ._eadg ,objects ...);};

// ReadBytesAt reads byte content at specific offset and length within the PDF.
func (_bebc *PdfParser )ReadBytesAt (offset ,len int64 )([]byte ,error ){_ccd :=_bebc .GetFileOffset ();_ ,_ffcae :=_bebc ._cbfb .Seek (offset ,_c .SeekStart );if _ffcae !=nil {return nil ,_ffcae ;};_fdbb :=make ([]byte ,len );_ ,_ffcae =_c .ReadAtLeast (_bebc ._cbfb ,_fdbb ,int (len ));
if _ffcae !=nil {return nil ,_ffcae ;};_bebc .SetFileOffset (_ccd );return _fdbb ,nil ;};type xrefType int ;

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_cga *RawEncoder )MakeDecodeParams ()PdfObject {return nil };

// LookupByNumber looks up a PdfObject by object number.  Returns an error on failure.
func (_dab *PdfParser )LookupByNumber (objNumber int )(PdfObject ,error ){_daeg ,_ ,_dde :=_dab .lookupByNumberWrapper (objNumber ,true );return _daeg ,_dde ;};

// Resolve resolves the reference and returns the indirect or stream object.
// If the reference cannot be resolved, a *PdfObjectNull object is returned.
func (_acfgd *PdfObjectReference )Resolve ()PdfObject {if _acfgd ._eaca ==nil {return MakeNull ();};_agbac ,_ ,_baaab :=_acfgd ._eaca .resolveReference (_acfgd );if _baaab !=nil {_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0072\u0065\u0073\u006f\u006cv\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065r\u0065n\u0063\u0065\u003a\u0020\u0025\u0076\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074",_baaab );
return MakeNull ();};if _agbac ==nil {_fg .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0072\u0065\u0073ol\u0076\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065:\u0020\u006ei\u006c\u0020\u006fb\u006a\u0065\u0063\u0074\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u0061\u0020nu\u006c\u006c\u0020o\u0062\u006a\u0065\u0063\u0074");
return MakeNull ();};return _agbac ;};

// PdfObjectReference represents the primitive PDF reference object.
type PdfObjectReference struct{_eaca *PdfParser ;ObjectNumber int64 ;GenerationNumber int64 ;};

// MakeArray creates an PdfObjectArray from a list of PdfObjects.
func MakeArray (objects ...PdfObject )*PdfObjectArray {return &PdfObjectArray {_eadg :objects }};func (_cfcd *JBIG2Image )toBitmap ()(_ffdeb *_bga .Bitmap ,_edfa error ){const _ecbe ="\u004a\u0042\u0049\u00472I\u006d\u0061\u0067\u0065\u002e\u0074\u006f\u0042\u0069\u0074\u006d\u0061\u0070";
if _cfcd .Data ==nil {return nil ,_bb .Error (_ecbe ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");};if _cfcd .Width ==0||_cfcd .Height ==0{return nil ,_bb .Error (_ecbe ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");
};if _cfcd .HasPadding {_ffdeb ,_edfa =_bga .NewWithData (_cfcd .Width ,_cfcd .Height ,_cfcd .Data );}else {_ffdeb ,_edfa =_bga .NewWithUnpaddedData (_cfcd .Width ,_cfcd .Height ,_cfcd .Data );};if _edfa !=nil {return nil ,_bb .Wrap (_edfa ,_ecbe ,"");
};return _ffdeb ,nil ;};

// GetName returns the *PdfObjectName represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetName (obj PdfObject )(_ebgd *PdfObjectName ,_aabe bool ){_ebgd ,_aabe =TraceToDirectObject (obj ).(*PdfObjectName );return _ebgd ,_aabe ;};

// NewLZWEncoder makes a new LZW encoder with default parameters.
func NewLZWEncoder ()*LZWEncoder {_dafa :=&LZWEncoder {};_dafa .Predictor =1;_dafa .BitsPerComponent =8;_dafa .Colors =1;_dafa .Columns =1;_dafa .EarlyChange =1;return _dafa ;};

// DecodeBytes decodes the CCITTFax encoded image data.
func (_deea *CCITTFaxEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_fecb :=&_bc .Encoder {K :_deea .K ,Columns :_deea .Columns ,EndOfLine :_deea .EndOfLine ,EndOfBlock :_deea .EndOfBlock ,BlackIs1 :_deea .BlackIs1 ,DamagedRowsBeforeError :_deea .DamagedRowsBeforeError ,Rows :_deea .Rows ,EncodedByteAlign :_deea .EncodedByteAlign };
_fbedcf ,_cada :=_fecb .Decode (encoded );if _cada !=nil {return nil ,_cada ;};var _bcee []byte ;_fccg :=0;var _egeg byte ;var _ddgc byte ;for _fcf :=range _fbedcf {if _egeg !=0{_bcee =append (_bcee ,_ddgc );_ddgc =0;_fccg ++;_egeg =0;};for _fed :=range _fbedcf [_fcf ]{_ddgc |=_fbedcf [_fcf ][_fed ]<<(7-_egeg );
_egeg ++;if _egeg ==8{_bcee =append (_bcee ,_ddgc );_ddgc =0;_fccg ++;_egeg =0;};};};if _egeg > 0{_bcee =append (_bcee ,_ddgc );};return _bcee ,nil ;};

// ToFloat64Array returns a slice of all elements in the array as a float64 slice.  An error is
// returned if the array contains non-numeric objects (each element can be either PdfObjectInteger
// or PdfObjectFloat).
func (_eab *PdfObjectArray )ToFloat64Array ()([]float64 ,error ){var _gffg []float64 ;for _ ,_edgc :=range _eab .Elements (){switch _ebdcg :=_edgc .(type ){case *PdfObjectInteger :_gffg =append (_gffg ,float64 (*_ebdcg ));case *PdfObjectFloat :_gffg =append (_gffg ,float64 (*_ebdcg ));
default:return nil ,ErrTypeError ;};};return _gffg ,nil ;};

// Merge merges in key/values from another dictionary. Overwriting if has same keys.
// The mutated dictionary (d) is returned in order to allow method chaining.
func (_cfeg *PdfObjectDictionary )Merge (another *PdfObjectDictionary )*PdfObjectDictionary {if another !=nil {for _ ,_edfcb :=range another .Keys (){_acbg :=another .Get (_edfcb );_cfeg .Set (_edfcb ,_acbg );};};return _cfeg ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set.  Some other parameters are generated elsewhere.
func (_ccadd *DCTEncoder )MakeStreamDict ()*PdfObjectDictionary {_aadg :=MakeDict ();_aadg .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_ccadd .GetFilterName ()));return _aadg ;};

// GetFilterName returns the name of the encoding filter.
func (_afbf *ASCIIHexEncoder )GetFilterName ()string {return StreamEncodingFilterNameASCIIHex };

// GetFilterName returns the name of the encoding filter.
func (_ege *CCITTFaxEncoder )GetFilterName ()string {return StreamEncodingFilterNameCCITTFax };

// DecodeStream decodes a JBIG2 encoded stream and returns the result as a slice of bytes.
func (_adcc *JBIG2Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _adcc .DecodeBytes (streamObj .Stream );};

// SetIfNotNil sets the dictionary's key -> val mapping entry -IF- val is not nil.
// Note that we take care to perform a type switch.  Otherwise if we would supply a nil value
// of another type, e.g. (PdfObjectArray*)(nil), then it would not be a PdfObject(nil) and thus
// would get set.
func (_cgdd *PdfObjectDictionary )SetIfNotNil (key PdfObjectName ,val PdfObject ){if val !=nil {switch _dedcd :=val .(type ){case *PdfObjectName :if _dedcd !=nil {_cgdd .Set (key ,val );};case *PdfObjectDictionary :if _dedcd !=nil {_cgdd .Set (key ,val );
};case *PdfObjectStream :if _dedcd !=nil {_cgdd .Set (key ,val );};case *PdfObjectString :if _dedcd !=nil {_cgdd .Set (key ,val );};case *PdfObjectNull :if _dedcd !=nil {_cgdd .Set (key ,val );};case *PdfObjectInteger :if _dedcd !=nil {_cgdd .Set (key ,val );
};case *PdfObjectArray :if _dedcd !=nil {_cgdd .Set (key ,val );};case *PdfObjectBool :if _dedcd !=nil {_cgdd .Set (key ,val );};case *PdfObjectFloat :if _dedcd !=nil {_cgdd .Set (key ,val );};case *PdfObjectReference :if _dedcd !=nil {_cgdd .Set (key ,val );
};case *PdfIndirectObject :if _dedcd !=nil {_cgdd .Set (key ,val );};default:_fg .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",val );
};};};

// TraceToDirectObject traces a PdfObject to a direct object.  For example direct objects contained
// in indirect objects (can be double referenced even).
func TraceToDirectObject (obj PdfObject )PdfObject {if _dacg ,_bddgg :=obj .(*PdfObjectReference );_bddgg {obj =_dacg .Resolve ();};_fdbd ,_afce :=obj .(*PdfIndirectObject );_eccf :=0;for _afce {obj =_fdbd .PdfObject ;_fdbd ,_afce =GetIndirect (obj );_eccf ++;
if _eccf > _ddgf {_fg .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0072\u0061\u0063\u0065\u0020\u0064\u0065p\u0074\u0068\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u0062\u0065\u0079\u006fn\u0064\u0020\u0025\u0064\u0020\u002d\u0020\u006e\u006f\u0074\u0020\u0067oi\u006e\u0067\u0020\u0064\u0065\u0065\u0070\u0065\u0072\u0021",_ddgf );
return nil ;};};return obj ;};

// JBIG2Image is the image structure used by the jbig2 encoder. Its Data must be in a
// 1 bit per component and 1 component per pixel (1bpp). In order to create binary image
// use GoImageToJBIG2 function. If the image data contains the row bytes padding set the HasPadding to true.
type JBIG2Image struct{

// Width and Height defines the image boundaries.
Width ,Height int ;

// Data is the byte slice data for the input image
Data []byte ;

// HasPadding is the attribute that defines if the last byte of the data in the row contains
// 0 bits padding.
HasPadding bool ;};const (DefaultJPEGQuality =75;);

// GetTrailer returns the PDFs trailer dictionary. The trailer dictionary is typically the starting point for a PDF,
// referencing other key objects that are important in the document structure.
func (_fddda *PdfParser )GetTrailer ()*PdfObjectDictionary {return _fddda ._eaaa };func (_gcgd *PdfCrypt )authenticate (_ecc []byte )(bool ,error ){_gcgd ._eeb =false ;_gfb :=_gcgd .securityHandler ();_fec ,_gfec ,_bac :=_gfb .Authenticate (&_gcgd ._aea ,_ecc );
if _bac !=nil {return false ,_bac ;}else if _gfec ==0||len (_fec )==0{return false ,nil ;};_gcgd ._eeb =true ;_gcgd ._cec =_fec ;return true ,nil ;};

// RawEncoder implements Raw encoder/decoder (no encoding, pass through)
type RawEncoder struct{};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_bcef *RunLengthEncoder )MakeStreamDict ()*PdfObjectDictionary {_bgbf :=MakeDict ();_bgbf .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_bcef .GetFilterName ()));return _bgbf ;};

// NewParserFromString is used for testing purposes.
func NewParserFromString (txt string )*PdfParser {_ebgg :=_fd .NewReader ([]byte (txt ));_feaag :=&PdfParser {ObjCache :objectCache {},_cbfb :_ebgg ,_eeaf :_bd .NewReader (_ebgg ),_eecc :int64 (len (txt )),_abec :map[int64 ]bool {}};_feaag ._dfb .ObjectMap =make (map[int ]XrefObject );
return _feaag ;};

// UpdateParams updates the parameter values of the encoder.
func (_cbd *ASCII85Encoder )UpdateParams (params *PdfObjectDictionary ){};var _bcgc =_ab .MustCompile ("\u0025P\u0044F\u002d\u0028\u005c\u0064\u0029\u005c\u002e\u0028\u005c\u0064\u0029");func (_aed *PdfCrypt )makeKey (_dec string ,_cafc ,_adg uint32 ,_abc []byte )([]byte ,error ){_edc ,_aag :=_aed ._egg [_dec ];
if !_aag {return nil ,_be .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_dec );};return _edc .MakeKey (_cafc ,_adg ,_abc );};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_dcb *FlateEncoder )MakeStreamDict ()*PdfObjectDictionary {_dcfb :=MakeDict ();_dcfb .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_dcb .GetFilterName ()));_aeef :=_dcb .MakeDecodeParams ();if _aeef !=nil {_dcfb .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_aeef );
};return _dcfb ;};

// WriteString outputs the object as it is to be written to file.
func (_cagd *PdfObjectNull )WriteString ()string {return "\u006e\u0075\u006c\u006c"};func _cedb (_egfb *PdfObjectStream ,_fcdgd *PdfObjectDictionary )(*JBIG2Encoder ,error ){const _cbcgg ="\u006ee\u0077\u004a\u0042\u0049G\u0032\u0044\u0065\u0063\u006fd\u0065r\u0046r\u006f\u006d\u0053\u0074\u0072\u0065\u0061m";
_gfecg :=NewJBIG2Encoder ();_fda :=_egfb .PdfObjectDictionary ;if _fda ==nil {return _gfecg ,nil ;};if _fcdgd ==nil {_ecgd :=_fda .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _ecgd !=nil {switch _fggcc :=_ecgd .(type ){case *PdfObjectDictionary :_fcdgd =_fggcc ;
case *PdfObjectArray :if _fggcc .Len ()==1{if _gcdb ,_fccgc :=GetDict (_fggcc .Get (0));_fccgc {_fcdgd =_gcdb ;};};default:_fg .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065P\u0061\u0072\u0061\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064i\u0063\u0074\u0069\u006f\u006e\u0061\u0072y\u0020\u0025\u0023\u0076",_ecgd );
return nil ,_bb .Errorf (_cbcgg ,"\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050a\u0072m\u0073\u0020\u0074\u0079\u0070\u0065\u003a \u0025\u0054",_fggcc );};};};if _fcdgd ==nil {return _gfecg ,nil ;};_gfecg .UpdateParams (_fcdgd );
_bfg ,_eadb :=GetStream (_fcdgd .Get ("\u004a\u0042\u0049G\u0032\u0047\u006c\u006f\u0062\u0061\u006c\u0073"));if !_eadb {return _gfecg ,nil ;};var _fcgea error ;_gfecg .Globals ,_fcgea =_gg .DecodeGlobals (_bfg .Stream );if _fcgea !=nil {_fcgea =_bb .Wrap (_fcgea ,_cbcgg ,"\u0063\u006f\u0072\u0072u\u0070\u0074\u0065\u0064\u0020\u006a\u0062\u0069\u0067\u0032 \u0065n\u0063\u006f\u0064\u0065\u0064\u0020\u0064a\u0074\u0061");
_fg .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_fcgea );return nil ,_fcgea ;};return _gfecg ,nil ;};

// PdfParser parses a PDF file and provides access to the object structure of the PDF.
type PdfParser struct{_ggaca Version ;_cbfb _c .ReadSeeker ;_eeaf *_bd .Reader ;_eecc int64 ;_dfb XrefTable ;_agba int64 ;_acfg *xrefType ;_egfg objectStreams ;_eaaa *PdfObjectDictionary ;_ggab *PdfCrypt ;_cceg bool ;ObjCache objectCache ;_gbaa map[int ]bool ;
_abec map[int64 ]bool ;};

// DecodeBytes decodes a byte slice from Run length encoding.
//
// 7.4.5 RunLengthDecode Filter
// The RunLengthDecode filter decodes data that has been encoded in a simple byte-oriented format based on run length.
// The encoded data shall be a sequence of runs, where each run shall consist of a length byte followed by 1 to 128
// bytes of data. If the length byte is in the range 0 to 127, the following length + 1 (1 to 128) bytes shall be
// copied literally during decompression. If length is in the range 129 to 255, the following single byte shall be
// copied 257 - length (2 to 128) times during decompression. A length value of 128 shall denote EOD.
func (_eafg *RunLengthEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_bdcc :=_fd .NewReader (encoded );var _ffdf []byte ;for {_aca ,_fbcd :=_bdcc .ReadByte ();if _fbcd !=nil {return nil ,_fbcd ;};if _aca > 128{_dbge ,_gdfc :=_bdcc .ReadByte ();
if _gdfc !=nil {return nil ,_gdfc ;};for _ebaf :=0;_ebaf < 257-int (_aca );_ebaf ++{_ffdf =append (_ffdf ,_dbge );};}else if _aca < 128{for _gdbe :=0;_gdbe < int (_aca )+1;_gdbe ++{_cfb ,_bcdc :=_bdcc .ReadByte ();if _bcdc !=nil {return nil ,_bcdc ;};_ffdf =append (_ffdf ,_cfb );
};}else {break ;};};return _ffdf ,nil ;};

// String returns a string describing `stream`.
func (_fabgf *PdfObjectStream )String ()string {return _be .Sprintf ("O\u0062j\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0025\u0064: \u0025\u0073",_fabgf .ObjectNumber ,_fabgf .PdfObjectDictionary );};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_bbff *JBIG2Encoder )MakeStreamDict ()*PdfObjectDictionary {_aage :=MakeDict ();_aage .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_bbff .GetFilterName ()));return _aage ;};

// StreamEncoder represents the interface for all PDF stream encoders.
type StreamEncoder interface{GetFilterName ()string ;MakeDecodeParams ()PdfObject ;MakeStreamDict ()*PdfObjectDictionary ;UpdateParams (_bdfee *PdfObjectDictionary );EncodeBytes (_fbc []byte )([]byte ,error );DecodeBytes (_gaff []byte )([]byte ,error );
DecodeStream (_bgab *PdfObjectStream )([]byte ,error );};

// SetPredictor sets the predictor function.  Specify the number of columns per row.
// The columns indicates the number of samples per row.
// Used for grouping data together for compression.
func (_eaa *FlateEncoder )SetPredictor (columns int ){_eaa .Predictor =11;_eaa .Columns =columns };

// Get returns the i-th element of the array or nil if out of bounds (by index).
func (_gdbc *PdfObjectArray )Get (i int )PdfObject {if _gdbc ==nil ||i >=len (_gdbc ._eadg )||i < 0{return nil ;};return _gdbc ._eadg [i ];};

// DecodeStream decodes the stream containing CCITTFax encoded image data.
func (_bbfba *CCITTFaxEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _bbfba .DecodeBytes (streamObj .Stream );};

// DecodeBytes decodes a slice of ASCII encoded bytes and returns the result.
func (_ddg *ASCIIHexEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_gdff :=_fd .NewReader (encoded );var _cagg []byte ;for {_ecfa ,_gffc :=_gdff .ReadByte ();if _gffc !=nil {return nil ,_gffc ;};if _ecfa =='>'{break ;};if IsWhiteSpace (_ecfa ){continue ;
};if (_ecfa >='a'&&_ecfa <='f')||(_ecfa >='A'&&_ecfa <='F')||(_ecfa >='0'&&_ecfa <='9'){_cagg =append (_cagg ,_ecfa );}else {_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0061\u0073\u0063\u0069\u0069 \u0068\u0065\u0078\u0020\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072 \u0028\u0025\u0063\u0029",_ecfa );
return nil ,_be .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0061\u0073\u0063\u0069\u0069\u0020\u0068e\u0078 \u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u0020\u0028\u0025\u0063\u0029",_ecfa );};};if len (_cagg )%2==1{_cagg =append (_cagg ,'0');
};_fg .Log .Trace ("\u0049\u006e\u0062\u006f\u0075\u006e\u0064\u0020\u0025\u0073",_cagg );_bgbg :=make ([]byte ,_bg .DecodedLen (len (_cagg )));_ ,_gdbf :=_bg .Decode (_bgbg ,_cagg );if _gdbf !=nil {return nil ,_gdbf ;};return _bgbg ,nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_acgb *LZWEncoder )UpdateParams (params *PdfObjectDictionary ){_fgg ,_bdacd :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _bdacd ==nil {_acgb .Predictor =int (_fgg );};_ggcf ,_bdacd :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));
if _bdacd ==nil {_acgb .BitsPerComponent =int (_ggcf );};_bdfc ,_bdacd :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _bdacd ==nil {_acgb .Columns =int (_bdfc );};_eba ,_bdacd :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));
if _bdacd ==nil {_acgb .Colors =int (_eba );};_fddd ,_bdacd :=GetNumberAsInt64 (params .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065"));if _bdacd ==nil {_acgb .EarlyChange =int (_fddd );};};

// UpdateParams updates the parameter values of the encoder.
func (_dfdc *CCITTFaxEncoder )UpdateParams (params *PdfObjectDictionary ){if _bgcfg ,_feca :=GetNumberAsInt64 (params .Get ("\u004b"));_feca ==nil {_dfdc .K =int (_bgcfg );};if _cbfa ,_cege :=GetNumberAsInt64 (params .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));
_cege ==nil {_dfdc .Columns =int (_cbfa );}else if _cbfa ,_cege =GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));_cege ==nil {_dfdc .Columns =int (_cbfa );};if _fee ,_fgge :=GetNumberAsInt64 (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));
_fgge ==nil {_dfdc .BlackIs1 =_fee > 0;}else {if _adcb ,_adf :=GetBoolVal (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_adf {_dfdc .BlackIs1 =_adcb ;}else {if _eadf ,_bfcd :=GetArray (params .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));
_bfcd {_dbe ,_bdca :=_eadf .ToIntegerArray ();if _bdca ==nil {_dfdc .BlackIs1 =_dbe [0]==1&&_dbe [1]==0;};};};};if _dfcb ,_fcde :=GetNumberAsInt64 (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));
_fcde ==nil {_dfdc .EncodedByteAlign =_dfcb > 0;}else {if _badf ,_adcg :=GetBoolVal (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_adcg {_dfdc .EncodedByteAlign =_badf ;};};if _daba ,_dcbb :=GetNumberAsInt64 (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));
_dcbb ==nil {_dfdc .EndOfLine =_daba > 0;}else {if _adga ,_eeca :=GetBoolVal (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_eeca {_dfdc .EndOfLine =_adga ;};};if _aagb ,_fgcd :=GetNumberAsInt64 (params .Get ("\u0052\u006f\u0077\u0073"));
_fgcd ==nil {_dfdc .Rows =int (_aagb );}else if _aagb ,_fgcd =GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));_fgcd ==nil {_dfdc .Rows =int (_aagb );};if _fbedc ,_gbda :=GetNumberAsInt64 (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));
_gbda ==nil {_dfdc .EndOfBlock =_fbedc > 0;}else {if _feaa ,_agd :=GetBoolVal (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_agd {_dfdc .EndOfBlock =_feaa ;};};if _cega ,_eaac :=GetNumberAsInt64 (params .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));
_eaac !=nil {_dfdc .DamagedRowsBeforeError =int (_cega );};};

// ToInt64Slice returns a slice of all array elements as an int64 slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_acfd *PdfObjectArray )ToInt64Slice ()([]int64 ,error ){var _acee []int64 ;for _ ,_daaf :=range _acfd .Elements (){if _degb ,_dgbbb :=_daaf .(*PdfObjectInteger );_dgbbb {_acee =append (_acee ,int64 (*_degb ));}else {return nil ,ErrTypeError ;};};
return _acee ,nil ;};

// String returns a string describing `d`.
func (_geaed *PdfObjectDictionary )String ()string {var _gbbe _ff .Builder ;_gbbe .WriteString ("\u0044\u0069\u0063t\u0028");for _ ,_eace :=range _geaed ._cabe {_cfaag :=_geaed ._ggbc [_eace ];_gbbe .WriteString ("\u0022"+_eace .String ()+"\u0022\u003a\u0020");
_gbbe .WriteString (_cfaag .String ());_gbbe .WriteString ("\u002c\u0020");};_gbbe .WriteString ("\u0029");return _gbbe .String ();};

// GetStringBytes is like GetStringVal except that it returns the string as a []byte.
// It is for convenience.
func GetStringBytes (obj PdfObject )(_cced []byte ,_gbbee bool ){_dbebe ,_gbbee :=TraceToDirectObject (obj ).(*PdfObjectString );if _gbbee {return _dbebe .Bytes (),true ;};return ;};

// Append appends PdfObject(s) to the streams.
func (_cfca *PdfObjectStreams )Append (objects ...PdfObject ){if _cfca ==nil {_fg .Log .Debug ("\u0057\u0061\u0072\u006e\u0020-\u0020\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0020\u0074\u006f\u0020\u0061p\u0070\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0073");
return ;};_cfca ._aebba =append (_cfca ._aebba ,objects ...);};func (_gbf *PdfParser )readTextLine ()(string ,error ){var _aeeb _fd .Buffer ;for {_befa ,_deac :=_gbf ._eeaf .Peek (1);if _deac !=nil {_fg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_deac .Error ());
return _aeeb .String (),_deac ;};if (_befa [0]!='\r')&&(_befa [0]!='\n'){_gfbf ,_ :=_gbf ._eeaf .ReadByte ();_aeeb .WriteByte (_gfbf );}else {break ;};};return _aeeb .String (),nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_bgfd *RawEncoder )UpdateParams (params *PdfObjectDictionary ){};func (_fgcf *ASCII85Encoder )base256Tobase85 (_fde uint32 )[5]byte {_faaf :=[5]byte {0,0,0,0,0};_gbge :=_fde ;for _aaf :=0;_aaf < 5;_aaf ++{_bbdg :=uint32 (1);for _afefb :=0;_afefb < 4-_aaf ;
_afefb ++{_bbdg *=85;};_gefb :=_gbge /_bbdg ;_gbge =_gbge %_bbdg ;_faaf [_aaf ]=byte (_gefb );};return _faaf ;};

// GetXrefType returns the type of the first xref object (table or stream).
func (_egga *PdfParser )GetXrefType ()*xrefType {return _egga ._acfg };

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_dade *MultiEncoder )MakeDecodeParams ()PdfObject {if len (_dade ._feab )==0{return nil ;};if len (_dade ._feab )==1{return _dade ._feab [0].MakeDecodeParams ();};_ggac :=MakeArray ();for _ ,_bdea :=range _dade ._feab {_cffg :=_bdea .MakeDecodeParams ();
if _cffg ==nil {_ggac .Append (MakeNull ());}else {_ggac .Append (_cffg );};};return _ggac ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_ceeg *CCITTFaxEncoder )MakeStreamDict ()*PdfObjectDictionary {_bage :=MakeDict ();_bage .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_ceeg .GetFilterName ()));_faac :=_ceeg .MakeDecodeParams ();if _faac !=nil {_bage .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_faac );
};return _bage ;};func (_eacg *PdfParser )xrefNextObjectOffset (_caed int64 )int64 {_abcb :=int64 (0);if len (_eacg ._dfb .ObjectMap )==0{return 0;};if len (_eacg ._dfb ._cc )==0{_ccaa :=0;for _ ,_fddf :=range _eacg ._dfb .ObjectMap {if _fddf .Offset > 0{_ccaa ++;
};};if _ccaa ==0{return 0;};_eacg ._dfb ._cc =make ([]XrefObject ,_ccaa );_dfgag :=0;for _ ,_eeee :=range _eacg ._dfb .ObjectMap {if _eeee .Offset > 0{_eacg ._dfb ._cc [_dfgag ]=_eeee ;_dfgag ++;};};_f .Slice (_eacg ._dfb ._cc ,func (_dcge ,_egac int )bool {return _eacg ._dfb ._cc [_dcge ].Offset < _eacg ._dfb ._cc [_egac ].Offset });
};_accdg :=_f .Search (len (_eacg ._dfb ._cc ),func (_adab int )bool {return _eacg ._dfb ._cc [_adab ].Offset >=_caed });if _accdg < len (_eacg ._dfb ._cc ){_abcb =_eacg ._dfb ._cc [_accdg ].Offset ;};return _abcb ;};func _geg (_cdea *_ed .FilterDict ,_fca *PdfObjectDictionary )error {if _age ,_ada :=_fca .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );
_ada {if _ece :=string (*_age );_ece !="C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"{_fg .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020C\u0046\u0020\u0064ic\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074e\u0072\u0029",_ece );
};};_gab ,_fef :=_fca .Get ("\u0043\u0046\u004d").(*PdfObjectName );if !_fef {return _be .Errorf ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0028\u004e\u006f\u006e\u0065\u0029");
};_cdea .CFM =string (*_gab );if _fba ,_cdg :=_fca .Get ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et").(*PdfObjectName );_cdg {_cdea .AuthEvent =_bda .AuthEvent (*_fba );}else {_cdea .AuthEvent =_bda .EventDocOpen ;};if _cb ,_dfee :=_fca .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );
_dfee {_cdea .Length =int (*_cb );};return nil ;};func (_agbcb *PdfParser )parseBool ()(PdfObjectBool ,error ){_fggf ,_gcaa :=_agbcb ._eeaf .Peek (4);if _gcaa !=nil {return PdfObjectBool (false ),_gcaa ;};if (len (_fggf )>=4)&&(string (_fggf [:4])=="\u0074\u0072\u0075\u0065"){_agbcb ._eeaf .Discard (4);
return PdfObjectBool (true ),nil ;};_fggf ,_gcaa =_agbcb ._eeaf .Peek (5);if _gcaa !=nil {return PdfObjectBool (false ),_gcaa ;};if (len (_fggf )>=5)&&(string (_fggf [:5])=="\u0066\u0061\u006cs\u0065"){_agbcb ._eeaf .Discard (5);return PdfObjectBool (false ),nil ;
};return PdfObjectBool (false ),_g .New ("\u0075n\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0062o\u006fl\u0065a\u006e\u0020\u0073\u0074\u0072\u0069\u006eg");};func (_cebec *PdfObjectFloat )String ()string {return _be .Sprintf ("\u0025\u0066",*_cebec )};
var _ffce =_ab .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064\u002b)\u005c\u0073\u002a\u0024");func (_gbef *PdfParser )resolveReference (_bbef *PdfObjectReference )(PdfObject ,bool ,error ){_ffdfd ,_cgdf :=_gbef .ObjCache [int (_bbef .ObjectNumber )];
if _cgdf {return _ffdfd ,true ,nil ;};_adcd ,_bcaf :=_gbef .LookupByReference (*_bbef );if _bcaf !=nil {return nil ,false ,_bcaf ;};_gbef .ObjCache [int (_bbef .ObjectNumber )]=_adcd ;return _adcd ,false ,nil ;};

// MakeFloat creates an PdfObjectFloat from a float64.
func MakeFloat (val float64 )*PdfObjectFloat {_ccgd :=PdfObjectFloat (val );return &_ccgd };var _dgbd =_ab .MustCompile ("\u0028\u005c\u0064\u002b)\\\u0073\u002b\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u006f\u0062\u006a");

// GetIndirect returns the *PdfIndirectObject represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetIndirect (obj PdfObject )(_fgggc *PdfIndirectObject ,_bacb bool ){obj =ResolveReference (obj );_fgggc ,_bacb =obj .(*PdfIndirectObject );return _fgggc ,_bacb ;};

// Encode encodes previously prepare jbig2 document and stores it as the byte slice.
func (_fabc *JBIG2Encoder )Encode ()(_fbba []byte ,_egf error ){const _ggf ="J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0045\u006eco\u0064\u0065";if _fabc ._bfdf ==nil {return nil ,_bb .Errorf (_ggf ,"\u0064\u006f\u0063u\u006d\u0065\u006e\u0074 \u0069\u006e\u0070\u0075\u0074\u0020\u0064a\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006e\u0065\u0064");
};_fabc ._bfdf .FullHeaders =_fabc .DefaultPageSettings .FileMode ;_fbba ,_egf =_fabc ._bfdf .Encode ();if _egf !=nil {return nil ,_bb .Wrap (_egf ,_ggf ,"");};return _fbba ,nil ;};

// GetCrypter returns the PdfCrypt instance which has information about the PDFs encryption.
func (_cfge *PdfParser )GetCrypter ()*PdfCrypt {return _cfge ._ggab };

// GetIntVal returns the int value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetIntVal (obj PdfObject )(_cggeb int ,_fddab bool ){_cfbg ,_fddab :=TraceToDirectObject (obj ).(*PdfObjectInteger );if _fddab &&_cfbg !=nil {return int (*_cfbg ),true ;};return 0,false ;};

// NewEncoderFromStream creates a StreamEncoder based on the stream's dictionary.
func NewEncoderFromStream (streamObj *PdfObjectStream )(StreamEncoder ,error ){_acfb :=TraceToDirectObject (streamObj .PdfObjectDictionary .Get ("\u0046\u0069\u006c\u0074\u0065\u0072"));if _acfb ==nil {return NewRawEncoder (),nil ;};if _ ,_dcbfe :=_acfb .(*PdfObjectNull );
_dcbfe {return NewRawEncoder (),nil ;};_cbed ,_addf :=_acfb .(*PdfObjectName );if !_addf {_egdf ,_bfge :=_acfb .(*PdfObjectArray );if !_bfge {return nil ,_be .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006f\u0072 \u0041\u0072\u0072\u0061\u0079\u0020\u006fb\u006a\u0065\u0063\u0074");
};if _egdf .Len ()==0{return NewRawEncoder (),nil ;};if _egdf .Len ()!=1{_bfeg ,_gfef :=_cecf (streamObj );if _gfef !=nil {_fg .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0063\u0072\u0065\u0061\u0074\u0069\u006e\u0067\u0020\u006d\u0075\u006c\u0074i\u0020\u0065\u006e\u0063\u006f\u0064\u0065r\u003a\u0020\u0025\u0076",_gfef );
return nil ,_gfef ;};_fg .Log .Trace ("\u004d\u0075\u006c\u0074\u0069\u0020\u0065\u006e\u0063:\u0020\u0025\u0073\u000a",_bfeg );return _bfeg ,nil ;};_acfb =_egdf .Get (0);_cbed ,_bfge =_acfb .(*PdfObjectName );if !_bfge {return nil ,_be .Errorf ("\u0066\u0069l\u0074\u0065\u0072\u0020a\u0072\u0072a\u0079\u0020\u006d\u0065\u006d\u0062\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006fb\u006a\u0065\u0063\u0074");
};};if _aedb ,_ecaf :=_cfbdb .Load (_cbed .String ());_ecaf {return _aedb .(StreamEncoder ),nil ;};switch *_cbed {case StreamEncodingFilterNameFlate :return _eaga (streamObj ,nil );case StreamEncodingFilterNameLZW :return _gegd (streamObj ,nil );case StreamEncodingFilterNameDCT :return _gad (streamObj ,nil );
case StreamEncodingFilterNameRunLength :return _efga (streamObj ,nil );case StreamEncodingFilterNameASCIIHex :return NewASCIIHexEncoder (),nil ;case StreamEncodingFilterNameASCII85 ,"\u0041\u0038\u0035":return NewASCII85Encoder (),nil ;case StreamEncodingFilterNameCCITTFax :return _dcdc (streamObj ,nil );
case StreamEncodingFilterNameJBIG2 :return _cedb (streamObj ,nil );case StreamEncodingFilterNameJPX :return NewJPXEncoder (),nil ;};_fg .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064\u0069\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006fd\u0021");
return nil ,_be .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064i\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006f\u0064\u0020\u0028\u0025\u0073\u0029",*_cbed );};

// GetFloat returns the *PdfObjectFloat represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetFloat (obj PdfObject )(_dfce *PdfObjectFloat ,_aecc bool ){_dfce ,_aecc =TraceToDirectObject (obj ).(*PdfObjectFloat );return _dfce ,_aecc ;};

// String returns a string describing `array`.
func (_beea *PdfObjectArray )String ()string {_gccag :="\u005b";for _eged ,_bdacb :=range _beea .Elements (){_gccag +=_bdacb .String ();if _eged < (_beea .Len ()-1){_gccag +="\u002c\u0020";};};_gccag +="\u005d";return _gccag ;};

// PdfCryptNewEncrypt makes the document crypt handler based on a specified crypt filter.
func PdfCryptNewEncrypt (cf _ed .Filter ,userPass ,ownerPass []byte ,perm _bda .Permissions )(*PdfCrypt ,*EncryptInfo ,error ){_bae :=&PdfCrypt {_bbba :make (map[PdfObject ]bool ),_egg :make (cryptFilters ),_aea :_bda .StdEncryptDict {P :perm ,EncryptMetadata :true }};
var _dgcb Version ;if cf !=nil {_gcb :=cf .PDFVersion ();_dgcb .Major ,_dgcb .Minor =_gcb [0],_gcb [1];V ,R :=cf .HandlerVersion ();_bae ._baf .V =V ;_bae ._aea .R =R ;_bae ._baf .Length =cf .KeyLength ()*8;};const (_edf =_baeb ;);_bae ._egg [_edf ]=cf ;
if _bae ._baf .V >=4{_bae ._ebg =_edf ;_bae ._dcf =_edf ;};_dabg :=_bae .newEncryptDict ();_bcb :=_gd .Sum ([]byte (_d .Now ().Format (_d .RFC850 )));_ddc :=string (_bcb [:]);_ccb :=make ([]byte ,100);_ac .Read (_ccb );_bcb =_gd .Sum (_ccb );_edfc :=string (_bcb [:]);
_fg .Log .Trace ("\u0052\u0061\u006e\u0064\u006f\u006d\u0020\u0062\u003a\u0020\u0025\u0020\u0078",_ccb );_fg .Log .Trace ("\u0047\u0065\u006e\u0020\u0049\u0064\u0020\u0030\u003a\u0020\u0025\u0020\u0078",_ddc );_bae ._bdad =_ddc ;_gea :=_bae .generateParams (userPass ,ownerPass );
if _gea !=nil {return nil ,nil ,_gea ;};_dcd (&_bae ._aea ,_dabg );if _bae ._baf .V >=4{if _agbc :=_bae .saveCryptFilters (_dabg );_agbc !=nil {return nil ,nil ,_agbc ;};};return _bae ,&EncryptInfo {Version :_dgcb ,Encrypt :_dabg ,ID0 :_ddc ,ID1 :_edfc },nil ;
};

// MakeNull creates an PdfObjectNull.
func MakeNull ()*PdfObjectNull {_gbffa :=PdfObjectNull {};return &_gbffa };

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_ggg *FlateEncoder )MakeDecodeParams ()PdfObject {if _ggg .Predictor > 1{_abg :=MakeDict ();_abg .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_ggg .Predictor )));if _ggg .BitsPerComponent !=8{_abg .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_ggg .BitsPerComponent )));
};if _ggg .Columns !=1{_abg .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_ggg .Columns )));};if _ggg .Colors !=1{_abg .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_ggg .Colors )));};return _abg ;};return nil ;};


// UpdateParams updates the parameter values of the encoder.
func (_fgda *RunLengthEncoder )UpdateParams (params *PdfObjectDictionary ){};

// Remove removes an element specified by key.
func (_bafg *PdfObjectDictionary )Remove (key PdfObjectName ){_cegb :=-1;for _cecda ,_acaf :=range _bafg ._cabe {if _acaf ==key {_cegb =_cecda ;break ;};};if _cegb >=0{_bafg ._cabe =append (_bafg ._cabe [:_cegb ],_bafg ._cabe [_cegb +1:]...);delete (_bafg ._ggbc ,key );
};};

// Inspect analyzes the document object structure. Returns a map of object types (by name) with the instance count
// as value.
func (_ccbea *PdfParser )Inspect ()(map[string ]int ,error ){return _ccbea .inspect ()};func _ca (_bdb PdfObject )(int64 ,int64 ,error ){if _bggd ,_dfa :=_bdb .(*PdfIndirectObject );_dfa {return _bggd .ObjectNumber ,_bggd .GenerationNumber ,nil ;};if _faa ,_dfd :=_bdb .(*PdfObjectStream );
_dfd {return _faa .ObjectNumber ,_faa .GenerationNumber ,nil ;};return 0,0,_g .New ("\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u002f\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062je\u0063\u0074");};

// GetNameVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetNameVal (obj PdfObject )(_dabea string ,_bbda bool ){_cgdbc ,_bbda :=TraceToDirectObject (obj ).(*PdfObjectName );if _bbda {return string (*_cgdbc ),true ;};return ;};func _gad (_beefg *PdfObjectStream ,_dedg *MultiEncoder )(*DCTEncoder ,error ){_ggb :=NewDCTEncoder ();
_gabg :=_beefg .PdfObjectDictionary ;if _gabg ==nil {return _ggb ,nil ;};_cfdg :=_beefg .Stream ;if _dedg !=nil {_dbba ,_aagd :=_dedg .DecodeBytes (_cfdg );if _aagd !=nil {return nil ,_aagd ;};_cfdg =_dbba ;};_eac :=_fd .NewReader (_cfdg );_ebgcf ,_fbda :=_ee .DecodeConfig (_eac );
if _fbda !=nil {_fg .Log .Debug ("\u0045\u0072\u0072or\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0065\u003a\u0020\u0025\u0073",_fbda );return nil ,_fbda ;};switch _ebgcf .ColorModel {case _e .RGBAModel :_ggb .BitsPerComponent =8;
_ggb .ColorComponents =3;case _e .RGBA64Model :_ggb .BitsPerComponent =16;_ggb .ColorComponents =3;case _e .GrayModel :_ggb .BitsPerComponent =8;_ggb .ColorComponents =1;case _e .Gray16Model :_ggb .BitsPerComponent =16;_ggb .ColorComponents =1;case _e .CMYKModel :_ggb .BitsPerComponent =8;
_ggb .ColorComponents =4;case _e .YCbCrModel :_ggb .BitsPerComponent =8;_ggb .ColorComponents =3;default:return nil ,_g .New ("\u0075\u006e\u0073up\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u006d\u006f\u0064\u0065\u006c");
};_ggb .Width =_ebgcf .Width ;_ggb .Height =_ebgcf .Height ;_fg .Log .Trace ("\u0044\u0043T\u0020\u0045\u006ec\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076",_ggb );_ggb .Quality =DefaultJPEGQuality ;return _ggb ,nil ;};

// PdfObjectBool represents the primitive PDF boolean object.
type PdfObjectBool bool ;

// NewRunLengthEncoder makes a new run length encoder
func NewRunLengthEncoder ()*RunLengthEncoder {return &RunLengthEncoder {}};

// GetDict returns the *PdfObjectDictionary represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetDict (obj PdfObject )(_gfea *PdfObjectDictionary ,_bdcca bool ){_gfea ,_bdcca =TraceToDirectObject (obj ).(*PdfObjectDictionary );return _gfea ,_bdcca ;};func _gefc (_effa int )int {_gafe :=_effa >>(_bgga -1);return (_effa ^_gafe )-_gafe };

// DecodeStream returns the passed in stream as a slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_ecde *RawEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return streamObj .Stream ,nil ;};

// DrawableImage is same as golang image/draw's Image interface that allow drawing images.
type DrawableImage interface{ColorModel ()_e .Model ;Bounds ()_fc .Rectangle ;At (_adbe ,_acga int )_e .Color ;Set (_baae ,_ead int ,_fcdg _e .Color );};

// PdfObjectFloat represents the primitive PDF floating point numerical object.
type PdfObjectFloat float64 ;const (StreamEncodingFilterNameFlate ="F\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameLZW ="\u004cZ\u0057\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameDCT ="\u0044C\u0054\u0044\u0065\u0063\u006f\u0064e";
StreamEncodingFilterNameRunLength ="\u0052u\u006eL\u0065\u006e\u0067\u0074\u0068\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameASCIIHex ="\u0041\u0053\u0043\u0049\u0049\u0048\u0065\u0078\u0044e\u0063\u006f\u0064\u0065";StreamEncodingFilterNameASCII85 ="\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0044\u0065\u0063\u006f\u0064\u0065";
StreamEncodingFilterNameCCITTFax ="\u0043\u0043\u0049\u0054\u0054\u0046\u0061\u0078\u0044e\u0063\u006f\u0064\u0065";StreamEncodingFilterNameJBIG2 ="J\u0042\u0049\u0047\u0032\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameJPX ="\u004aP\u0058\u0044\u0065\u0063\u006f\u0064e";
StreamEncodingFilterNameRaw ="\u0052\u0061\u0077";);

// GetFilterArray returns the names of the underlying encoding filters in an array that
// can be used as /Filter entry.
func (_cbcg *MultiEncoder )GetFilterArray ()*PdfObjectArray {_bbec :=make ([]PdfObject ,len (_cbcg ._feab ));for _fggg ,_gdbfb :=range _cbcg ._feab {_bbec [_fggg ]=MakeName (_gdbfb .GetFilterName ());};return MakeArray (_bbec ...);};

// AddEncoder adds the passed in encoder to the underlying encoder slice.
func (_gbc *MultiEncoder )AddEncoder (encoder StreamEncoder ){_gbc ._feab =append (_gbc ._feab ,encoder )};

// GetStringVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetStringVal (obj PdfObject )(_ebef string ,_acdgc bool ){_dgbbf ,_acdgc :=TraceToDirectObject (obj ).(*PdfObjectString );if _acdgc {return _dgbbf .Str (),true ;};return ;};func _gcbg (_acb _ed .Filter ,_dca _bda .AuthEvent )*PdfObjectDictionary {if _dca ==""{_dca =_bda .EventDocOpen ;
};_ffd :=MakeDict ();_ffd .Set ("\u0054\u0079\u0070\u0065",MakeName ("C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"));_ffd .Set ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et",MakeName (string (_dca )));_ffd .Set ("\u0043\u0046\u004d",MakeName (_acb .Name ()));
_ffd .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_acb .KeyLength ())));return _ffd ;};func _dcdc (_aab *PdfObjectStream ,_efgc *PdfObjectDictionary )(*CCITTFaxEncoder ,error ){_becd :=NewCCITTFaxEncoder ();_ecga :=_aab .PdfObjectDictionary ;
if _ecga ==nil {return _becd ,nil ;};if _efgc ==nil {_cbce :=TraceToDirectObject (_ecga .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));if _cbce !=nil {switch _ebdd :=_cbce .(type ){case *PdfObjectDictionary :_efgc =_ebdd ;case *PdfObjectArray :if _ebdd .Len ()==1{if _cbba ,_dgcdd :=GetDict (_ebdd .Get (0));
_dgcdd {_efgc =_cbba ;};};default:_fg .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_cbce );return nil ,_g .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");
};};if _efgc ==nil {_fg .Log .Error ("\u0044\u0065c\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064 %\u0023\u0076",_cbce );return nil ,_g .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");
};};if _ggba ,_decc :=GetNumberAsInt64 (_efgc .Get ("\u004b"));_decc ==nil {_becd .K =int (_ggba );};if _fcdb ,_dcab :=GetNumberAsInt64 (_efgc .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));_dcab ==nil {_becd .Columns =int (_fcdb );}else {_becd .Columns =1728;
};if _bgcc ,_dfga :=GetNumberAsInt64 (_efgc .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_dfga ==nil {_becd .BlackIs1 =_bgcc > 0;}else {if _fae ,_eca :=GetBoolVal (_efgc .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_eca {_becd .BlackIs1 =_fae ;
}else {if _fcge ,_fgec :=GetArray (_efgc .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));_fgec {_afee ,_cgab :=_fcge .ToIntegerArray ();if _cgab ==nil {_becd .BlackIs1 =_afee [0]==1&&_afee [1]==0;};};};};if _dfdf ,_afdb :=GetNumberAsInt64 (_efgc .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));
_afdb ==nil {_becd .EncodedByteAlign =_dfdf > 0;}else {if _gabge ,_acgaa :=GetBoolVal (_efgc .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_acgaa {_becd .EncodedByteAlign =_gabge ;};};if _fbcde ,_ffbf :=GetNumberAsInt64 (_efgc .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));
_ffbf ==nil {_becd .EndOfLine =_fbcde > 0;}else {if _dbgg ,_eegc :=GetBoolVal (_efgc .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_eegc {_becd .EndOfLine =_dbgg ;};};if _fgf ,_fccf :=GetNumberAsInt64 (_efgc .Get ("\u0052\u006f\u0077\u0073"));
_fccf ==nil {_becd .Rows =int (_fgf );};_becd .EndOfBlock =true ;if _baag ,_gaa :=GetNumberAsInt64 (_efgc .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_gaa ==nil {_becd .EndOfBlock =_baag > 0;}else {if _bdef ,_cggb :=GetBoolVal (_efgc .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));
_cggb {_becd .EndOfBlock =_bdef ;};};if _ecb ,_acfc :=GetNumberAsInt64 (_efgc .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));_acfc !=nil {_becd .DamagedRowsBeforeError =int (_ecb );
};_fg .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_efgc .String ());return _becd ,nil ;};

// NewJPXEncoder returns a new instance of JPXEncoder.
func NewJPXEncoder ()*JPXEncoder {return &JPXEncoder {}};

// WriteString outputs the object as it is to be written to file.
func (_cagb *PdfObjectReference )WriteString ()string {var _cbbb _ff .Builder ;_cbbb .WriteString (_b .FormatInt (_cagb .ObjectNumber ,10));_cbbb .WriteString ("\u0020");_cbbb .WriteString (_b .FormatInt (_cagb .GenerationNumber ,10));_cbbb .WriteString ("\u0020\u0052");
return _cbbb .String ();};

// PdfObjectDictionary represents the primitive PDF dictionary/map object.
type PdfObjectDictionary struct{_ggbc map[PdfObjectName ]PdfObject ;_cabe []PdfObjectName ;_dcfe *PdfParser ;};

// GetXrefTable returns the PDFs xref table.
func (_ffcec *PdfParser )GetXrefTable ()XrefTable {return _ffcec ._dfb };

// EqualObjects returns true if `obj1` and `obj2` have the same contents.
//
// NOTE: It is a good idea to flatten obj1 and obj2 with FlattenObject before calling this function
// so that contents, rather than references, can be compared.
func EqualObjects (obj1 ,obj2 PdfObject )bool {return _dcag (obj1 ,obj2 ,0)};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_geae *JPXEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};func (_dafef *PdfParser )parseXref ()(*PdfObjectDictionary ,error ){const _egbdb =20;_gaefe ,_ :=_dafef ._eeaf .Peek (_egbdb );for _dgce :=0;_dgce < 2;_dgce ++{if _dafef ._agba ==0{_dafef ._agba =_dafef .GetFileOffset ();
};if _dgbd .Match (_gaefe ){_fg .Log .Trace ("\u0078\u0072e\u0066\u0020\u0070\u006f\u0069\u006e\u0074\u0073\u0020\u0074\u006f\u0020\u0061\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u002e\u0020\u0050\u0072\u006f\u0062\u0061\u0062\u006c\u0079\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063\u0074");
_fg .Log .Debug ("\u0073t\u0061r\u0074\u0069\u006e\u0067\u0020w\u0069\u0074h\u0020\u0022\u0025\u0073\u0022",string (_gaefe ));return _dafef .parseXrefStream (nil );};if _egbe .Match (_gaefe ){_fg .Log .Trace ("\u0053\u0074\u0061\u006ed\u0061\u0072\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073e\u0063t\u0069\u006f\u006e\u0020\u0074\u0061\u0062l\u0065\u0021");
return _dafef .parseXrefTable ();};_bgfdd :=_dafef .GetFileOffset ();if _dafef ._agba ==0{_dafef ._agba =_bgfdd ;};_dafef .SetFileOffset (_bgfdd -_egbdb );defer _dafef .SetFileOffset (_bgfdd );_babcb ,_ :=_dafef ._eeaf .Peek (_egbdb );_gaefe =append (_babcb ,_gaefe ...);
};_fg .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u0078\u0072\u0065f\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006fr\u0020\u0073\u0074\u0072\u0065\u0061\u006d.\u0020\u0052\u0065\u0070\u0061i\u0072\u0020\u0061\u0074\u0074e\u006d\u0070\u0074\u0065\u0064\u003a\u0020\u004c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0065\u0061\u0072\u006c\u0069\u0065\u0073\u0074\u0020x\u0072\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u0062\u006f\u0074to\u006d\u002e");
if _bgde :=_dafef .repairSeekXrefMarker ();_bgde !=nil {_fg .Log .Debug ("\u0052e\u0070a\u0069\u0072\u0020\u0066\u0061i\u006c\u0065d\u0020\u002d\u0020\u0025\u0076",_bgde );return nil ,_bgde ;};return _dafef .parseXrefTable ();};

// LookupByReference looks up a PdfObject by a reference.
func (_dgg *PdfParser )LookupByReference (ref PdfObjectReference )(PdfObject ,error ){_fg .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0075\u0070\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0025\u0073",ref .String ());return _dgg .LookupByNumber (int (ref .ObjectNumber ));
};

// Encrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_cafcf *PdfCrypt )Encrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _cafcf .isEncrypted (obj ){return nil ;};switch _fbb :=obj .(type ){case *PdfIndirectObject :_cafcf ._bbba [_fbb ]=true ;_fg .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_fbb .ObjectNumber ,_fbb .GenerationNumber );
_fcgd :=_fbb .ObjectNumber ;_cccg :=_fbb .GenerationNumber ;_bdfe :=_cafcf .Encrypt (_fbb .PdfObject ,_fcgd ,_cccg );if _bdfe !=nil {return _bdfe ;};return nil ;case *PdfObjectStream :_cafcf ._bbba [_fbb ]=true ;_acbfe :=_fbb .PdfObjectDictionary ;if _deb ,_bag :=_acbfe .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );
_bag &&*_deb =="\u0058\u0052\u0065\u0066"{return nil ;};_afedd :=_fbb .ObjectNumber ;_fdd :=_fbb .GenerationNumber ;_fg .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_afedd ,_fdd );
_ebga :=_baeb ;if _cafcf ._baf .V >=4{_ebga =_cafcf ._ebg ;_fg .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_cafcf ._ebg );if _cgf ,_fcaa :=_acbfe .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );
_fcaa {if _cccf ,_fecgf :=GetName (_cgf .Get (0));_fecgf {if *_cccf =="\u0043\u0072\u0079p\u0074"{_ebga ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _dff ,_eaec :=_acbfe .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );
_eaec {if _afb ,_eagd :=_dff .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_eagd {if _ ,_becf :=_cafcf ._egg [string (*_afb )];_becf {_fg .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_afb );
_ebga =string (*_afb );};};};};};};_fg .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_ebga );if _ebga =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_baaa :=_cafcf .Encrypt (_fbb .PdfObjectDictionary ,_afedd ,_fdd );
if _baaa !=nil {return _baaa ;};_gdb ,_baaa :=_cafcf .makeKey (_ebga ,uint32 (_afedd ),uint32 (_fdd ),_cafcf ._cec );if _baaa !=nil {return _baaa ;};_fbb .Stream ,_baaa =_cafcf .encryptBytes (_fbb .Stream ,_ebga ,_gdb );if _baaa !=nil {return _baaa ;};
_acbfe .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_fbb .Stream ))));return nil ;case *PdfObjectString :_fg .Log .Trace ("\u0045n\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_effe :=_baeb ;
if _cafcf ._baf .V >=4{_fg .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_cafcf ._dcf );if _cafcf ._dcf =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_effe =_cafcf ._dcf ;};_feb ,_abdf :=_cafcf .makeKey (_effe ,uint32 (parentObjNum ),uint32 (parentGenNum ),_cafcf ._cec );
if _abdf !=nil {return _abdf ;};_ffeda :=_fbb .Str ();_bggf :=make ([]byte ,len (_ffeda ));for _aacce :=0;_aacce < len (_ffeda );_aacce ++{_bggf [_aacce ]=_ffeda [_aacce ];};_fg .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_bggf ,_bggf );
_bggf ,_abdf =_cafcf .encryptBytes (_bggf ,_effe ,_feb );if _abdf !=nil {return _abdf ;};_fbb ._aaccd =string (_bggf );return nil ;case *PdfObjectArray :for _ ,_dfeb :=range _fbb .Elements (){_gcbc :=_cafcf .Encrypt (_dfeb ,parentObjNum ,parentGenNum );
if _gcbc !=nil {return _gcbc ;};};return nil ;case *PdfObjectDictionary :_gfd :=false ;if _acg :=_fbb .Get ("\u0054\u0079\u0070\u0065");_acg !=nil {_cfgd ,_cadgc :=_acg .(*PdfObjectName );if _cadgc &&*_cfgd =="\u0053\u0069\u0067"{_gfd =true ;};};for _ ,_effd :=range _fbb .Keys (){_defg :=_fbb .Get (_effd );
if _gfd &&string (_effd )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;};if string (_effd )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_effd )!="\u0050\u0072\u0065\u0076"&&string (_effd )!="\u004c\u0061\u0073\u0074"{_dbfd :=_cafcf .Encrypt (_defg ,parentObjNum ,parentGenNum );
if _dbfd !=nil {return _dbfd ;};};};return nil ;};return nil ;};

// MakeHexString creates an PdfObjectString from a string intended for output as a hexadecimal string.
func MakeHexString (s string )*PdfObjectString {_cfde :=PdfObjectString {_aaccd :s ,_cef :true };return &_cfde ;};

// EncodeBytes encodes slice of bytes into JBIG2 encoding format.
// The input 'data' must be an image. In order to Decode it a user is responsible to
// load the codec ('png', 'jpg').
// Returns jbig2 single page encoded document byte slice. The encoder uses DefaultPageSettings
// to encode given image.
func (_afff *JBIG2Encoder )EncodeBytes (data []byte )([]byte ,error ){const _acgaf ="\u004aB\u0049\u0047\u0032\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002eE\u006e\u0063\u006f\u0064\u0065\u0042\u0079\u0074\u0065\u0073";if _afff .ColorComponents !=1||_afff .BitsPerComponent !=1{return nil ,_bb .Errorf (_acgaf ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u002e\u0020\u004a\u0042\u0049G\u0032\u0020E\u006e\u0063o\u0064\u0065\u0072\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020bi\u006e\u0061\u0072\u0079\u0020\u0069\u006d\u0061\u0067e\u0073\u0020\u0064\u0061\u0074\u0061");
};var (_dbef *_bga .Bitmap ;_ccfa error ;);_cgbea :=(_afff .Width *_afff .Height )==len (data );if _cgbea {_dbef ,_ccfa =_bga .NewWithUnpaddedData (_afff .Width ,_afff .Height ,data );}else {_dbef ,_ccfa =_bga .NewWithData (_afff .Width ,_afff .Height ,data );
};if _ccfa !=nil {return nil ,_ccfa ;};_fcgfe :=_afff .DefaultPageSettings ;if _ccfa =_fcgfe .Validate ();_ccfa !=nil {return nil ,_bb .Wrap (_ccfa ,_acgaf ,"");};if _afff ._bfdf ==nil {_afff ._bfdf =_ef .InitEncodeDocument (_fcgfe .FileMode );};switch _fcgfe .Compression {case JB2Generic :if _ccfa =_afff ._bfdf .AddGenericPage (_dbef ,_fcgfe .DuplicatedLinesRemoval );
_ccfa !=nil {return nil ,_bb .Wrap (_ccfa ,_acgaf ,"");};case JB2SymbolCorrelation :return nil ,_bb .Error (_acgaf ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
case JB2SymbolRankHaus :return nil ,_bb .Error (_acgaf ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
default:return nil ,_bb .Error (_acgaf ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return _afff .Encode ();};

// EncodeBytes encodes data into ASCII85 encoded format.
func (_fcda *ASCII85Encoder )EncodeBytes (data []byte )([]byte ,error ){var _cfc _fd .Buffer ;for _fea :=0;_fea < len (data );_fea +=4{_cgcc :=data [_fea ];_bddb :=1;_edfcd :=byte (0);if _fea +1< len (data ){_edfcd =data [_fea +1];_bddb ++;};_dcae :=byte (0);
if _fea +2< len (data ){_dcae =data [_fea +2];_bddb ++;};_fadg :=byte (0);if _fea +3< len (data ){_fadg =data [_fea +3];_bddb ++;};_fggc :=(uint32 (_cgcc )<<24)|(uint32 (_edfcd )<<16)|(uint32 (_dcae )<<8)|uint32 (_fadg );if _fggc ==0{_cfc .WriteByte ('z');
}else {_cdfe :=_fcda .base256Tobase85 (_fggc );for _ ,_dggb :=range _cdfe [:_bddb +1]{_cfc .WriteByte (_dggb +'!');};};};_cfc .WriteString ("\u007e\u003e");return _cfc .Bytes (),nil ;};

// String returns the state of the bool as "true" or "false".
func (_dcgc *PdfObjectBool )String ()string {if *_dcgc {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};

// MakeInteger creates a PdfObjectInteger from an int64.
func MakeInteger (val int64 )*PdfObjectInteger {_fefd :=PdfObjectInteger (val );return &_fefd };func _cecf (_gafa *PdfObjectStream )(*MultiEncoder ,error ){_deff :=NewMultiEncoder ();_fgcb :=_gafa .PdfObjectDictionary ;if _fgcb ==nil {return _deff ,nil ;
};var _efc *PdfObjectDictionary ;var _gggf []PdfObject ;_daa :=_fgcb .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _daa !=nil {_eeff ,_bdcfc :=_daa .(*PdfObjectDictionary );if _bdcfc {_efc =_eeff ;};_daegc ,_deag :=_daa .(*PdfObjectArray );
if _deag {for _ ,_ecbb :=range _daegc .Elements (){_ecbb =TraceToDirectObject (_ecbb );if _agff ,_gfed :=_ecbb .(*PdfObjectDictionary );_gfed {_gggf =append (_gggf ,_agff );}else {_gggf =append (_gggf ,MakeDict ());};};};};_daa =_fgcb .Get ("\u0046\u0069\u006c\u0074\u0065\u0072");
if _daa ==nil {return nil ,_be .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u006d\u0069s\u0073\u0069\u006e\u0067");};_ggca ,_gdda :=_daa .(*PdfObjectArray );if !_gdda {return nil ,_be .Errorf ("m\u0075\u006c\u0074\u0069\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0063\u0061\u006e\u0020\u006f\u006el\u0079\u0020\u0062\u0065\u0020\u006d\u0061\u0064\u0065\u0020fr\u006f\u006d\u0020a\u0072r\u0061\u0079");
};for _daac ,_agea :=range _ggca .Elements (){_efcb ,_ffca :=_agea .(*PdfObjectName );if !_ffca {return nil ,_be .Errorf ("\u006d\u0075l\u0074\u0069\u0020\u0066i\u006c\u0074e\u0072\u0020\u0061\u0072\u0072\u0061\u0079\u0020e\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u006e\u006f\u0074\u0020\u0061 \u006e\u0061\u006d\u0065");
};var _eagdd PdfObject ;if _efc !=nil {_eagdd =_efc ;}else {if len (_gggf )> 0{if _daac >=len (_gggf ){return nil ,_be .Errorf ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0073\u0020\u0069\u006e\u0020d\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006d\u0073\u0020a\u0072\u0072\u0061\u0079");
};_eagdd =_gggf [_daac ];};};var _gfbd *PdfObjectDictionary ;if _bbga ,_abde :=_eagdd .(*PdfObjectDictionary );_abde {_gfbd =_bbga ;};_fg .Log .Trace ("\u004e\u0065\u0078t \u006e\u0061\u006d\u0065\u003a\u0020\u0025\u0073\u002c \u0064p\u003a \u0025v\u002c\u0020\u0064\u0050\u0061\u0072\u0061\u006d\u0073\u003a\u0020\u0025\u0076",*_efcb ,_eagdd ,_gfbd );
if *_efcb ==StreamEncodingFilterNameFlate {_bdag ,_ccba :=_eaga (_gafa ,_gfbd );if _ccba !=nil {return nil ,_ccba ;};_deff .AddEncoder (_bdag );}else if *_efcb ==StreamEncodingFilterNameLZW {_gga ,_cdgc :=_gegd (_gafa ,_gfbd );if _cdgc !=nil {return nil ,_cdgc ;
};_deff .AddEncoder (_gga );}else if *_efcb ==StreamEncodingFilterNameASCIIHex {_efeg :=NewASCIIHexEncoder ();_deff .AddEncoder (_efeg );}else if *_efcb ==StreamEncodingFilterNameASCII85 {_cddd :=NewASCII85Encoder ();_deff .AddEncoder (_cddd );}else if *_efcb ==StreamEncodingFilterNameDCT {_bbgb ,_badgb :=_gad (_gafa ,_deff );
if _badgb !=nil {return nil ,_badgb ;};_deff .AddEncoder (_bbgb );_fg .Log .Trace ("A\u0064d\u0065\u0064\u0020\u0044\u0043\u0054\u0020\u0065n\u0063\u006f\u0064\u0065r.\u002e\u002e");_fg .Log .Trace ("\u004du\u006ct\u0069\u0020\u0065\u006e\u0063o\u0064\u0065r\u003a\u0020\u0025\u0023\u0076",_deff );
}else {_fg .Log .Error ("U\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0066\u0069l\u0074\u0065\u0072\u0020\u0025\u0073",*_efcb );return nil ,_be .Errorf ("\u0069\u006eva\u006c\u0069\u0064 \u0066\u0069\u006c\u0074er \u0069n \u006d\u0075\u006c\u0074\u0069\u0020\u0066il\u0074\u0065\u0072\u0020\u0061\u0072\u0072a\u0079");
};};return _deff ,nil ;};func _defe (_bfe int )cryptFilters {return cryptFilters {_baeb :_ed .NewFilterV2 (_bfe )}};

// Decrypt attempts to decrypt the PDF file with a specified password.  Also tries to
// decrypt with an empty password.  Returns true if successful, false otherwise.
// An error is returned when there is a problem with decrypting.
func (_afgf *PdfParser )Decrypt (password []byte )(bool ,error ){if _afgf ._ggab ==nil {return false ,_g .New ("\u0063\u0068\u0065\u0063k \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u0069\u0072s\u0074");};_cfaaa ,_gbff :=_afgf ._ggab .authenticate (password );
if _gbff !=nil {return false ,_gbff ;};if !_cfaaa {_cfaaa ,_gbff =_afgf ._ggab .authenticate ([]byte (""));};return _cfaaa ,_gbff ;};

// GetFilterName returns the names of the underlying encoding filters,
// separated by spaces.
// Note: This is just a string, should not be used in /Filter dictionary entry. Use GetFilterArray for that.
// TODO(v4): Refactor to GetFilter() which can be used for /Filter (either Name or Array), this can be
//  renamed to String() as a pretty string to use in debugging etc.
func (_gbac *MultiEncoder )GetFilterName ()string {_dabe :="";for _bgce ,_daegb :=range _gbac ._feab {_dabe +=_daegb .GetFilterName ();if _bgce < len (_gbac ._feab )-1{_dabe +="\u0020";};};return _dabe ;};

// DecodeBytes decodes a slice of JPX encoded bytes and returns the result.
func (_efef *JPXEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_fg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_efef .GetFilterName ());
return encoded ,ErrNoJPXDecode ;};

// JBIG2CompressionType defines the enum compression type used by the JBIG2Encoder.
type JBIG2CompressionType int ;

// Set sets the PdfObject at index i of the array. An error is returned if the index is outside bounds.
func (_dddd *PdfObjectArray )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_dddd ._eadg ){return _g .New ("\u006f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_dddd ._eadg [i ]=obj ;return nil ;};

// DecodeStream decodes RunLengthEncoded stream object and give back decoded bytes.
func (_afbb *RunLengthEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _afbb .DecodeBytes (streamObj .Stream );};

// PdfObjectInteger represents the primitive PDF integer numerical object.
type PdfObjectInteger int64 ;func _bebf (_cabc ,_cdebf ,_bgge uint8 )uint8 {_dgdeg :=int (_bgge );_gcdf :=int (_cdebf )-_dgdeg ;_aec :=int (_cabc )-_dgdeg ;_dgdeg =_gefc (_gcdf +_aec );_gcdf =_gefc (_gcdf );_aec =_gefc (_aec );if _gcdf <=_aec &&_gcdf <=_dgdeg {return _cabc ;
}else if _aec <=_dgdeg {return _cdebf ;};return _bgge ;};

// GetStream returns the *PdfObjectStream represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetStream (obj PdfObject )(_bcab *PdfObjectStream ,_edbd bool ){obj =ResolveReference (obj );_bcab ,_edbd =obj .(*PdfObjectStream );return _bcab ,_edbd ;};func (_bge *PdfParser )parseObject ()(PdfObject ,error ){_fg .Log .Trace ("\u0052e\u0061d\u0020\u0064\u0069\u0072\u0065c\u0074\u0020o\u0062\u006a\u0065\u0063\u0074");
_bge .skipSpaces ();for {_cafdb ,_cecd :=_bge ._eeaf .Peek (2);if _cecd !=nil {if _cecd !=_c .EOF ||len (_cafdb )==0{return nil ,_cecd ;};if len (_cafdb )==1{_cafdb =append (_cafdb ,' ');};};_fg .Log .Trace ("\u0050e\u0065k\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u003a\u0020\u0025\u0073",string (_cafdb ));
if _cafdb [0]=='/'{_bbfc ,_ddba :=_bge .parseName ();_fg .Log .Trace ("\u002d\u003e\u004ea\u006d\u0065\u003a\u0020\u0027\u0025\u0073\u0027",_bbfc );return &_bbfc ,_ddba ;}else if _cafdb [0]=='('{_fg .Log .Trace ("\u002d>\u0053\u0074\u0072\u0069\u006e\u0067!");
_bade ,_ebbg :=_bge .parseString ();return _bade ,_ebbg ;}else if _cafdb [0]=='['{_fg .Log .Trace ("\u002d\u003e\u0041\u0072\u0072\u0061\u0079\u0021");_gccd ,_eedb :=_bge .parseArray ();return _gccd ,_eedb ;}else if (_cafdb [0]=='<')&&(_cafdb [1]=='<'){_fg .Log .Trace ("\u002d>\u0044\u0069\u0063\u0074\u0021");
_edcdd ,_bfec :=_bge .ParseDict ();return _edcdd ,_bfec ;}else if _cafdb [0]=='<'{_fg .Log .Trace ("\u002d\u003e\u0048\u0065\u0078\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0021");_ged ,_abbg :=_bge .parseHexString ();return _ged ,_abbg ;}else if _cafdb [0]=='%'{_bge .readComment ();
_bge .skipSpaces ();}else {_fg .Log .Trace ("\u002d\u003eN\u0075\u006d\u0062e\u0072\u0020\u006f\u0072\u0020\u0072\u0065\u0066\u003f");_cafdb ,_ =_bge ._eeaf .Peek (15);_gdga :=string (_cafdb );_fg .Log .Trace ("\u0050\u0065\u0065k\u0020\u0073\u0074\u0072\u003a\u0020\u0025\u0073",_gdga );
if (len (_gdga )> 3)&&(_gdga [:4]=="\u006e\u0075\u006c\u006c"){_efaa ,_egca :=_bge .parseNull ();return &_efaa ,_egca ;}else if (len (_gdga )> 4)&&(_gdga [:5]=="\u0066\u0061\u006cs\u0065"){_ebdb ,_baad :=_bge .parseBool ();return &_ebdb ,_baad ;}else if (len (_gdga )> 3)&&(_gdga [:4]=="\u0074\u0072\u0075\u0065"){_gcab ,_ddeb :=_bge .parseBool ();
return &_gcab ,_ddeb ;};_egfd :=_bgcb .FindStringSubmatch (_gdga );if len (_egfd )> 1{_cafdb ,_ =_bge ._eeaf .ReadBytes ('R');_fg .Log .Trace ("\u002d\u003e\u0020\u0021\u0052\u0065\u0066\u003a\u0020\u0027\u0025\u0073\u0027",string (_cafdb [:]));_fdfc ,_fggcce :=_gabaa (string (_cafdb ));
_fdfc ._eaca =_bge ;return &_fdfc ,_fggcce ;};_gebf :=_bbfd .FindStringSubmatch (_gdga );if len (_gebf )> 1{_fg .Log .Trace ("\u002d\u003e\u0020\u004e\u0075\u006d\u0062\u0065\u0072\u0021");_cdcg ,_bdce :=_bge .parseNumber ();return _cdcg ,_bdce ;};_gebf =_ggda .FindStringSubmatch (_gdga );
if len (_gebf )> 1{_fg .Log .Trace ("\u002d\u003e\u0020\u0045xp\u006f\u006e\u0065\u006e\u0074\u0069\u0061\u006c\u0020\u004e\u0075\u006d\u0062\u0065r\u0021");_fg .Log .Trace ("\u0025\u0020\u0073",_gebf );_eaaf ,_dccf :=_bge .parseNumber ();return _eaaf ,_dccf ;
};_fg .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020U\u006e\u006b\u006e\u006f\u0077n\u0020(\u0070e\u0065\u006b\u0020\u0022\u0025\u0073\u0022)",_gdga );return nil ,_g .New ("\u006f\u0062\u006a\u0065\u0063t\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020\u0075\u006e\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e");
};};};func (_bfdd *PdfParser )repairSeekXrefMarker ()error {_geba ,_baaeb :=_bfdd ._cbfb .Seek (0,_c .SeekEnd );if _baaeb !=nil {return _baaeb ;};_abbgec :=_ab .MustCompile ("\u005cs\u0078\u0072\u0065\u0066\u005c\u0073*");var _afaa int64 ;var _fgea int64 =1000;
for _afaa < _geba {if _geba <=(_fgea +_afaa ){_fgea =_geba -_afaa ;};_ ,_cfbag :=_bfdd ._cbfb .Seek (-_afaa -_fgea ,_c .SeekEnd );if _cfbag !=nil {return _cfbag ;};_aeagc :=make ([]byte ,_fgea );_bfdd ._cbfb .Read (_aeagc );_fg .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0078\u0072\u0065\u0066\u0020\u003a\u0020\u0022\u0025\u0073\u0022",string (_aeagc ));
_ceeb :=_abbgec .FindAllStringIndex (string (_aeagc ),-1);if _ceeb !=nil {_dgge :=_ceeb [len (_ceeb )-1];_fg .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_ceeb );_bfdd ._cbfb .Seek (-_afaa -_fgea +int64 (_dgge [0]),_c .SeekEnd );_bfdd ._eeaf =_bd .NewReader (_bfdd ._cbfb );
for {_cddb ,_gdaba :=_bfdd ._eeaf .Peek (1);if _gdaba !=nil {return _gdaba ;};_fg .Log .Trace ("\u0042\u003a\u0020\u0025\u0064\u0020\u0025\u0063",_cddb [0],_cddb [0]);if !IsWhiteSpace (_cddb [0]){break ;};_bfdd ._eeaf .Discard (1);};return nil ;};_fg .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");
_afaa +=_fgea ;};_fg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074a\u0062\u006c\u0065\u0020\u006d\u0061r\u006b\u0065\u0072\u0020\u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066o\u0075\u006e\u0064\u002e");
return _g .New ("\u0078r\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0020");};

// JBIG2Encoder implements both jbig2 encoder and the decoder. The encoder allows to encode
// provided images (best used document scans) in multiple way. By default it uses single page generic
// encoder. It allows to store lossless data as a single segment.
// In order to store multiple image pages use the 'FileMode' which allows to store more pages within single jbig2 document.
// WIP: In order to obtain better compression results the encoder would allow to encode the input in a
// lossy or lossless way with a component (symbol) mode. It divides the image into components.
// Then checks if any component is 'similar' to the others and maps them together. The symbol classes are stored
// in the dictionary. Then the encoder creates text regions which uses the related symbol classes to fill it's space.
// The similarity is defined by the 'Threshold' variable (default: 0.95). The less the value is, the more components
// matches to single class, thus the compression is better, but the result might become lossy.
type JBIG2Encoder struct{

// These values are required to be set for the 'EncodeBytes' method.
// ColorComponents defines the number of color components for provided image.
ColorComponents int ;

// BitsPerComponent is the number of bits that stores per color component
BitsPerComponent int ;

// Width is the width of the image to encode
Width int ;

// Height is the height of the image to encode.
Height int ;_bfdf *_ef .Document ;

// Globals are the JBIG2 global segments.
Globals _gg .Globals ;

// IsChocolateData defines if the data is encoded such that
// binary data '1' means black and '0' white.
// otherwise the data is called vanilla.
// Naming convention taken from: 'https://en.wikipedia.org/wiki/Binary_image#Interpretation'
IsChocolateData bool ;

// DefaultPageSettings are the settings parameters used by the jbig2 encoder.
DefaultPageSettings JBIG2EncoderSettings ;};

// NewCCITTFaxEncoder makes a new CCITTFax encoder.
func NewCCITTFaxEncoder ()*CCITTFaxEncoder {return &CCITTFaxEncoder {Columns :1728,EndOfBlock :true }};func _gegd (_bagg *PdfObjectStream ,_bfee *PdfObjectDictionary )(*LZWEncoder ,error ){_dafc :=NewLZWEncoder ();_gec :=_bagg .PdfObjectDictionary ;if _gec ==nil {return _dafc ,nil ;
};if _bfee ==nil {_ebeb :=TraceToDirectObject (_gec .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));if _ebeb !=nil {if _fadd ,_aga :=_ebeb .(*PdfObjectDictionary );_aga {_bfee =_fadd ;}else if _gacga ,_dgcd :=_ebeb .(*PdfObjectArray );
_dgcd {if _gacga .Len ()==1{if _ddab ,_affb :=GetDict (_gacga .Get (0));_affb {_bfee =_ddab ;};};};if _bfee ==nil {_fg .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_ebeb );
return nil ,_be .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};};_adef :=_gec .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");if _adef !=nil {_efa ,_fcaf :=_adef .(*PdfObjectInteger );
if !_fcaf {_fg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a \u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065d\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u006e\u0075\u006d\u0065\u0072i\u0063 \u0028\u0025\u0054\u0029",_adef );
return nil ,_be .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");};if *_efa !=0&&*_efa !=1{return nil ,_be .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0076\u0061\u006c\u0075e\u0020\u0028\u006e\u006f\u0074 \u0030\u0020o\u0072\u0020\u0031\u0029");
};_dafc .EarlyChange =int (*_efa );}else {_dafc .EarlyChange =1;};if _bfee ==nil {return _dafc ,nil ;};if _fgbf ,_edbb :=GetIntVal (_bfee .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065"));_edbb {if _fgbf ==0||_fgbf ==1{_dafc .EarlyChange =_fgbf ;
}else {_fg .Log .Debug ("W\u0041\u0052\u004e\u003a\u0020\u0069n\u0076\u0061\u006c\u0069\u0064\u0020E\u0061\u0072\u006c\u0079\u0043\u0068\u0061n\u0067\u0065\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020%\u0064",_fgbf );};};_adef =_bfee .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");
if _adef !=nil {_afd ,_dgde :=_adef .(*PdfObjectInteger );if !_dgde {_fg .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_adef );
return nil ,_be .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_dafc .Predictor =int (*_afd );};_adef =_bfee .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");
if _adef !=nil {_aad ,_ggd :=_adef .(*PdfObjectInteger );if !_ggd {_fg .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");
return nil ,_be .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_dafc .BitsPerComponent =int (*_aad );};if _dafc .Predictor > 1{_dafc .Columns =1;_adef =_bfee .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");
if _adef !=nil {_ecgff ,_ebd :=_adef .(*PdfObjectInteger );if !_ebd {return nil ,_be .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_dafc .Columns =int (*_ecgff );
};_dafc .Colors =1;_adef =_bfee .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _adef !=nil {_abgb ,_dcdb :=_adef .(*PdfObjectInteger );if !_dcdb {return nil ,_be .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");
};_dafc .Colors =int (*_abgb );};};_fg .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_bfee .String ());return _dafc ,nil ;};

// CCITTFaxEncoder implements Group3 and Group4 facsimile (fax) encoder/decoder.
type CCITTFaxEncoder struct{K int ;EndOfLine bool ;EncodedByteAlign bool ;Columns int ;Rows int ;EndOfBlock bool ;BlackIs1 bool ;DamagedRowsBeforeError int ;};

// GetFilterName returns the name of the encoding filter.
func (_fcgff *JBIG2Encoder )GetFilterName ()string {return StreamEncodingFilterNameJBIG2 };

// UpdateParams updates the parameter values of the encoder.
func (_dgbb *MultiEncoder )UpdateParams (params *PdfObjectDictionary ){for _ ,_acdf :=range _dgbb ._feab {_acdf .UpdateParams (params );};};

// String returns a string describing `ind`.
func (_bccg *PdfIndirectObject )String ()string {return _be .Sprintf ("\u0049\u004f\u0062\u006a\u0065\u0063\u0074\u003a\u0025\u0064",(*_bccg ).ObjectNumber );};func (_ebce *PdfParser )parsePdfVersion ()(int ,int ,error ){var _bdff int64 =20;_dfgc :=make ([]byte ,_bdff );
_ebce ._cbfb .Seek (0,_c .SeekStart );_ebce ._cbfb .Read (_dfgc );var _gbe error ;var _bfff ,_cgcfc int ;if _gabaab :=_bcgc .FindStringSubmatch (string (_dfgc ));len (_gabaab )< 3{if _bfff ,_cgcfc ,_gbe =_ebce .seekPdfVersionTopDown ();_gbe !=nil {_fg .Log .Debug ("F\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065\u0063\u006f\u0076\u0065\u0072\u0079\u0020\u002d\u0020\u0075n\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0066\u0069nd\u0020\u0076\u0065r\u0073i\u006f\u006e");
return 0,0,_gbe ;};_ebce ._cbfb ,_gbe =_dgfec (_ebce ._cbfb ,_ebce .GetFileOffset ()-8);if _gbe !=nil {return 0,0,_gbe ;};}else {if _bfff ,_gbe =_b .Atoi (_gabaab [1]);_gbe !=nil {return 0,0,_gbe ;};if _cgcfc ,_gbe =_b .Atoi (_gabaab [2]);_gbe !=nil {return 0,0,_gbe ;
};_ebce .SetFileOffset (0);};_ebce ._eeaf =_bd .NewReader (_ebce ._cbfb );_fg .Log .Debug ("\u0050\u0064\u0066\u0020\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020%\u0064\u002e\u0025\u0064",_bfff ,_cgcfc );return _bfff ,_cgcfc ,nil ;};func (_efde *PdfParser )repairRebuildXrefsTopDown ()(*XrefTable ,error ){if _efde ._cceg {return nil ,_be .Errorf ("\u0072\u0065\u0070\u0061\u0069\u0072\u0020\u0066\u0061\u0069\u006c\u0065\u0064");
};_efde ._cceg =true ;_efde ._cbfb .Seek (0,_c .SeekStart );_efde ._eeaf =_bd .NewReader (_efde ._cbfb );_ffega :=20;_fecd :=make ([]byte ,_ffega );_cccgge :=XrefTable {};_cccgge .ObjectMap =make (map[int ]XrefObject );for {_gcfe ,_ffeag :=_efde ._eeaf .ReadByte ();
if _ffeag !=nil {if _ffeag ==_c .EOF {break ;}else {return nil ,_ffeag ;};};if _gcfe =='j'&&_fecd [_ffega -1]=='b'&&_fecd [_ffega -2]=='o'&&IsWhiteSpace (_fecd [_ffega -3]){_bdaf :=_ffega -4;for IsWhiteSpace (_fecd [_bdaf ])&&_bdaf > 0{_bdaf --;};if _bdaf ==0||!IsDecimalDigit (_fecd [_bdaf ]){continue ;
};for IsDecimalDigit (_fecd [_bdaf ])&&_bdaf > 0{_bdaf --;};if _bdaf ==0||!IsWhiteSpace (_fecd [_bdaf ]){continue ;};for IsWhiteSpace (_fecd [_bdaf ])&&_bdaf > 0{_bdaf --;};if _bdaf ==0||!IsDecimalDigit (_fecd [_bdaf ]){continue ;};for IsDecimalDigit (_fecd [_bdaf ])&&_bdaf > 0{_bdaf --;
};if _bdaf ==0{continue ;};_cdef :=_efde .GetFileOffset ()-int64 (_ffega -_bdaf );_ebefc :=append (_fecd [_bdaf +1:],_gcfe );_cgbg ,_ddfc ,_efbg :=_fdaf (string (_ebefc ));if _efbg !=nil {_fg .Log .Debug ("\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u006e\u0075\u006d\u0062\u0065r\u003a\u0020\u0025\u0076",_efbg );
return nil ,_efbg ;};if _gdbgd ,_cbdga :=_cccgge .ObjectMap [_cgbg ];!_cbdga ||_gdbgd .Generation < _ddfc {_aaab :=XrefObject {};_aaab .XType =XrefTypeTableEntry ;_aaab .ObjectNumber =_cgbg ;_aaab .Generation =_ddfc ;_aaab .Offset =_cdef ;_cccgge .ObjectMap [_cgbg ]=_aaab ;
};};_fecd =append (_fecd [1:_ffega ],_gcfe );};_efde ._gbaa =nil ;return &_cccgge ,nil ;};var _ggda =_ab .MustCompile ("\u005e\u005b\\\u002b\u002d\u002e\u005d*\u0028\u005b0\u002d\u0039\u002e\u005d\u002b\u0029\u005b\u0065E\u005d\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");
func (_feag *PdfParser )parseString ()(*PdfObjectString ,error ){_feag ._eeaf .ReadByte ();var _edg _fd .Buffer ;_ggbd :=1;for {_fcfef ,_cdeba :=_feag ._eeaf .Peek (1);if _cdeba !=nil {return MakeString (_edg .String ()),_cdeba ;};if _fcfef [0]=='\\'{_feag ._eeaf .ReadByte ();
_edgd ,_ccec :=_feag ._eeaf .ReadByte ();if _ccec !=nil {return MakeString (_edg .String ()),_ccec ;};if IsOctalDigit (_edgd ){_egae ,_egaae :=_feag ._eeaf .Peek (2);if _egaae !=nil {return MakeString (_edg .String ()),_egaae ;};var _bddd []byte ;_bddd =append (_bddd ,_edgd );
for _ ,_acae :=range _egae {if IsOctalDigit (_acae ){_bddd =append (_bddd ,_acae );}else {break ;};};_feag ._eeaf .Discard (len (_bddd )-1);_fg .Log .Trace ("\u004e\u0075\u006d\u0065ri\u0063\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0022\u0025\u0073\u0022",_bddd );
_bbecc ,_egaae :=_b .ParseUint (string (_bddd ),8,32);if _egaae !=nil {return MakeString (_edg .String ()),_egaae ;};_edg .WriteByte (byte (_bbecc ));continue ;};switch _edgd {case 'n':_edg .WriteRune ('\n');case 'r':_edg .WriteRune ('\r');case 't':_edg .WriteRune ('\t');
case 'b':_edg .WriteRune ('\b');case 'f':_edg .WriteRune ('\f');case '(':_edg .WriteRune ('(');case ')':_edg .WriteRune (')');case '\\':_edg .WriteRune ('\\');};continue ;}else if _fcfef [0]=='('{_ggbd ++;}else if _fcfef [0]==')'{_ggbd --;if _ggbd ==0{_feag ._eeaf .ReadByte ();
break ;};};_gacc ,_ :=_feag ._eeaf .ReadByte ();_edg .WriteByte (_gacc );};return MakeString (_edg .String ()),nil ;};var _cbfd =_ab .MustCompile ("\u0073t\u0061r\u0074\u0078\u003f\u0072\u0065f\u005c\u0073*\u0028\u005c\u0064\u002b\u0029");

// PdfVersion returns version of the PDF file.
func (_gbgg *PdfParser )PdfVersion ()Version {return _gbgg ._ggaca };func (_gega *PdfParser )inspect ()(map[string ]int ,error ){_fg .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0053P\u0045\u0043\u0054\u0020\u002d\u002d\u002d\u002d\u002d\u002d-\u002d\u002d\u002d");
_fg .Log .Trace ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");_dggd :=map[string ]int {};_bdae :=0;_ffcd :=0;var _dddde []int ;for _gdac :=range _gega ._dfb .ObjectMap {_dddde =append (_dddde ,_gdac );};_f .Ints (_dddde );_afbad :=0;
for _ ,_bdacc :=range _dddde {_dbfc :=_gega ._dfb .ObjectMap [_bdacc ];if _dbfc .ObjectNumber ==0{continue ;};_bdae ++;_fg .Log .Trace ("\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d");_fg .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0075\u0070\u0020\u006f\u0062\u006a\u0065c\u0074 \u006e\u0075\u006d\u0062\u0065\u0072\u003a \u0025\u0064",_dbfc .ObjectNumber );
_agag ,_effaf :=_gega .LookupByNumber (_dbfc .ObjectNumber );if _effaf !=nil {_fg .Log .Trace ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u006c\u006f\u006f\u006b\u0075p\u0020\u006f\u0062\u006a\u0020\u0025\u0064 \u0028\u0025\u0073\u0029",_dbfc .ObjectNumber ,_effaf );
_ffcd ++;continue ;};_fg .Log .Trace ("\u006fb\u006a\u003a\u0020\u0025\u0073",_agag );_eaacd ,_ffa :=_agag .(*PdfIndirectObject );if _ffa {_fg .Log .Trace ("\u0049N\u0044 \u004f\u004f\u0042\u004a\u0020\u0025\u0064\u003a\u0020\u0025\u0073",_dbfc .ObjectNumber ,_eaacd );
_ccfbe ,_dcdg :=_eaacd .PdfObject .(*PdfObjectDictionary );if _dcdg {if _aecea ,_gggg :=_ccfbe .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_gggg {_ggec :=string (*_aecea );_fg .Log .Trace ("\u002d\u002d\u002d\u003e\u0020\u004f\u0062\u006a\u0020\u0074\u0079\u0070e\u003a\u0020\u0025\u0073",_ggec );
_ ,_dbdb :=_dggd [_ggec ];if _dbdb {_dggd [_ggec ]++;}else {_dggd [_ggec ]=1;};}else if _acba ,_cdgaf :=_ccfbe .Get ("\u0053u\u0062\u0074\u0079\u0070\u0065").(*PdfObjectName );_cdgaf {_dcee :=string (*_acba );_fg .Log .Trace ("-\u002d-\u003e\u0020\u004f\u0062\u006a\u0020\u0073\u0075b\u0074\u0079\u0070\u0065: \u0025\u0073",_dcee );
_ ,_egbga :=_dggd [_dcee ];if _egbga {_dggd [_dcee ]++;}else {_dggd [_dcee ]=1;};};if _afcgc ,_edce :=_ccfbe .Get ("\u0053").(*PdfObjectName );_edce &&*_afcgc =="\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"{_ ,_fgace :=_dggd ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"];
if _fgace {_dggd ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]++;}else {_dggd ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]=1;};};};}else if _efgcc ,_dbad :=_agag .(*PdfObjectStream );_dbad {if _cfbe ,_gbdga :=_efgcc .PdfObjectDictionary .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );
_gbdga {_fg .Log .Trace ("\u002d\u002d\u003e\u0020\u0053\u0074\u0072\u0065\u0061\u006d\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073",*_cfbe );_bggab :=string (*_cfbe );_dggd [_bggab ]++;};}else {_bdbd ,_gdddb :=_agag .(*PdfObjectDictionary );
if _gdddb {_gaaa ,_ecef :=_bdbd .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if _ecef {_edac :=string (*_gaaa );_fg .Log .Trace ("\u002d-\u002d \u006f\u0062\u006a\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073",_edac );_dggd [_edac ]++;};};_fg .Log .Trace ("\u0044\u0049\u0052\u0045\u0043\u0054\u0020\u004f\u0042\u004a\u0020\u0025d\u003a\u0020\u0025\u0073",_dbfc .ObjectNumber ,_agag );
};_afbad ++;};_fg .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0045\u004fF\u0020\u0049\u004e\u0053\u0050\u0045\u0043T\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d");_fg .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");
_fg .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074 \u0063\u006f\u0075\u006e\u0074\u003a\u0020\u0025\u0064",_bdae );_fg .Log .Trace ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u006f\u006b\u0075p\u003a\u0020\u0025\u0064",_ffcd );for _bcgca ,_efcbc :=range _dggd {_fg .Log .Trace ("\u0025\u0073\u003a\u0020\u0025\u0064",_bcgca ,_efcbc );
};_fg .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");if len (_gega ._dfb .ObjectMap )< 1{_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0068\u0069\u0073 \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074 \u0069s\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0028\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0021\u0029");
return nil ,_be .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0064\u006fc\u0075\u006d\u0065\u006e\u0074\u0020\u0028\u0078r\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006d\u0069\u0073s\u0069\u006e\u0067\u0029");};_dcaaag ,_bffc :=_dggd ["\u0046\u006f\u006e\u0074"];
if !_bffc ||_dcaaag < 2{_fg .Log .Trace ("\u0054\u0068\u0069s \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020i\u0073 \u0070r\u006fb\u0061\u0062\u006c\u0079\u0020\u0073\u0063\u0061\u006e\u006e\u0065\u0064\u0021");}else {_fg .Log .Trace ("\u0054\u0068\u0069\u0073\u0020\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020\u0069\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0066o\u0072\u0020\u0065\u0078\u0074r\u0061\u0063t\u0069\u006f\u006e\u0021");
};return _dggd ,nil ;};

// ASCII85Encoder implements ASCII85 encoder/decoder.
type ASCII85Encoder struct{};type objectStreams map[int ]objectStream ;

// MakeStream creates an PdfObjectStream with specified contents and encoding. If encoding is nil, then raw encoding
// will be used (i.e. no encoding applied).
func MakeStream (contents []byte ,encoder StreamEncoder )(*PdfObjectStream ,error ){_eebg :=&PdfObjectStream {};if encoder ==nil {encoder =NewRawEncoder ();};_eebg .PdfObjectDictionary =encoder .MakeStreamDict ();_abgc ,_fffc :=encoder .EncodeBytes (contents );
if _fffc !=nil {return nil ,_fffc ;};_eebg .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_abgc ))));_eebg .Stream =_abgc ;return _eebg ,nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_fbaf *RunLengthEncoder )MakeDecodeParams ()PdfObject {return nil };

// WriteString outputs the object as it is to be written to file.
func (_gccde *PdfObjectString )WriteString ()string {var _dcaee _fd .Buffer ;if _gccde ._cef {_bgee :=_bg .EncodeToString (_gccde .Bytes ());_dcaee .WriteString ("\u003c");_dcaee .WriteString (_bgee );_dcaee .WriteString ("\u003e");return _dcaee .String ();
};_ceedg :=map[byte ]string {'\n':"\u005c\u006e",'\r':"\u005c\u0072",'\t':"\u005c\u0074",'\b':"\u005c\u0062",'\f':"\u005c\u0066",'(':"\u005c\u0028",')':"\u005c\u0029",'\\':"\u005c\u005c"};_dcaee .WriteString ("\u0028");for _bacd :=0;_bacd < len (_gccde ._aaccd );
_bacd ++{_gcefb :=_gccde ._aaccd [_bacd ];if _gccff ,_aacf :=_ceedg [_gcefb ];_aacf {_dcaee .WriteString (_gccff );}else {_dcaee .WriteByte (_gcefb );};};_dcaee .WriteString ("\u0029");return _dcaee .String ();};func _aac (_add XrefTable ){_fg .Log .Debug ("\u003dX\u003d\u0058\u003d\u0058\u003d");
_fg .Log .Debug ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");_cf :=0;for _ ,_dggf :=range _add .ObjectMap {_fg .Log .Debug ("i\u002b\u0031\u003a\u0020\u0025\u0064 \u0028\u006f\u0062\u006a\u0020\u006eu\u006d\u003a\u0020\u0025\u0064\u0020\u0067e\u006e\u003a\u0020\u0025\u0064\u0029\u0020\u002d\u003e\u0020%\u0064",_cf +1,_dggf .ObjectNumber ,_dggf .Generation ,_dggf .Offset );
_cf ++;};};

// MakeString creates an PdfObjectString from a string.
// NOTE: PDF does not use utf-8 string encoding like Go so `s` will often not be a utf-8 encoded
// string.
func MakeString (s string )*PdfObjectString {_bdbc :=PdfObjectString {_aaccd :s };return &_bdbc };func _gabaa (_cdga string )(PdfObjectReference ,error ){_fgdg :=PdfObjectReference {};_fdga :=_bgcb .FindStringSubmatch (_cdga );if len (_fdga )< 3{_fg .Log .Debug ("\u0045\u0072\u0072or\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");
return _fgdg ,_g .New ("\u0075n\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061r\u0073e\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");};_fbbb ,_ :=_b .Atoi (_fdga [1]);_bcgg ,_ :=_b .Atoi (_fdga [2]);_fgdg .ObjectNumber =int64 (_fbbb );_fgdg .GenerationNumber =int64 (_bcgg );
return _fgdg ,nil ;};

// DecodeStream decodes a LZW encoded stream and returns the result as a
// slice of bytes.
func (_agf *LZWEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_fg .Log .Trace ("\u004c\u005a\u0057 \u0044\u0065\u0063\u006f\u0064\u0069\u006e\u0067");_fg .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_agf .Predictor );
_gcae ,_fcdf :=_agf .DecodeBytes (streamObj .Stream );if _fcdf !=nil {return nil ,_fcdf ;};_fg .Log .Trace ("\u0020\u0049\u004e\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (streamObj .Stream ),streamObj .Stream );_fg .Log .Trace ("\u004f\u0055\u0054\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (_gcae ),_gcae );
if _agf .Predictor > 1{if _agf .Predictor ==2{_fg .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_eafd :=_agf .Columns *_agf .Colors ;if _eafd < 1{return []byte {},nil ;};_babb :=len (_gcae )/_eafd ;if len (_gcae )%_eafd !=0{_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");
return nil ,_be .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_gcae ),_eafd );};if _eafd %_agf .Colors !=0{return nil ,_be .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_eafd ,_agf .Colors );
};if _eafd > len (_gcae ){_fg .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_eafd ,len (_gcae ));
return nil ,_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_fg .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_gcae ),_gcae );
_cgfb :=_fd .NewBuffer (nil );for _ebdc :=0;_ebdc < _babb ;_ebdc ++{_gcgcg :=_gcae [_eafd *_ebdc :_eafd *(_ebdc +1)];for _bggdb :=_agf .Colors ;_bggdb < _eafd ;_bggdb ++{_gcgcg [_bggdb ]=byte (int (_gcgcg [_bggdb ]+_gcgcg [_bggdb -_agf .Colors ])%256);
};_cgfb .Write (_gcgcg );};_gfc :=_cgfb .Bytes ();_fg .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_gfc ),_gfc );return _gfc ,nil ;}else if _agf .Predictor >=10&&_agf .Predictor <=15{_fg .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");
_bdfec :=_agf .Columns *_agf .Colors +1;if _bdfec < 1{return []byte {},nil ;};_bdgg :=len (_gcae )/_bdfec ;if len (_gcae )%_bdfec !=0{return nil ,_be .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_gcae ),_bdfec );
};if _bdfec > len (_gcae ){_fg .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_bdfec ,len (_gcae ));
return nil ,_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_bgd :=_fd .NewBuffer (nil );_fg .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_agf .Columns );
_fg .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_gcae ),_bdfec ,_bdgg );_ebgc :=make ([]byte ,_bdfec );for _dea :=0;_dea < _bdfec ;_dea ++{_ebgc [_dea ]=0;
};for _afef :=0;_afef < _bdgg ;_afef ++{_bbd :=_gcae [_bdfec *_afef :_bdfec *(_afef +1)];_fbab :=_bbd [0];switch _fbab {case 0:case 1:for _cac :=2;_cac < _bdfec ;_cac ++{_bbd [_cac ]=byte (int (_bbd [_cac ]+_bbd [_cac -1])%256);};case 2:for _edbc :=1;_edbc < _bdfec ;
_edbc ++{_bbd [_edbc ]=byte (int (_bbd [_edbc ]+_ebgc [_edbc ])%256);};default:_fg .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0066i\u006c\u0074\u0065\u0072\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_fbab );
return nil ,_be .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_fbab );};for _gffbd :=0;_gffbd < _bdfec ;_gffbd ++{_ebgc [_gffbd ]=_bbd [_gffbd ];};_bgd .Write (_bbd [1:]);
};_ebad :=_bgd .Bytes ();return _ebad ,nil ;}else {_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_agf .Predictor );
return nil ,_be .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_agf .Predictor );};};return _gcae ,nil ;};

// MakeName creates a PdfObjectName from a string.
func MakeName (s string )*PdfObjectName {_gebgf :=PdfObjectName (s );return &_gebgf };var (ErrUnsupportedEncodingParameters =_g .New ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074\u0065\u0072\u0073");
ErrNoCCITTFaxDecode =_g .New ("\u0043\u0043I\u0054\u0054\u0046\u0061\u0078\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");
ErrNoJBIG2Decode =_g .New ("\u004a\u0042\u0049\u0047\u0032\u0044\u0065c\u006f\u0064\u0065 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");
ErrNoJPXDecode =_g .New ("\u004a\u0050\u0058\u0044\u0065c\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020i\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");
ErrNoPdfVersion =_g .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");ErrTypeError =_g .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");ErrRangeError =_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");
ErrNotSupported =_ec .New ("\u0066\u0065\u0061t\u0075\u0072\u0065\u0020n\u006f\u0074\u0020\u0063\u0075\u0072\u0072e\u006e\u0074\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");ErrNotANumber =_g .New ("\u006e\u006f\u0074 \u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072");
);const _ddgf =10;

// String returns the PDF version as a string. Implements interface fmt.Stringer.
func (_bbge Version )String ()string {return _be .Sprintf ("\u00250\u0064\u002e\u0025\u0030\u0064",_bbge .Major ,_bbge .Minor );};

// EncodeImage encodes 'img' golang image.Image into jbig2 encoded bytes document using default encoder settings.
func (_ebec *JBIG2Encoder )EncodeImage (img _fc .Image )([]byte ,error ){return _ebec .encodeImage (img )};

// DecodeImages decodes the page images from the jbig2 'encoded' data input.
// The jbig2 document may contain multiple pages, thus the function can return multiple
// images. The images order corresponds to the page number.
func (_gbaf *JBIG2Encoder )DecodeImages (encoded []byte )([]_fc .Image ,error ){const _edfb ="\u004aB\u0049\u0047\u0032\u0045n\u0063\u006f\u0064\u0065\u0072.\u0044e\u0063o\u0064\u0065\u0049\u006d\u0061\u0067\u0065s";_agdc ,_ffde :=_ecg .Decode (encoded ,_ecg .Parameters {},_gbaf .Globals .ToDocumentGlobals ());
if _ffde !=nil {return nil ,_bb .Wrap (_ffde ,_edfb ,"");};_bfde ,_ffde :=_agdc .PageNumber ();if _ffde !=nil {return nil ,_bb .Wrap (_ffde ,_edfb ,"");};_ddfaf :=[]_fc .Image {};var _bcfab _fc .Image ;for _aefe :=1;_aefe <=_bfde ;_aefe ++{_bcfab ,_ffde =_agdc .DecodePageImage (_aefe );
if _ffde !=nil {return nil ,_bb .Wrapf (_ffde ,_edfb ,"\u0070\u0061\u0067\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_aefe );};_ddfaf =append (_ddfaf ,_bcfab );};return _ddfaf ,nil ;};

// GetArray returns the *PdfObjectArray represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetArray (obj PdfObject )(_bagf *PdfObjectArray ,_fce bool ){_bagf ,_fce =TraceToDirectObject (obj ).(*PdfObjectArray );return _bagf ,_fce ;};

// DecodeBytes decodes a slice of Flate encoded bytes and returns the result.
func (_eedf *FlateEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_fg .Log .Trace ("\u0046\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065\u0020b\u0079\u0074\u0065\u0073");if len (encoded )==0{_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0046\u006c\u0061\u0074\u0065 e\u006ec\u006f\u0064\u0065\u0064\u0020\u0062\u0075\u0066\u0066\u0065\u0072\u002e \u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0062y\u0074\u0065\u0020\u0073\u006c\u0069\u0063\u0065\u002e");
return []byte {},nil ;};_cdfa :=_fd .NewReader (encoded );_aeagg ,_fad :=_eb .NewReader (_cdfa );if _fad !=nil {_fg .Log .Debug ("\u0044e\u0063o\u0064\u0069\u006e\u0067\u0020e\u0072\u0072o\u0072\u0020\u0025\u0076\u000a",_fad );_fg .Log .Debug ("\u0053t\u0072e\u0061\u006d\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (encoded ),encoded );
return nil ,_fad ;};defer _aeagg .Close ();var _aceb _fd .Buffer ;_aceb .ReadFrom (_aeagg );return _aceb .Bytes (),nil ;};

// ReadAtLeast reads at least n bytes into slice p.
// Returns the number of bytes read (should always be == n), and an error on failure.
func (_edag *PdfParser )ReadAtLeast (p []byte ,n int )(int ,error ){_eegf :=n ;_gcbgf :=0;_fgba :=0;for _eegf > 0{_cdeb ,_efeb :=_edag ._eeaf .Read (p [_gcbgf :]);if _efeb !=nil {_fg .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061d\u0069\u006e\u0067\u0020\u0028\u0025\u0064\u003b\u0025\u0064\u0029\u0020\u0025\u0073",_cdeb ,_fgba ,_efeb .Error ());
return _gcbgf ,_g .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065a\u0064\u0069\u006e\u0067");};_fgba ++;_gcbgf +=_cdeb ;_eegf -=_cdeb ;};return _gcbgf ,nil ;};func _efga (_dgdg *PdfObjectStream ,_caec *PdfObjectDictionary )(*RunLengthEncoder ,error ){return NewRunLengthEncoder (),nil ;
};

// NewASCII85Encoder makes a new ASCII85 encoder.
func NewASCII85Encoder ()*ASCII85Encoder {_bgff :=&ASCII85Encoder {};return _bgff };func _fdaf (_eced string )(int ,int ,error ){_agbbb :=_dgbd .FindStringSubmatch (_eced );if len (_agbbb )< 3{return 0,0,_g .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");
};_eggg ,_ :=_b .Atoi (_agbbb [1]);_ede ,_ :=_b .Atoi (_agbbb [2]);return _eggg ,_ede ,nil ;};

// ToIntegerArray returns a slice of all array elements as an int slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_bbgc *PdfObjectArray )ToIntegerArray ()([]int ,error ){var _gage []int ;for _ ,_adge :=range _bbgc .Elements (){if _bcgce ,_cagf :=_adge .(*PdfObjectInteger );_cagf {_gage =append (_gage ,int (*_bcgce ));}else {return nil ,ErrTypeError ;};};return _gage ,nil ;
};

// ResolveReferencesDeep recursively traverses through object `o`, looking up and replacing
// references with indirect objects.
// Optionally a map of already deep-resolved objects can be provided via `traversed`. The `traversed` map
// is updated while traversing the objects to avoid traversing same objects multiple times.
func ResolveReferencesDeep (o PdfObject ,traversed map[PdfObject ]struct{})error {if traversed ==nil {traversed =map[PdfObject ]struct{}{};};return _dgbbg (o ,0,traversed );};

// GetFilterName returns the name of the encoding filter.
func (_gadc *RawEncoder )GetFilterName ()string {return StreamEncodingFilterNameRaw };func (_ceed *JBIG2Encoder )encodeImage (_fgceg _fc .Image )([]byte ,error ){const _dafe ="e\u006e\u0063\u006f\u0064\u0065\u0049\u006d\u0061\u0067\u0065";_babc ,_cbffe :=GoImageToJBIG2 (_fgceg ,JB2ImageAutoThreshold );
if _cbffe !=nil {return nil ,_bb .Wrap (_cbffe ,_dafe ,"\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069m\u0061g\u0065\u0020\u0074\u006f\u0020\u006a\u0062\u0069\u0067\u0032\u0020\u0069\u006d\u0067");};if _cbffe =_ceed .AddPageImage (_babc ,&_ceed .DefaultPageSettings );
_cbffe !=nil {return nil ,_bb .Wrap (_cbffe ,_dafe ,"");};return _ceed .Encode ();};var _gbacd =_ab .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064+\u0029\u005c\u0073\u002b\u0028\u005b\u006e\u0066\u005d\u0029\\\u0073\u002a\u0024");


// String returns a string representation of the *PdfObjectString.
func (_cebg *PdfObjectString )String ()string {return _cebg ._aaccd };

// AddPageImage adds the page with the image 'img' to the encoder context in order to encode it jbig2 document.
// The 'settings' defines what encoding type should be used by the encoder.
func (_agfcg *JBIG2Encoder )AddPageImage (img *JBIG2Image ,settings *JBIG2EncoderSettings )(_eebf error ){const _cgge ="\u004a\u0042\u0049\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0041\u0064\u0064\u0050\u0061\u0067\u0065\u0049m\u0061\u0067\u0065";
if _agfcg ==nil {return _bb .Error (_cgge ,"J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u0020\u0069\u0073 n\u0069\u006c");};if settings ==nil {settings =&_agfcg .DefaultPageSettings ;};if _agfcg ._bfdf ==nil {_agfcg ._bfdf =_ef .InitEncodeDocument (settings .FileMode );
};if _eebf =settings .Validate ();_eebf !=nil {return _bb .Wrap (_eebf ,_cgge ,"");};_bgbd ,_eebf :=img .toBitmap ();if _eebf !=nil {return _bb .Wrap (_eebf ,_cgge ,"");};switch settings .Compression {case JB2Generic :if _eebf =_agfcg ._bfdf .AddGenericPage (_bgbd ,settings .DuplicatedLinesRemoval );
_eebf !=nil {return _bb .Wrap (_eebf ,_cgge ,"");};case JB2SymbolCorrelation :return _bb .Error (_cgge ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
case JB2SymbolRankHaus :return _bb .Error (_cgge ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
default:return _bb .Error (_cgge ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return nil ;};

// DecodeBytes decodes a slice of LZW encoded bytes and returns the result.
func (_dbg *LZWEncoder )DecodeBytes (encoded []byte )([]byte ,error ){var _bde _fd .Buffer ;_dece :=_fd .NewReader (encoded );var _fdda _c .ReadCloser ;if _dbg .EarlyChange ==1{_fdda =_de .NewReader (_dece ,_de .MSB ,8);}else {_fdda =_fa .NewReader (_dece ,_fa .MSB ,8);
};defer _fdda .Close ();if _ ,_bege :=_bde .ReadFrom (_fdda );_bege !=nil {if _bege !=_c .ErrUnexpectedEOF ||_bde .Len ()==0{return nil ,_bege ;};_fg .Log .Debug ("\u0057\u0041\u0052\u004e\u003a\u0020\u004c\u005a\u0057\u0020\u0064\u0065\u0063\u006f\u0064i\u006e\u0067\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076\u002e \u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062e \u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u002e",_bege );
};return _bde .Bytes (),nil ;};func (_bed *PdfCrypt )decryptBytes (_ffb []byte ,_fcc string ,_acd []byte )([]byte ,error ){_fg .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");_acdb ,_caa :=_bed ._egg [_fcc ];
if !_caa {return nil ,_be .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_fcc );};return _acdb .DecryptBytes (_ffb ,_acd );};func (_cgef *PdfParser )parseHexString ()(*PdfObjectString ,error ){_cgef ._eeaf .ReadByte ();
var _cgdb _fd .Buffer ;for {_dfgaf ,_cffc :=_cgef ._eeaf .Peek (1);if _cffc !=nil {return MakeString (""),_cffc ;};if _dfgaf [0]=='>'{_cgef ._eeaf .ReadByte ();break ;};_fabe ,_ :=_cgef ._eeaf .ReadByte ();if !IsWhiteSpace (_fabe ){_cgdb .WriteByte (_fabe );
};};if _cgdb .Len ()%2==1{_cgdb .WriteRune ('0');};_gccb ,_ :=_bg .DecodeString (_cgdb .String ());return MakeHexString (string (_gccb )),nil ;};

// PdfCryptNewDecrypt makes the document crypt handler based on the encryption dictionary
// and trailer dictionary. Returns an error on failure to process.
func PdfCryptNewDecrypt (parser *PdfParser ,ed ,trailer *PdfObjectDictionary )(*PdfCrypt ,error ){_bgc :=&PdfCrypt {_eeb :false ,_ffe :make (map[PdfObject ]bool ),_bbba :make (map[PdfObject ]bool ),_bcg :make (map[int ]struct{}),_daf :parser };_gcgc ,_bfeb :=ed .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectName );
if !_bfeb {_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0043\u0072\u0079\u0070\u0074 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061r\u0079 \u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u0066\u0069\u0065\u006c\u0064\u0021");
return _bgc ,_g .New ("r\u0065\u0071\u0075\u0069\u0072\u0065d\u0020\u0063\u0072\u0079\u0070\u0074 \u0066\u0069\u0065\u006c\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u006d\u0069\u0073\u0073\u0069n\u0067");};if *_gcgc !="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"{_fg .Log .Debug ("\u0045\u0052R\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020(%\u0073\u0029",*_gcgc );
return _bgc ,_g .New ("\u0075n\u0073u\u0070\u0070\u006f\u0072\u0074e\u0064\u0020F\u0069\u006c\u0074\u0065\u0072");};_bgc ._baf .Filter =string (*_gcgc );if _cad ,_ebc :=ed .Get ("\u0053u\u0062\u0046\u0069\u006c\u0074\u0065r").(*PdfObjectString );_ebc {_bgc ._baf .SubFilter =_cad .Str ();
_fg .Log .Debug ("\u0055s\u0069n\u0067\u0020\u0073\u0075\u0062f\u0069\u006ct\u0065\u0072\u0020\u0025\u0073",_cad );};if L ,_cce :=ed .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );_cce {if (*L %8)!=0{_fg .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0049\u006ev\u0061\u006c\u0069\u0064\u0020\u0065\u006ec\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006c\u0065\u006e\u0067\u0074\u0068");
return _bgc ,_g .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0065\u006e\u0063\u0072y\u0070t\u0069o\u006e\u0020\u006c\u0065\u006e\u0067\u0074h");};_bgc ._baf .Length =int (*L );}else {_bgc ._baf .Length =40;};_bgc ._baf .V =0;if _dfc ,_daef :=ed .Get ("\u0056").(*PdfObjectInteger );
_daef {V :=int (*_dfc );_bgc ._baf .V =V ;if V >=1&&V <=2{_bgc ._egg =_defe (_bgc ._baf .Length );}else if V >=4&&V <=5{if _geb :=_bgc .loadCryptFilters (ed );_geb !=nil {return _bgc ,_geb ;};}else {_fg .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0061lg\u006f\u0020\u0056 \u003d \u0025\u0064",V );
return _bgc ,_g .New ("u\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d");};};if _aacg :=_edfg (&_bgc ._aea ,ed );_aacg !=nil {return _bgc ,_aacg ;};_beef :="";if _cff ,_cagc :=trailer .Get ("\u0049\u0044").(*PdfObjectArray );
_cagc &&_cff .Len ()>=1{_aacc ,_dbc :=GetString (_cff .Get (0));if !_dbc {return _bgc ,_g .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0074r\u0061\u0069l\u0065\u0072\u0020\u0049\u0044");};_beef =_aacc .Str ();}else {_fg .Log .Debug ("\u0054\u0072ai\u006c\u0065\u0072 \u0049\u0044\u0020\u0061rra\u0079 m\u0069\u0073\u0073\u0069\u006e\u0067\u0020or\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0021");
};_bgc ._bdad =_beef ;return _bgc ,nil ;};func (_ebf *PdfCrypt )newEncryptDict ()*PdfObjectDictionary {_cda :=MakeDict ();_cda .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName ("\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"));_cda .Set ("\u0056",MakeInteger (int64 (_ebf ._baf .V )));
_cda .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_ebf ._baf .Length )));return _cda ;};func (_gef *PdfCrypt )isEncrypted (_gcf PdfObject )bool {_ ,_bdf :=_gef ._bbba [_gcf ];if _bdf {_fg .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0065\u006e\u0063\u0072y\u0070\u0074\u0065\u0064");
return true ;};_fg .Log .Trace ("\u004e\u006f\u0074\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");return false ;};var _cfbdb _ae .Map ;

// DecodeBytes decodes byte array with ASCII85. 5 ASCII characters -> 4 raw binary bytes
func (_bgae *ASCII85Encoder )DecodeBytes (encoded []byte )([]byte ,error ){var _bfc []byte ;_fg .Log .Trace ("\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0020\u0044e\u0063\u006f\u0064\u0065");_eegb :=0;_gaefa :=false ;for _eegb < len (encoded )&&!_gaefa {_edda :=[5]byte {0,0,0,0,0};
_abfg :=0;_dfac :=0;_ceg :=4;for _dfac < 5+_abfg {if _eegb +_dfac ==len (encoded ){break ;};_ddfa :=encoded [_eegb +_dfac ];if IsWhiteSpace (_ddfa ){_abfg ++;_dfac ++;continue ;}else if _ddfa =='~'&&_eegb +_dfac +1< len (encoded )&&encoded [_eegb +_dfac +1]=='>'{_ceg =(_dfac -_abfg )-1;
if _ceg < 0{_ceg =0;};_gaefa =true ;break ;}else if _ddfa >='!'&&_ddfa <='u'{_ddfa -='!';}else if _ddfa =='z'&&_dfac -_abfg ==0{_ceg =4;_dfac ++;break ;}else {_fg .Log .Error ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u002c\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020co\u0064\u0065");
return nil ,_g .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0063\u006f\u0064\u0065\u0020e\u006e\u0063\u006f\u0075\u006e\u0074\u0065\u0072\u0065\u0064");};_edda [_dfac -_abfg ]=_ddfa ;_dfac ++;};_eegb +=_dfac ;for _cbdg :=_ceg +1;_cbdg < 5;_cbdg ++{_edda [_cbdg ]=84;
};_gcdc :=uint32 (_edda [0])*85*85*85*85+uint32 (_edda [1])*85*85*85+uint32 (_edda [2])*85*85+uint32 (_edda [3])*85+uint32 (_edda [4]);_egcf :=[]byte {byte ((_gcdc >>24)&0xff),byte ((_gcdc >>16)&0xff),byte ((_gcdc >>8)&0xff),byte (_gcdc &0xff)};_bfc =append (_bfc ,_egcf [:_ceg ]...);
};_fg .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0065\u006e\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",encoded );_fg .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0064\u0065\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",_bfc );
return _bfc ,nil ;};

// Str returns the string value of the PdfObjectString. Defined in addition to String() function to clarify that
// this function returns the underlying string directly, whereas the String function technically could include
// debug info.
func (_dgfgb *PdfObjectString )Str ()string {return _dgfgb ._aaccd };

// DecodeStream decodes a DCT encoded stream and returns the result as a
// slice of bytes.
func (_eedc *DCTEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _eedc .DecodeBytes (streamObj .Stream );};func (_eed *PdfCrypt )checkAccessRights (_cfa []byte )(bool ,_bda .Permissions ,error ){_ddd :=_eed .securityHandler ();
_cccc ,_bad ,_acc :=_ddd .Authenticate (&_eed ._aea ,_cfa );if _acc !=nil {return false ,0,_acc ;}else if _bad ==0||len (_cccc )==0{return false ,0,nil ;};return true ,_bad ,nil ;};func (_gfdg *PdfParser )parseXrefStream (_cbae *PdfObjectInteger )(*PdfObjectDictionary ,error ){if _cbae !=nil {_fg .Log .Trace ("\u0058\u0052\u0065f\u0053\u0074\u006d\u0020x\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0061\u0074\u0020\u0025\u0064",_cbae );
_gfdg ._cbfb .Seek (int64 (*_cbae ),_c .SeekStart );_gfdg ._eeaf =_bd .NewReader (_gfdg ._cbfb );};_afbd :=_gfdg .GetFileOffset ();_cegeg ,_gcaf :=_gfdg .ParseIndirectObject ();if _gcaf !=nil {_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072\u0065\u0061d\u0020\u0078\u0072\u0065\u0066\u0020\u006fb\u006a\u0065\u0063\u0074");
return nil ,_g .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072e\u0061\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062j\u0065\u0063\u0074");};_fg .Log .Trace ("\u0058R\u0065f\u0053\u0074\u006d\u0020\u006fb\u006a\u0065c\u0074\u003a\u0020\u0025\u0073",_cegeg );
_ebdcd ,_ffdfa :=_cegeg .(*PdfObjectStream );if !_ffdfa {_fg .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0058R\u0065\u0066\u0053\u0074\u006d\u0020\u0070o\u0069\u006e\u0074\u0069\u006e\u0067 \u0074\u006f\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065a\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0021");
return nil ,_g .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0070\u006f\u0069\u006e\u0074i\u006e\u0067\u0020\u0074\u006f\u0020a\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006fb\u006a\u0065\u0063\u0074");};_ccfb :=_ebdcd .PdfObjectDictionary ;
_afgc ,_ffdfa :=_ebdcd .PdfObjectDictionary .Get ("\u0053\u0069\u007a\u0065").(*PdfObjectInteger );if !_ffdfa {_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u004d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0073\u0069\u007a\u0065\u0020f\u0072\u006f\u006d\u0020\u0078\u0072\u0065f\u0020\u0073\u0074\u006d");
return nil ,_g .New ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0053\u0069\u007ae\u0020\u0066\u0072\u006f\u006d\u0020\u0078\u0072\u0065\u0066 \u0073\u0074\u006d");};if int64 (*_afgc )> 8388607{_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u0053\u0069\u007a\u0065\u0020\u0065x\u0063\u0065\u0065\u0064\u0065\u0064\u0020l\u0069\u006d\u0069\u0074\u002c\u0020\u006f\u0076\u0065\u0072\u00208\u0033\u0038\u0038\u0036\u0030\u0037\u0020\u0028\u0025\u0064\u0029",*_afgc );
return nil ,_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_aacdg :=_ebdcd .PdfObjectDictionary .Get ("\u0057");_cbe ,_ffdfa :=_aacdg .(*PdfObjectArray );if !_ffdfa {return nil ,_g .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0057\u0020\u0069\u006e\u0020x\u0072\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d");
};_gcga :=_cbe .Len ();if _gcga !=3{_fg .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020\u0028\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033\u0020\u002d\u0020\u0025\u0064\u0029",_gcga );
return nil ,_g .New ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065f\u0020s\u0074\u006d\u0020\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033");};var _begc []int64 ;for _ecgaaf :=0;_ecgaaf < 3;
_ecgaaf ++{_becga ,_dcadb :=GetInt (_cbe .Get (_ecgaaf ));if !_dcadb {return nil ,_g .New ("i\u006e\u0076\u0061\u006cid\u0020w\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0074\u0079\u0070\u0065");};_begc =append (_begc ,int64 (*_becga ));};_agc ,_gcaf :=DecodeStream (_ebdcd );
if _gcaf !=nil {_fg .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020t\u006f \u0064e\u0063o\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u003a\u0020\u0025\u0076",_gcaf );return nil ,_gcaf ;};_fagb :=int (_begc [0]);
_agcf :=int (_begc [0]+_begc [1]);_fbbd :=int (_begc [0]+_begc [1]+_begc [2]);_bebfd :=int (_begc [0]+_begc [1]+_begc [2]);if _fagb < 0||_agcf < 0||_fbbd < 0{_fg .Log .Debug ("\u0045\u0072\u0072\u006fr\u0020\u0073\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u003c \u0030 \u0028\u0025\u0064\u002c\u0025\u0064\u002c%\u0064\u0029",_fagb ,_agcf ,_fbbd );
return nil ,_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};if _bebfd ==0{_fg .Log .Debug ("\u004e\u006f\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063t\u0073\u0020\u0069\u006e\u0020\u0073t\u0072\u0065\u0061\u006d\u0020\u0028\u0064\u0065\u006c\u0074\u0061\u0062\u0020=\u003d\u0020\u0030\u0029");
return _ccfb ,nil ;};_ggdf :=len (_agc )/_bebfd ;_dcdd :=0;_ddgd :=_ebdcd .PdfObjectDictionary .Get ("\u0049\u006e\u0064e\u0078");var _agdg []int ;if _ddgd !=nil {_fg .Log .Trace ("\u0049n\u0064\u0065\u0078\u003a\u0020\u0025b",_ddgd );_fcac ,_ddcd :=_ddgd .(*PdfObjectArray );
if !_ddcd {_fg .Log .Debug ("\u0049\u006e\u0076\u0061\u006ci\u0064\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0029");
return nil ,_g .New ("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0049\u006e\u0064e\u0078\u0020\u006f\u0062je\u0063\u0074");};if _fcac .Len ()%2!=0{_fg .Log .Debug ("\u0057\u0041\u0052\u004eI\u004e\u0047\u0020\u0046\u0061\u0069\u006c\u0075\u0072e\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020i\u006e\u0064\u0065\u0078\u0020n\u006f\u0074\u0020\u006d\u0075\u006c\u0074\u0069\u0070\u006c\u0065\u0020\u006f\u0066\u0020\u0032\u002e");
return nil ,_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_dcdd =0;_fcfea ,_efaf :=_fcac .ToIntegerArray ();if _efaf !=nil {_fg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072 \u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0065\u0078 \u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0073\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0073\u003a\u0020\u0025\u0076",_efaf );
return nil ,_efaf ;};for _aeae :=0;_aeae < len (_fcfea );_aeae +=2{_aece :=_fcfea [_aeae ];_cggcf :=_fcfea [_aeae +1];for _cfec :=0;_cfec < _cggcf ;_cfec ++{_agdg =append (_agdg ,_aece +_cfec );};_dcdd +=_cggcf ;};}else {for _cbg :=0;_cbg < int (*_afgc );
_cbg ++{_agdg =append (_agdg ,_cbg );};_dcdd =int (*_afgc );};if _ggdf ==_dcdd +1{_fg .Log .Debug ("\u0049n\u0063\u006f\u006d\u0070ati\u0062\u0069\u006c\u0069t\u0079\u003a\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006di\u0073\u0073\u0069\u006e\u0067\u0020\u0063\u006f\u0076\u0065\u0072\u0061\u0067\u0065\u0020\u006f\u0066\u0020\u0031\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u002d\u0020\u0061\u0070\u0070en\u0064\u0069\u006eg\u0020\u006f\u006e\u0065\u0020-\u0020M\u0061\u0079\u0020\u006c\u0065\u0061\u0064\u0020\u0074o\u0020\u0070\u0072\u006f\u0062\u006c\u0065\u006d\u0073");
_aded :=_dcdd -1;for _ ,_gfa :=range _agdg {if _gfa > _aded {_aded =_gfa ;};};_agdg =append (_agdg ,_aded +1);_dcdd ++;};if _ggdf !=len (_agdg ){_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020x\u0072\u0065\u0066 \u0073\u0074\u006d:\u0020\u006eu\u006d\u0020\u0065\u006e\u0074\u0072i\u0065s \u0021\u003d\u0020\u006c\u0065\u006e\u0028\u0069\u006e\u0064\u0069\u0063\u0065\u0073\u0029\u0020\u0028\u0025\u0064\u0020\u0021\u003d\u0020\u0025\u0064\u0029",_ggdf ,len (_agdg ));
return nil ,_g .New ("\u0078\u0072ef\u0020\u0073\u0074m\u0020\u006e\u0075\u006d en\u0074ri\u0065\u0073\u0020\u0021\u003d\u0020\u006cen\u0028\u0069\u006e\u0064\u0069\u0063\u0065s\u0029");};_fg .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074s\u0020\u0063\u006f\u0075\u006e\u0074\u0020\u0025\u0064",_dcdd );
_fg .Log .Trace ("\u0049\u006e\u0064i\u0063\u0065\u0073\u003a\u0020\u0025\u0020\u0064",_agdg );_cccgg :=func (_cgee []byte )int64 {var _bebd int64 ;for _febd :=0;_febd < len (_cgee );_febd ++{_bebd +=int64 (_cgee [_febd ])*(1<<uint (8*(len (_cgee )-_febd -1)));
};return _bebd ;};_fg .Log .Trace ("\u0044e\u0063\u006f\u0064\u0065d\u0020\u0073\u0074\u0072\u0065a\u006d \u006ce\u006e\u0067\u0074\u0068\u003a\u0020\u0025d",len (_agc ));_gece :=0;for _acdgg :=0;_acdgg < len (_agc );_acdgg +=_bebfd {_gadb :=_faed (len (_agc ),_acdgg ,_acdgg +_fagb );
if _gadb !=nil {_fg .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_gadb );return nil ,_gadb ;};_cebef :=_agc [_acdgg :_acdgg +_fagb ];_gadb =_faed (len (_agc ),_acdgg +_fagb ,_acdgg +_agcf );
if _gadb !=nil {_fg .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_gadb );return nil ,_gadb ;};_cfgdf :=_agc [_acdgg +_fagb :_acdgg +_agcf ];_gadb =_faed (len (_agc ),_acdgg +_agcf ,_acdgg +_fbbd );
if _gadb !=nil {_fg .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_gadb );return nil ,_gadb ;};_fbgb :=_agc [_acdgg +_agcf :_acdgg +_fbbd ];_gcafe :=_cccgg (_cebef );
_abfb :=_cccgg (_cfgdf );_aeab :=_cccgg (_fbgb );if _begc [0]==0{_gcafe =1;};if _gece >=len (_agdg ){_fg .Log .Debug ("X\u0052\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u002d\u0020\u0054\u0072\u0079\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0061\u0063\u0063e\u0073s\u0020\u0069\u006e\u0064e\u0078\u0020o\u0075\u0074\u0020\u006f\u0066\u0020\u0062\u006f\u0075\u006e\u0064\u0073\u0020\u002d\u0020\u0062\u0072\u0065\u0061\u006b\u0069\u006e\u0067");
break ;};_dfgad :=_agdg [_gece ];_gece ++;_fg .Log .Trace ("%\u0064\u002e\u0020\u0070\u0031\u003a\u0020\u0025\u0020\u0078",_dfgad ,_cebef );_fg .Log .Trace ("%\u0064\u002e\u0020\u0070\u0032\u003a\u0020\u0025\u0020\u0078",_dfgad ,_cfgdf );_fg .Log .Trace ("%\u0064\u002e\u0020\u0070\u0033\u003a\u0020\u0025\u0020\u0078",_dfgad ,_fbgb );
_fg .Log .Trace ("\u0025d\u002e \u0078\u0072\u0065\u0066\u003a \u0025\u0064 \u0025\u0064\u0020\u0025\u0064",_dfgad ,_gcafe ,_abfb ,_aeab );if _gcafe ==0{_fg .Log .Trace ("-\u0020\u0046\u0072\u0065\u0065\u0020o\u0062\u006a\u0065\u0063\u0074\u0020-\u0020\u0063\u0061\u006e\u0020\u0070\u0072o\u0062\u0061\u0062\u006c\u0079\u0020\u0069\u0067\u006e\u006fr\u0065");
}else if _gcafe ==1{_fg .Log .Trace ("\u002d\u0020I\u006e\u0020\u0075\u0073e\u0020\u002d \u0075\u006e\u0063\u006f\u006d\u0070\u0072\u0065s\u0073\u0065\u0064\u0020\u0076\u0069\u0061\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0062",_cfgdf );if _abfb ==_afbd {_fg .Log .Debug ("\u0055\u0070d\u0061\u0074\u0069\u006e\u0067\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0058\u0052\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0064",_dfgad ,_ebdcd .ObjectNumber );
_dfgad =int (_ebdcd .ObjectNumber );};if _fbeb ,_ccgf :=_gfdg ._dfb .ObjectMap [_dfgad ];!_ccgf ||int (_aeab )> _fbeb .Generation {_afdg :=XrefObject {ObjectNumber :_dfgad ,XType :XrefTypeTableEntry ,Offset :_abfb ,Generation :int (_aeab )};_gfdg ._dfb .ObjectMap [_dfgad ]=_afdg ;
};}else if _gcafe ==2{_fg .Log .Trace ("\u002d\u0020\u0049\u006e \u0075\u0073\u0065\u0020\u002d\u0020\u0063\u006f\u006d\u0070r\u0065s\u0073\u0065\u0064\u0020\u006f\u0062\u006ae\u0063\u0074");if _ ,_dcdce :=_gfdg ._dfb .ObjectMap [_dfgad ];!_dcdce {_gddcc :=XrefObject {ObjectNumber :_dfgad ,XType :XrefTypeObjectStream ,OsObjNumber :int (_abfb ),OsObjIndex :int (_aeab )};
_gfdg ._dfb .ObjectMap [_dfgad ]=_gddcc ;_fg .Log .Trace ("\u0065\u006e\u0074\u0072\u0079\u003a\u0020\u0025\u002b\u0076",_gddcc );};}else {_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052:\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0056\u0041L\u0049\u0044\u0020\u0054\u0059\u0050\u0045\u0020\u0058\u0072\u0065\u0066\u0053\u0074\u006d\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u003f\u002d\u002d\u002d\u002d\u002d\u002d-");
continue ;};};if _gfdg ._acfg ==nil {_aaed :=XrefTypeObjectStream ;_gfdg ._acfg =&_aaed ;};return _ccfb ,nil ;};

// NewFlateEncoder makes a new flate encoder with default parameters, predictor 1 and bits per component 8.
func NewFlateEncoder ()*FlateEncoder {_ebcg :=&FlateEncoder {};_ebcg .Predictor =1;_ebcg .BitsPerComponent =8;_ebcg .Colors =1;_ebcg .Columns =1;return _ebcg ;};

// DecodeBytes decodes a slice of JBIG2 encoded bytes and returns the results.
func (_geee *JBIG2Encoder )DecodeBytes (encoded []byte )([]byte ,error ){return _gg .DecodeBytes (encoded ,_ecg .Parameters {},_geee .Globals );};func _bbbb (_effdd PdfObject ,_fadgc int )PdfObject {if _fadgc > _ddgf {_fg .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_ddgf );
return MakeNull ();};switch _fgdc :=_effdd .(type ){case *PdfIndirectObject :_effdd =_bbbb ((*_fgdc ).PdfObject ,_fadgc +1);case *PdfObjectArray :for _fdfbd ,_afacc :=range (*_fgdc )._eadg {(*_fgdc )._eadg [_fdfbd ]=_bbbb (_afacc ,_fadgc +1);};case *PdfObjectDictionary :for _cefg ,_adcaf :=range (*_fgdc )._ggbc {(*_fgdc )._ggbc [_cefg ]=_bbbb (_adcaf ,_fadgc +1);
};_f .Slice ((*_fgdc )._cabe ,func (_bebg ,_aaee int )bool {return (*_fgdc )._cabe [_bebg ]< (*_fgdc )._cabe [_aaee ]});};return _effdd ;};func (_ge *PdfParser )lookupByNumber (_bcc int ,_becg bool )(PdfObject ,bool ,error ){_gge ,_agb :=_ge .ObjCache [_bcc ];
if _agb {_fg .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0063a\u0063\u0068\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0025\u0064",_bcc );return _gge ,false ,nil ;};if _ge ._gbaa ==nil {_ge ._gbaa =map[int ]bool {};
};if _ge ._gbaa [_bcc ]{_fg .Log .Debug ("ER\u0052\u004f\u0052\u003a\u0020\u004c\u006fok\u0075\u0070\u0020\u006f\u0066\u0020\u0025\u0064\u0020\u0069\u0073\u0020\u0061\u006c\u0072e\u0061\u0064\u0079\u0020\u0069\u006e\u0020\u0070\u0072\u006f\u0067\u0072\u0065\u0073\u0073\u0020\u002d\u0020\u0072\u0065c\u0075\u0072\u0073\u0069\u0076\u0065 \u006c\u006f\u006f\u006b\u0075\u0070\u0020\u0061\u0074t\u0065m\u0070\u0074\u0020\u0062\u006c\u006f\u0063\u006b\u0065\u0064",_bcc );
return nil ,false ,_g .New ("\u0072\u0065\u0063\u0075\u0072\u0073\u0069\u0076\u0065\u0020\u006c\u006f\u006f\u006b\u0075p\u0020a\u0074\u0074\u0065\u006d\u0070\u0074\u0020\u0062\u006c\u006f\u0063\u006b\u0065\u0064");};_ge ._gbaa [_bcc ]=true ;defer delete (_ge ._gbaa ,_bcc );
_dg ,_agb :=_ge ._dfb .ObjectMap [_bcc ];if !_agb {_fg .Log .Trace ("\u0055\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u006c\u006f\u0063\u0061t\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0069\u006e\u0020\u0078\u0072\u0065\u0066\u0073\u0021 \u002d\u0020\u0052\u0065\u0074u\u0072\u006e\u0069\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074");
var _eec PdfObjectNull ;return &_eec ,false ,nil ;};_fg .Log .Trace ("L\u006fo\u006b\u0075\u0070\u0020\u006f\u0062\u006a\u0020n\u0075\u006d\u0062\u0065r \u0025\u0064",_bcc );if _dg .XType ==XrefTypeTableEntry {_fg .Log .Trace ("\u0078r\u0065f\u006f\u0062\u006a\u0020\u006fb\u006a\u0020n\u0075\u006d\u0020\u0025\u0064",_dg .ObjectNumber );
_fg .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u0067e\u006e\u0020\u0025\u0064",_dg .Generation );_fg .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0064",_dg .Offset );_ge ._cbfb .Seek (_dg .Offset ,_c .SeekStart );
_ge ._eeaf =_bd .NewReader (_ge ._cbfb );_bbb ,_fdfd :=_ge .ParseIndirectObject ();if _fdfd !=nil {_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006ce\u0064\u0020\u0072\u0065\u0061\u0064\u0069n\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029",_fdfd );
if _becg {_fg .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0072\u0065\u0070\u0061\u0069r\u0020\u0078\u0072\u0065\u0066\u0073\u0020\u0028\u0074\u006f\u0070\u0020d\u006f\u0077\u006e\u0029");_bbf ,_gb :=_ge .repairRebuildXrefsTopDown ();
if _gb !=nil {_fg .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020r\u0065\u0070\u0061\u0069\u0072\u0020\u0028\u0025\u0073\u0029",_gb );return nil ,false ,_gb ;};_ge ._dfb =*_bbf ;return _ge .lookupByNumber (_bcc ,false );
};return nil ,false ,_fdfd ;};if _becg {_gaef ,_ ,_ :=_ca (_bbb );if int (_gaef )!=_bcc {_fg .Log .Debug ("\u0049n\u0076\u0061\u006c\u0069d\u0020\u0078\u0072\u0065\u0066s\u003a \u0052e\u0062\u0075\u0069\u006c\u0064\u0069\u006eg");_fgc :=_ge .rebuildXrefTable ();
if _fgc !=nil {return nil ,false ,_fgc ;};_ge .ObjCache =objectCache {};return _ge .lookupByNumberWrapper (_bcc ,false );};};_fg .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006f\u0062\u006a");_ge .ObjCache [_bcc ]=_bbb ;
return _bbb ,false ,nil ;}else if _dg .XType ==XrefTypeObjectStream {_fg .Log .Trace ("\u0078r\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0021");_fg .Log .Trace ("\u003e\u004c\u006f\u0061\u0064\u0020\u0076\u0069\u0061\u0020\u004f\u0053\u0021");
_fg .Log .Trace ("\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d \u0061\u0076\u0061\u0069\u006c\u0061b\u006c\u0065\u0020\u0069\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020%\u0064\u002f\u0025\u0064",_dg .OsObjNumber ,_dg .OsObjIndex );
if _dg .OsObjNumber ==_bcc {_fg .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0043i\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065f\u0065\u0072\u0065n\u0063e\u0021\u003f\u0021");return nil ,true ,_g .New ("\u0078\u0072\u0065f \u0063\u0069\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");
};if _ ,_fe :=_ge ._dfb .ObjectMap [_dg .OsObjNumber ];_fe {_gaf ,_ce :=_ge .lookupObjectViaOS (_dg .OsObjNumber ,_bcc );if _ce !=nil {_fg .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0052\u0065\u0074\u0075\u0072\u006e\u0069n\u0067\u0020\u0045\u0052\u0052\u0020\u0028\u0025\u0073\u0029",_ce );
return nil ,true ,_ce ;};_fg .Log .Trace ("\u003c\u004c\u006f\u0061\u0064\u0065\u0064\u0020\u0076i\u0061\u0020\u004f\u0053");_ge .ObjCache [_bcc ]=_gaf ;if _ge ._ggab !=nil {_ge ._ggab ._ffe [_gaf ]=true ;};return _gaf ,true ,nil ;};_fg .Log .Debug ("\u003f\u003f\u0020\u0042\u0065\u006c\u006f\u006eg\u0073\u0020\u0074o \u0061\u0020\u006e\u006f\u006e\u002dc\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u002e.\u002e\u0021");
return nil ,true ,_g .New ("\u006f\u0073\u0020\u0062\u0065\u006c\u006fn\u0067\u0073\u0020t\u006f\u0020\u0061\u0020n\u006f\u006e\u0020\u0063\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074");
};return nil ,false ,_g .New ("\u0075\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0078\u0072\u0065\u0066 \u0074\u0079\u0070\u0065");};

// WriteString outputs the object as it is to be written to file.
func (_faab *PdfObjectInteger )WriteString ()string {return _b .FormatInt (int64 (*_faab ),10)};

// NewParser creates a new parser for a PDF file via ReadSeeker. Loads the cross reference stream and trailer.
// An error is returned on failure.
func NewParser (rs _c .ReadSeeker )(*PdfParser ,error ){_gdcc :=&PdfParser {_cbfb :rs ,ObjCache :make (objectCache ),_abec :map[int64 ]bool {}};_bafb ,_dac ,_cffgc :=_gdcc .parsePdfVersion ();if _cffgc !=nil {_fg .Log .Error ("U\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0076e\u0072\u0073\u0069o\u006e:\u0020\u0025\u0076",_cffgc );
return nil ,_cffgc ;};_gdcc ._ggaca .Major =_bafb ;_gdcc ._ggaca .Minor =_dac ;if _gdcc ._eaaa ,_cffgc =_gdcc .loadXrefs ();_cffgc !=nil {_fg .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020F\u0061\u0069\u006c\u0065d t\u006f l\u006f\u0061\u0064\u0020\u0078\u0072\u0065f \u0074\u0061\u0062\u006c\u0065\u0021\u0020%\u0073",_cffgc );
return nil ,_cffgc ;};_fg .Log .Trace ("T\u0072\u0061\u0069\u006c\u0065\u0072\u003a\u0020\u0025\u0073",_gdcc ._eaaa );if len (_gdcc ._dfb .ObjectMap )==0{return nil ,_be .Errorf ("\u0065\u006d\u0070\u0074\u0079\u0020\u0058\u0052\u0045\u0046\u0020t\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0049\u006e\u0076a\u006c\u0069\u0064");
};return _gdcc ,nil ;};func (_fcbc *PdfParser )parseNumber ()(PdfObject ,error ){return ParseNumber (_fcbc ._eeaf )};func (_agfa *PdfParser )readComment ()(string ,error ){var _cecfg _fd .Buffer ;_ ,_cebe :=_agfa .skipSpaces ();if _cebe !=nil {return _cecfg .String (),_cebe ;
};_gecb :=true ;for {_ecda ,_gabf :=_agfa ._eeaf .Peek (1);if _gabf !=nil {_fg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_gabf .Error ());return _cecfg .String (),_gabf ;};if _gecb &&_ecda [0]!='%'{return _cecfg .String (),_g .New ("c\u006f\u006d\u006d\u0065\u006e\u0074 \u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0073\u0074a\u0072\u0074\u0020w\u0069t\u0068\u0020\u0025");
};_gecb =false ;if (_ecda [0]!='\r')&&(_ecda [0]!='\n'){_cgeb ,_ :=_agfa ._eeaf .ReadByte ();_cecfg .WriteByte (_cgeb );}else {break ;};};return _cecfg .String (),nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_cebc *LZWEncoder )MakeStreamDict ()*PdfObjectDictionary {_bead :=MakeDict ();_bead .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_cebc .GetFilterName ()));_gbae :=_cebc .MakeDecodeParams ();if _gbae !=nil {_bead .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_gbae );
};_bead .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (int64 (_cebc .EarlyChange )));return _bead ;};

// NewMultiEncoder returns a new instance of MultiEncoder.
func NewMultiEncoder ()*MultiEncoder {_eafdg :=MultiEncoder {};_eafdg ._feab =[]StreamEncoder {};return &_eafdg ;};

// IsEncrypted checks if the document is encrypted. A bool flag is returned indicating the result.
// First time when called, will check if the Encrypt dictionary is accessible through the trailer dictionary.
// If encrypted, prepares a crypt datastructure which can be used to authenticate and decrypt the document.
// On failure, an error is returned.
func (_agaa *PdfParser )IsEncrypted ()(bool ,error ){if _agaa ._ggab !=nil {return true ,nil ;}else if _agaa ._eaaa ==nil {return false ,nil ;};_fg .Log .Trace ("\u0043\u0068\u0065c\u006b\u0069\u006e\u0067 \u0065\u006e\u0063\u0072\u0079\u0070\u0074i\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0021");
_fdeb :=_agaa ._eaaa .Get ("\u0045n\u0063\u0072\u0079\u0070\u0074");if _fdeb ==nil {return false ,nil ;};_fg .Log .Trace ("\u0049\u0073\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u0021");var (_ecdd *PdfObjectDictionary ;);switch _dga :=_fdeb .(type ){case *PdfObjectDictionary :_ecdd =_dga ;
case *PdfObjectReference :_fg .Log .Trace ("\u0030\u003a\u0020\u004c\u006f\u006f\u006b\u0020\u0075\u0070\u0020\u0072e\u0066\u0020\u0025\u0071",_dga );_efba ,_gdag :=_agaa .LookupByReference (*_dga );_fg .Log .Trace ("\u0031\u003a\u0020%\u0071",_efba );
if _gdag !=nil {return false ,_gdag ;};_cedf ,_badfd :=_efba .(*PdfIndirectObject );if !_badfd {_fg .Log .Debug ("E\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006eo\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072ec\u0074\u0020\u006fb\u006ae\u0063\u0074");
return false ,_g .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");};_fdege ,_badfd :=_cedf .PdfObject .(*PdfObjectDictionary );_fg .Log .Trace ("\u0032\u003a\u0020%\u0071",_fdege );if !_badfd {return false ,_g .New ("\u0074\u0072a\u0069\u006c\u0065\u0072 \u0045\u006ec\u0072\u0079\u0070\u0074\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u006e\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");
};_ecdd =_fdege ;case *PdfObjectNull :_fg .Log .Debug ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074 \u0069\u0073\u0020a\u0020\u006e\u0075l\u006c\u0020o\u0062\u006a\u0065\u0063\u0074\u002e \u0046il\u0065\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u002e");
return false ,nil ;default:return false ,_be .Errorf ("u\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0079\u0070\u0065: \u0025\u0054",_dga );};_cfaa ,_agaf :=PdfCryptNewDecrypt (_agaa ,_ecdd ,_agaa ._eaaa );if _agaf !=nil {return false ,_agaf ;
};for _ ,_agbf :=range []string {"\u0045n\u0063\u0072\u0079\u0070\u0074"}{_ggfa :=_agaa ._eaaa .Get (PdfObjectName (_agbf ));if _ggfa ==nil {continue ;};switch _affff :=_ggfa .(type ){case *PdfObjectReference :_cfaa ._bcg [int (_affff .ObjectNumber )]=struct{}{};
case *PdfIndirectObject :_cfaa ._ffe [_affff ]=true ;_cfaa ._bcg [int (_affff .ObjectNumber )]=struct{}{};};};_agaa ._ggab =_cfaa ;_fg .Log .Trace ("\u0043\u0072\u0079\u0070\u0074\u0065\u0072\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0025\u0062",_cfaa );
return true ,nil ;};

// GetFileOffset returns the current file offset, accounting for buffered position.
func (_dfff *PdfParser )GetFileOffset ()int64 {_acdd ,_ :=_dfff ._cbfb .Seek (0,_c .SeekCurrent );_acdd -=int64 (_dfff ._eeaf .Buffered ());return _acdd ;};

// FlattenObject returns the contents of `obj`. In other words, `obj` with indirect objects replaced
// by their values.
// The replacements are made recursively to a depth of traceMaxDepth.
// NOTE: Dicts are sorted to make objects with same contents have the same PDF object strings.
func FlattenObject (obj PdfObject )PdfObject {return _bbbb (obj ,0)};

// IsDelimiter checks if a character represents a delimiter.
func IsDelimiter (c byte )bool {return c =='('||c ==')'||c =='<'||c =='>'||c =='['||c ==']'||c =='{'||c =='}'||c =='/'||c =='%';};

// JPXEncoder implements JPX encoder/decoder (dummy, for now)
// FIXME: implement
type JPXEncoder struct{};

// Len returns the number of elements in the array.
func (_affbgc *PdfObjectArray )Len ()int {if _affbgc ==nil {return 0;};return len (_affbgc ._eadg );};type cryptFilters map[string ]_ed .Filter ;const JB2ImageAutoThreshold =-1.0;

// EncodeJBIG2Image encodes 'img' into jbig2 encoded bytes stream, using default encoder settings.
func (_bbeba *JBIG2Encoder )EncodeJBIG2Image (img *JBIG2Image )([]byte ,error ){const _afeg ="c\u006f\u0072\u0065\u002eEn\u0063o\u0064\u0065\u004a\u0042\u0049G\u0032\u0049\u006d\u0061\u0067\u0065";if _eggb :=_bbeba .AddPageImage (img ,&_bbeba .DefaultPageSettings );
_eggb !=nil {return nil ,_bb .Wrap (_eggb ,_afeg ,"");};return _bbeba .Encode ();};

// GetAsFloat64Slice returns the array as []float64 slice.
// Returns an error if not entirely numeric (only PdfObjectIntegers, PdfObjectFloats).
func (_gbba *PdfObjectArray )GetAsFloat64Slice ()([]float64 ,error ){var _fbgab []float64 ;for _ ,_cgfe :=range _gbba .Elements (){_dbdda ,_dceb :=GetNumberAsFloat (TraceToDirectObject (_cgfe ));if _dceb !=nil {return nil ,_be .Errorf ("\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006e\u0075m\u0062\u0065\u0072");
};_fbgab =append (_fbgab ,_dbdda );};return _fbgab ,nil ;};var _bgcb =_ab .MustCompile ("\u005e\\\u0073\u002a\u005b\u002d]\u002a\u0028\u005c\u0064\u002b)\u005cs\u002b(\u005c\u0064\u002b\u0029\u005c\u0073\u002bR");

// EncodeBytes ASCII encodes the passed in slice of bytes.
func (_gfff *ASCIIHexEncoder )EncodeBytes (data []byte )([]byte ,error ){var _aef _fd .Buffer ;for _ ,_dbd :=range data {_aef .WriteString (_be .Sprintf ("\u0025\u002e\u0032X\u0020",_dbd ));};_aef .WriteByte ('>');return _aef .Bytes (),nil ;};

// DecodeStream decodes a JPX encoded stream and returns the result as a
// slice of bytes.
func (_afdf *JPXEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_fg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_afdf .GetFilterName ());
return streamObj .Stream ,ErrNoJPXDecode ;};

// LZWEncoder provides LZW encoding/decoding functionality.
type LZWEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Colors int ;

// LZW algorithm setting.
EarlyChange int ;};

// DecodeStream decodes a FlateEncoded stream object and give back decoded bytes.
func (_eaf *FlateEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_fg .Log .Trace ("\u0046l\u0061t\u0065\u0044\u0065\u0063\u006fd\u0065\u0020s\u0074\u0072\u0065\u0061\u006d");_fg .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_eaf .Predictor );
if _eaf .BitsPerComponent !=8{return nil ,_be .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003d\u0025\u0064\u0020\u0028\u006f\u006e\u006c\u0079\u0020\u0038\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0029",_eaf .BitsPerComponent );
};_gca ,_eee :=_eaf .DecodeBytes (streamObj .Stream );if _eee !=nil {return nil ,_eee ;};_gca ,_eee =_eaf .postDecodePredict (_gca );if _eee !=nil {return nil ,_eee ;};return _gca ,nil ;};

// GetNumbersAsFloat converts a list of pdf objects representing floats or integers to a slice of
// float64 values.
func GetNumbersAsFloat (objects []PdfObject )(_bgeg []float64 ,_bcac error ){for _ ,_caeg :=range objects {_cbfbg ,_dafcb :=GetNumberAsFloat (_caeg );if _dafcb !=nil {return nil ,_dafcb ;};_bgeg =append (_bgeg ,_cbfbg );};return _bgeg ,nil ;};

// PdfObjectNull represents the primitive PDF null object.
type PdfObjectNull struct{};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_gcbf *DCTEncoder )MakeDecodeParams ()PdfObject {return nil };

// GetString returns the *PdfObjectString represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetString (obj PdfObject )(_bgaf *PdfObjectString ,_dgcbg bool ){_bgaf ,_dgcbg =TraceToDirectObject (obj ).(*PdfObjectString );return _bgaf ,_dgcbg ;};

// XrefTable represents the cross references in a PDF, i.e. the table of objects and information
// where to access within the PDF file.
type XrefTable struct{ObjectMap map[int ]XrefObject ;_cc []XrefObject ;};var _dcaaa =_ab .MustCompile ("\u0025\u0025\u0045\u004f\u0046\u003f");func (_aacde *PdfParser )rebuildXrefTable ()error {_ggegd :=XrefTable {};_ggegd .ObjectMap =map[int ]XrefObject {};
_aeefe :=make ([]int ,0,len (_aacde ._dfb .ObjectMap ));for _aecg :=range _aacde ._dfb .ObjectMap {_aeefe =append (_aeefe ,_aecg );};_f .Ints (_aeefe );for _ ,_eaee :=range _aeefe {_dcadbe :=_aacde ._dfb .ObjectMap [_eaee ];_ggce ,_ ,_fggd :=_aacde .lookupByNumberWrapper (_eaee ,false );
if _fggd !=nil {_fg .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020U\u006e\u0061\u0062\u006ce t\u006f l\u006f\u006f\u006b\u0020\u0075\u0070\u0020ob\u006a\u0065\u0063\u0074\u0020\u0028\u0025s\u0029",_fggd );_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0063\u006fm\u0070\u006c\u0065\u0074\u0065\u006c\u0079\u0020\u0062\u0072\u006f\u006b\u0065\u006e\u0020\u002d\u0020\u0061\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0074\u006f \u0072\u0065\u0070\u0061\u0069r\u0020");
_eabe ,_gde :=_aacde .repairRebuildXrefsTopDown ();if _gde !=nil {_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0072\u0065\u0062\u0075\u0069l\u0064\u0020\u0072\u0065\u0070a\u0069\u0072 \u0028\u0025\u0073\u0029",_gde );
return _gde ;};_aacde ._dfb =*_eabe ;_fg .Log .Debug ("\u0052e\u0070\u0061\u0069\u0072e\u0064\u0020\u0078\u0072\u0065f\u0020t\u0061b\u006c\u0065\u0020\u0062\u0075\u0069\u006ct");return nil ;};_ggdd ,_adea ,_fggd :=_ca (_ggce );if _fggd !=nil {return _fggd ;
};_dcadbe .ObjectNumber =int (_ggdd );_dcadbe .Generation =int (_adea );_ggegd .ObjectMap [int (_ggdd )]=_dcadbe ;};_aacde ._dfb =_ggegd ;_fg .Log .Debug ("N\u0065w\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061b\u006c\u0065\u0020\u0062ui\u006c\u0074");
_aac (_aacde ._dfb );return nil ;};

// Elements returns a slice of the PdfObject elements in the array.
// Preferred over accessing the array directly as type may be changed in future major versions (v3).
func (_ddag *PdfObjectStreams )Elements ()[]PdfObject {if _ddag ==nil {return nil ;};return _ddag ._aebba ;};

// UpdateParams updates the parameter values of the encoder.
func (_aae *ASCIIHexEncoder )UpdateParams (params *PdfObjectDictionary ){};

// MakeObjectStreams creates an PdfObjectStreams from a list of PdfObjects.
func MakeObjectStreams (objects ...PdfObject )*PdfObjectStreams {return &PdfObjectStreams {_aebba :objects };};

// Bytes returns the PdfObjectString content as a []byte array.
func (_bcga *PdfObjectString )Bytes ()[]byte {return []byte (_bcga ._aaccd )};func _faed (_gdgf ,_dbdee ,_ccaab int )error {if _dbdee < 0||_dbdee > _gdgf {return _g .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0061\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");
};if _ccaab < _dbdee {return _g .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0073\u006c\u0069\u0063e\u0020i\u006ed\u0065\u0078\u0020\u0062\u0020\u003c\u0020a");};if _ccaab > _gdgf {return _g .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0062\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");
};return nil ;};func _eaga (_fga *PdfObjectStream ,_gcd *PdfObjectDictionary )(*FlateEncoder ,error ){_gdc :=NewFlateEncoder ();_dcg :=_fga .PdfObjectDictionary ;if _dcg ==nil {return _gdc ,nil ;};_gdc ._gfee =_ddgcb (_dcg );if _gcd ==nil {_edd :=TraceToDirectObject (_dcg .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));
switch _aeag :=_edd .(type ){case *PdfObjectArray :if _aeag .Len ()!=1{_fg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072:\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020a\u0072\u0072\u0061\u0079\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0021\u003d\u0020\u0031\u0020\u0028\u0025\u0064\u0029",_aeag .Len ());
return nil ,_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};if _ega ,_dbfda :=GetDict (_aeag .Get (0));_dbfda {_gcd =_ega ;};case *PdfObjectDictionary :_gcd =_aeag ;case *PdfObjectNull ,nil :default:_fg .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020n\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079 \u0028%\u0054\u0029",_edd );
return nil ,_be .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _gcd ==nil {return _gdc ,nil ;};_fg .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_gcd .String ());
_fbg :=_gcd .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");if _fbg ==nil {_fg .Log .Debug ("E\u0072\u0072o\u0072\u003a\u0020\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067 \u0066\u0072\u006f\u006d\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073 \u002d\u0020\u0043\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020\u0077\u0069t\u0068\u0020\u0064\u0065\u0066\u0061\u0075\u006c\u0074\u0020\u00281\u0029");
}else {_ccad ,_aeb :=_fbg .(*PdfObjectInteger );if !_aeb {_fg .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_fbg );
return nil ,_be .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_gdc .Predictor =int (*_ccad );};_fbg =_gcd .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");
if _fbg !=nil {_ddf ,_aebb :=_fbg .(*PdfObjectInteger );if !_aebb {_fg .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");
return nil ,_be .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_gdc .BitsPerComponent =int (*_ddf );};if _gdc .Predictor > 1{_gdc .Columns =1;_fbg =_gcd .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");
if _fbg !=nil {_bcfd ,_dcceb :=_fbg .(*PdfObjectInteger );if !_dcceb {return nil ,_be .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_gdc .Columns =int (*_bcfd );
};_gdc .Colors =1;_fbg =_gcd .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _fbg !=nil {_debf ,_dbcd :=_fbg .(*PdfObjectInteger );if !_dbcd {return nil ,_be .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");
};_gdc .Colors =int (*_debf );};};return _gdc ,nil ;};func _edfg (_ecf *_bda .StdEncryptDict ,_bab *PdfObjectDictionary )error {R ,_aba :=_bab .Get ("\u0052").(*PdfObjectInteger );if !_aba {return _g .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0052");
};if *R < 2||*R > 6{return _be .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0052 \u0028\u0025\u0064\u0029",*R );};_ecf .R =int (*R );O ,_aba :=_bab .GetString ("\u004f");if !_aba {return _g .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u004f");
};if _ecf .R ==5||_ecf .R ==6{if len (O )< 48{return _be .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u004f\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (O ));};}else if len (O )!=32{return _be .Errorf ("L\u0065n\u0067\u0074\u0068\u0028\u004f\u0029\u0020\u0021=\u0020\u0033\u0032\u0020(%\u0064\u0029",len (O ));
};_ecf .O =[]byte (O );U ,_aba :=_bab .GetString ("\u0055");if !_aba {return _g .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0055");};if _ecf .R ==5||_ecf .R ==6{if len (U )< 48{return _be .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u0055\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (U ));
};}else if len (U )!=32{_fg .Log .Debug ("\u0057\u0061r\u006e\u0069\u006e\u0067\u003a\u0020\u004c\u0065\u006e\u0067\u0074\u0068\u0028\u0055\u0029\u0020\u0021\u003d\u0020\u0033\u0032\u0020(%\u0064\u0029",len (U ));};_ecf .U =[]byte (U );if _ecf .R >=5{OE ,_agbd :=_bab .GetString ("\u004f\u0045");
if !_agbd {return _g .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u004f\u0045");}else if len (OE )!=32{return _be .Errorf ("L\u0065\u006e\u0067\u0074h(\u004fE\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (OE ));
};_ecf .OE =[]byte (OE );UE ,_agbd :=_bab .GetString ("\u0055\u0045");if !_agbd {return _g .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u0055\u0045");
}else if len (UE )!=32{return _be .Errorf ("L\u0065\u006e\u0067\u0074h(\u0055E\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (UE ));};_ecf .UE =[]byte (UE );};P ,_aba :=_bab .Get ("\u0050").(*PdfObjectInteger );if !_aba {return _g .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074 \u0064\u0069\u0063t\u0069\u006f\u006e\u0061r\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0070\u0065\u0072\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0061\u0074\u0074\u0072");
};_ecf .P =_bda .Permissions (*P );if _ecf .R ==6{Perms ,_ffeg :=_bab .GetString ("\u0050\u0065\u0072m\u0073");if !_ffeg {return _g .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0050\u0065\u0072\u006d\u0073");
}else if len (Perms )!=16{return _be .Errorf ("\u004ce\u006e\u0067\u0074\u0068\u0028\u0050\u0065\u0072\u006d\u0073\u0029 \u0021\u003d\u0020\u0031\u0036\u0020\u0028\u0025\u0064\u0029",len (Perms ));};_ecf .Perms =[]byte (Perms );};if _ccc ,_fbd :=_bab .Get ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061").(*PdfObjectBool );
_fbd {_ecf .EncryptMetadata =bool (*_ccc );}else {_ecf .EncryptMetadata =true ;};return nil ;};

// Decrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_cgba *PdfCrypt )Decrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _cgba .isDecrypted (obj ){return nil ;};switch _gce :=obj .(type ){case *PdfIndirectObject :_cgba ._ffe [_gce ]=true ;_fg .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_gce .ObjectNumber ,_gce .GenerationNumber );
_cfd :=_gce .ObjectNumber ;_egd :=_gce .GenerationNumber ;_ffed :=_cgba .Decrypt (_gce .PdfObject ,_cfd ,_egd );if _ffed !=nil {return _ffed ;};return nil ;case *PdfObjectStream :_cgba ._ffe [_gce ]=true ;_geac :=_gce .PdfObjectDictionary ;if _cgba ._aea .R !=5{if _dbb ,_cbc :=_geac .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );
_cbc &&*_dbb =="\u0058\u0052\u0065\u0066"{return nil ;};};_bffg :=_gce .ObjectNumber ;_dfg :=_gce .GenerationNumber ;_fg .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_bffg ,_dfg );
_acbf :=_baeb ;if _cgba ._baf .V >=4{_acbf =_cgba ._ebg ;_fg .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_cgba ._ebg );if _cgc ,_cafd :=_geac .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );
_cafd {if _adaf ,_dbf :=GetName (_cgc .Get (0));_dbf {if *_adaf =="\u0043\u0072\u0079p\u0074"{_acbf ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _gee ,_fbf :=_geac .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );
_fbf {if _cfg ,_abee :=_gee .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_abee {if _ ,_aedd :=_cgba ._egg [string (*_cfg )];_aedd {_fg .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_cfg );
_acbf =string (*_cfg );};};};};};};_fg .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_acbf );if _acbf =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_affe :=_cgba .Decrypt (_geac ,_bffg ,_dfg );
if _affe !=nil {return _affe ;};_geagc ,_affe :=_cgba .makeKey (_acbf ,uint32 (_bffg ),uint32 (_dfg ),_cgba ._cec );if _affe !=nil {return _affe ;};_gce .Stream ,_affe =_cgba .decryptBytes (_gce .Stream ,_acbf ,_geagc );if _affe !=nil {return _affe ;};
_geac .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_gce .Stream ))));return nil ;case *PdfObjectString :_fg .Log .Trace ("\u0044e\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_dgd :=_baeb ;
if _cgba ._baf .V >=4{_fg .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_cgba ._dcf );if _cgba ._dcf =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_dgd =_cgba ._dcf ;};_cdf ,_gffb :=_cgba .makeKey (_dgd ,uint32 (parentObjNum ),uint32 (parentGenNum ),_cgba ._cec );
if _gffb !=nil {return _gffb ;};_fcag :=_gce .Str ();_gacg :=make ([]byte ,len (_fcag ));for _edb :=0;_edb < len (_fcag );_edb ++{_gacg [_edb ]=_fcag [_edb ];};_fg .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_gacg ,_gacg );
_gacg ,_gffb =_cgba .decryptBytes (_gacg ,_dgd ,_cdf );if _gffb !=nil {return _gffb ;};_gce ._aaccd =string (_gacg );return nil ;case *PdfObjectArray :for _ ,_cbb :=range _gce .Elements (){_cbff :=_cgba .Decrypt (_cbb ,parentObjNum ,parentGenNum );if _cbff !=nil {return _cbff ;
};};return nil ;case *PdfObjectDictionary :_cadg :=false ;if _bceb :=_gce .Get ("\u0054\u0079\u0070\u0065");_bceb !=nil {_fbfe ,_baa :=_bceb .(*PdfObjectName );if _baa &&*_fbfe =="\u0053\u0069\u0067"{_cadg =true ;};};for _ ,_dcce :=range _gce .Keys (){_afed :=_gce .Get (_dcce );
if _cadg &&string (_dcce )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;};if string (_dcce )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_dcce )!="\u0050\u0072\u0065\u0076"&&string (_dcce )!="\u004c\u0061\u0073\u0074"{_cdc :=_cgba .Decrypt (_afed ,parentObjNum ,parentGenNum );
if _cdc !=nil {return _cdc ;};};};return nil ;};return nil ;};

// Keys returns the list of keys in the dictionary.
// If `d` is nil returns a nil slice.
func (_cgcg *PdfObjectDictionary )Keys ()[]PdfObjectName {if _cgcg ==nil {return nil ;};return _cgcg ._cabe ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_fage *ASCIIHexEncoder )MakeDecodeParams ()PdfObject {return nil };type objectStream struct{N int ;_eef []byte ;_eefc map[int ]int64 ;};

// ParseDict reads and parses a PDF dictionary object enclosed with '<<' and '>>'
func (_dgeg *PdfParser )ParseDict ()(*PdfObjectDictionary ,error ){_fg .Log .Trace ("\u0052\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020D\u0069\u0063\u0074\u0021");_adca :=MakeDict ();_adca ._dcfe =_dgeg ;_ceca ,_ :=_dgeg ._eeaf .ReadByte ();
if _ceca !='<'{return nil ,_g .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");};_ceca ,_ =_dgeg ._eeaf .ReadByte ();if _ceca !='<'{return nil ,_g .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");
};for {_dgeg .skipSpaces ();_dgeg .skipComments ();_cbda ,_edcda :=_dgeg ._eeaf .Peek (2);if _edcda !=nil {return nil ,_edcda ;};_fg .Log .Trace ("D\u0069c\u0074\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_cbda ),string (_cbda ));
if (_cbda [0]=='>')&&(_cbda [1]=='>'){_fg .Log .Trace ("\u0045\u004f\u0046\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");_dgeg ._eeaf .ReadByte ();_dgeg ._eeaf .ReadByte ();break ;};_fg .Log .Trace ("\u0050a\u0072s\u0065\u0020\u0074\u0068\u0065\u0020\u006e\u0061\u006d\u0065\u0021");
_becgf ,_edcda :=_dgeg .parseName ();_fg .Log .Trace ("\u004be\u0079\u003a\u0020\u0025\u0073",_becgf );if _edcda !=nil {_fg .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0052e\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006ea\u006d\u0065\u0020e\u0072r\u0020\u0025\u0073",_edcda );
return nil ,_edcda ;};if len (_becgf )> 4&&_becgf [len (_becgf )-4:]=="\u006e\u0075\u006c\u006c"{_geega :=_becgf [0:len (_becgf )-4];_fg .Log .Debug ("\u0054\u0061\u006b\u0069n\u0067\u0020\u0063\u0061\u0072\u0065\u0020\u006f\u0066\u0020n\u0075l\u006c\u0020\u0062\u0075\u0067\u0020\u0028%\u0073\u0029",_becgf );
_fg .Log .Debug ("\u004e\u0065\u0077\u0020ke\u0079\u0020\u0022\u0025\u0073\u0022\u0020\u003d\u0020\u006e\u0075\u006c\u006c",_geega );_dgeg .skipSpaces ();_dccb ,_ :=_dgeg ._eeaf .Peek (1);if _dccb [0]=='/'{_adca .Set (_geega ,MakeNull ());continue ;};};
_dgeg .skipSpaces ();_ggfb ,_edcda :=_dgeg .parseObject ();if _edcda !=nil {return nil ,_edcda ;};_adca .Set (_becgf ,_ggfb );if _fg .Log .IsLogLevel (_fg .LogLevelTrace ){_fg .Log .Trace ("\u0064\u0069\u0063\u0074\u005b\u0025\u0073\u005d\u0020\u003d\u0020\u0025\u0073",_becgf ,_ggfb .String ());
};};_fg .Log .Trace ("\u0072\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020\u0044\u0069\u0063\u0074\u0021");return _adca ,nil ;};func _dcd (_aff *_bda .StdEncryptDict ,_afa *PdfObjectDictionary ){_afa .Set ("\u0052",MakeInteger (int64 (_aff .R )));
_afa .Set ("\u0050",MakeInteger (int64 (_aff .P )));_afa .Set ("\u004f",MakeStringFromBytes (_aff .O ));_afa .Set ("\u0055",MakeStringFromBytes (_aff .U ));if _aff .R >=5{_afa .Set ("\u004f\u0045",MakeStringFromBytes (_aff .OE ));_afa .Set ("\u0055\u0045",MakeStringFromBytes (_aff .UE ));
_afa .Set ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061",MakeBool (_aff .EncryptMetadata ));if _aff .R > 5{_afa .Set ("\u0050\u0065\u0072m\u0073",MakeStringFromBytes (_aff .Perms ));};};};

// GetFilterName returns the name of the encoding filter.
func (_cgdg *DCTEncoder )GetFilterName ()string {return StreamEncodingFilterNameDCT };func (_dc *PdfParser )lookupByNumberWrapper (_dcc int ,_ba bool )(PdfObject ,bool ,error ){_acf ,_bgb ,_gff :=_dc .lookupByNumber (_dcc ,_ba );if _gff !=nil {return nil ,_bgb ,_gff ;
};if !_bgb &&_dc ._ggab !=nil &&!_dc ._ggab .isDecrypted (_acf ){_fdf :=_dc ._ggab .Decrypt (_acf ,0,0);if _fdf !=nil {return nil ,_bgb ,_fdf ;};};return _acf ,_bgb ,nil ;};

// DecodeBytes decodes a slice of DCT encoded bytes and returns the result.
func (_dcdf *DCTEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_ceab :=_fd .NewReader (encoded );_gged ,_acbff :=_ee .Decode (_ceab );if _acbff !=nil {_fg .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006eg\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_acbff );
return nil ,_acbff ;};_gbgb :=_gged .Bounds ();var _dfdg =make ([]byte ,_gbgb .Dx ()*_gbgb .Dy ()*_dcdf .ColorComponents *_dcdf .BitsPerComponent /8);_fcgfd :=0;for _ebff :=_gbgb .Min .Y ;_ebff < _gbgb .Max .Y ;_ebff ++{for _bddg :=_gbgb .Min .X ;_bddg < _gbgb .Max .X ;
_bddg ++{_cdd :=_gged .At (_bddg ,_ebff );if _dcdf .ColorComponents ==1{if _dcdf .BitsPerComponent ==16{_befd ,_dad :=_cdd .(_e .Gray16 );if !_dad {return nil ,_g .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_dfdg [_fcgfd ]=byte ((_befd .Y >>8)&0xff);_fcgfd ++;_dfdg [_fcgfd ]=byte (_befd .Y &0xff);_fcgfd ++;}else {_dee ,_bbfb :=_cdd .(_e .Gray );if !_bbfb {return nil ,_g .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_dfdg [_fcgfd ]=_dee .Y &0xff;_fcgfd ++;};}else if _dcdf .ColorComponents ==3{if _dcdf .BitsPerComponent ==16{_bbde ,_cggc :=_cdd .(_e .RGBA64 );if !_cggc {return nil ,_g .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_dfdg [_fcgfd ]=byte ((_bbde .R >>8)&0xff);_fcgfd ++;_dfdg [_fcgfd ]=byte (_bbde .R &0xff);_fcgfd ++;_dfdg [_fcgfd ]=byte ((_bbde .G >>8)&0xff);_fcgfd ++;_dfdg [_fcgfd ]=byte (_bbde .G &0xff);_fcgfd ++;_dfdg [_fcgfd ]=byte ((_bbde .B >>8)&0xff);_fcgfd ++;
_dfdg [_fcgfd ]=byte (_bbde .B &0xff);_fcgfd ++;}else {_begef ,_agfc :=_cdd .(_e .RGBA );if _agfc {_dfdg [_fcgfd ]=_begef .R &0xff;_fcgfd ++;_dfdg [_fcgfd ]=_begef .G &0xff;_fcgfd ++;_dfdg [_fcgfd ]=_begef .B &0xff;_fcgfd ++;}else {_dcbd ,_aagf :=_cdd .(_e .YCbCr );
if !_aagf {return nil ,_g .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_ddbc ,_bcfa ,_dce ,_ :=_dcbd .RGBA ();_dfdg [_fcgfd ]=byte (_ddbc >>8);_fcgfd ++;_dfdg [_fcgfd ]=byte (_bcfa >>8);_fcgfd ++;_dfdg [_fcgfd ]=byte (_dce >>8);
_fcgfd ++;};};}else if _dcdf .ColorComponents ==4{_dcadg ,_ddbf :=_cdd .(_e .CMYK );if !_ddbf {return nil ,_g .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_dfdg [_fcgfd ]=255-_dcadg .C &0xff;_fcgfd ++;
_dfdg [_fcgfd ]=255-_dcadg .M &0xff;_fcgfd ++;_dfdg [_fcgfd ]=255-_dcadg .Y &0xff;_fcgfd ++;_dfdg [_fcgfd ]=255-_dcadg .K &0xff;_fcgfd ++;};};};return _dfdg ,nil ;};

// GetObjectStreams returns the *PdfObjectStreams represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetObjectStreams (obj PdfObject )(_egbea *PdfObjectStreams ,_gcgg bool ){_egbea ,_gcgg =obj .(*PdfObjectStreams );return _egbea ,_gcgg ;};func (_dedcf *PdfParser )seekToEOFMarker (_bgca int64 )error {var _eega int64 ;var _fgcegb int64 =2048;for _eega < _bgca -4{if _bgca <=(_fgcegb +_eega ){_fgcegb =_bgca -_eega ;
};_ ,_dbde :=_dedcf ._cbfb .Seek (-_eega -_fgcegb ,_c .SeekEnd );if _dbde !=nil {return _dbde ;};_abbge :=make ([]byte ,_fgcegb );_dedcf ._cbfb .Read (_abbge );_fg .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0045\u004f\u0046 \u006da\u0072\u006b\u0065\u0072\u003a\u0020\u0022%\u0073\u0022",string (_abbge ));
_aeac :=_dcaaa .FindAllStringIndex (string (_abbge ),-1);if _aeac !=nil {_eafa :=_aeac [len (_aeac )-1];_fg .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_aeac );_dedcf ._cbfb .Seek (-_eega -_fgcegb +int64 (_eafa [0]),_c .SeekEnd );return nil ;
};_fg .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");
_eega +=_fgcegb -4;};_fg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006be\u0072 \u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u002e");return _g .New ("\u0045\u004f\u0046\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");
};

// RegisterCustomStreamEncoder register a custom encoder handler for certain filter.
func RegisterCustomStreamEncoder (filterName string ,customStreamEncoder StreamEncoder ){_cfbdb .Store (filterName ,customStreamEncoder );};

// EncodeBytes JPX encodes the passed in slice of bytes.
func (_gccf *JPXEncoder )EncodeBytes (data []byte )([]byte ,error ){_fg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_gccf .GetFilterName ());
return data ,ErrNoJPXDecode ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_bfd *ASCII85Encoder )MakeDecodeParams ()PdfObject {return nil };

// IsNullObject returns true if `obj` is a PdfObjectNull.
func IsNullObject (obj PdfObject )bool {_ ,_abgd :=TraceToDirectObject (obj ).(*PdfObjectNull );return _abgd ;};

// ResolveReference resolves reference if `o` is a *PdfObjectReference and returns the object referenced to.
// Otherwise returns back `o`.
func ResolveReference (obj PdfObject )PdfObject {if _efcc ,_debc :=obj .(*PdfObjectReference );_debc {return _efcc .Resolve ();};return obj ;};const _bgga =32<<(^uint (0)>>63);

// NewASCIIHexEncoder makes a new ASCII hex encoder.
func NewASCIIHexEncoder ()*ASCIIHexEncoder {_eda :=&ASCIIHexEncoder {};return _eda };func _ddgcb (_gagf *PdfObjectDictionary )(_afffa *_da .ImageBase ){var (_bgeee *PdfObjectInteger ;_dcgcg bool ;);if _bgeee ,_dcgcg =_gagf .Get ("\u0057\u0069\u0064t\u0068").(*PdfObjectInteger );
_dcgcg {_afffa =&_da .ImageBase {Width :int (*_bgeee )};}else {return nil ;};if _bgeee ,_dcgcg =_gagf .Get ("\u0048\u0065\u0069\u0067\u0068\u0074").(*PdfObjectInteger );_dcgcg {_afffa .Height =int (*_bgeee );};if _bgeee ,_dcgcg =_gagf .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074").(*PdfObjectInteger );
_dcgcg {_afffa .BitsPerComponent =int (*_bgeee );};if _bgeee ,_dcgcg =_gagf .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073").(*PdfObjectInteger );_dcgcg {_afffa .ColorComponents =int (*_bgeee );};return _afffa ;
};const (XrefTypeTableEntry xrefType =iota ;XrefTypeObjectStream xrefType =iota ;);

// MultiEncoder supports serial encoding.
type MultiEncoder struct{_feab []StreamEncoder };

// WriteString outputs the object as it is to be written to file.
func (_fggfa *PdfObjectFloat )WriteString ()string {return _b .FormatFloat (float64 (*_fggfa ),'f',-1,64);};

// PdfCrypt provides PDF encryption/decryption support.
// The PDF standard supports encryption of strings and streams (Section 7.6).
type PdfCrypt struct{_baf encryptDict ;_aea _bda .StdEncryptDict ;_bdad string ;_cec []byte ;_ffe map[PdfObject ]bool ;_bbba map[PdfObject ]bool ;_eeb bool ;_egg cryptFilters ;_ebg string ;_dcf string ;_daf *PdfParser ;_bcg map[int ]struct{};};func (_ecgaa *PdfParser )parseArray ()(*PdfObjectArray ,error ){_aeg :=MakeArray ();
_ecgaa ._eeaf .ReadByte ();for {_ecgaa .skipSpaces ();_feg ,_gbdg :=_ecgaa ._eeaf .Peek (1);if _gbdg !=nil {return _aeg ,_gbdg ;};if _feg [0]==']'{_ecgaa ._eeaf .ReadByte ();break ;};_gaae ,_gbdg :=_ecgaa .parseObject ();if _gbdg !=nil {return _aeg ,_gbdg ;
};_aeg .Append (_gaae );};return _aeg ,nil ;};

// DecodeGlobals decodes 'encoded' byte stream and returns their Globally defined segments ('Globals').
func (_ggcac *JBIG2Encoder )DecodeGlobals (encoded []byte )(_gg .Globals ,error ){return _gg .DecodeGlobals (encoded );};

// Resolve resolves a PdfObject to direct object, looking up and resolving references as needed (unlike TraceToDirect).
func (_dge *PdfParser )Resolve (obj PdfObject )(PdfObject ,error ){_dgc ,_ace :=obj .(*PdfObjectReference );if !_ace {return obj ,nil ;};_dfe :=_dge .GetFileOffset ();defer func (){_dge .SetFileOffset (_dfe )}();_ecgf ,_bbeb :=_dge .LookupByReference (*_dgc );
if _bbeb !=nil {return nil ,_bbeb ;};_def ,_afc :=_ecgf .(*PdfIndirectObject );if !_afc {return _ecgf ,nil ;};_ecgf =_def .PdfObject ;_ ,_ace =_ecgf .(*PdfObjectReference );if _ace {return _def ,_g .New ("\u006d\u0075lt\u0069\u0020\u0064e\u0070\u0074\u0068\u0020tra\u0063e \u0070\u006f\u0069\u006e\u0074\u0065\u0072 t\u006f\u0020\u0070\u006f\u0069\u006e\u0074e\u0072");
};return _ecgf ,nil ;};

// Clear resets the array to an empty state.
func (_fdbg *PdfObjectArray )Clear (){_fdbg ._eadg =[]PdfObject {}};

// WriteString outputs the object as it is to be written to file.
func (_cgga *PdfObjectDictionary )WriteString ()string {var _cbeb _ff .Builder ;_cbeb .WriteString ("\u003c\u003c");for _ ,_ffbd :=range _cgga ._cabe {_gaaef :=_cgga ._ggbc [_ffbd ];_cbeb .WriteString (_ffbd .WriteString ());_cbeb .WriteString ("\u0020");
_cbeb .WriteString (_gaaef .WriteString ());};_cbeb .WriteString ("\u003e\u003e");return _cbeb .String ();};

// EncodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_egb *RawEncoder )EncodeBytes (data []byte )([]byte ,error ){return data ,nil };

// XrefObject defines a cross reference entry which is a map between object number (with generation number) and the
// location of the actual object, either as a file offset (xref table entry), or as a location within an xref
// stream object (xref object stream).
type XrefObject struct{XType xrefType ;ObjectNumber int ;Generation int ;

// For normal xrefs (defined by OFFSET)
Offset int64 ;

// For xrefs to object streams.
OsObjNumber int ;OsObjIndex int ;};

// IsAuthenticated returns true if the PDF has already been authenticated for accessing.
func (_bbed *PdfParser )IsAuthenticated ()bool {return _bbed ._ggab ._eeb };

// IsOctalDigit checks if a character can be part of an octal digit string.
func IsOctalDigit (c byte )bool {return '0'<=c &&c <='7'};

// EncodeBytes encodes the image data using either Group3 or Group4 CCITT facsimile (fax) encoding.
// `data` is expected to be 1 color component, 1 bit per component. It is also valid to provide 8 BPC, 1 CC image like
// a standard go image Gray data.
func (_edde *CCITTFaxEncoder )EncodeBytes (data []byte )([]byte ,error ){var _dcgg _da .Gray ;switch len (data ){case _edde .Rows *_edde .Columns :_bdcf ,_afaf :=_da .NewImage (_edde .Columns ,_edde .Rows ,8,1,data ,nil ,nil );if _afaf !=nil {return nil ,_afaf ;
};_dcgg =_bdcf .(_da .Gray );case (_edde .Columns *_edde .Rows )+7>>3:_defa ,_gcbcg :=_da .NewImage (_edde .Columns ,_edde .Rows ,1,1,data ,nil ,nil );if _gcbcg !=nil {return nil ,_gcbcg ;};_caff :=_defa .(*_da .Monochrome );if _gcbcg =_caff .AddPadding ();
_gcbcg !=nil {return nil ,_gcbcg ;};_dcgg =_caff ;default:if len (data )< _da .BytesPerLine (_edde .Columns ,1,1)*_edde .Rows {return nil ,_g .New ("p\u0072\u006f\u0076\u0069\u0064\u0065d\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020i\u006e\u0070\u0075t\u0020d\u0061\u0074\u0061");
};_fdeg ,_fdg :=_da .NewImage (_edde .Columns ,_edde .Rows ,1,1,data ,nil ,nil );if _fdg !=nil {return nil ,_fdg ;};_geeg :=_fdeg .(*_da .Monochrome );_dcgg =_geeg ;};_affdc :=make ([][]byte ,_edde .Rows );for _caag :=0;_caag < _edde .Rows ;_caag ++{_fafe :=make ([]byte ,_edde .Columns );
for _dcaa :=0;_dcaa < _edde .Columns ;_dcaa ++{_gfde :=_dcgg .GrayAt (_dcaa ,_caag );_fafe [_dcaa ]=_gfde .Y >>7;};_affdc [_caag ]=_fafe ;};_cfba :=&_bc .Encoder {K :_edde .K ,Columns :_edde .Columns ,EndOfLine :_edde .EndOfLine ,EndOfBlock :_edde .EndOfBlock ,BlackIs1 :_edde .BlackIs1 ,DamagedRowsBeforeError :_edde .DamagedRowsBeforeError ,Rows :_edde .Rows ,EncodedByteAlign :_edde .EncodedByteAlign };
return _cfba .Encode (_affdc ),nil ;};

// Decoded returns the PDFDocEncoding or UTF-16BE decoded string contents.
// UTF-16BE is applied when the first two bytes are 0xFE, 0XFF, otherwise decoding of
// PDFDocEncoding is performed.
func (_ddbff *PdfObjectString )Decoded ()string {if _ddbff ==nil {return "";};_dadd :=[]byte (_ddbff ._aaccd );if len (_dadd )>=2&&_dadd [0]==0xFE&&_dadd [1]==0xFF{return _gf .UTF16ToString (_dadd [2:]);};return _gf .PDFDocEncodingToString (_dadd );};

// WriteString outputs the object as it is to be written to file.
func (_bdacbf *PdfObjectStreams )WriteString ()string {var _eedd _ff .Builder ;_eedd .WriteString (_b .FormatInt (_bdacbf .ObjectNumber ,10));_eedd .WriteString ("\u0020\u0030\u0020\u0052");return _eedd .String ();};func (_bce *PdfCrypt )securityHandler ()_bda .StdHandler {if _bce ._aea .R >=5{return _bda .NewHandlerR6 ();
};return _bda .NewHandlerR4 (_bce ._bdad ,_bce ._baf .Length );};

// PdfObject is an interface which all primitive PDF objects must implement.
type PdfObject interface{

// String outputs a string representation of the primitive (for debugging).
String ()string ;

// WriteString outputs the PDF primitive as written to file as expected by the standard.
// TODO(dennwc): it should return a byte slice, or accept a writer
WriteString ()string ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_acbd *JPXEncoder )MakeDecodeParams ()PdfObject {return nil };

// WriteString outputs the object as it is to be written to file.
func (_becb *PdfObjectStream )WriteString ()string {var _gbbb _ff .Builder ;_gbbb .WriteString (_b .FormatInt (_becb .ObjectNumber ,10));_gbbb .WriteString ("\u0020\u0030\u0020\u0052");return _gbbb .String ();};

// Elements returns a slice of the PdfObject elements in the array.
func (_dafb *PdfObjectArray )Elements ()[]PdfObject {if _dafb ==nil {return nil ;};return _dafb ._eadg ;};

// SetFileOffset sets the file to an offset position and resets buffer.
func (_abcf *PdfParser )SetFileOffset (offset int64 ){if offset < 0{offset =0;};_abcf ._cbfb .Seek (offset ,_c .SeekStart );_abcf ._eeaf =_bd .NewReader (_abcf ._cbfb );};

// MakeDecodeParams makes a new instance of an encoding dictionary based on the current encoder settings.
func (_cgec *JBIG2Encoder )MakeDecodeParams ()PdfObject {return MakeDict ()};

// PdfObjectName represents the primitive PDF name object.
type PdfObjectName string ;

// GetString is a helper for Get that returns a string value.
// Returns false if the key is missing or a value is not a string.
func (_dgfc *PdfObjectDictionary )GetString (key PdfObjectName )(string ,bool ){_dfdca ,_gcag :=_dgfc ._ggbc [key ].(*PdfObjectString );if !_gcag {return "",false ;};return _dfdca .Str (),true ;};

// FlateEncoder represents Flate encoding.
type FlateEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Rows int ;Colors int ;_gfee *_da .ImageBase ;};

// EncodeBytes encodes the passed in slice of bytes by passing it through the
// EncodeBytes method of the underlying encoders.
func (_eedfe *MultiEncoder )EncodeBytes (data []byte )([]byte ,error ){_cdcc :=data ;var _gdcd error ;for _egef :=len (_eedfe ._feab )-1;_egef >=0;_egef --{_ccbe :=_eedfe ._feab [_egef ];_cdcc ,_gdcd =_ccbe .EncodeBytes (_cdcc );if _gdcd !=nil {return nil ,_gdcd ;
};};return _cdcc ,nil ;};

// DecodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_bbdee *RawEncoder )DecodeBytes (encoded []byte )([]byte ,error ){return encoded ,nil };

// GetParser returns the parser for lazy-loading or compare references.
func (_fdfdf *PdfObjectReference )GetParser ()*PdfParser {return _fdfdf ._eaca };

// PdfObjectArray represents the primitive PDF array object.
type PdfObjectArray struct{_eadg []PdfObject };

// ParseNumber parses a numeric objects from a buffered stream.
// Section 7.3.3.
// Integer or Float.
//
// An integer shall be written as one or more decimal digits optionally
// preceded by a sign. The value shall be interpreted as a signed
// decimal integer and shall be converted to an integer object.
//
// A real value shall be written as one or more decimal digits with an
// optional sign and a leading, trailing, or embedded PERIOD (2Eh)
// (decimal point). The value shall be interpreted as a real number
// and shall be converted to a real object.
//
// Regarding exponential numbers: 7.3.3 Numeric Objects:
// A conforming writer shall not use the PostScript syntax for numbers
// with non-decimal radices (such as 16#FFFE) or in exponential format
// (such as 6.02E23).
// Nonetheless, we sometimes get numbers with exponential format, so
// we will support it in the reader (no confusion with other types, so
// no compromise).
func ParseNumber (buf *_bd .Reader )(PdfObject ,error ){_gcba :=false ;_cbeba :=true ;var _eeegg _fd .Buffer ;for {if _fg .Log .IsLogLevel (_fg .LogLevelTrace ){_fg .Log .Trace ("\u0050\u0061\u0072\u0073in\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0022\u0025\u0073\u0022",_eeegg .String ());
};_gbdc ,_cdda :=buf .Peek (1);if _cdda ==_c .EOF {break ;};if _cdda !=nil {_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0025\u0073",_cdda );return nil ,_cdda ;};if _cbeba &&(_gbdc [0]=='-'||_gbdc [0]=='+'){_abeb ,_ :=buf .ReadByte ();_eeegg .WriteByte (_abeb );
_cbeba =false ;}else if IsDecimalDigit (_gbdc [0]){_dcfef ,_ :=buf .ReadByte ();_eeegg .WriteByte (_dcfef );}else if _gbdc [0]=='.'{_dbff ,_ :=buf .ReadByte ();_eeegg .WriteByte (_dbff );_gcba =true ;}else if _gbdc [0]=='e'||_gbdc [0]=='E'{_adec ,_ :=buf .ReadByte ();
_eeegg .WriteByte (_adec );_gcba =true ;_cbeba =true ;}else {break ;};};var _bgef PdfObject ;if _gcba {_fgdfe ,_bbbdc :=_b .ParseFloat (_eeegg .String (),64);if _bbbdc !=nil {_fg .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0025v\u0020\u0065\u0072\u0072\u003d\u0025v\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0030\u002e\u0020\u004fu\u0074\u0070u\u0074\u0020\u006d\u0061y\u0020\u0062\u0065\u0020\u0069n\u0063\u006f\u0072\u0072\u0065\u0063\u0074",_eeegg .String (),_bbbdc );
_fgdfe =0.0;};_ccca :=PdfObjectFloat (_fgdfe );_bgef =&_ccca ;}else {_bggc ,_baaf :=_b .ParseInt (_eeegg .String (),10,64);if _baaf !=nil {_fg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0025\u0076\u0020\u0065\u0072\u0072\u003d%\u0076\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074 \u006d\u0061\u0079\u0020\u0062\u0065 \u0069\u006ec\u006f\u0072r\u0065c\u0074",_eeegg .String (),_baaf );
_bggc =0;};_dceef :=PdfObjectInteger (_bggc );_bgef =&_dceef ;};return _bgef ,nil ;};

// MakeStreamDict make a new instance of an encoding dictionary for a stream object.
func (_dba *ASCII85Encoder )MakeStreamDict ()*PdfObjectDictionary {_fbga :=MakeDict ();_fbga .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_dba .GetFilterName ()));return _fbga ;};

// GetNumberAsFloat returns the contents of `obj` as a float if it is an integer or float, or an
// error if it isn't.
func GetNumberAsFloat (obj PdfObject )(float64 ,error ){switch _cfbd :=obj .(type ){case *PdfObjectFloat :return float64 (*_cfbd ),nil ;case *PdfObjectInteger :return float64 (*_cfbd ),nil ;};return 0,ErrNotANumber ;};

// PdfObjectStreams represents the primitive PDF object streams.
// 7.5.7 Object Streams (page 45).
type PdfObjectStreams struct{PdfObjectReference ;_aebba []PdfObject ;};

// MakeIndirectObject creates an PdfIndirectObject with a specified direct object PdfObject.
func MakeIndirectObject (obj PdfObject )*PdfIndirectObject {_cgdfb :=&PdfIndirectObject {};_cgdfb .PdfObject =obj ;return _cgdfb ;};

// Set sets the PdfObject at index i of the streams. An error is returned if the index is outside bounds.
func (_acdeb *PdfObjectStreams )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_acdeb ._aebba ){return _g .New ("\u004f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_acdeb ._aebba [i ]=obj ;return nil ;};

// EncodeStream encodes the stream data using the encoded specified by the stream's dictionary.
func EncodeStream (streamObj *PdfObjectStream )error {_fg .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_deeb ,_cdag :=NewEncoderFromStream (streamObj );if _cdag !=nil {_fg .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_cdag );
return _cdag ;};if _eafb ,_abac :=_deeb .(*LZWEncoder );_abac {_eafb .EarlyChange =0;streamObj .PdfObjectDictionary .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (0));};_fg .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076\u000a",_deeb );
_fgdb ,_cdag :=_deeb .EncodeBytes (streamObj .Stream );if _cdag !=nil {_fg .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_cdag );return _cdag ;
};streamObj .Stream =_fgdb ;streamObj .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_fgdb ))));return nil ;};

// GetBoolVal returns the bool value within a *PdObjectBool represented by an PdfObject interface directly or indirectly.
// If the PdfObject does not represent a bool value, a default value of false is returned (found = false also).
func GetBoolVal (obj PdfObject )(_bedc bool ,_cgdc bool ){_fgdgb ,_cgdc :=TraceToDirectObject (obj ).(*PdfObjectBool );if _cgdc {return bool (*_fgdgb ),true ;};return false ,false ;};

// MakeArrayFromIntegers64 creates an PdfObjectArray from a slice of int64s, where each array element
// is an PdfObjectInteger.
func MakeArrayFromIntegers64 (vals []int64 )*PdfObjectArray {_ebgf :=MakeArray ();for _ ,_gcbe :=range vals {_ebgf .Append (MakeInteger (_gcbe ));};return _ebgf ;};

// UpdateParams updates the parameter values of the encoder.
func (_eaab *DCTEncoder )UpdateParams (params *PdfObjectDictionary ){_fgce ,_gabb :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _gabb ==nil {_eaab .ColorComponents =int (_fgce );
};_defce ,_gabb :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _gabb ==nil {_eaab .BitsPerComponent =int (_defce );};_dgbf ,_gabb :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));
if _gabb ==nil {_eaab .Width =int (_dgbf );};_ccg ,_gabb :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _gabb ==nil {_eaab .Height =int (_ccg );};_adbd ,_gabb :=GetNumberAsInt64 (params .Get ("\u0051u\u0061\u006c\u0069\u0074\u0079"));
if _gabb ==nil {_eaab .Quality =int (_adbd );};};func (_efce *PdfParser )skipComments ()error {if _ ,_agef :=_efce .skipSpaces ();_agef !=nil {return _agef ;};_bdgf :=true ;for {_gadce ,_dgcbd :=_efce ._eeaf .Peek (1);if _dgcbd !=nil {_fg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_dgcbd .Error ());
return _dgcbd ;};if _bdgf &&_gadce [0]!='%'{return nil ;};_bdgf =false ;if (_gadce [0]!='\r')&&(_gadce [0]!='\n'){_efce ._eeaf .ReadByte ();}else {break ;};};return _efce .skipComments ();};

// String returns a descriptive information string about the encryption method used.
func (_bbbf *PdfCrypt )String ()string {if _bbbf ==nil {return "";};_bee :=_bbbf ._baf .Filter +"\u0020\u002d\u0020";if _bbbf ._baf .V ==0{_bee +="\u0055\u006e\u0064\u006fcu\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0061\u006c\u0067\u006f\u0072\u0069\u0074h\u006d";
}else if _bbbf ._baf .V ==1{_bee +="\u0052\u0043\u0034:\u0020\u0034\u0030\u0020\u0062\u0069\u0074\u0073";}else if _bbbf ._baf .V ==2{_bee +=_be .Sprintf ("\u0052\u0043\u0034:\u0020\u0025\u0064\u0020\u0062\u0069\u0074\u0073",_bbbf ._baf .Length );}else if _bbbf ._baf .V ==3{_bee +="U\u006e\u0070\u0075\u0062li\u0073h\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d";
}else if _bbbf ._baf .V >=4{_bee +=_be .Sprintf ("\u0053\u0074r\u0065\u0061\u006d\u0020f\u0069\u006ct\u0065\u0072\u003a\u0020\u0025\u0073\u0020\u002d \u0053\u0074\u0072\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0074\u0065r\u003a\u0020\u0025\u0073",_bbbf ._ebg ,_bbbf ._dcf );
_bee +="\u003b\u0020C\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0073\u003a";for _fgb ,_baee :=range _bbbf ._egg {_bee +=_be .Sprintf ("\u0020\u002d\u0020\u0025\u0073\u003a\u0020\u0025\u0073 \u0028\u0025\u0064\u0029",_fgb ,_baee .Name (),_baee .KeyLength ());
};};_fcd :=_bbbf .GetAccessPermissions ();_bee +=_be .Sprintf ("\u0020\u002d\u0020\u0025\u0023\u0076",_fcd );return _bee ;};

// ASCIIHexEncoder implements ASCII hex encoder/decoder.
type ASCIIHexEncoder struct{};

// UpdateParams updates the parameter values of the encoder.
func (_efed *FlateEncoder )UpdateParams (params *PdfObjectDictionary ){_beb ,_cab :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _cab ==nil {_efed .Predictor =int (_beb );};_affd ,_cab :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));
if _cab ==nil {_efed .BitsPerComponent =int (_affd );};_badg ,_cab :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _cab ==nil {_efed .Columns =int (_badg );};_bea ,_cab :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));
if _cab ==nil {_efed .Colors =int (_bea );};};func (_eeeg *PdfParser )repairLocateXref ()(int64 ,error ){_ggcd :=int64 (1000);_eeeg ._cbfb .Seek (-_ggcd ,_c .SeekCurrent );_gbaea ,_gaga :=_eeeg ._cbfb .Seek (0,_c .SeekCurrent );if _gaga !=nil {return 0,_gaga ;
};_ffced :=make ([]byte ,_ggcd );_eeeg ._cbfb .Read (_ffced );_gffa :=_dfebf .FindAllStringIndex (string (_ffced ),-1);if len (_gffa )< 1{_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0065\u0070a\u0069\u0072\u003a\u0020\u0078\u0072\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021");
return 0,_g .New ("\u0072\u0065\u0070\u0061ir\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064");};_eacd :=int64 (_gffa [len (_gffa )-1][0]);_bgfa :=_gbaea +_eacd ;return _bgfa ,nil ;};func _dgfec (_acge _c .ReadSeeker ,_gggb int64 )(*offsetReader ,error ){_fdbc :=&offsetReader {_cgbf :_acge ,_gag :_gggb };
_ ,_eefcd :=_fdbc .Seek (0,_c .SeekStart );return _fdbc ,_eefcd ;};func (_eff *PdfCrypt )loadCryptFilters (_caf *PdfObjectDictionary )error {_eff ._egg =cryptFilters {};_bbc :=_caf .Get ("\u0043\u0046");_bbc =TraceToDirectObject (_bbc );if _eaea ,_bdd :=_bbc .(*PdfObjectReference );
_bdd {_ggc ,_eag :=_eff ._daf .LookupByReference (*_eaea );if _eag !=nil {_fg .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0075\u0070\u0020\u0043\u0046\u0020\u0072\u0065\u0066\u0065\u0072en\u0063\u0065");
return _eag ;};_bbc =TraceToDirectObject (_ggc );};_fcgf ,_fac :=_bbc .(*PdfObjectDictionary );if !_fac {_fg .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0043\u0046\u002c \u0074\u0079\u0070\u0065: \u0025\u0054",_bbc );return _g .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0043\u0046");
};for _ ,_cgb :=range _fcgf .Keys (){_dfdd :=_fcgf .Get (_cgb );if _fge ,_affc :=_dfdd .(*PdfObjectReference );_affc {_gcg ,_eeg :=_eff ._daf .LookupByReference (*_fge );if _eeg !=nil {_fg .Log .Debug ("\u0045\u0072ro\u0072\u0020\u006co\u006f\u006b\u0075\u0070 up\u0020di\u0063\u0074\u0069\u006f\u006e\u0061\u0072y \u0072\u0065\u0066\u0065\u0072\u0065\u006ec\u0065");
return _eeg ;};_dfdd =TraceToDirectObject (_gcg );};_beeb ,_dag :=_dfdd .(*PdfObjectDictionary );if !_dag {return _be .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074\u0020\u0069\u006e \u0043\u0046\u0020\u0028\u006e\u0061\u006d\u0065\u0020\u0025\u0073\u0029\u0020-\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079\u0020\u0062\u0075\u0074\u0020\u0025\u0054",_cgb ,_dfdd );
};if _cgb =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u002d\u0020\u0043\u0061\u006e\u006e\u006f\u0074\u0020\u006f\u0076\u0065\u0072\u0077r\u0069\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0069d\u0065\u006e\u0074\u0069\u0074\u0079\u0020\u0066\u0069\u006c\u0074\u0065\u0072 \u002d\u0020\u0054\u0072\u0079\u0069n\u0067\u0020\u006ee\u0078\u0074");
continue ;};var _gdf _ed .FilterDict ;if _cag :=_geg (&_gdf ,_beeb );_cag !=nil {return _cag ;};_bfa ,_bca :=_ed .NewFilter (_gdf );if _bca !=nil {return _bca ;};_eff ._egg [string (_cgb )]=_bfa ;};_eff ._egg ["\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"]=_ed .NewIdentity ();
_eff ._dcf ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _gbd ,_gbg :=_caf .Get ("\u0053\u0074\u0072\u0046").(*PdfObjectName );_gbg {if _ ,_fff :=_eff ._egg [string (*_gbd )];!_fff {return _be .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u0072\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_gbd );
};_eff ._dcf =string (*_gbd );};_eff ._ebg ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _fgcg ,_abd :=_caf .Get ("\u0053\u0074\u006d\u0046").(*PdfObjectName );_abd {if _ ,_ddb :=_eff ._egg [string (*_fgcg )];!_ddb {return _be .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u006d\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_fgcg );
};_eff ._ebg =string (*_fgcg );};return nil ;};func (_fdc *PdfParser )loadXrefs ()(*PdfObjectDictionary ,error ){_fdc ._dfb .ObjectMap =make (map[int ]XrefObject );_fdc ._egfg =make (objectStreams );_ebdg ,_fgece :=_fdc ._cbfb .Seek (0,_c .SeekEnd );if _fgece !=nil {return nil ,_fgece ;
};_fg .Log .Trace ("\u0066s\u0069\u007a\u0065\u003a\u0020\u0025d",_ebdg );_fdc ._eecc =_ebdg ;_fgece =_fdc .seekToEOFMarker (_ebdg );if _fgece !=nil {_fg .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0073\u0065\u0065\u006b\u0020\u0074\u006f\u0020\u0065\u006f\u0066\u0020\u006d\u0061\u0072\u006b\u0065\u0072: \u0025\u0076",_fgece );
return nil ,_fgece ;};_caaa ,_fgece :=_fdc ._cbfb .Seek (0,_c .SeekCurrent );if _fgece !=nil {return nil ,_fgece ;};var _bccd int64 =64;_eegd :=_caaa -_bccd ;if _eegd < 0{_eegd =0;};_ ,_fgece =_fdc ._cbfb .Seek (_eegd ,_c .SeekStart );if _fgece !=nil {return nil ,_fgece ;
};_gcef :=make ([]byte ,_bccd );_ ,_fgece =_fdc ._cbfb .Read (_gcef );if _fgece !=nil {_fg .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u003a\u0020\u0025\u0076",_fgece );
return nil ,_fgece ;};_cgaf :=_cbfd .FindStringSubmatch (string (_gcef ));if len (_cgaf )< 2{_fg .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020n\u006f\u0074\u0020f\u006fu\u006e\u0064\u0021");return nil ,_g .New ("\u0073\u0074\u0061\u0072tx\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");
};if len (_cgaf )> 2{_fg .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u004du\u006c\u0074\u0069\u0070\u006c\u0065\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029\u0021",_gcef );return nil ,_g .New ("m\u0075\u006c\u0074\u0069\u0070\u006ce\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065f\u0020\u0065\u006et\u0072i\u0065\u0073\u003f");
};_fdad ,_ :=_b .ParseInt (_cgaf [1],10,64);_fg .Log .Trace ("\u0073t\u0061r\u0074\u0078\u0072\u0065\u0066\u0020\u0061\u0074\u0020\u0025\u0064",_fdad );if _fdad > _ebdg {_fg .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u006f\u0066f\u0073e\u0074 \u006fu\u0074\u0073\u0069\u0064\u0065\u0020\u006f\u0066\u0020\u0066\u0069\u006c\u0065");
_fg .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0072e\u0070\u0061\u0069\u0072");_fdad ,_fgece =_fdc .repairLocateXref ();if _fgece !=nil {_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0052\u0065\u0070\u0061\u0069\u0072\u0020\u0061\u0074\u0074\u0065\u006d\u0070t\u0020\u0066\u0061\u0069\u006c\u0065\u0064 \u0028\u0025\u0073\u0029");
return nil ,_fgece ;};};_fdc ._cbfb .Seek (_fdad ,_c .SeekStart );_fdc ._eeaf =_bd .NewReader (_fdc ._cbfb );_fece ,_fgece :=_fdc .parseXref ();if _fgece !=nil {return nil ,_fgece ;};_efae :=_fece .Get ("\u0058R\u0065\u0066\u0053\u0074\u006d");if _efae !=nil {_fegc ,_cegf :=_efae .(*PdfObjectInteger );
if !_cegf {return nil ,_g .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0021=\u0020\u0069\u006e\u0074");};_ ,_fgece =_fdc .parseXrefStream (_fegc );if _fgece !=nil {return nil ,_fgece ;};};var _abba []int64 ;_dcaad :=func (_caae int64 ,_acca []int64 )bool {for _ ,_dgfg :=range _acca {if _dgfg ==_caae {return true ;
};};return false ;};_efae =_fece .Get ("\u0050\u0072\u0065\u0076");for _efae !=nil {_eccg ,_bggbc :=_efae .(*PdfObjectInteger );if !_bggbc {_fg .Log .Debug ("\u0049\u006ev\u0061\u006c\u0069\u0064\u0020P\u0072\u0065\u0076\u0020\u0072e\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u003a\u0020\u004e\u006f\u0074\u0020\u0061\u0020\u002a\u0050\u0064\u0066\u004f\u0062\u006a\u0065\u0063\u0074\u0049\u006e\u0074\u0065\u0067\u0065\u0072\u0020\u0028\u0025\u0054\u0029",_efae );
return _fece ,nil ;};_eede :=*_eccg ;_fg .Log .Trace ("\u0041\u006eot\u0068\u0065\u0072 \u0050\u0072\u0065\u0076 xr\u0065f \u0074\u0061\u0062\u006c\u0065\u0020\u006fbj\u0065\u0063\u0074\u0020\u0061\u0074\u0020%\u0064",_eede );_fdc ._cbfb .Seek (int64 (_eede ),_c .SeekStart );
_fdc ._eeaf =_bd .NewReader (_fdc ._cbfb );_eaae ,_fgde :=_fdc .parseXref ();if _fgde !=nil {_fg .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0045\u0072\u0072\u006f\u0072\u0020-\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u0061\u0064\u0069n\u0067\u0020\u0061\u006e\u006f\u0074\u0068\u0065\u0072\u0020\u0028\u0050re\u0076\u0029\u0020\u0074\u0072\u0061\u0069\u006c\u0065\u0072");
_fg .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0063\u006f\u006e\u0074\u0069n\u0075\u0065\u0020\u0062\u0079\u0020\u0069\u0067\u006e\u006f\u0072\u0069n\u0067\u0020\u0069\u0074");break ;};_efae =_eaae .Get ("\u0050\u0072\u0065\u0076");
if _efae !=nil {_dddf :=*(_efae .(*PdfObjectInteger ));if _dcaad (int64 (_dddf ),_abba ){_fg .Log .Debug ("\u0050\u0072ev\u0065\u006e\u0074i\u006e\u0067\u0020\u0063irc\u0075la\u0072\u0020\u0078\u0072\u0065\u0066\u0020re\u0066\u0065\u0072\u0065\u006e\u0063\u0069n\u0067");
break ;};_abba =append (_abba ,int64 (_dddf ));};};return _fece ,nil ;};

// IsPrintable checks if a character is printable.
// Regular characters that are outside the range EXCLAMATION MARK(21h)
// (!) to TILDE (7Eh) (~) should be written using the hexadecimal notation.
func IsPrintable (c byte )bool {return 0x21<=c &&c <=0x7E};func (_baeeb *PdfCrypt )saveCryptFilters (_cea *PdfObjectDictionary )error {if _baeeb ._baf .V < 4{return _g .New ("\u0063\u0061\u006e\u0020\u006f\u006e\u006c\u0079\u0020\u0062\u0065 \u0075\u0073\u0065\u0064\u0020\u0077\u0069\u0074\u0068\u0020V\u003e\u003d\u0034");
};_egc :=MakeDict ();_cea .Set ("\u0043\u0046",_egc );for _geag ,_efg :=range _baeeb ._egg {if _geag =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{continue ;};_cba :=_gcbg (_efg ,"");_egc .Set (PdfObjectName (_geag ),_cba );};_cea .Set ("\u0053\u0074\u0072\u0046",MakeName (_baeeb ._dcf ));
_cea .Set ("\u0053\u0074\u006d\u0046",MakeName (_baeeb ._ebg ));return nil ;};

// WriteString outputs the object as it is to be written to file.
func (_gbcf *PdfObjectName )WriteString ()string {var _eceb _fd .Buffer ;if len (*_gbcf )> 127{_fg .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u004e\u0061\u006d\u0065\u0020t\u006fo\u0020l\u006f\u006e\u0067\u0020\u0028\u0025\u0073)",*_gbcf );};_eceb .WriteString ("\u002f");
for _bafa :=0;_bafa < len (*_gbcf );_bafa ++{_bfab :=(*_gbcf )[_bafa ];if !IsPrintable (_bfab )||_bfab =='#'||IsDelimiter (_bfab ){_eceb .WriteString (_be .Sprintf ("\u0023\u0025\u002e2\u0078",_bfab ));}else {_eceb .WriteByte (_bfab );};};return _eceb .String ();
};

// EncodeBytes DCT encodes the passed in slice of bytes.
func (_cecb *DCTEncoder )EncodeBytes (data []byte )([]byte ,error ){_eecd ,_eaeg :=_da .NewImage (_cecb .Width ,_cecb .Height ,_cecb .BitsPerComponent ,_cecb .ColorComponents ,data ,nil ,nil );if _eaeg !=nil {return nil ,_eaeg ;};_fagf :=_ee .Options {};
_fagf .Quality =_cecb .Quality ;var _abb _fd .Buffer ;if _eaeg =_ee .Encode (&_abb ,_eecd ,&_fagf );_eaeg !=nil {return nil ,_eaeg ;};return _abb .Bytes (),nil ;};func (_gc *PdfParser )lookupObjectViaOS (_eg int ,_bbe int )(PdfObject ,error ){var _gfe *_fd .Reader ;
var _efe objectStream ;var _db bool ;_efe ,_db =_gc ._egfg [_eg ];if !_db {_bec ,_bf :=_gc .LookupByNumber (_eg );if _bf !=nil {_fg .Log .Debug ("\u004d\u0069ss\u0069\u006e\u0067 \u006f\u0062\u006a\u0065ct \u0073tr\u0065\u0061\u006d\u0020\u0077\u0069\u0074h \u006e\u0075\u006d\u0062\u0065\u0072\u0020%\u0064",_eg );
return nil ,_bf ;};_abe ,_cd :=_bec .(*PdfObjectStream );if !_cd {return nil ,_g .New ("i\u006e\u0076\u0061\u006cid\u0020o\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d");};if _gc ._ggab !=nil &&!_gc ._ggab .isDecrypted (_abe ){return nil ,_g .New ("\u006e\u0065\u0065\u0064\u0020\u0074\u006f\u0020\u0064\u0065\u0063r\u0079\u0070\u0074\u0020\u0074\u0068\u0065\u0020\u0073\u0074r\u0065\u0061\u006d");
};_aa :=_abe .PdfObjectDictionary ;_fg .Log .Trace ("\u0073o\u0020\u0064\u003a\u0020\u0025\u0073\n",_aa .String ());_df ,_cd :=_aa .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if !_cd {_fg .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0061\u006c\u0077\u0061\u0079\u0073\u0020\u0068\u0061\u0076\u0065\u0020\u0061\u0020\u0054\u0079\u0070\u0065");
return nil ,_g .New ("\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020T\u0079\u0070\u0065");};if _ff .ToLower (string (*_df ))!="\u006f\u0062\u006a\u0073\u0074\u006d"{_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0074\u0079\u0070\u0065\u0020s\u0068\u0061\u006c\u006c\u0020\u0061\u006c\u0077\u0061\u0079\u0073 \u0062\u0065\u0020\u004f\u0062\u006a\u0053\u0074\u006d\u0020\u0021");
return nil ,_g .New ("\u006f\u0062\u006a\u0065c\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0074y\u0070e\u0020\u0021\u003d\u0020\u004f\u0062\u006aS\u0074\u006d");};N ,_cd :=_aa .Get ("\u004e").(*PdfObjectInteger );if !_cd {return nil ,_g .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u004e\u0020i\u006e\u0020\u0073\u0074\u0072\u0065\u0061m\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");
};_dae ,_cd :=_aa .Get ("\u0046\u0069\u0072s\u0074").(*PdfObjectInteger );if !_cd {return nil ,_g .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0046\u0069\u0072\u0073\u0074\u0020i\u006e \u0073t\u0072e\u0061\u006d\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");
};_fg .Log .Trace ("\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0073\u0020\u006eu\u006d\u0062\u0065\u0072\u0020\u006f\u0066 \u006f\u0062\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_df ,*N );_abeg ,_bf :=DecodeStream (_abe );if _bf !=nil {return nil ,_bf ;
};_fg .Log .Trace ("D\u0065\u0063\u006f\u0064\u0065\u0064\u003a\u0020\u0025\u0073",_abeg );_bdc :=_gc .GetFileOffset ();defer func (){_gc .SetFileOffset (_bdc )}();_gfe =_fd .NewReader (_abeg );_gc ._eeaf =_bd .NewReader (_gfe );_fg .Log .Trace ("\u0050a\u0072s\u0069\u006e\u0067\u0020\u006ff\u0066\u0073e\u0074\u0020\u006d\u0061\u0070");
_gda :=map[int ]int64 {};for _fb :=0;_fb < int (*N );_fb ++{_gc .skipSpaces ();_gae ,_cca :=_gc .parseNumber ();if _cca !=nil {return nil ,_cca ;};_cg ,_fdb :=_gae .(*PdfObjectInteger );if !_fdb {return nil ,_g .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");
};_gc .skipSpaces ();_gae ,_cca =_gc .parseNumber ();if _cca !=nil {return nil ,_cca ;};_ad ,_fdb :=_gae .(*PdfObjectInteger );if !_fdb {return nil ,_g .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");
};_fg .Log .Trace ("\u006f\u0062j\u0020\u0025\u0064 \u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0025\u0064",*_cg ,*_ad );_gda [int (*_cg )]=int64 (*_dae +*_ad );};_efe =objectStream {N :int (*N ),_eef :_abeg ,_eefc :_gda };_gc ._egfg [_eg ]=_efe ;}else {_bcf :=_gc .GetFileOffset ();
defer func (){_gc .SetFileOffset (_bcf )}();_gfe =_fd .NewReader (_efe ._eef );_gc ._eeaf =_bd .NewReader (_gfe );};_fcg :=_efe ._eefc [_bbe ];_fg .Log .Trace ("\u0041\u0043\u0054\u0055AL\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u005b\u0025\u0064\u005d\u0020\u003d\u0020%\u0064",_bbe ,_fcg );
_gfe .Seek (_fcg ,_c .SeekStart );_gc ._eeaf =_bd .NewReader (_gfe );_ea ,_ :=_gc ._eeaf .Peek (100);_fg .Log .Trace ("\u004f\u0042\u004a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_ea ));_ag ,_bgg :=_gc .parseObject ();if _bgg !=nil {_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c \u0074\u006f\u0020\u0072\u0065\u0061\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_bgg );
return nil ,_bgg ;};if _ag ==nil {return nil ,_g .New ("o\u0062\u006a\u0065\u0063t \u0063a\u006e\u006e\u006f\u0074\u0020b\u0065\u0020\u006e\u0075\u006c\u006c");};_dd :=PdfIndirectObject {};_dd .ObjectNumber =int64 (_bbe );_dd .PdfObject =_ag ;return &_dd ,nil ;
};

// MakeEncodedString creates a PdfObjectString with encoded content, which can be either
// UTF-16BE or PDFDocEncoding depending on whether `utf16BE` is true or false respectively.
func MakeEncodedString (s string ,utf16BE bool )*PdfObjectString {if utf16BE {var _dedb _fd .Buffer ;_dedb .Write ([]byte {0xFE,0xFF});_dedb .WriteString (_gf .StringToUTF16 (s ));return &PdfObjectString {_aaccd :_dedb .String (),_cef :true };};return &PdfObjectString {_aaccd :string (_gf .StringToPDFDocEncoding (s )),_cef :false };
};func (_fcfe *PdfParser )parseName ()(PdfObjectName ,error ){var _cegg _fd .Buffer ;_cecbb :=false ;for {_afba ,_egec :=_fcfe ._eeaf .Peek (1);if _egec ==_c .EOF {break ;};if _egec !=nil {return PdfObjectName (_cegg .String ()),_egec ;};if !_cecbb {if _afba [0]=='/'{_cecbb =true ;
_fcfe ._eeaf .ReadByte ();}else if _afba [0]=='%'{_fcfe .readComment ();_fcfe .skipSpaces ();}else {_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020N\u0061\u006d\u0065\u0020\u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020w\u0069\u0074\u0068\u0020\u0025\u0073\u0020(\u0025\u0020\u0078\u0029",_afba ,_afba );
return PdfObjectName (_cegg .String ()),_be .Errorf ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u006ea\u006d\u0065:\u0020\u0028\u0025\u0063\u0029",_afba [0]);};}else {if IsWhiteSpace (_afba [0]){break ;}else if (_afba [0]=='/')||(_afba [0]=='[')||(_afba [0]=='(')||(_afba [0]==']')||(_afba [0]=='<')||(_afba [0]=='>'){break ;
}else if _afba [0]=='#'{_ggaa ,_acgd :=_fcfe ._eeaf .Peek (3);if _acgd !=nil {return PdfObjectName (_cegg .String ()),_acgd ;};_dbdf ,_acgd :=_bg .DecodeString (string (_ggaa [1:3]));if _acgd !=nil {_fg .Log .Debug ("\u0045\u0052\u0052\u004fR\u003a\u0020\u0049\u006ev\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0066o\u006c\u006co\u0077\u0069\u006e\u0067 \u0027\u0023\u0027\u002c \u0063\u006f\u006e\u0074\u0069n\u0075\u0069\u006e\u0067\u0020\u0075\u0073i\u006e\u0067\u0020\u006c\u0069t\u0065\u0072\u0061\u006c\u0020\u002d\u0020\u004f\u0075t\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074");
_cegg .WriteByte ('#');_fcfe ._eeaf .Discard (1);continue ;};_fcfe ._eeaf .Discard (3);_cegg .Write (_dbdf );}else {_cebee ,_ :=_fcfe ._eeaf .ReadByte ();_cegg .WriteByte (_cebee );};};};return PdfObjectName (_cegg .String ()),nil ;};

// Set sets the dictionary's key -> val mapping entry. Overwrites if key already set.
func (_dafg *PdfObjectDictionary )Set (key PdfObjectName ,val PdfObject ){_ ,_afega :=_dafg ._ggbc [key ];if !_afega {_dafg ._cabe =append (_dafg ._cabe ,key );};_dafg ._ggbc [key ]=val ;};

// IsWhiteSpace checks if byte represents a white space character.
func IsWhiteSpace (ch byte )bool {if (ch ==0x00)||(ch ==0x09)||(ch ==0x0A)||(ch ==0x0C)||(ch ==0x0D)||(ch ==0x20){return true ;};return false ;};

// PdfObjectString represents the primitive PDF string object.
type PdfObjectString struct{_aaccd string ;_cef bool ;};

// CheckAccessRights checks access rights and permissions for a specified password. If either user/owner password is
// specified, full rights are granted, otherwise the access rights are specified by the Permissions flag.
//
// The bool flag indicates that the user can access and view the file.
// The AccessPermissions shows what access the user has for editing etc.
// An error is returned if there was a problem performing the authentication.
func (_cfaf *PdfParser )CheckAccessRights (password []byte )(bool ,_bda .Permissions ,error ){if _cfaf ._ggab ==nil {return true ,_bda .PermOwner ,nil ;};return _cfaf ._ggab .checkAccessRights (password );};func _dgbbg (_eegee PdfObject ,_gcagf int ,_gede map[PdfObject ]struct{})error {_fg .Log .Trace ("\u0054\u0072\u0061\u0076\u0065\u0072s\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0064\u0061\u0074\u0061 \u0028\u0064\u0065\u0070\u0074\u0068\u0020=\u0020\u0025\u0064\u0029",_gcagf );
if _ ,_aebbf :=_gede [_eegee ];_aebbf {_fg .Log .Trace ("-\u0041\u006c\u0072\u0065ad\u0079 \u0074\u0072\u0061\u0076\u0065r\u0073\u0065\u0064\u002e\u002e\u002e");return nil ;};_gede [_eegee ]=struct{}{};switch _cded :=_eegee .(type ){case *PdfIndirectObject :_deda :=_cded ;
_fg .Log .Trace ("\u0069\u006f\u003a\u0020\u0025\u0073",_deda );_fg .Log .Trace ("\u002d\u0020\u0025\u0073",_deda .PdfObject );return _dgbbg (_deda .PdfObject ,_gcagf +1,_gede );case *PdfObjectStream :_eddeg :=_cded ;return _dgbbg (_eddeg .PdfObjectDictionary ,_gcagf +1,_gede );
case *PdfObjectDictionary :_deba :=_cded ;_fg .Log .Trace ("\u002d\u0020\u0064\u0069\u0063\u0074\u003a\u0020\u0025\u0073",_deba );for _ ,_abff :=range _deba .Keys (){_cccgd :=_deba .Get (_abff );if _ecfag ,_gfedc :=_cccgd .(*PdfObjectReference );_gfedc {_efea :=_ecfag .Resolve ();
_deba .Set (_abff ,_efea );_eefa :=_dgbbg (_efea ,_gcagf +1,_gede );if _eefa !=nil {return _eefa ;};}else {_ecgdb :=_dgbbg (_cccgd ,_gcagf +1,_gede );if _ecgdb !=nil {return _ecgdb ;};};};return nil ;case *PdfObjectArray :_fgeg :=_cded ;_fg .Log .Trace ("-\u0020\u0061\u0072\u0072\u0061\u0079\u003a\u0020\u0025\u0073",_fgeg );
for _egcg ,_aaaea :=range _fgeg .Elements (){if _ebfd ,_edba :=_aaaea .(*PdfObjectReference );_edba {_bdfge :=_ebfd .Resolve ();_fgeg .Set (_egcg ,_bdfge );_fgab :=_dgbbg (_bdfge ,_gcagf +1,_gede );if _fgab !=nil {return _fgab ;};}else {_cedbea :=_dgbbg (_aaaea ,_gcagf +1,_gede );
if _cedbea !=nil {return _cedbea ;};};};return nil ;case *PdfObjectReference :_fg .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020T\u0072\u0061\u0063\u0069\u006e\u0067\u0020\u0061\u0020r\u0065\u0066\u0065r\u0065n\u0063\u0065\u0021");return _g .New ("\u0065r\u0072\u006f\u0072\u0020t\u0072\u0061\u0063\u0069\u006eg\u0020a\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");
};return nil ;};var _dfebf =_ab .MustCompile ("\u005b\\\u0072\u005c\u006e\u005d\u005c\u0073\u002a\u0028\u0078\u0072\u0065f\u0029\u005c\u0073\u002a\u005b\u005c\u0072\u005c\u006e\u005d");

// GetFilterName returns the name of the encoding filter.
func (_efd *RunLengthEncoder )GetFilterName ()string {return StreamEncodingFilterNameRunLength };

// MakeArrayFromIntegers creates an PdfObjectArray from a slice of ints, where each array element is
// an PdfObjectInteger.
func MakeArrayFromIntegers (vals []int )*PdfObjectArray {_efdc :=MakeArray ();for _ ,_bfgd :=range vals {_efdc .Append (MakeInteger (int64 (_bfgd )));};return _efdc ;};

// GetBool returns the *PdfObjectBool object that is represented by a PdfObject directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetBool (obj PdfObject )(_eeed *PdfObjectBool ,_ceaf bool ){_eeed ,_ceaf =TraceToDirectObject (obj ).(*PdfObjectBool );return _eeed ,_ceaf ;};func _efade (_fdfb int )int {if _fdfb < 0{return -_fdfb ;};return _fdfb ;};

// PdfIndirectObject represents the primitive PDF indirect object.
type PdfIndirectObject struct{PdfObjectReference ;PdfObject ;};

// DCTEncoder provides a DCT (JPG) encoding/decoding functionality for images.
type DCTEncoder struct{ColorComponents int ;BitsPerComponent int ;Width int ;Height int ;Quality int ;};

// Clear resets the dictionary to an empty state.
func (_fgbff *PdfObjectDictionary )Clear (){_fgbff ._cabe =[]PdfObjectName {};_fgbff ._ggbc =map[PdfObjectName ]PdfObject {};};

// Get returns the PdfObject corresponding to the specified key.
// Returns a nil value if the key is not set.
func (_gaee *PdfObjectDictionary )Get (key PdfObjectName )PdfObject {_efcd ,_cdbe :=_gaee ._ggbc [key ];if !_cdbe {return nil ;};return _efcd ;};

// GetNumberAsInt64 returns the contents of `obj` as an int64 if it is an integer or float, or an
// error if it isn't. This is for cases where expecting an integer, but some implementations
// actually store the number in a floating point format.
func GetNumberAsInt64 (obj PdfObject )(int64 ,error ){switch _ageb :=obj .(type ){case *PdfObjectFloat :_fg .Log .Debug ("\u004e\u0075m\u0062\u0065\u0072\u0020\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0061\u0073\u0020\u0069\u006e\u0074e\u0067\u0065\u0072\u0020\u0077\u0061s\u0020\u0073\u0074\u006f\u0072\u0065\u0064\u0020\u0061\u0073\u0020\u0066\u006c\u006fa\u0074\u0020(\u0074\u0079\u0070\u0065 \u0063\u0061\u0073\u0074\u0069n\u0067\u0020\u0075\u0073\u0065\u0064\u0029");
return int64 (*_ageb ),nil ;case *PdfObjectInteger :return int64 (*_ageb ),nil ;};return 0,ErrNotANumber ;};

// ParseIndirectObject parses an indirect object from the input stream. Can also be an object stream.
// Returns the indirect object (*PdfIndirectObject) or the stream object (*PdfObjectStream).
func (_eggf *PdfParser )ParseIndirectObject ()(PdfObject ,error ){_ebae :=PdfIndirectObject {};_ebae ._eaca =_eggf ;_fg .Log .Trace ("\u002dR\u0065a\u0064\u0020\u0069\u006e\u0064i\u0072\u0065c\u0074\u0020\u006f\u0062\u006a");_egag ,_dfgea :=_eggf ._eeaf .Peek (20);
if _dfgea !=nil {if _dfgea !=_c .EOF {_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020r\u0065a\u0064\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a");return &_ebae ,_dfgea ;
};};_fg .Log .Trace ("\u0028\u0069\u006edi\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_egag ));_cedbe :=_dgbd .FindStringSubmatchIndex (string (_egag ));if len (_cedbe )< 6{if _dfgea ==_c .EOF {return nil ,_dfgea ;
};_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_egag ));
return &_ebae ,_g .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");
};_eggf ._eeaf .Discard (_cedbe [0]);_fg .Log .Trace ("O\u0066\u0066\u0073\u0065\u0074\u0073\u0020\u0025\u0020\u0064",_cedbe );_bgcba :=_cedbe [1]-_cedbe [0];_egea :=make ([]byte ,_bgcba );_ ,_dfgea =_eggf .ReadAtLeast (_egea ,_bgcba );if _dfgea !=nil {_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u0072\u0065\u0061\u0064\u0020-\u0020\u0025\u0073",_dfgea );
return nil ,_dfgea ;};_fg .Log .Trace ("\u0074\u0065\u0078t\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_egea );_dbeb :=_dgbd .FindStringSubmatch (string (_egea ));if len (_dbeb )< 3{_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_egea ));
return &_ebae ,_g .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");
};_cbea ,_ :=_b .Atoi (_dbeb [1]);_afac ,_ :=_b .Atoi (_dbeb [2]);_ebae .ObjectNumber =int64 (_cbea );_ebae .GenerationNumber =int64 (_afac );for {_afbfe ,_egcab :=_eggf ._eeaf .Peek (2);if _egcab !=nil {return &_ebae ,_egcab ;};_fg .Log .Trace ("I\u006ed\u002e\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_afbfe ),string (_afbfe ));
if IsWhiteSpace (_afbfe [0]){_eggf .skipSpaces ();}else if _afbfe [0]=='%'{_eggf .skipComments ();}else if (_afbfe [0]=='<')&&(_afbfe [1]=='<'){_fg .Log .Trace ("\u0043\u0061\u006c\u006c\u0020\u0050\u0061\u0072\u0073e\u0044\u0069\u0063\u0074");_ebae .PdfObject ,_egcab =_eggf .ParseDict ();
_fg .Log .Trace ("\u0045\u004f\u0046\u0020Ca\u006c\u006c\u0020\u0050\u0061\u0072\u0073\u0065\u0044\u0069\u0063\u0074\u003a\u0020%\u0076",_egcab );if _egcab !=nil {return &_ebae ,_egcab ;};_fg .Log .Trace ("\u0050\u0061\u0072\u0073\u0065\u0064\u0020\u0064\u0069\u0063t\u0069\u006f\u006e\u0061\u0072\u0079\u002e.\u002e\u0020\u0066\u0069\u006e\u0069\u0073\u0068\u0065\u0064\u002e");
}else if (_afbfe [0]=='/')||(_afbfe [0]=='(')||(_afbfe [0]=='[')||(_afbfe [0]=='<'){_ebae .PdfObject ,_egcab =_eggf .parseObject ();if _egcab !=nil {return &_ebae ,_egcab ;};_fg .Log .Trace ("P\u0061\u0072\u0073\u0065\u0064\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u002e\u002e\u002e \u0066\u0069\u006ei\u0073h\u0065\u0064\u002e");
}else if _afbfe [0]==']'{_fg .Log .Debug ("\u0057\u0041\u0052\u004e\u0049N\u0047\u003a\u0020\u0027\u005d\u0027 \u0063\u0068\u0061\u0072\u0061\u0063\u0074e\u0072\u0020\u006eo\u0074\u0020\u0062\u0065i\u006e\u0067\u0020\u0075\u0073\u0065d\u0020\u0061\u0073\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006e\u0064\u0069n\u0067\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e");
_eggf ._eeaf .Discard (1);}else {if _afbfe [0]=='e'{_cadf ,_agdbd :=_eggf .readTextLine ();if _agdbd !=nil {return nil ,_agdbd ;};if len (_cadf )>=6&&_cadf [0:6]=="\u0065\u006e\u0064\u006f\u0062\u006a"{break ;};}else if _afbfe [0]=='s'{_afbfe ,_ =_eggf ._eeaf .Peek (10);
if string (_afbfe [:6])=="\u0073\u0074\u0072\u0065\u0061\u006d"{_fdcf :=6;if len (_afbfe )> 6{if IsWhiteSpace (_afbfe [_fdcf ])&&_afbfe [_fdcf ]!='\r'&&_afbfe [_fdcf ]!='\n'{_fg .Log .Debug ("\u004e\u006fn\u002d\u0063\u006f\u006e\u0066\u006f\u0072\u006d\u0061\u006e\u0074\u0020\u0050\u0044\u0046\u0020\u006e\u006f\u0074 \u0065\u006e\u0064\u0069\u006e\u0067 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0069\u006e\u0065\u0020\u0070\u0072o\u0070\u0065r\u006c\u0079\u0020\u0077i\u0074\u0068\u0020\u0045\u004fL\u0020\u006d\u0061\u0072\u006b\u0065\u0072");
_fdcf ++;};if _afbfe [_fdcf ]=='\r'{_fdcf ++;if _afbfe [_fdcf ]=='\n'{_fdcf ++;};}else if _afbfe [_fdcf ]=='\n'{_fdcf ++;};};_eggf ._eeaf .Discard (_fdcf );_ebba ,_eagfd :=_ebae .PdfObject .(*PdfObjectDictionary );if !_eagfd {return nil ,_g .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006di\u0073s\u0069\u006e\u0067\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");
};_fg .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0069c\u0074\u0020\u0025\u0073",_ebba );_aaef ,_bdba :=_eggf .traceStreamLength (_ebba .Get ("\u004c\u0065\u006e\u0067\u0074\u0068"));if _bdba !=nil {_fg .Log .Debug ("\u0046\u0061\u0069l\u0020\u0074\u006f\u0020t\u0072\u0061\u0063\u0065\u0020\u0073\u0074r\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0025\u0076",_bdba );
return nil ,_bdba ;};_fg .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_aaef );_bfdb ,_ceba :=_aaef .(*PdfObjectInteger );if !_ceba {return nil ,_g .New ("\u0073\u0074re\u0061\u006d\u0020l\u0065\u006e\u0067\u0074h n\u0065ed\u0073\u0020\u0074\u006f\u0020\u0062\u0065 a\u006e\u0020\u0069\u006e\u0074\u0065\u0067e\u0072");
};_ecdg :=*_bfdb ;if _ecdg < 0{return nil ,_g .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006e\u0065\u0065\u0064\u0073\u0020\u0074\u006f \u0062e\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0030");};_bgcfe :=_eggf .GetFileOffset ();
_dfae :=_eggf .xrefNextObjectOffset (_bgcfe );if _bgcfe +int64 (_ecdg )> _dfae &&_dfae > _bgcfe {_fg .Log .Debug ("E\u0078\u0070\u0065\u0063te\u0064 \u0065\u006e\u0064\u0069\u006eg\u0020\u0061\u0074\u0020\u0025\u0064",_bgcfe +int64 (_ecdg ));_fg .Log .Debug ("\u004e\u0065\u0078\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020\u0061t\u0020\u0025\u0064",_dfae );
_dggg :=_dfae -_bgcfe -17;if _dggg < 0{return nil ,_g .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020go\u0069\u006e\u0067 \u0070\u0061s\u0074\u0020\u0062\u006f\u0075\u006ed\u0061\u0072i\u0065\u0073");
};_fg .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0061\u0020l\u0065\u006e\u0067\u0074\u0068\u0020c\u006f\u0072\u0072\u0065\u0063\u0074\u0069\u006f\u006e\u0020\u0074\u006f\u0020%\u0064\u002e\u002e\u002e",_dggg );_ecdg =PdfObjectInteger (_dggg );
_ebba .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (_dggg ));};if int64 (_ecdg )> _eggf ._eecc {_fg .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0053t\u0072\u0065\u0061\u006d\u0020l\u0065\u006e\u0067\u0074\u0068\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u0061\u0072\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0066\u0069\u006c\u0065\u0020\u0073\u0069\u007a\u0065");
return nil ,_g .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020la\u0072\u0067\u0065r\u0020\u0074h\u0061\u006e\u0020\u0066\u0069\u006ce\u0020\u0073i\u007a\u0065");};_eefcdc :=make ([]byte ,_ecdg );
_ ,_bdba =_eggf .ReadAtLeast (_eefcdc ,int (_ecdg ));if _bdba !=nil {_fg .Log .Debug ("E\u0052\u0052\u004f\u0052 s\u0074r\u0065\u0061\u006d\u0020\u0028%\u0064\u0029\u003a\u0020\u0025\u0058",len (_eefcdc ),_eefcdc );_fg .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_bdba );
return nil ,_bdba ;};_acgdg :=PdfObjectStream {};_acgdg .Stream =_eefcdc ;_acgdg .PdfObjectDictionary =_ebae .PdfObject .(*PdfObjectDictionary );_acgdg .ObjectNumber =_ebae .ObjectNumber ;_acgdg .GenerationNumber =_ebae .GenerationNumber ;_acgdg .PdfObjectReference ._eaca =_eggf ;
_eggf .skipSpaces ();_eggf ._eeaf .Discard (9);_eggf .skipSpaces ();return &_acgdg ,nil ;};};_ebae .PdfObject ,_egcab =_eggf .parseObject ();if _ebae .PdfObject ==nil {_fg .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");
_ebae .PdfObject =MakeNull ();};return &_ebae ,_egcab ;};};if _ebae .PdfObject ==nil {_fg .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");
_ebae .PdfObject =MakeNull ();};_fg .Log .Trace ("\u0052\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0021");return &_ebae ,nil ;};

// Version represents a version of a PDF standard.
type Version struct{Major int ;Minor int ;};

// NewJBIG2Encoder creates a new JBIG2Encoder.
func NewJBIG2Encoder ()*JBIG2Encoder {return &JBIG2Encoder {_bfdf :_ef .InitEncodeDocument (false )}};

// MakeArrayFromFloats creates an PdfObjectArray from a slice of float64s, where each array element is an
// PdfObjectFloat.
func MakeArrayFromFloats (vals []float64 )*PdfObjectArray {_eege :=MakeArray ();for _ ,_cfbaf :=range vals {_eege .Append (MakeFloat (_cfbaf ));};return _eege ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_bgf *LZWEncoder )MakeDecodeParams ()PdfObject {if _bgf .Predictor > 1{_gdg :=MakeDict ();_gdg .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_bgf .Predictor )));if _bgf .BitsPerComponent !=8{_gdg .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_bgf .BitsPerComponent )));
};if _bgf .Columns !=1{_gdg .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_bgf .Columns )));};if _bgf .Colors !=1{_gdg .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_bgf .Colors )));};return _gdg ;};return nil ;};


// MakeStringFromBytes creates an PdfObjectString from a byte array.
// This is more natural than MakeString as `data` is usually not utf-8 encoded.
func MakeStringFromBytes (data []byte )*PdfObjectString {return MakeString (string (data ))};

// EncryptInfo contains an information generated by the document encrypter.
type EncryptInfo struct{Version ;

// Encrypt is an encryption dictionary that contains all necessary parameters.
// It should be stored in all copies of the document trailer.
Encrypt *PdfObjectDictionary ;

// ID0 and ID1 are IDs used in the trailer. Older algorithms such as RC4 uses them for encryption.
ID0 ,ID1 string ;};

// GetInt returns the *PdfObjectBool object that is represented by a PdfObject either directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetInt (obj PdfObject )(_cged *PdfObjectInteger ,_gfbg bool ){_cged ,_gfbg =TraceToDirectObject (obj ).(*PdfObjectInteger );return _cged ,_gfbg ;};

// MakeDict creates and returns an empty PdfObjectDictionary.
func MakeDict ()*PdfObjectDictionary {_gfg :=&PdfObjectDictionary {};_gfg ._ggbc =map[PdfObjectName ]PdfObject {};_gfg ._cabe =[]PdfObjectName {};return _gfg ;};func (_bcgf *PdfCrypt )generateParams (_fab ,_aaa []byte )error {_dbcf :=_bcgf .securityHandler ();
_eea ,_ceb :=_dbcf .GenerateParams (&_bcgf ._aea ,_aaa ,_fab );if _ceb !=nil {return _ceb ;};_bcgf ._cec =_eea ;return nil ;};type offsetReader struct{_cgbf _c .ReadSeeker ;_gag int64 ;};

// GetFilterName returns the name of the encoding filter.
func (_debb *JPXEncoder )GetFilterName ()string {return StreamEncodingFilterNameJPX };var _egbe =_ab .MustCompile ("\u005c\u0073\u002a\u0078\u0072\u0065\u0066\u005c\u0073\u002a");

// DecodeStream decodes the stream data and returns the decoded data.
// An error is returned upon failure.
func DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_fg .Log .Trace ("\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_aaeb ,_bbeca :=NewEncoderFromStream (streamObj );if _bbeca !=nil {_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_bbeca );
return nil ,_bbeca ;};_fg .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076\u000a",_aaeb );_cbfbd ,_bbeca :=_aaeb .DecodeStream (streamObj );if _bbeca !=nil {_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_bbeca );
return nil ,_bbeca ;};return _cbfbd ,nil ;};func (_fdge *PdfParser )traceStreamLength (_eaece PdfObject )(PdfObject ,error ){_dfcf ,_dfacf :=_eaece .(*PdfObjectReference );if _dfacf {_fdbcg ,_edfcf :=_fdge ._abec [_dfcf .ObjectNumber ];if _edfcf &&_fdbcg {_fg .Log .Debug ("\u0053t\u0072\u0065a\u006d\u0020\u004c\u0065n\u0067\u0074\u0068 \u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065 u\u006e\u0072\u0065s\u006f\u006cv\u0065\u0064\u0020\u0028\u0069\u006cl\u0065\u0067a\u006c\u0029");
return nil ,_g .New ("\u0069\u006c\u006c\u0065ga\u006c\u0020\u0072\u0065\u0063\u0075\u0072\u0073\u0069\u0076\u0065\u0020\u006c\u006fo\u0070");};_fdge ._abec [_dfcf .ObjectNumber ]=true ;};_cdbf ,_agdb :=_fdge .Resolve (_eaece );if _agdb !=nil {return nil ,_agdb ;
};_fg .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_cdbf );if _dfacf {_fdge ._abec [_dfcf .ObjectNumber ]=false ;};return _cdbf ,nil ;};func (_ddcb *PdfParser )seekPdfVersionTopDown ()(int ,int ,error ){_ddcb ._cbfb .Seek (0,_c .SeekStart );
_ddcb ._eeaf =_bd .NewReader (_ddcb ._cbfb );_dcfc :=20;_gecd :=make ([]byte ,_dcfc );for {_bafba ,_fgdf :=_ddcb ._eeaf .ReadByte ();if _fgdf !=nil {if _fgdf ==_c .EOF {break ;}else {return 0,0,_fgdf ;};};if IsDecimalDigit (_bafba )&&_gecd [_dcfc -1]=='.'&&IsDecimalDigit (_gecd [_dcfc -2])&&_gecd [_dcfc -3]=='-'&&_gecd [_dcfc -4]=='F'&&_gecd [_dcfc -5]=='D'&&_gecd [_dcfc -6]=='P'{_fggcf :=int (_gecd [_dcfc -2]-'0');
_bddbb :=int (_bafba -'0');return _fggcf ,_bddbb ,nil ;};_gecd =append (_gecd [1:_dcfc ],_bafba );};return 0,0,_g .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};func (_acaa *PdfParser )parseNull ()(PdfObjectNull ,error ){_ ,_abgg :=_acaa ._eeaf .Discard (4);
return PdfObjectNull {},_abgg ;};

// String returns a string describing `streams`.
func (_ccaad *PdfObjectStreams )String ()string {return _be .Sprintf ("\u004f\u0062j\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0025\u0064",_ccaad .ObjectNumber );};

// NewDCTEncoder makes a new DCT encoder with default parameters.
func NewDCTEncoder ()*DCTEncoder {_fag :=&DCTEncoder {};_fag .ColorComponents =3;_fag .BitsPerComponent =8;_fag .Quality =DefaultJPEGQuality ;return _fag ;};func _dffc (_bagb PdfObject )(*float64 ,error ){switch _aafb :=_bagb .(type ){case *PdfObjectFloat :_egfgd :=float64 (*_aafb );
return &_egfgd ,nil ;case *PdfObjectInteger :_becda :=float64 (*_aafb );return &_becda ,nil ;case *PdfObjectNull :return nil ,nil ;};return nil ,ErrNotANumber ;};type encryptDict struct{Filter string ;V int ;SubFilter string ;Length int ;StmF string ;StrF string ;
EFF string ;CF map[string ]_ed .FilterDict ;};

// WriteString outputs the object as it is to be written to file.
func (_aaac *PdfObjectBool )WriteString ()string {if *_aaac {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};func _dcag (_cgfea ,_ggecf PdfObject ,_afbda int )bool {if _afbda > _ddgf {_fg .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_ddgf );
return false ;};if _cgfea ==nil &&_ggecf ==nil {return true ;}else if _cgfea ==nil ||_ggecf ==nil {return false ;};if _ga .TypeOf (_cgfea )!=_ga .TypeOf (_ggecf ){return false ;};switch _bdgc :=_cgfea .(type ){case *PdfObjectNull ,*PdfObjectReference :return true ;
case *PdfObjectName :return *_bdgc ==*(_ggecf .(*PdfObjectName ));case *PdfObjectString :return *_bdgc ==*(_ggecf .(*PdfObjectString ));case *PdfObjectInteger :return *_bdgc ==*(_ggecf .(*PdfObjectInteger ));case *PdfObjectBool :return *_bdgc ==*(_ggecf .(*PdfObjectBool ));
case *PdfObjectFloat :return *_bdgc ==*(_ggecf .(*PdfObjectFloat ));case *PdfIndirectObject :return _dcag (TraceToDirectObject (_cgfea ),TraceToDirectObject (_ggecf ),_afbda +1);case *PdfObjectArray :_gbfa :=_ggecf .(*PdfObjectArray );if len ((*_bdgc )._eadg )!=len ((*_gbfa )._eadg ){return false ;
};for _agcb ,_gefbb :=range (*_bdgc )._eadg {if !_dcag (_gefbb ,(*_gbfa )._eadg [_agcb ],_afbda +1){return false ;};};return true ;case *PdfObjectDictionary :_fecba :=_ggecf .(*PdfObjectDictionary );_cggec ,_eaaff :=(*_bdgc )._ggbc ,(*_fecba )._ggbc ;if len (_cggec )!=len (_eaaff ){return false ;
};for _dedd ,_daag :=range _cggec {_bgaef ,_agdcd :=_eaaff [_dedd ];if !_agdcd ||!_dcag (_daag ,_bgaef ,_afbda +1){return false ;};};return true ;case *PdfObjectStream :_edeb :=_ggecf .(*PdfObjectStream );return _dcag ((*_bdgc ).PdfObjectDictionary ,(*_edeb ).PdfObjectDictionary ,_afbda +1);
default:_fg .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",_cgfea );
};return false ;};

// SetImage sets the image base for given flate encoder.
func (_fdfdd *FlateEncoder )SetImage (img *_da .ImageBase ){_fdfdd ._gfee =img };

// IsFloatDigit checks if a character can be a part of a float number string.
func IsFloatDigit (c byte )bool {return ('0'<=c &&c <='9')||c =='.'};

// DecodeStream implements ASCII85 stream decoding.
func (_fbed *ASCII85Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _fbed .DecodeBytes (streamObj .Stream );};

// String returns a string representation of `name`.
func (_fffa *PdfObjectName )String ()string {return string (*_fffa )};

// WriteString outputs the object as it is to be written to file.
func (_ffcg *PdfObjectArray )WriteString ()string {var _cefe _ff .Builder ;_cefe .WriteString ("\u005b");for _adgb ,_geda :=range _ffcg .Elements (){_cefe .WriteString (_geda .WriteString ());if _adgb < (_ffcg .Len ()-1){_cefe .WriteString ("\u0020");};
};_cefe .WriteString ("\u005d");return _cefe .String ();};

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_defd *FlateEncoder )EncodeBytes (data []byte )([]byte ,error ){if _defd .Predictor !=1&&_defd .Predictor !=11{_fg .Log .Debug ("E\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0046\u006c\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065r\u0020P\u0072\u0065\u0064\u0069c\u0074\u006fr\u0020\u003d\u0020\u0031\u002c\u0020\u0031\u0031\u0020\u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");
return nil ,ErrUnsupportedEncodingParameters ;};if _defd .Predictor ==11{_ffc :=_defd .Columns ;_dgcg :=len (data )/_ffc ;if len (data )%_ffc !=0{_fg .Log .Error ("\u0049n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");
return nil ,_g .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");};_bbg :=_fd .NewBuffer (nil );_dgf :=make ([]byte ,_ffc );for _feba :=0;_feba < _dgcg ;_feba ++{_bccc :=data [_ffc *_feba :_ffc *(_feba +1)];
_dgf [0]=_bccc [0];for _agbb :=1;_agbb < _ffc ;_agbb ++{_dgf [_agbb ]=byte (int (_bccc [_agbb ]-_bccc [_agbb -1])%256);};_bbg .WriteByte (1);_bbg .Write (_dgf );};data =_bbg .Bytes ();};var _gcca _fd .Buffer ;_cafa :=_eb .NewWriter (&_gcca );_cafa .Write (data );
_cafa .Close ();return _gcca .Bytes (),nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_cgbe *CCITTFaxEncoder )MakeDecodeParams ()PdfObject {_faf :=MakeDict ();_faf .Set ("\u004b",MakeInteger (int64 (_cgbe .K )));_faf .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_cgbe .Columns )));if _cgbe .BlackIs1 {_faf .Set ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031",MakeBool (_cgbe .BlackIs1 ));
};if _cgbe .EncodedByteAlign {_faf .Set ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e",MakeBool (_cgbe .EncodedByteAlign ));};if _cgbe .EndOfLine &&_cgbe .K >=0{_faf .Set ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee",MakeBool (_cgbe .EndOfLine ));
};if _cgbe .Rows !=0&&!_cgbe .EndOfBlock {_faf .Set ("\u0052\u006f\u0077\u0073",MakeInteger (int64 (_cgbe .Rows )));};if !_cgbe .EndOfBlock {_faf .Set ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b",MakeBool (_cgbe .EndOfBlock ));};if _cgbe .DamagedRowsBeforeError !=0{_faf .Set ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072",MakeInteger (int64 (_cgbe .DamagedRowsBeforeError )));
};return _faf ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_gdd *RawEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};

// EncodeBytes implements support for LZW encoding.  Currently not supporting predictors (raw compressed data only).
// Only supports the Early change = 1 algorithm (compress/lzw) as the other implementation
// does not have a write method.
// TODO: Consider refactoring compress/lzw to allow both.
func (_dgb *LZWEncoder )EncodeBytes (data []byte )([]byte ,error ){if _dgb .Predictor !=1{return nil ,_be .Errorf ("\u004c\u005aW \u0050\u0072\u0065d\u0069\u0063\u0074\u006fr =\u00201 \u006f\u006e\u006c\u0079\u0020\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0079e\u0074");
};if _dgb .EarlyChange ==1{return nil ,_be .Errorf ("\u004c\u005a\u0057\u0020\u0045\u0061\u0072\u006c\u0079\u0020\u0043\u0068\u0061n\u0067\u0065\u0020\u003d\u0020\u0030 \u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0079\u0065\u0074");
};var _fddb _fd .Buffer ;_bcd :=_fa .NewWriter (&_fddb ,_fa .MSB ,8);_bcd .Write (data );_bcd .Close ();return _fddb .Bytes (),nil ;};

// String returns a string describing `null`.
func (_adgec *PdfObjectNull )String ()string {return "\u006e\u0075\u006c\u006c"};func (_fede *offsetReader )Read (p []byte )(_egdab int ,_dbaf error ){return _fede ._cgbf .Read (p )};func (_dedc *PdfParser )parseXrefTable ()(*PdfObjectDictionary ,error ){var _cgcb *PdfObjectDictionary ;
_cbbf ,_gbb :=_dedc .readTextLine ();if _gbb !=nil {return nil ,_gbb ;};_fg .Log .Trace ("\u0078\u0072\u0065\u0066 f\u0069\u0072\u0073\u0074\u0020\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_cbbf );_defcd :=-1;_egee :=0;_gebbb :=false ;_gcfba :="";
for {_dedc .skipSpaces ();_ ,_dffd :=_dedc ._eeaf .Peek (1);if _dffd !=nil {return nil ,_dffd ;};_cbbf ,_dffd =_dedc .readTextLine ();if _dffd !=nil {return nil ,_dffd ;};_cdccc :=_ffce .FindStringSubmatch (_cbbf );if len (_cdccc )==0{_fgfb :=len (_gcfba )> 0;
_gcfba +=_cbbf +"\u000a";if _fgfb {_cdccc =_ffce .FindStringSubmatch (_gcfba );};};if len (_cdccc )==3{_bdcd ,_ :=_b .Atoi (_cdccc [1]);_geegg ,_ :=_b .Atoi (_cdccc [2]);_defcd =_bdcd ;_egee =_geegg ;_gebbb =true ;_gcfba ="";_fg .Log .Trace ("\u0078r\u0065\u0066 \u0073\u0075\u0062s\u0065\u0063\u0074\u0069\u006f\u006e\u003a \u0066\u0069\u0072\u0073\u0074\u0020o\u0062\u006a\u0065\u0063\u0074\u003a\u0020\u0025\u0064\u0020\u006fb\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_defcd ,_egee );
continue ;};_gddd :=_gbacd .FindStringSubmatch (_cbbf );if len (_gddd )==4{if !_gebbb {_fg .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0058r\u0065\u0066\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u006fr\u006da\u0074\u0021\u000a");return nil ,_g .New ("\u0078\u0072\u0065\u0066 i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072\u006d\u0061\u0074");
};_afcc ,_ :=_b .ParseInt (_gddd [1],10,64);_eacb ,_ :=_b .Atoi (_gddd [2]);_eeba :=_gddd [3];_gcfba ="";if _ff .ToLower (_eeba )=="\u006e"&&_afcc > 1{_gdfe ,_cdb :=_dedc ._dfb .ObjectMap [_defcd ];if !_cdb ||_eacb > _gdfe .Generation {_afeed :=XrefObject {ObjectNumber :_defcd ,XType :XrefTypeTableEntry ,Offset :_afcc ,Generation :_eacb };
_dedc ._dfb .ObjectMap [_defcd ]=_afeed ;};};_defcd ++;continue ;};if (len (_cbbf )> 6)&&(_cbbf [:7]=="\u0074r\u0061\u0069\u006c\u0065\u0072"){_fg .Log .Trace ("\u0046o\u0075n\u0064\u0020\u0074\u0072\u0061i\u006c\u0065r\u0020\u002d\u0020\u0025\u0073",_cbbf );
if len (_cbbf )> 9{_dbdd :=_dedc .GetFileOffset ();_dedc .SetFileOffset (_dbdd -int64 (len (_cbbf ))+7);};_dedc .skipSpaces ();_dedc .skipComments ();_fg .Log .Trace ("R\u0065\u0061\u0064\u0069ng\u0020t\u0072\u0061\u0069\u006c\u0065r\u0020\u0064\u0069\u0063\u0074\u0021");
_fg .Log .Trace ("\u0070\u0065\u0065\u006b\u003a\u0020\u0022\u0025\u0073\u0022",_cbbf );_cgcb ,_dffd =_dedc .ParseDict ();_fg .Log .Trace ("\u0045O\u0046\u0020\u0072\u0065a\u0064\u0069\u006e\u0067\u0020t\u0072a\u0069l\u0065\u0072\u0020\u0064\u0069\u0063\u0074!");
if _dffd !=nil {_fg .Log .Debug ("\u0045\u0072\u0072o\u0072\u0020\u0070\u0061r\u0073\u0069\u006e\u0067\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u0064\u0069\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_dffd );return nil ,_dffd ;};break ;};if _cbbf =="\u0025\u0025\u0045O\u0046"{_fg .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006e\u0064 \u006f\u0066\u0020\u0066\u0069\u006c\u0065 -\u0020\u0074\u0072\u0061i\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066ou\u006e\u0064 \u002d\u0020\u0065\u0072\u0072\u006f\u0072\u0021");
return nil ,_g .New ("\u0065\u006e\u0064 \u006f\u0066\u0020\u0066i\u006c\u0065\u0020\u002d\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};_fg .Log .Trace ("\u0078\u0072\u0065\u0066\u0020\u006d\u006f\u0072\u0065 \u003a\u0020\u0025\u0073",_cbbf );
};_fg .Log .Trace ("\u0045\u004f\u0046 p\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0021");if _dedc ._acfg ==nil {_daff :=XrefTypeTableEntry ;_dedc ._acfg =&_daff ;};return _cgcb ,nil ;};

// RunLengthEncoder represents Run length encoding.
type RunLengthEncoder struct{};var _cfae =[]PdfObjectName {"\u0056","\u0052","\u004f","\u0055","\u0050"};func (_abf *PdfCrypt )encryptBytes (_ebb []byte ,_bdg string ,_dabd []byte )([]byte ,error ){_fg .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");
_ade ,_fecg :=_abf ._egg [_bdg ];if !_fecg {return nil ,_be .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_bdg );};return _ade .EncryptBytes (_ebb ,_dabd );};func (_egbd *offsetReader )Seek (offset int64 ,whence int )(int64 ,error ){if whence ==_c .SeekStart {offset +=_egbd ._gag ;
};_gcfc ,_bfce :=_egbd ._cgbf .Seek (offset ,whence );if _bfce !=nil {return _gcfc ,_bfce ;};if whence ==_c .SeekCurrent {_gcfc -=_egbd ._gag ;};if _gcfc < 0{return 0,_g .New ("\u0063\u006f\u0072\u0065\u002eo\u0066\u0066\u0073\u0065\u0074\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053e\u0065\u006b\u003a\u0020\u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e");
};return _gcfc ,nil ;};

// String returns a string describing `ref`.
func (_gffga *PdfObjectReference )String ()string {return _be .Sprintf ("\u0052\u0065\u0066\u0028\u0025\u0064\u0020\u0025\u0064\u0029",_gffga .ObjectNumber ,_gffga .GenerationNumber );};

// ToGoImage converts the JBIG2Image to the golang image.Image.
func (_cegd *JBIG2Image )ToGoImage ()(_fc .Image ,error ){const _ffbb ="J\u0042I\u0047\u0032\u0049\u006d\u0061\u0067\u0065\u002eT\u006f\u0047\u006f\u0049ma\u0067\u0065";if _cegd .Data ==nil {return nil ,_bb .Error (_ffbb ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");
};if _cegd .Width ==0||_cegd .Height ==0{return nil ,_bb .Error (_ffbb ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");
};_bcbg ,_gebb :=_da .NewImage (_cegd .Width ,_cegd .Height ,1,1,_cegd .Data ,nil ,nil );if _gebb !=nil {return nil ,_gebb ;};return _bcbg ,nil ;};func _dbec ()string {return _fg .Version };var _bbfd =_ab .MustCompile ("\u005e\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");


// GetObjectNums returns a sorted list of object numbers of the PDF objects in the file.
func (_aega *PdfParser )GetObjectNums ()[]int {var _cfee []int ;for _ ,_egcc :=range _aega ._dfb .ObjectMap {_cfee =append (_cfee ,_egcc .ObjectNumber );};_f .Ints (_cfee );return _cfee ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_ecbbb *MultiEncoder )MakeStreamDict ()*PdfObjectDictionary {_affbg :=MakeDict ();_affbg .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",_ecbbb .GetFilterArray ());for _ ,_cfbb :=range _ecbbb ._feab {_bgcd :=_cfbb .MakeStreamDict ();for _ ,_bggb :=range _bgcd .Keys (){_dgfe :=_bgcd .Get (_bggb );
if _bggb !="\u0046\u0069\u006c\u0074\u0065\u0072"&&_bggb !="D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"{_affbg .Set (_bggb ,_dgfe );};};};_dbfa :=_ecbbb .MakeDecodeParams ();if _dbfa !=nil {_affbg .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_dbfa );
};return _affbg ;};

// Len returns the number of elements in the streams.
func (_gdab *PdfObjectStreams )Len ()int {if _gdab ==nil {return 0;};return len (_gdab ._aebba );};

// GetAccessPermissions returns the PDF access permissions as an AccessPermissions object.
func (_facc *PdfCrypt )GetAccessPermissions ()_bda .Permissions {return _facc ._aea .P };