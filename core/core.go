//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package core defines and implements the primitive PDF object types in golang, and provides functionality
// for parsing those from a PDF file stream. This includes I/O handling, cross references, repairs, encryption,
// encoding and other core capabilities.
package core ;import (_gf "bufio";_gec "bytes";_ca "compress/lzw";_be "compress/zlib";_ge "crypto/md5";_cgg "crypto/rand";_cd "encoding/hex";_e "errors";_ff "fmt";_beg "github.com/unidoc/unipdf/v3/common";_bca "github.com/unidoc/unipdf/v3/core/security";_ag "github.com/unidoc/unipdf/v3/core/security/crypt";_ab "github.com/unidoc/unipdf/v3/internal/ccittfax";_da "github.com/unidoc/unipdf/v3/internal/imageutil";_gae "github.com/unidoc/unipdf/v3/internal/jbig2";_fg "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_cc "github.com/unidoc/unipdf/v3/internal/jbig2/decoder";_bc "github.com/unidoc/unipdf/v3/internal/jbig2/document";_aa "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_cae "github.com/unidoc/unipdf/v3/internal/strutils";_bb "golang.org/x/image/tiff/lzw";_gbg "golang.org/x/xerrors";_ga "image";_efb "image/color";_gb "image/jpeg";_cg "io";_bf "os";_f "reflect";_ef "regexp";_g "sort";_b "strconv";_d "strings";_a "time";);

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_bba *ASCIIHexEncoder )MakeDecodeParams ()PdfObject {return nil };func (_acdd *PdfParser )resolveReference (_affed *PdfObjectReference )(PdfObject ,bool ,error ){_cbcgf ,_beefd :=_acdd .ObjCache [int (_affed .ObjectNumber )];if _beefd {return _cbcgf ,true ,nil ;};_ggefb ,_gdbae :=_acdd .LookupByReference (*_affed );if _gdbae !=nil {return nil ,false ,_gdbae ;};_acdd .ObjCache [int (_affed .ObjectNumber )]=_ggefb ;return _ggefb ,false ,nil ;};

// WriteString outputs the object as it is to be written to file.
func (_fgae *PdfObjectNull )WriteString ()string {return "\u006e\u0075\u006c\u006c"};

// IsAuthenticated returns true if the PDF has already been authenticated for accessing.
func (_ggba *PdfParser )IsAuthenticated ()bool {return _ggba ._ccddd ._agce };

// ResolveReference resolves reference if `o` is a *PdfObjectReference and returns the object referenced to.
// Otherwise returns back `o`.
func ResolveReference (obj PdfObject )PdfObject {if _edbf ,_egdea :=obj .(*PdfObjectReference );_egdea {return _edbf .Resolve ();};return obj ;};

// GetName returns the *PdfObjectName represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetName (obj PdfObject )(_fcbcc *PdfObjectName ,_dfeb bool ){_fcbcc ,_dfeb =TraceToDirectObject (obj ).(*PdfObjectName );return _fcbcc ,_dfeb ;};var _baae =_ef .MustCompile ("\u005b\\\u0072\u005c\u006e\u005d\u005c\u0073\u002a\u0028\u0078\u0072\u0065f\u0029\u005c\u0073\u002a\u005b\u005c\u0072\u005c\u006e\u005d");func _agf (_gad *_bca .StdEncryptDict ,_fbf *PdfObjectDictionary )error {R ,_acaa :=_fbf .Get ("\u0052").(*PdfObjectInteger );if !_acaa {return _e .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0052");};if *R < 2||*R > 6{return _ff .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0052 \u0028\u0025\u0064\u0029",*R );};_gad .R =int (*R );O ,_acaa :=_fbf .GetString ("\u004f");if !_acaa {return _e .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u004f");};if _gad .R ==5||_gad .R ==6{if len (O )< 48{return _ff .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u004f\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (O ));};}else if len (O )!=32{return _ff .Errorf ("L\u0065n\u0067\u0074\u0068\u0028\u004f\u0029\u0020\u0021=\u0020\u0033\u0032\u0020(%\u0064\u0029",len (O ));};_gad .O =[]byte (O );U ,_acaa :=_fbf .GetString ("\u0055");if !_acaa {return _e .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0055");};if _gad .R ==5||_gad .R ==6{if len (U )< 48{return _ff .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u0055\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (U ));};}else if len (U )!=32{_beg .Log .Debug ("\u0057\u0061r\u006e\u0069\u006e\u0067\u003a\u0020\u004c\u0065\u006e\u0067\u0074\u0068\u0028\u0055\u0029\u0020\u0021\u003d\u0020\u0033\u0032\u0020(%\u0064\u0029",len (U ));};_gad .U =[]byte (U );if _gad .R >=5{OE ,_efa :=_fbf .GetString ("\u004f\u0045");if !_efa {return _e .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u004f\u0045");}else if len (OE )!=32{return _ff .Errorf ("L\u0065\u006e\u0067\u0074h(\u004fE\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (OE ));};_gad .OE =[]byte (OE );UE ,_efa :=_fbf .GetString ("\u0055\u0045");if !_efa {return _e .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u0055\u0045");}else if len (UE )!=32{return _ff .Errorf ("L\u0065\u006e\u0067\u0074h(\u0055E\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (UE ));};_gad .UE =[]byte (UE );};P ,_acaa :=_fbf .Get ("\u0050").(*PdfObjectInteger );if !_acaa {return _e .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074 \u0064\u0069\u0063t\u0069\u006f\u006e\u0061r\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0070\u0065\u0072\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0061\u0074\u0074\u0072");};_gad .P =_bca .Permissions (*P );if _gad .R ==6{Perms ,_gebg :=_fbf .GetString ("\u0050\u0065\u0072m\u0073");if !_gebg {return _e .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0050\u0065\u0072\u006d\u0073");}else if len (Perms )!=16{return _ff .Errorf ("\u004ce\u006e\u0067\u0074\u0068\u0028\u0050\u0065\u0072\u006d\u0073\u0029 \u0021\u003d\u0020\u0031\u0036\u0020\u0028\u0025\u0064\u0029",len (Perms ));};_gad .Perms =[]byte (Perms );};if _bccc ,_ada :=_fbf .Get ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061").(*PdfObjectBool );_ada {_gad .EncryptMetadata =bool (*_bccc );}else {_gad .EncryptMetadata =true ;};return nil ;};

// GetFilterName returns the name of the encoding filter.
func (_gggd *RunLengthEncoder )GetFilterName ()string {return StreamEncodingFilterNameRunLength };

// SetIfNotNil sets the dictionary's key -> val mapping entry -IF- val is not nil.
// Note that we take care to perform a type switch.  Otherwise if we would supply a nil value
// of another type, e.g. (PdfObjectArray*)(nil), then it would not be a PdfObject(nil) and thus
// would get set.
func (_egfga *PdfObjectDictionary )SetIfNotNil (key PdfObjectName ,val PdfObject ){if val !=nil {switch _fdcd :=val .(type ){case *PdfObjectName :if _fdcd !=nil {_egfga .Set (key ,val );};case *PdfObjectDictionary :if _fdcd !=nil {_egfga .Set (key ,val );};case *PdfObjectStream :if _fdcd !=nil {_egfga .Set (key ,val );};case *PdfObjectString :if _fdcd !=nil {_egfga .Set (key ,val );};case *PdfObjectNull :if _fdcd !=nil {_egfga .Set (key ,val );};case *PdfObjectInteger :if _fdcd !=nil {_egfga .Set (key ,val );};case *PdfObjectArray :if _fdcd !=nil {_egfga .Set (key ,val );};case *PdfObjectBool :if _fdcd !=nil {_egfga .Set (key ,val );};case *PdfObjectFloat :if _fdcd !=nil {_egfga .Set (key ,val );};case *PdfObjectReference :if _fdcd !=nil {_egfga .Set (key ,val );};case *PdfIndirectObject :if _fdcd !=nil {_egfga .Set (key ,val );};default:_beg .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",val );};};};

// SetFileOffset sets the file to an offset position and resets buffer.
func (_bbgd *PdfParser )SetFileOffset (offset int64 ){if offset < 0{offset =0;};_bbgd ._bdff .Seek (offset ,_cg .SeekStart );_bbgd ._cdff =_gf .NewReader (_bbgd ._bdff );};var _dcda =_ef .MustCompile ("\u0025P\u0044F\u002d\u0028\u005c\u0064\u0029\u005c\u002e\u0028\u005c\u0064\u0029");var _efgb =_ef .MustCompile ("\u005e\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");

// MultiEncoder supports serial encoding.
type MultiEncoder struct{_ccc []StreamEncoder };

// Elements returns a slice of the PdfObject elements in the array.
func (_dgdc *PdfObjectArray )Elements ()[]PdfObject {if _dgdc ==nil {return nil ;};return _dgdc ._fbcce ;};func _dbb (_fed XrefTable ){_beg .Log .Debug ("\u003dX\u003d\u0058\u003d\u0058\u003d");_beg .Log .Debug ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");_ce :=0;for _ ,_gaf :=range _fed .ObjectMap {_beg .Log .Debug ("i\u002b\u0031\u003a\u0020\u0025\u0064 \u0028\u006f\u0062\u006a\u0020\u006eu\u006d\u003a\u0020\u0025\u0064\u0020\u0067e\u006e\u003a\u0020\u0025\u0064\u0029\u0020\u002d\u003e\u0020%\u0064",_ce +1,_gaf .ObjectNumber ,_gaf .Generation ,_gaf .Offset );_ce ++;};};const JB2ImageAutoThreshold =-1.0;func (_dabe *offsetReader )Read (p []byte )(_efcc int ,_ccbg error ){return _dabe ._bbbd .Read (p )};

// DecodeStream decodes the stream data and returns the decoded data.
// An error is returned upon failure.
func DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_beg .Log .Trace ("\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_cdgg ,_gaae :=NewEncoderFromStream (streamObj );if _gaae !=nil {_beg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_gaae );return nil ,_gaae ;};_beg .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076\u000a",_cdgg );_bgad ,_gaae :=_cdgg .DecodeStream (streamObj );if _gaae !=nil {_beg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_gaae );return nil ,_gaae ;};return _bgad ,nil ;};

// GetFilterName returns the name of the encoding filter.
func (_fdbg *CCITTFaxEncoder )GetFilterName ()string {return StreamEncodingFilterNameCCITTFax };

// ReadBytesAt reads byte content at specific offset and length within the PDF.
func (_ddag *PdfParser )ReadBytesAt (offset ,len int64 )([]byte ,error ){_gagc :=_ddag .GetFileOffset ();_ ,_bdd :=_ddag ._bdff .Seek (offset ,_cg .SeekStart );if _bdd !=nil {return nil ,_bdd ;};_bbcf :=make ([]byte ,len );_ ,_bdd =_cg .ReadAtLeast (_ddag ._bdff ,_bbcf ,int (len ));if _bdd !=nil {return nil ,_bdd ;};_ddag .SetFileOffset (_gagc );return _bbcf ,nil ;};func _bdc (_dbbf int )cryptFilters {return cryptFilters {_gcd :_ag .NewFilterV2 (_dbbf )}};

// JPXEncoder implements JPX encoder/decoder (dummy, for now)
// FIXME: implement
type JPXEncoder struct{};

// GetString returns the *PdfObjectString represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetString (obj PdfObject )(_dgbe *PdfObjectString ,_adec bool ){_dgbe ,_adec =TraceToDirectObject (obj ).(*PdfObjectString );return _dgbe ,_adec ;};

// Remove removes an element specified by key.
func (_gcabg *PdfObjectDictionary )Remove (key PdfObjectName ){_bcdcb :=-1;for _bbabd ,_eegdg :=range _gcabg ._edcg {if _eegdg ==key {_bcdcb =_bbabd ;break ;};};if _bcdcb >=0{_gcabg ._edcg =append (_gcabg ._edcg [:_bcdcb ],_gcabg ._edcg [_bcdcb +1:]...);delete (_gcabg ._ggagd ,key );};};type offsetReader struct{_bbbd _cg .ReadSeeker ;_debe int64 ;};

// JBIG2Encoder implements both jbig2 encoder and the decoder. The encoder allows to encode
// provided images (best used document scans) in multiple way. By default it uses single page generic
// encoder. It allows to store lossless data as a single segment.
// In order to store multiple image pages use the 'FileMode' which allows to store more pages within single jbig2 document.
// WIP: In order to obtain better compression results the encoder would allow to encode the input in a
// lossy or lossless way with a component (symbol) mode. It divides the image into components.
// Then checks if any component is 'similar' to the others and maps them together. The symbol classes are stored
// in the dictionary. Then the encoder creates text regions which uses the related symbol classes to fill it's space.
// The similarity is defined by the 'Threshold' variable (default: 0.95). The less the value is, the more components
// matches to single class, thus the compression is better, but the result might become lossy.
type JBIG2Encoder struct{

// These values are required to be set for the 'EncodeBytes' method.
// ColorComponents defines the number of color components for provided image.
ColorComponents int ;

// BitsPerComponent is the number of bits that stores per color component
BitsPerComponent int ;

// Width is the width of the image to encode
Width int ;

// Height is the height of the image to encode.
Height int ;_adea *_bc .Document ;

// Globals are the JBIG2 global segments.
Globals _gae .Globals ;

// IsChocolateData defines if the data is encoded such that
// binary data '1' means black and '0' white.
// otherwise the data is called vanilla.
// Naming convention taken from: 'https://en.wikipedia.org/wiki/Binary_image#Interpretation'
IsChocolateData bool ;

// DefaultPageSettings are the settings parameters used by the jbig2 encoder.
DefaultPageSettings JBIG2EncoderSettings ;};func (_gabb *PdfParser )rebuildXrefTable ()error {_adeab :=XrefTable {};_adeab .ObjectMap =map[int ]XrefObject {};for _cfed ,_gdfe :=range _gabb ._bbda .ObjectMap {_badb ,_ ,_ffaec :=_gabb .lookupByNumberWrapper (_cfed ,false );if _ffaec !=nil {_beg .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020U\u006e\u0061\u0062\u006ce t\u006f l\u006f\u006f\u006b\u0020\u0075\u0070\u0020ob\u006a\u0065\u0063\u0074\u0020\u0028\u0025s\u0029",_ffaec );_beg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0063\u006fm\u0070\u006c\u0065\u0074\u0065\u006c\u0079\u0020\u0062\u0072\u006f\u006b\u0065\u006e\u0020\u002d\u0020\u0061\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0074\u006f \u0072\u0065\u0070\u0061\u0069r\u0020");_ebffd ,_baaa :=_gabb .repairRebuildXrefsTopDown ();if _baaa !=nil {_beg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0072\u0065\u0062\u0075\u0069l\u0064\u0020\u0072\u0065\u0070a\u0069\u0072 \u0028\u0025\u0073\u0029",_baaa );return _baaa ;};_gabb ._bbda =*_ebffd ;_beg .Log .Debug ("\u0052e\u0070\u0061\u0069\u0072e\u0064\u0020\u0078\u0072\u0065f\u0020t\u0061b\u006c\u0065\u0020\u0062\u0075\u0069\u006ct");return nil ;};_fdea ,_aaea ,_ffaec :=_fgg (_badb );if _ffaec !=nil {return _ffaec ;};_gdfe .ObjectNumber =int (_fdea );_gdfe .Generation =int (_aaea );_adeab .ObjectMap [int (_fdea )]=_gdfe ;};_gabb ._bbda =_adeab ;_beg .Log .Debug ("N\u0065w\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061b\u006c\u0065\u0020\u0062ui\u006c\u0074");_dbb (_gabb ._bbda );return nil ;};

// Encode encodes previously prepare jbig2 document and stores it as the byte slice.
func (_geacg *JBIG2Encoder )Encode ()(_gbeg []byte ,_gbdg error ){const _ffcbd ="J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0045\u006eco\u0064\u0065";if _geacg ._adea ==nil {return nil ,_aa .Errorf (_ffcbd ,"\u0064\u006f\u0063u\u006d\u0065\u006e\u0074 \u0069\u006e\u0070\u0075\u0074\u0020\u0064a\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006e\u0065\u0064");};_geacg ._adea .FullHeaders =_geacg .DefaultPageSettings .FileMode ;_gbeg ,_gbdg =_geacg ._adea .Encode ();if _gbdg !=nil {return nil ,_aa .Wrap (_gbdg ,_ffcbd ,"");};return _gbeg ,nil ;};func (_faag *PdfParser )loadXrefs ()(*PdfObjectDictionary ,error ){_faag ._bbda .ObjectMap =make (map[int ]XrefObject );_faag ._ecca =make (objectStreams );_cgdbc ,_dbccd :=_faag ._bdff .Seek (0,_cg .SeekEnd );if _dbccd !=nil {return nil ,_dbccd ;};_beg .Log .Trace ("\u0066s\u0069\u007a\u0065\u003a\u0020\u0025d",_cgdbc );_faag ._bdaca =_cgdbc ;_dbccd =_faag .seekToEOFMarker (_cgdbc );if _dbccd !=nil {_beg .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0073\u0065\u0065\u006b\u0020\u0074\u006f\u0020\u0065\u006f\u0066\u0020\u006d\u0061\u0072\u006b\u0065\u0072: \u0025\u0076",_dbccd );return nil ,_dbccd ;};_gfdee ,_dbccd :=_faag ._bdff .Seek (0,_cg .SeekCurrent );if _dbccd !=nil {return nil ,_dbccd ;};var _dacba int64 =64;_cdg :=_gfdee -_dacba ;if _cdg < 0{_cdg =0;};_ ,_dbccd =_faag ._bdff .Seek (_cdg ,_cg .SeekStart );if _dbccd !=nil {return nil ,_dbccd ;};_gdbcb :=make ([]byte ,_dacba );_ ,_dbccd =_faag ._bdff .Read (_gdbcb );if _dbccd !=nil {_beg .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u003a\u0020\u0025\u0076",_dbccd );return nil ,_dbccd ;};_gaba :=_fdbfd .FindStringSubmatch (string (_gdbcb ));if len (_gaba )< 2{_beg .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020n\u006f\u0074\u0020f\u006fu\u006e\u0064\u0021");return nil ,_e .New ("\u0073\u0074\u0061\u0072tx\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};if len (_gaba )> 2{_beg .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u004du\u006c\u0074\u0069\u0070\u006c\u0065\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029\u0021",_gdbcb );return nil ,_e .New ("m\u0075\u006c\u0074\u0069\u0070\u006ce\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065f\u0020\u0065\u006et\u0072i\u0065\u0073\u003f");};_fbgf ,_ :=_b .ParseInt (_gaba [1],10,64);_beg .Log .Trace ("\u0073t\u0061r\u0074\u0078\u0072\u0065\u0066\u0020\u0061\u0074\u0020\u0025\u0064",_fbgf );if _fbgf > _cgdbc {_beg .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u006f\u0066f\u0073e\u0074 \u006fu\u0074\u0073\u0069\u0064\u0065\u0020\u006f\u0066\u0020\u0066\u0069\u006c\u0065");_beg .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0072e\u0070\u0061\u0069\u0072");_fbgf ,_dbccd =_faag .repairLocateXref ();if _dbccd !=nil {_beg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0052\u0065\u0070\u0061\u0069\u0072\u0020\u0061\u0074\u0074\u0065\u006d\u0070t\u0020\u0066\u0061\u0069\u006c\u0065\u0064 \u0028\u0025\u0073\u0029");return nil ,_dbccd ;};};_faag ._bdff .Seek (int64 (_fbgf ),_cg .SeekStart );_faag ._cdff =_gf .NewReader (_faag ._bdff );_caaad ,_dbccd :=_faag .parseXref ();if _dbccd !=nil {return nil ,_dbccd ;};_eaeee :=_caaad .Get ("\u0058R\u0065\u0066\u0053\u0074\u006d");if _eaeee !=nil {_bgebf ,_cbff :=_eaeee .(*PdfObjectInteger );if !_cbff {return nil ,_e .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0021=\u0020\u0069\u006e\u0074");};_ ,_dbccd =_faag .parseXrefStream (_bgebf );if _dbccd !=nil {return nil ,_dbccd ;};};var _cfef []int64 ;_acabe :=func (_adb int64 ,_efbac []int64 )bool {for _ ,_gbea :=range _efbac {if _gbea ==_adb {return true ;};};return false ;};_eaeee =_caaad .Get ("\u0050\u0072\u0065\u0076");for _eaeee !=nil {_caec ,_faecb :=_eaeee .(*PdfObjectInteger );if !_faecb {_beg .Log .Debug ("\u0049\u006ev\u0061\u006c\u0069\u0064\u0020P\u0072\u0065\u0076\u0020\u0072e\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u003a\u0020\u004e\u006f\u0074\u0020\u0061\u0020\u002a\u0050\u0064\u0066\u004f\u0062\u006a\u0065\u0063\u0074\u0049\u006e\u0074\u0065\u0067\u0065\u0072\u0020\u0028\u0025\u0054\u0029",_eaeee );return _caaad ,nil ;};_agae :=*_caec ;_beg .Log .Trace ("\u0041\u006eot\u0068\u0065\u0072 \u0050\u0072\u0065\u0076 xr\u0065f \u0074\u0061\u0062\u006c\u0065\u0020\u006fbj\u0065\u0063\u0074\u0020\u0061\u0074\u0020%\u0064",_agae );_faag ._bdff .Seek (int64 (_agae ),_bf .SEEK_SET );_faag ._cdff =_gf .NewReader (_faag ._bdff );_feeg ,_dgde :=_faag .parseXref ();if _dgde !=nil {_beg .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0045\u0072\u0072\u006f\u0072\u0020-\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u0061\u0064\u0069n\u0067\u0020\u0061\u006e\u006f\u0074\u0068\u0065\u0072\u0020\u0028\u0050re\u0076\u0029\u0020\u0074\u0072\u0061\u0069\u006c\u0065\u0072");_beg .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0063\u006f\u006e\u0074\u0069n\u0075\u0065\u0020\u0062\u0079\u0020\u0069\u0067\u006e\u006f\u0072\u0069n\u0067\u0020\u0069\u0074");break ;};_eaeee =_feeg .Get ("\u0050\u0072\u0065\u0076");if _eaeee !=nil {_ffae :=*(_eaeee .(*PdfObjectInteger ));if _acabe (int64 (_ffae ),_cfef ){_beg .Log .Debug ("\u0050\u0072ev\u0065\u006e\u0074i\u006e\u0067\u0020\u0063irc\u0075la\u0072\u0020\u0078\u0072\u0065\u0066\u0020re\u0066\u0065\u0072\u0065\u006e\u0063\u0069n\u0067");break ;};_cfef =append (_cfef ,int64 (_ffae ));};};return _caaad ,nil ;};

// MakeStreamDict make a new instance of an encoding dictionary for a stream object.
func (_efbcb *ASCII85Encoder )MakeStreamDict ()*PdfObjectDictionary {_eefc :=MakeDict ();_eefc .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_efbcb .GetFilterName ()));return _eefc ;};

// DrawableImage is same as golang image/draw's Image interface that allow drawing images.
type DrawableImage interface{ColorModel ()_efb .Model ;Bounds ()_ga .Rectangle ;At (_ggdg ,_ceg int )_efb .Color ;Set (_gbed ,_ebfd int ,_cggg _efb .Color );};func (_ecfg *PdfParser )parseNull ()(PdfObjectNull ,error ){_ ,_fcbb :=_ecfg ._cdff .Discard (4);return PdfObjectNull {},_fcbb ;};func (_acage *PdfParser )seekPdfVersionTopDown ()(int ,int ,error ){_acage ._bdff .Seek (0,_bf .SEEK_SET );_acage ._cdff =_gf .NewReader (_acage ._bdff );_dega :=20;_agbb :=make ([]byte ,_dega );for {_dafd ,_dgbf :=_acage ._cdff .ReadByte ();if _dgbf !=nil {if _dgbf ==_cg .EOF {break ;}else {return 0,0,_dgbf ;};};if IsDecimalDigit (_dafd )&&_agbb [_dega -1]=='.'&&IsDecimalDigit (_agbb [_dega -2])&&_agbb [_dega -3]=='-'&&_agbb [_dega -4]=='F'&&_agbb [_dega -5]=='D'&&_agbb [_dega -6]=='P'{_ggbee :=int (_agbb [_dega -2]-'0');_ecce :=int (_dafd -'0');return _ggbee ,_ecce ,nil ;};_agbb =append (_agbb [1:_dega ],_dafd );};return 0,0,_e .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};

// GoImageToJBIG2 creates a binary image on the base of 'i' golang image.Image.
// If the image is not a black/white image then the function converts provided input into
// JBIG2Image with 1bpp. For non grayscale images the function performs the conversion to the grayscale temp image.
// Then it checks the value of the gray image value if it's within bounds of the black white threshold.
// This 'bwThreshold' value should be in range (0.0, 1.0). The threshold checks if the grayscale pixel (uint) value
// is greater or smaller than 'bwThreshold' * 255. Pixels inside the range will be white, and the others will be black.
// If the 'bwThreshold' is equal to -1.0 - JB2ImageAutoThreshold then it's value would be set on the base of
// it's histogram using Triangle method. For more information go to:
// 	https://www.mathworks.com/matlabcentral/fileexchange/28047-gray-image-thresholding-using-the-triangle-method
func GoImageToJBIG2 (i _ga .Image ,bwThreshold float64 )(*JBIG2Image ,error ){const _bdgcc ="\u0047\u006f\u0049\u006d\u0061\u0067\u0065\u0054\u006fJ\u0042\u0049\u0047\u0032";if i ==nil {return nil ,_aa .Error (_bdgcc ,"i\u006d\u0061\u0067\u0065 '\u0069'\u0020\u006e\u006f\u0074\u0020d\u0065\u0066\u0069\u006e\u0065\u0064");};var (_ffbfa uint8 ;_gafb _da .Image ;_edcf error ;);if bwThreshold ==JB2ImageAutoThreshold {_gafb ,_edcf =_da .MonochromeConverter .Convert (i );}else if bwThreshold > 1.0||bwThreshold < 0.0{return nil ,_aa .Error (_bdgcc ,"p\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074h\u0072\u0065\u0073\u0068\u006f\u006c\u0064 i\u0073\u0020\u006e\u006ft\u0020\u0069\u006e\u0020\u0061\u0020\u0072\u0061\u006ege\u0020\u007b0\u002e\u0030\u002c\u0020\u0031\u002e\u0030\u007d");}else {_ffbfa =uint8 (255*bwThreshold );_gafb ,_edcf =_da .MonochromeThresholdConverter (_ffbfa ).Convert (i );};if _edcf !=nil {return nil ,_edcf ;};return _cdfec (_gafb ),nil ;};

// PdfObjectArray represents the primitive PDF array object.
type PdfObjectArray struct{_fbcce []PdfObject };

// EncodeBytes encodes the passed in slice of bytes by passing it through the
// EncodeBytes method of the underlying encoders.
func (_eggf *MultiEncoder )EncodeBytes (data []byte )([]byte ,error ){_fegc :=data ;var _gbef error ;for _afbd :=len (_eggf ._ccc )-1;_afbd >=0;_afbd --{_eada :=_eggf ._ccc [_afbd ];_fegc ,_gbef =_eada .EncodeBytes (_fegc );if _gbef !=nil {return nil ,_gbef ;};};return _fegc ,nil ;};

// DecodeBytes decodes a slice of LZW encoded bytes and returns the result.
func (_bgb *LZWEncoder )DecodeBytes (encoded []byte )([]byte ,error ){var _efgf _gec .Buffer ;_feg :=_gec .NewReader (encoded );var _eag _cg .ReadCloser ;if _bgb .EarlyChange ==1{_eag =_bb .NewReader (_feg ,_bb .MSB ,8);}else {_eag =_ca .NewReader (_feg ,_ca .MSB ,8);};defer _eag .Close ();_ ,_bfae :=_efgf .ReadFrom (_eag );if _bfae !=nil {return nil ,_bfae ;};return _efgf .Bytes (),nil ;};

// Encrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_geda *PdfCrypt )Encrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _geda .isEncrypted (obj ){return nil ;};switch _ecdcf :=obj .(type ){case *PdfIndirectObject :_geda ._afc [_ecdcf ]=true ;_beg .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_ecdcf .ObjectNumber ,_ecdcf .GenerationNumber );_bff :=_ecdcf .ObjectNumber ;_eac :=_ecdcf .GenerationNumber ;_daee :=_geda .Encrypt (_ecdcf .PdfObject ,_bff ,_eac );if _daee !=nil {return _daee ;};return nil ;case *PdfObjectStream :_geda ._afc [_ecdcf ]=true ;_ggc :=_ecdcf .PdfObjectDictionary ;if _aaab ,_fdee :=_ggc .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_fdee &&*_aaab =="\u0058\u0052\u0065\u0066"{return nil ;};_gcf :=_ecdcf .ObjectNumber ;_eaef :=_ecdcf .GenerationNumber ;_beg .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_gcf ,_eaef );_bde :=_gcd ;if _geda ._geb .V >=4{_bde =_geda ._dae ;_beg .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_geda ._dae );if _fba ,_abfa :=_ggc .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );_abfa {if _dgg ,_fbgc :=GetName (_fba .Get (0));_fbgc {if *_dgg =="\u0043\u0072\u0079p\u0074"{_bde ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _fddb ,_eaeg :=_ggc .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );_eaeg {if _cceb ,_bfdf :=_fddb .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_bfdf {if _ ,_bfde :=_geda ._dbf [string (*_cceb )];_bfde {_beg .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_cceb );_bde =string (*_cceb );};};};};};};_beg .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_bde );if _bde =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_dcbc :=_geda .Encrypt (_ecdcf .PdfObjectDictionary ,_gcf ,_eaef );if _dcbc !=nil {return _dcbc ;};_bdec ,_dcbc :=_geda .makeKey (_bde ,uint32 (_gcf ),uint32 (_eaef ),_geda ._baa );if _dcbc !=nil {return _dcbc ;};_ecdcf .Stream ,_dcbc =_geda .encryptBytes (_ecdcf .Stream ,_bde ,_bdec );if _dcbc !=nil {return _dcbc ;};_ggc .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_ecdcf .Stream ))));return nil ;case *PdfObjectString :_beg .Log .Trace ("\u0045n\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_afgf :=_gcd ;if _geda ._geb .V >=4{_beg .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_geda ._fde );if _geda ._fde =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_afgf =_geda ._fde ;};_gge ,_fff :=_geda .makeKey (_afgf ,uint32 (parentObjNum ),uint32 (parentGenNum ),_geda ._baa );if _fff !=nil {return _fff ;};_gff :=_ecdcf .Str ();_ebdc :=make ([]byte ,len (_gff ));for _ebgd :=0;_ebgd < len (_gff );_ebgd ++{_ebdc [_ebgd ]=_gff [_ebgd ];};_beg .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_ebdc ,_ebdc );_ebdc ,_fff =_geda .encryptBytes (_ebdc ,_afgf ,_gge );if _fff !=nil {return _fff ;};_ecdcf ._aabg =string (_ebdc );return nil ;case *PdfObjectArray :for _ ,_acd :=range _ecdcf .Elements (){_edbg :=_geda .Encrypt (_acd ,parentObjNum ,parentGenNum );if _edbg !=nil {return _edbg ;};};return nil ;case *PdfObjectDictionary :_cff :=false ;if _gcgg :=_ecdcf .Get ("\u0054\u0079\u0070\u0065");_gcgg !=nil {_gfe ,_ebdce :=_gcgg .(*PdfObjectName );if _ebdce &&*_gfe =="\u0053\u0069\u0067"{_cff =true ;};};for _ ,_gbf :=range _ecdcf .Keys (){_ccebf :=_ecdcf .Get (_gbf );if _cff &&string (_gbf )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;};if string (_gbf )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_gbf )!="\u0050\u0072\u0065\u0076"&&string (_gbf )!="\u004c\u0061\u0073\u0074"{_gcbf :=_geda .Encrypt (_ccebf ,parentObjNum ,parentGenNum );if _gcbf !=nil {return _gcbf ;};};};return nil ;};return nil ;};

// NewLZWEncoder makes a new LZW encoder with default parameters.
func NewLZWEncoder ()*LZWEncoder {_cefa :=&LZWEncoder {};_cefa .Predictor =1;_cefa .BitsPerComponent =8;_cefa .Colors =1;_cefa .Columns =1;_cefa .EarlyChange =1;return _cefa ;};func (_cbgd *PdfParser )inspect ()(map[string ]int ,error ){_beg .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0053P\u0045\u0043\u0054\u0020\u002d\u002d\u002d\u002d\u002d\u002d-\u002d\u002d\u002d");_beg .Log .Trace ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");_bcdb :=map[string ]int {};_cacg :=0;_bbdc :=0;var _bgcea []int ;for _fdgf :=range _cbgd ._bbda .ObjectMap {_bgcea =append (_bgcea ,_fdgf );};_g .Ints (_bgcea );_cebcg :=0;for _ ,_cbabc :=range _bgcea {_cfegg :=_cbgd ._bbda .ObjectMap [_cbabc ];if _cfegg .ObjectNumber ==0{continue ;};_cacg ++;_beg .Log .Trace ("\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d");_beg .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0075\u0070\u0020\u006f\u0062\u006a\u0065c\u0074 \u006e\u0075\u006d\u0062\u0065\u0072\u003a \u0025\u0064",_cfegg .ObjectNumber );_ccbgb ,_fgac :=_cbgd .LookupByNumber (_cfegg .ObjectNumber );if _fgac !=nil {_beg .Log .Trace ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u006c\u006f\u006f\u006b\u0075p\u0020\u006f\u0062\u006a\u0020\u0025\u0064 \u0028\u0025\u0073\u0029",_cfegg .ObjectNumber ,_fgac );_bbdc ++;continue ;};_beg .Log .Trace ("\u006fb\u006a\u003a\u0020\u0025\u0073",_ccbgb );_eegdc ,_bbdfe :=_ccbgb .(*PdfIndirectObject );if _bbdfe {_beg .Log .Trace ("\u0049N\u0044 \u004f\u004f\u0042\u004a\u0020\u0025\u0064\u003a\u0020\u0025\u0073",_cfegg .ObjectNumber ,_eegdc );_bfdd ,_bgfag :=_eegdc .PdfObject .(*PdfObjectDictionary );if _bgfag {if _fagf ,_dfeg :=_bfdd .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_dfeg {_bfac :=string (*_fagf );_beg .Log .Trace ("\u002d\u002d\u002d\u003e\u0020\u004f\u0062\u006a\u0020\u0074\u0079\u0070e\u003a\u0020\u0025\u0073",_bfac );_ ,_gccb :=_bcdb [_bfac ];if _gccb {_bcdb [_bfac ]++;}else {_bcdb [_bfac ]=1;};}else if _gbdc ,_ccda :=_bfdd .Get ("\u0053u\u0062\u0074\u0079\u0070\u0065").(*PdfObjectName );_ccda {_gfef :=string (*_gbdc );_beg .Log .Trace ("-\u002d-\u003e\u0020\u004f\u0062\u006a\u0020\u0073\u0075b\u0074\u0079\u0070\u0065: \u0025\u0073",_gfef );_ ,_ecda :=_bcdb [_gfef ];if _ecda {_bcdb [_gfef ]++;}else {_bcdb [_gfef ]=1;};};if _eefa ,_bfdcc :=_bfdd .Get ("\u0053").(*PdfObjectName );_bfdcc &&*_eefa =="\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"{_ ,_gfdb :=_bcdb ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"];if _gfdb {_bcdb ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]++;}else {_bcdb ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]=1;};};};}else if _bbcd ,_afce :=_ccbgb .(*PdfObjectStream );_afce {if _bffeg ,_fdeag :=_bbcd .PdfObjectDictionary .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_fdeag {_beg .Log .Trace ("\u002d\u002d\u003e\u0020\u0053\u0074\u0072\u0065\u0061\u006d\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073",*_bffeg );_edfd :=string (*_bffeg );if _ ,_cffdg :=_bcdb [_edfd ];_cffdg {_bcdb [_edfd ]++;}else {_bcdb [_edfd ]=1;};};}else {_dbeb ,_dafa :=_ccbgb .(*PdfObjectDictionary );if _dafa {_ffdcc ,_fbdbf :=_dbeb .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if _fbdbf {_dgcf :=string (*_ffdcc );_beg .Log .Trace ("\u002d-\u002d \u006f\u0062\u006a\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073",_dgcf );_bcdb [_dgcf ]++;};};_beg .Log .Trace ("\u0044\u0049\u0052\u0045\u0043\u0054\u0020\u004f\u0042\u004a\u0020\u0025d\u003a\u0020\u0025\u0073",_cfegg .ObjectNumber ,_ccbgb );};_cebcg ++;};_beg .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0045\u004fF\u0020\u0049\u004e\u0053\u0050\u0045\u0043T\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d");_beg .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");_beg .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074 \u0063\u006f\u0075\u006e\u0074\u003a\u0020\u0025\u0064",_cacg );_beg .Log .Trace ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u006f\u006b\u0075p\u003a\u0020\u0025\u0064",_bbdc );for _dged ,_cebaa :=range _bcdb {_beg .Log .Trace ("\u0025\u0073\u003a\u0020\u0025\u0064",_dged ,_cebaa );};_beg .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");if len (_cbgd ._bbda .ObjectMap )< 1{_beg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0068\u0069\u0073 \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074 \u0069s\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0028\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0021\u0029");return nil ,_ff .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0064\u006fc\u0075\u006d\u0065\u006e\u0074\u0020\u0028\u0078r\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006d\u0069\u0073s\u0069\u006e\u0067\u0029");};_gaaa ,_fecdg :=_bcdb ["\u0046\u006f\u006e\u0074"];if !_fecdg ||_gaaa < 2{_beg .Log .Trace ("\u0054\u0068\u0069s \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020i\u0073 \u0070r\u006fb\u0061\u0062\u006c\u0079\u0020\u0073\u0063\u0061\u006e\u006e\u0065\u0064\u0021");}else {_beg .Log .Trace ("\u0054\u0068\u0069\u0073\u0020\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020\u0069\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0066o\u0072\u0020\u0065\u0078\u0074r\u0061\u0063t\u0069\u006f\u006e\u0021");};return _bcdb ,nil ;};func _ccea (_abeb _ag .Filter ,_age _bca .AuthEvent )*PdfObjectDictionary {if _age ==""{_age =_bca .EventDocOpen ;};_bfa :=MakeDict ();_bfa .Set ("\u0054\u0079\u0070\u0065",MakeName ("C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"));_bfa .Set ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et",MakeName (string (_age )));_bfa .Set ("\u0043\u0046\u004d",MakeName (_abeb .Name ()));_bfa .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_abeb .KeyLength ())));return _bfa ;};

// Len returns the number of elements in the streams.
func (_geec *PdfObjectStreams )Len ()int {if _geec ==nil {return 0;};return len (_geec ._acec );};

// LZWEncoder provides LZW encoding/decoding functionality.
type LZWEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Colors int ;

// LZW algorithm setting.
EarlyChange int ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set.  Some other parameters are generated elsewhere.
func (_affg *DCTEncoder )MakeStreamDict ()*PdfObjectDictionary {_cadag :=MakeDict ();_cadag .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_affg .GetFilterName ()));return _cadag ;};const _gccf =32<<(^uint (0)>>63);

// DecodeStream decodes RunLengthEncoded stream object and give back decoded bytes.
func (_gfbd *RunLengthEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _gfbd .DecodeBytes (streamObj .Stream );};func _afa (_bfg *_ag .FilterDict ,_dbg *PdfObjectDictionary )error {if _ged ,_bgf :=_dbg .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_bgf {if _egf :=string (*_ged );_egf !="C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"{_beg .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020C\u0046\u0020\u0064ic\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074e\u0072\u0029",_egf );};};_cggd ,_bbe :=_dbg .Get ("\u0043\u0046\u004d").(*PdfObjectName );if !_bbe {return _ff .Errorf ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0028\u004e\u006f\u006e\u0065\u0029");};_bfg .CFM =string (*_cggd );if _fbfe ,_fddf :=_dbg .Get ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et").(*PdfObjectName );_fddf {_bfg .AuthEvent =_bca .AuthEvent (*_fbfe );}else {_bfg .AuthEvent =_bca .EventDocOpen ;};if _afg ,_cda :=_dbg .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );_cda {_bfg .Length =int (*_afg );};return nil ;};

// GetNumberAsFloat returns the contents of `obj` as a float if it is an integer or float, or an
// error if it isn't.
func GetNumberAsFloat (obj PdfObject )(float64 ,error ){switch _ceba :=obj .(type ){case *PdfObjectFloat :return float64 (*_ceba ),nil ;case *PdfObjectInteger :return float64 (*_ceba ),nil ;};return 0,ErrNotANumber ;};

// PdfObject is an interface which all primitive PDF objects must implement.
type PdfObject interface{

// String outputs a string representation of the primitive (for debugging).
String ()string ;

// WriteString outputs the PDF primitive as written to file as expected by the standard.
// TODO(dennwc): it should return a byte slice, or accept a writer
WriteString ()string ;};var _fdbfd =_ef .MustCompile ("\u0073t\u0061r\u0074\u0078\u003f\u0072\u0065f\u005c\u0073*\u0028\u005c\u0064\u002b\u0029");func _faa (_eded *PdfObjectStream ,_bfc *PdfObjectDictionary )(*FlateEncoder ,error ){_beaa :=NewFlateEncoder ();_gdba :=_eded .PdfObjectDictionary ;if _gdba ==nil {return _beaa ,nil ;};_beaa ._fbbe =_dgba (_gdba );if _bfc ==nil {_edeg :=TraceToDirectObject (_gdba .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));switch _dee :=_edeg .(type ){case *PdfObjectArray :_gfea :=_dee ;if _gfea .Len ()!=1{_beg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072:\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020a\u0072\u0072\u0061\u0079\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0021\u003d\u0020\u0031\u0020\u0028\u0025\u0064\u0029",_gfea .Len ());return nil ,_e .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_edeg =TraceToDirectObject (_gfea .Get (0));case *PdfObjectDictionary :_bfc =_dee ;case *PdfObjectNull ,nil :default:_beg .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020n\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079 \u0028%\u0054\u0029",_edeg );return nil ,_ff .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _bfc ==nil {return _beaa ,nil ;};_beg .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_bfc .String ());_ffe :=_bfc .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");if _ffe ==nil {_beg .Log .Debug ("E\u0072\u0072o\u0072\u003a\u0020\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067 \u0066\u0072\u006f\u006d\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073 \u002d\u0020\u0043\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020\u0077\u0069t\u0068\u0020\u0064\u0065\u0066\u0061\u0075\u006c\u0074\u0020\u00281\u0029");}else {_cgd ,_bfda :=_ffe .(*PdfObjectInteger );if !_bfda {_beg .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_ffe );return nil ,_ff .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_beaa .Predictor =int (*_cgd );};_ffe =_bfc .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");if _ffe !=nil {_gfgcdf ,_cagb :=_ffe .(*PdfObjectInteger );if !_cagb {_beg .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");return nil ,_ff .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_beaa .BitsPerComponent =int (*_gfgcdf );};if _beaa .Predictor > 1{_beaa .Columns =1;_ffe =_bfc .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");if _ffe !=nil {_add ,_gffg :=_ffe .(*PdfObjectInteger );if !_gffg {return nil ,_ff .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_beaa .Columns =int (*_add );};_beaa .Colors =1;_ffe =_bfc .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _ffe !=nil {_ddc ,_fadg :=_ffe .(*PdfObjectInteger );if !_fadg {return nil ,_ff .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");};_beaa .Colors =int (*_ddc );};};return _beaa ,nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_fccd *LZWEncoder )UpdateParams (params *PdfObjectDictionary ){_bbc ,_fag :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _fag ==nil {_fccd .Predictor =int (_bbc );};_dcafb ,_fag :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _fag ==nil {_fccd .BitsPerComponent =int (_dcafb );};_eecf ,_fag :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _fag ==nil {_fccd .Columns =int (_eecf );};_gcggf ,_fag :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _fag ==nil {_fccd .Colors =int (_gcggf );};_gdbg ,_fag :=GetNumberAsInt64 (params .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065"));if _fag ==nil {_fccd .EarlyChange =int (_gdbg );};};

// NewCCITTFaxEncoder makes a new CCITTFax encoder.
func NewCCITTFaxEncoder ()*CCITTFaxEncoder {return &CCITTFaxEncoder {Columns :1728,EndOfBlock :true }};

// Set sets the PdfObject at index i of the streams. An error is returned if the index is outside bounds.
func (_dfcaf *PdfObjectStreams )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_dfcaf ._acec ){return _e .New ("\u004f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_dfcaf ._acec [i ]=obj ;return nil ;};

// ReadAtLeast reads at least n bytes into slice p.
// Returns the number of bytes read (should always be == n), and an error on failure.
func (_ggbc *PdfParser )ReadAtLeast (p []byte ,n int )(int ,error ){_caac :=n ;_ccag :=0;_abgb :=0;for _caac > 0{_gadc ,_abdgg :=_ggbc ._cdff .Read (p [_ccag :]);if _abdgg !=nil {_beg .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061d\u0069\u006e\u0067\u0020\u0028\u0025\u0064\u003b\u0025\u0064\u0029\u0020\u0025\u0073",_gadc ,_abgb ,_abdgg .Error ());return _ccag ,_e .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065a\u0064\u0069\u006e\u0067");};_abgb ++;_ccag +=_gadc ;_caac -=_gadc ;};return _ccag ,nil ;};

// NewMultiEncoder returns a new instance of MultiEncoder.
func NewMultiEncoder ()*MultiEncoder {_cdbaf :=MultiEncoder {};_cdbaf ._ccc =[]StreamEncoder {};return &_cdbaf ;};

// DecodeStream decodes a DCT encoded stream and returns the result as a
// slice of bytes.
func (_baac *DCTEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _baac .DecodeBytes (streamObj .Stream );};

// WriteString outputs the object as it is to be written to file.
func (_aaeff *PdfObjectStreams )WriteString ()string {var _ddfg _d .Builder ;_ddfg .WriteString (_b .FormatInt (_aaeff .ObjectNumber ,10));_ddfg .WriteString ("\u0020\u0030\u0020\u0052");return _ddfg .String ();};

// MakeName creates a PdfObjectName from a string.
func MakeName (s string )*PdfObjectName {_gbgbb :=PdfObjectName (s );return &_gbgbb };

// DCTEncoder provides a DCT (JPG) encoding/decoding functionality for images.
type DCTEncoder struct{ColorComponents int ;BitsPerComponent int ;Width int ;Height int ;Quality int ;};

// WriteString outputs the object as it is to be written to file.
func (_eead *PdfIndirectObject )WriteString ()string {var _gcea _d .Builder ;_gcea .WriteString (_b .FormatInt (_eead .ObjectNumber ,10));_gcea .WriteString ("\u0020\u0030\u0020\u0052");return _gcea .String ();};

// DecodeBytes decodes a slice of JPX encoded bytes and returns the result.
func (_ggff *JPXEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_beg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_ggff .GetFilterName ());return encoded ,ErrNoJPXDecode ;};

// GetFilterName returns the name of the encoding filter.
func (_cfa *LZWEncoder )GetFilterName ()string {return StreamEncodingFilterNameLZW };

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_bbdf *ASCIIHexEncoder )MakeStreamDict ()*PdfObjectDictionary {_baaf :=MakeDict ();_baaf .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_bbdf .GetFilterName ()));return _baaf ;};

// ParseNumber parses a numeric objects from a buffered stream.
// Section 7.3.3.
// Integer or Float.
//
// An integer shall be written as one or more decimal digits optionally
// preceded by a sign. The value shall be interpreted as a signed
// decimal integer and shall be converted to an integer object.
//
// A real value shall be written as one or more decimal digits with an
// optional sign and a leading, trailing, or embedded PERIOD (2Eh)
// (decimal point). The value shall be interpreted as a real number
// and shall be converted to a real object.
//
// Regarding exponential numbers: 7.3.3 Numeric Objects:
// A conforming writer shall not use the PostScript syntax for numbers
// with non-decimal radices (such as 16#FFFE) or in exponential format
// (such as 6.02E23).
// Nonetheless, we sometimes get numbers with exponential format, so
// we will support it in the reader (no confusion with other types, so
// no compromise).
func ParseNumber (buf *_gf .Reader )(PdfObject ,error ){_gabfb :=false ;_ggeca :=true ;var _dggefa _gec .Buffer ;for {if _beg .Log .IsLogLevel (_beg .LogLevelTrace ){_beg .Log .Trace ("\u0050\u0061\u0072\u0073in\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0022\u0025\u0073\u0022",_dggefa .String ());};_gagbc ,_dcdf :=buf .Peek (1);if _dcdf ==_cg .EOF {break ;};if _dcdf !=nil {_beg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0025\u0073",_dcdf );return nil ,_dcdf ;};if _ggeca &&(_gagbc [0]=='-'||_gagbc [0]=='+'){_cfbb ,_ :=buf .ReadByte ();_dggefa .WriteByte (_cfbb );_ggeca =false ;}else if IsDecimalDigit (_gagbc [0]){_aeag ,_ :=buf .ReadByte ();_dggefa .WriteByte (_aeag );}else if _gagbc [0]=='.'{_efce ,_ :=buf .ReadByte ();_dggefa .WriteByte (_efce );_gabfb =true ;}else if _gagbc [0]=='e'||_gagbc [0]=='E'{_gfdbd ,_ :=buf .ReadByte ();_dggefa .WriteByte (_gfdbd );_gabfb =true ;_ggeca =true ;}else {break ;};};var _cfeee PdfObject ;if _gabfb {_ecbc ,_eceb :=_b .ParseFloat (_dggefa .String (),64);if _eceb !=nil {_beg .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0025v\u0020\u0065\u0072\u0072\u003d\u0025v\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0030\u002e\u0020\u004fu\u0074\u0070u\u0074\u0020\u006d\u0061y\u0020\u0062\u0065\u0020\u0069n\u0063\u006f\u0072\u0072\u0065\u0063\u0074",_dggefa .String (),_eceb );_ecbc =0.0;_eceb =nil ;};_aaeaa :=PdfObjectFloat (_ecbc );_cfeee =&_aaeaa ;}else {_fcgba ,_ecgc :=_b .ParseInt (_dggefa .String (),10,64);if _ecgc !=nil {_beg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0025\u0076\u0020\u0065\u0072\u0072\u003d%\u0076\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074 \u006d\u0061\u0079\u0020\u0062\u0065 \u0069\u006ec\u006f\u0072r\u0065c\u0074",_dggefa .String (),_ecgc );_fcgba =0;_ecgc =nil ;};_gaddd :=PdfObjectInteger (_fcgba );_cfeee =&_gaddd ;};return _cfeee ,nil ;};

// PdfObjectReference represents the primitive PDF reference object.
type PdfObjectReference struct{_cabd *PdfParser ;ObjectNumber int64 ;GenerationNumber int64 ;};func _dgba (_cacc *PdfObjectDictionary )(_efbbg *_da .ImageBase ){var (_fcec *PdfObjectInteger ;_afggc bool ;);if _fcec ,_afggc =_cacc .Get ("\u0057\u0069\u0064t\u0068").(*PdfObjectInteger );_afggc {_efbbg =&_da .ImageBase {Width :int (*_fcec )};}else {return nil ;};if _fcec ,_afggc =_cacc .Get ("\u0048\u0065\u0069\u0067\u0068\u0074").(*PdfObjectInteger );_afggc {_efbbg .Height =int (*_fcec );};if _fcec ,_afggc =_cacc .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074").(*PdfObjectInteger );_afggc {_efbbg .BitsPerComponent =int (*_fcec );};if _fcec ,_afggc =_cacc .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073").(*PdfObjectInteger );_afggc {_efbbg .ColorComponents =int (*_fcec );};return _efbbg ;};

// DecodeBytes decodes a slice of Flate encoded bytes and returns the result.
func (_abea *FlateEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_beg .Log .Trace ("\u0046\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065\u0020b\u0079\u0074\u0065\u0073");if len (encoded )==0{_beg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0046\u006c\u0061\u0074\u0065 e\u006ec\u006f\u0064\u0065\u0064\u0020\u0062\u0075\u0066\u0066\u0065\u0072\u002e \u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0062y\u0074\u0065\u0020\u0073\u006c\u0069\u0063\u0065\u002e");return []byte {},nil ;};_bffe :=_gec .NewReader (encoded );_bebf ,_gffge :=_be .NewReader (_bffe );if _gffge !=nil {_beg .Log .Debug ("\u0044e\u0063o\u0064\u0069\u006e\u0067\u0020e\u0072\u0072o\u0072\u0020\u0025\u0076\u000a",_gffge );_beg .Log .Debug ("\u0053t\u0072e\u0061\u006d\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (encoded ),encoded );return nil ,_gffge ;};defer _bebf .Close ();var _eaee _gec .Buffer ;_eaee .ReadFrom (_bebf );return _eaee .Bytes (),nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_adcf *JBIG2Encoder )MakeStreamDict ()*PdfObjectDictionary {_daca :=MakeDict ();_daca .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_adcf .GetFilterName ()));return _daca ;};func _cea (_cgfe *PdfObjectStream ,_fdac *MultiEncoder )(*DCTEncoder ,error ){_cbcg :=NewDCTEncoder ();_dab :=_cgfe .PdfObjectDictionary ;if _dab ==nil {return _cbcg ,nil ;};_fgbe :=_cgfe .Stream ;if _fdac !=nil {_ffac ,_fdbb :=_fdac .DecodeBytes (_fgbe );if _fdbb !=nil {return nil ,_fdbb ;};_fgbe =_ffac ;};_cgfb :=_gec .NewReader (_fgbe );_dfde ,_aage :=_gb .DecodeConfig (_cgfb );if _aage !=nil {_beg .Log .Debug ("\u0045\u0072\u0072or\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0065\u003a\u0020\u0025\u0073",_aage );return nil ,_aage ;};switch _dfde .ColorModel {case _efb .RGBAModel :_cbcg .BitsPerComponent =8;_cbcg .ColorComponents =3;case _efb .RGBA64Model :_cbcg .BitsPerComponent =16;_cbcg .ColorComponents =3;case _efb .GrayModel :_cbcg .BitsPerComponent =8;_cbcg .ColorComponents =1;case _efb .Gray16Model :_cbcg .BitsPerComponent =16;_cbcg .ColorComponents =1;case _efb .CMYKModel :_cbcg .BitsPerComponent =8;_cbcg .ColorComponents =4;case _efb .YCbCrModel :_cbcg .BitsPerComponent =8;_cbcg .ColorComponents =3;default:return nil ,_e .New ("\u0075\u006e\u0073up\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u006d\u006f\u0064\u0065\u006c");};_cbcg .Width =_dfde .Width ;_cbcg .Height =_dfde .Height ;_beg .Log .Trace ("\u0044\u0043T\u0020\u0045\u006ec\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076",_cbcg );_cbcg .Quality =DefaultJPEGQuality ;return _cbcg ,nil ;};type xrefType int ;

// GetArray returns the *PdfObjectArray represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetArray (obj PdfObject )(_gedab *PdfObjectArray ,_decf bool ){_gedab ,_decf =TraceToDirectObject (obj ).(*PdfObjectArray );return _gedab ,_decf ;};type objectStream struct{N int ;_bea []byte ;_gd map[int ]int64 ;};

// GetFilterName returns the name of the encoding filter.
func (_faf *FlateEncoder )GetFilterName ()string {return StreamEncodingFilterNameFlate };

// DecodeBytes decodes a slice of JBIG2 encoded bytes and returns the results.
func (_abbbg *JBIG2Encoder )DecodeBytes (encoded []byte )([]byte ,error ){return _gae .DecodeBytes (encoded ,_cc .Parameters {},_abbbg .Globals );};

// PdfObjectStream represents the primitive PDF Object stream.
type PdfObjectStream struct{PdfObjectReference ;*PdfObjectDictionary ;Stream []byte ;};

// PdfObjectString represents the primitive PDF string object.
type PdfObjectString struct{_aabg string ;_abaf bool ;};

// GetFilterName returns the name of the encoding filter.
func (_feag *ASCIIHexEncoder )GetFilterName ()string {return StreamEncodingFilterNameASCIIHex };

// GetDict returns the *PdfObjectDictionary represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetDict (obj PdfObject )(_fgdbb *PdfObjectDictionary ,_fdfe bool ){_fgdbb ,_fdfe =TraceToDirectObject (obj ).(*PdfObjectDictionary );return _fgdbb ,_fdfe ;};

// RawEncoder implements Raw encoder/decoder (no encoding, pass through)
type RawEncoder struct{};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_bdf *RunLengthEncoder )MakeStreamDict ()*PdfObjectDictionary {_feec :=MakeDict ();_feec .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_bdf .GetFilterName ()));return _feec ;};

// GetAccessPermissions returns the PDF access permissions as an AccessPermissions object.
func (_fca *PdfCrypt )GetAccessPermissions ()_bca .Permissions {return _fca ._aba .P };

// ASCIIHexEncoder implements ASCII hex encoder/decoder.
type ASCIIHexEncoder struct{};

// IsEncrypted checks if the document is encrypted. A bool flag is returned indicating the result.
// First time when called, will check if the Encrypt dictionary is accessible through the trailer dictionary.
// If encrypted, prepares a crypt datastructure which can be used to authenticate and decrypt the document.
// On failure, an error is returned.
func (_efgfc *PdfParser )IsEncrypted ()(bool ,error ){if _efgfc ._ccddd !=nil {return true ,nil ;}else if _efgfc ._ace ==nil {return false ,nil ;};_beg .Log .Trace ("\u0043\u0068\u0065c\u006b\u0069\u006e\u0067 \u0065\u006e\u0063\u0072\u0079\u0070\u0074i\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0021");_fecd :=_efgfc ._ace .Get ("\u0045n\u0063\u0072\u0079\u0070\u0074");if _fecd ==nil {return false ,nil ;};_beg .Log .Trace ("\u0049\u0073\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u0021");var (_ceade *PdfObjectDictionary ;);switch _feac :=_fecd .(type ){case *PdfObjectDictionary :_ceade =_feac ;case *PdfObjectReference :_beg .Log .Trace ("\u0030\u003a\u0020\u004c\u006f\u006f\u006b\u0020\u0075\u0070\u0020\u0072e\u0066\u0020\u0025\u0071",_feac );_agbed ,_bgdc :=_efgfc .LookupByReference (*_feac );_beg .Log .Trace ("\u0031\u003a\u0020%\u0071",_agbed );if _bgdc !=nil {return false ,_bgdc ;};_defb ,_abec :=_agbed .(*PdfIndirectObject );if !_abec {_beg .Log .Debug ("E\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006eo\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072ec\u0074\u0020\u006fb\u006ae\u0063\u0074");return false ,_e .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");};_fdad ,_abec :=_defb .PdfObject .(*PdfObjectDictionary );_beg .Log .Trace ("\u0032\u003a\u0020%\u0071",_fdad );if !_abec {return false ,_e .New ("\u0074\u0072a\u0069\u006c\u0065\u0072 \u0045\u006ec\u0072\u0079\u0070\u0074\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u006e\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");};_ceade =_fdad ;case *PdfObjectNull :_beg .Log .Debug ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074 \u0069\u0073\u0020a\u0020\u006e\u0075l\u006c\u0020o\u0062\u006a\u0065\u0063\u0074\u002e \u0046il\u0065\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u002e");return false ,nil ;default:return false ,_ff .Errorf ("u\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0079\u0070\u0065: \u0025\u0054",_feac );};_bebbc ,_fdeeg :=PdfCryptNewDecrypt (_efgfc ,_ceade ,_efgfc ._ace );if _fdeeg !=nil {return false ,_fdeeg ;};for _ ,_faabd :=range []string {"\u0049\u006e\u0066\u006f","\u0045n\u0063\u0072\u0079\u0070\u0074"}{_abagd :=_efgfc ._ace .Get (PdfObjectName (_faabd ));if _abagd ==nil {continue ;};switch _gagb :=_abagd .(type ){case *PdfObjectReference :_bebbc ._bcc [int (_gagb .ObjectNumber )]=struct{}{};case *PdfIndirectObject :_bebbc ._ggd [_gagb ]=true ;_bebbc ._bcc [int (_gagb .ObjectNumber )]=struct{}{};};};_efgfc ._ccddd =_bebbc ;_beg .Log .Trace ("\u0043\u0072\u0079\u0070\u0074\u0065\u0072\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0025\u0062",_bebbc );return true ,nil ;};

// PdfObjectNull represents the primitive PDF null object.
type PdfObjectNull struct{};func (_bbg *PdfCrypt )newEncryptDict ()*PdfObjectDictionary {_beb :=MakeDict ();_beb .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName ("\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"));_beb .Set ("\u0056",MakeInteger (int64 (_bbg ._geb .V )));_beb .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_bbg ._geb .Length )));return _beb ;};func (_daba *PdfParser )xrefNextObjectOffset (_eddb int64 )int64 {_gabfe :=int64 (0);if len (_daba ._bbda .ObjectMap )==0{return 0;};if len (_daba ._bbda ._ec )==0{_gfed :=0;for _ ,_fdcf :=range _daba ._bbda .ObjectMap {if _fdcf .Offset > 0{_gfed ++;};};if _gfed ==0{return 0;};_daba ._bbda ._ec =make ([]XrefObject ,_gfed );_dfecbd :=0;for _ ,_caddg :=range _daba ._bbda .ObjectMap {if _caddg .Offset > 0{_daba ._bbda ._ec [_dfecbd ]=_caddg ;_dfecbd ++;};};_g .Slice (_daba ._bbda ._ec ,func (_fbdg ,_ecea int )bool {return _daba ._bbda ._ec [_fbdg ].Offset < _daba ._bbda ._ec [_ecea ].Offset });};_bbfc :=_g .Search (len (_daba ._bbda ._ec ),func (_cgdd int )bool {return _daba ._bbda ._ec [_cgdd ].Offset >=_eddb });if _bbfc < len (_daba ._bbda ._ec ){_gabfe =_daba ._bbda ._ec [_bbfc ].Offset ;};return _gabfe ;};

// EncodeBytes implements support for LZW encoding.  Currently not supporting predictors (raw compressed data only).
// Only supports the Early change = 1 algorithm (compress/lzw) as the other implementation
// does not have a write method.
// TODO: Consider refactoring compress/lzw to allow both.
func (_gfff *LZWEncoder )EncodeBytes (data []byte )([]byte ,error ){if _gfff .Predictor !=1{return nil ,_ff .Errorf ("\u004c\u005aW \u0050\u0072\u0065d\u0069\u0063\u0074\u006fr =\u00201 \u006f\u006e\u006c\u0079\u0020\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0079e\u0074");};if _gfff .EarlyChange ==1{return nil ,_ff .Errorf ("\u004c\u005a\u0057\u0020\u0045\u0061\u0072\u006c\u0079\u0020\u0043\u0068\u0061n\u0067\u0065\u0020\u003d\u0020\u0030 \u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0079\u0065\u0074");};var _fcea _gec .Buffer ;_dfge :=_ca .NewWriter (&_fcea ,_ca .MSB ,8);_dfge .Write (data );_dfge .Close ();return _fcea .Bytes (),nil ;};const (DefaultJPEGQuality =75;);func (_gadd *PdfParser )parseObject ()(PdfObject ,error ){_beg .Log .Trace ("\u0052e\u0061d\u0020\u0064\u0069\u0072\u0065c\u0074\u0020o\u0062\u006a\u0065\u0063\u0074");_gadd .skipSpaces ();for {_bacd ,_eade :=_gadd ._cdff .Peek (2);if _eade !=nil {if _eade !=_cg .EOF ||len (_bacd )==0{return nil ,_eade ;};if len (_bacd )==1{_bacd =append (_bacd ,' ');};};_beg .Log .Trace ("\u0050e\u0065k\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u003a\u0020\u0025\u0073",string (_bacd ));if _bacd [0]=='/'{_abgd ,_aggg :=_gadd .parseName ();_beg .Log .Trace ("\u002d\u003e\u004ea\u006d\u0065\u003a\u0020\u0027\u0025\u0073\u0027",_abgd );return &_abgd ,_aggg ;}else if _bacd [0]=='('{_beg .Log .Trace ("\u002d>\u0053\u0074\u0072\u0069\u006e\u0067!");_cdcgg ,_gdcb :=_gadd .parseString ();return _cdcgg ,_gdcb ;}else if _bacd [0]=='['{_beg .Log .Trace ("\u002d\u003e\u0041\u0072\u0072\u0061\u0079\u0021");_cece ,_dcg :=_gadd .parseArray ();return _cece ,_dcg ;}else if (_bacd [0]=='<')&&(_bacd [1]=='<'){_beg .Log .Trace ("\u002d>\u0044\u0069\u0063\u0074\u0021");_fdaf ,_dfff :=_gadd .ParseDict ();return _fdaf ,_dfff ;}else if _bacd [0]=='<'{_beg .Log .Trace ("\u002d\u003e\u0048\u0065\u0078\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0021");_gbgb ,_dgag :=_gadd .parseHexString ();return _gbgb ,_dgag ;}else if _bacd [0]=='%'{_gadd .readComment ();_gadd .skipSpaces ();}else {_beg .Log .Trace ("\u002d\u003eN\u0075\u006d\u0062e\u0072\u0020\u006f\u0072\u0020\u0072\u0065\u0066\u003f");_bacd ,_ =_gadd ._cdff .Peek (15);_dcfc :=string (_bacd );_beg .Log .Trace ("\u0050\u0065\u0065k\u0020\u0073\u0074\u0072\u003a\u0020\u0025\u0073",_dcfc );if (len (_dcfc )> 3)&&(_dcfc [:4]=="\u006e\u0075\u006c\u006c"){_ggbe ,_bdga :=_gadd .parseNull ();return &_ggbe ,_bdga ;}else if (len (_dcfc )> 4)&&(_dcfc [:5]=="\u0066\u0061\u006cs\u0065"){_gcbda ,_cfcf :=_gadd .parseBool ();return &_gcbda ,_cfcf ;}else if (len (_dcfc )> 3)&&(_dcfc [:4]=="\u0074\u0072\u0075\u0065"){_gaeg ,_efgea :=_gadd .parseBool ();return &_gaeg ,_efgea ;};_fffa :=_egfg .FindStringSubmatch (string (_dcfc ));if len (_fffa )> 1{_bacd ,_ =_gadd ._cdff .ReadBytes ('R');_beg .Log .Trace ("\u002d\u003e\u0020\u0021\u0052\u0065\u0066\u003a\u0020\u0027\u0025\u0073\u0027",string (_bacd [:]));_edee ,_ddgda :=_daaa (string (_bacd ));_edee ._cabd =_gadd ;return &_edee ,_ddgda ;};_ceee :=_efgb .FindStringSubmatch (string (_dcfc ));if len (_ceee )> 1{_beg .Log .Trace ("\u002d\u003e\u0020\u004e\u0075\u006d\u0062\u0065\u0072\u0021");_feebd ,_aaf :=_gadd .parseNumber ();return _feebd ,_aaf ;};_ceee =_cedcb .FindStringSubmatch (string (_dcfc ));if len (_ceee )> 1{_beg .Log .Trace ("\u002d\u003e\u0020\u0045xp\u006f\u006e\u0065\u006e\u0074\u0069\u0061\u006c\u0020\u004e\u0075\u006d\u0062\u0065r\u0021");_beg .Log .Trace ("\u0025\u0020\u0073",_ceee );_begf ,_fggd :=_gadd .parseNumber ();return _begf ,_fggd ;};_beg .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020U\u006e\u006b\u006e\u006f\u0077n\u0020(\u0070e\u0065\u006b\u0020\u0022\u0025\u0073\u0022)",_dcfc );return nil ,_e .New ("\u006f\u0062\u006a\u0065\u0063t\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020\u0075\u006e\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e");};};};func (_daad *PdfParser )readComment ()(string ,error ){var _cfae _gec .Buffer ;_ ,_adga :=_daad .skipSpaces ();if _adga !=nil {return _cfae .String (),_adga ;};_fcaef :=true ;for {_dbbee ,_fafc :=_daad ._cdff .Peek (1);if _fafc !=nil {_beg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_fafc .Error ());return _cfae .String (),_fafc ;};if _fcaef &&_dbbee [0]!='%'{return _cfae .String (),_e .New ("c\u006f\u006d\u006d\u0065\u006e\u0074 \u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0073\u0074a\u0072\u0074\u0020w\u0069t\u0068\u0020\u0025");};_fcaef =false ;if (_dbbee [0]!='\r')&&(_dbbee [0]!='\n'){_fbae ,_ :=_daad ._cdff .ReadByte ();_cfae .WriteByte (_fbae );}else {break ;};};return _cfae .String (),nil ;};func (_dcac *PdfParser )repairSeekXrefMarker ()error {_cggfa ,_facbf :=_dcac ._bdff .Seek (0,_bf .SEEK_END );if _facbf !=nil {return _facbf ;};_bgcf :=_ef .MustCompile ("\u005cs\u0078\u0072\u0065\u0066\u005c\u0073*");var _ddcb int64 ;var _beca int64 =1000;for _ddcb < _cggfa {if _cggfa <=(_beca +_ddcb ){_beca =_cggfa -_ddcb ;};_ ,_eceg :=_dcac ._bdff .Seek (-_ddcb -_beca ,_bf .SEEK_END );if _eceg !=nil {return _eceg ;};_bcgg :=make ([]byte ,_beca );_dcac ._bdff .Read (_bcgg );_beg .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0078\u0072\u0065\u0066\u0020\u003a\u0020\u0022\u0025\u0073\u0022",string (_bcgg ));_fgge :=_bgcf .FindAllStringIndex (string (_bcgg ),-1);if _fgge !=nil {_cceaa :=_fgge [len (_fgge )-1];_beg .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_fgge );_dcac ._bdff .Seek (-_ddcb -_beca +int64 (_cceaa [0]),_bf .SEEK_END );_dcac ._cdff =_gf .NewReader (_dcac ._bdff );for {_acde ,_ccfdf :=_dcac ._cdff .Peek (1);if _ccfdf !=nil {return _ccfdf ;};_beg .Log .Trace ("\u0042\u003a\u0020\u0025\u0064\u0020\u0025\u0063",_acde [0],_acde [0]);if !IsWhiteSpace (_acde [0]){break ;};_dcac ._cdff .Discard (1);};return nil ;};_beg .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");_ddcb +=_beca ;};_beg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074a\u0062\u006c\u0065\u0020\u006d\u0061r\u006b\u0065\u0072\u0020\u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066o\u0075\u006e\u0064\u002e");return _e .New ("\u0078r\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0020");};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_bdac *RawEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};var (ErrUnsupportedEncodingParameters =_e .New ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074\u0065\u0072\u0073");ErrNoCCITTFaxDecode =_e .New ("\u0043\u0043I\u0054\u0054\u0046\u0061\u0078\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");ErrNoJBIG2Decode =_e .New ("\u004a\u0042\u0049\u0047\u0032\u0044\u0065c\u006f\u0064\u0065 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");ErrNoJPXDecode =_e .New ("\u004a\u0050\u0058\u0044\u0065c\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020i\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");ErrNoPdfVersion =_e .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");ErrTypeError =_e .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");ErrRangeError =_e .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");ErrNotSupported =_gbg .New ("\u0066\u0065\u0061t\u0075\u0072\u0065\u0020n\u006f\u0074\u0020\u0063\u0075\u0072\u0072e\u006e\u0074\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");ErrNotANumber =_e .New ("\u006e\u006f\u0074 \u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072"););

// GetString is a helper for Get that returns a string value.
// Returns false if the key is missing or a value is not a string.
func (_gddf *PdfObjectDictionary )GetString (key PdfObjectName )(string ,bool ){_fdbfg ,_ggda :=_gddf ._ggagd [key ].(*PdfObjectString );if !_ggda {return "",false ;};return _fdbfg .Str (),true ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_edde *MultiEncoder )MakeDecodeParams ()PdfObject {if len (_edde ._ccc )==0{return nil ;};if len (_edde ._ccc )==1{return _edde ._ccc [0].MakeDecodeParams ();};_bdbf :=MakeArray ();for _ ,_bbag :=range _edde ._ccc {_bafe :=_bbag .MakeDecodeParams ();if _bafe ==nil {_bdbf .Append (MakeNull ());}else {_bdbf .Append (_bafe );};};return _bdbf ;};

// WriteString outputs the object as it is to be written to file.
func (_fadba *PdfObjectDictionary )WriteString ()string {var _cgab _d .Builder ;_cgab .WriteString ("\u003c\u003c");for _ ,_gfag :=range _fadba ._edcg {_cecf :=_fadba ._ggagd [_gfag ];_cgab .WriteString (_gfag .WriteString ());_cgab .WriteString ("\u0020");_cgab .WriteString (_cecf .WriteString ());};_cgab .WriteString ("\u003e\u003e");return _cgab .String ();};

// DecodeStream decodes a LZW encoded stream and returns the result as a
// slice of bytes.
func (_fbeg *LZWEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_beg .Log .Trace ("\u004c\u005a\u0057 \u0044\u0065\u0063\u006f\u0064\u0069\u006e\u0067");_beg .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_fbeg .Predictor );_cbab ,_dbba :=_fbeg .DecodeBytes (streamObj .Stream );if _dbba !=nil {return nil ,_dbba ;};_beg .Log .Trace ("\u0020\u0049\u004e\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (streamObj .Stream ),streamObj .Stream );_beg .Log .Trace ("\u004f\u0055\u0054\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (_cbab ),_cbab );if _fbeg .Predictor > 1{if _fbeg .Predictor ==2{_beg .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_aegg :=int (_fbeg .Columns )*_fbeg .Colors ;if _aegg < 1{return []byte {},nil ;};_ffcc :=len (_cbab )/_aegg ;if len (_cbab )%_aegg !=0{_beg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");return nil ,_ff .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_cbab ),_aegg );};if _aegg %_fbeg .Colors !=0{return nil ,_ff .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_aegg ,_fbeg .Colors );};if _aegg > len (_cbab ){_beg .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_aegg ,len (_cbab ));return nil ,_e .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_beg .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_cbab ),_cbab );_dfea :=_gec .NewBuffer (nil );for _ffcd :=0;_ffcd < _ffcc ;_ffcd ++{_cafg :=_cbab [_aegg *_ffcd :_aegg *(_ffcd +1)];for _baag :=_fbeg .Colors ;_baag < _aegg ;_baag ++{_cafg [_baag ]=byte (int (_cafg [_baag ]+_cafg [_baag -_fbeg .Colors ])%256);};_dfea .Write (_cafg );};_fdb :=_dfea .Bytes ();_beg .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_fdb ),_fdb );return _fdb ,nil ;}else if _fbeg .Predictor >=10&&_fbeg .Predictor <=15{_beg .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_cbbd :=int (_fbeg .Columns *_fbeg .Colors +1);if _cbbd < 1{return []byte {},nil ;};_bdae :=len (_cbab )/_cbbd ;if len (_cbab )%_cbbd !=0{return nil ,_ff .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_cbab ),_cbbd );};if _cbbd > len (_cbab ){_beg .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_cbbd ,len (_cbab ));return nil ,_e .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_gcce :=_gec .NewBuffer (nil );_beg .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_fbeg .Columns );_beg .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_cbab ),_cbbd ,_bdae );_gagf :=make ([]byte ,_cbbd );for _acag :=0;_acag < _cbbd ;_acag ++{_gagf [_acag ]=0;};for _dbga :=0;_dbga < _bdae ;_dbga ++{_egfc :=_cbab [_cbbd *_dbga :_cbbd *(_dbga +1)];_bbge :=_egfc [0];switch _bbge {case 0:case 1:for _abfc :=2;_abfc < _cbbd ;_abfc ++{_egfc [_abfc ]=byte (int (_egfc [_abfc ]+_egfc [_abfc -1])%256);};case 2:for _bafd :=1;_bafd < _cbbd ;_bafd ++{_egfc [_bafd ]=byte (int (_egfc [_bafd ]+_gagf [_bafd ])%256);};default:_beg .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0066i\u006c\u0074\u0065\u0072\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_bbge );return nil ,_ff .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_bbge );};for _afgg :=0;_afgg < _cbbd ;_afgg ++{_gagf [_afgg ]=_egfc [_afgg ];};_gcce .Write (_egfc [1:]);};_bded :=_gcce .Bytes ();return _bded ,nil ;}else {_beg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_fbeg .Predictor );return nil ,_ff .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_fbeg .Predictor );};};return _cbab ,nil ;};

// GetFilterName returns the name of the encoding filter.
func (_gca *RawEncoder )GetFilterName ()string {return StreamEncodingFilterNameRaw };

// EncodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_cffd *RawEncoder )EncodeBytes (data []byte )([]byte ,error ){return data ,nil };

// NewRawEncoder returns a new instace of RawEncoder.
func NewRawEncoder ()*RawEncoder {return &RawEncoder {}};

// NewParserFromString is used for testing purposes.
func NewParserFromString (txt string )*PdfParser {_ecaa :=_gec .NewReader ([]byte (txt ));_cecc :=&PdfParser {ObjCache :objectCache {},_bdff :_ecaa ,_cdff :_gf .NewReader (_ecaa ),_bdaca :int64 (len (txt )),_ebae :map[int64 ]bool {}};_cecc ._bbda .ObjectMap =make (map[int ]XrefObject );return _cecc ;};

// GetXrefOffset returns the offset of the xref table.
func (_gdbc *PdfParser )GetXrefOffset ()int64 {return _gdbc ._gedgc };func (_cecg *PdfParser )repairRebuildXrefsTopDown ()(*XrefTable ,error ){if _cecg ._gegg {return nil ,_ff .Errorf ("\u0072\u0065\u0070\u0061\u0069\u0072\u0020\u0066\u0061\u0069\u006c\u0065\u0064");};_cecg ._gegg =true ;_cecg ._bdff .Seek (0,_bf .SEEK_SET );_cecg ._cdff =_gf .NewReader (_cecg ._bdff );_fddc :=20;_agagf :=make ([]byte ,_fddc );_cbgae :=XrefTable {};_cbgae .ObjectMap =make (map[int ]XrefObject );for {_bgabe ,_eafe :=_cecg ._cdff .ReadByte ();if _eafe !=nil {if _eafe ==_cg .EOF {break ;}else {return nil ,_eafe ;};};if _bgabe =='j'&&_agagf [_fddc -1]=='b'&&_agagf [_fddc -2]=='o'&&IsWhiteSpace (_agagf [_fddc -3]){_beaaa :=_fddc -4;for IsWhiteSpace (_agagf [_beaaa ])&&_beaaa > 0{_beaaa --;};if _beaaa ==0||!IsDecimalDigit (_agagf [_beaaa ]){continue ;};for IsDecimalDigit (_agagf [_beaaa ])&&_beaaa > 0{_beaaa --;};if _beaaa ==0||!IsWhiteSpace (_agagf [_beaaa ]){continue ;};for IsWhiteSpace (_agagf [_beaaa ])&&_beaaa > 0{_beaaa --;};if _beaaa ==0||!IsDecimalDigit (_agagf [_beaaa ]){continue ;};for IsDecimalDigit (_agagf [_beaaa ])&&_beaaa > 0{_beaaa --;};if _beaaa ==0{continue ;};_aafdc :=_cecg .GetFileOffset ()-int64 (_fddc -_beaaa );_gege :=append (_agagf [_beaaa +1:],_bgabe );_ccaa ,_abbc ,_ffad :=_bbed (string (_gege ));if _ffad !=nil {_beg .Log .Debug ("\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u006e\u0075\u006d\u0062\u0065r\u003a\u0020\u0025\u0076",_ffad );return nil ,_ffad ;};if _efcfg ,_ceag :=_cbgae .ObjectMap [_ccaa ];!_ceag ||_efcfg .Generation < _abbc {_ffec :=XrefObject {};_ffec .XType =XrefTypeTableEntry ;_ffec .ObjectNumber =int (_ccaa );_ffec .Generation =int (_abbc );_ffec .Offset =_aafdc ;_cbgae .ObjectMap [_ccaa ]=_ffec ;};};_agagf =append (_agagf [1:_fddc ],_bgabe );};return &_cbgae ,nil ;};

// DecodeBytes decodes a multi-encoded slice of bytes by passing it through the
// DecodeBytes method of the underlying encoders.
func (_gegc *MultiEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_cbfd :=encoded ;var _cfdf error ;for _ ,_effg :=range _gegc ._ccc {_beg .Log .Trace ("\u004du\u006c\u0074i\u0020\u0045\u006e\u0063o\u0064\u0065\u0072 \u0044\u0065\u0063\u006f\u0064\u0065\u003a\u0020\u0041pp\u006c\u0079\u0069n\u0067\u0020F\u0069\u006c\u0074\u0065\u0072\u003a \u0025\u0076 \u0025\u0054",_effg ,_effg );_cbfd ,_cfdf =_effg .DecodeBytes (_cbfd );if _cfdf !=nil {return nil ,_cfdf ;};};return _cbfd ,nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_ffff *LZWEncoder )MakeStreamDict ()*PdfObjectDictionary {_ffeg :=MakeDict ();_ffeg .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_ffff .GetFilterName ()));_egfa :=_ffff .MakeDecodeParams ();if _egfa !=nil {_ffeg .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_egfa );};_ffeg .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (int64 (_ffff .EarlyChange )));return _ffeg ;};func (_dca *PdfCrypt )decryptBytes (_abf []byte ,_cgf string ,_bfe []byte )([]byte ,error ){_beg .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");_gfc ,_eeaa :=_dca ._dbf [_cgf ];if !_eeaa {return nil ,_ff .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_cgf );};return _gfc .DecryptBytes (_abf ,_bfe );};

// MakeArrayFromFloats creates an PdfObjectArray from a slice of float64s, where each array element is an
// PdfObjectFloat.
func MakeArrayFromFloats (vals []float64 )*PdfObjectArray {_gagdf :=MakeArray ();for _ ,_edbgd :=range vals {_gagdf .Append (MakeFloat (_edbgd ));};return _gagdf ;};

// NewJPXEncoder returns a new instance of JPXEncoder.
func NewJPXEncoder ()*JPXEncoder {return &JPXEncoder {}};

// Str returns the string value of the PdfObjectString. Defined in addition to String() function to clarify that
// this function returns the underlying string directly, whereas the String function technically could include
// debug info.
func (_fgeg *PdfObjectString )Str ()string {return _fgeg ._aabg };

// GetNumbersAsFloat converts a list of pdf objects representing floats or integers to a slice of
// float64 values.
func GetNumbersAsFloat (objects []PdfObject )(_eadcf []float64 ,_fdeg error ){for _ ,_aafb :=range objects {_gfcc ,_gfeb :=GetNumberAsFloat (_aafb );if _gfeb !=nil {return nil ,_gfeb ;};_eadcf =append (_eadcf ,_gfcc );};return _eadcf ,nil ;};

// DecodeBytes decodes byte array with ASCII85. 5 ASCII characters -> 4 raw binary bytes
func (_adgc *ASCII85Encoder )DecodeBytes (encoded []byte )([]byte ,error ){var _aacb []byte ;_beg .Log .Trace ("\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0020\u0044e\u0063\u006f\u0064\u0065");_affa :=0;_fbfb :=false ;for _affa < len (encoded )&&!_fbfb {_afac :=[5]byte {0,0,0,0,0};_gabg :=0;_fbbg :=0;_ggee :=4;for _fbbg < 5+_gabg {if _affa +_fbbg ==len (encoded ){break ;};_egbe :=encoded [_affa +_fbbg ];if IsWhiteSpace (_egbe ){_gabg ++;_fbbg ++;continue ;}else if _egbe =='~'&&_affa +_fbbg +1< len (encoded )&&encoded [_affa +_fbbg +1]=='>'{_ggee =(_fbbg -_gabg )-1;if _ggee < 0{_ggee =0;};_fbfb =true ;break ;}else if _egbe >='!'&&_egbe <='u'{_egbe -='!';}else if _egbe =='z'&&_fbbg -_gabg ==0{_ggee =4;_fbbg ++;break ;}else {_beg .Log .Error ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u002c\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020co\u0064\u0065");return nil ,_e .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0063\u006f\u0064\u0065\u0020e\u006e\u0063\u006f\u0075\u006e\u0074\u0065\u0072\u0065\u0064");};_afac [_fbbg -_gabg ]=_egbe ;_fbbg ++;};_affa +=_fbbg ;for _ddab :=_ggee +1;_ddab < 5;_ddab ++{_afac [_ddab ]=84;};_acad :=uint32 (_afac [0])*85*85*85*85+uint32 (_afac [1])*85*85*85+uint32 (_afac [2])*85*85+uint32 (_afac [3])*85+uint32 (_afac [4]);_dec :=[]byte {byte ((_acad >>24)&0xff),byte ((_acad >>16)&0xff),byte ((_acad >>8)&0xff),byte (_acad &0xff)};_aacb =append (_aacb ,_dec [:_ggee ]...);};_beg .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0065\u006e\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",encoded );_beg .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0064\u0065\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",_aacb );return _aacb ,nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_dacca *JPXEncoder )UpdateParams (params *PdfObjectDictionary ){};

// GetXrefType returns the type of the first xref object (table or stream).
func (_fdabg *PdfParser )GetXrefType ()*xrefType {return _fdabg ._bdaa };

// String returns a string representation of `name`.
func (_cgaf *PdfObjectName )String ()string {return string (*_cgaf )};

// GetStream returns the *PdfObjectStream represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetStream (obj PdfObject )(_cbdf *PdfObjectStream ,_cdca bool ){obj =ResolveReference (obj );_cbdf ,_cdca =obj .(*PdfObjectStream );return _cbdf ,_cdca ;};

// PdfCryptNewEncrypt makes the document crypt handler based on a specified crypt filter.
func PdfCryptNewEncrypt (cf _ag .Filter ,userPass ,ownerPass []byte ,perm _bca .Permissions )(*PdfCrypt ,*EncryptInfo ,error ){_df :=&PdfCrypt {_afc :make (map[PdfObject ]bool ),_dbf :make (cryptFilters ),_aba :_bca .StdEncryptDict {P :perm ,EncryptMetadata :true }};var _dacc Version ;if cf !=nil {_dcb :=cf .PDFVersion ();_dacc .Major ,_dacc .Minor =_dcb [0],_dcb [1];V ,R :=cf .HandlerVersion ();_df ._geb .V =V ;_df ._aba .R =R ;_df ._geb .Length =cf .KeyLength ()*8;};const (_fbd =_gcd ;);_df ._dbf [_fbd ]=cf ;if _df ._geb .V >=4{_df ._dae =_fbd ;_df ._fde =_fbd ;};_ee :=_df .newEncryptDict ();_beae :=_ge .Sum ([]byte (_a .Now ().Format (_a .RFC850 )));_gbae :=string (_beae [:]);_bac :=make ([]byte ,100);_cgg .Read (_bac );_beae =_ge .Sum (_bac );_dfg :=string (_beae [:]);_beg .Log .Trace ("\u0052\u0061\u006e\u0064\u006f\u006d\u0020\u0062\u003a\u0020\u0025\u0020\u0078",_bac );_beg .Log .Trace ("\u0047\u0065\u006e\u0020\u0049\u0064\u0020\u0030\u003a\u0020\u0025\u0020\u0078",_gbae );_df ._eg =string (_gbae );_aca :=_df .generateParams (userPass ,ownerPass );if _aca !=nil {return nil ,nil ,_aca ;};_baf (&_df ._aba ,_ee );if _df ._geb .V >=4{if _cee :=_df .saveCryptFilters (_ee );_cee !=nil {return nil ,nil ,_cee ;};};return _df ,&EncryptInfo {Version :_dacc ,Encrypt :_ee ,ID0 :_gbae ,ID1 :_dfg },nil ;};

// AddEncoder adds the passed in encoder to the underlying encoder slice.
func (_ffcbc *MultiEncoder )AddEncoder (encoder StreamEncoder ){_ffcbc ._ccc =append (_ffcbc ._ccc ,encoder );};func _ffccb ()string {return _beg .Version };

// ToGoImage converts the JBIG2Image to the golang image.Image.
func (_cebcb *JBIG2Image )ToGoImage ()(_ga .Image ,error ){const _gdgc ="J\u0042I\u0047\u0032\u0049\u006d\u0061\u0067\u0065\u002eT\u006f\u0047\u006f\u0049ma\u0067\u0065";if _cebcb .Data ==nil {return nil ,_aa .Error (_gdgc ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");};if _cebcb .Width ==0||_cebcb .Height ==0{return nil ,_aa .Error (_gdgc ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");};_eccc ,_gdge :=_da .NewImage (_cebcb .Width ,_cebcb .Height ,1,1,_cebcb .Data ,nil ,nil );if _gdge !=nil {return nil ,_gdge ;};return _eccc ,nil ;};

// PdfObjectInteger represents the primitive PDF integer numerical object.
type PdfObjectInteger int64 ;

// UpdateParams updates the parameter values of the encoder.
func (_edfb *CCITTFaxEncoder )UpdateParams (params *PdfObjectDictionary ){if _faaa ,_bdfg :=GetNumberAsInt64 (params .Get ("\u004b"));_bdfg ==nil {_edfb .K =int (_faaa );};if _afbee ,_ggea :=GetNumberAsInt64 (params .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));_ggea ==nil {_edfb .Columns =int (_afbee );}else if _afbee ,_ggea =GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));_ggea ==nil {_edfb .Columns =int (_afbee );};if _gadec ,_fece :=GetNumberAsInt64 (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_fece ==nil {_edfb .BlackIs1 =_gadec > 0;}else {if _faec ,_caaf :=GetBoolVal (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_caaf {_edfb .BlackIs1 =_faec ;}else {if _acadc ,_fadb :=GetArray (params .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));_fadb {_eegbe ,_adgf :=_acadc .ToIntegerArray ();if _adgf ==nil {_edfb .BlackIs1 =_eegbe [0]==1&&_eegbe [1]==0;};};};};if _gecb ,_cab :=GetNumberAsInt64 (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_cab ==nil {_edfb .EncodedByteAlign =_gecb > 0;}else {if _gee ,_becc :=GetBoolVal (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_becc {_edfb .EncodedByteAlign =_gee ;};};if _egcd ,_fdeb :=GetNumberAsInt64 (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_fdeb ==nil {_edfb .EndOfLine =_egcd > 0;}else {if _eaad ,_eeb :=GetBoolVal (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_eeb {_edfb .EndOfLine =_eaad ;};};if _eeee ,_bbfe :=GetNumberAsInt64 (params .Get ("\u0052\u006f\u0077\u0073"));_bbfe ==nil {_edfb .Rows =int (_eeee );}else if _eeee ,_bbfe =GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));_bbfe ==nil {_edfb .Rows =int (_eeee );};if _dgaa ,_dbcc :=GetNumberAsInt64 (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_dbcc ==nil {_edfb .EndOfBlock =_dgaa > 0;}else {if _fbgd ,_agcg :=GetBoolVal (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_agcg {_edfb .EndOfBlock =_fbgd ;};};if _gcff ,_acc :=GetNumberAsInt64 (params .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));_acc !=nil {_edfb .DamagedRowsBeforeError =int (_gcff );};};

// GetStringVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetStringVal (obj PdfObject )(_gdebge string ,_bcec bool ){_abcee ,_bcec :=TraceToDirectObject (obj ).(*PdfObjectString );if _bcec {return _abcee .Str (),true ;};return ;};func (_bcefe *PdfParser )parseXref ()(*PdfObjectDictionary ,error ){const _dcag =20;_dgee ,_ :=_bcefe ._cdff .Peek (_dcag );for _ccae :=0;_ccae < 2;_ccae ++{if _bcefe ._gedgc ==0{_bcefe ._gedgc =_bcefe .GetFileOffset ();};if _dbbe .Match (_dgee ){_beg .Log .Trace ("\u0078\u0072e\u0066\u0020\u0070\u006f\u0069\u006e\u0074\u0073\u0020\u0074\u006f\u0020\u0061\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u002e\u0020\u0050\u0072\u006f\u0062\u0061\u0062\u006c\u0079\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063\u0074");_beg .Log .Debug ("\u0073t\u0061r\u0074\u0069\u006e\u0067\u0020w\u0069\u0074h\u0020\u0022\u0025\u0073\u0022",string (_dgee ));return _bcefe .parseXrefStream (nil );};if _ebaf .Match (_dgee ){_beg .Log .Trace ("\u0053\u0074\u0061\u006ed\u0061\u0072\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073e\u0063t\u0069\u006f\u006e\u0020\u0074\u0061\u0062l\u0065\u0021");return _bcefe .parseXrefTable ();};_aebg :=_bcefe .GetFileOffset ();if _bcefe ._gedgc ==0{_bcefe ._gedgc =_aebg ;};_bcefe .SetFileOffset (_aebg -_dcag );defer _bcefe .SetFileOffset (_aebg );_agbda ,_ :=_bcefe ._cdff .Peek (_dcag );_dgee =append (_agbda ,_dgee ...);};_beg .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u0078\u0072\u0065f\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006fr\u0020\u0073\u0074\u0072\u0065\u0061\u006d.\u0020\u0052\u0065\u0070\u0061i\u0072\u0020\u0061\u0074\u0074e\u006d\u0070\u0074\u0065\u0064\u003a\u0020\u004c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0065\u0061\u0072\u006c\u0069\u0065\u0073\u0074\u0020x\u0072\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u0062\u006f\u0074to\u006d\u002e");if _adfcc :=_bcefe .repairSeekXrefMarker ();_adfcc !=nil {_beg .Log .Debug ("\u0052e\u0070a\u0069\u0072\u0020\u0066\u0061i\u006c\u0065d\u0020\u002d\u0020\u0025\u0076",_adfcc );return nil ,_adfcc ;};return _bcefe .parseXrefTable ();};

// UpdateParams updates the parameter values of the encoder.
func (_bdbe *MultiEncoder )UpdateParams (params *PdfObjectDictionary ){for _ ,_gce :=range _bdbe ._ccc {_gce .UpdateParams (params );};};

// NewDCTEncoder makes a new DCT encoder with default parameters.
func NewDCTEncoder ()*DCTEncoder {_ccbcc :=&DCTEncoder {};_ccbcc .ColorComponents =3;_ccbcc .BitsPerComponent =8;_ccbcc .Quality =DefaultJPEGQuality ;return _ccbcc ;};

// LookupByNumber looks up a PdfObject by object number.  Returns an error on failure.
func (_gag *PdfParser )LookupByNumber (objNumber int )(PdfObject ,error ){_adc ,_ ,_aag :=_gag .lookupByNumberWrapper (objNumber ,true );return _adc ,_aag ;};

// DecodeStream implements ASCII85 stream decoding.
func (_aeab *ASCII85Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _aeab .DecodeBytes (streamObj .Stream );};

// PdfParser parses a PDF file and provides access to the object structure of the PDF.
type PdfParser struct{_feaf Version ;_bdff _cg .ReadSeeker ;_cdff *_gf .Reader ;_bdaca int64 ;_bbda XrefTable ;_gedgc int64 ;_bdaa *xrefType ;_ecca objectStreams ;_ace *PdfObjectDictionary ;_ccddd *PdfCrypt ;_gegg bool ;ObjCache objectCache ;_ebae map[int64 ]bool ;};

// JBIG2Image is the image structure used by the jbig2 encoder. Its Data must be in a
// 1 bit per component and 1 component per pixel (1bpp). In order to create binary image
// use GoImageToJBIG2 function. If the image data contains the row bytes padding set the HasPadding to true.
type JBIG2Image struct{

// Width and Height defines the image boundaries.
Width ,Height int ;

// Data is the byte slice data for the input image
Data []byte ;

// HasPadding is the attribute that defines if the last byte of the data in the row contains
// 0 bits padding.
HasPadding bool ;};

// DecodeBytes decodes a slice of ASCII encoded bytes and returns the result.
func (_dgd *ASCIIHexEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_bdad :=_gec .NewReader (encoded );var _ggefd []byte ;for {_bcfa ,_bebd :=_bdad .ReadByte ();if _bebd !=nil {return nil ,_bebd ;};if _bcfa =='>'{break ;};if IsWhiteSpace (_bcfa ){continue ;};if (_bcfa >='a'&&_bcfa <='f')||(_bcfa >='A'&&_bcfa <='F')||(_bcfa >='0'&&_bcfa <='9'){_ggefd =append (_ggefd ,_bcfa );}else {_beg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0061\u0073\u0063\u0069\u0069 \u0068\u0065\u0078\u0020\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072 \u0028\u0025\u0063\u0029",_bcfa );return nil ,_ff .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0061\u0073\u0063\u0069\u0069\u0020\u0068e\u0078 \u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u0020\u0028\u0025\u0063\u0029",_bcfa );};};if len (_ggefd )%2==1{_ggefd =append (_ggefd ,'0');};_beg .Log .Trace ("\u0049\u006e\u0062\u006f\u0075\u006e\u0064\u0020\u0025\u0073",_ggefd );_bbcg :=make ([]byte ,_cd .DecodedLen (len (_ggefd )));_ ,_cede :=_cd .Decode (_bbcg ,_ggefd );if _cede !=nil {return nil ,_cede ;};return _bbcg ,nil ;};

// ToIntegerArray returns a slice of all array elements as an int slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_dbgg *PdfObjectArray )ToIntegerArray ()([]int ,error ){var _fgaga []int ;for _ ,_bebc :=range _dbgg .Elements (){if _bfgae ,_gedgb :=_bebc .(*PdfObjectInteger );_gedgb {_fgaga =append (_fgaga ,int (*_bfgae ));}else {return nil ,ErrTypeError ;};};return _fgaga ,nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_fbad *RunLengthEncoder )UpdateParams (params *PdfObjectDictionary ){};

// EncodeBytes ASCII encodes the passed in slice of bytes.
func (_bdgd *ASCIIHexEncoder )EncodeBytes (data []byte )([]byte ,error ){var _affee _gec .Buffer ;for _ ,_cedf :=range data {_affee .WriteString (_ff .Sprintf ("\u0025\u002e\u0032X\u0020",_cedf ));};_affee .WriteByte ('>');return _affee .Bytes (),nil ;};

// DecodeStream decodes a JPX encoded stream and returns the result as a
// slice of bytes.
func (_bbcge *JPXEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_beg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_bbcge .GetFilterName ());return streamObj .Stream ,ErrNoJPXDecode ;};

// Set sets the PdfObject at index i of the array. An error is returned if the index is outside bounds.
func (_edab *PdfObjectArray )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_edab ._fbcce ){return _e .New ("\u006f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_edab ._fbcce [i ]=obj ;return nil ;};

// GetParser returns the parser for lazy-loading or compare references.
func (_edfbb *PdfObjectReference )GetParser ()*PdfParser {return _edfbb ._cabd };

// GetObjectStreams returns the *PdfObjectStreams represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetObjectStreams (obj PdfObject )(_gdgaf *PdfObjectStreams ,_fafe bool ){_gdgaf ,_fafe =obj .(*PdfObjectStreams );return _gdgaf ,_fafe ;};

// MakeBool creates a PdfObjectBool from a bool value.
func MakeBool (val bool )*PdfObjectBool {_bcea :=PdfObjectBool (val );return &_bcea };var _egfg =_ef .MustCompile ("\u005e\\\u0073\u002a\u005b\u002d]\u002a\u0028\u005c\u0064\u002b)\u005cs\u002b(\u005c\u0064\u002b\u0029\u005c\u0073\u002bR");type encryptDict struct{Filter string ;V int ;SubFilter string ;Length int ;StmF string ;StrF string ;EFF string ;CF map[string ]_ag .FilterDict ;};

// DecodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_cdba *RawEncoder )DecodeBytes (encoded []byte )([]byte ,error ){return encoded ,nil };

// EqualObjects returns true if `obj1` and `obj2` have the same contents.
//
// NOTE: It is a good idea to flatten obj1 and obj2 with FlattenObject before calling this function
// so that contents, rather than references, can be compared.
func EqualObjects (obj1 ,obj2 PdfObject )bool {return _abcea (obj1 ,obj2 ,0)};

// WriteString outputs the object as it is to be written to file.
func (_eebg *PdfObjectName )WriteString ()string {var _beab _gec .Buffer ;if len (*_eebg )> 127{_beg .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u004e\u0061\u006d\u0065\u0020t\u006fo\u0020l\u006f\u006e\u0067\u0020\u0028\u0025\u0073)",*_eebg );};_beab .WriteString ("\u002f");for _fegg :=0;_fegg < len (*_eebg );_fegg ++{_bfga :=(*_eebg )[_fegg ];if !IsPrintable (_bfga )||_bfga =='#'||IsDelimiter (_bfga ){_beab .WriteString (_ff .Sprintf ("\u0023\u0025\u002e2\u0078",_bfga ));}else {_beab .WriteByte (_bfga );};};return _beab .String ();};

// WriteString outputs the object as it is to be written to file.
func (_aaedd *PdfObjectStream )WriteString ()string {var _bebde _d .Builder ;_bebde .WriteString (_b .FormatInt (_aaedd .ObjectNumber ,10));_bebde .WriteString ("\u0020\u0030\u0020\u0052");return _bebde .String ();};

// GetObjectNums returns a sorted list of object numbers of the PDF objects in the file.
func (_acbb *PdfParser )GetObjectNums ()[]int {var _ebcd []int ;for _ ,_fdfb :=range _acbb ._bbda .ObjectMap {_ebcd =append (_ebcd ,_fdfb .ObjectNumber );};_g .Ints (_ebcd );return _ebcd ;};

// MakeNull creates an PdfObjectNull.
func MakeNull ()*PdfObjectNull {_eeag :=PdfObjectNull {};return &_eeag };

// GetFloat returns the *PdfObjectFloat represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetFloat (obj PdfObject )(_cebfg *PdfObjectFloat ,_bbaef bool ){_cebfg ,_bbaef =TraceToDirectObject (obj ).(*PdfObjectFloat );return _cebfg ,_bbaef ;};

// String returns a string describing `ref`.
func (_ccfg *PdfObjectReference )String ()string {return _ff .Sprintf ("\u0052\u0065\u0066\u0028\u0025\u0064\u0020\u0025\u0064\u0029",_ccfg .ObjectNumber ,_ccfg .GenerationNumber );};

// String returns a string representation of the *PdfObjectString.
func (_dgb *PdfObjectString )String ()string {return _dgb ._aabg };

// GetBoolVal returns the bool value within a *PdObjectBool represented by an PdfObject interface directly or indirectly.
// If the PdfObject does not represent a bool value, a default value of false is returned (found = false also).
func GetBoolVal (obj PdfObject )(_eagc bool ,_eagf bool ){_fcgag ,_eagf :=TraceToDirectObject (obj ).(*PdfObjectBool );if _eagf {return bool (*_fcgag ),true ;};return false ,false ;};func _ggb (_fbfeb _cg .ReadSeeker ,_ggag int64 )(*offsetReader ,error ){_aaae :=&offsetReader {_bbbd :_fbfeb ,_debe :_ggag };_ ,_ddgd :=_aaae .Seek (0,_cg .SeekStart );return _aaae ,_ddgd ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_gfcb *RawEncoder )MakeDecodeParams ()PdfObject {return nil };

// ResolveReferencesDeep recursively traverses through object `o`, looking up and replacing
// references with indirect objects.
// Optionally a map of already deep-resolved objects can be provided via `traversed`. The `traversed` map
// is updated while traversing the objects to avoid traversing same objects multiple times.
func ResolveReferencesDeep (o PdfObject ,traversed map[PdfObject ]struct{})error {if traversed ==nil {traversed =map[PdfObject ]struct{}{};};return _efae (o ,0,traversed );};

// GetFilterName returns the names of the underlying encoding filters,
// separated by spaces.
// Note: This is just a string, should not be used in /Filter dictionary entry. Use GetFilterArray for that.
// TODO(v4): Refactor to GetFilter() which can be used for /Filter (either Name or Array), this can be
//  renamed to String() as a pretty string to use in debugging etc.
func (_edff *MultiEncoder )GetFilterName ()string {_eegg :="";for _cgaaa ,_agee :=range _edff ._ccc {_eegg +=_agee .GetFilterName ();if _cgaaa < len (_edff ._ccc )-1{_eegg +="\u0020";};};return _eegg ;};func _fdf (_cegc *PdfObjectStream ,_bdba *PdfObjectDictionary )(*CCITTFaxEncoder ,error ){_bceb :=NewCCITTFaxEncoder ();_dagb :=_cegc .PdfObjectDictionary ;if _dagb ==nil {return _bceb ,nil ;};if _bdba ==nil {_ece :=TraceToDirectObject (_dagb .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));if _ece !=nil {switch _cfbga :=_ece .(type ){case *PdfObjectDictionary :_bdba =_cfbga ;break ;case *PdfObjectArray :if _cfbga .Len ()==1{if _cdfe ,_dgeg :=GetDict (_cfbga .Get (0));_dgeg {_bdba =_cdfe ;};};default:_beg .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_ece );return nil ,_e .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _bdba ==nil {_beg .Log .Error ("\u0044\u0065c\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064 %\u0023\u0076",_ece );return nil ,_e .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _gaea ,_abg :=GetNumberAsInt64 (_bdba .Get ("\u004b"));_abg ==nil {_bceb .K =int (_gaea );};if _fgdfb ,_gaa :=GetNumberAsInt64 (_bdba .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));_gaa ==nil {_bceb .Columns =int (_fgdfb );}else {_bceb .Columns =1728;};if _addf ,_gga :=GetNumberAsInt64 (_bdba .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_gga ==nil {_bceb .BlackIs1 =_addf > 0;}else {if _cfec ,_ffdg :=GetBoolVal (_bdba .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_ffdg {_bceb .BlackIs1 =_cfec ;}else {if _defe ,_bagg :=GetArray (_bdba .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));_bagg {_bbae ,_gdbgf :=_defe .ToIntegerArray ();if _gdbgf ==nil {_bceb .BlackIs1 =_bbae [0]==1&&_bbae [1]==0;};};};};if _cfg ,_ebcb :=GetNumberAsInt64 (_bdba .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_ebcb ==nil {_bceb .EncodedByteAlign =_cfg > 0;}else {if _ecfc ,_abed :=GetBoolVal (_bdba .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_abed {_bceb .EncodedByteAlign =_ecfc ;};};if _fdfc ,_cfcb :=GetNumberAsInt64 (_bdba .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_cfcb ==nil {_bceb .EndOfLine =_fdfc > 0;}else {if _cedd ,_efc :=GetBoolVal (_bdba .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_efc {_bceb .EndOfLine =_cedd ;};};if _fcga ,_abfe :=GetNumberAsInt64 (_bdba .Get ("\u0052\u006f\u0077\u0073"));_abfe ==nil {_bceb .Rows =int (_fcga );};_bceb .EndOfBlock =true ;if _fbgb ,_egfeb :=GetNumberAsInt64 (_bdba .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_egfeb ==nil {_bceb .EndOfBlock =_fbgb > 0;}else {if _bbgg ,_ecef :=GetBoolVal (_bdba .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_ecef {_bceb .EndOfBlock =_bbgg ;};};if _gddg ,_fged :=GetNumberAsInt64 (_bdba .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));_fged !=nil {_bceb .DamagedRowsBeforeError =int (_gddg );};_beg .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_bdba .String ());return _bceb ,nil ;};

// WriteString outputs the object as it is to be written to file.
func (_agafc *PdfObjectInteger )WriteString ()string {return _b .FormatInt (int64 (*_agafc ),10)};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_fcee *JPXEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};

// GetFilterArray returns the names of the underlying encoding filters in an array that
// can be used as /Filter entry.
func (_bcccb *MultiEncoder )GetFilterArray ()*PdfObjectArray {_cefbf :=make ([]PdfObject ,len (_bcccb ._ccc ));for _dgge ,_gfaf :=range _bcccb ._ccc {_cefbf [_dgge ]=MakeName (_gfaf .GetFilterName ());};return MakeArray (_cefbf ...);};

// ParseDict reads and parses a PDF dictionary object enclosed with '<<' and '>>'
func (_daec *PdfParser )ParseDict ()(*PdfObjectDictionary ,error ){_beg .Log .Trace ("\u0052\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020D\u0069\u0063\u0074\u0021");_aeeg :=MakeDict ();_aeeg ._effde =_daec ;_bbeea ,_ :=_daec ._cdff .ReadByte ();if _bbeea !='<'{return nil ,_e .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");};_bbeea ,_ =_daec ._cdff .ReadByte ();if _bbeea !='<'{return nil ,_e .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");};for {_daec .skipSpaces ();_daec .skipComments ();_cdde ,_gdce :=_daec ._cdff .Peek (2);if _gdce !=nil {return nil ,_gdce ;};_beg .Log .Trace ("D\u0069c\u0074\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_cdde ),string (_cdde ));if (_cdde [0]=='>')&&(_cdde [1]=='>'){_beg .Log .Trace ("\u0045\u004f\u0046\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");_daec ._cdff .ReadByte ();_daec ._cdff .ReadByte ();break ;};_beg .Log .Trace ("\u0050a\u0072s\u0065\u0020\u0074\u0068\u0065\u0020\u006e\u0061\u006d\u0065\u0021");_aabc ,_gdce :=_daec .parseName ();_beg .Log .Trace ("\u004be\u0079\u003a\u0020\u0025\u0073",_aabc );if _gdce !=nil {_beg .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0052e\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006ea\u006d\u0065\u0020e\u0072r\u0020\u0025\u0073",_gdce );return nil ,_gdce ;};if len (_aabc )> 4&&_aabc [len (_aabc )-4:]=="\u006e\u0075\u006c\u006c"{_fbef :=_aabc [0:len (_aabc )-4];_beg .Log .Debug ("\u0054\u0061\u006b\u0069n\u0067\u0020\u0063\u0061\u0072\u0065\u0020\u006f\u0066\u0020n\u0075l\u006c\u0020\u0062\u0075\u0067\u0020\u0028%\u0073\u0029",_aabc );_beg .Log .Debug ("\u004e\u0065\u0077\u0020ke\u0079\u0020\u0022\u0025\u0073\u0022\u0020\u003d\u0020\u006e\u0075\u006c\u006c",_fbef );_daec .skipSpaces ();_bcfae ,_ :=_daec ._cdff .Peek (1);if _bcfae [0]=='/'{_aeeg .Set (_fbef ,MakeNull ());continue ;};};_daec .skipSpaces ();_abge ,_gdce :=_daec .parseObject ();if _gdce !=nil {return nil ,_gdce ;};_aeeg .Set (_aabc ,_abge );if _beg .Log .IsLogLevel (_beg .LogLevelTrace ){_beg .Log .Trace ("\u0064\u0069\u0063\u0074\u005b\u0025\u0073\u005d\u0020\u003d\u0020\u0025\u0073",_aabc ,_abge .String ());};};_beg .Log .Trace ("\u0072\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020\u0044\u0069\u0063\u0074\u0021");return _aeeg ,nil ;};

// PdfObjectBool represents the primitive PDF boolean object.
type PdfObjectBool bool ;

// ToFloat64Array returns a slice of all elements in the array as a float64 slice.  An error is
// returned if the array contains non-numeric objects (each element can be either PdfObjectInteger
// or PdfObjectFloat).
func (_edgf *PdfObjectArray )ToFloat64Array ()([]float64 ,error ){var _edbd []float64 ;for _ ,_egag :=range _edgf .Elements (){switch _gffb :=_egag .(type ){case *PdfObjectInteger :_edbd =append (_edbd ,float64 (*_gffb ));case *PdfObjectFloat :_edbd =append (_edbd ,float64 (*_gffb ));default:return nil ,ErrTypeError ;};};return _edbd ,nil ;};func _fbce (_geaf *PdfObjectStream )(*MultiEncoder ,error ){_adaf :=NewMultiEncoder ();_bcaa :=_geaf .PdfObjectDictionary ;if _bcaa ==nil {return _adaf ,nil ;};var _efcf *PdfObjectDictionary ;var _bccf []PdfObject ;_cgac :=_bcaa .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _cgac !=nil {_daae ,_gbb :=_cgac .(*PdfObjectDictionary );if _gbb {_efcf =_daae ;};_dead ,_dacgb :=_cgac .(*PdfObjectArray );if _dacgb {for _ ,_eebe :=range _dead .Elements (){_eebe =TraceToDirectObject (_eebe );if _aef ,_dbfa :=_eebe .(*PdfObjectDictionary );_dbfa {_bccf =append (_bccf ,_aef );}else {_bccf =append (_bccf ,MakeDict ());};};};};_cgac =_bcaa .Get ("\u0046\u0069\u006c\u0074\u0065\u0072");if _cgac ==nil {return nil ,_ff .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u006d\u0069s\u0073\u0069\u006e\u0067");};_aadeb ,_daccd :=_cgac .(*PdfObjectArray );if !_daccd {return nil ,_ff .Errorf ("m\u0075\u006c\u0074\u0069\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0063\u0061\u006e\u0020\u006f\u006el\u0079\u0020\u0062\u0065\u0020\u006d\u0061\u0064\u0065\u0020fr\u006f\u006d\u0020a\u0072r\u0061\u0079");};for _cdbb ,_bdcg :=range _aadeb .Elements (){_edgd ,_bagbd :=_bdcg .(*PdfObjectName );if !_bagbd {return nil ,_ff .Errorf ("\u006d\u0075l\u0074\u0069\u0020\u0066i\u006c\u0074e\u0072\u0020\u0061\u0072\u0072\u0061\u0079\u0020e\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u006e\u006f\u0074\u0020\u0061 \u006e\u0061\u006d\u0065");};var _agde PdfObject ;if _efcf !=nil {_agde =_efcf ;}else {if len (_bccf )> 0{if _cdbb >=len (_bccf ){return nil ,_ff .Errorf ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0073\u0020\u0069\u006e\u0020d\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006d\u0073\u0020a\u0072\u0072\u0061\u0079");};_agde =_bccf [_cdbb ];};};var _addcf *PdfObjectDictionary ;if _aaeg ,_cegcg :=_agde .(*PdfObjectDictionary );_cegcg {_addcf =_aaeg ;};_beg .Log .Trace ("\u004e\u0065\u0078t \u006e\u0061\u006d\u0065\u003a\u0020\u0025\u0073\u002c \u0064p\u003a \u0025v\u002c\u0020\u0064\u0050\u0061\u0072\u0061\u006d\u0073\u003a\u0020\u0025\u0076",*_edgd ,_agde ,_addcf );if *_edgd ==StreamEncodingFilterNameFlate {_dace ,_abde :=_faa (_geaf ,_addcf );if _abde !=nil {return nil ,_abde ;};_adaf .AddEncoder (_dace );}else if *_edgd ==StreamEncodingFilterNameLZW {_begc ,_dfdf :=_fffb (_geaf ,_addcf );if _dfdf !=nil {return nil ,_dfdf ;};_adaf .AddEncoder (_begc );}else if *_edgd ==StreamEncodingFilterNameASCIIHex {_ggecf :=NewASCIIHexEncoder ();_adaf .AddEncoder (_ggecf );}else if *_edgd ==StreamEncodingFilterNameASCII85 {_aab :=NewASCII85Encoder ();_adaf .AddEncoder (_aab );}else if *_edgd ==StreamEncodingFilterNameDCT {_cfac ,_cgcb :=_cea (_geaf ,_adaf );if _cgcb !=nil {return nil ,_cgcb ;};_adaf .AddEncoder (_cfac );_beg .Log .Trace ("A\u0064d\u0065\u0064\u0020\u0044\u0043\u0054\u0020\u0065n\u0063\u006f\u0064\u0065r.\u002e\u002e");_beg .Log .Trace ("\u004du\u006ct\u0069\u0020\u0065\u006e\u0063o\u0064\u0065r\u003a\u0020\u0025\u0023\u0076",_adaf );}else {_beg .Log .Error ("U\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0066\u0069l\u0074\u0065\u0072\u0020\u0025\u0073",*_edgd );return nil ,_ff .Errorf ("\u0069\u006eva\u006c\u0069\u0064 \u0066\u0069\u006c\u0074er \u0069n \u006d\u0075\u006c\u0074\u0069\u0020\u0066il\u0074\u0065\u0072\u0020\u0061\u0072\u0072a\u0079");};};return _adaf ,nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_abee *ASCIIHexEncoder )UpdateParams (params *PdfObjectDictionary ){};

// IsWhiteSpace checks if byte represents a white space character.
func IsWhiteSpace (ch byte )bool {if (ch ==0x00)||(ch ==0x09)||(ch ==0x0A)||(ch ==0x0C)||(ch ==0x0D)||(ch ==0x20){return true ;};return false ;};

// Inspect analyzes the document object structure. Returns a map of object types (by name) with the instance count
// as value.
func (_deae *PdfParser )Inspect ()(map[string ]int ,error ){return _deae .inspect ()};

// IsOctalDigit checks if a character can be part of an octal digit string.
func IsOctalDigit (c byte )bool {return '0'<=c &&c <='7'};

// String returns a string describing `null`.
func (_gcbe *PdfObjectNull )String ()string {return "\u006e\u0075\u006c\u006c"};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_dbbc *FlateEncoder )MakeStreamDict ()*PdfObjectDictionary {_cdb :=MakeDict ();_cdb .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_dbbc .GetFilterName ()));_dfd :=_dbbc .MakeDecodeParams ();if _dfd !=nil {_cdb .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_dfd );};return _cdb ;};

// DecodeStream decodes the stream containing CCITTFax encoded image data.
func (_edd *CCITTFaxEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _edd .DecodeBytes (streamObj .Stream );};

// DecodeBytes decodes a byte slice from Run length encoding.
//
// 7.4.5 RunLengthDecode Filter
// The RunLengthDecode filter decodes data that has been encoded in a simple byte-oriented format based on run length.
// The encoded data shall be a sequence of runs, where each run shall consist of a length byte followed by 1 to 128
// bytes of data. If the length byte is in the range 0 to 127, the following length + 1 (1 to 128) bytes shall be
// copied literally during decompression. If length is in the range 129 to 255, the following single byte shall be
// copied 257 - length (2 to 128) times during decompression. A length value of 128 shall denote EOD.
func (_bbb *RunLengthEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_fdg :=_gec .NewReader (encoded );var _bfdee []byte ;for {_adfc ,_eaca :=_fdg .ReadByte ();if _eaca !=nil {return nil ,_eaca ;};if _adfc > 128{_ceaa ,_cdbg :=_fdg .ReadByte ();if _cdbg !=nil {return nil ,_cdbg ;};for _ggf :=0;_ggf < 257-int (_adfc );_ggf ++{_bfdee =append (_bfdee ,_ceaa );};}else if _adfc < 128{for _egge :=0;_egge < int (_adfc )+1;_egge ++{_aea ,_cebf :=_fdg .ReadByte ();if _cebf !=nil {return nil ,_cebf ;};_bfdee =append (_bfdee ,_aea );};}else {break ;};};return _bfdee ,nil ;};

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_ade *FlateEncoder )EncodeBytes (data []byte )([]byte ,error ){if _ade .Predictor !=1&&_ade .Predictor !=11{_beg .Log .Debug ("E\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0046\u006c\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065r\u0020P\u0072\u0065\u0064\u0069c\u0074\u006fr\u0020\u003d\u0020\u0031\u002c\u0020\u0031\u0031\u0020\u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");return nil ,ErrUnsupportedEncodingParameters ;};if _ade .Predictor ==11{_bbd :=int (_ade .Columns );_egeg :=len (data )/_bbd ;if len (data )%_bbd !=0{_beg .Log .Error ("\u0049n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");return nil ,_e .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");};_ffeb :=_gec .NewBuffer (nil );_eee :=make ([]byte ,_bbd );for _bcd :=0;_bcd < _egeg ;_bcd ++{_fccb :=data [_bbd *_bcd :_bbd *(_bcd +1)];_eee [0]=_fccb [0];for _ggg :=1;_ggg < _bbd ;_ggg ++{_eee [_ggg ]=byte (int (_fccb [_ggg ]-_fccb [_ggg -1])%256);};_ffeb .WriteByte (1);_ffeb .Write (_eee );};data =_ffeb .Bytes ();};var _dcafd _gec .Buffer ;_cde :=_be .NewWriter (&_dcafd );_cde .Write (data );_cde .Close ();return _dcafd .Bytes (),nil ;};

// NewASCIIHexEncoder makes a new ASCII hex encoder.
func NewASCIIHexEncoder ()*ASCIIHexEncoder {_bccg :=&ASCIIHexEncoder {};return _bccg };func (_aagc *PdfParser )parseNumber ()(PdfObject ,error ){return ParseNumber (_aagc ._cdff )};

// WriteString outputs the object as it is to be written to file.
func (_dgdfa *PdfObjectBool )WriteString ()string {if *_dgdfa {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};

// String returns a string describing `streams`.
func (_cdga *PdfObjectStreams )String ()string {return _ff .Sprintf ("\u004f\u0062j\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0025\u0064",_cdga .ObjectNumber );};func (_gfcdfe *JBIG2Encoder )encodeImage (_cgcd _ga .Image )([]byte ,error ){const _bcb ="e\u006e\u0063\u006f\u0064\u0065\u0049\u006d\u0061\u0067\u0065";_gbcb ,_ggggd :=GoImageToJBIG2 (_cgcd ,JB2ImageAutoThreshold );if _ggggd !=nil {return nil ,_aa .Wrap (_ggggd ,_bcb ,"\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069m\u0061g\u0065\u0020\u0074\u006f\u0020\u006a\u0062\u0069\u0067\u0032\u0020\u0069\u006d\u0067");};if _ggggd =_gfcdfe .AddPageImage (_gbcb ,&_gfcdfe .DefaultPageSettings );_ggggd !=nil {return nil ,_aa .Wrap (_ggggd ,_bcb ,"");};return _gfcdfe .Encode ();};

// MakeDecodeParams makes a new instance of an encoding dictionary based on the current encoder settings.
func (_cgb *JBIG2Encoder )MakeDecodeParams ()PdfObject {return MakeDict ()};const (StreamEncodingFilterNameFlate ="F\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameLZW ="\u004cZ\u0057\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameDCT ="\u0044C\u0054\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameRunLength ="\u0052u\u006eL\u0065\u006e\u0067\u0074\u0068\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameASCIIHex ="\u0041\u0053\u0043\u0049\u0049\u0048\u0065\u0078\u0044e\u0063\u006f\u0064\u0065";StreamEncodingFilterNameASCII85 ="\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameCCITTFax ="\u0043\u0043\u0049\u0054\u0054\u0046\u0061\u0078\u0044e\u0063\u006f\u0064\u0065";StreamEncodingFilterNameJBIG2 ="J\u0042\u0049\u0047\u0032\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameJPX ="\u004aP\u0058\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameRaw ="\u0052\u0061\u0077";);

// RunLengthEncoder represents Run length encoding.
type RunLengthEncoder struct{};var _aagf =_ef .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064+\u0029\u005c\u0073\u002b\u0028\u005b\u006e\u0066\u005d\u0029\\\u0073\u002a\u0024");func _daaa (_cafgg string )(PdfObjectReference ,error ){_cdcg :=PdfObjectReference {};_caeddg :=_egfg .FindStringSubmatch (string (_cafgg ));if len (_caeddg )< 3{_beg .Log .Debug ("\u0045\u0072\u0072or\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");return _cdcg ,_e .New ("\u0075n\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061r\u0073e\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");};_gacf ,_ :=_b .Atoi (_caeddg [1]);_cfcgd ,_ :=_b .Atoi (_caeddg [2]);_cdcg .ObjectNumber =int64 (_gacf );_cdcg .GenerationNumber =int64 (_cfcgd );return _cdcg ,nil ;};

// EncodeBytes JPX encodes the passed in slice of bytes.
func (_fbdb *JPXEncoder )EncodeBytes (data []byte )([]byte ,error ){_beg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_fbdb .GetFilterName ());return data ,ErrNoJPXDecode ;};

// GetFilterName returns the name of the encoding filter.
func (_cbc *DCTEncoder )GetFilterName ()string {return StreamEncodingFilterNameDCT };func (_bdg *PdfCrypt )generateParams (_fac ,_bgd []byte )error {_cec :=_bdg .securityHandler ();_cfbc ,_dge :=_cec .GenerateParams (&_bdg ._aba ,_bgd ,_fac );if _dge !=nil {return _dge ;};_bdg ._baa =_cfbc ;return nil ;};

// NewRunLengthEncoder makes a new run length encoder
func NewRunLengthEncoder ()*RunLengthEncoder {return &RunLengthEncoder {}};func (_cada *PdfCrypt )isEncrypted (_fab PdfObject )bool {_ ,_efad :=_cada ._afc [_fab ];if _efad {_beg .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0065\u006e\u0063\u0072y\u0070\u0074\u0065\u0064");return true ;};_beg .Log .Trace ("\u004e\u006f\u0074\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");return false ;};var _abdg =[]PdfObjectName {"\u0056","\u0052","\u004f","\u0055","\u0050"};

// DecodeBytes decodes the CCITTFax encoded image data.
func (_bffab *CCITTFaxEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_bcfg :=&_ab .Encoder {K :_bffab .K ,Columns :_bffab .Columns ,EndOfLine :_bffab .EndOfLine ,EndOfBlock :_bffab .EndOfBlock ,BlackIs1 :_bffab .BlackIs1 ,DamagedRowsBeforeError :_bffab .DamagedRowsBeforeError ,Rows :_bffab .Rows ,EncodedByteAlign :_bffab .EncodedByteAlign };_dcbda ,_aacd :=_bcfg .Decode (encoded );if _aacd !=nil {return nil ,_aacd ;};var _dbffc []byte ;_aacg :=0;var _addc byte ;var _adeb byte ;for _edfg :=range _dcbda {if _addc !=0{_dbffc =append (_dbffc ,_adeb );_adeb =0;_aacg ++;_addc =0;};for _ggec :=range _dcbda [_edfg ]{_adeb |=_dcbda [_edfg ][_ggec ]<<(7-_addc );_addc ++;if _addc ==8{_dbffc =append (_dbffc ,_adeb );_adeb =0;_aacg ++;_addc =0;};};};if _addc > 0{_dbffc =append (_dbffc ,_adeb );};return _dbffc ,nil ;};

// Decrypt attempts to decrypt the PDF file with a specified password.  Also tries to
// decrypt with an empty password.  Returns true if successful, false otherwise.
// An error is returned when there is a problem with decrypting.
func (_cbga *PdfParser )Decrypt (password []byte )(bool ,error ){if _cbga ._ccddd ==nil {return false ,_e .New ("\u0063\u0068\u0065\u0063k \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u0069\u0072s\u0074");};_deec ,_egcbc :=_cbga ._ccddd .authenticate (password );if _egcbc !=nil {return false ,_egcbc ;};if !_deec {_deec ,_egcbc =_cbga ._ccddd .authenticate ([]byte (""));};return _deec ,_egcbc ;};

// CCITTFaxEncoder implements Group3 and Group4 facsimile (fax) encoder/decoder.
type CCITTFaxEncoder struct{K int ;EndOfLine bool ;EncodedByteAlign bool ;Columns int ;Rows int ;EndOfBlock bool ;BlackIs1 bool ;DamagedRowsBeforeError int ;};func _efeg (_fgbb ,_cggga ,_cbda int )error {if _cggga < 0||_cggga > _fgbb {return _e .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0061\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");};if _cbda < _cggga {return _e .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0073\u006c\u0069\u0063e\u0020i\u006ed\u0065\u0078\u0020\u0062\u0020\u003c\u0020a");};if _cbda > _fgbb {return _e .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0062\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");};return nil ;};

// GetNameVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetNameVal (obj PdfObject )(_facc string ,_gcfdb bool ){_dfbd ,_gcfdb :=TraceToDirectObject (obj ).(*PdfObjectName );if _gcfdb {return string (*_dfbd ),true ;};return ;};

// String returns a descriptive information string about the encryption method used.
func (_ebd *PdfCrypt )String ()string {if _ebd ==nil {return "";};_dcbb :=_ebd ._geb .Filter +"\u0020\u002d\u0020";if _ebd ._geb .V ==0{_dcbb +="\u0055\u006e\u0064\u006fcu\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0061\u006c\u0067\u006f\u0072\u0069\u0074h\u006d";}else if _ebd ._geb .V ==1{_dcbb +="\u0052\u0043\u0034:\u0020\u0034\u0030\u0020\u0062\u0069\u0074\u0073";}else if _ebd ._geb .V ==2{_dcbb +=_ff .Sprintf ("\u0052\u0043\u0034:\u0020\u0025\u0064\u0020\u0062\u0069\u0074\u0073",_ebd ._geb .Length );}else if _ebd ._geb .V ==3{_dcbb +="U\u006e\u0070\u0075\u0062li\u0073h\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d";}else if _ebd ._geb .V >=4{_dcbb +=_ff .Sprintf ("\u0053\u0074r\u0065\u0061\u006d\u0020f\u0069\u006ct\u0065\u0072\u003a\u0020\u0025\u0073\u0020\u002d \u0053\u0074\u0072\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0074\u0065r\u003a\u0020\u0025\u0073",_ebd ._dae ,_ebd ._fde );_dcbb +="\u003b\u0020C\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0073\u003a";for _ffbg ,_ffd :=range _ebd ._dbf {_dcbb +=_ff .Sprintf ("\u0020\u002d\u0020\u0025\u0073\u003a\u0020\u0025\u0073 \u0028\u0025\u0064\u0029",_ffbg ,_ffd .Name (),_ffd .KeyLength ());};};_bd :=_ebd .GetAccessPermissions ();_dcbb +=_ff .Sprintf ("\u0020\u002d\u0020\u0025\u0023\u0076",_bd );return _dcbb ;};

// NewEncoderFromStream creates a StreamEncoder based on the stream's dictionary.
func NewEncoderFromStream (streamObj *PdfObjectStream )(StreamEncoder ,error ){_dfef :=TraceToDirectObject (streamObj .PdfObjectDictionary .Get ("\u0046\u0069\u006c\u0074\u0065\u0072"));if _dfef ==nil {return NewRawEncoder (),nil ;};if _ ,_bbgf :=_dfef .(*PdfObjectNull );_bbgf {return NewRawEncoder (),nil ;};_bgba ,_bgce :=_dfef .(*PdfObjectName );if !_bgce {_febd ,_gbcf :=_dfef .(*PdfObjectArray );if !_gbcf {return nil ,_ff .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006f\u0072 \u0041\u0072\u0072\u0061\u0079\u0020\u006fb\u006a\u0065\u0063\u0074");};if _febd .Len ()==0{return NewRawEncoder (),nil ;};if _febd .Len ()!=1{_ccccf ,_gfcdc :=_fbce (streamObj );if _gfcdc !=nil {_beg .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0063\u0072\u0065\u0061\u0074\u0069\u006e\u0067\u0020\u006d\u0075\u006c\u0074i\u0020\u0065\u006e\u0063\u006f\u0064\u0065r\u003a\u0020\u0025\u0076",_gfcdc );return nil ,_gfcdc ;};_beg .Log .Trace ("\u004d\u0075\u006c\u0074\u0069\u0020\u0065\u006e\u0063:\u0020\u0025\u0073\u000a",_ccccf );return _ccccf ,nil ;};_dfef =_febd .Get (0);_bgba ,_gbcf =_dfef .(*PdfObjectName );if !_gbcf {return nil ,_ff .Errorf ("\u0066\u0069l\u0074\u0065\u0072\u0020a\u0072\u0072a\u0079\u0020\u006d\u0065\u006d\u0062\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006fb\u006a\u0065\u0063\u0074");};};switch *_bgba {case StreamEncodingFilterNameFlate :return _faa (streamObj ,nil );case StreamEncodingFilterNameLZW :return _fffb (streamObj ,nil );case StreamEncodingFilterNameDCT :return _cea (streamObj ,nil );case StreamEncodingFilterNameRunLength :return _cbg (streamObj ,nil );case StreamEncodingFilterNameASCIIHex :return NewASCIIHexEncoder (),nil ;case StreamEncodingFilterNameASCII85 ,"\u0041\u0038\u0035":return NewASCII85Encoder (),nil ;case StreamEncodingFilterNameCCITTFax :return _fdf (streamObj ,nil );case StreamEncodingFilterNameJBIG2 :return _gbbd (streamObj ,nil );case StreamEncodingFilterNameJPX :return NewJPXEncoder (),nil ;};_beg .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064\u0069\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006fd\u0021");return nil ,_ff .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064i\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006f\u0064\u0020\u0028\u0025\u0073\u0029",*_bgba );};func (_ccfc *PdfCrypt )encryptBytes (_ede []byte ,_gbc string ,_edg []byte )([]byte ,error ){_beg .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");_cdae ,_daa :=_ccfc ._dbf [_gbc ];if !_daa {return nil ,_ff .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_gbc );};return _cdae .EncryptBytes (_ede ,_edg );};

// FlateEncoder represents Flate encoding.
type FlateEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Rows int ;Colors int ;_fbbe *_da .ImageBase ;};

// EncodeImage encodes 'img' golang image.Image into jbig2 encoded bytes document using default encoder settings.
func (_gdc *JBIG2Encoder )EncodeImage (img _ga .Image )([]byte ,error ){return _gdc .encodeImage (img )};func _agfc (_bacg int )int {_ggaf :=_bacg >>(_gccf -1);return (_bacg ^_ggaf )-_ggaf };const (_ecf =0;_aegb =1;_bffef =2;_bce =3;_cef =4;);func (_bagc *PdfParser )repairLocateXref ()(int64 ,error ){_dffb :=int64 (1000);_bagc ._bdff .Seek (-_dffb ,_bf .SEEK_CUR );_ggecee ,_gdedb :=_bagc ._bdff .Seek (0,_bf .SEEK_CUR );if _gdedb !=nil {return 0,_gdedb ;};_egde :=make ([]byte ,_dffb );_bagc ._bdff .Read (_egde );_cedg :=_baae .FindAllStringIndex (string (_egde ),-1);if len (_cedg )< 1{_beg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0065\u0070a\u0069\u0072\u003a\u0020\u0078\u0072\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021");return 0,_e .New ("\u0072\u0065\u0070\u0061ir\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064");};_babe :=int64 (_cedg [len (_cedg )-1][0]);_fcac :=_ggecee +_babe ;return _fcac ,nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_bdgc *CCITTFaxEncoder )MakeDecodeParams ()PdfObject {_ddf :=MakeDict ();_ddf .Set ("\u004b",MakeInteger (int64 (_bdgc .K )));_ddf .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_bdgc .Columns )));if _bdgc .BlackIs1 {_ddf .Set ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031",MakeBool (_bdgc .BlackIs1 ));};if _bdgc .EncodedByteAlign {_ddf .Set ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e",MakeBool (_bdgc .EncodedByteAlign ));};if _bdgc .EndOfLine &&_bdgc .K >=0{_ddf .Set ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee",MakeBool (_bdgc .EndOfLine ));};if _bdgc .Rows !=0&&!_bdgc .EndOfBlock {_ddf .Set ("\u0052\u006f\u0077\u0073",MakeInteger (int64 (_bdgc .Rows )));};if !_bdgc .EndOfBlock {_ddf .Set ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b",MakeBool (_bdgc .EndOfBlock ));};if _bdgc .DamagedRowsBeforeError !=0{_ddf .Set ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072",MakeInteger (int64 (_bdgc .DamagedRowsBeforeError )));};return _ddf ;};func (_dgeb *PdfParser )traceStreamLength (_fdgg PdfObject )(PdfObject ,error ){_bfed ,_affge :=_fdgg .(*PdfObjectReference );if _affge {_ggdb ,_acca :=_dgeb ._ebae [_bfed .ObjectNumber ];if _acca &&_ggdb {_beg .Log .Debug ("\u0053t\u0072\u0065a\u006d\u0020\u004c\u0065n\u0067\u0074\u0068 \u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065 u\u006e\u0072\u0065s\u006f\u006cv\u0065\u0064\u0020\u0028\u0069\u006cl\u0065\u0067a\u006c\u0029");return nil ,_e .New ("\u0069\u006c\u006c\u0065ga\u006c\u0020\u0072\u0065\u0063\u0075\u0072\u0073\u0069\u0076\u0065\u0020\u006c\u006fo\u0070");};_dgeb ._ebae [_bfed .ObjectNumber ]=true ;};_ggde ,_ggdbd :=_dgeb .Resolve (_fdgg );if _ggdbd !=nil {return nil ,_ggdbd ;};_beg .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_ggde );if _affge {_dgeb ._ebae [_bfed .ObjectNumber ]=false ;};return _ggde ,nil ;};

// TraceToDirectObject traces a PdfObject to a direct object.  For example direct objects contained
// in indirect objects (can be double referenced even).
func TraceToDirectObject (obj PdfObject )PdfObject {if _cacbb ,_faca :=obj .(*PdfObjectReference );_faca {obj =_cacbb .Resolve ();};_ebda ,_abdc :=obj .(*PdfIndirectObject );_daddf :=0;for _abdc {obj =_ebda .PdfObject ;_ebda ,_abdc =GetIndirect (obj );_daddf ++;if _daddf > _gbab {_beg .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0072\u0061\u0063\u0065\u0020\u0064\u0065p\u0074\u0068\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u0062\u0065\u0079\u006fn\u0064\u0020\u0025\u0064\u0020\u002d\u0020\u006e\u006f\u0074\u0020\u0067oi\u006e\u0067\u0020\u0064\u0065\u0065\u0070\u0065\u0072\u0021",_gbab );return nil ;};};return obj ;};

// PdfCryptNewDecrypt makes the document crypt handler based on the encryption dictionary
// and trailer dictionary. Returns an error on failure to process.
func PdfCryptNewDecrypt (parser *PdfParser ,ed ,trailer *PdfObjectDictionary )(*PdfCrypt ,error ){_ebb :=&PdfCrypt {_agce :false ,_ggd :make (map[PdfObject ]bool ),_afc :make (map[PdfObject ]bool ),_bcc :make (map[int ]struct{}),_cbb :parser };_gcb ,_ecbf :=ed .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectName );if !_ecbf {_beg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0043\u0072\u0079\u0070\u0074 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061r\u0079 \u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u0066\u0069\u0065\u006c\u0064\u0021");return _ebb ,_e .New ("r\u0065\u0071\u0075\u0069\u0072\u0065d\u0020\u0063\u0072\u0079\u0070\u0074 \u0066\u0069\u0065\u006c\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u006d\u0069\u0073\u0073\u0069n\u0067");};if *_gcb !="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"{_beg .Log .Debug ("\u0045\u0052R\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020(%\u0073\u0029",*_gcb );return _ebb ,_e .New ("\u0075n\u0073u\u0070\u0070\u006f\u0072\u0074e\u0064\u0020F\u0069\u006c\u0074\u0065\u0072");};_ebb ._geb .Filter =string (*_gcb );if _deg ,_gfg :=ed .Get ("\u0053u\u0062\u0046\u0069\u006c\u0074\u0065r").(*PdfObjectString );_gfg {_ebb ._geb .SubFilter =_deg .Str ();_beg .Log .Debug ("\u0055s\u0069n\u0067\u0020\u0073\u0075\u0062f\u0069\u006ct\u0065\u0072\u0020\u0025\u0073",_deg );};if L ,_gfd :=ed .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );_gfd {if (*L %8)!=0{_beg .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0049\u006ev\u0061\u006c\u0069\u0064\u0020\u0065\u006ec\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006c\u0065\u006e\u0067\u0074\u0068");return _ebb ,_e .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0065\u006e\u0063\u0072y\u0070t\u0069o\u006e\u0020\u006c\u0065\u006e\u0067\u0074h");};_ebb ._geb .Length =int (*L );}else {_ebb ._geb .Length =40;};_ebb ._geb .V =0;if _gfgc ,_ccbe :=ed .Get ("\u0056").(*PdfObjectInteger );_ccbe {V :=int (*_gfgc );_ebb ._geb .V =V ;if V >=1&&V <=2{_ebb ._dbf =_bdc (_ebb ._geb .Length );}else if V >=4&&V <=5{if _cgc :=_ebb .loadCryptFilters (ed );_cgc !=nil {return _ebb ,_cgc ;};}else {_beg .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0061lg\u006f\u0020\u0056 \u003d \u0025\u0064",V );return _ebb ,_e .New ("u\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d");};};if _dfb :=_agf (&_ebb ._aba ,ed );_dfb !=nil {return _ebb ,_dfb ;};_aaa :="";if _egg ,_dfbb :=trailer .Get ("\u0049\u0044").(*PdfObjectArray );_dfbb &&_egg .Len ()>=1{_abaa ,_efab :=GetString (_egg .Get (0));if !_efab {return _ebb ,_e .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0074r\u0061\u0069l\u0065\u0072\u0020\u0049\u0044");};_aaa =_abaa .Str ();}else {_beg .Log .Debug ("\u0054\u0072ai\u006c\u0065\u0072 \u0049\u0044\u0020\u0061rra\u0079 m\u0069\u0073\u0073\u0069\u006e\u0067\u0020or\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0021");};_ebb ._eg =_aaa ;return _ebb ,nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_beef *ASCII85Encoder )MakeDecodeParams ()PdfObject {return nil };

// PdfObjectName represents the primitive PDF name object.
type PdfObjectName string ;

// EncodeJBIG2Image encodes 'img' into jbig2 encoded bytes stream, using default encoder settings.
func (_eaae *JBIG2Encoder )EncodeJBIG2Image (img *JBIG2Image )([]byte ,error ){const _ccfe ="c\u006f\u0072\u0065\u002eEn\u0063o\u0064\u0065\u004a\u0042\u0049G\u0032\u0049\u006d\u0061\u0067\u0065";if _dacfa :=_eaae .AddPageImage (img ,&_eaae .DefaultPageSettings );_dacfa !=nil {return nil ,_aa .Wrap (_dacfa ,_ccfe ,"");};return _eaae .Encode ();};

// String returns the state of the bool as "true" or "false".
func (_fbab *PdfObjectBool )String ()string {if *_fbab {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};const _gcd ="\u0053\u0074\u0064C\u0046";func (_aad *PdfCrypt )authenticate (_abb []byte )(bool ,error ){_aad ._agce =false ;_gaed :=_aad .securityHandler ();_cge ,_ebf ,_dgfg :=_gaed .Authenticate (&_aad ._aba ,_abb );if _dgfg !=nil {return false ,_dgfg ;}else if _ebf ==0||len (_cge )==0{return false ,nil ;};_aad ._agce =true ;_aad ._baa =_cge ;return true ,nil ;};func (_aed *PdfCrypt )saveCryptFilters (_gcc *PdfObjectDictionary )error {if _aed ._geb .V < 4{return _e .New ("\u0063\u0061\u006e\u0020\u006f\u006e\u006c\u0079\u0020\u0062\u0065 \u0075\u0073\u0065\u0064\u0020\u0077\u0069\u0074\u0068\u0020V\u003e\u003d\u0034");};_bab :=MakeDict ();_gcc .Set ("\u0043\u0046",_bab );for _dba ,_ecg :=range _aed ._dbf {if _dba =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{continue ;};_ebc :=_ccea (_ecg ,"");_bab .Set (PdfObjectName (_dba ),_ebc );};_gcc .Set ("\u0053\u0074\u0072\u0046",MakeName (_aed ._fde ));_gcc .Set ("\u0053\u0074\u006d\u0046",MakeName (_aed ._dae ));return nil ;};func (_egbd *PdfParser )readTextLine ()(string ,error ){var _edgg _gec .Buffer ;for {_baga ,_bccgd :=_egbd ._cdff .Peek (1);if _bccgd !=nil {_beg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_bccgd .Error ());return _edgg .String (),_bccgd ;};if (_baga [0]!='\r')&&(_baga [0]!='\n'){_cadd ,_ :=_egbd ._cdff .ReadByte ();_edgg .WriteByte (_cadd );}else {break ;};};return _edgg .String (),nil ;};

// Decoded returns the PDFDocEncoding or UTF-16BE decoded string contents.
// UTF-16BE is applied when the first two bytes are 0xFE, 0XFF, otherwise decoding of
// PDFDocEncoding is performed.
func (_gaeb *PdfObjectString )Decoded ()string {if _gaeb ==nil {return "";};_gcbge :=[]byte (_gaeb ._aabg );if len (_gcbge )>=2&&_gcbge [0]==0xFE&&_gcbge [1]==0xFF{return _cae .UTF16ToString (_gcbge [2:]);};return _cae .PDFDocEncodingToString (_gcbge );};type objectCache map[int ]PdfObject ;

// GetBool returns the *PdfObjectBool object that is represented by a PdfObject directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetBool (obj PdfObject )(_aafc *PdfObjectBool ,_bbeb bool ){_aafc ,_bbeb =TraceToDirectObject (obj ).(*PdfObjectBool );return _aafc ,_bbeb ;};

// WriteString outputs the object as it is to be written to file.
func (_dfgg *PdfObjectFloat )WriteString ()string {return _b .FormatFloat (float64 (*_dfgg ),'f',-1,64);};func (_fbcc *PdfCrypt )securityHandler ()_bca .StdHandler {if _fbcc ._aba .R >=5{return _bca .NewHandlerR6 ();};return _bca .NewHandlerR4 (_fbcc ._eg ,_fbcc ._geb .Length );};

// PdfObjectFloat represents the primitive PDF floating point numerical object.
type PdfObjectFloat float64 ;func (_gcbdd *PdfParser )parseString ()(*PdfObjectString ,error ){_gcbdd ._cdff .ReadByte ();var _aede _gec .Buffer ;_eaaf :=1;for {_feb ,_dcfeb :=_gcbdd ._cdff .Peek (1);if _dcfeb !=nil {return MakeString (_aede .String ()),_dcfeb ;};if _feb [0]=='\\'{_gcbdd ._cdff .ReadByte ();_cdcd ,_ggfa :=_gcbdd ._cdff .ReadByte ();if _ggfa !=nil {return MakeString (_aede .String ()),_ggfa ;};if IsOctalDigit (_cdcd ){_gfee ,_abce :=_gcbdd ._cdff .Peek (2);if _abce !=nil {return MakeString (_aede .String ()),_abce ;};var _aaebg []byte ;_aaebg =append (_aaebg ,_cdcd );for _ ,_gbeff :=range _gfee {if IsOctalDigit (_gbeff ){_aaebg =append (_aaebg ,_gbeff );}else {break ;};};_gcbdd ._cdff .Discard (len (_aaebg )-1);_beg .Log .Trace ("\u004e\u0075\u006d\u0065ri\u0063\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0022\u0025\u0073\u0022",_aaebg );_dacaa ,_abce :=_b .ParseUint (string (_aaebg ),8,32);if _abce !=nil {return MakeString (_aede .String ()),_abce ;};_aede .WriteByte (byte (_dacaa ));continue ;};switch _cdcd {case 'n':_aede .WriteRune ('\n');case 'r':_aede .WriteRune ('\r');case 't':_aede .WriteRune ('\t');case 'b':_aede .WriteRune ('\b');case 'f':_aede .WriteRune ('\f');case '(':_aede .WriteRune ('(');case ')':_aede .WriteRune (')');case '\\':_aede .WriteRune ('\\');};continue ;}else if _feb [0]=='('{_eaaf ++;}else if _feb [0]==')'{_eaaf --;if _eaaf ==0{_gcbdd ._cdff .ReadByte ();break ;};};_bgeb ,_ :=_gcbdd ._cdff .ReadByte ();_aede .WriteByte (_bgeb );};return MakeString (_aede .String ()),nil ;};

// ToInt64Slice returns a slice of all array elements as an int64 slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_bfdfe *PdfObjectArray )ToInt64Slice ()([]int64 ,error ){var _fdff []int64 ;for _ ,_aedec :=range _bfdfe .Elements (){if _dgea ,_facdg :=_aedec .(*PdfObjectInteger );_facdg {_fdff =append (_fdff ,int64 (*_dgea ));}else {return nil ,ErrTypeError ;};};return _fdff ,nil ;};

// String returns the PDF version as a string. Implements interface fmt.Stringer.
func (_bffd Version )String ()string {return _ff .Sprintf ("\u00250\u0064\u002e\u0025\u0030\u0064",_bffd .Major ,_bffd .Minor );};

// WriteString outputs the object as it is to be written to file.
func (_gbfc *PdfObjectArray )WriteString ()string {var _aaac _d .Builder ;_aaac .WriteString ("\u005b");for _bbca ,_bbeec :=range _gbfc .Elements (){_aaac .WriteString (_bbeec .WriteString ());if _bbca < (_gbfc .Len ()-1){_aaac .WriteString ("\u0020");};};_aaac .WriteString ("\u005d");return _aaac .String ();};

// IsFloatDigit checks if a character can be a part of a float number string.
func IsFloatDigit (c byte )bool {return ('0'<=c &&c <='9')||c =='.'};

// DecodeStream implements ASCII hex decoding.
func (_bccgg *ASCIIHexEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _bccgg .DecodeBytes (streamObj .Stream );};func (_fef *FlateEncoder )cleanImageData (_ded []byte )([]byte ,error ){if _fef ._fbbe ==nil {return _ded ,nil ;};if _fef ._fbbe .BitsPerComponent >=8{return _ded ,nil ;};_ecff :=_fef ._fbbe .BitsPerComponent *_fef ._fbbe .Width *_fef ._fbbe .ColorComponents *_fef ._fbbe .Height /8;_ded =_ded [:_ecff ];var _dfe error ;_ded ,_dfe =_da .AddDataPadding (_fef ._fbbe .Width ,_fef ._fbbe .Height ,_fef ._fbbe .BitsPerComponent ,_fef ._fbbe .ColorComponents ,_ded );if _dfe !=nil {return nil ,_dfe ;};return _ded ,nil ;};

// WriteString outputs the object as it is to be written to file.
func (_fceag *PdfObjectString )WriteString ()string {var _fcgb _gec .Buffer ;if _fceag ._abaf {_gdgag :=_cd .EncodeToString (_fceag .Bytes ());_fcgb .WriteString ("\u003c");_fcgb .WriteString (_gdgag );_fcgb .WriteString ("\u003e");return _fcgb .String ();};_gded :=map[byte ]string {'\n':"\u005c\u006e",'\r':"\u005c\u0072",'\t':"\u005c\u0074",'\b':"\u005c\u0062",'\f':"\u005c\u0066",'(':"\u005c\u0028",')':"\u005c\u0029",'\\':"\u005c\u005c"};_fcgb .WriteString ("\u0028");for _gebe :=0;_gebe < len (_fceag ._aabg );_gebe ++{_ddd :=_fceag ._aabg [_gebe ];if _gbfge ,_fffg :=_gded [_ddd ];_fffg {_fcgb .WriteString (_gbfge );}else {_fcgb .WriteByte (_ddd );};};_fcgb .WriteString ("\u0029");return _fcgb .String ();};

// StreamEncoder represents the interface for all PDF stream encoders.
type StreamEncoder interface{GetFilterName ()string ;MakeDecodeParams ()PdfObject ;MakeStreamDict ()*PdfObjectDictionary ;UpdateParams (_gfcd *PdfObjectDictionary );EncodeBytes (_cfdg []byte )([]byte ,error );DecodeBytes (_cag []byte )([]byte ,error );DecodeStream (_ccab *PdfObjectStream )([]byte ,error );};

// GetAsFloat64Slice returns the array as []float64 slice.
// Returns an error if not entirely numeric (only PdfObjectIntegers, PdfObjectFloats).
func (_ecfga *PdfObjectArray )GetAsFloat64Slice ()([]float64 ,error ){var _aggga []float64 ;for _ ,_gdebd :=range _ecfga .Elements (){_faae ,_aebe :=GetNumberAsFloat (TraceToDirectObject (_gdebd ));if _aebe !=nil {return nil ,_ff .Errorf ("\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006e\u0075m\u0062\u0065\u0072");};_aggga =append (_aggga ,_faae );};return _aggga ,nil ;};

// SetPredictor sets the predictor function.  Specify the number of columns per row.
// The columns indicates the number of samples per row.
// Used for grouping data together for compression.
func (_agbg *FlateEncoder )SetPredictor (columns int ){_agbg .Predictor =11;_agbg .Columns =columns };

// GetIndirect returns the *PdfIndirectObject represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetIndirect (obj PdfObject )(_eccg *PdfIndirectObject ,_aegee bool ){obj =ResolveReference (obj );_eccg ,_aegee =obj .(*PdfIndirectObject );return _eccg ,_aegee ;};func _baf (_fbb *_bca .StdEncryptDict ,_fad *PdfObjectDictionary ){_fad .Set ("\u0052",MakeInteger (int64 (_fbb .R )));_fad .Set ("\u0050",MakeInteger (int64 (_fbb .P )));_fad .Set ("\u004f",MakeStringFromBytes (_fbb .O ));_fad .Set ("\u0055",MakeStringFromBytes (_fbb .U ));if _fbb .R >=5{_fad .Set ("\u004f\u0045",MakeStringFromBytes (_fbb .OE ));_fad .Set ("\u0055\u0045",MakeStringFromBytes (_fbb .UE ));_fad .Set ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061",MakeBool (_fbb .EncryptMetadata ));if _fbb .R > 5{_fad .Set ("\u0050\u0065\u0072m\u0073",MakeStringFromBytes (_fbb .Perms ));};};};

// GetNumberAsInt64 returns the contents of `obj` as an int64 if it is an integer or float, or an
// error if it isn't. This is for cases where expecting an integer, but some implementations
// actually store the number in a floating point format.
func GetNumberAsInt64 (obj PdfObject )(int64 ,error ){switch _gafed :=obj .(type ){case *PdfObjectFloat :_beg .Log .Debug ("\u004e\u0075m\u0062\u0065\u0072\u0020\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0061\u0073\u0020\u0069\u006e\u0074e\u0067\u0065\u0072\u0020\u0077\u0061s\u0020\u0073\u0074\u006f\u0072\u0065\u0064\u0020\u0061\u0073\u0020\u0066\u006c\u006fa\u0074\u0020(\u0074\u0079\u0070\u0065 \u0063\u0061\u0073\u0074\u0069n\u0067\u0020\u0075\u0073\u0065\u0064\u0029");return int64 (*_gafed ),nil ;case *PdfObjectInteger :return int64 (*_gafed ),nil ;};return 0,ErrNotANumber ;};func (_ggece *PdfParser )parseArray ()(*PdfObjectArray ,error ){_bcaf :=MakeArray ();_ggece ._cdff .ReadByte ();for {_ggece .skipSpaces ();_aeda ,_eeab :=_ggece ._cdff .Peek (1);if _eeab !=nil {return _bcaf ,_eeab ;};if _aeda [0]==']'{_ggece ._cdff .ReadByte ();break ;};_faab ,_eeab :=_ggece .parseObject ();if _eeab !=nil {return _bcaf ,_eeab ;};_bcaf .Append (_faab );};return _bcaf ,nil ;};

// ParseIndirectObject parses an indirect object from the input stream. Can also be an object stream.
// Returns the indirect object (*PdfIndirectObject) or the stream object (*PdfObjectStream).
func (_befc *PdfParser )ParseIndirectObject ()(PdfObject ,error ){_fbdf :=PdfIndirectObject {};_fbdf ._cabd =_befc ;_beg .Log .Trace ("\u002dR\u0065a\u0064\u0020\u0069\u006e\u0064i\u0072\u0065c\u0074\u0020\u006f\u0062\u006a");_ccdb ,_gcca :=_befc ._cdff .Peek (20);if _gcca !=nil {if _gcca !=_cg .EOF {_beg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020r\u0065a\u0064\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a");return &_fbdf ,_gcca ;};};_beg .Log .Trace ("\u0028\u0069\u006edi\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_ccdb ));_bebb :=_dbbe .FindStringSubmatchIndex (string (_ccdb ));if len (_bebb )< 6{if _gcca ==_cg .EOF {return nil ,_gcca ;};_beg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_ccdb ));return &_fbdf ,_e .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");};_befc ._cdff .Discard (_bebb [0]);_beg .Log .Trace ("O\u0066\u0066\u0073\u0065\u0074\u0073\u0020\u0025\u0020\u0064",_bebb );_eacaa :=_bebb [1]-_bebb [0];_gcfa :=make ([]byte ,_eacaa );_ ,_gcca =_befc .ReadAtLeast (_gcfa ,_eacaa );if _gcca !=nil {_beg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u0072\u0065\u0061\u0064\u0020-\u0020\u0025\u0073",_gcca );return nil ,_gcca ;};_beg .Log .Trace ("\u0074\u0065\u0078t\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_gcfa );_dcdd :=_dbbe .FindStringSubmatch (string (_gcfa ));if len (_dcdd )< 3{_beg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_gcfa ));return &_fbdf ,_e .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");};_edgdae ,_ :=_b .Atoi (_dcdd [1]);_abege ,_ :=_b .Atoi (_dcdd [2]);_fbdf .ObjectNumber =int64 (_edgdae );_fbdf .GenerationNumber =int64 (_abege );for {_ebbcf ,_ddfc :=_befc ._cdff .Peek (2);if _ddfc !=nil {return &_fbdf ,_ddfc ;};_beg .Log .Trace ("I\u006ed\u002e\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_ebbcf ),string (_ebbcf ));if IsWhiteSpace (_ebbcf [0]){_befc .skipSpaces ();}else if _ebbcf [0]=='%'{_befc .skipComments ();}else if (_ebbcf [0]=='<')&&(_ebbcf [1]=='<'){_beg .Log .Trace ("\u0043\u0061\u006c\u006c\u0020\u0050\u0061\u0072\u0073e\u0044\u0069\u0063\u0074");_fbdf .PdfObject ,_ddfc =_befc .ParseDict ();_beg .Log .Trace ("\u0045\u004f\u0046\u0020Ca\u006c\u006c\u0020\u0050\u0061\u0072\u0073\u0065\u0044\u0069\u0063\u0074\u003a\u0020%\u0076",_ddfc );if _ddfc !=nil {return &_fbdf ,_ddfc ;};_beg .Log .Trace ("\u0050\u0061\u0072\u0073\u0065\u0064\u0020\u0064\u0069\u0063t\u0069\u006f\u006e\u0061\u0072\u0079\u002e.\u002e\u0020\u0066\u0069\u006e\u0069\u0073\u0068\u0065\u0064\u002e");}else if (_ebbcf [0]=='/')||(_ebbcf [0]=='(')||(_ebbcf [0]=='[')||(_ebbcf [0]=='<'){_fbdf .PdfObject ,_ddfc =_befc .parseObject ();if _ddfc !=nil {return &_fbdf ,_ddfc ;};_beg .Log .Trace ("P\u0061\u0072\u0073\u0065\u0064\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u002e\u002e\u002e \u0066\u0069\u006ei\u0073h\u0065\u0064\u002e");}else if _ebbcf [0]==']'{_beg .Log .Debug ("\u0057\u0041\u0052\u004e\u0049N\u0047\u003a\u0020\u0027\u005d\u0027 \u0063\u0068\u0061\u0072\u0061\u0063\u0074e\u0072\u0020\u006eo\u0074\u0020\u0062\u0065i\u006e\u0067\u0020\u0075\u0073\u0065d\u0020\u0061\u0073\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006e\u0064\u0069n\u0067\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e");_befc ._cdff .Discard (1);}else {if _ebbcf [0]=='e'{_ebbeg ,_ceca :=_befc .readTextLine ();if _ceca !=nil {return nil ,_ceca ;};if len (_ebbeg )>=6&&_ebbeg [0:6]=="\u0065\u006e\u0064\u006f\u0062\u006a"{break ;};}else if _ebbcf [0]=='s'{_ebbcf ,_ =_befc ._cdff .Peek (10);if string (_ebbcf [:6])=="\u0073\u0074\u0072\u0065\u0061\u006d"{_dcbg :=6;if len (_ebbcf )> 6{if IsWhiteSpace (_ebbcf [_dcbg ])&&_ebbcf [_dcbg ]!='\r'&&_ebbcf [_dcbg ]!='\n'{_beg .Log .Debug ("\u004e\u006fn\u002d\u0063\u006f\u006e\u0066\u006f\u0072\u006d\u0061\u006e\u0074\u0020\u0050\u0044\u0046\u0020\u006e\u006f\u0074 \u0065\u006e\u0064\u0069\u006e\u0067 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0069\u006e\u0065\u0020\u0070\u0072o\u0070\u0065r\u006c\u0079\u0020\u0077i\u0074\u0068\u0020\u0045\u004fL\u0020\u006d\u0061\u0072\u006b\u0065\u0072");_dcbg ++;};if _ebbcf [_dcbg ]=='\r'{_dcbg ++;if _ebbcf [_dcbg ]=='\n'{_dcbg ++;};}else if _ebbcf [_dcbg ]=='\n'{_dcbg ++;};};_befc ._cdff .Discard (_dcbg );_dfa ,_gfgd :=_fbdf .PdfObject .(*PdfObjectDictionary );if !_gfgd {return nil ,_e .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006di\u0073s\u0069\u006e\u0067\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_beg .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0069c\u0074\u0020\u0025\u0073",_dfa );_gggb ,_bbbe :=_befc .traceStreamLength (_dfa .Get ("\u004c\u0065\u006e\u0067\u0074\u0068"));if _bbbe !=nil {_beg .Log .Debug ("\u0046\u0061\u0069l\u0020\u0074\u006f\u0020t\u0072\u0061\u0063\u0065\u0020\u0073\u0074r\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0025\u0076",_bbbe );return nil ,_bbbe ;};_beg .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_gggb );_cegcc ,_dfdg :=_gggb .(*PdfObjectInteger );if !_dfdg {return nil ,_e .New ("\u0073\u0074re\u0061\u006d\u0020l\u0065\u006e\u0067\u0074h n\u0065ed\u0073\u0020\u0074\u006f\u0020\u0062\u0065 a\u006e\u0020\u0069\u006e\u0074\u0065\u0067e\u0072");};_efef :=*_cegcc ;if _efef < 0{return nil ,_e .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006e\u0065\u0065\u0064\u0073\u0020\u0074\u006f \u0062e\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0030");};_egd :=_befc .GetFileOffset ();_fbcg :=_befc .xrefNextObjectOffset (_egd );if _egd +int64 (_efef )> _fbcg &&_fbcg > _egd {_beg .Log .Debug ("E\u0078\u0070\u0065\u0063te\u0064 \u0065\u006e\u0064\u0069\u006eg\u0020\u0061\u0074\u0020\u0025\u0064",_egd +int64 (_efef ));_beg .Log .Debug ("\u004e\u0065\u0078\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020\u0061t\u0020\u0025\u0064",_fbcg );_bbab :=_fbcg -_egd -17;if _bbab < 0{return nil ,_e .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020go\u0069\u006e\u0067 \u0070\u0061s\u0074\u0020\u0062\u006f\u0075\u006ed\u0061\u0072i\u0065\u0073");};_beg .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0061\u0020l\u0065\u006e\u0067\u0074\u0068\u0020c\u006f\u0072\u0072\u0065\u0063\u0074\u0069\u006f\u006e\u0020\u0074\u006f\u0020%\u0064\u002e\u002e\u002e",_bbab );_efef =PdfObjectInteger (_bbab );_dfa .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (_bbab ));};if int64 (_efef )> _befc ._bdaca {_beg .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0053t\u0072\u0065\u0061\u006d\u0020l\u0065\u006e\u0067\u0074\u0068\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u0061\u0072\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0066\u0069\u006c\u0065\u0020\u0073\u0069\u007a\u0065");return nil ,_e .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020la\u0072\u0067\u0065r\u0020\u0074h\u0061\u006e\u0020\u0066\u0069\u006ce\u0020\u0073i\u007a\u0065");};_agag :=make ([]byte ,_efef );_ ,_bbbe =_befc .ReadAtLeast (_agag ,int (_efef ));if _bbbe !=nil {_beg .Log .Debug ("E\u0052\u0052\u004f\u0052 s\u0074r\u0065\u0061\u006d\u0020\u0028%\u0064\u0029\u003a\u0020\u0025\u0058",len (_agag ),_agag );_beg .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_bbbe );return nil ,_bbbe ;};_fcdg :=PdfObjectStream {};_fcdg .Stream =_agag ;_fcdg .PdfObjectDictionary =_fbdf .PdfObject .(*PdfObjectDictionary );_fcdg .ObjectNumber =_fbdf .ObjectNumber ;_fcdg .GenerationNumber =_fbdf .GenerationNumber ;_fcdg .PdfObjectReference ._cabd =_befc ;_befc .skipSpaces ();_befc ._cdff .Discard (9);_befc .skipSpaces ();return &_fcdg ,nil ;};};_fbdf .PdfObject ,_ddfc =_befc .parseObject ();if _fbdf .PdfObject ==nil {_beg .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");_fbdf .PdfObject =MakeNull ();};return &_fbdf ,_ddfc ;};};if _fbdf .PdfObject ==nil {_beg .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");_fbdf .PdfObject =MakeNull ();};_beg .Log .Trace ("\u0052\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0021");return &_fbdf ,nil ;};func (_ccfd *FlateEncoder )postDecodePredict (_dbd []byte )([]byte ,error ){if _ccfd .Predictor > 1{if _ccfd .Predictor ==2{_beg .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_beg .Log .Trace ("\u0043\u006f\u006c\u006f\u0072\u0073\u003a\u0020\u0025\u0064",_ccfd .Colors );_ddb :=int (_ccfd .Columns )*_ccfd .Colors ;if _ddb < 1{return []byte {},nil ;};_fcb :=len (_dbd )/_ddb ;if len (_dbd )%_ddb !=0{_beg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");return nil ,_ff .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_dbd ),_ddb );};if _ddb %_ccfd .Colors !=0{return nil ,_ff .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_ddb ,_ccfd .Colors );};if _ddb > len (_dbd ){_beg .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_ddb ,len (_dbd ));return nil ,_e .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_beg .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_dbd ),_dbd );_facd :=_gec .NewBuffer (nil );for _bge :=0;_bge < _fcb ;_bge ++{_efba :=_dbd [_ddb *_bge :_ddb *(_bge +1)];for _dfba :=_ccfd .Colors ;_dfba < _ddb ;_dfba ++{_efba [_dfba ]+=_efba [_dfba -_ccfd .Colors ];};_facd .Write (_efba );};_bgee :=_facd .Bytes ();_beg .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_bgee ),_bgee );return _bgee ,nil ;}else if _ccfd .Predictor >=10&&_ccfd .Predictor <=15{_beg .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_bgfa :=int (_ccfd .Columns *_ccfd .Colors +1);_ebfc :=len (_dbd )/_bgfa ;if len (_dbd )%_bgfa !=0{return nil ,_ff .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_dbd ),_bgfa );};if _bgfa > len (_dbd ){_beg .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_bgfa ,len (_dbd ));return nil ,_e .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_dagc :=_gec .NewBuffer (nil );_beg .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_ccfd .Columns );_beg .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_dbd ),_bgfa ,_ebfc );_fddd :=make ([]byte ,_bgfa );for _dda :=0;_dda < _bgfa ;_dda ++{_fddd [_dda ]=0;};_bga :=_ccfd .Colors ;for _aaeb :=0;_aaeb < _ebfc ;_aaeb ++{_cdad :=_dbd [_bgfa *_aaeb :_bgfa *(_aaeb +1)];_aade :=_cdad [0];switch _aade {case _ecf :case _aegb :for _gab :=1+_bga ;_gab < _bgfa ;_gab ++{_cdad [_gab ]+=_cdad [_gab -_bga ];};case _bffef :for _agcee :=1;_agcee < _bgfa ;_agcee ++{_cdad [_agcee ]+=_fddd [_agcee ];};case _bce :for _eef :=1;_eef < _bga +1;_eef ++{_cdad [_eef ]+=_fddd [_eef ]/2;};for _aedf :=_bga +1;_aedf < _bgfa ;_aedf ++{_cdad [_aedf ]+=byte ((int (_cdad [_aedf -_bga ])+int (_fddd [_aedf ]))/2);};case _cef :for _bdbd :=1;_bdbd < _bgfa ;_bdbd ++{var _cbad ,_degd ,_abef byte ;_degd =_fddd [_bdbd ];if _bdbd >=_bga +1{_cbad =_cdad [_bdbd -_bga ];_abef =_fddd [_bdbd -_bga ];};_cdad [_bdbd ]+=_bcdc (_cbad ,_degd ,_abef );};default:_beg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029\u0020\u0040\u0072o\u0077\u0020\u0025\u0064",_aade ,_aaeb );return nil ,_ff .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_aade );};copy (_fddd ,_cdad );_dagc .Write (_cdad [1:]);};_aadg :=_dagc .Bytes ();return _aadg ,nil ;}else {_beg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_ccfd .Predictor );return nil ,_ff .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_ccfd .Predictor );};};return _dbd ,nil ;};

// GetFilterName returns the name of the encoding filter.
func (_agbd *JBIG2Encoder )GetFilterName ()string {return StreamEncodingFilterNameJBIG2 };var _dbbe =_ef .MustCompile ("\u0028\u005c\u0064\u002b)\\\u0073\u002b\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u006f\u0062\u006a");

// GetFloatVal returns the float64 value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetFloatVal (obj PdfObject )(_dccf float64 ,_fbdbd bool ){_egfdd ,_fbdbd :=TraceToDirectObject (obj ).(*PdfObjectFloat );if _fbdbd {return float64 (*_egfdd ),true ;};return 0,false ;};

// GetCrypter returns the PdfCrypt instance which has information about the PDFs encryption.
func (_cdeg *PdfParser )GetCrypter ()*PdfCrypt {return _cdeg ._ccddd };

// NewFlateEncoder makes a new flate encoder with default parameters, predictor 1 and bits per component 8.
func NewFlateEncoder ()*FlateEncoder {_fee :=&FlateEncoder {};_fee .Predictor =1;_fee .BitsPerComponent =8;_fee .Colors =1;_fee .Columns =1;return _fee ;};

// MakeStringFromBytes creates an PdfObjectString from a byte array.
// This is more natural than MakeString as `data` is usually not utf-8 encoded.
func MakeStringFromBytes (data []byte )*PdfObjectString {return MakeString (string (data ))};

// EncodeBytes encodes data into ASCII85 encoded format.
func (_deb *ASCII85Encoder )EncodeBytes (data []byte )([]byte ,error ){var _fbff _gec .Buffer ;for _edga :=0;_edga < len (data );_edga +=4{_afd :=data [_edga ];_bffg :=1;_egfb :=byte (0);if _edga +1< len (data ){_egfb =data [_edga +1];_bffg ++;};_fbac :=byte (0);if _edga +2< len (data ){_fbac =data [_edga +2];_bffg ++;};_dfgf :=byte (0);if _edga +3< len (data ){_dfgf =data [_edga +3];_bffg ++;};_bagb :=(uint32 (_afd )<<24)|(uint32 (_egfb )<<16)|(uint32 (_fbac )<<8)|uint32 (_dfgf );if _bagb ==0{_fbff .WriteByte ('z');}else {_dfec :=_deb .base256Tobase85 (_bagb );for _ ,_bdeg :=range _dfec [:_bffg +1]{_fbff .WriteByte (_bdeg +'!');};};};_fbff .WriteString ("\u007e\u003e");return _fbff .Bytes (),nil ;};func (_gaad *JBIG2Image )toBitmap ()(_bcff *_fg .Bitmap ,_effgf error ){const _cdbag ="\u004a\u0042\u0049\u00472I\u006d\u0061\u0067\u0065\u002e\u0074\u006f\u0042\u0069\u0074\u006d\u0061\u0070";if _gaad .Data ==nil {return nil ,_aa .Error (_cdbag ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");};if _gaad .Width ==0||_gaad .Height ==0{return nil ,_aa .Error (_cdbag ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");};if _gaad .HasPadding {_bcff ,_effgf =_fg .NewWithData (_gaad .Width ,_gaad .Height ,_gaad .Data );}else {_bcff ,_effgf =_fg .NewWithUnpaddedData (_gaad .Width ,_gaad .Height ,_gaad .Data );};if _effgf !=nil {return nil ,_aa .Wrap (_effgf ,_cdbag ,"");};return _bcff ,nil ;};

// MakeArray creates an PdfObjectArray from a list of PdfObjects.
func MakeArray (objects ...PdfObject )*PdfObjectArray {_badf :=&PdfObjectArray {};_badf ._fbcce =[]PdfObject {};for _ ,_adda :=range objects {_badf ._fbcce =append (_badf ._fbcce ,_adda );};return _badf ;};func _cdfec (_eeef _da .Image )*JBIG2Image {_eadc :=_eeef .Base ();return &JBIG2Image {Data :_eadc .Data ,Width :_eadc .Width ,Height :_eadc .Height ,HasPadding :true };};

// UpdateParams updates the parameter values of the encoder.
func (_fec *FlateEncoder )UpdateParams (params *PdfObjectDictionary ){_cbbf ,_gdg :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _gdg ==nil {_fec .Predictor =int (_cbbf );};_gdaa ,_gdg :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _gdg ==nil {_fec .BitsPerComponent =int (_gdaa );};_gfcdf ,_gdg :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _gdg ==nil {_fec .Columns =int (_gfcdf );};_cebc ,_gdg :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _gdg ==nil {_fec .Colors =int (_cebc );};};func _fgg (_aeg PdfObject )(int64 ,int64 ,error ){if _eaa ,_dga :=_aeg .(*PdfIndirectObject );_dga {return _eaa .ObjectNumber ,_eaa .GenerationNumber ,nil ;};if _gg ,_bee :=_aeg .(*PdfObjectStream );_bee {return _gg .ObjectNumber ,_gg .GenerationNumber ,nil ;};return 0,0,_e .New ("\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u002f\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062je\u0063\u0074");};

// IsPrintable checks if a character is printable.
// Regular characters that are outside the range EXCLAMATION MARK(21h)
// (!) to TILDE (7Eh) (~) should be written using the hexadecimal notation.
func IsPrintable (c byte )bool {return 0x21<=c &&c <=0x7E};func _agfg (_fccf PdfObject ,_bdacf int )PdfObject {if _bdacf > _gbab {_beg .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_gbab );return MakeNull ();};switch _bdgeg :=_fccf .(type ){case *PdfIndirectObject :_fccf =_agfg ((*_bdgeg ).PdfObject ,_bdacf +1);case *PdfObjectArray :for _fgdce ,_ebbcd :=range (*_bdgeg )._fbcce {(*_bdgeg )._fbcce [_fgdce ]=_agfg (_ebbcd ,_bdacf +1);};case *PdfObjectDictionary :for _bceag ,_abbe :=range (*_bdgeg )._ggagd {(*_bdgeg )._ggagd [_bceag ]=_agfg (_abbe ,_bdacf +1);};_g .Slice ((*_bdgeg )._edcg ,func (_abba ,_cffb int )bool {return (*_bdgeg )._edcg [_abba ]< (*_bdgeg )._edcg [_cffb ]});};return _fccf ;};

// Bytes returns the PdfObjectString content as a []byte array.
func (_fggc *PdfObjectString )Bytes ()[]byte {return []byte (_fggc ._aabg )};

// XrefTable represents the cross references in a PDF, i.e. the table of objects and information
// where to access within the PDF file.
type XrefTable struct{ObjectMap map[int ]XrefObject ;_ec []XrefObject ;};func _fffb (_edea *PdfObjectStream ,_dbaa *PdfObjectDictionary )(*LZWEncoder ,error ){_facf :=NewLZWEncoder ();_aee :=_edea .PdfObjectDictionary ;if _aee ==nil {return _facf ,nil ;};if _dbaa ==nil {_egfe :=TraceToDirectObject (_aee .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));if _egfe !=nil {if _cdc ,_bgef :=_egfe .(*PdfObjectDictionary );_bgef {_dbaa =_cdc ;}else if _gac ,_bbf :=_egfe .(*PdfObjectArray );_bbf {if _gac .Len ()==1{if _ggef ,_ced :=GetDict (_gac .Get (0));_ced {_dbaa =_ggef ;};};};if _dbaa ==nil {_beg .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_egfe );return nil ,_ff .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};};_bgeef :=_aee .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");if _bgeef !=nil {_dedd ,_ebbe :=_bgeef .(*PdfObjectInteger );if !_ebbe {_beg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a \u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065d\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u006e\u0075\u006d\u0065\u0072i\u0063 \u0028\u0025\u0054\u0029",_bgeef );return nil ,_ff .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");};if *_dedd !=0&&*_dedd !=1{return nil ,_ff .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0076\u0061\u006c\u0075e\u0020\u0028\u006e\u006f\u0074 \u0030\u0020o\u0072\u0020\u0031\u0029");};_facf .EarlyChange =int (*_dedd );}else {_facf .EarlyChange =1;};if _dbaa ==nil {return _facf ,nil ;};_bgeef =_dbaa .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");if _bgeef !=nil {_fagb ,_bgab :=_bgeef .(*PdfObjectInteger );if !_bgab {_beg .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_bgeef );return nil ,_ff .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_facf .Predictor =int (*_fagb );};_bgeef =_dbaa .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");if _bgeef !=nil {_fedd ,_dbff :=_bgeef .(*PdfObjectInteger );if !_dbff {_beg .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");return nil ,_ff .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_facf .BitsPerComponent =int (*_fedd );};if _facf .Predictor > 1{_facf .Columns =1;_bgeef =_dbaa .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");if _bgeef !=nil {_gdd ,_cfbg :=_bgeef .(*PdfObjectInteger );if !_cfbg {return nil ,_ff .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_facf .Columns =int (*_gdd );};_facf .Colors =1;_bgeef =_dbaa .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _bgeef !=nil {_dacg ,_bgea :=_bgeef .(*PdfObjectInteger );if !_bgea {return nil ,_ff .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");};_facf .Colors =int (*_dacg );};};_beg .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_dbaa .String ());return _facf ,nil ;};

// Set sets the dictionary's key -> val mapping entry. Overwrites if key already set.
func (_dabg *PdfObjectDictionary )Set (key PdfObjectName ,val PdfObject ){_ ,_afef :=_dabg ._ggagd [key ];if !_afef {_dabg ._edcg =append (_dabg ._edcg ,key );};_dabg ._ggagd [key ]=val ;};

// GetTrailer returns the PDFs trailer dictionary. The trailer dictionary is typically the starting point for a PDF,
// referencing other key objects that are important in the document structure.
func (_fgfg *PdfParser )GetTrailer ()*PdfObjectDictionary {return _fgfg ._ace };func (_cb *PdfParser )lookupByNumberWrapper (_gfaa int ,_ffb bool )(PdfObject ,bool ,error ){_ae ,_cddg ,_bed :=_cb .lookupByNumber (_gfaa ,_ffb );if _bed !=nil {return nil ,_cddg ,_bed ;};if !_cddg &&_cb ._ccddd !=nil &&!_cb ._ccddd .isDecrypted (_ae ){_cga :=_cb ._ccddd .Decrypt (_ae ,0,0);if _cga !=nil {return nil ,_cddg ,_cga ;};};return _ae ,_cddg ,nil ;};func _bbed (_gdedf string )(int ,int ,error ){_afgfc :=_dbbe .FindStringSubmatch (_gdedf );if len (_afgfc )< 3{return 0,0,_e .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");};_dfdcc ,_ :=_b .Atoi (_afgfc [1]);_cccc ,_ :=_b .Atoi (_afgfc [2]);return _dfdcc ,_cccc ,nil ;};

// Clear resets the dictionary to an empty state.
func (_ddcf *PdfObjectDictionary )Clear (){_ddcf ._edcg =[]PdfObjectName {};_ddcf ._ggagd =map[PdfObjectName ]PdfObject {};};

// Clear resets the array to an empty state.
func (_gafe *PdfObjectArray )Clear (){_gafe ._fbcce =[]PdfObject {}};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_fgdc *FlateEncoder )MakeDecodeParams ()PdfObject {if _fgdc .Predictor > 1{_fgag :=MakeDict ();_fgag .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_fgdc .Predictor )));if _fgdc .BitsPerComponent !=8{_fgag .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_fgdc .BitsPerComponent )));};if _fgdc .Columns !=1{_fgag .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_fgdc .Columns )));};if _fgdc .Colors !=1{_fgag .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_fgdc .Colors )));};return _fgag ;};return nil ;};

// String returns a string describing `stream`.
func (_ccge *PdfObjectStream )String ()string {return _ff .Sprintf ("O\u0062j\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0025\u0064: \u0025\u0073",_ccge .ObjectNumber ,_ccge .PdfObjectDictionary );};

// MakeArrayFromIntegers creates an PdfObjectArray from a slice of ints, where each array element is
// an PdfObjectInteger.
func MakeArrayFromIntegers (vals []int )*PdfObjectArray {_ebef :=MakeArray ();for _ ,_eabd :=range vals {_ebef .Append (MakeInteger (int64 (_eabd )));};return _ebef ;};

// NewASCII85Encoder makes a new ASCII85 encoder.
func NewASCII85Encoder ()*ASCII85Encoder {_effd :=&ASCII85Encoder {};return _effd };

// Decrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_aaef *PdfCrypt )Decrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _aaef .isDecrypted (obj ){return nil ;};switch _dacf :=obj .(type ){case *PdfIndirectObject :_aaef ._ggd [_dacf ]=true ;_beg .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_dacf .ObjectNumber ,_dacf .GenerationNumber );_ffa :=_dacf .ObjectNumber ;_cbeb :=_dacf .GenerationNumber ;_gfgcd :=_aaef .Decrypt (_dacf .PdfObject ,_ffa ,_cbeb );if _gfgcd !=nil {return _gfgcd ;};return nil ;case *PdfObjectStream :_aaef ._ggd [_dacf ]=true ;_fcd :=_dacf .PdfObjectDictionary ;if _aaef ._aba .R !=5{if _efd ,_fda :=_fcd .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_fda &&*_efd =="\u0058\u0052\u0065\u0066"{return nil ;};};_gef :=_dacf .ObjectNumber ;_abbb :=_dacf .GenerationNumber ;_beg .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_gef ,_abbb );_dcd :=_gcd ;if _aaef ._geb .V >=4{_dcd =_aaef ._dae ;_beg .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_aaef ._dae );if _eff ,_bfgf :=_fcd .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );_bfgf {if _cfcd ,_abeg :=GetName (_eff .Get (0));_abeg {if *_cfcd =="\u0043\u0072\u0079p\u0074"{_dcd ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _bgfb ,_cgaa :=_fcd .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );_cgaa {if _affe ,_eeac :=_bgfb .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_eeac {if _ ,_fgf :=_aaef ._dbf [string (*_affe )];_fgf {_beg .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_affe );_dcd =string (*_affe );};};};};};};_beg .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_dcd );if _dcd =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_bag :=_aaef .Decrypt (_fcd ,_gef ,_abbb );if _bag !=nil {return _bag ;};_eba ,_bag :=_aaef .makeKey (_dcd ,uint32 (_gef ),uint32 (_abbb ),_aaef ._baa );if _bag !=nil {return _bag ;};_dacf .Stream ,_bag =_aaef .decryptBytes (_dacf .Stream ,_dcd ,_eba );if _bag !=nil {return _bag ;};_fcd .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_dacf .Stream ))));return nil ;case *PdfObjectString :_beg .Log .Trace ("\u0044e\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_ffc :=_gcd ;if _aaef ._geb .V >=4{_beg .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_aaef ._fde );if _aaef ._fde =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_ffc =_aaef ._fde ;};_dadd ,_bdb :=_aaef .makeKey (_ffc ,uint32 (parentObjNum ),uint32 (parentGenNum ),_aaef ._baa );if _bdb !=nil {return _bdb ;};_beaee :=_dacf .Str ();_eeg :=make ([]byte ,len (_beaee ));for _gfgcg :=0;_gfgcg < len (_beaee );_gfgcg ++{_eeg [_gfgcg ]=_beaee [_gfgcg ];};_beg .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_eeg ,_eeg );_eeg ,_bdb =_aaef .decryptBytes (_eeg ,_ffc ,_dadd );if _bdb !=nil {return _bdb ;};_dacf ._aabg =string (_eeg );return nil ;case *PdfObjectArray :for _ ,_acb :=range _dacf .Elements (){_ffcb :=_aaef .Decrypt (_acb ,parentObjNum ,parentGenNum );if _ffcb !=nil {return _ffcb ;};};return nil ;case *PdfObjectDictionary :_fge :=false ;if _dcaf :=_dacf .Get ("\u0054\u0079\u0070\u0065");_dcaf !=nil {_eggc ,_dbc :=_dcaf .(*PdfObjectName );if _dbc &&*_eggc =="\u0053\u0069\u0067"{_fge =true ;};};for _ ,_fccg :=range _dacf .Keys (){_edca :=_dacf .Get (_fccg );if _fge &&string (_fccg )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;};if string (_fccg )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_fccg )!="\u0050\u0072\u0065\u0076"&&string (_fccg )!="\u004c\u0061\u0073\u0074"{_ceb :=_aaef .Decrypt (_edca ,parentObjNum ,parentGenNum );if _ceb !=nil {return _ceb ;};};};return nil ;};return nil ;};func _efae (_cdaa PdfObject ,_fcaf int ,_cdbd map[PdfObject ]struct{})error {_beg .Log .Trace ("\u0054\u0072\u0061\u0076\u0065\u0072s\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0064\u0061\u0074\u0061 \u0028\u0064\u0065\u0070\u0074\u0068\u0020=\u0020\u0025\u0064\u0029",_fcaf );if _ ,_degf :=_cdbd [_cdaa ];_degf {_beg .Log .Trace ("-\u0041\u006c\u0072\u0065ad\u0079 \u0074\u0072\u0061\u0076\u0065r\u0073\u0065\u0064\u002e\u002e\u002e");return nil ;};_cdbd [_cdaa ]=struct{}{};switch _aeff :=_cdaa .(type ){case *PdfIndirectObject :_cfbf :=_aeff ;_beg .Log .Trace ("\u0069\u006f\u003a\u0020\u0025\u0073",_cfbf );_beg .Log .Trace ("\u002d\u0020\u0025\u0073",_cfbf .PdfObject );return _efae (_cfbf .PdfObject ,_fcaf +1,_cdbd );case *PdfObjectStream :_gecc :=_aeff ;return _efae (_gecc .PdfObjectDictionary ,_fcaf +1,_cdbd );case *PdfObjectDictionary :_cecfb :=_aeff ;_beg .Log .Trace ("\u002d\u0020\u0064\u0069\u0063\u0074\u003a\u0020\u0025\u0073",_cecfb );for _ ,_aecd :=range _cecfb .Keys (){_bdffbc :=_cecfb .Get (_aecd );if _cfba ,_bfce :=_bdffbc .(*PdfObjectReference );_bfce {_cabda :=_cfba .Resolve ();_cecfb .Set (_aecd ,_cabda );_affce :=_efae (_cabda ,_fcaf +1,_cdbd );if _affce !=nil {return _affce ;};}else {_gaac :=_efae (_bdffbc ,_fcaf +1,_cdbd );if _gaac !=nil {return _gaac ;};};};return nil ;case *PdfObjectArray :_gegd :=_aeff ;_beg .Log .Trace ("-\u0020\u0061\u0072\u0072\u0061\u0079\u003a\u0020\u0025\u0073",_gegd );for _ffde ,_ddbc :=range _gegd .Elements (){if _cdadf ,_ebaea :=_ddbc .(*PdfObjectReference );_ebaea {_fcf :=_cdadf .Resolve ();_gegd .Set (_ffde ,_fcf );_fceb :=_efae (_fcf ,_fcaf +1,_cdbd );if _fceb !=nil {return _fceb ;};}else {_bfge :=_efae (_ddbc ,_fcaf +1,_cdbd );if _bfge !=nil {return _bfge ;};};};return nil ;case *PdfObjectReference :_beg .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020T\u0072\u0061\u0063\u0069\u006e\u0067\u0020\u0061\u0020r\u0065\u0066\u0065r\u0065n\u0063\u0065\u0021");return _e .New ("\u0065r\u0072\u006f\u0072\u0020t\u0072\u0061\u0063\u0069\u006eg\u0020a\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");};return nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_fcdb *JPXEncoder )MakeDecodeParams ()PdfObject {return nil };

// MakeEncodedString creates a PdfObjectString with encoded content, which can be either
// UTF-16BE or PDFDocEncoding depending on whether `utf16BE` is true or false respectively.
func MakeEncodedString (s string ,utf16BE bool )*PdfObjectString {if utf16BE {var _bcccbe _gec .Buffer ;_bcccbe .Write ([]byte {0xFE,0xFF});_bcccbe .WriteString (_cae .StringToUTF16 (s ));return &PdfObjectString {_aabg :_bcccbe .String (),_abaf :true };};return &PdfObjectString {_aabg :string (_cae .StringToPDFDocEncoding (s )),_abaf :false };};

// WriteString outputs the object as it is to be written to file.
func (_abeag *PdfObjectReference )WriteString ()string {var _fcdc _d .Builder ;_fcdc .WriteString (_b .FormatInt (_abeag .ObjectNumber ,10));_fcdc .WriteString ("\u0020");_fcdc .WriteString (_b .FormatInt (_abeag .GenerationNumber ,10));_fcdc .WriteString ("\u0020\u0052");return _fcdc .String ();};

// CheckAccessRights checks access rights and permissions for a specified password. If either user/owner password is
// specified, full rights are granted, otherwise the access rights are specified by the Permissions flag.
//
// The bool flag indicates that the user can access and view the file.
// The AccessPermissions shows what access the user has for editing etc.
// An error is returned if there was a problem performing the authentication.
func (_eacae *PdfParser )CheckAccessRights (password []byte )(bool ,_bca .Permissions ,error ){if _eacae ._ccddd ==nil {return true ,_bca .PermOwner ,nil ;};return _eacae ._ccddd .checkAccessRights (password );};

// UpdateParams updates the parameter values of the encoder.
func (_ffbc *RawEncoder )UpdateParams (params *PdfObjectDictionary ){};

// EncodeBytes encodes slice of bytes into JBIG2 encoding format.
// The input 'data' must be an image. In order to Decode it a user is responsible to
// load the codec ('png', 'jpg').
// Returns jbig2 single page encoded document byte slice. The encoder uses DefaultPageSettings
// to encode given image.
func (_ddfd *JBIG2Encoder )EncodeBytes (data []byte )([]byte ,error ){const _ecfa ="\u004aB\u0049\u0047\u0032\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002eE\u006e\u0063\u006f\u0064\u0065\u0042\u0079\u0074\u0065\u0073";if _ddfd .ColorComponents !=1||_ddfd .BitsPerComponent !=1{return nil ,_aa .Errorf (_ecfa ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u002e\u0020\u004a\u0042\u0049G\u0032\u0020E\u006e\u0063o\u0064\u0065\u0072\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020bi\u006e\u0061\u0072\u0079\u0020\u0069\u006d\u0061\u0067e\u0073\u0020\u0064\u0061\u0074\u0061");};var (_dbea *_fg .Bitmap ;_dcfe error ;);_bdeda :=(_ddfd .Width *_ddfd .Height )==len (data );if _bdeda {_dbea ,_dcfe =_fg .NewWithUnpaddedData (_ddfd .Width ,_ddfd .Height ,data );}else {_dbea ,_dcfe =_fg .NewWithData (_ddfd .Width ,_ddfd .Height ,data );};if _dcfe !=nil {return nil ,_dcfe ;};_ebba :=_ddfd .DefaultPageSettings ;if _dcfe =_ebba .Validate ();_dcfe !=nil {return nil ,_aa .Wrap (_dcfe ,_ecfa ,"");};switch _ebba .Compression {case JB2Generic :if _dcfe =_ddfd ._adea .AddGenericPage (_dbea ,_ebba .DuplicatedLinesRemoval );_dcfe !=nil {return nil ,_aa .Wrap (_dcfe ,_ecfa ,"");};case JB2SymbolCorrelation :return nil ,_aa .Error (_ecfa ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");case JB2SymbolRankHaus :return nil ,_aa .Error (_ecfa ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");default:return nil ,_aa .Error (_ecfa ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return _ddfd .Encode ();};

// MakeIndirectObject creates an PdfIndirectObject with a specified direct object PdfObject.
func MakeIndirectObject (obj PdfObject )*PdfIndirectObject {_ccdbf :=&PdfIndirectObject {};_ccdbf .PdfObject =obj ;return _ccdbf ;};

// Elements returns a slice of the PdfObject elements in the array.
// Preferred over accessing the array directly as type may be changed in future major versions (v3).
func (_ceeee *PdfObjectStreams )Elements ()[]PdfObject {if _ceeee ==nil {return nil ;};return _ceeee ._acec ;};func (_ebbb *PdfParser )parsePdfVersion ()(int ,int ,error ){var _egff int64 =20;_geff :=make ([]byte ,_egff );_ebbb ._bdff .Seek (0,_bf .SEEK_SET );_ebbb ._bdff .Read (_geff );var _dacge error ;var _eda ,_cagbc int ;if _daed :=_dcda .FindStringSubmatch (string (_geff ));len (_daed )< 3{if _eda ,_cagbc ,_dacge =_ebbb .seekPdfVersionTopDown ();_dacge !=nil {_beg .Log .Debug ("F\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065\u0063\u006f\u0076\u0065\u0072\u0079\u0020\u002d\u0020\u0075n\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0066\u0069nd\u0020\u0076\u0065r\u0073i\u006f\u006e");return 0,0,_dacge ;};_ebbb ._bdff ,_dacge =_ggb (_ebbb ._bdff ,_ebbb .GetFileOffset ()-8);if _dacge !=nil {return 0,0,_dacge ;};}else {if _eda ,_dacge =_b .Atoi (_daed [1]);_dacge !=nil {return 0,0,_dacge ;};if _cagbc ,_dacge =_b .Atoi (_daed [2]);_dacge !=nil {return 0,0,_dacge ;};_ebbb .SetFileOffset (0);};_ebbb ._cdff =_gf .NewReader (_ebbb ._bdff );_beg .Log .Debug ("\u0050\u0064\u0066\u0020\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020%\u0064\u002e\u0025\u0064",_eda ,_cagbc );return _eda ,_cagbc ,nil ;};

// Get returns the i-th element of the array or nil if out of bounds (by index).
func (_cffc *PdfObjectArray )Get (i int )PdfObject {if _cffc ==nil ||i >=len (_cffc ._fbcce )||i < 0{return nil ;};return _cffc ._fbcce [i ];};

// MakeHexString creates an PdfObjectString from a string intended for output as a hexadecimal string.
func MakeHexString (s string )*PdfObjectString {_gcab :=PdfObjectString {_aabg :s ,_abaf :true };return &_gcab ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_cbd *LZWEncoder )MakeDecodeParams ()PdfObject {if _cbd .Predictor > 1{_gedg :=MakeDict ();_gedg .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_cbd .Predictor )));if _cbd .BitsPerComponent !=8{_gedg .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_cbd .BitsPerComponent )));};if _cbd .Columns !=1{_gedg .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_cbd .Columns )));};if _cbd .Colors !=1{_gedg .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_cbd .Colors )));};return _gedg ;};return nil ;};var _dbca =_ef .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064\u002b)\u005c\u0073\u002a\u0024");func (_cecb *offsetReader )Seek (offset int64 ,whence int )(int64 ,error ){if whence ==_cg .SeekStart {offset +=_cecb ._debe ;};_efga ,_eacc :=_cecb ._bbbd .Seek (offset ,whence );if _eacc !=nil {return _efga ,_eacc ;};if whence ==_cg .SeekCurrent {_efga -=_cecb ._debe ;};if _efga < 0{return 0,_e .New ("\u0063\u006f\u0072\u0065\u002eo\u0066\u0066\u0073\u0065\u0074\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053e\u0065\u006b\u003a\u0020\u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e");};return _efga ,nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_acdf *DCTEncoder )UpdateParams (params *PdfObjectDictionary ){_efbba ,_adee :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _adee ==nil {_acdf .ColorComponents =int (_efbba );};_ffbf ,_adee :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _adee ==nil {_acdf .BitsPerComponent =int (_ffbf );};_bcg ,_adee :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _adee ==nil {_acdf .Width =int (_bcg );};_agda ,_adee :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _adee ==nil {_acdf .Height =int (_agda );};_egc ,_adee :=GetNumberAsInt64 (params .Get ("\u0051u\u0061\u006c\u0069\u0074\u0079"));if _adee ==nil {_acdf .Quality =int (_egc );};};

// Keys returns the list of keys in the dictionary.
// If `d` is nil returns a nil slice.
func (_beeff *PdfObjectDictionary )Keys ()[]PdfObjectName {if _beeff ==nil {return nil ;};return _beeff ._edcg ;};func (_dfcf *PdfParser )parseName ()(PdfObjectName ,error ){var _efge _gec .Buffer ;_fabc :=false ;for {_gcgf ,_agcc :=_dfcf ._cdff .Peek (1);if _agcc ==_cg .EOF {break ;};if _agcc !=nil {return PdfObjectName (_efge .String ()),_agcc ;};if !_fabc {if _gcgf [0]=='/'{_fabc =true ;_dfcf ._cdff .ReadByte ();}else if _gcgf [0]=='%'{_dfcf .readComment ();_dfcf .skipSpaces ();}else {_beg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020N\u0061\u006d\u0065\u0020\u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020w\u0069\u0074\u0068\u0020\u0025\u0073\u0020(\u0025\u0020\u0078\u0029",_gcgf ,_gcgf );return PdfObjectName (_efge .String ()),_ff .Errorf ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u006ea\u006d\u0065:\u0020\u0028\u0025\u0063\u0029",_gcgf [0]);};}else {if IsWhiteSpace (_gcgf [0]){break ;}else if (_gcgf [0]=='/')||(_gcgf [0]=='[')||(_gcgf [0]=='(')||(_gcgf [0]==']')||(_gcgf [0]=='<')||(_gcgf [0]=='>'){break ;}else if _gcgf [0]=='#'{_bcgd ,_aaba :=_dfcf ._cdff .Peek (3);if _aaba !=nil {return PdfObjectName (_efge .String ()),_aaba ;};_cbadd ,_aaba :=_cd .DecodeString (string (_bcgd [1:3]));if _aaba !=nil {_beg .Log .Debug ("\u0045\u0052\u0052\u004fR\u003a\u0020\u0049\u006ev\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0066o\u006c\u006co\u0077\u0069\u006e\u0067 \u0027\u0023\u0027\u002c \u0063\u006f\u006e\u0074\u0069n\u0075\u0069\u006e\u0067\u0020\u0075\u0073i\u006e\u0067\u0020\u006c\u0069t\u0065\u0072\u0061\u006c\u0020\u002d\u0020\u004f\u0075t\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074");_efge .WriteByte ('#');_dfcf ._cdff .Discard (1);continue ;};_dfcf ._cdff .Discard (3);_efge .Write (_cbadd );}else {_feebc ,_ :=_dfcf ._cdff .ReadByte ();_efge .WriteByte (_feebc );};};};return PdfObjectName (_efge .String ()),nil ;};var _ebaf =_ef .MustCompile ("\u005c\u0073\u002a\u0078\u0072\u0065\u0066\u005c\u0073\u002a");type cryptFilters map[string ]_ag .Filter ;func (_bdge *PdfParser )skipSpaces ()(int ,error ){_ceff :=0;for {_gdeb ,_fdca :=_bdge ._cdff .ReadByte ();if _fdca !=nil {return 0,_fdca ;};if IsWhiteSpace (_gdeb ){_ceff ++;}else {_bdge ._cdff .UnreadByte ();break ;};};return _ceff ,nil ;};

// GetInt returns the *PdfObjectBool object that is represented by a PdfObject either directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetInt (obj PdfObject )(_egfd *PdfObjectInteger ,_bcgf bool ){_egfd ,_bcgf =TraceToDirectObject (obj ).(*PdfObjectInteger );return _egfd ,_bcgf ;};

// Merge merges in key/values from another dictionary. Overwriting if has same keys.
// The mutated dictionary (d) is returned in order to allow method chaining.
func (_cggf *PdfObjectDictionary )Merge (another *PdfObjectDictionary )*PdfObjectDictionary {if another !=nil {for _ ,_cfggg :=range another .Keys (){_fffc :=another .Get (_cfggg );_cggf .Set (_cfggg ,_fffc );};};return _cggf ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_fgcg *RunLengthEncoder )MakeDecodeParams ()PdfObject {return nil };func _cbg (_egbb *PdfObjectStream ,_fgbg *PdfObjectDictionary )(*RunLengthEncoder ,error ){return NewRunLengthEncoder (),nil ;};

// GetFilterName returns the name of the encoding filter.
func (_dfcg *JPXEncoder )GetFilterName ()string {return StreamEncodingFilterNameJPX };

// AddPageImage adds the page with the image 'img' to the encoder context in order to encode it jbig2 document.
// The 'settings' defines what encoding type should be used by the encoder.
func (_dceb *JBIG2Encoder )AddPageImage (img *JBIG2Image ,settings *JBIG2EncoderSettings )(_agfb error ){const _eca ="\u004a\u0042\u0049\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0041\u0064\u0064\u0050\u0061\u0067\u0065\u0049m\u0061\u0067\u0065";if _dceb ==nil {return _aa .Error (_eca ,"J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u0020\u0069\u0073 n\u0069\u006c");};if settings ==nil {settings =&_dceb .DefaultPageSettings ;};if _dceb ._adea ==nil {_dceb ._adea =_bc .InitEncodeDocument (settings .FileMode );};if _agfb =settings .Validate ();_agfb !=nil {return _aa .Wrap (_agfb ,_eca ,"");};_edfc ,_agfb :=img .toBitmap ();if _agfb !=nil {return _aa .Wrap (_agfb ,_eca ,"");};switch settings .Compression {case JB2Generic :if _agfb =_dceb ._adea .AddGenericPage (_edfc ,settings .DuplicatedLinesRemoval );_agfb !=nil {return _aa .Wrap (_agfb ,_eca ,"");};case JB2SymbolCorrelation :return _aa .Error (_eca ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");case JB2SymbolRankHaus :return _aa .Error (_eca ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");default:return _aa .Error (_eca ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return nil ;};func (_efcg *PdfParser )parseXrefStream (_bcaab *PdfObjectInteger )(*PdfObjectDictionary ,error ){if _bcaab !=nil {_beg .Log .Trace ("\u0058\u0052\u0065f\u0053\u0074\u006d\u0020x\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0061\u0074\u0020\u0025\u0064",_bcaab );_efcg ._bdff .Seek (int64 (*_bcaab ),_cg .SeekStart );_efcg ._cdff =_gf .NewReader (_efcg ._bdff );};_dfca :=_efcg .GetFileOffset ();_ebbc ,_agbc :=_efcg .ParseIndirectObject ();if _agbc !=nil {_beg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072\u0065\u0061d\u0020\u0078\u0072\u0065\u0066\u0020\u006fb\u006a\u0065\u0063\u0074");return nil ,_e .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072e\u0061\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062j\u0065\u0063\u0074");};_beg .Log .Trace ("\u0058R\u0065f\u0053\u0074\u006d\u0020\u006fb\u006a\u0065c\u0074\u003a\u0020\u0025\u0073",_ebbc );_cgfef ,_fbbfe :=_ebbc .(*PdfObjectStream );if !_fbbfe {_beg .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0058R\u0065\u0066\u0053\u0074\u006d\u0020\u0070o\u0069\u006e\u0074\u0069\u006e\u0067 \u0074\u006f\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065a\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0021");return nil ,_e .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0070\u006f\u0069\u006e\u0074i\u006e\u0067\u0020\u0074\u006f\u0020a\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006fb\u006a\u0065\u0063\u0074");};_aacf :=_cgfef .PdfObjectDictionary ;_bdee ,_fbbfe :=_cgfef .PdfObjectDictionary .Get ("\u0053\u0069\u007a\u0065").(*PdfObjectInteger );if !_fbbfe {_beg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u004d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0073\u0069\u007a\u0065\u0020f\u0072\u006f\u006d\u0020\u0078\u0072\u0065f\u0020\u0073\u0074\u006d");return nil ,_e .New ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0053\u0069\u007ae\u0020\u0066\u0072\u006f\u006d\u0020\u0078\u0072\u0065\u0066 \u0073\u0074\u006d");};if int64 (*_bdee )> 8388607{_beg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u0053\u0069\u007a\u0065\u0020\u0065x\u0063\u0065\u0065\u0064\u0065\u0064\u0020l\u0069\u006d\u0069\u0074\u002c\u0020\u006f\u0076\u0065\u0072\u00208\u0033\u0038\u0038\u0036\u0030\u0037\u0020\u0028\u0025\u0064\u0029",*_bdee );return nil ,_e .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_dafe :=_cgfef .PdfObjectDictionary .Get ("\u0057");_abca ,_fbbfe :=_dafe .(*PdfObjectArray );if !_fbbfe {return nil ,_e .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0057\u0020\u0069\u006e\u0020x\u0072\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d");};_ega :=_abca .Len ();if _ega !=3{_beg .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020\u0028\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033\u0020\u002d\u0020\u0025\u0064\u0029",_ega );return nil ,_e .New ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065f\u0020s\u0074\u006d\u0020\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033");};var _efff []int64 ;for _eeed :=0;_eeed < 3;_eeed ++{_eccd ,_aaaef :=GetInt (_abca .Get (_eeed ));if !_aaaef {return nil ,_e .New ("i\u006e\u0076\u0061\u006cid\u0020w\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0074\u0079\u0070\u0065");};_efff =append (_efff ,int64 (*_eccd ));};_bacb ,_agbc :=DecodeStream (_cgfef );if _agbc !=nil {_beg .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020t\u006f \u0064e\u0063o\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u003a\u0020\u0025\u0076",_agbc );return nil ,_agbc ;};_bcbf :=int (_efff [0]);_acef :=int (_efff [0]+_efff [1]);_eaeea :=int (_efff [0]+_efff [1]+_efff [2]);_badc :=int (_efff [0]+_efff [1]+_efff [2]);if _bcbf < 0||_acef < 0||_eaeea < 0{_beg .Log .Debug ("\u0045\u0072\u0072\u006fr\u0020\u0073\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u003c \u0030 \u0028\u0025\u0064\u002c\u0025\u0064\u002c%\u0064\u0029",_bcbf ,_acef ,_eaeea );return nil ,_e .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};if _badc ==0{_beg .Log .Debug ("\u004e\u006f\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063t\u0073\u0020\u0069\u006e\u0020\u0073t\u0072\u0065\u0061\u006d\u0020\u0028\u0064\u0065\u006c\u0074\u0061\u0062\u0020=\u003d\u0020\u0030\u0029");return _aacf ,nil ;};_dgfc :=len (_bacb )/_badc ;_efcd :=0;_gedd :=_cgfef .PdfObjectDictionary .Get ("\u0049\u006e\u0064e\u0078");var _edbc []int ;if _gedd !=nil {_beg .Log .Trace ("\u0049n\u0064\u0065\u0078\u003a\u0020\u0025b",_gedd );_edad ,_bcdd :=_gedd .(*PdfObjectArray );if !_bcdd {_beg .Log .Debug ("\u0049\u006e\u0076\u0061\u006ci\u0064\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0029");return nil ,_e .New ("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0049\u006e\u0064e\u0078\u0020\u006f\u0062je\u0063\u0074");};if _edad .Len ()%2!=0{_beg .Log .Debug ("\u0057\u0041\u0052\u004eI\u004e\u0047\u0020\u0046\u0061\u0069\u006c\u0075\u0072e\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020i\u006e\u0064\u0065\u0078\u0020n\u006f\u0074\u0020\u006d\u0075\u006c\u0074\u0069\u0070\u006c\u0065\u0020\u006f\u0066\u0020\u0032\u002e");return nil ,_e .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_efcd =0;_afgb ,_acab :=_edad .ToIntegerArray ();if _acab !=nil {_beg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072 \u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0065\u0078 \u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0073\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0073\u003a\u0020\u0025\u0076",_acab );return nil ,_acab ;};for _dggc :=0;_dggc < len (_afgb );_dggc +=2{_acdg :=_afgb [_dggc ];_ebe :=_afgb [_dggc +1];for _dgdf :=0;_dgdf < _ebe ;_dgdf ++{_edbc =append (_edbc ,_acdg +_dgdf );};_efcd +=_ebe ;};}else {for _ecdd :=0;_ecdd < int (*_bdee );_ecdd ++{_edbc =append (_edbc ,_ecdd );};_efcd =int (*_bdee );};if _dgfc ==_efcd +1{_beg .Log .Debug ("\u0049n\u0063\u006f\u006d\u0070ati\u0062\u0069\u006c\u0069t\u0079\u003a\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006di\u0073\u0073\u0069\u006e\u0067\u0020\u0063\u006f\u0076\u0065\u0072\u0061\u0067\u0065\u0020\u006f\u0066\u0020\u0031\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u002d\u0020\u0061\u0070\u0070en\u0064\u0069\u006eg\u0020\u006f\u006e\u0065\u0020-\u0020M\u0061\u0079\u0020\u006c\u0065\u0061\u0064\u0020\u0074o\u0020\u0070\u0072\u006f\u0062\u006c\u0065\u006d\u0073");_egcc :=_efcd -1;for _ ,_bfb :=range _edbc {if _bfb > _egcc {_egcc =_bfb ;};};_edbc =append (_edbc ,_egcc +1);_efcd ++;};if _dgfc !=len (_edbc ){_beg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020x\u0072\u0065\u0066 \u0073\u0074\u006d:\u0020\u006eu\u006d\u0020\u0065\u006e\u0074\u0072i\u0065s \u0021\u003d\u0020\u006c\u0065\u006e\u0028\u0069\u006e\u0064\u0069\u0063\u0065\u0073\u0029\u0020\u0028\u0025\u0064\u0020\u0021\u003d\u0020\u0025\u0064\u0029",_dgfc ,len (_edbc ));return nil ,_e .New ("\u0078\u0072ef\u0020\u0073\u0074m\u0020\u006e\u0075\u006d en\u0074ri\u0065\u0073\u0020\u0021\u003d\u0020\u006cen\u0028\u0069\u006e\u0064\u0069\u0063\u0065s\u0029");};_beg .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074s\u0020\u0063\u006f\u0075\u006e\u0074\u0020\u0025\u0064",_efcd );_beg .Log .Trace ("\u0049\u006e\u0064i\u0063\u0065\u0073\u003a\u0020\u0025\u0020\u0064",_edbc );_cgdc :=func (_acdge []byte )int64 {var _deba int64 ;for _debc :=0;_debc < len (_acdge );_debc ++{_deba +=int64 (_acdge [_debc ])*(1<<uint (8*(len (_acdge )-_debc -1)));};return _deba ;};_beg .Log .Trace ("\u0044e\u0063\u006f\u0064\u0065d\u0020\u0073\u0074\u0072\u0065a\u006d \u006ce\u006e\u0067\u0074\u0068\u003a\u0020\u0025d",len (_bacb ));_gcbgd :=0;for _cabe :=0;_cabe < len (_bacb );_cabe +=_badc {_facb :=_efeg (len (_bacb ),_cabe ,_cabe +_bcbf );if _facb !=nil {_beg .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_facb );return nil ,_facb ;};_ccbea :=_bacb [_cabe :_cabe +_bcbf ];_facb =_efeg (len (_bacb ),_cabe +_bcbf ,_cabe +_acef );if _facb !=nil {_beg .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_facb );return nil ,_facb ;};_dfdb :=_bacb [_cabe +_bcbf :_cabe +_acef ];_facb =_efeg (len (_bacb ),_cabe +_acef ,_cabe +_eaeea );if _facb !=nil {_beg .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_facb );return nil ,_facb ;};_fedda :=_bacb [_cabe +_acef :_cabe +_eaeea ];_fbffg :=_cgdc (_ccbea );_abgg :=_cgdc (_dfdb );_dbcd :=_cgdc (_fedda );if _efff [0]==0{_fbffg =1;};if _gcbgd >=len (_edbc ){_beg .Log .Debug ("X\u0052\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u002d\u0020\u0054\u0072\u0079\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0061\u0063\u0063e\u0073s\u0020\u0069\u006e\u0064e\u0078\u0020o\u0075\u0074\u0020\u006f\u0066\u0020\u0062\u006f\u0075\u006e\u0064\u0073\u0020\u002d\u0020\u0062\u0072\u0065\u0061\u006b\u0069\u006e\u0067");break ;};_edgda :=_edbc [_gcbgd ];_gcbgd ++;_beg .Log .Trace ("%\u0064\u002e\u0020\u0070\u0031\u003a\u0020\u0025\u0020\u0078",_edgda ,_ccbea );_beg .Log .Trace ("%\u0064\u002e\u0020\u0070\u0032\u003a\u0020\u0025\u0020\u0078",_edgda ,_dfdb );_beg .Log .Trace ("%\u0064\u002e\u0020\u0070\u0033\u003a\u0020\u0025\u0020\u0078",_edgda ,_fedda );_beg .Log .Trace ("\u0025d\u002e \u0078\u0072\u0065\u0066\u003a \u0025\u0064 \u0025\u0064\u0020\u0025\u0064",_edgda ,_fbffg ,_abgg ,_dbcd );if _fbffg ==0{_beg .Log .Trace ("-\u0020\u0046\u0072\u0065\u0065\u0020o\u0062\u006a\u0065\u0063\u0074\u0020-\u0020\u0063\u0061\u006e\u0020\u0070\u0072o\u0062\u0061\u0062\u006c\u0079\u0020\u0069\u0067\u006e\u006fr\u0065");}else if _fbffg ==1{_beg .Log .Trace ("\u002d\u0020I\u006e\u0020\u0075\u0073e\u0020\u002d \u0075\u006e\u0063\u006f\u006d\u0070\u0072\u0065s\u0073\u0065\u0064\u0020\u0076\u0069\u0061\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0062",_dfdb );if _abgg ==_dfca {_beg .Log .Debug ("\u0055\u0070d\u0061\u0074\u0069\u006e\u0067\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0058\u0052\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0064",_edgda ,_cgfef .ObjectNumber );_edgda =int (_cgfef .ObjectNumber );};if _cgfd ,_gddgg :=_efcg ._bbda .ObjectMap [_edgda ];!_gddgg ||int (_dbcd )> _cgfd .Generation {_afbgf :=XrefObject {ObjectNumber :_edgda ,XType :XrefTypeTableEntry ,Offset :_abgg ,Generation :int (_dbcd )};_efcg ._bbda .ObjectMap [_edgda ]=_afbgf ;};}else if _fbffg ==2{_beg .Log .Trace ("\u002d\u0020\u0049\u006e \u0075\u0073\u0065\u0020\u002d\u0020\u0063\u006f\u006d\u0070r\u0065s\u0073\u0065\u0064\u0020\u006f\u0062\u006ae\u0063\u0074");if _ ,_bgae :=_efcg ._bbda .ObjectMap [_edgda ];!_bgae {_dgec :=XrefObject {ObjectNumber :_edgda ,XType :XrefTypeObjectStream ,OsObjNumber :int (_abgg ),OsObjIndex :int (_dbcd )};_efcg ._bbda .ObjectMap [_edgda ]=_dgec ;_beg .Log .Trace ("\u0065\u006e\u0074\u0072\u0079\u003a\u0020\u0025\u002b\u0076",_dgec );};}else {_beg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052:\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0056\u0041L\u0049\u0044\u0020\u0054\u0059\u0050\u0045\u0020\u0058\u0072\u0065\u0066\u0053\u0074\u006d\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u003f\u002d\u002d\u002d\u002d\u002d\u002d-");continue ;};};if _efcg ._bdaa ==nil {_ccaf :=XrefTypeObjectStream ;_efcg ._bdaa =&_ccaf ;};return _aacf ,nil ;};

// DecodeGlobals decodes 'encoded' byte stream and returns their Globally defined segments ('Globals').
func (_gdf *JBIG2Encoder )DecodeGlobals (encoded []byte )(_gae .Globals ,error ){return _gae .DecodeGlobals (encoded );};

// SetImage sets the image base for given flate encoder.
func (_bec *FlateEncoder )SetImage (img *_da .ImageBase ){_bec ._fbbe =img };

// UpdateParams updates the parameter values of the encoder.
func (_agbgd *ASCII85Encoder )UpdateParams (params *PdfObjectDictionary ){};func (_ad *PdfParser )lookupObjectViaOS (_caea int ,_db int )(PdfObject ,error ){var _ffg *_gec .Reader ;var _fe objectStream ;var _cf bool ;_fe ,_cf =_ad ._ecca [_caea ];if !_cf {_abd ,_ea :=_ad .LookupByNumber (_caea );if _ea !=nil {_beg .Log .Debug ("\u004d\u0069ss\u0069\u006e\u0067 \u006f\u0062\u006a\u0065ct \u0073tr\u0065\u0061\u006d\u0020\u0077\u0069\u0074h \u006e\u0075\u006d\u0062\u0065\u0072\u0020%\u0064",_caea );return nil ,_ea ;};_af ,_ccb :=_abd .(*PdfObjectStream );if !_ccb {return nil ,_e .New ("i\u006e\u0076\u0061\u006cid\u0020o\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d");};if _ad ._ccddd !=nil &&!_ad ._ccddd .isDecrypted (_af ){return nil ,_e .New ("\u006e\u0065\u0065\u0064\u0020\u0074\u006f\u0020\u0064\u0065\u0063r\u0079\u0070\u0074\u0020\u0074\u0068\u0065\u0020\u0073\u0074r\u0065\u0061\u006d");};_aff :=_af .PdfObjectDictionary ;_beg .Log .Trace ("\u0073o\u0020\u0064\u003a\u0020\u0025\u0073\n",_aff .String ());_cdd ,_ccb :=_aff .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if !_ccb {_beg .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0061\u006c\u0077\u0061\u0079\u0073\u0020\u0068\u0061\u0076\u0065\u0020\u0061\u0020\u0054\u0079\u0070\u0065");return nil ,_e .New ("\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020T\u0079\u0070\u0065");};if _d .ToLower (string (*_cdd ))!="\u006f\u0062\u006a\u0073\u0074\u006d"{_beg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0074\u0079\u0070\u0065\u0020s\u0068\u0061\u006c\u006c\u0020\u0061\u006c\u0077\u0061\u0079\u0073 \u0062\u0065\u0020\u004f\u0062\u006a\u0053\u0074\u006d\u0020\u0021");return nil ,_e .New ("\u006f\u0062\u006a\u0065c\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0074y\u0070e\u0020\u0021\u003d\u0020\u004f\u0062\u006aS\u0074\u006d");};N ,_ccb :=_aff .Get ("\u004e").(*PdfObjectInteger );if !_ccb {return nil ,_e .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u004e\u0020i\u006e\u0020\u0073\u0074\u0072\u0065\u0061m\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_bg ,_ccb :=_aff .Get ("\u0046\u0069\u0072s\u0074").(*PdfObjectInteger );if !_ccb {return nil ,_e .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0046\u0069\u0072\u0073\u0074\u0020i\u006e \u0073t\u0072e\u0061\u006d\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_beg .Log .Trace ("\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0073\u0020\u006eu\u006d\u0062\u0065\u0072\u0020\u006f\u0066 \u006f\u0062\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_cdd ,*N );_gfb ,_ea :=DecodeStream (_af );if _ea !=nil {return nil ,_ea ;};_beg .Log .Trace ("D\u0065\u0063\u006f\u0064\u0065\u0064\u003a\u0020\u0025\u0073",_gfb );_aae :=_ad .GetFileOffset ();defer func (){_ad .SetFileOffset (_aae )}();_ffg =_gec .NewReader (_gfb );_ad ._cdff =_gf .NewReader (_ffg );_beg .Log .Trace ("\u0050a\u0072s\u0069\u006e\u0067\u0020\u006ff\u0066\u0073e\u0074\u0020\u006d\u0061\u0070");_eae :=map[int ]int64 {};for _dg :=0;_dg < int (*N );_dg ++{_ad .skipSpaces ();_fd ,_gc :=_ad .parseNumber ();if _gc !=nil {return nil ,_gc ;};_gba ,_fa :=_fd .(*PdfObjectInteger );if !_fa {return nil ,_e .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");};_ad .skipSpaces ();_fd ,_gc =_ad .parseNumber ();if _gc !=nil {return nil ,_gc ;};_gfbb ,_fa :=_fd .(*PdfObjectInteger );if !_fa {return nil ,_e .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");};_beg .Log .Trace ("\u006f\u0062j\u0020\u0025\u0064 \u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0025\u0064",*_gba ,*_gfbb );_eae [int (*_gba )]=int64 (*_bg +*_gfbb );};_fe =objectStream {N :int (*N ),_bea :_gfb ,_gd :_eae };_ad ._ecca [_caea ]=_fe ;}else {_ac :=_ad .GetFileOffset ();defer func (){_ad .SetFileOffset (_ac )}();_ffg =_gec .NewReader (_fe ._bea );_ad ._cdff =_gf .NewReader (_ffg );};_fgd :=_fe ._gd [_db ];_beg .Log .Trace ("\u0041\u0043\u0054\u0055AL\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u005b\u0025\u0064\u005d\u0020\u003d\u0020%\u0064",_db ,_fgd );_ffg .Seek (_fgd ,_bf .SEEK_SET );_ad ._cdff =_gf .NewReader (_ffg );_ed ,_ :=_ad ._cdff .Peek (100);_beg .Log .Trace ("\u004f\u0042\u004a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_ed ));_ecd ,_ccd :=_ad .parseObject ();if _ccd !=nil {_beg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c \u0074\u006f\u0020\u0072\u0065\u0061\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_ccd );return nil ,_ccd ;};if _ecd ==nil {return nil ,_e .New ("o\u0062\u006a\u0065\u0063t \u0063a\u006e\u006e\u006f\u0074\u0020b\u0065\u0020\u006e\u0075\u006c\u006c");};_agb :=PdfIndirectObject {};_agb .ObjectNumber =int64 (_db );_agb .PdfObject =_ecd ;return &_agb ,nil ;};func _cfgd (_geba int )int {if _geba < 0{return -_geba ;};return _geba ;};

// MakeArrayFromIntegers64 creates an PdfObjectArray from a slice of int64s, where each array element
// is an PdfObjectInteger.
func MakeArrayFromIntegers64 (vals []int64 )*PdfObjectArray {_cdfg :=MakeArray ();for _ ,_eecff :=range vals {_cdfg .Append (MakeInteger (_eecff ));};return _cdfg ;};const (XrefTypeTableEntry xrefType =iota ;XrefTypeObjectStream xrefType =iota ;);

// IsNullObject returns true if `obj` is a PdfObjectNull.
func IsNullObject (obj PdfObject )bool {_ ,_dggef :=TraceToDirectObject (obj ).(*PdfObjectNull );return _dggef ;};

// MakeFloat creates an PdfObjectFloat from a float64.
func MakeFloat (val float64 )*PdfObjectFloat {_ggfe :=PdfObjectFloat (val );return &_ggfe };

// Append appends PdfObject(s) to the array.
func (_fagg *PdfObjectArray )Append (objects ...PdfObject ){if _fagg ==nil {_beg .Log .Debug ("\u0057\u0061\u0072\u006e\u0020\u002d\u0020\u0041\u0074\u0074\u0065\u006d\u0070t\u0020\u0074\u006f\u0020\u0061\u0070p\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020a\u0072\u0072\u0061\u0079");return ;};if _fagg ._fbcce ==nil {_fagg ._fbcce =[]PdfObject {};};for _ ,_gbad :=range objects {_fagg ._fbcce =append (_fagg ._fbcce ,_gbad );};};func _abcea (_edgec ,_cdea PdfObject ,_ebad int )bool {if _ebad > _gbab {_beg .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_gbab );return false ;};if _edgec ==nil &&_cdea ==nil {return true ;}else if _edgec ==nil ||_cdea ==nil {return false ;};if _f .TypeOf (_edgec )!=_f .TypeOf (_cdea ){return false ;};switch _cced :=_edgec .(type ){case *PdfObjectNull ,*PdfObjectReference :return true ;case *PdfObjectName :return *_cced ==*(_cdea .(*PdfObjectName ));case *PdfObjectString :return *_cced ==*(_cdea .(*PdfObjectString ));case *PdfObjectInteger :return *_cced ==*(_cdea .(*PdfObjectInteger ));case *PdfObjectBool :return *_cced ==*(_cdea .(*PdfObjectBool ));case *PdfObjectFloat :return *_cced ==*(_cdea .(*PdfObjectFloat ));case *PdfIndirectObject :return _abcea (TraceToDirectObject (_edgec ),TraceToDirectObject (_cdea ),_ebad +1);case *PdfObjectArray :_cbaa :=_cdea .(*PdfObjectArray );if len ((*_cced )._fbcce )!=len ((*_cbaa )._fbcce ){return false ;};for _cfag ,_aabe :=range (*_cced )._fbcce {if !_abcea (_aabe ,(*_cbaa )._fbcce [_cfag ],_ebad +1){return false ;};};return true ;case *PdfObjectDictionary :_bgead :=_cdea .(*PdfObjectDictionary );_bcfff ,_begd :=(*_cced )._ggagd ,(*_bgead )._ggagd ;if len (_bcfff )!=len (_begd ){return false ;};for _cdge ,_eccga :=range _bcfff {_geeaf ,_gbdf :=_begd [_cdge ];if !_gbdf ||!_abcea (_eccga ,_geeaf ,_ebad +1){return false ;};};return true ;case *PdfObjectStream :_adeeb :=_cdea .(*PdfObjectStream );return _abcea ((*_cced ).PdfObjectDictionary ,(*_adeeb ).PdfObjectDictionary ,_ebad +1);default:_beg .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",_edgec );};return false ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_dfbbc *DCTEncoder )MakeDecodeParams ()PdfObject {return nil };

// DecodeStream decodes a FlateEncoded stream object and give back decoded bytes.
func (_ccbc *FlateEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_beg .Log .Trace ("\u0046l\u0061t\u0065\u0044\u0065\u0063\u006fd\u0065\u0020s\u0074\u0072\u0065\u0061\u006d");_beg .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_ccbc .Predictor );if _ccbc .BitsPerComponent !=8{return nil ,_ff .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003d\u0025\u0064\u0020\u0028\u006f\u006e\u006c\u0079\u0020\u0038\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0029",_ccbc .BitsPerComponent );};_gede ,_dbdb :=_ccbc .DecodeBytes (streamObj .Stream );if _dbdb !=nil {return nil ,_dbdb ;};_gede ,_dbdb =_ccbc .postDecodePredict (_gede );if _dbdb !=nil {return nil ,_dbdb ;};return _ccbc .cleanImageData (_gede );};

// MakeString creates an PdfObjectString from a string.
// NOTE: PDF does not use utf-8 string encoding like Go so `s` will often not be a utf-8 encoded
// string.
func MakeString (s string )*PdfObjectString {_agbcc :=PdfObjectString {_aabg :s };return &_agbcc };func (_aageg *PdfParser )skipComments ()error {if _ ,_abc :=_aageg .skipSpaces ();_abc !=nil {return _abc ;};_bdffb :=true ;for {_ggcg ,_efbd :=_aageg ._cdff .Peek (1);if _efbd !=nil {_beg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_efbd .Error ());return _efbd ;};if _bdffb &&_ggcg [0]!='%'{return nil ;};_bdffb =false ;if (_ggcg [0]!='\r')&&(_ggcg [0]!='\n'){_aageg ._cdff .ReadByte ();}else {break ;};};return _aageg .skipComments ();};

// DecodeImages decodes the page images from the jbig2 'encoded' data input.
// The jbig2 document may contain multiple pages, thus the function can return multiple
// images. The images order corresponds to the page number.
func (_gdfg *JBIG2Encoder )DecodeImages (encoded []byte )([]_ga .Image ,error ){const _dfecb ="\u004aB\u0049\u0047\u0032\u0045n\u0063\u006f\u0064\u0065\u0072.\u0044e\u0063o\u0064\u0065\u0049\u006d\u0061\u0067\u0065s";_ecec ,_aeeb :=_cc .Decode (encoded ,_cc .Parameters {},_gdfg .Globals .ToDocumentGlobals ());if _aeeb !=nil {return nil ,_aa .Wrap (_aeeb ,_dfecb ,"");};_ecde ,_aeeb :=_ecec .PageNumber ();if _aeeb !=nil {return nil ,_aa .Wrap (_aeeb ,_dfecb ,"");};_abbf :=[]_ga .Image {};var _fdbf _ga .Image ;for _faef :=1;_faef <=_ecde ;_faef ++{_fdbf ,_aeeb =_ecec .DecodePageImage (_faef );if _aeeb !=nil {return nil ,_aa .Wrapf (_aeeb ,_dfecb ,"\u0070\u0061\u0067\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_faef );};_abbf =append (_abbf ,_fdbf );};return _abbf ,nil ;};

// IsDecimalDigit checks if the character is a part of a decimal number string.
func IsDecimalDigit (c byte )bool {return '0'<=c &&c <='9'};

// GetStringBytes is like GetStringVal except that it returns the string as a []byte.
// It is for convenience.
func GetStringBytes (obj PdfObject )(_dfcc []byte ,_affc bool ){_cccb ,_affc :=TraceToDirectObject (obj ).(*PdfObjectString );if _affc {return _cccb .Bytes (),true ;};return ;};func (_bda *PdfCrypt )checkAccessRights (_dea []byte )(bool ,_bca .Permissions ,error ){_cfc :=_bda .securityHandler ();_cacb ,_gea ,_gfae :=_cfc .Authenticate (&_bda ._aba ,_dea );if _gfae !=nil {return false ,0,_gfae ;}else if _gea ==0||len (_cacb )==0{return false ,0,nil ;};return true ,_gea ,nil ;};

// FlattenObject returns the contents of `obj`. In other words, `obj` with indirect objects replaced
// by their values.
// The replacements are made recursively to a depth of traceMaxDepth.
// NOTE: Dicts are sorted to make objects with same contents have the same PDF object strings.
func FlattenObject (obj PdfObject )PdfObject {return _agfg (obj ,0)};

// MakeDict creates and returns an empty PdfObjectDictionary.
func MakeDict ()*PdfObjectDictionary {_ebdd :=&PdfObjectDictionary {};_ebdd ._ggagd =map[PdfObjectName ]PdfObject {};_ebdd ._edcg =[]PdfObjectName {};return _ebdd ;};

// GetXrefTable returns the PDFs xref table.
func (_cdfd *PdfParser )GetXrefTable ()XrefTable {return _cdfd ._bbda };func (_cfd *PdfCrypt )isDecrypted (_fcae PdfObject )bool {_ ,_fea :=_cfd ._ggd [_fcae ];if _fea {_beg .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0064\u0065\u0063\u0072y\u0070\u0074\u0065\u0064");return true ;};switch _geg :=_fcae .(type ){case *PdfObjectStream :if _cfd ._aba .R !=5{if _cba ,_efbb :=_geg .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_efbb &&*_cba =="\u0058\u0052\u0065\u0066"{return true ;};};case *PdfIndirectObject :if _ ,_fea =_cfd ._bcc [int (_geg .ObjectNumber )];_fea {return true ;};switch _caed :=_geg .PdfObject .(type ){case *PdfObjectDictionary :_dad :=true ;for _ ,_gdb :=range _abdg {if _caed .Get (_gdb )==nil {_dad =false ;break ;};};if _dad {return true ;};};};_beg .Log .Trace ("\u004e\u006f\u0074\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");return false ;};var _cedc =_ef .MustCompile ("\u0025\u0025\u0045\u004f\u0046\u003f");

// DecodeStream decodes a JBIG2 encoded stream and returns the result as a slice of bytes.
func (_gggg *JBIG2Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _gggg .DecodeBytes (streamObj .Stream );};func _gbbd (_bcfd *PdfObjectStream ,_bgfbc *PdfObjectDictionary )(*JBIG2Encoder ,error ){const _dece ="\u006ee\u0077\u004a\u0042\u0049G\u0032\u0044\u0065\u0063\u006fd\u0065r\u0046r\u006f\u006d\u0053\u0074\u0072\u0065\u0061m";_cfbgc :=&JBIG2Encoder {};_eaefa :=_bcfd .PdfObjectDictionary ;if _eaefa ==nil {return _cfbgc ,nil ;};if _bgfbc ==nil {_agaf :=_eaefa .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _agaf !=nil {switch _fedg :=_agaf .(type ){case *PdfObjectDictionary :_bgfbc =_fedg ;case *PdfObjectArray :if _fedg .Len ()==1{if _deed ,_bef :=GetDict (_fedg .Get (0));_bef {_bgfbc =_deed ;};};default:_beg .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065P\u0061\u0072\u0061\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064i\u0063\u0074\u0069\u006f\u006e\u0061\u0072y\u0020\u0025\u0023\u0076",_agaf );return nil ,_aa .Errorf (_dece ,"\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050a\u0072m\u0073\u0020\u0074\u0079\u0070\u0065\u003a \u0025\u0054",_fedg );};};};if _bgfbc ==nil {return _cfbgc ,nil ;};_cfbgc .UpdateParams (_bgfbc );_eadag :=_bgfbc .Get ("\u004a\u0042\u0049G\u0032\u0047\u006c\u006f\u0062\u0061\u006c\u0073");if _eadag ==nil {return _cfbgc ,nil ;};var _ccdc error ;_cfcda ,_agbe :=_eadag .(*PdfObjectStream );if !_agbe {_ccdc =_aa .Error (_dece ,"j\u0062\u0069\u0067\u0032\u002e\u0047\u006c\u006f\u0062a\u006c\u0073\u0020\u0073\u0074\u0072\u0065am\u0020\u0073\u0068\u006fu\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u006e\u0020Ob\u006a\u0065c\u0074\u0020\u0053\u0074\u0072\u0065\u0061\u006d");_beg .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_ccdc );return nil ,_ccdc ;};_cfbgc .Globals ,_ccdc =_gae .DecodeGlobals (_cfcda .Stream );if _ccdc !=nil {_ccdc =_aa .Wrap (_ccdc ,_dece ,"\u0063\u006f\u0072\u0072u\u0070\u0074\u0065\u0064\u0020\u006a\u0062\u0069\u0067\u0032 \u0065n\u0063\u006f\u0064\u0065\u0064\u0020\u0064a\u0074\u0061");_beg .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_ccdc );return nil ,_ccdc ;};return _cfbgc ,nil ;};

// EncryptInfo contains an information generated by the document encrypter.
type EncryptInfo struct{Version ;

// Encrypt is an encryption dictionary that contains all necessary parameters.
// It should be stored in all copies of the document trailer.
Encrypt *PdfObjectDictionary ;

// ID0 and ID1 are IDs used in the trailer. Older algorithms such as RC4 uses them for encryption.
ID0 ,ID1 string ;};

// Append appends PdfObject(s) to the streams.
func (_gdfb *PdfObjectStreams )Append (objects ...PdfObject ){if _gdfb ==nil {_beg .Log .Debug ("\u0057\u0061\u0072\u006e\u0020-\u0020\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0020\u0074\u006f\u0020\u0061p\u0070\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0073");return ;};if _gdfb ._acec ==nil {_gdfb ._acec =[]PdfObject {};};for _ ,_baad :=range objects {_gdfb ._acec =append (_gdfb ._acec ,_baad );};};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_bcef *CCITTFaxEncoder )MakeStreamDict ()*PdfObjectDictionary {_fbffd :=MakeDict ();_fbffd .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_bcef .GetFilterName ()));_dbe :=_bcef .MakeDecodeParams ();if _dbe !=nil {_fbffd .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_dbe );};return _fbffd ;};type objectStreams map[int ]objectStream ;const _gbab =10;func (_bfbea *PdfObjectFloat )String ()string {return _ff .Sprintf ("\u0025\u0066",*_bfbea )};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_aga *MultiEncoder )MakeStreamDict ()*PdfObjectDictionary {_efadf :=MakeDict ();_efadf .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",_aga .GetFilterArray ());for _ ,_dfdc :=range _aga ._ccc {_affeee :=_dfdc .MakeStreamDict ();for _ ,_gde :=range _affeee .Keys (){_abdge :=_affeee .Get (_gde );if _gde !="\u0046\u0069\u006c\u0074\u0065\u0072"&&_gde !="D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"{_efadf .Set (_gde ,_abdge );};};};_dbde :=_aga .MakeDecodeParams ();if _dbde !=nil {_efadf .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_dbde );};return _efadf ;};func _bcdc (_agg ,_ffce ,_efgc uint8 )uint8 {_bcebb :=int (_efgc );_adcc :=int (_ffce )-_bcebb ;_gfde :=int (_agg )-_bcebb ;_bcebb =_agfc (_adcc +_gfde );_adcc =_agfc (_adcc );_gfde =_agfc (_gfde );if _adcc <=_gfde &&_adcc <=_bcebb {return _agg ;}else if _gfde <=_bcebb {return _ffce ;};return _efgc ;};const (JB2Generic JBIG2CompressionType =iota ;JB2SymbolCorrelation ;JB2SymbolRankHaus ;);

// Version represents a version of a PDF standard.
type Version struct{Major int ;Minor int ;};func (_ebg *PdfCrypt )makeKey (_efbg string ,_fbbf ,_aaed uint32 ,_cfeg []byte )([]byte ,error ){_aac ,_dag :=_ebg ._dbf [_efbg ];if !_dag {return nil ,_ff .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_efbg );};return _aac .MakeKey (_fbbf ,_aaed ,_cfeg );};

// PdfObjectStreams represents the primitive PDF object streams.
// 7.5.7 Object Streams (page 45).
type PdfObjectStreams struct{PdfObjectReference ;_acec []PdfObject ;};func (_geea *PdfObjectInteger )String ()string {return _ff .Sprintf ("\u0025\u0064",*_geea )};

// UpdateParams updates the parameter values of the encoder.
// Implements StreamEncoder interface.
func (_bfcd *JBIG2Encoder )UpdateParams (params *PdfObjectDictionary ){_afbda ,_ecc :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _ecc ==nil {_bfcd .BitsPerComponent =int (_afbda );};_afdf ,_ecc :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _ecc ==nil {_bfcd .Width =int (_afdf );};_gbfg ,_ecc :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _ecc ==nil {_bfcd .Height =int (_gbfg );};_effe ,_ecc :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _ecc ==nil {_bfcd .ColorComponents =int (_effe );};};func (_eea *PdfCrypt )loadCryptFilters (_cbf *PdfObjectDictionary )error {_eea ._dbf =cryptFilters {};_fdc :=_cbf .Get ("\u0043\u0046");_fdc =TraceToDirectObject (_fdc );if _fbg ,_cbe :=_fdc .(*PdfObjectReference );_cbe {_fc ,_afb :=_eea ._cbb .LookupByReference (*_fbg );if _afb !=nil {_beg .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0075\u0070\u0020\u0043\u0046\u0020\u0072\u0065\u0066\u0065\u0072en\u0063\u0065");return _afb ;};_fdc =TraceToDirectObject (_fc );};_gbgg ,_fcc :=_fdc .(*PdfObjectDictionary );if !_fcc {_beg .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0043\u0046\u002c \u0074\u0079\u0070\u0065: \u0025\u0054",_fdc );return _e .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0043\u0046");};for _ ,_bafb :=range _gbgg .Keys (){_dgf :=_gbgg .Get (_bafb );if _fbe ,_agd :=_dgf .(*PdfObjectReference );_agd {_daef ,_afe :=_eea ._cbb .LookupByReference (*_fbe );if _afe !=nil {_beg .Log .Debug ("\u0045\u0072ro\u0072\u0020\u006co\u006f\u006b\u0075\u0070 up\u0020di\u0063\u0074\u0069\u006f\u006e\u0061\u0072y \u0072\u0065\u0066\u0065\u0072\u0065\u006ec\u0065");return _afe ;};_dgf =TraceToDirectObject (_daef );};_eec ,_cbfg :=_dgf .(*PdfObjectDictionary );if !_cbfg {return _ff .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074\u0020\u0069\u006e \u0043\u0046\u0020\u0028\u006e\u0061\u006d\u0065\u0020\u0025\u0073\u0029\u0020-\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079\u0020\u0062\u0075\u0074\u0020\u0025\u0054",_bafb ,_dgf );};if _bafb =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{_beg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u002d\u0020\u0043\u0061\u006e\u006e\u006f\u0074\u0020\u006f\u0076\u0065\u0072\u0077r\u0069\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0069d\u0065\u006e\u0074\u0069\u0074\u0079\u0020\u0066\u0069\u006c\u0074\u0065\u0072 \u002d\u0020\u0054\u0072\u0079\u0069n\u0067\u0020\u006ee\u0078\u0074");continue ;};var _bae _ag .FilterDict ;if _cceg :=_afa (&_bae ,_eec );_cceg !=nil {return _cceg ;};_gcg ,_gbd :=_ag .NewFilter (_bae );if _gbd !=nil {return _gbd ;};_eea ._dbf [string (_bafb )]=_gcg ;};_eea ._dbf ["\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"]=_ag .NewIdentity ();_eea ._fde ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _ege ,_cfb :=_cbf .Get ("\u0053\u0074\u0072\u0046").(*PdfObjectName );_cfb {if _ ,_fbc :=_eea ._dbf [string (*_ege )];!_fbc {return _ff .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u0072\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_ege );};_eea ._fde =string (*_ege );};_eea ._dae ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _ccdd ,_ccee :=_cbf .Get ("\u0053\u0074\u006d\u0046").(*PdfObjectName );_ccee {if _ ,_cac :=_eea ._dbf [string (*_ccdd )];!_cac {return _ff .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u006d\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_ccdd );};_eea ._dae =string (*_ccdd );};return nil ;};

// NewJBIG2Encoder creates a new JBIG2Encoder.
func NewJBIG2Encoder ()*JBIG2Encoder {return &JBIG2Encoder {_adea :_bc .InitEncodeDocument (false )}};func _dgae (_eabg PdfObject )(*float64 ,error ){switch _cfee :=_eabg .(type ){case *PdfObjectFloat :_bfeb :=float64 (*_cfee );return &_bfeb ,nil ;case *PdfObjectInteger :_dfeae :=float64 (*_cfee );return &_dfeae ,nil ;case *PdfObjectNull :return nil ,nil ;};return nil ,ErrNotANumber ;};

// NewParser creates a new parser for a PDF file via ReadSeeker. Loads the cross reference stream and trailer.
// An error is returned on failure.
func NewParser (rs _cg .ReadSeeker )(*PdfParser ,error ){_fefg :=&PdfParser {_bdff :rs ,ObjCache :make (objectCache ),_ebae :map[int64 ]bool {}};_ffda ,_edgb ,_gdea :=_fefg .parsePdfVersion ();if _gdea !=nil {_beg .Log .Error ("U\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0076e\u0072\u0073\u0069o\u006e:\u0020\u0025\u0076",_gdea );return nil ,_gdea ;};_fefg ._feaf .Major =_ffda ;_fefg ._feaf .Minor =_edgb ;if _fefg ._ace ,_gdea =_fefg .loadXrefs ();_gdea !=nil {_beg .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020F\u0061\u0069\u006c\u0065d t\u006f l\u006f\u0061\u0064\u0020\u0078\u0072\u0065f \u0074\u0061\u0062\u006c\u0065\u0021\u0020%\u0073",_gdea );return nil ,_gdea ;};_beg .Log .Trace ("T\u0072\u0061\u0069\u006c\u0065\u0072\u003a\u0020\u0025\u0073",_fefg ._ace );if len (_fefg ._bbda .ObjectMap )==0{return nil ,_ff .Errorf ("\u0065\u006d\u0070\u0074\u0079\u0020\u0058\u0052\u0045\u0046\u0020t\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0049\u006e\u0076a\u006c\u0069\u0064");};return _fefg ,nil ;};func (_daccc *PdfParser )parseHexString ()(*PdfObjectString ,error ){_daccc ._cdff .ReadByte ();var _dbdd _gec .Buffer ;for {_cead ,_ebce :=_daccc ._cdff .Peek (1);if _ebce !=nil {return MakeString (""),_ebce ;};if _cead [0]=='>'{_daccc ._cdff .ReadByte ();break ;};_gcag ,_ :=_daccc ._cdff .ReadByte ();if !IsWhiteSpace (_gcag ){_dbdd .WriteByte (_gcag );};};if _dbdd .Len ()%2==1{_dbdd .WriteRune ('0');};_caedd ,_ :=_cd .DecodeString (_dbdd .String ());return MakeHexString (string (_caedd )),nil ;};

// Validate validates the page settings for the JBIG2 encoder.
func (_dgcc JBIG2EncoderSettings )Validate ()error {const _egcb ="\u0076a\u006ci\u0064\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065\u0072";if _dgcc .Threshold < 0||_dgcc .Threshold > 1.0{return _aa .Errorf (_egcb ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074\u0068\u0072\u0065\u0073\u0068\u006f\u006c\u0064\u0020\u0076a\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0076\u0027 \u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0069\u006e\u0020\u0072\u0061n\u0067\u0065\u0020\u005b\u0030\u002e0\u002c\u0020\u0031.\u0030\u005d",_dgcc .Threshold );};if _dgcc .ResolutionX < 0{return _aa .Errorf (_egcb ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0078\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_dgcc .ResolutionX );};if _dgcc .ResolutionY < 0{return _aa .Errorf (_egcb ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0079\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_dgcc .ResolutionY );};if _dgcc .DefaultPixelValue !=0&&_dgcc .DefaultPixelValue !=1{return _aa .Errorf (_egcb ,"de\u0066\u0061u\u006c\u0074\u0020\u0070\u0069\u0078\u0065\u006c\u0020v\u0061\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0066o\u0072 \u0074\u0068\u0065\u0020\u0062\u0069\u0074\u003a \u007b0\u002c\u0031}",_dgcc .DefaultPixelValue );};if _dgcc .Compression !=JB2Generic {return _aa .Errorf (_egcb ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065d\u0020\u0063\u006fm\u0070\u0072\u0065\u0073s\u0069\u006f\u006e\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");};return nil ;};var _cedcb =_ef .MustCompile ("\u005e\u005b\\\u002b\u002d\u002e\u005d*\u0028\u005b0\u002d\u0039\u002e\u005d\u002b\u0029\u005b\u0065E\u005d\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");

// XrefObject defines a cross reference entry which is a map between object number (with generation number) and the
// location of the actual object, either as a file offset (xref table entry), or as a location within an xref
// stream object (xref object stream).
type XrefObject struct{XType xrefType ;ObjectNumber int ;Generation int ;

// For normal xrefs (defined by OFFSET)
Offset int64 ;

// For xrefs to object streams.
OsObjNumber int ;OsObjIndex int ;};func (_cgfeb *PdfParser )parseBool ()(PdfObjectBool ,error ){_agdae ,_ccbf :=_cgfeb ._cdff .Peek (4);if _ccbf !=nil {return PdfObjectBool (false ),_ccbf ;};if (len (_agdae )>=4)&&(string (_agdae [:4])=="\u0074\u0072\u0075\u0065"){_cgfeb ._cdff .Discard (4);return PdfObjectBool (true ),nil ;};_agdae ,_ccbf =_cgfeb ._cdff .Peek (5);if _ccbf !=nil {return PdfObjectBool (false ),_ccbf ;};if (len (_agdae )>=5)&&(string (_agdae [:5])=="\u0066\u0061\u006cs\u0065"){_cgfeb ._cdff .Discard (5);return PdfObjectBool (false ),nil ;};return PdfObjectBool (false ),_e .New ("\u0075n\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0062o\u006fl\u0065a\u006e\u0020\u0073\u0074\u0072\u0069\u006eg");};

// EncodeBytes encodes the image data using either Group3 or Group4 CCITT facsimile (fax) encoding.
// `data` is expected to be 1 color component, 1 byte per component.
func (_dfc *CCITTFaxEncoder )EncodeBytes (data []byte )([]byte ,error ){var _eab [][]byte ;for _fead :=0;_fead < len (data );_fead +=_dfc .Columns {_gbca :=make ([]byte ,_dfc .Columns );_bgaf :=0;for _bbee :=0;_bbee < _dfc .Columns ;_bbee ++{if data [_fead +_bbee ]==255{_gbca [_bgaf ]=1;}else {_gbca [_bgaf ]=0;};_bgaf ++;};_eab =append (_eab ,_gbca );};_edge :=&_ab .Encoder {K :_dfc .K ,Columns :_dfc .Columns ,EndOfLine :_dfc .EndOfLine ,EndOfBlock :_dfc .EndOfBlock ,BlackIs1 :_dfc .BlackIs1 ,DamagedRowsBeforeError :_dfc .DamagedRowsBeforeError ,Rows :_dfc .Rows ,EncodedByteAlign :_dfc .EncodedByteAlign };return _edge .Encode (_eab ),nil ;};

// DecodeBytes decodes a slice of DCT encoded bytes and returns the result.
func (_acg *DCTEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_gdga :=_gec .NewReader (encoded );_dcbd ,_dce :=_gb .Decode (_gdga );if _dce !=nil {_beg .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006eg\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_dce );return nil ,_dce ;};_gfbc :=_dcbd .Bounds ();var _addd =make ([]byte ,_gfbc .Dx ()*_gfbc .Dy ()*_acg .ColorComponents *_acg .BitsPerComponent /8);_baed :=0;for _eegd :=_gfbc .Min .Y ;_eegd < _gfbc .Max .Y ;_eegd ++{for _fcg :=_gfbc .Min .X ;_fcg < _gfbc .Max .X ;_fcg ++{_gecf :=_dcbd .At (_fcg ,_eegd );if _acg .ColorComponents ==1{if _acg .BitsPerComponent ==16{_bcdg ,_cafb :=_gecf .(_efb .Gray16 );if !_cafb {return nil ,_e .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_addd [_baed ]=byte ((_bcdg .Y >>8)&0xff);_baed ++;_addd [_baed ]=byte (_bcdg .Y &0xff);_baed ++;}else {_ddg ,_gedc :=_gecf .(_efb .Gray );if !_gedc {return nil ,_e .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_addd [_baed ]=byte (_ddg .Y &0xff);_baed ++;};}else if _acg .ColorComponents ==3{if _acg .BitsPerComponent ==16{_abag ,_eegb :=_gecf .(_efb .RGBA64 );if !_eegb {return nil ,_e .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_addd [_baed ]=byte ((_abag .R >>8)&0xff);_baed ++;_addd [_baed ]=byte (_abag .R &0xff);_baed ++;_addd [_baed ]=byte ((_abag .G >>8)&0xff);_baed ++;_addd [_baed ]=byte (_abag .G &0xff);_baed ++;_addd [_baed ]=byte ((_abag .B >>8)&0xff);_baed ++;_addd [_baed ]=byte (_abag .B &0xff);_baed ++;}else {_cdf ,_bgg :=_gecf .(_efb .RGBA );if _bgg {_addd [_baed ]=_cdf .R &0xff;_baed ++;_addd [_baed ]=_cdf .G &0xff;_baed ++;_addd [_baed ]=_cdf .B &0xff;_baed ++;}else {_cebe ,_dbgb :=_gecf .(_efb .YCbCr );if !_dbgb {return nil ,_e .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_caa ,_fdab ,_eefe ,_ :=_cebe .RGBA ();_addd [_baed ]=byte (_caa >>8);_baed ++;_addd [_baed ]=byte (_fdab >>8);_baed ++;_addd [_baed ]=byte (_eefe >>8);_baed ++;};};}else if _acg .ColorComponents ==4{_ccff ,_egb :=_gecf .(_efb .CMYK );if !_egb {return nil ,_e .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_addd [_baed ]=255-_ccff .C &0xff;_baed ++;_addd [_baed ]=255-_ccff .M &0xff;_baed ++;_addd [_baed ]=255-_ccff .Y &0xff;_baed ++;_addd [_baed ]=255-_ccff .K &0xff;_baed ++;};};};return _addd ,nil ;};

// PdfVersion returns version of the PDF file.
func (_aecg *PdfParser )PdfVersion ()Version {return _aecg ._feaf };

// LookupByReference looks up a PdfObject by a reference.
func (_dgc *PdfParser )LookupByReference (ref PdfObjectReference )(PdfObject ,error ){_beg .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0075\u0070\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0025\u0073",ref .String ());return _dgc .LookupByNumber (int (ref .ObjectNumber ));};

// EncodeBytes DCT encodes the passed in slice of bytes.
func (_cefb *DCTEncoder )EncodeBytes (data []byte )([]byte ,error ){_cbea ,_daf :=_da .NewImage (_cefb .Width ,_cefb .Height ,_cefb .BitsPerComponent ,_cefb .ColorComponents ,data ,nil ,nil );if _daf !=nil {return nil ,_daf ;};_edbb :=_gb .Options {};_edbb .Quality =_cefb .Quality ;var _edf _gec .Buffer ;if _daf =_gb .Encode (&_edf ,_cbea ,&_edbb );_daf !=nil {return nil ,_daf ;};return _edf .Bytes (),nil ;};func (_bgc *PdfParser )lookupByNumber (_dd int ,_ecb bool )(PdfObject ,bool ,error ){_efbc ,_ccf :=_bgc .ObjCache [_dd ];if _ccf {_beg .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0063a\u0063\u0068\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0025\u0064",_dd );return _efbc ,false ,nil ;};_cce ,_ccf :=_bgc ._bbda .ObjectMap [_dd ];if !_ccf {_beg .Log .Trace ("\u0055\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u006c\u006f\u0063\u0061t\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0069\u006e\u0020\u0078\u0072\u0065\u0066\u0073\u0021 \u002d\u0020\u0052\u0065\u0074u\u0072\u006e\u0069\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074");var _ba PdfObjectNull ;return &_ba ,false ,nil ;};_beg .Log .Trace ("L\u006fo\u006b\u0075\u0070\u0020\u006f\u0062\u006a\u0020n\u0075\u006d\u0062\u0065r \u0025\u0064",_dd );if _cce .XType ==XrefTypeTableEntry {_beg .Log .Trace ("\u0078r\u0065f\u006f\u0062\u006a\u0020\u006fb\u006a\u0020n\u0075\u006d\u0020\u0025\u0064",_cce .ObjectNumber );_beg .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u0067e\u006e\u0020\u0025\u0064",_cce .Generation );_beg .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0064",_cce .Offset );_bgc ._bdff .Seek (_cce .Offset ,_bf .SEEK_SET );_bgc ._cdff =_gf .NewReader (_bgc ._bdff );_bfd ,_dc :=_bgc .ParseIndirectObject ();if _dc !=nil {_beg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006ce\u0064\u0020\u0072\u0065\u0061\u0064\u0069n\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029",_dc );if _ecb {_beg .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0072\u0065\u0070\u0061\u0069r\u0020\u0078\u0072\u0065\u0066\u0073\u0020\u0028\u0074\u006f\u0070\u0020d\u006f\u0077\u006e\u0029");_abe ,_cad :=_bgc .repairRebuildXrefsTopDown ();if _cad !=nil {_beg .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020r\u0065\u0070\u0061\u0069\u0072\u0020\u0028\u0025\u0073\u0029",_cad );return nil ,false ,_cad ;};_bgc ._bbda =*_abe ;return _bgc .lookupByNumber (_dd ,false );};return nil ,false ,_dc ;};if _ecb {_fae ,_ ,_ :=_fgg (_bfd );if int (_fae )!=_dd {_beg .Log .Debug ("\u0049n\u0076\u0061\u006c\u0069d\u0020\u0078\u0072\u0065\u0066s\u003a \u0052e\u0062\u0075\u0069\u006c\u0064\u0069\u006eg");_de :=_bgc .rebuildXrefTable ();if _de !=nil {return nil ,false ,_de ;};_bgc .ObjCache =objectCache {};return _bgc .lookupByNumberWrapper (_dd ,false );};};_beg .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006f\u0062\u006a");_bgc .ObjCache [_dd ]=_bfd ;return _bfd ,false ,nil ;}else if _cce .XType ==XrefTypeObjectStream {_beg .Log .Trace ("\u0078r\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0021");_beg .Log .Trace ("\u003e\u004c\u006f\u0061\u0064\u0020\u0076\u0069\u0061\u0020\u004f\u0053\u0021");_beg .Log .Trace ("\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d \u0061\u0076\u0061\u0069\u006c\u0061b\u006c\u0065\u0020\u0069\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020%\u0064\u002f\u0025\u0064",_cce .OsObjNumber ,_cce .OsObjIndex );if _cce .OsObjNumber ==_dd {_beg .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0043i\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065f\u0065\u0072\u0065n\u0063e\u0021\u003f\u0021");return nil ,true ,_e .New ("\u0078\u0072\u0065f \u0063\u0069\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");};if _ ,_gagg :=_bgc ._bbda .ObjectMap [_cce .OsObjNumber ];_gagg {_efg ,_eb :=_bgc .lookupObjectViaOS (_cce .OsObjNumber ,_dd );if _eb !=nil {_beg .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0052\u0065\u0074\u0075\u0072\u006e\u0069n\u0067\u0020\u0045\u0052\u0052\u0020\u0028\u0025\u0073\u0029",_eb );return nil ,true ,_eb ;};_beg .Log .Trace ("\u003c\u004c\u006f\u0061\u0064\u0065\u0064\u0020\u0076i\u0061\u0020\u004f\u0053");_bgc .ObjCache [_dd ]=_efg ;if _bgc ._ccddd !=nil {_bgc ._ccddd ._ggd [_efg ]=true ;};return _efg ,true ,nil ;};_beg .Log .Debug ("\u003f\u003f\u0020\u0042\u0065\u006c\u006f\u006eg\u0073\u0020\u0074o \u0061\u0020\u006e\u006f\u006e\u002dc\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u002e.\u002e\u0021");return nil ,true ,_e .New ("\u006f\u0073\u0020\u0062\u0065\u006c\u006fn\u0067\u0073\u0020t\u006f\u0020\u0061\u0020n\u006f\u006e\u0020\u0063\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074");};return nil ,false ,_e .New ("\u0075\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0078\u0072\u0065\u0066 \u0074\u0079\u0070\u0065");};func (_acgc *PdfParser )parseXrefTable ()(*PdfObjectDictionary ,error ){var _fdgd *PdfObjectDictionary ;_bad ,_cgcf :=_acgc .readTextLine ();if _cgcf !=nil {return nil ,_cgcf ;};_beg .Log .Trace ("\u0078\u0072\u0065\u0066 f\u0069\u0072\u0073\u0074\u0020\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_bad );_fgfb :=-1;_bfgff :=0;_fbfa :=false ;_bcdgb :="";for {_acgc .skipSpaces ();_ ,_gegf :=_acgc ._cdff .Peek (1);if _gegf !=nil {return nil ,_gegf ;};_bad ,_gegf =_acgc .readTextLine ();if _gegf !=nil {return nil ,_gegf ;};_cffdc :=_dbca .FindStringSubmatch (_bad );if len (_cffdc )==0{_dedf :=len (_bcdgb )> 0;_bcdgb +=_bad +"\u000a";if _dedf {_cffdc =_dbca .FindStringSubmatch (_bcdgb );};};if len (_cffdc )==3{_acga ,_ :=_b .Atoi (_cffdc [1]);_dbgbb ,_ :=_b .Atoi (_cffdc [2]);_fgfb =_acga ;_bfgff =_dbgbb ;_fbfa =true ;_bcdgb ="";_beg .Log .Trace ("\u0078r\u0065\u0066 \u0073\u0075\u0062s\u0065\u0063\u0074\u0069\u006f\u006e\u003a \u0066\u0069\u0072\u0073\u0074\u0020o\u0062\u006a\u0065\u0063\u0074\u003a\u0020\u0025\u0064\u0020\u006fb\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_fgfb ,_bfgff );continue ;};_dfffg :=_aagf .FindStringSubmatch (_bad );if len (_dfffg )==4{if _fbfa ==false {_beg .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0058r\u0065\u0066\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u006fr\u006da\u0074\u0021\u000a");return nil ,_e .New ("\u0078\u0072\u0065\u0066 i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072\u006d\u0061\u0074");};_beda ,_ :=_b .ParseInt (_dfffg [1],10,64);_bdgb ,_ :=_b .Atoi (_dfffg [2]);_aada :=_dfffg [3];_bcdgb ="";if _d .ToLower (_aada )=="\u006e"&&_beda > 1{_eggfg ,_abfef :=_acgc ._bbda .ObjectMap [_fgfb ];if !_abfef ||_bdgb > _eggfg .Generation {_aafd :=XrefObject {ObjectNumber :_fgfb ,XType :XrefTypeTableEntry ,Offset :_beda ,Generation :_bdgb };_acgc ._bbda .ObjectMap [_fgfb ]=_aafd ;};};_fgfb ++;continue ;};if (len (_bad )> 6)&&(_bad [:7]=="\u0074r\u0061\u0069\u006c\u0065\u0072"){_beg .Log .Trace ("\u0046o\u0075n\u0064\u0020\u0074\u0072\u0061i\u006c\u0065r\u0020\u002d\u0020\u0025\u0073",_bad );if len (_bad )> 9{_bcdgbe :=_acgc .GetFileOffset ();_acgc .SetFileOffset (_bcdgbe -int64 (len (_bad ))+7);};_acgc .skipSpaces ();_acgc .skipComments ();_beg .Log .Trace ("R\u0065\u0061\u0064\u0069ng\u0020t\u0072\u0061\u0069\u006c\u0065r\u0020\u0064\u0069\u0063\u0074\u0021");_beg .Log .Trace ("\u0070\u0065\u0065\u006b\u003a\u0020\u0022\u0025\u0073\u0022",_bad );_fdgd ,_gegf =_acgc .ParseDict ();_beg .Log .Trace ("\u0045O\u0046\u0020\u0072\u0065a\u0064\u0069\u006e\u0067\u0020t\u0072a\u0069l\u0065\u0072\u0020\u0064\u0069\u0063\u0074!");if _gegf !=nil {_beg .Log .Debug ("\u0045\u0072\u0072o\u0072\u0020\u0070\u0061r\u0073\u0069\u006e\u0067\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u0064\u0069\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_gegf );return nil ,_gegf ;};break ;};if _bad =="\u0025\u0025\u0045O\u0046"{_beg .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006e\u0064 \u006f\u0066\u0020\u0066\u0069\u006c\u0065 -\u0020\u0074\u0072\u0061i\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066ou\u006e\u0064 \u002d\u0020\u0065\u0072\u0072\u006f\u0072\u0021");return nil ,_e .New ("\u0065\u006e\u0064 \u006f\u0066\u0020\u0066i\u006c\u0065\u0020\u002d\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};_beg .Log .Trace ("\u0078\u0072\u0065\u0066\u0020\u006d\u006f\u0072\u0065 \u003a\u0020\u0025\u0073",_bad );};_beg .Log .Trace ("\u0045\u004f\u0046 p\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0021");if _acgc ._bdaa ==nil {_caca :=XrefTypeTableEntry ;_acgc ._bdaa =&_caca ;};return _fdgd ,nil ;};

// PdfCrypt provides PDF encryption/decryption support.
// The PDF standard supports encryption of strings and streams (Section 7.6).
type PdfCrypt struct{_geb encryptDict ;_aba _bca .StdEncryptDict ;_eg string ;_baa []byte ;_ggd map[PdfObject ]bool ;_afc map[PdfObject ]bool ;_agce bool ;_dbf cryptFilters ;_dae string ;_fde string ;_cbb *PdfParser ;_bcc map[int ]struct{};};

// PdfIndirectObject represents the primitive PDF indirect object.
type PdfIndirectObject struct{PdfObjectReference ;PdfObject ;};

// GetIntVal returns the int value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetIntVal (obj PdfObject )(_eafc int ,_fcag bool ){_gbggf ,_fcag :=TraceToDirectObject (obj ).(*PdfObjectInteger );if _fcag &&_gbggf !=nil {return int (*_gbggf ),true ;};return 0,false ;};

// Len returns the number of elements in the array.
func (_afbde *PdfObjectArray )Len ()int {if _afbde ==nil {return 0;};return len (_afbde ._fbcce );};

// ASCII85Encoder implements ASCII85 encoder/decoder.
type ASCII85Encoder struct{};

// PdfObjectDictionary represents the primitive PDF dictionary/map object.
type PdfObjectDictionary struct{_ggagd map[PdfObjectName ]PdfObject ;_edcg []PdfObjectName ;_effde *PdfParser ;};

// GetFileOffset returns the current file offset, accounting for buffered position.
func (_gabf *PdfParser )GetFileOffset ()int64 {_becb ,_ :=_gabf ._bdff .Seek (0,_cg .SeekCurrent );_becb -=int64 (_gabf ._cdff .Buffered ());return _becb ;};

// String returns a string describing `array`.
func (_bgbg *PdfObjectArray )String ()string {_cdec :="\u005b";for _gddc ,_fdcc :=range _bgbg .Elements (){_cdec +=_fdcc .String ();if _gddc < (_bgbg .Len ()-1){_cdec +="\u002c\u0020";};};_cdec +="\u005d";return _cdec ;};

// DecodeStream returns the passed in stream as a slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_gcbd *RawEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return streamObj .Stream ,nil ;};

// GetFilterName returns the name of the encoding filter.
func (_feeb *ASCII85Encoder )GetFilterName ()string {return StreamEncodingFilterNameASCII85 };

// Resolve resolves a PdfObject to direct object, looking up and resolving references as needed (unlike TraceToDirect).
func (_caf *PdfParser )Resolve (obj PdfObject )(PdfObject ,error ){_adf ,_ffga :=obj .(*PdfObjectReference );if !_ffga {return obj ,nil ;};_dac :=_caf .GetFileOffset ();defer func (){_caf .SetFileOffset (_dac )}();_fdd ,_edb :=_caf .LookupByReference (*_adf );if _edb !=nil {return nil ,_edb ;};_gda ,_fb :=_fdd .(*PdfIndirectObject );if !_fb {return _fdd ,nil ;};_fdd =_gda .PdfObject ;_ ,_ffga =_fdd .(*PdfObjectReference );if _ffga {return _gda ,_e .New ("\u006d\u0075lt\u0069\u0020\u0064e\u0070\u0074\u0068\u0020tra\u0063e \u0070\u006f\u0069\u006e\u0074\u0065\u0072 t\u006f\u0020\u0070\u006f\u0069\u006e\u0074e\u0072");};return _fdd ,nil ;};

// String returns a string describing `ind`.
func (_eeea *PdfIndirectObject )String ()string {return _ff .Sprintf ("\u0049\u004f\u0062\u006a\u0065\u0063\u0074\u003a\u0025\u0064",(*_eeea ).ObjectNumber );};func (_ecba *ASCII85Encoder )base256Tobase85 (_ggce uint32 )[5]byte {_fcbc :=[5]byte {0,0,0,0,0};_beeea :=_ggce ;for _dage :=0;_dage < 5;_dage ++{_adgcd :=uint32 (1);for _afbg :=0;_afbg < 4-_dage ;_afbg ++{_adgcd *=85;};_fccba :=_beeea /_adgcd ;_beeea =_beeea %_adgcd ;_fcbc [_dage ]=byte (_fccba );};return _fcbc ;};

// JBIG2EncoderSettings contains the parameters and settings used by the JBIG2Encoder.
// Current version works only on JB2Generic compression.
type JBIG2EncoderSettings struct{

// FileMode defines if the jbig2 encoder should return full jbig2 file instead of
// shortened pdf mode. This adds the file header to the jbig2 definition.
FileMode bool ;

// Compression is the setting that defines the compression type used for encoding the page.
Compression JBIG2CompressionType ;

// DuplicatedLinesRemoval code generic region in a way such that if the lines are duplicated the encoder
// doesn't store it twice.
DuplicatedLinesRemoval bool ;

// DefaultPixelValue is the bit value initial for every pixel in the page.
DefaultPixelValue uint8 ;

// ResolutionX optional setting that defines the 'x' axis input image resolution - used for single page encoding.
ResolutionX int ;

// ResolutionY optional setting that defines the 'y' axis input image resolution - used for single page encoding.
ResolutionY int ;

// Threshold defines the threshold of the image correlation for
// non Generic compression.
// User only for JB2SymbolCorrelation and JB2SymbolRankHaus methods.
// Best results in range [0.7 - 0.98] - the less the better the compression would be
// but the more lossy.
// Default value: 0.95
Threshold float64 ;};

// DecodeStream decodes a multi-encoded stream by passing it through the
// DecodeStream method of the underlying encoders.
func (_dcf *MultiEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _dcf .DecodeBytes (streamObj .Stream );};func (_bfbe *PdfParser )seekToEOFMarker (_gagd int64 )error {var _ggcf int64 ;var _bfgb int64 =2048;for _ggcf < _gagd -4{if _gagd <=(_bfgb +_ggcf ){_bfgb =_gagd -_ggcf ;};_ ,_egcf :=_bfbe ._bdff .Seek (-_ggcf -_bfgb ,_cg .SeekEnd );if _egcf !=nil {return _egcf ;};_fgdb :=make ([]byte ,_bfgb );_bfbe ._bdff .Read (_fgdb );_beg .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0045\u004f\u0046 \u006da\u0072\u006b\u0065\u0072\u003a\u0020\u0022%\u0073\u0022",string (_fgdb ));_bcfgd :=_cedc .FindAllStringIndex (string (_fgdb ),-1);if _bcfgd !=nil {_edfba :=_bcfgd [len (_bcfgd )-1];_beg .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_bcfgd );_bfbe ._bdff .Seek (-_ggcf -_bfgb +int64 (_edfba [0]),_cg .SeekEnd );return nil ;};_beg .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");_ggcf +=_bfgb -4;};_beg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006be\u0072 \u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u002e");return _e .New ("\u0045\u004f\u0046\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};

// JBIG2CompressionType defines the enum compression type used by the JBIG2Encoder.
type JBIG2CompressionType int ;

// String returns a string describing `d`.
func (_cggfc *PdfObjectDictionary )String ()string {var _caeca _d .Builder ;_caeca .WriteString ("\u0044\u0069\u0063t\u0028");for _ ,_fdef :=range _cggfc ._edcg {_cdaec :=_cggfc ._ggagd [_fdef ];_caeca .WriteString ("\u0022"+_fdef .String ()+"\u0022\u003a\u0020");_caeca .WriteString (_cdaec .String ());_caeca .WriteString ("\u002c\u0020");};_caeca .WriteString ("\u0029");return _caeca .String ();};

// EncodeStream encodes the stream data using the encoded specified by the stream's dictionary.
func EncodeStream (streamObj *PdfObjectStream )error {_beg .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_dbdce ,_dabgb :=NewEncoderFromStream (streamObj );if _dabgb !=nil {_beg .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_dabgb );return _dabgb ;};if _ddbd ,_edegb :=_dbdce .(*LZWEncoder );_edegb {_ddbd .EarlyChange =0;streamObj .PdfObjectDictionary .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (0));};_beg .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076\u000a",_dbdce );_ggefg ,_dabgb :=_dbdce .EncodeBytes (streamObj .Stream );if _dabgb !=nil {_beg .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_dabgb );return _dabgb ;};streamObj .Stream =_ggefg ;streamObj .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_ggefg ))));return nil ;};

// Get returns the PdfObject corresponding to the specified key.
// Returns a nil value if the key is not set.
func (_bdfa *PdfObjectDictionary )Get (key PdfObjectName )PdfObject {_aged ,_cgda :=_bdfa ._ggagd [key ];if !_cgda {return nil ;};return _aged ;};

// IsDelimiter checks if a character represents a delimiter.
func IsDelimiter (c byte )bool {return c =='('||c ==')'||c =='<'||c =='>'||c =='['||c ==']'||c =='{'||c =='}'||c =='/'||c =='%';};

// MakeInteger creates a PdfObjectInteger from an int64.
func MakeInteger (val int64 )*PdfObjectInteger {_aege :=PdfObjectInteger (val );return &_aege };

// MakeObjectStreams creates an PdfObjectStreams from a list of PdfObjects.
func MakeObjectStreams (objects ...PdfObject )*PdfObjectStreams {_cdcb :=&PdfObjectStreams {};_cdcb ._acec =[]PdfObject {};for _ ,_fdbfb :=range objects {_cdcb ._acec =append (_cdcb ._acec ,_fdbfb );};return _cdcb ;};

// Resolve resolves the reference and returns the indirect or stream object.
// If the reference cannot be resolved, a *PdfObjectNull object is returned.
func (_aegbb *PdfObjectReference )Resolve ()PdfObject {if _aegbb ._cabd ==nil {return MakeNull ();};_gcec ,_ ,_cfcbd :=_aegbb ._cabd .resolveReference (_aegbb );if _cfcbd !=nil {_beg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0072\u0065\u0073\u006f\u006cv\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065r\u0065n\u0063\u0065\u003a\u0020\u0025\u0076\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074",_cfcbd );return MakeNull ();};if _gcec ==nil {_beg .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0072\u0065\u0073ol\u0076\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065:\u0020\u006ei\u006c\u0020\u006fb\u006a\u0065\u0063\u0074\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u0061\u0020nu\u006c\u006c\u0020o\u0062\u006a\u0065\u0063\u0074");return MakeNull ();};return _gcec ;};

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_ffgc *RunLengthEncoder )EncodeBytes (data []byte )([]byte ,error ){_ffdc :=_gec .NewReader (data );var _bdeb []byte ;var _beee []byte ;_def ,_bdbc :=_ffdc .ReadByte ();if _bdbc ==_cg .EOF {return []byte {},nil ;}else if _bdbc !=nil {return nil ,_bdbc ;};_fgc :=1;for {_fbgca ,_fbda :=_ffdc .ReadByte ();if _fbda ==_cg .EOF {break ;}else if _fbda !=nil {return nil ,_fbda ;};if _fbgca ==_def {if len (_beee )> 0{_beee =_beee [:len (_beee )-1];if len (_beee )> 0{_bdeb =append (_bdeb ,byte (len (_beee )-1));_bdeb =append (_bdeb ,_beee ...);};_fgc =1;_beee =[]byte {};};_fgc ++;if _fgc >=127{_bdeb =append (_bdeb ,byte (257-_fgc ),_def );_fgc =0;};}else {if _fgc > 0{if _fgc ==1{_beee =[]byte {_def };}else {_bdeb =append (_bdeb ,byte (257-_fgc ),_def );};_fgc =0;};_beee =append (_beee ,_fbgca );if len (_beee )>=127{_bdeb =append (_bdeb ,byte (len (_beee )-1));_bdeb =append (_bdeb ,_beee ...);_beee =[]byte {};};};_def =_fbgca ;};if len (_beee )> 0{_bdeb =append (_bdeb ,byte (len (_beee )-1));_bdeb =append (_bdeb ,_beee ...);}else if _fgc > 0{_bdeb =append (_bdeb ,byte (257-_fgc ),_def );};_bdeb =append (_bdeb ,128);return _bdeb ,nil ;};

// MakeStream creates an PdfObjectStream with specified contents and encoding. If encoding is nil, then raw encoding
// will be used (i.e. no encoding applied).
func MakeStream (contents []byte ,encoder StreamEncoder )(*PdfObjectStream ,error ){_gaca :=&PdfObjectStream {};if encoder ==nil {encoder =NewRawEncoder ();};_gaca .PdfObjectDictionary =encoder .MakeStreamDict ();_beeb ,_ddbf :=encoder .EncodeBytes (contents );if _ddbf !=nil {return nil ,_ddbf ;};_gaca .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_beeb ))));_gaca .Stream =_beeb ;return _gaca ,nil ;};