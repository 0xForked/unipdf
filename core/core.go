//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package core defines and implements the primitive PDF object types in golang, and provides functionality
// for parsing those from a PDF file stream. This includes I/O handling, cross references, repairs, encryption,
// encoding and other core capabilities.
package core ;import (_cbe "bufio";_cdc "bytes";_fg "compress/lzw";_e "compress/zlib";_cb "crypto/md5";_d "crypto/rand";_gd "encoding/hex";_b "errors";_fe "fmt";_ge "github.com/unidoc/unipdf/v3/common";_gc "github.com/unidoc/unipdf/v3/core/security";_ac "github.com/unidoc/unipdf/v3/core/security/crypt";_dcc "github.com/unidoc/unipdf/v3/internal/ccittfax";_ca "github.com/unidoc/unipdf/v3/internal/imageutil";_ccc "github.com/unidoc/unipdf/v3/internal/jbig2";_cbc "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_cf "github.com/unidoc/unipdf/v3/internal/jbig2/decoder";_ae "github.com/unidoc/unipdf/v3/internal/jbig2/document";_cc "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_ga "github.com/unidoc/unipdf/v3/internal/strutils";_bg "golang.org/x/image/tiff/lzw";_ffa "image";_gb "image/color";_cd "image/jpeg";_c "io";_ef "os";_ad "reflect";_ff "regexp";_f "sort";_g "strconv";_dc "strings";_gbe "time";);

// Len returns the number of elements in the streams.
func (_bdacd *PdfObjectStreams )Len ()int {if _bdacd ==nil {return 0;};return len (_bdacd ._ccff );};

// GetFilterName returns the name of the encoding filter.
func (_ebdc *LZWEncoder )GetFilterName ()string {return StreamEncodingFilterNameLZW };

// String returns the PDF version as a string. Implements interface fmt.Stringer.
func (_dgbe Version )String ()string {return _fe .Sprintf ("\u00250\u0064\u002e\u0025\u0030\u0064",_dgbe .Major ,_dgbe .Minor );};

// EncodeBytes encodes data into ASCII85 encoded format.
func (_edda *ASCII85Encoder )EncodeBytes (data []byte )([]byte ,error ){var _fabg _cdc .Buffer ;for _bag :=0;_bag < len (data );_bag +=4{_abgb :=data [_bag ];_agaa :=1;_ggdb :=byte (0);if _bag +1< len (data ){_ggdb =data [_bag +1];_agaa ++;};_gagda :=byte (0);if _bag +2< len (data ){_gagda =data [_bag +2];_agaa ++;};_cdaa :=byte (0);if _bag +3< len (data ){_cdaa =data [_bag +3];_agaa ++;};_adbd :=(uint32 (_abgb )<<24)|(uint32 (_ggdb )<<16)|(uint32 (_gagda )<<8)|uint32 (_cdaa );if _adbd ==0{_fabg .WriteByte ('z');}else {_ceeg :=_edda .base256Tobase85 (_adbd );for _ ,_gfgg :=range _ceeg [:_agaa +1]{_fabg .WriteByte (_gfgg +'!');};};};_fabg .WriteString ("\u007e\u003e");return _fabg .Bytes (),nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_ged *FlateEncoder )MakeStreamDict ()*PdfObjectDictionary {_cbgf :=MakeDict ();_cbgf .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_ged .GetFilterName ()));_bab :=_ged .MakeDecodeParams ();if _bab !=nil {_cbgf .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_bab );};return _cbgf ;};

// GetTrailer returns the PDFs trailer dictionary. The trailer dictionary is typically the starting point for a PDF,
// referencing other key objects that are important in the document structure.
func (_ccgag *PdfParser )GetTrailer ()*PdfObjectDictionary {return _ccgag ._aedd };

// IsAuthenticated returns true if the PDF has already been authenticated for accessing.
func (_agaab *PdfParser )IsAuthenticated ()bool {return _agaab ._ddfa ._dfa };

// WriteString outputs the object as it is to be written to file.
func (_eefb *PdfObjectBool )WriteString ()string {if *_eefb {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};

// GetFileOffset returns the current file offset, accounting for buffered position.
func (_cgeg *PdfParser )GetFileOffset ()int64 {_fcce ,_ :=_cgeg ._dceb .Seek (0,_c .SeekCurrent );_fcce -=int64 (_cgeg ._addbb .Buffered ());return _fcce ;};type cryptFilters map[string ]_ac .Filter ;

// TraceToDirectObject traces a PdfObject to a direct object.  For example direct objects contained
// in indirect objects (can be double referenced even).
func TraceToDirectObject (obj PdfObject )PdfObject {if _cccab ,_dccc :=obj .(*PdfObjectReference );_dccc {obj =_cccab .Resolve ();};_bfba ,_bfab :=obj .(*PdfIndirectObject );_dacce :=0;for _bfab {obj =_bfba .PdfObject ;_bfba ,_bfab =GetIndirect (obj );_dacce ++;if _dacce > _aeacd {_ge .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0072\u0061\u0063\u0065\u0020\u0064\u0065p\u0074\u0068\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u0062\u0065\u0079\u006fn\u0064\u0020\u0025\u0064\u0020\u002d\u0020\u006e\u006f\u0074\u0020\u0067oi\u006e\u0067\u0020\u0064\u0065\u0065\u0070\u0065\u0072\u0021",_aeacd );return nil ;};};return obj ;};

// UpdateParams updates the parameter values of the encoder.
func (_eddac *JPXEncoder )UpdateParams (params *PdfObjectDictionary ){};var _eade =_ff .MustCompile ("\u0025P\u0044F\u002d\u0028\u005c\u0064\u0029\u005c\u002e\u0028\u005c\u0064\u0029");func _beccb (_gfda string )(int ,int ,error ){_adeb :=_ggcc .FindStringSubmatch (_gfda );if len (_adeb )< 3{return 0,0,_b .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");};_aaee ,_ :=_g .Atoi (_adeb [1]);_bagf ,_ :=_g .Atoi (_adeb [2]);return _aaee ,_bagf ,nil ;};

// NewParser creates a new parser for a PDF file via ReadSeeker. Loads the cross reference stream and trailer.
// An error is returned on failure.
func NewParser (rs _c .ReadSeeker )(*PdfParser ,error ){_cfbc :=&PdfParser {_dceb :rs ,ObjCache :make (objectCache ),_dfda :map[int64 ]bool {}};_efbf ,_gbbeb ,_egfe :=_cfbc .parsePdfVersion ();if _egfe !=nil {_ge .Log .Error ("U\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0076e\u0072\u0073\u0069o\u006e:\u0020\u0025\u0076",_egfe );return nil ,_egfe ;};_cfbc ._aaaa .Major =_efbf ;_cfbc ._aaaa .Minor =_gbbeb ;if _cfbc ._aedd ,_egfe =_cfbc .loadXrefs ();_egfe !=nil {_ge .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020F\u0061\u0069\u006c\u0065d t\u006f l\u006f\u0061\u0064\u0020\u0078\u0072\u0065f \u0074\u0061\u0062\u006c\u0065\u0021\u0020%\u0073",_egfe );return nil ,_egfe ;};_ge .Log .Trace ("T\u0072\u0061\u0069\u006c\u0065\u0072\u003a\u0020\u0025\u0073",_cfbc ._aedd );if len (_cfbc ._afag .ObjectMap )==0{return nil ,_fe .Errorf ("\u0065\u006d\u0070\u0074\u0079\u0020\u0058\u0052\u0045\u0046\u0020t\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0049\u006e\u0076a\u006c\u0069\u0064");};return _cfbc ,nil ;};

// JBIG2Encoder implements both jbig2 encoder and the decoder. The encoder allows to encode
// provided images (best used document scans) in multiple way. By default it uses single page generic
// encoder. It allows to store lossless data as a single segment.
// In order to store multiple image pages use the 'FileMode' which allows to store more pages within single jbig2 document.
// WIP: In order to obtain better compression results the encoder would allow to encode the input in a
// lossy or lossless way with a component (symbol) mode. It divides the image into components.
// Then checks if any component is 'similar' to the others and maps them together. The symbol classes are stored
// in the dictionary. Then the encoder creates text regions which uses the related symbol classes to fill it's space.
// The similarity is defined by the 'Threshold' variable (default: 0.95). The less the value is, the more components
// matches to single class, thus the compression is better, but the result might become lossy.
type JBIG2Encoder struct{

// These values are required to be set for the 'EncodeBytes' method.
// ColorComponents defines the number of color components for provided image.
ColorComponents int ;

// BitsPerComponent is the number of bits that stores per color component
BitsPerComponent int ;

// Width is the width of the image to encode
Width int ;

// Height is the height of the image to encode.
Height int ;_dafd *_ae .Document ;

// Globals are the JBIG2 global segments.
Globals _ccc .Globals ;

// IsChocolateData defines if the data is encoded such that
// binary data '1' means black and '0' white.
// otherwise the data is called vanilla.
// Naming convention taken from: 'https://en.wikipedia.org/wiki/Binary_image#Interpretation'
IsChocolateData bool ;

// DefaultPageSettings are the settings parameters used by the jbig2 encoder.
DefaultPageSettings JBIG2EncoderSettings ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set.  Some other parameters are generated elsewhere.
func (_eede *DCTEncoder )MakeStreamDict ()*PdfObjectDictionary {_gecc :=MakeDict ();_gecc .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_eede .GetFilterName ()));return _gecc ;};

// DecodeBytes decodes the CCITTFax encoded image data.
func (_fgee *CCITTFaxEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_gcga :=&_dcc .Encoder {K :_fgee .K ,Columns :_fgee .Columns ,EndOfLine :_fgee .EndOfLine ,EndOfBlock :_fgee .EndOfBlock ,BlackIs1 :_fgee .BlackIs1 ,DamagedRowsBeforeError :_fgee .DamagedRowsBeforeError ,Rows :_fgee .Rows ,EncodedByteAlign :_fgee .EncodedByteAlign };_aaeg ,_bbeea :=_gcga .Decode (encoded );if _bbeea !=nil {return nil ,_bbeea ;};var _cccff []byte ;_fbfd :=0;var _ddff byte ;var _ddba byte ;for _ddcg :=range _aaeg {if _ddff !=0{_cccff =append (_cccff ,_ddba );_ddba =0;_fbfd ++;_ddff =0;};for _faag :=range _aaeg [_ddcg ]{_ddba |=_aaeg [_ddcg ][_faag ]<<(7-_ddff );_ddff ++;if _ddff ==8{_cccff =append (_cccff ,_ddba );_ddba =0;_fbfd ++;_ddff =0;};};};if _ddff > 0{_cccff =append (_cccff ,_ddba );};return _cccff ,nil ;};

// Decrypt attempts to decrypt the PDF file with a specified password.  Also tries to
// decrypt with an empty password.  Returns true if successful, false otherwise.
// An error is returned when there is a problem with decrypting.
func (_aeaf *PdfParser )Decrypt (password []byte )(bool ,error ){if _aeaf ._ddfa ==nil {return false ,_b .New ("\u0063\u0068\u0065\u0063k \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u0069\u0072s\u0074");};_fggd ,_addc :=_aeaf ._ddfa .authenticate (password );if _addc !=nil {return false ,_addc ;};if !_fggd {_fggd ,_addc =_aeaf ._ddfa .authenticate ([]byte (""));};return _fggd ,_addc ;};

// MakeBool creates a PdfObjectBool from a bool value.
func MakeBool (val bool )*PdfObjectBool {_fccf :=PdfObjectBool (val );return &_fccf };var _gbdgd =_ff .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064+\u0029\u005c\u0073\u002b\u0028\u005b\u006e\u0066\u005d\u0029\\\u0073\u002a\u0024");

// DecodeBytes decodes byte array with ASCII85. 5 ASCII characters -> 4 raw binary bytes
func (_dcca *ASCII85Encoder )DecodeBytes (encoded []byte )([]byte ,error ){var _dbbg []byte ;_ge .Log .Trace ("\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0020\u0044e\u0063\u006f\u0064\u0065");_eef :=0;_gdbg :=false ;for _eef < len (encoded )&&!_gdbg {_faeec :=[5]byte {0,0,0,0,0};_fefb :=0;_daad :=0;_eeb :=4;for _daad < 5+_fefb {if _eef +_daad ==len (encoded ){break ;};_dceeg :=encoded [_eef +_daad ];if IsWhiteSpace (_dceeg ){_fefb ++;_daad ++;continue ;}else if _dceeg =='~'&&_eef +_daad +1< len (encoded )&&encoded [_eef +_daad +1]=='>'{_eeb =(_daad -_fefb )-1;if _eeb < 0{_eeb =0;};_gdbg =true ;break ;}else if _dceeg >='!'&&_dceeg <='u'{_dceeg -='!';}else if _dceeg =='z'&&_daad -_fefb ==0{_eeb =4;_daad ++;break ;}else {_ge .Log .Error ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u002c\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020co\u0064\u0065");return nil ,_b .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0063\u006f\u0064\u0065\u0020e\u006e\u0063\u006f\u0075\u006e\u0074\u0065\u0072\u0065\u0064");};_faeec [_daad -_fefb ]=_dceeg ;_daad ++;};_eef +=_daad ;for _dcbd :=_eeb +1;_dcbd < 5;_dcbd ++{_faeec [_dcbd ]=84;};_cddf :=uint32 (_faeec [0])*85*85*85*85+uint32 (_faeec [1])*85*85*85+uint32 (_faeec [2])*85*85+uint32 (_faeec [3])*85+uint32 (_faeec [4]);_agae :=[]byte {byte ((_cddf >>24)&0xff),byte ((_cddf >>16)&0xff),byte ((_cddf >>8)&0xff),byte (_cddf &0xff)};_dbbg =append (_dbbg ,_agae [:_eeb ]...);};_ge .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0065\u006e\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",encoded );_ge .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0064\u0065\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",_dbbg );return _dbbg ,nil ;};

// PdfObjectInteger represents the primitive PDF integer numerical object.
type PdfObjectInteger int64 ;func (_faga *PdfParser )parseXrefStream (_bdgc *PdfObjectInteger )(*PdfObjectDictionary ,error ){if _bdgc !=nil {_ge .Log .Trace ("\u0058\u0052\u0065f\u0053\u0074\u006d\u0020x\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0061\u0074\u0020\u0025\u0064",_bdgc );_faga ._dceb .Seek (int64 (*_bdgc ),_c .SeekStart );_faga ._addbb =_cbe .NewReader (_faga ._dceb );};_aacfa :=_faga .GetFileOffset ();_bddd ,_bbec :=_faga .ParseIndirectObject ();if _bbec !=nil {_ge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072\u0065\u0061d\u0020\u0078\u0072\u0065\u0066\u0020\u006fb\u006a\u0065\u0063\u0074");return nil ,_b .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072e\u0061\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062j\u0065\u0063\u0074");};_ge .Log .Trace ("\u0058R\u0065f\u0053\u0074\u006d\u0020\u006fb\u006a\u0065c\u0074\u003a\u0020\u0025\u0073",_bddd );_edcf ,_ceba :=_bddd .(*PdfObjectStream );if !_ceba {_ge .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0058R\u0065\u0066\u0053\u0074\u006d\u0020\u0070o\u0069\u006e\u0074\u0069\u006e\u0067 \u0074\u006f\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065a\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0021");return nil ,_b .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0070\u006f\u0069\u006e\u0074i\u006e\u0067\u0020\u0074\u006f\u0020a\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006fb\u006a\u0065\u0063\u0074");};_eage :=_edcf .PdfObjectDictionary ;_febgbc ,_ceba :=_edcf .PdfObjectDictionary .Get ("\u0053\u0069\u007a\u0065").(*PdfObjectInteger );if !_ceba {_ge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u004d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0073\u0069\u007a\u0065\u0020f\u0072\u006f\u006d\u0020\u0078\u0072\u0065f\u0020\u0073\u0074\u006d");return nil ,_b .New ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0053\u0069\u007ae\u0020\u0066\u0072\u006f\u006d\u0020\u0078\u0072\u0065\u0066 \u0073\u0074\u006d");};if int64 (*_febgbc )> 8388607{_ge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u0053\u0069\u007a\u0065\u0020\u0065x\u0063\u0065\u0065\u0064\u0065\u0064\u0020l\u0069\u006d\u0069\u0074\u002c\u0020\u006f\u0076\u0065\u0072\u00208\u0033\u0038\u0038\u0036\u0030\u0037\u0020\u0028\u0025\u0064\u0029",*_febgbc );return nil ,_b .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_bffb :=_edcf .PdfObjectDictionary .Get ("\u0057");_gbec ,_ceba :=_bffb .(*PdfObjectArray );if !_ceba {return nil ,_b .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0057\u0020\u0069\u006e\u0020x\u0072\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d");};_fcceg :=_gbec .Len ();if _fcceg !=3{_ge .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020\u0028\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033\u0020\u002d\u0020\u0025\u0064\u0029",_fcceg );return nil ,_b .New ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065f\u0020s\u0074\u006d\u0020\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033");};var _bbadd []int64 ;for _gabag :=0;_gabag < 3;_gabag ++{_deef ,_dfcc :=GetInt (_gbec .Get (_gabag ));if !_dfcc {return nil ,_b .New ("i\u006e\u0076\u0061\u006cid\u0020w\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0074\u0079\u0070\u0065");};_bbadd =append (_bbadd ,int64 (*_deef ));};_gbfdb ,_bbec :=DecodeStream (_edcf );if _bbec !=nil {_ge .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020t\u006f \u0064e\u0063o\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u003a\u0020\u0025\u0076",_bbec );return nil ,_bbec ;};_cfebe :=int (_bbadd [0]);_efecb :=int (_bbadd [0]+_bbadd [1]);_fefgd :=int (_bbadd [0]+_bbadd [1]+_bbadd [2]);_faaaf :=int (_bbadd [0]+_bbadd [1]+_bbadd [2]);if _cfebe < 0||_efecb < 0||_fefgd < 0{_ge .Log .Debug ("\u0045\u0072\u0072\u006fr\u0020\u0073\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u003c \u0030 \u0028\u0025\u0064\u002c\u0025\u0064\u002c%\u0064\u0029",_cfebe ,_efecb ,_fefgd );return nil ,_b .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};if _faaaf ==0{_ge .Log .Debug ("\u004e\u006f\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063t\u0073\u0020\u0069\u006e\u0020\u0073t\u0072\u0065\u0061\u006d\u0020\u0028\u0064\u0065\u006c\u0074\u0061\u0062\u0020=\u003d\u0020\u0030\u0029");return _eage ,nil ;};_facc :=len (_gbfdb )/_faaaf ;_abcf :=0;_egaa :=_edcf .PdfObjectDictionary .Get ("\u0049\u006e\u0064e\u0078");var _edfd []int ;if _egaa !=nil {_ge .Log .Trace ("\u0049n\u0064\u0065\u0078\u003a\u0020\u0025b",_egaa );_agaf ,_fgeed :=_egaa .(*PdfObjectArray );if !_fgeed {_ge .Log .Debug ("\u0049\u006e\u0076\u0061\u006ci\u0064\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0029");return nil ,_b .New ("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0049\u006e\u0064e\u0078\u0020\u006f\u0062je\u0063\u0074");};if _agaf .Len ()%2!=0{_ge .Log .Debug ("\u0057\u0041\u0052\u004eI\u004e\u0047\u0020\u0046\u0061\u0069\u006c\u0075\u0072e\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020i\u006e\u0064\u0065\u0078\u0020n\u006f\u0074\u0020\u006d\u0075\u006c\u0074\u0069\u0070\u006c\u0065\u0020\u006f\u0066\u0020\u0032\u002e");return nil ,_b .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_abcf =0;_bfga ,_egce :=_agaf .ToIntegerArray ();if _egce !=nil {_ge .Log .Debug ("\u0045\u0072\u0072\u006f\u0072 \u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0065\u0078 \u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0073\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0073\u003a\u0020\u0025\u0076",_egce );return nil ,_egce ;};for _cafg :=0;_cafg < len (_bfga );_cafg +=2{_dda :=_bfga [_cafg ];_dbge :=_bfga [_cafg +1];for _dcfc :=0;_dcfc < _dbge ;_dcfc ++{_edfd =append (_edfd ,_dda +_dcfc );};_abcf +=_dbge ;};}else {for _ccfaa :=0;_ccfaa < int (*_febgbc );_ccfaa ++{_edfd =append (_edfd ,_ccfaa );};_abcf =int (*_febgbc );};if _facc ==_abcf +1{_ge .Log .Debug ("\u0049n\u0063\u006f\u006d\u0070ati\u0062\u0069\u006c\u0069t\u0079\u003a\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006di\u0073\u0073\u0069\u006e\u0067\u0020\u0063\u006f\u0076\u0065\u0072\u0061\u0067\u0065\u0020\u006f\u0066\u0020\u0031\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u002d\u0020\u0061\u0070\u0070en\u0064\u0069\u006eg\u0020\u006f\u006e\u0065\u0020-\u0020M\u0061\u0079\u0020\u006c\u0065\u0061\u0064\u0020\u0074o\u0020\u0070\u0072\u006f\u0062\u006c\u0065\u006d\u0073");_ddbec :=_abcf -1;for _ ,_eegc :=range _edfd {if _eegc > _ddbec {_ddbec =_eegc ;};};_edfd =append (_edfd ,_ddbec +1);_abcf ++;};if _facc !=len (_edfd ){_ge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020x\u0072\u0065\u0066 \u0073\u0074\u006d:\u0020\u006eu\u006d\u0020\u0065\u006e\u0074\u0072i\u0065s \u0021\u003d\u0020\u006c\u0065\u006e\u0028\u0069\u006e\u0064\u0069\u0063\u0065\u0073\u0029\u0020\u0028\u0025\u0064\u0020\u0021\u003d\u0020\u0025\u0064\u0029",_facc ,len (_edfd ));return nil ,_b .New ("\u0078\u0072ef\u0020\u0073\u0074m\u0020\u006e\u0075\u006d en\u0074ri\u0065\u0073\u0020\u0021\u003d\u0020\u006cen\u0028\u0069\u006e\u0064\u0069\u0063\u0065s\u0029");};_ge .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074s\u0020\u0063\u006f\u0075\u006e\u0074\u0020\u0025\u0064",_abcf );_ge .Log .Trace ("\u0049\u006e\u0064i\u0063\u0065\u0073\u003a\u0020\u0025\u0020\u0064",_edfd );_bgea :=func (_cff []byte )int64 {var _gagaff int64 ;for _efad :=0;_efad < len (_cff );_efad ++{_gagaff +=int64 (_cff [_efad ])*(1<<uint (8*(len (_cff )-_efad -1)));};return _gagaff ;};_ge .Log .Trace ("\u0044e\u0063\u006f\u0064\u0065d\u0020\u0073\u0074\u0072\u0065a\u006d \u006ce\u006e\u0067\u0074\u0068\u003a\u0020\u0025d",len (_gbfdb ));_aabg :=0;for _gcdbe :=0;_gcdbe < len (_gbfdb );_gcdbe +=_faaaf {_ccca :=_egagb (len (_gbfdb ),_gcdbe ,_gcdbe +_cfebe );if _ccca !=nil {_ge .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_ccca );return nil ,_ccca ;};_daff :=_gbfdb [_gcdbe :_gcdbe +_cfebe ];_ccca =_egagb (len (_gbfdb ),_gcdbe +_cfebe ,_gcdbe +_efecb );if _ccca !=nil {_ge .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_ccca );return nil ,_ccca ;};_feag :=_gbfdb [_gcdbe +_cfebe :_gcdbe +_efecb ];_ccca =_egagb (len (_gbfdb ),_gcdbe +_efecb ,_gcdbe +_fefgd );if _ccca !=nil {_ge .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_ccca );return nil ,_ccca ;};_acab :=_gbfdb [_gcdbe +_efecb :_gcdbe +_fefgd ];_fedb :=_bgea (_daff );_cdfc :=_bgea (_feag );_bcede :=_bgea (_acab );if _bbadd [0]==0{_fedb =1;};if _aabg >=len (_edfd ){_ge .Log .Debug ("X\u0052\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u002d\u0020\u0054\u0072\u0079\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0061\u0063\u0063e\u0073s\u0020\u0069\u006e\u0064e\u0078\u0020o\u0075\u0074\u0020\u006f\u0066\u0020\u0062\u006f\u0075\u006e\u0064\u0073\u0020\u002d\u0020\u0062\u0072\u0065\u0061\u006b\u0069\u006e\u0067");break ;};_dcce :=_edfd [_aabg ];_aabg ++;_ge .Log .Trace ("%\u0064\u002e\u0020\u0070\u0031\u003a\u0020\u0025\u0020\u0078",_dcce ,_daff );_ge .Log .Trace ("%\u0064\u002e\u0020\u0070\u0032\u003a\u0020\u0025\u0020\u0078",_dcce ,_feag );_ge .Log .Trace ("%\u0064\u002e\u0020\u0070\u0033\u003a\u0020\u0025\u0020\u0078",_dcce ,_acab );_ge .Log .Trace ("\u0025d\u002e \u0078\u0072\u0065\u0066\u003a \u0025\u0064 \u0025\u0064\u0020\u0025\u0064",_dcce ,_fedb ,_cdfc ,_bcede );if _fedb ==0{_ge .Log .Trace ("-\u0020\u0046\u0072\u0065\u0065\u0020o\u0062\u006a\u0065\u0063\u0074\u0020-\u0020\u0063\u0061\u006e\u0020\u0070\u0072o\u0062\u0061\u0062\u006c\u0079\u0020\u0069\u0067\u006e\u006fr\u0065");}else if _fedb ==1{_ge .Log .Trace ("\u002d\u0020I\u006e\u0020\u0075\u0073e\u0020\u002d \u0075\u006e\u0063\u006f\u006d\u0070\u0072\u0065s\u0073\u0065\u0064\u0020\u0076\u0069\u0061\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0062",_feag );if _cdfc ==_aacfa {_ge .Log .Debug ("\u0055\u0070d\u0061\u0074\u0069\u006e\u0067\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0058\u0052\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0064",_dcce ,_edcf .ObjectNumber );_dcce =int (_edcf .ObjectNumber );};if _abda ,_afga :=_faga ._afag .ObjectMap [_dcce ];!_afga ||int (_bcede )> _abda .Generation {_caed :=XrefObject {ObjectNumber :_dcce ,XType :XrefTypeTableEntry ,Offset :_cdfc ,Generation :int (_bcede )};_faga ._afag .ObjectMap [_dcce ]=_caed ;};}else if _fedb ==2{_ge .Log .Trace ("\u002d\u0020\u0049\u006e \u0075\u0073\u0065\u0020\u002d\u0020\u0063\u006f\u006d\u0070r\u0065s\u0073\u0065\u0064\u0020\u006f\u0062\u006ae\u0063\u0074");if _ ,_bdcbg :=_faga ._afag .ObjectMap [_dcce ];!_bdcbg {_adbe :=XrefObject {ObjectNumber :_dcce ,XType :XrefTypeObjectStream ,OsObjNumber :int (_cdfc ),OsObjIndex :int (_bcede )};_faga ._afag .ObjectMap [_dcce ]=_adbe ;_ge .Log .Trace ("\u0065\u006e\u0074\u0072\u0079\u003a\u0020\u0025\u002b\u0076",_adbe );};}else {_ge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052:\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0056\u0041L\u0049\u0044\u0020\u0054\u0059\u0050\u0045\u0020\u0058\u0072\u0065\u0066\u0053\u0074\u006d\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u003f\u002d\u002d\u002d\u002d\u002d\u002d-");continue ;};};if _faga ._ggad ==nil {_agcda :=XrefTypeObjectStream ;_faga ._ggad =&_agcda ;};return _eage ,nil ;};

// WriteString outputs the object as it is to be written to file.
func (_gcgd *PdfObjectArray )WriteString ()string {var _fffcb _dc .Builder ;_fffcb .WriteString ("\u005b");for _egfbc ,_aacd :=range _gcgd .Elements (){_fffcb .WriteString (_aacd .WriteString ());if _egfbc < (_gcgd .Len ()-1){_fffcb .WriteString ("\u0020");};};_fffcb .WriteString ("\u005d");return _fffcb .String ();};const (JB2Generic JBIG2CompressionType =iota ;JB2SymbolCorrelation ;JB2SymbolRankHaus ;);

// Elements returns a slice of the PdfObject elements in the array.
// Preferred over accessing the array directly as type may be changed in future major versions (v3).
func (_eeef *PdfObjectStreams )Elements ()[]PdfObject {if _eeef ==nil {return nil ;};return _eeef ._ccff ;};

// MakeArray creates an PdfObjectArray from a list of PdfObjects.
func MakeArray (objects ...PdfObject )*PdfObjectArray {_ceaf :=&PdfObjectArray {};_ceaf ._fbfcaa =[]PdfObject {};for _ ,_bcec :=range objects {_ceaf ._fbfcaa =append (_ceaf ._fbfcaa ,_bcec );};return _ceaf ;};func _efgf (_cgcb *PdfObjectDictionary )(_deca *_ca .ImageBase ){var (_gdef *PdfObjectInteger ;_dfec bool ;);if _gdef ,_dfec =_cgcb .Get ("\u0057\u0069\u0064t\u0068").(*PdfObjectInteger );_dfec {_deca =&_ca .ImageBase {Width :int (*_gdef )};}else {return nil ;};if _gdef ,_dfec =_cgcb .Get ("\u0048\u0065\u0069\u0067\u0068\u0074").(*PdfObjectInteger );_dfec {_deca .Height =int (*_gdef );};if _gdef ,_dfec =_cgcb .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074").(*PdfObjectInteger );_dfec {_deca .BitsPerComponent =int (*_gdef );};if _gdef ,_dfec =_cgcb .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073").(*PdfObjectInteger );_dfec {_deca .ColorComponents =int (*_gdef );};return _deca ;};

// WriteString outputs the object as it is to be written to file.
func (_affa *PdfObjectStreams )WriteString ()string {var _bdba _dc .Builder ;_bdba .WriteString (_g .FormatInt (_affa .ObjectNumber ,10));_bdba .WriteString ("\u0020\u0030\u0020\u0052");return _bdba .String ();};func (_gcf *PdfParser )lookupByNumber (_cccf int ,_edd bool )(PdfObject ,bool ,error ){_cag ,_cbeg :=_gcf .ObjCache [_cccf ];if _cbeg {_ge .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0063a\u0063\u0068\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0025\u0064",_cccf );return _cag ,false ,nil ;};_de ,_cbeg :=_gcf ._afag .ObjectMap [_cccf ];if !_cbeg {_ge .Log .Trace ("\u0055\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u006c\u006f\u0063\u0061t\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0069\u006e\u0020\u0078\u0072\u0065\u0066\u0073\u0021 \u002d\u0020\u0052\u0065\u0074u\u0072\u006e\u0069\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074");var _ccg PdfObjectNull ;return &_ccg ,false ,nil ;};_ge .Log .Trace ("L\u006fo\u006b\u0075\u0070\u0020\u006f\u0062\u006a\u0020n\u0075\u006d\u0062\u0065r \u0025\u0064",_cccf );if _de .XType ==XrefTypeTableEntry {_ge .Log .Trace ("\u0078r\u0065f\u006f\u0062\u006a\u0020\u006fb\u006a\u0020n\u0075\u006d\u0020\u0025\u0064",_de .ObjectNumber );_ge .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u0067e\u006e\u0020\u0025\u0064",_de .Generation );_ge .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0064",_de .Offset );_gcf ._dceb .Seek (_de .Offset ,_ef .SEEK_SET );_gcf ._addbb =_cbe .NewReader (_gcf ._dceb );_dg ,_feef :=_gcf .ParseIndirectObject ();if _feef !=nil {_ge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006ce\u0064\u0020\u0072\u0065\u0061\u0064\u0069n\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029",_feef );if _edd {_ge .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0072\u0065\u0070\u0061\u0069r\u0020\u0078\u0072\u0065\u0066\u0073\u0020\u0028\u0074\u006f\u0070\u0020d\u006f\u0077\u006e\u0029");_eed ,_ded :=_gcf .repairRebuildXrefsTopDown ();if _ded !=nil {_ge .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020r\u0065\u0070\u0061\u0069\u0072\u0020\u0028\u0025\u0073\u0029",_ded );return nil ,false ,_ded ;};_gcf ._afag =*_eed ;return _gcf .lookupByNumber (_cccf ,false );};return nil ,false ,_feef ;};if _edd {_bed ,_ ,_ :=_dca (_dg );if int (_bed )!=_cccf {_ge .Log .Debug ("\u0049n\u0076\u0061\u006c\u0069d\u0020\u0078\u0072\u0065\u0066s\u003a \u0052e\u0062\u0075\u0069\u006c\u0064\u0069\u006eg");_fff :=_gcf .rebuildXrefTable ();if _fff !=nil {return nil ,false ,_fff ;};_gcf .ObjCache =objectCache {};return _gcf .lookupByNumberWrapper (_cccf ,false );};};_ge .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006f\u0062\u006a");_gcf .ObjCache [_cccf ]=_dg ;return _dg ,false ,nil ;}else if _de .XType ==XrefTypeObjectStream {_ge .Log .Trace ("\u0078r\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0021");_ge .Log .Trace ("\u003e\u004c\u006f\u0061\u0064\u0020\u0076\u0069\u0061\u0020\u004f\u0053\u0021");_ge .Log .Trace ("\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d \u0061\u0076\u0061\u0069\u006c\u0061b\u006c\u0065\u0020\u0069\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020%\u0064\u002f\u0025\u0064",_de .OsObjNumber ,_de .OsObjIndex );if _de .OsObjNumber ==_cccf {_ge .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0043i\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065f\u0065\u0072\u0065n\u0063e\u0021\u003f\u0021");return nil ,true ,_b .New ("\u0078\u0072\u0065f \u0063\u0069\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");};if _ ,_dgc :=_gcf ._afag .ObjectMap [_de .OsObjNumber ];_dgc {_df ,_eff :=_gcf .lookupObjectViaOS (_de .OsObjNumber ,_cccf );if _eff !=nil {_ge .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0052\u0065\u0074\u0075\u0072\u006e\u0069n\u0067\u0020\u0045\u0052\u0052\u0020\u0028\u0025\u0073\u0029",_eff );return nil ,true ,_eff ;};_ge .Log .Trace ("\u003c\u004c\u006f\u0061\u0064\u0065\u0064\u0020\u0076i\u0061\u0020\u004f\u0053");_gcf .ObjCache [_cccf ]=_df ;if _gcf ._ddfa !=nil {_gcf ._ddfa ._ce [_df ]=true ;};return _df ,true ,nil ;};_ge .Log .Debug ("\u003f\u003f\u0020\u0042\u0065\u006c\u006f\u006eg\u0073\u0020\u0074o \u0061\u0020\u006e\u006f\u006e\u002dc\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u002e.\u002e\u0021");return nil ,true ,_b .New ("\u006f\u0073\u0020\u0062\u0065\u006c\u006fn\u0067\u0073\u0020t\u006f\u0020\u0061\u0020n\u006f\u006e\u0020\u0063\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074");};return nil ,false ,_b .New ("\u0075\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0078\u0072\u0065\u0066 \u0074\u0079\u0070\u0065");};

// MakeStream creates an PdfObjectStream with specified contents and encoding. If encoding is nil, then raw encoding
// will be used (i.e. no encoding applied).
func MakeStream (contents []byte ,encoder StreamEncoder )(*PdfObjectStream ,error ){_ffda :=&PdfObjectStream {};if encoder ==nil {encoder =NewRawEncoder ();};_ffda .PdfObjectDictionary =encoder .MakeStreamDict ();_gadba ,_ccec :=encoder .EncodeBytes (contents );if _ccec !=nil {return nil ,_ccec ;};_ffda .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_gadba ))));_ffda .Stream =_gadba ;return _ffda ,nil ;};

// Inspect analyzes the document object structure. Returns a map of object types (by name) with the instance count
// as value.
func (_eegf *PdfParser )Inspect ()(map[string ]int ,error ){return _eegf .inspect ()};func (_beffa *PdfParser )inspect ()(map[string ]int ,error ){_ge .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0053P\u0045\u0043\u0054\u0020\u002d\u002d\u002d\u002d\u002d\u002d-\u002d\u002d\u002d");_ge .Log .Trace ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");_ddcd :=map[string ]int {};_daafb :=0;_beae :=0;var _ffef []int ;for _abca :=range _beffa ._afag .ObjectMap {_ffef =append (_ffef ,_abca );};_f .Ints (_ffef );_dbfbc :=0;for _ ,_gddg :=range _ffef {_fgff :=_beffa ._afag .ObjectMap [_gddg ];if _fgff .ObjectNumber ==0{continue ;};_daafb ++;_ge .Log .Trace ("\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d");_ge .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0075\u0070\u0020\u006f\u0062\u006a\u0065c\u0074 \u006e\u0075\u006d\u0062\u0065\u0072\u003a \u0025\u0064",_fgff .ObjectNumber );_caeg ,_fgbab :=_beffa .LookupByNumber (_fgff .ObjectNumber );if _fgbab !=nil {_ge .Log .Trace ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u006c\u006f\u006f\u006b\u0075p\u0020\u006f\u0062\u006a\u0020\u0025\u0064 \u0028\u0025\u0073\u0029",_fgff .ObjectNumber ,_fgbab );_beae ++;continue ;};_ge .Log .Trace ("\u006fb\u006a\u003a\u0020\u0025\u0073",_caeg );_fdac ,_degad :=_caeg .(*PdfIndirectObject );if _degad {_ge .Log .Trace ("\u0049N\u0044 \u004f\u004f\u0042\u004a\u0020\u0025\u0064\u003a\u0020\u0025\u0073",_fgff .ObjectNumber ,_fdac );_gefg ,_faegc :=_fdac .PdfObject .(*PdfObjectDictionary );if _faegc {if _fedeb ,_aaeef :=_gefg .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_aaeef {_bddac :=string (*_fedeb );_ge .Log .Trace ("\u002d\u002d\u002d\u003e\u0020\u004f\u0062\u006a\u0020\u0074\u0079\u0070e\u003a\u0020\u0025\u0073",_bddac );_ ,_ccdfeb :=_ddcd [_bddac ];if _ccdfeb {_ddcd [_bddac ]++;}else {_ddcd [_bddac ]=1;};}else if _cdaeb ,_faegcd :=_gefg .Get ("\u0053u\u0062\u0074\u0079\u0070\u0065").(*PdfObjectName );_faegcd {_decdf :=string (*_cdaeb );_ge .Log .Trace ("-\u002d-\u003e\u0020\u004f\u0062\u006a\u0020\u0073\u0075b\u0074\u0079\u0070\u0065: \u0025\u0073",_decdf );_ ,_faecd :=_ddcd [_decdf ];if _faecd {_ddcd [_decdf ]++;}else {_ddcd [_decdf ]=1;};};if _aaea ,_gdeb :=_gefg .Get ("\u0053").(*PdfObjectName );_gdeb &&*_aaea =="\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"{_ ,_bdca :=_ddcd ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"];if _bdca {_ddcd ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]++;}else {_ddcd ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]=1;};};};}else if _adfc ,_gbegd :=_caeg .(*PdfObjectStream );_gbegd {if _gdbag ,_bdeg :=_adfc .PdfObjectDictionary .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_bdeg {_ge .Log .Trace ("\u002d\u002d\u003e\u0020\u0053\u0074\u0072\u0065\u0061\u006d\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073",*_gdbag );_deeda :=string (*_gdbag );if _ ,_ceae :=_ddcd [_deeda ];_ceae {_ddcd [_deeda ]++;}else {_ddcd [_deeda ]=1;};};}else {_fcga ,_fbgd :=_caeg .(*PdfObjectDictionary );if _fbgd {_gbbcd ,_fcfb :=_fcga .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if _fcfb {_acda :=string (*_gbbcd );_ge .Log .Trace ("\u002d-\u002d \u006f\u0062\u006a\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073",_acda );_ddcd [_acda ]++;};};_ge .Log .Trace ("\u0044\u0049\u0052\u0045\u0043\u0054\u0020\u004f\u0042\u004a\u0020\u0025d\u003a\u0020\u0025\u0073",_fgff .ObjectNumber ,_caeg );};_dbfbc ++;};_ge .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0045\u004fF\u0020\u0049\u004e\u0053\u0050\u0045\u0043T\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d");_ge .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");_ge .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074 \u0063\u006f\u0075\u006e\u0074\u003a\u0020\u0025\u0064",_daafb );_ge .Log .Trace ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u006f\u006b\u0075p\u003a\u0020\u0025\u0064",_beae );for _ccfda ,_ffcc :=range _ddcd {_ge .Log .Trace ("\u0025\u0073\u003a\u0020\u0025\u0064",_ccfda ,_ffcc );};_ge .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");if len (_beffa ._afag .ObjectMap )< 1{_ge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0068\u0069\u0073 \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074 \u0069s\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0028\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0021\u0029");return nil ,_fe .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0064\u006fc\u0075\u006d\u0065\u006e\u0074\u0020\u0028\u0078r\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006d\u0069\u0073s\u0069\u006e\u0067\u0029");};_ffdd ,_gdbe :=_ddcd ["\u0046\u006f\u006e\u0074"];if !_gdbe ||_ffdd < 2{_ge .Log .Trace ("\u0054\u0068\u0069s \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020i\u0073 \u0070r\u006fb\u0061\u0062\u006c\u0079\u0020\u0073\u0063\u0061\u006e\u006e\u0065\u0064\u0021");}else {_ge .Log .Trace ("\u0054\u0068\u0069\u0073\u0020\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020\u0069\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0066o\u0072\u0020\u0065\u0078\u0074r\u0061\u0063t\u0069\u006f\u006e\u0021");};return _ddcd ,nil ;};

// GetFloat returns the *PdfObjectFloat represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetFloat (obj PdfObject )(_dfeg *PdfObjectFloat ,_egea bool ){_dfeg ,_egea =TraceToDirectObject (obj ).(*PdfObjectFloat );return _dfeg ,_egea ;};

// DrawableImage is same as golang image/draw's Image interface that allow drawing images.
type DrawableImage interface{ColorModel ()_gb .Model ;Bounds ()_ffa .Rectangle ;At (_dcfeb ,_aae int )_gb .Color ;Set (_egc ,_agbd int ,_bfff _gb .Color );};

// Get returns the i-th element of the array or nil if out of bounds (by index).
func (_dba *PdfObjectArray )Get (i int )PdfObject {if _dba ==nil ||i >=len (_dba ._fbfcaa )||i < 0{return nil ;};return _dba ._fbfcaa [i ];};func _gbfcd (_egedc int )int {if _egedc < 0{return -_egedc ;};return _egedc ;};type objectStream struct{N int ;_bb []byte ;_aea map[int ]int64 ;};type objectCache map[int ]PdfObject ;

// String returns a string describing `stream`.
func (_dcbg *PdfObjectStream )String ()string {return _fe .Sprintf ("O\u0062j\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0025\u0064: \u0025\u0073",_dcbg .ObjectNumber ,_dcbg .PdfObjectDictionary );};

// DecodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_gdgd *RawEncoder )DecodeBytes (encoded []byte )([]byte ,error ){return encoded ,nil };

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_ccfg *ASCIIHexEncoder )MakeStreamDict ()*PdfObjectDictionary {_abag :=MakeDict ();_abag .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_ccfg .GetFilterName ()));return _abag ;};const (StreamEncodingFilterNameFlate ="F\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameLZW ="\u004cZ\u0057\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameDCT ="\u0044C\u0054\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameRunLength ="\u0052u\u006eL\u0065\u006e\u0067\u0074\u0068\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameASCIIHex ="\u0041\u0053\u0043\u0049\u0049\u0048\u0065\u0078\u0044e\u0063\u006f\u0064\u0065";StreamEncodingFilterNameASCII85 ="\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameCCITTFax ="\u0043\u0043\u0049\u0054\u0054\u0046\u0061\u0078\u0044e\u0063\u006f\u0064\u0065";StreamEncodingFilterNameJBIG2 ="J\u0042\u0049\u0047\u0032\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameJPX ="\u004aP\u0058\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameRaw ="\u0052\u0061\u0077";);func (_bbge *offsetReader )Read (p []byte )(_gcef int ,_fdfd error ){return _bbge ._cbfa .Read (p )};

// IsOctalDigit checks if a character can be part of an octal digit string.
func IsOctalDigit (c byte )bool {return '0'<=c &&c <='7'};

// PdfCryptNewEncrypt makes the document crypt handler based on a specified crypt filter.
func PdfCryptNewEncrypt (cf _ac .Filter ,userPass ,ownerPass []byte ,perm _gc .Permissions )(*PdfCrypt ,*EncryptInfo ,error ){_gbb :=&PdfCrypt {_efe :make (map[PdfObject ]bool ),_effg :make (cryptFilters ),_affe :_gc .StdEncryptDict {P :perm ,EncryptMetadata :true }};var _bba Version ;if cf !=nil {_aad :=cf .PDFVersion ();_bba .Major ,_bba .Minor =_aad [0],_aad [1];V ,R :=cf .HandlerVersion ();_gbb ._ddg .V =V ;_gbb ._affe .R =R ;_gbb ._ddg .Length =cf .KeyLength ()*8;};const (_ccb =_bgbf ;);_gbb ._effg [_ccb ]=cf ;if _gbb ._ddg .V >=4{_gbb ._dedf =_ccb ;_gbb ._cbd =_ccb ;};_bdf :=_gbb .newEncryptDict ();_aaf :=_cb .Sum ([]byte (_gbe .Now ().Format (_gbe .RFC850 )));_bcb :=string (_aaf [:]);_gccf :=make ([]byte ,100);_d .Read (_gccf );_aaf =_cb .Sum (_gccf );_daa :=string (_aaf [:]);_ge .Log .Trace ("\u0052\u0061\u006e\u0064\u006f\u006d\u0020\u0062\u003a\u0020\u0025\u0020\u0078",_gccf );_ge .Log .Trace ("\u0047\u0065\u006e\u0020\u0049\u0064\u0020\u0030\u003a\u0020\u0025\u0020\u0078",_bcb );_gbb ._gdcc =string (_bcb );_dfb :=_gbb .generateParams (userPass ,ownerPass );if _dfb !=nil {return nil ,nil ,_dfb ;};_fbf (&_gbb ._affe ,_bdf );if _gbb ._ddg .V >=4{if _fgb :=_gbb .saveCryptFilters (_bdf );_fgb !=nil {return nil ,nil ,_fgb ;};};return _gbb ,&EncryptInfo {Version :_bba ,Encrypt :_bdf ,ID0 :_bcb ,ID1 :_daa },nil ;};

// Encode encodes previously prepare jbig2 document and stores it as the byte slice.
func (_gedef *JBIG2Encoder )Encode ()(_eca []byte ,_fccb error ){const _gccd ="J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0045\u006eco\u0064\u0065";if _gedef ._dafd ==nil {return nil ,_cc .Errorf (_gccd ,"\u0064\u006f\u0063u\u006d\u0065\u006e\u0074 \u0069\u006e\u0070\u0075\u0074\u0020\u0064a\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006e\u0065\u0064");};_gedef ._dafd .FullHeaders =_gedef .DefaultPageSettings .FileMode ;_eca ,_fccb =_gedef ._dafd .Encode ();if _fccb !=nil {return nil ,_cc .Wrap (_fccb ,_gccd ,"");};return _eca ,nil ;};func (_ebfgg *PdfParser )parseXrefTable ()(*PdfObjectDictionary ,error ){var _dedeg *PdfObjectDictionary ;_aaaaa ,_fgce :=_ebfgg .readTextLine ();if _fgce !=nil {return nil ,_fgce ;};_ge .Log .Trace ("\u0078\u0072\u0065\u0066 f\u0069\u0072\u0073\u0074\u0020\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_aaaaa );_dgge :=-1;_bcbg :=0;_gdgfe :=false ;_gece :="";for {_ebfgg .skipSpaces ();_ ,_bbfb :=_ebfgg ._addbb .Peek (1);if _bbfb !=nil {return nil ,_bbfb ;};_aaaaa ,_bbfb =_ebfgg .readTextLine ();if _bbfb !=nil {return nil ,_bbfb ;};_dcgf :=_agedg .FindStringSubmatch (_aaaaa );if len (_dcgf )==0{_fgeae :=len (_gece )> 0;_gece +=_aaaaa +"\u000a";if _fgeae {_dcgf =_agedg .FindStringSubmatch (_gece );};};if len (_dcgf )==3{_bbcg ,_ :=_g .Atoi (_dcgf [1]);_aafgf ,_ :=_g .Atoi (_dcgf [2]);_dgge =_bbcg ;_bcbg =_aafgf ;_gdgfe =true ;_gece ="";_ge .Log .Trace ("\u0078r\u0065\u0066 \u0073\u0075\u0062s\u0065\u0063\u0074\u0069\u006f\u006e\u003a \u0066\u0069\u0072\u0073\u0074\u0020o\u0062\u006a\u0065\u0063\u0074\u003a\u0020\u0025\u0064\u0020\u006fb\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_dgge ,_bcbg );continue ;};_dgcaa :=_gbdgd .FindStringSubmatch (_aaaaa );if len (_dgcaa )==4{if _gdgfe ==false {_ge .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0058r\u0065\u0066\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u006fr\u006da\u0074\u0021\u000a");return nil ,_b .New ("\u0078\u0072\u0065\u0066 i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072\u006d\u0061\u0074");};_aagc ,_ :=_g .ParseInt (_dgcaa [1],10,64);_ecfg ,_ :=_g .Atoi (_dgcaa [2]);_bbef :=_dgcaa [3];_gece ="";if _dc .ToLower (_bbef )=="\u006e"&&_aagc > 1{_dadda ,_fccd :=_ebfgg ._afag .ObjectMap [_dgge ];if !_fccd ||_ecfg > _dadda .Generation {_dgged :=XrefObject {ObjectNumber :_dgge ,XType :XrefTypeTableEntry ,Offset :_aagc ,Generation :_ecfg };_ebfgg ._afag .ObjectMap [_dgge ]=_dgged ;};};_dgge ++;continue ;};if (len (_aaaaa )> 6)&&(_aaaaa [:7]=="\u0074r\u0061\u0069\u006c\u0065\u0072"){_ge .Log .Trace ("\u0046o\u0075n\u0064\u0020\u0074\u0072\u0061i\u006c\u0065r\u0020\u002d\u0020\u0025\u0073",_aaaaa );if len (_aaaaa )> 9{_bbad :=_ebfgg .GetFileOffset ();_ebfgg .SetFileOffset (_bbad -int64 (len (_aaaaa ))+7);};_ebfgg .skipSpaces ();_ebfgg .skipComments ();_ge .Log .Trace ("R\u0065\u0061\u0064\u0069ng\u0020t\u0072\u0061\u0069\u006c\u0065r\u0020\u0064\u0069\u0063\u0074\u0021");_ge .Log .Trace ("\u0070\u0065\u0065\u006b\u003a\u0020\u0022\u0025\u0073\u0022",_aaaaa );_dedeg ,_bbfb =_ebfgg .ParseDict ();_ge .Log .Trace ("\u0045O\u0046\u0020\u0072\u0065a\u0064\u0069\u006e\u0067\u0020t\u0072a\u0069l\u0065\u0072\u0020\u0064\u0069\u0063\u0074!");if _bbfb !=nil {_ge .Log .Debug ("\u0045\u0072\u0072o\u0072\u0020\u0070\u0061r\u0073\u0069\u006e\u0067\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u0064\u0069\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_bbfb );return nil ,_bbfb ;};break ;};if _aaaaa =="\u0025\u0025\u0045O\u0046"{_ge .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006e\u0064 \u006f\u0066\u0020\u0066\u0069\u006c\u0065 -\u0020\u0074\u0072\u0061i\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066ou\u006e\u0064 \u002d\u0020\u0065\u0072\u0072\u006f\u0072\u0021");return nil ,_b .New ("\u0065\u006e\u0064 \u006f\u0066\u0020\u0066i\u006c\u0065\u0020\u002d\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};_ge .Log .Trace ("\u0078\u0072\u0065\u0066\u0020\u006d\u006f\u0072\u0065 \u003a\u0020\u0025\u0073",_aaaaa );};_ge .Log .Trace ("\u0045\u004f\u0046 p\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0021");if _ebfgg ._ggad ==nil {_gcba :=XrefTypeTableEntry ;_ebfgg ._ggad =&_gcba ;};return _dedeg ,nil ;};

// ToIntegerArray returns a slice of all array elements as an int slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_fgfe *PdfObjectArray )ToIntegerArray ()([]int ,error ){var _gaea []int ;for _ ,_agadf :=range _fgfe .Elements (){if _cdfg ,_ebed :=_agadf .(*PdfObjectInteger );_ebed {_gaea =append (_gaea ,int (*_cdfg ));}else {return nil ,ErrTypeError ;};};return _gaea ,nil ;};func _fcg (_cce *PdfObjectStream ,_aba *PdfObjectDictionary )(*FlateEncoder ,error ){_bfgg :=NewFlateEncoder ();_dece :=_cce .PdfObjectDictionary ;if _dece ==nil {return _bfgg ,nil ;};_bfgg ._bbaf =_efgf (_dece );if _aba ==nil {_adcdd :=TraceToDirectObject (_dece .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));switch _afc :=_adcdd .(type ){case *PdfObjectArray :_bbc :=_afc ;if _bbc .Len ()!=1{_ge .Log .Debug ("\u0045\u0072\u0072\u006f\u0072:\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020a\u0072\u0072\u0061\u0079\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0021\u003d\u0020\u0031\u0020\u0028\u0025\u0064\u0029",_bbc .Len ());return nil ,_b .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_adcdd =TraceToDirectObject (_bbc .Get (0));case *PdfObjectDictionary :_aba =_afc ;case *PdfObjectNull ,nil :default:_ge .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020n\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079 \u0028%\u0054\u0029",_adcdd );return nil ,_fe .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _aba ==nil {return _bfgg ,nil ;};_ge .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_aba .String ());_fgg :=_aba .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");if _fgg ==nil {_ge .Log .Debug ("E\u0072\u0072o\u0072\u003a\u0020\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067 \u0066\u0072\u006f\u006d\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073 \u002d\u0020\u0043\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020\u0077\u0069t\u0068\u0020\u0064\u0065\u0066\u0061\u0075\u006c\u0074\u0020\u00281\u0029");}else {_bad ,_gba :=_fgg .(*PdfObjectInteger );if !_gba {_ge .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_fgg );return nil ,_fe .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_bfgg .Predictor =int (*_bad );};_fgg =_aba .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");if _fgg !=nil {_gfa ,_dfbf :=_fgg .(*PdfObjectInteger );if !_dfbf {_ge .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");return nil ,_fe .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_bfgg .BitsPerComponent =int (*_gfa );};if _bfgg .Predictor > 1{_bfgg .Columns =1;_fgg =_aba .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");if _fgg !=nil {_gcdc ,_gaee :=_fgg .(*PdfObjectInteger );if !_gaee {return nil ,_fe .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_bfgg .Columns =int (*_gcdc );};_bfgg .Colors =1;_fgg =_aba .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _fgg !=nil {_ggag ,_bge :=_fgg .(*PdfObjectInteger );if !_bge {return nil ,_fe .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");};_bfgg .Colors =int (*_ggag );};};return _bfgg ,nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_fbfg *MultiEncoder )MakeDecodeParams ()PdfObject {if len (_fbfg ._cbdga )==0{return nil ;};if len (_fbfg ._cbdga )==1{return _fbfg ._cbdga [0].MakeDecodeParams ();};_dab :=MakeArray ();for _ ,_eccd :=range _fbfg ._cbdga {_dadff :=_eccd .MakeDecodeParams ();if _dadff ==nil {_dab .Append (MakeNull ());}else {_dab .Append (_dadff );};};return _dab ;};

// Merge merges in key/values from another dictionary. Overwriting if has same keys.
// The mutated dictionary (d) is returned in order to allow method chaining.
func (_afge *PdfObjectDictionary )Merge (another *PdfObjectDictionary )*PdfObjectDictionary {if another !=nil {for _ ,_ggeaf :=range another .Keys (){_cbcg :=another .Get (_ggeaf );_afge .Set (_ggeaf ,_cbcg );};};return _afge ;};

// ASCII85Encoder implements ASCII85 encoder/decoder.
type ASCII85Encoder struct{};

// ParseIndirectObject parses an indirect object from the input stream. Can also be an object stream.
// Returns the indirect object (*PdfIndirectObject) or the stream object (*PdfObjectStream).
func (_cffc *PdfParser )ParseIndirectObject ()(PdfObject ,error ){_gcbe :=PdfIndirectObject {};_gcbe ._aaccf =_cffc ;_ge .Log .Trace ("\u002dR\u0065a\u0064\u0020\u0069\u006e\u0064i\u0072\u0065c\u0074\u0020\u006f\u0062\u006a");_gbaa ,_bgbg :=_cffc ._addbb .Peek (20);if _bgbg !=nil {if _bgbg !=_c .EOF {_ge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020r\u0065a\u0064\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a");return &_gcbe ,_bgbg ;};};_ge .Log .Trace ("\u0028\u0069\u006edi\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_gbaa ));_ggec :=_ggcc .FindStringSubmatchIndex (string (_gbaa ));if len (_ggec )< 6{if _bgbg ==_c .EOF {return nil ,_bgbg ;};_ge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_gbaa ));return &_gcbe ,_b .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");};_cffc ._addbb .Discard (_ggec [0]);_ge .Log .Trace ("O\u0066\u0066\u0073\u0065\u0074\u0073\u0020\u0025\u0020\u0064",_ggec );_gabe :=_ggec [1]-_ggec [0];_efce :=make ([]byte ,_gabe );_ ,_bgbg =_cffc .ReadAtLeast (_efce ,_gabe );if _bgbg !=nil {_ge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u0072\u0065\u0061\u0064\u0020-\u0020\u0025\u0073",_bgbg );return nil ,_bgbg ;};_ge .Log .Trace ("\u0074\u0065\u0078t\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_efce );_fgbeg :=_ggcc .FindStringSubmatch (string (_efce ));if len (_fgbeg )< 3{_ge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_efce ));return &_gcbe ,_b .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");};_ggbb ,_ :=_g .Atoi (_fgbeg [1]);_gadb ,_ :=_g .Atoi (_fgbeg [2]);_gcbe .ObjectNumber =int64 (_ggbb );_gcbe .GenerationNumber =int64 (_gadb );for {_afae ,_cabd :=_cffc ._addbb .Peek (2);if _cabd !=nil {return &_gcbe ,_cabd ;};_ge .Log .Trace ("I\u006ed\u002e\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_afae ),string (_afae ));if IsWhiteSpace (_afae [0]){_cffc .skipSpaces ();}else if _afae [0]=='%'{_cffc .skipComments ();}else if (_afae [0]=='<')&&(_afae [1]=='<'){_ge .Log .Trace ("\u0043\u0061\u006c\u006c\u0020\u0050\u0061\u0072\u0073e\u0044\u0069\u0063\u0074");_gcbe .PdfObject ,_cabd =_cffc .ParseDict ();_ge .Log .Trace ("\u0045\u004f\u0046\u0020Ca\u006c\u006c\u0020\u0050\u0061\u0072\u0073\u0065\u0044\u0069\u0063\u0074\u003a\u0020%\u0076",_cabd );if _cabd !=nil {return &_gcbe ,_cabd ;};_ge .Log .Trace ("\u0050\u0061\u0072\u0073\u0065\u0064\u0020\u0064\u0069\u0063t\u0069\u006f\u006e\u0061\u0072\u0079\u002e.\u002e\u0020\u0066\u0069\u006e\u0069\u0073\u0068\u0065\u0064\u002e");}else if (_afae [0]=='/')||(_afae [0]=='(')||(_afae [0]=='[')||(_afae [0]=='<'){_gcbe .PdfObject ,_cabd =_cffc .parseObject ();if _cabd !=nil {return &_gcbe ,_cabd ;};_ge .Log .Trace ("P\u0061\u0072\u0073\u0065\u0064\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u002e\u002e\u002e \u0066\u0069\u006ei\u0073h\u0065\u0064\u002e");}else if _afae [0]==']'{_ge .Log .Debug ("\u0057\u0041\u0052\u004e\u0049N\u0047\u003a\u0020\u0027\u005d\u0027 \u0063\u0068\u0061\u0072\u0061\u0063\u0074e\u0072\u0020\u006eo\u0074\u0020\u0062\u0065i\u006e\u0067\u0020\u0075\u0073\u0065d\u0020\u0061\u0073\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006e\u0064\u0069n\u0067\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e");_cffc ._addbb .Discard (1);}else {if _afae [0]=='e'{_beaf ,_eafg :=_cffc .readTextLine ();if _eafg !=nil {return nil ,_eafg ;};if len (_beaf )>=6&&_beaf [0:6]=="\u0065\u006e\u0064\u006f\u0062\u006a"{break ;};}else if _afae [0]=='s'{_afae ,_ =_cffc ._addbb .Peek (10);if string (_afae [:6])=="\u0073\u0074\u0072\u0065\u0061\u006d"{_ddcgb :=6;if len (_afae )> 6{if IsWhiteSpace (_afae [_ddcgb ])&&_afae [_ddcgb ]!='\r'&&_afae [_ddcgb ]!='\n'{_ge .Log .Debug ("\u004e\u006fn\u002d\u0063\u006f\u006e\u0066\u006f\u0072\u006d\u0061\u006e\u0074\u0020\u0050\u0044\u0046\u0020\u006e\u006f\u0074 \u0065\u006e\u0064\u0069\u006e\u0067 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0069\u006e\u0065\u0020\u0070\u0072o\u0070\u0065r\u006c\u0079\u0020\u0077i\u0074\u0068\u0020\u0045\u004fL\u0020\u006d\u0061\u0072\u006b\u0065\u0072");_ddcgb ++;};if _afae [_ddcgb ]=='\r'{_ddcgb ++;if _afae [_ddcgb ]=='\n'{_ddcgb ++;};}else if _afae [_ddcgb ]=='\n'{_ddcgb ++;};};_cffc ._addbb .Discard (_ddcgb );_gfge ,_gdfg :=_gcbe .PdfObject .(*PdfObjectDictionary );if !_gdfg {return nil ,_b .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006di\u0073s\u0069\u006e\u0067\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_ge .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0069c\u0074\u0020\u0025\u0073",_gfge );_fgec ,_dabd :=_cffc .traceStreamLength (_gfge .Get ("\u004c\u0065\u006e\u0067\u0074\u0068"));if _dabd !=nil {_ge .Log .Debug ("\u0046\u0061\u0069l\u0020\u0074\u006f\u0020t\u0072\u0061\u0063\u0065\u0020\u0073\u0074r\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0025\u0076",_dabd );return nil ,_dabd ;};_ge .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_fgec );_ggccb ,_acfd :=_fgec .(*PdfObjectInteger );if !_acfd {return nil ,_b .New ("\u0073\u0074re\u0061\u006d\u0020l\u0065\u006e\u0067\u0074h n\u0065ed\u0073\u0020\u0074\u006f\u0020\u0062\u0065 a\u006e\u0020\u0069\u006e\u0074\u0065\u0067e\u0072");};_fdgf :=*_ggccb ;if _fdgf < 0{return nil ,_b .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006e\u0065\u0065\u0064\u0073\u0020\u0074\u006f \u0062e\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0030");};_cfag :=_cffc .GetFileOffset ();_ecced :=_cffc .xrefNextObjectOffset (_cfag );if _cfag +int64 (_fdgf )> _ecced &&_ecced > _cfag {_ge .Log .Debug ("E\u0078\u0070\u0065\u0063te\u0064 \u0065\u006e\u0064\u0069\u006eg\u0020\u0061\u0074\u0020\u0025\u0064",_cfag +int64 (_fdgf ));_ge .Log .Debug ("\u004e\u0065\u0078\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020\u0061t\u0020\u0025\u0064",_ecced );_gadc :=_ecced -_cfag -17;if _gadc < 0{return nil ,_b .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020go\u0069\u006e\u0067 \u0070\u0061s\u0074\u0020\u0062\u006f\u0075\u006ed\u0061\u0072i\u0065\u0073");};_ge .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0061\u0020l\u0065\u006e\u0067\u0074\u0068\u0020c\u006f\u0072\u0072\u0065\u0063\u0074\u0069\u006f\u006e\u0020\u0074\u006f\u0020%\u0064\u002e\u002e\u002e",_gadc );_fdgf =PdfObjectInteger (_gadc );_gfge .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (_gadc ));};if int64 (_fdgf )> _cffc ._cded {_ge .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0053t\u0072\u0065\u0061\u006d\u0020l\u0065\u006e\u0067\u0074\u0068\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u0061\u0072\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0066\u0069\u006c\u0065\u0020\u0073\u0069\u007a\u0065");return nil ,_b .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020la\u0072\u0067\u0065r\u0020\u0074h\u0061\u006e\u0020\u0066\u0069\u006ce\u0020\u0073i\u007a\u0065");};_eabg :=make ([]byte ,_fdgf );_ ,_dabd =_cffc .ReadAtLeast (_eabg ,int (_fdgf ));if _dabd !=nil {_ge .Log .Debug ("E\u0052\u0052\u004f\u0052 s\u0074r\u0065\u0061\u006d\u0020\u0028%\u0064\u0029\u003a\u0020\u0025\u0058",len (_eabg ),_eabg );_ge .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_dabd );return nil ,_dabd ;};_bfc :=PdfObjectStream {};_bfc .Stream =_eabg ;_bfc .PdfObjectDictionary =_gcbe .PdfObject .(*PdfObjectDictionary );_bfc .ObjectNumber =_gcbe .ObjectNumber ;_bfc .GenerationNumber =_gcbe .GenerationNumber ;_bfc .PdfObjectReference ._aaccf =_cffc ;_cffc .skipSpaces ();_cffc ._addbb .Discard (9);_cffc .skipSpaces ();return &_bfc ,nil ;};};_gcbe .PdfObject ,_cabd =_cffc .parseObject ();if _gcbe .PdfObject ==nil {_ge .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");_gcbe .PdfObject =MakeNull ();};return &_gcbe ,_cabd ;};};if _gcbe .PdfObject ==nil {_ge .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");_gcbe .PdfObject =MakeNull ();};_ge .Log .Trace ("\u0052\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0021");return &_gcbe ,nil ;};

// DecodeStream returns the passed in stream as a slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_bged *RawEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return streamObj .Stream ,nil ;};

// DecodeImages decodes the page images from the jbig2 'encoded' data input.
// The jbig2 document may contain multiple pages, thus the function can return multiple
// images. The images order corresponds to the page number.
func (_eec *JBIG2Encoder )DecodeImages (encoded []byte )([]_ffa .Image ,error ){const _eba ="\u004aB\u0049\u0047\u0032\u0045n\u0063\u006f\u0064\u0065\u0072.\u0044e\u0063o\u0064\u0065\u0049\u006d\u0061\u0067\u0065s";_cdgc ,_eefa :=_cf .Decode (encoded ,_cf .Parameters {},_eec .Globals .ToDocumentGlobals ());if _eefa !=nil {return nil ,_cc .Wrap (_eefa ,_eba ,"");};_abbb ,_eefa :=_cdgc .PageNumber ();if _eefa !=nil {return nil ,_cc .Wrap (_eefa ,_eba ,"");};_bgbcb :=[]_ffa .Image {};var _gbab _ffa .Image ;for _dged :=1;_dged <=_abbb ;_dged ++{_gbab ,_eefa =_cdgc .DecodePageImage (_dged );if _eefa !=nil {return nil ,_cc .Wrapf (_eefa ,_eba ,"\u0070\u0061\u0067\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_dged );};_bgbcb =append (_bgbcb ,_gbab );};return _bgbcb ,nil ;};

// GetBool returns the *PdfObjectBool object that is represented by a PdfObject directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetBool (obj PdfObject )(_gceg *PdfObjectBool ,_cffg bool ){_gceg ,_cffg =TraceToDirectObject (obj ).(*PdfObjectBool );return _gceg ,_cffg ;};

// UpdateParams updates the parameter values of the encoder.
func (_bbaec *ASCII85Encoder )UpdateParams (params *PdfObjectDictionary ){};func (_ccba *FlateEncoder )cleanImageData (_adbb []byte )([]byte ,error ){if _ccba ._bbaf ==nil {return _adbb ,nil ;};if _ccba ._bbaf .BitsPerComponent >=8{return _adbb ,nil ;};_fbef :=_ccba ._bbaf .BitsPerComponent *_ccba ._bbaf .Width *_ccba ._bbaf .ColorComponents *_ccba ._bbaf .Height /8;_adbb =_adbb [:_fbef ];var _gaba error ;_adbb ,_gaba =_ca .AddDataPadding (_ccba ._bbaf .Width ,_ccba ._bbaf .Height ,_ccba ._bbaf .BitsPerComponent ,_ccba ._bbaf .ColorComponents ,_adbb );if _gaba !=nil {return nil ,_gaba ;};return _adbb ,nil ;};

// DecodeBytes decodes a slice of Flate encoded bytes and returns the result.
func (_faeg *FlateEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_ge .Log .Trace ("\u0046\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065\u0020b\u0079\u0074\u0065\u0073");if len (encoded )==0{_ge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0046\u006c\u0061\u0074\u0065 e\u006ec\u006f\u0064\u0065\u0064\u0020\u0062\u0075\u0066\u0066\u0065\u0072\u002e \u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0062y\u0074\u0065\u0020\u0073\u006c\u0069\u0063\u0065\u002e");return []byte {},nil ;};_bfd :=_cdc .NewReader (encoded );_ead ,_dgg :=_e .NewReader (_bfd );if _dgg !=nil {_ge .Log .Debug ("\u0044e\u0063o\u0064\u0069\u006e\u0067\u0020e\u0072\u0072o\u0072\u0020\u0025\u0076\u000a",_dgg );_ge .Log .Debug ("\u0053t\u0072e\u0061\u006d\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (encoded ),encoded );return nil ,_dgg ;};defer _ead .Close ();var _aeec _cdc .Buffer ;_aeec .ReadFrom (_ead );return _aeec .Bytes (),nil ;};

// ToGoImage converts the JBIG2Image to the golang image.Image.
func (_aege *JBIG2Image )ToGoImage ()(_ffa .Image ,error ){const _bdda ="J\u0042I\u0047\u0032\u0049\u006d\u0061\u0067\u0065\u002eT\u006f\u0047\u006f\u0049ma\u0067\u0065";if _aege .Data ==nil {return nil ,_cc .Error (_bdda ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");};if _aege .Width ==0||_aege .Height ==0{return nil ,_cc .Error (_bdda ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");};_ebbab ,_bac :=_ca .NewImage (_aege .Width ,_aege .Height ,1,1,_aege .Data ,nil ,nil );if _bac !=nil {return nil ,_bac ;};return _ebbab ,nil ;};func _bcg (_dce XrefTable ){_ge .Log .Debug ("\u003dX\u003d\u0058\u003d\u0058\u003d");_ge .Log .Debug ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");_caa :=0;for _ ,_gga :=range _dce .ObjectMap {_ge .Log .Debug ("i\u002b\u0031\u003a\u0020\u0025\u0064 \u0028\u006f\u0062\u006a\u0020\u006eu\u006d\u003a\u0020\u0025\u0064\u0020\u0067e\u006e\u003a\u0020\u0025\u0064\u0029\u0020\u002d\u003e\u0020%\u0064",_caa +1,_gga .ObjectNumber ,_gga .Generation ,_gga .Offset );_caa ++;};};

// DCTEncoder provides a DCT (JPG) encoding/decoding functionality for images.
type DCTEncoder struct{ColorComponents int ;BitsPerComponent int ;Width int ;Height int ;Quality int ;};

// NewASCIIHexEncoder makes a new ASCII hex encoder.
func NewASCIIHexEncoder ()*ASCIIHexEncoder {_dde :=&ASCIIHexEncoder {};return _dde };

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_ceac *JBIG2Encoder )MakeStreamDict ()*PdfObjectDictionary {_cdac :=MakeDict ();_cdac .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_ceac .GetFilterName ()));return _cdac ;};func (_ee *PdfParser )lookupByNumberWrapper (_aff int ,_gcg bool )(PdfObject ,bool ,error ){_cde ,_ba ,_ffab :=_ee .lookupByNumber (_aff ,_gcg );if _ffab !=nil {return nil ,_ba ,_ffab ;};if !_ba &&_ee ._ddfa !=nil &&!_ee ._ddfa .isDecrypted (_cde ){_gcd :=_ee ._ddfa .Decrypt (_cde ,0,0);if _gcd !=nil {return nil ,_ba ,_gcd ;};};return _cde ,_ba ,nil ;};func _aga (_dccf _ac .Filter ,_ffgf _gc .AuthEvent )*PdfObjectDictionary {if _ffgf ==""{_ffgf =_gc .EventDocOpen ;};_dcb :=MakeDict ();_dcb .Set ("\u0054\u0079\u0070\u0065",MakeName ("C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"));_dcb .Set ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et",MakeName (string (_ffgf )));_dcb .Set ("\u0043\u0046\u004d",MakeName (_dccf .Name ()));_dcb .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_dccf .KeyLength ())));return _dcb ;};

// GetIntVal returns the int value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetIntVal (obj PdfObject )(_bddef int ,_gfbaf bool ){_gefe ,_gfbaf :=TraceToDirectObject (obj ).(*PdfObjectInteger );if _gfbaf &&_gefe !=nil {return int (*_gefe ),true ;};return 0,false ;};

// GetStringBytes is like GetStringVal except that it returns the string as a []byte.
// It is for convenience.
func GetStringBytes (obj PdfObject )(_dbcg []byte ,_ecgg bool ){_ecaf ,_ecgg :=TraceToDirectObject (obj ).(*PdfObjectString );if _ecgg {return _ecaf .Bytes (),true ;};return ;};

// WriteString outputs the object as it is to be written to file.
func (_befe *PdfObjectStream )WriteString ()string {var _abbf _dc .Builder ;_abbf .WriteString (_g .FormatInt (_befe .ObjectNumber ,10));_abbf .WriteString ("\u0020\u0030\u0020\u0052");return _abbf .String ();};

// EncodeBytes DCT encodes the passed in slice of bytes.
func (_eaa *DCTEncoder )EncodeBytes (data []byte )([]byte ,error ){_bde ,_dfc :=_ca .NewImage (_eaa .Width ,_eaa .Height ,_eaa .BitsPerComponent ,_eaa .ColorComponents ,data ,nil ,nil );if _dfc !=nil {return nil ,_dfc ;};_gdbb :=_cd .Options {};_gdbb .Quality =_eaa .Quality ;var _beda _cdc .Buffer ;if _dfc =_cd .Encode (&_beda ,_bde ,&_gdbb );_dfc !=nil {return nil ,_dfc ;};return _beda .Bytes (),nil ;};

// GetNameVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetNameVal (obj PdfObject )(_ccac string ,_egdba bool ){_acgf ,_egdba :=TraceToDirectObject (obj ).(*PdfObjectName );if _egdba {return string (*_acgf ),true ;};return ;};func (_acaf *PdfParser )loadXrefs ()(*PdfObjectDictionary ,error ){_acaf ._afag .ObjectMap =make (map[int ]XrefObject );_acaf ._cebfa =make (objectStreams );_gbbg ,_gceb :=_acaf ._dceb .Seek (0,_c .SeekEnd );if _gceb !=nil {return nil ,_gceb ;};_ge .Log .Trace ("\u0066s\u0069\u007a\u0065\u003a\u0020\u0025d",_gbbg );_acaf ._cded =_gbbg ;_gceb =_acaf .seekToEOFMarker (_gbbg );if _gceb !=nil {_ge .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0073\u0065\u0065\u006b\u0020\u0074\u006f\u0020\u0065\u006f\u0066\u0020\u006d\u0061\u0072\u006b\u0065\u0072: \u0025\u0076",_gceb );return nil ,_gceb ;};_cgbf ,_gceb :=_acaf ._dceb .Seek (0,_c .SeekCurrent );if _gceb !=nil {return nil ,_gceb ;};var _fadfa int64 =64;_cefe :=_cgbf -_fadfa ;if _cefe < 0{_cefe =0;};_ ,_gceb =_acaf ._dceb .Seek (_cefe ,_c .SeekStart );if _gceb !=nil {return nil ,_gceb ;};_ffe :=make ([]byte ,_fadfa );_ ,_gceb =_acaf ._dceb .Read (_ffe );if _gceb !=nil {_ge .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u003a\u0020\u0025\u0076",_gceb );return nil ,_gceb ;};_afb :=_bgeb .FindStringSubmatch (string (_ffe ));if len (_afb )< 2{_ge .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020n\u006f\u0074\u0020f\u006fu\u006e\u0064\u0021");return nil ,_b .New ("\u0073\u0074\u0061\u0072tx\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};if len (_afb )> 2{_ge .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u004du\u006c\u0074\u0069\u0070\u006c\u0065\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029\u0021",_ffe );return nil ,_b .New ("m\u0075\u006c\u0074\u0069\u0070\u006ce\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065f\u0020\u0065\u006et\u0072i\u0065\u0073\u003f");};_gcec ,_ :=_g .ParseInt (_afb [1],10,64);_ge .Log .Trace ("\u0073t\u0061r\u0074\u0078\u0072\u0065\u0066\u0020\u0061\u0074\u0020\u0025\u0064",_gcec );if _gcec > _gbbg {_ge .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u006f\u0066f\u0073e\u0074 \u006fu\u0074\u0073\u0069\u0064\u0065\u0020\u006f\u0066\u0020\u0066\u0069\u006c\u0065");_ge .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0072e\u0070\u0061\u0069\u0072");_gcec ,_gceb =_acaf .repairLocateXref ();if _gceb !=nil {_ge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0052\u0065\u0070\u0061\u0069\u0072\u0020\u0061\u0074\u0074\u0065\u006d\u0070t\u0020\u0066\u0061\u0069\u006c\u0065\u0064 \u0028\u0025\u0073\u0029");return nil ,_gceb ;};};_acaf ._dceb .Seek (int64 (_gcec ),_c .SeekStart );_acaf ._addbb =_cbe .NewReader (_acaf ._dceb );_afed ,_gceb :=_acaf .parseXref ();if _gceb !=nil {return nil ,_gceb ;};_aabe :=_afed .Get ("\u0058R\u0065\u0066\u0053\u0074\u006d");if _aabe !=nil {_cgafg ,_bcde :=_aabe .(*PdfObjectInteger );if !_bcde {return nil ,_b .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0021=\u0020\u0069\u006e\u0074");};_ ,_gceb =_acaf .parseXrefStream (_cgafg );if _gceb !=nil {return nil ,_gceb ;};};var _fgbd []int64 ;_decdc :=func (_cace int64 ,_cefb []int64 )bool {for _ ,_fccg :=range _cefb {if _fccg ==_cace {return true ;};};return false ;};_aabe =_afed .Get ("\u0050\u0072\u0065\u0076");for _aabe !=nil {_fgcga ,_beaae :=_aabe .(*PdfObjectInteger );if !_beaae {_ge .Log .Debug ("\u0049\u006ev\u0061\u006c\u0069\u0064\u0020P\u0072\u0065\u0076\u0020\u0072e\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u003a\u0020\u004e\u006f\u0074\u0020\u0061\u0020\u002a\u0050\u0064\u0066\u004f\u0062\u006a\u0065\u0063\u0074\u0049\u006e\u0074\u0065\u0067\u0065\u0072\u0020\u0028\u0025\u0054\u0029",_aabe );return _afed ,nil ;};_cgcf :=*_fgcga ;_ge .Log .Trace ("\u0041\u006eot\u0068\u0065\u0072 \u0050\u0072\u0065\u0076 xr\u0065f \u0074\u0061\u0062\u006c\u0065\u0020\u006fbj\u0065\u0063\u0074\u0020\u0061\u0074\u0020%\u0064",_cgcf );_acaf ._dceb .Seek (int64 (_cgcf ),_ef .SEEK_SET );_acaf ._addbb =_cbe .NewReader (_acaf ._dceb );_ebc ,_gdbaa :=_acaf .parseXref ();if _gdbaa !=nil {_ge .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0045\u0072\u0072\u006f\u0072\u0020-\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u0061\u0064\u0069n\u0067\u0020\u0061\u006e\u006f\u0074\u0068\u0065\u0072\u0020\u0028\u0050re\u0076\u0029\u0020\u0074\u0072\u0061\u0069\u006c\u0065\u0072");_ge .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0063\u006f\u006e\u0074\u0069n\u0075\u0065\u0020\u0062\u0079\u0020\u0069\u0067\u006e\u006f\u0072\u0069n\u0067\u0020\u0069\u0074");break ;};_aabe =_ebc .Get ("\u0050\u0072\u0065\u0076");if _aabe !=nil {_bbgd :=*(_aabe .(*PdfObjectInteger ));if _decdc (int64 (_bbgd ),_fgbd ){_ge .Log .Debug ("\u0050\u0072ev\u0065\u006e\u0074i\u006e\u0067\u0020\u0063irc\u0075la\u0072\u0020\u0078\u0072\u0065\u0066\u0020re\u0066\u0065\u0072\u0065\u006e\u0063\u0069n\u0067");break ;};_fgbd =append (_fgbd ,int64 (_bbgd ));};};return _afed ,nil ;};func (_fae *PdfCrypt )isEncrypted (_ggd PdfObject )bool {_ ,_aaa :=_fae ._efe [_ggd ];if _aaa {_ge .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0065\u006e\u0063\u0072y\u0070\u0074\u0065\u0064");return true ;};_ge .Log .Trace ("\u004e\u006f\u0074\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");return false ;};

// GetInt returns the *PdfObjectBool object that is represented by a PdfObject either directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetInt (obj PdfObject )(_eaedd *PdfObjectInteger ,_fgdf bool ){_eaedd ,_fgdf =TraceToDirectObject (obj ).(*PdfObjectInteger );return _eaedd ,_fgdf ;};func (_fca *PdfCrypt )loadCryptFilters (_dea *PdfObjectDictionary )error {_fca ._effg =cryptFilters {};_cfg :=_dea .Get ("\u0043\u0046");_cfg =TraceToDirectObject (_cfg );if _dfg ,_afd :=_cfg .(*PdfObjectReference );_afd {_adcd ,_gaf :=_fca ._dge .LookupByReference (*_dfg );if _gaf !=nil {_ge .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0075\u0070\u0020\u0043\u0046\u0020\u0072\u0065\u0066\u0065\u0072en\u0063\u0065");return _gaf ;};_cfg =TraceToDirectObject (_adcd );};_fec ,_fed :=_cfg .(*PdfObjectDictionary );if !_fed {_ge .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0043\u0046\u002c \u0074\u0079\u0070\u0065: \u0025\u0054",_cfg );return _b .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0043\u0046");};for _ ,_cbce :=range _fec .Keys (){_bea :=_fec .Get (_cbce );if _gabd ,_gf :=_bea .(*PdfObjectReference );_gf {_gdb ,_gad :=_fca ._dge .LookupByReference (*_gabd );if _gad !=nil {_ge .Log .Debug ("\u0045\u0072ro\u0072\u0020\u006co\u006f\u006b\u0075\u0070 up\u0020di\u0063\u0074\u0069\u006f\u006e\u0061\u0072y \u0072\u0065\u0066\u0065\u0072\u0065\u006ec\u0065");return _gad ;};_bea =TraceToDirectObject (_gdb );};_fcd ,_ffgb :=_bea .(*PdfObjectDictionary );if !_ffgb {return _fe .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074\u0020\u0069\u006e \u0043\u0046\u0020\u0028\u006e\u0061\u006d\u0065\u0020\u0025\u0073\u0029\u0020-\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079\u0020\u0062\u0075\u0074\u0020\u0025\u0054",_cbce ,_bea );};if _cbce =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{_ge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u002d\u0020\u0043\u0061\u006e\u006e\u006f\u0074\u0020\u006f\u0076\u0065\u0072\u0077r\u0069\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0069d\u0065\u006e\u0074\u0069\u0074\u0079\u0020\u0066\u0069\u006c\u0074\u0065\u0072 \u002d\u0020\u0054\u0072\u0079\u0069n\u0067\u0020\u006ee\u0078\u0074");continue ;};var _bbgg _ac .FilterDict ;if _acc :=_eg (&_bbgg ,_fcd );_acc !=nil {return _acc ;};_ag ,_afa :=_ac .NewFilter (_bbgg );if _afa !=nil {return _afa ;};_fca ._effg [string (_cbce )]=_ag ;};_fca ._effg ["\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"]=_ac .NewIdentity ();_fca ._cbd ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _caad ,_efa :=_dea .Get ("\u0053\u0074\u0072\u0046").(*PdfObjectName );_efa {if _ ,_gfg :=_fca ._effg [string (*_caad )];!_gfg {return _fe .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u0072\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_caad );};_fca ._cbd =string (*_caad );};_fca ._dedf ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _aee ,_adb :=_dea .Get ("\u0053\u0074\u006d\u0046").(*PdfObjectName );_adb {if _ ,_bdc :=_fca ._effg [string (*_aee )];!_bdc {return _fe .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u006d\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_aee );};_fca ._dedf =string (*_aee );};return nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_ebge *RawEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};

// DecodeStream implements ASCII hex decoding.
func (_bgc *ASCIIHexEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _bgc .DecodeBytes (streamObj .Stream );};

// NewCCITTFaxEncoder makes a new CCITTFax encoder.
func NewCCITTFaxEncoder ()*CCITTFaxEncoder {return &CCITTFaxEncoder {Columns :1728,EndOfBlock :true }};

// UpdateParams updates the parameter values of the encoder.
func (_gda *ASCIIHexEncoder )UpdateParams (params *PdfObjectDictionary ){};

// UpdateParams updates the parameter values of the encoder.
func (_dcef *DCTEncoder )UpdateParams (params *PdfObjectDictionary ){_dcfbd ,_fbgg :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _fbgg ==nil {_dcef .ColorComponents =int (_dcfbd );};_dbe ,_fbgg :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _fbgg ==nil {_dcef .BitsPerComponent =int (_dbe );};_gfcc ,_fbgg :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _fbgg ==nil {_dcef .Width =int (_gfcc );};_cgag ,_fbgg :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _fbgg ==nil {_dcef .Height =int (_cgag );};_agf ,_fbgg :=GetNumberAsInt64 (params .Get ("\u0051u\u0061\u006c\u0069\u0074\u0079"));if _fbgg ==nil {_dcef .Quality =int (_agf );};};

// MakeArrayFromIntegers creates an PdfObjectArray from a slice of ints, where each array element is
// an PdfObjectInteger.
func MakeArrayFromIntegers (vals []int )*PdfObjectArray {_cbba :=MakeArray ();for _ ,_eabbg :=range vals {_cbba .Append (MakeInteger (int64 (_eabbg )));};return _cbba ;};

// PdfObject is an interface which all primitive PDF objects must implement.
type PdfObject interface{

// String outputs a string representation of the primitive (for debugging).
String ()string ;

// WriteString outputs the PDF primitive as written to file as expected by the standard.
// TODO(dennwc): it should return a byte slice, or accept a writer
WriteString ()string ;};

// FlattenObject returns the contents of `obj`. In other words, `obj` with indirect objects replaced
// by their values.
// The replacements are made recursively to a depth of traceMaxDepth.
// NOTE: Dicts are sorted to make objects with same contents have the same PDF object strings.
func FlattenObject (obj PdfObject )PdfObject {return _eagge (obj ,0)};

// NewLZWEncoder makes a new LZW encoder with default parameters.
func NewLZWEncoder ()*LZWEncoder {_ddgg :=&LZWEncoder {};_ddgg .Predictor =1;_ddgg .BitsPerComponent =8;_ddgg .Colors =1;_ddgg .Columns =1;_ddgg .EarlyChange =1;return _ddgg ;};

// GetArray returns the *PdfObjectArray represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetArray (obj PdfObject )(_edcbc *PdfObjectArray ,_gddc bool ){_edcbc ,_gddc =TraceToDirectObject (obj ).(*PdfObjectArray );return _edcbc ,_gddc ;};

// IsEncrypted checks if the document is encrypted. A bool flag is returned indicating the result.
// First time when called, will check if the Encrypt dictionary is accessible through the trailer dictionary.
// If encrypted, prepares a crypt datastructure which can be used to authenticate and decrypt the document.
// On failure, an error is returned.
func (_cgagg *PdfParser )IsEncrypted ()(bool ,error ){if _cgagg ._ddfa !=nil {return true ,nil ;}else if _cgagg ._aedd ==nil {return false ,nil ;};_ge .Log .Trace ("\u0043\u0068\u0065c\u006b\u0069\u006e\u0067 \u0065\u006e\u0063\u0072\u0079\u0070\u0074i\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0021");_eecc :=_cgagg ._aedd .Get ("\u0045n\u0063\u0072\u0079\u0070\u0074");if _eecc ==nil {return false ,nil ;};_ge .Log .Trace ("\u0049\u0073\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u0021");var (_cgecf *PdfObjectDictionary ;);switch _dceg :=_eecc .(type ){case *PdfObjectDictionary :_cgecf =_dceg ;case *PdfObjectReference :_ge .Log .Trace ("\u0030\u003a\u0020\u004c\u006f\u006f\u006b\u0020\u0075\u0070\u0020\u0072e\u0066\u0020\u0025\u0071",_dceg );_affc ,_bfgca :=_cgagg .LookupByReference (*_dceg );_ge .Log .Trace ("\u0031\u003a\u0020%\u0071",_affc );if _bfgca !=nil {return false ,_bfgca ;};_fdgge ,_ccge :=_affc .(*PdfIndirectObject );if !_ccge {_ge .Log .Debug ("E\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006eo\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072ec\u0074\u0020\u006fb\u006ae\u0063\u0074");return false ,_b .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");};_cfbg ,_ccge :=_fdgge .PdfObject .(*PdfObjectDictionary );_ge .Log .Trace ("\u0032\u003a\u0020%\u0071",_cfbg );if !_ccge {return false ,_b .New ("\u0074\u0072a\u0069\u006c\u0065\u0072 \u0045\u006ec\u0072\u0079\u0070\u0074\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u006e\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");};_cgecf =_cfbg ;case *PdfObjectNull :_ge .Log .Debug ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074 \u0069\u0073\u0020a\u0020\u006e\u0075l\u006c\u0020o\u0062\u006a\u0065\u0063\u0074\u002e \u0046il\u0065\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u002e");return false ,nil ;default:return false ,_fe .Errorf ("u\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0079\u0070\u0065: \u0025\u0054",_dceg );};_deebdg ,_ggga :=PdfCryptNewDecrypt (_cgagg ,_cgecf ,_cgagg ._aedd );if _ggga !=nil {return false ,_ggga ;};for _ ,_dcaa :=range []string {"\u0049\u006e\u0066\u006f","\u0045n\u0063\u0072\u0079\u0070\u0074"}{_bgab :=_cgagg ._aedd .Get (PdfObjectName (_dcaa ));if _bgab ==nil {continue ;};switch _bcbc :=_bgab .(type ){case *PdfObjectReference :_deebdg ._eac [int (_bcbc .ObjectNumber )]=struct{}{};case *PdfIndirectObject :_deebdg ._ce [_bcbc ]=true ;_deebdg ._eac [int (_bcbc .ObjectNumber )]=struct{}{};};};_cgagg ._ddfa =_deebdg ;_ge .Log .Trace ("\u0043\u0072\u0079\u0070\u0074\u0065\u0072\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0025\u0062",_deebdg );return true ,nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_agd *DCTEncoder )MakeDecodeParams ()PdfObject {return nil };

// NewASCII85Encoder makes a new ASCII85 encoder.
func NewASCII85Encoder ()*ASCII85Encoder {_degf :=&ASCII85Encoder {};return _degf };type objectStreams map[int ]objectStream ;

// Set sets the PdfObject at index i of the streams. An error is returned if the index is outside bounds.
func (_fece *PdfObjectStreams )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_fece ._ccff ){return _b .New ("\u004f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_fece ._ccff [i ]=obj ;return nil ;};

// SetImage sets the image base for given flate encoder.
func (_gccfb *FlateEncoder )SetImage (img *_ca .ImageBase ){_gccfb ._bbaf =img };

// GetFilterName returns the name of the encoding filter.
func (_gbdd *RawEncoder )GetFilterName ()string {return StreamEncodingFilterNameRaw };func (_ceaa *PdfParser )parseXref ()(*PdfObjectDictionary ,error ){const _gcfdf =20;_gcgf ,_ :=_ceaa ._addbb .Peek (_gcfdf );for _agcde :=0;_agcde < 2;_agcde ++{if _ceaa ._bced ==0{_ceaa ._bced =_ceaa .GetFileOffset ();};if _ggcc .Match (_gcgf ){_ge .Log .Trace ("\u0078\u0072e\u0066\u0020\u0070\u006f\u0069\u006e\u0074\u0073\u0020\u0074\u006f\u0020\u0061\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u002e\u0020\u0050\u0072\u006f\u0062\u0061\u0062\u006c\u0079\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063\u0074");_ge .Log .Debug ("\u0073t\u0061r\u0074\u0069\u006e\u0067\u0020w\u0069\u0074h\u0020\u0022\u0025\u0073\u0022",string (_gcgf ));return _ceaa .parseXrefStream (nil );};if _acga .Match (_gcgf ){_ge .Log .Trace ("\u0053\u0074\u0061\u006ed\u0061\u0072\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073e\u0063t\u0069\u006f\u006e\u0020\u0074\u0061\u0062l\u0065\u0021");return _ceaa .parseXrefTable ();};_gfff :=_ceaa .GetFileOffset ();if _ceaa ._bced ==0{_ceaa ._bced =_gfff ;};_ceaa .SetFileOffset (_gfff -_gcfdf );defer _ceaa .SetFileOffset (_gfff );_gffbe ,_ :=_ceaa ._addbb .Peek (_gcfdf );_gcgf =append (_gffbe ,_gcgf ...);};_ge .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u0078\u0072\u0065f\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006fr\u0020\u0073\u0074\u0072\u0065\u0061\u006d.\u0020\u0052\u0065\u0070\u0061i\u0072\u0020\u0061\u0074\u0074e\u006d\u0070\u0074\u0065\u0064\u003a\u0020\u004c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0065\u0061\u0072\u006c\u0069\u0065\u0073\u0074\u0020x\u0072\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u0062\u006f\u0074to\u006d\u002e");if _abba :=_ceaa .repairSeekXrefMarker ();_abba !=nil {_ge .Log .Debug ("\u0052e\u0070a\u0069\u0072\u0020\u0066\u0061i\u006c\u0065d\u0020\u002d\u0020\u0025\u0076",_abba );return nil ,_abba ;};return _ceaa .parseXrefTable ();};

// ParseDict reads and parses a PDF dictionary object enclosed with '<<' and '>>'
func (_bggge *PdfParser )ParseDict ()(*PdfObjectDictionary ,error ){_ge .Log .Trace ("\u0052\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020D\u0069\u0063\u0074\u0021");_dbca :=MakeDict ();_dbca ._deda =_bggge ;_ecgf ,_ :=_bggge ._addbb .ReadByte ();if _ecgf !='<'{return nil ,_b .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");};_ecgf ,_ =_bggge ._addbb .ReadByte ();if _ecgf !='<'{return nil ,_b .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");};for {_bggge .skipSpaces ();_bggge .skipComments ();_ggccg ,_dddb :=_bggge ._addbb .Peek (2);if _dddb !=nil {return nil ,_dddb ;};_ge .Log .Trace ("D\u0069c\u0074\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_ggccg ),string (_ggccg ));if (_ggccg [0]=='>')&&(_ggccg [1]=='>'){_ge .Log .Trace ("\u0045\u004f\u0046\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");_bggge ._addbb .ReadByte ();_bggge ._addbb .ReadByte ();break ;};_ge .Log .Trace ("\u0050a\u0072s\u0065\u0020\u0074\u0068\u0065\u0020\u006e\u0061\u006d\u0065\u0021");_gbgde ,_dddb :=_bggge .parseName ();_ge .Log .Trace ("\u004be\u0079\u003a\u0020\u0025\u0073",_gbgde );if _dddb !=nil {_ge .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0052e\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006ea\u006d\u0065\u0020e\u0072r\u0020\u0025\u0073",_dddb );return nil ,_dddb ;};if len (_gbgde )> 4&&_gbgde [len (_gbgde )-4:]=="\u006e\u0075\u006c\u006c"{_bcaa :=_gbgde [0:len (_gbgde )-4];_ge .Log .Debug ("\u0054\u0061\u006b\u0069n\u0067\u0020\u0063\u0061\u0072\u0065\u0020\u006f\u0066\u0020n\u0075l\u006c\u0020\u0062\u0075\u0067\u0020\u0028%\u0073\u0029",_gbgde );_ge .Log .Debug ("\u004e\u0065\u0077\u0020ke\u0079\u0020\u0022\u0025\u0073\u0022\u0020\u003d\u0020\u006e\u0075\u006c\u006c",_bcaa );_bggge .skipSpaces ();_eagg ,_ :=_bggge ._addbb .Peek (1);if _eagg [0]=='/'{_dbca .Set (_bcaa ,MakeNull ());continue ;};};_bggge .skipSpaces ();_cdgce ,_dddb :=_bggge .parseObject ();if _dddb !=nil {return nil ,_dddb ;};_dbca .Set (_gbgde ,_cdgce );if _ge .Log .IsLogLevel (_ge .LogLevelTrace ){_ge .Log .Trace ("\u0064\u0069\u0063\u0074\u005b\u0025\u0073\u005d\u0020\u003d\u0020\u0025\u0073",_gbgde ,_cdgce .String ());};};_ge .Log .Trace ("\u0072\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020\u0044\u0069\u0063\u0074\u0021");return _dbca ,nil ;};func (_cggc *PdfParser )parseString ()(*PdfObjectString ,error ){_cggc ._addbb .ReadByte ();var _eded _cdc .Buffer ;_cfba :=1;for {_eaff ,_dffd :=_cggc ._addbb .Peek (1);if _dffd !=nil {return MakeString (_eded .String ()),_dffd ;};if _eaff [0]=='\\'{_cggc ._addbb .ReadByte ();_defa ,_feedf :=_cggc ._addbb .ReadByte ();if _feedf !=nil {return MakeString (_eded .String ()),_feedf ;};if IsOctalDigit (_defa ){_dgca ,_abaf :=_cggc ._addbb .Peek (2);if _abaf !=nil {return MakeString (_eded .String ()),_abaf ;};var _fede []byte ;_fede =append (_fede ,_defa );for _ ,_afcda :=range _dgca {if IsOctalDigit (_afcda ){_fede =append (_fede ,_afcda );}else {break ;};};_cggc ._addbb .Discard (len (_fede )-1);_ge .Log .Trace ("\u004e\u0075\u006d\u0065ri\u0063\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0022\u0025\u0073\u0022",_fede );_gacf ,_abaf :=_g .ParseUint (string (_fede ),8,32);if _abaf !=nil {return MakeString (_eded .String ()),_abaf ;};_eded .WriteByte (byte (_gacf ));continue ;};switch _defa {case 'n':_eded .WriteRune ('\n');case 'r':_eded .WriteRune ('\r');case 't':_eded .WriteRune ('\t');case 'b':_eded .WriteRune ('\b');case 'f':_eded .WriteRune ('\f');case '(':_eded .WriteRune ('(');case ')':_eded .WriteRune (')');case '\\':_eded .WriteRune ('\\');};continue ;}else if _eaff [0]=='('{_cfba ++;}else if _eaff [0]==')'{_cfba --;if _cfba ==0{_cggc ._addbb .ReadByte ();break ;};};_gecb ,_ :=_cggc ._addbb .ReadByte ();_eded .WriteByte (_gecb );};return MakeString (_eded .String ()),nil ;};

// GetXrefType returns the type of the first xref object (table or stream).
func (_fgcf *PdfParser )GetXrefType ()*xrefType {return _fgcf ._ggad };

// EncodeImage encodes 'img' golang image.Image into jbig2 encoded bytes document using default encoder settings.
func (_ecg *JBIG2Encoder )EncodeImage (img _ffa .Image )([]byte ,error ){return _ecg .encodeImage (img )};func (_febd *PdfParser )parseBool ()(PdfObjectBool ,error ){_bddag ,_ffb :=_febd ._addbb .Peek (4);if _ffb !=nil {return PdfObjectBool (false ),_ffb ;};if (len (_bddag )>=4)&&(string (_bddag [:4])=="\u0074\u0072\u0075\u0065"){_febd ._addbb .Discard (4);return PdfObjectBool (true ),nil ;};_bddag ,_ffb =_febd ._addbb .Peek (5);if _ffb !=nil {return PdfObjectBool (false ),_ffb ;};if (len (_bddag )>=5)&&(string (_bddag [:5])=="\u0066\u0061\u006cs\u0065"){_febd ._addbb .Discard (5);return PdfObjectBool (false ),nil ;};return PdfObjectBool (false ),_b .New ("\u0075n\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0062o\u006fl\u0065a\u006e\u0020\u0073\u0074\u0072\u0069\u006eg");};var _ggcc =_ff .MustCompile ("\u0028\u005c\u0064\u002b)\\\u0073\u002b\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u006f\u0062\u006a");func (_gacff *PdfParser )parsePdfVersion ()(int ,int ,error ){var _fddbd int64 =20;_acba :=make ([]byte ,_fddbd );_gacff ._dceb .Seek (0,_ef .SEEK_SET );_gacff ._dceb .Read (_acba );var _gged error ;var _gafe ,_bgeff int ;if _ddbe :=_eade .FindStringSubmatch (string (_acba ));len (_ddbe )< 3{if _gafe ,_bgeff ,_gged =_gacff .seekPdfVersionTopDown ();_gged !=nil {_ge .Log .Debug ("F\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065\u0063\u006f\u0076\u0065\u0072\u0079\u0020\u002d\u0020\u0075n\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0066\u0069nd\u0020\u0076\u0065r\u0073i\u006f\u006e");return 0,0,_gged ;};_gacff ._dceb ,_gged =_adba (_gacff ._dceb ,_gacff .GetFileOffset ()-8);if _gged !=nil {return 0,0,_gged ;};}else {if _gafe ,_gged =_g .Atoi (_ddbe [1]);_gged !=nil {return 0,0,_gged ;};if _bgeff ,_gged =_g .Atoi (_ddbe [2]);_gged !=nil {return 0,0,_gged ;};_gacff .SetFileOffset (0);};_gacff ._addbb =_cbe .NewReader (_gacff ._dceb );_ge .Log .Debug ("\u0050\u0064\u0066\u0020\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020%\u0064\u002e\u0025\u0064",_gafe ,_bgeff );return _gafe ,_bgeff ,nil ;};func _ccga (_dga *_gc .StdEncryptDict ,_fag *PdfObjectDictionary )error {R ,_ddf :=_fag .Get ("\u0052").(*PdfObjectInteger );if !_ddf {return _b .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0052");};if *R < 2||*R > 6{return _fe .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0052 \u0028\u0025\u0064\u0029",*R );};_dga .R =int (*R );O ,_ddf :=_fag .GetString ("\u004f");if !_ddf {return _b .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u004f");};if _dga .R ==5||_dga .R ==6{if len (O )< 48{return _fe .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u004f\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (O ));};}else if len (O )!=32{return _fe .Errorf ("L\u0065n\u0067\u0074\u0068\u0028\u004f\u0029\u0020\u0021=\u0020\u0033\u0032\u0020(%\u0064\u0029",len (O ));};_dga .O =[]byte (O );U ,_ddf :=_fag .GetString ("\u0055");if !_ddf {return _b .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0055");};if _dga .R ==5||_dga .R ==6{if len (U )< 48{return _fe .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u0055\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (U ));};}else if len (U )!=32{_ge .Log .Debug ("\u0057\u0061r\u006e\u0069\u006e\u0067\u003a\u0020\u004c\u0065\u006e\u0067\u0074\u0068\u0028\u0055\u0029\u0020\u0021\u003d\u0020\u0033\u0032\u0020(%\u0064\u0029",len (U ));};_dga .U =[]byte (U );if _dga .R >=5{OE ,_ceb :=_fag .GetString ("\u004f\u0045");if !_ceb {return _b .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u004f\u0045");}else if len (OE )!=32{return _fe .Errorf ("L\u0065\u006e\u0067\u0074h(\u004fE\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (OE ));};_dga .OE =[]byte (OE );UE ,_ceb :=_fag .GetString ("\u0055\u0045");if !_ceb {return _b .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u0055\u0045");}else if len (UE )!=32{return _fe .Errorf ("L\u0065\u006e\u0067\u0074h(\u0055E\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (UE ));};_dga .UE =[]byte (UE );};P ,_ddf :=_fag .Get ("\u0050").(*PdfObjectInteger );if !_ddf {return _b .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074 \u0064\u0069\u0063t\u0069\u006f\u006e\u0061r\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0070\u0065\u0072\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0061\u0074\u0074\u0072");};_dga .P =_gc .Permissions (*P );if _dga .R ==6{Perms ,_gaa :=_fag .GetString ("\u0050\u0065\u0072m\u0073");if !_gaa {return _b .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0050\u0065\u0072\u006d\u0073");}else if len (Perms )!=16{return _fe .Errorf ("\u004ce\u006e\u0067\u0074\u0068\u0028\u0050\u0065\u0072\u006d\u0073\u0029 \u0021\u003d\u0020\u0031\u0036\u0020\u0028\u0025\u0064\u0029",len (Perms ));};_dga .Perms =[]byte (Perms );};if _fda ,_edb :=_fag .Get ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061").(*PdfObjectBool );_edb {_dga .EncryptMetadata =bool (*_fda );}else {_dga .EncryptMetadata =true ;};return nil ;};

// AddPageImage adds the page with the image 'img' to the encoder context in order to encode it jbig2 document.
// The 'settings' defines what encoding type should be used by the encoder.
func (_eefc *JBIG2Encoder )AddPageImage (img *JBIG2Image ,settings *JBIG2EncoderSettings )(_agfg error ){const _cegb ="\u004a\u0042\u0049\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0041\u0064\u0064\u0050\u0061\u0067\u0065\u0049m\u0061\u0067\u0065";if _eefc ==nil {return _cc .Error (_cegb ,"J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u0020\u0069\u0073 n\u0069\u006c");};if settings ==nil {settings =&_eefc .DefaultPageSettings ;};if _eefc ._dafd ==nil {_eefc ._dafd =_ae .InitEncodeDocument (settings .FileMode );};if _agfg =settings .Validate ();_agfg !=nil {return _cc .Wrap (_agfg ,_cegb ,"");};_dgbf ,_agfg :=img .toBitmap ();if _agfg !=nil {return _cc .Wrap (_agfg ,_cegb ,"");};switch settings .Compression {case JB2Generic :if _agfg =_eefc ._dafd .AddGenericPage (_dgbf ,settings .DuplicatedLinesRemoval );_agfg !=nil {return _cc .Wrap (_agfg ,_cegb ,"");};case JB2SymbolCorrelation :return _cc .Error (_cegb ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");case JB2SymbolRankHaus :return _cc .Error (_cegb ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");default:return _cc .Error (_cegb ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return nil ;};

// NewJBIG2Encoder creates a new JBIG2Encoder.
func NewJBIG2Encoder ()*JBIG2Encoder {return &JBIG2Encoder {_dafd :_ae .InitEncodeDocument (false )}};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_febg *RawEncoder )MakeDecodeParams ()PdfObject {return nil };var _eecg =_ff .MustCompile ("\u005e\\\u0073\u002a\u005b\u002d]\u002a\u0028\u005c\u0064\u002b)\u005cs\u002b(\u005c\u0064\u002b\u0029\u005c\u0073\u002bR");func (_aega *PdfParser )parseObject ()(PdfObject ,error ){_ge .Log .Trace ("\u0052e\u0061d\u0020\u0064\u0069\u0072\u0065c\u0074\u0020o\u0062\u006a\u0065\u0063\u0074");_aega .skipSpaces ();for {_febf ,_afda :=_aega ._addbb .Peek (2);if _afda !=nil {if _afda !=_c .EOF ||len (_febf )==0{return nil ,_afda ;};if len (_febf )==1{_febf =append (_febf ,' ');};};_ge .Log .Trace ("\u0050e\u0065k\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u003a\u0020\u0025\u0073",string (_febf ));if _febf [0]=='/'{_cggcf ,_efcd :=_aega .parseName ();_ge .Log .Trace ("\u002d\u003e\u004ea\u006d\u0065\u003a\u0020\u0027\u0025\u0073\u0027",_cggcf );return &_cggcf ,_efcd ;}else if _febf [0]=='('{_ge .Log .Trace ("\u002d>\u0053\u0074\u0072\u0069\u006e\u0067!");_fadd ,_efgd :=_aega .parseString ();return _fadd ,_efgd ;}else if _febf [0]=='['{_ge .Log .Trace ("\u002d\u003e\u0041\u0072\u0072\u0061\u0079\u0021");_dadc ,_afff :=_aega .parseArray ();return _dadc ,_afff ;}else if (_febf [0]=='<')&&(_febf [1]=='<'){_ge .Log .Trace ("\u002d>\u0044\u0069\u0063\u0074\u0021");_cbbe ,_efgc :=_aega .ParseDict ();return _cbbe ,_efgc ;}else if _febf [0]=='<'{_ge .Log .Trace ("\u002d\u003e\u0048\u0065\u0078\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0021");_ecb ,_eadee :=_aega .parseHexString ();return _ecb ,_eadee ;}else if _febf [0]=='%'{_aega .readComment ();_aega .skipSpaces ();}else {_ge .Log .Trace ("\u002d\u003eN\u0075\u006d\u0062e\u0072\u0020\u006f\u0072\u0020\u0072\u0065\u0066\u003f");_febf ,_ =_aega ._addbb .Peek (15);_eagff :=string (_febf );_ge .Log .Trace ("\u0050\u0065\u0065k\u0020\u0073\u0074\u0072\u003a\u0020\u0025\u0073",_eagff );if (len (_eagff )> 3)&&(_eagff [:4]=="\u006e\u0075\u006c\u006c"){_bbde ,_bfggc :=_aega .parseNull ();return &_bbde ,_bfggc ;}else if (len (_eagff )> 4)&&(_eagff [:5]=="\u0066\u0061\u006cs\u0065"){_eaded ,_cdbg :=_aega .parseBool ();return &_eaded ,_cdbg ;}else if (len (_eagff )> 3)&&(_eagff [:4]=="\u0074\u0072\u0075\u0065"){_geaa ,_cacae :=_aega .parseBool ();return &_geaa ,_cacae ;};_gcdb :=_eecg .FindStringSubmatch (string (_eagff ));if len (_gcdb )> 1{_febf ,_ =_aega ._addbb .ReadBytes ('R');_ge .Log .Trace ("\u002d\u003e\u0020\u0021\u0052\u0065\u0066\u003a\u0020\u0027\u0025\u0073\u0027",string (_febf [:]));_eecf ,_gafb :=_afcgc (string (_febf ));_eecf ._aaccf =_aega ;return &_eecf ,_gafb ;};_cedc :=_bagb .FindStringSubmatch (string (_eagff ));if len (_cedc )> 1{_ge .Log .Trace ("\u002d\u003e\u0020\u004e\u0075\u006d\u0062\u0065\u0072\u0021");_dgab ,_acfb :=_aega .parseNumber ();return _dgab ,_acfb ;};_cedc =_aged .FindStringSubmatch (string (_eagff ));if len (_cedc )> 1{_ge .Log .Trace ("\u002d\u003e\u0020\u0045xp\u006f\u006e\u0065\u006e\u0074\u0069\u0061\u006c\u0020\u004e\u0075\u006d\u0062\u0065r\u0021");_ge .Log .Trace ("\u0025\u0020\u0073",_cedc );_daab ,_bdde :=_aega .parseNumber ();return _daab ,_bdde ;};_ge .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020U\u006e\u006b\u006e\u006f\u0077n\u0020(\u0070e\u0065\u006b\u0020\u0022\u0025\u0073\u0022)",_eagff );return nil ,_b .New ("\u006f\u0062\u006a\u0065\u0063t\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020\u0075\u006e\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e");};};};

// EncryptInfo contains an information generated by the document encrypter.
type EncryptInfo struct{Version ;

// Encrypt is an encryption dictionary that contains all necessary parameters.
// It should be stored in all copies of the document trailer.
Encrypt *PdfObjectDictionary ;

// ID0 and ID1 are IDs used in the trailer. Older algorithms such as RC4 uses them for encryption.
ID0 ,ID1 string ;};

// EncodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_abgbd *RawEncoder )EncodeBytes (data []byte )([]byte ,error ){return data ,nil };

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_fddaf *RunLengthEncoder )EncodeBytes (data []byte )([]byte ,error ){_feac :=_cdc .NewReader (data );var _babd []byte ;var _eedeg []byte ;_edab ,_fcfc :=_feac .ReadByte ();if _fcfc ==_c .EOF {return []byte {},nil ;}else if _fcfc !=nil {return nil ,_fcfc ;};_baff :=1;for {_cgec ,_gfec :=_feac .ReadByte ();if _gfec ==_c .EOF {break ;}else if _gfec !=nil {return nil ,_gfec ;};if _cgec ==_edab {if len (_eedeg )> 0{_eedeg =_eedeg [:len (_eedeg )-1];if len (_eedeg )> 0{_babd =append (_babd ,byte (len (_eedeg )-1));_babd =append (_babd ,_eedeg ...);};_baff =1;_eedeg =[]byte {};};_baff ++;if _baff >=127{_babd =append (_babd ,byte (257-_baff ),_edab );_baff =0;};}else {if _baff > 0{if _baff ==1{_eedeg =[]byte {_edab };}else {_babd =append (_babd ,byte (257-_baff ),_edab );};_baff =0;};_eedeg =append (_eedeg ,_cgec );if len (_eedeg )>=127{_babd =append (_babd ,byte (len (_eedeg )-1));_babd =append (_babd ,_eedeg ...);_eedeg =[]byte {};};};_edab =_cgec ;};if len (_eedeg )> 0{_babd =append (_babd ,byte (len (_eedeg )-1));_babd =append (_babd ,_eedeg ...);}else if _baff > 0{_babd =append (_babd ,byte (257-_baff ),_edab );};_babd =append (_babd ,128);return _babd ,nil ;};func (_bbcf *PdfParser )readComment ()(string ,error ){var _fadf _cdc .Buffer ;_ ,_cgce :=_bbcf .skipSpaces ();if _cgce !=nil {return _fadf .String (),_cgce ;};_aafda :=true ;for {_fffd ,_edbg :=_bbcf ._addbb .Peek (1);if _edbg !=nil {_ge .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_edbg .Error ());return _fadf .String (),_edbg ;};if _aafda &&_fffd [0]!='%'{return _fadf .String (),_b .New ("c\u006f\u006d\u006d\u0065\u006e\u0074 \u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0073\u0074a\u0072\u0074\u0020w\u0069t\u0068\u0020\u0025");};_aafda =false ;if (_fffd [0]!='\r')&&(_fffd [0]!='\n'){_acae ,_ :=_bbcf ._addbb .ReadByte ();_fadf .WriteByte (_acae );}else {break ;};};return _fadf .String (),nil ;};

// Clear resets the dictionary to an empty state.
func (_efga *PdfObjectDictionary )Clear (){_efga ._bdgg =[]PdfObjectName {};_efga ._cbcd =map[PdfObjectName ]PdfObject {};};

// CCITTFaxEncoder implements Group3 and Group4 facsimile (fax) encoder/decoder.
type CCITTFaxEncoder struct{K int ;EndOfLine bool ;EncodedByteAlign bool ;Columns int ;Rows int ;EndOfBlock bool ;BlackIs1 bool ;DamagedRowsBeforeError int ;};func (_fbfcb *PdfParser )parseNull ()(PdfObjectNull ,error ){_ ,_fada :=_fbfcb ._addbb .Discard (4);return PdfObjectNull {},_fada ;};

// String returns a string representation of `name`.
func (_fbdf *PdfObjectName )String ()string {return string (*_fbdf )};

// GetAsFloat64Slice returns the array as []float64 slice.
// Returns an error if not entirely numeric (only PdfObjectIntegers, PdfObjectFloats).
func (_efbe *PdfObjectArray )GetAsFloat64Slice ()([]float64 ,error ){var _cfagg []float64 ;for _ ,_dfaf :=range _efbe .Elements (){_bcgcc ,_debe :=GetNumberAsFloat (TraceToDirectObject (_dfaf ));if _debe !=nil {return nil ,_fe .Errorf ("\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006e\u0075m\u0062\u0065\u0072");};_cfagg =append (_cfagg ,_bcgcc );};return _cfagg ,nil ;};

// DecodeBytes decodes a slice of ASCII encoded bytes and returns the result.
func (_faab *ASCIIHexEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_fbggf :=_cdc .NewReader (encoded );var _gagd []byte ;for {_dgfc ,_faed :=_fbggf .ReadByte ();if _faed !=nil {return nil ,_faed ;};if _dgfc =='>'{break ;};if IsWhiteSpace (_dgfc ){continue ;};if (_dgfc >='a'&&_dgfc <='f')||(_dgfc >='A'&&_dgfc <='F')||(_dgfc >='0'&&_dgfc <='9'){_gagd =append (_gagd ,_dgfc );}else {_ge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0061\u0073\u0063\u0069\u0069 \u0068\u0065\u0078\u0020\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072 \u0028\u0025\u0063\u0029",_dgfc );return nil ,_fe .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0061\u0073\u0063\u0069\u0069\u0020\u0068e\u0078 \u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u0020\u0028\u0025\u0063\u0029",_dgfc );};};if len (_gagd )%2==1{_gagd =append (_gagd ,'0');};_ge .Log .Trace ("\u0049\u006e\u0062\u006f\u0075\u006e\u0064\u0020\u0025\u0073",_gagd );_eagf :=make ([]byte ,_gd .DecodedLen (len (_gagd )));_ ,_fffc :=_gd .Decode (_eagf ,_gagd );if _fffc !=nil {return nil ,_fffc ;};return _eagf ,nil ;};func (_dadb *PdfParser )parseNumber ()(PdfObject ,error ){return ParseNumber (_dadb ._addbb )};

// GetFilterArray returns the names of the underlying encoding filters in an array that
// can be used as /Filter entry.
func (_bdce *MultiEncoder )GetFilterArray ()*PdfObjectArray {_bgfc :=make ([]PdfObject ,len (_bdce ._cbdga ));for _eged ,_febgb :=range _bdce ._cbdga {_bgfc [_eged ]=MakeName (_febgb .GetFilterName ());};return MakeArray (_bgfc ...);};func (_bae *PdfCrypt )isDecrypted (_dcee PdfObject )bool {_ ,_edbc :=_bae ._ce [_dcee ];if _edbc {_ge .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0064\u0065\u0063\u0072y\u0070\u0074\u0065\u0064");return true ;};switch _faf :=_dcee .(type ){case *PdfObjectStream :if _bae ._affe .R !=5{if _efb ,_dac :=_faf .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_dac &&*_efb =="\u0058\u0052\u0065\u0066"{return true ;};};case *PdfIndirectObject :if _ ,_edbc =_bae ._eac [int (_faf .ObjectNumber )];_edbc {return true ;};switch _gac :=_faf .PdfObject .(type ){case *PdfObjectDictionary :_dbb :=true ;for _ ,_bdfd :=range _abd {if _gac .Get (_bdfd )==nil {_dbb =false ;break ;};};if _dbb {return true ;};};};_ge .Log .Trace ("\u004e\u006f\u0074\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");return false ;};const _fege =32<<(^uint (0)>>63);var _aafg =_ff .MustCompile ("\u0025\u0025\u0045\u004f\u0046\u003f");

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_agcg *ASCII85Encoder )MakeDecodeParams ()PdfObject {return nil };

// GetFilterName returns the name of the encoding filter.
func (_adf *JPXEncoder )GetFilterName ()string {return StreamEncodingFilterNameJPX };

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_ddge *ASCIIHexEncoder )MakeDecodeParams ()PdfObject {return nil };

// DecodeStream decodes a DCT encoded stream and returns the result as a
// slice of bytes.
func (_dcdg *DCTEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _dcdg .DecodeBytes (streamObj .Stream );};

// Encrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_dgb *PdfCrypt )Encrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _dgb .isEncrypted (obj ){return nil ;};switch _adce :=obj .(type ){case *PdfIndirectObject :_dgb ._efe [_adce ]=true ;_ge .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_adce .ObjectNumber ,_adce .GenerationNumber );_dgd :=_adce .ObjectNumber ;_bcbd :=_adce .GenerationNumber ;_ebf :=_dgb .Encrypt (_adce .PdfObject ,_dgd ,_bcbd );if _ebf !=nil {return _ebf ;};return nil ;case *PdfObjectStream :_dgb ._efe [_adce ]=true ;_fgc :=_adce .PdfObjectDictionary ;if _ade ,_dcf :=_fgc .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_dcf &&*_ade =="\u0058\u0052\u0065\u0066"{return nil ;};_ggb :=_adce .ObjectNumber ;_ege :=_adce .GenerationNumber ;_ge .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_ggb ,_ege );_fdee :=_bgbf ;if _dgb ._ddg .V >=4{_fdee =_dgb ._dedf ;_ge .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_dgb ._dedf );if _feb ,_acgb :=_fgc .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );_acgb {if _gagg ,_egdg :=GetName (_feb .Get (0));_egdg {if *_gagg =="\u0043\u0072\u0079p\u0074"{_fdee ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _bcbb ,_bedg :=_fgc .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );_bedg {if _gbbb ,_cbdc :=_bcbb .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_cbdc {if _ ,_ccdf :=_dgb ._effg [string (*_gbbb )];_ccdf {_ge .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_gbbb );_fdee =string (*_gbbb );};};};};};};_ge .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_fdee );if _fdee =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_eafc :=_dgb .Encrypt (_adce .PdfObjectDictionary ,_ggb ,_ege );if _eafc !=nil {return _eafc ;};_agg ,_eafc :=_dgb .makeKey (_fdee ,uint32 (_ggb ),uint32 (_ege ),_dgb ._fbe );if _eafc !=nil {return _eafc ;};_adce .Stream ,_eafc =_dgb .encryptBytes (_adce .Stream ,_fdee ,_agg );if _eafc !=nil {return _eafc ;};_fgc .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_adce .Stream ))));return nil ;case *PdfObjectString :_ge .Log .Trace ("\u0045n\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_cbef :=_bgbf ;if _dgb ._ddg .V >=4{_ge .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_dgb ._cbd );if _dgb ._cbd =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_cbef =_dgb ._cbd ;};_fbff ,_egeb :=_dgb .makeKey (_cbef ,uint32 (parentObjNum ),uint32 (parentGenNum ),_dgb ._fbe );if _egeb !=nil {return _egeb ;};_cbbg :=_adce .Str ();_bff :=make ([]byte ,len (_cbbg ));for _dfd :=0;_dfd < len (_cbbg );_dfd ++{_bff [_dfd ]=_cbbg [_dfd ];};_ge .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_bff ,_bff );_bff ,_egeb =_dgb .encryptBytes (_bff ,_cbef ,_fbff );if _egeb !=nil {return _egeb ;};_adce ._bccece =string (_bff );return nil ;case *PdfObjectArray :for _ ,_gbf :=range _adce .Elements (){_bbae :=_dgb .Encrypt (_gbf ,parentObjNum ,parentGenNum );if _bbae !=nil {return _bbae ;};};return nil ;case *PdfObjectDictionary :_agga :=false ;if _gca :=_adce .Get ("\u0054\u0079\u0070\u0065");_gca !=nil {_fdd ,_gbde :=_gca .(*PdfObjectName );if _gbde &&*_fdd =="\u0053\u0069\u0067"{_agga =true ;};};for _ ,_gfgc :=range _adce .Keys (){_ede :=_adce .Get (_gfgc );if _agga &&string (_gfgc )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;};if string (_gfgc )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_gfgc )!="\u0050\u0072\u0065\u0076"&&string (_gfgc )!="\u004c\u0061\u0073\u0074"{_faee :=_dgb .Encrypt (_ede ,parentObjNum ,parentGenNum );if _faee !=nil {return _faee ;};};};return nil ;};return nil ;};

// PdfObjectString represents the primitive PDF string object.
type PdfObjectString struct{_bccece string ;_edcb bool ;};

// DecodeGlobals decodes 'encoded' byte stream and returns their Globally defined segments ('Globals').
func (_agdf *JBIG2Encoder )DecodeGlobals (encoded []byte )(_ccc .Globals ,error ){return _ccc .DecodeGlobals (encoded );};

// ToFloat64Array returns a slice of all elements in the array as a float64 slice.  An error is
// returned if the array contains non-numeric objects (each element can be either PdfObjectInteger
// or PdfObjectFloat).
func (_ecdd *PdfObjectArray )ToFloat64Array ()([]float64 ,error ){var _bdagd []float64 ;for _ ,_beab :=range _ecdd .Elements (){switch _dcgd :=_beab .(type ){case *PdfObjectInteger :_bdagd =append (_bdagd ,float64 (*_dcgd ));case *PdfObjectFloat :_bdagd =append (_bdagd ,float64 (*_dcgd ));default:return nil ,ErrTypeError ;};};return _bdagd ,nil ;};

// GetFilterName returns the name of the encoding filter.
func (_feed *DCTEncoder )GetFilterName ()string {return StreamEncodingFilterNameDCT };

// MakeName creates a PdfObjectName from a string.
func MakeName (s string )*PdfObjectName {_agcc :=PdfObjectName (s );return &_agcc };

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_gbaf *JPXEncoder )MakeDecodeParams ()PdfObject {return nil };

// GetFilterName returns the name of the encoding filter.
func (_dbcc *ASCII85Encoder )GetFilterName ()string {return StreamEncodingFilterNameASCII85 };

// DecodeBytes decodes a slice of JBIG2 encoded bytes and returns the results.
func (_ggg *JBIG2Encoder )DecodeBytes (encoded []byte )([]byte ,error ){return _ccc .DecodeBytes (encoded ,_cf .Parameters {},_ggg .Globals );};func _bega (_gcgb *PdfObjectStream ,_bcgc *PdfObjectDictionary )(*CCITTFaxEncoder ,error ){_fgae :=NewCCITTFaxEncoder ();_bedac :=_gcgb .PdfObjectDictionary ;if _bedac ==nil {return _fgae ,nil ;};if _bcgc ==nil {_cgfa :=TraceToDirectObject (_bedac .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));if _cgfa !=nil {switch _cgaf :=_cgfa .(type ){case *PdfObjectDictionary :_bcgc =_cgaf ;break ;case *PdfObjectArray :if _cgaf .Len ()==1{if _abc ,_caca :=GetDict (_cgaf .Get (0));_caca {_bcgc =_abc ;};};default:_ge .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_cgfa );return nil ,_b .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _bcgc ==nil {_ge .Log .Error ("\u0044\u0065c\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064 %\u0023\u0076",_cgfa );return nil ,_b .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _cbdg ,_cfec :=GetNumberAsInt64 (_bcgc .Get ("\u004b"));_cfec ==nil {_fgae .K =int (_cbdg );};if _decc ,_dedff :=GetNumberAsInt64 (_bcgc .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));_dedff ==nil {_fgae .Columns =int (_decc );}else {_fgae .Columns =1728;};if _gbae ,_gffb :=GetNumberAsInt64 (_bcgc .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_gffb ==nil {_fgae .BlackIs1 =_gbae > 0;}else {if _cecf ,_eggb :=GetBoolVal (_bcgc .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_eggb {_fgae .BlackIs1 =_cecf ;}else {if _acdd ,_eaaa :=GetArray (_bcgc .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));_eaaa {_aacf ,_agff :=_acdd .ToIntegerArray ();if _agff ==nil {_fgae .BlackIs1 =_aacf [0]==1&&_aacf [1]==0;};};};};if _ccgaf ,_bbb :=GetNumberAsInt64 (_bcgc .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_bbb ==nil {_fgae .EncodedByteAlign =_ccgaf > 0;}else {if _afe ,_facb :=GetBoolVal (_bcgc .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_facb {_fgae .EncodedByteAlign =_afe ;};};if _bgec ,_efbgd :=GetNumberAsInt64 (_bcgc .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_efbgd ==nil {_fgae .EndOfLine =_bgec > 0;}else {if _ecf ,_bdcb :=GetBoolVal (_bcgc .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_bdcb {_fgae .EndOfLine =_ecf ;};};if _adec ,_fgbe :=GetNumberAsInt64 (_bcgc .Get ("\u0052\u006f\u0077\u0073"));_fgbe ==nil {_fgae .Rows =int (_adec );};_fgae .EndOfBlock =true ;if _cfbf ,_aeae :=GetNumberAsInt64 (_bcgc .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_aeae ==nil {_fgae .EndOfBlock =_cfbf > 0;}else {if _dcba ,_dfba :=GetBoolVal (_bcgc .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_dfba {_fgae .EndOfBlock =_dcba ;};};if _aggag ,_fcgb :=GetNumberAsInt64 (_bcgc .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));_fcgb !=nil {_fgae .DamagedRowsBeforeError =int (_aggag );};_ge .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_bcgc .String ());return _fgae ,nil ;};func (_gaaf *PdfParser )skipSpaces ()(int ,error ){_dagb :=0;for {_ggde ,_dcdge :=_gaaf ._addbb .ReadByte ();if _dcdge !=nil {return 0,_dcdge ;};if IsWhiteSpace (_ggde ){_dagb ++;}else {_gaaf ._addbb .UnreadByte ();break ;};};return _dagb ,nil ;};

// WriteString outputs the object as it is to be written to file.
func (_adcg *PdfObjectReference )WriteString ()string {var _cddd _dc .Builder ;_cddd .WriteString (_g .FormatInt (_adcg .ObjectNumber ,10));_cddd .WriteString ("\u0020");_cddd .WriteString (_g .FormatInt (_adcg .GenerationNumber ,10));_cddd .WriteString ("\u0020\u0052");return _cddd .String ();};func (_agcga *PdfParser )repairRebuildXrefsTopDown ()(*XrefTable ,error ){if _agcga ._dcfa {return nil ,_fe .Errorf ("\u0072\u0065\u0070\u0061\u0069\u0072\u0020\u0066\u0061\u0069\u006c\u0065\u0064");};_agcga ._dcfa =true ;_agcga ._dceb .Seek (0,_ef .SEEK_SET );_agcga ._addbb =_cbe .NewReader (_agcga ._dceb );_ccace :=20;_gfbc :=make ([]byte ,_ccace );_cacg :=XrefTable {};_cacg .ObjectMap =make (map[int ]XrefObject );for {_geec ,_ebgaf :=_agcga ._addbb .ReadByte ();if _ebgaf !=nil {if _ebgaf ==_c .EOF {break ;}else {return nil ,_ebgaf ;};};if _geec =='j'&&_gfbc [_ccace -1]=='b'&&_gfbc [_ccace -2]=='o'&&IsWhiteSpace (_gfbc [_ccace -3]){_ccdfe :=_ccace -4;for IsWhiteSpace (_gfbc [_ccdfe ])&&_ccdfe > 0{_ccdfe --;};if _ccdfe ==0||!IsDecimalDigit (_gfbc [_ccdfe ]){continue ;};for IsDecimalDigit (_gfbc [_ccdfe ])&&_ccdfe > 0{_ccdfe --;};if _ccdfe ==0||!IsWhiteSpace (_gfbc [_ccdfe ]){continue ;};for IsWhiteSpace (_gfbc [_ccdfe ])&&_ccdfe > 0{_ccdfe --;};if _ccdfe ==0||!IsDecimalDigit (_gfbc [_ccdfe ]){continue ;};for IsDecimalDigit (_gfbc [_ccdfe ])&&_ccdfe > 0{_ccdfe --;};if _ccdfe ==0{continue ;};_ebec :=_agcga .GetFileOffset ()-int64 (_ccace -_ccdfe );_facf :=append (_gfbc [_ccdfe +1:],_geec );_cdgg ,_ddab ,_daaf :=_beccb (string (_facf ));if _daaf !=nil {_ge .Log .Debug ("\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u006e\u0075\u006d\u0062\u0065r\u003a\u0020\u0025\u0076",_daaf );return nil ,_daaf ;};if _bbce ,_afbf :=_cacg .ObjectMap [_cdgg ];!_afbf ||_bbce .Generation < _ddab {_bfgga :=XrefObject {};_bfgga .XType =XrefTypeTableEntry ;_bfgga .ObjectNumber =int (_cdgg );_bfgga .Generation =int (_ddab );_bfgga .Offset =_ebec ;_cacg .ObjectMap [_cdgg ]=_bfgga ;};};_gfbc =append (_gfbc [1:_ccace ],_geec );};return &_cacg ,nil ;};

// IsFloatDigit checks if a character can be a part of a float number string.
func IsFloatDigit (c byte )bool {return ('0'<=c &&c <='9')||c =='.'};func (_egaca *PdfParser )seekPdfVersionTopDown ()(int ,int ,error ){_egaca ._dceb .Seek (0,_ef .SEEK_SET );_egaca ._addbb =_cbe .NewReader (_egaca ._dceb );_efaa :=20;_fdcb :=make ([]byte ,_efaa );for {_cefee ,_deed :=_egaca ._addbb .ReadByte ();if _deed !=nil {if _deed ==_c .EOF {break ;}else {return 0,0,_deed ;};};if IsDecimalDigit (_cefee )&&_fdcb [_efaa -1]=='.'&&IsDecimalDigit (_fdcb [_efaa -2])&&_fdcb [_efaa -3]=='-'&&_fdcb [_efaa -4]=='F'&&_fdcb [_efaa -5]=='D'&&_fdcb [_efaa -6]=='P'{_fgeab :=int (_fdcb [_efaa -2]-'0');_eeca :=int (_cefee -'0');return _fgeab ,_eeca ,nil ;};_fdcb =append (_fdcb [1:_efaa ],_cefee );};return 0,0,_b .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};

// GetFloatVal returns the float64 value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetFloatVal (obj PdfObject )(_aadg float64 ,_gfca bool ){_bafa ,_gfca :=TraceToDirectObject (obj ).(*PdfObjectFloat );if _gfca {return float64 (*_bafa ),true ;};return 0,false ;};func (_beb *PdfCrypt )encryptBytes (_bgbc []byte ,_ega string ,_baa []byte )([]byte ,error ){_ge .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");_dfe ,_ffaf :=_beb ._effg [_ega ];if !_ffaf {return nil ,_fe .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_ega );};return _dfe .EncryptBytes (_bgbc ,_baa );};func _eee (_fdagf *PdfObjectStream ,_fcee *PdfObjectDictionary )(*JBIG2Encoder ,error ){const _gfga ="\u006ee\u0077\u004a\u0042\u0049G\u0032\u0044\u0065\u0063\u006fd\u0065r\u0046r\u006f\u006d\u0053\u0074\u0072\u0065\u0061m";_fgag :=&JBIG2Encoder {};_bggg :=_fdagf .PdfObjectDictionary ;if _bggg ==nil {return _fgag ,nil ;};if _fcee ==nil {_gbc :=_bggg .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _gbc !=nil {switch _fdb :=_gbc .(type ){case *PdfObjectDictionary :_fcee =_fdb ;case *PdfObjectArray :if _fdb .Len ()==1{if _dfbfa ,_gabfc :=GetDict (_fdb .Get (0));_gabfc {_fcee =_dfbfa ;};};default:_ge .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065P\u0061\u0072\u0061\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064i\u0063\u0074\u0069\u006f\u006e\u0061\u0072y\u0020\u0025\u0023\u0076",_gbc );return nil ,_cc .Errorf (_gfga ,"\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050a\u0072m\u0073\u0020\u0074\u0079\u0070\u0065\u003a \u0025\u0054",_fdb );};};};if _fcee ==nil {return _fgag ,nil ;};_fgag .UpdateParams (_fcee );_ebfe :=_fcee .Get ("\u004a\u0042\u0049G\u0032\u0047\u006c\u006f\u0062\u0061\u006c\u0073");if _ebfe ==nil {return _fgag ,nil ;};var _eedef error ;_acce ,_dfgbb :=_ebfe .(*PdfObjectStream );if !_dfgbb {_eedef =_cc .Error (_gfga ,"j\u0062\u0069\u0067\u0032\u002e\u0047\u006c\u006f\u0062a\u006c\u0073\u0020\u0073\u0074\u0072\u0065am\u0020\u0073\u0068\u006fu\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u006e\u0020Ob\u006a\u0065c\u0074\u0020\u0053\u0074\u0072\u0065\u0061\u006d");_ge .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_eedef );return nil ,_eedef ;};_fgag .Globals ,_eedef =_ccc .DecodeGlobals (_acce .Stream );if _eedef !=nil {_eedef =_cc .Wrap (_eedef ,_gfga ,"\u0063\u006f\u0072\u0072u\u0070\u0074\u0065\u0064\u0020\u006a\u0062\u0069\u0067\u0032 \u0065n\u0063\u006f\u0064\u0065\u0064\u0020\u0064a\u0074\u0061");_ge .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_eedef );return nil ,_eedef ;};return _fgag ,nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_dfdb *RunLengthEncoder )MakeDecodeParams ()PdfObject {return nil };var _bgeb =_ff .MustCompile ("\u0073t\u0061r\u0074\u0078\u003f\u0072\u0065f\u005c\u0073*\u0028\u005c\u0064\u002b\u0029");func (_cbegc *JBIG2Encoder )encodeImage (_aaec _ffa .Image )([]byte ,error ){const _abaa ="e\u006e\u0063\u006f\u0064\u0065\u0049\u006d\u0061\u0067\u0065";_acag ,_acb :=GoImageToJBIG2 (_aaec ,JB2ImageAutoThreshold );if _acb !=nil {return nil ,_cc .Wrap (_acb ,_abaa ,"\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069m\u0061g\u0065\u0020\u0074\u006f\u0020\u006a\u0062\u0069\u0067\u0032\u0020\u0069\u006d\u0067");};if _acb =_cbegc .AddPageImage (_acag ,&_cbegc .DefaultPageSettings );_acb !=nil {return nil ,_cc .Wrap (_acb ,_abaa ,"");};return _cbegc .Encode ();};

// PdfObjectFloat represents the primitive PDF floating point numerical object.
type PdfObjectFloat float64 ;

// DecodeStream implements ASCII85 stream decoding.
func (_egb *ASCII85Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _egb .DecodeBytes (streamObj .Stream );};

// GetParser returns the parser for lazy-loading or compare references.
func (_acdf *PdfObjectReference )GetParser ()*PdfParser {return _acdf ._aaccf };func (_gegd *PdfParser )readTextLine ()(string ,error ){var _fadfg _cdc .Buffer ;for {_agee ,_abfd :=_gegd ._addbb .Peek (1);if _abfd !=nil {_ge .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_abfd .Error ());return _fadfg .String (),_abfd ;};if (_agee [0]!='\r')&&(_agee [0]!='\n'){_gbegf ,_ :=_gegd ._addbb .ReadByte ();_fadfg .WriteByte (_gbegf );}else {break ;};};return _fadfg .String (),nil ;};

// PdfParser parses a PDF file and provides access to the object structure of the PDF.
type PdfParser struct{_aaaa Version ;_dceb _c .ReadSeeker ;_addbb *_cbe .Reader ;_cded int64 ;_afag XrefTable ;_bced int64 ;_ggad *xrefType ;_cebfa objectStreams ;_aedd *PdfObjectDictionary ;_ddfa *PdfCrypt ;_dcfa bool ;ObjCache objectCache ;_dfda map[int64 ]bool ;};

// Elements returns a slice of the PdfObject elements in the array.
func (_caba *PdfObjectArray )Elements ()[]PdfObject {if _caba ==nil {return nil ;};return _caba ._fbfcaa ;};

// PdfVersion returns version of the PDF file.
func (_gfegc *PdfParser )PdfVersion ()Version {return _gfegc ._aaaa };

// GetDict returns the *PdfObjectDictionary represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetDict (obj PdfObject )(_gcgc *PdfObjectDictionary ,_dege bool ){_gcgc ,_dege =TraceToDirectObject (obj ).(*PdfObjectDictionary );return _gcgc ,_dege ;};

// MakeNull creates an PdfObjectNull.
func MakeNull ()*PdfObjectNull {_gbge :=PdfObjectNull {};return &_gbge };type encryptDict struct{Filter string ;V int ;SubFilter string ;Length int ;StmF string ;StrF string ;EFF string ;CF map[string ]_ac .FilterDict ;};

// ResolveReference resolves reference if `o` is a *PdfObjectReference and returns the object referenced to.
// Otherwise returns back `o`.
func ResolveReference (obj PdfObject )PdfObject {if _gdaf ,_acbf :=obj .(*PdfObjectReference );_acbf {return _gdaf .Resolve ();};return obj ;};

// GetObjectStreams returns the *PdfObjectStreams represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetObjectStreams (obj PdfObject )(_fdebe *PdfObjectStreams ,_fadee bool ){_fdebe ,_fadee =obj .(*PdfObjectStreams );return _fdebe ,_fadee ;};func (_geag *PdfParser )traceStreamLength (_cbcfb PdfObject )(PdfObject ,error ){_gcbg ,_abce :=_cbcfb .(*PdfObjectReference );if _abce {_gebf ,_befc :=_geag ._dfda [_gcbg .ObjectNumber ];if _befc &&_gebf {_ge .Log .Debug ("\u0053t\u0072\u0065a\u006d\u0020\u004c\u0065n\u0067\u0074\u0068 \u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065 u\u006e\u0072\u0065s\u006f\u006cv\u0065\u0064\u0020\u0028\u0069\u006cl\u0065\u0067a\u006c\u0029");return nil ,_b .New ("\u0069\u006c\u006c\u0065ga\u006c\u0020\u0072\u0065\u0063\u0075\u0072\u0073\u0069\u0076\u0065\u0020\u006c\u006fo\u0070");};_geag ._dfda [_gcbg .ObjectNumber ]=true ;};_edee ,_cgdcd :=_geag .Resolve (_cbcfb );if _cgdcd !=nil {return nil ,_cgdcd ;};_ge .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_edee );if _abce {_geag ._dfda [_gcbg .ObjectNumber ]=false ;};return _edee ,nil ;};

// Set sets the dictionary's key -> val mapping entry. Overwrites if key already set.
func (_ecae *PdfObjectDictionary )Set (key PdfObjectName ,val PdfObject ){_ ,_cabc :=_ecae ._cbcd [key ];if !_cabc {_ecae ._bdgg =append (_ecae ._bdgg ,key );};_ecae ._cbcd [key ]=val ;};func _aeab (_bfbf *PdfObjectStream ,_fbc *PdfObjectDictionary )(*LZWEncoder ,error ){_cbeb :=NewLZWEncoder ();_fcf :=_bfbf .PdfObjectDictionary ;if _fcf ==nil {return _cbeb ,nil ;};if _fbc ==nil {_cgdb :=TraceToDirectObject (_fcf .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));if _cgdb !=nil {if _bdb ,_dacg :=_cgdb .(*PdfObjectDictionary );_dacg {_fbc =_bdb ;}else if _debc ,_abbe :=_cgdb .(*PdfObjectArray );_abbe {if _debc .Len ()==1{if _gbgd ,_fgd :=GetDict (_debc .Get (0));_fgd {_fbc =_gbgd ;};};};if _fbc ==nil {_ge .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_cgdb );return nil ,_fe .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};};_fac :=_fcf .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");if _fac !=nil {_deg ,_bffc :=_fac .(*PdfObjectInteger );if !_bffc {_ge .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a \u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065d\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u006e\u0075\u006d\u0065\u0072i\u0063 \u0028\u0025\u0054\u0029",_fac );return nil ,_fe .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");};if *_deg !=0&&*_deg !=1{return nil ,_fe .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0076\u0061\u006c\u0075e\u0020\u0028\u006e\u006f\u0074 \u0030\u0020o\u0072\u0020\u0031\u0029");};_cbeb .EarlyChange =int (*_deg );}else {_cbeb .EarlyChange =1;};if _fbc ==nil {return _cbeb ,nil ;};_fac =_fbc .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");if _fac !=nil {_cdeg ,_dgfb :=_fac .(*PdfObjectInteger );if !_dgfb {_ge .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_fac );return nil ,_fe .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_cbeb .Predictor =int (*_cdeg );};_fac =_fbc .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");if _fac !=nil {_afcfa ,_cbed :=_fac .(*PdfObjectInteger );if !_cbed {_ge .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");return nil ,_fe .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_cbeb .BitsPerComponent =int (*_afcfa );};if _cbeb .Predictor > 1{_cbeb .Columns =1;_fac =_fbc .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");if _fac !=nil {_fdda ,_ebda :=_fac .(*PdfObjectInteger );if !_ebda {return nil ,_fe .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_cbeb .Columns =int (*_fdda );};_cbeb .Colors =1;_fac =_fbc .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _fac !=nil {_egg ,_eggg :=_fac .(*PdfObjectInteger );if !_eggg {return nil ,_fe .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");};_cbeb .Colors =int (*_egg );};};_ge .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_fbc .String ());return _cbeb ,nil ;};

// GetFilterName returns the name of the encoding filter.
func (_ceab *JBIG2Encoder )GetFilterName ()string {return StreamEncodingFilterNameJBIG2 };

// String returns a string describing `array`.
func (_dfdc *PdfObjectArray )String ()string {_afgb :="\u005b";for _gfgad ,_ccaef :=range _dfdc .Elements (){_afgb +=_ccaef .String ();if _gfgad < (_dfdc .Len ()-1){_afgb +="\u002c\u0020";};};_afgb +="\u005d";return _afgb ;};

// MakeDict creates and returns an empty PdfObjectDictionary.
func MakeDict ()*PdfObjectDictionary {_cbcb :=&PdfObjectDictionary {};_cbcb ._cbcd =map[PdfObjectName ]PdfObject {};_cbcb ._bdgg =[]PdfObjectName {};return _cbcb ;};

// GetStream returns the *PdfObjectStream represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetStream (obj PdfObject )(_ddaa *PdfObjectStream ,_afea bool ){obj =ResolveReference (obj );_ddaa ,_afea =obj .(*PdfObjectStream );return _ddaa ,_afea ;};func _fgef (_bgfb *PdfObjectStream ,_fdeb *PdfObjectDictionary )(*RunLengthEncoder ,error ){return NewRunLengthEncoder (),nil ;};func _eace (_eaed _ca .Image )*JBIG2Image {_gecg :=_eaed .Base ();return &JBIG2Image {Data :_gecg .Data ,Width :_gecg .Width ,Height :_gecg .Height ,HasPadding :true };};func _deebe (_dfbe *PdfObjectStream )(*MultiEncoder ,error ){_adac :=NewMultiEncoder ();_daga :=_dfbe .PdfObjectDictionary ;if _daga ==nil {return _adac ,nil ;};var _cceg *PdfObjectDictionary ;var _dbg []PdfObject ;_dcga :=_daga .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _dcga !=nil {_ccegb ,_aabd :=_dcga .(*PdfObjectDictionary );if _aabd {_cceg =_ccegb ;};_fefg ,_feg :=_dcga .(*PdfObjectArray );if _feg {for _ ,_dega :=range _fefg .Elements (){_dega =TraceToDirectObject (_dega );if _ddbb ,_acgd :=_dega .(*PdfObjectDictionary );_acgd {_dbg =append (_dbg ,_ddbb );}else {_dbg =append (_dbg ,MakeDict ());};};};};_dcga =_daga .Get ("\u0046\u0069\u006c\u0074\u0065\u0072");if _dcga ==nil {return nil ,_fe .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u006d\u0069s\u0073\u0069\u006e\u0067");};_agbaa ,_fggb :=_dcga .(*PdfObjectArray );if !_fggb {return nil ,_fe .Errorf ("m\u0075\u006c\u0074\u0069\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0063\u0061\u006e\u0020\u006f\u006el\u0079\u0020\u0062\u0065\u0020\u006d\u0061\u0064\u0065\u0020fr\u006f\u006d\u0020a\u0072r\u0061\u0079");};for _dagd ,_cbfe :=range _agbaa .Elements (){_dgfbg ,_cddc :=_cbfe .(*PdfObjectName );if !_cddc {return nil ,_fe .Errorf ("\u006d\u0075l\u0074\u0069\u0020\u0066i\u006c\u0074e\u0072\u0020\u0061\u0072\u0072\u0061\u0079\u0020e\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u006e\u006f\u0074\u0020\u0061 \u006e\u0061\u006d\u0065");};var _gfag PdfObject ;if _cceg !=nil {_gfag =_cceg ;}else {if len (_dbg )> 0{if _dagd >=len (_dbg ){return nil ,_fe .Errorf ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0073\u0020\u0069\u006e\u0020d\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006d\u0073\u0020a\u0072\u0072\u0061\u0079");};_gfag =_dbg [_dagd ];};};var _ceed *PdfObjectDictionary ;if _dbgf ,_feae :=_gfag .(*PdfObjectDictionary );_feae {_ceed =_dbgf ;};_ge .Log .Trace ("\u004e\u0065\u0078t \u006e\u0061\u006d\u0065\u003a\u0020\u0025\u0073\u002c \u0064p\u003a \u0025v\u002c\u0020\u0064\u0050\u0061\u0072\u0061\u006d\u0073\u003a\u0020\u0025\u0076",*_dgfbg ,_gfag ,_ceed );if *_dgfbg ==StreamEncodingFilterNameFlate {_daadf ,_edg :=_fcg (_dfbe ,_ceed );if _edg !=nil {return nil ,_edg ;};_adac .AddEncoder (_daadf );}else if *_dgfbg ==StreamEncodingFilterNameLZW {_deaf ,_eebg :=_aeab (_dfbe ,_ceed );if _eebg !=nil {return nil ,_eebg ;};_adac .AddEncoder (_deaf );}else if *_dgfbg ==StreamEncodingFilterNameASCIIHex {_gdcdg :=NewASCIIHexEncoder ();_adac .AddEncoder (_gdcdg );}else if *_dgfbg ==StreamEncodingFilterNameASCII85 {_gabf :=NewASCII85Encoder ();_adac .AddEncoder (_gabf );}else if *_dgfbg ==StreamEncodingFilterNameDCT {_ffad ,_cefa :=_bgef (_dfbe ,_adac );if _cefa !=nil {return nil ,_cefa ;};_adac .AddEncoder (_ffad );_ge .Log .Trace ("A\u0064d\u0065\u0064\u0020\u0044\u0043\u0054\u0020\u0065n\u0063\u006f\u0064\u0065r.\u002e\u002e");_ge .Log .Trace ("\u004du\u006ct\u0069\u0020\u0065\u006e\u0063o\u0064\u0065r\u003a\u0020\u0025\u0023\u0076",_adac );}else {_ge .Log .Error ("U\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0066\u0069l\u0074\u0065\u0072\u0020\u0025\u0073",*_dgfbg );return nil ,_fe .Errorf ("\u0069\u006eva\u006c\u0069\u0064 \u0066\u0069\u006c\u0074er \u0069n \u006d\u0075\u006c\u0074\u0069\u0020\u0066il\u0074\u0065\u0072\u0020\u0061\u0072\u0072a\u0079");};};return _adac ,nil ;};func (_ace *PdfObjectFloat )String ()string {return _fe .Sprintf ("\u0025\u0066",*_ace )};

// GetAccessPermissions returns the PDF access permissions as an AccessPermissions object.
func (_bbee *PdfCrypt )GetAccessPermissions ()_gc .Permissions {return _bbee ._affe .P };const JB2ImageAutoThreshold =-1.0;

// MakeArrayFromFloats creates an PdfObjectArray from a slice of float64s, where each array element is an
// PdfObjectFloat.
func MakeArrayFromFloats (vals []float64 )*PdfObjectArray {_gdfgc :=MakeArray ();for _ ,_dgedc :=range vals {_gdfgc .Append (MakeFloat (_dgedc ));};return _gdfgc ;};

// PdfObjectReference represents the primitive PDF reference object.
type PdfObjectReference struct{_aaccf *PdfParser ;ObjectNumber int64 ;GenerationNumber int64 ;};

// DecodeStream decodes a FlateEncoded stream object and give back decoded bytes.
func (_daec *FlateEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_ge .Log .Trace ("\u0046l\u0061t\u0065\u0044\u0065\u0063\u006fd\u0065\u0020s\u0074\u0072\u0065\u0061\u006d");_ge .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_daec .Predictor );if _daec .BitsPerComponent !=8{return nil ,_fe .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003d\u0025\u0064\u0020\u0028\u006f\u006e\u006c\u0079\u0020\u0038\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0029",_daec .BitsPerComponent );};_bdaf ,_dcfe :=_daec .DecodeBytes (streamObj .Stream );if _dcfe !=nil {return nil ,_dcfe ;};_bdaf ,_dcfe =_daec .postDecodePredict (_bdaf );if _dcfe !=nil {return nil ,_dcfe ;};return _daec .cleanImageData (_bdaf );};

// PdfCrypt provides PDF encryption/decryption support.
// The PDF standard supports encryption of strings and streams (Section 7.6).
type PdfCrypt struct{_ddg encryptDict ;_affe _gc .StdEncryptDict ;_gdcc string ;_fbe []byte ;_ce map[PdfObject ]bool ;_efe map[PdfObject ]bool ;_dfa bool ;_effg cryptFilters ;_dedf string ;_cbd string ;_dge *PdfParser ;_eac map[int ]struct{};};func (_egfb *PdfParser )parseName ()(PdfObjectName ,error ){var _gdbad _cdc .Buffer ;_eceg :=false ;for {_fdbg ,_fceb :=_egfb ._addbb .Peek (1);if _fceb ==_c .EOF {break ;};if _fceb !=nil {return PdfObjectName (_gdbad .String ()),_fceb ;};if !_eceg {if _fdbg [0]=='/'{_eceg =true ;_egfb ._addbb .ReadByte ();}else if _fdbg [0]=='%'{_egfb .readComment ();_egfb .skipSpaces ();}else {_ge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020N\u0061\u006d\u0065\u0020\u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020w\u0069\u0074\u0068\u0020\u0025\u0073\u0020(\u0025\u0020\u0078\u0029",_fdbg ,_fdbg );return PdfObjectName (_gdbad .String ()),_fe .Errorf ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u006ea\u006d\u0065:\u0020\u0028\u0025\u0063\u0029",_fdbg [0]);};}else {if IsWhiteSpace (_fdbg [0]){break ;}else if (_fdbg [0]=='/')||(_fdbg [0]=='[')||(_fdbg [0]=='(')||(_fdbg [0]==']')||(_fdbg [0]=='<')||(_fdbg [0]=='>'){break ;}else if _fdbg [0]=='#'{_egfa ,_deebd :=_egfb ._addbb .Peek (3);if _deebd !=nil {return PdfObjectName (_gdbad .String ()),_deebd ;};_ecedb ,_deebd :=_gd .DecodeString (string (_egfa [1:3]));if _deebd !=nil {_ge .Log .Debug ("\u0045\u0052\u0052\u004fR\u003a\u0020\u0049\u006ev\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0066o\u006c\u006co\u0077\u0069\u006e\u0067 \u0027\u0023\u0027\u002c \u0063\u006f\u006e\u0074\u0069n\u0075\u0069\u006e\u0067\u0020\u0075\u0073i\u006e\u0067\u0020\u006c\u0069t\u0065\u0072\u0061\u006c\u0020\u002d\u0020\u004f\u0075t\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074");_gdbad .WriteByte ('#');_egfb ._addbb .Discard (1);continue ;};_egfb ._addbb .Discard (3);_gdbad .Write (_ecedb );}else {_afcg ,_ :=_egfb ._addbb .ReadByte ();_gdbad .WriteByte (_afcg );};};};return PdfObjectName (_gdbad .String ()),nil ;};func _egagb (_fdbcg ,_befd ,_fefaa int )error {if _befd < 0||_befd > _fdbcg {return _b .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0061\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");};if _fefaa < _befd {return _b .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0073\u006c\u0069\u0063e\u0020i\u006ed\u0065\u0078\u0020\u0062\u0020\u003c\u0020a");};if _fefaa > _fdbcg {return _b .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0062\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");};return nil ;};

// GetIndirect returns the *PdfIndirectObject represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetIndirect (obj PdfObject )(_bfe *PdfIndirectObject ,_fbfb bool ){obj =ResolveReference (obj );_bfe ,_fbfb =obj .(*PdfIndirectObject );return _bfe ,_fbfb ;};

// MakeString creates an PdfObjectString from a string.
// NOTE: PDF does not use utf-8 string encoding like Go so `s` will often not be a utf-8 encoded
// string.
func MakeString (s string )*PdfObjectString {_gfab :=PdfObjectString {_bccece :s };return &_gfab };func _aedgd ()string {return _ge .Version };

// Version represents a version of a PDF standard.
type Version struct{Major int ;Minor int ;};func (_ddce *PdfParser )xrefNextObjectOffset (_bccg int64 )int64 {_fabf :=int64 (0);if len (_ddce ._afag .ObjectMap )==0{return 0;};if len (_ddce ._afag ._eb )==0{_ebad :=0;for _ ,_agge :=range _ddce ._afag .ObjectMap {if _agge .Offset > 0{_ebad ++;};};if _ebad ==0{return 0;};_ddce ._afag ._eb =make ([]XrefObject ,_ebad );_geef :=0;for _ ,_bdag :=range _ddce ._afag .ObjectMap {if _bdag .Offset > 0{_ddce ._afag ._eb [_geef ]=_bdag ;_geef ++;};};_f .Slice (_ddce ._afag ._eb ,func (_efeb ,_fdgd int )bool {return _ddce ._afag ._eb [_efeb ].Offset < _ddce ._afag ._eb [_fdgd ].Offset });};_aeabd :=_f .Search (len (_ddce ._afag ._eb ),func (_egac int )bool {return _ddce ._afag ._eb [_egac ].Offset >=_bccg });if _aeabd < len (_ddce ._afag ._eb ){_fabf =_ddce ._afag ._eb [_aeabd ].Offset ;};return _fabf ;};

// String returns the state of the bool as "true" or "false".
func (_dacb *PdfObjectBool )String ()string {if *_dacb {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};

// IsNullObject returns true if `obj` is a PdfObjectNull.
func IsNullObject (obj PdfObject )bool {_ ,_fgeea :=TraceToDirectObject (obj ).(*PdfObjectNull );return _fgeea ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_eggc *JPXEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};

// PdfObjectStream represents the primitive PDF Object stream.
type PdfObjectStream struct{PdfObjectReference ;*PdfObjectDictionary ;Stream []byte ;};

// EncodeJBIG2Image encodes 'img' into jbig2 encoded bytes stream, using default encoder settings.
func (_dbbgd *JBIG2Encoder )EncodeJBIG2Image (img *JBIG2Image )([]byte ,error ){const _gfae ="c\u006f\u0072\u0065\u002eEn\u0063o\u0064\u0065\u004a\u0042\u0049G\u0032\u0049\u006d\u0061\u0067\u0065";if _fbaf :=_dbbgd .AddPageImage (img ,&_dbbgd .DefaultPageSettings );_fbaf !=nil {return nil ,_cc .Wrap (_fbaf ,_gfae ,"");};return _dbbgd .Encode ();};func _bbege (_beeb ,_gccb ,_edbabe uint8 )uint8 {_dgdb :=int (_edbabe );_cfdg :=int (_gccb )-_dgdb ;_fbd :=int (_beeb )-_dgdb ;_dgdb =_adad (_cfdg +_fbd );_cfdg =_adad (_cfdg );_fbd =_adad (_fbd );if _cfdg <=_fbd &&_cfdg <=_dgdb {return _beeb ;}else if _fbd <=_dgdb {return _gccb ;};return _edbabe ;};func (_egdc *PdfParser )rebuildXrefTable ()error {_fccfe :=XrefTable {};_fccfe .ObjectMap =map[int ]XrefObject {};for _bdbaa ,_dbcgf :=range _egdc ._afag .ObjectMap {_ccbc ,_ ,_febdb :=_egdc .lookupByNumberWrapper (_bdbaa ,false );if _febdb !=nil {_ge .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020U\u006e\u0061\u0062\u006ce t\u006f l\u006f\u006f\u006b\u0020\u0075\u0070\u0020ob\u006a\u0065\u0063\u0074\u0020\u0028\u0025s\u0029",_febdb );_ge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0063\u006fm\u0070\u006c\u0065\u0074\u0065\u006c\u0079\u0020\u0062\u0072\u006f\u006b\u0065\u006e\u0020\u002d\u0020\u0061\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0074\u006f \u0072\u0065\u0070\u0061\u0069r\u0020");_gbded ,_dggee :=_egdc .repairRebuildXrefsTopDown ();if _dggee !=nil {_ge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0072\u0065\u0062\u0075\u0069l\u0064\u0020\u0072\u0065\u0070a\u0069\u0072 \u0028\u0025\u0073\u0029",_dggee );return _dggee ;};_egdc ._afag =*_gbded ;_ge .Log .Debug ("\u0052e\u0070\u0061\u0069\u0072e\u0064\u0020\u0078\u0072\u0065f\u0020t\u0061b\u006c\u0065\u0020\u0062\u0075\u0069\u006ct");return nil ;};_bfcg ,_bcece ,_febdb :=_dca (_ccbc );if _febdb !=nil {return _febdb ;};_dbcgf .ObjectNumber =int (_bfcg );_dbcgf .Generation =int (_bcece );_fccfe .ObjectMap [int (_bfcg )]=_dbcgf ;};_egdc ._afag =_fccfe ;_ge .Log .Debug ("N\u0065w\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061b\u006c\u0065\u0020\u0062ui\u006c\u0074");_bcg (_egdc ._afag );return nil ;};

// DecodeStream decodes the stream data and returns the decoded data.
// An error is returned upon failure.
func DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_ge .Log .Trace ("\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_gfceg ,_adfe :=NewEncoderFromStream (streamObj );if _adfe !=nil {_ge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_adfe );return nil ,_adfe ;};_ge .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076\u000a",_gfceg );_eabc ,_adfe :=_gfceg .DecodeStream (streamObj );if _adfe !=nil {_ge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_adfe );return nil ,_adfe ;};return _eabc ,nil ;};var _aged =_ff .MustCompile ("\u005e\u005b\\\u002b\u002d\u002e\u005d*\u0028\u005b0\u002d\u0039\u002e\u005d\u002b\u0029\u005b\u0065E\u005d\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");

// EncodeBytes encodes slice of bytes into JBIG2 encoding format.
// The input 'data' must be an image. In order to Decode it a user is responsible to
// load the codec ('png', 'jpg').
// Returns jbig2 single page encoded document byte slice. The encoder uses DefaultPageSettings
// to encode given image.
func (_ddea *JBIG2Encoder )EncodeBytes (data []byte )([]byte ,error ){const _dfdbf ="\u004aB\u0049\u0047\u0032\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002eE\u006e\u0063\u006f\u0064\u0065\u0042\u0079\u0074\u0065\u0073";if _ddea .ColorComponents !=1||_ddea .BitsPerComponent !=1{return nil ,_cc .Errorf (_dfdbf ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u002e\u0020\u004a\u0042\u0049G\u0032\u0020E\u006e\u0063o\u0064\u0065\u0072\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020bi\u006e\u0061\u0072\u0079\u0020\u0069\u006d\u0061\u0067e\u0073\u0020\u0064\u0061\u0074\u0061");};var (_dgbc *_cbc .Bitmap ;_geac error ;);_gdf :=(_ddea .Width *_ddea .Height )==len (data );if _gdf {_dgbc ,_geac =_cbc .NewWithUnpaddedData (_ddea .Width ,_ddea .Height ,data );}else {_dgbc ,_geac =_cbc .NewWithData (_ddea .Width ,_ddea .Height ,data );};if _geac !=nil {return nil ,_geac ;};_acfe :=_ddea .DefaultPageSettings ;if _geac =_acfe .Validate ();_geac !=nil {return nil ,_cc .Wrap (_geac ,_dfdbf ,"");};switch _acfe .Compression {case JB2Generic :if _geac =_ddea ._dafd .AddGenericPage (_dgbc ,_acfe .DuplicatedLinesRemoval );_geac !=nil {return nil ,_cc .Wrap (_geac ,_dfdbf ,"");};case JB2SymbolCorrelation :return nil ,_cc .Error (_dfdbf ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");case JB2SymbolRankHaus :return nil ,_cc .Error (_dfdbf ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");default:return nil ,_cc .Error (_dfdbf ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return _ddea .Encode ();};type offsetReader struct{_cbfa _c .ReadSeeker ;_bada int64 ;};func _afcgc (_bffa string )(PdfObjectReference ,error ){_dggd :=PdfObjectReference {};_aec :=_eecg .FindStringSubmatch (string (_bffa ));if len (_aec )< 3{_ge .Log .Debug ("\u0045\u0072\u0072or\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");return _dggd ,_b .New ("\u0075n\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061r\u0073e\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");};_abff ,_ :=_g .Atoi (_aec [1]);_becc ,_ :=_g .Atoi (_aec [2]);_dggd .ObjectNumber =int64 (_abff );_dggd .GenerationNumber =int64 (_becc );return _dggd ,nil ;};

// GetNumbersAsFloat converts a list of pdf objects representing floats or integers to a slice of
// float64 values.
func GetNumbersAsFloat (objects []PdfObject )(_fcdf []float64 ,_dcgaf error ){for _ ,_gebe :=range objects {_eebd ,_fbbf :=GetNumberAsFloat (_gebe );if _fbbf !=nil {return nil ,_fbbf ;};_fcdf =append (_fcdf ,_eebd );};return _fcdf ,nil ;};

// IsWhiteSpace checks if byte represents a white space character.
func IsWhiteSpace (ch byte )bool {if (ch ==0x00)||(ch ==0x09)||(ch ==0x0A)||(ch ==0x0C)||(ch ==0x0D)||(ch ==0x20){return true ;};return false ;};

// GetFilterName returns the name of the encoding filter.
func (_dgcf *CCITTFaxEncoder )GetFilterName ()string {return StreamEncodingFilterNameCCITTFax };

// JBIG2Image is the image structure used by the jbig2 encoder. Its Data must be in a
// 1 bit per component and 1 component per pixel (1bpp). In order to create binary image
// use GoImageToJBIG2 function. If the image data contains the row bytes padding set the HasPadding to true.
type JBIG2Image struct{

// Width and Height defines the image boundaries.
Width ,Height int ;

// Data is the byte slice data for the input image
Data []byte ;

// HasPadding is the attribute that defines if the last byte of the data in the row contains
// 0 bits padding.
HasPadding bool ;};

// DecodeBytes decodes a slice of DCT encoded bytes and returns the result.
func (_deaa *DCTEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_fagg :=_cdc .NewReader (encoded );_ecce ,_fbca :=_cd .Decode (_fagg );if _fbca !=nil {_ge .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006eg\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_fbca );return nil ,_fbca ;};_aage :=_ecce .Bounds ();var _bga =make ([]byte ,_aage .Dx ()*_aage .Dy ()*_deaa .ColorComponents *_deaa .BitsPerComponent /8);_cef :=0;for _efg :=_aage .Min .Y ;_efg < _aage .Max .Y ;_efg ++{for _cggd :=_aage .Min .X ;_cggd < _aage .Max .X ;_cggd ++{_aca :=_ecce .At (_cggd ,_efg );if _deaa .ColorComponents ==1{if _deaa .BitsPerComponent ==16{_bbag ,_deaag :=_aca .(_gb .Gray16 );if !_deaag {return nil ,_b .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_bga [_cef ]=byte ((_bbag .Y >>8)&0xff);_cef ++;_bga [_cef ]=byte (_bbag .Y &0xff);_cef ++;}else {_cbf ,_bffca :=_aca .(_gb .Gray );if !_bffca {return nil ,_b .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_bga [_cef ]=byte (_cbf .Y &0xff);_cef ++;};}else if _deaa .ColorComponents ==3{if _deaa .BitsPerComponent ==16{_debf ,_fgbg :=_aca .(_gb .RGBA64 );if !_fgbg {return nil ,_b .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_bga [_cef ]=byte ((_debf .R >>8)&0xff);_cef ++;_bga [_cef ]=byte (_debf .R &0xff);_cef ++;_bga [_cef ]=byte ((_debf .G >>8)&0xff);_cef ++;_bga [_cef ]=byte (_debf .G &0xff);_cef ++;_bga [_cef ]=byte ((_debf .B >>8)&0xff);_cef ++;_bga [_cef ]=byte (_debf .B &0xff);_cef ++;}else {_afce ,_effd :=_aca .(_gb .RGBA );if _effd {_bga [_cef ]=_afce .R &0xff;_cef ++;_bga [_cef ]=_afce .G &0xff;_cef ++;_bga [_cef ]=_afce .B &0xff;_cef ++;}else {_faea ,_edac :=_aca .(_gb .YCbCr );if !_edac {return nil ,_b .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_ggea ,_dbeg ,_fdfa ,_ :=_faea .RGBA ();_bga [_cef ]=byte (_ggea >>8);_cef ++;_bga [_cef ]=byte (_dbeg >>8);_cef ++;_bga [_cef ]=byte (_fdfa >>8);_cef ++;};};}else if _deaa .ColorComponents ==4{_cfb ,_cdff :=_aca .(_gb .CMYK );if !_cdff {return nil ,_b .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_bga [_cef ]=255-_cfb .C &0xff;_cef ++;_bga [_cef ]=255-_cfb .M &0xff;_cef ++;_bga [_cef ]=255-_cfb .Y &0xff;_cef ++;_bga [_cef ]=255-_cfb .K &0xff;_cef ++;};};};return _bga ,nil ;};

// Decoded returns the PDFDocEncoding or UTF-16BE decoded string contents.
// UTF-16BE is applied when the first two bytes are 0xFE, 0XFF, otherwise decoding of
// PDFDocEncoding is performed.
func (_bfa *PdfObjectString )Decoded ()string {if _bfa ==nil {return "";};_edag :=[]byte (_bfa ._bccece );if len (_edag )>=2&&_edag [0]==0xFE&&_edag [1]==0xFF{return _ga .UTF16ToString (_edag [2:]);};return _ga .PDFDocEncodingToString (_edag );};func _bgef (_bfdf *PdfObjectStream ,_accd *MultiEncoder )(*DCTEncoder ,error ){_gada :=NewDCTEncoder ();_dgac :=_bfdf .PdfObjectDictionary ;if _dgac ==nil {return _gada ,nil ;};_beba :=_bfdf .Stream ;if _accd !=nil {_agcb ,_cfeb :=_accd .DecodeBytes (_beba );if _cfeb !=nil {return nil ,_cfeb ;};_beba =_agcb ;};_debcf :=_cdc .NewReader (_beba );_bede ,_dbfb :=_cd .DecodeConfig (_debcf );if _dbfb !=nil {_ge .Log .Debug ("\u0045\u0072\u0072or\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0065\u003a\u0020\u0025\u0073",_dbfb );return nil ,_dbfb ;};switch _bede .ColorModel {case _gb .RGBAModel :_gada .BitsPerComponent =8;_gada .ColorComponents =3;case _gb .RGBA64Model :_gada .BitsPerComponent =16;_gada .ColorComponents =3;case _gb .GrayModel :_gada .BitsPerComponent =8;_gada .ColorComponents =1;case _gb .Gray16Model :_gada .BitsPerComponent =16;_gada .ColorComponents =1;case _gb .CMYKModel :_gada .BitsPerComponent =8;_gada .ColorComponents =4;case _gb .YCbCrModel :_gada .BitsPerComponent =8;_gada .ColorComponents =3;default:return nil ,_b .New ("\u0075\u006e\u0073up\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u006d\u006f\u0064\u0065\u006c");};_gada .Width =_bede .Width ;_gada .Height =_bede .Height ;_ge .Log .Trace ("\u0044\u0043T\u0020\u0045\u006ec\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076",_gada );_gada .Quality =DefaultJPEGQuality ;return _gada ,nil ;};func (_fga *PdfCrypt )saveCryptFilters (_afg *PdfObjectDictionary )error {if _fga ._ddg .V < 4{return _b .New ("\u0063\u0061\u006e\u0020\u006f\u006e\u006c\u0079\u0020\u0062\u0065 \u0075\u0073\u0065\u0064\u0020\u0077\u0069\u0074\u0068\u0020V\u003e\u003d\u0034");};_bbf :=MakeDict ();_afg .Set ("\u0043\u0046",_bbf );for _dccg ,_bee :=range _fga ._effg {if _dccg =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{continue ;};_adca :=_aga (_bee ,"");_bbf .Set (PdfObjectName (_dccg ),_adca );};_afg .Set ("\u0053\u0074\u0072\u0046",MakeName (_fga ._cbd ));_afg .Set ("\u0053\u0074\u006d\u0046",MakeName (_fga ._dedf ));return nil ;};func (_begf *PdfCrypt )authenticate (_ddgd []byte )(bool ,error ){_begf ._dfa =false ;_dff :=_begf .securityHandler ();_abgd ,_cge ,_feec :=_dff .Authenticate (&_begf ._affe ,_ddgd );if _feec !=nil {return false ,_feec ;}else if _cge ==0||len (_abgd )==0{return false ,nil ;};_begf ._dfa =true ;_begf ._fbe =_abgd ;return true ,nil ;};

// PdfIndirectObject represents the primitive PDF indirect object.
type PdfIndirectObject struct{PdfObjectReference ;PdfObject ;};

// Append appends PdfObject(s) to the streams.
func (_bdagf *PdfObjectStreams )Append (objects ...PdfObject ){if _bdagf ==nil {_ge .Log .Debug ("\u0057\u0061\u0072\u006e\u0020-\u0020\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0020\u0074\u006f\u0020\u0061p\u0070\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0073");return ;};if _bdagf ._ccff ==nil {_bdagf ._ccff =[]PdfObject {};};for _ ,_ecaa :=range objects {_bdagf ._ccff =append (_bdagf ._ccff ,_ecaa );};};func (_ccd *PdfCrypt )checkAccessRights (_dbc []byte )(bool ,_gc .Permissions ,error ){_fcb :=_ccd .securityHandler ();_gdd ,_cdg ,_bafe :=_fcb .Authenticate (&_ccd ._affe ,_dbc );if _bafe !=nil {return false ,0,_bafe ;}else if _cdg ==0||len (_gdd )==0{return false ,0,nil ;};return true ,_cdg ,nil ;};

// PdfObjectBool represents the primitive PDF boolean object.
type PdfObjectBool bool ;

// MakeStreamDict make a new instance of an encoding dictionary for a stream object.
func (_afaa *ASCII85Encoder )MakeStreamDict ()*PdfObjectDictionary {_gcab :=MakeDict ();_gcab .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_afaa .GetFilterName ()));return _gcab ;};

// EncodeBytes ASCII encodes the passed in slice of bytes.
func (_eegd *ASCIIHexEncoder )EncodeBytes (data []byte )([]byte ,error ){var _gebc _cdc .Buffer ;for _ ,_begb :=range data {_gebc .WriteString (_fe .Sprintf ("\u0025\u002e\u0032X\u0020",_begb ));};_gebc .WriteByte ('>');return _gebc .Bytes (),nil ;};

// UpdateParams updates the parameter values of the encoder.
// Implements StreamEncoder interface.
func (_dfae *JBIG2Encoder )UpdateParams (params *PdfObjectDictionary ){_gbee ,_dgga :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _dgga ==nil {_dfae .BitsPerComponent =int (_gbee );};_fbbb ,_dgga :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _dgga ==nil {_dfae .Width =int (_fbbb );};_eeba ,_dgga :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _dgga ==nil {_dfae .Height =int (_eeba );};_fdage ,_dgga :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _dgga ==nil {_dfae .ColorComponents =int (_fdage );};};

// String returns a string representation of the *PdfObjectString.
func (_agfe *PdfObjectString )String ()string {return _agfe ._bccece };

// GetFilterName returns the name of the encoding filter.
func (_bec *RunLengthEncoder )GetFilterName ()string {return StreamEncodingFilterNameRunLength };

// ASCIIHexEncoder implements ASCII hex encoder/decoder.
type ASCIIHexEncoder struct{};

// PdfObjectArray represents the primitive PDF array object.
type PdfObjectArray struct{_fbfcaa []PdfObject };

// NewDCTEncoder makes a new DCT encoder with default parameters.
func NewDCTEncoder ()*DCTEncoder {_bgbff :=&DCTEncoder {};_bgbff .ColorComponents =3;_bgbff .BitsPerComponent =8;_bgbff .Quality =DefaultJPEGQuality ;return _bgbff ;};

// WriteString outputs the object as it is to be written to file.
func (_fbea *PdfObjectName )WriteString ()string {var _fbbd _cdc .Buffer ;if len (*_fbea )> 127{_ge .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u004e\u0061\u006d\u0065\u0020t\u006fo\u0020l\u006f\u006e\u0067\u0020\u0028\u0025\u0073)",*_fbea );};_fbbd .WriteString ("\u002f");for _accfg :=0;_accfg < len (*_fbea );_accfg ++{_cbcdg :=(*_fbea )[_accfg ];if !IsPrintable (_cbcdg )||_cbcdg =='#'||IsDelimiter (_cbcdg ){_fbbd .WriteString (_fe .Sprintf ("\u0023\u0025\u002e2\u0078",_cbcdg ));}else {_fbbd .WriteByte (_cbcdg );};};return _fbbd .String ();};func (_cgfb *offsetReader )Seek (offset int64 ,whence int )(int64 ,error ){if whence ==_c .SeekStart {offset +=_cgfb ._bada ;};_aace ,_edf :=_cgfb ._cbfa .Seek (offset ,whence );if _edf !=nil {return _aace ,_edf ;};if whence ==_c .SeekCurrent {_aace -=_cgfb ._bada ;};if _aace < 0{return 0,_b .New ("\u0063\u006f\u0072\u0065\u002eo\u0066\u0066\u0073\u0065\u0074\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053e\u0065\u006b\u003a\u0020\u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e");};return _aace ,nil ;};

// Resolve resolves a PdfObject to direct object, looking up and resolving references as needed (unlike TraceToDirect).
func (_gde *PdfParser )Resolve (obj PdfObject )(PdfObject ,error ){_dadd ,_cga :=obj .(*PdfObjectReference );if !_cga {return obj ,nil ;};_cab :=_gde .GetFileOffset ();defer func (){_gde .SetFileOffset (_cab )}();_fea ,_fc :=_gde .LookupByReference (*_dadd );if _fc !=nil {return nil ,_fc ;};_faa ,_ebd :=_fea .(*PdfIndirectObject );if !_ebd {return _fea ,nil ;};_fea =_faa .PdfObject ;_ ,_cga =_fea .(*PdfObjectReference );if _cga {return _faa ,_b .New ("\u006d\u0075lt\u0069\u0020\u0064e\u0070\u0074\u0068\u0020tra\u0063e \u0070\u006f\u0069\u006e\u0074\u0065\u0072 t\u006f\u0020\u0070\u006f\u0069\u006e\u0074e\u0072");};return _fea ,nil ;};

// FlateEncoder represents Flate encoding.
type FlateEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Rows int ;Colors int ;_bbaf *_ca .ImageBase ;};

// NewJPXEncoder returns a new instance of JPXEncoder.
func NewJPXEncoder ()*JPXEncoder {return &JPXEncoder {}};

// Len returns the number of elements in the array.
func (_eaaf *PdfObjectArray )Len ()int {if _eaaf ==nil {return 0;};return len (_eaaf ._fbfcaa );};var _abd =[]PdfObjectName {"\u0056","\u0052","\u004f","\u0055","\u0050"};func (_dgf *PdfCrypt )securityHandler ()_gc .StdHandler {if _dgf ._affe .R >=5{return _gc .NewHandlerR6 ();};return _gc .NewHandlerR4 (_dgf ._gdcc ,_dgf ._ddg .Length );};

// WriteString outputs the object as it is to be written to file.
func (_gbbc *PdfObjectNull )WriteString ()string {return "\u006e\u0075\u006c\u006c"};const (XrefTypeTableEntry xrefType =iota ;XrefTypeObjectStream xrefType =iota ;);

// Decrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_agba *PdfCrypt )Decrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _agba .isDecrypted (obj ){return nil ;};switch _ffc :=obj .(type ){case *PdfIndirectObject :_agba ._ce [_ffc ]=true ;_ge .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_ffc .ObjectNumber ,_ffc .GenerationNumber );_gcfd :=_ffc .ObjectNumber ;_fde :=_ffc .GenerationNumber ;_abb :=_agba .Decrypt (_ffc .PdfObject ,_gcfd ,_fde );if _abb !=nil {return _abb ;};return nil ;case *PdfObjectStream :_agba ._ce [_ffc ]=true ;_gae :=_ffc .PdfObjectDictionary ;if _agba ._affe .R !=5{if _acg ,_edc :=_gae .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_edc &&*_acg =="\u0058\u0052\u0065\u0066"{return nil ;};};_ebb :=_ffc .ObjectNumber ;_abga :=_ffc .GenerationNumber ;_ge .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_ebb ,_abga );_bcf :=_bgbf ;if _agba ._ddg .V >=4{_bcf =_agba ._dedf ;_ge .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_agba ._dedf );if _acf ,_gbbe :=_gae .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );_gbbe {if _fbg ,_bdac :=GetName (_acf .Get (0));_bdac {if *_fbg =="\u0043\u0072\u0079p\u0074"{_bcf ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _cdad ,_gfc :=_gae .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );_gfc {if _agc ,_dgeb :=_cdad .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_dgeb {if _ ,_gbeg :=_agba ._effg [string (*_agc )];_gbeg {_ge .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_agc );_bcf =string (*_agc );};};};};};};_ge .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_bcf );if _bcf =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_fgad :=_agba .Decrypt (_gae ,_ebb ,_abga );if _fgad !=nil {return _fgad ;};_eda ,_fgad :=_agba .makeKey (_bcf ,uint32 (_ebb ),uint32 (_abga ),_agba ._fbe );if _fgad !=nil {return _fgad ;};_ffc .Stream ,_fgad =_agba .decryptBytes (_ffc .Stream ,_bcf ,_eda );if _fgad !=nil {return _fgad ;};_gae .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_ffc .Stream ))));return nil ;case *PdfObjectString :_ge .Log .Trace ("\u0044e\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_gfe :=_bgbf ;if _agba ._ddg .V >=4{_ge .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_agba ._cbd );if _agba ._cbd =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_gfe =_agba ._cbd ;};_ffae ,_ddd :=_agba .makeKey (_gfe ,uint32 (parentObjNum ),uint32 (parentGenNum ),_agba ._fbe );if _ddd !=nil {return _ddd ;};_deeb :=_ffc .Str ();_bcab :=make ([]byte ,len (_deeb ));for _dacc :=0;_dacc < len (_deeb );_dacc ++{_bcab [_dacc ]=_deeb [_dacc ];};_ge .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_bcab ,_bcab );_bcab ,_ddd =_agba .decryptBytes (_bcab ,_gfe ,_ffae );if _ddd !=nil {return _ddd ;};_ffc ._bccece =string (_bcab );return nil ;case *PdfObjectArray :for _ ,_fage :=range _ffc .Elements (){_ebg :=_agba .Decrypt (_fage ,parentObjNum ,parentGenNum );if _ebg !=nil {return _ebg ;};};return nil ;case *PdfObjectDictionary :_fdaa :=false ;if _bgge :=_ffc .Get ("\u0054\u0079\u0070\u0065");_bgge !=nil {_cfa ,_cdae :=_bgge .(*PdfObjectName );if _cdae &&*_cfa =="\u0053\u0069\u0067"{_fdaa =true ;};};for _ ,_dcd :=range _ffc .Keys (){_cee :=_ffc .Get (_dcd );if _fdaa &&string (_dcd )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;};if string (_dcd )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_dcd )!="\u0050\u0072\u0065\u0076"&&string (_dcd )!="\u004c\u0061\u0073\u0074"{_aed :=_agba .Decrypt (_cee ,parentObjNum ,parentGenNum );if _aed !=nil {return _aed ;};};};return nil ;};return nil ;};func _fggbg (_gfage PdfObject )(*float64 ,error ){switch _cfde :=_gfage .(type ){case *PdfObjectFloat :_edec :=float64 (*_cfde );return &_edec ,nil ;case *PdfObjectInteger :_fdeg :=float64 (*_cfde );return &_fdeg ,nil ;case *PdfObjectNull :return nil ,nil ;};return nil ,ErrNotANumber ;};

// NewRawEncoder returns a new instace of RawEncoder.
func NewRawEncoder ()*RawEncoder {return &RawEncoder {}};

// EncodeStream encodes the stream data using the encoded specified by the stream's dictionary.
func EncodeStream (streamObj *PdfObjectStream )error {_ge .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_bgeg ,_faec :=NewEncoderFromStream (streamObj );if _faec !=nil {_ge .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_faec );return _faec ;};if _eecae ,_bdeb :=_bgeg .(*LZWEncoder );_bdeb {_eecae .EarlyChange =0;streamObj .PdfObjectDictionary .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (0));};_ge .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076\u000a",_bgeg );_cedg ,_faec :=_bgeg .EncodeBytes (streamObj .Stream );if _faec !=nil {_ge .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_faec );return _faec ;};streamObj .Stream =_cedg ;streamObj .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_cedg ))));return nil ;};

// NewMultiEncoder returns a new instance of MultiEncoder.
func NewMultiEncoder ()*MultiEncoder {_dbbbf :=MultiEncoder {};_dbbbf ._cbdga =[]StreamEncoder {};return &_dbbbf ;};func (_cac *PdfCrypt )generateParams (_gce ,_gec []byte )error {_egf :=_cac .securityHandler ();_fdde ,_ebfg :=_egf .GenerateParams (&_cac ._affe ,_gec ,_gce );if _ebfg !=nil {return _ebfg ;};_cac ._fbe =_fdde ;return nil ;};

// DecodeStream decodes a LZW encoded stream and returns the result as a
// slice of bytes.
func (_bggea *LZWEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_ge .Log .Trace ("\u004c\u005a\u0057 \u0044\u0065\u0063\u006f\u0064\u0069\u006e\u0067");_ge .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_bggea .Predictor );_feea ,_ccgb :=_bggea .DecodeBytes (streamObj .Stream );if _ccgb !=nil {return nil ,_ccgb ;};_ge .Log .Trace ("\u0020\u0049\u004e\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (streamObj .Stream ),streamObj .Stream );_ge .Log .Trace ("\u004f\u0055\u0054\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (_feea ),_feea );if _bggea .Predictor > 1{if _bggea .Predictor ==2{_ge .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_aef :=int (_bggea .Columns )*_bggea .Colors ;if _aef < 1{return []byte {},nil ;};_baef :=len (_feea )/_aef ;if len (_feea )%_aef !=0{_ge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");return nil ,_fe .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_feea ),_aef );};if _aef %_bggea .Colors !=0{return nil ,_fe .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_aef ,_bggea .Colors );};if _aef > len (_feea ){_ge .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_aef ,len (_feea ));return nil ,_b .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_ge .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_feea ),_feea );_efbg :=_cdc .NewBuffer (nil );for _bcaf :=0;_bcaf < _baef ;_bcaf ++{_aegb :=_feea [_aef *_bcaf :_aef *(_bcaf +1)];for _eabb :=_bggea .Colors ;_eabb < _aef ;_eabb ++{_aegb [_eabb ]=byte (int (_aegb [_eabb ]+_aegb [_eabb -_bggea .Colors ])%256);};_efbg .Write (_aegb );};_egee :=_efbg .Bytes ();_ge .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_egee ),_egee );return _egee ,nil ;}else if _bggea .Predictor >=10&&_bggea .Predictor <=15{_ge .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_gdgf :=int (_bggea .Columns *_bggea .Colors +1);if _gdgf < 1{return []byte {},nil ;};_caee :=len (_feea )/_gdgf ;if len (_feea )%_gdgf !=0{return nil ,_fe .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_feea ),_gdgf );};if _gdgf > len (_feea ){_ge .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_gdgf ,len (_feea ));return nil ,_b .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_fcc :=_cdc .NewBuffer (nil );_ge .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_bggea .Columns );_ge .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_feea ),_gdgf ,_caee );_eege :=make ([]byte ,_gdgf );for _cgb :=0;_cgb < _gdgf ;_cgb ++{_eege [_cgb ]=0;};for _bccc :=0;_bccc < _caee ;_bccc ++{_cbge :=_feea [_gdgf *_bccc :_gdgf *(_bccc +1)];_gdba :=_cbge [0];switch _gdba {case 0:case 1:for _cgf :=2;_cgf < _gdgf ;_cgf ++{_cbge [_cgf ]=byte (int (_cbge [_cgf ]+_cbge [_cgf -1])%256);};case 2:for _caff :=1;_caff < _gdgf ;_caff ++{_cbge [_caff ]=byte (int (_cbge [_caff ]+_eege [_caff ])%256);};default:_ge .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0066i\u006c\u0074\u0065\u0072\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_gdba );return nil ,_fe .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_gdba );};for _egdf :=0;_egdf < _gdgf ;_egdf ++{_eege [_egdf ]=_cbge [_egdf ];};_fcc .Write (_cbge [1:]);};_bcfd :=_fcc .Bytes ();return _bcfd ,nil ;}else {_ge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_bggea .Predictor );return nil ,_fe .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_bggea .Predictor );};};return _feea ,nil ;};func _adad (_edfa int )int {_dcedg :=_edfa >>(_fege -1);return (_edfa ^_dcedg )-_dcedg };

// PdfObjectNull represents the primitive PDF null object.
type PdfObjectNull struct{};

// DecodeStream decodes RunLengthEncoded stream object and give back decoded bytes.
func (_abf *RunLengthEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _abf .DecodeBytes (streamObj .Stream );};func _dca (_dad PdfObject )(int64 ,int64 ,error ){if _gee ,_gdg :=_dad .(*PdfIndirectObject );_gdg {return _gee .ObjectNumber ,_gee .GenerationNumber ,nil ;};if _bdd ,_bf :=_dad .(*PdfObjectStream );_bf {return _bdd .ObjectNumber ,_bdd .GenerationNumber ,nil ;};return 0,0,_b .New ("\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u002f\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062je\u0063\u0074");};func (_cg *PdfParser )lookupObjectViaOS (_ada int ,_aa int )(PdfObject ,error ){var _cae *_cdc .Reader ;var _bgb objectStream ;var _fee bool ;_bgb ,_fee =_cg ._cebfa [_ada ];if !_fee {_ea ,_eab :=_cg .LookupByNumber (_ada );if _eab !=nil {_ge .Log .Debug ("\u004d\u0069ss\u0069\u006e\u0067 \u006f\u0062\u006a\u0065ct \u0073tr\u0065\u0061\u006d\u0020\u0077\u0069\u0074h \u006e\u0075\u006d\u0062\u0065\u0072\u0020%\u0064",_ada );return nil ,_eab ;};_ed ,_be :=_ea .(*PdfObjectStream );if !_be {return nil ,_b .New ("i\u006e\u0076\u0061\u006cid\u0020o\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d");};if _cg ._ddfa !=nil &&!_cg ._ddfa .isDecrypted (_ed ){return nil ,_b .New ("\u006e\u0065\u0065\u0064\u0020\u0074\u006f\u0020\u0064\u0065\u0063r\u0079\u0070\u0074\u0020\u0074\u0068\u0065\u0020\u0073\u0074r\u0065\u0061\u006d");};_ffg :=_ed .PdfObjectDictionary ;_ge .Log .Trace ("\u0073o\u0020\u0064\u003a\u0020\u0025\u0073\n",_ffg .String ());_fa ,_be :=_ffg .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if !_be {_ge .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0061\u006c\u0077\u0061\u0079\u0073\u0020\u0068\u0061\u0076\u0065\u0020\u0061\u0020\u0054\u0079\u0070\u0065");return nil ,_b .New ("\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020T\u0079\u0070\u0065");};if _dc .ToLower (string (*_fa ))!="\u006f\u0062\u006a\u0073\u0074\u006d"{_ge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0074\u0079\u0070\u0065\u0020s\u0068\u0061\u006c\u006c\u0020\u0061\u006c\u0077\u0061\u0079\u0073 \u0062\u0065\u0020\u004f\u0062\u006a\u0053\u0074\u006d\u0020\u0021");return nil ,_b .New ("\u006f\u0062\u006a\u0065c\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0074y\u0070e\u0020\u0021\u003d\u0020\u004f\u0062\u006aS\u0074\u006d");};N ,_be :=_ffg .Get ("\u004e").(*PdfObjectInteger );if !_be {return nil ,_b .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u004e\u0020i\u006e\u0020\u0073\u0074\u0072\u0065\u0061m\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_gcc ,_be :=_ffg .Get ("\u0046\u0069\u0072s\u0074").(*PdfObjectInteger );if !_be {return nil ,_b .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0046\u0069\u0072\u0073\u0074\u0020i\u006e \u0073t\u0072e\u0061\u006d\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_ge .Log .Trace ("\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0073\u0020\u006eu\u006d\u0062\u0065\u0072\u0020\u006f\u0066 \u006f\u0062\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_fa ,*N );_ec ,_eab :=DecodeStream (_ed );if _eab !=nil {return nil ,_eab ;};_ge .Log .Trace ("D\u0065\u0063\u006f\u0064\u0065\u0064\u003a\u0020\u0025\u0073",_ec );_add :=_cg .GetFileOffset ();defer func (){_cg .SetFileOffset (_add )}();_cae =_cdc .NewReader (_ec );_cg ._addbb =_cbe .NewReader (_cae );_ge .Log .Trace ("\u0050a\u0072s\u0069\u006e\u0067\u0020\u006ff\u0066\u0073e\u0074\u0020\u006d\u0061\u0070");_cdb :=map[int ]int64 {};for _gdc :=0;_gdc < int (*N );_gdc ++{_cg .skipSpaces ();_bc ,_bca :=_cg .parseNumber ();if _bca !=nil {return nil ,_bca ;};_fd ,_ccf :=_bc .(*PdfObjectInteger );if !_ccf {return nil ,_b .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");};_cg .skipSpaces ();_bc ,_bca =_cg .parseNumber ();if _bca !=nil {return nil ,_bca ;};_cbb ,_ccf :=_bc .(*PdfObjectInteger );if !_ccf {return nil ,_b .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");};_ge .Log .Trace ("\u006f\u0062j\u0020\u0025\u0064 \u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0025\u0064",*_fd ,*_cbb );_cdb [int (*_fd )]=int64 (*_gcc +*_cbb );};_bgb =objectStream {N :int (*N ),_bb :_ec ,_aea :_cdb };_cg ._cebfa [_ada ]=_bgb ;}else {_bcc :=_cg .GetFileOffset ();defer func (){_cg .SetFileOffset (_bcc )}();_cae =_cdc .NewReader (_bgb ._bb );_cg ._addbb =_cbe .NewReader (_cae );};_gbg :=_bgb ._aea [_aa ];_ge .Log .Trace ("\u0041\u0043\u0054\u0055AL\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u005b\u0025\u0064\u005d\u0020\u003d\u0020%\u0064",_aa ,_gbg );_cae .Seek (_gbg ,_ef .SEEK_SET );_cg ._addbb =_cbe .NewReader (_cae );_af ,_ :=_cg ._addbb .Peek (100);_ge .Log .Trace ("\u004f\u0042\u004a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_af ));_gg ,_cbcc :=_cg .parseObject ();if _cbcc !=nil {_ge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c \u0074\u006f\u0020\u0072\u0065\u0061\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_cbcc );return nil ,_cbcc ;};if _gg ==nil {return nil ,_b .New ("o\u0062\u006a\u0065\u0063t \u0063a\u006e\u006e\u006f\u0074\u0020b\u0065\u0020\u006e\u0075\u006c\u006c");};_bgg :=PdfIndirectObject {};_bgg .ObjectNumber =int64 (_aa );_bgg .PdfObject =_gg ;return &_bgg ,nil ;};

// EncodeBytes JPX encodes the passed in slice of bytes.
func (_cfcc *JPXEncoder )EncodeBytes (data []byte )([]byte ,error ){_ge .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_cfcc .GetFilterName ());return data ,ErrNoJPXDecode ;};

// JPXEncoder implements JPX encoder/decoder (dummy, for now)
// FIXME: implement
type JPXEncoder struct{};

// MakeIndirectObject creates an PdfIndirectObject with a specified direct object PdfObject.
func MakeIndirectObject (obj PdfObject )*PdfIndirectObject {_ecede :=&PdfIndirectObject {};_ecede .PdfObject =obj ;return _ecede ;};func (_gff *ASCII85Encoder )base256Tobase85 (_abage uint32 )[5]byte {_ccfa :=[5]byte {0,0,0,0,0};_edcg :=_abage ;for _dfgb :=0;_dfgb < 5;_dfgb ++{_afdc :=uint32 (1);for _cba :=0;_cba < 4-_dfgb ;_cba ++{_afdc *=85;};_egbc :=_edcg /_afdc ;_edcg =_edcg %_afdc ;_ccfa [_dfgb ]=byte (_egbc );};return _ccfa ;};func (_cbad *PdfParser )repairSeekXrefMarker ()error {_daac ,_dgdf :=_cbad ._dceb .Seek (0,_ef .SEEK_END );if _dgdf !=nil {return _dgdf ;};_aeage :=_ff .MustCompile ("\u005cs\u0078\u0072\u0065\u0066\u005c\u0073*");var _fdbcc int64 ;var _fgba int64 =1000;for _fdbcc < _daac {if _daac <=(_fgba +_fdbcc ){_fgba =_daac -_fdbcc ;};_ ,_egaf :=_cbad ._dceb .Seek (-_fdbcc -_fgba ,_ef .SEEK_END );if _egaf !=nil {return _egaf ;};_ddag :=make ([]byte ,_fgba );_cbad ._dceb .Read (_ddag );_ge .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0078\u0072\u0065\u0066\u0020\u003a\u0020\u0022\u0025\u0073\u0022",string (_ddag ));_bgd :=_aeage .FindAllStringIndex (string (_ddag ),-1);if _bgd !=nil {_abbg :=_bgd [len (_bgd )-1];_ge .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_bgd );_cbad ._dceb .Seek (-_fdbcc -_fgba +int64 (_abbg [0]),_ef .SEEK_END );_cbad ._addbb =_cbe .NewReader (_cbad ._dceb );for {_fgde ,_ebdf :=_cbad ._addbb .Peek (1);if _ebdf !=nil {return _ebdf ;};_ge .Log .Trace ("\u0042\u003a\u0020\u0025\u0064\u0020\u0025\u0063",_fgde [0],_fgde [0]);if !IsWhiteSpace (_fgde [0]){break ;};_cbad ._addbb .Discard (1);};return nil ;};_ge .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");_fdbcc +=_fgba ;};_ge .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074a\u0062\u006c\u0065\u0020\u006d\u0061r\u006b\u0065\u0072\u0020\u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066o\u0075\u006e\u0064\u002e");return _b .New ("\u0078r\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0020");};

// ReadAtLeast reads at least n bytes into slice p.
// Returns the number of bytes read (should always be == n), and an error on failure.
func (_feebd *PdfParser )ReadAtLeast (p []byte ,n int )(int ,error ){_aadf :=n ;_acddd :=0;_dfee :=0;for _aadf > 0{_acdc ,_cebg :=_feebd ._addbb .Read (p [_acddd :]);if _cebg !=nil {_ge .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061d\u0069\u006e\u0067\u0020\u0028\u0025\u0064\u003b\u0025\u0064\u0029\u0020\u0025\u0073",_acdc ,_dfee ,_cebg .Error ());return _acddd ,_b .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065a\u0064\u0069\u006e\u0067");};_dfee ++;_acddd +=_acdc ;_aadf -=_acdc ;};return _acddd ,nil ;};func (_begc *JBIG2Image )toBitmap ()(_dgebf *_cbc .Bitmap ,_fgf error ){const _gbdg ="\u004a\u0042\u0049\u00472I\u006d\u0061\u0067\u0065\u002e\u0074\u006f\u0042\u0069\u0074\u006d\u0061\u0070";if _begc .Data ==nil {return nil ,_cc .Error (_gbdg ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");};if _begc .Width ==0||_begc .Height ==0{return nil ,_cc .Error (_gbdg ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");};if _begc .HasPadding {_dgebf ,_fgf =_cbc .NewWithData (_begc .Width ,_begc .Height ,_begc .Data );}else {_dgebf ,_fgf =_cbc .NewWithUnpaddedData (_begc .Width ,_begc .Height ,_begc .Data );};if _fgf !=nil {return nil ,_cc .Wrap (_fgf ,_gbdg ,"");};return _dgebf ,nil ;};

// JBIG2EncoderSettings contains the parameters and settings used by the JBIG2Encoder.
// Current version works only on JB2Generic compression.
type JBIG2EncoderSettings struct{

// FileMode defines if the jbig2 encoder should return full jbig2 file instead of
// shortened pdf mode. This adds the file header to the jbig2 definition.
FileMode bool ;

// Compression is the setting that defines the compression type used for encoding the page.
Compression JBIG2CompressionType ;

// DuplicatedLinesRemoval code generic region in a way such that if the lines are duplicated the encoder
// doesn't store it twice.
DuplicatedLinesRemoval bool ;

// DefaultPixelValue is the bit value initial for every pixel in the page.
DefaultPixelValue uint8 ;

// ResolutionX optional setting that defines the 'x' axis input image resolution - used for single page encoding.
ResolutionX int ;

// ResolutionY optional setting that defines the 'y' axis input image resolution - used for single page encoding.
ResolutionY int ;

// Threshold defines the threshold of the image correlation for
// non Generic compression.
// User only for JB2SymbolCorrelation and JB2SymbolRankHaus methods.
// Best results in range [0.7 - 0.98] - the less the better the compression would be
// but the more lossy.
// Default value: 0.95
Threshold float64 ;};

// Resolve resolves the reference and returns the indirect or stream object.
// If the reference cannot be resolved, a *PdfObjectNull object is returned.
func (_dccae *PdfObjectReference )Resolve ()PdfObject {if _dccae ._aaccf ==nil {return MakeNull ();};_eefd ,_ ,_dacd :=_dccae ._aaccf .resolveReference (_dccae );if _dacd !=nil {_ge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0072\u0065\u0073\u006f\u006cv\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065r\u0065n\u0063\u0065\u003a\u0020\u0025\u0076\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074",_dacd );return MakeNull ();};if _eefd ==nil {_ge .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0072\u0065\u0073ol\u0076\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065:\u0020\u006ei\u006c\u0020\u006fb\u006a\u0065\u0063\u0074\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u0061\u0020nu\u006c\u006c\u0020o\u0062\u006a\u0065\u0063\u0074");return MakeNull ();};return _eefd ;};

// Clear resets the array to an empty state.
func (_ecgc *PdfObjectArray )Clear (){_ecgc ._fbfcaa =[]PdfObject {}};var _bagb =_ff .MustCompile ("\u005e\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");var _gaaa =_ff .MustCompile ("\u005b\\\u0072\u005c\u006e\u005d\u005c\u0073\u002a\u0028\u0078\u0072\u0065f\u0029\u005c\u0073\u002a\u005b\u005c\u0072\u005c\u006e\u005d");

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_ccab *FlateEncoder )MakeDecodeParams ()PdfObject {if _ccab .Predictor > 1{_ecc :=MakeDict ();_ecc .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_ccab .Predictor )));if _ccab .BitsPerComponent !=8{_ecc .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_ccab .BitsPerComponent )));};if _ccab .Columns !=1{_ecc .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_ccab .Columns )));};if _ccab .Colors !=1{_ecc .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_ccab .Colors )));};return _ecc ;};return nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_addg *CCITTFaxEncoder )MakeDecodeParams ()PdfObject {_gfeg :=MakeDict ();_gfeg .Set ("\u004b",MakeInteger (int64 (_addg .K )));_gfeg .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_addg .Columns )));if _addg .BlackIs1 {_gfeg .Set ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031",MakeBool (_addg .BlackIs1 ));};if _addg .EncodedByteAlign {_gfeg .Set ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e",MakeBool (_addg .EncodedByteAlign ));};if _addg .EndOfLine &&_addg .K >=0{_gfeg .Set ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee",MakeBool (_addg .EndOfLine ));};if _addg .Rows !=0&&!_addg .EndOfBlock {_gfeg .Set ("\u0052\u006f\u0077\u0073",MakeInteger (int64 (_addg .Rows )));};if !_addg .EndOfBlock {_gfeg .Set ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b",MakeBool (_addg .EndOfBlock ));};if _addg .DamagedRowsBeforeError !=0{_gfeg .Set ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072",MakeInteger (int64 (_addg .DamagedRowsBeforeError )));};return _gfeg ;};

// GetString returns the *PdfObjectString represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetString (obj PdfObject )(_dadcd *PdfObjectString ,_abfgc bool ){_dadcd ,_abfgc =TraceToDirectObject (obj ).(*PdfObjectString );return _dadcd ,_abfgc ;};

// GetFilterName returns the name of the encoding filter.
func (_aac *ASCIIHexEncoder )GetFilterName ()string {return StreamEncodingFilterNameASCIIHex };

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_bdfg *LZWEncoder )MakeStreamDict ()*PdfObjectDictionary {_dcfb :=MakeDict ();_dcfb .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_bdfg .GetFilterName ()));_cec :=_bdfg .MakeDecodeParams ();if _cec !=nil {_dcfb .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_cec );};_dcfb .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (int64 (_bdfg .EarlyChange )));return _dcfb ;};

// MakeInteger creates a PdfObjectInteger from an int64.
func MakeInteger (val int64 )*PdfObjectInteger {_gfba :=PdfObjectInteger (val );return &_gfba };

// XrefTable represents the cross references in a PDF, i.e. the table of objects and information
// where to access within the PDF file.
type XrefTable struct{ObjectMap map[int ]XrefObject ;_eb []XrefObject ;};func _eg (_cad *_ac .FilterDict ,_bedf *PdfObjectDictionary )error {if _bbg ,_edbb :=_bedf .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_edbb {if _fge :=string (*_bbg );_fge !="C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"{_ge .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020C\u0046\u0020\u0064ic\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074e\u0072\u0029",_fge );};};_cea ,_gbd :=_bedf .Get ("\u0043\u0046\u004d").(*PdfObjectName );if !_gbd {return _fe .Errorf ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0028\u004e\u006f\u006e\u0065\u0029");};_cad .CFM =string (*_cea );if _beg ,_bbe :=_bedf .Get ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et").(*PdfObjectName );_bbe {_cad .AuthEvent =_gc .AuthEvent (*_beg );}else {_cad .AuthEvent =_gc .EventDocOpen ;};if _gdge ,_db :=_bedf .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );_db {_cad .Length =int (*_gdge );};return nil ;};

// Remove removes an element specified by key.
func (_dcag *PdfObjectDictionary )Remove (key PdfObjectName ){_ecddf :=-1;for _cfefd ,_ffdb :=range _dcag ._bdgg {if _ffdb ==key {_ecddf =_cfefd ;break ;};};if _ecddf >=0{_dcag ._bdgg =append (_dcag ._bdgg [:_ecddf ],_dcag ._bdgg [_ecddf +1:]...);delete (_dcag ._cbcd ,key );};};

// MakeFloat creates an PdfObjectFloat from a float64.
func MakeFloat (val float64 )*PdfObjectFloat {_feece :=PdfObjectFloat (val );return &_feece };

// GoImageToJBIG2 creates a binary image on the base of 'i' golang image.Image.
// If the image is not a black/white image then the function converts provided input into
// JBIG2Image with 1bpp. For non grayscale images the function performs the conversion to the grayscale temp image.
// Then it checks the value of the gray image value if it's within bounds of the black white threshold.
// This 'bwThreshold' value should be in range (0.0, 1.0). The threshold checks if the grayscale pixel (uint) value
// is greater or smaller than 'bwThreshold' * 255. Pixels inside the range will be white, and the others will be black.
// If the 'bwThreshold' is equal to -1.0 - JB2ImageAutoThreshold then it's value would be set on the base of
// it's histogram using Triangle method. For more information go to:
// 	https://www.mathworks.com/matlabcentral/fileexchange/28047-gray-image-thresholding-using-the-triangle-method
func GoImageToJBIG2 (i _ffa .Image ,bwThreshold float64 )(*JBIG2Image ,error ){const _gabfe ="\u0047\u006f\u0049\u006d\u0061\u0067\u0065\u0054\u006fJ\u0042\u0049\u0047\u0032";if i ==nil {return nil ,_cc .Error (_gabfe ,"i\u006d\u0061\u0067\u0065 '\u0069'\u0020\u006e\u006f\u0074\u0020d\u0065\u0066\u0069\u006e\u0065\u0064");};var (_fedff uint8 ;_fcdg _ca .Image ;_bcba error ;);if bwThreshold ==JB2ImageAutoThreshold {_fcdg ,_bcba =_ca .MonochromeConverter .Convert (i );}else if bwThreshold > 1.0||bwThreshold < 0.0{return nil ,_cc .Error (_gabfe ,"p\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074h\u0072\u0065\u0073\u0068\u006f\u006c\u0064 i\u0073\u0020\u006e\u006ft\u0020\u0069\u006e\u0020\u0061\u0020\u0072\u0061\u006ege\u0020\u007b0\u002e\u0030\u002c\u0020\u0031\u002e\u0030\u007d");}else {_fedff =uint8 (255*bwThreshold );_fcdg ,_bcba =_ca .MonochromeThresholdConverter (_fedff ).Convert (i );};if _bcba !=nil {return nil ,_bcba ;};return _eace (_fcdg ),nil ;};

// DecodeStream decodes a JPX encoded stream and returns the result as a
// slice of bytes.
func (_age *JPXEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_ge .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_age .GetFilterName ());return streamObj .Stream ,ErrNoJPXDecode ;};

// NewParserFromString is used for testing purposes.
func NewParserFromString (txt string )*PdfParser {_dbcaf :=_cdc .NewReader ([]byte (txt ));_afeb :=&PdfParser {ObjCache :objectCache {},_dceb :_dbcaf ,_addbb :_cbe .NewReader (_dbcaf ),_cded :int64 (len (txt )),_dfda :map[int64 ]bool {}};_afeb ._afag .ObjectMap =make (map[int ]XrefObject );return _afeb ;};

// MakeArrayFromIntegers64 creates an PdfObjectArray from a slice of int64s, where each array element
// is an PdfObjectInteger.
func MakeArrayFromIntegers64 (vals []int64 )*PdfObjectArray {_gcee :=MakeArray ();for _ ,_effbc :=range vals {_gcee .Append (MakeInteger (_effbc ));};return _gcee ;};

// MakeObjectStreams creates an PdfObjectStreams from a list of PdfObjects.
func MakeObjectStreams (objects ...PdfObject )*PdfObjectStreams {_cdga :=&PdfObjectStreams {};_cdga ._ccff =[]PdfObject {};for _ ,_becb :=range objects {_cdga ._ccff =append (_cdga ._ccff ,_becb );};return _cdga ;};func (_dcfbe *PdfParser )seekToEOFMarker (_dacf int64 )error {var _ecd int64 ;var _fdbc int64 =2048;for _ecd < _dacf -4{if _dacf <=(_fdbc +_ecd ){_fdbc =_dacf -_ecd ;};_ ,_bddf :=_dcfbe ._dceb .Seek (-_ecd -_fdbc ,_c .SeekEnd );if _bddf !=nil {return _bddf ;};_effb :=make ([]byte ,_fdbc );_dcfbe ._dceb .Read (_effb );_ge .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0045\u004f\u0046 \u006da\u0072\u006b\u0065\u0072\u003a\u0020\u0022%\u0073\u0022",string (_effb ));_fedfb :=_aafg .FindAllStringIndex (string (_effb ),-1);if _fedfb !=nil {_cggcg :=_fedfb [len (_fedfb )-1];_ge .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_fedfb );_dcfbe ._dceb .Seek (-_ecd -_fdbc +int64 (_cggcg [0]),_c .SeekEnd );return nil ;};_ge .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");_ecd +=_fdbc -4;};_ge .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006be\u0072 \u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u002e");return _b .New ("\u0045\u004f\u0046\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};

// WriteString outputs the object as it is to be written to file.
func (_eaab *PdfObjectInteger )WriteString ()string {return _g .FormatInt (int64 (*_eaab ),10)};

// DecodeBytes decodes a slice of LZW encoded bytes and returns the result.
func (_ece *LZWEncoder )DecodeBytes (encoded []byte )([]byte ,error ){var _gcaa _cdc .Buffer ;_accf :=_cdc .NewReader (encoded );var _bbd _c .ReadCloser ;if _ece .EarlyChange ==1{_bbd =_bg .NewReader (_accf ,_bg .MSB ,8);}else {_bbd =_fg .NewReader (_accf ,_fg .MSB ,8);};defer _bbd .Close ();_ ,_gebg :=_gcaa .ReadFrom (_bbd );if _gebg !=nil {return nil ,_gebg ;};return _gcaa .Bytes (),nil ;};const _bgbf ="\u0053\u0074\u0064C\u0046";func (_dcaf *PdfParser )resolveReference (_aabf *PdfObjectReference )(PdfObject ,bool ,error ){_fefa ,_ebdd :=_dcaf .ObjCache [int (_aabf .ObjectNumber )];if _ebdd {return _fefa ,true ,nil ;};_gedee ,_ddbd :=_dcaf .LookupByReference (*_aabf );if _ddbd !=nil {return nil ,false ,_ddbd ;};_dcaf .ObjCache [int (_aabf .ObjectNumber )]=_gedee ;return _gedee ,false ,nil ;};

// GetObjectNums returns a sorted list of object numbers of the PDF objects in the file.
func (_gcffd *PdfParser )GetObjectNums ()[]int {var _ecggb []int ;for _ ,_bfgb :=range _gcffd ._afag .ObjectMap {_ecggb =append (_ecggb ,_bfgb .ObjectNumber );};_f .Ints (_ecggb );return _ecggb ;};

// GetString is a helper for Get that returns a string value.
// Returns false if the key is missing or a value is not a string.
func (_aedg *PdfObjectDictionary )GetString (key PdfObjectName )(string ,bool ){_afbc ,_aaag :=_aedg ._cbcd [key ].(*PdfObjectString );if !_aaag {return "",false ;};return _afbc .Str (),true ;};

// GetNumberAsFloat returns the contents of `obj` as a float if it is an integer or float, or an
// error if it isn't.
func GetNumberAsFloat (obj PdfObject )(float64 ,error ){switch _adcf :=obj .(type ){case *PdfObjectFloat :return float64 (*_adcf ),nil ;case *PdfObjectInteger :return float64 (*_adcf ),nil ;};return 0,ErrNotANumber ;};

// CheckAccessRights checks access rights and permissions for a specified password. If either user/owner password is
// specified, full rights are granted, otherwise the access rights are specified by the Permissions flag.
//
// The bool flag indicates that the user can access and view the file.
// The AccessPermissions shows what access the user has for editing etc.
// An error is returned if there was a problem performing the authentication.
func (_adg *PdfParser )CheckAccessRights (password []byte )(bool ,_gc .Permissions ,error ){if _adg ._ddfa ==nil {return true ,_gc .PermOwner ,nil ;};return _adg ._ddfa .checkAccessRights (password );};

// NewEncoderFromStream creates a StreamEncoder based on the stream's dictionary.
func NewEncoderFromStream (streamObj *PdfObjectStream )(StreamEncoder ,error ){_efcc :=TraceToDirectObject (streamObj .PdfObjectDictionary .Get ("\u0046\u0069\u006c\u0074\u0065\u0072"));if _efcc ==nil {return NewRawEncoder (),nil ;};if _ ,_fcbf :=_efcc .(*PdfObjectNull );_fcbf {return NewRawEncoder (),nil ;};_bcbe ,_gfebf :=_efcc .(*PdfObjectName );if !_gfebf {_cbdf ,_dfgf :=_efcc .(*PdfObjectArray );if !_dfgf {return nil ,_fe .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006f\u0072 \u0041\u0072\u0072\u0061\u0079\u0020\u006fb\u006a\u0065\u0063\u0074");};if _cbdf .Len ()==0{return NewRawEncoder (),nil ;};if _cbdf .Len ()!=1{_bbfe ,_baed :=_deebe (streamObj );if _baed !=nil {_ge .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0063\u0072\u0065\u0061\u0074\u0069\u006e\u0067\u0020\u006d\u0075\u006c\u0074i\u0020\u0065\u006e\u0063\u006f\u0064\u0065r\u003a\u0020\u0025\u0076",_baed );return nil ,_baed ;};_ge .Log .Trace ("\u004d\u0075\u006c\u0074\u0069\u0020\u0065\u006e\u0063:\u0020\u0025\u0073\u000a",_bbfe );return _bbfe ,nil ;};_efcc =_cbdf .Get (0);_bcbe ,_dfgf =_efcc .(*PdfObjectName );if !_dfgf {return nil ,_fe .Errorf ("\u0066\u0069l\u0074\u0065\u0072\u0020a\u0072\u0072a\u0079\u0020\u006d\u0065\u006d\u0062\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006fb\u006a\u0065\u0063\u0074");};};switch *_bcbe {case StreamEncodingFilterNameFlate :return _fcg (streamObj ,nil );case StreamEncodingFilterNameLZW :return _aeab (streamObj ,nil );case StreamEncodingFilterNameDCT :return _bgef (streamObj ,nil );case StreamEncodingFilterNameRunLength :return _fgef (streamObj ,nil );case StreamEncodingFilterNameASCIIHex :return NewASCIIHexEncoder (),nil ;case StreamEncodingFilterNameASCII85 ,"\u0041\u0038\u0035":return NewASCII85Encoder (),nil ;case StreamEncodingFilterNameCCITTFax :return _bega (streamObj ,nil );case StreamEncodingFilterNameJBIG2 :return _eee (streamObj ,nil );case StreamEncodingFilterNameJPX :return NewJPXEncoder (),nil ;};_ge .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064\u0069\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006fd\u0021");return nil ,_fe .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064i\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006f\u0064\u0020\u0028\u0025\u0073\u0029",*_bcbe );};

// ParseNumber parses a numeric objects from a buffered stream.
// Section 7.3.3.
// Integer or Float.
//
// An integer shall be written as one or more decimal digits optionally
// preceded by a sign. The value shall be interpreted as a signed
// decimal integer and shall be converted to an integer object.
//
// A real value shall be written as one or more decimal digits with an
// optional sign and a leading, trailing, or embedded PERIOD (2Eh)
// (decimal point). The value shall be interpreted as a real number
// and shall be converted to a real object.
//
// Regarding exponential numbers: 7.3.3 Numeric Objects:
// A conforming writer shall not use the PostScript syntax for numbers
// with non-decimal radices (such as 16#FFFE) or in exponential format
// (such as 6.02E23).
// Nonetheless, we sometimes get numbers with exponential format, so
// we will support it in the reader (no confusion with other types, so
// no compromise).
func ParseNumber (buf *_cbe .Reader )(PdfObject ,error ){_edga :=false ;_gbeb :=true ;var _ffgbd _cdc .Buffer ;for {if _ge .Log .IsLogLevel (_ge .LogLevelTrace ){_ge .Log .Trace ("\u0050\u0061\u0072\u0073in\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0022\u0025\u0073\u0022",_ffgbd .String ());};_dcefc ,_baac :=buf .Peek (1);if _baac ==_c .EOF {break ;};if _baac !=nil {_ge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0025\u0073",_baac );return nil ,_baac ;};if _gbeb &&(_dcefc [0]=='-'||_dcefc [0]=='+'){_bcda ,_ :=buf .ReadByte ();_ffgbd .WriteByte (_bcda );_gbeb =false ;}else if IsDecimalDigit (_dcefc [0]){_gagf ,_ :=buf .ReadByte ();_ffgbd .WriteByte (_gagf );}else if _dcefc [0]=='.'{_fdebd ,_ :=buf .ReadByte ();_ffgbd .WriteByte (_fdebd );_edga =true ;}else if _dcefc [0]=='e'||_dcefc [0]=='E'{_acbc ,_ :=buf .ReadByte ();_ffgbd .WriteByte (_acbc );_edga =true ;_gbeb =true ;}else {break ;};};var _beaef PdfObject ;if _edga {_deebca ,_bafb :=_g .ParseFloat (_ffgbd .String (),64);if _bafb !=nil {_ge .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0025v\u0020\u0065\u0072\u0072\u003d\u0025v\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0030\u002e\u0020\u004fu\u0074\u0070u\u0074\u0020\u006d\u0061y\u0020\u0062\u0065\u0020\u0069n\u0063\u006f\u0072\u0072\u0065\u0063\u0074",_ffgbd .String (),_bafb );_deebca =0.0;_bafb =nil ;};_cdda :=PdfObjectFloat (_deebca );_beaef =&_cdda ;}else {_aegd ,_abfde :=_g .ParseInt (_ffgbd .String (),10,64);if _abfde !=nil {_ge .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0025\u0076\u0020\u0065\u0072\u0072\u003d%\u0076\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074 \u006d\u0061\u0079\u0020\u0062\u0065 \u0069\u006ec\u006f\u0072r\u0065c\u0074",_ffgbd .String (),_abfde );_aegd =0;_abfde =nil ;};_cebgd :=PdfObjectInteger (_aegd );_beaef =&_cebgd ;};return _beaef ,nil ;};

// Str returns the string value of the PdfObjectString. Defined in addition to String() function to clarify that
// this function returns the underlying string directly, whereas the String function technically could include
// debug info.
func (_abe *PdfObjectString )Str ()string {return _abe ._bccece };

// EncodeBytes encodes the image data using either Group3 or Group4 CCITT facsimile (fax) encoding.
// `data` is expected to be 1 color component, 1 byte per component.
func (_efab *CCITTFaxEncoder )EncodeBytes (data []byte )([]byte ,error ){var _egbcf [][]byte ;for _cbac :=0;_cbac < len (data );_cbac +=_efab .Columns {_afde :=make ([]byte ,_efab .Columns );_faad :=0;for _cgc :=0;_cgc < _efab .Columns ;_cgc ++{if data [_cbac +_cgc ]==255{_afde [_faad ]=1;}else {_afde [_faad ]=0;};_faad ++;};_egbcf =append (_egbcf ,_afde );};_bce :=&_dcc .Encoder {K :_efab .K ,Columns :_efab .Columns ,EndOfLine :_efab .EndOfLine ,EndOfBlock :_efab .EndOfBlock ,BlackIs1 :_efab .BlackIs1 ,DamagedRowsBeforeError :_efab .DamagedRowsBeforeError ,Rows :_efab .Rows ,EncodedByteAlign :_efab .EncodedByteAlign };return _bce .Encode (_egbcf ),nil ;};

// IsDelimiter checks if a character represents a delimiter.
func IsDelimiter (c byte )bool {return c =='('||c ==')'||c =='<'||c =='>'||c =='['||c ==']'||c =='{'||c =='}'||c =='/'||c =='%';};

// SetIfNotNil sets the dictionary's key -> val mapping entry -IF- val is not nil.
// Note that we take care to perform a type switch.  Otherwise if we would supply a nil value
// of another type, e.g. (PdfObjectArray*)(nil), then it would not be a PdfObject(nil) and thus
// would get set.
func (_ecdac *PdfObjectDictionary )SetIfNotNil (key PdfObjectName ,val PdfObject ){if val !=nil {switch _facca :=val .(type ){case *PdfObjectName :if _facca !=nil {_ecdac .Set (key ,val );};case *PdfObjectDictionary :if _facca !=nil {_ecdac .Set (key ,val );};case *PdfObjectStream :if _facca !=nil {_ecdac .Set (key ,val );};case *PdfObjectString :if _facca !=nil {_ecdac .Set (key ,val );};case *PdfObjectNull :if _facca !=nil {_ecdac .Set (key ,val );};case *PdfObjectInteger :if _facca !=nil {_ecdac .Set (key ,val );};case *PdfObjectArray :if _facca !=nil {_ecdac .Set (key ,val );};case *PdfObjectBool :if _facca !=nil {_ecdac .Set (key ,val );};case *PdfObjectFloat :if _facca !=nil {_ecdac .Set (key ,val );};case *PdfObjectReference :if _facca !=nil {_ecdac .Set (key ,val );};case *PdfIndirectObject :if _facca !=nil {_ecdac .Set (key ,val );};default:_ge .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",val );};};};

// GetFilterName returns the name of the encoding filter.
func (_fedf *FlateEncoder )GetFilterName ()string {return StreamEncodingFilterNameFlate };

// WriteString outputs the object as it is to be written to file.
func (_fdbb *PdfObjectDictionary )WriteString ()string {var _cdee _dc .Builder ;_cdee .WriteString ("\u003c\u003c");for _ ,_gdfb :=range _fdbb ._bdgg {_feacg :=_fdbb ._cbcd [_gdfb ];_cdee .WriteString (_gdfb .WriteString ());_cdee .WriteString ("\u0020");_cdee .WriteString (_feacg .WriteString ());};_cdee .WriteString ("\u003e\u003e");return _cdee .String ();};func (_aeg *FlateEncoder )postDecodePredict (_cbccb []byte )([]byte ,error ){if _aeg .Predictor > 1{if _aeg .Predictor ==2{_ge .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_ge .Log .Trace ("\u0043\u006f\u006c\u006f\u0072\u0073\u003a\u0020\u0025\u0064",_aeg .Colors );_geeg :=int (_aeg .Columns )*_aeg .Colors ;if _geeg < 1{return []byte {},nil ;};_cfe :=len (_cbccb )/_geeg ;if len (_cbccb )%_geeg !=0{_ge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");return nil ,_fe .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_cbccb ),_geeg );};if _geeg %_aeg .Colors !=0{return nil ,_fe .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_geeg ,_aeg .Colors );};if _geeg > len (_cbccb ){_ge .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_geeg ,len (_cbccb ));return nil ,_b .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_ge .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_cbccb ),_cbccb );_dfaa :=_cdc .NewBuffer (nil );for _aag :=0;_aag < _cfe ;_aag ++{_eeg :=_cbccb [_geeg *_aag :_geeg *(_aag +1)];for _cdd :=_aeg .Colors ;_cdd < _geeg ;_cdd ++{_eeg [_cdd ]+=_eeg [_cdd -_aeg .Colors ];};_dfaa .Write (_eeg );};_gbad :=_dfaa .Bytes ();_ge .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_gbad ),_gbad );return _gbad ,nil ;}else if _aeg .Predictor >=10&&_aeg .Predictor <=15{_ge .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_ccdc :=int (_aeg .Columns *_aeg .Colors +1);_fbed :=len (_cbccb )/_ccdc ;if len (_cbccb )%_ccdc !=0{return nil ,_fe .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_cbccb ),_ccdc );};if _ccdc > len (_cbccb ){_ge .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_ccdc ,len (_cbccb ));return nil ,_b .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_gcb :=_cdc .NewBuffer (nil );_ge .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_aeg .Columns );_ge .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_cbccb ),_ccdc ,_fbed );_feeg :=make ([]byte ,_ccdc );for _afcd :=0;_afcd < _ccdc ;_afcd ++{_feeg [_afcd ]=0;};_dceec :=_aeg .Colors ;for _agad :=0;_agad < _fbed ;_agad ++{_ebga :=_cbccb [_ccdc *_agad :_ccdc *(_agad +1)];_bgfg :=_ebga [0];switch _bgfg {case _gace :case _deebc :for _def :=1+_dceec ;_def < _ccdc ;_def ++{_ebga [_def ]+=_ebga [_def -_dceec ];};case _fgeb :for _efbd :=1;_efbd < _ccdc ;_efbd ++{_ebga [_efbd ]+=_feeg [_efbd ];};case _efaf :for _bffe :=1;_bffe < _dceec +1;_bffe ++{_ebga [_bffe ]+=_feeg [_bffe ]/2;};for _cgg :=_dceec +1;_cgg < _ccdc ;_cgg ++{_ebga [_cgg ]+=byte ((int (_ebga [_cgg -_dceec ])+int (_feeg [_cgg ]))/2);};case _gfeb :for _cgdc :=1;_cgdc < _ccdc ;_cgdc ++{var _abdc ,_bade ,_egebd byte ;_bade =_feeg [_cgdc ];if _cgdc >=_dceec +1{_abdc =_ebga [_cgdc -_dceec ];_egebd =_feeg [_cgdc -_dceec ];};_ebga [_cgdc ]+=_bbege (_abdc ,_bade ,_egebd );};default:_ge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029\u0020\u0040\u0072o\u0077\u0020\u0025\u0064",_bgfg ,_agad );return nil ,_fe .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_bgfg );};copy (_feeg ,_ebga );_gcb .Write (_ebga [1:]);};_ebba :=_gcb .Bytes ();return _ebba ,nil ;}else {_ge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_aeg .Predictor );return nil ,_fe .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_aeg .Predictor );};};return _cbccb ,nil ;};const _aeacd =10;

// PdfObjectDictionary represents the primitive PDF dictionary/map object.
type PdfObjectDictionary struct{_cbcd map[PdfObjectName ]PdfObject ;_bdgg []PdfObjectName ;_deda *PdfParser ;};

// String returns a string describing `ref`.
func (_aggg *PdfObjectReference )String ()string {return _fe .Sprintf ("\u0052\u0065\u0066\u0028\u0025\u0064\u0020\u0025\u0064\u0029",_aggg .ObjectNumber ,_aggg .GenerationNumber );};

// ToInt64Slice returns a slice of all array elements as an int64 slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_cffa *PdfObjectArray )ToInt64Slice ()([]int64 ,error ){var _bbeb []int64 ;for _ ,_aecc :=range _cffa .Elements (){if _fgaee ,_abceg :=_aecc .(*PdfObjectInteger );_abceg {_bbeb =append (_bbeb ,int64 (*_fgaee ));}else {return nil ,ErrTypeError ;};};return _bbeb ,nil ;};

// WriteString outputs the object as it is to be written to file.
func (_ccee *PdfIndirectObject )WriteString ()string {var _egede _dc .Builder ;_egede .WriteString (_g .FormatInt (_ccee .ObjectNumber ,10));_egede .WriteString ("\u0020\u0030\u0020\u0052");return _egede .String ();};

// UpdateParams updates the parameter values of the encoder.
func (_efde *MultiEncoder )UpdateParams (params *PdfObjectDictionary ){for _ ,_eeac :=range _efde ._cbdga {_eeac .UpdateParams (params );};};

// UpdateParams updates the parameter values of the encoder.
func (_bcgg *CCITTFaxEncoder )UpdateParams (params *PdfObjectDictionary ){if _egbcc ,_gbff :=GetNumberAsInt64 (params .Get ("\u004b"));_gbff ==nil {_bcgg .K =int (_egbcc );};if _dggf ,_edbd :=GetNumberAsInt64 (params .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));_edbd ==nil {_bcgg .Columns =int (_dggf );}else if _dggf ,_edbd =GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));_edbd ==nil {_bcgg .Columns =int (_dggf );};if _ddc ,_gdec :=GetNumberAsInt64 (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_gdec ==nil {_bcgg .BlackIs1 =_ddc > 0;}else {if _edbab ,_fcfd :=GetBoolVal (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_fcfd {_bcgg .BlackIs1 =_edbab ;}else {if _fgac ,_aeeca :=GetArray (params .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));_aeeca {_begd ,_febe :=_fgac .ToIntegerArray ();if _febe ==nil {_bcgg .BlackIs1 =_begd [0]==1&&_begd [1]==0;};};};};if _fcbe ,_bbgce :=GetNumberAsInt64 (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_bbgce ==nil {_bcgg .EncodedByteAlign =_fcbe > 0;}else {if _caea ,_eced :=GetBoolVal (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_eced {_bcgg .EncodedByteAlign =_caea ;};};if _fba ,_egge :=GetNumberAsInt64 (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_egge ==nil {_bcgg .EndOfLine =_fba > 0;}else {if _egdb ,_afabf :=GetBoolVal (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_afabf {_bcgg .EndOfLine =_egdb ;};};if _dadf ,_gffba :=GetNumberAsInt64 (params .Get ("\u0052\u006f\u0077\u0073"));_gffba ==nil {_bcgg .Rows =int (_dadf );}else if _dadf ,_gffba =GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));_gffba ==nil {_bcgg .Rows =int (_dadf );};if _egab ,_ddbg :=GetNumberAsInt64 (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_ddbg ==nil {_bcgg .EndOfBlock =_egab > 0;}else {if _cgad ,_cgfg :=GetBoolVal (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_cgfg {_bcgg .EndOfBlock =_cgad ;};};if _gea ,_eae :=GetNumberAsInt64 (params .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));_eae !=nil {_bcgg .DamagedRowsBeforeError =int (_gea );};};

// PdfObjectName represents the primitive PDF name object.
type PdfObjectName string ;

// Keys returns the list of keys in the dictionary.
// If `d` is nil returns a nil slice.
func (_efba *PdfObjectDictionary )Keys ()[]PdfObjectName {if _efba ==nil {return nil ;};return _efba ._bdgg ;};

// NewRunLengthEncoder makes a new run length encoder
func NewRunLengthEncoder ()*RunLengthEncoder {return &RunLengthEncoder {}};

// GetBoolVal returns the bool value within a *PdObjectBool represented by an PdfObject interface directly or indirectly.
// If the PdfObject does not represent a bool value, a default value of false is returned (found = false also).
func GetBoolVal (obj PdfObject )(_afdcg bool ,_dfdf bool ){_efbdg ,_dfdf :=TraceToDirectObject (obj ).(*PdfObjectBool );if _dfdf {return bool (*_efbdg ),true ;};return false ,false ;};

// DecodeStream decodes the stream containing CCITTFax encoded image data.
func (_fbee *CCITTFaxEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _fbee .DecodeBytes (streamObj .Stream );};

// GetNumberAsInt64 returns the contents of `obj` as an int64 if it is an integer or float, or an
// error if it isn't. This is for cases where expecting an integer, but some implementations
// actually store the number in a floating point format.
func GetNumberAsInt64 (obj PdfObject )(int64 ,error ){switch _ebcg :=obj .(type ){case *PdfObjectFloat :_ge .Log .Debug ("\u004e\u0075m\u0062\u0065\u0072\u0020\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0061\u0073\u0020\u0069\u006e\u0074e\u0067\u0065\u0072\u0020\u0077\u0061s\u0020\u0073\u0074\u006f\u0072\u0065\u0064\u0020\u0061\u0073\u0020\u0066\u006c\u006fa\u0074\u0020(\u0074\u0079\u0070\u0065 \u0063\u0061\u0073\u0074\u0069n\u0067\u0020\u0075\u0073\u0065\u0064\u0029");return int64 (*_ebcg ),nil ;case *PdfObjectInteger :return int64 (*_ebcg ),nil ;};return 0,ErrNotANumber ;};

// String returns a string describing `null`.
func (_geae *PdfObjectNull )String ()string {return "\u006e\u0075\u006c\u006c"};

// String returns a string describing `d`.
func (_eaec *PdfObjectDictionary )String ()string {var _fdaaa _dc .Builder ;_fdaaa .WriteString ("\u0044\u0069\u0063t\u0028");for _ ,_edef :=range _eaec ._bdgg {_addf :=_eaec ._cbcd [_edef ];_fdaaa .WriteString ("\u0022"+_edef .String ()+"\u0022\u003a\u0020");_fdaaa .WriteString (_addf .String ());_fdaaa .WriteString ("\u002c\u0020");};_fdaaa .WriteString ("\u0029");return _fdaaa .String ();};func (_bcd *PdfCrypt )newEncryptDict ()*PdfObjectDictionary {_eaf :=MakeDict ();_eaf .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName ("\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"));_eaf .Set ("\u0056",MakeInteger (int64 (_bcd ._ddg .V )));_eaf .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_bcd ._ddg .Length )));return _eaf ;};

// LookupByReference looks up a PdfObject by a reference.
func (_gab *PdfParser )LookupByReference (ref PdfObjectReference )(PdfObject ,error ){_ge .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0075\u0070\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0025\u0073",ref .String ());return _gab .LookupByNumber (int (ref .ObjectNumber ));};var _agedg =_ff .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064\u002b)\u005c\u0073\u002a\u0024");

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_ggba *CCITTFaxEncoder )MakeStreamDict ()*PdfObjectDictionary {_bbgc :=MakeDict ();_bbgc .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_ggba .GetFilterName ()));_fged :=_ggba .MakeDecodeParams ();if _fged !=nil {_bbgc .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_fged );};return _bbgc ;};

// ReadBytesAt reads byte content at specific offset and length within the PDF.
func (_gdeg *PdfParser )ReadBytesAt (offset ,len int64 )([]byte ,error ){_egbcca :=_gdeg .GetFileOffset ();_ ,_egca :=_gdeg ._dceb .Seek (offset ,_c .SeekStart );if _egca !=nil {return nil ,_egca ;};_aaac :=make ([]byte ,len );_ ,_egca =_c .ReadAtLeast (_gdeg ._dceb ,_aaac ,int (len ));if _egca !=nil {return nil ,_egca ;};_gdeg .SetFileOffset (_egbcca );return _aaac ,nil ;};

// MultiEncoder supports serial encoding.
type MultiEncoder struct{_cbdga []StreamEncoder };func _eag (_bgf int )cryptFilters {return cryptFilters {_bgbf :_ac .NewFilterV2 (_bgf )}};

// String returns a string describing `streams`.
func (_aaaf *PdfObjectStreams )String ()string {return _fe .Sprintf ("\u004f\u0062j\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0025\u0064",_aaaf .ObjectNumber );};

// String returns a string describing `ind`.
func (_fecdb *PdfIndirectObject )String ()string {return _fe .Sprintf ("\u0049\u004f\u0062\u006a\u0065\u0063\u0074\u003a\u0025\u0064",(*_fecdb ).ObjectNumber );};

// RunLengthEncoder represents Run length encoding.
type RunLengthEncoder struct{};

// GetXrefOffset returns the offset of the xref table.
func (_ced *PdfParser )GetXrefOffset ()int64 {return _ced ._bced };

// EncodeBytes encodes the passed in slice of bytes by passing it through the
// EncodeBytes method of the underlying encoders.
func (_egae *MultiEncoder )EncodeBytes (data []byte )([]byte ,error ){_acfa :=data ;var _dace error ;for _gede :=len (_egae ._cbdga )-1;_gede >=0;_gede --{_aeac :=_egae ._cbdga [_gede ];_acfa ,_dace =_aeac .EncodeBytes (_acfa );if _dace !=nil {return nil ,_dace ;};};return _acfa ,nil ;};

// Append appends PdfObject(s) to the array.
func (_badf *PdfObjectArray )Append (objects ...PdfObject ){if _badf ==nil {_ge .Log .Debug ("\u0057\u0061\u0072\u006e\u0020\u002d\u0020\u0041\u0074\u0074\u0065\u006d\u0070t\u0020\u0074\u006f\u0020\u0061\u0070p\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020a\u0072\u0072\u0061\u0079");return ;};if _badf ._fbfcaa ==nil {_badf ._fbfcaa =[]PdfObject {};};for _ ,_gbfc :=range objects {_badf ._fbfcaa =append (_badf ._fbfcaa ,_gbfc );};};var (ErrUnsupportedEncodingParameters =_b .New ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074\u0065\u0072\u0073");ErrNoCCITTFaxDecode =_b .New ("\u0043\u0043I\u0054\u0054\u0046\u0061\u0078\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");ErrNoJBIG2Decode =_b .New ("\u004a\u0042\u0049\u0047\u0032\u0044\u0065c\u006f\u0064\u0065 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");ErrNoJPXDecode =_b .New ("\u004a\u0050\u0058\u0044\u0065c\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020i\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");ErrNoPdfVersion =_b .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");ErrTypeError =_b .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");ErrRangeError =_b .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");ErrNotSupported =_b .New ("\u0066\u0065\u0061t\u0075\u0072\u0065\u0020n\u006f\u0074\u0020\u0063\u0075\u0072\u0072e\u006e\u0074\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");ErrNotANumber =_b .New ("\u006e\u006f\u0074 \u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072"););

// RawEncoder implements Raw encoder/decoder (no encoding, pass through)
type RawEncoder struct{};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_dbbb *RunLengthEncoder )MakeStreamDict ()*PdfObjectDictionary {_bgbe :=MakeDict ();_bgbe .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_dbbb .GetFilterName ()));return _bgbe ;};

// JBIG2CompressionType defines the enum compression type used by the JBIG2Encoder.
type JBIG2CompressionType int ;func _eagge (_dgeg PdfObject ,_dfccb int )PdfObject {if _dfccb > _aeacd {_ge .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_aeacd );return MakeNull ();};switch _faadb :=_dgeg .(type ){case *PdfIndirectObject :_dgeg =_eagge ((*_faadb ).PdfObject ,_dfccb +1);case *PdfObjectArray :for _bcge ,_bdgd :=range (*_faadb )._fbfcaa {(*_faadb )._fbfcaa [_bcge ]=_eagge (_bdgd ,_dfccb +1);};case *PdfObjectDictionary :for _abgag ,_bcef :=range (*_faadb )._cbcd {(*_faadb )._cbcd [_abgag ]=_eagge (_bcef ,_dfccb +1);};_f .Slice ((*_faadb )._bdgg ,func (_bgefe ,_eeeff int )bool {return (*_faadb )._bdgg [_bgefe ]< (*_faadb )._bdgg [_eeeff ]});};return _dgeg ;};func _adba (_agcd _c .ReadSeeker ,_egged int64 )(*offsetReader ,error ){_gacb :=&offsetReader {_cbfa :_agcd ,_bada :_egged };_ ,_cbfb :=_gacb .Seek (0,_c .SeekStart );return _gacb ,_cbfb ;};func _fbf (_geb *_gc .StdEncryptDict ,_bggf *PdfObjectDictionary ){_bggf .Set ("\u0052",MakeInteger (int64 (_geb .R )));_bggf .Set ("\u0050",MakeInteger (int64 (_geb .P )));_bggf .Set ("\u004f",MakeStringFromBytes (_geb .O ));_bggf .Set ("\u0055",MakeStringFromBytes (_geb .U ));if _geb .R >=5{_bggf .Set ("\u004f\u0045",MakeStringFromBytes (_geb .OE ));_bggf .Set ("\u0055\u0045",MakeStringFromBytes (_geb .UE ));_bggf .Set ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061",MakeBool (_geb .EncryptMetadata ));if _geb .R > 5{_bggf .Set ("\u0050\u0065\u0072m\u0073",MakeStringFromBytes (_geb .Perms ));};};};

// EncodeBytes implements support for LZW encoding.  Currently not supporting predictors (raw compressed data only).
// Only supports the Early change = 1 algorithm (compress/lzw) as the other implementation
// does not have a write method.
// TODO: Consider refactoring compress/lzw to allow both.
func (_cdegf *LZWEncoder )EncodeBytes (data []byte )([]byte ,error ){if _cdegf .Predictor !=1{return nil ,_fe .Errorf ("\u004c\u005aW \u0050\u0072\u0065d\u0069\u0063\u0074\u006fr =\u00201 \u006f\u006e\u006c\u0079\u0020\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0079e\u0074");};if _cdegf .EarlyChange ==1{return nil ,_fe .Errorf ("\u004c\u005a\u0057\u0020\u0045\u0061\u0072\u006c\u0079\u0020\u0043\u0068\u0061n\u0067\u0065\u0020\u003d\u0020\u0030 \u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0079\u0065\u0074");};var _gadg _cdc .Buffer ;_aefb :=_fg .NewWriter (&_gadg ,_fg .MSB ,8);_aefb .Write (data );_aefb .Close ();return _gadg .Bytes (),nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_fce *RunLengthEncoder )UpdateParams (params *PdfObjectDictionary ){};

// LZWEncoder provides LZW encoding/decoding functionality.
type LZWEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Colors int ;

// LZW algorithm setting.
EarlyChange int ;};

// XrefObject defines a cross reference entry which is a map between object number (with generation number) and the
// location of the actual object, either as a file offset (xref table entry), or as a location within an xref
// stream object (xref object stream).
type XrefObject struct{XType xrefType ;ObjectNumber int ;Generation int ;

// For normal xrefs (defined by OFFSET)
Offset int64 ;

// For xrefs to object streams.
OsObjNumber int ;OsObjIndex int ;};

// UpdateParams updates the parameter values of the encoder.
func (_dcg *LZWEncoder )UpdateParams (params *PdfObjectDictionary ){_ddb ,_afab :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _afab ==nil {_dcg .Predictor =int (_ddb );};_efd ,_afab :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _afab ==nil {_dcg .BitsPerComponent =int (_efd );};_fcdd ,_afab :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _afab ==nil {_dcg .Columns =int (_fcdd );};_cbege ,_afab :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _afab ==nil {_dcg .Colors =int (_cbege );};_addb ,_afab :=GetNumberAsInt64 (params .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065"));if _afab ==nil {_dcg .EarlyChange =int (_addb );};};

// StreamEncoder represents the interface for all PDF stream encoders.
type StreamEncoder interface{GetFilterName ()string ;MakeDecodeParams ()PdfObject ;MakeStreamDict ()*PdfObjectDictionary ;UpdateParams (_dae *PdfObjectDictionary );EncodeBytes (_fddb []byte )([]byte ,error );DecodeBytes (_acccd []byte )([]byte ,error );DecodeStream (_gbdec *PdfObjectStream )([]byte ,error );};

// WriteString outputs the object as it is to be written to file.
func (_dada *PdfObjectString )WriteString ()string {var _dgebg _cdc .Buffer ;if _dada ._edcb {_egag :=_gd .EncodeToString (_dada .Bytes ());_dgebg .WriteString ("\u003c");_dgebg .WriteString (_egag );_dgebg .WriteString ("\u003e");return _dgebg .String ();};_bdcg :=map[byte ]string {'\n':"\u005c\u006e",'\r':"\u005c\u0072",'\t':"\u005c\u0074",'\b':"\u005c\u0062",'\f':"\u005c\u0066",'(':"\u005c\u0028",')':"\u005c\u0029",'\\':"\u005c\u005c"};_dgebg .WriteString ("\u0028");for _cgcec :=0;_cgcec < len (_dada ._bccece );_cgcec ++{_dcfd :=_dada ._bccece [_cgcec ];if _fade ,_bcdc :=_bdcg [_dcfd ];_bcdc {_dgebg .WriteString (_fade );}else {_dgebg .WriteByte (_dcfd );};};_dgebg .WriteString ("\u0029");return _dgebg .String ();};

// PdfObjectStreams represents the primitive PDF object streams.
// 7.5.7 Object Streams (page 45).
type PdfObjectStreams struct{PdfObjectReference ;_ccff []PdfObject ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on the current encoder settings.
func (_cagc *JBIG2Encoder )MakeDecodeParams ()PdfObject {return MakeDict ()};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_eaba *MultiEncoder )MakeStreamDict ()*PdfObjectDictionary {_geccg :=MakeDict ();_geccg .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",_eaba .GetFilterArray ());for _ ,_fad :=range _eaba ._cbdga {_deag :=_fad .MakeStreamDict ();for _ ,_geegb :=range _deag .Keys (){_abge :=_deag .Get (_geegb );if _geegb !="\u0046\u0069\u006c\u0074\u0065\u0072"&&_geegb !="D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"{_geccg .Set (_geegb ,_abge );};};};_caef :=_eaba .MakeDecodeParams ();if _caef !=nil {_geccg .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_caef );};return _geccg ;};

// Set sets the PdfObject at index i of the array. An error is returned if the index is outside bounds.
func (_gfbf *PdfObjectArray )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_gfbf ._fbfcaa ){return _b .New ("\u006f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_gfbf ._fbfcaa [i ]=obj ;return nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_aggab *FlateEncoder )UpdateParams (params *PdfObjectDictionary ){_ggc ,_bfgc :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _bfgc ==nil {_aggab .Predictor =int (_ggc );};_gge ,_bfgc :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _bfgc ==nil {_aggab .BitsPerComponent =int (_gge );};_accg ,_bfgc :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _bfgc ==nil {_aggab .Columns =int (_accg );};_dbf ,_bfgc :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _bfgc ==nil {_aggab .Colors =int (_dbf );};};func _aacb (_ddfae ,_agggf PdfObject ,_fagge int )bool {if _fagge > _aeacd {_ge .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_aeacd );return false ;};if _ddfae ==nil &&_agggf ==nil {return true ;}else if _ddfae ==nil ||_agggf ==nil {return false ;};if _ad .TypeOf (_ddfae )!=_ad .TypeOf (_agggf ){return false ;};switch _dbag :=_ddfae .(type ){case *PdfObjectNull ,*PdfObjectReference :return true ;case *PdfObjectName :return *_dbag ==*(_agggf .(*PdfObjectName ));case *PdfObjectString :return *_dbag ==*(_agggf .(*PdfObjectString ));case *PdfObjectInteger :return *_dbag ==*(_agggf .(*PdfObjectInteger ));case *PdfObjectBool :return *_dbag ==*(_agggf .(*PdfObjectBool ));case *PdfObjectFloat :return *_dbag ==*(_agggf .(*PdfObjectFloat ));case *PdfIndirectObject :return _aacb (TraceToDirectObject (_ddfae ),TraceToDirectObject (_agggf ),_fagge +1);case *PdfObjectArray :_eebb :=_agggf .(*PdfObjectArray );if len ((*_dbag )._fbfcaa )!=len ((*_eebb )._fbfcaa ){return false ;};for _ebcf ,_eaca :=range (*_dbag )._fbfcaa {if !_aacb (_eaca ,(*_eebb )._fbfcaa [_ebcf ],_fagge +1){return false ;};};return true ;case *PdfObjectDictionary :_ggce :=_agggf .(*PdfObjectDictionary );_bgbffb ,_baec :=(*_dbag )._cbcd ,(*_ggce )._cbcd ;if len (_bgbffb )!=len (_baec ){return false ;};for _fdge ,_fggc :=range _bgbffb {_bgbed ,_bfdc :=_baec [_fdge ];if !_bfdc ||!_aacb (_fggc ,_bgbed ,_fagge +1){return false ;};};return true ;case *PdfObjectStream :_cegg :=_agggf .(*PdfObjectStream );return _aacb ((*_dbag ).PdfObjectDictionary ,(*_cegg ).PdfObjectDictionary ,_fagge +1);default:_ge .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",_ddfae );};return false ;};const (DefaultJPEGQuality =75;);

// GetStringVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetStringVal (obj PdfObject )(_fbdd string ,_degb bool ){_dfccf ,_degb :=TraceToDirectObject (obj ).(*PdfObjectString );if _degb {return _dfccf .Str (),true ;};return ;};

// DecodeBytes decodes a byte slice from Run length encoding.
//
// 7.4.5 RunLengthDecode Filter
// The RunLengthDecode filter decodes data that has been encoded in a simple byte-oriented format based on run length.
// The encoded data shall be a sequence of runs, where each run shall consist of a length byte followed by 1 to 128
// bytes of data. If the length byte is in the range 0 to 127, the following length + 1 (1 to 128) bytes shall be
// copied literally during decompression. If length is in the range 129 to 255, the following single byte shall be
// copied 257 - length (2 to 128) times during decompression. A length value of 128 shall denote EOD.
func (_bebaa *RunLengthEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_bcbbg :=_cdc .NewReader (encoded );var _feeb []byte ;for {_agbe ,_gfb :=_bcbbg .ReadByte ();if _gfb !=nil {return nil ,_gfb ;};if _agbe > 128{_fgcg ,_gdbd :=_bcbbg .ReadByte ();if _gdbd !=nil {return nil ,_gdbd ;};for _gdcd :=0;_gdcd < 257-int (_agbe );_gdcd ++{_feeb =append (_feeb ,_fgcg );};}else if _agbe < 128{for _dag :=0;_dag < int (_agbe )+1;_dag ++{_aaef ,_fbeg :=_bcbbg .ReadByte ();if _fbeg !=nil {return nil ,_fbeg ;};_feeb =append (_feeb ,_aaef );};}else {break ;};};return _feeb ,nil ;};

// GetCrypter returns the PdfCrypt instance which has information about the PDFs encryption.
func (_gbdb *PdfParser )GetCrypter ()*PdfCrypt {return _gbdb ._ddfa };

// WriteString outputs the object as it is to be written to file.
func (_bead *PdfObjectFloat )WriteString ()string {return _g .FormatFloat (float64 (*_bead ),'f',-1,64);};const (_gace =0;_deebc =1;_fgeb =2;_efaf =3;_gfeb =4;);

// DecodeStream decodes a multi-encoded stream by passing it through the
// DecodeStream method of the underlying encoders.
func (_cfac *MultiEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _cfac .DecodeBytes (streamObj .Stream );};func _afdea (_cbgd PdfObject ,_gcgfd int ,_fdcf map[PdfObject ]struct{})error {_ge .Log .Trace ("\u0054\u0072\u0061\u0076\u0065\u0072s\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0064\u0061\u0074\u0061 \u0028\u0064\u0065\u0070\u0074\u0068\u0020=\u0020\u0025\u0064\u0029",_gcgfd );if _ ,_abcb :=_fdcf [_cbgd ];_abcb {_ge .Log .Trace ("-\u0041\u006c\u0072\u0065ad\u0079 \u0074\u0072\u0061\u0076\u0065r\u0073\u0065\u0064\u002e\u002e\u002e");return nil ;};_fdcf [_cbgd ]=struct{}{};switch _eegeb :=_cbgd .(type ){case *PdfIndirectObject :_cece :=_eegeb ;_ge .Log .Trace ("\u0069\u006f\u003a\u0020\u0025\u0073",_cece );_ge .Log .Trace ("\u002d\u0020\u0025\u0073",_cece .PdfObject );return _afdea (_cece .PdfObject ,_gcgfd +1,_fdcf );case *PdfObjectStream :_bfce :=_eegeb ;return _afdea (_bfce .PdfObjectDictionary ,_gcgfd +1,_fdcf );case *PdfObjectDictionary :_bcac :=_eegeb ;_ge .Log .Trace ("\u002d\u0020\u0064\u0069\u0063\u0074\u003a\u0020\u0025\u0073",_bcac );for _ ,_dfggg :=range _bcac .Keys (){_afebe :=_bcac .Get (_dfggg );if _aggbb ,_cbefe :=_afebe .(*PdfObjectReference );_cbefe {_cbbd :=_aggbb .Resolve ();_bcac .Set (_dfggg ,_cbbd );_ffea :=_afdea (_cbbd ,_gcgfd +1,_fdcf );if _ffea !=nil {return _ffea ;};}else {_efef :=_afdea (_afebe ,_gcgfd +1,_fdcf );if _efef !=nil {return _efef ;};};};return nil ;case *PdfObjectArray :_gdbac :=_eegeb ;_ge .Log .Trace ("-\u0020\u0061\u0072\u0072\u0061\u0079\u003a\u0020\u0025\u0073",_gdbac );for _baffb ,_eaaaa :=range _gdbac .Elements (){if _febfe ,_begde :=_eaaaa .(*PdfObjectReference );_begde {_dgbb :=_febfe .Resolve ();_gdbac .Set (_baffb ,_dgbb );_cddcg :=_afdea (_dgbb ,_gcgfd +1,_fdcf );if _cddcg !=nil {return _cddcg ;};}else {_gegc :=_afdea (_eaaaa ,_gcgfd +1,_fdcf );if _gegc !=nil {return _gegc ;};};};return nil ;case *PdfObjectReference :_ge .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020T\u0072\u0061\u0063\u0069\u006e\u0067\u0020\u0061\u0020r\u0065\u0066\u0065r\u0065n\u0063\u0065\u0021");return _b .New ("\u0065r\u0072\u006f\u0072\u0020t\u0072\u0061\u0063\u0069\u006eg\u0020a\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");};return nil ;};

// ResolveReferencesDeep recursively traverses through object `o`, looking up and replacing
// references with indirect objects.
// Optionally a map of already deep-resolved objects can be provided via `traversed`. The `traversed` map
// is updated while traversing the objects to avoid traversing same objects multiple times.
func ResolveReferencesDeep (o PdfObject ,traversed map[PdfObject ]struct{})error {if traversed ==nil {traversed =map[PdfObject ]struct{}{};};return _afdea (o ,0,traversed );};

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_eea *FlateEncoder )EncodeBytes (data []byte )([]byte ,error ){if _eea .Predictor !=1&&_eea .Predictor !=11{_ge .Log .Debug ("E\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0046\u006c\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065r\u0020P\u0072\u0065\u0064\u0069c\u0074\u006fr\u0020\u003d\u0020\u0031\u002c\u0020\u0031\u0031\u0020\u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");return nil ,ErrUnsupportedEncodingParameters ;};if _eea .Predictor ==11{_egde :=int (_eea .Columns );_baag :=len (data )/_egde ;if len (data )%_egde !=0{_ge .Log .Error ("\u0049n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");return nil ,_b .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");};_effc :=_cdc .NewBuffer (nil );_fdag :=make ([]byte ,_egde );for _gcfe :=0;_gcfe < _baag ;_gcfe ++{_fdc :=data [_egde *_gcfe :_egde *(_gcfe +1)];_fdag [0]=_fdc [0];for _ffgc :=1;_ffgc < _egde ;_ffgc ++{_fdag [_ffgc ]=byte (int (_fdc [_ffgc ]-_fdc [_ffgc -1])%256);};_effc .WriteByte (1);_effc .Write (_fdag );};data =_effc .Bytes ();};var _geg _cdc .Buffer ;_bcce :=_e .NewWriter (&_geg );_bcce .Write (data );_bcce .Close ();return _geg .Bytes (),nil ;};type xrefType int ;

// IsPrintable checks if a character is printable.
// Regular characters that are outside the range EXCLAMATION MARK(21h)
// (!) to TILDE (7Eh) (~) should be written using the hexadecimal notation.
func IsPrintable (c byte )bool {return 0x21<=c &&c <=0x7E};

// MakeEncodedString creates a PdfObjectString with encoded content, which can be either
// UTF-16BE or PDFDocEncoding depending on whether `utf16BE` is true or false respectively.
func MakeEncodedString (s string ,utf16BE bool )*PdfObjectString {if utf16BE {var _bdfdb _cdc .Buffer ;_bdfdb .Write ([]byte {0xFE,0xFF});_bdfdb .WriteString (_ga .StringToUTF16 (s ));return &PdfObjectString {_bccece :_bdfdb .String (),_edcb :true };};return &PdfObjectString {_bccece :string (_ga .StringToPDFDocEncoding (s )),_edcb :false };};

// Get returns the PdfObject corresponding to the specified key.
// Returns a nil value if the key is not set.
func (_ddead *PdfObjectDictionary )Get (key PdfObjectName )PdfObject {_bbfa ,_cebfe :=_ddead ._cbcd [key ];if !_cebfe {return nil ;};return _bbfa ;};func (_gbfa *PdfParser )parseArray ()(*PdfObjectArray ,error ){_aadfc :=MakeArray ();_gbfa ._addbb .ReadByte ();for {_gbfa .skipSpaces ();_dgdg ,_cbda :=_gbfa ._addbb .Peek (1);if _cbda !=nil {return _aadfc ,_cbda ;};if _dgdg [0]==']'{_gbfa ._addbb .ReadByte ();break ;};_ebab ,_cbda :=_gbfa .parseObject ();if _cbda !=nil {return _aadfc ,_cbda ;};_aadfc .Append (_ebab );};return _aadfc ,nil ;};

// SetFileOffset sets the file to an offset position and resets buffer.
func (_dbfe *PdfParser )SetFileOffset (offset int64 ){if offset < 0{offset =0;};_dbfe ._dceb .Seek (offset ,_c .SeekStart );_dbfe ._addbb =_cbe .NewReader (_dbfe ._dceb );};

// GetXrefTable returns the PDFs xref table.
func (_eebe *PdfParser )GetXrefTable ()XrefTable {return _eebe ._afag };

// NewFlateEncoder makes a new flate encoder with default parameters, predictor 1 and bits per component 8.
func NewFlateEncoder ()*FlateEncoder {_efec :=&FlateEncoder {};_efec .Predictor =1;_efec .BitsPerComponent =8;_efec .Colors =1;_efec .Columns =1;return _efec ;};func (_fdgg *PdfParser )skipComments ()error {if _ ,_ebaf :=_fdgg .skipSpaces ();_ebaf !=nil {return _ebaf ;};_gbfd :=true ;for {_cfad ,_bdg :=_fdgg ._addbb .Peek (1);if _bdg !=nil {_ge .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_bdg .Error ());return _bdg ;};if _gbfd &&_cfad [0]!='%'{return nil ;};_gbfd =false ;if (_cfad [0]!='\r')&&(_cfad [0]!='\n'){_fdgg ._addbb .ReadByte ();}else {break ;};};return _fdgg .skipComments ();};

// DecodeBytes decodes a multi-encoded slice of bytes by passing it through the
// DecodeBytes method of the underlying encoders.
func (_aacc *MultiEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_acdb :=encoded ;var _fddf error ;for _ ,_faaa :=range _aacc ._cbdga {_ge .Log .Trace ("\u004du\u006c\u0074i\u0020\u0045\u006e\u0063o\u0064\u0065\u0072 \u0044\u0065\u0063\u006f\u0064\u0065\u003a\u0020\u0041pp\u006c\u0079\u0069n\u0067\u0020F\u0069\u006c\u0074\u0065\u0072\u003a \u0025\u0076 \u0025\u0054",_faaa ,_faaa );_acdb ,_fddf =_faaa .DecodeBytes (_acdb );if _fddf !=nil {return nil ,_fddf ;};};return _acdb ,nil ;};

// String returns a descriptive information string about the encryption method used.
func (_dcec *PdfCrypt )String ()string {if _dcec ==nil {return "";};_ab :=_dcec ._ddg .Filter +"\u0020\u002d\u0020";if _dcec ._ddg .V ==0{_ab +="\u0055\u006e\u0064\u006fcu\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0061\u006c\u0067\u006f\u0072\u0069\u0074h\u006d";}else if _dcec ._ddg .V ==1{_ab +="\u0052\u0043\u0034:\u0020\u0034\u0030\u0020\u0062\u0069\u0074\u0073";}else if _dcec ._ddg .V ==2{_ab +=_fe .Sprintf ("\u0052\u0043\u0034:\u0020\u0025\u0064\u0020\u0062\u0069\u0074\u0073",_dcec ._ddg .Length );}else if _dcec ._ddg .V ==3{_ab +="U\u006e\u0070\u0075\u0062li\u0073h\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d";}else if _dcec ._ddg .V >=4{_ab +=_fe .Sprintf ("\u0053\u0074r\u0065\u0061\u006d\u0020f\u0069\u006ct\u0065\u0072\u003a\u0020\u0025\u0073\u0020\u002d \u0053\u0074\u0072\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0074\u0065r\u003a\u0020\u0025\u0073",_dcec ._dedf ,_dcec ._cbd );_ab +="\u003b\u0020C\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0073\u003a";for _egd ,_bbeg :=range _dcec ._effg {_ab +=_fe .Sprintf ("\u0020\u002d\u0020\u0025\u0073\u003a\u0020\u0025\u0073 \u0028\u0025\u0064\u0029",_egd ,_bbeg .Name (),_bbeg .KeyLength ());};};_dced :=_dcec .GetAccessPermissions ();_ab +=_fe .Sprintf ("\u0020\u002d\u0020\u0025\u0023\u0076",_dced );return _ab ;};

// GetFilterName returns the names of the underlying encoding filters,
// separated by spaces.
// Note: This is just a string, should not be used in /Filter dictionary entry. Use GetFilterArray for that.
// TODO(v4): Refactor to GetFilter() which can be used for /Filter (either Name or Array), this can be
//  renamed to String() as a pretty string to use in debugging etc.
func (_fgea *MultiEncoder )GetFilterName ()string {_gef :="";for _aeb ,_ccgf :=range _fgea ._cbdga {_gef +=_ccgf .GetFilterName ();if _aeb < len (_fgea ._cbdga )-1{_gef +="\u0020";};};return _gef ;};

// DecodeStream decodes a JBIG2 encoded stream and returns the result as a slice of bytes.
func (_dgec *JBIG2Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _dgec .DecodeBytes (streamObj .Stream );};

// Validate validates the page settings for the JBIG2 encoder.
func (_eaga JBIG2EncoderSettings )Validate ()error {const _gagaf ="\u0076a\u006ci\u0064\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065\u0072";if _eaga .Threshold < 0||_eaga .Threshold > 1.0{return _cc .Errorf (_gagaf ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074\u0068\u0072\u0065\u0073\u0068\u006f\u006c\u0064\u0020\u0076a\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0076\u0027 \u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0069\u006e\u0020\u0072\u0061n\u0067\u0065\u0020\u005b\u0030\u002e0\u002c\u0020\u0031.\u0030\u005d",_eaga .Threshold );};if _eaga .ResolutionX < 0{return _cc .Errorf (_gagaf ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0078\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_eaga .ResolutionX );};if _eaga .ResolutionY < 0{return _cc .Errorf (_gagaf ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0079\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_eaga .ResolutionY );};if _eaga .DefaultPixelValue !=0&&_eaga .DefaultPixelValue !=1{return _cc .Errorf (_gagaf ,"de\u0066\u0061u\u006c\u0074\u0020\u0070\u0069\u0078\u0065\u006c\u0020v\u0061\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0066o\u0072 \u0074\u0068\u0065\u0020\u0062\u0069\u0074\u003a \u007b0\u002c\u0031}",_eaga .DefaultPixelValue );};if _eaga .Compression !=JB2Generic {return _cc .Errorf (_gagaf ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065d\u0020\u0063\u006fm\u0070\u0072\u0065\u0073s\u0069\u006f\u006e\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");};return nil ;};

// SetPredictor sets the predictor function.  Specify the number of columns per row.
// The columns indicates the number of samples per row.
// Used for grouping data together for compression.
func (_aafd *FlateEncoder )SetPredictor (columns int ){_aafd .Predictor =11;_aafd .Columns =columns };func (_beaa *PdfParser )parseHexString ()(*PdfObjectString ,error ){_beaa ._addbb .ReadByte ();var _acbd _cdc .Buffer ;for {_ddfb ,_afabg :=_beaa ._addbb .Peek (1);if _afabg !=nil {return MakeString (""),_afabg ;};if _ddfb [0]=='>'{_beaa ._addbb .ReadByte ();break ;};_cbgeg ,_ :=_beaa ._addbb .ReadByte ();if !IsWhiteSpace (_cbgeg ){_acbd .WriteByte (_cbgeg );};};if _acbd .Len ()%2==1{_acbd .WriteRune ('0');};_debb ,_ :=_gd .DecodeString (_acbd .String ());return MakeHexString (string (_debb )),nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_cdf *LZWEncoder )MakeDecodeParams ()PdfObject {if _cdf .Predictor > 1{_afcf :=MakeDict ();_afcf .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_cdf .Predictor )));if _cdf .BitsPerComponent !=8{_afcf .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_cdf .BitsPerComponent )));};if _cdf .Columns !=1{_afcf .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_cdf .Columns )));};if _cdf .Colors !=1{_afcf .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_cdf .Colors )));};return _afcf ;};return nil ;};func (_dgcb *PdfObjectInteger )String ()string {return _fe .Sprintf ("\u0025\u0064",*_dgcb )};

// AddEncoder adds the passed in encoder to the underlying encoder slice.
func (_gebgc *MultiEncoder )AddEncoder (encoder StreamEncoder ){_gebgc ._cbdga =append (_gebgc ._cbdga ,encoder );};

// GetName returns the *PdfObjectName represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetName (obj PdfObject )(_bbfbf *PdfObjectName ,_gcgaa bool ){_bbfbf ,_gcgaa =TraceToDirectObject (obj ).(*PdfObjectName );return _bbfbf ,_gcgaa ;};

// UpdateParams updates the parameter values of the encoder.
func (_fbb *RawEncoder )UpdateParams (params *PdfObjectDictionary ){};

// DecodeBytes decodes a slice of JPX encoded bytes and returns the result.
func (_cebf *JPXEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_ge .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_cebf .GetFilterName ());return encoded ,ErrNoJPXDecode ;};

// MakeHexString creates an PdfObjectString from a string intended for output as a hexadecimal string.
func MakeHexString (s string )*PdfObjectString {_aegad :=PdfObjectString {_bccece :s ,_edcb :true };return &_aegad ;};

// PdfCryptNewDecrypt makes the document crypt handler based on the encryption dictionary
// and trailer dictionary. Returns an error on failure to process.
func PdfCryptNewDecrypt (parser *PdfParser ,ed ,trailer *PdfObjectDictionary )(*PdfCrypt ,error ){_deb :=&PdfCrypt {_dfa :false ,_ce :make (map[PdfObject ]bool ),_efe :make (map[PdfObject ]bool ),_eac :make (map[int ]struct{}),_dge :parser };_fdf ,_gcff :=ed .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectName );if !_gcff {_ge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0043\u0072\u0079\u0070\u0074 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061r\u0079 \u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u0066\u0069\u0065\u006c\u0064\u0021");return _deb ,_b .New ("r\u0065\u0071\u0075\u0069\u0072\u0065d\u0020\u0063\u0072\u0079\u0070\u0074 \u0066\u0069\u0065\u006c\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u006d\u0069\u0073\u0073\u0069n\u0067");};if *_fdf !="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"{_ge .Log .Debug ("\u0045\u0052R\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020(%\u0073\u0029",*_fdf );return _deb ,_b .New ("\u0075n\u0073u\u0070\u0070\u006f\u0072\u0074e\u0064\u0020F\u0069\u006c\u0074\u0065\u0072");};_deb ._ddg .Filter =string (*_fdf );if _abg ,_cfc :=ed .Get ("\u0053u\u0062\u0046\u0069\u006c\u0074\u0065r").(*PdfObjectString );_cfc {_deb ._ddg .SubFilter =_abg .Str ();_ge .Log .Debug ("\u0055s\u0069n\u0067\u0020\u0073\u0075\u0062f\u0069\u006ct\u0065\u0072\u0020\u0025\u0073",_abg );};if L ,_bda :=ed .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );_bda {if (*L %8)!=0{_ge .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0049\u006ev\u0061\u006c\u0069\u0064\u0020\u0065\u006ec\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006c\u0065\u006e\u0067\u0074\u0068");return _deb ,_b .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0065\u006e\u0063\u0072y\u0070t\u0069o\u006e\u0020\u006c\u0065\u006e\u0067\u0074h");};_deb ._ddg .Length =int (*L );}else {_deb ._ddg .Length =40;};_deb ._ddg .V =0;if _aead ,_caf :=ed .Get ("\u0056").(*PdfObjectInteger );_caf {V :=int (*_aead );_deb ._ddg .V =V ;if V >=1&&V <=2{_deb ._effg =_eag (_deb ._ddg .Length );}else if V >=4&&V <=5{if _daf :=_deb .loadCryptFilters (ed );_daf !=nil {return _deb ,_daf ;};}else {_ge .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0061lg\u006f\u0020\u0056 \u003d \u0025\u0064",V );return _deb ,_b .New ("u\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d");};};if _bef :=_ccga (&_deb ._affe ,ed );_bef !=nil {return _deb ,_bef ;};_edba :="";if _bcgb ,_bfb :=trailer .Get ("\u0049\u0044").(*PdfObjectArray );_bfb &&_bcgb .Len ()>=1{_cdbd ,_dee :=GetString (_bcgb .Get (0));if !_dee {return _deb ,_b .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0074r\u0061\u0069l\u0065\u0072\u0020\u0049\u0044");};_edba =_cdbd .Str ();}else {_ge .Log .Debug ("\u0054\u0072ai\u006c\u0065\u0072 \u0049\u0044\u0020\u0061rra\u0079 m\u0069\u0073\u0073\u0069\u006e\u0067\u0020or\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0021");};_deb ._gdcc =_edba ;return _deb ,nil ;};func (_aafe *PdfCrypt )makeKey (_bcad string ,_agb ,_bgga uint32 ,_fef []byte )([]byte ,error ){_ceg ,_caae :=_aafe ._effg [_bcad ];if !_caae {return nil ,_fe .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_bcad );};return _ceg .MakeKey (_agb ,_bgga ,_fef );};

// IsDecimalDigit checks if the character is a part of a decimal number string.
func IsDecimalDigit (c byte )bool {return '0'<=c &&c <='9'};

// MakeStringFromBytes creates an PdfObjectString from a byte array.
// This is more natural than MakeString as `data` is usually not utf-8 encoded.
func MakeStringFromBytes (data []byte )*PdfObjectString {return MakeString (string (data ))};func (_ccae *PdfCrypt )decryptBytes (_fffe []byte ,_daae string ,_dec []byte )([]byte ,error ){_ge .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");_acde ,_cgd :=_ccae ._effg [_daae ];if !_cgd {return nil ,_fe .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_daae );};return _acde .DecryptBytes (_fffe ,_dec );};func (_gfd *PdfParser )repairLocateXref ()(int64 ,error ){_acfaf :=int64 (1000);_gfd ._dceb .Seek (-_acfaf ,_ef .SEEK_CUR );_cbcfbd ,_fedg :=_gfd ._dceb .Seek (0,_ef .SEEK_CUR );if _fedg !=nil {return 0,_fedg ;};_baga :=make ([]byte ,_acfaf );_gfd ._dceb .Read (_baga );_bcdf :=_gaaa .FindAllStringIndex (string (_baga ),-1);if len (_bcdf )< 1{_ge .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0065\u0070a\u0069\u0072\u003a\u0020\u0078\u0072\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021");return 0,_b .New ("\u0072\u0065\u0070\u0061ir\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064");};_abfa :=int64 (_bcdf [len (_bcdf )-1][0]);_ecgfd :=_cbcfbd +_abfa ;return _ecgfd ,nil ;};

// EqualObjects returns true if `obj1` and `obj2` have the same contents.
//
// NOTE: It is a good idea to flatten obj1 and obj2 with FlattenObject before calling this function
// so that contents, rather than references, can be compared.
func EqualObjects (obj1 ,obj2 PdfObject )bool {return _aacb (obj1 ,obj2 ,0)};

// LookupByNumber looks up a PdfObject by object number.  Returns an error on failure.
func (_adc *PdfParser )LookupByNumber (objNumber int )(PdfObject ,error ){_bd ,_ ,_acd :=_adc .lookupByNumberWrapper (objNumber ,true );return _bd ,_acd ;};var _acga =_ff .MustCompile ("\u005c\u0073\u002a\u0078\u0072\u0065\u0066\u005c\u0073\u002a");

// Bytes returns the PdfObjectString content as a []byte array.
func (_gfaea *PdfObjectString )Bytes ()[]byte {return []byte (_gfaea ._bccece )};