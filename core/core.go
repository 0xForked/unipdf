//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package core defines and implements the primitive PDF object types in golang, and provides functionality
// for parsing those from a PDF file stream. This includes I/O handling, cross references, repairs, encryption,
// encoding and other core capabilities.
package core ;import (_ef "bufio";_fbd "bytes";_fe "compress/lzw";_cdb "compress/zlib";_gg "crypto/md5";_fd "crypto/rand";_cd "encoding/hex";_g "errors";_e "fmt";_be "github.com/unidoc/unipdf/v3/common";_ag "github.com/unidoc/unipdf/v3/core/security";_da "github.com/unidoc/unipdf/v3/core/security/crypt";_de "github.com/unidoc/unipdf/v3/internal/ccittfax";_bea "github.com/unidoc/unipdf/v3/internal/imageutil";_ca "github.com/unidoc/unipdf/v3/internal/jbig2";_cdc "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_cg "github.com/unidoc/unipdf/v3/internal/jbig2/decoder";_eg "github.com/unidoc/unipdf/v3/internal/jbig2/document";_fbg "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_gag "github.com/unidoc/unipdf/v3/internal/strutils";_ga "golang.org/x/image/tiff/lzw";_ec "golang.org/x/xerrors";_ce "image";_fb "image/color";_b "image/jpeg";_d "io";_fec "os";_f "reflect";_ge "regexp";_ad "sort";_a "strconv";_bf "strings";_df "time";);

// MakeArrayFromIntegers64 creates an PdfObjectArray from a slice of int64s, where each array element
// is an PdfObjectInteger.
func MakeArrayFromIntegers64 (vals []int64 )*PdfObjectArray {_bgfc :=MakeArray ();for _ ,_dedd :=range vals {_bgfc .Append (MakeInteger (_dedd ));};return _bgfc ;};

// MakeArray creates an PdfObjectArray from a list of PdfObjects.
func MakeArray (objects ...PdfObject )*PdfObjectArray {_gdad :=&PdfObjectArray {};_gdad ._adcd =[]PdfObject {};for _ ,_cccfd :=range objects {_gdad ._adcd =append (_gdad ._adcd ,_cccfd );};return _gdad ;};func (_bdeb *PdfCrypt )generateParams (_ffae ,_afbb []byte )error {_gab :=_bdeb .securityHandler ();_edfe ,_acbg :=_gab .GenerateParams (&_bdeb ._deg ,_afbb ,_ffae );if _acbg !=nil {return _acbg ;};_bdeb ._ggb =_edfe ;return nil ;};

// GetXrefType returns the type of the first xref object (table or stream).
func (_gdaeg *PdfParser )GetXrefType ()*xrefType {return _gdaeg ._ebg };

// Clear resets the array to an empty state.
func (_dbgc *PdfObjectArray )Clear (){_dbgc ._adcd =[]PdfObject {}};

// ResolveReferencesDeep recursively traverses through object `o`, looking up and replacing
// references with indirect objects.
// Optionally a map of already deep-resolved objects can be provided via `traversed`. The `traversed` map
// is updated while traversing the objects to avoid traversing same objects multiple times.
func ResolveReferencesDeep (o PdfObject ,traversed map[PdfObject ]struct{})error {if traversed ==nil {traversed =map[PdfObject ]struct{}{};};return _fgec (o ,0,traversed );};

// GetFloatVal returns the float64 value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetFloatVal (obj PdfObject )(_bfbf float64 ,_bgae bool ){_cged ,_bgae :=TraceToDirectObject (obj ).(*PdfObjectFloat );if _bgae {return float64 (*_cged ),true ;};return 0,false ;};

// ASCII85Encoder implements ASCII85 encoder/decoder.
type ASCII85Encoder struct{};

// JBIG2Image is the image structure used by the jbig2 encoder. Its Data must be in a
// 1 bit per component and 1 component per pixel (1bpp). In order to create binary image
// use GoImageToJBIG2 function. If the image data contains the row bytes padding set the HasPadding to true.
type JBIG2Image struct{

// Width and Height defines the image boundaries.
Width ,Height int ;

// Data is the byte slice data for the input image
Data []byte ;

// HasPadding is the attribute that defines if the last byte of the data in the row contains
// 0 bits padding.
HasPadding bool ;};

// Get returns the i-th element of the array or nil if out of bounds (by index).
func (_ggeec *PdfObjectArray )Get (i int )PdfObject {if _ggeec ==nil ||i >=len (_ggeec ._adcd )||i < 0{return nil ;};return _ggeec ._adcd [i ];};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_cdbd *DCTEncoder )MakeDecodeParams ()PdfObject {return nil };

// String returns the PDF version as a string. Implements interface fmt.Stringer.
func (_acc Version )String ()string {return _e .Sprintf ("\u00250\u0064\u002e\u0025\u0030\u0064",_acc .Major ,_acc .Minor );};type encryptDict struct{Filter string ;V int ;SubFilter string ;Length int ;StmF string ;StrF string ;EFF string ;CF map[string ]_da .FilterDict ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_gfge *LZWEncoder )MakeStreamDict ()*PdfObjectDictionary {_fcgd :=MakeDict ();_fcgd .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_gfge .GetFilterName ()));_efa :=_gfge .MakeDecodeParams ();if _efa !=nil {_fcgd .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_efa );};_fcgd .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (int64 (_gfge .EarlyChange )));return _fcgd ;};

// GetIntVal returns the int value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetIntVal (obj PdfObject )(_babc int ,_cfc bool ){_gedd ,_cfc :=TraceToDirectObject (obj ).(*PdfObjectInteger );if _cfc &&_gedd !=nil {return int (*_gedd ),true ;};return 0,false ;};

// SetPredictor sets the predictor function.  Specify the number of columns per row.
// The columns indicates the number of samples per row.
// Used for grouping data together for compression.
func (_dbb *FlateEncoder )SetPredictor (columns int ){_dbb .Predictor =11;_dbb .Columns =columns };

// MakeFloat creates an PdfObjectFloat from a float64.
func MakeFloat (val float64 )*PdfObjectFloat {_bbcd :=PdfObjectFloat (val );return &_bbcd };func (_bffgf *PdfParser )parseBool ()(PdfObjectBool ,error ){_bacca ,_ddgf :=_bffgf ._fea .Peek (4);if _ddgf !=nil {return PdfObjectBool (false ),_ddgf ;};if (len (_bacca )>=4)&&(string (_bacca [:4])=="\u0074\u0072\u0075\u0065"){_bffgf ._fea .Discard (4);return PdfObjectBool (true ),nil ;};_bacca ,_ddgf =_bffgf ._fea .Peek (5);if _ddgf !=nil {return PdfObjectBool (false ),_ddgf ;};if (len (_bacca )>=5)&&(string (_bacca [:5])=="\u0066\u0061\u006cs\u0065"){_bffgf ._fea .Discard (5);return PdfObjectBool (false ),nil ;};return PdfObjectBool (false ),_g .New ("\u0075n\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0062o\u006fl\u0065a\u006e\u0020\u0073\u0074\u0072\u0069\u006eg");};

// SetImage sets the image base for given flate encoder.
func (_gfbc *FlateEncoder )SetImage (img *_bea .ImageBase ){_gfbc ._cbc =img };

// LZWEncoder provides LZW encoding/decoding functionality.
type LZWEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Colors int ;

// LZW algorithm setting.
EarlyChange int ;};func (_ddece *PdfObjectFloat )String ()string {return _e .Sprintf ("\u0025\u0066",*_ddece )};

// WriteString outputs the object as it is to be written to file.
func (_fefbd *PdfObjectNull )WriteString ()string {return "\u006e\u0075\u006c\u006c"};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_ebe *LZWEncoder )MakeDecodeParams ()PdfObject {if _ebe .Predictor > 1{_egdd :=MakeDict ();_egdd .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_ebe .Predictor )));if _ebe .BitsPerComponent !=8{_egdd .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_ebe .BitsPerComponent )));};if _ebe .Columns !=1{_egdd .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_ebe .Columns )));};if _ebe .Colors !=1{_egdd .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_ebe .Colors )));};return _egdd ;};return nil ;};

// GetFilterName returns the name of the encoding filter.
func (_bdcb *ASCII85Encoder )GetFilterName ()string {return StreamEncodingFilterNameASCII85 };

// Version represents a version of a PDF standard.
type Version struct{Major int ;Minor int ;};func _aecf (_bffg int )int {_decc :=_bffg >>(_daddf -1);return (_bffg ^_decc )-_decc };const (_dfff =0;_aaa =1;_ebab =2;_bdfa =3;_ggfd =4;);

// GetParser returns the parser for lazy-loading or compare references.
func (_egaag *PdfObjectReference )GetParser ()*PdfParser {return _egaag ._dfcg };

// MakeDecodeParams makes a new instance of an encoding dictionary based on the current encoder settings.
func (_eded *JBIG2Encoder )MakeDecodeParams ()PdfObject {return MakeDict ()};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_fafb *JPXEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};

// Get returns the PdfObject corresponding to the specified key.
// Returns a nil value if the key is not set.
func (_abed *PdfObjectDictionary )Get (key PdfObjectName )PdfObject {_afdbb ,_fdea :=_abed ._cfdc [key ];if !_fdea {return nil ;};return _afdbb ;};

// GetFilterName returns the name of the encoding filter.
func (_bgaf *RawEncoder )GetFilterName ()string {return StreamEncodingFilterNameRaw };

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_eead *MultiEncoder )MakeDecodeParams ()PdfObject {if len (_eead ._geffa )==0{return nil ;};if len (_eead ._geffa )==1{return _eead ._geffa [0].MakeDecodeParams ();};_fdcd :=MakeArray ();for _ ,_fbfe :=range _eead ._geffa {_cce :=_fbfe .MakeDecodeParams ();if _cce ==nil {_fdcd .Append (MakeNull ());}else {_fdcd .Append (_cce );};};return _fdcd ;};

// PdfObjectNull represents the primitive PDF null object.
type PdfObjectNull struct{};

// DecodeBytes decodes a slice of Flate encoded bytes and returns the result.
func (_bad *FlateEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_be .Log .Trace ("\u0046\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065\u0020b\u0079\u0074\u0065\u0073");if len (encoded )==0{_be .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0046\u006c\u0061\u0074\u0065 e\u006ec\u006f\u0064\u0065\u0064\u0020\u0062\u0075\u0066\u0066\u0065\u0072\u002e \u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0062y\u0074\u0065\u0020\u0073\u006c\u0069\u0063\u0065\u002e");return []byte {},nil ;};_fdbb :=_fbd .NewReader (encoded );_adfd ,_fgd :=_cdb .NewReader (_fdbb );if _fgd !=nil {_be .Log .Debug ("\u0044e\u0063o\u0064\u0069\u006e\u0067\u0020e\u0072\u0072o\u0072\u0020\u0025\u0076\u000a",_fgd );_be .Log .Debug ("\u0053t\u0072e\u0061\u006d\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (encoded ),encoded );return nil ,_fgd ;};defer _adfd .Close ();var _gfga _fbd .Buffer ;_gfga .ReadFrom (_adfd );return _gfga .Bytes (),nil ;};

// Validate validates the page settings for the JBIG2 encoder.
func (_bgda JBIG2EncoderSettings )Validate ()error {const _ecfc ="\u0076a\u006ci\u0064\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065\u0072";if _bgda .Threshold < 0||_bgda .Threshold > 1.0{return _fbg .Errorf (_ecfc ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074\u0068\u0072\u0065\u0073\u0068\u006f\u006c\u0064\u0020\u0076a\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0076\u0027 \u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0069\u006e\u0020\u0072\u0061n\u0067\u0065\u0020\u005b\u0030\u002e0\u002c\u0020\u0031.\u0030\u005d",_bgda .Threshold );};if _bgda .ResolutionX < 0{return _fbg .Errorf (_ecfc ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0078\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_bgda .ResolutionX );};if _bgda .ResolutionY < 0{return _fbg .Errorf (_ecfc ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0079\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_bgda .ResolutionY );};if _bgda .DefaultPixelValue !=0&&_bgda .DefaultPixelValue !=1{return _fbg .Errorf (_ecfc ,"de\u0066\u0061u\u006c\u0074\u0020\u0070\u0069\u0078\u0065\u006c\u0020v\u0061\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0066o\u0072 \u0074\u0068\u0065\u0020\u0062\u0069\u0074\u003a \u007b0\u002c\u0031}",_bgda .DefaultPixelValue );};if _bgda .Compression !=JB2Generic {return _fbg .Errorf (_ecfc ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065d\u0020\u0063\u006fm\u0070\u0072\u0065\u0073s\u0069\u006f\u006e\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");};return nil ;};

// IsNullObject returns true if `obj` is a PdfObjectNull.
func IsNullObject (obj PdfObject )bool {_ ,_dcfcb :=TraceToDirectObject (obj ).(*PdfObjectNull );return _dcfcb ;};func _ebd (_gec _da .Filter ,_ccb _ag .AuthEvent )*PdfObjectDictionary {if _ccb ==""{_ccb =_ag .EventDocOpen ;};_cf :=MakeDict ();_cf .Set ("\u0054\u0079\u0070\u0065",MakeName ("C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"));_cf .Set ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et",MakeName (string (_ccb )));_cf .Set ("\u0043\u0046\u004d",MakeName (_gec .Name ()));_cf .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_gec .KeyLength ())));return _cf ;};func _edc (_gca XrefTable ){_be .Log .Debug ("\u003dX\u003d\u0058\u003d\u0058\u003d");_be .Log .Debug ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");_gcd :=0;for _ ,_dgf :=range _gca .ObjectMap {_be .Log .Debug ("i\u002b\u0031\u003a\u0020\u0025\u0064 \u0028\u006f\u0062\u006a\u0020\u006eu\u006d\u003a\u0020\u0025\u0064\u0020\u0067e\u006e\u003a\u0020\u0025\u0064\u0029\u0020\u002d\u003e\u0020%\u0064",_gcd +1,_dgf .ObjectNumber ,_dgf .Generation ,_dgf .Offset );_gcd ++;};};

// DecodeStream decodes RunLengthEncoded stream object and give back decoded bytes.
func (_daeb *RunLengthEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _daeb .DecodeBytes (streamObj .Stream );};

// DecodeBytes decodes a slice of JPX encoded bytes and returns the result.
func (_bgeb *JPXEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_be .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_bgeb .GetFilterName ());return encoded ,ErrNoJPXDecode ;};

// LookupByReference looks up a PdfObject by a reference.
func (_gda *PdfParser )LookupByReference (ref PdfObjectReference )(PdfObject ,error ){_be .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0075\u0070\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0025\u0073",ref .String ());return _gda .LookupByNumber (int (ref .ObjectNumber ));};func (_gcc *PdfParser )seekToEOFMarker (_bfeaf int64 )error {var _gacd int64 ;var _bfgff int64 =2048;for _gacd < _bfeaf -4{if _bfeaf <=(_bfgff +_gacd ){_bfgff =_bfeaf -_gacd ;};_ ,_cegc :=_gcc ._cedgd .Seek (-_gacd -_bfgff ,_d .SeekEnd );if _cegc !=nil {return _cegc ;};_ddcf :=make ([]byte ,_bfgff );_gcc ._cedgd .Read (_ddcf );_be .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0045\u004f\u0046 \u006da\u0072\u006b\u0065\u0072\u003a\u0020\u0022%\u0073\u0022",string (_ddcf ));_fdfc :=_cdcea .FindAllStringIndex (string (_ddcf ),-1);if _fdfc !=nil {_dfaa :=_fdfc [len (_fdfc )-1];_be .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_fdfc );_gcc ._cedgd .Seek (-_gacd -_bfgff +int64 (_dfaa [0]),_d .SeekEnd );return nil ;};_be .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");_gacd +=_bfgff -4;};_be .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006be\u0072 \u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u002e");return _g .New ("\u0045\u004f\u0046\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};func _cbfd (_bedf _d .ReadSeeker ,_edffc int64 )(*offsetReader ,error ){_ageb :=&offsetReader {_eecc :_bedf ,_cgbf :_edffc };_ ,_babf :=_ageb .Seek (0,_d .SeekStart );return _ageb ,_babf ;};

// PdfVersion returns version of the PDF file.
func (_efee *PdfParser )PdfVersion ()Version {return _efee ._eecg };

// GetNumbersAsFloat converts a list of pdf objects representing floats or integers to a slice of
// float64 values.
func GetNumbersAsFloat (objects []PdfObject )(_afbd []float64 ,_egeg error ){for _ ,_cgff :=range objects {_ecec ,_gefb :=GetNumberAsFloat (_cgff );if _gefb !=nil {return nil ,_gefb ;};_afbd =append (_afbd ,_ecec );};return _afbd ,nil ;};

// GetCrypter returns the PdfCrypt instance which has information about the PDFs encryption.
func (_gdb *PdfParser )GetCrypter ()*PdfCrypt {return _gdb ._edaf };

// Remove removes an element specified by key.
func (_cgcf *PdfObjectDictionary )Remove (key PdfObjectName ){_aeecf :=-1;for _adaa ,_gbege :=range _cgcf ._beeac {if _gbege ==key {_aeecf =_adaa ;break ;};};if _aeecf >=0{_cgcf ._beeac =append (_cgcf ._beeac [:_aeecf ],_cgcf ._beeac [_aeecf +1:]...);delete (_cgcf ._cfdc ,key );};};var _edbf =_ge .MustCompile ("\u0028\u005c\u0064\u002b)\\\u0073\u002b\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u006f\u0062\u006a");

// AddEncoder adds the passed in encoder to the underlying encoder slice.
func (_defdg *MultiEncoder )AddEncoder (encoder StreamEncoder ){_defdg ._geffa =append (_defdg ._geffa ,encoder );};

// FlateEncoder represents Flate encoding.
type FlateEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Rows int ;Colors int ;_cbc *_bea .ImageBase ;};

// GetNumberAsInt64 returns the contents of `obj` as an int64 if it is an integer or float, or an
// error if it isn't. This is for cases where expecting an integer, but some implementations
// actually store the number in a floating point format.
func GetNumberAsInt64 (obj PdfObject )(int64 ,error ){switch _dbgce :=obj .(type ){case *PdfObjectFloat :_be .Log .Debug ("\u004e\u0075m\u0062\u0065\u0072\u0020\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0061\u0073\u0020\u0069\u006e\u0074e\u0067\u0065\u0072\u0020\u0077\u0061s\u0020\u0073\u0074\u006f\u0072\u0065\u0064\u0020\u0061\u0073\u0020\u0066\u006c\u006fa\u0074\u0020(\u0074\u0079\u0070\u0065 \u0063\u0061\u0073\u0074\u0069n\u0067\u0020\u0075\u0073\u0065\u0064\u0029");return int64 (*_dbgce ),nil ;case *PdfObjectInteger :return int64 (*_dbgce ),nil ;};return 0,ErrNotANumber ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_fdbfd *ASCII85Encoder )MakeDecodeParams ()PdfObject {return nil };

// UpdateParams updates the parameter values of the encoder.
func (_fgabf *DCTEncoder )UpdateParams (params *PdfObjectDictionary ){_aee ,_cfdd :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _cfdd ==nil {_fgabf .ColorComponents =int (_aee );};_efge ,_cfdd :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _cfdd ==nil {_fgabf .BitsPerComponent =int (_efge );};_edbg ,_cfdd :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _cfdd ==nil {_fgabf .Width =int (_edbg );};_cbea ,_cfdd :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _cfdd ==nil {_fgabf .Height =int (_cbea );};_fafg ,_cfdd :=GetNumberAsInt64 (params .Get ("\u0051u\u0061\u006c\u0069\u0074\u0079"));if _cfdd ==nil {_fgabf .Quality =int (_fafg );};};var _acbab =_ge .MustCompile ("\u0073t\u0061r\u0074\u0078\u003f\u0072\u0065f\u005c\u0073*\u0028\u005c\u0064\u002b\u0029");

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_gfbg *RawEncoder )MakeDecodeParams ()PdfObject {return nil };

// String returns a string describing `stream`.
func (_cffg *PdfObjectStream )String ()string {return _e .Sprintf ("O\u0062j\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0025\u0064: \u0025\u0073",_cffg .ObjectNumber ,_cffg .PdfObjectDictionary );};var _ggaa =_ge .MustCompile ("\u005e\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");

// NewASCIIHexEncoder makes a new ASCII hex encoder.
func NewASCIIHexEncoder ()*ASCIIHexEncoder {_fffc :=&ASCIIHexEncoder {};return _fffc };

// GetObjectStreams returns the *PdfObjectStreams represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetObjectStreams (obj PdfObject )(_beab *PdfObjectStreams ,_ggfb bool ){_beab ,_ggfb =obj .(*PdfObjectStreams );return _beab ,_ggfb ;};

// GetTrailer returns the PDFs trailer dictionary. The trailer dictionary is typically the starting point for a PDF,
// referencing other key objects that are important in the document structure.
func (_ebfc *PdfParser )GetTrailer ()*PdfObjectDictionary {return _ebfc ._gdeb };

// PdfObjectStreams represents the primitive PDF object streams.
// 7.5.7 Object Streams (page 45).
type PdfObjectStreams struct{PdfObjectReference ;_adfg []PdfObject ;};func (_dabcb *PdfParser )inspect ()(map[string ]int ,error ){_be .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0053P\u0045\u0043\u0054\u0020\u002d\u002d\u002d\u002d\u002d\u002d-\u002d\u002d\u002d");_be .Log .Trace ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");_gdeeb :=map[string ]int {};_aegbg :=0;_eccfb :=0;var _bcgad []int ;for _eedda :=range _dabcb ._eegf .ObjectMap {_bcgad =append (_bcgad ,_eedda );};_ad .Ints (_bcgad );_adgfg :=0;for _ ,_ecdee :=range _bcgad {_babbf :=_dabcb ._eegf .ObjectMap [_ecdee ];if _babbf .ObjectNumber ==0{continue ;};_aegbg ++;_be .Log .Trace ("\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d");_be .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0075\u0070\u0020\u006f\u0062\u006a\u0065c\u0074 \u006e\u0075\u006d\u0062\u0065\u0072\u003a \u0025\u0064",_babbf .ObjectNumber );_bbcba ,_gggcd :=_dabcb .LookupByNumber (_babbf .ObjectNumber );if _gggcd !=nil {_be .Log .Trace ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u006c\u006f\u006f\u006b\u0075p\u0020\u006f\u0062\u006a\u0020\u0025\u0064 \u0028\u0025\u0073\u0029",_babbf .ObjectNumber ,_gggcd );_eccfb ++;continue ;};_be .Log .Trace ("\u006fb\u006a\u003a\u0020\u0025\u0073",_bbcba );_gfda ,_cbaf :=_bbcba .(*PdfIndirectObject );if _cbaf {_be .Log .Trace ("\u0049N\u0044 \u004f\u004f\u0042\u004a\u0020\u0025\u0064\u003a\u0020\u0025\u0073",_babbf .ObjectNumber ,_gfda );_adccf ,_gbfg :=_gfda .PdfObject .(*PdfObjectDictionary );if _gbfg {if _bbgfc ,_acdc :=_adccf .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_acdc {_ecaf :=string (*_bbgfc );_be .Log .Trace ("\u002d\u002d\u002d\u003e\u0020\u004f\u0062\u006a\u0020\u0074\u0079\u0070e\u003a\u0020\u0025\u0073",_ecaf );_ ,_faabc :=_gdeeb [_ecaf ];if _faabc {_gdeeb [_ecaf ]++;}else {_gdeeb [_ecaf ]=1;};}else if _cegbd ,_afcg :=_adccf .Get ("\u0053u\u0062\u0074\u0079\u0070\u0065").(*PdfObjectName );_afcg {_ffdd :=string (*_cegbd );_be .Log .Trace ("-\u002d-\u003e\u0020\u004f\u0062\u006a\u0020\u0073\u0075b\u0074\u0079\u0070\u0065: \u0025\u0073",_ffdd );_ ,_baee :=_gdeeb [_ffdd ];if _baee {_gdeeb [_ffdd ]++;}else {_gdeeb [_ffdd ]=1;};};if _bgba ,_fgffg :=_adccf .Get ("\u0053").(*PdfObjectName );_fgffg &&*_bgba =="\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"{_ ,_edeeg :=_gdeeb ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"];if _edeeg {_gdeeb ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]++;}else {_gdeeb ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]=1;};};};}else if _caegb ,_eagg :=_bbcba .(*PdfObjectStream );_eagg {if _becce ,_bafg :=_caegb .PdfObjectDictionary .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_bafg {_be .Log .Trace ("\u002d\u002d\u003e\u0020\u0053\u0074\u0072\u0065\u0061\u006d\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073",*_becce );_agba :=string (*_becce );if _ ,_bbgfg :=_gdeeb [_agba ];_bbgfg {_gdeeb [_agba ]++;}else {_gdeeb [_agba ]=1;};};}else {_bbga ,_affcf :=_bbcba .(*PdfObjectDictionary );if _affcf {_gdcc ,_baffa :=_bbga .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if _baffa {_bdbg :=string (*_gdcc );_be .Log .Trace ("\u002d-\u002d \u006f\u0062\u006a\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073",_bdbg );_gdeeb [_bdbg ]++;};};_be .Log .Trace ("\u0044\u0049\u0052\u0045\u0043\u0054\u0020\u004f\u0042\u004a\u0020\u0025d\u003a\u0020\u0025\u0073",_babbf .ObjectNumber ,_bbcba );};_adgfg ++;};_be .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0045\u004fF\u0020\u0049\u004e\u0053\u0050\u0045\u0043T\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d");_be .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");_be .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074 \u0063\u006f\u0075\u006e\u0074\u003a\u0020\u0025\u0064",_aegbg );_be .Log .Trace ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u006f\u006b\u0075p\u003a\u0020\u0025\u0064",_eccfb );for _defg ,_fecdfe :=range _gdeeb {_be .Log .Trace ("\u0025\u0073\u003a\u0020\u0025\u0064",_defg ,_fecdfe );};_be .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");if len (_dabcb ._eegf .ObjectMap )< 1{_be .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0068\u0069\u0073 \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074 \u0069s\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0028\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0021\u0029");return nil ,_e .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0064\u006fc\u0075\u006d\u0065\u006e\u0074\u0020\u0028\u0078r\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006d\u0069\u0073s\u0069\u006e\u0067\u0029");};_cgee ,_bdedg :=_gdeeb ["\u0046\u006f\u006e\u0074"];if !_bdedg ||_cgee < 2{_be .Log .Trace ("\u0054\u0068\u0069s \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020i\u0073 \u0070r\u006fb\u0061\u0062\u006c\u0079\u0020\u0073\u0063\u0061\u006e\u006e\u0065\u0064\u0021");}else {_be .Log .Trace ("\u0054\u0068\u0069\u0073\u0020\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020\u0069\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0066o\u0072\u0020\u0065\u0078\u0074r\u0061\u0063t\u0069\u006f\u006e\u0021");};return _gdeeb ,nil ;};var _egdb =[]PdfObjectName {"\u0056","\u0052","\u004f","\u0055","\u0050"};

// DecodeGlobals decodes 'encoded' byte stream and returns their Globally defined segments ('Globals').
func (_geae *JBIG2Encoder )DecodeGlobals (encoded []byte )(_ca .Globals ,error ){return _ca .DecodeGlobals (encoded );};var _befd =_ge .MustCompile ("\u005b\\\u0072\u005c\u006e\u005d\u005c\u0073\u002a\u0028\u0078\u0072\u0065f\u0029\u005c\u0073\u002a\u005b\u005c\u0072\u005c\u006e\u005d");func _ddge (_edcd *PdfObjectStream ,_efbg *MultiEncoder )(*DCTEncoder ,error ){_eacb :=NewDCTEncoder ();_gaed :=_edcd .PdfObjectDictionary ;if _gaed ==nil {return _eacb ,nil ;};_dca :=_edcd .Stream ;if _efbg !=nil {_caec ,_caa :=_efbg .DecodeBytes (_dca );if _caa !=nil {return nil ,_caa ;};_dca =_caec ;};_eacf :=_fbd .NewReader (_dca );_gddb ,_dgca :=_b .DecodeConfig (_eacf );if _dgca !=nil {_be .Log .Debug ("\u0045\u0072\u0072or\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0065\u003a\u0020\u0025\u0073",_dgca );return nil ,_dgca ;};switch _gddb .ColorModel {case _fb .RGBAModel :_eacb .BitsPerComponent =8;_eacb .ColorComponents =3;case _fb .RGBA64Model :_eacb .BitsPerComponent =16;_eacb .ColorComponents =3;case _fb .GrayModel :_eacb .BitsPerComponent =8;_eacb .ColorComponents =1;case _fb .Gray16Model :_eacb .BitsPerComponent =16;_eacb .ColorComponents =1;case _fb .CMYKModel :_eacb .BitsPerComponent =8;_eacb .ColorComponents =4;case _fb .YCbCrModel :_eacb .BitsPerComponent =8;_eacb .ColorComponents =3;default:return nil ,_g .New ("\u0075\u006e\u0073up\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u006d\u006f\u0064\u0065\u006c");};_eacb .Width =_gddb .Width ;_eacb .Height =_gddb .Height ;_be .Log .Trace ("\u0044\u0043T\u0020\u0045\u006ec\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076",_eacb );_eacb .Quality =DefaultJPEGQuality ;return _eacb ,nil ;};

// DecodeStream decodes a multi-encoded stream by passing it through the
// DecodeStream method of the underlying encoders.
func (_gfdg *MultiEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _gfdg .DecodeBytes (streamObj .Stream );};

// JBIG2CompressionType defines the enum compression type used by the JBIG2Encoder.
type JBIG2CompressionType int ;func (_egaa *PdfParser )parseXrefStream (_ffdce *PdfObjectInteger )(*PdfObjectDictionary ,error ){if _ffdce !=nil {_be .Log .Trace ("\u0058\u0052\u0065f\u0053\u0074\u006d\u0020x\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0061\u0074\u0020\u0025\u0064",_ffdce );_egaa ._cedgd .Seek (int64 (*_ffdce ),_d .SeekStart );_egaa ._fea =_ef .NewReader (_egaa ._cedgd );};_aggfd :=_egaa .GetFileOffset ();_fbcf ,_cdff :=_egaa .ParseIndirectObject ();if _cdff !=nil {_be .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072\u0065\u0061d\u0020\u0078\u0072\u0065\u0066\u0020\u006fb\u006a\u0065\u0063\u0074");return nil ,_g .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072e\u0061\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062j\u0065\u0063\u0074");};_be .Log .Trace ("\u0058R\u0065f\u0053\u0074\u006d\u0020\u006fb\u006a\u0065c\u0074\u003a\u0020\u0025\u0073",_fbcf );_dega ,_dcfc :=_fbcf .(*PdfObjectStream );if !_dcfc {_be .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0058R\u0065\u0066\u0053\u0074\u006d\u0020\u0070o\u0069\u006e\u0074\u0069\u006e\u0067 \u0074\u006f\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065a\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0021");return nil ,_g .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0070\u006f\u0069\u006e\u0074i\u006e\u0067\u0020\u0074\u006f\u0020a\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006fb\u006a\u0065\u0063\u0074");};_eeee :=_dega .PdfObjectDictionary ;_fddea ,_dcfc :=_dega .PdfObjectDictionary .Get ("\u0053\u0069\u007a\u0065").(*PdfObjectInteger );if !_dcfc {_be .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u004d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0073\u0069\u007a\u0065\u0020f\u0072\u006f\u006d\u0020\u0078\u0072\u0065f\u0020\u0073\u0074\u006d");return nil ,_g .New ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0053\u0069\u007ae\u0020\u0066\u0072\u006f\u006d\u0020\u0078\u0072\u0065\u0066 \u0073\u0074\u006d");};if int64 (*_fddea )> 8388607{_be .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u0053\u0069\u007a\u0065\u0020\u0065x\u0063\u0065\u0065\u0064\u0065\u0064\u0020l\u0069\u006d\u0069\u0074\u002c\u0020\u006f\u0076\u0065\u0072\u00208\u0033\u0038\u0038\u0036\u0030\u0037\u0020\u0028\u0025\u0064\u0029",*_fddea );return nil ,_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_acaag :=_dega .PdfObjectDictionary .Get ("\u0057");_aged ,_dcfc :=_acaag .(*PdfObjectArray );if !_dcfc {return nil ,_g .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0057\u0020\u0069\u006e\u0020x\u0072\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d");};_aeagd :=_aged .Len ();if _aeagd !=3{_be .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020\u0028\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033\u0020\u002d\u0020\u0025\u0064\u0029",_aeagd );return nil ,_g .New ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065f\u0020s\u0074\u006d\u0020\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033");};var _fcfd []int64 ;for _efac :=0;_efac < 3;_efac ++{_beafa ,_cace :=GetInt (_aged .Get (_efac ));if !_cace {return nil ,_g .New ("i\u006e\u0076\u0061\u006cid\u0020w\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0074\u0079\u0070\u0065");};_fcfd =append (_fcfd ,int64 (*_beafa ));};_dcfg ,_cdff :=DecodeStream (_dega );if _cdff !=nil {_be .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020t\u006f \u0064e\u0063o\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u003a\u0020\u0025\u0076",_cdff );return nil ,_cdff ;};_bbfa :=int (_fcfd [0]);_ggeb :=int (_fcfd [0]+_fcfd [1]);_geca :=int (_fcfd [0]+_fcfd [1]+_fcfd [2]);_badg :=int (_fcfd [0]+_fcfd [1]+_fcfd [2]);if _bbfa < 0||_ggeb < 0||_geca < 0{_be .Log .Debug ("\u0045\u0072\u0072\u006fr\u0020\u0073\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u003c \u0030 \u0028\u0025\u0064\u002c\u0025\u0064\u002c%\u0064\u0029",_bbfa ,_ggeb ,_geca );return nil ,_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};if _badg ==0{_be .Log .Debug ("\u004e\u006f\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063t\u0073\u0020\u0069\u006e\u0020\u0073t\u0072\u0065\u0061\u006d\u0020\u0028\u0064\u0065\u006c\u0074\u0061\u0062\u0020=\u003d\u0020\u0030\u0029");return _eeee ,nil ;};_becf :=len (_dcfg )/_badg ;_baae :=0;_bcfeg :=_dega .PdfObjectDictionary .Get ("\u0049\u006e\u0064e\u0078");var _fcabg []int ;if _bcfeg !=nil {_be .Log .Trace ("\u0049n\u0064\u0065\u0078\u003a\u0020\u0025b",_bcfeg );_fcbc ,_abgg :=_bcfeg .(*PdfObjectArray );if !_abgg {_be .Log .Debug ("\u0049\u006e\u0076\u0061\u006ci\u0064\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0029");return nil ,_g .New ("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0049\u006e\u0064e\u0078\u0020\u006f\u0062je\u0063\u0074");};if _fcbc .Len ()%2!=0{_be .Log .Debug ("\u0057\u0041\u0052\u004eI\u004e\u0047\u0020\u0046\u0061\u0069\u006c\u0075\u0072e\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020i\u006e\u0064\u0065\u0078\u0020n\u006f\u0074\u0020\u006d\u0075\u006c\u0074\u0069\u0070\u006c\u0065\u0020\u006f\u0066\u0020\u0032\u002e");return nil ,_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_baae =0;_dbfg ,_dcfcd :=_fcbc .ToIntegerArray ();if _dcfcd !=nil {_be .Log .Debug ("\u0045\u0072\u0072\u006f\u0072 \u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0065\u0078 \u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0073\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0073\u003a\u0020\u0025\u0076",_dcfcd );return nil ,_dcfcd ;};for _afdg :=0;_afdg < len (_dbfg );_afdg +=2{_aac :=_dbfg [_afdg ];_acbcb :=_dbfg [_afdg +1];for _facc :=0;_facc < _acbcb ;_facc ++{_fcabg =append (_fcabg ,_aac +_facc );};_baae +=_acbcb ;};}else {for _gcdg :=0;_gcdg < int (*_fddea );_gcdg ++{_fcabg =append (_fcabg ,_gcdg );};_baae =int (*_fddea );};if _becf ==_baae +1{_be .Log .Debug ("\u0049n\u0063\u006f\u006d\u0070ati\u0062\u0069\u006c\u0069t\u0079\u003a\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006di\u0073\u0073\u0069\u006e\u0067\u0020\u0063\u006f\u0076\u0065\u0072\u0061\u0067\u0065\u0020\u006f\u0066\u0020\u0031\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u002d\u0020\u0061\u0070\u0070en\u0064\u0069\u006eg\u0020\u006f\u006e\u0065\u0020-\u0020M\u0061\u0079\u0020\u006c\u0065\u0061\u0064\u0020\u0074o\u0020\u0070\u0072\u006f\u0062\u006c\u0065\u006d\u0073");_eeca :=_baae -1;for _ ,_gbbb :=range _fcabg {if _gbbb > _eeca {_eeca =_gbbb ;};};_fcabg =append (_fcabg ,_eeca +1);_baae ++;};if _becf !=len (_fcabg ){_be .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020x\u0072\u0065\u0066 \u0073\u0074\u006d:\u0020\u006eu\u006d\u0020\u0065\u006e\u0074\u0072i\u0065s \u0021\u003d\u0020\u006c\u0065\u006e\u0028\u0069\u006e\u0064\u0069\u0063\u0065\u0073\u0029\u0020\u0028\u0025\u0064\u0020\u0021\u003d\u0020\u0025\u0064\u0029",_becf ,len (_fcabg ));return nil ,_g .New ("\u0078\u0072ef\u0020\u0073\u0074m\u0020\u006e\u0075\u006d en\u0074ri\u0065\u0073\u0020\u0021\u003d\u0020\u006cen\u0028\u0069\u006e\u0064\u0069\u0063\u0065s\u0029");};_be .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074s\u0020\u0063\u006f\u0075\u006e\u0074\u0020\u0025\u0064",_baae );_be .Log .Trace ("\u0049\u006e\u0064i\u0063\u0065\u0073\u003a\u0020\u0025\u0020\u0064",_fcabg );_egdg :=func (_degg []byte )int64 {var _gbce int64 ;for _agade :=0;_agade < len (_degg );_agade ++{_gbce +=int64 (_degg [_agade ])*(1<<uint (8*(len (_degg )-_agade -1)));};return _gbce ;};_be .Log .Trace ("\u0044e\u0063\u006f\u0064\u0065d\u0020\u0073\u0074\u0072\u0065a\u006d \u006ce\u006e\u0067\u0074\u0068\u003a\u0020\u0025d",len (_dcfg ));_eeec :=0;for _bbag :=0;_bbag < len (_dcfg );_bbag +=_badg {_fcbcd :=_cefeb (len (_dcfg ),_bbag ,_bbag +_bbfa );if _fcbcd !=nil {_be .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_fcbcd );return nil ,_fcbcd ;};_fefgb :=_dcfg [_bbag :_bbag +_bbfa ];_fcbcd =_cefeb (len (_dcfg ),_bbag +_bbfa ,_bbag +_ggeb );if _fcbcd !=nil {_be .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_fcbcd );return nil ,_fcbcd ;};_dabaf :=_dcfg [_bbag +_bbfa :_bbag +_ggeb ];_fcbcd =_cefeb (len (_dcfg ),_bbag +_ggeb ,_bbag +_geca );if _fcbcd !=nil {_be .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_fcbcd );return nil ,_fcbcd ;};_fcgcd :=_dcfg [_bbag +_ggeb :_bbag +_geca ];_acfd :=_egdg (_fefgb );_fcgdb :=_egdg (_dabaf );_febbd :=_egdg (_fcgcd );if _fcfd [0]==0{_acfd =1;};if _eeec >=len (_fcabg ){_be .Log .Debug ("X\u0052\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u002d\u0020\u0054\u0072\u0079\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0061\u0063\u0063e\u0073s\u0020\u0069\u006e\u0064e\u0078\u0020o\u0075\u0074\u0020\u006f\u0066\u0020\u0062\u006f\u0075\u006e\u0064\u0073\u0020\u002d\u0020\u0062\u0072\u0065\u0061\u006b\u0069\u006e\u0067");break ;};_gged :=_fcabg [_eeec ];_eeec ++;_be .Log .Trace ("%\u0064\u002e\u0020\u0070\u0031\u003a\u0020\u0025\u0020\u0078",_gged ,_fefgb );_be .Log .Trace ("%\u0064\u002e\u0020\u0070\u0032\u003a\u0020\u0025\u0020\u0078",_gged ,_dabaf );_be .Log .Trace ("%\u0064\u002e\u0020\u0070\u0033\u003a\u0020\u0025\u0020\u0078",_gged ,_fcgcd );_be .Log .Trace ("\u0025d\u002e \u0078\u0072\u0065\u0066\u003a \u0025\u0064 \u0025\u0064\u0020\u0025\u0064",_gged ,_acfd ,_fcgdb ,_febbd );if _acfd ==0{_be .Log .Trace ("-\u0020\u0046\u0072\u0065\u0065\u0020o\u0062\u006a\u0065\u0063\u0074\u0020-\u0020\u0063\u0061\u006e\u0020\u0070\u0072o\u0062\u0061\u0062\u006c\u0079\u0020\u0069\u0067\u006e\u006fr\u0065");}else if _acfd ==1{_be .Log .Trace ("\u002d\u0020I\u006e\u0020\u0075\u0073e\u0020\u002d \u0075\u006e\u0063\u006f\u006d\u0070\u0072\u0065s\u0073\u0065\u0064\u0020\u0076\u0069\u0061\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0062",_dabaf );if _fcgdb ==_aggfd {_be .Log .Debug ("\u0055\u0070d\u0061\u0074\u0069\u006e\u0067\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0058\u0052\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0064",_gged ,_dega .ObjectNumber );_gged =int (_dega .ObjectNumber );};if _fcgag ,_fcaf :=_egaa ._eegf .ObjectMap [_gged ];!_fcaf ||int (_febbd )> _fcgag .Generation {_ggaae :=XrefObject {ObjectNumber :_gged ,XType :XrefTypeTableEntry ,Offset :_fcgdb ,Generation :int (_febbd )};_egaa ._eegf .ObjectMap [_gged ]=_ggaae ;};}else if _acfd ==2{_be .Log .Trace ("\u002d\u0020\u0049\u006e \u0075\u0073\u0065\u0020\u002d\u0020\u0063\u006f\u006d\u0070r\u0065s\u0073\u0065\u0064\u0020\u006f\u0062\u006ae\u0063\u0074");if _ ,_daebe :=_egaa ._eegf .ObjectMap [_gged ];!_daebe {_ccbd :=XrefObject {ObjectNumber :_gged ,XType :XrefTypeObjectStream ,OsObjNumber :int (_fcgdb ),OsObjIndex :int (_febbd )};_egaa ._eegf .ObjectMap [_gged ]=_ccbd ;_be .Log .Trace ("\u0065\u006e\u0074\u0072\u0079\u003a\u0020\u0025\u002b\u0076",_ccbd );};}else {_be .Log .Debug ("\u0045\u0052\u0052\u004f\u0052:\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0056\u0041L\u0049\u0044\u0020\u0054\u0059\u0050\u0045\u0020\u0058\u0072\u0065\u0066\u0053\u0074\u006d\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u003f\u002d\u002d\u002d\u002d\u002d\u002d-");continue ;};};if _egaa ._ebg ==nil {_aceb :=XrefTypeObjectStream ;_egaa ._ebg =&_aceb ;};return _eeee ,nil ;};

// ResolveReference resolves reference if `o` is a *PdfObjectReference and returns the object referenced to.
// Otherwise returns back `o`.
func ResolveReference (obj PdfObject )PdfObject {if _fdeb ,_gbaa :=obj .(*PdfObjectReference );_gbaa {return _fdeb .Resolve ();};return obj ;};

// PdfObjectStream represents the primitive PDF Object stream.
type PdfObjectStream struct{PdfObjectReference ;*PdfObjectDictionary ;Stream []byte ;};

// EncodeBytes JPX encodes the passed in slice of bytes.
func (_ebabf *JPXEncoder )EncodeBytes (data []byte )([]byte ,error ){_be .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_ebabf .GetFilterName ());return data ,ErrNoJPXDecode ;};func (_ae *PdfParser )lookupByNumberWrapper (_dc int ,_ggf bool )(PdfObject ,bool ,error ){_eb ,_ea ,_dg :=_ae .lookupByNumber (_dc ,_ggf );if _dg !=nil {return nil ,_ea ,_dg ;};if !_ea &&_ae ._edaf !=nil &&!_ae ._edaf .isDecrypted (_eb ){_afc :=_ae ._edaf .Decrypt (_eb ,0,0);if _afc !=nil {return nil ,_ea ,_afc ;};};return _eb ,_ea ,nil ;};

// Merge merges in key/values from another dictionary. Overwriting if has same keys.
// The mutated dictionary (d) is returned in order to allow method chaining.
func (_gdaec *PdfObjectDictionary )Merge (another *PdfObjectDictionary )*PdfObjectDictionary {if another !=nil {for _ ,_egaf :=range another .Keys (){_dcab :=another .Get (_egaf );_gdaec .Set (_egaf ,_dcab );};};return _gdaec ;};

// UpdateParams updates the parameter values of the encoder.
func (_dabe *RunLengthEncoder )UpdateParams (params *PdfObjectDictionary ){};func _cefeb (_baffg ,_dfbfb ,_fegg int )error {if _dfbfb < 0||_dfbfb > _baffg {return _g .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0061\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");};if _fegg < _dfbfb {return _g .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0073\u006c\u0069\u0063e\u0020i\u006ed\u0065\u0078\u0020\u0062\u0020\u003c\u0020a");};if _fegg > _baffg {return _g .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0062\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");};return nil ;};

// NewFlateEncoder makes a new flate encoder with default parameters, predictor 1 and bits per component 8.
func NewFlateEncoder ()*FlateEncoder {_aeag :=&FlateEncoder {};_aeag .Predictor =1;_aeag .BitsPerComponent =8;_aeag .Colors =1;_aeag .Columns =1;return _aeag ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_adeg *JBIG2Encoder )MakeStreamDict ()*PdfObjectDictionary {_ebed :=MakeDict ();_ebed .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_adeg .GetFilterName ()));return _ebed ;};

// DecodeStream returns the passed in stream as a slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_cegb *RawEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return streamObj .Stream ,nil ;};func (_afb *PdfCrypt )makeKey (_efec string ,_ebc ,_gbc uint32 ,_ebfg []byte )([]byte ,error ){_egc ,_ffd :=_afb ._gac [_efec ];if !_ffd {return nil ,_e .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_efec );};return _egc .MakeKey (_ebc ,_gbc ,_ebfg );};

// GetNameVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetNameVal (obj PdfObject )(_edda string ,_fadd bool ){_cgdb ,_fadd :=TraceToDirectObject (obj ).(*PdfObjectName );if _fadd {return string (*_cgdb ),true ;};return ;};

// Bytes returns the PdfObjectString content as a []byte array.
func (_gegg *PdfObjectString )Bytes ()[]byte {return []byte (_gegg ._fggfe )};

// RunLengthEncoder represents Run length encoding.
type RunLengthEncoder struct{};func _bcga (_edae *PdfObjectStream ,_cdge *PdfObjectDictionary )(*CCITTFaxEncoder ,error ){_aebff :=NewCCITTFaxEncoder ();_gagg :=_edae .PdfObjectDictionary ;if _gagg ==nil {return _aebff ,nil ;};if _cdge ==nil {_gcdf :=TraceToDirectObject (_gagg .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));if _gcdf !=nil {switch _bbfc :=_gcdf .(type ){case *PdfObjectDictionary :_cdge =_bbfc ;break ;case *PdfObjectArray :if _bbfc .Len ()==1{if _baad ,_cfag :=GetDict (_bbfc .Get (0));_cfag {_cdge =_baad ;};};default:_be .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_gcdf );return nil ,_g .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _cdge ==nil {_be .Log .Error ("\u0044\u0065c\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064 %\u0023\u0076",_gcdf );return nil ,_g .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _gdec ,_dgcb :=GetNumberAsInt64 (_cdge .Get ("\u004b"));_dgcb ==nil {_aebff .K =int (_gdec );};if _gaff ,_cfg :=GetNumberAsInt64 (_cdge .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));_cfg ==nil {_aebff .Columns =int (_gaff );}else {_aebff .Columns =1728;};if _bgga ,_gcf :=GetNumberAsInt64 (_cdge .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_gcf ==nil {_aebff .BlackIs1 =_bgga > 0;}else {if _bgb ,_cca :=GetBoolVal (_cdge .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_cca {_aebff .BlackIs1 =_bgb ;}else {if _ddfc ,_ecbe :=GetArray (_cdge .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));_ecbe {_cfgg ,_efff :=_ddfc .ToIntegerArray ();if _efff ==nil {_aebff .BlackIs1 =_cfgg [0]==1&&_cfgg [1]==0;};};};};if _efcaf ,_fgde :=GetNumberAsInt64 (_cdge .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_fgde ==nil {_aebff .EncodedByteAlign =_efcaf > 0;}else {if _dagg ,_fefe :=GetBoolVal (_cdge .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_fefe {_aebff .EncodedByteAlign =_dagg ;};};if _acbc ,_bafbc :=GetNumberAsInt64 (_cdge .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_bafbc ==nil {_aebff .EndOfLine =_acbc > 0;}else {if _cadcf ,_aedg :=GetBoolVal (_cdge .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_aedg {_aebff .EndOfLine =_cadcf ;};};if _abgf ,_ecd :=GetNumberAsInt64 (_cdge .Get ("\u0052\u006f\u0077\u0073"));_ecd ==nil {_aebff .Rows =int (_abgf );};_aebff .EndOfBlock =true ;if _bfge ,_fgae :=GetNumberAsInt64 (_cdge .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_fgae ==nil {_aebff .EndOfBlock =_bfge > 0;}else {if _eccc ,_dba :=GetBoolVal (_cdge .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_dba {_aebff .EndOfBlock =_eccc ;};};if _fabe ,_fbdf :=GetNumberAsInt64 (_cdge .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));_fbdf !=nil {_aebff .DamagedRowsBeforeError =int (_fabe );};_be .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_cdge .String ());return _aebff ,nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_bcdc *CCITTFaxEncoder )MakeDecodeParams ()PdfObject {_cgfe :=MakeDict ();_cgfe .Set ("\u004b",MakeInteger (int64 (_bcdc .K )));_cgfe .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_bcdc .Columns )));if _bcdc .BlackIs1 {_cgfe .Set ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031",MakeBool (_bcdc .BlackIs1 ));};if _bcdc .EncodedByteAlign {_cgfe .Set ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e",MakeBool (_bcdc .EncodedByteAlign ));};if _bcdc .EndOfLine &&_bcdc .K >=0{_cgfe .Set ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee",MakeBool (_bcdc .EndOfLine ));};if _bcdc .Rows !=0&&!_bcdc .EndOfBlock {_cgfe .Set ("\u0052\u006f\u0077\u0073",MakeInteger (int64 (_bcdc .Rows )));};if !_bcdc .EndOfBlock {_cgfe .Set ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b",MakeBool (_bcdc .EndOfBlock ));};if _bcdc .DamagedRowsBeforeError !=0{_cgfe .Set ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072",MakeInteger (int64 (_bcdc .DamagedRowsBeforeError )));};return _cgfe ;};

// String returns a string describing `ref`.
func (_gbca *PdfObjectReference )String ()string {return _e .Sprintf ("\u0052\u0065\u0066\u0028\u0025\u0064\u0020\u0025\u0064\u0029",_gbca .ObjectNumber ,_gbca .GenerationNumber );};

// GetString is a helper for Get that returns a string value.
// Returns false if the key is missing or a value is not a string.
func (_abee *PdfObjectDictionary )GetString (key PdfObjectName )(string ,bool ){_ffeba ,_abcf :=_abee ._cfdc [key ].(*PdfObjectString );if !_abcf {return "",false ;};return _ffeba .Str (),true ;};func (_gbg *PdfCrypt )newEncryptDict ()*PdfObjectDictionary {_fgff :=MakeDict ();_fgff .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName ("\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"));_fgff .Set ("\u0056",MakeInteger (int64 (_gbg ._efd .V )));_fgff .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_gbg ._efd .Length )));return _fgff ;};func _fece (_caf *PdfObjectStream ,_dgee *PdfObjectDictionary )(*RunLengthEncoder ,error ){return NewRunLengthEncoder (),nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_baba *ASCIIHexEncoder )UpdateParams (params *PdfObjectDictionary ){};

// GetFilterName returns the name of the encoding filter.
func (_cede *JPXEncoder )GetFilterName ()string {return StreamEncodingFilterNameJPX };

// Decrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_bfaf *PdfCrypt )Decrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _bfaf .isDecrypted (obj ){return nil ;};switch _eee :=obj .(type ){case *PdfIndirectObject :_bfaf ._bff [_eee ]=true ;_be .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_eee .ObjectNumber ,_eee .GenerationNumber );_ddg :=_eee .ObjectNumber ;_abd :=_eee .GenerationNumber ;_abce :=_bfaf .Decrypt (_eee .PdfObject ,_ddg ,_abd );if _abce !=nil {return _abce ;};return nil ;case *PdfObjectStream :_bfaf ._bff [_eee ]=true ;_ffb :=_eee .PdfObjectDictionary ;if _bfaf ._deg .R !=5{if _afbg ,_ebaf :=_ffb .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_ebaf &&*_afbg =="\u0058\u0052\u0065\u0066"{return nil ;};};_efg :=_eee .ObjectNumber ;_dbc :=_eee .GenerationNumber ;_be .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_efg ,_dbc );_fgag :=_gaeg ;if _bfaf ._efd .V >=4{_fgag =_bfaf ._dfc ;_be .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_bfaf ._dfc );if _edb ,_bafb :=_ffb .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );_bafb {if _cge ,_fae :=GetName (_edb .Get (0));_fae {if *_cge =="\u0043\u0072\u0079p\u0074"{_fgag ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _acf ,_aed :=_ffb .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );_aed {if _cgg ,_fde :=_acf .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_fde {if _ ,_cdgb :=_bfaf ._gac [string (*_cgg )];_cdgb {_be .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_cgg );_fgag =string (*_cgg );};};};};};};_be .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_fgag );if _fgag =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_gcab :=_bfaf .Decrypt (_ffb ,_efg ,_dbc );if _gcab !=nil {return _gcab ;};_edd ,_gcab :=_bfaf .makeKey (_fgag ,uint32 (_efg ),uint32 (_dbc ),_bfaf ._ggb );if _gcab !=nil {return _gcab ;};_eee .Stream ,_gcab =_bfaf .decryptBytes (_eee .Stream ,_fgag ,_edd );if _gcab !=nil {return _gcab ;};_ffb .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_eee .Stream ))));return nil ;case *PdfObjectString :_be .Log .Trace ("\u0044e\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_bfef :=_gaeg ;if _bfaf ._efd .V >=4{_be .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_bfaf ._gfg );if _bfaf ._gfg =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_bfef =_bfaf ._gfg ;};_fcgc ,_gbcb :=_bfaf .makeKey (_bfef ,uint32 (parentObjNum ),uint32 (parentGenNum ),_bfaf ._ggb );if _gbcb !=nil {return _gbcb ;};_bcfe :=_eee .Str ();_gbb :=make ([]byte ,len (_bcfe ));for _cdfg :=0;_cdfg < len (_bcfe );_cdfg ++{_gbb [_cdfg ]=_bcfe [_cdfg ];};_be .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_gbb ,_gbb );_gbb ,_gbcb =_bfaf .decryptBytes (_gbb ,_bfef ,_fcgc );if _gbcb !=nil {return _gbcb ;};_eee ._fggfe =string (_gbb );return nil ;case *PdfObjectArray :for _ ,_cdbc :=range _eee .Elements (){_cgac :=_bfaf .Decrypt (_cdbc ,parentObjNum ,parentGenNum );if _cgac !=nil {return _cgac ;};};return nil ;case *PdfObjectDictionary :_ddd :=false ;if _cgbb :=_eee .Get ("\u0054\u0079\u0070\u0065");_cgbb !=nil {_gecbd ,_fbc :=_cgbb .(*PdfObjectName );if _fbc &&*_gecbd =="\u0053\u0069\u0067"{_ddd =true ;};};for _ ,_dbdg :=range _eee .Keys (){_fedg :=_eee .Get (_dbdg );if _ddd &&string (_dbdg )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;};if string (_dbdg )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_dbdg )!="\u0050\u0072\u0065\u0076"&&string (_dbdg )!="\u004c\u0061\u0073\u0074"{_fgfa :=_bfaf .Decrypt (_fedg ,parentObjNum ,parentGenNum );if _fgfa !=nil {return _fgfa ;};};};return nil ;};return nil ;};

// DecodeBytes decodes a slice of DCT encoded bytes and returns the result.
func (_fffe *DCTEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_agcc :=_fbd .NewReader (encoded );_ddf ,_ege :=_b .Decode (_agcc );if _ege !=nil {_be .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006eg\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_ege );return nil ,_ege ;};_dfef :=_ddf .Bounds ();var _ceb =make ([]byte ,_dfef .Dx ()*_dfef .Dy ()*_fffe .ColorComponents *_fffe .BitsPerComponent /8);_gcg :=0;for _dde :=_dfef .Min .Y ;_dde < _dfef .Max .Y ;_dde ++{for _cbd :=_dfef .Min .X ;_cbd < _dfef .Max .X ;_cbd ++{_eeea :=_ddf .At (_cbd ,_dde );if _fffe .ColorComponents ==1{if _fffe .BitsPerComponent ==16{_cbb ,_ceg :=_eeea .(_fb .Gray16 );if !_ceg {return nil ,_g .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_ceb [_gcg ]=byte ((_cbb .Y >>8)&0xff);_gcg ++;_ceb [_gcg ]=byte (_cbb .Y &0xff);_gcg ++;}else {_dee ,_efca :=_eeea .(_fb .Gray );if !_efca {return nil ,_g .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_ceb [_gcg ]=byte (_dee .Y &0xff);_gcg ++;};}else if _fffe .ColorComponents ==3{if _fffe .BitsPerComponent ==16{_aecd ,_cfea :=_eeea .(_fb .RGBA64 );if !_cfea {return nil ,_g .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_ceb [_gcg ]=byte ((_aecd .R >>8)&0xff);_gcg ++;_ceb [_gcg ]=byte (_aecd .R &0xff);_gcg ++;_ceb [_gcg ]=byte ((_aecd .G >>8)&0xff);_gcg ++;_ceb [_gcg ]=byte (_aecd .G &0xff);_gcg ++;_ceb [_gcg ]=byte ((_aecd .B >>8)&0xff);_gcg ++;_ceb [_gcg ]=byte (_aecd .B &0xff);_gcg ++;}else {_bbdf ,_acgd :=_eeea .(_fb .RGBA );if _acgd {_ceb [_gcg ]=_bbdf .R &0xff;_gcg ++;_ceb [_gcg ]=_bbdf .G &0xff;_gcg ++;_ceb [_gcg ]=_bbdf .B &0xff;_gcg ++;}else {_bbb ,_cfdg :=_eeea .(_fb .YCbCr );if !_cfdg {return nil ,_g .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_acff ,_gcb ,_bdagc ,_ :=_bbb .RGBA ();_ceb [_gcg ]=byte (_acff >>8);_gcg ++;_ceb [_gcg ]=byte (_gcb >>8);_gcg ++;_ceb [_gcg ]=byte (_bdagc >>8);_gcg ++;};};}else if _fffe .ColorComponents ==4{_cgc ,_adb :=_eeea .(_fb .CMYK );if !_adb {return nil ,_g .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_ceb [_gcg ]=255-_cgc .C &0xff;_gcg ++;_ceb [_gcg ]=255-_cgc .M &0xff;_gcg ++;_ceb [_gcg ]=255-_cgc .Y &0xff;_gcg ++;_ceb [_gcg ]=255-_cgc .K &0xff;_gcg ++;};};};return _ceb ,nil ;};func (_febbg *JBIG2Encoder )encodeImage (_aeec _ce .Image )([]byte ,error ){const _cccf ="e\u006e\u0063\u006f\u0064\u0065\u0049\u006d\u0061\u0067\u0065";_edbc ,_bdab :=GoImageToJBIG2 (_aeec ,JB2ImageAutoThreshold );if _bdab !=nil {return nil ,_fbg .Wrap (_bdab ,_cccf ,"\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069m\u0061g\u0065\u0020\u0074\u006f\u0020\u006a\u0062\u0069\u0067\u0032\u0020\u0069\u006d\u0067");};if _bdab =_febbg .AddPageImage (_edbc ,&_febbg .DefaultPageSettings );_bdab !=nil {return nil ,_fbg .Wrap (_bdab ,_cccf ,"");};return _febbg .Encode ();};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_abff *RawEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};func (_edffca *PdfParser )skipComments ()error {if _ ,_babb :=_edffca .skipSpaces ();_babb !=nil {return _babb ;};_bbec :=true ;for {_dacbb ,_cadcb :=_edffca ._fea .Peek (1);if _cadcb !=nil {_be .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_cadcb .Error ());return _cadcb ;};if _bbec &&_dacbb [0]!='%'{return nil ;};_bbec =false ;if (_dacbb [0]!='\r')&&(_dacbb [0]!='\n'){_edffca ._fea .ReadByte ();}else {break ;};};return _edffca .skipComments ();};func (_bdgc *PdfParser )readComment ()(string ,error ){var _aedba _fbd .Buffer ;_ ,_gbega :=_bdgc .skipSpaces ();if _gbega !=nil {return _aedba .String (),_gbega ;};_dgeg :=true ;for {_ddad ,_afeb :=_bdgc ._fea .Peek (1);if _afeb !=nil {_be .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_afeb .Error ());return _aedba .String (),_afeb ;};if _dgeg &&_ddad [0]!='%'{return _aedba .String (),_g .New ("c\u006f\u006d\u006d\u0065\u006e\u0074 \u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0073\u0074a\u0072\u0074\u0020w\u0069t\u0068\u0020\u0025");};_dgeg =false ;if (_ddad [0]!='\r')&&(_ddad [0]!='\n'){_cccc ,_ :=_bdgc ._fea .ReadByte ();_aedba .WriteByte (_cccc );}else {break ;};};return _aedba .String (),nil ;};

// NewRawEncoder returns a new instace of RawEncoder.
func NewRawEncoder ()*RawEncoder {return &RawEncoder {}};

// PdfObjectBool represents the primitive PDF boolean object.
type PdfObjectBool bool ;var _faa =_ge .MustCompile ("\u005e\u005b\\\u002b\u002d\u002e\u005d*\u0028\u005b0\u002d\u0039\u002e\u005d\u002b\u0029\u005b\u0065E\u005d\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");

// DecodeStream implements ASCII hex decoding.
func (_gde *ASCIIHexEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _gde .DecodeBytes (streamObj .Stream );};

// GetIndirect returns the *PdfIndirectObject represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetIndirect (obj PdfObject )(_fgabd *PdfIndirectObject ,_eacac bool ){obj =ResolveReference (obj );_fgabd ,_eacac =obj .(*PdfIndirectObject );return _fgabd ,_eacac ;};

// GetBoolVal returns the bool value within a *PdObjectBool represented by an PdfObject interface directly or indirectly.
// If the PdfObject does not represent a bool value, a default value of false is returned (found = false also).
func GetBoolVal (obj PdfObject )(_dcbcc bool ,_fdfcg bool ){_caae ,_fdfcg :=TraceToDirectObject (obj ).(*PdfObjectBool );if _fdfcg {return bool (*_caae ),true ;};return false ,false ;};

// GetStringBytes is like GetStringVal except that it returns the string as a []byte.
// It is for convenience.
func GetStringBytes (obj PdfObject )(_adbd []byte ,_gfcc bool ){_agac ,_gfcc :=TraceToDirectObject (obj ).(*PdfObjectString );if _gfcc {return _agac .Bytes (),true ;};return ;};type cryptFilters map[string ]_da .Filter ;func (_geded *PdfParser )skipSpaces ()(int ,error ){_fdef :=0;for {_gabb ,_eafe :=_geded ._fea .ReadByte ();if _eafe !=nil {return 0,_eafe ;};if IsWhiteSpace (_gabb ){_fdef ++;}else {_geded ._fea .UnreadByte ();break ;};};return _fdef ,nil ;};

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_fccf *FlateEncoder )EncodeBytes (data []byte )([]byte ,error ){if _fccf .Predictor !=1&&_fccf .Predictor !=11{_be .Log .Debug ("E\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0046\u006c\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065r\u0020P\u0072\u0065\u0064\u0069c\u0074\u006fr\u0020\u003d\u0020\u0031\u002c\u0020\u0031\u0031\u0020\u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");return nil ,ErrUnsupportedEncodingParameters ;};if _fccf .Predictor ==11{_agad :=int (_fccf .Columns );_bga :=len (data )/_agad ;if len (data )%_agad !=0{_be .Log .Error ("\u0049n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");return nil ,_g .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");};_efgd :=_fbd .NewBuffer (nil );_ccffg :=make ([]byte ,_agad );for _bgffb :=0;_bgffb < _bga ;_bgffb ++{_eagb :=data [_agad *_bgffb :_agad *(_bgffb +1)];_ccffg [0]=_eagb [0];for _ged :=1;_ged < _agad ;_ged ++{_ccffg [_ged ]=byte (int (_eagb [_ged ]-_eagb [_ged -1])%256);};_efgd .WriteByte (1);_efgd .Write (_ccffg );};data =_efgd .Bytes ();};var _acad _fbd .Buffer ;_dgc :=_cdb .NewWriter (&_acad );_dgc .Write (data );_dgc .Close ();return _acad .Bytes (),nil ;};

// MakeName creates a PdfObjectName from a string.
func MakeName (s string )*PdfObjectName {_dcbcb :=PdfObjectName (s );return &_dcbcb };

// DecodeBytes decodes a slice of JBIG2 encoded bytes and returns the results.
func (_eaf *JBIG2Encoder )DecodeBytes (encoded []byte )([]byte ,error ){return _ca .DecodeBytes (encoded ,_cg .Parameters {},_eaf .Globals );};var (ErrUnsupportedEncodingParameters =_g .New ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074\u0065\u0072\u0073");ErrNoCCITTFaxDecode =_g .New ("\u0043\u0043I\u0054\u0054\u0046\u0061\u0078\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");ErrNoJBIG2Decode =_g .New ("\u004a\u0042\u0049\u0047\u0032\u0044\u0065c\u006f\u0064\u0065 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");ErrNoJPXDecode =_g .New ("\u004a\u0050\u0058\u0044\u0065c\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020i\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");ErrNoPdfVersion =_g .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");ErrTypeError =_g .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");ErrRangeError =_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");ErrNotSupported =_ec .New ("\u0066\u0065\u0061t\u0075\u0072\u0065\u0020n\u006f\u0074\u0020\u0063\u0075\u0072\u0072e\u006e\u0074\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");ErrNotANumber =_g .New ("\u006e\u006f\u0074 \u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072"););

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_gcbf *RunLengthEncoder )MakeDecodeParams ()PdfObject {return nil };

// EqualObjects returns true if `obj1` and `obj2` have the same contents.
//
// NOTE: It is a good idea to flatten obj1 and obj2 with FlattenObject before calling this function
// so that contents, rather than references, can be compared.
func EqualObjects (obj1 ,obj2 PdfObject )bool {return _fcagg (obj1 ,obj2 ,0)};

// GetAccessPermissions returns the PDF access permissions as an AccessPermissions object.
func (_bccb *PdfCrypt )GetAccessPermissions ()_ag .Permissions {return _bccb ._deg .P };

// PdfCryptNewDecrypt makes the document crypt handler based on the encryption dictionary
// and trailer dictionary. Returns an error on failure to process.
func PdfCryptNewDecrypt (parser *PdfParser ,ed ,trailer *PdfObjectDictionary )(*PdfCrypt ,error ){_bed :=&PdfCrypt {_bdc :false ,_bff :make (map[PdfObject ]bool ),_gagf :make (map[PdfObject ]bool ),_afgd :make (map[int ]struct{}),_feb :parser };_daba ,_abad :=ed .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectName );if !_abad {_be .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0043\u0072\u0079\u0070\u0074 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061r\u0079 \u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u0066\u0069\u0065\u006c\u0064\u0021");return _bed ,_g .New ("r\u0065\u0071\u0075\u0069\u0072\u0065d\u0020\u0063\u0072\u0079\u0070\u0074 \u0066\u0069\u0065\u006c\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u006d\u0069\u0073\u0073\u0069n\u0067");};if *_daba !="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"{_be .Log .Debug ("\u0045\u0052R\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020(%\u0073\u0029",*_daba );return _bed ,_g .New ("\u0075n\u0073u\u0070\u0070\u006f\u0072\u0074e\u0064\u0020F\u0069\u006c\u0074\u0065\u0072");};_bed ._efd .Filter =string (*_daba );if _gecb ,_bdaad :=ed .Get ("\u0053u\u0062\u0046\u0069\u006c\u0074\u0065r").(*PdfObjectString );_bdaad {_bed ._efd .SubFilter =_gecb .Str ();_be .Log .Debug ("\u0055s\u0069n\u0067\u0020\u0073\u0075\u0062f\u0069\u006ct\u0065\u0072\u0020\u0025\u0073",_gecb );};if L ,_acb :=ed .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );_acb {if (*L %8)!=0{_be .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0049\u006ev\u0061\u006c\u0069\u0064\u0020\u0065\u006ec\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006c\u0065\u006e\u0067\u0074\u0068");return _bed ,_g .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0065\u006e\u0063\u0072y\u0070t\u0069o\u006e\u0020\u006c\u0065\u006e\u0067\u0074h");};_bed ._efd .Length =int (*L );}else {_bed ._efd .Length =40;};_bed ._efd .V =0;if _abag ,_aebf :=ed .Get ("\u0056").(*PdfObjectInteger );_aebf {V :=int (*_abag );_bed ._efd .V =V ;if V >=1&&V <=2{_bed ._gac =_bdf (_bed ._efd .Length );}else if V >=4&&V <=5{if _baff :=_bed .loadCryptFilters (ed );_baff !=nil {return _bed ,_baff ;};}else {_be .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0061lg\u006f\u0020\u0056 \u003d \u0025\u0064",V );return _bed ,_g .New ("u\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d");};};if _eed :=_ffeb (&_bed ._deg ,ed );_eed !=nil {return _bed ,_eed ;};_aga :="";if _dgbc ,_egd :=trailer .Get ("\u0049\u0044").(*PdfObjectArray );_egd &&_dgbc .Len ()>=1{_baea ,_bdb :=GetString (_dgbc .Get (0));if !_bdb {return _bed ,_g .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0074r\u0061\u0069l\u0065\u0072\u0020\u0049\u0044");};_aga =_baea .Str ();}else {_be .Log .Debug ("\u0054\u0072ai\u006c\u0065\u0072 \u0049\u0044\u0020\u0061rra\u0079 m\u0069\u0073\u0073\u0069\u006e\u0067\u0020or\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0021");};_bed ._geff =_aga ;return _bed ,nil ;};

// EncodeBytes encodes data into ASCII85 encoded format.
func (_fedc *ASCII85Encoder )EncodeBytes (data []byte )([]byte ,error ){var _bddd _fbd .Buffer ;for _ggbd :=0;_ggbd < len (data );_ggbd +=4{_fafa :=data [_ggbd ];_gede :=1;_bcce :=byte (0);if _ggbd +1< len (data ){_bcce =data [_ggbd +1];_gede ++;};_fbda :=byte (0);if _ggbd +2< len (data ){_fbda =data [_ggbd +2];_gede ++;};_cfef :=byte (0);if _ggbd +3< len (data ){_cfef =data [_ggbd +3];_gede ++;};_fdaf :=(uint32 (_fafa )<<24)|(uint32 (_bcce )<<16)|(uint32 (_fbda )<<8)|uint32 (_cfef );if _fdaf ==0{_bddd .WriteByte ('z');}else {_dfec :=_fedc .base256Tobase85 (_fdaf );for _ ,_bega :=range _dfec [:_gede +1]{_bddd .WriteByte (_bega +'!');};};};_bddd .WriteString ("\u007e\u003e");return _bddd .Bytes (),nil ;};

// RawEncoder implements Raw encoder/decoder (no encoding, pass through)
type RawEncoder struct{};func (_cfeac *JBIG2Image )toBitmap ()(_fbcd *_cdc .Bitmap ,_agca error ){const _eec ="\u004a\u0042\u0049\u00472I\u006d\u0061\u0067\u0065\u002e\u0074\u006f\u0042\u0069\u0074\u006d\u0061\u0070";if _cfeac .Data ==nil {return nil ,_fbg .Error (_eec ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");};if _cfeac .Width ==0||_cfeac .Height ==0{return nil ,_fbg .Error (_eec ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");};if _cfeac .HasPadding {_fbcd ,_agca =_cdc .NewWithData (_cfeac .Width ,_cfeac .Height ,_cfeac .Data );}else {_fbcd ,_agca =_cdc .NewWithUnpaddedData (_cfeac .Width ,_cfeac .Height ,_cfeac .Data );};if _agca !=nil {return nil ,_fbg .Wrap (_agca ,_eec ,"");};return _fbcd ,nil ;};const _daddf =32<<(^uint (0)>>63);

// Decoded returns the PDFDocEncoding or UTF-16BE decoded string contents.
// UTF-16BE is applied when the first two bytes are 0xFE, 0XFF, otherwise decoding of
// PDFDocEncoding is performed.
func (_ecee *PdfObjectString )Decoded ()string {if _ecee ==nil {return "";};_adgf :=[]byte (_ecee ._fggfe );if len (_adgf )>=2&&_adgf [0]==0xFE&&_adgf [1]==0xFF{return _gag .UTF16ToString (_adgf [2:]);};return _gag .PDFDocEncodingToString (_adgf );};func (_abdf *FlateEncoder )cleanImageData (_baa []byte )([]byte ,error ){if _abdf ._cbc ==nil {return _baa ,nil ;};if _abdf ._cbc .BitsPerComponent >=8{return _baa ,nil ;};_fceac :=_abdf ._cbc .BitsPerComponent *_abdf ._cbc .Width *_abdf ._cbc .ColorComponents *_abdf ._cbc .Height /8;_baa =_baa [:_fceac ];var _dgbb error ;_baa ,_dgbb =_bea .AddDataPadding (_abdf ._cbc .Width ,_abdf ._cbc .Height ,_abdf ._cbc .BitsPerComponent ,_abdf ._cbc .ColorComponents ,_baa );if _dgbb !=nil {return nil ,_dgbb ;};return _baa ,nil ;};

// IsOctalDigit checks if a character can be part of an octal digit string.
func IsOctalDigit (c byte )bool {return '0'<=c &&c <='7'};func (_agfe *PdfParser )seekPdfVersionTopDown ()(int ,int ,error ){_agfe ._cedgd .Seek (0,_fec .SEEK_SET );_agfe ._fea =_ef .NewReader (_agfe ._cedgd );_cccg :=20;_aabb :=make ([]byte ,_cccg );for {_bbfag ,_gaaa :=_agfe ._fea .ReadByte ();if _gaaa !=nil {if _gaaa ==_d .EOF {break ;}else {return 0,0,_gaaa ;};};if IsDecimalDigit (_bbfag )&&_aabb [_cccg -1]=='.'&&IsDecimalDigit (_aabb [_cccg -2])&&_aabb [_cccg -3]=='-'&&_aabb [_cccg -4]=='F'&&_aabb [_cccg -5]=='D'&&_aabb [_cccg -6]=='P'{_ccbda :=int (_aabb [_cccg -2]-'0');_agfdc :=int (_bbfag -'0');return _ccbda ,_agfdc ,nil ;};_aabb =append (_aabb [1:_cccg ],_bbfag );};return 0,0,_g .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};

// DecodeBytes decodes the CCITTFax encoded image data.
func (_effc *CCITTFaxEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_cbce :=&_de .Encoder {K :_effc .K ,Columns :_effc .Columns ,EndOfLine :_effc .EndOfLine ,EndOfBlock :_effc .EndOfBlock ,BlackIs1 :_effc .BlackIs1 ,DamagedRowsBeforeError :_effc .DamagedRowsBeforeError ,Rows :_effc .Rows ,EncodedByteAlign :_effc .EncodedByteAlign };_aef ,_efdb :=_cbce .Decode (encoded );if _efdb !=nil {return nil ,_efdb ;};var _gcea []byte ;_ffff :=0;var _eged byte ;var _cfae byte ;for _cfdda :=range _aef {if _eged !=0{_gcea =append (_gcea ,_cfae );_cfae =0;_ffff ++;_eged =0;};for _bbbc :=range _aef [_cfdda ]{_cfae |=_aef [_cfdda ][_bbbc ]<<(7-_eged );_eged ++;if _eged ==8{_gcea =append (_gcea ,_cfae );_cfae =0;_ffff ++;_eged =0;};};};if _eged > 0{_gcea =append (_gcea ,_cfae );};return _gcea ,nil ;};

// GetFilterName returns the name of the encoding filter.
func (_fbff *ASCIIHexEncoder )GetFilterName ()string {return StreamEncodingFilterNameASCIIHex };

// DecodeBytes decodes a slice of ASCII encoded bytes and returns the result.
func (_fca *ASCIIHexEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_egfca :=_fbd .NewReader (encoded );var _efedc []byte ;for {_age ,_cde :=_egfca .ReadByte ();if _cde !=nil {return nil ,_cde ;};if _age =='>'{break ;};if IsWhiteSpace (_age ){continue ;};if (_age >='a'&&_age <='f')||(_age >='A'&&_age <='F')||(_age >='0'&&_age <='9'){_efedc =append (_efedc ,_age );}else {_be .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0061\u0073\u0063\u0069\u0069 \u0068\u0065\u0078\u0020\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072 \u0028\u0025\u0063\u0029",_age );return nil ,_e .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0061\u0073\u0063\u0069\u0069\u0020\u0068e\u0078 \u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u0020\u0028\u0025\u0063\u0029",_age );};};if len (_efedc )%2==1{_efedc =append (_efedc ,'0');};_be .Log .Trace ("\u0049\u006e\u0062\u006f\u0075\u006e\u0064\u0020\u0025\u0073",_efedc );_gfd :=make ([]byte ,_cd .DecodedLen (len (_efedc )));_ ,_cbbd :=_cd .Decode (_gfd ,_efedc );if _cbbd !=nil {return nil ,_cbbd ;};return _gfd ,nil ;};

// GetFilterName returns the name of the encoding filter.
func (_cgaff *JBIG2Encoder )GetFilterName ()string {return StreamEncodingFilterNameJBIG2 };

// SetFileOffset sets the file to an offset position and resets buffer.
func (_fbad *PdfParser )SetFileOffset (offset int64 ){if offset < 0{offset =0;};_fbad ._cedgd .Seek (offset ,_d .SeekStart );_fbad ._fea =_ef .NewReader (_fbad ._cedgd );};func (_cdef *PdfParser )parseString ()(*PdfObjectString ,error ){_cdef ._fea .ReadByte ();var _dgged _fbd .Buffer ;_aaef :=1;for {_dfdg ,_cagg :=_cdef ._fea .Peek (1);if _cagg !=nil {return MakeString (_dgged .String ()),_cagg ;};if _dfdg [0]=='\\'{_cdef ._fea .ReadByte ();_decf ,_caeb :=_cdef ._fea .ReadByte ();if _caeb !=nil {return MakeString (_dgged .String ()),_caeb ;};if IsOctalDigit (_decf ){_fdf ,_edeg :=_cdef ._fea .Peek (2);if _edeg !=nil {return MakeString (_dgged .String ()),_edeg ;};var _efbb []byte ;_efbb =append (_efbb ,_decf );for _ ,_edffg :=range _fdf {if IsOctalDigit (_edffg ){_efbb =append (_efbb ,_edffg );}else {break ;};};_cdef ._fea .Discard (len (_efbb )-1);_be .Log .Trace ("\u004e\u0075\u006d\u0065ri\u0063\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0022\u0025\u0073\u0022",_efbb );_gcfd ,_edeg :=_a .ParseUint (string (_efbb ),8,32);if _edeg !=nil {return MakeString (_dgged .String ()),_edeg ;};_dgged .WriteByte (byte (_gcfd ));continue ;};switch _decf {case 'n':_dgged .WriteRune ('\n');case 'r':_dgged .WriteRune ('\r');case 't':_dgged .WriteRune ('\t');case 'b':_dgged .WriteRune ('\b');case 'f':_dgged .WriteRune ('\f');case '(':_dgged .WriteRune ('(');case ')':_dgged .WriteRune (')');case '\\':_dgged .WriteRune ('\\');};continue ;}else if _dfdg [0]=='('{_aaef ++;}else if _dfdg [0]==')'{_aaef --;if _aaef ==0{_cdef ._fea .ReadByte ();break ;};};_cbg ,_ :=_cdef ._fea .ReadByte ();_dgged .WriteByte (_cbg );};return MakeString (_dgged .String ()),nil ;};func (_afca *PdfParser )rebuildXrefTable ()error {_ffebb :=XrefTable {};_ffebb .ObjectMap =map[int ]XrefObject {};for _dcca ,_dggcg :=range _afca ._eegf .ObjectMap {_adcb ,_ ,_eece :=_afca .lookupByNumberWrapper (_dcca ,false );if _eece !=nil {_be .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020U\u006e\u0061\u0062\u006ce t\u006f l\u006f\u006f\u006b\u0020\u0075\u0070\u0020ob\u006a\u0065\u0063\u0074\u0020\u0028\u0025s\u0029",_eece );_be .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0063\u006fm\u0070\u006c\u0065\u0074\u0065\u006c\u0079\u0020\u0062\u0072\u006f\u006b\u0065\u006e\u0020\u002d\u0020\u0061\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0074\u006f \u0072\u0065\u0070\u0061\u0069r\u0020");_faaf ,_bgfda :=_afca .repairRebuildXrefsTopDown ();if _bgfda !=nil {_be .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0072\u0065\u0062\u0075\u0069l\u0064\u0020\u0072\u0065\u0070a\u0069\u0072 \u0028\u0025\u0073\u0029",_bgfda );return _bgfda ;};_afca ._eegf =*_faaf ;_be .Log .Debug ("\u0052e\u0070\u0061\u0069\u0072e\u0064\u0020\u0078\u0072\u0065f\u0020t\u0061b\u006c\u0065\u0020\u0062\u0075\u0069\u006ct");return nil ;};_dded ,_fdfg ,_eece :=_eab (_adcb );if _eece !=nil {return _eece ;};_dggcg .ObjectNumber =int (_dded );_dggcg .Generation =int (_fdfg );_ffebb .ObjectMap [int (_dded )]=_dggcg ;};_afca ._eegf =_ffebb ;_be .Log .Debug ("N\u0065w\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061b\u006c\u0065\u0020\u0062ui\u006c\u0074");_edc (_afca ._eegf );return nil ;};func _fcc (_efde *_ag .StdEncryptDict ,_fdd *PdfObjectDictionary ){_fdd .Set ("\u0052",MakeInteger (int64 (_efde .R )));_fdd .Set ("\u0050",MakeInteger (int64 (_efde .P )));_fdd .Set ("\u004f",MakeStringFromBytes (_efde .O ));_fdd .Set ("\u0055",MakeStringFromBytes (_efde .U ));if _efde .R >=5{_fdd .Set ("\u004f\u0045",MakeStringFromBytes (_efde .OE ));_fdd .Set ("\u0055\u0045",MakeStringFromBytes (_efde .UE ));_fdd .Set ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061",MakeBool (_efde .EncryptMetadata ));if _efde .R > 5{_fdd .Set ("\u0050\u0065\u0072m\u0073",MakeStringFromBytes (_efde .Perms ));};};};

// DecodeStream decodes a FlateEncoded stream object and give back decoded bytes.
func (_gbeg *FlateEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_be .Log .Trace ("\u0046l\u0061t\u0065\u0044\u0065\u0063\u006fd\u0065\u0020s\u0074\u0072\u0065\u0061\u006d");_be .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_gbeg .Predictor );if _gbeg .BitsPerComponent !=8{return nil ,_e .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003d\u0025\u0064\u0020\u0028\u006f\u006e\u006c\u0079\u0020\u0038\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0029",_gbeg .BitsPerComponent );};_bcg ,_cfba :=_gbeg .DecodeBytes (streamObj .Stream );if _cfba !=nil {return nil ,_cfba ;};_bcg ,_cfba =_gbeg .postDecodePredict (_bcg );if _cfba !=nil {return nil ,_cfba ;};return _gbeg .cleanImageData (_bcg );};

// NewJPXEncoder returns a new instance of JPXEncoder.
func NewJPXEncoder ()*JPXEncoder {return &JPXEncoder {}};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_efed *ASCIIHexEncoder )MakeStreamDict ()*PdfObjectDictionary {_cacf :=MakeDict ();_cacf .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_efed .GetFilterName ()));return _cacf ;};func _gagd (_beg *PdfObjectStream ,_baed *PdfObjectDictionary )(*LZWEncoder ,error ){_fdce :=NewLZWEncoder ();_bcdd :=_beg .PdfObjectDictionary ;if _bcdd ==nil {return _fdce ,nil ;};if _baed ==nil {_dfcd :=TraceToDirectObject (_bcdd .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));if _dfcd !=nil {if _bggc ,_cgga :=_dfcd .(*PdfObjectDictionary );_cgga {_baed =_bggc ;}else if _dabc ,_ebb :=_dfcd .(*PdfObjectArray );_ebb {if _dabc .Len ()==1{if _dea ,_dcga :=GetDict (_dabc .Get (0));_dcga {_baed =_dea ;};};};if _baed ==nil {_be .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_dfcd );return nil ,_e .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};};_eabc :=_bcdd .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");if _eabc !=nil {_fac ,_cagf :=_eabc .(*PdfObjectInteger );if !_cagf {_be .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a \u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065d\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u006e\u0075\u006d\u0065\u0072i\u0063 \u0028\u0025\u0054\u0029",_eabc );return nil ,_e .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");};if *_fac !=0&&*_fac !=1{return nil ,_e .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0076\u0061\u006c\u0075e\u0020\u0028\u006e\u006f\u0074 \u0030\u0020o\u0072\u0020\u0031\u0029");};_fdce .EarlyChange =int (*_fac );}else {_fdce .EarlyChange =1;};if _baed ==nil {return _fdce ,nil ;};_eabc =_baed .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");if _eabc !=nil {_bdfab ,_dfgc :=_eabc .(*PdfObjectInteger );if !_dfgc {_be .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_eabc );return nil ,_e .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_fdce .Predictor =int (*_bdfab );};_eabc =_baed .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");if _eabc !=nil {_bfea ,_dfcdf :=_eabc .(*PdfObjectInteger );if !_dfcdf {_be .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");return nil ,_e .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_fdce .BitsPerComponent =int (*_bfea );};if _fdce .Predictor > 1{_fdce .Columns =1;_eabc =_baed .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");if _eabc !=nil {_bacc ,_cfe :=_eabc .(*PdfObjectInteger );if !_cfe {return nil ,_e .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_fdce .Columns =int (*_bacc );};_fdce .Colors =1;_eabc =_baed .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _eabc !=nil {_aedb ,_egde :=_eabc .(*PdfObjectInteger );if !_egde {return nil ,_e .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");};_fdce .Colors =int (*_aedb );};};_be .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_baed .String ());return _fdce ,nil ;};

// Encrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_acbe *PdfCrypt )Encrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _acbe .isEncrypted (obj ){return nil ;};switch _fad :=obj .(type ){case *PdfIndirectObject :_acbe ._gagf [_fad ]=true ;_be .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_fad .ObjectNumber ,_fad .GenerationNumber );_cad :=_fad .ObjectNumber ;_eebc :=_fad .GenerationNumber ;_faf :=_acbe .Encrypt (_fad .PdfObject ,_cad ,_eebc );if _faf !=nil {return _faf ;};return nil ;case *PdfObjectStream :_acbe ._gagf [_fad ]=true ;_fce :=_fad .PdfObjectDictionary ;if _dcg ,_dbdd :=_fce .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_dbdd &&*_dcg =="\u0058\u0052\u0065\u0066"{return nil ;};_ded :=_fad .ObjectNumber ;_dgea :=_fad .GenerationNumber ;_be .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_ded ,_dgea );_fff :=_gaeg ;if _acbe ._efd .V >=4{_fff =_acbe ._dfc ;_be .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_acbe ._dfc );if _fge ,_cag :=_fce .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );_cag {if _bde ,_bag :=GetName (_fge .Get (0));_bag {if *_bde =="\u0043\u0072\u0079p\u0074"{_fff ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _bgff ,_cdde :=_fce .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );_cdde {if _fefg ,_cfa :=_bgff .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_cfa {if _ ,_efeb :=_acbe ._gac [string (*_fefg )];_efeb {_be .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_fefg );_fff =string (*_fefg );};};};};};};_be .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_fff );if _fff =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_aec :=_acbe .Encrypt (_fad .PdfObjectDictionary ,_ded ,_dgea );if _aec !=nil {return _aec ;};_afgde ,_aec :=_acbe .makeKey (_fff ,uint32 (_ded ),uint32 (_dgea ),_acbe ._ggb );if _aec !=nil {return _aec ;};_fad .Stream ,_aec =_acbe .encryptBytes (_fad .Stream ,_fff ,_afgde );if _aec !=nil {return _aec ;};_fce .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_fad .Stream ))));return nil ;case *PdfObjectString :_be .Log .Trace ("\u0045n\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_bdbb :=_gaeg ;if _acbe ._efd .V >=4{_be .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_acbe ._gfg );if _acbe ._gfg =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_bdbb =_acbe ._gfg ;};_fbgf ,_fgfe :=_acbe .makeKey (_bdbb ,uint32 (parentObjNum ),uint32 (parentGenNum ),_acbe ._ggb );if _fgfe !=nil {return _fgfe ;};_ccfa :=_fad .Str ();_cbeb :=make ([]byte ,len (_ccfa ));for _fgbg :=0;_fgbg < len (_ccfa );_fgbg ++{_cbeb [_fgbg ]=_ccfa [_fgbg ];};_be .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_cbeb ,_cbeb );_cbeb ,_fgfe =_acbe .encryptBytes (_cbeb ,_bdbb ,_fbgf );if _fgfe !=nil {return _fgfe ;};_fad ._fggfe =string (_cbeb );return nil ;case *PdfObjectArray :for _ ,_agaa :=range _fad .Elements (){_gaca :=_acbe .Encrypt (_agaa ,parentObjNum ,parentGenNum );if _gaca !=nil {return _gaca ;};};return nil ;case *PdfObjectDictionary :_bdgad :=false ;if _eggg :=_fad .Get ("\u0054\u0079\u0070\u0065");_eggg !=nil {_gegc ,_ggfe :=_eggg .(*PdfObjectName );if _ggfe &&*_gegc =="\u0053\u0069\u0067"{_bdgad =true ;};};for _ ,_dgfb :=range _fad .Keys (){_eda :=_fad .Get (_dgfb );if _bdgad &&string (_dgfb )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;};if string (_dgfb )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_dgfb )!="\u0050\u0072\u0065\u0076"&&string (_dgfb )!="\u004c\u0061\u0073\u0074"{_dabd :=_acbe .Encrypt (_eda ,parentObjNum ,parentGenNum );if _dabd !=nil {return _dabd ;};};};return nil ;};return nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_faeb *ASCII85Encoder )UpdateParams (params *PdfObjectDictionary ){};

// NewJBIG2Encoder creates a new JBIG2Encoder.
func NewJBIG2Encoder ()*JBIG2Encoder {return &JBIG2Encoder {_fcga :_eg .InitEncodeDocument (false )}};func _ffeb (_bda *_ag .StdEncryptDict ,_bdaa *PdfObjectDictionary )error {R ,_bdga :=_bdaa .Get ("\u0052").(*PdfObjectInteger );if !_bdga {return _g .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0052");};if *R < 2||*R > 6{return _e .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0052 \u0028\u0025\u0064\u0029",*R );};_bda .R =int (*R );O ,_bdga :=_bdaa .GetString ("\u004f");if !_bdga {return _g .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u004f");};if _bda .R ==5||_bda .R ==6{if len (O )< 48{return _e .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u004f\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (O ));};}else if len (O )!=32{return _e .Errorf ("L\u0065n\u0067\u0074\u0068\u0028\u004f\u0029\u0020\u0021=\u0020\u0033\u0032\u0020(%\u0064\u0029",len (O ));};_bda .O =[]byte (O );U ,_bdga :=_bdaa .GetString ("\u0055");if !_bdga {return _g .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0055");};if _bda .R ==5||_bda .R ==6{if len (U )< 48{return _e .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u0055\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (U ));};}else if len (U )!=32{_be .Log .Debug ("\u0057\u0061r\u006e\u0069\u006e\u0067\u003a\u0020\u004c\u0065\u006e\u0067\u0074\u0068\u0028\u0055\u0029\u0020\u0021\u003d\u0020\u0033\u0032\u0020(%\u0064\u0029",len (U ));};_bda .U =[]byte (U );if _bda .R >=5{OE ,_bfac :=_bdaa .GetString ("\u004f\u0045");if !_bfac {return _g .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u004f\u0045");}else if len (OE )!=32{return _e .Errorf ("L\u0065\u006e\u0067\u0074h(\u004fE\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (OE ));};_bda .OE =[]byte (OE );UE ,_bfac :=_bdaa .GetString ("\u0055\u0045");if !_bfac {return _g .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u0055\u0045");}else if len (UE )!=32{return _e .Errorf ("L\u0065\u006e\u0067\u0074h(\u0055E\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (UE ));};_bda .UE =[]byte (UE );};P ,_bdga :=_bdaa .Get ("\u0050").(*PdfObjectInteger );if !_bdga {return _g .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074 \u0064\u0069\u0063t\u0069\u006f\u006e\u0061r\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0070\u0065\u0072\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0061\u0074\u0074\u0072");};_bda .P =_ag .Permissions (*P );if _bda .R ==6{Perms ,_eeg :=_bdaa .GetString ("\u0050\u0065\u0072m\u0073");if !_eeg {return _g .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0050\u0065\u0072\u006d\u0073");}else if len (Perms )!=16{return _e .Errorf ("\u004ce\u006e\u0067\u0074\u0068\u0028\u0050\u0065\u0072\u006d\u0073\u0029 \u0021\u003d\u0020\u0031\u0036\u0020\u0028\u0025\u0064\u0029",len (Perms ));};_bda .Perms =[]byte (Perms );};if _ba ,_ac :=_bdaa .Get ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061").(*PdfObjectBool );_ac {_bda .EncryptMetadata =bool (*_ba );}else {_bda .EncryptMetadata =true ;};return nil ;};

// DecodeStream decodes a JBIG2 encoded stream and returns the result as a slice of bytes.
func (_aebc *JBIG2Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _aebc .DecodeBytes (streamObj .Stream );};

// NewASCII85Encoder makes a new ASCII85 encoder.
func NewASCII85Encoder ()*ASCII85Encoder {_ecag :=&ASCII85Encoder {};return _ecag };var _eeag =_ge .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064\u002b)\u005c\u0073\u002a\u0024");func (_bdag *PdfCrypt )securityHandler ()_ag .StdHandler {if _bdag ._deg .R >=5{return _ag .NewHandlerR6 ();};return _ag .NewHandlerR4 (_bdag ._geff ,_bdag ._efd .Length );};

// PdfObjectInteger represents the primitive PDF integer numerical object.
type PdfObjectInteger int64 ;func (_dbdc *FlateEncoder )postDecodePredict (_abaf []byte )([]byte ,error ){if _dbdc .Predictor > 1{if _dbdc .Predictor ==2{_be .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_be .Log .Trace ("\u0043\u006f\u006c\u006f\u0072\u0073\u003a\u0020\u0025\u0064",_dbdc .Colors );_dedg :=int (_dbdc .Columns )*_dbdc .Colors ;if _dedg < 1{return []byte {},nil ;};_fdbad :=len (_abaf )/_dedg ;if len (_abaf )%_dedg !=0{_be .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");return nil ,_e .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_abaf ),_dedg );};if _dedg %_dbdc .Colors !=0{return nil ,_e .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_dedg ,_dbdc .Colors );};if _dedg > len (_abaf ){_be .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_dedg ,len (_abaf ));return nil ,_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_be .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_abaf ),_abaf );_daf :=_fbd .NewBuffer (nil );for _effg :=0;_effg < _fdbad ;_effg ++{_acba :=_abaf [_dedg *_effg :_dedg *(_effg +1)];for _cfb :=_dbdc .Colors ;_cfb < _dedg ;_cfb ++{_acba [_cfb ]+=_acba [_cfb -_dbdc .Colors ];};_daf .Write (_acba );};_gbga :=_daf .Bytes ();_be .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_gbga ),_gbga );return _gbga ,nil ;}else if _dbdc .Predictor >=10&&_dbdc .Predictor <=15{_be .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_cgd :=int (_dbdc .Columns *_dbdc .Colors +1);_gecbb :=len (_abaf )/_cgd ;if len (_abaf )%_cgd !=0{return nil ,_e .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_abaf ),_cgd );};if _cgd > len (_abaf ){_be .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_cgd ,len (_abaf ));return nil ,_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_edfa :=_fbd .NewBuffer (nil );_be .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_dbdc .Columns );_be .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_abaf ),_cgd ,_gecbb );_afafb :=make ([]byte ,_cgd );for _daa :=0;_daa < _cgd ;_daa ++{_afafb [_daa ]=0;};_ggg :=_dbdc .Colors ;for _aab :=0;_aab < _gecbb ;_aab ++{_abg :=_abaf [_cgd *_aab :_cgd *(_aab +1)];_eca :=_abg [0];switch _eca {case _dfff :case _aaa :for _fcbg :=1+_ggg ;_fcbg < _cgd ;_fcbg ++{_abg [_fcbg ]+=_abg [_fcbg -_ggg ];};case _ebab :for _fdec :=1;_fdec < _cgd ;_fdec ++{_abg [_fdec ]+=_afafb [_fdec ];};case _bdfa :for _dgg :=1;_dgg < _ggg +1;_dgg ++{_abg [_dgg ]+=_afafb [_dgg ]/2;};for _efc :=_ggg +1;_efc < _cgd ;_efc ++{_abg [_efc ]+=byte ((int (_abg [_efc -_ggg ])+int (_afafb [_efc ]))/2);};case _ggfd :for _gea :=1;_gea < _cgd ;_gea ++{var _cedb ,_cgf ,_bac byte ;_cgf =_afafb [_gea ];if _gea >=_ggg +1{_cedb =_abg [_gea -_ggg ];_bac =_afafb [_gea -_ggg ];};_abg [_gea ]+=_fecdc (_cedb ,_cgf ,_bac );};default:_be .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029\u0020\u0040\u0072o\u0077\u0020\u0025\u0064",_eca ,_aab );return nil ,_e .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_eca );};copy (_afafb ,_abg );_edfa .Write (_abg [1:]);};_aeca :=_edfa .Bytes ();return _aeca ,nil ;}else {_be .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_dbdc .Predictor );return nil ,_e .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_dbdc .Predictor );};};return _abaf ,nil ;};

// NewMultiEncoder returns a new instance of MultiEncoder.
func NewMultiEncoder ()*MultiEncoder {_baedb :=MultiEncoder {};_baedb ._geffa =[]StreamEncoder {};return &_baedb ;};

// NewRunLengthEncoder makes a new run length encoder
func NewRunLengthEncoder ()*RunLengthEncoder {return &RunLengthEncoder {}};func _bdf (_dbd int )cryptFilters {return cryptFilters {_gaeg :_da .NewFilterV2 (_dbd )}};

// WriteString outputs the object as it is to be written to file.
func (_gcec *PdfObjectName )WriteString ()string {var _fefc _fbd .Buffer ;if len (*_gcec )> 127{_be .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u004e\u0061\u006d\u0065\u0020t\u006fo\u0020l\u006f\u006e\u0067\u0020\u0028\u0025\u0073)",*_gcec );};_fefc .WriteString ("\u002f");for _dgbd :=0;_dgbd < len (*_gcec );_dgbd ++{_accg :=(*_gcec )[_dgbd ];if !IsPrintable (_accg )||_accg =='#'||IsDelimiter (_accg ){_fefc .WriteString (_e .Sprintf ("\u0023\u0025\u002e2\u0078",_accg ));}else {_fefc .WriteByte (_accg );};};return _fefc .String ();};

// GetXrefOffset returns the offset of the xref table.
func (_eegg *PdfParser )GetXrefOffset ()int64 {return _eegg ._ddfd };

// DecodeStream decodes a LZW encoded stream and returns the result as a
// slice of bytes.
func (_dfa *LZWEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_be .Log .Trace ("\u004c\u005a\u0057 \u0044\u0065\u0063\u006f\u0064\u0069\u006e\u0067");_be .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_dfa .Predictor );_fecb ,_fcf :=_dfa .DecodeBytes (streamObj .Stream );if _fcf !=nil {return nil ,_fcf ;};_be .Log .Trace ("\u0020\u0049\u004e\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (streamObj .Stream ),streamObj .Stream );_be .Log .Trace ("\u004f\u0055\u0054\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (_fecb ),_fecb );if _dfa .Predictor > 1{if _dfa .Predictor ==2{_be .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_fdgc :=int (_dfa .Columns )*_dfa .Colors ;if _fdgc < 1{return []byte {},nil ;};_egag :=len (_fecb )/_fdgc ;if len (_fecb )%_fdgc !=0{_be .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");return nil ,_e .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_fecb ),_fdgc );};if _fdgc %_dfa .Colors !=0{return nil ,_e .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_fdgc ,_dfa .Colors );};if _fdgc > len (_fecb ){_be .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_fdgc ,len (_fecb ));return nil ,_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_be .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_fecb ),_fecb );_ebbf :=_fbd .NewBuffer (nil );for _dbce :=0;_dbce < _egag ;_dbce ++{_gbcbd :=_fecb [_fdgc *_dbce :_fdgc *(_dbce +1)];for _bec :=_dfa .Colors ;_bec < _fdgc ;_bec ++{_gbcbd [_bec ]=byte (int (_gbcbd [_bec ]+_gbcbd [_bec -_dfa .Colors ])%256);};_ebbf .Write (_gbcbd );};_gfe :=_ebbf .Bytes ();_be .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_gfe ),_gfe );return _gfe ,nil ;}else if _dfa .Predictor >=10&&_dfa .Predictor <=15{_be .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_bfbd :=int (_dfa .Columns *_dfa .Colors +1);if _bfbd < 1{return []byte {},nil ;};_befce :=len (_fecb )/_bfbd ;if len (_fecb )%_bfbd !=0{return nil ,_e .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_fecb ),_bfbd );};if _bfbd > len (_fecb ){_be .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_bfbd ,len (_fecb ));return nil ,_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_aaac :=_fbd .NewBuffer (nil );_be .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_dfa .Columns );_be .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_fecb ),_bfbd ,_befce );_gdag :=make ([]byte ,_bfbd );for _cacg :=0;_cacg < _bfbd ;_cacg ++{_gdag [_cacg ]=0;};for _eea :=0;_eea < _befce ;_eea ++{_gff :=_fecb [_bfbd *_eea :_bfbd *(_eea +1)];_agb :=_gff [0];switch _agb {case 0:case 1:for _aafg :=2;_aafg < _bfbd ;_aafg ++{_gff [_aafg ]=byte (int (_gff [_aafg ]+_gff [_aafg -1])%256);};case 2:for _cdbb :=1;_cdbb < _bfbd ;_cdbb ++{_gff [_cdbb ]=byte (int (_gff [_cdbb ]+_gdag [_cdbb ])%256);};default:_be .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0066i\u006c\u0074\u0065\u0072\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_agb );return nil ,_e .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_agb );};for _ebcg :=0;_ebcg < _bfbd ;_ebcg ++{_gdag [_ebcg ]=_gff [_ebcg ];};_aaac .Write (_gff [1:]);};_gggd :=_aaac .Bytes ();return _gggd ,nil ;}else {_be .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_dfa .Predictor );return nil ,_e .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_dfa .Predictor );};};return _fecb ,nil ;};var _fddg =_ge .MustCompile ("\u005c\u0073\u002a\u0078\u0072\u0065\u0066\u005c\u0073\u002a");func (_aag *PdfCrypt )saveCryptFilters (_afa *PdfObjectDictionary )error {if _aag ._efd .V < 4{return _g .New ("\u0063\u0061\u006e\u0020\u006f\u006e\u006c\u0079\u0020\u0062\u0065 \u0075\u0073\u0065\u0064\u0020\u0077\u0069\u0074\u0068\u0020V\u003e\u003d\u0034");};_dbgd :=MakeDict ();_afa .Set ("\u0043\u0046",_dbgd );for _dgfd ,_eggf :=range _aag ._gac {if _dgfd =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{continue ;};_ceee :=_ebd (_eggf ,"");_dbgd .Set (PdfObjectName (_dgfd ),_ceee );};_afa .Set ("\u0053\u0074\u0072\u0046",MakeName (_aag ._gfg ));_afa .Set ("\u0053\u0074\u006d\u0046",MakeName (_aag ._dfc ));return nil ;};func (_afaf *PdfCrypt )isDecrypted (_eccg PdfObject )bool {_ ,_cfd :=_afaf ._bff [_eccg ];if _cfd {_be .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0064\u0065\u0063\u0072y\u0070\u0074\u0065\u0064");return true ;};switch _ead :=_eccg .(type ){case *PdfObjectStream :if _afaf ._deg .R !=5{if _eef ,_agf :=_ead .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_agf &&*_eef =="\u0058\u0052\u0065\u0066"{return true ;};};case *PdfIndirectObject :if _ ,_cfd =_afaf ._afgd [int (_ead .ObjectNumber )];_cfd {return true ;};switch _ddbg :=_ead .PdfObject .(type ){case *PdfObjectDictionary :_fdbf :=true ;for _ ,_efb :=range _egdb {if _ddbg .Get (_efb )==nil {_fdbf =false ;break ;};};if _fdbf {return true ;};};};_be .Log .Trace ("\u004e\u006f\u0074\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");return false ;};func _dagb (_ccba *PdfObjectStream ,_cgeb *PdfObjectDictionary )(*JBIG2Encoder ,error ){const _ecgf ="\u006ee\u0077\u004a\u0042\u0049G\u0032\u0044\u0065\u0063\u006fd\u0065r\u0046r\u006f\u006d\u0053\u0074\u0072\u0065\u0061m";_bffb :=&JBIG2Encoder {};_dbac :=_ccba .PdfObjectDictionary ;if _dbac ==nil {return _bffb ,nil ;};if _cgeb ==nil {_bafd :=_dbac .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _bafd !=nil {switch _befb :=_bafd .(type ){case *PdfObjectDictionary :_cgeb =_befb ;case *PdfObjectArray :if _befb .Len ()==1{if _cfee ,_eaad :=GetDict (_befb .Get (0));_eaad {_cgeb =_cfee ;};};default:_be .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065P\u0061\u0072\u0061\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064i\u0063\u0074\u0069\u006f\u006e\u0061\u0072y\u0020\u0025\u0023\u0076",_bafd );return nil ,_fbg .Errorf (_ecgf ,"\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050a\u0072m\u0073\u0020\u0074\u0079\u0070\u0065\u003a \u0025\u0054",_befb );};};};if _cgeb ==nil {return _bffb ,nil ;};_bffb .UpdateParams (_cgeb );_fddee :=_cgeb .Get ("\u004a\u0042\u0049G\u0032\u0047\u006c\u006f\u0062\u0061\u006c\u0073");if _fddee ==nil {return _bffb ,nil ;};var _bggcd error ;_deab ,_fbbb :=_fddee .(*PdfObjectStream );if !_fbbb {_bggcd =_fbg .Error (_ecgf ,"j\u0062\u0069\u0067\u0032\u002e\u0047\u006c\u006f\u0062a\u006c\u0073\u0020\u0073\u0074\u0072\u0065am\u0020\u0073\u0068\u006fu\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u006e\u0020Ob\u006a\u0065c\u0074\u0020\u0053\u0074\u0072\u0065\u0061\u006d");_be .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_bggcd );return nil ,_bggcd ;};_bffb .Globals ,_bggcd =_ca .DecodeGlobals (_deab .Stream );if _bggcd !=nil {_bggcd =_fbg .Wrap (_bggcd ,_ecgf ,"\u0063\u006f\u0072\u0072u\u0070\u0074\u0065\u0064\u0020\u006a\u0062\u0069\u0067\u0032 \u0065n\u0063\u006f\u0064\u0065\u0064\u0020\u0064a\u0074\u0061");_be .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_bggcd );return nil ,_bggcd ;};return _bffb ,nil ;};

// DecodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_eccgg *RawEncoder )DecodeBytes (encoded []byte )([]byte ,error ){return encoded ,nil };func (_gdab *PdfParser )readTextLine ()(string ,error ){var _bgfe _fbd .Buffer ;for {_fdaeb ,_bdee :=_gdab ._fea .Peek (1);if _bdee !=nil {_be .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_bdee .Error ());return _bgfe .String (),_bdee ;};if (_fdaeb [0]!='\r')&&(_fdaeb [0]!='\n'){_aebg ,_ :=_gdab ._fea .ReadByte ();_bgfe .WriteByte (_aebg );}else {break ;};};return _bgfe .String (),nil ;};type xrefType int ;

// PdfObject is an interface which all primitive PDF objects must implement.
type PdfObject interface{

// String outputs a string representation of the primitive (for debugging).
String ()string ;

// WriteString outputs the PDF primitive as written to file as expected by the standard.
// TODO(dennwc): it should return a byte slice, or accept a writer
WriteString ()string ;};

// UpdateParams updates the parameter values of the encoder.
func (_eccf *LZWEncoder )UpdateParams (params *PdfObjectDictionary ){_bgedg ,_bbc :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _bbc ==nil {_eccf .Predictor =int (_bgedg );};_dbdad ,_bbc :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _bbc ==nil {_eccf .BitsPerComponent =int (_dbdad );};_dcb ,_bbc :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _bbc ==nil {_eccf .Columns =int (_dcb );};_bee ,_bbc :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _bbc ==nil {_eccf .Colors =int (_bee );};_dgge ,_bbc :=GetNumberAsInt64 (params .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065"));if _bbc ==nil {_eccf .EarlyChange =int (_dgge );};};

// IsFloatDigit checks if a character can be a part of a float number string.
func IsFloatDigit (c byte )bool {return ('0'<=c &&c <='9')||c =='.'};

// Elements returns a slice of the PdfObject elements in the array.
func (_afbf *PdfObjectArray )Elements ()[]PdfObject {if _afbf ==nil {return nil ;};return _afbf ._adcd ;};type objectStreams map[int ]objectStream ;func (_ddbd *PdfCrypt )loadCryptFilters (_cb *PdfObjectDictionary )error {_ddbd ._gac =cryptFilters {};_ccf :=_cb .Get ("\u0043\u0046");_ccf =TraceToDirectObject (_ccf );if _degb ,_bcd :=_ccf .(*PdfObjectReference );_bcd {_adg ,_ffab :=_ddbd ._feb .LookupByReference (*_degb );if _ffab !=nil {_be .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0075\u0070\u0020\u0043\u0046\u0020\u0072\u0065\u0066\u0065\u0072en\u0063\u0065");return _ffab ;};_ccf =TraceToDirectObject (_adg );};_bbge ,_fgab :=_ccf .(*PdfObjectDictionary );if !_fgab {_be .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0043\u0046\u002c \u0074\u0079\u0070\u0065: \u0025\u0054",_ccf );return _g .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0043\u0046");};for _ ,_gdfd :=range _bbge .Keys (){_fecc :=_bbge .Get (_gdfd );if _cdce ,_cea :=_fecc .(*PdfObjectReference );_cea {_fdb ,_fef :=_ddbd ._feb .LookupByReference (*_cdce );if _fef !=nil {_be .Log .Debug ("\u0045\u0072ro\u0072\u0020\u006co\u006f\u006b\u0075\u0070 up\u0020di\u0063\u0074\u0069\u006f\u006e\u0061\u0072y \u0072\u0065\u0066\u0065\u0072\u0065\u006ec\u0065");return _fef ;};_fecc =TraceToDirectObject (_fdb );};_ceed ,_cdf :=_fecc .(*PdfObjectDictionary );if !_cdf {return _e .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074\u0020\u0069\u006e \u0043\u0046\u0020\u0028\u006e\u0061\u006d\u0065\u0020\u0025\u0073\u0029\u0020-\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079\u0020\u0062\u0075\u0074\u0020\u0025\u0054",_gdfd ,_fecc );};if _gdfd =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{_be .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u002d\u0020\u0043\u0061\u006e\u006e\u006f\u0074\u0020\u006f\u0076\u0065\u0072\u0077r\u0069\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0069d\u0065\u006e\u0074\u0069\u0074\u0079\u0020\u0066\u0069\u006c\u0074\u0065\u0072 \u002d\u0020\u0054\u0072\u0079\u0069n\u0067\u0020\u006ee\u0078\u0074");continue ;};var _acg _da .FilterDict ;if _aeab :=_abc (&_acg ,_ceed );_aeab !=nil {return _aeab ;};_geg ,_bae :=_da .NewFilter (_acg );if _bae !=nil {return _bae ;};_ddbd ._gac [string (_gdfd )]=_geg ;};_ddbd ._gac ["\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"]=_da .NewIdentity ();_ddbd ._gfg ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _bcbb ,_ecc :=_cb .Get ("\u0053\u0074\u0072\u0046").(*PdfObjectName );_ecc {if _ ,_cbe :=_ddbd ._gac [string (*_bcbb )];!_cbe {return _e .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u0072\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_bcbb );};_ddbd ._gfg =string (*_bcbb );};_ddbd ._dfc ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _fgb ,_fdg :=_cb .Get ("\u0053\u0074\u006d\u0046").(*PdfObjectName );_fdg {if _ ,_ggag :=_ddbd ._gac [string (*_fgb )];!_ggag {return _e .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u006d\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_fgb );};_ddbd ._dfc =string (*_fgb );};return nil ;};

// MakeBool creates a PdfObjectBool from a bool value.
func MakeBool (val bool )*PdfObjectBool {_acfff :=PdfObjectBool (val );return &_acfff };func (_cbed *PdfParser )repairRebuildXrefsTopDown ()(*XrefTable ,error ){if _cbed ._cggd {return nil ,_e .Errorf ("\u0072\u0065\u0070\u0061\u0069\u0072\u0020\u0066\u0061\u0069\u006c\u0065\u0064");};_cbed ._cggd =true ;_cbed ._cedgd .Seek (0,_fec .SEEK_SET );_cbed ._fea =_ef .NewReader (_cbed ._cedgd );_ggea :=20;_agfd :=make ([]byte ,_ggea );_cbbf :=XrefTable {};_cbbf .ObjectMap =make (map[int ]XrefObject );for {_cebg ,_affc :=_cbed ._fea .ReadByte ();if _affc !=nil {if _affc ==_d .EOF {break ;}else {return nil ,_affc ;};};if _cebg =='j'&&_agfd [_ggea -1]=='b'&&_agfd [_ggea -2]=='o'&&IsWhiteSpace (_agfd [_ggea -3]){_fceb :=_ggea -4;for IsWhiteSpace (_agfd [_fceb ])&&_fceb > 0{_fceb --;};if _fceb ==0||!IsDecimalDigit (_agfd [_fceb ]){continue ;};for IsDecimalDigit (_agfd [_fceb ])&&_fceb > 0{_fceb --;};if _fceb ==0||!IsWhiteSpace (_agfd [_fceb ]){continue ;};for IsWhiteSpace (_agfd [_fceb ])&&_fceb > 0{_fceb --;};if _fceb ==0||!IsDecimalDigit (_agfd [_fceb ]){continue ;};for IsDecimalDigit (_agfd [_fceb ])&&_fceb > 0{_fceb --;};if _fceb ==0{continue ;};_geda :=_cbed .GetFileOffset ()-int64 (_ggea -_fceb );_bddg :=append (_agfd [_fceb +1:],_cebg );_cege ,_dbed ,_dabfe :=_cbffe (string (_bddg ));if _dabfe !=nil {_be .Log .Debug ("\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u006e\u0075\u006d\u0062\u0065r\u003a\u0020\u0025\u0076",_dabfe );return nil ,_dabfe ;};if _acfb ,_eega :=_cbbf .ObjectMap [_cege ];!_eega ||_acfb .Generation < _dbed {_eeeea :=XrefObject {};_eeeea .XType =XrefTypeTableEntry ;_eeeea .ObjectNumber =int (_cege );_eeeea .Generation =int (_dbed );_eeeea .Offset =_geda ;_cbbf .ObjectMap [_cege ]=_eeeea ;};};_agfd =append (_agfd [1:_ggea ],_cebg );};return &_cbbf ,nil ;};

// Len returns the number of elements in the array.
func (_bageb *PdfObjectArray )Len ()int {if _bageb ==nil {return 0;};return len (_bageb ._adcd );};func (_febb *PdfCrypt )checkAccessRights (_fbb []byte )(bool ,_ag .Permissions ,error ){_egfd :=_febb .securityHandler ();_bgedf ,_gfb ,_gba :=_egfd .Authenticate (&_febb ._deg ,_fbb );if _gba !=nil {return false ,0,_gba ;}else if _gfb ==0||len (_bgedf )==0{return false ,0,nil ;};return true ,_gfb ,nil ;};

// EncodeImage encodes 'img' golang image.Image into jbig2 encoded bytes document using default encoder settings.
func (_bfba *JBIG2Encoder )EncodeImage (img _ce .Image )([]byte ,error ){return _bfba .encodeImage (img )};

// JBIG2Encoder implements both jbig2 encoder and the decoder. The encoder allows to encode
// provided images (best used document scans) in multiple way. By default it uses single page generic
// encoder. It allows to store lossless data as a single segment.
// In order to store multiple image pages use the 'FileMode' which allows to store more pages within single jbig2 document.
// WIP: In order to obtain better compression results the encoder would allow to encode the input in a
// lossy or lossless way with a component (symbol) mode. It divides the image into components.
// Then checks if any component is 'similar' to the others and maps them together. The symbol classes are stored
// in the dictionary. Then the encoder creates text regions which uses the related symbol classes to fill it's space.
// The similarity is defined by the 'Threshold' variable (default: 0.95). The less the value is, the more components
// matches to single class, thus the compression is better, but the result might become lossy.
type JBIG2Encoder struct{

// These values are required to be set for the 'EncodeBytes' method.
// ColorComponents defines the number of color components for provided image.
ColorComponents int ;

// BitsPerComponent is the number of bits that stores per color component
BitsPerComponent int ;

// Width is the width of the image to encode
Width int ;

// Height is the height of the image to encode.
Height int ;_fcga *_eg .Document ;

// Globals are the JBIG2 global segments.
Globals _ca .Globals ;

// IsChocolateData defines if the data is encoded such that
// binary data '1' means black and '0' white.
// otherwise the data is called vanilla.
// Naming convention taken from: 'https://en.wikipedia.org/wiki/Binary_image#Interpretation'
IsChocolateData bool ;

// DefaultPageSettings are the settings parameters used by the jbig2 encoder.
DefaultPageSettings JBIG2EncoderSettings ;};

// EncodeBytes implements support for LZW encoding.  Currently not supporting predictors (raw compressed data only).
// Only supports the Early change = 1 algorithm (compress/lzw) as the other implementation
// does not have a write method.
// TODO: Consider refactoring compress/lzw to allow both.
func (_befced *LZWEncoder )EncodeBytes (data []byte )([]byte ,error ){if _befced .Predictor !=1{return nil ,_e .Errorf ("\u004c\u005aW \u0050\u0072\u0065d\u0069\u0063\u0074\u006fr =\u00201 \u006f\u006e\u006c\u0079\u0020\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0079e\u0074");};if _befced .EarlyChange ==1{return nil ,_e .Errorf ("\u004c\u005a\u0057\u0020\u0045\u0061\u0072\u006c\u0079\u0020\u0043\u0068\u0061n\u0067\u0065\u0020\u003d\u0020\u0030 \u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0079\u0065\u0074");};var _adge _fbd .Buffer ;_ffc :=_fe .NewWriter (&_adge ,_fe .MSB ,8);_ffc .Write (data );_ffc .Close ();return _adge .Bytes (),nil ;};

// String returns a string representation of the *PdfObjectString.
func (_fggge *PdfObjectString )String ()string {return _fggge ._fggfe };

// Str returns the string value of the PdfObjectString. Defined in addition to String() function to clarify that
// this function returns the underlying string directly, whereas the String function technically could include
// debug info.
func (_dbdgd *PdfObjectString )Str ()string {return _dbdgd ._fggfe };

// EncodeJBIG2Image encodes 'img' into jbig2 encoded bytes stream, using default encoder settings.
func (_dcae *JBIG2Encoder )EncodeJBIG2Image (img *JBIG2Image )([]byte ,error ){const _bagf ="c\u006f\u0072\u0065\u002eEn\u0063o\u0064\u0065\u004a\u0042\u0049G\u0032\u0049\u006d\u0061\u0067\u0065";if _aeagc :=_dcae .AddPageImage (img ,&_dcae .DefaultPageSettings );_aeagc !=nil {return nil ,_fbg .Wrap (_aeagc ,_bagf ,"");};return _dcae .Encode ();};

// EncryptInfo contains an information generated by the document encrypter.
type EncryptInfo struct{Version ;

// Encrypt is an encryption dictionary that contains all necessary parameters.
// It should be stored in all copies of the document trailer.
Encrypt *PdfObjectDictionary ;

// ID0 and ID1 are IDs used in the trailer. Older algorithms such as RC4 uses them for encryption.
ID0 ,ID1 string ;};func (_fdagf *PdfParser )traceStreamLength (_fgaeg PdfObject )(PdfObject ,error ){_beea ,_beafg :=_fgaeg .(*PdfObjectReference );if _beafg {_bfde ,_adgc :=_fdagf ._cfed [_beea .ObjectNumber ];if _adgc &&_bfde {_be .Log .Debug ("\u0053t\u0072\u0065a\u006d\u0020\u004c\u0065n\u0067\u0074\u0068 \u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065 u\u006e\u0072\u0065s\u006f\u006cv\u0065\u0064\u0020\u0028\u0069\u006cl\u0065\u0067a\u006c\u0029");return nil ,_g .New ("\u0069\u006c\u006c\u0065ga\u006c\u0020\u0072\u0065\u0063\u0075\u0072\u0073\u0069\u0076\u0065\u0020\u006c\u006fo\u0070");};_fdagf ._cfed [_beea .ObjectNumber ]=true ;};_acee ,_bdac :=_fdagf .Resolve (_fgaeg );if _bdac !=nil {return nil ,_bdac ;};_be .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_acee );if _beafg {_fdagf ._cfed [_beea .ObjectNumber ]=false ;};return _acee ,nil ;};func _dfcc ()string {return _be .Version };const (XrefTypeTableEntry xrefType =iota ;XrefTypeObjectStream xrefType =iota ;);

// Set sets the dictionary's key -> val mapping entry. Overwrites if key already set.
func (_eedd *PdfObjectDictionary )Set (key PdfObjectName ,val PdfObject ){_ ,_gdee :=_eedd ._cfdc [key ];if !_gdee {_eedd ._beeac =append (_eedd ._beeac ,key );};_eedd ._cfdc [key ]=val ;};

// DCTEncoder provides a DCT (JPG) encoding/decoding functionality for images.
type DCTEncoder struct{ColorComponents int ;BitsPerComponent int ;Width int ;Height int ;Quality int ;};

// WriteString outputs the object as it is to be written to file.
func (_baca *PdfObjectDictionary )WriteString ()string {var _cceb _bf .Builder ;_cceb .WriteString ("\u003c\u003c");for _ ,_fffa :=range _baca ._beeac {_bcae :=_baca ._cfdc [_fffa ];_cceb .WriteString (_fffa .WriteString ());_cceb .WriteString ("\u0020");_cceb .WriteString (_bcae .WriteString ());};_cceb .WriteString ("\u003e\u003e");return _cceb .String ();};func (_afae *PdfParser )parseObject ()(PdfObject ,error ){_be .Log .Trace ("\u0052e\u0061d\u0020\u0064\u0069\u0072\u0065c\u0074\u0020o\u0062\u006a\u0065\u0063\u0074");_afae .skipSpaces ();for {_cgcc ,_bdcd :=_afae ._fea .Peek (2);if _bdcd !=nil {if _bdcd !=_d .EOF ||len (_cgcc )==0{return nil ,_bdcd ;};if len (_cgcc )==1{_cgcc =append (_cgcc ,' ');};};_be .Log .Trace ("\u0050e\u0065k\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u003a\u0020\u0025\u0073",string (_cgcc ));if _cgcc [0]=='/'{_ddga ,_fbdd :=_afae .parseName ();_be .Log .Trace ("\u002d\u003e\u004ea\u006d\u0065\u003a\u0020\u0027\u0025\u0073\u0027",_ddga );return &_ddga ,_fbdd ;}else if _cgcc [0]=='('{_be .Log .Trace ("\u002d>\u0053\u0074\u0072\u0069\u006e\u0067!");_fdbac ,_fgc :=_afae .parseString ();return _fdbac ,_fgc ;}else if _cgcc [0]=='['{_be .Log .Trace ("\u002d\u003e\u0041\u0072\u0072\u0061\u0079\u0021");_aad ,_gagcc :=_afae .parseArray ();return _aad ,_gagcc ;}else if (_cgcc [0]=='<')&&(_cgcc [1]=='<'){_be .Log .Trace ("\u002d>\u0044\u0069\u0063\u0074\u0021");_ggdc ,_bafbg :=_afae .ParseDict ();return _ggdc ,_bafbg ;}else if _cgcc [0]=='<'{_be .Log .Trace ("\u002d\u003e\u0048\u0065\u0078\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0021");_ggdg ,_cec :=_afae .parseHexString ();return _ggdg ,_cec ;}else if _cgcc [0]=='%'{_afae .readComment ();_afae .skipSpaces ();}else {_be .Log .Trace ("\u002d\u003eN\u0075\u006d\u0062e\u0072\u0020\u006f\u0072\u0020\u0072\u0065\u0066\u003f");_cgcc ,_ =_afae ._fea .Peek (15);_ebcgc :=string (_cgcc );_be .Log .Trace ("\u0050\u0065\u0065k\u0020\u0073\u0074\u0072\u003a\u0020\u0025\u0073",_ebcgc );if (len (_ebcgc )> 3)&&(_ebcgc [:4]=="\u006e\u0075\u006c\u006c"){_dbaf ,_fdac :=_afae .parseNull ();return &_dbaf ,_fdac ;}else if (len (_ebcgc )> 4)&&(_ebcgc [:5]=="\u0066\u0061\u006cs\u0065"){_ggde ,_adba :=_afae .parseBool ();return &_ggde ,_adba ;}else if (len (_ebcgc )> 3)&&(_ebcgc [:4]=="\u0074\u0072\u0075\u0065"){_gcabe ,_facg :=_afae .parseBool ();return &_gcabe ,_facg ;};_gfgd :=_dcfb .FindStringSubmatch (string (_ebcgc ));if len (_gfgd )> 1{_cgcc ,_ =_afae ._fea .ReadBytes ('R');_be .Log .Trace ("\u002d\u003e\u0020\u0021\u0052\u0065\u0066\u003a\u0020\u0027\u0025\u0073\u0027",string (_cgcc [:]));_caggd ,_cbdfb :=_bbgecb (string (_cgcc ));_caggd ._dfcg =_afae ;return &_caggd ,_cbdfb ;};_efce :=_ggaa .FindStringSubmatch (string (_ebcgc ));if len (_efce )> 1{_be .Log .Trace ("\u002d\u003e\u0020\u004e\u0075\u006d\u0062\u0065\u0072\u0021");_gbf ,_fdcde :=_afae .parseNumber ();return _gbf ,_fdcde ;};_efce =_faa .FindStringSubmatch (string (_ebcgc ));if len (_efce )> 1{_be .Log .Trace ("\u002d\u003e\u0020\u0045xp\u006f\u006e\u0065\u006e\u0074\u0069\u0061\u006c\u0020\u004e\u0075\u006d\u0062\u0065r\u0021");_be .Log .Trace ("\u0025\u0020\u0073",_efce );_bfgf ,_bebc :=_afae .parseNumber ();return _bfgf ,_bebc ;};_be .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020U\u006e\u006b\u006e\u006f\u0077n\u0020(\u0070e\u0065\u006b\u0020\u0022\u0025\u0073\u0022)",_ebcgc );return nil ,_g .New ("\u006f\u0062\u006a\u0065\u0063t\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020\u0075\u006e\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e");};};};

// PdfObjectReference represents the primitive PDF reference object.
type PdfObjectReference struct{_dfcg *PdfParser ;ObjectNumber int64 ;GenerationNumber int64 ;};

// JBIG2EncoderSettings contains the parameters and settings used by the JBIG2Encoder.
// Current version works only on JB2Generic compression.
type JBIG2EncoderSettings struct{

// FileMode defines if the jbig2 encoder should return full jbig2 file instead of
// shortened pdf mode. This adds the file header to the jbig2 definition.
FileMode bool ;

// Compression is the setting that defines the compression type used for encoding the page.
Compression JBIG2CompressionType ;

// DuplicatedLinesRemoval code generic region in a way such that if the lines are duplicated the encoder
// doesn't store it twice.
DuplicatedLinesRemoval bool ;

// DefaultPixelValue is the bit value initial for every pixel in the page.
DefaultPixelValue uint8 ;

// ResolutionX optional setting that defines the 'x' axis input image resolution - used for single page encoding.
ResolutionX int ;

// ResolutionY optional setting that defines the 'y' axis input image resolution - used for single page encoding.
ResolutionY int ;

// Threshold defines the threshold of the image correlation for
// non Generic compression.
// User only for JB2SymbolCorrelation and JB2SymbolRankHaus methods.
// Best results in range [0.7 - 0.98] - the less the better the compression would be
// but the more lossy.
// Default value: 0.95
Threshold float64 ;};

// Clear resets the dictionary to an empty state.
func (_agaf *PdfObjectDictionary )Clear (){_agaf ._beeac =[]PdfObjectName {};_agaf ._cfdc =map[PdfObjectName ]PdfObject {};};func (_ebfb *PdfParser )xrefNextObjectOffset (_ebafc int64 )int64 {_bagff :=int64 (0);if len (_ebfb ._eegf .ObjectMap )==0{return 0;};if len (_ebfb ._eegf ._ee )==0{_feaf :=0;for _ ,_dfecd :=range _ebfb ._eegf .ObjectMap {if _dfecd .Offset > 0{_feaf ++;};};if _feaf ==0{return 0;};_ebfb ._eegf ._ee =make ([]XrefObject ,_feaf );_dcc :=0;for _ ,_gccf :=range _ebfb ._eegf .ObjectMap {if _gccf .Offset > 0{_ebfb ._eegf ._ee [_dcc ]=_gccf ;_dcc ++;};};_ad .Slice (_ebfb ._eegf ._ee ,func (_dddd ,_cccfc int )bool {return _ebfb ._eegf ._ee [_dddd ].Offset < _ebfb ._eegf ._ee [_cccfc ].Offset });};_bfda :=_ad .Search (len (_ebfb ._eegf ._ee ),func (_abdg int )bool {return _ebfb ._eegf ._ee [_abdg ].Offset >=_ebafc });if _bfda < len (_ebfb ._eegf ._ee ){_bagff =_ebfb ._eegf ._ee [_bfda ].Offset ;};return _bagff ;};

// DecodeBytes decodes a slice of LZW encoded bytes and returns the result.
func (_eeeb *LZWEncoder )DecodeBytes (encoded []byte )([]byte ,error ){var _bgfg _fbd .Buffer ;_afcb :=_fbd .NewReader (encoded );var _abba _d .ReadCloser ;if _eeeb .EarlyChange ==1{_abba =_ga .NewReader (_afcb ,_ga .MSB ,8);}else {_abba =_fe .NewReader (_afcb ,_fe .MSB ,8);};defer _abba .Close ();_ ,_adgg :=_bgfg .ReadFrom (_abba );if _adgg !=nil {return nil ,_adgg ;};return _bgfg .Bytes (),nil ;};

// ToFloat64Array returns a slice of all elements in the array as a float64 slice.  An error is
// returned if the array contains non-numeric objects (each element can be either PdfObjectInteger
// or PdfObjectFloat).
func (_fddec *PdfObjectArray )ToFloat64Array ()([]float64 ,error ){var _ffaec []float64 ;for _ ,_fdbag :=range _fddec .Elements (){switch _cadd :=_fdbag .(type ){case *PdfObjectInteger :_ffaec =append (_ffaec ,float64 (*_cadd ));case *PdfObjectFloat :_ffaec =append (_ffaec ,float64 (*_cadd ));default:return nil ,ErrTypeError ;};};return _ffaec ,nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_gadc *MultiEncoder )MakeStreamDict ()*PdfObjectDictionary {_ebdb :=MakeDict ();_ebdb .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",_gadc .GetFilterArray ());for _ ,_edee :=range _gadc ._geffa {_gbcbdb :=_edee .MakeStreamDict ();for _ ,_bagg :=range _gbcbdb .Keys (){_aefd :=_gbcbdb .Get (_bagg );if _bagg !="\u0046\u0069\u006c\u0074\u0065\u0072"&&_bagg !="D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"{_ebdb .Set (_bagg ,_aefd );};};};_dcf :=_gadc .MakeDecodeParams ();if _dcf !=nil {_ebdb .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_dcf );};return _ebdb ;};func (_abbea *PdfParser )loadXrefs ()(*PdfObjectDictionary ,error ){_abbea ._eegf .ObjectMap =make (map[int ]XrefObject );_abbea ._bbgec =make (objectStreams );_deabf ,_aaeb :=_abbea ._cedgd .Seek (0,_d .SeekEnd );if _aaeb !=nil {return nil ,_aaeb ;};_be .Log .Trace ("\u0066s\u0069\u007a\u0065\u003a\u0020\u0025d",_deabf );_abbea ._cgdf =_deabf ;_aaeb =_abbea .seekToEOFMarker (_deabf );if _aaeb !=nil {_be .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0073\u0065\u0065\u006b\u0020\u0074\u006f\u0020\u0065\u006f\u0066\u0020\u006d\u0061\u0072\u006b\u0065\u0072: \u0025\u0076",_aaeb );return nil ,_aaeb ;};_aeaga ,_aaeb :=_abbea ._cedgd .Seek (0,_d .SeekCurrent );if _aaeb !=nil {return nil ,_aaeb ;};var _gdgc int64 =64;_fada :=_aeaga -_gdgc ;if _fada < 0{_fada =0;};_ ,_aaeb =_abbea ._cedgd .Seek (_fada ,_d .SeekStart );if _aaeb !=nil {return nil ,_aaeb ;};_ddgeb :=make ([]byte ,_gdgc );_ ,_aaeb =_abbea ._cedgd .Read (_ddgeb );if _aaeb !=nil {_be .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u003a\u0020\u0025\u0076",_aaeb );return nil ,_aaeb ;};_eedc :=_acbab .FindStringSubmatch (string (_ddgeb ));if len (_eedc )< 2{_be .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020n\u006f\u0074\u0020f\u006fu\u006e\u0064\u0021");return nil ,_g .New ("\u0073\u0074\u0061\u0072tx\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};if len (_eedc )> 2{_be .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u004du\u006c\u0074\u0069\u0070\u006c\u0065\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029\u0021",_ddgeb );return nil ,_g .New ("m\u0075\u006c\u0074\u0069\u0070\u006ce\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065f\u0020\u0065\u006et\u0072i\u0065\u0073\u003f");};_fceg ,_ :=_a .ParseInt (_eedc [1],10,64);_be .Log .Trace ("\u0073t\u0061r\u0074\u0078\u0072\u0065\u0066\u0020\u0061\u0074\u0020\u0025\u0064",_fceg );if _fceg > _deabf {_be .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u006f\u0066f\u0073e\u0074 \u006fu\u0074\u0073\u0069\u0064\u0065\u0020\u006f\u0066\u0020\u0066\u0069\u006c\u0065");_be .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0072e\u0070\u0061\u0069\u0072");_fceg ,_aaeb =_abbea .repairLocateXref ();if _aaeb !=nil {_be .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0052\u0065\u0070\u0061\u0069\u0072\u0020\u0061\u0074\u0074\u0065\u006d\u0070t\u0020\u0066\u0061\u0069\u006c\u0065\u0064 \u0028\u0025\u0073\u0029");return nil ,_aaeb ;};};_abbea ._cedgd .Seek (int64 (_fceg ),_d .SeekStart );_abbea ._fea =_ef .NewReader (_abbea ._cedgd );_cdbdf ,_aaeb :=_abbea .parseXref ();if _aaeb !=nil {return nil ,_aaeb ;};_abgd :=_cdbdf .Get ("\u0058R\u0065\u0066\u0053\u0074\u006d");if _abgd !=nil {_beca ,_dcff :=_abgd .(*PdfObjectInteger );if !_dcff {return nil ,_g .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0021=\u0020\u0069\u006e\u0074");};_ ,_aaeb =_abbea .parseXrefStream (_beca );if _aaeb !=nil {return nil ,_aaeb ;};};var _edba []int64 ;_daab :=func (_cda int64 ,_afda []int64 )bool {for _ ,_bgcga :=range _afda {if _bgcga ==_cda {return true ;};};return false ;};_abgd =_cdbdf .Get ("\u0050\u0072\u0065\u0076");for _abgd !=nil {_edadc ,_efga :=_abgd .(*PdfObjectInteger );if !_efga {_be .Log .Debug ("\u0049\u006ev\u0061\u006c\u0069\u0064\u0020P\u0072\u0065\u0076\u0020\u0072e\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u003a\u0020\u004e\u006f\u0074\u0020\u0061\u0020\u002a\u0050\u0064\u0066\u004f\u0062\u006a\u0065\u0063\u0074\u0049\u006e\u0074\u0065\u0067\u0065\u0072\u0020\u0028\u0025\u0054\u0029",_abgd );return _cdbdf ,nil ;};_abfa :=*_edadc ;_be .Log .Trace ("\u0041\u006eot\u0068\u0065\u0072 \u0050\u0072\u0065\u0076 xr\u0065f \u0074\u0061\u0062\u006c\u0065\u0020\u006fbj\u0065\u0063\u0074\u0020\u0061\u0074\u0020%\u0064",_abfa );_abbea ._cedgd .Seek (int64 (_abfa ),_fec .SEEK_SET );_abbea ._fea =_ef .NewReader (_abbea ._cedgd );_bdagb ,_aeda :=_abbea .parseXref ();if _aeda !=nil {_be .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0045\u0072\u0072\u006f\u0072\u0020-\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u0061\u0064\u0069n\u0067\u0020\u0061\u006e\u006f\u0074\u0068\u0065\u0072\u0020\u0028\u0050re\u0076\u0029\u0020\u0074\u0072\u0061\u0069\u006c\u0065\u0072");_be .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0063\u006f\u006e\u0074\u0069n\u0075\u0065\u0020\u0062\u0079\u0020\u0069\u0067\u006e\u006f\u0072\u0069n\u0067\u0020\u0069\u0074");break ;};_abgd =_bdagb .Get ("\u0050\u0072\u0065\u0076");if _abgd !=nil {_gbbf :=*(_abgd .(*PdfObjectInteger ));if _daab (int64 (_gbbf ),_edba ){_be .Log .Debug ("\u0050\u0072ev\u0065\u006e\u0074i\u006e\u0067\u0020\u0063irc\u0075la\u0072\u0020\u0078\u0072\u0065\u0066\u0020re\u0066\u0065\u0072\u0065\u006e\u0063\u0069n\u0067");break ;};_edba =append (_edba ,int64 (_gbbf ));};};return _cdbdf ,nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_acde *RunLengthEncoder )MakeStreamDict ()*PdfObjectDictionary {_bab :=MakeDict ();_bab .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_acde .GetFilterName ()));return _bab ;};

// GetFilterName returns the name of the encoding filter.
func (_dcd *RunLengthEncoder )GetFilterName ()string {return StreamEncodingFilterNameRunLength };

// WriteString outputs the object as it is to be written to file.
func (_ebcf *PdfObjectFloat )WriteString ()string {return _a .FormatFloat (float64 (*_ebcf ),'f',-1,64);};

// EncodeBytes encodes the image data using either Group3 or Group4 CCITT facsimile (fax) encoding.
// `data` is expected to be 1 color component, 1 byte per component.
func (_agbg *CCITTFaxEncoder )EncodeBytes (data []byte )([]byte ,error ){var _bfed [][]byte ;for _cddeg :=0;_cddeg < len (data );_cddeg +=_agbg .Columns {_dabee :=make ([]byte ,_agbg .Columns );_fbdfa :=0;for _fbgd :=0;_fbgd < _agbg .Columns ;_fbgd ++{if data [_cddeg +_fbgd ]==255{_dabee [_fbdfa ]=1;}else {_dabee [_fbdfa ]=0;};_fbdfa ++;};_bfed =append (_bfed ,_dabee );};_fee :=&_de .Encoder {K :_agbg .K ,Columns :_agbg .Columns ,EndOfLine :_agbg .EndOfLine ,EndOfBlock :_agbg .EndOfBlock ,BlackIs1 :_agbg .BlackIs1 ,DamagedRowsBeforeError :_agbg .DamagedRowsBeforeError ,Rows :_agbg .Rows ,EncodedByteAlign :_agbg .EncodedByteAlign };return _fee .Encode (_bfed ),nil ;};func _egb (_fgaf *PdfObjectStream )(*MultiEncoder ,error ){_adbb :=NewMultiEncoder ();_ebef :=_fgaf .PdfObjectDictionary ;if _ebef ==nil {return _adbb ,nil ;};var _cba *PdfObjectDictionary ;var _becc []PdfObject ;_ecf :=_ebef .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _ecf !=nil {_edad ,_gffb :=_ecf .(*PdfObjectDictionary );if _gffb {_cba =_edad ;};_defd ,_gad :=_ecf .(*PdfObjectArray );if _gad {for _ ,_bgfgb :=range _defd .Elements (){_bgfgb =TraceToDirectObject (_bgfgb );if _gfdf ,_cbf :=_bgfgb .(*PdfObjectDictionary );_cbf {_becc =append (_becc ,_gfdf );}else {_becc =append (_becc ,MakeDict ());};};};};_ecf =_ebef .Get ("\u0046\u0069\u006c\u0074\u0065\u0072");if _ecf ==nil {return nil ,_e .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u006d\u0069s\u0073\u0069\u006e\u0067");};_acaa ,_aeaba :=_ecf .(*PdfObjectArray );if !_aeaba {return nil ,_e .Errorf ("m\u0075\u006c\u0074\u0069\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0063\u0061\u006e\u0020\u006f\u006el\u0079\u0020\u0062\u0065\u0020\u006d\u0061\u0064\u0065\u0020fr\u006f\u006d\u0020a\u0072r\u0061\u0079");};for _gacf ,_aae :=range _acaa .Elements (){_ddab ,_eadf :=_aae .(*PdfObjectName );if !_eadf {return nil ,_e .Errorf ("\u006d\u0075l\u0074\u0069\u0020\u0066i\u006c\u0074e\u0072\u0020\u0061\u0072\u0072\u0061\u0079\u0020e\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u006e\u006f\u0074\u0020\u0061 \u006e\u0061\u006d\u0065");};var _bacg PdfObject ;if _cba !=nil {_bacg =_cba ;}else {if len (_becc )> 0{if _gacf >=len (_becc ){return nil ,_e .Errorf ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0073\u0020\u0069\u006e\u0020d\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006d\u0073\u0020a\u0072\u0072\u0061\u0079");};_bacg =_becc [_gacf ];};};var _aced *PdfObjectDictionary ;if _cedf ,_gceb :=_bacg .(*PdfObjectDictionary );_gceb {_aced =_cedf ;};_be .Log .Trace ("\u004e\u0065\u0078t \u006e\u0061\u006d\u0065\u003a\u0020\u0025\u0073\u002c \u0064p\u003a \u0025v\u002c\u0020\u0064\u0050\u0061\u0072\u0061\u006d\u0073\u003a\u0020\u0025\u0076",*_ddab ,_bacg ,_aced );if *_ddab ==StreamEncodingFilterNameFlate {_gggc ,_fbac :=_bbff (_fgaf ,_aced );if _fbac !=nil {return nil ,_fbac ;};_adbb .AddEncoder (_gggc );}else if *_ddab ==StreamEncodingFilterNameLZW {_abgb ,_eebf :=_gagd (_fgaf ,_aced );if _eebf !=nil {return nil ,_eebf ;};_adbb .AddEncoder (_abgb );}else if *_ddab ==StreamEncodingFilterNameASCIIHex {_fdde :=NewASCIIHexEncoder ();_adbb .AddEncoder (_fdde );}else if *_ddab ==StreamEncodingFilterNameASCII85 {_bfcf :=NewASCII85Encoder ();_adbb .AddEncoder (_bfcf );}else if *_ddab ==StreamEncodingFilterNameDCT {_dacb ,_dgbca :=_ddge (_fgaf ,_adbb );if _dgbca !=nil {return nil ,_dgbca ;};_adbb .AddEncoder (_dacb );_be .Log .Trace ("A\u0064d\u0065\u0064\u0020\u0044\u0043\u0054\u0020\u0065n\u0063\u006f\u0064\u0065r.\u002e\u002e");_be .Log .Trace ("\u004du\u006ct\u0069\u0020\u0065\u006e\u0063o\u0064\u0065r\u003a\u0020\u0025\u0023\u0076",_adbb );}else {_be .Log .Error ("U\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0066\u0069l\u0074\u0065\u0072\u0020\u0025\u0073",*_ddab );return nil ,_e .Errorf ("\u0069\u006eva\u006c\u0069\u0064 \u0066\u0069\u006c\u0074er \u0069n \u006d\u0075\u006c\u0074\u0069\u0020\u0066il\u0074\u0065\u0072\u0020\u0061\u0072\u0072a\u0079");};};return _adbb ,nil ;};var _gbdg =_ge .MustCompile ("\u0025P\u0044F\u002d\u0028\u005c\u0064\u0029\u005c\u002e\u0028\u005c\u0064\u0029");

// String returns a string describing `ind`.
func (_fgdbc *PdfIndirectObject )String ()string {return _e .Sprintf ("\u0049\u004f\u0062\u006a\u0065\u0063\u0074\u003a\u0025\u0064",(*_fgdbc ).ObjectNumber );};

// EncodeBytes DCT encodes the passed in slice of bytes.
func (_dac *DCTEncoder )EncodeBytes (data []byte )([]byte ,error ){_fdae ,_dcgf :=_bea .NewImage (_dac .Width ,_dac .Height ,_dac .BitsPerComponent ,_dac .ColorComponents ,data ,nil ,nil );if _dcgf !=nil {return nil ,_dcgf ;};_bgde :=_b .Options {};_bgde .Quality =_dac .Quality ;var _ggbe _fbd .Buffer ;if _dcgf =_b .Encode (&_ggbe ,_fdae ,&_bgde );_dcgf !=nil {return nil ,_dcgf ;};return _ggbe .Bytes (),nil ;};

// DecodeStream decodes the stream containing CCITTFax encoded image data.
func (_gbgag *CCITTFaxEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _gbgag .DecodeBytes (streamObj .Stream );};func (_fbe *PdfParser )parseHexString ()(*PdfObjectString ,error ){_fbe ._fea .ReadByte ();var _gdde _fbd .Buffer ;for {_accc ,_fdcf :=_fbe ._fea .Peek (1);if _fdcf !=nil {return MakeString (""),_fdcf ;};if _accc [0]=='>'{_fbe ._fea .ReadByte ();break ;};_dbae ,_ :=_fbe ._fea .ReadByte ();if !IsWhiteSpace (_dbae ){_gdde .WriteByte (_dbae );};};if _gdde .Len ()%2==1{_gdde .WriteRune ('0');};_afbgf ,_ :=_cd .DecodeString (_gdde .String ());return MakeHexString (string (_afbgf )),nil ;};func _bbff (_beb *PdfObjectStream ,_befc *PdfObjectDictionary )(*FlateEncoder ,error ){_abf :=NewFlateEncoder ();_egdc :=_beb .PdfObjectDictionary ;if _egdc ==nil {return _abf ,nil ;};_abf ._cbc =_dfce (_egdc );if _befc ==nil {_gbe :=TraceToDirectObject (_egdc .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));switch _acd :=_gbe .(type ){case *PdfObjectArray :_bdea :=_acd ;if _bdea .Len ()!=1{_be .Log .Debug ("\u0045\u0072\u0072\u006f\u0072:\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020a\u0072\u0072\u0061\u0079\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0021\u003d\u0020\u0031\u0020\u0028\u0025\u0064\u0029",_bdea .Len ());return nil ,_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_gbe =TraceToDirectObject (_bdea .Get (0));case *PdfObjectDictionary :_befc =_acd ;case *PdfObjectNull ,nil :default:_be .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020n\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079 \u0028%\u0054\u0029",_gbe );return nil ,_e .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _befc ==nil {return _abf ,nil ;};_be .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_befc .String ());_aece :=_befc .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");if _aece ==nil {_be .Log .Debug ("E\u0072\u0072o\u0072\u003a\u0020\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067 \u0066\u0072\u006f\u006d\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073 \u002d\u0020\u0043\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020\u0077\u0069t\u0068\u0020\u0064\u0065\u0066\u0061\u0075\u006c\u0074\u0020\u00281\u0029");}else {_dbda ,_eeed :=_aece .(*PdfObjectInteger );if !_eeed {_be .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_aece );return nil ,_e .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_abf .Predictor =int (*_dbda );};_aece =_befc .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");if _aece !=nil {_afga ,_feca :=_aece .(*PdfObjectInteger );if !_feca {_be .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");return nil ,_e .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_abf .BitsPerComponent =int (*_afga );};if _abf .Predictor > 1{_abf .Columns =1;_aece =_befc .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");if _aece !=nil {_fda ,_ebff :=_aece .(*PdfObjectInteger );if !_ebff {return nil ,_e .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_abf .Columns =int (*_fda );};_abf .Colors =1;_aece =_befc .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _aece !=nil {_gbag ,_ccbb :=_aece .(*PdfObjectInteger );if !_ccbb {return nil ,_e .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");};_abf .Colors =int (*_gbag );};};return _abf ,nil ;};func (_aefde *PdfParser )repairSeekXrefMarker ()error {_fdgbc ,_aecdf :=_aefde ._cedgd .Seek (0,_fec .SEEK_END );if _aecdf !=nil {return _aecdf ;};_cfgbe :=_ge .MustCompile ("\u005cs\u0078\u0072\u0065\u0066\u005c\u0073*");var _gfce int64 ;var _fbcg int64 =1000;for _gfce < _fdgbc {if _fdgbc <=(_fbcg +_gfce ){_fbcg =_fdgbc -_gfce ;};_ ,_efdab :=_aefde ._cedgd .Seek (-_gfce -_fbcg ,_fec .SEEK_END );if _efdab !=nil {return _efdab ;};_fadeg :=make ([]byte ,_fbcg );_aefde ._cedgd .Read (_fadeg );_be .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0078\u0072\u0065\u0066\u0020\u003a\u0020\u0022\u0025\u0073\u0022",string (_fadeg ));_fgfee :=_cfgbe .FindAllStringIndex (string (_fadeg ),-1);if _fgfee !=nil {_ccdd :=_fgfee [len (_fgfee )-1];_be .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_fgfee );_aefde ._cedgd .Seek (-_gfce -_fbcg +int64 (_ccdd [0]),_fec .SEEK_END );_aefde ._fea =_ef .NewReader (_aefde ._cedgd );for {_cccb ,_addf :=_aefde ._fea .Peek (1);if _addf !=nil {return _addf ;};_be .Log .Trace ("\u0042\u003a\u0020\u0025\u0064\u0020\u0025\u0063",_cccb [0],_cccb [0]);if !IsWhiteSpace (_cccb [0]){break ;};_aefde ._fea .Discard (1);};return nil ;};_be .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");_gfce +=_fbcg ;};_be .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074a\u0062\u006c\u0065\u0020\u006d\u0061r\u006b\u0065\u0072\u0020\u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066o\u0075\u006e\u0064\u002e");return _g .New ("\u0078r\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0020");};type objectStream struct{N int ;_fg []byte ;_gf map[int ]int64 ;};func (_eggd *PdfParser )parseArray ()(*PdfObjectArray ,error ){_aecg :=MakeArray ();_eggd ._fea .ReadByte ();for {_eggd .skipSpaces ();_dgaad ,_affa :=_eggd ._fea .Peek (1);if _affa !=nil {return _aecg ,_affa ;};if _dgaad [0]==']'{_eggd ._fea .ReadByte ();break ;};_faee ,_affa :=_eggd .parseObject ();if _affa !=nil {return _aecg ,_affa ;};_aecg .Append (_faee );};return _aecg ,nil ;};const (DefaultJPEGQuality =75;);func _cbffe (_eadg string )(int ,int ,error ){_gbgb :=_edbf .FindStringSubmatch (_eadg );if len (_gbgb )< 3{return 0,0,_g .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");};_agdf ,_ :=_a .Atoi (_gbgb [1]);_gcef ,_ :=_a .Atoi (_gbgb [2]);return _agdf ,_gcef ,nil ;};

// GetName returns the *PdfObjectName represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetName (obj PdfObject )(_egad *PdfObjectName ,_ffcb bool ){_egad ,_ffcb =TraceToDirectObject (obj ).(*PdfObjectName );return _egad ,_ffcb ;};func (_aagd *PdfCrypt )decryptBytes (_ace []byte ,_dbf string ,_ccdg []byte )([]byte ,error ){_be .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");_cdd ,_cab :=_aagd ._gac [_dbf ];if !_cab {return nil ,_e .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_dbf );};return _cdd .DecryptBytes (_ace ,_ccdg );};

// String returns a string describing `d`.
func (_egggb *PdfObjectDictionary )String ()string {var _gcgc _bf .Builder ;_gcgc .WriteString ("\u0044\u0069\u0063t\u0028");for _ ,_efgge :=range _egggb ._beeac {_gbbe :=_egggb ._cfdc [_efgge ];_gcgc .WriteString ("\u0022"+_efgge .String ()+"\u0022\u003a\u0020");_gcgc .WriteString (_gbbe .String ());_gcgc .WriteString ("\u002c\u0020");};_gcgc .WriteString ("\u0029");return _gcgc .String ();};

// NewCCITTFaxEncoder makes a new CCITTFax encoder.
func NewCCITTFaxEncoder ()*CCITTFaxEncoder {return &CCITTFaxEncoder {Columns :1728,EndOfBlock :true }};func (_ebage *PdfParser )parseXref ()(*PdfObjectDictionary ,error ){const _fdcfe =20;_fgafg ,_ :=_ebage ._fea .Peek (_fdcfe );for _ebfgd :=0;_ebfgd < 2;_ebfgd ++{if _ebage ._ddfd ==0{_ebage ._ddfd =_ebage .GetFileOffset ();};if _edbf .Match (_fgafg ){_be .Log .Trace ("\u0078\u0072e\u0066\u0020\u0070\u006f\u0069\u006e\u0074\u0073\u0020\u0074\u006f\u0020\u0061\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u002e\u0020\u0050\u0072\u006f\u0062\u0061\u0062\u006c\u0079\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063\u0074");_be .Log .Debug ("\u0073t\u0061r\u0074\u0069\u006e\u0067\u0020w\u0069\u0074h\u0020\u0022\u0025\u0073\u0022",string (_fgafg ));return _ebage .parseXrefStream (nil );};if _fddg .Match (_fgafg ){_be .Log .Trace ("\u0053\u0074\u0061\u006ed\u0061\u0072\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073e\u0063t\u0069\u006f\u006e\u0020\u0074\u0061\u0062l\u0065\u0021");return _ebage .parseXrefTable ();};_dcaea :=_ebage .GetFileOffset ();if _ebage ._ddfd ==0{_ebage ._ddfd =_dcaea ;};_ebage .SetFileOffset (_dcaea -_fdcfe );defer _ebage .SetFileOffset (_dcaea );_adae ,_ :=_ebage ._fea .Peek (_fdcfe );_fgafg =append (_adae ,_fgafg ...);};_be .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u0078\u0072\u0065f\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006fr\u0020\u0073\u0074\u0072\u0065\u0061\u006d.\u0020\u0052\u0065\u0070\u0061i\u0072\u0020\u0061\u0074\u0074e\u006d\u0070\u0074\u0065\u0064\u003a\u0020\u004c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0065\u0061\u0072\u006c\u0069\u0065\u0073\u0074\u0020x\u0072\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u0062\u006f\u0074to\u006d\u002e");if _fbcda :=_ebage .repairSeekXrefMarker ();_fbcda !=nil {_be .Log .Debug ("\u0052e\u0070a\u0069\u0072\u0020\u0066\u0061i\u006c\u0065d\u0020\u002d\u0020\u0025\u0076",_fbcda );return nil ,_fbcda ;};return _ebage .parseXrefTable ();};

// String returns the state of the bool as "true" or "false".
func (_beda *PdfObjectBool )String ()string {if *_beda {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};func (_cdg *PdfParser )lookupByNumber (_ced int ,_bcc bool )(PdfObject ,bool ,error ){_caeg ,_bbf :=_cdg .ObjCache [_ced ];if _bbf {_be .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0063a\u0063\u0068\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0025\u0064",_ced );return _caeg ,false ,nil ;};_gae ,_bbf :=_cdg ._eegf .ObjectMap [_ced ];if !_bbf {_be .Log .Trace ("\u0055\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u006c\u006f\u0063\u0061t\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0069\u006e\u0020\u0078\u0072\u0065\u0066\u0073\u0021 \u002d\u0020\u0052\u0065\u0074u\u0072\u006e\u0069\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074");var _afg PdfObjectNull ;return &_afg ,false ,nil ;};_be .Log .Trace ("L\u006fo\u006b\u0075\u0070\u0020\u006f\u0062\u006a\u0020n\u0075\u006d\u0062\u0065r \u0025\u0064",_ced );if _gae .XType ==XrefTypeTableEntry {_be .Log .Trace ("\u0078r\u0065f\u006f\u0062\u006a\u0020\u006fb\u006a\u0020n\u0075\u006d\u0020\u0025\u0064",_gae .ObjectNumber );_be .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u0067e\u006e\u0020\u0025\u0064",_gae .Generation );_be .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0064",_gae .Offset );_cdg ._cedgd .Seek (_gae .Offset ,_fec .SEEK_SET );_cdg ._fea =_ef .NewReader (_cdg ._cedgd );_bd ,_fga :=_cdg .ParseIndirectObject ();if _fga !=nil {_be .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006ce\u0064\u0020\u0072\u0065\u0061\u0064\u0069n\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029",_fga );if _bcc {_be .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0072\u0065\u0070\u0061\u0069r\u0020\u0078\u0072\u0065\u0066\u0073\u0020\u0028\u0074\u006f\u0070\u0020d\u006f\u0077\u006e\u0029");_ffa ,_ed :=_cdg .repairRebuildXrefsTopDown ();if _ed !=nil {_be .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020r\u0065\u0070\u0061\u0069\u0072\u0020\u0028\u0025\u0073\u0029",_ed );return nil ,false ,_ed ;};_cdg ._eegf =*_ffa ;return _cdg .lookupByNumber (_ced ,false );};return nil ,false ,_fga ;};if _bcc {_aba ,_ ,_ :=_eab (_bd );if int (_aba )!=_ced {_be .Log .Debug ("\u0049n\u0076\u0061\u006c\u0069d\u0020\u0078\u0072\u0065\u0066s\u003a \u0052e\u0062\u0075\u0069\u006c\u0064\u0069\u006eg");_aeg :=_cdg .rebuildXrefTable ();if _aeg !=nil {return nil ,false ,_aeg ;};_cdg .ObjCache =objectCache {};return _cdg .lookupByNumberWrapper (_ced ,false );};};_be .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006f\u0062\u006a");_cdg .ObjCache [_ced ]=_bd ;return _bd ,false ,nil ;}else if _gae .XType ==XrefTypeObjectStream {_be .Log .Trace ("\u0078r\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0021");_be .Log .Trace ("\u003e\u004c\u006f\u0061\u0064\u0020\u0076\u0069\u0061\u0020\u004f\u0053\u0021");_be .Log .Trace ("\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d \u0061\u0076\u0061\u0069\u006c\u0061b\u006c\u0065\u0020\u0069\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020%\u0064\u002f\u0025\u0064",_gae .OsObjNumber ,_gae .OsObjIndex );if _gae .OsObjNumber ==_ced {_be .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0043i\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065f\u0065\u0072\u0065n\u0063e\u0021\u003f\u0021");return nil ,true ,_g .New ("\u0078\u0072\u0065f \u0063\u0069\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");};if _ ,_cdgc :=_cdg ._eegf .ObjectMap [_gae .OsObjNumber ];_cdgc {_egg ,_fgf :=_cdg .lookupObjectViaOS (_gae .OsObjNumber ,_ced );if _fgf !=nil {_be .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0052\u0065\u0074\u0075\u0072\u006e\u0069n\u0067\u0020\u0045\u0052\u0052\u0020\u0028\u0025\u0073\u0029",_fgf );return nil ,true ,_fgf ;};_be .Log .Trace ("\u003c\u004c\u006f\u0061\u0064\u0065\u0064\u0020\u0076i\u0061\u0020\u004f\u0053");_cdg .ObjCache [_ced ]=_egg ;if _cdg ._edaf !=nil {_cdg ._edaf ._bff [_egg ]=true ;};return _egg ,true ,nil ;};_be .Log .Debug ("\u003f\u003f\u0020\u0042\u0065\u006c\u006f\u006eg\u0073\u0020\u0074o \u0061\u0020\u006e\u006f\u006e\u002dc\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u002e.\u002e\u0021");return nil ,true ,_g .New ("\u006f\u0073\u0020\u0062\u0065\u006c\u006fn\u0067\u0073\u0020t\u006f\u0020\u0061\u0020n\u006f\u006e\u0020\u0063\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074");};return nil ,false ,_g .New ("\u0075\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0078\u0072\u0065\u0066 \u0074\u0079\u0070\u0065");};

// XrefObject defines a cross reference entry which is a map between object number (with generation number) and the
// location of the actual object, either as a file offset (xref table entry), or as a location within an xref
// stream object (xref object stream).
type XrefObject struct{XType xrefType ;ObjectNumber int ;Generation int ;

// For normal xrefs (defined by OFFSET)
Offset int64 ;

// For xrefs to object streams.
OsObjNumber int ;OsObjIndex int ;};var _fecdf =_ge .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064+\u0029\u005c\u0073\u002b\u0028\u005b\u006e\u0066\u005d\u0029\\\u0073\u002a\u0024");

// GetFilterName returns the name of the encoding filter.
func (_bgca *FlateEncoder )GetFilterName ()string {return StreamEncodingFilterNameFlate };

// GetXrefTable returns the PDFs xref table.
func (_dfbf *PdfParser )GetXrefTable ()XrefTable {return _dfbf ._eegf };

// MakeObjectStreams creates an PdfObjectStreams from a list of PdfObjects.
func MakeObjectStreams (objects ...PdfObject )*PdfObjectStreams {_geee :=&PdfObjectStreams {};_geee ._adfg =[]PdfObject {};for _ ,_dece :=range objects {_geee ._adfg =append (_geee ._adfg ,_dece );};return _geee ;};

// PdfObjectDictionary represents the primitive PDF dictionary/map object.
type PdfObjectDictionary struct{_cfdc map[PdfObjectName ]PdfObject ;_beeac []PdfObjectName ;_gdac *PdfParser ;};

// PdfObjectArray represents the primitive PDF array object.
type PdfObjectArray struct{_adcd []PdfObject };

// GetNumberAsFloat returns the contents of `obj` as a float if it is an integer or float, or an
// error if it isn't.
func GetNumberAsFloat (obj PdfObject )(float64 ,error ){switch _cff :=obj .(type ){case *PdfObjectFloat :return float64 (*_cff ),nil ;case *PdfObjectInteger :return float64 (*_cff ),nil ;};return 0,ErrNotANumber ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set.  Some other parameters are generated elsewhere.
func (_ceae *DCTEncoder )MakeStreamDict ()*PdfObjectDictionary {_dabdd :=MakeDict ();_dabdd .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_ceae .GetFilterName ()));return _dabdd ;};

// CheckAccessRights checks access rights and permissions for a specified password. If either user/owner password is
// specified, full rights are granted, otherwise the access rights are specified by the Permissions flag.
//
// The bool flag indicates that the user can access and view the file.
// The AccessPermissions shows what access the user has for editing etc.
// An error is returned if there was a problem performing the authentication.
func (_gcda *PdfParser )CheckAccessRights (password []byte )(bool ,_ag .Permissions ,error ){if _gcda ._edaf ==nil {return true ,_ag .PermOwner ,nil ;};return _gcda ._edaf .checkAccessRights (password );};

// MakeHexString creates an PdfObjectString from a string intended for output as a hexadecimal string.
func MakeHexString (s string )*PdfObjectString {_aeeb :=PdfObjectString {_fggfe :s ,_gdbg :true };return &_aeeb ;};

// MakeDict creates and returns an empty PdfObjectDictionary.
func MakeDict ()*PdfObjectDictionary {_gcgf :=&PdfObjectDictionary {};_gcgf ._cfdc =map[PdfObjectName ]PdfObject {};_gcgf ._beeac =[]PdfObjectName {};return _gcgf ;};

// PdfCryptNewEncrypt makes the document crypt handler based on a specified crypt filter.
func PdfCryptNewEncrypt (cf _da .Filter ,userPass ,ownerPass []byte ,perm _ag .Permissions )(*PdfCrypt ,*EncryptInfo ,error ){_bdg :=&PdfCrypt {_gagf :make (map[PdfObject ]bool ),_gac :make (cryptFilters ),_deg :_ag .StdEncryptDict {P :perm ,EncryptMetadata :true }};var _bbd Version ;if cf !=nil {_dd :=cf .PDFVersion ();_bbd .Major ,_bbd .Minor =_dd [0],_dd [1];V ,R :=cf .HandlerVersion ();_bdg ._efd .V =V ;_bdg ._deg .R =R ;_bdg ._efd .Length =cf .KeyLength ()*8;};const (_ebf =_gaeg ;);_bdg ._gac [_ebf ]=cf ;if _bdg ._efd .V >=4{_bdg ._dfc =_ebf ;_bdg ._gfg =_ebf ;};_cee :=_bdg .newEncryptDict ();_edf :=_gg .Sum ([]byte (_df .Now ().Format (_df .RFC850 )));_ffe :=string (_edf [:]);_daef :=make ([]byte ,100);_fd .Read (_daef );_edf =_gg .Sum (_daef );_gga :=string (_edf [:]);_be .Log .Trace ("\u0052\u0061\u006e\u0064\u006f\u006d\u0020\u0062\u003a\u0020\u0025\u0020\u0078",_daef );_be .Log .Trace ("\u0047\u0065\u006e\u0020\u0049\u0064\u0020\u0030\u003a\u0020\u0025\u0020\u0078",_ffe );_bdg ._geff =string (_ffe );_eac :=_bdg .generateParams (userPass ,ownerPass );if _eac !=nil {return nil ,nil ,_eac ;};_fcc (&_bdg ._deg ,_cee );if _bdg ._efd .V >=4{if _gef :=_bdg .saveCryptFilters (_cee );_gef !=nil {return nil ,nil ,_gef ;};};return _bdg ,&EncryptInfo {Version :_bbd ,Encrypt :_cee ,ID0 :_ffe ,ID1 :_gga },nil ;};

// PdfObjectFloat represents the primitive PDF floating point numerical object.
type PdfObjectFloat float64 ;

// MultiEncoder supports serial encoding.
type MultiEncoder struct{_geffa []StreamEncoder };

// Set sets the PdfObject at index i of the streams. An error is returned if the index is outside bounds.
func (_aegg *PdfObjectStreams )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_aegg ._adfg ){return _g .New ("\u004f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_aegg ._adfg [i ]=obj ;return nil ;};const (StreamEncodingFilterNameFlate ="F\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameLZW ="\u004cZ\u0057\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameDCT ="\u0044C\u0054\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameRunLength ="\u0052u\u006eL\u0065\u006e\u0067\u0074\u0068\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameASCIIHex ="\u0041\u0053\u0043\u0049\u0049\u0048\u0065\u0078\u0044e\u0063\u006f\u0064\u0065";StreamEncodingFilterNameASCII85 ="\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameCCITTFax ="\u0043\u0043\u0049\u0054\u0054\u0046\u0061\u0078\u0044e\u0063\u006f\u0064\u0065";StreamEncodingFilterNameJBIG2 ="J\u0042\u0049\u0047\u0032\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameJPX ="\u004aP\u0058\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameRaw ="\u0052\u0061\u0077";);

// MakeInteger creates a PdfObjectInteger from an int64.
func MakeInteger (val int64 )*PdfObjectInteger {_eefe :=PdfObjectInteger (val );return &_eefe };

// DecodeStream decodes the stream data and returns the decoded data.
// An error is returned upon failure.
func DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_be .Log .Trace ("\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_dceg ,_bdaf :=NewEncoderFromStream (streamObj );if _bdaf !=nil {_be .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_bdaf );return nil ,_bdaf ;};_be .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076\u000a",_dceg );_cgacc ,_bdaf :=_dceg .DecodeStream (streamObj );if _bdaf !=nil {_be .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_bdaf );return nil ,_bdaf ;};return _cgacc ,nil ;};func _bbfab (_dfad PdfObject )(*float64 ,error ){switch _aceg :=_dfad .(type ){case *PdfObjectFloat :_afge :=float64 (*_aceg );return &_afge ,nil ;case *PdfObjectInteger :_caada :=float64 (*_aceg );return &_caada ,nil ;case *PdfObjectNull :return nil ,nil ;};return nil ,ErrNotANumber ;};

// WriteString outputs the object as it is to be written to file.
func (_edebg *PdfIndirectObject )WriteString ()string {var _dggc _bf .Builder ;_dggc .WriteString (_a .FormatInt (_edebg .ObjectNumber ,10));_dggc .WriteString ("\u0020\u0030\u0020\u0052");return _dggc .String ();};

// MakeStreamDict make a new instance of an encoding dictionary for a stream object.
func (_deed *ASCII85Encoder )MakeStreamDict ()*PdfObjectDictionary {_feba :=MakeDict ();_feba .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_deed .GetFilterName ()));return _feba ;};

// GetFilterName returns the names of the underlying encoding filters,
// separated by spaces.
// Note: This is just a string, should not be used in /Filter dictionary entry. Use GetFilterArray for that.
// TODO(v4): Refactor to GetFilter() which can be used for /Filter (either Name or Array), this can be
//  renamed to String() as a pretty string to use in debugging etc.
func (_cbeg *MultiEncoder )GetFilterName ()string {_dfb :="";for _fecbc ,_dade :=range _cbeg ._geffa {_dfb +=_dade .GetFilterName ();if _fecbc < len (_cbeg ._geffa )-1{_dfb +="\u0020";};};return _dfb ;};

// FlattenObject returns the contents of `obj`. In other words, `obj` with indirect objects replaced
// by their values.
// The replacements are made recursively to a depth of traceMaxDepth.
// NOTE: Dicts are sorted to make objects with same contents have the same PDF object strings.
func FlattenObject (obj PdfObject )PdfObject {return _fffg (obj ,0)};

// GetFloat returns the *PdfObjectFloat represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetFloat (obj PdfObject )(_acgdg *PdfObjectFloat ,_afgdf bool ){_acgdg ,_afgdf =TraceToDirectObject (obj ).(*PdfObjectFloat );return _acgdg ,_afgdf ;};

// XrefTable represents the cross references in a PDF, i.e. the table of objects and information
// where to access within the PDF file.
type XrefTable struct{ObjectMap map[int ]XrefObject ;_ee []XrefObject ;};type offsetReader struct{_eecc _d .ReadSeeker ;_cgbf int64 ;};

// String returns a string describing `array`.
func (_bgeba *PdfObjectArray )String ()string {_aegb :="\u005b";for _bfgfb ,_dcaf :=range _bgeba .Elements (){_aegb +=_dcaf .String ();if _bfgfb < (_bgeba .Len ()-1){_aegb +="\u002c\u0020";};};_aegb +="\u005d";return _aegb ;};func _eab (_eeb PdfObject )(int64 ,int64 ,error ){if _aa ,_cae :=_eeb .(*PdfIndirectObject );_cae {return _aa .ObjectNumber ,_aa .GenerationNumber ,nil ;};if _aeb ,_ab :=_eeb .(*PdfObjectStream );_ab {return _aeb .ObjectNumber ,_aeb .GenerationNumber ,nil ;};return 0,0,_g .New ("\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u002f\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062je\u0063\u0074");};

// Elements returns a slice of the PdfObject elements in the array.
// Preferred over accessing the array directly as type may be changed in future major versions (v3).
func (_fccd *PdfObjectStreams )Elements ()[]PdfObject {if _fccd ==nil {return nil ;};return _fccd ._adfg ;};

// PdfObjectName represents the primitive PDF name object.
type PdfObjectName string ;

// SetIfNotNil sets the dictionary's key -> val mapping entry -IF- val is not nil.
// Note that we take care to perform a type switch.  Otherwise if we would supply a nil value
// of another type, e.g. (PdfObjectArray*)(nil), then it would not be a PdfObject(nil) and thus
// would get set.
func (_gebb *PdfObjectDictionary )SetIfNotNil (key PdfObjectName ,val PdfObject ){if val !=nil {switch _ddeb :=val .(type ){case *PdfObjectName :if _ddeb !=nil {_gebb .Set (key ,val );};case *PdfObjectDictionary :if _ddeb !=nil {_gebb .Set (key ,val );};case *PdfObjectStream :if _ddeb !=nil {_gebb .Set (key ,val );};case *PdfObjectString :if _ddeb !=nil {_gebb .Set (key ,val );};case *PdfObjectNull :if _ddeb !=nil {_gebb .Set (key ,val );};case *PdfObjectInteger :if _ddeb !=nil {_gebb .Set (key ,val );};case *PdfObjectArray :if _ddeb !=nil {_gebb .Set (key ,val );};case *PdfObjectBool :if _ddeb !=nil {_gebb .Set (key ,val );};case *PdfObjectFloat :if _ddeb !=nil {_gebb .Set (key ,val );};case *PdfObjectReference :if _ddeb !=nil {_gebb .Set (key ,val );};case *PdfIndirectObject :if _ddeb !=nil {_gebb .Set (key ,val );};default:_be .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",val );};};};func (_fgga *ASCII85Encoder )base256Tobase85 (_ggbg uint32 )[5]byte {_eaaf :=[5]byte {0,0,0,0,0};_cbef :=_ggbg ;for _fgdb :=0;_fgdb < 5;_fgdb ++{_fgdbd :=uint32 (1);for _bfg :=0;_bfg < 4-_fgdb ;_bfg ++{_fgdbd *=85;};_cgab :=_cbef /_fgdbd ;_cbef =_cbef %_fgdbd ;_eaaf [_fgdb ]=byte (_cgab );};return _eaaf ;};

// MakeIndirectObject creates an PdfIndirectObject with a specified direct object PdfObject.
func MakeIndirectObject (obj PdfObject )*PdfIndirectObject {_gdgcd :=&PdfIndirectObject {};_gdgcd .PdfObject =obj ;return _gdgcd ;};const JB2ImageAutoThreshold =-1.0;

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_adfb *FlateEncoder )MakeStreamDict ()*PdfObjectDictionary {_ccdc :=MakeDict ();_ccdc .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_adfb .GetFilterName ()));_abe :=_adfb .MakeDecodeParams ();if _abe !=nil {_ccdc .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_abe );};return _ccdc ;};

// DecodeBytes decodes byte array with ASCII85. 5 ASCII characters -> 4 raw binary bytes
func (_eeda *ASCII85Encoder )DecodeBytes (encoded []byte )([]byte ,error ){var _bccg []byte ;_be .Log .Trace ("\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0020\u0044e\u0063\u006f\u0064\u0065");_gdg :=0;_bcgb :=false ;for _gdg < len (encoded )&&!_bcgb {_fgdf :=[5]byte {0,0,0,0,0};_deb :=0;_ede :=0;_gdfdb :=4;for _ede < 5+_deb {if _gdg +_ede ==len (encoded ){break ;};_eaa :=encoded [_gdg +_ede ];if IsWhiteSpace (_eaa ){_deb ++;_ede ++;continue ;}else if _eaa =='~'&&_gdg +_ede +1< len (encoded )&&encoded [_gdg +_ede +1]=='>'{_gdfdb =(_ede -_deb )-1;if _gdfdb < 0{_gdfdb =0;};_bcgb =true ;break ;}else if _eaa >='!'&&_eaa <='u'{_eaa -='!';}else if _eaa =='z'&&_ede -_deb ==0{_gdfdb =4;_ede ++;break ;}else {_be .Log .Error ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u002c\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020co\u0064\u0065");return nil ,_g .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0063\u006f\u0064\u0065\u0020e\u006e\u0063\u006f\u0075\u006e\u0074\u0065\u0072\u0065\u0064");};_fgdf [_ede -_deb ]=_eaa ;_ede ++;};_gdg +=_ede ;for _gbdd :=_gdfdb +1;_gbdd < 5;_gbdd ++{_fgdf [_gbdd ]=84;};_cadc :=uint32 (_fgdf [0])*85*85*85*85+uint32 (_fgdf [1])*85*85*85+uint32 (_fgdf [2])*85*85+uint32 (_fgdf [3])*85+uint32 (_fgdf [4]);_ceaf :=[]byte {byte ((_cadc >>24)&0xff),byte ((_cadc >>16)&0xff),byte ((_cadc >>8)&0xff),byte (_cadc &0xff)};_bccg =append (_bccg ,_ceaf [:_gdfdb ]...);};_be .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0065\u006e\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",encoded );_be .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0064\u0065\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",_bccg );return _bccg ,nil ;};func (_cfgb *PdfParser )resolveReference (_dcac *PdfObjectReference )(PdfObject ,bool ,error ){_gdgb ,_ebeg :=_cfgb .ObjCache [int (_dcac .ObjectNumber )];if _ebeg {return _gdgb ,true ,nil ;};_ddgg ,_dfaf :=_cfgb .LookupByReference (*_dcac );if _dfaf !=nil {return nil ,false ,_dfaf ;};_cfgb .ObjCache [int (_dcac .ObjectNumber )]=_ddgg ;return _ddgg ,false ,nil ;};

// EncodeBytes encodes slice of bytes into JBIG2 encoding format.
// The input 'data' must be an image. In order to Decode it a user is responsible to
// load the codec ('png', 'jpg').
// Returns jbig2 single page encoded document byte slice. The encoder uses DefaultPageSettings
// to encode given image.
func (_eae *JBIG2Encoder )EncodeBytes (data []byte )([]byte ,error ){const _cabfd ="\u004aB\u0049\u0047\u0032\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002eE\u006e\u0063\u006f\u0064\u0065\u0042\u0079\u0074\u0065\u0073";if _eae .ColorComponents !=1||_eae .BitsPerComponent !=1{return nil ,_fbg .Errorf (_cabfd ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u002e\u0020\u004a\u0042\u0049G\u0032\u0020E\u006e\u0063o\u0064\u0065\u0072\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020bi\u006e\u0061\u0072\u0079\u0020\u0069\u006d\u0061\u0067e\u0073\u0020\u0064\u0061\u0074\u0061");};var (_daag *_cdc .Bitmap ;_ada error ;);_ffba :=(_eae .Width *_eae .Height )==len (data );if _ffba {_daag ,_ada =_cdc .NewWithUnpaddedData (_eae .Width ,_eae .Height ,data );}else {_daag ,_ada =_cdc .NewWithData (_eae .Width ,_eae .Height ,data );};if _ada !=nil {return nil ,_ada ;};_fgfec :=_eae .DefaultPageSettings ;if _ada =_fgfec .Validate ();_ada !=nil {return nil ,_fbg .Wrap (_ada ,_cabfd ,"");};switch _fgfec .Compression {case JB2Generic :if _ada =_eae ._fcga .AddGenericPage (_daag ,_fgfec .DuplicatedLinesRemoval );_ada !=nil {return nil ,_fbg .Wrap (_ada ,_cabfd ,"");};case JB2SymbolCorrelation :return nil ,_fbg .Error (_cabfd ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");case JB2SymbolRankHaus :return nil ,_fbg .Error (_cabfd ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");default:return nil ,_fbg .Error (_cabfd ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return _eae .Encode ();};

// DecodeBytes decodes a byte slice from Run length encoding.
//
// 7.4.5 RunLengthDecode Filter
// The RunLengthDecode filter decodes data that has been encoded in a simple byte-oriented format based on run length.
// The encoded data shall be a sequence of runs, where each run shall consist of a length byte followed by 1 to 128
// bytes of data. If the length byte is in the range 0 to 127, the following length + 1 (1 to 128) bytes shall be
// copied literally during decompression. If length is in the range 129 to 255, the following single byte shall be
// copied 257 - length (2 to 128) times during decompression. A length value of 128 shall denote EOD.
func (_fab *RunLengthEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_caed :=_fbd .NewReader (encoded );var _abcea []byte ;for {_dag ,_ccce :=_caed .ReadByte ();if _ccce !=nil {return nil ,_ccce ;};if _dag > 128{_agab ,_bbcb :=_caed .ReadByte ();if _bbcb !=nil {return nil ,_bbcb ;};for _gaf :=0;_gaf < 257-int (_dag );_gaf ++{_abcea =append (_abcea ,_agab );};}else if _dag < 128{for _bca :=0;_bca < int (_dag )+1;_bca ++{_ece ,_ffbb :=_caed .ReadByte ();if _ffbb !=nil {return nil ,_ffbb ;};_abcea =append (_abcea ,_ece );};}else {break ;};};return _abcea ,nil ;};

// Append appends PdfObject(s) to the streams.
func (_cgfb *PdfObjectStreams )Append (objects ...PdfObject ){if _cgfb ==nil {_be .Log .Debug ("\u0057\u0061\u0072\u006e\u0020-\u0020\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0020\u0074\u006f\u0020\u0061p\u0070\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0073");return ;};if _cgfb ._adfg ==nil {_cgfb ._adfg =[]PdfObject {};};for _ ,_cfead :=range objects {_cgfb ._adfg =append (_cgfb ._adfg ,_cfead );};};

// UpdateParams updates the parameter values of the encoder.
// Implements StreamEncoder interface.
func (_dadea *JBIG2Encoder )UpdateParams (params *PdfObjectDictionary ){_ffdc ,_cgdc :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _cgdc ==nil {_dadea .BitsPerComponent =int (_ffdc );};_edff ,_cgdc :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _cgdc ==nil {_dadea .Width =int (_edff );};_gge ,_cgdc :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _cgdc ==nil {_dadea .Height =int (_gge );};_fafd ,_cgdc :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _cgdc ==nil {_dadea .ColorComponents =int (_fafd );};};

// WriteString outputs the object as it is to be written to file.
func (_bdge *PdfObjectReference )WriteString ()string {var _beec _bf .Builder ;_beec .WriteString (_a .FormatInt (_bdge .ObjectNumber ,10));_beec .WriteString ("\u0020");_beec .WriteString (_a .FormatInt (_bdge .GenerationNumber ,10));_beec .WriteString ("\u0020\u0052");return _beec .String ();};func _fccg (_ggce int )int {if _ggce < 0{return -_ggce ;};return _ggce ;};

// LookupByNumber looks up a PdfObject by object number.  Returns an error on failure.
func (_aff *PdfParser )LookupByNumber (objNumber int )(PdfObject ,error ){_fed ,_ ,_bb :=_aff .lookupByNumberWrapper (objNumber ,true );return _fed ,_bb ;};

// GetBool returns the *PdfObjectBool object that is represented by a PdfObject directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetBool (obj PdfObject )(_afgg *PdfObjectBool ,_fbeg bool ){_afgg ,_fbeg =TraceToDirectObject (obj ).(*PdfObjectBool );return _afgg ,_fbeg ;};

// Len returns the number of elements in the streams.
func (_bbfbf *PdfObjectStreams )Len ()int {if _bbfbf ==nil {return 0;};return len (_bbfbf ._adfg );};

// UpdateParams updates the parameter values of the encoder.
func (_gdeg *RawEncoder )UpdateParams (params *PdfObjectDictionary ){};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_abb *FlateEncoder )MakeDecodeParams ()PdfObject {if _abb .Predictor > 1{_dbfb :=MakeDict ();_dbfb .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_abb .Predictor )));if _abb .BitsPerComponent !=8{_dbfb .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_abb .BitsPerComponent )));};if _abb .Columns !=1{_dbfb .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_abb .Columns )));};if _abb .Colors !=1{_dbfb .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_abb .Colors )));};return _dbfb ;};return nil ;};

// String returns a descriptive information string about the encryption method used.
func (_efe *PdfCrypt )String ()string {if _efe ==nil {return "";};_dadg :=_efe ._efd .Filter +"\u0020\u002d\u0020";if _efe ._efd .V ==0{_dadg +="\u0055\u006e\u0064\u006fcu\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0061\u006c\u0067\u006f\u0072\u0069\u0074h\u006d";}else if _efe ._efd .V ==1{_dadg +="\u0052\u0043\u0034:\u0020\u0034\u0030\u0020\u0062\u0069\u0074\u0073";}else if _efe ._efd .V ==2{_dadg +=_e .Sprintf ("\u0052\u0043\u0034:\u0020\u0025\u0064\u0020\u0062\u0069\u0074\u0073",_efe ._efd .Length );}else if _efe ._efd .V ==3{_dadg +="U\u006e\u0070\u0075\u0062li\u0073h\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d";}else if _efe ._efd .V >=4{_dadg +=_e .Sprintf ("\u0053\u0074r\u0065\u0061\u006d\u0020f\u0069\u006ct\u0065\u0072\u003a\u0020\u0025\u0073\u0020\u002d \u0053\u0074\u0072\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0074\u0065r\u003a\u0020\u0025\u0073",_efe ._dfc ,_efe ._gfg );_dadg +="\u003b\u0020C\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0073\u003a";for _ade ,_gdd :=range _efe ._gac {_dadg +=_e .Sprintf ("\u0020\u002d\u0020\u0025\u0073\u003a\u0020\u0025\u0073 \u0028\u0025\u0064\u0029",_ade ,_gdd .Name (),_gdd .KeyLength ());};};_aea :=_efe .GetAccessPermissions ();_dadg +=_e .Sprintf ("\u0020\u002d\u0020\u0025\u0023\u0076",_aea );return _dadg ;};

// PdfIndirectObject represents the primitive PDF indirect object.
type PdfIndirectObject struct{PdfObjectReference ;PdfObject ;};

// IsAuthenticated returns true if the PDF has already been authenticated for accessing.
func (_agdb *PdfParser )IsAuthenticated ()bool {return _agdb ._edaf ._bdc };

// ParseIndirectObject parses an indirect object from the input stream. Can also be an object stream.
// Returns the indirect object (*PdfIndirectObject) or the stream object (*PdfObjectStream).
func (_fdgg *PdfParser )ParseIndirectObject ()(PdfObject ,error ){_ggdca :=PdfIndirectObject {};_ggdca ._dfcg =_fdgg ;_be .Log .Trace ("\u002dR\u0065a\u0064\u0020\u0069\u006e\u0064i\u0072\u0065c\u0074\u0020\u006f\u0062\u006a");_fbadd ,_fgfc :=_fdgg ._fea .Peek (20);if _fgfc !=nil {if _fgfc !=_d .EOF {_be .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020r\u0065a\u0064\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a");return &_ggdca ,_fgfc ;};};_be .Log .Trace ("\u0028\u0069\u006edi\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_fbadd ));_bfbc :=_edbf .FindStringSubmatchIndex (string (_fbadd ));if len (_bfbc )< 6{if _fgfc ==_d .EOF {return nil ,_fgfc ;};_be .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_fbadd ));return &_ggdca ,_g .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");};_fdgg ._fea .Discard (_bfbc [0]);_be .Log .Trace ("O\u0066\u0066\u0073\u0065\u0074\u0073\u0020\u0025\u0020\u0064",_bfbc );_edbfc :=_bfbc [1]-_bfbc [0];_adfbd :=make ([]byte ,_edbfc );_ ,_fgfc =_fdgg .ReadAtLeast (_adfbd ,_edbfc );if _fgfc !=nil {_be .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u0072\u0065\u0061\u0064\u0020-\u0020\u0025\u0073",_fgfc );return nil ,_fgfc ;};_be .Log .Trace ("\u0074\u0065\u0078t\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_adfbd );_geac :=_edbf .FindStringSubmatch (string (_adfbd ));if len (_geac )< 3{_be .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_adfbd ));return &_ggdca ,_g .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");};_dcea ,_ :=_a .Atoi (_geac [1]);_fgfef ,_ :=_a .Atoi (_geac [2]);_ggdca .ObjectNumber =int64 (_dcea );_ggdca .GenerationNumber =int64 (_fgfef );for {_cbff ,_daea :=_fdgg ._fea .Peek (2);if _daea !=nil {return &_ggdca ,_daea ;};_be .Log .Trace ("I\u006ed\u002e\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_cbff ),string (_cbff ));if IsWhiteSpace (_cbff [0]){_fdgg .skipSpaces ();}else if _cbff [0]=='%'{_fdgg .skipComments ();}else if (_cbff [0]=='<')&&(_cbff [1]=='<'){_be .Log .Trace ("\u0043\u0061\u006c\u006c\u0020\u0050\u0061\u0072\u0073e\u0044\u0069\u0063\u0074");_ggdca .PdfObject ,_daea =_fdgg .ParseDict ();_be .Log .Trace ("\u0045\u004f\u0046\u0020Ca\u006c\u006c\u0020\u0050\u0061\u0072\u0073\u0065\u0044\u0069\u0063\u0074\u003a\u0020%\u0076",_daea );if _daea !=nil {return &_ggdca ,_daea ;};_be .Log .Trace ("\u0050\u0061\u0072\u0073\u0065\u0064\u0020\u0064\u0069\u0063t\u0069\u006f\u006e\u0061\u0072\u0079\u002e.\u002e\u0020\u0066\u0069\u006e\u0069\u0073\u0068\u0065\u0064\u002e");}else if (_cbff [0]=='/')||(_cbff [0]=='(')||(_cbff [0]=='[')||(_cbff [0]=='<'){_ggdca .PdfObject ,_daea =_fdgg .parseObject ();if _daea !=nil {return &_ggdca ,_daea ;};_be .Log .Trace ("P\u0061\u0072\u0073\u0065\u0064\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u002e\u002e\u002e \u0066\u0069\u006ei\u0073h\u0065\u0064\u002e");}else if _cbff [0]==']'{_be .Log .Debug ("\u0057\u0041\u0052\u004e\u0049N\u0047\u003a\u0020\u0027\u005d\u0027 \u0063\u0068\u0061\u0072\u0061\u0063\u0074e\u0072\u0020\u006eo\u0074\u0020\u0062\u0065i\u006e\u0067\u0020\u0075\u0073\u0065d\u0020\u0061\u0073\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006e\u0064\u0069n\u0067\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e");_fdgg ._fea .Discard (1);}else {if _cbff [0]=='e'{_gdaea ,_efdae :=_fdgg .readTextLine ();if _efdae !=nil {return nil ,_efdae ;};if len (_gdaea )>=6&&_gdaea [0:6]=="\u0065\u006e\u0064\u006f\u0062\u006a"{break ;};}else if _cbff [0]=='s'{_cbff ,_ =_fdgg ._fea .Peek (10);if string (_cbff [:6])=="\u0073\u0074\u0072\u0065\u0061\u006d"{_cgde :=6;if len (_cbff )> 6{if IsWhiteSpace (_cbff [_cgde ])&&_cbff [_cgde ]!='\r'&&_cbff [_cgde ]!='\n'{_be .Log .Debug ("\u004e\u006fn\u002d\u0063\u006f\u006e\u0066\u006f\u0072\u006d\u0061\u006e\u0074\u0020\u0050\u0044\u0046\u0020\u006e\u006f\u0074 \u0065\u006e\u0064\u0069\u006e\u0067 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0069\u006e\u0065\u0020\u0070\u0072o\u0070\u0065r\u006c\u0079\u0020\u0077i\u0074\u0068\u0020\u0045\u004fL\u0020\u006d\u0061\u0072\u006b\u0065\u0072");_cgde ++;};if _cbff [_cgde ]=='\r'{_cgde ++;if _cbff [_cgde ]=='\n'{_cgde ++;};}else if _cbff [_cgde ]=='\n'{_cgde ++;};};_fdgg ._fea .Discard (_cgde );_bfcg ,_dfgg :=_ggdca .PdfObject .(*PdfObjectDictionary );if !_dfgg {return nil ,_g .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006di\u0073s\u0069\u006e\u0067\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_be .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0069c\u0074\u0020\u0025\u0073",_bfcg );_daee ,_egecf :=_fdgg .traceStreamLength (_bfcg .Get ("\u004c\u0065\u006e\u0067\u0074\u0068"));if _egecf !=nil {_be .Log .Debug ("\u0046\u0061\u0069l\u0020\u0074\u006f\u0020t\u0072\u0061\u0063\u0065\u0020\u0073\u0074r\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0025\u0076",_egecf );return nil ,_egecf ;};_be .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_daee );_gaggc ,_gfdd :=_daee .(*PdfObjectInteger );if !_gfdd {return nil ,_g .New ("\u0073\u0074re\u0061\u006d\u0020l\u0065\u006e\u0067\u0074h n\u0065ed\u0073\u0020\u0074\u006f\u0020\u0062\u0065 a\u006e\u0020\u0069\u006e\u0074\u0065\u0067e\u0072");};_gaa :=*_gaggc ;if _gaa < 0{return nil ,_g .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006e\u0065\u0065\u0064\u0073\u0020\u0074\u006f \u0062e\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0030");};_dbfge :=_fdgg .GetFileOffset ();_ccbf :=_fdgg .xrefNextObjectOffset (_dbfge );if _dbfge +int64 (_gaa )> _ccbf &&_ccbf > _dbfge {_be .Log .Debug ("E\u0078\u0070\u0065\u0063te\u0064 \u0065\u006e\u0064\u0069\u006eg\u0020\u0061\u0074\u0020\u0025\u0064",_dbfge +int64 (_gaa ));_be .Log .Debug ("\u004e\u0065\u0078\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020\u0061t\u0020\u0025\u0064",_ccbf );_cceg :=_ccbf -_dbfge -17;if _cceg < 0{return nil ,_g .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020go\u0069\u006e\u0067 \u0070\u0061s\u0074\u0020\u0062\u006f\u0075\u006ed\u0061\u0072i\u0065\u0073");};_be .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0061\u0020l\u0065\u006e\u0067\u0074\u0068\u0020c\u006f\u0072\u0072\u0065\u0063\u0074\u0069\u006f\u006e\u0020\u0074\u006f\u0020%\u0064\u002e\u002e\u002e",_cceg );_gaa =PdfObjectInteger (_cceg );_bfcg .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (_cceg ));};if int64 (_gaa )> _fdgg ._cgdf {_be .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0053t\u0072\u0065\u0061\u006d\u0020l\u0065\u006e\u0067\u0074\u0068\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u0061\u0072\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0066\u0069\u006c\u0065\u0020\u0073\u0069\u007a\u0065");return nil ,_g .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020la\u0072\u0067\u0065r\u0020\u0074h\u0061\u006e\u0020\u0066\u0069\u006ce\u0020\u0073i\u007a\u0065");};_dgegg :=make ([]byte ,_gaa );_ ,_egecf =_fdgg .ReadAtLeast (_dgegg ,int (_gaa ));if _egecf !=nil {_be .Log .Debug ("E\u0052\u0052\u004f\u0052 s\u0074r\u0065\u0061\u006d\u0020\u0028%\u0064\u0029\u003a\u0020\u0025\u0058",len (_dgegg ),_dgegg );_be .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_egecf );return nil ,_egecf ;};_gabe :=PdfObjectStream {};_gabe .Stream =_dgegg ;_gabe .PdfObjectDictionary =_ggdca .PdfObject .(*PdfObjectDictionary );_gabe .ObjectNumber =_ggdca .ObjectNumber ;_gabe .GenerationNumber =_ggdca .GenerationNumber ;_gabe .PdfObjectReference ._dfcg =_fdgg ;_fdgg .skipSpaces ();_fdgg ._fea .Discard (9);_fdgg .skipSpaces ();return &_gabe ,nil ;};};_ggdca .PdfObject ,_daea =_fdgg .parseObject ();if _ggdca .PdfObject ==nil {_be .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");_ggdca .PdfObject =MakeNull ();};return &_ggdca ,_daea ;};};if _ggdca .PdfObject ==nil {_be .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");_ggdca .PdfObject =MakeNull ();};_be .Log .Trace ("\u0052\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0021");return &_ggdca ,nil ;};

// Set sets the PdfObject at index i of the array. An error is returned if the index is outside bounds.
func (_feec *PdfObjectArray )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_feec ._adcd ){return _g .New ("\u006f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_feec ._adcd [i ]=obj ;return nil ;};

// IsWhiteSpace checks if byte represents a white space character.
func IsWhiteSpace (ch byte )bool {if (ch ==0x00)||(ch ==0x09)||(ch ==0x0A)||(ch ==0x0C)||(ch ==0x0D)||(ch ==0x20){return true ;};return false ;};

// EncodeBytes ASCII encodes the passed in slice of bytes.
func (_dda *ASCIIHexEncoder )EncodeBytes (data []byte )([]byte ,error ){var _abbe _fbd .Buffer ;for _ ,_fecd :=range data {_abbe .WriteString (_e .Sprintf ("\u0025\u002e\u0032X\u0020",_fecd ));};_abbe .WriteByte ('>');return _abbe .Bytes (),nil ;};

// GetInt returns the *PdfObjectBool object that is represented by a PdfObject either directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetInt (obj PdfObject )(_ddfg *PdfObjectInteger ,_dgbdd bool ){_ddfg ,_dgbdd =TraceToDirectObject (obj ).(*PdfObjectInteger );return _ddfg ,_dgbdd ;};

// PdfCrypt provides PDF encryption/decryption support.
// The PDF standard supports encryption of strings and streams (Section 7.6).
type PdfCrypt struct{_efd encryptDict ;_deg _ag .StdEncryptDict ;_geff string ;_ggb []byte ;_bff map[PdfObject ]bool ;_gagf map[PdfObject ]bool ;_bdc bool ;_gac cryptFilters ;_dfc string ;_gfg string ;_feb *PdfParser ;_afgd map[int ]struct{};};const _ffgb =10;

// StreamEncoder represents the interface for all PDF stream encoders.
type StreamEncoder interface{GetFilterName ()string ;MakeDecodeParams ()PdfObject ;MakeStreamDict ()*PdfObjectDictionary ;UpdateParams (_ffea *PdfObjectDictionary );EncodeBytes (_gddf []byte )([]byte ,error );DecodeBytes (_aca []byte )([]byte ,error );DecodeStream (_dfe *PdfObjectStream )([]byte ,error );};

// DecodeStream decodes a DCT encoded stream and returns the result as a
// slice of bytes.
func (_bcdg *DCTEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _bcdg .DecodeBytes (streamObj .Stream );};

// GetFilterName returns the name of the encoding filter.
func (_dbcea *DCTEncoder )GetFilterName ()string {return StreamEncodingFilterNameDCT };

// IsDelimiter checks if a character represents a delimiter.
func IsDelimiter (c byte )bool {return c =='('||c ==')'||c =='<'||c =='>'||c =='['||c ==']'||c =='{'||c =='}'||c =='/'||c =='%';};

// MakeArrayFromFloats creates an PdfObjectArray from a slice of float64s, where each array element is an
// PdfObjectFloat.
func MakeArrayFromFloats (vals []float64 )*PdfObjectArray {_gddg :=MakeArray ();for _ ,_cadce :=range vals {_gddg .Append (MakeFloat (_cadce ));};return _gddg ;};

// GetArray returns the *PdfObjectArray represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetArray (obj PdfObject )(_adbe *PdfObjectArray ,_faab bool ){_adbe ,_faab =TraceToDirectObject (obj ).(*PdfObjectArray );return _adbe ,_faab ;};

// MakeArrayFromIntegers creates an PdfObjectArray from a slice of ints, where each array element is
// an PdfObjectInteger.
func MakeArrayFromIntegers (vals []int )*PdfObjectArray {_bfgfg :=MakeArray ();for _ ,_dgbf :=range vals {_bfgfg .Append (MakeInteger (int64 (_dgbf )));};return _bfgfg ;};

// EncodeBytes encodes the passed in slice of bytes by passing it through the
// EncodeBytes method of the underlying encoders.
func (_cfbf *MultiEncoder )EncodeBytes (data []byte )([]byte ,error ){_fafe :=data ;var _bcag error ;for _ebbb :=len (_cfbf ._geffa )-1;_ebbb >=0;_ebbb --{_badc :=_cfbf ._geffa [_ebbb ];_fafe ,_bcag =_badc .EncodeBytes (_fafe );if _bcag !=nil {return nil ,_bcag ;};};return _fafe ,nil ;};

// Append appends PdfObject(s) to the array.
func (_gcdab *PdfObjectArray )Append (objects ...PdfObject ){if _gcdab ==nil {_be .Log .Debug ("\u0057\u0061\u0072\u006e\u0020\u002d\u0020\u0041\u0074\u0074\u0065\u006d\u0070t\u0020\u0074\u006f\u0020\u0061\u0070p\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020a\u0072\u0072\u0061\u0079");return ;};if _gcdab ._adcd ==nil {_gcdab ._adcd =[]PdfObject {};};for _ ,_fefbf :=range objects {_gcdab ._adcd =append (_gcdab ._adcd ,_fefbf );};};func (_fcd *PdfCrypt )isEncrypted (_agg PdfObject )bool {_ ,_afgf :=_fcd ._gagf [_agg ];if _afgf {_be .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0065\u006e\u0063\u0072y\u0070\u0074\u0065\u0064");return true ;};_be .Log .Trace ("\u004e\u006f\u0074\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");return false ;};

// EncodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_edeb *RawEncoder )EncodeBytes (data []byte )([]byte ,error ){return data ,nil };

// GetFileOffset returns the current file offset, accounting for buffered position.
func (_agd *PdfParser )GetFileOffset ()int64 {_fbdfe ,_ :=_agd ._cedgd .Seek (0,_d .SeekCurrent );_fbdfe -=int64 (_agd ._fea .Buffered ());return _fbdfe ;};func (_cbde *offsetReader )Seek (offset int64 ,whence int )(int64 ,error ){if whence ==_d .SeekStart {offset +=_cbde ._cgbf ;};_gbgg ,_fggg :=_cbde ._eecc .Seek (offset ,whence );if _fggg !=nil {return _gbgg ,_fggg ;};if whence ==_d .SeekCurrent {_gbgg -=_cbde ._cgbf ;};if _gbgg < 0{return 0,_g .New ("\u0063\u006f\u0072\u0065\u002eo\u0066\u0066\u0073\u0065\u0074\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053e\u0065\u006b\u003a\u0020\u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e");};return _gbgg ,nil ;};

// WriteString outputs the object as it is to be written to file.
func (_bded *PdfObjectStreams )WriteString ()string {var _fcdd _bf .Builder ;_fcdd .WriteString (_a .FormatInt (_bded .ObjectNumber ,10));_fcdd .WriteString ("\u0020\u0030\u0020\u0052");return _fcdd .String ();};

// UpdateParams updates the parameter values of the encoder.
func (_agae *MultiEncoder )UpdateParams (params *PdfObjectDictionary ){for _ ,_fgdc :=range _agae ._geffa {_fgdc .UpdateParams (params );};};func (_dad *PdfParser )lookupObjectViaOS (_bg int ,_dae int )(PdfObject ,error ){var _bgd *_fbd .Reader ;var _eff objectStream ;var _gc bool ;_eff ,_gc =_dad ._bbgec [_bg ];if !_gc {_fc ,_bgf :=_dad .LookupByNumber (_bg );if _bgf !=nil {_be .Log .Debug ("\u004d\u0069ss\u0069\u006e\u0067 \u006f\u0062\u006a\u0065ct \u0073tr\u0065\u0061\u006d\u0020\u0077\u0069\u0074h \u006e\u0075\u006d\u0062\u0065\u0072\u0020%\u0064",_bg );return nil ,_bgf ;};_gb ,_cga :=_fc .(*PdfObjectStream );if !_cga {return nil ,_g .New ("i\u006e\u0076\u0061\u006cid\u0020o\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d");};if _dad ._edaf !=nil &&!_dad ._edaf .isDecrypted (_gb ){return nil ,_g .New ("\u006e\u0065\u0065\u0064\u0020\u0074\u006f\u0020\u0064\u0065\u0063r\u0079\u0070\u0074\u0020\u0074\u0068\u0065\u0020\u0073\u0074r\u0065\u0061\u006d");};_dec :=_gb .PdfObjectDictionary ;_be .Log .Trace ("\u0073o\u0020\u0064\u003a\u0020\u0025\u0073\n",_dec .String ());_gd ,_cga :=_dec .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if !_cga {_be .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0061\u006c\u0077\u0061\u0079\u0073\u0020\u0068\u0061\u0076\u0065\u0020\u0061\u0020\u0054\u0079\u0070\u0065");return nil ,_g .New ("\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020T\u0079\u0070\u0065");};if _bf .ToLower (string (*_gd ))!="\u006f\u0062\u006a\u0073\u0074\u006d"{_be .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0074\u0079\u0070\u0065\u0020s\u0068\u0061\u006c\u006c\u0020\u0061\u006c\u0077\u0061\u0079\u0073 \u0062\u0065\u0020\u004f\u0062\u006a\u0053\u0074\u006d\u0020\u0021");return nil ,_g .New ("\u006f\u0062\u006a\u0065c\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0074y\u0070e\u0020\u0021\u003d\u0020\u004f\u0062\u006aS\u0074\u006d");};N ,_cga :=_dec .Get ("\u004e").(*PdfObjectInteger );if !_cga {return nil ,_g .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u004e\u0020i\u006e\u0020\u0073\u0074\u0072\u0065\u0061m\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_bc ,_cga :=_dec .Get ("\u0046\u0069\u0072s\u0074").(*PdfObjectInteger );if !_cga {return nil ,_g .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0046\u0069\u0072\u0073\u0074\u0020i\u006e \u0073t\u0072e\u0061\u006d\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_be .Log .Trace ("\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0073\u0020\u006eu\u006d\u0062\u0065\u0072\u0020\u006f\u0066 \u006f\u0062\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_gd ,*N );_bfe ,_bgf :=DecodeStream (_gb );if _bgf !=nil {return nil ,_bgf ;};_be .Log .Trace ("D\u0065\u0063\u006f\u0064\u0065\u0064\u003a\u0020\u0025\u0073",_bfe );_agc :=_dad .GetFileOffset ();defer func (){_dad .SetFileOffset (_agc )}();_bgd =_fbd .NewReader (_bfe );_dad ._fea =_ef .NewReader (_bgd );_be .Log .Trace ("\u0050a\u0072s\u0069\u006e\u0067\u0020\u006ff\u0066\u0073e\u0074\u0020\u006d\u0061\u0070");_bfa :=map[int ]int64 {};for _egf :=0;_egf < int (*N );_egf ++{_dad .skipSpaces ();_ff ,_db :=_dad .parseNumber ();if _db !=nil {return nil ,_db ;};_adc ,_cac :=_ff .(*PdfObjectInteger );if !_cac {return nil ,_g .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");};_dad .skipSpaces ();_ff ,_db =_dad .parseNumber ();if _db !=nil {return nil ,_db ;};_af ,_cac :=_ff .(*PdfObjectInteger );if !_cac {return nil ,_g .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");};_be .Log .Trace ("\u006f\u0062j\u0020\u0025\u0064 \u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0025\u0064",*_adc ,*_af );_bfa [int (*_adc )]=int64 (*_bc +*_af );};_eff =objectStream {N :int (*N ),_fg :_bfe ,_gf :_bfa };_dad ._bbgec [_bg ]=_eff ;}else {_bcf :=_dad .GetFileOffset ();defer func (){_dad .SetFileOffset (_bcf )}();_bgd =_fbd .NewReader (_eff ._fg );_dad ._fea =_ef .NewReader (_bgd );};_gfc :=_eff ._gf [_dae ];_be .Log .Trace ("\u0041\u0043\u0054\u0055AL\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u005b\u0025\u0064\u005d\u0020\u003d\u0020%\u0064",_dae ,_gfc );_bgd .Seek (_gfc ,_fec .SEEK_SET );_dad ._fea =_ef .NewReader (_bgd );_gbd ,_ :=_dad ._fea .Peek (100);_be .Log .Trace ("\u004f\u0042\u004a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_gbd ));_bge ,_bged :=_dad .parseObject ();if _bged !=nil {_be .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c \u0074\u006f\u0020\u0072\u0065\u0061\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_bged );return nil ,_bged ;};if _bge ==nil {return nil ,_g .New ("o\u0062\u006a\u0065\u0063t \u0063a\u006e\u006e\u006f\u0074\u0020b\u0065\u0020\u006e\u0075\u006c\u006c");};_gdf :=PdfIndirectObject {};_gdf .ObjectNumber =int64 (_dae );_gdf .PdfObject =_bge ;return &_gdf ,nil ;};

// Keys returns the list of keys in the dictionary.
// If `d` is nil returns a nil slice.
func (_agebe *PdfObjectDictionary )Keys ()[]PdfObjectName {if _agebe ==nil {return nil ;};return _agebe ._beeac ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_aabg *ASCIIHexEncoder )MakeDecodeParams ()PdfObject {return nil };

// AddPageImage adds the page with the image 'img' to the encoder context in order to encode it jbig2 document.
// The 'settings' defines what encoding type should be used by the encoder.
func (_ffabe *JBIG2Encoder )AddPageImage (img *JBIG2Image ,settings *JBIG2EncoderSettings )(_dbdb error ){const _cabf ="\u004a\u0042\u0049\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0041\u0064\u0064\u0050\u0061\u0067\u0065\u0049m\u0061\u0067\u0065";if _ffabe ==nil {return _fbg .Error (_cabf ,"J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u0020\u0069\u0073 n\u0069\u006c");};if settings ==nil {settings =&_ffabe .DefaultPageSettings ;};if _ffabe ._fcga ==nil {_ffabe ._fcga =_eg .InitEncodeDocument (settings .FileMode );};if _dbdb =settings .Validate ();_dbdb !=nil {return _fbg .Wrap (_dbdb ,_cabf ,"");};_acae ,_dbdb :=img .toBitmap ();if _dbdb !=nil {return _fbg .Wrap (_dbdb ,_cabf ,"");};switch settings .Compression {case JB2Generic :if _dbdb =_ffabe ._fcga .AddGenericPage (_acae ,settings .DuplicatedLinesRemoval );_dbdb !=nil {return _fbg .Wrap (_dbdb ,_cabf ,"");};case JB2SymbolCorrelation :return _fbg .Error (_cabf ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");case JB2SymbolRankHaus :return _fbg .Error (_cabf ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");default:return _fbg .Error (_cabf ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return nil ;};

// IsDecimalDigit checks if the character is a part of a decimal number string.
func IsDecimalDigit (c byte )bool {return '0'<=c &&c <='9'};

// GetString returns the *PdfObjectString represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetString (obj PdfObject )(_ggdgg *PdfObjectString ,_bceb bool ){_ggdgg ,_bceb =TraceToDirectObject (obj ).(*PdfObjectString );return _ggdgg ,_bceb ;};

// GetStringVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetStringVal (obj PdfObject )(_efea string ,_fcfe bool ){_eaee ,_fcfe :=TraceToDirectObject (obj ).(*PdfObjectString );if _fcfe {return _eaee .Str (),true ;};return ;};func (_dbag *PdfParser )parseName ()(PdfObjectName ,error ){var _dedb _fbd .Buffer ;_abcab :=false ;for {_add ,_abeg :=_dbag ._fea .Peek (1);if _abeg ==_d .EOF {break ;};if _abeg !=nil {return PdfObjectName (_dedb .String ()),_abeg ;};if !_abcab {if _add [0]=='/'{_abcab =true ;_dbag ._fea .ReadByte ();}else if _add [0]=='%'{_dbag .readComment ();_dbag .skipSpaces ();}else {_be .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020N\u0061\u006d\u0065\u0020\u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020w\u0069\u0074\u0068\u0020\u0025\u0073\u0020(\u0025\u0020\u0078\u0029",_add ,_add );return PdfObjectName (_dedb .String ()),_e .Errorf ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u006ea\u006d\u0065:\u0020\u0028\u0025\u0063\u0029",_add [0]);};}else {if IsWhiteSpace (_add [0]){break ;}else if (_add [0]=='/')||(_add [0]=='[')||(_add [0]=='(')||(_add [0]==']')||(_add [0]=='<')||(_add [0]=='>'){break ;}else if _add [0]=='#'{_feee ,_adbbg :=_dbag ._fea .Peek (3);if _adbbg !=nil {return PdfObjectName (_dedb .String ()),_adbbg ;};_gffa ,_adbbg :=_cd .DecodeString (string (_feee [1:3]));if _adbbg !=nil {_be .Log .Debug ("\u0045\u0052\u0052\u004fR\u003a\u0020\u0049\u006ev\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0066o\u006c\u006co\u0077\u0069\u006e\u0067 \u0027\u0023\u0027\u002c \u0063\u006f\u006e\u0074\u0069n\u0075\u0069\u006e\u0067\u0020\u0075\u0073i\u006e\u0067\u0020\u006c\u0069t\u0065\u0072\u0061\u006c\u0020\u002d\u0020\u004f\u0075t\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074");_dedb .WriteByte ('#');_dbag ._fea .Discard (1);continue ;};_dbag ._fea .Discard (3);_dedb .Write (_gffa );}else {_eedb ,_ :=_dbag ._fea .ReadByte ();_dedb .WriteByte (_eedb );};};};return PdfObjectName (_dedb .String ()),nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_bfdd *CCITTFaxEncoder )UpdateParams (params *PdfObjectDictionary ){if _acbge ,_dgad :=GetNumberAsInt64 (params .Get ("\u004b"));_dgad ==nil {_bfdd .K =int (_acbge );};if _cfgge ,_def :=GetNumberAsInt64 (params .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));_def ==nil {_bfdd .Columns =int (_cfgge );}else if _cfgge ,_def =GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));_def ==nil {_bfdd .Columns =int (_cfgge );};if _fcda ,_dedge :=GetNumberAsInt64 (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_dedge ==nil {_bfdd .BlackIs1 =_fcda > 0;}else {if _gbcg ,_agbe :=GetBoolVal (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_agbe {_bfdd .BlackIs1 =_gbcg ;}else {if _afbe ,_dgfbc :=GetArray (params .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));_dgfbc {_ecg ,_dege :=_afbe .ToIntegerArray ();if _dege ==nil {_bfdd .BlackIs1 =_ecg [0]==1&&_ecg [1]==0;};};};};if _agga ,_dbbc :=GetNumberAsInt64 (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_dbbc ==nil {_bfdd .EncodedByteAlign =_agga > 0;}else {if _cfeb ,_bbbf :=GetBoolVal (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_bbbf {_bfdd .EncodedByteAlign =_cfeb ;};};if _dggd ,_edag :=GetNumberAsInt64 (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_edag ==nil {_bfdd .EndOfLine =_dggd > 0;}else {if _bbbd ,_gfef :=GetBoolVal (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_gfef {_bfdd .EndOfLine =_bbbd ;};};if _bdad ,_fecab :=GetNumberAsInt64 (params .Get ("\u0052\u006f\u0077\u0073"));_fecab ==nil {_bfdd .Rows =int (_bdad );}else if _bdad ,_fecab =GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));_fecab ==nil {_bfdd .Rows =int (_bdad );};if _edac ,_bfdc :=GetNumberAsInt64 (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_bfdc ==nil {_bfdd .EndOfBlock =_edac > 0;}else {if _cdfgc ,_bede :=GetBoolVal (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_bede {_bfdd .EndOfBlock =_cdfgc ;};};if _gaedd ,_dcgc :=GetNumberAsInt64 (params .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));_dcgc !=nil {_bfdd .DamagedRowsBeforeError =int (_gaedd );};};

// DecodeBytes decodes a multi-encoded slice of bytes by passing it through the
// DecodeBytes method of the underlying encoders.
func (_dfd *MultiEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_gbdb :=encoded ;var _eege error ;for _ ,_fbaf :=range _dfd ._geffa {_be .Log .Trace ("\u004du\u006c\u0074i\u0020\u0045\u006e\u0063o\u0064\u0065\u0072 \u0044\u0065\u0063\u006f\u0064\u0065\u003a\u0020\u0041pp\u006c\u0079\u0069n\u0067\u0020F\u0069\u006c\u0074\u0065\u0072\u003a \u0025\u0076 \u0025\u0054",_fbaf ,_fbaf );_gbdb ,_eege =_fbaf .DecodeBytes (_gbdb );if _eege !=nil {return nil ,_eege ;};};return _gbdb ,nil ;};

// ReadBytesAt reads byte content at specific offset and length within the PDF.
func (_fcab *PdfParser )ReadBytesAt (offset ,len int64 )([]byte ,error ){_befee :=_fcab .GetFileOffset ();_ ,_cafe :=_fcab ._cedgd .Seek (offset ,_d .SeekStart );if _cafe !=nil {return nil ,_cafe ;};_ecad :=make ([]byte ,len );_ ,_cafe =_d .ReadAtLeast (_fcab ._cedgd ,_ecad ,int (len ));if _cafe !=nil {return nil ,_cafe ;};_fcab .SetFileOffset (_befee );return _ecad ,nil ;};

// WriteString outputs the object as it is to be written to file.
func (_ffgf *PdfObjectStream )WriteString ()string {var _ebdc _bf .Builder ;_ebdc .WriteString (_a .FormatInt (_ffgf .ObjectNumber ,10));_ebdc .WriteString ("\u0020\u0030\u0020\u0052");return _ebdc .String ();};

// PdfParser parses a PDF file and provides access to the object structure of the PDF.
type PdfParser struct{_eecg Version ;_cedgd _d .ReadSeeker ;_fea *_ef .Reader ;_cgdf int64 ;_eegf XrefTable ;_ddfd int64 ;_ebg *xrefType ;_bbgec objectStreams ;_gdeb *PdfObjectDictionary ;_edaf *PdfCrypt ;_cggd bool ;ObjCache objectCache ;_cfed map[int64 ]bool ;};

// Decrypt attempts to decrypt the PDF file with a specified password.  Also tries to
// decrypt with an empty password.  Returns true if successful, false otherwise.
// An error is returned when there is a problem with decrypting.
func (_eaca *PdfParser )Decrypt (password []byte )(bool ,error ){if _eaca ._edaf ==nil {return false ,_g .New ("\u0063\u0068\u0065\u0063k \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u0069\u0072s\u0074");};_agbd ,_bage :=_eaca ._edaf .authenticate (password );if _bage !=nil {return false ,_bage ;};if !_agbd {_agbd ,_bage =_eaca ._edaf .authenticate ([]byte (""));};return _agbd ,_bage ;};

// UpdateParams updates the parameter values of the encoder.
func (_eefg *JPXEncoder )UpdateParams (params *PdfObjectDictionary ){};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_efgc *CCITTFaxEncoder )MakeStreamDict ()*PdfObjectDictionary {_ddgc :=MakeDict ();_ddgc .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_efgc .GetFilterName ()));_befg :=_efgc .MakeDecodeParams ();if _befg !=nil {_ddgc .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_befg );};return _ddgc ;};

// ParseNumber parses a numeric objects from a buffered stream.
// Section 7.3.3.
// Integer or Float.
//
// An integer shall be written as one or more decimal digits optionally
// preceded by a sign. The value shall be interpreted as a signed
// decimal integer and shall be converted to an integer object.
//
// A real value shall be written as one or more decimal digits with an
// optional sign and a leading, trailing, or embedded PERIOD (2Eh)
// (decimal point). The value shall be interpreted as a real number
// and shall be converted to a real object.
//
// Regarding exponential numbers: 7.3.3 Numeric Objects:
// A conforming writer shall not use the PostScript syntax for numbers
// with non-decimal radices (such as 16#FFFE) or in exponential format
// (such as 6.02E23).
// Nonetheless, we sometimes get numbers with exponential format, so
// we will support it in the reader (no confusion with other types, so
// no compromise).
func ParseNumber (buf *_ef .Reader )(PdfObject ,error ){_cbfc :=false ;_acgdgc :=true ;var _dgac _fbd .Buffer ;for {if _be .Log .IsLogLevel (_be .LogLevelTrace ){_be .Log .Trace ("\u0050\u0061\u0072\u0073in\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0022\u0025\u0073\u0022",_dgac .String ());};_gagce ,_cbga :=buf .Peek (1);if _cbga ==_d .EOF {break ;};if _cbga !=nil {_be .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0025\u0073",_cbga );return nil ,_cbga ;};if _acgdgc &&(_gagce [0]=='-'||_gagce [0]=='+'){_effe ,_ :=buf .ReadByte ();_dgac .WriteByte (_effe );_acgdgc =false ;}else if IsDecimalDigit (_gagce [0]){_cbfda ,_ :=buf .ReadByte ();_dgac .WriteByte (_cbfda );}else if _gagce [0]=='.'{_ebfgc ,_ :=buf .ReadByte ();_dgac .WriteByte (_ebfgc );_cbfc =true ;}else if _gagce [0]=='e'||_gagce [0]=='E'{_afbbc ,_ :=buf .ReadByte ();_dgac .WriteByte (_afbbc );_cbfc =true ;_acgdgc =true ;}else {break ;};};var _gdge PdfObject ;if _cbfc {_bbbdb ,_cefg :=_a .ParseFloat (_dgac .String (),64);if _cefg !=nil {_be .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0025v\u0020\u0065\u0072\u0072\u003d\u0025v\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0030\u002e\u0020\u004fu\u0074\u0070u\u0074\u0020\u006d\u0061y\u0020\u0062\u0065\u0020\u0069n\u0063\u006f\u0072\u0072\u0065\u0063\u0074",_dgac .String (),_cefg );_bbbdb =0.0;_cefg =nil ;};_bdgbf :=PdfObjectFloat (_bbbdb );_gdge =&_bdgbf ;}else {_abea ,_eeccd :=_a .ParseInt (_dgac .String (),10,64);if _eeccd !=nil {_be .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0025\u0076\u0020\u0065\u0072\u0072\u003d%\u0076\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074 \u006d\u0061\u0079\u0020\u0062\u0065 \u0069\u006ec\u006f\u0072r\u0065c\u0074",_dgac .String (),_eeccd );_abea =0;_eeccd =nil ;};_ggaad :=PdfObjectInteger (_abea );_gdge =&_ggaad ;};return _gdge ,nil ;};

// GetFilterArray returns the names of the underlying encoding filters in an array that
// can be used as /Filter entry.
func (_beeg *MultiEncoder )GetFilterArray ()*PdfObjectArray {_ecgc :=make ([]PdfObject ,len (_beeg ._geffa ));for _ggge ,_afe :=range _beeg ._geffa {_ecgc [_ggge ]=MakeName (_afe .GetFilterName ());};return MakeArray (_ecgc ...);};

// Inspect analyzes the document object structure. Returns a map of object types (by name) with the instance count
// as value.
func (_aefg *PdfParser )Inspect ()(map[string ]int ,error ){return _aefg .inspect ()};

// String returns a string describing `null`.
func (_bggcdd *PdfObjectNull )String ()string {return "\u006e\u0075\u006c\u006c"};

// PdfObjectString represents the primitive PDF string object.
type PdfObjectString struct{_fggfe string ;_gdbg bool ;};

// MakeEncodedString creates a PdfObjectString with encoded content, which can be either
// UTF-16BE or PDFDocEncoding depending on whether `utf16BE` is true or false respectively.
func MakeEncodedString (s string ,utf16BE bool )*PdfObjectString {if utf16BE {var _fgaff _fbd .Buffer ;_fgaff .Write ([]byte {0xFE,0xFF});_fgaff .WriteString (_gag .StringToUTF16 (s ));return &PdfObjectString {_fggfe :_fgaff .String (),_gdbg :true };};return &PdfObjectString {_fggfe :string (_gag .StringToPDFDocEncoding (s )),_gdbg :false };};

// DecodeImages decodes the page images from the jbig2 'encoded' data input.
// The jbig2 document may contain multiple pages, thus the function can return multiple
// images. The images order corresponds to the page number.
func (_bdef *JBIG2Encoder )DecodeImages (encoded []byte )([]_ce .Image ,error ){const _dfcdd ="\u004aB\u0049\u0047\u0032\u0045n\u0063\u006f\u0064\u0065\u0072.\u0044e\u0063o\u0064\u0065\u0049\u006d\u0061\u0067\u0065s";_adef ,_bbe :=_cg .Decode (encoded ,_cg .Parameters {},_bdef .Globals .ToDocumentGlobals ());if _bbe !=nil {return nil ,_fbg .Wrap (_bbe ,_dfcdd ,"");};_dceb ,_bbe :=_adef .PageNumber ();if _bbe !=nil {return nil ,_fbg .Wrap (_bbe ,_dfcdd ,"");};_dffe :=[]_ce .Image {};var _beee _ce .Image ;for _abfg :=1;_abfg <=_dceb ;_abfg ++{_beee ,_bbe =_adef .DecodePageImage (_abfg );if _bbe !=nil {return nil ,_fbg .Wrapf (_bbe ,_dfcdd ,"\u0070\u0061\u0067\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_abfg );};_dffe =append (_dffe ,_beee );};return _dffe ,nil ;};

// TraceToDirectObject traces a PdfObject to a direct object.  For example direct objects contained
// in indirect objects (can be double referenced even).
func TraceToDirectObject (obj PdfObject )PdfObject {if _cabd ,_geecc :=obj .(*PdfObjectReference );_geecc {obj =_cabd .Resolve ();};_cabg ,_ecdea :=obj .(*PdfIndirectObject );_ccaf :=0;for _ecdea {obj =_cabg .PdfObject ;_cabg ,_ecdea =GetIndirect (obj );_ccaf ++;if _ccaf > _ffgb {_be .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0072\u0061\u0063\u0065\u0020\u0064\u0065p\u0074\u0068\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u0062\u0065\u0079\u006fn\u0064\u0020\u0025\u0064\u0020\u002d\u0020\u006e\u006f\u0074\u0020\u0067oi\u006e\u0067\u0020\u0064\u0065\u0065\u0070\u0065\u0072\u0021",_ffgb );return nil ;};};return obj ;};func (_efef *PdfParser )parseNull ()(PdfObjectNull ,error ){_ ,_ebag :=_efef ._fea .Discard (4);return PdfObjectNull {},_ebag ;};

// IsEncrypted checks if the document is encrypted. A bool flag is returned indicating the result.
// First time when called, will check if the Encrypt dictionary is accessible through the trailer dictionary.
// If encrypted, prepares a crypt datastructure which can be used to authenticate and decrypt the document.
// On failure, an error is returned.
func (_cdbg *PdfParser )IsEncrypted ()(bool ,error ){if _cdbg ._edaf !=nil {return true ,nil ;}else if _cdbg ._gdeb ==nil {return false ,nil ;};_be .Log .Trace ("\u0043\u0068\u0065c\u006b\u0069\u006e\u0067 \u0065\u006e\u0063\u0072\u0079\u0070\u0074i\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0021");_abfb :=_cdbg ._gdeb .Get ("\u0045n\u0063\u0072\u0079\u0070\u0074");if _abfb ==nil {return false ,nil ;};_be .Log .Trace ("\u0049\u0073\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u0021");var (_abgda *PdfObjectDictionary ;);switch _ddda :=_abfb .(type ){case *PdfObjectDictionary :_abgda =_ddda ;case *PdfObjectReference :_be .Log .Trace ("\u0030\u003a\u0020\u004c\u006f\u006f\u006b\u0020\u0075\u0070\u0020\u0072e\u0066\u0020\u0025\u0071",_ddda );_edea ,_abgcg :=_cdbg .LookupByReference (*_ddda );_be .Log .Trace ("\u0031\u003a\u0020%\u0071",_edea );if _abgcg !=nil {return false ,_abgcg ;};_gecc ,_deag :=_edea .(*PdfIndirectObject );if !_deag {_be .Log .Debug ("E\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006eo\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072ec\u0074\u0020\u006fb\u006ae\u0063\u0074");return false ,_g .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");};_fggf ,_deag :=_gecc .PdfObject .(*PdfObjectDictionary );_be .Log .Trace ("\u0032\u003a\u0020%\u0071",_fggf );if !_deag {return false ,_g .New ("\u0074\u0072a\u0069\u006c\u0065\u0072 \u0045\u006ec\u0072\u0079\u0070\u0074\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u006e\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");};_abgda =_fggf ;case *PdfObjectNull :_be .Log .Debug ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074 \u0069\u0073\u0020a\u0020\u006e\u0075l\u006c\u0020o\u0062\u006a\u0065\u0063\u0074\u002e \u0046il\u0065\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u002e");return false ,nil ;default:return false ,_e .Errorf ("u\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0079\u0070\u0065: \u0025\u0054",_ddda );};_cbdd ,_egca :=PdfCryptNewDecrypt (_cdbg ,_abgda ,_cdbg ._gdeb );if _egca !=nil {return false ,_egca ;};for _ ,_aaff :=range []string {"\u0049\u006e\u0066\u006f","\u0045n\u0063\u0072\u0079\u0070\u0074"}{_eegd :=_cdbg ._gdeb .Get (PdfObjectName (_aaff ));if _eegd ==nil {continue ;};switch _bbdg :=_eegd .(type ){case *PdfObjectReference :_cbdd ._afgd [int (_bbdg .ObjectNumber )]=struct{}{};case *PdfIndirectObject :_cbdd ._bff [_bbdg ]=true ;_cbdd ._afgd [int (_bbdg .ObjectNumber )]=struct{}{};};};_cdbg ._edaf =_cbdd ;_be .Log .Trace ("\u0043\u0072\u0079\u0070\u0074\u0065\u0072\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0025\u0062",_cbdd );return true ,nil ;};

// GoImageToJBIG2 creates a binary image on the base of 'i' golang image.Image.
// If the image is not a black/white image then the function converts provided input into
// JBIG2Image with 1bpp. For non grayscale images the function performs the conversion to the grayscale temp image.
// Then it checks the value of the gray image value if it's within bounds of the black white threshold.
// This 'bwThreshold' value should be in range (0.0, 1.0). The threshold checks if the grayscale pixel (uint) value
// is greater or smaller than 'bwThreshold' * 255. Pixels inside the range will be white, and the others will be black.
// If the 'bwThreshold' is equal to -1.0 - JB2ImageAutoThreshold then it's value would be set on the base of
// it's histogram using Triangle method. For more information go to:
// 	https://www.mathworks.com/matlabcentral/fileexchange/28047-gray-image-thresholding-using-the-triangle-method
func GoImageToJBIG2 (i _ce .Image ,bwThreshold float64 )(*JBIG2Image ,error ){const _ccfe ="\u0047\u006f\u0049\u006d\u0061\u0067\u0065\u0054\u006fJ\u0042\u0049\u0047\u0032";if i ==nil {return nil ,_fbg .Error (_ccfe ,"i\u006d\u0061\u0067\u0065 '\u0069'\u0020\u006e\u006f\u0074\u0020d\u0065\u0066\u0069\u006e\u0065\u0064");};var (_bfag uint8 ;_ggee _bea .Image ;_egdcd error ;);if bwThreshold ==JB2ImageAutoThreshold {_ggee ,_egdcd =_bea .MonochromeConverter .Convert (i );}else if bwThreshold > 1.0||bwThreshold < 0.0{return nil ,_fbg .Error (_ccfe ,"p\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074h\u0072\u0065\u0073\u0068\u006f\u006c\u0064 i\u0073\u0020\u006e\u006ft\u0020\u0069\u006e\u0020\u0061\u0020\u0072\u0061\u006ege\u0020\u007b0\u002e\u0030\u002c\u0020\u0031\u002e\u0030\u007d");}else {_bfag =uint8 (255*bwThreshold );_ggee ,_egdcd =_bea .MonochromeThresholdConverter (_bfag ).Convert (i );};if _egdcd !=nil {return nil ,_egdcd ;};return _abgbd (_ggee ),nil ;};

// Resolve resolves the reference and returns the indirect or stream object.
// If the reference cannot be resolved, a *PdfObjectNull object is returned.
func (_cegcc *PdfObjectReference )Resolve ()PdfObject {if _cegcc ._dfcg ==nil {return MakeNull ();};_bddf ,_ ,_gfefd :=_cegcc ._dfcg .resolveReference (_cegcc );if _gfefd !=nil {_be .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0072\u0065\u0073\u006f\u006cv\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065r\u0065n\u0063\u0065\u003a\u0020\u0025\u0076\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074",_gfefd );return MakeNull ();};if _bddf ==nil {_be .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0072\u0065\u0073ol\u0076\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065:\u0020\u006ei\u006c\u0020\u006fb\u006a\u0065\u0063\u0074\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u0061\u0020nu\u006c\u006c\u0020o\u0062\u006a\u0065\u0063\u0074");return MakeNull ();};return _bddf ;};func _fgec (_fcdc PdfObject ,_debd int ,_aace map[PdfObject ]struct{})error {_be .Log .Trace ("\u0054\u0072\u0061\u0076\u0065\u0072s\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0064\u0061\u0074\u0061 \u0028\u0064\u0065\u0070\u0074\u0068\u0020=\u0020\u0025\u0064\u0029",_debd );if _ ,_fdebe :=_aace [_fcdc ];_fdebe {_be .Log .Trace ("-\u0041\u006c\u0072\u0065ad\u0079 \u0074\u0072\u0061\u0076\u0065r\u0073\u0065\u0064\u002e\u002e\u002e");return nil ;};_aace [_fcdc ]=struct{}{};switch _bcdcd :=_fcdc .(type ){case *PdfIndirectObject :_bdgef :=_bcdcd ;_be .Log .Trace ("\u0069\u006f\u003a\u0020\u0025\u0073",_bdgef );_be .Log .Trace ("\u002d\u0020\u0025\u0073",_bdgef .PdfObject );return _fgec (_bdgef .PdfObject ,_debd +1,_aace );case *PdfObjectStream :_cegaa :=_bcdcd ;return _fgec (_cegaa .PdfObjectDictionary ,_debd +1,_aace );case *PdfObjectDictionary :_cdgbg :=_bcdcd ;_be .Log .Trace ("\u002d\u0020\u0064\u0069\u0063\u0074\u003a\u0020\u0025\u0073",_cdgbg );for _ ,_fcad :=range _cdgbg .Keys (){_gcaa :=_cdgbg .Get (_fcad );if _fefd ,_adff :=_gcaa .(*PdfObjectReference );_adff {_febc :=_fefd .Resolve ();_cdgbg .Set (_fcad ,_febc );_cbdb :=_fgec (_febc ,_debd +1,_aace );if _cbdb !=nil {return _cbdb ;};}else {_gcfe :=_fgec (_gcaa ,_debd +1,_aace );if _gcfe !=nil {return _gcfe ;};};};return nil ;case *PdfObjectArray :_aeceb :=_bcdcd ;_be .Log .Trace ("-\u0020\u0061\u0072\u0072\u0061\u0079\u003a\u0020\u0025\u0073",_aeceb );for _dafac ,_edca :=range _aeceb .Elements (){if _fcdae ,_bcab :=_edca .(*PdfObjectReference );_bcab {_gadf :=_fcdae .Resolve ();_aeceb .Set (_dafac ,_gadf );_affb :=_fgec (_gadf ,_debd +1,_aace );if _affb !=nil {return _affb ;};}else {_eedg :=_fgec (_edca ,_debd +1,_aace );if _eedg !=nil {return _eedg ;};};};return nil ;case *PdfObjectReference :_be .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020T\u0072\u0061\u0063\u0069\u006e\u0067\u0020\u0061\u0020r\u0065\u0066\u0065r\u0065n\u0063\u0065\u0021");return _g .New ("\u0065r\u0072\u006f\u0072\u0020t\u0072\u0061\u0063\u0069\u006eg\u0020a\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");};return nil ;};

// DecodeStream decodes a JPX encoded stream and returns the result as a
// slice of bytes.
func (_cfbaf *JPXEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_be .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_cfbaf .GetFilterName ());return streamObj .Stream ,ErrNoJPXDecode ;};

// ASCIIHexEncoder implements ASCII hex encoder/decoder.
type ASCIIHexEncoder struct{};

// JPXEncoder implements JPX encoder/decoder (dummy, for now)
// FIXME: implement
type JPXEncoder struct{};type objectCache map[int ]PdfObject ;

// IsPrintable checks if a character is printable.
// Regular characters that are outside the range EXCLAMATION MARK(21h)
// (!) to TILDE (7Eh) (~) should be written using the hexadecimal notation.
func IsPrintable (c byte )bool {return 0x21<=c &&c <=0x7E};

// MakeStringFromBytes creates an PdfObjectString from a byte array.
// This is more natural than MakeString as `data` is usually not utf-8 encoded.
func MakeStringFromBytes (data []byte )*PdfObjectString {return MakeString (string (data ))};var _dcfb =_ge .MustCompile ("\u005e\\\u0073\u002a\u005b\u002d]\u002a\u0028\u005c\u0064\u002b)\u005cs\u002b(\u005c\u0064\u002b\u0029\u005c\u0073\u002bR");

// NewLZWEncoder makes a new LZW encoder with default parameters.
func NewLZWEncoder ()*LZWEncoder {_dga :=&LZWEncoder {};_dga .Predictor =1;_dga .BitsPerComponent =8;_dga .Colors =1;_dga .Columns =1;_dga .EarlyChange =1;return _dga ;};

// NewParserFromString is used for testing purposes.
func NewParserFromString (txt string )*PdfParser {_bfdad :=_fbd .NewReader ([]byte (txt ));_fcbgd :=&PdfParser {ObjCache :objectCache {},_cedgd :_bfdad ,_fea :_ef .NewReader (_bfdad ),_cgdf :int64 (len (txt )),_cfed :map[int64 ]bool {}};_fcbgd ._eegf .ObjectMap =make (map[int ]XrefObject );return _fcbgd ;};const (JB2Generic JBIG2CompressionType =iota ;JB2SymbolCorrelation ;JB2SymbolRankHaus ;);

// GetFilterName returns the name of the encoding filter.
func (_dce *CCITTFaxEncoder )GetFilterName ()string {return StreamEncodingFilterNameCCITTFax };func _fcagg (_deef ,_dfgb PdfObject ,_aebfd int )bool {if _aebfd > _ffgb {_be .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_ffgb );return false ;};if _deef ==nil &&_dfgb ==nil {return true ;}else if _deef ==nil ||_dfgb ==nil {return false ;};if _f .TypeOf (_deef )!=_f .TypeOf (_dfgb ){return false ;};switch _feff :=_deef .(type ){case *PdfObjectNull ,*PdfObjectReference :return true ;case *PdfObjectName :return *_feff ==*(_dfgb .(*PdfObjectName ));case *PdfObjectString :return *_feff ==*(_dfgb .(*PdfObjectString ));case *PdfObjectInteger :return *_feff ==*(_dfgb .(*PdfObjectInteger ));case *PdfObjectBool :return *_feff ==*(_dfgb .(*PdfObjectBool ));case *PdfObjectFloat :return *_feff ==*(_dfgb .(*PdfObjectFloat ));case *PdfIndirectObject :return _fcagg (TraceToDirectObject (_deef ),TraceToDirectObject (_dfgb ),_aebfd +1);case *PdfObjectArray :_fgagb :=_dfgb .(*PdfObjectArray );if len ((*_feff )._adcd )!=len ((*_fgagb )._adcd ){return false ;};for _cbdg ,_bdce :=range (*_feff )._adcd {if !_fcagg (_bdce ,(*_fgagb )._adcd [_cbdg ],_aebfd +1){return false ;};};return true ;case *PdfObjectDictionary :_ggbgd :=_dfgb .(*PdfObjectDictionary );_befeb ,_gece :=(*_feff )._cfdc ,(*_ggbgd )._cfdc ;if len (_befeb )!=len (_gece ){return false ;};for _bcbe ,_gagca :=range _befeb {_bdde ,_ccced :=_gece [_bcbe ];if !_ccced ||!_fcagg (_gagca ,_bdde ,_aebfd +1){return false ;};};return true ;case *PdfObjectStream :_cgda :=_dfgb .(*PdfObjectStream );return _fcagg ((*_feff ).PdfObjectDictionary ,(*_cgda ).PdfObjectDictionary ,_aebfd +1);default:_be .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",_deef );};return false ;};func _bbgecb (_bdbbf string )(PdfObjectReference ,error ){_dabec :=PdfObjectReference {};_daga :=_dcfb .FindStringSubmatch (string (_bdbbf ));if len (_daga )< 3{_be .Log .Debug ("\u0045\u0072\u0072or\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");return _dabec ,_g .New ("\u0075n\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061r\u0073e\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");};_beaa ,_ :=_a .Atoi (_daga [1]);_cbdf ,_ :=_a .Atoi (_daga [2]);_dabec .ObjectNumber =int64 (_beaa );_dabec .GenerationNumber =int64 (_cbdf );return _dabec ,nil ;};

// String returns a string representation of `name`.
func (_fbbe *PdfObjectName )String ()string {return string (*_fbbe )};func (_gce *PdfCrypt )authenticate (_gee []byte )(bool ,error ){_gce ._bdc =false ;_eba :=_gce .securityHandler ();_bfee ,_fba ,_gfcg :=_eba .Authenticate (&_gce ._deg ,_gee );if _gfcg !=nil {return false ,_gfcg ;}else if _fba ==0||len (_bfee )==0{return false ,nil ;};_gce ._bdc =true ;_gce ._ggb =_bfee ;return true ,nil ;};func _dfce (_abggg *PdfObjectDictionary )(_bcgc *_bea .ImageBase ){var (_begc *PdfObjectInteger ;_dbe bool ;);if _begc ,_dbe =_abggg .Get ("\u0057\u0069\u0064t\u0068").(*PdfObjectInteger );_dbe {_bcgc =&_bea .ImageBase {Width :int (*_begc )};}else {return nil ;};if _begc ,_dbe =_abggg .Get ("\u0048\u0065\u0069\u0067\u0068\u0074").(*PdfObjectInteger );_dbe {_bcgc .Height =int (*_begc );};if _begc ,_dbe =_abggg .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074").(*PdfObjectInteger );_dbe {_bcgc .BitsPerComponent =int (*_begc );};if _begc ,_dbe =_abggg .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073").(*PdfObjectInteger );_dbe {_bcgc .ColorComponents =int (*_begc );};return _bcgc ;};func (_febd *PdfParser )parseNumber ()(PdfObject ,error ){return ParseNumber (_febd ._fea )};

// NewParser creates a new parser for a PDF file via ReadSeeker. Loads the cross reference stream and trailer.
// An error is returned on failure.
func NewParser (rs _d .ReadSeeker )(*PdfParser ,error ){_fcgb :=&PdfParser {_cedgd :rs ,ObjCache :make (objectCache ),_cfed :map[int64 ]bool {}};_bbgf ,_gbdgb ,_efdg :=_fcgb .parsePdfVersion ();if _efdg !=nil {_be .Log .Error ("U\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0076e\u0072\u0073\u0069o\u006e:\u0020\u0025\u0076",_efdg );return nil ,_efdg ;};_fcgb ._eecg .Major =_bbgf ;_fcgb ._eecg .Minor =_gbdgb ;if _fcgb ._gdeb ,_efdg =_fcgb .loadXrefs ();_efdg !=nil {_be .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020F\u0061\u0069\u006c\u0065d t\u006f l\u006f\u0061\u0064\u0020\u0078\u0072\u0065f \u0074\u0061\u0062\u006c\u0065\u0021\u0020%\u0073",_efdg );return nil ,_efdg ;};_be .Log .Trace ("T\u0072\u0061\u0069\u006c\u0065\u0072\u003a\u0020\u0025\u0073",_fcgb ._gdeb );if len (_fcgb ._eegf .ObjectMap )==0{return nil ,_e .Errorf ("\u0065\u006d\u0070\u0074\u0079\u0020\u0058\u0052\u0045\u0046\u0020t\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0049\u006e\u0076a\u006c\u0069\u0064");};return _fcgb ,nil ;};func (_bgcb *offsetReader )Read (p []byte )(_gdc int ,_fafdc error ){return _bgcb ._eecc .Read (p )};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_cbcb *JPXEncoder )MakeDecodeParams ()PdfObject {return nil };func _abgbd (_baaa _bea .Image )*JBIG2Image {_bgcg :=_baaa .Base ();return &JBIG2Image {Data :_bgcg .Data ,Width :_bgcg .Width ,Height :_bgcg .Height ,HasPadding :true };};

// WriteString outputs the object as it is to be written to file.
func (_dbab *PdfObjectInteger )WriteString ()string {return _a .FormatInt (int64 (*_dbab ),10)};func (_cafb *PdfParser )repairLocateXref ()(int64 ,error ){_eacc :=int64 (1000);_cafb ._cedgd .Seek (-_eacc ,_fec .SEEK_CUR );_ceggd ,_gcga :=_cafb ._cedgd .Seek (0,_fec .SEEK_CUR );if _gcga !=nil {return 0,_gcga ;};_ccec :=make ([]byte ,_eacc );_cafb ._cedgd .Read (_ccec );_ceebb :=_befd .FindAllStringIndex (string (_ccec ),-1);if len (_ceebb )< 1{_be .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0065\u0070a\u0069\u0072\u003a\u0020\u0078\u0072\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021");return 0,_g .New ("\u0072\u0065\u0070\u0061ir\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064");};_ggeba :=int64 (_ceebb [len (_ceebb )-1][0]);_abcd :=_ceggd +_ggeba ;return _abcd ,nil ;};

// WriteString outputs the object as it is to be written to file.
func (_defe *PdfObjectString )WriteString ()string {var _fdaa _fbd .Buffer ;if _defe ._gdbg {_eace :=_cd .EncodeToString (_defe .Bytes ());_fdaa .WriteString ("\u003c");_fdaa .WriteString (_eace );_fdaa .WriteString ("\u003e");return _fdaa .String ();};_fdee :=map[byte ]string {'\n':"\u005c\u006e",'\r':"\u005c\u0072",'\t':"\u005c\u0074",'\b':"\u005c\u0062",'\f':"\u005c\u0066",'(':"\u005c\u0028",')':"\u005c\u0029",'\\':"\u005c\u005c"};_fdaa .WriteString ("\u0028");for _faeg :=0;_faeg < len (_defe ._fggfe );_faeg ++{_aagc :=_defe ._fggfe [_faeg ];if _bfdab ,_abac :=_fdee [_aagc ];_abac {_fdaa .WriteString (_bfdab );}else {_fdaa .WriteByte (_aagc );};};_fdaa .WriteString ("\u0029");return _fdaa .String ();};

// NewDCTEncoder makes a new DCT encoder with default parameters.
func NewDCTEncoder ()*DCTEncoder {_cedg :=&DCTEncoder {};_cedg .ColorComponents =3;_cedg .BitsPerComponent =8;_cedg .Quality =DefaultJPEGQuality ;return _cedg ;};func _abc (_bgc *_da .FilterDict ,_fa *PdfObjectDictionary )error {if _ddb ,_bcb :=_fa .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_bcb {if _gdae :=string (*_ddb );_gdae !="C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"{_be .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020C\u0046\u0020\u0064ic\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074e\u0072\u0029",_gdae );};};_egfc ,_dfg :=_fa .Get ("\u0043\u0046\u004d").(*PdfObjectName );if !_dfg {return _e .Errorf ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0028\u004e\u006f\u006e\u0065\u0029");};_bgc .CFM =string (*_egfc );if _ega ,_ccd :=_fa .Get ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et").(*PdfObjectName );_ccd {_bgc .AuthEvent =_ag .AuthEvent (*_ega );}else {_bgc .AuthEvent =_ag .EventDocOpen ;};if _bcfg ,_adf :=_fa .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );_adf {_bgc .Length =int (*_bcfg );};return nil ;};

// EncodeStream encodes the stream data using the encoded specified by the stream's dictionary.
func EncodeStream (streamObj *PdfObjectStream )error {_be .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_dfgf ,_begf :=NewEncoderFromStream (streamObj );if _begf !=nil {_be .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_begf );return _begf ;};if _aabe ,_egeb :=_dfgf .(*LZWEncoder );_egeb {_aabe .EarlyChange =0;streamObj .PdfObjectDictionary .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (0));};_be .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076\u000a",_dfgf );_bafbcb ,_begf :=_dfgf .EncodeBytes (streamObj .Stream );if _begf !=nil {_be .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_begf );return _begf ;};streamObj .Stream =_bafbcb ;streamObj .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_bafbcb ))));return nil ;};func _fffg (_gccfa PdfObject ,_ebgf int )PdfObject {if _ebgf > _ffgb {_be .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_ffgb );return MakeNull ();};switch _dfffb :=_gccfa .(type ){case *PdfIndirectObject :_gccfa =_fffg ((*_dfffb ).PdfObject ,_ebgf +1);case *PdfObjectArray :for _ecbc ,_fgbe :=range (*_dfffb )._adcd {(*_dfffb )._adcd [_ecbc ]=_fffg (_fgbe ,_ebgf +1);};case *PdfObjectDictionary :for _ggbeg ,_addb :=range (*_dfffb )._cfdc {(*_dfffb )._cfdc [_ggbeg ]=_fffg (_addb ,_ebgf +1);};_ad .Slice ((*_dfffb )._beeac ,func (_cfdaa ,_cced int )bool {return (*_dfffb )._beeac [_cfdaa ]< (*_dfffb )._beeac [_cced ]});};return _gccfa ;};

// ParseDict reads and parses a PDF dictionary object enclosed with '<<' and '>>'
func (_bfbb *PdfParser )ParseDict ()(*PdfObjectDictionary ,error ){_be .Log .Trace ("\u0052\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020D\u0069\u0063\u0074\u0021");_fgaa :=MakeDict ();_fgaa ._gdac =_bfbb ;_dggde ,_ :=_bfbb ._fea .ReadByte ();if _dggde !='<'{return nil ,_g .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");};_dggde ,_ =_bfbb ._fea .ReadByte ();if _dggde !='<'{return nil ,_g .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");};for {_bfbb .skipSpaces ();_bfbb .skipComments ();_gced ,_dbfa :=_bfbb ._fea .Peek (2);if _dbfa !=nil {return nil ,_dbfa ;};_be .Log .Trace ("D\u0069c\u0074\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_gced ),string (_gced ));if (_gced [0]=='>')&&(_gced [1]=='>'){_be .Log .Trace ("\u0045\u004f\u0046\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");_bfbb ._fea .ReadByte ();_bfbb ._fea .ReadByte ();break ;};_be .Log .Trace ("\u0050a\u0072s\u0065\u0020\u0074\u0068\u0065\u0020\u006e\u0061\u006d\u0065\u0021");_decga ,_dbfa :=_bfbb .parseName ();_be .Log .Trace ("\u004be\u0079\u003a\u0020\u0025\u0073",_decga );if _dbfa !=nil {_be .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0052e\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006ea\u006d\u0065\u0020e\u0072r\u0020\u0025\u0073",_dbfa );return nil ,_dbfa ;};if len (_decga )> 4&&_decga [len (_decga )-4:]=="\u006e\u0075\u006c\u006c"{_fbae :=_decga [0:len (_decga )-4];_be .Log .Debug ("\u0054\u0061\u006b\u0069n\u0067\u0020\u0063\u0061\u0072\u0065\u0020\u006f\u0066\u0020n\u0075l\u006c\u0020\u0062\u0075\u0067\u0020\u0028%\u0073\u0029",_decga );_be .Log .Debug ("\u004e\u0065\u0077\u0020ke\u0079\u0020\u0022\u0025\u0073\u0022\u0020\u003d\u0020\u006e\u0075\u006c\u006c",_fbae );_bfbb .skipSpaces ();_fagf ,_ :=_bfbb ._fea .Peek (1);if _fagf [0]=='/'{_fgaa .Set (_fbae ,MakeNull ());continue ;};};_bfbb .skipSpaces ();_efece ,_dbfa :=_bfbb .parseObject ();if _dbfa !=nil {return nil ,_dbfa ;};_fgaa .Set (_decga ,_efece );if _be .Log .IsLogLevel (_be .LogLevelTrace ){_be .Log .Trace ("\u0064\u0069\u0063\u0074\u005b\u0025\u0073\u005d\u0020\u003d\u0020\u0025\u0073",_decga ,_efece .String ());};};_be .Log .Trace ("\u0072\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020\u0044\u0069\u0063\u0074\u0021");return _fgaa ,nil ;};func (_fdba *PdfCrypt )encryptBytes (_ccff []byte ,_ddgd string ,_aaf []byte )([]byte ,error ){_be .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");_edcg ,_ccbg :=_fdba ._gac [_ddgd ];if !_ccbg {return nil ,_e .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_ddgd );};return _edcg .EncryptBytes (_ccff ,_aaf );};

// MakeStream creates an PdfObjectStream with specified contents and encoding. If encoding is nil, then raw encoding
// will be used (i.e. no encoding applied).
func MakeStream (contents []byte ,encoder StreamEncoder )(*PdfObjectStream ,error ){_bgee :=&PdfObjectStream {};if encoder ==nil {encoder =NewRawEncoder ();};_bgee .PdfObjectDictionary =encoder .MakeStreamDict ();_ggcc ,_bfaa :=encoder .EncodeBytes (contents );if _bfaa !=nil {return nil ,_bfaa ;};_bgee .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_ggcc ))));_bgee .Stream =_ggcc ;return _bgee ,nil ;};

// GetStream returns the *PdfObjectStream represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetStream (obj PdfObject )(_ffbc *PdfObjectStream ,_ececd bool ){obj =ResolveReference (obj );_ffbc ,_ececd =obj .(*PdfObjectStream );return _ffbc ,_ececd ;};var _cdcea =_ge .MustCompile ("\u0025\u0025\u0045\u004f\u0046\u003f");

// GetAsFloat64Slice returns the array as []float64 slice.
// Returns an error if not entirely numeric (only PdfObjectIntegers, PdfObjectFloats).
func (_ffaee *PdfObjectArray )GetAsFloat64Slice ()([]float64 ,error ){var _fcge []float64 ;for _ ,_gfea :=range _ffaee .Elements (){_fbee ,_afee :=GetNumberAsFloat (TraceToDirectObject (_gfea ));if _afee !=nil {return nil ,_e .Errorf ("\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006e\u0075m\u0062\u0065\u0072");};_fcge =append (_fcge ,_fbee );};return _fcge ,nil ;};func (_dbfe *PdfParser )parsePdfVersion ()(int ,int ,error ){var _gfgee int64 =20;_gffac :=make ([]byte ,_gfgee );_dbfe ._cedgd .Seek (0,_fec .SEEK_SET );_dbfe ._cedgd .Read (_gffac );var _bbfb error ;var _gbdc ,_accd int ;if _ddca :=_gbdg .FindStringSubmatch (string (_gffac ));len (_ddca )< 3{if _gbdc ,_accd ,_bbfb =_dbfe .seekPdfVersionTopDown ();_bbfb !=nil {_be .Log .Debug ("F\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065\u0063\u006f\u0076\u0065\u0072\u0079\u0020\u002d\u0020\u0075n\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0066\u0069nd\u0020\u0076\u0065r\u0073i\u006f\u006e");return 0,0,_bbfb ;};_dbfe ._cedgd ,_bbfb =_cbfd (_dbfe ._cedgd ,_dbfe .GetFileOffset ()-8);if _bbfb !=nil {return 0,0,_bbfb ;};}else {if _gbdc ,_bbfb =_a .Atoi (_ddca [1]);_bbfb !=nil {return 0,0,_bbfb ;};if _accd ,_bbfb =_a .Atoi (_ddca [2]);_bbfb !=nil {return 0,0,_bbfb ;};_dbfe .SetFileOffset (0);};_dbfe ._fea =_ef .NewReader (_dbfe ._cedgd );_be .Log .Debug ("\u0050\u0064\u0066\u0020\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020%\u0064\u002e\u0025\u0064",_gbdc ,_accd );return _gbdc ,_accd ,nil ;};

// Resolve resolves a PdfObject to direct object, looking up and resolving references as needed (unlike TraceToDirect).
func (_dab *PdfParser )Resolve (obj PdfObject )(PdfObject ,error ){_fcg ,_fcb :=obj .(*PdfObjectReference );if !_fcb {return obj ,nil ;};_dge :=_dab .GetFileOffset ();defer func (){_dab .SetFileOffset (_dge )}();_bbg ,_dbg :=_dab .LookupByReference (*_fcg );if _dbg !=nil {return nil ,_dbg ;};_gagb ,_bfd :=_bbg .(*PdfIndirectObject );if !_bfd {return _bbg ,nil ;};_bbg =_gagb .PdfObject ;_ ,_fcb =_bbg .(*PdfObjectReference );if _fcb {return _gagb ,_g .New ("\u006d\u0075lt\u0069\u0020\u0064e\u0070\u0074\u0068\u0020tra\u0063e \u0070\u006f\u0069\u006e\u0074\u0065\u0072 t\u006f\u0020\u0070\u006f\u0069\u006e\u0074e\u0072");};return _bbg ,nil ;};

// DrawableImage is same as golang image/draw's Image interface that allow drawing images.
type DrawableImage interface{ColorModel ()_fb .Model ;Bounds ()_ce .Rectangle ;At (_efgg ,_cfda int )_fb .Color ;Set (_daaf ,_cgaf int ,_ecb _fb .Color );};

// MakeNull creates an PdfObjectNull.
func MakeNull ()*PdfObjectNull {_ddcaa :=PdfObjectNull {};return &_ddcaa };

// ToGoImage converts the JBIG2Image to the golang image.Image.
func (_befec *JBIG2Image )ToGoImage ()(_ce .Image ,error ){const _gcac ="J\u0042I\u0047\u0032\u0049\u006d\u0061\u0067\u0065\u002eT\u006f\u0047\u006f\u0049ma\u0067\u0065";if _befec .Data ==nil {return nil ,_fbg .Error (_gcac ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");};if _befec .Width ==0||_befec .Height ==0{return nil ,_fbg .Error (_gcac ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");};_bgfb ,_gagc :=_bea .NewImage (_befec .Width ,_befec .Height ,1,1,_befec .Data ,nil ,nil );if _gagc !=nil {return nil ,_gagc ;};return _bgfb ,nil ;};

// Encode encodes previously prepare jbig2 document and stores it as the byte slice.
func (_dbde *JBIG2Encoder )Encode ()(_gedc []byte ,_afdb error ){const _egbd ="J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0045\u006eco\u0064\u0065";if _dbde ._fcga ==nil {return nil ,_fbg .Errorf (_egbd ,"\u0064\u006f\u0063u\u006d\u0065\u006e\u0074 \u0069\u006e\u0070\u0075\u0074\u0020\u0064a\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006e\u0065\u0064");};_dbde ._fcga .FullHeaders =_dbde .DefaultPageSettings .FileMode ;_gedc ,_afdb =_dbde ._fcga .Encode ();if _afdb !=nil {return nil ,_fbg .Wrap (_afdb ,_egbd ,"");};return _gedc ,nil ;};func _fecdc (_fefb ,_aedf ,_bba uint8 )uint8 {_aafb :=int (_bba );_gbge :=int (_aedf )-_aafb ;_caad :=int (_fefb )-_aafb ;_aafb =_aecf (_gbge +_caad );_gbge =_aecf (_gbge );_caad =_aecf (_caad );if _gbge <=_caad &&_gbge <=_aafb {return _fefb ;}else if _caad <=_aafb {return _aedf ;};return _bba ;};

// CCITTFaxEncoder implements Group3 and Group4 facsimile (fax) encoder/decoder.
type CCITTFaxEncoder struct{K int ;EndOfLine bool ;EncodedByteAlign bool ;Columns int ;Rows int ;EndOfBlock bool ;BlackIs1 bool ;DamagedRowsBeforeError int ;};

// GetObjectNums returns a sorted list of object numbers of the PDF objects in the file.
func (_abcdd *PdfParser )GetObjectNums ()[]int {var _geecb []int ;for _ ,_cgae :=range _abcdd ._eegf .ObjectMap {_geecb =append (_geecb ,_cgae .ObjectNumber );};_ad .Ints (_geecb );return _geecb ;};

// String returns a string describing `streams`.
func (_eceb *PdfObjectStreams )String ()string {return _e .Sprintf ("\u004f\u0062j\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0025\u0064",_eceb .ObjectNumber );};func (_eegb *PdfObjectInteger )String ()string {return _e .Sprintf ("\u0025\u0064",*_eegb )};

// MakeString creates an PdfObjectString from a string.
// NOTE: PDF does not use utf-8 string encoding like Go so `s` will often not be a utf-8 encoded
// string.
func MakeString (s string )*PdfObjectString {_dgcae :=PdfObjectString {_fggfe :s };return &_dgcae };

// UpdateParams updates the parameter values of the encoder.
func (_dadd *FlateEncoder )UpdateParams (params *PdfObjectDictionary ){_adfbb ,_abca :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _abca ==nil {_dadd .Predictor =int (_adfbb );};_dgec ,_abca :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _abca ==nil {_dadd .BitsPerComponent =int (_dgec );};_dff ,_abca :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _abca ==nil {_dadd .Columns =int (_dff );};_fcea ,_abca :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _abca ==nil {_dadd .Colors =int (_fcea );};};

// GetDict returns the *PdfObjectDictionary represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetDict (obj PdfObject )(_bdddb *PdfObjectDictionary ,_cgagf bool ){_bdddb ,_cgagf =TraceToDirectObject (obj ).(*PdfObjectDictionary );return _bdddb ,_cgagf ;};

// WriteString outputs the object as it is to be written to file.
func (_aacc *PdfObjectBool )WriteString ()string {if *_aacc {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};

// ToInt64Slice returns a slice of all array elements as an int64 slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_fbba *PdfObjectArray )ToInt64Slice ()([]int64 ,error ){var _dfffd []int64 ;for _ ,_fecdd :=range _fbba .Elements (){if _dafa ,_bbede :=_fecdd .(*PdfObjectInteger );_bbede {_dfffd =append (_dfffd ,int64 (*_dafa ));}else {return nil ,ErrTypeError ;};};return _dfffd ,nil ;};

// DecodeStream implements ASCII85 stream decoding.
func (_egec *ASCII85Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _egec .DecodeBytes (streamObj .Stream );};

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_cegg *RunLengthEncoder )EncodeBytes (data []byte )([]byte ,error ){_decg :=_fbd .NewReader (data );var _dgaa []byte ;var _efgf []byte ;_cfeg ,_ceeb :=_decg .ReadByte ();if _ceeb ==_d .EOF {return []byte {},nil ;}else if _ceeb !=nil {return nil ,_ceeb ;};_bacf :=1;for {_ccbc ,_befe :=_decg .ReadByte ();if _befe ==_d .EOF {break ;}else if _befe !=nil {return nil ,_befe ;};if _ccbc ==_cfeg {if len (_efgf )> 0{_efgf =_efgf [:len (_efgf )-1];if len (_efgf )> 0{_dgaa =append (_dgaa ,byte (len (_efgf )-1));_dgaa =append (_dgaa ,_efgf ...);};_bacf =1;_efgf =[]byte {};};_bacf ++;if _bacf >=127{_dgaa =append (_dgaa ,byte (257-_bacf ),_cfeg );_bacf =0;};}else {if _bacf > 0{if _bacf ==1{_efgf =[]byte {_cfeg };}else {_dgaa =append (_dgaa ,byte (257-_bacf ),_cfeg );};_bacf =0;};_efgf =append (_efgf ,_ccbc );if len (_efgf )>=127{_dgaa =append (_dgaa ,byte (len (_efgf )-1));_dgaa =append (_dgaa ,_efgf ...);_efgf =[]byte {};};};_cfeg =_ccbc ;};if len (_efgf )> 0{_dgaa =append (_dgaa ,byte (len (_efgf )-1));_dgaa =append (_dgaa ,_efgf ...);}else if _bacf > 0{_dgaa =append (_dgaa ,byte (257-_bacf ),_cfeg );};_dgaa =append (_dgaa ,128);return _dgaa ,nil ;};

// WriteString outputs the object as it is to be written to file.
func (_afde *PdfObjectArray )WriteString ()string {var _bada _bf .Builder ;_bada .WriteString ("\u005b");for _gcabd ,_ggcb :=range _afde .Elements (){_bada .WriteString (_ggcb .WriteString ());if _gcabd < (_afde .Len ()-1){_bada .WriteString ("\u0020");};};_bada .WriteString ("\u005d");return _bada .String ();};const _gaeg ="\u0053\u0074\u0064C\u0046";

// ToIntegerArray returns a slice of all array elements as an int slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_dbff *PdfObjectArray )ToIntegerArray ()([]int ,error ){var _cgbbd []int ;for _ ,_bdgae :=range _dbff .Elements (){if _aaee ,_geacf :=_bdgae .(*PdfObjectInteger );_geacf {_cgbbd =append (_cgbbd ,int (*_aaee ));}else {return nil ,ErrTypeError ;};};return _cgbbd ,nil ;};

// GetFilterName returns the name of the encoding filter.
func (_cdbca *LZWEncoder )GetFilterName ()string {return StreamEncodingFilterNameLZW };

// ReadAtLeast reads at least n bytes into slice p.
// Returns the number of bytes read (should always be == n), and an error on failure.
func (_gfa *PdfParser )ReadAtLeast (p []byte ,n int )(int ,error ){_eaac :=n ;_aabgc :=0;_cef :=0;for _eaac > 0{_adcc ,_cdcf :=_gfa ._fea .Read (p [_aabgc :]);if _cdcf !=nil {_be .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061d\u0069\u006e\u0067\u0020\u0028\u0025\u0064\u003b\u0025\u0064\u0029\u0020\u0025\u0073",_adcc ,_cef ,_cdcf .Error ());return _aabgc ,_g .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065a\u0064\u0069\u006e\u0067");};_cef ++;_aabgc +=_adcc ;_eaac -=_adcc ;};return _aabgc ,nil ;};func (_eagc *PdfParser )parseXrefTable ()(*PdfObjectDictionary ,error ){var _cedbe *PdfObjectDictionary ;_adgb ,_eeaf :=_eagc .readTextLine ();if _eeaf !=nil {return nil ,_eeaf ;};_be .Log .Trace ("\u0078\u0072\u0065\u0066 f\u0069\u0072\u0073\u0074\u0020\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_adgb );_bgfd :=-1;_gdfe :=0;_fggb :=false ;_dabf :="";for {_eagc .skipSpaces ();_ ,_bdda :=_eagc ._fea .Peek (1);if _bdda !=nil {return nil ,_bdda ;};_adgb ,_bdda =_eagc .readTextLine ();if _bdda !=nil {return nil ,_bdda ;};_bcgf :=_eeag .FindStringSubmatch (_adgb );if len (_bcgf )==0{_agfa :=len (_dabf )> 0;_dabf +=_adgb +"\u000a";if _agfa {_bcgf =_eeag .FindStringSubmatch (_dabf );};};if len (_bcgf )==3{_fgffa ,_ :=_a .Atoi (_bcgf [1]);_aggf ,_ :=_a .Atoi (_bcgf [2]);_bgfd =_fgffa ;_gdfe =_aggf ;_fggb =true ;_dabf ="";_be .Log .Trace ("\u0078r\u0065\u0066 \u0073\u0075\u0062s\u0065\u0063\u0074\u0069\u006f\u006e\u003a \u0066\u0069\u0072\u0073\u0074\u0020o\u0062\u006a\u0065\u0063\u0074\u003a\u0020\u0025\u0064\u0020\u006fb\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_bgfd ,_gdfe );continue ;};_effd :=_fecdf .FindStringSubmatch (_adgb );if len (_effd )==4{if _fggb ==false {_be .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0058r\u0065\u0066\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u006fr\u006da\u0074\u0021\u000a");return nil ,_g .New ("\u0078\u0072\u0065\u0066 i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072\u006d\u0061\u0074");};_bdgb ,_ :=_a .ParseInt (_effd [1],10,64);_fffb ,_ :=_a .Atoi (_effd [2]);_cafd :=_effd [3];_dabf ="";if _bf .ToLower (_cafd )=="\u006e"&&_bdgb > 1{_fgdce ,_gcgg :=_eagc ._eegf .ObjectMap [_bgfd ];if !_gcgg ||_fffb > _fgdce .Generation {_cega :=XrefObject {ObjectNumber :_bgfd ,XType :XrefTypeTableEntry ,Offset :_bdgb ,Generation :_fffb };_eagc ._eegf .ObjectMap [_bgfd ]=_cega ;};};_bgfd ++;continue ;};if (len (_adgb )> 6)&&(_adgb [:7]=="\u0074r\u0061\u0069\u006c\u0065\u0072"){_be .Log .Trace ("\u0046o\u0075n\u0064\u0020\u0074\u0072\u0061i\u006c\u0065r\u0020\u002d\u0020\u0025\u0073",_adgb );if len (_adgb )> 9{_bbcc :=_eagc .GetFileOffset ();_eagc .SetFileOffset (_bbcc -int64 (len (_adgb ))+7);};_eagc .skipSpaces ();_eagc .skipComments ();_be .Log .Trace ("R\u0065\u0061\u0064\u0069ng\u0020t\u0072\u0061\u0069\u006c\u0065r\u0020\u0064\u0069\u0063\u0074\u0021");_be .Log .Trace ("\u0070\u0065\u0065\u006b\u003a\u0020\u0022\u0025\u0073\u0022",_adgb );_cedbe ,_bdda =_eagc .ParseDict ();_be .Log .Trace ("\u0045O\u0046\u0020\u0072\u0065a\u0064\u0069\u006e\u0067\u0020t\u0072a\u0069l\u0065\u0072\u0020\u0064\u0069\u0063\u0074!");if _bdda !=nil {_be .Log .Debug ("\u0045\u0072\u0072o\u0072\u0020\u0070\u0061r\u0073\u0069\u006e\u0067\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u0064\u0069\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_bdda );return nil ,_bdda ;};break ;};if _adgb =="\u0025\u0025\u0045O\u0046"{_be .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006e\u0064 \u006f\u0066\u0020\u0066\u0069\u006c\u0065 -\u0020\u0074\u0072\u0061i\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066ou\u006e\u0064 \u002d\u0020\u0065\u0072\u0072\u006f\u0072\u0021");return nil ,_g .New ("\u0065\u006e\u0064 \u006f\u0066\u0020\u0066i\u006c\u0065\u0020\u002d\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};_be .Log .Trace ("\u0078\u0072\u0065\u0066\u0020\u006d\u006f\u0072\u0065 \u003a\u0020\u0025\u0073",_adgb );};_be .Log .Trace ("\u0045\u004f\u0046 p\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0021");if _eagc ._ebg ==nil {_fcdag :=XrefTypeTableEntry ;_eagc ._ebg =&_fcdag ;};return _cedbe ,nil ;};

// NewEncoderFromStream creates a StreamEncoder based on the stream's dictionary.
func NewEncoderFromStream (streamObj *PdfObjectStream )(StreamEncoder ,error ){_caegd :=TraceToDirectObject (streamObj .PdfObjectDictionary .Get ("\u0046\u0069\u006c\u0074\u0065\u0072"));if _caegd ==nil {return NewRawEncoder (),nil ;};if _ ,_cagd :=_caegd .(*PdfObjectNull );_cagd {return NewRawEncoder (),nil ;};_ebfd ,_dcfbc :=_caegd .(*PdfObjectName );if !_dcfbc {_acdb ,_geag :=_caegd .(*PdfObjectArray );if !_geag {return nil ,_e .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006f\u0072 \u0041\u0072\u0072\u0061\u0079\u0020\u006fb\u006a\u0065\u0063\u0074");};if _acdb .Len ()==0{return NewRawEncoder (),nil ;};if _acdb .Len ()!=1{_ecfe ,_edg :=_egb (streamObj );if _edg !=nil {_be .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0063\u0072\u0065\u0061\u0074\u0069\u006e\u0067\u0020\u006d\u0075\u006c\u0074i\u0020\u0065\u006e\u0063\u006f\u0064\u0065r\u003a\u0020\u0025\u0076",_edg );return nil ,_edg ;};_be .Log .Trace ("\u004d\u0075\u006c\u0074\u0069\u0020\u0065\u006e\u0063:\u0020\u0025\u0073\u000a",_ecfe );return _ecfe ,nil ;};_caegd =_acdb .Get (0);_ebfd ,_geag =_caegd .(*PdfObjectName );if !_geag {return nil ,_e .Errorf ("\u0066\u0069l\u0074\u0065\u0072\u0020a\u0072\u0072a\u0079\u0020\u006d\u0065\u006d\u0062\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006fb\u006a\u0065\u0063\u0074");};};switch *_ebfd {case StreamEncodingFilterNameFlate :return _bbff (streamObj ,nil );case StreamEncodingFilterNameLZW :return _gagd (streamObj ,nil );case StreamEncodingFilterNameDCT :return _ddge (streamObj ,nil );case StreamEncodingFilterNameRunLength :return _fece (streamObj ,nil );case StreamEncodingFilterNameASCIIHex :return NewASCIIHexEncoder (),nil ;case StreamEncodingFilterNameASCII85 ,"\u0041\u0038\u0035":return NewASCII85Encoder (),nil ;case StreamEncodingFilterNameCCITTFax :return _bcga (streamObj ,nil );case StreamEncodingFilterNameJBIG2 :return _dagb (streamObj ,nil );case StreamEncodingFilterNameJPX :return NewJPXEncoder (),nil ;};_be .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064\u0069\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006fd\u0021");return nil ,_e .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064i\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006f\u0064\u0020\u0028\u0025\u0073\u0029",*_ebfd );};