//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package core defines and implements the primitive PDF object types in golang, and provides functionality
// for parsing those from a PDF file stream. This includes I/O handling, cross references, repairs, encryption,
// encoding and other core capabilities.
package core ;import (_ga "bufio";_acf "bytes";_gd "compress/lzw";_gg "compress/zlib";_cg "crypto/md5";_fe "crypto/rand";_ed "encoding/hex";_d "errors";_ad "fmt";_fc "github.com/unidoc/unipdf/v3/common";_db "github.com/unidoc/unipdf/v3/core/security";_fa "github.com/unidoc/unipdf/v3/core/security/crypt";_af "github.com/unidoc/unipdf/v3/internal/ccittfax";_df "github.com/unidoc/unipdf/v3/internal/imageutil";_fcd "github.com/unidoc/unipdf/v3/internal/jbig2";_cb "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_ff "github.com/unidoc/unipdf/v3/internal/jbig2/decoder";_fb "github.com/unidoc/unipdf/v3/internal/jbig2/document";_be "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_gb "github.com/unidoc/unipdf/v3/internal/strutils";_fba "golang.org/x/image/tiff/lzw";_dg "image";_bc "image/color";_f "image/jpeg";_de "io";_ac "os";_g "reflect";_e "regexp";_bf "sort";_a "strconv";_bcb "strings";_c "time";);

// GetObjectNums returns a sorted list of object numbers of the PDF objects in the file.
func (_fddfa *PdfParser )GetObjectNums ()[]int {var _abae []int ;for _ ,_cbgd :=range _fddfa ._cefa .ObjectMap {_abae =append (_abae ,_cbgd .ObjectNumber );};_bf .Ints (_abae );return _abae ;};

// ResolveReferencesDeep recursively traverses through object `o`, looking up and replacing
// references with indirect objects.
// Optionally a map of already deep-resolved objects can be provided via `traversed`. The `traversed` map
// is updated while traversing the objects to avoid traversing same objects multiple times.
func ResolveReferencesDeep (o PdfObject ,traversed map[PdfObject ]struct{})error {if traversed ==nil {traversed =map[PdfObject ]struct{}{};};return _dggbf (o ,0,traversed );};func _cca (_fag int )cryptFilters {return cryptFilters {_bbb :_fa .NewFilterV2 (_fag )}};

// ToGoImage converts the JBIG2Image to the golang image.Image.
func (_aefg *JBIG2Image )ToGoImage ()(_dg .Image ,error ){const _bbdf ="J\u0042I\u0047\u0032\u0049\u006d\u0061\u0067\u0065\u002eT\u006f\u0047\u006f\u0049ma\u0067\u0065";if _aefg .Data ==nil {return nil ,_be .Error (_bbdf ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");};if _aefg .Width ==0||_aefg .Height ==0{return nil ,_be .Error (_bbdf ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");};_fccf ,_dfdf :=_df .NewImage (_aefg .Width ,_aefg .Height ,1,1,_aefg .Data ,nil ,nil );if _dfdf !=nil {return nil ,_dfdf ;};return _fccf ,nil ;};

// Encode encodes previously prepare jbig2 document and stores it as the byte slice.
func (_afdd *JBIG2Encoder )Encode ()(_cbeb []byte ,_caca error ){const _bdde ="J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0045\u006eco\u0064\u0065";if _afdd ._gfeb ==nil {return nil ,_be .Errorf (_bdde ,"\u0064\u006f\u0063u\u006d\u0065\u006e\u0074 \u0069\u006e\u0070\u0075\u0074\u0020\u0064a\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006e\u0065\u0064");};_afdd ._gfeb .FullHeaders =_afdd .DefaultPageSettings .FileMode ;_cbeb ,_caca =_afdd ._gfeb .Encode ();if _caca !=nil {return nil ,_be .Wrap (_caca ,_bdde ,"");};return _cbeb ,nil ;};

// GetFilterName returns the names of the underlying encoding filters,
// separated by spaces.
// Note: This is just a string, should not be used in /Filter dictionary entry. Use GetFilterArray for that.
// TODO(v4): Refactor to GetFilter() which can be used for /Filter (either Name or Array), this can be
//  renamed to String() as a pretty string to use in debugging etc.
func (_feeb *MultiEncoder )GetFilterName ()string {_gdbd :="";for _gfde ,_ccag :=range _feeb ._deeb {_gdbd +=_ccag .GetFilterName ();if _gfde < len (_feeb ._deeb )-1{_gdbd +="\u0020";};};return _gdbd ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on the current encoder settings.
func (_fdde *JBIG2Encoder )MakeDecodeParams ()PdfObject {return MakeDict ()};

// EncodeBytes encodes the image data using either Group3 or Group4 CCITT facsimile (fax) encoding.
// `data` is expected to be 1 color component, 1 byte per component.
func (_dbeb *CCITTFaxEncoder )EncodeBytes (data []byte )([]byte ,error ){var _feca [][]byte ;for _aage :=0;_aage < len (data );_aage +=_dbeb .Columns {_bacf :=make ([]byte ,_dbeb .Columns );_aeff :=0;for _bdgg :=0;_bdgg < _dbeb .Columns ;_bdgg ++{if data [_aage +_bdgg ]==255{_bacf [_aeff ]=1;}else {_bacf [_aeff ]=0;};_aeff ++;};_feca =append (_feca ,_bacf );};_geg :=&_af .Encoder {K :_dbeb .K ,Columns :_dbeb .Columns ,EndOfLine :_dbeb .EndOfLine ,EndOfBlock :_dbeb .EndOfBlock ,BlackIs1 :_dbeb .BlackIs1 ,DamagedRowsBeforeError :_dbeb .DamagedRowsBeforeError ,Rows :_dbeb .Rows ,EncodedByteAlign :_dbeb .EncodedByteAlign };return _geg .Encode (_feca ),nil ;};

// IsEncrypted checks if the document is encrypted. A bool flag is returned indicating the result.
// First time when called, will check if the Encrypt dictionary is accessible through the trailer dictionary.
// If encrypted, prepares a crypt datastructure which can be used to authenticate and decrypt the document.
// On failure, an error is returned.
func (_dege *PdfParser )IsEncrypted ()(bool ,error ){if _dege ._fgae !=nil {return true ,nil ;}else if _dege ._dgef ==nil {return false ,nil ;};_fc .Log .Trace ("\u0043\u0068\u0065c\u006b\u0069\u006e\u0067 \u0065\u006e\u0063\u0072\u0079\u0070\u0074i\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0021");_fgef :=_dege ._dgef .Get ("\u0045n\u0063\u0072\u0079\u0070\u0074");if _fgef ==nil {return false ,nil ;};_fc .Log .Trace ("\u0049\u0073\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u0021");var (_daea *PdfObjectDictionary ;);switch _eaag :=_fgef .(type ){case *PdfObjectDictionary :_daea =_eaag ;case *PdfObjectReference :_fc .Log .Trace ("\u0030\u003a\u0020\u004c\u006f\u006f\u006b\u0020\u0075\u0070\u0020\u0072e\u0066\u0020\u0025\u0071",_eaag );_egegf ,_bcbc :=_dege .LookupByReference (*_eaag );_fc .Log .Trace ("\u0031\u003a\u0020%\u0071",_egegf );if _bcbc !=nil {return false ,_bcbc ;};_bdff ,_ccebf :=_egegf .(*PdfIndirectObject );if !_ccebf {_fc .Log .Debug ("E\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006eo\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072ec\u0074\u0020\u006fb\u006ae\u0063\u0074");return false ,_d .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");};_gbfc ,_ccebf :=_bdff .PdfObject .(*PdfObjectDictionary );_fc .Log .Trace ("\u0032\u003a\u0020%\u0071",_gbfc );if !_ccebf {return false ,_d .New ("\u0074\u0072a\u0069\u006c\u0065\u0072 \u0045\u006ec\u0072\u0079\u0070\u0074\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u006e\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");};_daea =_gbfc ;case *PdfObjectNull :_fc .Log .Debug ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074 \u0069\u0073\u0020a\u0020\u006e\u0075l\u006c\u0020o\u0062\u006a\u0065\u0063\u0074\u002e \u0046il\u0065\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u002e");return false ,nil ;default:return false ,_ad .Errorf ("u\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0079\u0070\u0065: \u0025\u0054",_eaag );};_cfgf ,_baeb :=PdfCryptNewDecrypt (_dege ,_daea ,_dege ._dgef );if _baeb !=nil {return false ,_baeb ;};for _ ,_dfbf :=range []string {"\u0049\u006e\u0066\u006f","\u0045n\u0063\u0072\u0079\u0070\u0074"}{_gecab :=_dege ._dgef .Get (PdfObjectName (_dfbf ));if _gecab ==nil {continue ;};switch _beeg :=_gecab .(type ){case *PdfObjectReference :_cfgf ._dggc [int (_beeg .ObjectNumber )]=struct{}{};case *PdfIndirectObject :_cfgf ._fdg [_beeg ]=true ;_cfgf ._dggc [int (_beeg .ObjectNumber )]=struct{}{};};};_dege ._fgae =_cfgf ;_fc .Log .Trace ("\u0043\u0072\u0079\u0070\u0074\u0065\u0072\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0025\u0062",_cfgf );return true ,nil ;};

// ParseIndirectObject parses an indirect object from the input stream. Can also be an object stream.
// Returns the indirect object (*PdfIndirectObject) or the stream object (*PdfObjectStream).
func (_fdc *PdfParser )ParseIndirectObject ()(PdfObject ,error ){_ccebb :=PdfIndirectObject {};_ccebb ._ddaa =_fdc ;_fc .Log .Trace ("\u002dR\u0065a\u0064\u0020\u0069\u006e\u0064i\u0072\u0065c\u0074\u0020\u006f\u0062\u006a");_aedef ,_fdcf :=_fdc ._edcc .Peek (20);if _fdcf !=nil {if _fdcf !=_de .EOF {_fc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020r\u0065a\u0064\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a");return &_ccebb ,_fdcf ;};};_fc .Log .Trace ("\u0028\u0069\u006edi\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_aedef ));_edcfa :=_adcf .FindStringSubmatchIndex (string (_aedef ));if len (_edcfa )< 6{if _fdcf ==_de .EOF {return nil ,_fdcf ;};_fc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_aedef ));return &_ccebb ,_d .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");};_fdc ._edcc .Discard (_edcfa [0]);_fc .Log .Trace ("O\u0066\u0066\u0073\u0065\u0074\u0073\u0020\u0025\u0020\u0064",_edcfa );_cgaeb :=_edcfa [1]-_edcfa [0];_fdab :=make ([]byte ,_cgaeb );_ ,_fdcf =_fdc .ReadAtLeast (_fdab ,_cgaeb );if _fdcf !=nil {_fc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u0072\u0065\u0061\u0064\u0020-\u0020\u0025\u0073",_fdcf );return nil ,_fdcf ;};_fc .Log .Trace ("\u0074\u0065\u0078t\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_fdab );_cdaba :=_adcf .FindStringSubmatch (string (_fdab ));if len (_cdaba )< 3{_fc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_fdab ));return &_ccebb ,_d .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");};_cebf ,_ :=_a .Atoi (_cdaba [1]);_cacc ,_ :=_a .Atoi (_cdaba [2]);_ccebb .ObjectNumber =int64 (_cebf );_ccebb .GenerationNumber =int64 (_cacc );for {_baee ,_geee :=_fdc ._edcc .Peek (2);if _geee !=nil {return &_ccebb ,_geee ;};_fc .Log .Trace ("I\u006ed\u002e\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_baee ),string (_baee ));if IsWhiteSpace (_baee [0]){_fdc .skipSpaces ();}else if _baee [0]=='%'{_fdc .skipComments ();}else if (_baee [0]=='<')&&(_baee [1]=='<'){_fc .Log .Trace ("\u0043\u0061\u006c\u006c\u0020\u0050\u0061\u0072\u0073e\u0044\u0069\u0063\u0074");_ccebb .PdfObject ,_geee =_fdc .ParseDict ();_fc .Log .Trace ("\u0045\u004f\u0046\u0020Ca\u006c\u006c\u0020\u0050\u0061\u0072\u0073\u0065\u0044\u0069\u0063\u0074\u003a\u0020%\u0076",_geee );if _geee !=nil {return &_ccebb ,_geee ;};_fc .Log .Trace ("\u0050\u0061\u0072\u0073\u0065\u0064\u0020\u0064\u0069\u0063t\u0069\u006f\u006e\u0061\u0072\u0079\u002e.\u002e\u0020\u0066\u0069\u006e\u0069\u0073\u0068\u0065\u0064\u002e");}else if (_baee [0]=='/')||(_baee [0]=='(')||(_baee [0]=='[')||(_baee [0]=='<'){_ccebb .PdfObject ,_geee =_fdc .parseObject ();if _geee !=nil {return &_ccebb ,_geee ;};_fc .Log .Trace ("P\u0061\u0072\u0073\u0065\u0064\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u002e\u002e\u002e \u0066\u0069\u006ei\u0073h\u0065\u0064\u002e");}else if _baee [0]==']'{_fc .Log .Debug ("\u0057\u0041\u0052\u004e\u0049N\u0047\u003a\u0020\u0027\u005d\u0027 \u0063\u0068\u0061\u0072\u0061\u0063\u0074e\u0072\u0020\u006eo\u0074\u0020\u0062\u0065i\u006e\u0067\u0020\u0075\u0073\u0065d\u0020\u0061\u0073\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006e\u0064\u0069n\u0067\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e");_fdc ._edcc .Discard (1);}else {if _baee [0]=='e'{_ebfc ,_gcdf :=_fdc .readTextLine ();if _gcdf !=nil {return nil ,_gcdf ;};if len (_ebfc )>=6&&_ebfc [0:6]=="\u0065\u006e\u0064\u006f\u0062\u006a"{break ;};}else if _baee [0]=='s'{_baee ,_ =_fdc ._edcc .Peek (10);if string (_baee [:6])=="\u0073\u0074\u0072\u0065\u0061\u006d"{_dccda :=6;if len (_baee )> 6{if IsWhiteSpace (_baee [_dccda ])&&_baee [_dccda ]!='\r'&&_baee [_dccda ]!='\n'{_fc .Log .Debug ("\u004e\u006fn\u002d\u0063\u006f\u006e\u0066\u006f\u0072\u006d\u0061\u006e\u0074\u0020\u0050\u0044\u0046\u0020\u006e\u006f\u0074 \u0065\u006e\u0064\u0069\u006e\u0067 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0069\u006e\u0065\u0020\u0070\u0072o\u0070\u0065r\u006c\u0079\u0020\u0077i\u0074\u0068\u0020\u0045\u004fL\u0020\u006d\u0061\u0072\u006b\u0065\u0072");_dccda ++;};if _baee [_dccda ]=='\r'{_dccda ++;if _baee [_dccda ]=='\n'{_dccda ++;};}else if _baee [_dccda ]=='\n'{_dccda ++;};};_fdc ._edcc .Discard (_dccda );_gcff ,_dece :=_ccebb .PdfObject .(*PdfObjectDictionary );if !_dece {return nil ,_d .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006di\u0073s\u0069\u006e\u0067\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_fc .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0069c\u0074\u0020\u0025\u0073",_gcff );_ggcg ,_afedde :=_fdc .traceStreamLength (_gcff .Get ("\u004c\u0065\u006e\u0067\u0074\u0068"));if _afedde !=nil {_fc .Log .Debug ("\u0046\u0061\u0069l\u0020\u0074\u006f\u0020t\u0072\u0061\u0063\u0065\u0020\u0073\u0074r\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0025\u0076",_afedde );return nil ,_afedde ;};_fc .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_ggcg );_eeeb ,_gcfgf :=_ggcg .(*PdfObjectInteger );if !_gcfgf {return nil ,_d .New ("\u0073\u0074re\u0061\u006d\u0020l\u0065\u006e\u0067\u0074h n\u0065ed\u0073\u0020\u0074\u006f\u0020\u0062\u0065 a\u006e\u0020\u0069\u006e\u0074\u0065\u0067e\u0072");};_gbaa :=*_eeeb ;if _gbaa < 0{return nil ,_d .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006e\u0065\u0065\u0064\u0073\u0020\u0074\u006f \u0062e\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0030");};_bgfb :=_fdc .GetFileOffset ();_fffe :=_fdc .xrefNextObjectOffset (_bgfb );if _bgfb +int64 (_gbaa )> _fffe &&_fffe > _bgfb {_fc .Log .Debug ("E\u0078\u0070\u0065\u0063te\u0064 \u0065\u006e\u0064\u0069\u006eg\u0020\u0061\u0074\u0020\u0025\u0064",_bgfb +int64 (_gbaa ));_fc .Log .Debug ("\u004e\u0065\u0078\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020\u0061t\u0020\u0025\u0064",_fffe );_fdfb :=_fffe -_bgfb -17;if _fdfb < 0{return nil ,_d .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020go\u0069\u006e\u0067 \u0070\u0061s\u0074\u0020\u0062\u006f\u0075\u006ed\u0061\u0072i\u0065\u0073");};_fc .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0061\u0020l\u0065\u006e\u0067\u0074\u0068\u0020c\u006f\u0072\u0072\u0065\u0063\u0074\u0069\u006f\u006e\u0020\u0074\u006f\u0020%\u0064\u002e\u002e\u002e",_fdfb );_gbaa =PdfObjectInteger (_fdfb );_gcff .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (_fdfb ));};if int64 (_gbaa )> _fdc ._afgg {_fc .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0053t\u0072\u0065\u0061\u006d\u0020l\u0065\u006e\u0067\u0074\u0068\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u0061\u0072\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0066\u0069\u006c\u0065\u0020\u0073\u0069\u007a\u0065");return nil ,_d .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020la\u0072\u0067\u0065r\u0020\u0074h\u0061\u006e\u0020\u0066\u0069\u006ce\u0020\u0073i\u007a\u0065");};_fbaa :=make ([]byte ,_gbaa );_ ,_afedde =_fdc .ReadAtLeast (_fbaa ,int (_gbaa ));if _afedde !=nil {_fc .Log .Debug ("E\u0052\u0052\u004f\u0052 s\u0074r\u0065\u0061\u006d\u0020\u0028%\u0064\u0029\u003a\u0020\u0025\u0058",len (_fbaa ),_fbaa );_fc .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_afedde );return nil ,_afedde ;};_cgaf :=PdfObjectStream {};_cgaf .Stream =_fbaa ;_cgaf .PdfObjectDictionary =_ccebb .PdfObject .(*PdfObjectDictionary );_cgaf .ObjectNumber =_ccebb .ObjectNumber ;_cgaf .GenerationNumber =_ccebb .GenerationNumber ;_cgaf .PdfObjectReference ._ddaa =_fdc ;_fdc .skipSpaces ();_fdc ._edcc .Discard (9);_fdc .skipSpaces ();return &_cgaf ,nil ;};};_ccebb .PdfObject ,_geee =_fdc .parseObject ();if _ccebb .PdfObject ==nil {_fc .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");_ccebb .PdfObject =MakeNull ();};return &_ccebb ,_geee ;};};if _ccebb .PdfObject ==nil {_fc .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");_ccebb .PdfObject =MakeNull ();};_fc .Log .Trace ("\u0052\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0021");return &_ccebb ,nil ;};

// PdfParser parses a PDF file and provides access to the object structure of the PDF.
type PdfParser struct{_ggdd Version ;_ffgb _de .ReadSeeker ;_edcc *_ga .Reader ;_afgg int64 ;_cefa XrefTable ;_fde int64 ;_gegg *xrefType ;_ead objectStreams ;_dgef *PdfObjectDictionary ;_fgae *PdfCrypt ;_bcgg bool ;ObjCache objectCache ;_eggc map[int64 ]bool ;};

// NewLZWEncoder makes a new LZW encoder with default parameters.
func NewLZWEncoder ()*LZWEncoder {_bbff :=&LZWEncoder {};_bbff .Predictor =1;_bbff .BitsPerComponent =8;_bbff .Colors =1;_bbff .Columns =1;_bbff .EarlyChange =1;return _bbff ;};func _bdc (_aaa *_db .StdEncryptDict ,_bcgd *PdfObjectDictionary )error {R ,_dcad :=_bcgd .Get ("\u0052").(*PdfObjectInteger );if !_dcad {return _d .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0052");};if *R < 2||*R > 6{return _ad .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0052 \u0028\u0025\u0064\u0029",*R );};_aaa .R =int (*R );O ,_dcad :=_bcgd .GetString ("\u004f");if !_dcad {return _d .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u004f");};if _aaa .R ==5||_aaa .R ==6{if len (O )< 48{return _ad .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u004f\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (O ));};}else if len (O )!=32{return _ad .Errorf ("L\u0065n\u0067\u0074\u0068\u0028\u004f\u0029\u0020\u0021=\u0020\u0033\u0032\u0020(%\u0064\u0029",len (O ));};_aaa .O =[]byte (O );U ,_dcad :=_bcgd .GetString ("\u0055");if !_dcad {return _d .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0055");};if _aaa .R ==5||_aaa .R ==6{if len (U )< 48{return _ad .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u0055\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (U ));};}else if len (U )!=32{_fc .Log .Debug ("\u0057\u0061r\u006e\u0069\u006e\u0067\u003a\u0020\u004c\u0065\u006e\u0067\u0074\u0068\u0028\u0055\u0029\u0020\u0021\u003d\u0020\u0033\u0032\u0020(%\u0064\u0029",len (U ));};_aaa .U =[]byte (U );if _aaa .R >=5{OE ,_cee :=_bcgd .GetString ("\u004f\u0045");if !_cee {return _d .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u004f\u0045");}else if len (OE )!=32{return _ad .Errorf ("L\u0065\u006e\u0067\u0074h(\u004fE\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (OE ));};_aaa .OE =[]byte (OE );UE ,_cee :=_bcgd .GetString ("\u0055\u0045");if !_cee {return _d .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u0055\u0045");}else if len (UE )!=32{return _ad .Errorf ("L\u0065\u006e\u0067\u0074h(\u0055E\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (UE ));};_aaa .UE =[]byte (UE );};P ,_dcad :=_bcgd .Get ("\u0050").(*PdfObjectInteger );if !_dcad {return _d .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074 \u0064\u0069\u0063t\u0069\u006f\u006e\u0061r\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0070\u0065\u0072\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0061\u0074\u0074\u0072");};_aaa .P =_db .Permissions (*P );if _aaa .R ==6{Perms ,_ecc :=_bcgd .GetString ("\u0050\u0065\u0072m\u0073");if !_ecc {return _d .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0050\u0065\u0072\u006d\u0073");}else if len (Perms )!=16{return _ad .Errorf ("\u004ce\u006e\u0067\u0074\u0068\u0028\u0050\u0065\u0072\u006d\u0073\u0029 \u0021\u003d\u0020\u0031\u0036\u0020\u0028\u0025\u0064\u0029",len (Perms ));};_aaa .Perms =[]byte (Perms );};if _acbf ,_fca :=_bcgd .Get ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061").(*PdfObjectBool );_fca {_aaa .EncryptMetadata =bool (*_acbf );}else {_aaa .EncryptMetadata =true ;};return nil ;};func (_fef *PdfCrypt )newEncryptDict ()*PdfObjectDictionary {_cgbf :=MakeDict ();_cgbf .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName ("\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"));_cgbf .Set ("\u0056",MakeInteger (int64 (_fef ._dbb .V )));_cgbf .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_fef ._dbb .Length )));return _cgbf ;};func (_dfe *PdfCrypt )loadCryptFilters (_bdb *PdfObjectDictionary )error {_dfe ._fgb =cryptFilters {};_fcg :=_bdb .Get ("\u0043\u0046");_fcg =TraceToDirectObject (_fcg );if _bcge ,_ceec :=_fcg .(*PdfObjectReference );_ceec {_aacb ,_bgf :=_dfe ._fgbc .LookupByReference (*_bcge );if _bgf !=nil {_fc .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0075\u0070\u0020\u0043\u0046\u0020\u0072\u0065\u0066\u0065\u0072en\u0063\u0065");return _bgf ;};_fcg =TraceToDirectObject (_aacb );};_gfd ,_edbg :=_fcg .(*PdfObjectDictionary );if !_edbg {_fc .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0043\u0046\u002c \u0074\u0079\u0070\u0065: \u0025\u0054",_fcg );return _d .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0043\u0046");};for _ ,_cfc :=range _gfd .Keys (){_efdg :=_gfd .Get (_cfc );if _bdf ,_bad :=_efdg .(*PdfObjectReference );_bad {_bdgf ,_cae :=_dfe ._fgbc .LookupByReference (*_bdf );if _cae !=nil {_fc .Log .Debug ("\u0045\u0072ro\u0072\u0020\u006co\u006f\u006b\u0075\u0070 up\u0020di\u0063\u0074\u0069\u006f\u006e\u0061\u0072y \u0072\u0065\u0066\u0065\u0072\u0065\u006ec\u0065");return _cae ;};_efdg =TraceToDirectObject (_bdgf );};_eca ,_fcb :=_efdg .(*PdfObjectDictionary );if !_fcb {return _ad .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074\u0020\u0069\u006e \u0043\u0046\u0020\u0028\u006e\u0061\u006d\u0065\u0020\u0025\u0073\u0029\u0020-\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079\u0020\u0062\u0075\u0074\u0020\u0025\u0054",_cfc ,_efdg );};if _cfc =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{_fc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u002d\u0020\u0043\u0061\u006e\u006e\u006f\u0074\u0020\u006f\u0076\u0065\u0072\u0077r\u0069\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0069d\u0065\u006e\u0074\u0069\u0074\u0079\u0020\u0066\u0069\u006c\u0074\u0065\u0072 \u002d\u0020\u0054\u0072\u0079\u0069n\u0067\u0020\u006ee\u0078\u0074");continue ;};var _aeb _fa .FilterDict ;if _acbe :=_abf (&_aeb ,_eca );_acbe !=nil {return _acbe ;};_dfea ,_bbc :=_fa .NewFilter (_aeb );if _bbc !=nil {return _bbc ;};_dfe ._fgb [string (_cfc )]=_dfea ;};_dfe ._fgb ["\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"]=_fa .NewIdentity ();_dfe ._ebcg ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _dab ,_ffg :=_bdb .Get ("\u0053\u0074\u0072\u0046").(*PdfObjectName );_ffg {if _ ,_ggef :=_dfe ._fgb [string (*_dab )];!_ggef {return _ad .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u0072\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_dab );};_dfe ._ebcg =string (*_dab );};_dfe ._efe ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _dag ,_aag :=_bdb .Get ("\u0053\u0074\u006d\u0046").(*PdfObjectName );_aag {if _ ,_cfd :=_dfe ._fgb [string (*_dag )];!_cfd {return _ad .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u006d\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_dag );};_dfe ._efe =string (*_dag );};return nil ;};

// MakeObjectStreams creates an PdfObjectStreams from a list of PdfObjects.
func MakeObjectStreams (objects ...PdfObject )*PdfObjectStreams {_cffe :=&PdfObjectStreams {};_cffe ._fbg =[]PdfObject {};for _ ,_dccfa :=range objects {_cffe ._fbg =append (_cffe ._fbg ,_dccfa );};return _cffe ;};func (_fgdd *PdfParser )rebuildXrefTable ()error {_daacc :=XrefTable {};_daacc .ObjectMap =map[int ]XrefObject {};for _badab ,_ceaa :=range _fgdd ._cefa .ObjectMap {_acdd ,_ ,_aaeeg :=_fgdd .lookupByNumberWrapper (_badab ,false );if _aaeeg !=nil {_fc .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020U\u006e\u0061\u0062\u006ce t\u006f l\u006f\u006f\u006b\u0020\u0075\u0070\u0020ob\u006a\u0065\u0063\u0074\u0020\u0028\u0025s\u0029",_aaeeg );_fc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0063\u006fm\u0070\u006c\u0065\u0074\u0065\u006c\u0079\u0020\u0062\u0072\u006f\u006b\u0065\u006e\u0020\u002d\u0020\u0061\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0074\u006f \u0072\u0065\u0070\u0061\u0069r\u0020");_geba ,_ecce :=_fgdd .repairRebuildXrefsTopDown ();if _ecce !=nil {_fc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0072\u0065\u0062\u0075\u0069l\u0064\u0020\u0072\u0065\u0070a\u0069\u0072 \u0028\u0025\u0073\u0029",_ecce );return _ecce ;};_fgdd ._cefa =*_geba ;_fc .Log .Debug ("\u0052e\u0070\u0061\u0069\u0072e\u0064\u0020\u0078\u0072\u0065f\u0020t\u0061b\u006c\u0065\u0020\u0062\u0075\u0069\u006ct");return nil ;};_abcg ,_cfbb ,_aaeeg :=_da (_acdd );if _aaeeg !=nil {return _aaeeg ;};_ceaa .ObjectNumber =int (_abcg );_ceaa .Generation =int (_cfbb );_daacc .ObjectMap [int (_abcg )]=_ceaa ;};_fgdd ._cefa =_daacc ;_fc .Log .Debug ("N\u0065w\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061b\u006c\u0065\u0020\u0062ui\u006c\u0074");_ged (_fgdd ._cefa );return nil ;};

// ASCII85Encoder implements ASCII85 encoder/decoder.
type ASCII85Encoder struct{};

// ToFloat64Array returns a slice of all elements in the array as a float64 slice.  An error is
// returned if the array contains non-numeric objects (each element can be either PdfObjectInteger
// or PdfObjectFloat).
func (_cfcg *PdfObjectArray )ToFloat64Array ()([]float64 ,error ){var _cced []float64 ;for _ ,_acad :=range _cfcg .Elements (){switch _ebga :=_acad .(type ){case *PdfObjectInteger :_cced =append (_cced ,float64 (*_ebga ));case *PdfObjectFloat :_cced =append (_cced ,float64 (*_ebga ));default:return nil ,ErrTypeError ;};};return _cced ,nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_fece *FlateEncoder )MakeDecodeParams ()PdfObject {if _fece .Predictor > 1{_dff :=MakeDict ();_dff .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_fece .Predictor )));if _fece .BitsPerComponent !=8{_dff .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_fece .BitsPerComponent )));};if _fece .Columns !=1{_dff .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_fece .Columns )));};if _fece .Colors !=1{_dff .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_fece .Colors )));};return _dff ;};return nil ;};

// Merge merges in key/values from another dictionary. Overwriting if has same keys.
// The mutated dictionary (d) is returned in order to allow method chaining.
func (_baeeb *PdfObjectDictionary )Merge (another *PdfObjectDictionary )*PdfObjectDictionary {if another !=nil {for _ ,_adbgc :=range another .Keys (){_fdag :=another .Get (_adbgc );_baeeb .Set (_adbgc ,_fdag );};};return _baeeb ;};var _defe =_e .MustCompile ("\u005b\\\u0072\u005c\u006e\u005d\u005c\u0073\u002a\u0028\u0078\u0072\u0065f\u0029\u005c\u0073\u002a\u005b\u005c\u0072\u005c\u006e\u005d");

// MakeArray creates an PdfObjectArray from a list of PdfObjects.
func MakeArray (objects ...PdfObject )*PdfObjectArray {_ecdc :=&PdfObjectArray {};_ecdc ._fbbf =[]PdfObject {};for _ ,_adbge :=range objects {_ecdc ._fbbf =append (_ecdc ._fbbf ,_adbge );};return _ecdc ;};

// PdfObject is an interface which all primitive PDF objects must implement.
type PdfObject interface{

// String outputs a string representation of the primitive (for debugging).
String ()string ;

// WriteString outputs the PDF primitive as written to file as expected by the standard.
// TODO(dennwc): it should return a byte slice, or accept a writer
WriteString ()string ;};

// MakeIndirectObject creates an PdfIndirectObject with a specified direct object PdfObject.
func MakeIndirectObject (obj PdfObject )*PdfIndirectObject {_fcdg :=&PdfIndirectObject {};_fcdg .PdfObject =obj ;return _fcdg ;};func _bgfd (_bgg *PdfObjectStream ,_cdc *PdfObjectDictionary )(*FlateEncoder ,error ){_bgdb :=NewFlateEncoder ();_agc :=_bgg .PdfObjectDictionary ;if _agc ==nil {return _bgdb ,nil ;};_bgdb ._aba =_bfea (_agc );if _cdc ==nil {_babf :=TraceToDirectObject (_agc .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));switch _bfdc :=_babf .(type ){case *PdfObjectArray :_fcdc :=_bfdc ;if _fcdc .Len ()!=1{_fc .Log .Debug ("\u0045\u0072\u0072\u006f\u0072:\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020a\u0072\u0072\u0061\u0079\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0021\u003d\u0020\u0031\u0020\u0028\u0025\u0064\u0029",_fcdc .Len ());return nil ,_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_babf =TraceToDirectObject (_fcdc .Get (0));case *PdfObjectDictionary :_cdc =_bfdc ;case *PdfObjectNull ,nil :default:_fc .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020n\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079 \u0028%\u0054\u0029",_babf );return nil ,_ad .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _cdc ==nil {return _bgdb ,nil ;};_fc .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_cdc .String ());_gag :=_cdc .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");if _gag ==nil {_fc .Log .Debug ("E\u0072\u0072o\u0072\u003a\u0020\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067 \u0066\u0072\u006f\u006d\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073 \u002d\u0020\u0043\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020\u0077\u0069t\u0068\u0020\u0064\u0065\u0066\u0061\u0075\u006c\u0074\u0020\u00281\u0029");}else {_eead ,_adb :=_gag .(*PdfObjectInteger );if !_adb {_fc .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_gag );return nil ,_ad .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_bgdb .Predictor =int (*_eead );};_gag =_cdc .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");if _gag !=nil {_gdga ,_dcd :=_gag .(*PdfObjectInteger );if !_dcd {_fc .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");return nil ,_ad .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_bgdb .BitsPerComponent =int (*_gdga );};if _bgdb .Predictor > 1{_bgdb .Columns =1;_gag =_cdc .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");if _gag !=nil {_agda ,_dgf :=_gag .(*PdfObjectInteger );if !_dgf {return nil ,_ad .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_bgdb .Columns =int (*_agda );};_bgdb .Colors =1;_gag =_cdc .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _gag !=nil {_gffd ,_fgde :=_gag .(*PdfObjectInteger );if !_fgde {return nil ,_ad .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");};_bgdb .Colors =int (*_gffd );};};return _bgdb ,nil ;};

// WriteString outputs the object as it is to be written to file.
func (_afeb *PdfObjectFloat )WriteString ()string {return _a .FormatFloat (float64 (*_afeb ),'f',-1,64);};

// DecodeBytes decodes a multi-encoded slice of bytes by passing it through the
// DecodeBytes method of the underlying encoders.
func (_debf *MultiEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_fafb :=encoded ;var _cdecd error ;for _ ,_faac :=range _debf ._deeb {_fc .Log .Trace ("\u004du\u006c\u0074i\u0020\u0045\u006e\u0063o\u0064\u0065\u0072 \u0044\u0065\u0063\u006f\u0064\u0065\u003a\u0020\u0041pp\u006c\u0079\u0069n\u0067\u0020F\u0069\u006c\u0074\u0065\u0072\u003a \u0025\u0076 \u0025\u0054",_faac ,_faac );_fafb ,_cdecd =_faac .DecodeBytes (_fafb );if _cdecd !=nil {return nil ,_cdecd ;};};return _fafb ,nil ;};

// StreamEncoder represents the interface for all PDF stream encoders.
type StreamEncoder interface{GetFilterName ()string ;MakeDecodeParams ()PdfObject ;MakeStreamDict ()*PdfObjectDictionary ;UpdateParams (_ebe *PdfObjectDictionary );EncodeBytes (_dbdc []byte )([]byte ,error );DecodeBytes (_afa []byte )([]byte ,error );DecodeStream (_edf *PdfObjectStream )([]byte ,error );};

// EncodeBytes encodes data into ASCII85 encoded format.
func (_adgb *ASCII85Encoder )EncodeBytes (data []byte )([]byte ,error ){var _beee _acf .Buffer ;for _gafe :=0;_gafe < len (data );_gafe +=4{_bac :=data [_gafe ];_ccgab :=1;_cdg :=byte (0);if _gafe +1< len (data ){_cdg =data [_gafe +1];_ccgab ++;};_fagf :=byte (0);if _gafe +2< len (data ){_fagf =data [_gafe +2];_ccgab ++;};_eaff :=byte (0);if _gafe +3< len (data ){_eaff =data [_gafe +3];_ccgab ++;};_fcgf :=(uint32 (_bac )<<24)|(uint32 (_cdg )<<16)|(uint32 (_fagf )<<8)|uint32 (_eaff );if _fcgf ==0{_beee .WriteByte ('z');}else {_gec :=_adgb .base256Tobase85 (_fcgf );for _ ,_efdd :=range _gec [:_ccgab +1]{_beee .WriteByte (_efdd +'!');};};};_beee .WriteString ("\u007e\u003e");return _beee .Bytes (),nil ;};

// MakeDict creates and returns an empty PdfObjectDictionary.
func MakeDict ()*PdfObjectDictionary {_cadbg :=&PdfObjectDictionary {};_cadbg ._baca =map[PdfObjectName ]PdfObject {};_cadbg ._baed =[]PdfObjectName {};return _cadbg ;};

// GoImageToJBIG2 creates a binary image on the base of 'i' golang image.Image.
// If the image is not a black/white image then the function converts provided input into
// JBIG2Image with 1bpp. For non grayscale images the function performs the conversion to the grayscale temp image.
// Then it checks the value of the gray image value if it's within bounds of the black white threshold.
// This 'bwThreshold' value should be in range (0.0, 1.0). The threshold checks if the grayscale pixel (uint) value
// is greater or smaller than 'bwThreshold' * 255. Pixels inside the range will be white, and the others will be black.
// If the 'bwThreshold' is equal to -1.0 - JB2ImageAutoThreshold then it's value would be set on the base of
// it's histogram using Triangle method. For more information go to:
// 	https://www.mathworks.com/matlabcentral/fileexchange/28047-gray-image-thresholding-using-the-triangle-method
func GoImageToJBIG2 (i _dg .Image ,bwThreshold float64 )(*JBIG2Image ,error ){const _gefcg ="\u0047\u006f\u0049\u006d\u0061\u0067\u0065\u0054\u006fJ\u0042\u0049\u0047\u0032";if i ==nil {return nil ,_be .Error (_gefcg ,"i\u006d\u0061\u0067\u0065 '\u0069'\u0020\u006e\u006f\u0074\u0020d\u0065\u0066\u0069\u006e\u0065\u0064");};var (_gedd uint8 ;_fbfd _df .Image ;_ggefg error ;);if bwThreshold ==JB2ImageAutoThreshold {_fbfd ,_ggefg =_df .MonochromeConverter .Convert (i );}else if bwThreshold > 1.0||bwThreshold < 0.0{return nil ,_be .Error (_gefcg ,"p\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074h\u0072\u0065\u0073\u0068\u006f\u006c\u0064 i\u0073\u0020\u006e\u006ft\u0020\u0069\u006e\u0020\u0061\u0020\u0072\u0061\u006ege\u0020\u007b0\u002e\u0030\u002c\u0020\u0031\u002e\u0030\u007d");}else {_gedd =uint8 (255*bwThreshold );_fbfd ,_ggefg =_df .MonochromeThresholdConverter (_gedd ).Convert (i );};if _ggefg !=nil {return nil ,_ggefg ;};return _bbfa (_fbfd ),nil ;};func (_fbga *PdfParser )repairRebuildXrefsTopDown ()(*XrefTable ,error ){if _fbga ._bcgg {return nil ,_ad .Errorf ("\u0072\u0065\u0070\u0061\u0069\u0072\u0020\u0066\u0061\u0069\u006c\u0065\u0064");};_fbga ._bcgg =true ;_fbga ._ffgb .Seek (0,_ac .SEEK_SET );_fbga ._edcc =_ga .NewReader (_fbga ._ffgb );_bbeg :=20;_dafb :=make ([]byte ,_bbeg );_aafab :=XrefTable {};_aafab .ObjectMap =make (map[int ]XrefObject );for {_daff ,_ebccf :=_fbga ._edcc .ReadByte ();if _ebccf !=nil {if _ebccf ==_de .EOF {break ;}else {return nil ,_ebccf ;};};if _daff =='j'&&_dafb [_bbeg -1]=='b'&&_dafb [_bbeg -2]=='o'&&IsWhiteSpace (_dafb [_bbeg -3]){_debec :=_bbeg -4;for IsWhiteSpace (_dafb [_debec ])&&_debec > 0{_debec --;};if _debec ==0||!IsDecimalDigit (_dafb [_debec ]){continue ;};for IsDecimalDigit (_dafb [_debec ])&&_debec > 0{_debec --;};if _debec ==0||!IsWhiteSpace (_dafb [_debec ]){continue ;};for IsWhiteSpace (_dafb [_debec ])&&_debec > 0{_debec --;};if _debec ==0||!IsDecimalDigit (_dafb [_debec ]){continue ;};for IsDecimalDigit (_dafb [_debec ])&&_debec > 0{_debec --;};if _debec ==0{continue ;};_cbdd :=_fbga .GetFileOffset ()-int64 (_bbeg -_debec );_ggddb :=append (_dafb [_debec +1:],_daff );_fceefg ,_cafe ,_gdffe :=_aafa (string (_ggddb ));if _gdffe !=nil {_fc .Log .Debug ("\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u006e\u0075\u006d\u0062\u0065r\u003a\u0020\u0025\u0076",_gdffe );return nil ,_gdffe ;};if _cgfag ,_ccafb :=_aafab .ObjectMap [_fceefg ];!_ccafb ||_cgfag .Generation < _cafe {_eeaa :=XrefObject {};_eeaa .XType =XrefTypeTableEntry ;_eeaa .ObjectNumber =int (_fceefg );_eeaa .Generation =int (_cafe );_eeaa .Offset =_cbdd ;_aafab .ObjectMap [_fceefg ]=_eeaa ;};};_dafb =append (_dafb [1:_bbeg ],_daff );};return &_aafab ,nil ;};func _dggbf (_feag PdfObject ,_bgaa int ,_aafe map[PdfObject ]struct{})error {_fc .Log .Trace ("\u0054\u0072\u0061\u0076\u0065\u0072s\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0064\u0061\u0074\u0061 \u0028\u0064\u0065\u0070\u0074\u0068\u0020=\u0020\u0025\u0064\u0029",_bgaa );if _ ,_agfc :=_aafe [_feag ];_agfc {_fc .Log .Trace ("-\u0041\u006c\u0072\u0065ad\u0079 \u0074\u0072\u0061\u0076\u0065r\u0073\u0065\u0064\u002e\u002e\u002e");return nil ;};_aafe [_feag ]=struct{}{};switch _bbeb :=_feag .(type ){case *PdfIndirectObject :_gcfc :=_bbeb ;_fc .Log .Trace ("\u0069\u006f\u003a\u0020\u0025\u0073",_gcfc );_fc .Log .Trace ("\u002d\u0020\u0025\u0073",_gcfc .PdfObject );return _dggbf (_gcfc .PdfObject ,_bgaa +1,_aafe );case *PdfObjectStream :_abcde :=_bbeb ;return _dggbf (_abcde .PdfObjectDictionary ,_bgaa +1,_aafe );case *PdfObjectDictionary :_edbc :=_bbeb ;_fc .Log .Trace ("\u002d\u0020\u0064\u0069\u0063\u0074\u003a\u0020\u0025\u0073",_edbc );for _ ,_fdggc :=range _edbc .Keys (){_ffag :=_edbc .Get (_fdggc );if _bbaa ,_ebgda :=_ffag .(*PdfObjectReference );_ebgda {_fcag :=_bbaa .Resolve ();_edbc .Set (_fdggc ,_fcag );_cbca :=_dggbf (_fcag ,_bgaa +1,_aafe );if _cbca !=nil {return _cbca ;};}else {_beggg :=_dggbf (_ffag ,_bgaa +1,_aafe );if _beggg !=nil {return _beggg ;};};};return nil ;case *PdfObjectArray :_fecc :=_bbeb ;_fc .Log .Trace ("-\u0020\u0061\u0072\u0072\u0061\u0079\u003a\u0020\u0025\u0073",_fecc );for _fcbaf ,_bbfag :=range _fecc .Elements (){if _cbfdg ,_ggcdd :=_bbfag .(*PdfObjectReference );_ggcdd {_ccdg :=_cbfdg .Resolve ();_fecc .Set (_fcbaf ,_ccdg );_cbcgg :=_dggbf (_ccdg ,_bgaa +1,_aafe );if _cbcgg !=nil {return _cbcgg ;};}else {_cdcd :=_dggbf (_bbfag ,_bgaa +1,_aafe );if _cdcd !=nil {return _cdcd ;};};};return nil ;case *PdfObjectReference :_fc .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020T\u0072\u0061\u0063\u0069\u006e\u0067\u0020\u0061\u0020r\u0065\u0066\u0065r\u0065n\u0063\u0065\u0021");return _d .New ("\u0065r\u0072\u006f\u0072\u0020t\u0072\u0061\u0063\u0069\u006eg\u0020a\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");};return nil ;};

// MultiEncoder supports serial encoding.
type MultiEncoder struct{_deeb []StreamEncoder };func (_cddg *PdfParser )parseBool ()(PdfObjectBool ,error ){_bfafg ,_dfca :=_cddg ._edcc .Peek (4);if _dfca !=nil {return PdfObjectBool (false ),_dfca ;};if (len (_bfafg )>=4)&&(string (_bfafg [:4])=="\u0074\u0072\u0075\u0065"){_cddg ._edcc .Discard (4);return PdfObjectBool (true ),nil ;};_bfafg ,_dfca =_cddg ._edcc .Peek (5);if _dfca !=nil {return PdfObjectBool (false ),_dfca ;};if (len (_bfafg )>=5)&&(string (_bfafg [:5])=="\u0066\u0061\u006cs\u0065"){_cddg ._edcc .Discard (5);return PdfObjectBool (false ),nil ;};return PdfObjectBool (false ),_d .New ("\u0075n\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0062o\u006fl\u0065a\u006e\u0020\u0073\u0074\u0072\u0069\u006eg");};

// NewJBIG2Encoder creates a new JBIG2Encoder.
func NewJBIG2Encoder ()*JBIG2Encoder {return &JBIG2Encoder {_gfeb :_fb .InitEncodeDocument (false )}};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_dgeg *ASCII85Encoder )MakeDecodeParams ()PdfObject {return nil };

// PdfObjectInteger represents the primitive PDF integer numerical object.
type PdfObjectInteger int64 ;

// GetFilterName returns the name of the encoding filter.
func (_gbc *ASCIIHexEncoder )GetFilterName ()string {return StreamEncodingFilterNameASCIIHex };

// String returns the state of the bool as "true" or "false".
func (_bgee *PdfObjectBool )String ()string {if *_bgee {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};

// EncodeBytes DCT encodes the passed in slice of bytes.
func (_eagf *DCTEncoder )EncodeBytes (data []byte )([]byte ,error ){_ddbf ,_cage :=_df .NewImage (_eagf .Width ,_eagf .Height ,_eagf .BitsPerComponent ,_eagf .ColorComponents ,data ,nil ,nil );if _cage !=nil {return nil ,_cage ;};_cdeb :=_f .Options {};_cdeb .Quality =_eagf .Quality ;var _fcab _acf .Buffer ;if _cage =_f .Encode (&_fcab ,_ddbf ,&_cdeb );_cage !=nil {return nil ,_cage ;};return _fcab .Bytes (),nil ;};func (_cdgae *PdfParser )parseXref ()(*PdfObjectDictionary ,error ){const _fdfg =20;_bggg ,_ :=_cdgae ._edcc .Peek (_fdfg );for _abdg :=0;_abdg < 2;_abdg ++{if _cdgae ._fde ==0{_cdgae ._fde =_cdgae .GetFileOffset ();};if _adcf .Match (_bggg ){_fc .Log .Trace ("\u0078\u0072e\u0066\u0020\u0070\u006f\u0069\u006e\u0074\u0073\u0020\u0074\u006f\u0020\u0061\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u002e\u0020\u0050\u0072\u006f\u0062\u0061\u0062\u006c\u0079\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063\u0074");_fc .Log .Debug ("\u0073t\u0061r\u0074\u0069\u006e\u0067\u0020w\u0069\u0074h\u0020\u0022\u0025\u0073\u0022",string (_bggg ));return _cdgae .parseXrefStream (nil );};if _ecfff .Match (_bggg ){_fc .Log .Trace ("\u0053\u0074\u0061\u006ed\u0061\u0072\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073e\u0063t\u0069\u006f\u006e\u0020\u0074\u0061\u0062l\u0065\u0021");return _cdgae .parseXrefTable ();};_edfg :=_cdgae .GetFileOffset ();if _cdgae ._fde ==0{_cdgae ._fde =_edfg ;};_cdgae .SetFileOffset (_edfg -_fdfg );defer _cdgae .SetFileOffset (_edfg );_debc ,_ :=_cdgae ._edcc .Peek (_fdfg );_bggg =append (_debc ,_bggg ...);};_fc .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u0078\u0072\u0065f\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006fr\u0020\u0073\u0074\u0072\u0065\u0061\u006d.\u0020\u0052\u0065\u0070\u0061i\u0072\u0020\u0061\u0074\u0074e\u006d\u0070\u0074\u0065\u0064\u003a\u0020\u004c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0065\u0061\u0072\u006c\u0069\u0065\u0073\u0074\u0020x\u0072\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u0062\u006f\u0074to\u006d\u002e");if _afage :=_cdgae .repairSeekXrefMarker ();_afage !=nil {_fc .Log .Debug ("\u0052e\u0070a\u0069\u0072\u0020\u0066\u0061i\u006c\u0065d\u0020\u002d\u0020\u0025\u0076",_afage );return nil ,_afage ;};return _cdgae .parseXrefTable ();};

// MakeArrayFromIntegers creates an PdfObjectArray from a slice of ints, where each array element is
// an PdfObjectInteger.
func MakeArrayFromIntegers (vals []int )*PdfObjectArray {_febf :=MakeArray ();for _ ,_aabg :=range vals {_febf .Append (MakeInteger (int64 (_aabg )));};return _febf ;};func (_dbd *PdfCrypt )isDecrypted (_baa PdfObject )bool {_ ,_fdd :=_dbd ._fdg [_baa ];if _fdd {_fc .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0064\u0065\u0063\u0072y\u0070\u0074\u0065\u0064");return true ;};switch _cagd :=_baa .(type ){case *PdfObjectStream :if _dbd ._ec .R !=5{if _ffd ,_ccbg :=_cagd .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_ccbg &&*_ffd =="\u0058\u0052\u0065\u0066"{return true ;};};case *PdfIndirectObject :if _ ,_fdd =_dbd ._dggc [int (_cagd .ObjectNumber )];_fdd {return true ;};switch _bdca :=_cagd .PdfObject .(type ){case *PdfObjectDictionary :_bcff :=true ;for _ ,_bgcd :=range _fad {if _bdca .Get (_bgcd )==nil {_bcff =false ;break ;};};if _bcff {return true ;};};};_fc .Log .Trace ("\u004e\u006f\u0074\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");return false ;};

// Resolve resolves the reference and returns the indirect or stream object.
// If the reference cannot be resolved, a *PdfObjectNull object is returned.
func (_fcdgc *PdfObjectReference )Resolve ()PdfObject {if _fcdgc ._ddaa ==nil {return MakeNull ();};_fcdgd ,_ ,_gccf :=_fcdgc ._ddaa .resolveReference (_fcdgc );if _gccf !=nil {_fc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0072\u0065\u0073\u006f\u006cv\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065r\u0065n\u0063\u0065\u003a\u0020\u0025\u0076\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074",_gccf );return MakeNull ();};if _fcdgd ==nil {_fc .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0072\u0065\u0073ol\u0076\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065:\u0020\u006ei\u006c\u0020\u006fb\u006a\u0065\u0063\u0074\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u0061\u0020nu\u006c\u006c\u0020o\u0062\u006a\u0065\u0063\u0074");return MakeNull ();};return _fcdgd ;};

// Elements returns a slice of the PdfObject elements in the array.
func (_addcf *PdfObjectArray )Elements ()[]PdfObject {if _addcf ==nil {return nil ;};return _addcf ._fbbf ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_feac *JPXEncoder )MakeDecodeParams ()PdfObject {return nil };

// NewASCIIHexEncoder makes a new ASCII hex encoder.
func NewASCIIHexEncoder ()*ASCIIHexEncoder {_age :=&ASCIIHexEncoder {};return _age };

// DrawableImage is same as golang image/draw's Image interface that allow drawing images.
type DrawableImage interface{ColorModel ()_bc .Model ;Bounds ()_dg .Rectangle ;At (_eefc ,_gdfe int )_bc .Color ;Set (_gfda ,_cfad int ,_deegd _bc .Color );};

// GetStream returns the *PdfObjectStream represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetStream (obj PdfObject )(_cgbb *PdfObjectStream ,_gfdac bool ){obj =ResolveReference (obj );_cgbb ,_gfdac =obj .(*PdfObjectStream );return _cgbb ,_gfdac ;};

// String returns a string describing `ind`.
func (_cbba *PdfIndirectObject )String ()string {return _ad .Sprintf ("\u0049\u004f\u0062\u006a\u0065\u0063\u0074\u003a\u0025\u0064",(*_cbba ).ObjectNumber );};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_fgfb *MultiEncoder )MakeStreamDict ()*PdfObjectDictionary {_fge :=MakeDict ();_fge .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",_fgfb .GetFilterArray ());for _ ,_fagb :=range _fgfb ._deeb {_gecg :=_fagb .MakeStreamDict ();for _ ,_bafcg :=range _gecg .Keys (){_edgf :=_gecg .Get (_bafcg );if _bafcg !="\u0046\u0069\u006c\u0074\u0065\u0072"&&_bafcg !="D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"{_fge .Set (_bafcg ,_edgf );};};};_bbde :=_fgfb .MakeDecodeParams ();if _bbde !=nil {_fge .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_bbde );};return _fge ;};

// GetInt returns the *PdfObjectBool object that is represented by a PdfObject either directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetInt (obj PdfObject )(_afeg *PdfObjectInteger ,_ceag bool ){_afeg ,_ceag =TraceToDirectObject (obj ).(*PdfObjectInteger );return _afeg ,_ceag ;};

// GetNumbersAsFloat converts a list of pdf objects representing floats or integers to a slice of
// float64 values.
func GetNumbersAsFloat (objects []PdfObject )(_aacbd []float64 ,_aagbc error ){for _ ,_bgbe :=range objects {_bec ,_dcfg :=GetNumberAsFloat (_bgbe );if _dcfg !=nil {return nil ,_dcfg ;};_aacbd =append (_aacbd ,_bec );};return _aacbd ,nil ;};

// EqualObjects returns true if `obj1` and `obj2` have the same contents.
//
// NOTE: It is a good idea to flatten obj1 and obj2 with FlattenObject before calling this function
// so that contents, rather than references, can be compared.
func EqualObjects (obj1 ,obj2 PdfObject )bool {return _abaf (obj1 ,obj2 ,0)};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_bcfg *JBIG2Encoder )MakeStreamDict ()*PdfObjectDictionary {_fcead :=MakeDict ();_fcead .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_bcfg .GetFilterName ()));return _fcead ;};var _begg =_e .MustCompile ("\u005e\\\u0073\u002a\u005b\u002d]\u002a\u0028\u005c\u0064\u002b)\u005cs\u002b(\u005c\u0064\u002b\u0029\u005c\u0073\u002bR");func _ggfc (_dgad PdfObject )(*float64 ,error ){switch _dddb :=_dgad .(type ){case *PdfObjectFloat :_dfbfe :=float64 (*_dddb );return &_dfbfe ,nil ;case *PdfObjectInteger :_dccg :=float64 (*_dddb );return &_dccg ,nil ;case *PdfObjectNull :return nil ,nil ;};return nil ,ErrNotANumber ;};func (_fedg *PdfParser )skipComments ()error {if _ ,_gfdae :=_fedg .skipSpaces ();_gfdae !=nil {return _gfdae ;};_eega :=true ;for {_aaada ,_ccbd :=_fedg ._edcc .Peek (1);if _ccbd !=nil {_fc .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_ccbd .Error ());return _ccbd ;};if _eega &&_aaada [0]!='%'{return nil ;};_eega =false ;if (_aaada [0]!='\r')&&(_aaada [0]!='\n'){_fedg ._edcc .ReadByte ();}else {break ;};};return _fedg .skipComments ();};

// MakeStringFromBytes creates an PdfObjectString from a byte array.
// This is more natural than MakeString as `data` is usually not utf-8 encoded.
func MakeStringFromBytes (data []byte )*PdfObjectString {return MakeString (string (data ))};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_feab *FlateEncoder )MakeStreamDict ()*PdfObjectDictionary {_beg :=MakeDict ();_beg .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_feab .GetFilterName ()));_bfafc :=_feab .MakeDecodeParams ();if _bfafc !=nil {_beg .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_bfafc );};return _beg ;};

// WriteString outputs the object as it is to be written to file.
func (_gdgd *PdfObjectInteger )WriteString ()string {return _a .FormatInt (int64 (*_gdgd ),10)};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_ecg *CCITTFaxEncoder )MakeStreamDict ()*PdfObjectDictionary {_gcbg :=MakeDict ();_gcbg .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_ecg .GetFilterName ()));_aec :=_ecg .MakeDecodeParams ();if _aec !=nil {_gcbg .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_aec );};return _gcbg ;};

// SetImage sets the image base for given flate encoder.
func (_cffg *FlateEncoder )SetImage (img *_df .ImageBase ){_cffg ._aba =img };const (_cfgd =0;_fadg =1;_ebcf =2;_bfcb =3;_dfeb =4;);func (_dfbc *PdfParser )repairSeekXrefMarker ()error {_fafbbc ,_abda :=_dfbc ._ffgb .Seek (0,_ac .SEEK_END );if _abda !=nil {return _abda ;};_cgffc :=_e .MustCompile ("\u005cs\u0078\u0072\u0065\u0066\u005c\u0073*");var _fgaa int64 ;var _faef int64 =1000;for _fgaa < _fafbbc {if _fafbbc <=(_faef +_fgaa ){_faef =_fafbbc -_fgaa ;};_ ,_aefd :=_dfbc ._ffgb .Seek (-_fgaa -_faef ,_ac .SEEK_END );if _aefd !=nil {return _aefd ;};_aedd :=make ([]byte ,_faef );_dfbc ._ffgb .Read (_aedd );_fc .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0078\u0072\u0065\u0066\u0020\u003a\u0020\u0022\u0025\u0073\u0022",string (_aedd ));_fadc :=_cgffc .FindAllStringIndex (string (_aedd ),-1);if _fadc !=nil {_acfaf :=_fadc [len (_fadc )-1];_fc .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_fadc );_dfbc ._ffgb .Seek (-_fgaa -_faef +int64 (_acfaf [0]),_ac .SEEK_END );_dfbc ._edcc =_ga .NewReader (_dfbc ._ffgb );for {_acfff ,_adfdg :=_dfbc ._edcc .Peek (1);if _adfdg !=nil {return _adfdg ;};_fc .Log .Trace ("\u0042\u003a\u0020\u0025\u0064\u0020\u0025\u0063",_acfff [0],_acfff [0]);if !IsWhiteSpace (_acfff [0]){break ;};_dfbc ._edcc .Discard (1);};return nil ;};_fc .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");_fgaa +=_faef ;};_fc .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074a\u0062\u006c\u0065\u0020\u006d\u0061r\u006b\u0065\u0072\u0020\u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066o\u0075\u006e\u0064\u002e");return _d .New ("\u0078r\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0020");};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_gcfb *CCITTFaxEncoder )MakeDecodeParams ()PdfObject {_bgfa :=MakeDict ();_bgfa .Set ("\u004b",MakeInteger (int64 (_gcfb .K )));_bgfa .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_gcfb .Columns )));if _gcfb .BlackIs1 {_bgfa .Set ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031",MakeBool (_gcfb .BlackIs1 ));};if _gcfb .EncodedByteAlign {_bgfa .Set ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e",MakeBool (_gcfb .EncodedByteAlign ));};if _gcfb .EndOfLine &&_gcfb .K >=0{_bgfa .Set ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee",MakeBool (_gcfb .EndOfLine ));};if _gcfb .Rows !=0&&!_gcfb .EndOfBlock {_bgfa .Set ("\u0052\u006f\u0077\u0073",MakeInteger (int64 (_gcfb .Rows )));};if !_gcfb .EndOfBlock {_bgfa .Set ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b",MakeBool (_gcfb .EndOfBlock ));};if _gcfb .DamagedRowsBeforeError !=0{_bgfa .Set ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072",MakeInteger (int64 (_gcfb .DamagedRowsBeforeError )));};return _bgfa ;};

// MakeHexString creates an PdfObjectString from a string intended for output as a hexadecimal string.
func MakeHexString (s string )*PdfObjectString {_fbeb :=PdfObjectString {_ddeab :s ,_ddcc :true };return &_fbeb ;};

// PdfObjectArray represents the primitive PDF array object.
type PdfObjectArray struct{_fbbf []PdfObject };

// DecodeStream decodes a JPX encoded stream and returns the result as a
// slice of bytes.
func (_bddf *JPXEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_fc .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_bddf .GetFilterName ());return streamObj .Stream ,ErrNoJPXDecode ;};

// DecodeGlobals decodes 'encoded' byte stream and returns their Globally defined segments ('Globals').
func (_ebcb *JBIG2Encoder )DecodeGlobals (encoded []byte )(_fcd .Globals ,error ){return _fcd .DecodeGlobals (encoded );};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_ddgf *MultiEncoder )MakeDecodeParams ()PdfObject {if len (_ddgf ._deeb )==0{return nil ;};if len (_ddgf ._deeb )==1{return _ddgf ._deeb [0].MakeDecodeParams ();};_gddf :=MakeArray ();for _ ,_adecd :=range _ddgf ._deeb {_egd :=_adecd .MakeDecodeParams ();if _egd ==nil {_gddf .Append (MakeNull ());}else {_gddf .Append (_egd );};};return _gddf ;};

// WriteString outputs the object as it is to be written to file.
func (_gcee *PdfIndirectObject )WriteString ()string {var _geggd _bcb .Builder ;_geggd .WriteString (_a .FormatInt (_gcee .ObjectNumber ,10));_geggd .WriteString ("\u0020\u0030\u0020\u0052");return _geggd .String ();};

// NewEncoderFromStream creates a StreamEncoder based on the stream's dictionary.
func NewEncoderFromStream (streamObj *PdfObjectStream )(StreamEncoder ,error ){_cadc :=TraceToDirectObject (streamObj .PdfObjectDictionary .Get ("\u0046\u0069\u006c\u0074\u0065\u0072"));if _cadc ==nil {return NewRawEncoder (),nil ;};if _ ,_affbg :=_cadc .(*PdfObjectNull );_affbg {return NewRawEncoder (),nil ;};_dfbcb ,_efda :=_cadc .(*PdfObjectName );if !_efda {_gcgge ,_dbfb :=_cadc .(*PdfObjectArray );if !_dbfb {return nil ,_ad .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006f\u0072 \u0041\u0072\u0072\u0061\u0079\u0020\u006fb\u006a\u0065\u0063\u0074");};if _gcgge .Len ()==0{return NewRawEncoder (),nil ;};if _gcgge .Len ()!=1{_ebaf ,_cfaf :=_fddd (streamObj );if _cfaf !=nil {_fc .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0063\u0072\u0065\u0061\u0074\u0069\u006e\u0067\u0020\u006d\u0075\u006c\u0074i\u0020\u0065\u006e\u0063\u006f\u0064\u0065r\u003a\u0020\u0025\u0076",_cfaf );return nil ,_cfaf ;};_fc .Log .Trace ("\u004d\u0075\u006c\u0074\u0069\u0020\u0065\u006e\u0063:\u0020\u0025\u0073\u000a",_ebaf );return _ebaf ,nil ;};_cadc =_gcgge .Get (0);_dfbcb ,_dbfb =_cadc .(*PdfObjectName );if !_dbfb {return nil ,_ad .Errorf ("\u0066\u0069l\u0074\u0065\u0072\u0020a\u0072\u0072a\u0079\u0020\u006d\u0065\u006d\u0062\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006fb\u006a\u0065\u0063\u0074");};};switch *_dfbcb {case StreamEncodingFilterNameFlate :return _bgfd (streamObj ,nil );case StreamEncodingFilterNameLZW :return _cgae (streamObj ,nil );case StreamEncodingFilterNameDCT :return _bgfg (streamObj ,nil );case StreamEncodingFilterNameRunLength :return _dbaf (streamObj ,nil );case StreamEncodingFilterNameASCIIHex :return NewASCIIHexEncoder (),nil ;case StreamEncodingFilterNameASCII85 ,"\u0041\u0038\u0035":return NewASCII85Encoder (),nil ;case StreamEncodingFilterNameCCITTFax :return _abfc (streamObj ,nil );case StreamEncodingFilterNameJBIG2 :return _dfecg (streamObj ,nil );case StreamEncodingFilterNameJPX :return NewJPXEncoder (),nil ;};_fc .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064\u0069\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006fd\u0021");return nil ,_ad .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064i\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006f\u0064\u0020\u0028\u0025\u0073\u0029",*_dfbcb );};var _fcba =_e .MustCompile ("\u005e\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");

// NewASCII85Encoder makes a new ASCII85 encoder.
func NewASCII85Encoder ()*ASCII85Encoder {_fcee :=&ASCII85Encoder {};return _fcee };func (_gaa *PdfCrypt )authenticate (_cacg []byte )(bool ,error ){_gaa ._bcg =false ;_cdd :=_gaa .securityHandler ();_aed ,_gbb ,_bfaf :=_cdd .Authenticate (&_gaa ._ec ,_cacg );if _bfaf !=nil {return false ,_bfaf ;}else if _gbb ==0||len (_aed )==0{return false ,nil ;};_gaa ._bcg =true ;_gaa ._bgb =_aed ;return true ,nil ;};var _ebdge =_e .MustCompile ("\u0025\u0025\u0045\u004f\u0046\u003f");func _ged (_ce XrefTable ){_fc .Log .Debug ("\u003dX\u003d\u0058\u003d\u0058\u003d");_fc .Log .Debug ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");_bbe :=0;for _ ,_bdd :=range _ce .ObjectMap {_fc .Log .Debug ("i\u002b\u0031\u003a\u0020\u0025\u0064 \u0028\u006f\u0062\u006a\u0020\u006eu\u006d\u003a\u0020\u0025\u0064\u0020\u0067e\u006e\u003a\u0020\u0025\u0064\u0029\u0020\u002d\u003e\u0020%\u0064",_bbe +1,_bdd .ObjectNumber ,_bdd .Generation ,_bdd .Offset );_bbe ++;};};

// XrefTable represents the cross references in a PDF, i.e. the table of objects and information
// where to access within the PDF file.
type XrefTable struct{ObjectMap map[int ]XrefObject ;_cgf []XrefObject ;};

// DecodeStream decodes a JBIG2 encoded stream and returns the result as a slice of bytes.
func (_afdgf *JBIG2Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _afdgf .DecodeBytes (streamObj .Stream );};

// DecodeBytes decodes a byte slice from Run length encoding.
//
// 7.4.5 RunLengthDecode Filter
// The RunLengthDecode filter decodes data that has been encoded in a simple byte-oriented format based on run length.
// The encoded data shall be a sequence of runs, where each run shall consist of a length byte followed by 1 to 128
// bytes of data. If the length byte is in the range 0 to 127, the following length + 1 (1 to 128) bytes shall be
// copied literally during decompression. If length is in the range 129 to 255, the following single byte shall be
// copied 257 - length (2 to 128) times during decompression. A length value of 128 shall denote EOD.
func (_cdfb *RunLengthEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_fcde :=_acf .NewReader (encoded );var _dfgf []byte ;for {_acfc ,_fada :=_fcde .ReadByte ();if _fada !=nil {return nil ,_fada ;};if _acfc > 128{_bgbb ,_aga :=_fcde .ReadByte ();if _aga !=nil {return nil ,_aga ;};for _fgfa :=0;_fgfa < 257-int (_acfc );_fgfa ++{_dfgf =append (_dfgf ,_bgbb );};}else if _acfc < 128{for _eced :=0;_eced < int (_acfc )+1;_eced ++{_ccga ,_deef :=_fcde .ReadByte ();if _deef !=nil {return nil ,_deef ;};_dfgf =append (_dfgf ,_ccga );};}else {break ;};};return _dfgf ,nil ;};func (_ecac *PdfParser )readTextLine ()(string ,error ){var _ccdb _acf .Buffer ;for {_egaf ,_caeb :=_ecac ._edcc .Peek (1);if _caeb !=nil {_fc .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_caeb .Error ());return _ccdb .String (),_caeb ;};if (_egaf [0]!='\r')&&(_egaf [0]!='\n'){_cageg ,_ :=_ecac ._edcc .ReadByte ();_ccdb .WriteByte (_cageg );}else {break ;};};return _ccdb .String (),nil ;};

// String returns a string representation of the *PdfObjectString.
func (_dcce *PdfObjectString )String ()string {return _dcce ._ddeab };

// String returns the PDF version as a string. Implements interface fmt.Stringer.
func (_ebdb Version )String ()string {return _ad .Sprintf ("\u00250\u0064\u002e\u0025\u0030\u0064",_ebdb .Major ,_ebdb .Minor );};

// GetXrefType returns the type of the first xref object (table or stream).
func (_geggc *PdfParser )GetXrefType ()*xrefType {return _geggc ._gegg };func (_fbbcb *PdfParser )seekPdfVersionTopDown ()(int ,int ,error ){_fbbcb ._ffgb .Seek (0,_ac .SEEK_SET );_fbbcb ._edcc =_ga .NewReader (_fbbcb ._ffgb );_adga :=20;_ebfd :=make ([]byte ,_adga );for {_eegb ,_dfba :=_fbbcb ._edcc .ReadByte ();if _dfba !=nil {if _dfba ==_de .EOF {break ;}else {return 0,0,_dfba ;};};if IsDecimalDigit (_eegb )&&_ebfd [_adga -1]=='.'&&IsDecimalDigit (_ebfd [_adga -2])&&_ebfd [_adga -3]=='-'&&_ebfd [_adga -4]=='F'&&_ebfd [_adga -5]=='D'&&_ebfd [_adga -6]=='P'{_cfbf :=int (_ebfd [_adga -2]-'0');_gbab :=int (_eegb -'0');return _cfbf ,_gbab ,nil ;};_ebfd =append (_ebfd [1:_adga ],_eegb );};return 0,0,_d .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};

// DecodeImages decodes the page images from the jbig2 'encoded' data input.
// The jbig2 document may contain multiple pages, thus the function can return multiple
// images. The images order corresponds to the page number.
func (_daaca *JBIG2Encoder )DecodeImages (encoded []byte )([]_dg .Image ,error ){const _fddfg ="\u004aB\u0049\u0047\u0032\u0045n\u0063\u006f\u0064\u0065\u0072.\u0044e\u0063o\u0064\u0065\u0049\u006d\u0061\u0067\u0065s";_aagc ,_geaf :=_ff .Decode (encoded ,_ff .Parameters {},_daaca .Globals .ToDocumentGlobals ());if _geaf !=nil {return nil ,_be .Wrap (_geaf ,_fddfg ,"");};_bagd ,_geaf :=_aagc .PageNumber ();if _geaf !=nil {return nil ,_be .Wrap (_geaf ,_fddfg ,"");};_agge :=[]_dg .Image {};var _dfbd _dg .Image ;for _gdba :=1;_gdba <=_bagd ;_gdba ++{_dfbd ,_geaf =_aagc .DecodePageImage (_gdba );if _geaf !=nil {return nil ,_be .Wrapf (_geaf ,_fddfg ,"\u0070\u0061\u0067\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_gdba );};_agge =append (_agge ,_dfbd );};return _agge ,nil ;};

// GetObjectStreams returns the *PdfObjectStreams represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetObjectStreams (obj PdfObject )(_gceed *PdfObjectStreams ,_gbfb bool ){_gceed ,_gbfb =obj .(*PdfObjectStreams );return _gceed ,_gbfb ;};type objectStreams map[int ]objectStream ;func (_gadb *PdfCrypt )isEncrypted (_cgd PdfObject )bool {_ ,_dbbd :=_gadb ._ba [_cgd ];if _dbbd {_fc .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0065\u006e\u0063\u0072y\u0070\u0074\u0065\u0064");return true ;};_fc .Log .Trace ("\u004e\u006f\u0074\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");return false ;};

// IsWhiteSpace checks if byte represents a white space character.
func IsWhiteSpace (ch byte )bool {if (ch ==0x00)||(ch ==0x09)||(ch ==0x0A)||(ch ==0x0C)||(ch ==0x0D)||(ch ==0x20){return true ;};return false ;};

// Resolve resolves a PdfObject to direct object, looking up and resolving references as needed (unlike TraceToDirect).
func (_aac *PdfParser )Resolve (obj PdfObject )(PdfObject ,error ){_bfa ,_gff :=obj .(*PdfObjectReference );if !_gff {return obj ,nil ;};_bde :=_aac .GetFileOffset ();defer func (){_aac .SetFileOffset (_bde )}();_ggec ,_abb :=_aac .LookupByReference (*_bfa );if _abb !=nil {return nil ,_abb ;};_gee ,_cgg :=_ggec .(*PdfIndirectObject );if !_cgg {return _ggec ,nil ;};_ggec =_gee .PdfObject ;_ ,_gff =_ggec .(*PdfObjectReference );if _gff {return _gee ,_d .New ("\u006d\u0075lt\u0069\u0020\u0064e\u0070\u0074\u0068\u0020tra\u0063e \u0070\u006f\u0069\u006e\u0074\u0065\u0072 t\u006f\u0020\u0070\u006f\u0069\u006e\u0074e\u0072");};return _ggec ,nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_geecd *RawEncoder )UpdateParams (params *PdfObjectDictionary ){};type offsetReader struct{_dfda _de .ReadSeeker ;_daf int64 ;};

// ParseNumber parses a numeric objects from a buffered stream.
// Section 7.3.3.
// Integer or Float.
//
// An integer shall be written as one or more decimal digits optionally
// preceded by a sign. The value shall be interpreted as a signed
// decimal integer and shall be converted to an integer object.
//
// A real value shall be written as one or more decimal digits with an
// optional sign and a leading, trailing, or embedded PERIOD (2Eh)
// (decimal point). The value shall be interpreted as a real number
// and shall be converted to a real object.
//
// Regarding exponential numbers: 7.3.3 Numeric Objects:
// A conforming writer shall not use the PostScript syntax for numbers
// with non-decimal radices (such as 16#FFFE) or in exponential format
// (such as 6.02E23).
// Nonetheless, we sometimes get numbers with exponential format, so
// we will support it in the reader (no confusion with other types, so
// no compromise).
func ParseNumber (buf *_ga .Reader )(PdfObject ,error ){_gaddc :=false ;_fcdf :=true ;var _affcb _acf .Buffer ;for {if _fc .Log .IsLogLevel (_fc .LogLevelTrace ){_fc .Log .Trace ("\u0050\u0061\u0072\u0073in\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0022\u0025\u0073\u0022",_affcb .String ());};_ggbf ,_dbce :=buf .Peek (1);if _dbce ==_de .EOF {break ;};if _dbce !=nil {_fc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0025\u0073",_dbce );return nil ,_dbce ;};if _fcdf &&(_ggbf [0]=='-'||_ggbf [0]=='+'){_beeecb ,_ :=buf .ReadByte ();_affcb .WriteByte (_beeecb );_fcdf =false ;}else if IsDecimalDigit (_ggbf [0]){_efaa ,_ :=buf .ReadByte ();_affcb .WriteByte (_efaa );}else if _ggbf [0]=='.'{_cccg ,_ :=buf .ReadByte ();_affcb .WriteByte (_cccg );_gaddc =true ;}else if _ggbf [0]=='e'||_ggbf [0]=='E'{_gcaf ,_ :=buf .ReadByte ();_affcb .WriteByte (_gcaf );_gaddc =true ;_fcdf =true ;}else {break ;};};var _afcd PdfObject ;if _gaddc {_ddge ,_daga :=_a .ParseFloat (_affcb .String (),64);if _daga !=nil {_fc .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0025v\u0020\u0065\u0072\u0072\u003d\u0025v\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0030\u002e\u0020\u004fu\u0074\u0070u\u0074\u0020\u006d\u0061y\u0020\u0062\u0065\u0020\u0069n\u0063\u006f\u0072\u0072\u0065\u0063\u0074",_affcb .String (),_daga );_ddge =0.0;_daga =nil ;};_egdea :=PdfObjectFloat (_ddge );_afcd =&_egdea ;}else {_ecge ,_eccad :=_a .ParseInt (_affcb .String (),10,64);if _eccad !=nil {_fc .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0025\u0076\u0020\u0065\u0072\u0072\u003d%\u0076\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074 \u006d\u0061\u0079\u0020\u0062\u0065 \u0069\u006ec\u006f\u0072r\u0065c\u0074",_affcb .String (),_eccad );_ecge =0;_eccad =nil ;};_cagf :=PdfObjectInteger (_ecge );_afcd =&_cagf ;};return _afcd ,nil ;};var _fad =[]PdfObjectName {"\u0056","\u0052","\u004f","\u0055","\u0050"};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_edaf *RunLengthEncoder )MakeDecodeParams ()PdfObject {return nil };func _dfecg (_faba *PdfObjectStream ,_fddc *PdfObjectDictionary )(*JBIG2Encoder ,error ){const _gabc ="\u006ee\u0077\u004a\u0042\u0049G\u0032\u0044\u0065\u0063\u006fd\u0065r\u0046r\u006f\u006d\u0053\u0074\u0072\u0065\u0061m";_ebca :=&JBIG2Encoder {};_ecba :=_faba .PdfObjectDictionary ;if _ecba ==nil {return _ebca ,nil ;};if _fddc ==nil {_gfg :=_ecba .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _gfg !=nil {switch _dbag :=_gfg .(type ){case *PdfObjectDictionary :_fddc =_dbag ;case *PdfObjectArray :if _dbag .Len ()==1{if _ace ,_feea :=GetDict (_dbag .Get (0));_feea {_fddc =_ace ;};};default:_fc .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065P\u0061\u0072\u0061\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064i\u0063\u0074\u0069\u006f\u006e\u0061\u0072y\u0020\u0025\u0023\u0076",_gfg );return nil ,_be .Errorf (_gabc ,"\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050a\u0072m\u0073\u0020\u0074\u0079\u0070\u0065\u003a \u0025\u0054",_dbag );};};};if _fddc ==nil {return _ebca ,nil ;};_ebca .UpdateParams (_fddc );_ebac :=_fddc .Get ("\u004a\u0042\u0049G\u0032\u0047\u006c\u006f\u0062\u0061\u006c\u0073");if _ebac ==nil {return _ebca ,nil ;};var _fbef error ;_gagg ,_dfdg :=_ebac .(*PdfObjectStream );if !_dfdg {_fbef =_be .Error (_gabc ,"j\u0062\u0069\u0067\u0032\u002e\u0047\u006c\u006f\u0062a\u006c\u0073\u0020\u0073\u0074\u0072\u0065am\u0020\u0073\u0068\u006fu\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u006e\u0020Ob\u006a\u0065c\u0074\u0020\u0053\u0074\u0072\u0065\u0061\u006d");_fc .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_fbef );return nil ,_fbef ;};_ebca .Globals ,_fbef =_fcd .DecodeGlobals (_gagg .Stream );if _fbef !=nil {_fbef =_be .Wrap (_fbef ,_gabc ,"\u0063\u006f\u0072\u0072u\u0070\u0074\u0065\u0064\u0020\u006a\u0062\u0069\u0067\u0032 \u0065n\u0063\u006f\u0064\u0065\u0064\u0020\u0064a\u0074\u0061");_fc .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_fbef );return nil ,_fbef ;};return _ebca ,nil ;};var _adcf =_e .MustCompile ("\u0028\u005c\u0064\u002b)\\\u0073\u002b\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u006f\u0062\u006a");

// DecodeBytes decodes a slice of ASCII encoded bytes and returns the result.
func (_addc *ASCIIHexEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_fdff :=_acf .NewReader (encoded );var _afed []byte ;for {_bdeb ,_fgdf :=_fdff .ReadByte ();if _fgdf !=nil {return nil ,_fgdf ;};if _bdeb =='>'{break ;};if IsWhiteSpace (_bdeb ){continue ;};if (_bdeb >='a'&&_bdeb <='f')||(_bdeb >='A'&&_bdeb <='F')||(_bdeb >='0'&&_bdeb <='9'){_afed =append (_afed ,_bdeb );}else {_fc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0061\u0073\u0063\u0069\u0069 \u0068\u0065\u0078\u0020\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072 \u0028\u0025\u0063\u0029",_bdeb );return nil ,_ad .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0061\u0073\u0063\u0069\u0069\u0020\u0068e\u0078 \u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u0020\u0028\u0025\u0063\u0029",_bdeb );};};if len (_afed )%2==1{_afed =append (_afed ,'0');};_fc .Log .Trace ("\u0049\u006e\u0062\u006f\u0075\u006e\u0064\u0020\u0025\u0073",_afed );_eaadf :=make ([]byte ,_ed .DecodedLen (len (_afed )));_ ,_cbfd :=_ed .Decode (_eaadf ,_afed );if _cbfd !=nil {return nil ,_cbfd ;};return _eaadf ,nil ;};type objectCache map[int ]PdfObject ;

// NewJPXEncoder returns a new instance of JPXEncoder.
func NewJPXEncoder ()*JPXEncoder {return &JPXEncoder {}};func (_egege *PdfObjectFloat )String ()string {return _ad .Sprintf ("\u0025\u0066",*_egege )};

// PdfVersion returns version of the PDF file.
func (_gecce *PdfParser )PdfVersion ()Version {return _gecce ._ggdd };func (_agdbg *PdfParser )inspect ()(map[string ]int ,error ){_fc .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0053P\u0045\u0043\u0054\u0020\u002d\u002d\u002d\u002d\u002d\u002d-\u002d\u002d\u002d");_fc .Log .Trace ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");_ccgdf :=map[string ]int {};_fcfd :=0;_dbcc :=0;var _cgfcg []int ;for _dddbeg :=range _agdbg ._cefa .ObjectMap {_cgfcg =append (_cgfcg ,_dddbeg );};_bf .Ints (_cgfcg );_faed :=0;for _ ,_afcce :=range _cgfcg {_gbeg :=_agdbg ._cefa .ObjectMap [_afcce ];if _gbeg .ObjectNumber ==0{continue ;};_fcfd ++;_fc .Log .Trace ("\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d");_fc .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0075\u0070\u0020\u006f\u0062\u006a\u0065c\u0074 \u006e\u0075\u006d\u0062\u0065\u0072\u003a \u0025\u0064",_gbeg .ObjectNumber );_dgcf ,_caag :=_agdbg .LookupByNumber (_gbeg .ObjectNumber );if _caag !=nil {_fc .Log .Trace ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u006c\u006f\u006f\u006b\u0075p\u0020\u006f\u0062\u006a\u0020\u0025\u0064 \u0028\u0025\u0073\u0029",_gbeg .ObjectNumber ,_caag );_dbcc ++;continue ;};_fc .Log .Trace ("\u006fb\u006a\u003a\u0020\u0025\u0073",_dgcf );_fefg ,_fbbcg :=_dgcf .(*PdfIndirectObject );if _fbbcg {_fc .Log .Trace ("\u0049N\u0044 \u004f\u004f\u0042\u004a\u0020\u0025\u0064\u003a\u0020\u0025\u0073",_gbeg .ObjectNumber ,_fefg );_cbea ,_gbd :=_fefg .PdfObject .(*PdfObjectDictionary );if _gbd {if _gafa ,_ccgcg :=_cbea .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_ccgcg {_fdcd :=string (*_gafa );_fc .Log .Trace ("\u002d\u002d\u002d\u003e\u0020\u004f\u0062\u006a\u0020\u0074\u0079\u0070e\u003a\u0020\u0025\u0073",_fdcd );_ ,_fcaag :=_ccgdf [_fdcd ];if _fcaag {_ccgdf [_fdcd ]++;}else {_ccgdf [_fdcd ]=1;};}else if _gadd ,_fgad :=_cbea .Get ("\u0053u\u0062\u0074\u0079\u0070\u0065").(*PdfObjectName );_fgad {_aeea :=string (*_gadd );_fc .Log .Trace ("-\u002d-\u003e\u0020\u004f\u0062\u006a\u0020\u0073\u0075b\u0074\u0079\u0070\u0065: \u0025\u0073",_aeea );_ ,_adad :=_ccgdf [_aeea ];if _adad {_ccgdf [_aeea ]++;}else {_ccgdf [_aeea ]=1;};};if _affba ,_dcgcf :=_cbea .Get ("\u0053").(*PdfObjectName );_dcgcf &&*_affba =="\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"{_ ,_feeg :=_ccgdf ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"];if _feeg {_ccgdf ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]++;}else {_ccgdf ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]=1;};};};}else if _fgffc ,_agbd :=_dgcf .(*PdfObjectStream );_agbd {if _dade ,_gdee :=_fgffc .PdfObjectDictionary .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_gdee {_fc .Log .Trace ("\u002d\u002d\u003e\u0020\u0053\u0074\u0072\u0065\u0061\u006d\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073",*_dade );_febgc :=string (*_dade );if _ ,_gcce :=_ccgdf [_febgc ];_gcce {_ccgdf [_febgc ]++;}else {_ccgdf [_febgc ]=1;};};}else {_dfbbc ,_bcae :=_dgcf .(*PdfObjectDictionary );if _bcae {_gfdba ,_gfdaa :=_dfbbc .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if _gfdaa {_fdca :=string (*_gfdba );_fc .Log .Trace ("\u002d-\u002d \u006f\u0062\u006a\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073",_fdca );_ccgdf [_fdca ]++;};};_fc .Log .Trace ("\u0044\u0049\u0052\u0045\u0043\u0054\u0020\u004f\u0042\u004a\u0020\u0025d\u003a\u0020\u0025\u0073",_gbeg .ObjectNumber ,_dgcf );};_faed ++;};_fc .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0045\u004fF\u0020\u0049\u004e\u0053\u0050\u0045\u0043T\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d");_fc .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");_fc .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074 \u0063\u006f\u0075\u006e\u0074\u003a\u0020\u0025\u0064",_fcfd );_fc .Log .Trace ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u006f\u006b\u0075p\u003a\u0020\u0025\u0064",_dbcc );for _fgbd ,_aaafa :=range _ccgdf {_fc .Log .Trace ("\u0025\u0073\u003a\u0020\u0025\u0064",_fgbd ,_aaafa );};_fc .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");if len (_agdbg ._cefa .ObjectMap )< 1{_fc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0068\u0069\u0073 \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074 \u0069s\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0028\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0021\u0029");return nil ,_ad .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0064\u006fc\u0075\u006d\u0065\u006e\u0074\u0020\u0028\u0078r\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006d\u0069\u0073s\u0069\u006e\u0067\u0029");};_badg ,_cdbcd :=_ccgdf ["\u0046\u006f\u006e\u0074"];if !_cdbcd ||_badg < 2{_fc .Log .Trace ("\u0054\u0068\u0069s \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020i\u0073 \u0070r\u006fb\u0061\u0062\u006c\u0079\u0020\u0073\u0063\u0061\u006e\u006e\u0065\u0064\u0021");}else {_fc .Log .Trace ("\u0054\u0068\u0069\u0073\u0020\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020\u0069\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0066o\u0072\u0020\u0065\u0078\u0074r\u0061\u0063t\u0069\u006f\u006e\u0021");};return _ccgdf ,nil ;};

// EncodeBytes JPX encodes the passed in slice of bytes.
func (_cfff *JPXEncoder )EncodeBytes (data []byte )([]byte ,error ){_fc .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_cfff .GetFilterName ());return data ,ErrNoJPXDecode ;};

// UpdateParams updates the parameter values of the encoder.
func (_agab *ASCII85Encoder )UpdateParams (params *PdfObjectDictionary ){};

// DecodeStream decodes the stream containing CCITTFax encoded image data.
func (_bbgf *CCITTFaxEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _bbgf .DecodeBytes (streamObj .Stream );};

// PdfObjectNull represents the primitive PDF null object.
type PdfObjectNull struct{};func _bgfg (_agg *PdfObjectStream ,_gbbe *MultiEncoder )(*DCTEncoder ,error ){_cadb :=NewDCTEncoder ();_bced :=_agg .PdfObjectDictionary ;if _bced ==nil {return _cadb ,nil ;};_gadc :=_agg .Stream ;if _gbbe !=nil {_cdec ,_dfc :=_gbbe .DecodeBytes (_gadc );if _dfc !=nil {return nil ,_dfc ;};_gadc =_cdec ;};_fabd :=_acf .NewReader (_gadc );_dfdd ,_deeg :=_f .DecodeConfig (_fabd );if _deeg !=nil {_fc .Log .Debug ("\u0045\u0072\u0072or\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0065\u003a\u0020\u0025\u0073",_deeg );return nil ,_deeg ;};switch _dfdd .ColorModel {case _bc .RGBAModel :_cadb .BitsPerComponent =8;_cadb .ColorComponents =3;case _bc .RGBA64Model :_cadb .BitsPerComponent =16;_cadb .ColorComponents =3;case _bc .GrayModel :_cadb .BitsPerComponent =8;_cadb .ColorComponents =1;case _bc .Gray16Model :_cadb .BitsPerComponent =16;_cadb .ColorComponents =1;case _bc .CMYKModel :_cadb .BitsPerComponent =8;_cadb .ColorComponents =4;case _bc .YCbCrModel :_cadb .BitsPerComponent =8;_cadb .ColorComponents =3;default:return nil ,_d .New ("\u0075\u006e\u0073up\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u006d\u006f\u0064\u0065\u006c");};_cadb .Width =_dfdd .Width ;_cadb .Height =_dfdd .Height ;_fc .Log .Trace ("\u0044\u0043T\u0020\u0045\u006ec\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076",_cadb );_cadb .Quality =DefaultJPEGQuality ;return _cadb ,nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_fcf *JPXEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};

// GetAccessPermissions returns the PDF access permissions as an AccessPermissions object.
func (_fcdd *PdfCrypt )GetAccessPermissions ()_db .Permissions {return _fcdd ._ec .P };const (JB2Generic JBIG2CompressionType =iota ;JB2SymbolCorrelation ;JB2SymbolRankHaus ;);

// DecodeStream decodes RunLengthEncoded stream object and give back decoded bytes.
func (_cege *RunLengthEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _cege .DecodeBytes (streamObj .Stream );};

// Set sets the PdfObject at index i of the streams. An error is returned if the index is outside bounds.
func (_gffe *PdfObjectStreams )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_gffe ._fbg ){return _d .New ("\u004f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_gffe ._fbg [i ]=obj ;return nil ;};

// ReadAtLeast reads at least n bytes into slice p.
// Returns the number of bytes read (should always be == n), and an error on failure.
func (_dafg *PdfParser )ReadAtLeast (p []byte ,n int )(int ,error ){_aacba :=n ;_ffbd :=0;_gaga :=0;for _aacba > 0{_cdga ,_cfab :=_dafg ._edcc .Read (p [_ffbd :]);if _cfab !=nil {_fc .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061d\u0069\u006e\u0067\u0020\u0028\u0025\u0064\u003b\u0025\u0064\u0029\u0020\u0025\u0073",_cdga ,_gaga ,_cfab .Error ());return _ffbd ,_d .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065a\u0064\u0069\u006e\u0067");};_gaga ++;_ffbd +=_cdga ;_aacba -=_cdga ;};return _ffbd ,nil ;};

// JBIG2EncoderSettings contains the parameters and settings used by the JBIG2Encoder.
// Current version works only on JB2Generic compression.
type JBIG2EncoderSettings struct{

// FileMode defines if the jbig2 encoder should return full jbig2 file instead of
// shortened pdf mode. This adds the file header to the jbig2 definition.
FileMode bool ;

// Compression is the setting that defines the compression type used for encoding the page.
Compression JBIG2CompressionType ;

// DuplicatedLinesRemoval code generic region in a way such that if the lines are duplicated the encoder
// doesn't store it twice.
DuplicatedLinesRemoval bool ;

// DefaultPixelValue is the bit value initial for every pixel in the page.
DefaultPixelValue uint8 ;

// ResolutionX optional setting that defines the 'x' axis input image resolution - used for single page encoding.
ResolutionX int ;

// ResolutionY optional setting that defines the 'y' axis input image resolution - used for single page encoding.
ResolutionY int ;

// Threshold defines the threshold of the image correlation for
// non Generic compression.
// User only for JB2SymbolCorrelation and JB2SymbolRankHaus methods.
// Best results in range [0.7 - 0.98] - the less the better the compression would be
// but the more lossy.
// Default value: 0.95
Threshold float64 ;};

// Clear resets the dictionary to an empty state.
func (_deag *PdfObjectDictionary )Clear (){_deag ._baed =[]PdfObjectName {};_deag ._baca =map[PdfObjectName ]PdfObject {};};func (_gad *PdfParser )lookupByNumber (_efd int ,_fbb bool )(PdfObject ,bool ,error ){_dfg ,_eab :=_gad .ObjCache [_efd ];if _eab {_fc .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0063a\u0063\u0068\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0025\u0064",_efd );return _dfg ,false ,nil ;};_fec ,_eab :=_gad ._cefa .ObjectMap [_efd ];if !_eab {_fc .Log .Trace ("\u0055\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u006c\u006f\u0063\u0061t\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0069\u006e\u0020\u0078\u0072\u0065\u0066\u0073\u0021 \u002d\u0020\u0052\u0065\u0074u\u0072\u006e\u0069\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074");var _eea PdfObjectNull ;return &_eea ,false ,nil ;};_fc .Log .Trace ("L\u006fo\u006b\u0075\u0070\u0020\u006f\u0062\u006a\u0020n\u0075\u006d\u0062\u0065r \u0025\u0064",_efd );if _fec .XType ==XrefTypeTableEntry {_fc .Log .Trace ("\u0078r\u0065f\u006f\u0062\u006a\u0020\u006fb\u006a\u0020n\u0075\u006d\u0020\u0025\u0064",_fec .ObjectNumber );_fc .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u0067e\u006e\u0020\u0025\u0064",_fec .Generation );_fc .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0064",_fec .Offset );_gad ._ffgb .Seek (_fec .Offset ,_ac .SEEK_SET );_gad ._edcc =_ga .NewReader (_gad ._ffgb );_cfb ,_aea :=_gad .ParseIndirectObject ();if _aea !=nil {_fc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006ce\u0064\u0020\u0072\u0065\u0061\u0064\u0069n\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029",_aea );if _fbb {_fc .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0072\u0065\u0070\u0061\u0069r\u0020\u0078\u0072\u0065\u0066\u0073\u0020\u0028\u0074\u006f\u0070\u0020d\u006f\u0077\u006e\u0029");_aa ,_fbab :=_gad .repairRebuildXrefsTopDown ();if _fbab !=nil {_fc .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020r\u0065\u0070\u0061\u0069\u0072\u0020\u0028\u0025\u0073\u0029",_fbab );return nil ,false ,_fbab ;};_gad ._cefa =*_aa ;return _gad .lookupByNumber (_efd ,false );};return nil ,false ,_aea ;};if _fbb {_gc ,_ ,_ :=_da (_cfb );if int (_gc )!=_efd {_fc .Log .Debug ("\u0049n\u0076\u0061\u006c\u0069d\u0020\u0078\u0072\u0065\u0066s\u003a \u0052e\u0062\u0075\u0069\u006c\u0064\u0069\u006eg");_ca :=_gad .rebuildXrefTable ();if _ca !=nil {return nil ,false ,_ca ;};_gad .ObjCache =objectCache {};return _gad .lookupByNumberWrapper (_efd ,false );};};_fc .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006f\u0062\u006a");_gad .ObjCache [_efd ]=_cfb ;return _cfb ,false ,nil ;}else if _fec .XType ==XrefTypeObjectStream {_fc .Log .Trace ("\u0078r\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0021");_fc .Log .Trace ("\u003e\u004c\u006f\u0061\u0064\u0020\u0076\u0069\u0061\u0020\u004f\u0053\u0021");_fc .Log .Trace ("\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d \u0061\u0076\u0061\u0069\u006c\u0061b\u006c\u0065\u0020\u0069\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020%\u0064\u002f\u0025\u0064",_fec .OsObjNumber ,_fec .OsObjIndex );if _fec .OsObjNumber ==_efd {_fc .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0043i\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065f\u0065\u0072\u0065n\u0063e\u0021\u003f\u0021");return nil ,true ,_d .New ("\u0078\u0072\u0065f \u0063\u0069\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");};if _ ,_ggb :=_gad ._cefa .ObjectMap [_fec .OsObjNumber ];_ggb {_bed ,_fdb :=_gad .lookupObjectViaOS (_fec .OsObjNumber ,_efd );if _fdb !=nil {_fc .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0052\u0065\u0074\u0075\u0072\u006e\u0069n\u0067\u0020\u0045\u0052\u0052\u0020\u0028\u0025\u0073\u0029",_fdb );return nil ,true ,_fdb ;};_fc .Log .Trace ("\u003c\u004c\u006f\u0061\u0064\u0065\u0064\u0020\u0076i\u0061\u0020\u004f\u0053");_gad .ObjCache [_efd ]=_bed ;if _gad ._fgae !=nil {_gad ._fgae ._fdg [_bed ]=true ;};return _bed ,true ,nil ;};_fc .Log .Debug ("\u003f\u003f\u0020\u0042\u0065\u006c\u006f\u006eg\u0073\u0020\u0074o \u0061\u0020\u006e\u006f\u006e\u002dc\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u002e.\u002e\u0021");return nil ,true ,_d .New ("\u006f\u0073\u0020\u0062\u0065\u006c\u006fn\u0067\u0073\u0020t\u006f\u0020\u0061\u0020n\u006f\u006e\u0020\u0063\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074");};return nil ,false ,_d .New ("\u0075\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0078\u0072\u0065\u0066 \u0074\u0079\u0070\u0065");};

// GetFilterName returns the name of the encoding filter.
func (_gfdc *RawEncoder )GetFilterName ()string {return StreamEncodingFilterNameRaw };

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set.  Some other parameters are generated elsewhere.
func (_eddae *DCTEncoder )MakeStreamDict ()*PdfObjectDictionary {_ebge :=MakeDict ();_ebge .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_eddae .GetFilterName ()));return _ebge ;};

// GetFilterArray returns the names of the underlying encoding filters in an array that
// can be used as /Filter entry.
func (_feda *MultiEncoder )GetFilterArray ()*PdfObjectArray {_fgga :=make ([]PdfObject ,len (_feda ._deeb ));for _daab ,_cgfg :=range _feda ._deeb {_fgga [_daab ]=MakeName (_cgfg .GetFilterName ());};return MakeArray (_fgga ...);};

// GetFilterName returns the name of the encoding filter.
func (_gfdg *JBIG2Encoder )GetFilterName ()string {return StreamEncodingFilterNameJBIG2 };func (_gade *ASCII85Encoder )base256Tobase85 (_daac uint32 )[5]byte {_gcbe :=[5]byte {0,0,0,0,0};_dacf :=_daac ;for _adc :=0;_adc < 5;_adc ++{_bgcg :=uint32 (1);for _eefg :=0;_eefg < 4-_adc ;_eefg ++{_bgcg *=85;};_beag :=_dacf /_bgcg ;_dacf =_dacf %_bgcg ;_gcbe [_adc ]=byte (_beag );};return _gcbe ;};

// EncryptInfo contains an information generated by the document encrypter.
type EncryptInfo struct{Version ;

// Encrypt is an encryption dictionary that contains all necessary parameters.
// It should be stored in all copies of the document trailer.
Encrypt *PdfObjectDictionary ;

// ID0 and ID1 are IDs used in the trailer. Older algorithms such as RC4 uses them for encryption.
ID0 ,ID1 string ;};type objectStream struct{N int ;_add []byte ;_def map[int ]int64 ;};

// EncodeImage encodes 'img' golang image.Image into jbig2 encoded bytes document using default encoder settings.
func (_gdag *JBIG2Encoder )EncodeImage (img _dg .Image )([]byte ,error ){return _gdag .encodeImage (img )};

// DecodeBytes decodes the CCITTFax encoded image data.
func (_fgab *CCITTFaxEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_acga :=&_af .Encoder {K :_fgab .K ,Columns :_fgab .Columns ,EndOfLine :_fgab .EndOfLine ,EndOfBlock :_fgab .EndOfBlock ,BlackIs1 :_fgab .BlackIs1 ,DamagedRowsBeforeError :_fgab .DamagedRowsBeforeError ,Rows :_fgab .Rows ,EncodedByteAlign :_fgab .EncodedByteAlign };_bgge ,_dcgf :=_acga .Decode (encoded );if _dcgf !=nil {return nil ,_dcgf ;};var _ebfa []byte ;_febd :=0;var _cgbg byte ;var _abca byte ;for _cdfc :=range _bgge {if _cgbg !=0{_ebfa =append (_ebfa ,_abca );_abca =0;_febd ++;_cgbg =0;};for _adgd :=range _bgge [_cdfc ]{_abca |=_bgge [_cdfc ][_adgd ]<<(7-_cgbg );_cgbg ++;if _cgbg ==8{_ebfa =append (_ebfa ,_abca );_abca =0;_febd ++;_cgbg =0;};};};if _cgbg > 0{_ebfa =append (_ebfa ,_abca );};return _ebfa ,nil ;};

// IsPrintable checks if a character is printable.
// Regular characters that are outside the range EXCLAMATION MARK(21h)
// (!) to TILDE (7Eh) (~) should be written using the hexadecimal notation.
func IsPrintable (c byte )bool {return 0x21<=c &&c <=0x7E};

// PdfObjectFloat represents the primitive PDF floating point numerical object.
type PdfObjectFloat float64 ;

// CheckAccessRights checks access rights and permissions for a specified password. If either user/owner password is
// specified, full rights are granted, otherwise the access rights are specified by the Permissions flag.
//
// The bool flag indicates that the user can access and view the file.
// The AccessPermissions shows what access the user has for editing etc.
// An error is returned if there was a problem performing the authentication.
func (_egde *PdfParser )CheckAccessRights (password []byte )(bool ,_db .Permissions ,error ){if _egde ._fgae ==nil {return true ,_db .PermOwner ,nil ;};return _egde ._fgae .checkAccessRights (password );};func (_ega *PdfCrypt )makeKey (_aae string ,_gdc ,_cagg uint32 ,_bfd []byte )([]byte ,error ){_bbcf ,_bdba :=_ega ._fgb [_aae ];if !_bdba {return nil ,_ad .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_aae );};return _bbcf .MakeKey (_gdc ,_cagg ,_bfd );};func _gaag (_cede string )(PdfObjectReference ,error ){_gadg :=PdfObjectReference {};_aaae :=_begg .FindStringSubmatch (string (_cede ));if len (_aaae )< 3{_fc .Log .Debug ("\u0045\u0072\u0072or\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");return _gadg ,_d .New ("\u0075n\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061r\u0073e\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");};_ffdd ,_ :=_a .Atoi (_aaae [1]);_abdd ,_ :=_a .Atoi (_aaae [2]);_gadg .ObjectNumber =int64 (_ffdd );_gadg .GenerationNumber =int64 (_abdd );return _gadg ,nil ;};type xrefType int ;func (_eddbd *PdfParser )parseNumber ()(PdfObject ,error ){return ParseNumber (_eddbd ._edcc )};

// IsAuthenticated returns true if the PDF has already been authenticated for accessing.
func (_egda *PdfParser )IsAuthenticated ()bool {return _egda ._fgae ._bcg };

// PdfObjectStream represents the primitive PDF Object stream.
type PdfObjectStream struct{PdfObjectReference ;*PdfObjectDictionary ;Stream []byte ;};func (_bgbg *PdfCrypt )decryptBytes (_dee []byte ,_cba string ,_bfge []byte )([]byte ,error ){_fc .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");_ecab ,_dac :=_bgbg ._fgb [_cba ];if !_dac {return nil ,_ad .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_cba );};return _ecab .DecryptBytes (_dee ,_bfge );};func (_bedae *PdfParser )readComment ()(string ,error ){var _ggcd _acf .Buffer ;_ ,_ebfb :=_bedae .skipSpaces ();if _ebfb !=nil {return _ggcd .String (),_ebfb ;};_fgfab :=true ;for {_bceb ,_cbag :=_bedae ._edcc .Peek (1);if _cbag !=nil {_fc .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_cbag .Error ());return _ggcd .String (),_cbag ;};if _fgfab &&_bceb [0]!='%'{return _ggcd .String (),_d .New ("c\u006f\u006d\u006d\u0065\u006e\u0074 \u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0073\u0074a\u0072\u0074\u0020w\u0069t\u0068\u0020\u0025");};_fgfab =false ;if (_bceb [0]!='\r')&&(_bceb [0]!='\n'){_gafg ,_ :=_bedae ._edcc .ReadByte ();_ggcd .WriteByte (_gafg );}else {break ;};};return _ggcd .String (),nil ;};

// GetFileOffset returns the current file offset, accounting for buffered position.
func (_dbfd *PdfParser )GetFileOffset ()int64 {_dbfe ,_ :=_dbfd ._ffgb .Seek (0,_de .SeekCurrent );_dbfe -=int64 (_dbfd ._edcc .Buffered ());return _dbfe ;};

// PdfObjectString represents the primitive PDF string object.
type PdfObjectString struct{_ddeab string ;_ddcc bool ;};

// GetStringBytes is like GetStringVal except that it returns the string as a []byte.
// It is for convenience.
func GetStringBytes (obj PdfObject )(_dcgc []byte ,_gabe bool ){_caga ,_gabe :=TraceToDirectObject (obj ).(*PdfObjectString );if _gabe {return _caga .Bytes (),true ;};return ;};const (StreamEncodingFilterNameFlate ="F\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameLZW ="\u004cZ\u0057\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameDCT ="\u0044C\u0054\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameRunLength ="\u0052u\u006eL\u0065\u006e\u0067\u0074\u0068\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameASCIIHex ="\u0041\u0053\u0043\u0049\u0049\u0048\u0065\u0078\u0044e\u0063\u006f\u0064\u0065";StreamEncodingFilterNameASCII85 ="\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameCCITTFax ="\u0043\u0043\u0049\u0054\u0054\u0046\u0061\u0078\u0044e\u0063\u006f\u0064\u0065";StreamEncodingFilterNameJBIG2 ="J\u0042\u0049\u0047\u0032\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameJPX ="\u004aP\u0058\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameRaw ="\u0052\u0061\u0077";);

// DecodeBytes decodes a slice of DCT encoded bytes and returns the result.
func (_feae *DCTEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_ebb :=_acf .NewReader (encoded );_bbd ,_ded :=_f .Decode (_ebb );if _ded !=nil {_fc .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006eg\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_ded );return nil ,_ded ;};_caeed :=_bbd .Bounds ();var _baec =make ([]byte ,_caeed .Dx ()*_caeed .Dy ()*_feae .ColorComponents *_feae .BitsPerComponent /8);_daca :=0;for _adec :=_caeed .Min .Y ;_adec < _caeed .Max .Y ;_adec ++{for _bbed :=_caeed .Min .X ;_bbed < _caeed .Max .X ;_bbed ++{_dgcg :=_bbd .At (_bbed ,_adec );if _feae .ColorComponents ==1{if _feae .BitsPerComponent ==16{_gdcg ,_bda :=_dgcg .(_bc .Gray16 );if !_bda {return nil ,_d .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_baec [_daca ]=byte ((_gdcg .Y >>8)&0xff);_daca ++;_baec [_daca ]=byte (_gdcg .Y &0xff);_daca ++;}else {_fdbc ,_addb :=_dgcg .(_bc .Gray );if !_addb {return nil ,_d .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_baec [_daca ]=byte (_fdbc .Y &0xff);_daca ++;};}else if _feae .ColorComponents ==3{if _feae .BitsPerComponent ==16{_fcc ,_aede :=_dgcg .(_bc .RGBA64 );if !_aede {return nil ,_d .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_baec [_daca ]=byte ((_fcc .R >>8)&0xff);_daca ++;_baec [_daca ]=byte (_fcc .R &0xff);_daca ++;_baec [_daca ]=byte ((_fcc .G >>8)&0xff);_daca ++;_baec [_daca ]=byte (_fcc .G &0xff);_daca ++;_baec [_daca ]=byte ((_fcc .B >>8)&0xff);_daca ++;_baec [_daca ]=byte (_fcc .B &0xff);_daca ++;}else {_agdb ,_dada :=_dgcg .(_bc .RGBA );if _dada {_baec [_daca ]=_agdb .R &0xff;_daca ++;_baec [_daca ]=_agdb .G &0xff;_daca ++;_baec [_daca ]=_agdb .B &0xff;_daca ++;}else {_gbbd ,_dec :=_dgcg .(_bc .YCbCr );if !_dec {return nil ,_d .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_egbb ,_cgac ,_abdc ,_ :=_gbbd .RGBA ();_baec [_daca ]=byte (_egbb >>8);_daca ++;_baec [_daca ]=byte (_cgac >>8);_daca ++;_baec [_daca ]=byte (_abdc >>8);_daca ++;};};}else if _feae .ColorComponents ==4{_cdad ,_ecag :=_dgcg .(_bc .CMYK );if !_ecag {return nil ,_d .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_baec [_daca ]=255-_cdad .C &0xff;_daca ++;_baec [_daca ]=255-_cdad .M &0xff;_daca ++;_baec [_daca ]=255-_cdad .Y &0xff;_daca ++;_baec [_daca ]=255-_cdad .K &0xff;_daca ++;};};};return _baec ,nil ;};func _acea (_fggfe int )int {_dffd :=_fggfe >>(_dbge -1);return (_fggfe ^_dffd )-_dffd };

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_aaac *DCTEncoder )MakeDecodeParams ()PdfObject {return nil };

// PdfCrypt provides PDF encryption/decryption support.
// The PDF standard supports encryption of strings and streams (Section 7.6).
type PdfCrypt struct{_dbb encryptDict ;_ec _db .StdEncryptDict ;_eeef string ;_bgb []byte ;_fdg map[PdfObject ]bool ;_ba map[PdfObject ]bool ;_bcg bool ;_fgb cryptFilters ;_efe string ;_ebcg string ;_fgbc *PdfParser ;_dggc map[int ]struct{};};func (_cbae *PdfParser )parseObject ()(PdfObject ,error ){_fc .Log .Trace ("\u0052e\u0061d\u0020\u0064\u0069\u0072\u0065c\u0074\u0020o\u0062\u006a\u0065\u0063\u0074");_cbae .skipSpaces ();for {_gggbc ,_dbfa :=_cbae ._edcc .Peek (2);if _dbfa !=nil {if _dbfa !=_de .EOF ||len (_gggbc )==0{return nil ,_dbfa ;};if len (_gggbc )==1{_gggbc =append (_gggbc ,' ');};};_fc .Log .Trace ("\u0050e\u0065k\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u003a\u0020\u0025\u0073",string (_gggbc ));if _gggbc [0]=='/'{_gdbae ,_eabed :=_cbae .parseName ();_fc .Log .Trace ("\u002d\u003e\u004ea\u006d\u0065\u003a\u0020\u0027\u0025\u0073\u0027",_gdbae );return &_gdbae ,_eabed ;}else if _gggbc [0]=='('{_fc .Log .Trace ("\u002d>\u0053\u0074\u0072\u0069\u006e\u0067!");_eddab ,_bebb :=_cbae .parseString ();return _eddab ,_bebb ;}else if _gggbc [0]=='['{_fc .Log .Trace ("\u002d\u003e\u0041\u0072\u0072\u0061\u0079\u0021");_cdab ,_cbfe :=_cbae .parseArray ();return _cdab ,_cbfe ;}else if (_gggbc [0]=='<')&&(_gggbc [1]=='<'){_fc .Log .Trace ("\u002d>\u0044\u0069\u0063\u0074\u0021");_bgbga ,_agfd :=_cbae .ParseDict ();return _bgbga ,_agfd ;}else if _gggbc [0]=='<'{_fc .Log .Trace ("\u002d\u003e\u0048\u0065\u0078\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0021");_faca ,_eadd :=_cbae .parseHexString ();return _faca ,_eadd ;}else if _gggbc [0]=='%'{_cbae .readComment ();_cbae .skipSpaces ();}else {_fc .Log .Trace ("\u002d\u003eN\u0075\u006d\u0062e\u0072\u0020\u006f\u0072\u0020\u0072\u0065\u0066\u003f");_gggbc ,_ =_cbae ._edcc .Peek (15);_fbbef :=string (_gggbc );_fc .Log .Trace ("\u0050\u0065\u0065k\u0020\u0073\u0074\u0072\u003a\u0020\u0025\u0073",_fbbef );if (len (_fbbef )> 3)&&(_fbbef [:4]=="\u006e\u0075\u006c\u006c"){_bagdf ,_dedg :=_cbae .parseNull ();return &_bagdf ,_dedg ;}else if (len (_fbbef )> 4)&&(_fbbef [:5]=="\u0066\u0061\u006cs\u0065"){_aagdg ,_gcbgd :=_cbae .parseBool ();return &_aagdg ,_gcbgd ;}else if (len (_fbbef )> 3)&&(_fbbef [:4]=="\u0074\u0072\u0075\u0065"){_geca ,_cfdde :=_cbae .parseBool ();return &_geca ,_cfdde ;};_bfgf :=_begg .FindStringSubmatch (string (_fbbef ));if len (_bfgf )> 1{_gggbc ,_ =_cbae ._edcc .ReadBytes ('R');_fc .Log .Trace ("\u002d\u003e\u0020\u0021\u0052\u0065\u0066\u003a\u0020\u0027\u0025\u0073\u0027",string (_gggbc [:]));_dcbfb ,_abbc :=_gaag (string (_gggbc ));_dcbfb ._ddaa =_cbae ;return &_dcbfb ,_abbc ;};_dfcg :=_fcba .FindStringSubmatch (string (_fbbef ));if len (_dfcg )> 1{_fc .Log .Trace ("\u002d\u003e\u0020\u004e\u0075\u006d\u0062\u0065\u0072\u0021");_caef ,_eccf :=_cbae .parseNumber ();return _caef ,_eccf ;};_dfcg =_adbe .FindStringSubmatch (string (_fbbef ));if len (_dfcg )> 1{_fc .Log .Trace ("\u002d\u003e\u0020\u0045xp\u006f\u006e\u0065\u006e\u0074\u0069\u0061\u006c\u0020\u004e\u0075\u006d\u0062\u0065r\u0021");_fc .Log .Trace ("\u0025\u0020\u0073",_dfcg );_ccgd ,_efdc :=_cbae .parseNumber ();return _ccgd ,_efdc ;};_fc .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020U\u006e\u006b\u006e\u006f\u0077n\u0020(\u0070e\u0065\u006b\u0020\u0022\u0025\u0073\u0022)",_fbbef );return nil ,_d .New ("\u006f\u0062\u006a\u0065\u0063t\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020\u0075\u006e\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e");};};};

// Elements returns a slice of the PdfObject elements in the array.
// Preferred over accessing the array directly as type may be changed in future major versions (v3).
func (_gbced *PdfObjectStreams )Elements ()[]PdfObject {if _gbced ==nil {return nil ;};return _gbced ._fbg ;};

// GetNumberAsFloat returns the contents of `obj` as a float if it is an integer or float, or an
// error if it isn't.
func GetNumberAsFloat (obj PdfObject )(float64 ,error ){switch _daaf :=obj .(type ){case *PdfObjectFloat :return float64 (*_daaf ),nil ;case *PdfObjectInteger :return float64 (*_daaf ),nil ;};return 0,ErrNotANumber ;};func (_dagb *FlateEncoder )cleanImageData (_dagbc []byte )([]byte ,error ){if _dagb ._aba ==nil {return _dagbc ,nil ;};if _dagb ._aba .BitsPerComponent >=8{return _dagbc ,nil ;};_dabg :=_dagb ._aba .BitsPerComponent *_dagb ._aba .Width *_dagb ._aba .ColorComponents *_dagb ._aba .Height /8;_dagbc =_dagbc [:_dabg ];var _bfba error ;_dagbc ,_bfba =_df .AddDataPadding (_dagb ._aba .Width ,_dagb ._aba .Height ,_dagb ._aba .BitsPerComponent ,_dagb ._aba .ColorComponents ,_dagbc );if _bfba !=nil {return nil ,_bfba ;};return _dagbc ,nil ;};

// Decrypt attempts to decrypt the PDF file with a specified password.  Also tries to
// decrypt with an empty password.  Returns true if successful, false otherwise.
// An error is returned when there is a problem with decrypting.
func (_aaga *PdfParser )Decrypt (password []byte )(bool ,error ){if _aaga ._fgae ==nil {return false ,_d .New ("\u0063\u0068\u0065\u0063k \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u0069\u0072s\u0074");};_fdge ,_fecb :=_aaga ._fgae .authenticate (password );if _fecb !=nil {return false ,_fecb ;};if !_fdge {_fdge ,_fecb =_aaga ._fgae .authenticate ([]byte (""));};return _fdge ,_fecb ;};

// Remove removes an element specified by key.
func (_gbaac *PdfObjectDictionary )Remove (key PdfObjectName ){_ebdba :=-1;for _ecfe ,_gdcge :=range _gbaac ._baed {if _gdcge ==key {_ebdba =_ecfe ;break ;};};if _ebdba >=0{_gbaac ._baed =append (_gbaac ._baed [:_ebdba ],_gbaac ._baed [_ebdba +1:]...);delete (_gbaac ._baca ,key );};};

// UpdateParams updates the parameter values of the encoder.
func (_gbgd *DCTEncoder )UpdateParams (params *PdfObjectDictionary ){_eabg ,_eeege :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _eeege ==nil {_gbgd .ColorComponents =int (_eabg );};_egff ,_eeege :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _eeege ==nil {_gbgd .BitsPerComponent =int (_egff );};_bfde ,_eeege :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _eeege ==nil {_gbgd .Width =int (_bfde );};_aeaab ,_eeege :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _eeege ==nil {_gbgd .Height =int (_aeaab );};_eddg ,_eeege :=GetNumberAsInt64 (params .Get ("\u0051u\u0061\u006c\u0069\u0074\u0079"));if _eeege ==nil {_gbgd .Quality =int (_eddg );};};func (_dcef *PdfParser )loadXrefs ()(*PdfObjectDictionary ,error ){_dcef ._cefa .ObjectMap =make (map[int ]XrefObject );_dcef ._ead =make (objectStreams );_abfgd ,_fcddd :=_dcef ._ffgb .Seek (0,_de .SeekEnd );if _fcddd !=nil {return nil ,_fcddd ;};_fc .Log .Trace ("\u0066s\u0069\u007a\u0065\u003a\u0020\u0025d",_abfgd );_dcef ._afgg =_abfgd ;_fcddd =_dcef .seekToEOFMarker (_abfgd );if _fcddd !=nil {_fc .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0073\u0065\u0065\u006b\u0020\u0074\u006f\u0020\u0065\u006f\u0066\u0020\u006d\u0061\u0072\u006b\u0065\u0072: \u0025\u0076",_fcddd );return nil ,_fcddd ;};_bfdf ,_fcddd :=_dcef ._ffgb .Seek (0,_de .SeekCurrent );if _fcddd !=nil {return nil ,_fcddd ;};var _cbed int64 =64;_eaab :=_bfdf -_cbed ;if _eaab < 0{_eaab =0;};_ ,_fcddd =_dcef ._ffgb .Seek (_eaab ,_de .SeekStart );if _fcddd !=nil {return nil ,_fcddd ;};_dbaa :=make ([]byte ,_cbed );_ ,_fcddd =_dcef ._ffgb .Read (_dbaa );if _fcddd !=nil {_fc .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u003a\u0020\u0025\u0076",_fcddd );return nil ,_fcddd ;};_ceeg :=_bbca .FindStringSubmatch (string (_dbaa ));if len (_ceeg )< 2{_fc .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020n\u006f\u0074\u0020f\u006fu\u006e\u0064\u0021");return nil ,_d .New ("\u0073\u0074\u0061\u0072tx\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};if len (_ceeg )> 2{_fc .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u004du\u006c\u0074\u0069\u0070\u006c\u0065\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029\u0021",_dbaa );return nil ,_d .New ("m\u0075\u006c\u0074\u0069\u0070\u006ce\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065f\u0020\u0065\u006et\u0072i\u0065\u0073\u003f");};_acbfb ,_ :=_a .ParseInt (_ceeg [1],10,64);_fc .Log .Trace ("\u0073t\u0061r\u0074\u0078\u0072\u0065\u0066\u0020\u0061\u0074\u0020\u0025\u0064",_acbfb );if _acbfb > _abfgd {_fc .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u006f\u0066f\u0073e\u0074 \u006fu\u0074\u0073\u0069\u0064\u0065\u0020\u006f\u0066\u0020\u0066\u0069\u006c\u0065");_fc .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0072e\u0070\u0061\u0069\u0072");_acbfb ,_fcddd =_dcef .repairLocateXref ();if _fcddd !=nil {_fc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0052\u0065\u0070\u0061\u0069\u0072\u0020\u0061\u0074\u0074\u0065\u006d\u0070t\u0020\u0066\u0061\u0069\u006c\u0065\u0064 \u0028\u0025\u0073\u0029");return nil ,_fcddd ;};};_dcef ._ffgb .Seek (int64 (_acbfb ),_de .SeekStart );_dcef ._edcc =_ga .NewReader (_dcef ._ffgb );_geafd ,_fcddd :=_dcef .parseXref ();if _fcddd !=nil {return nil ,_fcddd ;};_bedc :=_geafd .Get ("\u0058R\u0065\u0066\u0053\u0074\u006d");if _bedc !=nil {_cddb ,_dcbb :=_bedc .(*PdfObjectInteger );if !_dcbb {return nil ,_d .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0021=\u0020\u0069\u006e\u0074");};_ ,_fcddd =_dcef .parseXrefStream (_cddb );if _fcddd !=nil {return nil ,_fcddd ;};};var _effg []int64 ;_cacgb :=func (_ffgbf int64 ,_cfgag []int64 )bool {for _ ,_eeda :=range _cfgag {if _eeda ==_ffgbf {return true ;};};return false ;};_bedc =_geafd .Get ("\u0050\u0072\u0065\u0076");for _bedc !=nil {_aded ,_cab :=_bedc .(*PdfObjectInteger );if !_cab {_fc .Log .Debug ("\u0049\u006ev\u0061\u006c\u0069\u0064\u0020P\u0072\u0065\u0076\u0020\u0072e\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u003a\u0020\u004e\u006f\u0074\u0020\u0061\u0020\u002a\u0050\u0064\u0066\u004f\u0062\u006a\u0065\u0063\u0074\u0049\u006e\u0074\u0065\u0067\u0065\u0072\u0020\u0028\u0025\u0054\u0029",_bedc );return _geafd ,nil ;};_dabc :=*_aded ;_fc .Log .Trace ("\u0041\u006eot\u0068\u0065\u0072 \u0050\u0072\u0065\u0076 xr\u0065f \u0074\u0061\u0062\u006c\u0065\u0020\u006fbj\u0065\u0063\u0074\u0020\u0061\u0074\u0020%\u0064",_dabc );_dcef ._ffgb .Seek (int64 (_dabc ),_ac .SEEK_SET );_dcef ._edcc =_ga .NewReader (_dcef ._ffgb );_beed ,_fcga :=_dcef .parseXref ();if _fcga !=nil {_fc .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0045\u0072\u0072\u006f\u0072\u0020-\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u0061\u0064\u0069n\u0067\u0020\u0061\u006e\u006f\u0074\u0068\u0065\u0072\u0020\u0028\u0050re\u0076\u0029\u0020\u0074\u0072\u0061\u0069\u006c\u0065\u0072");_fc .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0063\u006f\u006e\u0074\u0069n\u0075\u0065\u0020\u0062\u0079\u0020\u0069\u0067\u006e\u006f\u0072\u0069n\u0067\u0020\u0069\u0074");break ;};_bedc =_beed .Get ("\u0050\u0072\u0065\u0076");if _bedc !=nil {_addg :=*(_bedc .(*PdfObjectInteger ));if _cacgb (int64 (_addg ),_effg ){_fc .Log .Debug ("\u0050\u0072ev\u0065\u006e\u0074i\u006e\u0067\u0020\u0063irc\u0075la\u0072\u0020\u0078\u0072\u0065\u0066\u0020re\u0066\u0065\u0072\u0065\u006e\u0063\u0069n\u0067");break ;};_effg =append (_effg ,int64 (_addg ));};};return _geafd ,nil ;};

// Len returns the number of elements in the array.
func (_decd *PdfObjectArray )Len ()int {if _decd ==nil {return 0;};return len (_decd ._fbbf );};

// DecodeBytes decodes byte array with ASCII85. 5 ASCII characters -> 4 raw binary bytes
func (_gbef *ASCII85Encoder )DecodeBytes (encoded []byte )([]byte ,error ){var _fgbe []byte ;_fc .Log .Trace ("\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0020\u0044e\u0063\u006f\u0064\u0065");_dcdg :=0;_dbea :=false ;for _dcdg < len (encoded )&&!_dbea {_eacg :=[5]byte {0,0,0,0,0};_bbab :=0;_dcda :=0;_dfb :=4;for _dcda < 5+_bbab {if _dcdg +_dcda ==len (encoded ){break ;};_bff :=encoded [_dcdg +_dcda ];if IsWhiteSpace (_bff ){_bbab ++;_dcda ++;continue ;}else if _bff =='~'&&_dcdg +_dcda +1< len (encoded )&&encoded [_dcdg +_dcda +1]=='>'{_dfb =(_dcda -_bbab )-1;if _dfb < 0{_dfb =0;};_dbea =true ;break ;}else if _bff >='!'&&_bff <='u'{_bff -='!';}else if _bff =='z'&&_dcda -_bbab ==0{_dfb =4;_dcda ++;break ;}else {_fc .Log .Error ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u002c\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020co\u0064\u0065");return nil ,_d .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0063\u006f\u0064\u0065\u0020e\u006e\u0063\u006f\u0075\u006e\u0074\u0065\u0072\u0065\u0064");};_eacg [_dcda -_bbab ]=_bff ;_dcda ++;};_dcdg +=_dcda ;for _cgc :=_dfb +1;_cgc < 5;_cgc ++{_eacg [_cgc ]=84;};_aeeb :=uint32 (_eacg [0])*85*85*85*85+uint32 (_eacg [1])*85*85*85+uint32 (_eacg [2])*85*85+uint32 (_eacg [3])*85+uint32 (_eacg [4]);_deegf :=[]byte {byte ((_aeeb >>24)&0xff),byte ((_aeeb >>16)&0xff),byte ((_aeeb >>8)&0xff),byte (_aeeb &0xff)};_fgbe =append (_fgbe ,_deegf [:_dfb ]...);};_fc .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0065\u006e\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",encoded );_fc .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0064\u0065\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",_fgbe );return _fgbe ,nil ;};

// PdfObjectName represents the primitive PDF name object.
type PdfObjectName string ;func (_cfec *PdfParser )traceStreamLength (_fbfa PdfObject )(PdfObject ,error ){_fagc ,_efdf :=_fbfa .(*PdfObjectReference );if _efdf {_afcb ,_fabaf :=_cfec ._eggc [_fagc .ObjectNumber ];if _fabaf &&_afcb {_fc .Log .Debug ("\u0053t\u0072\u0065a\u006d\u0020\u004c\u0065n\u0067\u0074\u0068 \u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065 u\u006e\u0072\u0065s\u006f\u006cv\u0065\u0064\u0020\u0028\u0069\u006cl\u0065\u0067a\u006c\u0029");return nil ,_d .New ("\u0069\u006c\u006c\u0065ga\u006c\u0020\u0072\u0065\u0063\u0075\u0072\u0073\u0069\u0076\u0065\u0020\u006c\u006fo\u0070");};_cfec ._eggc [_fagc .ObjectNumber ]=true ;};_cedd ,_ffddb :=_cfec .Resolve (_fbfa );if _ffddb !=nil {return nil ,_ffddb ;};_fc .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_cedd );if _efdf {_cfec ._eggc [_fagc .ObjectNumber ]=false ;};return _cedd ,nil ;};const (DefaultJPEGQuality =75;);func _dgaa (_bbecb ,_fggd ,_cdb uint8 )uint8 {_adcb :=int (_cdb );_bdcg :=int (_fggd )-_adcb ;_baac :=int (_bbecb )-_adcb ;_adcb =_acea (_bdcg +_baac );_bdcg =_acea (_bdcg );_baac =_acea (_baac );if _bdcg <=_baac &&_bdcg <=_adcb {return _bbecb ;}else if _baac <=_adcb {return _fggd ;};return _cdb ;};

// Keys returns the list of keys in the dictionary.
// If `d` is nil returns a nil slice.
func (_ebdf *PdfObjectDictionary )Keys ()[]PdfObjectName {if _ebdf ==nil {return nil ;};return _ebdf ._baed ;};

// GetXrefOffset returns the offset of the xref table.
func (_egbd *PdfParser )GetXrefOffset ()int64 {return _egbd ._fde };var _adbe =_e .MustCompile ("\u005e\u005b\\\u002b\u002d\u002e\u005d*\u0028\u005b0\u002d\u0039\u002e\u005d\u002b\u0029\u005b\u0065E\u005d\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");

// GetNumberAsInt64 returns the contents of `obj` as an int64 if it is an integer or float, or an
// error if it isn't. This is for cases where expecting an integer, but some implementations
// actually store the number in a floating point format.
func GetNumberAsInt64 (obj PdfObject )(int64 ,error ){switch _cdae :=obj .(type ){case *PdfObjectFloat :_fc .Log .Debug ("\u004e\u0075m\u0062\u0065\u0072\u0020\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0061\u0073\u0020\u0069\u006e\u0074e\u0067\u0065\u0072\u0020\u0077\u0061s\u0020\u0073\u0074\u006f\u0072\u0065\u0064\u0020\u0061\u0073\u0020\u0066\u006c\u006fa\u0074\u0020(\u0074\u0079\u0070\u0065 \u0063\u0061\u0073\u0074\u0069n\u0067\u0020\u0075\u0073\u0065\u0064\u0029");return int64 (*_cdae ),nil ;case *PdfObjectInteger :return int64 (*_cdae ),nil ;};return 0,ErrNotANumber ;};

// UpdateParams updates the parameter values of the encoder.
func (_dga *LZWEncoder )UpdateParams (params *PdfObjectDictionary ){_aagd ,_eaad :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _eaad ==nil {_dga .Predictor =int (_aagd );};_fddf ,_eaad :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _eaad ==nil {_dga .BitsPerComponent =int (_fddf );};_fbce ,_eaad :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _eaad ==nil {_dga .Columns =int (_fbce );};_dad ,_eaad :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _eaad ==nil {_dga .Colors =int (_dad );};_agf ,_eaad :=GetNumberAsInt64 (params .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065"));if _eaad ==nil {_dga .EarlyChange =int (_agf );};};

// Version represents a version of a PDF standard.
type Version struct{Major int ;Minor int ;};type cryptFilters map[string ]_fa .Filter ;func (_cgad *PdfParser )xrefNextObjectOffset (_gcdg int64 )int64 {_adba :=int64 (0);if len (_cgad ._cefa .ObjectMap )==0{return 0;};if len (_cgad ._cefa ._cgf )==0{_agbb :=0;for _ ,_cgdc :=range _cgad ._cefa .ObjectMap {if _cgdc .Offset > 0{_agbb ++;};};if _agbb ==0{return 0;};_cgad ._cefa ._cgf =make ([]XrefObject ,_agbb );_bbeecb :=0;for _ ,_acfcb :=range _cgad ._cefa .ObjectMap {if _acfcb .Offset > 0{_cgad ._cefa ._cgf [_bbeecb ]=_acfcb ;_bbeecb ++;};};_bf .Slice (_cgad ._cefa ._cgf ,func (_aeed ,_agfg int )bool {return _cgad ._cefa ._cgf [_aeed ].Offset < _cgad ._cefa ._cgf [_agfg ].Offset });};_bffg :=_bf .Search (len (_cgad ._cefa ._cgf ),func (_ddaed int )bool {return _cgad ._cefa ._cgf [_ddaed ].Offset >=_gcdg });if _bffg < len (_cgad ._cefa ._cgf ){_adba =_cgad ._cefa ._cgf [_bffg ].Offset ;};return _adba ;};const (XrefTypeTableEntry xrefType =iota ;XrefTypeObjectStream xrefType =iota ;);func (_ccbad *PdfObjectInteger )String ()string {return _ad .Sprintf ("\u0025\u0064",*_ccbad )};

// MakeName creates a PdfObjectName from a string.
func MakeName (s string )*PdfObjectName {_fegee :=PdfObjectName (s );return &_fegee };

// GetFilterName returns the name of the encoding filter.
func (_ddad *LZWEncoder )GetFilterName ()string {return StreamEncodingFilterNameLZW };func (_cega *PdfParser )parseXrefStream (_gbae *PdfObjectInteger )(*PdfObjectDictionary ,error ){if _gbae !=nil {_fc .Log .Trace ("\u0058\u0052\u0065f\u0053\u0074\u006d\u0020x\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0061\u0074\u0020\u0025\u0064",_gbae );_cega ._ffgb .Seek (int64 (*_gbae ),_de .SeekStart );_cega ._edcc =_ga .NewReader (_cega ._ffgb );};_bbef :=_cega .GetFileOffset ();_dfgg ,_fegg :=_cega .ParseIndirectObject ();if _fegg !=nil {_fc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072\u0065\u0061d\u0020\u0078\u0072\u0065\u0066\u0020\u006fb\u006a\u0065\u0063\u0074");return nil ,_d .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072e\u0061\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062j\u0065\u0063\u0074");};_fc .Log .Trace ("\u0058R\u0065f\u0053\u0074\u006d\u0020\u006fb\u006a\u0065c\u0074\u003a\u0020\u0025\u0073",_dfgg );_dgag ,_dbadc :=_dfgg .(*PdfObjectStream );if !_dbadc {_fc .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0058R\u0065\u0066\u0053\u0074\u006d\u0020\u0070o\u0069\u006e\u0074\u0069\u006e\u0067 \u0074\u006f\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065a\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0021");return nil ,_d .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0070\u006f\u0069\u006e\u0074i\u006e\u0067\u0020\u0074\u006f\u0020a\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006fb\u006a\u0065\u0063\u0074");};_bdbf :=_dgag .PdfObjectDictionary ;_bfae ,_dbadc :=_dgag .PdfObjectDictionary .Get ("\u0053\u0069\u007a\u0065").(*PdfObjectInteger );if !_dbadc {_fc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u004d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0073\u0069\u007a\u0065\u0020f\u0072\u006f\u006d\u0020\u0078\u0072\u0065f\u0020\u0073\u0074\u006d");return nil ,_d .New ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0053\u0069\u007ae\u0020\u0066\u0072\u006f\u006d\u0020\u0078\u0072\u0065\u0066 \u0073\u0074\u006d");};if int64 (*_bfae )> 8388607{_fc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u0053\u0069\u007a\u0065\u0020\u0065x\u0063\u0065\u0065\u0064\u0065\u0064\u0020l\u0069\u006d\u0069\u0074\u002c\u0020\u006f\u0076\u0065\u0072\u00208\u0033\u0038\u0038\u0036\u0030\u0037\u0020\u0028\u0025\u0064\u0029",*_bfae );return nil ,_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_ffee :=_dgag .PdfObjectDictionary .Get ("\u0057");_dcadd ,_dbadc :=_ffee .(*PdfObjectArray );if !_dbadc {return nil ,_d .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0057\u0020\u0069\u006e\u0020x\u0072\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d");};_bgga :=_dcadd .Len ();if _bgga !=3{_fc .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020\u0028\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033\u0020\u002d\u0020\u0025\u0064\u0029",_bgga );return nil ,_d .New ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065f\u0020s\u0074\u006d\u0020\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033");};var _dgec []int64 ;for _egga :=0;_egga < 3;_egga ++{_ccef ,_ggabc :=GetInt (_dcadd .Get (_egga ));if !_ggabc {return nil ,_d .New ("i\u006e\u0076\u0061\u006cid\u0020w\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0074\u0079\u0070\u0065");};_dgec =append (_dgec ,int64 (*_ccef ));};_gdae ,_fegg :=DecodeStream (_dgag );if _fegg !=nil {_fc .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020t\u006f \u0064e\u0063o\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u003a\u0020\u0025\u0076",_fegg );return nil ,_fegg ;};_agfb :=int (_dgec [0]);_bfaee :=int (_dgec [0]+_dgec [1]);_cgff :=int (_dgec [0]+_dgec [1]+_dgec [2]);_bdgb :=int (_dgec [0]+_dgec [1]+_dgec [2]);if _agfb < 0||_bfaee < 0||_cgff < 0{_fc .Log .Debug ("\u0045\u0072\u0072\u006fr\u0020\u0073\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u003c \u0030 \u0028\u0025\u0064\u002c\u0025\u0064\u002c%\u0064\u0029",_agfb ,_bfaee ,_cgff );return nil ,_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};if _bdgb ==0{_fc .Log .Debug ("\u004e\u006f\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063t\u0073\u0020\u0069\u006e\u0020\u0073t\u0072\u0065\u0061\u006d\u0020\u0028\u0064\u0065\u006c\u0074\u0061\u0062\u0020=\u003d\u0020\u0030\u0029");return _bdbf ,nil ;};_agea :=len (_gdae )/_bdgb ;_ddeb :=0;_bffe :=_dgag .PdfObjectDictionary .Get ("\u0049\u006e\u0064e\u0078");var _cbdg []int ;if _bffe !=nil {_fc .Log .Trace ("\u0049n\u0064\u0065\u0078\u003a\u0020\u0025b",_bffe );_ffec ,_addca :=_bffe .(*PdfObjectArray );if !_addca {_fc .Log .Debug ("\u0049\u006e\u0076\u0061\u006ci\u0064\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0029");return nil ,_d .New ("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0049\u006e\u0064e\u0078\u0020\u006f\u0062je\u0063\u0074");};if _ffec .Len ()%2!=0{_fc .Log .Debug ("\u0057\u0041\u0052\u004eI\u004e\u0047\u0020\u0046\u0061\u0069\u006c\u0075\u0072e\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020i\u006e\u0064\u0065\u0078\u0020n\u006f\u0074\u0020\u006d\u0075\u006c\u0074\u0069\u0070\u006c\u0065\u0020\u006f\u0066\u0020\u0032\u002e");return nil ,_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_ddeb =0;_fdgg ,_dgea :=_ffec .ToIntegerArray ();if _dgea !=nil {_fc .Log .Debug ("\u0045\u0072\u0072\u006f\u0072 \u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0065\u0078 \u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0073\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0073\u003a\u0020\u0025\u0076",_dgea );return nil ,_dgea ;};for _babg :=0;_babg < len (_fdgg );_babg +=2{_aabf :=_fdgg [_babg ];_fgcg :=_fdgg [_babg +1];for _agcf :=0;_agcf < _fgcg ;_agcf ++{_cbdg =append (_cbdg ,_aabf +_agcf );};_ddeb +=_fgcg ;};}else {for _ggce :=0;_ggce < int (*_bfae );_ggce ++{_cbdg =append (_cbdg ,_ggce );};_ddeb =int (*_bfae );};if _agea ==_ddeb +1{_fc .Log .Debug ("\u0049n\u0063\u006f\u006d\u0070ati\u0062\u0069\u006c\u0069t\u0079\u003a\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006di\u0073\u0073\u0069\u006e\u0067\u0020\u0063\u006f\u0076\u0065\u0072\u0061\u0067\u0065\u0020\u006f\u0066\u0020\u0031\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u002d\u0020\u0061\u0070\u0070en\u0064\u0069\u006eg\u0020\u006f\u006e\u0065\u0020-\u0020M\u0061\u0079\u0020\u006c\u0065\u0061\u0064\u0020\u0074o\u0020\u0070\u0072\u006f\u0062\u006c\u0065\u006d\u0073");_abag :=_ddeb -1;for _ ,_acfa :=range _cbdg {if _acfa > _abag {_abag =_acfa ;};};_cbdg =append (_cbdg ,_abag +1);_ddeb ++;};if _agea !=len (_cbdg ){_fc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020x\u0072\u0065\u0066 \u0073\u0074\u006d:\u0020\u006eu\u006d\u0020\u0065\u006e\u0074\u0072i\u0065s \u0021\u003d\u0020\u006c\u0065\u006e\u0028\u0069\u006e\u0064\u0069\u0063\u0065\u0073\u0029\u0020\u0028\u0025\u0064\u0020\u0021\u003d\u0020\u0025\u0064\u0029",_agea ,len (_cbdg ));return nil ,_d .New ("\u0078\u0072ef\u0020\u0073\u0074m\u0020\u006e\u0075\u006d en\u0074ri\u0065\u0073\u0020\u0021\u003d\u0020\u006cen\u0028\u0069\u006e\u0064\u0069\u0063\u0065s\u0029");};_fc .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074s\u0020\u0063\u006f\u0075\u006e\u0074\u0020\u0025\u0064",_ddeb );_fc .Log .Trace ("\u0049\u006e\u0064i\u0063\u0065\u0073\u003a\u0020\u0025\u0020\u0064",_cbdg );_bge :=func (_bggb []byte )int64 {var _gceb int64 ;for _ggdb :=0;_ggdb < len (_bggb );_ggdb ++{_gceb +=int64 (_bggb [_ggdb ])*(1<<uint (8*(len (_bggb )-_ggdb -1)));};return _gceb ;};_fc .Log .Trace ("\u0044e\u0063\u006f\u0064\u0065d\u0020\u0073\u0074\u0072\u0065a\u006d \u006ce\u006e\u0067\u0074\u0068\u003a\u0020\u0025d",len (_gdae ));_bddeg :=0;for _dcee :=0;_dcee < len (_gdae );_dcee +=_bdgb {_fgdcg :=_bgffb (len (_gdae ),_dcee ,_dcee +_agfb );if _fgdcg !=nil {_fc .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_fgdcg );return nil ,_fgdcg ;};_edca :=_gdae [_dcee :_dcee +_agfb ];_fgdcg =_bgffb (len (_gdae ),_dcee +_agfb ,_dcee +_bfaee );if _fgdcg !=nil {_fc .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_fgdcg );return nil ,_fgdcg ;};_dgb :=_gdae [_dcee +_agfb :_dcee +_bfaee ];_fgdcg =_bgffb (len (_gdae ),_dcee +_bfaee ,_dcee +_cgff );if _fgdcg !=nil {_fc .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_fgdcg );return nil ,_fgdcg ;};_bafg :=_gdae [_dcee +_bfaee :_dcee +_cgff ];_gdff :=_bge (_edca );_affd :=_bge (_dgb );_dbgf :=_bge (_bafg );if _dgec [0]==0{_gdff =1;};if _bddeg >=len (_cbdg ){_fc .Log .Debug ("X\u0052\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u002d\u0020\u0054\u0072\u0079\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0061\u0063\u0063e\u0073s\u0020\u0069\u006e\u0064e\u0078\u0020o\u0075\u0074\u0020\u006f\u0066\u0020\u0062\u006f\u0075\u006e\u0064\u0073\u0020\u002d\u0020\u0062\u0072\u0065\u0061\u006b\u0069\u006e\u0067");break ;};_fdba :=_cbdg [_bddeg ];_bddeg ++;_fc .Log .Trace ("%\u0064\u002e\u0020\u0070\u0031\u003a\u0020\u0025\u0020\u0078",_fdba ,_edca );_fc .Log .Trace ("%\u0064\u002e\u0020\u0070\u0032\u003a\u0020\u0025\u0020\u0078",_fdba ,_dgb );_fc .Log .Trace ("%\u0064\u002e\u0020\u0070\u0033\u003a\u0020\u0025\u0020\u0078",_fdba ,_bafg );_fc .Log .Trace ("\u0025d\u002e \u0078\u0072\u0065\u0066\u003a \u0025\u0064 \u0025\u0064\u0020\u0025\u0064",_fdba ,_gdff ,_affd ,_dbgf );if _gdff ==0{_fc .Log .Trace ("-\u0020\u0046\u0072\u0065\u0065\u0020o\u0062\u006a\u0065\u0063\u0074\u0020-\u0020\u0063\u0061\u006e\u0020\u0070\u0072o\u0062\u0061\u0062\u006c\u0079\u0020\u0069\u0067\u006e\u006fr\u0065");}else if _gdff ==1{_fc .Log .Trace ("\u002d\u0020I\u006e\u0020\u0075\u0073e\u0020\u002d \u0075\u006e\u0063\u006f\u006d\u0070\u0072\u0065s\u0073\u0065\u0064\u0020\u0076\u0069\u0061\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0062",_dgb );if _affd ==_bbef {_fc .Log .Debug ("\u0055\u0070d\u0061\u0074\u0069\u006e\u0067\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0058\u0052\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0064",_fdba ,_dgag .ObjectNumber );_fdba =int (_dgag .ObjectNumber );};if _bddeb ,_ceb :=_cega ._cefa .ObjectMap [_fdba ];!_ceb ||int (_dbgf )> _bddeb .Generation {_ccbf :=XrefObject {ObjectNumber :_fdba ,XType :XrefTypeTableEntry ,Offset :_affd ,Generation :int (_dbgf )};_cega ._cefa .ObjectMap [_fdba ]=_ccbf ;};}else if _gdff ==2{_fc .Log .Trace ("\u002d\u0020\u0049\u006e \u0075\u0073\u0065\u0020\u002d\u0020\u0063\u006f\u006d\u0070r\u0065s\u0073\u0065\u0064\u0020\u006f\u0062\u006ae\u0063\u0074");if _ ,_deac :=_cega ._cefa .ObjectMap [_fdba ];!_deac {_gfga :=XrefObject {ObjectNumber :_fdba ,XType :XrefTypeObjectStream ,OsObjNumber :int (_affd ),OsObjIndex :int (_dbgf )};_cega ._cefa .ObjectMap [_fdba ]=_gfga ;_fc .Log .Trace ("\u0065\u006e\u0074\u0072\u0079\u003a\u0020\u0025\u002b\u0076",_gfga );};}else {_fc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052:\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0056\u0041L\u0049\u0044\u0020\u0054\u0059\u0050\u0045\u0020\u0058\u0072\u0065\u0066\u0053\u0074\u006d\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u003f\u002d\u002d\u002d\u002d\u002d\u002d-");continue ;};};if _cega ._gegg ==nil {_bcga :=XrefTypeObjectStream ;_cega ._gegg =&_bcga ;};return _bdbf ,nil ;};

// LZWEncoder provides LZW encoding/decoding functionality.
type LZWEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Colors int ;

// LZW algorithm setting.
EarlyChange int ;};

// DecodeStream decodes the stream data and returns the decoded data.
// An error is returned upon failure.
func DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_fc .Log .Trace ("\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_cfged ,_bcbce :=NewEncoderFromStream (streamObj );if _bcbce !=nil {_fc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_bcbce );return nil ,_bcbce ;};_fc .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076\u000a",_cfged );_ddeg ,_bcbce :=_cfged .DecodeStream (streamObj );if _bcbce !=nil {_fc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_bcbce );return nil ,_bcbce ;};return _ddeg ,nil ;};

// GetFilterName returns the name of the encoding filter.
func (_ddae *DCTEncoder )GetFilterName ()string {return StreamEncodingFilterNameDCT };

// DecodeStream implements ASCII85 stream decoding.
func (_bcea *ASCII85Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _bcea .DecodeBytes (streamObj .Stream );};

// GetBoolVal returns the bool value within a *PdObjectBool represented by an PdfObject interface directly or indirectly.
// If the PdfObject does not represent a bool value, a default value of false is returned (found = false also).
func GetBoolVal (obj PdfObject )(_gddb bool ,_gcbed bool ){_ccgc ,_gcbed :=TraceToDirectObject (obj ).(*PdfObjectBool );if _gcbed {return bool (*_ccgc ),true ;};return false ,false ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_gcba *ASCIIHexEncoder )MakeDecodeParams ()PdfObject {return nil };func _bfea (_fefc *PdfObjectDictionary )(_aggc *_df .ImageBase ){var (_ebcfd *PdfObjectInteger ;_eaeb bool ;);if _ebcfd ,_eaeb =_fefc .Get ("\u0057\u0069\u0064t\u0068").(*PdfObjectInteger );_eaeb {_aggc =&_df .ImageBase {Width :int (*_ebcfd )};}else {return nil ;};if _ebcfd ,_eaeb =_fefc .Get ("\u0048\u0065\u0069\u0067\u0068\u0074").(*PdfObjectInteger );_eaeb {_aggc .Height =int (*_ebcfd );};if _ebcfd ,_eaeb =_fefc .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074").(*PdfObjectInteger );_eaeb {_aggc .BitsPerComponent =int (*_ebcfd );};if _ebcfd ,_eaeb =_fefc .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073").(*PdfObjectInteger );_eaeb {_aggc .ColorComponents =int (*_ebcfd );};return _aggc ;};

// ToInt64Slice returns a slice of all array elements as an int64 slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_fcgec *PdfObjectArray )ToInt64Slice ()([]int64 ,error ){var _cded []int64 ;for _ ,_affc :=range _fcgec .Elements (){if _eaac ,_cgbab :=_affc .(*PdfObjectInteger );_cgbab {_cded =append (_cded ,int64 (*_eaac ));}else {return nil ,ErrTypeError ;};};return _cded ,nil ;};

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_ceac *FlateEncoder )EncodeBytes (data []byte )([]byte ,error ){if _ceac .Predictor !=1&&_ceac .Predictor !=11{_fc .Log .Debug ("E\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0046\u006c\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065r\u0020P\u0072\u0065\u0064\u0069c\u0074\u006fr\u0020\u003d\u0020\u0031\u002c\u0020\u0031\u0031\u0020\u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");return nil ,ErrUnsupportedEncodingParameters ;};if _ceac .Predictor ==11{_caeec :=int (_ceac .Columns );_aafg :=len (data )/_caeec ;if len (data )%_caeec !=0{_fc .Log .Error ("\u0049n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");return nil ,_d .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");};_dfd :=_acf .NewBuffer (nil );_dda :=make ([]byte ,_caeec );for _ecd :=0;_ecd < _aafg ;_ecd ++{_bgdg :=data [_caeec *_ecd :_caeec *(_ecd +1)];_dda [0]=_bgdg [0];for _acd :=1;_acd < _caeec ;_acd ++{_dda [_acd ]=byte (int (_bgdg [_acd ]-_bgdg [_acd -1])%256);};_dfd .WriteByte (1);_dfd .Write (_dda );};data =_dfd .Bytes ();};var _dbba _acf .Buffer ;_cfge :=_gg .NewWriter (&_dbba );_cfge .Write (data );_cfge .Close ();return _dbba .Bytes (),nil ;};

// DecodeBytes decodes a slice of JBIG2 encoded bytes and returns the results.
func (_edaa *JBIG2Encoder )DecodeBytes (encoded []byte )([]byte ,error ){return _fcd .DecodeBytes (encoded ,_ff .Parameters {},_edaa .Globals );};

// GetName returns the *PdfObjectName represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetName (obj PdfObject )(_dbc *PdfObjectName ,_cdag bool ){_dbc ,_cdag =TraceToDirectObject (obj ).(*PdfObjectName );return _dbc ,_cdag ;};func _abaf (_aedg ,_cbda PdfObject ,_ddbe int )bool {if _ddbe > _cefec {_fc .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_cefec );return false ;};if _aedg ==nil &&_cbda ==nil {return true ;}else if _aedg ==nil ||_cbda ==nil {return false ;};if _g .TypeOf (_aedg )!=_g .TypeOf (_cbda ){return false ;};switch _bdbc :=_aedg .(type ){case *PdfObjectNull ,*PdfObjectReference :return true ;case *PdfObjectName :return *_bdbc ==*(_cbda .(*PdfObjectName ));case *PdfObjectString :return *_bdbc ==*(_cbda .(*PdfObjectString ));case *PdfObjectInteger :return *_bdbc ==*(_cbda .(*PdfObjectInteger ));case *PdfObjectBool :return *_bdbc ==*(_cbda .(*PdfObjectBool ));case *PdfObjectFloat :return *_bdbc ==*(_cbda .(*PdfObjectFloat ));case *PdfIndirectObject :return _abaf (TraceToDirectObject (_aedg ),TraceToDirectObject (_cbda ),_ddbe +1);case *PdfObjectArray :_fceea :=_cbda .(*PdfObjectArray );if len ((*_bdbc )._fbbf )!=len ((*_fceea )._fbbf ){return false ;};for _febgf ,_fcfcd :=range (*_bdbc )._fbbf {if !_abaf (_fcfcd ,(*_fceea )._fbbf [_febgf ],_ddbe +1){return false ;};};return true ;case *PdfObjectDictionary :_begb :=_cbda .(*PdfObjectDictionary );_bdcd ,_egfba :=(*_bdbc )._baca ,(*_begb )._baca ;if len (_bdcd )!=len (_egfba ){return false ;};for _fegcg ,_bdcf :=range _bdcd {_eagfe ,_bdbda :=_egfba [_fegcg ];if !_bdbda ||!_abaf (_bdcf ,_eagfe ,_ddbe +1){return false ;};};return true ;case *PdfObjectStream :_bacg :=_cbda .(*PdfObjectStream );return _abaf ((*_bdbc ).PdfObjectDictionary ,(*_bacg ).PdfObjectDictionary ,_ddbe +1);default:_fc .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",_aedg );};return false ;};

// EncodeStream encodes the stream data using the encoded specified by the stream's dictionary.
func EncodeStream (streamObj *PdfObjectStream )error {_fc .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_aagcg ,_cefb :=NewEncoderFromStream (streamObj );if _cefb !=nil {_fc .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_cefb );return _cefb ;};if _eddfd ,_cacgg :=_aagcg .(*LZWEncoder );_cacgg {_eddfd .EarlyChange =0;streamObj .PdfObjectDictionary .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (0));};_fc .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076\u000a",_aagcg );_bgbgg ,_cefb :=_aagcg .EncodeBytes (streamObj .Stream );if _cefb !=nil {_fc .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_cefb );return _cefb ;};streamObj .Stream =_bgbgg ;streamObj .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_bgbgg ))));return nil ;};func (_adag *offsetReader )Seek (offset int64 ,whence int )(int64 ,error ){if whence ==_de .SeekStart {offset +=_adag ._daf ;};_bgab ,_ebbe :=_adag ._dfda .Seek (offset ,whence );if _ebbe !=nil {return _bgab ,_ebbe ;};if whence ==_de .SeekCurrent {_bgab -=_adag ._daf ;};if _bgab < 0{return 0,_d .New ("\u0063\u006f\u0072\u0065\u002eo\u0066\u0066\u0073\u0065\u0074\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053e\u0065\u006b\u003a\u0020\u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e");};return _bgab ,nil ;};

// GetCrypter returns the PdfCrypt instance which has information about the PDFs encryption.
func (_fgdc *PdfParser )GetCrypter ()*PdfCrypt {return _fgdc ._fgae };

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_eccg *RunLengthEncoder )EncodeBytes (data []byte )([]byte ,error ){_ffde :=_acf .NewReader (data );var _cgdd []byte ;var _gffb []byte ;_dcdd ,_cfgeb :=_ffde .ReadByte ();if _cfgeb ==_de .EOF {return []byte {},nil ;}else if _cfgeb !=nil {return nil ,_cfgeb ;};_ggbd :=1;for {_gfe ,_fbabb :=_ffde .ReadByte ();if _fbabb ==_de .EOF {break ;}else if _fbabb !=nil {return nil ,_fbabb ;};if _gfe ==_dcdd {if len (_gffb )> 0{_gffb =_gffb [:len (_gffb )-1];if len (_gffb )> 0{_cgdd =append (_cgdd ,byte (len (_gffb )-1));_cgdd =append (_cgdd ,_gffb ...);};_ggbd =1;_gffb =[]byte {};};_ggbd ++;if _ggbd >=127{_cgdd =append (_cgdd ,byte (257-_ggbd ),_dcdd );_ggbd =0;};}else {if _ggbd > 0{if _ggbd ==1{_gffb =[]byte {_dcdd };}else {_cgdd =append (_cgdd ,byte (257-_ggbd ),_dcdd );};_ggbd =0;};_gffb =append (_gffb ,_gfe );if len (_gffb )>=127{_cgdd =append (_cgdd ,byte (len (_gffb )-1));_cgdd =append (_cgdd ,_gffb ...);_gffb =[]byte {};};};_dcdd =_gfe ;};if len (_gffb )> 0{_cgdd =append (_cgdd ,byte (len (_gffb )-1));_cgdd =append (_cgdd ,_gffb ...);}else if _ggbd > 0{_cgdd =append (_cgdd ,byte (257-_ggbd ),_dcdd );};_cgdd =append (_cgdd ,128);return _cgdd ,nil ;};

// ResolveReference resolves reference if `o` is a *PdfObjectReference and returns the object referenced to.
// Otherwise returns back `o`.
func ResolveReference (obj PdfObject )PdfObject {if _gcdb ,_afbg :=obj .(*PdfObjectReference );_afbg {return _gcdb .Resolve ();};return obj ;};

// Validate validates the page settings for the JBIG2 encoder.
func (_dfgfc JBIG2EncoderSettings )Validate ()error {const _bcc ="\u0076a\u006ci\u0064\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065\u0072";if _dfgfc .Threshold < 0||_dfgfc .Threshold > 1.0{return _be .Errorf (_bcc ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074\u0068\u0072\u0065\u0073\u0068\u006f\u006c\u0064\u0020\u0076a\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0076\u0027 \u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0069\u006e\u0020\u0072\u0061n\u0067\u0065\u0020\u005b\u0030\u002e0\u002c\u0020\u0031.\u0030\u005d",_dfgfc .Threshold );};if _dfgfc .ResolutionX < 0{return _be .Errorf (_bcc ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0078\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_dfgfc .ResolutionX );};if _dfgfc .ResolutionY < 0{return _be .Errorf (_bcc ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0079\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_dfgfc .ResolutionY );};if _dfgfc .DefaultPixelValue !=0&&_dfgfc .DefaultPixelValue !=1{return _be .Errorf (_bcc ,"de\u0066\u0061u\u006c\u0074\u0020\u0070\u0069\u0078\u0065\u006c\u0020v\u0061\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0066o\u0072 \u0074\u0068\u0065\u0020\u0062\u0069\u0074\u003a \u007b0\u002c\u0031}",_dfgfc .DefaultPixelValue );};if _dfgfc .Compression !=JB2Generic {return _be .Errorf (_bcc ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065d\u0020\u0063\u006fm\u0070\u0072\u0065\u0073s\u0069\u006f\u006e\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");};return nil ;};

// EncodeBytes ASCII encodes the passed in slice of bytes.
func (_bbdg *ASCIIHexEncoder )EncodeBytes (data []byte )([]byte ,error ){var _bgcda _acf .Buffer ;for _ ,_faf :=range data {_bgcda .WriteString (_ad .Sprintf ("\u0025\u002e\u0032X\u0020",_faf ));};_bgcda .WriteByte ('>');return _bgcda .Bytes (),nil ;};func (_dfgb *offsetReader )Read (p []byte )(_ebfag int ,_dbac error ){return _dfgb ._dfda .Read (p )};

// WriteString outputs the object as it is to be written to file.
func (_geab *PdfObjectArray )WriteString ()string {var _fggda _bcb .Builder ;_fggda .WriteString ("\u005b");for _bebf ,_abaa :=range _geab .Elements (){_fggda .WriteString (_abaa .WriteString ());if _bebf < (_geab .Len ()-1){_fggda .WriteString ("\u0020");};};_fggda .WriteString ("\u005d");return _fggda .String ();};

// UpdateParams updates the parameter values of the encoder.
func (_gdgab *ASCIIHexEncoder )UpdateParams (params *PdfObjectDictionary ){};func (_fced *PdfParser )parseString ()(*PdfObjectString ,error ){_fced ._edcc .ReadByte ();var _fbcb _acf .Buffer ;_dbgg :=1;for {_dfgbg ,_fege :=_fced ._edcc .Peek (1);if _fege !=nil {return MakeString (_fbcb .String ()),_fege ;};if _dfgbg [0]=='\\'{_fced ._edcc .ReadByte ();_cgcf ,_dcab :=_fced ._edcc .ReadByte ();if _dcab !=nil {return MakeString (_fbcb .String ()),_dcab ;};if IsOctalDigit (_cgcf ){_afedd ,_fceb :=_fced ._edcc .Peek (2);if _fceb !=nil {return MakeString (_fbcb .String ()),_fceb ;};var _cbcd []byte ;_cbcd =append (_cbcd ,_cgcf );for _ ,_ffga :=range _afedd {if IsOctalDigit (_ffga ){_cbcd =append (_cbcd ,_ffga );}else {break ;};};_fced ._edcc .Discard (len (_cbcd )-1);_fc .Log .Trace ("\u004e\u0075\u006d\u0065ri\u0063\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0022\u0025\u0073\u0022",_cbcd );_fgcd ,_fceb :=_a .ParseUint (string (_cbcd ),8,32);if _fceb !=nil {return MakeString (_fbcb .String ()),_fceb ;};_fbcb .WriteByte (byte (_fgcd ));continue ;};switch _cgcf {case 'n':_fbcb .WriteRune ('\n');case 'r':_fbcb .WriteRune ('\r');case 't':_fbcb .WriteRune ('\t');case 'b':_fbcb .WriteRune ('\b');case 'f':_fbcb .WriteRune ('\f');case '(':_fbcb .WriteRune ('(');case ')':_fbcb .WriteRune (')');case '\\':_fbcb .WriteRune ('\\');};continue ;}else if _dfgbg [0]=='('{_dbgg ++;}else if _dfgbg [0]==')'{_dbgg --;if _dbgg ==0{_fced ._edcc .ReadByte ();break ;};};_edfb ,_ :=_fced ._edcc .ReadByte ();_fbcb .WriteByte (_edfb );};return MakeString (_fbcb .String ()),nil ;};

// WriteString outputs the object as it is to be written to file.
func (_ccfb *PdfObjectStreams )WriteString ()string {var _aeffc _bcb .Builder ;_aeffc .WriteString (_a .FormatInt (_ccfb .ObjectNumber ,10));_aeffc .WriteString ("\u0020\u0030\u0020\u0052");return _aeffc .String ();};

// IsOctalDigit checks if a character can be part of an octal digit string.
func IsOctalDigit (c byte )bool {return '0'<=c &&c <='7'};

// MakeString creates an PdfObjectString from a string.
// NOTE: PDF does not use utf-8 string encoding like Go so `s` will often not be a utf-8 encoded
// string.
func MakeString (s string )*PdfObjectString {_cffgb :=PdfObjectString {_ddeab :s };return &_cffgb };

// ReadBytesAt reads byte content at specific offset and length within the PDF.
func (_aeae *PdfParser )ReadBytesAt (offset ,len int64 )([]byte ,error ){_ffcb :=_aeae .GetFileOffset ();_ ,_cbffd :=_aeae ._ffgb .Seek (offset ,_de .SeekStart );if _cbffd !=nil {return nil ,_cbffd ;};_cdgc :=make ([]byte ,len );_ ,_cbffd =_de .ReadAtLeast (_aeae ._ffgb ,_cdgc ,int (len ));if _cbffd !=nil {return nil ,_cbffd ;};_aeae .SetFileOffset (_ffcb );return _cdgc ,nil ;};func (_eb *PdfParser )lookupObjectViaOS (_cf int ,_ebd int )(PdfObject ,error ){var _afb *_acf .Reader ;var _dd objectStream ;var _afg bool ;_dd ,_afg =_eb ._ead [_cf ];if !_afg {_cge ,_cd :=_eb .LookupByNumber (_cf );if _cd !=nil {_fc .Log .Debug ("\u004d\u0069ss\u0069\u006e\u0067 \u006f\u0062\u006a\u0065ct \u0073tr\u0065\u0061\u006d\u0020\u0077\u0069\u0074h \u006e\u0075\u006d\u0062\u0065\u0072\u0020%\u0064",_cf );return nil ,_cd ;};_ebc ,_ea :=_cge .(*PdfObjectStream );if !_ea {return nil ,_d .New ("i\u006e\u0076\u0061\u006cid\u0020o\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d");};if _eb ._fgae !=nil &&!_eb ._fgae .isDecrypted (_ebc ){return nil ,_d .New ("\u006e\u0065\u0065\u0064\u0020\u0074\u006f\u0020\u0064\u0065\u0063r\u0079\u0070\u0074\u0020\u0074\u0068\u0065\u0020\u0073\u0074r\u0065\u0061\u006d");};_acb :=_ebc .PdfObjectDictionary ;_fc .Log .Trace ("\u0073o\u0020\u0064\u003a\u0020\u0025\u0073\n",_acb .String ());_ggd ,_ea :=_acb .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if !_ea {_fc .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0061\u006c\u0077\u0061\u0079\u0073\u0020\u0068\u0061\u0076\u0065\u0020\u0061\u0020\u0054\u0079\u0070\u0065");return nil ,_d .New ("\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020T\u0079\u0070\u0065");};if _bcb .ToLower (string (*_ggd ))!="\u006f\u0062\u006a\u0073\u0074\u006d"{_fc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0074\u0079\u0070\u0065\u0020s\u0068\u0061\u006c\u006c\u0020\u0061\u006c\u0077\u0061\u0079\u0073 \u0062\u0065\u0020\u004f\u0062\u006a\u0053\u0074\u006d\u0020\u0021");return nil ,_d .New ("\u006f\u0062\u006a\u0065c\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0074y\u0070e\u0020\u0021\u003d\u0020\u004f\u0062\u006aS\u0074\u006d");};N ,_ea :=_acb .Get ("\u004e").(*PdfObjectInteger );if !_ea {return nil ,_d .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u004e\u0020i\u006e\u0020\u0073\u0074\u0072\u0065\u0061m\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_ag ,_ea :=_acb .Get ("\u0046\u0069\u0072s\u0074").(*PdfObjectInteger );if !_ea {return nil ,_d .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0046\u0069\u0072\u0073\u0074\u0020i\u006e \u0073t\u0072e\u0061\u006d\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_fc .Log .Trace ("\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0073\u0020\u006eu\u006d\u0062\u0065\u0072\u0020\u006f\u0066 \u006f\u0062\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_ggd ,*N );_cc ,_cd :=DecodeStream (_ebc );if _cd !=nil {return nil ,_cd ;};_fc .Log .Trace ("D\u0065\u0063\u006f\u0064\u0065\u0064\u003a\u0020\u0025\u0073",_cc );_dbe :=_eb .GetFileOffset ();defer func (){_eb .SetFileOffset (_dbe )}();_afb =_acf .NewReader (_cc );_eb ._edcc =_ga .NewReader (_afb );_fc .Log .Trace ("\u0050a\u0072s\u0069\u006e\u0067\u0020\u006ff\u0066\u0073e\u0074\u0020\u006d\u0061\u0070");_ge :=map[int ]int64 {};for _edb :=0;_edb < int (*N );_edb ++{_eb .skipSpaces ();_ef ,_acg :=_eb .parseNumber ();if _acg !=nil {return nil ,_acg ;};_fbe ,_ee :=_ef .(*PdfObjectInteger );if !_ee {return nil ,_d .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");};_eb .skipSpaces ();_ef ,_acg =_eb .parseNumber ();if _acg !=nil {return nil ,_acg ;};_eg ,_ee :=_ef .(*PdfObjectInteger );if !_ee {return nil ,_d .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");};_fc .Log .Trace ("\u006f\u0062j\u0020\u0025\u0064 \u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0025\u0064",*_fbe ,*_eg );_ge [int (*_fbe )]=int64 (*_ag +*_eg );};_dd =objectStream {N :int (*N ),_add :_cc ,_def :_ge };_eb ._ead [_cf ]=_dd ;}else {_gef :=_eb .GetFileOffset ();defer func (){_eb .SetFileOffset (_gef )}();_afb =_acf .NewReader (_dd ._add );_eb ._edcc =_ga .NewReader (_afb );};_fg :=_dd ._def [_ebd ];_fc .Log .Trace ("\u0041\u0043\u0054\u0055AL\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u005b\u0025\u0064\u005d\u0020\u003d\u0020%\u0064",_ebd ,_fg );_afb .Seek (_fg ,_ac .SEEK_SET );_eb ._edcc =_ga .NewReader (_afb );_ab ,_ :=_eb ._edcc .Peek (100);_fc .Log .Trace ("\u004f\u0042\u004a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_ab ));_ccb ,_abg :=_eb .parseObject ();if _abg !=nil {_fc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c \u0074\u006f\u0020\u0072\u0065\u0061\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_abg );return nil ,_abg ;};if _ccb ==nil {return nil ,_d .New ("o\u0062\u006a\u0065\u0063t \u0063a\u006e\u006e\u006f\u0074\u0020b\u0065\u0020\u006e\u0075\u006c\u006c");};_ae :=PdfIndirectObject {};_ae .ObjectNumber =int64 (_ebd );_ae .PdfObject =_ccb ;return &_ae ,nil ;};

// GetTrailer returns the PDFs trailer dictionary. The trailer dictionary is typically the starting point for a PDF,
// referencing other key objects that are important in the document structure.
func (_edbb *PdfParser )GetTrailer ()*PdfObjectDictionary {return _edbb ._dgef };

// Decoded returns the PDFDocEncoding or UTF-16BE decoded string contents.
// UTF-16BE is applied when the first two bytes are 0xFE, 0XFF, otherwise decoding of
// PDFDocEncoding is performed.
func (_dced *PdfObjectString )Decoded ()string {if _dced ==nil {return "";};_cgdg :=[]byte (_dced ._ddeab );if len (_cgdg )>=2&&_cgdg [0]==0xFE&&_cgdg [1]==0xFF{return _gb .UTF16ToString (_cgdg [2:]);};return _gb .PDFDocEncodingToString (_cgdg );};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_dfge *LZWEncoder )MakeStreamDict ()*PdfObjectDictionary {_gab :=MakeDict ();_gab .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_dfge .GetFilterName ()));_aeba :=_dfge .MakeDecodeParams ();if _aeba !=nil {_gab .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_aeba );};_gab .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (int64 (_dfge .EarlyChange )));return _gab ;};

// Clear resets the array to an empty state.
func (_ffeee *PdfObjectArray )Clear (){_ffeee ._fbbf =[]PdfObject {}};

// GetNameVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetNameVal (obj PdfObject )(_cabf string ,_dbcg bool ){_cgbabf ,_dbcg :=TraceToDirectObject (obj ).(*PdfObjectName );if _dbcg {return string (*_cgbabf ),true ;};return ;};

// IsNullObject returns true if `obj` is a PdfObjectNull.
func IsNullObject (obj PdfObject )bool {_ ,_deccd :=TraceToDirectObject (obj ).(*PdfObjectNull );return _deccd ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_afcc *ASCIIHexEncoder )MakeStreamDict ()*PdfObjectDictionary {_ebeb :=MakeDict ();_ebeb .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_afcc .GetFilterName ()));return _ebeb ;};

// GetArray returns the *PdfObjectArray represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetArray (obj PdfObject )(_ebabg *PdfObjectArray ,_cbdgc bool ){_ebabg ,_cbdgc =TraceToDirectObject (obj ).(*PdfObjectArray );return _ebabg ,_cbdgc ;};

// WriteString outputs the object as it is to be written to file.
func (_fdgee *PdfObjectStream )WriteString ()string {var _eecdb _bcb .Builder ;_eecdb .WriteString (_a .FormatInt (_fdgee .ObjectNumber ,10));_eecdb .WriteString ("\u0020\u0030\u0020\u0052");return _eecdb .String ();};

// DecodeBytes decodes a slice of LZW encoded bytes and returns the result.
func (_bafc *LZWEncoder )DecodeBytes (encoded []byte )([]byte ,error ){var _ccf _acf .Buffer ;_aef :=_acf .NewReader (encoded );var _cbgc _de .ReadCloser ;if _bafc .EarlyChange ==1{_cbgc =_fba .NewReader (_aef ,_fba .MSB ,8);}else {_cbgc =_gd .NewReader (_aef ,_gd .MSB ,8);};defer _cbgc .Close ();_ ,_cggb :=_ccf .ReadFrom (_cbgc );if _cggb !=nil {return nil ,_cggb ;};return _ccf .Bytes (),nil ;};const JB2ImageAutoThreshold =-1.0;func _bace ()string {return _fc .Version };

// Inspect analyzes the document object structure. Returns a map of object types (by name) with the instance count
// as value.
func (_cfeb *PdfParser )Inspect ()(map[string ]int ,error ){return _cfeb .inspect ()};func _dgc (_fgg *_db .StdEncryptDict ,_gdd *PdfObjectDictionary ){_gdd .Set ("\u0052",MakeInteger (int64 (_fgg .R )));_gdd .Set ("\u0050",MakeInteger (int64 (_fgg .P )));_gdd .Set ("\u004f",MakeStringFromBytes (_fgg .O ));_gdd .Set ("\u0055",MakeStringFromBytes (_fgg .U ));if _fgg .R >=5{_gdd .Set ("\u004f\u0045",MakeStringFromBytes (_fgg .OE ));_gdd .Set ("\u0055\u0045",MakeStringFromBytes (_fgg .UE ));_gdd .Set ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061",MakeBool (_fgg .EncryptMetadata ));if _fgg .R > 5{_gdd .Set ("\u0050\u0065\u0072m\u0073",MakeStringFromBytes (_fgg .Perms ));};};};func (_cbff *PdfCrypt )securityHandler ()_db .StdHandler {if _cbff ._ec .R >=5{return _db .NewHandlerR6 ();};return _db .NewHandlerR4 (_cbff ._eeef ,_cbff ._dbb .Length );};

// PdfCryptNewEncrypt makes the document crypt handler based on a specified crypt filter.
func PdfCryptNewEncrypt (cf _fa .Filter ,userPass ,ownerPass []byte ,perm _db .Permissions )(*PdfCrypt ,*EncryptInfo ,error ){_dca :=&PdfCrypt {_ba :make (map[PdfObject ]bool ),_fgb :make (cryptFilters ),_ec :_db .StdEncryptDict {P :perm ,EncryptMetadata :true }};var _bedg Version ;if cf !=nil {_cde :=cf .PDFVersion ();_bedg .Major ,_bedg .Minor =_cde [0],_cde [1];V ,R :=cf .HandlerVersion ();_dca ._dbb .V =V ;_dca ._ec .R =R ;_dca ._dbb .Length =cf .KeyLength ()*8;};const (_ddf =_bbb ;);_dca ._fgb [_ddf ]=cf ;if _dca ._dbb .V >=4{_dca ._efe =_ddf ;_dca ._ebcg =_ddf ;};_bdg :=_dca .newEncryptDict ();_adg :=_cg .Sum ([]byte (_c .Now ().Format (_c .RFC850 )));_cbf :=string (_adg [:]);_dgg :=make ([]byte ,100);_fe .Read (_dgg );_adg =_cg .Sum (_dgg );_bg :=string (_adg [:]);_fc .Log .Trace ("\u0052\u0061\u006e\u0064\u006f\u006d\u0020\u0062\u003a\u0020\u0025\u0020\u0078",_dgg );_fc .Log .Trace ("\u0047\u0065\u006e\u0020\u0049\u0064\u0020\u0030\u003a\u0020\u0025\u0020\u0078",_cbf );_dca ._eeef =string (_cbf );_daa :=_dca .generateParams (userPass ,ownerPass );if _daa !=nil {return nil ,nil ,_daa ;};_dgc (&_dca ._ec ,_bdg );if _dca ._dbb .V >=4{if _ege :=_dca .saveCryptFilters (_bdg );_ege !=nil {return nil ,nil ,_ege ;};};return _dca ,&EncryptInfo {Version :_bedg ,Encrypt :_bdg ,ID0 :_cbf ,ID1 :_bg },nil ;};

// Decrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_bbf *PdfCrypt )Decrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _bbf .isDecrypted (obj ){return nil ;};switch _agbg :=obj .(type ){case *PdfIndirectObject :_bbf ._fdg [_agbg ]=true ;_fc .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_agbg .ObjectNumber ,_agbg .GenerationNumber );_dbgc :=_agbg .ObjectNumber ;_efca :=_agbg .GenerationNumber ;_bgd :=_bbf .Decrypt (_agbg .PdfObject ,_dbgc ,_efca );if _bgd !=nil {return _bgd ;};return nil ;case *PdfObjectStream :_bbf ._fdg [_agbg ]=true ;_abff :=_agbg .PdfObjectDictionary ;if _bbf ._ec .R !=5{if _dfec ,_egad :=_abff .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_egad &&*_dfec =="\u0058\u0052\u0065\u0066"{return nil ;};};_cga :=_agbg .ObjectNumber ;_abd :=_agbg .GenerationNumber ;_fc .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_cga ,_abd );_ffeg :=_bbb ;if _bbf ._dbb .V >=4{_ffeg =_bbf ._efe ;_fc .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_bbf ._efe );if _eag ,_deb :=_abff .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );_deb {if _cad ,_bbee :=GetName (_eag .Get (0));_bbee {if *_cad =="\u0043\u0072\u0079p\u0074"{_ffeg ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _gdf ,_fgf :=_abff .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );_fgf {if _daag ,_fda :=_gdf .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_fda {if _ ,_dcb :=_bbf ._fgb [string (*_daag )];_dcb {_fc .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_daag );_ffeg =string (*_daag );};};};};};};_fc .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_ffeg );if _ffeg =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_afge :=_bbf .Decrypt (_abff ,_cga ,_abd );if _afge !=nil {return _afge ;};_fbea ,_afge :=_bbf .makeKey (_ffeg ,uint32 (_cga ),uint32 (_abd ),_bbf ._bgb );if _afge !=nil {return _afge ;};_agbg .Stream ,_afge =_bbf .decryptBytes (_agbg .Stream ,_ffeg ,_fbea );if _afge !=nil {return _afge ;};_abff .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_agbg .Stream ))));return nil ;case *PdfObjectString :_fc .Log .Trace ("\u0044e\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_gae :=_bbb ;if _bbf ._dbb .V >=4{_fc .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_bbf ._ebcg );if _bbf ._ebcg =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_gae =_bbf ._ebcg ;};_eeeg ,_gaad :=_bbf .makeKey (_gae ,uint32 (parentObjNum ),uint32 (parentGenNum ),_bbf ._bgb );if _gaad !=nil {return _gaad ;};_fcge :=_agbg .Str ();_ccg :=make ([]byte ,len (_fcge ));for _fgfg :=0;_fgfg < len (_fcge );_fgfg ++{_ccg [_fgfg ]=_fcge [_fgfg ];};_fc .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_ccg ,_ccg );_ccg ,_gaad =_bbf .decryptBytes (_ccg ,_gae ,_eeeg );if _gaad !=nil {return _gaad ;};_agbg ._ddeab =string (_ccg );return nil ;case *PdfObjectArray :for _ ,_dcg :=range _agbg .Elements (){_gfa :=_bbf .Decrypt (_dcg ,parentObjNum ,parentGenNum );if _gfa !=nil {return _gfa ;};};return nil ;case *PdfObjectDictionary :_afgd :=false ;if _adf :=_agbg .Get ("\u0054\u0079\u0070\u0065");_adf !=nil {_ebg ,_feb :=_adf .(*PdfObjectName );if _feb &&*_ebg =="\u0053\u0069\u0067"{_afgd =true ;};};for _ ,_fefd :=range _agbg .Keys (){_aafb :=_agbg .Get (_fefd );if _afgd &&string (_fefd )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;};if string (_fefd )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_fefd )!="\u0050\u0072\u0065\u0076"&&string (_fefd )!="\u004c\u0061\u0073\u0074"{_fbec :=_bbf .Decrypt (_aafb ,parentObjNum ,parentGenNum );if _fbec !=nil {return _fbec ;};};};return nil ;};return nil ;};func (_ceg *FlateEncoder )postDecodePredict (_efbb []byte )([]byte ,error ){if _ceg .Predictor > 1{if _ceg .Predictor ==2{_fc .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_fc .Log .Trace ("\u0043\u006f\u006c\u006f\u0072\u0073\u003a\u0020\u0025\u0064",_ceg .Colors );_baad :=int (_ceg .Columns )*_ceg .Colors ;if _baad < 1{return []byte {},nil ;};_eff :=len (_efbb )/_baad ;if len (_efbb )%_baad !=0{_fc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");return nil ,_ad .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_efbb ),_baad );};if _baad %_ceg .Colors !=0{return nil ,_ad .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_baad ,_ceg .Colors );};if _baad > len (_efbb ){_fc .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_baad ,len (_efbb ));return nil ,_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_fc .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_efbb ),_efbb );_bfdcf :=_acf .NewBuffer (nil );for _afdg :=0;_afdg < _eff ;_afdg ++{_edda :=_efbb [_baad *_afdg :_baad *(_afdg +1)];for _bded :=_ceg .Colors ;_bded < _baad ;_bded ++{_edda [_bded ]+=_edda [_bded -_ceg .Colors ];};_bfdcf .Write (_edda );};_afaf :=_bfdcf .Bytes ();_fc .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_afaf ),_afaf );return _afaf ,nil ;}else if _ceg .Predictor >=10&&_ceg .Predictor <=15{_fc .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_abge :=int (_ceg .Columns *_ceg .Colors +1);_gefc :=len (_efbb )/_abge ;if len (_efbb )%_abge !=0{return nil ,_ad .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_efbb ),_abge );};if _abge > len (_efbb ){_fc .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_abge ,len (_efbb ));return nil ,_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_bddd :=_acf .NewBuffer (nil );_fc .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_ceg .Columns );_fc .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_efbb ),_abge ,_gefc );_bfgc :=make ([]byte ,_abge );for _ece :=0;_ece < _abge ;_ece ++{_bfgc [_ece ]=0;};_dccd :=_ceg .Colors ;for _beda :=0;_beda < _gefc ;_beda ++{_afe :=_efbb [_abge *_beda :_abge *(_beda +1)];_daee :=_afe [0];switch _daee {case _cfgd :case _fadg :for _bcgb :=1+_dccd ;_bcgb < _abge ;_bcgb ++{_afe [_bcgb ]+=_afe [_bcgb -_dccd ];};case _ebcf :for _eecf :=1;_eecf < _abge ;_eecf ++{_afe [_eecf ]+=_bfgc [_eecf ];};case _bfcb :for _bdcc :=1;_bdcc < _dccd +1;_bdcc ++{_afe [_bdcc ]+=_bfgc [_bdcc ]/2;};for _eddf :=_dccd +1;_eddf < _abge ;_eddf ++{_afe [_eddf ]+=byte ((int (_afe [_eddf -_dccd ])+int (_bfgc [_eddf ]))/2);};case _dfeb :for _afag :=1;_afag < _abge ;_afag ++{var _egc ,_fgc ,_eed byte ;_fgc =_bfgc [_afag ];if _afag >=_dccd +1{_egc =_afe [_afag -_dccd ];_eed =_bfgc [_afag -_dccd ];};_afe [_afag ]+=_dgaa (_egc ,_fgc ,_eed );};default:_fc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029\u0020\u0040\u0072o\u0077\u0020\u0025\u0064",_daee ,_beda );return nil ,_ad .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_daee );};copy (_bfgc ,_afe );_bddd .Write (_afe [1:]);};_ceecf :=_bddd .Bytes ();return _ceecf ,nil ;}else {_fc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_ceg .Predictor );return nil ,_ad .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_ceg .Predictor );};};return _efbb ,nil ;};func _fddd (_ceeb *PdfObjectStream )(*MultiEncoder ,error ){_dcf :=NewMultiEncoder ();_edcf :=_ceeb .PdfObjectDictionary ;if _edcf ==nil {return _dcf ,nil ;};var _dgfd *PdfObjectDictionary ;var _ddc []PdfObject ;_cbgf :=_edcf .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _cbgf !=nil {_bgag ,_bfac :=_cbgf .(*PdfObjectDictionary );if _bfac {_dgfd =_bgag ;};_gedf ,_bcda :=_cbgf .(*PdfObjectArray );if _bcda {for _ ,_acbfe :=range _gedf .Elements (){_acbfe =TraceToDirectObject (_acbfe );if _eacb ,_abbf :=_acbfe .(*PdfObjectDictionary );_abbf {_ddc =append (_ddc ,_eacb );}else {_ddc =append (_ddc ,MakeDict ());};};};};_cbgf =_edcf .Get ("\u0046\u0069\u006c\u0074\u0065\u0072");if _cbgf ==nil {return nil ,_ad .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u006d\u0069s\u0073\u0069\u006e\u0067");};_ddgg ,_fcea :=_cbgf .(*PdfObjectArray );if !_fcea {return nil ,_ad .Errorf ("m\u0075\u006c\u0074\u0069\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0063\u0061\u006e\u0020\u006f\u006el\u0079\u0020\u0062\u0065\u0020\u006d\u0061\u0064\u0065\u0020fr\u006f\u006d\u0020a\u0072r\u0061\u0079");};for _aeag ,_bgff :=range _ddgg .Elements (){_cbga ,_afff :=_bgff .(*PdfObjectName );if !_afff {return nil ,_ad .Errorf ("\u006d\u0075l\u0074\u0069\u0020\u0066i\u006c\u0074e\u0072\u0020\u0061\u0072\u0072\u0061\u0079\u0020e\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u006e\u006f\u0074\u0020\u0061 \u006e\u0061\u006d\u0065");};var _beeec PdfObject ;if _dgfd !=nil {_beeec =_dgfd ;}else {if len (_ddc )> 0{if _aeag >=len (_ddc ){return nil ,_ad .Errorf ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0073\u0020\u0069\u006e\u0020d\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006d\u0073\u0020a\u0072\u0072\u0061\u0079");};_beeec =_ddc [_aeag ];};};var _dfa *PdfObjectDictionary ;if _faag ,_bgacc :=_beeec .(*PdfObjectDictionary );_bgacc {_dfa =_faag ;};_fc .Log .Trace ("\u004e\u0065\u0078t \u006e\u0061\u006d\u0065\u003a\u0020\u0025\u0073\u002c \u0064p\u003a \u0025v\u002c\u0020\u0064\u0050\u0061\u0072\u0061\u006d\u0073\u003a\u0020\u0025\u0076",*_cbga ,_beeec ,_dfa );if *_cbga ==StreamEncodingFilterNameFlate {_eabf ,_bcfa :=_bgfd (_ceeb ,_dfa );if _bcfa !=nil {return nil ,_bcfa ;};_dcf .AddEncoder (_eabf );}else if *_cbga ==StreamEncodingFilterNameLZW {_egeg ,_gfaa :=_cgae (_ceeb ,_dfa );if _gfaa !=nil {return nil ,_gfaa ;};_dcf .AddEncoder (_egeg );}else if *_cbga ==StreamEncodingFilterNameASCIIHex {_bdggf :=NewASCIIHexEncoder ();_dcf .AddEncoder (_bdggf );}else if *_cbga ==StreamEncodingFilterNameASCII85 {_bedb :=NewASCII85Encoder ();_dcf .AddEncoder (_bedb );}else if *_cbga ==StreamEncodingFilterNameDCT {_edg ,_faeb :=_bgfg (_ceeb ,_dcf );if _faeb !=nil {return nil ,_faeb ;};_dcf .AddEncoder (_edg );_fc .Log .Trace ("A\u0064d\u0065\u0064\u0020\u0044\u0043\u0054\u0020\u0065n\u0063\u006f\u0064\u0065r.\u002e\u002e");_fc .Log .Trace ("\u004du\u006ct\u0069\u0020\u0065\u006e\u0063o\u0064\u0065r\u003a\u0020\u0025\u0023\u0076",_dcf );}else {_fc .Log .Error ("U\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0066\u0069l\u0074\u0065\u0072\u0020\u0025\u0073",*_cbga );return nil ,_ad .Errorf ("\u0069\u006eva\u006c\u0069\u0064 \u0066\u0069\u006c\u0074er \u0069n \u006d\u0075\u006c\u0074\u0069\u0020\u0066il\u0074\u0065\u0072\u0020\u0061\u0072\u0072a\u0079");};};return _dcf ,nil ;};

// IsDelimiter checks if a character represents a delimiter.
func IsDelimiter (c byte )bool {return c =='('||c ==')'||c =='<'||c =='>'||c =='['||c ==']'||c =='{'||c =='}'||c =='/'||c =='%';};func (_dcga *PdfCrypt )generateParams (_ffc ,_egb []byte )error {_fgd :=_dcga .securityHandler ();_cedc ,_bbba :=_fgd .GenerateParams (&_dcga ._ec ,_egb ,_ffc );if _bbba !=nil {return _bbba ;};_dcga ._bgb =_cedc ;return nil ;};

// WriteString outputs the object as it is to be written to file.
func (_faaab *PdfObjectDictionary )WriteString ()string {var _aaee _bcb .Builder ;_aaee .WriteString ("\u003c\u003c");for _ ,_aacf :=range _faaab ._baed {_ccaff :=_faaab ._baca [_aacf ];_aaee .WriteString (_aacf .WriteString ());_aaee .WriteString ("\u0020");_aaee .WriteString (_ccaff .WriteString ());};_aaee .WriteString ("\u003e\u003e");return _aaee .String ();};

// String returns a string describing `d`.
func (_aeabe *PdfObjectDictionary )String ()string {var _eabd _bcb .Builder ;_eabd .WriteString ("\u0044\u0069\u0063t\u0028");for _ ,_eae :=range _aeabe ._baed {_ebec :=_aeabe ._baca [_eae ];_eabd .WriteString ("\u0022"+_eae .String ()+"\u0022\u003a\u0020");_eabd .WriteString (_ebec .String ());_eabd .WriteString ("\u002c\u0020");};_eabd .WriteString ("\u0029");return _eabd .String ();};

// GetDict returns the *PdfObjectDictionary represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetDict (obj PdfObject )(_ggfdf *PdfObjectDictionary ,_dddbe bool ){_ggfdf ,_dddbe =TraceToDirectObject (obj ).(*PdfObjectDictionary );return _ggfdf ,_dddbe ;};

// UpdateParams updates the parameter values of the encoder.
func (_daeea *RunLengthEncoder )UpdateParams (params *PdfObjectDictionary ){};

// WriteString outputs the object as it is to be written to file.
func (_effgc *PdfObjectName )WriteString ()string {var _abga _acf .Buffer ;if len (*_effgc )> 127{_fc .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u004e\u0061\u006d\u0065\u0020t\u006fo\u0020l\u006f\u006e\u0067\u0020\u0028\u0025\u0073)",*_effgc );};_abga .WriteString ("\u002f");for _fegca :=0;_fegca < len (*_effgc );_fegca ++{_bgde :=(*_effgc )[_fegca ];if !IsPrintable (_bgde )||_bgde =='#'||IsDelimiter (_bgde ){_abga .WriteString (_ad .Sprintf ("\u0023\u0025\u002e2\u0078",_bgde ));}else {_abga .WriteByte (_bgde );};};return _abga .String ();};

// GetIndirect returns the *PdfIndirectObject represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetIndirect (obj PdfObject )(_bead *PdfIndirectObject ,_egfb bool ){obj =ResolveReference (obj );_bead ,_egfb =obj .(*PdfIndirectObject );return _bead ,_egfb ;};

// String returns a string describing `array`.
func (_edga *PdfObjectArray )String ()string {_cdbc :="\u005b";for _fdaf ,_cbb :=range _edga .Elements (){_cdbc +=_cbb .String ();if _fdaf < (_edga .Len ()-1){_cdbc +="\u002c\u0020";};};_cdbc +="\u005d";return _cdbc ;};

// Str returns the string value of the PdfObjectString. Defined in addition to String() function to clarify that
// this function returns the underlying string directly, whereas the String function technically could include
// debug info.
func (_bddb *PdfObjectString )Str ()string {return _bddb ._ddeab };

// GetFloat returns the *PdfObjectFloat represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetFloat (obj PdfObject )(_befe *PdfObjectFloat ,_ccbde bool ){_befe ,_ccbde =TraceToDirectObject (obj ).(*PdfObjectFloat );return _befe ,_ccbde ;};var _gcfg =_e .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064+\u0029\u005c\u0073\u002b\u0028\u005b\u006e\u0066\u005d\u0029\\\u0073\u002a\u0024");func (_aabfc *PdfParser )seekToEOFMarker (_badd int64 )error {var _dcgg int64 ;var _fagfd int64 =2048;for _dcgg < _badd -4{if _badd <=(_fagfd +_dcgg ){_fagfd =_badd -_dcgg ;};_ ,_eebb :=_aabfc ._ffgb .Seek (-_dcgg -_fagfd ,_de .SeekEnd );if _eebb !=nil {return _eebb ;};_dffa :=make ([]byte ,_fagfd );_aabfc ._ffgb .Read (_dffa );_fc .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0045\u004f\u0046 \u006da\u0072\u006b\u0065\u0072\u003a\u0020\u0022%\u0073\u0022",string (_dffa ));_degdc :=_ebdge .FindAllStringIndex (string (_dffa ),-1);if _degdc !=nil {_fggg :=_degdc [len (_degdc )-1];_fc .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_degdc );_aabfc ._ffgb .Seek (-_dcgg -_fagfd +int64 (_fggg [0]),_de .SeekEnd );return nil ;};_fc .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");_dcgg +=_fagfd -4;};_fc .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006be\u0072 \u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u002e");return _d .New ("\u0045\u004f\u0046\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};

// Append appends PdfObject(s) to the streams.
func (_egfc *PdfObjectStreams )Append (objects ...PdfObject ){if _egfc ==nil {_fc .Log .Debug ("\u0057\u0061\u0072\u006e\u0020-\u0020\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0020\u0074\u006f\u0020\u0061p\u0070\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0073");return ;};if _egfc ._fbg ==nil {_egfc ._fbg =[]PdfObject {};};for _ ,_ccdc :=range objects {_egfc ._fbg =append (_egfc ._fbg ,_ccdc );};};

// ASCIIHexEncoder implements ASCII hex encoder/decoder.
type ASCIIHexEncoder struct{};

// DecodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_cffd *RawEncoder )DecodeBytes (encoded []byte )([]byte ,error ){return encoded ,nil };

// FlateEncoder represents Flate encoding.
type FlateEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Rows int ;Colors int ;_aba *_df .ImageBase ;};

// GetFilterName returns the name of the encoding filter.
func (_egg *ASCII85Encoder )GetFilterName ()string {return StreamEncodingFilterNameASCII85 };

// PdfObjectReference represents the primitive PDF reference object.
type PdfObjectReference struct{_ddaa *PdfParser ;ObjectNumber int64 ;GenerationNumber int64 ;};

// PdfCryptNewDecrypt makes the document crypt handler based on the encryption dictionary
// and trailer dictionary. Returns an error on failure to process.
func PdfCryptNewDecrypt (parser *PdfParser ,ed ,trailer *PdfObjectDictionary )(*PdfCrypt ,error ){_cbe :=&PdfCrypt {_bcg :false ,_fdg :make (map[PdfObject ]bool ),_ba :make (map[PdfObject ]bool ),_dggc :make (map[int ]struct{}),_fgbc :parser };_aaf ,_cbfa :=ed .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectName );if !_cbfa {_fc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0043\u0072\u0079\u0070\u0074 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061r\u0079 \u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u0066\u0069\u0065\u006c\u0064\u0021");return _cbe ,_d .New ("r\u0065\u0071\u0075\u0069\u0072\u0065d\u0020\u0063\u0072\u0079\u0070\u0074 \u0066\u0069\u0065\u006c\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u006d\u0069\u0073\u0073\u0069n\u0067");};if *_aaf !="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"{_fc .Log .Debug ("\u0045\u0052R\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020(%\u0073\u0029",*_aaf );return _cbe ,_d .New ("\u0075n\u0073u\u0070\u0070\u006f\u0072\u0074e\u0064\u0020F\u0069\u006c\u0074\u0065\u0072");};_cbe ._dbb .Filter =string (*_aaf );if _deg ,_bfc :=ed .Get ("\u0053u\u0062\u0046\u0069\u006c\u0074\u0065r").(*PdfObjectString );_bfc {_cbe ._dbb .SubFilter =_deg .Str ();_fc .Log .Debug ("\u0055s\u0069n\u0067\u0020\u0073\u0075\u0062f\u0069\u006ct\u0065\u0072\u0020\u0025\u0073",_deg );};if L ,_ddd :=ed .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );_ddd {if (*L %8)!=0{_fc .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0049\u006ev\u0061\u006c\u0069\u0064\u0020\u0065\u006ec\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006c\u0065\u006e\u0067\u0074\u0068");return _cbe ,_d .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0065\u006e\u0063\u0072y\u0070t\u0069o\u006e\u0020\u006c\u0065\u006e\u0067\u0074h");};_cbe ._dbb .Length =int (*L );}else {_cbe ._dbb .Length =40;};_cbe ._dbb .V =0;if _beac ,_baf :=ed .Get ("\u0056").(*PdfObjectInteger );_baf {V :=int (*_beac );_cbe ._dbb .V =V ;if V >=1&&V <=2{_cbe ._fgb =_cca (_cbe ._dbb .Length );}else if V >=4&&V <=5{if _cfdc :=_cbe .loadCryptFilters (ed );_cfdc !=nil {return _cbe ,_cfdc ;};}else {_fc .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0061lg\u006f\u0020\u0056 \u003d \u0025\u0064",V );return _cbe ,_d .New ("u\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d");};};if _ebdg :=_bdc (&_cbe ._ec ,ed );_ebdg !=nil {return _cbe ,_ebdg ;};_cfa :="";if _cec ,_cag :=trailer .Get ("\u0049\u0044").(*PdfObjectArray );_cag &&_cec .Len ()>=1{_aeaa ,_dbg :=GetString (_cec .Get (0));if !_dbg {return _cbe ,_d .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0074r\u0061\u0069l\u0065\u0072\u0020\u0049\u0044");};_cfa =_aeaa .Str ();}else {_fc .Log .Debug ("\u0054\u0072ai\u006c\u0065\u0072 \u0049\u0044\u0020\u0061rra\u0079 m\u0069\u0073\u0073\u0069\u006e\u0067\u0020or\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0021");};_cbe ._eeef =_cfa ;return _cbe ,nil ;};

// GetBool returns the *PdfObjectBool object that is represented by a PdfObject directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetBool (obj PdfObject )(_cagdd *PdfObjectBool ,_cggd bool ){_cagdd ,_cggd =TraceToDirectObject (obj ).(*PdfObjectBool );return _cagdd ,_cggd ;};func (_gbca *PdfParser )resolveReference (_bcag *PdfObjectReference )(PdfObject ,bool ,error ){_egdd ,_dbbdg :=_gbca .ObjCache [int (_bcag .ObjectNumber )];if _dbbdg {return _egdd ,true ,nil ;};_eadb ,_ecbad :=_gbca .LookupByReference (*_bcag );if _ecbad !=nil {return nil ,false ,_ecbad ;};_gbca .ObjCache [int (_bcag .ObjectNumber )]=_eadb ;return _eadb ,false ,nil ;};

// String returns a string describing `streams`.
func (_ebea *PdfObjectStreams )String ()string {return _ad .Sprintf ("\u004f\u0062j\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0025\u0064",_ebea .ObjectNumber );};

// NewMultiEncoder returns a new instance of MultiEncoder.
func NewMultiEncoder ()*MultiEncoder {_bgac :=MultiEncoder {};_bgac ._deeb =[]StreamEncoder {};return &_bgac ;};

// Get returns the i-th element of the array or nil if out of bounds (by index).
func (_geeg *PdfObjectArray )Get (i int )PdfObject {if _geeg ==nil ||i >=len (_geeg ._fbbf )||i < 0{return nil ;};return _geeg ._fbbf [i ];};

// Encrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_ccd *PdfCrypt )Encrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _ccd .isEncrypted (obj ){return nil ;};switch _bcd :=obj .(type ){case *PdfIndirectObject :_ccd ._ba [_bcd ]=true ;_fc .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_bcd .ObjectNumber ,_bcd .GenerationNumber );_dbdae :=_bcd .ObjectNumber ;_bee :=_bcd .GenerationNumber ;_fcbb :=_ccd .Encrypt (_bcd .PdfObject ,_dbdae ,_bee );if _fcbb !=nil {return _fcbb ;};return nil ;case *PdfObjectStream :_ccd ._ba [_bcd ]=true ;_beacf :=_bcd .PdfObjectDictionary ;if _dfeaa ,_ffda :=_beacf .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_ffda &&*_dfeaa =="\u0058\u0052\u0065\u0066"{return nil ;};_gbbc :=_bcd .ObjectNumber ;_eec :=_bcd .GenerationNumber ;_fc .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_gbbc ,_eec );_addd :=_bbb ;if _ccd ._dbb .V >=4{_addd =_ccd ._efe ;_fc .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_ccd ._efe );if _acc ,_cbac :=_beacf .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );_cbac {if _gbg ,_fbc :=GetName (_acc .Get (0));_fbc {if *_gbg =="\u0043\u0072\u0079p\u0074"{_addd ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _eeg ,_dbad :=_beacf .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );_dbad {if _fcbe ,_ggg :=_eeg .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_ggg {if _ ,_ecb :=_ccd ._fgb [string (*_fcbe )];_ecb {_fc .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_fcbe );_addd =string (*_fcbe );};};};};};};_fc .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_addd );if _addd =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_ceecg :=_ccd .Encrypt (_bcd .PdfObjectDictionary ,_gbbc ,_eec );if _ceecg !=nil {return _ceecg ;};_cgba ,_ceecg :=_ccd .makeKey (_addd ,uint32 (_gbbc ),uint32 (_eec ),_ccd ._bgb );if _ceecg !=nil {return _ceecg ;};_bcd .Stream ,_ceecg =_ccd .encryptBytes (_bcd .Stream ,_addd ,_cgba );if _ceecg !=nil {return _ceecg ;};_beacf .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_bcd .Stream ))));return nil ;case *PdfObjectString :_fc .Log .Trace ("\u0045n\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_eacd :=_bbb ;if _ccd ._dbb .V >=4{_fc .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_ccd ._ebcg );if _ccd ._ebcg =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_eacd =_ccd ._ebcg ;};_cea ,_edd :=_ccd .makeKey (_eacd ,uint32 (parentObjNum ),uint32 (parentGenNum ),_ccd ._bgb );if _edd !=nil {return _edd ;};_cgbfa :=_bcd .Str ();_acbg :=make ([]byte ,len (_cgbfa ));for _ccba :=0;_ccba < len (_cgbfa );_ccba ++{_acbg [_ccba ]=_cgbfa [_ccba ];};_fc .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_acbg ,_acbg );_acbg ,_edd =_ccd .encryptBytes (_acbg ,_eacd ,_cea );if _edd !=nil {return _edd ;};_bcd ._ddeab =string (_acbg );return nil ;case *PdfObjectArray :for _ ,_eebe :=range _bcd .Elements (){_bdeg :=_ccd .Encrypt (_eebe ,parentObjNum ,parentGenNum );if _bdeg !=nil {return _bdeg ;};};return nil ;case *PdfObjectDictionary :_defb :=false ;if _abfg :=_bcd .Get ("\u0054\u0079\u0070\u0065");_abfg !=nil {_faa ,_bcee :=_abfg .(*PdfObjectName );if _bcee &&*_faa =="\u0053\u0069\u0067"{_defb =true ;};};for _ ,_eddb :=range _bcd .Keys (){_ffgd :=_bcd .Get (_eddb );if _defb &&string (_eddb )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;};if string (_eddb )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_eddb )!="\u0050\u0072\u0065\u0076"&&string (_eddb )!="\u004c\u0061\u0073\u0074"{_gbgb :=_ccd .Encrypt (_ffgd ,parentObjNum ,parentGenNum );if _gbgb !=nil {return _gbgb ;};};};return nil ;};return nil ;};

// MakeBool creates a PdfObjectBool from a bool value.
func MakeBool (val bool )*PdfObjectBool {_aad :=PdfObjectBool (val );return &_aad };func (_adee *PdfParser )parseNull ()(PdfObjectNull ,error ){_ ,_acee :=_adee ._edcc .Discard (4);return PdfObjectNull {},_acee ;};

// Len returns the number of elements in the streams.
func (_agcg *PdfObjectStreams )Len ()int {if _agcg ==nil {return 0;};return len (_agcg ._fbg );};

// MakeArrayFromIntegers64 creates an PdfObjectArray from a slice of int64s, where each array element
// is an PdfObjectInteger.
func MakeArrayFromIntegers64 (vals []int64 )*PdfObjectArray {_ggff :=MakeArray ();for _ ,_bcgab :=range vals {_ggff .Append (MakeInteger (_bcgab ));};return _ggff ;};type encryptDict struct{Filter string ;V int ;SubFilter string ;Length int ;StmF string ;StrF string ;EFF string ;CF map[string ]_fa .FilterDict ;};

// JPXEncoder implements JPX encoder/decoder (dummy, for now)
// FIXME: implement
type JPXEncoder struct{};

// UpdateParams updates the parameter values of the encoder.
func (_ffcf *CCITTFaxEncoder )UpdateParams (params *PdfObjectDictionary ){if _gea ,_abcc :=GetNumberAsInt64 (params .Get ("\u004b"));_abcc ==nil {_ffcf .K =int (_gea );};if _bedgg ,_cfac :=GetNumberAsInt64 (params .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));_cfac ==nil {_ffcf .Columns =int (_bedgg );}else if _bedgg ,_cfac =GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));_cfac ==nil {_ffcf .Columns =int (_bedgg );};if _fcdef ,_acfe :=GetNumberAsInt64 (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_acfe ==nil {_ffcf .BlackIs1 =_fcdef > 0;}else {if _decg ,_geece :=GetBoolVal (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_geece {_ffcf .BlackIs1 =_decg ;}else {if _adgf ,_bedf :=GetArray (params .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));_bedf {_edac ,_gcgg :=_adgf .ToIntegerArray ();if _gcgg ==nil {_ffcf .BlackIs1 =_edac [0]==1&&_edac [1]==0;};};};};if _ffdg ,_dcgb :=GetNumberAsInt64 (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_dcgb ==nil {_ffcf .EncodedByteAlign =_ffdg > 0;}else {if _dggb ,_cef :=GetBoolVal (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_cef {_ffcf .EncodedByteAlign =_dggb ;};};if _adeb ,_ecca :=GetNumberAsInt64 (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_ecca ==nil {_ffcf .EndOfLine =_adeb > 0;}else {if _dceac ,_ffb :=GetBoolVal (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_ffb {_ffcf .EndOfLine =_dceac ;};};if _cfgda ,_gbff :=GetNumberAsInt64 (params .Get ("\u0052\u006f\u0077\u0073"));_gbff ==nil {_ffcf .Rows =int (_cfgda );}else if _cfgda ,_gbff =GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));_gbff ==nil {_ffcf .Rows =int (_cfgda );};if _bfbd ,_cfdd :=GetNumberAsInt64 (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_cfdd ==nil {_ffcf .EndOfBlock =_bfbd > 0;}else {if _gfc ,_adeba :=GetBoolVal (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_adeba {_ffcf .EndOfBlock =_gfc ;};};if _afbd ,_gfcg :=GetNumberAsInt64 (params .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));_gfcg !=nil {_ffcf .DamagedRowsBeforeError =int (_afbd );};};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_gdcb *RawEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};

// PdfObjectBool represents the primitive PDF boolean object.
type PdfObjectBool bool ;

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_faaa *RunLengthEncoder )MakeStreamDict ()*PdfObjectDictionary {_aab :=MakeDict ();_aab .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_faaa .GetFilterName ()));return _aab ;};

// WriteString outputs the object as it is to be written to file.
func (_geb *PdfObjectString )WriteString ()string {var _fdad _acf .Buffer ;if _geb ._ddcc {_fccc :=_ed .EncodeToString (_geb .Bytes ());_fdad .WriteString ("\u003c");_fdad .WriteString (_fccc );_fdad .WriteString ("\u003e");return _fdad .String ();};_egbe :=map[byte ]string {'\n':"\u005c\u006e",'\r':"\u005c\u0072",'\t':"\u005c\u0074",'\b':"\u005c\u0062",'\f':"\u005c\u0066",'(':"\u005c\u0028",')':"\u005c\u0029",'\\':"\u005c\u005c"};_fdad .WriteString ("\u0028");for _cged :=0;_cged < len (_geb ._ddeab );_cged ++{_ggda :=_geb ._ddeab [_cged ];if _aadd ,_ddaef :=_egbe [_ggda ];_ddaef {_fdad .WriteString (_aadd );}else {_fdad .WriteByte (_ggda );};};_fdad .WriteString ("\u0029");return _fdad .String ();};

// DecodeBytes decodes a slice of JPX encoded bytes and returns the result.
func (_fceef *JPXEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_fc .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_fceef .GetFilterName ());return encoded ,ErrNoJPXDecode ;};func (_affb *PdfParser )parseHexString ()(*PdfObjectString ,error ){_affb ._edcc .ReadByte ();var _cgbc _acf .Buffer ;for {_aca ,_gaab :=_affb ._edcc .Peek (1);if _gaab !=nil {return MakeString (""),_gaab ;};if _aca [0]=='>'{_affb ._edcc .ReadByte ();break ;};_dgd ,_ :=_affb ._edcc .ReadByte ();if !IsWhiteSpace (_dgd ){_cgbc .WriteByte (_dgd );};};if _cgbc .Len ()%2==1{_cgbc .WriteRune ('0');};_ddbc ,_ :=_ed .DecodeString (_cgbc .String ());return MakeHexString (string (_ddbc )),nil ;};func (_bfdb *PdfParser )parseName ()(PdfObjectName ,error ){var _gcfgd _acf .Buffer ;_bege :=false ;for {_ggfd ,_gdcd :=_bfdb ._edcc .Peek (1);if _gdcd ==_de .EOF {break ;};if _gdcd !=nil {return PdfObjectName (_gcfgd .String ()),_gdcd ;};if !_bege {if _ggfd [0]=='/'{_bege =true ;_bfdb ._edcc .ReadByte ();}else if _ggfd [0]=='%'{_bfdb .readComment ();_bfdb .skipSpaces ();}else {_fc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020N\u0061\u006d\u0065\u0020\u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020w\u0069\u0074\u0068\u0020\u0025\u0073\u0020(\u0025\u0020\u0078\u0029",_ggfd ,_ggfd );return PdfObjectName (_gcfgd .String ()),_ad .Errorf ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u006ea\u006d\u0065:\u0020\u0028\u0025\u0063\u0029",_ggfd [0]);};}else {if IsWhiteSpace (_ggfd [0]){break ;}else if (_ggfd [0]=='/')||(_ggfd [0]=='[')||(_ggfd [0]=='(')||(_ggfd [0]==']')||(_ggfd [0]=='<')||(_ggfd [0]=='>'){break ;}else if _ggfd [0]=='#'{_faebc ,_dagbd :=_bfdb ._edcc .Peek (3);if _dagbd !=nil {return PdfObjectName (_gcfgd .String ()),_dagbd ;};_eecd ,_dagbd :=_ed .DecodeString (string (_faebc [1:3]));if _dagbd !=nil {_fc .Log .Debug ("\u0045\u0052\u0052\u004fR\u003a\u0020\u0049\u006ev\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0066o\u006c\u006co\u0077\u0069\u006e\u0067 \u0027\u0023\u0027\u002c \u0063\u006f\u006e\u0074\u0069n\u0075\u0069\u006e\u0067\u0020\u0075\u0073i\u006e\u0067\u0020\u006c\u0069t\u0065\u0072\u0061\u006c\u0020\u002d\u0020\u004f\u0075t\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074");_gcfgd .WriteByte ('#');_bfdb ._edcc .Discard (1);continue ;};_bfdb ._edcc .Discard (3);_gcfgd .Write (_eecd );}else {_gaae ,_ :=_bfdb ._edcc .ReadByte ();_gcfgd .WriteByte (_gaae );};};};return PdfObjectName (_gcfgd .String ()),nil ;};

// MakeInteger creates a PdfObjectInteger from an int64.
func MakeInteger (val int64 )*PdfObjectInteger {_bdbd :=PdfObjectInteger (val );return &_bdbd };const _bbb ="\u0053\u0074\u0064C\u0046";

// DecodeStream decodes a DCT encoded stream and returns the result as a
// slice of bytes.
func (_bag *DCTEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _bag .DecodeBytes (streamObj .Stream );};

// NewParserFromString is used for testing purposes.
func NewParserFromString (txt string )*PdfParser {_cbfb :=_acf .NewReader ([]byte (txt ));_ggaf :=&PdfParser {ObjCache :objectCache {},_ffgb :_cbfb ,_edcc :_ga .NewReader (_cbfb ),_afgg :int64 (len (txt )),_eggc :map[int64 ]bool {}};_ggaf ._cefa .ObjectMap =make (map[int ]XrefObject );return _ggaf ;};

// GetFilterName returns the name of the encoding filter.
func (_ggc *FlateEncoder )GetFilterName ()string {return StreamEncodingFilterNameFlate };func (_fegd *PdfParser )parseArray ()(*PdfObjectArray ,error ){_gaace :=MakeArray ();_fegd ._edcc .ReadByte ();for {_fegd .skipSpaces ();_gfb ,_eggcf :=_fegd ._edcc .Peek (1);if _eggcf !=nil {return _gaace ,_eggcf ;};if _gfb [0]==']'{_fegd ._edcc .ReadByte ();break ;};_fbbe ,_eggcf :=_fegd .parseObject ();if _eggcf !=nil {return _gaace ,_eggcf ;};_gaace .Append (_fbbe );};return _gaace ,nil ;};func (_gf *PdfParser )lookupByNumberWrapper (_ccc int ,_eee bool )(PdfObject ,bool ,error ){_gge ,_agd ,_bb :=_gf .lookupByNumber (_ccc ,_eee );if _bb !=nil {return nil ,_agd ,_bb ;};if !_agd &&_gf ._fgae !=nil &&!_gf ._fgae .isDecrypted (_gge ){_bd :=_gf ._fgae .Decrypt (_gge ,0,0);if _bd !=nil {return nil ,_agd ,_bd ;};};return _gge ,_agd ,nil ;};

// PdfObjectStreams represents the primitive PDF object streams.
// 7.5.7 Object Streams (page 45).
type PdfObjectStreams struct{PdfObjectReference ;_fbg []PdfObject ;};func (_bbg *PdfCrypt )checkAccessRights (_bdce []byte )(bool ,_db .Permissions ,error ){_agb :=_bbg .securityHandler ();_ebcc ,_bgc ,_aagb :=_agb .Authenticate (&_bbg ._ec ,_bdce );if _aagb !=nil {return false ,0,_aagb ;}else if _bgc ==0||len (_ebcc )==0{return false ,0,nil ;};return true ,_bgc ,nil ;};

// GetXrefTable returns the PDFs xref table.
func (_bdee *PdfParser )GetXrefTable ()XrefTable {return _bdee ._cefa };

// NewDCTEncoder makes a new DCT encoder with default parameters.
func NewDCTEncoder ()*DCTEncoder {_afc :=&DCTEncoder {};_afc .ColorComponents =3;_afc .BitsPerComponent =8;_afc .Quality =DefaultJPEGQuality ;return _afc ;};

// WriteString outputs the object as it is to be written to file.
func (_cgbe *PdfObjectReference )WriteString ()string {var _eedf _bcb .Builder ;_eedf .WriteString (_a .FormatInt (_cgbe .ObjectNumber ,10));_eedf .WriteString ("\u0020");_eedf .WriteString (_a .FormatInt (_cgbe .GenerationNumber ,10));_eedf .WriteString ("\u0020\u0052");return _eedf .String ();};

// DecodeStream decodes a multi-encoded stream by passing it through the
// DecodeStream method of the underlying encoders.
func (_ceab *MultiEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _ceab .DecodeBytes (streamObj .Stream );};

// JBIG2Image is the image structure used by the jbig2 encoder. Its Data must be in a
// 1 bit per component and 1 component per pixel (1bpp). In order to create binary image
// use GoImageToJBIG2 function. If the image data contains the row bytes padding set the HasPadding to true.
type JBIG2Image struct{

// Width and Height defines the image boundaries.
Width ,Height int ;

// Data is the byte slice data for the input image
Data []byte ;

// HasPadding is the attribute that defines if the last byte of the data in the row contains
// 0 bits padding.
HasPadding bool ;};func (_cdecb *PdfParser )repairLocateXref ()(int64 ,error ){_aeaef :=int64 (1000);_cdecb ._ffgb .Seek (-_aeaef ,_ac .SEEK_CUR );_eedg ,_egec :=_cdecb ._ffgb .Seek (0,_ac .SEEK_CUR );if _egec !=nil {return 0,_egec ;};_daeed :=make ([]byte ,_aeaef );_cdecb ._ffgb .Read (_daeed );_bdac :=_defe .FindAllStringIndex (string (_daeed ),-1);if len (_bdac )< 1{_fc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0065\u0070a\u0069\u0072\u003a\u0020\u0078\u0072\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021");return 0,_d .New ("\u0072\u0065\u0070\u0061ir\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064");};_gfdeg :=int64 (_bdac [len (_bdac )-1][0]);_fbfb :=_eedg +_gfdeg ;return _fbfb ,nil ;};

// GetString returns the *PdfObjectString represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetString (obj PdfObject )(_gaeg *PdfObjectString ,_dafc bool ){_gaeg ,_dafc =TraceToDirectObject (obj ).(*PdfObjectString );return _gaeg ,_dafc ;};

// DecodeStream implements ASCII hex decoding.
func (_dabf *ASCIIHexEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _dabf .DecodeBytes (streamObj .Stream );};

// GetFilterName returns the name of the encoding filter.
func (_caf *CCITTFaxEncoder )GetFilterName ()string {return StreamEncodingFilterNameCCITTFax };

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_gcf *RawEncoder )MakeDecodeParams ()PdfObject {return nil };

// IsDecimalDigit checks if the character is a part of a decimal number string.
func IsDecimalDigit (c byte )bool {return '0'<=c &&c <='9'};

// LookupByReference looks up a PdfObject by a reference.
func (_dc *PdfParser )LookupByReference (ref PdfObjectReference )(PdfObject ,error ){_fc .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0075\u0070\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0025\u0073",ref .String ());return _dc .LookupByNumber (int (ref .ObjectNumber ));};

// AddEncoder adds the passed in encoder to the underlying encoder slice.
func (_dggga *MultiEncoder )AddEncoder (encoder StreamEncoder ){_dggga ._deeb =append (_dggga ._deeb ,encoder );};

// EncodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_abffd *RawEncoder )EncodeBytes (data []byte )([]byte ,error ){return data ,nil };

// UpdateParams updates the parameter values of the encoder.
func (_cgda *FlateEncoder )UpdateParams (params *PdfObjectDictionary ){_gde ,_aafd :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _aafd ==nil {_cgda .Predictor =int (_gde );};_eda ,_aafd :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _aafd ==nil {_cgda .BitsPerComponent =int (_eda );};_feg ,_aafd :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _aafd ==nil {_cgda .Columns =int (_feg );};_cfga ,_aafd :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _aafd ==nil {_cgda .Colors =int (_cfga );};};

// Get returns the PdfObject corresponding to the specified key.
// Returns a nil value if the key is not set.
func (_fdcg *PdfObjectDictionary )Get (key PdfObjectName )PdfObject {_cfgdf ,_caeef :=_fdcg ._baca [key ];if !_caeef {return nil ;};return _cfgdf ;};func _bbfa (_bdfg _df .Image )*JBIG2Image {_gecc :=_bdfg .Base ();return &JBIG2Image {Data :_gecc .Data ,Width :_gecc .Width ,Height :_gecc .Height ,HasPadding :true };};

// GetFilterName returns the name of the encoding filter.
func (_bcgbe *RunLengthEncoder )GetFilterName ()string {return StreamEncodingFilterNameRunLength };

// ToIntegerArray returns a slice of all array elements as an int slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_facb *PdfObjectArray )ToIntegerArray ()([]int ,error ){var _aaaf []int ;for _ ,_gcbc :=range _facb .Elements (){if _dfggc ,_acgb :=_gcbc .(*PdfObjectInteger );_acgb {_aaaf =append (_aaaf ,int (*_dfggc ));}else {return nil ,ErrTypeError ;};};return _aaaf ,nil ;};var _gdef =_e .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064\u002b)\u005c\u0073\u002a\u0024");var _bbca =_e .MustCompile ("\u0073t\u0061r\u0074\u0078\u003f\u0072\u0065f\u005c\u0073*\u0028\u005c\u0064\u002b\u0029");func (_bca *PdfCrypt )saveCryptFilters (_ced *PdfObjectDictionary )error {if _bca ._dbb .V < 4{return _d .New ("\u0063\u0061\u006e\u0020\u006f\u006e\u006c\u0079\u0020\u0062\u0065 \u0075\u0073\u0065\u0064\u0020\u0077\u0069\u0074\u0068\u0020V\u003e\u003d\u0034");};_gcb :=MakeDict ();_ced .Set ("\u0043\u0046",_gcb );for _cce ,_gdda :=range _bca ._fgb {if _cce =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{continue ;};_fbf :=_ecfg (_gdda ,"");_gcb .Set (PdfObjectName (_cce ),_fbf );};_ced .Set ("\u0053\u0074\u0072\u0046",MakeName (_bca ._ebcg ));_ced .Set ("\u0053\u0074\u006d\u0046",MakeName (_bca ._efe ));return nil ;};func _dcbfe (_fffb int )int {if _fffb < 0{return -_fffb ;};return _fffb ;};func (_aecg *PdfParser )skipSpaces ()(int ,error ){_abcd :=0;for {_geccec ,_gedg :=_aecg ._edcc .ReadByte ();if _gedg !=nil {return 0,_gedg ;};if IsWhiteSpace (_geccec ){_abcd ++;}else {_aecg ._edcc .UnreadByte ();break ;};};return _abcd ,nil ;};func (_agae *PdfParser )parsePdfVersion ()(int ,int ,error ){var _gcga int64 =20;_dgdf :=make ([]byte ,_gcga );_agae ._ffgb .Seek (0,_ac .SEEK_SET );_agae ._ffgb .Read (_dgdf );var _ffdea error ;var _cfade ,_bbdc int ;if _edbgg :=_faad .FindStringSubmatch (string (_dgdf ));len (_edbgg )< 3{if _cfade ,_bbdc ,_ffdea =_agae .seekPdfVersionTopDown ();_ffdea !=nil {_fc .Log .Debug ("F\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065\u0063\u006f\u0076\u0065\u0072\u0079\u0020\u002d\u0020\u0075n\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0066\u0069nd\u0020\u0076\u0065r\u0073i\u006f\u006e");return 0,0,_ffdea ;};_agae ._ffgb ,_ffdea =_ffdaf (_agae ._ffgb ,_agae .GetFileOffset ()-8);if _ffdea !=nil {return 0,0,_ffdea ;};}else {if _cfade ,_ffdea =_a .Atoi (_edbgg [1]);_ffdea !=nil {return 0,0,_ffdea ;};if _bbdc ,_ffdea =_a .Atoi (_edbgg [2]);_ffdea !=nil {return 0,0,_ffdea ;};_agae .SetFileOffset (0);};_agae ._edcc =_ga .NewReader (_agae ._ffgb );_fc .Log .Debug ("\u0050\u0064\u0066\u0020\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020%\u0064\u002e\u0025\u0064",_cfade ,_bbdc );return _cfade ,_bbdc ,nil ;};

// NewRawEncoder returns a new instace of RawEncoder.
func NewRawEncoder ()*RawEncoder {return &RawEncoder {}};func _abf (_efef *_fa .FilterDict ,_bfg *PdfObjectDictionary )error {if _geec ,_cbg :=_bfg .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_cbg {if _gdg :=string (*_geec );_gdg !="C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"{_fc .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020C\u0046\u0020\u0064ic\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074e\u0072\u0029",_gdg );};};_fdf ,_bcec :=_bfg .Get ("\u0043\u0046\u004d").(*PdfObjectName );if !_bcec {return _ad .Errorf ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0028\u004e\u006f\u006e\u0065\u0029");};_efef .CFM =string (*_fdf );if _dcea ,_cbc :=_bfg .Get ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et").(*PdfObjectName );_cbc {_efef .AuthEvent =_db .AuthEvent (*_dcea );}else {_efef .AuthEvent =_db .EventDocOpen ;};if _ebf ,_cac :=_bfg .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );_cac {_efef .Length =int (*_ebf );};return nil ;};func (_dea *PdfCrypt )encryptBytes (_dbda []byte ,_ade string ,_egf []byte )([]byte ,error ){_fc .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");_dcge ,_agdg :=_dea ._fgb [_ade ];if !_agdg {return nil ,_ad .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_ade );};return _dcge .EncryptBytes (_dbda ,_egf );};

// MakeFloat creates an PdfObjectFloat from a float64.
func MakeFloat (val float64 )*PdfObjectFloat {_gdgc :=PdfObjectFloat (val );return &_gdgc };

// RawEncoder implements Raw encoder/decoder (no encoding, pass through)
type RawEncoder struct{};

// EncodeBytes encodes slice of bytes into JBIG2 encoding format.
// The input 'data' must be an image. In order to Decode it a user is responsible to
// load the codec ('png', 'jpg').
// Returns jbig2 single page encoded document byte slice. The encoder uses DefaultPageSettings
// to encode given image.
func (_facd *JBIG2Encoder )EncodeBytes (data []byte )([]byte ,error ){const _dbbb ="\u004aB\u0049\u0047\u0032\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002eE\u006e\u0063\u006f\u0064\u0065\u0042\u0079\u0074\u0065\u0073";if _facd .ColorComponents !=1||_facd .BitsPerComponent !=1{return nil ,_be .Errorf (_dbbb ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u002e\u0020\u004a\u0042\u0049G\u0032\u0020E\u006e\u0063o\u0064\u0065\u0072\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020bi\u006e\u0061\u0072\u0079\u0020\u0069\u006d\u0061\u0067e\u0073\u0020\u0064\u0061\u0074\u0061");};var (_ceebg *_cb .Bitmap ;_acgd error ;);_faacf :=(_facd .Width *_facd .Height )==len (data );if _faacf {_ceebg ,_acgd =_cb .NewWithUnpaddedData (_facd .Width ,_facd .Height ,data );}else {_ceebg ,_acgd =_cb .NewWithData (_facd .Width ,_facd .Height ,data );};if _acgd !=nil {return nil ,_acgd ;};_ecbg :=_facd .DefaultPageSettings ;if _acgd =_ecbg .Validate ();_acgd !=nil {return nil ,_be .Wrap (_acgd ,_dbbb ,"");};switch _ecbg .Compression {case JB2Generic :if _acgd =_facd ._gfeb .AddGenericPage (_ceebg ,_ecbg .DuplicatedLinesRemoval );_acgd !=nil {return nil ,_be .Wrap (_acgd ,_dbbb ,"");};case JB2SymbolCorrelation :return nil ,_be .Error (_dbbb ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");case JB2SymbolRankHaus :return nil ,_be .Error (_dbbb ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");default:return nil ,_be .Error (_dbbb ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return _facd .Encode ();};

// String returns a string representation of `name`.
func (_cfcf *PdfObjectName )String ()string {return string (*_cfcf )};func _bgffb (_gbcc ,_eacbe ,_bgabb int )error {if _eacbe < 0||_eacbe > _gbcc {return _d .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0061\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");};if _bgabb < _eacbe {return _d .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0073\u006c\u0069\u0063e\u0020i\u006ed\u0065\u0078\u0020\u0062\u0020\u003c\u0020a");};if _bgabb > _gbcc {return _d .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0062\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");};return nil ;};const _cefec =10;

// WriteString outputs the object as it is to be written to file.
func (_eggd *PdfObjectBool )WriteString ()string {if *_eggd {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};

// SetFileOffset sets the file to an offset position and resets buffer.
func (_gbce *PdfParser )SetFileOffset (offset int64 ){if offset < 0{offset =0;};_gbce ._ffgb .Seek (offset ,_de .SeekStart );_gbce ._edcc =_ga .NewReader (_gbce ._ffgb );};

// SetPredictor sets the predictor function.  Specify the number of columns per row.
// The columns indicates the number of samples per row.
// Used for grouping data together for compression.
func (_dde *FlateEncoder )SetPredictor (columns int ){_dde .Predictor =11;_dde .Columns =columns };

// DCTEncoder provides a DCT (JPG) encoding/decoding functionality for images.
type DCTEncoder struct{ColorComponents int ;BitsPerComponent int ;Width int ;Height int ;Quality int ;};

// DecodeStream returns the passed in stream as a slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_gdeg *RawEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return streamObj .Stream ,nil ;};

// GetIntVal returns the int value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetIntVal (obj PdfObject )(_bddbf int ,_dagc bool ){_feed ,_dagc :=TraceToDirectObject (obj ).(*PdfObjectInteger );if _dagc &&_feed !=nil {return int (*_feed ),true ;};return 0,false ;};func _abfc (_abffa *PdfObjectStream ,_gggg *PdfObjectDictionary )(*CCITTFaxEncoder ,error ){_bafe :=NewCCITTFaxEncoder ();_cceb :=_abffa .PdfObjectDictionary ;if _cceb ==nil {return _bafe ,nil ;};if _gggg ==nil {_adbg :=TraceToDirectObject (_cceb .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));if _adbg !=nil {switch _fgag :=_adbg .(type ){case *PdfObjectDictionary :_gggg =_fgag ;break ;case *PdfObjectArray :if _fgag .Len ()==1{if _gbcf ,_cegeg :=GetDict (_fgag .Get (0));_cegeg {_gggg =_gbcf ;};};default:_fc .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_adbg );return nil ,_d .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _gggg ==nil {_fc .Log .Error ("\u0044\u0065c\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064 %\u0023\u0076",_adbg );return nil ,_d .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _eba ,_gcc :=GetNumberAsInt64 (_gggg .Get ("\u004b"));_gcc ==nil {_bafe .K =int (_eba );};if _edc ,_bacd :=GetNumberAsInt64 (_gggg .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));_bacd ==nil {_bafe .Columns =int (_edc );}else {_bafe .Columns =1728;};if _fee ,_eebf :=GetNumberAsInt64 (_gggg .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_eebf ==nil {_bafe .BlackIs1 =_fee > 0;}else {if _eaga ,_ddg :=GetBoolVal (_gggg .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_ddg {_bafe .BlackIs1 =_eaga ;}else {if _efce ,_fed :=GetArray (_gggg .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));_fed {_aeac ,_fgff :=_efce .ToIntegerArray ();if _fgff ==nil {_bafe .BlackIs1 =_aeac [0]==1&&_aeac [1]==0;};};};};if _ecaa ,_ffcc :=GetNumberAsInt64 (_gggg .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_ffcc ==nil {_bafe .EncodedByteAlign =_ecaa > 0;}else {if _gdb ,_cece :=GetBoolVal (_gggg .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_cece {_bafe .EncodedByteAlign =_gdb ;};};if _ccaf ,_cggf :=GetNumberAsInt64 (_gggg .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_cggf ==nil {_bafe .EndOfLine =_ccaf > 0;}else {if _ffgc ,_ggcc :=GetBoolVal (_gggg .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_ggcc {_bafe .EndOfLine =_ffgc ;};};if _ffded ,_cecb :=GetNumberAsInt64 (_gggg .Get ("\u0052\u006f\u0077\u0073"));_cecb ==nil {_bafe .Rows =int (_ffded );};_bafe .EndOfBlock =true ;if _agee ,_dfga :=GetNumberAsInt64 (_gggg .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_dfga ==nil {_bafe .EndOfBlock =_agee > 0;}else {if _ebab ,_ggag :=GetBoolVal (_gggg .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_ggag {_bafe .EndOfBlock =_ebab ;};};if _efdb ,_eabe :=GetNumberAsInt64 (_gggg .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));_eabe !=nil {_bafe .DamagedRowsBeforeError =int (_efdb );};_fc .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_gggg .String ());return _bafe ,nil ;};func _aafa (_fbdd string )(int ,int ,error ){_edaff :=_adcf .FindStringSubmatch (_fbdd );if len (_edaff )< 3{return 0,0,_d .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");};_fgaee ,_ :=_a .Atoi (_edaff [1]);_fgdce ,_ :=_a .Atoi (_edaff [2]);return _fgaee ,_fgdce ,nil ;};

// JBIG2CompressionType defines the enum compression type used by the JBIG2Encoder.
type JBIG2CompressionType int ;

// MakeStreamDict make a new instance of an encoding dictionary for a stream object.
func (_efae *ASCII85Encoder )MakeStreamDict ()*PdfObjectDictionary {_edafb :=MakeDict ();_edafb .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_efae .GetFilterName ()));return _edafb ;};func _dbaf (_cfe *PdfObjectStream ,_gggf *PdfObjectDictionary )(*RunLengthEncoder ,error ){return NewRunLengthEncoder (),nil ;};const _dbge =32<<(^uint (0)>>63);

// MakeEncodedString creates a PdfObjectString with encoded content, which can be either
// UTF-16BE or PDFDocEncoding depending on whether `utf16BE` is true or false respectively.
func MakeEncodedString (s string ,utf16BE bool )*PdfObjectString {if utf16BE {var _dbec _acf .Buffer ;_dbec .Write ([]byte {0xFE,0xFF});_dbec .WriteString (_gb .StringToUTF16 (s ));return &PdfObjectString {_ddeab :_dbec .String (),_ddcc :true };};return &PdfObjectString {_ddeab :string (_gb .StringToPDFDocEncoding (s )),_ddcc :false };};

// NewFlateEncoder makes a new flate encoder with default parameters, predictor 1 and bits per component 8.
func NewFlateEncoder ()*FlateEncoder {_gaec :=&FlateEncoder {};_gaec .Predictor =1;_gaec .BitsPerComponent =8;_gaec .Colors =1;_gaec .Columns =1;return _gaec ;};

// XrefObject defines a cross reference entry which is a map between object number (with generation number) and the
// location of the actual object, either as a file offset (xref table entry), or as a location within an xref
// stream object (xref object stream).
type XrefObject struct{XType xrefType ;ObjectNumber int ;Generation int ;

// For normal xrefs (defined by OFFSET)
Offset int64 ;

// For xrefs to object streams.
OsObjNumber int ;OsObjIndex int ;};

// EncodeBytes encodes the passed in slice of bytes by passing it through the
// EncodeBytes method of the underlying encoders.
func (_dcfd *MultiEncoder )EncodeBytes (data []byte )([]byte ,error ){_egba :=data ;var _gdbb error ;for _bbec :=len (_dcfd ._deeb )-1;_bbec >=0;_bbec --{_baea :=_dcfd ._deeb [_bbec ];_egba ,_gdbb =_baea .EncodeBytes (_egba );if _gdbb !=nil {return nil ,_gdbb ;};};return _egba ,nil ;};

// TraceToDirectObject traces a PdfObject to a direct object.  For example direct objects contained
// in indirect objects (can be double referenced even).
func TraceToDirectObject (obj PdfObject )PdfObject {if _dfcd ,_bbbf :=obj .(*PdfObjectReference );_bbbf {obj =_dfcd .Resolve ();};_ggfdc ,_adae :=obj .(*PdfIndirectObject );_aacg :=0;for _adae {obj =_ggfdc .PdfObject ;_ggfdc ,_adae =GetIndirect (obj );_aacg ++;if _aacg > _cefec {_fc .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0072\u0061\u0063\u0065\u0020\u0064\u0065p\u0074\u0068\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u0062\u0065\u0079\u006fn\u0064\u0020\u0025\u0064\u0020\u002d\u0020\u006e\u006f\u0074\u0020\u0067oi\u006e\u0067\u0020\u0064\u0065\u0065\u0070\u0065\u0072\u0021",_cefec );return nil ;};};return obj ;};

// NewCCITTFaxEncoder makes a new CCITTFax encoder.
func NewCCITTFaxEncoder ()*CCITTFaxEncoder {return &CCITTFaxEncoder {Columns :1728,EndOfBlock :true }};

// GetFilterName returns the name of the encoding filter.
func (_cecf *JPXEncoder )GetFilterName ()string {return StreamEncodingFilterNameJPX };func _ecfg (_dcc _fa .Filter ,_fff _db .AuthEvent )*PdfObjectDictionary {if _fff ==""{_fff =_db .EventDocOpen ;};_ffe :=MakeDict ();_ffe .Set ("\u0054\u0079\u0070\u0065",MakeName ("C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"));_ffe .Set ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et",MakeName (string (_fff )));_ffe .Set ("\u0043\u0046\u004d",MakeName (_dcc .Name ()));_ffe .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_dcc .KeyLength ())));return _ffe ;};

// GetParser returns the parser for lazy-loading or compare references.
func (_adfg *PdfObjectReference )GetParser ()*PdfParser {return _adfg ._ddaa };

// String returns a string describing `ref`.
func (_fdbd *PdfObjectReference )String ()string {return _ad .Sprintf ("\u0052\u0065\u0066\u0028\u0025\u0064\u0020\u0025\u0064\u0029",_fdbd .ObjectNumber ,_fdbd .GenerationNumber );};var _faad =_e .MustCompile ("\u0025P\u0044F\u002d\u0028\u005c\u0064\u0029\u005c\u002e\u0028\u005c\u0064\u0029");

// RunLengthEncoder represents Run length encoding.
type RunLengthEncoder struct{};

// UpdateParams updates the parameter values of the encoder.
func (_ebfg *MultiEncoder )UpdateParams (params *PdfObjectDictionary ){for _ ,_gfce :=range _ebfg ._deeb {_gfce .UpdateParams (params );};};

// PdfIndirectObject represents the primitive PDF indirect object.
type PdfIndirectObject struct{PdfObjectReference ;PdfObject ;};

// MakeStream creates an PdfObjectStream with specified contents and encoding. If encoding is nil, then raw encoding
// will be used (i.e. no encoding applied).
func MakeStream (contents []byte ,encoder StreamEncoder )(*PdfObjectStream ,error ){_dfce :=&PdfObjectStream {};if encoder ==nil {encoder =NewRawEncoder ();};_dfce .PdfObjectDictionary =encoder .MakeStreamDict ();_cbebe ,_fedc :=encoder .EncodeBytes (contents );if _fedc !=nil {return nil ,_fedc ;};_dfce .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_cbebe ))));_dfce .Stream =_cbebe ;return _dfce ,nil ;};

// JBIG2Encoder implements both jbig2 encoder and the decoder. The encoder allows to encode
// provided images (best used document scans) in multiple way. By default it uses single page generic
// encoder. It allows to store lossless data as a single segment.
// In order to store multiple image pages use the 'FileMode' which allows to store more pages within single jbig2 document.
// WIP: In order to obtain better compression results the encoder would allow to encode the input in a
// lossy or lossless way with a component (symbol) mode. It divides the image into components.
// Then checks if any component is 'similar' to the others and maps them together. The symbol classes are stored
// in the dictionary. Then the encoder creates text regions which uses the related symbol classes to fill it's space.
// The similarity is defined by the 'Threshold' variable (default: 0.95). The less the value is, the more components
// matches to single class, thus the compression is better, but the result might become lossy.
type JBIG2Encoder struct{

// These values are required to be set for the 'EncodeBytes' method.
// ColorComponents defines the number of color components for provided image.
ColorComponents int ;

// BitsPerComponent is the number of bits that stores per color component
BitsPerComponent int ;

// Width is the width of the image to encode
Width int ;

// Height is the height of the image to encode.
Height int ;_gfeb *_fb .Document ;

// Globals are the JBIG2 global segments.
Globals _fcd .Globals ;

// IsChocolateData defines if the data is encoded such that
// binary data '1' means black and '0' white.
// otherwise the data is called vanilla.
// Naming convention taken from: 'https://en.wikipedia.org/wiki/Binary_image#Interpretation'
IsChocolateData bool ;

// DefaultPageSettings are the settings parameters used by the jbig2 encoder.
DefaultPageSettings JBIG2EncoderSettings ;};

// NewRunLengthEncoder makes a new run length encoder
func NewRunLengthEncoder ()*RunLengthEncoder {return &RunLengthEncoder {}};

// SetIfNotNil sets the dictionary's key -> val mapping entry -IF- val is not nil.
// Note that we take care to perform a type switch.  Otherwise if we would supply a nil value
// of another type, e.g. (PdfObjectArray*)(nil), then it would not be a PdfObject(nil) and thus
// would get set.
func (_effc *PdfObjectDictionary )SetIfNotNil (key PdfObjectName ,val PdfObject ){if val !=nil {switch _egada :=val .(type ){case *PdfObjectName :if _egada !=nil {_effc .Set (key ,val );};case *PdfObjectDictionary :if _egada !=nil {_effc .Set (key ,val );};case *PdfObjectStream :if _egada !=nil {_effc .Set (key ,val );};case *PdfObjectString :if _egada !=nil {_effc .Set (key ,val );};case *PdfObjectNull :if _egada !=nil {_effc .Set (key ,val );};case *PdfObjectInteger :if _egada !=nil {_effc .Set (key ,val );};case *PdfObjectArray :if _egada !=nil {_effc .Set (key ,val );};case *PdfObjectBool :if _egada !=nil {_effc .Set (key ,val );};case *PdfObjectFloat :if _egada !=nil {_effc .Set (key ,val );};case *PdfObjectReference :if _egada !=nil {_effc .Set (key ,val );};case *PdfIndirectObject :if _egada !=nil {_effc .Set (key ,val );};default:_fc .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",val );};};};

// FlattenObject returns the contents of `obj`. In other words, `obj` with indirect objects replaced
// by their values.
// The replacements are made recursively to a depth of traceMaxDepth.
// NOTE: Dicts are sorted to make objects with same contents have the same PDF object strings.
func FlattenObject (obj PdfObject )PdfObject {return _bbegc (obj ,0)};

// PdfObjectDictionary represents the primitive PDF dictionary/map object.
type PdfObjectDictionary struct{_baca map[PdfObjectName ]PdfObject ;_baed []PdfObjectName ;_gac *PdfParser ;};func (_eebef *PdfParser )parseXrefTable ()(*PdfObjectDictionary ,error ){var _daed *PdfObjectDictionary ;_gdbaea ,_fcfg :=_eebef .readTextLine ();if _fcfg !=nil {return nil ,_fcfg ;};_fc .Log .Trace ("\u0078\u0072\u0065\u0066 f\u0069\u0072\u0073\u0074\u0020\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_gdbaea );_beafc :=-1;_aefe :=0;_facf :=false ;_fdae :="";for {_eebef .skipSpaces ();_ ,_aeab :=_eebef ._edcc .Peek (1);if _aeab !=nil {return nil ,_aeab ;};_gdbaea ,_aeab =_eebef .readTextLine ();if _aeab !=nil {return nil ,_aeab ;};_fedaf :=_gdef .FindStringSubmatch (_gdbaea );if len (_fedaf )==0{_gfef :=len (_fdae )> 0;_fdae +=_gdbaea +"\u000a";if _gfef {_fedaf =_gdef .FindStringSubmatch (_fdae );};};if len (_fedaf )==3{_cfbg ,_ :=_a .Atoi (_fedaf [1]);_ecee ,_ :=_a .Atoi (_fedaf [2]);_beafc =_cfbg ;_aefe =_ecee ;_facf =true ;_fdae ="";_fc .Log .Trace ("\u0078r\u0065\u0066 \u0073\u0075\u0062s\u0065\u0063\u0074\u0069\u006f\u006e\u003a \u0066\u0069\u0072\u0073\u0074\u0020o\u0062\u006a\u0065\u0063\u0074\u003a\u0020\u0025\u0064\u0020\u006fb\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_beafc ,_aefe );continue ;};_gcd :=_gcfg .FindStringSubmatch (_gdbaea );if len (_gcd )==4{if _facf ==false {_fc .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0058r\u0065\u0066\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u006fr\u006da\u0074\u0021\u000a");return nil ,_d .New ("\u0078\u0072\u0065\u0066 i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072\u006d\u0061\u0074");};_gba ,_ :=_a .ParseInt (_gcd [1],10,64);_acgf ,_ :=_a .Atoi (_gcd [2]);_bfe :=_gcd [3];_fdae ="";if _bcb .ToLower (_bfe )=="\u006e"&&_gba > 1{_ddea ,_bfcg :=_eebef ._cefa .ObjectMap [_beafc ];if !_bfcg ||_acgf > _ddea .Generation {_fegc :=XrefObject {ObjectNumber :_beafc ,XType :XrefTypeTableEntry ,Offset :_gba ,Generation :_acgf };_eebef ._cefa .ObjectMap [_beafc ]=_fegc ;};};_beafc ++;continue ;};if (len (_gdbaea )> 6)&&(_gdbaea [:7]=="\u0074r\u0061\u0069\u006c\u0065\u0072"){_fc .Log .Trace ("\u0046o\u0075n\u0064\u0020\u0074\u0072\u0061i\u006c\u0065r\u0020\u002d\u0020\u0025\u0073",_gdbaea );if len (_gdbaea )> 9{_dagd :=_eebef .GetFileOffset ();_eebef .SetFileOffset (_dagd -int64 (len (_gdbaea ))+7);};_eebef .skipSpaces ();_eebef .skipComments ();_fc .Log .Trace ("R\u0065\u0061\u0064\u0069ng\u0020t\u0072\u0061\u0069\u006c\u0065r\u0020\u0064\u0069\u0063\u0074\u0021");_fc .Log .Trace ("\u0070\u0065\u0065\u006b\u003a\u0020\u0022\u0025\u0073\u0022",_gdbaea );_daed ,_aeab =_eebef .ParseDict ();_fc .Log .Trace ("\u0045O\u0046\u0020\u0072\u0065a\u0064\u0069\u006e\u0067\u0020t\u0072a\u0069l\u0065\u0072\u0020\u0064\u0069\u0063\u0074!");if _aeab !=nil {_fc .Log .Debug ("\u0045\u0072\u0072o\u0072\u0020\u0070\u0061r\u0073\u0069\u006e\u0067\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u0064\u0069\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_aeab );return nil ,_aeab ;};break ;};if _gdbaea =="\u0025\u0025\u0045O\u0046"{_fc .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006e\u0064 \u006f\u0066\u0020\u0066\u0069\u006c\u0065 -\u0020\u0074\u0072\u0061i\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066ou\u006e\u0064 \u002d\u0020\u0065\u0072\u0072\u006f\u0072\u0021");return nil ,_d .New ("\u0065\u006e\u0064 \u006f\u0066\u0020\u0066i\u006c\u0065\u0020\u002d\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};_fc .Log .Trace ("\u0078\u0072\u0065\u0066\u0020\u006d\u006f\u0072\u0065 \u003a\u0020\u0025\u0073",_gdbaea );};_fc .Log .Trace ("\u0045\u004f\u0046 p\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0021");if _eebef ._gegg ==nil {_decc :=XrefTypeTableEntry ;_eebef ._gegg =&_decc ;};return _daed ,nil ;};

// GetAsFloat64Slice returns the array as []float64 slice.
// Returns an error if not entirely numeric (only PdfObjectIntegers, PdfObjectFloats).
func (_fbcbb *PdfObjectArray )GetAsFloat64Slice ()([]float64 ,error ){var _aced []float64 ;for _ ,_gaee :=range _fbcbb .Elements (){_bgda ,_ccbdg :=GetNumberAsFloat (TraceToDirectObject (_gaee ));if _ccbdg !=nil {return nil ,_ad .Errorf ("\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006e\u0075m\u0062\u0065\u0072");};_aced =append (_aced ,_bgda );};return _aced ,nil ;};

// IsFloatDigit checks if a character can be a part of a float number string.
func IsFloatDigit (c byte )bool {return ('0'<=c &&c <='9')||c =='.'};var (ErrUnsupportedEncodingParameters =_d .New ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074\u0065\u0072\u0073");ErrNoCCITTFaxDecode =_d .New ("\u0043\u0043I\u0054\u0054\u0046\u0061\u0078\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");ErrNoJBIG2Decode =_d .New ("\u004a\u0042\u0049\u0047\u0032\u0044\u0065c\u006f\u0064\u0065 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");ErrNoJPXDecode =_d .New ("\u004a\u0050\u0058\u0044\u0065c\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020i\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");ErrNoPdfVersion =_d .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");ErrTypeError =_d .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");ErrRangeError =_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");ErrNotSupported =_d .New ("\u0066\u0065\u0061t\u0075\u0072\u0065\u0020n\u006f\u0074\u0020\u0063\u0075\u0072\u0072e\u006e\u0074\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");ErrNotANumber =_d .New ("\u006e\u006f\u0074 \u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072"););

// GetStringVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetStringVal (obj PdfObject )(_adde string ,_acff bool ){_cfgb ,_acff :=TraceToDirectObject (obj ).(*PdfObjectString );if _acff {return _cfgb .Str (),true ;};return ;};func _ffdaf (_bbecc _de .ReadSeeker ,_fbbb int64 )(*offsetReader ,error ){_dccf :=&offsetReader {_dfda :_bbecc ,_daf :_fbbb };_ ,_afde :=_dccf .Seek (0,_de .SeekStart );return _dccf ,_afde ;};var _ecfff =_e .MustCompile ("\u005c\u0073\u002a\u0078\u0072\u0065\u0066\u005c\u0073\u002a");

// Set sets the PdfObject at index i of the array. An error is returned if the index is outside bounds.
func (_febb *PdfObjectArray )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_febb ._fbbf ){return _d .New ("\u006f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_febb ._fbbf [i ]=obj ;return nil ;};

// MakeNull creates an PdfObjectNull.
func MakeNull ()*PdfObjectNull {_efff :=PdfObjectNull {};return &_efff };

// Set sets the dictionary's key -> val mapping entry. Overwrites if key already set.
func (_abgd *PdfObjectDictionary )Set (key PdfObjectName ,val PdfObject ){_ ,_gagf :=_abgd ._baca [key ];if !_gagf {_abgd ._baed =append (_abgd ._baed ,key );};_abgd ._baca [key ]=val ;};

// String returns a string describing `null`.
func (_dbgfe *PdfObjectNull )String ()string {return "\u006e\u0075\u006c\u006c"};

// ParseDict reads and parses a PDF dictionary object enclosed with '<<' and '>>'
func (_cdac *PdfParser )ParseDict ()(*PdfObjectDictionary ,error ){_fc .Log .Trace ("\u0052\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020D\u0069\u0063\u0074\u0021");_gfba :=MakeDict ();_gfba ._gac =_cdac ;_egdg ,_ :=_cdac ._edcc .ReadByte ();if _egdg !='<'{return nil ,_d .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");};_egdg ,_ =_cdac ._edcc .ReadByte ();if _egdg !='<'{return nil ,_d .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");};for {_cdac .skipSpaces ();_cdac .skipComments ();_ecffb ,_cdda :=_cdac ._edcc .Peek (2);if _cdda !=nil {return nil ,_cdda ;};_fc .Log .Trace ("D\u0069c\u0074\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_ecffb ),string (_ecffb ));if (_ecffb [0]=='>')&&(_ecffb [1]=='>'){_fc .Log .Trace ("\u0045\u004f\u0046\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");_cdac ._edcc .ReadByte ();_cdac ._edcc .ReadByte ();break ;};_fc .Log .Trace ("\u0050a\u0072s\u0065\u0020\u0074\u0068\u0065\u0020\u006e\u0061\u006d\u0065\u0021");_bcaa ,_cdda :=_cdac .parseName ();_fc .Log .Trace ("\u004be\u0079\u003a\u0020\u0025\u0073",_bcaa );if _cdda !=nil {_fc .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0052e\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006ea\u006d\u0065\u0020e\u0072r\u0020\u0025\u0073",_cdda );return nil ,_cdda ;};if len (_bcaa )> 4&&_bcaa [len (_bcaa )-4:]=="\u006e\u0075\u006c\u006c"{_beaf :=_bcaa [0:len (_bcaa )-4];_fc .Log .Debug ("\u0054\u0061\u006b\u0069n\u0067\u0020\u0063\u0061\u0072\u0065\u0020\u006f\u0066\u0020n\u0075l\u006c\u0020\u0062\u0075\u0067\u0020\u0028%\u0073\u0029",_bcaa );_fc .Log .Debug ("\u004e\u0065\u0077\u0020ke\u0079\u0020\u0022\u0025\u0073\u0022\u0020\u003d\u0020\u006e\u0075\u006c\u006c",_beaf );_cdac .skipSpaces ();_fbbeg ,_ :=_cdac ._edcc .Peek (1);if _fbbeg [0]=='/'{_gfba .Set (_beaf ,MakeNull ());continue ;};};_cdac .skipSpaces ();_ccdbc ,_cdda :=_cdac .parseObject ();if _cdda !=nil {return nil ,_cdda ;};_gfba .Set (_bcaa ,_ccdbc );if _fc .Log .IsLogLevel (_fc .LogLevelTrace ){_fc .Log .Trace ("\u0064\u0069\u0063\u0074\u005b\u0025\u0073\u005d\u0020\u003d\u0020\u0025\u0073",_bcaa ,_ccdbc .String ());};};_fc .Log .Trace ("\u0072\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020\u0044\u0069\u0063\u0074\u0021");return _gfba ,nil ;};

// String returns a descriptive information string about the encryption method used.
func (_ggbe *PdfCrypt )String ()string {if _ggbe ==nil {return "";};_fea :=_ggbe ._dbb .Filter +"\u0020\u002d\u0020";if _ggbe ._dbb .V ==0{_fea +="\u0055\u006e\u0064\u006fcu\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0061\u006c\u0067\u006f\u0072\u0069\u0074h\u006d";}else if _ggbe ._dbb .V ==1{_fea +="\u0052\u0043\u0034:\u0020\u0034\u0030\u0020\u0062\u0069\u0074\u0073";}else if _ggbe ._dbb .V ==2{_fea +=_ad .Sprintf ("\u0052\u0043\u0034:\u0020\u0025\u0064\u0020\u0062\u0069\u0074\u0073",_ggbe ._dbb .Length );}else if _ggbe ._dbb .V ==3{_fea +="U\u006e\u0070\u0075\u0062li\u0073h\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d";}else if _ggbe ._dbb .V >=4{_fea +=_ad .Sprintf ("\u0053\u0074r\u0065\u0061\u006d\u0020f\u0069\u006ct\u0065\u0072\u003a\u0020\u0025\u0073\u0020\u002d \u0053\u0074\u0072\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0074\u0065r\u003a\u0020\u0025\u0073",_ggbe ._efe ,_ggbe ._ebcg );_fea +="\u003b\u0020C\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0073\u003a";for _ggdc ,_bfb :=range _ggbe ._fgb {_fea +=_ad .Sprintf ("\u0020\u002d\u0020\u0025\u0073\u003a\u0020\u0025\u0073 \u0028\u0025\u0064\u0029",_ggdc ,_bfb .Name (),_bfb .KeyLength ());};};_fbbc :=_ggbe .GetAccessPermissions ();_fea +=_ad .Sprintf ("\u0020\u002d\u0020\u0025\u0023\u0076",_fbbc );return _fea ;};

// DecodeBytes decodes a slice of Flate encoded bytes and returns the result.
func (_caee *FlateEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_fc .Log .Trace ("\u0046\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065\u0020b\u0079\u0074\u0065\u0073");if len (encoded )==0{_fc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0046\u006c\u0061\u0074\u0065 e\u006ec\u006f\u0064\u0065\u0064\u0020\u0062\u0075\u0066\u0066\u0065\u0072\u002e \u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0062y\u0074\u0065\u0020\u0073\u006c\u0069\u0063\u0065\u002e");return []byte {},nil ;};_gda :=_acf .NewReader (encoded );_gaf ,_fac :=_gg .NewReader (_gda );if _fac !=nil {_fc .Log .Debug ("\u0044e\u0063o\u0064\u0069\u006e\u0067\u0020e\u0072\u0072o\u0072\u0020\u0025\u0076\u000a",_fac );_fc .Log .Debug ("\u0053t\u0072e\u0061\u006d\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (encoded ),encoded );return nil ,_fac ;};defer _gaf .Close ();var _gcg _acf .Buffer ;_gcg .ReadFrom (_gaf );return _gcg .Bytes (),nil ;};

// Bytes returns the PdfObjectString content as a []byte array.
func (_dbbf *PdfObjectString )Bytes ()[]byte {return []byte (_dbbf ._ddeab )};func _bbegc (_dfbe PdfObject ,_fbag int )PdfObject {if _fbag > _cefec {_fc .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_cefec );return MakeNull ();};switch _acda :=_dfbe .(type ){case *PdfIndirectObject :_dfbe =_bbegc ((*_acda ).PdfObject ,_fbag +1);case *PdfObjectArray :for _becg ,_bcgc :=range (*_acda )._fbbf {(*_acda )._fbbf [_becg ]=_bbegc (_bcgc ,_fbag +1);};case *PdfObjectDictionary :for _afgeg ,_adaf :=range (*_acda )._baca {(*_acda )._baca [_afgeg ]=_bbegc (_adaf ,_fbag +1);};_bf .Slice ((*_acda )._baed ,func (_gfcb ,_cggg int )bool {return (*_acda )._baed [_gfcb ]< (*_acda )._baed [_cggg ]});};return _dfbe ;};

// LookupByNumber looks up a PdfObject by object number.  Returns an error on failure.
func (_cff *PdfParser )LookupByNumber (objNumber int )(PdfObject ,error ){_efc ,_ ,_efb :=_cff .lookupByNumberWrapper (objNumber ,true );return _efc ,_efb ;};

// UpdateParams updates the parameter values of the encoder.
// Implements StreamEncoder interface.
func (_ecfc *JBIG2Encoder )UpdateParams (params *PdfObjectDictionary ){_beb ,_edag :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _edag ==nil {_ecfc .BitsPerComponent =int (_beb );};_efga ,_edag :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _edag ==nil {_ecfc .Width =int (_efga );};_cade ,_edag :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _edag ==nil {_ecfc .Height =int (_cade );};_ecff ,_edag :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _edag ==nil {_ecfc .ColorComponents =int (_ecff );};};func _cgae (_eagc *PdfObjectStream ,_eaf *PdfObjectDictionary )(*LZWEncoder ,error ){_gcgd :=NewLZWEncoder ();_eef :=_eagc .PdfObjectDictionary ;if _eef ==nil {return _gcgd ,nil ;};if _eaf ==nil {_fab :=TraceToDirectObject (_eef .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));if _fab !=nil {if _efeb ,_ggab :=_fab .(*PdfObjectDictionary );_ggab {_eaf =_efeb ;}else if _dbdb ,_abfd :=_fab .(*PdfObjectArray );_abfd {if _dbdb .Len ()==1{if _bdega ,_efg :=GetDict (_dbdb .Get (0));_efg {_eaf =_bdega ;};};};if _eaf ==nil {_fc .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_fab );return nil ,_ad .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};};_gaac :=_eef .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");if _gaac !=nil {_dgge ,_bga :=_gaac .(*PdfObjectInteger );if !_bga {_fc .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a \u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065d\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u006e\u0075\u006d\u0065\u0072i\u0063 \u0028\u0025\u0054\u0029",_gaac );return nil ,_ad .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");};if *_dgge !=0&&*_dgge !=1{return nil ,_ad .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0076\u0061\u006c\u0075e\u0020\u0028\u006e\u006f\u0074 \u0030\u0020o\u0072\u0020\u0031\u0029");};_gcgd .EarlyChange =int (*_dgge );}else {_gcgd .EarlyChange =1;};if _eaf ==nil {return _gcgd ,nil ;};_gaac =_eaf .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");if _gaac !=nil {_fggf ,_bgdgf :=_gaac .(*PdfObjectInteger );if !_bgdgf {_fc .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_gaac );return nil ,_ad .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_gcgd .Predictor =int (*_fggf );};_gaac =_eaf .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");if _gaac !=nil {_dge ,_gggb :=_gaac .(*PdfObjectInteger );if !_gggb {_fc .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");return nil ,_ad .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_gcgd .BitsPerComponent =int (*_dge );};if _gcgd .Predictor > 1{_gcgd .Columns =1;_gaac =_eaf .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");if _gaac !=nil {_adbd ,_fbcf :=_gaac .(*PdfObjectInteger );if !_fbcf {return nil ,_ad .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_gcgd .Columns =int (*_adbd );};_gcgd .Colors =1;_gaac =_eaf .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _gaac !=nil {_gbf ,_ggf :=_gaac .(*PdfObjectInteger );if !_ggf {return nil ,_ad .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");};_gcgd .Colors =int (*_gbf );};};_fc .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_eaf .String ());return _gcgd ,nil ;};

// String returns a string describing `stream`.
func (_efbg *PdfObjectStream )String ()string {return _ad .Sprintf ("O\u0062j\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0025\u0064: \u0025\u0073",_efbg .ObjectNumber ,_efbg .PdfObjectDictionary );};

// WriteString outputs the object as it is to be written to file.
func (_ggfe *PdfObjectNull )WriteString ()string {return "\u006e\u0075\u006c\u006c"};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_eaa *LZWEncoder )MakeDecodeParams ()PdfObject {if _eaa .Predictor > 1{_gga :=MakeDict ();_gga .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_eaa .Predictor )));if _eaa .BitsPerComponent !=8{_gga .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_eaa .BitsPerComponent )));};if _eaa .Columns !=1{_gga .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_eaa .Columns )));};if _eaa .Colors !=1{_gga .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_eaa .Colors )));};return _gga ;};return nil ;};

// MakeArrayFromFloats creates an PdfObjectArray from a slice of float64s, where each array element is an
// PdfObjectFloat.
func MakeArrayFromFloats (vals []float64 )*PdfObjectArray {_ffa :=MakeArray ();for _ ,_dfgd :=range vals {_ffa .Append (MakeFloat (_dfgd ));};return _ffa ;};

// EncodeBytes implements support for LZW encoding.  Currently not supporting predictors (raw compressed data only).
// Only supports the Early change = 1 algorithm (compress/lzw) as the other implementation
// does not have a write method.
// TODO: Consider refactoring compress/lzw to allow both.
func (_cbd *LZWEncoder )EncodeBytes (data []byte )([]byte ,error ){if _cbd .Predictor !=1{return nil ,_ad .Errorf ("\u004c\u005aW \u0050\u0072\u0065d\u0069\u0063\u0074\u006fr =\u00201 \u006f\u006e\u006c\u0079\u0020\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0079e\u0074");};if _cbd .EarlyChange ==1{return nil ,_ad .Errorf ("\u004c\u005a\u0057\u0020\u0045\u0061\u0072\u006c\u0079\u0020\u0043\u0068\u0061n\u0067\u0065\u0020\u003d\u0020\u0030 \u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0079\u0065\u0074");};var _gce _acf .Buffer ;_aee :=_gd .NewWriter (&_gce ,_gd .MSB ,8);_aee .Write (data );_aee .Close ();return _gce .Bytes (),nil ;};

// EncodeJBIG2Image encodes 'img' into jbig2 encoded bytes stream, using default encoder settings.
func (_cada *JBIG2Encoder )EncodeJBIG2Image (img *JBIG2Image )([]byte ,error ){const _eaffb ="c\u006f\u0072\u0065\u002eEn\u0063o\u0064\u0065\u004a\u0042\u0049G\u0032\u0049\u006d\u0061\u0067\u0065";if _aaad :=_cada .AddPageImage (img ,&_cada .DefaultPageSettings );_aaad !=nil {return nil ,_be .Wrap (_aaad ,_eaffb ,"");};return _cada .Encode ();};

// GetFloatVal returns the float64 value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetFloatVal (obj PdfObject )(_fgagf float64 ,_eceg bool ){_cgaeba ,_eceg :=TraceToDirectObject (obj ).(*PdfObjectFloat );if _eceg {return float64 (*_cgaeba ),true ;};return 0,false ;};

// DecodeStream decodes a FlateEncoded stream object and give back decoded bytes.
func (_dggg *FlateEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_fc .Log .Trace ("\u0046l\u0061t\u0065\u0044\u0065\u0063\u006fd\u0065\u0020s\u0074\u0072\u0065\u0061\u006d");_fc .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_dggg .Predictor );if _dggg .BitsPerComponent !=8{return nil ,_ad .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003d\u0025\u0064\u0020\u0028\u006f\u006e\u006c\u0079\u0020\u0038\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0029",_dggg .BitsPerComponent );};_cdde ,_ccgb :=_dggg .DecodeBytes (streamObj .Stream );if _ccgb !=nil {return nil ,_ccgb ;};_cdde ,_ccgb =_dggg .postDecodePredict (_cdde );if _ccgb !=nil {return nil ,_ccgb ;};return _dggg .cleanImageData (_cdde );};

// GetString is a helper for Get that returns a string value.
// Returns false if the key is missing or a value is not a string.
func (_debe *PdfObjectDictionary )GetString (key PdfObjectName )(string ,bool ){_gbbda ,_afbde :=_debe ._baca [key ].(*PdfObjectString );if !_afbde {return "",false ;};return _gbbda .Str (),true ;};

// CCITTFaxEncoder implements Group3 and Group4 facsimile (fax) encoder/decoder.
type CCITTFaxEncoder struct{K int ;EndOfLine bool ;EncodedByteAlign bool ;Columns int ;Rows int ;EndOfBlock bool ;BlackIs1 bool ;DamagedRowsBeforeError int ;};

// Append appends PdfObject(s) to the array.
func (_agead *PdfObjectArray )Append (objects ...PdfObject ){if _agead ==nil {_fc .Log .Debug ("\u0057\u0061\u0072\u006e\u0020\u002d\u0020\u0041\u0074\u0074\u0065\u006d\u0070t\u0020\u0074\u006f\u0020\u0061\u0070p\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020a\u0072\u0072\u0061\u0079");return ;};if _agead ._fbbf ==nil {_agead ._fbbf =[]PdfObject {};};for _ ,_fecd :=range objects {_agead ._fbbf =append (_agead ._fbbf ,_fecd );};};

// AddPageImage adds the page with the image 'img' to the encoder context in order to encode it jbig2 document.
// The 'settings' defines what encoding type should be used by the encoder.
func (_dccb *JBIG2Encoder )AddPageImage (img *JBIG2Image ,settings *JBIG2EncoderSettings )(_bgfe error ){const _bfbe ="\u004a\u0042\u0049\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0041\u0064\u0064\u0050\u0061\u0067\u0065\u0049m\u0061\u0067\u0065";if _dccb ==nil {return _be .Error (_bfbe ,"J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u0020\u0069\u0073 n\u0069\u006c");};if settings ==nil {settings =&_dccb .DefaultPageSettings ;};if _dccb ._gfeb ==nil {_dccb ._gfeb =_fb .InitEncodeDocument (settings .FileMode );};if _bgfe =settings .Validate ();_bgfe !=nil {return _be .Wrap (_bgfe ,_bfbe ,"");};_gca ,_bgfe :=img .toBitmap ();if _bgfe !=nil {return _be .Wrap (_bgfe ,_bfbe ,"");};switch settings .Compression {case JB2Generic :if _bgfe =_dccb ._gfeb .AddGenericPage (_gca ,settings .DuplicatedLinesRemoval );_bgfe !=nil {return _be .Wrap (_bgfe ,_bfbe ,"");};case JB2SymbolCorrelation :return _be .Error (_bfbe ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");case JB2SymbolRankHaus :return _be .Error (_bfbe ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");default:return _be .Error (_bfbe ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return nil ;};

// NewParser creates a new parser for a PDF file via ReadSeeker. Loads the cross reference stream and trailer.
// An error is returned on failure.
func NewParser (rs _de .ReadSeeker )(*PdfParser ,error ){_abbfa :=&PdfParser {_ffgb :rs ,ObjCache :make (objectCache ),_eggc :map[int64 ]bool {}};_cacb ,_acaf ,_ggad :=_abbfa .parsePdfVersion ();if _ggad !=nil {_fc .Log .Error ("U\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0076e\u0072\u0073\u0069o\u006e:\u0020\u0025\u0076",_ggad );return nil ,_ggad ;};_abbfa ._ggdd .Major =_cacb ;_abbfa ._ggdd .Minor =_acaf ;if _abbfa ._dgef ,_ggad =_abbfa .loadXrefs ();_ggad !=nil {_fc .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020F\u0061\u0069\u006c\u0065d t\u006f l\u006f\u0061\u0064\u0020\u0078\u0072\u0065f \u0074\u0061\u0062\u006c\u0065\u0021\u0020%\u0073",_ggad );return nil ,_ggad ;};_fc .Log .Trace ("T\u0072\u0061\u0069\u006c\u0065\u0072\u003a\u0020\u0025\u0073",_abbfa ._dgef );if len (_abbfa ._cefa .ObjectMap )==0{return nil ,_ad .Errorf ("\u0065\u006d\u0070\u0074\u0079\u0020\u0058\u0052\u0045\u0046\u0020t\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0049\u006e\u0076a\u006c\u0069\u0064");};return _abbfa ,nil ;};func (_cgeb *JBIG2Encoder )encodeImage (_bedggd _dg .Image )([]byte ,error ){const _dcbe ="e\u006e\u0063\u006f\u0064\u0065\u0049\u006d\u0061\u0067\u0065";_fged ,_bbeec :=GoImageToJBIG2 (_bedggd ,JB2ImageAutoThreshold );if _bbeec !=nil {return nil ,_be .Wrap (_bbeec ,_dcbe ,"\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069m\u0061g\u0065\u0020\u0074\u006f\u0020\u006a\u0062\u0069\u0067\u0032\u0020\u0069\u006d\u0067");};if _bbeec =_cgeb .AddPageImage (_fged ,&_cgeb .DefaultPageSettings );_bbeec !=nil {return nil ,_be .Wrap (_bbeec ,_dcbe ,"");};return _cgeb .Encode ();};

// UpdateParams updates the parameter values of the encoder.
func (_geecc *JPXEncoder )UpdateParams (params *PdfObjectDictionary ){};func (_gedc *JBIG2Image )toBitmap ()(_ede *_cb .Bitmap ,_geda error ){const _fcff ="\u004a\u0042\u0049\u00472I\u006d\u0061\u0067\u0065\u002e\u0074\u006f\u0042\u0069\u0074\u006d\u0061\u0070";if _gedc .Data ==nil {return nil ,_be .Error (_fcff ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");};if _gedc .Width ==0||_gedc .Height ==0{return nil ,_be .Error (_fcff ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");};if _gedc .HasPadding {_ede ,_geda =_cb .NewWithData (_gedc .Width ,_gedc .Height ,_gedc .Data );}else {_ede ,_geda =_cb .NewWithUnpaddedData (_gedc .Width ,_gedc .Height ,_gedc .Data );};if _geda !=nil {return nil ,_be .Wrap (_geda ,_fcff ,"");};return _ede ,nil ;};func _da (_abe PdfObject )(int64 ,int64 ,error ){if _dba ,_gbe :=_abe .(*PdfIndirectObject );_gbe {return _dba .ObjectNumber ,_dba .GenerationNumber ,nil ;};if _bce ,_bcf :=_abe .(*PdfObjectStream );_bcf {return _bce .ObjectNumber ,_bce .GenerationNumber ,nil ;};return 0,0,_d .New ("\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u002f\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062je\u0063\u0074");};

// DecodeStream decodes a LZW encoded stream and returns the result as a
// slice of bytes.
func (_ada *LZWEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_fc .Log .Trace ("\u004c\u005a\u0057 \u0044\u0065\u0063\u006f\u0064\u0069\u006e\u0067");_fc .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_ada .Predictor );_fae ,_ecfd :=_ada .DecodeBytes (streamObj .Stream );if _ecfd !=nil {return nil ,_ecfd ;};_fc .Log .Trace ("\u0020\u0049\u004e\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (streamObj .Stream ),streamObj .Stream );_fc .Log .Trace ("\u004f\u0055\u0054\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (_fae ),_fae );if _ada .Predictor > 1{if _ada .Predictor ==2{_fc .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_ccgg :=int (_ada .Columns )*_ada .Colors ;if _ccgg < 1{return []byte {},nil ;};_defbd :=len (_fae )/_ccgg ;if len (_fae )%_ccgg !=0{_fc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");return nil ,_ad .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_fae ),_ccgg );};if _ccgg %_ada .Colors !=0{return nil ,_ad .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_ccgg ,_ada .Colors );};if _ccgg > len (_fae ){_fc .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_ccgg ,len (_fae ));return nil ,_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_fc .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_fae ),_fae );_abc :=_acf .NewBuffer (nil );for _cda :=0;_cda < _defbd ;_cda ++{_ebgd :=_fae [_ccgg *_cda :_ccgg *(_cda +1)];for _gaba :=_ada .Colors ;_gaba < _ccgg ;_gaba ++{_ebgd [_gaba ]=byte (int (_ebgd [_gaba ]+_ebgd [_gaba -_ada .Colors ])%256);};_abc .Write (_ebgd );};_bba :=_abc .Bytes ();_fc .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_bba ),_bba );return _bba ,nil ;}else if _ada .Predictor >=10&&_ada .Predictor <=15{_fc .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_cdef :=int (_ada .Columns *_ada .Colors +1);if _cdef < 1{return []byte {},nil ;};_fce :=len (_fae )/_cdef ;if len (_fae )%_cdef !=0{return nil ,_ad .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_fae ),_cdef );};if _cdef > len (_fae ){_fc .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_cdef ,len (_fae ));return nil ,_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_dddf :=_acf .NewBuffer (nil );_fc .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_ada .Columns );_fc .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_fae ),_cdef ,_fce );_faea :=make ([]byte ,_cdef );for _dgggf :=0;_dgggf < _cdef ;_dgggf ++{_faea [_dgggf ]=0;};for _cegc :=0;_cegc < _fce ;_cegc ++{_gefe :=_fae [_cdef *_cegc :_cdef *(_cegc +1)];_bdcca :=_gefe [0];switch _bdcca {case 0:case 1:for _bbgc :=2;_bbgc < _cdef ;_bbgc ++{_gefe [_bbgc ]=byte (int (_gefe [_bbgc ]+_gefe [_bbgc -1])%256);};case 2:for _ggbb :=1;_ggbb < _cdef ;_ggbb ++{_gefe [_ggbb ]=byte (int (_gefe [_ggbb ]+_faea [_ggbb ])%256);};default:_fc .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0066i\u006c\u0074\u0065\u0072\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_bdcca );return nil ,_ad .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_bdcca );};for _bae :=0;_bae < _cdef ;_bae ++{_faea [_bae ]=_gefe [_bae ];};_dddf .Write (_gefe [1:]);};_cdf :=_dddf .Bytes ();return _cdf ,nil ;}else {_fc .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_ada .Predictor );return nil ,_ad .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_ada .Predictor );};};return _fae ,nil ;};