//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package core defines and implements the primitive PDF object types in golang, and provides functionality
// for parsing those from a PDF file stream. This includes I/O handling, cross references, repairs, encryption,
// encoding and other core capabilities.
package core ;import (_ac "bufio";_fb "bytes";_ad "compress/lzw";_c "compress/zlib";_bb "crypto/md5";_ec "crypto/rand";_af "encoding/hex";_e "errors";_ce "fmt";_bf "github.com/unidoc/unipdf/v3/common";_afe "github.com/unidoc/unipdf/v3/core/security";_ecf "github.com/unidoc/unipdf/v3/core/security/crypt";_acc "github.com/unidoc/unipdf/v3/internal/ccittfax";_aa "github.com/unidoc/unipdf/v3/internal/imageutil";_eb "github.com/unidoc/unipdf/v3/internal/jbig2";_gb "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_abc "github.com/unidoc/unipdf/v3/internal/jbig2/decoder";_ca "github.com/unidoc/unipdf/v3/internal/jbig2/document";_fg "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_ae "github.com/unidoc/unipdf/v3/internal/strutils";_de "golang.org/x/image/tiff/lzw";_gd "golang.org/x/xerrors";_dd "image";_bg "image/color";_g "image/jpeg";_aba "io";_d "reflect";_dce "regexp";_b "sort";_dc "strconv";_ab "strings";_a "sync";_ed "time";);

// DecodeStream decodes the stream containing CCITTFax encoded image data.
func (_bfa *CCITTFaxEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _bfa .DecodeBytes (streamObj .Stream );};

// DecodeStream decodes RunLengthEncoded stream object and give back decoded bytes.
func (_fgce *RunLengthEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _fgce .DecodeBytes (streamObj .Stream );};

// GetFilterName returns the name of the encoding filter.
func (_bbf *DCTEncoder )GetFilterName ()string {return StreamEncodingFilterNameDCT };func (_bcbe *PdfParser )parseObject ()(PdfObject ,error ){_bf .Log .Trace ("\u0052e\u0061d\u0020\u0064\u0069\u0072\u0065c\u0074\u0020o\u0062\u006a\u0065\u0063\u0074");_bcbe .skipSpaces ();for {_dbge ,_ggaa :=_bcbe ._bdc .Peek (2);if _ggaa !=nil {if _ggaa !=_aba .EOF ||len (_dbge )==0{return nil ,_ggaa ;};if len (_dbge )==1{_dbge =append (_dbge ,' ');};};_bf .Log .Trace ("\u0050e\u0065k\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u003a\u0020\u0025\u0073",string (_dbge ));if _dbge [0]=='/'{_ffgbc ,_babd :=_bcbe .parseName ();_bf .Log .Trace ("\u002d\u003e\u004ea\u006d\u0065\u003a\u0020\u0027\u0025\u0073\u0027",_ffgbc );return &_ffgbc ,_babd ;}else if _dbge [0]=='('{_bf .Log .Trace ("\u002d>\u0053\u0074\u0072\u0069\u006e\u0067!");_ebbd ,_dbegg :=_bcbe .parseString ();return _ebbd ,_dbegg ;}else if _dbge [0]=='['{_bf .Log .Trace ("\u002d\u003e\u0041\u0072\u0072\u0061\u0079\u0021");_bfbb ,_affg :=_bcbe .parseArray ();return _bfbb ,_affg ;}else if (_dbge [0]=='<')&&(_dbge [1]=='<'){_bf .Log .Trace ("\u002d>\u0044\u0069\u0063\u0074\u0021");_edfd ,_bgfb :=_bcbe .ParseDict ();return _edfd ,_bgfb ;}else if _dbge [0]=='<'{_bf .Log .Trace ("\u002d\u003e\u0048\u0065\u0078\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0021");_cddde ,_gda :=_bcbe .parseHexString ();return _cddde ,_gda ;}else if _dbge [0]=='%'{_bcbe .readComment ();_bcbe .skipSpaces ();}else {_bf .Log .Trace ("\u002d\u003eN\u0075\u006d\u0062e\u0072\u0020\u006f\u0072\u0020\u0072\u0065\u0066\u003f");_dbge ,_ =_bcbe ._bdc .Peek (15);_adfg :=string (_dbge );_bf .Log .Trace ("\u0050\u0065\u0065k\u0020\u0073\u0074\u0072\u003a\u0020\u0025\u0073",_adfg );if (len (_adfg )> 3)&&(_adfg [:4]=="\u006e\u0075\u006c\u006c"){_gcafb ,_edad :=_bcbe .parseNull ();return &_gcafb ,_edad ;}else if (len (_adfg )> 4)&&(_adfg [:5]=="\u0066\u0061\u006cs\u0065"){_aafb ,_faec :=_bcbe .parseBool ();return &_aafb ,_faec ;}else if (len (_adfg )> 3)&&(_adfg [:4]=="\u0074\u0072\u0075\u0065"){_dgbb ,_fgcc :=_bcbe .parseBool ();return &_dgbb ,_fgcc ;};_eabe :=_bgba .FindStringSubmatch (_adfg );if len (_eabe )> 1{_dbge ,_ =_bcbe ._bdc .ReadBytes ('R');_bf .Log .Trace ("\u002d\u003e\u0020\u0021\u0052\u0065\u0066\u003a\u0020\u0027\u0025\u0073\u0027",string (_dbge [:]));_ccge ,_bgeg :=_aeeee (string (_dbge ));_ccge ._bcdd =_bcbe ;return &_ccge ,_bgeg ;};_bdcf :=_daae .FindStringSubmatch (_adfg );if len (_bdcf )> 1{_bf .Log .Trace ("\u002d\u003e\u0020\u004e\u0075\u006d\u0062\u0065\u0072\u0021");_fcdg ,_abgba :=_bcbe .parseNumber ();return _fcdg ,_abgba ;};_bdcf =_dgca .FindStringSubmatch (_adfg );if len (_bdcf )> 1{_bf .Log .Trace ("\u002d\u003e\u0020\u0045xp\u006f\u006e\u0065\u006e\u0074\u0069\u0061\u006c\u0020\u004e\u0075\u006d\u0062\u0065r\u0021");_bf .Log .Trace ("\u0025\u0020\u0073",_bdcf );_bgbb ,_cdfgb :=_bcbe .parseNumber ();return _bgbb ,_cdfgb ;};_bf .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020U\u006e\u006b\u006e\u006f\u0077n\u0020(\u0070e\u0065\u006b\u0020\u0022\u0025\u0073\u0022)",_adfg );return nil ,_e .New ("\u006f\u0062\u006a\u0065\u0063t\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020\u0075\u006e\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e");};};};

// MultiEncoder supports serial encoding.
type MultiEncoder struct{_gbag []StreamEncoder };

// DecodeStream decodes a JBIG2 encoded stream and returns the result as a slice of bytes.
func (_eaccg *JBIG2Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _eaccg .DecodeBytes (streamObj .Stream );};

// NewEncoderFromStream creates a StreamEncoder based on the stream's dictionary.
func NewEncoderFromStream (streamObj *PdfObjectStream )(StreamEncoder ,error ){_aeeef :=TraceToDirectObject (streamObj .PdfObjectDictionary .Get ("\u0046\u0069\u006c\u0074\u0065\u0072"));if _aeeef ==nil {return NewRawEncoder (),nil ;};if _ ,_ggbab :=_aeeef .(*PdfObjectNull );_ggbab {return NewRawEncoder (),nil ;};_ebfd ,_dbedf :=_aeeef .(*PdfObjectName );if !_dbedf {_cbaa ,_adbgd :=_aeeef .(*PdfObjectArray );if !_adbgd {return nil ,_ce .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006f\u0072 \u0041\u0072\u0072\u0061\u0079\u0020\u006fb\u006a\u0065\u0063\u0074");};if _cbaa .Len ()==0{return NewRawEncoder (),nil ;};if _cbaa .Len ()!=1{_febff ,_ecfa :=_ffe (streamObj );if _ecfa !=nil {_bf .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0063\u0072\u0065\u0061\u0074\u0069\u006e\u0067\u0020\u006d\u0075\u006c\u0074i\u0020\u0065\u006e\u0063\u006f\u0064\u0065r\u003a\u0020\u0025\u0076",_ecfa );return nil ,_ecfa ;};_bf .Log .Trace ("\u004d\u0075\u006c\u0074\u0069\u0020\u0065\u006e\u0063:\u0020\u0025\u0073\u000a",_febff );return _febff ,nil ;};_aeeef =_cbaa .Get (0);_ebfd ,_adbgd =_aeeef .(*PdfObjectName );if !_adbgd {return nil ,_ce .Errorf ("\u0066\u0069l\u0074\u0065\u0072\u0020a\u0072\u0072a\u0079\u0020\u006d\u0065\u006d\u0062\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006fb\u006a\u0065\u0063\u0074");};};if _agffb ,_gbggg :=_gbgee .Load (_ebfd .String ());_gbggg {return _agffb .(StreamEncoder ),nil ;};switch *_ebfd {case StreamEncodingFilterNameFlate :return _dfba (streamObj ,nil );case StreamEncodingFilterNameLZW :return _agg (streamObj ,nil );case StreamEncodingFilterNameDCT :return _cge (streamObj ,nil );case StreamEncodingFilterNameRunLength :return _gege (streamObj ,nil );case StreamEncodingFilterNameASCIIHex :return NewASCIIHexEncoder (),nil ;case StreamEncodingFilterNameASCII85 ,"\u0041\u0038\u0035":return NewASCII85Encoder (),nil ;case StreamEncodingFilterNameCCITTFax :return _cbg (streamObj ,nil );case StreamEncodingFilterNameJBIG2 :return _ddag (streamObj ,nil );case StreamEncodingFilterNameJPX :return NewJPXEncoder (),nil ;};_bf .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064\u0069\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006fd\u0021");return nil ,_ce .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064i\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006f\u0064\u0020\u0028\u0025\u0073\u0029",*_ebfd );};

// PdfObjectString represents the primitive PDF string object.
type PdfObjectString struct{_gcae string ;_efgcb bool ;};

// PdfCryptNewEncrypt makes the document crypt handler based on a specified crypt filter.
func PdfCryptNewEncrypt (cf _ecf .Filter ,userPass ,ownerPass []byte ,perm _afe .Permissions )(*PdfCrypt ,*EncryptInfo ,error ){_dcaa :=&PdfCrypt {_eecg :make (map[PdfObject ]bool ),_ecb :make (cryptFilters ),_dgd :_afe .StdEncryptDict {P :perm ,EncryptMetadata :true }};var _dde Version ;if cf !=nil {_ffdf :=cf .PDFVersion ();_dde .Major ,_dde .Minor =_ffdf [0],_ffdf [1];V ,R :=cf .HandlerVersion ();_dcaa ._gbe .V =V ;_dcaa ._dgd .R =R ;_dcaa ._gbe .Length =cf .KeyLength ()*8;};const (_cbe =_edd ;);_dcaa ._ecb [_cbe ]=cf ;if _dcaa ._gbe .V >=4{_dcaa ._cbca =_cbe ;_dcaa ._gbba =_cbe ;};_dcee :=_dcaa .newEncryptDict ();_afc :=_bb .Sum ([]byte (_ed .Now ().Format (_ed .RFC850 )));_eee :=string (_afc [:]);_ddef :=make ([]byte ,100);_ec .Read (_ddef );_afc =_bb .Sum (_ddef );_daa :=string (_afc [:]);_bf .Log .Trace ("\u0052\u0061\u006e\u0064\u006f\u006d\u0020\u0062\u003a\u0020\u0025\u0020\u0078",_ddef );_bf .Log .Trace ("\u0047\u0065\u006e\u0020\u0049\u0064\u0020\u0030\u003a\u0020\u0025\u0020\u0078",_eee );_dcaa ._ddc =_eee ;_geb :=_dcaa .generateParams (userPass ,ownerPass );if _geb !=nil {return nil ,nil ,_geb ;};_dbg (&_dcaa ._dgd ,_dcee );if _dcaa ._gbe .V >=4{if _cbb :=_dcaa .saveCryptFilters (_dcee );_cbb !=nil {return nil ,nil ,_cbb ;};};return _dcaa ,&EncryptInfo {Version :_dde ,Encrypt :_dcee ,ID0 :_eee ,ID1 :_daa },nil ;};

// MakeObjectStreams creates an PdfObjectStreams from a list of PdfObjects.
func MakeObjectStreams (objects ...PdfObject )*PdfObjectStreams {return &PdfObjectStreams {_adca :objects };};type objectStreams map[int ]objectStream ;

// String returns a string describing `ref`.
func (_fgeaa *PdfObjectReference )String ()string {return _ce .Sprintf ("\u0052\u0065\u0066\u0028\u0025\u0064\u0020\u0025\u0064\u0029",_fgeaa .ObjectNumber ,_fgeaa .GenerationNumber );};func _aca (_cbbd int )cryptFilters {return cryptFilters {_edd :_ecf .NewFilterV2 (_cbbd )}};

// IsNullObject returns true if `obj` is a PdfObjectNull.
func IsNullObject (obj PdfObject )bool {_ ,_dgcb :=TraceToDirectObject (obj ).(*PdfObjectNull );return _dgcb ;};

// NewRawEncoder returns a new instace of RawEncoder.
func NewRawEncoder ()*RawEncoder {return &RawEncoder {}};type offsetReader struct{_edg _aba .ReadSeeker ;_cec int64 ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_dbf *RunLengthEncoder )MakeStreamDict ()*PdfObjectDictionary {_cedea :=MakeDict ();_cedea .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_dbf .GetFilterName ()));return _cedea ;};

// PdfCryptNewDecrypt makes the document crypt handler based on the encryption dictionary
// and trailer dictionary. Returns an error on failure to process.
func PdfCryptNewDecrypt (parser *PdfParser ,ed ,trailer *PdfObjectDictionary )(*PdfCrypt ,error ){_daf :=&PdfCrypt {_fbc :false ,_fgc :make (map[PdfObject ]bool ),_eecg :make (map[PdfObject ]bool ),_fea :make (map[int ]struct{}),_cg :parser };_ade ,_fde :=ed .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectName );if !_fde {_bf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0043\u0072\u0079\u0070\u0074 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061r\u0079 \u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u0066\u0069\u0065\u006c\u0064\u0021");return _daf ,_e .New ("r\u0065\u0071\u0075\u0069\u0072\u0065d\u0020\u0063\u0072\u0079\u0070\u0074 \u0066\u0069\u0065\u006c\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u006d\u0069\u0073\u0073\u0069n\u0067");};if *_ade !="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"{_bf .Log .Debug ("\u0045\u0052R\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020(%\u0073\u0029",*_ade );return _daf ,_e .New ("\u0075n\u0073u\u0070\u0070\u006f\u0072\u0074e\u0064\u0020F\u0069\u006c\u0074\u0065\u0072");};_daf ._gbe .Filter =string (*_ade );if _eaf ,_aagf :=ed .Get ("\u0053u\u0062\u0046\u0069\u006c\u0074\u0065r").(*PdfObjectString );_aagf {_daf ._gbe .SubFilter =_eaf .Str ();_bf .Log .Debug ("\u0055s\u0069n\u0067\u0020\u0073\u0075\u0062f\u0069\u006ct\u0065\u0072\u0020\u0025\u0073",_eaf );};if L ,_efa :=ed .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );_efa {if (*L %8)!=0{_bf .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0049\u006ev\u0061\u006c\u0069\u0064\u0020\u0065\u006ec\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006c\u0065\u006e\u0067\u0074\u0068");return _daf ,_e .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0065\u006e\u0063\u0072y\u0070t\u0069o\u006e\u0020\u006c\u0065\u006e\u0067\u0074h");};_daf ._gbe .Length =int (*L );}else {_daf ._gbe .Length =40;};_daf ._gbe .V =0;if _dee ,_bga :=ed .Get ("\u0056").(*PdfObjectInteger );_bga {V :=int (*_dee );_daf ._gbe .V =V ;if V >=1&&V <=2{_daf ._ecb =_aca (_daf ._gbe .Length );}else if V >=4&&V <=5{if _dafg :=_daf .loadCryptFilters (ed );_dafg !=nil {return _daf ,_dafg ;};}else {_bf .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0061lg\u006f\u0020\u0056 \u003d \u0025\u0064",V );return _daf ,_e .New ("u\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d");};};if _eaa :=_ccd (&_daf ._dgd ,ed );_eaa !=nil {return _daf ,_eaa ;};_gebg :="";if _ebf ,_eeec :=trailer .Get ("\u0049\u0044").(*PdfObjectArray );_eeec &&_ebf .Len ()>=1{_bgg ,_ebe :=GetString (_ebf .Get (0));if !_ebe {return _daf ,_e .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0074r\u0061\u0069l\u0065\u0072\u0020\u0049\u0044");};_gebg =_bgg .Str ();}else {_bf .Log .Debug ("\u0054\u0072ai\u006c\u0065\u0072 \u0049\u0044\u0020\u0061rra\u0079 m\u0069\u0073\u0073\u0069\u006e\u0067\u0020or\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0021");};_daf ._ddc =_gebg ;return _daf ,nil ;};

// GetAccessPermissions returns the PDF access permissions as an AccessPermissions object.
func (_ece *PdfCrypt )GetAccessPermissions ()_afe .Permissions {return _ece ._dgd .P };var _gacf =_dce .MustCompile ("\u0025P\u0044F\u002d\u0028\u005c\u0064\u0029\u005c\u002e\u0028\u005c\u0064\u0029");const JB2ImageAutoThreshold =-1.0;

// DecodeStream implements ASCII hex decoding.
func (_bcdb *ASCIIHexEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _bcdb .DecodeBytes (streamObj .Stream );};

// GetFilterName returns the name of the encoding filter.
func (_ege *FlateEncoder )GetFilterName ()string {return StreamEncodingFilterNameFlate };func (_bfcd *PdfParser )readTextLine ()(string ,error ){var _bgece _fb .Buffer ;for {_ceed ,_ccdb :=_bfcd ._bdc .Peek (1);if _ccdb !=nil {_bf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_ccdb .Error ());return _bgece .String (),_ccdb ;};if (_ceed [0]!='\r')&&(_ceed [0]!='\n'){_ggdf ,_ :=_bfcd ._bdc .ReadByte ();_bgece .WriteByte (_ggdf );}else {break ;};};return _bgece .String (),nil ;};func _bbb (_agf *_ecf .FilterDict ,_bef *PdfObjectDictionary )error {if _cgd ,_caa :=_bef .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_caa {if _bed :=string (*_cgd );_bed !="C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"{_bf .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020C\u0046\u0020\u0064ic\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074e\u0072\u0029",_bed );};};_fge ,_egfe :=_bef .Get ("\u0043\u0046\u004d").(*PdfObjectName );if !_egfe {return _ce .Errorf ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0028\u004e\u006f\u006e\u0065\u0029");};_agf .CFM =string (*_fge );if _fag ,_egbcb :=_bef .Get ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et").(*PdfObjectName );_egbcb {_agf .AuthEvent =_afe .AuthEvent (*_fag );}else {_agf .AuthEvent =_afe .EventDocOpen ;};if _fab ,_ccb :=_bef .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );_ccb {_agf .Length =int (*_fab );};return nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_fee *LZWEncoder )UpdateParams (params *PdfObjectDictionary ){_dgb ,_fdaa :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _fdaa ==nil {_fee .Predictor =int (_dgb );};_bbgf ,_fdaa :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _fdaa ==nil {_fee .BitsPerComponent =int (_bbgf );};_ccgd ,_fdaa :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _fdaa ==nil {_fee .Columns =int (_ccgd );};_edac ,_fdaa :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _fdaa ==nil {_fee .Colors =int (_edac );};_eaagg ,_fdaa :=GetNumberAsInt64 (params .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065"));if _fdaa ==nil {_fee .EarlyChange =int (_eaagg );};};func (_ffa *PdfCrypt )generateParams (_dcbb ,_bda []byte )error {_fdbd :=_ffa .securityHandler ();_acb ,_ebfb :=_fdbd .GenerateParams (&_ffa ._dgd ,_bda ,_dcbb );if _ebfb !=nil {return _ebfb ;};_ffa ._cce =_acb ;return nil ;};

// DecodeBytes decodes the CCITTFax encoded image data.
func (_baec *CCITTFaxEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_gfdf :=&_acc .Encoder {K :_baec .K ,Columns :_baec .Columns ,EndOfLine :_baec .EndOfLine ,EndOfBlock :_baec .EndOfBlock ,BlackIs1 :_baec .BlackIs1 ,DamagedRowsBeforeError :_baec .DamagedRowsBeforeError ,Rows :_baec .Rows ,EncodedByteAlign :_baec .EncodedByteAlign };_dcbd ,_fdgbb :=_gfdf .Decode (encoded );if _fdgbb !=nil {return nil ,_fdgbb ;};var _acad []byte ;_ddb :=0;var _ggea byte ;var _abdeg byte ;for _ggdg :=range _dcbd {if _ggea !=0{_acad =append (_acad ,_abdeg );_abdeg =0;_ddb ++;_ggea =0;};for _fdbb :=range _dcbd [_ggdg ]{_abdeg |=_dcbd [_ggdg ][_fdbb ]<<(7-_ggea );_ggea ++;if _ggea ==8{_acad =append (_acad ,_abdeg );_abdeg =0;_ddb ++;_ggea =0;};};};if _ggea > 0{_acad =append (_acad ,_abdeg );};return _acad ,nil ;};

// JBIG2Encoder implements both jbig2 encoder and the decoder. The encoder allows to encode
// provided images (best used document scans) in multiple way. By default it uses single page generic
// encoder. It allows to store lossless data as a single segment.
// In order to store multiple image pages use the 'FileMode' which allows to store more pages within single jbig2 document.
// WIP: In order to obtain better compression results the encoder would allow to encode the input in a
// lossy or lossless way with a component (symbol) mode. It divides the image into components.
// Then checks if any component is 'similar' to the others and maps them together. The symbol classes are stored
// in the dictionary. Then the encoder creates text regions which uses the related symbol classes to fill it's space.
// The similarity is defined by the 'Threshold' variable (default: 0.95). The less the value is, the more components
// matches to single class, thus the compression is better, but the result might become lossy.
type JBIG2Encoder struct{

// These values are required to be set for the 'EncodeBytes' method.
// ColorComponents defines the number of color components for provided image.
ColorComponents int ;

// BitsPerComponent is the number of bits that stores per color component
BitsPerComponent int ;

// Width is the width of the image to encode
Width int ;

// Height is the height of the image to encode.
Height int ;_ddfd *_ca .Document ;

// Globals are the JBIG2 global segments.
Globals _eb .Globals ;

// IsChocolateData defines if the data is encoded such that
// binary data '1' means black and '0' white.
// otherwise the data is called vanilla.
// Naming convention taken from: 'https://en.wikipedia.org/wiki/Binary_image#Interpretation'
IsChocolateData bool ;

// DefaultPageSettings are the settings parameters used by the jbig2 encoder.
DefaultPageSettings JBIG2EncoderSettings ;};

// ParseIndirectObject parses an indirect object from the input stream. Can also be an object stream.
// Returns the indirect object (*PdfIndirectObject) or the stream object (*PdfObjectStream).
func (_bcdbc *PdfParser )ParseIndirectObject ()(PdfObject ,error ){_ggbc :=PdfIndirectObject {};_ggbc ._bcdd =_bcdbc ;_bf .Log .Trace ("\u002dR\u0065a\u0064\u0020\u0069\u006e\u0064i\u0072\u0065c\u0074\u0020\u006f\u0062\u006a");_cfec ,_bcef :=_bcdbc ._bdc .Peek (20);if _bcef !=nil {if _bcef !=_aba .EOF {_bf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020r\u0065a\u0064\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a");return &_ggbc ,_bcef ;};};_bf .Log .Trace ("\u0028\u0069\u006edi\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_cfec ));_bgab :=_dbgg .FindStringSubmatchIndex (string (_cfec ));if len (_bgab )< 6{if _bcef ==_aba .EOF {return nil ,_bcef ;};_bf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_cfec ));return &_ggbc ,_e .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");};_bcdbc ._bdc .Discard (_bgab [0]);_bf .Log .Trace ("O\u0066\u0066\u0073\u0065\u0074\u0073\u0020\u0025\u0020\u0064",_bgab );_gfcf :=_bgab [1]-_bgab [0];_aaaf :=make ([]byte ,_gfcf );_ ,_bcef =_bcdbc .ReadAtLeast (_aaaf ,_gfcf );if _bcef !=nil {_bf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u0072\u0065\u0061\u0064\u0020-\u0020\u0025\u0073",_bcef );return nil ,_bcef ;};_bf .Log .Trace ("\u0074\u0065\u0078t\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_aaaf );_eefdg :=_dbgg .FindStringSubmatch (string (_aaaf ));if len (_eefdg )< 3{_bf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_aaaf ));return &_ggbc ,_e .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");};_dbege ,_ :=_dc .Atoi (_eefdg [1]);_egagc ,_ :=_dc .Atoi (_eefdg [2]);_ggbc .ObjectNumber =int64 (_dbege );_ggbc .GenerationNumber =int64 (_egagc );for {_bfab ,_eggb :=_bcdbc ._bdc .Peek (2);if _eggb !=nil {return &_ggbc ,_eggb ;};_bf .Log .Trace ("I\u006ed\u002e\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_bfab ),string (_bfab ));if IsWhiteSpace (_bfab [0]){_bcdbc .skipSpaces ();}else if _bfab [0]=='%'{_bcdbc .skipComments ();}else if (_bfab [0]=='<')&&(_bfab [1]=='<'){_bf .Log .Trace ("\u0043\u0061\u006c\u006c\u0020\u0050\u0061\u0072\u0073e\u0044\u0069\u0063\u0074");_ggbc .PdfObject ,_eggb =_bcdbc .ParseDict ();_bf .Log .Trace ("\u0045\u004f\u0046\u0020Ca\u006c\u006c\u0020\u0050\u0061\u0072\u0073\u0065\u0044\u0069\u0063\u0074\u003a\u0020%\u0076",_eggb );if _eggb !=nil {return &_ggbc ,_eggb ;};_bf .Log .Trace ("\u0050\u0061\u0072\u0073\u0065\u0064\u0020\u0064\u0069\u0063t\u0069\u006f\u006e\u0061\u0072\u0079\u002e.\u002e\u0020\u0066\u0069\u006e\u0069\u0073\u0068\u0065\u0064\u002e");}else if (_bfab [0]=='/')||(_bfab [0]=='(')||(_bfab [0]=='[')||(_bfab [0]=='<'){_ggbc .PdfObject ,_eggb =_bcdbc .parseObject ();if _eggb !=nil {return &_ggbc ,_eggb ;};_bf .Log .Trace ("P\u0061\u0072\u0073\u0065\u0064\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u002e\u002e\u002e \u0066\u0069\u006ei\u0073h\u0065\u0064\u002e");}else if _bfab [0]==']'{_bf .Log .Debug ("\u0057\u0041\u0052\u004e\u0049N\u0047\u003a\u0020\u0027\u005d\u0027 \u0063\u0068\u0061\u0072\u0061\u0063\u0074e\u0072\u0020\u006eo\u0074\u0020\u0062\u0065i\u006e\u0067\u0020\u0075\u0073\u0065d\u0020\u0061\u0073\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006e\u0064\u0069n\u0067\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e");_bcdbc ._bdc .Discard (1);}else {if _bfab [0]=='e'{_ebcd ,_bbed :=_bcdbc .readTextLine ();if _bbed !=nil {return nil ,_bbed ;};if len (_ebcd )>=6&&_ebcd [0:6]=="\u0065\u006e\u0064\u006f\u0062\u006a"{break ;};}else if _bfab [0]=='s'{_bfab ,_ =_bcdbc ._bdc .Peek (10);if string (_bfab [:6])=="\u0073\u0074\u0072\u0065\u0061\u006d"{_ffba :=6;if len (_bfab )> 6{if IsWhiteSpace (_bfab [_ffba ])&&_bfab [_ffba ]!='\r'&&_bfab [_ffba ]!='\n'{_bf .Log .Debug ("\u004e\u006fn\u002d\u0063\u006f\u006e\u0066\u006f\u0072\u006d\u0061\u006e\u0074\u0020\u0050\u0044\u0046\u0020\u006e\u006f\u0074 \u0065\u006e\u0064\u0069\u006e\u0067 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0069\u006e\u0065\u0020\u0070\u0072o\u0070\u0065r\u006c\u0079\u0020\u0077i\u0074\u0068\u0020\u0045\u004fL\u0020\u006d\u0061\u0072\u006b\u0065\u0072");_ffba ++;};if _bfab [_ffba ]=='\r'{_ffba ++;if _bfab [_ffba ]=='\n'{_ffba ++;};}else if _bfab [_ffba ]=='\n'{_ffba ++;};};_bcdbc ._bdc .Discard (_ffba );_gegg ,_afgb :=_ggbc .PdfObject .(*PdfObjectDictionary );if !_afgb {return nil ,_e .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006di\u0073s\u0069\u006e\u0067\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_bf .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0069c\u0074\u0020\u0025\u0073",_gegg );_cade ,_gbac :=_bcdbc .traceStreamLength (_gegg .Get ("\u004c\u0065\u006e\u0067\u0074\u0068"));if _gbac !=nil {_bf .Log .Debug ("\u0046\u0061\u0069l\u0020\u0074\u006f\u0020t\u0072\u0061\u0063\u0065\u0020\u0073\u0074r\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0025\u0076",_gbac );return nil ,_gbac ;};_bf .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_cade );_ebga ,_gcfad :=_cade .(*PdfObjectInteger );if !_gcfad {return nil ,_e .New ("\u0073\u0074re\u0061\u006d\u0020l\u0065\u006e\u0067\u0074h n\u0065ed\u0073\u0020\u0074\u006f\u0020\u0062\u0065 a\u006e\u0020\u0069\u006e\u0074\u0065\u0067e\u0072");};_aceba :=*_ebga ;if _aceba < 0{return nil ,_e .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006e\u0065\u0065\u0064\u0073\u0020\u0074\u006f \u0062e\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0030");};_gefba :=_bcdbc .GetFileOffset ();_cbbafb :=_bcdbc .xrefNextObjectOffset (_gefba );if _gefba +int64 (_aceba )> _cbbafb &&_cbbafb > _gefba {_bf .Log .Debug ("E\u0078\u0070\u0065\u0063te\u0064 \u0065\u006e\u0064\u0069\u006eg\u0020\u0061\u0074\u0020\u0025\u0064",_gefba +int64 (_aceba ));_bf .Log .Debug ("\u004e\u0065\u0078\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020\u0061t\u0020\u0025\u0064",_cbbafb );_ccgca :=_cbbafb -_gefba -17;if _ccgca < 0{return nil ,_e .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020go\u0069\u006e\u0067 \u0070\u0061s\u0074\u0020\u0062\u006f\u0075\u006ed\u0061\u0072i\u0065\u0073");};_bf .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0061\u0020l\u0065\u006e\u0067\u0074\u0068\u0020c\u006f\u0072\u0072\u0065\u0063\u0074\u0069\u006f\u006e\u0020\u0074\u006f\u0020%\u0064\u002e\u002e\u002e",_ccgca );_aceba =PdfObjectInteger (_ccgca );_gegg .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (_ccgca ));};if int64 (_aceba )> _bcdbc ._fcda {_bf .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0053t\u0072\u0065\u0061\u006d\u0020l\u0065\u006e\u0067\u0074\u0068\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u0061\u0072\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0066\u0069\u006c\u0065\u0020\u0073\u0069\u007a\u0065");return nil ,_e .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020la\u0072\u0067\u0065r\u0020\u0074h\u0061\u006e\u0020\u0066\u0069\u006ce\u0020\u0073i\u007a\u0065");};_adge :=make ([]byte ,_aceba );_ ,_gbac =_bcdbc .ReadAtLeast (_adge ,int (_aceba ));if _gbac !=nil {_bf .Log .Debug ("E\u0052\u0052\u004f\u0052 s\u0074r\u0065\u0061\u006d\u0020\u0028%\u0064\u0029\u003a\u0020\u0025\u0058",len (_adge ),_adge );_bf .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_gbac );return nil ,_gbac ;};_cgaa :=PdfObjectStream {};_cgaa .Stream =_adge ;_cgaa .PdfObjectDictionary =_ggbc .PdfObject .(*PdfObjectDictionary );_cgaa .ObjectNumber =_ggbc .ObjectNumber ;_cgaa .GenerationNumber =_ggbc .GenerationNumber ;_cgaa .PdfObjectReference ._bcdd =_bcdbc ;_bcdbc .skipSpaces ();_bcdbc ._bdc .Discard (9);_bcdbc .skipSpaces ();return &_cgaa ,nil ;};};_ggbc .PdfObject ,_eggb =_bcdbc .parseObject ();if _ggbc .PdfObject ==nil {_bf .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");_ggbc .PdfObject =MakeNull ();};return &_ggbc ,_eggb ;};};if _ggbc .PdfObject ==nil {_bf .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");_ggbc .PdfObject =MakeNull ();};_bf .Log .Trace ("\u0052\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0021");return &_ggbc ,nil ;};

// EncodeBytes encodes data into ASCII85 encoded format.
func (_gbeb *ASCII85Encoder )EncodeBytes (data []byte )([]byte ,error ){var _caac _fb .Buffer ;for _acbf :=0;_acbf < len (data );_acbf +=4{_ddfac :=data [_acbf ];_ggb :=1;_afgd :=byte (0);if _acbf +1< len (data ){_afgd =data [_acbf +1];_ggb ++;};_deeg :=byte (0);if _acbf +2< len (data ){_deeg =data [_acbf +2];_ggb ++;};_egd :=byte (0);if _acbf +3< len (data ){_egd =data [_acbf +3];_ggb ++;};_ccfb :=(uint32 (_ddfac )<<24)|(uint32 (_afgd )<<16)|(uint32 (_deeg )<<8)|uint32 (_egd );if _ccfb ==0{_caac .WriteByte ('z');}else {_fada :=_gbeb .base256Tobase85 (_ccfb );for _ ,_fedg :=range _fada [:_ggb +1]{_caac .WriteByte (_fedg +'!');};};};_caac .WriteString ("\u007e\u003e");return _caac .Bytes (),nil ;};

// NewMultiEncoder returns a new instance of MultiEncoder.
func NewMultiEncoder ()*MultiEncoder {_fdge :=MultiEncoder {};_fdge ._gbag =[]StreamEncoder {};return &_fdge ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_cccff *ASCII85Encoder )MakeDecodeParams ()PdfObject {return nil };func _cgea (_cdga int )int {_bdfc :=_cdga >>(_ecgbd -1);return (_cdga ^_bdfc )-_bdfc };func (_egcf *PdfParser )rebuildXrefTable ()error {_baada :=XrefTable {};_baada .ObjectMap =map[int ]XrefObject {};_acabb :=make ([]int ,0,len (_egcf ._bbfg .ObjectMap ));for _cgcbf :=range _egcf ._bbfg .ObjectMap {_acabb =append (_acabb ,_cgcbf );};_b .Ints (_acabb );for _ ,_ecdf :=range _acabb {_cdad :=_egcf ._bbfg .ObjectMap [_ecdf ];_ccaa ,_ ,_eeaf :=_egcf .lookupByNumberWrapper (_ecdf ,false );if _eeaf !=nil {_bf .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020U\u006e\u0061\u0062\u006ce t\u006f l\u006f\u006f\u006b\u0020\u0075\u0070\u0020ob\u006a\u0065\u0063\u0074\u0020\u0028\u0025s\u0029",_eeaf );_bf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0063\u006fm\u0070\u006c\u0065\u0074\u0065\u006c\u0079\u0020\u0062\u0072\u006f\u006b\u0065\u006e\u0020\u002d\u0020\u0061\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0074\u006f \u0072\u0065\u0070\u0061\u0069r\u0020");_dedbe ,_dbgbe :=_egcf .repairRebuildXrefsTopDown ();if _dbgbe !=nil {_bf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0072\u0065\u0062\u0075\u0069l\u0064\u0020\u0072\u0065\u0070a\u0069\u0072 \u0028\u0025\u0073\u0029",_dbgbe );return _dbgbe ;};_egcf ._bbfg =*_dedbe ;_bf .Log .Debug ("\u0052e\u0070\u0061\u0069\u0072e\u0064\u0020\u0078\u0072\u0065f\u0020t\u0061b\u006c\u0065\u0020\u0062\u0075\u0069\u006ct");return nil ;};_cbfg ,_faad ,_eeaf :=_dgf (_ccaa );if _eeaf !=nil {return _eeaf ;};_cdad .ObjectNumber =int (_cbfg );_cdad .Generation =int (_faad );_baada .ObjectMap [int (_cbfg )]=_cdad ;};_egcf ._bbfg =_baada ;_bf .Log .Debug ("N\u0065w\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061b\u006c\u0065\u0020\u0062ui\u006c\u0074");_cca (_egcf ._bbfg );return nil ;};var _bafgg =_dce .MustCompile ("\u0073t\u0061r\u0074\u0078\u003f\u0072\u0065f\u005c\u0073*\u0028\u005c\u0064\u002b\u0029");func (_abcb *PdfCrypt )makeKey (_ace string ,_fbfe ,_eece uint32 ,_gdbd []byte )([]byte ,error ){_dgdg ,_cbba :=_abcb ._ecb [_ace ];if !_cbba {return nil ,_ce .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_ace );};return _dgdg .MakeKey (_fbfe ,_eece ,_gdbd );};

// PdfObjectName represents the primitive PDF name object.
type PdfObjectName string ;

// DecodeBytes decodes a slice of Flate encoded bytes and returns the result.
func (_fecg *FlateEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_bf .Log .Trace ("\u0046\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065\u0020b\u0079\u0074\u0065\u0073");if len (encoded )==0{_bf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0046\u006c\u0061\u0074\u0065 e\u006ec\u006f\u0064\u0065\u0064\u0020\u0062\u0075\u0066\u0066\u0065\u0072\u002e \u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0062y\u0074\u0065\u0020\u0073\u006c\u0069\u0063\u0065\u002e");return []byte {},nil ;};_gge :=_fb .NewReader (encoded );_gba ,_eebf :=_c .NewReader (_gge );if _eebf !=nil {_bf .Log .Debug ("\u0044e\u0063o\u0064\u0069\u006e\u0067\u0020e\u0072\u0072o\u0072\u0020\u0025\u0076\u000a",_eebf );_bf .Log .Debug ("\u0053t\u0072e\u0061\u006d\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (encoded ),encoded );return nil ,_eebf ;};defer _gba .Close ();var _afcc _fb .Buffer ;_afcc .ReadFrom (_gba );return _afcc .Bytes (),nil ;};func (_cegb *offsetReader )Read (p []byte )(_fedd int ,_dfgd error ){return _cegb ._edg .Read (p )};func (_effa *PdfParser )parseBool ()(PdfObjectBool ,error ){_gagb ,_gabe :=_effa ._bdc .Peek (4);if _gabe !=nil {return PdfObjectBool (false ),_gabe ;};if (len (_gagb )>=4)&&(string (_gagb [:4])=="\u0074\u0072\u0075\u0065"){_effa ._bdc .Discard (4);return PdfObjectBool (true ),nil ;};_gagb ,_gabe =_effa ._bdc .Peek (5);if _gabe !=nil {return PdfObjectBool (false ),_gabe ;};if (len (_gagb )>=5)&&(string (_gagb [:5])=="\u0066\u0061\u006cs\u0065"){_effa ._bdc .Discard (5);return PdfObjectBool (false ),nil ;};return PdfObjectBool (false ),_e .New ("\u0075n\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0062o\u006fl\u0065a\u006e\u0020\u0073\u0074\u0072\u0069\u006eg");};func (_geae *PdfParser )repairRebuildXrefsTopDown ()(*XrefTable ,error ){if _geae ._bbacb {return nil ,_ce .Errorf ("\u0072\u0065\u0070\u0061\u0069\u0072\u0020\u0066\u0061\u0069\u006c\u0065\u0064");};_geae ._bbacb =true ;_geae ._aagc .Seek (0,_aba .SeekStart );_geae ._bdc =_ac .NewReader (_geae ._aagc );_fedb :=20;_accd :=make ([]byte ,_fedb );_bada :=XrefTable {};_bada .ObjectMap =make (map[int ]XrefObject );for {_ceba ,_dedf :=_geae ._bdc .ReadByte ();if _dedf !=nil {if _dedf ==_aba .EOF {break ;}else {return nil ,_dedf ;};};if _ceba =='j'&&_accd [_fedb -1]=='b'&&_accd [_fedb -2]=='o'&&IsWhiteSpace (_accd [_fedb -3]){_badac :=_fedb -4;for IsWhiteSpace (_accd [_badac ])&&_badac > 0{_badac --;};if _badac ==0||!IsDecimalDigit (_accd [_badac ]){continue ;};for IsDecimalDigit (_accd [_badac ])&&_badac > 0{_badac --;};if _badac ==0||!IsWhiteSpace (_accd [_badac ]){continue ;};for IsWhiteSpace (_accd [_badac ])&&_badac > 0{_badac --;};if _badac ==0||!IsDecimalDigit (_accd [_badac ]){continue ;};for IsDecimalDigit (_accd [_badac ])&&_badac > 0{_badac --;};if _badac ==0{continue ;};_cddb :=_geae .GetFileOffset ()-int64 (_fedb -_badac );_cegf :=append (_accd [_badac +1:],_ceba );_bcae ,_ffge ,_ggaff :=_febbc (string (_cegf ));if _ggaff !=nil {_bf .Log .Debug ("\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u006e\u0075\u006d\u0062\u0065r\u003a\u0020\u0025\u0076",_ggaff );return nil ,_ggaff ;};if _bedb ,_afcg :=_bada .ObjectMap [_bcae ];!_afcg ||_bedb .Generation < _ffge {_dgcbb :=XrefObject {};_dgcbb .XType =XrefTypeTableEntry ;_dgcbb .ObjectNumber =_bcae ;_dgcbb .Generation =_ffge ;_dgcbb .Offset =_cddb ;_bada .ObjectMap [_bcae ]=_dgcbb ;};};_accd =append (_accd [1:_fedb ],_ceba );};_geae ._bgec =nil ;return &_bada ,nil ;};

// JPXEncoder implements JPX encoder/decoder (dummy, for now)
// FIXME: implement
type JPXEncoder struct{};

// ASCIIHexEncoder implements ASCII hex encoder/decoder.
type ASCIIHexEncoder struct{};

// DecodeBytes decodes a multi-encoded slice of bytes by passing it through the
// DecodeBytes method of the underlying encoders.
func (_fbda *MultiEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_cbbdf :=encoded ;var _cgcg error ;for _ ,_ddaa :=range _fbda ._gbag {_bf .Log .Trace ("\u004du\u006c\u0074i\u0020\u0045\u006e\u0063o\u0064\u0065\u0072 \u0044\u0065\u0063\u006f\u0064\u0065\u003a\u0020\u0041pp\u006c\u0079\u0069n\u0067\u0020F\u0069\u006c\u0074\u0065\u0072\u003a \u0025\u0076 \u0025\u0054",_ddaa ,_ddaa );_cbbdf ,_cgcg =_ddaa .DecodeBytes (_cbbdf );if _cgcg !=nil {return nil ,_cgcg ;};};return _cbbdf ,nil ;};

// GetFileOffset returns the current file offset, accounting for buffered position.
func (_fgdf *PdfParser )GetFileOffset ()int64 {_cgdb ,_ :=_fgdf ._aagc .Seek (0,_aba .SeekCurrent );_cgdb -=int64 (_fgdf ._bdc .Buffered ());return _cgdb ;};

// WriteString outputs the object as it is to be written to file.
func (_deab *PdfObjectString )WriteString ()string {var _ffeb _fb .Buffer ;if _deab ._efgcb {_eacgd :=_af .EncodeToString (_deab .Bytes ());_ffeb .WriteString ("\u003c");_ffeb .WriteString (_eacgd );_ffeb .WriteString ("\u003e");return _ffeb .String ();};_cgfa :=map[byte ]string {'\n':"\u005c\u006e",'\r':"\u005c\u0072",'\t':"\u005c\u0074",'\b':"\u005c\u0062",'\f':"\u005c\u0066",'(':"\u005c\u0028",')':"\u005c\u0029",'\\':"\u005c\u005c"};_ffeb .WriteString ("\u0028");for _dfga :=0;_dfga < len (_deab ._gcae );_dfga ++{_cfde :=_deab ._gcae [_dfga ];if _baeb ,_bgaed :=_cgfa [_cfde ];_bgaed {_ffeb .WriteString (_baeb );}else {_ffeb .WriteByte (_cfde );};};_ffeb .WriteString ("\u0029");return _ffeb .String ();};

// WriteString outputs the object as it is to be written to file.
func (_defb *PdfObjectFloat )WriteString ()string {return _dc .FormatFloat (float64 (*_defb ),'f',-1,64);};func _fdab (_cgce ,_bbbd ,_fgca uint8 )uint8 {_afccfg :=int (_fgca );_cgb :=int (_bbbd )-_afccfg ;_deceg :=int (_cgce )-_afccfg ;_afccfg =_cgea (_cgb +_deceg );_cgb =_cgea (_cgb );_deceg =_cgea (_deceg );if _cgb <=_deceg &&_cgb <=_afccfg {return _cgce ;}else if _deceg <=_afccfg {return _bbbd ;};return _fgca ;};var _bdbc =_dce .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064\u002b)\u005c\u0073\u002a\u0024");func (_gffd *PdfCrypt )securityHandler ()_afe .StdHandler {if _gffd ._dgd .R >=5{return _afe .NewHandlerR6 ();};return _afe .NewHandlerR4 (_gffd ._ddc ,_gffd ._gbe .Length );};

// NewLZWEncoder makes a new LZW encoder with default parameters.
func NewLZWEncoder ()*LZWEncoder {_fgef :=&LZWEncoder {};_fgef .Predictor =1;_fgef .BitsPerComponent =8;_fgef .Colors =1;_fgef .Columns =1;_fgef .EarlyChange =1;return _fgef ;};

// GetBool returns the *PdfObjectBool object that is represented by a PdfObject directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetBool (obj PdfObject )(_ebdb *PdfObjectBool ,_cfcg bool ){_ebdb ,_cfcg =TraceToDirectObject (obj ).(*PdfObjectBool );return _ebdb ,_cfcg ;};

// ResolveReferencesDeep recursively traverses through object `o`, looking up and replacing
// references with indirect objects.
// Optionally a map of already deep-resolved objects can be provided via `traversed`. The `traversed` map
// is updated while traversing the objects to avoid traversing same objects multiple times.
func ResolveReferencesDeep (o PdfObject ,traversed map[PdfObject ]struct{})error {if traversed ==nil {traversed =map[PdfObject ]struct{}{};};return _ffbaf (o ,0,traversed );};func (_bgag *JBIG2Encoder )encodeImage (_ccea _dd .Image )([]byte ,error ){const _bfdd ="e\u006e\u0063\u006f\u0064\u0065\u0049\u006d\u0061\u0067\u0065";_acebc ,_afb :=GoImageToJBIG2 (_ccea ,JB2ImageAutoThreshold );if _afb !=nil {return nil ,_fg .Wrap (_afb ,_bfdd ,"\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069m\u0061g\u0065\u0020\u0074\u006f\u0020\u006a\u0062\u0069\u0067\u0032\u0020\u0069\u006d\u0067");};if _afb =_bgag .AddPageImage (_acebc ,&_bgag .DefaultPageSettings );_afb !=nil {return nil ,_fg .Wrap (_afb ,_bfdd ,"");};return _bgag .Encode ();};

// GetFilterName returns the name of the encoding filter.
func (_ccdc *RunLengthEncoder )GetFilterName ()string {return StreamEncodingFilterNameRunLength };func _aeeee (_adga string )(PdfObjectReference ,error ){_beba :=PdfObjectReference {};_dcga :=_bgba .FindStringSubmatch (_adga );if len (_dcga )< 3{_bf .Log .Debug ("\u0045\u0072\u0072or\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");return _beba ,_e .New ("\u0075n\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061r\u0073e\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");};_aebb ,_ :=_dc .Atoi (_dcga [1]);_ecdg ,_ :=_dc .Atoi (_dcga [2]);_beba .ObjectNumber =int64 (_aebb );_beba .GenerationNumber =int64 (_ecdg );return _beba ,nil ;};

// SetImage sets the image base for given flate encoder.
func (_dfd *FlateEncoder )SetImage (img *_aa .ImageBase ){_dfd ._agac =img };

// DecodeGlobals decodes 'encoded' byte stream and returns their Globally defined segments ('Globals').
func (_gfeg *JBIG2Encoder )DecodeGlobals (encoded []byte )(_eb .Globals ,error ){return _eb .DecodeGlobals (encoded );};

// MakeHexString creates an PdfObjectString from a string intended for output as a hexadecimal string.
func MakeHexString (s string )*PdfObjectString {_ggdfe :=PdfObjectString {_gcae :s ,_efgcb :true };return &_ggdfe ;};

// Remove removes an element specified by key.
func (_cafb *PdfObjectDictionary )Remove (key PdfObjectName ){_deeb :=-1;for _gfaa ,_fgdg :=range _cafb ._eaef {if _fgdg ==key {_deeb =_gfaa ;break ;};};if _deeb >=0{_cafb ._eaef =append (_cafb ._eaef [:_deeb ],_cafb ._eaef [_deeb +1:]...);delete (_cafb ._ffca ,key );};};

// Encode encodes previously prepare jbig2 document and stores it as the byte slice.
func (_gbcf *JBIG2Encoder )Encode ()(_efgb []byte ,_agbef error ){const _eefa ="J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0045\u006eco\u0064\u0065";if _gbcf ._ddfd ==nil {return nil ,_fg .Errorf (_eefa ,"\u0064\u006f\u0063u\u006d\u0065\u006e\u0074 \u0069\u006e\u0070\u0075\u0074\u0020\u0064a\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006e\u0065\u0064");};_gbcf ._ddfd .FullHeaders =_gbcf .DefaultPageSettings .FileMode ;_efgb ,_agbef =_gbcf ._ddfd .Encode ();if _agbef !=nil {return nil ,_fg .Wrap (_agbef ,_eefa ,"");};return _efgb ,nil ;};func (_gedb *offsetReader )Seek (offset int64 ,whence int )(int64 ,error ){if whence ==_aba .SeekStart {offset +=_gedb ._cec ;};_effc ,_fbfed :=_gedb ._edg .Seek (offset ,whence );if _fbfed !=nil {return _effc ,_fbfed ;};if whence ==_aba .SeekCurrent {_effc -=_gedb ._cec ;};if _effc < 0{return 0,_e .New ("\u0063\u006f\u0072\u0065\u002eo\u0066\u0066\u0073\u0065\u0074\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053e\u0065\u006b\u003a\u0020\u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e");};return _effc ,nil ;};func (_abbc *PdfParser )repairLocateXref ()(int64 ,error ){_cdaaa :=int64 (1000);_abbc ._aagc .Seek (-_cdaaa ,_aba .SeekCurrent );_cgeab ,_cged :=_abbc ._aagc .Seek (0,_aba .SeekCurrent );if _cged !=nil {return 0,_cged ;};_fbdce :=make ([]byte ,_cdaaa );_abbc ._aagc .Read (_fbdce );_gdcec :=_cace .FindAllStringIndex (string (_fbdce ),-1);if len (_gdcec )< 1{_bf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0065\u0070a\u0069\u0072\u003a\u0020\u0078\u0072\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021");return 0,_e .New ("\u0072\u0065\u0070\u0061ir\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064");};_adabf :=int64 (_gdcec [len (_gdcec )-1][0]);_dfcce :=_cgeab +_adabf ;return _dfcce ,nil ;};func (_aebe *PdfParser )parseXrefStream (_bace *PdfObjectInteger )(*PdfObjectDictionary ,error ){if _bace !=nil {_bf .Log .Trace ("\u0058\u0052\u0065f\u0053\u0074\u006d\u0020x\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0061\u0074\u0020\u0025\u0064",_bace );_aebe ._aagc .Seek (int64 (*_bace ),_aba .SeekStart );_aebe ._bdc =_ac .NewReader (_aebe ._aagc );};_afbf :=_aebe .GetFileOffset ();_bdgf ,_aabc :=_aebe .ParseIndirectObject ();if _aabc !=nil {_bf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072\u0065\u0061d\u0020\u0078\u0072\u0065\u0066\u0020\u006fb\u006a\u0065\u0063\u0074");return nil ,_e .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072e\u0061\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062j\u0065\u0063\u0074");};_bf .Log .Trace ("\u0058R\u0065f\u0053\u0074\u006d\u0020\u006fb\u006a\u0065c\u0074\u003a\u0020\u0025\u0073",_bdgf );_cegc ,_agdb :=_bdgf .(*PdfObjectStream );if !_agdb {_bf .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0058R\u0065\u0066\u0053\u0074\u006d\u0020\u0070o\u0069\u006e\u0074\u0069\u006e\u0067 \u0074\u006f\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065a\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0021");return nil ,_e .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0070\u006f\u0069\u006e\u0074i\u006e\u0067\u0020\u0074\u006f\u0020a\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006fb\u006a\u0065\u0063\u0074");};_bdfa :=_cegc .PdfObjectDictionary ;_feda ,_agdb :=_cegc .PdfObjectDictionary .Get ("\u0053\u0069\u007a\u0065").(*PdfObjectInteger );if !_agdb {_bf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u004d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0073\u0069\u007a\u0065\u0020f\u0072\u006f\u006d\u0020\u0078\u0072\u0065f\u0020\u0073\u0074\u006d");return nil ,_e .New ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0053\u0069\u007ae\u0020\u0066\u0072\u006f\u006d\u0020\u0078\u0072\u0065\u0066 \u0073\u0074\u006d");};if int64 (*_feda )> 8388607{_bf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u0053\u0069\u007a\u0065\u0020\u0065x\u0063\u0065\u0065\u0064\u0065\u0064\u0020l\u0069\u006d\u0069\u0074\u002c\u0020\u006f\u0076\u0065\u0072\u00208\u0033\u0038\u0038\u0036\u0030\u0037\u0020\u0028\u0025\u0064\u0029",*_feda );return nil ,_e .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_ddgg :=_cegc .PdfObjectDictionary .Get ("\u0057");_ecfg ,_agdb :=_ddgg .(*PdfObjectArray );if !_agdb {return nil ,_e .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0057\u0020\u0069\u006e\u0020x\u0072\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d");};_facd :=_ecfg .Len ();if _facd !=3{_bf .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020\u0028\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033\u0020\u002d\u0020\u0025\u0064\u0029",_facd );return nil ,_e .New ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065f\u0020s\u0074\u006d\u0020\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033");};var _edgc []int64 ;for _bedda :=0;_bedda < 3;_bedda ++{_efacd ,_gced :=GetInt (_ecfg .Get (_bedda ));if !_gced {return nil ,_e .New ("i\u006e\u0076\u0061\u006cid\u0020w\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0074\u0079\u0070\u0065");};_edgc =append (_edgc ,int64 (*_efacd ));};_gcba ,_aabc :=DecodeStream (_cegc );if _aabc !=nil {_bf .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020t\u006f \u0064e\u0063o\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u003a\u0020\u0025\u0076",_aabc );return nil ,_aabc ;};_fce :=int (_edgc [0]);_acdd :=int (_edgc [0]+_edgc [1]);_feac :=int (_edgc [0]+_edgc [1]+_edgc [2]);_edee :=int (_edgc [0]+_edgc [1]+_edgc [2]);if _fce < 0||_acdd < 0||_feac < 0{_bf .Log .Debug ("\u0045\u0072\u0072\u006fr\u0020\u0073\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u003c \u0030 \u0028\u0025\u0064\u002c\u0025\u0064\u002c%\u0064\u0029",_fce ,_acdd ,_feac );return nil ,_e .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};if _edee ==0{_bf .Log .Debug ("\u004e\u006f\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063t\u0073\u0020\u0069\u006e\u0020\u0073t\u0072\u0065\u0061\u006d\u0020\u0028\u0064\u0065\u006c\u0074\u0061\u0062\u0020=\u003d\u0020\u0030\u0029");return _bdfa ,nil ;};_gdbf :=len (_gcba )/_edee ;_daff :=0;_dfeg :=_cegc .PdfObjectDictionary .Get ("\u0049\u006e\u0064e\u0078");var _aecb []int ;if _dfeg !=nil {_bf .Log .Trace ("\u0049n\u0064\u0065\u0078\u003a\u0020\u0025b",_dfeg );_acea ,_cadb :=_dfeg .(*PdfObjectArray );if !_cadb {_bf .Log .Debug ("\u0049\u006e\u0076\u0061\u006ci\u0064\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0029");return nil ,_e .New ("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0049\u006e\u0064e\u0078\u0020\u006f\u0062je\u0063\u0074");};if _acea .Len ()%2!=0{_bf .Log .Debug ("\u0057\u0041\u0052\u004eI\u004e\u0047\u0020\u0046\u0061\u0069\u006c\u0075\u0072e\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020i\u006e\u0064\u0065\u0078\u0020n\u006f\u0074\u0020\u006d\u0075\u006c\u0074\u0069\u0070\u006c\u0065\u0020\u006f\u0066\u0020\u0032\u002e");return nil ,_e .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_daff =0;_aefg ,_bdeg :=_acea .ToIntegerArray ();if _bdeg !=nil {_bf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072 \u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0065\u0078 \u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0073\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0073\u003a\u0020\u0025\u0076",_bdeg );return nil ,_bdeg ;};for _dcfb :=0;_dcfb < len (_aefg );_dcfb +=2{_egab :=_aefg [_dcfb ];_agedc :=_aefg [_dcfb +1];for _gfbf :=0;_gfbf < _agedc ;_gfbf ++{_aecb =append (_aecb ,_egab +_gfbf );};_daff +=_agedc ;};}else {for _dfegf :=0;_dfegf < int (*_feda );_dfegf ++{_aecb =append (_aecb ,_dfegf );};_daff =int (*_feda );};if _gdbf ==_daff +1{_bf .Log .Debug ("\u0049n\u0063\u006f\u006d\u0070ati\u0062\u0069\u006c\u0069t\u0079\u003a\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006di\u0073\u0073\u0069\u006e\u0067\u0020\u0063\u006f\u0076\u0065\u0072\u0061\u0067\u0065\u0020\u006f\u0066\u0020\u0031\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u002d\u0020\u0061\u0070\u0070en\u0064\u0069\u006eg\u0020\u006f\u006e\u0065\u0020-\u0020M\u0061\u0079\u0020\u006c\u0065\u0061\u0064\u0020\u0074o\u0020\u0070\u0072\u006f\u0062\u006c\u0065\u006d\u0073");_abda :=_daff -1;for _ ,_bdfef :=range _aecb {if _bdfef > _abda {_abda =_bdfef ;};};_aecb =append (_aecb ,_abda +1);_daff ++;};if _gdbf !=len (_aecb ){_bf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020x\u0072\u0065\u0066 \u0073\u0074\u006d:\u0020\u006eu\u006d\u0020\u0065\u006e\u0074\u0072i\u0065s \u0021\u003d\u0020\u006c\u0065\u006e\u0028\u0069\u006e\u0064\u0069\u0063\u0065\u0073\u0029\u0020\u0028\u0025\u0064\u0020\u0021\u003d\u0020\u0025\u0064\u0029",_gdbf ,len (_aecb ));return nil ,_e .New ("\u0078\u0072ef\u0020\u0073\u0074m\u0020\u006e\u0075\u006d en\u0074ri\u0065\u0073\u0020\u0021\u003d\u0020\u006cen\u0028\u0069\u006e\u0064\u0069\u0063\u0065s\u0029");};_bf .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074s\u0020\u0063\u006f\u0075\u006e\u0074\u0020\u0025\u0064",_daff );_bf .Log .Trace ("\u0049\u006e\u0064i\u0063\u0065\u0073\u003a\u0020\u0025\u0020\u0064",_aecb );_fcbb :=func (_cffd []byte )int64 {var _eddcb int64 ;for _cbcba :=0;_cbcba < len (_cffd );_cbcba ++{_eddcb +=int64 (_cffd [_cbcba ])*(1<<uint (8*(len (_cffd )-_cbcba -1)));};return _eddcb ;};_bf .Log .Trace ("\u0044e\u0063\u006f\u0064\u0065d\u0020\u0073\u0074\u0072\u0065a\u006d \u006ce\u006e\u0067\u0074\u0068\u003a\u0020\u0025d",len (_gcba ));_gbcba :=0;for _agaa :=0;_agaa < len (_gcba );_agaa +=_edee {_deaf :=_baaa (len (_gcba ),_agaa ,_agaa +_fce );if _deaf !=nil {_bf .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_deaf );return nil ,_deaf ;};_eggd :=_gcba [_agaa :_agaa +_fce ];_deaf =_baaa (len (_gcba ),_agaa +_fce ,_agaa +_acdd );if _deaf !=nil {_bf .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_deaf );return nil ,_deaf ;};_eeda :=_gcba [_agaa +_fce :_agaa +_acdd ];_deaf =_baaa (len (_gcba ),_agaa +_acdd ,_agaa +_feac );if _deaf !=nil {_bf .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_deaf );return nil ,_deaf ;};_gacg :=_gcba [_agaa +_acdd :_agaa +_feac ];_fbaa :=_fcbb (_eggd );_cbbg :=_fcbb (_eeda );_eceed :=_fcbb (_gacg );if _edgc [0]==0{_fbaa =1;};if _gbcba >=len (_aecb ){_bf .Log .Debug ("X\u0052\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u002d\u0020\u0054\u0072\u0079\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0061\u0063\u0063e\u0073s\u0020\u0069\u006e\u0064e\u0078\u0020o\u0075\u0074\u0020\u006f\u0066\u0020\u0062\u006f\u0075\u006e\u0064\u0073\u0020\u002d\u0020\u0062\u0072\u0065\u0061\u006b\u0069\u006e\u0067");break ;};_ggac :=_aecb [_gbcba ];_gbcba ++;_bf .Log .Trace ("%\u0064\u002e\u0020\u0070\u0031\u003a\u0020\u0025\u0020\u0078",_ggac ,_eggd );_bf .Log .Trace ("%\u0064\u002e\u0020\u0070\u0032\u003a\u0020\u0025\u0020\u0078",_ggac ,_eeda );_bf .Log .Trace ("%\u0064\u002e\u0020\u0070\u0033\u003a\u0020\u0025\u0020\u0078",_ggac ,_gacg );_bf .Log .Trace ("\u0025d\u002e \u0078\u0072\u0065\u0066\u003a \u0025\u0064 \u0025\u0064\u0020\u0025\u0064",_ggac ,_fbaa ,_cbbg ,_eceed );if _fbaa ==0{_bf .Log .Trace ("-\u0020\u0046\u0072\u0065\u0065\u0020o\u0062\u006a\u0065\u0063\u0074\u0020-\u0020\u0063\u0061\u006e\u0020\u0070\u0072o\u0062\u0061\u0062\u006c\u0079\u0020\u0069\u0067\u006e\u006fr\u0065");}else if _fbaa ==1{_bf .Log .Trace ("\u002d\u0020I\u006e\u0020\u0075\u0073e\u0020\u002d \u0075\u006e\u0063\u006f\u006d\u0070\u0072\u0065s\u0073\u0065\u0064\u0020\u0076\u0069\u0061\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0062",_eeda );if _cbbg ==_afbf {_bf .Log .Debug ("\u0055\u0070d\u0061\u0074\u0069\u006e\u0067\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0058\u0052\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0064",_ggac ,_cegc .ObjectNumber );_ggac =int (_cegc .ObjectNumber );};if _ebad ,_aeeb :=_aebe ._bbfg .ObjectMap [_ggac ];!_aeeb ||int (_eceed )> _ebad .Generation {_eefdd :=XrefObject {ObjectNumber :_ggac ,XType :XrefTypeTableEntry ,Offset :_cbbg ,Generation :int (_eceed )};_aebe ._bbfg .ObjectMap [_ggac ]=_eefdd ;};}else if _fbaa ==2{_bf .Log .Trace ("\u002d\u0020\u0049\u006e \u0075\u0073\u0065\u0020\u002d\u0020\u0063\u006f\u006d\u0070r\u0065s\u0073\u0065\u0064\u0020\u006f\u0062\u006ae\u0063\u0074");if _ ,_gaca :=_aebe ._bbfg .ObjectMap [_ggac ];!_gaca {_fgbaf :=XrefObject {ObjectNumber :_ggac ,XType :XrefTypeObjectStream ,OsObjNumber :int (_cbbg ),OsObjIndex :int (_eceed )};_aebe ._bbfg .ObjectMap [_ggac ]=_fgbaf ;_bf .Log .Trace ("\u0065\u006e\u0074\u0072\u0079\u003a\u0020\u0025\u002b\u0076",_fgbaf );};}else {_bf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052:\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0056\u0041L\u0049\u0044\u0020\u0054\u0059\u0050\u0045\u0020\u0058\u0072\u0065\u0066\u0053\u0074\u006d\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u003f\u002d\u002d\u002d\u002d\u002d\u002d-");continue ;};};if _aebe ._eaba ==nil {_cfge :=XrefTypeObjectStream ;_aebe ._eaba =&_cfge ;};return _bdfa ,nil ;};const _ecgbd =32<<(^uint (0)>>63);

// EncodeBytes implements support for LZW encoding.  Currently not supporting predictors (raw compressed data only).
// Only supports the Early change = 1 algorithm (compress/lzw) as the other implementation
// does not have a write method.
// TODO: Consider refactoring compress/lzw to allow both.
func (_aaff *LZWEncoder )EncodeBytes (data []byte )([]byte ,error ){if _aaff .Predictor !=1{return nil ,_ce .Errorf ("\u004c\u005aW \u0050\u0072\u0065d\u0069\u0063\u0074\u006fr =\u00201 \u006f\u006e\u006c\u0079\u0020\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0079e\u0074");};if _aaff .EarlyChange ==1{return nil ,_ce .Errorf ("\u004c\u005a\u0057\u0020\u0045\u0061\u0072\u006c\u0079\u0020\u0043\u0068\u0061n\u0067\u0065\u0020\u003d\u0020\u0030 \u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0079\u0065\u0074");};var _cdge _fb .Buffer ;_adag :=_ad .NewWriter (&_cdge ,_ad .MSB ,8);_adag .Write (data );_adag .Close ();return _cdge .Bytes (),nil ;};const (StreamEncodingFilterNameFlate ="F\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameLZW ="\u004cZ\u0057\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameDCT ="\u0044C\u0054\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameRunLength ="\u0052u\u006eL\u0065\u006e\u0067\u0074\u0068\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameASCIIHex ="\u0041\u0053\u0043\u0049\u0049\u0048\u0065\u0078\u0044e\u0063\u006f\u0064\u0065";StreamEncodingFilterNameASCII85 ="\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameCCITTFax ="\u0043\u0043\u0049\u0054\u0054\u0046\u0061\u0078\u0044e\u0063\u006f\u0064\u0065";StreamEncodingFilterNameJBIG2 ="J\u0042\u0049\u0047\u0032\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameJPX ="\u004aP\u0058\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameRaw ="\u0052\u0061\u0077";);

// ToFloat64Array returns a slice of all elements in the array as a float64 slice.  An error is
// returned if the array contains non-numeric objects (each element can be either PdfObjectInteger
// or PdfObjectFloat).
func (_edbfe *PdfObjectArray )ToFloat64Array ()([]float64 ,error ){var _beead []float64 ;for _ ,_gcfg :=range _edbfe .Elements (){switch _ddcd :=_gcfg .(type ){case *PdfObjectInteger :_beead =append (_beead ,float64 (*_ddcd ));case *PdfObjectFloat :_beead =append (_beead ,float64 (*_ddcd ));default:return nil ,ErrTypeError ;};};return _beead ,nil ;};

// Version represents a version of a PDF standard.
type Version struct{Major int ;Minor int ;};

// MakeInteger creates a PdfObjectInteger from an int64.
func MakeInteger (val int64 )*PdfObjectInteger {_befc :=PdfObjectInteger (val );return &_befc };

// UpdateParams updates the parameter values of the encoder.
func (_feee *RunLengthEncoder )UpdateParams (params *PdfObjectDictionary ){};

// GetFilterName returns the name of the encoding filter.
func (_cgc *RawEncoder )GetFilterName ()string {return StreamEncodingFilterNameRaw };func (_abfb *ASCII85Encoder )base256Tobase85 (_defc uint32 )[5]byte {_acgd :=[5]byte {0,0,0,0,0};_gbc :=_defc ;for _gagf :=0;_gagf < 5;_gagf ++{_fbcf :=uint32 (1);for _aafd :=0;_aafd < 4-_gagf ;_aafd ++{_fbcf *=85;};_aedd :=_gbc /_fbcf ;_gbc =_gbc %_fbcf ;_acgd [_gagf ]=byte (_aedd );};return _acgd ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_bgbca *RawEncoder )MakeDecodeParams ()PdfObject {return nil };func (_bdce *PdfParser )traceStreamLength (_acbfa PdfObject )(PdfObject ,error ){_cbeae ,_fafe :=_acbfa .(*PdfObjectReference );if _fafe {_eceg ,_cbeg :=_bdce ._ffdfa [_cbeae .ObjectNumber ];if _cbeg &&_eceg {_bf .Log .Debug ("\u0053t\u0072\u0065a\u006d\u0020\u004c\u0065n\u0067\u0074\u0068 \u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065 u\u006e\u0072\u0065s\u006f\u006cv\u0065\u0064\u0020\u0028\u0069\u006cl\u0065\u0067a\u006c\u0029");return nil ,_e .New ("\u0069\u006c\u006c\u0065ga\u006c\u0020\u0072\u0065\u0063\u0075\u0072\u0073\u0069\u0076\u0065\u0020\u006c\u006fo\u0070");};_bdce ._ffdfa [_cbeae .ObjectNumber ]=true ;};_daac ,_fbed :=_bdce .Resolve (_acbfa );if _fbed !=nil {return nil ,_fbed ;};_bf .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_daac );if _fafe {_bdce ._ffdfa [_cbeae .ObjectNumber ]=false ;};return _daac ,nil ;};const (JB2Generic JBIG2CompressionType =iota ;JB2SymbolCorrelation ;JB2SymbolRankHaus ;);

// Decrypt attempts to decrypt the PDF file with a specified password.  Also tries to
// decrypt with an empty password.  Returns true if successful, false otherwise.
// An error is returned when there is a problem with decrypting.
func (_dbad *PdfParser )Decrypt (password []byte )(bool ,error ){if _dbad ._aggc ==nil {return false ,_e .New ("\u0063\u0068\u0065\u0063k \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u0069\u0072s\u0074");};_cgcb ,_bcfcf :=_dbad ._aggc .authenticate (password );if _bcfcf !=nil {return false ,_bcfcf ;};if !_cgcb {_cgcb ,_bcfcf =_dbad ._aggc .authenticate ([]byte (""));};return _cgcb ,_bcfcf ;};

// DecodeBytes decodes byte array with ASCII85. 5 ASCII characters -> 4 raw binary bytes
func (_efbg *ASCII85Encoder )DecodeBytes (encoded []byte )([]byte ,error ){var _dgbd []byte ;_bf .Log .Trace ("\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0020\u0044e\u0063\u006f\u0064\u0065");_afd :=0;_edacb :=false ;for _afd < len (encoded )&&!_edacb {_edbd :=[5]byte {0,0,0,0,0};_fdadd :=0;_bfc :=0;_adeb :=4;for _bfc < 5+_fdadd {if _afd +_bfc ==len (encoded ){break ;};_gdef :=encoded [_afd +_bfc ];if IsWhiteSpace (_gdef ){_fdadd ++;_bfc ++;continue ;}else if _gdef =='~'&&_afd +_bfc +1< len (encoded )&&encoded [_afd +_bfc +1]=='>'{_adeb =(_bfc -_fdadd )-1;if _adeb < 0{_adeb =0;};_edacb =true ;break ;}else if _gdef >='!'&&_gdef <='u'{_gdef -='!';}else if _gdef =='z'&&_bfc -_fdadd ==0{_adeb =4;_bfc ++;break ;}else {_bf .Log .Error ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u002c\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020co\u0064\u0065");return nil ,_e .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0063\u006f\u0064\u0065\u0020e\u006e\u0063\u006f\u0075\u006e\u0074\u0065\u0072\u0065\u0064");};_edbd [_bfc -_fdadd ]=_gdef ;_bfc ++;};_afd +=_bfc ;for _affe :=_adeb +1;_affe < 5;_affe ++{_edbd [_affe ]=84;};_dafb :=uint32 (_edbd [0])*85*85*85*85+uint32 (_edbd [1])*85*85*85+uint32 (_edbd [2])*85*85+uint32 (_edbd [3])*85+uint32 (_edbd [4]);_cfce :=[]byte {byte ((_dafb >>24)&0xff),byte ((_dafb >>16)&0xff),byte ((_dafb >>8)&0xff),byte (_dafb &0xff)};_dgbd =append (_dgbd ,_cfce [:_adeb ]...);};_bf .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0065\u006e\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",encoded );_bf .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0064\u0065\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",_dgbd );return _dgbd ,nil ;};

// MakeStreamDict make a new instance of an encoding dictionary for a stream object.
func (_gdgd *ASCII85Encoder )MakeStreamDict ()*PdfObjectDictionary {_edef :=MakeDict ();_edef .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_gdgd .GetFilterName ()));return _edef ;};

// IsWhiteSpace checks if byte represents a white space character.
func IsWhiteSpace (ch byte )bool {if (ch ==0x00)||(ch ==0x09)||(ch ==0x0A)||(ch ==0x0C)||(ch ==0x0D)||(ch ==0x20){return true ;};return false ;};

// String returns a descriptive information string about the encryption method used.
func (_dbgc *PdfCrypt )String ()string {if _dbgc ==nil {return "";};_efe :=_dbgc ._gbe .Filter +"\u0020\u002d\u0020";if _dbgc ._gbe .V ==0{_efe +="\u0055\u006e\u0064\u006fcu\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0061\u006c\u0067\u006f\u0072\u0069\u0074h\u006d";}else if _dbgc ._gbe .V ==1{_efe +="\u0052\u0043\u0034:\u0020\u0034\u0030\u0020\u0062\u0069\u0074\u0073";}else if _dbgc ._gbe .V ==2{_efe +=_ce .Sprintf ("\u0052\u0043\u0034:\u0020\u0025\u0064\u0020\u0062\u0069\u0074\u0073",_dbgc ._gbe .Length );}else if _dbgc ._gbe .V ==3{_efe +="U\u006e\u0070\u0075\u0062li\u0073h\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d";}else if _dbgc ._gbe .V >=4{_efe +=_ce .Sprintf ("\u0053\u0074r\u0065\u0061\u006d\u0020f\u0069\u006ct\u0065\u0072\u003a\u0020\u0025\u0073\u0020\u002d \u0053\u0074\u0072\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0074\u0065r\u003a\u0020\u0025\u0073",_dbgc ._cbca ,_dbgc ._gbba );_efe +="\u003b\u0020C\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0073\u003a";for _gef ,_efg :=range _dbgc ._ecb {_efe +=_ce .Sprintf ("\u0020\u002d\u0020\u0025\u0073\u003a\u0020\u0025\u0073 \u0028\u0025\u0064\u0029",_gef ,_efg .Name (),_efg .KeyLength ());};};_fbcd :=_dbgc .GetAccessPermissions ();_efe +=_ce .Sprintf ("\u0020\u002d\u0020\u0025\u0023\u0076",_fbcd );return _efe ;};

// GetNumberAsFloat returns the contents of `obj` as a float if it is an integer or float, or an
// error if it isn't.
func GetNumberAsFloat (obj PdfObject )(float64 ,error ){switch _gdbfc :=obj .(type ){case *PdfObjectFloat :return float64 (*_gdbfc ),nil ;case *PdfObjectInteger :return float64 (*_gdbfc ),nil ;};return 0,ErrNotANumber ;};var _eddg =_dce .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064+\u0029\u005c\u0073\u002b\u0028\u005b\u006e\u0066\u005d\u0029\\\u0073\u002a\u0024");

// UpdateParams updates the parameter values of the encoder.
func (_fed *ASCIIHexEncoder )UpdateParams (params *PdfObjectDictionary ){};

// DecodeStream decodes a JPX encoded stream and returns the result as a
// slice of bytes.
func (_ccdcg *JPXEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_bf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_ccdcg .GetFilterName ());return streamObj .Stream ,ErrNoJPXDecode ;};

// DCTEncoder provides a DCT (JPG) encoding/decoding functionality for images.
type DCTEncoder struct{ColorComponents int ;BitsPerComponent int ;Width int ;Height int ;Quality int ;};

// UpdateParams updates the parameter values of the encoder.
func (_bbac *CCITTFaxEncoder )UpdateParams (params *PdfObjectDictionary ){if _fcc ,_gcce :=GetNumberAsInt64 (params .Get ("\u004b"));_gcce ==nil {_bbac .K =int (_fcc );};if _aafde ,_afda :=GetNumberAsInt64 (params .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));_afda ==nil {_bbac .Columns =int (_aafde );}else if _aafde ,_afda =GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));_afda ==nil {_bbac .Columns =int (_aafde );};if _edfe ,_acae :=GetNumberAsInt64 (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_acae ==nil {_bbac .BlackIs1 =_edfe > 0;}else {if _daaf ,_egfd :=GetBoolVal (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_egfd {_bbac .BlackIs1 =_daaf ;}else {if _abgaa ,_aagd :=GetArray (params .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));_aagd {_dgdf ,_cdee :=_abgaa .ToIntegerArray ();if _cdee ==nil {_bbac .BlackIs1 =_dgdf [0]==1&&_dgdf [1]==0;};};};};if _ddd ,_faeb :=GetNumberAsInt64 (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_faeb ==nil {_bbac .EncodedByteAlign =_ddd > 0;}else {if _cddd ,_daef :=GetBoolVal (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_daef {_bbac .EncodedByteAlign =_cddd ;};};if _bee ,_bffd :=GetNumberAsInt64 (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_bffd ==nil {_bbac .EndOfLine =_bee > 0;}else {if _dece ,_efac :=GetBoolVal (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_efac {_bbac .EndOfLine =_dece ;};};if _adaf ,_dffbf :=GetNumberAsInt64 (params .Get ("\u0052\u006f\u0077\u0073"));_dffbf ==nil {_bbac .Rows =int (_adaf );}else if _adaf ,_dffbf =GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));_dffbf ==nil {_bbac .Rows =int (_adaf );};if _aceb ,_egfbb :=GetNumberAsInt64 (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_egfbb ==nil {_bbac .EndOfBlock =_aceb > 0;}else {if _bfeb ,_baea :=GetBoolVal (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_baea {_bbac .EndOfBlock =_bfeb ;};};if _baff ,_dacd :=GetNumberAsInt64 (params .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));_dacd !=nil {_bbac .DamagedRowsBeforeError =int (_baff );};};

// IsEncrypted checks if the document is encrypted. A bool flag is returned indicating the result.
// First time when called, will check if the Encrypt dictionary is accessible through the trailer dictionary.
// If encrypted, prepares a crypt datastructure which can be used to authenticate and decrypt the document.
// On failure, an error is returned.
func (_gdce *PdfParser )IsEncrypted ()(bool ,error ){if _gdce ._aggc !=nil {return true ,nil ;}else if _gdce ._caec ==nil {return false ,nil ;};_bf .Log .Trace ("\u0043\u0068\u0065c\u006b\u0069\u006e\u0067 \u0065\u006e\u0063\u0072\u0079\u0070\u0074i\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0021");_adgc :=_gdce ._caec .Get ("\u0045n\u0063\u0072\u0079\u0070\u0074");if _adgc ==nil {return false ,nil ;};_bf .Log .Trace ("\u0049\u0073\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u0021");var (_bfdge *PdfObjectDictionary ;);switch _edebf :=_adgc .(type ){case *PdfObjectDictionary :_bfdge =_edebf ;case *PdfObjectReference :_bf .Log .Trace ("\u0030\u003a\u0020\u004c\u006f\u006f\u006b\u0020\u0075\u0070\u0020\u0072e\u0066\u0020\u0025\u0071",_edebf );_abab ,_ebgf :=_gdce .LookupByReference (*_edebf );_bf .Log .Trace ("\u0031\u003a\u0020%\u0071",_abab );if _ebgf !=nil {return false ,_ebgf ;};_egga ,_gfaf :=_abab .(*PdfIndirectObject );if !_gfaf {_bf .Log .Debug ("E\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006eo\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072ec\u0074\u0020\u006fb\u006ae\u0063\u0074");return false ,_e .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");};_dacde ,_gfaf :=_egga .PdfObject .(*PdfObjectDictionary );_bf .Log .Trace ("\u0032\u003a\u0020%\u0071",_dacde );if !_gfaf {return false ,_e .New ("\u0074\u0072a\u0069\u006c\u0065\u0072 \u0045\u006ec\u0072\u0079\u0070\u0074\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u006e\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");};_bfdge =_dacde ;case *PdfObjectNull :_bf .Log .Debug ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074 \u0069\u0073\u0020a\u0020\u006e\u0075l\u006c\u0020o\u0062\u006a\u0065\u0063\u0074\u002e \u0046il\u0065\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u002e");return false ,nil ;default:return false ,_ce .Errorf ("u\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0079\u0070\u0065: \u0025\u0054",_edebf );};_acab ,_cedcc :=PdfCryptNewDecrypt (_gdce ,_bfdge ,_gdce ._caec );if _cedcc !=nil {return false ,_cedcc ;};for _ ,_edba :=range []string {"\u0045n\u0063\u0072\u0079\u0070\u0074"}{_bdbd :=_gdce ._caec .Get (PdfObjectName (_edba ));if _bdbd ==nil {continue ;};switch _edbgd :=_bdbd .(type ){case *PdfObjectReference :_acab ._fea [int (_edbgd .ObjectNumber )]=struct{}{};case *PdfIndirectObject :_acab ._fgc [_edbgd ]=true ;_acab ._fea [int (_edbgd .ObjectNumber )]=struct{}{};};};_gdce ._aggc =_acab ;_bf .Log .Trace ("\u0043\u0072\u0079\u0070\u0074\u0065\u0072\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0025\u0062",_acab );return true ,nil ;};

// ToGoImage converts the JBIG2Image to the golang image.Image.
func (_fbcc *JBIG2Image )ToGoImage ()(_dd .Image ,error ){const _bde ="J\u0042I\u0047\u0032\u0049\u006d\u0061\u0067\u0065\u002eT\u006f\u0047\u006f\u0049ma\u0067\u0065";if _fbcc .Data ==nil {return nil ,_fg .Error (_bde ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");};if _fbcc .Width ==0||_fbcc .Height ==0{return nil ,_fg .Error (_bde ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");};_ggba ,_gecf :=_aa .NewImage (_fbcc .Width ,_fbcc .Height ,1,1,_fbcc .Data ,nil ,nil );if _gecf !=nil {return nil ,_gecf ;};return _ggba ,nil ;};

// DecodeBytes decodes a slice of LZW encoded bytes and returns the result.
func (_fbfa *LZWEncoder )DecodeBytes (encoded []byte )([]byte ,error ){var _ffaf _fb .Buffer ;_aeca :=_fb .NewReader (encoded );var _fbe _aba .ReadCloser ;if _fbfa .EarlyChange ==1{_fbe =_de .NewReader (_aeca ,_de .MSB ,8);}else {_fbe =_ad .NewReader (_aeca ,_ad .MSB ,8);};defer _fbe .Close ();if _ ,_dgef :=_ffaf .ReadFrom (_fbe );_dgef !=nil {if _dgef !=_aba .ErrUnexpectedEOF ||_ffaf .Len ()==0{return nil ,_dgef ;};_bf .Log .Debug ("\u0057\u0041\u0052\u004e\u003a\u0020\u004c\u005a\u0057\u0020\u0064\u0065\u0063\u006f\u0064i\u006e\u0067\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076\u002e \u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062e \u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u002e",_dgef );};return _ffaf .Bytes (),nil ;};

// NewParserFromString is used for testing purposes.
func NewParserFromString (txt string )*PdfParser {_fbad :=_fb .NewReader ([]byte (txt ));_ddgd :=&PdfParser {ObjCache :objectCache {},_aagc :_fbad ,_bdc :_ac .NewReader (_fbad ),_fcda :int64 (len (txt )),_ffdfa :map[int64 ]bool {}};_ddgd ._bbfg .ObjectMap =make (map[int ]XrefObject );return _ddgd ;};

// GetIndirect returns the *PdfIndirectObject represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetIndirect (obj PdfObject )(_deed *PdfIndirectObject ,_bcaa bool ){obj =ResolveReference (obj );_deed ,_bcaa =obj .(*PdfIndirectObject );return _deed ,_bcaa ;};

// IsOctalDigit checks if a character can be part of an octal digit string.
func IsOctalDigit (c byte )bool {return '0'<=c &&c <='7'};

// UpdateParams updates the parameter values of the encoder.
func (_ggfc *JPXEncoder )UpdateParams (params *PdfObjectDictionary ){};func (_gfgb *PdfParser )repairSeekXrefMarker ()error {_agda ,_facc :=_gfgb ._aagc .Seek (0,_aba .SeekEnd );if _facc !=nil {return _facc ;};_gfad :=_dce .MustCompile ("\u005cs\u0078\u0072\u0065\u0066\u005c\u0073*");var _dgfc int64 ;var _bdbcb int64 =1000;for _dgfc < _agda {if _agda <=(_bdbcb +_dgfc ){_bdbcb =_agda -_dgfc ;};_ ,_fdfee :=_gfgb ._aagc .Seek (-_dgfc -_bdbcb ,_aba .SeekEnd );if _fdfee !=nil {return _fdfee ;};_abag :=make ([]byte ,_bdbcb );_gfgb ._aagc .Read (_abag );_bf .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0078\u0072\u0065\u0066\u0020\u003a\u0020\u0022\u0025\u0073\u0022",string (_abag ));_dfgcbc :=_gfad .FindAllStringIndex (string (_abag ),-1);if _dfgcbc !=nil {_dbde :=_dfgcbc [len (_dfgcbc )-1];_bf .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_dfgcbc );_gfgb ._aagc .Seek (-_dgfc -_bdbcb +int64 (_dbde [0]),_aba .SeekEnd );_gfgb ._bdc =_ac .NewReader (_gfgb ._aagc );for {_bgaf ,_aacf :=_gfgb ._bdc .Peek (1);if _aacf !=nil {return _aacf ;};_bf .Log .Trace ("\u0042\u003a\u0020\u0025\u0064\u0020\u0025\u0063",_bgaf [0],_bgaf [0]);if !IsWhiteSpace (_bgaf [0]){break ;};_gfgb ._bdc .Discard (1);};return nil ;};_bf .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");_dgfc +=_bdbcb ;};_bf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074a\u0062\u006c\u0065\u0020\u006d\u0061r\u006b\u0065\u0072\u0020\u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066o\u0075\u006e\u0064\u002e");return _e .New ("\u0078r\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0020");};

// UpdateParams updates the parameter values of the encoder.
func (_ebfa *RawEncoder )UpdateParams (params *PdfObjectDictionary ){};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_cedc *CCITTFaxEncoder )MakeStreamDict ()*PdfObjectDictionary {_gdgc :=MakeDict ();_gdgc .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_cedc .GetFilterName ()));_faaad :=_cedc .MakeDecodeParams ();if _faaad !=nil {_gdgc .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_faaad );};return _gdgc ;};

// PdfObject is an interface which all primitive PDF objects must implement.
type PdfObject interface{

// String outputs a string representation of the primitive (for debugging).
String ()string ;

// WriteString outputs the PDF primitive as written to file as expected by the standard.
// TODO(dennwc): it should return a byte slice, or accept a writer
WriteString ()string ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_fafg *MultiEncoder )MakeStreamDict ()*PdfObjectDictionary {_gefdb :=MakeDict ();_gefdb .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",_fafg .GetFilterArray ());for _ ,_edbgf :=range _fafg ._gbag {_beeb :=_edbgf .MakeStreamDict ();for _ ,_fcba :=range _beeb .Keys (){_gdefa :=_beeb .Get (_fcba );if _fcba !="\u0046\u0069\u006c\u0074\u0065\u0072"&&_fcba !="D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"{_gefdb .Set (_fcba ,_gdefa );};};};_dadce :=_fafg .MakeDecodeParams ();if _dadce !=nil {_gefdb .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_dadce );};return _gefdb ;};

// String returns a string describing `streams`.
func (_fdfe *PdfObjectStreams )String ()string {return _ce .Sprintf ("\u004f\u0062j\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0025\u0064",_fdfe .ObjectNumber );};

// GoImageToJBIG2 creates a binary image on the base of 'i' golang image.Image.
// If the image is not a black/white image then the function converts provided input into
// JBIG2Image with 1bpp. For non grayscale images the function performs the conversion to the grayscale temp image.
// Then it checks the value of the gray image value if it's within bounds of the black white threshold.
// This 'bwThreshold' value should be in range (0.0, 1.0). The threshold checks if the grayscale pixel (uint) value
// is greater or smaller than 'bwThreshold' * 255. Pixels inside the range will be white, and the others will be black.
// If the 'bwThreshold' is equal to -1.0 - JB2ImageAutoThreshold then it's value would be set on the base of
// it's histogram using Triangle method. For more information go to:
// 	https://www.mathworks.com/matlabcentral/fileexchange/28047-gray-image-thresholding-using-the-triangle-method
func GoImageToJBIG2 (i _dd .Image ,bwThreshold float64 )(*JBIG2Image ,error ){const _deee ="\u0047\u006f\u0049\u006d\u0061\u0067\u0065\u0054\u006fJ\u0042\u0049\u0047\u0032";if i ==nil {return nil ,_fg .Error (_deee ,"i\u006d\u0061\u0067\u0065 '\u0069'\u0020\u006e\u006f\u0074\u0020d\u0065\u0066\u0069\u006e\u0065\u0064");};var (_eafa uint8 ;_fcd _aa .Image ;_dbfb error ;);if bwThreshold ==JB2ImageAutoThreshold {_fcd ,_dbfb =_aa .MonochromeConverter .Convert (i );}else if bwThreshold > 1.0||bwThreshold < 0.0{return nil ,_fg .Error (_deee ,"p\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074h\u0072\u0065\u0073\u0068\u006f\u006c\u0064 i\u0073\u0020\u006e\u006ft\u0020\u0069\u006e\u0020\u0061\u0020\u0072\u0061\u006ege\u0020\u007b0\u002e\u0030\u002c\u0020\u0031\u002e\u0030\u007d");}else {_eafa =uint8 (255*bwThreshold );_fcd ,_dbfb =_aa .MonochromeThresholdConverter (_eafa ).Convert (i );};if _dbfb !=nil {return nil ,_dbfb ;};return _caae (_fcd ),nil ;};

// MakeBool creates a PdfObjectBool from a bool value.
func MakeBool (val bool )*PdfObjectBool {_cece :=PdfObjectBool (val );return &_cece };

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set.  Some other parameters are generated elsewhere.
func (_gcfae *DCTEncoder )MakeStreamDict ()*PdfObjectDictionary {_dfa :=MakeDict ();_dfa .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_gcfae .GetFilterName ()));return _dfa ;};

// DecodeBytes decodes a slice of JPX encoded bytes and returns the result.
func (_fba *JPXEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_bf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_fba .GetFilterName ());return encoded ,ErrNoJPXDecode ;};

// DecodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_fbfad *RawEncoder )DecodeBytes (encoded []byte )([]byte ,error ){return encoded ,nil };

// JBIG2CompressionType defines the enum compression type used by the JBIG2Encoder.
type JBIG2CompressionType int ;func (_dcac *PdfParser )parsePdfVersion ()(int ,int ,error ){var _degc int64 =20;_baga :=make ([]byte ,_degc );_dcac ._aagc .Seek (0,_aba .SeekStart );_dcac ._aagc .Read (_baga );var _afed error ;var _adgf ,_feeeg int ;if _edbe :=_gacf .FindStringSubmatch (string (_baga ));len (_edbe )< 3{if _adgf ,_feeeg ,_afed =_dcac .seekPdfVersionTopDown ();_afed !=nil {_bf .Log .Debug ("F\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065\u0063\u006f\u0076\u0065\u0072\u0079\u0020\u002d\u0020\u0075n\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0066\u0069nd\u0020\u0076\u0065r\u0073i\u006f\u006e");return 0,0,_afed ;};_dcac ._aagc ,_afed =_cccgg (_dcac ._aagc ,_dcac .GetFileOffset ()-8);if _afed !=nil {return 0,0,_afed ;};}else {if _adgf ,_afed =_dc .Atoi (_edbe [1]);_afed !=nil {return 0,0,_afed ;};if _feeeg ,_afed =_dc .Atoi (_edbe [2]);_afed !=nil {return 0,0,_afed ;};_dcac .SetFileOffset (0);};_dcac ._bdc =_ac .NewReader (_dcac ._aagc );_bf .Log .Debug ("\u0050\u0064\u0066\u0020\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020%\u0064\u002e\u0025\u0064",_adgf ,_feeeg );return _adgf ,_feeeg ,nil ;};

// IsPrintable checks if a character is printable.
// Regular characters that are outside the range EXCLAMATION MARK(21h)
// (!) to TILDE (7Eh) (~) should be written using the hexadecimal notation.
func IsPrintable (c byte )bool {return 0x21<=c &&c <=0x7E};func (_ebdd *PdfParser )skipComments ()error {if _ ,_beeg :=_ebdd .skipSpaces ();_beeg !=nil {return _beeg ;};_affb :=true ;for {_dagcg ,_ffbb :=_ebdd ._bdc .Peek (1);if _ffbb !=nil {_bf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_ffbb .Error ());return _ffbb ;};if _affb &&_dagcg [0]!='%'{return nil ;};_affb =false ;if (_dagcg [0]!='\r')&&(_dagcg [0]!='\n'){_ebdd ._bdc .ReadByte ();}else {break ;};};return _ebdd .skipComments ();};

// Len returns the number of elements in the streams.
func (_bedf *PdfObjectStreams )Len ()int {if _bedf ==nil {return 0;};return len (_bedf ._adca );};func _dgf (_dca PdfObject )(int64 ,int64 ,error ){if _ada ,_gad :=_dca .(*PdfIndirectObject );_gad {return _ada .ObjectNumber ,_ada .GenerationNumber ,nil ;};if _dga ,_aad :=_dca .(*PdfObjectStream );_aad {return _dga .ObjectNumber ,_dga .GenerationNumber ,nil ;};return 0,0,_e .New ("\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u002f\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062je\u0063\u0074");};

// GetIntVal returns the int value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetIntVal (obj PdfObject )(_efbe int ,_eegd bool ){_bbbe ,_eegd :=TraceToDirectObject (obj ).(*PdfObjectInteger );if _eegd &&_bbbe !=nil {return int (*_bbbe ),true ;};return 0,false ;};func (_gfbb *PdfParser )parseString ()(*PdfObjectString ,error ){_gfbb ._bdc .ReadByte ();var _gbge _fb .Buffer ;_fdbe :=1;for {_dedba ,_egae :=_gfbb ._bdc .Peek (1);if _egae !=nil {return MakeString (_gbge .String ()),_egae ;};if _dedba [0]=='\\'{_gfbb ._bdc .ReadByte ();_cfbe ,_ebgc :=_gfbb ._bdc .ReadByte ();if _ebgc !=nil {return MakeString (_gbge .String ()),_ebgc ;};if IsOctalDigit (_cfbe ){_efd ,_gbbb :=_gfbb ._bdc .Peek (2);if _gbbb !=nil {return MakeString (_gbge .String ()),_gbbb ;};var _ceeb []byte ;_ceeb =append (_ceeb ,_cfbe );for _ ,_ddae :=range _efd {if IsOctalDigit (_ddae ){_ceeb =append (_ceeb ,_ddae );}else {break ;};};_gfbb ._bdc .Discard (len (_ceeb )-1);_bf .Log .Trace ("\u004e\u0075\u006d\u0065ri\u0063\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0022\u0025\u0073\u0022",_ceeb );_ggdc ,_gbbb :=_dc .ParseUint (string (_ceeb ),8,32);if _gbbb !=nil {return MakeString (_gbge .String ()),_gbbb ;};_gbge .WriteByte (byte (_ggdc ));continue ;};switch _cfbe {case 'n':_gbge .WriteRune ('\n');case 'r':_gbge .WriteRune ('\r');case 't':_gbge .WriteRune ('\t');case 'b':_gbge .WriteRune ('\b');case 'f':_gbge .WriteRune ('\f');case '(':_gbge .WriteRune ('(');case ')':_gbge .WriteRune (')');case '\\':_gbge .WriteRune ('\\');};continue ;}else if _dedba [0]=='('{_fdbe ++;}else if _dedba [0]==')'{_fdbe --;if _fdbe ==0{_gfbb ._bdc .ReadByte ();break ;};};_dead ,_ :=_gfbb ._bdc .ReadByte ();_gbge .WriteByte (_dead );};return MakeString (_gbge .String ()),nil ;};func (_gfgd *PdfParser )xrefNextObjectOffset (_eaec int64 )int64 {_gbbag :=int64 (0);if len (_gfgd ._bbfg .ObjectMap )==0{return 0;};if len (_gfgd ._bbfg ._be )==0{_ccce :=0;for _ ,_agfc :=range _gfgd ._bbfg .ObjectMap {if _agfc .Offset > 0{_ccce ++;};};if _ccce ==0{return 0;};_gfgd ._bbfg ._be =make ([]XrefObject ,_ccce );_dfdf :=0;for _ ,_afbb :=range _gfgd ._bbfg .ObjectMap {if _afbb .Offset > 0{_gfgd ._bbfg ._be [_dfdf ]=_afbb ;_dfdf ++;};};_b .Slice (_gfgd ._bbfg ._be ,func (_cgbg ,_cdc int )bool {return _gfgd ._bbfg ._be [_cgbg ].Offset < _gfgd ._bbfg ._be [_cdc ].Offset });};_fcdb :=_b .Search (len (_gfgd ._bbfg ._be ),func (_ddcg int )bool {return _gfgd ._bbfg ._be [_ddcg ].Offset >=_eaec });if _fcdb < len (_gfgd ._bbfg ._be ){_gbbag =_gfgd ._bbfg ._be [_fcdb ].Offset ;};return _gbbag ;};

// DrawableImage is same as golang image/draw's Image interface that allow drawing images.
type DrawableImage interface{ColorModel ()_bg .Model ;Bounds ()_dd .Rectangle ;At (_agfa ,_bcegf int )_bg .Color ;Set (_efee ,_dfe int ,_ebg _bg .Color );};var (ErrUnsupportedEncodingParameters =_e .New ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074\u0065\u0072\u0073");ErrNoCCITTFaxDecode =_e .New ("\u0043\u0043I\u0054\u0054\u0046\u0061\u0078\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");ErrNoJBIG2Decode =_e .New ("\u004a\u0042\u0049\u0047\u0032\u0044\u0065c\u006f\u0064\u0065 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");ErrNoJPXDecode =_e .New ("\u004a\u0050\u0058\u0044\u0065c\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020i\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");ErrNoPdfVersion =_e .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");ErrTypeError =_e .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");ErrRangeError =_e .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");ErrNotSupported =_gd .New ("\u0066\u0065\u0061t\u0075\u0072\u0065\u0020n\u006f\u0074\u0020\u0063\u0075\u0072\u0072e\u006e\u0074\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");ErrNotANumber =_e .New ("\u006e\u006f\u0074 \u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072"););

// GetAsFloat64Slice returns the array as []float64 slice.
// Returns an error if not entirely numeric (only PdfObjectIntegers, PdfObjectFloats).
func (_afcf *PdfObjectArray )GetAsFloat64Slice ()([]float64 ,error ){var _cefe []float64 ;for _ ,_dbfa :=range _afcf .Elements (){_aggg ,_effg :=GetNumberAsFloat (TraceToDirectObject (_dbfa ));if _effg !=nil {return nil ,_ce .Errorf ("\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006e\u0075m\u0062\u0065\u0072");};_cefe =append (_cefe ,_aggg );};return _cefe ,nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_gdcc *JBIG2Encoder )MakeStreamDict ()*PdfObjectDictionary {_ebda :=MakeDict ();_ebda .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_gdcc .GetFilterName ()));return _ebda ;};func _febbc (_fadd string )(int ,int ,error ){_efed :=_dbgg .FindStringSubmatch (_fadd );if len (_efed )< 3{return 0,0,_e .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");};_ecgg ,_ :=_dc .Atoi (_efed [1]);_afbab ,_ :=_dc .Atoi (_efed [2]);return _ecgg ,_afbab ,nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_dcca *JPXEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};

// GetStringBytes is like GetStringVal except that it returns the string as a []byte.
// It is for convenience.
func GetStringBytes (obj PdfObject )(_afgbc []byte ,_bgca bool ){_afcd ,_bgca :=TraceToDirectObject (obj ).(*PdfObjectString );if _bgca {return _afcd .Bytes (),true ;};return ;};

// Clear resets the dictionary to an empty state.
func (_bbfda *PdfObjectDictionary )Clear (){_bbfda ._eaef =[]PdfObjectName {};_bbfda ._ffca =map[PdfObjectName ]PdfObject {};};

// XrefTable represents the cross references in a PDF, i.e. the table of objects and information
// where to access within the PDF file.
type XrefTable struct{ObjectMap map[int ]XrefObject ;_be []XrefObject ;};

// StreamEncoder represents the interface for all PDF stream encoders.
type StreamEncoder interface{GetFilterName ()string ;MakeDecodeParams ()PdfObject ;MakeStreamDict ()*PdfObjectDictionary ;UpdateParams (_eac *PdfObjectDictionary );EncodeBytes (_gcf []byte )([]byte ,error );DecodeBytes (_bdf []byte )([]byte ,error );DecodeStream (_dfc *PdfObjectStream )([]byte ,error );};

// Set sets the dictionary's key -> val mapping entry. Overwrites if key already set.
func (_facdg *PdfObjectDictionary )Set (key PdfObjectName ,val PdfObject ){_ ,_gdaa :=_facdg ._ffca [key ];if !_gdaa {_facdg ._eaef =append (_facdg ._eaef ,key );};_facdg ._ffca [key ]=val ;};type encryptDict struct{Filter string ;V int ;SubFilter string ;Length int ;StmF string ;StrF string ;EFF string ;CF map[string ]_ecf .FilterDict ;};

// PdfParser parses a PDF file and provides access to the object structure of the PDF.
type PdfParser struct{_eaagd Version ;_aagc _aba .ReadSeeker ;_bdc *_ac .Reader ;_fcda int64 ;_bbfg XrefTable ;_addb int64 ;_eaba *xrefType ;_cbde objectStreams ;_caec *PdfObjectDictionary ;_aggc *PdfCrypt ;_bbacb bool ;ObjCache objectCache ;_bgec map[int ]bool ;_ffdfa map[int64 ]bool ;};func (_afca *PdfCrypt )loadCryptFilters (_gab *PdfObjectDictionary )error {_afca ._ecb =cryptFilters {};_bbg :=_gab .Get ("\u0043\u0046");_bbg =TraceToDirectObject (_bbg );if _gac ,_cea :=_bbg .(*PdfObjectReference );_cea {_bfe ,_aaga :=_afca ._cg .LookupByReference (*_gac );if _aaga !=nil {_bf .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0075\u0070\u0020\u0043\u0046\u0020\u0072\u0065\u0066\u0065\u0072en\u0063\u0065");return _aaga ;};_bbg =TraceToDirectObject (_bfe );};_cbce ,_egc :=_bbg .(*PdfObjectDictionary );if !_egc {_bf .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0043\u0046\u002c \u0074\u0079\u0070\u0065: \u0025\u0054",_bbg );return _e .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0043\u0046");};for _ ,_dac :=range _cbce .Keys (){_cdf :=_cbce .Get (_dac );if _dccf ,_cfbc :=_cdf .(*PdfObjectReference );_cfbc {_ecg ,_gdc :=_afca ._cg .LookupByReference (*_dccf );if _gdc !=nil {_bf .Log .Debug ("\u0045\u0072ro\u0072\u0020\u006co\u006f\u006b\u0075\u0070 up\u0020di\u0063\u0074\u0069\u006f\u006e\u0061\u0072y \u0072\u0065\u0066\u0065\u0072\u0065\u006ec\u0065");return _gdc ;};_cdf =TraceToDirectObject (_ecg );};_ddee ,_abdb :=_cdf .(*PdfObjectDictionary );if !_abdb {return _ce .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074\u0020\u0069\u006e \u0043\u0046\u0020\u0028\u006e\u0061\u006d\u0065\u0020\u0025\u0073\u0029\u0020-\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079\u0020\u0062\u0075\u0074\u0020\u0025\u0054",_dac ,_cdf );};if _dac =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{_bf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u002d\u0020\u0043\u0061\u006e\u006e\u006f\u0074\u0020\u006f\u0076\u0065\u0072\u0077r\u0069\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0069d\u0065\u006e\u0074\u0069\u0074\u0079\u0020\u0066\u0069\u006c\u0074\u0065\u0072 \u002d\u0020\u0054\u0072\u0079\u0069n\u0067\u0020\u006ee\u0078\u0074");continue ;};var _afa _ecf .FilterDict ;if _aga :=_bbb (&_afa ,_ddee );_aga !=nil {return _aga ;};_ffg ,_ffbc :=_ecf .NewFilter (_afa );if _ffbc !=nil {return _ffbc ;};_afca ._ecb [string (_dac )]=_ffg ;};_afca ._ecb ["\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"]=_ecf .NewIdentity ();_afca ._gbba ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _fdf ,_bbba :=_gab .Get ("\u0053\u0074\u0072\u0046").(*PdfObjectName );_bbba {if _ ,_dcb :=_afca ._ecb [string (*_fdf )];!_dcb {return _ce .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u0072\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_fdf );};_afca ._gbba =string (*_fdf );};_afca ._cbca ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _aee ,_fdc :=_gab .Get ("\u0053\u0074\u006d\u0046").(*PdfObjectName );_fdc {if _ ,_fdg :=_afca ._ecb [string (*_aee )];!_fdg {return _ce .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u006d\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_aee );};_afca ._cbca =string (*_aee );};return nil ;};

// GetXrefTable returns the PDFs xref table.
func (_baee *PdfParser )GetXrefTable ()XrefTable {return _baee ._bbfg };

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_gee *LZWEncoder )MakeStreamDict ()*PdfObjectDictionary {_fbbf :=MakeDict ();_fbbf .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_gee .GetFilterName ()));_adb :=_gee .MakeDecodeParams ();if _adb !=nil {_fbbf .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_adb );};_fbbf .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (int64 (_gee .EarlyChange )));return _fbbf ;};

// MakeEncodedString creates a PdfObjectString with encoded content, which can be either
// UTF-16BE or PDFDocEncoding depending on whether `utf16BE` is true or false respectively.
func MakeEncodedString (s string ,utf16BE bool )*PdfObjectString {if utf16BE {var _becdc _fb .Buffer ;_becdc .Write ([]byte {0xFE,0xFF});_becdc .WriteString (_ae .StringToUTF16 (s ));return &PdfObjectString {_gcae :_becdc .String (),_efgcb :true };};return &PdfObjectString {_gcae :string (_ae .StringToPDFDocEncoding (s )),_efgcb :false };};

// EncodeStream encodes the stream data using the encoded specified by the stream's dictionary.
func EncodeStream (streamObj *PdfObjectStream )error {_bf .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_fgaff ,_ccdd :=NewEncoderFromStream (streamObj );if _ccdd !=nil {_bf .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_ccdd );return _ccdd ;};if _bgegb ,_gfbd :=_fgaff .(*LZWEncoder );_gfbd {_bgegb .EarlyChange =0;streamObj .PdfObjectDictionary .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (0));};_bf .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076\u000a",_fgaff );_dgge ,_ccdd :=_fgaff .EncodeBytes (streamObj .Stream );if _ccdd !=nil {_bf .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_ccdd );return _ccdd ;};streamObj .Stream =_dgge ;streamObj .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_dgge ))));return nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_acaa *RunLengthEncoder )MakeDecodeParams ()PdfObject {return nil };

// ParseDict reads and parses a PDF dictionary object enclosed with '<<' and '>>'
func (_gdddc *PdfParser )ParseDict ()(*PdfObjectDictionary ,error ){_bf .Log .Trace ("\u0052\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020D\u0069\u0063\u0074\u0021");_gafe :=MakeDict ();_gafe ._ddgdd =_gdddc ;_dba ,_ :=_gdddc ._bdc .ReadByte ();if _dba !='<'{return nil ,_e .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");};_dba ,_ =_gdddc ._bdc .ReadByte ();if _dba !='<'{return nil ,_e .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");};for {_gdddc .skipSpaces ();_gdddc .skipComments ();_caea ,_eefd :=_gdddc ._bdc .Peek (2);if _eefd !=nil {return nil ,_eefd ;};_bf .Log .Trace ("D\u0069c\u0074\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_caea ),string (_caea ));if (_caea [0]=='>')&&(_caea [1]=='>'){_bf .Log .Trace ("\u0045\u004f\u0046\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");_gdddc ._bdc .ReadByte ();_gdddc ._bdc .ReadByte ();break ;};_bf .Log .Trace ("\u0050a\u0072s\u0065\u0020\u0074\u0068\u0065\u0020\u006e\u0061\u006d\u0065\u0021");_efgd ,_eefd :=_gdddc .parseName ();_bf .Log .Trace ("\u004be\u0079\u003a\u0020\u0025\u0073",_efgd );if _eefd !=nil {_bf .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0052e\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006ea\u006d\u0065\u0020e\u0072r\u0020\u0025\u0073",_eefd );return nil ,_eefd ;};if len (_efgd )> 4&&_efgd [len (_efgd )-4:]=="\u006e\u0075\u006c\u006c"{_efea :=_efgd [0:len (_efgd )-4];_bf .Log .Debug ("\u0054\u0061\u006b\u0069n\u0067\u0020\u0063\u0061\u0072\u0065\u0020\u006f\u0066\u0020n\u0075l\u006c\u0020\u0062\u0075\u0067\u0020\u0028%\u0073\u0029",_efgd );_bf .Log .Debug ("\u004e\u0065\u0077\u0020ke\u0079\u0020\u0022\u0025\u0073\u0022\u0020\u003d\u0020\u006e\u0075\u006c\u006c",_efea );_gdddc .skipSpaces ();_dbcf ,_ :=_gdddc ._bdc .Peek (1);if _dbcf [0]=='/'{_gafe .Set (_efea ,MakeNull ());continue ;};};_gdddc .skipSpaces ();_aeda ,_eefd :=_gdddc .parseObject ();if _eefd !=nil {return nil ,_eefd ;};_gafe .Set (_efgd ,_aeda );if _bf .Log .IsLogLevel (_bf .LogLevelTrace ){_bf .Log .Trace ("\u0064\u0069\u0063\u0074\u005b\u0025\u0073\u005d\u0020\u003d\u0020\u0025\u0073",_efgd ,_aeda .String ());};};_bf .Log .Trace ("\u0072\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020\u0044\u0069\u0063\u0074\u0021");return _gafe ,nil ;};

// CCITTFaxEncoder implements Group3 and Group4 facsimile (fax) encoder/decoder.
type CCITTFaxEncoder struct{K int ;EndOfLine bool ;EncodedByteAlign bool ;Columns int ;Rows int ;EndOfBlock bool ;BlackIs1 bool ;DamagedRowsBeforeError int ;};

// GetXrefType returns the type of the first xref object (table or stream).
func (_bcca *PdfParser )GetXrefType ()*xrefType {return _bcca ._eaba };

// DecodeStream decodes a multi-encoded stream by passing it through the
// DecodeStream method of the underlying encoders.
func (_agfag *MultiEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _agfag .DecodeBytes (streamObj .Stream );};

// IsDecimalDigit checks if the character is a part of a decimal number string.
func IsDecimalDigit (c byte )bool {return '0'<=c &&c <='9'};

// Validate validates the page settings for the JBIG2 encoder.
func (_cffg JBIG2EncoderSettings )Validate ()error {const _gcca ="\u0076a\u006ci\u0064\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065\u0072";if _cffg .Threshold < 0||_cffg .Threshold > 1.0{return _fg .Errorf (_gcca ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074\u0068\u0072\u0065\u0073\u0068\u006f\u006c\u0064\u0020\u0076a\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0076\u0027 \u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0069\u006e\u0020\u0072\u0061n\u0067\u0065\u0020\u005b\u0030\u002e0\u002c\u0020\u0031.\u0030\u005d",_cffg .Threshold );};if _cffg .ResolutionX < 0{return _fg .Errorf (_gcca ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0078\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_cffg .ResolutionX );};if _cffg .ResolutionY < 0{return _fg .Errorf (_gcca ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0079\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_cffg .ResolutionY );};if _cffg .DefaultPixelValue !=0&&_cffg .DefaultPixelValue !=1{return _fg .Errorf (_gcca ,"de\u0066\u0061u\u006c\u0074\u0020\u0070\u0069\u0078\u0065\u006c\u0020v\u0061\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0066o\u0072 \u0074\u0068\u0065\u0020\u0062\u0069\u0074\u003a \u007b0\u002c\u0031}",_cffg .DefaultPixelValue );};if _cffg .Compression !=JB2Generic {return _fg .Errorf (_gcca ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065d\u0020\u0063\u006fm\u0070\u0072\u0065\u0073s\u0069\u006f\u006e\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");};return nil ;};

// String returns the PDF version as a string. Implements interface fmt.Stringer.
func (_adfa Version )String ()string {return _ce .Sprintf ("\u00250\u0064\u002e\u0025\u0030\u0064",_adfa .Major ,_adfa .Minor );};

// Keys returns the list of keys in the dictionary.
// If `d` is nil returns a nil slice.
func (_dgdee *PdfObjectDictionary )Keys ()[]PdfObjectName {if _dgdee ==nil {return nil ;};return _dgdee ._eaef ;};

// EncodeBytes DCT encodes the passed in slice of bytes.
func (_bbbc *DCTEncoder )EncodeBytes (data []byte )([]byte ,error ){_cgef ,_faaa :=_aa .NewImage (_bbbc .Width ,_bbbc .Height ,_bbbc .BitsPerComponent ,_bbbc .ColorComponents ,data ,nil ,nil );if _faaa !=nil {return nil ,_faaa ;};_fgd :=_g .Options {};_fgd .Quality =_bbbc .Quality ;var _ffag _fb .Buffer ;if _faaa =_g .Encode (&_ffag ,_cgef ,&_fgd );_faaa !=nil {return nil ,_faaa ;};return _ffag .Bytes (),nil ;};

// NewJBIG2Encoder creates a new JBIG2Encoder.
func NewJBIG2Encoder ()*JBIG2Encoder {return &JBIG2Encoder {_ddfd :_ca .InitEncodeDocument (false )}};var _cace =_dce .MustCompile ("\u005b\\\u0072\u005c\u006e\u005d\u005c\u0073\u002a\u0028\u0078\u0072\u0065f\u0029\u005c\u0073\u002a\u005b\u005c\u0072\u005c\u006e\u005d");

// GetFilterName returns the name of the encoding filter.
func (_aged *ASCIIHexEncoder )GetFilterName ()string {return StreamEncodingFilterNameASCIIHex };func _gcbd ()string {return _bf .Version };

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_dbea *RunLengthEncoder )EncodeBytes (data []byte )([]byte ,error ){_ddca :=_fb .NewReader (data );var _gcac []byte ;var _bcgb []byte ;_aecd ,_acdff :=_ddca .ReadByte ();if _acdff ==_aba .EOF {return []byte {},nil ;}else if _acdff !=nil {return nil ,_acdff ;};_cbcae :=1;for {_ccf ,_bgd :=_ddca .ReadByte ();if _bgd ==_aba .EOF {break ;}else if _bgd !=nil {return nil ,_bgd ;};if _ccf ==_aecd {if len (_bcgb )> 0{_bcgb =_bcgb [:len (_bcgb )-1];if len (_bcgb )> 0{_gcac =append (_gcac ,byte (len (_bcgb )-1));_gcac =append (_gcac ,_bcgb ...);};_cbcae =1;_bcgb =[]byte {};};_cbcae ++;if _cbcae >=127{_gcac =append (_gcac ,byte (257-_cbcae ),_aecd );_cbcae =0;};}else {if _cbcae > 0{if _cbcae ==1{_bcgb =[]byte {_aecd };}else {_gcac =append (_gcac ,byte (257-_cbcae ),_aecd );};_cbcae =0;};_bcgb =append (_bcgb ,_ccf );if len (_bcgb )>=127{_gcac =append (_gcac ,byte (len (_bcgb )-1));_gcac =append (_gcac ,_bcgb ...);_bcgb =[]byte {};};};_aecd =_ccf ;};if len (_bcgb )> 0{_gcac =append (_gcac ,byte (len (_bcgb )-1));_gcac =append (_gcac ,_bcgb ...);}else if _cbcae > 0{_gcac =append (_gcac ,byte (257-_cbcae ),_aecd );};_gcac =append (_gcac ,128);return _gcac ,nil ;};func (_gdg *PdfCrypt )decryptBytes (_gefb []byte ,_acg string ,_dbe []byte )([]byte ,error ){_bf .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");_baf ,_fad :=_gdg ._ecb [_acg ];if !_fad {return nil ,_ce .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_acg );};return _baf .DecryptBytes (_gefb ,_dbe );};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_cdfd *RawEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};func _cccgg (_dbcba _aba .ReadSeeker ,_cefa int64 )(*offsetReader ,error ){_eedg :=&offsetReader {_edg :_dbcba ,_cec :_cefa };_ ,_aced :=_eedg .Seek (0,_aba .SeekStart );return _eedg ,_aced ;};

// PdfCrypt provides PDF encryption/decryption support.
// The PDF standard supports encryption of strings and streams (Section 7.6).
type PdfCrypt struct{_gbe encryptDict ;_dgd _afe .StdEncryptDict ;_ddc string ;_cce []byte ;_fgc map[PdfObject ]bool ;_eecg map[PdfObject ]bool ;_fbc bool ;_ecb cryptFilters ;_cbca string ;_gbba string ;_cg *PdfParser ;_fea map[int ]struct{};};

// GetName returns the *PdfObjectName represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetName (obj PdfObject )(_fcbf *PdfObjectName ,_agba bool ){_fcbf ,_agba =TraceToDirectObject (obj ).(*PdfObjectName );return _fcbf ,_agba ;};

// UpdateParams updates the parameter values of the encoder.
// Implements StreamEncoder interface.
func (_beea *JBIG2Encoder )UpdateParams (params *PdfObjectDictionary ){_dbb ,_gagee :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _gagee ==nil {_beea .BitsPerComponent =int (_dbb );};_gcgc ,_gagee :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _gagee ==nil {_beea .Width =int (_gcgc );};_bgda ,_gagee :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _gagee ==nil {_beea .Height =int (_bgda );};_dfbd ,_gagee :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _gagee ==nil {_beea .ColorComponents =int (_dfbd );};};func _aae (_cee _ecf .Filter ,_fbcdd _afe .AuthEvent )*PdfObjectDictionary {if _fbcdd ==""{_fbcdd =_afe .EventDocOpen ;};_gefd :=MakeDict ();_gefd .Set ("\u0054\u0079\u0070\u0065",MakeName ("C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"));_gefd .Set ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et",MakeName (string (_fbcdd )));_gefd .Set ("\u0043\u0046\u004d",MakeName (_cee .Name ()));_gefd .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_cee .KeyLength ())));return _gefd ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on the current encoder settings.
func (_fabc *JBIG2Encoder )MakeDecodeParams ()PdfObject {return MakeDict ()};

// RawEncoder implements Raw encoder/decoder (no encoding, pass through)
type RawEncoder struct{};

// GetFilterName returns the name of the encoding filter.
func (_dge *LZWEncoder )GetFilterName ()string {return StreamEncodingFilterNameLZW };

// Len returns the number of elements in the array.
func (_bbbg *PdfObjectArray )Len ()int {if _bbbg ==nil {return 0;};return len (_bbbg ._cdbee );};func (_aac *PdfCrypt )isEncrypted (_aea PdfObject )bool {_ ,_bbge :=_aac ._eecg [_aea ];if _bbge {_bf .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0065\u006e\u0063\u0072y\u0070\u0074\u0065\u0064");return true ;};_bf .Log .Trace ("\u004e\u006f\u0074\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");return false ;};func (_edefd *PdfParser )seekToEOFMarker (_gece int64 )error {var _cgge int64 ;var _gdae int64 =2048;for _cgge < _gece -4{if _gece <=(_gdae +_cgge ){_gdae =_gece -_cgge ;};_ ,_egagb :=_edefd ._aagc .Seek (-_cgge -_gdae ,_aba .SeekEnd );if _egagb !=nil {return _egagb ;};_adab :=make ([]byte ,_gdae );_edefd ._aagc .Read (_adab );_bf .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0045\u004f\u0046 \u006da\u0072\u006b\u0065\u0072\u003a\u0020\u0022%\u0073\u0022",string (_adab ));_fabca :=_dgeb .FindAllStringIndex (string (_adab ),-1);if _fabca !=nil {_babda :=_fabca [len (_fabca )-1];_bf .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_fabca );_edefd ._aagc .Seek (-_cgge -_gdae +int64 (_babda [0]),_aba .SeekEnd );return nil ;};_bf .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");_cgge +=_gdae -4;};_bf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006be\u0072 \u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u002e");return _e .New ("\u0045\u004f\u0046\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};

// String returns a string describing `d`.
func (_afbc *PdfObjectDictionary )String ()string {var _afgf _ab .Builder ;_afgf .WriteString ("\u0044\u0069\u0063t\u0028");for _ ,_ggbcb :=range _afbc ._eaef {_ffbab :=_afbc ._ffca [_ggbcb ];_afgf .WriteString ("\u0022"+_ggbcb .String ()+"\u0022\u003a\u0020");_afgf .WriteString (_ffbab .String ());_afgf .WriteString ("\u002c\u0020");};_afgf .WriteString ("\u0029");return _afgf .String ();};

// UpdateParams updates the parameter values of the encoder.
func (_eede *DCTEncoder )UpdateParams (params *PdfObjectDictionary ){_dbd ,_bbbad :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _bbbad ==nil {_eede .ColorComponents =int (_dbd );};_bgb ,_bbbad :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _bbbad ==nil {_eede .BitsPerComponent =int (_bgb );};_gadc ,_bbbad :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _bbbad ==nil {_eede .Width =int (_gadc );};_ddeg ,_bbbad :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _bbbad ==nil {_eede .Height =int (_ddeg );};_dfac ,_bbbad :=GetNumberAsInt64 (params .Get ("\u0051u\u0061\u006c\u0069\u0074\u0079"));if _bbbad ==nil {_eede .Quality =int (_dfac );};};

// WriteString outputs the object as it is to be written to file.
func (_cfff *PdfObjectReference )WriteString ()string {var _bega _ab .Builder ;_bega .WriteString (_dc .FormatInt (_cfff .ObjectNumber ,10));_bega .WriteString ("\u0020");_bega .WriteString (_dc .FormatInt (_cfff .GenerationNumber ,10));_bega .WriteString ("\u0020\u0052");return _bega .String ();};

// GetTrailer returns the PDFs trailer dictionary. The trailer dictionary is typically the starting point for a PDF,
// referencing other key objects that are important in the document structure.
func (_dace *PdfParser )GetTrailer ()*PdfObjectDictionary {return _dace ._caec };func _adcd (_edbc PdfObject ,_efgg int )PdfObject {if _efgg > _bgedb {_bf .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_bgedb );return MakeNull ();};switch _fbde :=_edbc .(type ){case *PdfIndirectObject :_edbc =_adcd ((*_fbde ).PdfObject ,_efgg +1);case *PdfObjectArray :for _ddeef ,_cdfc :=range (*_fbde )._cdbee {(*_fbde )._cdbee [_ddeef ]=_adcd (_cdfc ,_efgg +1);};case *PdfObjectDictionary :for _dbeaa ,_dded :=range (*_fbde )._ffca {(*_fbde )._ffca [_dbeaa ]=_adcd (_dded ,_efgg +1);};_b .Slice ((*_fbde )._eaef ,func (_fgcfa ,_ceca int )bool {return (*_fbde )._eaef [_fgcfa ]< (*_fbde )._eaef [_ceca ]});};return _edbc ;};

// UpdateParams updates the parameter values of the encoder.
func (_cfee *FlateEncoder )UpdateParams (params *PdfObjectDictionary ){_bbea ,_befd :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _befd ==nil {_cfee .Predictor =int (_bbea );};_bcd ,_befd :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _befd ==nil {_cfee .BitsPerComponent =int (_bcd );};_eaea ,_befd :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _befd ==nil {_cfee .Columns =int (_eaea );};_dbgb ,_befd :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _befd ==nil {_cfee .Colors =int (_dbgb );};};func (_eaed *PdfParser )parseNumber ()(PdfObject ,error ){return ParseNumber (_eaed ._bdc )};

// TraceToDirectObject traces a PdfObject to a direct object.  For example direct objects contained
// in indirect objects (can be double referenced even).
func TraceToDirectObject (obj PdfObject )PdfObject {if _aggdg ,_ecge :=obj .(*PdfObjectReference );_ecge {obj =_aggdg .Resolve ();};_gdf ,_cbcec :=obj .(*PdfIndirectObject );_beebb :=0;for _cbcec {obj =_gdf .PdfObject ;_gdf ,_cbcec =GetIndirect (obj );_beebb ++;if _beebb > _bgedb {_bf .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0072\u0061\u0063\u0065\u0020\u0064\u0065p\u0074\u0068\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u0062\u0065\u0079\u006fn\u0064\u0020\u0025\u0064\u0020\u002d\u0020\u006e\u006f\u0074\u0020\u0067oi\u006e\u0067\u0020\u0064\u0065\u0065\u0070\u0065\u0072\u0021",_bgedb );return nil ;};};return obj ;};func (_bedeg *PdfParser )parseName ()(PdfObjectName ,error ){var _fgcaa _fb .Buffer ;_fabe :=false ;for {_dabb ,_agfaa :=_bedeg ._bdc .Peek (1);if _agfaa ==_aba .EOF {break ;};if _agfaa !=nil {return PdfObjectName (_fgcaa .String ()),_agfaa ;};if !_fabe {if _dabb [0]=='/'{_fabe =true ;_bedeg ._bdc .ReadByte ();}else if _dabb [0]=='%'{_bedeg .readComment ();_bedeg .skipSpaces ();}else {_bf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020N\u0061\u006d\u0065\u0020\u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020w\u0069\u0074\u0068\u0020\u0025\u0073\u0020(\u0025\u0020\u0078\u0029",_dabb ,_dabb );return PdfObjectName (_fgcaa .String ()),_ce .Errorf ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u006ea\u006d\u0065:\u0020\u0028\u0025\u0063\u0029",_dabb [0]);};}else {if IsWhiteSpace (_dabb [0]){break ;}else if (_dabb [0]=='/')||(_dabb [0]=='[')||(_dabb [0]=='(')||(_dabb [0]==']')||(_dabb [0]=='<')||(_dabb [0]=='>'){break ;}else if _dabb [0]=='#'{_beb ,_fgcab :=_bedeg ._bdc .Peek (3);if _fgcab !=nil {return PdfObjectName (_fgcaa .String ()),_fgcab ;};_dfbad ,_fgcab :=_af .DecodeString (string (_beb [1:3]));if _fgcab !=nil {_bf .Log .Debug ("\u0045\u0052\u0052\u004fR\u003a\u0020\u0049\u006ev\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0066o\u006c\u006co\u0077\u0069\u006e\u0067 \u0027\u0023\u0027\u002c \u0063\u006f\u006e\u0074\u0069n\u0075\u0069\u006e\u0067\u0020\u0075\u0073i\u006e\u0067\u0020\u006c\u0069t\u0065\u0072\u0061\u006c\u0020\u002d\u0020\u004f\u0075t\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074");_fgcaa .WriteByte ('#');_bedeg ._bdc .Discard (1);continue ;};_bedeg ._bdc .Discard (3);_fgcaa .Write (_dfbad );}else {_gegd ,_ :=_bedeg ._bdc .ReadByte ();_fgcaa .WriteByte (_gegd );};};};return PdfObjectName (_fgcaa .String ()),nil ;};var _dgeb =_dce .MustCompile ("\u0025\u0025\u0045\u004f\u0046\u003f");var _gbgee _a .Map ;func (_abg *PdfParser )lookupObjectViaOS (_dg int ,_db int )(PdfObject ,error ){var _da *_fb .Reader ;var _cfb objectStream ;var _aec bool ;_cfb ,_aec =_abg ._cbde [_dg ];if !_aec {_bgf ,_fga :=_abg .LookupByNumber (_dg );if _fga !=nil {_bf .Log .Debug ("\u004d\u0069ss\u0069\u006e\u0067 \u006f\u0062\u006a\u0065ct \u0073tr\u0065\u0061\u006d\u0020\u0077\u0069\u0074h \u006e\u0075\u006d\u0062\u0065\u0072\u0020%\u0064",_dg );return nil ,_fga ;};_dag ,_gbd :=_bgf .(*PdfObjectStream );if !_gbd {return nil ,_e .New ("i\u006e\u0076\u0061\u006cid\u0020o\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d");};if _abg ._aggc !=nil &&!_abg ._aggc .isDecrypted (_dag ){return nil ,_e .New ("\u006e\u0065\u0065\u0064\u0020\u0074\u006f\u0020\u0064\u0065\u0063r\u0079\u0070\u0074\u0020\u0074\u0068\u0065\u0020\u0073\u0074r\u0065\u0061\u006d");};_fbf :=_dag .PdfObjectDictionary ;_bf .Log .Trace ("\u0073o\u0020\u0064\u003a\u0020\u0025\u0073\n",_fbf .String ());_cd ,_gbd :=_fbf .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if !_gbd {_bf .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0061\u006c\u0077\u0061\u0079\u0073\u0020\u0068\u0061\u0076\u0065\u0020\u0061\u0020\u0054\u0079\u0070\u0065");return nil ,_e .New ("\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020T\u0079\u0070\u0065");};if _ab .ToLower (string (*_cd ))!="\u006f\u0062\u006a\u0073\u0074\u006d"{_bf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0074\u0079\u0070\u0065\u0020s\u0068\u0061\u006c\u006c\u0020\u0061\u006c\u0077\u0061\u0079\u0073 \u0062\u0065\u0020\u004f\u0062\u006a\u0053\u0074\u006d\u0020\u0021");return nil ,_e .New ("\u006f\u0062\u006a\u0065c\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0074y\u0070e\u0020\u0021\u003d\u0020\u004f\u0062\u006aS\u0074\u006d");};N ,_gbd :=_fbf .Get ("\u004e").(*PdfObjectInteger );if !_gbd {return nil ,_e .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u004e\u0020i\u006e\u0020\u0073\u0074\u0072\u0065\u0061m\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_bbe ,_gbd :=_fbf .Get ("\u0046\u0069\u0072s\u0074").(*PdfObjectInteger );if !_gbd {return nil ,_e .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0046\u0069\u0072\u0073\u0074\u0020i\u006e \u0073t\u0072e\u0061\u006d\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_bf .Log .Trace ("\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0073\u0020\u006eu\u006d\u0062\u0065\u0072\u0020\u006f\u0066 \u006f\u0062\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_cd ,*N );_ee ,_fga :=DecodeStream (_dag );if _fga !=nil {return nil ,_fga ;};_bf .Log .Trace ("D\u0065\u0063\u006f\u0064\u0065\u0064\u003a\u0020\u0025\u0073",_ee );_eg :=_abg .GetFileOffset ();defer func (){_abg .SetFileOffset (_eg )}();_da =_fb .NewReader (_ee );_abg ._bdc =_ac .NewReader (_da );_bf .Log .Trace ("\u0050a\u0072s\u0069\u006e\u0067\u0020\u006ff\u0066\u0073e\u0074\u0020\u006d\u0061\u0070");_ega :=map[int ]int64 {};for _ebc :=0;_ebc < int (*N );_ebc ++{_abg .skipSpaces ();_accg ,_fe :=_abg .parseNumber ();if _fe !=nil {return nil ,_fe ;};_fbd ,_egb :=_accg .(*PdfObjectInteger );if !_egb {return nil ,_e .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");};_abg .skipSpaces ();_accg ,_fe =_abg .parseNumber ();if _fe !=nil {return nil ,_fe ;};_cc ,_egb :=_accg .(*PdfObjectInteger );if !_egb {return nil ,_e .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");};_bf .Log .Trace ("\u006f\u0062j\u0020\u0025\u0064 \u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0025\u0064",*_fbd ,*_cc );_ega [int (*_fbd )]=int64 (*_bbe +*_cc );};_cfb =objectStream {N :int (*N ),_cf :_ee ,_gf :_ega };_abg ._cbde [_dg ]=_cfb ;}else {_bfg :=_abg .GetFileOffset ();defer func (){_abg .SetFileOffset (_bfg )}();_da =_fb .NewReader (_cfb ._cf );_abg ._bdc =_ac .NewReader (_da );};_cfa :=_cfb ._gf [_db ];_bf .Log .Trace ("\u0041\u0043\u0054\u0055AL\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u005b\u0025\u0064\u005d\u0020\u003d\u0020%\u0064",_db ,_cfa );_da .Seek (_cfa ,_aba .SeekStart );_abg ._bdc =_ac .NewReader (_da );_ea ,_ :=_abg ._bdc .Peek (100);_bf .Log .Trace ("\u004f\u0042\u004a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_ea ));_cb ,_cbc :=_abg .parseObject ();if _cbc !=nil {_bf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c \u0074\u006f\u0020\u0072\u0065\u0061\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_cbc );return nil ,_cbc ;};if _cb ==nil {return nil ,_e .New ("o\u0062\u006a\u0065\u0063t \u0063a\u006e\u006e\u006f\u0074\u0020b\u0065\u0020\u006e\u0075\u006c\u006c");};_gff :=PdfIndirectObject {};_gff .ObjectNumber =int64 (_db );_gff .PdfObject =_cb ;return &_gff ,nil ;};

// NewASCII85Encoder makes a new ASCII85 encoder.
func NewASCII85Encoder ()*ASCII85Encoder {_deea :=&ASCII85Encoder {};return _deea };

// Decrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_abbd *PdfCrypt )Decrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _abbd .isDecrypted (obj ){return nil ;};switch _cbcac :=obj .(type ){case *PdfIndirectObject :_abbd ._fgc [_cbcac ]=true ;_bf .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_cbcac .ObjectNumber ,_cbcac .GenerationNumber );_fgb :=_cbcac .ObjectNumber ;_feg :=_cbcac .GenerationNumber ;_age :=_abbd .Decrypt (_cbcac .PdfObject ,_fgb ,_feg );if _age !=nil {return _age ;};return nil ;case *PdfObjectStream :_abbd ._fgc [_cbcac ]=true ;_fefe :=_cbcac .PdfObjectDictionary ;if _abbd ._dgd .R !=5{if _fgbd ,_gg :=_fefe .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_gg &&*_fgbd =="\u0058\u0052\u0065\u0066"{return nil ;};};_bafg :=_cbcac .ObjectNumber ;_eff :=_cbcac .GenerationNumber ;_bf .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_bafg ,_eff );_dccg :=_edd ;if _abbd ._gbe .V >=4{_dccg =_abbd ._cbca ;_bf .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_abbd ._cbca );if _agab ,_dfg :=_fefe .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );_dfg {if _ggc ,_def :=GetName (_agab .Get (0));_def {if *_ggc =="\u0043\u0072\u0079p\u0074"{_dccg ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _aab ,_cacf :=_fefe .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );_cacf {if _dedb ,_ceb :=_aab .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_ceb {if _ ,_acce :=_abbd ._ecb [string (*_dedb )];_acce {_bf .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_dedb );_dccg =string (*_dedb );};};};};};};_bf .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_dccg );if _dccg =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_cef :=_abbd .Decrypt (_fefe ,_bafg ,_eff );if _cef !=nil {return _cef ;};_faga ,_cef :=_abbd .makeKey (_dccg ,uint32 (_bafg ),uint32 (_eff ),_abbd ._cce );if _cef !=nil {return _cef ;};_cbcac .Stream ,_cef =_abbd .decryptBytes (_cbcac .Stream ,_dccg ,_faga );if _cef !=nil {return _cef ;};_fefe .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_cbcac .Stream ))));return nil ;case *PdfObjectString :_bf .Log .Trace ("\u0044e\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_dda :=_edd ;if _abbd ._gbe .V >=4{_bf .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_abbd ._gbba );if _abbd ._gbba =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_dda =_abbd ._gbba ;};_beff ,_ecae :=_abbd .makeKey (_dda ,uint32 (parentObjNum ),uint32 (parentGenNum ),_abbd ._cce );if _ecae !=nil {return _ecae ;};_ced :=_cbcac .Str ();_dgaa :=make ([]byte ,len (_ced ));for _faa :=0;_faa < len (_ced );_faa ++{_dgaa [_faa ]=_ced [_faa ];};_bf .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_dgaa ,_dgaa );_dgaa ,_ecae =_abbd .decryptBytes (_dgaa ,_dda ,_beff );if _ecae !=nil {return _ecae ;};_cbcac ._gcae =string (_dgaa );return nil ;case *PdfObjectArray :for _ ,_gaee :=range _cbcac .Elements (){_eddd :=_abbd .Decrypt (_gaee ,parentObjNum ,parentGenNum );if _eddd !=nil {return _eddd ;};};return nil ;case *PdfObjectDictionary :_fgec :=false ;if _eea :=_cbcac .Get ("\u0054\u0079\u0070\u0065");_eea !=nil {_eda ,_ged :=_eea .(*PdfObjectName );if _ged &&*_eda =="\u0053\u0069\u0067"{_fgec =true ;};};for _ ,_adee :=range _cbcac .Keys (){_fgbc :=_cbcac .Get (_adee );if _fgec &&string (_adee )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;};if string (_adee )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_adee )!="\u0050\u0072\u0065\u0076"&&string (_adee )!="\u004c\u0061\u0073\u0074"{_cefc :=_abbd .Decrypt (_fgbc ,parentObjNum ,parentGenNum );if _cefc !=nil {return _cefc ;};};};return nil ;};return nil ;};const (DefaultJPEGQuality =75;);

// WriteString outputs the object as it is to be written to file.
func (_agff *PdfObjectStreams )WriteString ()string {var _gbdabg _ab .Builder ;_gbdabg .WriteString (_dc .FormatInt (_agff .ObjectNumber ,10));_gbdabg .WriteString ("\u0020\u0030\u0020\u0052");return _gbdabg .String ();};func _dbg (_abd *_afe .StdEncryptDict ,_eeeg *PdfObjectDictionary ){_eeeg .Set ("\u0052",MakeInteger (int64 (_abd .R )));_eeeg .Set ("\u0050",MakeInteger (int64 (_abd .P )));_eeeg .Set ("\u004f",MakeStringFromBytes (_abd .O ));_eeeg .Set ("\u0055",MakeStringFromBytes (_abd .U ));if _abd .R >=5{_eeeg .Set ("\u004f\u0045",MakeStringFromBytes (_abd .OE ));_eeeg .Set ("\u0055\u0045",MakeStringFromBytes (_abd .UE ));_eeeg .Set ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061",MakeBool (_abd .EncryptMetadata ));if _abd .R > 5{_eeeg .Set ("\u0050\u0065\u0072m\u0073",MakeStringFromBytes (_abd .Perms ));};};};

// PdfObjectArray represents the primitive PDF array object.
type PdfObjectArray struct{_cdbee []PdfObject };

// ReadAtLeast reads at least n bytes into slice p.
// Returns the number of bytes read (should always be == n), and an error on failure.
func (_dada *PdfParser )ReadAtLeast (p []byte ,n int )(int ,error ){_aaed :=n ;_dgff :=0;_aaab :=0;for _aaed > 0{_gfdb ,_ebb :=_dada ._bdc .Read (p [_dgff :]);if _ebb !=nil {_bf .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061d\u0069\u006e\u0067\u0020\u0028\u0025\u0064\u003b\u0025\u0064\u0029\u0020\u0025\u0073",_gfdb ,_aaab ,_ebb .Error ());return _dgff ,_e .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065a\u0064\u0069\u006e\u0067");};_aaab ++;_dgff +=_gfdb ;_aaed -=_gfdb ;};return _dgff ,nil ;};const (_aafa =0;_aceg =1;_accf =2;_cde =3;_fecf =4;);func (_aeac *PdfParser )readComment ()(string ,error ){var _efgc _fb .Buffer ;_ ,_egee :=_aeac .skipSpaces ();if _egee !=nil {return _efgc .String (),_egee ;};_ebabe :=true ;for {_dbce ,_bdee :=_aeac ._bdc .Peek (1);if _bdee !=nil {_bf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_bdee .Error ());return _efgc .String (),_bdee ;};if _ebabe &&_dbce [0]!='%'{return _efgc .String (),_e .New ("c\u006f\u006d\u006d\u0065\u006e\u0074 \u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0073\u0074a\u0072\u0074\u0020w\u0069t\u0068\u0020\u0025");};_ebabe =false ;if (_dbce [0]!='\r')&&(_dbce [0]!='\n'){_ebgb ,_ :=_aeac ._bdc .ReadByte ();_efgc .WriteByte (_ebgb );}else {break ;};};return _efgc .String (),nil ;};

// String returns a string describing `ind`.
func (_feage *PdfIndirectObject )String ()string {return _ce .Sprintf ("\u0049\u004f\u0062\u006a\u0065\u0063\u0074\u003a\u0025\u0064",(*_feage ).ObjectNumber );};

// JBIG2Image is the image structure used by the jbig2 encoder. Its Data must be in a
// 1 bit per component and 1 component per pixel (1bpp). In order to create binary image
// use GoImageToJBIG2 function. If the image data contains the row bytes padding set the HasPadding to true.
type JBIG2Image struct{

// Width and Height defines the image boundaries.
Width ,Height int ;

// Data is the byte slice data for the input image
Data []byte ;

// HasPadding is the attribute that defines if the last byte of the data in the row contains
// 0 bits padding.
HasPadding bool ;};func _cbg (_affa *PdfObjectStream ,_cbcb *PdfObjectDictionary )(*CCITTFaxEncoder ,error ){_agad :=NewCCITTFaxEncoder ();_cdfa :=_affa .PdfObjectDictionary ;if _cdfa ==nil {return _agad ,nil ;};if _cbcb ==nil {_gfebc :=TraceToDirectObject (_cdfa .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));if _gfebc !=nil {switch _ddaf :=_gfebc .(type ){case *PdfObjectDictionary :_cbcb =_ddaf ;case *PdfObjectArray :if _ddaf .Len ()==1{if _bggbg ,_gfdc :=GetDict (_ddaf .Get (0));_gfdc {_cbcb =_bggbg ;};};default:_bf .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_gfebc );return nil ,_e .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _cbcb ==nil {_bf .Log .Error ("\u0044\u0065c\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064 %\u0023\u0076",_gfebc );return nil ,_e .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _addc ,_eccb :=GetNumberAsInt64 (_cbcb .Get ("\u004b"));_eccb ==nil {_agad .K =int (_addc );};if _fcgc ,_adef :=GetNumberAsInt64 (_cbcb .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));_adef ==nil {_agad .Columns =int (_fcgc );}else {_agad .Columns =1728;};if _bcc ,_gbgb :=GetNumberAsInt64 (_cbcb .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_gbgb ==nil {_agad .BlackIs1 =_bcc > 0;}else {if _agd ,_cfed :=GetBoolVal (_cbcb .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_cfed {_agad .BlackIs1 =_agd ;}else {if _bbfd ,_dccd :=GetArray (_cbcb .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));_dccd {_fgagb ,_cacgb :=_bbfd .ToIntegerArray ();if _cacgb ==nil {_agad .BlackIs1 =_fgagb [0]==1&&_fgagb [1]==0;};};};};if _gagd ,_fbea :=GetNumberAsInt64 (_cbcb .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_fbea ==nil {_agad .EncodedByteAlign =_gagd > 0;}else {if _afccf ,_caf :=GetBoolVal (_cbcb .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_caf {_agad .EncodedByteAlign =_afccf ;};};if _ffac ,_faba :=GetNumberAsInt64 (_cbcb .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_faba ==nil {_agad .EndOfLine =_ffac > 0;}else {if _agce ,_abce :=GetBoolVal (_cbcb .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_abce {_agad .EndOfLine =_agce ;};};if _cegd ,_eabc :=GetNumberAsInt64 (_cbcb .Get ("\u0052\u006f\u0077\u0073"));_eabc ==nil {_agad .Rows =int (_cegd );};_agad .EndOfBlock =true ;if _dfcg ,_dbed :=GetNumberAsInt64 (_cbcb .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_dbed ==nil {_agad .EndOfBlock =_dfcg > 0;}else {if _fdcf ,_edcc :=GetBoolVal (_cbcb .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_edcc {_agad .EndOfBlock =_fdcf ;};};if _ggbg ,_gbcc :=GetNumberAsInt64 (_cbcb .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));_gbcc !=nil {_agad .DamagedRowsBeforeError =int (_ggbg );};_bf .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_cbcb .String ());return _agad ,nil ;};

// PdfObjectFloat represents the primitive PDF floating point numerical object.
type PdfObjectFloat float64 ;

// MakeArrayFromFloats creates an PdfObjectArray from a slice of float64s, where each array element is an
// PdfObjectFloat.
func MakeArrayFromFloats (vals []float64 )*PdfObjectArray {_acacc :=MakeArray ();for _ ,_fcad :=range vals {_acacc .Append (MakeFloat (_fcad ));};return _acacc ;};

// EncodeJBIG2Image encodes 'img' into jbig2 encoded bytes stream, using default encoder settings.
func (_fdfb *JBIG2Encoder )EncodeJBIG2Image (img *JBIG2Image )([]byte ,error ){const _bdge ="c\u006f\u0072\u0065\u002eEn\u0063o\u0064\u0065\u004a\u0042\u0049G\u0032\u0049\u006d\u0061\u0067\u0065";if _gfddd :=_fdfb .AddPageImage (img ,&_fdfb .DefaultPageSettings );_gfddd !=nil {return nil ,_fg .Wrap (_gfddd ,_bdge ,"");};return _fdfb .Encode ();};

// String returns a string describing `stream`.
func (_dbaa *PdfObjectStream )String ()string {return _ce .Sprintf ("O\u0062j\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0025\u0064: \u0025\u0073",_dbaa .ObjectNumber ,_dbaa .PdfObjectDictionary );};

// NewCCITTFaxEncoder makes a new CCITTFax encoder.
func NewCCITTFaxEncoder ()*CCITTFaxEncoder {return &CCITTFaxEncoder {Columns :1728,EndOfBlock :true }};

// Clear resets the array to an empty state.
func (_dade *PdfObjectArray )Clear (){_dade ._cdbee =[]PdfObject {}};

// Inspect analyzes the document object structure. Returns a map of object types (by name) with the instance count
// as value.
func (_bcaba *PdfParser )Inspect ()(map[string ]int ,error ){return _bcaba .inspect ()};func (_adfe *PdfObjectFloat )String ()string {return _ce .Sprintf ("\u0025\u0066",*_adfe )};func _caae (_gcgg _aa .Image )*JBIG2Image {_dgc :=_gcgg .Base ();return &JBIG2Image {Data :_dgc .Data ,Width :_dgc .Width ,Height :_dgc .Height ,HasPadding :true };};

// GetString returns the *PdfObjectString represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetString (obj PdfObject )(_cbafc *PdfObjectString ,_aeebc bool ){_cbafc ,_aeebc =TraceToDirectObject (obj ).(*PdfObjectString );return _cbafc ,_aeebc ;};

// MakeIndirectObject creates an PdfIndirectObject with a specified direct object PdfObject.
func MakeIndirectObject (obj PdfObject )*PdfIndirectObject {_eabce :=&PdfIndirectObject {};_eabce .PdfObject =obj ;return _eabce ;};type xrefType int ;

// Append appends PdfObject(s) to the streams.
func (_ggfe *PdfObjectStreams )Append (objects ...PdfObject ){if _ggfe ==nil {_bf .Log .Debug ("\u0057\u0061\u0072\u006e\u0020-\u0020\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0020\u0074\u006f\u0020\u0061p\u0070\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0073");return ;};_ggfe ._adca =append (_ggfe ._adca ,objects ...);};

// MakeArrayFromIntegers64 creates an PdfObjectArray from a slice of int64s, where each array element
// is an PdfObjectInteger.
func MakeArrayFromIntegers64 (vals []int64 )*PdfObjectArray {_geac :=MakeArray ();for _ ,_fgeg :=range vals {_geac .Append (MakeInteger (_fgeg ));};return _geac ;};

// GetObjectNums returns a sorted list of object numbers of the PDF objects in the file.
func (_ddfgf *PdfParser )GetObjectNums ()[]int {var _bbeab []int ;for _ ,_bbbec :=range _ddfgf ._bbfg .ObjectMap {_bbeab =append (_bbeab ,_bbbec .ObjectNumber );};_b .Ints (_bbeab );return _bbeab ;};

// MakeStream creates an PdfObjectStream with specified contents and encoding. If encoding is nil, then raw encoding
// will be used (i.e. no encoding applied).
func MakeStream (contents []byte ,encoder StreamEncoder )(*PdfObjectStream ,error ){_bbdb :=&PdfObjectStream {};if encoder ==nil {encoder =NewRawEncoder ();};_bbdb .PdfObjectDictionary =encoder .MakeStreamDict ();_cffba ,_agae :=encoder .EncodeBytes (contents );if _agae !=nil {return nil ,_agae ;};_bbdb .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_cffba ))));_bbdb .Stream =_cffba ;return _bbdb ,nil ;};

// MakeArrayFromIntegers creates an PdfObjectArray from a slice of ints, where each array element is
// an PdfObjectInteger.
func MakeArrayFromIntegers (vals []int )*PdfObjectArray {_aecfg :=MakeArray ();for _ ,_gbda :=range vals {_aecfg .Append (MakeInteger (int64 (_gbda )));};return _aecfg ;};func _cca (_gcc XrefTable ){_bf .Log .Debug ("\u003dX\u003d\u0058\u003d\u0058\u003d");_bf .Log .Debug ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");_feca :=0;for _ ,_bc :=range _gcc .ObjectMap {_bf .Log .Debug ("i\u002b\u0031\u003a\u0020\u0025\u0064 \u0028\u006f\u0062\u006a\u0020\u006eu\u006d\u003a\u0020\u0025\u0064\u0020\u0067e\u006e\u003a\u0020\u0025\u0064\u0029\u0020\u002d\u003e\u0020%\u0064",_feca +1,_bc .ObjectNumber ,_bc .Generation ,_bc .Offset );_feca ++;};};

// GetFilterName returns the names of the underlying encoding filters,
// separated by spaces.
// Note: This is just a string, should not be used in /Filter dictionary entry. Use GetFilterArray for that.
// TODO(v4): Refactor to GetFilter() which can be used for /Filter (either Name or Array), this can be
//  renamed to String() as a pretty string to use in debugging etc.
func (_edbg *MultiEncoder )GetFilterName ()string {_cgca :="";for _dfcc ,_aeg :=range _edbg ._gbag {_cgca +=_aeg .GetFilterName ();if _dfcc < len (_edbg ._gbag )-1{_cgca +="\u0020";};};return _cgca ;};

// XrefObject defines a cross reference entry which is a map between object number (with generation number) and the
// location of the actual object, either as a file offset (xref table entry), or as a location within an xref
// stream object (xref object stream).
type XrefObject struct{XType xrefType ;ObjectNumber int ;Generation int ;

// For normal xrefs (defined by OFFSET)
Offset int64 ;

// For xrefs to object streams.
OsObjNumber int ;OsObjIndex int ;};

// MakeName creates a PdfObjectName from a string.
func MakeName (s string )*PdfObjectName {_gbcff :=PdfObjectName (s );return &_gbcff };

// GetCrypter returns the PdfCrypt instance which has information about the PDFs encryption.
func (_gbeg *PdfParser )GetCrypter ()*PdfCrypt {return _gbeg ._aggc };

// GetBoolVal returns the bool value within a *PdObjectBool represented by an PdfObject interface directly or indirectly.
// If the PdfObject does not represent a bool value, a default value of false is returned (found = false also).
func GetBoolVal (obj PdfObject )(_acba bool ,_egea bool ){_gdcd ,_egea :=TraceToDirectObject (obj ).(*PdfObjectBool );if _egea {return bool (*_gdcd ),true ;};return false ,false ;};

// WriteString outputs the object as it is to be written to file.
func (_cccb *PdfObjectBool )WriteString ()string {if *_cccb {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};

// GetStream returns the *PdfObjectStream represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetStream (obj PdfObject )(_gfff *PdfObjectStream ,_bdfca bool ){obj =ResolveReference (obj );_gfff ,_bdfca =obj .(*PdfObjectStream );return _gfff ,_bdfca ;};

// WriteString outputs the object as it is to be written to file.
func (_adeeb *PdfIndirectObject )WriteString ()string {var _fgbcd _ab .Builder ;_fgbcd .WriteString (_dc .FormatInt (_adeeb .ObjectNumber ,10));_fgbcd .WriteString ("\u0020\u0030\u0020\u0052");return _fgbcd .String ();};

// EncodeBytes encodes the passed in slice of bytes by passing it through the
// EncodeBytes method of the underlying encoders.
func (_becd *MultiEncoder )EncodeBytes (data []byte )([]byte ,error ){_ebfbg :=data ;var _gfccd error ;for _efff :=len (_becd ._gbag )-1;_efff >=0;_efff --{_eaeaa :=_becd ._gbag [_efff ];_ebfbg ,_gfccd =_eaeaa .EncodeBytes (_ebfbg );if _gfccd !=nil {return nil ,_gfccd ;};};return _ebfbg ,nil ;};

// DecodeStream decodes a LZW encoded stream and returns the result as a
// slice of bytes.
func (_degd *LZWEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_bf .Log .Trace ("\u004c\u005a\u0057 \u0044\u0065\u0063\u006f\u0064\u0069\u006e\u0067");_bf .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_degd .Predictor );_cgf ,_bfdg :=_degd .DecodeBytes (streamObj .Stream );if _bfdg !=nil {return nil ,_bfdg ;};_bf .Log .Trace ("\u0020\u0049\u004e\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (streamObj .Stream ),streamObj .Stream );_bf .Log .Trace ("\u004f\u0055\u0054\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (_cgf ),_cgf );if _degd .Predictor > 1{if _degd .Predictor ==2{_bf .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_ffgb :=_degd .Columns *_degd .Colors ;if _ffgb < 1{return []byte {},nil ;};_bfge :=len (_cgf )/_ffgb ;if len (_cgf )%_ffgb !=0{_bf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");return nil ,_ce .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_cgf ),_ffgb );};if _ffgb %_degd .Colors !=0{return nil ,_ce .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_ffgb ,_degd .Colors );};if _ffgb > len (_cgf ){_bf .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_ffgb ,len (_cgf ));return nil ,_e .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_bf .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_cgf ),_cgf );_gagc :=_fb .NewBuffer (nil );for _bfec :=0;_bfec < _bfge ;_bfec ++{_dad :=_cgf [_ffgb *_bfec :_ffgb *(_bfec +1)];for _dfde :=_degd .Colors ;_dfde < _ffgb ;_dfde ++{_dad [_dfde ]=byte (int (_dad [_dfde ]+_dad [_dfde -_degd .Colors ])%256);};_gagc .Write (_dad );};_cbd :=_gagc .Bytes ();_bf .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_cbd ),_cbd );return _cbd ,nil ;}else if _degd .Predictor >=10&&_degd .Predictor <=15{_bf .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_ggd :=_degd .Columns *_degd .Colors +1;if _ggd < 1{return []byte {},nil ;};_dadc :=len (_cgf )/_ggd ;if len (_cgf )%_ggd !=0{return nil ,_ce .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_cgf ),_ggd );};if _ggd > len (_cgf ){_bf .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_ggd ,len (_cgf ));return nil ,_e .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_gded :=_fb .NewBuffer (nil );_bf .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_degd .Columns );_bf .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_cgf ),_ggd ,_dadc );_fdgb :=make ([]byte ,_ggd );for _cfcc :=0;_cfcc < _ggd ;_cfcc ++{_fdgb [_cfcc ]=0;};for _fdag :=0;_fdag < _dadc ;_fdag ++{_adc :=_cgf [_ggd *_fdag :_ggd *(_fdag +1)];_aade :=_adc [0];switch _aade {case 0:case 1:for _adbc :=2;_adbc < _ggd ;_adbc ++{_adc [_adbc ]=byte (int (_adc [_adbc ]+_adc [_adbc -1])%256);};case 2:for _egbcd :=1;_egbcd < _ggd ;_egbcd ++{_adc [_egbcd ]=byte (int (_adc [_egbcd ]+_fdgb [_egbcd ])%256);};default:_bf .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0066i\u006c\u0074\u0065\u0072\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_aade );return nil ,_ce .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_aade );};for _adbg :=0;_adbg < _ggd ;_adbg ++{_fdgb [_adbg ]=_adc [_adbg ];};_gded .Write (_adc [1:]);};_eacc :=_gded .Bytes ();return _eacc ,nil ;}else {_bf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_degd .Predictor );return nil ,_ce .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_degd .Predictor );};};return _cgf ,nil ;};func _eabf (_bgdg PdfObject )(*float64 ,error ){switch _bbca :=_bgdg .(type ){case *PdfObjectFloat :_dcdc :=float64 (*_bbca );return &_dcdc ,nil ;case *PdfObjectInteger :_adabg :=float64 (*_bbca );return &_adabg ,nil ;case *PdfObjectNull :return nil ,nil ;};return nil ,ErrNotANumber ;};

// FlateEncoder represents Flate encoding.
type FlateEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Rows int ;Colors int ;_agac *_aa .ImageBase ;};

// EncodeImage encodes 'img' golang image.Image into jbig2 encoded bytes document using default encoder settings.
func (_cdfag *JBIG2Encoder )EncodeImage (img _dd .Image )([]byte ,error ){return _cdfag .encodeImage (img );};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_ecd *CCITTFaxEncoder )MakeDecodeParams ()PdfObject {_defa :=MakeDict ();_defa .Set ("\u004b",MakeInteger (int64 (_ecd .K )));_defa .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_ecd .Columns )));if _ecd .BlackIs1 {_defa .Set ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031",MakeBool (_ecd .BlackIs1 ));};if _ecd .EncodedByteAlign {_defa .Set ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e",MakeBool (_ecd .EncodedByteAlign ));};if _ecd .EndOfLine &&_ecd .K >=0{_defa .Set ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee",MakeBool (_ecd .EndOfLine ));};if _ecd .Rows !=0&&!_ecd .EndOfBlock {_defa .Set ("\u0052\u006f\u0077\u0073",MakeInteger (int64 (_ecd .Rows )));};if !_ecd .EndOfBlock {_defa .Set ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b",MakeBool (_ecd .EndOfBlock ));};if _ecd .DamagedRowsBeforeError !=0{_defa .Set ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072",MakeInteger (int64 (_ecd .DamagedRowsBeforeError )));};return _defa ;};var _dbgg =_dce .MustCompile ("\u0028\u005c\u0064\u002b)\\\u0073\u002b\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u006f\u0062\u006a");var _dgca =_dce .MustCompile ("\u005e\u005b\\\u002b\u002d\u002e\u005d*\u0028\u005b0\u002d\u0039\u002e\u005d\u002b\u0029\u005b\u0065E\u005d\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");

// DecodeStream decodes a FlateEncoded stream object and give back decoded bytes.
func (_feagb *FlateEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_bf .Log .Trace ("\u0046l\u0061t\u0065\u0044\u0065\u0063\u006fd\u0065\u0020s\u0074\u0072\u0065\u0061\u006d");_bf .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_feagb .Predictor );if _feagb .BitsPerComponent !=8{return nil ,_ce .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003d\u0025\u0064\u0020\u0028\u006f\u006e\u006c\u0079\u0020\u0038\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0029",_feagb .BitsPerComponent );};_aadf ,_bdfe :=_feagb .DecodeBytes (streamObj .Stream );if _bdfe !=nil {return nil ,_bdfe ;};_aadf ,_bdfe =_feagb .postDecodePredict (_aadf );if _bdfe !=nil {return nil ,_bdfe ;};return _aadf ,nil ;};

// SetPredictor sets the predictor function.  Specify the number of columns per row.
// The columns indicates the number of samples per row.
// Used for grouping data together for compression.
func (_fcb *FlateEncoder )SetPredictor (columns int ){_fcb .Predictor =11;_fcb .Columns =columns };

// UpdateParams updates the parameter values of the encoder.
func (_faac *ASCII85Encoder )UpdateParams (params *PdfObjectDictionary ){};

// PdfObjectInteger represents the primitive PDF integer numerical object.
type PdfObjectInteger int64 ;

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_dcf *ASCIIHexEncoder )MakeDecodeParams ()PdfObject {return nil };var _abcg =[]PdfObjectName {"\u0056","\u0052","\u004f","\u0055","\u0050"};

// PdfObjectNull represents the primitive PDF null object.
type PdfObjectNull struct{};

// Elements returns a slice of the PdfObject elements in the array.
// Preferred over accessing the array directly as type may be changed in future major versions (v3).
func (_cgddd *PdfObjectStreams )Elements ()[]PdfObject {if _cgddd ==nil {return nil ;};return _cgddd ._adca ;};

// Resolve resolves the reference and returns the indirect or stream object.
// If the reference cannot be resolved, a *PdfObjectNull object is returned.
func (_febf *PdfObjectReference )Resolve ()PdfObject {if _febf ._bcdd ==nil {return MakeNull ();};_ggee ,_ ,_faef :=_febf ._bcdd .resolveReference (_febf );if _faef !=nil {_bf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0072\u0065\u0073\u006f\u006cv\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065r\u0065n\u0063\u0065\u003a\u0020\u0025\u0076\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074",_faef );return MakeNull ();};if _ggee ==nil {_bf .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0072\u0065\u0073ol\u0076\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065:\u0020\u006ei\u006c\u0020\u006fb\u006a\u0065\u0063\u0074\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u0061\u0020nu\u006c\u006c\u0020o\u0062\u006a\u0065\u0063\u0074");return MakeNull ();};return _ggee ;};

// MakeStringFromBytes creates an PdfObjectString from a byte array.
// This is more natural than MakeString as `data` is usually not utf-8 encoded.
func MakeStringFromBytes (data []byte )*PdfObjectString {return MakeString (string (data ))};

// GetInt returns the *PdfObjectBool object that is represented by a PdfObject either directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetInt (obj PdfObject )(_ccec *PdfObjectInteger ,_ecbd bool ){_ccec ,_ecbd =TraceToDirectObject (obj ).(*PdfObjectInteger );return _ccec ,_ecbd ;};func (_fa *PdfParser )lookupByNumber (_fef int ,_dcc bool )(PdfObject ,bool ,error ){_aag ,_gae :=_fa .ObjCache [_fef ];if _gae {_bf .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0063a\u0063\u0068\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0025\u0064",_fef );return _aag ,false ,nil ;};if _fa ._bgec ==nil {_fa ._bgec =map[int ]bool {};};if _fa ._bgec [_fef ]{_bf .Log .Debug ("ER\u0052\u004f\u0052\u003a\u0020\u004c\u006fok\u0075\u0070\u0020\u006f\u0066\u0020\u0025\u0064\u0020\u0069\u0073\u0020\u0061\u006c\u0072e\u0061\u0064\u0079\u0020\u0069\u006e\u0020\u0070\u0072\u006f\u0067\u0072\u0065\u0073\u0073\u0020\u002d\u0020\u0072\u0065c\u0075\u0072\u0073\u0069\u0076\u0065 \u006c\u006f\u006f\u006b\u0075\u0070\u0020\u0061\u0074t\u0065m\u0070\u0074\u0020\u0062\u006c\u006f\u0063\u006b\u0065\u0064",_fef );return nil ,false ,_e .New ("\u0072\u0065\u0063\u0075\u0072\u0073\u0069\u0076\u0065\u0020\u006c\u006f\u006f\u006b\u0075p\u0020a\u0074\u0074\u0065\u006d\u0070\u0074\u0020\u0062\u006c\u006f\u0063\u006b\u0065\u0064");};_fa ._bgec [_fef ]=true ;defer delete (_fa ._bgec ,_fef );_gbb ,_gae :=_fa ._bbfg .ObjectMap [_fef ];if !_gae {_bf .Log .Trace ("\u0055\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u006c\u006f\u0063\u0061t\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0069\u006e\u0020\u0078\u0072\u0065\u0066\u0073\u0021 \u002d\u0020\u0052\u0065\u0074u\u0072\u006e\u0069\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074");var _cdd PdfObjectNull ;return &_cdd ,false ,nil ;};_bf .Log .Trace ("L\u006fo\u006b\u0075\u0070\u0020\u006f\u0062\u006a\u0020n\u0075\u006d\u0062\u0065r \u0025\u0064",_fef );if _gbb .XType ==XrefTypeTableEntry {_bf .Log .Trace ("\u0078r\u0065f\u006f\u0062\u006a\u0020\u006fb\u006a\u0020n\u0075\u006d\u0020\u0025\u0064",_gbb .ObjectNumber );_bf .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u0067e\u006e\u0020\u0025\u0064",_gbb .Generation );_bf .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0064",_gbb .Offset );_fa ._aagc .Seek (_gbb .Offset ,_aba .SeekStart );_fa ._bdc =_ac .NewReader (_fa ._aagc );_ffd ,_agb :=_fa .ParseIndirectObject ();if _agb !=nil {_bf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006ce\u0064\u0020\u0072\u0065\u0061\u0064\u0069n\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029",_agb );if _dcc {_bf .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0072\u0065\u0070\u0061\u0069r\u0020\u0078\u0072\u0065\u0066\u0073\u0020\u0028\u0074\u006f\u0070\u0020d\u006f\u0077\u006e\u0029");_abf ,_ge :=_fa .repairRebuildXrefsTopDown ();if _ge !=nil {_bf .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020r\u0065\u0070\u0061\u0069\u0072\u0020\u0028\u0025\u0073\u0029",_ge );return nil ,false ,_ge ;};_fa ._bbfg =*_abf ;return _fa .lookupByNumber (_fef ,false );};return nil ,false ,_agb ;};if _dcc {_bec ,_ ,_ :=_dgf (_ffd );if int (_bec )!=_fef {_bf .Log .Debug ("\u0049n\u0076\u0061\u006c\u0069d\u0020\u0078\u0072\u0065\u0066s\u003a \u0052e\u0062\u0075\u0069\u006c\u0064\u0069\u006eg");_gag :=_fa .rebuildXrefTable ();if _gag !=nil {return nil ,false ,_gag ;};_fa .ObjCache =objectCache {};return _fa .lookupByNumberWrapper (_fef ,false );};};_bf .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006f\u0062\u006a");_fa .ObjCache [_fef ]=_ffd ;return _ffd ,false ,nil ;}else if _gbb .XType ==XrefTypeObjectStream {_bf .Log .Trace ("\u0078r\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0021");_bf .Log .Trace ("\u003e\u004c\u006f\u0061\u0064\u0020\u0076\u0069\u0061\u0020\u004f\u0053\u0021");_bf .Log .Trace ("\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d \u0061\u0076\u0061\u0069\u006c\u0061b\u006c\u0065\u0020\u0069\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020%\u0064\u002f\u0025\u0064",_gbb .OsObjNumber ,_gbb .OsObjIndex );if _gbb .OsObjNumber ==_fef {_bf .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0043i\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065f\u0065\u0072\u0065n\u0063e\u0021\u003f\u0021");return nil ,true ,_e .New ("\u0078\u0072\u0065f \u0063\u0069\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");};if _ ,_aaf :=_fa ._bbfg .ObjectMap [_gbb .OsObjNumber ];_aaf {_feb ,_abb :=_fa .lookupObjectViaOS (_gbb .OsObjNumber ,_fef );if _abb !=nil {_bf .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0052\u0065\u0074\u0075\u0072\u006e\u0069n\u0067\u0020\u0045\u0052\u0052\u0020\u0028\u0025\u0073\u0029",_abb );return nil ,true ,_abb ;};_bf .Log .Trace ("\u003c\u004c\u006f\u0061\u0064\u0065\u0064\u0020\u0076i\u0061\u0020\u004f\u0053");_fa .ObjCache [_fef ]=_feb ;if _fa ._aggc !=nil {_fa ._aggc ._fgc [_feb ]=true ;};return _feb ,true ,nil ;};_bf .Log .Debug ("\u003f\u003f\u0020\u0042\u0065\u006c\u006f\u006eg\u0073\u0020\u0074o \u0061\u0020\u006e\u006f\u006e\u002dc\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u002e.\u002e\u0021");return nil ,true ,_e .New ("\u006f\u0073\u0020\u0062\u0065\u006c\u006fn\u0067\u0073\u0020t\u006f\u0020\u0061\u0020n\u006f\u006e\u0020\u0063\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074");};return nil ,false ,_e .New ("\u0075\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0078\u0072\u0065\u0066 \u0074\u0079\u0070\u0065");};func _cge (_bbeb *PdfObjectStream ,_cccge *MultiEncoder )(*DCTEncoder ,error ){_gea :=NewDCTEncoder ();_cag :=_bbeb .PdfObjectDictionary ;if _cag ==nil {return _gea ,nil ;};_aff :=_bbeb .Stream ;if _cccge !=nil {_ffab ,_bgbc :=_cccge .DecodeBytes (_aff );if _bgbc !=nil {return nil ,_bgbc ;};_aff =_ffab ;};_agcf :=_fb .NewReader (_aff );_aggf ,_eddc :=_g .DecodeConfig (_agcf );if _eddc !=nil {_bf .Log .Debug ("\u0045\u0072\u0072or\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0065\u003a\u0020\u0025\u0073",_eddc );return nil ,_eddc ;};switch _aggf .ColorModel {case _bg .RGBAModel :_gea .BitsPerComponent =8;_gea .ColorComponents =3;case _bg .RGBA64Model :_gea .BitsPerComponent =16;_gea .ColorComponents =3;case _bg .GrayModel :_gea .BitsPerComponent =8;_gea .ColorComponents =1;case _bg .Gray16Model :_gea .BitsPerComponent =16;_gea .ColorComponents =1;case _bg .CMYKModel :_gea .BitsPerComponent =8;_gea .ColorComponents =4;case _bg .YCbCrModel :_gea .BitsPerComponent =8;_gea .ColorComponents =3;default:return nil ,_e .New ("\u0075\u006e\u0073up\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u006d\u006f\u0064\u0065\u006c");};_gea .Width =_aggf .Width ;_gea .Height =_aggf .Height ;_bf .Log .Trace ("\u0044\u0043T\u0020\u0045\u006ec\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076",_gea );_gea .Quality =DefaultJPEGQuality ;return _gea ,nil ;};

// GetFloat returns the *PdfObjectFloat represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetFloat (obj PdfObject )(_deeac *PdfObjectFloat ,_gadg bool ){_deeac ,_gadg =TraceToDirectObject (obj ).(*PdfObjectFloat );return _deeac ,_gadg ;};

// ASCII85Encoder implements ASCII85 encoder/decoder.
type ASCII85Encoder struct{};

// FlattenObject returns the contents of `obj`. In other words, `obj` with indirect objects replaced
// by their values.
// The replacements are made recursively to a depth of traceMaxDepth.
// NOTE: Dicts are sorted to make objects with same contents have the same PDF object strings.
func FlattenObject (obj PdfObject )PdfObject {return _adcd (obj ,0)};

// EncryptInfo contains an information generated by the document encrypter.
type EncryptInfo struct{Version ;

// Encrypt is an encryption dictionary that contains all necessary parameters.
// It should be stored in all copies of the document trailer.
Encrypt *PdfObjectDictionary ;

// ID0 and ID1 are IDs used in the trailer. Older algorithms such as RC4 uses them for encryption.
ID0 ,ID1 string ;};

// String returns a string describing `null`.
func (_ecff *PdfObjectNull )String ()string {return "\u006e\u0075\u006c\u006c"};

// WriteString outputs the object as it is to be written to file.
func (_decb *PdfObjectInteger )WriteString ()string {return _dc .FormatInt (int64 (*_decb ),10)};

// Str returns the string value of the PdfObjectString. Defined in addition to String() function to clarify that
// this function returns the underlying string directly, whereas the String function technically could include
// debug info.
func (_cdgd *PdfObjectString )Str ()string {return _cdgd ._gcae };

// Get returns the i-th element of the array or nil if out of bounds (by index).
func (_edfg *PdfObjectArray )Get (i int )PdfObject {if _edfg ==nil ||i >=len (_edfg ._cdbee )||i < 0{return nil ;};return _edfg ._cdbee [i ];};func (_fbg *PdfCrypt )authenticate (_fca []byte )(bool ,error ){_fbg ._fbc =false ;_gfd :=_fbg .securityHandler ();_cfc ,_bea ,_fff :=_gfd .Authenticate (&_fbg ._dgd ,_fca );if _fff !=nil {return false ,_fff ;}else if _bea ==0||len (_cfc )==0{return false ,nil ;};_fbg ._fbc =true ;_fbg ._cce =_cfc ;return true ,nil ;};

// DecodeStream implements ASCII85 stream decoding.
func (_ebab *ASCII85Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _ebab .DecodeBytes (streamObj .Stream );};

// Elements returns a slice of the PdfObject elements in the array.
func (_efcc *PdfObjectArray )Elements ()[]PdfObject {if _efcc ==nil {return nil ;};return _efcc ._cdbee ;};

// EncodeBytes ASCII encodes the passed in slice of bytes.
func (_gcd *ASCIIHexEncoder )EncodeBytes (data []byte )([]byte ,error ){var _eeac _fb .Buffer ;for _ ,_abe :=range data {_eeac .WriteString (_ce .Sprintf ("\u0025\u002e\u0032X\u0020",_abe ));};_eeac .WriteByte ('>');return _eeac .Bytes (),nil ;};

// PdfObjectReference represents the primitive PDF reference object.
type PdfObjectReference struct{_bcdd *PdfParser ;ObjectNumber int64 ;GenerationNumber int64 ;};

// MakeNull creates an PdfObjectNull.
func MakeNull ()*PdfObjectNull {_cgbd :=PdfObjectNull {};return &_cgbd };func _ffbaf (_gafed PdfObject ,_edecb int ,_geggc map[PdfObject ]struct{})error {_bf .Log .Trace ("\u0054\u0072\u0061\u0076\u0065\u0072s\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0064\u0061\u0074\u0061 \u0028\u0064\u0065\u0070\u0074\u0068\u0020=\u0020\u0025\u0064\u0029",_edecb );if _ ,_befa :=_geggc [_gafed ];_befa {_bf .Log .Trace ("-\u0041\u006c\u0072\u0065ad\u0079 \u0074\u0072\u0061\u0076\u0065r\u0073\u0065\u0064\u002e\u002e\u002e");return nil ;};_geggc [_gafed ]=struct{}{};switch _dcbf :=_gafed .(type ){case *PdfIndirectObject :_aada :=_dcbf ;_bf .Log .Trace ("\u0069\u006f\u003a\u0020\u0025\u0073",_aada );_bf .Log .Trace ("\u002d\u0020\u0025\u0073",_aada .PdfObject );return _ffbaf (_aada .PdfObject ,_edecb +1,_geggc );case *PdfObjectStream :_eadc :=_dcbf ;return _ffbaf (_eadc .PdfObjectDictionary ,_edecb +1,_geggc );case *PdfObjectDictionary :_deca :=_dcbf ;_bf .Log .Trace ("\u002d\u0020\u0064\u0069\u0063\u0074\u003a\u0020\u0025\u0073",_deca );for _ ,_cadd :=range _deca .Keys (){_eecd :=_deca .Get (_cadd );if _ceaf ,_becec :=_eecd .(*PdfObjectReference );_becec {_cdeee :=_ceaf .Resolve ();_deca .Set (_cadd ,_cdeee );_dddc :=_ffbaf (_cdeee ,_edecb +1,_geggc );if _dddc !=nil {return _dddc ;};}else {_ccda :=_ffbaf (_eecd ,_edecb +1,_geggc );if _ccda !=nil {return _ccda ;};};};return nil ;case *PdfObjectArray :_cdbef :=_dcbf ;_bf .Log .Trace ("-\u0020\u0061\u0072\u0072\u0061\u0079\u003a\u0020\u0025\u0073",_cdbef );for _affgg ,_efcce :=range _cdbef .Elements (){if _fdffe ,_agdc :=_efcce .(*PdfObjectReference );_agdc {_gddda :=_fdffe .Resolve ();_cdbef .Set (_affgg ,_gddda );_gbdd :=_ffbaf (_gddda ,_edecb +1,_geggc );if _gbdd !=nil {return _gbdd ;};}else {_fagef :=_ffbaf (_efcce ,_edecb +1,_geggc );if _fagef !=nil {return _fagef ;};};};return nil ;case *PdfObjectReference :_bf .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020T\u0072\u0061\u0063\u0069\u006e\u0067\u0020\u0061\u0020r\u0065\u0066\u0065r\u0065n\u0063\u0065\u0021");return _e .New ("\u0065r\u0072\u006f\u0072\u0020t\u0072\u0061\u0063\u0069\u006eg\u0020a\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");};return nil ;};

// PdfIndirectObject represents the primitive PDF indirect object.
type PdfIndirectObject struct{PdfObjectReference ;PdfObject ;};var _cbaf =_dce .MustCompile ("\u005c\u0073\u002a\u0078\u0072\u0065\u0066\u005c\u0073\u002a");

// WriteString outputs the object as it is to be written to file.
func (_gggf *PdfObjectDictionary )WriteString ()string {var _cfab _ab .Builder ;_cfab .WriteString ("\u003c\u003c");for _ ,_ffda :=range _gggf ._eaef {_ebfc :=_gggf ._ffca [_ffda ];_cfab .WriteString (_ffda .WriteString ());_cfab .WriteString ("\u0020");_cfab .WriteString (_ebfc .WriteString ());};_cfab .WriteString ("\u003e\u003e");return _cfab .String ();};

// Encrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_dcde *PdfCrypt )Encrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _dcde .isEncrypted (obj ){return nil ;};switch _agbe :=obj .(type ){case *PdfIndirectObject :_dcde ._eecg [_agbe ]=true ;_bf .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_agbe .ObjectNumber ,_agbe .GenerationNumber );_eaac :=_agbe .ObjectNumber ;_fadb :=_agbe .GenerationNumber ;_eae :=_dcde .Encrypt (_agbe .PdfObject ,_eaac ,_fadb );if _eae !=nil {return _eae ;};return nil ;case *PdfObjectStream :_dcde ._eecg [_agbe ]=true ;_dfb :=_agbe .PdfObjectDictionary ;if _ddab ,_gbf :=_dfb .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_gbf &&*_ddab =="\u0058\u0052\u0065\u0066"{return nil ;};_cfd :=_agbe .ObjectNumber ;_dae :=_agbe .GenerationNumber ;_bf .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_cfd ,_dae );_efc :=_edd ;if _dcde ._gbe .V >=4{_efc =_dcde ._cbca ;_bf .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_dcde ._cbca );if _acgb ,_cede :=_dfb .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );_cede {if _bcf ,_feag :=GetName (_acgb .Get (0));_feag {if *_bcf =="\u0043\u0072\u0079p\u0074"{_efc ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _fgag ,_cga :=_dfb .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );_cga {if _bdb ,_gfdd :=_fgag .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_gfdd {if _ ,_fda :=_dcde ._ecb [string (*_bdb )];_fda {_bf .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_bdb );_efc =string (*_bdb );};};};};};};_bf .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_efc );if _efc =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_eaab :=_dcde .Encrypt (_agbe .PdfObjectDictionary ,_cfd ,_dae );if _eaab !=nil {return _eaab ;};_agcd ,_eaab :=_dcde .makeKey (_efc ,uint32 (_cfd ),uint32 (_dae ),_dcde ._cce );if _eaab !=nil {return _eaab ;};_agbe .Stream ,_eaab =_dcde .encryptBytes (_agbe .Stream ,_efc ,_agcd );if _eaab !=nil {return _eaab ;};_dfb .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_agbe .Stream ))));return nil ;case *PdfObjectString :_bf .Log .Trace ("\u0045n\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_gcab :=_edd ;if _dcde ._gbe .V >=4{_bf .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_dcde ._gbba );if _dcde ._gbba =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_gcab =_dcde ._gbba ;};_dgfd ,_gddd :=_dcde .makeKey (_gcab ,uint32 (parentObjNum ),uint32 (parentGenNum ),_dcde ._cce );if _gddd !=nil {return _gddd ;};_gbbaa :=_agbe .Str ();_cdff :=make ([]byte ,len (_gbbaa ));for _eeb :=0;_eeb < len (_gbbaa );_eeb ++{_cdff [_eeb ]=_gbbaa [_eeb ];};_bf .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_cdff ,_cdff );_cdff ,_gddd =_dcde .encryptBytes (_cdff ,_gcab ,_dgfd );if _gddd !=nil {return _gddd ;};_agbe ._gcae =string (_cdff );return nil ;case *PdfObjectArray :for _ ,_gcbc :=range _agbe .Elements (){_edeb :=_dcde .Encrypt (_gcbc ,parentObjNum ,parentGenNum );if _edeb !=nil {return _edeb ;};};return nil ;case *PdfObjectDictionary :_defd :=false ;if _fgbg :=_agbe .Get ("\u0054\u0079\u0070\u0065");_fgbg !=nil {_cccg ,_defe :=_fgbg .(*PdfObjectName );if _defe &&*_cccg =="\u0053\u0069\u0067"{_defd =true ;};};for _ ,_bbee :=range _agbe .Keys (){_fdad :=_agbe .Get (_bbee );if _defd &&string (_bbee )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;};if string (_bbee )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_bbee )!="\u0050\u0072\u0065\u0076"&&string (_bbee )!="\u004c\u0061\u0073\u0074"{_ddf :=_dcde .Encrypt (_fdad ,parentObjNum ,parentGenNum );if _ddf !=nil {return _ddf ;};};};return nil ;};return nil ;};

// DecodeStream decodes a DCT encoded stream and returns the result as a
// slice of bytes.
func (_edcb *DCTEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _edcb .DecodeBytes (streamObj .Stream );};

// Set sets the PdfObject at index i of the array. An error is returned if the index is outside bounds.
func (_ababc *PdfObjectArray )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_ababc ._cdbee ){return _e .New ("\u006f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_ababc ._cdbee [i ]=obj ;return nil ;};

// DecodeBytes decodes a byte slice from Run length encoding.
//
// 7.4.5 RunLengthDecode Filter
// The RunLengthDecode filter decodes data that has been encoded in a simple byte-oriented format based on run length.
// The encoded data shall be a sequence of runs, where each run shall consist of a length byte followed by 1 to 128
// bytes of data. If the length byte is in the range 0 to 127, the following length + 1 (1 to 128) bytes shall be
// copied literally during decompression. If length is in the range 129 to 255, the following single byte shall be
// copied 257 - length (2 to 128) times during decompression. A length value of 128 shall denote EOD.
func (_cbff *RunLengthEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_eddf :=_fb .NewReader (encoded );var _gbdg []byte ;for {_ecaee ,_efcf :=_eddf .ReadByte ();if _efcf !=nil {return nil ,_efcf ;};if _ecaee > 128{_degdg ,_fgaf :=_eddf .ReadByte ();if _fgaf !=nil {return nil ,_fgaf ;};for _aefa :=0;_aefa < 257-int (_ecaee );_aefa ++{_gbdg =append (_gbdg ,_degdg );};}else if _ecaee < 128{for _fcg :=0;_fcg < int (_ecaee )+1;_fcg ++{_ffgc ,_gfeb :=_eddf .ReadByte ();if _gfeb !=nil {return nil ,_gfeb ;};_gbdg =append (_gbdg ,_ffgc );};}else {break ;};};return _gbdg ,nil ;};func _agg (_eba *PdfObjectStream ,_fbga *PdfObjectDictionary )(*LZWEncoder ,error ){_bedd :=NewLZWEncoder ();_ebcg :=_eba .PdfObjectDictionary ;if _ebcg ==nil {return _bedd ,nil ;};if _fbga ==nil {_egfb :=TraceToDirectObject (_ebcg .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));if _egfb !=nil {if _deaa ,_gbbc :=_egfb .(*PdfObjectDictionary );_gbbc {_fbga =_deaa ;}else if _bcb ,_aefb :=_egfb .(*PdfObjectArray );_aefb {if _bcb .Len ()==1{if _ead ,_eebd :=GetDict (_bcb .Get (0));_eebd {_fbga =_ead ;};};};if _fbga ==nil {_bf .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_egfb );return nil ,_ce .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};};_dgg :=_ebcg .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");if _dgg !=nil {_geff ,_cae :=_dgg .(*PdfObjectInteger );if !_cae {_bf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a \u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065d\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u006e\u0075\u006d\u0065\u0072i\u0063 \u0028\u0025\u0054\u0029",_dgg );return nil ,_ce .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");};if *_geff !=0&&*_geff !=1{return nil ,_ce .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0076\u0061\u006c\u0075e\u0020\u0028\u006e\u006f\u0074 \u0030\u0020o\u0072\u0020\u0031\u0029");};_bedd .EarlyChange =int (*_geff );}else {_bedd .EarlyChange =1;};if _fbga ==nil {return _bedd ,nil ;};if _cfg ,_bfb :=GetIntVal (_fbga .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065"));_bfb {if _cfg ==0||_cfg ==1{_bedd .EarlyChange =_cfg ;}else {_bf .Log .Debug ("W\u0041\u0052\u004e\u003a\u0020\u0069n\u0076\u0061\u006c\u0069\u0064\u0020E\u0061\u0072\u006c\u0079\u0043\u0068\u0061n\u0067\u0065\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020%\u0064",_cfg );};};_dgg =_fbga .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");if _dgg !=nil {_fgbf ,_ebd :=_dgg .(*PdfObjectInteger );if !_ebd {_bf .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_dgg );return nil ,_ce .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_bedd .Predictor =int (*_fgbf );};_dgg =_fbga .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");if _dgg !=nil {_ebaf ,_febb :=_dgg .(*PdfObjectInteger );if !_febb {_bf .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");return nil ,_ce .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_bedd .BitsPerComponent =int (*_ebaf );};if _bedd .Predictor > 1{_bedd .Columns =1;_dgg =_fbga .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");if _dgg !=nil {_ddfa ,_febe :=_dgg .(*PdfObjectInteger );if !_febe {return nil ,_ce .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_bedd .Columns =int (*_ddfa );};_bedd .Colors =1;_dgg =_fbga .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _dgg !=nil {_gedd ,_gdbg :=_dgg .(*PdfObjectInteger );if !_gdbg {return nil ,_ce .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");};_bedd .Colors =int (*_gedd );};};_bf .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_fbga .String ());return _bedd ,nil ;};

// PdfObjectStream represents the primitive PDF Object stream.
type PdfObjectStream struct{PdfObjectReference ;*PdfObjectDictionary ;Stream []byte ;};func _acff (_efca *PdfObjectDictionary )(_bfee *_aa .ImageBase ){var (_gcdd *PdfObjectInteger ;_dfbaa bool ;);if _gcdd ,_dfbaa =_efca .Get ("\u0057\u0069\u0064t\u0068").(*PdfObjectInteger );_dfbaa {_bfee =&_aa .ImageBase {Width :int (*_gcdd )};}else {return nil ;};if _gcdd ,_dfbaa =_efca .Get ("\u0048\u0065\u0069\u0067\u0068\u0074").(*PdfObjectInteger );_dfbaa {_bfee .Height =int (*_gcdd );};if _gcdd ,_dfbaa =_efca .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074").(*PdfObjectInteger );_dfbaa {_bfee .BitsPerComponent =int (*_gcdd );};if _gcdd ,_dfbaa =_efca .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073").(*PdfObjectInteger );_dfbaa {_bfee .ColorComponents =int (*_gcdd );};return _bfee ;};

// PdfVersion returns version of the PDF file.
func (_adbb *PdfParser )PdfVersion ()Version {return _adbb ._eaagd };

// ReadBytesAt reads byte content at specific offset and length within the PDF.
func (_geaf *PdfParser )ReadBytesAt (offset ,len int64 )([]byte ,error ){_fcf :=_geaf .GetFileOffset ();_ ,_bbgd :=_geaf ._aagc .Seek (offset ,_aba .SeekStart );if _bbgd !=nil {return nil ,_bbgd ;};_ccgg :=make ([]byte ,len );_ ,_bbgd =_aba .ReadAtLeast (_geaf ._aagc ,_ccgg ,int (len ));if _bbgd !=nil {return nil ,_bbgd ;};_geaf .SetFileOffset (_fcf );return _ccgg ,nil ;};

// AddPageImage adds the page with the image 'img' to the encoder context in order to encode it jbig2 document.
// The 'settings' defines what encoding type should be used by the encoder.
func (_fcgeb *JBIG2Encoder )AddPageImage (img *JBIG2Image ,settings *JBIG2EncoderSettings )(_gcbe error ){const _adgd ="\u004a\u0042\u0049\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0041\u0064\u0064\u0050\u0061\u0067\u0065\u0049m\u0061\u0067\u0065";if _fcgeb ==nil {return _fg .Error (_adgd ,"J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u0020\u0069\u0073 n\u0069\u006c");};if settings ==nil {settings =&_fcgeb .DefaultPageSettings ;};if _fcgeb ._ddfd ==nil {_fcgeb ._ddfd =_ca .InitEncodeDocument (settings .FileMode );};if _gcbe =settings .Validate ();_gcbe !=nil {return _fg .Wrap (_gcbe ,_adgd ,"");};_cbbdc ,_gcbe :=img .toBitmap ();if _gcbe !=nil {return _fg .Wrap (_gcbe ,_adgd ,"");};switch settings .Compression {case JB2Generic :if _gcbe =_fcgeb ._ddfd .AddGenericPage (_cbbdc ,settings .DuplicatedLinesRemoval );_gcbe !=nil {return _fg .Wrap (_gcbe ,_adgd ,"");};case JB2SymbolCorrelation :return _fg .Error (_adgd ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");case JB2SymbolRankHaus :return _fg .Error (_adgd ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");default:return _fg .Error (_adgd ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return nil ;};

// WriteString outputs the object as it is to be written to file.
func (_deff *PdfObjectStream )WriteString ()string {var _agaac _ab .Builder ;_agaac .WriteString (_dc .FormatInt (_deff .ObjectNumber ,10));_agaac .WriteString ("\u0020\u0030\u0020\u0052");return _agaac .String ();};

// Resolve resolves a PdfObject to direct object, looking up and resolving references as needed (unlike TraceToDirect).
func (_eec *PdfParser )Resolve (obj PdfObject )(PdfObject ,error ){_ba ,_ceg :=obj .(*PdfObjectReference );if !_ceg {return obj ,nil ;};_df :=_eec .GetFileOffset ();defer func (){_eec .SetFileOffset (_df )}();_fd ,_gfc :=_eec .LookupByReference (*_ba );if _gfc !=nil {return nil ,_gfc ;};_egf ,_fec :=_fd .(*PdfIndirectObject );if !_fec {return _fd ,nil ;};_fd =_egf .PdfObject ;_ ,_ceg =_fd .(*PdfObjectReference );if _ceg {return _egf ,_e .New ("\u006d\u0075lt\u0069\u0020\u0064e\u0070\u0074\u0068\u0020tra\u0063e \u0070\u006f\u0069\u006e\u0074\u0065\u0072 t\u006f\u0020\u0070\u006f\u0069\u006e\u0074e\u0072");};return _fd ,nil ;};

// GetNameVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetNameVal (obj PdfObject )(_gfgf string ,_egcgg bool ){_ggag ,_egcgg :=TraceToDirectObject (obj ).(*PdfObjectName );if _egcgg {return string (*_ggag ),true ;};return ;};

// String returns a string representation of `name`.
func (_adgfa *PdfObjectName )String ()string {return string (*_adgfa )};func _baaa (_edge ,_eded ,_ggga int )error {if _eded < 0||_eded > _edge {return _e .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0061\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");};if _ggga < _eded {return _e .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0073\u006c\u0069\u0063e\u0020i\u006ed\u0065\u0078\u0020\u0062\u0020\u003c\u0020a");};if _ggga > _edge {return _e .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0062\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");};return nil ;};

// Decoded returns the PDFDocEncoding or UTF-16BE decoded string contents.
// UTF-16BE is applied when the first two bytes are 0xFE, 0XFF, otherwise decoding of
// PDFDocEncoding is performed.
func (_efae *PdfObjectString )Decoded ()string {if _efae ==nil {return "";};_cbbafg :=[]byte (_efae ._gcae );if len (_cbbafg )>=2&&_cbbafg [0]==0xFE&&_cbbafg [1]==0xFF{return _ae .UTF16ToString (_cbbafg [2:]);};return _ae .PDFDocEncodingToString (_cbbafg );};

// GetDict returns the *PdfObjectDictionary represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetDict (obj PdfObject )(_ggcd *PdfObjectDictionary ,_bfgc bool ){_ggcd ,_bfgc =TraceToDirectObject (obj ).(*PdfObjectDictionary );return _ggcd ,_bfgc ;};

// GetNumberAsInt64 returns the contents of `obj` as an int64 if it is an integer or float, or an
// error if it isn't. This is for cases where expecting an integer, but some implementations
// actually store the number in a floating point format.
func GetNumberAsInt64 (obj PdfObject )(int64 ,error ){switch _aagg :=obj .(type ){case *PdfObjectFloat :_bf .Log .Debug ("\u004e\u0075m\u0062\u0065\u0072\u0020\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0061\u0073\u0020\u0069\u006e\u0074e\u0067\u0065\u0072\u0020\u0077\u0061s\u0020\u0073\u0074\u006f\u0072\u0065\u0064\u0020\u0061\u0073\u0020\u0066\u006c\u006fa\u0074\u0020(\u0074\u0079\u0070\u0065 \u0063\u0061\u0073\u0074\u0069n\u0067\u0020\u0075\u0073\u0065\u0064\u0029");return int64 (*_aagg ),nil ;case *PdfObjectInteger :return int64 (*_aagg ),nil ;};return 0,ErrNotANumber ;};

// LookupByReference looks up a PdfObject by a reference.
func (_gaeg *PdfParser )LookupByReference (ref PdfObjectReference )(PdfObject ,error ){_bf .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0075\u0070\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0025\u0073",ref .String ());return _gaeg .LookupByNumber (int (ref .ObjectNumber ));};

// IsDelimiter checks if a character represents a delimiter.
func IsDelimiter (c byte )bool {return c =='('||c ==')'||c =='<'||c =='>'||c =='['||c ==']'||c =='{'||c =='}'||c =='/'||c =='%';};

// MakeFloat creates an PdfObjectFloat from a float64.
func MakeFloat (val float64 )*PdfObjectFloat {_gbce :=PdfObjectFloat (val );return &_gbce };

// DecodeStream returns the passed in stream as a slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_acf *RawEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return streamObj .Stream ,nil ;};

// PdfObjectDictionary represents the primitive PDF dictionary/map object.
type PdfObjectDictionary struct{_ffca map[PdfObjectName ]PdfObject ;_eaef []PdfObjectName ;_ddgdd *PdfParser ;};

// GetStringVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetStringVal (obj PdfObject )(_gfbff string ,_cebf bool ){_ccgf ,_cebf :=TraceToDirectObject (obj ).(*PdfObjectString );if _cebf {return _ccgf .Str (),true ;};return ;};func _ffe (_bacd *PdfObjectStream )(*MultiEncoder ,error ){_gdedg :=NewMultiEncoder ();_fabb :=_bacd .PdfObjectDictionary ;if _fabb ==nil {return _gdedg ,nil ;};var _cedcb *PdfObjectDictionary ;var _ccbb []PdfObject ;_ffaga :=_fabb .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _ffaga !=nil {_gfcc ,_acaae :=_ffaga .(*PdfObjectDictionary );if _acaae {_cedcb =_gfcc ;};_ccaf ,_fagab :=_ffaga .(*PdfObjectArray );if _fagab {for _ ,_ebdf :=range _ccaf .Elements (){_ebdf =TraceToDirectObject (_ebdf );if _dbcb ,_agcc :=_ebdf .(*PdfObjectDictionary );_agcc {_ccbb =append (_ccbb ,_dbcb );}else {_ccbb =append (_ccbb ,MakeDict ());};};};};_ffaga =_fabb .Get ("\u0046\u0069\u006c\u0074\u0065\u0072");if _ffaga ==nil {return nil ,_ce .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u006d\u0069s\u0073\u0069\u006e\u0067");};_aaeb ,_fcge :=_ffaga .(*PdfObjectArray );if !_fcge {return nil ,_ce .Errorf ("m\u0075\u006c\u0074\u0069\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0063\u0061\u006e\u0020\u006f\u006el\u0079\u0020\u0062\u0065\u0020\u006d\u0061\u0064\u0065\u0020fr\u006f\u006d\u0020a\u0072r\u0061\u0079");};for _fdfa ,_ecee :=range _aaeb .Elements (){_gcdf ,_ecce :=_ecee .(*PdfObjectName );if !_ecce {return nil ,_ce .Errorf ("\u006d\u0075l\u0074\u0069\u0020\u0066i\u006c\u0074e\u0072\u0020\u0061\u0072\u0072\u0061\u0079\u0020e\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u006e\u006f\u0074\u0020\u0061 \u006e\u0061\u006d\u0065");};var _cdaa PdfObject ;if _cedcb !=nil {_cdaa =_cedcb ;}else {if len (_ccbb )> 0{if _fdfa >=len (_ccbb ){return nil ,_ce .Errorf ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0073\u0020\u0069\u006e\u0020d\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006d\u0073\u0020a\u0072\u0072\u0061\u0079");};_cdaa =_ccbb [_fdfa ];};};var _ddbd *PdfObjectDictionary ;if _afecc ,_dbfe :=_cdaa .(*PdfObjectDictionary );_dbfe {_ddbd =_afecc ;};_bf .Log .Trace ("\u004e\u0065\u0078t \u006e\u0061\u006d\u0065\u003a\u0020\u0025\u0073\u002c \u0064p\u003a \u0025v\u002c\u0020\u0064\u0050\u0061\u0072\u0061\u006d\u0073\u003a\u0020\u0025\u0076",*_gcdf ,_cdaa ,_ddbd );if *_gcdf ==StreamEncodingFilterNameFlate {_gaeee ,_fdcd :=_dfba (_bacd ,_ddbd );if _fdcd !=nil {return nil ,_fdcd ;};_gdedg .AddEncoder (_gaeee );}else if *_gcdf ==StreamEncodingFilterNameLZW {_egge ,_gcabg :=_agg (_bacd ,_ddbd );if _gcabg !=nil {return nil ,_gcabg ;};_gdedg .AddEncoder (_egge );}else if *_gcdf ==StreamEncodingFilterNameASCIIHex {_dedc :=NewASCIIHexEncoder ();_gdedg .AddEncoder (_dedc );}else if *_gcdf ==StreamEncodingFilterNameASCII85 {_acaf :=NewASCII85Encoder ();_gdedg .AddEncoder (_acaf );}else if *_gcdf ==StreamEncodingFilterNameDCT {_cdb ,_cdeed :=_cge (_bacd ,_gdedg );if _cdeed !=nil {return nil ,_cdeed ;};_gdedg .AddEncoder (_cdb );_bf .Log .Trace ("A\u0064d\u0065\u0064\u0020\u0044\u0043\u0054\u0020\u0065n\u0063\u006f\u0064\u0065r.\u002e\u002e");_bf .Log .Trace ("\u004du\u006ct\u0069\u0020\u0065\u006e\u0063o\u0064\u0065r\u003a\u0020\u0025\u0023\u0076",_gdedg );}else {_bf .Log .Error ("U\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0066\u0069l\u0074\u0065\u0072\u0020\u0025\u0073",*_gcdf );return nil ,_ce .Errorf ("\u0069\u006eva\u006c\u0069\u0064 \u0066\u0069\u006c\u0074er \u0069n \u006d\u0075\u006c\u0074\u0069\u0020\u0066il\u0074\u0065\u0072\u0020\u0061\u0072\u0072a\u0079");};};return _gdedg ,nil ;};

// Merge merges in key/values from another dictionary. Overwriting if has same keys.
// The mutated dictionary (d) is returned in order to allow method chaining.
func (_bfeca *PdfObjectDictionary )Merge (another *PdfObjectDictionary )*PdfObjectDictionary {if another !=nil {for _ ,_egged :=range another .Keys (){_dgdb :=another .Get (_egged );_bfeca .Set (_egged ,_dgdb );};};return _bfeca ;};

// GetFilterArray returns the names of the underlying encoding filters in an array that
// can be used as /Filter entry.
func (_aacc *MultiEncoder )GetFilterArray ()*PdfObjectArray {_ecca :=make ([]PdfObject ,len (_aacc ._gbag ));for _dfaf ,_bcfe :=range _aacc ._gbag {_ecca [_dfaf ]=MakeName (_bcfe .GetFilterName ());};return MakeArray (_ecca ...);};type objectCache map[int ]PdfObject ;

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_egag *FlateEncoder )EncodeBytes (data []byte )([]byte ,error ){if _egag .Predictor !=1&&_egag .Predictor !=11{_bf .Log .Debug ("E\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0046\u006c\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065r\u0020P\u0072\u0065\u0064\u0069c\u0074\u006fr\u0020\u003d\u0020\u0031\u002c\u0020\u0031\u0031\u0020\u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");return nil ,ErrUnsupportedEncodingParameters ;};if _egag .Predictor ==11{_cccf :=_egag .Columns ;_daeg :=len (data )/_cccf ;if len (data )%_cccf !=0{_bf .Log .Error ("\u0049n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");return nil ,_e .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");};_faae :=_fb .NewBuffer (nil );_afaf :=make ([]byte ,_cccf );for _afeg :=0;_afeg < _daeg ;_afeg ++{_gfb :=data [_cccf *_afeg :_cccf *(_afeg +1)];_afaf [0]=_gfb [0];for _ecgb :=1;_ecgb < _cccf ;_ecgb ++{_afaf [_ecgb ]=byte (int (_gfb [_ecgb ]-_gfb [_ecgb -1])%256);};_faae .WriteByte (1);_faae .Write (_afaf );};data =_faae .Bytes ();};var _gaec _fb .Buffer ;_bab :=_c .NewWriter (&_gaec );_bab .Write (data );_bab .Close ();return _gaec .Bytes (),nil ;};type cryptFilters map[string ]_ecf .Filter ;func (_dfff *FlateEncoder )postDecodePredict (_ccg []byte )([]byte ,error ){if _dfff .Predictor > 1{if _dfff .Predictor ==2{_bf .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_bf .Log .Trace ("\u0043\u006f\u006c\u006f\u0072\u0073\u003a\u0020\u0025\u0064",_dfff .Colors );_edf :=_dfff .Columns *_dfff .Colors ;if _edf < 1{return []byte {},nil ;};_beg :=len (_ccg )/_edf ;if len (_ccg )%_edf !=0{_bf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");return nil ,_ce .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_ccg ),_edf );};if _edf %_dfff .Colors !=0{return nil ,_ce .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_edf ,_dfff .Colors );};if _edf > len (_ccg ){_bf .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_edf ,len (_ccg ));return nil ,_e .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_bf .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_ccg ),_ccg );_edae :=_fb .NewBuffer (nil );for _fgcd :=0;_fgcd < _beg ;_fgcd ++{_cedd :=_ccg [_edf *_fgcd :_edf *(_fgcd +1)];for _facg :=_dfff .Colors ;_facg < _edf ;_facg ++{_cedd [_facg ]+=_cedd [_facg -_dfff .Colors ];};_edae .Write (_cedd );};_afg :=_edae .Bytes ();_bf .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_afg ),_afg );return _afg ,nil ;}else if _dfff .Predictor >=10&&_dfff .Predictor <=15{_bf .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_bfgb :=_dfff .Columns *_dfff .Colors +1;_gaf :=len (_ccg )/_bfgb ;if len (_ccg )%_bfgb !=0{return nil ,_ce .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_ccg ),_bfgb );};if _bfgb > len (_ccg ){_bf .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_bfgb ,len (_ccg ));return nil ,_e .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_aabb :=_fb .NewBuffer (nil );_bf .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_dfff .Columns );_bf .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_ccg ),_bfgb ,_gaf );_dabe :=make ([]byte ,_bfgb );for _bbc :=0;_bbc < _bfgb ;_bbc ++{_dabe [_bbc ]=0;};_bge :=_dfff .Colors ;for _dffb :=0;_dffb < _gaf ;_dffb ++{_gacc :=_ccg [_bfgb *_dffb :_bfgb *(_dffb +1)];_ecc :=_gacc [0];switch _ecc {case _aafa :case _aceg :for _dbeg :=1+_bge ;_dbeg < _bfgb ;_dbeg ++{_gacc [_dbeg ]+=_gacc [_dbeg -_bge ];};case _accf :for _fded :=1;_fded < _bfgb ;_fded ++{_gacc [_fded ]+=_dabe [_fded ];};case _cde :for _abad :=1;_abad < _bge +1;_abad ++{_gacc [_abad ]+=_dabe [_abad ]/2;};for _fdadb :=_bge +1;_fdadb < _bfgb ;_fdadb ++{_gacc [_fdadb ]+=byte ((int (_gacc [_fdadb -_bge ])+int (_dabe [_fdadb ]))/2);};case _fecf :for _cda :=1;_cda < _bfgb ;_cda ++{var _face ,_bede ,_bbce byte ;_bede =_dabe [_cda ];if _cda >=_bge +1{_face =_gacc [_cda -_bge ];_bbce =_dabe [_cda -_bge ];};_gacc [_cda ]+=_fdab (_face ,_bede ,_bbce );};default:_bf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029\u0020\u0040\u0072o\u0077\u0020\u0025\u0064",_ecc ,_dffb );return nil ,_ce .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_ecc );};copy (_dabe ,_gacc );_aabb .Write (_gacc [1:]);};_cba :=_aabb .Bytes ();return _cba ,nil ;}else {_bf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_dfff .Predictor );return nil ,_ce .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_dfff .Predictor );};};return _ccg ,nil ;};

// WriteString outputs the object as it is to be written to file.
func (_gbdab *PdfObjectName )WriteString ()string {var _gbee _fb .Buffer ;if len (*_gbdab )> 127{_bf .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u004e\u0061\u006d\u0065\u0020t\u006fo\u0020l\u006f\u006e\u0067\u0020\u0028\u0025\u0073)",*_gbdab );};_gbee .WriteString ("\u002f");for _fgda :=0;_fgda < len (*_gbdab );_fgda ++{_cbag :=(*_gbdab )[_fgda ];if !IsPrintable (_cbag )||_cbag =='#'||IsDelimiter (_cbag ){_gbee .WriteString (_ce .Sprintf ("\u0023\u0025\u002e2\u0078",_cbag ));}else {_gbee .WriteByte (_cbag );};};return _gbee .String ();};

// SetIfNotNil sets the dictionary's key -> val mapping entry -IF- val is not nil.
// Note that we take care to perform a type switch.  Otherwise if we would supply a nil value
// of another type, e.g. (PdfObjectArray*)(nil), then it would not be a PdfObject(nil) and thus
// would get set.
func (_faacg *PdfObjectDictionary )SetIfNotNil (key PdfObjectName ,val PdfObject ){if val !=nil {switch _fdbc :=val .(type ){case *PdfObjectName :if _fdbc !=nil {_faacg .Set (key ,val );};case *PdfObjectDictionary :if _fdbc !=nil {_faacg .Set (key ,val );};case *PdfObjectStream :if _fdbc !=nil {_faacg .Set (key ,val );};case *PdfObjectString :if _fdbc !=nil {_faacg .Set (key ,val );};case *PdfObjectNull :if _fdbc !=nil {_faacg .Set (key ,val );};case *PdfObjectInteger :if _fdbc !=nil {_faacg .Set (key ,val );};case *PdfObjectArray :if _fdbc !=nil {_faacg .Set (key ,val );};case *PdfObjectBool :if _fdbc !=nil {_faacg .Set (key ,val );};case *PdfObjectFloat :if _fdbc !=nil {_faacg .Set (key ,val );};case *PdfObjectReference :if _fdbc !=nil {_faacg .Set (key ,val );};case *PdfIndirectObject :if _fdbc !=nil {_faacg .Set (key ,val );};default:_bf .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",val );};};};

// UpdateParams updates the parameter values of the encoder.
func (_cbfd *MultiEncoder )UpdateParams (params *PdfObjectDictionary ){for _ ,_cfae :=range _cbfd ._gbag {_cfae .UpdateParams (params );};};

// NewASCIIHexEncoder makes a new ASCII hex encoder.
func NewASCIIHexEncoder ()*ASCIIHexEncoder {_cbcaa :=&ASCIIHexEncoder {};return _cbcaa };

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_abgf *FlateEncoder )MakeDecodeParams ()PdfObject {if _abgf .Predictor > 1{_beca :=MakeDict ();_beca .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_abgf .Predictor )));if _abgf .BitsPerComponent !=8{_beca .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_abgf .BitsPerComponent )));};if _abgf .Columns !=1{_beca .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_abgf .Columns )));};if _abgf .Colors !=1{_beca .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_abgf .Colors )));};return _beca ;};return nil ;};func _gege (_accc *PdfObjectStream ,_baca *PdfObjectDictionary )(*RunLengthEncoder ,error ){return NewRunLengthEncoder (),nil ;};

// ToInt64Slice returns a slice of all array elements as an int64 slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_bgad *PdfObjectArray )ToInt64Slice ()([]int64 ,error ){var _aeddg []int64 ;for _ ,_afeb :=range _bgad .Elements (){if _fffa ,_beabf :=_afeb .(*PdfObjectInteger );_beabf {_aeddg =append (_aeddg ,int64 (*_fffa ));}else {return nil ,ErrTypeError ;};};return _aeddg ,nil ;};

// DecodeStream decodes the stream data and returns the decoded data.
// An error is returned upon failure.
func DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_bf .Log .Trace ("\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_dadd ,_ecfb :=NewEncoderFromStream (streamObj );if _ecfb !=nil {_bf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_ecfb );return nil ,_ecfb ;};_bf .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076\u000a",_dadd );_dadac ,_ecfb :=_dadd .DecodeStream (streamObj );if _ecfb !=nil {_bf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_ecfb );return nil ,_ecfb ;};return _dadac ,nil ;};

// NewParser creates a new parser for a PDF file via ReadSeeker. Loads the cross reference stream and trailer.
// An error is returned on failure.
func NewParser (rs _aba .ReadSeeker )(*PdfParser ,error ){_bddd :=&PdfParser {_aagc :rs ,ObjCache :make (objectCache ),_ffdfa :map[int64 ]bool {}};_bdfeb ,_ffad ,_begf :=_bddd .parsePdfVersion ();if _begf !=nil {_bf .Log .Error ("U\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0076e\u0072\u0073\u0069o\u006e:\u0020\u0025\u0076",_begf );return nil ,_begf ;};_bddd ._eaagd .Major =_bdfeb ;_bddd ._eaagd .Minor =_ffad ;if _bddd ._caec ,_begf =_bddd .loadXrefs ();_begf !=nil {_bf .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020F\u0061\u0069\u006c\u0065d t\u006f l\u006f\u0061\u0064\u0020\u0078\u0072\u0065f \u0074\u0061\u0062\u006c\u0065\u0021\u0020%\u0073",_begf );return nil ,_begf ;};_bf .Log .Trace ("T\u0072\u0061\u0069\u006c\u0065\u0072\u003a\u0020\u0025\u0073",_bddd ._caec );if len (_bddd ._bbfg .ObjectMap )==0{return nil ,_ce .Errorf ("\u0065\u006d\u0070\u0074\u0079\u0020\u0058\u0052\u0045\u0046\u0020t\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0049\u006e\u0076a\u006c\u0069\u0064");};return _bddd ,nil ;};

// IsFloatDigit checks if a character can be a part of a float number string.
func IsFloatDigit (c byte )bool {return ('0'<=c &&c <='9')||c =='.'};

// GetFilterName returns the name of the encoding filter.
func (_dgfb *CCITTFaxEncoder )GetFilterName ()string {return StreamEncodingFilterNameCCITTFax };func (_agaf *PdfCrypt )saveCryptFilters (_acdf *PdfObjectDictionary )error {if _agaf ._gbe .V < 4{return _e .New ("\u0063\u0061\u006e\u0020\u006f\u006e\u006c\u0079\u0020\u0062\u0065 \u0075\u0073\u0065\u0064\u0020\u0077\u0069\u0074\u0068\u0020V\u003e\u003d\u0034");};_abgb :=MakeDict ();_acdf .Set ("\u0043\u0046",_abgb );for _cced ,_edb :=range _agaf ._ecb {if _cced =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{continue ;};_bce :=_aae (_edb ,"");_abgb .Set (PdfObjectName (_cced ),_bce );};_acdf .Set ("\u0053\u0074\u0072\u0046",MakeName (_agaf ._gbba ));_acdf .Set ("\u0053\u0074\u006d\u0046",MakeName (_agaf ._cbca ));return nil ;};

// IsAuthenticated returns true if the PDF has already been authenticated for accessing.
func (_dabef *PdfParser )IsAuthenticated ()bool {return _dabef ._aggc ._fbc };

// GetString is a helper for Get that returns a string value.
// Returns false if the key is missing or a value is not a string.
func (_feeg *PdfObjectDictionary )GetString (key PdfObjectName )(string ,bool ){_ecga ,_gbab :=_feeg ._ffca [key ].(*PdfObjectString );if !_gbab {return "",false ;};return _ecga .Str (),true ;};func (_dfgc *PdfParser )parseXref ()(*PdfObjectDictionary ,error ){const _cefaf =20;_dfgcb ,_ :=_dfgc ._bdc .Peek (_cefaf );for _gdec :=0;_gdec < 2;_gdec ++{if _dfgc ._addb ==0{_dfgc ._addb =_dfgc .GetFileOffset ();};if _dbgg .Match (_dfgcb ){_bf .Log .Trace ("\u0078\u0072e\u0066\u0020\u0070\u006f\u0069\u006e\u0074\u0073\u0020\u0074\u006f\u0020\u0061\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u002e\u0020\u0050\u0072\u006f\u0062\u0061\u0062\u006c\u0079\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063\u0074");_bf .Log .Debug ("\u0073t\u0061r\u0074\u0069\u006e\u0067\u0020w\u0069\u0074h\u0020\u0022\u0025\u0073\u0022",string (_dfgcb ));return _dfgc .parseXrefStream (nil );};if _cbaf .Match (_dfgcb ){_bf .Log .Trace ("\u0053\u0074\u0061\u006ed\u0061\u0072\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073e\u0063t\u0069\u006f\u006e\u0020\u0074\u0061\u0062l\u0065\u0021");return _dfgc .parseXrefTable ();};_edfc :=_dfgc .GetFileOffset ();if _dfgc ._addb ==0{_dfgc ._addb =_edfc ;};_dfgc .SetFileOffset (_edfc -_cefaf );defer _dfgc .SetFileOffset (_edfc );_gccag ,_ :=_dfgc ._bdc .Peek (_cefaf );_dfgcb =append (_gccag ,_dfgcb ...);};_bf .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u0078\u0072\u0065f\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006fr\u0020\u0073\u0074\u0072\u0065\u0061\u006d.\u0020\u0052\u0065\u0070\u0061i\u0072\u0020\u0061\u0074\u0074e\u006d\u0070\u0074\u0065\u0064\u003a\u0020\u004c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0065\u0061\u0072\u006c\u0069\u0065\u0073\u0074\u0020x\u0072\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u0062\u006f\u0074to\u006d\u002e");if _eebde :=_dfgc .repairSeekXrefMarker ();_eebde !=nil {_bf .Log .Debug ("\u0052e\u0070a\u0069\u0072\u0020\u0066\u0061i\u006c\u0065d\u0020\u002d\u0020\u0025\u0076",_eebde );return nil ,_eebde ;};return _dfgc .parseXrefTable ();};var _bgba =_dce .MustCompile ("\u005e\\\u0073\u002a\u005b\u002d]\u002a\u0028\u005c\u0064\u002b)\u005cs\u002b(\u005c\u0064\u002b\u0029\u005c\u0073\u002bR");

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_edca *MultiEncoder )MakeDecodeParams ()PdfObject {if len (_edca ._gbag )==0{return nil ;};if len (_edca ._gbag )==1{return _edca ._gbag [0].MakeDecodeParams ();};_eeba :=MakeArray ();for _ ,_cdfae :=range _edca ._gbag {_dfcf :=_cdfae .MakeDecodeParams ();if _dfcf ==nil {_eeba .Append (MakeNull ());}else {_eeba .Append (_dfcf );};};return _eeba ;};

// Bytes returns the PdfObjectString content as a []byte array.
func (_dfec *PdfObjectString )Bytes ()[]byte {return []byte (_dfec ._gcae )};func (_afbbe *PdfParser )resolveReference (_eacg *PdfObjectReference )(PdfObject ,bool ,error ){_dgaf ,_dbgeg :=_afbbe .ObjCache [int (_eacg .ObjectNumber )];if _dbgeg {return _dgaf ,true ,nil ;};_dafc ,_fage :=_afbbe .LookupByReference (*_eacg );if _fage !=nil {return nil ,false ,_fage ;};_afbbe .ObjCache [int (_eacg .ObjectNumber )]=_dafc ;return _dafc ,false ,nil ;};func (_caff *PdfParser )parseNull ()(PdfObjectNull ,error ){_ ,_feaf :=_caff ._bdc .Discard (4);return PdfObjectNull {},_feaf ;};func (_aecf *PdfCrypt )isDecrypted (_abde PdfObject )bool {_ ,_dab :=_aecf ._fgc [_abde ];if _dab {_bf .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0064\u0065\u0063\u0072y\u0070\u0074\u0065\u0064");return true ;};switch _cfe :=_abde .(type ){case *PdfObjectStream :if _aecf ._dgd .R !=5{if _abfe ,_ecbg :=_cfe .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_ecbg &&*_abfe =="\u0058\u0052\u0065\u0066"{return true ;};};case *PdfIndirectObject :if _ ,_dab =_aecf ._fea [int (_cfe .ObjectNumber )];_dab {return true ;};switch _fdb :=_cfe .PdfObject .(type ){case *PdfObjectDictionary :_cgg :=true ;for _ ,_fae :=range _abcg {if _fdb .Get (_fae )==nil {_cgg =false ;break ;};};if _cgg {return true ;};};};_bf .Log .Trace ("\u004e\u006f\u0074\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");return false ;};func (_aadg *PdfParser )skipSpaces ()(int ,error ){_ebcc :=0;for {_cdfg ,_cdfb :=_aadg ._bdc .ReadByte ();if _cdfb !=nil {return 0,_cdfb ;};if IsWhiteSpace (_cdfg ){_ebcc ++;}else {_aadg ._bdc .UnreadByte ();break ;};};return _ebcc ,nil ;};func (_gca *PdfCrypt )checkAccessRights (_gcb []byte )(bool ,_afe .Permissions ,error ){_ded :=_gca .securityHandler ();_add ,_dcd ,_gdd :=_ded .Authenticate (&_gca ._dgd ,_gcb );if _gdd !=nil {return false ,0,_gdd ;}else if _dcd ==0||len (_add )==0{return false ,0,nil ;};return true ,_dcd ,nil ;};func (_dgcf *PdfParser )parseHexString ()(*PdfObjectString ,error ){_dgcf ._bdc .ReadByte ();var _eada _fb .Buffer ;for {_agfb ,_bfcg :=_dgcf ._bdc .Peek (1);if _bfcg !=nil {return MakeString (""),_bfcg ;};if _agfb [0]=='>'{_dgcf ._bdc .ReadByte ();break ;};_gafc ,_ :=_dgcf ._bdc .ReadByte ();if !IsWhiteSpace (_gafc ){_eada .WriteByte (_gafc );};};if _eada .Len ()%2==1{_eada .WriteRune ('0');};_ecbe ,_ :=_af .DecodeString (_eada .String ());return MakeHexString (string (_ecbe )),nil ;};

// NewFlateEncoder makes a new flate encoder with default parameters, predictor 1 and bits per component 8.
func NewFlateEncoder ()*FlateEncoder {_abcf :=&FlateEncoder {};_abcf .Predictor =1;_abcf .BitsPerComponent =8;_abcf .Colors =1;_abcf .Columns =1;return _abcf ;};

// MakeArray creates an PdfObjectArray from a list of PdfObjects.
func MakeArray (objects ...PdfObject )*PdfObjectArray {return &PdfObjectArray {_cdbee :objects }};

// ResolveReference resolves reference if `o` is a *PdfObjectReference and returns the object referenced to.
// Otherwise returns back `o`.
func ResolveReference (obj PdfObject )PdfObject {if _ccedd ,_dffea :=obj .(*PdfObjectReference );_dffea {return _ccedd .Resolve ();};return obj ;};func (_begg *PdfParser )seekPdfVersionTopDown ()(int ,int ,error ){_begg ._aagc .Seek (0,_aba .SeekStart );_begg ._bdc =_ac .NewReader (_begg ._aagc );_gaga :=20;_deac :=make ([]byte ,_gaga );for {_ccdbg ,_cfef :=_begg ._bdc .ReadByte ();if _cfef !=nil {if _cfef ==_aba .EOF {break ;}else {return 0,0,_cfef ;};};if IsDecimalDigit (_ccdbg )&&_deac [_gaga -1]=='.'&&IsDecimalDigit (_deac [_gaga -2])&&_deac [_gaga -3]=='-'&&_deac [_gaga -4]=='F'&&_deac [_gaga -5]=='D'&&_deac [_gaga -6]=='P'{_aeba :=int (_deac [_gaga -2]-'0');_ebdc :=int (_ccdbg -'0');return _aeba ,_ebdc ,nil ;};_deac =append (_deac [1:_gaga ],_ccdbg );};return 0,0,_e .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};

// String returns a string representation of the *PdfObjectString.
func (_deaag *PdfObjectString )String ()string {return _deaag ._gcae };

// GetFloatVal returns the float64 value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetFloatVal (obj PdfObject )(_bcab float64 ,_ffef bool ){_edddd ,_ffef :=TraceToDirectObject (obj ).(*PdfObjectFloat );if _ffef {return float64 (*_edddd ),true ;};return 0,false ;};

// CheckAccessRights checks access rights and permissions for a specified password. If either user/owner password is
// specified, full rights are granted, otherwise the access rights are specified by the Permissions flag.
//
// The bool flag indicates that the user can access and view the file.
// The AccessPermissions shows what access the user has for editing etc.
// An error is returned if there was a problem performing the authentication.
func (_cdcd *PdfParser )CheckAccessRights (password []byte )(bool ,_afe .Permissions ,error ){if _cdcd ._aggc ==nil {return true ,_afe .PermOwner ,nil ;};return _cdcd ._aggc .checkAccessRights (password );};

// String returns the state of the bool as "true" or "false".
func (_dccb *PdfObjectBool )String ()string {if *_dccb {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};

// GetNumbersAsFloat converts a list of pdf objects representing floats or integers to a slice of
// float64 values.
func GetNumbersAsFloat (objects []PdfObject )(_eacce []float64 ,_gdefd error ){for _ ,_cfadg :=range objects {_aggfa ,_dcfa :=GetNumberAsFloat (_cfadg );if _dcfa !=nil {return nil ,_dcfa ;};_eacce =append (_eacce ,_aggfa );};return _eacce ,nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_cffb *JPXEncoder )MakeDecodeParams ()PdfObject {return nil };

// DecodeBytes decodes a slice of ASCII encoded bytes and returns the result.
func (_gfba *ASCIIHexEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_agea :=_fb .NewReader (encoded );var _ggfg []byte ;for {_aaa ,_bggb :=_agea .ReadByte ();if _bggb !=nil {return nil ,_bggb ;};if _aaa =='>'{break ;};if IsWhiteSpace (_aaa ){continue ;};if (_aaa >='a'&&_aaa <='f')||(_aaa >='A'&&_aaa <='F')||(_aaa >='0'&&_aaa <='9'){_ggfg =append (_ggfg ,_aaa );}else {_bf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0061\u0073\u0063\u0069\u0069 \u0068\u0065\u0078\u0020\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072 \u0028\u0025\u0063\u0029",_aaa );return nil ,_ce .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0061\u0073\u0063\u0069\u0069\u0020\u0068e\u0078 \u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u0020\u0028\u0025\u0063\u0029",_aaa );};};if len (_ggfg )%2==1{_ggfg =append (_ggfg ,'0');};_bf .Log .Trace ("\u0049\u006e\u0062\u006f\u0075\u006e\u0064\u0020\u0025\u0073",_ggfg );_edebb :=make ([]byte ,_af .DecodedLen (len (_ggfg )));_ ,_ccbe :=_af .Decode (_edebb ,_ggfg );if _ccbe !=nil {return nil ,_ccbe ;};return _edebb ,nil ;};func _ddag (_gcaa *PdfObjectStream ,_ddfg *PdfObjectDictionary )(*JBIG2Encoder ,error ){const _fgcf ="\u006ee\u0077\u004a\u0042\u0049G\u0032\u0044\u0065\u0063\u006fd\u0065r\u0046r\u006f\u006d\u0053\u0074\u0072\u0065\u0061m";_dgde :=NewJBIG2Encoder ();_aeb :=_gcaa .PdfObjectDictionary ;if _aeb ==nil {return _dgde ,nil ;};if _ddfg ==nil {_eecgf :=_aeb .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _eecgf !=nil {switch _bcbdb :=_eecgf .(type ){case *PdfObjectDictionary :_ddfg =_bcbdb ;case *PdfObjectArray :if _bcbdb .Len ()==1{if _bfag ,_efgf :=GetDict (_bcbdb .Get (0));_efgf {_ddfg =_bfag ;};};default:_bf .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065P\u0061\u0072\u0061\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064i\u0063\u0074\u0069\u006f\u006e\u0061\u0072y\u0020\u0025\u0023\u0076",_eecgf );return nil ,_fg .Errorf (_fgcf ,"\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050a\u0072m\u0073\u0020\u0074\u0079\u0070\u0065\u003a \u0025\u0054",_bcbdb );};};};if _ddfg ==nil {return _dgde ,nil ;};_dgde .UpdateParams (_ddfg );_gcdc ,_gbgg :=GetStream (_ddfg .Get ("\u004a\u0042\u0049G\u0032\u0047\u006c\u006f\u0062\u0061\u006c\u0073"));if !_gbgg {return _dgde ,nil ;};var _caga error ;_dgde .Globals ,_caga =_eb .DecodeGlobals (_gcdc .Stream );if _caga !=nil {_caga =_fg .Wrap (_caga ,_fgcf ,"\u0063\u006f\u0072\u0072u\u0070\u0074\u0065\u0064\u0020\u006a\u0062\u0069\u0067\u0032 \u0065n\u0063\u006f\u0064\u0065\u0064\u0020\u0064a\u0074\u0061");_bf .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_caga );return nil ,_caga ;};return _dgde ,nil ;};func _ffade (_dfdd int )int {if _dfdd < 0{return -_dfdd ;};return _dfdd ;};

// GetFilterName returns the name of the encoding filter.
func (_aeee *JBIG2Encoder )GetFilterName ()string {return StreamEncodingFilterNameJBIG2 };

// WriteString outputs the object as it is to be written to file.
func (_ecfc *PdfObjectNull )WriteString ()string {return "\u006e\u0075\u006c\u006c"};func (_daba *PdfCrypt )encryptBytes (_cbf []byte ,_dec string ,_cbea []byte )([]byte ,error ){_bf .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");_egg ,_bdd :=_daba ._ecb [_dec ];if !_bdd {return nil ,_ce .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_dec );};return _egg .EncryptBytes (_cbf ,_cbea );};

// DecodeBytes decodes a slice of JBIG2 encoded bytes and returns the results.
func (_befe *JBIG2Encoder )DecodeBytes (encoded []byte )([]byte ,error ){return _eb .DecodeBytes (encoded ,_abc .Parameters {},_befe .Globals );};func (_cbgg *PdfParser )parseArray ()(*PdfObjectArray ,error ){_cdgb :=MakeArray ();_cbgg ._bdc .ReadByte ();for {_cbgg .skipSpaces ();_eeg ,_eecgb :=_cbgg ._bdc .Peek (1);if _eecgb !=nil {return _cdgb ,_eecgb ;};if _eeg [0]==']'{_cbgg ._bdc .ReadByte ();break ;};_bcda ,_eecgb :=_cbgg .parseObject ();if _eecgb !=nil {return _cdgb ,_eecgb ;};_cdgb .Append (_bcda );};return _cdgb ,nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_daeb *LZWEncoder )MakeDecodeParams ()PdfObject {if _daeb .Predictor > 1{_ffdff :=MakeDict ();_ffdff .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_daeb .Predictor )));if _daeb .BitsPerComponent !=8{_ffdff .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_daeb .BitsPerComponent )));};if _daeb .Columns !=1{_ffdff .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_daeb .Columns )));};if _daeb .Colors !=1{_ffdff .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_daeb .Colors )));};return _ffdff ;};return nil ;};func _cdeg (_ggde ,_gddg PdfObject ,_fgdd int )bool {if _fgdd > _bgedb {_bf .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_bgedb );return false ;};if _ggde ==nil &&_gddg ==nil {return true ;}else if _ggde ==nil ||_gddg ==nil {return false ;};if _d .TypeOf (_ggde )!=_d .TypeOf (_gddg ){return false ;};switch _bfgecf :=_ggde .(type ){case *PdfObjectNull ,*PdfObjectReference :return true ;case *PdfObjectName :return *_bfgecf ==*(_gddg .(*PdfObjectName ));case *PdfObjectString :return *_bfgecf ==*(_gddg .(*PdfObjectString ));case *PdfObjectInteger :return *_bfgecf ==*(_gddg .(*PdfObjectInteger ));case *PdfObjectBool :return *_bfgecf ==*(_gddg .(*PdfObjectBool ));case *PdfObjectFloat :return *_bfgecf ==*(_gddg .(*PdfObjectFloat ));case *PdfIndirectObject :return _cdeg (TraceToDirectObject (_ggde ),TraceToDirectObject (_gddg ),_fgdd +1);case *PdfObjectArray :_bdbf :=_gddg .(*PdfObjectArray );if len ((*_bfgecf )._cdbee )!=len ((*_bdbf )._cdbee ){return false ;};for _dgee ,_gged :=range (*_bfgecf )._cdbee {if !_cdeg (_gged ,(*_bdbf )._cdbee [_dgee ],_fgdd +1){return false ;};};return true ;case *PdfObjectDictionary :_ffga :=_gddg .(*PdfObjectDictionary );_cfag ,_gfdbeg :=(*_bfgecf )._ffca ,(*_ffga )._ffca ;if len (_cfag )!=len (_gfdbeg ){return false ;};for _bbbcb ,_feaa :=range _cfag {_bfbc ,_edaed :=_gfdbeg [_bbbcb ];if !_edaed ||!_cdeg (_feaa ,_bfbc ,_fgdd +1){return false ;};};return true ;case *PdfObjectStream :_dfeb :=_gddg .(*PdfObjectStream );return _cdeg ((*_bfgecf ).PdfObjectDictionary ,(*_dfeb ).PdfObjectDictionary ,_fgdd +1);default:_bf .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",_ggde );};return false ;};

// LookupByNumber looks up a PdfObject by object number.  Returns an error on failure.
func (_dea *PdfParser )LookupByNumber (objNumber int )(PdfObject ,error ){_ff ,_ ,_cdg :=_dea .lookupByNumberWrapper (objNumber ,true );return _ff ,_cdg ;};

// Set sets the PdfObject at index i of the streams. An error is returned if the index is outside bounds.
func (_cfba *PdfObjectStreams )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_cfba ._adca ){return _e .New ("\u004f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_cfba ._adca [i ]=obj ;return nil ;};

// JBIG2EncoderSettings contains the parameters and settings used by the JBIG2Encoder.
// Current version works only on JB2Generic compression.
type JBIG2EncoderSettings struct{

// FileMode defines if the jbig2 encoder should return full jbig2 file instead of
// shortened pdf mode. This adds the file header to the jbig2 definition.
FileMode bool ;

// Compression is the setting that defines the compression type used for encoding the page.
Compression JBIG2CompressionType ;

// DuplicatedLinesRemoval code generic region in a way such that if the lines are duplicated the encoder
// doesn't store it twice.
DuplicatedLinesRemoval bool ;

// DefaultPixelValue is the bit value initial for every pixel in the page.
DefaultPixelValue uint8 ;

// ResolutionX optional setting that defines the 'x' axis input image resolution - used for single page encoding.
ResolutionX int ;

// ResolutionY optional setting that defines the 'y' axis input image resolution - used for single page encoding.
ResolutionY int ;

// Threshold defines the threshold of the image correlation for
// non Generic compression.
// User only for JB2SymbolCorrelation and JB2SymbolRankHaus methods.
// Best results in range [0.7 - 0.98] - the less the better the compression would be
// but the more lossy.
// Default value: 0.95
Threshold float64 ;};

// Append appends PdfObject(s) to the array.
func (_beab *PdfObjectArray )Append (objects ...PdfObject ){if _beab ==nil {_bf .Log .Debug ("\u0057\u0061\u0072\u006e\u0020\u002d\u0020\u0041\u0074\u0074\u0065\u006d\u0070t\u0020\u0074\u006f\u0020\u0061\u0070p\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020a\u0072\u0072\u0061\u0079");return ;};_beab ._cdbee =append (_beab ._cdbee ,objects ...);};

// GetArray returns the *PdfObjectArray represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetArray (obj PdfObject )(_gadb *PdfObjectArray ,_afag bool ){_gadb ,_afag =TraceToDirectObject (obj ).(*PdfObjectArray );return _gadb ,_afag ;};

// LZWEncoder provides LZW encoding/decoding functionality.
type LZWEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Colors int ;

// LZW algorithm setting.
EarlyChange int ;};

// EncodeBytes JPX encodes the passed in slice of bytes.
func (_fdfc *JPXEncoder )EncodeBytes (data []byte )([]byte ,error ){_bf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_fdfc .GetFilterName ());return data ,ErrNoJPXDecode ;};func (_ga *PdfParser )lookupByNumberWrapper (_fbb int ,_gdb bool )(PdfObject ,bool ,error ){_ef ,_egbc ,_ag :=_ga .lookupByNumber (_fbb ,_gdb );if _ag !=nil {return nil ,_egbc ,_ag ;};if !_egbc &&_ga ._aggc !=nil &&!_ga ._aggc .isDecrypted (_ef ){_ffb :=_ga ._aggc .Decrypt (_ef ,0,0);if _ffb !=nil {return nil ,_egbc ,_ffb ;};};return _ef ,_egbc ,nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_bdg *DCTEncoder )MakeDecodeParams ()PdfObject {return nil };

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_cfdb *FlateEncoder )MakeStreamDict ()*PdfObjectDictionary {_gcfa :=MakeDict ();_gcfa .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_cfdb .GetFilterName ()));_bcg :=_cfdb .MakeDecodeParams ();if _bcg !=nil {_gcfa .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_bcg );};return _gcfa ;};

// MakeDict creates and returns an empty PdfObjectDictionary.
func MakeDict ()*PdfObjectDictionary {_afdf :=&PdfObjectDictionary {};_afdf ._ffca =map[PdfObjectName ]PdfObject {};_afdf ._eaef =[]PdfObjectName {};return _afdf ;};

// GetXrefOffset returns the offset of the xref table.
func (_gga *PdfParser )GetXrefOffset ()int64 {return _gga ._addb };var _daae =_dce .MustCompile ("\u005e\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");

// GetObjectStreams returns the *PdfObjectStreams represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetObjectStreams (obj PdfObject )(_edeg *PdfObjectStreams ,_gcgcc bool ){_edeg ,_gcgcc =obj .(*PdfObjectStreams );return _edeg ,_gcgcc ;};

// EncodeBytes encodes slice of bytes into JBIG2 encoding format.
// The input 'data' must be an image. In order to Decode it a user is responsible to
// load the codec ('png', 'jpg').
// Returns jbig2 single page encoded document byte slice. The encoder uses DefaultPageSettings
// to encode given image.
func (_gfg *JBIG2Encoder )EncodeBytes (data []byte )([]byte ,error ){const _gec ="\u004aB\u0049\u0047\u0032\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002eE\u006e\u0063\u006f\u0064\u0065\u0042\u0079\u0074\u0065\u0073";if _gfg .ColorComponents !=1||_gfg .BitsPerComponent !=1{return nil ,_fg .Errorf (_gec ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u002e\u0020\u004a\u0042\u0049G\u0032\u0020E\u006e\u0063o\u0064\u0065\u0072\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020bi\u006e\u0061\u0072\u0079\u0020\u0069\u006d\u0061\u0067e\u0073\u0020\u0064\u0061\u0074\u0061");};var (_bbdc *_gb .Bitmap ;_afdd error ;);_bcegc :=(_gfg .Width *_gfg .Height )==len (data );if _bcegc {_bbdc ,_afdd =_gb .NewWithUnpaddedData (_gfg .Width ,_gfg .Height ,data );}else {_bbdc ,_afdd =_gb .NewWithData (_gfg .Width ,_gfg .Height ,data );};if _afdd !=nil {return nil ,_afdd ;};_bcad :=_gfg .DefaultPageSettings ;if _afdd =_bcad .Validate ();_afdd !=nil {return nil ,_fg .Wrap (_afdd ,_gec ,"");};if _gfg ._ddfd ==nil {_gfg ._ddfd =_ca .InitEncodeDocument (_bcad .FileMode );};switch _bcad .Compression {case JB2Generic :if _afdd =_gfg ._ddfd .AddGenericPage (_bbdc ,_bcad .DuplicatedLinesRemoval );_afdd !=nil {return nil ,_fg .Wrap (_afdd ,_gec ,"");};case JB2SymbolCorrelation :return nil ,_fg .Error (_gec ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");case JB2SymbolRankHaus :return nil ,_fg .Error (_gec ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");default:return nil ,_fg .Error (_gec ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return _gfg .Encode ();};

// MakeString creates an PdfObjectString from a string.
// NOTE: PDF does not use utf-8 string encoding like Go so `s` will often not be a utf-8 encoded
// string.
func MakeString (s string )*PdfObjectString {_aaad :=PdfObjectString {_gcae :s };return &_aaad };

// String returns a string describing `array`.
func (_cacd *PdfObjectArray )String ()string {_cbgd :="\u005b";for _ddefd ,_bcee :=range _cacd .Elements (){_cbgd +=_bcee .String ();if _ddefd < (_cacd .Len ()-1){_cbgd +="\u002c\u0020";};};_cbgd +="\u005d";return _cbgd ;};func (_ggae *PdfParser )loadXrefs ()(*PdfObjectDictionary ,error ){_ggae ._bbfg .ObjectMap =make (map[int ]XrefObject );_ggae ._cbde =make (objectStreams );_affgd ,_gaff :=_ggae ._aagc .Seek (0,_aba .SeekEnd );if _gaff !=nil {return nil ,_gaff ;};_bf .Log .Trace ("\u0066s\u0069\u007a\u0065\u003a\u0020\u0025d",_affgd );_ggae ._fcda =_affgd ;_gaff =_ggae .seekToEOFMarker (_affgd );if _gaff !=nil {_bf .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0073\u0065\u0065\u006b\u0020\u0074\u006f\u0020\u0065\u006f\u0066\u0020\u006d\u0061\u0072\u006b\u0065\u0072: \u0025\u0076",_gaff );return nil ,_gaff ;};_aebg ,_gaff :=_ggae ._aagc .Seek (0,_aba .SeekCurrent );if _gaff !=nil {return nil ,_gaff ;};var _adfd int64 =64;_bbgg :=_aebg -_adfd ;if _bbgg < 0{_bbgg =0;};_ ,_gaff =_ggae ._aagc .Seek (_bbgg ,_aba .SeekStart );if _gaff !=nil {return nil ,_gaff ;};_baa :=make ([]byte ,_adfd );_ ,_gaff =_ggae ._aagc .Read (_baa );if _gaff !=nil {_bf .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u003a\u0020\u0025\u0076",_gaff );return nil ,_gaff ;};_bbdcd :=_bafgg .FindStringSubmatch (string (_baa ));if len (_bbdcd )< 2{_bf .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020n\u006f\u0074\u0020f\u006fu\u006e\u0064\u0021");return nil ,_e .New ("\u0073\u0074\u0061\u0072tx\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};if len (_bbdcd )> 2{_bf .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u004du\u006c\u0074\u0069\u0070\u006c\u0065\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029\u0021",_baa );return nil ,_e .New ("m\u0075\u006c\u0074\u0069\u0070\u006ce\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065f\u0020\u0065\u006et\u0072i\u0065\u0073\u003f");};_bgae ,_ :=_dc .ParseInt (_bbdcd [1],10,64);_bf .Log .Trace ("\u0073t\u0061r\u0074\u0078\u0072\u0065\u0066\u0020\u0061\u0074\u0020\u0025\u0064",_bgae );if _bgae > _affgd {_bf .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u006f\u0066f\u0073e\u0074 \u006fu\u0074\u0073\u0069\u0064\u0065\u0020\u006f\u0066\u0020\u0066\u0069\u006c\u0065");_bf .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0072e\u0070\u0061\u0069\u0072");_bgae ,_gaff =_ggae .repairLocateXref ();if _gaff !=nil {_bf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0052\u0065\u0070\u0061\u0069\u0072\u0020\u0061\u0074\u0074\u0065\u006d\u0070t\u0020\u0066\u0061\u0069\u006c\u0065\u0064 \u0028\u0025\u0073\u0029");return nil ,_gaff ;};};_ggae ._aagc .Seek (_bgae ,_aba .SeekStart );_ggae ._bdc =_ac .NewReader (_ggae ._aagc );_cggc ,_gaff :=_ggae .parseXref ();if _gaff !=nil {return nil ,_gaff ;};_gcgb :=_cggc .Get ("\u0058R\u0065\u0066\u0053\u0074\u006d");if _gcgb !=nil {_ecdd ,_cgbf :=_gcgb .(*PdfObjectInteger );if !_cgbf {return nil ,_e .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0021=\u0020\u0069\u006e\u0074");};_ ,_gaff =_ggae .parseXrefStream (_ecdd );if _gaff !=nil {return nil ,_gaff ;};};var _baad []int64 ;_gaa :=func (_febc int64 ,_egaf []int64 )bool {for _ ,_ceff :=range _egaf {if _ceff ==_febc {return true ;};};return false ;};_gcgb =_cggc .Get ("\u0050\u0072\u0065\u0076");for _gcgb !=nil {_bedc ,_bfcgc :=_gcgb .(*PdfObjectInteger );if !_bfcgc {_bf .Log .Debug ("\u0049\u006ev\u0061\u006c\u0069\u0064\u0020P\u0072\u0065\u0076\u0020\u0072e\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u003a\u0020\u004e\u006f\u0074\u0020\u0061\u0020\u002a\u0050\u0064\u0066\u004f\u0062\u006a\u0065\u0063\u0074\u0049\u006e\u0074\u0065\u0067\u0065\u0072\u0020\u0028\u0025\u0054\u0029",_gcgb );return _cggc ,nil ;};_bdda :=*_bedc ;_bf .Log .Trace ("\u0041\u006eot\u0068\u0065\u0072 \u0050\u0072\u0065\u0076 xr\u0065f \u0074\u0061\u0062\u006c\u0065\u0020\u006fbj\u0065\u0063\u0074\u0020\u0061\u0074\u0020%\u0064",_bdda );_ggae ._aagc .Seek (int64 (_bdda ),_aba .SeekStart );_ggae ._bdc =_ac .NewReader (_ggae ._aagc );_dffe ,_egcg :=_ggae .parseXref ();if _egcg !=nil {_bf .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0045\u0072\u0072\u006f\u0072\u0020-\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u0061\u0064\u0069n\u0067\u0020\u0061\u006e\u006f\u0074\u0068\u0065\u0072\u0020\u0028\u0050re\u0076\u0029\u0020\u0074\u0072\u0061\u0069\u006c\u0065\u0072");_bf .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0063\u006f\u006e\u0074\u0069n\u0075\u0065\u0020\u0062\u0079\u0020\u0069\u0067\u006e\u006f\u0072\u0069n\u0067\u0020\u0069\u0074");break ;};_gcgb =_dffe .Get ("\u0050\u0072\u0065\u0076");if _gcgb !=nil {_afgg :=*(_gcgb .(*PdfObjectInteger ));if _gaa (int64 (_afgg ),_baad ){_bf .Log .Debug ("\u0050\u0072ev\u0065\u006e\u0074i\u006e\u0067\u0020\u0063irc\u0075la\u0072\u0020\u0078\u0072\u0065\u0066\u0020re\u0066\u0065\u0072\u0065\u006e\u0063\u0069n\u0067");break ;};_baad =append (_baad ,int64 (_afgg ));};};return _cggc ,nil ;};

// RegisterCustomStreamEncoder register a custom encoder handler for certain filter.
func RegisterCustomStreamEncoder (filterName string ,customStreamEncoder StreamEncoder ){_gbgee .Store (filterName ,customStreamEncoder );};

// PdfObjectStreams represents the primitive PDF object streams.
// 7.5.7 Object Streams (page 45).
type PdfObjectStreams struct{PdfObjectReference ;_adca []PdfObject ;};

// SetFileOffset sets the file to an offset position and resets buffer.
func (_fbddc *PdfParser )SetFileOffset (offset int64 ){if offset < 0{offset =0;};_fbddc ._aagc .Seek (offset ,_aba .SeekStart );_fbddc ._bdc =_ac .NewReader (_fbddc ._aagc );};

// GetFilterName returns the name of the encoding filter.
func (_cafg *JPXEncoder )GetFilterName ()string {return StreamEncodingFilterNameJPX };func (_bgc *PdfObjectInteger )String ()string {return _ce .Sprintf ("\u0025\u0064",*_bgc )};

// NewRunLengthEncoder makes a new run length encoder
func NewRunLengthEncoder ()*RunLengthEncoder {return &RunLengthEncoder {}};

// EqualObjects returns true if `obj1` and `obj2` have the same contents.
//
// NOTE: It is a good idea to flatten obj1 and obj2 with FlattenObject before calling this function
// so that contents, rather than references, can be compared.
func EqualObjects (obj1 ,obj2 PdfObject )bool {return _cdeg (obj1 ,obj2 ,0)};func _ccd (_ccc *_afe .StdEncryptDict ,_deg *PdfObjectDictionary )error {R ,_aef :=_deg .Get ("\u0052").(*PdfObjectInteger );if !_aef {return _e .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0052");};if *R < 2||*R > 6{return _ce .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0052 \u0028\u0025\u0064\u0029",*R );};_ccc .R =int (*R );O ,_aef :=_deg .GetString ("\u004f");if !_aef {return _e .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u004f");};if _ccc .R ==5||_ccc .R ==6{if len (O )< 48{return _ce .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u004f\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (O ));};}else if len (O )!=32{return _ce .Errorf ("L\u0065n\u0067\u0074\u0068\u0028\u004f\u0029\u0020\u0021=\u0020\u0033\u0032\u0020(%\u0064\u0029",len (O ));};_ccc .O =[]byte (O );U ,_aef :=_deg .GetString ("\u0055");if !_aef {return _e .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0055");};if _ccc .R ==5||_ccc .R ==6{if len (U )< 48{return _ce .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u0055\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (U ));};}else if len (U )!=32{_bf .Log .Debug ("\u0057\u0061r\u006e\u0069\u006e\u0067\u003a\u0020\u004c\u0065\u006e\u0067\u0074\u0068\u0028\u0055\u0029\u0020\u0021\u003d\u0020\u0033\u0032\u0020(%\u0064\u0029",len (U ));};_ccc .U =[]byte (U );if _ccc .R >=5{OE ,_aece :=_deg .GetString ("\u004f\u0045");if !_aece {return _e .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u004f\u0045");}else if len (OE )!=32{return _ce .Errorf ("L\u0065\u006e\u0067\u0074h(\u004fE\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (OE ));};_ccc .OE =[]byte (OE );UE ,_aece :=_deg .GetString ("\u0055\u0045");if !_aece {return _e .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u0055\u0045");}else if len (UE )!=32{return _ce .Errorf ("L\u0065\u006e\u0067\u0074h(\u0055E\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (UE ));};_ccc .UE =[]byte (UE );};P ,_aef :=_deg .Get ("\u0050").(*PdfObjectInteger );if !_aef {return _e .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074 \u0064\u0069\u0063t\u0069\u006f\u006e\u0061r\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0070\u0065\u0072\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0061\u0074\u0074\u0072");};_ccc .P =_afe .Permissions (*P );if _ccc .R ==6{Perms ,_bfd :=_deg .GetString ("\u0050\u0065\u0072m\u0073");if !_bfd {return _e .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0050\u0065\u0072\u006d\u0073");}else if len (Perms )!=16{return _ce .Errorf ("\u004ce\u006e\u0067\u0074\u0068\u0028\u0050\u0065\u0072\u006d\u0073\u0029 \u0021\u003d\u0020\u0031\u0036\u0020\u0028\u0025\u0064\u0029",len (Perms ));};_ccc .Perms =[]byte (Perms );};if _bd ,_cac :=_deg .Get ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061").(*PdfObjectBool );_cac {_ccc .EncryptMetadata =bool (*_bd );}else {_ccc .EncryptMetadata =true ;};return nil ;};

// PdfObjectBool represents the primitive PDF boolean object.
type PdfObjectBool bool ;

// RunLengthEncoder represents Run length encoding.
type RunLengthEncoder struct{};

// DecodeBytes decodes a slice of DCT encoded bytes and returns the result.
func (_bceg *DCTEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_daca :=_fb .NewReader (encoded );_dabg ,_deb :=_g .Decode (_daca );if _deb !=nil {_bf .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006eg\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_deb );return nil ,_deb ;};_dagc :=_dabg .Bounds ();var _efb =make ([]byte ,_dagc .Dx ()*_dagc .Dy ()*_bceg .ColorComponents *_bceg .BitsPerComponent /8);_gdeg :=0;for _bac :=_dagc .Min .Y ;_bac < _dagc .Max .Y ;_bac ++{for _cgdd :=_dagc .Min .X ;_cgdd < _dagc .Max .X ;_cgdd ++{_ggdb :=_dabg .At (_cgdd ,_bac );if _bceg .ColorComponents ==1{if _bceg .BitsPerComponent ==16{_fgbcf ,_adg :=_ggdb .(_bg .Gray16 );if !_adg {return nil ,_e .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_efb [_gdeg ]=byte ((_fgbcf .Y >>8)&0xff);_gdeg ++;_efb [_gdeg ]=byte (_fgbcf .Y &0xff);_gdeg ++;}else {_cacg ,_gbg :=_ggdb .(_bg .Gray );if !_gbg {return nil ,_e .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_efb [_gdeg ]=_cacg .Y &0xff;_gdeg ++;};}else if _bceg .ColorComponents ==3{if _bceg .BitsPerComponent ==16{_fbeb ,_gfa :=_ggdb .(_bg .RGBA64 );if !_gfa {return nil ,_e .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_efb [_gdeg ]=byte ((_fbeb .R >>8)&0xff);_gdeg ++;_efb [_gdeg ]=byte (_fbeb .R &0xff);_gdeg ++;_efb [_gdeg ]=byte ((_fbeb .G >>8)&0xff);_gdeg ++;_efb [_gdeg ]=byte (_fbeb .G &0xff);_gdeg ++;_efb [_gdeg ]=byte ((_fbeb .B >>8)&0xff);_gdeg ++;_efb [_gdeg ]=byte (_fbeb .B &0xff);_gdeg ++;}else {_cad ,_abba :=_ggdb .(_bg .RGBA );if _abba {_efb [_gdeg ]=_cad .R &0xff;_gdeg ++;_efb [_gdeg ]=_cad .G &0xff;_gdeg ++;_efb [_gdeg ]=_cad .B &0xff;_gdeg ++;}else {_gabg ,_bfdc :=_ggdb .(_bg .YCbCr );if !_bfdc {return nil ,_e .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_gfe ,_abga ,_geg ,_ :=_gabg .RGBA ();_efb [_gdeg ]=byte (_gfe >>8);_gdeg ++;_efb [_gdeg ]=byte (_abga >>8);_gdeg ++;_efb [_gdeg ]=byte (_geg >>8);_gdeg ++;};};}else if _bceg .ColorComponents ==4{_bae ,_ccgc :=_ggdb .(_bg .CMYK );if !_ccgc {return nil ,_e .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_efb [_gdeg ]=255-_bae .C &0xff;_gdeg ++;_efb [_gdeg ]=255-_bae .M &0xff;_gdeg ++;_efb [_gdeg ]=255-_bae .Y &0xff;_gdeg ++;_efb [_gdeg ]=255-_bae .K &0xff;_gdeg ++;};};};return _efb ,nil ;};const _bgedb =10;

// ToIntegerArray returns a slice of all array elements as an int slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_ddbg *PdfObjectArray )ToIntegerArray ()([]int ,error ){var _ecfgg []int ;for _ ,_gedg :=range _ddbg .Elements (){if _gfab ,_acaef :=_gedg .(*PdfObjectInteger );_acaef {_ecfgg =append (_ecfgg ,int (*_gfab ));}else {return nil ,ErrTypeError ;};};return _ecfgg ,nil ;};

// ParseNumber parses a numeric objects from a buffered stream.
// Section 7.3.3.
// Integer or Float.
//
// An integer shall be written as one or more decimal digits optionally
// preceded by a sign. The value shall be interpreted as a signed
// decimal integer and shall be converted to an integer object.
//
// A real value shall be written as one or more decimal digits with an
// optional sign and a leading, trailing, or embedded PERIOD (2Eh)
// (decimal point). The value shall be interpreted as a real number
// and shall be converted to a real object.
//
// Regarding exponential numbers: 7.3.3 Numeric Objects:
// A conforming writer shall not use the PostScript syntax for numbers
// with non-decimal radices (such as 16#FFFE) or in exponential format
// (such as 6.02E23).
// Nonetheless, we sometimes get numbers with exponential format, so
// we will support it in the reader (no confusion with other types, so
// no compromise).
func ParseNumber (buf *_ac .Reader )(PdfObject ,error ){_gcfag :=false ;_febcgf :=true ;var _dcda _fb .Buffer ;for {if _bf .Log .IsLogLevel (_bf .LogLevelTrace ){_bf .Log .Trace ("\u0050\u0061\u0072\u0073in\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0022\u0025\u0073\u0022",_dcda .String ());};_acfc ,_dbgcc :=buf .Peek (1);if _dbgcc ==_aba .EOF {break ;};if _dbgcc !=nil {_bf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0025\u0073",_dbgcc );return nil ,_dbgcc ;};if _febcgf &&(_acfc [0]=='-'||_acfc [0]=='+'){_cdbd ,_ :=buf .ReadByte ();_dcda .WriteByte (_cdbd );_febcgf =false ;}else if IsDecimalDigit (_acfc [0]){_ceab ,_ :=buf .ReadByte ();_dcda .WriteByte (_ceab );}else if _acfc [0]=='.'{_eacd ,_ :=buf .ReadByte ();_dcda .WriteByte (_eacd );_gcfag =true ;}else if _acfc [0]=='e'||_acfc [0]=='E'{_gadcb ,_ :=buf .ReadByte ();_dcda .WriteByte (_gadcb );_gcfag =true ;_febcgf =true ;}else {break ;};};var _becdd PdfObject ;if _gcfag {_babfd ,_bdba :=_dc .ParseFloat (_dcda .String (),64);if _bdba !=nil {_bf .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0025v\u0020\u0065\u0072\u0072\u003d\u0025v\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0030\u002e\u0020\u004fu\u0074\u0070u\u0074\u0020\u006d\u0061y\u0020\u0062\u0065\u0020\u0069n\u0063\u006f\u0072\u0072\u0065\u0063\u0074",_dcda .String (),_bdba );_babfd =0.0;};_gaed :=PdfObjectFloat (_babfd );_becdd =&_gaed ;}else {_gcbb ,_fecgad :=_dc .ParseInt (_dcda .String (),10,64);if _fecgad !=nil {_bf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0025\u0076\u0020\u0065\u0072\u0072\u003d%\u0076\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074 \u006d\u0061\u0079\u0020\u0062\u0065 \u0069\u006ec\u006f\u0072r\u0065c\u0074",_dcda .String (),_fecgad );_gcbb =0;};_bdgff :=PdfObjectInteger (_gcbb );_becdd =&_bdgff ;};return _becdd ,nil ;};

// EncodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_daee *RawEncoder )EncodeBytes (data []byte )([]byte ,error ){return data ,nil };func _dfba (_cfaf *PdfObjectStream ,_gage *PdfObjectDictionary )(*FlateEncoder ,error ){_fgf :=NewFlateEncoder ();_eed :=_cfaf .PdfObjectDictionary ;if _eed ==nil {return _fgf ,nil ;};_fgf ._agac =_acff (_eed );if _gage ==nil {_fbdd :=TraceToDirectObject (_eed .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));switch _fgfg :=_fbdd .(type ){case *PdfObjectArray :if _fgfg .Len ()!=1{_bf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072:\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020a\u0072\u0072\u0061\u0079\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0021\u003d\u0020\u0031\u0020\u0028\u0025\u0064\u0029",_fgfg .Len ());return nil ,_e .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};if _aage ,_edc :=GetDict (_fgfg .Get (0));_edc {_gage =_aage ;};case *PdfObjectDictionary :_gage =_fgfg ;case *PdfObjectNull ,nil :default:_bf .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020n\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079 \u0028%\u0054\u0029",_fbdd );return nil ,_ce .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _gage ==nil {return _fgf ,nil ;};_bf .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_gage .String ());_dabc :=_gage .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");if _dabc ==nil {_bf .Log .Debug ("E\u0072\u0072o\u0072\u003a\u0020\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067 \u0066\u0072\u006f\u006d\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073 \u002d\u0020\u0043\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020\u0077\u0069t\u0068\u0020\u0064\u0065\u0066\u0061\u0075\u006c\u0074\u0020\u00281\u0029");}else {_dcg ,_gccc :=_dabc .(*PdfObjectInteger );if !_gccc {_bf .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_dabc );return nil ,_ce .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_fgf .Predictor =int (*_dcg );};_dabc =_gage .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");if _dabc !=nil {_ggf ,_fbfg :=_dabc .(*PdfObjectInteger );if !_fbfg {_bf .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");return nil ,_ce .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_fgf .BitsPerComponent =int (*_ggf );};if _fgf .Predictor > 1{_fgf .Columns =1;_dabc =_gage .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");if _dabc !=nil {_addf ,_gcaf :=_dabc .(*PdfObjectInteger );if !_gcaf {return nil ,_ce .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_fgf .Columns =int (*_addf );};_fgf .Colors =1;_dabc =_gage .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _dabc !=nil {_bca ,_dbga :=_dabc .(*PdfObjectInteger );if !_dbga {return nil ,_ce .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");};_fgf .Colors =int (*_bca );};};return _fgf ,nil ;};type objectStream struct{N int ;_cf []byte ;_gf map[int ]int64 ;};func (_fc *PdfCrypt )newEncryptDict ()*PdfObjectDictionary {_acd :=MakeDict ();_acd .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName ("\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"));_acd .Set ("\u0056",MakeInteger (int64 (_fc ._gbe .V )));_acd .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_fc ._gbe .Length )));return _acd ;};func (_bcge *PdfParser )inspect ()(map[string ]int ,error ){_bf .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0053P\u0045\u0043\u0054\u0020\u002d\u002d\u002d\u002d\u002d\u002d-\u002d\u002d\u002d");_bf .Log .Trace ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");_begd :=map[string ]int {};_dcdg :=0;_cafa :=0;var _febcf []int ;for _febcg :=range _bcge ._bbfg .ObjectMap {_febcf =append (_febcf ,_febcg );};_b .Ints (_febcf );_ebed :=0;for _ ,_cfabc :=range _febcf {_eeag :=_bcge ._bbfg .ObjectMap [_cfabc ];if _eeag .ObjectNumber ==0{continue ;};_dcdg ++;_bf .Log .Trace ("\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d");_bf .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0075\u0070\u0020\u006f\u0062\u006a\u0065c\u0074 \u006e\u0075\u006d\u0062\u0065\u0072\u003a \u0025\u0064",_eeag .ObjectNumber );_acead ,_bfgec :=_bcge .LookupByNumber (_eeag .ObjectNumber );if _bfgec !=nil {_bf .Log .Trace ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u006c\u006f\u006f\u006b\u0075p\u0020\u006f\u0062\u006a\u0020\u0025\u0064 \u0028\u0025\u0073\u0029",_eeag .ObjectNumber ,_bfgec );_cafa ++;continue ;};_bf .Log .Trace ("\u006fb\u006a\u003a\u0020\u0025\u0073",_acead );_dffg ,_dcfc :=_acead .(*PdfIndirectObject );if _dcfc {_bf .Log .Trace ("\u0049N\u0044 \u004f\u004f\u0042\u004a\u0020\u0025\u0064\u003a\u0020\u0025\u0073",_eeag .ObjectNumber ,_dffg );_efacdg ,_ffce :=_dffg .PdfObject .(*PdfObjectDictionary );if _ffce {if _edfcg ,_fdee :=_efacdg .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_fdee {_bfecf :=string (*_edfcg );_bf .Log .Trace ("\u002d\u002d\u002d\u003e\u0020\u004f\u0062\u006a\u0020\u0074\u0079\u0070e\u003a\u0020\u0025\u0073",_bfecf );_ ,_cdfdb :=_begd [_bfecf ];if _cdfdb {_begd [_bfecf ]++;}else {_begd [_bfecf ]=1;};}else if _eege ,_fcfa :=_efacdg .Get ("\u0053u\u0062\u0074\u0079\u0070\u0065").(*PdfObjectName );_fcfa {_adae :=string (*_eege );_bf .Log .Trace ("-\u002d-\u003e\u0020\u004f\u0062\u006a\u0020\u0073\u0075b\u0074\u0079\u0070\u0065: \u0025\u0073",_adae );_ ,_fdbcc :=_begd [_adae ];if _fdbcc {_begd [_adae ]++;}else {_begd [_adae ]=1;};};if _gafcc ,_aadd :=_efacdg .Get ("\u0053").(*PdfObjectName );_aadd &&*_gafcc =="\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"{_ ,_dafge :=_begd ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"];if _dafge {_begd ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]++;}else {_begd ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]=1;};};};}else if _fecga ,_cdbed :=_acead .(*PdfObjectStream );_cdbed {if _ggcg ,_efga :=_fecga .PdfObjectDictionary .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_efga {_bf .Log .Trace ("\u002d\u002d\u003e\u0020\u0053\u0074\u0072\u0065\u0061\u006d\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073",*_ggcg );_ggbcbe :=string (*_ggcg );_begd [_ggbcbe ]++;};}else {_efad ,_fgbe :=_acead .(*PdfObjectDictionary );if _fgbe {_agacg ,_gfbdd :=_efad .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if _gfbdd {_cggb :=string (*_agacg );_bf .Log .Trace ("\u002d-\u002d \u006f\u0062\u006a\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073",_cggb );_begd [_cggb ]++;};};_bf .Log .Trace ("\u0044\u0049\u0052\u0045\u0043\u0054\u0020\u004f\u0042\u004a\u0020\u0025d\u003a\u0020\u0025\u0073",_eeag .ObjectNumber ,_acead );};_ebed ++;};_bf .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0045\u004fF\u0020\u0049\u004e\u0053\u0050\u0045\u0043T\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d");_bf .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");_bf .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074 \u0063\u006f\u0075\u006e\u0074\u003a\u0020\u0025\u0064",_dcdg );_bf .Log .Trace ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u006f\u006b\u0075p\u003a\u0020\u0025\u0064",_cafa );for _eedgb ,_cbdg :=range _begd {_bf .Log .Trace ("\u0025\u0073\u003a\u0020\u0025\u0064",_eedgb ,_cbdg );};_bf .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");if len (_bcge ._bbfg .ObjectMap )< 1{_bf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0068\u0069\u0073 \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074 \u0069s\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0028\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0021\u0029");return nil ,_ce .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0064\u006fc\u0075\u006d\u0065\u006e\u0074\u0020\u0028\u0078r\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006d\u0069\u0073s\u0069\u006e\u0067\u0029");};_cfda ,_facdgc :=_begd ["\u0046\u006f\u006e\u0074"];if !_facdgc ||_cfda < 2{_bf .Log .Trace ("\u0054\u0068\u0069s \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020i\u0073 \u0070r\u006fb\u0061\u0062\u006c\u0079\u0020\u0073\u0063\u0061\u006e\u006e\u0065\u0064\u0021");}else {_bf .Log .Trace ("\u0054\u0068\u0069\u0073\u0020\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020\u0069\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0066o\u0072\u0020\u0065\u0078\u0074r\u0061\u0063t\u0069\u006f\u006e\u0021");};return _begd ,nil ;};

// EncodeBytes encodes the image data using either Group3 or Group4 CCITT facsimile (fax) encoding.
// `data` is expected to be 1 color component, 1 bit per component. It is also valid to provide 8 BPC, 1 CC image like
// a standard go image Gray data.
func (_deec *CCITTFaxEncoder )EncodeBytes (data []byte )([]byte ,error ){var _edbf _aa .Gray ;switch len (data ){case _deec .Rows *_deec .Columns :_aaae ,_gbcb :=_aa .NewImage (_deec .Columns ,_deec .Rows ,8,1,data ,nil ,nil );if _gbcb !=nil {return nil ,_gbcb ;};_edbf =_aaae .(_aa .Gray );case (_deec .Columns *_deec .Rows )+7>>3:_dcdb ,_cagf :=_aa .NewImage (_deec .Columns ,_deec .Rows ,1,1,data ,nil ,nil );if _cagf !=nil {return nil ,_cagf ;};_bgga :=_dcdb .(*_aa .Monochrome );if _cagf =_bgga .AddPadding ();_cagf !=nil {return nil ,_cagf ;};_edbf =_bgga ;default:if len (data )< _aa .BytesPerLine (_deec .Columns ,1,1)*_deec .Rows {return nil ,_e .New ("p\u0072\u006f\u0076\u0069\u0064\u0065d\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020i\u006e\u0070\u0075t\u0020d\u0061\u0074\u0061");};_deda ,_cbcg :=_aa .NewImage (_deec .Columns ,_deec .Rows ,1,1,data ,nil ,nil );if _cbcg !=nil {return nil ,_cbcg ;};_bcbd :=_deda .(*_aa .Monochrome );_edbf =_bcbd ;};_acac :=make ([][]byte ,_deec .Rows );for _bbd :=0;_bbd < _deec .Rows ;_bbd ++{_afec :=make ([]byte ,_deec .Columns );for _aead :=0;_aead < _deec .Columns ;_aead ++{_befb :=_edbf .GrayAt (_aead ,_bbd );_afec [_aead ]=_befb .Y >>7;};_acac [_bbd ]=_afec ;};_faf :=&_acc .Encoder {K :_deec .K ,Columns :_deec .Columns ,EndOfLine :_deec .EndOfLine ,EndOfBlock :_deec .EndOfBlock ,BlackIs1 :_deec .BlackIs1 ,DamagedRowsBeforeError :_deec .DamagedRowsBeforeError ,Rows :_deec .Rows ,EncodedByteAlign :_deec .EncodedByteAlign };return _faf .Encode (_acac ),nil ;};

// GetParser returns the parser for lazy-loading or compare references.
func (_gagcb *PdfObjectReference )GetParser ()*PdfParser {return _gagcb ._bcdd };

// GetFilterName returns the name of the encoding filter.
func (_abca *ASCII85Encoder )GetFilterName ()string {return StreamEncodingFilterNameASCII85 };func (_edcf *PdfParser )parseXrefTable ()(*PdfObjectDictionary ,error ){var _effb *PdfObjectDictionary ;_fcgcb ,_deeab :=_edcf .readTextLine ();if _deeab !=nil {return nil ,_deeab ;};_bf .Log .Trace ("\u0078\u0072\u0065\u0066 f\u0069\u0072\u0073\u0074\u0020\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_fcgcb );_dgfa :=-1;_bbga :=0;_ggaf :=false ;_fdgf :="";for {_edcf .skipSpaces ();_ ,_bfbbg :=_edcf ._bdc .Peek (1);if _bfbbg !=nil {return nil ,_bfbbg ;};_fcgcb ,_bfbbg =_edcf .readTextLine ();if _bfbbg !=nil {return nil ,_bfbbg ;};_bbgda :=_bdbc .FindStringSubmatch (_fcgcb );if len (_bbgda )==0{_bdaa :=len (_fdgf )> 0;_fdgf +=_fcgcb +"\u000a";if _bdaa {_bbgda =_bdbc .FindStringSubmatch (_fdgf );};};if len (_bbgda )==3{_dbgaf ,_ :=_dc .Atoi (_bbgda [1]);_dgga ,_ :=_dc .Atoi (_bbgda [2]);_dgfa =_dbgaf ;_bbga =_dgga ;_ggaf =true ;_fdgf ="";_bf .Log .Trace ("\u0078r\u0065\u0066 \u0073\u0075\u0062s\u0065\u0063\u0074\u0069\u006f\u006e\u003a \u0066\u0069\u0072\u0073\u0074\u0020o\u0062\u006a\u0065\u0063\u0074\u003a\u0020\u0025\u0064\u0020\u006fb\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_dgfa ,_bbga );continue ;};_eebc :=_eddg .FindStringSubmatch (_fcgcb );if len (_eebc )==4{if !_ggaf {_bf .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0058r\u0065\u0066\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u006fr\u006da\u0074\u0021\u000a");return nil ,_e .New ("\u0078\u0072\u0065\u0066 i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072\u006d\u0061\u0074");};_bfdca ,_ :=_dc .ParseInt (_eebc [1],10,64);_gecd ,_ :=_dc .Atoi (_eebc [2]);_edec :=_eebc [3];_fdgf ="";if _ab .ToLower (_edec )=="\u006e"&&_bfdca > 1{_dfda ,_bfga :=_edcf ._bbfg .ObjectMap [_dgfa ];if !_bfga ||_gecd > _dfda .Generation {_cddda :=XrefObject {ObjectNumber :_dgfa ,XType :XrefTypeTableEntry ,Offset :_bfdca ,Generation :_gecd };_edcf ._bbfg .ObjectMap [_dgfa ]=_cddda ;};};_dgfa ++;continue ;};if (len (_fcgcb )> 6)&&(_fcgcb [:7]=="\u0074r\u0061\u0069\u006c\u0065\u0072"){_bf .Log .Trace ("\u0046o\u0075n\u0064\u0020\u0074\u0072\u0061i\u006c\u0065r\u0020\u002d\u0020\u0025\u0073",_fcgcb );if len (_fcgcb )> 9{_abgc :=_edcf .GetFileOffset ();_edcf .SetFileOffset (_abgc -int64 (len (_fcgcb ))+7);};_edcf .skipSpaces ();_edcf .skipComments ();_bf .Log .Trace ("R\u0065\u0061\u0064\u0069ng\u0020t\u0072\u0061\u0069\u006c\u0065r\u0020\u0064\u0069\u0063\u0074\u0021");_bf .Log .Trace ("\u0070\u0065\u0065\u006b\u003a\u0020\u0022\u0025\u0073\u0022",_fcgcb );_effb ,_bfbbg =_edcf .ParseDict ();_bf .Log .Trace ("\u0045O\u0046\u0020\u0072\u0065a\u0064\u0069\u006e\u0067\u0020t\u0072a\u0069l\u0065\u0072\u0020\u0064\u0069\u0063\u0074!");if _bfbbg !=nil {_bf .Log .Debug ("\u0045\u0072\u0072o\u0072\u0020\u0070\u0061r\u0073\u0069\u006e\u0067\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u0064\u0069\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_bfbbg );return nil ,_bfbbg ;};break ;};if _fcgcb =="\u0025\u0025\u0045O\u0046"{_bf .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006e\u0064 \u006f\u0066\u0020\u0066\u0069\u006c\u0065 -\u0020\u0074\u0072\u0061i\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066ou\u006e\u0064 \u002d\u0020\u0065\u0072\u0072\u006f\u0072\u0021");return nil ,_e .New ("\u0065\u006e\u0064 \u006f\u0066\u0020\u0066i\u006c\u0065\u0020\u002d\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};_bf .Log .Trace ("\u0078\u0072\u0065\u0066\u0020\u006d\u006f\u0072\u0065 \u003a\u0020\u0025\u0073",_fcgcb );};_bf .Log .Trace ("\u0045\u004f\u0046 p\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0021");if _edcf ._eaba ==nil {_eade :=XrefTypeTableEntry ;_edcf ._eaba =&_eade ;};return _effb ,nil ;};const (XrefTypeTableEntry xrefType =iota ;XrefTypeObjectStream xrefType =iota ;);func (_fgba *JBIG2Image )toBitmap ()(_ggg *_gb .Bitmap ,_fdac error ){const _fedf ="\u004a\u0042\u0049\u00472I\u006d\u0061\u0067\u0065\u002e\u0074\u006f\u0042\u0069\u0074\u006d\u0061\u0070";if _fgba .Data ==nil {return nil ,_fg .Error (_fedf ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");};if _fgba .Width ==0||_fgba .Height ==0{return nil ,_fg .Error (_fedf ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");};if _fgba .HasPadding {_ggg ,_fdac =_gb .NewWithData (_fgba .Width ,_fgba .Height ,_fgba .Data );}else {_ggg ,_fdac =_gb .NewWithUnpaddedData (_fgba .Width ,_fgba .Height ,_fgba .Data );};if _fdac !=nil {return nil ,_fg .Wrap (_fdac ,_fedf ,"");};return _ggg ,nil ;};

// NewJPXEncoder returns a new instance of JPXEncoder.
func NewJPXEncoder ()*JPXEncoder {return &JPXEncoder {}};

// AddEncoder adds the passed in encoder to the underlying encoder slice.
func (_gce *MultiEncoder )AddEncoder (encoder StreamEncoder ){_gce ._gbag =append (_gce ._gbag ,encoder )};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_deag *ASCIIHexEncoder )MakeStreamDict ()*PdfObjectDictionary {_gbfa :=MakeDict ();_gbfa .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_deag .GetFilterName ()));return _gbfa ;};

// Get returns the PdfObject corresponding to the specified key.
// Returns a nil value if the key is not set.
func (_dbbb *PdfObjectDictionary )Get (key PdfObjectName )PdfObject {_fgea ,_aaffb :=_dbbb ._ffca [key ];if !_aaffb {return nil ;};return _fgea ;};

// DecodeImages decodes the page images from the jbig2 'encoded' data input.
// The jbig2 document may contain multiple pages, thus the function can return multiple
// images. The images order corresponds to the page number.
func (_bccd *JBIG2Encoder )DecodeImages (encoded []byte )([]_dd .Image ,error ){const _gcg ="\u004aB\u0049\u0047\u0032\u0045n\u0063\u006f\u0064\u0065\u0072.\u0044e\u0063o\u0064\u0065\u0049\u006d\u0061\u0067\u0065s";_gfec ,_aecaa :=_abc .Decode (encoded ,_abc .Parameters {},_bccd .Globals .ToDocumentGlobals ());if _aecaa !=nil {return nil ,_fg .Wrap (_aecaa ,_gcg ,"");};_bece ,_aecaa :=_gfec .PageNumber ();if _aecaa !=nil {return nil ,_fg .Wrap (_aecaa ,_gcg ,"");};_dggb :=[]_dd .Image {};var _bfdgd _dd .Image ;for _cebb :=1;_cebb <=_bece ;_cebb ++{_bfdgd ,_aecaa =_gfec .DecodePageImage (_cebb );if _aecaa !=nil {return nil ,_fg .Wrapf (_aecaa ,_gcg ,"\u0070\u0061\u0067\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_cebb );};_dggb =append (_dggb ,_bfdgd );};return _dggb ,nil ;};

// WriteString outputs the object as it is to be written to file.
func (_fecd *PdfObjectArray )WriteString ()string {var _dcgg _ab .Builder ;_dcgg .WriteString ("\u005b");for _beaag ,_gcacg :=range _fecd .Elements (){_dcgg .WriteString (_gcacg .WriteString ());if _beaag < (_fecd .Len ()-1){_dcgg .WriteString ("\u0020");};};_dcgg .WriteString ("\u005d");return _dcgg .String ();};const _edd ="\u0053\u0074\u0064C\u0046";

// NewDCTEncoder makes a new DCT encoder with default parameters.
func NewDCTEncoder ()*DCTEncoder {_agfe :=&DCTEncoder {};_agfe .ColorComponents =3;_agfe .BitsPerComponent =8;_agfe .Quality =DefaultJPEGQuality ;return _agfe ;};