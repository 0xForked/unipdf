//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package core defines and implements the primitive PDF object types in golang, and provides functionality
// for parsing those from a PDF file stream. This includes I/O handling, cross references, repairs, encryption,
// encoding and other core capabilities.
package core ;import (_gd "bufio";_abb "bytes";_ge "compress/lzw";_bb "compress/zlib";_fb "crypto/md5";_ag "crypto/rand";_g "encoding/hex";_d "errors";_ca "fmt";_aab "github.com/unidoc/unipdf/v3/common";_fbd "github.com/unidoc/unipdf/v3/core/security";
_dd "github.com/unidoc/unipdf/v3/core/security/crypt";_ae "github.com/unidoc/unipdf/v3/internal/ccittfax";_gdd "github.com/unidoc/unipdf/v3/internal/imageutil";_aeg "github.com/unidoc/unipdf/v3/internal/jbig2";_edc "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";
_fcg "github.com/unidoc/unipdf/v3/internal/jbig2/decoder";_bbe "github.com/unidoc/unipdf/v3/internal/jbig2/document";_ba "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_gdb "github.com/unidoc/unipdf/v3/internal/strutils";_fc "golang.org/x/image/tiff/lzw";
_abc "golang.org/x/xerrors";_ab "image";_bc "image/color";_aa "image/jpeg";_bf "io";_a "reflect";_ed "regexp";_f "sort";_b "strconv";_gg "strings";_c "sync";_ec "time";_ea "unicode";);func _ead (_gfb XrefTable ){_aab .Log .Debug ("\u003dX\u003d\u0058\u003d\u0058\u003d");
_aab .Log .Debug ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");_gdg :=0;for _ ,_acd :=range _gfb .ObjectMap {_aab .Log .Debug ("i\u002b\u0031\u003a\u0020\u0025\u0064 \u0028\u006f\u0062\u006a\u0020\u006eu\u006d\u003a\u0020\u0025\u0064\u0020\u0067e\u006e\u003a\u0020\u0025\u0064\u0029\u0020\u002d\u003e\u0020%\u0064",_gdg +1,_acd .ObjectNumber ,_acd .Generation ,_acd .Offset );
_gdg ++;};};func (_ddbd *PdfCrypt )securityHandler ()_fbd .StdHandler {if _ddbd ._fca .R >=5{return _fbd .NewHandlerR6 ();};return _fbd .NewHandlerR4 (_ddbd ._fgg ,_ddbd ._dab .Length );};func (_aga *PdfParser )lookupByNumber (_bfb int ,_gcc bool )(PdfObject ,bool ,error ){_fbg ,_cee :=_aga .ObjCache [_bfb ];
if _cee {_aab .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0063a\u0063\u0068\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0025\u0064",_bfb );return _fbg ,false ,nil ;};if _aga ._eeebe ==nil {_aga ._eeebe =map[int ]bool {};
};if _aga ._eeebe [_bfb ]{_aab .Log .Debug ("ER\u0052\u004f\u0052\u003a\u0020\u004c\u006fok\u0075\u0070\u0020\u006f\u0066\u0020\u0025\u0064\u0020\u0069\u0073\u0020\u0061\u006c\u0072e\u0061\u0064\u0079\u0020\u0069\u006e\u0020\u0070\u0072\u006f\u0067\u0072\u0065\u0073\u0073\u0020\u002d\u0020\u0072\u0065c\u0075\u0072\u0073\u0069\u0076\u0065 \u006c\u006f\u006f\u006b\u0075\u0070\u0020\u0061\u0074t\u0065m\u0070\u0074\u0020\u0062\u006c\u006f\u0063\u006b\u0065\u0064",_bfb );
return nil ,false ,_d .New ("\u0072\u0065\u0063\u0075\u0072\u0073\u0069\u0076\u0065\u0020\u006c\u006f\u006f\u006b\u0075p\u0020a\u0074\u0074\u0065\u006d\u0070\u0074\u0020\u0062\u006c\u006f\u0063\u006b\u0065\u0064");};_aga ._eeebe [_bfb ]=true ;defer delete (_aga ._eeebe ,_bfb );
_fgd ,_cee :=_aga ._feabg .ObjectMap [_bfb ];if !_cee {_aab .Log .Trace ("\u0055\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u006c\u006f\u0063\u0061t\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0069\u006e\u0020\u0078\u0072\u0065\u0066\u0073\u0021 \u002d\u0020\u0052\u0065\u0074u\u0072\u006e\u0069\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074");
var _ecd PdfObjectNull ;return &_ecd ,false ,nil ;};_aab .Log .Trace ("L\u006fo\u006b\u0075\u0070\u0020\u006f\u0062\u006a\u0020n\u0075\u006d\u0062\u0065r \u0025\u0064",_bfb );if _fgd .XType ==XrefTypeTableEntry {_aab .Log .Trace ("\u0078r\u0065f\u006f\u0062\u006a\u0020\u006fb\u006a\u0020n\u0075\u006d\u0020\u0025\u0064",_fgd .ObjectNumber );
_aab .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u0067e\u006e\u0020\u0025\u0064",_fgd .Generation );_aab .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0064",_fgd .Offset );
_aga ._fdeg .Seek (_fgd .Offset ,_bf .SeekStart );_aga ._aaae =_gd .NewReader (_aga ._fdeg );_gec ,_adg :=_aga .ParseIndirectObject ();if _adg !=nil {_aab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006ce\u0064\u0020\u0072\u0065\u0061\u0064\u0069n\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029",_adg );
if _gcc {_aab .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0072\u0065\u0070\u0061\u0069r\u0020\u0078\u0072\u0065\u0066\u0073\u0020\u0028\u0074\u006f\u0070\u0020d\u006f\u0077\u006e\u0029");_gdbd ,_fcf :=_aga .repairRebuildXrefsTopDown ();
if _fcf !=nil {_aab .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020r\u0065\u0070\u0061\u0069\u0072\u0020\u0028\u0025\u0073\u0029",_fcf );return nil ,false ,_fcf ;};_aga ._feabg =*_gdbd ;return _aga .lookupByNumber (_bfb ,false );
};return nil ,false ,_adg ;};if _gcc {_gcf ,_ ,_ :=_cad (_gec );if int (_gcf )!=_bfb {_aab .Log .Debug ("\u0049n\u0076\u0061\u006c\u0069d\u0020\u0078\u0072\u0065\u0066s\u003a \u0052e\u0062\u0075\u0069\u006c\u0064\u0069\u006eg");_fba :=_aga .rebuildXrefTable ();
if _fba !=nil {return nil ,false ,_fba ;};_aga .ObjCache =objectCache {};return _aga .lookupByNumberWrapper (_bfb ,false );};};_aab .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006f\u0062\u006a");_aga .ObjCache [_bfb ]=_gec ;
return _gec ,false ,nil ;}else if _fgd .XType ==XrefTypeObjectStream {_aab .Log .Trace ("\u0078r\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0021");_aab .Log .Trace ("\u003e\u004c\u006f\u0061\u0064\u0020\u0076\u0069\u0061\u0020\u004f\u0053\u0021");
_aab .Log .Trace ("\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d \u0061\u0076\u0061\u0069\u006c\u0061b\u006c\u0065\u0020\u0069\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020%\u0064\u002f\u0025\u0064",_fgd .OsObjNumber ,_fgd .OsObjIndex );
if _fgd .OsObjNumber ==_bfb {_aab .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0043i\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065f\u0065\u0072\u0065n\u0063e\u0021\u003f\u0021");return nil ,true ,_d .New ("\u0078\u0072\u0065f \u0063\u0069\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");
};if _ ,_egf :=_aga ._feabg .ObjectMap [_fgd .OsObjNumber ];_egf {_bgd ,_egc :=_aga .lookupObjectViaOS (_fgd .OsObjNumber ,_bfb );if _egc !=nil {_aab .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0052\u0065\u0074\u0075\u0072\u006e\u0069n\u0067\u0020\u0045\u0052\u0052\u0020\u0028\u0025\u0073\u0029",_egc );
return nil ,true ,_egc ;};_aab .Log .Trace ("\u003c\u004c\u006f\u0061\u0064\u0065\u0064\u0020\u0076i\u0061\u0020\u004f\u0053");_aga .ObjCache [_bfb ]=_bgd ;if _aga ._gbbg !=nil {_aga ._gbbg ._ffb [_bgd ]=true ;};return _bgd ,true ,nil ;};_aab .Log .Debug ("\u003f\u003f\u0020\u0042\u0065\u006c\u006f\u006eg\u0073\u0020\u0074o \u0061\u0020\u006e\u006f\u006e\u002dc\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u002e.\u002e\u0021");
return nil ,true ,_d .New ("\u006f\u0073\u0020\u0062\u0065\u006c\u006fn\u0067\u0073\u0020t\u006f\u0020\u0061\u0020n\u006f\u006e\u0020\u0063\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074");
};return nil ,false ,_d .New ("\u0075\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0078\u0072\u0065\u0066 \u0074\u0079\u0070\u0065");};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_agaab *LZWEncoder )MakeDecodeParams ()PdfObject {if _agaab .Predictor > 1{_gecc :=MakeDict ();_gecc .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_agaab .Predictor )));if _agaab .BitsPerComponent !=8{_gecc .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_agaab .BitsPerComponent )));
};if _agaab .Columns !=1{_gecc .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_agaab .Columns )));};if _agaab .Colors !=1{_gecc .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_agaab .Colors )));};return _gecc ;};return nil ;
};

// MakeStream creates an PdfObjectStream with specified contents and encoding. If encoding is nil, then raw encoding
// will be used (i.e. no encoding applied).
func MakeStream (contents []byte ,encoder StreamEncoder )(*PdfObjectStream ,error ){_feaca :=&PdfObjectStream {};if encoder ==nil {encoder =NewRawEncoder ();};_feaca .PdfObjectDictionary =encoder .MakeStreamDict ();_addd ,_gedff :=encoder .EncodeBytes (contents );
if _gedff !=nil {return nil ,_gedff ;};_feaca .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_addd ))));_feaca .Stream =_addd ;return _feaca ,nil ;};func (_aede *PdfParser )parseString ()(*PdfObjectString ,error ){_aede ._aaae .ReadByte ();
var _gcgd _abb .Buffer ;_dfbg :=1;for {_eagag ,_gceb :=_aede ._aaae .Peek (1);if _gceb !=nil {return MakeString (_gcgd .String ()),_gceb ;};if _eagag [0]=='\\'{_aede ._aaae .ReadByte ();_dbeg ,_gcaa :=_aede ._aaae .ReadByte ();if _gcaa !=nil {return MakeString (_gcgd .String ()),_gcaa ;
};if IsOctalDigit (_dbeg ){_beeg ,_dabe :=_aede ._aaae .Peek (2);if _dabe !=nil {return MakeString (_gcgd .String ()),_dabe ;};var _bdfg []byte ;_bdfg =append (_bdfg ,_dbeg );for _ ,_afeg :=range _beeg {if IsOctalDigit (_afeg ){_bdfg =append (_bdfg ,_afeg );
}else {break ;};};_aede ._aaae .Discard (len (_bdfg )-1);_aab .Log .Trace ("\u004e\u0075\u006d\u0065ri\u0063\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0022\u0025\u0073\u0022",_bdfg );_gffbd ,_dabe :=_b .ParseUint (string (_bdfg ),8,32);if _dabe !=nil {return MakeString (_gcgd .String ()),_dabe ;
};_gcgd .WriteByte (byte (_gffbd ));continue ;};switch _dbeg {case 'n':_gcgd .WriteRune ('\n');case 'r':_gcgd .WriteRune ('\r');case 't':_gcgd .WriteRune ('\t');case 'b':_gcgd .WriteRune ('\b');case 'f':_gcgd .WriteRune ('\f');case '(':_gcgd .WriteRune ('(');
case ')':_gcgd .WriteRune (')');case '\\':_gcgd .WriteRune ('\\');};continue ;}else if _eagag [0]=='('{_dfbg ++;}else if _eagag [0]==')'{_dfbg --;if _dfbg ==0{_aede ._aaae .ReadByte ();break ;};};_ded ,_ :=_aede ._aaae .ReadByte ();_gcgd .WriteByte (_ded );
};return MakeString (_gcgd .String ()),nil ;};

// DecodeStream decodes a FlateEncoded stream object and give back decoded bytes.
func (_aed *FlateEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_aab .Log .Trace ("\u0046l\u0061t\u0065\u0044\u0065\u0063\u006fd\u0065\u0020s\u0074\u0072\u0065\u0061\u006d");_aab .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_aed .Predictor );
if _aed .BitsPerComponent !=8{return nil ,_ca .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003d\u0025\u0064\u0020\u0028\u006f\u006e\u006c\u0079\u0020\u0038\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0029",_aed .BitsPerComponent );
};_fgc ,_egcb :=_aed .DecodeBytes (streamObj .Stream );if _egcb !=nil {return nil ,_egcb ;};_fgc ,_egcb =_aed .postDecodePredict (_fgc );if _egcb !=nil {return nil ,_egcb ;};return _fgc ,nil ;};func _aeed (_cea ,_edebc ,_dgebg uint8 )uint8 {_egagf :=int (_dgebg );
_abfa :=int (_edebc )-_egagf ;_gdfc :=int (_cea )-_egagf ;_egagf =_dbgd (_abfa +_gdfc );_abfa =_dbgd (_abfa );_gdfc =_dbgd (_gdfc );if _abfa <=_gdfc &&_abfa <=_egagf {return _cea ;}else if _gdfc <=_egagf {return _edebc ;};return _dgebg ;};

// UpdateParams updates the parameter values of the encoder.
func (_cfee *LZWEncoder )UpdateParams (params *PdfObjectDictionary ){_cbee ,_deb :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _deb ==nil {_cfee .Predictor =int (_cbee );};_bggf ,_deb :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));
if _deb ==nil {_cfee .BitsPerComponent =int (_bggf );};_cfbb ,_deb :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _deb ==nil {_cfee .Columns =int (_cfbb );};_ddc ,_deb :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));
if _deb ==nil {_cfee .Colors =int (_ddc );};_ggge ,_deb :=GetNumberAsInt64 (params .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065"));if _deb ==nil {_cfee .EarlyChange =int (_ggge );};};var _eded =_ed .MustCompile ("\u0073t\u0061r\u0074\u0078\u003f\u0072\u0065f\u005c\u0073*\u0028\u005c\u0064\u002b\u0029");


// GetName returns the *PdfObjectName represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetName (obj PdfObject )(_bbeb *PdfObjectName ,_cdfff bool ){_bbeb ,_cdfff =TraceToDirectObject (obj ).(*PdfObjectName );return _bbeb ,_cdfff ;};

// PdfObjectInteger represents the primitive PDF integer numerical object.
type PdfObjectInteger int64 ;const (DefaultJPEGQuality =75;);

// DecodeStream returns the passed in stream as a slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_egff *RawEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return streamObj .Stream ,nil ;};

// NewASCIIHexEncoder makes a new ASCII hex encoder.
func NewASCIIHexEncoder ()*ASCIIHexEncoder {_bfce :=&ASCIIHexEncoder {};return _bfce };

// SetIfNotNil sets the dictionary's key -> val mapping entry -IF- val is not nil.
// Note that we take care to perform a type switch.  Otherwise if we would supply a nil value
// of another type, e.g. (PdfObjectArray*)(nil), then it would not be a PdfObject(nil) and thus
// would get set.
func (_cdgc *PdfObjectDictionary )SetIfNotNil (key PdfObjectName ,val PdfObject ){if val !=nil {switch _aedd :=val .(type ){case *PdfObjectName :if _aedd !=nil {_cdgc .Set (key ,val );};case *PdfObjectDictionary :if _aedd !=nil {_cdgc .Set (key ,val );
};case *PdfObjectStream :if _aedd !=nil {_cdgc .Set (key ,val );};case *PdfObjectString :if _aedd !=nil {_cdgc .Set (key ,val );};case *PdfObjectNull :if _aedd !=nil {_cdgc .Set (key ,val );};case *PdfObjectInteger :if _aedd !=nil {_cdgc .Set (key ,val );
};case *PdfObjectArray :if _aedd !=nil {_cdgc .Set (key ,val );};case *PdfObjectBool :if _aedd !=nil {_cdgc .Set (key ,val );};case *PdfObjectFloat :if _aedd !=nil {_cdgc .Set (key ,val );};case *PdfObjectReference :if _aedd !=nil {_cdgc .Set (key ,val );
};case *PdfIndirectObject :if _aedd !=nil {_cdgc .Set (key ,val );};default:_aab .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",val );
};};};

// Str returns the string value of the PdfObjectString. Defined in addition to String() function to clarify that
// this function returns the underlying string directly, whereas the String function technically could include
// debug info.
func (_dbfab *PdfObjectString )Str ()string {return _dbfab ._agadg };

// DrawableImage is same as golang image/draw's Image interface that allow drawing images.
type DrawableImage interface{ColorModel ()_bc .Model ;Bounds ()_ab .Rectangle ;At (_degg ,_bcf int )_bc .Color ;Set (_egd ,_edcd int ,_eeaf _bc .Color );};

// NewRunLengthEncoder makes a new run length encoder
func NewRunLengthEncoder ()*RunLengthEncoder {return &RunLengthEncoder {}};

// DCTEncoder provides a DCT (JPG) encoding/decoding functionality for images.
type DCTEncoder struct{ColorComponents int ;BitsPerComponent int ;Width int ;Height int ;Quality int ;};func _geag (_gdac _bf .ReadSeeker ,_dabd int64 )(*offsetReader ,error ){_ffffb :=&offsetReader {_afgb :_gdac ,_bdeaf :_dabd };_ ,_gbde :=_ffffb .Seek (0,_bf .SeekStart );
return _ffffb ,_gbde ;};

// ToGoImage converts the JBIG2Image to the golang image.Image.
func (_eaab *JBIG2Image )ToGoImage ()(_ab .Image ,error ){const _dbcf ="J\u0042I\u0047\u0032\u0049\u006d\u0061\u0067\u0065\u002eT\u006f\u0047\u006f\u0049ma\u0067\u0065";if _eaab .Data ==nil {return nil ,_ba .Error (_dbcf ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");
};if _eaab .Width ==0||_eaab .Height ==0{return nil ,_ba .Error (_dbcf ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");
};_abag ,_ggb :=_gdd .NewImage (_eaab .Width ,_eaab .Height ,1,1,_eaab .Data ,nil ,nil );if _ggb !=nil {return nil ,_ggb ;};return _abag ,nil ;};func _gedd (_cde int )cryptFilters {return cryptFilters {_ee :_dd .NewFilterV2 (_cde )}};

// PdfIndirectObject represents the primitive PDF indirect object.
type PdfIndirectObject struct{PdfObjectReference ;PdfObject ;};func (_cdced *FlateEncoder )postDecodePredict (_fcef []byte )([]byte ,error ){if _cdced .Predictor > 1{if _cdced .Predictor ==2{_aab .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");
_aab .Log .Trace ("\u0043\u006f\u006c\u006f\u0072\u0073\u003a\u0020\u0025\u0064",_cdced .Colors );_ggfa :=_cdced .Columns *_cdced .Colors ;if _ggfa < 1{return []byte {},nil ;};_agdb :=len (_fcef )/_ggfa ;if len (_fcef )%_ggfa !=0{_aab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");
return nil ,_ca .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_fcef ),_ggfa );};if _ggfa %_cdced .Colors !=0{return nil ,_ca .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_ggfa ,_cdced .Colors );
};if _ggfa > len (_fcef ){_aab .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_ggfa ,len (_fcef ));
return nil ,_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_aab .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_fcef ),_fcef );
_cbc :=_abb .NewBuffer (nil );for _gbae :=0;_gbae < _agdb ;_gbae ++{_gggb :=_fcef [_ggfa *_gbae :_ggfa *(_gbae +1)];for _fedc :=_cdced .Colors ;_fedc < _ggfa ;_fedc ++{_gggb [_fedc ]+=_gggb [_fedc -_cdced .Colors ];};_cbc .Write (_gggb );};_cdd :=_cbc .Bytes ();
_aab .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_cdd ),_cdd );return _cdd ,nil ;}else if _cdced .Predictor >=10&&_cdced .Predictor <=15{_aab .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");
_cagg :=_cdced .Columns *_cdced .Colors +1;_efde :=len (_fcef )/_cagg ;if len (_fcef )%_cagg !=0{return nil ,_ca .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_fcef ),_cagg );
};if _cagg > len (_fcef ){_aab .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_cagg ,len (_fcef ));
return nil ,_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_deg :=_abb .NewBuffer (nil );_aab .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_cdced .Columns );
_aab .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_fcef ),_cagg ,_efde );_agde :=make ([]byte ,_cagg );for _fccc :=0;_fccc < _cagg ;_fccc ++{_agde [_fccc ]=0;
};_cgaf :=_cdced .Colors ;for _ccfc :=0;_ccfc < _efde ;_ccfc ++{_bfd :=_fcef [_cagg *_ccfc :_cagg *(_ccfc +1)];_cagf :=_bfd [0];switch _cagf {case _bcbc :case _agb :for _fae :=1+_cgaf ;_fae < _cagg ;_fae ++{_bfd [_fae ]+=_bfd [_fae -_cgaf ];};case _cecb :for _eecg :=1;
_eecg < _cagg ;_eecg ++{_bfd [_eecg ]+=_agde [_eecg ];};case _ebc :for _dcdb :=1;_dcdb < _cgaf +1;_dcdb ++{_bfd [_dcdb ]+=_agde [_dcdb ]/2;};for _faa :=_cgaf +1;_faa < _cagg ;_faa ++{_bfd [_faa ]+=byte ((int (_bfd [_faa -_cgaf ])+int (_agde [_faa ]))/2);
};case _bace :for _ddbde :=1;_ddbde < _cagg ;_ddbde ++{var _aafd ,_acb ,_agbg byte ;_acb =_agde [_ddbde ];if _ddbde >=_cgaf +1{_aafd =_bfd [_ddbde -_cgaf ];_agbg =_agde [_ddbde -_cgaf ];};_bfd [_ddbde ]+=_aeed (_aafd ,_acb ,_agbg );};default:_aab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029\u0020\u0040\u0072o\u0077\u0020\u0025\u0064",_cagf ,_ccfc );
return nil ,_ca .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_cagf );};copy (_agde ,_bfd );_deg .Write (_bfd [1:]);};_ccfe :=_deg .Bytes ();return _ccfe ,nil ;
}else {_aab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_cdced .Predictor );return nil ,_ca .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_cdced .Predictor );
};};return _fcef ,nil ;};func (_cbda *PdfParser )parseNull ()(PdfObjectNull ,error ){_ ,_dgge :=_cbda ._aaae .Discard (4);return PdfObjectNull {},_dgge ;};func (_babbf *PdfParser )xrefNextObjectOffset (_cbcbf int64 )int64 {_ddab :=int64 (0);if len (_babbf ._feabg .ObjectMap )==0{return 0;
};if len (_babbf ._feabg ._gea )==0{_dfad :=0;for _ ,_dfbd :=range _babbf ._feabg .ObjectMap {if _dfbd .Offset > 0{_dfad ++;};};if _dfad ==0{return 0;};_babbf ._feabg ._gea =make ([]XrefObject ,_dfad );_gbdbf :=0;for _ ,_cfaf :=range _babbf ._feabg .ObjectMap {if _cfaf .Offset > 0{_babbf ._feabg ._gea [_gbdbf ]=_cfaf ;
_gbdbf ++;};};_f .Slice (_babbf ._feabg ._gea ,func (_bfae ,_becdg int )bool {return _babbf ._feabg ._gea [_bfae ].Offset < _babbf ._feabg ._gea [_becdg ].Offset ;});};_cfcb :=_f .Search (len (_babbf ._feabg ._gea ),func (_cebee int )bool {return _babbf ._feabg ._gea [_cebee ].Offset >=_cbcbf });
if _cfcb < len (_babbf ._feabg ._gea ){_ddab =_babbf ._feabg ._gea [_cfcb ].Offset ;};return _ddab ;};func (_cbea *PdfParser )readTextLine ()(string ,error ){var _gdfe _abb .Buffer ;for {_gbfd ,_abeg :=_cbea ._aaae .Peek (1);if _abeg !=nil {_aab .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_abeg .Error ());
return _gdfe .String (),_abeg ;};if (_gbfd [0]!='\r')&&(_gbfd [0]!='\n'){_eddcd ,_ :=_cbea ._aaae .ReadByte ();_gdfe .WriteByte (_eddcd );}else {break ;};};return _gdfe .String (),nil ;};

// Remove removes an element specified by key.
func (_acbg *PdfObjectDictionary )Remove (key PdfObjectName ){_deeg :=-1;for _bbff ,_feeg :=range _acbg ._eegb {if _feeg ==key {_deeg =_bbff ;break ;};};if _deeg >=0{_acbg ._eegb =append (_acbg ._eegb [:_deeg ],_acbg ._eegb [_deeg +1:]...);delete (_acbg ._abegb ,key );
};};type objectStream struct{N int ;_bff []byte ;_bfa map[int ]int64 ;};

// UpdateParams updates the parameter values of the encoder.
// Implements StreamEncoder interface.
func (_cfgb *JBIG2Encoder )UpdateParams (params *PdfObjectDictionary ){_adfb ,_abde :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _abde ==nil {_cfgb .BitsPerComponent =int (_adfb );
};_bgc ,_abde :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _abde ==nil {_cfgb .Width =int (_bgc );};_fbca ,_abde :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _abde ==nil {_cfgb .Height =int (_fbca );
};_bfgg ,_abde :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _abde ==nil {_cfgb .ColorComponents =int (_bfgg );};};

// PdfParser parses a PDF file and provides access to the object structure of the PDF.
type PdfParser struct{_cbgab Version ;_fdeg _bf .ReadSeeker ;_aaae *_gd .Reader ;_eagg int64 ;_feabg XrefTable ;_fedcb int64 ;_dbff *xrefType ;_bgba objectStreams ;_daeb *PdfObjectDictionary ;_gbbg *PdfCrypt ;_gdddc *PdfIndirectObject ;_gdff bool ;ObjCache objectCache ;
_eeebe map[int ]bool ;_cggec map[int64 ]bool ;_accf ParserMetadata ;_ffeg bool ;};

// DecodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_eeba *RawEncoder )DecodeBytes (encoded []byte )([]byte ,error ){return encoded ,nil };func (_gaaf *JBIG2Encoder )encodeImage (_ebgd _ab .Image )([]byte ,error ){const _cede ="e\u006e\u0063\u006f\u0064\u0065\u0049\u006d\u0061\u0067\u0065";_dcgb ,_cgfae :=GoImageToJBIG2 (_ebgd ,JB2ImageAutoThreshold );
if _cgfae !=nil {return nil ,_ba .Wrap (_cgfae ,_cede ,"\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069m\u0061g\u0065\u0020\u0074\u006f\u0020\u006a\u0062\u0069\u0067\u0032\u0020\u0069\u006d\u0067");};if _cgfae =_gaaf .AddPageImage (_dcgb ,&_gaaf .DefaultPageSettings );
_cgfae !=nil {return nil ,_ba .Wrap (_cgfae ,_cede ,"");};return _gaaf .Encode ();};

// IsDelimiter checks if a character represents a delimiter.
func IsDelimiter (c byte )bool {return c =='('||c ==')'||c =='<'||c =='>'||c =='['||c ==']'||c =='{'||c =='}'||c =='/'||c =='%';};

// Elements returns a slice of the PdfObject elements in the array.
// Preferred over accessing the array directly as type may be changed in future major versions (v3).
func (_daaf *PdfObjectStreams )Elements ()[]PdfObject {if _daaf ==nil {return nil ;};return _daaf ._cgaag ;};

// WriteString outputs the object as it is to be written to file.
func (_dcfca *PdfIndirectObject )WriteString ()string {var _cffc _gg .Builder ;_cffc .WriteString (_b .FormatInt (_dcfca .ObjectNumber ,10));_cffc .WriteString ("\u0020\u0030\u0020\u0052");return _cffc .String ();};func (_ffgf *PdfParser )skipComments ()error {if _ ,_ccg :=_ffgf .skipSpaces ();
_ccg !=nil {return _ccg ;};_afaag :=true ;for {_dccg ,_eed :=_ffgf ._aaae .Peek (1);if _eed !=nil {_aab .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_eed .Error ());return _eed ;};if _afaag &&_dccg [0]!='%'{return nil ;};_afaag =false ;
if (_dccg [0]!='\r')&&(_dccg [0]!='\n'){_ffgf ._aaae .ReadByte ();}else {break ;};};return _ffgf .skipComments ();};

// ResolveReference resolves reference if `o` is a *PdfObjectReference and returns the object referenced to.
// Otherwise returns back `o`.
func ResolveReference (obj PdfObject )PdfObject {if _cdga ,_ebbfd :=obj .(*PdfObjectReference );_ebbfd {return _cdga .Resolve ();};return obj ;};

// Get returns the PdfObject corresponding to the specified key.
// Returns a nil value if the key is not set.
func (_ddbbg *PdfObjectDictionary )Get (key PdfObjectName )PdfObject {_ddbbg ._aggc .Lock ();defer _ddbbg ._aggc .Unlock ();_feea ,_cbeg :=_ddbbg ._abegb [key ];if !_cbeg {return nil ;};return _feea ;};func (_dcc *PdfCrypt )generateParams (_cafe ,_cacd []byte )error {_fde :=_dcc .securityHandler ();
_dgeb ,_eee :=_fde .GenerateParams (&_dcc ._fca ,_cacd ,_cafe );if _eee !=nil {return _eee ;};_dcc ._afdc =_dgeb ;return nil ;};

// EqualObjects returns true if `obj1` and `obj2` have the same contents.
//
// NOTE: It is a good idea to flatten obj1 and obj2 with FlattenObject before calling this function
// so that contents, rather than references, can be compared.
func EqualObjects (obj1 ,obj2 PdfObject )bool {return _ffcg (obj1 ,obj2 ,0)};

// PdfObjectArray represents the primitive PDF array object.
type PdfObjectArray struct{_beea []PdfObject };

// MakeIndirectObject creates an PdfIndirectObject with a specified direct object PdfObject.
func MakeIndirectObject (obj PdfObject )*PdfIndirectObject {_gdfa :=&PdfIndirectObject {};_gdfa .PdfObject =obj ;return _gdfa ;};

// DecodeBytes decodes a slice of LZW encoded bytes and returns the result.
func (_dfg *LZWEncoder )DecodeBytes (encoded []byte )([]byte ,error ){var _gbfb _abb .Buffer ;_ecdb :=_abb .NewReader (encoded );var _edbg _bf .ReadCloser ;if _dfg .EarlyChange ==1{_edbg =_fc .NewReader (_ecdb ,_fc .MSB ,8);}else {_edbg =_ge .NewReader (_ecdb ,_ge .MSB ,8);
};defer _edbg .Close ();if _ ,_ffa :=_gbfb .ReadFrom (_edbg );_ffa !=nil {if _ffa !=_bf .ErrUnexpectedEOF ||_gbfb .Len ()==0{return nil ,_ffa ;};_aab .Log .Debug ("\u0057\u0041\u0052\u004e\u003a\u0020\u004c\u005a\u0057\u0020\u0064\u0065\u0063\u006f\u0064i\u006e\u0067\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076\u002e \u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062e \u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u002e",_ffa );
};return _gbfb .Bytes (),nil ;};

// Decrypt attempts to decrypt the PDF file with a specified password.  Also tries to
// decrypt with an empty password.  Returns true if successful, false otherwise.
// An error is returned when there is a problem with decrypting.
func (_bdead *PdfParser )Decrypt (password []byte )(bool ,error ){if _bdead ._gbbg ==nil {return false ,_d .New ("\u0063\u0068\u0065\u0063k \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u0069\u0072s\u0074");};_gagg ,_fbac :=_bdead ._gbbg .authenticate (password );
if _fbac !=nil {return false ,_fbac ;};if !_gagg {_gagg ,_fbac =_bdead ._gbbg .authenticate ([]byte (""));};return _gagg ,_fbac ;};

// LZWEncoder provides LZW encoding/decoding functionality.
type LZWEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Colors int ;

// LZW algorithm setting.
EarlyChange int ;};

// FlateEncoder represents Flate encoding.
type FlateEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Rows int ;Colors int ;_dbgf *_gdd .ImageBase ;};

// ParseIndirectObject parses an indirect object from the input stream. Can also be an object stream.
// Returns the indirect object (*PdfIndirectObject) or the stream object (*PdfObjectStream).
func (_ddcb *PdfParser )ParseIndirectObject ()(PdfObject ,error ){_edebg :=PdfIndirectObject {};_edebg ._acge =_ddcb ;_aab .Log .Trace ("\u002dR\u0065a\u0064\u0020\u0069\u006e\u0064i\u0072\u0065c\u0074\u0020\u006f\u0062\u006a");_acea ,_ggfe :=_ddcb ._aaae .Peek (20);
if _ggfe !=nil {if _ggfe !=_bf .EOF {_aab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020r\u0065a\u0064\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a");return &_edebg ,_ggfe ;
};};_aab .Log .Trace ("\u0028\u0069\u006edi\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_acea ));_gdbfb :=_bbefd .FindStringSubmatchIndex (string (_acea ));if len (_gdbfb )< 6{if _ggfe ==_bf .EOF {return nil ,_ggfe ;
};_aab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_acea ));
return &_edebg ,_d .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");
};_ddcb ._aaae .Discard (_gdbfb [0]);_aab .Log .Trace ("O\u0066\u0066\u0073\u0065\u0074\u0073\u0020\u0025\u0020\u0064",_gdbfb );_eega :=_gdbfb [1]-_gdbfb [0];_bbgee :=make ([]byte ,_eega );_ ,_ggfe =_ddcb .ReadAtLeast (_bbgee ,_eega );if _ggfe !=nil {_aab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u0072\u0065\u0061\u0064\u0020-\u0020\u0025\u0073",_ggfe );
return nil ,_ggfe ;};_aab .Log .Trace ("\u0074\u0065\u0078t\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_bbgee );_geabd :=_bbefd .FindStringSubmatch (string (_bbgee ));if len (_geabd )< 3{_aab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_bbgee ));
return &_edebg ,_d .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");
};_gccda ,_ :=_b .Atoi (_geabd [1]);_dggc ,_ :=_b .Atoi (_geabd [2]);_edebg .ObjectNumber =int64 (_gccda );_edebg .GenerationNumber =int64 (_dggc );for {_afbf ,_adfe :=_ddcb ._aaae .Peek (2);if _adfe !=nil {return &_edebg ,_adfe ;};_aab .Log .Trace ("I\u006ed\u002e\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_afbf ),string (_afbf ));
if IsWhiteSpace (_afbf [0]){_ddcb .skipSpaces ();}else if _afbf [0]=='%'{_ddcb .skipComments ();}else if (_afbf [0]=='<')&&(_afbf [1]=='<'){_aab .Log .Trace ("\u0043\u0061\u006c\u006c\u0020\u0050\u0061\u0072\u0073e\u0044\u0069\u0063\u0074");_edebg .PdfObject ,_adfe =_ddcb .ParseDict ();
_aab .Log .Trace ("\u0045\u004f\u0046\u0020Ca\u006c\u006c\u0020\u0050\u0061\u0072\u0073\u0065\u0044\u0069\u0063\u0074\u003a\u0020%\u0076",_adfe );if _adfe !=nil {return &_edebg ,_adfe ;};_aab .Log .Trace ("\u0050\u0061\u0072\u0073\u0065\u0064\u0020\u0064\u0069\u0063t\u0069\u006f\u006e\u0061\u0072\u0079\u002e.\u002e\u0020\u0066\u0069\u006e\u0069\u0073\u0068\u0065\u0064\u002e");
}else if (_afbf [0]=='/')||(_afbf [0]=='(')||(_afbf [0]=='[')||(_afbf [0]=='<'){_edebg .PdfObject ,_adfe =_ddcb .parseObject ();if _adfe !=nil {return &_edebg ,_adfe ;};_aab .Log .Trace ("P\u0061\u0072\u0073\u0065\u0064\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u002e\u002e\u002e \u0066\u0069\u006ei\u0073h\u0065\u0064\u002e");
}else if _afbf [0]==']'{_aab .Log .Debug ("\u0057\u0041\u0052\u004e\u0049N\u0047\u003a\u0020\u0027\u005d\u0027 \u0063\u0068\u0061\u0072\u0061\u0063\u0074e\u0072\u0020\u006eo\u0074\u0020\u0062\u0065i\u006e\u0067\u0020\u0075\u0073\u0065d\u0020\u0061\u0073\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006e\u0064\u0069n\u0067\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e");
_ddcb ._aaae .Discard (1);}else {if _afbf [0]=='e'{_dfff ,_ccac :=_ddcb .readTextLine ();if _ccac !=nil {return nil ,_ccac ;};if len (_dfff )>=6&&_dfff [0:6]=="\u0065\u006e\u0064\u006f\u0062\u006a"{break ;};}else if _afbf [0]=='s'{_afbf ,_ =_ddcb ._aaae .Peek (10);
if string (_afbf [:6])=="\u0073\u0074\u0072\u0065\u0061\u006d"{_ddeb :=6;if len (_afbf )> 6{if IsWhiteSpace (_afbf [_ddeb ])&&_afbf [_ddeb ]!='\r'&&_afbf [_ddeb ]!='\n'{_aab .Log .Debug ("\u004e\u006fn\u002d\u0063\u006f\u006e\u0066\u006f\u0072\u006d\u0061\u006e\u0074\u0020\u0050\u0044\u0046\u0020\u006e\u006f\u0074 \u0065\u006e\u0064\u0069\u006e\u0067 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0069\u006e\u0065\u0020\u0070\u0072o\u0070\u0065r\u006c\u0079\u0020\u0077i\u0074\u0068\u0020\u0045\u004fL\u0020\u006d\u0061\u0072\u006b\u0065\u0072");
_ddcb ._accf ._bceb =true ;_ddeb ++;};if _afbf [_ddeb ]=='\r'{_ddeb ++;if _afbf [_ddeb ]=='\n'{_ddeb ++;};}else if _afbf [_ddeb ]=='\n'{_ddeb ++;}else {_ddcb ._accf ._bceb =true ;};};_ddcb ._aaae .Discard (_ddeb );_dfdbd ,_abeb :=_edebg .PdfObject .(*PdfObjectDictionary );
if !_abeb {return nil ,_d .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006di\u0073s\u0069\u006e\u0067\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_aab .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0069c\u0074\u0020\u0025\u0073",_dfdbd );
_gbda ,_bgbg :=_ddcb .traceStreamLength (_dfdbd .Get ("\u004c\u0065\u006e\u0067\u0074\u0068"));if _bgbg !=nil {_aab .Log .Debug ("\u0046\u0061\u0069l\u0020\u0074\u006f\u0020t\u0072\u0061\u0063\u0065\u0020\u0073\u0074r\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0025\u0076",_bgbg );
return nil ,_bgbg ;};_aab .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_gbda );_fgbd ,_gfde :=_gbda .(*PdfObjectInteger );if !_gfde {return nil ,_d .New ("\u0073\u0074re\u0061\u006d\u0020l\u0065\u006e\u0067\u0074h n\u0065ed\u0073\u0020\u0074\u006f\u0020\u0062\u0065 a\u006e\u0020\u0069\u006e\u0074\u0065\u0067e\u0072");
};_dacca :=*_fgbd ;if _dacca < 0{return nil ,_d .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006e\u0065\u0065\u0064\u0073\u0020\u0074\u006f \u0062e\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0030");};_gecbd :=_ddcb .GetFileOffset ();
_cbgcf :=_ddcb .xrefNextObjectOffset (_gecbd );if _gecbd +int64 (_dacca )> _cbgcf &&_cbgcf > _gecbd {_aab .Log .Debug ("E\u0078\u0070\u0065\u0063te\u0064 \u0065\u006e\u0064\u0069\u006eg\u0020\u0061\u0074\u0020\u0025\u0064",_gecbd +int64 (_dacca ));_aab .Log .Debug ("\u004e\u0065\u0078\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020\u0061t\u0020\u0025\u0064",_cbgcf );
_acdd :=_cbgcf -_gecbd -17;if _acdd < 0{return nil ,_d .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020go\u0069\u006e\u0067 \u0070\u0061s\u0074\u0020\u0062\u006f\u0075\u006ed\u0061\u0072i\u0065\u0073");
};_aab .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0061\u0020l\u0065\u006e\u0067\u0074\u0068\u0020c\u006f\u0072\u0072\u0065\u0063\u0074\u0069\u006f\u006e\u0020\u0074\u006f\u0020%\u0064\u002e\u002e\u002e",_acdd );_dacca =PdfObjectInteger (_acdd );
_dfdbd .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (_acdd ));};if int64 (_dacca )> _ddcb ._eagg {_aab .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0053t\u0072\u0065\u0061\u006d\u0020l\u0065\u006e\u0067\u0074\u0068\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u0061\u0072\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0066\u0069\u006c\u0065\u0020\u0073\u0069\u007a\u0065");
return nil ,_d .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020la\u0072\u0067\u0065r\u0020\u0074h\u0061\u006e\u0020\u0066\u0069\u006ce\u0020\u0073i\u007a\u0065");};_afea :=make ([]byte ,_dacca );
_ ,_bgbg =_ddcb .ReadAtLeast (_afea ,int (_dacca ));if _bgbg !=nil {_aab .Log .Debug ("E\u0052\u0052\u004f\u0052 s\u0074r\u0065\u0061\u006d\u0020\u0028%\u0064\u0029\u003a\u0020\u0025\u0058",len (_afea ),_afea );_aab .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_bgbg );
return nil ,_bgbg ;};_dgba :=PdfObjectStream {};_dgba .Stream =_afea ;_dgba .PdfObjectDictionary =_edebg .PdfObject .(*PdfObjectDictionary );_dgba .ObjectNumber =_edebg .ObjectNumber ;_dgba .GenerationNumber =_edebg .GenerationNumber ;_dgba .PdfObjectReference ._acge =_ddcb ;
_ddcb .skipSpaces ();_ddcb ._aaae .Discard (9);_ddcb .skipSpaces ();return &_dgba ,nil ;};};_edebg .PdfObject ,_adfe =_ddcb .parseObject ();if _edebg .PdfObject ==nil {_aab .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");
_edebg .PdfObject =MakeNull ();};return &_edebg ,_adfe ;};};if _edebg .PdfObject ==nil {_aab .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");
_edebg .PdfObject =MakeNull ();};_aab .Log .Trace ("\u0052\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0021");return &_edebg ,nil ;};

// EncodeBytes ASCII encodes the passed in slice of bytes.
func (_daa *ASCIIHexEncoder )EncodeBytes (data []byte )([]byte ,error ){var _ecbd _abb .Buffer ;for _ ,_ddbb :=range data {_ecbd .WriteString (_ca .Sprintf ("\u0025\u002e\u0032X\u0020",_ddbb ));};_ecbd .WriteByte ('>');return _ecbd .Bytes (),nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_ecbdf *MultiEncoder )MakeDecodeParams ()PdfObject {if len (_ecbdf ._dfdb )==0{return nil ;};if len (_ecbdf ._dfdb )==1{return _ecbdf ._dfdb [0].MakeDecodeParams ();};_gcg :=MakeArray ();_gfed :=true ;for _ ,_dgeeg :=range _ecbdf ._dfdb {_bdge :=_dgeeg .MakeDecodeParams ();
if _bdge ==nil {_gcg .Append (MakeNull ());}else {_gfed =false ;_gcg .Append (_bdge );};};if _gfed {return nil ;};return _gcg ;};

// Keys returns the list of keys in the dictionary.
// If `d` is nil returns a nil slice.
func (_debdd *PdfObjectDictionary )Keys ()[]PdfObjectName {if _debdd ==nil {return nil ;};return _debdd ._eegb ;};func (_efa *JBIG2Image )toBitmap ()(_cafc *_edc .Bitmap ,_cccg error ){const _dfef ="\u004a\u0042\u0049\u00472I\u006d\u0061\u0067\u0065\u002e\u0074\u006f\u0042\u0069\u0074\u006d\u0061\u0070";
if _efa .Data ==nil {return nil ,_ba .Error (_dfef ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");};if _efa .Width ==0||_efa .Height ==0{return nil ,_ba .Error (_dfef ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");
};if _efa .HasPadding {_cafc ,_cccg =_edc .NewWithData (_efa .Width ,_efa .Height ,_efa .Data );}else {_cafc ,_cccg =_edc .NewWithUnpaddedData (_efa .Width ,_efa .Height ,_efa .Data );};if _cccg !=nil {return nil ,_ba .Wrap (_cccg ,_dfef ,"");};return _cafc ,nil ;
};func (_debd *PdfParser )parseArray ()(*PdfObjectArray ,error ){_bede :=MakeArray ();_debd ._aaae .ReadByte ();for {_debd .skipSpaces ();_bagd ,_bffc :=_debd ._aaae .Peek (1);if _bffc !=nil {return _bede ,_bffc ;};if _bagd [0]==']'{_debd ._aaae .ReadByte ();
break ;};_gecec ,_bffc :=_debd .parseObject ();if _bffc !=nil {return _bede ,_bffc ;};_bede .Append (_gecec );};return _bede ,nil ;};

// GetString returns the *PdfObjectString represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetString (obj PdfObject )(_ddgg *PdfObjectString ,_ebda bool ){_ddgg ,_ebda =TraceToDirectObject (obj ).(*PdfObjectString );return _ddgg ,_ebda ;};

// JPXEncoder implements JPX encoder/decoder (dummy, for now)
// FIXME: implement
type JPXEncoder struct{};

// Get returns the i-th element of the array or nil if out of bounds (by index).
func (_afab *PdfObjectArray )Get (i int )PdfObject {if _afab ==nil ||i >=len (_afab ._beea )||i < 0{return nil ;};return _afab ._beea [i ];};

// Decoded returns the PDFDocEncoding or UTF-16BE decoded string contents.
// UTF-16BE is applied when the first two bytes are 0xFE, 0XFF, otherwise decoding of
// PDFDocEncoding is performed.
func (_gbfg *PdfObjectString )Decoded ()string {if _gbfg ==nil {return "";};_fgcba :=[]byte (_gbfg ._agadg );if len (_fgcba )>=2&&_fgcba [0]==0xFE&&_fgcba [1]==0xFF{return _gdb .UTF16ToString (_fgcba [2:]);};return _gdb .PDFDocEncodingToString (_fgcba );
};const (_bcbc =0;_agb =1;_cecb =2;_ebc =3;_bace =4;);

// DecodeBytes decodes byte array with ASCII85. 5 ASCII characters -> 4 raw binary bytes
func (_gaf *ASCII85Encoder )DecodeBytes (encoded []byte )([]byte ,error ){var _cadb []byte ;_aab .Log .Trace ("\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0020\u0044e\u0063\u006f\u0064\u0065");_cadf :=0;_eeeda :=false ;for _cadf < len (encoded )&&!_eeeda {_agf :=[5]byte {0,0,0,0,0};
_gfae :=0;_bbac :=0;_afae :=4;for _bbac < 5+_gfae {if _cadf +_bbac ==len (encoded ){break ;};_bfeaa :=encoded [_cadf +_bbac ];if IsWhiteSpace (_bfeaa ){_gfae ++;_bbac ++;continue ;}else if _bfeaa =='~'&&_cadf +_bbac +1< len (encoded )&&encoded [_cadf +_bbac +1]=='>'{_afae =(_bbac -_gfae )-1;
if _afae < 0{_afae =0;};_eeeda =true ;break ;}else if _bfeaa >='!'&&_bfeaa <='u'{_bfeaa -='!';}else if _bfeaa =='z'&&_bbac -_gfae ==0{_afae =4;_bbac ++;break ;}else {_aab .Log .Error ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u002c\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020co\u0064\u0065");
return nil ,_d .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0063\u006f\u0064\u0065\u0020e\u006e\u0063\u006f\u0075\u006e\u0074\u0065\u0072\u0065\u0064");};_agf [_bbac -_gfae ]=_bfeaa ;_bbac ++;};_cadf +=_bbac ;for _cabg :=_afae +1;_cabg < 5;_cabg ++{_agf [_cabg ]=84;
};_fgdd :=uint32 (_agf [0])*85*85*85*85+uint32 (_agf [1])*85*85*85+uint32 (_agf [2])*85*85+uint32 (_agf [3])*85+uint32 (_agf [4]);_aeee :=[]byte {byte ((_fgdd >>24)&0xff),byte ((_fgdd >>16)&0xff),byte ((_fgdd >>8)&0xff),byte (_fgdd &0xff)};_cadb =append (_cadb ,_aeee [:_afae ]...);
};_aab .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0065\u006e\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",encoded );_aab .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0064\u0065\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",_cadb );
return _cadb ,nil ;};

// HasInvalidSubsectionHeader implements core.ParserMetadata interface.
func (_eebe ParserMetadata )HasInvalidSubsectionHeader ()bool {return _eebe ._deeb };

// DecodeBytes decodes a multi-encoded slice of bytes by passing it through the
// DecodeBytes method of the underlying encoders.
func (_dce *MultiEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_ebfg :=encoded ;var _bbfd error ;for _ ,_cdgb :=range _dce ._dfdb {_aab .Log .Trace ("\u004du\u006c\u0074i\u0020\u0045\u006e\u0063o\u0064\u0065\u0072 \u0044\u0065\u0063\u006f\u0064\u0065\u003a\u0020\u0041pp\u006c\u0079\u0069n\u0067\u0020F\u0069\u006c\u0074\u0065\u0072\u003a \u0025\u0076 \u0025\u0054",_cdgb ,_cdgb );
_ebfg ,_bbfd =_cdgb .DecodeBytes (_ebfg );if _bbfd !=nil {return nil ,_bbfd ;};};return _ebfg ,nil ;};

// AddEncoder adds the passed in encoder to the underlying encoder slice.
func (_cbcb *MultiEncoder )AddEncoder (encoder StreamEncoder ){_cbcb ._dfdb =append (_cbcb ._dfdb ,encoder );};

// PdfObjectBool represents the primitive PDF boolean object.
type PdfObjectBool bool ;func _fegd (_bfe *PdfObjectStream ,_edbe *PdfObjectDictionary )(*LZWEncoder ,error ){_geea :=NewLZWEncoder ();_eddc :=_bfe .PdfObjectDictionary ;if _eddc ==nil {return _geea ,nil ;};if _edbe ==nil {_edea :=TraceToDirectObject (_eddc .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));
if _edea !=nil {if _gffg ,_bfag :=_edea .(*PdfObjectDictionary );_bfag {_edbe =_gffg ;}else if _gbb ,_dbe :=_edea .(*PdfObjectArray );_dbe {if _gbb .Len ()==1{if _fad ,_bcegg :=GetDict (_gbb .Get (0));_bcegg {_edbe =_fad ;};};};if _edbe ==nil {_aab .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_edea );
return nil ,_ca .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};};_cbbf :=_eddc .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");if _cbbf !=nil {_bbfc ,_gead :=_cbbf .(*PdfObjectInteger );
if !_gead {_aab .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a \u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065d\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u006e\u0075\u006d\u0065\u0072i\u0063 \u0028\u0025\u0054\u0029",_cbbf );
return nil ,_ca .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");};if *_bbfc !=0&&*_bbfc !=1{return nil ,_ca .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0076\u0061\u006c\u0075e\u0020\u0028\u006e\u006f\u0074 \u0030\u0020o\u0072\u0020\u0031\u0029");
};_geea .EarlyChange =int (*_bbfc );}else {_geea .EarlyChange =1;};if _edbe ==nil {return _geea ,nil ;};if _fcae ,_gbff :=GetIntVal (_edbe .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065"));_gbff {if _fcae ==0||_fcae ==1{_geea .EarlyChange =_fcae ;
}else {_aab .Log .Debug ("W\u0041\u0052\u004e\u003a\u0020\u0069n\u0076\u0061\u006c\u0069\u0064\u0020E\u0061\u0072\u006c\u0079\u0043\u0068\u0061n\u0067\u0065\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020%\u0064",_fcae );};};_cbbf =_edbe .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");
if _cbbf !=nil {_bdda ,_ebgc :=_cbbf .(*PdfObjectInteger );if !_ebgc {_aab .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_cbbf );
return nil ,_ca .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_geea .Predictor =int (*_bdda );};_cbbf =_edbe .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");
if _cbbf !=nil {_fegc ,_aad :=_cbbf .(*PdfObjectInteger );if !_aad {_aab .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");
return nil ,_ca .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_geea .BitsPerComponent =int (*_fegc );};if _geea .Predictor > 1{_geea .Columns =1;_cbbf =_edbe .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");
if _cbbf !=nil {_fbgg ,_fedg :=_cbbf .(*PdfObjectInteger );if !_fedg {return nil ,_ca .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_geea .Columns =int (*_fbgg );
};_geea .Colors =1;_cbbf =_edbe .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _cbbf !=nil {_cbde ,_gceae :=_cbbf .(*PdfObjectInteger );if !_gceae {return nil ,_ca .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");
};_geea .Colors =int (*_cbde );};};_aab .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_edbe .String ());return _geea ,nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_dffe *JPXEncoder )UpdateParams (params *PdfObjectDictionary ){};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_cadd *CCITTFaxEncoder )MakeStreamDict ()*PdfObjectDictionary {_egec :=MakeDict ();_egec .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_cadd .GetFilterName ()));_egec .SetIfNotNil ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_cadd .MakeDecodeParams ());
return _egec ;};

// EncodeBytes encodes the passed in slice of bytes by passing it through the
// EncodeBytes method of the underlying encoders.
func (_debf *MultiEncoder )EncodeBytes (data []byte )([]byte ,error ){_dcca :=data ;var _dgc error ;for _cffa :=len (_debf ._dfdb )-1;_cffa >=0;_cffa --{_adb :=_debf ._dfdb [_cffa ];_dcca ,_dgc =_adb .EncodeBytes (_dcca );if _dgc !=nil {return nil ,_dgc ;
};};return _dcca ,nil ;};

// GetXrefTable returns the PDFs xref table.
func (_fbga *PdfParser )GetXrefTable ()XrefTable {return _fbga ._feabg };

// Bytes returns the PdfObjectString content as a []byte array.
func (_gecd *PdfObjectString )Bytes ()[]byte {return []byte (_gecd ._agadg )};const _ee ="\u0053\u0074\u0064C\u0046";

// GetStream returns the *PdfObjectStream represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetStream (obj PdfObject )(_bdfe *PdfObjectStream ,_gabb bool ){obj =ResolveReference (obj );_bdfe ,_gabb =obj .(*PdfObjectStream );return _bdfe ,_gabb ;};func (_bdgb *PdfParser )parseDetailedHeader ()(_fac error ){_bdgb ._fdeg .Seek (0,_bf .SeekStart );
_bdgb ._aaae =_gd .NewReader (_bdgb ._fdeg );_cbef :=20;_egga :=make ([]byte ,_cbef );var (_baf bool ;_dbag int ;);for {_bfc ,_gge :=_bdgb ._aaae .ReadByte ();if _gge !=nil {if _gge ==_bf .EOF {break ;}else {return _gge ;};};if IsDecimalDigit (_bfc )&&_egga [_cbef -1]=='.'&&IsDecimalDigit (_egga [_cbef -2])&&_egga [_cbef -3]=='-'&&_egga [_cbef -4]=='F'&&_egga [_cbef -5]=='D'&&_egga [_cbef -6]=='P'&&_egga [_cbef -7]=='%'{_bdgb ._cbgab =Version {Major :int (_egga [_cbef -2]-'0'),Minor :int (_bfc -'0')};
_bdgb ._accf ._bdg =_dbag -7;_baf =true ;break ;};_dbag ++;_egga =append (_egga [1:_cbef ],_bfc );};if !_baf {return _ca .Errorf ("n\u006f \u0066\u0069\u006c\u0065\u0020\u0068\u0065\u0061d\u0065\u0072\u0020\u0066ou\u006e\u0064");};_cfgf ,_fac :=_bdgb ._aaae .ReadByte ();
if _fac ==_bf .EOF {return _ca .Errorf ("\u006eo\u0074\u0020\u0061\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0050d\u0066\u0020\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074");};if _fac !=nil {return _fac ;};_bdgb ._accf ._bbcd =_cfgf =='\n';_cfgf ,_fac =_bdgb ._aaae .ReadByte ();
if _fac !=nil {return _ca .Errorf ("\u006e\u006f\u0074\u0020a\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0070\u0064\u0066 \u0064o\u0063\u0075\u006d\u0065\u006e\u0074\u003a \u0025\u0077",_fac );};if _cfgf !='%'{return nil ;};_aecf :=make ([]byte ,4);_ ,_fac =_bdgb ._aaae .Read (_aecf );
if _fac !=nil {return _ca .Errorf ("\u006e\u006f\u0074\u0020a\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0070\u0064\u0066 \u0064o\u0063\u0075\u006d\u0065\u006e\u0074\u003a \u0025\u0077",_fac );};_bdgb ._accf ._edeb =[4]byte {_aecf [0],_aecf [1],_aecf [2],_aecf [3]};
return nil ;};

// IsHexadecimal checks if the PdfObjectString contains Hexadecimal data.
func (_fdea *PdfObjectString )IsHexadecimal ()bool {return _fdea ._bgbe };

// NewJPXEncoder returns a new instance of JPXEncoder.
func NewJPXEncoder ()*JPXEncoder {return &JPXEncoder {}};

// WriteString outputs the object as it is to be written to file.
func (_edgb *PdfObjectFloat )WriteString ()string {return _b .FormatFloat (float64 (*_edgb ),'f',-1,64);};const (JB2Generic JBIG2CompressionType =iota ;JB2SymbolCorrelation ;JB2SymbolRankHaus ;);

// GetFloat returns the *PdfObjectFloat represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetFloat (obj PdfObject )(_baff *PdfObjectFloat ,_edaaf bool ){_baff ,_edaaf =TraceToDirectObject (obj ).(*PdfObjectFloat );return _baff ,_edaaf ;};type encryptDict struct{Filter string ;V int ;SubFilter string ;Length int ;StmF string ;StrF string ;
EFF string ;CF map[string ]_dd .FilterDict ;};

// NewLZWEncoder makes a new LZW encoder with default parameters.
func NewLZWEncoder ()*LZWEncoder {_aegf :=&LZWEncoder {};_aegf .Predictor =1;_aegf .BitsPerComponent =8;_aegf .Colors =1;_aegf .Columns =1;_aegf .EarlyChange =1;return _aegf ;};

// DecodeGlobals decodes 'encoded' byte stream and returns their Globally defined segments ('Globals').
func (_gfgdg *JBIG2Encoder )DecodeGlobals (encoded []byte )(_aeg .Globals ,error ){return _aeg .DecodeGlobals (encoded );};func _cac (_abbd _dd .Filter ,_fea _fbd .AuthEvent )*PdfObjectDictionary {if _fea ==""{_fea =_fbd .EventDocOpen ;};_ebab :=MakeDict ();
_ebab .Set ("\u0054\u0079\u0070\u0065",MakeName ("C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"));_ebab .Set ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et",MakeName (string (_fea )));_ebab .Set ("\u0043\u0046\u004d",MakeName (_abbd .Name ()));
_ebab .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_abbd .KeyLength ())));return _ebab ;};

// EncodeStream encodes the stream data using the encoded specified by the stream's dictionary.
func EncodeStream (streamObj *PdfObjectStream )error {_aab .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_cgab ,_dfaf :=NewEncoderFromStream (streamObj );if _dfaf !=nil {_aab .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_dfaf );
return _dfaf ;};if _ecdc ,_bfdef :=_cgab .(*LZWEncoder );_bfdef {_ecdc .EarlyChange =0;streamObj .PdfObjectDictionary .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (0));};_aab .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076\u000a",_cgab );
_beed ,_dfaf :=_cgab .EncodeBytes (streamObj .Stream );if _dfaf !=nil {_aab .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_dfaf );return _dfaf ;
};streamObj .Stream =_beed ;streamObj .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_beed ))));return nil ;};

// String returns a string describing `streams`.
func (_eebb *PdfObjectStreams )String ()string {return _ca .Sprintf ("\u004f\u0062j\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0025\u0064",_eebb .ObjectNumber );};

// JBIG2Image is the image structure used by the jbig2 encoder. Its Data must be in a
// 1 bit per component and 1 component per pixel (1bpp). In order to create binary image
// use GoImageToJBIG2 function. If the image data contains the row bytes padding set the HasPadding to true.
type JBIG2Image struct{

// Width and Height defines the image boundaries.
Width ,Height int ;

// Data is the byte slice data for the input image
Data []byte ;

// HasPadding is the attribute that defines if the last byte of the data in the row contains
// 0 bits padding.
HasPadding bool ;};type objectCache map[int ]PdfObject ;

// MakeStreamDict make a new instance of an encoding dictionary for a stream object.
func (_fgce *ASCII85Encoder )MakeStreamDict ()*PdfObjectDictionary {_cbad :=MakeDict ();_cbad .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_fgce .GetFilterName ()));return _cbad ;};

// HasInvalidSeparationAfterXRef implements core.ParserMetadata interface.
func (_ggab ParserMetadata )HasInvalidSeparationAfterXRef ()bool {return _ggab ._eeb };

// GetFilterName returns the name of the encoding filter.
func (_ddef *ASCII85Encoder )GetFilterName ()string {return StreamEncodingFilterNameASCII85 };

// GetObjectStreams returns the *PdfObjectStreams represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetObjectStreams (obj PdfObject )(_ebbg *PdfObjectStreams ,_ggfg bool ){_ebbg ,_ggfg =obj .(*PdfObjectStreams );return _ebbg ,_ggfg ;};var _cfd =_ed .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064+\u0029\u005c\u0073\u002b\u0028\u005b\u006e\u0066\u005d\u0029\\\u0073\u002a\u0024");
func (_cdec *PdfCrypt )checkAccessRights (_edcb []byte )(bool ,_fbd .Permissions ,error ){_cbgg :=_cdec .securityHandler ();_aag ,_cfg ,_gbd :=_cbgg .Authenticate (&_cdec ._fca ,_edcb );if _gbd !=nil {return false ,0,_gbd ;}else if _cfg ==0||len (_aag )==0{return false ,0,nil ;
};return true ,_cfg ,nil ;};

// ParserMetadata is the parser based metadata information about document.
// The data here could be used on document verification.
type ParserMetadata struct{_bdg int ;_bbcd bool ;_edeb [4]byte ;_dbde bool ;_cga bool ;_eaded bool ;_bceb bool ;_deeb bool ;_eeb bool ;};var _bbefd =_ed .MustCompile ("\u0028\u005c\u0064\u002b)\\\u0073\u002b\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u006f\u0062\u006a");
func (_ggbaa *PdfObjectInteger )String ()string {return _ca .Sprintf ("\u0025\u0064",*_ggbaa )};func (_gdddbe *PdfParser )readComment ()(string ,error ){var _ggba _abb .Buffer ;_ ,_adgb :=_gdddbe .skipSpaces ();if _adgb !=nil {return _ggba .String (),_adgb ;
};_bfaa :=true ;for {_aca ,_ebdc :=_gdddbe ._aaae .Peek (1);if _ebdc !=nil {_aab .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_ebdc .Error ());return _ggba .String (),_ebdc ;};if _bfaa &&_aca [0]!='%'{return _ggba .String (),_d .New ("c\u006f\u006d\u006d\u0065\u006e\u0074 \u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0073\u0074a\u0072\u0074\u0020w\u0069t\u0068\u0020\u0025");
};_bfaa =false ;if (_aca [0]!='\r')&&(_aca [0]!='\n'){_dffd ,_ :=_gdddbe ._aaae .ReadByte ();_ggba .WriteByte (_dffd );}else {break ;};};return _ggba .String (),nil ;};

// GetAsFloat64Slice returns the array as []float64 slice.
// Returns an error if not entirely numeric (only PdfObjectIntegers, PdfObjectFloats).
func (_cbgaa *PdfObjectArray )GetAsFloat64Slice ()([]float64 ,error ){var _aeceaa []float64 ;for _ ,_aeagc :=range _cbgaa .Elements (){_ceag ,_gcgb :=GetNumberAsFloat (TraceToDirectObject (_aeagc ));if _gcgb !=nil {return nil ,_ca .Errorf ("\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006e\u0075m\u0062\u0065\u0072");
};_aeceaa =append (_aeceaa ,_ceag );};return _aeceaa ,nil ;};

// SetPredictor sets the predictor function.  Specify the number of columns per row.
// The columns indicates the number of samples per row.
// Used for grouping data together for compression.
func (_cbggf *FlateEncoder )SetPredictor (columns int ){_cbggf .Predictor =11;_cbggf .Columns =columns ;};func (_dbg *PdfCrypt )loadCryptFilters (_cgf *PdfObjectDictionary )error {_dbg ._egg =cryptFilters {};_dfd :=_cgf .Get ("\u0043\u0046");_dfd =TraceToDirectObject (_dfd );
if _cc ,_deca :=_dfd .(*PdfObjectReference );_deca {_caf ,_ecee :=_dbg ._eade .LookupByReference (*_cc );if _ecee !=nil {_aab .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0075\u0070\u0020\u0043\u0046\u0020\u0072\u0065\u0066\u0065\u0072en\u0063\u0065");
return _ecee ;};_dfd =TraceToDirectObject (_caf );};_gcd ,_bge :=_dfd .(*PdfObjectDictionary );if !_bge {_aab .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0043\u0046\u002c \u0074\u0079\u0070\u0065: \u0025\u0054",_dfd );return _d .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0043\u0046");
};for _ ,_egfc :=range _gcd .Keys (){_cgfa :=_gcd .Get (_egfc );if _eadf ,_gece :=_cgfa .(*PdfObjectReference );_gece {_edee ,_ecb :=_dbg ._eade .LookupByReference (*_eadf );if _ecb !=nil {_aab .Log .Debug ("\u0045\u0072ro\u0072\u0020\u006co\u006f\u006b\u0075\u0070 up\u0020di\u0063\u0074\u0069\u006f\u006e\u0061\u0072y \u0072\u0065\u0066\u0065\u0072\u0065\u006ec\u0065");
return _ecb ;};_cgfa =TraceToDirectObject (_edee );};_efg ,_afb :=_cgfa .(*PdfObjectDictionary );if !_afb {return _ca .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074\u0020\u0069\u006e \u0043\u0046\u0020\u0028\u006e\u0061\u006d\u0065\u0020\u0025\u0073\u0029\u0020-\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079\u0020\u0062\u0075\u0074\u0020\u0025\u0054",_egfc ,_cgfa );
};if _egfc =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{_aab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u002d\u0020\u0043\u0061\u006e\u006e\u006f\u0074\u0020\u006f\u0076\u0065\u0072\u0077r\u0069\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0069d\u0065\u006e\u0074\u0069\u0074\u0079\u0020\u0066\u0069\u006c\u0074\u0065\u0072 \u002d\u0020\u0054\u0072\u0079\u0069n\u0067\u0020\u006ee\u0078\u0074");
continue ;};var _ade _dd .FilterDict ;if _ddbg :=_bac (&_ade ,_efg );_ddbg !=nil {return _ddbg ;};_bdf ,_ced :=_dd .NewFilter (_ade );if _ced !=nil {return _ced ;};_dbg ._egg [string (_egfc )]=_bdf ;};_dbg ._egg ["\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"]=_dd .NewIdentity ();
_dbg ._aeac ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _fe ,_dac :=_cgf .Get ("\u0053\u0074\u0072\u0046").(*PdfObjectName );_dac {if _ ,_geda :=_dbg ._egg [string (*_fe )];!_geda {return _ca .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u0072\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_fe );
};_dbg ._aeac =string (*_fe );};_dbg ._bdb ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _efe ,_cag :=_cgf .Get ("\u0053\u0074\u006d\u0046").(*PdfObjectName );_cag {if _ ,_gfaf :=_dbg ._egg [string (*_efe )];!_gfaf {return _ca .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u006d\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_efe );
};_dbg ._bdb =string (*_efe );};return nil ;};

// DecodeStream decodes the stream containing CCITTFax encoded image data.
func (_gegg *CCITTFaxEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _gegg .DecodeBytes (streamObj .Stream );};type offsetReader struct{_afgb _bf .ReadSeeker ;_bdeaf int64 ;};

// NewMultiEncoder returns a new instance of MultiEncoder.
func NewMultiEncoder ()*MultiEncoder {_edaa :=MultiEncoder {};_edaa ._dfdb =[]StreamEncoder {};return &_edaa ;};func (_faccb *PdfParser )parseObject ()(PdfObject ,error ){_aab .Log .Trace ("\u0052e\u0061d\u0020\u0064\u0069\u0072\u0065c\u0074\u0020o\u0062\u006a\u0065\u0063\u0074");
_faccb .skipSpaces ();for {_adbe ,_ecdg :=_faccb ._aaae .Peek (2);if _ecdg !=nil {if _ecdg !=_bf .EOF ||len (_adbe )==0{return nil ,_ecdg ;};if len (_adbe )==1{_adbe =append (_adbe ,' ');};};_aab .Log .Trace ("\u0050e\u0065k\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u003a\u0020\u0025\u0073",string (_adbe ));
if _adbe [0]=='/'{_gfab ,_ggaa :=_faccb .parseName ();_aab .Log .Trace ("\u002d\u003e\u004ea\u006d\u0065\u003a\u0020\u0027\u0025\u0073\u0027",_gfab );return &_gfab ,_ggaa ;}else if _adbe [0]=='('{_aab .Log .Trace ("\u002d>\u0053\u0074\u0072\u0069\u006e\u0067!");
_cdbf ,_bbbbf :=_faccb .parseString ();return _cdbf ,_bbbbf ;}else if _adbe [0]=='['{_aab .Log .Trace ("\u002d\u003e\u0041\u0072\u0072\u0061\u0079\u0021");_defd ,_edca :=_faccb .parseArray ();return _defd ,_edca ;}else if (_adbe [0]=='<')&&(_adbe [1]=='<'){_aab .Log .Trace ("\u002d>\u0044\u0069\u0063\u0074\u0021");
_bgcc ,_efc :=_faccb .ParseDict ();return _bgcc ,_efc ;}else if _adbe [0]=='<'{_aab .Log .Trace ("\u002d\u003e\u0048\u0065\u0078\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0021");_gaac ,_gedad :=_faccb .parseHexString ();return _gaac ,_gedad ;}else if _adbe [0]=='%'{_faccb .readComment ();
_faccb .skipSpaces ();}else {_aab .Log .Trace ("\u002d\u003eN\u0075\u006d\u0062e\u0072\u0020\u006f\u0072\u0020\u0072\u0065\u0066\u003f");_adbe ,_ =_faccb ._aaae .Peek (15);_dfec :=string (_adbe );_aab .Log .Trace ("\u0050\u0065\u0065k\u0020\u0073\u0074\u0072\u003a\u0020\u0025\u0073",_dfec );
if (len (_dfec )> 3)&&(_dfec [:4]=="\u006e\u0075\u006c\u006c"){_ccge ,_feeb :=_faccb .parseNull ();return &_ccge ,_feeb ;}else if (len (_dfec )> 4)&&(_dfec [:5]=="\u0066\u0061\u006cs\u0065"){_agcb ,_fcgc :=_faccb .parseBool ();return &_agcb ,_fcgc ;}else if (len (_dfec )> 3)&&(_dfec [:4]=="\u0074\u0072\u0075\u0065"){_feee ,_gbfe :=_faccb .parseBool ();
return &_feee ,_gbfe ;};_ddeeb :=_acege .FindStringSubmatch (_dfec );if len (_ddeeb )> 1{_adbe ,_ =_faccb ._aaae .ReadBytes ('R');_aab .Log .Trace ("\u002d\u003e\u0020\u0021\u0052\u0065\u0066\u003a\u0020\u0027\u0025\u0073\u0027",string (_adbe [:]));_gedb ,_geddd :=_fdfb (string (_adbe ));
_gedb ._acge =_faccb ;return &_gedb ,_geddd ;};_gbce :=_gabd .FindStringSubmatch (_dfec );if len (_gbce )> 1{_aab .Log .Trace ("\u002d\u003e\u0020\u004e\u0075\u006d\u0062\u0065\u0072\u0021");_dbbc ,_fdbb :=_faccb .parseNumber ();return _dbbc ,_fdbb ;};
_gbce =_cbf .FindStringSubmatch (_dfec );if len (_gbce )> 1{_aab .Log .Trace ("\u002d\u003e\u0020\u0045xp\u006f\u006e\u0065\u006e\u0074\u0069\u0061\u006c\u0020\u004e\u0075\u006d\u0062\u0065r\u0021");_aab .Log .Trace ("\u0025\u0020\u0073",_gbce );_abfb ,_ffaf :=_faccb .parseNumber ();
return _abfb ,_ffaf ;};_aab .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020U\u006e\u006b\u006e\u006f\u0077n\u0020(\u0070e\u0065\u006b\u0020\u0022\u0025\u0073\u0022)",_dfec );return nil ,_d .New ("\u006f\u0062\u006a\u0065\u0063t\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020\u0075\u006e\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e");
};};};

// WriteString outputs the object as it is to be written to file.
func (_gede *PdfObjectString )WriteString ()string {var _acbcbe _abb .Buffer ;if _gede ._bgbe {_acfc :=_g .EncodeToString (_gede .Bytes ());_acbcbe .WriteString ("\u003c");_acbcbe .WriteString (_acfc );_acbcbe .WriteString ("\u003e");return _acbcbe .String ();
};_gbdad :=map[byte ]string {'\n':"\u005c\u006e",'\r':"\u005c\u0072",'\t':"\u005c\u0074",'\b':"\u005c\u0062",'\f':"\u005c\u0066",'(':"\u005c\u0028",')':"\u005c\u0029",'\\':"\u005c\u005c"};_acbcbe .WriteString ("\u0028");for _agdc :=0;_agdc < len (_gede ._agadg );
_agdc ++{_eabc :=_gede ._agadg [_agdc ];if _bfbb ,_cggf :=_gbdad [_eabc ];_cggf {_acbcbe .WriteString (_bfbb );}else {_acbcbe .WriteByte (_eabc );};};_acbcbe .WriteString ("\u0029");return _acbcbe .String ();};func _bec (_gfdce *PdfObjectStream ,_dgga *PdfObjectDictionary )(*RunLengthEncoder ,error ){return NewRunLengthEncoder (),nil ;
};func (_ceeg *PdfParser )rebuildXrefTable ()error {_ffdcc :=XrefTable {};_ffdcc .ObjectMap =map[int ]XrefObject {};_dcaa :=make ([]int ,0,len (_ceeg ._feabg .ObjectMap ));for _egda :=range _ceeg ._feabg .ObjectMap {_dcaa =append (_dcaa ,_egda );};_f .Ints (_dcaa );
for _ ,_febg :=range _dcaa {_eggd :=_ceeg ._feabg .ObjectMap [_febg ];_baddg ,_ ,_fdcb :=_ceeg .lookupByNumberWrapper (_febg ,false );if _fdcb !=nil {_aab .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020U\u006e\u0061\u0062\u006ce t\u006f l\u006f\u006f\u006b\u0020\u0075\u0070\u0020ob\u006a\u0065\u0063\u0074\u0020\u0028\u0025s\u0029",_fdcb );
_aab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0063\u006fm\u0070\u006c\u0065\u0074\u0065\u006c\u0079\u0020\u0062\u0072\u006f\u006b\u0065\u006e\u0020\u002d\u0020\u0061\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0074\u006f \u0072\u0065\u0070\u0061\u0069r\u0020");
_fbbc ,_cddf :=_ceeg .repairRebuildXrefsTopDown ();if _cddf !=nil {_aab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0072\u0065\u0062\u0075\u0069l\u0064\u0020\u0072\u0065\u0070a\u0069\u0072 \u0028\u0025\u0073\u0029",_cddf );
return _cddf ;};_ceeg ._feabg =*_fbbc ;_aab .Log .Debug ("\u0052e\u0070\u0061\u0069\u0072e\u0064\u0020\u0078\u0072\u0065f\u0020t\u0061b\u006c\u0065\u0020\u0062\u0075\u0069\u006ct");return nil ;};_ggadg ,_bbdee ,_fdcb :=_cad (_baddg );if _fdcb !=nil {return _fdcb ;
};_eggd .ObjectNumber =int (_ggadg );_eggd .Generation =int (_bbdee );_ffdcc .ObjectMap [int (_ggadg )]=_eggd ;};_ceeg ._feabg =_ffdcc ;_aab .Log .Debug ("N\u0065w\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061b\u006c\u0065\u0020\u0062ui\u006c\u0074");
_ead (_ceeg ._feabg );return nil ;};

// MultiEncoder supports serial encoding.
type MultiEncoder struct{_dfdb []StreamEncoder };func (_gggd *PdfParser )checkPostEOFData ()error {const _bbb ="\u0025\u0025\u0045O\u0046";_ ,_fddg :=_gggd ._fdeg .Seek (-int64 (len ([]byte (_bbb )))-1,_bf .SeekEnd );if _fddg !=nil {return _fddg ;};_ddf :=make ([]byte ,len ([]byte (_bbb ))+1);
_ ,_fddg =_gggd ._fdeg .Read (_ddf );if _fddg !=nil {if _fddg !=_bf .EOF {return _fddg ;};};if string (_ddf )==_bbb ||string (_ddf )==_bbb +"\u000a"{_gggd ._accf ._dbde =true ;};return nil ;};func (_cgdec *PdfParser )repairSeekXrefMarker ()error {_gaced ,_dccgg :=_cgdec ._fdeg .Seek (0,_bf .SeekEnd );
if _dccgg !=nil {return _dccgg ;};_adfcd :=_ed .MustCompile ("\u005cs\u0078\u0072\u0065\u0066\u005c\u0073*");var _agbc int64 ;var _febd int64 =1000;for _agbc < _gaced {if _gaced <=(_febd +_agbc ){_febd =_gaced -_agbc ;};_ ,_bggge :=_cgdec ._fdeg .Seek (-_agbc -_febd ,_bf .SeekEnd );
if _bggge !=nil {return _bggge ;};_dgece :=make ([]byte ,_febd );_cgdec ._fdeg .Read (_dgece );_aab .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0078\u0072\u0065\u0066\u0020\u003a\u0020\u0022\u0025\u0073\u0022",string (_dgece ));
_ecgg :=_adfcd .FindAllStringIndex (string (_dgece ),-1);if _ecgg !=nil {_agfg :=_ecgg [len (_ecgg )-1];_aab .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_ecgg );_cgdec ._fdeg .Seek (-_agbc -_febd +int64 (_agfg [0]),_bf .SeekEnd );_cgdec ._aaae =_gd .NewReader (_cgdec ._fdeg );
for {_cgdea ,_dged :=_cgdec ._aaae .Peek (1);if _dged !=nil {return _dged ;};_aab .Log .Trace ("\u0042\u003a\u0020\u0025\u0064\u0020\u0025\u0063",_cgdea [0],_cgdea [0]);if !IsWhiteSpace (_cgdea [0]){break ;};_cgdec ._aaae .Discard (1);};return nil ;};_aab .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");
_agbc +=_febd ;};_aab .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074a\u0062\u006c\u0065\u0020\u006d\u0061r\u006b\u0065\u0072\u0020\u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066o\u0075\u006e\u0064\u002e");
return _d .New ("\u0078r\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0020");};

// EncodeBytes JPX encodes the passed in slice of bytes.
func (_bbcad *JPXEncoder )EncodeBytes (data []byte )([]byte ,error ){_aab .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_bbcad .GetFilterName ());
return data ,ErrNoJPXDecode ;};

// PdfCrypt provides PDF encryption/decryption support.
// The PDF standard supports encryption of strings and streams (Section 7.6).
type PdfCrypt struct{_dab encryptDict ;_fca _fbd .StdEncryptDict ;_fgg string ;_afdc []byte ;_ffb map[PdfObject ]bool ;_fga map[PdfObject ]bool ;_gdf bool ;_egg cryptFilters ;_bdb string ;_aeac string ;_eade *PdfParser ;_df map[int ]struct{};};

// WriteString outputs the object as it is to be written to file.
func (_agff *PdfObjectReference )WriteString ()string {var _dabfd _gg .Builder ;_dabfd .WriteString (_b .FormatInt (_agff .ObjectNumber ,10));_dabfd .WriteString ("\u0020");_dabfd .WriteString (_b .FormatInt (_agff .GenerationNumber ,10));_dabfd .WriteString ("\u0020\u0052");
return _dabfd .String ();};const _aaab =32<<(^uint (0)>>63);

// GetObjectNums returns a sorted list of object numbers of the PDF objects in the file.
func (_dfea *PdfParser )GetObjectNums ()[]int {var _beff []int ;for _ ,_ccba :=range _dfea ._feabg .ObjectMap {_beff =append (_beff ,_ccba .ObjectNumber );};_f .Ints (_beff );return _beff ;};func (_gdge *PdfCrypt )encryptBytes (_dae []byte ,_fed string ,_egcgc []byte )([]byte ,error ){_aab .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");
_fbc ,_eec :=_gdge ._egg [_fed ];if !_eec {return nil ,_ca .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_fed );};return _fbc .EncryptBytes (_dae ,_egcgc );};

// String returns a string describing `array`.
func (_dfac *PdfObjectArray )String ()string {_bdca :="\u005b";for _fegde ,_bgeg :=range _dfac .Elements (){_bdca +=_bgeg .String ();if _fegde < (_dfac .Len ()-1){_bdca +="\u002c\u0020";};};_bdca +="\u005d";return _bdca ;};

// String returns a string describing `ref`.
func (_fdef *PdfObjectReference )String ()string {return _ca .Sprintf ("\u0052\u0065\u0066\u0028\u0025\u0064\u0020\u0025\u0064\u0029",_fdef .ObjectNumber ,_fdef .GenerationNumber );};

// GetFilterName returns the name of the encoding filter.
func (_dcda *LZWEncoder )GetFilterName ()string {return StreamEncodingFilterNameLZW };

// GetInt returns the *PdfObjectBool object that is represented by a PdfObject either directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetInt (obj PdfObject )(_bccc *PdfObjectInteger ,_egdgf bool ){_bccc ,_egdgf =TraceToDirectObject (obj ).(*PdfObjectInteger );return _bccc ,_egdgf ;};type cryptFilters map[string ]_dd .Filter ;

// GetFilterName returns the name of the encoding filter.
func (_gcbf *JBIG2Encoder )GetFilterName ()string {return StreamEncodingFilterNameJBIG2 };func (_dga *offsetReader )Seek (offset int64 ,whence int )(int64 ,error ){if whence ==_bf .SeekStart {offset +=_dga ._bdeaf ;};_abdb ,_bda :=_dga ._afgb .Seek (offset ,whence );
if _bda !=nil {return _abdb ,_bda ;};if whence ==_bf .SeekCurrent {_abdb -=_dga ._bdeaf ;};if _abdb < 0{return 0,_d .New ("\u0063\u006f\u0072\u0065\u002eo\u0066\u0066\u0073\u0065\u0074\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053e\u0065\u006b\u003a\u0020\u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e");
};return _abdb ,nil ;};

// GetFileOffset returns the current file offset, accounting for buffered position.
func (_ffbe *PdfParser )GetFileOffset ()int64 {_gaba ,_ :=_ffbe ._fdeg .Seek (0,_bf .SeekCurrent );_gaba -=int64 (_ffbe ._aaae .Buffered ());return _gaba ;};func _egaa (_ffbb *_fbd .StdEncryptDict ,_eae *PdfObjectDictionary ){_eae .Set ("\u0052",MakeInteger (int64 (_ffbb .R )));
_eae .Set ("\u0050",MakeInteger (int64 (_ffbb .P )));_eae .Set ("\u004f",MakeStringFromBytes (_ffbb .O ));_eae .Set ("\u0055",MakeStringFromBytes (_ffbb .U ));if _ffbb .R >=5{_eae .Set ("\u004f\u0045",MakeStringFromBytes (_ffbb .OE ));_eae .Set ("\u0055\u0045",MakeStringFromBytes (_ffbb .UE ));
_eae .Set ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061",MakeBool (_ffbb .EncryptMetadata ));if _ffbb .R > 5{_eae .Set ("\u0050\u0065\u0072m\u0073",MakeStringFromBytes (_ffbb .Perms ));};};};

// DecodeStream decodes a JBIG2 encoded stream and returns the result as a slice of bytes.
func (_acfd *JBIG2Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _acfd .DecodeBytes (streamObj .Stream );};var _gabd =_ed .MustCompile ("\u005e\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");


// Set sets the PdfObject at index i of the streams. An error is returned if the index is outside bounds.
func (_cggcb *PdfObjectStreams )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_cggcb ._cgaag ){return _d .New ("\u004f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_cggcb ._cgaag [i ]=obj ;return nil ;};

// LookupByReference looks up a PdfObject by a reference.
func (_fdb *PdfParser )LookupByReference (ref PdfObjectReference )(PdfObject ,error ){_aab .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0075\u0070\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0025\u0073",ref .String ());return _fdb .LookupByNumber (int (ref .ObjectNumber ));
};

// PdfObjectStreams represents the primitive PDF object streams.
// 7.5.7 Object Streams (page 45).
type PdfObjectStreams struct{PdfObjectReference ;_cgaag []PdfObject ;};

// WriteString outputs the object as it is to be written to file.
func (_bdbfg *PdfObjectBool )WriteString ()string {if *_bdbfg {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};

// PdfObjectString represents the primitive PDF string object.
type PdfObjectString struct{_agadg string ;_bgbe bool ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_bgb *JBIG2Encoder )MakeStreamDict ()*PdfObjectDictionary {_ffcff :=MakeDict ();_ffcff .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_bgb .GetFilterName ()));return _ffcff ;};

// MakeName creates a PdfObjectName from a string.
func MakeName (s string )*PdfObjectName {_bbea :=PdfObjectName (s );return &_bbea };var _cbf =_ed .MustCompile ("\u005e\u005b\\\u002b\u002d\u002e\u005d*\u0028\u005b0\u002d\u0039\u002e\u005d\u002b\u0029\u005b\u0065E\u005d\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");


// DecodeBytes decodes a slice of JBIG2 encoded bytes and returns the results.
func (_deba *JBIG2Encoder )DecodeBytes (encoded []byte )([]byte ,error ){return _aeg .DecodeBytes (encoded ,_fcg .Parameters {},_deba .Globals );};

// WriteString outputs the object as it is to be written to file.
func (_cgfd *PdfObjectDictionary )WriteString ()string {var _ggef _gg .Builder ;_ggef .WriteString ("\u003c\u003c");for _ ,_ddce :=range _cgfd ._eegb {_daac :=_cgfd ._abegb [_ddce ];_ggef .WriteString (_ddce .WriteString ());_ggef .WriteString ("\u0020");
_ggef .WriteString (_daac .WriteString ());};_ggef .WriteString ("\u003e\u003e");return _ggef .String ();};

// UpdateParams updates the parameter values of the encoder.
func (_fgda *RawEncoder )UpdateParams (params *PdfObjectDictionary ){};

// PdfObjectDictionary represents the primitive PDF dictionary/map object.
type PdfObjectDictionary struct{_abegb map[PdfObjectName ]PdfObject ;_eegb []PdfObjectName ;_aggc *_c .Mutex ;_fbaab *PdfParser ;};

// Version represents a version of a PDF standard.
type Version struct{Major int ;Minor int ;};func _dbgd (_aecb int )int {_adba :=_aecb >>(_aaab -1);return (_aecb ^_adba )-_adba };func (_aefb *PdfParser )parseXrefStream (_fcab *PdfObjectInteger )(*PdfObjectDictionary ,error ){if _fcab !=nil {_aab .Log .Trace ("\u0058\u0052\u0065f\u0053\u0074\u006d\u0020x\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0061\u0074\u0020\u0025\u0064",_fcab );
_aefb ._fdeg .Seek (int64 (*_fcab ),_bf .SeekStart );_aefb ._aaae =_gd .NewReader (_aefb ._fdeg );};_cegc :=_aefb .GetFileOffset ();_fbcaa ,_gdcc :=_aefb .ParseIndirectObject ();if _gdcc !=nil {_aab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072\u0065\u0061d\u0020\u0078\u0072\u0065\u0066\u0020\u006fb\u006a\u0065\u0063\u0074");
return nil ,_d .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072e\u0061\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062j\u0065\u0063\u0074");};_aab .Log .Trace ("\u0058R\u0065f\u0053\u0074\u006d\u0020\u006fb\u006a\u0065c\u0074\u003a\u0020\u0025\u0073",_fbcaa );
_dbgb ,_dgae :=_fbcaa .(*PdfObjectStream );if !_dgae {_aab .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0058R\u0065\u0066\u0053\u0074\u006d\u0020\u0070o\u0069\u006e\u0074\u0069\u006e\u0067 \u0074\u006f\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065a\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0021");
return nil ,_d .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0070\u006f\u0069\u006e\u0074i\u006e\u0067\u0020\u0074\u006f\u0020a\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006fb\u006a\u0065\u0063\u0074");};_aebfg :=_dbgb .PdfObjectDictionary ;
_gccad ,_dgae :=_dbgb .PdfObjectDictionary .Get ("\u0053\u0069\u007a\u0065").(*PdfObjectInteger );if !_dgae {_aab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u004d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0073\u0069\u007a\u0065\u0020f\u0072\u006f\u006d\u0020\u0078\u0072\u0065f\u0020\u0073\u0074\u006d");
return nil ,_d .New ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0053\u0069\u007ae\u0020\u0066\u0072\u006f\u006d\u0020\u0078\u0072\u0065\u0066 \u0073\u0074\u006d");};if int64 (*_gccad )> 8388607{_aab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u0053\u0069\u007a\u0065\u0020\u0065x\u0063\u0065\u0065\u0064\u0065\u0064\u0020l\u0069\u006d\u0069\u0074\u002c\u0020\u006f\u0076\u0065\u0072\u00208\u0033\u0038\u0038\u0036\u0030\u0037\u0020\u0028\u0025\u0064\u0029",*_gccad );
return nil ,_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_bggg :=_dbgb .PdfObjectDictionary .Get ("\u0057");_babb ,_dgae :=_bggg .(*PdfObjectArray );if !_dgae {return nil ,_d .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0057\u0020\u0069\u006e\u0020x\u0072\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d");
};_ebaa :=_babb .Len ();if _ebaa !=3{_aab .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020\u0028\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033\u0020\u002d\u0020\u0025\u0064\u0029",_ebaa );
return nil ,_d .New ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065f\u0020s\u0074\u006d\u0020\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033");};var _abgd []int64 ;for _fgff :=0;_fgff < 3;
_fgff ++{_cbac ,_eaba :=GetInt (_babb .Get (_fgff ));if !_eaba {return nil ,_d .New ("i\u006e\u0076\u0061\u006cid\u0020w\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0074\u0079\u0070\u0065");};_abgd =append (_abgd ,int64 (*_cbac ));};_addg ,_gdcc :=DecodeStream (_dbgb );
if _gdcc !=nil {_aab .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020t\u006f \u0064e\u0063o\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u003a\u0020\u0025\u0076",_gdcc );return nil ,_gdcc ;};_fgef :=int (_abgd [0]);
_fagb :=int (_abgd [0]+_abgd [1]);_ebeb :=int (_abgd [0]+_abgd [1]+_abgd [2]);_acbc :=int (_abgd [0]+_abgd [1]+_abgd [2]);if _fgef < 0||_fagb < 0||_ebeb < 0{_aab .Log .Debug ("\u0045\u0072\u0072\u006fr\u0020\u0073\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u003c \u0030 \u0028\u0025\u0064\u002c\u0025\u0064\u002c%\u0064\u0029",_fgef ,_fagb ,_ebeb );
return nil ,_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};if _acbc ==0{_aab .Log .Debug ("\u004e\u006f\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063t\u0073\u0020\u0069\u006e\u0020\u0073t\u0072\u0065\u0061\u006d\u0020\u0028\u0064\u0065\u006c\u0074\u0061\u0062\u0020=\u003d\u0020\u0030\u0029");
return _aebfg ,nil ;};_begac :=len (_addg )/_acbc ;_cedbc :=0;_cbeef :=_dbgb .PdfObjectDictionary .Get ("\u0049\u006e\u0064e\u0078");var _eaebe []int ;if _cbeef !=nil {_aab .Log .Trace ("\u0049n\u0064\u0065\u0078\u003a\u0020\u0025b",_cbeef );_ccdgc ,_faefe :=_cbeef .(*PdfObjectArray );
if !_faefe {_aab .Log .Debug ("\u0049\u006e\u0076\u0061\u006ci\u0064\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0029");
return nil ,_d .New ("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0049\u006e\u0064e\u0078\u0020\u006f\u0062je\u0063\u0074");};if _ccdgc .Len ()%2!=0{_aab .Log .Debug ("\u0057\u0041\u0052\u004eI\u004e\u0047\u0020\u0046\u0061\u0069\u006c\u0075\u0072e\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020i\u006e\u0064\u0065\u0078\u0020n\u006f\u0074\u0020\u006d\u0075\u006c\u0074\u0069\u0070\u006c\u0065\u0020\u006f\u0066\u0020\u0032\u002e");
return nil ,_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_cedbc =0;_acbcc ,_ecfg :=_ccdgc .ToIntegerArray ();if _ecfg !=nil {_aab .Log .Debug ("\u0045\u0072\u0072\u006f\u0072 \u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0065\u0078 \u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0073\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0073\u003a\u0020\u0025\u0076",_ecfg );
return nil ,_ecfg ;};for _acbcb :=0;_acbcb < len (_acbcc );_acbcb +=2{_fcbc :=_acbcc [_acbcb ];_dgaf :=_acbcc [_acbcb +1];for _facg :=0;_facg < _dgaf ;_facg ++{_eaebe =append (_eaebe ,_fcbc +_facg );};_cedbc +=_dgaf ;};}else {for _gfdb :=0;_gfdb < int (*_gccad );
_gfdb ++{_eaebe =append (_eaebe ,_gfdb );};_cedbc =int (*_gccad );};if _begac ==_cedbc +1{_aab .Log .Debug ("\u0049n\u0063\u006f\u006d\u0070ati\u0062\u0069\u006c\u0069t\u0079\u003a\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006di\u0073\u0073\u0069\u006e\u0067\u0020\u0063\u006f\u0076\u0065\u0072\u0061\u0067\u0065\u0020\u006f\u0066\u0020\u0031\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u002d\u0020\u0061\u0070\u0070en\u0064\u0069\u006eg\u0020\u006f\u006e\u0065\u0020-\u0020M\u0061\u0079\u0020\u006c\u0065\u0061\u0064\u0020\u0074o\u0020\u0070\u0072\u006f\u0062\u006c\u0065\u006d\u0073");
_ceff :=_cedbc -1;for _ ,_dafg :=range _eaebe {if _dafg > _ceff {_ceff =_dafg ;};};_eaebe =append (_eaebe ,_ceff +1);_cedbc ++;};if _begac !=len (_eaebe ){_aab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020x\u0072\u0065\u0066 \u0073\u0074\u006d:\u0020\u006eu\u006d\u0020\u0065\u006e\u0074\u0072i\u0065s \u0021\u003d\u0020\u006c\u0065\u006e\u0028\u0069\u006e\u0064\u0069\u0063\u0065\u0073\u0029\u0020\u0028\u0025\u0064\u0020\u0021\u003d\u0020\u0025\u0064\u0029",_begac ,len (_eaebe ));
return nil ,_d .New ("\u0078\u0072ef\u0020\u0073\u0074m\u0020\u006e\u0075\u006d en\u0074ri\u0065\u0073\u0020\u0021\u003d\u0020\u006cen\u0028\u0069\u006e\u0064\u0069\u0063\u0065s\u0029");};_aab .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074s\u0020\u0063\u006f\u0075\u006e\u0074\u0020\u0025\u0064",_cedbc );
_aab .Log .Trace ("\u0049\u006e\u0064i\u0063\u0065\u0073\u003a\u0020\u0025\u0020\u0064",_eaebe );_caad :=func (_egffa []byte )int64 {var _bbfb int64 ;for _bcee :=0;_bcee < len (_egffa );_bcee ++{_bbfb +=int64 (_egffa [_bcee ])*(1<<uint (8*(len (_egffa )-_bcee -1)));
};return _bbfb ;};_aab .Log .Trace ("\u0044e\u0063\u006f\u0064\u0065d\u0020\u0073\u0074\u0072\u0065a\u006d \u006ce\u006e\u0067\u0074\u0068\u003a\u0020\u0025d",len (_addg ));_agce :=0;for _egdgde :=0;_egdgde < len (_addg );_egdgde +=_acbc {_dacc :=_dacgb (len (_addg ),_egdgde ,_egdgde +_fgef );
if _dacc !=nil {_aab .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_dacc );return nil ,_dacc ;};_decec :=_addg [_egdgde :_egdgde +_fgef ];_dacc =_dacgb (len (_addg ),_egdgde +_fgef ,_egdgde +_fagb );
if _dacc !=nil {_aab .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_dacc );return nil ,_dacc ;};_ffecd :=_addg [_egdgde +_fgef :_egdgde +_fagb ];_dacc =_dacgb (len (_addg ),_egdgde +_fagb ,_egdgde +_ebeb );
if _dacc !=nil {_aab .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_dacc );return nil ,_dacc ;};_bdgae :=_addg [_egdgde +_fagb :_egdgde +_ebeb ];_bfeb :=_caad (_decec );
_fggc :=_caad (_ffecd );_eaca :=_caad (_bdgae );if _abgd [0]==0{_bfeb =1;};if _agce >=len (_eaebe ){_aab .Log .Debug ("X\u0052\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u002d\u0020\u0054\u0072\u0079\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0061\u0063\u0063e\u0073s\u0020\u0069\u006e\u0064e\u0078\u0020o\u0075\u0074\u0020\u006f\u0066\u0020\u0062\u006f\u0075\u006e\u0064\u0073\u0020\u002d\u0020\u0062\u0072\u0065\u0061\u006b\u0069\u006e\u0067");
break ;};_gbfbd :=_eaebe [_agce ];_agce ++;_aab .Log .Trace ("%\u0064\u002e\u0020\u0070\u0031\u003a\u0020\u0025\u0020\u0078",_gbfbd ,_decec );_aab .Log .Trace ("%\u0064\u002e\u0020\u0070\u0032\u003a\u0020\u0025\u0020\u0078",_gbfbd ,_ffecd );_aab .Log .Trace ("%\u0064\u002e\u0020\u0070\u0033\u003a\u0020\u0025\u0020\u0078",_gbfbd ,_bdgae );
_aab .Log .Trace ("\u0025d\u002e \u0078\u0072\u0065\u0066\u003a \u0025\u0064 \u0025\u0064\u0020\u0025\u0064",_gbfbd ,_bfeb ,_fggc ,_eaca );if _bfeb ==0{_aab .Log .Trace ("-\u0020\u0046\u0072\u0065\u0065\u0020o\u0062\u006a\u0065\u0063\u0074\u0020-\u0020\u0063\u0061\u006e\u0020\u0070\u0072o\u0062\u0061\u0062\u006c\u0079\u0020\u0069\u0067\u006e\u006fr\u0065");
}else if _bfeb ==1{_aab .Log .Trace ("\u002d\u0020I\u006e\u0020\u0075\u0073e\u0020\u002d \u0075\u006e\u0063\u006f\u006d\u0070\u0072\u0065s\u0073\u0065\u0064\u0020\u0076\u0069\u0061\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0062",_ffecd );if _fggc ==_cegc {_aab .Log .Debug ("\u0055\u0070d\u0061\u0074\u0069\u006e\u0067\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0058\u0052\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0064",_gbfbd ,_dbgb .ObjectNumber );
_gbfbd =int (_dbgb .ObjectNumber );};if _fbge ,_geeag :=_aefb ._feabg .ObjectMap [_gbfbd ];!_geeag ||int (_eaca )> _fbge .Generation {_adbec :=XrefObject {ObjectNumber :_gbfbd ,XType :XrefTypeTableEntry ,Offset :_fggc ,Generation :int (_eaca )};_aefb ._feabg .ObjectMap [_gbfbd ]=_adbec ;
};}else if _bfeb ==2{_aab .Log .Trace ("\u002d\u0020\u0049\u006e \u0075\u0073\u0065\u0020\u002d\u0020\u0063\u006f\u006d\u0070r\u0065s\u0073\u0065\u0064\u0020\u006f\u0062\u006ae\u0063\u0074");if _ ,_gafg :=_aefb ._feabg .ObjectMap [_gbfbd ];!_gafg {_eeab :=XrefObject {ObjectNumber :_gbfbd ,XType :XrefTypeObjectStream ,OsObjNumber :int (_fggc ),OsObjIndex :int (_eaca )};
_aefb ._feabg .ObjectMap [_gbfbd ]=_eeab ;_aab .Log .Trace ("\u0065\u006e\u0074\u0072\u0079\u003a\u0020\u0025\u002b\u0076",_eeab );};}else {_aab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052:\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0056\u0041L\u0049\u0044\u0020\u0054\u0059\u0050\u0045\u0020\u0058\u0072\u0065\u0066\u0053\u0074\u006d\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u003f\u002d\u002d\u002d\u002d\u002d\u002d-");
continue ;};};if _aefb ._dbff ==nil {_gaga :=XrefTypeObjectStream ;_aefb ._dbff =&_gaga ;};return _aebfg ,nil ;};var _gbefc =_ed .MustCompile ("\u005b\\\u0072\u005c\u006e\u005d\u005c\u0073\u002a\u0028\u0078\u0072\u0065f\u0029\u005c\u0073\u002a\u005b\u005c\u0072\u005c\u006e\u005d");


// GetIndirect returns the *PdfIndirectObject represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetIndirect (obj PdfObject )(_gcced *PdfIndirectObject ,_fbfg bool ){obj =ResolveReference (obj );_gcced ,_fbfg =obj .(*PdfIndirectObject );return _gcced ,_fbfg ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_fbec *RunLengthEncoder )MakeDecodeParams ()PdfObject {return nil };

// MakeArrayFromIntegers creates an PdfObjectArray from a slice of ints, where each array element is
// an PdfObjectInteger.
func MakeArrayFromIntegers (vals []int )*PdfObjectArray {_gfdf :=MakeArray ();for _ ,_cecd :=range vals {_gfdf .Append (MakeInteger (int64 (_cecd )));};return _gfdf ;};

// UpdateParams updates the parameter values of the encoder.
func (_dfga *DCTEncoder )UpdateParams (params *PdfObjectDictionary ){_dde ,_ffcc :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _ffcc ==nil {_dfga .ColorComponents =int (_dde );};
_dgecg ,_ffcc :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _ffcc ==nil {_dfga .BitsPerComponent =int (_dgecg );};_fded ,_ffcc :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));
if _ffcc ==nil {_dfga .Width =int (_fded );};_ebgbd ,_ffcc :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _ffcc ==nil {_dfga .Height =int (_ebgbd );};_faaa ,_ffcc :=GetNumberAsInt64 (params .Get ("\u0051u\u0061\u006c\u0069\u0074\u0079"));
if _ffcc ==nil {_dfga .Quality =int (_faaa );};};

// UpdateParams updates the parameter values of the encoder.
func (_abd *RunLengthEncoder )UpdateParams (params *PdfObjectDictionary ){};

// WriteString outputs the object as it is to be written to file.
func (_ggcec *PdfObjectInteger )WriteString ()string {return _b .FormatInt (int64 (*_ggcec ),10)};

// String returns the PDF version as a string. Implements interface fmt.Stringer.
func (_bcbg Version )String ()string {return _ca .Sprintf ("\u00250\u0064\u002e\u0025\u0030\u0064",_bcbg .Major ,_bcbg .Minor );};

// WriteString outputs the object as it is to be written to file.
func (_gacf *PdfObjectNull )WriteString ()string {return "\u006e\u0075\u006c\u006c"};

// IsFloatDigit checks if a character can be a part of a float number string.
func IsFloatDigit (c byte )bool {return ('0'<=c &&c <='9')||c =='.'};

// String returns a descriptive information string about the encryption method used.
func (_cbgb *PdfCrypt )String ()string {if _cbgb ==nil {return "";};_bfbd :=_cbgb ._dab .Filter +"\u0020\u002d\u0020";if _cbgb ._dab .V ==0{_bfbd +="\u0055\u006e\u0064\u006fcu\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0061\u006c\u0067\u006f\u0072\u0069\u0074h\u006d";
}else if _cbgb ._dab .V ==1{_bfbd +="\u0052\u0043\u0034:\u0020\u0034\u0030\u0020\u0062\u0069\u0074\u0073";}else if _cbgb ._dab .V ==2{_bfbd +=_ca .Sprintf ("\u0052\u0043\u0034:\u0020\u0025\u0064\u0020\u0062\u0069\u0074\u0073",_cbgb ._dab .Length );}else if _cbgb ._dab .V ==3{_bfbd +="U\u006e\u0070\u0075\u0062li\u0073h\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d";
}else if _cbgb ._dab .V >=4{_bfbd +=_ca .Sprintf ("\u0053\u0074r\u0065\u0061\u006d\u0020f\u0069\u006ct\u0065\u0072\u003a\u0020\u0025\u0073\u0020\u002d \u0053\u0074\u0072\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0074\u0065r\u003a\u0020\u0025\u0073",_cbgb ._bdb ,_cbgb ._aeac );
_bfbd +="\u003b\u0020C\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0073\u003a";for _ga ,_ffd :=range _cbgb ._egg {_bfbd +=_ca .Sprintf ("\u0020\u002d\u0020\u0025\u0073\u003a\u0020\u0025\u0073 \u0028\u0025\u0064\u0029",_ga ,_ffd .Name (),_ffd .KeyLength ());
};};_dea :=_cbgb .GetAccessPermissions ();_bfbd +=_ca .Sprintf ("\u0020\u002d\u0020\u0025\u0023\u0076",_dea );return _bfbd ;};

// PdfVersion returns version of the PDF file.
func (_cggga *PdfParser )PdfVersion ()Version {return _cggga ._cbgab };

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_agad *RunLengthEncoder )MakeStreamDict ()*PdfObjectDictionary {_gcac :=MakeDict ();_gcac .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_agad .GetFilterName ()));return _gcac ;};func _cad (_eac PdfObject )(int64 ,int64 ,error ){if _aaa ,_abe :=_eac .(*PdfIndirectObject );
_abe {return _aaa .ObjectNumber ,_aaa .GenerationNumber ,nil ;};if _cae ,_fd :=_eac .(*PdfObjectStream );_fd {return _cae .ObjectNumber ,_cae .GenerationNumber ,nil ;};return 0,0,_d .New ("\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u002f\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062je\u0063\u0074");
};

// DecodeStream implements ASCII85 stream decoding.
func (_gcacg *ASCII85Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _gcacg .DecodeBytes (streamObj .Stream );};

// DecodeStream decodes a DCT encoded stream and returns the result as a
// slice of bytes.
func (_cebg *DCTEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _cebg .DecodeBytes (streamObj .Stream );};

// DecodeBytes decodes a slice of ASCII encoded bytes and returns the result.
func (_beef *ASCIIHexEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_ebdd :=_abb .NewReader (encoded );var _bccd []byte ;for {_cbga ,_ccc :=_ebdd .ReadByte ();if _ccc !=nil {return nil ,_ccc ;};if _cbga =='>'{break ;};if IsWhiteSpace (_cbga ){continue ;
};if (_cbga >='a'&&_cbga <='f')||(_cbga >='A'&&_cbga <='F')||(_cbga >='0'&&_cbga <='9'){_bccd =append (_bccd ,_cbga );}else {_aab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0061\u0073\u0063\u0069\u0069 \u0068\u0065\u0078\u0020\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072 \u0028\u0025\u0063\u0029",_cbga );
return nil ,_ca .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0061\u0073\u0063\u0069\u0069\u0020\u0068e\u0078 \u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u0020\u0028\u0025\u0063\u0029",_cbga );};};if len (_bccd )%2==1{_bccd =append (_bccd ,'0');
};_aab .Log .Trace ("\u0049\u006e\u0062\u006f\u0075\u006e\u0064\u0020\u0025\u0073",_bccd );_aaccd :=make ([]byte ,_g .DecodedLen (len (_bccd )));_ ,_bfgf :=_g .Decode (_aaccd ,_bccd );if _bfgf !=nil {return nil ,_bfgf ;};return _aaccd ,nil ;};func _fggaa (_adge *PdfObjectStream )(*MultiEncoder ,error ){_eccf :=NewMultiEncoder ();
_becd :=_adge .PdfObjectDictionary ;if _becd ==nil {return _eccf ,nil ;};var _dgbf *PdfObjectDictionary ;var _gbbd []PdfObject ;_fbfd :=_becd .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _fbfd !=nil {_fege ,_afaa :=_fbfd .(*PdfObjectDictionary );
if _afaa {_dgbf =_fege ;};_aecd ,_faff :=_fbfd .(*PdfObjectArray );if _faff {for _ ,_fab :=range _aecd .Elements (){_fab =TraceToDirectObject (_fab );if _cgaa ,_edab :=_fab .(*PdfObjectDictionary );_edab {_gbbd =append (_gbbd ,_cgaa );}else {_gbbd =append (_gbbd ,MakeDict ());
};};};};_fbfd =_becd .Get ("\u0046\u0069\u006c\u0074\u0065\u0072");if _fbfd ==nil {return nil ,_ca .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u006d\u0069s\u0073\u0069\u006e\u0067");};_aded ,_gdga :=_fbfd .(*PdfObjectArray );if !_gdga {return nil ,_ca .Errorf ("m\u0075\u006c\u0074\u0069\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0063\u0061\u006e\u0020\u006f\u006el\u0079\u0020\u0062\u0065\u0020\u006d\u0061\u0064\u0065\u0020fr\u006f\u006d\u0020a\u0072r\u0061\u0079");
};for _egecd ,_fefb :=range _aded .Elements (){_cccd ,_cbgc :=_fefb .(*PdfObjectName );if !_cbgc {return nil ,_ca .Errorf ("\u006d\u0075l\u0074\u0069\u0020\u0066i\u006c\u0074e\u0072\u0020\u0061\u0072\u0072\u0061\u0079\u0020e\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u006e\u006f\u0074\u0020\u0061 \u006e\u0061\u006d\u0065");
};var _eeeb PdfObject ;if _dgbf !=nil {_eeeb =_dgbf ;}else {if len (_gbbd )> 0{if _egecd >=len (_gbbd ){return nil ,_ca .Errorf ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0073\u0020\u0069\u006e\u0020d\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006d\u0073\u0020a\u0072\u0072\u0061\u0079");
};_eeeb =_gbbd [_egecd ];};};var _bgfd *PdfObjectDictionary ;if _gdbff ,_cecc :=_eeeb .(*PdfObjectDictionary );_cecc {_bgfd =_gdbff ;};_aab .Log .Trace ("\u004e\u0065\u0078t \u006e\u0061\u006d\u0065\u003a\u0020\u0025\u0073\u002c \u0064p\u003a \u0025v\u002c\u0020\u0064\u0050\u0061\u0072\u0061\u006d\u0073\u003a\u0020\u0025\u0076",*_cccd ,_eeeb ,_bgfd );
if *_cccd ==StreamEncodingFilterNameFlate {_dgef ,_bgdf :=_aba (_adge ,_bgfd );if _bgdf !=nil {return nil ,_bgdf ;};_eccf .AddEncoder (_dgef );}else if *_cccd ==StreamEncodingFilterNameLZW {_gcce ,_ffgc :=_fegd (_adge ,_bgfd );if _ffgc !=nil {return nil ,_ffgc ;
};_eccf .AddEncoder (_gcce );}else if *_cccd ==StreamEncodingFilterNameASCIIHex {_gaecf :=NewASCIIHexEncoder ();_eccf .AddEncoder (_gaecf );}else if *_cccd ==StreamEncodingFilterNameASCII85 {_agg :=NewASCII85Encoder ();_eccf .AddEncoder (_agg );}else if *_cccd ==StreamEncodingFilterNameDCT {_ffff ,_ffccg :=_ebdge (_adge ,_eccf );
if _ffccg !=nil {return nil ,_ffccg ;};_eccf .AddEncoder (_ffff );_aab .Log .Trace ("A\u0064d\u0065\u0064\u0020\u0044\u0043\u0054\u0020\u0065n\u0063\u006f\u0064\u0065r.\u002e\u002e");_aab .Log .Trace ("\u004du\u006ct\u0069\u0020\u0065\u006e\u0063o\u0064\u0065r\u003a\u0020\u0025\u0023\u0076",_eccf );
}else if *_cccd ==StreamEncodingFilterNameCCITTFax {_gfbe ,_dace :=_dggg (_adge ,_bgfd );if _dace !=nil {return nil ,_dace ;};_eccf .AddEncoder (_gfbe );}else {_aab .Log .Error ("U\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0066\u0069l\u0074\u0065\u0072\u0020\u0025\u0073",*_cccd );
return nil ,_ca .Errorf ("\u0069\u006eva\u006c\u0069\u0064 \u0066\u0069\u006c\u0074er \u0069n \u006d\u0075\u006c\u0074\u0069\u0020\u0066il\u0074\u0065\u0072\u0020\u0061\u0072\u0072a\u0079");};};return _eccf ,nil ;};func (_cbg *PdfCrypt )newEncryptDict ()*PdfObjectDictionary {_dda :=MakeDict ();
_dda .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName ("\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"));_dda .Set ("\u0056",MakeInteger (int64 (_cbg ._dab .V )));_dda .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_cbg ._dab .Length )));
return _dda ;};

// ASCII85Encoder implements ASCII85 encoder/decoder.
type ASCII85Encoder struct{};

// Encode encodes previously prepare jbig2 document and stores it as the byte slice.
func (_aacg *JBIG2Encoder )Encode ()(_dbad []byte ,_gccd error ){const _agfe ="J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0045\u006eco\u0064\u0065";if _aacg ._faeb ==nil {return nil ,_ba .Errorf (_agfe ,"\u0064\u006f\u0063u\u006d\u0065\u006e\u0074 \u0069\u006e\u0070\u0075\u0074\u0020\u0064a\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006e\u0065\u0064");
};_aacg ._faeb .FullHeaders =_aacg .DefaultPageSettings .FileMode ;_dbad ,_gccd =_aacg ._faeb .Encode ();if _gccd !=nil {return nil ,_ba .Wrap (_gccd ,_agfe ,"");};return _dbad ,nil ;};

// SetFileOffset sets the file to an offset position and resets buffer.
func (_faffg *PdfParser )SetFileOffset (offset int64 ){if offset < 0{offset =0;};_faffg ._fdeg .Seek (offset ,_bf .SeekStart );_faffg ._aaae =_gd .NewReader (_faffg ._fdeg );};func (_bfbg *PdfParser )traceStreamLength (_aebg PdfObject )(PdfObject ,error ){_caee ,_gcab :=_aebg .(*PdfObjectReference );
if _gcab {_gace ,_gbdg :=_bfbg ._cggec [_caee .ObjectNumber ];if _gbdg &&_gace {_aab .Log .Debug ("\u0053t\u0072\u0065a\u006d\u0020\u004c\u0065n\u0067\u0074\u0068 \u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065 u\u006e\u0072\u0065s\u006f\u006cv\u0065\u0064\u0020\u0028\u0069\u006cl\u0065\u0067a\u006c\u0029");
return nil ,_d .New ("\u0069\u006c\u006c\u0065ga\u006c\u0020\u0072\u0065\u0063\u0075\u0072\u0073\u0069\u0076\u0065\u0020\u006c\u006fo\u0070");};_bfbg ._cggec [_caee .ObjectNumber ]=true ;};_dfdf ,_cdff :=_bfbg .Resolve (_aebg );if _cdff !=nil {return nil ,_cdff ;
};_aab .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_dfdf );if _gcab {_bfbg ._cggec [_caee .ObjectNumber ]=false ;};return _dfdf ,nil ;};func _dggg (_ccbf *PdfObjectStream ,_gegec *PdfObjectDictionary )(*CCITTFaxEncoder ,error ){_egcc :=NewCCITTFaxEncoder ();
_faec :=_ccbf .PdfObjectDictionary ;if _faec ==nil {return _egcc ,nil ;};if _gegec ==nil {_eaebg :=TraceToDirectObject (_faec .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));if _eaebg !=nil {switch _afg :=_eaebg .(type ){case *PdfObjectDictionary :_gegec =_afg ;
case *PdfObjectArray :if _afg .Len ()==1{if _adac ,_afga :=GetDict (_afg .Get (0));_afga {_gegec =_adac ;};};default:_aab .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_eaebg );
return nil ,_d .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _gegec ==nil {_aab .Log .Error ("\u0044\u0065c\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064 %\u0023\u0076",_eaebg );
return nil ,_d .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _ffcf ,_caae :=GetNumberAsInt64 (_gegec .Get ("\u004b"));_caae ==nil {_egcc .K =int (_ffcf );};if _egaae ,_fdc :=GetNumberAsInt64 (_gegec .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));
_fdc ==nil {_egcc .Columns =int (_egaae );}else {_egcc .Columns =1728;};if _ffbcf ,_cgdab :=GetNumberAsInt64 (_gegec .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_cgdab ==nil {_egcc .BlackIs1 =_ffbcf > 0;}else {if _cdg ,_bbbc :=GetBoolVal (_gegec .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));
_bbbc {_egcc .BlackIs1 =_cdg ;}else {if _acbe ,_ecc :=GetArray (_gegec .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));_ecc {_cfab ,_dfgb :=_acbe .ToIntegerArray ();if _dfgb ==nil {_egcc .BlackIs1 =_cfab [0]==1&&_cfab [1]==0;};};};};if _debb ,_bdff :=GetNumberAsInt64 (_gegec .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));
_bdff ==nil {_egcc .EncodedByteAlign =_debb > 0;}else {if _egad ,_gfgb :=GetBoolVal (_gegec .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_gfgb {_egcc .EncodedByteAlign =_egad ;};};if _adab ,_gcdf :=GetNumberAsInt64 (_gegec .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));
_gcdf ==nil {_egcc .EndOfLine =_adab > 0;}else {if _bagf ,_cacf :=GetBoolVal (_gegec .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_cacf {_egcc .EndOfLine =_bagf ;};};if _dfde ,_aeag :=GetNumberAsInt64 (_gegec .Get ("\u0052\u006f\u0077\u0073"));
_aeag ==nil {_egcc .Rows =int (_dfde );};_egcc .EndOfBlock =true ;if _bgde ,_ecbe :=GetNumberAsInt64 (_gegec .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_ecbe ==nil {_egcc .EndOfBlock =_bgde > 0;}else {if _bcdd ,_cfc :=GetBoolVal (_gegec .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));
_cfc {_egcc .EndOfBlock =_bcdd ;};};if _bfgd ,_egbb :=GetNumberAsInt64 (_gegec .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));_egbb !=nil {_egcc .DamagedRowsBeforeError =int (_bfgd );
};_aab .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_gegec .String ());return _egcc ,nil ;};const (StreamEncodingFilterNameFlate ="F\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065";
StreamEncodingFilterNameLZW ="\u004cZ\u0057\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameDCT ="\u0044C\u0054\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameRunLength ="\u0052u\u006eL\u0065\u006e\u0067\u0074\u0068\u0044\u0065\u0063\u006f\u0064\u0065";
StreamEncodingFilterNameASCIIHex ="\u0041\u0053\u0043\u0049\u0049\u0048\u0065\u0078\u0044e\u0063\u006f\u0064\u0065";StreamEncodingFilterNameASCII85 ="\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameCCITTFax ="\u0043\u0043\u0049\u0054\u0054\u0046\u0061\u0078\u0044e\u0063\u006f\u0064\u0065";
StreamEncodingFilterNameJBIG2 ="J\u0042\u0049\u0047\u0032\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameJPX ="\u004aP\u0058\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameRaw ="\u0052\u0061\u0077";);func _ffcg (_ffegd ,_eece PdfObject ,_dabeg int )bool {if _dabeg > _ebaaa {_aab .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_ebaaa );
return false ;};if _ffegd ==nil &&_eece ==nil {return true ;}else if _ffegd ==nil ||_eece ==nil {return false ;};if _a .TypeOf (_ffegd )!=_a .TypeOf (_eece ){return false ;};switch _bgfce :=_ffegd .(type ){case *PdfObjectNull ,*PdfObjectReference :return true ;
case *PdfObjectName :return *_bgfce ==*(_eece .(*PdfObjectName ));case *PdfObjectString :return *_bgfce ==*(_eece .(*PdfObjectString ));case *PdfObjectInteger :return *_bgfce ==*(_eece .(*PdfObjectInteger ));case *PdfObjectBool :return *_bgfce ==*(_eece .(*PdfObjectBool ));
case *PdfObjectFloat :return *_bgfce ==*(_eece .(*PdfObjectFloat ));case *PdfIndirectObject :return _ffcg (TraceToDirectObject (_ffegd ),TraceToDirectObject (_eece ),_dabeg +1);case *PdfObjectArray :_dadg :=_eece .(*PdfObjectArray );if len ((*_bgfce )._beea )!=len ((*_dadg )._beea ){return false ;
};for _aebc ,_ffda :=range (*_bgfce )._beea {if !_ffcg (_ffda ,(*_dadg )._beea [_aebc ],_dabeg +1){return false ;};};return true ;case *PdfObjectDictionary :_cdgg :=_eece .(*PdfObjectDictionary );_acaa ,_feaf :=(*_bgfce )._abegb ,(*_cdgg )._abegb ;if len (_acaa )!=len (_feaf ){return false ;
};for _dbgda ,_afbbf :=range _acaa {_dagc ,_aeaf :=_feaf [_dbgda ];if !_aeaf ||!_ffcg (_afbbf ,_dagc ,_dabeg +1){return false ;};};return true ;case *PdfObjectStream :_fggbb :=_eece .(*PdfObjectStream );return _ffcg ((*_bgfce ).PdfObjectDictionary ,(*_fggbb ).PdfObjectDictionary ,_dabeg +1);
default:_aab .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",_ffegd );
};return false ;};

// ParseDict reads and parses a PDF dictionary object enclosed with '<<' and '>>'
func (_gffgf *PdfParser )ParseDict ()(*PdfObjectDictionary ,error ){_aab .Log .Trace ("\u0052\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020D\u0069\u0063\u0074\u0021");_abgb :=MakeDict ();_abgb ._fbaab =_gffgf ;_dafc ,_ :=_gffgf ._aaae .ReadByte ();
if _dafc !='<'{return nil ,_d .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");};_dafc ,_ =_gffgf ._aaae .ReadByte ();if _dafc !='<'{return nil ,_d .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");
};for {_gffgf .skipSpaces ();_gffgf .skipComments ();_cgac ,_adc :=_gffgf ._aaae .Peek (2);if _adc !=nil {return nil ,_adc ;};_aab .Log .Trace ("D\u0069c\u0074\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_cgac ),string (_cgac ));
if (_cgac [0]=='>')&&(_cgac [1]=='>'){_aab .Log .Trace ("\u0045\u004f\u0046\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");_gffgf ._aaae .ReadByte ();_gffgf ._aaae .ReadByte ();break ;};_aab .Log .Trace ("\u0050a\u0072s\u0065\u0020\u0074\u0068\u0065\u0020\u006e\u0061\u006d\u0065\u0021");
_eceg ,_adc :=_gffgf .parseName ();_aab .Log .Trace ("\u004be\u0079\u003a\u0020\u0025\u0073",_eceg );if _adc !=nil {_aab .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0052e\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006ea\u006d\u0065\u0020e\u0072r\u0020\u0025\u0073",_adc );
return nil ,_adc ;};if len (_eceg )> 4&&_eceg [len (_eceg )-4:]=="\u006e\u0075\u006c\u006c"{_bfbe :=_eceg [0:len (_eceg )-4];_aab .Log .Debug ("\u0054\u0061\u006b\u0069n\u0067\u0020\u0063\u0061\u0072\u0065\u0020\u006f\u0066\u0020n\u0075l\u006c\u0020\u0062\u0075\u0067\u0020\u0028%\u0073\u0029",_eceg );
_aab .Log .Debug ("\u004e\u0065\u0077\u0020ke\u0079\u0020\u0022\u0025\u0073\u0022\u0020\u003d\u0020\u006e\u0075\u006c\u006c",_bfbe );_gffgf .skipSpaces ();_aefeb ,_ :=_gffgf ._aaae .Peek (1);if _aefeb [0]=='/'{_abgb .Set (_bfbe ,MakeNull ());continue ;
};};_gffgf .skipSpaces ();_egge ,_adc :=_gffgf .parseObject ();if _adc !=nil {return nil ,_adc ;};_abgb .Set (_eceg ,_egge );if _aab .Log .IsLogLevel (_aab .LogLevelTrace ){_aab .Log .Trace ("\u0064\u0069\u0063\u0074\u005b\u0025\u0073\u005d\u0020\u003d\u0020\u0025\u0073",_eceg ,_egge .String ());
};};_aab .Log .Trace ("\u0072\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020\u0044\u0069\u0063\u0074\u0021");return _abgb ,nil ;};

// Validate validates the page settings for the JBIG2 encoder.
func (_bbbb JBIG2EncoderSettings )Validate ()error {const _cggg ="\u0076a\u006ci\u0064\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065\u0072";if _bbbb .Threshold < 0||_bbbb .Threshold > 1.0{return _ba .Errorf (_cggg ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074\u0068\u0072\u0065\u0073\u0068\u006f\u006c\u0064\u0020\u0076a\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0076\u0027 \u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0069\u006e\u0020\u0072\u0061n\u0067\u0065\u0020\u005b\u0030\u002e0\u002c\u0020\u0031.\u0030\u005d",_bbbb .Threshold );
};if _bbbb .ResolutionX < 0{return _ba .Errorf (_cggg ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0078\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_bbbb .ResolutionX );
};if _bbbb .ResolutionY < 0{return _ba .Errorf (_cggg ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0079\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_bbbb .ResolutionY );
};if _bbbb .DefaultPixelValue !=0&&_bbbb .DefaultPixelValue !=1{return _ba .Errorf (_cggg ,"de\u0066\u0061u\u006c\u0074\u0020\u0070\u0069\u0078\u0065\u006c\u0020v\u0061\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0066o\u0072 \u0074\u0068\u0065\u0020\u0062\u0069\u0074\u003a \u007b0\u002c\u0031}",_bbbb .DefaultPixelValue );
};if _bbbb .Compression !=JB2Generic {return _ba .Errorf (_cggg ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065d\u0020\u0063\u006fm\u0070\u0072\u0065\u0073s\u0069\u006f\u006e\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
};return nil ;};

// GetParser returns the parser for lazy-loading or compare references.
func (_eggaa *PdfObjectReference )GetParser ()*PdfParser {return _eggaa ._acge };var _dddd =_ed .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064\u002b)\u005c\u0073\u002a\u0024");

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_abcd *ASCIIHexEncoder )MakeStreamDict ()*PdfObjectDictionary {_cabe :=MakeDict ();_cabe .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_abcd .GetFilterName ()));return _cabe ;};func (_gbfde *PdfParser )parseNumber ()(PdfObject ,error ){return ParseNumber (_gbfde ._aaae )};
func (_eeafe *PdfParser )parseXrefTable ()(*PdfObjectDictionary ,error ){var _geab *PdfObjectDictionary ;_gbbf ,_bfde :=_eeafe .readTextLine ();if _bfde !=nil {return nil ,_bfde ;};if _eeafe ._ffeg &&_gg .Count (_gg .TrimPrefix (_gbbf ,"\u0078\u0072\u0065\u0066"),"\u0020")> 0{_eeafe ._accf ._eeb =true ;
};_aab .Log .Trace ("\u0078\u0072\u0065\u0066 f\u0069\u0072\u0073\u0074\u0020\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_gbbf );_gdfg :=-1;_gccc :=0;_dbgfd :=false ;_eedf :="";for {_eeafe .skipSpaces ();_ ,_abdgc :=_eeafe ._aaae .Peek (1);if _abdgc !=nil {return nil ,_abdgc ;
};_gbbf ,_abdgc =_eeafe .readTextLine ();if _abdgc !=nil {return nil ,_abdgc ;};_fbff :=_dddd .FindStringSubmatch (_gbbf );if len (_fbff )==0{_aagga :=len (_eedf )> 0;_eedf +=_gbbf +"\u000a";if _aagga {_fbff =_dddd .FindStringSubmatch (_eedf );};};if len (_fbff )==3{if _eeafe ._ffeg &&!_eeafe ._accf ._deeb {var (_ddba bool ;
_eabf int ;);for _ ,_fffg :=range _gbbf {if _ea .IsDigit (_fffg ){if _ddba {break ;};continue ;};if !_ddba {_ddba =true ;};_eabf ++;};if _eabf > 1{_eeafe ._accf ._deeb =true ;};};_addb ,_ :=_b .Atoi (_fbff [1]);_cffac ,_ :=_b .Atoi (_fbff [2]);_gdfg =_addb ;
_gccc =_cffac ;_dbgfd =true ;_eedf ="";_aab .Log .Trace ("\u0078r\u0065\u0066 \u0073\u0075\u0062s\u0065\u0063\u0074\u0069\u006f\u006e\u003a \u0066\u0069\u0072\u0073\u0074\u0020o\u0062\u006a\u0065\u0063\u0074\u003a\u0020\u0025\u0064\u0020\u006fb\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_gdfg ,_gccc );
continue ;};_aaeg :=_cfd .FindStringSubmatch (_gbbf );if len (_aaeg )==4{if !_dbgfd {_aab .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0058r\u0065\u0066\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u006fr\u006da\u0074\u0021\u000a");return nil ,_d .New ("\u0078\u0072\u0065\u0066 i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072\u006d\u0061\u0074");
};_eabff ,_ :=_b .ParseInt (_aaeg [1],10,64);_cecbe ,_ :=_b .Atoi (_aaeg [2]);_bffg :=_aaeg [3];_eedf ="";if _gg .ToLower (_bffg )=="\u006e"&&_eabff > 1{_feedb ,_cedb :=_eeafe ._feabg .ObjectMap [_gdfg ];if !_cedb ||_cecbe > _feedb .Generation {_caea :=XrefObject {ObjectNumber :_gdfg ,XType :XrefTypeTableEntry ,Offset :_eabff ,Generation :_cecbe };
_eeafe ._feabg .ObjectMap [_gdfg ]=_caea ;};};_gdfg ++;continue ;};if (len (_gbbf )> 6)&&(_gbbf [:7]=="\u0074r\u0061\u0069\u006c\u0065\u0072"){_aab .Log .Trace ("\u0046o\u0075n\u0064\u0020\u0074\u0072\u0061i\u006c\u0065r\u0020\u002d\u0020\u0025\u0073",_gbbf );
if len (_gbbf )> 9{_ddgfa :=_eeafe .GetFileOffset ();_eeafe .SetFileOffset (_ddgfa -int64 (len (_gbbf ))+7);};_eeafe .skipSpaces ();_eeafe .skipComments ();_aab .Log .Trace ("R\u0065\u0061\u0064\u0069ng\u0020t\u0072\u0061\u0069\u006c\u0065r\u0020\u0064\u0069\u0063\u0074\u0021");
_aab .Log .Trace ("\u0070\u0065\u0065\u006b\u003a\u0020\u0022\u0025\u0073\u0022",_gbbf );_geab ,_abdgc =_eeafe .ParseDict ();_aab .Log .Trace ("\u0045O\u0046\u0020\u0072\u0065a\u0064\u0069\u006e\u0067\u0020t\u0072a\u0069l\u0065\u0072\u0020\u0064\u0069\u0063\u0074!");
if _abdgc !=nil {_aab .Log .Debug ("\u0045\u0072\u0072o\u0072\u0020\u0070\u0061r\u0073\u0069\u006e\u0067\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u0064\u0069\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_abdgc );return nil ,_abdgc ;};break ;};if _gbbf =="\u0025\u0025\u0045O\u0046"{_aab .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006e\u0064 \u006f\u0066\u0020\u0066\u0069\u006c\u0065 -\u0020\u0074\u0072\u0061i\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066ou\u006e\u0064 \u002d\u0020\u0065\u0072\u0072\u006f\u0072\u0021");
return nil ,_d .New ("\u0065\u006e\u0064 \u006f\u0066\u0020\u0066i\u006c\u0065\u0020\u002d\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};_aab .Log .Trace ("\u0078\u0072\u0065\u0066\u0020\u006d\u006f\u0072\u0065 \u003a\u0020\u0025\u0073",_gbbf );
};_aab .Log .Trace ("\u0045\u004f\u0046 p\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0021");if _eeafe ._dbff ==nil {_cddb :=XrefTypeTableEntry ;_eeafe ._dbff =&_cddb ;};return _geab ,nil ;};var _acege =_ed .MustCompile ("\u005e\\\u0073\u002a\u005b\u002d]\u002a\u0028\u005c\u0064\u002b)\u005cs\u002b(\u005c\u0064\u002b\u0029\u005c\u0073\u002bR");
func (_cgb *PdfCrypt )isDecrypted (_fff PdfObject )bool {_ ,_dbd :=_cgb ._ffb [_fff ];if _dbd {_aab .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0064\u0065\u0063\u0072y\u0070\u0074\u0065\u0064");return true ;};switch _geg :=_fff .(type ){case *PdfObjectStream :if _cgb ._fca .R !=5{if _cge ,_dgd :=_geg .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );
_dgd &&*_cge =="\u0058\u0052\u0065\u0066"{return true ;};};case *PdfIndirectObject :if _ ,_dbd =_cgb ._df [int (_geg .ObjectNumber )];_dbd {return true ;};switch _def :=_geg .PdfObject .(type ){case *PdfObjectDictionary :_ggg :=true ;for _ ,_gfg :=range _fef {if _def .Get (_gfg )==nil {_ggg =false ;
break ;};};if _ggg {return true ;};};};_aab .Log .Trace ("\u004e\u006f\u0074\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");return false ;};

// WriteString outputs the object as it is to be written to file.
func (_bebg *PdfObjectStreams )WriteString ()string {var _cegfg _gg .Builder ;_cegfg .WriteString (_b .FormatInt (_bebg .ObjectNumber ,10));_cegfg .WriteString ("\u0020\u0030\u0020\u0052");return _cegfg .String ();};func (_fabd *PdfParser )loadXrefs ()(*PdfObjectDictionary ,error ){_fabd ._feabg .ObjectMap =make (map[int ]XrefObject );
_fabd ._bgba =make (objectStreams );_aecg ,_fbdb :=_fabd ._fdeg .Seek (0,_bf .SeekEnd );if _fbdb !=nil {return nil ,_fbdb ;};_aab .Log .Trace ("\u0066s\u0069\u007a\u0065\u003a\u0020\u0025d",_aecg );_fabd ._eagg =_aecg ;_fbdb =_fabd .seekToEOFMarker (_aecg );
if _fbdb !=nil {_aab .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0073\u0065\u0065\u006b\u0020\u0074\u006f\u0020\u0065\u006f\u0066\u0020\u006d\u0061\u0072\u006b\u0065\u0072: \u0025\u0076",_fbdb );return nil ,_fbdb ;};_dgfd ,_fbdb :=_fabd ._fdeg .Seek (0,_bf .SeekCurrent );
if _fbdb !=nil {return nil ,_fbdb ;};var _fcdd int64 =64;_aefa :=_dgfd -_fcdd ;if _aefa < 0{_aefa =0;};_ ,_fbdb =_fabd ._fdeg .Seek (_aefa ,_bf .SeekStart );if _fbdb !=nil {return nil ,_fbdb ;};_fedb :=make ([]byte ,_fcdd );_ ,_fbdb =_fabd ._fdeg .Read (_fedb );
if _fbdb !=nil {_aab .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u003a\u0020\u0025\u0076",_fbdb );
return nil ,_fbdb ;};_cbefb :=_eded .FindStringSubmatch (string (_fedb ));if len (_cbefb )< 2{_aab .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020n\u006f\u0074\u0020f\u006fu\u006e\u0064\u0021");
return nil ,_d .New ("\u0073\u0074\u0061\u0072tx\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};if len (_cbefb )> 2{_aab .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u004du\u006c\u0074\u0069\u0070\u006c\u0065\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029\u0021",_fedb );
return nil ,_d .New ("m\u0075\u006c\u0074\u0069\u0070\u006ce\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065f\u0020\u0065\u006et\u0072i\u0065\u0073\u003f");};_deecg ,_ :=_b .ParseInt (_cbefb [1],10,64);_aab .Log .Trace ("\u0073t\u0061r\u0074\u0078\u0072\u0065\u0066\u0020\u0061\u0074\u0020\u0025\u0064",_deecg );
if _deecg > _aecg {_aab .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u006f\u0066f\u0073e\u0074 \u006fu\u0074\u0073\u0069\u0064\u0065\u0020\u006f\u0066\u0020\u0066\u0069\u006c\u0065");_aab .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0072e\u0070\u0061\u0069\u0072");
_deecg ,_fbdb =_fabd .repairLocateXref ();if _fbdb !=nil {_aab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0052\u0065\u0070\u0061\u0069\u0072\u0020\u0061\u0074\u0074\u0065\u006d\u0070t\u0020\u0066\u0061\u0069\u006c\u0065\u0064 \u0028\u0025\u0073\u0029");
return nil ,_fbdb ;};};_fabd ._fdeg .Seek (_deecg ,_bf .SeekStart );_fabd ._aaae =_gd .NewReader (_fabd ._fdeg );_bafe ,_fbdb :=_fabd .parseXref ();if _fbdb !=nil {return nil ,_fbdb ;};_bbcg :=_bafe .Get ("\u0058R\u0065\u0066\u0053\u0074\u006d");if _bbcg !=nil {_begb ,_dcac :=_bbcg .(*PdfObjectInteger );
if !_dcac {return nil ,_d .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0021=\u0020\u0069\u006e\u0074");};_ ,_fbdb =_fabd .parseXrefStream (_begb );if _fbdb !=nil {return nil ,_fbdb ;};};var _aabbf []int64 ;_ebec :=func (_daag int64 ,_aedg []int64 )bool {for _ ,_gffd :=range _aedg {if _gffd ==_daag {return true ;
};};return false ;};_bbcg =_bafe .Get ("\u0050\u0072\u0065\u0076");for _bbcg !=nil {_cegfb ,_aeae :=_bbcg .(*PdfObjectInteger );if !_aeae {_aab .Log .Debug ("\u0049\u006ev\u0061\u006c\u0069\u0064\u0020P\u0072\u0065\u0076\u0020\u0072e\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u003a\u0020\u004e\u006f\u0074\u0020\u0061\u0020\u002a\u0050\u0064\u0066\u004f\u0062\u006a\u0065\u0063\u0074\u0049\u006e\u0074\u0065\u0067\u0065\u0072\u0020\u0028\u0025\u0054\u0029",_bbcg );
return _bafe ,nil ;};_fgaab :=*_cegfb ;_aab .Log .Trace ("\u0041\u006eot\u0068\u0065\u0072 \u0050\u0072\u0065\u0076 xr\u0065f \u0074\u0061\u0062\u006c\u0065\u0020\u006fbj\u0065\u0063\u0074\u0020\u0061\u0074\u0020%\u0064",_fgaab );_fabd ._fdeg .Seek (int64 (_fgaab ),_bf .SeekStart );
_fabd ._aaae =_gd .NewReader (_fabd ._fdeg );_gdbg ,_geae :=_fabd .parseXref ();if _geae !=nil {_aab .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0045\u0072\u0072\u006f\u0072\u0020-\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u0061\u0064\u0069n\u0067\u0020\u0061\u006e\u006f\u0074\u0068\u0065\u0072\u0020\u0028\u0050re\u0076\u0029\u0020\u0074\u0072\u0061\u0069\u006c\u0065\u0072");
_aab .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0063\u006f\u006e\u0074\u0069n\u0075\u0065\u0020\u0062\u0079\u0020\u0069\u0067\u006e\u006f\u0072\u0069n\u0067\u0020\u0069\u0074");break ;};_bbcg =_gdbg .Get ("\u0050\u0072\u0065\u0076");
if _bbcg !=nil {_ccbd :=*(_bbcg .(*PdfObjectInteger ));if _ebec (int64 (_ccbd ),_aabbf ){_aab .Log .Debug ("\u0050\u0072ev\u0065\u006e\u0074i\u006e\u0067\u0020\u0063irc\u0075la\u0072\u0020\u0078\u0072\u0065\u0066\u0020re\u0066\u0065\u0072\u0065\u006e\u0063\u0069n\u0067");
break ;};_aabbf =append (_aabbf ,int64 (_ccbd ));};};return _bafe ,nil ;};

// GetNumberAsInt64 returns the contents of `obj` as an int64 if it is an integer or float, or an
// error if it isn't. This is for cases where expecting an integer, but some implementations
// actually store the number in a floating point format.
func GetNumberAsInt64 (obj PdfObject )(int64 ,error ){_dafd ,_bdgef :=obj .(*PdfObjectReference );if _bdgef {obj =TraceToDirectObject (_dafd );};switch _eeea :=obj .(type ){case *PdfObjectFloat :_aab .Log .Debug ("\u004e\u0075m\u0062\u0065\u0072\u0020\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0061\u0073\u0020\u0069\u006e\u0074e\u0067\u0065\u0072\u0020\u0077\u0061s\u0020\u0073\u0074\u006f\u0072\u0065\u0064\u0020\u0061\u0073\u0020\u0066\u006c\u006fa\u0074\u0020(\u0074\u0079\u0070\u0065 \u0063\u0061\u0073\u0074\u0069n\u0067\u0020\u0075\u0073\u0065\u0064\u0029");
return int64 (*_eeea ),nil ;case *PdfObjectInteger :return int64 (*_eeea ),nil ;};return 0,ErrNotANumber ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_fcag *RawEncoder )MakeDecodeParams ()PdfObject {return nil };

// HasEOLAfterHeader gets information if there is a EOL after the version header.
func (_dcgc ParserMetadata )HasEOLAfterHeader ()bool {return _dcgc ._bbcd };func (_gcbc *PdfParser )skipSpaces ()(int ,error ){_bdga :=0;for {_ddgf ,_gaeb :=_gcbc ._aaae .ReadByte ();if _gaeb !=nil {return 0,_gaeb ;};if IsWhiteSpace (_ddgf ){_bdga ++;}else {_gcbc ._aaae .UnreadByte ();
break ;};};return _bdga ,nil ;};

// NewParser creates a new parser for a PDF file via ReadSeeker. Loads the cross reference stream and trailer.
// An error is returned on failure.
func NewParser (rs _bf .ReadSeeker )(*PdfParser ,error ){_eced :=&PdfParser {_fdeg :rs ,ObjCache :make (objectCache ),_cggec :map[int64 ]bool {}};_gdag ,_dabc ,_fadf :=_eced .parsePdfVersion ();if _fadf !=nil {_aab .Log .Error ("U\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0076e\u0072\u0073\u0069o\u006e:\u0020\u0025\u0076",_fadf );
return nil ,_fadf ;};_eced ._cbgab .Major =_gdag ;_eced ._cbgab .Minor =_dabc ;if _eced ._daeb ,_fadf =_eced .loadXrefs ();_fadf !=nil {_aab .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020F\u0061\u0069\u006c\u0065d t\u006f l\u006f\u0061\u0064\u0020\u0078\u0072\u0065f \u0074\u0061\u0062\u006c\u0065\u0021\u0020%\u0073",_fadf );
return nil ,_fadf ;};_aab .Log .Trace ("T\u0072\u0061\u0069\u006c\u0065\u0072\u003a\u0020\u0025\u0073",_eced ._daeb );if len (_eced ._feabg .ObjectMap )==0{return nil ,_ca .Errorf ("\u0065\u006d\u0070\u0074\u0079\u0020\u0058\u0052\u0045\u0046\u0020t\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0049\u006e\u0076a\u006c\u0069\u0064");
};return _eced ,nil ;};

// PdfObject is an interface which all primitive PDF objects must implement.
type PdfObject interface{

// String outputs a string representation of the primitive (for debugging).
String ()string ;

// WriteString outputs the PDF primitive as written to file as expected by the standard.
// TODO(dennwc): it should return a byte slice, or accept a writer
WriteString ()string ;};

// DecodeBytes decodes a byte slice from Run length encoding.
//
// 7.4.5 RunLengthDecode Filter
// The RunLengthDecode filter decodes data that has been encoded in a simple byte-oriented format based on run length.
// The encoded data shall be a sequence of runs, where each run shall consist of a length byte followed by 1 to 128
// bytes of data. If the length byte is in the range 0 to 127, the following length + 1 (1 to 128) bytes shall be
// copied literally during decompression. If length is in the range 129 to 255, the following single byte shall be
// copied 257 - length (2 to 128) times during decompression. A length value of 128 shall denote EOD.
func (_abfgc *RunLengthEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_bcgb :=_abb .NewReader (encoded );var _bde []byte ;for {_ccfed ,_cagge :=_bcgb .ReadByte ();if _cagge !=nil {return nil ,_cagge ;};if _ccfed > 128{_bbdf ,_edebe :=_bcgb .ReadByte ();
if _edebe !=nil {return nil ,_edebe ;};for _babg :=0;_babg < 257-int (_ccfed );_babg ++{_bde =append (_bde ,_bbdf );};}else if _ccfed < 128{for _cfa :=0;_cfa < int (_ccfed )+1;_cfa ++{_ddee ,_afag :=_bcgb .ReadByte ();if _afag !=nil {return nil ,_afag ;
};_bde =append (_bde ,_ddee );};}else {break ;};};return _bde ,nil ;};

// Merge merges in key/values from another dictionary. Overwriting if has same keys.
// The mutated dictionary (d) is returned in order to allow method chaining.
func (_acdc *PdfObjectDictionary )Merge (another *PdfObjectDictionary )*PdfObjectDictionary {if another !=nil {for _ ,_eead :=range another .Keys (){_gade :=another .Get (_eead );_acdc .Set (_eead ,_gade );};};return _acdc ;};

// HeaderCommentBytes gets the header comment bytes.
func (_deebd ParserMetadata )HeaderCommentBytes ()[4]byte {return _deebd ._edeb };var (ErrUnsupportedEncodingParameters =_d .New ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074\u0065\u0072\u0073");
ErrNoCCITTFaxDecode =_d .New ("\u0043\u0043I\u0054\u0054\u0046\u0061\u0078\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");
ErrNoJBIG2Decode =_d .New ("\u004a\u0042\u0049\u0047\u0032\u0044\u0065c\u006f\u0064\u0065 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");
ErrNoJPXDecode =_d .New ("\u004a\u0050\u0058\u0044\u0065c\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020i\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");
ErrNoPdfVersion =_d .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");ErrTypeError =_d .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");ErrRangeError =_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");
ErrNotSupported =_abc .New ("\u0066\u0065\u0061t\u0075\u0072\u0065\u0020n\u006f\u0074\u0020\u0063\u0075\u0072\u0072e\u006e\u0074\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");ErrNotANumber =_d .New ("\u006e\u006f\u0074 \u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072");
);var _cbefc =_ed .MustCompile ("\u005c\u0073\u002a\u0078\u0072\u0065\u0066\u005c\u0073\u002a");

// MakeDictMap creates a PdfObjectDictionary initialized from a map of keys to values.
func MakeDictMap (objmap map[string ]PdfObject )*PdfObjectDictionary {_dgggg :=MakeDict ();return _dgggg .Update (objmap );};

// RegisterCustomStreamEncoder register a custom encoder handler for certain filter.
func RegisterCustomStreamEncoder (filterName string ,customStreamEncoder StreamEncoder ){_gbbfa .Store (filterName ,customStreamEncoder );};const JB2ImageAutoThreshold =-1.0;

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_daee *FlateEncoder )EncodeBytes (data []byte )([]byte ,error ){if _daee .Predictor !=1&&_daee .Predictor !=11{_aab .Log .Debug ("E\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0046\u006c\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065r\u0020P\u0072\u0065\u0064\u0069c\u0074\u006fr\u0020\u003d\u0020\u0031\u002c\u0020\u0031\u0031\u0020\u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");
return nil ,ErrUnsupportedEncodingParameters ;};if _daee .Predictor ==11{_bbca :=_daee .Columns ;_acde :=len (data )/_bbca ;if len (data )%_bbca !=0{_aab .Log .Error ("\u0049n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");
return nil ,_d .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");};_bae :=_abb .NewBuffer (nil );_ddd :=make ([]byte ,_bbca );for _cfec :=0;_cfec < _acde ;_cfec ++{_dbcb :=data [_bbca *_cfec :_bbca *(_cfec +1)];
_ddd [0]=_dbcb [0];for _fbb :=1;_fbb < _bbca ;_fbb ++{_ddd [_fbb ]=byte (int (_dbcb [_fbb ]-_dbcb [_fbb -1])%256);};_bae .WriteByte (1);_bae .Write (_ddd );};data =_bae .Bytes ();};var _bacfc _abb .Buffer ;_gfdc :=_bb .NewWriter (&_bacfc );_gfdc .Write (data );
_gfdc .Close ();return _bacfc .Bytes (),nil ;};

// Decrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_gga *PdfCrypt )Decrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _gga .isDecrypted (obj ){return nil ;};switch _afa :=obj .(type ){case *PdfIndirectObject :_gga ._ffb [_afa ]=true ;_aab .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_afa .ObjectNumber ,_afa .GenerationNumber );
_aef :=_afa .ObjectNumber ;_daf :=_afa .GenerationNumber ;_fbdf :=_gga .Decrypt (_afa .PdfObject ,_aef ,_daf );if _fbdf !=nil {return _fbdf ;};return nil ;case *PdfObjectStream :_gga ._ffb [_afa ]=true ;_ggf :=_afa .PdfObjectDictionary ;if _gga ._fca .R !=5{if _eaa ,_aabb :=_ggf .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );
_aabb &&*_eaa =="\u0058\u0052\u0065\u0066"{return nil ;};};_gcb :=_afa .ObjectNumber ;_gce :=_afa .GenerationNumber ;_aab .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_gcb ,_gce );
_cdef :=_ee ;if _gga ._dab .V >=4{_cdef =_gga ._bdb ;_aab .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_gga ._bdb );if _abce ,_gggg :=_ggf .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );
_gggg {if _dcd ,_afda :=GetName (_abce .Get (0));_afda {if *_dcd =="\u0043\u0072\u0079p\u0074"{_cdef ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _afbd ,_ffc :=_ggf .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );
_ffc {if _acc ,_bbd :=_afbd .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_bbd {if _ ,_gaec :=_gga ._egg [string (*_acc )];_gaec {_aab .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_acc );
_cdef =string (*_acc );};};};};};};_aab .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_cdef );if _cdef =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_egb :=_gga .Decrypt (_ggf ,_gcb ,_gce );
if _egb !=nil {return _egb ;};_gba ,_egb :=_gga .makeKey (_cdef ,uint32 (_gcb ),uint32 (_gce ),_gga ._afdc );if _egb !=nil {return _egb ;};_afa .Stream ,_egb =_gga .decryptBytes (_afa .Stream ,_cdef ,_gba );if _egb !=nil {return _egb ;};_ggf .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_afa .Stream ))));
return nil ;case *PdfObjectString :_aab .Log .Trace ("\u0044e\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_gcca :=_ee ;if _gga ._dab .V >=4{_aab .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_gga ._aeac );
if _gga ._aeac =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_gcca =_gga ._aeac ;};_cdf ,_bdbe :=_gga .makeKey (_gcca ,uint32 (parentObjNum ),uint32 (parentGenNum ),_gga ._afdc );if _bdbe !=nil {return _bdbe ;};_deeccf :=_afa .Str ();
_caa :=make ([]byte ,len (_deeccf ));for _gfgd :=0;_gfgd < len (_deeccf );_gfgd ++{_caa [_gfgd ]=_deeccf [_gfgd ];};if len (_caa )> 0{_aab .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_caa ,_caa );
_caa ,_bdbe =_gga .decryptBytes (_caa ,_gcca ,_cdf );if _bdbe !=nil {return _bdbe ;};};_afa ._agadg =string (_caa );return nil ;case *PdfObjectArray :for _ ,_gca :=range _afa .Elements (){_decd :=_gga .Decrypt (_gca ,parentObjNum ,parentGenNum );if _decd !=nil {return _decd ;
};};return nil ;case *PdfObjectDictionary :_deaa :=false ;if _ege :=_afa .Get ("\u0054\u0079\u0070\u0065");_ege !=nil {_eab ,_ecdf :=_ege .(*PdfObjectName );if _ecdf &&*_eab =="\u0053\u0069\u0067"{_deaa =true ;};};for _ ,_efdg :=range _afa .Keys (){_ggd :=_afa .Get (_efdg );
if _deaa &&string (_efdg )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;};if string (_efdg )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_efdg )!="\u0050\u0072\u0065\u0076"&&string (_efdg )!="\u004c\u0061\u0073\u0074"{_fdf :=_gga .Decrypt (_ggd ,parentObjNum ,parentGenNum );
if _fdf !=nil {return _fdf ;};};};return nil ;};return nil ;};

// GetFilterName returns the name of the encoding filter.
func (_gbab *CCITTFaxEncoder )GetFilterName ()string {return StreamEncodingFilterNameCCITTFax };

// EncodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_efdf *RawEncoder )EncodeBytes (data []byte )([]byte ,error ){return data ,nil };

// String returns a string describing `ind`.
func (_fade *PdfIndirectObject )String ()string {return _ca .Sprintf ("\u0049\u004f\u0062\u006a\u0065\u0063\u0074\u003a\u0025\u0064",(*_fade ).ObjectNumber );};func (_effg *PdfParser )parseBool ()(PdfObjectBool ,error ){_gacc ,_ggce :=_effg ._aaae .Peek (4);
if _ggce !=nil {return PdfObjectBool (false ),_ggce ;};if (len (_gacc )>=4)&&(string (_gacc [:4])=="\u0074\u0072\u0075\u0065"){_effg ._aaae .Discard (4);return PdfObjectBool (true ),nil ;};_gacc ,_ggce =_effg ._aaae .Peek (5);if _ggce !=nil {return PdfObjectBool (false ),_ggce ;
};if (len (_gacc )>=5)&&(string (_gacc [:5])=="\u0066\u0061\u006cs\u0065"){_effg ._aaae .Discard (5);return PdfObjectBool (false ),nil ;};return PdfObjectBool (false ),_d .New ("\u0075n\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0062o\u006fl\u0065a\u006e\u0020\u0073\u0074\u0072\u0069\u006eg");
};

// GetCrypter returns the PdfCrypt instance which has information about the PDFs encryption.
func (_adbb *PdfParser )GetCrypter ()*PdfCrypt {return _adbb ._gbbg };

// IsDecimalDigit checks if the character is a part of a decimal number string.
func IsDecimalDigit (c byte )bool {return '0'<=c &&c <='9'};

// GetXrefType returns the type of the first xref object (table or stream).
func (_gefb *PdfParser )GetXrefType ()*xrefType {return _gefb ._dbff };const _ebaaa =10;

// MakeArrayFromIntegers64 creates an PdfObjectArray from a slice of int64s, where each array element
// is an PdfObjectInteger.
func MakeArrayFromIntegers64 (vals []int64 )*PdfObjectArray {_gaag :=MakeArray ();for _ ,_fead :=range vals {_gaag .Append (MakeInteger (_fead ));};return _gaag ;};

// DecodeBytes decodes a slice of Flate encoded bytes and returns the result.
func (_gbe *FlateEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_aab .Log .Trace ("\u0046\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065\u0020b\u0079\u0074\u0065\u0073");if len (encoded )==0{_aab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0046\u006c\u0061\u0074\u0065 e\u006ec\u006f\u0064\u0065\u0064\u0020\u0062\u0075\u0066\u0066\u0065\u0072\u002e \u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0062y\u0074\u0065\u0020\u0073\u006c\u0069\u0063\u0065\u002e");
return []byte {},nil ;};_aaf :=_abb .NewReader (encoded );_dffc ,_bab :=_bb .NewReader (_aaf );if _bab !=nil {_aab .Log .Debug ("\u0044e\u0063o\u0064\u0069\u006e\u0067\u0020e\u0072\u0072o\u0072\u0020\u0025\u0076\u000a",_bab );_aab .Log .Debug ("\u0053t\u0072e\u0061\u006d\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (encoded ),encoded );
return nil ,_bab ;};defer _dffc .Close ();var _cgfag _abb .Buffer ;_cgfag .ReadFrom (_dffc );return _cgfag .Bytes (),nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_cfaa *CCITTFaxEncoder )MakeDecodeParams ()PdfObject {_fdfd :=MakeDict ();_fdfd .Set ("\u004b",MakeInteger (int64 (_cfaa .K )));_fdfd .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_cfaa .Columns )));if _cfaa .BlackIs1 {_fdfd .Set ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031",MakeBool (_cfaa .BlackIs1 ));
};if _cfaa .EncodedByteAlign {_fdfd .Set ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e",MakeBool (_cfaa .EncodedByteAlign ));};if _cfaa .EndOfLine &&_cfaa .K >=0{_fdfd .Set ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee",MakeBool (_cfaa .EndOfLine ));
};if _cfaa .Rows !=0&&!_cfaa .EndOfBlock {_fdfd .Set ("\u0052\u006f\u0077\u0073",MakeInteger (int64 (_cfaa .Rows )));};if !_cfaa .EndOfBlock {_fdfd .Set ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b",MakeBool (_cfaa .EndOfBlock ));};if _cfaa .DamagedRowsBeforeError !=0{_fdfd .Set ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072",MakeInteger (int64 (_cfaa .DamagedRowsBeforeError )));
};return _fdfd ;};func (_eegbb *PdfObjectFloat )String ()string {return _ca .Sprintf ("\u0025\u0066",*_eegbb )};func _gaafdd (_geeb *PdfObjectDictionary )(_adfc *_gdd .ImageBase ){var (_dbagc *PdfObjectInteger ;_gaaga bool ;);if _dbagc ,_gaaga =_geeb .Get ("\u0057\u0069\u0064t\u0068").(*PdfObjectInteger );
_gaaga {_adfc =&_gdd .ImageBase {Width :int (*_dbagc )};}else {return nil ;};if _dbagc ,_gaaga =_geeb .Get ("\u0048\u0065\u0069\u0067\u0068\u0074").(*PdfObjectInteger );_gaaga {_adfc .Height =int (*_dbagc );};if _dbagc ,_gaaga =_geeb .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074").(*PdfObjectInteger );
_gaaga {_adfc .BitsPerComponent =int (*_dbagc );};if _dbagc ,_gaaga =_geeb .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073").(*PdfObjectInteger );_gaaga {_adfc .ColorComponents =int (*_dbagc );};return _adfc ;};func (_cbed *PdfParser )parseHexString ()(*PdfObjectString ,error ){_cbed ._aaae .ReadByte ();
var _ccad _abb .Buffer ;for {_feed ,_decde :=_cbed ._aaae .Peek (1);if _decde !=nil {return MakeString (""),_decde ;};if _feed [0]=='>'{_cbed ._aaae .ReadByte ();break ;};_geagg ,_ :=_cbed ._aaae .ReadByte ();if _cbed ._ffeg {if _abb .IndexByte (_aaca ,_geagg )==-1{_cbed ._accf ._eaded =true ;
};};if !IsWhiteSpace (_geagg ){_ccad .WriteByte (_geagg );};};if _ccad .Len ()%2==1{_cbed ._accf ._cga =true ;_ccad .WriteRune ('0');};_adbf ,_ :=_g .DecodeString (_ccad .String ());return MakeHexString (string (_adbf )),nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_gdbf *CCITTFaxEncoder )UpdateParams (params *PdfObjectDictionary ){if _fbef ,_aefd :=GetNumberAsInt64 (params .Get ("\u004b"));_aefd ==nil {_gdbf .K =int (_fbef );};if _fcde ,_fdfda :=GetNumberAsInt64 (params .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));
_fdfda ==nil {_gdbf .Columns =int (_fcde );}else if _fcde ,_fdfda =GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));_fdfda ==nil {_gdbf .Columns =int (_fcde );};if _dafe ,_begc :=GetNumberAsInt64 (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));
_begc ==nil {_gdbf .BlackIs1 =_dafe > 0;}else {if _degb ,_dafa :=GetBoolVal (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_dafa {_gdbf .BlackIs1 =_degb ;}else {if _cdda ,_facc :=GetArray (params .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));
_facc {_eeecd ,_fddd :=_cdda .ToIntegerArray ();if _fddd ==nil {_gdbf .BlackIs1 =_eeecd [0]==1&&_eeecd [1]==0;};};};};if _egbc ,_badd :=GetNumberAsInt64 (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));
_badd ==nil {_gdbf .EncodedByteAlign =_egbc > 0;}else {if _agbgg ,_aege :=GetBoolVal (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_aege {_gdbf .EncodedByteAlign =_agbgg ;};};if _gad ,_efba :=GetNumberAsInt64 (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));
_efba ==nil {_gdbf .EndOfLine =_gad > 0;}else {if _abbc ,_cdaa :=GetBoolVal (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_cdaa {_gdbf .EndOfLine =_abbc ;};};if _edbge ,_fcfe :=GetNumberAsInt64 (params .Get ("\u0052\u006f\u0077\u0073"));
_fcfe ==nil {_gdbf .Rows =int (_edbge );}else if _edbge ,_fcfe =GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));_fcfe ==nil {_gdbf .Rows =int (_edbge );};if _gaa ,_beb :=GetNumberAsInt64 (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));
_beb ==nil {_gdbf .EndOfBlock =_gaa > 0;}else {if _abfc ,_adaa :=GetBoolVal (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_adaa {_gdbf .EndOfBlock =_abfc ;};};if _deced ,_ebfe :=GetNumberAsInt64 (params .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));
_ebfe !=nil {_gdbf .DamagedRowsBeforeError =int (_deced );};};func (_fcbcb *PdfParser )seekToEOFMarker (_adcd int64 )error {var _gdbfa int64 ;var _beeba int64 =2048;for _gdbfa < _adcd -4{if _adcd <=(_beeba +_gdbfa ){_beeba =_adcd -_gdbfa ;};_ ,_bbbg :=_fcbcb ._fdeg .Seek (-_gdbfa -_beeba ,_bf .SeekEnd );
if _bbbg !=nil {return _bbbg ;};_acbeg :=make ([]byte ,_beeba );_fcbcb ._fdeg .Read (_acbeg );_aab .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0045\u004f\u0046 \u006da\u0072\u006b\u0065\u0072\u003a\u0020\u0022%\u0073\u0022",string (_acbeg ));
_dbfd :=_fgdea .FindAllStringIndex (string (_acbeg ),-1);if _dbfd !=nil {_abccc :=_dbfd [len (_dbfd )-1];_aab .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_dbfd );_cabge :=-_gdbfa -_beeba +int64 (_abccc [0]);_fcbcb ._fdeg .Seek (_cabge ,_bf .SeekEnd );
return nil ;};_aab .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");
_gdbfa +=_beeba -4;};_aab .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006be\u0072 \u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u002e");return _d .New ("\u0045\u004f\u0046\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");
};

// HasDataAfterEOF checks if there is some data after EOF marker.
func (_fcda ParserMetadata )HasDataAfterEOF ()bool {return _fcda ._dbde };

// HeaderPosition gets the file header position.
func (_ddac ParserMetadata )HeaderPosition ()int {return _ddac ._bdg };

// DecodeStream decodes a JPX encoded stream and returns the result as a
// slice of bytes.
func (_baec *JPXEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_aab .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_baec .GetFilterName ());
return streamObj .Stream ,ErrNoJPXDecode ;};

// JBIG2Encoder implements both jbig2 encoder and the decoder. The encoder allows to encode
// provided images (best used document scans) in multiple way. By default it uses single page generic
// encoder. It allows to store lossless data as a single segment.
// In order to store multiple image pages use the 'FileMode' which allows to store more pages within single jbig2 document.
// WIP: In order to obtain better compression results the encoder would allow to encode the input in a
// lossy or lossless way with a component (symbol) mode. It divides the image into components.
// Then checks if any component is 'similar' to the others and maps them together. The symbol classes are stored
// in the dictionary. Then the encoder creates text regions which uses the related symbol classes to fill it's space.
// The similarity is defined by the 'Threshold' variable (default: 0.95). The less the value is, the more components
// matches to single class, thus the compression is better, but the result might become lossy.
type JBIG2Encoder struct{

// These values are required to be set for the 'EncodeBytes' method.
// ColorComponents defines the number of color components for provided image.
ColorComponents int ;

// BitsPerComponent is the number of bits that stores per color component
BitsPerComponent int ;

// Width is the width of the image to encode
Width int ;

// Height is the height of the image to encode.
Height int ;_faeb *_bbe .Document ;

// Globals are the JBIG2 global segments.
Globals _aeg .Globals ;

// IsChocolateData defines if the data is encoded such that
// binary data '1' means black and '0' white.
// otherwise the data is called vanilla.
// Naming convention taken from: 'https://en.wikipedia.org/wiki/Binary_image#Interpretation'
IsChocolateData bool ;

// DefaultPageSettings are the settings parameters used by the jbig2 encoder.
DefaultPageSettings JBIG2EncoderSettings ;};

// GoImageToJBIG2 creates a binary image on the base of 'i' golang image.Image.
// If the image is not a black/white image then the function converts provided input into
// JBIG2Image with 1bpp. For non grayscale images the function performs the conversion to the grayscale temp image.
// Then it checks the value of the gray image value if it's within bounds of the black white threshold.
// This 'bwThreshold' value should be in range (0.0, 1.0). The threshold checks if the grayscale pixel (uint) value
// is greater or smaller than 'bwThreshold' * 255. Pixels inside the range will be white, and the others will be black.
// If the 'bwThreshold' is equal to -1.0 - JB2ImageAutoThreshold then it's value would be set on the base of
// it's histogram using Triangle method. For more information go to:
// 	https://www.mathworks.com/matlabcentral/fileexchange/28047-gray-image-thresholding-using-the-triangle-method
func GoImageToJBIG2 (i _ab .Image ,bwThreshold float64 )(*JBIG2Image ,error ){const _ebcg ="\u0047\u006f\u0049\u006d\u0061\u0067\u0065\u0054\u006fJ\u0042\u0049\u0047\u0032";if i ==nil {return nil ,_ba .Error (_ebcg ,"i\u006d\u0061\u0067\u0065 '\u0069'\u0020\u006e\u006f\u0074\u0020d\u0065\u0066\u0069\u006e\u0065\u0064");
};var (_eefe uint8 ;_bdea _gdd .Image ;_ccfd error ;);if bwThreshold ==JB2ImageAutoThreshold {_bdea ,_ccfd =_gdd .MonochromeConverter .Convert (i );}else if bwThreshold > 1.0||bwThreshold < 0.0{return nil ,_ba .Error (_ebcg ,"p\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074h\u0072\u0065\u0073\u0068\u006f\u006c\u0064 i\u0073\u0020\u006e\u006ft\u0020\u0069\u006e\u0020\u0061\u0020\u0072\u0061\u006ege\u0020\u007b0\u002e\u0030\u002c\u0020\u0031\u002e\u0030\u007d");
}else {_eefe =uint8 (255*bwThreshold );_bdea ,_ccfd =_gdd .MonochromeThresholdConverter (_eefe ).Convert (i );};if _ccfd !=nil {return nil ,_ccfd ;};return _cfega (_bdea ),nil ;};func (_cbdf *PdfParser )repairRebuildXrefsTopDown ()(*XrefTable ,error ){if _cbdf ._gdff {return nil ,_ca .Errorf ("\u0072\u0065\u0070\u0061\u0069\u0072\u0020\u0066\u0061\u0069\u006c\u0065\u0064");
};_cbdf ._gdff =true ;_cbdf ._fdeg .Seek (0,_bf .SeekStart );_cbdf ._aaae =_gd .NewReader (_cbdf ._fdeg );_fcff :=20;_facb :=make ([]byte ,_fcff );_gfc :=XrefTable {};_gfc .ObjectMap =make (map[int ]XrefObject );for {_deddc ,_ggfcd :=_cbdf ._aaae .ReadByte ();
if _ggfcd !=nil {if _ggfcd ==_bf .EOF {break ;}else {return nil ,_ggfcd ;};};if _deddc =='j'&&_facb [_fcff -1]=='b'&&_facb [_fcff -2]=='o'&&IsWhiteSpace (_facb [_fcff -3]){_bbbgf :=_fcff -4;for IsWhiteSpace (_facb [_bbbgf ])&&_bbbgf > 0{_bbbgf --;};if _bbbgf ==0||!IsDecimalDigit (_facb [_bbbgf ]){continue ;
};for IsDecimalDigit (_facb [_bbbgf ])&&_bbbgf > 0{_bbbgf --;};if _bbbgf ==0||!IsWhiteSpace (_facb [_bbbgf ]){continue ;};for IsWhiteSpace (_facb [_bbbgf ])&&_bbbgf > 0{_bbbgf --;};if _bbbgf ==0||!IsDecimalDigit (_facb [_bbbgf ]){continue ;};for IsDecimalDigit (_facb [_bbbgf ])&&_bbbgf > 0{_bbbgf --;
};if _bbbgf ==0{continue ;};_cadag :=_cbdf .GetFileOffset ()-int64 (_fcff -_bbbgf );_gadc :=append (_facb [_bbbgf +1:],_deddc );_bcdbb ,_dfca ,_cgbf :=_cgad (string (_gadc ));if _cgbf !=nil {_aab .Log .Debug ("\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u006e\u0075\u006d\u0062\u0065r\u003a\u0020\u0025\u0076",_cgbf );
return nil ,_cgbf ;};if _cedbb ,_dccf :=_gfc .ObjectMap [_bcdbb ];!_dccf ||_cedbb .Generation < _dfca {_adbg :=XrefObject {};_adbg .XType =XrefTypeTableEntry ;_adbg .ObjectNumber =_bcdbb ;_adbg .Generation =_dfca ;_adbg .Offset =_cadag ;_gfc .ObjectMap [_bcdbb ]=_adbg ;
};};_facb =append (_facb [1:_fcff ],_deddc );};_cbdf ._eeebe =nil ;return &_gfc ,nil ;};

// NewASCII85Encoder makes a new ASCII85 encoder.
func NewASCII85Encoder ()*ASCII85Encoder {_egdg :=&ASCII85Encoder {};return _egdg };

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_ffaag *RawEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};

// NewParserFromString is used for testing purposes.
func NewParserFromString (txt string )*PdfParser {_dedc :=_abb .NewReader ([]byte (txt ));_gdaf :=&PdfParser {ObjCache :objectCache {},_fdeg :_dedc ,_aaae :_gd .NewReader (_dedc ),_eagg :int64 (len (txt )),_cggec :map[int64 ]bool {}};_gdaf ._feabg .ObjectMap =make (map[int ]XrefObject );
return _gdaf ;};

// EncryptInfo contains an information generated by the document encrypter.
type EncryptInfo struct{Version ;

// Encrypt is an encryption dictionary that contains all necessary parameters.
// It should be stored in all copies of the document trailer.
Encrypt *PdfObjectDictionary ;

// ID0 and ID1 are IDs used in the trailer. Older algorithms such as RC4 uses them for encryption.
ID0 ,ID1 string ;};

// EncodeBytes implements support for LZW encoding.  Currently not supporting predictors (raw compressed data only).
// Only supports the Early change = 1 algorithm (compress/lzw) as the other implementation
// does not have a write method.
// TODO: Consider refactoring compress/lzw to allow both.
func (_aceg *LZWEncoder )EncodeBytes (data []byte )([]byte ,error ){if _aceg .Predictor !=1{return nil ,_ca .Errorf ("\u004c\u005aW \u0050\u0072\u0065d\u0069\u0063\u0074\u006fr =\u00201 \u006f\u006e\u006c\u0079\u0020\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0079e\u0074");
};if _aceg .EarlyChange ==1{return nil ,_ca .Errorf ("\u004c\u005a\u0057\u0020\u0045\u0061\u0072\u006c\u0079\u0020\u0043\u0068\u0061n\u0067\u0065\u0020\u003d\u0020\u0030 \u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0079\u0065\u0074");
};var _fdg _abb .Buffer ;_fbf :=_ge .NewWriter (&_fdg ,_ge .MSB ,8);_fbf .Write (data );_fbf .Close ();return _fdg .Bytes (),nil ;};

// NewCCITTFaxEncoder makes a new CCITTFax encoder.
func NewCCITTFaxEncoder ()*CCITTFaxEncoder {return &CCITTFaxEncoder {Columns :1728,EndOfBlock :true }};

// MakeDict creates and returns an empty PdfObjectDictionary.
func MakeDict ()*PdfObjectDictionary {_ffga :=&PdfObjectDictionary {};_ffga ._abegb =map[PdfObjectName ]PdfObject {};_ffga ._eegb =[]PdfObjectName {};_ffga ._aggc =&_c .Mutex {};return _ffga ;};

// GetBoolVal returns the bool value within a *PdObjectBool represented by an PdfObject interface directly or indirectly.
// If the PdfObject does not represent a bool value, a default value of false is returned (found = false also).
func GetBoolVal (obj PdfObject )(_aagf bool ,_dcdgg bool ){_ceef ,_dcdgg :=TraceToDirectObject (obj ).(*PdfObjectBool );if _dcdgg {return bool (*_ceef ),true ;};return false ,false ;};func _baa (_dg *_fbd .StdEncryptDict ,_gcfg *PdfObjectDictionary )error {R ,_ffge :=_gcfg .Get ("\u0052").(*PdfObjectInteger );
if !_ffge {return _d .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0052");};if *R < 2||*R > 6{return _ca .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0052 \u0028\u0025\u0064\u0029",*R );
};_dg .R =int (*R );O ,_ffge :=_gcfg .GetString ("\u004f");if !_ffge {return _d .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u004f");};if _dg .R ==5||_dg .R ==6{if len (O )< 48{return _ca .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u004f\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (O ));
};}else if len (O )!=32{return _ca .Errorf ("L\u0065n\u0067\u0074\u0068\u0028\u004f\u0029\u0020\u0021=\u0020\u0033\u0032\u0020(%\u0064\u0029",len (O ));};_dg .O =[]byte (O );U ,_ffge :=_gcfg .GetString ("\u0055");if !_ffge {return _d .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0055");
};if _dg .R ==5||_dg .R ==6{if len (U )< 48{return _ca .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u0055\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (U ));};}else if len (U )!=32{_aab .Log .Debug ("\u0057\u0061r\u006e\u0069\u006e\u0067\u003a\u0020\u004c\u0065\u006e\u0067\u0074\u0068\u0028\u0055\u0029\u0020\u0021\u003d\u0020\u0033\u0032\u0020(%\u0064\u0029",len (U ));
};_dg .U =[]byte (U );if _dg .R >=5{OE ,_fggb :=_gcfg .GetString ("\u004f\u0045");if !_fggb {return _d .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u004f\u0045");
}else if len (OE )!=32{return _ca .Errorf ("L\u0065\u006e\u0067\u0074h(\u004fE\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (OE ));};_dg .OE =[]byte (OE );UE ,_fggb :=_gcfg .GetString ("\u0055\u0045");if !_fggb {return _d .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u0055\u0045");
}else if len (UE )!=32{return _ca .Errorf ("L\u0065\u006e\u0067\u0074h(\u0055E\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (UE ));};_dg .UE =[]byte (UE );};P ,_ffge :=_gcfg .Get ("\u0050").(*PdfObjectInteger );if !_ffge {return _d .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074 \u0064\u0069\u0063t\u0069\u006f\u006e\u0061r\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0070\u0065\u0072\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0061\u0074\u0074\u0072");
};_dg .P =_fbd .Permissions (*P );if _dg .R ==6{Perms ,_dcag :=_gcfg .GetString ("\u0050\u0065\u0072m\u0073");if !_dcag {return _d .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0050\u0065\u0072\u006d\u0073");
}else if len (Perms )!=16{return _ca .Errorf ("\u004ce\u006e\u0067\u0074\u0068\u0028\u0050\u0065\u0072\u006d\u0073\u0029 \u0021\u003d\u0020\u0031\u0036\u0020\u0028\u0025\u0064\u0029",len (Perms ));};_dg .Perms =[]byte (Perms );};if _fcb ,_gef :=_gcfg .Get ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061").(*PdfObjectBool );
_gef {_dg .EncryptMetadata =bool (*_fcb );}else {_dg .EncryptMetadata =true ;};return nil ;};

// Set sets the dictionary's key -> val mapping entry. Overwrites if key already set.
func (_cacg *PdfObjectDictionary )Set (key PdfObjectName ,val PdfObject ){_cacg .setWithLock (key ,val ,true );};

// PdfObjectReference represents the primitive PDF reference object.
type PdfObjectReference struct{_acge *PdfParser ;ObjectNumber int64 ;GenerationNumber int64 ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_egbe *JPXEncoder )MakeDecodeParams ()PdfObject {return nil };

// GetNameVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetNameVal (obj PdfObject )(_bgea string ,_eabag bool ){_eefg ,_eabag :=TraceToDirectObject (obj ).(*PdfObjectName );if _eabag {return string (*_eefg ),true ;};return ;};

// FlattenObject returns the contents of `obj`. In other words, `obj` with indirect objects replaced
// by their values.
// The replacements are made recursively to a depth of traceMaxDepth.
// NOTE: Dicts are sorted to make objects with same contents have the same PDF object strings.
func FlattenObject (obj PdfObject )PdfObject {return _aafc (obj ,0)};

// String returns a string representation of the *PdfObjectString.
func (_ecbf *PdfObjectString )String ()string {return _ecbf ._agadg };func (_aeeg *PdfParser )parsePdfVersion ()(int ,int ,error ){var _aegbb int64 =20;_fgf :=make ([]byte ,_aegbb );_aeeg ._fdeg .Seek (0,_bf .SeekStart );_aeeg ._fdeg .Read (_fgf );var _bgff error ;
var _bggdc ,_egdc int ;if _ddgb :=_gbaea .FindStringSubmatch (string (_fgf ));len (_ddgb )< 3{if _bggdc ,_egdc ,_bgff =_aeeg .seekPdfVersionTopDown ();_bgff !=nil {_aab .Log .Debug ("F\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065\u0063\u006f\u0076\u0065\u0072\u0079\u0020\u002d\u0020\u0075n\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0066\u0069nd\u0020\u0076\u0065r\u0073i\u006f\u006e");
return 0,0,_bgff ;};_aeeg ._fdeg ,_bgff =_geag (_aeeg ._fdeg ,_aeeg .GetFileOffset ()-8);if _bgff !=nil {return 0,0,_bgff ;};}else {if _bggdc ,_bgff =_b .Atoi (_ddgb [1]);_bgff !=nil {return 0,0,_bgff ;};if _egdc ,_bgff =_b .Atoi (_ddgb [2]);_bgff !=nil {return 0,0,_bgff ;
};_aeeg .SetFileOffset (0);};_aeeg ._aaae =_gd .NewReader (_aeeg ._fdeg );_aab .Log .Debug ("\u0050\u0064\u0066\u0020\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020%\u0064\u002e\u0025\u0064",_bggdc ,_egdc );return _bggdc ,_egdc ,nil ;};

// AddPageImage adds the page with the image 'img' to the encoder context in order to encode it jbig2 document.
// The 'settings' defines what encoding type should be used by the encoder.
func (_fcad *JBIG2Encoder )AddPageImage (img *JBIG2Image ,settings *JBIG2EncoderSettings )(_gbc error ){const _aebf ="\u004a\u0042\u0049\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0041\u0064\u0064\u0050\u0061\u0067\u0065\u0049m\u0061\u0067\u0065";
if _fcad ==nil {return _ba .Error (_aebf ,"J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u0020\u0069\u0073 n\u0069\u006c");};if settings ==nil {settings =&_fcad .DefaultPageSettings ;};if _fcad ._faeb ==nil {_fcad ._faeb =_bbe .InitEncodeDocument (settings .FileMode );
};if _gbc =settings .Validate ();_gbc !=nil {return _ba .Wrap (_gbc ,_aebf ,"");};_cafd ,_gbc :=img .toBitmap ();if _gbc !=nil {return _ba .Wrap (_gbc ,_aebf ,"");};switch settings .Compression {case JB2Generic :if _gbc =_fcad ._faeb .AddGenericPage (_cafd ,settings .DuplicatedLinesRemoval );
_gbc !=nil {return _ba .Wrap (_gbc ,_aebf ,"");};case JB2SymbolCorrelation :return _ba .Error (_aebf ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
case JB2SymbolRankHaus :return _ba .Error (_aebf ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
default:return _ba .Error (_aebf ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_ggc *LZWEncoder )MakeStreamDict ()*PdfObjectDictionary {_bgee :=MakeDict ();_bgee .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_ggc .GetFilterName ()));_cda :=_ggc .MakeDecodeParams ();if _cda !=nil {_bgee .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_cda );
};_bgee .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (int64 (_ggc .EarlyChange )));return _bgee ;};

// HasNonConformantStream implements core.ParserMetadata.
func (_bacf ParserMetadata )HasNonConformantStream ()bool {return _bacf ._bceb };

// GetBool returns the *PdfObjectBool object that is represented by a PdfObject directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetBool (obj PdfObject )(_fcee *PdfObjectBool ,_gbbfb bool ){_fcee ,_gbbfb =TraceToDirectObject (obj ).(*PdfObjectBool );return _fcee ,_gbbfb ;};

// EncodeBytes DCT encodes the passed in slice of bytes.
func (_decb *DCTEncoder )EncodeBytes (data []byte )([]byte ,error ){var _dgebb _ab .Image ;if _decb .ColorComponents ==1&&_decb .BitsPerComponent ==8{_dgebb =&_ab .Gray {Rect :_ab .Rect (0,0,_decb .Width ,_decb .Height ),Pix :data ,Stride :_gdd .BytesPerLine (_decb .Width ,_decb .BitsPerComponent ,_decb .ColorComponents )};
}else {var _fcdf error ;_dgebb ,_fcdf =_gdd .NewImage (_decb .Width ,_decb .Height ,_decb .BitsPerComponent ,_decb .ColorComponents ,data ,nil ,nil );if _fcdf !=nil {return nil ,_fcdf ;};};_cfbbd :=_aa .Options {};_cfbbd .Quality =_decb .Quality ;var _bega _abb .Buffer ;
if _afaf :=_aa .Encode (&_bega ,_dgebb ,&_cfbbd );_afaf !=nil {return nil ,_afaf ;};return _bega .Bytes (),nil ;};

// DecodeStream decodes RunLengthEncoded stream object and give back decoded bytes.
func (_fge *RunLengthEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _fge .DecodeBytes (streamObj .Stream );};

// EncodeBytes encodes data into ASCII85 encoded format.
func (_abea *ASCII85Encoder )EncodeBytes (data []byte )([]byte ,error ){var _ccbb _abb .Buffer ;for _afaea :=0;_afaea < len (data );_afaea +=4{_gfff :=data [_afaea ];_gdba :=1;_bedd :=byte (0);if _afaea +1< len (data ){_bedd =data [_afaea +1];_gdba ++;
};_ebcaf :=byte (0);if _afaea +2< len (data ){_ebcaf =data [_afaea +2];_gdba ++;};_gcdc :=byte (0);if _afaea +3< len (data ){_gcdc =data [_afaea +3];_gdba ++;};_egag :=(uint32 (_gfff )<<24)|(uint32 (_bedd )<<16)|(uint32 (_ebcaf )<<8)|uint32 (_gcdc );if _egag ==0{_ccbb .WriteByte ('z');
}else {_egdgd :=_abea .base256Tobase85 (_egag );for _ ,_gefg :=range _egdgd [:_gdba +1]{_ccbb .WriteByte (_gefg +'!');};};};_ccbb .WriteString ("\u007e\u003e");return _ccbb .Bytes (),nil ;};

// PdfObjectFloat represents the primitive PDF floating point numerical object.
type PdfObjectFloat float64 ;

// GetDict returns the *PdfObjectDictionary represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetDict (obj PdfObject )(_gbea *PdfObjectDictionary ,_bgaa bool ){_gbea ,_bgaa =TraceToDirectObject (obj ).(*PdfObjectDictionary );return _gbea ,_bgaa ;};

// RunLengthEncoder represents Run length encoding.
type RunLengthEncoder struct{};

// MakeDecodeParams makes a new instance of an encoding dictionary based on the current encoder settings.
func (_affb *JBIG2Encoder )MakeDecodeParams ()PdfObject {return MakeDict ()};

// NewFlateEncoder makes a new flate encoder with default parameters, predictor 1 and bits per component 8.
func NewFlateEncoder ()*FlateEncoder {_eeaa :=&FlateEncoder {};_eeaa .Predictor =1;_eeaa .BitsPerComponent =8;_eeaa .Colors =1;_eeaa .Columns =1;return _eeaa ;};

// GetArray returns the *PdfObjectArray represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetArray (obj PdfObject )(_agedc *PdfObjectArray ,_baac bool ){_agedc ,_baac =TraceToDirectObject (obj ).(*PdfObjectArray );return _agedc ,_baac ;};

// Len returns the number of elements in the streams.
func (_bgae *PdfObjectStreams )Len ()int {if _bgae ==nil {return 0;};return len (_bgae ._cgaag );};func _ebdge (_gbdb *PdfObjectStream ,_abcc *MultiEncoder )(*DCTEncoder ,error ){_efda :=NewDCTEncoder ();_gac :=_gbdb .PdfObjectDictionary ;if _gac ==nil {return _efda ,nil ;
};_dgda :=_gbdb .Stream ;if _abcc !=nil {_gegd ,_bccf :=_abcc .DecodeBytes (_dgda );if _bccf !=nil {return nil ,_bccf ;};_dgda =_gegd ;};_bea :=_abb .NewReader (_dgda );_gcaf ,_eagb :=_aa .DecodeConfig (_bea );if _eagb !=nil {_aab .Log .Debug ("\u0045\u0072\u0072or\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0065\u003a\u0020\u0025\u0073",_eagb );
return nil ,_eagb ;};switch _gcaf .ColorModel {case _bc .RGBAModel :_efda .BitsPerComponent =8;_efda .ColorComponents =3;case _bc .RGBA64Model :_efda .BitsPerComponent =16;_efda .ColorComponents =3;case _bc .GrayModel :_efda .BitsPerComponent =8;_efda .ColorComponents =1;
case _bc .Gray16Model :_efda .BitsPerComponent =16;_efda .ColorComponents =1;case _bc .CMYKModel :_efda .BitsPerComponent =8;_efda .ColorComponents =4;case _bc .YCbCrModel :_efda .BitsPerComponent =8;_efda .ColorComponents =3;default:return nil ,_d .New ("\u0075\u006e\u0073up\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u006d\u006f\u0064\u0065\u006c");
};_efda .Width =_gcaf .Width ;_efda .Height =_gcaf .Height ;_aab .Log .Trace ("\u0044\u0043T\u0020\u0045\u006ec\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076",_efda );_efda .Quality =DefaultJPEGQuality ;return _efda ,nil ;};

// NewEncoderFromStream creates a StreamEncoder based on the stream's dictionary.
func NewEncoderFromStream (streamObj *PdfObjectStream )(StreamEncoder ,error ){_bbbcg :=TraceToDirectObject (streamObj .PdfObjectDictionary .Get ("\u0046\u0069\u006c\u0074\u0065\u0072"));if _bbbcg ==nil {return NewRawEncoder (),nil ;};if _ ,_cddff :=_bbbcg .(*PdfObjectNull );
_cddff {return NewRawEncoder (),nil ;};_bfceb ,_ebdb :=_bbbcg .(*PdfObjectName );if !_ebdb {_fgfa ,_afgc :=_bbbcg .(*PdfObjectArray );if !_afgc {return nil ,_ca .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006f\u0072 \u0041\u0072\u0072\u0061\u0079\u0020\u006fb\u006a\u0065\u0063\u0074");
};if _fgfa .Len ()==0{return NewRawEncoder (),nil ;};if _fgfa .Len ()!=1{_gagc ,_bcgff :=_fggaa (streamObj );if _bcgff !=nil {_aab .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0063\u0072\u0065\u0061\u0074\u0069\u006e\u0067\u0020\u006d\u0075\u006c\u0074i\u0020\u0065\u006e\u0063\u006f\u0064\u0065r\u003a\u0020\u0025\u0076",_bcgff );
return nil ,_bcgff ;};_aab .Log .Trace ("\u004d\u0075\u006c\u0074\u0069\u0020\u0065\u006e\u0063:\u0020\u0025\u0073\u000a",_gagc );return _gagc ,nil ;};_bbbcg =_fgfa .Get (0);_bfceb ,_afgc =_bbbcg .(*PdfObjectName );if !_afgc {return nil ,_ca .Errorf ("\u0066\u0069l\u0074\u0065\u0072\u0020a\u0072\u0072a\u0079\u0020\u006d\u0065\u006d\u0062\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006fb\u006a\u0065\u0063\u0074");
};};if _aeeec ,_dad :=_gbbfa .Load (_bfceb .String ());_dad {return _aeeec .(StreamEncoder ),nil ;};switch *_bfceb {case StreamEncodingFilterNameFlate :return _aba (streamObj ,nil );case StreamEncodingFilterNameLZW :return _fegd (streamObj ,nil );case StreamEncodingFilterNameDCT :return _ebdge (streamObj ,nil );
case StreamEncodingFilterNameRunLength :return _bec (streamObj ,nil );case StreamEncodingFilterNameASCIIHex :return NewASCIIHexEncoder (),nil ;case StreamEncodingFilterNameASCII85 ,"\u0041\u0038\u0035":return NewASCII85Encoder (),nil ;case StreamEncodingFilterNameCCITTFax :return _dggg (streamObj ,nil );
case StreamEncodingFilterNameJBIG2 :return _dbbb (streamObj ,nil );case StreamEncodingFilterNameJPX :return NewJPXEncoder (),nil ;};_aab .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064\u0069\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006fd\u0021");
return nil ,_ca .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064i\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006f\u0064\u0020\u0028\u0025\u0073\u0029",*_bfceb );};

// ToIntegerArray returns a slice of all array elements as an int slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_egaf *PdfObjectArray )ToIntegerArray ()([]int ,error ){var _eabfe []int ;for _ ,_bgbf :=range _egaf .Elements (){if _ddgfb ,_cebgc :=_bgbf .(*PdfObjectInteger );_cebgc {_eabfe =append (_eabfe ,int (*_ddgfb ));}else {return nil ,ErrTypeError ;};};
return _eabfe ,nil ;};func (_abdg *PdfParser )parseName ()(PdfObjectName ,error ){var _aefe _abb .Buffer ;_fbgad :=false ;for {_cggc ,_bddg :=_abdg ._aaae .Peek (1);if _bddg ==_bf .EOF {break ;};if _bddg !=nil {return PdfObjectName (_aefe .String ()),_bddg ;
};if !_fbgad {if _cggc [0]=='/'{_fbgad =true ;_abdg ._aaae .ReadByte ();}else if _cggc [0]=='%'{_abdg .readComment ();_abdg .skipSpaces ();}else {_aab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020N\u0061\u006d\u0065\u0020\u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020w\u0069\u0074\u0068\u0020\u0025\u0073\u0020(\u0025\u0020\u0078\u0029",_cggc ,_cggc );
return PdfObjectName (_aefe .String ()),_ca .Errorf ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u006ea\u006d\u0065:\u0020\u0028\u0025\u0063\u0029",_cggc [0]);};}else {if IsWhiteSpace (_cggc [0]){break ;}else if (_cggc [0]=='/')||(_cggc [0]=='[')||(_cggc [0]=='(')||(_cggc [0]==']')||(_cggc [0]=='<')||(_cggc [0]=='>'){break ;
}else if _cggc [0]=='#'{_bddc ,_gedde :=_abdg ._aaae .Peek (3);if _gedde !=nil {return PdfObjectName (_aefe .String ()),_gedde ;};_ccbg ,_gedde :=_g .DecodeString (string (_bddc [1:3]));if _gedde !=nil {_aab .Log .Debug ("\u0045\u0052\u0052\u004fR\u003a\u0020\u0049\u006ev\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0066o\u006c\u006co\u0077\u0069\u006e\u0067 \u0027\u0023\u0027\u002c \u0063\u006f\u006e\u0074\u0069n\u0075\u0069\u006e\u0067\u0020\u0075\u0073i\u006e\u0067\u0020\u006c\u0069t\u0065\u0072\u0061\u006c\u0020\u002d\u0020\u004f\u0075t\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074");
_aefe .WriteByte ('#');_abdg ._aaae .Discard (1);continue ;};_abdg ._aaae .Discard (3);_aefe .Write (_ccbg );}else {_fdddd ,_ :=_abdg ._aaae .ReadByte ();_aefe .WriteByte (_fdddd );};};};return PdfObjectName (_aefe .String ()),nil ;};func _dafga ()string {return _aab .Version };
func (_gbg *PdfParser )repairLocateXref ()(int64 ,error ){_efdga :=int64 (1000);_gbg ._fdeg .Seek (-_efdga ,_bf .SeekCurrent );_bcac ,_fdbae :=_gbg ._fdeg .Seek (0,_bf .SeekCurrent );if _fdbae !=nil {return 0,_fdbae ;};_fgeg :=make ([]byte ,_efdga );_gbg ._fdeg .Read (_fgeg );
_efag :=_gbefc .FindAllStringIndex (string (_fgeg ),-1);if len (_efag )< 1{_aab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0065\u0070a\u0069\u0072\u003a\u0020\u0078\u0072\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021");
return 0,_d .New ("\u0072\u0065\u0070\u0061ir\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064");};_cdfa :=int64 (_efag [len (_efag )-1][0]);_accb :=_bcac +_cdfa ;return _accb ,nil ;};

// Encrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_accd *PdfCrypt )Encrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _accd .isEncrypted (obj ){return nil ;};switch _ebd :=obj .(type ){case *PdfIndirectObject :_accd ._fga [_ebd ]=true ;_aab .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_ebd .ObjectNumber ,_ebd .GenerationNumber );
_fcge :=_ebd .ObjectNumber ;_gbf :=_ebd .GenerationNumber ;_edcc :=_accd .Encrypt (_ebd .PdfObject ,_fcge ,_gbf );if _edcc !=nil {return _edcc ;};return nil ;case *PdfObjectStream :_accd ._fga [_ebd ]=true ;_fec :=_ebd .PdfObjectDictionary ;if _eacg ,_cegd :=_fec .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );
_cegd &&*_eacg =="\u0058\u0052\u0065\u0066"{return nil ;};_cgg :=_ebd .ObjectNumber ;_cbaf :=_ebd .GenerationNumber ;_aab .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_cgg ,_cbaf );
_eaeb :=_ee ;if _accd ._dab .V >=4{_eaeb =_accd ._bdb ;_aab .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_accd ._bdb );if _bgf ,_ffe :=_fec .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );
_ffe {if _cab ,_dfa :=GetName (_bgf .Get (0));_dfa {if *_cab =="\u0043\u0072\u0079p\u0074"{_eaeb ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _fdd ,_gfad :=_fec .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );
_gfad {if _fcc ,_bagg :=_fdd .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_bagg {if _ ,_cacb :=_accd ._egg [string (*_fcc )];_cacb {_aab .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_fcc );
_eaeb =string (*_fcc );};};};};};};_aab .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_eaeb );if _eaeb =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_efgc :=_accd .Encrypt (_ebd .PdfObjectDictionary ,_cgg ,_cbaf );
if _efgc !=nil {return _efgc ;};_cgdc ,_efgc :=_accd .makeKey (_eaeb ,uint32 (_cgg ),uint32 (_cbaf ),_accd ._afdc );if _efgc !=nil {return _efgc ;};_ebd .Stream ,_efgc =_accd .encryptBytes (_ebd .Stream ,_eaeb ,_cgdc );if _efgc !=nil {return _efgc ;};_fec .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_ebd .Stream ))));
return nil ;case *PdfObjectString :_aab .Log .Trace ("\u0045n\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_ebdg :=_ee ;if _accd ._dab .V >=4{_aab .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_accd ._aeac );
if _accd ._aeac =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_ebdg =_accd ._aeac ;};_dcg ,_afdcc :=_accd .makeKey (_ebdg ,uint32 (parentObjNum ),uint32 (parentGenNum ),_accd ._afdc );if _afdcc !=nil {return _afdcc ;};_ebg :=_ebd .Str ();
_bfac :=make ([]byte ,len (_ebg ));for _afdf :=0;_afdf < len (_ebg );_afdf ++{_bfac [_afdf ]=_ebg [_afdf ];};_aab .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_bfac ,_bfac );
_bfac ,_afdcc =_accd .encryptBytes (_bfac ,_ebdg ,_dcg );if _afdcc !=nil {return _afdcc ;};_ebd ._agadg =string (_bfac );return nil ;case *PdfObjectArray :for _ ,_ebgb :=range _ebd .Elements (){_afde :=_accd .Encrypt (_ebgb ,parentObjNum ,parentGenNum );
if _afde !=nil {return _afde ;};};return nil ;case *PdfObjectDictionary :_cada :=false ;if _deee :=_ebd .Get ("\u0054\u0079\u0070\u0065");_deee !=nil {_ecg ,_cgee :=_deee .(*PdfObjectName );if _cgee &&*_ecg =="\u0053\u0069\u0067"{_cada =true ;};};for _ ,_bcc :=range _ebd .Keys (){_cdce :=_ebd .Get (_bcc );
if _cada &&string (_bcc )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;};if string (_bcc )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_bcc )!="\u0050\u0072\u0065\u0076"&&string (_bcc )!="\u004c\u0061\u0073\u0074"{_bbf :=_accd .Encrypt (_cdce ,parentObjNum ,parentGenNum );
if _bbf !=nil {return _bbf ;};};};return nil ;};return nil ;};

// GetAccessPermissions returns the PDF access permissions as an AccessPermissions object.
func (_aegb *PdfCrypt )GetAccessPermissions ()_fbd .Permissions {return _aegb ._fca .P };

// WriteString outputs the object as it is to be written to file.
func (_abad *PdfObjectArray )WriteString ()string {var _feef _gg .Builder ;_feef .WriteString ("\u005b");for _dabb ,_dedd :=range _abad .Elements (){_feef .WriteString (_dedd .WriteString ());if _dabb < (_abad .Len ()-1){_feef .WriteString ("\u0020");};
};_feef .WriteString ("\u005d");return _feef .String ();};func (_abage *PdfParser )inspect ()(map[string ]int ,error ){_aab .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0053P\u0045\u0043\u0054\u0020\u002d\u002d\u002d\u002d\u002d\u002d-\u002d\u002d\u002d");
_aab .Log .Trace ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");_dafdg :=map[string ]int {};_cfbe :=0;_gedg :=0;var _adbd []int ;for _degc :=range _abage ._feabg .ObjectMap {_adbd =append (_adbd ,_degc );};_f .Ints (_adbd );_cbcd :=0;
for _ ,_gfaa :=range _adbd {_dbfed :=_abage ._feabg .ObjectMap [_gfaa ];if _dbfed .ObjectNumber ==0{continue ;};_cfbe ++;_aab .Log .Trace ("\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d");_aab .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0075\u0070\u0020\u006f\u0062\u006a\u0065c\u0074 \u006e\u0075\u006d\u0062\u0065\u0072\u003a \u0025\u0064",_dbfed .ObjectNumber );
_egdcd ,_gdda :=_abage .LookupByNumber (_dbfed .ObjectNumber );if _gdda !=nil {_aab .Log .Trace ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u006c\u006f\u006f\u006b\u0075p\u0020\u006f\u0062\u006a\u0020\u0025\u0064 \u0028\u0025\u0073\u0029",_dbfed .ObjectNumber ,_gdda );
_gedg ++;continue ;};_aab .Log .Trace ("\u006fb\u006a\u003a\u0020\u0025\u0073",_egdcd );_aeagce ,_bdab :=_egdcd .(*PdfIndirectObject );if _bdab {_aab .Log .Trace ("\u0049N\u0044 \u004f\u004f\u0042\u004a\u0020\u0025\u0064\u003a\u0020\u0025\u0073",_dbfed .ObjectNumber ,_aeagce );
_dbfbc ,_acded :=_aeagce .PdfObject .(*PdfObjectDictionary );if _acded {if _bedgb ,_abbcb :=_dbfbc .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_abbcb {_gbbff :=string (*_bedgb );_aab .Log .Trace ("\u002d\u002d\u002d\u003e\u0020\u004f\u0062\u006a\u0020\u0074\u0079\u0070e\u003a\u0020\u0025\u0073",_gbbff );
_ ,_cbafa :=_dafdg [_gbbff ];if _cbafa {_dafdg [_gbbff ]++;}else {_dafdg [_gbbff ]=1;};}else if _ebbb ,_bebba :=_dbfbc .Get ("\u0053u\u0062\u0074\u0079\u0070\u0065").(*PdfObjectName );_bebba {_eabae :=string (*_ebbb );_aab .Log .Trace ("-\u002d-\u003e\u0020\u004f\u0062\u006a\u0020\u0073\u0075b\u0074\u0079\u0070\u0065: \u0025\u0073",_eabae );
_ ,_fbaf :=_dafdg [_eabae ];if _fbaf {_dafdg [_eabae ]++;}else {_dafdg [_eabae ]=1;};};if _bfcg ,_egege :=_dbfbc .Get ("\u0053").(*PdfObjectName );_egege &&*_bfcg =="\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"{_ ,_gedge :=_dafdg ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"];
if _gedge {_dafdg ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]++;}else {_dafdg ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]=1;};};};}else if _gceaf ,_acbf :=_egdcd .(*PdfObjectStream );_acbf {if _cfceb ,_bbdc :=_gceaf .PdfObjectDictionary .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );
_bbdc {_aab .Log .Trace ("\u002d\u002d\u003e\u0020\u0053\u0074\u0072\u0065\u0061\u006d\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073",*_cfceb );_dfcf :=string (*_cfceb );_dafdg [_dfcf ]++;};}else {_bggfe ,_adcb :=_egdcd .(*PdfObjectDictionary );
if _adcb {_dbega ,_gdfcg :=_bggfe .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if _gdfcg {_bacd :=string (*_dbega );_aab .Log .Trace ("\u002d-\u002d \u006f\u0062\u006a\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073",_bacd );_dafdg [_bacd ]++;};
};_aab .Log .Trace ("\u0044\u0049\u0052\u0045\u0043\u0054\u0020\u004f\u0042\u004a\u0020\u0025d\u003a\u0020\u0025\u0073",_dbfed .ObjectNumber ,_egdcd );};_cbcd ++;};_aab .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0045\u004fF\u0020\u0049\u004e\u0053\u0050\u0045\u0043T\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d");
_aab .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");_aab .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074 \u0063\u006f\u0075\u006e\u0074\u003a\u0020\u0025\u0064",_cfbe );_aab .Log .Trace ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u006f\u006b\u0075p\u003a\u0020\u0025\u0064",_gedg );
for _egdab ,_bbae :=range _dafdg {_aab .Log .Trace ("\u0025\u0073\u003a\u0020\u0025\u0064",_egdab ,_bbae );};_aab .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");if len (_abage ._feabg .ObjectMap )< 1{_aab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0068\u0069\u0073 \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074 \u0069s\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0028\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0021\u0029");
return nil ,_ca .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0064\u006fc\u0075\u006d\u0065\u006e\u0074\u0020\u0028\u0078r\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006d\u0069\u0073s\u0069\u006e\u0067\u0029");};_cadbg ,_dfab :=_dafdg ["\u0046\u006f\u006e\u0074"];
if !_dfab ||_cadbg < 2{_aab .Log .Trace ("\u0054\u0068\u0069s \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020i\u0073 \u0070r\u006fb\u0061\u0062\u006c\u0079\u0020\u0073\u0063\u0061\u006e\u006e\u0065\u0064\u0021");}else {_aab .Log .Trace ("\u0054\u0068\u0069\u0073\u0020\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020\u0069\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0066o\u0072\u0020\u0065\u0078\u0074r\u0061\u0063t\u0069\u006f\u006e\u0021");
};return _dafdg ,nil ;};

// MakeInteger creates a PdfObjectInteger from an int64.
func MakeInteger (val int64 )*PdfObjectInteger {_dbege :=PdfObjectInteger (val );return &_dbege };

// Elements returns a slice of the PdfObject elements in the array.
func (_bfbba *PdfObjectArray )Elements ()[]PdfObject {if _bfbba ==nil {return nil ;};return _bfbba ._beea ;};

// PdfObjectNull represents the primitive PDF null object.
type PdfObjectNull struct{};func _aafc (_ffcfc PdfObject ,_ceba int )PdfObject {if _ceba > _ebaaa {_aab .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_ebaaa );
return MakeNull ();};switch _bbaa :=_ffcfc .(type ){case *PdfIndirectObject :_ffcfc =_aafc ((*_bbaa ).PdfObject ,_ceba +1);case *PdfObjectArray :for _defa ,_gfade :=range (*_bbaa )._beea {(*_bbaa )._beea [_defa ]=_aafc (_gfade ,_ceba +1);};case *PdfObjectDictionary :for _dffb ,_fbag :=range (*_bbaa )._abegb {(*_bbaa )._abegb [_dffb ]=_aafc (_fbag ,_ceba +1);
};_f .Slice ((*_bbaa )._eegb ,func (_bbga ,_fbfgd int )bool {return (*_bbaa )._eegb [_bbga ]< (*_bbaa )._eegb [_fbfgd ]});};return _ffcfc ;};

// DecodeBytes decodes the CCITTFax encoded image data.
func (_ggdc *CCITTFaxEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_edg :=&_ae .Encoder {K :_ggdc .K ,Columns :_ggdc .Columns ,EndOfLine :_ggdc .EndOfLine ,EndOfBlock :_ggdc .EndOfBlock ,BlackIs1 :_ggdc .BlackIs1 ,DamagedRowsBeforeError :_ggdc .DamagedRowsBeforeError ,Rows :_ggdc .Rows ,EncodedByteAlign :_ggdc .EncodedByteAlign };
_eef ,_dcfc :=_edg .Decode (encoded );if _dcfc !=nil {return nil ,_dcfc ;};var _babe []byte ;_ebbf :=0;var _bdbf byte ;var _fbed byte ;for _fceb :=range _eef {if _bdbf !=0{_babe =append (_babe ,_fbed );_fbed =0;_ebbf ++;_bdbf =0;};for _faab :=range _eef [_fceb ]{_fbed |=_eef [_fceb ][_faab ]<<(7-_bdbf );
_bdbf ++;if _bdbf ==8{_babe =append (_babe ,_fbed );_fbed =0;_ebbf ++;_bdbf =0;};};};if _bdbf > 0{_babe =append (_babe ,_fbed );};return _babe ,nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_gacd *ASCIIHexEncoder )UpdateParams (params *PdfObjectDictionary ){};

// NewCompliancePdfParser creates a new PdfParser that will parse input reader with the focus on extracting more metadata, which
// might affect performance of the regular PdfParser this function.
func NewCompliancePdfParser (rs _bf .ReadSeeker )(_cabc *PdfParser ,_fgde error ){_cabc =&PdfParser {_fdeg :rs ,ObjCache :make (objectCache ),_cggec :map[int64 ]bool {},_ffeg :true };if _fgde =_cabc .parseDetailedHeader ();_fgde !=nil {return nil ,_fgde ;
};if _cabc ._daeb ,_fgde =_cabc .loadXrefs ();_fgde !=nil {_aab .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020F\u0061\u0069\u006c\u0065d t\u006f l\u006f\u0061\u0064\u0020\u0078\u0072\u0065f \u0074\u0061\u0062\u006c\u0065\u0021\u0020%\u0073",_fgde );return nil ,_fgde ;
};_aab .Log .Trace ("T\u0072\u0061\u0069\u006c\u0065\u0072\u003a\u0020\u0025\u0073",_cabc ._daeb );if len (_cabc ._feabg .ObjectMap )==0{return nil ,_ca .Errorf ("\u0065\u006d\u0070\u0074\u0079\u0020\u0058\u0052\u0045\u0046\u0020t\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0049\u006e\u0076a\u006c\u0069\u0064");
};return _cabc ,nil ;};

// MakeString creates an PdfObjectString from a string.
// NOTE: PDF does not use utf-8 string encoding like Go so `s` will often not be a utf-8 encoded
// string.
func MakeString (s string )*PdfObjectString {_ggec :=PdfObjectString {_agadg :s };return &_ggec };

// JBIG2EncoderSettings contains the parameters and settings used by the JBIG2Encoder.
// Current version works only on JB2Generic compression.
type JBIG2EncoderSettings struct{

// FileMode defines if the jbig2 encoder should return full jbig2 file instead of
// shortened pdf mode. This adds the file header to the jbig2 definition.
FileMode bool ;

// Compression is the setting that defines the compression type used for encoding the page.
Compression JBIG2CompressionType ;

// DuplicatedLinesRemoval code generic region in a way such that if the lines are duplicated the encoder
// doesn't store it twice.
DuplicatedLinesRemoval bool ;

// DefaultPixelValue is the bit value initial for every pixel in the page.
DefaultPixelValue uint8 ;

// ResolutionX optional setting that defines the 'x' axis input image resolution - used for single page encoding.
ResolutionX int ;

// ResolutionY optional setting that defines the 'y' axis input image resolution - used for single page encoding.
ResolutionY int ;

// Threshold defines the threshold of the image correlation for
// non Generic compression.
// User only for JB2SymbolCorrelation and JB2SymbolRankHaus methods.
// Best results in range [0.7 - 0.98] - the less the better the compression would be
// but the more lossy.
// Default value: 0.95
Threshold float64 ;};func _dbbb (_dbfa *PdfObjectStream ,_bebb *PdfObjectDictionary )(*JBIG2Encoder ,error ){const _ffccf ="\u006ee\u0077\u004a\u0042\u0049G\u0032\u0044\u0065\u0063\u006fd\u0065r\u0046r\u006f\u006d\u0053\u0074\u0072\u0065\u0061m";_bef :=NewJBIG2Encoder ();
_fdbg :=_dbfa .PdfObjectDictionary ;if _fdbg ==nil {return _bef ,nil ;};if _bebb ==nil {_acfde :=_fdbg .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _acfde !=nil {switch _gaafd :=_acfde .(type ){case *PdfObjectDictionary :_bebb =_gaafd ;
case *PdfObjectArray :if _gaafd .Len ()==1{if _bcfc ,_gddfd :=GetDict (_gaafd .Get (0));_gddfd {_bebb =_bcfc ;};};default:_aab .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065P\u0061\u0072\u0061\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064i\u0063\u0074\u0069\u006f\u006e\u0061\u0072y\u0020\u0025\u0023\u0076",_acfde );
return nil ,_ba .Errorf (_ffccf ,"\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050a\u0072m\u0073\u0020\u0074\u0079\u0070\u0065\u003a \u0025\u0054",_gaafd );};};};if _bebb ==nil {return _bef ,nil ;};_bef .UpdateParams (_bebb );
_ebe ,_dcad :=GetStream (_bebb .Get ("\u004a\u0042\u0049G\u0032\u0047\u006c\u006f\u0062\u0061\u006c\u0073"));if !_dcad {return _bef ,nil ;};var _fcfeb error ;_bef .Globals ,_fcfeb =_aeg .DecodeGlobals (_ebe .Stream );if _fcfeb !=nil {_fcfeb =_ba .Wrap (_fcfeb ,_ffccf ,"\u0063\u006f\u0072\u0072u\u0070\u0074\u0065\u0064\u0020\u006a\u0062\u0069\u0067\u0032 \u0065n\u0063\u006f\u0064\u0065\u0064\u0020\u0064a\u0074\u0061");
_aab .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_fcfeb );return nil ,_fcfeb ;};return _bef ,nil ;};

// DecodeStream decodes a multi-encoded stream by passing it through the
// DecodeStream method of the underlying encoders.
func (_egca *MultiEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _egca .DecodeBytes (streamObj .Stream );};

// TraceToDirectObject traces a PdfObject to a direct object.  For example direct objects contained
// in indirect objects (can be double referenced even).
func TraceToDirectObject (obj PdfObject )PdfObject {if _bcea ,_dgab :=obj .(*PdfObjectReference );_dgab {obj =_bcea .Resolve ();};_bcbfg ,_fegf :=obj .(*PdfIndirectObject );_dfc :=0;for _fegf {obj =_bcbfg .PdfObject ;_bcbfg ,_fegf =GetIndirect (obj );_dfc ++;
if _dfc > _ebaaa {_aab .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0072\u0061\u0063\u0065\u0020\u0064\u0065p\u0074\u0068\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u0062\u0065\u0079\u006fn\u0064\u0020\u0025\u0064\u0020\u002d\u0020\u006e\u006f\u0074\u0020\u0067oi\u006e\u0067\u0020\u0064\u0065\u0065\u0070\u0065\u0072\u0021",_ebaaa );
return nil ;};};return obj ;};

// MakeEncodedString creates a PdfObjectString with encoded content, which can be either
// UTF-16BE or PDFDocEncoding depending on whether `utf16BE` is true or false respectively.
func MakeEncodedString (s string ,utf16BE bool )*PdfObjectString {if utf16BE {var _ffdd _abb .Buffer ;_ffdd .Write ([]byte {0xFE,0xFF});_ffdd .WriteString (_gdb .StringToUTF16 (s ));return &PdfObjectString {_agadg :_ffdd .String (),_bgbe :true };};return &PdfObjectString {_agadg :string (_gdb .StringToPDFDocEncoding (s )),_bgbe :false };
};

// StreamEncoder represents the interface for all PDF stream encoders.
type StreamEncoder interface{GetFilterName ()string ;MakeDecodeParams ()PdfObject ;MakeStreamDict ()*PdfObjectDictionary ;UpdateParams (_dcf *PdfObjectDictionary );EncodeBytes (_cfeb []byte )([]byte ,error );DecodeBytes (_ecea []byte )([]byte ,error );
DecodeStream (_eacgc *PdfObjectStream )([]byte ,error );};

// IsWhiteSpace checks if byte represents a white space character.
func IsWhiteSpace (ch byte )bool {if (ch ==0x00)||(ch ==0x09)||(ch ==0x0A)||(ch ==0x0C)||(ch ==0x0D)||(ch ==0x20){return true ;};return false ;};

// Clear resets the dictionary to an empty state.
func (_gbdf *PdfObjectDictionary )Clear (){_gbdf ._eegb =[]PdfObjectName {};_gbdf ._abegb =map[PdfObjectName ]PdfObject {};_gbdf ._aggc =&_c .Mutex {};};func (_eda *PdfParser )lookupObjectViaOS (_eaf int ,_eb int )(PdfObject ,error ){var _aea *_abb .Reader ;
var _eag objectStream ;var _eg bool ;_eag ,_eg =_eda ._bgba [_eaf ];if !_eg {_ede ,_ddg :=_eda .LookupByNumber (_eaf );if _ddg !=nil {_aab .Log .Debug ("\u004d\u0069ss\u0069\u006e\u0067 \u006f\u0062\u006a\u0065ct \u0073tr\u0065\u0061\u006d\u0020\u0077\u0069\u0074h \u006e\u0075\u006d\u0062\u0065\u0072\u0020%\u0064",_eaf );
return nil ,_ddg ;};_ad ,_ega :=_ede .(*PdfObjectStream );if !_ega {return nil ,_d .New ("i\u006e\u0076\u0061\u006cid\u0020o\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d");};if _eda ._gbbg !=nil &&!_eda ._gbbg .isDecrypted (_ad ){return nil ,_d .New ("\u006e\u0065\u0065\u0064\u0020\u0074\u006f\u0020\u0064\u0065\u0063r\u0079\u0070\u0074\u0020\u0074\u0068\u0065\u0020\u0073\u0074r\u0065\u0061\u006d");
};_fg :=_ad .PdfObjectDictionary ;_aab .Log .Trace ("\u0073o\u0020\u0064\u003a\u0020\u0025\u0073\n",_fg .String ());_bba ,_ega :=_fg .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if !_ega {_aab .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0061\u006c\u0077\u0061\u0079\u0073\u0020\u0068\u0061\u0076\u0065\u0020\u0061\u0020\u0054\u0079\u0070\u0065");
return nil ,_d .New ("\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020T\u0079\u0070\u0065");};if _gg .ToLower (string (*_bba ))!="\u006f\u0062\u006a\u0073\u0074\u006d"{_aab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0074\u0079\u0070\u0065\u0020s\u0068\u0061\u006c\u006c\u0020\u0061\u006c\u0077\u0061\u0079\u0073 \u0062\u0065\u0020\u004f\u0062\u006a\u0053\u0074\u006d\u0020\u0021");
return nil ,_d .New ("\u006f\u0062\u006a\u0065c\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0074y\u0070e\u0020\u0021\u003d\u0020\u004f\u0062\u006aS\u0074\u006d");};N ,_ega :=_fg .Get ("\u004e").(*PdfObjectInteger );if !_ega {return nil ,_d .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u004e\u0020i\u006e\u0020\u0073\u0074\u0072\u0065\u0061m\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");
};_fa ,_ega :=_fg .Get ("\u0046\u0069\u0072s\u0074").(*PdfObjectInteger );if !_ega {return nil ,_d .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0046\u0069\u0072\u0073\u0074\u0020i\u006e \u0073t\u0072e\u0061\u006d\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");
};_aab .Log .Trace ("\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0073\u0020\u006eu\u006d\u0062\u0065\u0072\u0020\u006f\u0066 \u006f\u0062\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_bba ,*N );_db ,_ddg :=DecodeStream (_ad );if _ddg !=nil {return nil ,_ddg ;
};_aab .Log .Trace ("D\u0065\u0063\u006f\u0064\u0065\u0064\u003a\u0020\u0025\u0073",_db );_ddb :=_eda .GetFileOffset ();defer func (){_eda .SetFileOffset (_ddb )}();_aea =_abb .NewReader (_db );_eda ._aaae =_gd .NewReader (_aea );_aab .Log .Trace ("\u0050a\u0072s\u0069\u006e\u0067\u0020\u006ff\u0066\u0073e\u0074\u0020\u006d\u0061\u0070");
_ce :=map[int ]int64 {};for _ef :=0;_ef < int (*N );_ef ++{_eda .skipSpaces ();_ac ,_gf :=_eda .parseNumber ();if _gf !=nil {return nil ,_gf ;};_gb ,_bad :=_ac .(*PdfObjectInteger );if !_bad {return nil ,_d .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");
};_eda .skipSpaces ();_ac ,_gf =_eda .parseNumber ();if _gf !=nil {return nil ,_gf ;};_de ,_bad :=_ac .(*PdfObjectInteger );if !_bad {return nil ,_d .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");
};_aab .Log .Trace ("\u006f\u0062j\u0020\u0025\u0064 \u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0025\u0064",*_gb ,*_de );_ce [int (*_gb )]=int64 (*_fa +*_de );};_eag =objectStream {N :int (*N ),_bff :_db ,_bfa :_ce };_eda ._bgba [_eaf ]=_eag ;}else {_da :=_eda .GetFileOffset ();
defer func (){_eda .SetFileOffset (_da )}();_aea =_abb .NewReader (_eag ._bff );_eda ._aaae =_gd .NewReader (_aea );};_cb :=_eag ._bfa [_eb ];_aab .Log .Trace ("\u0041\u0043\u0054\u0055AL\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u005b\u0025\u0064\u005d\u0020\u003d\u0020%\u0064",_eb ,_cb );
_aea .Seek (_cb ,_bf .SeekStart );_eda ._aaae =_gd .NewReader (_aea );_dba ,_ :=_eda ._aaae .Peek (100);_aab .Log .Trace ("\u004f\u0042\u004a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_dba ));_gfa ,_ece :=_eda .parseObject ();
if _ece !=nil {_aab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c \u0074\u006f\u0020\u0072\u0065\u0061\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_ece );return nil ,_ece ;};if _gfa ==nil {return nil ,_d .New ("o\u0062\u006a\u0065\u0063t \u0063a\u006e\u006e\u006f\u0074\u0020b\u0065\u0020\u006e\u0075\u006c\u006c");
};_gee :=PdfIndirectObject {};_gee .ObjectNumber =int64 (_eb );_gee .PdfObject =_gfa ;_gee ._acge =_eda ;return &_gee ,nil ;};

// Set sets the PdfObject at index i of the array. An error is returned if the index is outside bounds.
func (_cegce *PdfObjectArray )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_cegce ._beea ){return _d .New ("\u006f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_cegce ._beea [i ]=obj ;return nil ;};var _fef =[]PdfObjectName {"\u0056","\u0052","\u004f","\u0055","\u0050"};


// CCITTFaxEncoder implements Group3 and Group4 facsimile (fax) encoder/decoder.
type CCITTFaxEncoder struct{K int ;EndOfLine bool ;EncodedByteAlign bool ;Columns int ;Rows int ;EndOfBlock bool ;BlackIs1 bool ;DamagedRowsBeforeError int ;};

// XrefTable represents the cross references in a PDF, i.e. the table of objects and information
// where to access within the PDF file.
type XrefTable struct{ObjectMap map[int ]XrefObject ;_gea []XrefObject ;};

// Clear resets the array to an empty state.
func (_abbe *PdfObjectArray )Clear (){_abbe ._beea =[]PdfObject {}};var _aaca =[]byte ("\u0030\u0031\u0032\u003345\u0036\u0037\u0038\u0039\u0061\u0062\u0063\u0064\u0065\u0066\u0041\u0042\u0043\u0044E\u0046");

// GetFilterName returns the name of the encoding filter.
func (_fcdc *RunLengthEncoder )GetFilterName ()string {return StreamEncodingFilterNameRunLength };

// GetNumberAsFloat returns the contents of `obj` as a float if it is an integer or float, or an
// error if it isn't.
func GetNumberAsFloat (obj PdfObject )(float64 ,error ){switch _bddgg :=obj .(type ){case *PdfObjectFloat :return float64 (*_bddgg ),nil ;case *PdfObjectInteger :return float64 (*_bddgg ),nil ;};return 0,ErrNotANumber ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_gag *FlateEncoder )MakeDecodeParams ()PdfObject {if _gag .Predictor > 1{_gcea :=MakeDict ();_gcea .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_gag .Predictor )));if _gag .BitsPerComponent !=8{_gcea .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_gag .BitsPerComponent )));
};if _gag .Columns !=1{_gcea .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_gag .Columns )));};if _gag .Colors !=1{_gcea .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_gag .Colors )));};return _gcea ;};return nil ;
};

// DecodeImages decodes the page images from the jbig2 'encoded' data input.
// The jbig2 document may contain multiple pages, thus the function can return multiple
// images. The images order corresponds to the page number.
func (_bcdc *JBIG2Encoder )DecodeImages (encoded []byte )([]_ab .Image ,error ){const _egdge ="\u004aB\u0049\u0047\u0032\u0045n\u0063\u006f\u0064\u0065\u0072.\u0044e\u0063o\u0064\u0065\u0049\u006d\u0061\u0067\u0065s";_bgge ,_abbb :=_fcg .Decode (encoded ,_fcg .Parameters {},_bcdc .Globals .ToDocumentGlobals ());
if _abbb !=nil {return nil ,_ba .Wrap (_abbb ,_egdge ,"");};_cefe ,_abbb :=_bgge .PageNumber ();if _abbb !=nil {return nil ,_ba .Wrap (_abbb ,_egdge ,"");};_affc :=[]_ab .Image {};var _dbgfc _ab .Image ;for _eeg :=1;_eeg <=_cefe ;_eeg ++{_dbgfc ,_abbb =_bgge .DecodePageImage (_eeg );
if _abbb !=nil {return nil ,_ba .Wrapf (_abbb ,_egdge ,"\u0070\u0061\u0067\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_eeg );};_affc =append (_affc ,_dbgfc );};return _affc ,nil ;};type xrefType int ;

// Inspect analyzes the document object structure. Returns a map of object types (by name) with the instance count
// as value.
func (_dagg *PdfParser )Inspect ()(map[string ]int ,error ){return _dagg .inspect ()};func (_fffdb *PdfParser )parseXref ()(*PdfObjectDictionary ,error ){const _gdeg =20;_ebaad ,_ :=_fffdb ._aaae .Peek (_gdeg );for _cebe :=0;_cebe < 2;_cebe ++{if _fffdb ._fedcb ==0{_fffdb ._fedcb =_fffdb .GetFileOffset ();
};if _bbefd .Match (_ebaad ){_aab .Log .Trace ("\u0078\u0072e\u0066\u0020\u0070\u006f\u0069\u006e\u0074\u0073\u0020\u0074\u006f\u0020\u0061\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u002e\u0020\u0050\u0072\u006f\u0062\u0061\u0062\u006c\u0079\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063\u0074");
_aab .Log .Debug ("\u0073t\u0061r\u0074\u0069\u006e\u0067\u0020w\u0069\u0074h\u0020\u0022\u0025\u0073\u0022",string (_ebaad ));return _fffdb .parseXrefStream (nil );};if _cbefc .Match (_ebaad ){_aab .Log .Trace ("\u0053\u0074\u0061\u006ed\u0061\u0072\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073e\u0063t\u0069\u006f\u006e\u0020\u0074\u0061\u0062l\u0065\u0021");
return _fffdb .parseXrefTable ();};_dcfg :=_fffdb .GetFileOffset ();if _fffdb ._fedcb ==0{_fffdb ._fedcb =_dcfg ;};_fffdb .SetFileOffset (_dcfg -_gdeg );defer _fffdb .SetFileOffset (_dcfg );_fegdd ,_ :=_fffdb ._aaae .Peek (_gdeg );_ebaad =append (_fegdd ,_ebaad ...);
};_aab .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u0078\u0072\u0065f\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006fr\u0020\u0073\u0074\u0072\u0065\u0061\u006d.\u0020\u0052\u0065\u0070\u0061i\u0072\u0020\u0061\u0074\u0074e\u006d\u0070\u0074\u0065\u0064\u003a\u0020\u004c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0065\u0061\u0072\u006c\u0069\u0065\u0073\u0074\u0020x\u0072\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u0062\u006f\u0074to\u006d\u002e");
if _affg :=_fffdb .repairSeekXrefMarker ();_affg !=nil {_aab .Log .Debug ("\u0052e\u0070a\u0069\u0072\u0020\u0066\u0061i\u006c\u0065d\u0020\u002d\u0020\u0025\u0076",_affg );return nil ,_affg ;};return _fffdb .parseXrefTable ();};

// EncodeBytes encodes slice of bytes into JBIG2 encoding format.
// The input 'data' must be an image. In order to Decode it a user is responsible to
// load the codec ('png', 'jpg').
// Returns jbig2 single page encoded document byte slice. The encoder uses DefaultPageSettings
// to encode given image.
func (_beeb *JBIG2Encoder )EncodeBytes (data []byte )([]byte ,error ){const _gfag ="\u004aB\u0049\u0047\u0032\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002eE\u006e\u0063\u006f\u0064\u0065\u0042\u0079\u0074\u0065\u0073";if _beeb .ColorComponents !=1||_beeb .BitsPerComponent !=1{return nil ,_ba .Errorf (_gfag ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u002e\u0020\u004a\u0042\u0049G\u0032\u0020E\u006e\u0063o\u0064\u0065\u0072\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020bi\u006e\u0061\u0072\u0079\u0020\u0069\u006d\u0061\u0067e\u0073\u0020\u0064\u0061\u0074\u0061");
};var (_agab *_edc .Bitmap ;_bgdg error ;);_bcbf :=(_beeb .Width *_beeb .Height )==len (data );if _bcbf {_agab ,_bgdg =_edc .NewWithUnpaddedData (_beeb .Width ,_beeb .Height ,data );}else {_agab ,_bgdg =_edc .NewWithData (_beeb .Width ,_beeb .Height ,data );
};if _bgdg !=nil {return nil ,_bgdg ;};_gdc :=_beeb .DefaultPageSettings ;if _bgdg =_gdc .Validate ();_bgdg !=nil {return nil ,_ba .Wrap (_bgdg ,_gfag ,"");};if _beeb ._faeb ==nil {_beeb ._faeb =_bbe .InitEncodeDocument (_gdc .FileMode );};switch _gdc .Compression {case JB2Generic :if _bgdg =_beeb ._faeb .AddGenericPage (_agab ,_gdc .DuplicatedLinesRemoval );
_bgdg !=nil {return nil ,_ba .Wrap (_bgdg ,_gfag ,"");};case JB2SymbolCorrelation :return nil ,_ba .Error (_gfag ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
case JB2SymbolRankHaus :return nil ,_ba .Error (_gfag ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
default:return nil ,_ba .Error (_gfag ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return _beeb .Encode ();};

// MakeBool creates a PdfObjectBool from a bool value.
func MakeBool (val bool )*PdfObjectBool {_cabf :=PdfObjectBool (val );return &_cabf };

// IsPrintable checks if a character is printable.
// Regular characters that are outside the range EXCLAMATION MARK(21h)
// (!) to TILDE (7Eh) (~) should be written using the hexadecimal notation.
func IsPrintable (c byte )bool {return 0x21<=c &&c <=0x7E};

// WriteString outputs the object as it is to be written to file.
func (_cagb *PdfObjectName )WriteString ()string {var _bca _abb .Buffer ;if len (*_cagb )> 127{_aab .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u004e\u0061\u006d\u0065\u0020t\u006fo\u0020l\u006f\u006e\u0067\u0020\u0028\u0025\u0073)",*_cagb );};_bca .WriteString ("\u002f");
for _eada :=0;_eada < len (*_cagb );_eada ++{_baga :=(*_cagb )[_eada ];if !IsPrintable (_baga )||_baga =='#'||IsDelimiter (_baga ){_bca .WriteString (_ca .Sprintf ("\u0023\u0025\u002e2\u0078",_baga ));}else {_bca .WriteByte (_baga );};};return _bca .String ();
};

// ReadAtLeast reads at least n bytes into slice p.
// Returns the number of bytes read (should always be == n), and an error on failure.
func (_cegfe *PdfParser )ReadAtLeast (p []byte ,n int )(int ,error ){_dfda :=n ;_baef :=0;_dcdg :=0;for _dfda > 0{_afcb ,_eff :=_cegfe ._aaae .Read (p [_baef :]);if _eff !=nil {_aab .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061d\u0069\u006e\u0067\u0020\u0028\u0025\u0064\u003b\u0025\u0064\u0029\u0020\u0025\u0073",_afcb ,_dcdg ,_eff .Error ());
return _baef ,_d .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065a\u0064\u0069\u006e\u0067");};_dcdg ++;_baef +=_afcb ;_dfda -=_afcb ;};return _baef ,nil ;};func _aba (_egfg *PdfObjectStream ,_feac *PdfObjectDictionary )(*FlateEncoder ,error ){_dgf :=NewFlateEncoder ();
_fce :=_egfg .PdfObjectDictionary ;if _fce ==nil {return _dgf ,nil ;};_dgf ._dbgf =_gaafdd (_fce );if _feac ==nil {_eadfb :=TraceToDirectObject (_fce .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));switch _eabg :=_eadfb .(type ){case *PdfObjectArray :if _eabg .Len ()!=1{_aab .Log .Debug ("\u0045\u0072\u0072\u006f\u0072:\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020a\u0072\u0072\u0061\u0079\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0021\u003d\u0020\u0031\u0020\u0028\u0025\u0064\u0029",_eabg .Len ());
return nil ,_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};if _ccf ,_cgde :=GetDict (_eabg .Get (0));_cgde {_feac =_ccf ;};case *PdfObjectDictionary :_feac =_eabg ;case *PdfObjectNull ,nil :default:_aab .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020n\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079 \u0028%\u0054\u0029",_eadfb );
return nil ,_ca .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _feac ==nil {return _dgf ,nil ;};_aab .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_feac .String ());
_bdd :=_feac .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");if _bdd ==nil {_aab .Log .Debug ("E\u0072\u0072o\u0072\u003a\u0020\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067 \u0066\u0072\u006f\u006d\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073 \u002d\u0020\u0043\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020\u0077\u0069t\u0068\u0020\u0064\u0065\u0066\u0061\u0075\u006c\u0074\u0020\u00281\u0029");
}else {_gedab ,_cbd :=_bdd .(*PdfObjectInteger );if !_cbd {_aab .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_bdd );
return nil ,_ca .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_dgf .Predictor =int (*_gedab );};_bdd =_feac .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");
if _bdd !=nil {_dbgfb ,_gedf :=_bdd .(*PdfObjectInteger );if !_gedf {_aab .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");
return nil ,_ca .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_dgf .BitsPerComponent =int (*_dbgfb );};if _dgf .Predictor > 1{_dgf .Columns =1;_bdd =_feac .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");
if _bdd !=nil {_bbef ,_bggd :=_bdd .(*PdfObjectInteger );if !_bggd {return nil ,_ca .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_dgf .Columns =int (*_bbef );
};_dgf .Colors =1;_bdd =_feac .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _bdd !=nil {_eagc ,_abed :=_bdd .(*PdfObjectInteger );if !_abed {return nil ,_ca .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");
};_dgf .Colors =int (*_eagc );};};return _dgf ,nil ;};func _bac (_fgga *_dd .FilterDict ,_bcb *PdfObjectDictionary )error {if _cgc ,_cd :=_bcb .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_cd {if _dfe :=string (*_cgc );_dfe !="C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"{_aab .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020C\u0046\u0020\u0064ic\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074e\u0072\u0029",_dfe );
};};_geb ,_gda :=_bcb .Get ("\u0043\u0046\u004d").(*PdfObjectName );if !_gda {return _ca .Errorf ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0028\u004e\u006f\u006e\u0065\u0029");
};_fgga .CFM =string (*_geb );if _dec ,_gdaa :=_bcb .Get ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et").(*PdfObjectName );_gdaa {_fgga .AuthEvent =_fbd .AuthEvent (*_dec );}else {_fgga .AuthEvent =_fbd .EventDocOpen ;};if _ebb ,_fda :=_bcb .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );
_fda {_fgga .Length =int (*_ebb );};return nil ;};func _dacgb (_agdd ,_ebbeg ,_aaed int )error {if _ebbeg < 0||_ebbeg > _agdd {return _d .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0061\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");
};if _aaed < _ebbeg {return _d .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0073\u006c\u0069\u0063e\u0020i\u006ed\u0065\u0078\u0020\u0062\u0020\u003c\u0020a");};if _aaed > _agdd {return _d .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0062\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");
};return nil ;};

// DecodeStream decodes a LZW encoded stream and returns the result as a
// slice of bytes.
func (_eeec *LZWEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_aab .Log .Trace ("\u004c\u005a\u0057 \u0044\u0065\u0063\u006f\u0064\u0069\u006e\u0067");_aab .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_eeec .Predictor );
_dgb ,_bdgba :=_eeec .DecodeBytes (streamObj .Stream );if _bdgba !=nil {return nil ,_bdgba ;};_aab .Log .Trace ("\u0020\u0049\u004e\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (streamObj .Stream ),streamObj .Stream );_aab .Log .Trace ("\u004f\u0055\u0054\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (_dgb ),_dgb );
if _eeec .Predictor > 1{if _eeec .Predictor ==2{_aab .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_dfgf :=_eeec .Columns *_eeec .Colors ;if _dfgf < 1{return []byte {},nil ;};_fceg :=len (_dgb )/_dfgf ;if len (_dgb )%_dfgf !=0{_aab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");
return nil ,_ca .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_dgb ),_dfgf );};if _dfgf %_eeec .Colors !=0{return nil ,_ca .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_dfgf ,_eeec .Colors );
};if _dfgf > len (_dgb ){_aab .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_dfgf ,len (_dgb ));
return nil ,_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_aab .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_dgb ),_dgb );
_bcge :=_abb .NewBuffer (nil );for _gabf :=0;_gabf < _fceg ;_gabf ++{_aece :=_dgb [_dfgf *_gabf :_dfgf *(_gabf +1)];for _dfdg :=_eeec .Colors ;_dfdg < _dfgf ;_dfdg ++{_aece [_dfdg ]=byte (int (_aece [_dfdg ]+_aece [_dfdg -_eeec .Colors ])%256);};_bcge .Write (_aece );
};_fgaa :=_bcge .Bytes ();_aab .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_fgaa ),_fgaa );return _fgaa ,nil ;}else if _eeec .Predictor >=10&&_eeec .Predictor <=15{_aab .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");
_ggca :=_eeec .Columns *_eeec .Colors +1;if _ggca < 1{return []byte {},nil ;};_bacbc :=len (_dgb )/_ggca ;if len (_dgb )%_ggca !=0{return nil ,_ca .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_dgb ),_ggca );
};if _ggca > len (_dgb ){_aab .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_ggca ,len (_dgb ));
return nil ,_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_ebge :=_abb .NewBuffer (nil );_aab .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_eeec .Columns );
_aab .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_dgb ),_ggca ,_bacbc );_bged :=make ([]byte ,_ggca );for _ddcd :=0;_ddcd < _ggca ;_ddcd ++{_bged [_ddcd ]=0;
};for _eeed :=0;_eeed < _bacbc ;_eeed ++{_gege :=_dgb [_ggca *_eeed :_ggca *(_eeed +1)];_abfg :=_gege [0];switch _abfg {case 0:case 1:for _geba :=2;_geba < _ggca ;_geba ++{_gege [_geba ]=byte (int (_gege [_geba ]+_gege [_geba -1])%256);};case 2:for _agda :=1;
_agda < _ggca ;_agda ++{_gege [_agda ]=byte (int (_gege [_agda ]+_bged [_agda ])%256);};default:_aab .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0066i\u006c\u0074\u0065\u0072\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_abfg );
return nil ,_ca .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_abfg );};for _cgcd :=0;_cgcd < _ggca ;_cgcd ++{_bged [_cgcd ]=_gege [_cgcd ];};_ebge .Write (_gege [1:]);
};_bee :=_ebge .Bytes ();return _bee ,nil ;}else {_aab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_eeec .Predictor );
return nil ,_ca .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_eeec .Predictor );};};return _dgb ,nil ;};

// JBIG2CompressionType defines the enum compression type used by the JBIG2Encoder.
type JBIG2CompressionType int ;func (_eaga *offsetReader )Read (p []byte )(_eeafc int ,_aegfd error ){return _eaga ._afgb .Read (p )};

// IsNullObject returns true if `obj` is a PdfObjectNull.
func IsNullObject (obj PdfObject )bool {_ ,_adcc :=TraceToDirectObject (obj ).(*PdfObjectNull );return _adcc ;};

// GetFilterArray returns the names of the underlying encoding filters in an array that
// can be used as /Filter entry.
func (_dddbb *MultiEncoder )GetFilterArray ()*PdfObjectArray {_abg :=make ([]PdfObject ,len (_dddbb ._dfdb ));for _cff ,_fbea :=range _dddbb ._dfdb {_abg [_cff ]=MakeName (_fbea .GetFilterName ());};return MakeArray (_abg ...);};func _cddcc (_gedc PdfObject )(*float64 ,error ){switch _fcec :=_gedc .(type ){case *PdfObjectFloat :_cfafb :=float64 (*_fcec );
return &_cfafb ,nil ;case *PdfObjectInteger :_cgeeb :=float64 (*_fcec );return &_cgeeb ,nil ;case *PdfObjectNull :return nil ,nil ;};return nil ,ErrNotANumber ;};

// MakeNull creates an PdfObjectNull.
func MakeNull ()*PdfObjectNull {_fccg :=PdfObjectNull {};return &_fccg };

// EncodeBytes encodes the image data using either Group3 or Group4 CCITT facsimile (fax) encoding.
// `data` is expected to be 1 color component, 1 bit per component. It is also valid to provide 8 BPC, 1 CC image like
// a standard go image Gray data.
func (_daff *CCITTFaxEncoder )EncodeBytes (data []byte )([]byte ,error ){var _aaadg _gdd .Gray ;switch len (data ){case _daff .Rows *_daff .Columns :_gdbc ,_cbafc :=_gdd .NewImage (_daff .Columns ,_daff .Rows ,8,1,data ,nil ,nil );if _cbafc !=nil {return nil ,_cbafc ;
};_aaadg =_gdbc .(_gdd .Gray );case (_daff .Columns *_daff .Rows )+7>>3:_dfb ,_dgee :=_gdd .NewImage (_daff .Columns ,_daff .Rows ,1,1,data ,nil ,nil );if _dgee !=nil {return nil ,_dgee ;};_ebbe :=_dfb .(*_gdd .Monochrome );if _dgee =_ebbe .AddPadding ();
_dgee !=nil {return nil ,_dgee ;};_aaadg =_ebbe ;default:if len (data )< _gdd .BytesPerLine (_daff .Columns ,1,1)*_daff .Rows {return nil ,_d .New ("p\u0072\u006f\u0076\u0069\u0064\u0065d\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020i\u006e\u0070\u0075t\u0020d\u0061\u0074\u0061");
};_dabf ,_add :=_gdd .NewImage (_daff .Columns ,_daff .Rows ,1,1,data ,nil ,nil );if _add !=nil {return nil ,_add ;};_faac :=_dabf .(*_gdd .Monochrome );_aaadg =_faac ;};_fgb :=make ([][]byte ,_daff .Rows );for _gdddb :=0;_gdddb < _daff .Rows ;_gdddb ++{_cefba :=make ([]byte ,_daff .Columns );
for _cbdd :=0;_cbdd < _daff .Columns ;_cbdd ++{_feb :=_aaadg .GrayAt (_cbdd ,_gdddb );_cefba [_cbdd ]=_feb .Y >>7;};_fgb [_gdddb ]=_cefba ;};_dgbb :=&_ae .Encoder {K :_daff .K ,Columns :_daff .Columns ,EndOfLine :_daff .EndOfLine ,EndOfBlock :_daff .EndOfBlock ,BlackIs1 :_daff .BlackIs1 ,DamagedRowsBeforeError :_daff .DamagedRowsBeforeError ,Rows :_daff .Rows ,EncodedByteAlign :_daff .EncodedByteAlign };
return _dgbb .Encode (_fgb ),nil ;};

// PdfCryptNewEncrypt makes the document crypt handler based on a specified crypt filter.
func PdfCryptNewEncrypt (cf _dd .Filter ,userPass ,ownerPass []byte ,perm _fbd .Permissions )(*PdfCrypt ,*EncryptInfo ,error ){_eba :=&PdfCrypt {_fga :make (map[PdfObject ]bool ),_egg :make (cryptFilters ),_fca :_fbd .StdEncryptDict {P :perm ,EncryptMetadata :true }};
var _bdc Version ;if cf !=nil {_be :=cf .PDFVersion ();_bdc .Major ,_bdc .Minor =_be [0],_be [1];V ,R :=cf .HandlerVersion ();_eba ._dab .V =V ;_eba ._fca .R =R ;_eba ._dab .Length =cf .KeyLength ()*8;};const (_aeb =_ee ;);_eba ._egg [_aeb ]=cf ;if _eba ._dab .V >=4{_eba ._bdb =_aeb ;
_eba ._aeac =_aeb ;};_cbbb :=_eba .newEncryptDict ();_ged :=_fb .Sum ([]byte (_ec .Now ().Format (_ec .RFC850 )));_dee :=string (_ged [:]);_beg :=make ([]byte ,100);_ag .Read (_beg );_ged =_fb .Sum (_beg );_ff :=string (_ged [:]);_aab .Log .Trace ("\u0052\u0061\u006e\u0064\u006f\u006d\u0020\u0062\u003a\u0020\u0025\u0020\u0078",_beg );
_aab .Log .Trace ("\u0047\u0065\u006e\u0020\u0049\u0064\u0020\u0030\u003a\u0020\u0025\u0020\u0078",_dee );_eba ._fgg =_dee ;_caeb :=_eba .generateParams (userPass ,ownerPass );if _caeb !=nil {return nil ,nil ,_caeb ;};_egaa (&_eba ._fca ,_cbbb );if _eba ._dab .V >=4{if _ffg :=_eba .saveCryptFilters (_cbbb );
_ffg !=nil {return nil ,nil ,_ffg ;};};return _eba ,&EncryptInfo {Version :_bdc ,Encrypt :_cbbb ,ID0 :_dee ,ID1 :_ff },nil ;};

// IsOctalDigit checks if a character can be part of an octal digit string.
func IsOctalDigit (c byte )bool {return '0'<=c &&c <='7'};

// HasInvalidHexRunes implements core.ParserMetadata interface.
func (_cca ParserMetadata )HasInvalidHexRunes ()bool {return _cca ._eaded };func (_bbgf *PdfObjectDictionary )setWithLock (_cdag PdfObjectName ,_cccga PdfObject ,_gebeg bool ){if _gebeg {_bbgf ._aggc .Lock ();defer _bbgf ._aggc .Unlock ();};_ ,_cfdg :=_bbgf ._abegb [_cdag ];
if !_cfdg {_bbgf ._eegb =append (_bbgf ._eegb ,_cdag );};_bbgf ._abegb [_cdag ]=_cccga ;};

// PdfObjectName represents the primitive PDF name object.
type PdfObjectName string ;

// LookupByNumber looks up a PdfObject by object number.  Returns an error on failure.
func (_bce *PdfParser )LookupByNumber (objNumber int )(PdfObject ,error ){_cba ,_ ,_cf :=_bce .lookupByNumberWrapper (objNumber ,true );return _cba ,_cf ;};

// ParserMetadata gets the pdf parser metadata.
func (_ccb *PdfParser )ParserMetadata ()(ParserMetadata ,error ){if !_ccb ._ffeg {return ParserMetadata {},_ca .Errorf ("\u0070\u0061\u0072\u0073\u0065r\u0020\u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u006d\u0061\u0072\u006be\u0064\u0020\u0066\u006f\u0072\u0020\u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0064\u0065\u0074\u0061\u0069\u006c\u0065\u0064\u0020\u006d\u0065\u0074\u0061\u0064\u0061\u0074a");
};return _ccb ._accf ,nil ;};

// GetStringVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetStringVal (obj PdfObject )(_aeaea string ,_gfgc bool ){_dbfef ,_gfgc :=TraceToDirectObject (obj ).(*PdfObjectString );if _gfgc {return _dbfef .Str (),true ;};return ;};

// MakeArrayFromFloats creates an PdfObjectArray from a slice of float64s, where each array element is an
// PdfObjectFloat.
func MakeArrayFromFloats (vals []float64 )*PdfObjectArray {_fcebe :=MakeArray ();for _ ,_febf :=range vals {_fcebe .Append (MakeFloat (_febf ));};return _fcebe ;};

// GetStringBytes is like GetStringVal except that it returns the string as a []byte.
// It is for convenience.
func GetStringBytes (obj PdfObject )(_daed []byte ,_fegfg bool ){_afdg ,_fegfg :=TraceToDirectObject (obj ).(*PdfObjectString );if _fegfg {return _afdg .Bytes (),true ;};return ;};

// GetXrefOffset returns the offset of the xref table.
func (_bcbce *PdfParser )GetXrefOffset ()int64 {return _bcbce ._fedcb };

// GetFilterName returns the name of the encoding filter.
func (_bbdd *RawEncoder )GetFilterName ()string {return StreamEncodingFilterNameRaw };

// MakeStringFromBytes creates an PdfObjectString from a byte array.
// This is more natural than MakeString as `data` is usually not utf-8 encoded.
func MakeStringFromBytes (data []byte )*PdfObjectString {return MakeString (string (data ))};func (_aac *PdfCrypt )decryptBytes (_bgg []byte ,_aaac string ,_aagg []byte )([]byte ,error ){_aab .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");
_agaa ,_cec :=_aac ._egg [_aaac ];if !_cec {return nil ,_ca .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_aaac );};return _agaa .DecryptBytes (_bgg ,_aagg );};

// NewDCTEncoder makes a new DCT encoder with default parameters.
func NewDCTEncoder ()*DCTEncoder {_agdad :=&DCTEncoder {};_agdad .ColorComponents =3;_agdad .BitsPerComponent =8;_agdad .Quality =DefaultJPEGQuality ;return _agdad ;};

// String returns a string describing `d`.
func (_bedc *PdfObjectDictionary )String ()string {var _bbce _gg .Builder ;_bbce .WriteString ("\u0044\u0069\u0063t\u0028");for _ ,_bgfc :=range _bedc ._eegb {_dbada :=_bedc ._abegb [_bgfc ];_bbce .WriteString ("\u0022"+_bgfc .String ()+"\u0022\u003a\u0020");
_bbce .WriteString (_dbada .String ());_bbce .WriteString ("\u002c\u0020");};_bbce .WriteString ("\u0029");return _bbce .String ();};type objectStreams map[int ]objectStream ;func (_gagd *PdfParser )resolveReference (_cdgf *PdfObjectReference )(PdfObject ,bool ,error ){_eggaf ,_fbcf :=_gagd .ObjCache [int (_cdgf .ObjectNumber )];
if _fbcf {return _eggaf ,true ,nil ;};_fgec ,_adae :=_gagd .LookupByReference (*_cdgf );if _adae !=nil {return nil ,false ,_adae ;};_gagd .ObjCache [int (_cdgf .ObjectNumber )]=_fgec ;return _fgec ,false ,nil ;};

// Append appends PdfObject(s) to the streams.
func (_dffg *PdfObjectStreams )Append (objects ...PdfObject ){if _dffg ==nil {_aab .Log .Debug ("\u0057\u0061\u0072\u006e\u0020-\u0020\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0020\u0074\u006f\u0020\u0061p\u0070\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0073");
return ;};_dffg ._cgaag =append (_dffg ._cgaag ,objects ...);};

// GetFilterName returns the name of the encoding filter.
func (_ffaa *DCTEncoder )GetFilterName ()string {return StreamEncodingFilterNameDCT };

// NewJBIG2Encoder creates a new JBIG2Encoder.
func NewJBIG2Encoder ()*JBIG2Encoder {return &JBIG2Encoder {_faeb :_bbe .InitEncodeDocument (false )}};

// DecodeStream decodes the stream data and returns the decoded data.
// An error is returned upon failure.
func DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_aab .Log .Trace ("\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_eagf ,_cdca :=NewEncoderFromStream (streamObj );if _cdca !=nil {_aab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_cdca );
return nil ,_cdca ;};_aab .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076\u000a",_eagf );_gcgc ,_cdca :=_eagf .DecodeStream (streamObj );if _cdca !=nil {_aab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_cdca );
return nil ,_cdca ;};return _gcgc ,nil ;};

// XrefObject defines a cross reference entry which is a map between object number (with generation number) and the
// location of the actual object, either as a file offset (xref table entry), or as a location within an xref
// stream object (xref object stream).
type XrefObject struct{XType xrefType ;ObjectNumber int ;Generation int ;

// For normal xrefs (defined by OFFSET)
Offset int64 ;

// For xrefs to object streams.
OsObjNumber int ;OsObjIndex int ;};

// Update updates multiple keys and returns the dictionary back so can be used in a chained fashion.
func (_gabg *PdfObjectDictionary )Update (objmap map[string ]PdfObject )*PdfObjectDictionary {_gabg ._aggc .Lock ();defer _gabg ._aggc .Unlock ();for _edaac ,_aggae :=range objmap {_gabg .setWithLock (PdfObjectName (_edaac ),_aggae ,false );};return _gabg ;
};func (_aaad *PdfCrypt )isEncrypted (_affd PdfObject )bool {_ ,_aee :=_aaad ._fga [_affd ];if _aee {_aab .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0065\u006e\u0063\u0072y\u0070\u0074\u0065\u0064");return true ;};_aab .Log .Trace ("\u004e\u006f\u0074\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");
return false ;};func (_egaab *PdfCrypt )makeKey (_dbbe string ,_deec ,_aff uint32 ,_cfe []byte )([]byte ,error ){_gff ,_bag :=_egaab ._egg [_dbbe ];if !_bag {return nil ,_ca .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_dbbe );
};return _gff .MakeKey (_deec ,_aff ,_cfe );};

// ASCIIHexEncoder implements ASCII hex encoder/decoder.
type ASCIIHexEncoder struct{};func _cfega (_aadb _gdd .Image )*JBIG2Image {_efeb :=_aadb .Base ();return &JBIG2Image {Data :_efeb .Data ,Width :_efeb .Width ,Height :_efeb .Height ,HasPadding :true };};func (_ddae *PdfCrypt )authenticate (_efd []byte )(bool ,error ){_ddae ._gdf =false ;
_dbc :=_ddae .securityHandler ();_age ,_aec ,_gdaae :=_dbc .Authenticate (&_ddae ._fca ,_efd );if _gdaae !=nil {return false ,_gdaae ;}else if _aec ==0||len (_age )==0{return false ,nil ;};_ddae ._gdf =true ;_ddae ._afdc =_age ;return true ,nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_fffd *DCTEncoder )MakeDecodeParams ()PdfObject {return nil };

// DecodeBytes decodes a slice of JPX encoded bytes and returns the result.
func (_cdb *JPXEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_aab .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_cdb .GetFilterName ());
return encoded ,ErrNoJPXDecode ;};func _fdfb (_cfegb string )(PdfObjectReference ,error ){_afaad :=PdfObjectReference {};_bbge :=_acege .FindStringSubmatch (_cfegb );if len (_bbge )< 3{_aab .Log .Debug ("\u0045\u0072\u0072or\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");
return _afaad ,_d .New ("\u0075n\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061r\u0073e\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");};_facf ,_ :=_b .Atoi (_bbge [1]);_bccfa ,_ :=_b .Atoi (_bbge [2]);_afaad .ObjectNumber =int64 (_facf );
_afaad .GenerationNumber =int64 (_bccfa );return _afaad ,nil ;};func _dbdf (_aaec PdfObject ,_eafbg int ,_fccb map[PdfObject ]struct{})error {_aab .Log .Trace ("\u0054\u0072\u0061\u0076\u0065\u0072s\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0064\u0061\u0074\u0061 \u0028\u0064\u0065\u0070\u0074\u0068\u0020=\u0020\u0025\u0064\u0029",_eafbg );
if _ ,_ebdgb :=_fccb [_aaec ];_ebdgb {_aab .Log .Trace ("-\u0041\u006c\u0072\u0065ad\u0079 \u0074\u0072\u0061\u0076\u0065r\u0073\u0065\u0064\u002e\u002e\u002e");return nil ;};_fccb [_aaec ]=struct{}{};switch _ccda :=_aaec .(type ){case *PdfIndirectObject :_baaf :=_ccda ;
_aab .Log .Trace ("\u0069\u006f\u003a\u0020\u0025\u0073",_baaf );_aab .Log .Trace ("\u002d\u0020\u0025\u0073",_baaf .PdfObject );return _dbdf (_baaf .PdfObject ,_eafbg +1,_fccb );case *PdfObjectStream :_dfbgc :=_ccda ;return _dbdf (_dfbgc .PdfObjectDictionary ,_eafbg +1,_fccb );
case *PdfObjectDictionary :_gffce :=_ccda ;_aab .Log .Trace ("\u002d\u0020\u0064\u0069\u0063\u0074\u003a\u0020\u0025\u0073",_gffce );for _ ,_egada :=range _gffce .Keys (){_ccbdb :=_gffce .Get (_egada );if _ggfcda ,_dbffd :=_ccbdb .(*PdfObjectReference );
_dbffd {_gfdcf :=_ggfcda .Resolve ();_gffce .Set (_egada ,_gfdcf );_egdaf :=_dbdf (_gfdcf ,_eafbg +1,_fccb );if _egdaf !=nil {return _egdaf ;};}else {_dbfb :=_dbdf (_ccbdb ,_eafbg +1,_fccb );if _dbfb !=nil {return _dbfb ;};};};return nil ;case *PdfObjectArray :_eeeag :=_ccda ;
_aab .Log .Trace ("-\u0020\u0061\u0072\u0072\u0061\u0079\u003a\u0020\u0025\u0073",_eeeag );for _fbecg ,_dfafc :=range _eeeag .Elements (){if _cegb ,_eacab :=_dfafc .(*PdfObjectReference );_eacab {_dbed :=_cegb .Resolve ();_eeeag .Set (_fbecg ,_dbed );_gddcb :=_dbdf (_dbed ,_eafbg +1,_fccb );
if _gddcb !=nil {return _gddcb ;};}else {_ceaf :=_dbdf (_dfafc ,_eafbg +1,_fccb );if _ceaf !=nil {return _ceaf ;};};};return nil ;case *PdfObjectReference :_aab .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020T\u0072\u0061\u0063\u0069\u006e\u0067\u0020\u0061\u0020r\u0065\u0066\u0065r\u0065n\u0063\u0065\u0021");
return _d .New ("\u0065r\u0072\u006f\u0072\u0020t\u0072\u0061\u0063\u0069\u006eg\u0020a\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");};return nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_edae *FlateEncoder )MakeStreamDict ()*PdfObjectDictionary {_eadfa :=MakeDict ();_eadfa .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_edae .GetFilterName ()));_dgec :=_edae .MakeDecodeParams ();if _dgec !=nil {_eadfa .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_dgec );
};return _eadfa ;};func (_bgfff *PdfParser )seekPdfVersionTopDown ()(int ,int ,error ){_bgfff ._fdeg .Seek (0,_bf .SeekStart );_bgfff ._aaae =_gd .NewReader (_bgfff ._fdeg );_cadg :=20;_fggd :=make ([]byte ,_cadg );for {_fddf ,_bcgf :=_bgfff ._aaae .ReadByte ();
if _bcgf !=nil {if _bcgf ==_bf .EOF {break ;}else {return 0,0,_bcgf ;};};if IsDecimalDigit (_fddf )&&_fggd [_cadg -1]=='.'&&IsDecimalDigit (_fggd [_cadg -2])&&_fggd [_cadg -3]=='-'&&_fggd [_cadg -4]=='F'&&_fggd [_cadg -5]=='D'&&_fggd [_cadg -6]=='P'{_gcgg :=int (_fggd [_cadg -2]-'0');
_fbeg :=int (_fddf -'0');return _gcgg ,_fbeg ,nil ;};_fggd =append (_fggd [1:_cadg ],_fddf );};return 0,0,_d .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_ecf *JPXEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};

// GetTrailer returns the PDFs trailer dictionary. The trailer dictionary is typically the starting point for a PDF,
// referencing other key objects that are important in the document structure.
func (_aegd *PdfParser )GetTrailer ()*PdfObjectDictionary {return _aegd ._daeb };

// ResolveReferencesDeep recursively traverses through object `o`, looking up and replacing
// references with indirect objects.
// Optionally a map of already deep-resolved objects can be provided via `traversed`. The `traversed` map
// is updated while traversing the objects to avoid traversing same objects multiple times.
func ResolveReferencesDeep (o PdfObject ,traversed map[PdfObject ]struct{})error {if traversed ==nil {traversed =map[PdfObject ]struct{}{};};return _dbdf (o ,0,traversed );};

// PdfCryptNewDecrypt makes the document crypt handler based on the encryption dictionary
// and trailer dictionary. Returns an error on failure to process.
func PdfCryptNewDecrypt (parser *PdfParser ,ed ,trailer *PdfObjectDictionary )(*PdfCrypt ,error ){_ace :=&PdfCrypt {_gdf :false ,_ffb :make (map[PdfObject ]bool ),_fga :make (map[PdfObject ]bool ),_df :make (map[int ]struct{}),_eade :parser };_bed ,_gefa :=ed .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectName );
if !_gefa {_aab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0043\u0072\u0079\u0070\u0074 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061r\u0079 \u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u0066\u0069\u0065\u006c\u0064\u0021");
return _ace ,_d .New ("r\u0065\u0071\u0075\u0069\u0072\u0065d\u0020\u0063\u0072\u0079\u0070\u0074 \u0066\u0069\u0065\u006c\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u006d\u0069\u0073\u0073\u0069n\u0067");};if *_bed !="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"{_aab .Log .Debug ("\u0045\u0052R\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020(%\u0073\u0029",*_bed );
return _ace ,_d .New ("\u0075n\u0073u\u0070\u0070\u006f\u0072\u0074e\u0064\u0020F\u0069\u006c\u0074\u0065\u0072");};_ace ._dab .Filter =string (*_bed );if _dcab ,_ceg :=ed .Get ("\u0053u\u0062\u0046\u0069\u006c\u0074\u0065r").(*PdfObjectString );_ceg {_ace ._dab .SubFilter =_dcab .Str ();
_aab .Log .Debug ("\u0055s\u0069n\u0067\u0020\u0073\u0075\u0062f\u0069\u006ct\u0065\u0072\u0020\u0025\u0073",_dcab );};if L ,_afbb :=ed .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );_afbb {if (*L %8)!=0{_aab .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0049\u006ev\u0061\u006c\u0069\u0064\u0020\u0065\u006ec\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006c\u0065\u006e\u0067\u0074\u0068");
return _ace ,_d .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0065\u006e\u0063\u0072y\u0070t\u0069o\u006e\u0020\u006c\u0065\u006e\u0067\u0074h");};_ace ._dab .Length =int (*L );}else {_ace ._dab .Length =40;};_ace ._dab .V =0;if _dff ,_bdbb :=ed .Get ("\u0056").(*PdfObjectInteger );
_bdbb {V :=int (*_dff );_ace ._dab .V =V ;if V >=1&&V <=2{_ace ._egg =_gedd (_ace ._dab .Length );}else if V >=4&&V <=5{if _begd :=_ace .loadCryptFilters (ed );_begd !=nil {return _ace ,_begd ;};}else {_aab .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0061lg\u006f\u0020\u0056 \u003d \u0025\u0064",V );
return _ace ,_d .New ("u\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d");};};if _feg :=_baa (&_ace ._fca ,ed );_feg !=nil {return _ace ,_feg ;};_afc :="";if _fee ,_dbb :=trailer .Get ("\u0049\u0044").(*PdfObjectArray );
_dbb &&_fee .Len ()>=1{_gae ,_adf :=GetString (_fee .Get (0));if !_adf {return _ace ,_d .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0074r\u0061\u0069l\u0065\u0072\u0020\u0049\u0044");};_afc =_gae .Str ();}else {_aab .Log .Debug ("\u0054\u0072ai\u006c\u0065\u0072 \u0049\u0044\u0020\u0061rra\u0079 m\u0069\u0073\u0073\u0069\u006e\u0067\u0020or\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0021");
};_ace ._fgg =_afc ;return _ace ,nil ;};var _gbbfa _c .Map ;func _cgad (_bcdb string )(int ,int ,error ){_bdde :=_bbefd .FindStringSubmatch (_bcdb );if len (_bdde )< 3{return 0,0,_d .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");
};_cfdb ,_ :=_b .Atoi (_bdde [1]);_aedf ,_ :=_b .Atoi (_bdde [2]);return _cfdb ,_aedf ,nil ;};

// SetImage sets the image base for given flate encoder.
func (_fbe *FlateEncoder )SetImage (img *_gdd .ImageBase ){_fbe ._dbgf =img };

// ReadBytesAt reads byte content at specific offset and length within the PDF.
func (_ggdg *PdfParser )ReadBytesAt (offset ,len int64 )([]byte ,error ){_cgge :=_ggdg .GetFileOffset ();_ ,_eebeb :=_ggdg ._fdeg .Seek (offset ,_bf .SeekStart );if _eebeb !=nil {return nil ,_eebeb ;};_efgd :=make ([]byte ,len );_ ,_eebeb =_bf .ReadAtLeast (_ggdg ._fdeg ,_efgd ,int (len ));
if _eebeb !=nil {return nil ,_eebeb ;};_ggdg .SetFileOffset (_cgge );return _efgd ,nil ;};

// GetFilterName returns the name of the encoding filter.
func (_gaca *ASCIIHexEncoder )GetFilterName ()string {return StreamEncodingFilterNameASCIIHex };

// Len returns the number of elements in the array.
func (_bcbge *PdfObjectArray )Len ()int {if _bcbge ==nil {return 0;};return len (_bcbge ._beea );};

// EncodeImage encodes 'img' golang image.Image into jbig2 encoded bytes document using default encoder settings.
func (_ddfg *JBIG2Encoder )EncodeImage (img _ab .Image )([]byte ,error ){return _ddfg .encodeImage (img )};

// GetNumbersAsFloat converts a list of pdf objects representing floats or integers to a slice of
// float64 values.
func GetNumbersAsFloat (objects []PdfObject )(_feagf []float64 ,_abedf error ){for _ ,_bedg :=range objects {_geca ,_cedf :=GetNumberAsFloat (_bedg );if _cedf !=nil {return nil ,_cedf ;};_feagf =append (_feagf ,_geca );};return _feagf ,nil ;};

// GetFilterName returns the name of the encoding filter.
func (_dgg *FlateEncoder )GetFilterName ()string {return StreamEncodingFilterNameFlate };

// ParseNumber parses a numeric objects from a buffered stream.
// Section 7.3.3.
// Integer or Float.
//
// An integer shall be written as one or more decimal digits optionally
// preceded by a sign. The value shall be interpreted as a signed
// decimal integer and shall be converted to an integer object.
//
// A real value shall be written as one or more decimal digits with an
// optional sign and a leading, trailing, or embedded PERIOD (2Eh)
// (decimal point). The value shall be interpreted as a real number
// and shall be converted to a real object.
//
// Regarding exponential numbers: 7.3.3 Numeric Objects:
// A conforming writer shall not use the PostScript syntax for numbers
// with non-decimal radices (such as 16#FFFE) or in exponential format
// (such as 6.02E23).
// Nonetheless, we sometimes get numbers with exponential format, so
// we will support it in the reader (no confusion with other types, so
// no compromise).
func ParseNumber (buf *_gd .Reader )(PdfObject ,error ){_ebcgb :=false ;_eegc :=true ;var _deddd _abb .Buffer ;for {if _aab .Log .IsLogLevel (_aab .LogLevelTrace ){_aab .Log .Trace ("\u0050\u0061\u0072\u0073in\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0022\u0025\u0073\u0022",_deddd .String ());
};_bdbeg ,_bgef :=buf .Peek (1);if _bgef ==_bf .EOF {break ;};if _bgef !=nil {_aab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0025\u0073",_bgef );return nil ,_bgef ;};if _eegc &&(_bdbeg [0]=='-'||_bdbeg [0]=='+'){_acdbf ,_ :=buf .ReadByte ();_deddd .WriteByte (_acdbf );
_eegc =false ;}else if IsDecimalDigit (_bdbeg [0]){_gfabd ,_ :=buf .ReadByte ();_deddd .WriteByte (_gfabd );}else if _bdbeg [0]=='.'{_bfaed ,_ :=buf .ReadByte ();_deddd .WriteByte (_bfaed );_ebcgb =true ;}else if _bdbeg [0]=='e'||_bdbeg [0]=='E'{_eefd ,_ :=buf .ReadByte ();
_deddd .WriteByte (_eefd );_ebcgb =true ;_eegc =true ;}else {break ;};};var _agbe PdfObject ;if _ebcgb {_cafg ,_baag :=_b .ParseFloat (_deddd .String (),64);if _baag !=nil {_aab .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0025v\u0020\u0065\u0072\u0072\u003d\u0025v\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0030\u002e\u0020\u004fu\u0074\u0070u\u0074\u0020\u006d\u0061y\u0020\u0062\u0065\u0020\u0069n\u0063\u006f\u0072\u0072\u0065\u0063\u0074",_deddd .String (),_baag );
_cafg =0.0;};_debc :=PdfObjectFloat (_cafg );_agbe =&_debc ;}else {_daea ,_acdeb :=_b .ParseInt (_deddd .String (),10,64);if _acdeb !=nil {_aab .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0025\u0076\u0020\u0065\u0072\u0072\u003d%\u0076\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074 \u006d\u0061\u0079\u0020\u0062\u0065 \u0069\u006ec\u006f\u0072r\u0065c\u0074",_deddd .String (),_acdeb );
_daea =0;};_ffef :=PdfObjectInteger (_daea );_agbe =&_ffef ;};return _agbe ,nil ;};func (_caga *PdfCrypt )saveCryptFilters (_dge *PdfObjectDictionary )error {if _caga ._dab .V < 4{return _d .New ("\u0063\u0061\u006e\u0020\u006f\u006e\u006c\u0079\u0020\u0062\u0065 \u0075\u0073\u0065\u0064\u0020\u0077\u0069\u0074\u0068\u0020V\u003e\u003d\u0034");
};_egcg :=MakeDict ();_dge .Set ("\u0043\u0046",_egcg );for _dgeg ,_gfd :=range _caga ._egg {if _dgeg =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{continue ;};_cgd :=_cac (_gfd ,"");_egcg .Set (PdfObjectName (_dgeg ),_cgd );};_dge .Set ("\u0053\u0074\u0072\u0046",MakeName (_caga ._aeac ));
_dge .Set ("\u0053\u0074\u006d\u0046",MakeName (_caga ._bdb ));return nil ;};

// GetFilterName returns the names of the underlying encoding filters,
// separated by spaces.
// Note: This is just a string, should not be used in /Filter dictionary entry. Use GetFilterArray for that.
// TODO(v4): Refactor to GetFilter() which can be used for /Filter (either Name or Array), this can be
//  renamed to String() as a pretty string to use in debugging etc.
func (_baece *MultiEncoder )GetFilterName ()string {_faba :="";for _agc ,_gegda :=range _baece ._dfdb {_faba +=_gegda .GetFilterName ();if _agc < len (_baece ._dfdb )-1{_faba +="\u0020";};};return _faba ;};

// IsAuthenticated returns true if the PDF has already been authenticated for accessing.
func (_eafb *PdfParser )IsAuthenticated ()bool {return _eafb ._gbbg ._gdf };

// String returns the state of the bool as "true" or "false".
func (_fecf *PdfObjectBool )String ()string {if *_fecf {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};func _fgcec (_fcac int )int {if _fcac < 0{return -_fcac ;};return _fcac ;};

// GetString is a helper for Get that returns a string value.
// Returns false if the key is missing or a value is not a string.
func (_gdec *PdfObjectDictionary )GetString (key PdfObjectName )(string ,bool ){_dcga :=_gdec .Get (key );if _dcga ==nil {return "",false ;};_aegda ,_gffc :=_dcga .(*PdfObjectString );if !_gffc {return "",false ;};return _aegda .Str (),true ;};var _gbaea =_ed .MustCompile ("\u0025P\u0044F\u002d\u0028\u005c\u0064\u0029\u005c\u002e\u0028\u005c\u0064\u0029");
func (_bcg *PdfParser )lookupByNumberWrapper (_bceg int ,_af bool )(PdfObject ,bool ,error ){_fbdd ,_edb ,_bg :=_bcg .lookupByNumber (_bceg ,_af );if _bg !=nil {return nil ,_edb ,_bg ;};if !_edb &&_bcg ._gbbg !=nil &&_bcg ._gbbg ._gdf &&!_bcg ._gbbg .isDecrypted (_fbdd ){_fbda :=_bcg ._gbbg .Decrypt (_fbdd ,0,0);
if _fbda !=nil {return nil ,_edb ,_fbda ;};};return _fbdd ,_edb ,nil ;};

// HasOddLengthHexStrings checks if the document has odd length hexadecimal strings.
func (_efb ParserMetadata )HasOddLengthHexStrings ()bool {return _efb ._cga };

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_ccee *ASCIIHexEncoder )MakeDecodeParams ()PdfObject {return nil };

// DecodeStream implements ASCII hex decoding.
func (_eecgf *ASCIIHexEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _eecgf .DecodeBytes (streamObj .Stream );};

// EncodeJBIG2Image encodes 'img' into jbig2 encoded bytes stream, using default encoder settings.
func (_gddca *JBIG2Encoder )EncodeJBIG2Image (img *JBIG2Image )([]byte ,error ){const _baca ="c\u006f\u0072\u0065\u002eEn\u0063o\u0064\u0065\u004a\u0042\u0049G\u0032\u0049\u006d\u0061\u0067\u0065";if _afca :=_gddca .AddPageImage (img ,&_gddca .DefaultPageSettings );
_afca !=nil {return nil ,_ba .Wrap (_afca ,_baca ,"");};return _gddca .Encode ();};

// MakeHexString creates an PdfObjectString from a string intended for output as a hexadecimal string.
func MakeHexString (s string )*PdfObjectString {_bcbfb :=PdfObjectString {_agadg :s ,_bgbe :true };return &_bcbfb ;};

// Resolve resolves the reference and returns the indirect or stream object.
// If the reference cannot be resolved, a *PdfObjectNull object is returned.
func (_bafg *PdfObjectReference )Resolve ()PdfObject {if _bafg ._acge ==nil {return MakeNull ();};_bbgb ,_ ,_aabc :=_bafg ._acge .resolveReference (_bafg );if _aabc !=nil {_aab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0072\u0065\u0073\u006f\u006cv\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065r\u0065n\u0063\u0065\u003a\u0020\u0025\u0076\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074",_aabc );
return MakeNull ();};if _bbgb ==nil {_aab .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0072\u0065\u0073ol\u0076\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065:\u0020\u006ei\u006c\u0020\u006fb\u006a\u0065\u0063\u0074\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u0061\u0020nu\u006c\u006c\u0020o\u0062\u006a\u0065\u0063\u0074");
return MakeNull ();};return _bbgb ;};

// MakeArray creates an PdfObjectArray from a list of PdfObjects.
func MakeArray (objects ...PdfObject )*PdfObjectArray {return &PdfObjectArray {_beea :objects }};

// MakeFloat creates an PdfObjectFloat from a float64.
func MakeFloat (val float64 )*PdfObjectFloat {_ffbcc :=PdfObjectFloat (val );return &_ffbcc };

// String returns a string representation of `name`.
func (_faca *PdfObjectName )String ()string {return string (*_faca )};

// GetEncryptObj returns the PdfIndirectObject which has information about the PDFs encryption details.
func (_cggee *PdfParser )GetEncryptObj ()*PdfIndirectObject {return _cggee ._gdddc };

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_ccfg *MultiEncoder )MakeStreamDict ()*PdfObjectDictionary {_cgdf :=MakeDict ();_cgdf .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",_ccfg .GetFilterArray ());for _ ,_eddf :=range _ccfg ._dfdb {_fdba :=_eddf .MakeStreamDict ();for _ ,_bcfe :=range _fdba .Keys (){_gccf :=_fdba .Get (_bcfe );
if _bcfe !="\u0046\u0069\u006c\u0074\u0065\u0072"&&_bcfe !="D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"{_cgdf .Set (_bcfe ,_gccf );};};};_ggdcf :=_ccfg .MakeDecodeParams ();if _ggdcf !=nil {_cgdf .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_ggdcf );
};return _cgdf ;};

// WriteString outputs the object as it is to be written to file.
func (_acca *PdfObjectStream )WriteString ()string {var _cfcea _gg .Builder ;_cfcea .WriteString (_b .FormatInt (_acca .ObjectNumber ,10));_cfcea .WriteString ("\u0020\u0030\u0020\u0052");return _cfcea .String ();};

// ToInt64Slice returns a slice of all array elements as an int64 slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_eage *PdfObjectArray )ToInt64Slice ()([]int64 ,error ){var _badec []int64 ;for _ ,_fefeb :=range _eage .Elements (){if _eacge ,_fcaeg :=_fefeb .(*PdfObjectInteger );_fcaeg {_badec =append (_badec ,int64 (*_eacge ));}else {return nil ,ErrTypeError ;
};};return _badec ,nil ;};

// String returns a string describing `stream`.
func (_agcg *PdfObjectStream )String ()string {return _ca .Sprintf ("O\u0062j\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0025\u0064: \u0025\u0073",_agcg .ObjectNumber ,_agcg .PdfObjectDictionary );};var _fgdea =_ed .MustCompile ("\u0025\u0025\u0045\u004f\u0046\u003f");


// GetIntVal returns the int value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetIntVal (obj PdfObject )(_bdeb int ,_gdbffb bool ){_ggfc ,_gdbffb :=TraceToDirectObject (obj ).(*PdfObjectInteger );if _gdbffb &&_ggfc !=nil {return int (*_ggfc ),true ;};return 0,false ;};

// GetFloatVal returns the float64 value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetFloatVal (obj PdfObject )(_fgcbd float64 ,_eebd bool ){_ddeff ,_eebd :=TraceToDirectObject (obj ).(*PdfObjectFloat );if _eebd {return float64 (*_ddeff ),true ;};return 0,false ;};

// GetFilterName returns the name of the encoding filter.
func (_ecbb *JPXEncoder )GetFilterName ()string {return StreamEncodingFilterNameJPX };

// PdfObjectStream represents the primitive PDF Object stream.
type PdfObjectStream struct{PdfObjectReference ;*PdfObjectDictionary ;Stream []byte ;};

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_cegf *RunLengthEncoder )EncodeBytes (data []byte )([]byte ,error ){_gddd :=_abb .NewReader (data );var _cfeg []byte ;var _gebf []byte ;_cefb ,_bcd :=_gddd .ReadByte ();if _bcd ==_bf .EOF {return []byte {},nil ;}else if _bcd !=nil {return nil ,_bcd ;
};_cce :=1;for {_ccdb ,_gfe :=_gddd .ReadByte ();if _gfe ==_bf .EOF {break ;}else if _gfe !=nil {return nil ,_gfe ;};if _ccdb ==_cefb {if len (_gebf )> 0{_gebf =_gebf [:len (_gebf )-1];if len (_gebf )> 0{_cfeg =append (_cfeg ,byte (len (_gebf )-1));_cfeg =append (_cfeg ,_gebf ...);
};_cce =1;_gebf =[]byte {};};_cce ++;if _cce >=127{_cfeg =append (_cfeg ,byte (257-_cce ),_cefb );_cce =0;};}else {if _cce > 0{if _cce ==1{_gebf =[]byte {_cefb };}else {_cfeg =append (_cfeg ,byte (257-_cce ),_cefb );};_cce =0;};_gebf =append (_gebf ,_ccdb );
if len (_gebf )>=127{_cfeg =append (_cfeg ,byte (len (_gebf )-1));_cfeg =append (_cfeg ,_gebf ...);_gebf =[]byte {};};};_cefb =_ccdb ;};if len (_gebf )> 0{_cfeg =append (_cfeg ,byte (len (_gebf )-1));_cfeg =append (_cfeg ,_gebf ...);}else if _cce > 0{_cfeg =append (_cfeg ,byte (257-_cce ),_cefb );
};_cfeg =append (_cfeg ,128);return _cfeg ,nil ;};

// IsEncrypted checks if the document is encrypted. A bool flag is returned indicating the result.
// First time when called, will check if the Encrypt dictionary is accessible through the trailer dictionary.
// If encrypted, prepares a crypt datastructure which can be used to authenticate and decrypt the document.
// On failure, an error is returned.
func (_cdcc *PdfParser )IsEncrypted ()(bool ,error ){if _cdcc ._gbbg !=nil {return true ,nil ;}else if _cdcc ._daeb ==nil {return false ,nil ;};_aab .Log .Trace ("\u0043\u0068\u0065c\u006b\u0069\u006e\u0067 \u0065\u006e\u0063\u0072\u0079\u0070\u0074i\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0021");
_fecg :=_cdcc ._daeb .Get ("\u0045n\u0063\u0072\u0079\u0070\u0074");if _fecg ==nil {return false ,nil ;};_aab .Log .Trace ("\u0049\u0073\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u0021");var (_gddg *PdfObjectDictionary ;);switch _cebb :=_fecg .(type ){case *PdfObjectDictionary :_gddg =_cebb ;
case *PdfObjectReference :_aab .Log .Trace ("\u0030\u003a\u0020\u004c\u006f\u006f\u006b\u0020\u0075\u0070\u0020\u0072e\u0066\u0020\u0025\u0071",_cebb );_bade ,_cgef :=_cdcc .LookupByReference (*_cebb );_aab .Log .Trace ("\u0031\u003a\u0020%\u0071",_bade );
if _cgef !=nil {return false ,_cgef ;};_cegfbd ,_ggff :=_bade .(*PdfIndirectObject );if !_ggff {_aab .Log .Debug ("E\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006eo\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072ec\u0074\u0020\u006fb\u006ae\u0063\u0074");
return false ,_d .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");};_ebfga ,_ggff :=_cegfbd .PdfObject .(*PdfObjectDictionary );_cdcc ._gdddc =_cegfbd ;_aab .Log .Trace ("\u0032\u003a\u0020%\u0071",_ebfga );
if !_ggff {return false ,_d .New ("\u0074\u0072a\u0069\u006c\u0065\u0072 \u0045\u006ec\u0072\u0079\u0070\u0074\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u006e\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");};_gddg =_ebfga ;
case *PdfObjectNull :_aab .Log .Debug ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074 \u0069\u0073\u0020a\u0020\u006e\u0075l\u006c\u0020o\u0062\u006a\u0065\u0063\u0074\u002e \u0046il\u0065\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u002e");
return false ,nil ;default:return false ,_ca .Errorf ("u\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0079\u0070\u0065: \u0025\u0054",_cebb );};_ddfgb ,_beee :=PdfCryptNewDecrypt (_cdcc ,_gddg ,_cdcc ._daeb );if _beee !=nil {return false ,_beee ;
};for _ ,_dbac :=range []string {"\u0045n\u0063\u0072\u0079\u0070\u0074"}{_bfgc :=_cdcc ._daeb .Get (PdfObjectName (_dbac ));if _bfgc ==nil {continue ;};switch _abac :=_bfgc .(type ){case *PdfObjectReference :_ddfgb ._df [int (_abac .ObjectNumber )]=struct{}{};
case *PdfIndirectObject :_ddfgb ._ffb [_abac ]=true ;_ddfgb ._df [int (_abac .ObjectNumber )]=struct{}{};};};_cdcc ._gbbg =_ddfgb ;_aab .Log .Trace ("\u0043\u0072\u0079\u0070\u0074\u0065\u0072\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0025\u0062",_ddfgb );
return true ,nil ;};

// MakeObjectStreams creates an PdfObjectStreams from a list of PdfObjects.
func MakeObjectStreams (objects ...PdfObject )*PdfObjectStreams {return &PdfObjectStreams {_cgaag :objects };};

// NewRawEncoder returns a new instace of RawEncoder.
func NewRawEncoder ()*RawEncoder {return &RawEncoder {}};

// Append appends PdfObject(s) to the array.
func (_dcdbe *PdfObjectArray )Append (objects ...PdfObject ){if _dcdbe ==nil {_aab .Log .Debug ("\u0057\u0061\u0072\u006e\u0020\u002d\u0020\u0041\u0074\u0074\u0065\u006d\u0070t\u0020\u0074\u006f\u0020\u0061\u0070p\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020a\u0072\u0072\u0061\u0079");
return ;};_dcdbe ._beea =append (_dcdbe ._beea ,objects ...);};

// String returns a string describing `null`.
func (_gcad *PdfObjectNull )String ()string {return "\u006e\u0075\u006c\u006c"};

// UpdateParams updates the parameter values of the encoder.
func (_cdefc *MultiEncoder )UpdateParams (params *PdfObjectDictionary ){for _ ,_egaga :=range _cdefc ._dfdb {_egaga .UpdateParams (params );};};func (_edbc *ASCII85Encoder )base256Tobase85 (_dbdea uint32 )[5]byte {_eacb :=[5]byte {0,0,0,0,0};_cdcf :=_dbdea ;
for _bggfd :=0;_bggfd < 5;_bggfd ++{_gdae :=uint32 (1);for _faef :=0;_faef < 4-_bggfd ;_faef ++{_gdae *=85;};_ccdg :=_cdcf /_gdae ;_cdcf =_cdcf %_gdae ;_eacb [_bggfd ]=byte (_ccdg );};return _eacb ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_afe *ASCII85Encoder )MakeDecodeParams ()PdfObject {return nil };

// DecodeBytes decodes a slice of DCT encoded bytes and returns the result.
func (_bbcf *DCTEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_gbfc :=_abb .NewReader (encoded );_acgb ,_fgcb :=_aa .Decode (_gbfc );if _fgcb !=nil {_aab .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006eg\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_fgcb );
return nil ,_fgcb ;};_bfea :=_acgb .Bounds ();var _aacc =make ([]byte ,_bfea .Dx ()*_bfea .Dy ()*_bbcf .ColorComponents *_bbcf .BitsPerComponent /8);_eggf :=0;for _gddf :=_bfea .Min .Y ;_gddf < _bfea .Max .Y ;_gddf ++{for _fefd :=_bfea .Min .X ;_fefd < _bfea .Max .X ;
_fefd ++{_ggad :=_acgb .At (_fefd ,_gddf );if _bbcf .ColorComponents ==1{if _bbcf .BitsPerComponent ==16{_cef ,_gebe :=_ggad .(_bc .Gray16 );if !_gebe {return nil ,_d .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_aacc [_eggf ]=byte ((_cef .Y >>8)&0xff);_eggf ++;_aacc [_eggf ]=byte (_cef .Y &0xff);_eggf ++;}else {_gffb ,_bfg :=_ggad .(_bc .Gray );if !_bfg {return nil ,_d .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_aacc [_eggf ]=_gffb .Y &0xff;_eggf ++;};}else if _bbcf .ColorComponents ==3{if _bbcf .BitsPerComponent ==16{_cddc ,_deab :=_ggad .(_bc .RGBA64 );if !_deab {return nil ,_d .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_aacc [_eggf ]=byte ((_cddc .R >>8)&0xff);_eggf ++;_aacc [_eggf ]=byte (_cddc .R &0xff);_eggf ++;_aacc [_eggf ]=byte ((_cddc .G >>8)&0xff);_eggf ++;_aacc [_eggf ]=byte (_cddc .G &0xff);_eggf ++;_aacc [_eggf ]=byte ((_cddc .B >>8)&0xff);_eggf ++;_aacc [_eggf ]=byte (_cddc .B &0xff);
_eggf ++;}else {_egea ,_abbdc :=_ggad .(_bc .RGBA );if _abbdc {_aacc [_eggf ]=_egea .R &0xff;_eggf ++;_aacc [_eggf ]=_egea .G &0xff;_eggf ++;_aacc [_eggf ]=_egea .B &0xff;_eggf ++;}else {_ccd ,_ggdb :=_ggad .(_bc .YCbCr );if !_ggdb {return nil ,_d .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_ccae ,_ffec ,_eeedd ,_ :=_ccd .RGBA ();_aacc [_eggf ]=byte (_ccae >>8);_eggf ++;_aacc [_eggf ]=byte (_ffec >>8);_eggf ++;_aacc [_eggf ]=byte (_eeedd >>8);_eggf ++;};};}else if _bbcf .ColorComponents ==4{_ebca ,_aae :=_ggad .(_bc .CMYK );if !_aae {return nil ,_d .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_aacc [_eggf ]=255-_ebca .C &0xff;_eggf ++;_aacc [_eggf ]=255-_ebca .M &0xff;_eggf ++;_aacc [_eggf ]=255-_ebca .Y &0xff;_eggf ++;_aacc [_eggf ]=255-_ebca .K &0xff;_eggf ++;};};};return _aacc ,nil ;};const (XrefTypeTableEntry xrefType =iota ;XrefTypeObjectStream xrefType =iota ;
);

// Resolve resolves a PdfObject to direct object, looking up and resolving references as needed (unlike TraceToDirect).
func (_afd *PdfParser )Resolve (obj PdfObject )(PdfObject ,error ){_aegc ,_abf :=obj .(*PdfObjectReference );if !_abf {return obj ,nil ;};_cbe :=_afd .GetFileOffset ();defer func (){_afd .SetFileOffset (_cbe )}();_dca ,_bbg :=_afd .LookupByReference (*_aegc );
if _bbg !=nil {return nil ,_bbg ;};_fag ,_cg :=_dca .(*PdfIndirectObject );if !_cg {return _dca ,nil ;};_dca =_fag .PdfObject ;_ ,_abf =_dca .(*PdfObjectReference );if _abf {return _fag ,_d .New ("\u006d\u0075lt\u0069\u0020\u0064e\u0070\u0074\u0068\u0020tra\u0063e \u0070\u006f\u0069\u006e\u0074\u0065\u0072 t\u006f\u0020\u0070\u006f\u0069\u006e\u0074e\u0072");
};return _dca ,nil ;};

// RawEncoder implements Raw encoder/decoder (no encoding, pass through)
type RawEncoder struct{};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set.  Some other parameters are generated elsewhere.
func (_dbf *DCTEncoder )MakeStreamDict ()*PdfObjectDictionary {_gbef :=MakeDict ();_gbef .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_dbf .GetFilterName ()));return _gbef ;};

// UpdateParams updates the parameter values of the encoder.
func (_acf *ASCII85Encoder )UpdateParams (params *PdfObjectDictionary ){};

// CheckAccessRights checks access rights and permissions for a specified password. If either user/owner password is
// specified, full rights are granted, otherwise the access rights are specified by the Permissions flag.
//
// The bool flag indicates that the user can access and view the file.
// The AccessPermissions shows what access the user has for editing etc.
// An error is returned if there was a problem performing the authentication.
func (_ddgfc *PdfParser )CheckAccessRights (password []byte )(bool ,_fbd .Permissions ,error ){if _ddgfc ._gbbg ==nil {return true ,_fbd .PermOwner ,nil ;};return _ddgfc ._gbbg .checkAccessRights (password );};

// UpdateParams updates the parameter values of the encoder.
func (_bacb *FlateEncoder )UpdateParams (params *PdfObjectDictionary ){_cagac ,_ffbc :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _ffbc ==nil {_bacb .Predictor =int (_cagac );};_dece ,_ffbc :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));
if _ffbc ==nil {_bacb .BitsPerComponent =int (_dece );};_faf ,_ffbc :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _ffbc ==nil {_bacb .Columns =int (_faf );};_ebf ,_ffbc :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));
if _ffbc ==nil {_bacb .Colors =int (_ebf );};};

// ToFloat64Array returns a slice of all elements in the array as a float64 slice.  An error is
// returned if the array contains non-numeric objects (each element can be either PdfObjectInteger
// or PdfObjectFloat).
func (_acae *PdfObjectArray )ToFloat64Array ()([]float64 ,error ){var _gdeb []float64 ;for _ ,_dag :=range _acae .Elements (){switch _bdad :=_dag .(type ){case *PdfObjectInteger :_gdeb =append (_gdeb ,float64 (*_bdad ));case *PdfObjectFloat :_gdeb =append (_gdeb ,float64 (*_bdad ));
default:return nil ,ErrTypeError ;};};return _gdeb ,nil ;};