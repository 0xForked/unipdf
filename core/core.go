//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package core defines and implements the primitive PDF object types in golang, and provides functionality
// for parsing those from a PDF file stream. This includes I/O handling, cross references, repairs, encryption,
// encoding and other core capabilities.
package core ;import (_fg "bufio";_ba "bytes";_gg "compress/lzw";_a "compress/zlib";_fcc "crypto/md5";_bc "crypto/rand";_eb "encoding/hex";_f "errors";_be "fmt";_gb "github.com/unidoc/unipdf/v3/common";_bed "github.com/unidoc/unipdf/v3/core/security";_egg "github.com/unidoc/unipdf/v3/core/security/crypt";
_ac "github.com/unidoc/unipdf/v3/internal/ccittfax";_fe "github.com/unidoc/unipdf/v3/internal/imageutil";_gge "github.com/unidoc/unipdf/v3/internal/jbig2";_dg "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_gdga "github.com/unidoc/unipdf/v3/internal/jbig2/decoder";
_ec "github.com/unidoc/unipdf/v3/internal/jbig2/document";_geb "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_db "github.com/unidoc/unipdf/v3/internal/strutils";_bac "golang.org/x/image/tiff/lzw";_ge "golang.org/x/xerrors";_ca "image";_eg "image/color";
_gdg "image/jpeg";_ed "io";_c "io/ioutil";_fa "reflect";_d "regexp";_gd "sort";_fc "strconv";_cc "strings";_b "sync";_fb "time";_g "unicode";);func (_bbga *PdfParser )traceStreamLength (_gfdb PdfObject )(PdfObject ,error ){_fdaf ,_defcd :=_gfdb .(*PdfObjectReference );
if _defcd {_fdeg ,_gbbe :=_bbga ._beeab [_fdaf .ObjectNumber ];if _gbbe &&_fdeg {_gb .Log .Debug ("\u0053t\u0072\u0065a\u006d\u0020\u004c\u0065n\u0067\u0074\u0068 \u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065 u\u006e\u0072\u0065s\u006f\u006cv\u0065\u0064\u0020\u0028\u0069\u006cl\u0065\u0067a\u006c\u0029");
return nil ,_f .New ("\u0069\u006c\u006c\u0065ga\u006c\u0020\u0072\u0065\u0063\u0075\u0072\u0073\u0069\u0076\u0065\u0020\u006c\u006fo\u0070");};_bbga ._beeab [_fdaf .ObjectNumber ]=true ;};_ggebb ,_dbeb :=_bbga .Resolve (_gfdb );if _dbeb !=nil {return nil ,_dbeb ;
};_gb .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_ggebb );if _defcd {_bbga ._beeab [_fdaf .ObjectNumber ]=false ;};return _ggebb ,nil ;};

// GetFilterName returns the name of the encoding filter.
func (_aebdd *JBIG2Encoder )GetFilterName ()string {return StreamEncodingFilterNameJBIG2 };

// DecodeStream decodes a DCT encoded stream and returns the result as a
// slice of bytes.
func (_fegb *DCTEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _fegb .DecodeBytes (streamObj .Stream );};

// LookupByReference looks up a PdfObject by a reference.
func (_bgb *PdfParser )LookupByReference (ref PdfObjectReference )(PdfObject ,error ){_gb .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0075\u0070\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0025\u0073",ref .String ());return _bgb .LookupByNumber (int (ref .ObjectNumber ));
};

// DecodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_ggff *RawEncoder )DecodeBytes (encoded []byte )([]byte ,error ){return encoded ,nil };

// String returns a string describing `null`.
func (_cagd *PdfObjectNull )String ()string {return "\u006e\u0075\u006c\u006c"};func (_gbdac *PdfParser )repairRebuildXrefsTopDown ()(*XrefTable ,error ){if _gbdac ._beea {return nil ,_be .Errorf ("\u0072\u0065\u0070\u0061\u0069\u0072\u0020\u0066\u0061\u0069\u006c\u0065\u0064");
};_gbdac ._beea =true ;_gbdac ._ffaf .Seek (0,_ed .SeekStart );_gbdac ._eecd =_fg .NewReader (_gbdac ._ffaf );_bebb :=20;_cfgg :=make ([]byte ,_bebb );_gcagf :=XrefTable {};_gcagf .ObjectMap =make (map[int ]XrefObject );for {_ddfb ,_bcfe :=_gbdac ._eecd .ReadByte ();
if _bcfe !=nil {if _bcfe ==_ed .EOF {break ;}else {return nil ,_bcfe ;};};if _ddfb =='j'&&_cfgg [_bebb -1]=='b'&&_cfgg [_bebb -2]=='o'&&IsWhiteSpace (_cfgg [_bebb -3]){_agbb :=_bebb -4;for IsWhiteSpace (_cfgg [_agbb ])&&_agbb > 0{_agbb --;};if _agbb ==0||!IsDecimalDigit (_cfgg [_agbb ]){continue ;
};for IsDecimalDigit (_cfgg [_agbb ])&&_agbb > 0{_agbb --;};if _agbb ==0||!IsWhiteSpace (_cfgg [_agbb ]){continue ;};for IsWhiteSpace (_cfgg [_agbb ])&&_agbb > 0{_agbb --;};if _agbb ==0||!IsDecimalDigit (_cfgg [_agbb ]){continue ;};for IsDecimalDigit (_cfgg [_agbb ])&&_agbb > 0{_agbb --;
};if _agbb ==0{continue ;};_bffbb :=_gbdac .GetFileOffset ()-int64 (_bebb -_agbb );_edgbf :=append (_cfgg [_agbb +1:],_ddfb );_bcgd ,_facbf ,_dfc :=_gecec (string (_edgbf ));if _dfc !=nil {_gb .Log .Debug ("\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u006e\u0075\u006d\u0062\u0065r\u003a\u0020\u0025\u0076",_dfc );
return nil ,_dfc ;};if _fgfc ,_egcc :=_gcagf .ObjectMap [_bcgd ];!_egcc ||_fgfc .Generation < _facbf {_dbdeb :=XrefObject {};_dbdeb .XType =XrefTypeTableEntry ;_dbdeb .ObjectNumber =_bcgd ;_dbdeb .Generation =_facbf ;_dbdeb .Offset =_bffbb ;_gcagf .ObjectMap [_bcgd ]=_dbdeb ;
};};_cfgg =append (_cfgg [1:_bebb ],_ddfb );};_gbdac ._cada =nil ;return &_gcagf ,nil ;};

// Clear resets the dictionary to an empty state.
func (_gabc *PdfObjectDictionary )Clear (){_gabc ._cgcf =[]PdfObjectName {};_gabc ._egfe =map[PdfObjectName ]PdfObject {};_gabc ._gfae =&_b .Mutex {};};

// RawEncoder implements Raw encoder/decoder (no encoding, pass through)
type RawEncoder struct{};

// GetNumbersAsFloat converts a list of pdf objects representing floats or integers to a slice of
// float64 values.
func GetNumbersAsFloat (objects []PdfObject )(_ededa []float64 ,_afdfa error ){for _ ,_fagc :=range objects {_dadc ,_cggg :=GetNumberAsFloat (_fagc );if _cggg !=nil {return nil ,_cggg ;};_ededa =append (_ededa ,_dadc );};return _ededa ,nil ;};

// JBIG2Encoder implements both jbig2 encoder and the decoder. The encoder allows to encode
// provided images (best used document scans) in multiple way. By default it uses single page generic
// encoder. It allows to store lossless data as a single segment.
// In order to store multiple image pages use the 'FileMode' which allows to store more pages within single jbig2 document.
// WIP: In order to obtain better compression results the encoder would allow to encode the input in a
// lossy or lossless way with a component (symbol) mode. It divides the image into components.
// Then checks if any component is 'similar' to the others and maps them together. The symbol classes are stored
// in the dictionary. Then the encoder creates text regions which uses the related symbol classes to fill it's space.
// The similarity is defined by the 'Threshold' variable (default: 0.95). The less the value is, the more components
// matches to single class, thus the compression is better, but the result might become lossy.
type JBIG2Encoder struct{

// These values are required to be set for the 'EncodeBytes' method.
// ColorComponents defines the number of color components for provided image.
ColorComponents int ;

// BitsPerComponent is the number of bits that stores per color component
BitsPerComponent int ;

// Width is the width of the image to encode
Width int ;

// Height is the height of the image to encode.
Height int ;_afbe *_ec .Document ;

// Globals are the JBIG2 global segments.
Globals _gge .Globals ;

// IsChocolateData defines if the data is encoded such that
// binary data '1' means black and '0' white.
// otherwise the data is called vanilla.
// Naming convention taken from: 'https://en.wikipedia.org/wiki/Binary_image#Interpretation'
IsChocolateData bool ;

// DefaultPageSettings are the settings parameters used by the jbig2 encoder.
DefaultPageSettings JBIG2EncoderSettings ;};

// PdfObjectReference represents the primitive PDF reference object.
type PdfObjectReference struct{_eebc *PdfParser ;ObjectNumber int64 ;GenerationNumber int64 ;};

// MakeObjectStreams creates an PdfObjectStreams from a list of PdfObjects.
func MakeObjectStreams (objects ...PdfObject )*PdfObjectStreams {return &PdfObjectStreams {_ffcdf :objects };};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_ebff *LZWEncoder )MakeDecodeParams ()PdfObject {if _ebff .Predictor > 1{_agbg :=MakeDict ();_agbg .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_ebff .Predictor )));if _ebff .BitsPerComponent !=8{_agbg .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_ebff .BitsPerComponent )));
};if _ebff .Columns !=1{_agbg .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_ebff .Columns )));};if _ebff .Colors !=1{_agbg .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_ebff .Colors )));};return _agbg ;};return nil ;
};

// DecodeStream decodes a JBIG2 encoded stream and returns the result as a slice of bytes.
func (_fbegc *JBIG2Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _fbegc .DecodeBytes (streamObj .Stream );};

// IsHexadecimal checks if the PdfObjectString contains Hexadecimal data.
func (_becae *PdfObjectString )IsHexadecimal ()bool {return _becae ._gcadg };

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_cggf *FlateEncoder )EncodeBytes (data []byte )([]byte ,error ){if _cggf .Predictor !=1&&_cggf .Predictor !=11{_gb .Log .Debug ("E\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0046\u006c\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065r\u0020P\u0072\u0065\u0064\u0069c\u0074\u006fr\u0020\u003d\u0020\u0031\u002c\u0020\u0031\u0031\u0020\u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");
return nil ,ErrUnsupportedEncodingParameters ;};if _cggf .Predictor ==11{_gfcf :=_cggf .Columns ;_gab :=len (data )/_gfcf ;if len (data )%_gfcf !=0{_gb .Log .Error ("\u0049n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");
return nil ,_f .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");};_bba :=_ba .NewBuffer (nil );_bbfe :=make ([]byte ,_gfcf );for _ade :=0;_ade < _gab ;_ade ++{_eada :=data [_gfcf *_ade :_gfcf *(_ade +1)];
_bbfe [0]=_eada [0];for _aeeg :=1;_aeeg < _gfcf ;_aeeg ++{_bbfe [_aeeg ]=byte (int (_eada [_aeeg ]-_eada [_aeeg -1])%256);};_bba .WriteByte (1);_bba .Write (_bbfe );};data =_bba .Bytes ();};var _cba _ba .Buffer ;_dgfe :=_a .NewWriter (&_cba );_dgfe .Write (data );
_dgfe .Close ();return _cba .Bytes (),nil ;};var _bdab =_d .MustCompile ("\u0073t\u0061r\u0074\u0078\u003f\u0072\u0065f\u005c\u0073*\u0028\u005c\u0064\u002b\u0029");

// PdfCryptNewEncrypt makes the document crypt handler based on a specified crypt filter.
func PdfCryptNewEncrypt (cf _egg .Filter ,userPass ,ownerPass []byte ,perm _bed .Permissions )(*PdfCrypt ,*EncryptInfo ,error ){_dc :=&PdfCrypt {_cff :make (map[PdfObject ]bool ),_aag :make (cryptFilters ),_bgf :_bed .StdEncryptDict {P :perm ,EncryptMetadata :true }};
var _caeb Version ;if cf !=nil {_age :=cf .PDFVersion ();_caeb .Major ,_caeb .Minor =_age [0],_age [1];V ,R :=cf .HandlerVersion ();_dc ._dad .V =V ;_dc ._bgf .R =R ;_dc ._dad .Length =cf .KeyLength ()*8;};const (_ebc =_afe ;);_dc ._aag [_ebc ]=cf ;if _dc ._dad .V >=4{_dc ._fca =_ebc ;
_dc ._fbd =_ebc ;};_fgf :=_dc .newEncryptDict ();_bcb :=_fcc .Sum ([]byte (_fb .Now ().Format (_fb .RFC850 )));_ebaa :=string (_bcb [:]);_cec :=make ([]byte ,100);_bc .Read (_cec );_bcb =_fcc .Sum (_cec );_fcb :=string (_bcb [:]);_gb .Log .Trace ("\u0052\u0061\u006e\u0064\u006f\u006d\u0020\u0062\u003a\u0020\u0025\u0020\u0078",_cec );
_gb .Log .Trace ("\u0047\u0065\u006e\u0020\u0049\u0064\u0020\u0030\u003a\u0020\u0025\u0020\u0078",_ebaa );_dc ._bce =_ebaa ;_ggg :=_dc .generateParams (userPass ,ownerPass );if _ggg !=nil {return nil ,nil ,_ggg ;};_dge (&_dc ._bgf ,_fgf );if _dc ._dad .V >=4{if _gggc :=_dc .saveCryptFilters (_fgf );
_gggc !=nil {return nil ,nil ,_gggc ;};};return _dc ,&EncryptInfo {Version :_caeb ,Encrypt :_fgf ,ID0 :_ebaa ,ID1 :_fcb },nil ;};

// WriteString outputs the object as it is to be written to file.
func (_fdeb *PdfObjectBool )WriteString ()string {if *_fdeb {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};

// GetFilterName returns the name of the encoding filter.
func (_bfba *CCITTFaxEncoder )GetFilterName ()string {return StreamEncodingFilterNameCCITTFax };func _bdgca (_ccdab ,_dbbg PdfObject ,_ceea int )bool {if _ceea > _aab {_gb .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_aab );
return false ;};if _ccdab ==nil &&_dbbg ==nil {return true ;}else if _ccdab ==nil ||_dbbg ==nil {return false ;};if _fa .TypeOf (_ccdab )!=_fa .TypeOf (_dbbg ){return false ;};switch _dgfaa :=_ccdab .(type ){case *PdfObjectNull ,*PdfObjectReference :return true ;
case *PdfObjectName :return *_dgfaa ==*(_dbbg .(*PdfObjectName ));case *PdfObjectString :return *_dgfaa ==*(_dbbg .(*PdfObjectString ));case *PdfObjectInteger :return *_dgfaa ==*(_dbbg .(*PdfObjectInteger ));case *PdfObjectBool :return *_dgfaa ==*(_dbbg .(*PdfObjectBool ));
case *PdfObjectFloat :return *_dgfaa ==*(_dbbg .(*PdfObjectFloat ));case *PdfIndirectObject :return _bdgca (TraceToDirectObject (_ccdab ),TraceToDirectObject (_dbbg ),_ceea +1);case *PdfObjectArray :_cbgeg :=_dbbg .(*PdfObjectArray );if len ((*_dgfaa )._edgfg )!=len ((*_cbgeg )._edgfg ){return false ;
};for _ebcee ,_gffbc :=range (*_dgfaa )._edgfg {if !_bdgca (_gffbc ,(*_cbgeg )._edgfg [_ebcee ],_ceea +1){return false ;};};return true ;case *PdfObjectDictionary :_cfegf :=_dbbg .(*PdfObjectDictionary );_gbde ,_bdcf :=(*_dgfaa )._egfe ,(*_cfegf )._egfe ;
if len (_gbde )!=len (_bdcf ){return false ;};for _cggbg ,_cdcf :=range _gbde {_facfbb ,_daca :=_bdcf [_cggbg ];if !_daca ||!_bdgca (_cdcf ,_facfbb ,_ceea +1){return false ;};};return true ;case *PdfObjectStream :_bacadg :=_dbbg .(*PdfObjectStream );return _bdgca ((*_dgfaa ).PdfObjectDictionary ,(*_bacadg ).PdfObjectDictionary ,_ceea +1);
default:_gb .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",_ccdab );
};return false ;};

// Elements returns a slice of the PdfObject elements in the array.
// Preferred over accessing the array directly as type may be changed in future major versions (v3).
func (_cfad *PdfObjectStreams )Elements ()[]PdfObject {if _cfad ==nil {return nil ;};return _cfad ._ffcdf ;};func (_faeba *PdfParser )xrefNextObjectOffset (_dggd int64 )int64 {_egfb :=int64 (0);if len (_faeba ._aaaf .ObjectMap )==0{return 0;};if len (_faeba ._aaaf ._gba )==0{_bgaae :=0;
for _ ,_ccbb :=range _faeba ._aaaf .ObjectMap {if _ccbb .Offset > 0{_bgaae ++;};};if _bgaae ==0{return 0;};_faeba ._aaaf ._gba =make ([]XrefObject ,_bgaae );_ggga :=0;for _ ,_ddbd :=range _faeba ._aaaf .ObjectMap {if _ddbd .Offset > 0{_faeba ._aaaf ._gba [_ggga ]=_ddbd ;
_ggga ++;};};_gd .Slice (_faeba ._aaaf ._gba ,func (_abdb ,_bgdf int )bool {return _faeba ._aaaf ._gba [_abdb ].Offset < _faeba ._aaaf ._gba [_bgdf ].Offset });};_afaa :=_gd .Search (len (_faeba ._aaaf ._gba ),func (_cdfe int )bool {return _faeba ._aaaf ._gba [_cdfe ].Offset >=_dggd });
if _afaa < len (_faeba ._aaaf ._gba ){_egfb =_faeba ._aaaf ._gba [_afaa ].Offset ;};return _egfb ;};func (_ddfa *PdfParser )parseDetailedHeader ()(_cfb error ){_ddfa ._ffaf .Seek (0,_ed .SeekStart );_ddfa ._eecd =_fg .NewReader (_ddfa ._ffaf );_efgd :=20;
_cbdb :=make ([]byte ,_efgd );var (_fagf bool ;_fcgg int ;);for {_dbcf ,_edf :=_ddfa ._eecd .ReadByte ();if _edf !=nil {if _edf ==_ed .EOF {break ;}else {return _edf ;};};if IsDecimalDigit (_dbcf )&&_cbdb [_efgd -1]=='.'&&IsDecimalDigit (_cbdb [_efgd -2])&&_cbdb [_efgd -3]=='-'&&_cbdb [_efgd -4]=='F'&&_cbdb [_efgd -5]=='D'&&_cbdb [_efgd -6]=='P'&&_cbdb [_efgd -7]=='%'{_ddfa ._bdc =Version {Major :int (_cbdb [_efgd -2]-'0'),Minor :int (_dbcf -'0')};
_ddfa ._fbgfd ._aadd =_fcgg -7;_fagf =true ;break ;};_fcgg ++;_cbdb =append (_cbdb [1:_efgd ],_dbcf );};if !_fagf {return _be .Errorf ("n\u006f \u0066\u0069\u006c\u0065\u0020\u0068\u0065\u0061d\u0065\u0072\u0020\u0066ou\u006e\u0064");};_dca ,_cfb :=_ddfa ._eecd .ReadByte ();
if _cfb ==_ed .EOF {return _be .Errorf ("\u006eo\u0074\u0020\u0061\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0050d\u0066\u0020\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074");};if _cfb !=nil {return _cfb ;};_ddfa ._fbgfd ._abb =_dca =='\n';_dca ,_cfb =_ddfa ._eecd .ReadByte ();
if _cfb !=nil {return _be .Errorf ("\u006e\u006f\u0074\u0020a\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0070\u0064\u0066 \u0064o\u0063\u0075\u006d\u0065\u006e\u0074\u003a \u0025\u0077",_cfb );};if _dca !='%'{return nil ;};_egd :=make ([]byte ,4);_ ,_cfb =_ddfa ._eecd .Read (_egd );
if _cfb !=nil {return _be .Errorf ("\u006e\u006f\u0074\u0020a\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0070\u0064\u0066 \u0064o\u0063\u0075\u006d\u0065\u006e\u0074\u003a \u0025\u0077",_cfb );};_ddfa ._fbgfd ._aef =[4]byte {_egd [0],_egd [1],_egd [2],_egd [3]};
return nil ;};const JB2ImageAutoThreshold =-1.0;

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_baeca *JPXEncoder )MakeDecodeParams ()PdfObject {return nil };func _dfga (_cbcb *PdfObjectStream ,_bcge *PdfObjectDictionary )(*LZWEncoder ,error ){_abfg :=NewLZWEncoder ();_aegf :=_cbcb .PdfObjectDictionary ;if _aegf ==nil {return _abfg ,nil ;};
if _bcge ==nil {_fedc :=TraceToDirectObject (_aegf .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));if _fedc !=nil {if _edfa ,_cbab :=_fedc .(*PdfObjectDictionary );_cbab {_bcge =_edfa ;}else if _gdcd ,_ebbbd :=_fedc .(*PdfObjectArray );
_ebbbd {if _gdcd .Len ()==1{if _caed ,_bgdb :=GetDict (_gdcd .Get (0));_bgdb {_bcge =_caed ;};};};if _bcge ==nil {_gb .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_fedc );
return nil ,_be .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};};_eeb :=_aegf .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");if _eeb !=nil {_agba ,_gcb :=_eeb .(*PdfObjectInteger );
if !_gcb {_gb .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a \u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065d\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u006e\u0075\u006d\u0065\u0072i\u0063 \u0028\u0025\u0054\u0029",_eeb );
return nil ,_be .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");};if *_agba !=0&&*_agba !=1{return nil ,_be .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0076\u0061\u006c\u0075e\u0020\u0028\u006e\u006f\u0074 \u0030\u0020o\u0072\u0020\u0031\u0029");
};_abfg .EarlyChange =int (*_agba );}else {_abfg .EarlyChange =1;};if _bcge ==nil {return _abfg ,nil ;};if _cefe ,_fac :=GetIntVal (_bcge .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065"));_fac {if _cefe ==0||_cefe ==1{_abfg .EarlyChange =_cefe ;
}else {_gb .Log .Debug ("W\u0041\u0052\u004e\u003a\u0020\u0069n\u0076\u0061\u006c\u0069\u0064\u0020E\u0061\u0072\u006c\u0079\u0043\u0068\u0061n\u0067\u0065\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020%\u0064",_cefe );};};_eeb =_bcge .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");
if _eeb !=nil {_bae ,_gfcg :=_eeb .(*PdfObjectInteger );if !_gfcg {_gb .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_eeb );
return nil ,_be .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_abfg .Predictor =int (*_bae );};_eeb =_bcge .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");
if _eeb !=nil {_fbcc ,_efa :=_eeb .(*PdfObjectInteger );if !_efa {_gb .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");
return nil ,_be .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_abfg .BitsPerComponent =int (*_fbcc );};if _abfg .Predictor > 1{_abfg .Columns =1;_eeb =_bcge .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");
if _eeb !=nil {_aggb ,_adb :=_eeb .(*PdfObjectInteger );if !_adb {return nil ,_be .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_abfg .Columns =int (*_aggb );
};_abfg .Colors =1;_eeb =_bcge .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _eeb !=nil {_baeg ,_fcdf :=_eeb .(*PdfObjectInteger );if !_fcdf {return nil ,_be .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");
};_abfg .Colors =int (*_baeg );};};_gb .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_bcge .String ());return _abfg ,nil ;};

// JBIG2Image is the image structure used by the jbig2 encoder. Its Data must be in a
// 1 bit per component and 1 component per pixel (1bpp). In order to create binary image
// use GoImageToJBIG2 function. If the image data contains the row bytes padding set the HasPadding to true.
type JBIG2Image struct{

// Width and Height defines the image boundaries.
Width ,Height int ;

// Data is the byte slice data for the input image
Data []byte ;

// HasPadding is the attribute that defines if the last byte of the data in the row contains
// 0 bits padding.
HasPadding bool ;};var (ErrUnsupportedEncodingParameters =_f .New ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074\u0065\u0072\u0073");ErrNoCCITTFaxDecode =_f .New ("\u0043\u0043I\u0054\u0054\u0046\u0061\u0078\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");
ErrNoJBIG2Decode =_f .New ("\u004a\u0042\u0049\u0047\u0032\u0044\u0065c\u006f\u0064\u0065 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");
ErrNoJPXDecode =_f .New ("\u004a\u0050\u0058\u0044\u0065c\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020i\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");
ErrNoPdfVersion =_f .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");ErrTypeError =_f .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");ErrRangeError =_f .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");
ErrNotSupported =_ge .New ("\u0066\u0065\u0061t\u0075\u0072\u0065\u0020n\u006f\u0074\u0020\u0063\u0075\u0072\u0072e\u006e\u0074\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");ErrNotANumber =_f .New ("\u006e\u006f\u0074 \u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072");
);

// RunLengthEncoder represents Run length encoding.
type RunLengthEncoder struct{};const (DefaultJPEGQuality =75;);

// FlateEncoder represents Flate encoding.
type FlateEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Rows int ;Colors int ;_fbee *_fe .ImageBase ;};

// GetFilterName returns the name of the encoding filter.
func (_cbe *FlateEncoder )GetFilterName ()string {return StreamEncodingFilterNameFlate };

// NewRawEncoder returns a new instace of RawEncoder.
func NewRawEncoder ()*RawEncoder {return &RawEncoder {}};

// SetIfNotNil sets the dictionary's key -> val mapping entry -IF- val is not nil.
// Note that we take care to perform a type switch.  Otherwise if we would supply a nil value
// of another type, e.g. (PdfObjectArray*)(nil), then it would not be a PdfObject(nil) and thus
// would get set.
func (_abga *PdfObjectDictionary )SetIfNotNil (key PdfObjectName ,val PdfObject ){if val !=nil {switch _gfdg :=val .(type ){case *PdfObjectName :if _gfdg !=nil {_abga .Set (key ,val );};case *PdfObjectDictionary :if _gfdg !=nil {_abga .Set (key ,val );
};case *PdfObjectStream :if _gfdg !=nil {_abga .Set (key ,val );};case *PdfObjectString :if _gfdg !=nil {_abga .Set (key ,val );};case *PdfObjectNull :if _gfdg !=nil {_abga .Set (key ,val );};case *PdfObjectInteger :if _gfdg !=nil {_abga .Set (key ,val );
};case *PdfObjectArray :if _gfdg !=nil {_abga .Set (key ,val );};case *PdfObjectBool :if _gfdg !=nil {_abga .Set (key ,val );};case *PdfObjectFloat :if _gfdg !=nil {_abga .Set (key ,val );};case *PdfObjectReference :if _gfdg !=nil {_abga .Set (key ,val );
};case *PdfIndirectObject :if _gfdg !=nil {_abga .Set (key ,val );};default:_gb .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",val );
};};};

// GetDict returns the *PdfObjectDictionary represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetDict (obj PdfObject )(_gdcg *PdfObjectDictionary ,_gbcfb bool ){_gdcg ,_gbcfb =TraceToDirectObject (obj ).(*PdfObjectDictionary );return _gdcg ,_gbcfb ;};func _edaef (_gbcc int )int {if _gbcc < 0{return -_gbcc ;};return _gbcc ;};

// PdfObjectBool represents the primitive PDF boolean object.
type PdfObjectBool bool ;func _cefg (_ccga *PdfObjectStream ,_eecg *PdfObjectDictionary )(*JBIG2Encoder ,error ){const _afa ="\u006ee\u0077\u004a\u0042\u0049G\u0032\u0044\u0065\u0063\u006fd\u0065r\u0046r\u006f\u006d\u0053\u0074\u0072\u0065\u0061m";_cbbb :=NewJBIG2Encoder ();
_debda :=_ccga .PdfObjectDictionary ;if _debda ==nil {return _cbbb ,nil ;};if _eecg ==nil {_efcc :=_debda .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _efcc !=nil {switch _efd :=_efcc .(type ){case *PdfObjectDictionary :_eecg =_efd ;
case *PdfObjectArray :if _efd .Len ()==1{if _gaee ,_gcad :=GetDict (_efd .Get (0));_gcad {_eecg =_gaee ;};};default:_gb .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065P\u0061\u0072\u0061\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064i\u0063\u0074\u0069\u006f\u006e\u0061\u0072y\u0020\u0025\u0023\u0076",_efcc );
return nil ,_geb .Errorf (_afa ,"\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050a\u0072m\u0073\u0020\u0074\u0079\u0070\u0065\u003a \u0025\u0054",_efd );};};};if _eecg ==nil {return _cbbb ,nil ;};_cbbb .UpdateParams (_eecg );
_ecggc ,_gdaf :=GetStream (_eecg .Get ("\u004a\u0042\u0049G\u0032\u0047\u006c\u006f\u0062\u0061\u006c\u0073"));if !_gdaf {return _cbbb ,nil ;};var _cbff error ;_cbbb .Globals ,_cbff =_gge .DecodeGlobals (_ecggc .Stream );if _cbff !=nil {_cbff =_geb .Wrap (_cbff ,_afa ,"\u0063\u006f\u0072\u0072u\u0070\u0074\u0065\u0064\u0020\u006a\u0062\u0069\u0067\u0032 \u0065n\u0063\u006f\u0064\u0065\u0064\u0020\u0064a\u0074\u0061");
_gb .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_cbff );return nil ,_cbff ;};return _cbbb ,nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_gfca *ASCIIHexEncoder )MakeDecodeParams ()PdfObject {return nil };

// WriteString outputs the object as it is to be written to file.
func (_bffg *PdfObjectStream )WriteString ()string {var _efadf _cc .Builder ;_efadf .WriteString (_fc .FormatInt (_bffg .ObjectNumber ,10));_efadf .WriteString ("\u0020\u0030\u0020\u0052");return _efadf .String ();};func (_ceb *PdfParser )checkPostEOFData ()error {const _ggd ="\u0025\u0025\u0045O\u0046";
_ ,_afba :=_ceb ._ffaf .Seek (-int64 (len ([]byte (_ggd )))-1,_ed .SeekEnd );if _afba !=nil {return _afba ;};_edg :=make ([]byte ,len ([]byte (_ggd ))+1);_ ,_afba =_ceb ._ffaf .Read (_edg );if _afba !=nil {if _afba !=_ed .EOF {return _afba ;};};if string (_edg )==_ggd ||string (_edg )==_ggd +"\u000a"{_ceb ._fbgfd ._cdgg =true ;
};return nil ;};var _cega =_d .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064\u002b)\u005c\u0073\u002a\u0024");

// MakeDictMap creates a PdfObjectDictionary initialized from a map of keys to values.
func MakeDictMap (objmap map[string ]PdfObject )*PdfObjectDictionary {_daec :=MakeDict ();return _daec .Update (objmap );};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_agge *RunLengthEncoder )MakeStreamDict ()*PdfObjectDictionary {_cabd :=MakeDict ();_cabd .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_agge .GetFilterName ()));return _cabd ;};

// GetNumberAsInt64 returns the contents of `obj` as an int64 if it is an integer or float, or an
// error if it isn't. This is for cases where expecting an integer, but some implementations
// actually store the number in a floating point format.
func GetNumberAsInt64 (obj PdfObject )(int64 ,error ){switch _fddg :=obj .(type ){case *PdfObjectFloat :_gb .Log .Debug ("\u004e\u0075m\u0062\u0065\u0072\u0020\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0061\u0073\u0020\u0069\u006e\u0074e\u0067\u0065\u0072\u0020\u0077\u0061s\u0020\u0073\u0074\u006f\u0072\u0065\u0064\u0020\u0061\u0073\u0020\u0066\u006c\u006fa\u0074\u0020(\u0074\u0079\u0070\u0065 \u0063\u0061\u0073\u0074\u0069n\u0067\u0020\u0075\u0073\u0065\u0064\u0029");
return int64 (*_fddg ),nil ;case *PdfObjectInteger :return int64 (*_fddg ),nil ;case *PdfObjectReference :_bgec :=TraceToDirectObject (obj );return GetNumberAsInt64 (_bgec );case *PdfIndirectObject :return GetNumberAsInt64 (_fddg .PdfObject );};return 0,ErrNotANumber ;
};

// Encrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_cbgd *PdfCrypt )Encrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _cbgd .isEncrypted (obj ){return nil ;};switch _fge :=obj .(type ){case *PdfIndirectObject :_cbgd ._cff [_fge ]=true ;_gb .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_fge .ObjectNumber ,_fge .GenerationNumber );
_fgad :=_fge .ObjectNumber ;_geg :=_fge .GenerationNumber ;_bcg :=_cbgd .Encrypt (_fge .PdfObject ,_fgad ,_geg );if _bcg !=nil {return _bcg ;};return nil ;case *PdfObjectStream :_cbgd ._cff [_fge ]=true ;_aede :=_fge .PdfObjectDictionary ;if _fcdg ,_daff :=_aede .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );
_daff &&*_fcdg =="\u0058\u0052\u0065\u0066"{return nil ;};_faaf :=_fge .ObjectNumber ;_defae :=_fge .GenerationNumber ;_gb .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_faaf ,_defae );
_dce :=_afe ;if _cbgd ._dad .V >=4{_dce =_cbgd ._fca ;_gb .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_cbgd ._fca );if _efg ,_fbadg :=_aede .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );
_fbadg {if _ecfg ,_eac :=GetName (_efg .Get (0));_eac {if *_ecfg =="\u0043\u0072\u0079p\u0074"{_dce ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _cca ,_debf :=_aede .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );
_debf {if _ddg ,_feaa :=_cca .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_feaa {if _ ,_fbea :=_cbgd ._aag [string (*_ddg )];_fbea {_gb .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_ddg );
_dce =string (*_ddg );};};};};};};_gb .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_dce );if _dce =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_daffb :=_cbgd .Encrypt (_fge .PdfObjectDictionary ,_faaf ,_defae );
if _daffb !=nil {return _daffb ;};_deg ,_daffb :=_cbgd .makeKey (_dce ,uint32 (_faaf ),uint32 (_defae ),_cbgd ._ada );if _daffb !=nil {return _daffb ;};_fge .Stream ,_daffb =_cbgd .encryptBytes (_fge .Stream ,_dce ,_deg );if _daffb !=nil {return _daffb ;
};_aede .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_fge .Stream ))));return nil ;case *PdfObjectString :_gb .Log .Trace ("\u0045n\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_aad :=_afe ;
if _cbgd ._dad .V >=4{_gb .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_cbgd ._fbd );if _cbgd ._fbd =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_aad =_cbgd ._fbd ;};_cbgda ,_eceg :=_cbgd .makeKey (_aad ,uint32 (parentObjNum ),uint32 (parentGenNum ),_cbgd ._ada );
if _eceg !=nil {return _eceg ;};_acb :=_fge .Str ();_agc :=make ([]byte ,len (_acb ));for _fbeg :=0;_fbeg < len (_acb );_fbeg ++{_agc [_fbeg ]=_acb [_fbeg ];};_gb .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_agc ,_agc );
_agc ,_eceg =_cbgd .encryptBytes (_agc ,_aad ,_cbgda );if _eceg !=nil {return _eceg ;};_fge ._fddd =string (_agc );return nil ;case *PdfObjectArray :for _ ,_fegea :=range _fge .Elements (){_acf :=_cbgd .Encrypt (_fegea ,parentObjNum ,parentGenNum );if _acf !=nil {return _acf ;
};};return nil ;case *PdfObjectDictionary :_ffg :=false ;if _afb :=_fge .Get ("\u0054\u0079\u0070\u0065");_afb !=nil {_fcef ,_fbec :=_afb .(*PdfObjectName );if _fbec &&*_fcef =="\u0053\u0069\u0067"{_ffg =true ;};};for _ ,_gebe :=range _fge .Keys (){_fceg :=_fge .Get (_gebe );
if _ffg &&string (_gebe )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;};if string (_gebe )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_gebe )!="\u0050\u0072\u0065\u0076"&&string (_gebe )!="\u004c\u0061\u0073\u0074"{_fad :=_cbgd .Encrypt (_fceg ,parentObjNum ,parentGenNum );
if _fad !=nil {return _fad ;};};};return nil ;};return nil ;};

// String returns a string describing `d`.
func (_cfdc *PdfObjectDictionary )String ()string {var _bdeg _cc .Builder ;_bdeg .WriteString ("\u0044\u0069\u0063t\u0028");for _ ,_adagd :=range _cfdc ._cgcf {_edda :=_cfdc ._egfe [_adagd ];_bdeg .WriteString ("\u0022"+_adagd .String ()+"\u0022\u003a\u0020");
_bdeg .WriteString (_edda .String ());_bdeg .WriteString ("\u002c\u0020");};_bdeg .WriteString ("\u0029");return _bdeg .String ();};

// SetPredictor sets the predictor function.  Specify the number of columns per row.
// The columns indicates the number of samples per row.
// Used for grouping data together for compression.
func (_bgfc *FlateEncoder )SetPredictor (columns int ){_bgfc .Predictor =11;_bgfc .Columns =columns };type objectCache map[int ]PdfObject ;func (_baca *JBIG2Encoder )encodeImage (_fcce _ca .Image )([]byte ,error ){const _agbe ="e\u006e\u0063\u006f\u0064\u0065\u0049\u006d\u0061\u0067\u0065";
_ecfde ,_bgeb :=GoImageToJBIG2 (_fcce ,JB2ImageAutoThreshold );if _bgeb !=nil {return nil ,_geb .Wrap (_bgeb ,_agbe ,"\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069m\u0061g\u0065\u0020\u0074\u006f\u0020\u006a\u0062\u0069\u0067\u0032\u0020\u0069\u006d\u0067");
};if _bgeb =_baca .AddPageImage (_ecfde ,&_baca .DefaultPageSettings );_bgeb !=nil {return nil ,_geb .Wrap (_bgeb ,_agbe ,"");};return _baca .Encode ();};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_cffa *ASCIIHexEncoder )MakeStreamDict ()*PdfObjectDictionary {_ecgg :=MakeDict ();_ecgg .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_cffa .GetFilterName ()));return _ecgg ;};

// String returns a string describing `streams`.
func (_fagb *PdfObjectStreams )String ()string {return _be .Sprintf ("\u004f\u0062j\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0025\u0064",_fagb .ObjectNumber );};func (_ffaa *PdfParser )parseHexString ()(*PdfObjectString ,error ){_ffaa ._eecd .ReadByte ();
var _bcbc _ba .Buffer ;for {_gccb ,_bafa :=_ffaa ._eecd .Peek (1);if _bafa !=nil {return MakeString (""),_bafa ;};if _gccb [0]=='>'{_ffaa ._eecd .ReadByte ();break ;};_gbb ,_ :=_ffaa ._eecd .ReadByte ();if _ffaa ._defe {if _ba .IndexByte (_fbbf ,_gbb )==-1{_ffaa ._fbgfd ._fdb =true ;
};};if !IsWhiteSpace (_gbb ){_bcbc .WriteByte (_gbb );};};if _bcbc .Len ()%2==1{_ffaa ._fbgfd ._ccef =true ;_bcbc .WriteRune ('0');};_cfeb ,_ :=_eb .DecodeString (_bcbc .String ());return MakeHexString (string (_cfeb )),nil ;};type cryptFilters map[string ]_egg .Filter ;


// MakeArrayFromIntegers64 creates an PdfObjectArray from a slice of int64s, where each array element
// is an PdfObjectInteger.
func MakeArrayFromIntegers64 (vals []int64 )*PdfObjectArray {_egaa :=MakeArray ();for _ ,_cfeda :=range vals {_egaa .Append (MakeInteger (_cfeda ));};return _egaa ;};func _gccba (_fdgfd PdfObject )(*float64 ,error ){switch _dgac :=_fdgfd .(type ){case *PdfObjectFloat :_dcgb :=float64 (*_dgac );
return &_dcgb ,nil ;case *PdfObjectInteger :_eefbb :=float64 (*_dgac );return &_eefbb ,nil ;case *PdfObjectNull :return nil ,nil ;};return nil ,ErrNotANumber ;};

// EqualObjects returns true if `obj1` and `obj2` have the same contents.
//
// NOTE: It is a good idea to flatten obj1 and obj2 with FlattenObject before calling this function
// so that contents, rather than references, can be compared.
func EqualObjects (obj1 ,obj2 PdfObject )bool {return _bdgca (obj1 ,obj2 ,0)};

// AddPageImage adds the page with the image 'img' to the encoder context in order to encode it jbig2 document.
// The 'settings' defines what encoding type should be used by the encoder.
func (_cacc *JBIG2Encoder )AddPageImage (img *JBIG2Image ,settings *JBIG2EncoderSettings )(_fafd error ){const _gfcad ="\u004a\u0042\u0049\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0041\u0064\u0064\u0050\u0061\u0067\u0065\u0049m\u0061\u0067\u0065";
if _cacc ==nil {return _geb .Error (_gfcad ,"J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u0020\u0069\u0073 n\u0069\u006c");};if settings ==nil {settings =&_cacc .DefaultPageSettings ;};if _cacc ._afbe ==nil {_cacc ._afbe =_ec .InitEncodeDocument (settings .FileMode );
};if _fafd =settings .Validate ();_fafd !=nil {return _geb .Wrap (_fafd ,_gfcad ,"");};_gegf ,_fafd :=img .toBitmap ();if _fafd !=nil {return _geb .Wrap (_fafd ,_gfcad ,"");};switch settings .Compression {case JB2Generic :if _fafd =_cacc ._afbe .AddGenericPage (_gegf ,settings .DuplicatedLinesRemoval );
_fafd !=nil {return _geb .Wrap (_fafd ,_gfcad ,"");};case JB2SymbolCorrelation :return _geb .Error (_gfcad ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
case JB2SymbolRankHaus :return _geb .Error (_gfcad ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
default:return _geb .Error (_gfcad ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return nil ;};

// NewDCTEncoder makes a new DCT encoder with default parameters.
func NewDCTEncoder ()*DCTEncoder {_fbg :=&DCTEncoder {};_fbg .ColorComponents =3;_fbg .BitsPerComponent =8;_fbg .Quality =DefaultJPEGQuality ;return _fbg ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_aefb *FlateEncoder )MakeStreamDict ()*PdfObjectDictionary {_bbgc :=MakeDict ();_bbgc .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_aefb .GetFilterName ()));_ccc :=_aefb .MakeDecodeParams ();if _ccc !=nil {_bbgc .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_ccc );
};return _bbgc ;};

// UpdateParams updates the parameter values of the encoder.
func (_bab *DCTEncoder )UpdateParams (params *PdfObjectDictionary ){_fdc ,_abcd :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _abcd ==nil {_bab .ColorComponents =int (_fdc );};_ggf ,_abcd :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));
if _abcd ==nil {_bab .BitsPerComponent =int (_ggf );};_eaba ,_abcd :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _abcd ==nil {_bab .Width =int (_eaba );};_adcd ,_abcd :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));
if _abcd ==nil {_bab .Height =int (_adcd );};_gdgac ,_abcd :=GetNumberAsInt64 (params .Get ("\u0051u\u0061\u006c\u0069\u0074\u0079"));if _abcd ==nil {_bab .Quality =int (_gdgac );};};

// MakeNull creates an PdfObjectNull.
func MakeNull ()*PdfObjectNull {_dagf :=PdfObjectNull {};return &_dagf };

// WriteString outputs the object as it is to be written to file.
func (_fbdge *PdfObjectNull )WriteString ()string {return "\u006e\u0075\u006c\u006c"};

// GetObjectStreams returns the *PdfObjectStreams represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetObjectStreams (obj PdfObject )(_aecbe *PdfObjectStreams ,_dcadb bool ){_aecbe ,_dcadb =obj .(*PdfObjectStreams );return _aecbe ,_dcadb ;};

// NewCompliancePdfParser creates a new PdfParser that will parse input reader with the focus on extracting more metadata, which
// might affect performance of the regular PdfParser this function.
func NewCompliancePdfParser (rs _ed .ReadSeeker )(_bdg *PdfParser ,_aff error ){_bdg =&PdfParser {_ffaf :rs ,ObjCache :make (objectCache ),_beeab :map[int64 ]bool {},_defe :true ,_eadaa :make (map[*PdfParser ]*PdfParser )};if _aff =_bdg .parseDetailedHeader ();
_aff !=nil {return nil ,_aff ;};if _bdg ._fae ,_aff =_bdg .loadXrefs ();_aff !=nil {_gb .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020F\u0061\u0069\u006c\u0065d t\u006f l\u006f\u0061\u0064\u0020\u0078\u0072\u0065f \u0074\u0061\u0062\u006c\u0065\u0021\u0020%\u0073",_aff );
return nil ,_aff ;};_gb .Log .Trace ("T\u0072\u0061\u0069\u006c\u0065\u0072\u003a\u0020\u0025\u0073",_bdg ._fae );if len (_bdg ._aaaf .ObjectMap )==0{return nil ,_be .Errorf ("\u0065\u006d\u0070\u0074\u0079\u0020\u0058\u0052\u0045\u0046\u0020t\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0049\u006e\u0076a\u006c\u0069\u0064");
};return _bdg ,nil ;};

// HeaderCommentBytes gets the header comment bytes.
func (_fgd ParserMetadata )HeaderCommentBytes ()[4]byte {return _fgd ._aef };func _eebd (_eeab string )(PdfObjectReference ,error ){_eegd :=PdfObjectReference {};_egce :=_fdab .FindStringSubmatch (_eeab );if len (_egce )< 3{_gb .Log .Debug ("\u0045\u0072\u0072or\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");
return _eegd ,_f .New ("\u0075n\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061r\u0073e\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");};_aeca ,_ :=_fc .Atoi (_egce [1]);_cced ,_ :=_fc .Atoi (_egce [2]);_eegd .ObjectNumber =int64 (_aeca );_eegd .GenerationNumber =int64 (_cced );
return _eegd ,nil ;};

// GetFileOffset returns the current file offset, accounting for buffered position.
func (_abfbe *PdfParser )GetFileOffset ()int64 {_cfdb ,_ :=_abfbe ._ffaf .Seek (0,_ed .SeekCurrent );_cfdb -=int64 (_abfbe ._eecd .Buffered ());return _cfdb ;};

// GetPreviousRevisionReadSeeker returns ReadSeeker for the previous version of the Pdf document.
func (_ebef *PdfParser )GetPreviousRevisionReadSeeker ()(_ed .ReadSeeker ,error ){if _acfg :=_ebef .seekToEOFMarker (_ebef ._gfab -_deee );_acfg !=nil {return nil ,_acfg ;};_eaege ,_ceadb :=_ebef ._ffaf .Seek (0,_ed .SeekCurrent );if _ceadb !=nil {return nil ,_ceadb ;
};_eaege +=_deee ;return _ebca (_ebef ._ffaf ,_eaege );};var _gbec =_d .MustCompile ("\u005c\u0073\u002a\u0078\u0072\u0065\u0066\u005c\u0073\u002a");

// IsDecimalDigit checks if the character is a part of a decimal number string.
func IsDecimalDigit (c byte )bool {return '0'<=c &&c <='9'};

// Update updates multiple keys and returns the dictionary back so can be used in a chained fashion.
func (_dbad *PdfObjectDictionary )Update (objmap map[string ]PdfObject )*PdfObjectDictionary {_dbad ._gfae .Lock ();defer _dbad ._gfae .Unlock ();for _dacf ,_cdcc :=range objmap {_dbad .setWithLock (PdfObjectName (_dacf ),_cdcc ,false );};return _dbad ;
};func (_dffa *PdfParser )skipSpaces ()(int ,error ){_efge :=0;for {_cdaf ,_ceegb :=_dffa ._eecd .ReadByte ();if _ceegb !=nil {return 0,_ceegb ;};if IsWhiteSpace (_cdaf ){_efge ++;}else {_dffa ._eecd .UnreadByte ();break ;};};return _efge ,nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_fbef *ASCII85Encoder )MakeDecodeParams ()PdfObject {return nil };

// DecodeBytes decodes a byte slice from Run length encoding.
//
// 7.4.5 RunLengthDecode Filter
// The RunLengthDecode filter decodes data that has been encoded in a simple byte-oriented format based on run length.
// The encoded data shall be a sequence of runs, where each run shall consist of a length byte followed by 1 to 128
// bytes of data. If the length byte is in the range 0 to 127, the following length + 1 (1 to 128) bytes shall be
// copied literally during decompression. If length is in the range 129 to 255, the following single byte shall be
// copied 257 - length (2 to 128) times during decompression. A length value of 128 shall denote EOD.
func (_eca *RunLengthEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_bcggd :=_ba .NewReader (encoded );var _bcdg []byte ;for {_cgdg ,_ccag :=_bcggd .ReadByte ();if _ccag !=nil {return nil ,_ccag ;};if _cgdg > 128{_acbd ,_dcdd :=_bcggd .ReadByte ();
if _dcdd !=nil {return nil ,_dcdd ;};for _cdac :=0;_cdac < 257-int (_cgdg );_cdac ++{_bcdg =append (_bcdg ,_acbd );};}else if _cgdg < 128{for _fbba :=0;_fbba < int (_cgdg )+1;_fbba ++{_dda ,_fabd :=_bcggd .ReadByte ();if _fabd !=nil {return nil ,_fabd ;
};_bcdg =append (_bcdg ,_dda );};}else {break ;};};return _bcdg ,nil ;};func (_efeg *PdfParser )checkLinearizedInformation (_eaae *PdfObjectDictionary )(bool ,error ){var _aaada error ;_efeg ._egcf ,_aaada =GetNumberAsInt64 (_eaae .Get ("\u004c"));if _aaada !=nil {return false ,_aaada ;
};_aaada =_efeg .seekToEOFMarker (_efeg ._egcf );switch _aaada {case nil :return true ,nil ;case _gffb :return false ,nil ;default:return false ,_aaada ;};};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_ecad *RunLengthEncoder )MakeDecodeParams ()PdfObject {return nil };func _agaf (_abeg ,_bggd ,_acfc uint8 )uint8 {_cbge :=int (_acfc );_cbbg :=int (_bggd )-_cbge ;_fgbd :=int (_abeg )-_cbge ;_cbge =_ebfag (_cbbg +_fgbd );_cbbg =_ebfag (_cbbg );_fgbd =_ebfag (_fgbd );
if _cbbg <=_fgbd &&_cbbg <=_cbge {return _abeg ;}else if _fgbd <=_cbge {return _bggd ;};return _acfc ;};var _cdaaa _b .Map ;

// IsAuthenticated returns true if the PDF has already been authenticated for accessing.
func (_ffcd *PdfParser )IsAuthenticated ()bool {return _ffcd ._cddg ._bda };

// GetPreviousRevisionParser returns PdfParser for the previous version of the Pdf document.
func (_aaec *PdfParser )GetPreviousRevisionParser ()(*PdfParser ,error ){if _aaec ._gbabc ==0{return nil ,_f .New ("\u0074\u0068\u0069\u0073 i\u0073\u0020\u0066\u0069\u0072\u0073\u0074\u0020\u0072\u0065\u0076\u0069\u0073\u0069o\u006e");};if _aeeb ,_cbad :=_aaec ._eadaa [_aaec ];
_cbad {return _aeeb ,nil ;};_dgef ,_aaeb :=_aaec .GetPreviousRevisionReadSeeker ();if _aaeb !=nil {return nil ,_aaeb ;};_fcab ,_aaeb :=NewParser (_dgef );_fcab ._eadaa =_aaec ._eadaa ;if _aaeb !=nil {return nil ,_aaeb ;};_aaec ._eadaa [_aaec ]=_fcab ;return _fcab ,nil ;
};func (_ecfa *JBIG2Image )toBitmap ()(_bdbd *_dg .Bitmap ,_agae error ){const _fadf ="\u004a\u0042\u0049\u00472I\u006d\u0061\u0067\u0065\u002e\u0074\u006f\u0042\u0069\u0074\u006d\u0061\u0070";if _ecfa .Data ==nil {return nil ,_geb .Error (_fadf ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");
};if _ecfa .Width ==0||_ecfa .Height ==0{return nil ,_geb .Error (_fadf ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");
};if _ecfa .HasPadding {_bdbd ,_agae =_dg .NewWithData (_ecfa .Width ,_ecfa .Height ,_ecfa .Data );}else {_bdbd ,_agae =_dg .NewWithUnpaddedData (_ecfa .Width ,_ecfa .Height ,_ecfa .Data );};if _agae !=nil {return nil ,_geb .Wrap (_agae ,_fadf ,"");};return _bdbd ,nil ;
};func (_dbe *PdfCrypt )decryptBytes (_cbg []byte ,_dfg string ,_bcc []byte )([]byte ,error ){_gb .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");_daab ,_gfg :=_dbe ._aag [_dfg ];if !_gfg {return nil ,_be .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_dfg );
};return _daab .DecryptBytes (_cbg ,_bcc );};func (_cfdg *ASCII85Encoder )base256Tobase85 (_ggaaa uint32 )[5]byte {_cafd :=[5]byte {0,0,0,0,0};_adeb :=_ggaaa ;for _aea :=0;_aea < 5;_aea ++{_baf :=uint32 (1);for _eaea :=0;_eaea < 4-_aea ;_eaea ++{_baf *=85;
};_fgcb :=_adeb /_baf ;_adeb =_adeb %_baf ;_cafd [_aea ]=byte (_fgcb );};return _cafd ;};func (_af *PdfParser )lookupObjectViaOS (_aa int ,_bec int )(PdfObject ,error ){var _fce *_ba .Reader ;var _cd objectStream ;var _fea bool ;_cd ,_fea =_af ._aedd [_aa ];
if !_fea {_cf ,_gc :=_af .LookupByNumber (_aa );if _gc !=nil {_gb .Log .Debug ("\u004d\u0069ss\u0069\u006e\u0067 \u006f\u0062\u006a\u0065ct \u0073tr\u0065\u0061\u006d\u0020\u0077\u0069\u0074h \u006e\u0075\u006d\u0062\u0065\u0072\u0020%\u0064",_aa );return nil ,_gc ;
};_ce ,_fga :=_cf .(*PdfObjectStream );if !_fga {return nil ,_f .New ("i\u006e\u0076\u0061\u006cid\u0020o\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d");};if _af ._cddg !=nil &&!_af ._cddg .isDecrypted (_ce ){return nil ,_f .New ("\u006e\u0065\u0065\u0064\u0020\u0074\u006f\u0020\u0064\u0065\u0063r\u0079\u0070\u0074\u0020\u0074\u0068\u0065\u0020\u0073\u0074r\u0065\u0061\u006d");
};_gdd :=_ce .PdfObjectDictionary ;_gb .Log .Trace ("\u0073o\u0020\u0064\u003a\u0020\u0025\u0073\n",_gdd .String ());_da ,_fga :=_gdd .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if !_fga {_gb .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0061\u006c\u0077\u0061\u0079\u0073\u0020\u0068\u0061\u0076\u0065\u0020\u0061\u0020\u0054\u0079\u0070\u0065");
return nil ,_f .New ("\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020T\u0079\u0070\u0065");};if _cc .ToLower (string (*_da ))!="\u006f\u0062\u006a\u0073\u0074\u006d"{_gb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0074\u0079\u0070\u0065\u0020s\u0068\u0061\u006c\u006c\u0020\u0061\u006c\u0077\u0061\u0079\u0073 \u0062\u0065\u0020\u004f\u0062\u006a\u0053\u0074\u006d\u0020\u0021");
return nil ,_f .New ("\u006f\u0062\u006a\u0065c\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0074y\u0070e\u0020\u0021\u003d\u0020\u004f\u0062\u006aS\u0074\u006d");};N ,_fga :=_gdd .Get ("\u004e").(*PdfObjectInteger );if !_fga {return nil ,_f .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u004e\u0020i\u006e\u0020\u0073\u0074\u0072\u0065\u0061m\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");
};_gdgc ,_fga :=_gdd .Get ("\u0046\u0069\u0072s\u0074").(*PdfObjectInteger );if !_fga {return nil ,_f .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0046\u0069\u0072\u0073\u0074\u0020i\u006e \u0073t\u0072e\u0061\u006d\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");
};_gb .Log .Trace ("\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0073\u0020\u006eu\u006d\u0062\u0065\u0072\u0020\u006f\u0066 \u006f\u0062\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_da ,*N );_ea ,_gc :=DecodeStream (_ce );if _gc !=nil {return nil ,_gc ;
};_gb .Log .Trace ("D\u0065\u0063\u006f\u0064\u0065\u0064\u003a\u0020\u0025\u0073",_ea );_ecc :=_af .GetFileOffset ();defer func (){_af .SetFileOffset (_ecc )}();_fce =_ba .NewReader (_ea );_af ._eecd =_fg .NewReader (_fce );_gb .Log .Trace ("\u0050a\u0072s\u0069\u006e\u0067\u0020\u006ff\u0066\u0073e\u0074\u0020\u006d\u0061\u0070");
_bd :=map[int ]int64 {};for _ga :=0;_ga < int (*N );_ga ++{_af .skipSpaces ();_ebb ,_ebd :=_af .parseNumber ();if _ebd !=nil {return nil ,_ebd ;};_fba ,_dd :=_ebb .(*PdfObjectInteger );if !_dd {return nil ,_f .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");
};_af .skipSpaces ();_ebb ,_ebd =_af .parseNumber ();if _ebd !=nil {return nil ,_ebd ;};_ced ,_dd :=_ebb .(*PdfObjectInteger );if !_dd {return nil ,_f .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");
};_gb .Log .Trace ("\u006f\u0062j\u0020\u0025\u0064 \u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0025\u0064",*_fba ,*_ced );_bd [int (*_fba )]=int64 (*_gdgc +*_ced );};_cd =objectStream {N :int (*N ),_fbb :_ea ,_ebf :_bd };_af ._aedd [_aa ]=_cd ;}else {_de :=_af .GetFileOffset ();
defer func (){_af .SetFileOffset (_de )}();_fce =_ba .NewReader (_cd ._fbb );_af ._eecd =_fg .NewReader (_fce );};_fcg :=_cd ._ebf [_bec ];_gb .Log .Trace ("\u0041\u0043\u0054\u0055AL\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u005b\u0025\u0064\u005d\u0020\u003d\u0020%\u0064",_bec ,_fcg );
_fce .Seek (_fcg ,_ed .SeekStart );_af ._eecd =_fg .NewReader (_fce );_dde ,_ :=_af ._eecd .Peek (100);_gb .Log .Trace ("\u004f\u0042\u004a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_dde ));_cede ,_cae :=_af .parseObject ();if _cae !=nil {_gb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c \u0074\u006f\u0020\u0072\u0065\u0061\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_cae );
return nil ,_cae ;};if _cede ==nil {return nil ,_f .New ("o\u0062\u006a\u0065\u0063t \u0063a\u006e\u006e\u006f\u0074\u0020b\u0065\u0020\u006e\u0075\u006c\u006c");};_ad :=PdfIndirectObject {};_ad .ObjectNumber =int64 (_bec );_ad .PdfObject =_cede ;_ad ._eebc =_af ;
return &_ad ,nil ;};

// HasOddLengthHexStrings checks if the document has odd length hexadecimal strings.
func (_dgge ParserMetadata )HasOddLengthHexStrings ()bool {return _dgge ._ccef };

// String returns a string describing `array`.
func (_aaef *PdfObjectArray )String ()string {_cbfbf :="\u005b";for _deaf ,_cdfg :=range _aaef .Elements (){_cbfbf +=_cdfg .String ();if _deaf < (_aaef .Len ()-1){_cbfbf +="\u002c\u0020";};};_cbfbf +="\u005d";return _cbfbf ;};

// XrefTable represents the cross references in a PDF, i.e. the table of objects and information
// where to access within the PDF file.
type XrefTable struct{ObjectMap map[int ]XrefObject ;_gba []XrefObject ;};const _afe ="\u0053\u0074\u0064C\u0046";

// ParseNumber parses a numeric objects from a buffered stream.
// Section 7.3.3.
// Integer or Float.
//
// An integer shall be written as one or more decimal digits optionally
// preceded by a sign. The value shall be interpreted as a signed
// decimal integer and shall be converted to an integer object.
//
// A real value shall be written as one or more decimal digits with an
// optional sign and a leading, trailing, or embedded PERIOD (2Eh)
// (decimal point). The value shall be interpreted as a real number
// and shall be converted to a real object.
//
// Regarding exponential numbers: 7.3.3 Numeric Objects:
// A conforming writer shall not use the PostScript syntax for numbers
// with non-decimal radices (such as 16#FFFE) or in exponential format
// (such as 6.02E23).
// Nonetheless, we sometimes get numbers with exponential format, so
// we will support it in the reader (no confusion with other types, so
// no compromise).
func ParseNumber (buf *_fg .Reader )(PdfObject ,error ){_gbdg :=false ;_cbbc :=true ;var _gfcae _ba .Buffer ;for {if _gb .Log .IsLogLevel (_gb .LogLevelTrace ){_gb .Log .Trace ("\u0050\u0061\u0072\u0073in\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0022\u0025\u0073\u0022",_gfcae .String ());
};_aeac ,_bdea :=buf .Peek (1);if _bdea ==_ed .EOF {break ;};if _bdea !=nil {_gb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0025\u0073",_bdea );return nil ,_bdea ;};if _cbbc &&(_aeac [0]=='-'||_aeac [0]=='+'){_ggbg ,_ :=buf .ReadByte ();_gfcae .WriteByte (_ggbg );
_cbbc =false ;}else if IsDecimalDigit (_aeac [0]){_aebaf ,_ :=buf .ReadByte ();_gfcae .WriteByte (_aebaf );}else if _aeac [0]=='.'{_dgab ,_ :=buf .ReadByte ();_gfcae .WriteByte (_dgab );_gbdg =true ;}else if _aeac [0]=='e'||_aeac [0]=='E'{_dcdf ,_ :=buf .ReadByte ();
_gfcae .WriteByte (_dcdf );_gbdg =true ;_cbbc =true ;}else {break ;};};var _fgaeg PdfObject ;if _gbdg {_adaf ,_gagfb :=_fc .ParseFloat (_gfcae .String (),64);if _gagfb !=nil {_gb .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0025v\u0020\u0065\u0072\u0072\u003d\u0025v\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0030\u002e\u0020\u004fu\u0074\u0070u\u0074\u0020\u006d\u0061y\u0020\u0062\u0065\u0020\u0069n\u0063\u006f\u0072\u0072\u0065\u0063\u0074",_gfcae .String (),_gagfb );
_adaf =0.0;};_bdace :=PdfObjectFloat (_adaf );_fgaeg =&_bdace ;}else {_dacfb ,_fbbb :=_fc .ParseInt (_gfcae .String (),10,64);if _fbbb !=nil {_gb .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0025\u0076\u0020\u0065\u0072\u0072\u003d%\u0076\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074 \u006d\u0061\u0079\u0020\u0062\u0065 \u0069\u006ec\u006f\u0072r\u0065c\u0074",_gfcae .String (),_fbbb );
_dacfb =0;};_ebbge :=PdfObjectInteger (_dacfb );_fgaeg =&_ebbge ;};return _fgaeg ,nil ;};func _ebca (_egdfg _ed .ReadSeeker ,_dbbc int64 )(*limitedReadSeeker ,error ){_ ,_dbgf :=_egdfg .Seek (0,_ed .SeekStart );if _dbgf !=nil {return nil ,_dbgf ;};return &limitedReadSeeker {_gbcf :_egdfg ,_fcacg :_dbbc },nil ;
};

// Str returns the string value of the PdfObjectString. Defined in addition to String() function to clarify that
// this function returns the underlying string directly, whereas the String function technically could include
// debug info.
func (_eacf *PdfObjectString )Str ()string {return _eacf ._fddd };

// DecodeStream decodes a LZW encoded stream and returns the result as a
// slice of bytes.
func (_gee *LZWEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_gb .Log .Trace ("\u004c\u005a\u0057 \u0044\u0065\u0063\u006f\u0064\u0069\u006e\u0067");_gb .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_gee .Predictor );
_feaeb ,_ffae :=_gee .DecodeBytes (streamObj .Stream );if _ffae !=nil {return nil ,_ffae ;};_gb .Log .Trace ("\u0020\u0049\u004e\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (streamObj .Stream ),streamObj .Stream );_gb .Log .Trace ("\u004f\u0055\u0054\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (_feaeb ),_feaeb );
if _gee .Predictor > 1{if _gee .Predictor ==2{_gb .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_abfc :=_gee .Columns *_gee .Colors ;if _abfc < 1{return []byte {},nil ;};_aba :=len (_feaeb )/_abfc ;if len (_feaeb )%_abfc !=0{_gb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");
return nil ,_be .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_feaeb ),_abfc );};if _abfc %_gee .Colors !=0{return nil ,_be .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_abfc ,_gee .Colors );
};if _abfc > len (_feaeb ){_gb .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_abfc ,len (_feaeb ));
return nil ,_f .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_gb .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_feaeb ),_feaeb );
_afd :=_ba .NewBuffer (nil );for _ffc :=0;_ffc < _aba ;_ffc ++{_ggb :=_feaeb [_abfc *_ffc :_abfc *(_ffc +1)];for _eaeg :=_gee .Colors ;_eaeg < _abfc ;_eaeg ++{_ggb [_eaeg ]=byte (int (_ggb [_eaeg ]+_ggb [_eaeg -_gee .Colors ])%256);};_afd .Write (_ggb );
};_fbdff :=_afd .Bytes ();_gb .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_fbdff ),_fbdff );return _fbdff ,nil ;}else if _gee .Predictor >=10&&_gee .Predictor <=15{_gb .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");
_geef :=_gee .Columns *_gee .Colors +1;if _geef < 1{return []byte {},nil ;};_gegg :=len (_feaeb )/_geef ;if len (_feaeb )%_geef !=0{return nil ,_be .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_feaeb ),_geef );
};if _geef > len (_feaeb ){_gb .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_geef ,len (_feaeb ));
return nil ,_f .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_abce :=_ba .NewBuffer (nil );_gb .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_gee .Columns );
_gb .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_feaeb ),_geef ,_gegg );_gafd :=make ([]byte ,_geef );for _adge :=0;_adge < _geef ;_adge ++{_gafd [_adge ]=0;
};for _adgee :=0;_adgee < _gegg ;_adgee ++{_adeg :=_feaeb [_geef *_adgee :_geef *(_adgee +1)];_fec :=_adeg [0];switch _fec {case 0:case 1:for _dafd :=2;_dafd < _geef ;_dafd ++{_adeg [_dafd ]=byte (int (_adeg [_dafd ]+_adeg [_dafd -1])%256);};case 2:for _befg :=1;
_befg < _geef ;_befg ++{_adeg [_befg ]=byte (int (_adeg [_befg ]+_gafd [_befg ])%256);};default:_gb .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0066i\u006c\u0074\u0065\u0072\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_fec );
return nil ,_be .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_fec );};for _ecbg :=0;_ecbg < _geef ;_ecbg ++{_gafd [_ecbg ]=_adeg [_ecbg ];};_abce .Write (_adeg [1:]);
};_eea :=_abce .Bytes ();return _eea ,nil ;}else {_gb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_gee .Predictor );
return nil ,_be .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_gee .Predictor );};};return _feaeb ,nil ;};

// SetFileOffset sets the file to an offset position and resets buffer.
func (_caea *PdfParser )SetFileOffset (offset int64 ){if offset < 0{offset =0;};_caea ._ffaf .Seek (offset ,_ed .SeekStart );_caea ._eecd =_fg .NewReader (_caea ._ffaf );};

// DecodeBytes decodes byte array with ASCII85. 5 ASCII characters -> 4 raw binary bytes
func (_cfcf *ASCII85Encoder )DecodeBytes (encoded []byte )([]byte ,error ){var _accee []byte ;_gb .Log .Trace ("\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0020\u0044e\u0063\u006f\u0064\u0065");_aefbd :=0;_dec :=false ;for _aefbd < len (encoded )&&!_dec {_eagc :=[5]byte {0,0,0,0,0};
_bcga :=0;_beca :=0;_bcff :=4;for _beca < 5+_bcga {if _aefbd +_beca ==len (encoded ){break ;};_ddge :=encoded [_aefbd +_beca ];if IsWhiteSpace (_ddge ){_bcga ++;_beca ++;continue ;}else if _ddge =='~'&&_aefbd +_beca +1< len (encoded )&&encoded [_aefbd +_beca +1]=='>'{_bcff =(_beca -_bcga )-1;
if _bcff < 0{_bcff =0;};_dec =true ;break ;}else if _ddge >='!'&&_ddge <='u'{_ddge -='!';}else if _ddge =='z'&&_beca -_bcga ==0{_bcff =4;_beca ++;break ;}else {_gb .Log .Error ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u002c\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020co\u0064\u0065");
return nil ,_f .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0063\u006f\u0064\u0065\u0020e\u006e\u0063\u006f\u0075\u006e\u0074\u0065\u0072\u0065\u0064");};_eagc [_beca -_bcga ]=_ddge ;_beca ++;};_aefbd +=_beca ;for _defc :=_bcff +1;_defc < 5;_defc ++{_eagc [_defc ]=84;
};_ebdd :=uint32 (_eagc [0])*85*85*85*85+uint32 (_eagc [1])*85*85*85+uint32 (_eagc [2])*85*85+uint32 (_eagc [3])*85+uint32 (_eagc [4]);_cgga :=[]byte {byte ((_ebdd >>24)&0xff),byte ((_ebdd >>16)&0xff),byte ((_ebdd >>8)&0xff),byte (_ebdd &0xff)};_accee =append (_accee ,_cgga [:_bcff ]...);
};_gb .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0065\u006e\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",encoded );_gb .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0064\u0065\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",_accee );
return _accee ,nil ;};

// PdfObject is an interface which all primitive PDF objects must implement.
type PdfObject interface{

// String outputs a string representation of the primitive (for debugging).
String ()string ;

// WriteString outputs the PDF primitive as written to file as expected by the standard.
// TODO(dennwc): it should return a byte slice, or accept a writer
WriteString ()string ;};

// NewJBIG2Encoder creates a new JBIG2Encoder.
func NewJBIG2Encoder ()*JBIG2Encoder {return &JBIG2Encoder {_afbe :_ec .InitEncodeDocument (false )}};

// UpdateParams updates the parameter values of the encoder.
func (_fcgb *ASCIIHexEncoder )UpdateParams (params *PdfObjectDictionary ){};

// DecodeBytes decodes a multi-encoded slice of bytes by passing it through the
// DecodeBytes method of the underlying encoders.
func (_fdbf *MultiEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_ebdb :=encoded ;var _bdba error ;for _ ,_gdfd :=range _fdbf ._fbgeg {_gb .Log .Trace ("\u004du\u006c\u0074i\u0020\u0045\u006e\u0063o\u0064\u0065\u0072 \u0044\u0065\u0063\u006f\u0064\u0065\u003a\u0020\u0041pp\u006c\u0079\u0069n\u0067\u0020F\u0069\u006c\u0074\u0065\u0072\u003a \u0025\u0076 \u0025\u0054",_gdfd ,_gdfd );
_ebdb ,_bdba =_gdfd .DecodeBytes (_ebdb );if _bdba !=nil {return nil ,_bdba ;};};return _ebdb ,nil ;};

// MakeArrayFromFloats creates an PdfObjectArray from a slice of float64s, where each array element is an
// PdfObjectFloat.
func MakeArrayFromFloats (vals []float64 )*PdfObjectArray {_gfbf :=MakeArray ();for _ ,_fdde :=range vals {_gfbf .Append (MakeFloat (_fdde ));};return _gfbf ;};

// NewJPXEncoder returns a new instance of JPXEncoder.
func NewJPXEncoder ()*JPXEncoder {return &JPXEncoder {}};

// LookupByNumber looks up a PdfObject by object number.  Returns an error on failure.
func (_ag *PdfParser )LookupByNumber (objNumber int )(PdfObject ,error ){_ddd ,_ ,_eaa :=_ag .lookupByNumberWrapper (objNumber ,true );return _ddd ,_eaa ;};func (_gaeb *PdfParser )repairLocateXref ()(int64 ,error ){_dadfb :=int64 (1000);_gaeb ._ffaf .Seek (-_dadfb ,_ed .SeekCurrent );
_afce ,_cfcfb :=_gaeb ._ffaf .Seek (0,_ed .SeekCurrent );if _cfcfb !=nil {return 0,_cfcfb ;};_beeb :=make ([]byte ,_dadfb );_gaeb ._ffaf .Read (_beeb );_bcba :=_bcbd .FindAllStringIndex (string (_beeb ),-1);if len (_bcba )< 1{_gb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0065\u0070a\u0069\u0072\u003a\u0020\u0078\u0072\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021");
return 0,_f .New ("\u0072\u0065\u0070\u0061ir\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064");};_fcfg :=int64 (_bcba [len (_bcba )-1][0]);_fbac :=_afce +_fcfg ;return _fbac ,nil ;};

// EncodeBytes ASCII encodes the passed in slice of bytes.
func (_fafb *ASCIIHexEncoder )EncodeBytes (data []byte )([]byte ,error ){var _dcfc _ba .Buffer ;for _ ,_bge :=range data {_dcfc .WriteString (_be .Sprintf ("\u0025\u002e\u0032X\u0020",_bge ));};_dcfc .WriteByte ('>');return _dcfc .Bytes (),nil ;};

// HasEOLAfterHeader gets information if there is a EOL after the version header.
func (_badcb ParserMetadata )HasEOLAfterHeader ()bool {return _badcb ._abb };

// DecodeBytes decodes a slice of DCT encoded bytes and returns the result.
func (_abda *DCTEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_accc :=_ba .NewReader (encoded );_dbf ,_gbfgg :=_gdg .Decode (_accc );if _gbfgg !=nil {_gb .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006eg\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_gbfgg );
return nil ,_gbfgg ;};_gabe :=_dbf .Bounds ();var _ffaef =make ([]byte ,_gabe .Dx ()*_gabe .Dy ()*_abda .ColorComponents *_abda .BitsPerComponent /8);_fffb :=0;for _efaf :=_gabe .Min .Y ;_efaf < _gabe .Max .Y ;_efaf ++{for _fcf :=_gabe .Min .X ;_fcf < _gabe .Max .X ;
_fcf ++{_edb :=_dbf .At (_fcf ,_efaf );if _abda .ColorComponents ==1{if _abda .BitsPerComponent ==16{_cadef ,_fegd :=_edb .(_eg .Gray16 );if !_fegd {return nil ,_f .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_ffaef [_fffb ]=byte ((_cadef .Y >>8)&0xff);_fffb ++;_ffaef [_fffb ]=byte (_cadef .Y &0xff);_fffb ++;}else {_feee ,_cfc :=_edb .(_eg .Gray );if !_cfc {return nil ,_f .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_ffaef [_fffb ]=_feee .Y &0xff;_fffb ++;};}else if _abda .ColorComponents ==3{if _abda .BitsPerComponent ==16{_fbeea ,_gedf :=_edb .(_eg .RGBA64 );if !_gedf {return nil ,_f .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_ffaef [_fffb ]=byte ((_fbeea .R >>8)&0xff);_fffb ++;_ffaef [_fffb ]=byte (_fbeea .R &0xff);_fffb ++;_ffaef [_fffb ]=byte ((_fbeea .G >>8)&0xff);_fffb ++;_ffaef [_fffb ]=byte (_fbeea .G &0xff);_fffb ++;_ffaef [_fffb ]=byte ((_fbeea .B >>8)&0xff);_fffb ++;
_ffaef [_fffb ]=byte (_fbeea .B &0xff);_fffb ++;}else {_cbac ,_debag :=_edb .(_eg .RGBA );if _debag {_ffaef [_fffb ]=_cbac .R &0xff;_fffb ++;_ffaef [_fffb ]=_cbac .G &0xff;_fffb ++;_ffaef [_fffb ]=_cbac .B &0xff;_fffb ++;}else {_bdde ,_fdac :=_edb .(_eg .YCbCr );
if !_fdac {return nil ,_f .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_aeda ,_cdga ,_cbf ,_ :=_bdde .RGBA ();_ffaef [_fffb ]=byte (_aeda >>8);_fffb ++;_ffaef [_fffb ]=byte (_cdga >>8);_fffb ++;_ffaef [_fffb ]=byte (_cbf >>8);
_fffb ++;};};}else if _abda .ColorComponents ==4{_aggg ,_fadb :=_edb .(_eg .CMYK );if !_fadb {return nil ,_f .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_ffaef [_fffb ]=255-_aggg .C &0xff;_fffb ++;_ffaef [_fffb ]=255-_aggg .M &0xff;
_fffb ++;_ffaef [_fffb ]=255-_aggg .Y &0xff;_fffb ++;_ffaef [_fffb ]=255-_aggg .K &0xff;_fffb ++;};};};return _ffaef ,nil ;};

// TraceToDirectObject traces a PdfObject to a direct object.  For example direct objects contained
// in indirect objects (can be double referenced even).
func TraceToDirectObject (obj PdfObject )PdfObject {if _edfca ,_ceaa :=obj .(*PdfObjectReference );_ceaa {obj =_edfca .Resolve ();};_fddb ,_fdcga :=obj .(*PdfIndirectObject );_acfac :=0;for _fdcga {obj =_fddb .PdfObject ;_fddb ,_fdcga =GetIndirect (obj );
_acfac ++;if _acfac > _aab {_gb .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0072\u0061\u0063\u0065\u0020\u0064\u0065p\u0074\u0068\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u0062\u0065\u0079\u006fn\u0064\u0020\u0025\u0064\u0020\u002d\u0020\u006e\u006f\u0074\u0020\u0067oi\u006e\u0067\u0020\u0064\u0065\u0065\u0070\u0065\u0072\u0021",_aab );
return nil ;};};return obj ;};

// String returns a descriptive information string about the encryption method used.
func (_bacb *PdfCrypt )String ()string {if _bacb ==nil {return "";};_beg :=_bacb ._dad .Filter +"\u0020\u002d\u0020";if _bacb ._dad .V ==0{_beg +="\u0055\u006e\u0064\u006fcu\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0061\u006c\u0067\u006f\u0072\u0069\u0074h\u006d";
}else if _bacb ._dad .V ==1{_beg +="\u0052\u0043\u0034:\u0020\u0034\u0030\u0020\u0062\u0069\u0074\u0073";}else if _bacb ._dad .V ==2{_beg +=_be .Sprintf ("\u0052\u0043\u0034:\u0020\u0025\u0064\u0020\u0062\u0069\u0074\u0073",_bacb ._dad .Length );}else if _bacb ._dad .V ==3{_beg +="U\u006e\u0070\u0075\u0062li\u0073h\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d";
}else if _bacb ._dad .V >=4{_beg +=_be .Sprintf ("\u0053\u0074r\u0065\u0061\u006d\u0020f\u0069\u006ct\u0065\u0072\u003a\u0020\u0025\u0073\u0020\u002d \u0053\u0074\u0072\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0074\u0065r\u003a\u0020\u0025\u0073",_bacb ._fca ,_bacb ._fbd );
_beg +="\u003b\u0020C\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0073\u003a";for _gfc ,_add :=range _bacb ._aag {_beg +=_be .Sprintf ("\u0020\u002d\u0020\u0025\u0073\u003a\u0020\u0025\u0073 \u0028\u0025\u0064\u0029",_gfc ,_add .Name (),_add .KeyLength ());
};};_gcdc :=_bacb .GetAccessPermissions ();_beg +=_be .Sprintf ("\u0020\u002d\u0020\u0025\u0023\u0076",_gcdc );return _beg ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_gdf *FlateEncoder )MakeDecodeParams ()PdfObject {if _gdf .Predictor > 1{_ggef :=MakeDict ();_ggef .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_gdf .Predictor )));if _gdf .BitsPerComponent !=8{_ggef .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_gdf .BitsPerComponent )));
};if _gdf .Columns !=1{_ggef .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_gdf .Columns )));};if _gdf .Colors !=1{_ggef .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_gdf .Colors )));};return _ggef ;};return nil ;
};

// GetFilterName returns the name of the encoding filter.
func (_eccd *RunLengthEncoder )GetFilterName ()string {return StreamEncodingFilterNameRunLength };func (_faaa *PdfCrypt )saveCryptFilters (_feae *PdfObjectDictionary )error {if _faaa ._dad .V < 4{return _f .New ("\u0063\u0061\u006e\u0020\u006f\u006e\u006c\u0079\u0020\u0062\u0065 \u0075\u0073\u0065\u0064\u0020\u0077\u0069\u0074\u0068\u0020V\u003e\u003d\u0034");
};_adab :=MakeDict ();_feae .Set ("\u0043\u0046",_adab );for _becg ,_agb :=range _faaa ._aag {if _becg =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{continue ;};_edd :=_gbfg (_agb ,"");_adab .Set (PdfObjectName (_becg ),_edd );};_feae .Set ("\u0053\u0074\u0072\u0046",MakeName (_faaa ._fbd ));
_feae .Set ("\u0053\u0074\u006d\u0046",MakeName (_faaa ._fca ));return nil ;};func (_cgaf *PdfParser )parseObject ()(PdfObject ,error ){_gb .Log .Trace ("\u0052e\u0061d\u0020\u0064\u0069\u0072\u0065c\u0074\u0020o\u0062\u006a\u0065\u0063\u0074");_cgaf .skipSpaces ();
for {_ecefa ,_cbbe :=_cgaf ._eecd .Peek (2);if _cbbe !=nil {if _cbbe !=_ed .EOF ||len (_ecefa )==0{return nil ,_cbbe ;};if len (_ecefa )==1{_ecefa =append (_ecefa ,' ');};};_gb .Log .Trace ("\u0050e\u0065k\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u003a\u0020\u0025\u0073",string (_ecefa ));
if _ecefa [0]=='/'{_cfba ,_fbab :=_cgaf .parseName ();_gb .Log .Trace ("\u002d\u003e\u004ea\u006d\u0065\u003a\u0020\u0027\u0025\u0073\u0027",_cfba );return &_cfba ,_fbab ;}else if _ecefa [0]=='('{_gb .Log .Trace ("\u002d>\u0053\u0074\u0072\u0069\u006e\u0067!");
_aebc ,_efbg :=_cgaf .parseString ();return _aebc ,_efbg ;}else if _ecefa [0]=='['{_gb .Log .Trace ("\u002d\u003e\u0041\u0072\u0072\u0061\u0079\u0021");_gcbc ,_ebea :=_cgaf .parseArray ();return _gcbc ,_ebea ;}else if (_ecefa [0]=='<')&&(_ecefa [1]=='<'){_gb .Log .Trace ("\u002d>\u0044\u0069\u0063\u0074\u0021");
_agacf ,_egae :=_cgaf .ParseDict ();return _agacf ,_egae ;}else if _ecefa [0]=='<'{_gb .Log .Trace ("\u002d\u003e\u0048\u0065\u0078\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0021");_egea ,_cfegg :=_cgaf .parseHexString ();return _egea ,_cfegg ;}else if _ecefa [0]=='%'{_cgaf .readComment ();
_cgaf .skipSpaces ();}else {_gb .Log .Trace ("\u002d\u003eN\u0075\u006d\u0062e\u0072\u0020\u006f\u0072\u0020\u0072\u0065\u0066\u003f");_ecefa ,_ =_cgaf ._eecd .Peek (15);_adgf :=string (_ecefa );_gb .Log .Trace ("\u0050\u0065\u0065k\u0020\u0073\u0074\u0072\u003a\u0020\u0025\u0073",_adgf );
if (len (_adgf )> 3)&&(_adgf [:4]=="\u006e\u0075\u006c\u006c"){_afdad ,_degac :=_cgaf .parseNull ();return &_afdad ,_degac ;}else if (len (_adgf )> 4)&&(_adgf [:5]=="\u0066\u0061\u006cs\u0065"){_ffdeb ,_gaeef :=_cgaf .parseBool ();return &_ffdeb ,_gaeef ;
}else if (len (_adgf )> 3)&&(_adgf [:4]=="\u0074\u0072\u0075\u0065"){_efce ,_dfgd :=_cgaf .parseBool ();return &_efce ,_dfgd ;};_afbd :=_fdab .FindStringSubmatch (_adgf );if len (_afbd )> 1{_ecefa ,_ =_cgaf ._eecd .ReadBytes ('R');_gb .Log .Trace ("\u002d\u003e\u0020\u0021\u0052\u0065\u0066\u003a\u0020\u0027\u0025\u0073\u0027",string (_ecefa [:]));
_gaca ,_bgac :=_eebd (string (_ecefa ));_gaca ._eebc =_cgaf ;return &_gaca ,_bgac ;};_faab :=_bgdcd .FindStringSubmatch (_adgf );if len (_faab )> 1{_gb .Log .Trace ("\u002d\u003e\u0020\u004e\u0075\u006d\u0062\u0065\u0072\u0021");_cgf ,_gefa :=_cgaf .parseNumber ();
return _cgf ,_gefa ;};_faab =_fgae .FindStringSubmatch (_adgf );if len (_faab )> 1{_gb .Log .Trace ("\u002d\u003e\u0020\u0045xp\u006f\u006e\u0065\u006e\u0074\u0069\u0061\u006c\u0020\u004e\u0075\u006d\u0062\u0065r\u0021");_gb .Log .Trace ("\u0025\u0020\u0073",_faab );
_afbde ,_cbfg :=_cgaf .parseNumber ();return _afbde ,_cbfg ;};_gb .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020U\u006e\u006b\u006e\u006f\u0077n\u0020(\u0070e\u0065\u006b\u0020\u0022\u0025\u0073\u0022)",_adgf );return nil ,_f .New ("\u006f\u0062\u006a\u0065\u0063t\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020\u0075\u006e\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e");
};};};

// NewASCIIHexEncoder makes a new ASCII hex encoder.
func NewASCIIHexEncoder ()*ASCIIHexEncoder {_ebcc :=&ASCIIHexEncoder {};return _ebcc };

// MakeString creates an PdfObjectString from a string.
// NOTE: PDF does not use utf-8 string encoding like Go so `s` will often not be a utf-8 encoded
// string.
func MakeString (s string )*PdfObjectString {_ffca :=PdfObjectString {_fddd :s };return &_ffca };

// WriteString outputs the object as it is to be written to file.
func (_bfcc *PdfObjectName )WriteString ()string {var _beffd _ba .Buffer ;if len (*_bfcc )> 127{_gb .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u004e\u0061\u006d\u0065\u0020t\u006fo\u0020l\u006f\u006e\u0067\u0020\u0028\u0025\u0073)",*_bfcc );};_beffd .WriteString ("\u002f");
for _cgcfb :=0;_cgcfb < len (*_bfcc );_cgcfb ++{_bbega :=(*_bfcc )[_cgcfb ];if !IsPrintable (_bbega )||_bbega =='#'||IsDelimiter (_bbega ){_beffd .WriteString (_be .Sprintf ("\u0023\u0025\u002e2\u0078",_bbega ));}else {_beffd .WriteByte (_bbega );};};return _beffd .String ();
};var _fbbf =[]byte ("\u0030\u0031\u0032\u003345\u0036\u0037\u0038\u0039\u0061\u0062\u0063\u0064\u0065\u0066\u0041\u0042\u0043\u0044E\u0046");func _ccd (_gbe *_egg .FilterDict ,_badf *PdfObjectDictionary )error {if _fbad ,_gf :=_badf .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );
_gf {if _bf :=string (*_fbad );_bf !="C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"{_gb .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020C\u0046\u0020\u0064ic\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074e\u0072\u0029",_bf );
};};_faa ,_ecb :=_badf .Get ("\u0043\u0046\u004d").(*PdfObjectName );if !_ecb {return _be .Errorf ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0028\u004e\u006f\u006e\u0065\u0029");
};_gbe .CFM =string (*_faa );if _baa ,_gda :=_badf .Get ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et").(*PdfObjectName );_gda {_gbe .AuthEvent =_bed .AuthEvent (*_baa );}else {_gbe .AuthEvent =_bed .EventDocOpen ;};if _bga ,_fbbe :=_badf .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );
_fbbe {_gbe .Length =int (*_bga );};return nil ;};

// Inspect analyzes the document object structure. Returns a map of object types (by name) with the instance count
// as value.
func (_faagg *PdfParser )Inspect ()(map[string ]int ,error ){return _faagg .inspect ()};

// GetString is a helper for Get that returns a string value.
// Returns false if the key is missing or a value is not a string.
func (_bfef *PdfObjectDictionary )GetString (key PdfObjectName )(string ,bool ){_cdbd :=_bfef .Get (key );if _cdbd ==nil {return "",false ;};_bdabb ,_gbdda :=_cdbd .(*PdfObjectString );if !_gbdda {return "",false ;};return _bdabb .Str (),true ;};func (_fdaff *PdfParser )repairSeekXrefMarker ()error {_gafb ,_egba :=_fdaff ._ffaf .Seek (0,_ed .SeekEnd );
if _egba !=nil {return _egba ;};_bcdf :=_d .MustCompile ("\u005cs\u0078\u0072\u0065\u0066\u005c\u0073*");var _ggeec int64 ;var _gebed int64 =1000;for _ggeec < _gafb {if _gafb <=(_gebed +_ggeec ){_gebed =_gafb -_ggeec ;};_ ,_abgcb :=_fdaff ._ffaf .Seek (-_ggeec -_gebed ,_ed .SeekEnd );
if _abgcb !=nil {return _abgcb ;};_afceb :=make ([]byte ,_gebed );_fdaff ._ffaf .Read (_afceb );_gb .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0078\u0072\u0065\u0066\u0020\u003a\u0020\u0022\u0025\u0073\u0022",string (_afceb ));
_ddfad :=_bcdf .FindAllStringIndex (string (_afceb ),-1);if _ddfad !=nil {_ffcab :=_ddfad [len (_ddfad )-1];_gb .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_ddfad );_fdaff ._ffaf .Seek (-_ggeec -_gebed +int64 (_ffcab [0]),_ed .SeekEnd );
_fdaff ._eecd =_fg .NewReader (_fdaff ._ffaf );for {_abeaf ,_facee :=_fdaff ._eecd .Peek (1);if _facee !=nil {return _facee ;};_gb .Log .Trace ("\u0042\u003a\u0020\u0025\u0064\u0020\u0025\u0063",_abeaf [0],_abeaf [0]);if !IsWhiteSpace (_abeaf [0]){break ;
};_fdaff ._eecd .Discard (1);};return nil ;};_gb .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");
_ggeec +=_gebed ;};_gb .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074a\u0062\u006c\u0065\u0020\u006d\u0061r\u006b\u0065\u0072\u0020\u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066o\u0075\u006e\u0064\u002e");
return _f .New ("\u0078r\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0020");};

// Set sets the dictionary's key -> val mapping entry. Overwrites if key already set.
func (_gfaf *PdfObjectDictionary )Set (key PdfObjectName ,val PdfObject ){_gfaf .setWithLock (key ,val ,true );};

// GetEncryptObj returns the PdfIndirectObject which has information about the PDFs encryption details.
func (_edfc *PdfParser )GetEncryptObj ()*PdfIndirectObject {return _edfc ._acfb };

// ASCII85Encoder implements ASCII85 encoder/decoder.
type ASCII85Encoder struct{};func _gecec (_cgdd string )(int ,int ,error ){_gfbb :=_effe .FindStringSubmatch (_cgdd );if len (_gfbb )< 3{return 0,0,_f .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");
};_gedc ,_ :=_fc .Atoi (_gfbb [1]);_ebga ,_ :=_fc .Atoi (_gfbb [2]);return _gedc ,_ebga ,nil ;};

// PdfObjectStream represents the primitive PDF Object stream.
type PdfObjectStream struct{PdfObjectReference ;*PdfObjectDictionary ;Stream []byte ;};func (_cgcad *PdfParser )parseName ()(PdfObjectName ,error ){var _gddb _ba .Buffer ;_dffad :=false ;for {_addb ,_efeb :=_cgcad ._eecd .Peek (1);if _efeb ==_ed .EOF {break ;
};if _efeb !=nil {return PdfObjectName (_gddb .String ()),_efeb ;};if !_dffad {if _addb [0]=='/'{_dffad =true ;_cgcad ._eecd .ReadByte ();}else if _addb [0]=='%'{_cgcad .readComment ();_cgcad .skipSpaces ();}else {_gb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020N\u0061\u006d\u0065\u0020\u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020w\u0069\u0074\u0068\u0020\u0025\u0073\u0020(\u0025\u0020\u0078\u0029",_addb ,_addb );
return PdfObjectName (_gddb .String ()),_be .Errorf ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u006ea\u006d\u0065:\u0020\u0028\u0025\u0063\u0029",_addb [0]);};}else {if IsWhiteSpace (_addb [0]){break ;}else if (_addb [0]=='/')||(_addb [0]=='[')||(_addb [0]=='(')||(_addb [0]==']')||(_addb [0]=='<')||(_addb [0]=='>'){break ;
}else if _addb [0]=='#'{_fggg ,_aega :=_cgcad ._eecd .Peek (3);if _aega !=nil {return PdfObjectName (_gddb .String ()),_aega ;};_abbc ,_aega :=_eb .DecodeString (string (_fggg [1:3]));if _aega !=nil {_gb .Log .Debug ("\u0045\u0052\u0052\u004fR\u003a\u0020\u0049\u006ev\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0066o\u006c\u006co\u0077\u0069\u006e\u0067 \u0027\u0023\u0027\u002c \u0063\u006f\u006e\u0074\u0069n\u0075\u0069\u006e\u0067\u0020\u0075\u0073i\u006e\u0067\u0020\u006c\u0069t\u0065\u0072\u0061\u006c\u0020\u002d\u0020\u004f\u0075t\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074");
_gddb .WriteByte ('#');_cgcad ._eecd .Discard (1);continue ;};_cgcad ._eecd .Discard (3);_gddb .Write (_abbc );}else {_eefd ,_ :=_cgcad ._eecd .ReadByte ();_gddb .WriteByte (_eefd );};};};return PdfObjectName (_gddb .String ()),nil ;};

// NewASCII85Encoder makes a new ASCII85 encoder.
func NewASCII85Encoder ()*ASCII85Encoder {_ddbb :=&ASCII85Encoder {};return _ddbb };

// EncodeBytes encodes the passed in slice of bytes by passing it through the
// EncodeBytes method of the underlying encoders.
func (_acfa *MultiEncoder )EncodeBytes (data []byte )([]byte ,error ){_gdcdd :=data ;var _cdd error ;for _aedb :=len (_acfa ._fbgeg )-1;_aedb >=0;_aedb --{_bfgb :=_acfa ._fbgeg [_aedb ];_gdcdd ,_cdd =_bfgb .EncodeBytes (_gdcdd );if _cdd !=nil {return nil ,_cdd ;
};};return _gdcdd ,nil ;};

// Get returns the PdfObject corresponding to the specified key.
// Returns a nil value if the key is not set.
func (_aedeb *PdfObjectDictionary )Get (key PdfObjectName )PdfObject {_aedeb ._gfae .Lock ();defer _aedeb ._gfae .Unlock ();_bgfea ,_begcg :=_aedeb ._egfe [key ];if !_begcg {return nil ;};return _bgfea ;};func (_gbae *PdfParser )seekToEOFMarker (_bebe int64 )error {var _ffgb int64 ;
var _abfcba int64 =2048;for _ffgb < _bebe -4{if _bebe <=(_abfcba +_ffgb ){_abfcba =_bebe -_ffgb ;};_ ,_dfab :=_gbae ._ffaf .Seek (_bebe -_ffgb -_abfcba ,_ed .SeekStart );if _dfab !=nil {return _dfab ;};_efgf :=make ([]byte ,_abfcba );_gbae ._ffaf .Read (_efgf );
_gb .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0045\u004f\u0046 \u006da\u0072\u006b\u0065\u0072\u003a\u0020\u0022%\u0073\u0022",string (_efgf ));_dgfd :=_bddb .FindAllStringIndex (string (_efgf ),-1);if _dgfd !=nil {_fcebc :=_dgfd [len (_dgfd )-1];
_gb .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_dgfd );_dgcd :=_bebe -_ffgb -_abfcba +int64 (_fcebc [0]);_gbae ._ffaf .Seek (_dgcd ,_ed .SeekStart );return nil ;};_gb .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");
_ffgb +=_abfcba -4;};_gb .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006be\u0072 \u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u002e");return _gffb ;};

// UpdateParams updates the parameter values of the encoder.
func (_dcfd *ASCII85Encoder )UpdateParams (params *PdfObjectDictionary ){};

// DecodeStream decodes a JPX encoded stream and returns the result as a
// slice of bytes.
func (_fdcb *JPXEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_gb .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_fdcb .GetFilterName ());
return streamObj .Stream ,ErrNoJPXDecode ;};

// NewParser creates a new parser for a PDF file via ReadSeeker. Loads the cross reference stream and trailer.
// An error is returned on failure.
func NewParser (rs _ed .ReadSeeker )(*PdfParser ,error ){_ddfg :=&PdfParser {_ffaf :rs ,ObjCache :make (objectCache ),_beeab :map[int64 ]bool {},_eggde :make ([]int64 ,0),_eadaa :make (map[*PdfParser ]*PdfParser )};_dadd ,_gegfb ,_cdddc :=_ddfg .parsePdfVersion ();
if _cdddc !=nil {_gb .Log .Error ("U\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0076e\u0072\u0073\u0069o\u006e:\u0020\u0025\u0076",_cdddc );return nil ,_cdddc ;};_ddfg ._bdc .Major =_dadd ;_ddfg ._bdc .Minor =_gegfb ;
if _ddfg ._fae ,_cdddc =_ddfg .loadXrefs ();_cdddc !=nil {_gb .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020F\u0061\u0069\u006c\u0065d t\u006f l\u006f\u0061\u0064\u0020\u0078\u0072\u0065f \u0074\u0061\u0062\u006c\u0065\u0021\u0020%\u0073",_cdddc );return nil ,_cdddc ;
};_gb .Log .Trace ("T\u0072\u0061\u0069\u006c\u0065\u0072\u003a\u0020\u0025\u0073",_ddfg ._fae );_abdba ,_cdddc :=_ddfg .parseLinearizedDictionary ();if _cdddc !=nil {return nil ,_cdddc ;};if _abdba !=nil {_ddfg ._eaec ,_cdddc =_ddfg .checkLinearizedInformation (_abdba );
if _cdddc !=nil {return nil ,_cdddc ;};};if len (_ddfg ._aaaf .ObjectMap )==0{return nil ,_be .Errorf ("\u0065\u006d\u0070\u0074\u0079\u0020\u0058\u0052\u0045\u0046\u0020t\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0049\u006e\u0076a\u006c\u0069\u0064");
};_ddfg ._gbabc =len (_ddfg ._eggde );if _ddfg ._eaec &&_ddfg ._gbabc !=0{_ddfg ._gbabc --;};_ddfg ._fcgd =make ([]*PdfParser ,_ddfg ._gbabc );return _ddfg ,nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_deef *JPXEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_fgaf *JBIG2Encoder )MakeStreamDict ()*PdfObjectDictionary {_gddc :=MakeDict ();_gddc .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_fgaf .GetFilterName ()));return _gddc ;};

// NewParserFromString is used for testing purposes.
func NewParserFromString (txt string )*PdfParser {_cgfa :=_ba .NewReader ([]byte (txt ));_bdbdb :=&PdfParser {ObjCache :objectCache {},_ffaf :_cgfa ,_eecd :_fg .NewReader (_cgfa ),_gfab :int64 (len (txt )),_beeab :map[int64 ]bool {},_eadaa :make (map[*PdfParser ]*PdfParser )};
_bdbdb ._aaaf .ObjectMap =make (map[int ]XrefObject );return _bdbdb ;};

// MakeStream creates an PdfObjectStream with specified contents and encoding. If encoding is nil, then raw encoding
// will be used (i.e. no encoding applied).
func MakeStream (contents []byte ,encoder StreamEncoder )(*PdfObjectStream ,error ){_cefgcf :=&PdfObjectStream {};if encoder ==nil {encoder =NewRawEncoder ();};_cefgcf .PdfObjectDictionary =encoder .MakeStreamDict ();_gegec ,_fcfd :=encoder .EncodeBytes (contents );
if _fcfd !=nil {return nil ,_fcfd ;};_cefgcf .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_gegec ))));_cefgcf .Stream =_gegec ;return _cefgcf ,nil ;};

// GetFilterName returns the name of the encoding filter.
func (_abfgd *ASCII85Encoder )GetFilterName ()string {return StreamEncodingFilterNameASCII85 };

// GetString returns the *PdfObjectString represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetString (obj PdfObject )(_gggg *PdfObjectString ,_egeae bool ){_gggg ,_egeae =TraceToDirectObject (obj ).(*PdfObjectString );return _gggg ,_egeae ;};

// PdfParser parses a PDF file and provides access to the object structure of the PDF.
type PdfParser struct{_bdc Version ;_ffaf _ed .ReadSeeker ;_eecd *_fg .Reader ;_gfab int64 ;_aaaf XrefTable ;_cbbgc int64 ;_dgaf *xrefType ;_aedd objectStreams ;_fae *PdfObjectDictionary ;_cddg *PdfCrypt ;_acfb *PdfIndirectObject ;_beea bool ;ObjCache objectCache ;
_cada map[int ]bool ;_beeab map[int64 ]bool ;_fbgfd ParserMetadata ;_defe bool ;_eggde []int64 ;_gbabc int ;_eaec bool ;_egcf int64 ;_eadaa map[*PdfParser ]*PdfParser ;_fcgd []*PdfParser ;};

// GetFilterName returns the name of the encoding filter.
func (_cbcc *RawEncoder )GetFilterName ()string {return StreamEncodingFilterNameRaw };

// EncodeBytes encodes slice of bytes into JBIG2 encoding format.
// The input 'data' must be an image. In order to Decode it a user is responsible to
// load the codec ('png', 'jpg').
// Returns jbig2 single page encoded document byte slice. The encoder uses DefaultPageSettings
// to encode given image.
func (_bee *JBIG2Encoder )EncodeBytes (data []byte )([]byte ,error ){const _gef ="\u004aB\u0049\u0047\u0032\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002eE\u006e\u0063\u006f\u0064\u0065\u0042\u0079\u0074\u0065\u0073";if _bee .ColorComponents !=1||_bee .BitsPerComponent !=1{return nil ,_geb .Errorf (_gef ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u002e\u0020\u004a\u0042\u0049G\u0032\u0020E\u006e\u0063o\u0064\u0065\u0072\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020bi\u006e\u0061\u0072\u0079\u0020\u0069\u006d\u0061\u0067e\u0073\u0020\u0064\u0061\u0074\u0061");
};var (_aaa *_dg .Bitmap ;_gcca error ;);_gggd :=(_bee .Width *_bee .Height )==len (data );if _gggd {_aaa ,_gcca =_dg .NewWithUnpaddedData (_bee .Width ,_bee .Height ,data );}else {_aaa ,_gcca =_dg .NewWithData (_bee .Width ,_bee .Height ,data );};if _gcca !=nil {return nil ,_gcca ;
};_gfccb :=_bee .DefaultPageSettings ;if _gcca =_gfccb .Validate ();_gcca !=nil {return nil ,_geb .Wrap (_gcca ,_gef ,"");};if _bee ._afbe ==nil {_bee ._afbe =_ec .InitEncodeDocument (_gfccb .FileMode );};switch _gfccb .Compression {case JB2Generic :if _gcca =_bee ._afbe .AddGenericPage (_aaa ,_gfccb .DuplicatedLinesRemoval );
_gcca !=nil {return nil ,_geb .Wrap (_gcca ,_gef ,"");};case JB2SymbolCorrelation :return nil ,_geb .Error (_gef ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
case JB2SymbolRankHaus :return nil ,_geb .Error (_gef ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
default:return nil ,_geb .Error (_gef ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return _bee .Encode ();};func (_fbed *PdfParser )parseArray ()(*PdfObjectArray ,error ){_fcceg :=MakeArray ();
_fbed ._eecd .ReadByte ();for {_fbed .skipSpaces ();_bdagb ,_cffaf :=_fbed ._eecd .Peek (1);if _cffaf !=nil {return _fcceg ,_cffaf ;};if _bdagb [0]==']'{_fbed ._eecd .ReadByte ();break ;};_adag ,_cffaf :=_fbed .parseObject ();if _cffaf !=nil {return _fcceg ,_cffaf ;
};_fcceg .Append (_adag );};return _fcceg ,nil ;};func _ccaa (_debb ,_gfecb ,_gfcgd int )error {if _gfecb < 0||_gfecb > _debb {return _f .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0061\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");
};if _gfcgd < _gfecb {return _f .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0073\u006c\u0069\u0063e\u0020i\u006ed\u0065\u0078\u0020\u0062\u0020\u003c\u0020a");};if _gfcgd > _debb {return _f .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0062\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");
};return nil ;};func (_cedge *PdfParser )resolveReference (_aebg *PdfObjectReference )(PdfObject ,bool ,error ){_edff ,_cbed :=_cedge .ObjCache [int (_aebg .ObjectNumber )];if _cbed {return _edff ,true ,nil ;};_cdaa ,_ffba :=_cedge .LookupByReference (*_aebg );
if _ffba !=nil {return nil ,false ,_ffba ;};_cedge .ObjCache [int (_aebg .ObjectNumber )]=_cdaa ;return _cdaa ,false ,nil ;};

// IsOctalDigit checks if a character can be part of an octal digit string.
func IsOctalDigit (c byte )bool {return '0'<=c &&c <='7'};

// ParserMetadata gets the pdf parser metadata.
func (_ddec *PdfParser )ParserMetadata ()(ParserMetadata ,error ){if !_ddec ._defe {return ParserMetadata {},_be .Errorf ("\u0070\u0061\u0072\u0073\u0065r\u0020\u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u006d\u0061\u0072\u006be\u0064\u0020\u0066\u006f\u0072\u0020\u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0064\u0065\u0074\u0061\u0069\u006c\u0065\u0064\u0020\u006d\u0065\u0074\u0061\u0064\u0061\u0074a");
};return _ddec ._fbgfd ,nil ;};

// PdfObjectFloat represents the primitive PDF floating point numerical object.
type PdfObjectFloat float64 ;func (_cee *PdfCrypt )newEncryptDict ()*PdfObjectDictionary {_gaf :=MakeDict ();_gaf .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName ("\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"));_gaf .Set ("\u0056",MakeInteger (int64 (_cee ._dad .V )));
_gaf .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_cee ._dad .Length )));return _gaf ;};

// Resolve resolves the reference and returns the indirect or stream object.
// If the reference cannot be resolved, a *PdfObjectNull object is returned.
func (_fffc *PdfObjectReference )Resolve ()PdfObject {if _fffc ._eebc ==nil {return MakeNull ();};_dbec ,_ ,_fdgfa :=_fffc ._eebc .resolveReference (_fffc );if _fdgfa !=nil {_gb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0072\u0065\u0073\u006f\u006cv\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065r\u0065n\u0063\u0065\u003a\u0020\u0025\u0076\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074",_fdgfa );
return MakeNull ();};if _dbec ==nil {_gb .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0072\u0065\u0073ol\u0076\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065:\u0020\u006ei\u006c\u0020\u006fb\u006a\u0065\u0063\u0074\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u0061\u0020nu\u006c\u006c\u0020o\u0062\u006a\u0065\u0063\u0074");
return MakeNull ();};return _dbec ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set.  Some other parameters are generated elsewhere.
func (_fdg *DCTEncoder )MakeStreamDict ()*PdfObjectDictionary {_baag :=MakeDict ();_baag .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_fdg .GetFilterName ()));return _baag ;};type limitedReadSeeker struct{_gbcf _ed .ReadSeeker ;_fcacg int64 ;
};

// MakeEncodedString creates a PdfObjectString with encoded content, which can be either
// UTF-16BE or PDFDocEncoding depending on whether `utf16BE` is true or false respectively.
func MakeEncodedString (s string ,utf16BE bool )*PdfObjectString {if utf16BE {var _ccbe _ba .Buffer ;_ccbe .Write ([]byte {0xFE,0xFF});_ccbe .WriteString (_db .StringToUTF16 (s ));return &PdfObjectString {_fddd :_ccbe .String (),_gcadg :true };};return &PdfObjectString {_fddd :string (_db .StringToPDFDocEncoding (s )),_gcadg :false };
};

// GetXrefType returns the type of the first xref object (table or stream).
func (_cdbc *PdfParser )GetXrefType ()*xrefType {return _cdbc ._dgaf };const (XrefTypeTableEntry xrefType =iota ;XrefTypeObjectStream xrefType =iota ;);

// DCTEncoder provides a DCT (JPG) encoding/decoding functionality for images.
type DCTEncoder struct{ColorComponents int ;BitsPerComponent int ;Width int ;Height int ;Quality int ;};

// GetFilterName returns the name of the encoding filter.
func (_addc *JPXEncoder )GetFilterName ()string {return StreamEncodingFilterNameJPX };func (_agfd *PdfParser )skipComments ()error {if _ ,_fgfg :=_agfd .skipSpaces ();_fgfg !=nil {return _fgfg ;};_gbfd :=true ;for {_degge ,_egbda :=_agfd ._eecd .Peek (1);
if _egbda !=nil {_gb .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_egbda .Error ());return _egbda ;};if _gbfd &&_degge [0]!='%'{return nil ;};_gbfd =false ;if (_degge [0]!='\r')&&(_degge [0]!='\n'){_agfd ._eecd .ReadByte ();}else {break ;
};};return _agfd .skipComments ();};

// GetObjectNums returns a sorted list of object numbers of the PDF objects in the file.
func (_gdbc *PdfParser )GetObjectNums ()[]int {var _ddeg []int ;for _ ,_aedg :=range _gdbc ._aaaf .ObjectMap {_ddeg =append (_ddeg ,_aedg .ObjectNumber );};_gd .Ints (_ddeg );return _ddeg ;};

// GetAccessPermissions returns the PDF access permissions as an AccessPermissions object.
func (_bagc *PdfCrypt )GetAccessPermissions ()_bed .Permissions {return _bagc ._bgf .P };

// Set sets the PdfObject at index i of the streams. An error is returned if the index is outside bounds.
func (_dfbg *PdfObjectStreams )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_dfbg ._ffcdf ){return _f .New ("\u004f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_dfbg ._ffcdf [i ]=obj ;return nil ;};

// DecodeStream decodes RunLengthEncoded stream object and give back decoded bytes.
func (_egdf *RunLengthEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _egdf .DecodeBytes (streamObj .Stream );};

// ParserMetadata is the parser based metadata information about document.
// The data here could be used on document verification.
type ParserMetadata struct{_aadd int ;_abb bool ;_aef [4]byte ;_cdgg bool ;_ccef bool ;_fdb bool ;_bcgg bool ;_gbd bool ;_egbf bool ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_bccg *MultiEncoder )MakeStreamDict ()*PdfObjectDictionary {_bdfa :=MakeDict ();_bdfa .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",_bccg .GetFilterArray ());for _ ,_bddc :=range _bccg ._fbgeg {_baagf :=_bddc .MakeStreamDict ();for _ ,_ddef :=range _baagf .Keys (){_acea :=_baagf .Get (_ddef );
if _ddef !="\u0046\u0069\u006c\u0074\u0065\u0072"&&_ddef !="D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"{_bdfa .Set (_ddef ,_acea );};};};_ecbd :=_bccg .MakeDecodeParams ();if _ecbd !=nil {_bdfa .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_ecbd );
};return _bdfa ;};func _dddc (_bagcd *PdfObjectStream ,_bdac *MultiEncoder )(*DCTEncoder ,error ){_acad :=NewDCTEncoder ();_gbda :=_bagcd .PdfObjectDictionary ;if _gbda ==nil {return _acad ,nil ;};_dbde :=_bagcd .Stream ;if _bdac !=nil {_gdgd ,_ffdg :=_bdac .DecodeBytes (_dbde );
if _ffdg !=nil {return nil ,_ffdg ;};_dbde =_gdgd ;};_aafc :=_ba .NewReader (_dbde );_ffbe ,_agcc :=_gdg .DecodeConfig (_aafc );if _agcc !=nil {_gb .Log .Debug ("\u0045\u0072\u0072or\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0065\u003a\u0020\u0025\u0073",_agcc );
return nil ,_agcc ;};switch _ffbe .ColorModel {case _eg .RGBAModel :_acad .BitsPerComponent =8;_acad .ColorComponents =3;case _eg .RGBA64Model :_acad .BitsPerComponent =16;_acad .ColorComponents =3;case _eg .GrayModel :_acad .BitsPerComponent =8;_acad .ColorComponents =1;
case _eg .Gray16Model :_acad .BitsPerComponent =16;_acad .ColorComponents =1;case _eg .CMYKModel :_acad .BitsPerComponent =8;_acad .ColorComponents =4;case _eg .YCbCrModel :_acad .BitsPerComponent =8;_acad .ColorComponents =3;default:return nil ,_f .New ("\u0075\u006e\u0073up\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u006d\u006f\u0064\u0065\u006c");
};_acad .Width =_ffbe .Width ;_acad .Height =_ffbe .Height ;_gb .Log .Trace ("\u0044\u0043T\u0020\u0045\u006ec\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076",_acad );_acad .Quality =DefaultJPEGQuality ;return _acad ,nil ;};

// String returns a string representation of the *PdfObjectString.
func (_dded *PdfObjectString )String ()string {return _dded ._fddd };

// String returns a string describing `stream`.
func (_dbcag *PdfObjectStream )String ()string {return _be .Sprintf ("O\u0062j\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0025\u0064: \u0025\u0073",_dbcag .ObjectNumber ,_dbcag .PdfObjectDictionary );};func _fbbga (_gbf XrefTable ){_gb .Log .Debug ("\u003dX\u003d\u0058\u003d\u0058\u003d");
_gb .Log .Debug ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");_dab :=0;for _ ,_egb :=range _gbf .ObjectMap {_gb .Log .Debug ("i\u002b\u0031\u003a\u0020\u0025\u0064 \u0028\u006f\u0062\u006a\u0020\u006eu\u006d\u003a\u0020\u0025\u0064\u0020\u0067e\u006e\u003a\u0020\u0025\u0064\u0029\u0020\u002d\u003e\u0020%\u0064",_dab +1,_egb .ObjectNumber ,_egb .Generation ,_egb .Offset );
_dab ++;};};func (_efad *offsetReader )Read (p []byte )(_beae int ,_gbfc error ){return _efad ._aec .Read (p )};

// NewLZWEncoder makes a new LZW encoder with default parameters.
func NewLZWEncoder ()*LZWEncoder {_egfg :=&LZWEncoder {};_egfg .Predictor =1;_egfg .BitsPerComponent =8;_egfg .Colors =1;_egfg .Columns =1;_egfg .EarlyChange =1;return _egfg ;};func (_eeaa *PdfParser )parseString ()(*PdfObjectString ,error ){_eeaa ._eecd .ReadByte ();
var _cddd _ba .Buffer ;_dfadd :=1;for {_acbg ,_bagg :=_eeaa ._eecd .Peek (1);if _bagg !=nil {return MakeString (_cddd .String ()),_bagg ;};if _acbg [0]=='\\'{_eeaa ._eecd .ReadByte ();_afgd ,_abbf :=_eeaa ._eecd .ReadByte ();if _abbf !=nil {return MakeString (_cddd .String ()),_abbf ;
};if IsOctalDigit (_afgd ){_agdd ,_bebf :=_eeaa ._eecd .Peek (2);if _bebf !=nil {return MakeString (_cddd .String ()),_bebf ;};var _dgcf []byte ;_dgcf =append (_dgcf ,_afgd );for _ ,_cffc :=range _agdd {if IsOctalDigit (_cffc ){_dgcf =append (_dgcf ,_cffc );
}else {break ;};};_eeaa ._eecd .Discard (len (_dgcf )-1);_gb .Log .Trace ("\u004e\u0075\u006d\u0065ri\u0063\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0022\u0025\u0073\u0022",_dgcf );_gbea ,_bebf :=_fc .ParseUint (string (_dgcf ),8,32);if _bebf !=nil {return MakeString (_cddd .String ()),_bebf ;
};_cddd .WriteByte (byte (_gbea ));continue ;};switch _afgd {case 'n':_cddd .WriteRune ('\n');case 'r':_cddd .WriteRune ('\r');case 't':_cddd .WriteRune ('\t');case 'b':_cddd .WriteRune ('\b');case 'f':_cddd .WriteRune ('\f');case '(':_cddd .WriteRune ('(');
case ')':_cddd .WriteRune (')');case '\\':_cddd .WriteRune ('\\');};continue ;}else if _acbg [0]=='('{_dfadd ++;}else if _acbg [0]==')'{_dfadd --;if _dfadd ==0{_eeaa ._eecd .ReadByte ();break ;};};_bacad ,_ :=_eeaa ._eecd .ReadByte ();_cddd .WriteByte (_bacad );
};return MakeString (_cddd .String ()),nil ;};

// NewRunLengthEncoder makes a new run length encoder
func NewRunLengthEncoder ()*RunLengthEncoder {return &RunLengthEncoder {}};

// ResolveReference resolves reference if `o` is a *PdfObjectReference and returns the object referenced to.
// Otherwise returns back `o`.
func ResolveReference (obj PdfObject )PdfObject {if _eebe ,_cabg :=obj .(*PdfObjectReference );_cabg {return _eebe .Resolve ();};return obj ;};

// Append appends PdfObject(s) to the array.
func (_eagcb *PdfObjectArray )Append (objects ...PdfObject ){if _eagcb ==nil {_gb .Log .Debug ("\u0057\u0061\u0072\u006e\u0020\u002d\u0020\u0041\u0074\u0074\u0065\u006d\u0070t\u0020\u0074\u006f\u0020\u0061\u0070p\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020a\u0072\u0072\u0061\u0079");
return ;};_eagcb ._edgfg =append (_eagcb ._edgfg ,objects ...);};func (_ebbeg *PdfCrypt )encryptBytes (_dabf []byte ,_deb string ,_cabc []byte )([]byte ,error ){_gb .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");
_dacd ,_eef :=_ebbeg ._aag [_deb ];if !_eef {return nil ,_be .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_deb );};return _dacd .EncryptBytes (_dabf ,_cabc );};var _fdab =_d .MustCompile ("\u005e\\\u0073\u002a\u005b\u002d]\u002a\u0028\u005c\u0064\u002b)\u005cs\u002b(\u005c\u0064\u002b\u0029\u005c\u0073\u002bR");


// ASCIIHexEncoder implements ASCII hex encoder/decoder.
type ASCIIHexEncoder struct{};

// GetStringBytes is like GetStringVal except that it returns the string as a []byte.
// It is for convenience.
func GetStringBytes (obj PdfObject )(_geab []byte ,_fgggfb bool ){_eaagb ,_fgggfb :=TraceToDirectObject (obj ).(*PdfObjectString );if _fgggfb {return _eaagb .Bytes (),true ;};return ;};

// PdfVersion returns version of the PDF file.
func (_fbae *PdfParser )PdfVersion ()Version {return _fbae ._bdc };

// ToFloat64Array returns a slice of all elements in the array as a float64 slice.  An error is
// returned if the array contains non-numeric objects (each element can be either PdfObjectInteger
// or PdfObjectFloat).
func (_bddf *PdfObjectArray )ToFloat64Array ()([]float64 ,error ){var _ageg []float64 ;for _ ,_cafe :=range _bddf .Elements (){switch _aeba :=_cafe .(type ){case *PdfObjectInteger :_ageg =append (_ageg ,float64 (*_aeba ));case *PdfObjectFloat :_ageg =append (_ageg ,float64 (*_aeba ));
default:return nil ,ErrTypeError ;};};return _ageg ,nil ;};func _bad (_cea PdfObject )(int64 ,int64 ,error ){if _gcc ,_cef :=_cea .(*PdfIndirectObject );_cef {return _gcc .ObjectNumber ,_gcc .GenerationNumber ,nil ;};if _df ,_daf :=_cea .(*PdfObjectStream );
_daf {return _df .ObjectNumber ,_df .GenerationNumber ,nil ;};return 0,0,_f .New ("\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u002f\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062je\u0063\u0074");};

// String returns the PDF version as a string. Implements interface fmt.Stringer.
func (_accce Version )String ()string {return _be .Sprintf ("\u00250\u0064\u002e\u0025\u0030\u0064",_accce .Major ,_accce .Minor );};

// MakeArray creates an PdfObjectArray from a list of PdfObjects.
func MakeArray (objects ...PdfObject )*PdfObjectArray {return &PdfObjectArray {_edgfg :objects }};func (_bgbac *PdfParser )readComment ()(string ,error ){var _agac _ba .Buffer ;_ ,_agga :=_bgbac .skipSpaces ();if _agga !=nil {return _agac .String (),_agga ;
};_facb :=true ;for {_bdda ,_deca :=_bgbac ._eecd .Peek (1);if _deca !=nil {_gb .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_deca .Error ());return _agac .String (),_deca ;};if _facb &&_bdda [0]!='%'{return _agac .String (),_f .New ("c\u006f\u006d\u006d\u0065\u006e\u0074 \u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0073\u0074a\u0072\u0074\u0020w\u0069t\u0068\u0020\u0025");
};_facb =false ;if (_bdda [0]!='\r')&&(_bdda [0]!='\n'){_egec ,_ :=_bgbac ._eecd .ReadByte ();_agac .WriteByte (_egec );}else {break ;};};return _agac .String (),nil ;};

// GetArray returns the *PdfObjectArray represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetArray (obj PdfObject )(_cgcfa *PdfObjectArray ,_bbad bool ){_cgcfa ,_bbad =TraceToDirectObject (obj ).(*PdfObjectArray );return _cgcfa ,_bbad ;};

// JBIG2CompressionType defines the enum compression type used by the JBIG2Encoder.
type JBIG2CompressionType int ;

// DecodeStream decodes the stream containing CCITTFax encoded image data.
func (_gdaa *CCITTFaxEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _gdaa .DecodeBytes (streamObj .Stream );};

// UpdateParams updates the parameter values of the encoder.
func (_dgaa *JPXEncoder )UpdateParams (params *PdfObjectDictionary ){};

// GetNumberAsFloat returns the contents of `obj` as a float if it is an integer or float, or an
// error if it isn't.
func GetNumberAsFloat (obj PdfObject )(float64 ,error ){switch _fbdg :=obj .(type ){case *PdfObjectFloat :return float64 (*_fbdg ),nil ;case *PdfObjectInteger :return float64 (*_fbdg ),nil ;case *PdfObjectReference :_gdcbc :=TraceToDirectObject (obj );
return GetNumberAsFloat (_gdcbc );case *PdfIndirectObject :return GetNumberAsFloat (_fbdg .PdfObject );};return 0,ErrNotANumber ;};

// EncodeBytes JPX encodes the passed in slice of bytes.
func (_bfe *JPXEncoder )EncodeBytes (data []byte )([]byte ,error ){_gb .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_bfe .GetFilterName ());
return data ,ErrNoJPXDecode ;};

// GetBoolVal returns the bool value within a *PdObjectBool represented by an PdfObject interface directly or indirectly.
// If the PdfObject does not represent a bool value, a default value of false is returned (found = false also).
func GetBoolVal (obj PdfObject )(_gfda bool ,_bbbb bool ){_cggc ,_bbbb :=TraceToDirectObject (obj ).(*PdfObjectBool );if _bbbb {return bool (*_cggc ),true ;};return false ,false ;};

// GetXrefTable returns the PDFs xref table.
func (_bcdgac *PdfParser )GetXrefTable ()XrefTable {return _bcdgac ._aaaf };const (_feff =0;_dcc =1;_ccf =2;_aca =3;_abe =4;);func (_ccge *PdfParser )rebuildXrefTable ()error {_fgabd :=XrefTable {};_fgabd .ObjectMap =map[int ]XrefObject {};_daddg :=make ([]int ,0,len (_ccge ._aaaf .ObjectMap ));
for _agab :=range _ccge ._aaaf .ObjectMap {_daddg =append (_daddg ,_agab );};_gd .Ints (_daddg );for _ ,_dedba :=range _daddg {_eebf :=_ccge ._aaaf .ObjectMap [_dedba ];_bddfa ,_ ,_adcg :=_ccge .lookupByNumberWrapper (_dedba ,false );if _adcg !=nil {_gb .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020U\u006e\u0061\u0062\u006ce t\u006f l\u006f\u006f\u006b\u0020\u0075\u0070\u0020ob\u006a\u0065\u0063\u0074\u0020\u0028\u0025s\u0029",_adcg );
_gb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0063\u006fm\u0070\u006c\u0065\u0074\u0065\u006c\u0079\u0020\u0062\u0072\u006f\u006b\u0065\u006e\u0020\u002d\u0020\u0061\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0074\u006f \u0072\u0065\u0070\u0061\u0069r\u0020");
_gcdca ,_gefae :=_ccge .repairRebuildXrefsTopDown ();if _gefae !=nil {_gb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0072\u0065\u0062\u0075\u0069l\u0064\u0020\u0072\u0065\u0070a\u0069\u0072 \u0028\u0025\u0073\u0029",_gefae );
return _gefae ;};_ccge ._aaaf =*_gcdca ;_gb .Log .Debug ("\u0052e\u0070\u0061\u0069\u0072e\u0064\u0020\u0078\u0072\u0065f\u0020t\u0061b\u006c\u0065\u0020\u0062\u0075\u0069\u006ct");return nil ;};_caced ,_gbdbe ,_adcg :=_bad (_bddfa );if _adcg !=nil {return _adcg ;
};_eebf .ObjectNumber =int (_caced );_eebf .Generation =int (_gbdbe );_fgabd .ObjectMap [int (_caced )]=_eebf ;};_ccge ._aaaf =_fgabd ;_gb .Log .Debug ("N\u0065w\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061b\u006c\u0065\u0020\u0062ui\u006c\u0074");_fbbga (_ccge ._aaaf );
return nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_gfcce *CCITTFaxEncoder )MakeStreamDict ()*PdfObjectDictionary {_aeaa :=MakeDict ();_aeaa .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_gfcce .GetFilterName ()));_aeaa .SetIfNotNil ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_gfcce .MakeDecodeParams ());
return _aeaa ;};

// PdfCrypt provides PDF encryption/decryption support.
// The PDF standard supports encryption of strings and streams (Section 7.6).
type PdfCrypt struct{_dad encryptDict ;_bgf _bed .StdEncryptDict ;_bce string ;_ada []byte ;_bgg map[PdfObject ]bool ;_cff map[PdfObject ]bool ;_bda bool ;_aag cryptFilters ;_fca string ;_fbd string ;_gbaa *PdfParser ;_dcb map[int ]struct{};};

// PdfObjectArray represents the primitive PDF array object.
type PdfObjectArray struct{_edgfg []PdfObject };

// UpdateParams updates the parameter values of the encoder.
func (_ccaf *CCITTFaxEncoder )UpdateParams (params *PdfObjectDictionary ){if _afea ,_fcag :=GetNumberAsInt64 (params .Get ("\u004b"));_fcag ==nil {_ccaf .K =int (_afea );};if _geec ,_acab :=GetNumberAsInt64 (params .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));
_acab ==nil {_ccaf .Columns =int (_geec );}else if _geec ,_acab =GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));_acab ==nil {_ccaf .Columns =int (_geec );};if _edce ,_bfbd :=GetNumberAsInt64 (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));
_bfbd ==nil {_ccaf .BlackIs1 =_edce > 0;}else {if _aegb ,_cbcd :=GetBoolVal (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_cbcd {_ccaf .BlackIs1 =_aegb ;}else {if _bbgb ,_geaa :=GetArray (params .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));
_geaa {_ccde ,_ggeb :=_bbgb .ToIntegerArray ();if _ggeb ==nil {_ccaf .BlackIs1 =_ccde [0]==1&&_ccde [1]==0;};};};};if _decg ,_bfbb :=GetNumberAsInt64 (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));
_bfbb ==nil {_ccaf .EncodedByteAlign =_decg > 0;}else {if _fcac ,_bgdc :=GetBoolVal (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_bgdc {_ccaf .EncodedByteAlign =_fcac ;};};if _gabed ,_cccg :=GetNumberAsInt64 (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));
_cccg ==nil {_ccaf .EndOfLine =_gabed > 0;}else {if _ccgf ,_gdcb :=GetBoolVal (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_gdcb {_ccaf .EndOfLine =_ccgf ;};};if _dabfg ,_ddcc :=GetNumberAsInt64 (params .Get ("\u0052\u006f\u0077\u0073"));
_ddcc ==nil {_ccaf .Rows =int (_dabfg );}else if _dabfg ,_ddcc =GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));_ddcc ==nil {_ccaf .Rows =int (_dabfg );};if _efea ,_bbeab :=GetNumberAsInt64 (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));
_bbeab ==nil {_ccaf .EndOfBlock =_efea > 0;}else {if _ebdf ,_fdgba :=GetBoolVal (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_fdgba {_ccaf .EndOfBlock =_ebdf ;};};if _gccd ,_eega :=GetNumberAsInt64 (params .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));
_eega !=nil {_ccaf .DamagedRowsBeforeError =int (_gccd );};};

// DecodeBytes decodes the CCITTFax encoded image data.
func (_gafc *CCITTFaxEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_agbad ,_aeec :=_ac .NewDecoder (encoded ,_ac .DecodeOptions {Columns :_gafc .Columns ,Rows :_gafc .Rows ,K :_gafc .K ,EncodedByteAligned :_gafc .EncodedByteAlign ,BlackIsOne :_gafc .BlackIs1 ,EndOfBlock :_gafc .EndOfBlock ,EndOfLine :_gafc .EndOfLine ,DamagedRowsBeforeError :_gafc .DamagedRowsBeforeError });
if _aeec !=nil {return nil ,_aeec ;};_dgc ,_aeec :=_c .ReadAll (_agbad );if _aeec !=nil {return nil ,_aeec ;};return _dgc ,nil ;};

// GoImageToJBIG2 creates a binary image on the base of 'i' golang image.Image.
// If the image is not a black/white image then the function converts provided input into
// JBIG2Image with 1bpp. For non grayscale images the function performs the conversion to the grayscale temp image.
// Then it checks the value of the gray image value if it's within bounds of the black white threshold.
// This 'bwThreshold' value should be in range (0.0, 1.0). The threshold checks if the grayscale pixel (uint) value
// is greater or smaller than 'bwThreshold' * 255. Pixels inside the range will be white, and the others will be black.
// If the 'bwThreshold' is equal to -1.0 - JB2ImageAutoThreshold then it's value would be set on the base of
// it's histogram using Triangle method. For more information go to:
// 	https://www.mathworks.com/matlabcentral/fileexchange/28047-gray-image-thresholding-using-the-triangle-method
func GoImageToJBIG2 (i _ca .Image ,bwThreshold float64 )(*JBIG2Image ,error ){const _gfac ="\u0047\u006f\u0049\u006d\u0061\u0067\u0065\u0054\u006fJ\u0042\u0049\u0047\u0032";if i ==nil {return nil ,_geb .Error (_gfac ,"i\u006d\u0061\u0067\u0065 '\u0069'\u0020\u006e\u006f\u0074\u0020d\u0065\u0066\u0069\u006e\u0065\u0064");
};var (_eged uint8 ;_cfeg _fe .Image ;_baba error ;);if bwThreshold ==JB2ImageAutoThreshold {_cfeg ,_baba =_fe .MonochromeConverter .Convert (i );}else if bwThreshold > 1.0||bwThreshold < 0.0{return nil ,_geb .Error (_gfac ,"p\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074h\u0072\u0065\u0073\u0068\u006f\u006c\u0064 i\u0073\u0020\u006e\u006ft\u0020\u0069\u006e\u0020\u0061\u0020\u0072\u0061\u006ege\u0020\u007b0\u002e\u0030\u002c\u0020\u0031\u002e\u0030\u007d");
}else {_eged =uint8 (255*bwThreshold );_cfeg ,_baba =_fe .MonochromeThresholdConverter (_eged ).Convert (i );};if _baba !=nil {return nil ,_baba ;};return _ffde (_cfeg ),nil ;};

// JBIG2EncoderSettings contains the parameters and settings used by the JBIG2Encoder.
// Current version works only on JB2Generic compression.
type JBIG2EncoderSettings struct{

// FileMode defines if the jbig2 encoder should return full jbig2 file instead of
// shortened pdf mode. This adds the file header to the jbig2 definition.
FileMode bool ;

// Compression is the setting that defines the compression type used for encoding the page.
Compression JBIG2CompressionType ;

// DuplicatedLinesRemoval code generic region in a way such that if the lines are duplicated the encoder
// doesn't store it twice.
DuplicatedLinesRemoval bool ;

// DefaultPixelValue is the bit value initial for every pixel in the page.
DefaultPixelValue uint8 ;

// ResolutionX optional setting that defines the 'x' axis input image resolution - used for single page encoding.
ResolutionX int ;

// ResolutionY optional setting that defines the 'y' axis input image resolution - used for single page encoding.
ResolutionY int ;

// Threshold defines the threshold of the image correlation for
// non Generic compression.
// User only for JB2SymbolCorrelation and JB2SymbolRankHaus methods.
// Best results in range [0.7 - 0.98] - the less the better the compression would be
// but the more lossy.
// Default value: 0.95
Threshold float64 ;};

// IsDelimiter checks if a character represents a delimiter.
func IsDelimiter (c byte )bool {return c =='('||c ==')'||c =='<'||c =='>'||c =='['||c ==']'||c =='{'||c =='}'||c =='/'||c =='%';};func (_cbfc *PdfParser )parseXref ()(*PdfObjectDictionary ,error ){const _gged =20;_dede ,_ :=_cbfc ._eecd .Peek (_gged );
for _aebddf :=0;_aebddf < 2;_aebddf ++{if _cbfc ._cbbgc ==0{_cbfc ._cbbgc =_cbfc .GetFileOffset ();};if _effe .Match (_dede ){_gb .Log .Trace ("\u0078\u0072e\u0066\u0020\u0070\u006f\u0069\u006e\u0074\u0073\u0020\u0074\u006f\u0020\u0061\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u002e\u0020\u0050\u0072\u006f\u0062\u0061\u0062\u006c\u0079\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063\u0074");
_gb .Log .Debug ("\u0073t\u0061r\u0074\u0069\u006e\u0067\u0020w\u0069\u0074h\u0020\u0022\u0025\u0073\u0022",string (_dede ));return _cbfc .parseXrefStream (nil );};if _gbec .Match (_dede ){_gb .Log .Trace ("\u0053\u0074\u0061\u006ed\u0061\u0072\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073e\u0063t\u0069\u006f\u006e\u0020\u0074\u0061\u0062l\u0065\u0021");
return _cbfc .parseXrefTable ();};_abbe :=_cbfc .GetFileOffset ();if _cbfc ._cbbgc ==0{_cbfc ._cbbgc =_abbe ;};_cbfc .SetFileOffset (_abbe -_gged );defer _cbfc .SetFileOffset (_abbe );_gfb ,_ :=_cbfc ._eecd .Peek (_gged );_dede =append (_gfb ,_dede ...);
};_gb .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u0078\u0072\u0065f\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006fr\u0020\u0073\u0074\u0072\u0065\u0061\u006d.\u0020\u0052\u0065\u0070\u0061i\u0072\u0020\u0061\u0074\u0074e\u006d\u0070\u0074\u0065\u0064\u003a\u0020\u004c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0065\u0061\u0072\u006c\u0069\u0065\u0073\u0074\u0020x\u0072\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u0062\u006f\u0074to\u006d\u002e");
if _fdcbf :=_cbfc .repairSeekXrefMarker ();_fdcbf !=nil {_gb .Log .Debug ("\u0052e\u0070a\u0069\u0072\u0020\u0066\u0061i\u006c\u0065d\u0020\u002d\u0020\u0025\u0076",_fdcbf );return nil ,_fdcbf ;};return _cbfc .parseXrefTable ();};

// ToGoImage converts the JBIG2Image to the golang image.Image.
func (_gbad *JBIG2Image )ToGoImage ()(_ca .Image ,error ){const _cfff ="J\u0042I\u0047\u0032\u0049\u006d\u0061\u0067\u0065\u002eT\u006f\u0047\u006f\u0049ma\u0067\u0065";if _gbad .Data ==nil {return nil ,_geb .Error (_cfff ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");
};if _gbad .Width ==0||_gbad .Height ==0{return nil ,_geb .Error (_cfff ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");
};_aafd ,_cbgb :=_fe .NewImage (_gbad .Width ,_gbad .Height ,1,1,_gbad .Data ,nil ,nil );if _cbgb !=nil {return nil ,_cbgb ;};return _aafd ,nil ;};

// DecodeBytes decodes a slice of ASCII encoded bytes and returns the result.
func (_ggee *ASCIIHexEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_ecadb :=_ba .NewReader (encoded );var _dag []byte ;for {_aacd ,_dcadg :=_ecadb .ReadByte ();if _dcadg !=nil {return nil ,_dcadg ;};if _aacd =='>'{break ;};if IsWhiteSpace (_aacd ){continue ;
};if (_aacd >='a'&&_aacd <='f')||(_aacd >='A'&&_aacd <='F')||(_aacd >='0'&&_aacd <='9'){_dag =append (_dag ,_aacd );}else {_gb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0061\u0073\u0063\u0069\u0069 \u0068\u0065\u0078\u0020\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072 \u0028\u0025\u0063\u0029",_aacd );
return nil ,_be .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0061\u0073\u0063\u0069\u0069\u0020\u0068e\u0078 \u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u0020\u0028\u0025\u0063\u0029",_aacd );};};if len (_dag )%2==1{_dag =append (_dag ,'0');
};_gb .Log .Trace ("\u0049\u006e\u0062\u006f\u0075\u006e\u0064\u0020\u0025\u0073",_dag );_adcb :=make ([]byte ,_eb .DecodedLen (len (_dag )));_ ,_dddb :=_eb .Decode (_adcb ,_dag );if _dddb !=nil {return nil ,_dddb ;};return _adcb ,nil ;};

// PdfCryptNewDecrypt makes the document crypt handler based on the encryption dictionary
// and trailer dictionary. Returns an error on failure to process.
func PdfCryptNewDecrypt (parser *PdfParser ,ed ,trailer *PdfObjectDictionary )(*PdfCrypt ,error ){_eaag :=&PdfCrypt {_bda :false ,_bgg :make (map[PdfObject ]bool ),_cff :make (map[PdfObject ]bool ),_dcb :make (map[int ]struct{}),_gbaa :parser };_dfe ,_fgab :=ed .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectName );
if !_fgab {_gb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0043\u0072\u0079\u0070\u0074 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061r\u0079 \u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u0066\u0069\u0065\u006c\u0064\u0021");
return _eaag ,_f .New ("r\u0065\u0071\u0075\u0069\u0072\u0065d\u0020\u0063\u0072\u0079\u0070\u0074 \u0066\u0069\u0065\u006c\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u006d\u0069\u0073\u0073\u0069n\u0067");};if *_dfe !="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"{_gb .Log .Debug ("\u0045\u0052R\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020(%\u0073\u0029",*_dfe );
return _eaag ,_f .New ("\u0075n\u0073u\u0070\u0070\u006f\u0072\u0074e\u0064\u0020F\u0069\u006c\u0074\u0065\u0072");};_eaag ._dad .Filter =string (*_dfe );if _ddcf ,_cac :=ed .Get ("\u0053u\u0062\u0046\u0069\u006c\u0074\u0065r").(*PdfObjectString );_cac {_eaag ._dad .SubFilter =_ddcf .Str ();
_gb .Log .Debug ("\u0055s\u0069n\u0067\u0020\u0073\u0075\u0062f\u0069\u006ct\u0065\u0072\u0020\u0025\u0073",_ddcf );};if L ,_gff :=ed .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );_gff {if (*L %8)!=0{_gb .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0049\u006ev\u0061\u006c\u0069\u0064\u0020\u0065\u006ec\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006c\u0065\u006e\u0067\u0074\u0068");
return _eaag ,_f .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0065\u006e\u0063\u0072y\u0070t\u0069o\u006e\u0020\u006c\u0065\u006e\u0067\u0074h");};_eaag ._dad .Length =int (*L );}else {_eaag ._dad .Length =40;};_eaag ._dad .V =0;if _baaa ,_gfce :=ed .Get ("\u0056").(*PdfObjectInteger );
_gfce {V :=int (*_baaa );_eaag ._dad .V =V ;if V >=1&&V <=2{_eaag ._aag =_acc (_eaag ._dad .Length );}else if V >=4&&V <=5{if _gbg :=_eaag .loadCryptFilters (ed );_gbg !=nil {return _eaag ,_gbg ;};}else {_gb .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0061lg\u006f\u0020\u0056 \u003d \u0025\u0064",V );
return _eaag ,_f .New ("u\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d");};};if _agg :=_caa (&_eaag ._bgf ,ed );_agg !=nil {return _eaag ,_agg ;};_gfd :="";if _ceeg ,_ead :=trailer .Get ("\u0049\u0044").(*PdfObjectArray );
_ead &&_ceeg .Len ()>=1{_cdgb ,_dgb :=GetString (_ceeg .Get (0));if !_dgb {return _eaag ,_f .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0074r\u0061\u0069l\u0065\u0072\u0020\u0049\u0044");};_gfd =_cdgb .Str ();}else {_gb .Log .Debug ("\u0054\u0072ai\u006c\u0065\u0072 \u0049\u0044\u0020\u0061rra\u0079 m\u0069\u0073\u0073\u0069\u006e\u0067\u0020or\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0021");
};_eaag ._bce =_gfd ;return _eaag ,nil ;};var _bgdcd =_d .MustCompile ("\u005e\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");func (_dedg *PdfParser )parseXrefStream (_fccf *PdfObjectInteger )(*PdfObjectDictionary ,error ){if _fccf !=nil {_gb .Log .Trace ("\u0058\u0052\u0065f\u0053\u0074\u006d\u0020x\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0061\u0074\u0020\u0025\u0064",_fccf );
_dedg ._ffaf .Seek (int64 (*_fccf ),_ed .SeekStart );_dedg ._eecd =_fg .NewReader (_dedg ._ffaf );};_becgb :=_dedg .GetFileOffset ();_ffdf ,_caaa :=_dedg .ParseIndirectObject ();if _caaa !=nil {_gb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072\u0065\u0061d\u0020\u0078\u0072\u0065\u0066\u0020\u006fb\u006a\u0065\u0063\u0074");
return nil ,_f .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072e\u0061\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062j\u0065\u0063\u0074");};_gb .Log .Trace ("\u0058R\u0065f\u0053\u0074\u006d\u0020\u006fb\u006a\u0065c\u0074\u003a\u0020\u0025\u0073",_ffdf );
_cfga ,_ccb :=_ffdf .(*PdfObjectStream );if !_ccb {_gb .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0058R\u0065\u0066\u0053\u0074\u006d\u0020\u0070o\u0069\u006e\u0074\u0069\u006e\u0067 \u0074\u006f\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065a\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0021");
return nil ,_f .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0070\u006f\u0069\u006e\u0074i\u006e\u0067\u0020\u0074\u006f\u0020a\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006fb\u006a\u0065\u0063\u0074");};_bdge :=_cfga .PdfObjectDictionary ;
_eefda ,_ccb :=_cfga .PdfObjectDictionary .Get ("\u0053\u0069\u007a\u0065").(*PdfObjectInteger );if !_ccb {_gb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u004d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0073\u0069\u007a\u0065\u0020f\u0072\u006f\u006d\u0020\u0078\u0072\u0065f\u0020\u0073\u0074\u006d");
return nil ,_f .New ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0053\u0069\u007ae\u0020\u0066\u0072\u006f\u006d\u0020\u0078\u0072\u0065\u0066 \u0073\u0074\u006d");};if int64 (*_eefda )> 8388607{_gb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u0053\u0069\u007a\u0065\u0020\u0065x\u0063\u0065\u0065\u0064\u0065\u0064\u0020l\u0069\u006d\u0069\u0074\u002c\u0020\u006f\u0076\u0065\u0072\u00208\u0033\u0038\u0038\u0036\u0030\u0037\u0020\u0028\u0025\u0064\u0029",*_eefda );
return nil ,_f .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_gagg :=_cfga .PdfObjectDictionary .Get ("\u0057");_ffgf ,_ccb :=_gagg .(*PdfObjectArray );if !_ccb {return nil ,_f .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0057\u0020\u0069\u006e\u0020x\u0072\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d");
};_agbgd :=_ffgf .Len ();if _agbgd !=3{_gb .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020\u0028\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033\u0020\u002d\u0020\u0025\u0064\u0029",_agbgd );
return nil ,_f .New ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065f\u0020s\u0074\u006d\u0020\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033");};var _cbdafa []int64 ;for _cecb :=0;_cecb < 3;
_cecb ++{_gfdfg ,_edgg :=GetInt (_ffgf .Get (_cecb ));if !_edgg {return nil ,_f .New ("i\u006e\u0076\u0061\u006cid\u0020w\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0074\u0079\u0070\u0065");};_cbdafa =append (_cbdafa ,int64 (*_gfdfg ));};_ceegg ,_caaa :=DecodeStream (_cfga );
if _caaa !=nil {_gb .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020t\u006f \u0064e\u0063o\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u003a\u0020\u0025\u0076",_caaa );return nil ,_caaa ;};_babeg :=int (_cbdafa [0]);
_gced :=int (_cbdafa [0]+_cbdafa [1]);_fcad :=int (_cbdafa [0]+_cbdafa [1]+_cbdafa [2]);_ebce :=int (_cbdafa [0]+_cbdafa [1]+_cbdafa [2]);if _babeg < 0||_gced < 0||_fcad < 0{_gb .Log .Debug ("\u0045\u0072\u0072\u006fr\u0020\u0073\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u003c \u0030 \u0028\u0025\u0064\u002c\u0025\u0064\u002c%\u0064\u0029",_babeg ,_gced ,_fcad );
return nil ,_f .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};if _ebce ==0{_gb .Log .Debug ("\u004e\u006f\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063t\u0073\u0020\u0069\u006e\u0020\u0073t\u0072\u0065\u0061\u006d\u0020\u0028\u0064\u0065\u006c\u0074\u0061\u0062\u0020=\u003d\u0020\u0030\u0029");
return _bdge ,nil ;};_eeee :=len (_ceegg )/_ebce ;_ddfd :=0;_acac :=_cfga .PdfObjectDictionary .Get ("\u0049\u006e\u0064e\u0078");var _cafb []int ;if _acac !=nil {_gb .Log .Trace ("\u0049n\u0064\u0065\u0078\u003a\u0020\u0025b",_acac );_abae ,_bffbc :=_acac .(*PdfObjectArray );
if !_bffbc {_gb .Log .Debug ("\u0049\u006e\u0076\u0061\u006ci\u0064\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0029");
return nil ,_f .New ("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0049\u006e\u0064e\u0078\u0020\u006f\u0062je\u0063\u0074");};if _abae .Len ()%2!=0{_gb .Log .Debug ("\u0057\u0041\u0052\u004eI\u004e\u0047\u0020\u0046\u0061\u0069\u006c\u0075\u0072e\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020i\u006e\u0064\u0065\u0078\u0020n\u006f\u0074\u0020\u006d\u0075\u006c\u0074\u0069\u0070\u006c\u0065\u0020\u006f\u0066\u0020\u0032\u002e");
return nil ,_f .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_ddfd =0;_gfdeg ,_degd :=_abae .ToIntegerArray ();if _degd !=nil {_gb .Log .Debug ("\u0045\u0072\u0072\u006f\u0072 \u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0065\u0078 \u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0073\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0073\u003a\u0020\u0025\u0076",_degd );
return nil ,_degd ;};for _cbec :=0;_cbec < len (_gfdeg );_cbec +=2{_ffab :=_gfdeg [_cbec ];_fdcg :=_gfdeg [_cbec +1];for _edfb :=0;_edfb < _fdcg ;_edfb ++{_cafb =append (_cafb ,_ffab +_edfb );};_ddfd +=_fdcg ;};}else {for _fcdee :=0;_fcdee < int (*_eefda );
_fcdee ++{_cafb =append (_cafb ,_fcdee );};_ddfd =int (*_eefda );};if _eeee ==_ddfd +1{_gb .Log .Debug ("\u0049n\u0063\u006f\u006d\u0070ati\u0062\u0069\u006c\u0069t\u0079\u003a\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006di\u0073\u0073\u0069\u006e\u0067\u0020\u0063\u006f\u0076\u0065\u0072\u0061\u0067\u0065\u0020\u006f\u0066\u0020\u0031\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u002d\u0020\u0061\u0070\u0070en\u0064\u0069\u006eg\u0020\u006f\u006e\u0065\u0020-\u0020M\u0061\u0079\u0020\u006c\u0065\u0061\u0064\u0020\u0074o\u0020\u0070\u0072\u006f\u0062\u006c\u0065\u006d\u0073");
_aedcd :=_ddfd -1;for _ ,_fcec :=range _cafb {if _fcec > _aedcd {_aedcd =_fcec ;};};_cafb =append (_cafb ,_aedcd +1);_ddfd ++;};if _eeee !=len (_cafb ){_gb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020x\u0072\u0065\u0066 \u0073\u0074\u006d:\u0020\u006eu\u006d\u0020\u0065\u006e\u0074\u0072i\u0065s \u0021\u003d\u0020\u006c\u0065\u006e\u0028\u0069\u006e\u0064\u0069\u0063\u0065\u0073\u0029\u0020\u0028\u0025\u0064\u0020\u0021\u003d\u0020\u0025\u0064\u0029",_eeee ,len (_cafb ));
return nil ,_f .New ("\u0078\u0072ef\u0020\u0073\u0074m\u0020\u006e\u0075\u006d en\u0074ri\u0065\u0073\u0020\u0021\u003d\u0020\u006cen\u0028\u0069\u006e\u0064\u0069\u0063\u0065s\u0029");};_gb .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074s\u0020\u0063\u006f\u0075\u006e\u0074\u0020\u0025\u0064",_ddfd );
_gb .Log .Trace ("\u0049\u006e\u0064i\u0063\u0065\u0073\u003a\u0020\u0025\u0020\u0064",_cafb );_gdac :=func (_dbgd []byte )int64 {var _cfgaf int64 ;for _efeag :=0;_efeag < len (_dbgd );_efeag ++{_cfgaf +=int64 (_dbgd [_efeag ])*(1<<uint (8*(len (_dbgd )-_efeag -1)));
};return _cfgaf ;};_gb .Log .Trace ("\u0044e\u0063\u006f\u0064\u0065d\u0020\u0073\u0074\u0072\u0065a\u006d \u006ce\u006e\u0067\u0074\u0068\u003a\u0020\u0025d",len (_ceegg ));_eegac :=0;for _affdc :=0;_affdc < len (_ceegg );_affdc +=_ebce {_ffdd :=_ccaa (len (_ceegg ),_affdc ,_affdc +_babeg );
if _ffdd !=nil {_gb .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_ffdd );return nil ,_ffdd ;};_bcbcb :=_ceegg [_affdc :_affdc +_babeg ];_ffdd =_ccaa (len (_ceegg ),_affdc +_babeg ,_affdc +_gced );
if _ffdd !=nil {_gb .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_ffdd );return nil ,_ffdd ;};_dada :=_ceegg [_affdc +_babeg :_affdc +_gced ];_ffdd =_ccaa (len (_ceegg ),_affdc +_gced ,_affdc +_fcad );
if _ffdd !=nil {_gb .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_ffdd );return nil ,_ffdd ;};_egecd :=_ceegg [_affdc +_gced :_affdc +_fcad ];_eecb :=_gdac (_bcbcb );
_ebdeg :=_gdac (_dada );_fceb :=_gdac (_egecd );if _cbdafa [0]==0{_eecb =1;};if _eegac >=len (_cafb ){_gb .Log .Debug ("X\u0052\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u002d\u0020\u0054\u0072\u0079\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0061\u0063\u0063e\u0073s\u0020\u0069\u006e\u0064e\u0078\u0020o\u0075\u0074\u0020\u006f\u0066\u0020\u0062\u006f\u0075\u006e\u0064\u0073\u0020\u002d\u0020\u0062\u0072\u0065\u0061\u006b\u0069\u006e\u0067");
break ;};_feec :=_cafb [_eegac ];_eegac ++;_gb .Log .Trace ("%\u0064\u002e\u0020\u0070\u0031\u003a\u0020\u0025\u0020\u0078",_feec ,_bcbcb );_gb .Log .Trace ("%\u0064\u002e\u0020\u0070\u0032\u003a\u0020\u0025\u0020\u0078",_feec ,_dada );_gb .Log .Trace ("%\u0064\u002e\u0020\u0070\u0033\u003a\u0020\u0025\u0020\u0078",_feec ,_egecd );
_gb .Log .Trace ("\u0025d\u002e \u0078\u0072\u0065\u0066\u003a \u0025\u0064 \u0025\u0064\u0020\u0025\u0064",_feec ,_eecb ,_ebdeg ,_fceb );if _eecb ==0{_gb .Log .Trace ("-\u0020\u0046\u0072\u0065\u0065\u0020o\u0062\u006a\u0065\u0063\u0074\u0020-\u0020\u0063\u0061\u006e\u0020\u0070\u0072o\u0062\u0061\u0062\u006c\u0079\u0020\u0069\u0067\u006e\u006fr\u0065");
}else if _eecb ==1{_gb .Log .Trace ("\u002d\u0020I\u006e\u0020\u0075\u0073e\u0020\u002d \u0075\u006e\u0063\u006f\u006d\u0070\u0072\u0065s\u0073\u0065\u0064\u0020\u0076\u0069\u0061\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0062",_dada );if _ebdeg ==_becgb {_gb .Log .Debug ("\u0055\u0070d\u0061\u0074\u0069\u006e\u0067\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0058\u0052\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0064",_feec ,_cfga .ObjectNumber );
_feec =int (_cfga .ObjectNumber );};if _bdfc ,_dbgb :=_dedg ._aaaf .ObjectMap [_feec ];!_dbgb ||int (_fceb )> _bdfc .Generation {_fecfd :=XrefObject {ObjectNumber :_feec ,XType :XrefTypeTableEntry ,Offset :_ebdeg ,Generation :int (_fceb )};_dedg ._aaaf .ObjectMap [_feec ]=_fecfd ;
};}else if _eecb ==2{_gb .Log .Trace ("\u002d\u0020\u0049\u006e \u0075\u0073\u0065\u0020\u002d\u0020\u0063\u006f\u006d\u0070r\u0065s\u0073\u0065\u0064\u0020\u006f\u0062\u006ae\u0063\u0074");if _ ,_bgag :=_dedg ._aaaf .ObjectMap [_feec ];!_bgag {_daea :=XrefObject {ObjectNumber :_feec ,XType :XrefTypeObjectStream ,OsObjNumber :int (_ebdeg ),OsObjIndex :int (_fceb )};
_dedg ._aaaf .ObjectMap [_feec ]=_daea ;_gb .Log .Trace ("\u0065\u006e\u0074\u0072\u0079\u003a\u0020\u0025\u002b\u0076",_daea );};}else {_gb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052:\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0056\u0041L\u0049\u0044\u0020\u0054\u0059\u0050\u0045\u0020\u0058\u0072\u0065\u0066\u0053\u0074\u006d\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u003f\u002d\u002d\u002d\u002d\u002d\u002d-");
continue ;};};if _dedg ._dgaf ==nil {_ffaba :=XrefTypeObjectStream ;_dedg ._dgaf =&_ffaba ;};return _bdge ,nil ;};

// GetFilterName returns the name of the encoding filter.
func (_cedd *ASCIIHexEncoder )GetFilterName ()string {return StreamEncodingFilterNameASCIIHex };func (_ceab *PdfCrypt )isEncrypted (_deff PdfObject )bool {_ ,_eee :=_ceab ._cff [_deff ];if _eee {_gb .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0065\u006e\u0063\u0072y\u0070\u0074\u0065\u0064");
return true ;};_gb .Log .Trace ("\u004e\u006f\u0074\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");return false ;};

// EncodeBytes implements support for LZW encoding.  Currently not supporting predictors (raw compressed data only).
// Only supports the Early change = 1 algorithm (compress/lzw) as the other implementation
// does not have a write method.
// TODO: Consider refactoring compress/lzw to allow both.
func (_afgb *LZWEncoder )EncodeBytes (data []byte )([]byte ,error ){if _afgb .Predictor !=1{return nil ,_be .Errorf ("\u004c\u005aW \u0050\u0072\u0065d\u0069\u0063\u0074\u006fr =\u00201 \u006f\u006e\u006c\u0079\u0020\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0079e\u0074");
};if _afgb .EarlyChange ==1{return nil ,_be .Errorf ("\u004c\u005a\u0057\u0020\u0045\u0061\u0072\u006c\u0079\u0020\u0043\u0068\u0061n\u0067\u0065\u0020\u003d\u0020\u0030 \u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0079\u0065\u0074");
};var _dfeg _ba .Buffer ;_fgfb :=_gg .NewWriter (&_dfeg ,_gg .MSB ,8);_fgfb .Write (data );_fgfb .Close ();return _dfeg .Bytes (),nil ;};func (_ddcfb *PdfCrypt )securityHandler ()_bed .StdHandler {if _ddcfb ._bgf .R >=5{return _bed .NewHandlerR6 ();};return _bed .NewHandlerR4 (_ddcfb ._bce ,_ddcfb ._dad .Length );
};type offsetReader struct{_aec _ed .ReadSeeker ;_acbb int64 ;};

// DecodeBytes decodes a slice of LZW encoded bytes and returns the result.
func (_abcb *LZWEncoder )DecodeBytes (encoded []byte )([]byte ,error ){var _adec _ba .Buffer ;_ffdcg :=_ba .NewReader (encoded );var _afeb _ed .ReadCloser ;if _abcb .EarlyChange ==1{_afeb =_bac .NewReader (_ffdcg ,_bac .MSB ,8);}else {_afeb =_gg .NewReader (_ffdcg ,_gg .MSB ,8);
};defer _afeb .Close ();if _ ,_dcd :=_adec .ReadFrom (_afeb );_dcd !=nil {if _dcd !=_ed .ErrUnexpectedEOF ||_adec .Len ()==0{return nil ,_dcd ;};_gb .Log .Debug ("\u0057\u0041\u0052\u004e\u003a\u0020\u004c\u005a\u0057\u0020\u0064\u0065\u0063\u006f\u0064i\u006e\u0067\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076\u002e \u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062e \u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u002e",_dcd );
};return _adec .Bytes (),nil ;};

// ParseDict reads and parses a PDF dictionary object enclosed with '<<' and '>>'
func (_aefd *PdfParser )ParseDict ()(*PdfObjectDictionary ,error ){_gb .Log .Trace ("\u0052\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020D\u0069\u0063\u0074\u0021");_gacb :=MakeDict ();_gacb ._aced =_aefd ;_ebde ,_ :=_aefd ._eecd .ReadByte ();
if _ebde !='<'{return nil ,_f .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");};_ebde ,_ =_aefd ._eecd .ReadByte ();if _ebde !='<'{return nil ,_f .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");
};for {_aefd .skipSpaces ();_aefd .skipComments ();_fcbg ,_bdfaa :=_aefd ._eecd .Peek (2);if _bdfaa !=nil {return nil ,_bdfaa ;};_gb .Log .Trace ("D\u0069c\u0074\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_fcbg ),string (_fcbg ));
if (_fcbg [0]=='>')&&(_fcbg [1]=='>'){_gb .Log .Trace ("\u0045\u004f\u0046\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");_aefd ._eecd .ReadByte ();_aefd ._eecd .ReadByte ();break ;};_gb .Log .Trace ("\u0050a\u0072s\u0065\u0020\u0074\u0068\u0065\u0020\u006e\u0061\u006d\u0065\u0021");
_feeb ,_bdfaa :=_aefd .parseName ();_gb .Log .Trace ("\u004be\u0079\u003a\u0020\u0025\u0073",_feeb );if _bdfaa !=nil {_gb .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0052e\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006ea\u006d\u0065\u0020e\u0072r\u0020\u0025\u0073",_bdfaa );
return nil ,_bdfaa ;};if len (_feeb )> 4&&_feeb [len (_feeb )-4:]=="\u006e\u0075\u006c\u006c"{_ggdg :=_feeb [0:len (_feeb )-4];_gb .Log .Debug ("\u0054\u0061\u006b\u0069n\u0067\u0020\u0063\u0061\u0072\u0065\u0020\u006f\u0066\u0020n\u0075l\u006c\u0020\u0062\u0075\u0067\u0020\u0028%\u0073\u0029",_feeb );
_gb .Log .Debug ("\u004e\u0065\u0077\u0020ke\u0079\u0020\u0022\u0025\u0073\u0022\u0020\u003d\u0020\u006e\u0075\u006c\u006c",_ggdg );_aefd .skipSpaces ();_fbca ,_ :=_aefd ._eecd .Peek (1);if _fbca [0]=='/'{_gacb .Set (_ggdg ,MakeNull ());continue ;};};_aefd .skipSpaces ();
_gfdd ,_bdfaa :=_aefd .parseObject ();if _bdfaa !=nil {return nil ,_bdfaa ;};_gacb .Set (_feeb ,_gfdd );if _gb .Log .IsLogLevel (_gb .LogLevelTrace ){_gb .Log .Trace ("\u0064\u0069\u0063\u0074\u005b\u0025\u0073\u005d\u0020\u003d\u0020\u0025\u0073",_feeb ,_gfdd .String ());
};};_gb .Log .Trace ("\u0072\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020\u0044\u0069\u0063\u0074\u0021");return _gacb ,nil ;};const (JB2Generic JBIG2CompressionType =iota ;JB2SymbolCorrelation ;JB2SymbolRankHaus ;);func _ddeff (_ffcc PdfObject ,_fdfeg int ,_dgad map[PdfObject ]struct{})error {_gb .Log .Trace ("\u0054\u0072\u0061\u0076\u0065\u0072s\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0064\u0061\u0074\u0061 \u0028\u0064\u0065\u0070\u0074\u0068\u0020=\u0020\u0025\u0064\u0029",_fdfeg );
if _ ,_deeg :=_dgad [_ffcc ];_deeg {_gb .Log .Trace ("-\u0041\u006c\u0072\u0065ad\u0079 \u0074\u0072\u0061\u0076\u0065r\u0073\u0065\u0064\u002e\u002e\u002e");return nil ;};_dgad [_ffcc ]=struct{}{};switch _aadca :=_ffcc .(type ){case *PdfIndirectObject :_abcda :=_aadca ;
_gb .Log .Trace ("\u0069\u006f\u003a\u0020\u0025\u0073",_abcda );_gb .Log .Trace ("\u002d\u0020\u0025\u0073",_abcda .PdfObject );return _ddeff (_abcda .PdfObject ,_fdfeg +1,_dgad );case *PdfObjectStream :_ccfb :=_aadca ;return _ddeff (_ccfb .PdfObjectDictionary ,_fdfeg +1,_dgad );
case *PdfObjectDictionary :_dbda :=_aadca ;_gb .Log .Trace ("\u002d\u0020\u0064\u0069\u0063\u0074\u003a\u0020\u0025\u0073",_dbda );for _ ,_fdcf :=range _dbda .Keys (){_bdaf :=_dbda .Get (_fdcf );if _cabfg ,_adcdf :=_bdaf .(*PdfObjectReference );_adcdf {_eccg :=_cabfg .Resolve ();
_dbda .Set (_fdcf ,_eccg );_aadfc :=_ddeff (_eccg ,_fdfeg +1,_dgad );if _aadfc !=nil {return _aadfc ;};}else {_gceaa :=_ddeff (_bdaf ,_fdfeg +1,_dgad );if _gceaa !=nil {return _gceaa ;};};};return nil ;case *PdfObjectArray :_cdfge :=_aadca ;_gb .Log .Trace ("-\u0020\u0061\u0072\u0072\u0061\u0079\u003a\u0020\u0025\u0073",_cdfge );
for _ggcf ,_ebae :=range _cdfge .Elements (){if _bebd ,_acabf :=_ebae .(*PdfObjectReference );_acabf {_dadfc :=_bebd .Resolve ();_cdfge .Set (_ggcf ,_dadfc );_bdgc :=_ddeff (_dadfc ,_fdfeg +1,_dgad );if _bdgc !=nil {return _bdgc ;};}else {_bgfce :=_ddeff (_ebae ,_fdfeg +1,_dgad );
if _bgfce !=nil {return _bgfce ;};};};return nil ;case *PdfObjectReference :_gb .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020T\u0072\u0061\u0063\u0069\u006e\u0067\u0020\u0061\u0020r\u0065\u0066\u0065r\u0065n\u0063\u0065\u0021");return _f .New ("\u0065r\u0072\u006f\u0072\u0020t\u0072\u0061\u0063\u0069\u006eg\u0020a\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");
};return nil ;};

// DecodeBytes decodes a slice of JBIG2 encoded bytes and returns the results.
func (_bccf *JBIG2Encoder )DecodeBytes (encoded []byte )([]byte ,error ){return _gge .DecodeBytes (encoded ,_gdga .Parameters {},_bccf .Globals );};func (_dggf *PdfParser )parsePdfVersion ()(int ,int ,error ){var _gbage int64 =20;_aace :=make ([]byte ,_gbage );
_dggf ._ffaf .Seek (0,_ed .SeekStart );_dggf ._ffaf .Read (_aace );var _ggdd error ;var _eeed ,_fged int ;if _baef :=_fbgg .FindStringSubmatch (string (_aace ));len (_baef )< 3{if _eeed ,_fged ,_ggdd =_dggf .seekPdfVersionTopDown ();_ggdd !=nil {_gb .Log .Debug ("F\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065\u0063\u006f\u0076\u0065\u0072\u0079\u0020\u002d\u0020\u0075n\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0066\u0069nd\u0020\u0076\u0065r\u0073i\u006f\u006e");
return 0,0,_ggdd ;};_dggf ._ffaf ,_ggdd =_eecf (_dggf ._ffaf ,_dggf .GetFileOffset ()-8);if _ggdd !=nil {return 0,0,_ggdd ;};}else {if _eeed ,_ggdd =_fc .Atoi (_baef [1]);_ggdd !=nil {return 0,0,_ggdd ;};if _fged ,_ggdd =_fc .Atoi (_baef [2]);_ggdd !=nil {return 0,0,_ggdd ;
};_dggf .SetFileOffset (0);};_dggf ._eecd =_fg .NewReader (_dggf ._ffaf );_gb .Log .Debug ("\u0050\u0064\u0066\u0020\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020%\u0064\u002e\u0025\u0064",_eeed ,_fged );return _eeed ,_fged ,nil ;};

// EncodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_ceg *RawEncoder )EncodeBytes (data []byte )([]byte ,error ){return data ,nil };

// GetStringVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetStringVal (obj PdfObject )(_bgddc string ,_gcab bool ){_fbbfa ,_gcab :=TraceToDirectObject (obj ).(*PdfObjectString );if _gcab {return _fbbfa .Str (),true ;};return ;};

// PdfObjectName represents the primitive PDF name object.
type PdfObjectName string ;

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_fgg *CCITTFaxEncoder )MakeDecodeParams ()PdfObject {_bbead :=MakeDict ();_bbead .Set ("\u004b",MakeInteger (int64 (_fgg .K )));_bbead .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_fgg .Columns )));if _fgg .BlackIs1 {_bbead .Set ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031",MakeBool (_fgg .BlackIs1 ));
};if _fgg .EncodedByteAlign {_bbead .Set ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e",MakeBool (_fgg .EncodedByteAlign ));};if _fgg .EndOfLine &&_fgg .K >=0{_bbead .Set ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee",MakeBool (_fgg .EndOfLine ));
};if _fgg .Rows !=0&&!_fgg .EndOfBlock {_bbead .Set ("\u0052\u006f\u0077\u0073",MakeInteger (int64 (_fgg .Rows )));};if !_fgg .EndOfBlock {_bbead .Set ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b",MakeBool (_fgg .EndOfBlock ));};if _fgg .DamagedRowsBeforeError !=0{_bbead .Set ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072",MakeInteger (int64 (_fgg .DamagedRowsBeforeError )));
};return _bbead ;};

// GetRevision returns PdfParser for the specific version of the Pdf document.
func (_gdfda *PdfParser )GetRevision (revisionNumber int )(*PdfParser ,error ){_afcf :=_gdfda ._gbabc ;if _afcf ==revisionNumber {return _gdfda ,nil ;};if _afcf < revisionNumber {return nil ,_f .New ("\u0075\u006e\u0064\u0065\u0066\u0069\u006e\u0065\u0064\u0020\u0072\u0065\u0076\u0069\u0073i\u006fn\u004e\u0075\u006d\u0062\u0065\u0072\u0020\u0076\u0065\u0072\u0073\u0069\u006f\u006e");
};if _gdfda ._fcgd [revisionNumber ]!=nil {return _gdfda ._fcgd [revisionNumber ],nil ;};_bgdd :=_gdfda ;for ;_afcf > revisionNumber ;_afcf --{_fecc ,_afac :=_bgdd .GetPreviousRevisionParser ();if _afac !=nil {return nil ,_afac ;};_gdfda ._fcgd [_afcf -1]=_fecc ;
_gdfda ._eadaa [_bgdd ]=_fecc ;_bgdd =_fecc ;};return _bgdd ,nil ;};

// WriteString outputs the object as it is to be written to file.
func (_abdbac *PdfIndirectObject )WriteString ()string {var _efdcd _cc .Builder ;_efdcd .WriteString (_fc .FormatInt (_abdbac .ObjectNumber ,10));_efdcd .WriteString ("\u0020\u0030\u0020\u0052");return _efdcd .String ();};

// WriteString outputs the object as it is to be written to file.
func (_gfgf *PdfObjectStreams )WriteString ()string {var _edbcg _cc .Builder ;_edbcg .WriteString (_fc .FormatInt (_gfgf .ObjectNumber ,10));_edbcg .WriteString ("\u0020\u0030\u0020\u0052");return _edbcg .String ();};

// MakeName creates a PdfObjectName from a string.
func MakeName (s string )*PdfObjectName {_cbecb :=PdfObjectName (s );return &_cbecb };const _deee =6;

// ResolveReferencesDeep recursively traverses through object `o`, looking up and replacing
// references with indirect objects.
// Optionally a map of already deep-resolved objects can be provided via `traversed`. The `traversed` map
// is updated while traversing the objects to avoid traversing same objects multiple times.
func ResolveReferencesDeep (o PdfObject ,traversed map[PdfObject ]struct{})error {if traversed ==nil {traversed =map[PdfObject ]struct{}{};};return _ddeff (o ,0,traversed );};func _bedbe (_ffbee PdfObject ,_dbcfba int )PdfObject {if _dbcfba > _aab {_gb .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_aab );
return MakeNull ();};switch _ccfg :=_ffbee .(type ){case *PdfIndirectObject :_ffbee =_bedbe ((*_ccfg ).PdfObject ,_dbcfba +1);case *PdfObjectArray :for _eadea ,_abcg :=range (*_ccfg )._edgfg {(*_ccfg )._edgfg [_eadea ]=_bedbe (_abcg ,_dbcfba +1);};case *PdfObjectDictionary :for _ebdg ,_fcddc :=range (*_ccfg )._egfe {(*_ccfg )._egfe [_ebdg ]=_bedbe (_fcddc ,_dbcfba +1);
};_gd .Slice ((*_ccfg )._cgcf ,func (_eeegf ,_cfeed int )bool {return (*_ccfg )._cgcf [_eeegf ]< (*_ccfg )._cgcf [_cfeed ]});};return _ffbee ;};

// Decrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_egbd *PdfCrypt )Decrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _egbd .isDecrypted (obj ){return nil ;};switch _cbda :=obj .(type ){case *PdfIndirectObject :_egbd ._bgg [_cbda ]=true ;_gb .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_cbda .ObjectNumber ,_cbda .GenerationNumber );
_cade :=_cbda .ObjectNumber ;_gdb :=_cbda .GenerationNumber ;_dfaf :=_egbd .Decrypt (_cbda .PdfObject ,_cade ,_gdb );if _dfaf !=nil {return _dfaf ;};return nil ;case *PdfObjectStream :_egbd ._bgg [_cbda ]=true ;_dgbe :=_cbda .PdfObjectDictionary ;if _egbd ._bgf .R !=5{if _begc ,_dfad :=_dgbe .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );
_dfad &&*_begc =="\u0058\u0052\u0065\u0066"{return nil ;};};_gea :=_cbda .ObjectNumber ;_ffd :=_cbda .GenerationNumber ;_gb .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_gea ,_ffd );
_ddf :=_afe ;if _egbd ._dad .V >=4{_ddf =_egbd ._fca ;_gb .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_egbd ._fca );if _dbd ,_cgb :=_dgbe .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );
_cgb {if _ecf ,_ebbd :=GetName (_dbd .Get (0));_ebbd {if *_ecf =="\u0043\u0072\u0079p\u0074"{_ddf ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _gfceb ,_bbe :=_dgbe .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );
_bbe {if _ecce ,_gfe :=_gfceb .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_gfe {if _ ,_dggg :=_egbd ._aag [string (*_ecce )];_dggg {_gb .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_ecce );
_ddf =string (*_ecce );};};};};};};_gb .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_ddf );if _ddf =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_dgf :=_egbd .Decrypt (_dgbe ,_gea ,_ffd );
if _dgf !=nil {return _dgf ;};_ffbc ,_dgf :=_egbd .makeKey (_ddf ,uint32 (_gea ),uint32 (_ffd ),_egbd ._ada );if _dgf !=nil {return _dgf ;};_cbda .Stream ,_dgf =_egbd .decryptBytes (_cbda .Stream ,_ddf ,_ffbc );if _dgf !=nil {return _dgf ;};_dgbe .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_cbda .Stream ))));
return nil ;case *PdfObjectString :_gb .Log .Trace ("\u0044e\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_egf :=_afe ;if _egbd ._dad .V >=4{_gb .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_egbd ._fbd );
if _egbd ._fbd =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_egf =_egbd ._fbd ;};_cag ,_dcf :=_egbd .makeKey (_egf ,uint32 (parentObjNum ),uint32 (parentGenNum ),_egbd ._ada );if _dcf !=nil {return _dcf ;};_cece :=_cbda .Str ();_ee :=make ([]byte ,len (_cece ));
for _cfg :=0;_cfg < len (_cece );_cfg ++{_ee [_cfg ]=_cece [_cfg ];};if len (_ee )> 0{_gb .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_ee ,_ee );_ee ,_dcf =_egbd .decryptBytes (_ee ,_egf ,_cag );
if _dcf !=nil {return _dcf ;};};_cbda ._fddd =string (_ee );return nil ;case *PdfObjectArray :for _ ,_ebbf :=range _cbda .Elements (){_bbf :=_egbd .Decrypt (_ebbf ,parentObjNum ,parentGenNum );if _bbf !=nil {return _bbf ;};};return nil ;case *PdfObjectDictionary :_bgd :=false ;
if _cge :=_cbda .Get ("\u0054\u0079\u0070\u0065");_cge !=nil {_bfg ,_dbb :=_cge .(*PdfObjectName );if _dbb &&*_bfg =="\u0053\u0069\u0067"{_bgd =true ;};};for _ ,_eab :=range _cbda .Keys (){_eff :=_cbda .Get (_eab );if _bgd &&string (_eab )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;
};if string (_eab )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_eab )!="\u0050\u0072\u0065\u0076"&&string (_eab )!="\u004c\u0061\u0073\u0074"{_ecef :=_egbd .Decrypt (_eff ,parentObjNum ,parentGenNum );if _ecef !=nil {return _ecef ;};};};return nil ;
};return nil ;};

// JPXEncoder implements JPX encoder/decoder (dummy, for now)
// FIXME: implement
type JPXEncoder struct{};

// EncodeBytes encodes data into ASCII85 encoded format.
func (_gfgc *ASCII85Encoder )EncodeBytes (data []byte )([]byte ,error ){var _dgdb _ba .Buffer ;for _abg :=0;_abg < len (data );_abg +=4{_fgca :=data [_abg ];_cga :=1;_fbgf :=byte (0);if _abg +1< len (data ){_fbgf =data [_abg +1];_cga ++;};_eccec :=byte (0);
if _abg +2< len (data ){_eccec =data [_abg +2];_cga ++;};_gfcc :=byte (0);if _abg +3< len (data ){_gfcc =data [_abg +3];_cga ++;};_bca :=(uint32 (_fgca )<<24)|(uint32 (_fbgf )<<16)|(uint32 (_eccec )<<8)|uint32 (_gfcc );if _bca ==0{_dgdb .WriteByte ('z');
}else {_afda :=_gfgc .base256Tobase85 (_bca );for _ ,_bbea :=range _afda [:_cga +1]{_dgdb .WriteByte (_bbea +'!');};};};_dgdb .WriteString ("\u007e\u003e");return _dgdb .Bytes (),nil ;};

// String returns a string describing `ind`.
func (_gbca *PdfIndirectObject )String ()string {return _be .Sprintf ("\u0049\u004f\u0062\u006a\u0065\u0063\u0074\u003a\u0025\u0064",(*_gbca ).ObjectNumber );};func _faf (_dbbd *PdfObjectStream ,_edae *PdfObjectDictionary )(*FlateEncoder ,error ){_ebfa :=NewFlateEncoder ();
_cde :=_dbbd .PdfObjectDictionary ;if _cde ==nil {return _ebfa ,nil ;};_ebfa ._fbee =_bcaf (_cde );if _edae ==nil {_cadg :=TraceToDirectObject (_cde .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));switch _afge :=_cadg .(type ){case *PdfObjectArray :if _afge .Len ()!=1{_gb .Log .Debug ("\u0045\u0072\u0072\u006f\u0072:\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020a\u0072\u0072\u0061\u0079\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0021\u003d\u0020\u0031\u0020\u0028\u0025\u0064\u0029",_afge .Len ());
return nil ,_f .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};if _dbcg ,_bdd :=GetDict (_afge .Get (0));_bdd {_edae =_dbcg ;};case *PdfObjectDictionary :_edae =_afge ;case *PdfObjectNull ,nil :default:_gb .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020n\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079 \u0028%\u0054\u0029",_cadg );
return nil ,_be .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _edae ==nil {return _ebfa ,nil ;};_gb .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_edae .String ());
_efc :=_edae .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");if _efc ==nil {_gb .Log .Debug ("E\u0072\u0072o\u0072\u003a\u0020\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067 \u0066\u0072\u006f\u006d\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073 \u002d\u0020\u0043\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020\u0077\u0069t\u0068\u0020\u0064\u0065\u0066\u0061\u0075\u006c\u0074\u0020\u00281\u0029");
}else {_dcfg ,_dbg :=_efc .(*PdfObjectInteger );if !_dbg {_gb .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_efc );
return nil ,_be .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_ebfa .Predictor =int (*_dcfg );};_efc =_edae .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");
if _efc !=nil {_bcd ,_gac :=_efc .(*PdfObjectInteger );if !_gac {_gb .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");
return nil ,_be .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_ebfa .BitsPerComponent =int (*_bcd );};if _ebfa .Predictor > 1{_ebfa .Columns =1;_efc =_edae .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");
if _efc !=nil {_fedb ,_fgcg :=_efc .(*PdfObjectInteger );if !_fgcg {return nil ,_be .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_ebfa .Columns =int (*_fedb );
};_ebfa .Colors =1;_efc =_edae .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _efc !=nil {_gbeg ,_cbgdf :=_efc .(*PdfObjectInteger );if !_cbgdf {return nil ,_be .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");
};_ebfa .Colors =int (*_gbeg );};};return _ebfa ,nil ;};

// GetNameVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetNameVal (obj PdfObject )(_cdeec string ,_becc bool ){_ggfd ,_becc :=TraceToDirectObject (obj ).(*PdfObjectName );if _becc {return string (*_ggfd ),true ;};return ;};

// EncodeStream encodes the stream data using the encoded specified by the stream's dictionary.
func EncodeStream (streamObj *PdfObjectStream )error {_gb .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_eecbb ,_cgda :=NewEncoderFromStream (streamObj );if _cgda !=nil {_gb .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_cgda );
return _cgda ;};if _dccc ,_eccde :=_eecbb .(*LZWEncoder );_eccde {_dccc .EarlyChange =0;streamObj .PdfObjectDictionary .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (0));};_gb .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076\u000a",_eecbb );
_egcec ,_cgda :=_eecbb .EncodeBytes (streamObj .Stream );if _cgda !=nil {_gb .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_cgda );return _cgda ;
};streamObj .Stream =_egcec ;streamObj .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_egcec ))));return nil ;};func (_dcbfe *PdfParser )parseNumber ()(PdfObject ,error ){return ParseNumber (_dcbfe ._eecd )};
const _aab =10;

// PdfObjectNull represents the primitive PDF null object.
type PdfObjectNull struct{};

// HeaderPosition gets the file header position.
func (_bcf ParserMetadata )HeaderPosition ()int {return _bcf ._aadd };

// EncodeJBIG2Image encodes 'img' into jbig2 encoded bytes stream, using default encoder settings.
func (_edeb *JBIG2Encoder )EncodeJBIG2Image (img *JBIG2Image )([]byte ,error ){const _bdbe ="c\u006f\u0072\u0065\u002eEn\u0063o\u0064\u0065\u004a\u0042\u0049G\u0032\u0049\u006d\u0061\u0067\u0065";if _dggge :=_edeb .AddPageImage (img ,&_edeb .DefaultPageSettings );
_dggge !=nil {return nil ,_geb .Wrap (_dggge ,_bdbe ,"");};return _edeb .Encode ();};func (_cefgc *PdfParser )loadXrefs ()(*PdfObjectDictionary ,error ){_cefgc ._aaaf .ObjectMap =make (map[int ]XrefObject );_cefgc ._aedd =make (objectStreams );_dbfb ,_dgfa :=_cefgc ._ffaf .Seek (0,_ed .SeekEnd );
if _dgfa !=nil {return nil ,_dgfa ;};_gb .Log .Trace ("\u0066s\u0069\u007a\u0065\u003a\u0020\u0025d",_dbfb );_cefgc ._gfab =_dbfb ;_dgfa =_cefgc .seekToEOFMarker (_dbfb );if _dgfa !=nil {_gb .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0073\u0065\u0065\u006b\u0020\u0074\u006f\u0020\u0065\u006f\u0066\u0020\u006d\u0061\u0072\u006b\u0065\u0072: \u0025\u0076",_dgfa );
return nil ,_dgfa ;};_cfee ,_dgfa :=_cefgc ._ffaf .Seek (0,_ed .SeekCurrent );if _dgfa !=nil {return nil ,_dgfa ;};var _egcg int64 =64;_bbda :=_cfee -_egcg ;if _bbda < 0{_bbda =0;};_ ,_dgfa =_cefgc ._ffaf .Seek (_bbda ,_ed .SeekStart );if _dgfa !=nil {return nil ,_dgfa ;
};_adgg :=make ([]byte ,_egcg );_ ,_dgfa =_cefgc ._ffaf .Read (_adgg );if _dgfa !=nil {_gb .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u003a\u0020\u0025\u0076",_dgfa );
return nil ,_dgfa ;};_babef :=_bdab .FindStringSubmatch (string (_adgg ));if len (_babef )< 2{_gb .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020n\u006f\u0074\u0020f\u006fu\u006e\u0064\u0021");
return nil ,_f .New ("\u0073\u0074\u0061\u0072tx\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};if len (_babef )> 2{_gb .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u004du\u006c\u0074\u0069\u0070\u006c\u0065\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029\u0021",_adgg );
return nil ,_f .New ("m\u0075\u006c\u0074\u0069\u0070\u006ce\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065f\u0020\u0065\u006et\u0072i\u0065\u0073\u003f");};_gefg ,_ :=_fc .ParseInt (_babef [1],10,64);_gb .Log .Trace ("\u0073t\u0061r\u0074\u0078\u0072\u0065\u0066\u0020\u0061\u0074\u0020\u0025\u0064",_gefg );
if _gefg > _dbfb {_gb .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u006f\u0066f\u0073e\u0074 \u006fu\u0074\u0073\u0069\u0064\u0065\u0020\u006f\u0066\u0020\u0066\u0069\u006c\u0065");_gb .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0072e\u0070\u0061\u0069\u0072");
_gefg ,_dgfa =_cefgc .repairLocateXref ();if _dgfa !=nil {_gb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0052\u0065\u0070\u0061\u0069\u0072\u0020\u0061\u0074\u0074\u0065\u006d\u0070t\u0020\u0066\u0061\u0069\u006c\u0065\u0064 \u0028\u0025\u0073\u0029");
return nil ,_dgfa ;};};_cefgc ._ffaf .Seek (_gefg ,_ed .SeekStart );_cefgc ._eecd =_fg .NewReader (_cefgc ._ffaf );_cggd ,_dgfa :=_cefgc .parseXref ();if _dgfa !=nil {return nil ,_dgfa ;};_ddba :=_cggd .Get ("\u0058R\u0065\u0066\u0053\u0074\u006d");if _ddba !=nil {_acgd ,_abdfe :=_ddba .(*PdfObjectInteger );
if !_abdfe {return nil ,_f .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0021=\u0020\u0069\u006e\u0074");};_ ,_dgfa =_cefgc .parseXrefStream (_acgd );if _dgfa !=nil {return nil ,_dgfa ;};};var _cfgf []int64 ;_ffe :=func (_ddae int64 ,_caae []int64 )bool {for _ ,_cbfbb :=range _caae {if _cbfbb ==_ddae {return true ;
};};return false ;};_ddba =_cggd .Get ("\u0050\u0072\u0065\u0076");for _ddba !=nil {_fbda ,_dcfb :=_ddba .(*PdfObjectInteger );if !_dcfb {_gb .Log .Debug ("\u0049\u006ev\u0061\u006c\u0069\u0064\u0020P\u0072\u0065\u0076\u0020\u0072e\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u003a\u0020\u004e\u006f\u0074\u0020\u0061\u0020\u002a\u0050\u0064\u0066\u004f\u0062\u006a\u0065\u0063\u0074\u0049\u006e\u0074\u0065\u0067\u0065\u0072\u0020\u0028\u0025\u0054\u0029",_ddba );
return _cggd ,nil ;};_dcfa :=*_fbda ;_gb .Log .Trace ("\u0041\u006eot\u0068\u0065\u0072 \u0050\u0072\u0065\u0076 xr\u0065f \u0074\u0061\u0062\u006c\u0065\u0020\u006fbj\u0065\u0063\u0074\u0020\u0061\u0074\u0020%\u0064",_dcfa );_cefgc ._ffaf .Seek (int64 (_dcfa ),_ed .SeekStart );
_cefgc ._eecd =_fg .NewReader (_cefgc ._ffaf );_geefb ,_cbacg :=_cefgc .parseXref ();if _cbacg !=nil {_gb .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0045\u0072\u0072\u006f\u0072\u0020-\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u0061\u0064\u0069n\u0067\u0020\u0061\u006e\u006f\u0074\u0068\u0065\u0072\u0020\u0028\u0050re\u0076\u0029\u0020\u0074\u0072\u0061\u0069\u006c\u0065\u0072");
_gb .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0063\u006f\u006e\u0074\u0069n\u0075\u0065\u0020\u0062\u0079\u0020\u0069\u0067\u006e\u006f\u0072\u0069n\u0067\u0020\u0069\u0074");break ;};_cefgc ._eggde =append (_cefgc ._eggde ,int64 (_dcfa ));
_ddba =_geefb .Get ("\u0050\u0072\u0065\u0076");if _ddba !=nil {_ggged :=*(_ddba .(*PdfObjectInteger ));if _ffe (int64 (_ggged ),_cfgf ){_gb .Log .Debug ("\u0050\u0072ev\u0065\u006e\u0074i\u006e\u0067\u0020\u0063irc\u0075la\u0072\u0020\u0078\u0072\u0065\u0066\u0020re\u0066\u0065\u0072\u0065\u006e\u0063\u0069n\u0067");
break ;};_cfgf =append (_cfgf ,int64 (_ggged ));};};return _cggd ,nil ;};func _ebfag (_fcega int )int {_cgc :=_fcega >>(_bcfae -1);return (_fcega ^_cgc )-_cgc };

// NewEncoderFromStream creates a StreamEncoder based on the stream's dictionary.
func NewEncoderFromStream (streamObj *PdfObjectStream )(StreamEncoder ,error ){_ffbgd :=TraceToDirectObject (streamObj .PdfObjectDictionary .Get ("\u0046\u0069\u006c\u0074\u0065\u0072"));if _ffbgd ==nil {return NewRawEncoder (),nil ;};if _ ,_gbbb :=_ffbgd .(*PdfObjectNull );
_gbbb {return NewRawEncoder (),nil ;};_ededd ,_ceca :=_ffbgd .(*PdfObjectName );if !_ceca {_ffce ,_bggdg :=_ffbgd .(*PdfObjectArray );if !_bggdg {return nil ,_be .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006f\u0072 \u0041\u0072\u0072\u0061\u0079\u0020\u006fb\u006a\u0065\u0063\u0074");
};if _ffce .Len ()==0{return NewRawEncoder (),nil ;};if _ffce .Len ()!=1{_ccbg ,_abbeg :=_face (streamObj );if _abbeg !=nil {_gb .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0063\u0072\u0065\u0061\u0074\u0069\u006e\u0067\u0020\u006d\u0075\u006c\u0074i\u0020\u0065\u006e\u0063\u006f\u0064\u0065r\u003a\u0020\u0025\u0076",_abbeg );
return nil ,_abbeg ;};_gb .Log .Trace ("\u004d\u0075\u006c\u0074\u0069\u0020\u0065\u006e\u0063:\u0020\u0025\u0073\u000a",_ccbg );return _ccbg ,nil ;};_ffbgd =_ffce .Get (0);_ededd ,_bggdg =_ffbgd .(*PdfObjectName );if !_bggdg {return nil ,_be .Errorf ("\u0066\u0069l\u0074\u0065\u0072\u0020a\u0072\u0072a\u0079\u0020\u006d\u0065\u006d\u0062\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006fb\u006a\u0065\u0063\u0074");
};};if _afbc ,_fccda :=_cdaaa .Load (_ededd .String ());_fccda {return _afbc .(StreamEncoder ),nil ;};switch *_ededd {case StreamEncodingFilterNameFlate :return _faf (streamObj ,nil );case StreamEncodingFilterNameLZW :return _dfga (streamObj ,nil );case StreamEncodingFilterNameDCT :return _dddc (streamObj ,nil );
case StreamEncodingFilterNameRunLength :return _ede (streamObj ,nil );case StreamEncodingFilterNameASCIIHex :return NewASCIIHexEncoder (),nil ;case StreamEncodingFilterNameASCII85 ,"\u0041\u0038\u0035":return NewASCII85Encoder (),nil ;case StreamEncodingFilterNameCCITTFax :return _cecgb (streamObj ,nil );
case StreamEncodingFilterNameJBIG2 :return _cefg (streamObj ,nil );case StreamEncodingFilterNameJPX :return NewJPXEncoder (),nil ;};_gb .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064\u0069\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006fd\u0021");
return nil ,_be .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064i\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006f\u0064\u0020\u0028\u0025\u0073\u0029",*_ededd );};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_cdca *DCTEncoder )MakeDecodeParams ()PdfObject {return nil };

// Remove removes an element specified by key.
func (_agacg *PdfObjectDictionary )Remove (key PdfObjectName ){_eecfg :=-1;for _bgae ,_ceadf :=range _agacg ._cgcf {if _ceadf ==key {_eecfg =_bgae ;break ;};};if _eecfg >=0{_agacg ._cgcf =append (_agacg ._cgcf [:_eecfg ],_agacg ._cgcf [_eecfg +1:]...);
delete (_agacg ._egfe ,key );};};

// CCITTFaxEncoder implements Group3 and Group4 facsimile (fax) encoder/decoder.
type CCITTFaxEncoder struct{K int ;EndOfLine bool ;EncodedByteAlign bool ;Columns int ;Rows int ;EndOfBlock bool ;BlackIs1 bool ;DamagedRowsBeforeError int ;};

// Encode encodes previously prepare jbig2 document and stores it as the byte slice.
func (_ddfaae *JBIG2Encoder )Encode ()(_aefga []byte ,_egcb error ){const _edbc ="J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0045\u006eco\u0064\u0065";if _ddfaae ._afbe ==nil {return nil ,_geb .Errorf (_edbc ,"\u0064\u006f\u0063u\u006d\u0065\u006e\u0074 \u0069\u006e\u0070\u0075\u0074\u0020\u0064a\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006e\u0065\u0064");
};_ddfaae ._afbe .FullHeaders =_ddfaae .DefaultPageSettings .FileMode ;_aefga ,_egcb =_ddfaae ._afbe .Encode ();if _egcb !=nil {return nil ,_geb .Wrap (_egcb ,_edbc ,"");};return _aefga ,nil ;};var _effe =_d .MustCompile ("\u0028\u005c\u0064\u002b)\\\u0073\u002b\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u006f\u0062\u006a");


// MakeStreamDict make a new instance of an encoding dictionary for a stream object.
func (_fdgc *ASCII85Encoder )MakeStreamDict ()*PdfObjectDictionary {_cebe :=MakeDict ();_cebe .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_fdgc .GetFilterName ()));return _cebe ;};

// PdfObjectInteger represents the primitive PDF integer numerical object.
type PdfObjectInteger int64 ;

// MakeArrayFromIntegers creates an PdfObjectArray from a slice of ints, where each array element is
// an PdfObjectInteger.
func MakeArrayFromIntegers (vals []int )*PdfObjectArray {_bcde :=MakeArray ();for _ ,_cdcbg :=range vals {_bcde .Append (MakeInteger (int64 (_cdcbg )));};return _bcde ;};

// HasInvalidSeparationAfterXRef implements core.ParserMetadata interface.
func (_fda ParserMetadata )HasInvalidSeparationAfterXRef ()bool {return _fda ._egbf };func (_fef *PdfCrypt )checkAccessRights (_fag []byte )(bool ,_bed .Permissions ,error ){_gfa :=_fef .securityHandler ();_fbdf ,_fbc ,_abd :=_gfa .Authenticate (&_fef ._bgf ,_fag );
if _abd !=nil {return false ,0,_abd ;}else if _fbc ==0||len (_fbdf )==0{return false ,0,nil ;};return true ,_fbc ,nil ;};

// DecodeStream decodes a multi-encoded stream by passing it through the
// DecodeStream method of the underlying encoders.
func (_acgf *MultiEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _acgf .DecodeBytes (streamObj .Stream );};

// NewMultiEncoder returns a new instance of MultiEncoder.
func NewMultiEncoder ()*MultiEncoder {_agf :=MultiEncoder {};_agf ._fbgeg =[]StreamEncoder {};return &_agf ;};func _caa (_gbag *_bed .StdEncryptDict ,_aaf *PdfObjectDictionary )error {R ,_bcbe :=_aaf .Get ("\u0052").(*PdfObjectInteger );if !_bcbe {return _f .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0052");
};if *R < 2||*R > 6{return _be .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0052 \u0028\u0025\u0064\u0029",*R );};_gbag .R =int (*R );O ,_bcbe :=_aaf .GetString ("\u004f");if !_bcbe {return _f .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u004f");
};if _gbag .R ==5||_gbag .R ==6{if len (O )< 48{return _be .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u004f\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (O ));};}else if len (O )!=32{return _be .Errorf ("L\u0065n\u0067\u0074\u0068\u0028\u004f\u0029\u0020\u0021=\u0020\u0033\u0032\u0020(%\u0064\u0029",len (O ));
};_gbag .O =[]byte (O );U ,_bcbe :=_aaf .GetString ("\u0055");if !_bcbe {return _f .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0055");};if _gbag .R ==5||_gbag .R ==6{if len (U )< 48{return _be .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u0055\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (U ));
};}else if len (U )!=32{_gb .Log .Debug ("\u0057\u0061r\u006e\u0069\u006e\u0067\u003a\u0020\u004c\u0065\u006e\u0067\u0074\u0068\u0028\u0055\u0029\u0020\u0021\u003d\u0020\u0033\u0032\u0020(%\u0064\u0029",len (U ));};_gbag .U =[]byte (U );if _gbag .R >=5{OE ,_ae :=_aaf .GetString ("\u004f\u0045");
if !_ae {return _f .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u004f\u0045");}else if len (OE )!=32{return _be .Errorf ("L\u0065\u006e\u0067\u0074h(\u004fE\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (OE ));
};_gbag .OE =[]byte (OE );UE ,_ae :=_aaf .GetString ("\u0055\u0045");if !_ae {return _f .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u0055\u0045");
}else if len (UE )!=32{return _be .Errorf ("L\u0065\u006e\u0067\u0074h(\u0055E\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (UE ));};_gbag .UE =[]byte (UE );};P ,_bcbe :=_aaf .Get ("\u0050").(*PdfObjectInteger );if !_bcbe {return _f .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074 \u0064\u0069\u0063t\u0069\u006f\u006e\u0061r\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0070\u0065\u0072\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0061\u0074\u0074\u0072");
};_gbag .P =_bed .Permissions (*P );if _gbag .R ==6{Perms ,_badc :=_aaf .GetString ("\u0050\u0065\u0072m\u0073");if !_badc {return _f .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0050\u0065\u0072\u006d\u0073");
}else if len (Perms )!=16{return _be .Errorf ("\u004ce\u006e\u0067\u0074\u0068\u0028\u0050\u0065\u0072\u006d\u0073\u0029 \u0021\u003d\u0020\u0031\u0036\u0020\u0028\u0025\u0064\u0029",len (Perms ));};_gbag .Perms =[]byte (Perms );};if _cab ,_defa :=_aaf .Get ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061").(*PdfObjectBool );
_defa {_gbag .EncryptMetadata =bool (*_cab );}else {_gbag .EncryptMetadata =true ;};return nil ;};

// XrefObject defines a cross reference entry which is a map between object number (with generation number) and the
// location of the actual object, either as a file offset (xref table entry), or as a location within an xref
// stream object (xref object stream).
type XrefObject struct{XType xrefType ;ObjectNumber int ;Generation int ;

// For normal xrefs (defined by OFFSET)
Offset int64 ;

// For xrefs to object streams.
OsObjNumber int ;OsObjIndex int ;};

// UpdateParams updates the parameter values of the encoder.
func (_cdeg *LZWEncoder )UpdateParams (params *PdfObjectDictionary ){_deba ,_ccac :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _ccac ==nil {_cdeg .Predictor =int (_deba );};_gagf ,_ccac :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));
if _ccac ==nil {_cdeg .BitsPerComponent =int (_gagf );};_gbc ,_ccac :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _ccac ==nil {_cdeg .Columns =int (_gbc );};_affb ,_ccac :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));
if _ccac ==nil {_cdeg .Colors =int (_affb );};_fee ,_ccac :=GetNumberAsInt64 (params .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065"));if _ccac ==nil {_cdeg .EarlyChange =int (_fee );};};func (_gbcfc *PdfParser )parseXrefTable ()(*PdfObjectDictionary ,error ){var _dcgc *PdfObjectDictionary ;
_gfaa ,_bffc :=_gbcfc .readTextLine ();if _bffc !=nil {return nil ,_bffc ;};if _gbcfc ._defe &&_cc .Count (_cc .TrimPrefix (_gfaa ,"\u0078\u0072\u0065\u0066"),"\u0020")> 0{_gbcfc ._fbgfd ._egbf =true ;};_gb .Log .Trace ("\u0078\u0072\u0065\u0066 f\u0069\u0072\u0073\u0074\u0020\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_gfaa );
_deda :=-1;_cccc :=0;_fecf :=false ;_defed :="";for {_gbcfc .skipSpaces ();_ ,_bdga :=_gbcfc ._eecd .Peek (1);if _bdga !=nil {return nil ,_bdga ;};_gfaa ,_bdga =_gbcfc .readTextLine ();if _bdga !=nil {return nil ,_bdga ;};_gegd :=_cega .FindStringSubmatch (_gfaa );
if len (_gegd )==0{_fdag :=len (_defed )> 0;_defed +=_gfaa +"\u000a";if _fdag {_gegd =_cega .FindStringSubmatch (_defed );};};if len (_gegd )==3{if _gbcfc ._defe &&!_gbcfc ._fbgfd ._gbd {var (_feac bool ;_faeb int ;);for _ ,_dfec :=range _gfaa {if _g .IsDigit (_dfec ){if _feac {break ;
};continue ;};if !_feac {_feac =true ;};_faeb ++;};if _faeb > 1{_gbcfc ._fbgfd ._gbd =true ;};};_fdbg ,_ :=_fc .Atoi (_gegd [1]);_dbbf ,_ :=_fc .Atoi (_gegd [2]);_deda =_fdbg ;_cccc =_dbbf ;_fecf =true ;_defed ="";_gb .Log .Trace ("\u0078r\u0065\u0066 \u0073\u0075\u0062s\u0065\u0063\u0074\u0069\u006f\u006e\u003a \u0066\u0069\u0072\u0073\u0074\u0020o\u0062\u006a\u0065\u0063\u0074\u003a\u0020\u0025\u0064\u0020\u006fb\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_deda ,_cccc );
continue ;};_cbfgc :=_acbc .FindStringSubmatch (_gfaa );if len (_cbfgc )==4{if !_fecf {_gb .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0058r\u0065\u0066\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u006fr\u006da\u0074\u0021\u000a");return nil ,_f .New ("\u0078\u0072\u0065\u0066 i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072\u006d\u0061\u0074");
};_adef ,_ :=_fc .ParseInt (_cbfgc [1],10,64);_ecab ,_ :=_fc .Atoi (_cbfgc [2]);_eeeb :=_cbfgc [3];_defed ="";if _cc .ToLower (_eeeb )=="\u006e"&&_adef > 1{_abfcb ,_fgdc :=_gbcfc ._aaaf .ObjectMap [_deda ];if !_fgdc ||_ecab > _abfcb .Generation {_cgee :=XrefObject {ObjectNumber :_deda ,XType :XrefTypeTableEntry ,Offset :_adef ,Generation :_ecab };
_gbcfc ._aaaf .ObjectMap [_deda ]=_cgee ;};};_deda ++;continue ;};if (len (_gfaa )> 6)&&(_gfaa [:7]=="\u0074r\u0061\u0069\u006c\u0065\u0072"){_gb .Log .Trace ("\u0046o\u0075n\u0064\u0020\u0074\u0072\u0061i\u006c\u0065r\u0020\u002d\u0020\u0025\u0073",_gfaa );
if len (_gfaa )> 9{_fgcd :=_gbcfc .GetFileOffset ();_gbcfc .SetFileOffset (_fgcd -int64 (len (_gfaa ))+7);};_gbcfc .skipSpaces ();_gbcfc .skipComments ();_gb .Log .Trace ("R\u0065\u0061\u0064\u0069ng\u0020t\u0072\u0061\u0069\u006c\u0065r\u0020\u0064\u0069\u0063\u0074\u0021");
_gb .Log .Trace ("\u0070\u0065\u0065\u006b\u003a\u0020\u0022\u0025\u0073\u0022",_gfaa );_dcgc ,_bdga =_gbcfc .ParseDict ();_gb .Log .Trace ("\u0045O\u0046\u0020\u0072\u0065a\u0064\u0069\u006e\u0067\u0020t\u0072a\u0069l\u0065\u0072\u0020\u0064\u0069\u0063\u0074!");
if _bdga !=nil {_gb .Log .Debug ("\u0045\u0072\u0072o\u0072\u0020\u0070\u0061r\u0073\u0069\u006e\u0067\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u0064\u0069\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_bdga );return nil ,_bdga ;};break ;};if _gfaa =="\u0025\u0025\u0045O\u0046"{_gb .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006e\u0064 \u006f\u0066\u0020\u0066\u0069\u006c\u0065 -\u0020\u0074\u0072\u0061i\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066ou\u006e\u0064 \u002d\u0020\u0065\u0072\u0072\u006f\u0072\u0021");
return nil ,_f .New ("\u0065\u006e\u0064 \u006f\u0066\u0020\u0066i\u006c\u0065\u0020\u002d\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};_gb .Log .Trace ("\u0078\u0072\u0065\u0066\u0020\u006d\u006f\u0072\u0065 \u003a\u0020\u0025\u0073",_gfaa );
};_gb .Log .Trace ("\u0045\u004f\u0046 p\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0021");if _gbcfc ._dgaf ==nil {_bbfc :=XrefTypeTableEntry ;_gbcfc ._dgaf =&_bbfc ;};return _dcgc ,nil ;};

// RegisterCustomStreamEncoder register a custom encoder handler for certain filter.
func RegisterCustomStreamEncoder (filterName string ,customStreamEncoder StreamEncoder ){_cdaaa .Store (filterName ,customStreamEncoder );};func (_dafa *PdfParser )parseNull ()(PdfObjectNull ,error ){_ ,_dfdc :=_dafa ._eecd .Discard (4);return PdfObjectNull {},_dfdc ;
};

// GetInt returns the *PdfObjectBool object that is represented by a PdfObject either directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetInt (obj PdfObject )(_ceagd *PdfObjectInteger ,_decgg bool ){_ceagd ,_decgg =TraceToDirectObject (obj ).(*PdfObjectInteger );return _ceagd ,_decgg ;};

// DecodeGlobals decodes 'encoded' byte stream and returns their Globally defined segments ('Globals').
func (_abdg *JBIG2Encoder )DecodeGlobals (encoded []byte )(_gge .Globals ,error ){return _gge .DecodeGlobals (encoded );};

// HasInvalidSubsectionHeader implements core.ParserMetadata interface.
func (_aee ParserMetadata )HasInvalidSubsectionHeader ()bool {return _aee ._gbd };func _abcf ()string {return _gb .Version };

// GetFilterName returns the name of the encoding filter.
func (_ecg *DCTEncoder )GetFilterName ()string {return StreamEncodingFilterNameDCT };

// IsEncrypted checks if the document is encrypted. A bool flag is returned indicating the result.
// First time when called, will check if the Encrypt dictionary is accessible through the trailer dictionary.
// If encrypted, prepares a crypt datastructure which can be used to authenticate and decrypt the document.
// On failure, an error is returned.
func (_egfd *PdfParser )IsEncrypted ()(bool ,error ){if _egfd ._cddg !=nil {return true ,nil ;}else if _egfd ._fae ==nil {return false ,nil ;};_gb .Log .Trace ("\u0043\u0068\u0065c\u006b\u0069\u006e\u0067 \u0065\u006e\u0063\u0072\u0079\u0070\u0074i\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0021");
_bfbdb :=_egfd ._fae .Get ("\u0045n\u0063\u0072\u0079\u0070\u0074");if _bfbdb ==nil {return false ,nil ;};_gb .Log .Trace ("\u0049\u0073\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u0021");var (_fcdea *PdfObjectDictionary ;);switch _ffafd :=_bfbdb .(type ){case *PdfObjectDictionary :_fcdea =_ffafd ;
case *PdfObjectReference :_gb .Log .Trace ("\u0030\u003a\u0020\u004c\u006f\u006f\u006b\u0020\u0075\u0070\u0020\u0072e\u0066\u0020\u0025\u0071",_ffafd );_dcbc ,_ebbc :=_egfd .LookupByReference (*_ffafd );_gb .Log .Trace ("\u0031\u003a\u0020%\u0071",_dcbc );
if _ebbc !=nil {return false ,_ebbc ;};_bedd ,_ecefb :=_dcbc .(*PdfIndirectObject );if !_ecefb {_gb .Log .Debug ("E\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006eo\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072ec\u0074\u0020\u006fb\u006ae\u0063\u0074");
return false ,_f .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");};_dba ,_ecefb :=_bedd .PdfObject .(*PdfObjectDictionary );_egfd ._acfb =_bedd ;_gb .Log .Trace ("\u0032\u003a\u0020%\u0071",_dba );if !_ecefb {return false ,_f .New ("\u0074\u0072a\u0069\u006c\u0065\u0072 \u0045\u006ec\u0072\u0079\u0070\u0074\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u006e\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");
};_fcdea =_dba ;case *PdfObjectNull :_gb .Log .Debug ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074 \u0069\u0073\u0020a\u0020\u006e\u0075l\u006c\u0020o\u0062\u006a\u0065\u0063\u0074\u002e \u0046il\u0065\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u002e");
return false ,nil ;default:return false ,_be .Errorf ("u\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0079\u0070\u0065: \u0025\u0054",_ffafd );};_fbdc ,_geee :=PdfCryptNewDecrypt (_egfd ,_fcdea ,_egfd ._fae );if _geee !=nil {return false ,_geee ;
};for _ ,_afca :=range []string {"\u0045n\u0063\u0072\u0079\u0070\u0074"}{_cbgg :=_egfd ._fae .Get (PdfObjectName (_afca ));if _cbgg ==nil {continue ;};switch _bgfb :=_cbgg .(type ){case *PdfObjectReference :_fbdc ._dcb [int (_bgfb .ObjectNumber )]=struct{}{};
case *PdfIndirectObject :_fbdc ._bgg [_bgfb ]=true ;_fbdc ._dcb [int (_bgfb .ObjectNumber )]=struct{}{};};};_egfd ._cddg =_fbdc ;_gb .Log .Trace ("\u0043\u0072\u0079\u0070\u0074\u0065\u0072\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0025\u0062",_fbdc );
return true ,nil ;};

// GetRevisionNumber returns the current version of the Pdf document.
func (_cbde *PdfParser )GetRevisionNumber ()int {return _cbde ._gbabc };

// WriteString outputs the object as it is to be written to file.
func (_cdff *PdfObjectInteger )WriteString ()string {return _fc .FormatInt (int64 (*_cdff ),10)};func (_aeab *limitedReadSeeker )getError (_gece int64 )error {switch {case _gece < 0:return _be .Errorf ("\u0075\u006e\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064 \u006e\u0065\u0067\u0061\u0074\u0069\u0076e\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u003a\u0020\u0025\u0064",_gece );
case _gece > _aeab ._fcacg :return _be .Errorf ("u\u006e\u0065\u0078\u0070ec\u0074e\u0064\u0020\u006f\u0066\u0066s\u0065\u0074\u003a\u0020\u0025\u0064",_gece );};return nil ;};

// AddEncoder adds the passed in encoder to the underlying encoder slice.
func (_bgbf *MultiEncoder )AddEncoder (encoder StreamEncoder ){_bgbf ._fbgeg =append (_bgbf ._fbgeg ,encoder );};func (_cce *PdfCrypt )generateParams (_ecfd ,_eda []byte )error {_cdae :=_cce .securityHandler ();_fdd ,_cbga :=_cdae .GenerateParams (&_cce ._bgf ,_eda ,_ecfd );
if _cbga !=nil {return _cbga ;};_cce ._ada =_fdd ;return nil ;};func (_dffag *PdfObjectDictionary )setWithLock (_abgb PdfObjectName ,_babd PdfObject ,_bfbff bool ){if _bfbff {_dffag ._gfae .Lock ();defer _dffag ._gfae .Unlock ();};_ ,_gebb :=_dffag ._egfe [_abgb ];
if !_gebb {_dffag ._cgcf =append (_dffag ._cgcf ,_abgb );};_dffag ._egfe [_abgb ]=_babd ;};

// LZWEncoder provides LZW encoding/decoding functionality.
type LZWEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Colors int ;

// LZW algorithm setting.
EarlyChange int ;};func _cecgb (_eefb *PdfObjectStream ,_fdgb *PdfObjectDictionary )(*CCITTFaxEncoder ,error ){_fbgd :=NewCCITTFaxEncoder ();_dbee :=_eefb .PdfObjectDictionary ;if _dbee ==nil {return _fbgd ,nil ;};if _fdgb ==nil {_cgaa :=TraceToDirectObject (_dbee .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));
if _cgaa !=nil {switch _degg :=_cgaa .(type ){case *PdfObjectDictionary :_fdgb =_degg ;case *PdfObjectArray :if _degg .Len ()==1{if _bdbf ,_dccd :=GetDict (_degg .Get (0));_dccd {_fdgb =_bdbf ;};};default:_gb .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_cgaa );
return nil ,_f .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _fdgb ==nil {_gb .Log .Error ("\u0044\u0065c\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064 %\u0023\u0076",_cgaa );
return nil ,_f .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _dcaf ,_aebb :=GetNumberAsInt64 (_fdgb .Get ("\u004b"));_aebb ==nil {_fbgd .K =int (_dcaf );};if _gcac ,_abfa :=GetNumberAsInt64 (_fdgb .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));
_abfa ==nil {_fbgd .Columns =int (_gcac );}else {_fbgd .Columns =1728;};if _dbba ,_bcdgc :=GetNumberAsInt64 (_fdgb .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_bcdgc ==nil {_fbgd .BlackIs1 =_dbba > 0;}else {if _ege ,_edgf :=GetBoolVal (_fdgb .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));
_edgf {_fbgd .BlackIs1 =_ege ;}else {if _aeag ,_beff :=GetArray (_fdgb .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));_beff {_bfbc ,_dcee :=_aeag .ToIntegerArray ();if _dcee ==nil {_fbgd .BlackIs1 =_bfbc [0]==1&&_bfbc [1]==0;};};};};if _facf ,_fbge :=GetNumberAsInt64 (_fdgb .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));
_fbge ==nil {_fbgd .EncodedByteAlign =_facf > 0;}else {if _gfag ,_dbdee :=GetBoolVal (_fdgb .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_dbdee {_fbgd .EncodedByteAlign =_gfag ;};};if _gdab ,_edgb :=GetNumberAsInt64 (_fdgb .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));
_edgb ==nil {_fbgd .EndOfLine =_gdab > 0;}else {if _agcb ,_aefg :=GetBoolVal (_fdgb .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_aefg {_fbgd .EndOfLine =_agcb ;};};if _fefg ,_dfgb :=GetNumberAsInt64 (_fdgb .Get ("\u0052\u006f\u0077\u0073"));
_dfgb ==nil {_fbgd .Rows =int (_fefg );};_fbgd .EndOfBlock =true ;if _abec ,_gfdeb :=GetNumberAsInt64 (_fdgb .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_gfdeb ==nil {_fbgd .EndOfBlock =_abec > 0;}else {if _bfa ,_cgaaf :=GetBoolVal (_fdgb .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));
_cgaaf {_fbgd .EndOfBlock =_bfa ;};};if _acd ,_cdf :=GetNumberAsInt64 (_fdgb .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));_cdf !=nil {_fbgd .DamagedRowsBeforeError =int (_acd );
};_gb .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_fdgb .String ());return _fbgd ,nil ;};

// Validate validates the page settings for the JBIG2 encoder.
func (_beffa JBIG2EncoderSettings )Validate ()error {const _fccd ="\u0076a\u006ci\u0064\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065\u0072";if _beffa .Threshold < 0||_beffa .Threshold > 1.0{return _geb .Errorf (_fccd ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074\u0068\u0072\u0065\u0073\u0068\u006f\u006c\u0064\u0020\u0076a\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0076\u0027 \u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0069\u006e\u0020\u0072\u0061n\u0067\u0065\u0020\u005b\u0030\u002e0\u002c\u0020\u0031.\u0030\u005d",_beffa .Threshold );
};if _beffa .ResolutionX < 0{return _geb .Errorf (_fccd ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0078\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_beffa .ResolutionX );
};if _beffa .ResolutionY < 0{return _geb .Errorf (_fccd ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0079\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_beffa .ResolutionY );
};if _beffa .DefaultPixelValue !=0&&_beffa .DefaultPixelValue !=1{return _geb .Errorf (_fccd ,"de\u0066\u0061u\u006c\u0074\u0020\u0070\u0069\u0078\u0065\u006c\u0020v\u0061\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0066o\u0072 \u0074\u0068\u0065\u0020\u0062\u0069\u0074\u003a \u007b0\u002c\u0031}",_beffa .DefaultPixelValue );
};if _beffa .Compression !=JB2Generic {return _geb .Errorf (_fccd ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065d\u0020\u0063\u006fm\u0070\u0072\u0065\u0073s\u0069\u006f\u006e\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
};return nil ;};

// PdfIndirectObject represents the primitive PDF indirect object.
type PdfIndirectObject struct{PdfObjectReference ;PdfObject ;};type encryptDict struct{Filter string ;V int ;SubFilter string ;Length int ;StmF string ;StrF string ;EFF string ;CF map[string ]_egg .FilterDict ;};

// MakeHexString creates an PdfObjectString from a string intended for output as a hexadecimal string.
func MakeHexString (s string )*PdfObjectString {_dbed :=PdfObjectString {_fddd :s ,_gcadg :true };return &_dbed ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_bcfc *MultiEncoder )MakeDecodeParams ()PdfObject {if len (_bcfc ._fbgeg )==0{return nil ;};if len (_bcfc ._fbgeg )==1{return _bcfc ._fbgeg [0].MakeDecodeParams ();};_eade :=MakeArray ();_ded :=true ;for _ ,_befc :=range _bcfc ._fbgeg {_eec :=_befc .MakeDecodeParams ();
if _eec ==nil {_eade .Append (MakeNull ());}else {_ded =false ;_eade .Append (_eec );};};if _ded {return nil ;};return _eade ;};

// GetAsFloat64Slice returns the array as []float64 slice.
// Returns an error if not entirely numeric (only PdfObjectIntegers, PdfObjectFloats).
func (_eeec *PdfObjectArray )GetAsFloat64Slice ()([]float64 ,error ){var _dcdc []float64 ;for _ ,_edcef :=range _eeec .Elements (){_eccdb ,_fcda :=GetNumberAsFloat (TraceToDirectObject (_edcef ));if _fcda !=nil {return nil ,_be .Errorf ("\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006e\u0075m\u0062\u0065\u0072");
};_dcdc =append (_dcdc ,_eccdb );};return _dcdc ,nil ;};

// GetName returns the *PdfObjectName represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetName (obj PdfObject )(_cagg *PdfObjectName ,_daaag bool ){_cagg ,_daaag =TraceToDirectObject (obj ).(*PdfObjectName );return _cagg ,_daaag ;};

// IsPrintable checks if a character is printable.
// Regular characters that are outside the range EXCLAMATION MARK(21h)
// (!) to TILDE (7Eh) (~) should be written using the hexadecimal notation.
func IsPrintable (c byte )bool {return 0x21<=c &&c <=0x7E};

// WriteString outputs the object as it is to be written to file.
func (_facfb *PdfObjectString )WriteString ()string {var _efbc _ba .Buffer ;if _facfb ._gcadg {_edfce :=_eb .EncodeToString (_facfb .Bytes ());_efbc .WriteString ("\u003c");_efbc .WriteString (_edfce );_efbc .WriteString ("\u003e");return _efbc .String ();
};_fgabc :=map[byte ]string {'\n':"\u005c\u006e",'\r':"\u005c\u0072",'\t':"\u005c\u0074",'\b':"\u005c\u0062",'\f':"\u005c\u0066",'(':"\u005c\u0028",')':"\u005c\u0029",'\\':"\u005c\u005c"};_efbc .WriteString ("\u0028");for _ecfc :=0;_ecfc < len (_facfb ._fddd );
_ecfc ++{_gaecg :=_facfb ._fddd [_ecfc ];if _fabf ,_dfbb :=_fgabc [_gaecg ];_dfbb {_efbc .WriteString (_fabf );}else {_efbc .WriteByte (_gaecg );};};_efbc .WriteString ("\u0029");return _efbc .String ();};

// NewFlateEncoder makes a new flate encoder with default parameters, predictor 1 and bits per component 8.
func NewFlateEncoder ()*FlateEncoder {_effa :=&FlateEncoder {};_effa .Predictor =1;_effa .BitsPerComponent =8;_effa .Colors =1;_effa .Columns =1;return _effa ;};

// MakeInteger creates a PdfObjectInteger from an int64.
func MakeInteger (val int64 )*PdfObjectInteger {_ebdde :=PdfObjectInteger (val );return &_ebdde };

// HasInvalidHexRunes implements core.ParserMetadata interface.
func (_fddf ParserMetadata )HasInvalidHexRunes ()bool {return _fddf ._fdb };func (_dga *PdfParser )lookupByNumberWrapper (_feg int ,_ebbb bool )(PdfObject ,bool ,error ){_dbc ,_ff ,_cdg :=_dga .lookupByNumber (_feg ,_ebbb );if _cdg !=nil {return nil ,_ff ,_cdg ;
};if !_ff &&_dga ._cddg !=nil &&_dga ._cddg ._bda &&!_dga ._cddg .isDecrypted (_dbc ){_egc :=_dga ._cddg .Decrypt (_dbc ,0,0);if _egc !=nil {return nil ,_ff ,_egc ;};};return _dbc ,_ff ,nil ;};

// MakeFloat creates an PdfObjectFloat from a float64.
func MakeFloat (val float64 )*PdfObjectFloat {_cabf :=PdfObjectFloat (val );return &_cabf };

// MakeIndirectObject creates an PdfIndirectObject with a specified direct object PdfObject.
func MakeIndirectObject (obj PdfObject )*PdfIndirectObject {_dfb :=&PdfIndirectObject {};_dfb .PdfObject =obj ;return _dfb ;};

// SetImage sets the image base for given flate encoder.
func (_dfeb *FlateEncoder )SetImage (img *_fe .ImageBase ){_dfeb ._fbee =img };

// GetBool returns the *PdfObjectBool object that is represented by a PdfObject directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetBool (obj PdfObject )(_adefe *PdfObjectBool ,_faed bool ){_adefe ,_faed =TraceToDirectObject (obj ).(*PdfObjectBool );return _adefe ,_faed ;};

// String returns a string describing `ref`.
func (_deaa *PdfObjectReference )String ()string {return _be .Sprintf ("\u0052\u0065\u0066\u0028\u0025\u0064\u0020\u0025\u0064\u0029",_deaa .ObjectNumber ,_deaa .GenerationNumber );};

// GetXrefOffset returns the offset of the xref table.
func (_cgca *PdfParser )GetXrefOffset ()int64 {return _cgca ._cbbgc };

// GetFilterArray returns the names of the underlying encoding filters in an array that
// can be used as /Filter entry.
func (_bbb *MultiEncoder )GetFilterArray ()*PdfObjectArray {_cace :=make ([]PdfObject ,len (_bbb ._fbgeg ));for _cgbf ,_cbb :=range _bbb ._fbgeg {_cace [_cgbf ]=MakeName (_cbb .GetFilterName ());};return MakeArray (_cace ...);};var _daa =[]PdfObjectName {"\u0056","\u0052","\u004f","\u0055","\u0050"};
var _fgae =_d .MustCompile ("\u005e\u005b\\\u002b\u002d\u002e\u005d*\u0028\u005b0\u002d\u0039\u002e\u005d\u002b\u0029\u005b\u0065E\u005d\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");var _bcbd =_d .MustCompile ("\u005b\\\u0072\u005c\u006e\u005d\u005c\u0073\u002a\u0028\u0078\u0072\u0065f\u0029\u005c\u0073\u002a\u005b\u005c\u0072\u005c\u006e\u005d");


// DecodeStream implements ASCII hex decoding.
func (_bcfa *ASCIIHexEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _bcfa .DecodeBytes (streamObj .Stream );};

// Len returns the number of elements in the array.
func (_fafg *PdfObjectArray )Len ()int {if _fafg ==nil {return 0;};return len (_fafg ._edgfg );};

// Len returns the number of elements in the streams.
func (_gccag *PdfObjectStreams )Len ()int {if _gccag ==nil {return 0;};return len (_gccag ._ffcdf );};

// WriteString outputs the object as it is to be written to file.
func (_agdc *PdfObjectArray )WriteString ()string {var _fegda _cc .Builder ;_fegda .WriteString ("\u005b");for _eacag ,_efcee :=range _agdc .Elements (){_fegda .WriteString (_efcee .WriteString ());if _eacag < (_agdc .Len ()-1){_fegda .WriteString ("\u0020");
};};_fegda .WriteString ("\u005d");return _fegda .String ();};

// GetCrypter returns the PdfCrypt instance which has information about the PDFs encryption.
func (_bfd *PdfParser )GetCrypter ()*PdfCrypt {return _bfd ._cddg };var _gffb =_f .New ("\u0045\u004f\u0046\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");

// Read implementation of Read interface.
func (_gegff *limitedReadSeeker )Read (p []byte )(_afaf int ,_bgea error ){_dbbe ,_bgea :=_gegff ._gbcf .Seek (0,_ed .SeekCurrent );if _bgea !=nil {return 0,_bgea ;};_aagb :=_gegff ._fcacg -_dbbe ;if _aagb ==0{return 0,_ed .EOF ;};if _fgb :=int64 (len (p ));
_fgb < _aagb {_aagb =_fgb ;};_cdec :=make ([]byte ,_aagb );_afaf ,_bgea =_gegff ._gbcf .Read (_cdec );copy (p ,_cdec );return _afaf ,_bgea ;};func _eecf (_dgae _ed .ReadSeeker ,_babe int64 )(*offsetReader ,error ){_bddd :=&offsetReader {_aec :_dgae ,_acbb :_babe };
_ ,_aecg :=_bddd .Seek (0,_ed .SeekStart );return _bddd ,_aecg ;};

// HasDataAfterEOF checks if there is some data after EOF marker.
func (_fff ParserMetadata )HasDataAfterEOF ()bool {return _fff ._cdgg };

// ReadBytesAt reads byte content at specific offset and length within the PDF.
func (_aafg *PdfParser )ReadBytesAt (offset ,len int64 )([]byte ,error ){_eeeg :=_aafg .GetFileOffset ();_ ,_ebeb :=_aafg ._ffaf .Seek (offset ,_ed .SeekStart );if _ebeb !=nil {return nil ,_ebeb ;};_dgfb :=make ([]byte ,len );_ ,_ebeb =_ed .ReadAtLeast (_aafg ._ffaf ,_dgfb ,int (len ));
if _ebeb !=nil {return nil ,_ebeb ;};_aafg .SetFileOffset (_eeeg );return _dgfb ,nil ;};

// IsFloatDigit checks if a character can be a part of a float number string.
func IsFloatDigit (c byte )bool {return ('0'<=c &&c <='9')||c =='.'};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_gbdb *RawEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};

// Resolve resolves a PdfObject to direct object, looking up and resolving references as needed (unlike TraceToDirect).
func (_ggea *PdfParser )Resolve (obj PdfObject )(PdfObject ,error ){_ab ,_eba :=obj .(*PdfObjectReference );if !_eba {return obj ,nil ;};_bace :=_ggea .GetFileOffset ();defer func (){_ggea .SetFileOffset (_bace )}();_gec ,_ffa :=_ggea .LookupByReference (*_ab );
if _ffa !=nil {return nil ,_ffa ;};_ece ,_fgc :=_gec .(*PdfIndirectObject );if !_fgc {return _gec ,nil ;};_gec =_ece .PdfObject ;_ ,_eba =_gec .(*PdfObjectReference );if _eba {return _ece ,_f .New ("\u006d\u0075lt\u0069\u0020\u0064e\u0070\u0074\u0068\u0020tra\u0063e \u0070\u006f\u0069\u006e\u0074\u0065\u0072 t\u006f\u0020\u0070\u006f\u0069\u006e\u0074e\u0072");
};return _gec ,nil ;};

// MultiEncoder supports serial encoding.
type MultiEncoder struct{_fbgeg []StreamEncoder };

// GetTrailer returns the PDFs trailer dictionary. The trailer dictionary is typically the starting point for a PDF,
// referencing other key objects that are important in the document structure.
func (_abea *PdfParser )GetTrailer ()*PdfObjectDictionary {return _abea ._fae };

// PdfObjectDictionary represents the primitive PDF dictionary/map object.
type PdfObjectDictionary struct{_egfe map[PdfObjectName ]PdfObject ;_cgcf []PdfObjectName ;_gfae *_b .Mutex ;_aced *PdfParser ;};

// MakeStringFromBytes creates an PdfObjectString from a byte array.
// This is more natural than MakeString as `data` is usually not utf-8 encoded.
func MakeStringFromBytes (data []byte )*PdfObjectString {return MakeString (string (data ))};

// Elements returns a slice of the PdfObject elements in the array.
func (_aece *PdfObjectArray )Elements ()[]PdfObject {if _aece ==nil {return nil ;};return _aece ._edgfg ;};

// GetFilterName returns the name of the encoding filter.
func (_ddb *LZWEncoder )GetFilterName ()string {return StreamEncodingFilterNameLZW };

// ToInt64Slice returns a slice of all array elements as an int64 slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_cdbg *PdfObjectArray )ToInt64Slice ()([]int64 ,error ){var _bgc []int64 ;for _ ,_gcec :=range _cdbg .Elements (){if _bbbd ,_dfbc :=_gcec .(*PdfObjectInteger );_dfbc {_bgc =append (_bgc ,int64 (*_bbbd ));}else {return nil ,ErrTypeError ;};};return _bgc ,nil ;
};

// MakeDecodeParams makes a new instance of an encoding dictionary based on the current encoder settings.
func (_ebbg *JBIG2Encoder )MakeDecodeParams ()PdfObject {return MakeDict ()};

// UpdateParams updates the parameter values of the encoder.
func (_bccb *MultiEncoder )UpdateParams (params *PdfObjectDictionary ){for _ ,_abge :=range _bccb ._fbgeg {_abge .UpdateParams (params );};};

// DecodeStream decodes the stream data and returns the decoded data.
// An error is returned upon failure.
func DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_gb .Log .Trace ("\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_cacb ,_dgdbd :=NewEncoderFromStream (streamObj );if _dgdbd !=nil {_gb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_dgdbd );
return nil ,_dgdbd ;};_gb .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076\u000a",_cacb );_egda ,_dgdbd :=_cacb .DecodeStream (streamObj );if _dgdbd !=nil {_gb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_dgdbd );
return nil ,_dgdbd ;};return _egda ,nil ;};func _ede (_gaag *PdfObjectStream ,_ecfdb *PdfObjectDictionary )(*RunLengthEncoder ,error ){return NewRunLengthEncoder (),nil ;};

// Merge merges in key/values from another dictionary. Overwriting if has same keys.
// The mutated dictionary (d) is returned in order to allow method chaining.
func (_gaeg *PdfObjectDictionary )Merge (another *PdfObjectDictionary )*PdfObjectDictionary {if another !=nil {for _ ,_afgbe :=range another .Keys (){_fffga :=another .Get (_afgbe );_gaeg .Set (_afgbe ,_fffga );};};return _gaeg ;};func (_cb *PdfCrypt )makeKey (_cbd string ,_fd ,_gfde uint32 ,_bea []byte )([]byte ,error ){_adad ,_fcdd :=_cb ._aag [_cbd ];
if !_fcdd {return nil ,_be .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_cbd );};return _adad .MakeKey (_fd ,_gfde ,_bea );};func (_ffdda *PdfObjectInteger )String ()string {return _be .Sprintf ("\u0025\u0064",*_ffdda )};
func (_ccea *PdfParser )readTextLine ()(string ,error ){var _bccgg _ba .Buffer ;for {_bdcb ,_afdb :=_ccea ._eecd .Peek (1);if _afdb !=nil {_gb .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_afdb .Error ());return _bccgg .String (),_afdb ;
};if (_bdcb [0]!='\r')&&(_bdcb [0]!='\n'){_affd ,_ :=_ccea ._eecd .ReadByte ();_bccgg .WriteByte (_affd );}else {break ;};};return _bccgg .String (),nil ;};

// String returns the state of the bool as "true" or "false".
func (_fceaf *PdfObjectBool )String ()string {if *_fceaf {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};

// EncodeBytes encodes the image data using either Group3 or Group4 CCITT facsimile (fax) encoding.
// `data` is expected to be 1 color component, 1 bit per component. It is also valid to provide 8 BPC, 1 CC image like
// a standard go image Gray data.
func (_geeff *CCITTFaxEncoder )EncodeBytes (data []byte )([]byte ,error ){var _ccfc _fe .Gray ;switch len (data ){case _geeff .Rows *_geeff .Columns :_adca ,_aga :=_fe .NewImage (_geeff .Columns ,_geeff .Rows ,8,1,data ,nil ,nil );if _aga !=nil {return nil ,_aga ;
};_ccfc =_adca .(_fe .Gray );case (_geeff .Columns *_geeff .Rows )+7>>3:_ffbcb ,_ffbd :=_fe .NewImage (_geeff .Columns ,_geeff .Rows ,1,1,data ,nil ,nil );if _ffbd !=nil {return nil ,_ffbd ;};_cdgbc :=_ffbcb .(*_fe .Monochrome );if _ffbd =_cdgbc .AddPadding ();
_ffbd !=nil {return nil ,_ffbd ;};_ccfc =_cdgbc ;default:if len (data )< _fe .BytesPerLine (_geeff .Columns ,1,1)*_geeff .Rows {return nil ,_f .New ("p\u0072\u006f\u0076\u0069\u0064\u0065d\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020i\u006e\u0070\u0075t\u0020d\u0061\u0074\u0061");
};_dgbd ,_afeag :=_fe .NewImage (_geeff .Columns ,_geeff .Rows ,1,1,data ,nil ,nil );if _afeag !=nil {return nil ,_afeag ;};_acbf :=_dgbd .(*_fe .Monochrome );_ccfc =_acbf ;};_gdde :=make ([][]byte ,_geeff .Rows );for _dgdg :=0;_dgdg < _geeff .Rows ;_dgdg ++{_ddfaa :=make ([]byte ,_geeff .Columns );
for _fbdbd :=0;_fbdbd < _geeff .Columns ;_fbdbd ++{_aefgg :=_ccfc .GrayAt (_fbdbd ,_dgdg );_ddfaa [_fbdbd ]=_aefgg .Y >>7;};_gdde [_dgdg ]=_ddfaa ;};_efcb :=&_ac .Encoder {K :_geeff .K ,Columns :_geeff .Columns ,EndOfLine :_geeff .EndOfLine ,EndOfBlock :_geeff .EndOfBlock ,BlackIs1 :_geeff .BlackIs1 ,DamagedRowsBeforeError :_geeff .DamagedRowsBeforeError ,Rows :_geeff .Rows ,EncodedByteAlign :_geeff .EncodedByteAlign };
return _efcb .Encode (_gdde ),nil ;};

// ReadAtLeast reads at least n bytes into slice p.
// Returns the number of bytes read (should always be == n), and an error on failure.
func (_bacg *PdfParser )ReadAtLeast (p []byte ,n int )(int ,error ){_facd :=n ;_dff :=0;_ebaf :=0;for _facd > 0{_gbdd ,_dbef :=_bacg ._eecd .Read (p [_dff :]);if _dbef !=nil {_gb .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061d\u0069\u006e\u0067\u0020\u0028\u0025\u0064\u003b\u0025\u0064\u0029\u0020\u0025\u0073",_gbdd ,_ebaf ,_dbef .Error ());
return _dff ,_f .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065a\u0064\u0069\u006e\u0067");};_ebaf ++;_dff +=_gbdd ;_facd -=_gbdd ;};return _dff ,nil ;};

// Clear resets the array to an empty state.
func (_dbaa *PdfObjectArray )Clear (){_dbaa ._edgfg =[]PdfObject {}};

// GetStream returns the *PdfObjectStream represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetStream (obj PdfObject )(_cadgb *PdfObjectStream ,_dgda bool ){obj =ResolveReference (obj );_cadgb ,_dgda =obj .(*PdfObjectStream );return _cadgb ,_dgda ;};

// EncryptInfo contains an information generated by the document encrypter.
type EncryptInfo struct{Version ;

// Encrypt is an encryption dictionary that contains all necessary parameters.
// It should be stored in all copies of the document trailer.
Encrypt *PdfObjectDictionary ;

// ID0 and ID1 are IDs used in the trailer. Older algorithms such as RC4 uses them for encryption.
ID0 ,ID1 string ;};func (_fcd *PdfParser )lookupByNumber (_fed int ,_agd bool )(PdfObject ,bool ,error ){_ccg ,_cg :=_fcd .ObjCache [_fed ];if _cg {_gb .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0063a\u0063\u0068\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0025\u0064",_fed );
return _ccg ,false ,nil ;};if _fcd ._cada ==nil {_fcd ._cada =map[int ]bool {};};if _fcd ._cada [_fed ]{_gb .Log .Debug ("ER\u0052\u004f\u0052\u003a\u0020\u004c\u006fok\u0075\u0070\u0020\u006f\u0066\u0020\u0025\u0064\u0020\u0069\u0073\u0020\u0061\u006c\u0072e\u0061\u0064\u0079\u0020\u0069\u006e\u0020\u0070\u0072\u006f\u0067\u0072\u0065\u0073\u0073\u0020\u002d\u0020\u0072\u0065c\u0075\u0072\u0073\u0069\u0076\u0065 \u006c\u006f\u006f\u006b\u0075\u0070\u0020\u0061\u0074t\u0065m\u0070\u0074\u0020\u0062\u006c\u006f\u0063\u006b\u0065\u0064",_fed );
return nil ,false ,_f .New ("\u0072\u0065\u0063\u0075\u0072\u0073\u0069\u0076\u0065\u0020\u006c\u006f\u006f\u006b\u0075p\u0020a\u0074\u0074\u0065\u006d\u0070\u0074\u0020\u0062\u006c\u006f\u0063\u006b\u0065\u0064");};_fcd ._cada [_fed ]=true ;defer delete (_fcd ._cada ,_fed );
_ddc ,_cg :=_fcd ._aaaf .ObjectMap [_fed ];if !_cg {_gb .Log .Trace ("\u0055\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u006c\u006f\u0063\u0061t\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0069\u006e\u0020\u0078\u0072\u0065\u0066\u0073\u0021 \u002d\u0020\u0052\u0065\u0074u\u0072\u006e\u0069\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074");
var _gcd PdfObjectNull ;return &_gcd ,false ,nil ;};_gb .Log .Trace ("L\u006fo\u006b\u0075\u0070\u0020\u006f\u0062\u006a\u0020n\u0075\u006d\u0062\u0065r \u0025\u0064",_fed );if _ddc .XType ==XrefTypeTableEntry {_gb .Log .Trace ("\u0078r\u0065f\u006f\u0062\u006a\u0020\u006fb\u006a\u0020n\u0075\u006d\u0020\u0025\u0064",_ddc .ObjectNumber );
_gb .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u0067e\u006e\u0020\u0025\u0064",_ddc .Generation );_gb .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0064",_ddc .Offset );_fcd ._ffaf .Seek (_ddc .Offset ,_ed .SeekStart );
_fcd ._eecd =_fg .NewReader (_fcd ._ffaf );_fbe ,_gae :=_fcd .ParseIndirectObject ();if _gae !=nil {_gb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006ce\u0064\u0020\u0072\u0065\u0061\u0064\u0069n\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029",_gae );
if _agd {_gb .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0072\u0065\u0070\u0061\u0069r\u0020\u0078\u0072\u0065\u0066\u0073\u0020\u0028\u0074\u006f\u0070\u0020d\u006f\u0077\u006e\u0029");_cgg ,_fbbg :=_fcd .repairRebuildXrefsTopDown ();
if _fbbg !=nil {_gb .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020r\u0065\u0070\u0061\u0069\u0072\u0020\u0028\u0025\u0073\u0029",_fbbg );return nil ,false ,_fbbg ;};_fcd ._aaaf =*_cgg ;return _fcd .lookupByNumber (_fed ,false );
};return nil ,false ,_gae ;};if _agd {_dgg ,_ ,_ :=_bad (_fbe );if int (_dgg )!=_fed {_gb .Log .Debug ("\u0049n\u0076\u0061\u006c\u0069d\u0020\u0078\u0072\u0065\u0066s\u003a \u0052e\u0062\u0075\u0069\u006c\u0064\u0069\u006eg");_gga :=_fcd .rebuildXrefTable ();
if _gga !=nil {return nil ,false ,_gga ;};_fcd .ObjCache =objectCache {};return _fcd .lookupByNumberWrapper (_fed ,false );};};_gb .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006f\u0062\u006a");_fcd .ObjCache [_fed ]=_fbe ;
return _fbe ,false ,nil ;}else if _ddc .XType ==XrefTypeObjectStream {_gb .Log .Trace ("\u0078r\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0021");_gb .Log .Trace ("\u003e\u004c\u006f\u0061\u0064\u0020\u0076\u0069\u0061\u0020\u004f\u0053\u0021");
_gb .Log .Trace ("\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d \u0061\u0076\u0061\u0069\u006c\u0061b\u006c\u0065\u0020\u0069\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020%\u0064\u002f\u0025\u0064",_ddc .OsObjNumber ,_ddc .OsObjIndex );
if _ddc .OsObjNumber ==_fed {_gb .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0043i\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065f\u0065\u0072\u0065n\u0063e\u0021\u003f\u0021");return nil ,true ,_f .New ("\u0078\u0072\u0065f \u0063\u0069\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");
};if _ ,_acg :=_fcd ._aaaf .ObjectMap [_ddc .OsObjNumber ];_acg {_cdb ,_cad :=_fcd .lookupObjectViaOS (_ddc .OsObjNumber ,_fed );if _cad !=nil {_gb .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0052\u0065\u0074\u0075\u0072\u006e\u0069n\u0067\u0020\u0045\u0052\u0052\u0020\u0028\u0025\u0073\u0029",_cad );
return nil ,true ,_cad ;};_gb .Log .Trace ("\u003c\u004c\u006f\u0061\u0064\u0065\u0064\u0020\u0076i\u0061\u0020\u004f\u0053");_fcd .ObjCache [_fed ]=_cdb ;if _fcd ._cddg !=nil {_fcd ._cddg ._bgg [_cdb ]=true ;};return _cdb ,true ,nil ;};_gb .Log .Debug ("\u003f\u003f\u0020\u0042\u0065\u006c\u006f\u006eg\u0073\u0020\u0074o \u0061\u0020\u006e\u006f\u006e\u002dc\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u002e.\u002e\u0021");
return nil ,true ,_f .New ("\u006f\u0073\u0020\u0062\u0065\u006c\u006fn\u0067\u0073\u0020t\u006f\u0020\u0061\u0020n\u006f\u006e\u0020\u0063\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074");
};return nil ,false ,_f .New ("\u0075\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0078\u0072\u0065\u0066 \u0074\u0079\u0070\u0065");};func (_aage *PdfObjectFloat )String ()string {return _be .Sprintf ("\u0025\u0066",*_aage )};

// GetParser returns the parser for lazy-loading or compare references.
func (_ecca *PdfObjectReference )GetParser ()*PdfParser {return _ecca ._eebc };

// WriteString outputs the object as it is to be written to file.
func (_affc *PdfObjectReference )WriteString ()string {var _agaa _cc .Builder ;_agaa .WriteString (_fc .FormatInt (_affc .ObjectNumber ,10));_agaa .WriteString ("\u0020");_agaa .WriteString (_fc .FormatInt (_affc .GenerationNumber ,10));_agaa .WriteString ("\u0020\u0052");
return _agaa .String ();};

// EncodeImage encodes 'img' golang image.Image into jbig2 encoded bytes document using default encoder settings.
func (_bdag *JBIG2Encoder )EncodeImage (img _ca .Image )([]byte ,error ){return _bdag .encodeImage (img )};

// Set sets the PdfObject at index i of the array. An error is returned if the index is outside bounds.
func (_gdcf *PdfObjectArray )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_gdcf ._edgfg ){return _f .New ("\u006f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_gdcf ._edgfg [i ]=obj ;return nil ;};

// ParseIndirectObject parses an indirect object from the input stream. Can also be an object stream.
// Returns the indirect object (*PdfIndirectObject) or the stream object (*PdfObjectStream).
func (_efga *PdfParser )ParseIndirectObject ()(PdfObject ,error ){_efccd :=PdfIndirectObject {};_efccd ._eebc =_efga ;_gb .Log .Trace ("\u002dR\u0065a\u0064\u0020\u0069\u006e\u0064i\u0072\u0065c\u0074\u0020\u006f\u0062\u006a");_daaf ,_bde :=_efga ._eecd .Peek (20);
if _bde !=nil {if _bde !=_ed .EOF {_gb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020r\u0065a\u0064\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a");return &_efccd ,_bde ;
};};_gb .Log .Trace ("\u0028\u0069\u006edi\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_daaf ));_caca :=_effe .FindStringSubmatchIndex (string (_daaf ));if len (_caca )< 6{if _bde ==_ed .EOF {return nil ,_bde ;
};_gb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_daaf ));
return &_efccd ,_f .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");
};_efga ._eecd .Discard (_caca [0]);_gb .Log .Trace ("O\u0066\u0066\u0073\u0065\u0074\u0073\u0020\u0025\u0020\u0064",_caca );_bbaf :=_caca [1]-_caca [0];_bfca :=make ([]byte ,_bbaf );_ ,_bde =_efga .ReadAtLeast (_bfca ,_bbaf );if _bde !=nil {_gb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u0072\u0065\u0061\u0064\u0020-\u0020\u0025\u0073",_bde );
return nil ,_bde ;};_gb .Log .Trace ("\u0074\u0065\u0078t\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_bfca );_dced :=_effe .FindStringSubmatch (string (_bfca ));if len (_dced )< 3{_gb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_bfca ));
return &_efccd ,_f .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");
};_dbdb ,_ :=_fc .Atoi (_dced [1]);_cadaf ,_ :=_fc .Atoi (_dced [2]);_efccd .ObjectNumber =int64 (_dbdb );_efccd .GenerationNumber =int64 (_cadaf );for {_bgfe ,_effd :=_efga ._eecd .Peek (2);if _effd !=nil {return &_efccd ,_effd ;};_gb .Log .Trace ("I\u006ed\u002e\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_bgfe ),string (_bgfe ));
if IsWhiteSpace (_bgfe [0]){_efga .skipSpaces ();}else if _bgfe [0]=='%'{_efga .skipComments ();}else if (_bgfe [0]=='<')&&(_bgfe [1]=='<'){_gb .Log .Trace ("\u0043\u0061\u006c\u006c\u0020\u0050\u0061\u0072\u0073e\u0044\u0069\u0063\u0074");_efccd .PdfObject ,_effd =_efga .ParseDict ();
_gb .Log .Trace ("\u0045\u004f\u0046\u0020Ca\u006c\u006c\u0020\u0050\u0061\u0072\u0073\u0065\u0044\u0069\u0063\u0074\u003a\u0020%\u0076",_effd );if _effd !=nil {return &_efccd ,_effd ;};_gb .Log .Trace ("\u0050\u0061\u0072\u0073\u0065\u0064\u0020\u0064\u0069\u0063t\u0069\u006f\u006e\u0061\u0072\u0079\u002e.\u002e\u0020\u0066\u0069\u006e\u0069\u0073\u0068\u0065\u0064\u002e");
}else if (_bgfe [0]=='/')||(_bgfe [0]=='(')||(_bgfe [0]=='[')||(_bgfe [0]=='<'){_efccd .PdfObject ,_effd =_efga .parseObject ();if _effd !=nil {return &_efccd ,_effd ;};_gb .Log .Trace ("P\u0061\u0072\u0073\u0065\u0064\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u002e\u002e\u002e \u0066\u0069\u006ei\u0073h\u0065\u0064\u002e");
}else if _bgfe [0]==']'{_gb .Log .Debug ("\u0057\u0041\u0052\u004e\u0049N\u0047\u003a\u0020\u0027\u005d\u0027 \u0063\u0068\u0061\u0072\u0061\u0063\u0074e\u0072\u0020\u006eo\u0074\u0020\u0062\u0065i\u006e\u0067\u0020\u0075\u0073\u0065d\u0020\u0061\u0073\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006e\u0064\u0069n\u0067\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e");
_efga ._eecd .Discard (1);}else {if _bgfe [0]=='e'{_ggbc ,_feeg :=_efga .readTextLine ();if _feeg !=nil {return nil ,_feeg ;};if len (_ggbc )>=6&&_ggbc [0:6]=="\u0065\u006e\u0064\u006f\u0062\u006a"{break ;};}else if _bgfe [0]=='s'{_bgfe ,_ =_efga ._eecd .Peek (10);
if string (_bgfe [:6])=="\u0073\u0074\u0072\u0065\u0061\u006d"{_aegca :=6;if len (_bgfe )> 6{if IsWhiteSpace (_bgfe [_aegca ])&&_bgfe [_aegca ]!='\r'&&_bgfe [_aegca ]!='\n'{_gb .Log .Debug ("\u004e\u006fn\u002d\u0063\u006f\u006e\u0066\u006f\u0072\u006d\u0061\u006e\u0074\u0020\u0050\u0044\u0046\u0020\u006e\u006f\u0074 \u0065\u006e\u0064\u0069\u006e\u0067 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0069\u006e\u0065\u0020\u0070\u0072o\u0070\u0065r\u006c\u0079\u0020\u0077i\u0074\u0068\u0020\u0045\u004fL\u0020\u006d\u0061\u0072\u006b\u0065\u0072");
_efga ._fbgfd ._bcgg =true ;_aegca ++;};if _bgfe [_aegca ]=='\r'{_aegca ++;if _bgfe [_aegca ]=='\n'{_aegca ++;};}else if _bgfe [_aegca ]=='\n'{_aegca ++;}else {_efga ._fbgfd ._bcgg =true ;};};_efga ._eecd .Discard (_aegca );_eded ,_cead :=_efccd .PdfObject .(*PdfObjectDictionary );
if !_cead {return nil ,_f .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006di\u0073s\u0069\u006e\u0067\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_gb .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0069c\u0074\u0020\u0025\u0073",_eded );
_aafga ,_cfgd :=_efga .traceStreamLength (_eded .Get ("\u004c\u0065\u006e\u0067\u0074\u0068"));if _cfgd !=nil {_gb .Log .Debug ("\u0046\u0061\u0069l\u0020\u0074\u006f\u0020t\u0072\u0061\u0063\u0065\u0020\u0073\u0074r\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0025\u0076",_cfgd );
return nil ,_cfgd ;};_gb .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_aafga );_ffbea ,_feacd :=_aafga .(*PdfObjectInteger );if !_feacd {return nil ,_f .New ("\u0073\u0074re\u0061\u006d\u0020l\u0065\u006e\u0067\u0074h n\u0065ed\u0073\u0020\u0074\u006f\u0020\u0062\u0065 a\u006e\u0020\u0069\u006e\u0074\u0065\u0067e\u0072");
};_cdfb :=*_ffbea ;if _cdfb < 0{return nil ,_f .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006e\u0065\u0065\u0064\u0073\u0020\u0074\u006f \u0062e\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0030");};_agce :=_efga .GetFileOffset ();
_gefc :=_efga .xrefNextObjectOffset (_agce );if _agce +int64 (_cdfb )> _gefc &&_gefc > _agce {_gb .Log .Debug ("E\u0078\u0070\u0065\u0063te\u0064 \u0065\u006e\u0064\u0069\u006eg\u0020\u0061\u0074\u0020\u0025\u0064",_agce +int64 (_cdfb ));_gb .Log .Debug ("\u004e\u0065\u0078\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020\u0061t\u0020\u0025\u0064",_gefc );
_eadag :=_gefc -_agce -17;if _eadag < 0{return nil ,_f .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020go\u0069\u006e\u0067 \u0070\u0061s\u0074\u0020\u0062\u006f\u0075\u006ed\u0061\u0072i\u0065\u0073");
};_gb .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0061\u0020l\u0065\u006e\u0067\u0074\u0068\u0020c\u006f\u0072\u0072\u0065\u0063\u0074\u0069\u006f\u006e\u0020\u0074\u006f\u0020%\u0064\u002e\u002e\u002e",_eadag );_cdfb =PdfObjectInteger (_eadag );
_eded .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (_eadag ));};if int64 (_cdfb )> _efga ._gfab {_gb .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0053t\u0072\u0065\u0061\u006d\u0020l\u0065\u006e\u0067\u0074\u0068\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u0061\u0072\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0066\u0069\u006c\u0065\u0020\u0073\u0069\u007a\u0065");
return nil ,_f .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020la\u0072\u0067\u0065r\u0020\u0074h\u0061\u006e\u0020\u0066\u0069\u006ce\u0020\u0073i\u007a\u0065");};_gdce :=make ([]byte ,_cdfb );
_ ,_cfgd =_efga .ReadAtLeast (_gdce ,int (_cdfb ));if _cfgd !=nil {_gb .Log .Debug ("E\u0052\u0052\u004f\u0052 s\u0074r\u0065\u0061\u006d\u0020\u0028%\u0064\u0029\u003a\u0020\u0025\u0058",len (_gdce ),_gdce );_gb .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_cfgd );
return nil ,_cfgd ;};_cdee :=PdfObjectStream {};_cdee .Stream =_gdce ;_cdee .PdfObjectDictionary =_efccd .PdfObject .(*PdfObjectDictionary );_cdee .ObjectNumber =_efccd .ObjectNumber ;_cdee .GenerationNumber =_efccd .GenerationNumber ;_cdee .PdfObjectReference ._eebc =_efga ;
_efga .skipSpaces ();_efga ._eecd .Discard (9);_efga .skipSpaces ();return &_cdee ,nil ;};};_efccd .PdfObject ,_effd =_efga .parseObject ();if _efccd .PdfObject ==nil {_gb .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");
_efccd .PdfObject =MakeNull ();};return &_efccd ,_effd ;};};if _efccd .PdfObject ==nil {_gb .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");
_efccd .PdfObject =MakeNull ();};_gb .Log .Trace ("\u0052\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0021");return &_efccd ,nil ;};

// Decrypt attempts to decrypt the PDF file with a specified password.  Also tries to
// decrypt with an empty password.  Returns true if successful, false otherwise.
// An error is returned when there is a problem with decrypting.
func (_cfffe *PdfParser )Decrypt (password []byte )(bool ,error ){if _cfffe ._cddg ==nil {return false ,_f .New ("\u0063\u0068\u0065\u0063k \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u0069\u0072s\u0074");};_caeg ,_gcage :=_cfffe ._cddg .authenticate (password );
if _gcage !=nil {return false ,_gcage ;};if !_caeg {_caeg ,_gcage =_cfffe ._cddg .authenticate ([]byte (""));};return _caeg ,_gcage ;};

// UpdateParams updates the parameter values of the encoder.
func (_cggb *FlateEncoder )UpdateParams (params *PdfObjectDictionary ){_bbd ,_cbdaf :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _cbdaf ==nil {_cggb .Predictor =int (_bbd );};_dfebd ,_cbdaf :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));
if _cbdaf ==nil {_cggb .BitsPerComponent =int (_dfebd );};_aadc ,_cbdaf :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _cbdaf ==nil {_cggb .Columns =int (_aadc );};_cfe ,_cbdaf :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));
if _cbdaf ==nil {_cggb .Colors =int (_cfe );};};

// Keys returns the list of keys in the dictionary.
// If `d` is nil returns a nil slice.
func (_fdbee *PdfObjectDictionary )Keys ()[]PdfObjectName {if _fdbee ==nil {return nil ;};return _fdbee ._cgcf ;};

// String returns a string representation of `name`.
func (_feaeg *PdfObjectName )String ()string {return string (*_feaeg )};func (_ddcff *PdfParser )inspect ()(map[string ]int ,error ){_gb .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0053P\u0045\u0043\u0054\u0020\u002d\u002d\u002d\u002d\u002d\u002d-\u002d\u002d\u002d");
_gb .Log .Trace ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");_aeegg :=map[string ]int {};_gebg :=0;_ccce :=0;var _agbbg []int ;for _fcadb :=range _ddcff ._aaaf .ObjectMap {_agbbg =append (_agbbg ,_fcadb );};_gd .Ints (_agbbg );_dfff :=0;
for _ ,_gacab :=range _agbbg {_ggfa :=_ddcff ._aaaf .ObjectMap [_gacab ];if _ggfa .ObjectNumber ==0{continue ;};_gebg ++;_gb .Log .Trace ("\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d");_gb .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0075\u0070\u0020\u006f\u0062\u006a\u0065c\u0074 \u006e\u0075\u006d\u0062\u0065\u0072\u003a \u0025\u0064",_ggfa .ObjectNumber );
_gfcee ,_gdda :=_ddcff .LookupByNumber (_ggfa .ObjectNumber );if _gdda !=nil {_gb .Log .Trace ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u006c\u006f\u006f\u006b\u0075p\u0020\u006f\u0062\u006a\u0020\u0025\u0064 \u0028\u0025\u0073\u0029",_ggfa .ObjectNumber ,_gdda );
_ccce ++;continue ;};_gb .Log .Trace ("\u006fb\u006a\u003a\u0020\u0025\u0073",_gfcee );_defg ,_dbag :=_gfcee .(*PdfIndirectObject );if _dbag {_gb .Log .Trace ("\u0049N\u0044 \u004f\u004f\u0042\u004a\u0020\u0025\u0064\u003a\u0020\u0025\u0073",_ggfa .ObjectNumber ,_defg );
_cdcbf ,_fcdc :=_defg .PdfObject .(*PdfObjectDictionary );if _fcdc {if _bddcd ,_fgabcb :=_cdcbf .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_fgabcb {_fbfc :=string (*_bddcd );_gb .Log .Trace ("\u002d\u002d\u002d\u003e\u0020\u004f\u0062\u006a\u0020\u0074\u0079\u0070e\u003a\u0020\u0025\u0073",_fbfc );
_ ,_efcg :=_aeegg [_fbfc ];if _efcg {_aeegg [_fbfc ]++;}else {_aeegg [_fbfc ]=1;};}else if _eaf ,_gfdda :=_cdcbf .Get ("\u0053u\u0062\u0074\u0079\u0070\u0065").(*PdfObjectName );_gfdda {_bddec :=string (*_eaf );_gb .Log .Trace ("-\u002d-\u003e\u0020\u004f\u0062\u006a\u0020\u0073\u0075b\u0074\u0079\u0070\u0065: \u0025\u0073",_bddec );
_ ,_bggg :=_aeegg [_bddec ];if _bggg {_aeegg [_bddec ]++;}else {_aeegg [_bddec ]=1;};};if _beaeg ,_bafad :=_cdcbf .Get ("\u0053").(*PdfObjectName );_bafad &&*_beaeg =="\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"{_ ,_edced :=_aeegg ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"];
if _edced {_aeegg ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]++;}else {_aeegg ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]=1;};};};}else if _edab ,_gbgde :=_gfcee .(*PdfObjectStream );_gbgde {if _egde ,_acgfg :=_edab .PdfObjectDictionary .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );
_acgfg {_gb .Log .Trace ("\u002d\u002d\u003e\u0020\u0053\u0074\u0072\u0065\u0061\u006d\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073",*_egde );_ffgd :=string (*_egde );_aeegg [_ffgd ]++;};}else {_becd ,_egfc :=_gfcee .(*PdfObjectDictionary );
if _egfc {_bbaa ,_bfeg :=_becd .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if _bfeg {_fefe :=string (*_bbaa );_gb .Log .Trace ("\u002d-\u002d \u006f\u0062\u006a\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073",_fefe );_aeegg [_fefe ]++;};};_gb .Log .Trace ("\u0044\u0049\u0052\u0045\u0043\u0054\u0020\u004f\u0042\u004a\u0020\u0025d\u003a\u0020\u0025\u0073",_ggfa .ObjectNumber ,_gfcee );
};_dfff ++;};_gb .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0045\u004fF\u0020\u0049\u004e\u0053\u0050\u0045\u0043T\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d");_gb .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");
_gb .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074 \u0063\u006f\u0075\u006e\u0074\u003a\u0020\u0025\u0064",_gebg );_gb .Log .Trace ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u006f\u006b\u0075p\u003a\u0020\u0025\u0064",_ccce );for _debagf ,_gfed :=range _aeegg {_gb .Log .Trace ("\u0025\u0073\u003a\u0020\u0025\u0064",_debagf ,_gfed );
};_gb .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");if len (_ddcff ._aaaf .ObjectMap )< 1{_gb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0068\u0069\u0073 \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074 \u0069s\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0028\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0021\u0029");
return nil ,_be .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0064\u006fc\u0075\u006d\u0065\u006e\u0074\u0020\u0028\u0078r\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006d\u0069\u0073s\u0069\u006e\u0067\u0029");};_gfaca ,_acga :=_aeegg ["\u0046\u006f\u006e\u0074"];
if !_acga ||_gfaca < 2{_gb .Log .Trace ("\u0054\u0068\u0069s \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020i\u0073 \u0070r\u006fb\u0061\u0062\u006c\u0079\u0020\u0073\u0063\u0061\u006e\u006e\u0065\u0064\u0021");}else {_gb .Log .Trace ("\u0054\u0068\u0069\u0073\u0020\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020\u0069\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0066o\u0072\u0020\u0065\u0078\u0074r\u0061\u0063t\u0069\u006f\u006e\u0021");
};return _aeegg ,nil ;};func (_agdf *PdfCrypt )loadCryptFilters (_adf *PdfObjectDictionary )error {_agdf ._aag =cryptFilters {};_edc :=_adf .Get ("\u0043\u0046");_edc =TraceToDirectObject (_edc );if _ebe ,_bcef :=_edc .(*PdfObjectReference );_bcef {_ccda ,_bag :=_agdf ._gbaa .LookupByReference (*_ebe );
if _bag !=nil {_gb .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0075\u0070\u0020\u0043\u0046\u0020\u0072\u0065\u0066\u0065\u0072en\u0063\u0065");return _bag ;};_edc =TraceToDirectObject (_ccda );};_fbdb ,_ecee :=_edc .(*PdfObjectDictionary );
if !_ecee {_gb .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0043\u0046\u002c \u0074\u0079\u0070\u0065: \u0025\u0054",_edc );return _f .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0043\u0046");};for _ ,_fbf :=range _fbdb .Keys (){_caf :=_fbdb .Get (_fbf );
if _gaa ,_ceeb :=_caf .(*PdfObjectReference );_ceeb {_dfd ,_ebbe :=_agdf ._gbaa .LookupByReference (*_gaa );if _ebbe !=nil {_gb .Log .Debug ("\u0045\u0072ro\u0072\u0020\u006co\u006f\u006b\u0075\u0070 up\u0020di\u0063\u0074\u0069\u006f\u006e\u0061\u0072y \u0072\u0065\u0066\u0065\u0072\u0065\u006ec\u0065");
return _ebbe ;};_caf =TraceToDirectObject (_dfd );};_adc ,_daed :=_caf .(*PdfObjectDictionary );if !_daed {return _be .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074\u0020\u0069\u006e \u0043\u0046\u0020\u0028\u006e\u0061\u006d\u0065\u0020\u0025\u0073\u0029\u0020-\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079\u0020\u0062\u0075\u0074\u0020\u0025\u0054",_fbf ,_caf );
};if _fbf =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{_gb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u002d\u0020\u0043\u0061\u006e\u006e\u006f\u0074\u0020\u006f\u0076\u0065\u0072\u0077r\u0069\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0069d\u0065\u006e\u0074\u0069\u0074\u0079\u0020\u0066\u0069\u006c\u0074\u0065\u0072 \u002d\u0020\u0054\u0072\u0079\u0069n\u0067\u0020\u006ee\u0078\u0074");
continue ;};var _eggd _egg .FilterDict ;if _dcg :=_ccd (&_eggd ,_adc );_dcg !=nil {return _dcg ;};_eaaa ,_aac :=_egg .NewFilter (_eggd );if _aac !=nil {return _aac ;};_agdf ._aag [string (_fbf )]=_eaaa ;};_agdf ._aag ["\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"]=_egg .NewIdentity ();
_agdf ._fbd ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _acce ,_aeb :=_adf .Get ("\u0053\u0074\u0072\u0046").(*PdfObjectName );_aeb {if _ ,_dfa :=_agdf ._aag [string (*_acce )];!_dfa {return _be .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u0072\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_acce );
};_agdf ._fbd =string (*_acce );};_agdf ._fca ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _eag ,_gdc :=_adf .Get ("\u0053\u0074\u006d\u0046").(*PdfObjectName );_gdc {if _ ,_aebd :=_agdf ._aag [string (*_eag )];!_aebd {return _be .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u006d\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_eag );
};_agdf ._fca =string (*_eag );};return nil ;};

// GetIntVal returns the int value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetIntVal (obj PdfObject )(_fgce int ,_bdad bool ){_dgbb ,_bdad :=TraceToDirectObject (obj ).(*PdfObjectInteger );if _bdad &&_dgbb !=nil {return int (*_dgbb ),true ;};return 0,false ;};

// GetIndirect returns the *PdfIndirectObject represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetIndirect (obj PdfObject )(_cfaf *PdfIndirectObject ,_feab bool ){obj =ResolveReference (obj );_cfaf ,_feab =obj .(*PdfIndirectObject );return _cfaf ,_feab ;};

// Append appends PdfObject(s) to the streams.
func (_gcegf *PdfObjectStreams )Append (objects ...PdfObject ){if _gcegf ==nil {_gb .Log .Debug ("\u0057\u0061\u0072\u006e\u0020-\u0020\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0020\u0074\u006f\u0020\u0061p\u0070\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0073");
return ;};_gcegf ._ffcdf =append (_gcegf ._ffcdf ,objects ...);};func (_babc *PdfParser )parseBool ()(PdfObjectBool ,error ){_afde ,_acfaa :=_babc ._eecd .Peek (4);if _acfaa !=nil {return PdfObjectBool (false ),_acfaa ;};if (len (_afde )>=4)&&(string (_afde [:4])=="\u0074\u0072\u0075\u0065"){_babc ._eecd .Discard (4);
return PdfObjectBool (true ),nil ;};_afde ,_acfaa =_babc ._eecd .Peek (5);if _acfaa !=nil {return PdfObjectBool (false ),_acfaa ;};if (len (_afde )>=5)&&(string (_afde [:5])=="\u0066\u0061\u006cs\u0065"){_babc ._eecd .Discard (5);return PdfObjectBool (false ),nil ;
};return PdfObjectBool (false ),_f .New ("\u0075n\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0062o\u006fl\u0065a\u006e\u0020\u0073\u0074\u0072\u0069\u006eg");};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_gfcfg *RawEncoder )MakeDecodeParams ()PdfObject {return nil };

// DrawableImage is same as golang image/draw's Image interface that allow drawing images.
type DrawableImage interface{ColorModel ()_eg .Model ;Bounds ()_ca .Rectangle ;At (_bbeg ,_agcd int )_eg .Color ;Set (_beb ,_baec int ,_ggc _eg .Color );};

// Version represents a version of a PDF standard.
type Version struct{Major int ;Minor int ;};

// DecodeStream implements ASCII85 stream decoding.
func (_fffg *ASCII85Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _fffg .DecodeBytes (streamObj .Stream );};func _dge (_bgba *_bed .StdEncryptDict ,_dae *PdfObjectDictionary ){_dae .Set ("\u0052",MakeInteger (int64 (_bgba .R )));
_dae .Set ("\u0050",MakeInteger (int64 (_bgba .P )));_dae .Set ("\u004f",MakeStringFromBytes (_bgba .O ));_dae .Set ("\u0055",MakeStringFromBytes (_bgba .U ));if _bgba .R >=5{_dae .Set ("\u004f\u0045",MakeStringFromBytes (_bgba .OE ));_dae .Set ("\u0055\u0045",MakeStringFromBytes (_bgba .UE ));
_dae .Set ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061",MakeBool (_bgba .EncryptMetadata ));if _bgba .R > 5{_dae .Set ("\u0050\u0065\u0072m\u0073",MakeStringFromBytes (_bgba .Perms ));};};};

// CheckAccessRights checks access rights and permissions for a specified password. If either user/owner password is
// specified, full rights are granted, otherwise the access rights are specified by the Permissions flag.
//
// The bool flag indicates that the user can access and view the file.
// The AccessPermissions shows what access the user has for editing etc.
// An error is returned if there was a problem performing the authentication.
func (_cded *PdfParser )CheckAccessRights (password []byte )(bool ,_bed .Permissions ,error ){if _cded ._cddg ==nil {return true ,_bed .PermOwner ,nil ;};return _cded ._cddg .checkAccessRights (password );};const (StreamEncodingFilterNameFlate ="F\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065";
StreamEncodingFilterNameLZW ="\u004cZ\u0057\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameDCT ="\u0044C\u0054\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameRunLength ="\u0052u\u006eL\u0065\u006e\u0067\u0074\u0068\u0044\u0065\u0063\u006f\u0064\u0065";
StreamEncodingFilterNameASCIIHex ="\u0041\u0053\u0043\u0049\u0049\u0048\u0065\u0078\u0044e\u0063\u006f\u0064\u0065";StreamEncodingFilterNameASCII85 ="\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameCCITTFax ="\u0043\u0043\u0049\u0054\u0054\u0046\u0061\u0078\u0044e\u0063\u006f\u0064\u0065";
StreamEncodingFilterNameJBIG2 ="J\u0042\u0049\u0047\u0032\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameJPX ="\u004aP\u0058\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameRaw ="\u0052\u0061\u0077";);

// FlattenObject returns the contents of `obj`. In other words, `obj` with indirect objects replaced
// by their values.
// The replacements are made recursively to a depth of traceMaxDepth.
// NOTE: Dicts are sorted to make objects with same contents have the same PDF object strings.
func FlattenObject (obj PdfObject )PdfObject {return _bedbe (obj ,0)};

// IsWhiteSpace checks if byte represents a white space character.
func IsWhiteSpace (ch byte )bool {if (ch ==0x00)||(ch ==0x09)||(ch ==0x0A)||(ch ==0x0C)||(ch ==0x0D)||(ch ==0x20){return true ;};return false ;};

// MakeBool creates a PdfObjectBool from a bool value.
func MakeBool (val bool )*PdfObjectBool {_aeddd :=PdfObjectBool (val );return &_aeddd };func (_addg *PdfParser )getNumbersOfUpdatedObjects (_cfac *PdfParser )([]int ,error ){if _cfac ==nil {return nil ,_f .New ("\u0070\u0072e\u0076\u0069\u006f\u0075\u0073\u0020\u0070\u0061\u0072\u0073\u0065\u0072\u0020\u0063\u0061\u006e\u0027\u0074\u0020\u0062\u0065\u0020nu\u006c\u006c");
};_gfddg :=_cfac ._gfab ;_bceb :=make ([]int ,0);_acgc :=make (map[int ]interface{});_dcfe :=make (map[int ]int64 );for _edgc ,_gaab :=range _addg ._aaaf .ObjectMap {if _gaab .Offset ==0{if _gaab .OsObjNumber !=0{if _gaec ,_fdbfc :=_addg ._aaaf .ObjectMap [_gaab .OsObjNumber ];
_fdbfc {_acgc [_gaab .OsObjNumber ]=struct{}{};_dcfe [_edgc ]=_gaec .Offset ;}else {return nil ,_f .New ("u\u006ed\u0065\u0066\u0069\u006e\u0065\u0064\u0020\u0078r\u0065\u0066\u0020\u0074ab\u006c\u0065");};};}else {_dcfe [_edgc ]=_gaab .Offset ;};};for _fddc ,_cadf :=range _dcfe {if _ ,_aacde :=_acgc [_fddc ];
_aacde {continue ;};if _cadf > _gfddg {_bceb =append (_bceb ,_fddc );};};return _bceb ,nil ;};var _fbgg =_d .MustCompile ("\u0025P\u0044F\u002d\u0028\u005c\u0064\u0029\u005c\u002e\u0028\u005c\u0064\u0029");type objectStreams map[int ]objectStream ;func _ffde (_aae _fe .Image )*JBIG2Image {_cadc :=_aae .Base ();
return &JBIG2Image {Data :_cadc .Data ,Width :_cadc .Width ,Height :_cadc .Height ,HasPadding :true };};

// DecodeBytes decodes a slice of JPX encoded bytes and returns the result.
func (_dcbf *JPXEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_gb .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_dcbf .GetFilterName ());
return encoded ,ErrNoJPXDecode ;};type objectStream struct{N int ;_fbb []byte ;_ebf map[int ]int64 ;};

// WriteString outputs the object as it is to be written to file.
func (_ffbg *PdfObjectFloat )WriteString ()string {return _fc .FormatFloat (float64 (*_ffbg ),'f',-1,64);};

// MakeDict creates and returns an empty PdfObjectDictionary.
func MakeDict ()*PdfObjectDictionary {_bgeg :=&PdfObjectDictionary {};_bgeg ._egfe =map[PdfObjectName ]PdfObject {};_bgeg ._cgcf =[]PdfObjectName {};_bgeg ._gfae =&_b .Mutex {};return _bgeg ;};func (_bbc *PdfCrypt )isDecrypted (_dadf PdfObject )bool {_ ,_afg :=_bbc ._bgg [_dadf ];
if _afg {_gb .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0064\u0065\u0063\u0072y\u0070\u0074\u0065\u0064");return true ;};switch _faag :=_dadf .(type ){case *PdfObjectStream :if _bbc ._bgf .R !=5{if _bfb ,_fege :=_faag .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );
_fege &&*_bfb =="\u0058\u0052\u0065\u0066"{return true ;};};case *PdfIndirectObject :if _ ,_afg =_bbc ._dcb [int (_faag .ObjectNumber )];_afg {return true ;};switch _gad :=_faag .PdfObject .(type ){case *PdfObjectDictionary :_bbg :=true ;for _ ,_cfa :=range _daa {if _gad .Get (_cfa )==nil {_bbg =false ;
break ;};};if _bbg {return true ;};};};_gb .Log .Trace ("\u004e\u006f\u0074\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");return false ;};

// GetFloat returns the *PdfObjectFloat represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetFloat (obj PdfObject )(_eegdg *PdfObjectFloat ,_faafa bool ){_eegdg ,_faafa =TraceToDirectObject (obj ).(*PdfObjectFloat );return _eegdg ,_faafa ;};func _acc (_bff int )cryptFilters {return cryptFilters {_afe :_egg .NewFilterV2 (_bff )}};

// HasNonConformantStream implements core.ParserMetadata.
func (_aadf ParserMetadata )HasNonConformantStream ()bool {return _aadf ._bcgg };

// DecodeImages decodes the page images from the jbig2 'encoded' data input.
// The jbig2 document may contain multiple pages, thus the function can return multiple
// images. The images order corresponds to the page number.
func (_cccd *JBIG2Encoder )DecodeImages (encoded []byte )([]_ca .Image ,error ){const _fbdfd ="\u004aB\u0049\u0047\u0032\u0045n\u0063\u006f\u0064\u0065\u0072.\u0044e\u0063o\u0064\u0065\u0049\u006d\u0061\u0067\u0065s";_ddcg ,_gbgd :=_gdga .Decode (encoded ,_gdga .Parameters {},_cccd .Globals .ToDocumentGlobals ());
if _gbgd !=nil {return nil ,_geb .Wrap (_gbgd ,_fbdfd ,"");};_gcag ,_gbgd :=_ddcg .PageNumber ();if _gbgd !=nil {return nil ,_geb .Wrap (_gbgd ,_fbdfd ,"");};_efgc :=[]_ca .Image {};var _bbac _ca .Image ;for _cbea :=1;_cbea <=_gcag ;_cbea ++{_bbac ,_gbgd =_ddcg .DecodePageImage (_cbea );
if _gbgd !=nil {return nil ,_geb .Wrapf (_gbgd ,_fbdfd ,"\u0070\u0061\u0067\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_cbea );};_efgc =append (_efgc ,_bbac );};return _efgc ,nil ;};

// StreamEncoder represents the interface for all PDF stream encoders.
type StreamEncoder interface{GetFilterName ()string ;MakeDecodeParams ()PdfObject ;MakeStreamDict ()*PdfObjectDictionary ;UpdateParams (_ceag *PdfObjectDictionary );EncodeBytes (_efe []byte )([]byte ,error );DecodeBytes (_fab []byte )([]byte ,error );DecodeStream (_cbdc *PdfObjectStream )([]byte ,error );
};

// EncodeBytes DCT encodes the passed in slice of bytes.
func (_feb *DCTEncoder )EncodeBytes (data []byte )([]byte ,error ){var _ggaa _ca .Image ;if _feb .ColorComponents ==1&&_feb .BitsPerComponent ==8{_ggaa =&_ca .Gray {Rect :_ca .Rect (0,0,_feb .Width ,_feb .Height ),Pix :data ,Stride :_fe .BytesPerLine (_feb .Width ,_feb .BitsPerComponent ,_feb .ColorComponents )};
}else {var _fffe error ;_ggaa ,_fffe =_fe .NewImage (_feb .Width ,_feb .Height ,_feb .BitsPerComponent ,_feb .ColorComponents ,data ,nil ,nil );if _fffe !=nil {return nil ,_fffe ;};};_cgd :=_gdg .Options {};_cgd .Quality =_feb .Quality ;var _dcad _ba .Buffer ;
if _bbfb :=_gdg .Encode (&_dcad ,_ggaa ,&_cgd );_bbfb !=nil {return nil ,_bbfb ;};return _dcad .Bytes (),nil ;};func _gbfg (_bef _egg .Filter ,_adg _bed .AuthEvent )*PdfObjectDictionary {if _adg ==""{_adg =_bed .EventDocOpen ;};_ef :=MakeDict ();_ef .Set ("\u0054\u0079\u0070\u0065",MakeName ("C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"));
_ef .Set ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et",MakeName (string (_adg )));_ef .Set ("\u0043\u0046\u004d",MakeName (_bef .Name ()));_ef .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_bef .KeyLength ())));return _ef ;};

// Bytes returns the PdfObjectString content as a []byte array.
func (_ceed *PdfObjectString )Bytes ()[]byte {return []byte (_ceed ._fddd )};

// GetFloatVal returns the float64 value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetFloatVal (obj PdfObject )(_gceg float64 ,_dbcfb bool ){_gcg ,_dbcfb :=TraceToDirectObject (obj ).(*PdfObjectFloat );if _dbcfb {return float64 (*_gcg ),true ;};return 0,false ;};

// Get returns the i-th element of the array or nil if out of bounds (by index).
func (_bbaff *PdfObjectArray )Get (i int )PdfObject {if _bbaff ==nil ||i >=len (_bbaff ._edgfg )||i < 0{return nil ;};return _bbaff ._edgfg [i ];};func (_eacb *PdfParser )seekPdfVersionTopDown ()(int ,int ,error ){_eacb ._ffaf .Seek (0,_ed .SeekStart );
_eacb ._eecd =_fg .NewReader (_eacb ._ffaf );_dfacg :=20;_bfac :=make ([]byte ,_dfacg );for {_bfccf ,_adgd :=_eacb ._eecd .ReadByte ();if _adgd !=nil {if _adgd ==_ed .EOF {break ;}else {return 0,0,_adgd ;};};if IsDecimalDigit (_bfccf )&&_bfac [_dfacg -1]=='.'&&IsDecimalDigit (_bfac [_dfacg -2])&&_bfac [_dfacg -3]=='-'&&_bfac [_dfacg -4]=='F'&&_bfac [_dfacg -5]=='D'&&_bfac [_dfacg -6]=='P'{_cege :=int (_bfac [_dfacg -2]-'0');
_gfea :=int (_bfccf -'0');return _cege ,_gfea ,nil ;};_bfac =append (_bfac [1:_dfacg ],_bfccf );};return 0,0,_f .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};

// DecodeBytes decodes a slice of Flate encoded bytes and returns the result.
func (_affe *FlateEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_gb .Log .Trace ("\u0046\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065\u0020b\u0079\u0074\u0065\u0073");if len (encoded )==0{_gb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0046\u006c\u0061\u0074\u0065 e\u006ec\u006f\u0064\u0065\u0064\u0020\u0062\u0075\u0066\u0066\u0065\u0072\u002e \u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0062y\u0074\u0065\u0020\u0073\u006c\u0069\u0063\u0065\u002e");
return []byte {},nil ;};_egdb :=_ba .NewReader (encoded );_dea ,_aeg :=_a .NewReader (_egdb );if _aeg !=nil {_gb .Log .Debug ("\u0044e\u0063o\u0064\u0069\u006e\u0067\u0020e\u0072\u0072o\u0072\u0020\u0025\u0076\u000a",_aeg );_gb .Log .Debug ("\u0053t\u0072e\u0061\u006d\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (encoded ),encoded );
return nil ,_aeg ;};defer _dea .Close ();var _cbc _ba .Buffer ;_cbc .ReadFrom (_dea );return _cbc .Bytes (),nil ;};type xrefType int ;

// WriteString outputs the object as it is to be written to file.
func (_fdae *PdfObjectDictionary )WriteString ()string {var _cgbb _cc .Builder ;_cgbb .WriteString ("\u003c\u003c");for _ ,_ecfb :=range _fdae ._cgcf {_bfff :=_fdae ._egfe [_ecfb ];_cgbb .WriteString (_ecfb .WriteString ());_cgbb .WriteString ("\u0020");
_cgbb .WriteString (_bfff .WriteString ());};_cgbb .WriteString ("\u003e\u003e");return _cgbb .String ();};

// ToIntegerArray returns a slice of all array elements as an int slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_ddgb *PdfObjectArray )ToIntegerArray ()([]int ,error ){var _gdadd []int ;for _ ,_dadae :=range _ddgb .Elements (){if _febg ,_agada :=_dadae .(*PdfObjectInteger );_agada {_gdadd =append (_gdadd ,int (*_febg ));}else {return nil ,ErrTypeError ;};};
return _gdadd ,nil ;};

// NewCCITTFaxEncoder makes a new CCITTFax encoder.
func NewCCITTFaxEncoder ()*CCITTFaxEncoder {return &CCITTFaxEncoder {Columns :1728,EndOfBlock :true }};func (_daaa *offsetReader )Seek (offset int64 ,whence int )(int64 ,error ){if whence ==_ed .SeekStart {offset +=_daaa ._acbb ;};_aceab ,_cgaac :=_daaa ._aec .Seek (offset ,whence );
if _cgaac !=nil {return _aceab ,_cgaac ;};if whence ==_ed .SeekCurrent {_aceab -=_daaa ._acbb ;};if _aceab < 0{return 0,_f .New ("\u0063\u006f\u0072\u0065\u002eo\u0066\u0066\u0073\u0065\u0074\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053e\u0065\u006b\u003a\u0020\u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e");
};return _aceab ,nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_cfd *LZWEncoder )MakeStreamDict ()*PdfObjectDictionary {_dee :=MakeDict ();_dee .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_cfd .GetFilterName ()));_cdc :=_cfd .MakeDecodeParams ();if _cdc !=nil {_dee .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_cdc );
};_dee .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (int64 (_cfd .EarlyChange )));return _dee ;};

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_eaca *RunLengthEncoder )EncodeBytes (data []byte )([]byte ,error ){_bedb :=_ba .NewReader (data );var _aafcf []byte ;var _effaf []byte ;_deab ,_bcgc :=_bedb .ReadByte ();if _bcgc ==_ed .EOF {return []byte {},nil ;}else if _bcgc !=nil {return nil ,_bcgc ;
};_dadb :=1;for {_bcgge ,_ggge :=_bedb .ReadByte ();if _ggge ==_ed .EOF {break ;}else if _ggge !=nil {return nil ,_ggge ;};if _bcgge ==_deab {if len (_effaf )> 0{_effaf =_effaf [:len (_effaf )-1];if len (_effaf )> 0{_aafcf =append (_aafcf ,byte (len (_effaf )-1));
_aafcf =append (_aafcf ,_effaf ...);};_dadb =1;_effaf =[]byte {};};_dadb ++;if _dadb >=127{_aafcf =append (_aafcf ,byte (257-_dadb ),_deab );_dadb =0;};}else {if _dadb > 0{if _dadb ==1{_effaf =[]byte {_deab };}else {_aafcf =append (_aafcf ,byte (257-_dadb ),_deab );
};_dadb =0;};_effaf =append (_effaf ,_bcgge );if len (_effaf )>=127{_aafcf =append (_aafcf ,byte (len (_effaf )-1));_aafcf =append (_aafcf ,_effaf ...);_effaf =[]byte {};};};_deab =_bcgge ;};if len (_effaf )> 0{_aafcf =append (_aafcf ,byte (len (_effaf )-1));
_aafcf =append (_aafcf ,_effaf ...);}else if _dadb > 0{_aafcf =append (_aafcf ,byte (257-_dadb ),_deab );};_aafcf =append (_aafcf ,128);return _aafcf ,nil ;};

// IsNullObject returns true if `obj` is a PdfObjectNull.
func IsNullObject (obj PdfObject )bool {_ ,_gcdf :=TraceToDirectObject (obj ).(*PdfObjectNull );return _gcdf ;};func (_fde *FlateEncoder )postDecodePredict (_gccc []byte )([]byte ,error ){if _fde .Predictor > 1{if _fde .Predictor ==2{_gb .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");
_gb .Log .Trace ("\u0043\u006f\u006c\u006f\u0072\u0073\u003a\u0020\u0025\u0064",_fde .Colors );_accg :=_fde .Columns *_fde .Colors ;if _accg < 1{return []byte {},nil ;};_dega :=len (_gccc )/_accg ;if len (_gccc )%_accg !=0{_gb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");
return nil ,_be .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_gccc ),_accg );};if _accg %_fde .Colors !=0{return nil ,_be .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_accg ,_fde .Colors );
};if _accg > len (_gccc ){_gb .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_accg ,len (_gccc ));
return nil ,_f .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_gb .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_gccc ),_gccc );
_cecg :=_ba .NewBuffer (nil );for _cdad :=0;_cdad < _dega ;_cdad ++{_abfb :=_gccc [_accg *_cdad :_accg *(_cdad +1)];for _gccg :=_fde .Colors ;_gccg < _accg ;_gccg ++{_abfb [_gccg ]+=_abfb [_gccg -_fde .Colors ];};_cecg .Write (_abfb );};_fgee :=_cecg .Bytes ();
_gb .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_fgee ),_fgee );return _fgee ,nil ;}else if _fde .Predictor >=10&&_fde .Predictor <=15{_gb .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");
_cdea :=_fde .Columns *_fde .Colors +1;_ccdd :=len (_gccc )/_cdea ;if len (_gccc )%_cdea !=0{return nil ,_be .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_gccc ),_cdea );
};if _cdea > len (_gccc ){_gb .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_cdea ,len (_gccc ));
return nil ,_f .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_fega :=_ba .NewBuffer (nil );_gb .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_fde .Columns );
_gb .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_gccc ),_cdea ,_ccdd );_eccb :=make ([]byte ,_cdea );for _fdfe :=0;_fdfe < _cdea ;_fdfe ++{_eccb [_fdfe ]=0;
};_dggb :=_fde .Colors ;for _cdbf :=0;_cdbf < _ccdd ;_cdbf ++{_faaad :=_gccc [_cdea *_cdbf :_cdea *(_cdbf +1)];_abdf :=_faaad [0];switch _abdf {case _feff :case _dcc :for _cdef :=1+_dggb ;_cdef < _cdea ;_cdef ++{_faaad [_cdef ]+=_faaad [_cdef -_dggb ];
};case _ccf :for _eeg :=1;_eeg < _cdea ;_eeg ++{_faaad [_eeg ]+=_eccb [_eeg ];};case _aca :for _bdf :=1;_bdf < _dggb +1;_bdf ++{_faaad [_bdf ]+=_eccb [_bdf ]/2;};for _eggb :=_dggb +1;_eggb < _cdea ;_eggb ++{_faaad [_eggb ]+=byte ((int (_faaad [_eggb -_dggb ])+int (_eccb [_eggb ]))/2);
};case _abe :for _cedb :=1;_cedb < _cdea ;_cedb ++{var _dgdc ,_bacf ,_eae byte ;_bacf =_eccb [_cedb ];if _cedb >=_dggb +1{_dgdc =_faaad [_cedb -_dggb ];_eae =_eccb [_cedb -_dggb ];};_faaad [_cedb ]+=_agaf (_dgdc ,_bacf ,_eae );};default:_gb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029\u0020\u0040\u0072o\u0077\u0020\u0025\u0064",_abdf ,_cdbf );
return nil ,_be .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_abdf );};copy (_eccb ,_faaad );_fega .Write (_faaad [1:]);};_gfgb :=_fega .Bytes ();return _gfgb ,nil ;
}else {_gb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_fde .Predictor );return nil ,_be .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_fde .Predictor );
};};return _gccc ,nil ;};func (_aed *PdfCrypt )authenticate (_dgee []byte )(bool ,error ){_aed ._bda =false ;_efb :=_aed .securityHandler ();_cedg ,_bdb ,_gdgg :=_efb .Authenticate (&_aed ._bgf ,_dgee );if _gdgg !=nil {return false ,_gdgg ;}else if _bdb ==0||len (_cedg )==0{return false ,nil ;
};_aed ._bda =true ;_aed ._ada =_cedg ;return true ,nil ;};

// DecodeStream returns the passed in stream as a slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_gege *RawEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return streamObj .Stream ,nil ;};func (_acff *PdfParser )parseLinearizedDictionary ()(*PdfObjectDictionary ,error ){_fgaa ,_ffee :=_acff ._ffaf .Seek (0,_ed .SeekEnd );
if _ffee !=nil {return nil ,_ffee ;};var _fgbb int64 ;var _ccec int64 =2048;for _fgbb < _fgaa -4{if _fgaa <=(_ccec +_fgbb ){_ccec =_fgaa -_fgbb ;};_ ,_gfge :=_acff ._ffaf .Seek (_fgbb ,_ed .SeekStart );if _gfge !=nil {return nil ,_gfge ;};_eeef :=make ([]byte ,_ccec );
_ ,_gfge =_acff ._ffaf .Read (_eeef );if _gfge !=nil {return nil ,_gfge ;};_gb .Log .Trace ("\u004c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0066i\u0072\u0073\u0074\u0020\u0069\u006ed\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u003a \u0022\u0025\u0073\u0022",string (_eeef ));
_gbfgf :=_effe .FindAllStringIndex (string (_eeef ),-1);if _gbfgf !=nil {_adagf :=_gbfgf [0];_gb .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_gbfgf );_ ,_cecf :=_acff ._ffaf .Seek (int64 (_adagf [0]),_ed .SeekStart );if _cecf !=nil {return nil ,_cecf ;
};_acff ._eecd =_fg .NewReader (_acff ._ffaf );_bbce ,_cecf :=_acff .ParseIndirectObject ();if _cecf !=nil {return nil ,nil ;};if _fcea ,_ebg :=GetIndirect (_bbce );_ebg {if _cddgg ,_fdfa :=GetDict (_fcea .PdfObject );_fdfa {if _eagf :=_cddgg .Get ("\u004c\u0069\u006e\u0065\u0061\u0072\u0069\u007a\u0065\u0064");
_eagf !=nil {return _cddgg ,nil ;};return nil ,nil ;};};return nil ,nil ;};_fgbb +=_ccec -4;};return nil ,_f .New ("\u0074\u0068\u0065\u0020\u0066\u0069\u0072\u0073\u0074\u0020\u006fb\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0066o\u0075\u006e\u0064");
};func _face (_cdbfd *PdfObjectStream )(*MultiEncoder ,error ){_bffb :=NewMultiEncoder ();_bbae :=_cdbfd .PdfObjectDictionary ;if _bbae ==nil {return _bffb ,nil ;};var _eceeg *PdfObjectDictionary ;var _edef []PdfObject ;_ceec :=_bbae .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");
if _ceec !=nil {_gegef ,_bbfbb :=_ceec .(*PdfObjectDictionary );if _bbfbb {_eceeg =_gegef ;};_gacd ,_bada :=_ceec .(*PdfObjectArray );if _bada {for _ ,_cbfb :=range _gacd .Elements (){_cbfb =TraceToDirectObject (_cbfb );if _bgaa ,_dadbg :=_cbfb .(*PdfObjectDictionary );
_dadbg {_edef =append (_edef ,_bgaa );}else {_edef =append (_edef ,MakeDict ());};};};};_ceec =_bbae .Get ("\u0046\u0069\u006c\u0074\u0065\u0072");if _ceec ==nil {return nil ,_be .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u006d\u0069s\u0073\u0069\u006e\u0067");
};_debd ,_cefb :=_ceec .(*PdfObjectArray );if !_cefb {return nil ,_be .Errorf ("m\u0075\u006c\u0074\u0069\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0063\u0061\u006e\u0020\u006f\u006el\u0079\u0020\u0062\u0065\u0020\u006d\u0061\u0064\u0065\u0020fr\u006f\u006d\u0020a\u0072r\u0061\u0079");
};for _dagc ,_adde :=range _debd .Elements (){_cdgc ,_bcdga :=_adde .(*PdfObjectName );if !_bcdga {return nil ,_be .Errorf ("\u006d\u0075l\u0074\u0069\u0020\u0066i\u006c\u0074e\u0072\u0020\u0061\u0072\u0072\u0061\u0079\u0020e\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u006e\u006f\u0074\u0020\u0061 \u006e\u0061\u006d\u0065");
};var _gbab PdfObject ;if _eceeg !=nil {_gbab =_eceeg ;}else {if len (_edef )> 0{if _dagc >=len (_edef ){return nil ,_be .Errorf ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0073\u0020\u0069\u006e\u0020d\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006d\u0073\u0020a\u0072\u0072\u0061\u0079");
};_gbab =_edef [_dagc ];};};var _dgbg *PdfObjectDictionary ;if _aeded ,_efba :=_gbab .(*PdfObjectDictionary );_efba {_dgbg =_aeded ;};_gb .Log .Trace ("\u004e\u0065\u0078t \u006e\u0061\u006d\u0065\u003a\u0020\u0025\u0073\u002c \u0064p\u003a \u0025v\u002c\u0020\u0064\u0050\u0061\u0072\u0061\u006d\u0073\u003a\u0020\u0025\u0076",*_cdgc ,_gbab ,_dgbg );
if *_cdgc ==StreamEncodingFilterNameFlate {_fefa ,_gcea :=_faf (_cdbfd ,_dgbg );if _gcea !=nil {return nil ,_gcea ;};_bffb .AddEncoder (_fefa );}else if *_cdgc ==StreamEncodingFilterNameLZW {_afc ,_bbca :=_dfga (_cdbfd ,_dgbg );if _bbca !=nil {return nil ,_bbca ;
};_bffb .AddEncoder (_afc );}else if *_cdgc ==StreamEncodingFilterNameASCIIHex {_ega :=NewASCIIHexEncoder ();_bffb .AddEncoder (_ega );}else if *_cdgc ==StreamEncodingFilterNameASCII85 {_gcdg :=NewASCII85Encoder ();_bffb .AddEncoder (_gcdg );}else if *_cdgc ==StreamEncodingFilterNameDCT {_afgg ,_cdcb :=_dddc (_cdbfd ,_bffb );
if _cdcb !=nil {return nil ,_cdcb ;};_bffb .AddEncoder (_afgg );_gb .Log .Trace ("A\u0064d\u0065\u0064\u0020\u0044\u0043\u0054\u0020\u0065n\u0063\u006f\u0064\u0065r.\u002e\u002e");_gb .Log .Trace ("\u004du\u006ct\u0069\u0020\u0065\u006e\u0063o\u0064\u0065r\u003a\u0020\u0025\u0023\u0076",_bffb );
}else if *_cdgc ==StreamEncodingFilterNameCCITTFax {_gfdc ,_egge :=_cecgb (_cdbfd ,_dgbg );if _egge !=nil {return nil ,_egge ;};_bffb .AddEncoder (_gfdc );}else {_gb .Log .Error ("U\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0066\u0069l\u0074\u0065\u0072\u0020\u0025\u0073",*_cdgc );
return nil ,_be .Errorf ("\u0069\u006eva\u006c\u0069\u0064 \u0066\u0069\u006c\u0074er \u0069n \u006d\u0075\u006c\u0074\u0069\u0020\u0066il\u0074\u0065\u0072\u0020\u0061\u0072\u0072a\u0079");};};return _bffb ,nil ;};

// Seek implementation of Seek interface.
func (_gadc *limitedReadSeeker )Seek (offset int64 ,whence int )(int64 ,error ){var _cgeb int64 ;switch whence {case _ed .SeekStart :_cgeb =offset ;case _ed .SeekCurrent :_dgag ,_aecb :=_gadc ._gbcf .Seek (0,_ed .SeekCurrent );if _aecb !=nil {return 0,_aecb ;
};_cgeb =_dgag +offset ;case _ed .SeekEnd :_cgeb =_gadc ._fcacg +offset ;};if _aaad :=_gadc .getError (_cgeb );_aaad !=nil {return 0,_aaad ;};if _ ,_aaddf :=_gadc ._gbcf .Seek (_cgeb ,_ed .SeekStart );_aaddf !=nil {return 0,_aaddf ;};return _cgeb ,nil ;
};

// UpdateParams updates the parameter values of the encoder.
func (_bcfg *RunLengthEncoder )UpdateParams (params *PdfObjectDictionary ){};

// DecodeStream decodes a FlateEncoded stream object and give back decoded bytes.
func (_abc *FlateEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_gb .Log .Trace ("\u0046l\u0061t\u0065\u0044\u0065\u0063\u006fd\u0065\u0020s\u0074\u0072\u0065\u0061\u006d");_gb .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_abc .Predictor );
if _abc .BitsPerComponent !=8{return nil ,_be .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003d\u0025\u0064\u0020\u0028\u006f\u006e\u006c\u0079\u0020\u0038\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0029",_abc .BitsPerComponent );
};_ace ,_befd :=_abc .DecodeBytes (streamObj .Stream );if _befd !=nil {return nil ,_befd ;};_ace ,_befd =_abc .postDecodePredict (_ace );if _befd !=nil {return nil ,_befd ;};return _ace ,nil ;};

// PdfObjectStreams represents the primitive PDF object streams.
// 7.5.7 Object Streams (page 45).
type PdfObjectStreams struct{PdfObjectReference ;_ffcdf []PdfObject ;};

// PdfObjectString represents the primitive PDF string object.
type PdfObjectString struct{_fddd string ;_gcadg bool ;};var _acbc =_d .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064+\u0029\u005c\u0073\u002b\u0028\u005b\u006e\u0066\u005d\u0029\\\u0073\u002a\u0024");const _bcfae =32<<(^uint (0)>>63);
var _bddb =_d .MustCompile ("\u0025\u0025\u0045\u004f\u0046\u003f");func _bcaf (_dafc *PdfObjectDictionary )(_ecfcb *_fe .ImageBase ){var (_acfd *PdfObjectInteger ;_ffabc bool ;);if _acfd ,_ffabc =_dafc .Get ("\u0057\u0069\u0064t\u0068").(*PdfObjectInteger );
_ffabc {_ecfcb =&_fe .ImageBase {Width :int (*_acfd )};}else {return nil ;};if _acfd ,_ffabc =_dafc .Get ("\u0048\u0065\u0069\u0067\u0068\u0074").(*PdfObjectInteger );_ffabc {_ecfcb .Height =int (*_acfd );};if _acfd ,_ffabc =_dafc .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074").(*PdfObjectInteger );
_ffabc {_ecfcb .BitsPerComponent =int (*_acfd );};if _acfd ,_ffabc =_dafc .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073").(*PdfObjectInteger );_ffabc {_ecfcb .ColorComponents =int (*_acfd );};return _ecfcb ;};

// GetUpdatedObjects returns pdf objects which were updated from the specific version (from prevParser).
func (_ccage *PdfParser )GetUpdatedObjects (prevParser *PdfParser )(map[int64 ]PdfObject ,error ){if prevParser ==nil {return nil ,_f .New ("\u0070\u0072e\u0076\u0069\u006f\u0075\u0073\u0020\u0070\u0061\u0072\u0073\u0065\u0072\u0020\u0063\u0061\u006e\u0027\u0074\u0020\u0062\u0065\u0020nu\u006c\u006c");
};_afbeb ,_ffdfa :=_ccage .getNumbersOfUpdatedObjects (prevParser );if _ffdfa !=nil {return nil ,_ffdfa ;};_edbb :=make (map[int64 ]PdfObject );for _ ,_fcbf :=range _afbeb {if _aeaba ,_afcb :=_ccage .LookupByNumber (_fcbf );_afcb ==nil {_edbb [int64 (_fcbf )]=_aeaba ;
}else {return nil ,_afcb ;};};return _edbb ,nil ;};

// GetFilterName returns the names of the underlying encoding filters,
// separated by spaces.
// Note: This is just a string, should not be used in /Filter dictionary entry. Use GetFilterArray for that.
// TODO(v4): Refactor to GetFilter() which can be used for /Filter (either Name or Array), this can be
//  renamed to String() as a pretty string to use in debugging etc.
func (_ddab *MultiEncoder )GetFilterName ()string {_fcbd :="";for _eggg ,_ggbe :=range _ddab ._fbgeg {_fcbd +=_ggbe .GetFilterName ();if _eggg < len (_ddab ._fbgeg )-1{_fcbd +="\u0020";};};return _fcbd ;};

// UpdateParams updates the parameter values of the encoder.
func (_ecbf *RawEncoder )UpdateParams (params *PdfObjectDictionary ){};

// Decoded returns the PDFDocEncoding or UTF-16BE decoded string contents.
// UTF-16BE is applied when the first two bytes are 0xFE, 0XFF, otherwise decoding of
// PDFDocEncoding is performed.
func (_geeg *PdfObjectString )Decoded ()string {if _geeg ==nil {return "";};_dddg :=[]byte (_geeg ._fddd );if len (_dddg )>=2&&_dddg [0]==0xFE&&_dddg [1]==0xFF{return _db .UTF16ToString (_dddg [2:]);};return _db .PDFDocEncodingToString (_dddg );};

// UpdateParams updates the parameter values of the encoder.
// Implements StreamEncoder interface.
func (_addd *JBIG2Encoder )UpdateParams (params *PdfObjectDictionary ){_afff ,_bfc :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _bfc ==nil {_addd .BitsPerComponent =int (_afff );
};_dgdga ,_bfc :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _bfc ==nil {_addd .Width =int (_dgdga );};_cdgga ,_bfc :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _bfc ==nil {_addd .Height =int (_cdgga );
};_cgac ,_bfc :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _bfc ==nil {_addd .ColorComponents =int (_cgac );};};