//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package core defines and implements the primitive PDF object types in golang, and provides functionality
// for parsing those from a PDF file stream. This includes I/O handling, cross references, repairs, encryption,
// encoding and other core capabilities.
package core ;import (_b "bufio";_dd "bytes";_ee "compress/lzw";_gfd "compress/zlib";_gc "crypto/md5";_cb "crypto/rand";_fe "encoding/hex";_fb "errors";_af "fmt";_fdf "github.com/unidoc/unipdf/v3/common";_ge "github.com/unidoc/unipdf/v3/core/security";
_gd "github.com/unidoc/unipdf/v3/core/security/crypt";_ac "github.com/unidoc/unipdf/v3/internal/ccittfax";_gb "github.com/unidoc/unipdf/v3/internal/imageutil";_cea "github.com/unidoc/unipdf/v3/internal/jbig2";_ddb "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";
_gge "github.com/unidoc/unipdf/v3/internal/jbig2/decoder";_ga "github.com/unidoc/unipdf/v3/internal/jbig2/document";_de "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_ce "github.com/unidoc/unipdf/v3/internal/strutils";_cd "golang.org/x/image/tiff/lzw";
_bg "golang.org/x/xerrors";_fg "image";_aa "image/color";_dc "image/jpeg";_gg "io";_gf "io/ioutil";_g "reflect";_c "regexp";_d "sort";_a "strconv";_eaa "strings";_fd "sync";_ea "time";_e "unicode";);

// GetNumberAsFloat returns the contents of `obj` as a float if it is an integer or float, or an
// error if it isn't.
func GetNumberAsFloat (obj PdfObject )(float64 ,error ){switch _becfb :=obj .(type ){case *PdfObjectFloat :return float64 (*_becfb ),nil ;case *PdfObjectInteger :return float64 (*_becfb ),nil ;};return 0,ErrNotANumber ;};func _bccgb (_gcff *PdfObjectStream )(*MultiEncoder ,error ){_dacba :=NewMultiEncoder ();
_bgac :=_gcff .PdfObjectDictionary ;if _bgac ==nil {return _dacba ,nil ;};var _gabg *PdfObjectDictionary ;var _fgef []PdfObject ;_dcab :=_bgac .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _dcab !=nil {_fggd ,_bae :=_dcab .(*PdfObjectDictionary );
if _bae {_gabg =_fggd ;};_bfeb ,_acdc :=_dcab .(*PdfObjectArray );if _acdc {for _ ,_eggbf :=range _bfeb .Elements (){_eggbf =TraceToDirectObject (_eggbf );if _abbgb ,_dfgd :=_eggbf .(*PdfObjectDictionary );_dfgd {_fgef =append (_fgef ,_abbgb );}else {_fgef =append (_fgef ,MakeDict ());
};};};};_dcab =_bgac .Get ("\u0046\u0069\u006c\u0074\u0065\u0072");if _dcab ==nil {return nil ,_af .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u006d\u0069s\u0073\u0069\u006e\u0067");};_dgac ,_cbcbb :=_dcab .(*PdfObjectArray );if !_cbcbb {return nil ,_af .Errorf ("m\u0075\u006c\u0074\u0069\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0063\u0061\u006e\u0020\u006f\u006el\u0079\u0020\u0062\u0065\u0020\u006d\u0061\u0064\u0065\u0020fr\u006f\u006d\u0020a\u0072r\u0061\u0079");
};for _dfdg ,_eegde :=range _dgac .Elements (){_dbbg ,_gagac :=_eegde .(*PdfObjectName );if !_gagac {return nil ,_af .Errorf ("\u006d\u0075l\u0074\u0069\u0020\u0066i\u006c\u0074e\u0072\u0020\u0061\u0072\u0072\u0061\u0079\u0020e\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u006e\u006f\u0074\u0020\u0061 \u006e\u0061\u006d\u0065");
};var _abaa PdfObject ;if _gabg !=nil {_abaa =_gabg ;}else {if len (_fgef )> 0{if _dfdg >=len (_fgef ){return nil ,_af .Errorf ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0073\u0020\u0069\u006e\u0020d\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006d\u0073\u0020a\u0072\u0072\u0061\u0079");
};_abaa =_fgef [_dfdg ];};};var _eagd *PdfObjectDictionary ;if _dcfd ,_dbggf :=_abaa .(*PdfObjectDictionary );_dbggf {_eagd =_dcfd ;};_fdf .Log .Trace ("\u004e\u0065\u0078t \u006e\u0061\u006d\u0065\u003a\u0020\u0025\u0073\u002c \u0064p\u003a \u0025v\u002c\u0020\u0064\u0050\u0061\u0072\u0061\u006d\u0073\u003a\u0020\u0025\u0076",*_dbbg ,_abaa ,_eagd );
if *_dbbg ==StreamEncodingFilterNameFlate {_gadc ,_fgfb :=_dgfa (_gcff ,_eagd );if _fgfb !=nil {return nil ,_fgfb ;};_dacba .AddEncoder (_gadc );}else if *_dbbg ==StreamEncodingFilterNameLZW {_gade ,_geda :=_dcafe (_gcff ,_eagd );if _geda !=nil {return nil ,_geda ;
};_dacba .AddEncoder (_gade );}else if *_dbbg ==StreamEncodingFilterNameASCIIHex {_ddg :=NewASCIIHexEncoder ();_dacba .AddEncoder (_ddg );}else if *_dbbg ==StreamEncodingFilterNameASCII85 {_ecbg :=NewASCII85Encoder ();_dacba .AddEncoder (_ecbg );}else if *_dbbg ==StreamEncodingFilterNameDCT {_fdad ,_fggf :=_gfc (_gcff ,_dacba );
if _fggf !=nil {return nil ,_fggf ;};_dacba .AddEncoder (_fdad );_fdf .Log .Trace ("A\u0064d\u0065\u0064\u0020\u0044\u0043\u0054\u0020\u0065n\u0063\u006f\u0064\u0065r.\u002e\u002e");_fdf .Log .Trace ("\u004du\u006ct\u0069\u0020\u0065\u006e\u0063o\u0064\u0065r\u003a\u0020\u0025\u0023\u0076",_dacba );
}else if *_dbbg ==StreamEncodingFilterNameCCITTFax {_efgc ,_cgba :=_edcb (_gcff ,_eagd );if _cgba !=nil {return nil ,_cgba ;};_dacba .AddEncoder (_efgc );}else {_fdf .Log .Error ("U\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0066\u0069l\u0074\u0065\u0072\u0020\u0025\u0073",*_dbbg );
return nil ,_af .Errorf ("\u0069\u006eva\u006c\u0069\u0064 \u0066\u0069\u006c\u0074er \u0069n \u006d\u0075\u006c\u0074\u0069\u0020\u0066il\u0074\u0065\u0072\u0020\u0061\u0072\u0072a\u0079");};};return _dacba ,nil ;};var _fdaa =[]byte ("\u0030\u0031\u0032\u003345\u0036\u0037\u0038\u0039\u0061\u0062\u0063\u0064\u0065\u0066\u0041\u0042\u0043\u0044E\u0046");
func (_ded *PdfCrypt )saveCryptFilters (_aaaa *PdfObjectDictionary )error {if _ded ._cbc .V < 4{return _fb .New ("\u0063\u0061\u006e\u0020\u006f\u006e\u006c\u0079\u0020\u0062\u0065 \u0075\u0073\u0065\u0064\u0020\u0077\u0069\u0074\u0068\u0020V\u003e\u003d\u0034");
};_dbca :=MakeDict ();_aaaa .Set ("\u0043\u0046",_dbca );for _dbg ,_cag :=range _ded ._bafb {if _dbg =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{continue ;};_afbb :=_fge (_cag ,"");_dbca .Set (PdfObjectName (_dbg ),_afbb );};_aaaa .Set ("\u0053\u0074\u0072\u0046",MakeName (_ded ._egg ));
_aaaa .Set ("\u0053\u0074\u006d\u0046",MakeName (_ded ._afb ));return nil ;};

// ReadBytesAt reads byte content at specific offset and length within the PDF.
func (_dfbb *PdfParser )ReadBytesAt (offset ,len int64 )([]byte ,error ){_cccd :=_dfbb .GetFileOffset ();_ ,_egdd :=_dfbb ._cgda .Seek (offset ,_gg .SeekStart );if _egdd !=nil {return nil ,_egdd ;};_gbgc :=make ([]byte ,len );_ ,_egdd =_gg .ReadAtLeast (_dfbb ._cgda ,_gbgc ,int (len ));
if _egdd !=nil {return nil ,_egdd ;};_dfbb .SetFileOffset (_cccd );return _gbgc ,nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_cba *FlateEncoder )MakeDecodeParams ()PdfObject {if _cba .Predictor > 1{_feef :=MakeDict ();_feef .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_cba .Predictor )));if _cba .BitsPerComponent !=8{_feef .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_cba .BitsPerComponent )));
};if _cba .Columns !=1{_feef .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_cba .Columns )));};if _cba .Colors !=1{_feef .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_cba .Colors )));};return _feef ;};return nil ;
};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_gaa *LZWEncoder )MakeDecodeParams ()PdfObject {if _gaa .Predictor > 1{_feaf :=MakeDict ();_feaf .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_gaa .Predictor )));if _gaa .BitsPerComponent !=8{_feaf .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_gaa .BitsPerComponent )));
};if _gaa .Columns !=1{_feaf .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_gaa .Columns )));};if _gaa .Colors !=1{_feaf .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_gaa .Colors )));};return _feaf ;};return nil ;
};const _cddc =6;

// PdfObjectNull represents the primitive PDF null object.
type PdfObjectNull struct{};

// WriteString outputs the object as it is to be written to file.
func (_facf *PdfObjectStreams )WriteString ()string {var _gdcee _eaa .Builder ;_gdcee .WriteString (_a .FormatInt (_facf .ObjectNumber ,10));_gdcee .WriteString ("\u0020\u0030\u0020\u0052");return _gdcee .String ();};func (_feca *PdfParser )parseNull ()(PdfObjectNull ,error ){_ ,_gcbge :=_feca ._fbgde .Discard (4);
return PdfObjectNull {},_gcbge ;};

// Set sets the PdfObject at index i of the streams. An error is returned if the index is outside bounds.
func (_cefc *PdfObjectStreams )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_cefc ._aagf ){return _fb .New ("\u004f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_cefc ._aagf [i ]=obj ;return nil ;};

// DecodeBytes decodes a byte slice from Run length encoding.
//
// 7.4.5 RunLengthDecode Filter
// The RunLengthDecode filter decodes data that has been encoded in a simple byte-oriented format based on run length.
// The encoded data shall be a sequence of runs, where each run shall consist of a length byte followed by 1 to 128
// bytes of data. If the length byte is in the range 0 to 127, the following length + 1 (1 to 128) bytes shall be
// copied literally during decompression. If length is in the range 129 to 255, the following single byte shall be
// copied 257 - length (2 to 128) times during decompression. A length value of 128 shall denote EOD.
func (_baba *RunLengthEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_abge :=_dd .NewReader (encoded );var _dcfg []byte ;for {_daea ,_cabd :=_abge .ReadByte ();if _cabd !=nil {return nil ,_cabd ;};if _daea > 128{_ffc ,_bbdf :=_abge .ReadByte ();
if _bbdf !=nil {return nil ,_bbdf ;};for _agea :=0;_agea < 257-int (_daea );_agea ++{_dcfg =append (_dcfg ,_ffc );};}else if _daea < 128{for _ebe :=0;_ebe < int (_daea )+1;_ebe ++{_dabcd ,_cfgba :=_abge .ReadByte ();if _cfgba !=nil {return nil ,_cfgba ;
};_dcfg =append (_dcfg ,_dabcd );};}else {break ;};};return _dcfg ,nil ;};

// GetBoolVal returns the bool value within a *PdObjectBool represented by an PdfObject interface directly or indirectly.
// If the PdfObject does not represent a bool value, a default value of false is returned (found = false also).
func GetBoolVal (obj PdfObject )(_ffceff bool ,_debad bool ){_cfded ,_debad :=TraceToDirectObject (obj ).(*PdfObjectBool );if _debad {return bool (*_cfded ),true ;};return false ,false ;};func _dgfa (_abbg *PdfObjectStream ,_cfae *PdfObjectDictionary )(*FlateEncoder ,error ){_gbbg :=NewFlateEncoder ();
_fece :=_abbg .PdfObjectDictionary ;if _fece ==nil {return _gbbg ,nil ;};_gbbg ._bgdb =_dabd (_fece );if _cfae ==nil {_agf :=TraceToDirectObject (_fece .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));switch _faf :=_agf .(type ){case *PdfObjectArray :if _faf .Len ()!=1{_fdf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072:\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020a\u0072\u0072\u0061\u0079\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0021\u003d\u0020\u0031\u0020\u0028\u0025\u0064\u0029",_faf .Len ());
return nil ,_fb .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};if _ccfb ,_cgbd :=GetDict (_faf .Get (0));_cgbd {_cfae =_ccfb ;};case *PdfObjectDictionary :_cfae =_faf ;case *PdfObjectNull ,nil :default:_fdf .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020n\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079 \u0028%\u0054\u0029",_agf );
return nil ,_af .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _cfae ==nil {return _gbbg ,nil ;};_fdf .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_cfae .String ());
_gfbe :=_cfae .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");if _gfbe ==nil {_fdf .Log .Debug ("E\u0072\u0072o\u0072\u003a\u0020\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067 \u0066\u0072\u006f\u006d\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073 \u002d\u0020\u0043\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020\u0077\u0069t\u0068\u0020\u0064\u0065\u0066\u0061\u0075\u006c\u0074\u0020\u00281\u0029");
}else {_cdba ,_bbgg :=_gfbe .(*PdfObjectInteger );if !_bbgg {_fdf .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_gfbe );
return nil ,_af .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_gbbg .Predictor =int (*_cdba );};_gfbe =_cfae .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");
if _gfbe !=nil {_feec ,_cdag :=_gfbe .(*PdfObjectInteger );if !_cdag {_fdf .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");
return nil ,_af .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_gbbg .BitsPerComponent =int (*_feec );};if _gbbg .Predictor > 1{_gbbg .Columns =1;_gfbe =_cfae .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");
if _gfbe !=nil {_ecd ,_gee :=_gfbe .(*PdfObjectInteger );if !_gee {return nil ,_af .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_gbbg .Columns =int (*_ecd );
};_gbbg .Colors =1;_gfbe =_cfae .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _gfbe !=nil {_cgge ,_edf :=_gfbe .(*PdfObjectInteger );if !_edf {return nil ,_af .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");
};_gbbg .Colors =int (*_cgge );};};return _gbbg ,nil ;};func _accd (_cfad int )int {if _cfad < 0{return -_cfad ;};return _cfad ;};

// NewDCTEncoder makes a new DCT encoder with default parameters.
func NewDCTEncoder ()*DCTEncoder {_dfeg :=&DCTEncoder {};_dfeg .ColorComponents =3;_dfeg .BitsPerComponent =8;_dfeg .Quality =DefaultJPEGQuality ;return _dfeg ;};const JB2ImageAutoThreshold =-1.0;

// ParseDict reads and parses a PDF dictionary object enclosed with '<<' and '>>'
func (_egcc *PdfParser )ParseDict ()(*PdfObjectDictionary ,error ){_fdf .Log .Trace ("\u0052\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020D\u0069\u0063\u0074\u0021");_fcba :=MakeDict ();_fcba ._abcg =_egcc ;_dgbg ,_ :=_egcc ._fbgde .ReadByte ();
if _dgbg !='<'{return nil ,_fb .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");};_dgbg ,_ =_egcc ._fbgde .ReadByte ();if _dgbg !='<'{return nil ,_fb .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");
};for {_egcc .skipSpaces ();_egcc .skipComments ();_becge ,_egda :=_egcc ._fbgde .Peek (2);if _egda !=nil {return nil ,_egda ;};_fdf .Log .Trace ("D\u0069c\u0074\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_becge ),string (_becge ));
if (_becge [0]=='>')&&(_becge [1]=='>'){_fdf .Log .Trace ("\u0045\u004f\u0046\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");_egcc ._fbgde .ReadByte ();_egcc ._fbgde .ReadByte ();break ;};_fdf .Log .Trace ("\u0050a\u0072s\u0065\u0020\u0074\u0068\u0065\u0020\u006e\u0061\u006d\u0065\u0021");
_eddg ,_egda :=_egcc .parseName ();_fdf .Log .Trace ("\u004be\u0079\u003a\u0020\u0025\u0073",_eddg );if _egda !=nil {_fdf .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0052e\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006ea\u006d\u0065\u0020e\u0072r\u0020\u0025\u0073",_egda );
return nil ,_egda ;};if len (_eddg )> 4&&_eddg [len (_eddg )-4:]=="\u006e\u0075\u006c\u006c"{_effa :=_eddg [0:len (_eddg )-4];_fdf .Log .Debug ("\u0054\u0061\u006b\u0069n\u0067\u0020\u0063\u0061\u0072\u0065\u0020\u006f\u0066\u0020n\u0075l\u006c\u0020\u0062\u0075\u0067\u0020\u0028%\u0073\u0029",_eddg );
_fdf .Log .Debug ("\u004e\u0065\u0077\u0020ke\u0079\u0020\u0022\u0025\u0073\u0022\u0020\u003d\u0020\u006e\u0075\u006c\u006c",_effa );_egcc .skipSpaces ();_gbgaf ,_ :=_egcc ._fbgde .Peek (1);if _gbgaf [0]=='/'{_fcba .Set (_effa ,MakeNull ());continue ;};
};_egcc .skipSpaces ();_aecd ,_egda :=_egcc .parseObject ();if _egda !=nil {return nil ,_egda ;};_fcba .Set (_eddg ,_aecd );if _fdf .Log .IsLogLevel (_fdf .LogLevelTrace ){_fdf .Log .Trace ("\u0064\u0069\u0063\u0074\u005b\u0025\u0073\u005d\u0020\u003d\u0020\u0025\u0073",_eddg ,_aecd .String ());
};};_fdf .Log .Trace ("\u0072\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020\u0044\u0069\u0063\u0074\u0021");return _fcba ,nil ;};

// Decrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_dga *PdfCrypt )Decrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _dga .isDecrypted (obj ){return nil ;};switch _bbc :=obj .(type ){case *PdfIndirectObject :_dga ._bbd [_bbc ]=true ;_fdf .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_bbc .ObjectNumber ,_bbc .GenerationNumber );
_gfb :=_bbc .ObjectNumber ;_cad :=_bbc .GenerationNumber ;_eee :=_dga .Decrypt (_bbc .PdfObject ,_gfb ,_cad );if _eee !=nil {return _eee ;};return nil ;case *PdfObjectStream :_dga ._bbd [_bbc ]=true ;_eaef :=_bbc .PdfObjectDictionary ;if _dga ._aebg .R !=5{if _gdd ,_edb :=_eaef .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );
_edb &&*_gdd =="\u0058\u0052\u0065\u0066"{return nil ;};};_dbab :=_bbc .ObjectNumber ;_ebd :=_bbc .GenerationNumber ;_fdf .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_dbab ,_ebd );
_dacb :=_cfg ;if _dga ._cbc .V >=4{_dacb =_dga ._afb ;_fdf .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_dga ._afb );if _dbgg ,_gbgb :=_eaef .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );
_gbgb {if _fbc ,_efd :=GetName (_dbgg .Get (0));_efd {if *_fbc =="\u0043\u0072\u0079p\u0074"{_dacb ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _bbcb ,_dcgb :=_eaef .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );
_dcgb {if _daeb ,_aaf :=_bbcb .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_aaf {if _ ,_aebd :=_dga ._bafb [string (*_daeb )];_aebd {_fdf .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_daeb );
_dacb =string (*_daeb );};};};};};};_fdf .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_dacb );if _dacb =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_ebdg :=_dga .Decrypt (_eaef ,_dbab ,_ebd );
if _ebdg !=nil {return _ebdg ;};_fbcc ,_ebdg :=_dga .makeKey (_dacb ,uint32 (_dbab ),uint32 (_ebd ),_dga ._adb );if _ebdg !=nil {return _ebdg ;};_bbc .Stream ,_ebdg =_dga .decryptBytes (_bbc .Stream ,_dacb ,_fbcc );if _ebdg !=nil {return _ebdg ;};_eaef .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_bbc .Stream ))));
return nil ;case *PdfObjectString :_fdf .Log .Trace ("\u0044e\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_cddf :=_cfg ;if _dga ._cbc .V >=4{_fdf .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_dga ._egg );
if _dga ._egg =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_cddf =_dga ._egg ;};_beea ,_gcbe :=_dga .makeKey (_cddf ,uint32 (parentObjNum ),uint32 (parentGenNum ),_dga ._adb );if _gcbe !=nil {return _gcbe ;};_gba :=_bbc .Str ();_abgg :=make ([]byte ,len (_gba ));
for _feb :=0;_feb < len (_gba );_feb ++{_abgg [_feb ]=_gba [_feb ];};if len (_abgg )> 0{_fdf .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_abgg ,_abgg );
_abgg ,_gcbe =_dga .decryptBytes (_abgg ,_cddf ,_beea );if _gcbe !=nil {return _gcbe ;};};_bbc ._eagb =string (_abgg );return nil ;case *PdfObjectArray :for _ ,_bgf :=range _bbc .Elements (){_cab :=_dga .Decrypt (_bgf ,parentObjNum ,parentGenNum );if _cab !=nil {return _cab ;
};};return nil ;case *PdfObjectDictionary :_cdb :=false ;if _bff :=_bbc .Get ("\u0054\u0079\u0070\u0065");_bff !=nil {_ceg ,_deee :=_bff .(*PdfObjectName );if _deee &&*_ceg =="\u0053\u0069\u0067"{_cdb =true ;};};for _ ,_gacc :=range _bbc .Keys (){_adag :=_bbc .Get (_gacc );
if _cdb &&string (_gacc )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;};if string (_gacc )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_gacc )!="\u0050\u0072\u0065\u0076"&&string (_gacc )!="\u004c\u0061\u0073\u0074"{_gada :=_dga .Decrypt (_adag ,parentObjNum ,parentGenNum );
if _gada !=nil {return _gada ;};};};return nil ;};return nil ;};

// XrefTable represents the cross references in a PDF, i.e. the table of objects and information
// where to access within the PDF file.
type XrefTable struct{ObjectMap map[int ]XrefObject ;_be []XrefObject ;};

// DecodeStream decodes the stream data and returns the decoded data.
// An error is returned upon failure.
func DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_fdf .Log .Trace ("\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_ceeba ,_beaea :=NewEncoderFromStream (streamObj );if _beaea !=nil {_fdf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_beaea );
return nil ,_beaea ;};_fdf .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076\u000a",_ceeba );_geff ,_beaea :=_ceeba .DecodeStream (streamObj );if _beaea !=nil {_fdf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_beaea );
return nil ,_beaea ;};return _geff ,nil ;};

// ParseIndirectObject parses an indirect object from the input stream. Can also be an object stream.
// Returns the indirect object (*PdfIndirectObject) or the stream object (*PdfObjectStream).
func (_afdf *PdfParser )ParseIndirectObject ()(PdfObject ,error ){_cdcd :=PdfIndirectObject {};_cdcd ._gdad =_afdf ;_fdf .Log .Trace ("\u002dR\u0065a\u0064\u0020\u0069\u006e\u0064i\u0072\u0065c\u0074\u0020\u006f\u0062\u006a");_bceab ,_afcf :=_afdf ._fbgde .Peek (20);
if _afcf !=nil {if _afcf !=_gg .EOF {_fdf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020r\u0065a\u0064\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a");return &_cdcd ,_afcf ;
};};_fdf .Log .Trace ("\u0028\u0069\u006edi\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_bceab ));_bbfe :=_bafbb .FindStringSubmatchIndex (string (_bceab ));if len (_bbfe )< 6{if _afcf ==_gg .EOF {return nil ,_afcf ;
};_fdf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_bceab ));
return &_cdcd ,_fb .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");
};_afdf ._fbgde .Discard (_bbfe [0]);_fdf .Log .Trace ("O\u0066\u0066\u0073\u0065\u0074\u0073\u0020\u0025\u0020\u0064",_bbfe );_efcg :=_bbfe [1]-_bbfe [0];_dcfee :=make ([]byte ,_efcg );_ ,_afcf =_afdf .ReadAtLeast (_dcfee ,_efcg );if _afcf !=nil {_fdf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u0072\u0065\u0061\u0064\u0020-\u0020\u0025\u0073",_afcf );
return nil ,_afcf ;};_fdf .Log .Trace ("\u0074\u0065\u0078t\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_dcfee );_aceg :=_bafbb .FindStringSubmatch (string (_dcfee ));if len (_aceg )< 3{_fdf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_dcfee ));
return &_cdcd ,_fb .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");
};_cbdb ,_ :=_a .Atoi (_aceg [1]);_dcfaa ,_ :=_a .Atoi (_aceg [2]);_cdcd .ObjectNumber =int64 (_cbdb );_cdcd .GenerationNumber =int64 (_dcfaa );for {_gcda ,_afbbg :=_afdf ._fbgde .Peek (2);if _afbbg !=nil {return &_cdcd ,_afbbg ;};_fdf .Log .Trace ("I\u006ed\u002e\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_gcda ),string (_gcda ));
if IsWhiteSpace (_gcda [0]){_afdf .skipSpaces ();}else if _gcda [0]=='%'{_afdf .skipComments ();}else if (_gcda [0]=='<')&&(_gcda [1]=='<'){_fdf .Log .Trace ("\u0043\u0061\u006c\u006c\u0020\u0050\u0061\u0072\u0073e\u0044\u0069\u0063\u0074");_cdcd .PdfObject ,_afbbg =_afdf .ParseDict ();
_fdf .Log .Trace ("\u0045\u004f\u0046\u0020Ca\u006c\u006c\u0020\u0050\u0061\u0072\u0073\u0065\u0044\u0069\u0063\u0074\u003a\u0020%\u0076",_afbbg );if _afbbg !=nil {return &_cdcd ,_afbbg ;};_fdf .Log .Trace ("\u0050\u0061\u0072\u0073\u0065\u0064\u0020\u0064\u0069\u0063t\u0069\u006f\u006e\u0061\u0072\u0079\u002e.\u002e\u0020\u0066\u0069\u006e\u0069\u0073\u0068\u0065\u0064\u002e");
}else if (_gcda [0]=='/')||(_gcda [0]=='(')||(_gcda [0]=='[')||(_gcda [0]=='<'){_cdcd .PdfObject ,_afbbg =_afdf .parseObject ();if _afbbg !=nil {return &_cdcd ,_afbbg ;};_fdf .Log .Trace ("P\u0061\u0072\u0073\u0065\u0064\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u002e\u002e\u002e \u0066\u0069\u006ei\u0073h\u0065\u0064\u002e");
}else if _gcda [0]==']'{_fdf .Log .Debug ("\u0057\u0041\u0052\u004e\u0049N\u0047\u003a\u0020\u0027\u005d\u0027 \u0063\u0068\u0061\u0072\u0061\u0063\u0074e\u0072\u0020\u006eo\u0074\u0020\u0062\u0065i\u006e\u0067\u0020\u0075\u0073\u0065d\u0020\u0061\u0073\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006e\u0064\u0069n\u0067\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e");
_afdf ._fbgde .Discard (1);}else {if _gcda [0]=='e'{_abfcb ,_dffb :=_afdf .readTextLine ();if _dffb !=nil {return nil ,_dffb ;};if len (_abfcb )>=6&&_abfcb [0:6]=="\u0065\u006e\u0064\u006f\u0062\u006a"{break ;};}else if _gcda [0]=='s'{_gcda ,_ =_afdf ._fbgde .Peek (10);
if string (_gcda [:6])=="\u0073\u0074\u0072\u0065\u0061\u006d"{_ageb :=6;if len (_gcda )> 6{if IsWhiteSpace (_gcda [_ageb ])&&_gcda [_ageb ]!='\r'&&_gcda [_ageb ]!='\n'{_fdf .Log .Debug ("\u004e\u006fn\u002d\u0063\u006f\u006e\u0066\u006f\u0072\u006d\u0061\u006e\u0074\u0020\u0050\u0044\u0046\u0020\u006e\u006f\u0074 \u0065\u006e\u0064\u0069\u006e\u0067 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0069\u006e\u0065\u0020\u0070\u0072o\u0070\u0065r\u006c\u0079\u0020\u0077i\u0074\u0068\u0020\u0045\u004fL\u0020\u006d\u0061\u0072\u006b\u0065\u0072");
_afdf ._aadf ._afd =true ;_ageb ++;};if _gcda [_ageb ]=='\r'{_ageb ++;if _gcda [_ageb ]=='\n'{_ageb ++;};}else if _gcda [_ageb ]=='\n'{_ageb ++;}else {_afdf ._aadf ._afd =true ;};};_afdf ._fbgde .Discard (_ageb );_fcdg ,_fbcgc :=_cdcd .PdfObject .(*PdfObjectDictionary );
if !_fbcgc {return nil ,_fb .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006di\u0073s\u0069\u006e\u0067\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_fdf .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0069c\u0074\u0020\u0025\u0073",_fcdg );
_ceba ,_ffce :=_afdf .traceStreamLength (_fcdg .Get ("\u004c\u0065\u006e\u0067\u0074\u0068"));if _ffce !=nil {_fdf .Log .Debug ("\u0046\u0061\u0069l\u0020\u0074\u006f\u0020t\u0072\u0061\u0063\u0065\u0020\u0073\u0074r\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0025\u0076",_ffce );
return nil ,_ffce ;};_fdf .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_ceba );_fgadg ,_bgagb :=_ceba .(*PdfObjectInteger );if !_bgagb {return nil ,_fb .New ("\u0073\u0074re\u0061\u006d\u0020l\u0065\u006e\u0067\u0074h n\u0065ed\u0073\u0020\u0074\u006f\u0020\u0062\u0065 a\u006e\u0020\u0069\u006e\u0074\u0065\u0067e\u0072");
};_aefd :=*_fgadg ;if _aefd < 0{return nil ,_fb .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006e\u0065\u0065\u0064\u0073\u0020\u0074\u006f \u0062e\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0030");};_edae :=_afdf .GetFileOffset ();
_bdbc :=_afdf .xrefNextObjectOffset (_edae );if _edae +int64 (_aefd )> _bdbc &&_bdbc > _edae {_fdf .Log .Debug ("E\u0078\u0070\u0065\u0063te\u0064 \u0065\u006e\u0064\u0069\u006eg\u0020\u0061\u0074\u0020\u0025\u0064",_edae +int64 (_aefd ));_fdf .Log .Debug ("\u004e\u0065\u0078\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020\u0061t\u0020\u0025\u0064",_bdbc );
_abfd :=_bdbc -_edae -17;if _abfd < 0{return nil ,_fb .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020go\u0069\u006e\u0067 \u0070\u0061s\u0074\u0020\u0062\u006f\u0075\u006ed\u0061\u0072i\u0065\u0073");
};_fdf .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0061\u0020l\u0065\u006e\u0067\u0074\u0068\u0020c\u006f\u0072\u0072\u0065\u0063\u0074\u0069\u006f\u006e\u0020\u0074\u006f\u0020%\u0064\u002e\u002e\u002e",_abfd );_aefd =PdfObjectInteger (_abfd );
_fcdg .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (_abfd ));};if int64 (_aefd )> _afdf ._gdgf {_fdf .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0053t\u0072\u0065\u0061\u006d\u0020l\u0065\u006e\u0067\u0074\u0068\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u0061\u0072\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0066\u0069\u006c\u0065\u0020\u0073\u0069\u007a\u0065");
return nil ,_fb .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020la\u0072\u0067\u0065r\u0020\u0074h\u0061\u006e\u0020\u0066\u0069\u006ce\u0020\u0073i\u007a\u0065");};_dgcba :=make ([]byte ,_aefd );
_ ,_ffce =_afdf .ReadAtLeast (_dgcba ,int (_aefd ));if _ffce !=nil {_fdf .Log .Debug ("E\u0052\u0052\u004f\u0052 s\u0074r\u0065\u0061\u006d\u0020\u0028%\u0064\u0029\u003a\u0020\u0025\u0058",len (_dgcba ),_dgcba );_fdf .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_ffce );
return nil ,_ffce ;};_befd :=PdfObjectStream {};_befd .Stream =_dgcba ;_befd .PdfObjectDictionary =_cdcd .PdfObject .(*PdfObjectDictionary );_befd .ObjectNumber =_cdcd .ObjectNumber ;_befd .GenerationNumber =_cdcd .GenerationNumber ;_befd .PdfObjectReference ._gdad =_afdf ;
_afdf .skipSpaces ();_afdf ._fbgde .Discard (9);_afdf .skipSpaces ();return &_befd ,nil ;};};_cdcd .PdfObject ,_afbbg =_afdf .parseObject ();if _cdcd .PdfObject ==nil {_fdf .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");
_cdcd .PdfObject =MakeNull ();};return &_cdcd ,_afbbg ;};};if _cdcd .PdfObject ==nil {_fdf .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");
_cdcd .PdfObject =MakeNull ();};_fdf .Log .Trace ("\u0052\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0021");return &_cdcd ,nil ;};

// DecodeBytes decodes a slice of LZW encoded bytes and returns the result.
func (_cacfd *LZWEncoder )DecodeBytes (encoded []byte )([]byte ,error ){var _dagf _dd .Buffer ;_cbgg :=_dd .NewReader (encoded );var _cdc _gg .ReadCloser ;if _cacfd .EarlyChange ==1{_cdc =_cd .NewReader (_cbgg ,_cd .MSB ,8);}else {_cdc =_ee .NewReader (_cbgg ,_ee .MSB ,8);
};defer _cdc .Close ();if _ ,_bacb :=_dagf .ReadFrom (_cdc );_bacb !=nil {if _bacb !=_gg .ErrUnexpectedEOF ||_dagf .Len ()==0{return nil ,_bacb ;};_fdf .Log .Debug ("\u0057\u0041\u0052\u004e\u003a\u0020\u004c\u005a\u0057\u0020\u0064\u0065\u0063\u006f\u0064i\u006e\u0067\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076\u002e \u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062e \u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u002e",_bacb );
};return _dagf .Bytes (),nil ;};

// ParserMetadata is the parser based metadata information about document.
// The data here could be used on document verification.
type ParserMetadata struct{_gfdf int ;_eaac bool ;_fddb [4]byte ;_fdc bool ;_bffa bool ;_cebe bool ;_afd bool ;_dfde bool ;_bcf bool ;};

// EncodeJBIG2Image encodes 'img' into jbig2 encoded bytes stream, using default encoder settings.
func (_gaf *JBIG2Encoder )EncodeJBIG2Image (img *JBIG2Image )([]byte ,error ){const _eacfb ="c\u006f\u0072\u0065\u002eEn\u0063o\u0064\u0065\u004a\u0042\u0049G\u0032\u0049\u006d\u0061\u0067\u0065";if _cdfg :=_gaf .AddPageImage (img ,&_gaf .DefaultPageSettings );
_cdfg !=nil {return nil ,_de .Wrap (_cdfg ,_eacfb ,"");};return _gaf .Encode ();};

// NewJBIG2Encoder creates a new JBIG2Encoder.
func NewJBIG2Encoder ()*JBIG2Encoder {return &JBIG2Encoder {_bege :_ga .InitEncodeDocument (false )}};

// Inspect analyzes the document object structure. Returns a map of object types (by name) with the instance count
// as value.
func (_ccff *PdfParser )Inspect ()(map[string ]int ,error ){return _ccff .inspect ()};const (XrefTypeTableEntry xrefType =iota ;XrefTypeObjectStream xrefType =iota ;);

// NewParserFromString is used for testing purposes.
func NewParserFromString (txt string )*PdfParser {_ddcc :=_dd .NewReader ([]byte (txt ));_edcc :=&PdfParser {ObjCache :objectCache {},_cgda :_ddcc ,_fbgde :_b .NewReader (_ddcc ),_gdgf :int64 (len (txt )),_ddede :map[int64 ]bool {},_cggc :make (map[*PdfParser ]*PdfParser )};
_edcc ._bfaa .ObjectMap =make (map[int ]XrefObject );return _edcc ;};

// Update updates multiple keys and returns the dictionary back so can be used in a chained fashion.
func (_eaefe *PdfObjectDictionary )Update (objmap map[string ]PdfObject )*PdfObjectDictionary {_eaefe ._dggf .Lock ();defer _eaefe ._dggf .Unlock ();for _febab ,_cgcab :=range objmap {_eaefe .setWithLock (PdfObjectName (_febab ),_cgcab ,false );};return _eaefe ;
};

// Bytes returns the PdfObjectString content as a []byte array.
func (_ebfd *PdfObjectString )Bytes ()[]byte {return []byte (_ebfd ._eagb )};func _dead (_aeeb _gg .ReadSeeker ,_ddac int64 )(*offsetReader ,error ){_cge :=&offsetReader {_ebefg :_aeeb ,_aeed :_ddac };_ ,_facb :=_cge .Seek (0,_gg .SeekStart );return _cge ,_facb ;
};

// HasInvalidHexRunes implements core.ParserMetadata interface.
func (_faad ParserMetadata )HasInvalidHexRunes ()bool {return _faad ._cebe };

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_ebdc *FlateEncoder )EncodeBytes (data []byte )([]byte ,error ){if _ebdc .Predictor !=1&&_ebdc .Predictor !=11{_fdf .Log .Debug ("E\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0046\u006c\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065r\u0020P\u0072\u0065\u0064\u0069c\u0074\u006fr\u0020\u003d\u0020\u0031\u002c\u0020\u0031\u0031\u0020\u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");
return nil ,ErrUnsupportedEncodingParameters ;};if _ebdc .Predictor ==11{_cfgb :=_ebdc .Columns ;_dbf :=len (data )/_cfgb ;if len (data )%_cfgb !=0{_fdf .Log .Error ("\u0049n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");
return nil ,_fb .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");};_eggb :=_dd .NewBuffer (nil );_cfge :=make ([]byte ,_cfgb );for _cfcg :=0;_cfcg < _dbf ;_cfcg ++{_gbe :=data [_cfgb *_cfcg :_cfgb *(_cfcg +1)];
_cfge [0]=_gbe [0];for _cbd :=1;_cbd < _cfgb ;_cbd ++{_cfge [_cbd ]=byte (int (_gbe [_cbd ]-_gbe [_cbd -1])%256);};_eggb .WriteByte (1);_eggb .Write (_cfge );};data =_eggb .Bytes ();};var _cafb _dd .Buffer ;_fdfe :=_gfd .NewWriter (&_cafb );_fdfe .Write (data );
_fdfe .Close ();return _cafb .Bytes (),nil ;};

// WriteString outputs the object as it is to be written to file.
func (_ebffd *PdfObjectString )WriteString ()string {var _aeega _dd .Buffer ;if _ebffd ._gccd {_eacfa :=_fe .EncodeToString (_ebffd .Bytes ());_aeega .WriteString ("\u003c");_aeega .WriteString (_eacfa );_aeega .WriteString ("\u003e");return _aeega .String ();
};_dddf :=map[byte ]string {'\n':"\u005c\u006e",'\r':"\u005c\u0072",'\t':"\u005c\u0074",'\b':"\u005c\u0062",'\f':"\u005c\u0066",'(':"\u005c\u0028",')':"\u005c\u0029",'\\':"\u005c\u005c"};_aeega .WriteString ("\u0028");for _fafbc :=0;_fafbc < len (_ebffd ._eagb );
_fafbc ++{_fead :=_ebffd ._eagb [_fafbc ];if _cegb ,_abcb :=_dddf [_fead ];_abcb {_aeega .WriteString (_cegb );}else {_aeega .WriteByte (_fead );};};_aeega .WriteString ("\u0029");return _aeega .String ();};

// GetRevision returns PdfParser for the specific version of the Pdf document.
func (_efdd *PdfParser )GetRevision (revisionNumber int )(*PdfParser ,error ){_dcffc :=_efdd ._dcgd ;if _dcffc ==revisionNumber {return _efdd ,nil ;};if _dcffc < revisionNumber {return nil ,_fb .New ("\u0075\u006e\u0064\u0065\u0066\u0069\u006e\u0065\u0064\u0020\u0072\u0065\u0076\u0069\u0073i\u006fn\u004e\u0075\u006d\u0062\u0065\u0072\u0020\u0076\u0065\u0072\u0073\u0069\u006f\u006e");
};if _efdd ._geeca [revisionNumber ]!=nil {return _efdd ._geeca [revisionNumber ],nil ;};_dbbe :=_efdd ;for ;_dcffc > revisionNumber ;_dcffc --{_gcad ,_gefb :=_dbbe .GetPreviousRevisionParser ();if _gefb !=nil {return nil ,_gefb ;};_efdd ._geeca [_dcffc -1]=_gcad ;
_efdd ._cggc [_dbbe ]=_gcad ;_dbbe =_gcad ;};return _dbbe ,nil ;};type xrefType int ;var _bafbb =_c .MustCompile ("\u0028\u005c\u0064\u002b)\\\u0073\u002b\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u006f\u0062\u006a");var _eabc =[]PdfObjectName {"\u0056","\u0052","\u004f","\u0055","\u0050"};
func _agfeg (_bgbb _gg .ReadSeeker ,_geee int64 )(*limitedReadSeeker ,error ){_ ,_fgdg :=_bgbb .Seek (0,_gg .SeekStart );if _fgdg !=nil {return nil ,_fgdg ;};return &limitedReadSeeker {_acfb :_bgbb ,_aggf :_geee },nil ;};

// GetFilterName returns the name of the encoding filter.
func (_gagd *LZWEncoder )GetFilterName ()string {return StreamEncodingFilterNameLZW };

// NewASCII85Encoder makes a new ASCII85 encoder.
func NewASCII85Encoder ()*ASCII85Encoder {_efdf :=&ASCII85Encoder {};return _efdf };func (_dag *PdfParser )lookupByNumberWrapper (_cdd int ,_fed bool )(PdfObject ,bool ,error ){_bce ,_eeg ,_aec :=_dag .lookupByNumber (_cdd ,_fed );if _aec !=nil {return nil ,_eeg ,_aec ;
};if !_eeg &&_dag ._adfa !=nil &&_dag ._adfa ._abf &&!_dag ._adfa .isDecrypted (_bce ){_dab :=_dag ._adfa .Decrypt (_bce ,0,0);if _dab !=nil {return nil ,_eeg ,_dab ;};};return _bce ,_eeg ,nil ;};

// ReadAtLeast reads at least n bytes into slice p.
// Returns the number of bytes read (should always be == n), and an error on failure.
func (_fgba *PdfParser )ReadAtLeast (p []byte ,n int )(int ,error ){_baeb :=n ;_cgfb :=0;_fcdc :=0;for _baeb > 0{_fag ,_dadc :=_fgba ._fbgde .Read (p [_cgfb :]);if _dadc !=nil {_fdf .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061d\u0069\u006e\u0067\u0020\u0028\u0025\u0064\u003b\u0025\u0064\u0029\u0020\u0025\u0073",_fag ,_fcdc ,_dadc .Error ());
return _cgfb ,_fb .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065a\u0064\u0069\u006e\u0067");};_fcdc ++;_cgfb +=_fag ;_baeb -=_fag ;};return _cgfb ,nil ;};

// Version represents a version of a PDF standard.
type Version struct{Major int ;Minor int ;};

// Encode encodes previously prepare jbig2 document and stores it as the byte slice.
func (_eaeb *JBIG2Encoder )Encode ()(_bbec []byte ,_dcfac error ){const _bgag ="J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0045\u006eco\u0064\u0065";if _eaeb ._bege ==nil {return nil ,_de .Errorf (_bgag ,"\u0064\u006f\u0063u\u006d\u0065\u006e\u0074 \u0069\u006e\u0070\u0075\u0074\u0020\u0064a\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006e\u0065\u0064");
};_eaeb ._bege .FullHeaders =_eaeb .DefaultPageSettings .FileMode ;_bbec ,_dcfac =_eaeb ._bege .Encode ();if _dcfac !=nil {return nil ,_de .Wrap (_dcfac ,_bgag ,"");};return _bbec ,nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_gdbd *RunLengthEncoder )MakeDecodeParams ()PdfObject {return nil };const (DefaultJPEGQuality =75;);

// DecodeBytes decodes a slice of JBIG2 encoded bytes and returns the results.
func (_bgeg *JBIG2Encoder )DecodeBytes (encoded []byte )([]byte ,error ){return _cea .DecodeBytes (encoded ,_gge .Parameters {},_bgeg .Globals );};

// EncodeImage encodes 'img' golang image.Image into jbig2 encoded bytes document using default encoder settings.
func (_fbed *JBIG2Encoder )EncodeImage (img _fg .Image )([]byte ,error ){return _fbed .encodeImage (img )};

// HeaderCommentBytes gets the header comment bytes.
func (_bda ParserMetadata )HeaderCommentBytes ()[4]byte {return _bda ._fddb };

// GetInt returns the *PdfObjectBool object that is represented by a PdfObject either directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetInt (obj PdfObject )(_afed *PdfObjectInteger ,_abcf bool ){_afed ,_abcf =TraceToDirectObject (obj ).(*PdfObjectInteger );return _afed ,_abcf ;};

// DecodeStream decodes a FlateEncoded stream object and give back decoded bytes.
func (_eba *FlateEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_fdf .Log .Trace ("\u0046l\u0061t\u0065\u0044\u0065\u0063\u006fd\u0065\u0020s\u0074\u0072\u0065\u0061\u006d");_fdf .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_eba .Predictor );
if _eba .BitsPerComponent !=8{return nil ,_af .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003d\u0025\u0064\u0020\u0028\u006f\u006e\u006c\u0079\u0020\u0038\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0029",_eba .BitsPerComponent );
};_ccbb ,_cacf :=_eba .DecodeBytes (streamObj .Stream );if _cacf !=nil {return nil ,_cacf ;};_ccbb ,_cacf =_eba .postDecodePredict (_ccbb );if _cacf !=nil {return nil ,_cacf ;};return _ccbb ,nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_adfd *RawEncoder )UpdateParams (params *PdfObjectDictionary ){};func _dgged (_geafg PdfObject ,_beeab int )PdfObject {if _beeab > _gbdc {_fdf .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_gbdc );
return MakeNull ();};switch _bfdg :=_geafg .(type ){case *PdfIndirectObject :_geafg =_dgged ((*_bfdg ).PdfObject ,_beeab +1);case *PdfObjectArray :for _acabe ,_dadg :=range (*_bfdg )._beeag {(*_bfdg )._beeag [_acabe ]=_dgged (_dadg ,_beeab +1);};case *PdfObjectDictionary :for _gggbb ,_faabf :=range (*_bfdg )._cgbf {(*_bfdg )._cgbf [_gggbb ]=_dgged (_faabf ,_beeab +1);
};_d .Slice ((*_bfdg )._aadg ,func (_fceeb ,_edgdf int )bool {return (*_bfdg )._aadg [_fceeb ]< (*_bfdg )._aadg [_edgdf ]});};return _geafg ;};

// AddEncoder adds the passed in encoder to the underlying encoder slice.
func (_abec *MultiEncoder )AddEncoder (encoder StreamEncoder ){_abec ._cbdf =append (_abec ._cbdf ,encoder );};

// EncodeBytes ASCII encodes the passed in slice of bytes.
func (_bcfa *ASCIIHexEncoder )EncodeBytes (data []byte )([]byte ,error ){var _adf _dd .Buffer ;for _ ,_aaec :=range data {_adf .WriteString (_af .Sprintf ("\u0025\u002e\u0032X\u0020",_aaec ));};_adf .WriteByte ('>');return _adf .Bytes (),nil ;};

// MakeEncodedString creates a PdfObjectString with encoded content, which can be either
// UTF-16BE or PDFDocEncoding depending on whether `utf16BE` is true or false respectively.
func MakeEncodedString (s string ,utf16BE bool )*PdfObjectString {if utf16BE {var _bgbc _dd .Buffer ;_bgbc .Write ([]byte {0xFE,0xFF});_bgbc .WriteString (_ce .StringToUTF16 (s ));return &PdfObjectString {_eagb :_bgbc .String (),_gccd :true };};return &PdfObjectString {_eagb :string (_ce .StringToPDFDocEncoding (s )),_gccd :false };
};

// DecodeStream decodes RunLengthEncoded stream object and give back decoded bytes.
func (_caab *RunLengthEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _caab .DecodeBytes (streamObj .Stream );};func (_bfbga *PdfParser )parseString ()(*PdfObjectString ,error ){_bfbga ._fbgde .ReadByte ();var _gfe _dd .Buffer ;
_afecd :=1;for {_fafb ,_becfe :=_bfbga ._fbgde .Peek (1);if _becfe !=nil {return MakeString (_gfe .String ()),_becfe ;};if _fafb [0]=='\\'{_bfbga ._fbgde .ReadByte ();_bedg ,_bcec :=_bfbga ._fbgde .ReadByte ();if _bcec !=nil {return MakeString (_gfe .String ()),_bcec ;
};if IsOctalDigit (_bedg ){_cfgee ,_bbggb :=_bfbga ._fbgde .Peek (2);if _bbggb !=nil {return MakeString (_gfe .String ()),_bbggb ;};var _dacab []byte ;_dacab =append (_dacab ,_bedg );for _ ,_bfgb :=range _cfgee {if IsOctalDigit (_bfgb ){_dacab =append (_dacab ,_bfgb );
}else {break ;};};_bfbga ._fbgde .Discard (len (_dacab )-1);_fdf .Log .Trace ("\u004e\u0075\u006d\u0065ri\u0063\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0022\u0025\u0073\u0022",_dacab );_aded ,_bbggb :=_a .ParseUint (string (_dacab ),8,32);if _bbggb !=nil {return MakeString (_gfe .String ()),_bbggb ;
};_gfe .WriteByte (byte (_aded ));continue ;};switch _bedg {case 'n':_gfe .WriteRune ('\n');case 'r':_gfe .WriteRune ('\r');case 't':_gfe .WriteRune ('\t');case 'b':_gfe .WriteRune ('\b');case 'f':_gfe .WriteRune ('\f');case '(':_gfe .WriteRune ('(');case ')':_gfe .WriteRune (')');
case '\\':_gfe .WriteRune ('\\');};continue ;}else if _fafb [0]=='('{_afecd ++;}else if _fafb [0]==')'{_afecd --;if _afecd ==0{_bfbga ._fbgde .ReadByte ();break ;};};_fef ,_ :=_bfbga ._fbgde .ReadByte ();_gfe .WriteByte (_fef );};return MakeString (_gfe .String ()),nil ;
};

// GetName returns the *PdfObjectName represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetName (obj PdfObject )(_aaecg *PdfObjectName ,_ecdg bool ){_aaecg ,_ecdg =TraceToDirectObject (obj ).(*PdfObjectName );return _aaecg ,_ecdg ;};

// String returns a string representation of the *PdfObjectString.
func (_cebec *PdfObjectString )String ()string {return _cebec ._eagb };

// GetAsFloat64Slice returns the array as []float64 slice.
// Returns an error if not entirely numeric (only PdfObjectIntegers, PdfObjectFloats).
func (_ebbd *PdfObjectArray )GetAsFloat64Slice ()([]float64 ,error ){var _egee []float64 ;for _ ,_bgeag :=range _ebbd .Elements (){_ddgcg ,_egdab :=GetNumberAsFloat (TraceToDirectObject (_bgeag ));if _egdab !=nil {return nil ,_af .Errorf ("\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006e\u0075m\u0062\u0065\u0072");
};_egee =append (_egee ,_ddgcg );};return _egee ,nil ;};

// DecodeBytes decodes a multi-encoded slice of bytes by passing it through the
// DecodeBytes method of the underlying encoders.
func (_ccae *MultiEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_gcac :=encoded ;var _ecge error ;for _ ,_fcgcc :=range _ccae ._cbdf {_fdf .Log .Trace ("\u004du\u006c\u0074i\u0020\u0045\u006e\u0063o\u0064\u0065\u0072 \u0044\u0065\u0063\u006f\u0064\u0065\u003a\u0020\u0041pp\u006c\u0079\u0069n\u0067\u0020F\u0069\u006c\u0074\u0065\u0072\u003a \u0025\u0076 \u0025\u0054",_fcgcc ,_fcgcc );
_gcac ,_ecge =_fcgcc .DecodeBytes (_gcac );if _ecge !=nil {return nil ,_ecge ;};};return _gcac ,nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_aeccd *ASCII85Encoder )MakeDecodeParams ()PdfObject {return nil };

// GoImageToJBIG2 creates a binary image on the base of 'i' golang image.Image.
// If the image is not a black/white image then the function converts provided input into
// JBIG2Image with 1bpp. For non grayscale images the function performs the conversion to the grayscale temp image.
// Then it checks the value of the gray image value if it's within bounds of the black white threshold.
// This 'bwThreshold' value should be in range (0.0, 1.0). The threshold checks if the grayscale pixel (uint) value
// is greater or smaller than 'bwThreshold' * 255. Pixels inside the range will be white, and the others will be black.
// If the 'bwThreshold' is equal to -1.0 - JB2ImageAutoThreshold then it's value would be set on the base of
// it's histogram using Triangle method. For more information go to:
// 	https://www.mathworks.com/matlabcentral/fileexchange/28047-gray-image-thresholding-using-the-triangle-method
func GoImageToJBIG2 (i _fg .Image ,bwThreshold float64 )(*JBIG2Image ,error ){const _aea ="\u0047\u006f\u0049\u006d\u0061\u0067\u0065\u0054\u006fJ\u0042\u0049\u0047\u0032";if i ==nil {return nil ,_de .Error (_aea ,"i\u006d\u0061\u0067\u0065 '\u0069'\u0020\u006e\u006f\u0074\u0020d\u0065\u0066\u0069\u006e\u0065\u0064");
};var (_baec uint8 ;_fedg _gb .Image ;_cefb error ;);if bwThreshold ==JB2ImageAutoThreshold {_fedg ,_cefb =_gb .MonochromeConverter .Convert (i );}else if bwThreshold > 1.0||bwThreshold < 0.0{return nil ,_de .Error (_aea ,"p\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074h\u0072\u0065\u0073\u0068\u006f\u006c\u0064 i\u0073\u0020\u006e\u006ft\u0020\u0069\u006e\u0020\u0061\u0020\u0072\u0061\u006ege\u0020\u007b0\u002e\u0030\u002c\u0020\u0031\u002e\u0030\u007d");
}else {_baec =uint8 (255*bwThreshold );_fedg ,_cefb =_gb .MonochromeThresholdConverter (_baec ).Convert (i );};if _cefb !=nil {return nil ,_cefb ;};return _dcbae (_fedg ),nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_bagc *MultiEncoder )MakeStreamDict ()*PdfObjectDictionary {_begd :=MakeDict ();_begd .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",_bagc .GetFilterArray ());for _ ,_dcff :=range _bagc ._cbdf {_fegb :=_dcff .MakeStreamDict ();for _ ,_eaab :=range _fegb .Keys (){_baab :=_fegb .Get (_eaab );
if _eaab !="\u0046\u0069\u006c\u0074\u0065\u0072"&&_eaab !="D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"{_begd .Set (_eaab ,_baab );};};};_acc :=_bagc .MakeDecodeParams ();if _acc !=nil {_begd .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_acc );
};return _begd ;};

// ToGoImage converts the JBIG2Image to the golang image.Image.
func (_feefd *JBIG2Image )ToGoImage ()(_fg .Image ,error ){const _bbcff ="J\u0042I\u0047\u0032\u0049\u006d\u0061\u0067\u0065\u002eT\u006f\u0047\u006f\u0049ma\u0067\u0065";if _feefd .Data ==nil {return nil ,_de .Error (_bbcff ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");
};if _feefd .Width ==0||_feefd .Height ==0{return nil ,_de .Error (_bbcff ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");
};_ggf ,_fbab :=_gb .NewImage (_feefd .Width ,_feefd .Height ,1,1,_feefd .Data ,nil ,nil );if _fbab !=nil {return nil ,_fbab ;};return _ggf ,nil ;};

// DecodeBytes decodes a slice of DCT encoded bytes and returns the result.
func (_acd *DCTEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_abee :=_dd .NewReader (encoded );_febd ,_gab :=_dc .Decode (_abee );if _gab !=nil {_fdf .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006eg\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_gab );
return nil ,_gab ;};_bfd :=_febd .Bounds ();var _gdafd =make ([]byte ,_bfd .Dx ()*_bfd .Dy ()*_acd .ColorComponents *_acd .BitsPerComponent /8);_fgcb :=0;for _fdfc :=_bfd .Min .Y ;_fdfc < _bfd .Max .Y ;_fdfc ++{for _dade :=_bfd .Min .X ;_dade < _bfd .Max .X ;
_dade ++{_ccda :=_febd .At (_dade ,_fdfc );if _acd .ColorComponents ==1{if _acd .BitsPerComponent ==16{_bdgc ,_dagb :=_ccda .(_aa .Gray16 );if !_dagb {return nil ,_fb .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_gdafd [_fgcb ]=byte ((_bdgc .Y >>8)&0xff);_fgcb ++;_gdafd [_fgcb ]=byte (_bdgc .Y &0xff);_fgcb ++;}else {_gagf ,_cfd :=_ccda .(_aa .Gray );if !_cfd {return nil ,_fb .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_gdafd [_fgcb ]=_gagf .Y &0xff;_fgcb ++;};}else if _acd .ColorComponents ==3{if _acd .BitsPerComponent ==16{_cfab ,_ddab :=_ccda .(_aa .RGBA64 );if !_ddab {return nil ,_fb .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_gdafd [_fgcb ]=byte ((_cfab .R >>8)&0xff);_fgcb ++;_gdafd [_fgcb ]=byte (_cfab .R &0xff);_fgcb ++;_gdafd [_fgcb ]=byte ((_cfab .G >>8)&0xff);_fgcb ++;_gdafd [_fgcb ]=byte (_cfab .G &0xff);_fgcb ++;_gdafd [_fgcb ]=byte ((_cfab .B >>8)&0xff);_fgcb ++;
_gdafd [_fgcb ]=byte (_cfab .B &0xff);_fgcb ++;}else {_fddg ,_beacd :=_ccda .(_aa .RGBA );if _beacd {_gdafd [_fgcb ]=_fddg .R &0xff;_fgcb ++;_gdafd [_fgcb ]=_fddg .G &0xff;_fgcb ++;_gdafd [_fgcb ]=_fddg .B &0xff;_fgcb ++;}else {_fcff ,_gea :=_ccda .(_aa .YCbCr );
if !_gea {return nil ,_fb .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_ecfe ,_dbb ,_gfge ,_ :=_fcff .RGBA ();_gdafd [_fgcb ]=byte (_ecfe >>8);_fgcb ++;_gdafd [_fgcb ]=byte (_dbb >>8);_fgcb ++;_gdafd [_fgcb ]=byte (_gfge >>8);
_fgcb ++;};};}else if _acd .ColorComponents ==4{_cgc ,_fcaad :=_ccda .(_aa .CMYK );if !_fcaad {return nil ,_fb .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_gdafd [_fgcb ]=255-_cgc .C &0xff;_fgcb ++;
_gdafd [_fgcb ]=255-_cgc .M &0xff;_fgcb ++;_gdafd [_fgcb ]=255-_cgc .Y &0xff;_fgcb ++;_gdafd [_fgcb ]=255-_cgc .K &0xff;_fgcb ++;};};};return _gdafd ,nil ;};

// IsAuthenticated returns true if the PDF has already been authenticated for accessing.
func (_edag *PdfParser )IsAuthenticated ()bool {return _edag ._adfa ._abf };

// DecodeStream decodes a JBIG2 encoded stream and returns the result as a slice of bytes.
func (_bgca *JBIG2Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _bgca .DecodeBytes (streamObj .Stream );};

// String returns a string describing `ind`.
func (_faea *PdfIndirectObject )String ()string {return _af .Sprintf ("\u0049\u004f\u0062\u006a\u0065\u0063\u0074\u003a\u0025\u0064",(*_faea ).ObjectNumber );};func _dcbae (_aegfg _gb .Image )*JBIG2Image {_ecbb :=_aegfg .Base ();return &JBIG2Image {Data :_ecbb .Data ,Width :_ecbb .Width ,Height :_ecbb .Height ,HasPadding :true };
};func (_ffgg *PdfParser )traceStreamLength (_ggeab PdfObject )(PdfObject ,error ){_fdaf ,_becff :=_ggeab .(*PdfObjectReference );if _becff {_gfgg ,_dcgda :=_ffgg ._ddede [_fdaf .ObjectNumber ];if _dcgda &&_gfgg {_fdf .Log .Debug ("\u0053t\u0072\u0065a\u006d\u0020\u004c\u0065n\u0067\u0074\u0068 \u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065 u\u006e\u0072\u0065s\u006f\u006cv\u0065\u0064\u0020\u0028\u0069\u006cl\u0065\u0067a\u006c\u0029");
return nil ,_fb .New ("\u0069\u006c\u006c\u0065ga\u006c\u0020\u0072\u0065\u0063\u0075\u0072\u0073\u0069\u0076\u0065\u0020\u006c\u006fo\u0070");};_ffgg ._ddede [_fdaf .ObjectNumber ]=true ;};_caea ,_bdgba :=_ffgg .Resolve (_ggeab );if _bdgba !=nil {return nil ,_bdgba ;
};_fdf .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_caea );if _becff {_ffgg ._ddede [_fdaf .ObjectNumber ]=false ;};return _caea ,nil ;};var (ErrUnsupportedEncodingParameters =_fb .New ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074\u0065\u0072\u0073");
ErrNoCCITTFaxDecode =_fb .New ("\u0043\u0043I\u0054\u0054\u0046\u0061\u0078\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");
ErrNoJBIG2Decode =_fb .New ("\u004a\u0042\u0049\u0047\u0032\u0044\u0065c\u006f\u0064\u0065 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");
ErrNoJPXDecode =_fb .New ("\u004a\u0050\u0058\u0044\u0065c\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020i\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");
ErrNoPdfVersion =_fb .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");ErrTypeError =_fb .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");ErrRangeError =_fb .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");
ErrNotSupported =_bg .New ("\u0066\u0065\u0061t\u0075\u0072\u0065\u0020n\u006f\u0074\u0020\u0063\u0075\u0072\u0072e\u006e\u0074\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");ErrNotANumber =_fb .New ("\u006e\u006f\u0074 \u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072");
);

// GetFilterName returns the name of the encoding filter.
func (_dbd *FlateEncoder )GetFilterName ()string {return StreamEncodingFilterNameFlate };

// DecodeStream implements ASCII hex decoding.
func (_fbef *ASCIIHexEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _fbef .DecodeBytes (streamObj .Stream );};

// DecodeStream decodes a DCT encoded stream and returns the result as a
// slice of bytes.
func (_gbc *DCTEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _gbc .DecodeBytes (streamObj .Stream );};const (JB2Generic JBIG2CompressionType =iota ;JB2SymbolCorrelation ;JB2SymbolRankHaus ;);

// NewParser creates a new parser for a PDF file via ReadSeeker. Loads the cross reference stream and trailer.
// An error is returned on failure.
func NewParser (rs _gg .ReadSeeker )(*PdfParser ,error ){_gdbe :=&PdfParser {_cgda :rs ,ObjCache :make (objectCache ),_ddede :map[int64 ]bool {},_egfg :make ([]int64 ,0),_cggc :make (map[*PdfParser ]*PdfParser )};_bbb ,_gcec ,_caaa :=_gdbe .parsePdfVersion ();
if _caaa !=nil {_fdf .Log .Error ("U\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0076e\u0072\u0073\u0069o\u006e:\u0020\u0025\u0076",_caaa );return nil ,_caaa ;};_gdbe ._ddc .Major =_bbb ;_gdbe ._ddc .Minor =_gcec ;
if _gdbe ._gdcfc ,_caaa =_gdbe .loadXrefs ();_caaa !=nil {_fdf .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020F\u0061\u0069\u006c\u0065d t\u006f l\u006f\u0061\u0064\u0020\u0078\u0072\u0065f \u0074\u0061\u0062\u006c\u0065\u0021\u0020%\u0073",_caaa );return nil ,_caaa ;
};_fdf .Log .Trace ("T\u0072\u0061\u0069\u006c\u0065\u0072\u003a\u0020\u0025\u0073",_gdbe ._gdcfc );_cabbd ,_caaa :=_gdbe .parseLinearizedDictionary ();if _caaa !=nil {return nil ,_caaa ;};if _cabbd !=nil {_gdbe ._ecdb ,_caaa =_gdbe .checkLinearizedInformation (_cabbd );
if _caaa !=nil {return nil ,_caaa ;};};if len (_gdbe ._bfaa .ObjectMap )==0{return nil ,_af .Errorf ("\u0065\u006d\u0070\u0074\u0079\u0020\u0058\u0052\u0045\u0046\u0020t\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0049\u006e\u0076a\u006c\u0069\u0064");};
_gdbe ._dcgd =len (_gdbe ._egfg );if _gdbe ._ecdb &&_gdbe ._dcgd !=0{_gdbe ._dcgd --;};_gdbe ._geeca =make ([]*PdfParser ,_gdbe ._dcgd );return _gdbe ,nil ;};

// WriteString outputs the object as it is to be written to file.
func (_gagc *PdfObjectArray )WriteString ()string {var _beeg _eaa .Builder ;_beeg .WriteString ("\u005b");for _cabg ,_ccaab :=range _gagc .Elements (){_beeg .WriteString (_ccaab .WriteString ());if _cabg < (_gagc .Len ()-1){_beeg .WriteString ("\u0020");
};};_beeg .WriteString ("\u005d");return _beeg .String ();};

// GetIndirect returns the *PdfIndirectObject represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetIndirect (obj PdfObject )(_cfecd *PdfIndirectObject ,_gbecd bool ){obj =ResolveReference (obj );_cfecd ,_gbecd =obj .(*PdfIndirectObject );return _cfecd ,_gbecd ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_edc *CCITTFaxEncoder )MakeStreamDict ()*PdfObjectDictionary {_eefdd :=MakeDict ();_eefdd .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_edc .GetFilterName ()));_eefdd .SetIfNotNil ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_edc .MakeDecodeParams ());
return _eefdd ;};func (_cgca *PdfParser )parseName ()(PdfObjectName ,error ){var _cbece _dd .Buffer ;_dabg :=false ;for {_bggf ,_dddd :=_cgca ._fbgde .Peek (1);if _dddd ==_gg .EOF {break ;};if _dddd !=nil {return PdfObjectName (_cbece .String ()),_dddd ;
};if !_dabg {if _bggf [0]=='/'{_dabg =true ;_cgca ._fbgde .ReadByte ();}else if _bggf [0]=='%'{_cgca .readComment ();_cgca .skipSpaces ();}else {_fdf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020N\u0061\u006d\u0065\u0020\u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020w\u0069\u0074\u0068\u0020\u0025\u0073\u0020(\u0025\u0020\u0078\u0029",_bggf ,_bggf );
return PdfObjectName (_cbece .String ()),_af .Errorf ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u006ea\u006d\u0065:\u0020\u0028\u0025\u0063\u0029",_bggf [0]);};}else {if IsWhiteSpace (_bggf [0]){break ;}else if (_bggf [0]=='/')||(_bggf [0]=='[')||(_bggf [0]=='(')||(_bggf [0]==']')||(_bggf [0]=='<')||(_bggf [0]=='>'){break ;
}else if _bggf [0]=='#'{_fegbe ,_feeef :=_cgca ._fbgde .Peek (3);if _feeef !=nil {return PdfObjectName (_cbece .String ()),_feeef ;};_cfbb ,_feeef :=_fe .DecodeString (string (_fegbe [1:3]));if _feeef !=nil {_fdf .Log .Debug ("\u0045\u0052\u0052\u004fR\u003a\u0020\u0049\u006ev\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0066o\u006c\u006co\u0077\u0069\u006e\u0067 \u0027\u0023\u0027\u002c \u0063\u006f\u006e\u0074\u0069n\u0075\u0069\u006e\u0067\u0020\u0075\u0073i\u006e\u0067\u0020\u006c\u0069t\u0065\u0072\u0061\u006c\u0020\u002d\u0020\u004f\u0075t\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074");
_cbece .WriteByte ('#');_cgca ._fbgde .Discard (1);continue ;};_cgca ._fbgde .Discard (3);_cbece .Write (_cfbb );}else {_febg ,_ :=_cgca ._fbgde .ReadByte ();_cbece .WriteByte (_febg );};};};return PdfObjectName (_cbece .String ()),nil ;};

// AddPageImage adds the page with the image 'img' to the encoder context in order to encode it jbig2 document.
// The 'settings' defines what encoding type should be used by the encoder.
func (_fggbb *JBIG2Encoder )AddPageImage (img *JBIG2Image ,settings *JBIG2EncoderSettings )(_dcbac error ){const _abfg ="\u004a\u0042\u0049\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0041\u0064\u0064\u0050\u0061\u0067\u0065\u0049m\u0061\u0067\u0065";
if _fggbb ==nil {return _de .Error (_abfg ,"J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u0020\u0069\u0073 n\u0069\u006c");};if settings ==nil {settings =&_fggbb .DefaultPageSettings ;};if _fggbb ._bege ==nil {_fggbb ._bege =_ga .InitEncodeDocument (settings .FileMode );
};if _dcbac =settings .Validate ();_dcbac !=nil {return _de .Wrap (_dcbac ,_abfg ,"");};_agfa ,_dcbac :=img .toBitmap ();if _dcbac !=nil {return _de .Wrap (_dcbac ,_abfg ,"");};switch settings .Compression {case JB2Generic :if _dcbac =_fggbb ._bege .AddGenericPage (_agfa ,settings .DuplicatedLinesRemoval );
_dcbac !=nil {return _de .Wrap (_dcbac ,_abfg ,"");};case JB2SymbolCorrelation :return _de .Error (_abfg ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
case JB2SymbolRankHaus :return _de .Error (_abfg ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
default:return _de .Error (_abfg ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return nil ;};

// MakeStringFromBytes creates an PdfObjectString from a byte array.
// This is more natural than MakeString as `data` is usually not utf-8 encoded.
func MakeStringFromBytes (data []byte )*PdfObjectString {return MakeString (string (data ))};var _aace =_c .MustCompile ("\u005e\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_deac *MultiEncoder )MakeDecodeParams ()PdfObject {if len (_deac ._cbdf )==0{return nil ;};if len (_deac ._cbdf )==1{return _deac ._cbdf [0].MakeDecodeParams ();};_adbe :=MakeArray ();_aaae :=true ;for _ ,_ace :=range _deac ._cbdf {_ggeb :=_ace .MakeDecodeParams ();
if _ggeb ==nil {_adbe .Append (MakeNull ());}else {_aaae =false ;_adbe .Append (_ggeb );};};if _aaae {return nil ;};return _adbe ;};

// UpdateParams updates the parameter values of the encoder.
func (_efc *CCITTFaxEncoder )UpdateParams (params *PdfObjectDictionary ){if _eaed ,_eeda :=GetNumberAsInt64 (params .Get ("\u004b"));_eeda ==nil {_efc .K =int (_eaed );};if _acgf ,_afac :=GetNumberAsInt64 (params .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));
_afac ==nil {_efc .Columns =int (_acgf );}else if _acgf ,_afac =GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));_afac ==nil {_efc .Columns =int (_acgf );};if _beeb ,_abga :=GetNumberAsInt64 (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));
_abga ==nil {_efc .BlackIs1 =_beeb > 0;}else {if _bgbf ,_eaea :=GetBoolVal (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_eaea {_efc .BlackIs1 =_bgbf ;}else {if _gfgef ,_dbcaa :=GetArray (params .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));
_dbcaa {_bdfe ,_ddba :=_gfgef .ToIntegerArray ();if _ddba ==nil {_efc .BlackIs1 =_bdfe [0]==1&&_bdfe [1]==0;};};};};if _fdag ,_gdcff :=GetNumberAsInt64 (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));
_gdcff ==nil {_efc .EncodedByteAlign =_fdag > 0;}else {if _daed ,_bccg :=GetBoolVal (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_bccg {_efc .EncodedByteAlign =_daed ;};};if _ffba ,_gged :=GetNumberAsInt64 (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));
_gged ==nil {_efc .EndOfLine =_ffba > 0;}else {if _gdfd ,_gbec :=GetBoolVal (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_gbec {_efc .EndOfLine =_gdfd ;};};if _bfe ,_fcgf :=GetNumberAsInt64 (params .Get ("\u0052\u006f\u0077\u0073"));_fcgf ==nil {_efc .Rows =int (_bfe );
}else if _bfe ,_fcgf =GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));_fcgf ==nil {_efc .Rows =int (_bfe );};if _bfcg ,_cdfe :=GetNumberAsInt64 (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_cdfe ==nil {_efc .EndOfBlock =_bfcg > 0;
}else {if _eca ,_dcgbc :=GetBoolVal (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_dcgbc {_efc .EndOfBlock =_eca ;};};if _bgdg ,_gega :=GetNumberAsInt64 (params .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));
_gega !=nil {_efc .DamagedRowsBeforeError =int (_bgdg );};};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_gbfb *RawEncoder )MakeDecodeParams ()PdfObject {return nil };func _fedc (_cfff PdfObject )(*float64 ,error ){switch _ebfa :=_cfff .(type ){case *PdfObjectFloat :_ccgc :=float64 (*_ebfa );return &_ccgc ,nil ;case *PdfObjectInteger :_defa :=float64 (*_ebfa );
return &_defa ,nil ;case *PdfObjectNull :return nil ,nil ;};return nil ,ErrNotANumber ;};

// EncodeBytes encodes slice of bytes into JBIG2 encoding format.
// The input 'data' must be an image. In order to Decode it a user is responsible to
// load the codec ('png', 'jpg').
// Returns jbig2 single page encoded document byte slice. The encoder uses DefaultPageSettings
// to encode given image.
func (_agfbd *JBIG2Encoder )EncodeBytes (data []byte )([]byte ,error ){const _gcedb ="\u004aB\u0049\u0047\u0032\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002eE\u006e\u0063\u006f\u0064\u0065\u0042\u0079\u0074\u0065\u0073";if _agfbd .ColorComponents !=1||_agfbd .BitsPerComponent !=1{return nil ,_de .Errorf (_gcedb ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u002e\u0020\u004a\u0042\u0049G\u0032\u0020E\u006e\u0063o\u0064\u0065\u0072\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020bi\u006e\u0061\u0072\u0079\u0020\u0069\u006d\u0061\u0067e\u0073\u0020\u0064\u0061\u0074\u0061");
};var (_aad *_ddb .Bitmap ;_aef error ;);_dcabb :=(_agfbd .Width *_agfbd .Height )==len (data );if _dcabb {_aad ,_aef =_ddb .NewWithUnpaddedData (_agfbd .Width ,_agfbd .Height ,data );}else {_aad ,_aef =_ddb .NewWithData (_agfbd .Width ,_agfbd .Height ,data );
};if _aef !=nil {return nil ,_aef ;};_gfcc :=_agfbd .DefaultPageSettings ;if _aef =_gfcc .Validate ();_aef !=nil {return nil ,_de .Wrap (_aef ,_gcedb ,"");};if _agfbd ._bege ==nil {_agfbd ._bege =_ga .InitEncodeDocument (_gfcc .FileMode );};switch _gfcc .Compression {case JB2Generic :if _aef =_agfbd ._bege .AddGenericPage (_aad ,_gfcc .DuplicatedLinesRemoval );
_aef !=nil {return nil ,_de .Wrap (_aef ,_gcedb ,"");};case JB2SymbolCorrelation :return nil ,_de .Error (_gcedb ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
case JB2SymbolRankHaus :return nil ,_de .Error (_gcedb ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
default:return nil ,_de .Error (_gcedb ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return _agfbd .Encode ();};

// MakeDecodeParams makes a new instance of an encoding dictionary based on the current encoder settings.
func (_fgccg *JBIG2Encoder )MakeDecodeParams ()PdfObject {return MakeDict ()};func (_acg *PdfCrypt )makeKey (_fgdd string ,_ebb ,_beb uint32 ,_geb []byte )([]byte ,error ){_bfbg ,_abg :=_acg ._bafb [_fgdd ];if !_abg {return nil ,_af .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_fgdd );
};return _bfbg .MakeKey (_ebb ,_beb ,_geb );};

// String returns a string describing `streams`.
func (_effca *PdfObjectStreams )String ()string {return _af .Sprintf ("\u004f\u0062j\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0025\u0064",_effca .ObjectNumber );};func (_dcdgc *PdfParser )parseHexString ()(*PdfObjectString ,error ){_dcdgc ._fbgde .ReadByte ();
var _deed _dd .Buffer ;for {_cbff ,_gddg :=_dcdgc ._fbgde .Peek (1);if _gddg !=nil {return MakeString (""),_gddg ;};if _cbff [0]=='>'{_dcdgc ._fbgde .ReadByte ();break ;};_dece ,_ :=_dcdgc ._fbgde .ReadByte ();if _dcdgc ._dcfb {if _dd .IndexByte (_fdaa ,_dece )==-1{_dcdgc ._aadf ._cebe =true ;
};};if !IsWhiteSpace (_dece ){_deed .WriteByte (_dece );};};if _deed .Len ()%2==1{_dcdgc ._aadf ._bffa =true ;_deed .WriteRune ('0');};_gedb ,_ :=_fe .DecodeString (_deed .String ());return MakeHexString (string (_gedb )),nil ;};

// Get returns the PdfObject corresponding to the specified key.
// Returns a nil value if the key is not set.
func (_dadaa *PdfObjectDictionary )Get (key PdfObjectName )PdfObject {_dadaa ._dggf .Lock ();defer _dadaa ._dggf .Unlock ();_ddgg ,_cffgd :=_dadaa ._cgbf [key ];if !_cffgd {return nil ;};return _ddgg ;};

// GetEncryptObj returns the PdfIndirectObject which has information about the PDFs encryption details.
func (_cgad *PdfParser )GetEncryptObj ()*PdfIndirectObject {return _cgad ._gdgfc };

// PdfObjectFloat represents the primitive PDF floating point numerical object.
type PdfObjectFloat float64 ;

// PdfObjectDictionary represents the primitive PDF dictionary/map object.
type PdfObjectDictionary struct{_cgbf map[PdfObjectName ]PdfObject ;_aadg []PdfObjectName ;_dggf *_fd .Mutex ;_abcg *PdfParser ;};func (_bfcb *PdfCrypt )decryptBytes (_gdfg []byte ,_gca string ,_eed []byte )([]byte ,error ){_fdf .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");
_fbac ,_aeg :=_bfcb ._bafb [_gca ];if !_aeg {return nil ,_af .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_gca );};return _fbac .DecryptBytes (_gdfg ,_eed );};func (_dfeff *PdfObjectFloat )String ()string {return _af .Sprintf ("\u0025\u0066",*_dfeff )};


// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_bece *JBIG2Encoder )MakeStreamDict ()*PdfObjectDictionary {_bdb :=MakeDict ();_bdb .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_bece .GetFilterName ()));return _bdb ;};var _eefb =_c .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064+\u0029\u005c\u0073\u002b\u0028\u005b\u006e\u0066\u005d\u0029\\\u0073\u002a\u0024");


// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_gbae *LZWEncoder )MakeStreamDict ()*PdfObjectDictionary {_aaff :=MakeDict ();_aaff .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_gbae .GetFilterName ()));_efdb :=_gbae .MakeDecodeParams ();if _efdb !=nil {_aaff .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_efdb );
};_aaff .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (int64 (_gbae .EarlyChange )));return _aaff ;};

// Str returns the string value of the PdfObjectString. Defined in addition to String() function to clarify that
// this function returns the underlying string directly, whereas the String function technically could include
// debug info.
func (_abbc *PdfObjectString )Str ()string {return _abbc ._eagb };

// String returns a descriptive information string about the encryption method used.
func (_aff *PdfCrypt )String ()string {if _aff ==nil {return "";};_gadg :=_aff ._cbc .Filter +"\u0020\u002d\u0020";if _aff ._cbc .V ==0{_gadg +="\u0055\u006e\u0064\u006fcu\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0061\u006c\u0067\u006f\u0072\u0069\u0074h\u006d";
}else if _aff ._cbc .V ==1{_gadg +="\u0052\u0043\u0034:\u0020\u0034\u0030\u0020\u0062\u0069\u0074\u0073";}else if _aff ._cbc .V ==2{_gadg +=_af .Sprintf ("\u0052\u0043\u0034:\u0020\u0025\u0064\u0020\u0062\u0069\u0074\u0073",_aff ._cbc .Length );}else if _aff ._cbc .V ==3{_gadg +="U\u006e\u0070\u0075\u0062li\u0073h\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d";
}else if _aff ._cbc .V >=4{_gadg +=_af .Sprintf ("\u0053\u0074r\u0065\u0061\u006d\u0020f\u0069\u006ct\u0065\u0072\u003a\u0020\u0025\u0073\u0020\u002d \u0053\u0074\u0072\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0074\u0065r\u003a\u0020\u0025\u0073",_aff ._afb ,_aff ._egg );
_gadg +="\u003b\u0020C\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0073\u003a";for _eac ,_bafc :=range _aff ._bafb {_gadg +=_af .Sprintf ("\u0020\u002d\u0020\u0025\u0073\u003a\u0020\u0025\u0073 \u0028\u0025\u0064\u0029",_eac ,_bafc .Name (),_bafc .KeyLength ());
};};_ggb :=_aff .GetAccessPermissions ();_gadg +=_af .Sprintf ("\u0020\u002d\u0020\u0025\u0023\u0076",_ggb );return _gadg ;};

// Decoded returns the PDFDocEncoding or UTF-16BE decoded string contents.
// UTF-16BE is applied when the first two bytes are 0xFE, 0XFF, otherwise decoding of
// PDFDocEncoding is performed.
func (_gcfc *PdfObjectString )Decoded ()string {if _gcfc ==nil {return "";};_abfgg :=[]byte (_gcfc ._eagb );if len (_abfgg )>=2&&_abfgg [0]==0xFE&&_abfgg [1]==0xFF{return _ce .UTF16ToString (_abfgg [2:]);};return _ce .PDFDocEncodingToString (_abfgg );};
var _fcge =_c .MustCompile ("\u005b\\\u0072\u005c\u006e\u005d\u005c\u0073\u002a\u0028\u0078\u0072\u0065f\u0029\u005c\u0073\u002a\u005b\u005c\u0072\u005c\u006e\u005d");

// NewCCITTFaxEncoder makes a new CCITTFax encoder.
func NewCCITTFaxEncoder ()*CCITTFaxEncoder {return &CCITTFaxEncoder {Columns :1728,EndOfBlock :true }};

// UpdateParams updates the parameter values of the encoder.
func (_cdca *MultiEncoder )UpdateParams (params *PdfObjectDictionary ){for _ ,_gfad :=range _cdca ._cbdf {_gfad .UpdateParams (params );};};

// PdfParser parses a PDF file and provides access to the object structure of the PDF.
type PdfParser struct{_ddc Version ;_cgda _gg .ReadSeeker ;_fbgde *_b .Reader ;_gdgf int64 ;_bfaa XrefTable ;_dfc int64 ;_fced *xrefType ;_fgfg objectStreams ;_gdcfc *PdfObjectDictionary ;_adfa *PdfCrypt ;_gdgfc *PdfIndirectObject ;_fadg bool ;ObjCache objectCache ;
_eedae map[int ]bool ;_ddede map[int64 ]bool ;_aadf ParserMetadata ;_dcfb bool ;_egfg []int64 ;_dcgd int ;_ecdb bool ;_fgdgf int64 ;_cggc map[*PdfParser ]*PdfParser ;_geeca []*PdfParser ;};

// EncodeBytes encodes the passed in slice of bytes by passing it through the
// EncodeBytes method of the underlying encoders.
func (_bgcg *MultiEncoder )EncodeBytes (data []byte )([]byte ,error ){_dcbab :=data ;var _bfcd error ;for _fbf :=len (_bgcg ._cbdf )-1;_fbf >=0;_fbf --{_bgbd :=_bgcg ._cbdf [_fbf ];_dcbab ,_bfcd =_bgbd .EncodeBytes (_dcbab );if _bfcd !=nil {return nil ,_bfcd ;
};};return _dcbab ,nil ;};

// MakeObjectStreams creates an PdfObjectStreams from a list of PdfObjects.
func MakeObjectStreams (objects ...PdfObject )*PdfObjectStreams {return &PdfObjectStreams {_aagf :objects };};

// GetFilterName returns the name of the encoding filter.
func (_cggf *RawEncoder )GetFilterName ()string {return StreamEncodingFilterNameRaw };

// GetBool returns the *PdfObjectBool object that is represented by a PdfObject directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetBool (obj PdfObject )(_becag *PdfObjectBool ,_baeba bool ){_becag ,_baeba =TraceToDirectObject (obj ).(*PdfObjectBool );return _becag ,_baeba ;};

// GetFilterName returns the name of the encoding filter.
func (_fcg *DCTEncoder )GetFilterName ()string {return StreamEncodingFilterNameDCT };

// Set sets the PdfObject at index i of the array. An error is returned if the index is outside bounds.
func (_eacca *PdfObjectArray )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_eacca ._beeag ){return _fb .New ("\u006f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_eacca ._beeag [i ]=obj ;return nil ;};

// EncodeBytes encodes data into ASCII85 encoded format.
func (_egba *ASCII85Encoder )EncodeBytes (data []byte )([]byte ,error ){var _cbbe _dd .Buffer ;for _beee :=0;_beee < len (data );_beee +=4{_cffa :=data [_beee ];_agee :=1;_cgf :=byte (0);if _beee +1< len (data ){_cgf =data [_beee +1];_agee ++;};_affd :=byte (0);
if _beee +2< len (data ){_affd =data [_beee +2];_agee ++;};_decae :=byte (0);if _beee +3< len (data ){_decae =data [_beee +3];_agee ++;};_fadc :=(uint32 (_cffa )<<24)|(uint32 (_cgf )<<16)|(uint32 (_affd )<<8)|uint32 (_decae );if _fadc ==0{_cbbe .WriteByte ('z');
}else {_eda :=_egba .base256Tobase85 (_fadc );for _ ,_cfdb :=range _eda [:_agee +1]{_cbbe .WriteByte (_cfdb +'!');};};};_cbbe .WriteString ("\u007e\u003e");return _cbbe .Bytes (),nil ;};

// GetParser returns the parser for lazy-loading or compare references.
func (_edff *PdfObjectReference )GetParser ()*PdfParser {return _edff ._gdad };

// GetObjectStreams returns the *PdfObjectStreams represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetObjectStreams (obj PdfObject )(_cdef *PdfObjectStreams ,_efba bool ){_cdef ,_efba =obj .(*PdfObjectStreams );return _cdef ,_efba ;};

// JPXEncoder implements JPX encoder/decoder (dummy, for now)
// FIXME: implement
type JPXEncoder struct{};var _cdbf =_c .MustCompile ("\u005c\u0073\u002a\u0078\u0072\u0065\u0066\u005c\u0073\u002a");func _fge (_bfb _gd .Filter ,_facd _ge .AuthEvent )*PdfObjectDictionary {if _facd ==""{_facd =_ge .EventDocOpen ;};_ffb :=MakeDict ();_ffb .Set ("\u0054\u0079\u0070\u0065",MakeName ("C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"));
_ffb .Set ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et",MakeName (string (_facd )));_ffb .Set ("\u0043\u0046\u004d",MakeName (_bfb .Name ()));_ffb .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_bfb .KeyLength ())));return _ffb ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_ggae *FlateEncoder )MakeStreamDict ()*PdfObjectDictionary {_acf :=MakeDict ();_acf .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_ggae .GetFilterName ()));_bbcf :=_ggae .MakeDecodeParams ();if _bbcf !=nil {_acf .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_bbcf );
};return _acf ;};

// PdfObjectString represents the primitive PDF string object.
type PdfObjectString struct{_eagb string ;_gccd bool ;};

// HasOddLengthHexStrings checks if the document has odd length hexadecimal strings.
func (_abef ParserMetadata )HasOddLengthHexStrings ()bool {return _abef ._bffa };func (_ddbd *PdfParser )checkLinearizedInformation (_bgdba *PdfObjectDictionary )(bool ,error ){var _dccb error ;_ddbd ._fgdgf ,_dccb =GetNumberAsInt64 (_bgdba .Get ("\u004c"));
if _dccb !=nil {return false ,_dccb ;};_dccb =_ddbd .seekToEOFMarker (_ddbd ._fgdgf );switch _dccb {case nil :return true ,nil ;case _cdg :return false ,nil ;default:return false ,_dccb ;};};

// Remove removes an element specified by key.
func (_fefa *PdfObjectDictionary )Remove (key PdfObjectName ){_gagfa :=-1;for _gfcec ,_gfbbb :=range _fefa ._aadg {if _gfbbb ==key {_gagfa =_gfcec ;break ;};};if _gagfa >=0{_fefa ._aadg =append (_fefa ._aadg [:_gagfa ],_fefa ._aadg [_gagfa +1:]...);delete (_fefa ._cgbf ,key );
};};func _fbcf (_gdgc *PdfObjectStream ,_bcfaf *PdfObjectDictionary )(*JBIG2Encoder ,error ){const _bfea ="\u006ee\u0077\u004a\u0042\u0049G\u0032\u0044\u0065\u0063\u006fd\u0065r\u0046r\u006f\u006d\u0053\u0074\u0072\u0065\u0061m";_agb :=NewJBIG2Encoder ();
_gace :=_gdgc .PdfObjectDictionary ;if _gace ==nil {return _agb ,nil ;};if _bcfaf ==nil {_fegd :=_gace .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _fegd !=nil {switch _dgcb :=_fegd .(type ){case *PdfObjectDictionary :_bcfaf =_dgcb ;
case *PdfObjectArray :if _dgcb .Len ()==1{if _gfce ,_abeea :=GetDict (_dgcb .Get (0));_abeea {_bcfaf =_gfce ;};};default:_fdf .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065P\u0061\u0072\u0061\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064i\u0063\u0074\u0069\u006f\u006e\u0061\u0072y\u0020\u0025\u0023\u0076",_fegd );
return nil ,_de .Errorf (_bfea ,"\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050a\u0072m\u0073\u0020\u0074\u0079\u0070\u0065\u003a \u0025\u0054",_dgcb );};};};if _bcfaf ==nil {return _agb ,nil ;};_agb .UpdateParams (_bcfaf );
_agfe ,_ggc :=GetStream (_bcfaf .Get ("\u004a\u0042\u0049G\u0032\u0047\u006c\u006f\u0062\u0061\u006c\u0073"));if !_ggc {return _agb ,nil ;};var _bcbb error ;_agb .Globals ,_bcbb =_cea .DecodeGlobals (_agfe .Stream );if _bcbb !=nil {_bcbb =_de .Wrap (_bcbb ,_bfea ,"\u0063\u006f\u0072\u0072u\u0070\u0074\u0065\u0064\u0020\u006a\u0062\u0069\u0067\u0032 \u0065n\u0063\u006f\u0064\u0065\u0064\u0020\u0064a\u0074\u0061");
_fdf .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_bcbb );return nil ,_bcbb ;};return _agb ,nil ;};

// PdfVersion returns version of the PDF file.
func (_bdbb *PdfParser )PdfVersion ()Version {return _bdbb ._ddc };

// EncodeBytes DCT encodes the passed in slice of bytes.
func (_ffbf *DCTEncoder )EncodeBytes (data []byte )([]byte ,error ){var _ccab _fg .Image ;if _ffbf .ColorComponents ==1&&_ffbf .BitsPerComponent ==8{_ccab =&_fg .Gray {Rect :_fg .Rect (0,0,_ffbf .Width ,_ffbf .Height ),Pix :data ,Stride :_gb .BytesPerLine (_ffbf .Width ,_ffbf .BitsPerComponent ,_ffbf .ColorComponents )};
}else {var _bbe error ;_ccab ,_bbe =_gb .NewImage (_ffbf .Width ,_ffbf .Height ,_ffbf .BitsPerComponent ,_ffbf .ColorComponents ,data ,nil ,nil );if _bbe !=nil {return nil ,_bbe ;};};_fcgd :=_dc .Options {};_fcgd .Quality =_ffbf .Quality ;var _gced _dd .Buffer ;
if _ege :=_dc .Encode (&_gced ,_ccab ,&_fcgd );_ege !=nil {return nil ,_ege ;};return _gced .Bytes (),nil ;};

// JBIG2Image is the image structure used by the jbig2 encoder. Its Data must be in a
// 1 bit per component and 1 component per pixel (1bpp). In order to create binary image
// use GoImageToJBIG2 function. If the image data contains the row bytes padding set the HasPadding to true.
type JBIG2Image struct{

// Width and Height defines the image boundaries.
Width ,Height int ;

// Data is the byte slice data for the input image
Data []byte ;

// HasPadding is the attribute that defines if the last byte of the data in the row contains
// 0 bits padding.
HasPadding bool ;};

// EncryptInfo contains an information generated by the document encrypter.
type EncryptInfo struct{Version ;

// Encrypt is an encryption dictionary that contains all necessary parameters.
// It should be stored in all copies of the document trailer.
Encrypt *PdfObjectDictionary ;

// ID0 and ID1 are IDs used in the trailer. Older algorithms such as RC4 uses them for encryption.
ID0 ,ID1 string ;};

// String returns the state of the bool as "true" or "false".
func (_ddf *PdfObjectBool )String ()string {if *_ddf {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};

// MakeName creates a PdfObjectName from a string.
func MakeName (s string )*PdfObjectName {_dfea :=PdfObjectName (s );return &_dfea };

// StreamEncoder represents the interface for all PDF stream encoders.
type StreamEncoder interface{GetFilterName ()string ;MakeDecodeParams ()PdfObject ;MakeStreamDict ()*PdfObjectDictionary ;UpdateParams (_aae *PdfObjectDictionary );EncodeBytes (_dcaf []byte )([]byte ,error );DecodeBytes (_deg []byte )([]byte ,error );DecodeStream (_bca *PdfObjectStream )([]byte ,error );
};

// GetXrefType returns the type of the first xref object (table or stream).
func (_eaf *PdfParser )GetXrefType ()*xrefType {return _eaf ._fced };var _ceeb =_c .MustCompile ("\u0073t\u0061r\u0074\u0078\u003f\u0072\u0065f\u005c\u0073*\u0028\u005c\u0064\u002b\u0029");type offsetReader struct{_ebefg _gg .ReadSeeker ;_aeed int64 ;};


// NewCompliancePdfParser creates a new PdfParser that will parse input reader with the focus on extracting more metadata, which
// might affect performance of the regular PdfParser this function.
func NewCompliancePdfParser (rs _gg .ReadSeeker )(_ffd *PdfParser ,_cda error ){_ffd =&PdfParser {_cgda :rs ,ObjCache :make (objectCache ),_ddede :map[int64 ]bool {},_dcfb :true ,_cggc :make (map[*PdfParser ]*PdfParser )};if _cda =_ffd .parseDetailedHeader ();
_cda !=nil {return nil ,_cda ;};if _ffd ._gdcfc ,_cda =_ffd .loadXrefs ();_cda !=nil {_fdf .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020F\u0061\u0069\u006c\u0065d t\u006f l\u006f\u0061\u0064\u0020\u0078\u0072\u0065f \u0074\u0061\u0062\u006c\u0065\u0021\u0020%\u0073",_cda );
return nil ,_cda ;};_fdf .Log .Trace ("T\u0072\u0061\u0069\u006c\u0065\u0072\u003a\u0020\u0025\u0073",_ffd ._gdcfc );if len (_ffd ._bfaa .ObjectMap )==0{return nil ,_af .Errorf ("\u0065\u006d\u0070\u0074\u0079\u0020\u0058\u0052\u0045\u0046\u0020t\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0049\u006e\u0076a\u006c\u0069\u0064");
};return _ffd ,nil ;};func (_dcag *PdfParser )parsePdfVersion ()(int ,int ,error ){var _caec int64 =20;_cgce :=make ([]byte ,_caec );_dcag ._cgda .Seek (0,_gg .SeekStart );_dcag ._cgda .Read (_cgce );var _gdge error ;var _bcada ,_dgfb int ;if _cccc :=_bacae .FindStringSubmatch (string (_cgce ));
len (_cccc )< 3{if _bcada ,_dgfb ,_gdge =_dcag .seekPdfVersionTopDown ();_gdge !=nil {_fdf .Log .Debug ("F\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065\u0063\u006f\u0076\u0065\u0072\u0079\u0020\u002d\u0020\u0075n\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0066\u0069nd\u0020\u0076\u0065r\u0073i\u006f\u006e");
return 0,0,_gdge ;};_dcag ._cgda ,_gdge =_dead (_dcag ._cgda ,_dcag .GetFileOffset ()-8);if _gdge !=nil {return 0,0,_gdge ;};}else {if _bcada ,_gdge =_a .Atoi (_cccc [1]);_gdge !=nil {return 0,0,_gdge ;};if _dgfb ,_gdge =_a .Atoi (_cccc [2]);_gdge !=nil {return 0,0,_gdge ;
};_dcag .SetFileOffset (0);};_dcag ._fbgde =_b .NewReader (_dcag ._cgda );_fdf .Log .Debug ("\u0050\u0064\u0066\u0020\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020%\u0064\u002e\u0025\u0064",_bcada ,_dgfb );return _bcada ,_dgfb ,nil ;};

// ToFloat64Array returns a slice of all elements in the array as a float64 slice.  An error is
// returned if the array contains non-numeric objects (each element can be either PdfObjectInteger
// or PdfObjectFloat).
func (_addg *PdfObjectArray )ToFloat64Array ()([]float64 ,error ){var _ceea []float64 ;for _ ,_acff :=range _addg .Elements (){switch _cdeg :=_acff .(type ){case *PdfObjectInteger :_ceea =append (_ceea ,float64 (*_cdeg ));case *PdfObjectFloat :_ceea =append (_ceea ,float64 (*_cdeg ));
default:return nil ,ErrTypeError ;};};return _ceea ,nil ;};

// PdfCryptNewDecrypt makes the document crypt handler based on the encryption dictionary
// and trailer dictionary. Returns an error on failure to process.
func PdfCryptNewDecrypt (parser *PdfParser ,ed ,trailer *PdfObjectDictionary )(*PdfCrypt ,error ){_fec :=&PdfCrypt {_abf :false ,_bbd :make (map[PdfObject ]bool ),_fcb :make (map[PdfObject ]bool ),_bga :make (map[int ]struct{}),_ada :parser };_bfc ,_eefd :=ed .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectName );
if !_eefd {_fdf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0043\u0072\u0079\u0070\u0074 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061r\u0079 \u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u0066\u0069\u0065\u006c\u0064\u0021");
return _fec ,_fb .New ("r\u0065\u0071\u0075\u0069\u0072\u0065d\u0020\u0063\u0072\u0079\u0070\u0074 \u0066\u0069\u0065\u006c\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u006d\u0069\u0073\u0073\u0069n\u0067");};if *_bfc !="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"{_fdf .Log .Debug ("\u0045\u0052R\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020(%\u0073\u0029",*_bfc );
return _fec ,_fb .New ("\u0075n\u0073u\u0070\u0070\u006f\u0072\u0074e\u0064\u0020F\u0069\u006c\u0074\u0065\u0072");};_fec ._cbc .Filter =string (*_bfc );if _cafd ,_fce :=ed .Get ("\u0053u\u0062\u0046\u0069\u006c\u0074\u0065r").(*PdfObjectString );_fce {_fec ._cbc .SubFilter =_cafd .Str ();
_fdf .Log .Debug ("\u0055s\u0069n\u0067\u0020\u0073\u0075\u0062f\u0069\u006ct\u0065\u0072\u0020\u0025\u0073",_cafd );};if L ,_dcfa :=ed .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );_dcfa {if (*L %8)!=0{_fdf .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0049\u006ev\u0061\u006c\u0069\u0064\u0020\u0065\u006ec\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006c\u0065\u006e\u0067\u0074\u0068");
return _fec ,_fb .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0065\u006e\u0063\u0072y\u0070t\u0069o\u006e\u0020\u006c\u0065\u006e\u0067\u0074h");};_fec ._cbc .Length =int (*L );}else {_fec ._cbc .Length =40;};_fec ._cbc .V =0;if _bace ,_add :=ed .Get ("\u0056").(*PdfObjectInteger );
_add {V :=int (*_bace );_fec ._cbc .V =V ;if V >=1&&V <=2{_fec ._bafb =_ggd (_fec ._cbc .Length );}else if V >=4&&V <=5{if _bcea :=_fec .loadCryptFilters (ed );_bcea !=nil {return _fec ,_bcea ;};}else {_fdf .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0061lg\u006f\u0020\u0056 \u003d \u0025\u0064",V );
return _fec ,_fb .New ("u\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d");};};if _fcc :=_decf (&_fec ._aebg ,ed );_fcc !=nil {return _fec ,_fcc ;};_gdf :="";if _eggg ,_gcb :=trailer .Get ("\u0049\u0044").(*PdfObjectArray );
_gcb &&_eggg .Len ()>=1{_dded ,_cffe :=GetString (_eggg .Get (0));if !_cffe {return _fec ,_fb .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0074r\u0061\u0069l\u0065\u0072\u0020\u0049\u0044");};_gdf =_dded .Str ();}else {_fdf .Log .Debug ("\u0054\u0072ai\u006c\u0065\u0072 \u0049\u0044\u0020\u0061rra\u0079 m\u0069\u0073\u0073\u0069\u006e\u0067\u0020or\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0021");
};_fec ._cdf =_gdf ;return _fec ,nil ;};

// ASCII85Encoder implements ASCII85 encoder/decoder.
type ASCII85Encoder struct{};

// ResolveReferencesDeep recursively traverses through object `o`, looking up and replacing
// references with indirect objects.
// Optionally a map of already deep-resolved objects can be provided via `traversed`. The `traversed` map
// is updated while traversing the objects to avoid traversing same objects multiple times.
func ResolveReferencesDeep (o PdfObject ,traversed map[PdfObject ]struct{})error {if traversed ==nil {traversed =map[PdfObject ]struct{}{};};return _acfbe (o ,0,traversed );};

// HasEOLAfterHeader gets information if there is a EOL after the version header.
func (_dgaf ParserMetadata )HasEOLAfterHeader ()bool {return _dgaf ._eaac };

// EncodeBytes implements support for LZW encoding.  Currently not supporting predictors (raw compressed data only).
// Only supports the Early change = 1 algorithm (compress/lzw) as the other implementation
// does not have a write method.
// TODO: Consider refactoring compress/lzw to allow both.
func (_aabb *LZWEncoder )EncodeBytes (data []byte )([]byte ,error ){if _aabb .Predictor !=1{return nil ,_af .Errorf ("\u004c\u005aW \u0050\u0072\u0065d\u0069\u0063\u0074\u006fr =\u00201 \u006f\u006e\u006c\u0079\u0020\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0079e\u0074");
};if _aabb .EarlyChange ==1{return nil ,_af .Errorf ("\u004c\u005a\u0057\u0020\u0045\u0061\u0072\u006c\u0079\u0020\u0043\u0068\u0061n\u0067\u0065\u0020\u003d\u0020\u0030 \u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0079\u0065\u0074");
};var _efad _dd .Buffer ;_cfcga :=_ee .NewWriter (&_efad ,_ee .MSB ,8);_cfcga .Write (data );_cfcga .Close ();return _efad .Bytes (),nil ;};func (_cgadf *PdfParser )readComment ()(string ,error ){var _gabf _dd .Buffer ;_ ,_dged :=_cgadf .skipSpaces ();
if _dged !=nil {return _gabf .String (),_dged ;};_gdbc :=true ;for {_acgff ,_efee :=_cgadf ._fbgde .Peek (1);if _efee !=nil {_fdf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_efee .Error ());return _gabf .String (),_efee ;};if _gdbc &&_acgff [0]!='%'{return _gabf .String (),_fb .New ("c\u006f\u006d\u006d\u0065\u006e\u0074 \u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0073\u0074a\u0072\u0074\u0020w\u0069t\u0068\u0020\u0025");
};_gdbc =false ;if (_acgff [0]!='\r')&&(_acgff [0]!='\n'){_aabad ,_ :=_cgadf ._fbgde .ReadByte ();_gabf .WriteByte (_aabad );}else {break ;};};return _gabf .String (),nil ;};

// MakeNull creates an PdfObjectNull.
func MakeNull ()*PdfObjectNull {_adbd :=PdfObjectNull {};return &_adbd };

// SetFileOffset sets the file to an offset position and resets buffer.
func (_dbdad *PdfParser )SetFileOffset (offset int64 ){if offset < 0{offset =0;};_dbdad ._cgda .Seek (offset ,_gg .SeekStart );_dbdad ._fbgde =_b .NewReader (_dbdad ._cgda );};func _egea (_ceab string )(int ,int ,error ){_caaae :=_bafbb .FindStringSubmatch (_ceab );
if len (_caaae )< 3{return 0,0,_fb .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");
};_beccg ,_ :=_a .Atoi (_caaae [1]);_bgbff ,_ :=_a .Atoi (_caaae [2]);return _beccg ,_bgbff ,nil ;};

// NewRawEncoder returns a new instace of RawEncoder.
func NewRawEncoder ()*RawEncoder {return &RawEncoder {}};func (_dfa *PdfCrypt )loadCryptFilters (_dff *PdfObjectDictionary )error {_dfa ._bafb =cryptFilters {};_dee :=_dff .Get ("\u0043\u0046");_dee =TraceToDirectObject (_dee );if _fa ,_cec :=_dee .(*PdfObjectReference );
_cec {_daca ,_gcgb :=_dfa ._ada .LookupByReference (*_fa );if _gcgb !=nil {_fdf .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0075\u0070\u0020\u0043\u0046\u0020\u0072\u0065\u0066\u0065\u0072en\u0063\u0065");
return _gcgb ;};_dee =TraceToDirectObject (_daca );};_eae ,_adgf :=_dee .(*PdfObjectDictionary );if !_adgf {_fdf .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0043\u0046\u002c \u0074\u0079\u0070\u0065: \u0025\u0054",_dee );return _fb .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0043\u0046");
};for _ ,_faa :=range _eae .Keys (){_fgc :=_eae .Get (_faa );if _gbga ,_cbeb :=_fgc .(*PdfObjectReference );_cbeb {_afbc ,_eab :=_dfa ._ada .LookupByReference (*_gbga );if _eab !=nil {_fdf .Log .Debug ("\u0045\u0072ro\u0072\u0020\u006co\u006f\u006b\u0075\u0070 up\u0020di\u0063\u0074\u0069\u006f\u006e\u0061\u0072y \u0072\u0065\u0066\u0065\u0072\u0065\u006ec\u0065");
return _eab ;};_fgc =TraceToDirectObject (_afbc );};_gdaf ,_dcb :=_fgc .(*PdfObjectDictionary );if !_dcb {return _af .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074\u0020\u0069\u006e \u0043\u0046\u0020\u0028\u006e\u0061\u006d\u0065\u0020\u0025\u0073\u0029\u0020-\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079\u0020\u0062\u0075\u0074\u0020\u0025\u0054",_faa ,_fgc );
};if _faa =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{_fdf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u002d\u0020\u0043\u0061\u006e\u006e\u006f\u0074\u0020\u006f\u0076\u0065\u0072\u0077r\u0069\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0069d\u0065\u006e\u0074\u0069\u0074\u0079\u0020\u0066\u0069\u006c\u0074\u0065\u0072 \u002d\u0020\u0054\u0072\u0079\u0069n\u0067\u0020\u006ee\u0078\u0074");
continue ;};var _edg _gd .FilterDict ;if _becg :=_cfe (&_edg ,_gdaf );_becg !=nil {return _becg ;};_eggf ,_gagb :=_gd .NewFilter (_edg );if _gagb !=nil {return _gagb ;};_dfa ._bafb [string (_faa )]=_eggf ;};_dfa ._bafb ["\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"]=_gd .NewIdentity ();
_dfa ._egg ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _dea ,_fac :=_dff .Get ("\u0053\u0074\u0072\u0046").(*PdfObjectName );_fac {if _ ,_dde :=_dfa ._bafb [string (*_dea )];!_dde {return _af .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u0072\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_dea );
};_dfa ._egg =string (*_dea );};_dfa ._afb ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _fbd ,_fdg :=_dff .Get ("\u0053\u0074\u006d\u0046").(*PdfObjectName );_fdg {if _ ,_ff :=_dfa ._bafb [string (*_fbd )];!_ff {return _af .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u006d\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_fbd );
};_dfa ._afb =string (*_fbd );};return nil ;};

// GetUpdatedObjects returns pdf objects which were updated from the specific version (from prevParser).
func (_ffcef *PdfParser )GetUpdatedObjects (prevParser *PdfParser )(map[int64 ]PdfObject ,error ){if prevParser ==nil {return nil ,_fb .New ("\u0070\u0072e\u0076\u0069\u006f\u0075\u0073\u0020\u0070\u0061\u0072\u0073\u0065\u0072\u0020\u0063\u0061\u006e\u0027\u0074\u0020\u0062\u0065\u0020nu\u006c\u006c");
};_dege ,_dgeda :=_ffcef .getNumbersOfUpdatedObjects (prevParser );if _dgeda !=nil {return nil ,_dgeda ;};_ageg :=make (map[int64 ]PdfObject );for _ ,_aefc :=range _dege {if _dgge ,_ebff :=_ffcef .LookupByNumber (_aefc );_ebff ==nil {_ageg [int64 (_aefc )]=_dgge ;
}else {return nil ,_ebff ;};};return _ageg ,nil ;};

// GetFilterName returns the name of the encoding filter.
func (_aegf *ASCII85Encoder )GetFilterName ()string {return StreamEncodingFilterNameASCII85 };

// UpdateParams updates the parameter values of the encoder.
func (_cfee *ASCIIHexEncoder )UpdateParams (params *PdfObjectDictionary ){};

// GetPreviousRevisionReadSeeker returns ReadSeeker for the previous version of the Pdf document.
func (_fabc *PdfParser )GetPreviousRevisionReadSeeker ()(_gg .ReadSeeker ,error ){if _bbdeg :=_fabc .seekToEOFMarker (_fabc ._gdgf -_cddc );_bbdeg !=nil {return nil ,_bbdeg ;};_eedea ,_gafd :=_fabc ._cgda .Seek (0,_gg .SeekCurrent );if _gafd !=nil {return nil ,_gafd ;
};_eedea +=_cddc ;return _agfeg (_fabc ._cgda ,_eedea );};

// UpdateParams updates the parameter values of the encoder.
func (_cbb *ASCII85Encoder )UpdateParams (params *PdfObjectDictionary ){};

// DecodeStream decodes a multi-encoded stream by passing it through the
// DecodeStream method of the underlying encoders.
func (_aeece *MultiEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _aeece .DecodeBytes (streamObj .Stream );};var _bacae =_c .MustCompile ("\u0025P\u0044F\u002d\u0028\u005c\u0064\u0029\u005c\u002e\u0028\u005c\u0064\u0029");

// JBIG2Encoder implements both jbig2 encoder and the decoder. The encoder allows to encode
// provided images (best used document scans) in multiple way. By default it uses single page generic
// encoder. It allows to store lossless data as a single segment.
// In order to store multiple image pages use the 'FileMode' which allows to store more pages within single jbig2 document.
// WIP: In order to obtain better compression results the encoder would allow to encode the input in a
// lossy or lossless way with a component (symbol) mode. It divides the image into components.
// Then checks if any component is 'similar' to the others and maps them together. The symbol classes are stored
// in the dictionary. Then the encoder creates text regions which uses the related symbol classes to fill it's space.
// The similarity is defined by the 'Threshold' variable (default: 0.95). The less the value is, the more components
// matches to single class, thus the compression is better, but the result might become lossy.
type JBIG2Encoder struct{

// These values are required to be set for the 'EncodeBytes' method.
// ColorComponents defines the number of color components for provided image.
ColorComponents int ;

// BitsPerComponent is the number of bits that stores per color component
BitsPerComponent int ;

// Width is the width of the image to encode
Width int ;

// Height is the height of the image to encode.
Height int ;_bege *_ga .Document ;

// Globals are the JBIG2 global segments.
Globals _cea .Globals ;

// IsChocolateData defines if the data is encoded such that
// binary data '1' means black and '0' white.
// otherwise the data is called vanilla.
// Naming convention taken from: 'https://en.wikipedia.org/wiki/Binary_image#Interpretation'
IsChocolateData bool ;

// DefaultPageSettings are the settings parameters used by the jbig2 encoder.
DefaultPageSettings JBIG2EncoderSettings ;};

// NewEncoderFromStream creates a StreamEncoder based on the stream's dictionary.
func NewEncoderFromStream (streamObj *PdfObjectStream )(StreamEncoder ,error ){_ecgab :=TraceToDirectObject (streamObj .PdfObjectDictionary .Get ("\u0046\u0069\u006c\u0074\u0065\u0072"));if _ecgab ==nil {return NewRawEncoder (),nil ;};if _ ,_cafga :=_ecgab .(*PdfObjectNull );
_cafga {return NewRawEncoder (),nil ;};_egga ,_gfbg :=_ecgab .(*PdfObjectName );if !_gfbg {_cgecg ,_gdeb :=_ecgab .(*PdfObjectArray );if !_gdeb {return nil ,_af .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006f\u0072 \u0041\u0072\u0072\u0061\u0079\u0020\u006fb\u006a\u0065\u0063\u0074");
};if _cgecg .Len ()==0{return NewRawEncoder (),nil ;};if _cgecg .Len ()!=1{_fdbcg ,_fafac :=_bccgb (streamObj );if _fafac !=nil {_fdf .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0063\u0072\u0065\u0061\u0074\u0069\u006e\u0067\u0020\u006d\u0075\u006c\u0074i\u0020\u0065\u006e\u0063\u006f\u0064\u0065r\u003a\u0020\u0025\u0076",_fafac );
return nil ,_fafac ;};_fdf .Log .Trace ("\u004d\u0075\u006c\u0074\u0069\u0020\u0065\u006e\u0063:\u0020\u0025\u0073\u000a",_fdbcg );return _fdbcg ,nil ;};_ecgab =_cgecg .Get (0);_egga ,_gdeb =_ecgab .(*PdfObjectName );if !_gdeb {return nil ,_af .Errorf ("\u0066\u0069l\u0074\u0065\u0072\u0020a\u0072\u0072a\u0079\u0020\u006d\u0065\u006d\u0062\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006fb\u006a\u0065\u0063\u0074");
};};if _fcec ,_addb :=_ffebb .Load (_egga .String ());_addb {return _fcec .(StreamEncoder ),nil ;};switch *_egga {case StreamEncodingFilterNameFlate :return _dgfa (streamObj ,nil );case StreamEncodingFilterNameLZW :return _dcafe (streamObj ,nil );case StreamEncodingFilterNameDCT :return _gfc (streamObj ,nil );
case StreamEncodingFilterNameRunLength :return _dbde (streamObj ,nil );case StreamEncodingFilterNameASCIIHex :return NewASCIIHexEncoder (),nil ;case StreamEncodingFilterNameASCII85 ,"\u0041\u0038\u0035":return NewASCII85Encoder (),nil ;case StreamEncodingFilterNameCCITTFax :return _edcb (streamObj ,nil );
case StreamEncodingFilterNameJBIG2 :return _fbcf (streamObj ,nil );case StreamEncodingFilterNameJPX :return NewJPXEncoder (),nil ;};_fdf .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064\u0069\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006fd\u0021");
return nil ,_af .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064i\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006f\u0064\u0020\u0028\u0025\u0073\u0029",*_egga );};type objectStreams map[int ]objectStream ;


// MakeStream creates an PdfObjectStream with specified contents and encoding. If encoding is nil, then raw encoding
// will be used (i.e. no encoding applied).
func MakeStream (contents []byte ,encoder StreamEncoder )(*PdfObjectStream ,error ){_ffee :=&PdfObjectStream {};if encoder ==nil {encoder =NewRawEncoder ();};_ffee .PdfObjectDictionary =encoder .MakeStreamDict ();_bbce ,_fgbc :=encoder .EncodeBytes (contents );
if _fgbc !=nil {return nil ,_fgbc ;};_ffee .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_bbce ))));_ffee .Stream =_bbce ;return _ffee ,nil ;};

// GetXrefTable returns the PDFs xref table.
func (_bdcf *PdfParser )GetXrefTable ()XrefTable {return _bdcf ._bfaa };func (_agbe *PdfObjectDictionary )setWithLock (_ffac PdfObjectName ,_dbddf PdfObject ,_fbaf bool ){if _fbaf {_agbe ._dggf .Lock ();defer _agbe ._dggf .Unlock ();};_ ,_geab :=_agbe ._cgbf [_ffac ];
if !_geab {_agbe ._aadg =append (_agbe ._aadg ,_ffac );};_agbe ._cgbf [_ffac ]=_dbddf ;};func (_gec *ASCII85Encoder )base256Tobase85 (_bcag uint32 )[5]byte {_bgaa :=[5]byte {0,0,0,0,0};_cdbd :=_bcag ;for _cedd :=0;_cedd < 5;_cedd ++{_cga :=uint32 (1);for _bbagf :=0;
_bbagf < 4-_cedd ;_bbagf ++{_cga *=85;};_abfc :=_cdbd /_cga ;_cdbd =_cdbd %_cga ;_bgaa [_cedd ]=byte (_abfc );};return _bgaa ;};

// RunLengthEncoder represents Run length encoding.
type RunLengthEncoder struct{};

// GetNumberAsInt64 returns the contents of `obj` as an int64 if it is an integer or float, or an
// error if it isn't. This is for cases where expecting an integer, but some implementations
// actually store the number in a floating point format.
func GetNumberAsInt64 (obj PdfObject )(int64 ,error ){_aacae ,_facdd :=obj .(*PdfObjectReference );if _facdd {obj =TraceToDirectObject (_aacae );}else if _fbcfa ,_dbcf :=obj .(*PdfIndirectObject );_dbcf {obj =_fbcfa .PdfObject ;};switch _aggg :=obj .(type ){case *PdfObjectFloat :_fdf .Log .Debug ("\u004e\u0075m\u0062\u0065\u0072\u0020\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0061\u0073\u0020\u0069\u006e\u0074e\u0067\u0065\u0072\u0020\u0077\u0061s\u0020\u0073\u0074\u006f\u0072\u0065\u0064\u0020\u0061\u0073\u0020\u0066\u006c\u006fa\u0074\u0020(\u0074\u0079\u0070\u0065 \u0063\u0061\u0073\u0074\u0069n\u0067\u0020\u0075\u0073\u0065\u0064\u0029");
return int64 (*_aggg ),nil ;case *PdfObjectInteger :return int64 (*_aggg ),nil ;};return 0,ErrNotANumber ;};

// DecodeStream implements ASCII85 stream decoding.
func (_afaf *ASCII85Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _afaf .DecodeBytes (streamObj .Stream );};

// GetFloat returns the *PdfObjectFloat represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetFloat (obj PdfObject )(_adedb *PdfObjectFloat ,_eddc bool ){_adedb ,_eddc =TraceToDirectObject (obj ).(*PdfObjectFloat );return _adedb ,_eddc ;};

// WriteString outputs the object as it is to be written to file.
func (_dddg *PdfObjectNull )WriteString ()string {return "\u006e\u0075\u006c\u006c"};

// PdfObject is an interface which all primitive PDF objects must implement.
type PdfObject interface{

// String outputs a string representation of the primitive (for debugging).
String ()string ;

// WriteString outputs the PDF primitive as written to file as expected by the standard.
// TODO(dennwc): it should return a byte slice, or accept a writer
WriteString ()string ;};func (_agc *PdfParser )checkPostEOFData ()error {const _gga ="\u0025\u0025\u0045O\u0046";_ ,_ebgb :=_agc ._cgda .Seek (-int64 (len ([]byte (_gga )))-1,_gg .SeekEnd );if _ebgb !=nil {return _ebgb ;};_aab :=make ([]byte ,len ([]byte (_gga ))+1);
_ ,_ebgb =_agc ._cgda .Read (_aab );if _ebgb !=nil {if _ebgb !=_gg .EOF {return _ebgb ;};};if string (_aab )==_gga ||string (_aab )==_gga +"\u000a"{_agc ._aadf ._fdc =true ;};return nil ;};

// ResolveReference resolves reference if `o` is a *PdfObjectReference and returns the object referenced to.
// Otherwise returns back `o`.
func ResolveReference (obj PdfObject )PdfObject {if _adae ,_abdg :=obj .(*PdfObjectReference );_abdg {return _adae .Resolve ();};return obj ;};func (_geec *limitedReadSeeker )getError (_ccgd int64 )error {switch {case _ccgd < 0:return _af .Errorf ("\u0075\u006e\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064 \u006e\u0065\u0067\u0061\u0074\u0069\u0076e\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u003a\u0020\u0025\u0064",_ccgd );
case _ccgd > _geec ._aggf :return _af .Errorf ("u\u006e\u0065\u0078\u0070ec\u0074e\u0064\u0020\u006f\u0066\u0066s\u0065\u0074\u003a\u0020\u0025\u0064",_ccgd );};return nil ;};type cryptFilters map[string ]_gd .Filter ;

// HasNonConformantStream implements core.ParserMetadata.
func (_bbcg ParserMetadata )HasNonConformantStream ()bool {return _bbcg ._afd };

// PdfObjectName represents the primitive PDF name object.
type PdfObjectName string ;

// PdfObjectBool represents the primitive PDF boolean object.
type PdfObjectBool bool ;

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_ebef *RunLengthEncoder )MakeStreamDict ()*PdfObjectDictionary {_dgaa :=MakeDict ();_dgaa .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_ebef .GetFilterName ()));return _dgaa ;};

// DecodeStream decodes a JPX encoded stream and returns the result as a
// slice of bytes.
func (_dbga *JPXEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_fdf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_dbga .GetFilterName ());
return streamObj .Stream ,ErrNoJPXDecode ;};

// WriteString outputs the object as it is to be written to file.
func (_addgd *PdfObjectDictionary )WriteString ()string {var _efdde _eaa .Builder ;_efdde .WriteString ("\u003c\u003c");for _ ,_geca :=range _addgd ._aadg {_geea :=_addgd ._cgbf [_geca ];_efdde .WriteString (_geca .WriteString ());_efdde .WriteString ("\u0020");
_efdde .WriteString (_geea .WriteString ());};_efdde .WriteString ("\u003e\u003e");return _efdde .String ();};

// GetTrailer returns the PDFs trailer dictionary. The trailer dictionary is typically the starting point for a PDF,
// referencing other key objects that are important in the document structure.
func (_bfef *PdfParser )GetTrailer ()*PdfObjectDictionary {return _bfef ._gdcfc };

// WriteString outputs the object as it is to be written to file.
func (_ead *PdfObjectReference )WriteString ()string {var _ecbc _eaa .Builder ;_ecbc .WriteString (_a .FormatInt (_ead .ObjectNumber ,10));_ecbc .WriteString ("\u0020");_ecbc .WriteString (_a .FormatInt (_ead .GenerationNumber ,10));_ecbc .WriteString ("\u0020\u0052");
return _ecbc .String ();};func (_eddb *PdfParser )xrefNextObjectOffset (_ffcd int64 )int64 {_egae :=int64 (0);if len (_eddb ._bfaa .ObjectMap )==0{return 0;};if len (_eddb ._bfaa ._be )==0{_ebfe :=0;for _ ,_bafgc :=range _eddb ._bfaa .ObjectMap {if _bafgc .Offset > 0{_ebfe ++;
};};if _ebfe ==0{return 0;};_eddb ._bfaa ._be =make ([]XrefObject ,_ebfe );_abed :=0;for _ ,_cgdf :=range _eddb ._bfaa .ObjectMap {if _cgdf .Offset > 0{_eddb ._bfaa ._be [_abed ]=_cgdf ;_abed ++;};};_d .Slice (_eddb ._bfaa ._be ,func (_ceee ,_edgd int )bool {return _eddb ._bfaa ._be [_ceee ].Offset < _eddb ._bfaa ._be [_edgd ].Offset });
};_cfca :=_d .Search (len (_eddb ._bfaa ._be ),func (_fceea int )bool {return _eddb ._bfaa ._be [_fceea ].Offset >=_ffcd });if _cfca < len (_eddb ._bfaa ._be ){_egae =_eddb ._bfaa ._be [_cfca ].Offset ;};return _egae ;};

// GetCrypter returns the PdfCrypt instance which has information about the PDFs encryption.
func (_cacd *PdfParser )GetCrypter ()*PdfCrypt {return _cacd ._adfa };

// DecodeStream returns the passed in stream as a slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_gcbf *RawEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return streamObj .Stream ,nil ;};

// Append appends PdfObject(s) to the array.
func (_eaacc *PdfObjectArray )Append (objects ...PdfObject ){if _eaacc ==nil {_fdf .Log .Debug ("\u0057\u0061\u0072\u006e\u0020\u002d\u0020\u0041\u0074\u0074\u0065\u006d\u0070t\u0020\u0074\u006f\u0020\u0061\u0070p\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020a\u0072\u0072\u0061\u0079");
return ;};_eaacc ._beeag =append (_eaacc ._beeag ,objects ...);};func _beba (_bacaf int )int {_becd :=_bacaf >>(_bfg -1);return (_bacaf ^_becd )-_becd };func (_dgada *PdfParser )repairLocateXref ()(int64 ,error ){_ebee :=int64 (1000);_dgada ._cgda .Seek (-_ebee ,_gg .SeekCurrent );
_ffgda ,_feff :=_dgada ._cgda .Seek (0,_gg .SeekCurrent );if _feff !=nil {return 0,_feff ;};_ccbd :=make ([]byte ,_ebee );_dgada ._cgda .Read (_ccbd );_caaf :=_fcge .FindAllStringIndex (string (_ccbd ),-1);if len (_caaf )< 1{_fdf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0065\u0070a\u0069\u0072\u003a\u0020\u0078\u0072\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021");
return 0,_fb .New ("\u0072\u0065\u0070\u0061ir\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064");};_ebdgb :=int64 (_caaf [len (_caaf )-1][0]);_accg :=_ffgda +_ebdgb ;return _accg ,nil ;};

// MakeStreamDict make a new instance of an encoding dictionary for a stream object.
func (_aaga *ASCII85Encoder )MakeStreamDict ()*PdfObjectDictionary {_fcbb :=MakeDict ();_fcbb .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_aaga .GetFilterName ()));return _fcbb ;};

// GetNameVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetNameVal (obj PdfObject )(_ffab string ,_efeeb bool ){_bdbbb ,_efeeb :=TraceToDirectObject (obj ).(*PdfObjectName );if _efeeb {return string (*_bdbbb ),true ;};return ;};

// EncodeStream encodes the stream data using the encoded specified by the stream's dictionary.
func EncodeStream (streamObj *PdfObjectStream )error {_fdf .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_dgdc ,_efeb :=NewEncoderFromStream (streamObj );if _efeb !=nil {_fdf .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_efeb );
return _efeb ;};if _abgag ,_ebec :=_dgdc .(*LZWEncoder );_ebec {_abgag .EarlyChange =0;streamObj .PdfObjectDictionary .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (0));};_fdf .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076\u000a",_dgdc );
_afcca ,_efeb :=_dgdc .EncodeBytes (streamObj .Stream );if _efeb !=nil {_fdf .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_efeb );return _efeb ;
};streamObj .Stream =_afcca ;streamObj .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_afcca ))));return nil ;};

// DecodeStream decodes the stream containing CCITTFax encoded image data.
func (_bcgaf *CCITTFaxEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _bcgaf .DecodeBytes (streamObj .Stream );};

// IsOctalDigit checks if a character can be part of an octal digit string.
func IsOctalDigit (c byte )bool {return '0'<=c &&c <='7'};

// GetString is a helper for Get that returns a string value.
// Returns false if the key is missing or a value is not a string.
func (_aceb *PdfObjectDictionary )GetString (key PdfObjectName )(string ,bool ){_bebba :=_aceb .Get (key );if _bebba ==nil {return "",false ;};_ceddb ,_ecgae :=_bebba .(*PdfObjectString );if !_ecgae {return "",false ;};return _ceddb .Str (),true ;};func (_gafc *PdfParser )parseLinearizedDictionary ()(*PdfObjectDictionary ,error ){_gggf ,_fgca :=_gafc ._cgda .Seek (0,_gg .SeekEnd );
if _fgca !=nil {return nil ,_fgca ;};var _bbge int64 ;var _ddgf int64 =2048;for _bbge < _gggf -4{if _gggf <=(_ddgf +_bbge ){_ddgf =_gggf -_bbge ;};_ ,_gcba :=_gafc ._cgda .Seek (_bbge ,_gg .SeekStart );if _gcba !=nil {return nil ,_gcba ;};_afff :=make ([]byte ,_ddgf );
_ ,_gcba =_gafc ._cgda .Read (_afff );if _gcba !=nil {return nil ,_gcba ;};_fdf .Log .Trace ("\u004c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0066i\u0072\u0073\u0074\u0020\u0069\u006ed\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u003a \u0022\u0025\u0073\u0022",string (_afff ));
_aeecc :=_bafbb .FindAllStringIndex (string (_afff ),-1);if _aeecc !=nil {_dafag :=_aeecc [0];_fdf .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_aeecc );_ ,_ggcb :=_gafc ._cgda .Seek (int64 (_dafag [0]),_gg .SeekStart );if _ggcb !=nil {return nil ,_ggcb ;
};_gafc ._fbgde =_b .NewReader (_gafc ._cgda );_cecf ,_ggcb :=_gafc .ParseIndirectObject ();if _ggcb !=nil {return nil ,nil ;};if _deea ,_eaebg :=GetIndirect (_cecf );_eaebg {if _aegg ,_aabe :=GetDict (_deea .PdfObject );_aabe {if _gbfg :=_aegg .Get ("\u004c\u0069\u006e\u0065\u0061\u0072\u0069\u007a\u0065\u0064");
_gbfg !=nil {return _aegg ,nil ;};return nil ,nil ;};};return nil ,nil ;};_bbge +=_ddgf -4;};return nil ,_fb .New ("\u0074\u0068\u0065\u0020\u0066\u0069\u0072\u0073\u0074\u0020\u006fb\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0066o\u0075\u006e\u0064");
};const _cfg ="\u0053\u0074\u0064C\u0046";var _fcfd =_c .MustCompile ("\u005e\u005b\\\u002b\u002d\u002e\u005d*\u0028\u005b0\u002d\u0039\u002e\u005d\u002b\u0029\u005b\u0065E\u005d\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");


// MakeFloat creates an PdfObjectFloat from a float64.
func MakeFloat (val float64 )*PdfObjectFloat {_afbg :=PdfObjectFloat (val );return &_afbg };

// GetStream returns the *PdfObjectStream represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetStream (obj PdfObject )(_cdea *PdfObjectStream ,_cfdf bool ){obj =ResolveReference (obj );_cdea ,_cfdf =obj .(*PdfObjectStream );return _cdea ,_cfdf ;};

// GetIntVal returns the int value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetIntVal (obj PdfObject )(_feaca int ,_fgbf bool ){_cead ,_fgbf :=TraceToDirectObject (obj ).(*PdfObjectInteger );if _fgbf &&_cead !=nil {return int (*_cead ),true ;};return 0,false ;};var _gcfg =_c .MustCompile ("\u0025\u0025\u0045\u004f\u0046\u003f");


// IsEncrypted checks if the document is encrypted. A bool flag is returned indicating the result.
// First time when called, will check if the Encrypt dictionary is accessible through the trailer dictionary.
// If encrypted, prepares a crypt datastructure which can be used to authenticate and decrypt the document.
// On failure, an error is returned.
func (_bgba *PdfParser )IsEncrypted ()(bool ,error ){if _bgba ._adfa !=nil {return true ,nil ;}else if _bgba ._gdcfc ==nil {return false ,nil ;};_fdf .Log .Trace ("\u0043\u0068\u0065c\u006b\u0069\u006e\u0067 \u0065\u006e\u0063\u0072\u0079\u0070\u0074i\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0021");
_eagc :=_bgba ._gdcfc .Get ("\u0045n\u0063\u0072\u0079\u0070\u0074");if _eagc ==nil {return false ,nil ;};_fdf .Log .Trace ("\u0049\u0073\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u0021");var (_fdgf *PdfObjectDictionary ;);switch _dgadb :=_eagc .(type ){case *PdfObjectDictionary :_fdgf =_dgadb ;
case *PdfObjectReference :_fdf .Log .Trace ("\u0030\u003a\u0020\u004c\u006f\u006f\u006b\u0020\u0075\u0070\u0020\u0072e\u0066\u0020\u0025\u0071",_dgadb );_aade ,_bccgd :=_bgba .LookupByReference (*_dgadb );_fdf .Log .Trace ("\u0031\u003a\u0020%\u0071",_aade );
if _bccgd !=nil {return false ,_bccgd ;};_fega ,_gdgfcg :=_aade .(*PdfIndirectObject );if !_gdgfcg {_fdf .Log .Debug ("E\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006eo\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072ec\u0074\u0020\u006fb\u006ae\u0063\u0074");
return false ,_fb .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");};_fcga ,_gdgfcg :=_fega .PdfObject .(*PdfObjectDictionary );_bgba ._gdgfc =_fega ;_fdf .Log .Trace ("\u0032\u003a\u0020%\u0071",_fcga );if !_gdgfcg {return false ,_fb .New ("\u0074\u0072a\u0069\u006c\u0065\u0072 \u0045\u006ec\u0072\u0079\u0070\u0074\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u006e\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");
};_fdgf =_fcga ;case *PdfObjectNull :_fdf .Log .Debug ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074 \u0069\u0073\u0020a\u0020\u006e\u0075l\u006c\u0020o\u0062\u006a\u0065\u0063\u0074\u002e \u0046il\u0065\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u002e");
return false ,nil ;default:return false ,_af .Errorf ("u\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0079\u0070\u0065: \u0025\u0054",_dgadb );};_dage ,_cgafc :=PdfCryptNewDecrypt (_bgba ,_fdgf ,_bgba ._gdcfc );if _cgafc !=nil {return false ,_cgafc ;
};for _ ,_edebb :=range []string {"\u0045n\u0063\u0072\u0079\u0070\u0074"}{_aagg :=_bgba ._gdcfc .Get (PdfObjectName (_edebb ));if _aagg ==nil {continue ;};switch _fdcg :=_aagg .(type ){case *PdfObjectReference :_dage ._bga [int (_fdcg .ObjectNumber )]=struct{}{};
case *PdfIndirectObject :_dage ._bbd [_fdcg ]=true ;_dage ._bga [int (_fdcg .ObjectNumber )]=struct{}{};};};_bgba ._adfa =_dage ;_fdf .Log .Trace ("\u0043\u0072\u0079\u0070\u0074\u0065\u0072\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0025\u0062",_dage );
return true ,nil ;};

// MakeDictMap creates a PdfObjectDictionary initialized from a map of keys to values.
func MakeDictMap (objmap map[string ]PdfObject )*PdfObjectDictionary {_bfcbc :=MakeDict ();return _bfcbc .Update (objmap );};

// DrawableImage is same as golang image/draw's Image interface that allow drawing images.
type DrawableImage interface{ColorModel ()_aa .Model ;Bounds ()_fg .Rectangle ;At (_bde ,_ggee int )_aa .Color ;Set (_cacfa ,_eacf int ,_edeb _aa .Color );};

// Resolve resolves the reference and returns the indirect or stream object.
// If the reference cannot be resolved, a *PdfObjectNull object is returned.
func (_cecbf *PdfObjectReference )Resolve ()PdfObject {if _cecbf ._gdad ==nil {return MakeNull ();};_gacf ,_ ,_feggd :=_cecbf ._gdad .resolveReference (_cecbf );if _feggd !=nil {_fdf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0072\u0065\u0073\u006f\u006cv\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065r\u0065n\u0063\u0065\u003a\u0020\u0025\u0076\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074",_feggd );
return MakeNull ();};if _gacf ==nil {_fdf .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0072\u0065\u0073ol\u0076\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065:\u0020\u006ei\u006c\u0020\u006fb\u006a\u0065\u0063\u0074\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u0061\u0020nu\u006c\u006c\u0020o\u0062\u006a\u0065\u0063\u0074");
return MakeNull ();};return _gacf ;};func (_ec *PdfParser )lookupObjectViaOS (_fga int ,_ag int )(PdfObject ,error ){var _becf *_dd .Reader ;var _cc objectStream ;var _cf bool ;_cc ,_cf =_ec ._fgfg [_fga ];if !_cf {_gag ,_cff :=_ec .LookupByNumber (_fga );
if _cff !=nil {_fdf .Log .Debug ("\u004d\u0069ss\u0069\u006e\u0067 \u006f\u0062\u006a\u0065ct \u0073tr\u0065\u0061\u006d\u0020\u0077\u0069\u0074h \u006e\u0075\u006d\u0062\u0065\u0072\u0020%\u0064",_fga );return nil ,_cff ;};_ab ,_ae :=_gag .(*PdfObjectStream );
if !_ae {return nil ,_fb .New ("i\u006e\u0076\u0061\u006cid\u0020o\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d");};if _ec ._adfa !=nil &&!_ec ._adfa .isDecrypted (_ab ){return nil ,_fb .New ("\u006e\u0065\u0065\u0064\u0020\u0074\u006f\u0020\u0064\u0065\u0063r\u0079\u0070\u0074\u0020\u0074\u0068\u0065\u0020\u0073\u0074r\u0065\u0061\u006d");
};_ba :=_ab .PdfObjectDictionary ;_fdf .Log .Trace ("\u0073o\u0020\u0064\u003a\u0020\u0025\u0073\n",_ba .String ());_da ,_ae :=_ba .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if !_ae {_fdf .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0061\u006c\u0077\u0061\u0079\u0073\u0020\u0068\u0061\u0076\u0065\u0020\u0061\u0020\u0054\u0079\u0070\u0065");
return nil ,_fb .New ("\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020T\u0079\u0070\u0065");};if _eaa .ToLower (string (*_da ))!="\u006f\u0062\u006a\u0073\u0074\u006d"{_fdf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0074\u0079\u0070\u0065\u0020s\u0068\u0061\u006c\u006c\u0020\u0061\u006c\u0077\u0061\u0079\u0073 \u0062\u0065\u0020\u004f\u0062\u006a\u0053\u0074\u006d\u0020\u0021");
return nil ,_fb .New ("\u006f\u0062\u006a\u0065c\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0074y\u0070e\u0020\u0021\u003d\u0020\u004f\u0062\u006aS\u0074\u006d");};N ,_ae :=_ba .Get ("\u004e").(*PdfObjectInteger );if !_ae {return nil ,_fb .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u004e\u0020i\u006e\u0020\u0073\u0074\u0072\u0065\u0061m\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");
};_ef ,_ae :=_ba .Get ("\u0046\u0069\u0072s\u0074").(*PdfObjectInteger );if !_ae {return nil ,_fb .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0046\u0069\u0072\u0073\u0074\u0020i\u006e \u0073t\u0072e\u0061\u006d\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");
};_fdf .Log .Trace ("\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0073\u0020\u006eu\u006d\u0062\u0065\u0072\u0020\u006f\u0066 \u006f\u0062\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_da ,*N );_ca ,_cff :=DecodeStream (_ab );if _cff !=nil {return nil ,_cff ;
};_fdf .Log .Trace ("D\u0065\u0063\u006f\u0064\u0065\u0064\u003a\u0020\u0025\u0073",_ca );_bgc :=_ec .GetFileOffset ();defer func (){_ec .SetFileOffset (_bgc )}();_becf =_dd .NewReader (_ca );_ec ._fbgde =_b .NewReader (_becf );_fdf .Log .Trace ("\u0050a\u0072s\u0069\u006e\u0067\u0020\u006ff\u0066\u0073e\u0074\u0020\u006d\u0061\u0070");
_df :=map[int ]int64 {};for _dfe :=0;_dfe < int (*N );_dfe ++{_ec .skipSpaces ();_eg ,_ged :=_ec .parseNumber ();if _ged !=nil {return nil ,_ged ;};_cbe ,_dfb :=_eg .(*PdfObjectInteger );if !_dfb {return nil ,_fb .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");
};_ec .skipSpaces ();_eg ,_ged =_ec .parseNumber ();if _ged !=nil {return nil ,_ged ;};_db ,_dfb :=_eg .(*PdfObjectInteger );if !_dfb {return nil ,_fb .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");
};_fdf .Log .Trace ("\u006f\u0062j\u0020\u0025\u0064 \u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0025\u0064",*_cbe ,*_db );_df [int (*_cbe )]=int64 (*_ef +*_db );};_cc =objectStream {N :int (*N ),_bc :_ca ,_bec :_df };_ec ._fgfg [_fga ]=_cc ;}else {_gbb :=_ec .GetFileOffset ();
defer func (){_ec .SetFileOffset (_gbb )}();_becf =_dd .NewReader (_cc ._bc );_ec ._fbgde =_b .NewReader (_becf );};_fea :=_cc ._bec [_ag ];_fdf .Log .Trace ("\u0041\u0043\u0054\u0055AL\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u005b\u0025\u0064\u005d\u0020\u003d\u0020%\u0064",_ag ,_fea );
_becf .Seek (_fea ,_gg .SeekStart );_ec ._fbgde =_b .NewReader (_becf );_egf ,_ :=_ec ._fbgde .Peek (100);_fdf .Log .Trace ("\u004f\u0042\u004a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_egf ));_ceae ,_bb :=_ec .parseObject ();
if _bb !=nil {_fdf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c \u0074\u006f\u0020\u0072\u0065\u0061\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_bb );return nil ,_bb ;};if _ceae ==nil {return nil ,_fb .New ("o\u0062\u006a\u0065\u0063t \u0063a\u006e\u006e\u006f\u0074\u0020b\u0065\u0020\u006e\u0075\u006c\u006c");
};_afa :=PdfIndirectObject {};_afa .ObjectNumber =int64 (_ag );_afa .PdfObject =_ceae ;_afa ._gdad =_ec ;return &_afa ,nil ;};func (_gbbf *PdfCrypt )checkAccessRights (_dgd []byte )(bool ,_ge .Permissions ,error ){_agd :=_gbbf .securityHandler ();_fgd ,_cgb ,_acae :=_agd .Authenticate (&_gbbf ._aebg ,_dgd );
if _acae !=nil {return false ,0,_acae ;}else if _cgb ==0||len (_fgd )==0{return false ,0,nil ;};return true ,_cgb ,nil ;};

// MakeArrayFromIntegers creates an PdfObjectArray from a slice of ints, where each array element is
// an PdfObjectInteger.
func MakeArrayFromIntegers (vals []int )*PdfObjectArray {_debae :=MakeArray ();for _ ,_gaaa :=range vals {_debae .Append (MakeInteger (int64 (_gaaa )));};return _debae ;};

// UpdateParams updates the parameter values of the encoder.
func (_fgg *RunLengthEncoder )UpdateParams (params *PdfObjectDictionary ){};

// GetStringBytes is like GetStringVal except that it returns the string as a []byte.
// It is for convenience.
func GetStringBytes (obj PdfObject )(_acag []byte ,_eddcb bool ){_edab ,_eddcb :=TraceToDirectObject (obj ).(*PdfObjectString );if _eddcb {return _edab .Bytes (),true ;};return ;};func (_aega *PdfParser )parseXrefTable ()(*PdfObjectDictionary ,error ){var _ffgbb *PdfObjectDictionary ;
_baae ,_debe :=_aega .readTextLine ();if _debe !=nil {return nil ,_debe ;};if _aega ._dcfb &&_eaa .Count (_eaa .TrimPrefix (_baae ,"\u0078\u0072\u0065\u0066"),"\u0020")> 0{_aega ._aadf ._bcf =true ;};_fdf .Log .Trace ("\u0078\u0072\u0065\u0066 f\u0069\u0072\u0073\u0074\u0020\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_baae );
_cccf :=-1;_afae :=0;_gcee :=false ;_cgfge :="";for {_aega .skipSpaces ();_ ,_cgaf :=_aega ._fbgde .Peek (1);if _cgaf !=nil {return nil ,_cgaf ;};_baae ,_cgaf =_aega .readTextLine ();if _cgaf !=nil {return nil ,_cgaf ;};_gdbff :=_fffa .FindStringSubmatch (_baae );
if len (_gdbff )==0{_bcbe :=len (_cgfge )> 0;_cgfge +=_baae +"\u000a";if _bcbe {_gdbff =_fffa .FindStringSubmatch (_cgfge );};};if len (_gdbff )==3{if _aega ._dcfb &&!_aega ._aadf ._dfde {var (_fddc bool ;_ddge int ;);for _ ,_bgeab :=range _baae {if _e .IsDigit (_bgeab ){if _fddc {break ;
};continue ;};if !_fddc {_fddc =true ;};_ddge ++;};if _ddge > 1{_aega ._aadf ._dfde =true ;};};_cdgd ,_ :=_a .Atoi (_gdbff [1]);_ffga ,_ :=_a .Atoi (_gdbff [2]);_cccf =_cdgd ;_afae =_ffga ;_gcee =true ;_cgfge ="";_fdf .Log .Trace ("\u0078r\u0065\u0066 \u0073\u0075\u0062s\u0065\u0063\u0074\u0069\u006f\u006e\u003a \u0066\u0069\u0072\u0073\u0074\u0020o\u0062\u006a\u0065\u0063\u0074\u003a\u0020\u0025\u0064\u0020\u006fb\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_cccf ,_afae );
continue ;};_eefe :=_eefb .FindStringSubmatch (_baae );if len (_eefe )==4{if !_gcee {_fdf .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0058r\u0065\u0066\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u006fr\u006da\u0074\u0021\u000a");return nil ,_fb .New ("\u0078\u0072\u0065\u0066 i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072\u006d\u0061\u0074");
};_cfbg ,_ :=_a .ParseInt (_eefe [1],10,64);_beaca ,_ :=_a .Atoi (_eefe [2]);_becae :=_eefe [3];_cgfge ="";if _eaa .ToLower (_becae )=="\u006e"&&_cfbg > 1{_eaebf ,_cdgb :=_aega ._bfaa .ObjectMap [_cccf ];if !_cdgb ||_beaca > _eaebf .Generation {_cgee :=XrefObject {ObjectNumber :_cccf ,XType :XrefTypeTableEntry ,Offset :_cfbg ,Generation :_beaca };
_aega ._bfaa .ObjectMap [_cccf ]=_cgee ;};};_cccf ++;continue ;};if (len (_baae )> 6)&&(_baae [:7]=="\u0074r\u0061\u0069\u006c\u0065\u0072"){_fdf .Log .Trace ("\u0046o\u0075n\u0064\u0020\u0074\u0072\u0061i\u006c\u0065r\u0020\u002d\u0020\u0025\u0073",_baae );
if len (_baae )> 9{_fabf :=_aega .GetFileOffset ();_aega .SetFileOffset (_fabf -int64 (len (_baae ))+7);};_aega .skipSpaces ();_aega .skipComments ();_fdf .Log .Trace ("R\u0065\u0061\u0064\u0069ng\u0020t\u0072\u0061\u0069\u006c\u0065r\u0020\u0064\u0069\u0063\u0074\u0021");
_fdf .Log .Trace ("\u0070\u0065\u0065\u006b\u003a\u0020\u0022\u0025\u0073\u0022",_baae );_ffgbb ,_cgaf =_aega .ParseDict ();_fdf .Log .Trace ("\u0045O\u0046\u0020\u0072\u0065a\u0064\u0069\u006e\u0067\u0020t\u0072a\u0069l\u0065\u0072\u0020\u0064\u0069\u0063\u0074!");
if _cgaf !=nil {_fdf .Log .Debug ("\u0045\u0072\u0072o\u0072\u0020\u0070\u0061r\u0073\u0069\u006e\u0067\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u0064\u0069\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_cgaf );return nil ,_cgaf ;};break ;};if _baae =="\u0025\u0025\u0045O\u0046"{_fdf .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006e\u0064 \u006f\u0066\u0020\u0066\u0069\u006c\u0065 -\u0020\u0074\u0072\u0061i\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066ou\u006e\u0064 \u002d\u0020\u0065\u0072\u0072\u006f\u0072\u0021");
return nil ,_fb .New ("\u0065\u006e\u0064 \u006f\u0066\u0020\u0066i\u006c\u0065\u0020\u002d\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};_fdf .Log .Trace ("\u0078\u0072\u0065\u0066\u0020\u006d\u006f\u0072\u0065 \u003a\u0020\u0025\u0073",_baae );
};_fdf .Log .Trace ("\u0045\u004f\u0046 p\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0021");if _aega ._fced ==nil {_daba :=XrefTypeTableEntry ;_aega ._fced =&_daba ;};return _ffgbb ,nil ;};

// String returns a string describing `array`.
func (_gcdg *PdfObjectArray )String ()string {_effb :="\u005b";for _ecga ,_bgfc :=range _gcdg .Elements (){_effb +=_bgfc .String ();if _ecga < (_gcdg .Len ()-1){_effb +="\u002c\u0020";};};_effb +="\u005d";return _effb ;};func (_fae *PdfCrypt )securityHandler ()_ge .StdHandler {if _fae ._aebg .R >=5{return _ge .NewHandlerR6 ();
};return _ge .NewHandlerR4 (_fae ._cdf ,_fae ._cbc .Length );};

// MakeBool creates a PdfObjectBool from a bool value.
func MakeBool (val bool )*PdfObjectBool {_affg :=PdfObjectBool (val );return &_affg };

// IsWhiteSpace checks if byte represents a white space character.
func IsWhiteSpace (ch byte )bool {if (ch ==0x00)||(ch ==0x09)||(ch ==0x0A)||(ch ==0x0C)||(ch ==0x0D)||(ch ==0x20){return true ;};return false ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_fbgd *ASCIIHexEncoder )MakeStreamDict ()*PdfObjectDictionary {_gbf :=MakeDict ();_gbf .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_fbgd .GetFilterName ()));return _gbf ;};

// RegisterCustomStreamEncoder register a custom encoder handler for certain filter.
func RegisterCustomStreamEncoder (filterName string ,customStreamEncoder StreamEncoder ){_ffebb .Store (filterName ,customStreamEncoder );};func (_deadg *PdfParser )repairSeekXrefMarker ()error {_cabf ,_gecf :=_deadg ._cgda .Seek (0,_gg .SeekEnd );if _gecf !=nil {return _gecf ;
};_gdgfe :=_c .MustCompile ("\u005cs\u0078\u0072\u0065\u0066\u005c\u0073*");var _gedc int64 ;var _ecdgb int64 =1000;for _gedc < _cabf {if _cabf <=(_ecdgb +_gedc ){_ecdgb =_cabf -_gedc ;};_ ,_ceeed :=_deadg ._cgda .Seek (-_gedc -_ecdgb ,_gg .SeekEnd );if _ceeed !=nil {return _ceeed ;
};_egdb :=make ([]byte ,_ecdgb );_deadg ._cgda .Read (_egdb );_fdf .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0078\u0072\u0065\u0066\u0020\u003a\u0020\u0022\u0025\u0073\u0022",string (_egdb ));_bgdde :=_gdgfe .FindAllStringIndex (string (_egdb ),-1);
if _bgdde !=nil {_afcc :=_bgdde [len (_bgdde )-1];_fdf .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_bgdde );_deadg ._cgda .Seek (-_gedc -_ecdgb +int64 (_afcc [0]),_gg .SeekEnd );_deadg ._fbgde =_b .NewReader (_deadg ._cgda );for {_egaa ,_dcae :=_deadg ._fbgde .Peek (1);
if _dcae !=nil {return _dcae ;};_fdf .Log .Trace ("\u0042\u003a\u0020\u0025\u0064\u0020\u0025\u0063",_egaa [0],_egaa [0]);if !IsWhiteSpace (_egaa [0]){break ;};_deadg ._fbgde .Discard (1);};return nil ;};_fdf .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");
_gedc +=_ecdgb ;};_fdf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074a\u0062\u006c\u0065\u0020\u006d\u0061r\u006b\u0065\u0072\u0020\u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066o\u0075\u006e\u0064\u002e");
return _fb .New ("\u0078r\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0020");};func (_eff *PdfCrypt )encryptBytes (_fad []byte ,_ccgb string ,_aafe []byte )([]byte ,error ){_fdf .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");
_ade ,_gdfe :=_eff ._bafb [_ccgb ];if !_gdfe {return nil ,_af .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_ccgb );};return _ade .EncryptBytes (_fad ,_aafe );};

// CCITTFaxEncoder implements Group3 and Group4 facsimile (fax) encoder/decoder.
type CCITTFaxEncoder struct{K int ;EndOfLine bool ;EncodedByteAlign bool ;Columns int ;Rows int ;EndOfBlock bool ;BlackIs1 bool ;DamagedRowsBeforeError int ;};

// GetArray returns the *PdfObjectArray represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetArray (obj PdfObject )(_dggfc *PdfObjectArray ,_bfdbc bool ){_dggfc ,_bfdbc =TraceToDirectObject (obj ).(*PdfObjectArray );return _dggfc ,_bfdbc ;};

// CheckAccessRights checks access rights and permissions for a specified password. If either user/owner password is
// specified, full rights are granted, otherwise the access rights are specified by the Permissions flag.
//
// The bool flag indicates that the user can access and view the file.
// The AccessPermissions shows what access the user has for editing etc.
// An error is returned if there was a problem performing the authentication.
func (_cfbe *PdfParser )CheckAccessRights (password []byte )(bool ,_ge .Permissions ,error ){if _cfbe ._adfa ==nil {return true ,_ge .PermOwner ,nil ;};return _cfbe ._adfa .checkAccessRights (password );};func (_bdefa *PdfParser )parseXrefStream (_aged *PdfObjectInteger )(*PdfObjectDictionary ,error ){if _aged !=nil {_fdf .Log .Trace ("\u0058\u0052\u0065f\u0053\u0074\u006d\u0020x\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0061\u0074\u0020\u0025\u0064",_aged );
_bdefa ._cgda .Seek (int64 (*_aged ),_gg .SeekStart );_bdefa ._fbgde =_b .NewReader (_bdefa ._cgda );};_fcee :=_bdefa .GetFileOffset ();_bdbba ,_fbegc :=_bdefa .ParseIndirectObject ();if _fbegc !=nil {_fdf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072\u0065\u0061d\u0020\u0078\u0072\u0065\u0066\u0020\u006fb\u006a\u0065\u0063\u0074");
return nil ,_fb .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072e\u0061\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062j\u0065\u0063\u0074");};_fdf .Log .Trace ("\u0058R\u0065f\u0053\u0074\u006d\u0020\u006fb\u006a\u0065c\u0074\u003a\u0020\u0025\u0073",_bdbba );
_bafg ,_eagdb :=_bdbba .(*PdfObjectStream );if !_eagdb {_fdf .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0058R\u0065\u0066\u0053\u0074\u006d\u0020\u0070o\u0069\u006e\u0074\u0069\u006e\u0067 \u0074\u006f\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065a\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0021");
return nil ,_fb .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0070\u006f\u0069\u006e\u0074i\u006e\u0067\u0020\u0074\u006f\u0020a\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006fb\u006a\u0065\u0063\u0074");};_bcagd :=_bafg .PdfObjectDictionary ;
_debeb ,_eagdb :=_bafg .PdfObjectDictionary .Get ("\u0053\u0069\u007a\u0065").(*PdfObjectInteger );if !_eagdb {_fdf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u004d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0073\u0069\u007a\u0065\u0020f\u0072\u006f\u006d\u0020\u0078\u0072\u0065f\u0020\u0073\u0074\u006d");
return nil ,_fb .New ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0053\u0069\u007ae\u0020\u0066\u0072\u006f\u006d\u0020\u0078\u0072\u0065\u0066 \u0073\u0074\u006d");};if int64 (*_debeb )> 8388607{_fdf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u0053\u0069\u007a\u0065\u0020\u0065x\u0063\u0065\u0065\u0064\u0065\u0064\u0020l\u0069\u006d\u0069\u0074\u002c\u0020\u006f\u0076\u0065\u0072\u00208\u0033\u0038\u0038\u0036\u0030\u0037\u0020\u0028\u0025\u0064\u0029",*_debeb );
return nil ,_fb .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_ffaf :=_bafg .PdfObjectDictionary .Get ("\u0057");_faca ,_eagdb :=_ffaf .(*PdfObjectArray );if !_eagdb {return nil ,_fb .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0057\u0020\u0069\u006e\u0020x\u0072\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d");
};_baed :=_faca .Len ();if _baed !=3{_fdf .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020\u0028\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033\u0020\u002d\u0020\u0025\u0064\u0029",_baed );
return nil ,_fb .New ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065f\u0020s\u0074\u006d\u0020\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033");};var _bbgc []int64 ;for _ccbg :=0;_ccbg < 3;
_ccbg ++{_cbeae ,_aabg :=GetInt (_faca .Get (_ccbg ));if !_aabg {return nil ,_fb .New ("i\u006e\u0076\u0061\u006cid\u0020w\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0074\u0079\u0070\u0065");};_bbgc =append (_bbgc ,int64 (*_cbeae ));};_debd ,_fbegc :=DecodeStream (_bafg );
if _fbegc !=nil {_fdf .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020t\u006f \u0064e\u0063o\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u003a\u0020\u0025\u0076",_fbegc );return nil ,_fbegc ;};_fdeeg :=int (_bbgc [0]);
_edec :=int (_bbgc [0]+_bbgc [1]);_efaf :=int (_bbgc [0]+_bbgc [1]+_bbgc [2]);_cadc :=int (_bbgc [0]+_bbgc [1]+_bbgc [2]);if _fdeeg < 0||_edec < 0||_efaf < 0{_fdf .Log .Debug ("\u0045\u0072\u0072\u006fr\u0020\u0073\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u003c \u0030 \u0028\u0025\u0064\u002c\u0025\u0064\u002c%\u0064\u0029",_fdeeg ,_edec ,_efaf );
return nil ,_fb .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};if _cadc ==0{_fdf .Log .Debug ("\u004e\u006f\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063t\u0073\u0020\u0069\u006e\u0020\u0073t\u0072\u0065\u0061\u006d\u0020\u0028\u0064\u0065\u006c\u0074\u0061\u0062\u0020=\u003d\u0020\u0030\u0029");
return _bcagd ,nil ;};_beacg :=len (_debd )/_cadc ;_ecbd :=0;_gegf :=_bafg .PdfObjectDictionary .Get ("\u0049\u006e\u0064e\u0078");var _bfffa []int ;if _gegf !=nil {_fdf .Log .Trace ("\u0049n\u0064\u0065\u0078\u003a\u0020\u0025b",_gegf );_aefa ,_dcaa :=_gegf .(*PdfObjectArray );
if !_dcaa {_fdf .Log .Debug ("\u0049\u006e\u0076\u0061\u006ci\u0064\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0029");
return nil ,_fb .New ("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0049\u006e\u0064e\u0078\u0020\u006f\u0062je\u0063\u0074");};if _aefa .Len ()%2!=0{_fdf .Log .Debug ("\u0057\u0041\u0052\u004eI\u004e\u0047\u0020\u0046\u0061\u0069\u006c\u0075\u0072e\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020i\u006e\u0064\u0065\u0078\u0020n\u006f\u0074\u0020\u006d\u0075\u006c\u0074\u0069\u0070\u006c\u0065\u0020\u006f\u0066\u0020\u0032\u002e");
return nil ,_fb .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_ecbd =0;_baebc ,_cfeg :=_aefa .ToIntegerArray ();if _cfeg !=nil {_fdf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072 \u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0065\u0078 \u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0073\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0073\u003a\u0020\u0025\u0076",_cfeg );
return nil ,_cfeg ;};for _fbefe :=0;_fbefe < len (_baebc );_fbefe +=2{_bdge :=_baebc [_fbefe ];_gdde :=_baebc [_fbefe +1];for _fccd :=0;_fccd < _gdde ;_fccd ++{_bfffa =append (_bfffa ,_bdge +_fccd );};_ecbd +=_gdde ;};}else {for _fceab :=0;_fceab < int (*_debeb );
_fceab ++{_bfffa =append (_bfffa ,_fceab );};_ecbd =int (*_debeb );};if _beacg ==_ecbd +1{_fdf .Log .Debug ("\u0049n\u0063\u006f\u006d\u0070ati\u0062\u0069\u006c\u0069t\u0079\u003a\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006di\u0073\u0073\u0069\u006e\u0067\u0020\u0063\u006f\u0076\u0065\u0072\u0061\u0067\u0065\u0020\u006f\u0066\u0020\u0031\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u002d\u0020\u0061\u0070\u0070en\u0064\u0069\u006eg\u0020\u006f\u006e\u0065\u0020-\u0020M\u0061\u0079\u0020\u006c\u0065\u0061\u0064\u0020\u0074o\u0020\u0070\u0072\u006f\u0062\u006c\u0065\u006d\u0073");
_fdb :=_ecbd -1;for _ ,_gfga :=range _bfffa {if _gfga > _fdb {_fdb =_gfga ;};};_bfffa =append (_bfffa ,_fdb +1);_ecbd ++;};if _beacg !=len (_bfffa ){_fdf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020x\u0072\u0065\u0066 \u0073\u0074\u006d:\u0020\u006eu\u006d\u0020\u0065\u006e\u0074\u0072i\u0065s \u0021\u003d\u0020\u006c\u0065\u006e\u0028\u0069\u006e\u0064\u0069\u0063\u0065\u0073\u0029\u0020\u0028\u0025\u0064\u0020\u0021\u003d\u0020\u0025\u0064\u0029",_beacg ,len (_bfffa ));
return nil ,_fb .New ("\u0078\u0072ef\u0020\u0073\u0074m\u0020\u006e\u0075\u006d en\u0074ri\u0065\u0073\u0020\u0021\u003d\u0020\u006cen\u0028\u0069\u006e\u0064\u0069\u0063\u0065s\u0029");};_fdf .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074s\u0020\u0063\u006f\u0075\u006e\u0074\u0020\u0025\u0064",_ecbd );
_fdf .Log .Trace ("\u0049\u006e\u0064i\u0063\u0065\u0073\u003a\u0020\u0025\u0020\u0064",_bfffa );_bbaf :=func (_dgfbb []byte )int64 {var _ebbcc int64 ;for _gadcb :=0;_gadcb < len (_dgfbb );_gadcb ++{_ebbcc +=int64 (_dgfbb [_gadcb ])*(1<<uint (8*(len (_dgfbb )-_gadcb -1)));
};return _ebbcc ;};_fdf .Log .Trace ("\u0044e\u0063\u006f\u0064\u0065d\u0020\u0073\u0074\u0072\u0065a\u006d \u006ce\u006e\u0067\u0074\u0068\u003a\u0020\u0025d",len (_debd ));_eacb :=0;for _afabg :=0;_afabg < len (_debd );_afabg +=_cadc {_caeg :=_gafcc (len (_debd ),_afabg ,_afabg +_fdeeg );
if _caeg !=nil {_fdf .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_caeg );return nil ,_caeg ;};_gdfa :=_debd [_afabg :_afabg +_fdeeg ];_caeg =_gafcc (len (_debd ),_afabg +_fdeeg ,_afabg +_edec );
if _caeg !=nil {_fdf .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_caeg );return nil ,_caeg ;};_eefeb :=_debd [_afabg +_fdeeg :_afabg +_edec ];_caeg =_gafcc (len (_debd ),_afabg +_edec ,_afabg +_efaf );
if _caeg !=nil {_fdf .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_caeg );return nil ,_caeg ;};_cafe :=_debd [_afabg +_edec :_afabg +_efaf ];_feba :=_bbaf (_gdfa );
_cbebg :=_bbaf (_eefeb );_efdgb :=_bbaf (_cafe );if _bbgc [0]==0{_feba =1;};if _eacb >=len (_bfffa ){_fdf .Log .Debug ("X\u0052\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u002d\u0020\u0054\u0072\u0079\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0061\u0063\u0063e\u0073s\u0020\u0069\u006e\u0064e\u0078\u0020o\u0075\u0074\u0020\u006f\u0066\u0020\u0062\u006f\u0075\u006e\u0064\u0073\u0020\u002d\u0020\u0062\u0072\u0065\u0061\u006b\u0069\u006e\u0067");
break ;};_dagbd :=_bfffa [_eacb ];_eacb ++;_fdf .Log .Trace ("%\u0064\u002e\u0020\u0070\u0031\u003a\u0020\u0025\u0020\u0078",_dagbd ,_gdfa );_fdf .Log .Trace ("%\u0064\u002e\u0020\u0070\u0032\u003a\u0020\u0025\u0020\u0078",_dagbd ,_eefeb );_fdf .Log .Trace ("%\u0064\u002e\u0020\u0070\u0033\u003a\u0020\u0025\u0020\u0078",_dagbd ,_cafe );
_fdf .Log .Trace ("\u0025d\u002e \u0078\u0072\u0065\u0066\u003a \u0025\u0064 \u0025\u0064\u0020\u0025\u0064",_dagbd ,_feba ,_cbebg ,_efdgb );if _feba ==0{_fdf .Log .Trace ("-\u0020\u0046\u0072\u0065\u0065\u0020o\u0062\u006a\u0065\u0063\u0074\u0020-\u0020\u0063\u0061\u006e\u0020\u0070\u0072o\u0062\u0061\u0062\u006c\u0079\u0020\u0069\u0067\u006e\u006fr\u0065");
}else if _feba ==1{_fdf .Log .Trace ("\u002d\u0020I\u006e\u0020\u0075\u0073e\u0020\u002d \u0075\u006e\u0063\u006f\u006d\u0070\u0072\u0065s\u0073\u0065\u0064\u0020\u0076\u0069\u0061\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0062",_eefeb );if _cbebg ==_fcee {_fdf .Log .Debug ("\u0055\u0070d\u0061\u0074\u0069\u006e\u0067\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0058\u0052\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0064",_dagbd ,_bafg .ObjectNumber );
_dagbd =int (_bafg .ObjectNumber );};if _gfgag ,_beae :=_bdefa ._bfaa .ObjectMap [_dagbd ];!_beae ||int (_efdgb )> _gfgag .Generation {_aaaafe :=XrefObject {ObjectNumber :_dagbd ,XType :XrefTypeTableEntry ,Offset :_cbebg ,Generation :int (_efdgb )};_bdefa ._bfaa .ObjectMap [_dagbd ]=_aaaafe ;
};}else if _feba ==2{_fdf .Log .Trace ("\u002d\u0020\u0049\u006e \u0075\u0073\u0065\u0020\u002d\u0020\u0063\u006f\u006d\u0070r\u0065s\u0073\u0065\u0064\u0020\u006f\u0062\u006ae\u0063\u0074");if _ ,_bfbgc :=_bdefa ._bfaa .ObjectMap [_dagbd ];!_bfbgc {_cabb :=XrefObject {ObjectNumber :_dagbd ,XType :XrefTypeObjectStream ,OsObjNumber :int (_cbebg ),OsObjIndex :int (_efdgb )};
_bdefa ._bfaa .ObjectMap [_dagbd ]=_cabb ;_fdf .Log .Trace ("\u0065\u006e\u0074\u0072\u0079\u003a\u0020\u0025\u002b\u0076",_cabb );};}else {_fdf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052:\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0056\u0041L\u0049\u0044\u0020\u0054\u0059\u0050\u0045\u0020\u0058\u0072\u0065\u0066\u0053\u0074\u006d\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u003f\u002d\u002d\u002d\u002d\u002d\u002d-");
continue ;};};if _bdefa ._fced ==nil {_ebce :=XrefTypeObjectStream ;_bdefa ._fced =&_ebce ;};return _bcagd ,nil ;};func (_bcef *JBIG2Image )toBitmap ()(_ccga *_ddb .Bitmap ,_ffgd error ){const _bdba ="\u004a\u0042\u0049\u00472I\u006d\u0061\u0067\u0065\u002e\u0074\u006f\u0042\u0069\u0074\u006d\u0061\u0070";
if _bcef .Data ==nil {return nil ,_de .Error (_bdba ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");};if _bcef .Width ==0||_bcef .Height ==0{return nil ,_de .Error (_bdba ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");
};if _bcef .HasPadding {_ccga ,_ffgd =_ddb .NewWithData (_bcef .Width ,_bcef .Height ,_bcef .Data );}else {_ccga ,_ffgd =_ddb .NewWithUnpaddedData (_bcef .Width ,_bcef .Height ,_bcef .Data );};if _ffgd !=nil {return nil ,_de .Wrap (_ffgd ,_bdba ,"");};
return _ccga ,nil ;};

// WriteString outputs the object as it is to be written to file.
func (_gfde *PdfObjectStream )WriteString ()string {var _cbge _eaa .Builder ;_cbge .WriteString (_a .FormatInt (_gfde .ObjectNumber ,10));_cbge .WriteString ("\u0020\u0030\u0020\u0052");return _cbge .String ();};func _bge (_gfac XrefTable ){_fdf .Log .Debug ("\u003dX\u003d\u0058\u003d\u0058\u003d");
_fdf .Log .Debug ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");_bdf :=0;for _ ,_dac :=range _gfac .ObjectMap {_fdf .Log .Debug ("i\u002b\u0031\u003a\u0020\u0025\u0064 \u0028\u006f\u0062\u006a\u0020\u006eu\u006d\u003a\u0020\u0025\u0064\u0020\u0067e\u006e\u003a\u0020\u0025\u0064\u0029\u0020\u002d\u003e\u0020%\u0064",_bdf +1,_dac .ObjectNumber ,_dac .Generation ,_dac .Offset );
_bdf ++;};};func (_dcfe *PdfCrypt )generateParams (_fcfg ,_dcgf []byte )error {_bdg :=_dcfe .securityHandler ();_abgb ,_bcc :=_bdg .GenerateParams (&_dcfe ._aebg ,_dcgf ,_fcfg );if _bcc !=nil {return _bcc ;};_dcfe ._adb =_abgb ;return nil ;};

// SetImage sets the image base for given flate encoder.
func (_fbg *FlateEncoder )SetImage (img *_gb .ImageBase ){_fbg ._bgdb =img };func _dbde (_bced *PdfObjectStream ,_ddd *PdfObjectDictionary )(*RunLengthEncoder ,error ){return NewRunLengthEncoder (),nil ;};func _edcb (_degc *PdfObjectStream ,_abfe *PdfObjectDictionary )(*CCITTFaxEncoder ,error ){_gbd :=NewCCITTFaxEncoder ();
_ggdc :=_degc .PdfObjectDictionary ;if _ggdc ==nil {return _gbd ,nil ;};if _abfe ==nil {_fbdce :=TraceToDirectObject (_ggdc .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));if _fbdce !=nil {switch _ccdc :=_fbdce .(type ){case *PdfObjectDictionary :_abfe =_ccdc ;
case *PdfObjectArray :if _ccdc .Len ()==1{if _aaba ,_gbfe :=GetDict (_ccdc .Get (0));_gbfe {_abfe =_aaba ;};};default:_fdf .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_fbdce );
return nil ,_fb .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _abfe ==nil {_fdf .Log .Error ("\u0044\u0065c\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064 %\u0023\u0076",_fbdce );
return nil ,_fb .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _cgfd ,_fdcc :=GetNumberAsInt64 (_abfe .Get ("\u004b"));_fdcc ==nil {_gbd .K =int (_cgfd );};if _cdfcg ,_bcae :=GetNumberAsInt64 (_abfe .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));
_bcae ==nil {_gbd .Columns =int (_cdfcg );}else {_gbd .Columns =1728;};if _fecd ,_cbbb :=GetNumberAsInt64 (_abfe .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_cbbb ==nil {_gbd .BlackIs1 =_fecd > 0;}else {if _aaab ,_cefd :=GetBoolVal (_abfe .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));
_cefd {_gbd .BlackIs1 =_aaab ;}else {if _fcgc ,_eea :=GetArray (_abfe .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));_eea {_bgfa ,_fcea :=_fcgc .ToIntegerArray ();if _fcea ==nil {_gbd .BlackIs1 =_bgfa [0]==1&&_bgfa [1]==0;};};};};if _agde ,_dagbc :=GetNumberAsInt64 (_abfe .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));
_dagbc ==nil {_gbd .EncodedByteAlign =_agde > 0;}else {if _gfgea ,_ecg :=GetBoolVal (_abfe .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_ecg {_gbd .EncodedByteAlign =_gfgea ;};};if _eeb ,_bef :=GetNumberAsInt64 (_abfe .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));
_bef ==nil {_gbd .EndOfLine =_eeb > 0;}else {if _ffa ,_dfae :=GetBoolVal (_abfe .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_dfae {_gbd .EndOfLine =_ffa ;};};if _efbc ,_fddf :=GetNumberAsInt64 (_abfe .Get ("\u0052\u006f\u0077\u0073"));_fddf ==nil {_gbd .Rows =int (_efbc );
};_gbd .EndOfBlock =true ;if _gfdfb ,_ebf :=GetNumberAsInt64 (_abfe .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_ebf ==nil {_gbd .EndOfBlock =_gfdfb > 0;}else {if _gae ,_ddafd :=GetBoolVal (_abfe .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));
_ddafd {_gbd .EndOfBlock =_gae ;};};if _cgdg ,_deda :=GetNumberAsInt64 (_abfe .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));_deda !=nil {_gbd .DamagedRowsBeforeError =int (_cgdg );
};_fdf .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_abfe .String ());return _gbd ,nil ;};type objectStream struct{N int ;_bc []byte ;_bec map[int ]int64 ;};func (_efac *PdfCrypt )isEncrypted (_beca PdfObject )bool {_ ,_dgf :=_efac ._fcb [_beca ];
if _dgf {_fdf .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0065\u006e\u0063\u0072y\u0070\u0074\u0065\u0064");return true ;};_fdf .Log .Trace ("\u004e\u006f\u0074\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");
return false ;};

// Clear resets the dictionary to an empty state.
func (_cffd *PdfObjectDictionary )Clear (){_cffd ._aadg =[]PdfObjectName {};_cffd ._cgbf =map[PdfObjectName ]PdfObject {};_cffd ._dggf =&_fd .Mutex {};};

// Len returns the number of elements in the array.
func (_fdbc *PdfObjectArray )Len ()int {if _fdbc ==nil {return 0;};return len (_fdbc ._beeag );};

// PdfObjectStream represents the primitive PDF Object stream.
type PdfObjectStream struct{PdfObjectReference ;*PdfObjectDictionary ;Stream []byte ;};

// NewJPXEncoder returns a new instance of JPXEncoder.
func NewJPXEncoder ()*JPXEncoder {return &JPXEncoder {}};func (_dgcd *PdfParser )readTextLine ()(string ,error ){var _ebdb _dd .Buffer ;for {_babe ,_eafd :=_dgcd ._fbgde .Peek (1);if _eafd !=nil {_fdf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_eafd .Error ());
return _ebdb .String (),_eafd ;};if (_babe [0]!='\r')&&(_babe [0]!='\n'){_ffbc ,_ :=_dgcd ._fbgde .ReadByte ();_ebdb .WriteByte (_ffbc );}else {break ;};};return _ebdb .String (),nil ;};

// LookupByNumber looks up a PdfObject by object number.  Returns an error on failure.
func (_gda *PdfParser )LookupByNumber (objNumber int )(PdfObject ,error ){_ggg ,_ ,_bd :=_gda .lookupByNumberWrapper (objNumber ,true );return _ggg ,_bd ;};

// String returns a string representation of `name`.
func (_ffdb *PdfObjectName )String ()string {return string (*_ffdb )};

// NewMultiEncoder returns a new instance of MultiEncoder.
func NewMultiEncoder ()*MultiEncoder {_fabb :=MultiEncoder {};_fabb ._cbdf =[]StreamEncoder {};return &_fabb ;};func _acfbe (_dadcee PdfObject ,_dcdgd int ,_daaa map[PdfObject ]struct{})error {_fdf .Log .Trace ("\u0054\u0072\u0061\u0076\u0065\u0072s\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0064\u0061\u0074\u0061 \u0028\u0064\u0065\u0070\u0074\u0068\u0020=\u0020\u0025\u0064\u0029",_dcdgd );
if _ ,_dggbe :=_daaa [_dadcee ];_dggbe {_fdf .Log .Trace ("-\u0041\u006c\u0072\u0065ad\u0079 \u0074\u0072\u0061\u0076\u0065r\u0073\u0065\u0064\u002e\u002e\u002e");return nil ;};_daaa [_dadcee ]=struct{}{};switch _acbg :=_dadcee .(type ){case *PdfIndirectObject :_bafcb :=_acbg ;
_fdf .Log .Trace ("\u0069\u006f\u003a\u0020\u0025\u0073",_bafcb );_fdf .Log .Trace ("\u002d\u0020\u0025\u0073",_bafcb .PdfObject );return _acfbe (_bafcb .PdfObject ,_dcdgd +1,_daaa );case *PdfObjectStream :_dbgc :=_acbg ;return _acfbe (_dbgc .PdfObjectDictionary ,_dcdgd +1,_daaa );
case *PdfObjectDictionary :_gbde :=_acbg ;_fdf .Log .Trace ("\u002d\u0020\u0064\u0069\u0063\u0074\u003a\u0020\u0025\u0073",_gbde );for _ ,_cbeaa :=range _gbde .Keys (){_acgg :=_gbde .Get (_cbeaa );if _bdgcb ,_dcgdc :=_acgg .(*PdfObjectReference );_dcgdc {_bdfbef :=_bdgcb .Resolve ();
_gbde .Set (_cbeaa ,_bdfbef );_fceeg :=_acfbe (_bdfbef ,_dcdgd +1,_daaa );if _fceeg !=nil {return _fceeg ;};}else {_afbf :=_acfbe (_acgg ,_dcdgd +1,_daaa );if _afbf !=nil {return _afbf ;};};};return nil ;case *PdfObjectArray :_eedc :=_acbg ;_fdf .Log .Trace ("-\u0020\u0061\u0072\u0072\u0061\u0079\u003a\u0020\u0025\u0073",_eedc );
for _caaaf ,_ffeea :=range _eedc .Elements (){if _bcbf ,_feabg :=_ffeea .(*PdfObjectReference );_feabg {_dcaac :=_bcbf .Resolve ();_eedc .Set (_caaaf ,_dcaac );_cfcgb :=_acfbe (_dcaac ,_dcdgd +1,_daaa );if _cfcgb !=nil {return _cfcgb ;};}else {_gbce :=_acfbe (_ffeea ,_dcdgd +1,_daaa );
if _gbce !=nil {return _gbce ;};};};return nil ;case *PdfObjectReference :_fdf .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020T\u0072\u0061\u0063\u0069\u006e\u0067\u0020\u0061\u0020r\u0065\u0066\u0065r\u0065n\u0063\u0065\u0021");return _fb .New ("\u0065r\u0072\u006f\u0072\u0020t\u0072\u0061\u0063\u0069\u006eg\u0020a\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");
};return nil ;};

// LZWEncoder provides LZW encoding/decoding functionality.
type LZWEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Colors int ;

// LZW algorithm setting.
EarlyChange int ;};

// UpdateParams updates the parameter values of the encoder.
func (_bdfb *JPXEncoder )UpdateParams (params *PdfObjectDictionary ){};func (_gdgcf *offsetReader )Read (p []byte )(_fafa int ,_geba error ){return _gdgcf ._ebefg .Read (p )};

// DCTEncoder provides a DCT (JPG) encoding/decoding functionality for images.
type DCTEncoder struct{ColorComponents int ;BitsPerComponent int ;Width int ;Height int ;Quality int ;};

// JBIG2EncoderSettings contains the parameters and settings used by the JBIG2Encoder.
// Current version works only on JB2Generic compression.
type JBIG2EncoderSettings struct{

// FileMode defines if the jbig2 encoder should return full jbig2 file instead of
// shortened pdf mode. This adds the file header to the jbig2 definition.
FileMode bool ;

// Compression is the setting that defines the compression type used for encoding the page.
Compression JBIG2CompressionType ;

// DuplicatedLinesRemoval code generic region in a way such that if the lines are duplicated the encoder
// doesn't store it twice.
DuplicatedLinesRemoval bool ;

// DefaultPixelValue is the bit value initial for every pixel in the page.
DefaultPixelValue uint8 ;

// ResolutionX optional setting that defines the 'x' axis input image resolution - used for single page encoding.
ResolutionX int ;

// ResolutionY optional setting that defines the 'y' axis input image resolution - used for single page encoding.
ResolutionY int ;

// Threshold defines the threshold of the image correlation for
// non Generic compression.
// User only for JB2SymbolCorrelation and JB2SymbolRankHaus methods.
// Best results in range [0.7 - 0.98] - the less the better the compression would be
// but the more lossy.
// Default value: 0.95
Threshold float64 ;};

// String returns a string describing `ref`.
func (_eafc *PdfObjectReference )String ()string {return _af .Sprintf ("\u0052\u0065\u0066\u0028\u0025\u0064\u0020\u0025\u0064\u0029",_eafc .ObjectNumber ,_eafc .GenerationNumber );};func _bgdd (_ece ,_dcda ,_afefc uint8 )uint8 {_fffb :=int (_afefc );_cagf :=int (_dcda )-_fffb ;
_dbcb :=int (_ece )-_fffb ;_fffb =_beba (_cagf +_dbcb );_cagf =_beba (_cagf );_dbcb =_beba (_dbcb );if _cagf <=_dbcb &&_cagf <=_fffb {return _ece ;}else if _dbcb <=_fffb {return _dcda ;};return _afefc ;};

// MakeIndirectObject creates an PdfIndirectObject with a specified direct object PdfObject.
func MakeIndirectObject (obj PdfObject )*PdfIndirectObject {_fceg :=&PdfIndirectObject {};_fceg .PdfObject =obj ;return _fceg ;};func _gfc (_dcba *PdfObjectStream ,_bcge *MultiEncoder )(*DCTEncoder ,error ){_bab :=NewDCTEncoder ();_gdcf :=_dcba .PdfObjectDictionary ;
if _gdcf ==nil {return _bab ,nil ;};_dffc :=_dcba .Stream ;if _bcge !=nil {_gcag ,_cbec :=_bcge .DecodeBytes (_dffc );if _cbec !=nil {return nil ,_cbec ;};_dffc =_gcag ;};_decd :=_dd .NewReader (_dffc );_efadb ,_effd :=_dc .DecodeConfig (_decd );if _effd !=nil {_fdf .Log .Debug ("\u0045\u0072\u0072or\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0065\u003a\u0020\u0025\u0073",_effd );
return nil ,_effd ;};switch _efadb .ColorModel {case _aa .RGBAModel :_bab .BitsPerComponent =8;_bab .ColorComponents =3;case _aa .RGBA64Model :_bab .BitsPerComponent =16;_bab .ColorComponents =3;case _aa .GrayModel :_bab .BitsPerComponent =8;_bab .ColorComponents =1;
case _aa .Gray16Model :_bab .BitsPerComponent =16;_bab .ColorComponents =1;case _aa .CMYKModel :_bab .BitsPerComponent =8;_bab .ColorComponents =4;case _aa .YCbCrModel :_bab .BitsPerComponent =8;_bab .ColorComponents =3;default:return nil ,_fb .New ("\u0075\u006e\u0073up\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u006d\u006f\u0064\u0065\u006c");
};_bab .Width =_efadb .Width ;_bab .Height =_efadb .Height ;_fdf .Log .Trace ("\u0044\u0043T\u0020\u0045\u006ec\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076",_bab );_bab .Quality =DefaultJPEGQuality ;return _bab ,nil ;};

// Merge merges in key/values from another dictionary. Overwriting if has same keys.
// The mutated dictionary (d) is returned in order to allow method chaining.
func (_gedf *PdfObjectDictionary )Merge (another *PdfObjectDictionary )*PdfObjectDictionary {if another !=nil {for _ ,_ddag :=range another .Keys (){_ggef :=another .Get (_ddag );_gedf .Set (_ddag ,_ggef );};};return _gedf ;};func _eeaf ()string {return _fdf .Version };


// GetDict returns the *PdfObjectDictionary represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetDict (obj PdfObject )(_gefaf *PdfObjectDictionary ,_ddgfd bool ){_gefaf ,_ddgfd =TraceToDirectObject (obj ).(*PdfObjectDictionary );return _gefaf ,_ddgfd ;};func (_cdcaf *PdfParser )parseNumber ()(PdfObject ,error ){return ParseNumber (_cdcaf ._fbgde )};


// WriteString outputs the object as it is to be written to file.
func (_cebae *PdfObjectBool )WriteString ()string {if *_cebae {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};

// PdfCryptNewEncrypt makes the document crypt handler based on a specified crypt filter.
func PdfCryptNewEncrypt (cf _gd .Filter ,userPass ,ownerPass []byte ,perm _ge .Permissions )(*PdfCrypt ,*EncryptInfo ,error ){_fee :=&PdfCrypt {_fcb :make (map[PdfObject ]bool ),_bafb :make (cryptFilters ),_aebg :_ge .StdEncryptDict {P :perm ,EncryptMetadata :true }};
var _dae Version ;if cf !=nil {_gad :=cf .PDFVersion ();_dae .Major ,_dae .Minor =_gad [0],_gad [1];V ,R :=cf .HandlerVersion ();_fee ._cbc .V =V ;_fee ._aebg .R =R ;_fee ._cbc .Length =cf .KeyLength ()*8;};const (_dbc =_cfg ;);_fee ._bafb [_dbc ]=cf ;
if _fee ._cbc .V >=4{_fee ._afb =_dbc ;_fee ._egg =_dbc ;};_gfaf :=_fee .newEncryptDict ();_fcf :=_gc .Sum ([]byte (_ea .Now ().Format (_ea .RFC850 )));_ecf :=string (_fcf [:]);_bcb :=make ([]byte ,100);_cb .Read (_bcb );_fcf =_gc .Sum (_bcb );_ddbf :=string (_fcf [:]);
_fdf .Log .Trace ("\u0052\u0061\u006e\u0064\u006f\u006d\u0020\u0062\u003a\u0020\u0025\u0020\u0078",_bcb );_fdf .Log .Trace ("\u0047\u0065\u006e\u0020\u0049\u0064\u0020\u0030\u003a\u0020\u0025\u0020\u0078",_ecf );_fee ._cdf =_ecf ;_fba :=_fee .generateParams (userPass ,ownerPass );
if _fba !=nil {return nil ,nil ,_fba ;};_ccf (&_fee ._aebg ,_gfaf );if _fee ._cbc .V >=4{if _gdc :=_fee .saveCryptFilters (_gfaf );_gdc !=nil {return nil ,nil ,_gdc ;};};return _fee ,&EncryptInfo {Version :_dae ,Encrypt :_gfaf ,ID0 :_ecf ,ID1 :_ddbf },nil ;
};

// DecodeBytes decodes a slice of Flate encoded bytes and returns the result.
func (_cbcc *FlateEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_fdf .Log .Trace ("\u0046\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065\u0020b\u0079\u0074\u0065\u0073");if len (encoded )==0{_fdf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0046\u006c\u0061\u0074\u0065 e\u006ec\u006f\u0064\u0065\u0064\u0020\u0062\u0075\u0066\u0066\u0065\u0072\u002e \u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0062y\u0074\u0065\u0020\u0073\u006c\u0069\u0063\u0065\u002e");
return []byte {},nil ;};_fccg :=_dd .NewReader (encoded );_ced ,_abgbg :=_gfd .NewReader (_fccg );if _abgbg !=nil {_fdf .Log .Debug ("\u0044e\u0063o\u0064\u0069\u006e\u0067\u0020e\u0072\u0072o\u0072\u0020\u0025\u0076\u000a",_abgbg );_fdf .Log .Debug ("\u0053t\u0072e\u0061\u006d\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (encoded ),encoded );
return nil ,_abgbg ;};defer _ced .Close ();var _cfc _dd .Buffer ;_cfc .ReadFrom (_ced );return _cfc .Bytes (),nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_bgec *CCITTFaxEncoder )MakeDecodeParams ()PdfObject {_dgff :=MakeDict ();_dgff .Set ("\u004b",MakeInteger (int64 (_bgec .K )));_dgff .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_bgec .Columns )));if _bgec .BlackIs1 {_dgff .Set ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031",MakeBool (_bgec .BlackIs1 ));
};if _bgec .EncodedByteAlign {_dgff .Set ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e",MakeBool (_bgec .EncodedByteAlign ));};if _bgec .EndOfLine &&_bgec .K >=0{_dgff .Set ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee",MakeBool (_bgec .EndOfLine ));
};if _bgec .Rows !=0&&!_bgec .EndOfBlock {_dgff .Set ("\u0052\u006f\u0077\u0073",MakeInteger (int64 (_bgec .Rows )));};if !_bgec .EndOfBlock {_dgff .Set ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b",MakeBool (_bgec .EndOfBlock ));};if _bgec .DamagedRowsBeforeError !=0{_dgff .Set ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072",MakeInteger (int64 (_bgec .DamagedRowsBeforeError )));
};return _dgff ;};

// EncodeBytes encodes the image data using either Group3 or Group4 CCITT facsimile (fax) encoding.
// `data` is expected to be 1 color component, 1 bit per component. It is also valid to provide 8 BPC, 1 CC image like
// a standard go image Gray data.
func (_bbggd *CCITTFaxEncoder )EncodeBytes (data []byte )([]byte ,error ){var _daa _gb .Gray ;switch len (data ){case _bbggd .Rows *_bbggd .Columns :_dcdc ,_gefa :=_gb .NewImage (_bbggd .Columns ,_bbggd .Rows ,8,1,data ,nil ,nil );if _gefa !=nil {return nil ,_gefa ;
};_daa =_dcdc .(_gb .Gray );case (_bbggd .Columns *_bbggd .Rows )+7>>3:_dgcf ,_ega :=_gb .NewImage (_bbggd .Columns ,_bbggd .Rows ,1,1,data ,nil ,nil );if _ega !=nil {return nil ,_ega ;};_geag :=_dgcf .(*_gb .Monochrome );if _ega =_geag .AddPadding ();
_ega !=nil {return nil ,_ega ;};_daa =_geag ;default:if len (data )< _gb .BytesPerLine (_bbggd .Columns ,1,1)*_bbggd .Rows {return nil ,_fb .New ("p\u0072\u006f\u0076\u0069\u0064\u0065d\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020i\u006e\u0070\u0075t\u0020d\u0061\u0074\u0061");
};_faee ,_fbga :=_gb .NewImage (_bbggd .Columns ,_bbggd .Rows ,1,1,data ,nil ,nil );if _fbga !=nil {return nil ,_fbga ;};_egc :=_faee .(*_gb .Monochrome );_daa =_egc ;};_cffb :=make ([][]byte ,_bbggd .Rows );for _cdagc :=0;_cdagc < _bbggd .Rows ;_cdagc ++{_bcad :=make ([]byte ,_bbggd .Columns );
for _eedf :=0;_eedf < _bbggd .Columns ;_eedf ++{_eccb :=_daa .GrayAt (_eedf ,_cdagc );_bcad [_eedf ]=_eccb .Y >>7;};_cffb [_cdagc ]=_bcad ;};_bedb :=&_ac .Encoder {K :_bbggd .K ,Columns :_bbggd .Columns ,EndOfLine :_bbggd .EndOfLine ,EndOfBlock :_bbggd .EndOfBlock ,BlackIs1 :_bbggd .BlackIs1 ,DamagedRowsBeforeError :_bbggd .DamagedRowsBeforeError ,Rows :_bbggd .Rows ,EncodedByteAlign :_bbggd .EncodedByteAlign };
return _bedb .Encode (_cffb ),nil ;};

// HasInvalidSubsectionHeader implements core.ParserMetadata interface.
func (_aegb ParserMetadata )HasInvalidSubsectionHeader ()bool {return _aegb ._dfde };

// HasInvalidSeparationAfterXRef implements core.ParserMetadata interface.
func (_fde ParserMetadata )HasInvalidSeparationAfterXRef ()bool {return _fde ._bcf };

// MakeArrayFromFloats creates an PdfObjectArray from a slice of float64s, where each array element is an
// PdfObjectFloat.
func MakeArrayFromFloats (vals []float64 )*PdfObjectArray {_cce :=MakeArray ();for _ ,_dbag :=range vals {_cce .Append (MakeFloat (_dbag ));};return _cce ;};

// GetFilterName returns the name of the encoding filter.
func (_deb *ASCIIHexEncoder )GetFilterName ()string {return StreamEncodingFilterNameASCIIHex };

// GetPreviousRevisionParser returns PdfParser for the previous version of the Pdf document.
func (_bgbg *PdfParser )GetPreviousRevisionParser ()(*PdfParser ,error ){if _bgbg ._dcgd ==0{return nil ,_fb .New ("\u0074\u0068\u0069\u0073 i\u0073\u0020\u0066\u0069\u0072\u0073\u0074\u0020\u0072\u0065\u0076\u0069\u0073\u0069o\u006e");};if _ddaff ,_gebae :=_bgbg ._cggc [_bgbg ];
_gebae {return _ddaff ,nil ;};_aebe ,_acfba :=_bgbg .GetPreviousRevisionReadSeeker ();if _acfba !=nil {return nil ,_acfba ;};_gebaa ,_acfba :=NewParser (_aebe );_gebaa ._cggc =_bgbg ._cggc ;if _acfba !=nil {return nil ,_acfba ;};_bgbg ._cggc [_bgbg ]=_gebaa ;
return _gebaa ,nil ;};type limitedReadSeeker struct{_acfb _gg .ReadSeeker ;_aggf int64 ;};

// NewASCIIHexEncoder makes a new ASCII hex encoder.
func NewASCIIHexEncoder ()*ASCIIHexEncoder {_dbe :=&ASCIIHexEncoder {};return _dbe };func (_efdfc *PdfParser )parseXref ()(*PdfObjectDictionary ,error ){const _dadce =20;_eebd ,_ :=_efdfc ._fbgde .Peek (_dadce );for _bfbgcd :=0;_bfbgcd < 2;_bfbgcd ++{if _efdfc ._dfc ==0{_efdfc ._dfc =_efdfc .GetFileOffset ();
};if _bafbb .Match (_eebd ){_fdf .Log .Trace ("\u0078\u0072e\u0066\u0020\u0070\u006f\u0069\u006e\u0074\u0073\u0020\u0074\u006f\u0020\u0061\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u002e\u0020\u0050\u0072\u006f\u0062\u0061\u0062\u006c\u0079\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063\u0074");
_fdf .Log .Debug ("\u0073t\u0061r\u0074\u0069\u006e\u0067\u0020w\u0069\u0074h\u0020\u0022\u0025\u0073\u0022",string (_eebd ));return _efdfc .parseXrefStream (nil );};if _cdbf .Match (_eebd ){_fdf .Log .Trace ("\u0053\u0074\u0061\u006ed\u0061\u0072\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073e\u0063t\u0069\u006f\u006e\u0020\u0074\u0061\u0062l\u0065\u0021");
return _efdfc .parseXrefTable ();};_agga :=_efdfc .GetFileOffset ();if _efdfc ._dfc ==0{_efdfc ._dfc =_agga ;};_efdfc .SetFileOffset (_agga -_dadce );defer _efdfc .SetFileOffset (_agga );_defg ,_ :=_efdfc ._fbgde .Peek (_dadce );_eebd =append (_defg ,_eebd ...);
};_fdf .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u0078\u0072\u0065f\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006fr\u0020\u0073\u0074\u0072\u0065\u0061\u006d.\u0020\u0052\u0065\u0070\u0061i\u0072\u0020\u0061\u0074\u0074e\u006d\u0070\u0074\u0065\u0064\u003a\u0020\u004c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0065\u0061\u0072\u006c\u0069\u0065\u0073\u0074\u0020x\u0072\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u0062\u006f\u0074to\u006d\u002e");
if _adc :=_efdfc .repairSeekXrefMarker ();_adc !=nil {_fdf .Log .Debug ("\u0052e\u0070a\u0069\u0072\u0020\u0066\u0061i\u006c\u0065d\u0020\u002d\u0020\u0025\u0076",_adc );return nil ,_adc ;};return _efdfc .parseXrefTable ();};

// GetString returns the *PdfObjectString represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetString (obj PdfObject )(_gcaa *PdfObjectString ,_cgadb bool ){_gcaa ,_cgadb =TraceToDirectObject (obj ).(*PdfObjectString );return _gcaa ,_cgadb ;};

// Set sets the dictionary's key -> val mapping entry. Overwrites if key already set.
func (_ffbd *PdfObjectDictionary )Set (key PdfObjectName ,val PdfObject ){_ffbd .setWithLock (key ,val ,true );};

// JBIG2CompressionType defines the enum compression type used by the JBIG2Encoder.
type JBIG2CompressionType int ;

// PdfObjectArray represents the primitive PDF array object.
type PdfObjectArray struct{_beeag []PdfObject };

// Keys returns the list of keys in the dictionary.
// If `d` is nil returns a nil slice.
func (_ffbe *PdfObjectDictionary )Keys ()[]PdfObjectName {if _ffbe ==nil {return nil ;};return _ffbe ._aadg ;};

// String returns the PDF version as a string. Implements interface fmt.Stringer.
func (_feac Version )String ()string {return _af .Sprintf ("\u00250\u0064\u002e\u0025\u0030\u0064",_feac .Major ,_feac .Minor );};func _dcafe (_ecb *PdfObjectStream ,_abc *PdfObjectDictionary )(*LZWEncoder ,error ){_fgac :=NewLZWEncoder ();_fca :=_ecb .PdfObjectDictionary ;
if _fca ==nil {return _fgac ,nil ;};if _abc ==nil {_bbag :=TraceToDirectObject (_fca .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));if _bbag !=nil {if _bfff ,_gbee :=_bbag .(*PdfObjectDictionary );_gbee {_abc =_bfff ;}else if _efbd ,_cdae :=_bbag .(*PdfObjectArray );
_cdae {if _efbd .Len ()==1{if _badd ,_beac :=GetDict (_efbd .Get (0));_beac {_abc =_badd ;};};};if _abc ==nil {_fdf .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_bbag );
return nil ,_af .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};};_dgc :=_fca .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");if _dgc !=nil {_gdg ,_dgda :=_dgc .(*PdfObjectInteger );
if !_dgda {_fdf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a \u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065d\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u006e\u0075\u006d\u0065\u0072i\u0063 \u0028\u0025\u0054\u0029",_dgc );
return nil ,_af .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");};if *_gdg !=0&&*_gdg !=1{return nil ,_af .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0076\u0061\u006c\u0075e\u0020\u0028\u006e\u006f\u0074 \u0030\u0020o\u0072\u0020\u0031\u0029");
};_fgac .EarlyChange =int (*_gdg );}else {_fgac .EarlyChange =1;};if _abc ==nil {return _fgac ,nil ;};if _fddea ,_adad :=GetIntVal (_abc .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065"));_adad {if _fddea ==0||_fddea ==1{_fgac .EarlyChange =_fddea ;
}else {_fdf .Log .Debug ("W\u0041\u0052\u004e\u003a\u0020\u0069n\u0076\u0061\u006c\u0069\u0064\u0020E\u0061\u0072\u006c\u0079\u0043\u0068\u0061n\u0067\u0065\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020%\u0064",_fddea );};};_dgc =_abc .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");
if _dgc !=nil {_dgeb ,_cfga :=_dgc .(*PdfObjectInteger );if !_cfga {_fdf .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_dgc );
return nil ,_af .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_fgac .Predictor =int (*_dgeb );};_dgc =_abc .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");
if _dgc !=nil {_gebg ,_fcfef :=_dgc .(*PdfObjectInteger );if !_fcfef {_fdf .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");
return nil ,_af .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_fgac .BitsPerComponent =int (*_gebg );};if _fgac .Predictor > 1{_fgac .Columns =1;_dgc =_abc .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");
if _dgc !=nil {_gdce ,_cegc :=_dgc .(*PdfObjectInteger );if !_cegc {return nil ,_af .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_fgac .Columns =int (*_gdce );
};_fgac .Colors =1;_dgc =_abc .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _dgc !=nil {_abfb ,_fcaa :=_dgc .(*PdfObjectInteger );if !_fcaa {return nil ,_af .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");
};_fgac .Colors =int (*_abfb );};};_fdf .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_abc .String ());return _fgac ,nil ;};

// MakeString creates an PdfObjectString from a string.
// NOTE: PDF does not use utf-8 string encoding like Go so `s` will often not be a utf-8 encoded
// string.
func MakeString (s string )*PdfObjectString {_decca :=PdfObjectString {_eagb :s };return &_decca };

// DecodeBytes decodes a slice of ASCII encoded bytes and returns the result.
func (_dacg *ASCIIHexEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_def :=_dd .NewReader (encoded );var _aebfb []byte ;for {_cdaec ,_aag :=_def .ReadByte ();if _aag !=nil {return nil ,_aag ;};if _cdaec =='>'{break ;};if IsWhiteSpace (_cdaec ){continue ;
};if (_cdaec >='a'&&_cdaec <='f')||(_cdaec >='A'&&_cdaec <='F')||(_cdaec >='0'&&_cdaec <='9'){_aebfb =append (_aebfb ,_cdaec );}else {_fdf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0061\u0073\u0063\u0069\u0069 \u0068\u0065\u0078\u0020\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072 \u0028\u0025\u0063\u0029",_cdaec );
return nil ,_af .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0061\u0073\u0063\u0069\u0069\u0020\u0068e\u0078 \u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u0020\u0028\u0025\u0063\u0029",_cdaec );};};if len (_aebfb )%2==1{_aebfb =append (_aebfb ,'0');
};_fdf .Log .Trace ("\u0049\u006e\u0062\u006f\u0075\u006e\u0064\u0020\u0025\u0073",_aebfb );_dfab :=make ([]byte ,_fe .DecodedLen (len (_aebfb )));_ ,_dcdg :=_fe .Decode (_dfab ,_aebfb );if _dcdg !=nil {return nil ,_dcdg ;};return _dfab ,nil ;};func (_dbac *PdfParser )seekToEOFMarker (_bdcfg int64 )error {var _cfbda int64 ;
var _cgbc int64 =2048;for _cfbda < _bdcfg -4{if _bdcfg <=(_cgbc +_cfbda ){_cgbc =_bdcfg -_cfbda ;};_ ,_adcf :=_dbac ._cgda .Seek (_bdcfg -_cfbda -_cgbc ,_gg .SeekStart );if _adcf !=nil {return _adcf ;};_efeab :=make ([]byte ,_cgbc );_dbac ._cgda .Read (_efeab );
_fdf .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0045\u004f\u0046 \u006da\u0072\u006b\u0065\u0072\u003a\u0020\u0022%\u0073\u0022",string (_efeab ));_cdec :=_gcfg .FindAllStringIndex (string (_efeab ),-1);if _cdec !=nil {_gfcb :=_cdec [len (_cdec )-1];
_fdf .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_cdec );_ccgdd :=_bdcfg -_cfbda -_cgbc +int64 (_gfcb [0]);_dbac ._cgda .Seek (_ccgdd ,_gg .SeekStart );return nil ;};_fdf .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");
_cfbda +=_cgbc -4;};_fdf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006be\u0072 \u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u002e");return _cdg ;};

// EncodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_fafc *RawEncoder )EncodeBytes (data []byte )([]byte ,error ){return data ,nil };

// String returns a string describing `null`.
func (_eddbd *PdfObjectNull )String ()string {return "\u006e\u0075\u006c\u006c"};const (_gacd =0;_dfdb =1;_cfbd =2;_bfab =3;_egd =4;);func _dabd (_cdfgf *PdfObjectDictionary )(_gddc *_gb .ImageBase ){var (_dfcb *PdfObjectInteger ;_eacbg bool ;);if _dfcb ,_eacbg =_cdfgf .Get ("\u0057\u0069\u0064t\u0068").(*PdfObjectInteger );
_eacbg {_gddc =&_gb .ImageBase {Width :int (*_dfcb )};}else {return nil ;};if _dfcb ,_eacbg =_cdfgf .Get ("\u0048\u0065\u0069\u0067\u0068\u0074").(*PdfObjectInteger );_eacbg {_gddc .Height =int (*_dfcb );};if _dfcb ,_eacbg =_cdfgf .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074").(*PdfObjectInteger );
_eacbg {_gddc .BitsPerComponent =int (*_dfcb );};if _dfcb ,_eacbg =_cdfgf .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073").(*PdfObjectInteger );_eacbg {_gddc .ColorComponents =int (*_dfcb );};return _gddc ;};func (_cded *PdfCrypt )newEncryptDict ()*PdfObjectDictionary {_cafg :=MakeDict ();
_cafg .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName ("\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"));_cafg .Set ("\u0056",MakeInteger (int64 (_cded ._cbc .V )));_cafg .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_cded ._cbc .Length )));
return _cafg ;};func (_fffd *PdfParser )getNumbersOfUpdatedObjects (_bafcd *PdfParser )([]int ,error ){if _bafcd ==nil {return nil ,_fb .New ("\u0070\u0072e\u0076\u0069\u006f\u0075\u0073\u0020\u0070\u0061\u0072\u0073\u0065\u0072\u0020\u0063\u0061\u006e\u0027\u0074\u0020\u0062\u0065\u0020nu\u006c\u006c");
};_bffad :=_bafcd ._gdgf ;_ccccf :=make ([]int ,0);_adge :=make (map[int ]interface{});_gcbc :=make (map[int ]int64 );for _ebdd ,_fabfe :=range _fffd ._bfaa .ObjectMap {if _fabfe .Offset ==0{if _fabfe .OsObjNumber !=0{if _feae ,_dafaf :=_fffd ._bfaa .ObjectMap [_fabfe .OsObjNumber ];
_dafaf {_adge [_fabfe .OsObjNumber ]=struct{}{};_gcbc [_ebdd ]=_feae .Offset ;}else {return nil ,_fb .New ("u\u006ed\u0065\u0066\u0069\u006e\u0065\u0064\u0020\u0078r\u0065\u0066\u0020\u0074ab\u006c\u0065");};};}else {_gcbc [_ebdd ]=_fabfe .Offset ;};};
for _fceae ,_cfdc :=range _gcbc {if _ ,_efgd :=_adge [_fceae ];_efgd {continue ;};if _cfdc > _bffad {_ccccf =append (_ccccf ,_fceae );};};return _ccccf ,nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_bfce *RawEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};

// IsFloatDigit checks if a character can be a part of a float number string.
func IsFloatDigit (c byte )bool {return ('0'<=c &&c <='9')||c =='.'};

// GetFileOffset returns the current file offset, accounting for buffered position.
func (_dadb *PdfParser )GetFileOffset ()int64 {_ecag ,_ :=_dadb ._cgda .Seek (0,_gg .SeekCurrent );_ecag -=int64 (_dadb ._fbgde .Buffered ());return _ecag ;};

// WriteString outputs the object as it is to be written to file.
func (_abgf *PdfObjectName )WriteString ()string {var _efaa _dd .Buffer ;if len (*_abgf )> 127{_fdf .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u004e\u0061\u006d\u0065\u0020t\u006fo\u0020l\u006f\u006e\u0067\u0020\u0028\u0025\u0073)",*_abgf );};_efaa .WriteString ("\u002f");
for _befg :=0;_befg < len (*_abgf );_befg ++{_fgcac :=(*_abgf )[_befg ];if !IsPrintable (_fgcac )||_fgcac =='#'||IsDelimiter (_fgcac ){_efaa .WriteString (_af .Sprintf ("\u0023\u0025\u002e2\u0078",_fgcac ));}else {_efaa .WriteByte (_fgcac );};};return _efaa .String ();
};

// GetObjectNums returns a sorted list of object numbers of the PDF objects in the file.
func (_eaccf *PdfParser )GetObjectNums ()[]int {var _ddbfb []int ;for _ ,_ccca :=range _eaccf ._bfaa .ObjectMap {_ddbfb =append (_ddbfb ,_ccca .ObjectNumber );};_d .Ints (_ddbfb );return _ddbfb ;};

// UpdateParams updates the parameter values of the encoder.
func (_cfgbc *DCTEncoder )UpdateParams (params *PdfObjectDictionary ){_bdcc ,_adbc :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _adbc ==nil {_cfgbc .ColorComponents =int (_bdcc );
};_egdf ,_adbc :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _adbc ==nil {_cfgbc .BitsPerComponent =int (_egdf );};_ecdc ,_adbc :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));
if _adbc ==nil {_cfgbc .Width =int (_ecdc );};_fbgf ,_adbc :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _adbc ==nil {_cfgbc .Height =int (_fbgf );};_dabbb ,_adbc :=GetNumberAsInt64 (params .Get ("\u0051u\u0061\u006c\u0069\u0074\u0079"));
if _adbc ==nil {_cfgbc .Quality =int (_dabbb );};};func (_ecce *offsetReader )Seek (offset int64 ,whence int )(int64 ,error ){if whence ==_gg .SeekStart {offset +=_ecce ._aeed ;};_fggba ,_gagbe :=_ecce ._ebefg .Seek (offset ,whence );if _gagbe !=nil {return _fggba ,_gagbe ;
};if whence ==_gg .SeekCurrent {_fggba -=_ecce ._aeed ;};if _fggba < 0{return 0,_fb .New ("\u0063\u006f\u0072\u0065\u002eo\u0066\u0066\u0073\u0065\u0074\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053e\u0065\u006b\u003a\u0020\u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e");
};return _fggba ,nil ;};

// GetFilterName returns the name of the encoding filter.
func (_cfgbca *JBIG2Encoder )GetFilterName ()string {return StreamEncodingFilterNameJBIG2 };

// WriteString outputs the object as it is to be written to file.
func (_fgcf *PdfObjectFloat )WriteString ()string {return _a .FormatFloat (float64 (*_fgcf ),'f',-1,64);};

// IsPrintable checks if a character is printable.
// Regular characters that are outside the range EXCLAMATION MARK(21h)
// (!) to TILDE (7Eh) (~) should be written using the hexadecimal notation.
func IsPrintable (c byte )bool {return 0x21<=c &&c <=0x7E};

// NewFlateEncoder makes a new flate encoder with default parameters, predictor 1 and bits per component 8.
func NewFlateEncoder ()*FlateEncoder {_gff :=&FlateEncoder {};_gff .Predictor =1;_gff .BitsPerComponent =8;_gff .Colors =1;_gff .Columns =1;return _gff ;};

// GetStringVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetStringVal (obj PdfObject )(_cdegf string ,_dbacb bool ){_fdac ,_dbacb :=TraceToDirectObject (obj ).(*PdfObjectString );if _dbacb {return _fdac .Str (),true ;};return ;};func (_fafe *PdfParser )repairRebuildXrefsTopDown ()(*XrefTable ,error ){if _fafe ._fadg {return nil ,_af .Errorf ("\u0072\u0065\u0070\u0061\u0069\u0072\u0020\u0066\u0061\u0069\u006c\u0065\u0064");
};_fafe ._fadg =true ;_fafe ._cgda .Seek (0,_gg .SeekStart );_fafe ._fbgde =_b .NewReader (_fafe ._cgda );_bfbf :=20;_gefef :=make ([]byte ,_bfbf );_beaf :=XrefTable {};_beaf .ObjectMap =make (map[int ]XrefObject );for {_fdfg ,_fage :=_fafe ._fbgde .ReadByte ();
if _fage !=nil {if _fage ==_gg .EOF {break ;}else {return nil ,_fage ;};};if _fdfg =='j'&&_gefef [_bfbf -1]=='b'&&_gefef [_bfbf -2]=='o'&&IsWhiteSpace (_gefef [_bfbf -3]){_fcfad :=_bfbf -4;for IsWhiteSpace (_gefef [_fcfad ])&&_fcfad > 0{_fcfad --;};if _fcfad ==0||!IsDecimalDigit (_gefef [_fcfad ]){continue ;
};for IsDecimalDigit (_gefef [_fcfad ])&&_fcfad > 0{_fcfad --;};if _fcfad ==0||!IsWhiteSpace (_gefef [_fcfad ]){continue ;};for IsWhiteSpace (_gefef [_fcfad ])&&_fcfad > 0{_fcfad --;};if _fcfad ==0||!IsDecimalDigit (_gefef [_fcfad ]){continue ;};for IsDecimalDigit (_gefef [_fcfad ])&&_fcfad > 0{_fcfad --;
};if _fcfad ==0{continue ;};_cedf :=_fafe .GetFileOffset ()-int64 (_bfbf -_fcfad );_ebddc :=append (_gefef [_fcfad +1:],_fdfg );_fgbg ,_ccba ,_fdede :=_egea (string (_ebddc ));if _fdede !=nil {_fdf .Log .Debug ("\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u006e\u0075\u006d\u0062\u0065r\u003a\u0020\u0025\u0076",_fdede );
return nil ,_fdede ;};if _ggdg ,_afbgb :=_beaf .ObjectMap [_fgbg ];!_afbgb ||_ggdg .Generation < _ccba {_fbcb :=XrefObject {};_fbcb .XType =XrefTypeTableEntry ;_fbcb .ObjectNumber =_fgbg ;_fbcb .Generation =_ccba ;_fbcb .Offset =_cedf ;_beaf .ObjectMap [_fgbg ]=_fbcb ;
};};_gefef =append (_gefef [1:_bfbf ],_fdfg );};_fafe ._eedae =nil ;return &_beaf ,nil ;};

// IsDecimalDigit checks if the character is a part of a decimal number string.
func IsDecimalDigit (c byte )bool {return '0'<=c &&c <='9'};func (_cfgfd *PdfParser )rebuildXrefTable ()error {_cdfaa :=XrefTable {};_cdfaa .ObjectMap =map[int ]XrefObject {};_edgbc :=make ([]int ,0,len (_cfgfd ._bfaa .ObjectMap ));for _bdde :=range _cfgfd ._bfaa .ObjectMap {_edgbc =append (_edgbc ,_bdde );
};_d .Ints (_edgbc );for _ ,_ddbbe :=range _edgbc {_babaa :=_cfgfd ._bfaa .ObjectMap [_ddbbe ];_fgfa ,_ ,_gfae :=_cfgfd .lookupByNumberWrapper (_ddbbe ,false );if _gfae !=nil {_fdf .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020U\u006e\u0061\u0062\u006ce t\u006f l\u006f\u006f\u006b\u0020\u0075\u0070\u0020ob\u006a\u0065\u0063\u0074\u0020\u0028\u0025s\u0029",_gfae );
_fdf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0063\u006fm\u0070\u006c\u0065\u0074\u0065\u006c\u0079\u0020\u0062\u0072\u006f\u006b\u0065\u006e\u0020\u002d\u0020\u0061\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0074\u006f \u0072\u0065\u0070\u0061\u0069r\u0020");
_dddgc ,_fgbe :=_cfgfd .repairRebuildXrefsTopDown ();if _fgbe !=nil {_fdf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0072\u0065\u0062\u0075\u0069l\u0064\u0020\u0072\u0065\u0070a\u0069\u0072 \u0028\u0025\u0073\u0029",_fgbe );
return _fgbe ;};_cfgfd ._bfaa =*_dddgc ;_fdf .Log .Debug ("\u0052e\u0070\u0061\u0069\u0072e\u0064\u0020\u0078\u0072\u0065f\u0020t\u0061b\u006c\u0065\u0020\u0062\u0075\u0069\u006ct");return nil ;};_bgdc ,_gdced ,_gfae :=_gbbd (_fgfa );if _gfae !=nil {return _gfae ;
};_babaa .ObjectNumber =int (_bgdc );_babaa .Generation =int (_gdced );_cdfaa .ObjectMap [int (_bgdc )]=_babaa ;};_cfgfd ._bfaa =_cdfaa ;_fdf .Log .Debug ("N\u0065w\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061b\u006c\u0065\u0020\u0062ui\u006c\u0074");
_bge (_cfgfd ._bfaa );return nil ;};func (_aedf *PdfParser )resolveReference (_eede *PdfObjectReference )(PdfObject ,bool ,error ){_fabe ,_gdabf :=_aedf .ObjCache [int (_eede .ObjectNumber )];if _gdabf {return _fabe ,true ,nil ;};_agcbe ,_bccd :=_aedf .LookupByReference (*_eede );
if _bccd !=nil {return nil ,false ,_bccd ;};_aedf .ObjCache [int (_eede .ObjectNumber )]=_agcbe ;return _agcbe ,false ,nil ;};

// Encrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_ccgba *PdfCrypt )Encrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _ccgba .isEncrypted (obj ){return nil ;};switch _gdab :=obj .(type ){case *PdfIndirectObject :_ccgba ._fcb [_gdab ]=true ;_fdf .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_gdab .ObjectNumber ,_gdab .GenerationNumber );
_fab :=_gdab .ObjectNumber ;_fcfa :=_gdab .GenerationNumber ;_gfg :=_ccgba .Encrypt (_gdab .PdfObject ,_fab ,_fcfa );if _gfg !=nil {return _gfg ;};return nil ;case *PdfObjectStream :_ccgba ._fcb [_gdab ]=true ;_gce :=_gdab .PdfObjectDictionary ;if _cecb ,_ddaf :=_gce .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );
_ddaf &&*_cecb =="\u0058\u0052\u0065\u0066"{return nil ;};_cbg :=_gdab .ObjectNumber ;_ddad :=_gdab .GenerationNumber ;_fdf .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_cbg ,_ddad );
_bcga :=_cfg ;if _ccgba ._cbc .V >=4{_bcga =_ccgba ._afb ;_fdf .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_ccgba ._afb );if _adga ,_cee :=_gce .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );
_cee {if _fbcg ,_eegd :=GetName (_adga .Get (0));_eegd {if *_fbcg =="\u0043\u0072\u0079p\u0074"{_bcga ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _fgfc ,_efae :=_gce .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );
_efae {if _dfg ,_feda :=_fgfc .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_feda {if _ ,_cfb :=_ccgba ._bafb [string (*_dfg )];_cfb {_fdf .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_dfg );
_bcga =string (*_dfg );};};};};};};_fdf .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_bcga );if _bcga =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_gdafg :=_ccgba .Encrypt (_gdab .PdfObjectDictionary ,_cbg ,_ddad );
if _gdafg !=nil {return _gdafg ;};_dgad ,_gdafg :=_ccgba .makeKey (_bcga ,uint32 (_cbg ),uint32 (_ddad ),_ccgba ._adb );if _gdafg !=nil {return _gdafg ;};_gdab .Stream ,_gdafg =_ccgba .encryptBytes (_gdab .Stream ,_bcga ,_dgad );if _gdafg !=nil {return _gdafg ;
};_gce .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_gdab .Stream ))));return nil ;case *PdfObjectString :_fdf .Log .Trace ("\u0045n\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_dcbb :=_cfg ;
if _ccgba ._cbc .V >=4{_fdf .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_ccgba ._egg );if _ccgba ._egg =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_dcbb =_ccgba ._egg ;};_bfa ,_cfa :=_ccgba .makeKey (_dcbb ,uint32 (parentObjNum ),uint32 (parentGenNum ),_ccgba ._adb );
if _cfa !=nil {return _cfa ;};_cbga :=_gdab .Str ();_dffe :=make ([]byte ,len (_cbga ));for _abb :=0;_abb < len (_cbga );_abb ++{_dffe [_abb ]=_cbga [_abb ];};_fdf .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_dffe ,_dffe );
_dffe ,_cfa =_ccgba .encryptBytes (_dffe ,_dcbb ,_bfa );if _cfa !=nil {return _cfa ;};_gdab ._eagb =string (_dffe );return nil ;case *PdfObjectArray :for _ ,_bdca :=range _gdab .Elements (){_caa :=_ccgba .Encrypt (_bdca ,parentObjNum ,parentGenNum );if _caa !=nil {return _caa ;
};};return nil ;case *PdfObjectDictionary :_gbge :=false ;if _ddbb :=_gdab .Get ("\u0054\u0079\u0070\u0065");_ddbb !=nil {_afef ,_dfdf :=_ddbb .(*PdfObjectName );if _dfdf &&*_afef =="\u0053\u0069\u0067"{_gbge =true ;};};for _ ,_ggda :=range _gdab .Keys (){_bbde :=_gdab .Get (_ggda );
if _gbge &&string (_ggda )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;};if string (_ggda )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_ggda )!="\u0050\u0072\u0065\u0076"&&string (_ggda )!="\u004c\u0061\u0073\u0074"{_efff :=_ccgba .Encrypt (_bbde ,parentObjNum ,parentGenNum );
if _efff !=nil {return _efff ;};};};return nil ;};return nil ;};func _cfbbb (_fabd string )(PdfObjectReference ,error ){_begf :=PdfObjectReference {};_ffgb :=_gfdab .FindStringSubmatch (_fabd );if len (_ffgb )< 3{_fdf .Log .Debug ("\u0045\u0072\u0072or\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");
return _begf ,_fb .New ("\u0075n\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061r\u0073e\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");};_cgea ,_ :=_a .Atoi (_ffgb [1]);_ffbfa ,_ :=_a .Atoi (_ffgb [2]);_begf .ObjectNumber =int64 (_cgea );_begf .GenerationNumber =int64 (_ffbfa );
return _begf ,nil ;};

// HeaderPosition gets the file header position.
func (_cgg ParserMetadata )HeaderPosition ()int {return _cgg ._gfdf };func (_accc *PdfParser )skipComments ()error {if _ ,_efdg :=_accc .skipSpaces ();_efdg !=nil {return _efdg ;};_ccad :=true ;for {_aaaaf ,_fdee :=_accc ._fbgde .Peek (1);if _fdee !=nil {_fdf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_fdee .Error ());
return _fdee ;};if _ccad &&_aaaaf [0]!='%'{return nil ;};_ccad =false ;if (_aaaaf [0]!='\r')&&(_aaaaf [0]!='\n'){_accc ._fbgde .ReadByte ();}else {break ;};};return _accc .skipComments ();};

// GetFilterArray returns the names of the underlying encoding filters in an array that
// can be used as /Filter entry.
func (_agfb *MultiEncoder )GetFilterArray ()*PdfObjectArray {_gdda :=make ([]PdfObject ,len (_agfb ._cbdf ));for _edaf ,_fggb :=range _agfb ._cbdf {_gdda [_edaf ]=MakeName (_fggb .GetFilterName ());};return MakeArray (_gdda ...);};

// MakeDict creates and returns an empty PdfObjectDictionary.
func MakeDict ()*PdfObjectDictionary {_dbfbe :=&PdfObjectDictionary {};_dbfbe ._cgbf =map[PdfObjectName ]PdfObject {};_dbfbe ._aadg =[]PdfObjectName {};_dbfbe ._dggf =&_fd .Mutex {};return _dbfbe ;};

// Elements returns a slice of the PdfObject elements in the array.
// Preferred over accessing the array directly as type may be changed in future major versions (v3).
func (_dfbd *PdfObjectStreams )Elements ()[]PdfObject {if _dfbd ==nil {return nil ;};return _dfbd ._aagf ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_bcgc *JPXEncoder )MakeDecodeParams ()PdfObject {return nil };func _gafcc (_fagg ,_dagfd ,_bgef int )error {if _dagfd < 0||_dagfd > _fagg {return _fb .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0061\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");
};if _bgef < _dagfd {return _fb .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0073\u006c\u0069\u0063e\u0020i\u006ed\u0065\u0078\u0020\u0062\u0020\u003c\u0020a");};if _bgef > _fagg {return _fb .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0062\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");
};return nil ;};

// MakeInteger creates a PdfObjectInteger from an int64.
func MakeInteger (val int64 )*PdfObjectInteger {_geed :=PdfObjectInteger (val );return &_geed };

// Get returns the i-th element of the array or nil if out of bounds (by index).
func (_bebc *PdfObjectArray )Get (i int )PdfObject {if _bebc ==nil ||i >=len (_bebc ._beeag )||i < 0{return nil ;};return _bebc ._beeag [i ];};

// PdfObjectReference represents the primitive PDF reference object.
type PdfObjectReference struct{_gdad *PdfParser ;ObjectNumber int64 ;GenerationNumber int64 ;};func _ggd (_aecc int )cryptFilters {return cryptFilters {_cfg :_gd .NewFilterV2 (_aecc )}};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set.  Some other parameters are generated elsewhere.
func (_aeege *DCTEncoder )MakeStreamDict ()*PdfObjectDictionary {_fgeb :=MakeDict ();_fgeb .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_aeege .GetFilterName ()));return _fgeb ;};

// Decrypt attempts to decrypt the PDF file with a specified password.  Also tries to
// decrypt with an empty password.  Returns true if successful, false otherwise.
// An error is returned when there is a problem with decrypting.
func (_bcab *PdfParser )Decrypt (password []byte )(bool ,error ){if _bcab ._adfa ==nil {return false ,_fb .New ("\u0063\u0068\u0065\u0063k \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u0069\u0072s\u0074");};_fefg ,_adbb :=_bcab ._adfa .authenticate (password );
if _adbb !=nil {return false ,_adbb ;};if !_fefg {_fefg ,_adbb =_bcab ._adfa .authenticate ([]byte (""));};return _fefg ,_adbb ;};

// String returns a string describing `d`.
func (_afcd *PdfObjectDictionary )String ()string {var _acfbd _eaa .Builder ;_acfbd .WriteString ("\u0044\u0069\u0063t\u0028");for _ ,_gde :=range _afcd ._aadg {_ecece :=_afcd ._cgbf [_gde ];_acfbd .WriteString ("\u0022"+_gde .String ()+"\u0022\u003a\u0020");
_acfbd .WriteString (_ecece .String ());_acfbd .WriteString ("\u002c\u0020");};_acfbd .WriteString ("\u0029");return _acfbd .String ();};

// UpdateParams updates the parameter values of the encoder.
func (_ccb *FlateEncoder )UpdateParams (params *PdfObjectDictionary ){_gadf ,_deca :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _deca ==nil {_ccb .Predictor =int (_gadf );};_edgb ,_deca :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));
if _deca ==nil {_ccb .BitsPerComponent =int (_edgb );};_bad ,_deca :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _deca ==nil {_ccb .Columns =int (_bad );};_caff ,_deca :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));
if _deca ==nil {_ccb .Colors =int (_caff );};};var _cdg =_fb .New ("\u0045\u004f\u0046\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");

// MakeArray creates an PdfObjectArray from a list of PdfObjects.
func MakeArray (objects ...PdfObject )*PdfObjectArray {return &PdfObjectArray {_beeag :objects }};func _decf (_afec *_ge .StdEncryptDict ,_gef *PdfObjectDictionary )error {R ,_cbea :=_gef .Get ("\u0052").(*PdfObjectInteger );if !_cbea {return _fb .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0052");
};if *R < 2||*R > 6{return _af .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0052 \u0028\u0025\u0064\u0029",*R );};_afec .R =int (*R );O ,_cbea :=_gef .GetString ("\u004f");if !_cbea {return _fb .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u004f");
};if _afec .R ==5||_afec .R ==6{if len (O )< 48{return _af .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u004f\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (O ));};}else if len (O )!=32{return _af .Errorf ("L\u0065n\u0067\u0074\u0068\u0028\u004f\u0029\u0020\u0021=\u0020\u0033\u0032\u0020(%\u0064\u0029",len (O ));
};_afec .O =[]byte (O );U ,_cbea :=_gef .GetString ("\u0055");if !_cbea {return _fb .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0055");};if _afec .R ==5||_afec .R ==6{if len (U )< 48{return _af .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u0055\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (U ));
};}else if len (U )!=32{_fdf .Log .Debug ("\u0057\u0061r\u006e\u0069\u006e\u0067\u003a\u0020\u004c\u0065\u006e\u0067\u0074\u0068\u0028\u0055\u0029\u0020\u0021\u003d\u0020\u0033\u0032\u0020(%\u0064\u0029",len (U ));};_afec .U =[]byte (U );if _afec .R >=5{OE ,_cac :=_gef .GetString ("\u004f\u0045");
if !_cac {return _fb .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u004f\u0045");}else if len (OE )!=32{return _af .Errorf ("L\u0065\u006e\u0067\u0074h(\u004fE\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (OE ));
};_afec .OE =[]byte (OE );UE ,_cac :=_gef .GetString ("\u0055\u0045");if !_cac {return _fb .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u0055\u0045");
}else if len (UE )!=32{return _af .Errorf ("L\u0065\u006e\u0067\u0074h(\u0055E\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (UE ));};_afec .UE =[]byte (UE );};P ,_cbea :=_gef .Get ("\u0050").(*PdfObjectInteger );if !_cbea {return _fb .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074 \u0064\u0069\u0063t\u0069\u006f\u006e\u0061r\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0070\u0065\u0072\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0061\u0074\u0074\u0072");
};_afec .P =_ge .Permissions (*P );if _afec .R ==6{Perms ,_dda :=_gef .GetString ("\u0050\u0065\u0072m\u0073");if !_dda {return _fb .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0050\u0065\u0072\u006d\u0073");
}else if len (Perms )!=16{return _af .Errorf ("\u004ce\u006e\u0067\u0074\u0068\u0028\u0050\u0065\u0072\u006d\u0073\u0029 \u0021\u003d\u0020\u0031\u0036\u0020\u0028\u0025\u0064\u0029",len (Perms ));};_afec .Perms =[]byte (Perms );};if _eef ,_bba :=_gef .Get ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061").(*PdfObjectBool );
_bba {_afec .EncryptMetadata =bool (*_eef );}else {_afec .EncryptMetadata =true ;};return nil ;};

// FlateEncoder represents Flate encoding.
type FlateEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Rows int ;Colors int ;_bgdb *_gb .ImageBase ;};func (_baddc *PdfParser )inspect ()(map[string ]int ,error ){_fdf .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0053P\u0045\u0043\u0054\u0020\u002d\u002d\u002d\u002d\u002d\u002d-\u002d\u002d\u002d");
_fdf .Log .Trace ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");_befdb :=map[string ]int {};_bccb :=0;_fffg :=0;var _baddcf []int ;for _ddcbd :=range _baddc ._bfaa .ObjectMap {_baddcf =append (_baddcf ,_ddcbd );};_d .Ints (_baddcf );
_aacd :=0;for _ ,_egca :=range _baddcf {_fbgad :=_baddc ._bfaa .ObjectMap [_egca ];if _fbgad .ObjectNumber ==0{continue ;};_bccb ++;_fdf .Log .Trace ("\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d");_fdf .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0075\u0070\u0020\u006f\u0062\u006a\u0065c\u0074 \u006e\u0075\u006d\u0062\u0065\u0072\u003a \u0025\u0064",_fbgad .ObjectNumber );
_faaf ,_cafc :=_baddc .LookupByNumber (_fbgad .ObjectNumber );if _cafc !=nil {_fdf .Log .Trace ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u006c\u006f\u006f\u006b\u0075p\u0020\u006f\u0062\u006a\u0020\u0025\u0064 \u0028\u0025\u0073\u0029",_fbgad .ObjectNumber ,_cafc );
_fffg ++;continue ;};_fdf .Log .Trace ("\u006fb\u006a\u003a\u0020\u0025\u0073",_faaf );_gdgcd ,_bcabb :=_faaf .(*PdfIndirectObject );if _bcabb {_fdf .Log .Trace ("\u0049N\u0044 \u004f\u004f\u0042\u004a\u0020\u0025\u0064\u003a\u0020\u0025\u0073",_fbgad .ObjectNumber ,_gdgcd );
_fffe ,_aaea :=_gdgcd .PdfObject .(*PdfObjectDictionary );if _aaea {if _cafgab ,_dedf :=_fffe .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_dedf {_cdbg :=string (*_cafgab );_fdf .Log .Trace ("\u002d\u002d\u002d\u003e\u0020\u004f\u0062\u006a\u0020\u0074\u0079\u0070e\u003a\u0020\u0025\u0073",_cdbg );
_ ,_egef :=_befdb [_cdbg ];if _egef {_befdb [_cdbg ]++;}else {_befdb [_cdbg ]=1;};}else if _edecf ,_cabeg :=_fffe .Get ("\u0053u\u0062\u0074\u0079\u0070\u0065").(*PdfObjectName );_cabeg {_dafae :=string (*_edecf );_fdf .Log .Trace ("-\u002d-\u003e\u0020\u004f\u0062\u006a\u0020\u0073\u0075b\u0074\u0079\u0070\u0065: \u0025\u0073",_dafae );
_ ,_cfceg :=_befdb [_dafae ];if _cfceg {_befdb [_dafae ]++;}else {_befdb [_dafae ]=1;};};if _gdaa ,_cceg :=_fffe .Get ("\u0053").(*PdfObjectName );_cceg &&*_gdaa =="\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"{_ ,_aaef :=_befdb ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"];
if _aaef {_befdb ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]++;}else {_befdb ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]=1;};};};}else if _gfff ,_fcgac :=_faaf .(*PdfObjectStream );_fcgac {if _egdc ,_aegbc :=_gfff .PdfObjectDictionary .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );
_aegbc {_fdf .Log .Trace ("\u002d\u002d\u003e\u0020\u0053\u0074\u0072\u0065\u0061\u006d\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073",*_egdc );_dcbc :=string (*_egdc );_befdb [_dcbc ]++;};}else {_dcdac ,_acfbb :=_faaf .(*PdfObjectDictionary );
if _acfbb {_befga ,_ffff :=_dcdac .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if _ffff {_fgbad :=string (*_befga );_fdf .Log .Trace ("\u002d-\u002d \u006f\u0062\u006a\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073",_fgbad );_befdb [_fgbad ]++;
};};_fdf .Log .Trace ("\u0044\u0049\u0052\u0045\u0043\u0054\u0020\u004f\u0042\u004a\u0020\u0025d\u003a\u0020\u0025\u0073",_fbgad .ObjectNumber ,_faaf );};_aacd ++;};_fdf .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0045\u004fF\u0020\u0049\u004e\u0053\u0050\u0045\u0043T\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d");
_fdf .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");_fdf .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074 \u0063\u006f\u0075\u006e\u0074\u003a\u0020\u0025\u0064",_bccb );_fdf .Log .Trace ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u006f\u006b\u0075p\u003a\u0020\u0025\u0064",_fffg );
for _gafa ,_bdff :=range _befdb {_fdf .Log .Trace ("\u0025\u0073\u003a\u0020\u0025\u0064",_gafa ,_bdff );};_fdf .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");if len (_baddc ._bfaa .ObjectMap )< 1{_fdf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0068\u0069\u0073 \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074 \u0069s\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0028\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0021\u0029");
return nil ,_af .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0064\u006fc\u0075\u006d\u0065\u006e\u0074\u0020\u0028\u0078r\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006d\u0069\u0073s\u0069\u006e\u0067\u0029");};_gfba ,_gdec :=_befdb ["\u0046\u006f\u006e\u0074"];
if !_gdec ||_gfba < 2{_fdf .Log .Trace ("\u0054\u0068\u0069s \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020i\u0073 \u0070r\u006fb\u0061\u0062\u006c\u0079\u0020\u0073\u0063\u0061\u006e\u006e\u0065\u0064\u0021");}else {_fdf .Log .Trace ("\u0054\u0068\u0069\u0073\u0020\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020\u0069\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0066o\u0072\u0020\u0065\u0078\u0074r\u0061\u0063t\u0069\u006f\u006e\u0021");
};return _befdb ,nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_ccgf *ASCIIHexEncoder )MakeDecodeParams ()PdfObject {return nil };

// HasDataAfterEOF checks if there is some data after EOF marker.
func (_afbe ParserMetadata )HasDataAfterEOF ()bool {return _afbe ._fdc };

// Validate validates the page settings for the JBIG2 encoder.
func (_debf JBIG2EncoderSettings )Validate ()error {const _becc ="\u0076a\u006ci\u0064\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065\u0072";if _debf .Threshold < 0||_debf .Threshold > 1.0{return _de .Errorf (_becc ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074\u0068\u0072\u0065\u0073\u0068\u006f\u006c\u0064\u0020\u0076a\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0076\u0027 \u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0069\u006e\u0020\u0072\u0061n\u0067\u0065\u0020\u005b\u0030\u002e0\u002c\u0020\u0031.\u0030\u005d",_debf .Threshold );
};if _debf .ResolutionX < 0{return _de .Errorf (_becc ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0078\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_debf .ResolutionX );
};if _debf .ResolutionY < 0{return _de .Errorf (_becc ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0079\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_debf .ResolutionY );
};if _debf .DefaultPixelValue !=0&&_debf .DefaultPixelValue !=1{return _de .Errorf (_becc ,"de\u0066\u0061u\u006c\u0074\u0020\u0070\u0069\u0078\u0065\u006c\u0020v\u0061\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0066o\u0072 \u0074\u0068\u0065\u0020\u0062\u0069\u0074\u003a \u007b0\u002c\u0031}",_debf .DefaultPixelValue );
};if _debf .Compression !=JB2Generic {return _de .Errorf (_becc ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065d\u0020\u0063\u006fm\u0070\u0072\u0065\u0073s\u0069\u006f\u006e\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
};return nil ;};

// DecodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_efbb *RawEncoder )DecodeBytes (encoded []byte )([]byte ,error ){return encoded ,nil };

// Append appends PdfObject(s) to the streams.
func (_fcae *PdfObjectStreams )Append (objects ...PdfObject ){if _fcae ==nil {_fdf .Log .Debug ("\u0057\u0061\u0072\u006e\u0020-\u0020\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0020\u0074\u006f\u0020\u0061p\u0070\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0073");
return ;};_fcae ._aagf =append (_fcae ._aagf ,objects ...);};

// TraceToDirectObject traces a PdfObject to a direct object.  For example direct objects contained
// in indirect objects (can be double referenced even).
func TraceToDirectObject (obj PdfObject )PdfObject {if _bbff ,_gcae :=obj .(*PdfObjectReference );_gcae {obj =_bbff .Resolve ();};_faab ,_efddc :=obj .(*PdfIndirectObject );_dgcg :=0;for _efddc {obj =_faab .PdfObject ;_faab ,_efddc =GetIndirect (obj );
_dgcg ++;if _dgcg > _gbdc {_fdf .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0072\u0061\u0063\u0065\u0020\u0064\u0065p\u0074\u0068\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u0062\u0065\u0079\u006fn\u0064\u0020\u0025\u0064\u0020\u002d\u0020\u006e\u006f\u0074\u0020\u0067oi\u006e\u0067\u0020\u0064\u0065\u0065\u0070\u0065\u0072\u0021",_gbdc );
return nil ;};};return obj ;};

// SetPredictor sets the predictor function.  Specify the number of columns per row.
// The columns indicates the number of samples per row.
// Used for grouping data together for compression.
func (_bbdef *FlateEncoder )SetPredictor (columns int ){_bbdef .Predictor =11;_bbdef .Columns =columns ;};

// EncodeBytes JPX encodes the passed in slice of bytes.
func (_fgad *JPXEncoder )EncodeBytes (data []byte )([]byte ,error ){_fdf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_fgad .GetFilterName ());
return data ,ErrNoJPXDecode ;};const _bfg =32<<(^uint (0)>>63);

// UpdateParams updates the parameter values of the encoder.
func (_ecc *LZWEncoder )UpdateParams (params *PdfObjectDictionary ){_dgg ,_dbfb :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _dbfb ==nil {_ecc .Predictor =int (_dgg );};_fegf ,_dbfb :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));
if _dbfb ==nil {_ecc .BitsPerComponent =int (_fegf );};_aac ,_dbfb :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _dbfb ==nil {_ecc .Columns =int (_aac );};_ebcg ,_dbfb :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));
if _dbfb ==nil {_ecc .Colors =int (_ebcg );};_cca ,_dbfb :=GetNumberAsInt64 (params .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065"));if _dbfb ==nil {_ecc .EarlyChange =int (_cca );};};const (StreamEncodingFilterNameFlate ="F\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065";
StreamEncodingFilterNameLZW ="\u004cZ\u0057\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameDCT ="\u0044C\u0054\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameRunLength ="\u0052u\u006eL\u0065\u006e\u0067\u0074\u0068\u0044\u0065\u0063\u006f\u0064\u0065";
StreamEncodingFilterNameASCIIHex ="\u0041\u0053\u0043\u0049\u0049\u0048\u0065\u0078\u0044e\u0063\u006f\u0064\u0065";StreamEncodingFilterNameASCII85 ="\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameCCITTFax ="\u0043\u0043\u0049\u0054\u0054\u0046\u0061\u0078\u0044e\u0063\u006f\u0064\u0065";
StreamEncodingFilterNameJBIG2 ="J\u0042\u0049\u0047\u0032\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameJPX ="\u004aP\u0058\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameRaw ="\u0052\u0061\u0077";);var _ffebb _fd .Map ;type objectCache map[int ]PdfObject ;


// GetFilterName returns the name of the encoding filter.
func (_fcd *CCITTFaxEncoder )GetFilterName ()string {return StreamEncodingFilterNameCCITTFax };

// String returns a string describing `stream`.
func (_bedd *PdfObjectStream )String ()string {return _af .Sprintf ("O\u0062j\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0025\u0064: \u0025\u0073",_bedd .ObjectNumber ,_bedd .PdfObjectDictionary );};

// WriteString outputs the object as it is to be written to file.
func (_cfce *PdfObjectInteger )WriteString ()string {return _a .FormatInt (int64 (*_cfce ),10)};func (_ffe *PdfCrypt )isDecrypted (_fgf PdfObject )bool {_ ,_ebc :=_ffe ._bbd [_fgf ];if _ebc {_fdf .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0064\u0065\u0063\u0072y\u0070\u0074\u0065\u0064");
return true ;};switch _bbae :=_fgf .(type ){case *PdfObjectStream :if _ffe ._aebg .R !=5{if _fbdc ,_abe :=_bbae .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_abe &&*_fbdc =="\u0058\u0052\u0065\u0066"{return true ;};};case *PdfIndirectObject :if _ ,_ebc =_ffe ._bga [int (_bbae .ObjectNumber )];
_ebc {return true ;};switch _cef :=_bbae .PdfObject .(type ){case *PdfObjectDictionary :_cbf :=true ;for _ ,_ecfc :=range _eabc {if _cef .Get (_ecfc )==nil {_cbf =false ;break ;};};if _cbf {return true ;};};};_fdf .Log .Trace ("\u004e\u006f\u0074\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");
return false ;};func (_fbb *JBIG2Encoder )encodeImage (_bfdb _fg .Image )([]byte ,error ){const _ffcc ="e\u006e\u0063\u006f\u0064\u0065\u0049\u006d\u0061\u0067\u0065";_acb ,_gbfd :=GoImageToJBIG2 (_bfdb ,JB2ImageAutoThreshold );if _gbfd !=nil {return nil ,_de .Wrap (_gbfd ,_ffcc ,"\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069m\u0061g\u0065\u0020\u0074\u006f\u0020\u006a\u0062\u0069\u0067\u0032\u0020\u0069\u006d\u0067");
};if _gbfd =_fbb .AddPageImage (_acb ,&_fbb .DefaultPageSettings );_gbfd !=nil {return nil ,_de .Wrap (_gbfd ,_ffcc ,"");};return _fbb .Encode ();};

// DecodeBytes decodes byte array with ASCII85. 5 ASCII characters -> 4 raw binary bytes
func (_fbcga *ASCII85Encoder )DecodeBytes (encoded []byte )([]byte ,error ){var _ebad []byte ;_fdf .Log .Trace ("\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0020\u0044e\u0063\u006f\u0064\u0065");_agg :=0;_feafe :=false ;for _agg < len (encoded )&&!_feafe {_gfbb :=[5]byte {0,0,0,0,0};
_feab :=0;_abd :=0;_abgd :=4;for _abd < 5+_feab {if _agg +_abd ==len (encoded ){break ;};_cfde :=encoded [_agg +_abd ];if IsWhiteSpace (_cfde ){_feab ++;_abd ++;continue ;}else if _cfde =='~'&&_agg +_abd +1< len (encoded )&&encoded [_agg +_abd +1]=='>'{_abgd =(_abd -_feab )-1;
if _abgd < 0{_abgd =0;};_feafe =true ;break ;}else if _cfde >='!'&&_cfde <='u'{_cfde -='!';}else if _cfde =='z'&&_abd -_feab ==0{_abgd =4;_abd ++;break ;}else {_fdf .Log .Error ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u002c\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020co\u0064\u0065");
return nil ,_fb .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0063\u006f\u0064\u0065\u0020e\u006e\u0063\u006f\u0075\u006e\u0074\u0065\u0072\u0065\u0064");};_gfbb [_abd -_feab ]=_cfde ;_abd ++;};_agg +=_abd ;for _gegd :=_abgd +1;_gegd < 5;_gegd ++{_gfbb [_gegd ]=84;
};_eeeeb :=uint32 (_gfbb [0])*85*85*85*85+uint32 (_gfbb [1])*85*85*85+uint32 (_gfbb [2])*85*85+uint32 (_gfbb [3])*85+uint32 (_gfbb [4]);_feabc :=[]byte {byte ((_eeeeb >>24)&0xff),byte ((_eeeeb >>16)&0xff),byte ((_eeeeb >>8)&0xff),byte (_eeeeb &0xff)};_ebad =append (_ebad ,_feabc [:_abgd ]...);
};_fdf .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0065\u006e\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",encoded );_fdf .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0064\u0065\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",_ebad );
return _ebad ,nil ;};func _gbbd (_cg PdfObject )(int64 ,int64 ,error ){if _ed ,_dcc :=_cg .(*PdfIndirectObject );_dcc {return _ed .ObjectNumber ,_ed .GenerationNumber ,nil ;};if _bf ,_baf :=_cg .(*PdfObjectStream );_baf {return _bf .ObjectNumber ,_bf .GenerationNumber ,nil ;
};return 0,0,_fb .New ("\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u002f\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062je\u0063\u0074");};

// ParseNumber parses a numeric objects from a buffered stream.
// Section 7.3.3.
// Integer or Float.
//
// An integer shall be written as one or more decimal digits optionally
// preceded by a sign. The value shall be interpreted as a signed
// decimal integer and shall be converted to an integer object.
//
// A real value shall be written as one or more decimal digits with an
// optional sign and a leading, trailing, or embedded PERIOD (2Eh)
// (decimal point). The value shall be interpreted as a real number
// and shall be converted to a real object.
//
// Regarding exponential numbers: 7.3.3 Numeric Objects:
// A conforming writer shall not use the PostScript syntax for numbers
// with non-decimal radices (such as 16#FFFE) or in exponential format
// (such as 6.02E23).
// Nonetheless, we sometimes get numbers with exponential format, so
// we will support it in the reader (no confusion with other types, so
// no compromise).
func ParseNumber (buf *_b .Reader )(PdfObject ,error ){_bfed :=false ;_dfagc :=true ;var _ccbgg _dd .Buffer ;for {if _fdf .Log .IsLogLevel (_fdf .LogLevelTrace ){_fdf .Log .Trace ("\u0050\u0061\u0072\u0073in\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0022\u0025\u0073\u0022",_ccbgg .String ());
};_fagc ,_dagbdg :=buf .Peek (1);if _dagbdg ==_gg .EOF {break ;};if _dagbdg !=nil {_fdf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0025\u0073",_dagbdg );return nil ,_dagbdg ;};if _dfagc &&(_fagc [0]=='-'||_fagc [0]=='+'){_cbeag ,_ :=buf .ReadByte ();
_ccbgg .WriteByte (_cbeag );_dfagc =false ;}else if IsDecimalDigit (_fagc [0]){_bbcec ,_ :=buf .ReadByte ();_ccbgg .WriteByte (_bbcec );}else if _fagc [0]=='.'{_bbdag ,_ :=buf .ReadByte ();_ccbgg .WriteByte (_bbdag );_bfed =true ;}else if _fagc [0]=='e'||_fagc [0]=='E'{_daaaa ,_ :=buf .ReadByte ();
_ccbgg .WriteByte (_daaaa );_bfed =true ;_dfagc =true ;}else {break ;};};var _cddg PdfObject ;if _bfed {_ceac ,_ccfc :=_a .ParseFloat (_ccbgg .String (),64);if _ccfc !=nil {_fdf .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0025v\u0020\u0065\u0072\u0072\u003d\u0025v\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0030\u002e\u0020\u004fu\u0074\u0070u\u0074\u0020\u006d\u0061y\u0020\u0062\u0065\u0020\u0069n\u0063\u006f\u0072\u0072\u0065\u0063\u0074",_ccbgg .String (),_ccfc );
_ceac =0.0;};_adea :=PdfObjectFloat (_ceac );_cddg =&_adea ;}else {_effcd ,_edac :=_a .ParseInt (_ccbgg .String (),10,64);if _edac !=nil {_fdf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0025\u0076\u0020\u0065\u0072\u0072\u003d%\u0076\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074 \u006d\u0061\u0079\u0020\u0062\u0065 \u0069\u006ec\u006f\u0072r\u0065c\u0074",_ccbgg .String (),_edac );
_effcd =0;};_afde :=PdfObjectInteger (_effcd );_cddg =&_afde ;};return _cddg ,nil ;};

// DecodeImages decodes the page images from the jbig2 'encoded' data input.
// The jbig2 document may contain multiple pages, thus the function can return multiple
// images. The images order corresponds to the page number.
func (_fceb *JBIG2Encoder )DecodeImages (encoded []byte )([]_fg .Image ,error ){const _ccdcf ="\u004aB\u0049\u0047\u0032\u0045n\u0063\u006f\u0064\u0065\u0072.\u0044e\u0063o\u0064\u0065\u0049\u006d\u0061\u0067\u0065s";_ebbc ,_ebcgd :=_gge .Decode (encoded ,_gge .Parameters {},_fceb .Globals .ToDocumentGlobals ());
if _ebcgd !=nil {return nil ,_de .Wrap (_ebcgd ,_ccdcf ,"");};_dgbe ,_ebcgd :=_ebbc .PageNumber ();if _ebcgd !=nil {return nil ,_de .Wrap (_ebcgd ,_ccdcf ,"");};_cbbf :=[]_fg .Image {};var _ddgc _fg .Image ;for _deeef :=1;_deeef <=_dgbe ;_deeef ++{_ddgc ,_ebcgd =_ebbc .DecodePageImage (_deeef );
if _ebcgd !=nil {return nil ,_de .Wrapf (_ebcgd ,_ccdcf ,"\u0070\u0061\u0067\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_deeef );};_cbbf =append (_cbbf ,_ddgc );};return _cbbf ,nil ;};func _ccf (_gcga *_ge .StdEncryptDict ,_cdfc *PdfObjectDictionary ){_cdfc .Set ("\u0052",MakeInteger (int64 (_gcga .R )));
_cdfc .Set ("\u0050",MakeInteger (int64 (_gcga .P )));_cdfc .Set ("\u004f",MakeStringFromBytes (_gcga .O ));_cdfc .Set ("\u0055",MakeStringFromBytes (_gcga .U ));if _gcga .R >=5{_cdfc .Set ("\u004f\u0045",MakeStringFromBytes (_gcga .OE ));_cdfc .Set ("\u0055\u0045",MakeStringFromBytes (_gcga .UE ));
_cdfc .Set ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061",MakeBool (_gcga .EncryptMetadata ));if _gcga .R > 5{_cdfc .Set ("\u0050\u0065\u0072m\u0073",MakeStringFromBytes (_gcga .Perms ));};};};

// Clear resets the array to an empty state.
func (_abfba *PdfObjectArray )Clear (){_abfba ._beeag =[]PdfObject {}};func (_bbf *PdfParser )parseDetailedHeader ()(_affe error ){_bbf ._cgda .Seek (0,_gg .SeekStart );_bbf ._fbgde =_b .NewReader (_bbf ._cgda );_cffg :=20;_ebg :=make ([]byte ,_cffg );
var (_gcea bool ;_cdbb int ;);for {_faaa ,_fgcg :=_bbf ._fbgde .ReadByte ();if _fgcg !=nil {if _fgcg ==_gg .EOF {break ;}else {return _fgcg ;};};if IsDecimalDigit (_faaa )&&_ebg [_cffg -1]=='.'&&IsDecimalDigit (_ebg [_cffg -2])&&_ebg [_cffg -3]=='-'&&_ebg [_cffg -4]=='F'&&_ebg [_cffg -5]=='D'&&_ebg [_cffg -6]=='P'&&_ebg [_cffg -7]=='%'{_bbf ._ddc =Version {Major :int (_ebg [_cffg -2]-'0'),Minor :int (_faaa -'0')};
_bbf ._aadf ._gfdf =_cdbb -7;_gcea =true ;break ;};_cdbb ++;_ebg =append (_ebg [1:_cffg ],_faaa );};if !_gcea {return _af .Errorf ("n\u006f \u0066\u0069\u006c\u0065\u0020\u0068\u0065\u0061d\u0065\u0072\u0020\u0066ou\u006e\u0064");};_bbda ,_affe :=_bbf ._fbgde .ReadByte ();
if _affe ==_gg .EOF {return _af .Errorf ("\u006eo\u0074\u0020\u0061\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0050d\u0066\u0020\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074");};if _affe !=nil {return _affe ;};_bbf ._aadf ._eaac =_bbda =='\n';_bbda ,_affe =_bbf ._fbgde .ReadByte ();
if _affe !=nil {return _af .Errorf ("\u006e\u006f\u0074\u0020a\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0070\u0064\u0066 \u0064o\u0063\u0075\u006d\u0065\u006e\u0074\u003a \u0025\u0077",_affe );};if _bbda !='%'{return nil ;};_cgga :=make ([]byte ,4);_ ,_affe =_bbf ._fbgde .Read (_cgga );
if _affe !=nil {return _af .Errorf ("\u006e\u006f\u0074\u0020a\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0070\u0064\u0066 \u0064o\u0063\u0075\u006d\u0065\u006e\u0074\u003a \u0025\u0077",_affe );};_bbf ._aadf ._fddb =[4]byte {_cgga [0],_cgga [1],_cgga [2],_cgga [3]};
return nil ;};

// MakeHexString creates an PdfObjectString from a string intended for output as a hexadecimal string.
func MakeHexString (s string )*PdfObjectString {_gfcee :=PdfObjectString {_eagb :s ,_gccd :true };return &_gfcee ;};func _cfe (_dge *_gd .FilterDict ,_eecb *PdfObjectDictionary )error {if _fdde ,_cbcb :=_eecb .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );
_cbcb {if _dca :=string (*_fdde );_dca !="C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"{_fdf .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020C\u0046\u0020\u0064ic\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074e\u0072\u0029",_dca );
};};_afc ,_bgea :=_eecb .Get ("\u0043\u0046\u004d").(*PdfObjectName );if !_bgea {return _af .Errorf ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0028\u004e\u006f\u006e\u0065\u0029");
};_dge .CFM =string (*_afc );if _gfda ,_bdc :=_eecb .Get ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et").(*PdfObjectName );_bdc {_dge .AuthEvent =_ge .AuthEvent (*_gfda );}else {_dge .AuthEvent =_ge .EventDocOpen ;};if _adg ,_caf :=_eecb .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );
_caf {_dge .Length =int (*_adg );};return nil ;};func (_dfaf *PdfParser )parseObject ()(PdfObject ,error ){_fdf .Log .Trace ("\u0052e\u0061d\u0020\u0064\u0069\u0072\u0065c\u0074\u0020o\u0062\u006a\u0065\u0063\u0074");_dfaf .skipSpaces ();for {_fegg ,_fbaa :=_dfaf ._fbgde .Peek (2);
if _fbaa !=nil {if _fbaa !=_gg .EOF ||len (_fegg )==0{return nil ,_fbaa ;};if len (_fegg )==1{_fegg =append (_fegg ,' ');};};_fdf .Log .Trace ("\u0050e\u0065k\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u003a\u0020\u0025\u0073",string (_fegg ));if _fegg [0]=='/'{_fffad ,_dbdca :=_dfaf .parseName ();
_fdf .Log .Trace ("\u002d\u003e\u004ea\u006d\u0065\u003a\u0020\u0027\u0025\u0073\u0027",_fffad );return &_fffad ,_dbdca ;}else if _fegg [0]=='('{_fdf .Log .Trace ("\u002d>\u0053\u0074\u0072\u0069\u006e\u0067!");_bafce ,_dbdd :=_dfaf .parseString ();return _bafce ,_dbdd ;
}else if _fegg [0]=='['{_fdf .Log .Trace ("\u002d\u003e\u0041\u0072\u0072\u0061\u0079\u0021");_ecfcf ,_dgbc :=_dfaf .parseArray ();return _ecfcf ,_dgbc ;}else if (_fegg [0]=='<')&&(_fegg [1]=='<'){_fdf .Log .Trace ("\u002d>\u0044\u0069\u0063\u0074\u0021");
_befb ,_cae :=_dfaf .ParseDict ();return _befb ,_cae ;}else if _fegg [0]=='<'{_fdf .Log .Trace ("\u002d\u003e\u0048\u0065\u0078\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0021");_ggdac ,_cdcad :=_dfaf .parseHexString ();return _ggdac ,_cdcad ;}else if _fegg [0]=='%'{_dfaf .readComment ();
_dfaf .skipSpaces ();}else {_fdf .Log .Trace ("\u002d\u003eN\u0075\u006d\u0062e\u0072\u0020\u006f\u0072\u0020\u0072\u0065\u0066\u003f");_fegg ,_ =_dfaf ._fbgde .Peek (15);_cfec :=string (_fegg );_fdf .Log .Trace ("\u0050\u0065\u0065k\u0020\u0073\u0074\u0072\u003a\u0020\u0025\u0073",_cfec );
if (len (_cfec )> 3)&&(_cfec [:4]=="\u006e\u0075\u006c\u006c"){_fdef ,_ceagf :=_dfaf .parseNull ();return &_fdef ,_ceagf ;}else if (len (_cfec )> 4)&&(_cfec [:5]=="\u0066\u0061\u006cs\u0065"){_dfcf ,_dbed :=_dfaf .parseBool ();return &_dfcf ,_dbed ;}else if (len (_cfec )> 3)&&(_cfec [:4]=="\u0074\u0072\u0075\u0065"){_egfb ,_adgbe :=_dfaf .parseBool ();
return &_egfb ,_adgbe ;};_cfdd :=_gfdab .FindStringSubmatch (_cfec );if len (_cfdd )> 1{_fegg ,_ =_dfaf ._fbgde .ReadBytes ('R');_fdf .Log .Trace ("\u002d\u003e\u0020\u0021\u0052\u0065\u0066\u003a\u0020\u0027\u0025\u0073\u0027",string (_fegg [:]));_effc ,_daag :=_cfbbb (string (_fegg ));
_effc ._gdad =_dfaf ;return &_effc ,_daag ;};_gggd :=_aace .FindStringSubmatch (_cfec );if len (_gggd )> 1{_fdf .Log .Trace ("\u002d\u003e\u0020\u004e\u0075\u006d\u0062\u0065\u0072\u0021");_fcebb ,_bbaa :=_dfaf .parseNumber ();return _fcebb ,_bbaa ;};_gggd =_fcfd .FindStringSubmatch (_cfec );
if len (_gggd )> 1{_fdf .Log .Trace ("\u002d\u003e\u0020\u0045xp\u006f\u006e\u0065\u006e\u0074\u0069\u0061\u006c\u0020\u004e\u0075\u006d\u0062\u0065r\u0021");_fdf .Log .Trace ("\u0025\u0020\u0073",_gggd );_ggfd ,_aeae :=_dfaf .parseNumber ();return _ggfd ,_aeae ;
};_fdf .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020U\u006e\u006b\u006e\u006f\u0077n\u0020(\u0070e\u0065\u006b\u0020\u0022\u0025\u0073\u0022)",_cfec );return nil ,_fb .New ("\u006f\u0062\u006a\u0065\u0063t\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020\u0075\u006e\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e");
};};};

// GetFloatVal returns the float64 value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetFloatVal (obj PdfObject )(_dbef float64 ,_fbae bool ){_abeef ,_fbae :=TraceToDirectObject (obj ).(*PdfObjectFloat );if _fbae {return float64 (*_abeef ),true ;};return 0,false ;};

// UpdateParams updates the parameter values of the encoder.
// Implements StreamEncoder interface.
func (_dbcc *JBIG2Encoder )UpdateParams (params *PdfObjectDictionary ){_fcbf ,_ceag :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _ceag ==nil {_dbcc .BitsPerComponent =int (_fcbf );
};_gcd ,_ceag :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _ceag ==nil {_dbcc .Width =int (_gcd );};_ffeb ,_ceag :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _ceag ==nil {_dbcc .Height =int (_ffeb );
};_gccc ,_ceag :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _ceag ==nil {_dbcc .ColorComponents =int (_gccc );};};

// GetAccessPermissions returns the PDF access permissions as an AccessPermissions object.
func (_gcf *PdfCrypt )GetAccessPermissions ()_ge .Permissions {return _gcf ._aebg .P };

// Seek implementation of Seek interface.
func (_efdff *limitedReadSeeker )Seek (offset int64 ,whence int )(int64 ,error ){var _aaca int64 ;switch whence {case _gg .SeekStart :_aaca =offset ;case _gg .SeekCurrent :_cebc ,_cffea :=_efdff ._acfb .Seek (0,_gg .SeekCurrent );if _cffea !=nil {return 0,_cffea ;
};_aaca =_cebc +offset ;case _gg .SeekEnd :_aaca =_efdff ._aggf +offset ;};if _cbaf :=_efdff .getError (_aaca );_cbaf !=nil {return 0,_cbaf ;};if _ ,_acdcf :=_efdff ._acfb .Seek (_aaca ,_gg .SeekStart );_acdcf !=nil {return 0,_acdcf ;};return _aaca ,nil ;
};

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_bdef *RunLengthEncoder )EncodeBytes (data []byte )([]byte ,error ){_efe :=_dd .NewReader (data );var _gaga []byte ;var _cgd []byte ;_cdfa ,_fcfeg :=_efe .ReadByte ();if _fcfeg ==_gg .EOF {return []byte {},nil ;}else if _fcfeg !=nil {return nil ,_fcfeg ;
};_gdbf :=1;for {_cggg ,_beg :=_efe .ReadByte ();if _beg ==_gg .EOF {break ;}else if _beg !=nil {return nil ,_beg ;};if _cggg ==_cdfa {if len (_cgd )> 0{_cgd =_cgd [:len (_cgd )-1];if len (_cgd )> 0{_gaga =append (_gaga ,byte (len (_cgd )-1));_gaga =append (_gaga ,_cgd ...);
};_gdbf =1;_cgd =[]byte {};};_gdbf ++;if _gdbf >=127{_gaga =append (_gaga ,byte (257-_gdbf ),_cdfa );_gdbf =0;};}else {if _gdbf > 0{if _gdbf ==1{_cgd =[]byte {_cdfa };}else {_gaga =append (_gaga ,byte (257-_gdbf ),_cdfa );};_gdbf =0;};_cgd =append (_cgd ,_cggg );
if len (_cgd )>=127{_gaga =append (_gaga ,byte (len (_cgd )-1));_gaga =append (_gaga ,_cgd ...);_cgd =[]byte {};};};_cdfa =_cggg ;};if len (_cgd )> 0{_gaga =append (_gaga ,byte (len (_cgd )-1));_gaga =append (_gaga ,_cgd ...);}else if _gdbf > 0{_gaga =append (_gaga ,byte (257-_gdbf ),_cdfa );
};_gaga =append (_gaga ,128);return _gaga ,nil ;};

// ParserMetadata gets the pdf parser metadata.
func (_dabc *PdfParser )ParserMetadata ()(ParserMetadata ,error ){if !_dabc ._dcfb {return ParserMetadata {},_af .Errorf ("\u0070\u0061\u0072\u0073\u0065r\u0020\u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u006d\u0061\u0072\u006be\u0064\u0020\u0066\u006f\u0072\u0020\u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0064\u0065\u0074\u0061\u0069\u006c\u0065\u0064\u0020\u006d\u0065\u0074\u0061\u0064\u0061\u0074a");
};return _dabc ._aadf ,nil ;};func (_geeb *PdfParser )skipSpaces ()(int ,error ){_geef :=0;for {_bebd ,_decc :=_geeb ._fbgde .ReadByte ();if _decc !=nil {return 0,_decc ;};if IsWhiteSpace (_bebd ){_geef ++;}else {_geeb ._fbgde .UnreadByte ();break ;};};
return _geef ,nil ;};

// XrefObject defines a cross reference entry which is a map between object number (with generation number) and the
// location of the actual object, either as a file offset (xref table entry), or as a location within an xref
// stream object (xref object stream).
type XrefObject struct{XType xrefType ;ObjectNumber int ;Generation int ;

// For normal xrefs (defined by OFFSET)
Offset int64 ;

// For xrefs to object streams.
OsObjNumber int ;OsObjIndex int ;};func (_bebe *FlateEncoder )postDecodePredict (_dabb []byte )([]byte ,error ){if _bebe .Predictor > 1{if _bebe .Predictor ==2{_fdf .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");
_fdf .Log .Trace ("\u0043\u006f\u006c\u006f\u0072\u0073\u003a\u0020\u0025\u0064",_bebe .Colors );_ffg :=_bebe .Columns *_bebe .Colors ;if _ffg < 1{return []byte {},nil ;};_ffdc :=len (_dabb )/_ffg ;if len (_dabb )%_ffg !=0{_fdf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");
return nil ,_af .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_dabb ),_ffg );};if _ffg %_bebe .Colors !=0{return nil ,_af .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_ffg ,_bebe .Colors );
};if _ffg > len (_dabb ){_fdf .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_ffg ,len (_dabb ));
return nil ,_fb .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_fdf .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_dabb ),_dabb );
_feecf :=_dd .NewBuffer (nil );for _baa :=0;_baa < _ffdc ;_baa ++{_bgg :=_dabb [_ffg *_baa :_ffg *(_baa +1)];for _agcb :=_bebe .Colors ;_agcb < _ffg ;_agcb ++{_bgg [_agcb ]+=_bgg [_agcb -_bebe .Colors ];};_feecf .Write (_bgg );};_eegdd :=_feecf .Bytes ();
_fdf .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_eegdd ),_eegdd );return _eegdd ,nil ;}else if _bebe .Predictor >=10&&_bebe .Predictor <=15{_fdf .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");
_fff :=_bebe .Columns *_bebe .Colors +1;_afab :=len (_dabb )/_fff ;if len (_dabb )%_fff !=0{return nil ,_af .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_dabb ),_fff );
};if _fff > len (_dabb ){_fdf .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_fff ,len (_dabb ));
return nil ,_fb .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_gcbg :=_dd .NewBuffer (nil );_fdf .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_bebe .Columns );
_fdf .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_dabb ),_fff ,_afab );_cfgf :=make ([]byte ,_fff );for _acab :=0;_acab < _fff ;_acab ++{_cfgf [_acab ]=0;};
_cbee :=_bebe .Colors ;for _gffg :=0;_gffg < _afab ;_gffg ++{_egb :=_dabb [_fff *_gffg :_fff *(_gffg +1)];_fda :=_egb [0];switch _fda {case _gacd :case _dfdb :for _aba :=1+_cbee ;_aba < _fff ;_aba ++{_egb [_aba ]+=_egb [_aba -_cbee ];};case _cfbd :for _aebf :=1;
_aebf < _fff ;_aebf ++{_egb [_aebf ]+=_cfgf [_aebf ];};case _bfab :for _deab :=1;_deab < _cbee +1;_deab ++{_egb [_deab ]+=_cfgf [_deab ]/2;};for _dfgb :=_cbee +1;_dfgb < _fff ;_dfgb ++{_egb [_dfgb ]+=byte ((int (_egb [_dfgb -_cbee ])+int (_cfgf [_dfgb ]))/2);
};case _egd :for _baca :=1;_baca < _fff ;_baca ++{var _aabf ,_dgec ,_ggea byte ;_dgec =_cfgf [_baca ];if _baca >=_cbee +1{_aabf =_egb [_baca -_cbee ];_ggea =_cfgf [_baca -_cbee ];};_egb [_baca ]+=_bgdd (_aabf ,_dgec ,_ggea );};default:_fdf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029\u0020\u0040\u0072o\u0077\u0020\u0025\u0064",_fda ,_gffg );
return nil ,_af .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_fda );};copy (_cfgf ,_egb );_gcbg .Write (_egb [1:]);};_agfg :=_gcbg .Bytes ();return _agfg ,nil ;
}else {_fdf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_bebe .Predictor );return nil ,_af .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_bebe .Predictor );
};};return _dabb ,nil ;};

// PdfObjectInteger represents the primitive PDF integer numerical object.
type PdfObjectInteger int64 ;

// ASCIIHexEncoder implements ASCII hex encoder/decoder.
type ASCIIHexEncoder struct{};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_feee *JPXEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};

// MultiEncoder supports serial encoding.
type MultiEncoder struct{_cbdf []StreamEncoder };

// GetFilterName returns the name of the encoding filter.
func (_fbccg *RunLengthEncoder )GetFilterName ()string {return StreamEncodingFilterNameRunLength };

// Read implementation of Read interface.
func (_dbgb *limitedReadSeeker )Read (p []byte )(_fgcbc int ,_abba error ){_fged ,_abba :=_dbgb ._acfb .Seek (0,_gg .SeekCurrent );if _abba !=nil {return 0,_abba ;};_affa :=_dbgb ._aggf -_fged ;if _affa ==0{return 0,_gg .EOF ;};if _edca :=int64 (len (p ));
_edca < _affa {_affa =_edca ;};_bgbde :=make ([]byte ,_affa );_fgcbc ,_abba =_dbgb ._acfb .Read (_bgbde );copy (p ,_bgbde );return _fgcbc ,_abba ;};

// WriteString outputs the object as it is to be written to file.
func (_deabd *PdfIndirectObject )WriteString ()string {var _geedg _eaa .Builder ;_geedg .WriteString (_a .FormatInt (_deabd .ObjectNumber ,10));_geedg .WriteString ("\u0020\u0030\u0020\u0052");return _geedg .String ();};

// NewLZWEncoder makes a new LZW encoder with default parameters.
func NewLZWEncoder ()*LZWEncoder {_gedg :=&LZWEncoder {};_gedg .Predictor =1;_gedg .BitsPerComponent =8;_gedg .Colors =1;_gedg .Columns =1;_gedg .EarlyChange =1;return _gedg ;};

// IsNullObject returns true if `obj` is a PdfObjectNull.
func IsNullObject (obj PdfObject )bool {_ ,_bacd :=TraceToDirectObject (obj ).(*PdfObjectNull );return _bacd ;};

// PdfCrypt provides PDF encryption/decryption support.
// The PDF standard supports encryption of strings and streams (Section 7.6).
type PdfCrypt struct{_cbc encryptDict ;_aebg _ge .StdEncryptDict ;_cdf string ;_adb []byte ;_bbd map[PdfObject ]bool ;_fcb map[PdfObject ]bool ;_abf bool ;_bafb cryptFilters ;_afb string ;_egg string ;_ada *PdfParser ;_bga map[int ]struct{};};

// Elements returns a slice of the PdfObject elements in the array.
func (_aggfd *PdfObjectArray )Elements ()[]PdfObject {if _aggfd ==nil {return nil ;};return _aggfd ._beeag ;};func (_edd *PdfParser )parseArray ()(*PdfObjectArray ,error ){_gfcd :=MakeArray ();_edd ._fbgde .ReadByte ();for {_edd .skipSpaces ();_adgb ,_afbcb :=_edd ._fbgde .Peek (1);
if _afbcb !=nil {return _gfcd ,_afbcb ;};if _adgb [0]==']'{_edd ._fbgde .ReadByte ();break ;};_ddcb ,_afbcb :=_edd .parseObject ();if _afbcb !=nil {return _gfcd ,_afbcb ;};_gfcd .Append (_ddcb );};return _gfcd ,nil ;};func (_bcgb *PdfCrypt )authenticate (_bed []byte )(bool ,error ){_bcgb ._abf =false ;
_eaba :=_bcgb .securityHandler ();_gdb ,_gac ,_ddeg :=_eaba .Authenticate (&_bcgb ._aebg ,_bed );if _ddeg !=nil {return false ,_ddeg ;}else if _gac ==0||len (_gdb )==0{return false ,nil ;};_bcgb ._abf =true ;_bcgb ._adb =_gdb ;return true ,nil ;};

// IsHexadecimal checks if the PdfObjectString contains Hexadecimal data.
func (_agfae *PdfObjectString )IsHexadecimal ()bool {return _agfae ._gccd };func _fffed (_gdga ,_bggfe PdfObject ,_dgaca int )bool {if _dgaca > _gbdc {_fdf .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_gbdc );
return false ;};if _gdga ==nil &&_bggfe ==nil {return true ;}else if _gdga ==nil ||_bggfe ==nil {return false ;};if _g .TypeOf (_gdga )!=_g .TypeOf (_bggfe ){return false ;};switch _dcgbg :=_gdga .(type ){case *PdfObjectNull ,*PdfObjectReference :return true ;
case *PdfObjectName :return *_dcgbg ==*(_bggfe .(*PdfObjectName ));case *PdfObjectString :return *_dcgbg ==*(_bggfe .(*PdfObjectString ));case *PdfObjectInteger :return *_dcgbg ==*(_bggfe .(*PdfObjectInteger ));case *PdfObjectBool :return *_dcgbg ==*(_bggfe .(*PdfObjectBool ));
case *PdfObjectFloat :return *_dcgbg ==*(_bggfe .(*PdfObjectFloat ));case *PdfIndirectObject :return _fffed (TraceToDirectObject (_gdga ),TraceToDirectObject (_bggfe ),_dgaca +1);case *PdfObjectArray :_bdag :=_bggfe .(*PdfObjectArray );if len ((*_dcgbg )._beeag )!=len ((*_bdag )._beeag ){return false ;
};for _aege ,_badde :=range (*_dcgbg )._beeag {if !_fffed (_badde ,(*_bdag )._beeag [_aege ],_dgaca +1){return false ;};};return true ;case *PdfObjectDictionary :_egfa :=_bggfe .(*PdfObjectDictionary );_ccgbe ,_efgcb :=(*_dcgbg )._cgbf ,(*_egfa )._cgbf ;
if len (_ccgbe )!=len (_efgcb ){return false ;};for _feece ,_abbf :=range _ccgbe {_dabag ,_dfcff :=_efgcb [_feece ];if !_dfcff ||!_fffed (_abbf ,_dabag ,_dgaca +1){return false ;};};return true ;case *PdfObjectStream :_dabbg :=_bggfe .(*PdfObjectStream );
return _fffed ((*_dcgbg ).PdfObjectDictionary ,(*_dabbg ).PdfObjectDictionary ,_dgaca +1);default:_fdf .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",_gdga );
};return false ;};func (_ffbdb *PdfParser )seekPdfVersionTopDown ()(int ,int ,error ){_ffbdb ._cgda .Seek (0,_gg .SeekStart );_ffbdb ._fbgde =_b .NewReader (_ffbdb ._cgda );_dffef :=20;_bgcgff :=make ([]byte ,_dffef );for {_fccb ,_cbgae :=_ffbdb ._fbgde .ReadByte ();
if _cbgae !=nil {if _cbgae ==_gg .EOF {break ;}else {return 0,0,_cbgae ;};};if IsDecimalDigit (_fccb )&&_bgcgff [_dffef -1]=='.'&&IsDecimalDigit (_bgcgff [_dffef -2])&&_bgcgff [_dffef -3]=='-'&&_bgcgff [_dffef -4]=='F'&&_bgcgff [_dffef -5]=='D'&&_bgcgff [_dffef -6]=='P'{_abfcg :=int (_bgcgff [_dffef -2]-'0');
_cgeee :=int (_fccb -'0');return _abfcg ,_cgeee ,nil ;};_bgcgff =append (_bgcgff [1:_dffef ],_fccb );};return 0,0,_fb .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};

// MakeArrayFromIntegers64 creates an PdfObjectArray from a slice of int64s, where each array element
// is an PdfObjectInteger.
func MakeArrayFromIntegers64 (vals []int64 )*PdfObjectArray {_dfag :=MakeArray ();for _ ,_edcbc :=range vals {_dfag .Append (MakeInteger (_edcbc ));};return _dfag ;};

// SetIfNotNil sets the dictionary's key -> val mapping entry -IF- val is not nil.
// Note that we take care to perform a type switch.  Otherwise if we would supply a nil value
// of another type, e.g. (PdfObjectArray*)(nil), then it would not be a PdfObject(nil) and thus
// would get set.
func (_bfbd *PdfObjectDictionary )SetIfNotNil (key PdfObjectName ,val PdfObject ){if val !=nil {switch _cgec :=val .(type ){case *PdfObjectName :if _cgec !=nil {_bfbd .Set (key ,val );};case *PdfObjectDictionary :if _cgec !=nil {_bfbd .Set (key ,val );
};case *PdfObjectStream :if _cgec !=nil {_bfbd .Set (key ,val );};case *PdfObjectString :if _cgec !=nil {_bfbd .Set (key ,val );};case *PdfObjectNull :if _cgec !=nil {_bfbd .Set (key ,val );};case *PdfObjectInteger :if _cgec !=nil {_bfbd .Set (key ,val );
};case *PdfObjectArray :if _cgec !=nil {_bfbd .Set (key ,val );};case *PdfObjectBool :if _cgec !=nil {_bfbd .Set (key ,val );};case *PdfObjectFloat :if _cgec !=nil {_bfbd .Set (key ,val );};case *PdfObjectReference :if _cgec !=nil {_bfbd .Set (key ,val );
};case *PdfIndirectObject :if _cgec !=nil {_bfbd .Set (key ,val );};default:_fdf .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",val );
};};};

// ToInt64Slice returns a slice of all array elements as an int64 slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_eabg *PdfObjectArray )ToInt64Slice ()([]int64 ,error ){var _bcbg []int64 ;for _ ,_eegg :=range _eabg .Elements (){if _egdaf ,_gdcbe :=_eegg .(*PdfObjectInteger );_gdcbe {_bcbg =append (_bcbg ,int64 (*_egdaf ));}else {return nil ,ErrTypeError ;};
};return _bcbg ,nil ;};func (_cfgbg *PdfParser )loadXrefs ()(*PdfObjectDictionary ,error ){_cfgbg ._bfaa .ObjectMap =make (map[int ]XrefObject );_cfgbg ._fgfg =make (objectStreams );_bggg ,_bdaf :=_cfgbg ._cgda .Seek (0,_gg .SeekEnd );if _bdaf !=nil {return nil ,_bdaf ;
};_fdf .Log .Trace ("\u0066s\u0069\u007a\u0065\u003a\u0020\u0025d",_bggg );_cfgbg ._gdgf =_bggg ;_bdaf =_cfgbg .seekToEOFMarker (_bggg );if _bdaf !=nil {_fdf .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0073\u0065\u0065\u006b\u0020\u0074\u006f\u0020\u0065\u006f\u0066\u0020\u006d\u0061\u0072\u006b\u0065\u0072: \u0025\u0076",_bdaf );
return nil ,_bdaf ;};_aed ,_bdaf :=_cfgbg ._cgda .Seek (0,_gg .SeekCurrent );if _bdaf !=nil {return nil ,_bdaf ;};var _cggb int64 =64;_ddee :=_aed -_cggb ;if _ddee < 0{_ddee =0;};_ ,_bdaf =_cfgbg ._cgda .Seek (_ddee ,_gg .SeekStart );if _bdaf !=nil {return nil ,_bdaf ;
};_cfdg :=make ([]byte ,_cggb );_ ,_bdaf =_cfgbg ._cgda .Read (_cfdg );if _bdaf !=nil {_fdf .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u003a\u0020\u0025\u0076",_bdaf );
return nil ,_bdaf ;};_ggaf :=_ceeb .FindStringSubmatch (string (_cfdg ));if len (_ggaf )< 2{_fdf .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020n\u006f\u0074\u0020f\u006fu\u006e\u0064\u0021");return nil ,_fb .New ("\u0073\u0074\u0061\u0072tx\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");
};if len (_ggaf )> 2{_fdf .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u004du\u006c\u0074\u0069\u0070\u006c\u0065\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029\u0021",_cfdg );return nil ,_fb .New ("m\u0075\u006c\u0074\u0069\u0070\u006ce\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065f\u0020\u0065\u006et\u0072i\u0065\u0073\u003f");
};_gbef ,_ :=_a .ParseInt (_ggaf [1],10,64);_fdf .Log .Trace ("\u0073t\u0061r\u0074\u0078\u0072\u0065\u0066\u0020\u0061\u0074\u0020\u0025\u0064",_gbef );if _gbef > _bggg {_fdf .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u006f\u0066f\u0073e\u0074 \u006fu\u0074\u0073\u0069\u0064\u0065\u0020\u006f\u0066\u0020\u0066\u0069\u006c\u0065");
_fdf .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0072e\u0070\u0061\u0069\u0072");_gbef ,_bdaf =_cfgbg .repairLocateXref ();if _bdaf !=nil {_fdf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0052\u0065\u0070\u0061\u0069\u0072\u0020\u0061\u0074\u0074\u0065\u006d\u0070t\u0020\u0066\u0061\u0069\u006c\u0065\u0064 \u0028\u0025\u0073\u0029");
return nil ,_bdaf ;};};_cfgbg ._cgda .Seek (_gbef ,_gg .SeekStart );_cfgbg ._fbgde =_b .NewReader (_cfgbg ._cgda );_eacc ,_bdaf :=_cfgbg .parseXref ();if _bdaf !=nil {return nil ,_bdaf ;};_deba :=_eacc .Get ("\u0058R\u0065\u0066\u0053\u0074\u006d");if _deba !=nil {_acad ,_cbeba :=_deba .(*PdfObjectInteger );
if !_cbeba {return nil ,_fb .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0021=\u0020\u0069\u006e\u0074");};_ ,_bdaf =_cfgbg .parseXrefStream (_acad );if _bdaf !=nil {return nil ,_bdaf ;};};var _fdfd []int64 ;_cgfa :=func (_bdfa int64 ,_dfce []int64 )bool {for _ ,_edga :=range _dfce {if _edga ==_bdfa {return true ;
};};return false ;};_deba =_eacc .Get ("\u0050\u0072\u0065\u0076");for _deba !=nil {_bdfbb ,_gdcb :=_deba .(*PdfObjectInteger );if !_gdcb {_fdf .Log .Debug ("\u0049\u006ev\u0061\u006c\u0069\u0064\u0020P\u0072\u0065\u0076\u0020\u0072e\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u003a\u0020\u004e\u006f\u0074\u0020\u0061\u0020\u002a\u0050\u0064\u0066\u004f\u0062\u006a\u0065\u0063\u0074\u0049\u006e\u0074\u0065\u0067\u0065\u0072\u0020\u0028\u0025\u0054\u0029",_deba );
return _eacc ,nil ;};_cffc :=*_bdfbb ;_fdf .Log .Trace ("\u0041\u006eot\u0068\u0065\u0072 \u0050\u0072\u0065\u0076 xr\u0065f \u0074\u0061\u0062\u006c\u0065\u0020\u006fbj\u0065\u0063\u0074\u0020\u0061\u0074\u0020%\u0064",_cffc );_cfgbg ._cgda .Seek (int64 (_cffc ),_gg .SeekStart );
_cfgbg ._fbgde =_b .NewReader (_cfgbg ._cgda );_agfc ,_fgcce :=_cfgbg .parseXref ();if _fgcce !=nil {_fdf .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0045\u0072\u0072\u006f\u0072\u0020-\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u0061\u0064\u0069n\u0067\u0020\u0061\u006e\u006f\u0074\u0068\u0065\u0072\u0020\u0028\u0050re\u0076\u0029\u0020\u0074\u0072\u0061\u0069\u006c\u0065\u0072");
_fdf .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0063\u006f\u006e\u0074\u0069n\u0075\u0065\u0020\u0062\u0079\u0020\u0069\u0067\u006e\u006f\u0072\u0069n\u0067\u0020\u0069\u0074");break ;};_cfgbg ._egfg =append (_cfgbg ._egfg ,int64 (_cffc ));
_deba =_agfc .Get ("\u0050\u0072\u0065\u0076");if _deba !=nil {_ccdad :=*(_deba .(*PdfObjectInteger ));if _cgfa (int64 (_ccdad ),_fdfd ){_fdf .Log .Debug ("\u0050\u0072ev\u0065\u006e\u0074i\u006e\u0067\u0020\u0063irc\u0075la\u0072\u0020\u0078\u0072\u0065\u0066\u0020re\u0066\u0065\u0072\u0065\u006e\u0063\u0069n\u0067");
break ;};_fdfd =append (_fdfd ,int64 (_ccdad ));};};return _eacc ,nil ;};const _gbdc =10;type encryptDict struct{Filter string ;V int ;SubFilter string ;Length int ;StmF string ;StrF string ;EFF string ;CF map[string ]_gd .FilterDict ;};

// PdfIndirectObject represents the primitive PDF indirect object.
type PdfIndirectObject struct{PdfObjectReference ;PdfObject ;};

// IsDelimiter checks if a character represents a delimiter.
func IsDelimiter (c byte )bool {return c =='('||c ==')'||c =='<'||c =='>'||c =='['||c ==']'||c =='{'||c =='}'||c =='/'||c =='%';};

// NewRunLengthEncoder makes a new run length encoder
func NewRunLengthEncoder ()*RunLengthEncoder {return &RunLengthEncoder {}};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_cdbc *DCTEncoder )MakeDecodeParams ()PdfObject {return nil };

// EqualObjects returns true if `obj1` and `obj2` have the same contents.
//
// NOTE: It is a good idea to flatten obj1 and obj2 with FlattenObject before calling this function
// so that contents, rather than references, can be compared.
func EqualObjects (obj1 ,obj2 PdfObject )bool {return _fffed (obj1 ,obj2 ,0)};

// ToIntegerArray returns a slice of all array elements as an int slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_fggc *PdfObjectArray )ToIntegerArray ()([]int ,error ){var _ffbcf []int ;for _ ,_fdeeb :=range _fggc .Elements (){if _eead ,_defd :=_fdeeb .(*PdfObjectInteger );_defd {_ffbcf =append (_ffbcf ,int (*_eead ));}else {return nil ,ErrTypeError ;};};return _ffbcf ,nil ;
};

// DecodeGlobals decodes 'encoded' byte stream and returns their Globally defined segments ('Globals').
func (_bgcgf *JBIG2Encoder )DecodeGlobals (encoded []byte )(_cea .Globals ,error ){return _cea .DecodeGlobals (encoded );};

// DecodeStream decodes a LZW encoded stream and returns the result as a
// slice of bytes.
func (_dgb *LZWEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_fdf .Log .Trace ("\u004c\u005a\u0057 \u0044\u0065\u0063\u006f\u0064\u0069\u006e\u0067");_fdf .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_dgb .Predictor );
_faed ,_dafa :=_dgb .DecodeBytes (streamObj .Stream );if _dafa !=nil {return nil ,_dafa ;};_fdf .Log .Trace ("\u0020\u0049\u004e\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (streamObj .Stream ),streamObj .Stream );_fdf .Log .Trace ("\u004f\u0055\u0054\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (_faed ),_faed );
if _dgb .Predictor > 1{if _dgb .Predictor ==2{_fdf .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_eeee :=_dgb .Columns *_dgb .Colors ;if _eeee < 1{return []byte {},nil ;};_cegd :=len (_faed )/_eeee ;if len (_faed )%_eeee !=0{_fdf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");
return nil ,_af .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_faed ),_eeee );};if _eeee %_dgb .Colors !=0{return nil ,_af .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_eeee ,_dgb .Colors );
};if _eeee > len (_faed ){_fdf .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_eeee ,len (_faed ));
return nil ,_fb .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_fdf .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_faed ),_faed );
_degg :=_dd .NewBuffer (nil );for _efg :=0;_efg < _cegd ;_efg ++{_beag :=_faed [_eeee *_efg :_eeee *(_efg +1)];for _eag :=_dgb .Colors ;_eag < _eeee ;_eag ++{_beag [_eag ]=byte (int (_beag [_eag ]+_beag [_eag -_dgb .Colors ])%256);};_degg .Write (_beag );
};_gffgd :=_degg .Bytes ();_fdf .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_gffgd ),_gffgd );return _gffgd ,nil ;}else if _dgb .Predictor >=10&&_dgb .Predictor <=15{_fdf .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");
_dbdc :=_dgb .Columns *_dgb .Colors +1;if _dbdc < 1{return []byte {},nil ;};_ebgg :=len (_faed )/_dbdc ;if len (_faed )%_dbdc !=0{return nil ,_af .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_faed ),_dbdc );
};if _dbdc > len (_faed ){_fdf .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_dbdc ,len (_faed ));
return nil ,_fb .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_ddae :=_dd .NewBuffer (nil );_fdf .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_dgb .Columns );
_fdf .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_faed ),_dbdc ,_ebgg );_ede :=make ([]byte ,_dbdc );for _fecg :=0;_fecg < _dbdc ;_fecg ++{_ede [_fecg ]=0;
};for _bgb :=0;_bgb < _ebgg ;_bgb ++{_aeeg :=_faed [_dbdc *_bgb :_dbdc *(_bgb +1)];_ccd :=_aeeg [0];switch _ccd {case 0:case 1:for _adgac :=2;_adgac < _dbdc ;_adgac ++{_aeeg [_adgac ]=byte (int (_aeeg [_adgac ]+_aeeg [_adgac -1])%256);};case 2:for _afba :=1;
_afba < _dbdc ;_afba ++{_aeeg [_afba ]=byte (int (_aeeg [_afba ]+_ede [_afba ])%256);};default:_fdf .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0066i\u006c\u0074\u0065\u0072\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_ccd );
return nil ,_af .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_ccd );};for _bebb :=0;_bebb < _dbdc ;_bebb ++{_ede [_bebb ]=_aeeg [_bebb ];};_ddae .Write (_aeeg [1:]);
};_dbda :=_ddae .Bytes ();return _dbda ,nil ;}else {_fdf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_dgb .Predictor );
return nil ,_af .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_dgb .Predictor );};};return _faed ,nil ;};var _gfdab =_c .MustCompile ("\u005e\\\u0073\u002a\u005b\u002d]\u002a\u0028\u005c\u0064\u002b)\u005cs\u002b(\u005c\u0064\u002b\u0029\u005c\u0073\u002bR");


// GetFilterName returns the name of the encoding filter.
func (_fgcc *JPXEncoder )GetFilterName ()string {return StreamEncodingFilterNameJPX };

// GetXrefOffset returns the offset of the xref table.
func (_bgfe *PdfParser )GetXrefOffset ()int64 {return _bgfe ._dfc };

// PdfObjectStreams represents the primitive PDF object streams.
// 7.5.7 Object Streams (page 45).
type PdfObjectStreams struct{PdfObjectReference ;_aagf []PdfObject ;};var _fffa =_c .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064\u002b)\u005c\u0073\u002a\u0024");

// GetFilterName returns the names of the underlying encoding filters,
// separated by spaces.
// Note: This is just a string, should not be used in /Filter dictionary entry. Use GetFilterArray for that.
// TODO(v4): Refactor to GetFilter() which can be used for /Filter (either Name or Array), this can be
//  renamed to String() as a pretty string to use in debugging etc.
func (_gfdg *MultiEncoder )GetFilterName ()string {_defb :="";for _bgcb ,_dacae :=range _gfdg ._cbdf {_defb +=_dacae .GetFilterName ();if _bgcb < len (_gfdg ._cbdf )-1{_defb +="\u0020";};};return _defb ;};

// FlattenObject returns the contents of `obj`. In other words, `obj` with indirect objects replaced
// by their values.
// The replacements are made recursively to a depth of traceMaxDepth.
// NOTE: Dicts are sorted to make objects with same contents have the same PDF object strings.
func FlattenObject (obj PdfObject )PdfObject {return _dgged (obj ,0)};

// Resolve resolves a PdfObject to direct object, looking up and resolving references as needed (unlike TraceToDirect).
func (_aeb *PdfParser )Resolve (obj PdfObject )(PdfObject ,error ){_bcg ,_gfa :=obj .(*PdfObjectReference );if !_gfa {return obj ,nil ;};_fc :=_aeb .GetFileOffset ();defer func (){_aeb .SetFileOffset (_fc )}();_ad ,_bee :=_aeb .LookupByReference (*_bcg );
if _bee !=nil {return nil ,_bee ;};_dba ,_ccc :=_ad .(*PdfIndirectObject );if !_ccc {return _ad ,nil ;};_ad =_dba .PdfObject ;_ ,_gfa =_ad .(*PdfObjectReference );if _gfa {return _dba ,_fb .New ("\u006d\u0075lt\u0069\u0020\u0064e\u0070\u0074\u0068\u0020tra\u0063e \u0070\u006f\u0069\u006e\u0074\u0065\u0072 t\u006f\u0020\u0070\u006f\u0069\u006e\u0074e\u0072");
};return _ad ,nil ;};

// GetRevisionNumber returns the current version of the Pdf document.
func (_fcdd *PdfParser )GetRevisionNumber ()int {return _fcdd ._dcgd };

// DecodeBytes decodes a slice of JPX encoded bytes and returns the result.
func (_fbea *JPXEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_fdf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_fbea .GetFilterName ());
return encoded ,ErrNoJPXDecode ;};

// LookupByReference looks up a PdfObject by a reference.
func (_dcf *PdfParser )LookupByReference (ref PdfObjectReference )(PdfObject ,error ){_fdf .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0075\u0070\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0025\u0073",ref .String ());return _dcf .LookupByNumber (int (ref .ObjectNumber ));
};func (_bdgb *PdfParser )parseBool ()(PdfObjectBool ,error ){_efea ,_dada :=_bdgb ._fbgde .Peek (4);if _dada !=nil {return PdfObjectBool (false ),_dada ;};if (len (_efea )>=4)&&(string (_efea [:4])=="\u0074\u0072\u0075\u0065"){_bdgb ._fbgde .Discard (4);
return PdfObjectBool (true ),nil ;};_efea ,_dada =_bdgb ._fbgde .Peek (5);if _dada !=nil {return PdfObjectBool (false ),_dada ;};if (len (_efea )>=5)&&(string (_efea [:5])=="\u0066\u0061\u006cs\u0065"){_bdgb ._fbgde .Discard (5);return PdfObjectBool (false ),nil ;
};return PdfObjectBool (false ),_fb .New ("\u0075n\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0062o\u006fl\u0065a\u006e\u0020\u0073\u0074\u0072\u0069\u006eg");};

// DecodeBytes decodes the CCITTFax encoded image data.
func (_edeg *CCITTFaxEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_dabe ,_cgfg :=_ac .NewDecoder (encoded ,_ac .DecodeOptions {Columns :_edeg .Columns ,Rows :_edeg .Rows ,K :_edeg .K ,EncodedByteAligned :_edeg .EncodedByteAlign ,BlackIsOne :_edeg .BlackIs1 ,EndOfBlock :_edeg .EndOfBlock ,EndOfLine :_edeg .EndOfLine ,DamagedRowsBeforeError :_edeg .DamagedRowsBeforeError });
if _cgfg !=nil {return nil ,_cgfg ;};_bffd ,_cgfg :=_gf .ReadAll (_dabe );if _cgfg !=nil {return nil ,_cgfg ;};return _bffd ,nil ;};

// GetNumbersAsFloat converts a list of pdf objects representing floats or integers to a slice of
// float64 values.
func GetNumbersAsFloat (objects []PdfObject )(_bdfbe []float64 ,_dggfd error ){for _ ,_dccg :=range objects {_dfegg ,_gaba :=GetNumberAsFloat (_dccg );if _gaba !=nil {return nil ,_gaba ;};_bdfbe =append (_bdfbe ,_dfegg );};return _bdfbe ,nil ;};func (_cdce *PdfObjectInteger )String ()string {return _af .Sprintf ("\u0025\u0064",*_cdce )};


// Len returns the number of elements in the streams.
func (_gffa *PdfObjectStreams )Len ()int {if _gffa ==nil {return 0;};return len (_gffa ._aagf );};

// RawEncoder implements Raw encoder/decoder (no encoding, pass through)
type RawEncoder struct{};func (_dg *PdfParser )lookupByNumber (_aee int ,_afe bool )(PdfObject ,bool ,error ){_ceb ,_efb :=_dg .ObjCache [_aee ];if _efb {_fdf .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0063a\u0063\u0068\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0025\u0064",_aee );
return _ceb ,false ,nil ;};if _dg ._eedae ==nil {_dg ._eedae =map[int ]bool {};};if _dg ._eedae [_aee ]{_fdf .Log .Debug ("ER\u0052\u004f\u0052\u003a\u0020\u004c\u006fok\u0075\u0070\u0020\u006f\u0066\u0020\u0025\u0064\u0020\u0069\u0073\u0020\u0061\u006c\u0072e\u0061\u0064\u0079\u0020\u0069\u006e\u0020\u0070\u0072\u006f\u0067\u0072\u0065\u0073\u0073\u0020\u002d\u0020\u0072\u0065c\u0075\u0072\u0073\u0069\u0076\u0065 \u006c\u006f\u006f\u006b\u0075\u0070\u0020\u0061\u0074t\u0065m\u0070\u0074\u0020\u0062\u006c\u006f\u0063\u006b\u0065\u0064",_aee );
return nil ,false ,_fb .New ("\u0072\u0065\u0063\u0075\u0072\u0073\u0069\u0076\u0065\u0020\u006c\u006f\u006f\u006b\u0075p\u0020a\u0074\u0074\u0065\u006d\u0070\u0074\u0020\u0062\u006c\u006f\u0063\u006b\u0065\u0064");};_dg ._eedae [_aee ]=true ;defer delete (_dg ._eedae ,_aee );
_bac ,_efb :=_dg ._bfaa .ObjectMap [_aee ];if !_efb {_fdf .Log .Trace ("\u0055\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u006c\u006f\u0063\u0061t\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0069\u006e\u0020\u0078\u0072\u0065\u0066\u0073\u0021 \u002d\u0020\u0052\u0065\u0074u\u0072\u006e\u0069\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074");
var _cde PdfObjectNull ;return &_cde ,false ,nil ;};_fdf .Log .Trace ("L\u006fo\u006b\u0075\u0070\u0020\u006f\u0062\u006a\u0020n\u0075\u006d\u0062\u0065r \u0025\u0064",_aee );if _bac .XType ==XrefTypeTableEntry {_fdf .Log .Trace ("\u0078r\u0065f\u006f\u0062\u006a\u0020\u006fb\u006a\u0020n\u0075\u006d\u0020\u0025\u0064",_bac .ObjectNumber );
_fdf .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u0067e\u006e\u0020\u0025\u0064",_bac .Generation );_fdf .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0064",_bac .Offset );
_dg ._cgda .Seek (_bac .Offset ,_gg .SeekStart );_dg ._fbgde =_b .NewReader (_dg ._cgda );_geg ,_dec :=_dg .ParseIndirectObject ();if _dec !=nil {_fdf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006ce\u0064\u0020\u0072\u0065\u0061\u0064\u0069n\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029",_dec );
if _afe {_fdf .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0072\u0065\u0070\u0061\u0069r\u0020\u0078\u0072\u0065\u0066\u0073\u0020\u0028\u0074\u006f\u0070\u0020d\u006f\u0077\u006e\u0029");_bgd ,_gcg :=_dg .repairRebuildXrefsTopDown ();
if _gcg !=nil {_fdf .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020r\u0065\u0070\u0061\u0069\u0072\u0020\u0028\u0025\u0073\u0029",_gcg );return nil ,false ,_gcg ;};_dg ._bfaa =*_bgd ;return _dg .lookupByNumber (_aee ,false );
};return nil ,false ,_dec ;};if _afe {_aca ,_ ,_ :=_gbbd (_geg );if int (_aca )!=_aee {_fdf .Log .Debug ("\u0049n\u0076\u0061\u006c\u0069d\u0020\u0078\u0072\u0065\u0066s\u003a \u0052e\u0062\u0075\u0069\u006c\u0064\u0069\u006eg");_aaa :=_dg .rebuildXrefTable ();
if _aaa !=nil {return nil ,false ,_aaa ;};_dg .ObjCache =objectCache {};return _dg .lookupByNumberWrapper (_aee ,false );};};_fdf .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006f\u0062\u006a");_dg .ObjCache [_aee ]=_geg ;
return _geg ,false ,nil ;}else if _bac .XType ==XrefTypeObjectStream {_fdf .Log .Trace ("\u0078r\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0021");_fdf .Log .Trace ("\u003e\u004c\u006f\u0061\u0064\u0020\u0076\u0069\u0061\u0020\u004f\u0053\u0021");
_fdf .Log .Trace ("\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d \u0061\u0076\u0061\u0069\u006c\u0061b\u006c\u0065\u0020\u0069\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020%\u0064\u002f\u0025\u0064",_bac .OsObjNumber ,_bac .OsObjIndex );
if _bac .OsObjNumber ==_aee {_fdf .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0043i\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065f\u0065\u0072\u0065n\u0063e\u0021\u003f\u0021");return nil ,true ,_fb .New ("\u0078\u0072\u0065f \u0063\u0069\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");
};if _ ,_daf :=_dg ._bfaa .ObjectMap [_bac .OsObjNumber ];_daf {_dfd ,_efa :=_dg .lookupObjectViaOS (_bac .OsObjNumber ,_aee );if _efa !=nil {_fdf .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0052\u0065\u0074\u0075\u0072\u006e\u0069n\u0067\u0020\u0045\u0052\u0052\u0020\u0028\u0025\u0073\u0029",_efa );
return nil ,true ,_efa ;};_fdf .Log .Trace ("\u003c\u004c\u006f\u0061\u0064\u0065\u0064\u0020\u0076i\u0061\u0020\u004f\u0053");_dg .ObjCache [_aee ]=_dfd ;if _dg ._adfa !=nil {_dg ._adfa ._bbd [_dfd ]=true ;};return _dfd ,true ,nil ;};_fdf .Log .Debug ("\u003f\u003f\u0020\u0042\u0065\u006c\u006f\u006eg\u0073\u0020\u0074o \u0061\u0020\u006e\u006f\u006e\u002dc\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u002e.\u002e\u0021");
return nil ,true ,_fb .New ("\u006f\u0073\u0020\u0062\u0065\u006c\u006fn\u0067\u0073\u0020t\u006f\u0020\u0061\u0020n\u006f\u006e\u0020\u0063\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074");
};return nil ,false ,_fb .New ("\u0075\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0078\u0072\u0065\u0066 \u0074\u0079\u0070\u0065");};