//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package core defines and implements the primitive PDF object types in golang, and provides functionality
// for parsing those from a PDF file stream. This includes I/O handling, cross references, repairs, encryption,
// encoding and other core capabilities.
package core ;import (_eg "bufio";_gcd "bytes";_bed "compress/lzw";_d "compress/zlib";_gd "crypto/md5";_ga "crypto/rand";_fc "encoding/hex";_c "errors";_gc "fmt";_fg "github.com/unidoc/unipdf/v3/common";_dfg "github.com/unidoc/unipdf/v3/core/security";_cd "github.com/unidoc/unipdf/v3/core/security/crypt";_afd "github.com/unidoc/unipdf/v3/internal/ccittfax";_ee "github.com/unidoc/unipdf/v3/internal/imageutil";_bf "github.com/unidoc/unipdf/v3/internal/jbig2";_gf "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_cf "github.com/unidoc/unipdf/v3/internal/jbig2/decoder";_ca "github.com/unidoc/unipdf/v3/internal/jbig2/document";_ad "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_df "github.com/unidoc/unipdf/v3/internal/strutils";_def "golang.org/x/image/tiff/lzw";_gad "golang.org/x/xerrors";_cg "image";_be "image/color";_af "image/jpeg";_de "io";_g "reflect";_a "regexp";_b "sort";_e "strconv";_afa "strings";_ge "time";);var _faag =_a .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064\u002b)\u005c\u0073\u002a\u0024");

// Clear resets the array to an empty state.
func (_daef *PdfObjectArray )Clear (){_daef ._bcea =[]PdfObject {}};func (_fgfd *PdfCrypt )saveCryptFilters (_gdb *PdfObjectDictionary )error {if _fgfd ._age .V < 4{return _c .New ("\u0063\u0061\u006e\u0020\u006f\u006e\u006c\u0079\u0020\u0062\u0065 \u0075\u0073\u0065\u0064\u0020\u0077\u0069\u0074\u0068\u0020V\u003e\u003d\u0034");};_ebd :=MakeDict ();_gdb .Set ("\u0043\u0046",_ebd );for _gaa ,_cea :=range _fgfd ._dfb {if _gaa =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{continue ;};_eac :=_gdf (_cea ,"");_ebd .Set (PdfObjectName (_gaa ),_eac );};_gdb .Set ("\u0053\u0074\u0072\u0046",MakeName (_fgfd ._fcb ));_gdb .Set ("\u0053\u0074\u006d\u0046",MakeName (_fgfd ._gca ));return nil ;};

// GetObjectNums returns a sorted list of object numbers of the PDF objects in the file.
func (_badeg *PdfParser )GetObjectNums ()[]int {var _ceab []int ;for _ ,_caaa :=range _badeg ._cgbgg .ObjectMap {_ceab =append (_ceab ,_caaa .ObjectNumber );};_b .Ints (_ceab );return _ceab ;};

// Encode encodes previously prepare jbig2 document and stores it as the byte slice.
func (_ggac *JBIG2Encoder )Encode ()(_adbf []byte ,_edeb error ){const _ecbe ="J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0045\u006eco\u0064\u0065";if _ggac ._gbae ==nil {return nil ,_ad .Errorf (_ecbe ,"\u0064\u006f\u0063u\u006d\u0065\u006e\u0074 \u0069\u006e\u0070\u0075\u0074\u0020\u0064a\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006e\u0065\u0064");};_ggac ._gbae .FullHeaders =_ggac .DefaultPageSettings .FileMode ;_adbf ,_edeb =_ggac ._gbae .Encode ();if _edeb !=nil {return nil ,_ad .Wrap (_edeb ,_ecbe ,"");};return _adbf ,nil ;};

// String returns a descriptive information string about the encryption method used.
func (_baca *PdfCrypt )String ()string {if _baca ==nil {return "";};_adc :=_baca ._age .Filter +"\u0020\u002d\u0020";if _baca ._age .V ==0{_adc +="\u0055\u006e\u0064\u006fcu\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0061\u006c\u0067\u006f\u0072\u0069\u0074h\u006d";}else if _baca ._age .V ==1{_adc +="\u0052\u0043\u0034:\u0020\u0034\u0030\u0020\u0062\u0069\u0074\u0073";}else if _baca ._age .V ==2{_adc +=_gc .Sprintf ("\u0052\u0043\u0034:\u0020\u0025\u0064\u0020\u0062\u0069\u0074\u0073",_baca ._age .Length );}else if _baca ._age .V ==3{_adc +="U\u006e\u0070\u0075\u0062li\u0073h\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d";}else if _baca ._age .V >=4{_adc +=_gc .Sprintf ("\u0053\u0074r\u0065\u0061\u006d\u0020f\u0069\u006ct\u0065\u0072\u003a\u0020\u0025\u0073\u0020\u002d \u0053\u0074\u0072\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0074\u0065r\u003a\u0020\u0025\u0073",_baca ._gca ,_baca ._fcb );_adc +="\u003b\u0020C\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0073\u003a";for _cag ,_gef :=range _baca ._dfb {_adc +=_gc .Sprintf ("\u0020\u002d\u0020\u0025\u0073\u003a\u0020\u0025\u0073 \u0028\u0025\u0064\u0029",_cag ,_gef .Name (),_gef .KeyLength ());};};_cga :=_baca .GetAccessPermissions ();_adc +=_gc .Sprintf ("\u0020\u002d\u0020\u0025\u0023\u0076",_cga );return _adc ;};const _bfb ="\u0053\u0074\u0064C\u0046";

// DecodeGlobals decodes 'encoded' byte stream and returns their Globally defined segments ('Globals').
func (_dagaa *JBIG2Encoder )DecodeGlobals (encoded []byte )(_bf .Globals ,error ){return _bf .DecodeGlobals (encoded );};

// GetArray returns the *PdfObjectArray represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetArray (obj PdfObject )(_bcge *PdfObjectArray ,_fdfcc bool ){_bcge ,_fdfcc =TraceToDirectObject (obj ).(*PdfObjectArray );return _bcge ,_fdfcc ;};

// WriteString outputs the object as it is to be written to file.
func (_dadg *PdfObjectString )WriteString ()string {var _efabc _gcd .Buffer ;if _dadg ._eade {_gbbgb :=_fc .EncodeToString (_dadg .Bytes ());_efabc .WriteString ("\u003c");_efabc .WriteString (_gbbgb );_efabc .WriteString ("\u003e");return _efabc .String ();};_bfaca :=map[byte ]string {'\n':"\u005c\u006e",'\r':"\u005c\u0072",'\t':"\u005c\u0074",'\b':"\u005c\u0062",'\f':"\u005c\u0066",'(':"\u005c\u0028",')':"\u005c\u0029",'\\':"\u005c\u005c"};_efabc .WriteString ("\u0028");for _ffdaa :=0;_ffdaa < len (_dadg ._abgc );_ffdaa ++{_ecfad :=_dadg ._abgc [_ffdaa ];if _eegb ,_cfdf :=_bfaca [_ecfad ];_cfdf {_efabc .WriteString (_eegb );}else {_efabc .WriteByte (_ecfad );};};_efabc .WriteString ("\u0029");return _efabc .String ();};

// PdfCryptNewEncrypt makes the document crypt handler based on a specified crypt filter.
func PdfCryptNewEncrypt (cf _cd .Filter ,userPass ,ownerPass []byte ,perm _dfg .Permissions )(*PdfCrypt ,*EncryptInfo ,error ){_cbfg :=&PdfCrypt {_aaa :make (map[PdfObject ]bool ),_dfb :make (cryptFilters ),_cgc :_dfg .StdEncryptDict {P :perm ,EncryptMetadata :true }};var _cdb Version ;if cf !=nil {_cbd :=cf .PDFVersion ();_cdb .Major ,_cdb .Minor =_cbd [0],_cbd [1];V ,R :=cf .HandlerVersion ();_cbfg ._age .V =V ;_cbfg ._cgc .R =R ;_cbfg ._age .Length =cf .KeyLength ()*8;};const (_ab =_bfb ;);_cbfg ._dfb [_ab ]=cf ;if _cbfg ._age .V >=4{_cbfg ._gca =_ab ;_cbfg ._fcb =_ab ;};_geb :=_cbfg .newEncryptDict ();_fce :=_gd .Sum ([]byte (_ge .Now ().Format (_ge .RFC850 )));_gac :=string (_fce [:]);_eebd :=make ([]byte ,100);_ga .Read (_eebd );_fce =_gd .Sum (_eebd );_ffc :=string (_fce [:]);_fg .Log .Trace ("\u0052\u0061\u006e\u0064\u006f\u006d\u0020\u0062\u003a\u0020\u0025\u0020\u0078",_eebd );_fg .Log .Trace ("\u0047\u0065\u006e\u0020\u0049\u0064\u0020\u0030\u003a\u0020\u0025\u0020\u0078",_gac );_cbfg ._dg =_gac ;_aa :=_cbfg .generateParams (userPass ,ownerPass );if _aa !=nil {return nil ,nil ,_aa ;};_eda (&_cbfg ._cgc ,_geb );if _cbfg ._age .V >=4{if _eag :=_cbfg .saveCryptFilters (_geb );_eag !=nil {return nil ,nil ,_eag ;};};return _cbfg ,&EncryptInfo {Version :_cdb ,Encrypt :_geb ,ID0 :_gac ,ID1 :_ffc },nil ;};func _eebgb (_agaba *PdfObjectDictionary )(_adbdff *_ee .ImageBase ){var (_ccaf *PdfObjectInteger ;_begbe bool ;);if _ccaf ,_begbe =_agaba .Get ("\u0057\u0069\u0064t\u0068").(*PdfObjectInteger );_begbe {_adbdff =&_ee .ImageBase {Width :int (*_ccaf )};}else {return nil ;};if _ccaf ,_begbe =_agaba .Get ("\u0048\u0065\u0069\u0067\u0068\u0074").(*PdfObjectInteger );_begbe {_adbdff .Height =int (*_ccaf );};if _ccaf ,_begbe =_agaba .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074").(*PdfObjectInteger );_begbe {_adbdff .BitsPerComponent =int (*_ccaf );};if _ccaf ,_begbe =_agaba .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073").(*PdfObjectInteger );_begbe {_adbdff .ColorComponents =int (*_ccaf );};return _adbdff ;};

// Bytes returns the PdfObjectString content as a []byte array.
func (_ceaac *PdfObjectString )Bytes ()[]byte {return []byte (_ceaac ._abgc )};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_dbcc *JPXEncoder )MakeDecodeParams ()PdfObject {return nil };

// ToInt64Slice returns a slice of all array elements as an int64 slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_adccb *PdfObjectArray )ToInt64Slice ()([]int64 ,error ){var _bcgd []int64 ;for _ ,_cccb :=range _adccb .Elements (){if _cfee ,_fbae :=_cccb .(*PdfObjectInteger );_fbae {_bcgd =append (_bcgd ,int64 (*_cfee ));}else {return nil ,ErrTypeError ;};};return _bcgd ,nil ;};func (_egaga *PdfParser )parseName ()(PdfObjectName ,error ){var _egeg _gcd .Buffer ;_bfac :=false ;for {_dfaf ,_beec :=_egaga ._daba .Peek (1);if _beec ==_de .EOF {break ;};if _beec !=nil {return PdfObjectName (_egeg .String ()),_beec ;};if !_bfac {if _dfaf [0]=='/'{_bfac =true ;_egaga ._daba .ReadByte ();}else if _dfaf [0]=='%'{_egaga .readComment ();_egaga .skipSpaces ();}else {_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020N\u0061\u006d\u0065\u0020\u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020w\u0069\u0074\u0068\u0020\u0025\u0073\u0020(\u0025\u0020\u0078\u0029",_dfaf ,_dfaf );return PdfObjectName (_egeg .String ()),_gc .Errorf ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u006ea\u006d\u0065:\u0020\u0028\u0025\u0063\u0029",_dfaf [0]);};}else {if IsWhiteSpace (_dfaf [0]){break ;}else if (_dfaf [0]=='/')||(_dfaf [0]=='[')||(_dfaf [0]=='(')||(_dfaf [0]==']')||(_dfaf [0]=='<')||(_dfaf [0]=='>'){break ;}else if _dfaf [0]=='#'{_gaef ,_ddcc :=_egaga ._daba .Peek (3);if _ddcc !=nil {return PdfObjectName (_egeg .String ()),_ddcc ;};_adbg ,_ddcc :=_fc .DecodeString (string (_gaef [1:3]));if _ddcc !=nil {_fg .Log .Debug ("\u0045\u0052\u0052\u004fR\u003a\u0020\u0049\u006ev\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0066o\u006c\u006co\u0077\u0069\u006e\u0067 \u0027\u0023\u0027\u002c \u0063\u006f\u006e\u0074\u0069n\u0075\u0069\u006e\u0067\u0020\u0075\u0073i\u006e\u0067\u0020\u006c\u0069t\u0065\u0072\u0061\u006c\u0020\u002d\u0020\u004f\u0075t\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074");_egeg .WriteByte ('#');_egaga ._daba .Discard (1);continue ;};_egaga ._daba .Discard (3);_egeg .Write (_adbg );}else {_efdf ,_ :=_egaga ._daba .ReadByte ();_egeg .WriteByte (_efdf );};};};return PdfObjectName (_egeg .String ()),nil ;};

// LookupByNumber looks up a PdfObject by object number.  Returns an error on failure.
func (_bgd *PdfParser )LookupByNumber (objNumber int )(PdfObject ,error ){_ade ,_ ,_bea :=_bgd .lookupByNumberWrapper (objNumber ,true );return _ade ,_bea ;};var _bbda =_a .MustCompile ("\u0025P\u0044F\u002d\u0028\u005c\u0064\u0029\u005c\u002e\u0028\u005c\u0064\u0029");

// NewASCIIHexEncoder makes a new ASCII hex encoder.
func NewASCIIHexEncoder ()*ASCIIHexEncoder {_eae :=&ASCIIHexEncoder {};return _eae };

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_agebd *RawEncoder )MakeDecodeParams ()PdfObject {return nil };

// DecodeBytes decodes a slice of JBIG2 encoded bytes and returns the results.
func (_becg *JBIG2Encoder )DecodeBytes (encoded []byte )([]byte ,error ){return _bf .DecodeBytes (encoded ,_cf .Parameters {},_becg .Globals );};

// Resolve resolves the reference and returns the indirect or stream object.
// If the reference cannot be resolved, a *PdfObjectNull object is returned.
func (_dfec *PdfObjectReference )Resolve ()PdfObject {if _dfec ._dgcf ==nil {return MakeNull ();};_ecadc ,_ ,_ddbefb :=_dfec ._dgcf .resolveReference (_dfec );if _ddbefb !=nil {_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0072\u0065\u0073\u006f\u006cv\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065r\u0065n\u0063\u0065\u003a\u0020\u0025\u0076\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074",_ddbefb );return MakeNull ();};if _ecadc ==nil {_fg .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0072\u0065\u0073ol\u0076\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065:\u0020\u006ei\u006c\u0020\u006fb\u006a\u0065\u0063\u0074\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u0061\u0020nu\u006c\u006c\u0020o\u0062\u006a\u0065\u0063\u0074");return MakeNull ();};return _ecadc ;};

// Version represents a version of a PDF standard.
type Version struct{Major int ;Minor int ;};

// MakeFloat creates an PdfObjectFloat from a float64.
func MakeFloat (val float64 )*PdfObjectFloat {_caa :=PdfObjectFloat (val );return &_caa };

// Len returns the number of elements in the array.
func (_dffce *PdfObjectArray )Len ()int {if _dffce ==nil {return 0;};return len (_dffce ._bcea );};

// Append appends PdfObject(s) to the array.
func (_acbag *PdfObjectArray )Append (objects ...PdfObject ){if _acbag ==nil {_fg .Log .Debug ("\u0057\u0061\u0072\u006e\u0020\u002d\u0020\u0041\u0074\u0074\u0065\u006d\u0070t\u0020\u0074\u006f\u0020\u0061\u0070p\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020a\u0072\u0072\u0061\u0079");return ;};_acbag ._bcea =append (_acbag ._bcea ,objects ...);};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_ddbd *RunLengthEncoder )MakeStreamDict ()*PdfObjectDictionary {_defd :=MakeDict ();_defd .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_ddbd .GetFilterName ()));return _defd ;};

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_dcda *RunLengthEncoder )EncodeBytes (data []byte )([]byte ,error ){_caea :=_gcd .NewReader (data );var _cadg []byte ;var _eef []byte ;_fcfb ,_dbb :=_caea .ReadByte ();if _dbb ==_de .EOF {return []byte {},nil ;}else if _dbb !=nil {return nil ,_dbb ;};_deef :=1;for {_ebcb ,_bgda :=_caea .ReadByte ();if _bgda ==_de .EOF {break ;}else if _bgda !=nil {return nil ,_bgda ;};if _ebcb ==_fcfb {if len (_eef )> 0{_eef =_eef [:len (_eef )-1];if len (_eef )> 0{_cadg =append (_cadg ,byte (len (_eef )-1));_cadg =append (_cadg ,_eef ...);};_deef =1;_eef =[]byte {};};_deef ++;if _deef >=127{_cadg =append (_cadg ,byte (257-_deef ),_fcfb );_deef =0;};}else {if _deef > 0{if _deef ==1{_eef =[]byte {_fcfb };}else {_cadg =append (_cadg ,byte (257-_deef ),_fcfb );};_deef =0;};_eef =append (_eef ,_ebcb );if len (_eef )>=127{_cadg =append (_cadg ,byte (len (_eef )-1));_cadg =append (_cadg ,_eef ...);_eef =[]byte {};};};_fcfb =_ebcb ;};if len (_eef )> 0{_cadg =append (_cadg ,byte (len (_eef )-1));_cadg =append (_cadg ,_eef ...);}else if _deef > 0{_cadg =append (_cadg ,byte (257-_deef ),_fcfb );};_cadg =append (_cadg ,128);return _cadg ,nil ;};

// GetFilterName returns the name of the encoding filter.
func (_dgdf *RawEncoder )GetFilterName ()string {return StreamEncodingFilterNameRaw };func (_afbd *PdfCrypt )checkAccessRights (_adb []byte )(bool ,_dfg .Permissions ,error ){_abb :=_afbd .securityHandler ();_faf ,_agbd ,_cfcd :=_abb .Authenticate (&_afbd ._cgc ,_adb );if _cfcd !=nil {return false ,0,_cfcd ;}else if _agbd ==0||len (_faf )==0{return false ,0,nil ;};return true ,_agbd ,nil ;};

// DecodeStream decodes RunLengthEncoded stream object and give back decoded bytes.
func (_dfdd *RunLengthEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _dfdd .DecodeBytes (streamObj .Stream );};

// DecodeStream decodes the stream containing CCITTFax encoded image data.
func (_caga *CCITTFaxEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _caga .DecodeBytes (streamObj .Stream );};

// NewEncoderFromStream creates a StreamEncoder based on the stream's dictionary.
func NewEncoderFromStream (streamObj *PdfObjectStream )(StreamEncoder ,error ){_faeg :=TraceToDirectObject (streamObj .PdfObjectDictionary .Get ("\u0046\u0069\u006c\u0074\u0065\u0072"));if _faeg ==nil {return NewRawEncoder (),nil ;};if _ ,_eebac :=_faeg .(*PdfObjectNull );_eebac {return NewRawEncoder (),nil ;};_fdde ,_bfacdf :=_faeg .(*PdfObjectName );if !_bfacdf {_effge ,_aefg :=_faeg .(*PdfObjectArray );if !_aefg {return nil ,_gc .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006f\u0072 \u0041\u0072\u0072\u0061\u0079\u0020\u006fb\u006a\u0065\u0063\u0074");};if _effge .Len ()==0{return NewRawEncoder (),nil ;};if _effge .Len ()!=1{_cadc ,_edgaf :=_bdeg (streamObj );if _edgaf !=nil {_fg .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0063\u0072\u0065\u0061\u0074\u0069\u006e\u0067\u0020\u006d\u0075\u006c\u0074i\u0020\u0065\u006e\u0063\u006f\u0064\u0065r\u003a\u0020\u0025\u0076",_edgaf );return nil ,_edgaf ;};_fg .Log .Trace ("\u004d\u0075\u006c\u0074\u0069\u0020\u0065\u006e\u0063:\u0020\u0025\u0073\u000a",_cadc );return _cadc ,nil ;};_faeg =_effge .Get (0);_fdde ,_aefg =_faeg .(*PdfObjectName );if !_aefg {return nil ,_gc .Errorf ("\u0066\u0069l\u0074\u0065\u0072\u0020a\u0072\u0072a\u0079\u0020\u006d\u0065\u006d\u0062\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006fb\u006a\u0065\u0063\u0074");};};switch *_fdde {case StreamEncodingFilterNameFlate :return _cbgc (streamObj ,nil );case StreamEncodingFilterNameLZW :return _ead (streamObj ,nil );case StreamEncodingFilterNameDCT :return _bde (streamObj ,nil );case StreamEncodingFilterNameRunLength :return _bfbc (streamObj ,nil );case StreamEncodingFilterNameASCIIHex :return NewASCIIHexEncoder (),nil ;case StreamEncodingFilterNameASCII85 ,"\u0041\u0038\u0035":return NewASCII85Encoder (),nil ;case StreamEncodingFilterNameCCITTFax :return _efad (streamObj ,nil );case StreamEncodingFilterNameJBIG2 :return _ccdd (streamObj ,nil );case StreamEncodingFilterNameJPX :return NewJPXEncoder (),nil ;};_fg .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064\u0069\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006fd\u0021");return nil ,_gc .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064i\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006f\u0064\u0020\u0028\u0025\u0073\u0029",*_fdde );};

// EncodeBytes encodes slice of bytes into JBIG2 encoding format.
// The input 'data' must be an image. In order to Decode it a user is responsible to
// load the codec ('png', 'jpg').
// Returns jbig2 single page encoded document byte slice. The encoder uses DefaultPageSettings
// to encode given image.
func (_egfb *JBIG2Encoder )EncodeBytes (data []byte )([]byte ,error ){const _dbce ="\u004aB\u0049\u0047\u0032\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002eE\u006e\u0063\u006f\u0064\u0065\u0042\u0079\u0074\u0065\u0073";if _egfb .ColorComponents !=1||_egfb .BitsPerComponent !=1{return nil ,_ad .Errorf (_dbce ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u002e\u0020\u004a\u0042\u0049G\u0032\u0020E\u006e\u0063o\u0064\u0065\u0072\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020bi\u006e\u0061\u0072\u0079\u0020\u0069\u006d\u0061\u0067e\u0073\u0020\u0064\u0061\u0074\u0061");};var (_ccef *_gf .Bitmap ;_gebaa error ;);_acg :=(_egfb .Width *_egfb .Height )==len (data );if _acg {_ccef ,_gebaa =_gf .NewWithUnpaddedData (_egfb .Width ,_egfb .Height ,data );}else {_ccef ,_gebaa =_gf .NewWithData (_egfb .Width ,_egfb .Height ,data );};if _gebaa !=nil {return nil ,_gebaa ;};_eaba :=_egfb .DefaultPageSettings ;if _gebaa =_eaba .Validate ();_gebaa !=nil {return nil ,_ad .Wrap (_gebaa ,_dbce ,"");};switch _eaba .Compression {case JB2Generic :if _gebaa =_egfb ._gbae .AddGenericPage (_ccef ,_eaba .DuplicatedLinesRemoval );_gebaa !=nil {return nil ,_ad .Wrap (_gebaa ,_dbce ,"");};case JB2SymbolCorrelation :return nil ,_ad .Error (_dbce ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");case JB2SymbolRankHaus :return nil ,_ad .Error (_dbce ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");default:return nil ,_ad .Error (_dbce ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return _egfb .Encode ();};

// GetInt returns the *PdfObjectBool object that is represented by a PdfObject either directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetInt (obj PdfObject )(_dcaf *PdfObjectInteger ,_cefd bool ){_dcaf ,_cefd =TraceToDirectObject (obj ).(*PdfObjectInteger );return _dcaf ,_cefd ;};

// PdfVersion returns version of the PDF file.
func (_feg *PdfParser )PdfVersion ()Version {return _feg ._adagd };

// GetNumberAsInt64 returns the contents of `obj` as an int64 if it is an integer or float, or an
// error if it isn't. This is for cases where expecting an integer, but some implementations
// actually store the number in a floating point format.
func GetNumberAsInt64 (obj PdfObject )(int64 ,error ){switch _badg :=obj .(type ){case *PdfObjectFloat :_fg .Log .Debug ("\u004e\u0075m\u0062\u0065\u0072\u0020\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0061\u0073\u0020\u0069\u006e\u0074e\u0067\u0065\u0072\u0020\u0077\u0061s\u0020\u0073\u0074\u006f\u0072\u0065\u0064\u0020\u0061\u0073\u0020\u0066\u006c\u006fa\u0074\u0020(\u0074\u0079\u0070\u0065 \u0063\u0061\u0073\u0074\u0069n\u0067\u0020\u0075\u0073\u0065\u0064\u0029");return int64 (*_badg ),nil ;case *PdfObjectInteger :return int64 (*_badg ),nil ;};return 0,ErrNotANumber ;};

// MakeArrayFromIntegers creates an PdfObjectArray from a slice of ints, where each array element is
// an PdfObjectInteger.
func MakeArrayFromIntegers (vals []int )*PdfObjectArray {_ceg :=MakeArray ();for _ ,_beag :=range vals {_ceg .Append (MakeInteger (int64 (_beag )));};return _ceg ;};func _gbbg (_gddec _ee .Image )*JBIG2Image {_gbaed :=_gddec .Base ();return &JBIG2Image {Data :_gbaed .Data ,Width :_gbaed .Width ,Height :_gbaed .Height ,HasPadding :true };};

// UpdateParams updates the parameter values of the encoder.
func (_gdae *DCTEncoder )UpdateParams (params *PdfObjectDictionary ){_beca ,_aeea :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _aeea ==nil {_gdae .ColorComponents =int (_beca );};_faae ,_aeea :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _aeea ==nil {_gdae .BitsPerComponent =int (_faae );};_dbec ,_aeea :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _aeea ==nil {_gdae .Width =int (_dbec );};_agbe ,_aeea :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _aeea ==nil {_gdae .Height =int (_agbe );};_bfdf ,_aeea :=GetNumberAsInt64 (params .Get ("\u0051u\u0061\u006c\u0069\u0074\u0079"));if _aeea ==nil {_gdae .Quality =int (_bfdf );};};

// WriteString outputs the object as it is to be written to file.
func (_cegc *PdfObjectDictionary )WriteString ()string {var _efaf _afa .Builder ;_efaf .WriteString ("\u003c\u003c");for _ ,_abab :=range _cegc ._fgae {_bedcd :=_cegc ._acacc [_abab ];_efaf .WriteString (_abab .WriteString ());_efaf .WriteString ("\u0020");_efaf .WriteString (_bedcd .WriteString ());};_efaf .WriteString ("\u003e\u003e");return _efaf .String ();};const JB2ImageAutoThreshold =-1.0;

// JBIG2EncoderSettings contains the parameters and settings used by the JBIG2Encoder.
// Current version works only on JB2Generic compression.
type JBIG2EncoderSettings struct{

// FileMode defines if the jbig2 encoder should return full jbig2 file instead of
// shortened pdf mode. This adds the file header to the jbig2 definition.
FileMode bool ;

// Compression is the setting that defines the compression type used for encoding the page.
Compression JBIG2CompressionType ;

// DuplicatedLinesRemoval code generic region in a way such that if the lines are duplicated the encoder
// doesn't store it twice.
DuplicatedLinesRemoval bool ;

// DefaultPixelValue is the bit value initial for every pixel in the page.
DefaultPixelValue uint8 ;

// ResolutionX optional setting that defines the 'x' axis input image resolution - used for single page encoding.
ResolutionX int ;

// ResolutionY optional setting that defines the 'y' axis input image resolution - used for single page encoding.
ResolutionY int ;

// Threshold defines the threshold of the image correlation for
// non Generic compression.
// User only for JB2SymbolCorrelation and JB2SymbolRankHaus methods.
// Best results in range [0.7 - 0.98] - the less the better the compression would be
// but the more lossy.
// Default value: 0.95
Threshold float64 ;};

// EncodeBytes ASCII encodes the passed in slice of bytes.
func (_cbaad *ASCIIHexEncoder )EncodeBytes (data []byte )([]byte ,error ){var _egge _gcd .Buffer ;for _ ,_fbf :=range data {_egge .WriteString (_gc .Sprintf ("\u0025\u002e\u0032X\u0020",_fbf ));};_egge .WriteByte ('>');return _egge .Bytes (),nil ;};func _ead (_aeef *PdfObjectStream ,_bage *PdfObjectDictionary )(*LZWEncoder ,error ){_aabb :=NewLZWEncoder ();_ccfb :=_aeef .PdfObjectDictionary ;if _ccfb ==nil {return _aabb ,nil ;};if _bage ==nil {_ebab :=TraceToDirectObject (_ccfb .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));if _ebab !=nil {if _cgab ,_bcab :=_ebab .(*PdfObjectDictionary );_bcab {_bage =_cgab ;}else if _aaed ,_cge :=_ebab .(*PdfObjectArray );_cge {if _aaed .Len ()==1{if _cgbg ,_ebfa :=GetDict (_aaed .Get (0));_ebfa {_bage =_cgbg ;};};};if _bage ==nil {_fg .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_ebab );return nil ,_gc .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};};_fcda :=_ccfb .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");if _fcda !=nil {_dgd ,_gdaf :=_fcda .(*PdfObjectInteger );if !_gdaf {_fg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a \u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065d\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u006e\u0075\u006d\u0065\u0072i\u0063 \u0028\u0025\u0054\u0029",_fcda );return nil ,_gc .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");};if *_dgd !=0&&*_dgd !=1{return nil ,_gc .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0076\u0061\u006c\u0075e\u0020\u0028\u006e\u006f\u0074 \u0030\u0020o\u0072\u0020\u0031\u0029");};_aabb .EarlyChange =int (*_dgd );}else {_aabb .EarlyChange =1;};if _bage ==nil {return _aabb ,nil ;};_fcda =_bage .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");if _fcda !=nil {_dffc ,_agac :=_fcda .(*PdfObjectInteger );if !_agac {_fg .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_fcda );return nil ,_gc .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_aabb .Predictor =int (*_dffc );};_fcda =_bage .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");if _fcda !=nil {_egdd ,_eeba :=_fcda .(*PdfObjectInteger );if !_eeba {_fg .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");return nil ,_gc .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_aabb .BitsPerComponent =int (*_egdd );};if _aabb .Predictor > 1{_aabb .Columns =1;_fcda =_bage .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");if _fcda !=nil {_aegc ,_cdbgg :=_fcda .(*PdfObjectInteger );if !_cdbgg {return nil ,_gc .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_aabb .Columns =int (*_aegc );};_aabb .Colors =1;_fcda =_bage .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _fcda !=nil {_adfe ,_acag :=_fcda .(*PdfObjectInteger );if !_acag {return nil ,_gc .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");};_aabb .Colors =int (*_adfe );};};_fg .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_bage .String ());return _aabb ,nil ;};

// MakeArrayFromFloats creates an PdfObjectArray from a slice of float64s, where each array element is an
// PdfObjectFloat.
func MakeArrayFromFloats (vals []float64 )*PdfObjectArray {_ffda :=MakeArray ();for _ ,_dgfg :=range vals {_ffda .Append (MakeFloat (_dgfg ));};return _ffda ;};const (_adbd =0;_daff =1;_ecfa =2;_daaa =3;_dafa =4;);

// DecodeStream decodes the stream data and returns the decoded data.
// An error is returned upon failure.
func DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_fg .Log .Trace ("\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_cadf ,_eeeec :=NewEncoderFromStream (streamObj );if _eeeec !=nil {_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_eeeec );return nil ,_eeeec ;};_fg .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076\u000a",_cadf );_aedd ,_eeeec :=_cadf .DecodeStream (streamObj );if _eeeec !=nil {_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_eeeec );return nil ,_eeeec ;};return _aedd ,nil ;};func _dccg ()string {return _fg .Version };

// NewJPXEncoder returns a new instance of JPXEncoder.
func NewJPXEncoder ()*JPXEncoder {return &JPXEncoder {}};

// RunLengthEncoder represents Run length encoding.
type RunLengthEncoder struct{};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_cace *ASCII85Encoder )MakeDecodeParams ()PdfObject {return nil };

// IsPrintable checks if a character is printable.
// Regular characters that are outside the range EXCLAMATION MARK(21h)
// (!) to TILDE (7Eh) (~) should be written using the hexadecimal notation.
func IsPrintable (c byte )bool {return 0x21<=c &&c <=0x7E};

// Clear resets the dictionary to an empty state.
func (_badc *PdfObjectDictionary )Clear (){_badc ._fgae =[]PdfObjectName {};_badc ._acacc =map[PdfObjectName ]PdfObject {};};

// GetParser returns the parser for lazy-loading or compare references.
func (_feag *PdfObjectReference )GetParser ()*PdfParser {return _feag ._dgcf };

// Merge merges in key/values from another dictionary. Overwriting if has same keys.
// The mutated dictionary (d) is returned in order to allow method chaining.
func (_egdf *PdfObjectDictionary )Merge (another *PdfObjectDictionary )*PdfObjectDictionary {if another !=nil {for _ ,_fdcg :=range another .Keys (){_beaga :=another .Get (_fdcg );_egdf .Set (_fdcg ,_beaga );};};return _egdf ;};func (_eeac *PdfObjectFloat )String ()string {return _gc .Sprintf ("\u0025\u0066",*_eeac )};func (_ggae *PdfParser )rebuildXrefTable ()error {_efgef :=XrefTable {};_efgef .ObjectMap =map[int ]XrefObject {};_febcg :=make ([]int ,0,len (_ggae ._cgbgg .ObjectMap ));for _ccbd :=range _ggae ._cgbgg .ObjectMap {_febcg =append (_febcg ,_ccbd );};_b .Ints (_febcg );for _ ,_ccabg :=range _febcg {_bacbb :=_ggae ._cgbgg .ObjectMap [_ccabg ];_cffbe ,_ ,_geff :=_ggae .lookupByNumberWrapper (_ccabg ,false );if _geff !=nil {_fg .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020U\u006e\u0061\u0062\u006ce t\u006f l\u006f\u006f\u006b\u0020\u0075\u0070\u0020ob\u006a\u0065\u0063\u0074\u0020\u0028\u0025s\u0029",_geff );_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0063\u006fm\u0070\u006c\u0065\u0074\u0065\u006c\u0079\u0020\u0062\u0072\u006f\u006b\u0065\u006e\u0020\u002d\u0020\u0061\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0074\u006f \u0072\u0065\u0070\u0061\u0069r\u0020");_fadgc ,_gedaa :=_ggae .repairRebuildXrefsTopDown ();if _gedaa !=nil {_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0072\u0065\u0062\u0075\u0069l\u0064\u0020\u0072\u0065\u0070a\u0069\u0072 \u0028\u0025\u0073\u0029",_gedaa );return _gedaa ;};_ggae ._cgbgg =*_fadgc ;_fg .Log .Debug ("\u0052e\u0070\u0061\u0069\u0072e\u0064\u0020\u0078\u0072\u0065f\u0020t\u0061b\u006c\u0065\u0020\u0062\u0075\u0069\u006ct");return nil ;};_gfcac ,_fedc ,_geff :=_dc (_cffbe );if _geff !=nil {return _geff ;};_bacbb .ObjectNumber =int (_gfcac );_bacbb .Generation =int (_fedc );_efgef .ObjectMap [int (_gfcac )]=_bacbb ;};_ggae ._cgbgg =_efgef ;_fg .Log .Debug ("N\u0065w\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061b\u006c\u0065\u0020\u0062ui\u006c\u0074");_bdgf (_ggae ._cgbgg );return nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set.  Some other parameters are generated elsewhere.
func (_bdbb *DCTEncoder )MakeStreamDict ()*PdfObjectDictionary {_fbca :=MakeDict ();_fbca .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_bdbb .GetFilterName ()));return _fbca ;};

// IsDelimiter checks if a character represents a delimiter.
func IsDelimiter (c byte )bool {return c =='('||c ==')'||c =='<'||c =='>'||c =='['||c ==']'||c =='{'||c =='}'||c =='/'||c =='%';};

// ResolveReference resolves reference if `o` is a *PdfObjectReference and returns the object referenced to.
// Otherwise returns back `o`.
func ResolveReference (obj PdfObject )PdfObject {if _bebba ,_adad :=obj .(*PdfObjectReference );_adad {return _bebba .Resolve ();};return obj ;};

// UpdateParams updates the parameter values of the encoder.
func (_eccde *ASCIIHexEncoder )UpdateParams (params *PdfObjectDictionary ){};

// LZWEncoder provides LZW encoding/decoding functionality.
type LZWEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Colors int ;

// LZW algorithm setting.
EarlyChange int ;};

// PdfObjectNull represents the primitive PDF null object.
type PdfObjectNull struct{};

// UpdateParams updates the parameter values of the encoder.
func (_effg *MultiEncoder )UpdateParams (params *PdfObjectDictionary ){for _ ,_fbg :=range _effg ._gba {_fbg .UpdateParams (params );};};

// NewLZWEncoder makes a new LZW encoder with default parameters.
func NewLZWEncoder ()*LZWEncoder {_ddb :=&LZWEncoder {};_ddb .Predictor =1;_ddb .BitsPerComponent =8;_ddb .Colors =1;_ddb .Columns =1;_ddb .EarlyChange =1;return _ddb ;};

// Len returns the number of elements in the streams.
func (_dcbf *PdfObjectStreams )Len ()int {if _dcbf ==nil {return 0;};return len (_dcbf ._gfcee );};

// Validate validates the page settings for the JBIG2 encoder.
func (_eeeg JBIG2EncoderSettings )Validate ()error {const _aagd ="\u0076a\u006ci\u0064\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065\u0072";if _eeeg .Threshold < 0||_eeeg .Threshold > 1.0{return _ad .Errorf (_aagd ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074\u0068\u0072\u0065\u0073\u0068\u006f\u006c\u0064\u0020\u0076a\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0076\u0027 \u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0069\u006e\u0020\u0072\u0061n\u0067\u0065\u0020\u005b\u0030\u002e0\u002c\u0020\u0031.\u0030\u005d",_eeeg .Threshold );};if _eeeg .ResolutionX < 0{return _ad .Errorf (_aagd ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0078\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_eeeg .ResolutionX );};if _eeeg .ResolutionY < 0{return _ad .Errorf (_aagd ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0079\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_eeeg .ResolutionY );};if _eeeg .DefaultPixelValue !=0&&_eeeg .DefaultPixelValue !=1{return _ad .Errorf (_aagd ,"de\u0066\u0061u\u006c\u0074\u0020\u0070\u0069\u0078\u0065\u006c\u0020v\u0061\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0066o\u0072 \u0074\u0068\u0065\u0020\u0062\u0069\u0074\u003a \u007b0\u002c\u0031}",_eeeg .DefaultPixelValue );};if _eeeg .Compression !=JB2Generic {return _ad .Errorf (_aagd ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065d\u0020\u0063\u006fm\u0070\u0072\u0065\u0073s\u0069\u006f\u006e\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");};return nil ;};

// PdfCryptNewDecrypt makes the document crypt handler based on the encryption dictionary
// and trailer dictionary. Returns an error on failure to process.
func PdfCryptNewDecrypt (parser *PdfParser ,ed ,trailer *PdfObjectDictionary )(*PdfCrypt ,error ){_bec :=&PdfCrypt {_bddg :false ,_cc :make (map[PdfObject ]bool ),_aaa :make (map[PdfObject ]bool ),_cdbg :make (map[int ]struct{}),_afaf :parser };_fgc ,_dee :=ed .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectName );if !_dee {_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0043\u0072\u0079\u0070\u0074 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061r\u0079 \u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u0066\u0069\u0065\u006c\u0064\u0021");return _bec ,_c .New ("r\u0065\u0071\u0075\u0069\u0072\u0065d\u0020\u0063\u0072\u0079\u0070\u0074 \u0066\u0069\u0065\u006c\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u006d\u0069\u0073\u0073\u0069n\u0067");};if *_fgc !="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"{_fg .Log .Debug ("\u0045\u0052R\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020(%\u0073\u0029",*_fgc );return _bec ,_c .New ("\u0075n\u0073u\u0070\u0070\u006f\u0072\u0074e\u0064\u0020F\u0069\u006c\u0074\u0065\u0072");};_bec ._age .Filter =string (*_fgc );if _fecg ,_dae :=ed .Get ("\u0053u\u0062\u0046\u0069\u006c\u0074\u0065r").(*PdfObjectString );_dae {_bec ._age .SubFilter =_fecg .Str ();_fg .Log .Debug ("\u0055s\u0069n\u0067\u0020\u0073\u0075\u0062f\u0069\u006ct\u0065\u0072\u0020\u0025\u0073",_fecg );};if L ,_bcd :=ed .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );_bcd {if (*L %8)!=0{_fg .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0049\u006ev\u0061\u006c\u0069\u0064\u0020\u0065\u006ec\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006c\u0065\u006e\u0067\u0074\u0068");return _bec ,_c .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0065\u006e\u0063\u0072y\u0070t\u0069o\u006e\u0020\u006c\u0065\u006e\u0067\u0074h");};_bec ._age .Length =int (*L );}else {_bec ._age .Length =40;};_bec ._age .V =0;if _bedb ,_cedf :=ed .Get ("\u0056").(*PdfObjectInteger );_cedf {V :=int (*_bedb );_bec ._age .V =V ;if V >=1&&V <=2{_bec ._dfb =_bgb (_bec ._age .Length );}else if V >=4&&V <=5{if _agb :=_bec .loadCryptFilters (ed );_agb !=nil {return _bec ,_agb ;};}else {_fg .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0061lg\u006f\u0020\u0056 \u003d \u0025\u0064",V );return _bec ,_c .New ("u\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d");};};if _eagd :=_bfe (&_bec ._cgc ,ed );_eagd !=nil {return _bec ,_eagd ;};_cee :="";if _egee ,_bcc :=trailer .Get ("\u0049\u0044").(*PdfObjectArray );_bcc &&_egee .Len ()>=1{_efb ,_bcdg :=GetString (_egee .Get (0));if !_bcdg {return _bec ,_c .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0074r\u0061\u0069l\u0065\u0072\u0020\u0049\u0044");};_cee =_efb .Str ();}else {_fg .Log .Debug ("\u0054\u0072ai\u006c\u0065\u0072 \u0049\u0044\u0020\u0061rra\u0079 m\u0069\u0073\u0073\u0069\u006e\u0067\u0020or\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0021");};_bec ._dg =_cee ;return _bec ,nil ;};

// String returns a string describing `stream`.
func (_cdfb *PdfObjectStream )String ()string {return _gc .Sprintf ("O\u0062j\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0025\u0064: \u0025\u0073",_cdfb .ObjectNumber ,_cdfb .PdfObjectDictionary );};

// EncodeBytes implements support for LZW encoding.  Currently not supporting predictors (raw compressed data only).
// Only supports the Early change = 1 algorithm (compress/lzw) as the other implementation
// does not have a write method.
// TODO: Consider refactoring compress/lzw to allow both.
func (_gefb *LZWEncoder )EncodeBytes (data []byte )([]byte ,error ){if _gefb .Predictor !=1{return nil ,_gc .Errorf ("\u004c\u005aW \u0050\u0072\u0065d\u0069\u0063\u0074\u006fr =\u00201 \u006f\u006e\u006c\u0079\u0020\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0079e\u0074");};if _gefb .EarlyChange ==1{return nil ,_gc .Errorf ("\u004c\u005a\u0057\u0020\u0045\u0061\u0072\u006c\u0079\u0020\u0043\u0068\u0061n\u0067\u0065\u0020\u003d\u0020\u0030 \u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0079\u0065\u0074");};var _faaa _gcd .Buffer ;_gdde :=_bed .NewWriter (&_faaa ,_bed .MSB ,8);_gdde .Write (data );_gdde .Close ();return _faaa .Bytes (),nil ;};

// GetFilterName returns the name of the encoding filter.
func (_cfg *CCITTFaxEncoder )GetFilterName ()string {return StreamEncodingFilterNameCCITTFax };

// Set sets the PdfObject at index i of the streams. An error is returned if the index is outside bounds.
func (_cfcdd *PdfObjectStreams )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_cfcdd ._gfcee ){return _c .New ("\u004f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_cfcdd ._gfcee [i ]=obj ;return nil ;};

// WriteString outputs the object as it is to be written to file.
func (_efcbd *PdfObjectStream )WriteString ()string {var _dfbd _afa .Builder ;_dfbd .WriteString (_e .FormatInt (_efcbd .ObjectNumber ,10));_dfbd .WriteString ("\u0020\u0030\u0020\u0052");return _dfbd .String ();};

// PdfObjectDictionary represents the primitive PDF dictionary/map object.
type PdfObjectDictionary struct{_acacc map[PdfObjectName ]PdfObject ;_fgae []PdfObjectName ;_adcc *PdfParser ;};

// ToIntegerArray returns a slice of all array elements as an int slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_gdee *PdfObjectArray )ToIntegerArray ()([]int ,error ){var _adege []int ;for _ ,_dbbee :=range _gdee .Elements (){if _edbfe ,_dgdbb :=_dbbee .(*PdfObjectInteger );_dgdbb {_adege =append (_adege ,int (*_edbfe ));}else {return nil ,ErrTypeError ;};};return _adege ,nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on the current encoder settings.
func (_gcb *JBIG2Encoder )MakeDecodeParams ()PdfObject {return MakeDict ()};

// SetPredictor sets the predictor function.  Specify the number of columns per row.
// The columns indicates the number of samples per row.
// Used for grouping data together for compression.
func (_edfc *FlateEncoder )SetPredictor (columns int ){_edfc .Predictor =11;_edfc .Columns =columns };const _cffg =10;

// Resolve resolves a PdfObject to direct object, looking up and resolving references as needed (unlike TraceToDirect).
func (_bdf *PdfParser )Resolve (obj PdfObject )(PdfObject ,error ){_ecf ,_gb :=obj .(*PdfObjectReference );if !_gb {return obj ,nil ;};_cfc :=_bdf .GetFileOffset ();defer func (){_bdf .SetFileOffset (_cfc )}();_eca ,_dfe :=_bdf .LookupByReference (*_ecf );if _dfe !=nil {return nil ,_dfe ;};_gg ,_ecff :=_eca .(*PdfIndirectObject );if !_ecff {return _eca ,nil ;};_eca =_gg .PdfObject ;_ ,_gb =_eca .(*PdfObjectReference );if _gb {return _gg ,_c .New ("\u006d\u0075lt\u0069\u0020\u0064e\u0070\u0074\u0068\u0020tra\u0063e \u0070\u006f\u0069\u006e\u0074\u0065\u0072 t\u006f\u0020\u0070\u006f\u0069\u006e\u0074e\u0072");};return _eca ,nil ;};func (_cdac *PdfParser )loadXrefs ()(*PdfObjectDictionary ,error ){_cdac ._cgbgg .ObjectMap =make (map[int ]XrefObject );_cdac ._eaeg =make (objectStreams );_bdbd ,_fdbb :=_cdac ._cdfe .Seek (0,_de .SeekEnd );if _fdbb !=nil {return nil ,_fdbb ;};_fg .Log .Trace ("\u0066s\u0069\u007a\u0065\u003a\u0020\u0025d",_bdbd );_cdac ._eecde =_bdbd ;_fdbb =_cdac .seekToEOFMarker (_bdbd );if _fdbb !=nil {_fg .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0073\u0065\u0065\u006b\u0020\u0074\u006f\u0020\u0065\u006f\u0066\u0020\u006d\u0061\u0072\u006b\u0065\u0072: \u0025\u0076",_fdbb );return nil ,_fdbb ;};_aedfa ,_fdbb :=_cdac ._cdfe .Seek (0,_de .SeekCurrent );if _fdbb !=nil {return nil ,_fdbb ;};var _ddeae int64 =64;_gdfff :=_aedfa -_ddeae ;if _gdfff < 0{_gdfff =0;};_ ,_fdbb =_cdac ._cdfe .Seek (_gdfff ,_de .SeekStart );if _fdbb !=nil {return nil ,_fdbb ;};_bbcf :=make ([]byte ,_ddeae );_ ,_fdbb =_cdac ._cdfe .Read (_bbcf );if _fdbb !=nil {_fg .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u003a\u0020\u0025\u0076",_fdbb );return nil ,_fdbb ;};_aggf :=_gfdf .FindStringSubmatch (string (_bbcf ));if len (_aggf )< 2{_fg .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020n\u006f\u0074\u0020f\u006fu\u006e\u0064\u0021");return nil ,_c .New ("\u0073\u0074\u0061\u0072tx\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};if len (_aggf )> 2{_fg .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u004du\u006c\u0074\u0069\u0070\u006c\u0065\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029\u0021",_bbcf );return nil ,_c .New ("m\u0075\u006c\u0074\u0069\u0070\u006ce\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065f\u0020\u0065\u006et\u0072i\u0065\u0073\u003f");};_cddd ,_ :=_e .ParseInt (_aggf [1],10,64);_fg .Log .Trace ("\u0073t\u0061r\u0074\u0078\u0072\u0065\u0066\u0020\u0061\u0074\u0020\u0025\u0064",_cddd );if _cddd > _bdbd {_fg .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u006f\u0066f\u0073e\u0074 \u006fu\u0074\u0073\u0069\u0064\u0065\u0020\u006f\u0066\u0020\u0066\u0069\u006c\u0065");_fg .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0072e\u0070\u0061\u0069\u0072");_cddd ,_fdbb =_cdac .repairLocateXref ();if _fdbb !=nil {_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0052\u0065\u0070\u0061\u0069\u0072\u0020\u0061\u0074\u0074\u0065\u006d\u0070t\u0020\u0066\u0061\u0069\u006c\u0065\u0064 \u0028\u0025\u0073\u0029");return nil ,_fdbb ;};};_cdac ._cdfe .Seek (_cddd ,_de .SeekStart );_cdac ._daba =_eg .NewReader (_cdac ._cdfe );_gefg ,_fdbb :=_cdac .parseXref ();if _fdbb !=nil {return nil ,_fdbb ;};_ecfb :=_gefg .Get ("\u0058R\u0065\u0066\u0053\u0074\u006d");if _ecfb !=nil {_bagd ,_dbfed :=_ecfb .(*PdfObjectInteger );if !_dbfed {return nil ,_c .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0021=\u0020\u0069\u006e\u0074");};_ ,_fdbb =_cdac .parseXrefStream (_bagd );if _fdbb !=nil {return nil ,_fdbb ;};};var _aba []int64 ;_ceba :=func (_bbg int64 ,_fefe []int64 )bool {for _ ,_eccf :=range _fefe {if _eccf ==_bbg {return true ;};};return false ;};_ecfb =_gefg .Get ("\u0050\u0072\u0065\u0076");for _ecfb !=nil {_fgfe ,_ebde :=_ecfb .(*PdfObjectInteger );if !_ebde {_fg .Log .Debug ("\u0049\u006ev\u0061\u006c\u0069\u0064\u0020P\u0072\u0065\u0076\u0020\u0072e\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u003a\u0020\u004e\u006f\u0074\u0020\u0061\u0020\u002a\u0050\u0064\u0066\u004f\u0062\u006a\u0065\u0063\u0074\u0049\u006e\u0074\u0065\u0067\u0065\u0072\u0020\u0028\u0025\u0054\u0029",_ecfb );return _gefg ,nil ;};_geab :=*_fgfe ;_fg .Log .Trace ("\u0041\u006eot\u0068\u0065\u0072 \u0050\u0072\u0065\u0076 xr\u0065f \u0074\u0061\u0062\u006c\u0065\u0020\u006fbj\u0065\u0063\u0074\u0020\u0061\u0074\u0020%\u0064",_geab );_cdac ._cdfe .Seek (int64 (_geab ),_de .SeekStart );_cdac ._daba =_eg .NewReader (_cdac ._cdfe );_gcdb ,_bce :=_cdac .parseXref ();if _bce !=nil {_fg .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0045\u0072\u0072\u006f\u0072\u0020-\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u0061\u0064\u0069n\u0067\u0020\u0061\u006e\u006f\u0074\u0068\u0065\u0072\u0020\u0028\u0050re\u0076\u0029\u0020\u0074\u0072\u0061\u0069\u006c\u0065\u0072");_fg .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0063\u006f\u006e\u0074\u0069n\u0075\u0065\u0020\u0062\u0079\u0020\u0069\u0067\u006e\u006f\u0072\u0069n\u0067\u0020\u0069\u0074");break ;};_ecfb =_gcdb .Get ("\u0050\u0072\u0065\u0076");if _ecfb !=nil {_ccee :=*(_ecfb .(*PdfObjectInteger ));if _ceba (int64 (_ccee ),_aba ){_fg .Log .Debug ("\u0050\u0072ev\u0065\u006e\u0074i\u006e\u0067\u0020\u0063irc\u0075la\u0072\u0020\u0078\u0072\u0065\u0066\u0020re\u0066\u0065\u0072\u0065\u006e\u0063\u0069n\u0067");break ;};_aba =append (_aba ,int64 (_ccee ));};};return _gefg ,nil ;};var _gedfe =_a .MustCompile ("\u005e\u005b\\\u002b\u002d\u002e\u005d*\u0028\u005b0\u002d\u0039\u002e\u005d\u002b\u0029\u005b\u0065E\u005d\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");

// EncryptInfo contains an information generated by the document encrypter.
type EncryptInfo struct{Version ;

// Encrypt is an encryption dictionary that contains all necessary parameters.
// It should be stored in all copies of the document trailer.
Encrypt *PdfObjectDictionary ;

// ID0 and ID1 are IDs used in the trailer. Older algorithms such as RC4 uses them for encryption.
ID0 ,ID1 string ;};

// MakeStreamDict make a new instance of an encoding dictionary for a stream object.
func (_bfaf *ASCII85Encoder )MakeStreamDict ()*PdfObjectDictionary {_fcec :=MakeDict ();_fcec .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_bfaf .GetFilterName ()));return _fcec ;};

// WriteString outputs the object as it is to be written to file.
func (_addc *PdfObjectFloat )WriteString ()string {return _e .FormatFloat (float64 (*_addc ),'f',-1,64);};

// MultiEncoder supports serial encoding.
type MultiEncoder struct{_gba []StreamEncoder };func (_ebc *PdfCrypt )securityHandler ()_dfg .StdHandler {if _ebc ._cgc .R >=5{return _dfg .NewHandlerR6 ();};return _dfg .NewHandlerR4 (_ebc ._dg ,_ebc ._age .Length );};

// GetFilterName returns the name of the encoding filter.
func (_aad *LZWEncoder )GetFilterName ()string {return StreamEncodingFilterNameLZW };func _gfab (_fgde ,_fbbac ,_bbb int )error {if _fbbac < 0||_fbbac > _fgde {return _c .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0061\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");};if _bbb < _fbbac {return _c .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0073\u006c\u0069\u0063e\u0020i\u006ed\u0065\u0078\u0020\u0062\u0020\u003c\u0020a");};if _bbb > _fgde {return _c .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0062\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");};return nil ;};func _fe (_ega *_cd .FilterDict ,_gacg *PdfObjectDictionary )error {if _cca ,_bdb :=_gacg .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_bdb {if _bdbg :=string (*_cca );_bdbg !="C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"{_fg .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020C\u0046\u0020\u0064ic\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074e\u0072\u0029",_bdbg );};};_dcb ,_gag :=_gacg .Get ("\u0043\u0046\u004d").(*PdfObjectName );if !_gag {return _gc .Errorf ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0028\u004e\u006f\u006e\u0065\u0029");};_ega .CFM =string (*_dcb );if _ccd ,_cde :=_gacg .Get ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et").(*PdfObjectName );_cde {_ega .AuthEvent =_dfg .AuthEvent (*_ccd );}else {_ega .AuthEvent =_dfg .EventDocOpen ;};if _dcf ,_fgdb :=_gacg .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );_fgdb {_ega .Length =int (*_dcf );};return nil ;};

// GetXrefOffset returns the offset of the xref table.
func (_feaf *PdfParser )GetXrefOffset ()int64 {return _feaf ._cfed };

// ResolveReferencesDeep recursively traverses through object `o`, looking up and replacing
// references with indirect objects.
// Optionally a map of already deep-resolved objects can be provided via `traversed`. The `traversed` map
// is updated while traversing the objects to avoid traversing same objects multiple times.
func ResolveReferencesDeep (o PdfObject ,traversed map[PdfObject ]struct{})error {if traversed ==nil {traversed =map[PdfObject ]struct{}{};};return _cggd (o ,0,traversed );};

// GetNumbersAsFloat converts a list of pdf objects representing floats or integers to a slice of
// float64 values.
func GetNumbersAsFloat (objects []PdfObject )(_agbb []float64 ,_aacg error ){for _ ,_dfcd :=range objects {_abfge ,_feebcd :=GetNumberAsFloat (_dfcd );if _feebcd !=nil {return nil ,_feebcd ;};_agbb =append (_agbb ,_abfge );};return _agbb ,nil ;};

// String returns a string describing `d`.
func (_dagab *PdfObjectDictionary )String ()string {var _efbgf _afa .Builder ;_efbgf .WriteString ("\u0044\u0069\u0063t\u0028");for _ ,_aaag :=range _dagab ._fgae {_bdccf :=_dagab ._acacc [_aaag ];_efbgf .WriteString ("\u0022"+_aaag .String ()+"\u0022\u003a\u0020");_efbgf .WriteString (_bdccf .String ());_efbgf .WriteString ("\u002c\u0020");};_efbgf .WriteString ("\u0029");return _efbgf .String ();};

// String returns the state of the bool as "true" or "false".
func (_abfc *PdfObjectBool )String ()string {if *_abfc {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};

// Decrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_fbd *PdfCrypt )Decrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _fbd .isDecrypted (obj ){return nil ;};switch _bedc :=obj .(type ){case *PdfIndirectObject :_fbd ._cc [_bedc ]=true ;_fg .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_bedc .ObjectNumber ,_bedc .GenerationNumber );_agf :=_bedc .ObjectNumber ;_bfd :=_bedc .GenerationNumber ;_afg :=_fbd .Decrypt (_bedc .PdfObject ,_agf ,_bfd );if _afg !=nil {return _afg ;};return nil ;case *PdfObjectStream :_fbd ._cc [_bedc ]=true ;_dad :=_bedc .PdfObjectDictionary ;if _fbd ._cgc .R !=5{if _abba ,_egag :=_dad .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_egag &&*_abba =="\u0058\u0052\u0065\u0066"{return nil ;};};_dafd :=_bedc .ObjectNumber ;_cbag :=_bedc .GenerationNumber ;_fg .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_dafd ,_cbag );_dagf :=_bfb ;if _fbd ._age .V >=4{_dagf =_fbd ._gca ;_fg .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_fbd ._gca );if _eeec ,_aaee :=_dad .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );_aaee {if _ecfd ,_feeg :=GetName (_eeec .Get (0));_feeg {if *_ecfd =="\u0043\u0072\u0079p\u0074"{_dagf ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _cda ,_ecfdd :=_dad .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );_ecfdd {if _eab ,_aaec :=_cda .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_aaec {if _ ,_gec :=_fbd ._dfb [string (*_eab )];_gec {_fg .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_eab );_dagf =string (*_eab );};};};};};};_fg .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_dagf );if _dagf =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_dadd :=_fbd .Decrypt (_dad ,_dafd ,_cbag );if _dadd !=nil {return _dadd ;};_bafe ,_dadd :=_fbd .makeKey (_dagf ,uint32 (_dafd ),uint32 (_cbag ),_fbd ._gbb );if _dadd !=nil {return _dadd ;};_bedc .Stream ,_dadd =_fbd .decryptBytes (_bedc .Stream ,_dagf ,_bafe );if _dadd !=nil {return _dadd ;};_dad .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_bedc .Stream ))));return nil ;case *PdfObjectString :_fg .Log .Trace ("\u0044e\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_cfb :=_bfb ;if _fbd ._age .V >=4{_fg .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_fbd ._fcb );if _fbd ._fcb =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_cfb =_fbd ._fcb ;};_ccbb ,_eec :=_fbd .makeKey (_cfb ,uint32 (parentObjNum ),uint32 (parentGenNum ),_fbd ._gbb );if _eec !=nil {return _eec ;};_cbc :=_bedc .Str ();_gaaa :=make ([]byte ,len (_cbc ));for _ggf :=0;_ggf < len (_cbc );_ggf ++{_gaaa [_ggf ]=_cbc [_ggf ];};_fg .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_gaaa ,_gaaa );_gaaa ,_eec =_fbd .decryptBytes (_gaaa ,_cfb ,_ccbb );if _eec !=nil {return _eec ;};_bedc ._abgc =string (_gaaa );return nil ;case *PdfObjectArray :for _ ,_ccdf :=range _bedc .Elements (){_cgb :=_fbd .Decrypt (_ccdf ,parentObjNum ,parentGenNum );if _cgb !=nil {return _cgb ;};};return nil ;case *PdfObjectDictionary :_fdf :=false ;if _fgfg :=_bedc .Get ("\u0054\u0079\u0070\u0065");_fgfg !=nil {_acd ,_afde :=_fgfg .(*PdfObjectName );if _afde &&*_acd =="\u0053\u0069\u0067"{_fdf =true ;};};for _ ,_gfff :=range _bedc .Keys (){_aag :=_bedc .Get (_gfff );if _fdf &&string (_gfff )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;};if string (_gfff )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_gfff )!="\u0050\u0072\u0065\u0076"&&string (_gfff )!="\u004c\u0061\u0073\u0074"{_dd :=_fbd .Decrypt (_aag ,parentObjNum ,parentGenNum );if _dd !=nil {return _dd ;};};};return nil ;};return nil ;};type objectStreams map[int ]objectStream ;

// DecodeStream decodes a LZW encoded stream and returns the result as a
// slice of bytes.
func (_egcc *LZWEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_fg .Log .Trace ("\u004c\u005a\u0057 \u0044\u0065\u0063\u006f\u0064\u0069\u006e\u0067");_fg .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_egcc .Predictor );_eaf ,_gfcb :=_egcc .DecodeBytes (streamObj .Stream );if _gfcb !=nil {return nil ,_gfcb ;};_fg .Log .Trace ("\u0020\u0049\u004e\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (streamObj .Stream ),streamObj .Stream );_fg .Log .Trace ("\u004f\u0055\u0054\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (_eaf ),_eaf );if _egcc .Predictor > 1{if _egcc .Predictor ==2{_fg .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_abea :=_egcc .Columns *_egcc .Colors ;if _abea < 1{return []byte {},nil ;};_ccgb :=len (_eaf )/_abea ;if len (_eaf )%_abea !=0{_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");return nil ,_gc .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_eaf ),_abea );};if _abea %_egcc .Colors !=0{return nil ,_gc .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_abea ,_egcc .Colors );};if _abea > len (_eaf ){_fg .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_abea ,len (_eaf ));return nil ,_c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_fg .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_eaf ),_eaf );_edb :=_gcd .NewBuffer (nil );for _cdag :=0;_cdag < _ccgb ;_cdag ++{_dgae :=_eaf [_abea *_cdag :_abea *(_cdag +1)];for _dcd :=_egcc .Colors ;_dcd < _abea ;_dcd ++{_dgae [_dcd ]=byte (int (_dgae [_dcd ]+_dgae [_dcd -_egcc .Colors ])%256);};_edb .Write (_dgae );};_gdaa :=_edb .Bytes ();_fg .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_gdaa ),_gdaa );return _gdaa ,nil ;}else if _egcc .Predictor >=10&&_egcc .Predictor <=15{_fg .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_acbf :=_egcc .Columns *_egcc .Colors +1;if _acbf < 1{return []byte {},nil ;};_cebf :=len (_eaf )/_acbf ;if len (_eaf )%_acbf !=0{return nil ,_gc .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_eaf ),_acbf );};if _acbf > len (_eaf ){_fg .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_acbf ,len (_eaf ));return nil ,_c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_abeac :=_gcd .NewBuffer (nil );_fg .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_egcc .Columns );_fg .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_eaf ),_acbf ,_cebf );_cdeb :=make ([]byte ,_acbf );for _cfbe :=0;_cfbe < _acbf ;_cfbe ++{_cdeb [_cfbe ]=0;};for _bfa :=0;_bfa < _cebf ;_bfa ++{_dfge :=_eaf [_acbf *_bfa :_acbf *(_bfa +1)];_fef :=_dfge [0];switch _fef {case 0:case 1:for _bgde :=2;_bgde < _acbf ;_bgde ++{_dfge [_bgde ]=byte (int (_dfge [_bgde ]+_dfge [_bgde -1])%256);};case 2:for _gebc :=1;_gebc < _acbf ;_gebc ++{_dfge [_gebc ]=byte (int (_dfge [_gebc ]+_cdeb [_gebc ])%256);};default:_fg .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0066i\u006c\u0074\u0065\u0072\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_fef );return nil ,_gc .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_fef );};for _aea :=0;_aea < _acbf ;_aea ++{_cdeb [_aea ]=_dfge [_aea ];};_abeac .Write (_dfge [1:]);};_bedbe :=_abeac .Bytes ();return _bedbe ,nil ;}else {_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_egcc .Predictor );return nil ,_gc .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_egcc .Predictor );};};return _eaf ,nil ;};

// DecodeStream decodes a FlateEncoded stream object and give back decoded bytes.
func (_gaf *FlateEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_fg .Log .Trace ("\u0046l\u0061t\u0065\u0044\u0065\u0063\u006fd\u0065\u0020s\u0074\u0072\u0065\u0061\u006d");_fg .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_gaf .Predictor );if _gaf .BitsPerComponent !=8{return nil ,_gc .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003d\u0025\u0064\u0020\u0028\u006f\u006e\u006c\u0079\u0020\u0038\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0029",_gaf .BitsPerComponent );};_cfef ,_ccbe :=_gaf .DecodeBytes (streamObj .Stream );if _ccbe !=nil {return nil ,_ccbe ;};_cfef ,_ccbe =_gaf .postDecodePredict (_cfef );if _ccbe !=nil {return nil ,_ccbe ;};return _gaf .cleanImageData (_cfef );};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_bgbcg *MultiEncoder )MakeStreamDict ()*PdfObjectDictionary {_abbb :=MakeDict ();_abbb .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",_bgbcg .GetFilterArray ());for _ ,_gade :=range _bgbcg ._gba {_gedf :=_gade .MakeStreamDict ();for _ ,_afacd :=range _gedf .Keys (){_egda :=_gedf .Get (_afacd );if _afacd !="\u0046\u0069\u006c\u0074\u0065\u0072"&&_afacd !="D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"{_abbb .Set (_afacd ,_egda );};};};_beba :=_bgbcg .MakeDecodeParams ();if _beba !=nil {_abbb .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_beba );};return _abbb ;};func (_acf *PdfParser )repairSeekXrefMarker ()error {_bfea ,_cec :=_acf ._cdfe .Seek (0,_de .SeekEnd );if _cec !=nil {return _cec ;};_bcceg :=_a .MustCompile ("\u005cs\u0078\u0072\u0065\u0066\u005c\u0073*");var _edcab int64 ;var _fgfb int64 =1000;for _edcab < _bfea {if _bfea <=(_fgfb +_edcab ){_fgfb =_bfea -_edcab ;};_ ,_gbdg :=_acf ._cdfe .Seek (-_edcab -_fgfb ,_de .SeekEnd );if _gbdg !=nil {return _gbdg ;};_ggeaa :=make ([]byte ,_fgfb );_acf ._cdfe .Read (_ggeaa );_fg .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0078\u0072\u0065\u0066\u0020\u003a\u0020\u0022\u0025\u0073\u0022",string (_ggeaa ));_cdfd :=_bcceg .FindAllStringIndex (string (_ggeaa ),-1);if _cdfd !=nil {_bdbbc :=_cdfd [len (_cdfd )-1];_fg .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_cdfd );_acf ._cdfe .Seek (-_edcab -_fgfb +int64 (_bdbbc [0]),_de .SeekEnd );_acf ._daba =_eg .NewReader (_acf ._cdfe );for {_eefa ,_gaceb :=_acf ._daba .Peek (1);if _gaceb !=nil {return _gaceb ;};_fg .Log .Trace ("\u0042\u003a\u0020\u0025\u0064\u0020\u0025\u0063",_eefa [0],_eefa [0]);if !IsWhiteSpace (_eefa [0]){break ;};_acf ._daba .Discard (1);};return nil ;};_fg .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");_edcab +=_fgfb ;};_fg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074a\u0062\u006c\u0065\u0020\u006d\u0061r\u006b\u0065\u0072\u0020\u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066o\u0075\u006e\u0064\u002e");return _c .New ("\u0078r\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0020");};

// WriteString outputs the object as it is to be written to file.
func (_dcbc *PdfObjectInteger )WriteString ()string {return _e .FormatInt (int64 (*_dcbc ),10)};

// PdfObjectArray represents the primitive PDF array object.
type PdfObjectArray struct{_bcea []PdfObject };func _bfbc (_afbc *PdfObjectStream ,_egcgb *PdfObjectDictionary )(*RunLengthEncoder ,error ){return NewRunLengthEncoder (),nil ;};

// GetDict returns the *PdfObjectDictionary represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetDict (obj PdfObject )(_cgcd *PdfObjectDictionary ,_efbgb bool ){_cgcd ,_efbgb =TraceToDirectObject (obj ).(*PdfObjectDictionary );return _cgcd ,_efbgb ;};

// SetIfNotNil sets the dictionary's key -> val mapping entry -IF- val is not nil.
// Note that we take care to perform a type switch.  Otherwise if we would supply a nil value
// of another type, e.g. (PdfObjectArray*)(nil), then it would not be a PdfObject(nil) and thus
// would get set.
func (_dbbdd *PdfObjectDictionary )SetIfNotNil (key PdfObjectName ,val PdfObject ){if val !=nil {switch _dfbb :=val .(type ){case *PdfObjectName :if _dfbb !=nil {_dbbdd .Set (key ,val );};case *PdfObjectDictionary :if _dfbb !=nil {_dbbdd .Set (key ,val );};case *PdfObjectStream :if _dfbb !=nil {_dbbdd .Set (key ,val );};case *PdfObjectString :if _dfbb !=nil {_dbbdd .Set (key ,val );};case *PdfObjectNull :if _dfbb !=nil {_dbbdd .Set (key ,val );};case *PdfObjectInteger :if _dfbb !=nil {_dbbdd .Set (key ,val );};case *PdfObjectArray :if _dfbb !=nil {_dbbdd .Set (key ,val );};case *PdfObjectBool :if _dfbb !=nil {_dbbdd .Set (key ,val );};case *PdfObjectFloat :if _dfbb !=nil {_dbbdd .Set (key ,val );};case *PdfObjectReference :if _dfbb !=nil {_dbbdd .Set (key ,val );};case *PdfIndirectObject :if _dfbb !=nil {_dbbdd .Set (key ,val );};default:_fg .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",val );};};};

// MakeArrayFromIntegers64 creates an PdfObjectArray from a slice of int64s, where each array element
// is an PdfObjectInteger.
func MakeArrayFromIntegers64 (vals []int64 )*PdfObjectArray {_aceg :=MakeArray ();for _ ,_fcgc :=range vals {_aceg .Append (MakeInteger (_fcgc ));};return _aceg ;};

// NewParser creates a new parser for a PDF file via ReadSeeker. Loads the cross reference stream and trailer.
// An error is returned on failure.
func NewParser (rs _de .ReadSeeker )(*PdfParser ,error ){_dbeg :=&PdfParser {_cdfe :rs ,ObjCache :make (objectCache ),_bcaa :map[int64 ]bool {}};_ggc ,_ecgcg ,_cbef :=_dbeg .parsePdfVersion ();if _cbef !=nil {_fg .Log .Error ("U\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0076e\u0072\u0073\u0069o\u006e:\u0020\u0025\u0076",_cbef );return nil ,_cbef ;};_dbeg ._adagd .Major =_ggc ;_dbeg ._adagd .Minor =_ecgcg ;if _dbeg ._eaeb ,_cbef =_dbeg .loadXrefs ();_cbef !=nil {_fg .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020F\u0061\u0069\u006c\u0065d t\u006f l\u006f\u0061\u0064\u0020\u0078\u0072\u0065f \u0074\u0061\u0062\u006c\u0065\u0021\u0020%\u0073",_cbef );return nil ,_cbef ;};_fg .Log .Trace ("T\u0072\u0061\u0069\u006c\u0065\u0072\u003a\u0020\u0025\u0073",_dbeg ._eaeb );if len (_dbeg ._cgbgg .ObjectMap )==0{return nil ,_gc .Errorf ("\u0065\u006d\u0070\u0074\u0079\u0020\u0058\u0052\u0045\u0046\u0020t\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0049\u006e\u0076a\u006c\u0069\u0064");};return _dbeg ,nil ;};

// GetFilterName returns the name of the encoding filter.
func (_add *ASCII85Encoder )GetFilterName ()string {return StreamEncodingFilterNameASCII85 };func (_efab *PdfParser )resolveReference (_gbbfg *PdfObjectReference )(PdfObject ,bool ,error ){_dfag ,_abff :=_efab .ObjCache [int (_gbbfg .ObjectNumber )];if _abff {return _dfag ,true ,nil ;};_bfaeg ,_ffce :=_efab .LookupByReference (*_gbbfg );if _ffce !=nil {return nil ,false ,_ffce ;};_efab .ObjCache [int (_gbbfg .ObjectNumber )]=_bfaeg ;return _bfaeg ,false ,nil ;};

// ToGoImage converts the JBIG2Image to the golang image.Image.
func (_eced *JBIG2Image )ToGoImage ()(_cg .Image ,error ){const _dfgfd ="J\u0042I\u0047\u0032\u0049\u006d\u0061\u0067\u0065\u002eT\u006f\u0047\u006f\u0049ma\u0067\u0065";if _eced .Data ==nil {return nil ,_ad .Error (_dfgfd ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");};if _eced .Width ==0||_eced .Height ==0{return nil ,_ad .Error (_dfgfd ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");};_edbd ,_edff :=_ee .NewImage (_eced .Width ,_eced .Height ,1,1,_eced .Data ,nil ,nil );if _edff !=nil {return nil ,_edff ;};return _edbd ,nil ;};func (_adg *PdfParser )lookupByNumberWrapper (_ecd int ,_ef bool )(PdfObject ,bool ,error ){_eff ,_cb ,_bac :=_adg .lookupByNumber (_ecd ,_ef );if _bac !=nil {return nil ,_cb ,_bac ;};if !_cb &&_adg ._abd !=nil &&!_adg ._abd .isDecrypted (_eff ){_bdd :=_adg ._abd .Decrypt (_eff ,0,0);if _bdd !=nil {return nil ,_cb ,_bdd ;};};return _eff ,_cb ,nil ;};

// CheckAccessRights checks access rights and permissions for a specified password. If either user/owner password is
// specified, full rights are granted, otherwise the access rights are specified by the Permissions flag.
//
// The bool flag indicates that the user can access and view the file.
// The AccessPermissions shows what access the user has for editing etc.
// An error is returned if there was a problem performing the authentication.
func (_gcdfe *PdfParser )CheckAccessRights (password []byte )(bool ,_dfg .Permissions ,error ){if _gcdfe ._abd ==nil {return true ,_dfg .PermOwner ,nil ;};return _gcdfe ._abd .checkAccessRights (password );};const (DefaultJPEGQuality =75;);func _gdffe (_egcce PdfObject ,_cbbf int )PdfObject {if _cbbf > _cffg {_fg .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_cffg );return MakeNull ();};switch _efee :=_egcce .(type ){case *PdfIndirectObject :_egcce =_gdffe ((*_efee ).PdfObject ,_cbbf +1);case *PdfObjectArray :for _dafdb ,_gcad :=range (*_efee )._bcea {(*_efee )._bcea [_dafdb ]=_gdffe (_gcad ,_cbbf +1);};case *PdfObjectDictionary :for _ggdab ,_deaf :=range (*_efee )._acacc {(*_efee )._acacc [_ggdab ]=_gdffe (_deaf ,_cbbf +1);};_b .Slice ((*_efee )._fgae ,func (_edbfa ,_bbee int )bool {return (*_efee )._fgae [_edbfa ]< (*_efee )._fgae [_bbee ]});};return _egcce ;};

// JBIG2Encoder implements both jbig2 encoder and the decoder. The encoder allows to encode
// provided images (best used document scans) in multiple way. By default it uses single page generic
// encoder. It allows to store lossless data as a single segment.
// In order to store multiple image pages use the 'FileMode' which allows to store more pages within single jbig2 document.
// WIP: In order to obtain better compression results the encoder would allow to encode the input in a
// lossy or lossless way with a component (symbol) mode. It divides the image into components.
// Then checks if any component is 'similar' to the others and maps them together. The symbol classes are stored
// in the dictionary. Then the encoder creates text regions which uses the related symbol classes to fill it's space.
// The similarity is defined by the 'Threshold' variable (default: 0.95). The less the value is, the more components
// matches to single class, thus the compression is better, but the result might become lossy.
type JBIG2Encoder struct{

// These values are required to be set for the 'EncodeBytes' method.
// ColorComponents defines the number of color components for provided image.
ColorComponents int ;

// BitsPerComponent is the number of bits that stores per color component
BitsPerComponent int ;

// Width is the width of the image to encode
Width int ;

// Height is the height of the image to encode.
Height int ;_gbae *_ca .Document ;

// Globals are the JBIG2 global segments.
Globals _bf .Globals ;

// IsChocolateData defines if the data is encoded such that
// binary data '1' means black and '0' white.
// otherwise the data is called vanilla.
// Naming convention taken from: 'https://en.wikipedia.org/wiki/Binary_image#Interpretation'
IsChocolateData bool ;

// DefaultPageSettings are the settings parameters used by the jbig2 encoder.
DefaultPageSettings JBIG2EncoderSettings ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_cgd *LZWEncoder )MakeStreamDict ()*PdfObjectDictionary {_gceg :=MakeDict ();_gceg .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_cgd .GetFilterName ()));_bbag :=_cgd .MakeDecodeParams ();if _bbag !=nil {_gceg .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_bbag );};_gceg .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (int64 (_cgd .EarlyChange )));return _gceg ;};func _bfead (_dabf ,_ffcf PdfObject ,_gbcdf int )bool {if _gbcdf > _cffg {_fg .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_cffg );return false ;};if _dabf ==nil &&_ffcf ==nil {return true ;}else if _dabf ==nil ||_ffcf ==nil {return false ;};if _g .TypeOf (_dabf )!=_g .TypeOf (_ffcf ){return false ;};switch _gcfa :=_dabf .(type ){case *PdfObjectNull ,*PdfObjectReference :return true ;case *PdfObjectName :return *_gcfa ==*(_ffcf .(*PdfObjectName ));case *PdfObjectString :return *_gcfa ==*(_ffcf .(*PdfObjectString ));case *PdfObjectInteger :return *_gcfa ==*(_ffcf .(*PdfObjectInteger ));case *PdfObjectBool :return *_gcfa ==*(_ffcf .(*PdfObjectBool ));case *PdfObjectFloat :return *_gcfa ==*(_ffcf .(*PdfObjectFloat ));case *PdfIndirectObject :return _bfead (TraceToDirectObject (_dabf ),TraceToDirectObject (_ffcf ),_gbcdf +1);case *PdfObjectArray :_ffeea :=_ffcf .(*PdfObjectArray );if len ((*_gcfa )._bcea )!=len ((*_ffeea )._bcea ){return false ;};for _fcfc ,_ffdba :=range (*_gcfa )._bcea {if !_bfead (_ffdba ,(*_ffeea )._bcea [_fcfc ],_gbcdf +1){return false ;};};return true ;case *PdfObjectDictionary :_fcgf :=_ffcf .(*PdfObjectDictionary );_fddf ,_ddefa :=(*_gcfa )._acacc ,(*_fcgf )._acacc ;if len (_fddf )!=len (_ddefa ){return false ;};for _cgcf ,_cgbefd :=range _fddf {_begdc ,_bdda :=_ddefa [_cgcf ];if !_bdda ||!_bfead (_cgbefd ,_begdc ,_gbcdf +1){return false ;};};return true ;case *PdfObjectStream :_aeac :=_ffcf .(*PdfObjectStream );return _bfead ((*_gcfa ).PdfObjectDictionary ,(*_aeac ).PdfObjectDictionary ,_gbcdf +1);default:_fg .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",_dabf );};return false ;};func (_bdegg *PdfParser )skipComments ()error {if _ ,_dcdc :=_bdegg .skipSpaces ();_dcdc !=nil {return _dcdc ;};_gacf :=true ;for {_ccgg ,_gfgf :=_bdegg ._daba .Peek (1);if _gfgf !=nil {_fg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_gfgf .Error ());return _gfgf ;};if _gacf &&_ccgg [0]!='%'{return nil ;};_gacf =false ;if (_ccgg [0]!='\r')&&(_ccgg [0]!='\n'){_bdegg ._daba .ReadByte ();}else {break ;};};return _bdegg .skipComments ();};func (_edab *PdfParser )inspect ()(map[string ]int ,error ){_fg .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0053P\u0045\u0043\u0054\u0020\u002d\u002d\u002d\u002d\u002d\u002d-\u002d\u002d\u002d");_fg .Log .Trace ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");_cagbd :=map[string ]int {};_fegd :=0;_eafc :=0;var _dcebf []int ;for _ffbf :=range _edab ._cgbgg .ObjectMap {_dcebf =append (_dcebf ,_ffbf );};_b .Ints (_dcebf );_fbad :=0;for _ ,_begc :=range _dcebf {_bbdb :=_edab ._cgbgg .ObjectMap [_begc ];if _bbdb .ObjectNumber ==0{continue ;};_fegd ++;_fg .Log .Trace ("\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d");_fg .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0075\u0070\u0020\u006f\u0062\u006a\u0065c\u0074 \u006e\u0075\u006d\u0062\u0065\u0072\u003a \u0025\u0064",_bbdb .ObjectNumber );_fedfa ,_efec :=_edab .LookupByNumber (_bbdb .ObjectNumber );if _efec !=nil {_fg .Log .Trace ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u006c\u006f\u006f\u006b\u0075p\u0020\u006f\u0062\u006a\u0020\u0025\u0064 \u0028\u0025\u0073\u0029",_bbdb .ObjectNumber ,_efec );_eafc ++;continue ;};_fg .Log .Trace ("\u006fb\u006a\u003a\u0020\u0025\u0073",_fedfa );_deba ,_gbceg :=_fedfa .(*PdfIndirectObject );if _gbceg {_fg .Log .Trace ("\u0049N\u0044 \u004f\u004f\u0042\u004a\u0020\u0025\u0064\u003a\u0020\u0025\u0073",_bbdb .ObjectNumber ,_deba );_eegfb ,_bdcg :=_deba .PdfObject .(*PdfObjectDictionary );if _bdcg {if _ebee ,_dabb :=_eegfb .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_dabb {_egcf :=string (*_ebee );_fg .Log .Trace ("\u002d\u002d\u002d\u003e\u0020\u004f\u0062\u006a\u0020\u0074\u0079\u0070e\u003a\u0020\u0025\u0073",_egcf );_ ,_eeda :=_cagbd [_egcf ];if _eeda {_cagbd [_egcf ]++;}else {_cagbd [_egcf ]=1;};}else if _dede ,_gcfbd :=_eegfb .Get ("\u0053u\u0062\u0074\u0079\u0070\u0065").(*PdfObjectName );_gcfbd {_gcbee :=string (*_dede );_fg .Log .Trace ("-\u002d-\u003e\u0020\u004f\u0062\u006a\u0020\u0073\u0075b\u0074\u0079\u0070\u0065: \u0025\u0073",_gcbee );_ ,_befa :=_cagbd [_gcbee ];if _befa {_cagbd [_gcbee ]++;}else {_cagbd [_gcbee ]=1;};};if _dggg ,_fbag :=_eegfb .Get ("\u0053").(*PdfObjectName );_fbag &&*_dggg =="\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"{_ ,_bcac :=_cagbd ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"];if _bcac {_cagbd ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]++;}else {_cagbd ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]=1;};};};}else if _gccag ,_gddg :=_fedfa .(*PdfObjectStream );_gddg {if _cggab ,_fddb :=_gccag .PdfObjectDictionary .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_fddb {_fg .Log .Trace ("\u002d\u002d\u003e\u0020\u0053\u0074\u0072\u0065\u0061\u006d\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073",*_cggab );_abec :=string (*_cggab );_cagbd [_abec ]++;};}else {_fdae ,_cebaa :=_fedfa .(*PdfObjectDictionary );if _cebaa {_dgge ,_fedec :=_fdae .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if _fedec {_ffea :=string (*_dgge );_fg .Log .Trace ("\u002d-\u002d \u006f\u0062\u006a\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073",_ffea );_cagbd [_ffea ]++;};};_fg .Log .Trace ("\u0044\u0049\u0052\u0045\u0043\u0054\u0020\u004f\u0042\u004a\u0020\u0025d\u003a\u0020\u0025\u0073",_bbdb .ObjectNumber ,_fedfa );};_fbad ++;};_fg .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0045\u004fF\u0020\u0049\u004e\u0053\u0050\u0045\u0043T\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d");_fg .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");_fg .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074 \u0063\u006f\u0075\u006e\u0074\u003a\u0020\u0025\u0064",_fegd );_fg .Log .Trace ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u006f\u006b\u0075p\u003a\u0020\u0025\u0064",_eafc );for _dfdf ,_bdef :=range _cagbd {_fg .Log .Trace ("\u0025\u0073\u003a\u0020\u0025\u0064",_dfdf ,_bdef );};_fg .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");if len (_edab ._cgbgg .ObjectMap )< 1{_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0068\u0069\u0073 \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074 \u0069s\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0028\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0021\u0029");return nil ,_gc .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0064\u006fc\u0075\u006d\u0065\u006e\u0074\u0020\u0028\u0078r\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006d\u0069\u0073s\u0069\u006e\u0067\u0029");};_bgaa ,_dffd :=_cagbd ["\u0046\u006f\u006e\u0074"];if !_dffd ||_bgaa < 2{_fg .Log .Trace ("\u0054\u0068\u0069s \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020i\u0073 \u0070r\u006fb\u0061\u0062\u006c\u0079\u0020\u0073\u0063\u0061\u006e\u006e\u0065\u0064\u0021");}else {_fg .Log .Trace ("\u0054\u0068\u0069\u0073\u0020\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020\u0069\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0066o\u0072\u0020\u0065\u0078\u0074r\u0061\u0063t\u0069\u006f\u006e\u0021");};return _cagbd ,nil ;};

// PdfParser parses a PDF file and provides access to the object structure of the PDF.
type PdfParser struct{_adagd Version ;_cdfe _de .ReadSeeker ;_daba *_eg .Reader ;_eecde int64 ;_cgbgg XrefTable ;_cfed int64 ;_fagf *xrefType ;_eaeg objectStreams ;_eaeb *PdfObjectDictionary ;_abd *PdfCrypt ;_gacd bool ;ObjCache objectCache ;_dce map[int ]bool ;_bcaa map[int64 ]bool ;};func (_fda *PdfParser )lookupByNumber (_geg int ,_baf bool )(PdfObject ,bool ,error ){_eeb ,_afb :=_fda .ObjCache [_geg ];if _afb {_fg .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0063a\u0063\u0068\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0025\u0064",_geg );return _eeb ,false ,nil ;};if _fda ._dce ==nil {_fda ._dce =map[int ]bool {};};if _fda ._dce [_geg ]{_fg .Log .Debug ("ER\u0052\u004f\u0052\u003a\u0020\u004c\u006fok\u0075\u0070\u0020\u006f\u0066\u0020\u0025\u0064\u0020\u0069\u0073\u0020\u0061\u006c\u0072e\u0061\u0064\u0079\u0020\u0069\u006e\u0020\u0070\u0072\u006f\u0067\u0072\u0065\u0073\u0073\u0020\u002d\u0020\u0072\u0065c\u0075\u0072\u0073\u0069\u0076\u0065 \u006c\u006f\u006f\u006b\u0075\u0070\u0020\u0061\u0074t\u0065m\u0070\u0074\u0020\u0062\u006c\u006f\u0063\u006b\u0065\u0064",_geg );return nil ,false ,_c .New ("\u0072\u0065\u0063\u0075\u0072\u0073\u0069\u0076\u0065\u0020\u006c\u006f\u006f\u006b\u0075p\u0020a\u0074\u0074\u0065\u006d\u0070\u0074\u0020\u0062\u006c\u006f\u0063\u006b\u0065\u0064");};_fda ._dce [_geg ]=true ;defer delete (_fda ._dce ,_geg );_bb ,_afb :=_fda ._cgbgg .ObjectMap [_geg ];if !_afb {_fg .Log .Trace ("\u0055\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u006c\u006f\u0063\u0061t\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0069\u006e\u0020\u0078\u0072\u0065\u0066\u0073\u0021 \u002d\u0020\u0052\u0065\u0074u\u0072\u006e\u0069\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074");var _ffd PdfObjectNull ;return &_ffd ,false ,nil ;};_fg .Log .Trace ("L\u006fo\u006b\u0075\u0070\u0020\u006f\u0062\u006a\u0020n\u0075\u006d\u0062\u0065r \u0025\u0064",_geg );if _bb .XType ==XrefTypeTableEntry {_fg .Log .Trace ("\u0078r\u0065f\u006f\u0062\u006a\u0020\u006fb\u006a\u0020n\u0075\u006d\u0020\u0025\u0064",_bb .ObjectNumber );_fg .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u0067e\u006e\u0020\u0025\u0064",_bb .Generation );_fg .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0064",_bb .Offset );_fda ._cdfe .Seek (_bb .Offset ,_de .SeekStart );_fda ._daba =_eg .NewReader (_fda ._cdfe );_cbf ,_gde :=_fda .ParseIndirectObject ();if _gde !=nil {_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006ce\u0064\u0020\u0072\u0065\u0061\u0064\u0069n\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029",_gde );if _baf {_fg .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0072\u0065\u0070\u0061\u0069r\u0020\u0078\u0072\u0065\u0066\u0073\u0020\u0028\u0074\u006f\u0070\u0020d\u006f\u0077\u006e\u0029");_bca ,_bef :=_fda .repairRebuildXrefsTopDown ();if _bef !=nil {_fg .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020r\u0065\u0070\u0061\u0069\u0072\u0020\u0028\u0025\u0073\u0029",_bef );return nil ,false ,_bef ;};_fda ._cgbgg =*_bca ;return _fda .lookupByNumber (_geg ,false );};return nil ,false ,_gde ;};if _baf {_gfd ,_ ,_ :=_dc (_cbf );if int (_gfd )!=_geg {_fg .Log .Debug ("\u0049n\u0076\u0061\u006c\u0069d\u0020\u0078\u0072\u0065\u0066s\u003a \u0052e\u0062\u0075\u0069\u006c\u0064\u0069\u006eg");_bba :=_fda .rebuildXrefTable ();if _bba !=nil {return nil ,false ,_bba ;};_fda .ObjCache =objectCache {};return _fda .lookupByNumberWrapper (_geg ,false );};};_fg .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006f\u0062\u006a");_fda .ObjCache [_geg ]=_cbf ;return _cbf ,false ,nil ;}else if _bb .XType ==XrefTypeObjectStream {_fg .Log .Trace ("\u0078r\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0021");_fg .Log .Trace ("\u003e\u004c\u006f\u0061\u0064\u0020\u0076\u0069\u0061\u0020\u004f\u0053\u0021");_fg .Log .Trace ("\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d \u0061\u0076\u0061\u0069\u006c\u0061b\u006c\u0065\u0020\u0069\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020%\u0064\u002f\u0025\u0064",_bb .OsObjNumber ,_bb .OsObjIndex );if _bb .OsObjNumber ==_geg {_fg .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0043i\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065f\u0065\u0072\u0065n\u0063e\u0021\u003f\u0021");return nil ,true ,_c .New ("\u0078\u0072\u0065f \u0063\u0069\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");};if _ ,_edf :=_fda ._cgbgg .ObjectMap [_bb .OsObjNumber ];_edf {_cbb ,_ced :=_fda .lookupObjectViaOS (_bb .OsObjNumber ,_geg );if _ced !=nil {_fg .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0052\u0065\u0074\u0075\u0072\u006e\u0069n\u0067\u0020\u0045\u0052\u0052\u0020\u0028\u0025\u0073\u0029",_ced );return nil ,true ,_ced ;};_fg .Log .Trace ("\u003c\u004c\u006f\u0061\u0064\u0065\u0064\u0020\u0076i\u0061\u0020\u004f\u0053");_fda .ObjCache [_geg ]=_cbb ;if _fda ._abd !=nil {_fda ._abd ._cc [_cbb ]=true ;};return _cbb ,true ,nil ;};_fg .Log .Debug ("\u003f\u003f\u0020\u0042\u0065\u006c\u006f\u006eg\u0073\u0020\u0074o \u0061\u0020\u006e\u006f\u006e\u002dc\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u002e.\u002e\u0021");return nil ,true ,_c .New ("\u006f\u0073\u0020\u0062\u0065\u006c\u006fn\u0067\u0073\u0020t\u006f\u0020\u0061\u0020n\u006f\u006e\u0020\u0063\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074");};return nil ,false ,_c .New ("\u0075\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0078\u0072\u0065\u0066 \u0074\u0079\u0070\u0065");};

// GetFilterName returns the name of the encoding filter.
func (_agad *DCTEncoder )GetFilterName ()string {return StreamEncodingFilterNameDCT };func (_fga *PdfParser )parseXrefStream (_cddf *PdfObjectInteger )(*PdfObjectDictionary ,error ){if _cddf !=nil {_fg .Log .Trace ("\u0058\u0052\u0065f\u0053\u0074\u006d\u0020x\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0061\u0074\u0020\u0025\u0064",_cddf );_fga ._cdfe .Seek (int64 (*_cddf ),_de .SeekStart );_fga ._daba =_eg .NewReader (_fga ._cdfe );};_fgca :=_fga .GetFileOffset ();_aabba ,_fegb :=_fga .ParseIndirectObject ();if _fegb !=nil {_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072\u0065\u0061d\u0020\u0078\u0072\u0065\u0066\u0020\u006fb\u006a\u0065\u0063\u0074");return nil ,_c .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072e\u0061\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062j\u0065\u0063\u0074");};_fg .Log .Trace ("\u0058R\u0065f\u0053\u0074\u006d\u0020\u006fb\u006a\u0065c\u0074\u003a\u0020\u0025\u0073",_aabba );_afab ,_cade :=_aabba .(*PdfObjectStream );if !_cade {_fg .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0058R\u0065\u0066\u0053\u0074\u006d\u0020\u0070o\u0069\u006e\u0074\u0069\u006e\u0067 \u0074\u006f\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065a\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0021");return nil ,_c .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0070\u006f\u0069\u006e\u0074i\u006e\u0067\u0020\u0074\u006f\u0020a\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006fb\u006a\u0065\u0063\u0074");};_gdfg :=_afab .PdfObjectDictionary ;_ffee ,_cade :=_afab .PdfObjectDictionary .Get ("\u0053\u0069\u007a\u0065").(*PdfObjectInteger );if !_cade {_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u004d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0073\u0069\u007a\u0065\u0020f\u0072\u006f\u006d\u0020\u0078\u0072\u0065f\u0020\u0073\u0074\u006d");return nil ,_c .New ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0053\u0069\u007ae\u0020\u0066\u0072\u006f\u006d\u0020\u0078\u0072\u0065\u0066 \u0073\u0074\u006d");};if int64 (*_ffee )> 8388607{_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u0053\u0069\u007a\u0065\u0020\u0065x\u0063\u0065\u0065\u0064\u0065\u0064\u0020l\u0069\u006d\u0069\u0074\u002c\u0020\u006f\u0076\u0065\u0072\u00208\u0033\u0038\u0038\u0036\u0030\u0037\u0020\u0028\u0025\u0064\u0029",*_ffee );return nil ,_c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_afgb :=_afab .PdfObjectDictionary .Get ("\u0057");_abbe ,_cade :=_afgb .(*PdfObjectArray );if !_cade {return nil ,_c .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0057\u0020\u0069\u006e\u0020x\u0072\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d");};_bdac :=_abbe .Len ();if _bdac !=3{_fg .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020\u0028\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033\u0020\u002d\u0020\u0025\u0064\u0029",_bdac );return nil ,_c .New ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065f\u0020s\u0074\u006d\u0020\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033");};var _gebe []int64 ;for _acga :=0;_acga < 3;_acga ++{_agbf ,_fcc :=GetInt (_abbe .Get (_acga ));if !_fcc {return nil ,_c .New ("i\u006e\u0076\u0061\u006cid\u0020w\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0074\u0079\u0070\u0065");};_gebe =append (_gebe ,int64 (*_agbf ));};_gdcec ,_fegb :=DecodeStream (_afab );if _fegb !=nil {_fg .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020t\u006f \u0064e\u0063o\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u003a\u0020\u0025\u0076",_fegb );return nil ,_fegb ;};_bfaga :=int (_gebe [0]);_ebfaa :=int (_gebe [0]+_gebe [1]);_dcgc :=int (_gebe [0]+_gebe [1]+_gebe [2]);_dgbc :=int (_gebe [0]+_gebe [1]+_gebe [2]);if _bfaga < 0||_ebfaa < 0||_dcgc < 0{_fg .Log .Debug ("\u0045\u0072\u0072\u006fr\u0020\u0073\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u003c \u0030 \u0028\u0025\u0064\u002c\u0025\u0064\u002c%\u0064\u0029",_bfaga ,_ebfaa ,_dcgc );return nil ,_c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};if _dgbc ==0{_fg .Log .Debug ("\u004e\u006f\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063t\u0073\u0020\u0069\u006e\u0020\u0073t\u0072\u0065\u0061\u006d\u0020\u0028\u0064\u0065\u006c\u0074\u0061\u0062\u0020=\u003d\u0020\u0030\u0029");return _gdfg ,nil ;};_ccdge :=len (_gdcec )/_dgbc ;_cdbgac :=0;_fbea :=_afab .PdfObjectDictionary .Get ("\u0049\u006e\u0064e\u0078");var _cebdd []int ;if _fbea !=nil {_fg .Log .Trace ("\u0049n\u0064\u0065\u0078\u003a\u0020\u0025b",_fbea );_bcae ,_gagf :=_fbea .(*PdfObjectArray );if !_gagf {_fg .Log .Debug ("\u0049\u006e\u0076\u0061\u006ci\u0064\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0029");return nil ,_c .New ("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0049\u006e\u0064e\u0078\u0020\u006f\u0062je\u0063\u0074");};if _bcae .Len ()%2!=0{_fg .Log .Debug ("\u0057\u0041\u0052\u004eI\u004e\u0047\u0020\u0046\u0061\u0069\u006c\u0075\u0072e\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020i\u006e\u0064\u0065\u0078\u0020n\u006f\u0074\u0020\u006d\u0075\u006c\u0074\u0069\u0070\u006c\u0065\u0020\u006f\u0066\u0020\u0032\u002e");return nil ,_c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_cdbgac =0;_gega ,_bbcd :=_bcae .ToIntegerArray ();if _bbcd !=nil {_fg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072 \u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0065\u0078 \u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0073\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0073\u003a\u0020\u0025\u0076",_bbcd );return nil ,_bbcd ;};for _ebcg :=0;_ebcg < len (_gega );_ebcg +=2{_dggfd :=_gega [_ebcg ];_aacf :=_gega [_ebcg +1];for _ffad :=0;_ffad < _aacf ;_ffad ++{_cebdd =append (_cebdd ,_dggfd +_ffad );};_cdbgac +=_aacf ;};}else {for _fede :=0;_fede < int (*_ffee );_fede ++{_cebdd =append (_cebdd ,_fede );};_cdbgac =int (*_ffee );};if _ccdge ==_cdbgac +1{_fg .Log .Debug ("\u0049n\u0063\u006f\u006d\u0070ati\u0062\u0069\u006c\u0069t\u0079\u003a\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006di\u0073\u0073\u0069\u006e\u0067\u0020\u0063\u006f\u0076\u0065\u0072\u0061\u0067\u0065\u0020\u006f\u0066\u0020\u0031\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u002d\u0020\u0061\u0070\u0070en\u0064\u0069\u006eg\u0020\u006f\u006e\u0065\u0020-\u0020M\u0061\u0079\u0020\u006c\u0065\u0061\u0064\u0020\u0074o\u0020\u0070\u0072\u006f\u0062\u006c\u0065\u006d\u0073");_aeaf :=_cdbgac -1;for _ ,_cfgd :=range _cebdd {if _cfgd > _aeaf {_aeaf =_cfgd ;};};_cebdd =append (_cebdd ,_aeaf +1);_cdbgac ++;};if _ccdge !=len (_cebdd ){_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020x\u0072\u0065\u0066 \u0073\u0074\u006d:\u0020\u006eu\u006d\u0020\u0065\u006e\u0074\u0072i\u0065s \u0021\u003d\u0020\u006c\u0065\u006e\u0028\u0069\u006e\u0064\u0069\u0063\u0065\u0073\u0029\u0020\u0028\u0025\u0064\u0020\u0021\u003d\u0020\u0025\u0064\u0029",_ccdge ,len (_cebdd ));return nil ,_c .New ("\u0078\u0072ef\u0020\u0073\u0074m\u0020\u006e\u0075\u006d en\u0074ri\u0065\u0073\u0020\u0021\u003d\u0020\u006cen\u0028\u0069\u006e\u0064\u0069\u0063\u0065s\u0029");};_fg .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074s\u0020\u0063\u006f\u0075\u006e\u0074\u0020\u0025\u0064",_cdbgac );_fg .Log .Trace ("\u0049\u006e\u0064i\u0063\u0065\u0073\u003a\u0020\u0025\u0020\u0064",_cebdd );_afdfd :=func (_bedce []byte )int64 {var _dcdf int64 ;for _bgfb :=0;_bgfb < len (_bedce );_bgfb ++{_dcdf +=int64 (_bedce [_bgfb ])*(1<<uint (8*(len (_bedce )-_bgfb -1)));};return _dcdf ;};_fg .Log .Trace ("\u0044e\u0063\u006f\u0064\u0065d\u0020\u0073\u0074\u0072\u0065a\u006d \u006ce\u006e\u0067\u0074\u0068\u003a\u0020\u0025d",len (_gdcec ));_bfdd :=0;for _ffbd :=0;_ffbd < len (_gdcec );_ffbd +=_dgbc {_ebcgb :=_gfab (len (_gdcec ),_ffbd ,_ffbd +_bfaga );if _ebcgb !=nil {_fg .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_ebcgb );return nil ,_ebcgb ;};_dgefa :=_gdcec [_ffbd :_ffbd +_bfaga ];_ebcgb =_gfab (len (_gdcec ),_ffbd +_bfaga ,_ffbd +_ebfaa );if _ebcgb !=nil {_fg .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_ebcgb );return nil ,_ebcgb ;};_gcdf :=_gdcec [_ffbd +_bfaga :_ffbd +_ebfaa ];_ebcgb =_gfab (len (_gdcec ),_ffbd +_ebfaa ,_ffbd +_dcgc );if _ebcgb !=nil {_fg .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_ebcgb );return nil ,_ebcgb ;};_efge :=_gdcec [_ffbd +_ebfaa :_ffbd +_dcgc ];_ebda :=_afdfd (_dgefa );_cbfc :=_afdfd (_gcdf );_fagfe :=_afdfd (_efge );if _gebe [0]==0{_ebda =1;};if _bfdd >=len (_cebdd ){_fg .Log .Debug ("X\u0052\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u002d\u0020\u0054\u0072\u0079\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0061\u0063\u0063e\u0073s\u0020\u0069\u006e\u0064e\u0078\u0020o\u0075\u0074\u0020\u006f\u0066\u0020\u0062\u006f\u0075\u006e\u0064\u0073\u0020\u002d\u0020\u0062\u0072\u0065\u0061\u006b\u0069\u006e\u0067");break ;};_aadd :=_cebdd [_bfdd ];_bfdd ++;_fg .Log .Trace ("%\u0064\u002e\u0020\u0070\u0031\u003a\u0020\u0025\u0020\u0078",_aadd ,_dgefa );_fg .Log .Trace ("%\u0064\u002e\u0020\u0070\u0032\u003a\u0020\u0025\u0020\u0078",_aadd ,_gcdf );_fg .Log .Trace ("%\u0064\u002e\u0020\u0070\u0033\u003a\u0020\u0025\u0020\u0078",_aadd ,_efge );_fg .Log .Trace ("\u0025d\u002e \u0078\u0072\u0065\u0066\u003a \u0025\u0064 \u0025\u0064\u0020\u0025\u0064",_aadd ,_ebda ,_cbfc ,_fagfe );if _ebda ==0{_fg .Log .Trace ("-\u0020\u0046\u0072\u0065\u0065\u0020o\u0062\u006a\u0065\u0063\u0074\u0020-\u0020\u0063\u0061\u006e\u0020\u0070\u0072o\u0062\u0061\u0062\u006c\u0079\u0020\u0069\u0067\u006e\u006fr\u0065");}else if _ebda ==1{_fg .Log .Trace ("\u002d\u0020I\u006e\u0020\u0075\u0073e\u0020\u002d \u0075\u006e\u0063\u006f\u006d\u0070\u0072\u0065s\u0073\u0065\u0064\u0020\u0076\u0069\u0061\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0062",_gcdf );if _cbfc ==_fgca {_fg .Log .Debug ("\u0055\u0070d\u0061\u0074\u0069\u006e\u0067\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0058\u0052\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0064",_aadd ,_afab .ObjectNumber );_aadd =int (_afab .ObjectNumber );};if _dcad ,_gcfdb :=_fga ._cgbgg .ObjectMap [_aadd ];!_gcfdb ||int (_fagfe )> _dcad .Generation {_feebc :=XrefObject {ObjectNumber :_aadd ,XType :XrefTypeTableEntry ,Offset :_cbfc ,Generation :int (_fagfe )};_fga ._cgbgg .ObjectMap [_aadd ]=_feebc ;};}else if _ebda ==2{_fg .Log .Trace ("\u002d\u0020\u0049\u006e \u0075\u0073\u0065\u0020\u002d\u0020\u0063\u006f\u006d\u0070r\u0065s\u0073\u0065\u0064\u0020\u006f\u0062\u006ae\u0063\u0074");if _ ,_dbd :=_fga ._cgbgg .ObjectMap [_aadd ];!_dbd {_ebgda :=XrefObject {ObjectNumber :_aadd ,XType :XrefTypeObjectStream ,OsObjNumber :int (_cbfc ),OsObjIndex :int (_fagfe )};_fga ._cgbgg .ObjectMap [_aadd ]=_ebgda ;_fg .Log .Trace ("\u0065\u006e\u0074\u0072\u0079\u003a\u0020\u0025\u002b\u0076",_ebgda );};}else {_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052:\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0056\u0041L\u0049\u0044\u0020\u0054\u0059\u0050\u0045\u0020\u0058\u0072\u0065\u0066\u0053\u0074\u006d\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u003f\u002d\u002d\u002d\u002d\u002d\u002d-");continue ;};};if _fga ._fagf ==nil {_fcfg :=XrefTypeObjectStream ;_fga ._fagf =&_fcfg ;};return _gdfg ,nil ;};func (_egf *FlateEncoder )postDecodePredict (_gcg []byte )([]byte ,error ){if _egf .Predictor > 1{if _egf .Predictor ==2{_fg .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_fg .Log .Trace ("\u0043\u006f\u006c\u006f\u0072\u0073\u003a\u0020\u0025\u0064",_egf .Colors );_beg :=_egf .Columns *_egf .Colors ;if _beg < 1{return []byte {},nil ;};_faa :=len (_gcg )/_beg ;if len (_gcg )%_beg !=0{_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");return nil ,_gc .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_gcg ),_beg );};if _beg %_egf .Colors !=0{return nil ,_gc .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_beg ,_egf .Colors );};if _beg > len (_gcg ){_fg .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_beg ,len (_gcg ));return nil ,_c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_fg .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_gcg ),_gcg );_daad :=_gcd .NewBuffer (nil );for _ceb :=0;_ceb < _faa ;_ceb ++{_eccd :=_gcg [_beg *_ceb :_beg *(_ceb +1)];for _ecfde :=_egf .Colors ;_ecfde < _beg ;_ecfde ++{_eccd [_ecfde ]+=_eccd [_ecfde -_egf .Colors ];};_daad .Write (_eccd );};_aec :=_daad .Bytes ();_fg .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_aec ),_aec );return _aec ,nil ;}else if _egf .Predictor >=10&&_egf .Predictor <=15{_fg .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_agcg :=_egf .Columns *_egf .Colors +1;_bggb :=len (_gcg )/_agcg ;if len (_gcg )%_agcg !=0{return nil ,_gc .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_gcg ),_agcg );};if _agcg > len (_gcg ){_fg .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_agcg ,len (_gcg ));return nil ,_c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_fadg :=_gcd .NewBuffer (nil );_fg .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_egf .Columns );_fg .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_gcg ),_agcg ,_bggb );_egg :=make ([]byte ,_agcg );for _ddf :=0;_ddf < _agcg ;_ddf ++{_egg [_ddf ]=0;};_gga :=_egf .Colors ;for _cdcd :=0;_cdcd < _bggb ;_cdcd ++{_gcge :=_gcg [_agcg *_cdcd :_agcg *(_cdcd +1)];_bdfeb :=_gcge [0];switch _bdfeb {case _adbd :case _daff :for _ggfd :=1+_gga ;_ggfd < _agcg ;_ggfd ++{_gcge [_ggfd ]+=_gcge [_ggfd -_gga ];};case _ecfa :for _eebe :=1;_eebe < _agcg ;_eebe ++{_gcge [_eebe ]+=_egg [_eebe ];};case _daaa :for _gffc :=1;_gffc < _gga +1;_gffc ++{_gcge [_gffc ]+=_egg [_gffc ]/2;};for _gedc :=_gga +1;_gedc < _agcg ;_gedc ++{_gcge [_gedc ]+=byte ((int (_gcge [_gedc -_gga ])+int (_egg [_gedc ]))/2);};case _dafa :for _dde :=1;_dde < _agcg ;_dde ++{var _ded ,_gfe ,_aced byte ;_gfe =_egg [_dde ];if _dde >=_gga +1{_ded =_gcge [_dde -_gga ];_aced =_egg [_dde -_gga ];};_gcge [_dde ]+=_becgc (_ded ,_gfe ,_aced );};default:_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029\u0020\u0040\u0072o\u0077\u0020\u0025\u0064",_bdfeb ,_cdcd );return nil ,_gc .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_bdfeb );};copy (_egg ,_gcge );_fadg .Write (_gcge [1:]);};_fdg :=_fadg .Bytes ();return _fdg ,nil ;}else {_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_egf .Predictor );return nil ,_gc .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_egf .Predictor );};};return _gcg ,nil ;};func (_dccc *FlateEncoder )cleanImageData (_bab []byte )([]byte ,error ){if _dccc ._aef ==nil {return _bab ,nil ;};if _dccc ._aef .BitsPerComponent >=8{return _bab ,nil ;};_dgb :=_dccc ._aef .BitsPerComponent *_dccc ._aef .Width *_dccc ._aef .ColorComponents *_dccc ._aef .Height /8;_bab =_bab [:_dgb ];var _gdfb error ;_bab ,_gdfb =_ee .AddDataPadding (_dccc ._aef .Width ,_dccc ._aef .Height ,_dccc ._aef .BitsPerComponent ,_dccc ._aef .ColorComponents ,_bab );if _gdfb !=nil {return nil ,_gdfb ;};return _bab ,nil ;};

// IsWhiteSpace checks if byte represents a white space character.
func IsWhiteSpace (ch byte )bool {if (ch ==0x00)||(ch ==0x09)||(ch ==0x0A)||(ch ==0x0C)||(ch ==0x0D)||(ch ==0x20){return true ;};return false ;};

// GetFilterName returns the name of the encoding filter.
func (_gcca *FlateEncoder )GetFilterName ()string {return StreamEncodingFilterNameFlate };

// GetString is a helper for Get that returns a string value.
// Returns false if the key is missing or a value is not a string.
func (_gbgd *PdfObjectDictionary )GetString (key PdfObjectName )(string ,bool ){_ecfdf ,_efgc :=_gbgd ._acacc [key ].(*PdfObjectString );if !_efgc {return "",false ;};return _ecfdf .Str (),true ;};func (_ebb *offsetReader )Seek (offset int64 ,whence int )(int64 ,error ){if whence ==_de .SeekStart {offset +=_ebb ._egcgd ;};_fgec ,_dgea :=_ebb ._eefca .Seek (offset ,whence );if _dgea !=nil {return _fgec ,_dgea ;};if whence ==_de .SeekCurrent {_fgec -=_ebb ._egcgd ;};if _fgec < 0{return 0,_c .New ("\u0063\u006f\u0072\u0065\u002eo\u0066\u0066\u0073\u0065\u0074\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053e\u0065\u006b\u003a\u0020\u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e");};return _fgec ,nil ;};

// RawEncoder implements Raw encoder/decoder (no encoding, pass through)
type RawEncoder struct{};

// String returns the PDF version as a string. Implements interface fmt.Stringer.
func (_cdgee Version )String ()string {return _gc .Sprintf ("\u00250\u0064\u002e\u0025\u0030\u0064",_cdgee .Major ,_cdgee .Minor );};var _eed =_a .MustCompile ("\u0028\u005c\u0064\u002b)\\\u0073\u002b\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u006f\u0062\u006a");

// NewCCITTFaxEncoder makes a new CCITTFax encoder.
func NewCCITTFaxEncoder ()*CCITTFaxEncoder {return &CCITTFaxEncoder {Columns :1728,EndOfBlock :true }};

// EncodeBytes JPX encodes the passed in slice of bytes.
func (_ggda *JPXEncoder )EncodeBytes (data []byte )([]byte ,error ){_fg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_ggda .GetFilterName ());return data ,ErrNoJPXDecode ;};

// StreamEncoder represents the interface for all PDF stream encoders.
type StreamEncoder interface{GetFilterName ()string ;MakeDecodeParams ()PdfObject ;MakeStreamDict ()*PdfObjectDictionary ;UpdateParams (_dge *PdfObjectDictionary );EncodeBytes (_ecg []byte )([]byte ,error );DecodeBytes (_dcc []byte )([]byte ,error );DecodeStream (_daea *PdfObjectStream )([]byte ,error );};

// MakeString creates an PdfObjectString from a string.
// NOTE: PDF does not use utf-8 string encoding like Go so `s` will often not be a utf-8 encoded
// string.
func MakeString (s string )*PdfObjectString {_gegg :=PdfObjectString {_abgc :s };return &_gegg };func (_egeaf *JBIG2Image )toBitmap ()(_cdgac *_gf .Bitmap ,_ecgc error ){const _cgbef ="\u004a\u0042\u0049\u00472I\u006d\u0061\u0067\u0065\u002e\u0074\u006f\u0042\u0069\u0074\u006d\u0061\u0070";if _egeaf .Data ==nil {return nil ,_ad .Error (_cgbef ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");};if _egeaf .Width ==0||_egeaf .Height ==0{return nil ,_ad .Error (_cgbef ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");};if _egeaf .HasPadding {_cdgac ,_ecgc =_gf .NewWithData (_egeaf .Width ,_egeaf .Height ,_egeaf .Data );}else {_cdgac ,_ecgc =_gf .NewWithUnpaddedData (_egeaf .Width ,_egeaf .Height ,_egeaf .Data );};if _ecgc !=nil {return nil ,_ad .Wrap (_ecgc ,_cgbef ,"");};return _cdgac ,nil ;};var _cfcb =_a .MustCompile ("\u005e\\\u0073\u002a\u005b\u002d]\u002a\u0028\u005c\u0064\u002b)\u005cs\u002b(\u005c\u0064\u002b\u0029\u005c\u0073\u002bR");

// PdfObjectStream represents the primitive PDF Object stream.
type PdfObjectStream struct{PdfObjectReference ;*PdfObjectDictionary ;Stream []byte ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_bgbc *FlateEncoder )MakeDecodeParams ()PdfObject {if _bgbc .Predictor > 1{_bfc :=MakeDict ();_bfc .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_bgbc .Predictor )));if _bgbc .BitsPerComponent !=8{_bfc .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_bgbc .BitsPerComponent )));};if _bgbc .Columns !=1{_bfc .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_bgbc .Columns )));};if _bgbc .Colors !=1{_bfc .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_bgbc .Colors )));};return _bfc ;};return nil ;};func (_efcb *PdfParser )parseHexString ()(*PdfObjectString ,error ){_efcb ._daba .ReadByte ();var _agcge _gcd .Buffer ;for {_egaf ,_cgbd :=_efcb ._daba .Peek (1);if _cgbd !=nil {return MakeString (""),_cgbd ;};if _egaf [0]=='>'{_efcb ._daba .ReadByte ();break ;};_gecc ,_ :=_efcb ._daba .ReadByte ();if !IsWhiteSpace (_gecc ){_agcge .WriteByte (_gecc );};};if _agcge .Len ()%2==1{_agcge .WriteRune ('0');};_aabf ,_ :=_fc .DecodeString (_agcge .String ());return MakeHexString (string (_aabf )),nil ;};var _cafb =_a .MustCompile ("\u005c\u0073\u002a\u0078\u0072\u0065\u0066\u005c\u0073\u002a");

// DecodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_cefg *RawEncoder )DecodeBytes (encoded []byte )([]byte ,error ){return encoded ,nil };

// DecodeStream implements ASCII85 stream decoding.
func (_edfbf *ASCII85Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _edfbf .DecodeBytes (streamObj .Stream );};

// TraceToDirectObject traces a PdfObject to a direct object.  For example direct objects contained
// in indirect objects (can be double referenced even).
func TraceToDirectObject (obj PdfObject )PdfObject {if _bbde ,_bcdea :=obj .(*PdfObjectReference );_bcdea {obj =_bbde .Resolve ();};_bgdc ,_fadeg :=obj .(*PdfIndirectObject );_bafb :=0;for _fadeg {obj =_bgdc .PdfObject ;_bgdc ,_fadeg =GetIndirect (obj );_bafb ++;if _bafb > _cffg {_fg .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0072\u0061\u0063\u0065\u0020\u0064\u0065p\u0074\u0068\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u0062\u0065\u0079\u006fn\u0064\u0020\u0025\u0064\u0020\u002d\u0020\u006e\u006f\u0074\u0020\u0067oi\u006e\u0067\u0020\u0064\u0065\u0065\u0070\u0065\u0072\u0021",_cffg );return nil ;};};return obj ;};

// PdfIndirectObject represents the primitive PDF indirect object.
type PdfIndirectObject struct{PdfObjectReference ;PdfObject ;};func (_beeb *PdfCrypt )encryptBytes (_adba []byte ,_bdfe string ,_dfgb []byte )([]byte ,error ){_fg .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");_ebfg ,_gadd :=_beeb ._dfb [_bdfe ];if !_gadd {return nil ,_gc .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_bdfe );};return _ebfg .EncryptBytes (_adba ,_dfgb );};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_eabf *ASCIIHexEncoder )MakeDecodeParams ()PdfObject {return nil };func (_fcab *ASCII85Encoder )base256Tobase85 (_gfce uint32 )[5]byte {_afac :=[5]byte {0,0,0,0,0};_bdgff :=_gfce ;for _daga :=0;_daga < 5;_daga ++{_acee :=uint32 (1);for _ffcd :=0;_ffcd < 4-_daga ;_ffcd ++{_acee *=85;};_bfgc :=_bdgff /_acee ;_bdgff =_bdgff %_acee ;_afac [_daga ]=byte (_bfgc );};return _afac ;};

// GetStringVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetStringVal (obj PdfObject )(_caae string ,_bdag bool ){_gfgfe ,_bdag :=TraceToDirectObject (obj ).(*PdfObjectString );if _bdag {return _gfgfe .Str (),true ;};return ;};func (_fefge *PdfParser )seekToEOFMarker (_ebbac int64 )error {var _dbfe int64 ;var _ecgb int64 =2048;for _dbfe < _ebbac -4{if _ebbac <=(_ecgb +_dbfe ){_ecgb =_ebbac -_dbfe ;};_ ,_becb :=_fefge ._cdfe .Seek (-_dbfe -_ecgb ,_de .SeekEnd );if _becb !=nil {return _becb ;};_effac :=make ([]byte ,_ecgb );_fefge ._cdfe .Read (_effac );_fg .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0045\u004f\u0046 \u006da\u0072\u006b\u0065\u0072\u003a\u0020\u0022%\u0073\u0022",string (_effac ));_fgcb :=_fcbd .FindAllStringIndex (string (_effac ),-1);if _fgcb !=nil {_debf :=_fgcb [len (_fgcb )-1];_fg .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_fgcb );_fefge ._cdfe .Seek (-_dbfe -_ecgb +int64 (_debf [0]),_de .SeekEnd );return nil ;};_fg .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");_dbfe +=_ecgb -4;};_fg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006be\u0072 \u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u002e");return _c .New ("\u0045\u004f\u0046\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};func (_ebed *PdfParser )parseNull ()(PdfObjectNull ,error ){_ ,_ffdf :=_ebed ._daba .Discard (4);return PdfObjectNull {},_ffdf ;};

// EncodeImage encodes 'img' golang image.Image into jbig2 encoded bytes document using default encoder settings.
func (_cbdd *JBIG2Encoder )EncodeImage (img _cg .Image )([]byte ,error ){return _cbdd .encodeImage (img )};

// DecodeStream decodes a JBIG2 encoded stream and returns the result as a slice of bytes.
func (_eefd *JBIG2Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _eefd .DecodeBytes (streamObj .Stream );};

// GetFilterName returns the name of the encoding filter.
func (_gefc *JBIG2Encoder )GetFilterName ()string {return StreamEncodingFilterNameJBIG2 };

// MakeArray creates an PdfObjectArray from a list of PdfObjects.
func MakeArray (objects ...PdfObject )*PdfObjectArray {return &PdfObjectArray {_bcea :objects }};

// MakeIndirectObject creates an PdfIndirectObject with a specified direct object PdfObject.
func MakeIndirectObject (obj PdfObject )*PdfIndirectObject {_afbad :=&PdfIndirectObject {};_afbad .PdfObject =obj ;return _afbad ;};

// ParseDict reads and parses a PDF dictionary object enclosed with '<<' and '>>'
func (_eaed *PdfParser )ParseDict ()(*PdfObjectDictionary ,error ){_fg .Log .Trace ("\u0052\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020D\u0069\u0063\u0074\u0021");_dead :=MakeDict ();_dead ._adcc =_eaed ;_dadaa ,_ :=_eaed ._daba .ReadByte ();if _dadaa !='<'{return nil ,_c .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");};_dadaa ,_ =_eaed ._daba .ReadByte ();if _dadaa !='<'{return nil ,_c .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");};for {_eaed .skipSpaces ();_eaed .skipComments ();_feeb ,_badf :=_eaed ._daba .Peek (2);if _badf !=nil {return nil ,_badf ;};_fg .Log .Trace ("D\u0069c\u0074\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_feeb ),string (_feeb ));if (_feeb [0]=='>')&&(_feeb [1]=='>'){_fg .Log .Trace ("\u0045\u004f\u0046\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");_eaed ._daba .ReadByte ();_eaed ._daba .ReadByte ();break ;};_fg .Log .Trace ("\u0050a\u0072s\u0065\u0020\u0074\u0068\u0065\u0020\u006e\u0061\u006d\u0065\u0021");_bdfc ,_badf :=_eaed .parseName ();_fg .Log .Trace ("\u004be\u0079\u003a\u0020\u0025\u0073",_bdfc );if _badf !=nil {_fg .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0052e\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006ea\u006d\u0065\u0020e\u0072r\u0020\u0025\u0073",_badf );return nil ,_badf ;};if len (_bdfc )> 4&&_bdfc [len (_bdfc )-4:]=="\u006e\u0075\u006c\u006c"{_bfedb :=_bdfc [0:len (_bdfc )-4];_fg .Log .Debug ("\u0054\u0061\u006b\u0069n\u0067\u0020\u0063\u0061\u0072\u0065\u0020\u006f\u0066\u0020n\u0075l\u006c\u0020\u0062\u0075\u0067\u0020\u0028%\u0073\u0029",_bdfc );_fg .Log .Debug ("\u004e\u0065\u0077\u0020ke\u0079\u0020\u0022\u0025\u0073\u0022\u0020\u003d\u0020\u006e\u0075\u006c\u006c",_bfedb );_eaed .skipSpaces ();_ebba ,_ :=_eaed ._daba .Peek (1);if _ebba [0]=='/'{_dead .Set (_bfedb ,MakeNull ());continue ;};};_eaed .skipSpaces ();_defdf ,_badf :=_eaed .parseObject ();if _badf !=nil {return nil ,_badf ;};_dead .Set (_bdfc ,_defdf );if _fg .Log .IsLogLevel (_fg .LogLevelTrace ){_fg .Log .Trace ("\u0064\u0069\u0063\u0074\u005b\u0025\u0073\u005d\u0020\u003d\u0020\u0025\u0073",_bdfc ,_defdf .String ());};};_fg .Log .Trace ("\u0072\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020\u0044\u0069\u0063\u0074\u0021");return _dead ,nil ;};

// LookupByReference looks up a PdfObject by a reference.
func (_dffa *PdfParser )LookupByReference (ref PdfObjectReference )(PdfObject ,error ){_fg .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0075\u0070\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0025\u0073",ref .String ());return _dffa .LookupByNumber (int (ref .ObjectNumber ));};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_dbf *DCTEncoder )MakeDecodeParams ()PdfObject {return nil };type objectCache map[int ]PdfObject ;func (_bgfc *PdfParser )xrefNextObjectOffset (_gdfba int64 )int64 {_ceed :=int64 (0);if len (_bgfc ._cgbgg .ObjectMap )==0{return 0;};if len (_bgfc ._cgbgg ._bd )==0{_ggee :=0;for _ ,_eaab :=range _bgfc ._cgbgg .ObjectMap {if _eaab .Offset > 0{_ggee ++;};};if _ggee ==0{return 0;};_bgfc ._cgbgg ._bd =make ([]XrefObject ,_ggee );_bcfa :=0;for _ ,_gcde :=range _bgfc ._cgbgg .ObjectMap {if _gcde .Offset > 0{_bgfc ._cgbgg ._bd [_bcfa ]=_gcde ;_bcfa ++;};};_b .Slice (_bgfc ._cgbgg ._bd ,func (_ceeb ,_feeba int )bool {return _bgfc ._cgbgg ._bd [_ceeb ].Offset < _bgfc ._cgbgg ._bd [_feeba ].Offset });};_fgeg :=_b .Search (len (_bgfc ._cgbgg ._bd ),func (_afag int )bool {return _bgfc ._cgbgg ._bd [_afag ].Offset >=_gdfba });if _fgeg < len (_bgfc ._cgbgg ._bd ){_ceed =_bgfc ._cgbgg ._bd [_fgeg ].Offset ;};return _ceed ;};

// DecodeStream decodes a multi-encoded stream by passing it through the
// DecodeStream method of the underlying encoders.
func (_beaae *MultiEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _beaae .DecodeBytes (streamObj .Stream );};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_aeba *MultiEncoder )MakeDecodeParams ()PdfObject {if len (_aeba ._gba )==0{return nil ;};if len (_aeba ._gba )==1{return _aeba ._gba [0].MakeDecodeParams ();};_edgg :=MakeArray ();for _ ,_dfcc :=range _aeba ._gba {_ccag :=_dfcc .MakeDecodeParams ();if _ccag ==nil {_edgg .Append (MakeNull ());}else {_edgg .Append (_ccag );};};return _edgg ;};

// CCITTFaxEncoder implements Group3 and Group4 facsimile (fax) encoder/decoder.
type CCITTFaxEncoder struct{K int ;EndOfLine bool ;EncodedByteAlign bool ;Columns int ;Rows int ;EndOfBlock bool ;BlackIs1 bool ;DamagedRowsBeforeError int ;};const _efg =32<<(^uint (0)>>63);var (ErrUnsupportedEncodingParameters =_c .New ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074\u0065\u0072\u0073");ErrNoCCITTFaxDecode =_c .New ("\u0043\u0043I\u0054\u0054\u0046\u0061\u0078\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");ErrNoJBIG2Decode =_c .New ("\u004a\u0042\u0049\u0047\u0032\u0044\u0065c\u006f\u0064\u0065 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");ErrNoJPXDecode =_c .New ("\u004a\u0050\u0058\u0044\u0065c\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020i\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");ErrNoPdfVersion =_c .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");ErrTypeError =_c .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");ErrRangeError =_c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");ErrNotSupported =_gad .New ("\u0066\u0065\u0061t\u0075\u0072\u0065\u0020n\u006f\u0074\u0020\u0063\u0075\u0072\u0072e\u006e\u0074\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");ErrNotANumber =_c .New ("\u006e\u006f\u0074 \u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072"););

// SetFileOffset sets the file to an offset position and resets buffer.
func (_bddc *PdfParser )SetFileOffset (offset int64 ){if offset < 0{offset =0;};_bddc ._cdfe .Seek (offset ,_de .SeekStart );_bddc ._daba =_eg .NewReader (_bddc ._cdfe );};

// UpdateParams updates the parameter values of the encoder.
func (_eegg *RawEncoder )UpdateParams (params *PdfObjectDictionary ){};

// IsFloatDigit checks if a character can be a part of a float number string.
func IsFloatDigit (c byte )bool {return ('0'<=c &&c <='9')||c =='.'};func _dc (_cba PdfObject )(int64 ,int64 ,error ){if _bgeb ,_fff :=_cba .(*PdfIndirectObject );_fff {return _bgeb .ObjectNumber ,_bgeb .GenerationNumber ,nil ;};if _cgg ,_cdc :=_cba .(*PdfObjectStream );_cdc {return _cgg .ObjectNumber ,_cgg .GenerationNumber ,nil ;};return 0,0,_c .New ("\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u002f\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062je\u0063\u0074");};func _bcdfg (_ebga _de .ReadSeeker ,_bacb int64 )(*offsetReader ,error ){_beea :=&offsetReader {_eefca :_ebga ,_egcgd :_bacb };_ ,_bedgc :=_beea .Seek (0,_de .SeekStart );return _beea ,_bedgc ;};func (_fbcae *PdfParser )traceStreamLength (_deed PdfObject )(PdfObject ,error ){_bdegc ,_gefe :=_deed .(*PdfObjectReference );if _gefe {_eaec ,_bebg :=_fbcae ._bcaa [_bdegc .ObjectNumber ];if _bebg &&_eaec {_fg .Log .Debug ("\u0053t\u0072\u0065a\u006d\u0020\u004c\u0065n\u0067\u0074\u0068 \u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065 u\u006e\u0072\u0065s\u006f\u006cv\u0065\u0064\u0020\u0028\u0069\u006cl\u0065\u0067a\u006c\u0029");return nil ,_c .New ("\u0069\u006c\u006c\u0065ga\u006c\u0020\u0072\u0065\u0063\u0075\u0072\u0073\u0069\u0076\u0065\u0020\u006c\u006fo\u0070");};_fbcae ._bcaa [_bdegc .ObjectNumber ]=true ;};_gaca ,_cgbc :=_fbcae .Resolve (_deed );if _cgbc !=nil {return nil ,_cgbc ;};_fg .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_gaca );if _gefe {_fbcae ._bcaa [_bdegc .ObjectNumber ]=false ;};return _gaca ,nil ;};func (_bggf *PdfParser )parseXrefTable ()(*PdfObjectDictionary ,error ){var _bddd *PdfObjectDictionary ;_deecf ,_aedf :=_bggf .readTextLine ();if _aedf !=nil {return nil ,_aedf ;};_fg .Log .Trace ("\u0078\u0072\u0065\u0066 f\u0069\u0072\u0073\u0074\u0020\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_deecf );_cdebf :=-1;_ebeb :=0;_bfbf :=false ;_ebdb :="";for {_bggf .skipSpaces ();_ ,_aege :=_bggf ._daba .Peek (1);if _aege !=nil {return nil ,_aege ;};_deecf ,_aege =_bggf .readTextLine ();if _aege !=nil {return nil ,_aege ;};_eaae :=_faag .FindStringSubmatch (_deecf );if len (_eaae )==0{_ecga :=len (_ebdb )> 0;_ebdb +=_deecf +"\u000a";if _ecga {_eaae =_faag .FindStringSubmatch (_ebdb );};};if len (_eaae )==3{_aabc ,_ :=_e .Atoi (_eaae [1]);_abge ,_ :=_e .Atoi (_eaae [2]);_cdebf =_aabc ;_ebeb =_abge ;_bfbf =true ;_ebdb ="";_fg .Log .Trace ("\u0078r\u0065\u0066 \u0073\u0075\u0062s\u0065\u0063\u0074\u0069\u006f\u006e\u003a \u0066\u0069\u0072\u0073\u0074\u0020o\u0062\u006a\u0065\u0063\u0074\u003a\u0020\u0025\u0064\u0020\u006fb\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_cdebf ,_ebeb );continue ;};_gcbd :=_bbf .FindStringSubmatch (_deecf );if len (_gcbd )==4{if !_bfbf {_fg .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0058r\u0065\u0066\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u006fr\u006da\u0074\u0021\u000a");return nil ,_c .New ("\u0078\u0072\u0065\u0066 i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072\u006d\u0061\u0074");};_fba ,_ :=_e .ParseInt (_gcbd [1],10,64);_dfee ,_ :=_e .Atoi (_gcbd [2]);_bfcb :=_gcbd [3];_ebdb ="";if _afa .ToLower (_bfcb )=="\u006e"&&_fba > 1{_fdeag ,_afgg :=_bggf ._cgbgg .ObjectMap [_cdebf ];if !_afgg ||_dfee > _fdeag .Generation {_bfae :=XrefObject {ObjectNumber :_cdebf ,XType :XrefTypeTableEntry ,Offset :_fba ,Generation :_dfee };_bggf ._cgbgg .ObjectMap [_cdebf ]=_bfae ;};};_cdebf ++;continue ;};if (len (_deecf )> 6)&&(_deecf [:7]=="\u0074r\u0061\u0069\u006c\u0065\u0072"){_fg .Log .Trace ("\u0046o\u0075n\u0064\u0020\u0074\u0072\u0061i\u006c\u0065r\u0020\u002d\u0020\u0025\u0073",_deecf );if len (_deecf )> 9{_cfea :=_bggf .GetFileOffset ();_bggf .SetFileOffset (_cfea -int64 (len (_deecf ))+7);};_bggf .skipSpaces ();_bggf .skipComments ();_fg .Log .Trace ("R\u0065\u0061\u0064\u0069ng\u0020t\u0072\u0061\u0069\u006c\u0065r\u0020\u0064\u0069\u0063\u0074\u0021");_fg .Log .Trace ("\u0070\u0065\u0065\u006b\u003a\u0020\u0022\u0025\u0073\u0022",_deecf );_bddd ,_aege =_bggf .ParseDict ();_fg .Log .Trace ("\u0045O\u0046\u0020\u0072\u0065a\u0064\u0069\u006e\u0067\u0020t\u0072a\u0069l\u0065\u0072\u0020\u0064\u0069\u0063\u0074!");if _aege !=nil {_fg .Log .Debug ("\u0045\u0072\u0072o\u0072\u0020\u0070\u0061r\u0073\u0069\u006e\u0067\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u0064\u0069\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_aege );return nil ,_aege ;};break ;};if _deecf =="\u0025\u0025\u0045O\u0046"{_fg .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006e\u0064 \u006f\u0066\u0020\u0066\u0069\u006c\u0065 -\u0020\u0074\u0072\u0061i\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066ou\u006e\u0064 \u002d\u0020\u0065\u0072\u0072\u006f\u0072\u0021");return nil ,_c .New ("\u0065\u006e\u0064 \u006f\u0066\u0020\u0066i\u006c\u0065\u0020\u002d\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};_fg .Log .Trace ("\u0078\u0072\u0065\u0066\u0020\u006d\u006f\u0072\u0065 \u003a\u0020\u0025\u0073",_deecf );};_fg .Log .Trace ("\u0045\u004f\u0046 p\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0021");if _bggf ._fagf ==nil {_eebfe :=XrefTypeTableEntry ;_bggf ._fagf =&_eebfe ;};return _bddd ,nil ;};

// SetImage sets the image base for given flate encoder.
func (_ebgd *FlateEncoder )SetImage (img *_ee .ImageBase ){_ebgd ._aef =img };

// EncodeJBIG2Image encodes 'img' into jbig2 encoded bytes stream, using default encoder settings.
func (_dggd *JBIG2Encoder )EncodeJBIG2Image (img *JBIG2Image )([]byte ,error ){const _egfe ="c\u006f\u0072\u0065\u002eEn\u0063o\u0064\u0065\u004a\u0042\u0049G\u0032\u0049\u006d\u0061\u0067\u0065";if _dgda :=_dggd .AddPageImage (img ,&_dggd .DefaultPageSettings );_dgda !=nil {return nil ,_ad .Wrap (_dgda ,_egfe ,"");};return _dggd .Encode ();};func _ccdd (_eeecd *PdfObjectStream ,_ceff *PdfObjectDictionary )(*JBIG2Encoder ,error ){const _affe ="\u006ee\u0077\u004a\u0042\u0049G\u0032\u0044\u0065\u0063\u006fd\u0065r\u0046r\u006f\u006d\u0053\u0074\u0072\u0065\u0061m";_gbfd :=&JBIG2Encoder {};_eccb :=_eeecd .PdfObjectDictionary ;if _eccb ==nil {return _gbfd ,nil ;};if _ceff ==nil {_eafb :=_eccb .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _eafb !=nil {switch _fbcd :=_eafb .(type ){case *PdfObjectDictionary :_ceff =_fbcd ;case *PdfObjectArray :if _fbcd .Len ()==1{if _gfcbe ,_ddec :=GetDict (_fbcd .Get (0));_ddec {_ceff =_gfcbe ;};};default:_fg .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065P\u0061\u0072\u0061\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064i\u0063\u0074\u0069\u006f\u006e\u0061\u0072y\u0020\u0025\u0023\u0076",_eafb );return nil ,_ad .Errorf (_affe ,"\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050a\u0072m\u0073\u0020\u0074\u0079\u0070\u0065\u003a \u0025\u0054",_fbcd );};};};if _ceff ==nil {return _gbfd ,nil ;};_gbfd .UpdateParams (_ceff );_fgcd :=_ceff .Get ("\u004a\u0042\u0049G\u0032\u0047\u006c\u006f\u0062\u0061\u006c\u0073");if _fgcd ==nil {return _gbfd ,nil ;};var _bfag error ;_eece ,_gfeae :=_fgcd .(*PdfObjectStream );if !_gfeae {_bfag =_ad .Error (_affe ,"j\u0062\u0069\u0067\u0032\u002e\u0047\u006c\u006f\u0062a\u006c\u0073\u0020\u0073\u0074\u0072\u0065am\u0020\u0073\u0068\u006fu\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u006e\u0020Ob\u006a\u0065c\u0074\u0020\u0053\u0074\u0072\u0065\u0061\u006d");_fg .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_bfag );return nil ,_bfag ;};_gbfd .Globals ,_bfag =_bf .DecodeGlobals (_eece .Stream );if _bfag !=nil {_bfag =_ad .Wrap (_bfag ,_affe ,"\u0063\u006f\u0072\u0072u\u0070\u0074\u0065\u0064\u0020\u006a\u0062\u0069\u0067\u0032 \u0065n\u0063\u006f\u0064\u0065\u0064\u0020\u0064a\u0074\u0061");_fg .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_bfag );return nil ,_bfag ;};return _gbfd ,nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_gccf *CCITTFaxEncoder )UpdateParams (params *PdfObjectDictionary ){if _bedg ,_dgeg :=GetNumberAsInt64 (params .Get ("\u004b"));_dgeg ==nil {_gccf .K =int (_bedg );};if _gddd ,_cacef :=GetNumberAsInt64 (params .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));_cacef ==nil {_gccf .Columns =int (_gddd );}else if _gddd ,_cacef =GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));_cacef ==nil {_gccf .Columns =int (_gddd );};if _dbc ,_egae :=GetNumberAsInt64 (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_egae ==nil {_gccf .BlackIs1 =_dbc > 0;}else {if _bccf ,_ecdf :=GetBoolVal (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_ecdf {_gccf .BlackIs1 =_bccf ;}else {if _afgc ,_cgfd :=GetArray (params .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));_cgfd {_cbdfe ,_cagf :=_afgc .ToIntegerArray ();if _cagf ==nil {_gccf .BlackIs1 =_cbdfe [0]==1&&_cbdfe [1]==0;};};};};if _debd ,_ffg :=GetNumberAsInt64 (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_ffg ==nil {_gccf .EncodedByteAlign =_debd > 0;}else {if _ecdfd ,_bfge :=GetBoolVal (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_bfge {_gccf .EncodedByteAlign =_ecdfd ;};};if _cefe ,_fdd :=GetNumberAsInt64 (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_fdd ==nil {_gccf .EndOfLine =_cefe > 0;}else {if _gdea ,_cdgc :=GetBoolVal (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_cdgc {_gccf .EndOfLine =_gdea ;};};if _bbdd ,_ccfc :=GetNumberAsInt64 (params .Get ("\u0052\u006f\u0077\u0073"));_ccfc ==nil {_gccf .Rows =int (_bbdd );}else if _bbdd ,_ccfc =GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));_ccfc ==nil {_gccf .Rows =int (_bbdd );};if _ggg ,_bfbcc :=GetNumberAsInt64 (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_bfbcc ==nil {_gccf .EndOfBlock =_ggg > 0;}else {if _ffa ,_fdgf :=GetBoolVal (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_fdgf {_gccf .EndOfBlock =_ffa ;};};if _ffga ,_cbgd :=GetNumberAsInt64 (params .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));_cbgd !=nil {_gccf .DamagedRowsBeforeError =int (_ffga );};};

// UpdateParams updates the parameter values of the encoder.
// Implements StreamEncoder interface.
func (_gecgg *JBIG2Encoder )UpdateParams (params *PdfObjectDictionary ){_fcece ,_ccad :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _ccad ==nil {_gecgg .BitsPerComponent =int (_fcece );};_cafd ,_ccad :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _ccad ==nil {_gecgg .Width =int (_cafd );};_abcd ,_ccad :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _ccad ==nil {_gecgg .Height =int (_abcd );};_aecc ,_ccad :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _ccad ==nil {_gecgg .ColorComponents =int (_aecc );};};var _cagb =[]PdfObjectName {"\u0056","\u0052","\u004f","\u0055","\u0050"};

// PdfObjectFloat represents the primitive PDF floating point numerical object.
type PdfObjectFloat float64 ;func _bgfcc (_bfcg int )int {if _bfcg < 0{return -_bfcg ;};return _bfcg ;};func (_ggdf *PdfParser )readTextLine ()(string ,error ){var _gfcc _gcd .Buffer ;for {_ecac ,_fdad :=_ggdf ._daba .Peek (1);if _fdad !=nil {_fg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_fdad .Error ());return _gfcc .String (),_fdad ;};if (_ecac [0]!='\r')&&(_ecac [0]!='\n'){_efeb ,_ :=_ggdf ._daba .ReadByte ();_gfcc .WriteByte (_efeb );}else {break ;};};return _gfcc .String (),nil ;};func _eaa (_gcaec string )(PdfObjectReference ,error ){_beeca :=PdfObjectReference {};_gadc :=_cfcb .FindStringSubmatch (_gcaec );if len (_gadc )< 3{_fg .Log .Debug ("\u0045\u0072\u0072or\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");return _beeca ,_c .New ("\u0075n\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061r\u0073e\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");};_babe ,_ :=_e .Atoi (_gadc [1]);_dcea ,_ :=_e .Atoi (_gadc [2]);_beeca .ObjectNumber =int64 (_babe );_beeca .GenerationNumber =int64 (_dcea );return _beeca ,nil ;};var _bbf =_a .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064+\u0029\u005c\u0073\u002b\u0028\u005b\u006e\u0066\u005d\u0029\\\u0073\u002a\u0024");

// ToFloat64Array returns a slice of all elements in the array as a float64 slice.  An error is
// returned if the array contains non-numeric objects (each element can be either PdfObjectInteger
// or PdfObjectFloat).
func (_fddc *PdfObjectArray )ToFloat64Array ()([]float64 ,error ){var _daaef []float64 ;for _ ,_dadgf :=range _fddc .Elements (){switch _ebdea :=_dadgf .(type ){case *PdfObjectInteger :_daaef =append (_daaef ,float64 (*_ebdea ));case *PdfObjectFloat :_daaef =append (_daaef ,float64 (*_ebdea ));default:return nil ,ErrTypeError ;};};return _daaef ,nil ;};

// NewFlateEncoder makes a new flate encoder with default parameters, predictor 1 and bits per component 8.
func NewFlateEncoder ()*FlateEncoder {_bfec :=&FlateEncoder {};_bfec .Predictor =1;_bfec .BitsPerComponent =8;_bfec .Colors =1;_bfec .Columns =1;return _bfec ;};func (_gecb *PdfParser )repairLocateXref ()(int64 ,error ){_agcc :=int64 (1000);_gecb ._cdfe .Seek (-_agcc ,_de .SeekCurrent );_gdfa ,_bgbb :=_gecb ._cdfe .Seek (0,_de .SeekCurrent );if _bgbb !=nil {return 0,_bgbb ;};_cfda :=make ([]byte ,_agcc );_gecb ._cdfe .Read (_cfda );_cfeg :=_fafg .FindAllStringIndex (string (_cfda ),-1);if len (_cfeg )< 1{_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0065\u0070a\u0069\u0072\u003a\u0020\u0078\u0072\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021");return 0,_c .New ("\u0072\u0065\u0070\u0061ir\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064");};_dda :=int64 (_cfeg [len (_cfeg )-1][0]);_dabd :=_gdfa +_dda ;return _dabd ,nil ;};

// DrawableImage is same as golang image/draw's Image interface that allow drawing images.
type DrawableImage interface{ColorModel ()_be .Model ;Bounds ()_cg .Rectangle ;At (_dgc ,_gcga int )_be .Color ;Set (_degb ,_cabd int ,_eggg _be .Color );};

// GetFilterName returns the name of the encoding filter.
func (_faeb *JPXEncoder )GetFilterName ()string {return StreamEncodingFilterNameJPX };

// Get returns the PdfObject corresponding to the specified key.
// Returns a nil value if the key is not set.
func (_feca *PdfObjectDictionary )Get (key PdfObjectName )PdfObject {_abdf ,_faada :=_feca ._acacc [key ];if !_faada {return nil ;};return _abdf ;};type offsetReader struct{_eefca _de .ReadSeeker ;_egcgd int64 ;};

// UpdateParams updates the parameter values of the encoder.
func (_gge *RunLengthEncoder )UpdateParams (params *PdfObjectDictionary ){};

// WriteString outputs the object as it is to be written to file.
func (_dafed *PdfObjectStreams )WriteString ()string {var _bgbcd _afa .Builder ;_bgbcd .WriteString (_e .FormatInt (_dafed .ObjectNumber ,10));_bgbcd .WriteString ("\u0020\u0030\u0020\u0052");return _bgbcd .String ();};

// MakeDict creates and returns an empty PdfObjectDictionary.
func MakeDict ()*PdfObjectDictionary {_bdddb :=&PdfObjectDictionary {};_bdddb ._acacc =map[PdfObjectName ]PdfObject {};_bdddb ._fgae =[]PdfObjectName {};return _bdddb ;};

// Inspect analyzes the document object structure. Returns a map of object types (by name) with the instance count
// as value.
func (_dffg *PdfParser )Inspect ()(map[string ]int ,error ){return _dffg .inspect ()};func (_eeaaaf *PdfParser )parsePdfVersion ()(int ,int ,error ){var _gbe int64 =20;_aac :=make ([]byte ,_gbe );_eeaaaf ._cdfe .Seek (0,_de .SeekStart );_eeaaaf ._cdfe .Read (_aac );var _fgbec error ;var _gcfd ,_gdcef int ;if _gaed :=_bbda .FindStringSubmatch (string (_aac ));len (_gaed )< 3{if _gcfd ,_gdcef ,_fgbec =_eeaaaf .seekPdfVersionTopDown ();_fgbec !=nil {_fg .Log .Debug ("F\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065\u0063\u006f\u0076\u0065\u0072\u0079\u0020\u002d\u0020\u0075n\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0066\u0069nd\u0020\u0076\u0065r\u0073i\u006f\u006e");return 0,0,_fgbec ;};_eeaaaf ._cdfe ,_fgbec =_bcdfg (_eeaaaf ._cdfe ,_eeaaaf .GetFileOffset ()-8);if _fgbec !=nil {return 0,0,_fgbec ;};}else {if _gcfd ,_fgbec =_e .Atoi (_gaed [1]);_fgbec !=nil {return 0,0,_fgbec ;};if _gdcef ,_fgbec =_e .Atoi (_gaed [2]);_fgbec !=nil {return 0,0,_fgbec ;};_eeaaaf .SetFileOffset (0);};_eeaaaf ._daba =_eg .NewReader (_eeaaaf ._cdfe );_fg .Log .Debug ("\u0050\u0064\u0066\u0020\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020%\u0064\u002e\u0025\u0064",_gcfd ,_gdcef );return _gcfd ,_gdcef ,nil ;};

// ParseNumber parses a numeric objects from a buffered stream.
// Section 7.3.3.
// Integer or Float.
//
// An integer shall be written as one or more decimal digits optionally
// preceded by a sign. The value shall be interpreted as a signed
// decimal integer and shall be converted to an integer object.
//
// A real value shall be written as one or more decimal digits with an
// optional sign and a leading, trailing, or embedded PERIOD (2Eh)
// (decimal point). The value shall be interpreted as a real number
// and shall be converted to a real object.
//
// Regarding exponential numbers: 7.3.3 Numeric Objects:
// A conforming writer shall not use the PostScript syntax for numbers
// with non-decimal radices (such as 16#FFFE) or in exponential format
// (such as 6.02E23).
// Nonetheless, we sometimes get numbers with exponential format, so
// we will support it in the reader (no confusion with other types, so
// no compromise).
func ParseNumber (buf *_eg .Reader )(PdfObject ,error ){_ebbg :=false ;_gedd :=true ;var _gdfag _gcd .Buffer ;for {if _fg .Log .IsLogLevel (_fg .LogLevelTrace ){_fg .Log .Trace ("\u0050\u0061\u0072\u0073in\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0022\u0025\u0073\u0022",_gdfag .String ());};_decga ,_aece :=buf .Peek (1);if _aece ==_de .EOF {break ;};if _aece !=nil {_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0025\u0073",_aece );return nil ,_aece ;};if _gedd &&(_decga [0]=='-'||_decga [0]=='+'){_agbeb ,_ :=buf .ReadByte ();_gdfag .WriteByte (_agbeb );_gedd =false ;}else if IsDecimalDigit (_decga [0]){_dgac ,_ :=buf .ReadByte ();_gdfag .WriteByte (_dgac );}else if _decga [0]=='.'{_fbgd ,_ :=buf .ReadByte ();_gdfag .WriteByte (_fbgd );_ebbg =true ;}else if _decga [0]=='e'||_decga [0]=='E'{_cgge ,_ :=buf .ReadByte ();_gdfag .WriteByte (_cgge );_ebbg =true ;_gedd =true ;}else {break ;};};var _efff PdfObject ;if _ebbg {_ccff ,_bbcgd :=_e .ParseFloat (_gdfag .String (),64);if _bbcgd !=nil {_fg .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0025v\u0020\u0065\u0072\u0072\u003d\u0025v\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0030\u002e\u0020\u004fu\u0074\u0070u\u0074\u0020\u006d\u0061y\u0020\u0062\u0065\u0020\u0069n\u0063\u006f\u0072\u0072\u0065\u0063\u0074",_gdfag .String (),_bbcgd );_ccff =0.0;};_gcee :=PdfObjectFloat (_ccff );_efff =&_gcee ;}else {_bgfe ,_cega :=_e .ParseInt (_gdfag .String (),10,64);if _cega !=nil {_fg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0025\u0076\u0020\u0065\u0072\u0072\u003d%\u0076\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074 \u006d\u0061\u0079\u0020\u0062\u0065 \u0069\u006ec\u006f\u0072r\u0065c\u0074",_gdfag .String (),_cega );_bgfe =0;};_cefdg :=PdfObjectInteger (_bgfe );_efff =&_cefdg ;};return _efff ,nil ;};func (_ffdb *PdfCrypt )decryptBytes (_beaa []byte ,_dbe string ,_fcf []byte )([]byte ,error ){_fg .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");_dcba ,_dgg :=_ffdb ._dfb [_dbe ];if !_dgg {return nil ,_gc .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_dbe );};return _dcba .DecryptBytes (_beaa ,_fcf );};func _bfe (_da *_dfg .StdEncryptDict ,_efca *PdfObjectDictionary )error {R ,_ebf :=_efca .Get ("\u0052").(*PdfObjectInteger );if !_ebf {return _c .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0052");};if *R < 2||*R > 6{return _gc .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0052 \u0028\u0025\u0064\u0029",*R );};_da .R =int (*R );O ,_ebf :=_efca .GetString ("\u004f");if !_ebf {return _c .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u004f");};if _da .R ==5||_da .R ==6{if len (O )< 48{return _gc .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u004f\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (O ));};}else if len (O )!=32{return _gc .Errorf ("L\u0065n\u0067\u0074\u0068\u0028\u004f\u0029\u0020\u0021=\u0020\u0033\u0032\u0020(%\u0064\u0029",len (O ));};_da .O =[]byte (O );U ,_ebf :=_efca .GetString ("\u0055");if !_ebf {return _c .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0055");};if _da .R ==5||_da .R ==6{if len (U )< 48{return _gc .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u0055\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (U ));};}else if len (U )!=32{_fg .Log .Debug ("\u0057\u0061r\u006e\u0069\u006e\u0067\u003a\u0020\u004c\u0065\u006e\u0067\u0074\u0068\u0028\u0055\u0029\u0020\u0021\u003d\u0020\u0033\u0032\u0020(%\u0064\u0029",len (U ));};_da .U =[]byte (U );if _da .R >=5{OE ,_gbg :=_efca .GetString ("\u004f\u0045");if !_gbg {return _c .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u004f\u0045");}else if len (OE )!=32{return _gc .Errorf ("L\u0065\u006e\u0067\u0074h(\u004fE\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (OE ));};_da .OE =[]byte (OE );UE ,_gbg :=_efca .GetString ("\u0055\u0045");if !_gbg {return _c .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u0055\u0045");}else if len (UE )!=32{return _gc .Errorf ("L\u0065\u006e\u0067\u0074h(\u0055E\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (UE ));};_da .UE =[]byte (UE );};P ,_ebf :=_efca .Get ("\u0050").(*PdfObjectInteger );if !_ebf {return _c .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074 \u0064\u0069\u0063t\u0069\u006f\u006e\u0061r\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0070\u0065\u0072\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0061\u0074\u0074\u0072");};_da .P =_dfg .Permissions (*P );if _da .R ==6{Perms ,_dfa :=_efca .GetString ("\u0050\u0065\u0072m\u0073");if !_dfa {return _c .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0050\u0065\u0072\u006d\u0073");}else if len (Perms )!=16{return _gc .Errorf ("\u004ce\u006e\u0067\u0074\u0068\u0028\u0050\u0065\u0072\u006d\u0073\u0029 \u0021\u003d\u0020\u0031\u0036\u0020\u0028\u0025\u0064\u0029",len (Perms ));};_da .Perms =[]byte (Perms );};if _beed ,_afe :=_efca .Get ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061").(*PdfObjectBool );_afe {_da .EncryptMetadata =bool (*_beed );}else {_da .EncryptMetadata =true ;};return nil ;};

// String returns a string describing `null`.
func (_eabdg *PdfObjectNull )String ()string {return "\u006e\u0075\u006c\u006c"};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_cffb *RawEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};func _becgc (_deeb ,_afdf ,_fdcce uint8 )uint8 {_dgadc :=int (_fdcce );_fgbe :=int (_afdf )-_dgadc ;_cdbga :=int (_deeb )-_dgadc ;_dgadc =_abfg (_fgbe +_cdbga );_fgbe =_abfg (_fgbe );_cdbga =_abfg (_cdbga );if _fgbe <=_cdbga &&_fgbe <=_dgadc {return _deeb ;}else if _cdbga <=_dgadc {return _afdf ;};return _fdcce ;};

// DecodeStream decodes a JPX encoded stream and returns the result as a
// slice of bytes.
func (_gdafd *JPXEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_fg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_gdafd .GetFilterName ());return streamObj .Stream ,ErrNoJPXDecode ;};const (StreamEncodingFilterNameFlate ="F\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameLZW ="\u004cZ\u0057\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameDCT ="\u0044C\u0054\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameRunLength ="\u0052u\u006eL\u0065\u006e\u0067\u0074\u0068\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameASCIIHex ="\u0041\u0053\u0043\u0049\u0049\u0048\u0065\u0078\u0044e\u0063\u006f\u0064\u0065";StreamEncodingFilterNameASCII85 ="\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameCCITTFax ="\u0043\u0043\u0049\u0054\u0054\u0046\u0061\u0078\u0044e\u0063\u006f\u0064\u0065";StreamEncodingFilterNameJBIG2 ="J\u0042\u0049\u0047\u0032\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameJPX ="\u004aP\u0058\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameRaw ="\u0052\u0061\u0077";);

// GetBool returns the *PdfObjectBool object that is represented by a PdfObject directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetBool (obj PdfObject )(_ffcg *PdfObjectBool ,_aebf bool ){_ffcg ,_aebf =TraceToDirectObject (obj ).(*PdfObjectBool );return _ffcg ,_aebf ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_dfbf *FlateEncoder )MakeStreamDict ()*PdfObjectDictionary {_fgg :=MakeDict ();_fgg .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_dfbf .GetFilterName ()));_gbbf :=_dfbf .MakeDecodeParams ();if _gbbf !=nil {_fgg .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_gbbf );};return _fgg ;};

// WriteString outputs the object as it is to be written to file.
func (_gefeg *PdfObjectArray )WriteString ()string {var _cfca _afa .Builder ;_cfca .WriteString ("\u005b");for _bebb ,_fbcb :=range _gefeg .Elements (){_cfca .WriteString (_fbcb .WriteString ());if _bebb < (_gefeg .Len ()-1){_cfca .WriteString ("\u0020");};};_cfca .WriteString ("\u005d");return _cfca .String ();};

// GetFileOffset returns the current file offset, accounting for buffered position.
func (_gcfb *PdfParser )GetFileOffset ()int64 {_fffc ,_ :=_gcfb ._cdfe .Seek (0,_de .SeekCurrent );_fffc -=int64 (_gcfb ._daba .Buffered ());return _fffc ;};

// DecodeBytes decodes byte array with ASCII85. 5 ASCII characters -> 4 raw binary bytes
func (_dffea *ASCII85Encoder )DecodeBytes (encoded []byte )([]byte ,error ){var _abbc []byte ;_fg .Log .Trace ("\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0020\u0044e\u0063\u006f\u0064\u0065");_fdge :=0;_beab :=false ;for _fdge < len (encoded )&&!_beab {_dab :=[5]byte {0,0,0,0,0};_daed :=0;_fdgb :=0;_abbf :=4;for _fdgb < 5+_daed {if _fdge +_fdgb ==len (encoded ){break ;};_ddeg :=encoded [_fdge +_fdgb ];if IsWhiteSpace (_ddeg ){_daed ++;_fdgb ++;continue ;}else if _ddeg =='~'&&_fdge +_fdgb +1< len (encoded )&&encoded [_fdge +_fdgb +1]=='>'{_abbf =(_fdgb -_daed )-1;if _abbf < 0{_abbf =0;};_beab =true ;break ;}else if _ddeg >='!'&&_ddeg <='u'{_ddeg -='!';}else if _ddeg =='z'&&_fdgb -_daed ==0{_abbf =4;_fdgb ++;break ;}else {_fg .Log .Error ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u002c\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020co\u0064\u0065");return nil ,_c .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0063\u006f\u0064\u0065\u0020e\u006e\u0063\u006f\u0075\u006e\u0074\u0065\u0072\u0065\u0064");};_dab [_fdgb -_daed ]=_ddeg ;_fdgb ++;};_fdge +=_fdgb ;for _fbe :=_abbf +1;_fbe < 5;_fbe ++{_dab [_fbe ]=84;};_beae :=uint32 (_dab [0])*85*85*85*85+uint32 (_dab [1])*85*85*85+uint32 (_dab [2])*85*85+uint32 (_dab [3])*85+uint32 (_dab [4]);_dgdb :=[]byte {byte ((_beae >>24)&0xff),byte ((_beae >>16)&0xff),byte ((_beae >>8)&0xff),byte (_beae &0xff)};_abbc =append (_abbc ,_dgdb [:_abbf ]...);};_fg .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0065\u006e\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",encoded );_fg .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0064\u0065\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",_abbc );return _abbc ,nil ;};

// DecodeBytes decodes a multi-encoded slice of bytes by passing it through the
// DecodeBytes method of the underlying encoders.
func (_dfed *MultiEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_ddbe :=encoded ;var _adcg error ;for _ ,_cgff :=range _dfed ._gba {_fg .Log .Trace ("\u004du\u006c\u0074i\u0020\u0045\u006e\u0063o\u0064\u0065\u0072 \u0044\u0065\u0063\u006f\u0064\u0065\u003a\u0020\u0041pp\u006c\u0079\u0069n\u0067\u0020F\u0069\u006c\u0074\u0065\u0072\u003a \u0025\u0076 \u0025\u0054",_cgff ,_cgff );_ddbe ,_adcg =_cgff .DecodeBytes (_ddbe );if _adcg !=nil {return nil ,_adcg ;};};return _ddbe ,nil ;};

// Set sets the PdfObject at index i of the array. An error is returned if the index is outside bounds.
func (_dfgae *PdfObjectArray )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_dfgae ._bcea ){return _c .New ("\u006f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_dfgae ._bcea [i ]=obj ;return nil ;};

// EncodeBytes DCT encodes the passed in slice of bytes.
func (_dcfe *DCTEncoder )EncodeBytes (data []byte )([]byte ,error ){_efe ,_fge :=_ee .NewImage (_dcfe .Width ,_dcfe .Height ,_dcfe .BitsPerComponent ,_dcfe .ColorComponents ,data ,nil ,nil );if _fge !=nil {return nil ,_fge ;};_dgef :=_af .Options {};_dgef .Quality =_dcfe .Quality ;var _gdc _gcd .Buffer ;if _fge =_af .Encode (&_gdc ,_efe ,&_dgef );_fge !=nil {return nil ,_fge ;};return _gdc .Bytes (),nil ;};

// PdfObjectReference represents the primitive PDF reference object.
type PdfObjectReference struct{_dgcf *PdfParser ;ObjectNumber int64 ;GenerationNumber int64 ;};

// UpdateParams updates the parameter values of the encoder.
func (_afbb *ASCII85Encoder )UpdateParams (params *PdfObjectDictionary ){};func _bdgf (_egb XrefTable ){_fg .Log .Debug ("\u003dX\u003d\u0058\u003d\u0058\u003d");_fg .Log .Debug ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");_gee :=0;for _ ,_fgb :=range _egb .ObjectMap {_fg .Log .Debug ("i\u002b\u0031\u003a\u0020\u0025\u0064 \u0028\u006f\u0062\u006a\u0020\u006eu\u006d\u003a\u0020\u0025\u0064\u0020\u0067e\u006e\u003a\u0020\u0025\u0064\u0029\u0020\u002d\u003e\u0020%\u0064",_gee +1,_fgb .ObjectNumber ,_fgb .Generation ,_fgb .Offset );_gee ++;};};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_eggf *CCITTFaxEncoder )MakeStreamDict ()*PdfObjectDictionary {_eeff :=MakeDict ();_eeff .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_eggf .GetFilterName ()));_agfc :=_eggf .MakeDecodeParams ();if _agfc !=nil {_eeff .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_agfc );};return _eeff ;};

// GetFilterArray returns the names of the underlying encoding filters in an array that
// can be used as /Filter entry.
func (_ffgd *MultiEncoder )GetFilterArray ()*PdfObjectArray {_agacd :=make ([]PdfObject ,len (_ffgd ._gba ));for _fffd ,_ddg :=range _ffgd ._gba {_agacd [_fffd ]=MakeName (_ddg .GetFilterName ());};return MakeArray (_agacd ...);};type objectStream struct{N int ;_eee []byte ;_dff map[int ]int64 ;};func (_ffb *PdfCrypt )newEncryptDict ()*PdfObjectDictionary {_cgga :=MakeDict ();_cgga .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName ("\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"));_cgga .Set ("\u0056",MakeInteger (int64 (_ffb ._age .V )));_cgga .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_ffb ._age .Length )));return _cgga ;};func (_gcc *PdfCrypt )loadCryptFilters (_cff *PdfObjectDictionary )error {_gcc ._dfb =cryptFilters {};_cgf :=_cff .Get ("\u0043\u0046");_cgf =TraceToDirectObject (_cgf );if _fb ,_ace :=_cgf .(*PdfObjectReference );_ace {_dfgf ,_afc :=_gcc ._afaf .LookupByReference (*_fb );if _afc !=nil {_fg .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0075\u0070\u0020\u0043\u0046\u0020\u0072\u0065\u0066\u0065\u0072en\u0063\u0065");return _afc ;};_cgf =TraceToDirectObject (_dfgf );};_fde ,_dec :=_cgf .(*PdfObjectDictionary );if !_dec {_fg .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0043\u0046\u002c \u0074\u0079\u0070\u0065: \u0025\u0054",_cgf );return _c .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0043\u0046");};for _ ,_fgbd :=range _fde .Keys (){_adeg :=_fde .Get (_fgbd );if _cbaa ,_ffe :=_adeg .(*PdfObjectReference );_ffe {_abc ,_fea :=_gcc ._afaf .LookupByReference (*_cbaa );if _fea !=nil {_fg .Log .Debug ("\u0045\u0072ro\u0072\u0020\u006co\u006f\u006b\u0075\u0070 up\u0020di\u0063\u0074\u0069\u006f\u006e\u0061\u0072y \u0072\u0065\u0066\u0065\u0072\u0065\u006ec\u0065");return _fea ;};_adeg =TraceToDirectObject (_abc );};_ccb ,_feb :=_adeg .(*PdfObjectDictionary );if !_feb {return _gc .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074\u0020\u0069\u006e \u0043\u0046\u0020\u0028\u006e\u0061\u006d\u0065\u0020\u0025\u0073\u0029\u0020-\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079\u0020\u0062\u0075\u0074\u0020\u0025\u0054",_fgbd ,_adeg );};if _fgbd =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u002d\u0020\u0043\u0061\u006e\u006e\u006f\u0074\u0020\u006f\u0076\u0065\u0072\u0077r\u0069\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0069d\u0065\u006e\u0074\u0069\u0074\u0079\u0020\u0066\u0069\u006c\u0074\u0065\u0072 \u002d\u0020\u0054\u0072\u0079\u0069n\u0067\u0020\u006ee\u0078\u0074");continue ;};var _bcgf _cd .FilterDict ;if _beb :=_fe (&_bcgf ,_ccb );_beb !=nil {return _beb ;};_ebe ,_dfea :=_cd .NewFilter (_bcgf );if _dfea !=nil {return _dfea ;};_gcc ._dfb [string (_fgbd )]=_ebe ;};_gcc ._dfb ["\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"]=_cd .NewIdentity ();_gcc ._fcb ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _fad ,_eba :=_cff .Get ("\u0053\u0074\u0072\u0046").(*PdfObjectName );_eba {if _ ,_gdec :=_gcc ._dfb [string (*_fad )];!_gdec {return _gc .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u0072\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_fad );};_gcc ._fcb =string (*_fad );};_gcc ._gca ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _gfb ,_db :=_cff .Get ("\u0053\u0074\u006d\u0046").(*PdfObjectName );_db {if _ ,_ageb :=_gcc ._dfb [string (*_gfb )];!_ageb {return _gc .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u006d\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_gfb );};_gcc ._gca =string (*_gfb );};return nil ;};

// GetFloat returns the *PdfObjectFloat represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetFloat (obj PdfObject )(_fefd *PdfObjectFloat ,_ecge bool ){_fefd ,_ecge =TraceToDirectObject (obj ).(*PdfObjectFloat );return _fefd ,_ecge ;};

// GetBoolVal returns the bool value within a *PdObjectBool represented by an PdfObject interface directly or indirectly.
// If the PdfObject does not represent a bool value, a default value of false is returned (found = false also).
func GetBoolVal (obj PdfObject )(_adece bool ,_gecgb bool ){_dccb ,_gecgb :=TraceToDirectObject (obj ).(*PdfObjectBool );if _gecgb {return bool (*_dccb ),true ;};return false ,false ;};

// Get returns the i-th element of the array or nil if out of bounds (by index).
func (_egagf *PdfObjectArray )Get (i int )PdfObject {if _egagf ==nil ||i >=len (_egagf ._bcea )||i < 0{return nil ;};return _egagf ._bcea [i ];};

// MakeHexString creates an PdfObjectString from a string intended for output as a hexadecimal string.
func MakeHexString (s string )*PdfObjectString {_bfacd :=PdfObjectString {_abgc :s ,_eade :true };return &_bfacd ;};

// DecodeBytes decodes a slice of DCT encoded bytes and returns the result.
func (_cae *DCTEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_bff :=_gcd .NewReader (encoded );_dea ,_ada :=_af .Decode (_bff );if _ada !=nil {_fg .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006eg\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_ada );return nil ,_ada ;};_cbe :=_dea .Bounds ();var _bfeb =make ([]byte ,_cbe .Dx ()*_cbe .Dy ()*_cae .ColorComponents *_cae .BitsPerComponent /8);_bdgb :=0;for _deae :=_cbe .Min .Y ;_deae < _cbe .Max .Y ;_deae ++{for _dgga :=_cbe .Min .X ;_dgga < _cbe .Max .X ;_dgga ++{_afcc :=_dea .At (_dgga ,_deae );if _cae .ColorComponents ==1{if _cae .BitsPerComponent ==16{_dffca ,_cdcg :=_afcc .(_be .Gray16 );if !_cdcg {return nil ,_c .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_bfeb [_bdgb ]=byte ((_dffca .Y >>8)&0xff);_bdgb ++;_bfeb [_bdgb ]=byte (_dffca .Y &0xff);_bdgb ++;}else {_fgcc ,_gcgc :=_afcc .(_be .Gray );if !_gcgc {return nil ,_c .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_bfeb [_bdgb ]=_fgcc .Y &0xff;_bdgb ++;};}else if _cae .ColorComponents ==3{if _cae .BitsPerComponent ==16{_egcg ,_gfea :=_afcc .(_be .RGBA64 );if !_gfea {return nil ,_c .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_bfeb [_bdgb ]=byte ((_egcg .R >>8)&0xff);_bdgb ++;_bfeb [_bdgb ]=byte (_egcg .R &0xff);_bdgb ++;_bfeb [_bdgb ]=byte ((_egcg .G >>8)&0xff);_bdgb ++;_bfeb [_bdgb ]=byte (_egcg .G &0xff);_bdgb ++;_bfeb [_bdgb ]=byte ((_egcg .B >>8)&0xff);_bdgb ++;_bfeb [_bdgb ]=byte (_egcg .B &0xff);_bdgb ++;}else {_gdeca ,_bfba :=_afcc .(_be .RGBA );if _bfba {_bfeb [_bdgb ]=_gdeca .R &0xff;_bdgb ++;_bfeb [_bdgb ]=_gdeca .G &0xff;_bdgb ++;_bfeb [_bdgb ]=_gdeca .B &0xff;_bdgb ++;}else {_aaeb ,_agfb :=_afcc .(_be .YCbCr );if !_agfb {return nil ,_c .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_adbdg ,_deea ,_dba ,_ :=_aaeb .RGBA ();_bfeb [_bdgb ]=byte (_adbdg >>8);_bdgb ++;_bfeb [_bdgb ]=byte (_deea >>8);_bdgb ++;_bfeb [_bdgb ]=byte (_dba >>8);_bdgb ++;};};}else if _cae .ColorComponents ==4{_fdea ,_agg :=_afcc .(_be .CMYK );if !_agg {return nil ,_c .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_bfeb [_bdgb ]=255-_fdea .C &0xff;_bdgb ++;_bfeb [_bdgb ]=255-_fdea .M &0xff;_bdgb ++;_bfeb [_bdgb ]=255-_fdea .Y &0xff;_bdgb ++;_bfeb [_bdgb ]=255-_fdea .K &0xff;_bdgb ++;};};};return _bfeb ,nil ;};

// JBIG2CompressionType defines the enum compression type used by the JBIG2Encoder.
type JBIG2CompressionType int ;

// GetStringBytes is like GetStringVal except that it returns the string as a []byte.
// It is for convenience.
func GetStringBytes (obj PdfObject )(_fedf []byte ,_cdba bool ){_abffd ,_cdba :=TraceToDirectObject (obj ).(*PdfObjectString );if _cdba {return _abffd .Bytes (),true ;};return ;};func (_gfcd *PdfCrypt )generateParams (_gbf ,_fdec []byte )error {_fac :=_gfcd .securityHandler ();_bgg ,_cfec :=_fac .GenerateParams (&_gfcd ._cgc ,_fdec ,_gbf );if _cfec !=nil {return _cfec ;};_gfcd ._gbb =_bgg ;return nil ;};func (_afbed *PdfParser )parseObject ()(PdfObject ,error ){_fg .Log .Trace ("\u0052e\u0061d\u0020\u0064\u0069\u0072\u0065c\u0074\u0020o\u0062\u006a\u0065\u0063\u0074");_afbed .skipSpaces ();for {_bbeaf ,_bdbc :=_afbed ._daba .Peek (2);if _bdbc !=nil {if _bdbc !=_de .EOF ||len (_bbeaf )==0{return nil ,_bdbc ;};if len (_bbeaf )==1{_bbeaf =append (_bbeaf ,' ');};};_fg .Log .Trace ("\u0050e\u0065k\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u003a\u0020\u0025\u0073",string (_bbeaf ));if _bbeaf [0]=='/'{_baa ,_dfbg :=_afbed .parseName ();_fg .Log .Trace ("\u002d\u003e\u004ea\u006d\u0065\u003a\u0020\u0027\u0025\u0073\u0027",_baa );return &_baa ,_dfbg ;}else if _bbeaf [0]=='('{_fg .Log .Trace ("\u002d>\u0053\u0074\u0072\u0069\u006e\u0067!");_cdcgd ,_faba :=_afbed .parseString ();return _cdcgd ,_faba ;}else if _bbeaf [0]=='['{_fg .Log .Trace ("\u002d\u003e\u0041\u0072\u0072\u0061\u0079\u0021");_gbdc ,_feee :=_afbed .parseArray ();return _gbdc ,_feee ;}else if (_bbeaf [0]=='<')&&(_bbeaf [1]=='<'){_fg .Log .Trace ("\u002d>\u0044\u0069\u0063\u0074\u0021");_fgcdc ,_edbf :=_afbed .ParseDict ();return _fgcdc ,_edbf ;}else if _bbeaf [0]=='<'{_fg .Log .Trace ("\u002d\u003e\u0048\u0065\u0078\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0021");_ggdd ,_adec :=_afbed .parseHexString ();return _ggdd ,_adec ;}else if _bbeaf [0]=='%'{_afbed .readComment ();_afbed .skipSpaces ();}else {_fg .Log .Trace ("\u002d\u003eN\u0075\u006d\u0062e\u0072\u0020\u006f\u0072\u0020\u0072\u0065\u0066\u003f");_bbeaf ,_ =_afbed ._daba .Peek (15);_cbcf :=string (_bbeaf );_fg .Log .Trace ("\u0050\u0065\u0065k\u0020\u0073\u0074\u0072\u003a\u0020\u0025\u0073",_cbcf );if (len (_cbcf )> 3)&&(_cbcf [:4]=="\u006e\u0075\u006c\u006c"){_fdfd ,_gfcce :=_afbed .parseNull ();return &_fdfd ,_gfcce ;}else if (len (_cbcf )> 4)&&(_cbcf [:5]=="\u0066\u0061\u006cs\u0065"){_fbfd ,_fed :=_afbed .parseBool ();return &_fbfd ,_fed ;}else if (len (_cbcf )> 3)&&(_cbcf [:4]=="\u0074\u0072\u0075\u0065"){_ddea ,_egccg :=_afbed .parseBool ();return &_ddea ,_egccg ;};_dcdd :=_cfcb .FindStringSubmatch (_cbcf );if len (_dcdd )> 1{_bbeaf ,_ =_afbed ._daba .ReadBytes ('R');_fg .Log .Trace ("\u002d\u003e\u0020\u0021\u0052\u0065\u0066\u003a\u0020\u0027\u0025\u0073\u0027",string (_bbeaf [:]));_caggf ,_fged :=_eaa (string (_bbeaf ));_caggf ._dgcf =_afbed ;return &_caggf ,_fged ;};_fbde :=_agcd .FindStringSubmatch (_cbcf );if len (_fbde )> 1{_fg .Log .Trace ("\u002d\u003e\u0020\u004e\u0075\u006d\u0062\u0065\u0072\u0021");_bfdfg ,_eeed :=_afbed .parseNumber ();return _bfdfg ,_eeed ;};_fbde =_gedfe .FindStringSubmatch (_cbcf );if len (_fbde )> 1{_fg .Log .Trace ("\u002d\u003e\u0020\u0045xp\u006f\u006e\u0065\u006e\u0074\u0069\u0061\u006c\u0020\u004e\u0075\u006d\u0062\u0065r\u0021");_fg .Log .Trace ("\u0025\u0020\u0073",_fbde );_gfgc ,_agag :=_afbed .parseNumber ();return _gfgc ,_agag ;};_fg .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020U\u006e\u006b\u006e\u006f\u0077n\u0020(\u0070e\u0065\u006b\u0020\u0022\u0025\u0073\u0022)",_cbcf );return nil ,_c .New ("\u006f\u0062\u006a\u0065\u0063t\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020\u0075\u006e\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e");};};};

// MakeInteger creates a PdfObjectInteger from an int64.
func MakeInteger (val int64 )*PdfObjectInteger {_aaae :=PdfObjectInteger (val );return &_aaae };

// JPXEncoder implements JPX encoder/decoder (dummy, for now)
// FIXME: implement
type JPXEncoder struct{};func (_bfeg *PdfCrypt )authenticate (_fee []byte )(bool ,error ){_bfeg ._bddg =false ;_aee :=_bfeg .securityHandler ();_bbe ,_afda ,_bdc :=_aee .Authenticate (&_bfeg ._cgc ,_fee );if _bdc !=nil {return false ,_bdc ;}else if _afda ==0||len (_bbe )==0{return false ,nil ;};_bfeg ._bddg =true ;_bfeg ._gbb =_bbe ;return true ,nil ;};

// NewParserFromString is used for testing purposes.
func NewParserFromString (txt string )*PdfParser {_bgfbb :=_gcd .NewReader ([]byte (txt ));_aeda :=&PdfParser {ObjCache :objectCache {},_cdfe :_bgfbb ,_daba :_eg .NewReader (_bgfbb ),_eecde :int64 (len (txt )),_bcaa :map[int64 ]bool {}};_aeda ._cgbgg .ObjectMap =make (map[int ]XrefObject );return _aeda ;};func _gdf (_feab _cd .Filter ,_bbc _dfg .AuthEvent )*PdfObjectDictionary {if _bbc ==""{_bbc =_dfg .EventDocOpen ;};_ccc :=MakeDict ();_ccc .Set ("\u0054\u0079\u0070\u0065",MakeName ("C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"));_ccc .Set ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et",MakeName (string (_bbc )));_ccc .Set ("\u0043\u0046\u004d",MakeName (_feab .Name ()));_ccc .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_feab .KeyLength ())));return _ccc ;};

// GetNameVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetNameVal (obj PdfObject )(_ffeg string ,_bgga bool ){_fedd ,_bgga :=TraceToDirectObject (obj ).(*PdfObjectName );if _bgga {return string (*_fedd ),true ;};return ;};

// PdfObjectInteger represents the primitive PDF integer numerical object.
type PdfObjectInteger int64 ;

// MakeNull creates an PdfObjectNull.
func MakeNull ()*PdfObjectNull {_ddbef :=PdfObjectNull {};return &_ddbef };

// DecodeStream decodes a DCT encoded stream and returns the result as a
// slice of bytes.
func (_ebgg *DCTEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _ebgg .DecodeBytes (streamObj .Stream );};

// EncodeBytes encodes the image data using either Group3 or Group4 CCITT facsimile (fax) encoding.
// `data` is expected to be 1 color component, 1 byte per component.
func (_begb *CCITTFaxEncoder )EncodeBytes (data []byte )([]byte ,error ){var _gecd [][]byte ;for _fab :=0;_fab < len (data );_fab +=_begb .Columns {_edd :=make ([]byte ,_begb .Columns );_egbg :=0;for _ccdc :=0;_ccdc < _begb .Columns ;_ccdc ++{if data [_fab +_ccdc ]==255{_edd [_egbg ]=1;}else {_edd [_egbg ]=0;};_egbg ++;};_gecd =append (_gecd ,_edd );};_agcgc :=&_afd .Encoder {K :_begb .K ,Columns :_begb .Columns ,EndOfLine :_begb .EndOfLine ,EndOfBlock :_begb .EndOfBlock ,BlackIs1 :_begb .BlackIs1 ,DamagedRowsBeforeError :_begb .DamagedRowsBeforeError ,Rows :_begb .Rows ,EncodedByteAlign :_begb .EncodedByteAlign };return _agcgc .Encode (_gecd ),nil ;};func _bgb (_cef int )cryptFilters {return cryptFilters {_bfb :_cd .NewFilterV2 (_cef )}};type cryptFilters map[string ]_cd .Filter ;

// PdfObjectName represents the primitive PDF name object.
type PdfObjectName string ;

// DCTEncoder provides a DCT (JPG) encoding/decoding functionality for images.
type DCTEncoder struct{ColorComponents int ;BitsPerComponent int ;Width int ;Height int ;Quality int ;};

// NewRunLengthEncoder makes a new run length encoder
func NewRunLengthEncoder ()*RunLengthEncoder {return &RunLengthEncoder {}};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_aeaa *CCITTFaxEncoder )MakeDecodeParams ()PdfObject {_deb :=MakeDict ();_deb .Set ("\u004b",MakeInteger (int64 (_aeaa .K )));_deb .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_aeaa .Columns )));if _aeaa .BlackIs1 {_deb .Set ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031",MakeBool (_aeaa .BlackIs1 ));};if _aeaa .EncodedByteAlign {_deb .Set ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e",MakeBool (_aeaa .EncodedByteAlign ));};if _aeaa .EndOfLine &&_aeaa .K >=0{_deb .Set ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee",MakeBool (_aeaa .EndOfLine ));};if _aeaa .Rows !=0&&!_aeaa .EndOfBlock {_deb .Set ("\u0052\u006f\u0077\u0073",MakeInteger (int64 (_aeaa .Rows )));};if !_aeaa .EndOfBlock {_deb .Set ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b",MakeBool (_aeaa .EndOfBlock ));};if _aeaa .DamagedRowsBeforeError !=0{_deb .Set ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072",MakeInteger (int64 (_aeaa .DamagedRowsBeforeError )));};return _deb ;};

// MakeBool creates a PdfObjectBool from a bool value.
func MakeBool (val bool )*PdfObjectBool {_agab :=PdfObjectBool (val );return &_agab };

// Elements returns a slice of the PdfObject elements in the array.
func (_gace *PdfObjectArray )Elements ()[]PdfObject {if _gace ==nil {return nil ;};return _gace ._bcea ;};

// NewRawEncoder returns a new instace of RawEncoder.
func NewRawEncoder ()*RawEncoder {return &RawEncoder {}};

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_aed *FlateEncoder )EncodeBytes (data []byte )([]byte ,error ){if _aed .Predictor !=1&&_aed .Predictor !=11{_fg .Log .Debug ("E\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0046\u006c\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065r\u0020P\u0072\u0065\u0064\u0069c\u0074\u006fr\u0020\u003d\u0020\u0031\u002c\u0020\u0031\u0031\u0020\u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");return nil ,ErrUnsupportedEncodingParameters ;};if _aed .Predictor ==11{_gdad :=_aed .Columns ;_faad :=len (data )/_gdad ;if len (data )%_gdad !=0{_fg .Log .Error ("\u0049n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");return nil ,_c .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");};_efce :=_gcd .NewBuffer (nil );_agfa :=make ([]byte ,_gdad );for _aab :=0;_aab < _faad ;_aab ++{_aeg :=data [_gdad *_aab :_gdad *(_aab +1)];_agfa [0]=_aeg [0];for _gecg :=1;_gecg < _gdad ;_gecg ++{_agfa [_gecg ]=byte (int (_aeg [_gecg ]-_aeg [_gecg -1])%256);};_efce .WriteByte (1);_efce .Write (_agfa );};data =_efce .Bytes ();};var _gcae _gcd .Buffer ;_deg :=_d .NewWriter (&_gcae );_deg .Write (data );_deg .Close ();return _gcae .Bytes (),nil ;};

// String returns a string representation of `name`.
func (_agbdg *PdfObjectName )String ()string {return string (*_agbdg )};

// XrefObject defines a cross reference entry which is a map between object number (with generation number) and the
// location of the actual object, either as a file offset (xref table entry), or as a location within an xref
// stream object (xref object stream).
type XrefObject struct{XType xrefType ;ObjectNumber int ;Generation int ;

// For normal xrefs (defined by OFFSET)
Offset int64 ;

// For xrefs to object streams.
OsObjNumber int ;OsObjIndex int ;};

// String returns a string describing `ref`.
func (_cfbg *PdfObjectReference )String ()string {return _gc .Sprintf ("\u0052\u0065\u0066\u0028\u0025\u0064\u0020\u0025\u0064\u0029",_cfbg .ObjectNumber ,_cfbg .GenerationNumber );};

// EncodeStream encodes the stream data using the encoded specified by the stream's dictionary.
func EncodeStream (streamObj *PdfObjectStream )error {_fg .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_dabc ,_bddb :=NewEncoderFromStream (streamObj );if _bddb !=nil {_fg .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_bddb );return _bddb ;};if _gcgac ,_eaaa :=_dabc .(*LZWEncoder );_eaaa {_gcgac .EarlyChange =0;streamObj .PdfObjectDictionary .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (0));};_fg .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076\u000a",_dabc );_bdbfe ,_bddb :=_dabc .EncodeBytes (streamObj .Stream );if _bddb !=nil {_fg .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_bddb );return _bddb ;};streamObj .Stream =_bdbfe ;streamObj .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_bdbfe ))));return nil ;};

// FlateEncoder represents Flate encoding.
type FlateEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Rows int ;Colors int ;_aef *_ee .ImageBase ;};

// GetName returns the *PdfObjectName represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetName (obj PdfObject )(_baac *PdfObjectName ,_gefeb bool ){_baac ,_gefeb =TraceToDirectObject (obj ).(*PdfObjectName );return _baac ,_gefeb ;};

// JBIG2Image is the image structure used by the jbig2 encoder. Its Data must be in a
// 1 bit per component and 1 component per pixel (1bpp). In order to create binary image
// use GoImageToJBIG2 function. If the image data contains the row bytes padding set the HasPadding to true.
type JBIG2Image struct{

// Width and Height defines the image boundaries.
Width ,Height int ;

// Data is the byte slice data for the input image
Data []byte ;

// HasPadding is the attribute that defines if the last byte of the data in the row contains
// 0 bits padding.
HasPadding bool ;};func (_acgc *PdfParser )repairRebuildXrefsTopDown ()(*XrefTable ,error ){if _acgc ._gacd {return nil ,_gc .Errorf ("\u0072\u0065\u0070\u0061\u0069\u0072\u0020\u0066\u0061\u0069\u006c\u0065\u0064");};_acgc ._gacd =true ;_acgc ._cdfe .Seek (0,_de .SeekStart );_acgc ._daba =_eg .NewReader (_acgc ._cdfe );_aebbg :=20;_fdcgf :=make ([]byte ,_aebbg );_dbde :=XrefTable {};_dbde .ObjectMap =make (map[int ]XrefObject );for {_cgbcb ,_cged :=_acgc ._daba .ReadByte ();if _cged !=nil {if _cged ==_de .EOF {break ;}else {return nil ,_cged ;};};if _cgbcb =='j'&&_fdcgf [_aebbg -1]=='b'&&_fdcgf [_aebbg -2]=='o'&&IsWhiteSpace (_fdcgf [_aebbg -3]){_bfbgf :=_aebbg -4;for IsWhiteSpace (_fdcgf [_bfbgf ])&&_bfbgf > 0{_bfbgf --;};if _bfbgf ==0||!IsDecimalDigit (_fdcgf [_bfbgf ]){continue ;};for IsDecimalDigit (_fdcgf [_bfbgf ])&&_bfbgf > 0{_bfbgf --;};if _bfbgf ==0||!IsWhiteSpace (_fdcgf [_bfbgf ]){continue ;};for IsWhiteSpace (_fdcgf [_bfbgf ])&&_bfbgf > 0{_bfbgf --;};if _bfbgf ==0||!IsDecimalDigit (_fdcgf [_bfbgf ]){continue ;};for IsDecimalDigit (_fdcgf [_bfbgf ])&&_bfbgf > 0{_bfbgf --;};if _bfbgf ==0{continue ;};_bfgfe :=_acgc .GetFileOffset ()-int64 (_aebbg -_bfbgf );_eagb :=append (_fdcgf [_bfbgf +1:],_cgbcb );_gfde ,_gfee ,_bgbg :=_ddeb (string (_eagb ));if _bgbg !=nil {_fg .Log .Debug ("\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u006e\u0075\u006d\u0062\u0065r\u003a\u0020\u0025\u0076",_bgbg );return nil ,_bgbg ;};if _dceb ,_acbc :=_dbde .ObjectMap [_gfde ];!_acbc ||_dceb .Generation < _gfee {_gded :=XrefObject {};_gded .XType =XrefTypeTableEntry ;_gded .ObjectNumber =_gfde ;_gded .Generation =_gfee ;_gded .Offset =_bfgfe ;_dbde .ObjectMap [_gfde ]=_gded ;};};_fdcgf =append (_fdcgf [1:_aebbg ],_cgbcb );};_acgc ._dce =nil ;return &_dbde ,nil ;};

// Keys returns the list of keys in the dictionary.
// If `d` is nil returns a nil slice.
func (_dacb *PdfObjectDictionary )Keys ()[]PdfObjectName {if _dacb ==nil {return nil ;};return _dacb ._fgae ;};func _cbgc (_bebd *PdfObjectStream ,_gdd *PdfObjectDictionary )(*FlateEncoder ,error ){_aeb :=NewFlateEncoder ();_afdc :=_bebd .PdfObjectDictionary ;if _afdc ==nil {return _aeb ,nil ;};_aeb ._aef =_eebgb (_afdc );if _gdd ==nil {_edg :=TraceToDirectObject (_afdc .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));switch _gaga :=_edg .(type ){case *PdfObjectArray :if _gaga .Len ()!=1{_fg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072:\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020a\u0072\u0072\u0061\u0079\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0021\u003d\u0020\u0031\u0020\u0028\u0025\u0064\u0029",_gaga .Len ());return nil ,_c .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};if _fcd ,_gbdd :=GetDict (_gaga .Get (0));_gbdd {_gdd =_fcd ;};case *PdfObjectDictionary :_gdd =_gaga ;case *PdfObjectNull ,nil :default:_fg .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020n\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079 \u0028%\u0054\u0029",_edg );return nil ,_gc .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _gdd ==nil {return _aeb ,nil ;};_fg .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_gdd .String ());_gebg :=_gdd .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");if _gebg ==nil {_fg .Log .Debug ("E\u0072\u0072o\u0072\u003a\u0020\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067 \u0066\u0072\u006f\u006d\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073 \u002d\u0020\u0043\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020\u0077\u0069t\u0068\u0020\u0064\u0065\u0066\u0061\u0075\u006c\u0074\u0020\u00281\u0029");}else {_aeee ,_gfba :=_gebg .(*PdfObjectInteger );if !_gfba {_fg .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_gebg );return nil ,_gc .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_aeb .Predictor =int (*_aeee );};_gebg =_gdd .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");if _gebg !=nil {_accb ,_eea :=_gebg .(*PdfObjectInteger );if !_eea {_fg .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");return nil ,_gc .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_aeb .BitsPerComponent =int (*_accb );};if _aeb .Predictor > 1{_aeb .Columns =1;_gebg =_gdd .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");if _gebg !=nil {_aded ,_deff :=_gebg .(*PdfObjectInteger );if !_deff {return nil ,_gc .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_aeb .Columns =int (*_aded );};_aeb .Colors =1;_gebg =_gdd .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _gebg !=nil {_cgfe ,_bgec :=_gebg .(*PdfObjectInteger );if !_bgec {return nil ,_gc .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");};_aeb .Colors =int (*_cgfe );};};return _aeb ,nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_cfd *JBIG2Encoder )MakeStreamDict ()*PdfObjectDictionary {_gcdd :=MakeDict ();_gcdd .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_cfd .GetFilterName ()));return _gcdd ;};

// ReadBytesAt reads byte content at specific offset and length within the PDF.
func (_dbbe *PdfParser )ReadBytesAt (offset ,len int64 )([]byte ,error ){_eggc :=_dbbe .GetFileOffset ();_ ,_dffb :=_dbbe ._cdfe .Seek (offset ,_de .SeekStart );if _dffb !=nil {return nil ,_dffb ;};_gdbf :=make ([]byte ,len );_ ,_dffb =_de .ReadAtLeast (_dbbe ._cdfe ,_gdbf ,int (len ));if _dffb !=nil {return nil ,_dffb ;};_dbbe .SetFileOffset (_eggc );return _gdbf ,nil ;};

// WriteString outputs the object as it is to be written to file.
func (_fbcf *PdfIndirectObject )WriteString ()string {var _dced _afa .Builder ;_dced .WriteString (_e .FormatInt (_fbcf .ObjectNumber ,10));_dced .WriteString ("\u0020\u0030\u0020\u0052");return _dced .String ();};func _bde (_eeg *PdfObjectStream ,_cdbe *MultiEncoder )(*DCTEncoder ,error ){_cebb :=NewDCTEncoder ();_ecad :=_eeg .PdfObjectDictionary ;if _ecad ==nil {return _cebb ,nil ;};_dfga :=_eeg .Stream ;if _cdbe !=nil {_afea ,_efbg :=_cdbe .DecodeBytes (_dfga );if _efbg !=nil {return nil ,_efbg ;};_dfga =_afea ;};_gfg :=_gcd .NewReader (_dfga );_cdged ,_fcac :=_af .DecodeConfig (_gfg );if _fcac !=nil {_fg .Log .Debug ("\u0045\u0072\u0072or\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0065\u003a\u0020\u0025\u0073",_fcac );return nil ,_fcac ;};switch _cdged .ColorModel {case _be .RGBAModel :_cebb .BitsPerComponent =8;_cebb .ColorComponents =3;case _be .RGBA64Model :_cebb .BitsPerComponent =16;_cebb .ColorComponents =3;case _be .GrayModel :_cebb .BitsPerComponent =8;_cebb .ColorComponents =1;case _be .Gray16Model :_cebb .BitsPerComponent =16;_cebb .ColorComponents =1;case _be .CMYKModel :_cebb .BitsPerComponent =8;_cebb .ColorComponents =4;case _be .YCbCrModel :_cebb .BitsPerComponent =8;_cebb .ColorComponents =3;default:return nil ,_c .New ("\u0075\u006e\u0073up\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u006d\u006f\u0064\u0065\u006c");};_cebb .Width =_cdged .Width ;_cebb .Height =_cdged .Height ;_fg .Log .Trace ("\u0044\u0043T\u0020\u0045\u006ec\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076",_cebb );_cebb .Quality =DefaultJPEGQuality ;return _cebb ,nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_egc *FlateEncoder )UpdateParams (params *PdfObjectDictionary ){_afbe ,_bga :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _bga ==nil {_egc .Predictor =int (_afbe );};_bfg ,_bga :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _bga ==nil {_egc .BitsPerComponent =int (_bfg );};_gbd ,_bga :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _bga ==nil {_egc .Columns =int (_gbd );};_egd ,_bga :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _bga ==nil {_egc .Colors =int (_egd );};};const (JB2Generic JBIG2CompressionType =iota ;JB2SymbolCorrelation ;JB2SymbolRankHaus ;);

// DecodeBytes decodes a slice of JPX encoded bytes and returns the result.
func (_gfceb *JPXEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_fg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_gfceb .GetFilterName ());return encoded ,ErrNoJPXDecode ;};

// String returns a string describing `ind`.
func (_fgeef *PdfIndirectObject )String ()string {return _gc .Sprintf ("\u0049\u004f\u0062\u006a\u0065\u0063\u0074\u003a\u0025\u0064",(*_fgeef ).ObjectNumber );};

// GetAsFloat64Slice returns the array as []float64 slice.
// Returns an error if not entirely numeric (only PdfObjectIntegers, PdfObjectFloats).
func (_cabb *PdfObjectArray )GetAsFloat64Slice ()([]float64 ,error ){var _eecdc []float64 ;for _ ,_eeea :=range _cabb .Elements (){_dbfg ,_gfgfc :=GetNumberAsFloat (TraceToDirectObject (_eeea ));if _gfgfc !=nil {return nil ,_gc .Errorf ("\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006e\u0075m\u0062\u0065\u0072");};_eecdc =append (_eecdc ,_dbfg );};return _eecdc ,nil ;};func (_ddbc *JBIG2Encoder )encodeImage (_ccfce _cg .Image )([]byte ,error ){const _fdeb ="e\u006e\u0063\u006f\u0064\u0065\u0049\u006d\u0061\u0067\u0065";_bade ,_bdbf :=GoImageToJBIG2 (_ccfce ,JB2ImageAutoThreshold );if _bdbf !=nil {return nil ,_ad .Wrap (_bdbf ,_fdeb ,"\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069m\u0061g\u0065\u0020\u0074\u006f\u0020\u006a\u0062\u0069\u0067\u0032\u0020\u0069\u006d\u0067");};if _bdbf =_ddbc .AddPageImage (_bade ,&_ddbc .DefaultPageSettings );_bdbf !=nil {return nil ,_ad .Wrap (_bdbf ,_fdeb ,"");};return _ddbc .Encode ();};

// GetStream returns the *PdfObjectStream represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetStream (obj PdfObject )(_fgcg *PdfObjectStream ,_cdde bool ){obj =ResolveReference (obj );_fgcg ,_cdde =obj .(*PdfObjectStream );return _fgcg ,_cdde ;};func (_cbaac *PdfParser )seekPdfVersionTopDown ()(int ,int ,error ){_cbaac ._cdfe .Seek (0,_de .SeekStart );_cbaac ._daba =_eg .NewReader (_cbaac ._cdfe );_fdeca :=20;_edcg :=make ([]byte ,_fdeca );for {_bacc ,_dggdg :=_cbaac ._daba .ReadByte ();if _dggdg !=nil {if _dggdg ==_de .EOF {break ;}else {return 0,0,_dggdg ;};};if IsDecimalDigit (_bacc )&&_edcg [_fdeca -1]=='.'&&IsDecimalDigit (_edcg [_fdeca -2])&&_edcg [_fdeca -3]=='-'&&_edcg [_fdeca -4]=='F'&&_edcg [_fdeca -5]=='D'&&_edcg [_fdeca -6]=='P'{_fbfa :=int (_edcg [_fdeca -2]-'0');_ecbb :=int (_bacc -'0');return _fbfa ,_ecbb ,nil ;};_edcg =append (_edcg [1:_fdeca ],_bacc );};return 0,0,_c .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_gafa *LZWEncoder )MakeDecodeParams ()PdfObject {if _gafa .Predictor > 1{_cad :=MakeDict ();_cad .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_gafa .Predictor )));if _gafa .BitsPerComponent !=8{_cad .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_gafa .BitsPerComponent )));};if _gafa .Columns !=1{_cad .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_gafa .Columns )));};if _gafa .Colors !=1{_cad .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_gafa .Colors )));};return _cad ;};return nil ;};func (_daa *PdfCrypt )isDecrypted (_aaf PdfObject )bool {_ ,_abe :=_daa ._cc [_aaf ];if _abe {_fg .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0064\u0065\u0063\u0072y\u0070\u0074\u0065\u0064");return true ;};switch _egec :=_aaf .(type ){case *PdfObjectStream :if _daa ._cgc .R !=5{if _bcdf ,_bcf :=_egec .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_bcf &&*_bcdf =="\u0058\u0052\u0065\u0066"{return true ;};};case *PdfIndirectObject :if _ ,_abe =_daa ._cdbg [int (_egec .ObjectNumber )];_abe {return true ;};switch _ggd :=_egec .PdfObject .(type ){case *PdfObjectDictionary :_aca :=true ;for _ ,_daf :=range _cagb {if _ggd .Get (_daf )==nil {_aca =false ;break ;};};if _aca {return true ;};};};_fg .Log .Trace ("\u004e\u006f\u0074\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");return false ;};

// AddPageImage adds the page with the image 'img' to the encoder context in order to encode it jbig2 document.
// The 'settings' defines what encoding type should be used by the encoder.
func (_ffde *JBIG2Encoder )AddPageImage (img *JBIG2Image ,settings *JBIG2EncoderSettings )(_fcfbd error ){const _cgag ="\u004a\u0042\u0049\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0041\u0064\u0064\u0050\u0061\u0067\u0065\u0049m\u0061\u0067\u0065";if _ffde ==nil {return _ad .Error (_cgag ,"J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u0020\u0069\u0073 n\u0069\u006c");};if settings ==nil {settings =&_ffde .DefaultPageSettings ;};if _ffde ._gbae ==nil {_ffde ._gbae =_ca .InitEncodeDocument (settings .FileMode );};if _fcfbd =settings .Validate ();_fcfbd !=nil {return _ad .Wrap (_fcfbd ,_cgag ,"");};_bae ,_fcfbd :=img .toBitmap ();if _fcfbd !=nil {return _ad .Wrap (_fcfbd ,_cgag ,"");};switch settings .Compression {case JB2Generic :if _fcfbd =_ffde ._gbae .AddGenericPage (_bae ,settings .DuplicatedLinesRemoval );_fcfbd !=nil {return _ad .Wrap (_fcfbd ,_cgag ,"");};case JB2SymbolCorrelation :return _ad .Error (_cgag ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");case JB2SymbolRankHaus :return _ad .Error (_cgag ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");default:return _ad .Error (_cgag ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return nil ;};

// GetNumberAsFloat returns the contents of `obj` as a float if it is an integer or float, or an
// error if it isn't.
func GetNumberAsFloat (obj PdfObject )(float64 ,error ){switch _cefgd :=obj .(type ){case *PdfObjectFloat :return float64 (*_cefgd ),nil ;case *PdfObjectInteger :return float64 (*_cefgd ),nil ;};return 0,ErrNotANumber ;};

// String returns a string describing `streams`.
func (_cbee *PdfObjectStreams )String ()string {return _gc .Sprintf ("\u004f\u0062j\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0025\u0064",_cbee .ObjectNumber );};

// DecodeStream implements ASCII hex decoding.
func (_ecba *ASCIIHexEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _ecba .DecodeBytes (streamObj .Stream );};

// AddEncoder adds the passed in encoder to the underlying encoder slice.
func (_bfgd *MultiEncoder )AddEncoder (encoder StreamEncoder ){_bfgd ._gba =append (_bfgd ._gba ,encoder );};func _abfg (_dcce int )int {_ecbea :=_dcce >>(_efg -1);return (_dcce ^_ecbea )-_ecbea };

// Remove removes an element specified by key.
func (_fecgc *PdfObjectDictionary )Remove (key PdfObjectName ){_cggc :=-1;for _dcfc ,_faaea :=range _fecgc ._fgae {if _faaea ==key {_cggc =_dcfc ;break ;};};if _cggc >=0{_fecgc ._fgae =append (_fecgc ._fgae [:_cggc ],_fecgc ._fgae [_cggc +1:]...);delete (_fecgc ._acacc ,key );};};

// GetFilterName returns the name of the encoding filter.
func (_ecb *RunLengthEncoder )GetFilterName ()string {return StreamEncodingFilterNameRunLength };

// Elements returns a slice of the PdfObject elements in the array.
// Preferred over accessing the array directly as type may be changed in future major versions (v3).
func (_bcfae *PdfObjectStreams )Elements ()[]PdfObject {if _bcfae ==nil {return nil ;};return _bcfae ._gfcee ;};func _eda (_geba *_dfg .StdEncryptDict ,_bag *PdfObjectDictionary ){_bag .Set ("\u0052",MakeInteger (int64 (_geba .R )));_bag .Set ("\u0050",MakeInteger (int64 (_geba .P )));_bag .Set ("\u004f",MakeStringFromBytes (_geba .O ));_bag .Set ("\u0055",MakeStringFromBytes (_geba .U ));if _geba .R >=5{_bag .Set ("\u004f\u0045",MakeStringFromBytes (_geba .OE ));_bag .Set ("\u0055\u0045",MakeStringFromBytes (_geba .UE ));_bag .Set ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061",MakeBool (_geba .EncryptMetadata ));if _geba .R > 5{_bag .Set ("\u0050\u0065\u0072m\u0073",MakeStringFromBytes (_geba .Perms ));};};};

// PdfObject is an interface which all primitive PDF objects must implement.
type PdfObject interface{

// String outputs a string representation of the primitive (for debugging).
String ()string ;

// WriteString outputs the PDF primitive as written to file as expected by the standard.
// TODO(dennwc): it should return a byte slice, or accept a writer
WriteString ()string ;};func (_ae *PdfParser )lookupObjectViaOS (_cfe int ,_eb int )(PdfObject ,error ){var _fd *_gcd .Reader ;var _ac objectStream ;var _ag bool ;_ac ,_ag =_ae ._eaeg [_cfe ];if !_ag {_ege ,_bg :=_ae .LookupByNumber (_cfe );if _bg !=nil {_fg .Log .Debug ("\u004d\u0069ss\u0069\u006e\u0067 \u006f\u0062\u006a\u0065ct \u0073tr\u0065\u0061\u006d\u0020\u0077\u0069\u0074h \u006e\u0075\u006d\u0062\u0065\u0072\u0020%\u0064",_cfe );return nil ,_bg ;};_ec ,_ed :=_ege .(*PdfObjectStream );if !_ed {return nil ,_c .New ("i\u006e\u0076\u0061\u006cid\u0020o\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d");};if _ae ._abd !=nil &&!_ae ._abd .isDecrypted (_ec ){return nil ,_c .New ("\u006e\u0065\u0065\u0064\u0020\u0074\u006f\u0020\u0064\u0065\u0063r\u0079\u0070\u0074\u0020\u0074\u0068\u0065\u0020\u0073\u0074r\u0065\u0061\u006d");};_ecc :=_ec .PdfObjectDictionary ;_fg .Log .Trace ("\u0073o\u0020\u0064\u003a\u0020\u0025\u0073\n",_ecc .String ());_gff ,_ed :=_ecc .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if !_ed {_fg .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0061\u006c\u0077\u0061\u0079\u0073\u0020\u0068\u0061\u0076\u0065\u0020\u0061\u0020\u0054\u0079\u0070\u0065");return nil ,_c .New ("\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020T\u0079\u0070\u0065");};if _afa .ToLower (string (*_gff ))!="\u006f\u0062\u006a\u0073\u0074\u006d"{_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0074\u0079\u0070\u0065\u0020s\u0068\u0061\u006c\u006c\u0020\u0061\u006c\u0077\u0061\u0079\u0073 \u0062\u0065\u0020\u004f\u0062\u006a\u0053\u0074\u006d\u0020\u0021");return nil ,_c .New ("\u006f\u0062\u006a\u0065c\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0074y\u0070e\u0020\u0021\u003d\u0020\u004f\u0062\u006aS\u0074\u006d");};N ,_ed :=_ecc .Get ("\u004e").(*PdfObjectInteger );if !_ed {return nil ,_c .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u004e\u0020i\u006e\u0020\u0073\u0074\u0072\u0065\u0061m\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_gcdc ,_ed :=_ecc .Get ("\u0046\u0069\u0072s\u0074").(*PdfObjectInteger );if !_ed {return nil ,_c .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0046\u0069\u0072\u0073\u0074\u0020i\u006e \u0073t\u0072e\u0061\u006d\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_fg .Log .Trace ("\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0073\u0020\u006eu\u006d\u0062\u0065\u0072\u0020\u006f\u0066 \u006f\u0062\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_gff ,*N );_gcf ,_bg :=DecodeStream (_ec );if _bg !=nil {return nil ,_bg ;};_fg .Log .Trace ("D\u0065\u0063\u006f\u0064\u0065\u0064\u003a\u0020\u0025\u0073",_gcf );_cdf :=_ae .GetFileOffset ();defer func (){_ae .SetFileOffset (_cdf )}();_fd =_gcd .NewReader (_gcf );_ae ._daba =_eg .NewReader (_fd );_fg .Log .Trace ("\u0050a\u0072s\u0069\u006e\u0067\u0020\u006ff\u0066\u0073e\u0074\u0020\u006d\u0061\u0070");_bc :=map[int ]int64 {};for _ff :=0;_ff < int (*N );_ff ++{_ae .skipSpaces ();_bdg ,_cfeb :=_ae .parseNumber ();if _cfeb !=nil {return nil ,_cfeb ;};_fgd ,_ged :=_bdg .(*PdfObjectInteger );if !_ged {return nil ,_c .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");};_ae .skipSpaces ();_bdg ,_cfeb =_ae .parseNumber ();if _cfeb !=nil {return nil ,_cfeb ;};_adf ,_ged :=_bdg .(*PdfObjectInteger );if !_ged {return nil ,_c .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");};_fg .Log .Trace ("\u006f\u0062j\u0020\u0025\u0064 \u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0025\u0064",*_fgd ,*_adf );_bc [int (*_fgd )]=int64 (*_gcdc +*_adf );};_ac =objectStream {N :int (*N ),_eee :_gcf ,_dff :_bc };_ae ._eaeg [_cfe ]=_ac ;}else {_fca :=_ae .GetFileOffset ();defer func (){_ae .SetFileOffset (_fca )}();_fd =_gcd .NewReader (_ac ._eee );_ae ._daba =_eg .NewReader (_fd );};_ea :=_ac ._dff [_eb ];_fg .Log .Trace ("\u0041\u0043\u0054\u0055AL\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u005b\u0025\u0064\u005d\u0020\u003d\u0020%\u0064",_eb ,_ea );_fd .Seek (_ea ,_de .SeekStart );_ae ._daba =_eg .NewReader (_fd );_ce ,_ :=_ae ._daba .Peek (100);_fg .Log .Trace ("\u004f\u0042\u004a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_ce ));_fa ,_gce :=_ae .parseObject ();if _gce !=nil {_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c \u0074\u006f\u0020\u0072\u0065\u0061\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_gce );return nil ,_gce ;};if _fa ==nil {return nil ,_c .New ("o\u0062\u006a\u0065\u0063t \u0063a\u006e\u006e\u006f\u0074\u0020b\u0065\u0020\u006e\u0075\u006c\u006c");};_bge :=PdfIndirectObject {};_bge .ObjectNumber =int64 (_eb );_bge .PdfObject =_fa ;return &_bge ,nil ;};

// DecodeBytes decodes a slice of ASCII encoded bytes and returns the result.
func (_ccec *ASCIIHexEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_dffe :=_gcd .NewReader (encoded );var _bgcf []byte ;for {_eabd ,_agef :=_dffe .ReadByte ();if _agef !=nil {return nil ,_agef ;};if _eabd =='>'{break ;};if IsWhiteSpace (_eabd ){continue ;};if (_eabd >='a'&&_eabd <='f')||(_eabd >='A'&&_eabd <='F')||(_eabd >='0'&&_eabd <='9'){_bgcf =append (_bgcf ,_eabd );}else {_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0061\u0073\u0063\u0069\u0069 \u0068\u0065\u0078\u0020\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072 \u0028\u0025\u0063\u0029",_eabd );return nil ,_gc .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0061\u0073\u0063\u0069\u0069\u0020\u0068e\u0078 \u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u0020\u0028\u0025\u0063\u0029",_eabd );};};if len (_bgcf )%2==1{_bgcf =append (_bgcf ,'0');};_fg .Log .Trace ("\u0049\u006e\u0062\u006f\u0075\u006e\u0064\u0020\u0025\u0073",_bgcf );_gdbc :=make ([]byte ,_fc .DecodedLen (len (_bgcf )));_ ,_dggf :=_fc .Decode (_gdbc ,_bgcf );if _dggf !=nil {return nil ,_dggf ;};return _gdbc ,nil ;};

// IsDecimalDigit checks if the character is a part of a decimal number string.
func IsDecimalDigit (c byte )bool {return '0'<=c &&c <='9'};func _bdeg (_adag *PdfObjectStream )(*MultiEncoder ,error ){_gebgf :=NewMultiEncoder ();_dgaf :=_adag .PdfObjectDictionary ;if _dgaf ==nil {return _gebgf ,nil ;};var _fag *PdfObjectDictionary ;var _cbge []PdfObject ;_gdga :=_dgaf .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _gdga !=nil {_eefc ,_bggc :=_gdga .(*PdfObjectDictionary );if _bggc {_fag =_eefc ;};_geeg ,_acda :=_gdga .(*PdfObjectArray );if _acda {for _ ,_eeaa :=range _geeg .Elements (){_eeaa =TraceToDirectObject (_eeaa );if _gbcc ,_caf :=_eeaa .(*PdfObjectDictionary );_caf {_cbge =append (_cbge ,_gbcc );}else {_cbge =append (_cbge ,MakeDict ());};};};};_gdga =_dgaf .Get ("\u0046\u0069\u006c\u0074\u0065\u0072");if _gdga ==nil {return nil ,_gc .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u006d\u0069s\u0073\u0069\u006e\u0067");};_cbeb ,_fade :=_gdga .(*PdfObjectArray );if !_fade {return nil ,_gc .Errorf ("m\u0075\u006c\u0074\u0069\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0063\u0061\u006e\u0020\u006f\u006el\u0079\u0020\u0062\u0065\u0020\u006d\u0061\u0064\u0065\u0020fr\u006f\u006d\u0020a\u0072r\u0061\u0079");};for _edga ,_dega :=range _cbeb .Elements (){_dada ,_ece :=_dega .(*PdfObjectName );if !_ece {return nil ,_gc .Errorf ("\u006d\u0075l\u0074\u0069\u0020\u0066i\u006c\u0074e\u0072\u0020\u0061\u0072\u0072\u0061\u0079\u0020e\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u006e\u006f\u0074\u0020\u0061 \u006e\u0061\u006d\u0065");};var _afgf PdfObject ;if _fag !=nil {_afgf =_fag ;}else {if len (_cbge )> 0{if _edga >=len (_cbge ){return nil ,_gc .Errorf ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0073\u0020\u0069\u006e\u0020d\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006d\u0073\u0020a\u0072\u0072\u0061\u0079");};_afgf =_cbge [_edga ];};};var _dadb *PdfObjectDictionary ;if _eeaaa ,_feba :=_afgf .(*PdfObjectDictionary );_feba {_dadb =_eeaaa ;};_fg .Log .Trace ("\u004e\u0065\u0078t \u006e\u0061\u006d\u0065\u003a\u0020\u0025\u0073\u002c \u0064p\u003a \u0025v\u002c\u0020\u0064\u0050\u0061\u0072\u0061\u006d\u0073\u003a\u0020\u0025\u0076",*_dada ,_afgf ,_dadb );if *_dada ==StreamEncodingFilterNameFlate {_fadc ,_fddd :=_cbgc (_adag ,_dadb );if _fddd !=nil {return nil ,_fddd ;};_gebgf .AddEncoder (_fadc );}else if *_dada ==StreamEncodingFilterNameLZW {_ebcd ,_adbdd :=_ead (_adag ,_dadb );if _adbdd !=nil {return nil ,_adbdd ;};_gebgf .AddEncoder (_ebcd );}else if *_dada ==StreamEncodingFilterNameASCIIHex {_ceadd :=NewASCIIHexEncoder ();_gebgf .AddEncoder (_ceadd );}else if *_dada ==StreamEncodingFilterNameASCII85 {_cedd :=NewASCII85Encoder ();_gebgf .AddEncoder (_cedd );}else if *_dada ==StreamEncodingFilterNameDCT {_acba ,_dgf :=_bde (_adag ,_gebgf );if _dgf !=nil {return nil ,_dgf ;};_gebgf .AddEncoder (_acba );_fg .Log .Trace ("A\u0064d\u0065\u0064\u0020\u0044\u0043\u0054\u0020\u0065n\u0063\u006f\u0064\u0065r.\u002e\u002e");_fg .Log .Trace ("\u004du\u006ct\u0069\u0020\u0065\u006e\u0063o\u0064\u0065r\u003a\u0020\u0025\u0023\u0076",_gebgf );}else {_fg .Log .Error ("U\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0066\u0069l\u0074\u0065\u0072\u0020\u0025\u0073",*_dada );return nil ,_gc .Errorf ("\u0069\u006eva\u006c\u0069\u0064 \u0066\u0069\u006c\u0074er \u0069n \u006d\u0075\u006c\u0074\u0069\u0020\u0066il\u0074\u0065\u0072\u0020\u0061\u0072\u0072a\u0079");};};return _gebgf ,nil ;};

// String returns a string describing `array`.
func (_geca *PdfObjectArray )String ()string {_ecdg :="\u005b";for _cbbg ,_dfafe :=range _geca .Elements (){_ecdg +=_dfafe .String ();if _cbbg < (_geca .Len ()-1){_ecdg +="\u002c\u0020";};};_ecdg +="\u005d";return _ecdg ;};func (_aeaad *PdfParser )readComment ()(string ,error ){var _afff _gcd .Buffer ;_ ,_gcbe :=_aeaad .skipSpaces ();if _gcbe !=nil {return _afff .String (),_gcbe ;};_ccgf :=true ;for {_abda ,_daae :=_aeaad ._daba .Peek (1);if _daae !=nil {_fg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_daae .Error ());return _afff .String (),_daae ;};if _ccgf &&_abda [0]!='%'{return _afff .String (),_c .New ("c\u006f\u006d\u006d\u0065\u006e\u0074 \u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0073\u0074a\u0072\u0074\u0020w\u0069t\u0068\u0020\u0025");};_ccgf =false ;if (_abda [0]!='\r')&&(_abda [0]!='\n'){_dbbd ,_ :=_aeaad ._daba .ReadByte ();_afff .WriteByte (_dbbd );}else {break ;};};return _afff .String (),nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_bgf *JPXEncoder )UpdateParams (params *PdfObjectDictionary ){};

// DecodeImages decodes the page images from the jbig2 'encoded' data input.
// The jbig2 document may contain multiple pages, thus the function can return multiple
// images. The images order corresponds to the page number.
func (_ggdaf *JBIG2Encoder )DecodeImages (encoded []byte )([]_cg .Image ,error ){const _gebab ="\u004aB\u0049\u0047\u0032\u0045n\u0063\u006f\u0064\u0065\u0072.\u0044e\u0063o\u0064\u0065\u0049\u006d\u0061\u0067\u0065s";_ddgd ,_cdga :=_cf .Decode (encoded ,_cf .Parameters {},_ggdaf .Globals .ToDocumentGlobals ());if _cdga !=nil {return nil ,_ad .Wrap (_cdga ,_gebab ,"");};_ccab ,_cdga :=_ddgd .PageNumber ();if _cdga !=nil {return nil ,_ad .Wrap (_cdga ,_gebab ,"");};_egbe :=[]_cg .Image {};var _agaf _cg .Image ;for _dac :=1;_dac <=_ccab ;_dac ++{_agaf ,_cdga =_ddgd .DecodePageImage (_dac );if _cdga !=nil {return nil ,_ad .Wrapf (_cdga ,_gebab ,"\u0070\u0061\u0067\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_dac );};_egbe =append (_egbe ,_agaf );};return _egbe ,nil ;};

// ASCIIHexEncoder implements ASCII hex encoder/decoder.
type ASCIIHexEncoder struct{};func (_dabg *PdfParser )parseBool ()(PdfObjectBool ,error ){_agfcd ,_dafe :=_dabg ._daba .Peek (4);if _dafe !=nil {return PdfObjectBool (false ),_dafe ;};if (len (_agfcd )>=4)&&(string (_agfcd [:4])=="\u0074\u0072\u0075\u0065"){_dabg ._daba .Discard (4);return PdfObjectBool (true ),nil ;};_agfcd ,_dafe =_dabg ._daba .Peek (5);if _dafe !=nil {return PdfObjectBool (false ),_dafe ;};if (len (_agfcd )>=5)&&(string (_agfcd [:5])=="\u0066\u0061\u006cs\u0065"){_dabg ._daba .Discard (5);return PdfObjectBool (false ),nil ;};return PdfObjectBool (false ),_c .New ("\u0075n\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0062o\u006fl\u0065a\u006e\u0020\u0073\u0074\u0072\u0069\u006eg");};

// EncodeBytes encodes data into ASCII85 encoded format.
func (_fgef *ASCII85Encoder )EncodeBytes (data []byte )([]byte ,error ){var _gdca _gcd .Buffer ;for _daab :=0;_daab < len (data );_daab +=4{_fffa :=data [_daab ];_acbe :=1;_dfc :=byte (0);if _daab +1< len (data ){_dfc =data [_daab +1];_acbe ++;};_abedb :=byte (0);if _daab +2< len (data ){_abedb =data [_daab +2];_acbe ++;};_afafg :=byte (0);if _daab +3< len (data ){_afafg =data [_daab +3];_acbe ++;};_dggag :=(uint32 (_fffa )<<24)|(uint32 (_dfc )<<16)|(uint32 (_abedb )<<8)|uint32 (_afafg );if _dggag ==0{_gdca .WriteByte ('z');}else {_accag :=_fgef .base256Tobase85 (_dggag );for _ ,_edad :=range _accag [:_acbe +1]{_gdca .WriteByte (_edad +'!');};};};_gdca .WriteString ("\u007e\u003e");return _gdca .Bytes (),nil ;};func (_fbfe *PdfParser )parseNumber ()(PdfObject ,error ){return ParseNumber (_fbfe ._daba )};

// ReadAtLeast reads at least n bytes into slice p.
// Returns the number of bytes read (should always be == n), and an error on failure.
func (_gdac *PdfParser )ReadAtLeast (p []byte ,n int )(int ,error ){_fefg :=n ;_adbdf :=0;_gfa :=0;for _fefg > 0{_cbfe ,_cdef :=_gdac ._daba .Read (p [_adbdf :]);if _cdef !=nil {_fg .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061d\u0069\u006e\u0067\u0020\u0028\u0025\u0064\u003b\u0025\u0064\u0029\u0020\u0025\u0073",_cbfe ,_gfa ,_cdef .Error ());return _adbdf ,_c .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065a\u0064\u0069\u006e\u0067");};_gfa ++;_adbdf +=_cbfe ;_fefg -=_cbfe ;};return _adbdf ,nil ;};

// MakeStream creates an PdfObjectStream with specified contents and encoding. If encoding is nil, then raw encoding
// will be used (i.e. no encoding applied).
func MakeStream (contents []byte ,encoder StreamEncoder )(*PdfObjectStream ,error ){_cgbgbb :=&PdfObjectStream {};if encoder ==nil {encoder =NewRawEncoder ();};_cgbgbb .PdfObjectDictionary =encoder .MakeStreamDict ();_gged ,_dccf :=encoder .EncodeBytes (contents );if _dccf !=nil {return nil ,_dccf ;};_cgbgbb .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_gged ))));_cgbgbb .Stream =_gged ;return _cgbgbb ,nil ;};func _ddeb (_gacdd string )(int ,int ,error ){_fega :=_eed .FindStringSubmatch (_gacdd );if len (_fega )< 3{return 0,0,_c .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");};_eaece ,_ :=_e .Atoi (_fega [1]);_ffcdf ,_ :=_e .Atoi (_fega [2]);return _eaece ,_ffcdf ,nil ;};

// PdfObjectBool represents the primitive PDF boolean object.
type PdfObjectBool bool ;

// GetFloatVal returns the float64 value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetFloatVal (obj PdfObject )(_fecc float64 ,_ggeb bool ){_afbab ,_ggeb :=TraceToDirectObject (obj ).(*PdfObjectFloat );if _ggeb {return float64 (*_afbab ),true ;};return 0,false ;};

// WriteString outputs the object as it is to be written to file.
func (_becce *PdfObjectBool )WriteString ()string {if *_becce {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};

// DecodeBytes decodes a slice of LZW encoded bytes and returns the result.
func (_abed *LZWEncoder )DecodeBytes (encoded []byte )([]byte ,error ){var _acca _gcd .Buffer ;_cdge :=_gcd .NewReader (encoded );var _efdb _de .ReadCloser ;if _abed .EarlyChange ==1{_efdb =_def .NewReader (_cdge ,_def .MSB ,8);}else {_efdb =_bed .NewReader (_cdge ,_bed .MSB ,8);};defer _efdb .Close ();_ ,_cce :=_acca .ReadFrom (_efdb );if _cce !=nil {return nil ,_cce ;};return _acca .Bytes (),nil ;};

// GoImageToJBIG2 creates a binary image on the base of 'i' golang image.Image.
// If the image is not a black/white image then the function converts provided input into
// JBIG2Image with 1bpp. For non grayscale images the function performs the conversion to the grayscale temp image.
// Then it checks the value of the gray image value if it's within bounds of the black white threshold.
// This 'bwThreshold' value should be in range (0.0, 1.0). The threshold checks if the grayscale pixel (uint) value
// is greater or smaller than 'bwThreshold' * 255. Pixels inside the range will be white, and the others will be black.
// If the 'bwThreshold' is equal to -1.0 - JB2ImageAutoThreshold then it's value would be set on the base of
// it's histogram using Triangle method. For more information go to:
// 	https://www.mathworks.com/matlabcentral/fileexchange/28047-gray-image-thresholding-using-the-triangle-method
func GoImageToJBIG2 (i _cg .Image ,bwThreshold float64 )(*JBIG2Image ,error ){const _gegd ="\u0047\u006f\u0049\u006d\u0061\u0067\u0065\u0054\u006fJ\u0042\u0049\u0047\u0032";if i ==nil {return nil ,_ad .Error (_gegd ,"i\u006d\u0061\u0067\u0065 '\u0069'\u0020\u006e\u006f\u0074\u0020d\u0065\u0066\u0069\u006e\u0065\u0064");};var (_bgbf uint8 ;_gffa _ee .Image ;_daee error ;);if bwThreshold ==JB2ImageAutoThreshold {_gffa ,_daee =_ee .MonochromeConverter .Convert (i );}else if bwThreshold > 1.0||bwThreshold < 0.0{return nil ,_ad .Error (_gegd ,"p\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074h\u0072\u0065\u0073\u0068\u006f\u006c\u0064 i\u0073\u0020\u006e\u006ft\u0020\u0069\u006e\u0020\u0061\u0020\u0072\u0061\u006ege\u0020\u007b0\u002e\u0030\u002c\u0020\u0031\u002e\u0030\u007d");}else {_bgbf =uint8 (255*bwThreshold );_gffa ,_daee =_ee .MonochromeThresholdConverter (_bgbf ).Convert (i );};if _daee !=nil {return nil ,_daee ;};return _gbbg (_gffa ),nil ;};var _fafg =_a .MustCompile ("\u005b\\\u0072\u005c\u006e\u005d\u005c\u0073\u002a\u0028\u0078\u0072\u0065f\u0029\u005c\u0073\u002a\u005b\u005c\u0072\u005c\u006e\u005d");

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_febc *RunLengthEncoder )MakeDecodeParams ()PdfObject {return nil };

// PdfCrypt provides PDF encryption/decryption support.
// The PDF standard supports encryption of strings and streams (Section 7.6).
type PdfCrypt struct{_age encryptDict ;_cgc _dfg .StdEncryptDict ;_dg string ;_gbb []byte ;_cc map[PdfObject ]bool ;_aaa map[PdfObject ]bool ;_bddg bool ;_dfb cryptFilters ;_gca string ;_fcb string ;_afaf *PdfParser ;_cdbg map[int ]struct{};};

// NewASCII85Encoder makes a new ASCII85 encoder.
func NewASCII85Encoder ()*ASCII85Encoder {_gdaeg :=&ASCII85Encoder {};return _gdaeg };

// GetIndirect returns the *PdfIndirectObject represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetIndirect (obj PdfObject )(_dcgd *PdfIndirectObject ,_babeb bool ){obj =ResolveReference (obj );_dcgd ,_babeb =obj .(*PdfIndirectObject );return _dcgd ,_babeb ;};

// WriteString outputs the object as it is to be written to file.
func (_beebc *PdfObjectReference )WriteString ()string {var _begf _afa .Builder ;_begf .WriteString (_e .FormatInt (_beebc .ObjectNumber ,10));_begf .WriteString ("\u0020");_begf .WriteString (_e .FormatInt (_beebc .GenerationNumber ,10));_begf .WriteString ("\u0020\u0052");return _begf .String ();};

// MakeStringFromBytes creates an PdfObjectString from a byte array.
// This is more natural than MakeString as `data` is usually not utf-8 encoded.
func MakeStringFromBytes (data []byte )*PdfObjectString {return MakeString (string (data ))};

// IsAuthenticated returns true if the PDF has already been authenticated for accessing.
func (_dgeaf *PdfParser )IsAuthenticated ()bool {return _dgeaf ._abd ._bddg };

// EqualObjects returns true if `obj1` and `obj2` have the same contents.
//
// NOTE: It is a good idea to flatten obj1 and obj2 with FlattenObject before calling this function
// so that contents, rather than references, can be compared.
func EqualObjects (obj1 ,obj2 PdfObject )bool {return _bfead (obj1 ,obj2 ,0)};

// Decrypt attempts to decrypt the PDF file with a specified password.  Also tries to
// decrypt with an empty password.  Returns true if successful, false otherwise.
// An error is returned when there is a problem with decrypting.
func (_dbdg *PdfParser )Decrypt (password []byte )(bool ,error ){if _dbdg ._abd ==nil {return false ,_c .New ("\u0063\u0068\u0065\u0063k \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u0069\u0072s\u0074");};_fedbg ,_cgbgb :=_dbdg ._abd .authenticate (password );if _cgbgb !=nil {return false ,_cgbgb ;};if !_fedbg {_fedbg ,_cgbgb =_dbdg ._abd .authenticate ([]byte (""));};return _fedbg ,_cgbgb ;};

// GetFilterName returns the name of the encoding filter.
func (_becf *ASCIIHexEncoder )GetFilterName ()string {return StreamEncodingFilterNameASCIIHex };var _fcbd =_a .MustCompile ("\u0025\u0025\u0045\u004f\u0046\u003f");

// UpdateParams updates the parameter values of the encoder.
func (_aafd *LZWEncoder )UpdateParams (params *PdfObjectDictionary ){_ddcd ,_cbdf :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _cbdf ==nil {_aafd .Predictor =int (_ddcd );};_gdgd ,_cbdf :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _cbdf ==nil {_aafd .BitsPerComponent =int (_gdgd );};_agd ,_cbdf :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _cbdf ==nil {_aafd .Columns =int (_agd );};_gccce ,_cbdf :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _cbdf ==nil {_aafd .Colors =int (_gccce );};_ede ,_cbdf :=GetNumberAsInt64 (params .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065"));if _cbdf ==nil {_aafd .EarlyChange =int (_ede );};};var _gfdf =_a .MustCompile ("\u0073t\u0061r\u0074\u0078\u003f\u0072\u0065f\u005c\u0073*\u0028\u005c\u0064\u002b\u0029");type xrefType int ;

// GetCrypter returns the PdfCrypt instance which has information about the PDFs encryption.
func (_dggfa *PdfParser )GetCrypter ()*PdfCrypt {return _dggfa ._abd };func _bfgf (_bcce PdfObject )(*float64 ,error ){switch _aebb :=_bcce .(type ){case *PdfObjectFloat :_ffbc :=float64 (*_aebb );return &_ffbc ,nil ;case *PdfObjectInteger :_gccg :=float64 (*_aebb );return &_gccg ,nil ;case *PdfObjectNull :return nil ,nil ;};return nil ,ErrNotANumber ;};type encryptDict struct{Filter string ;V int ;SubFilter string ;Length int ;StmF string ;StrF string ;EFF string ;CF map[string ]_cd .FilterDict ;};

// EncodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_dca *RawEncoder )EncodeBytes (data []byte )([]byte ,error ){return data ,nil };

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_gdce *ASCIIHexEncoder )MakeStreamDict ()*PdfObjectDictionary {_cdad :=MakeDict ();_cdad .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_gdce .GetFilterName ()));return _cdad ;};const (XrefTypeTableEntry xrefType =iota ;XrefTypeObjectStream xrefType =iota ;);

// GetFilterName returns the names of the underlying encoding filters,
// separated by spaces.
// Note: This is just a string, should not be used in /Filter dictionary entry. Use GetFilterArray for that.
// TODO(v4): Refactor to GetFilter() which can be used for /Filter (either Name or Array), this can be
//  renamed to String() as a pretty string to use in debugging etc.
func (_dgba *MultiEncoder )GetFilterName ()string {_dfab :="";for _bfed ,_gcef :=range _dgba ._gba {_dfab +=_gcef .GetFilterName ();if _bfed < len (_dgba ._gba )-1{_dfab +="\u0020";};};return _dfab ;};func _efad (_decc *PdfObjectStream ,_effa *PdfObjectDictionary )(*CCITTFaxEncoder ,error ){_bcga :=NewCCITTFaxEncoder ();_abeg :=_decc .PdfObjectDictionary ;if _abeg ==nil {return _bcga ,nil ;};if _effa ==nil {_fdbg :=TraceToDirectObject (_abeg .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));if _fdbg !=nil {switch _dcac :=_fdbg .(type ){case *PdfObjectDictionary :_effa =_dcac ;case *PdfObjectArray :if _dcac .Len ()==1{if _bcde ,_begd :=GetDict (_dcac .Get (0));_begd {_effa =_bcde ;};};default:_fg .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_fdbg );return nil ,_c .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _effa ==nil {_fg .Log .Error ("\u0044\u0065c\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064 %\u0023\u0076",_fdbg );return nil ,_c .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _fgee ,_acad :=GetNumberAsInt64 (_effa .Get ("\u004b"));_acad ==nil {_bcga .K =int (_fgee );};if _gfeg ,_gfda :=GetNumberAsInt64 (_effa .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));_gfda ==nil {_bcga .Columns =int (_gfeg );}else {_bcga .Columns =1728;};if _ecffg ,_adcb :=GetNumberAsInt64 (_effa .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_adcb ==nil {_bcga .BlackIs1 =_ecffg > 0;}else {if _deda ,_dfaad :=GetBoolVal (_effa .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_dfaad {_bcga .BlackIs1 =_deda ;}else {if _dgca ,_ccdg :=GetArray (_effa .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));_ccdg {_dcaa ,_bda :=_dgca .ToIntegerArray ();if _bda ==nil {_bcga .BlackIs1 =_dcaa [0]==1&&_dcaa [1]==0;};};};};if _eeee ,_aecb :=GetNumberAsInt64 (_effa .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_aecb ==nil {_bcga .EncodedByteAlign =_eeee > 0;}else {if _gbfg ,_bdcc :=GetBoolVal (_effa .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_bdcc {_bcga .EncodedByteAlign =_gbfg ;};};if _aceef ,_adff :=GetNumberAsInt64 (_effa .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_adff ==nil {_bcga .EndOfLine =_aceef > 0;}else {if _ffdc ,_bad :=GetBoolVal (_effa .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_bad {_bcga .EndOfLine =_ffdc ;};};if _bbce ,_agfg :=GetNumberAsInt64 (_effa .Get ("\u0052\u006f\u0077\u0073"));_agfg ==nil {_bcga .Rows =int (_bbce );};_bcga .EndOfBlock =true ;if _eegf ,_cacf :=GetNumberAsInt64 (_effa .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_cacf ==nil {_bcga .EndOfBlock =_eegf > 0;}else {if _cebe ,_agge :=GetBoolVal (_effa .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_agge {_bcga .EndOfBlock =_cebe ;};};if _abf ,_deec :=GetNumberAsInt64 (_effa .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));_deec !=nil {_bcga .DamagedRowsBeforeError =int (_abf );};_fg .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_effa .String ());return _bcga ,nil ;};

// DecodeBytes decodes a byte slice from Run length encoding.
//
// 7.4.5 RunLengthDecode Filter
// The RunLengthDecode filter decodes data that has been encoded in a simple byte-oriented format based on run length.
// The encoded data shall be a sequence of runs, where each run shall consist of a length byte followed by 1 to 128
// bytes of data. If the length byte is in the range 0 to 127, the following length + 1 (1 to 128) bytes shall be
// copied literally during decompression. If length is in the range 129 to 255, the following single byte shall be
// copied 257 - length (2 to 128) times during decompression. A length value of 128 shall denote EOD.
func (_bgdg *RunLengthEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_faaf :=_gcd .NewReader (encoded );var _gdff []byte ;for {_bffd ,_dcbe :=_faaf .ReadByte ();if _dcbe !=nil {return nil ,_dcbe ;};if _bffd > 128{_gae ,_egea :=_faaf .ReadByte ();if _egea !=nil {return nil ,_egea ;};for _agba :=0;_agba < 257-int (_bffd );_agba ++{_gdff =append (_gdff ,_gae );};}else if _bffd < 128{for _adfb :=0;_adfb < int (_bffd )+1;_adfb ++{_eebg ,_efa :=_faaf .ReadByte ();if _efa !=nil {return nil ,_efa ;};_gdff =append (_gdff ,_eebg );};}else {break ;};};return _gdff ,nil ;};func (_eggce *PdfParser )skipSpaces ()(int ,error ){_eccdd :=0;for {_gcce ,_afdb :=_eggce ._daba .ReadByte ();if _afdb !=nil {return 0,_afdb ;};if IsWhiteSpace (_gcce ){_eccdd ++;}else {_eggce ._daba .UnreadByte ();break ;};};return _eccdd ,nil ;};func (_gab *offsetReader )Read (p []byte )(_gebad int ,_cfebc error ){return _gab ._eefca .Read (p )};func (_gead *PdfObjectInteger )String ()string {return _gc .Sprintf ("\u0025\u0064",*_gead )};

// Set sets the dictionary's key -> val mapping entry. Overwrites if key already set.
func (_fdgea *PdfObjectDictionary )Set (key PdfObjectName ,val PdfObject ){_ ,_dfdde :=_fdgea ._acacc [key ];if !_dfdde {_fdgea ._fgae =append (_fdgea ._fgae ,key );};_fdgea ._acacc [key ]=val ;};

// Append appends PdfObject(s) to the streams.
func (_cbfd *PdfObjectStreams )Append (objects ...PdfObject ){if _cbfd ==nil {_fg .Log .Debug ("\u0057\u0061\u0072\u006e\u0020-\u0020\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0020\u0074\u006f\u0020\u0061p\u0070\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0073");return ;};_cbfd ._gfcee =append (_cbfd ._gfcee ,objects ...);};

// GetString returns the *PdfObjectString represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetString (obj PdfObject )(_fadcc *PdfObjectString ,_gefec bool ){_fadcc ,_gefec =TraceToDirectObject (obj ).(*PdfObjectString );return _fadcc ,_gefec ;};

// NewDCTEncoder makes a new DCT encoder with default parameters.
func NewDCTEncoder ()*DCTEncoder {_dfd :=&DCTEncoder {};_dfd .ColorComponents =3;_dfd .BitsPerComponent =8;_dfd .Quality =DefaultJPEGQuality ;return _dfd ;};

// GetObjectStreams returns the *PdfObjectStreams represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetObjectStreams (obj PdfObject )(_bgbe *PdfObjectStreams ,_bdfcg bool ){_bgbe ,_bdfcg =obj .(*PdfObjectStreams );return _bgbe ,_bdfcg ;};func (_aaeg *PdfCrypt )makeKey (_bgc string ,_bfbg ,_fgfa uint32 ,_gacgc []byte )([]byte ,error ){_gbc ,_cbdg :=_aaeg ._dfb [_bgc ];if !_cbdg {return nil ,_gc .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_bgc );};return _gbc .MakeKey (_bfbg ,_fgfa ,_gacgc );};func (_dgfe *PdfParser )parseXref ()(*PdfObjectDictionary ,error ){const _ddef =20;_aaba ,_ :=_dgfe ._daba .Peek (_ddef );for _babd :=0;_babd < 2;_babd ++{if _dgfe ._cfed ==0{_dgfe ._cfed =_dgfe .GetFileOffset ();};if _eed .Match (_aaba ){_fg .Log .Trace ("\u0078\u0072e\u0066\u0020\u0070\u006f\u0069\u006e\u0074\u0073\u0020\u0074\u006f\u0020\u0061\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u002e\u0020\u0050\u0072\u006f\u0062\u0061\u0062\u006c\u0079\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063\u0074");_fg .Log .Debug ("\u0073t\u0061r\u0074\u0069\u006e\u0067\u0020w\u0069\u0074h\u0020\u0022\u0025\u0073\u0022",string (_aaba ));return _dgfe .parseXrefStream (nil );};if _cafb .Match (_aaba ){_fg .Log .Trace ("\u0053\u0074\u0061\u006ed\u0061\u0072\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073e\u0063t\u0069\u006f\u006e\u0020\u0074\u0061\u0062l\u0065\u0021");return _dgfe .parseXrefTable ();};_gbcd :=_dgfe .GetFileOffset ();if _dgfe ._cfed ==0{_dgfe ._cfed =_gbcd ;};_dgfe .SetFileOffset (_gbcd -_ddef );defer _dgfe .SetFileOffset (_gbcd );_bdgd ,_ :=_dgfe ._daba .Peek (_ddef );_aaba =append (_bdgd ,_aaba ...);};_fg .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u0078\u0072\u0065f\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006fr\u0020\u0073\u0074\u0072\u0065\u0061\u006d.\u0020\u0052\u0065\u0070\u0061i\u0072\u0020\u0061\u0074\u0074e\u006d\u0070\u0074\u0065\u0064\u003a\u0020\u004c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0065\u0061\u0072\u006c\u0069\u0065\u0073\u0074\u0020x\u0072\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u0062\u006f\u0074to\u006d\u002e");if _eaedd :=_dgfe .repairSeekXrefMarker ();_eaedd !=nil {_fg .Log .Debug ("\u0052e\u0070a\u0069\u0072\u0020\u0066\u0061i\u006c\u0065d\u0020\u002d\u0020\u0025\u0076",_eaedd );return nil ,_eaedd ;};return _dgfe .parseXrefTable ();};

// GetXrefType returns the type of the first xref object (table or stream).
func (_afafb *PdfParser )GetXrefType ()*xrefType {return _afafb ._fagf };

// Decoded returns the PDFDocEncoding or UTF-16BE decoded string contents.
// UTF-16BE is applied when the first two bytes are 0xFE, 0XFF, otherwise decoding of
// PDFDocEncoding is performed.
func (_dfce *PdfObjectString )Decoded ()string {if _dfce ==nil {return "";};_bdff :=[]byte (_dfce ._abgc );if len (_bdff )>=2&&_bdff [0]==0xFE&&_bdff [1]==0xFF{return _df .UTF16ToString (_bdff [2:]);};return _df .PDFDocEncodingToString (_bdff );};

// ParseIndirectObject parses an indirect object from the input stream. Can also be an object stream.
// Returns the indirect object (*PdfIndirectObject) or the stream object (*PdfObjectStream).
func (_bbcg *PdfParser )ParseIndirectObject ()(PdfObject ,error ){_defdg :=PdfIndirectObject {};_defdg ._dgcf =_bbcg ;_fg .Log .Trace ("\u002dR\u0065a\u0064\u0020\u0069\u006e\u0064i\u0072\u0065c\u0074\u0020\u006f\u0062\u006a");_gcea ,_dbfb :=_bbcg ._daba .Peek (20);if _dbfb !=nil {if _dbfb !=_de .EOF {_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020r\u0065a\u0064\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a");return &_defdg ,_dbfb ;};};_fg .Log .Trace ("\u0028\u0069\u006edi\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_gcea ));_fedb :=_eed .FindStringSubmatchIndex (string (_gcea ));if len (_fedb )< 6{if _dbfb ==_de .EOF {return nil ,_dbfb ;};_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_gcea ));return &_defdg ,_c .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");};_bbcg ._daba .Discard (_fedb [0]);_fg .Log .Trace ("O\u0066\u0066\u0073\u0065\u0074\u0073\u0020\u0025\u0020\u0064",_fedb );_gdbcc :=_fedb [1]-_fedb [0];_daddd :=make ([]byte ,_gdbcc );_ ,_dbfb =_bbcg .ReadAtLeast (_daddd ,_gdbcc );if _dbfb !=nil {_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u0072\u0065\u0061\u0064\u0020-\u0020\u0025\u0073",_dbfb );return nil ,_dbfb ;};_fg .Log .Trace ("\u0074\u0065\u0078t\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_daddd );_caeg :=_eed .FindStringSubmatch (string (_daddd ));if len (_caeg )< 3{_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_daddd ));return &_defdg ,_c .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");};_ecdd ,_ :=_e .Atoi (_caeg [1]);_fcbe ,_ :=_e .Atoi (_caeg [2]);_defdg .ObjectNumber =int64 (_ecdd );_defdg .GenerationNumber =int64 (_fcbe );for {_bced ,_dgab :=_bbcg ._daba .Peek (2);if _dgab !=nil {return &_defdg ,_dgab ;};_fg .Log .Trace ("I\u006ed\u002e\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_bced ),string (_bced ));if IsWhiteSpace (_bced [0]){_bbcg .skipSpaces ();}else if _bced [0]=='%'{_bbcg .skipComments ();}else if (_bced [0]=='<')&&(_bced [1]=='<'){_fg .Log .Trace ("\u0043\u0061\u006c\u006c\u0020\u0050\u0061\u0072\u0073e\u0044\u0069\u0063\u0074");_defdg .PdfObject ,_dgab =_bbcg .ParseDict ();_fg .Log .Trace ("\u0045\u004f\u0046\u0020Ca\u006c\u006c\u0020\u0050\u0061\u0072\u0073\u0065\u0044\u0069\u0063\u0074\u003a\u0020%\u0076",_dgab );if _dgab !=nil {return &_defdg ,_dgab ;};_fg .Log .Trace ("\u0050\u0061\u0072\u0073\u0065\u0064\u0020\u0064\u0069\u0063t\u0069\u006f\u006e\u0061\u0072\u0079\u002e.\u002e\u0020\u0066\u0069\u006e\u0069\u0073\u0068\u0065\u0064\u002e");}else if (_bced [0]=='/')||(_bced [0]=='(')||(_bced [0]=='[')||(_bced [0]=='<'){_defdg .PdfObject ,_dgab =_bbcg .parseObject ();if _dgab !=nil {return &_defdg ,_dgab ;};_fg .Log .Trace ("P\u0061\u0072\u0073\u0065\u0064\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u002e\u002e\u002e \u0066\u0069\u006ei\u0073h\u0065\u0064\u002e");}else if _bced [0]==']'{_fg .Log .Debug ("\u0057\u0041\u0052\u004e\u0049N\u0047\u003a\u0020\u0027\u005d\u0027 \u0063\u0068\u0061\u0072\u0061\u0063\u0074e\u0072\u0020\u006eo\u0074\u0020\u0062\u0065i\u006e\u0067\u0020\u0075\u0073\u0065d\u0020\u0061\u0073\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006e\u0064\u0069n\u0067\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e");_bbcg ._daba .Discard (1);}else {if _bced [0]=='e'{_cefeg ,_ffgag :=_bbcg .readTextLine ();if _ffgag !=nil {return nil ,_ffgag ;};if len (_cefeg )>=6&&_cefeg [0:6]=="\u0065\u006e\u0064\u006f\u0062\u006a"{break ;};}else if _bced [0]=='s'{_bced ,_ =_bbcg ._daba .Peek (10);if string (_bced [:6])=="\u0073\u0074\u0072\u0065\u0061\u006d"{_fafa :=6;if len (_bced )> 6{if IsWhiteSpace (_bced [_fafa ])&&_bced [_fafa ]!='\r'&&_bced [_fafa ]!='\n'{_fg .Log .Debug ("\u004e\u006fn\u002d\u0063\u006f\u006e\u0066\u006f\u0072\u006d\u0061\u006e\u0074\u0020\u0050\u0044\u0046\u0020\u006e\u006f\u0074 \u0065\u006e\u0064\u0069\u006e\u0067 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0069\u006e\u0065\u0020\u0070\u0072o\u0070\u0065r\u006c\u0079\u0020\u0077i\u0074\u0068\u0020\u0045\u004fL\u0020\u006d\u0061\u0072\u006b\u0065\u0072");_fafa ++;};if _bced [_fafa ]=='\r'{_fafa ++;if _bced [_fafa ]=='\n'{_fafa ++;};}else if _bced [_fafa ]=='\n'{_fafa ++;};};_bbcg ._daba .Discard (_fafa );_cfa ,_dfgef :=_defdg .PdfObject .(*PdfObjectDictionary );if !_dfgef {return nil ,_c .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006di\u0073s\u0069\u006e\u0067\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_fg .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0069c\u0074\u0020\u0025\u0073",_cfa );_deecc ,_gbaa :=_bbcg .traceStreamLength (_cfa .Get ("\u004c\u0065\u006e\u0067\u0074\u0068"));if _gbaa !=nil {_fg .Log .Debug ("\u0046\u0061\u0069l\u0020\u0074\u006f\u0020t\u0072\u0061\u0063\u0065\u0020\u0073\u0074r\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0025\u0076",_gbaa );return nil ,_gbaa ;};_fg .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_deecc );_abac ,_bgac :=_deecc .(*PdfObjectInteger );if !_bgac {return nil ,_c .New ("\u0073\u0074re\u0061\u006d\u0020l\u0065\u006e\u0067\u0074h n\u0065ed\u0073\u0020\u0074\u006f\u0020\u0062\u0065 a\u006e\u0020\u0069\u006e\u0074\u0065\u0067e\u0072");};_dgdg :=*_abac ;if _dgdg < 0{return nil ,_c .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006e\u0065\u0065\u0064\u0073\u0020\u0074\u006f \u0062e\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0030");};_afba :=_bbcg .GetFileOffset ();_edc :=_bbcg .xrefNextObjectOffset (_afba );if _afba +int64 (_dgdg )> _edc &&_edc > _afba {_fg .Log .Debug ("E\u0078\u0070\u0065\u0063te\u0064 \u0065\u006e\u0064\u0069\u006eg\u0020\u0061\u0074\u0020\u0025\u0064",_afba +int64 (_dgdg ));_fg .Log .Debug ("\u004e\u0065\u0078\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020\u0061t\u0020\u0025\u0064",_edc );_afcf :=_edc -_afba -17;if _afcf < 0{return nil ,_c .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020go\u0069\u006e\u0067 \u0070\u0061s\u0074\u0020\u0062\u006f\u0075\u006ed\u0061\u0072i\u0065\u0073");};_fg .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0061\u0020l\u0065\u006e\u0067\u0074\u0068\u0020c\u006f\u0072\u0072\u0065\u0063\u0074\u0069\u006f\u006e\u0020\u0074\u006f\u0020%\u0064\u002e\u002e\u002e",_afcf );_dgdg =PdfObjectInteger (_afcf );_cfa .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (_afcf ));};if int64 (_dgdg )> _bbcg ._eecde {_fg .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0053t\u0072\u0065\u0061\u006d\u0020l\u0065\u006e\u0067\u0074\u0068\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u0061\u0072\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0066\u0069\u006c\u0065\u0020\u0073\u0069\u007a\u0065");return nil ,_c .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020la\u0072\u0067\u0065r\u0020\u0074h\u0061\u006e\u0020\u0066\u0069\u006ce\u0020\u0073i\u007a\u0065");};_adga :=make ([]byte ,_dgdg );_ ,_gbaa =_bbcg .ReadAtLeast (_adga ,int (_dgdg ));if _gbaa !=nil {_fg .Log .Debug ("E\u0052\u0052\u004f\u0052 s\u0074r\u0065\u0061\u006d\u0020\u0028%\u0064\u0029\u003a\u0020\u0025\u0058",len (_adga ),_adga );_fg .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_gbaa );return nil ,_gbaa ;};_bfdc :=PdfObjectStream {};_bfdc .Stream =_adga ;_bfdc .PdfObjectDictionary =_defdg .PdfObject .(*PdfObjectDictionary );_bfdc .ObjectNumber =_defdg .ObjectNumber ;_bfdc .GenerationNumber =_defdg .GenerationNumber ;_bfdc .PdfObjectReference ._dgcf =_bbcg ;_bbcg .skipSpaces ();_bbcg ._daba .Discard (9);_bbcg .skipSpaces ();return &_bfdc ,nil ;};};_defdg .PdfObject ,_dgab =_bbcg .parseObject ();if _defdg .PdfObject ==nil {_fg .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");_defdg .PdfObject =MakeNull ();};return &_defdg ,_dgab ;};};if _defdg .PdfObject ==nil {_fg .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");_defdg .PdfObject =MakeNull ();};_fg .Log .Trace ("\u0052\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0021");return &_defdg ,nil ;};

// WriteString outputs the object as it is to be written to file.
func (_fcgb *PdfObjectName )WriteString ()string {var _gcda _gcd .Buffer ;if len (*_fcgb )> 127{_fg .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u004e\u0061\u006d\u0065\u0020t\u006fo\u0020l\u006f\u006e\u0067\u0020\u0028\u0025\u0073)",*_fcgb );};_gcda .WriteString ("\u002f");for _cgaba :=0;_cgaba < len (*_fcgb );_cgaba ++{_bfad :=(*_fcgb )[_cgaba ];if !IsPrintable (_bfad )||_bfad =='#'||IsDelimiter (_bfad ){_gcda .WriteString (_gc .Sprintf ("\u0023\u0025\u002e2\u0078",_bfad ));}else {_gcda .WriteByte (_bfad );};};return _gcda .String ();};

// GetIntVal returns the int value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetIntVal (obj PdfObject )(_effb int ,_egfbb bool ){_egfc ,_egfbb :=TraceToDirectObject (obj ).(*PdfObjectInteger );if _egfbb &&_egfc !=nil {return int (*_egfc ),true ;};return 0,false ;};

// String returns a string representation of the *PdfObjectString.
func (_edca *PdfObjectString )String ()string {return _edca ._abgc };

// MakeObjectStreams creates an PdfObjectStreams from a list of PdfObjects.
func MakeObjectStreams (objects ...PdfObject )*PdfObjectStreams {return &PdfObjectStreams {_gfcee :objects };};var _agcd =_a .MustCompile ("\u005e\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");

// IsOctalDigit checks if a character can be part of an octal digit string.
func IsOctalDigit (c byte )bool {return '0'<=c &&c <='7'};

// DecodeStream returns the passed in stream as a slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_dedb *RawEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return streamObj .Stream ,nil ;};

// WriteString outputs the object as it is to be written to file.
func (_edaa *PdfObjectNull )WriteString ()string {return "\u006e\u0075\u006c\u006c"};

// Encrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_gaac *PdfCrypt )Encrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _gaac .isEncrypted (obj ){return nil ;};switch _aagf :=obj .(type ){case *PdfIndirectObject :_gaac ._aaa [_aagf ]=true ;_fg .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_aagf .ObjectNumber ,_aagf .GenerationNumber );_agc :=_aagf .ObjectNumber ;_edfb :=_aagf .GenerationNumber ;_cdg :=_gaac .Encrypt (_aagf .PdfObject ,_agc ,_edfb );if _cdg !=nil {return _cdg ;};return nil ;case *PdfObjectStream :_gaac ._aaa [_aagf ]=true ;_geef :=_aagf .PdfObjectDictionary ;if _gda ,_bddgg :=_geef .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_bddgg &&*_gda =="\u0058\u0052\u0065\u0066"{return nil ;};_ecffe :=_aagf .ObjectNumber ;_bgbd :=_aagf .GenerationNumber ;_fg .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_ecffe ,_bgbd );_efd :=_bfb ;if _gaac ._age .V >=4{_efd =_gaac ._gca ;_fg .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_gaac ._gca );if _gacgf ,_acc :=_geef .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );_acc {if _dga ,_aga :=GetName (_gacgf .Get (0));_aga {if *_dga =="\u0043\u0072\u0079p\u0074"{_efd ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _ceaa ,_gdg :=_geef .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );_gdg {if _dcg ,_fffe :=_ceaa .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_fffe {if _ ,_eabg :=_gaac ._dfb [string (*_dcg )];_eabg {_fg .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_dcg );_efd =string (*_dcg );};};};};};};_fg .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_efd );if _efd =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_bbd :=_gaac .Encrypt (_aagf .PdfObjectDictionary ,_ecffe ,_bgbd );if _bbd !=nil {return _bbd ;};_aff ,_bbd :=_gaac .makeKey (_efd ,uint32 (_ecffe ),uint32 (_bgbd ),_gaac ._gbb );if _bbd !=nil {return _bbd ;};_aagf .Stream ,_bbd =_gaac .encryptBytes (_aagf .Stream ,_efd ,_aff );if _bbd !=nil {return _bbd ;};_geef .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_aagf .Stream ))));return nil ;case *PdfObjectString :_fg .Log .Trace ("\u0045n\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_abg :=_bfb ;if _gaac ._age .V >=4{_fg .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_gaac ._fcb );if _gaac ._fcb =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_abg =_gaac ._fcb ;};_cac ,_aeed :=_gaac .makeKey (_abg ,uint32 (parentObjNum ),uint32 (parentGenNum ),_gaac ._gbb );if _aeed !=nil {return _aeed ;};_cead :=_aagf .Str ();_bdde :=make ([]byte ,len (_cead ));for _ffbe :=0;_ffbe < len (_cead );_ffbe ++{_bdde [_ffbe ]=_cead [_ffbe ];};_fg .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_bdde ,_bdde );_bdde ,_aeed =_gaac .encryptBytes (_bdde ,_abg ,_cac );if _aeed !=nil {return _aeed ;};_aagf ._abgc =string (_bdde );return nil ;case *PdfObjectArray :for _ ,_fdc :=range _aagf .Elements (){_fffee :=_gaac .Encrypt (_fdc ,parentObjNum ,parentGenNum );if _fffee !=nil {return _fffee ;};};return nil ;case *PdfObjectDictionary :_bcgfg :=false ;if _cab :=_aagf .Get ("\u0054\u0079\u0070\u0065");_cab !=nil {_cgbe ,_dgaa :=_cab .(*PdfObjectName );if _dgaa &&*_cgbe =="\u0053\u0069\u0067"{_bcgfg =true ;};};for _ ,_cdd :=range _aagf .Keys (){_dfef :=_aagf .Get (_cdd );if _bcgfg &&string (_cdd )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;};if string (_cdd )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_cdd )!="\u0050\u0072\u0065\u0076"&&string (_cdd )!="\u004c\u0061\u0073\u0074"{_fbb :=_gaac .Encrypt (_dfef ,parentObjNum ,parentGenNum );if _fbb !=nil {return _fbb ;};};};return nil ;};return nil ;};func (_dedd *PdfParser )parseString ()(*PdfObjectString ,error ){_dedd ._daba .ReadByte ();var _aebg _gcd .Buffer ;_gbfc :=1;for {_dgbd ,_dbbb :=_dedd ._daba .Peek (1);if _dbbb !=nil {return MakeString (_aebg .String ()),_dbbb ;};if _dgbd [0]=='\\'{_dedd ._daba .ReadByte ();_bcgg ,_efcef :=_dedd ._daba .ReadByte ();if _efcef !=nil {return MakeString (_aebg .String ()),_efcef ;};if IsOctalDigit (_bcgg ){_beef ,_fcea :=_dedd ._daba .Peek (2);if _fcea !=nil {return MakeString (_aebg .String ()),_fcea ;};var _afafe []byte ;_afafe =append (_afafe ,_bcgg );for _ ,_gfed :=range _beef {if IsOctalDigit (_gfed ){_afafe =append (_afafe ,_gfed );}else {break ;};};_dedd ._daba .Discard (len (_afafe )-1);_fg .Log .Trace ("\u004e\u0075\u006d\u0065ri\u0063\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0022\u0025\u0073\u0022",_afafe );_eeaac ,_fcea :=_e .ParseUint (string (_afafe ),8,32);if _fcea !=nil {return MakeString (_aebg .String ()),_fcea ;};_aebg .WriteByte (byte (_eeaac ));continue ;};switch _bcgg {case 'n':_aebg .WriteRune ('\n');case 'r':_aebg .WriteRune ('\r');case 't':_aebg .WriteRune ('\t');case 'b':_aebg .WriteRune ('\b');case 'f':_aebg .WriteRune ('\f');case '(':_aebg .WriteRune ('(');case ')':_aebg .WriteRune (')');case '\\':_aebg .WriteRune ('\\');};continue ;}else if _dgbd [0]=='('{_gbfc ++;}else if _dgbd [0]==')'{_gbfc --;if _gbfc ==0{_dedd ._daba .ReadByte ();break ;};};_bbef ,_ :=_dedd ._daba .ReadByte ();_aebg .WriteByte (_bbef );};return MakeString (_aebg .String ()),nil ;};

// MakeEncodedString creates a PdfObjectString with encoded content, which can be either
// UTF-16BE or PDFDocEncoding depending on whether `utf16BE` is true or false respectively.
func MakeEncodedString (s string ,utf16BE bool )*PdfObjectString {if utf16BE {var _ggde _gcd .Buffer ;_ggde .Write ([]byte {0xFE,0xFF});_ggde .WriteString (_df .StringToUTF16 (s ));return &PdfObjectString {_abgc :_ggde .String (),_eade :true };};return &PdfObjectString {_abgc :string (_df .StringToPDFDocEncoding (s )),_eade :false };};func (_ebg *PdfCrypt )isEncrypted (_dcfg PdfObject )bool {_ ,_bece :=_ebg ._aaa [_dcfg ];if _bece {_fg .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0065\u006e\u0063\u0072y\u0070\u0074\u0065\u0064");return true ;};_fg .Log .Trace ("\u004e\u006f\u0074\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");return false ;};

// GetAccessPermissions returns the PDF access permissions as an AccessPermissions object.
func (_aae *PdfCrypt )GetAccessPermissions ()_dfg .Permissions {return _aae ._cgc .P };

// DecodeBytes decodes the CCITTFax encoded image data.
func (_gdade *CCITTFaxEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_afcg :=&_afd .Encoder {K :_gdade .K ,Columns :_gdade .Columns ,EndOfLine :_gdade .EndOfLine ,EndOfBlock :_gdade .EndOfBlock ,BlackIs1 :_gdade .BlackIs1 ,DamagedRowsBeforeError :_gdade .DamagedRowsBeforeError ,Rows :_gdade .Rows ,EncodedByteAlign :_gdade .EncodedByteAlign };_eecg ,_gdbd :=_afcg .Decode (encoded );if _gdbd !=nil {return nil ,_gdbd ;};var _ccae []byte ;_ddfd :=0;var _ddcg byte ;var _fae byte ;for _fdaf :=range _eecg {if _ddcg !=0{_ccae =append (_ccae ,_fae );_fae =0;_ddfd ++;_ddcg =0;};for _gdcc :=range _eecg [_fdaf ]{_fae |=_eecg [_fdaf ][_gdcc ]<<(7-_ddcg );_ddcg ++;if _ddcg ==8{_ccae =append (_ccae ,_fae );_fae =0;_ddfd ++;_ddcg =0;};};};if _ddcg > 0{_ccae =append (_ccae ,_fae );};return _ccae ,nil ;};

// GetTrailer returns the PDFs trailer dictionary. The trailer dictionary is typically the starting point for a PDF,
// referencing other key objects that are important in the document structure.
func (_agfd *PdfParser )GetTrailer ()*PdfObjectDictionary {return _agfd ._eaeb };

// FlattenObject returns the contents of `obj`. In other words, `obj` with indirect objects replaced
// by their values.
// The replacements are made recursively to a depth of traceMaxDepth.
// NOTE: Dicts are sorted to make objects with same contents have the same PDF object strings.
func FlattenObject (obj PdfObject )PdfObject {return _gdffe (obj ,0)};

// PdfObjectString represents the primitive PDF string object.
type PdfObjectString struct{_abgc string ;_eade bool ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_eacc *JPXEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};

// MakeName creates a PdfObjectName from a string.
func MakeName (s string )*PdfObjectName {_ffff :=PdfObjectName (s );return &_ffff };

// NewMultiEncoder returns a new instance of MultiEncoder.
func NewMultiEncoder ()*MultiEncoder {_adfba :=MultiEncoder {};_adfba ._gba =[]StreamEncoder {};return &_adfba ;};

// XrefTable represents the cross references in a PDF, i.e. the table of objects and information
// where to access within the PDF file.
type XrefTable struct{ObjectMap map[int ]XrefObject ;_bd []XrefObject ;};

// NewJBIG2Encoder creates a new JBIG2Encoder.
func NewJBIG2Encoder ()*JBIG2Encoder {return &JBIG2Encoder {_gbae :_ca .InitEncodeDocument (false )}};func _cggd (_fgdd PdfObject ,_cefc int ,_edebc map[PdfObject ]struct{})error {_fg .Log .Trace ("\u0054\u0072\u0061\u0076\u0065\u0072s\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0064\u0061\u0074\u0061 \u0028\u0064\u0065\u0070\u0074\u0068\u0020=\u0020\u0025\u0064\u0029",_cefc );if _ ,_edcaa :=_edebc [_fgdd ];_edcaa {_fg .Log .Trace ("-\u0041\u006c\u0072\u0065ad\u0079 \u0074\u0072\u0061\u0076\u0065r\u0073\u0065\u0064\u002e\u002e\u002e");return nil ;};_edebc [_fgdd ]=struct{}{};switch _eabdd :=_fgdd .(type ){case *PdfIndirectObject :_fcgbe :=_eabdd ;_fg .Log .Trace ("\u0069\u006f\u003a\u0020\u0025\u0073",_fcgbe );_fg .Log .Trace ("\u002d\u0020\u0025\u0073",_fcgbe .PdfObject );return _cggd (_fcgbe .PdfObject ,_cefc +1,_edebc );case *PdfObjectStream :_bffg :=_eabdd ;return _cggd (_bffg .PdfObjectDictionary ,_cefc +1,_edebc );case *PdfObjectDictionary :_eedg :=_eabdd ;_fg .Log .Trace ("\u002d\u0020\u0064\u0069\u0063\u0074\u003a\u0020\u0025\u0073",_eedg );for _ ,_cdee :=range _eedg .Keys (){_fegba :=_eedg .Get (_cdee );if _eddf ,_bdca :=_fegba .(*PdfObjectReference );_bdca {_bded :=_eddf .Resolve ();_eedg .Set (_cdee ,_bded );_gedad :=_cggd (_bded ,_cefc +1,_edebc );if _gedad !=nil {return _gedad ;};}else {_cdea :=_cggd (_fegba ,_cefc +1,_edebc );if _cdea !=nil {return _cdea ;};};};return nil ;case *PdfObjectArray :_cgeb :=_eabdd ;_fg .Log .Trace ("-\u0020\u0061\u0072\u0072\u0061\u0079\u003a\u0020\u0025\u0073",_cgeb );for _aeedd ,_eabae :=range _cgeb .Elements (){if _bgbdf ,_cdbd :=_eabae .(*PdfObjectReference );_cdbd {_afbbg :=_bgbdf .Resolve ();_cgeb .Set (_aeedd ,_afbbg );_fced :=_cggd (_afbbg ,_cefc +1,_edebc );if _fced !=nil {return _fced ;};}else {_fbeaf :=_cggd (_eabae ,_cefc +1,_edebc );if _fbeaf !=nil {return _fbeaf ;};};};return nil ;case *PdfObjectReference :_fg .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020T\u0072\u0061\u0063\u0069\u006e\u0067\u0020\u0061\u0020r\u0065\u0066\u0065r\u0065n\u0063\u0065\u0021");return _c .New ("\u0065r\u0072\u006f\u0072\u0020t\u0072\u0061\u0063\u0069\u006eg\u0020a\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");};return nil ;};

// GetXrefTable returns the PDFs xref table.
func (_acab *PdfParser )GetXrefTable ()XrefTable {return _acab ._cgbgg };

// EncodeBytes encodes the passed in slice of bytes by passing it through the
// EncodeBytes method of the underlying encoders.
func (_gbce *MultiEncoder )EncodeBytes (data []byte )([]byte ,error ){_eagde :=data ;var _eagg error ;for _adbc :=len (_gbce ._gba )-1;_adbc >=0;_adbc --{_decg :=_gbce ._gba [_adbc ];_eagde ,_eagg =_decg .EncodeBytes (_eagde );if _eagg !=nil {return nil ,_eagg ;};};return _eagde ,nil ;};

// IsNullObject returns true if `obj` is a PdfObjectNull.
func IsNullObject (obj PdfObject )bool {_ ,_bgdgg :=TraceToDirectObject (obj ).(*PdfObjectNull );return _bgdgg ;};func (_efgf *PdfParser )parseArray ()(*PdfObjectArray ,error ){_abcc :=MakeArray ();_efgf ._daba .ReadByte ();for {_efgf .skipSpaces ();_addb ,_fbfb :=_efgf ._daba .Peek (1);if _fbfb !=nil {return _abcc ,_fbfb ;};if _addb [0]==']'{_efgf ._daba .ReadByte ();break ;};_aafc ,_fbfb :=_efgf .parseObject ();if _fbfb !=nil {return _abcc ,_fbfb ;};_abcc .Append (_aafc );};return _abcc ,nil ;};

// DecodeBytes decodes a slice of Flate encoded bytes and returns the result.
func (_ccf *FlateEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_fg .Log .Trace ("\u0046\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065\u0020b\u0079\u0074\u0065\u0073");if len (encoded )==0{_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0046\u006c\u0061\u0074\u0065 e\u006ec\u006f\u0064\u0065\u0064\u0020\u0062\u0075\u0066\u0066\u0065\u0072\u002e \u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0062y\u0074\u0065\u0020\u0073\u006c\u0069\u0063\u0065\u002e");return []byte {},nil ;};_ccg :=_gcd .NewReader (encoded );_cbfb ,_fdcc :=_d .NewReader (_ccg );if _fdcc !=nil {_fg .Log .Debug ("\u0044e\u0063o\u0064\u0069\u006e\u0067\u0020e\u0072\u0072o\u0072\u0020\u0025\u0076\u000a",_fdcc );_fg .Log .Debug ("\u0053t\u0072e\u0061\u006d\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (encoded ),encoded );return nil ,_fdcc ;};defer _cbfb .Close ();var _gea _gcd .Buffer ;_gea .ReadFrom (_cbfb );return _gea .Bytes (),nil ;};

// PdfObjectStreams represents the primitive PDF object streams.
// 7.5.7 Object Streams (page 45).
type PdfObjectStreams struct{PdfObjectReference ;_gfcee []PdfObject ;};

// IsEncrypted checks if the document is encrypted. A bool flag is returned indicating the result.
// First time when called, will check if the Encrypt dictionary is accessible through the trailer dictionary.
// If encrypted, prepares a crypt datastructure which can be used to authenticate and decrypt the document.
// On failure, an error is returned.
func (_dbeb *PdfParser )IsEncrypted ()(bool ,error ){if _dbeb ._abd !=nil {return true ,nil ;}else if _dbeb ._eaeb ==nil {return false ,nil ;};_fg .Log .Trace ("\u0043\u0068\u0065c\u006b\u0069\u006e\u0067 \u0065\u006e\u0063\u0072\u0079\u0070\u0074i\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0021");_dgdbd :=_dbeb ._eaeb .Get ("\u0045n\u0063\u0072\u0079\u0070\u0074");if _dgdbd ==nil {return false ,nil ;};_fg .Log .Trace ("\u0049\u0073\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u0021");var (_gdadb *PdfObjectDictionary ;);switch _dfgbf :=_dgdbd .(type ){case *PdfObjectDictionary :_gdadb =_dfgbf ;case *PdfObjectReference :_fg .Log .Trace ("\u0030\u003a\u0020\u004c\u006f\u006f\u006b\u0020\u0075\u0070\u0020\u0072e\u0066\u0020\u0025\u0071",_dfgbf );_abbfb ,_dabe :=_dbeb .LookupByReference (*_dfgbf );_fg .Log .Trace ("\u0031\u003a\u0020%\u0071",_abbfb );if _dabe !=nil {return false ,_dabe ;};_bdad ,_dfcg :=_abbfb .(*PdfIndirectObject );if !_dfcg {_fg .Log .Debug ("E\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006eo\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072ec\u0074\u0020\u006fb\u006ae\u0063\u0074");return false ,_c .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");};_aaebc ,_dfcg :=_bdad .PdfObject .(*PdfObjectDictionary );_fg .Log .Trace ("\u0032\u003a\u0020%\u0071",_aaebc );if !_dfcg {return false ,_c .New ("\u0074\u0072a\u0069\u006c\u0065\u0072 \u0045\u006ec\u0072\u0079\u0070\u0074\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u006e\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");};_gdadb =_aaebc ;case *PdfObjectNull :_fg .Log .Debug ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074 \u0069\u0073\u0020a\u0020\u006e\u0075l\u006c\u0020o\u0062\u006a\u0065\u0063\u0074\u002e \u0046il\u0065\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u002e");return false ,nil ;default:return false ,_gc .Errorf ("u\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0079\u0070\u0065: \u0025\u0054",_dfgbf );};_fgfab ,_ebcf :=PdfCryptNewDecrypt (_dbeb ,_gdadb ,_dbeb ._eaeb );if _ebcf !=nil {return false ,_ebcf ;};for _ ,_badfg :=range []string {"\u0045n\u0063\u0072\u0079\u0070\u0074"}{_afbae :=_dbeb ._eaeb .Get (PdfObjectName (_badfg ));if _afbae ==nil {continue ;};switch _fdfc :=_afbae .(type ){case *PdfObjectReference :_fgfab ._cdbg [int (_fdfc .ObjectNumber )]=struct{}{};case *PdfIndirectObject :_fgfab ._cc [_fdfc ]=true ;_fgfab ._cdbg [int (_fdfc .ObjectNumber )]=struct{}{};};};_dbeb ._abd =_fgfab ;_fg .Log .Trace ("\u0043\u0072\u0079\u0070\u0074\u0065\u0072\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0025\u0062",_fgfab );return true ,nil ;};

// ASCII85Encoder implements ASCII85 encoder/decoder.
type ASCII85Encoder struct{};

// Str returns the string value of the PdfObjectString. Defined in addition to String() function to clarify that
// this function returns the underlying string directly, whereas the String function technically could include
// debug info.
func (_abce *PdfObjectString )Str ()string {return _abce ._abgc };