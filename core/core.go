//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package core defines and implements the primitive PDF object types in golang, and provides functionality
// for parsing those from a PDF file stream. This includes I/O handling, cross references, repairs, encryption,
// encoding and other core capabilities.
package core ;import (_dg "bufio";_ced "bytes";_e "compress/lzw";_d "compress/zlib";_aa "crypto/md5";_ea "crypto/rand";_a "encoding/hex";_g "errors";_ce "fmt";_cab "github.com/unidoc/unipdf/v3/common";_bd "github.com/unidoc/unipdf/v3/core/security";_de "github.com/unidoc/unipdf/v3/core/security/crypt";_gf "github.com/unidoc/unipdf/v3/internal/ccittfax";_cedb "github.com/unidoc/unipdf/v3/internal/imageutil";_ac "github.com/unidoc/unipdf/v3/internal/jbig2";_ef "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_beb "github.com/unidoc/unipdf/v3/internal/jbig2/decoder";_ag "github.com/unidoc/unipdf/v3/internal/jbig2/document";_eea "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_gcf "github.com/unidoc/unipdf/v3/internal/strutils";_db "golang.org/x/image/tiff/lzw";_be "golang.org/x/xerrors";_gd "image";_ca "image/color";_gc "image/jpeg";_ge "io";_b "reflect";_cc "regexp";_c "sort";_ga "strconv";_ee "strings";_gb "time";);var _bddf =_cc .MustCompile ("\u005e\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");

// EncodeBytes encodes slice of bytes into JBIG2 encoding format.
// The input 'data' must be an image. In order to Decode it a user is responsible to
// load the codec ('png', 'jpg').
// Returns jbig2 single page encoded document byte slice. The encoder uses DefaultPageSettings
// to encode given image.
func (_dcfd *JBIG2Encoder )EncodeBytes (data []byte )([]byte ,error ){const _adgf ="\u004aB\u0049\u0047\u0032\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002eE\u006e\u0063\u006f\u0064\u0065\u0042\u0079\u0074\u0065\u0073";if _dcfd .ColorComponents !=1||_dcfd .BitsPerComponent !=1{return nil ,_eea .Errorf (_adgf ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u002e\u0020\u004a\u0042\u0049G\u0032\u0020E\u006e\u0063o\u0064\u0065\u0072\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020bi\u006e\u0061\u0072\u0079\u0020\u0069\u006d\u0061\u0067e\u0073\u0020\u0064\u0061\u0074\u0061");};var (_dbfd *_ef .Bitmap ;_aeea error ;);_edcb :=(_dcfd .Width *_dcfd .Height )==len (data );if _edcb {_dbfd ,_aeea =_ef .NewWithUnpaddedData (_dcfd .Width ,_dcfd .Height ,data );}else {_dbfd ,_aeea =_ef .NewWithData (_dcfd .Width ,_dcfd .Height ,data );};if _aeea !=nil {return nil ,_aeea ;};_gcfge :=_dcfd .DefaultPageSettings ;if _aeea =_gcfge .Validate ();_aeea !=nil {return nil ,_eea .Wrap (_aeea ,_adgf ,"");};switch _gcfge .Compression {case JB2Generic :if _aeea =_dcfd ._adfd .AddGenericPage (_dbfd ,_gcfge .DuplicatedLinesRemoval );_aeea !=nil {return nil ,_eea .Wrap (_aeea ,_adgf ,"");};case JB2SymbolCorrelation :return nil ,_eea .Error (_adgf ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");case JB2SymbolRankHaus :return nil ,_eea .Error (_adgf ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");default:return nil ,_eea .Error (_adgf ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return _dcfd .Encode ();};const _bdcc ="\u0053\u0074\u0064C\u0046";

// PdfIndirectObject represents the primitive PDF indirect object.
type PdfIndirectObject struct{PdfObjectReference ;PdfObject ;};

// UpdateParams updates the parameter values of the encoder.
func (_efda *CCITTFaxEncoder )UpdateParams (params *PdfObjectDictionary ){if _fffce ,_adag :=GetNumberAsInt64 (params .Get ("\u004b"));_adag ==nil {_efda .K =int (_fffce );};if _cggae ,_bgg :=GetNumberAsInt64 (params .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));_bgg ==nil {_efda .Columns =int (_cggae );}else if _cggae ,_bgg =GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));_bgg ==nil {_efda .Columns =int (_cggae );};if _gagf ,_fadg :=GetNumberAsInt64 (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_fadg ==nil {_efda .BlackIs1 =_gagf > 0;}else {if _gcg ,_fded :=GetBoolVal (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_fded {_efda .BlackIs1 =_gcg ;}else {if _cba ,_deafc :=GetArray (params .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));_deafc {_cfag ,_bgff :=_cba .ToIntegerArray ();if _bgff ==nil {_efda .BlackIs1 =_cfag [0]==1&&_cfag [1]==0;};};};};if _cfbd ,_ede :=GetNumberAsInt64 (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_ede ==nil {_efda .EncodedByteAlign =_cfbd > 0;}else {if _gbc ,_dgcf :=GetBoolVal (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_dgcf {_efda .EncodedByteAlign =_gbc ;};};if _edac ,_ebaa :=GetNumberAsInt64 (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_ebaa ==nil {_efda .EndOfLine =_edac > 0;}else {if _eddb ,_gdd :=GetBoolVal (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_gdd {_efda .EndOfLine =_eddb ;};};if _bgdb ,_bbcg :=GetNumberAsInt64 (params .Get ("\u0052\u006f\u0077\u0073"));_bbcg ==nil {_efda .Rows =int (_bgdb );}else if _bgdb ,_bbcg =GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));_bbcg ==nil {_efda .Rows =int (_bgdb );};if _bffa ,_ggeg :=GetNumberAsInt64 (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_ggeg ==nil {_efda .EndOfBlock =_bffa > 0;}else {if _gfcc ,_gcfg :=GetBoolVal (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_gcfg {_efda .EndOfBlock =_gfcc ;};};if _gdbe ,_agce :=GetNumberAsInt64 (params .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));_agce !=nil {_efda .DamagedRowsBeforeError =int (_gdbe );};};func (_daed *PdfParser )parseXref ()(*PdfObjectDictionary ,error ){const _bfdf =20;_afbf ,_ :=_daed ._afbd .Peek (_bfdf );for _dceb :=0;_dceb < 2;_dceb ++{if _daed ._dbbdf ==0{_daed ._dbbdf =_daed .GetFileOffset ();};if _gcfd .Match (_afbf ){_cab .Log .Trace ("\u0078\u0072e\u0066\u0020\u0070\u006f\u0069\u006e\u0074\u0073\u0020\u0074\u006f\u0020\u0061\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u002e\u0020\u0050\u0072\u006f\u0062\u0061\u0062\u006c\u0079\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063\u0074");_cab .Log .Debug ("\u0073t\u0061r\u0074\u0069\u006e\u0067\u0020w\u0069\u0074h\u0020\u0022\u0025\u0073\u0022",string (_afbf ));return _daed .parseXrefStream (nil );};if _aefge .Match (_afbf ){_cab .Log .Trace ("\u0053\u0074\u0061\u006ed\u0061\u0072\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073e\u0063t\u0069\u006f\u006e\u0020\u0074\u0061\u0062l\u0065\u0021");return _daed .parseXrefTable ();};_fagcd :=_daed .GetFileOffset ();if _daed ._dbbdf ==0{_daed ._dbbdf =_fagcd ;};_daed .SetFileOffset (_fagcd -_bfdf );defer _daed .SetFileOffset (_fagcd );_gadfe ,_ :=_daed ._afbd .Peek (_bfdf );_afbf =append (_gadfe ,_afbf ...);};_cab .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u0078\u0072\u0065f\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006fr\u0020\u0073\u0074\u0072\u0065\u0061\u006d.\u0020\u0052\u0065\u0070\u0061i\u0072\u0020\u0061\u0074\u0074e\u006d\u0070\u0074\u0065\u0064\u003a\u0020\u004c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0065\u0061\u0072\u006c\u0069\u0065\u0073\u0074\u0020x\u0072\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u0062\u006f\u0074to\u006d\u002e");if _dddaf :=_daed .repairSeekXrefMarker ();_dddaf !=nil {_cab .Log .Debug ("\u0052e\u0070a\u0069\u0072\u0020\u0066\u0061i\u006c\u0065d\u0020\u002d\u0020\u0025\u0076",_dddaf );return nil ,_dddaf ;};return _daed .parseXrefTable ();};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_gdcb *MultiEncoder )MakeStreamDict ()*PdfObjectDictionary {_agegg :=MakeDict ();_agegg .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",_gdcb .GetFilterArray ());for _ ,_bfag :=range _gdcb ._dffc {_bffb :=_bfag .MakeStreamDict ();for _ ,_aadec :=range _bffb .Keys (){_decb :=_bffb .Get (_aadec );if _aadec !="\u0046\u0069\u006c\u0074\u0065\u0072"&&_aadec !="D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"{_agegg .Set (_aadec ,_decb );};};};_adfc :=_gdcb .MakeDecodeParams ();if _adfc !=nil {_agegg .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_adfc );};return _agegg ;};

// ReadAtLeast reads at least n bytes into slice p.
// Returns the number of bytes read (should always be == n), and an error on failure.
func (_fdfb *PdfParser )ReadAtLeast (p []byte ,n int )(int ,error ){_gaeg :=n ;_ceaff :=0;_bfef :=0;for _gaeg > 0{_bfaca ,_ccee :=_fdfb ._afbd .Read (p [_ceaff :]);if _ccee !=nil {_cab .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061d\u0069\u006e\u0067\u0020\u0028\u0025\u0064\u003b\u0025\u0064\u0029\u0020\u0025\u0073",_bfaca ,_bfef ,_ccee .Error ());return _ceaff ,_g .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065a\u0064\u0069\u006e\u0067");};_bfef ++;_ceaff +=_bfaca ;_gaeg -=_bfaca ;};return _ceaff ,nil ;};

// DecodeStream decodes a DCT encoded stream and returns the result as a
// slice of bytes.
func (_ffcbf *DCTEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _ffcbf .DecodeBytes (streamObj .Stream );};type encryptDict struct{Filter string ;V int ;SubFilter string ;Length int ;StmF string ;StrF string ;EFF string ;CF map[string ]_de .FilterDict ;};

// WriteString outputs the object as it is to be written to file.
func (_gbae *PdfObjectStreams )WriteString ()string {var _gefge _ee .Builder ;_gefge .WriteString (_ga .FormatInt (_gbae .ObjectNumber ,10));_gefge .WriteString ("\u0020\u0030\u0020\u0052");return _gefge .String ();};

// PdfObjectInteger represents the primitive PDF integer numerical object.
type PdfObjectInteger int64 ;

// PdfObjectBool represents the primitive PDF boolean object.
type PdfObjectBool bool ;

// GetString returns the *PdfObjectString represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetString (obj PdfObject )(_abbbe *PdfObjectString ,_edge bool ){_abbbe ,_edge =TraceToDirectObject (obj ).(*PdfObjectString );return _abbbe ,_edge ;};

// GetFilterName returns the name of the encoding filter.
func (_dge *RunLengthEncoder )GetFilterName ()string {return StreamEncodingFilterNameRunLength };

// WriteString outputs the object as it is to be written to file.
func (_eaab *PdfObjectString )WriteString ()string {var _dbfac _ced .Buffer ;if _eaab ._cfde {_dcde :=_a .EncodeToString (_eaab .Bytes ());_dbfac .WriteString ("\u003c");_dbfac .WriteString (_dcde );_dbfac .WriteString ("\u003e");return _dbfac .String ();};_dgdf :=map[byte ]string {'\n':"\u005c\u006e",'\r':"\u005c\u0072",'\t':"\u005c\u0074",'\b':"\u005c\u0062",'\f':"\u005c\u0066",'(':"\u005c\u0028",')':"\u005c\u0029",'\\':"\u005c\u005c"};_dbfac .WriteString ("\u0028");for _baea :=0;_baea < len (_eaab ._gcfee );_baea ++{_agcbc :=_eaab ._gcfee [_baea ];if _gbcd ,_bdbaea :=_dgdf [_agcbc ];_bdbaea {_dbfac .WriteString (_gbcd );}else {_dbfac .WriteByte (_agcbc );};};_dbfac .WriteString ("\u0029");return _dbfac .String ();};func (_bcee *PdfObjectInteger )String ()string {return _ce .Sprintf ("\u0025\u0064",*_bcee )};

// Bytes returns the PdfObjectString content as a []byte array.
func (_adfg *PdfObjectString )Bytes ()[]byte {return []byte (_adfg ._gcfee )};

// Validate validates the page settings for the JBIG2 encoder.
func (_fbbfe JBIG2EncoderSettings )Validate ()error {const _efff ="\u0076a\u006ci\u0064\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065\u0072";if _fbbfe .Threshold < 0||_fbbfe .Threshold > 1.0{return _eea .Errorf (_efff ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074\u0068\u0072\u0065\u0073\u0068\u006f\u006c\u0064\u0020\u0076a\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0076\u0027 \u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0069\u006e\u0020\u0072\u0061n\u0067\u0065\u0020\u005b\u0030\u002e0\u002c\u0020\u0031.\u0030\u005d",_fbbfe .Threshold );};if _fbbfe .ResolutionX < 0{return _eea .Errorf (_efff ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0078\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_fbbfe .ResolutionX );};if _fbbfe .ResolutionY < 0{return _eea .Errorf (_efff ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0079\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_fbbfe .ResolutionY );};if _fbbfe .DefaultPixelValue !=0&&_fbbfe .DefaultPixelValue !=1{return _eea .Errorf (_efff ,"de\u0066\u0061u\u006c\u0074\u0020\u0070\u0069\u0078\u0065\u006c\u0020v\u0061\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0066o\u0072 \u0074\u0068\u0065\u0020\u0062\u0069\u0074\u003a \u007b0\u002c\u0031}",_fbbfe .DefaultPixelValue );};if _fbbfe .Compression !=JB2Generic {return _eea .Errorf (_efff ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065d\u0020\u0063\u006fm\u0070\u0072\u0065\u0073s\u0069\u006f\u006e\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");};return nil ;};

// GetNameVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetNameVal (obj PdfObject )(_efaa string ,_egda bool ){_bfaa ,_egda :=TraceToDirectObject (obj ).(*PdfObjectName );if _egda {return string (*_bfaa ),true ;};return ;};

// Set sets the dictionary's key -> val mapping entry. Overwrites if key already set.
func (_ccef *PdfObjectDictionary )Set (key PdfObjectName ,val PdfObject ){_ ,_debf :=_ccef ._agcee [key ];if !_debf {_ccef ._eafbb =append (_ccef ._eafbb ,key );};_ccef ._agcee [key ]=val ;};func (_gabbe *PdfParser )parseObject ()(PdfObject ,error ){_cab .Log .Trace ("\u0052e\u0061d\u0020\u0064\u0069\u0072\u0065c\u0074\u0020o\u0062\u006a\u0065\u0063\u0074");_gabbe .skipSpaces ();for {_eced ,_eebf :=_gabbe ._afbd .Peek (2);if _eebf !=nil {if _eebf !=_ge .EOF ||len (_eced )==0{return nil ,_eebf ;};if len (_eced )==1{_eced =append (_eced ,' ');};};_cab .Log .Trace ("\u0050e\u0065k\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u003a\u0020\u0025\u0073",string (_eced ));if _eced [0]=='/'{_ecce ,_dfaa :=_gabbe .parseName ();_cab .Log .Trace ("\u002d\u003e\u004ea\u006d\u0065\u003a\u0020\u0027\u0025\u0073\u0027",_ecce );return &_ecce ,_dfaa ;}else if _eced [0]=='('{_cab .Log .Trace ("\u002d>\u0053\u0074\u0072\u0069\u006e\u0067!");_addf ,_bbegb :=_gabbe .parseString ();return _addf ,_bbegb ;}else if _eced [0]=='['{_cab .Log .Trace ("\u002d\u003e\u0041\u0072\u0072\u0061\u0079\u0021");_cfbdg ,_aebc :=_gabbe .parseArray ();return _cfbdg ,_aebc ;}else if (_eced [0]=='<')&&(_eced [1]=='<'){_cab .Log .Trace ("\u002d>\u0044\u0069\u0063\u0074\u0021");_fdbe ,_eecbg :=_gabbe .ParseDict ();return _fdbe ,_eecbg ;}else if _eced [0]=='<'{_cab .Log .Trace ("\u002d\u003e\u0048\u0065\u0078\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0021");_abefb ,_cabd :=_gabbe .parseHexString ();return _abefb ,_cabd ;}else if _eced [0]=='%'{_gabbe .readComment ();_gabbe .skipSpaces ();}else {_cab .Log .Trace ("\u002d\u003eN\u0075\u006d\u0062e\u0072\u0020\u006f\u0072\u0020\u0072\u0065\u0066\u003f");_eced ,_ =_gabbe ._afbd .Peek (15);_gggd :=string (_eced );_cab .Log .Trace ("\u0050\u0065\u0065k\u0020\u0073\u0074\u0072\u003a\u0020\u0025\u0073",_gggd );if (len (_gggd )> 3)&&(_gggd [:4]=="\u006e\u0075\u006c\u006c"){_eggc ,_fab :=_gabbe .parseNull ();return &_eggc ,_fab ;}else if (len (_gggd )> 4)&&(_gggd [:5]=="\u0066\u0061\u006cs\u0065"){_bdg ,_cgcb :=_gabbe .parseBool ();return &_bdg ,_cgcb ;}else if (len (_gggd )> 3)&&(_gggd [:4]=="\u0074\u0072\u0075\u0065"){_cbbe ,_cfbgf :=_gabbe .parseBool ();return &_cbbe ,_cfbgf ;};_gbfae :=_deff .FindStringSubmatch (_gggd );if len (_gbfae )> 1{_eced ,_ =_gabbe ._afbd .ReadBytes ('R');_cab .Log .Trace ("\u002d\u003e\u0020\u0021\u0052\u0065\u0066\u003a\u0020\u0027\u0025\u0073\u0027",string (_eced [:]));_cgbac ,_gdcg :=_dcgb (string (_eced ));_cgbac ._eddcb =_gabbe ;return &_cgbac ,_gdcg ;};_cgbgc :=_bddf .FindStringSubmatch (_gggd );if len (_cgbgc )> 1{_cab .Log .Trace ("\u002d\u003e\u0020\u004e\u0075\u006d\u0062\u0065\u0072\u0021");_fabe ,_cgbf :=_gabbe .parseNumber ();return _fabe ,_cgbf ;};_cgbgc =_cadf .FindStringSubmatch (_gggd );if len (_cgbgc )> 1{_cab .Log .Trace ("\u002d\u003e\u0020\u0045xp\u006f\u006e\u0065\u006e\u0074\u0069\u0061\u006c\u0020\u004e\u0075\u006d\u0062\u0065r\u0021");_cab .Log .Trace ("\u0025\u0020\u0073",_cgbgc );_ffcf ,_gfbd :=_gabbe .parseNumber ();return _ffcf ,_gfbd ;};_cab .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020U\u006e\u006b\u006e\u006f\u0077n\u0020(\u0070e\u0065\u006b\u0020\u0022\u0025\u0073\u0022)",_gggd );return nil ,_g .New ("\u006f\u0062\u006a\u0065\u0063t\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020\u0075\u006e\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e");};};};

// NewLZWEncoder makes a new LZW encoder with default parameters.
func NewLZWEncoder ()*LZWEncoder {_caef :=&LZWEncoder {};_caef .Predictor =1;_caef .BitsPerComponent =8;_caef .Colors =1;_caef .Columns =1;_caef .EarlyChange =1;return _caef ;};func (_cdcd *PdfParser )parseXrefStream (_afbc *PdfObjectInteger )(*PdfObjectDictionary ,error ){if _afbc !=nil {_cab .Log .Trace ("\u0058\u0052\u0065f\u0053\u0074\u006d\u0020x\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0061\u0074\u0020\u0025\u0064",_afbc );_cdcd ._bfca .Seek (int64 (*_afbc ),_ge .SeekStart );_cdcd ._afbd =_dg .NewReader (_cdcd ._bfca );};_ecfbf :=_cdcd .GetFileOffset ();_aecf ,_egdc :=_cdcd .ParseIndirectObject ();if _egdc !=nil {_cab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072\u0065\u0061d\u0020\u0078\u0072\u0065\u0066\u0020\u006fb\u006a\u0065\u0063\u0074");return nil ,_g .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072e\u0061\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062j\u0065\u0063\u0074");};_cab .Log .Trace ("\u0058R\u0065f\u0053\u0074\u006d\u0020\u006fb\u006a\u0065c\u0074\u003a\u0020\u0025\u0073",_aecf );_dcag ,_gabdf :=_aecf .(*PdfObjectStream );if !_gabdf {_cab .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0058R\u0065\u0066\u0053\u0074\u006d\u0020\u0070o\u0069\u006e\u0074\u0069\u006e\u0067 \u0074\u006f\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065a\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0021");return nil ,_g .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0070\u006f\u0069\u006e\u0074i\u006e\u0067\u0020\u0074\u006f\u0020a\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006fb\u006a\u0065\u0063\u0074");};_dfcc :=_dcag .PdfObjectDictionary ;_gcfa ,_gabdf :=_dcag .PdfObjectDictionary .Get ("\u0053\u0069\u007a\u0065").(*PdfObjectInteger );if !_gabdf {_cab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u004d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0073\u0069\u007a\u0065\u0020f\u0072\u006f\u006d\u0020\u0078\u0072\u0065f\u0020\u0073\u0074\u006d");return nil ,_g .New ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0053\u0069\u007ae\u0020\u0066\u0072\u006f\u006d\u0020\u0078\u0072\u0065\u0066 \u0073\u0074\u006d");};if int64 (*_gcfa )> 8388607{_cab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u0053\u0069\u007a\u0065\u0020\u0065x\u0063\u0065\u0065\u0064\u0065\u0064\u0020l\u0069\u006d\u0069\u0074\u002c\u0020\u006f\u0076\u0065\u0072\u00208\u0033\u0038\u0038\u0036\u0030\u0037\u0020\u0028\u0025\u0064\u0029",*_gcfa );return nil ,_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_dfeg :=_dcag .PdfObjectDictionary .Get ("\u0057");_daaae ,_gabdf :=_dfeg .(*PdfObjectArray );if !_gabdf {return nil ,_g .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0057\u0020\u0069\u006e\u0020x\u0072\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d");};_fddg :=_daaae .Len ();if _fddg !=3{_cab .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020\u0028\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033\u0020\u002d\u0020\u0025\u0064\u0029",_fddg );return nil ,_g .New ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065f\u0020s\u0074\u006d\u0020\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033");};var _bgdc []int64 ;for _cbde :=0;_cbde < 3;_cbde ++{_ecaa ,_eabb :=GetInt (_daaae .Get (_cbde ));if !_eabb {return nil ,_g .New ("i\u006e\u0076\u0061\u006cid\u0020w\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0074\u0079\u0070\u0065");};_bgdc =append (_bgdc ,int64 (*_ecaa ));};_eadc ,_egdc :=DecodeStream (_dcag );if _egdc !=nil {_cab .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020t\u006f \u0064e\u0063o\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u003a\u0020\u0025\u0076",_egdc );return nil ,_egdc ;};_eedb :=int (_bgdc [0]);_facg :=int (_bgdc [0]+_bgdc [1]);_cfec :=int (_bgdc [0]+_bgdc [1]+_bgdc [2]);_cfga :=int (_bgdc [0]+_bgdc [1]+_bgdc [2]);if _eedb < 0||_facg < 0||_cfec < 0{_cab .Log .Debug ("\u0045\u0072\u0072\u006fr\u0020\u0073\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u003c \u0030 \u0028\u0025\u0064\u002c\u0025\u0064\u002c%\u0064\u0029",_eedb ,_facg ,_cfec );return nil ,_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};if _cfga ==0{_cab .Log .Debug ("\u004e\u006f\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063t\u0073\u0020\u0069\u006e\u0020\u0073t\u0072\u0065\u0061\u006d\u0020\u0028\u0064\u0065\u006c\u0074\u0061\u0062\u0020=\u003d\u0020\u0030\u0029");return _dfcc ,nil ;};_aacf :=len (_eadc )/_cfga ;_cadfa :=0;_feca :=_dcag .PdfObjectDictionary .Get ("\u0049\u006e\u0064e\u0078");var _baeg []int ;if _feca !=nil {_cab .Log .Trace ("\u0049n\u0064\u0065\u0078\u003a\u0020\u0025b",_feca );_dfbe ,_egea :=_feca .(*PdfObjectArray );if !_egea {_cab .Log .Debug ("\u0049\u006e\u0076\u0061\u006ci\u0064\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0029");return nil ,_g .New ("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0049\u006e\u0064e\u0078\u0020\u006f\u0062je\u0063\u0074");};if _dfbe .Len ()%2!=0{_cab .Log .Debug ("\u0057\u0041\u0052\u004eI\u004e\u0047\u0020\u0046\u0061\u0069\u006c\u0075\u0072e\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020i\u006e\u0064\u0065\u0078\u0020n\u006f\u0074\u0020\u006d\u0075\u006c\u0074\u0069\u0070\u006c\u0065\u0020\u006f\u0066\u0020\u0032\u002e");return nil ,_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_cadfa =0;_fbgd ,_dcff :=_dfbe .ToIntegerArray ();if _dcff !=nil {_cab .Log .Debug ("\u0045\u0072\u0072\u006f\u0072 \u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0065\u0078 \u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0073\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0073\u003a\u0020\u0025\u0076",_dcff );return nil ,_dcff ;};for _afee :=0;_afee < len (_fbgd );_afee +=2{_faaba :=_fbgd [_afee ];_fbdd :=_fbgd [_afee +1];for _cdeb :=0;_cdeb < _fbdd ;_cdeb ++{_baeg =append (_baeg ,_faaba +_cdeb );};_cadfa +=_fbdd ;};}else {for _afac :=0;_afac < int (*_gcfa );_afac ++{_baeg =append (_baeg ,_afac );};_cadfa =int (*_gcfa );};if _aacf ==_cadfa +1{_cab .Log .Debug ("\u0049n\u0063\u006f\u006d\u0070ati\u0062\u0069\u006c\u0069t\u0079\u003a\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006di\u0073\u0073\u0069\u006e\u0067\u0020\u0063\u006f\u0076\u0065\u0072\u0061\u0067\u0065\u0020\u006f\u0066\u0020\u0031\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u002d\u0020\u0061\u0070\u0070en\u0064\u0069\u006eg\u0020\u006f\u006e\u0065\u0020-\u0020M\u0061\u0079\u0020\u006c\u0065\u0061\u0064\u0020\u0074o\u0020\u0070\u0072\u006f\u0062\u006c\u0065\u006d\u0073");_ccbd :=_cadfa -1;for _ ,_gbaba :=range _baeg {if _gbaba > _ccbd {_ccbd =_gbaba ;};};_baeg =append (_baeg ,_ccbd +1);_cadfa ++;};if _aacf !=len (_baeg ){_cab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020x\u0072\u0065\u0066 \u0073\u0074\u006d:\u0020\u006eu\u006d\u0020\u0065\u006e\u0074\u0072i\u0065s \u0021\u003d\u0020\u006c\u0065\u006e\u0028\u0069\u006e\u0064\u0069\u0063\u0065\u0073\u0029\u0020\u0028\u0025\u0064\u0020\u0021\u003d\u0020\u0025\u0064\u0029",_aacf ,len (_baeg ));return nil ,_g .New ("\u0078\u0072ef\u0020\u0073\u0074m\u0020\u006e\u0075\u006d en\u0074ri\u0065\u0073\u0020\u0021\u003d\u0020\u006cen\u0028\u0069\u006e\u0064\u0069\u0063\u0065s\u0029");};_cab .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074s\u0020\u0063\u006f\u0075\u006e\u0074\u0020\u0025\u0064",_cadfa );_cab .Log .Trace ("\u0049\u006e\u0064i\u0063\u0065\u0073\u003a\u0020\u0025\u0020\u0064",_baeg );_ebff :=func (_bcgff []byte )int64 {var _aedb int64 ;for _cffg :=0;_cffg < len (_bcgff );_cffg ++{_aedb +=int64 (_bcgff [_cffg ])*(1<<uint (8*(len (_bcgff )-_cffg -1)));};return _aedb ;};_cab .Log .Trace ("\u0044e\u0063\u006f\u0064\u0065d\u0020\u0073\u0074\u0072\u0065a\u006d \u006ce\u006e\u0067\u0074\u0068\u003a\u0020\u0025d",len (_eadc ));_ggac :=0;for _bgbg :=0;_bgbg < len (_eadc );_bgbg +=_cfga {_dbdgd :=_beed (len (_eadc ),_bgbg ,_bgbg +_eedb );if _dbdgd !=nil {_cab .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_dbdgd );return nil ,_dbdgd ;};_edbe :=_eadc [_bgbg :_bgbg +_eedb ];_dbdgd =_beed (len (_eadc ),_bgbg +_eedb ,_bgbg +_facg );if _dbdgd !=nil {_cab .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_dbdgd );return nil ,_dbdgd ;};_ebae :=_eadc [_bgbg +_eedb :_bgbg +_facg ];_dbdgd =_beed (len (_eadc ),_bgbg +_facg ,_bgbg +_cfec );if _dbdgd !=nil {_cab .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_dbdgd );return nil ,_dbdgd ;};_aagb :=_eadc [_bgbg +_facg :_bgbg +_cfec ];_dbffa :=_ebff (_edbe );_adfea :=_ebff (_ebae );_adfa :=_ebff (_aagb );if _bgdc [0]==0{_dbffa =1;};if _ggac >=len (_baeg ){_cab .Log .Debug ("X\u0052\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u002d\u0020\u0054\u0072\u0079\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0061\u0063\u0063e\u0073s\u0020\u0069\u006e\u0064e\u0078\u0020o\u0075\u0074\u0020\u006f\u0066\u0020\u0062\u006f\u0075\u006e\u0064\u0073\u0020\u002d\u0020\u0062\u0072\u0065\u0061\u006b\u0069\u006e\u0067");break ;};_bbg :=_baeg [_ggac ];_ggac ++;_cab .Log .Trace ("%\u0064\u002e\u0020\u0070\u0031\u003a\u0020\u0025\u0020\u0078",_bbg ,_edbe );_cab .Log .Trace ("%\u0064\u002e\u0020\u0070\u0032\u003a\u0020\u0025\u0020\u0078",_bbg ,_ebae );_cab .Log .Trace ("%\u0064\u002e\u0020\u0070\u0033\u003a\u0020\u0025\u0020\u0078",_bbg ,_aagb );_cab .Log .Trace ("\u0025d\u002e \u0078\u0072\u0065\u0066\u003a \u0025\u0064 \u0025\u0064\u0020\u0025\u0064",_bbg ,_dbffa ,_adfea ,_adfa );if _dbffa ==0{_cab .Log .Trace ("-\u0020\u0046\u0072\u0065\u0065\u0020o\u0062\u006a\u0065\u0063\u0074\u0020-\u0020\u0063\u0061\u006e\u0020\u0070\u0072o\u0062\u0061\u0062\u006c\u0079\u0020\u0069\u0067\u006e\u006fr\u0065");}else if _dbffa ==1{_cab .Log .Trace ("\u002d\u0020I\u006e\u0020\u0075\u0073e\u0020\u002d \u0075\u006e\u0063\u006f\u006d\u0070\u0072\u0065s\u0073\u0065\u0064\u0020\u0076\u0069\u0061\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0062",_ebae );if _adfea ==_ecfbf {_cab .Log .Debug ("\u0055\u0070d\u0061\u0074\u0069\u006e\u0067\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0058\u0052\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0064",_bbg ,_dcag .ObjectNumber );_bbg =int (_dcag .ObjectNumber );};if _dcagg ,_bbegbg :=_cdcd ._adde .ObjectMap [_bbg ];!_bbegbg ||int (_adfa )> _dcagg .Generation {_ffbg :=XrefObject {ObjectNumber :_bbg ,XType :XrefTypeTableEntry ,Offset :_adfea ,Generation :int (_adfa )};_cdcd ._adde .ObjectMap [_bbg ]=_ffbg ;};}else if _dbffa ==2{_cab .Log .Trace ("\u002d\u0020\u0049\u006e \u0075\u0073\u0065\u0020\u002d\u0020\u0063\u006f\u006d\u0070r\u0065s\u0073\u0065\u0064\u0020\u006f\u0062\u006ae\u0063\u0074");if _ ,_bcfa :=_cdcd ._adde .ObjectMap [_bbg ];!_bcfa {_fabed :=XrefObject {ObjectNumber :_bbg ,XType :XrefTypeObjectStream ,OsObjNumber :int (_adfea ),OsObjIndex :int (_adfa )};_cdcd ._adde .ObjectMap [_bbg ]=_fabed ;_cab .Log .Trace ("\u0065\u006e\u0074\u0072\u0079\u003a\u0020\u0025\u002b\u0076",_fabed );};}else {_cab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052:\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0056\u0041L\u0049\u0044\u0020\u0054\u0059\u0050\u0045\u0020\u0058\u0072\u0065\u0066\u0053\u0074\u006d\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u003f\u002d\u002d\u002d\u002d\u002d\u002d-");continue ;};};if _cdcd ._cggb ==nil {_dfbf :=XrefTypeObjectStream ;_cdcd ._cggb =&_dfbf ;};return _dfcc ,nil ;};func (_ddefag *PdfParser )parseXrefTable ()(*PdfObjectDictionary ,error ){var _aead *PdfObjectDictionary ;_fade ,_fdcd :=_ddefag .readTextLine ();if _fdcd !=nil {return nil ,_fdcd ;};_cab .Log .Trace ("\u0078\u0072\u0065\u0066 f\u0069\u0072\u0073\u0074\u0020\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_fade );_adca :=-1;_gcedge :=0;_beeb :=false ;_adea :="";for {_ddefag .skipSpaces ();_ ,_caed :=_ddefag ._afbd .Peek (1);if _caed !=nil {return nil ,_caed ;};_fade ,_caed =_ddefag .readTextLine ();if _caed !=nil {return nil ,_caed ;};_fdac :=_egf .FindStringSubmatch (_fade );if len (_fdac )==0{_gbga :=len (_adea )> 0;_adea +=_fade +"\u000a";if _gbga {_fdac =_egf .FindStringSubmatch (_adea );};};if len (_fdac )==3{_ccgf ,_ :=_ga .Atoi (_fdac [1]);_badf ,_ :=_ga .Atoi (_fdac [2]);_adca =_ccgf ;_gcedge =_badf ;_beeb =true ;_adea ="";_cab .Log .Trace ("\u0078r\u0065\u0066 \u0073\u0075\u0062s\u0065\u0063\u0074\u0069\u006f\u006e\u003a \u0066\u0069\u0072\u0073\u0074\u0020o\u0062\u006a\u0065\u0063\u0074\u003a\u0020\u0025\u0064\u0020\u006fb\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_adca ,_gcedge );continue ;};_ebddb :=_ccfc .FindStringSubmatch (_fade );if len (_ebddb )==4{if !_beeb {_cab .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0058r\u0065\u0066\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u006fr\u006da\u0074\u0021\u000a");return nil ,_g .New ("\u0078\u0072\u0065\u0066 i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072\u006d\u0061\u0074");};_bfae ,_ :=_ga .ParseInt (_ebddb [1],10,64);_aacda ,_ :=_ga .Atoi (_ebddb [2]);_gagc :=_ebddb [3];_adea ="";if _ee .ToLower (_gagc )=="\u006e"&&_bfae > 1{_adgbe ,_bdfd :=_ddefag ._adde .ObjectMap [_adca ];if !_bdfd ||_aacda > _adgbe .Generation {_bfceg :=XrefObject {ObjectNumber :_adca ,XType :XrefTypeTableEntry ,Offset :_bfae ,Generation :_aacda };_ddefag ._adde .ObjectMap [_adca ]=_bfceg ;};};_adca ++;continue ;};if (len (_fade )> 6)&&(_fade [:7]=="\u0074r\u0061\u0069\u006c\u0065\u0072"){_cab .Log .Trace ("\u0046o\u0075n\u0064\u0020\u0074\u0072\u0061i\u006c\u0065r\u0020\u002d\u0020\u0025\u0073",_fade );if len (_fade )> 9{_dcfa :=_ddefag .GetFileOffset ();_ddefag .SetFileOffset (_dcfa -int64 (len (_fade ))+7);};_ddefag .skipSpaces ();_ddefag .skipComments ();_cab .Log .Trace ("R\u0065\u0061\u0064\u0069ng\u0020t\u0072\u0061\u0069\u006c\u0065r\u0020\u0064\u0069\u0063\u0074\u0021");_cab .Log .Trace ("\u0070\u0065\u0065\u006b\u003a\u0020\u0022\u0025\u0073\u0022",_fade );_aead ,_caed =_ddefag .ParseDict ();_cab .Log .Trace ("\u0045O\u0046\u0020\u0072\u0065a\u0064\u0069\u006e\u0067\u0020t\u0072a\u0069l\u0065\u0072\u0020\u0064\u0069\u0063\u0074!");if _caed !=nil {_cab .Log .Debug ("\u0045\u0072\u0072o\u0072\u0020\u0070\u0061r\u0073\u0069\u006e\u0067\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u0064\u0069\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_caed );return nil ,_caed ;};break ;};if _fade =="\u0025\u0025\u0045O\u0046"{_cab .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006e\u0064 \u006f\u0066\u0020\u0066\u0069\u006c\u0065 -\u0020\u0074\u0072\u0061i\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066ou\u006e\u0064 \u002d\u0020\u0065\u0072\u0072\u006f\u0072\u0021");return nil ,_g .New ("\u0065\u006e\u0064 \u006f\u0066\u0020\u0066i\u006c\u0065\u0020\u002d\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};_cab .Log .Trace ("\u0078\u0072\u0065\u0066\u0020\u006d\u006f\u0072\u0065 \u003a\u0020\u0025\u0073",_fade );};_cab .Log .Trace ("\u0045\u004f\u0046 p\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0021");if _ddefag ._cggb ==nil {_efea :=XrefTypeTableEntry ;_ddefag ._cggb =&_efea ;};return _aead ,nil ;};

// AddPageImage adds the page with the image 'img' to the encoder context in order to encode it jbig2 document.
// The 'settings' defines what encoding type should be used by the encoder.
func (_bgc *JBIG2Encoder )AddPageImage (img *JBIG2Image ,settings *JBIG2EncoderSettings )(_cddc error ){const _aeac ="\u004a\u0042\u0049\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0041\u0064\u0064\u0050\u0061\u0067\u0065\u0049m\u0061\u0067\u0065";if _bgc ==nil {return _eea .Error (_aeac ,"J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u0020\u0069\u0073 n\u0069\u006c");};if settings ==nil {settings =&_bgc .DefaultPageSettings ;};if _bgc ._adfd ==nil {_bgc ._adfd =_ag .InitEncodeDocument (settings .FileMode );};if _cddc =settings .Validate ();_cddc !=nil {return _eea .Wrap (_cddc ,_aeac ,"");};_eddba ,_cddc :=img .toBitmap ();if _cddc !=nil {return _eea .Wrap (_cddc ,_aeac ,"");};switch settings .Compression {case JB2Generic :if _cddc =_bgc ._adfd .AddGenericPage (_eddba ,settings .DuplicatedLinesRemoval );_cddc !=nil {return _eea .Wrap (_cddc ,_aeac ,"");};case JB2SymbolCorrelation :return _eea .Error (_aeac ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");case JB2SymbolRankHaus :return _eea .Error (_aeac ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");default:return _eea .Error (_aeac ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return nil ;};

// String returns a string describing `null`.
func (_dccd *PdfObjectNull )String ()string {return "\u006e\u0075\u006c\u006c"};

// GetFilterName returns the name of the encoding filter.
func (_bfbe *ASCIIHexEncoder )GetFilterName ()string {return StreamEncodingFilterNameASCIIHex };

// Inspect analyzes the document object structure. Returns a map of object types (by name) with the instance count
// as value.
func (_cfbdc *PdfParser )Inspect ()(map[string ]int ,error ){return _cfbdc .inspect ()};func (_dcdf *PdfCrypt )encryptBytes (_dfad []byte ,_deaf string ,_ccec []byte )([]byte ,error ){_cab .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");_fgc ,_baadb :=_dcdf ._faa [_deaf ];if !_baadb {return nil ,_ce .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_deaf );};return _fgc .EncryptBytes (_dfad ,_ccec );};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_fbbg *ASCIIHexEncoder )MakeStreamDict ()*PdfObjectDictionary {_ddga :=MakeDict ();_ddga .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_fbbg .GetFilterName ()));return _ddga ;};

// ToIntegerArray returns a slice of all array elements as an int slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_baadd *PdfObjectArray )ToIntegerArray ()([]int ,error ){var _cefc []int ;for _ ,_afadc :=range _baadd .Elements (){if _gbfdb ,_befc :=_afadc .(*PdfObjectInteger );_befc {_cefc =append (_cefc ,int (*_gbfdb ));}else {return nil ,ErrTypeError ;};};return _cefc ,nil ;};

// RunLengthEncoder represents Run length encoding.
type RunLengthEncoder struct{};

// ReadBytesAt reads byte content at specific offset and length within the PDF.
func (_gaaga *PdfParser )ReadBytesAt (offset ,len int64 )([]byte ,error ){_ccge :=_gaaga .GetFileOffset ();_ ,_ffda :=_gaaga ._bfca .Seek (offset ,_ge .SeekStart );if _ffda !=nil {return nil ,_ffda ;};_fdcc :=make ([]byte ,len );_ ,_ffda =_ge .ReadAtLeast (_gaaga ._bfca ,_fdcc ,int (len ));if _ffda !=nil {return nil ,_ffda ;};_gaaga .SetFileOffset (_ccge );return _fdcc ,nil ;};func _dcgb (_bgddg string )(PdfObjectReference ,error ){_fbfc :=PdfObjectReference {};_gagg :=_deff .FindStringSubmatch (_bgddg );if len (_gagg )< 3{_cab .Log .Debug ("\u0045\u0072\u0072or\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");return _fbfc ,_g .New ("\u0075n\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061r\u0073e\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");};_abdba ,_ :=_ga .Atoi (_gagg [1]);_cdae ,_ :=_ga .Atoi (_gagg [2]);_fbfc .ObjectNumber =int64 (_abdba );_fbfc .GenerationNumber =int64 (_cdae );return _fbfc ,nil ;};func _abfa (_bfd int )cryptFilters {return cryptFilters {_bdcc :_de .NewFilterV2 (_bfd )}};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_gabd *JPXEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};

// GetAccessPermissions returns the PDF access permissions as an AccessPermissions object.
func (_ceaf *PdfCrypt )GetAccessPermissions ()_bd .Permissions {return _ceaf ._gfa .P };

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_gged *LZWEncoder )MakeDecodeParams ()PdfObject {if _gged .Predictor > 1{_aebb :=MakeDict ();_aebb .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_gged .Predictor )));if _gged .BitsPerComponent !=8{_aebb .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_gged .BitsPerComponent )));};if _gged .Columns !=1{_aebb .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_gged .Columns )));};if _gged .Colors !=1{_aebb .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_gged .Colors )));};return _aebb ;};return nil ;};var _dccf =_cc .MustCompile ("\u005b\\\u0072\u005c\u006e\u005d\u005c\u0073\u002a\u0028\u0078\u0072\u0065f\u0029\u005c\u0073\u002a\u005b\u005c\u0072\u005c\u006e\u005d");

// LZWEncoder provides LZW encoding/decoding functionality.
type LZWEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Colors int ;

// LZW algorithm setting.
EarlyChange int ;};func _edad (_deee int )int {if _deee < 0{return -_deee ;};return _deee ;};

// GetAsFloat64Slice returns the array as []float64 slice.
// Returns an error if not entirely numeric (only PdfObjectIntegers, PdfObjectFloats).
func (_feaf *PdfObjectArray )GetAsFloat64Slice ()([]float64 ,error ){var _fcab []float64 ;for _ ,_caab :=range _feaf .Elements (){_cebga ,_eabd :=GetNumberAsFloat (TraceToDirectObject (_caab ));if _eabd !=nil {return nil ,_ce .Errorf ("\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006e\u0075m\u0062\u0065\u0072");};_fcab =append (_fcab ,_cebga );};return _fcab ,nil ;};func (_egce *offsetReader )Seek (offset int64 ,whence int )(int64 ,error ){if whence ==_ge .SeekStart {offset +=_egce ._gcedg ;};_fgac ,_cgeb :=_egce ._edgc .Seek (offset ,whence );if _cgeb !=nil {return _fgac ,_cgeb ;};if whence ==_ge .SeekCurrent {_fgac -=_egce ._gcedg ;};if _fgac < 0{return 0,_g .New ("\u0063\u006f\u0072\u0065\u002eo\u0066\u0066\u0073\u0065\u0074\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053e\u0065\u006b\u003a\u0020\u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e");};return _fgac ,nil ;};func _agd (_deeg PdfObject )(int64 ,int64 ,error ){if _ad ,_cef :=_deeg .(*PdfIndirectObject );_cef {return _ad .ObjectNumber ,_ad .GenerationNumber ,nil ;};if _df ,_dbb :=_deeg .(*PdfObjectStream );_dbb {return _df .ObjectNumber ,_df .GenerationNumber ,nil ;};return 0,0,_g .New ("\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u002f\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062je\u0063\u0074");};func _aaad (_gedg *PdfObjectStream ,_abce *PdfObjectDictionary )(*CCITTFaxEncoder ,error ){_bddc :=NewCCITTFaxEncoder ();_defc :=_gedg .PdfObjectDictionary ;if _defc ==nil {return _bddc ,nil ;};if _abce ==nil {_eeaae :=TraceToDirectObject (_defc .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));if _eeaae !=nil {switch _dfcf :=_eeaae .(type ){case *PdfObjectDictionary :_abce =_dfcf ;case *PdfObjectArray :if _dfcf .Len ()==1{if _adgb ,_fgeed :=GetDict (_dfcf .Get (0));_fgeed {_abce =_adgb ;};};default:_cab .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_eeaae );return nil ,_g .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _abce ==nil {_cab .Log .Error ("\u0044\u0065c\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064 %\u0023\u0076",_eeaae );return nil ,_g .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _gbgc ,_eedg :=GetNumberAsInt64 (_abce .Get ("\u004b"));_eedg ==nil {_bddc .K =int (_gbgc );};if _eege ,_dbdd :=GetNumberAsInt64 (_abce .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));_dbdd ==nil {_bddc .Columns =int (_eege );}else {_bddc .Columns =1728;};if _ffdff ,_edcf :=GetNumberAsInt64 (_abce .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_edcf ==nil {_bddc .BlackIs1 =_ffdff > 0;}else {if _fbbfc ,_bbcc :=GetBoolVal (_abce .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_bbcc {_bddc .BlackIs1 =_fbbfc ;}else {if _adf ,_aefef :=GetArray (_abce .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));_aefef {_ddcf ,_adged :=_adf .ToIntegerArray ();if _adged ==nil {_bddc .BlackIs1 =_ddcf [0]==1&&_ddcf [1]==0;};};};};if _aae ,_gecf :=GetNumberAsInt64 (_abce .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_gecf ==nil {_bddc .EncodedByteAlign =_aae > 0;}else {if _ggg ,_abdd :=GetBoolVal (_abce .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_abdd {_bddc .EncodedByteAlign =_ggg ;};};if _abdf ,_gggb :=GetNumberAsInt64 (_abce .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_gggb ==nil {_bddc .EndOfLine =_abdf > 0;}else {if _cadg ,_aea :=GetBoolVal (_abce .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_aea {_bddc .EndOfLine =_cadg ;};};if _dbcf ,_ccca :=GetNumberAsInt64 (_abce .Get ("\u0052\u006f\u0077\u0073"));_ccca ==nil {_bddc .Rows =int (_dbcf );};_bddc .EndOfBlock =true ;if _dfafc ,_gdbfe :=GetNumberAsInt64 (_abce .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_gdbfe ==nil {_bddc .EndOfBlock =_dfafc > 0;}else {if _adfe ,_dgdg :=GetBoolVal (_abce .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_dgdg {_bddc .EndOfBlock =_adfe ;};};if _dbcd ,_gccgg :=GetNumberAsInt64 (_abce .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));_gccgg !=nil {_bddc .DamagedRowsBeforeError =int (_dbcd );};_cab .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_abce .String ());return _bddc ,nil ;};

// XrefTable represents the cross references in a PDF, i.e. the table of objects and information
// where to access within the PDF file.
type XrefTable struct{ObjectMap map[int ]XrefObject ;_cac []XrefObject ;};

// WriteString outputs the object as it is to be written to file.
func (_gafb *PdfObjectReference )WriteString ()string {var _ccd _ee .Builder ;_ccd .WriteString (_ga .FormatInt (_gafb .ObjectNumber ,10));_ccd .WriteString ("\u0020");_ccd .WriteString (_ga .FormatInt (_gafb .GenerationNumber ,10));_ccd .WriteString ("\u0020\u0052");return _ccd .String ();};func _dcb (_gcc XrefTable ){_cab .Log .Debug ("\u003dX\u003d\u0058\u003d\u0058\u003d");_cab .Log .Debug ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");_degg :=0;for _ ,_ffa :=range _gcc .ObjectMap {_cab .Log .Debug ("i\u002b\u0031\u003a\u0020\u0025\u0064 \u0028\u006f\u0062\u006a\u0020\u006eu\u006d\u003a\u0020\u0025\u0064\u0020\u0067e\u006e\u003a\u0020\u0025\u0064\u0029\u0020\u002d\u003e\u0020%\u0064",_degg +1,_ffa .ObjectNumber ,_ffa .Generation ,_ffa .Offset );_degg ++;};};

// DecodeStream decodes a JPX encoded stream and returns the result as a
// slice of bytes.
func (_dgcc *JPXEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_cab .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_dgcc .GetFilterName ());return streamObj .Stream ,ErrNoJPXDecode ;};

// MakeArrayFromIntegers creates an PdfObjectArray from a slice of ints, where each array element is
// an PdfObjectInteger.
func MakeArrayFromIntegers (vals []int )*PdfObjectArray {_afcb :=MakeArray ();for _ ,_dccg :=range vals {_afcb .Append (MakeInteger (int64 (_dccg )));};return _afcb ;};

// DecodeBytes decodes a byte slice from Run length encoding.
//
// 7.4.5 RunLengthDecode Filter
// The RunLengthDecode filter decodes data that has been encoded in a simple byte-oriented format based on run length.
// The encoded data shall be a sequence of runs, where each run shall consist of a length byte followed by 1 to 128
// bytes of data. If the length byte is in the range 0 to 127, the following length + 1 (1 to 128) bytes shall be
// copied literally during decompression. If length is in the range 129 to 255, the following single byte shall be
// copied 257 - length (2 to 128) times during decompression. A length value of 128 shall denote EOD.
func (_abbc *RunLengthEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_ccecb :=_ced .NewReader (encoded );var _abdb []byte ;for {_efgg ,_cede :=_ccecb .ReadByte ();if _cede !=nil {return nil ,_cede ;};if _efgg > 128{_fgag ,_bbade :=_ccecb .ReadByte ();if _bbade !=nil {return nil ,_bbade ;};for _fcdd :=0;_fcdd < 257-int (_efgg );_fcdd ++{_abdb =append (_abdb ,_fgag );};}else if _efgg < 128{for _dbdf :=0;_dbdf < int (_efgg )+1;_dbdf ++{_bbc ,_caeg :=_ccecb .ReadByte ();if _caeg !=nil {return nil ,_caeg ;};_abdb =append (_abdb ,_bbc );};}else {break ;};};return _abdb ,nil ;};

// DCTEncoder provides a DCT (JPG) encoding/decoding functionality for images.
type DCTEncoder struct{ColorComponents int ;BitsPerComponent int ;Width int ;Height int ;Quality int ;};

// Str returns the string value of the PdfObjectString. Defined in addition to String() function to clarify that
// this function returns the underlying string directly, whereas the String function technically could include
// debug info.
func (_eac *PdfObjectString )Str ()string {return _eac ._gcfee };

// IsAuthenticated returns true if the PDF has already been authenticated for accessing.
func (_beag *PdfParser )IsAuthenticated ()bool {return _beag ._ggd ._aed };

// DecodeBytes decodes a slice of Flate encoded bytes and returns the result.
func (_cda *FlateEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_cab .Log .Trace ("\u0046\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065\u0020b\u0079\u0074\u0065\u0073");if len (encoded )==0{_cab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0046\u006c\u0061\u0074\u0065 e\u006ec\u006f\u0064\u0065\u0064\u0020\u0062\u0075\u0066\u0066\u0065\u0072\u002e \u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0062y\u0074\u0065\u0020\u0073\u006c\u0069\u0063\u0065\u002e");return []byte {},nil ;};_gfgd :=_ced .NewReader (encoded );_afge ,_bbe :=_d .NewReader (_gfgd );if _bbe !=nil {_cab .Log .Debug ("\u0044e\u0063o\u0064\u0069\u006e\u0067\u0020e\u0072\u0072o\u0072\u0020\u0025\u0076\u000a",_bbe );_cab .Log .Debug ("\u0053t\u0072e\u0061\u006d\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (encoded ),encoded );return nil ,_bbe ;};defer _afge .Close ();var _cdfd _ced .Buffer ;_cdfd .ReadFrom (_afge );return _cdfd .Bytes (),nil ;};

// PdfCryptNewEncrypt makes the document crypt handler based on a specified crypt filter.
func PdfCryptNewEncrypt (cf _de .Filter ,userPass ,ownerPass []byte ,perm _bd .Permissions )(*PdfCrypt ,*EncryptInfo ,error ){_baa :=&PdfCrypt {_bdc :make (map[PdfObject ]bool ),_faa :make (cryptFilters ),_gfa :_bd .StdEncryptDict {P :perm ,EncryptMetadata :true }};var _ddd Version ;if cf !=nil {_dad :=cf .PDFVersion ();_ddd .Major ,_ddd .Minor =_dad [0],_dad [1];V ,R :=cf .HandlerVersion ();_baa ._gead .V =V ;_baa ._gfa .R =R ;_baa ._gead .Length =cf .KeyLength ()*8;};const (_gad =_bdcc ;);_baa ._faa [_gad ]=cf ;if _baa ._gead .V >=4{_baa ._degc =_gad ;_baa ._dcbe =_gad ;};_agc :=_baa .newEncryptDict ();_ace :=_aa .Sum ([]byte (_gb .Now ().Format (_gb .RFC850 )));_cb :=string (_ace [:]);_eff :=make ([]byte ,100);_ea .Read (_eff );_ace =_aa .Sum (_eff );_gaag :=string (_ace [:]);_cab .Log .Trace ("\u0052\u0061\u006e\u0064\u006f\u006d\u0020\u0062\u003a\u0020\u0025\u0020\u0078",_eff );_cab .Log .Trace ("\u0047\u0065\u006e\u0020\u0049\u0064\u0020\u0030\u003a\u0020\u0025\u0020\u0078",_cb );_baa ._gae =_cb ;_ddg :=_baa .generateParams (userPass ,ownerPass );if _ddg !=nil {return nil ,nil ,_ddg ;};_ead (&_baa ._gfa ,_agc );if _baa ._gead .V >=4{if _gaab :=_baa .saveCryptFilters (_agc );_gaab !=nil {return nil ,nil ,_gaab ;};};return _baa ,&EncryptInfo {Version :_ddd ,Encrypt :_agc ,ID0 :_cb ,ID1 :_gaag },nil ;};

// WriteString outputs the object as it is to be written to file.
func (_ffdc *PdfObjectInteger )WriteString ()string {return _ga .FormatInt (int64 (*_ffdc ),10)};

// GetXrefTable returns the PDFs xref table.
func (_fae *PdfParser )GetXrefTable ()XrefTable {return _fae ._adde };

// GoImageToJBIG2 creates a binary image on the base of 'i' golang image.Image.
// If the image is not a black/white image then the function converts provided input into
// JBIG2Image with 1bpp. For non grayscale images the function performs the conversion to the grayscale temp image.
// Then it checks the value of the gray image value if it's within bounds of the black white threshold.
// This 'bwThreshold' value should be in range (0.0, 1.0). The threshold checks if the grayscale pixel (uint) value
// is greater or smaller than 'bwThreshold' * 255. Pixels inside the range will be white, and the others will be black.
// If the 'bwThreshold' is equal to -1.0 - JB2ImageAutoThreshold then it's value would be set on the base of
// it's histogram using Triangle method. For more information go to:
// 	https://www.mathworks.com/matlabcentral/fileexchange/28047-gray-image-thresholding-using-the-triangle-method
func GoImageToJBIG2 (i _gd .Image ,bwThreshold float64 )(*JBIG2Image ,error ){const _dbcc ="\u0047\u006f\u0049\u006d\u0061\u0067\u0065\u0054\u006fJ\u0042\u0049\u0047\u0032";if i ==nil {return nil ,_eea .Error (_dbcc ,"i\u006d\u0061\u0067\u0065 '\u0069'\u0020\u006e\u006f\u0074\u0020d\u0065\u0066\u0069\u006e\u0065\u0064");};var (_gecbe uint8 ;_fdgg _cedb .Image ;_bada error ;);if bwThreshold ==JB2ImageAutoThreshold {_fdgg ,_bada =_cedb .MonochromeConverter .Convert (i );}else if bwThreshold > 1.0||bwThreshold < 0.0{return nil ,_eea .Error (_dbcc ,"p\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074h\u0072\u0065\u0073\u0068\u006f\u006c\u0064 i\u0073\u0020\u006e\u006ft\u0020\u0069\u006e\u0020\u0061\u0020\u0072\u0061\u006ege\u0020\u007b0\u002e\u0030\u002c\u0020\u0031\u002e\u0030\u007d");}else {_gecbe =uint8 (255*bwThreshold );_fdgg ,_bada =_cedb .MonochromeThresholdConverter (_gecbe ).Convert (i );};if _bada !=nil {return nil ,_bada ;};return _gcfe (_fdgg ),nil ;};

// DecodeStream decodes a FlateEncoded stream object and give back decoded bytes.
func (_dbc *FlateEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_cab .Log .Trace ("\u0046l\u0061t\u0065\u0044\u0065\u0063\u006fd\u0065\u0020s\u0074\u0072\u0065\u0061\u006d");_cab .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_dbc .Predictor );if _dbc .BitsPerComponent !=8{return nil ,_ce .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003d\u0025\u0064\u0020\u0028\u006f\u006e\u006c\u0079\u0020\u0038\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0029",_dbc .BitsPerComponent );};_aafb ,_dgg :=_dbc .DecodeBytes (streamObj .Stream );if _dgg !=nil {return nil ,_dgg ;};_aafb ,_dgg =_dbc .postDecodePredict (_aafb );if _dgg !=nil {return nil ,_dgg ;};return _dbc .cleanImageData (_aafb );};var _cecg =_cc .MustCompile ("\u0025\u0025\u0045\u004f\u0046\u003f");

// GetFloat returns the *PdfObjectFloat represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetFloat (obj PdfObject )(_gfdg *PdfObjectFloat ,_daea bool ){_gfdg ,_daea =TraceToDirectObject (obj ).(*PdfObjectFloat );return _gfdg ,_daea ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_eda *ASCIIHexEncoder )MakeDecodeParams ()PdfObject {return nil };func (_dffe *PdfCrypt )isDecrypted (_cccg PdfObject )bool {_ ,_defee :=_dffe ._fba [_cccg ];if _defee {_cab .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0064\u0065\u0063\u0072y\u0070\u0074\u0065\u0064");return true ;};switch _eceb :=_cccg .(type ){case *PdfObjectStream :if _dffe ._gfa .R !=5{if _ceaa ,_ada :=_eceb .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_ada &&*_ceaa =="\u0058\u0052\u0065\u0066"{return true ;};};case *PdfIndirectObject :if _ ,_defee =_dffe ._bgb [int (_eceb .ObjectNumber )];_defee {return true ;};switch _dfd :=_eceb .PdfObject .(type ){case *PdfObjectDictionary :_deeb :=true ;for _ ,_ccb :=range _fged {if _dfd .Get (_ccb )==nil {_deeb =false ;break ;};};if _deeb {return true ;};};};_cab .Log .Trace ("\u004e\u006f\u0074\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");return false ;};func (_gaaa *PdfCrypt )securityHandler ()_bd .StdHandler {if _gaaa ._gfa .R >=5{return _bd .NewHandlerR6 ();};return _bd .NewHandlerR4 (_gaaa ._gae ,_gaaa ._gead .Length );};func (_cfcdd *PdfParser )repairLocateXref ()(int64 ,error ){_bbegc :=int64 (1000);_cfcdd ._bfca .Seek (-_bbegc ,_ge .SeekCurrent );_cfeca ,_dceg :=_cfcdd ._bfca .Seek (0,_ge .SeekCurrent );if _dceg !=nil {return 0,_dceg ;};_ageca :=make ([]byte ,_bbegc );_cfcdd ._bfca .Read (_ageca );_deed :=_dccf .FindAllStringIndex (string (_ageca ),-1);if len (_deed )< 1{_cab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0065\u0070a\u0069\u0072\u003a\u0020\u0078\u0072\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021");return 0,_g .New ("\u0072\u0065\u0070\u0061ir\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064");};_bbdb :=int64 (_deed [len (_deed )-1][0]);_dbbde :=_cfeca +_bbdb ;return _dbbde ,nil ;};

// IsPrintable checks if a character is printable.
// Regular characters that are outside the range EXCLAMATION MARK(21h)
// (!) to TILDE (7Eh) (~) should be written using the hexadecimal notation.
func IsPrintable (c byte )bool {return 0x21<=c &&c <=0x7E};

// Version represents a version of a PDF standard.
type Version struct{Major int ;Minor int ;};func (_aacc *PdfCrypt )authenticate (_adc []byte )(bool ,error ){_aacc ._aed =false ;_gaaae :=_aacc .securityHandler ();_ade ,_ffd ,_ddbb :=_gaaae .Authenticate (&_aacc ._gfa ,_adc );if _ddbb !=nil {return false ,_ddbb ;}else if _ffd ==0||len (_ade )==0{return false ,nil ;};_aacc ._aed =true ;_aacc ._cgg =_ade ;return true ,nil ;};var _ccfc =_cc .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064+\u0029\u005c\u0073\u002b\u0028\u005b\u006e\u0066\u005d\u0029\\\u0073\u002a\u0024");func _ccgc (_daf *PdfObjectStream ,_efc *PdfObjectDictionary )(*FlateEncoder ,error ){_fadf :=NewFlateEncoder ();_eed :=_daf .PdfObjectDictionary ;if _eed ==nil {return _fadf ,nil ;};_fadf ._fbde =_agcd (_eed );if _efc ==nil {_dbdg :=TraceToDirectObject (_eed .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));switch _ddee :=_dbdg .(type ){case *PdfObjectArray :if _ddee .Len ()!=1{_cab .Log .Debug ("\u0045\u0072\u0072\u006f\u0072:\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020a\u0072\u0072\u0061\u0079\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0021\u003d\u0020\u0031\u0020\u0028\u0025\u0064\u0029",_ddee .Len ());return nil ,_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};if _ceb ,_eab :=GetDict (_ddee .Get (0));_eab {_efc =_ceb ;};case *PdfObjectDictionary :_efc =_ddee ;case *PdfObjectNull ,nil :default:_cab .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020n\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079 \u0028%\u0054\u0029",_dbdg );return nil ,_ce .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _efc ==nil {return _fadf ,nil ;};_cab .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_efc .String ());_beea :=_efc .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");if _beea ==nil {_cab .Log .Debug ("E\u0072\u0072o\u0072\u003a\u0020\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067 \u0066\u0072\u006f\u006d\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073 \u002d\u0020\u0043\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020\u0077\u0069t\u0068\u0020\u0064\u0065\u0066\u0061\u0075\u006c\u0074\u0020\u00281\u0029");}else {_fbfe ,_ecag :=_beea .(*PdfObjectInteger );if !_ecag {_cab .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_beea );return nil ,_ce .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_fadf .Predictor =int (*_fbfe );};_beea =_efc .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");if _beea !=nil {_ddad ,_fgb :=_beea .(*PdfObjectInteger );if !_fgb {_cab .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");return nil ,_ce .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_fadf .BitsPerComponent =int (*_ddad );};if _fadf .Predictor > 1{_fadf .Columns =1;_beea =_efc .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");if _beea !=nil {_edfa ,_gce :=_beea .(*PdfObjectInteger );if !_gce {return nil ,_ce .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_fadf .Columns =int (*_edfa );};_fadf .Colors =1;_beea =_efc .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _beea !=nil {_bfba ,_aeg :=_beea .(*PdfObjectInteger );if !_aeg {return nil ,_ce .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");};_fadf .Colors =int (*_bfba );};};return _fadf ,nil ;};func (_abef *FlateEncoder )postDecodePredict (_dgaf []byte )([]byte ,error ){if _abef .Predictor > 1{if _abef .Predictor ==2{_cab .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_cab .Log .Trace ("\u0043\u006f\u006c\u006f\u0072\u0073\u003a\u0020\u0025\u0064",_abef .Colors );_fbfg :=_abef .Columns *_abef .Colors ;if _fbfg < 1{return []byte {},nil ;};_cfg :=len (_dgaf )/_fbfg ;if len (_dgaf )%_fbfg !=0{_cab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");return nil ,_ce .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_dgaf ),_fbfg );};if _fbfg %_abef .Colors !=0{return nil ,_ce .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_fbfg ,_abef .Colors );};if _fbfg > len (_dgaf ){_cab .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_fbfg ,len (_dgaf ));return nil ,_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_cab .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_dgaf ),_dgaf );_gbab :=_ced .NewBuffer (nil );for _deef :=0;_deef < _cfg ;_deef ++{_fac :=_dgaf [_fbfg *_deef :_fbfg *(_deef +1)];for _dgde :=_abef .Colors ;_dgde < _fbfg ;_dgde ++{_fac [_dgde ]+=_fac [_dgde -_abef .Colors ];};_gbab .Write (_fac );};_dgf :=_gbab .Bytes ();_cab .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_dgf ),_dgf );return _dgf ,nil ;}else if _abef .Predictor >=10&&_abef .Predictor <=15{_cab .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_eef :=_abef .Columns *_abef .Colors +1;_dec :=len (_dgaf )/_eef ;if len (_dgaf )%_eef !=0{return nil ,_ce .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_dgaf ),_eef );};if _eef > len (_dgaf ){_cab .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_eef ,len (_dgaf ));return nil ,_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_fcd :=_ced .NewBuffer (nil );_cab .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_abef .Columns );_cab .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_dgaf ),_eef ,_dec );_adbb :=make ([]byte ,_eef );for _ddeb :=0;_ddeb < _eef ;_ddeb ++{_adbb [_ddeb ]=0;};_geb :=_abef .Colors ;for _gca :=0;_gca < _dec ;_gca ++{_gdb :=_dgaf [_eef *_gca :_eef *(_gca +1)];_ebgb :=_gdb [0];switch _ebgb {case _abd :case _fbac :for _bfbc :=1+_geb ;_bfbc < _eef ;_bfbc ++{_gdb [_bfbc ]+=_gdb [_bfbc -_geb ];};case _ecc :for _bdbg :=1;_bdbg < _eef ;_bdbg ++{_gdb [_bdbg ]+=_adbb [_bdbg ];};case _cbed :for _aaab :=1;_aaab < _geb +1;_aaab ++{_gdb [_aaab ]+=_adbb [_aaab ]/2;};for _gbag :=_geb +1;_gbag < _eef ;_gbag ++{_gdb [_gbag ]+=byte ((int (_gdb [_gbag -_geb ])+int (_adbb [_gbag ]))/2);};case _fbe :for _dddb :=1;_dddb < _eef ;_dddb ++{var _egg ,_bgfg ,_eaga byte ;_bgfg =_adbb [_dddb ];if _dddb >=_geb +1{_egg =_gdb [_dddb -_geb ];_eaga =_adbb [_dddb -_geb ];};_gdb [_dddb ]+=_gddb (_egg ,_bgfg ,_eaga );};default:_cab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029\u0020\u0040\u0072o\u0077\u0020\u0025\u0064",_ebgb ,_gca );return nil ,_ce .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_ebgb );};copy (_adbb ,_gdb );_fcd .Write (_gdb [1:]);};_gcb :=_fcd .Bytes ();return _gcb ,nil ;}else {_cab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_abef .Predictor );return nil ,_ce .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_abef .Predictor );};};return _dgaf ,nil ;};

// JPXEncoder implements JPX encoder/decoder (dummy, for now)
// FIXME: implement
type JPXEncoder struct{};

// StreamEncoder represents the interface for all PDF stream encoders.
type StreamEncoder interface{GetFilterName ()string ;MakeDecodeParams ()PdfObject ;MakeStreamDict ()*PdfObjectDictionary ;UpdateParams (_ffb *PdfObjectDictionary );EncodeBytes (_dgdc []byte )([]byte ,error );DecodeBytes (_bfg []byte )([]byte ,error );DecodeStream (_acfd *PdfObjectStream )([]byte ,error );};

// Keys returns the list of keys in the dictionary.
// If `d` is nil returns a nil slice.
func (_bgdaa *PdfObjectDictionary )Keys ()[]PdfObjectName {if _bgdaa ==nil {return nil ;};return _bgdaa ._eafbb ;};

// DecodeStream decodes a LZW encoded stream and returns the result as a
// slice of bytes.
func (_gbfd *LZWEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_cab .Log .Trace ("\u004c\u005a\u0057 \u0044\u0065\u0063\u006f\u0064\u0069\u006e\u0067");_cab .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_gbfd .Predictor );_abdc ,_eaed :=_gbfd .DecodeBytes (streamObj .Stream );if _eaed !=nil {return nil ,_eaed ;};_cab .Log .Trace ("\u0020\u0049\u004e\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (streamObj .Stream ),streamObj .Stream );_cab .Log .Trace ("\u004f\u0055\u0054\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (_abdc ),_abdc );if _gbfd .Predictor > 1{if _gbfd .Predictor ==2{_cab .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_cag :=_gbfd .Columns *_gbfd .Colors ;if _cag < 1{return []byte {},nil ;};_fbea :=len (_abdc )/_cag ;if len (_abdc )%_cag !=0{_cab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");return nil ,_ce .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_abdc ),_cag );};if _cag %_gbfd .Colors !=0{return nil ,_ce .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_cag ,_gbfd .Colors );};if _cag > len (_abdc ){_cab .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_cag ,len (_abdc ));return nil ,_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_cab .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_abdc ),_abdc );_cfaa :=_ced .NewBuffer (nil );for _acfg :=0;_acfg < _fbea ;_acfg ++{_fadd :=_abdc [_cag *_acfg :_cag *(_acfg +1)];for _dcgc :=_gbfd .Colors ;_dcgc < _cag ;_dcgc ++{_fadd [_dcgc ]=byte (int (_fadd [_dcgc ]+_fadd [_dcgc -_gbfd .Colors ])%256);};_cfaa .Write (_fadd );};_dbdc :=_cfaa .Bytes ();_cab .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_dbdc ),_dbdc );return _dbdc ,nil ;}else if _gbfd .Predictor >=10&&_gbfd .Predictor <=15{_cab .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_gfab :=_gbfd .Columns *_gbfd .Colors +1;if _gfab < 1{return []byte {},nil ;};_fgfg :=len (_abdc )/_gfab ;if len (_abdc )%_gfab !=0{return nil ,_ce .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_abdc ),_gfab );};if _gfab > len (_abdc ){_cab .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_gfab ,len (_abdc ));return nil ,_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_gccd :=_ced .NewBuffer (nil );_cab .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_gbfd .Columns );_cab .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_abdc ),_gfab ,_fgfg );_efb :=make ([]byte ,_gfab );for _dca :=0;_dca < _gfab ;_dca ++{_efb [_dca ]=0;};for _dbda :=0;_dbda < _fgfg ;_dbda ++{_caba :=_abdc [_gfab *_dbda :_gfab *(_dbda +1)];_dfgb :=_caba [0];switch _dfgb {case 0:case 1:for _bceb :=2;_bceb < _gfab ;_bceb ++{_caba [_bceb ]=byte (int (_caba [_bceb ]+_caba [_bceb -1])%256);};case 2:for _fagc :=1;_fagc < _gfab ;_fagc ++{_caba [_fagc ]=byte (int (_caba [_fagc ]+_efb [_fagc ])%256);};default:_cab .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0066i\u006c\u0074\u0065\u0072\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_dfgb );return nil ,_ce .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_dfgb );};for _bcg :=0;_bcg < _gfab ;_bcg ++{_efb [_bcg ]=_caba [_bcg ];};_gccd .Write (_caba [1:]);};_aadg :=_gccd .Bytes ();return _aadg ,nil ;}else {_cab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_gbfd .Predictor );return nil ,_ce .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_gbfd .Predictor );};};return _abdc ,nil ;};func _dbg (_bba *_bd .StdEncryptDict ,_bbd *PdfObjectDictionary )error {R ,_bbag :=_bbd .Get ("\u0052").(*PdfObjectInteger );if !_bbag {return _g .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0052");};if *R < 2||*R > 6{return _ce .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0052 \u0028\u0025\u0064\u0029",*R );};_bba .R =int (*R );O ,_bbag :=_bbd .GetString ("\u004f");if !_bbag {return _g .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u004f");};if _bba .R ==5||_bba .R ==6{if len (O )< 48{return _ce .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u004f\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (O ));};}else if len (O )!=32{return _ce .Errorf ("L\u0065n\u0067\u0074\u0068\u0028\u004f\u0029\u0020\u0021=\u0020\u0033\u0032\u0020(%\u0064\u0029",len (O ));};_bba .O =[]byte (O );U ,_bbag :=_bbd .GetString ("\u0055");if !_bbag {return _g .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0055");};if _bba .R ==5||_bba .R ==6{if len (U )< 48{return _ce .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u0055\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (U ));};}else if len (U )!=32{_cab .Log .Debug ("\u0057\u0061r\u006e\u0069\u006e\u0067\u003a\u0020\u004c\u0065\u006e\u0067\u0074\u0068\u0028\u0055\u0029\u0020\u0021\u003d\u0020\u0033\u0032\u0020(%\u0064\u0029",len (U ));};_bba .U =[]byte (U );if _bba .R >=5{OE ,_ageb :=_bbd .GetString ("\u004f\u0045");if !_ageb {return _g .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u004f\u0045");}else if len (OE )!=32{return _ce .Errorf ("L\u0065\u006e\u0067\u0074h(\u004fE\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (OE ));};_bba .OE =[]byte (OE );UE ,_ageb :=_bbd .GetString ("\u0055\u0045");if !_ageb {return _g .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u0055\u0045");}else if len (UE )!=32{return _ce .Errorf ("L\u0065\u006e\u0067\u0074h(\u0055E\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (UE ));};_bba .UE =[]byte (UE );};P ,_bbag :=_bbd .Get ("\u0050").(*PdfObjectInteger );if !_bbag {return _g .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074 \u0064\u0069\u0063t\u0069\u006f\u006e\u0061r\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0070\u0065\u0072\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0061\u0074\u0074\u0072");};_bba .P =_bd .Permissions (*P );if _bba .R ==6{Perms ,_cefa :=_bbd .GetString ("\u0050\u0065\u0072m\u0073");if !_cefa {return _g .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0050\u0065\u0072\u006d\u0073");}else if len (Perms )!=16{return _ce .Errorf ("\u004ce\u006e\u0067\u0074\u0068\u0028\u0050\u0065\u0072\u006d\u0073\u0029 \u0021\u003d\u0020\u0031\u0036\u0020\u0028\u0025\u0064\u0029",len (Perms ));};_bba .Perms =[]byte (Perms );};if _fff ,_dbba :=_bbd .Get ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061").(*PdfObjectBool );_dbba {_bba .EncryptMetadata =bool (*_fff );}else {_bba .EncryptMetadata =true ;};return nil ;};

// IsWhiteSpace checks if byte represents a white space character.
func IsWhiteSpace (ch byte )bool {if (ch ==0x00)||(ch ==0x09)||(ch ==0x0A)||(ch ==0x0C)||(ch ==0x0D)||(ch ==0x20){return true ;};return false ;};var _fged =[]PdfObjectName {"\u0056","\u0052","\u004f","\u0055","\u0050"};

// SetImage sets the image base for given flate encoder.
func (_caff *FlateEncoder )SetImage (img *_cedb .ImageBase ){_caff ._fbde =img };func _bda (_gfg _de .Filter ,_eag _bd .AuthEvent )*PdfObjectDictionary {if _eag ==""{_eag =_bd .EventDocOpen ;};_dcd :=MakeDict ();_dcd .Set ("\u0054\u0079\u0070\u0065",MakeName ("C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"));_dcd .Set ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et",MakeName (string (_eag )));_dcd .Set ("\u0043\u0046\u004d",MakeName (_gfg .Name ()));_dcd .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_gfg .KeyLength ())));return _dcd ;};func (_cafc *PdfParser )parsePdfVersion ()(int ,int ,error ){var _gee int64 =20;_dbfde :=make ([]byte ,_gee );_cafc ._bfca .Seek (0,_ge .SeekStart );_cafc ._bfca .Read (_dbfde );var _ecga error ;var _adgee ,_gdg int ;if _ggedf :=_dgab .FindStringSubmatch (string (_dbfde ));len (_ggedf )< 3{if _adgee ,_gdg ,_ecga =_cafc .seekPdfVersionTopDown ();_ecga !=nil {_cab .Log .Debug ("F\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065\u0063\u006f\u0076\u0065\u0072\u0079\u0020\u002d\u0020\u0075n\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0066\u0069nd\u0020\u0076\u0065r\u0073i\u006f\u006e");return 0,0,_ecga ;};_cafc ._bfca ,_ecga =_dgge (_cafc ._bfca ,_cafc .GetFileOffset ()-8);if _ecga !=nil {return 0,0,_ecga ;};}else {if _adgee ,_ecga =_ga .Atoi (_ggedf [1]);_ecga !=nil {return 0,0,_ecga ;};if _gdg ,_ecga =_ga .Atoi (_ggedf [2]);_ecga !=nil {return 0,0,_ecga ;};_cafc .SetFileOffset (0);};_cafc ._afbd =_dg .NewReader (_cafc ._bfca );_cab .Log .Debug ("\u0050\u0064\u0066\u0020\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020%\u0064\u002e\u0025\u0064",_adgee ,_gdg );return _adgee ,_gdg ,nil ;};var _abgf =_cc .MustCompile ("\u0073t\u0061r\u0074\u0078\u003f\u0072\u0065f\u005c\u0073*\u0028\u005c\u0064\u002b\u0029");

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_gbfa *MultiEncoder )MakeDecodeParams ()PdfObject {if len (_gbfa ._dffc )==0{return nil ;};if len (_gbfa ._dffc )==1{return _gbfa ._dffc [0].MakeDecodeParams ();};_cacc :=MakeArray ();for _ ,_ecfa :=range _gbfa ._dffc {_efdg :=_ecfa .MakeDecodeParams ();if _efdg ==nil {_cacc .Append (MakeNull ());}else {_cacc .Append (_efdg );};};return _cacc ;};

// DecodeStream decodes RunLengthEncoded stream object and give back decoded bytes.
func (_bfee *RunLengthEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _bfee .DecodeBytes (streamObj .Stream );};

// PdfObjectReference represents the primitive PDF reference object.
type PdfObjectReference struct{_eddcb *PdfParser ;ObjectNumber int64 ;GenerationNumber int64 ;};func (_bb *PdfParser )lookupByNumberWrapper (_aag int ,_eg bool )(PdfObject ,bool ,error ){_deb ,_ba ,_bag :=_bb .lookupByNumber (_aag ,_eg );if _bag !=nil {return nil ,_ba ,_bag ;};if !_ba &&_bb ._ggd !=nil &&!_bb ._ggd .isDecrypted (_deb ){_fgf :=_bb ._ggd .Decrypt (_deb ,0,0);if _fgf !=nil {return nil ,_ba ,_fgf ;};};return _deb ,_ba ,nil ;};

// PdfObjectDictionary represents the primitive PDF dictionary/map object.
type PdfObjectDictionary struct{_agcee map[PdfObjectName ]PdfObject ;_eafbb []PdfObjectName ;_aagdf *PdfParser ;};var _aefge =_cc .MustCompile ("\u005c\u0073\u002a\u0078\u0072\u0065\u0066\u005c\u0073\u002a");

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_gaee *RunLengthEncoder )MakeStreamDict ()*PdfObjectDictionary {_fda :=MakeDict ();_fda .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_gaee .GetFilterName ()));return _fda ;};

// WriteString outputs the object as it is to be written to file.
func (_cdeg *PdfObjectDictionary )WriteString ()string {var _dced _ee .Builder ;_dced .WriteString ("\u003c\u003c");for _ ,_ffabdc :=range _cdeg ._eafbb {_egef :=_cdeg ._agcee [_ffabdc ];_dced .WriteString (_ffabdc .WriteString ());_dced .WriteString ("\u0020");_dced .WriteString (_egef .WriteString ());};_dced .WriteString ("\u003e\u003e");return _dced .String ();};

// ASCII85Encoder implements ASCII85 encoder/decoder.
type ASCII85Encoder struct{};func (_cfc *PdfCrypt )isEncrypted (_deea PdfObject )bool {_ ,_cec :=_cfc ._bdc [_deea ];if _cec {_cab .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0065\u006e\u0063\u0072y\u0070\u0074\u0065\u0064");return true ;};_cab .Log .Trace ("\u004e\u006f\u0074\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");return false ;};func (_gdbec *PdfParser )loadXrefs ()(*PdfObjectDictionary ,error ){_gdbec ._adde .ObjectMap =make (map[int ]XrefObject );_gdbec ._abeb =make (objectStreams );_fdbad ,_gcbc :=_gdbec ._bfca .Seek (0,_ge .SeekEnd );if _gcbc !=nil {return nil ,_gcbc ;};_cab .Log .Trace ("\u0066s\u0069\u007a\u0065\u003a\u0020\u0025d",_fdbad );_gdbec ._cfbg =_fdbad ;_gcbc =_gdbec .seekToEOFMarker (_fdbad );if _gcbc !=nil {_cab .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0073\u0065\u0065\u006b\u0020\u0074\u006f\u0020\u0065\u006f\u0066\u0020\u006d\u0061\u0072\u006b\u0065\u0072: \u0025\u0076",_gcbc );return nil ,_gcbc ;};_becc ,_gcbc :=_gdbec ._bfca .Seek (0,_ge .SeekCurrent );if _gcbc !=nil {return nil ,_gcbc ;};var _accc int64 =64;_abag :=_becc -_accc ;if _abag < 0{_abag =0;};_ ,_gcbc =_gdbec ._bfca .Seek (_abag ,_ge .SeekStart );if _gcbc !=nil {return nil ,_gcbc ;};_aefbg :=make ([]byte ,_accc );_ ,_gcbc =_gdbec ._bfca .Read (_aefbg );if _gcbc !=nil {_cab .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u003a\u0020\u0025\u0076",_gcbc );return nil ,_gcbc ;};_bgbad :=_abgf .FindStringSubmatch (string (_aefbg ));if len (_bgbad )< 2{_cab .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020n\u006f\u0074\u0020f\u006fu\u006e\u0064\u0021");return nil ,_g .New ("\u0073\u0074\u0061\u0072tx\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};if len (_bgbad )> 2{_cab .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u004du\u006c\u0074\u0069\u0070\u006c\u0065\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029\u0021",_aefbg );return nil ,_g .New ("m\u0075\u006c\u0074\u0069\u0070\u006ce\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065f\u0020\u0065\u006et\u0072i\u0065\u0073\u003f");};_efdec ,_ :=_ga .ParseInt (_bgbad [1],10,64);_cab .Log .Trace ("\u0073t\u0061r\u0074\u0078\u0072\u0065\u0066\u0020\u0061\u0074\u0020\u0025\u0064",_efdec );if _efdec > _fdbad {_cab .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u006f\u0066f\u0073e\u0074 \u006fu\u0074\u0073\u0069\u0064\u0065\u0020\u006f\u0066\u0020\u0066\u0069\u006c\u0065");_cab .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0072e\u0070\u0061\u0069\u0072");_efdec ,_gcbc =_gdbec .repairLocateXref ();if _gcbc !=nil {_cab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0052\u0065\u0070\u0061\u0069\u0072\u0020\u0061\u0074\u0074\u0065\u006d\u0070t\u0020\u0066\u0061\u0069\u006c\u0065\u0064 \u0028\u0025\u0073\u0029");return nil ,_gcbc ;};};_gdbec ._bfca .Seek (_efdec ,_ge .SeekStart );_gdbec ._afbd =_dg .NewReader (_gdbec ._bfca );_ggdf ,_gcbc :=_gdbec .parseXref ();if _gcbc !=nil {return nil ,_gcbc ;};_agde :=_ggdf .Get ("\u0058R\u0065\u0066\u0053\u0074\u006d");if _agde !=nil {_acdb ,_badd :=_agde .(*PdfObjectInteger );if !_badd {return nil ,_g .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0021=\u0020\u0069\u006e\u0074");};_ ,_gcbc =_gdbec .parseXrefStream (_acdb );if _gcbc !=nil {return nil ,_gcbc ;};};var _gcac []int64 ;_bfaga :=func (_gcaee int64 ,_bdfg []int64 )bool {for _ ,_eddca :=range _bdfg {if _eddca ==_gcaee {return true ;};};return false ;};_agde =_ggdf .Get ("\u0050\u0072\u0065\u0076");for _agde !=nil {_eabeg ,_fdfd :=_agde .(*PdfObjectInteger );if !_fdfd {_cab .Log .Debug ("\u0049\u006ev\u0061\u006c\u0069\u0064\u0020P\u0072\u0065\u0076\u0020\u0072e\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u003a\u0020\u004e\u006f\u0074\u0020\u0061\u0020\u002a\u0050\u0064\u0066\u004f\u0062\u006a\u0065\u0063\u0074\u0049\u006e\u0074\u0065\u0067\u0065\u0072\u0020\u0028\u0025\u0054\u0029",_agde );return _ggdf ,nil ;};_ecd :=*_eabeg ;_cab .Log .Trace ("\u0041\u006eot\u0068\u0065\u0072 \u0050\u0072\u0065\u0076 xr\u0065f \u0074\u0061\u0062\u006c\u0065\u0020\u006fbj\u0065\u0063\u0074\u0020\u0061\u0074\u0020%\u0064",_ecd );_gdbec ._bfca .Seek (int64 (_ecd ),_ge .SeekStart );_gdbec ._afbd =_dg .NewReader (_gdbec ._bfca );_bfaf ,_ggcfg :=_gdbec .parseXref ();if _ggcfg !=nil {_cab .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0045\u0072\u0072\u006f\u0072\u0020-\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u0061\u0064\u0069n\u0067\u0020\u0061\u006e\u006f\u0074\u0068\u0065\u0072\u0020\u0028\u0050re\u0076\u0029\u0020\u0074\u0072\u0061\u0069\u006c\u0065\u0072");_cab .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0063\u006f\u006e\u0074\u0069n\u0075\u0065\u0020\u0062\u0079\u0020\u0069\u0067\u006e\u006f\u0072\u0069n\u0067\u0020\u0069\u0074");break ;};_agde =_bfaf .Get ("\u0050\u0072\u0065\u0076");if _agde !=nil {_egde :=*(_agde .(*PdfObjectInteger ));if _bfaga (int64 (_egde ),_gcac ){_cab .Log .Debug ("\u0050\u0072ev\u0065\u006e\u0074i\u006e\u0067\u0020\u0063irc\u0075la\u0072\u0020\u0078\u0072\u0065\u0066\u0020re\u0066\u0065\u0072\u0065\u006e\u0063\u0069n\u0067");break ;};_gcac =append (_gcac ,int64 (_egde ));};};return _ggdf ,nil ;};

// GetFilterArray returns the names of the underlying encoding filters in an array that
// can be used as /Filter entry.
func (_gega *MultiEncoder )GetFilterArray ()*PdfObjectArray {_effd :=make ([]PdfObject ,len (_gega ._dffc ));for _aggb ,_bagc :=range _gega ._dffc {_effd [_aggb ]=MakeName (_bagc .GetFilterName ());};return MakeArray (_effd ...);};func (_adebe *PdfParser )rebuildXrefTable ()error {_ebfga :=XrefTable {};_ebfga .ObjectMap =map[int ]XrefObject {};_dfegdb :=make ([]int ,0,len (_adebe ._adde .ObjectMap ));for _ebed :=range _adebe ._adde .ObjectMap {_dfegdb =append (_dfegdb ,_ebed );};_c .Ints (_dfegdb );for _ ,_eacc :=range _dfegdb {_edca :=_adebe ._adde .ObjectMap [_eacc ];_ffgf ,_ ,_badfd :=_adebe .lookupByNumberWrapper (_eacc ,false );if _badfd !=nil {_cab .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020U\u006e\u0061\u0062\u006ce t\u006f l\u006f\u006f\u006b\u0020\u0075\u0070\u0020ob\u006a\u0065\u0063\u0074\u0020\u0028\u0025s\u0029",_badfd );_cab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0063\u006fm\u0070\u006c\u0065\u0074\u0065\u006c\u0079\u0020\u0062\u0072\u006f\u006b\u0065\u006e\u0020\u002d\u0020\u0061\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0074\u006f \u0072\u0065\u0070\u0061\u0069r\u0020");_ddgdf ,_eece :=_adebe .repairRebuildXrefsTopDown ();if _eece !=nil {_cab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0072\u0065\u0062\u0075\u0069l\u0064\u0020\u0072\u0065\u0070a\u0069\u0072 \u0028\u0025\u0073\u0029",_eece );return _eece ;};_adebe ._adde =*_ddgdf ;_cab .Log .Debug ("\u0052e\u0070\u0061\u0069\u0072e\u0064\u0020\u0078\u0072\u0065f\u0020t\u0061b\u006c\u0065\u0020\u0062\u0075\u0069\u006ct");return nil ;};_eddg ,_ddadg ,_badfd :=_agd (_ffgf );if _badfd !=nil {return _badfd ;};_edca .ObjectNumber =int (_eddg );_edca .Generation =int (_ddadg );_ebfga .ObjectMap [int (_eddg )]=_edca ;};_adebe ._adde =_ebfga ;_cab .Log .Debug ("N\u0065w\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061b\u006c\u0065\u0020\u0062ui\u006c\u0074");_dcb (_adebe ._adde );return nil ;};

// Decrypt attempts to decrypt the PDF file with a specified password.  Also tries to
// decrypt with an empty password.  Returns true if successful, false otherwise.
// An error is returned when there is a problem with decrypting.
func (_dafb *PdfParser )Decrypt (password []byte )(bool ,error ){if _dafb ._ggd ==nil {return false ,_g .New ("\u0063\u0068\u0065\u0063k \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u0069\u0072s\u0074");};_aadgg ,_bdca :=_dafb ._ggd .authenticate (password );if _bdca !=nil {return false ,_bdca ;};if !_aadgg {_aadgg ,_bdca =_dafb ._ggd .authenticate ([]byte (""));};return _aadgg ,_bdca ;};const (JB2Generic JBIG2CompressionType =iota ;JB2SymbolCorrelation ;JB2SymbolRankHaus ;);

// GetFloatVal returns the float64 value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetFloatVal (obj PdfObject )(_efcb float64 ,_fbdeg bool ){_ffec ,_fbdeg :=TraceToDirectObject (obj ).(*PdfObjectFloat );if _fbdeg {return float64 (*_ffec ),true ;};return 0,false ;};

// PdfCrypt provides PDF encryption/decryption support.
// The PDF standard supports encryption of strings and streams (Section 7.6).
type PdfCrypt struct{_gead encryptDict ;_gfa _bd .StdEncryptDict ;_gae string ;_cgg []byte ;_fba map[PdfObject ]bool ;_bdc map[PdfObject ]bool ;_aed bool ;_faa cryptFilters ;_degc string ;_dcbe string ;_cbe *PdfParser ;_bgb map[int ]struct{};};

// EncodeBytes encodes the passed in slice of bytes by passing it through the
// EncodeBytes method of the underlying encoders.
func (_afad *MultiEncoder )EncodeBytes (data []byte )([]byte ,error ){_gecc :=data ;var _dafd error ;for _ggbc :=len (_afad ._dffc )-1;_ggbc >=0;_ggbc --{_fbff :=_afad ._dffc [_ggbc ];_gecc ,_dafd =_fbff .EncodeBytes (_gecc );if _dafd !=nil {return nil ,_dafd ;};};return _gecc ,nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_aefg *LZWEncoder )MakeStreamDict ()*PdfObjectDictionary {_gec :=MakeDict ();_gec .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_aefg .GetFilterName ()));_effe :=_aefg .MakeDecodeParams ();if _effe !=nil {_gec .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_effe );};_gec .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (int64 (_aefg .EarlyChange )));return _gec ;};

// JBIG2Image is the image structure used by the jbig2 encoder. Its Data must be in a
// 1 bit per component and 1 component per pixel (1bpp). In order to create binary image
// use GoImageToJBIG2 function. If the image data contains the row bytes padding set the HasPadding to true.
type JBIG2Image struct{

// Width and Height defines the image boundaries.
Width ,Height int ;

// Data is the byte slice data for the input image
Data []byte ;

// HasPadding is the attribute that defines if the last byte of the data in the row contains
// 0 bits padding.
HasPadding bool ;};

// GetFilterName returns the name of the encoding filter.
func (_dfca *JPXEncoder )GetFilterName ()string {return StreamEncodingFilterNameJPX };

// WriteString outputs the object as it is to be written to file.
func (_gabg *PdfObjectFloat )WriteString ()string {return _ga .FormatFloat (float64 (*_gabg ),'f',-1,64);};func (_gded *PdfParser )skipComments ()error {if _ ,_gcaa :=_gded .skipSpaces ();_gcaa !=nil {return _gcaa ;};_dbbdfc :=true ;for {_cdce ,_edec :=_gded ._afbd .Peek (1);if _edec !=nil {_cab .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_edec .Error ());return _edec ;};if _dbbdfc &&_cdce [0]!='%'{return nil ;};_dbbdfc =false ;if (_cdce [0]!='\r')&&(_cdce [0]!='\n'){_gded ._afbd .ReadByte ();}else {break ;};};return _gded .skipComments ();};

// NewParser creates a new parser for a PDF file via ReadSeeker. Loads the cross reference stream and trailer.
// An error is returned on failure.
func NewParser (rs _ge .ReadSeeker )(*PdfParser ,error ){_ggbae :=&PdfParser {_bfca :rs ,ObjCache :make (objectCache ),_gcd :map[int64 ]bool {}};_gcdd ,_dffg ,_cadb :=_ggbae .parsePdfVersion ();if _cadb !=nil {_cab .Log .Error ("U\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0076e\u0072\u0073\u0069o\u006e:\u0020\u0025\u0076",_cadb );return nil ,_cadb ;};_ggbae ._abfd .Major =_gcdd ;_ggbae ._abfd .Minor =_dffg ;if _ggbae ._faca ,_cadb =_ggbae .loadXrefs ();_cadb !=nil {_cab .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020F\u0061\u0069\u006c\u0065d t\u006f l\u006f\u0061\u0064\u0020\u0078\u0072\u0065f \u0074\u0061\u0062\u006c\u0065\u0021\u0020%\u0073",_cadb );return nil ,_cadb ;};_cab .Log .Trace ("T\u0072\u0061\u0069\u006c\u0065\u0072\u003a\u0020\u0025\u0073",_ggbae ._faca );if len (_ggbae ._adde .ObjectMap )==0{return nil ,_ce .Errorf ("\u0065\u006d\u0070\u0074\u0079\u0020\u0058\u0052\u0045\u0046\u0020t\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0049\u006e\u0076a\u006c\u0069\u0064");};return _ggbae ,nil ;};var (ErrUnsupportedEncodingParameters =_g .New ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074\u0065\u0072\u0073");ErrNoCCITTFaxDecode =_g .New ("\u0043\u0043I\u0054\u0054\u0046\u0061\u0078\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");ErrNoJBIG2Decode =_g .New ("\u004a\u0042\u0049\u0047\u0032\u0044\u0065c\u006f\u0064\u0065 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");ErrNoJPXDecode =_g .New ("\u004a\u0050\u0058\u0044\u0065c\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020i\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");ErrNoPdfVersion =_g .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");ErrTypeError =_g .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");ErrRangeError =_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");ErrNotSupported =_be .New ("\u0066\u0065\u0061t\u0075\u0072\u0065\u0020n\u006f\u0074\u0020\u0063\u0075\u0072\u0072e\u006e\u0074\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");ErrNotANumber =_g .New ("\u006e\u006f\u0074 \u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072"););func _fea (_af *_de .FilterDict ,_ec *PdfObjectDictionary )error {if _babb ,_cdf :=_ec .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_cdf {if _aad :=string (*_babb );_aad !="C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"{_cab .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020C\u0046\u0020\u0064ic\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074e\u0072\u0029",_aad );};};_bdf ,_cefab :=_ec .Get ("\u0043\u0046\u004d").(*PdfObjectName );if !_cefab {return _ce .Errorf ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0028\u004e\u006f\u006e\u0065\u0029");};_af .CFM =string (*_bdf );if _abe ,_bgd :=_ec .Get ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et").(*PdfObjectName );_bgd {_af .AuthEvent =_bd .AuthEvent (*_abe );}else {_af .AuthEvent =_bd .EventDocOpen ;};if _ccf ,_dgc :=_ec .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );_dgc {_af .Length =int (*_ccf );};return nil ;};

// GetFilterName returns the name of the encoding filter.
func (_daag *RawEncoder )GetFilterName ()string {return StreamEncodingFilterNameRaw };

// ToFloat64Array returns a slice of all elements in the array as a float64 slice.  An error is
// returned if the array contains non-numeric objects (each element can be either PdfObjectInteger
// or PdfObjectFloat).
func (_bcdg *PdfObjectArray )ToFloat64Array ()([]float64 ,error ){var _acbda []float64 ;for _ ,_ggcfa :=range _bcdg .Elements (){switch _bdbb :=_ggcfa .(type ){case *PdfObjectInteger :_acbda =append (_acbda ,float64 (*_bdbb ));case *PdfObjectFloat :_acbda =append (_acbda ,float64 (*_bdbb ));default:return nil ,ErrTypeError ;};};return _acbda ,nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_ecagb *RawEncoder )UpdateParams (params *PdfObjectDictionary ){};func (_dbd *PdfCrypt )generateParams (_bee ,_ffab []byte )error {_bdd :=_dbd .securityHandler ();_fagb ,_bdbae :=_bdd .GenerateParams (&_dbd ._gfa ,_ffab ,_bee );if _bdbae !=nil {return _bdbae ;};_dbd ._cgg =_fagb ;return nil ;};

// Merge merges in key/values from another dictionary. Overwriting if has same keys.
// The mutated dictionary (d) is returned in order to allow method chaining.
func (_fcfb *PdfObjectDictionary )Merge (another *PdfObjectDictionary )*PdfObjectDictionary {if another !=nil {for _ ,_gccdf :=range another .Keys (){_gabdc :=another .Get (_gccdf );_fcfb .Set (_gccdf ,_gabdc );};};return _fcfb ;};

// UpdateParams updates the parameter values of the encoder.
func (_bed *FlateEncoder )UpdateParams (params *PdfObjectDictionary ){_dga ,_abfe :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _abfe ==nil {_bed .Predictor =int (_dga );};_cgfd ,_abfe :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _abfe ==nil {_bed .BitsPerComponent =int (_cgfd );};_cafe ,_abfe :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _abfe ==nil {_bed .Columns =int (_cafe );};_bgfc ,_abfe :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _abfe ==nil {_bed .Colors =int (_bgfc );};};

// NewASCIIHexEncoder makes a new ASCII hex encoder.
func NewASCIIHexEncoder ()*ASCIIHexEncoder {_bge :=&ASCIIHexEncoder {};return _bge };

// PdfObjectStreams represents the primitive PDF object streams.
// 7.5.7 Object Streams (page 45).
type PdfObjectStreams struct{PdfObjectReference ;_gccb []PdfObject ;};

// FlattenObject returns the contents of `obj`. In other words, `obj` with indirect objects replaced
// by their values.
// The replacements are made recursively to a depth of traceMaxDepth.
// NOTE: Dicts are sorted to make objects with same contents have the same PDF object strings.
func FlattenObject (obj PdfObject )PdfObject {return _dgff (obj ,0)};

// DecodeStream implements ASCII hex decoding.
func (_cdbb *ASCIIHexEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _cdbb .DecodeBytes (streamObj .Stream );};

// DecodeStream decodes a multi-encoded stream by passing it through the
// DecodeStream method of the underlying encoders.
func (_adeb *MultiEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _adeb .DecodeBytes (streamObj .Stream );};

// DecodeBytes decodes a slice of JBIG2 encoded bytes and returns the results.
func (_aeda *JBIG2Encoder )DecodeBytes (encoded []byte )([]byte ,error ){return _ac .DecodeBytes (encoded ,_beb .Parameters {},_aeda .Globals );};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_fcgg *FlateEncoder )MakeDecodeParams ()PdfObject {if _fcgg .Predictor > 1{_aee :=MakeDict ();_aee .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_fcgg .Predictor )));if _fcgg .BitsPerComponent !=8{_aee .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_fcgg .BitsPerComponent )));};if _fcgg .Columns !=1{_aee .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_fcgg .Columns )));};if _fcgg .Colors !=1{_aee .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_fcgg .Colors )));};return _aee ;};return nil ;};var _dgab =_cc .MustCompile ("\u0025P\u0044F\u002d\u0028\u005c\u0064\u0029\u005c\u002e\u0028\u005c\u0064\u0029");func (_dddg *JBIG2Encoder )encodeImage (_cdee _gd .Image )([]byte ,error ){const _efbc ="e\u006e\u0063\u006f\u0064\u0065\u0049\u006d\u0061\u0067\u0065";_dgfg ,_fcga :=GoImageToJBIG2 (_cdee ,JB2ImageAutoThreshold );if _fcga !=nil {return nil ,_eea .Wrap (_fcga ,_efbc ,"\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069m\u0061g\u0065\u0020\u0074\u006f\u0020\u006a\u0062\u0069\u0067\u0032\u0020\u0069\u006d\u0067");};if _fcga =_dddg .AddPageImage (_dgfg ,&_dddg .DefaultPageSettings );_fcga !=nil {return nil ,_eea .Wrap (_fcga ,_efbc ,"");};return _dddg .Encode ();};

// DecodeImages decodes the page images from the jbig2 'encoded' data input.
// The jbig2 document may contain multiple pages, thus the function can return multiple
// images. The images order corresponds to the page number.
func (_fdga *JBIG2Encoder )DecodeImages (encoded []byte )([]_gd .Image ,error ){const _agca ="\u004aB\u0049\u0047\u0032\u0045n\u0063\u006f\u0064\u0065\u0072.\u0044e\u0063o\u0064\u0065\u0049\u006d\u0061\u0067\u0065s";_bgde ,_feb :=_beb .Decode (encoded ,_beb .Parameters {},_fdga .Globals .ToDocumentGlobals ());if _feb !=nil {return nil ,_eea .Wrap (_feb ,_agca ,"");};_eagf ,_feb :=_bgde .PageNumber ();if _feb !=nil {return nil ,_eea .Wrap (_feb ,_agca ,"");};_fbc :=[]_gd .Image {};var _dcfg _gd .Image ;for _afb :=1;_afb <=_eagf ;_afb ++{_dcfg ,_feb =_bgde .DecodePageImage (_afb );if _feb !=nil {return nil ,_eea .Wrapf (_feb ,_agca ,"\u0070\u0061\u0067\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_afb );};_fbc =append (_fbc ,_dcfg );};return _fbc ,nil ;};

// ASCIIHexEncoder implements ASCII hex encoder/decoder.
type ASCIIHexEncoder struct{};func (_bgbaf *PdfParser )parseBool ()(PdfObjectBool ,error ){_effda ,_bgfcb :=_bgbaf ._afbd .Peek (4);if _bgfcb !=nil {return PdfObjectBool (false ),_bgfcb ;};if (len (_effda )>=4)&&(string (_effda [:4])=="\u0074\u0072\u0075\u0065"){_bgbaf ._afbd .Discard (4);return PdfObjectBool (true ),nil ;};_effda ,_bgfcb =_bgbaf ._afbd .Peek (5);if _bgfcb !=nil {return PdfObjectBool (false ),_bgfcb ;};if (len (_effda )>=5)&&(string (_effda [:5])=="\u0066\u0061\u006cs\u0065"){_bgbaf ._afbd .Discard (5);return PdfObjectBool (false ),nil ;};return PdfObjectBool (false ),_g .New ("\u0075n\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0062o\u006fl\u0065a\u006e\u0020\u0073\u0074\u0072\u0069\u006eg");};

// Clear resets the array to an empty state.
func (_cbg *PdfObjectArray )Clear (){_cbg ._gaggf =[]PdfObject {}};

// CheckAccessRights checks access rights and permissions for a specified password. If either user/owner password is
// specified, full rights are granted, otherwise the access rights are specified by the Permissions flag.
//
// The bool flag indicates that the user can access and view the file.
// The AccessPermissions shows what access the user has for editing etc.
// An error is returned if there was a problem performing the authentication.
func (_efdd *PdfParser )CheckAccessRights (password []byte )(bool ,_bd .Permissions ,error ){if _efdd ._ggd ==nil {return true ,_bd .PermOwner ,nil ;};return _efdd ._ggd .checkAccessRights (password );};

// ToGoImage converts the JBIG2Image to the golang image.Image.
func (_gafd *JBIG2Image )ToGoImage ()(_gd .Image ,error ){const _gedfd ="J\u0042I\u0047\u0032\u0049\u006d\u0061\u0067\u0065\u002eT\u006f\u0047\u006f\u0049ma\u0067\u0065";if _gafd .Data ==nil {return nil ,_eea .Error (_gedfd ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");};if _gafd .Width ==0||_gafd .Height ==0{return nil ,_eea .Error (_gedfd ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");};_dbdfc ,_eeega :=_cedb .NewImage (_gafd .Width ,_gafd .Height ,1,1,_gafd .Data ,nil ,nil );if _eeega !=nil {return nil ,_eeega ;};return _dbdfc ,nil ;};const (DefaultJPEGQuality =75;);func (_cdb *PdfCrypt )makeKey (_egbg string ,_dcfc ,_fffg uint32 ,_bece []byte )([]byte ,error ){_geaf ,_cfb :=_cdb ._faa [_egbg ];if !_cfb {return nil ,_ce .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_egbg );};return _geaf .MakeKey (_dcfc ,_fffg ,_bece );};

// String returns a string describing `array`.
func (_dfcce *PdfObjectArray )String ()string {_gaga :="\u005b";for _bffg ,_bcga :=range _dfcce .Elements (){_gaga +=_bcga .String ();if _bffg < (_dfcce .Len ()-1){_gaga +="\u002c\u0020";};};_gaga +="\u005d";return _gaga ;};func (_gdedc *PdfParser )parseName ()(PdfObjectName ,error ){var _aggbc _ced .Buffer ;_gaaf :=false ;for {_caffd ,_aca :=_gdedc ._afbd .Peek (1);if _aca ==_ge .EOF {break ;};if _aca !=nil {return PdfObjectName (_aggbc .String ()),_aca ;};if !_gaaf {if _caffd [0]=='/'{_gaaf =true ;_gdedc ._afbd .ReadByte ();}else if _caffd [0]=='%'{_gdedc .readComment ();_gdedc .skipSpaces ();}else {_cab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020N\u0061\u006d\u0065\u0020\u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020w\u0069\u0074\u0068\u0020\u0025\u0073\u0020(\u0025\u0020\u0078\u0029",_caffd ,_caffd );return PdfObjectName (_aggbc .String ()),_ce .Errorf ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u006ea\u006d\u0065:\u0020\u0028\u0025\u0063\u0029",_caffd [0]);};}else {if IsWhiteSpace (_caffd [0]){break ;}else if (_caffd [0]=='/')||(_caffd [0]=='[')||(_caffd [0]=='(')||(_caffd [0]==']')||(_caffd [0]=='<')||(_caffd [0]=='>'){break ;}else if _caffd [0]=='#'{_edagf ,_abfg :=_gdedc ._afbd .Peek (3);if _abfg !=nil {return PdfObjectName (_aggbc .String ()),_abfg ;};_cgaa ,_abfg :=_a .DecodeString (string (_edagf [1:3]));if _abfg !=nil {_cab .Log .Debug ("\u0045\u0052\u0052\u004fR\u003a\u0020\u0049\u006ev\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0066o\u006c\u006co\u0077\u0069\u006e\u0067 \u0027\u0023\u0027\u002c \u0063\u006f\u006e\u0074\u0069n\u0075\u0069\u006e\u0067\u0020\u0075\u0073i\u006e\u0067\u0020\u006c\u0069t\u0065\u0072\u0061\u006c\u0020\u002d\u0020\u004f\u0075t\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074");_aggbc .WriteByte ('#');_gdedc ._afbd .Discard (1);continue ;};_gdedc ._afbd .Discard (3);_aggbc .Write (_cgaa );}else {_fgcff ,_ :=_gdedc ._afbd .ReadByte ();_aggbc .WriteByte (_fgcff );};};};return PdfObjectName (_aggbc .String ()),nil ;};

// LookupByReference looks up a PdfObject by a reference.
func (_bcc *PdfParser )LookupByReference (ref PdfObjectReference )(PdfObject ,error ){_cab .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0075\u0070\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0025\u0073",ref .String ());return _bcc .LookupByNumber (int (ref .ObjectNumber ));};var _cadf =_cc .MustCompile ("\u005e\u005b\\\u002b\u002d\u002e\u005d*\u0028\u005b0\u002d\u0039\u002e\u005d\u002b\u0029\u005b\u0065E\u005d\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");

// ResolveReference resolves reference if `o` is a *PdfObjectReference and returns the object referenced to.
// Otherwise returns back `o`.
func ResolveReference (obj PdfObject )PdfObject {if _aceg ,_bgbga :=obj .(*PdfObjectReference );_bgbga {return _aceg .Resolve ();};return obj ;};func (_fgcf *offsetReader )Read (p []byte )(_bacb int ,_cfba error ){return _fgcf ._edgc .Read (p )};func _bebd (_begb PdfObject ,_dbfae int ,_gcag map[PdfObject ]struct{})error {_cab .Log .Trace ("\u0054\u0072\u0061\u0076\u0065\u0072s\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0064\u0061\u0074\u0061 \u0028\u0064\u0065\u0070\u0074\u0068\u0020=\u0020\u0025\u0064\u0029",_dbfae );if _ ,_gfgef :=_gcag [_begb ];_gfgef {_cab .Log .Trace ("-\u0041\u006c\u0072\u0065ad\u0079 \u0074\u0072\u0061\u0076\u0065r\u0073\u0065\u0064\u002e\u002e\u002e");return nil ;};_gcag [_begb ]=struct{}{};switch _cabe :=_begb .(type ){case *PdfIndirectObject :_bbdf :=_cabe ;_cab .Log .Trace ("\u0069\u006f\u003a\u0020\u0025\u0073",_bbdf );_cab .Log .Trace ("\u002d\u0020\u0025\u0073",_bbdf .PdfObject );return _bebd (_bbdf .PdfObject ,_dbfae +1,_gcag );case *PdfObjectStream :_ggda :=_cabe ;return _bebd (_ggda .PdfObjectDictionary ,_dbfae +1,_gcag );case *PdfObjectDictionary :_eccd :=_cabe ;_cab .Log .Trace ("\u002d\u0020\u0064\u0069\u0063\u0074\u003a\u0020\u0025\u0073",_eccd );for _ ,_fffa :=range _eccd .Keys (){_cgab :=_eccd .Get (_fffa );if _bbgf ,_baee :=_cgab .(*PdfObjectReference );_baee {_eebc :=_bbgf .Resolve ();_eccd .Set (_fffa ,_eebc );_gbca :=_bebd (_eebc ,_dbfae +1,_gcag );if _gbca !=nil {return _gbca ;};}else {_gbbcb :=_bebd (_cgab ,_dbfae +1,_gcag );if _gbbcb !=nil {return _gbbcb ;};};};return nil ;case *PdfObjectArray :_bcbd :=_cabe ;_cab .Log .Trace ("-\u0020\u0061\u0072\u0072\u0061\u0079\u003a\u0020\u0025\u0073",_bcbd );for _eefg ,_eeeaa :=range _bcbd .Elements (){if _dcfde ,_acccf :=_eeeaa .(*PdfObjectReference );_acccf {_feafd :=_dcfde .Resolve ();_bcbd .Set (_eefg ,_feafd );_eedd :=_bebd (_feafd ,_dbfae +1,_gcag );if _eedd !=nil {return _eedd ;};}else {_feab :=_bebd (_eeeaa ,_dbfae +1,_gcag );if _feab !=nil {return _feab ;};};};return nil ;case *PdfObjectReference :_cab .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020T\u0072\u0061\u0063\u0069\u006e\u0067\u0020\u0061\u0020r\u0065\u0066\u0065r\u0065n\u0063\u0065\u0021");return _g .New ("\u0065r\u0072\u006f\u0072\u0020t\u0072\u0061\u0063\u0069\u006eg\u0020a\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");};return nil ;};func _fefa (_bfeac string )(int ,int ,error ){_gcgg :=_gcfd .FindStringSubmatch (_bfeac );if len (_gcgg )< 3{return 0,0,_g .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");};_dbdga ,_ :=_ga .Atoi (_gcgg [1]);_dgbe ,_ :=_ga .Atoi (_gcgg [2]);return _dbdga ,_dgbe ,nil ;};

// PdfParser parses a PDF file and provides access to the object structure of the PDF.
type PdfParser struct{_abfd Version ;_bfca _ge .ReadSeeker ;_afbd *_dg .Reader ;_cfbg int64 ;_adde XrefTable ;_dbbdf int64 ;_cggb *xrefType ;_abeb objectStreams ;_faca *PdfObjectDictionary ;_ggd *PdfCrypt ;_dcbc bool ;ObjCache objectCache ;_baec map[int ]bool ;_gcd map[int64 ]bool ;};const _bbba =10;

// JBIG2EncoderSettings contains the parameters and settings used by the JBIG2Encoder.
// Current version works only on JB2Generic compression.
type JBIG2EncoderSettings struct{

// FileMode defines if the jbig2 encoder should return full jbig2 file instead of
// shortened pdf mode. This adds the file header to the jbig2 definition.
FileMode bool ;

// Compression is the setting that defines the compression type used for encoding the page.
Compression JBIG2CompressionType ;

// DuplicatedLinesRemoval code generic region in a way such that if the lines are duplicated the encoder
// doesn't store it twice.
DuplicatedLinesRemoval bool ;

// DefaultPixelValue is the bit value initial for every pixel in the page.
DefaultPixelValue uint8 ;

// ResolutionX optional setting that defines the 'x' axis input image resolution - used for single page encoding.
ResolutionX int ;

// ResolutionY optional setting that defines the 'y' axis input image resolution - used for single page encoding.
ResolutionY int ;

// Threshold defines the threshold of the image correlation for
// non Generic compression.
// User only for JB2SymbolCorrelation and JB2SymbolRankHaus methods.
// Best results in range [0.7 - 0.98] - the less the better the compression would be
// but the more lossy.
// Default value: 0.95
Threshold float64 ;};

// Elements returns a slice of the PdfObject elements in the array.
// Preferred over accessing the array directly as type may be changed in future major versions (v3).
func (_gbfde *PdfObjectStreams )Elements ()[]PdfObject {if _gbfde ==nil {return nil ;};return _gbfde ._gccb ;};

// EncodeBytes encodes the image data using either Group3 or Group4 CCITT facsimile (fax) encoding.
// `data` is expected to be 1 color component, 1 byte per component.
func (_ebfe *CCITTFaxEncoder )EncodeBytes (data []byte )([]byte ,error ){var _bcb [][]byte ;for _bfbg :=0;_bfbg < len (data );_bfbg +=_ebfe .Columns {_cbdg :=make ([]byte ,_ebfe .Columns );_eafc :=0;for _fed :=0;_fed < _ebfe .Columns ;_fed ++{if data [_bfbg +_fed ]==255{_cbdg [_eafc ]=1;}else {_cbdg [_eafc ]=0;};_eafc ++;};_bcb =append (_bcb ,_cbdg );};_gfeb :=&_gf .Encoder {K :_ebfe .K ,Columns :_ebfe .Columns ,EndOfLine :_ebfe .EndOfLine ,EndOfBlock :_ebfe .EndOfBlock ,BlackIs1 :_ebfe .BlackIs1 ,DamagedRowsBeforeError :_ebfe .DamagedRowsBeforeError ,Rows :_ebfe .Rows ,EncodedByteAlign :_ebfe .EncodedByteAlign };return _gfeb .Encode (_bcb ),nil ;};type objectStream struct{N int ;_eb []byte ;_dgd map[int ]int64 ;};

// Resolve resolves the reference and returns the indirect or stream object.
// If the reference cannot be resolved, a *PdfObjectNull object is returned.
func (_agbec *PdfObjectReference )Resolve ()PdfObject {if _agbec ._eddcb ==nil {return MakeNull ();};_abgff ,_ ,_cfgc :=_agbec ._eddcb .resolveReference (_agbec );if _cfgc !=nil {_cab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0072\u0065\u0073\u006f\u006cv\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065r\u0065n\u0063\u0065\u003a\u0020\u0025\u0076\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074",_cfgc );return MakeNull ();};if _abgff ==nil {_cab .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0072\u0065\u0073ol\u0076\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065:\u0020\u006ei\u006c\u0020\u006fb\u006a\u0065\u0063\u0074\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u0061\u0020nu\u006c\u006c\u0020o\u0062\u006a\u0065\u0063\u0074");return MakeNull ();};return _abgff ;};

// ParseIndirectObject parses an indirect object from the input stream. Can also be an object stream.
// Returns the indirect object (*PdfIndirectObject) or the stream object (*PdfObjectStream).
func (_ccfb *PdfParser )ParseIndirectObject ()(PdfObject ,error ){_edba :=PdfIndirectObject {};_edba ._eddcb =_ccfb ;_cab .Log .Trace ("\u002dR\u0065a\u0064\u0020\u0069\u006e\u0064i\u0072\u0065c\u0074\u0020\u006f\u0062\u006a");_cdea ,_dgacb :=_ccfb ._afbd .Peek (20);if _dgacb !=nil {if _dgacb !=_ge .EOF {_cab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020r\u0065a\u0064\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a");return &_edba ,_dgacb ;};};_cab .Log .Trace ("\u0028\u0069\u006edi\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_cdea ));_ceg :=_gcfd .FindStringSubmatchIndex (string (_cdea ));if len (_ceg )< 6{if _dgacb ==_ge .EOF {return nil ,_dgacb ;};_cab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_cdea ));return &_edba ,_g .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");};_ccfb ._afbd .Discard (_ceg [0]);_cab .Log .Trace ("O\u0066\u0066\u0073\u0065\u0074\u0073\u0020\u0025\u0020\u0064",_ceg );_gabf :=_ceg [1]-_ceg [0];_fbab :=make ([]byte ,_gabf );_ ,_dgacb =_ccfb .ReadAtLeast (_fbab ,_gabf );if _dgacb !=nil {_cab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u0072\u0065\u0061\u0064\u0020-\u0020\u0025\u0073",_dgacb );return nil ,_dgacb ;};_cab .Log .Trace ("\u0074\u0065\u0078t\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_fbab );_cdgb :=_gcfd .FindStringSubmatch (string (_fbab ));if len (_cdgb )< 3{_cab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_fbab ));return &_edba ,_g .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");};_eafg ,_ :=_ga .Atoi (_cdgb [1]);_bfbb ,_ :=_ga .Atoi (_cdgb [2]);_edba .ObjectNumber =int64 (_eafg );_edba .GenerationNumber =int64 (_bfbb );for {_dbgd ,_bafg :=_ccfb ._afbd .Peek (2);if _bafg !=nil {return &_edba ,_bafg ;};_cab .Log .Trace ("I\u006ed\u002e\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_dbgd ),string (_dbgd ));if IsWhiteSpace (_dbgd [0]){_ccfb .skipSpaces ();}else if _dbgd [0]=='%'{_ccfb .skipComments ();}else if (_dbgd [0]=='<')&&(_dbgd [1]=='<'){_cab .Log .Trace ("\u0043\u0061\u006c\u006c\u0020\u0050\u0061\u0072\u0073e\u0044\u0069\u0063\u0074");_edba .PdfObject ,_bafg =_ccfb .ParseDict ();_cab .Log .Trace ("\u0045\u004f\u0046\u0020Ca\u006c\u006c\u0020\u0050\u0061\u0072\u0073\u0065\u0044\u0069\u0063\u0074\u003a\u0020%\u0076",_bafg );if _bafg !=nil {return &_edba ,_bafg ;};_cab .Log .Trace ("\u0050\u0061\u0072\u0073\u0065\u0064\u0020\u0064\u0069\u0063t\u0069\u006f\u006e\u0061\u0072\u0079\u002e.\u002e\u0020\u0066\u0069\u006e\u0069\u0073\u0068\u0065\u0064\u002e");}else if (_dbgd [0]=='/')||(_dbgd [0]=='(')||(_dbgd [0]=='[')||(_dbgd [0]=='<'){_edba .PdfObject ,_bafg =_ccfb .parseObject ();if _bafg !=nil {return &_edba ,_bafg ;};_cab .Log .Trace ("P\u0061\u0072\u0073\u0065\u0064\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u002e\u002e\u002e \u0066\u0069\u006ei\u0073h\u0065\u0064\u002e");}else if _dbgd [0]==']'{_cab .Log .Debug ("\u0057\u0041\u0052\u004e\u0049N\u0047\u003a\u0020\u0027\u005d\u0027 \u0063\u0068\u0061\u0072\u0061\u0063\u0074e\u0072\u0020\u006eo\u0074\u0020\u0062\u0065i\u006e\u0067\u0020\u0075\u0073\u0065d\u0020\u0061\u0073\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006e\u0064\u0069n\u0067\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e");_ccfb ._afbd .Discard (1);}else {if _dbgd [0]=='e'{_bbgg ,_faabe :=_ccfb .readTextLine ();if _faabe !=nil {return nil ,_faabe ;};if len (_bbgg )>=6&&_bbgg [0:6]=="\u0065\u006e\u0064\u006f\u0062\u006a"{break ;};}else if _dbgd [0]=='s'{_dbgd ,_ =_ccfb ._afbd .Peek (10);if string (_dbgd [:6])=="\u0073\u0074\u0072\u0065\u0061\u006d"{_adcg :=6;if len (_dbgd )> 6{if IsWhiteSpace (_dbgd [_adcg ])&&_dbgd [_adcg ]!='\r'&&_dbgd [_adcg ]!='\n'{_cab .Log .Debug ("\u004e\u006fn\u002d\u0063\u006f\u006e\u0066\u006f\u0072\u006d\u0061\u006e\u0074\u0020\u0050\u0044\u0046\u0020\u006e\u006f\u0074 \u0065\u006e\u0064\u0069\u006e\u0067 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0069\u006e\u0065\u0020\u0070\u0072o\u0070\u0065r\u006c\u0079\u0020\u0077i\u0074\u0068\u0020\u0045\u004fL\u0020\u006d\u0061\u0072\u006b\u0065\u0072");_adcg ++;};if _dbgd [_adcg ]=='\r'{_adcg ++;if _dbgd [_adcg ]=='\n'{_adcg ++;};}else if _dbgd [_adcg ]=='\n'{_adcg ++;};};_ccfb ._afbd .Discard (_adcg );_bdeaf ,_aegf :=_edba .PdfObject .(*PdfObjectDictionary );if !_aegf {return nil ,_g .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006di\u0073s\u0069\u006e\u0067\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_cab .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0069c\u0074\u0020\u0025\u0073",_bdeaf );_cdebg ,_bdfdf :=_ccfb .traceStreamLength (_bdeaf .Get ("\u004c\u0065\u006e\u0067\u0074\u0068"));if _bdfdf !=nil {_cab .Log .Debug ("\u0046\u0061\u0069l\u0020\u0074\u006f\u0020t\u0072\u0061\u0063\u0065\u0020\u0073\u0074r\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0025\u0076",_bdfdf );return nil ,_bdfdf ;};_cab .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_cdebg );_fbbfg ,_gdgd :=_cdebg .(*PdfObjectInteger );if !_gdgd {return nil ,_g .New ("\u0073\u0074re\u0061\u006d\u0020l\u0065\u006e\u0067\u0074h n\u0065ed\u0073\u0020\u0074\u006f\u0020\u0062\u0065 a\u006e\u0020\u0069\u006e\u0074\u0065\u0067e\u0072");};_cdag :=*_fbbfg ;if _cdag < 0{return nil ,_g .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006e\u0065\u0065\u0064\u0073\u0020\u0074\u006f \u0062e\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0030");};_abdff :=_ccfb .GetFileOffset ();_ebab :=_ccfb .xrefNextObjectOffset (_abdff );if _abdff +int64 (_cdag )> _ebab &&_ebab > _abdff {_cab .Log .Debug ("E\u0078\u0070\u0065\u0063te\u0064 \u0065\u006e\u0064\u0069\u006eg\u0020\u0061\u0074\u0020\u0025\u0064",_abdff +int64 (_cdag ));_cab .Log .Debug ("\u004e\u0065\u0078\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020\u0061t\u0020\u0025\u0064",_ebab );_bdgb :=_ebab -_abdff -17;if _bdgb < 0{return nil ,_g .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020go\u0069\u006e\u0067 \u0070\u0061s\u0074\u0020\u0062\u006f\u0075\u006ed\u0061\u0072i\u0065\u0073");};_cab .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0061\u0020l\u0065\u006e\u0067\u0074\u0068\u0020c\u006f\u0072\u0072\u0065\u0063\u0074\u0069\u006f\u006e\u0020\u0074\u006f\u0020%\u0064\u002e\u002e\u002e",_bdgb );_cdag =PdfObjectInteger (_bdgb );_bdeaf .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (_bdgb ));};if int64 (_cdag )> _ccfb ._cfbg {_cab .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0053t\u0072\u0065\u0061\u006d\u0020l\u0065\u006e\u0067\u0074\u0068\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u0061\u0072\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0066\u0069\u006c\u0065\u0020\u0073\u0069\u007a\u0065");return nil ,_g .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020la\u0072\u0067\u0065r\u0020\u0074h\u0061\u006e\u0020\u0066\u0069\u006ce\u0020\u0073i\u007a\u0065");};_cgd :=make ([]byte ,_cdag );_ ,_bdfdf =_ccfb .ReadAtLeast (_cgd ,int (_cdag ));if _bdfdf !=nil {_cab .Log .Debug ("E\u0052\u0052\u004f\u0052 s\u0074r\u0065\u0061\u006d\u0020\u0028%\u0064\u0029\u003a\u0020\u0025\u0058",len (_cgd ),_cgd );_cab .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_bdfdf );return nil ,_bdfdf ;};_gcgcf :=PdfObjectStream {};_gcgcf .Stream =_cgd ;_gcgcf .PdfObjectDictionary =_edba .PdfObject .(*PdfObjectDictionary );_gcgcf .ObjectNumber =_edba .ObjectNumber ;_gcgcf .GenerationNumber =_edba .GenerationNumber ;_gcgcf .PdfObjectReference ._eddcb =_ccfb ;_ccfb .skipSpaces ();_ccfb ._afbd .Discard (9);_ccfb .skipSpaces ();return &_gcgcf ,nil ;};};_edba .PdfObject ,_bafg =_ccfb .parseObject ();if _edba .PdfObject ==nil {_cab .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");_edba .PdfObject =MakeNull ();};return &_edba ,_bafg ;};};if _edba .PdfObject ==nil {_cab .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");_edba .PdfObject =MakeNull ();};_cab .Log .Trace ("\u0052\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0021");return &_edba ,nil ;};func (_efgd *PdfParser )parseNull ()(PdfObjectNull ,error ){_ ,_fdca :=_efgd ._afbd .Discard (4);return PdfObjectNull {},_fdca ;};func (_bdcf *FlateEncoder )cleanImageData (_bdff []byte )([]byte ,error ){if _bdcf ._fbde ==nil {return _bdff ,nil ;};if _bdcf ._fbde .BitsPerComponent >=8{return _bdff ,nil ;};_dcbf :=_bdcf ._fbde .BitsPerComponent *_bdcf ._fbde .Width *_bdcf ._fbde .ColorComponents *_bdcf ._fbde .Height /8;_bdff =_bdff [:_dcbf ];var _gdbf error ;_bdff ,_gdbf =_cedb .AddDataPadding (_bdcf ._fbde .Width ,_bdcf ._fbde .Height ,_bdcf ._fbde .BitsPerComponent ,_bdcf ._fbde .ColorComponents ,_bdff );if _gdbf !=nil {return nil ,_gdbf ;};return _bdff ,nil ;};

// RawEncoder implements Raw encoder/decoder (no encoding, pass through)
type RawEncoder struct{};

// UpdateParams updates the parameter values of the encoder.
func (_fdg *RunLengthEncoder )UpdateParams (params *PdfObjectDictionary ){};func (_cdcc *PdfParser )parseArray ()(*PdfObjectArray ,error ){_fedb :=MakeArray ();_cdcc ._afbd .ReadByte ();for {_cdcc .skipSpaces ();_defa ,_eddce :=_cdcc ._afbd .Peek (1);if _eddce !=nil {return _fedb ,_eddce ;};if _defa [0]==']'{_cdcc ._afbd .ReadByte ();break ;};_bfbeb ,_eddce :=_cdcc .parseObject ();if _eddce !=nil {return _fedb ,_eddce ;};_fedb .Append (_bfbeb );};return _fedb ,nil ;};

// GetXrefType returns the type of the first xref object (table or stream).
func (_bded *PdfParser )GetXrefType ()*xrefType {return _bded ._cggb };

// Append appends PdfObject(s) to the array.
func (_agcf *PdfObjectArray )Append (objects ...PdfObject ){if _agcf ==nil {_cab .Log .Debug ("\u0057\u0061\u0072\u006e\u0020\u002d\u0020\u0041\u0074\u0074\u0065\u006d\u0070t\u0020\u0074\u006f\u0020\u0061\u0070p\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020a\u0072\u0072\u0061\u0079");return ;};_agcf ._gaggf =append (_agcf ._gaggf ,objects ...);};func (_dfgc *PdfParser )traceStreamLength (_fdfdd PdfObject )(PdfObject ,error ){_edea ,_fdde :=_fdfdd .(*PdfObjectReference );if _fdde {_acbfd ,_efba :=_dfgc ._gcd [_edea .ObjectNumber ];if _efba &&_acbfd {_cab .Log .Debug ("\u0053t\u0072\u0065a\u006d\u0020\u004c\u0065n\u0067\u0074\u0068 \u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065 u\u006e\u0072\u0065s\u006f\u006cv\u0065\u0064\u0020\u0028\u0069\u006cl\u0065\u0067a\u006c\u0029");return nil ,_g .New ("\u0069\u006c\u006c\u0065ga\u006c\u0020\u0072\u0065\u0063\u0075\u0072\u0073\u0069\u0076\u0065\u0020\u006c\u006fo\u0070");};_dfgc ._gcd [_edea .ObjectNumber ]=true ;};_afbe ,_abfge :=_dfgc .Resolve (_fdfdd );if _abfge !=nil {return nil ,_abfge ;};_cab .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_afbe );if _fdde {_dfgc ._gcd [_edea .ObjectNumber ]=false ;};return _afbe ,nil ;};

// EqualObjects returns true if `obj1` and `obj2` have the same contents.
//
// NOTE: It is a good idea to flatten obj1 and obj2 with FlattenObject before calling this function
// so that contents, rather than references, can be compared.
func EqualObjects (obj1 ,obj2 PdfObject )bool {return _abefg (obj1 ,obj2 ,0)};type objectStreams map[int ]objectStream ;

// String returns a string describing `ref`.
func (_cbdf *PdfObjectReference )String ()string {return _ce .Sprintf ("\u0052\u0065\u0066\u0028\u0025\u0064\u0020\u0025\u0064\u0029",_cbdf .ObjectNumber ,_cbdf .GenerationNumber );};

// EncodeImage encodes 'img' golang image.Image into jbig2 encoded bytes document using default encoder settings.
func (_ffeg *JBIG2Encoder )EncodeImage (img _gd .Image )([]byte ,error ){return _ffeg .encodeImage (img )};

// String returns the state of the bool as "true" or "false".
func (_fbcb *PdfObjectBool )String ()string {if *_fbcb {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};

// GetParser returns the parser for lazy-loading or compare references.
func (_gdfc *PdfObjectReference )GetParser ()*PdfParser {return _gdfc ._eddcb };

// NewJBIG2Encoder creates a new JBIG2Encoder.
func NewJBIG2Encoder ()*JBIG2Encoder {return &JBIG2Encoder {_adfd :_ag .InitEncodeDocument (false )}};func (_fecb *PdfParser )parseString ()(*PdfObjectString ,error ){_fecb ._afbd .ReadByte ();var _bfcf _ced .Buffer ;_efad :=1;for {_gdegg ,_cdcf :=_fecb ._afbd .Peek (1);if _cdcf !=nil {return MakeString (_bfcf .String ()),_cdcf ;};if _gdegg [0]=='\\'{_fecb ._afbd .ReadByte ();_fcdf ,_ebbb :=_fecb ._afbd .ReadByte ();if _ebbb !=nil {return MakeString (_bfcf .String ()),_ebbb ;};if IsOctalDigit (_fcdf ){_adbeb ,_dfgbf :=_fecb ._afbd .Peek (2);if _dfgbf !=nil {return MakeString (_bfcf .String ()),_dfgbf ;};var _bdea []byte ;_bdea =append (_bdea ,_fcdf );for _ ,_cebef :=range _adbeb {if IsOctalDigit (_cebef ){_bdea =append (_bdea ,_cebef );}else {break ;};};_fecb ._afbd .Discard (len (_bdea )-1);_cab .Log .Trace ("\u004e\u0075\u006d\u0065ri\u0063\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0022\u0025\u0073\u0022",_bdea );_bfde ,_dfgbf :=_ga .ParseUint (string (_bdea ),8,32);if _dfgbf !=nil {return MakeString (_bfcf .String ()),_dfgbf ;};_bfcf .WriteByte (byte (_bfde ));continue ;};switch _fcdf {case 'n':_bfcf .WriteRune ('\n');case 'r':_bfcf .WriteRune ('\r');case 't':_bfcf .WriteRune ('\t');case 'b':_bfcf .WriteRune ('\b');case 'f':_bfcf .WriteRune ('\f');case '(':_bfcf .WriteRune ('(');case ')':_bfcf .WriteRune (')');case '\\':_bfcf .WriteRune ('\\');};continue ;}else if _gdegg [0]=='('{_efad ++;}else if _gdegg [0]==')'{_efad --;if _efad ==0{_fecb ._afbd .ReadByte ();break ;};};_gffg ,_ :=_fecb ._afbd .ReadByte ();_bfcf .WriteByte (_gffg );};return MakeString (_bfcf .String ()),nil ;};

// Clear resets the dictionary to an empty state.
func (_bfcb *PdfObjectDictionary )Clear (){_bfcb ._eafbb =[]PdfObjectName {};_bfcb ._agcee =map[PdfObjectName ]PdfObject {};};

// MakeBool creates a PdfObjectBool from a bool value.
func MakeBool (val bool )*PdfObjectBool {_eegag :=PdfObjectBool (val );return &_eegag };func _cfcd (_ccgg *PdfObjectStream ,_gfb *PdfObjectDictionary )(*RunLengthEncoder ,error ){return NewRunLengthEncoder (),nil ;};func (_gcbeb *PdfParser )parseNumber ()(PdfObject ,error ){return ParseNumber (_gcbeb ._afbd )};

// IsDelimiter checks if a character represents a delimiter.
func IsDelimiter (c byte )bool {return c =='('||c ==')'||c =='<'||c =='>'||c =='['||c ==']'||c =='{'||c =='}'||c =='/'||c =='%';};

// DecodeBytes decodes a slice of DCT encoded bytes and returns the result.
func (_aafe *DCTEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_caa :=_ced .NewReader (encoded );_bcf ,_agab :=_gc .Decode (_caa );if _agab !=nil {_cab .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006eg\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_agab );return nil ,_agab ;};_dbde :=_bcf .Bounds ();var _bfbcb =make ([]byte ,_dbde .Dx ()*_dbde .Dy ()*_aafe .ColorComponents *_aafe .BitsPerComponent /8);_acd :=0;for _ecac :=_dbde .Min .Y ;_ecac < _dbde .Max .Y ;_ecac ++{for _fcde :=_dbde .Min .X ;_fcde < _dbde .Max .X ;_fcde ++{_dedf :=_bcf .At (_fcde ,_ecac );if _aafe .ColorComponents ==1{if _aafe .BitsPerComponent ==16{_ddgd ,_dfaf :=_dedf .(_ca .Gray16 );if !_dfaf {return nil ,_g .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_bfbcb [_acd ]=byte ((_ddgd .Y >>8)&0xff);_acd ++;_bfbcb [_acd ]=byte (_ddgd .Y &0xff);_acd ++;}else {_eafb ,_effa :=_dedf .(_ca .Gray );if !_effa {return nil ,_g .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_bfbcb [_acd ]=_eafb .Y &0xff;_acd ++;};}else if _aafe .ColorComponents ==3{if _aafe .BitsPerComponent ==16{_cga ,_gdee :=_dedf .(_ca .RGBA64 );if !_gdee {return nil ,_g .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_bfbcb [_acd ]=byte ((_cga .R >>8)&0xff);_acd ++;_bfbcb [_acd ]=byte (_cga .R &0xff);_acd ++;_bfbcb [_acd ]=byte ((_cga .G >>8)&0xff);_acd ++;_bfbcb [_acd ]=byte (_cga .G &0xff);_acd ++;_bfbcb [_acd ]=byte ((_cga .B >>8)&0xff);_acd ++;_bfbcb [_acd ]=byte (_cga .B &0xff);_acd ++;}else {_dcbfe ,_ebdb :=_dedf .(_ca .RGBA );if _ebdb {_bfbcb [_acd ]=_dcbfe .R &0xff;_acd ++;_bfbcb [_acd ]=_dcbfe .G &0xff;_acd ++;_bfbcb [_acd ]=_dcbfe .B &0xff;_acd ++;}else {_bad ,_ebgg :=_dedf .(_ca .YCbCr );if !_ebgg {return nil ,_g .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_eba ,_fec ,_aefe ,_ :=_bad .RGBA ();_bfbcb [_acd ]=byte (_eba >>8);_acd ++;_bfbcb [_acd ]=byte (_fec >>8);_acd ++;_bfbcb [_acd ]=byte (_aefe >>8);_acd ++;};};}else if _aafe .ColorComponents ==4{_efde ,_gef :=_dedf .(_ca .CMYK );if !_gef {return nil ,_g .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_bfbcb [_acd ]=255-_efde .C &0xff;_acd ++;_bfbcb [_acd ]=255-_efde .M &0xff;_acd ++;_bfbcb [_acd ]=255-_efde .Y &0xff;_acd ++;_bfbcb [_acd ]=255-_efde .K &0xff;_acd ++;};};};return _bfbcb ,nil ;};

// NewRawEncoder returns a new instace of RawEncoder.
func NewRawEncoder ()*RawEncoder {return &RawEncoder {}};

// String returns the PDF version as a string. Implements interface fmt.Stringer.
func (_afc Version )String ()string {return _ce .Sprintf ("\u00250\u0064\u002e\u0025\u0030\u0064",_afc .Major ,_afc .Minor );};func (_dbab *PdfCrypt )decryptBytes (_cfac []byte ,_adg string ,_dfb []byte )([]byte ,error ){_cab .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");_cgga ,_cae :=_dbab ._faa [_adg ];if !_cae {return nil ,_ce .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_adg );};return _cgga .DecryptBytes (_cfac ,_dfb );};

// MakeArray creates an PdfObjectArray from a list of PdfObjects.
func MakeArray (objects ...PdfObject )*PdfObjectArray {return &PdfObjectArray {_gaggf :objects }};

// PdfObjectString represents the primitive PDF string object.
type PdfObjectString struct{_gcfee string ;_cfde bool ;};const _abadf =32<<(^uint (0)>>63);

// Len returns the number of elements in the array.
func (_afbg *PdfObjectArray )Len ()int {if _afbg ==nil {return 0;};return len (_afbg ._gaggf );};func (_cecf *ASCII85Encoder )base256Tobase85 (_cge uint32 )[5]byte {_ccce :=[5]byte {0,0,0,0,0};_agbd :=_cge ;for _dbdab :=0;_dbdab < 5;_dbdab ++{_fdb :=uint32 (1);for _gbe :=0;_gbe < 4-_dbdab ;_gbe ++{_fdb *=85;};_gced :=_agbd /_fdb ;_agbd =_agbd %_fdb ;_ccce [_dbdab ]=byte (_gced );};return _ccce ;};

// GetDict returns the *PdfObjectDictionary represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetDict (obj PdfObject )(_bcce *PdfObjectDictionary ,_dgfb bool ){_bcce ,_dgfb =TraceToDirectObject (obj ).(*PdfObjectDictionary );return _bcce ,_dgfb ;};const (XrefTypeTableEntry xrefType =iota ;XrefTypeObjectStream xrefType =iota ;);

// DecodeBytes decodes a multi-encoded slice of bytes by passing it through the
// DecodeBytes method of the underlying encoders.
func (_ebb *MultiEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_eeef :=encoded ;var _gbfdc error ;for _ ,_geaa :=range _ebb ._dffc {_cab .Log .Trace ("\u004du\u006c\u0074i\u0020\u0045\u006e\u0063o\u0064\u0065\u0072 \u0044\u0065\u0063\u006f\u0064\u0065\u003a\u0020\u0041pp\u006c\u0079\u0069n\u0067\u0020F\u0069\u006c\u0074\u0065\u0072\u003a \u0025\u0076 \u0025\u0054",_geaa ,_geaa );_eeef ,_gbfdc =_geaa .DecodeBytes (_eeef );if _gbfdc !=nil {return nil ,_gbfdc ;};};return _eeef ,nil ;};

// WriteString outputs the object as it is to be written to file.
func (_aebg *PdfObjectBool )WriteString ()string {if *_aebg {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};

// MultiEncoder supports serial encoding.
type MultiEncoder struct{_dffc []StreamEncoder };

// UpdateParams updates the parameter values of the encoder.
func (_caca *ASCIIHexEncoder )UpdateParams (params *PdfObjectDictionary ){};

// PdfObjectStream represents the primitive PDF Object stream.
type PdfObjectStream struct{PdfObjectReference ;*PdfObjectDictionary ;Stream []byte ;};

// UpdateParams updates the parameter values of the encoder.
func (_dce *ASCII85Encoder )UpdateParams (params *PdfObjectDictionary ){};

// String returns a string describing `d`.
func (_cgce *PdfObjectDictionary )String ()string {var _eaef _ee .Builder ;_eaef .WriteString ("\u0044\u0069\u0063t\u0028");for _ ,_dfff :=range _cgce ._eafbb {_fbabfg :=_cgce ._agcee [_dfff ];_eaef .WriteString ("\u0022"+_dfff .String ()+"\u0022\u003a\u0020");_eaef .WriteString (_fbabfg .String ());_eaef .WriteString ("\u002c\u0020");};_eaef .WriteString ("\u0029");return _eaef .String ();};func _gaef (_bbb *PdfObjectStream ,_dgb *PdfObjectDictionary )(*LZWEncoder ,error ){_ageg :=NewLZWEncoder ();_gaf :=_bbb .PdfObjectDictionary ;if _gaf ==nil {return _ageg ,nil ;};if _dgb ==nil {_fbaca :=TraceToDirectObject (_gaf .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));if _fbaca !=nil {if _cfca ,_cfab :=_fbaca .(*PdfObjectDictionary );_cfab {_dgb =_cfca ;}else if _cfbf ,_ffea :=_fbaca .(*PdfObjectArray );_ffea {if _cfbf .Len ()==1{if _cee ,_abad :=GetDict (_cfbf .Get (0));_abad {_dgb =_cee ;};};};if _dgb ==nil {_cab .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_fbaca );return nil ,_ce .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};};_baaf :=_gaf .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");if _baaf !=nil {_ffdf ,_edbg :=_baaf .(*PdfObjectInteger );if !_edbg {_cab .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a \u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065d\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u006e\u0075\u006d\u0065\u0072i\u0063 \u0028\u0025\u0054\u0029",_baaf );return nil ,_ce .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");};if *_ffdf !=0&&*_ffdf !=1{return nil ,_ce .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0076\u0061\u006c\u0075e\u0020\u0028\u006e\u006f\u0074 \u0030\u0020o\u0072\u0020\u0031\u0029");};_ageg .EarlyChange =int (*_ffdf );}else {_ageg .EarlyChange =1;};if _dgb ==nil {return _ageg ,nil ;};_baaf =_dgb .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");if _baaf !=nil {_fef ,_dag :=_baaf .(*PdfObjectInteger );if !_dag {_cab .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_baaf );return nil ,_ce .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_ageg .Predictor =int (*_fef );};_baaf =_dgb .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");if _baaf !=nil {_fcggd ,_eegf :=_baaf .(*PdfObjectInteger );if !_eegf {_cab .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");return nil ,_ce .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_ageg .BitsPerComponent =int (*_fcggd );};if _ageg .Predictor > 1{_ageg .Columns =1;_baaf =_dgb .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");if _baaf !=nil {_agcb ,_dgac :=_baaf .(*PdfObjectInteger );if !_dgac {return nil ,_ce .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_ageg .Columns =int (*_agcb );};_ageg .Colors =1;_baaf =_dgb .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _baaf !=nil {_begc ,_aaaa :=_baaf .(*PdfObjectInteger );if !_aaaa {return nil ,_ce .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");};_ageg .Colors =int (*_begc );};};_cab .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_dgb .String ());return _ageg ,nil ;};

// String returns a string describing `ind`.
func (_fgcac *PdfIndirectObject )String ()string {return _ce .Sprintf ("\u0049\u004f\u0062\u006a\u0065\u0063\u0074\u003a\u0025\u0064",(*_fgcac ).ObjectNumber );};

// Elements returns a slice of the PdfObject elements in the array.
func (_cegf *PdfObjectArray )Elements ()[]PdfObject {if _cegf ==nil {return nil ;};return _cegf ._gaggf ;};

// WriteString outputs the object as it is to be written to file.
func (_dfcdd *PdfIndirectObject )WriteString ()string {var _ffdee _ee .Builder ;_ffdee .WriteString (_ga .FormatInt (_dfcdd .ObjectNumber ,10));_ffdee .WriteString ("\u0020\u0030\u0020\u0052");return _ffdee .String ();};

// DecodeBytes decodes a slice of LZW encoded bytes and returns the result.
func (_bga *LZWEncoder )DecodeBytes (encoded []byte )([]byte ,error ){var _eee _ced .Buffer ;_baba :=_ced .NewReader (encoded );var _baab _ge .ReadCloser ;if _bga .EarlyChange ==1{_baab =_db .NewReader (_baba ,_db .MSB ,8);}else {_baab =_e .NewReader (_baba ,_e .MSB ,8);};defer _baab .Close ();_ ,_aafc :=_eee .ReadFrom (_baab );if _aafc !=nil {return nil ,_aafc ;};return _eee .Bytes (),nil ;};

// GetNumbersAsFloat converts a list of pdf objects representing floats or integers to a slice of
// float64 values.
func GetNumbersAsFloat (objects []PdfObject )(_bfab []float64 ,_eafge error ){for _ ,_fcbb :=range objects {_aafea ,_fdfg :=GetNumberAsFloat (_fcbb );if _fdfg !=nil {return nil ,_fdfg ;};_bfab =append (_bfab ,_aafea );};return _bfab ,nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_ffga *JPXEncoder )UpdateParams (params *PdfObjectDictionary ){};

// IsEncrypted checks if the document is encrypted. A bool flag is returned indicating the result.
// First time when called, will check if the Encrypt dictionary is accessible through the trailer dictionary.
// If encrypted, prepares a crypt datastructure which can be used to authenticate and decrypt the document.
// On failure, an error is returned.
func (_gafec *PdfParser )IsEncrypted ()(bool ,error ){if _gafec ._ggd !=nil {return true ,nil ;}else if _gafec ._faca ==nil {return false ,nil ;};_cab .Log .Trace ("\u0043\u0068\u0065c\u006b\u0069\u006e\u0067 \u0065\u006e\u0063\u0072\u0079\u0070\u0074i\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0021");_gfge :=_gafec ._faca .Get ("\u0045n\u0063\u0072\u0079\u0070\u0074");if _gfge ==nil {return false ,nil ;};_cab .Log .Trace ("\u0049\u0073\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u0021");var (_egbb *PdfObjectDictionary ;);switch _dcgbg :=_gfge .(type ){case *PdfObjectDictionary :_egbb =_dcgbg ;case *PdfObjectReference :_cab .Log .Trace ("\u0030\u003a\u0020\u004c\u006f\u006f\u006b\u0020\u0075\u0070\u0020\u0072e\u0066\u0020\u0025\u0071",_dcgbg );_eedge ,_abgd :=_gafec .LookupByReference (*_dcgbg );_cab .Log .Trace ("\u0031\u003a\u0020%\u0071",_eedge );if _abgd !=nil {return false ,_abgd ;};_gfgde ,_adcgg :=_eedge .(*PdfIndirectObject );if !_adcgg {_cab .Log .Debug ("E\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006eo\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072ec\u0074\u0020\u006fb\u006ae\u0063\u0074");return false ,_g .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");};_cdaeg ,_adcgg :=_gfgde .PdfObject .(*PdfObjectDictionary );_cab .Log .Trace ("\u0032\u003a\u0020%\u0071",_cdaeg );if !_adcgg {return false ,_g .New ("\u0074\u0072a\u0069\u006c\u0065\u0072 \u0045\u006ec\u0072\u0079\u0070\u0074\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u006e\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");};_egbb =_cdaeg ;case *PdfObjectNull :_cab .Log .Debug ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074 \u0069\u0073\u0020a\u0020\u006e\u0075l\u006c\u0020o\u0062\u006a\u0065\u0063\u0074\u002e \u0046il\u0065\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u002e");return false ,nil ;default:return false ,_ce .Errorf ("u\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0079\u0070\u0065: \u0025\u0054",_dcgbg );};_gfgee ,_fgbdc :=PdfCryptNewDecrypt (_gafec ,_egbb ,_gafec ._faca );if _fgbdc !=nil {return false ,_fgbdc ;};for _ ,_bebgd :=range []string {"\u0045n\u0063\u0072\u0079\u0070\u0074"}{_beaa :=_gafec ._faca .Get (PdfObjectName (_bebgd ));if _beaa ==nil {continue ;};switch _egcca :=_beaa .(type ){case *PdfObjectReference :_gfgee ._bgb [int (_egcca .ObjectNumber )]=struct{}{};case *PdfIndirectObject :_gfgee ._fba [_egcca ]=true ;_gfgee ._bgb [int (_egcca .ObjectNumber )]=struct{}{};};};_gafec ._ggd =_gfgee ;_cab .Log .Trace ("\u0043\u0072\u0079\u0070\u0074\u0065\u0072\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0025\u0062",_gfgee );return true ,nil ;};

// NewJPXEncoder returns a new instance of JPXEncoder.
func NewJPXEncoder ()*JPXEncoder {return &JPXEncoder {}};

// DecodeBytes decodes a slice of ASCII encoded bytes and returns the result.
func (_edfe *ASCIIHexEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_accd :=_ced .NewReader (encoded );var _efag []byte ;for {_gdf ,_baf :=_accd .ReadByte ();if _baf !=nil {return nil ,_baf ;};if _gdf =='>'{break ;};if IsWhiteSpace (_gdf ){continue ;};if (_gdf >='a'&&_gdf <='f')||(_gdf >='A'&&_gdf <='F')||(_gdf >='0'&&_gdf <='9'){_efag =append (_efag ,_gdf );}else {_cab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0061\u0073\u0063\u0069\u0069 \u0068\u0065\u0078\u0020\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072 \u0028\u0025\u0063\u0029",_gdf );return nil ,_ce .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0061\u0073\u0063\u0069\u0069\u0020\u0068e\u0078 \u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u0020\u0028\u0025\u0063\u0029",_gdf );};};if len (_efag )%2==1{_efag =append (_efag ,'0');};_cab .Log .Trace ("\u0049\u006e\u0062\u006f\u0075\u006e\u0064\u0020\u0025\u0073",_efag );_aade :=make ([]byte ,_a .DecodedLen (len (_efag )));_ ,_dada :=_a .Decode (_aade ,_efag );if _dada !=nil {return nil ,_dada ;};return _aade ,nil ;};

// GetFilterName returns the names of the underlying encoding filters,
// separated by spaces.
// Note: This is just a string, should not be used in /Filter dictionary entry. Use GetFilterArray for that.
// TODO(v4): Refactor to GetFilter() which can be used for /Filter (either Name or Array), this can be
//  renamed to String() as a pretty string to use in debugging etc.
func (_ffgab *MultiEncoder )GetFilterName ()string {_fafb :="";for _ccab ,_bbcf :=range _ffgab ._dffc {_fafb +=_bbcf .GetFilterName ();if _ccab < len (_ffgab ._dffc )-1{_fafb +="\u0020";};};return _fafb ;};

// EncodeBytes encodes data into ASCII85 encoded format.
func (_adge *ASCII85Encoder )EncodeBytes (data []byte )([]byte ,error ){var _bbaa _ced .Buffer ;for _dgda :=0;_dgda < len (data );_dgda +=4{_dfggg :=data [_dgda ];_eafa :=1;_cbbg :=byte (0);if _dgda +1< len (data ){_cbbg =data [_dgda +1];_eafa ++;};_ddefa :=byte (0);if _dgda +2< len (data ){_ddefa =data [_dgda +2];_eafa ++;};_gaede :=byte (0);if _dgda +3< len (data ){_gaede =data [_dgda +3];_eafa ++;};_ddag :=(uint32 (_dfggg )<<24)|(uint32 (_cbbg )<<16)|(uint32 (_ddefa )<<8)|uint32 (_gaede );if _ddag ==0{_bbaa .WriteByte ('z');}else {_fcb :=_adge .base256Tobase85 (_ddag );for _ ,_edc :=range _fcb [:_eafa +1]{_bbaa .WriteByte (_edc +'!');};};};_bbaa .WriteString ("\u007e\u003e");return _bbaa .Bytes (),nil ;};

// GetNumberAsInt64 returns the contents of `obj` as an int64 if it is an integer or float, or an
// error if it isn't. This is for cases where expecting an integer, but some implementations
// actually store the number in a floating point format.
func GetNumberAsInt64 (obj PdfObject )(int64 ,error ){switch _fbcg :=obj .(type ){case *PdfObjectFloat :_cab .Log .Debug ("\u004e\u0075m\u0062\u0065\u0072\u0020\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0061\u0073\u0020\u0069\u006e\u0074e\u0067\u0065\u0072\u0020\u0077\u0061s\u0020\u0073\u0074\u006f\u0072\u0065\u0064\u0020\u0061\u0073\u0020\u0066\u006c\u006fa\u0074\u0020(\u0074\u0079\u0070\u0065 \u0063\u0061\u0073\u0074\u0069n\u0067\u0020\u0075\u0073\u0065\u0064\u0029");return int64 (*_fbcg ),nil ;case *PdfObjectInteger :return int64 (*_fbcg ),nil ;};return 0,ErrNotANumber ;};

// NewDCTEncoder makes a new DCT encoder with default parameters.
func NewDCTEncoder ()*DCTEncoder {_gafe :=&DCTEncoder {};_gafe .ColorComponents =3;_gafe .BitsPerComponent =8;_gafe .Quality =DefaultJPEGQuality ;return _gafe ;};

// ParseDict reads and parses a PDF dictionary object enclosed with '<<' and '>>'
func (_ebac *PdfParser )ParseDict ()(*PdfObjectDictionary ,error ){_cab .Log .Trace ("\u0052\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020D\u0069\u0063\u0074\u0021");_dcdfd :=MakeDict ();_dcdfd ._aagdf =_ebac ;_gfgb ,_ :=_ebac ._afbd .ReadByte ();if _gfgb !='<'{return nil ,_g .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");};_gfgb ,_ =_ebac ._afbd .ReadByte ();if _gfgb !='<'{return nil ,_g .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");};for {_ebac .skipSpaces ();_ebac .skipComments ();_fbacg ,_bgee :=_ebac ._afbd .Peek (2);if _bgee !=nil {return nil ,_bgee ;};_cab .Log .Trace ("D\u0069c\u0074\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_fbacg ),string (_fbacg ));if (_fbacg [0]=='>')&&(_fbacg [1]=='>'){_cab .Log .Trace ("\u0045\u004f\u0046\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");_ebac ._afbd .ReadByte ();_ebac ._afbd .ReadByte ();break ;};_cab .Log .Trace ("\u0050a\u0072s\u0065\u0020\u0074\u0068\u0065\u0020\u006e\u0061\u006d\u0065\u0021");_dddgc ,_bgee :=_ebac .parseName ();_cab .Log .Trace ("\u004be\u0079\u003a\u0020\u0025\u0073",_dddgc );if _bgee !=nil {_cab .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0052e\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006ea\u006d\u0065\u0020e\u0072r\u0020\u0025\u0073",_bgee );return nil ,_bgee ;};if len (_dddgc )> 4&&_dddgc [len (_dddgc )-4:]=="\u006e\u0075\u006c\u006c"{_gaeed :=_dddgc [0:len (_dddgc )-4];_cab .Log .Debug ("\u0054\u0061\u006b\u0069n\u0067\u0020\u0063\u0061\u0072\u0065\u0020\u006f\u0066\u0020n\u0075l\u006c\u0020\u0062\u0075\u0067\u0020\u0028%\u0073\u0029",_dddgc );_cab .Log .Debug ("\u004e\u0065\u0077\u0020ke\u0079\u0020\u0022\u0025\u0073\u0022\u0020\u003d\u0020\u006e\u0075\u006c\u006c",_gaeed );_ebac .skipSpaces ();_feff ,_ :=_ebac ._afbd .Peek (1);if _feff [0]=='/'{_dcdfd .Set (_gaeed ,MakeNull ());continue ;};};_ebac .skipSpaces ();_cedd ,_bgee :=_ebac .parseObject ();if _bgee !=nil {return nil ,_bgee ;};_dcdfd .Set (_dddgc ,_cedd );if _cab .Log .IsLogLevel (_cab .LogLevelTrace ){_cab .Log .Trace ("\u0064\u0069\u0063\u0074\u005b\u0025\u0073\u005d\u0020\u003d\u0020\u0025\u0073",_dddgc ,_cedd .String ());};};_cab .Log .Trace ("\u0072\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020\u0044\u0069\u0063\u0074\u0021");return _dcdfd ,nil ;};

// MakeString creates an PdfObjectString from a string.
// NOTE: PDF does not use utf-8 string encoding like Go so `s` will often not be a utf-8 encoded
// string.
func MakeString (s string )*PdfObjectString {_eeed :=PdfObjectString {_gcfee :s };return &_eeed };

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_gabb *FlateEncoder )MakeStreamDict ()*PdfObjectDictionary {_fbb :=MakeDict ();_fbb .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_gabb .GetFilterName ()));_dadb :=_gabb .MakeDecodeParams ();if _dadb !=nil {_fbb .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_dadb );};return _fbb ;};func (_ecgg *PdfParser )resolveReference (_fcca *PdfObjectReference )(PdfObject ,bool ,error ){_feae ,_fagcg :=_ecgg .ObjCache [int (_fcca .ObjectNumber )];if _fagcg {return _feae ,true ,nil ;};_fbae ,_bfbgd :=_ecgg .LookupByReference (*_fcca );if _bfbgd !=nil {return nil ,false ,_bfbgd ;};_ecgg .ObjCache [int (_fcca .ObjectNumber )]=_fbae ;return _fbae ,false ,nil ;};func (_ceed *PdfParser )xrefNextObjectOffset (_dcaf int64 )int64 {_aadgf :=int64 (0);if len (_ceed ._adde .ObjectMap )==0{return 0;};if len (_ceed ._adde ._cac )==0{_fagce :=0;for _ ,_dfegd :=range _ceed ._adde .ObjectMap {if _dfegd .Offset > 0{_fagce ++;};};if _fagce ==0{return 0;};_ceed ._adde ._cac =make ([]XrefObject ,_fagce );_cdde :=0;for _ ,_faff :=range _ceed ._adde .ObjectMap {if _faff .Offset > 0{_ceed ._adde ._cac [_cdde ]=_faff ;_cdde ++;};};_c .Slice (_ceed ._adde ._cac ,func (_ggae ,_cdbc int )bool {return _ceed ._adde ._cac [_ggae ].Offset < _ceed ._adde ._cac [_cdbc ].Offset });};_ddaa :=_c .Search (len (_ceed ._adde ._cac ),func (_aadc int )bool {return _ceed ._adde ._cac [_aadc ].Offset >=_dcaf });if _ddaa < len (_ceed ._adde ._cac ){_aadgf =_ceed ._adde ._cac [_ddaa ].Offset ;};return _aadgf ;};

// GetXrefOffset returns the offset of the xref table.
func (_dage *PdfParser )GetXrefOffset ()int64 {return _dage ._dbbdf };

// EncryptInfo contains an information generated by the document encrypter.
type EncryptInfo struct{Version ;

// Encrypt is an encryption dictionary that contains all necessary parameters.
// It should be stored in all copies of the document trailer.
Encrypt *PdfObjectDictionary ;

// ID0 and ID1 are IDs used in the trailer. Older algorithms such as RC4 uses them for encryption.
ID0 ,ID1 string ;};

// SetPredictor sets the predictor function.  Specify the number of columns per row.
// The columns indicates the number of samples per row.
// Used for grouping data together for compression.
func (_ecebb *FlateEncoder )SetPredictor (columns int ){_ecebb .Predictor =11;_ecebb .Columns =columns ;};func _gddb (_gedge ,_ggba ,_fdba uint8 )uint8 {_bcccg :=int (_fdba );_dffcb :=int (_ggba )-_bcccg ;_gac :=int (_gedge )-_bcccg ;_bcccg =_begcf (_dffcb +_gac );_dffcb =_begcf (_dffcb );_gac =_begcf (_gac );if _dffcb <=_gac &&_dffcb <=_bcccg {return _gedge ;}else if _gac <=_bcccg {return _ggba ;};return _fdba ;};

// MakeHexString creates an PdfObjectString from a string intended for output as a hexadecimal string.
func MakeHexString (s string )*PdfObjectString {_afbdd :=PdfObjectString {_gcfee :s ,_cfde :true };return &_afbdd ;};func (_fb *PdfParser )lookupObjectViaOS (_acg int ,_bf int )(PdfObject ,error ){var _bfa *_ced .Reader ;var _cea objectStream ;var _fbd bool ;_cea ,_fbd =_fb ._abeb [_acg ];if !_fbd {_bde ,_deg :=_fb .LookupByNumber (_acg );if _deg !=nil {_cab .Log .Debug ("\u004d\u0069ss\u0069\u006e\u0067 \u006f\u0062\u006a\u0065ct \u0073tr\u0065\u0061\u006d\u0020\u0077\u0069\u0074h \u006e\u0075\u006d\u0062\u0065\u0072\u0020%\u0064",_acg );return nil ,_deg ;};_fg ,_beg :=_bde .(*PdfObjectStream );if !_beg {return nil ,_g .New ("i\u006e\u0076\u0061\u006cid\u0020o\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d");};if _fb ._ggd !=nil &&!_fb ._ggd .isDecrypted (_fg ){return nil ,_g .New ("\u006e\u0065\u0065\u0064\u0020\u0074\u006f\u0020\u0064\u0065\u0063r\u0079\u0070\u0074\u0020\u0074\u0068\u0065\u0020\u0073\u0074r\u0065\u0061\u006d");};_cg :=_fg .PdfObjectDictionary ;_cab .Log .Trace ("\u0073o\u0020\u0064\u003a\u0020\u0025\u0073\n",_cg .String ());_dc ,_beg :=_cg .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if !_beg {_cab .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0061\u006c\u0077\u0061\u0079\u0073\u0020\u0068\u0061\u0076\u0065\u0020\u0061\u0020\u0054\u0079\u0070\u0065");return nil ,_g .New ("\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020T\u0079\u0070\u0065");};if _ee .ToLower (string (*_dc ))!="\u006f\u0062\u006a\u0073\u0074\u006d"{_cab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0074\u0079\u0070\u0065\u0020s\u0068\u0061\u006c\u006c\u0020\u0061\u006c\u0077\u0061\u0079\u0073 \u0062\u0065\u0020\u004f\u0062\u006a\u0053\u0074\u006d\u0020\u0021");return nil ,_g .New ("\u006f\u0062\u006a\u0065c\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0074y\u0070e\u0020\u0021\u003d\u0020\u004f\u0062\u006aS\u0074\u006d");};N ,_beg :=_cg .Get ("\u004e").(*PdfObjectInteger );if !_beg {return nil ,_g .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u004e\u0020i\u006e\u0020\u0073\u0074\u0072\u0065\u0061m\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_agg ,_beg :=_cg .Get ("\u0046\u0069\u0072s\u0074").(*PdfObjectInteger );if !_beg {return nil ,_g .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0046\u0069\u0072\u0073\u0074\u0020i\u006e \u0073t\u0072e\u0061\u006d\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_cab .Log .Trace ("\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0073\u0020\u006eu\u006d\u0062\u0065\u0072\u0020\u006f\u0066 \u006f\u0062\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_dc ,*N );_age ,_deg :=DecodeStream (_fg );if _deg !=nil {return nil ,_deg ;};_cab .Log .Trace ("D\u0065\u0063\u006f\u0064\u0065\u0064\u003a\u0020\u0025\u0073",_age );_dba :=_fb .GetFileOffset ();defer func (){_fb .SetFileOffset (_dba )}();_bfa =_ced .NewReader (_age );_fb ._afbd =_dg .NewReader (_bfa );_cab .Log .Trace ("\u0050a\u0072s\u0069\u006e\u0067\u0020\u006ff\u0066\u0073e\u0074\u0020\u006d\u0061\u0070");_cedc :=map[int ]int64 {};for _gba :=0;_gba < int (*N );_gba ++{_fb .skipSpaces ();_bc ,_begg :=_fb .parseNumber ();if _begg !=nil {return nil ,_begg ;};_dcc ,_agec :=_bc .(*PdfObjectInteger );if !_agec {return nil ,_g .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");};_fb .skipSpaces ();_bc ,_begg =_fb .parseNumber ();if _begg !=nil {return nil ,_begg ;};_ccc ,_agec :=_bc .(*PdfObjectInteger );if !_agec {return nil ,_g .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");};_cab .Log .Trace ("\u006f\u0062j\u0020\u0025\u0064 \u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0025\u0064",*_dcc ,*_ccc );_cedc [int (*_dcc )]=int64 (*_agg +*_ccc );};_cea =objectStream {N :int (*N ),_eb :_age ,_dgd :_cedc };_fb ._abeb [_acg ]=_cea ;}else {_bcd :=_fb .GetFileOffset ();defer func (){_fb .SetFileOffset (_bcd )}();_bfa =_ced .NewReader (_cea ._eb );_fb ._afbd =_dg .NewReader (_bfa );};_bff :=_cea ._dgd [_bf ];_cab .Log .Trace ("\u0041\u0043\u0054\u0055AL\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u005b\u0025\u0064\u005d\u0020\u003d\u0020%\u0064",_bf ,_bff );_bfa .Seek (_bff ,_ge .SeekStart );_fb ._afbd =_dg .NewReader (_bfa );_gaa ,_ :=_fb ._afbd .Peek (100);_cab .Log .Trace ("\u004f\u0042\u004a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_gaa ));_ff ,_cce :=_fb .parseObject ();if _cce !=nil {_cab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c \u0074\u006f\u0020\u0072\u0065\u0061\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_cce );return nil ,_cce ;};if _ff ==nil {return nil ,_g .New ("o\u0062\u006a\u0065\u0063t \u0063a\u006e\u006e\u006f\u0074\u0020b\u0065\u0020\u006e\u0075\u006c\u006c");};_dee :=PdfIndirectObject {};_dee .ObjectNumber =int64 (_bf );_dee .PdfObject =_ff ;return &_dee ,nil ;};

// PdfObjectFloat represents the primitive PDF floating point numerical object.
type PdfObjectFloat float64 ;

// String returns a descriptive information string about the encryption method used.
func (_fbf *PdfCrypt )String ()string {if _fbf ==nil {return "";};_bca :=_fbf ._gead .Filter +"\u0020\u002d\u0020";if _fbf ._gead .V ==0{_bca +="\u0055\u006e\u0064\u006fcu\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0061\u006c\u0067\u006f\u0072\u0069\u0074h\u006d";}else if _fbf ._gead .V ==1{_bca +="\u0052\u0043\u0034:\u0020\u0034\u0030\u0020\u0062\u0069\u0074\u0073";}else if _fbf ._gead .V ==2{_bca +=_ce .Sprintf ("\u0052\u0043\u0034:\u0020\u0025\u0064\u0020\u0062\u0069\u0074\u0073",_fbf ._gead .Length );}else if _fbf ._gead .V ==3{_bca +="U\u006e\u0070\u0075\u0062li\u0073h\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d";}else if _fbf ._gead .V >=4{_bca +=_ce .Sprintf ("\u0053\u0074r\u0065\u0061\u006d\u0020f\u0069\u006ct\u0065\u0072\u003a\u0020\u0025\u0073\u0020\u002d \u0053\u0074\u0072\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0074\u0065r\u003a\u0020\u0025\u0073",_fbf ._degc ,_fbf ._dcbe );_bca +="\u003b\u0020C\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0073\u003a";for _bgf ,_gccg :=range _fbf ._faa {_bca +=_ce .Sprintf ("\u0020\u002d\u0020\u0025\u0073\u003a\u0020\u0025\u0073 \u0028\u0025\u0064\u0029",_bgf ,_gccg .Name (),_gccg .KeyLength ());};};_eeb :=_fbf .GetAccessPermissions ();_bca +=_ce .Sprintf ("\u0020\u002d\u0020\u0025\u0023\u0076",_eeb );return _bca ;};func _aeca (_fbda *PdfObjectStream ,_ffbd *PdfObjectDictionary )(*JBIG2Encoder ,error ){const _aafba ="\u006ee\u0077\u004a\u0042\u0049G\u0032\u0044\u0065\u0063\u006fd\u0065r\u0046r\u006f\u006d\u0053\u0074\u0072\u0065\u0061m";_cdg :=&JBIG2Encoder {};_gff :=_fbda .PdfObjectDictionary ;if _gff ==nil {return _cdg ,nil ;};if _ffbd ==nil {_afaf :=_gff .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _afaf !=nil {switch _ddbba :=_afaf .(type ){case *PdfObjectDictionary :_ffbd =_ddbba ;case *PdfObjectArray :if _ddbba .Len ()==1{if _cgbgb ,_ffee :=GetDict (_ddbba .Get (0));_ffee {_ffbd =_cgbgb ;};};default:_cab .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065P\u0061\u0072\u0061\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064i\u0063\u0074\u0069\u006f\u006e\u0061\u0072y\u0020\u0025\u0023\u0076",_afaf );return nil ,_eea .Errorf (_aafba ,"\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050a\u0072m\u0073\u0020\u0074\u0079\u0070\u0065\u003a \u0025\u0054",_ddbba );};};};if _ffbd ==nil {return _cdg ,nil ;};_cdg .UpdateParams (_ffbd );_ebdd :=_ffbd .Get ("\u004a\u0042\u0049G\u0032\u0047\u006c\u006f\u0062\u0061\u006c\u0073");if _ebdd ==nil {return _cdg ,nil ;};var _dbad error ;_cdca ,_gbabg :=_ebdd .(*PdfObjectStream );if !_gbabg {_dbad =_eea .Error (_aafba ,"j\u0062\u0069\u0067\u0032\u002e\u0047\u006c\u006f\u0062a\u006c\u0073\u0020\u0073\u0074\u0072\u0065am\u0020\u0073\u0068\u006fu\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u006e\u0020Ob\u006a\u0065c\u0074\u0020\u0053\u0074\u0072\u0065\u0061\u006d");_cab .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_dbad );return nil ,_dbad ;};_cdg .Globals ,_dbad =_ac .DecodeGlobals (_cdca .Stream );if _dbad !=nil {_dbad =_eea .Wrap (_dbad ,_aafba ,"\u0063\u006f\u0072\u0072u\u0070\u0074\u0065\u0064\u0020\u006a\u0062\u0069\u0067\u0032 \u0065n\u0063\u006f\u0064\u0065\u0064\u0020\u0064a\u0074\u0061");_cab .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_dbad );return nil ,_dbad ;};return _cdg ,nil ;};

// AddEncoder adds the passed in encoder to the underlying encoder slice.
func (_fcda *MultiEncoder )AddEncoder (encoder StreamEncoder ){_fcda ._dffc =append (_fcda ._dffc ,encoder );};func (_dfac *JBIG2Image )toBitmap ()(_fafg *_ef .Bitmap ,_fdbg error ){const _bebc ="\u004a\u0042\u0049\u00472I\u006d\u0061\u0067\u0065\u002e\u0074\u006f\u0042\u0069\u0074\u006d\u0061\u0070";if _dfac .Data ==nil {return nil ,_eea .Error (_bebc ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");};if _dfac .Width ==0||_dfac .Height ==0{return nil ,_eea .Error (_bebc ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");};if _dfac .HasPadding {_fafg ,_fdbg =_ef .NewWithData (_dfac .Width ,_dfac .Height ,_dfac .Data );}else {_fafg ,_fdbg =_ef .NewWithUnpaddedData (_dfac .Width ,_dfac .Height ,_dfac .Data );};if _fdbg !=nil {return nil ,_eea .Wrap (_fdbg ,_bebc ,"");};return _fafg ,nil ;};

// MakeIndirectObject creates an PdfIndirectObject with a specified direct object PdfObject.
func MakeIndirectObject (obj PdfObject )*PdfIndirectObject {_egfc :=&PdfIndirectObject {};_egfc .PdfObject =obj ;return _egfc ;};

// Remove removes an element specified by key.
func (_gbbc *PdfObjectDictionary )Remove (key PdfObjectName ){_bdga :=-1;for _agaa ,_cged :=range _gbbc ._eafbb {if _cged ==key {_bdga =_agaa ;break ;};};if _bdga >=0{_gbbc ._eafbb =append (_gbbc ._eafbb [:_bdga ],_gbbc ._eafbb [_bdga +1:]...);delete (_gbbc ._agcee ,key );};};

// UpdateParams updates the parameter values of the encoder.
func (_aba *LZWEncoder )UpdateParams (params *PdfObjectDictionary ){_bbdg ,_add :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _add ==nil {_aba .Predictor =int (_bbdg );};_gfe ,_add :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _add ==nil {_aba .BitsPerComponent =int (_gfe );};_bccb ,_add :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _add ==nil {_aba .Columns =int (_bccb );};_eebg ,_add :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _add ==nil {_aba .Colors =int (_eebg );};_acbd ,_add :=GetNumberAsInt64 (params .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065"));if _add ==nil {_aba .EarlyChange =int (_acbd );};};

// UpdateParams updates the parameter values of the encoder.
func (_ddca *MultiEncoder )UpdateParams (params *PdfObjectDictionary ){for _ ,_fdc :=range _ddca ._dffc {_fdc .UpdateParams (params );};};func _abefg (_gegf ,_cffd PdfObject ,_gbcc int )bool {if _gbcc > _bbba {_cab .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_bbba );return false ;};if _gegf ==nil &&_cffd ==nil {return true ;}else if _gegf ==nil ||_cffd ==nil {return false ;};if _b .TypeOf (_gegf )!=_b .TypeOf (_cffd ){return false ;};switch _bgaa :=_gegf .(type ){case *PdfObjectNull ,*PdfObjectReference :return true ;case *PdfObjectName :return *_bgaa ==*(_cffd .(*PdfObjectName ));case *PdfObjectString :return *_bgaa ==*(_cffd .(*PdfObjectString ));case *PdfObjectInteger :return *_bgaa ==*(_cffd .(*PdfObjectInteger ));case *PdfObjectBool :return *_bgaa ==*(_cffd .(*PdfObjectBool ));case *PdfObjectFloat :return *_bgaa ==*(_cffd .(*PdfObjectFloat ));case *PdfIndirectObject :return _abefg (TraceToDirectObject (_gegf ),TraceToDirectObject (_cffd ),_gbcc +1);case *PdfObjectArray :_edeb :=_cffd .(*PdfObjectArray );if len ((*_bgaa )._gaggf )!=len ((*_edeb )._gaggf ){return false ;};for _fcfgb ,_cgaae :=range (*_bgaa )._gaggf {if !_abefg (_cgaae ,(*_edeb )._gaggf [_fcfgb ],_gbcc +1){return false ;};};return true ;case *PdfObjectDictionary :_cbc :=_cffd .(*PdfObjectDictionary );_gace ,_cdeag :=(*_bgaa )._agcee ,(*_cbc )._agcee ;if len (_gace )!=len (_cdeag ){return false ;};for _gdfd ,_gfcge :=range _gace {_agcae ,_ccbg :=_cdeag [_gdfd ];if !_ccbg ||!_abefg (_gfcge ,_agcae ,_gbcc +1){return false ;};};return true ;case *PdfObjectStream :_acbe :=_cffd .(*PdfObjectStream );return _abefg ((*_bgaa ).PdfObjectDictionary ,(*_acbe ).PdfObjectDictionary ,_gbcc +1);default:_cab .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",_gegf );};return false ;};

// IsFloatDigit checks if a character can be a part of a float number string.
func IsFloatDigit (c byte )bool {return ('0'<=c &&c <='9')||c =='.'};

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_aeeg *RunLengthEncoder )EncodeBytes (data []byte )([]byte ,error ){_fdf :=_ced .NewReader (data );var _cbd []byte ;var _acbg []byte ;_abca ,_daaa :=_fdf .ReadByte ();if _daaa ==_ge .EOF {return []byte {},nil ;}else if _daaa !=nil {return nil ,_daaa ;};_gefb :=1;for {_dab ,_cgbe :=_fdf .ReadByte ();if _cgbe ==_ge .EOF {break ;}else if _cgbe !=nil {return nil ,_cgbe ;};if _dab ==_abca {if len (_acbg )> 0{_acbg =_acbg [:len (_acbg )-1];if len (_acbg )> 0{_cbd =append (_cbd ,byte (len (_acbg )-1));_cbd =append (_cbd ,_acbg ...);};_gefb =1;_acbg =[]byte {};};_gefb ++;if _gefb >=127{_cbd =append (_cbd ,byte (257-_gefb ),_abca );_gefb =0;};}else {if _gefb > 0{if _gefb ==1{_acbg =[]byte {_abca };}else {_cbd =append (_cbd ,byte (257-_gefb ),_abca );};_gefb =0;};_acbg =append (_acbg ,_dab );if len (_acbg )>=127{_cbd =append (_cbd ,byte (len (_acbg )-1));_cbd =append (_cbd ,_acbg ...);_acbg =[]byte {};};};_abca =_dab ;};if len (_acbg )> 0{_cbd =append (_cbd ,byte (len (_acbg )-1));_cbd =append (_cbd ,_acbg ...);}else if _gefb > 0{_cbd =append (_cbd ,byte (257-_gefb ),_abca );};_cbd =append (_cbd ,128);return _cbd ,nil ;};

// GetFilterName returns the name of the encoding filter.
func (_aeed *JBIG2Encoder )GetFilterName ()string {return StreamEncodingFilterNameJBIG2 };

// GetFilterName returns the name of the encoding filter.
func (_dfce *ASCII85Encoder )GetFilterName ()string {return StreamEncodingFilterNameASCII85 };

// Append appends PdfObject(s) to the streams.
func (_dcce *PdfObjectStreams )Append (objects ...PdfObject ){if _dcce ==nil {_cab .Log .Debug ("\u0057\u0061\u0072\u006e\u0020-\u0020\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0020\u0074\u006f\u0020\u0061p\u0070\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0073");return ;};_dcce ._gccb =append (_dcce ._gccb ,objects ...);};

// Get returns the PdfObject corresponding to the specified key.
// Returns a nil value if the key is not set.
func (_gbfc *PdfObjectDictionary )Get (key PdfObjectName )PdfObject {_efgdd ,_cedec :=_gbfc ._agcee [key ];if !_cedec {return nil ;};return _efgdd ;};

// NewParserFromString is used for testing purposes.
func NewParserFromString (txt string )*PdfParser {_fagcb :=_ced .NewReader ([]byte (txt ));_gacf :=&PdfParser {ObjCache :objectCache {},_bfca :_fagcb ,_afbd :_dg .NewReader (_fagcb ),_cfbg :int64 (len (txt )),_gcd :map[int64 ]bool {}};_gacf ._adde .ObjectMap =make (map[int ]XrefObject );return _gacf ;};

// NewCCITTFaxEncoder makes a new CCITTFax encoder.
func NewCCITTFaxEncoder ()*CCITTFaxEncoder {return &CCITTFaxEncoder {Columns :1728,EndOfBlock :true }};

// UpdateParams updates the parameter values of the encoder.
// Implements StreamEncoder interface.
func (_fbbc *JBIG2Encoder )UpdateParams (params *PdfObjectDictionary ){_fffdd ,_eeda :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _eeda ==nil {_fbbc .BitsPerComponent =int (_fffdd );};_eafbc ,_eeda :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _eeda ==nil {_fbbc .Width =int (_eafbc );};_ffba ,_eeda :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _eeda ==nil {_fbbc .Height =int (_ffba );};_adgef ,_eeda :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _eeda ==nil {_fbbc .ColorComponents =int (_adgef );};};func _dgge (_ebfa _ge .ReadSeeker ,_bae int64 )(*offsetReader ,error ){_ddebg :=&offsetReader {_edgc :_ebfa ,_gcedg :_bae };_ ,_edae :=_ddebg .Seek (0,_ge .SeekStart );return _ddebg ,_edae ;};

// DecodeGlobals decodes 'encoded' byte stream and returns their Globally defined segments ('Globals').
func (_cgfe *JBIG2Encoder )DecodeGlobals (encoded []byte )(_ac .Globals ,error ){return _ac .DecodeGlobals (encoded );};

// IsOctalDigit checks if a character can be part of an octal digit string.
func IsOctalDigit (c byte )bool {return '0'<=c &&c <='7'};

// PdfCryptNewDecrypt makes the document crypt handler based on the encryption dictionary
// and trailer dictionary. Returns an error on failure to process.
func PdfCryptNewDecrypt (parser *PdfParser ,ed ,trailer *PdfObjectDictionary )(*PdfCrypt ,error ){_bgfb :=&PdfCrypt {_aed :false ,_fba :make (map[PdfObject ]bool ),_bdc :make (map[PdfObject ]bool ),_bgb :make (map[int ]struct{}),_cbe :parser };_abff ,_fgg :=ed .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectName );if !_fgg {_cab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0043\u0072\u0079\u0070\u0074 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061r\u0079 \u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u0066\u0069\u0065\u006c\u0064\u0021");return _bgfb ,_g .New ("r\u0065\u0071\u0075\u0069\u0072\u0065d\u0020\u0063\u0072\u0079\u0070\u0074 \u0066\u0069\u0065\u006c\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u006d\u0069\u0073\u0073\u0069n\u0067");};if *_abff !="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"{_cab .Log .Debug ("\u0045\u0052R\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020(%\u0073\u0029",*_abff );return _bgfb ,_g .New ("\u0075n\u0073u\u0070\u0070\u006f\u0072\u0074e\u0064\u0020F\u0069\u006c\u0074\u0065\u0072");};_bgfb ._gead .Filter =string (*_abff );if _feg ,_aga :=ed .Get ("\u0053u\u0062\u0046\u0069\u006c\u0074\u0065r").(*PdfObjectString );_aga {_bgfb ._gead .SubFilter =_feg .Str ();_cab .Log .Debug ("\u0055s\u0069n\u0067\u0020\u0073\u0075\u0062f\u0069\u006ct\u0065\u0072\u0020\u0025\u0073",_feg );};if L ,_eeaa :=ed .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );_eeaa {if (*L %8)!=0{_cab .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0049\u006ev\u0061\u006c\u0069\u0064\u0020\u0065\u006ec\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006c\u0065\u006e\u0067\u0074\u0068");return _bgfb ,_g .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0065\u006e\u0063\u0072y\u0070t\u0069o\u006e\u0020\u006c\u0065\u006e\u0067\u0074h");};_bgfb ._gead .Length =int (*L );}else {_bgfb ._gead .Length =40;};_bgfb ._gead .V =0;if _aac ,_daa :=ed .Get ("\u0056").(*PdfObjectInteger );_daa {V :=int (*_aac );_bgfb ._gead .V =V ;if V >=1&&V <=2{_bgfb ._faa =_abfa (_bgfb ._gead .Length );}else if V >=4&&V <=5{if _fd :=_bgfb .loadCryptFilters (ed );_fd !=nil {return _bgfb ,_fd ;};}else {_cab .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0061lg\u006f\u0020\u0056 \u003d \u0025\u0064",V );return _bgfb ,_g .New ("u\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d");};};if _bec :=_dbg (&_bgfb ._gfa ,ed );_bec !=nil {return _bgfb ,_bec ;};_cdc :="";if _fga ,_dfc :=trailer .Get ("\u0049\u0044").(*PdfObjectArray );_dfc &&_fga .Len ()>=1{_efd ,_gge :=GetString (_fga .Get (0));if !_gge {return _bgfb ,_g .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0074r\u0061\u0069l\u0065\u0072\u0020\u0049\u0044");};_cdc =_efd .Str ();}else {_cab .Log .Debug ("\u0054\u0072ai\u006c\u0065\u0072 \u0049\u0044\u0020\u0061rra\u0079 m\u0069\u0073\u0073\u0069\u006e\u0067\u0020or\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0021");};_bgfb ._gae =_cdc ;return _bgfb ,nil ;};

// Decoded returns the PDFDocEncoding or UTF-16BE decoded string contents.
// UTF-16BE is applied when the first two bytes are 0xFE, 0XFF, otherwise decoding of
// PDFDocEncoding is performed.
func (_bcab *PdfObjectString )Decoded ()string {if _bcab ==nil {return "";};_fdded :=[]byte (_bcab ._gcfee );if len (_fdded )>=2&&_fdded [0]==0xFE&&_fdded [1]==0xFF{return _gcf .UTF16ToString (_fdded [2:]);};return _gcf .PDFDocEncodingToString (_fdded );};

// GetTrailer returns the PDFs trailer dictionary. The trailer dictionary is typically the starting point for a PDF,
// referencing other key objects that are important in the document structure.
func (_agegb *PdfParser )GetTrailer ()*PdfObjectDictionary {return _agegb ._faca };func (_beff *PdfObjectFloat )String ()string {return _ce .Sprintf ("\u0025\u0066",*_beff )};

// String returns a string describing `stream`.
func (_baac *PdfObjectStream )String ()string {return _ce .Sprintf ("O\u0062j\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0025\u0064: \u0025\u0073",_baac .ObjectNumber ,_baac .PdfObjectDictionary );};var _deff =_cc .MustCompile ("\u005e\\\u0073\u002a\u005b\u002d]\u002a\u0028\u005c\u0064\u002b)\u005cs\u002b(\u005c\u0064\u002b\u0029\u005c\u0073\u002bR");

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_cff *JPXEncoder )MakeDecodeParams ()PdfObject {return nil };func _gcfe (_bdaa _cedb .Image )*JBIG2Image {_egcc :=_bdaa .Base ();return &JBIG2Image {Data :_egcc .Data ,Width :_egcc .Width ,Height :_egcc .Height ,HasPadding :true };};

// MakeArrayFromIntegers64 creates an PdfObjectArray from a slice of int64s, where each array element
// is an PdfObjectInteger.
func MakeArrayFromIntegers64 (vals []int64 )*PdfObjectArray {_fbabf :=MakeArray ();for _ ,_egbd :=range vals {_fbabf .Append (MakeInteger (_egbd ));};return _fbabf ;};var _gcfd =_cc .MustCompile ("\u0028\u005c\u0064\u002b)\\\u0073\u002b\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u006f\u0062\u006a");

// EncodeStream encodes the stream data using the encoded specified by the stream's dictionary.
func EncodeStream (streamObj *PdfObjectStream )error {_cab .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_cafg ,_dgbb :=NewEncoderFromStream (streamObj );if _dgbb !=nil {_cab .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_dgbb );return _dgbb ;};if _gagad ,_ggga :=_cafg .(*LZWEncoder );_ggga {_gagad .EarlyChange =0;streamObj .PdfObjectDictionary .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (0));};_cab .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076\u000a",_cafg );_gbdb ,_dgbb :=_cafg .EncodeBytes (streamObj .Stream );if _dgbb !=nil {_cab .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_dgbb );return _dgbb ;};streamObj .Stream =_gbdb ;streamObj .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_gbdb ))));return nil ;};

// GetFilterName returns the name of the encoding filter.
func (_dbbd *CCITTFaxEncoder )GetFilterName ()string {return StreamEncodingFilterNameCCITTFax };

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_gde *DCTEncoder )MakeDecodeParams ()PdfObject {return nil };

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_bbde *CCITTFaxEncoder )MakeDecodeParams ()PdfObject {_gcbe :=MakeDict ();_gcbe .Set ("\u004b",MakeInteger (int64 (_bbde .K )));_gcbe .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_bbde .Columns )));if _bbde .BlackIs1 {_gcbe .Set ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031",MakeBool (_bbde .BlackIs1 ));};if _bbde .EncodedByteAlign {_gcbe .Set ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e",MakeBool (_bbde .EncodedByteAlign ));};if _bbde .EndOfLine &&_bbde .K >=0{_gcbe .Set ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee",MakeBool (_bbde .EndOfLine ));};if _bbde .Rows !=0&&!_bbde .EndOfBlock {_gcbe .Set ("\u0052\u006f\u0077\u0073",MakeInteger (int64 (_bbde .Rows )));};if !_bbde .EndOfBlock {_gcbe .Set ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b",MakeBool (_bbde .EndOfBlock ));};if _bbde .DamagedRowsBeforeError !=0{_gcbe .Set ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072",MakeInteger (int64 (_bbde .DamagedRowsBeforeError )));};return _gcbe ;};

// GetFilterName returns the name of the encoding filter.
func (_gbff *DCTEncoder )GetFilterName ()string {return StreamEncodingFilterNameDCT };

// ParseNumber parses a numeric objects from a buffered stream.
// Section 7.3.3.
// Integer or Float.
//
// An integer shall be written as one or more decimal digits optionally
// preceded by a sign. The value shall be interpreted as a signed
// decimal integer and shall be converted to an integer object.
//
// A real value shall be written as one or more decimal digits with an
// optional sign and a leading, trailing, or embedded PERIOD (2Eh)
// (decimal point). The value shall be interpreted as a real number
// and shall be converted to a real object.
//
// Regarding exponential numbers: 7.3.3 Numeric Objects:
// A conforming writer shall not use the PostScript syntax for numbers
// with non-decimal radices (such as 16#FFFE) or in exponential format
// (such as 6.02E23).
// Nonetheless, we sometimes get numbers with exponential format, so
// we will support it in the reader (no confusion with other types, so
// no compromise).
func ParseNumber (buf *_dg .Reader )(PdfObject ,error ){_abae :=false ;_bcdbe :=true ;var _gcee _ced .Buffer ;for {if _cab .Log .IsLogLevel (_cab .LogLevelTrace ){_cab .Log .Trace ("\u0050\u0061\u0072\u0073in\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0022\u0025\u0073\u0022",_gcee .String ());};_cbgf ,_ebee :=buf .Peek (1);if _ebee ==_ge .EOF {break ;};if _ebee !=nil {_cab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0025\u0073",_ebee );return nil ,_ebee ;};if _bcdbe &&(_cbgf [0]=='-'||_cbgf [0]=='+'){_edagg ,_ :=buf .ReadByte ();_gcee .WriteByte (_edagg );_bcdbe =false ;}else if IsDecimalDigit (_cbgf [0]){_bcfc ,_ :=buf .ReadByte ();_gcee .WriteByte (_bcfc );}else if _cbgf [0]=='.'{_dfge ,_ :=buf .ReadByte ();_gcee .WriteByte (_dfge );_abae =true ;}else if _cbgf [0]=='e'||_cbgf [0]=='E'{_acbc ,_ :=buf .ReadByte ();_gcee .WriteByte (_acbc );_abae =true ;_bcdbe =true ;}else {break ;};};var _defb PdfObject ;if _abae {_gbec ,_cfgg :=_ga .ParseFloat (_gcee .String (),64);if _cfgg !=nil {_cab .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0025v\u0020\u0065\u0072\u0072\u003d\u0025v\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0030\u002e\u0020\u004fu\u0074\u0070u\u0074\u0020\u006d\u0061y\u0020\u0062\u0065\u0020\u0069n\u0063\u006f\u0072\u0072\u0065\u0063\u0074",_gcee .String (),_cfgg );_gbec =0.0;};_edaa :=PdfObjectFloat (_gbec );_defb =&_edaa ;}else {_afeg ,_feec :=_ga .ParseInt (_gcee .String (),10,64);if _feec !=nil {_cab .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0025\u0076\u0020\u0065\u0072\u0072\u003d%\u0076\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074 \u006d\u0061\u0079\u0020\u0062\u0065 \u0069\u006ec\u006f\u0072r\u0065c\u0074",_gcee .String (),_feec );_afeg =0;};_bdgbb :=PdfObjectInteger (_afeg );_defb =&_bdgbb ;};return _defb ,nil ;};

// MakeEncodedString creates a PdfObjectString with encoded content, which can be either
// UTF-16BE or PDFDocEncoding depending on whether `utf16BE` is true or false respectively.
func MakeEncodedString (s string ,utf16BE bool )*PdfObjectString {if utf16BE {var _geda _ced .Buffer ;_geda .Write ([]byte {0xFE,0xFF});_geda .WriteString (_gcf .StringToUTF16 (s ));return &PdfObjectString {_gcfee :_geda .String (),_cfde :true };};return &PdfObjectString {_gcfee :string (_gcf .StringToPDFDocEncoding (s )),_cfde :false };};type xrefType int ;

// PdfVersion returns version of the PDF file.
func (_ffbe *PdfParser )PdfVersion ()Version {return _ffbe ._abfd };

// MakeInteger creates a PdfObjectInteger from an int64.
func MakeInteger (val int64 )*PdfObjectInteger {_fagg :=PdfObjectInteger (val );return &_fagg };func _begcf (_dcbab int )int {_ecb :=_dcbab >>(_abadf -1);return (_dcbab ^_ecb )-_ecb };

// GetBool returns the *PdfObjectBool object that is represented by a PdfObject directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetBool (obj PdfObject )(_cgfdd *PdfObjectBool ,_cfea bool ){_cgfdd ,_cfea =TraceToDirectObject (obj ).(*PdfObjectBool );return _cgfdd ,_cfea ;};

// WriteString outputs the object as it is to be written to file.
func (_ebfb *PdfObjectNull )WriteString ()string {return "\u006e\u0075\u006c\u006c"};

// Len returns the number of elements in the streams.
func (_aaea *PdfObjectStreams )Len ()int {if _aaea ==nil {return 0;};return len (_aaea ._gccb );};

// GetName returns the *PdfObjectName represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetName (obj PdfObject )(_bdgc *PdfObjectName ,_caad bool ){_bdgc ,_caad =TraceToDirectObject (obj ).(*PdfObjectName );return _bdgc ,_caad ;};

// Get returns the i-th element of the array or nil if out of bounds (by index).
func (_cfaaf *PdfObjectArray )Get (i int )PdfObject {if _cfaaf ==nil ||i >=len (_cfaaf ._gaggf )||i < 0{return nil ;};return _cfaaf ._gaggf [i ];};

// EncodeBytes DCT encodes the passed in slice of bytes.
func (_aggc *DCTEncoder )EncodeBytes (data []byte )([]byte ,error ){_gaed ,_aacd :=_cedb .NewImage (_aggc .Width ,_aggc .Height ,_aggc .BitsPerComponent ,_aggc .ColorComponents ,data ,nil ,nil );if _aacd !=nil {return nil ,_aacd ;};_eabf :=_gc .Options {};_eabf .Quality =_aggc .Quality ;var _gfad _ced .Buffer ;if _aacd =_gc .Encode (&_gfad ,_gaed ,&_eabf );_aacd !=nil {return nil ,_aacd ;};return _gfad .Bytes (),nil ;};

// Encrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_fadc *PdfCrypt )Encrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _fadc .isEncrypted (obj ){return nil ;};switch _bagf :=obj .(type ){case *PdfIndirectObject :_fadc ._bdc [_bagf ]=true ;_cab .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_bagf .ObjectNumber ,_bagf .GenerationNumber );_ddbd :=_bagf .ObjectNumber ;_daee :=_bagf .GenerationNumber ;_bfe :=_fadc .Encrypt (_bagf .PdfObject ,_ddbd ,_daee );if _bfe !=nil {return _bfe ;};return nil ;case *PdfObjectStream :_fadc ._bdc [_bagf ]=true ;_ebd :=_bagf .PdfObjectDictionary ;if _feaa ,_cgb :=_ebd .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_cgb &&*_feaa =="\u0058\u0052\u0065\u0066"{return nil ;};_bbad :=_bagf .ObjectNumber ;_efe :=_bagf .GenerationNumber ;_cab .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_bbad ,_efe );_bcea :=_bdcc ;if _fadc ._gead .V >=4{_bcea =_fadc ._degc ;_cab .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_fadc ._degc );if _cgba ,_gedf :=_ebd .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );_gedf {if _eae ,_fege :=GetName (_cgba .Get (0));_fege {if *_eae =="\u0043\u0072\u0079p\u0074"{_bcea ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _cefd ,_bdee :=_ebd .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );_bdee {if _gfae ,_bdba :=_cefd .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_bdba {if _ ,_fggf :=_fadc ._faa [string (*_gfae )];_fggf {_cab .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_gfae );_bcea =string (*_gfae );};};};};};};_cab .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_bcea );if _bcea =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_geg :=_fadc .Encrypt (_bagf .PdfObjectDictionary ,_bbad ,_efe );if _geg !=nil {return _geg ;};_acb ,_geg :=_fadc .makeKey (_bcea ,uint32 (_bbad ),uint32 (_efe ),_fadc ._cgg );if _geg !=nil {return _geg ;};_bagf .Stream ,_geg =_fadc .encryptBytes (_bagf .Stream ,_bcea ,_acb );if _geg !=nil {return _geg ;};_ebd .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_bagf .Stream ))));return nil ;case *PdfObjectString :_cab .Log .Trace ("\u0045n\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_fgga :=_bdcc ;if _fadc ._gead .V >=4{_cab .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_fadc ._dcbe );if _fadc ._dcbe =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_fgga =_fadc ._dcbe ;};_cfe ,_aefb :=_fadc .makeKey (_fgga ,uint32 (parentObjNum ),uint32 (parentGenNum ),_fadc ._cgg );if _aefb !=nil {return _aefb ;};_ddef :=_bagf .Str ();_beca :=make ([]byte ,len (_ddef ));for _faab :=0;_faab < len (_ddef );_faab ++{_beca [_faab ]=_ddef [_faab ];};_cab .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_beca ,_beca );_beca ,_aefb =_fadc .encryptBytes (_beca ,_fgga ,_cfe );if _aefb !=nil {return _aefb ;};_bagf ._gcfee =string (_beca );return nil ;case *PdfObjectArray :for _ ,_cded :=range _bagf .Elements (){_ggb :=_fadc .Encrypt (_cded ,parentObjNum ,parentGenNum );if _ggb !=nil {return _ggb ;};};return nil ;case *PdfObjectDictionary :_fgff :=false ;if _fbaa :=_bagf .Get ("\u0054\u0079\u0070\u0065");_fbaa !=nil {_dfg ,_abed :=_fbaa .(*PdfObjectName );if _abed &&*_dfg =="\u0053\u0069\u0067"{_fgff =true ;};};for _ ,_cgbae :=range _bagf .Keys (){_dfgg :=_bagf .Get (_cgbae );if _fgff &&string (_cgbae )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;};if string (_cgbae )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_cgbae )!="\u0050\u0072\u0065\u0076"&&string (_cgbae )!="\u004c\u0061\u0073\u0074"{_cefag :=_fadc .Encrypt (_dfgg ,parentObjNum ,parentGenNum );if _cefag !=nil {return _cefag ;};};};return nil ;};return nil ;};

// Resolve resolves a PdfObject to direct object, looking up and resolving references as needed (unlike TraceToDirect).
func (_fa *PdfParser )Resolve (obj PdfObject )(PdfObject ,error ){_abc ,_gg :=obj .(*PdfObjectReference );if !_gg {return obj ,nil ;};_gag :=_fa .GetFileOffset ();defer func (){_fa .SetFileOffset (_gag )}();_eec ,_ae :=_fa .LookupByReference (*_abc );if _ae !=nil {return nil ,_ae ;};_gea ,_dda :=_eec .(*PdfIndirectObject );if !_dda {return _eec ,nil ;};_eec =_gea .PdfObject ;_ ,_gg =_eec .(*PdfObjectReference );if _gg {return _gea ,_g .New ("\u006d\u0075lt\u0069\u0020\u0064e\u0070\u0074\u0068\u0020tra\u0063e \u0070\u006f\u0069\u006e\u0074\u0065\u0072 t\u006f\u0020\u0070\u006f\u0069\u006e\u0074e\u0072");};return _eec ,nil ;};

// MakeObjectStreams creates an PdfObjectStreams from a list of PdfObjects.
func MakeObjectStreams (objects ...PdfObject )*PdfObjectStreams {return &PdfObjectStreams {_gccb :objects };};

// DecodeStream decodes the stream data and returns the decoded data.
// An error is returned upon failure.
func DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_cab .Log .Trace ("\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_dbabg ,_cadbb :=NewEncoderFromStream (streamObj );if _cadbb !=nil {_cab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_cadbb );return nil ,_cadbb ;};_cab .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076\u000a",_dbabg );_fecbe ,_cadbb :=_dbabg .DecodeStream (streamObj );if _cadbb !=nil {_cab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_cadbb );return nil ,_cadbb ;};return _fecbe ,nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_geaef *RunLengthEncoder )MakeDecodeParams ()PdfObject {return nil };var _egf =_cc .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064\u002b)\u005c\u0073\u002a\u0024");func _afdca (_ecge PdfObject )(*float64 ,error ){switch _fgdf :=_ecge .(type ){case *PdfObjectFloat :_efdee :=float64 (*_fgdf );return &_efdee ,nil ;case *PdfObjectInteger :_abgdf :=float64 (*_fgdf );return &_abgdf ,nil ;case *PdfObjectNull :return nil ,nil ;};return nil ,ErrNotANumber ;};

// Set sets the PdfObject at index i of the array. An error is returned if the index is outside bounds.
func (_bgef *PdfObjectArray )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_bgef ._gaggf ){return _g .New ("\u006f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_bgef ._gaggf [i ]=obj ;return nil ;};

// MakeNull creates an PdfObjectNull.
func MakeNull ()*PdfObjectNull {_fgdd :=PdfObjectNull {};return &_fgdd };

// DecodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_agad *RawEncoder )DecodeBytes (encoded []byte )([]byte ,error ){return encoded ,nil };type objectCache map[int ]PdfObject ;

// MakeStringFromBytes creates an PdfObjectString from a byte array.
// This is more natural than MakeString as `data` is usually not utf-8 encoded.
func MakeStringFromBytes (data []byte )*PdfObjectString {return MakeString (string (data ))};

// PdfObjectNull represents the primitive PDF null object.
type PdfObjectNull struct{};

// Encode encodes previously prepare jbig2 document and stores it as the byte slice.
func (_edde *JBIG2Encoder )Encode ()(_fgge []byte ,_aacg error ){const _gcfc ="J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0045\u006eco\u0064\u0065";if _edde ._adfd ==nil {return nil ,_eea .Errorf (_gcfc ,"\u0064\u006f\u0063u\u006d\u0065\u006e\u0074 \u0069\u006e\u0070\u0075\u0074\u0020\u0064a\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006e\u0065\u0064");};_edde ._adfd .FullHeaders =_edde .DefaultPageSettings .FileMode ;_fgge ,_aacg =_edde ._adfd .Encode ();if _aacg !=nil {return nil ,_eea .Wrap (_aacg ,_gcfc ,"");};return _fgge ,nil ;};

// SetFileOffset sets the file to an offset position and resets buffer.
func (_dfdc *PdfParser )SetFileOffset (offset int64 ){if offset < 0{offset =0;};_dfdc ._bfca .Seek (offset ,_ge .SeekStart );_dfdc ._afbd =_dg .NewReader (_dfdc ._bfca );};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_bacd *RawEncoder )MakeDecodeParams ()PdfObject {return nil };

// MakeDecodeParams makes a new instance of an encoding dictionary based on the current encoder settings.
func (_ddda *JBIG2Encoder )MakeDecodeParams ()PdfObject {return MakeDict ()};

// DecodeBytes decodes a slice of JPX encoded bytes and returns the result.
func (_cabf *JPXEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_cab .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_cabf .GetFilterName ());return encoded ,ErrNoJPXDecode ;};type cryptFilters map[string ]_de .Filter ;

// NewASCII85Encoder makes a new ASCII85 encoder.
func NewASCII85Encoder ()*ASCII85Encoder {_deca :=&ASCII85Encoder {};return _deca };func (_baad *PdfCrypt )newEncryptDict ()*PdfObjectDictionary {_ebf :=MakeDict ();_ebf .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName ("\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"));_ebf .Set ("\u0056",MakeInteger (int64 (_baad ._gead .V )));_ebf .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_baad ._gead .Length )));return _ebf ;};

// EncodeJBIG2Image encodes 'img' into jbig2 encoded bytes stream, using default encoder settings.
func (_gga *JBIG2Encoder )EncodeJBIG2Image (img *JBIG2Image )([]byte ,error ){const _gecb ="c\u006f\u0072\u0065\u002eEn\u0063o\u0064\u0065\u004a\u0042\u0049G\u0032\u0049\u006d\u0061\u0067\u0065";if _bgffb :=_gga .AddPageImage (img ,&_gga .DefaultPageSettings );_bgffb !=nil {return nil ,_eea .Wrap (_bgffb ,_gecb ,"");};return _gga .Encode ();};func (_dbgf *PdfCrypt )saveCryptFilters (_aaf *PdfObjectDictionary )error {if _dbgf ._gead .V < 4{return _g .New ("\u0063\u0061\u006e\u0020\u006f\u006e\u006c\u0079\u0020\u0062\u0065 \u0075\u0073\u0065\u0064\u0020\u0077\u0069\u0074\u0068\u0020V\u003e\u003d\u0034");};_bfac :=MakeDict ();_aaf .Set ("\u0043\u0046",_bfac );for _abb ,_cca :=range _dbgf ._faa {if _abb =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{continue ;};_defe :=_bda (_cca ,"");_bfac .Set (PdfObjectName (_abb ),_defe );};_aaf .Set ("\u0053\u0074\u0072\u0046",MakeName (_dbgf ._dcbe ));_aaf .Set ("\u0053\u0074\u006d\u0046",MakeName (_dbgf ._degc ));return nil ;};

// GetArray returns the *PdfObjectArray represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetArray (obj PdfObject )(_aaeg *PdfObjectArray ,_gdfb bool ){_aaeg ,_gdfb =TraceToDirectObject (obj ).(*PdfObjectArray );return _aaeg ,_gdfb ;};func _beed (_eggca ,_dacc ,_gegc int )error {if _dacc < 0||_dacc > _eggca {return _g .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0061\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");};if _gegc < _dacc {return _g .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0073\u006c\u0069\u0063e\u0020i\u006ed\u0065\u0078\u0020\u0062\u0020\u003c\u0020a");};if _gegc > _eggca {return _g .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0062\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");};return nil ;};

// LookupByNumber looks up a PdfObject by object number.  Returns an error on failure.
func (_cf *PdfParser )LookupByNumber (objNumber int )(PdfObject ,error ){_cd ,_ ,_ab :=_cf .lookupByNumberWrapper (objNumber ,true );return _cd ,_ab ;};

// DecodeBytes decodes the CCITTFax encoded image data.
func (_bfdc *CCITTFaxEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_bcfe :=&_gf .Encoder {K :_bfdc .K ,Columns :_bfdc .Columns ,EndOfLine :_bfdc .EndOfLine ,EndOfBlock :_bfdc .EndOfBlock ,BlackIs1 :_bfdc .BlackIs1 ,DamagedRowsBeforeError :_bfdc .DamagedRowsBeforeError ,Rows :_bfdc .Rows ,EncodedByteAlign :_bfdc .EncodedByteAlign };_aacb ,_gebe :=_bcfe .Decode (encoded );if _gebe !=nil {return nil ,_gebe ;};var _bgae []byte ;_eddc :=0;var _ggc byte ;var _cfaaa byte ;for _bea :=range _aacb {if _ggc !=0{_bgae =append (_bgae ,_cfaaa );_cfaaa =0;_eddc ++;_ggc =0;};for _decae :=range _aacb [_bea ]{_cfaaa |=_aacb [_bea ][_decae ]<<(7-_ggc );_ggc ++;if _ggc ==8{_bgae =append (_bgae ,_cfaaa );_cfaaa =0;_eddc ++;_ggc =0;};};};if _ggc > 0{_bgae =append (_bgae ,_cfaaa );};return _bgae ,nil ;};

// SetIfNotNil sets the dictionary's key -> val mapping entry -IF- val is not nil.
// Note that we take care to perform a type switch.  Otherwise if we would supply a nil value
// of another type, e.g. (PdfObjectArray*)(nil), then it would not be a PdfObject(nil) and thus
// would get set.
func (_dged *PdfObjectDictionary )SetIfNotNil (key PdfObjectName ,val PdfObject ){if val !=nil {switch _cagb :=val .(type ){case *PdfObjectName :if _cagb !=nil {_dged .Set (key ,val );};case *PdfObjectDictionary :if _cagb !=nil {_dged .Set (key ,val );};case *PdfObjectStream :if _cagb !=nil {_dged .Set (key ,val );};case *PdfObjectString :if _cagb !=nil {_dged .Set (key ,val );};case *PdfObjectNull :if _cagb !=nil {_dged .Set (key ,val );};case *PdfObjectInteger :if _cagb !=nil {_dged .Set (key ,val );};case *PdfObjectArray :if _cagb !=nil {_dged .Set (key ,val );};case *PdfObjectBool :if _cagb !=nil {_dged .Set (key ,val );};case *PdfObjectFloat :if _cagb !=nil {_dged .Set (key ,val );};case *PdfObjectReference :if _cagb !=nil {_dged .Set (key ,val );};case *PdfIndirectObject :if _cagb !=nil {_dged .Set (key ,val );};default:_cab .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",val );};};};

// JBIG2Encoder implements both jbig2 encoder and the decoder. The encoder allows to encode
// provided images (best used document scans) in multiple way. By default it uses single page generic
// encoder. It allows to store lossless data as a single segment.
// In order to store multiple image pages use the 'FileMode' which allows to store more pages within single jbig2 document.
// WIP: In order to obtain better compression results the encoder would allow to encode the input in a
// lossy or lossless way with a component (symbol) mode. It divides the image into components.
// Then checks if any component is 'similar' to the others and maps them together. The symbol classes are stored
// in the dictionary. Then the encoder creates text regions which uses the related symbol classes to fill it's space.
// The similarity is defined by the 'Threshold' variable (default: 0.95). The less the value is, the more components
// matches to single class, thus the compression is better, but the result might become lossy.
type JBIG2Encoder struct{

// These values are required to be set for the 'EncodeBytes' method.
// ColorComponents defines the number of color components for provided image.
ColorComponents int ;

// BitsPerComponent is the number of bits that stores per color component
BitsPerComponent int ;

// Width is the width of the image to encode
Width int ;

// Height is the height of the image to encode.
Height int ;_adfd *_ag .Document ;

// Globals are the JBIG2 global segments.
Globals _ac .Globals ;

// IsChocolateData defines if the data is encoded such that
// binary data '1' means black and '0' white.
// otherwise the data is called vanilla.
// Naming convention taken from: 'https://en.wikipedia.org/wiki/Binary_image#Interpretation'
IsChocolateData bool ;

// DefaultPageSettings are the settings parameters used by the jbig2 encoder.
DefaultPageSettings JBIG2EncoderSettings ;};

// GetStream returns the *PdfObjectStream represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetStream (obj PdfObject )(_gcff *PdfObjectStream ,_gede bool ){obj =ResolveReference (obj );_gcff ,_gede =obj .(*PdfObjectStream );return _gcff ,_gede ;};func (_agf *PdfParser )lookupByNumber (_ffe int ,_fge bool )(PdfObject ,bool ,error ){_egb ,_bfb :=_agf .ObjCache [_ffe ];if _bfb {_cab .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0063a\u0063\u0068\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0025\u0064",_ffe );return _egb ,false ,nil ;};if _agf ._baec ==nil {_agf ._baec =map[int ]bool {};};if _agf ._baec [_ffe ]{_cab .Log .Debug ("ER\u0052\u004f\u0052\u003a\u0020\u004c\u006fok\u0075\u0070\u0020\u006f\u0066\u0020\u0025\u0064\u0020\u0069\u0073\u0020\u0061\u006c\u0072e\u0061\u0064\u0079\u0020\u0069\u006e\u0020\u0070\u0072\u006f\u0067\u0072\u0065\u0073\u0073\u0020\u002d\u0020\u0072\u0065c\u0075\u0072\u0073\u0069\u0076\u0065 \u006c\u006f\u006f\u006b\u0075\u0070\u0020\u0061\u0074t\u0065m\u0070\u0074\u0020\u0062\u006c\u006f\u0063\u006b\u0065\u0064",_ffe );return nil ,false ,_g .New ("\u0072\u0065\u0063\u0075\u0072\u0073\u0069\u0076\u0065\u0020\u006c\u006f\u006f\u006b\u0075p\u0020a\u0074\u0074\u0065\u006d\u0070\u0074\u0020\u0062\u006c\u006f\u0063\u006b\u0065\u0064");};_agf ._baec [_ffe ]=true ;defer delete (_agf ._baec ,_ffe );_fe ,_bfb :=_agf ._adde .ObjectMap [_ffe ];if !_bfb {_cab .Log .Trace ("\u0055\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u006c\u006f\u0063\u0061t\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0069\u006e\u0020\u0078\u0072\u0065\u0066\u0073\u0021 \u002d\u0020\u0052\u0065\u0074u\u0072\u006e\u0069\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074");var _aagd PdfObjectNull ;return &_aagd ,false ,nil ;};_cab .Log .Trace ("L\u006fo\u006b\u0075\u0070\u0020\u006f\u0062\u006a\u0020n\u0075\u006d\u0062\u0065r \u0025\u0064",_ffe );if _fe .XType ==XrefTypeTableEntry {_cab .Log .Trace ("\u0078r\u0065f\u006f\u0062\u006a\u0020\u006fb\u006a\u0020n\u0075\u006d\u0020\u0025\u0064",_fe .ObjectNumber );_cab .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u0067e\u006e\u0020\u0025\u0064",_fe .Generation );_cab .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0064",_fe .Offset );_agf ._bfca .Seek (_fe .Offset ,_ge .SeekStart );_agf ._afbd =_dg .NewReader (_agf ._bfca );_ed ,_gbf :=_agf .ParseIndirectObject ();if _gbf !=nil {_cab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006ce\u0064\u0020\u0072\u0065\u0061\u0064\u0069n\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029",_gbf );if _fge {_cab .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0072\u0065\u0070\u0061\u0069r\u0020\u0078\u0072\u0065\u0066\u0073\u0020\u0028\u0074\u006f\u0070\u0020d\u006f\u0077\u006e\u0029");_gfd ,_ebg :=_agf .repairRebuildXrefsTopDown ();if _ebg !=nil {_cab .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020r\u0065\u0070\u0061\u0069\u0072\u0020\u0028\u0025\u0073\u0029",_ebg );return nil ,false ,_ebg ;};_agf ._adde =*_gfd ;return _agf .lookupByNumber (_ffe ,false );};return nil ,false ,_gbf ;};if _fge {_dcf ,_ ,_ :=_agd (_ed );if int (_dcf )!=_ffe {_cab .Log .Debug ("\u0049n\u0076\u0061\u006c\u0069d\u0020\u0078\u0072\u0065\u0066s\u003a \u0052e\u0062\u0075\u0069\u006c\u0064\u0069\u006eg");_def :=_agf .rebuildXrefTable ();if _def !=nil {return nil ,false ,_def ;};_agf .ObjCache =objectCache {};return _agf .lookupByNumberWrapper (_ffe ,false );};};_cab .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006f\u0062\u006a");_agf .ObjCache [_ffe ]=_ed ;return _ed ,false ,nil ;}else if _fe .XType ==XrefTypeObjectStream {_cab .Log .Trace ("\u0078r\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0021");_cab .Log .Trace ("\u003e\u004c\u006f\u0061\u0064\u0020\u0076\u0069\u0061\u0020\u004f\u0053\u0021");_cab .Log .Trace ("\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d \u0061\u0076\u0061\u0069\u006c\u0061b\u006c\u0065\u0020\u0069\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020%\u0064\u002f\u0025\u0064",_fe .OsObjNumber ,_fe .OsObjIndex );if _fe .OsObjNumber ==_ffe {_cab .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0043i\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065f\u0065\u0072\u0065n\u0063e\u0021\u003f\u0021");return nil ,true ,_g .New ("\u0078\u0072\u0065f \u0063\u0069\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");};if _ ,_ddb :=_agf ._adde .ObjectMap [_fe .OsObjNumber ];_ddb {_bg ,_cfa :=_agf .lookupObjectViaOS (_fe .OsObjNumber ,_ffe );if _cfa !=nil {_cab .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0052\u0065\u0074\u0075\u0072\u006e\u0069n\u0067\u0020\u0045\u0052\u0052\u0020\u0028\u0025\u0073\u0029",_cfa );return nil ,true ,_cfa ;};_cab .Log .Trace ("\u003c\u004c\u006f\u0061\u0064\u0065\u0064\u0020\u0076i\u0061\u0020\u004f\u0053");_agf .ObjCache [_ffe ]=_bg ;if _agf ._ggd !=nil {_agf ._ggd ._fba [_bg ]=true ;};return _bg ,true ,nil ;};_cab .Log .Debug ("\u003f\u003f\u0020\u0042\u0065\u006c\u006f\u006eg\u0073\u0020\u0074o \u0061\u0020\u006e\u006f\u006e\u002dc\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u002e.\u002e\u0021");return nil ,true ,_g .New ("\u006f\u0073\u0020\u0062\u0065\u006c\u006fn\u0067\u0073\u0020t\u006f\u0020\u0061\u0020n\u006f\u006e\u0020\u0063\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074");};return nil ,false ,_g .New ("\u0075\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0078\u0072\u0065\u0066 \u0074\u0079\u0070\u0065");};func _dgff (_beba PdfObject ,_edagb int )PdfObject {if _edagb > _bbba {_cab .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_bbba );return MakeNull ();};switch _fgbe :=_beba .(type ){case *PdfIndirectObject :_beba =_dgff ((*_fgbe ).PdfObject ,_edagb +1);case *PdfObjectArray :for _cdeee ,_efdb :=range (*_fgbe )._gaggf {(*_fgbe )._gaggf [_cdeee ]=_dgff (_efdb ,_edagb +1);};case *PdfObjectDictionary :for _bedf ,_bfceb :=range (*_fgbe )._agcee {(*_fgbe )._agcee [_bedf ]=_dgff (_bfceb ,_edagb +1);};_c .Slice ((*_fgbe )._eafbb ,func (_beaf ,_dbce int )bool {return (*_fgbe )._eafbb [_beaf ]< (*_fgbe )._eafbb [_dbce ]});};return _beba ;};

// PdfObjectName represents the primitive PDF name object.
type PdfObjectName string ;

// PdfObjectArray represents the primitive PDF array object.
type PdfObjectArray struct{_gaggf []PdfObject };

// NewRunLengthEncoder makes a new run length encoder
func NewRunLengthEncoder ()*RunLengthEncoder {return &RunLengthEncoder {}};

// GetCrypter returns the PdfCrypt instance which has information about the PDFs encryption.
func (_addeb *PdfParser )GetCrypter ()*PdfCrypt {return _addeb ._ggd };

// GetStringBytes is like GetStringVal except that it returns the string as a []byte.
// It is for convenience.
func GetStringBytes (obj PdfObject )(_geab []byte ,_fegc bool ){_cefec ,_fegc :=TraceToDirectObject (obj ).(*PdfObjectString );if _fegc {return _cefec .Bytes (),true ;};return ;};

// WriteString outputs the object as it is to be written to file.
func (_ecdf *PdfObjectArray )WriteString ()string {var _fcgc _ee .Builder ;_fcgc .WriteString ("\u005b");for _bdffe ,_aedga :=range _ecdf .Elements (){_fcgc .WriteString (_aedga .WriteString ());if _bdffe < (_ecdf .Len ()-1){_fcgc .WriteString ("\u0020");};};_fcgc .WriteString ("\u005d");return _fcgc .String ();};

// GetNumberAsFloat returns the contents of `obj` as a float if it is an integer or float, or an
// error if it isn't.
func GetNumberAsFloat (obj PdfObject )(float64 ,error ){switch _dfada :=obj .(type ){case *PdfObjectFloat :return float64 (*_dfada ),nil ;case *PdfObjectInteger :return float64 (*_dfada ),nil ;};return 0,ErrNotANumber ;};

// DecodeStream implements ASCII85 stream decoding.
func (_ecg *ASCII85Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _ecg .DecodeBytes (streamObj .Stream );};func (_abcae *PdfParser )seekPdfVersionTopDown ()(int ,int ,error ){_abcae ._bfca .Seek (0,_ge .SeekStart );_abcae ._afbd =_dg .NewReader (_abcae ._bfca );_fcgce :=20;_cdbee :=make ([]byte ,_fcgce );for {_fdee ,_dgfc :=_abcae ._afbd .ReadByte ();if _dgfc !=nil {if _dgfc ==_ge .EOF {break ;}else {return 0,0,_dgfc ;};};if IsDecimalDigit (_fdee )&&_cdbee [_fcgce -1]=='.'&&IsDecimalDigit (_cdbee [_fcgce -2])&&_cdbee [_fcgce -3]=='-'&&_cdbee [_fcgce -4]=='F'&&_cdbee [_fcgce -5]=='D'&&_cdbee [_fcgce -6]=='P'{_bddd :=int (_cdbee [_fcgce -2]-'0');_adcd :=int (_fdee -'0');return _bddd ,_adcd ,nil ;};_cdbee =append (_cdbee [1:_fcgce ],_fdee );};return 0,0,_g .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};

// DecodeStream decodes a JBIG2 encoded stream and returns the result as a slice of bytes.
func (_badg *JBIG2Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _badg .DecodeBytes (streamObj .Stream );};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_eeea *CCITTFaxEncoder )MakeStreamDict ()*PdfObjectDictionary {_ceae :=MakeDict ();_ceae .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_eeea .GetFilterName ()));_dgbg :=_eeea .MakeDecodeParams ();if _dgbg !=nil {_ceae .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_dgbg );};return _ceae ;};

// MakeStreamDict make a new instance of an encoding dictionary for a stream object.
func (_ebfgg *ASCII85Encoder )MakeStreamDict ()*PdfObjectDictionary {_bcde :=MakeDict ();_bcde .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_ebfgg .GetFilterName ()));return _bcde ;};func (_aedc *PdfParser )readTextLine ()(string ,error ){var _bcdb _ced .Buffer ;for {_eddf ,_ddcag :=_aedc ._afbd .Peek (1);if _ddcag !=nil {_cab .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_ddcag .Error ());return _bcdb .String (),_ddcag ;};if (_eddf [0]!='\r')&&(_eddf [0]!='\n'){_gcef ,_ :=_aedc ._afbd .ReadByte ();_bcdb .WriteByte (_gcef );}else {break ;};};return _bcdb .String (),nil ;};func (_dcee *PdfParser )seekToEOFMarker (_gcce int64 )error {var _eabe int64 ;var _bdcg int64 =2048;for _eabe < _gcce -4{if _gcce <=(_bdcg +_eabe ){_bdcg =_gcce -_eabe ;};_ ,_abcf :=_dcee ._bfca .Seek (-_eabe -_bdcg ,_ge .SeekEnd );if _abcf !=nil {return _abcf ;};_acbdc :=make ([]byte ,_bdcg );_dcee ._bfca .Read (_acbdc );_cab .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0045\u004f\u0046 \u006da\u0072\u006b\u0065\u0072\u003a\u0020\u0022%\u0073\u0022",string (_acbdc ));_dbbf :=_cecg .FindAllStringIndex (string (_acbdc ),-1);if _dbbf !=nil {_egfd :=_dbbf [len (_dbbf )-1];_cab .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_dbbf );_dcee ._bfca .Seek (-_eabe -_bdcg +int64 (_egfd [0]),_ge .SeekEnd );return nil ;};_cab .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");_eabe +=_bdcg -4;};_cab .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006be\u0072 \u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u002e");return _g .New ("\u0045\u004f\u0046\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};

// String returns a string representation of the *PdfObjectString.
func (_ffde *PdfObjectString )String ()string {return _ffde ._gcfee };

// IsDecimalDigit checks if the character is a part of a decimal number string.
func IsDecimalDigit (c byte )bool {return '0'<=c &&c <='9'};

// NewEncoderFromStream creates a StreamEncoder based on the stream's dictionary.
func NewEncoderFromStream (streamObj *PdfObjectStream )(StreamEncoder ,error ){_bbecc :=TraceToDirectObject (streamObj .PdfObjectDictionary .Get ("\u0046\u0069\u006c\u0074\u0065\u0072"));if _bbecc ==nil {return NewRawEncoder (),nil ;};if _ ,_febd :=_bbecc .(*PdfObjectNull );_febd {return NewRawEncoder (),nil ;};_aab ,_gdda :=_bbecc .(*PdfObjectName );if !_gdda {_bgdcb ,_eedgg :=_bbecc .(*PdfObjectArray );if !_eedgg {return nil ,_ce .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006f\u0072 \u0041\u0072\u0072\u0061\u0079\u0020\u006fb\u006a\u0065\u0063\u0074");};if _bgdcb .Len ()==0{return NewRawEncoder (),nil ;};if _bgdcb .Len ()!=1{_aaadc ,_abde :=_acgd (streamObj );if _abde !=nil {_cab .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0063\u0072\u0065\u0061\u0074\u0069\u006e\u0067\u0020\u006d\u0075\u006c\u0074i\u0020\u0065\u006e\u0063\u006f\u0064\u0065r\u003a\u0020\u0025\u0076",_abde );return nil ,_abde ;};_cab .Log .Trace ("\u004d\u0075\u006c\u0074\u0069\u0020\u0065\u006e\u0063:\u0020\u0025\u0073\u000a",_aaadc );return _aaadc ,nil ;};_bbecc =_bgdcb .Get (0);_aab ,_eedgg =_bbecc .(*PdfObjectName );if !_eedgg {return nil ,_ce .Errorf ("\u0066\u0069l\u0074\u0065\u0072\u0020a\u0072\u0072a\u0079\u0020\u006d\u0065\u006d\u0062\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006fb\u006a\u0065\u0063\u0074");};};switch *_aab {case StreamEncodingFilterNameFlate :return _ccgc (streamObj ,nil );case StreamEncodingFilterNameLZW :return _gaef (streamObj ,nil );case StreamEncodingFilterNameDCT :return _cad (streamObj ,nil );case StreamEncodingFilterNameRunLength :return _cfcd (streamObj ,nil );case StreamEncodingFilterNameASCIIHex :return NewASCIIHexEncoder (),nil ;case StreamEncodingFilterNameASCII85 ,"\u0041\u0038\u0035":return NewASCII85Encoder (),nil ;case StreamEncodingFilterNameCCITTFax :return _aaad (streamObj ,nil );case StreamEncodingFilterNameJBIG2 :return _aeca (streamObj ,nil );case StreamEncodingFilterNameJPX :return NewJPXEncoder (),nil ;};_cab .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064\u0069\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006fd\u0021");return nil ,_ce .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064i\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006f\u0064\u0020\u0028\u0025\u0073\u0029",*_aab );};func (_bccf *PdfParser )repairRebuildXrefsTopDown ()(*XrefTable ,error ){if _bccf ._dcbc {return nil ,_ce .Errorf ("\u0072\u0065\u0070\u0061\u0069\u0072\u0020\u0066\u0061\u0069\u006c\u0065\u0064");};_bccf ._dcbc =true ;_bccf ._bfca .Seek (0,_ge .SeekStart );_bccf ._afbd =_dg .NewReader (_bccf ._bfca );_bfcfa :=20;_aeegd :=make ([]byte ,_bfcfa );_bfgg :=XrefTable {};_bfgg .ObjectMap =make (map[int ]XrefObject );for {_fcbbd ,_dcfb :=_bccf ._afbd .ReadByte ();if _dcfb !=nil {if _dcfb ==_ge .EOF {break ;}else {return nil ,_dcfb ;};};if _fcbbd =='j'&&_aeegd [_bfcfa -1]=='b'&&_aeegd [_bfcfa -2]=='o'&&IsWhiteSpace (_aeegd [_bfcfa -3]){_cfcc :=_bfcfa -4;for IsWhiteSpace (_aeegd [_cfcc ])&&_cfcc > 0{_cfcc --;};if _cfcc ==0||!IsDecimalDigit (_aeegd [_cfcc ]){continue ;};for IsDecimalDigit (_aeegd [_cfcc ])&&_cfcc > 0{_cfcc --;};if _cfcc ==0||!IsWhiteSpace (_aeegd [_cfcc ]){continue ;};for IsWhiteSpace (_aeegd [_cfcc ])&&_cfcc > 0{_cfcc --;};if _cfcc ==0||!IsDecimalDigit (_aeegd [_cfcc ]){continue ;};for IsDecimalDigit (_aeegd [_cfcc ])&&_cfcc > 0{_cfcc --;};if _cfcc ==0{continue ;};_babf :=_bccf .GetFileOffset ()-int64 (_bfcfa -_cfcc );_gfcd :=append (_aeegd [_cfcc +1:],_fcbbd );_fbgc ,_ffegb ,_fcfbe :=_fefa (string (_gfcd ));if _fcfbe !=nil {_cab .Log .Debug ("\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u006e\u0075\u006d\u0062\u0065r\u003a\u0020\u0025\u0076",_fcfbe );return nil ,_fcfbe ;};if _cced ,_dadd :=_bfgg .ObjectMap [_fbgc ];!_dadd ||_cced .Generation < _ffegb {_gfcdg :=XrefObject {};_gfcdg .XType =XrefTypeTableEntry ;_gfcdg .ObjectNumber =_fbgc ;_gfcdg .Generation =_ffegb ;_gfcdg .Offset =_babf ;_bfgg .ObjectMap [_fbgc ]=_gfcdg ;};};_aeegd =append (_aeegd [1:_bfcfa ],_fcbbd );};_bccf ._baec =nil ;return &_bfgg ,nil ;};

// WriteString outputs the object as it is to be written to file.
func (_cadbe *PdfObjectName )WriteString ()string {var _aedf _ced .Buffer ;if len (*_cadbe )> 127{_cab .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u004e\u0061\u006d\u0065\u0020t\u006fo\u0020l\u006f\u006e\u0067\u0020\u0028\u0025\u0073)",*_cadbe );};_aedf .WriteString ("\u002f");for _eabfb :=0;_eabfb < len (*_cadbe );_eabfb ++{_fcea :=(*_cadbe )[_eabfb ];if !IsPrintable (_fcea )||_fcea =='#'||IsDelimiter (_fcea ){_aedf .WriteString (_ce .Sprintf ("\u0023\u0025\u002e2\u0078",_fcea ));}else {_aedf .WriteByte (_fcea );};};return _aedf .String ();};

// DecodeStream decodes the stream containing CCITTFax encoded image data.
func (_fbfb *CCITTFaxEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _fbfb .DecodeBytes (streamObj .Stream );};

// GetFilterName returns the name of the encoding filter.
func (_efee *LZWEncoder )GetFilterName ()string {return StreamEncodingFilterNameLZW };const (StreamEncodingFilterNameFlate ="F\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameLZW ="\u004cZ\u0057\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameDCT ="\u0044C\u0054\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameRunLength ="\u0052u\u006eL\u0065\u006e\u0067\u0074\u0068\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameASCIIHex ="\u0041\u0053\u0043\u0049\u0049\u0048\u0065\u0078\u0044e\u0063\u006f\u0064\u0065";StreamEncodingFilterNameASCII85 ="\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameCCITTFax ="\u0043\u0043\u0049\u0054\u0054\u0046\u0061\u0078\u0044e\u0063\u006f\u0064\u0065";StreamEncodingFilterNameJBIG2 ="J\u0042\u0049\u0047\u0032\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameJPX ="\u004aP\u0058\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameRaw ="\u0052\u0061\u0077";);

// PdfObject is an interface which all primitive PDF objects must implement.
type PdfObject interface{

// String outputs a string representation of the primitive (for debugging).
String ()string ;

// WriteString outputs the PDF primitive as written to file as expected by the standard.
// TODO(dennwc): it should return a byte slice, or accept a writer
WriteString ()string ;};

// GetString is a helper for Get that returns a string value.
// Returns false if the key is missing or a value is not a string.
func (_dbcb *PdfObjectDictionary )GetString (key PdfObjectName )(string ,bool ){_cfad ,_dcbd :=_dbcb ._agcee [key ].(*PdfObjectString );if !_dcbd {return "",false ;};return _cfad .Str (),true ;};func (_afda *PdfParser )readComment ()(string ,error ){var _bdabg _ced .Buffer ;_ ,_cebg :=_afda .skipSpaces ();if _cebg !=nil {return _bdabg .String (),_cebg ;};_cgcc :=true ;for {_eega ,_ccega :=_afda ._afbd .Peek (1);if _ccega !=nil {_cab .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_ccega .Error ());return _bdabg .String (),_ccega ;};if _cgcc &&_eega [0]!='%'{return _bdabg .String (),_g .New ("c\u006f\u006d\u006d\u0065\u006e\u0074 \u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0073\u0074a\u0072\u0074\u0020w\u0069t\u0068\u0020\u0025");};_cgcc =false ;if (_eega [0]!='\r')&&(_eega [0]!='\n'){_eeefe ,_ :=_afda ._afbd .ReadByte ();_bdabg .WriteByte (_eeefe );}else {break ;};};return _bdabg .String (),nil ;};

// GetFileOffset returns the current file offset, accounting for buffered position.
func (_fgd *PdfParser )GetFileOffset ()int64 {_bdfa ,_ :=_fgd ._bfca .Seek (0,_ge .SeekCurrent );_bdfa -=int64 (_fgd ._afbd .Buffered ());return _bdfa ;};func _cad (_egc *PdfObjectStream ,_gbfdg *MultiEncoder )(*DCTEncoder ,error ){_ggbf :=NewDCTEncoder ();_gdeg :=_egc .PdfObjectDictionary ;if _gdeg ==nil {return _ggbf ,nil ;};_ded :=_egc .Stream ;if _gbfdg !=nil {_bbec ,_cfbc :=_gbfdg .DecodeBytes (_ded );if _cfbc !=nil {return nil ,_cfbc ;};_ded =_bbec ;};_abdca :=_ced .NewReader (_ded );_dfe ,_afgeb :=_gc .DecodeConfig (_abdca );if _afgeb !=nil {_cab .Log .Debug ("\u0045\u0072\u0072or\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0065\u003a\u0020\u0025\u0073",_afgeb );return nil ,_afgeb ;};switch _dfe .ColorModel {case _ca .RGBAModel :_ggbf .BitsPerComponent =8;_ggbf .ColorComponents =3;case _ca .RGBA64Model :_ggbf .BitsPerComponent =16;_ggbf .ColorComponents =3;case _ca .GrayModel :_ggbf .BitsPerComponent =8;_ggbf .ColorComponents =1;case _ca .Gray16Model :_ggbf .BitsPerComponent =16;_ggbf .ColorComponents =1;case _ca .CMYKModel :_ggbf .BitsPerComponent =8;_ggbf .ColorComponents =4;case _ca .YCbCrModel :_ggbf .BitsPerComponent =8;_ggbf .ColorComponents =3;default:return nil ,_g .New ("\u0075\u006e\u0073up\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u006d\u006f\u0064\u0065\u006c");};_ggbf .Width =_dfe .Width ;_ggbf .Height =_dfe .Height ;_cab .Log .Trace ("\u0044\u0043T\u0020\u0045\u006ec\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076",_ggbf );_ggbf .Quality =DefaultJPEGQuality ;return _ggbf ,nil ;};

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_dbe *FlateEncoder )EncodeBytes (data []byte )([]byte ,error ){if _dbe .Predictor !=1&&_dbe .Predictor !=11{_cab .Log .Debug ("E\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0046\u006c\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065r\u0020P\u0072\u0065\u0064\u0069c\u0074\u006fr\u0020\u003d\u0020\u0031\u002c\u0020\u0031\u0031\u0020\u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");return nil ,ErrUnsupportedEncodingParameters ;};if _dbe .Predictor ==11{_eaf :=_dbe .Columns ;_cccb :=len (data )/_eaf ;if len (data )%_eaf !=0{_cab .Log .Error ("\u0049n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");return nil ,_g .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");};_bgba :=_ced .NewBuffer (nil );_egd :=make ([]byte ,_eaf );for _aeb :=0;_aeb < _cccb ;_aeb ++{_dcba :=data [_eaf *_aeb :_eaf *(_aeb +1)];_egd [0]=_dcba [0];for _bedc :=1;_bedc < _eaf ;_bedc ++{_egd [_bedc ]=byte (int (_dcba [_bedc ]-_dcba [_bedc -1])%256);};_bgba .WriteByte (1);_bgba .Write (_egd );};data =_bgba .Bytes ();};var _gedb _ced .Buffer ;_cgbg :=_d .NewWriter (&_gedb );_cgbg .Write (data );_cgbg .Close ();return _gedb .Bytes (),nil ;};type offsetReader struct{_edgc _ge .ReadSeeker ;_gcedg int64 ;};

// CCITTFaxEncoder implements Group3 and Group4 facsimile (fax) encoder/decoder.
type CCITTFaxEncoder struct{K int ;EndOfLine bool ;EncodedByteAlign bool ;Columns int ;Rows int ;EndOfBlock bool ;BlackIs1 bool ;DamagedRowsBeforeError int ;};

// GetIndirect returns the *PdfIndirectObject represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetIndirect (obj PdfObject )(_cfcf *PdfIndirectObject ,_cgfa bool ){obj =ResolveReference (obj );_cfcf ,_cgfa =obj .(*PdfIndirectObject );return _cfcf ,_cgfa ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_fee *ASCII85Encoder )MakeDecodeParams ()PdfObject {return nil };

// FlateEncoder represents Flate encoding.
type FlateEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Rows int ;Colors int ;_fbde *_cedb .ImageBase ;};func (_dcg *PdfCrypt )loadCryptFilters (_dae *PdfObjectDictionary )error {_dcg ._faa =cryptFilters {};_afg :=_dae .Get ("\u0043\u0046");_afg =TraceToDirectObject (_afg );if _eada ,_dbf :=_afg .(*PdfObjectReference );_dbf {_bbf ,_fag :=_dcg ._cbe .LookupByReference (*_eada );if _fag !=nil {_cab .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0075\u0070\u0020\u0043\u0046\u0020\u0072\u0065\u0066\u0065\u0072en\u0063\u0065");return _fag ;};_afg =TraceToDirectObject (_bbf );};_gfc ,_gbb :=_afg .(*PdfObjectDictionary );if !_gbb {_cab .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0043\u0046\u002c \u0074\u0079\u0070\u0065: \u0025\u0054",_afg );return _g .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0043\u0046");};for _ ,_fc :=range _gfc .Keys (){_cdd :=_gfc .Get (_fc );if _adb ,_gadc :=_cdd .(*PdfObjectReference );_gadc {_cde ,_dde :=_dcg ._cbe .LookupByReference (*_adb );if _dde !=nil {_cab .Log .Debug ("\u0045\u0072ro\u0072\u0020\u006co\u006f\u006b\u0075\u0070 up\u0020di\u0063\u0074\u0069\u006f\u006e\u0061\u0072y \u0072\u0065\u0066\u0065\u0072\u0065\u006ec\u0065");return _dde ;};_cdd =TraceToDirectObject (_cde );};_bccc ,_dac :=_cdd .(*PdfObjectDictionary );if !_dac {return _ce .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074\u0020\u0069\u006e \u0043\u0046\u0020\u0028\u006e\u0061\u006d\u0065\u0020\u0025\u0073\u0029\u0020-\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079\u0020\u0062\u0075\u0074\u0020\u0025\u0054",_fc ,_cdd );};if _fc =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{_cab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u002d\u0020\u0043\u0061\u006e\u006e\u006f\u0074\u0020\u006f\u0076\u0065\u0072\u0077r\u0069\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0069d\u0065\u006e\u0074\u0069\u0074\u0079\u0020\u0066\u0069\u006c\u0074\u0065\u0072 \u002d\u0020\u0054\u0072\u0079\u0069n\u0067\u0020\u006ee\u0078\u0074");continue ;};var _edb _de .FilterDict ;if _dcbb :=_fea (&_edb ,_bccc );_dcbb !=nil {return _dcbb ;};_dff ,_dea :=_de .NewFilter (_edb );if _dea !=nil {return _dea ;};_dcg ._faa [string (_fc )]=_dff ;};_dcg ._faa ["\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"]=_de .NewIdentity ();_dcg ._dcbe ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _cceg ,_fcg :=_dae .Get ("\u0053\u0074\u0072\u0046").(*PdfObjectName );_fcg {if _ ,_daeg :=_dcg ._faa [string (*_cceg )];!_daeg {return _ce .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u0072\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_cceg );};_dcg ._dcbe =string (*_cceg );};_dcg ._degc ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _agb ,_efg :=_dae .Get ("\u0053\u0074\u006d\u0046").(*PdfObjectName );_efg {if _ ,_ccg :=_dcg ._faa [string (*_agb )];!_ccg {return _ce .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u006d\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_agb );};_dcg ._degc =string (*_agb );};return nil ;};func _acgd (_gbd *PdfObjectStream )(*MultiEncoder ,error ){_bfc :=NewMultiEncoder ();_aaaaa :=_gbd .PdfObjectDictionary ;if _aaaaa ==nil {return _bfc ,nil ;};var _fbgf *PdfObjectDictionary ;var _aebf []PdfObject ;_bdffb :=_aaaaa .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _bdffb !=nil {_abbb ,_abg :=_bdffb .(*PdfObjectDictionary );if _abg {_fbgf =_abbb ;};_faac ,_eecb :=_bdffb .(*PdfObjectArray );if _eecb {for _ ,_ecgc :=range _faac .Elements (){_ecgc =TraceToDirectObject (_ecgc );if _egac ,_fbfee :=_ecgc .(*PdfObjectDictionary );_fbfee {_aebf =append (_aebf ,_egac );}else {_aebf =append (_aebf ,MakeDict ());};};};};_bdffb =_aaaaa .Get ("\u0046\u0069\u006c\u0074\u0065\u0072");if _bdffb ==nil {return nil ,_ce .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u006d\u0069s\u0073\u0069\u006e\u0067");};_dbff ,_egcf :=_bdffb .(*PdfObjectArray );if !_egcf {return nil ,_ce .Errorf ("m\u0075\u006c\u0074\u0069\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0063\u0061\u006e\u0020\u006f\u006el\u0079\u0020\u0062\u0065\u0020\u006d\u0061\u0064\u0065\u0020fr\u006f\u006d\u0020a\u0072r\u0061\u0079");};for _aaed ,_bdfc :=range _dbff .Elements (){_efce ,_egab :=_bdfc .(*PdfObjectName );if !_egab {return nil ,_ce .Errorf ("\u006d\u0075l\u0074\u0069\u0020\u0066i\u006c\u0074e\u0072\u0020\u0061\u0072\u0072\u0061\u0079\u0020e\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u006e\u006f\u0074\u0020\u0061 \u006e\u0061\u006d\u0065");};var _gedd PdfObject ;if _fbgf !=nil {_gedd =_fbgf ;}else {if len (_aebf )> 0{if _aaed >=len (_aebf ){return nil ,_ce .Errorf ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0073\u0020\u0069\u006e\u0020d\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006d\u0073\u0020a\u0072\u0072\u0061\u0079");};_gedd =_aebf [_aaed ];};};var _eaa *PdfObjectDictionary ;if _bgda ,_beae :=_gedd .(*PdfObjectDictionary );_beae {_eaa =_bgda ;};_cab .Log .Trace ("\u004e\u0065\u0078t \u006e\u0061\u006d\u0065\u003a\u0020\u0025\u0073\u002c \u0064p\u003a \u0025v\u002c\u0020\u0064\u0050\u0061\u0072\u0061\u006d\u0073\u003a\u0020\u0025\u0076",*_efce ,_gedd ,_eaa );if *_efce ==StreamEncodingFilterNameFlate {_bdbe ,_bdae :=_ccgc (_gbd ,_eaa );if _bdae !=nil {return nil ,_bdae ;};_bfc .AddEncoder (_bdbe );}else if *_efce ==StreamEncodingFilterNameLZW {_edfg ,_gdc :=_gaef (_gbd ,_eaa );if _gdc !=nil {return nil ,_gdc ;};_bfc .AddEncoder (_edfg );}else if *_efce ==StreamEncodingFilterNameASCIIHex {_gada :=NewASCIIHexEncoder ();_bfc .AddEncoder (_gada );}else if *_efce ==StreamEncodingFilterNameASCII85 {_ccbf :=NewASCII85Encoder ();_bfc .AddEncoder (_ccbf );}else if *_efce ==StreamEncodingFilterNameDCT {_ddeef ,_cfee :=_cad (_gbd ,_bfc );if _cfee !=nil {return nil ,_cfee ;};_bfc .AddEncoder (_ddeef );_cab .Log .Trace ("A\u0064d\u0065\u0064\u0020\u0044\u0043\u0054\u0020\u0065n\u0063\u006f\u0064\u0065r.\u002e\u002e");_cab .Log .Trace ("\u004du\u006ct\u0069\u0020\u0065\u006e\u0063o\u0064\u0065r\u003a\u0020\u0025\u0023\u0076",_bfc );}else {_cab .Log .Error ("U\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0066\u0069l\u0074\u0065\u0072\u0020\u0025\u0073",*_efce );return nil ,_ce .Errorf ("\u0069\u006eva\u006c\u0069\u0064 \u0066\u0069\u006c\u0074er \u0069n \u006d\u0075\u006c\u0074\u0069\u0020\u0066il\u0074\u0065\u0072\u0020\u0061\u0072\u0072a\u0079");};};return _bfc ,nil ;};

// GetObjectNums returns a sorted list of object numbers of the PDF objects in the file.
func (_gccbe *PdfParser )GetObjectNums ()[]int {var _edga []int ;for _ ,_gcde :=range _gccbe ._adde .ObjectMap {_edga =append (_edga ,_gcde .ObjectNumber );};_c .Ints (_edga );return _edga ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_acff *JBIG2Encoder )MakeStreamDict ()*PdfObjectDictionary {_faga :=MakeDict ();_faga .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_acff .GetFilterName ()));return _faga ;};

// MakeArrayFromFloats creates an PdfObjectArray from a slice of float64s, where each array element is an
// PdfObjectFloat.
func MakeArrayFromFloats (vals []float64 )*PdfObjectArray {_dfbd :=MakeArray ();for _ ,_dgcd :=range vals {_dfbd .Append (MakeFloat (_dgcd ));};return _dfbd ;};

// Decrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_bdfb *PdfCrypt )Decrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _bdfb .isDecrypted (obj ){return nil ;};switch _fde :=obj .(type ){case *PdfIndirectObject :_bdfb ._fba [_fde ]=true ;_cab .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_fde .ObjectNumber ,_fde .GenerationNumber );_aaa :=_fde .ObjectNumber ;_gfga :=_fde .GenerationNumber ;_fffc :=_bdfb .Decrypt (_fde .PdfObject ,_aaa ,_gfga );if _fffc !=nil {return _fffc ;};return nil ;case *PdfObjectStream :_bdfb ._fba [_fde ]=true ;_ged :=_fde .PdfObjectDictionary ;if _bdfb ._gfa .R !=5{if _cgf ,_ffc :=_ged .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_ffc &&*_cgf =="\u0058\u0052\u0065\u0066"{return nil ;};};_degb :=_fde .ObjectNumber ;_ecf :=_fde .GenerationNumber ;_cab .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_degb ,_ecf );_dbfa :=_bdcc ;if _bdfb ._gead .V >=4{_dbfa =_bdfb ._degc ;_cab .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_bdfb ._degc );if _bffc ,_abeg :=_ged .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );_abeg {if _bcec ,_ecfb :=GetName (_bffc .Get (0));_ecfb {if *_bcec =="\u0043\u0072\u0079p\u0074"{_dbfa ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _fbg ,_dfa :=_ged .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );_dfa {if _ddc ,_bgbd :=_fbg .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_bgbd {if _ ,_bagb :=_bdfb ._faa [string (*_ddc )];_bagb {_cab .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_ddc );_dbfa =string (*_ddc );};};};};};};_cab .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_dbfa );if _dbfa =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_afd :=_bdfb .Decrypt (_ged ,_degb ,_ecf );if _afd !=nil {return _afd ;};_ebfg ,_afd :=_bdfb .makeKey (_dbfa ,uint32 (_degb ),uint32 (_ecf ),_bdfb ._cgg );if _afd !=nil {return _afd ;};_fde .Stream ,_afd =_bdfb .decryptBytes (_fde .Stream ,_dbfa ,_ebfg );if _afd !=nil {return _afd ;};_ged .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_fde .Stream ))));return nil ;case *PdfObjectString :_cab .Log .Trace ("\u0044e\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_cdbg :=_bdcc ;if _bdfb ._gead .V >=4{_cab .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_bdfb ._dcbe );if _bdfb ._dcbe =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_cdbg =_bdfb ._dcbe ;};_caea ,_gbg :=_bdfb .makeKey (_cdbg ,uint32 (parentObjNum ),uint32 (parentGenNum ),_bdfb ._cgg );if _gbg !=nil {return _gbg ;};_fad :=_fde .Str ();_cfaf :=make ([]byte ,len (_fad ));for _bebg :=0;_bebg < len (_fad );_bebg ++{_cfaf [_bebg ]=_fad [_bebg ];};_cab .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_cfaf ,_cfaf );_cfaf ,_gbg =_bdfb .decryptBytes (_cfaf ,_cdbg ,_caea );if _gbg !=nil {return _gbg ;};_fde ._gcfee =string (_cfaf );return nil ;case *PdfObjectArray :for _ ,_acf :=range _fde .Elements (){_ega :=_bdfb .Decrypt (_acf ,parentObjNum ,parentGenNum );if _ega !=nil {return _ega ;};};return nil ;case *PdfObjectDictionary :_fcc :=false ;if _geae :=_fde .Get ("\u0054\u0079\u0070\u0065");_geae !=nil {_ffg ,_bdb :=_geae .(*PdfObjectName );if _bdb &&*_ffg =="\u0053\u0069\u0067"{_fcc =true ;};};for _ ,_aec :=range _fde .Keys (){_efa :=_fde .Get (_aec );if _fcc &&string (_aec )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;};if string (_aec )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_aec )!="\u0050\u0072\u0065\u0076"&&string (_aec )!="\u004c\u0061\u0073\u0074"{_gab :=_bdfb .Decrypt (_efa ,parentObjNum ,parentGenNum );if _gab !=nil {return _gab ;};};};return nil ;};return nil ;};

// NewFlateEncoder makes a new flate encoder with default parameters, predictor 1 and bits per component 8.
func NewFlateEncoder ()*FlateEncoder {_adbe :=&FlateEncoder {};_adbe .Predictor =1;_adbe .BitsPerComponent =8;_adbe .Colors =1;_adbe .Columns =1;return _adbe ;};

// DecodeBytes decodes byte array with ASCII85. 5 ASCII characters -> 4 raw binary bytes
func (_cedce *ASCII85Encoder )DecodeBytes (encoded []byte )([]byte ,error ){var _acbf []byte ;_cab .Log .Trace ("\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0020\u0044e\u0063\u006f\u0064\u0065");_fgee :=0;_bdccg :=false ;for _fgee < len (encoded )&&!_bdccg {_aced :=[5]byte {0,0,0,0,0};_edaf :=0;_eeeg :=0;_bgdd :=4;for _eeeg < 5+_edaf {if _fgee +_eeeg ==len (encoded ){break ;};_bdfe :=encoded [_fgee +_eeeg ];if IsWhiteSpace (_bdfe ){_edaf ++;_eeeg ++;continue ;}else if _bdfe =='~'&&_fgee +_eeeg +1< len (encoded )&&encoded [_fgee +_eeeg +1]=='>'{_bgdd =(_eeeg -_edaf )-1;if _bgdd < 0{_bgdd =0;};_bdccg =true ;break ;}else if _bdfe >='!'&&_bdfe <='u'{_bdfe -='!';}else if _bdfe =='z'&&_eeeg -_edaf ==0{_bgdd =4;_eeeg ++;break ;}else {_cab .Log .Error ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u002c\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020co\u0064\u0065");return nil ,_g .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0063\u006f\u0064\u0065\u0020e\u006e\u0063\u006f\u0075\u006e\u0074\u0065\u0072\u0065\u0064");};_aced [_eeeg -_edaf ]=_bdfe ;_eeeg ++;};_fgee +=_eeeg ;for _bfea :=_bgdd +1;_bfea < 5;_bfea ++{_aced [_bfea ]=84;};_aedg :=uint32 (_aced [0])*85*85*85*85+uint32 (_aced [1])*85*85*85+uint32 (_aced [2])*85*85+uint32 (_aced [3])*85+uint32 (_aced [4]);_fbbf :=[]byte {byte ((_aedg >>24)&0xff),byte ((_aedg >>16)&0xff),byte ((_aedg >>8)&0xff),byte (_aedg &0xff)};_acbf =append (_acbf ,_fbbf [:_bgdd ]...);};_cab .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0065\u006e\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",encoded );_cab .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0064\u0065\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",_acbf );return _acbf ,nil ;};func _edcba ()string {return _cab .Version };

// GetStringVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetStringVal (obj PdfObject )(_gafc string ,_cead bool ){_daad ,_cead :=TraceToDirectObject (obj ).(*PdfObjectString );if _cead {return _daad .Str (),true ;};return ;};

// MakeDict creates and returns an empty PdfObjectDictionary.
func MakeDict ()*PdfObjectDictionary {_begf :=&PdfObjectDictionary {};_begf ._agcee =map[PdfObjectName ]PdfObject {};_begf ._eafbb =[]PdfObjectName {};return _begf ;};

// EncodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_badc *RawEncoder )EncodeBytes (data []byte )([]byte ,error ){return data ,nil };

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_gabbg *RawEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};

// GetFilterName returns the name of the encoding filter.
func (_ggbg *FlateEncoder )GetFilterName ()string {return StreamEncodingFilterNameFlate };

// GetIntVal returns the int value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetIntVal (obj PdfObject )(_cfacf int ,_dcac bool ){_abedd ,_dcac :=TraceToDirectObject (obj ).(*PdfObjectInteger );if _dcac &&_abedd !=nil {return int (*_abedd ),true ;};return 0,false ;};

// JBIG2CompressionType defines the enum compression type used by the JBIG2Encoder.
type JBIG2CompressionType int ;

// String returns a string describing `streams`.
func (_feda *PdfObjectStreams )String ()string {return _ce .Sprintf ("\u004f\u0062j\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0025\u0064",_feda .ObjectNumber );};func _agcd (_cgfad *PdfObjectDictionary )(_bdaac *_cedb .ImageBase ){var (_dbfdeb *PdfObjectInteger ;_fbbb bool ;);if _dbfdeb ,_fbbb =_cgfad .Get ("\u0057\u0069\u0064t\u0068").(*PdfObjectInteger );_fbbb {_bdaac =&_cedb .ImageBase {Width :int (*_dbfdeb )};}else {return nil ;};if _dbfdeb ,_fbbb =_cgfad .Get ("\u0048\u0065\u0069\u0067\u0068\u0074").(*PdfObjectInteger );_fbbb {_bdaac .Height =int (*_dbfdeb );};if _dbfdeb ,_fbbb =_cgfad .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074").(*PdfObjectInteger );_fbbb {_bdaac .BitsPerComponent =int (*_dbfdeb );};if _dbfdeb ,_fbbb =_cgfad .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073").(*PdfObjectInteger );_fbbb {_bdaac .ColorComponents =int (*_dbfdeb );};return _bdaac ;};func (_fdd *PdfParser )parseHexString ()(*PdfObjectString ,error ){_fdd ._afbd .ReadByte ();var _aaee _ced .Buffer ;for {_fbee ,_bcbf :=_fdd ._afbd .Peek (1);if _bcbf !=nil {return MakeString (""),_bcbf ;};if _fbee [0]=='>'{_fdd ._afbd .ReadByte ();break ;};_bcgf ,_ :=_fdd ._afbd .ReadByte ();if !IsWhiteSpace (_bcgf ){_aaee .WriteByte (_bcgf );};};if _aaee .Len ()%2==1{_aaee .WriteRune ('0');};_defd ,_ :=_a .DecodeString (_aaee .String ());return MakeHexString (string (_defd )),nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set.  Some other parameters are generated elsewhere.
func (_acc *DCTEncoder )MakeStreamDict ()*PdfObjectDictionary {_caefg :=MakeDict ();_caefg .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_acc .GetFilterName ()));return _caefg ;};

// EncodeBytes JPX encodes the passed in slice of bytes.
func (_gddd *JPXEncoder )EncodeBytes (data []byte )([]byte ,error ){_cab .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_gddd .GetFilterName ());return data ,ErrNoJPXDecode ;};

// DecodeStream returns the passed in stream as a slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_fgca *RawEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return streamObj .Stream ,nil ;};const (_abd =0;_fbac =1;_ecc =2;_cbed =3;_fbe =4;);func (_bgcd *PdfParser )inspect ()(map[string ]int ,error ){_cab .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0053P\u0045\u0043\u0054\u0020\u002d\u002d\u002d\u002d\u002d\u002d-\u002d\u002d\u002d");_cab .Log .Trace ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");_gcba :=map[string ]int {};_caegg :=0;_abcaa :=0;var _dfab []int ;for _ecbf :=range _bgcd ._adde .ObjectMap {_dfab =append (_dfab ,_ecbf );};_c .Ints (_dfab );_dade :=0;for _ ,_egfdc :=range _dfab {_bafd :=_bgcd ._adde .ObjectMap [_egfdc ];if _bafd .ObjectNumber ==0{continue ;};_caegg ++;_cab .Log .Trace ("\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d");_cab .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0075\u0070\u0020\u006f\u0062\u006a\u0065c\u0074 \u006e\u0075\u006d\u0062\u0065\u0072\u003a \u0025\u0064",_bafd .ObjectNumber );_dbbe ,_eggg :=_bgcd .LookupByNumber (_bafd .ObjectNumber );if _eggg !=nil {_cab .Log .Trace ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u006c\u006f\u006f\u006b\u0075p\u0020\u006f\u0062\u006a\u0020\u0025\u0064 \u0028\u0025\u0073\u0029",_bafd .ObjectNumber ,_eggg );_abcaa ++;continue ;};_cab .Log .Trace ("\u006fb\u006a\u003a\u0020\u0025\u0073",_dbbe );_eedc ,_fafc :=_dbbe .(*PdfIndirectObject );if _fafc {_cab .Log .Trace ("\u0049N\u0044 \u004f\u004f\u0042\u004a\u0020\u0025\u0064\u003a\u0020\u0025\u0073",_bafd .ObjectNumber ,_eedc );_bdcfb ,_cdda :=_eedc .PdfObject .(*PdfObjectDictionary );if _cdda {if _cgfc ,_eabea :=_bdcfb .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_eabea {_cgfg :=string (*_cgfc );_cab .Log .Trace ("\u002d\u002d\u002d\u003e\u0020\u004f\u0062\u006a\u0020\u0074\u0079\u0070e\u003a\u0020\u0025\u0073",_cgfg );_ ,_bcad :=_gcba [_cgfg ];if _bcad {_gcba [_cgfg ]++;}else {_gcba [_cgfg ]=1;};}else if _adgc ,_cegd :=_bdcfb .Get ("\u0053u\u0062\u0074\u0079\u0070\u0065").(*PdfObjectName );_cegd {_dacb :=string (*_adgc );_cab .Log .Trace ("-\u002d-\u003e\u0020\u004f\u0062\u006a\u0020\u0073\u0075b\u0074\u0079\u0070\u0065: \u0025\u0073",_dacb );_ ,_accaf :=_gcba [_dacb ];if _accaf {_gcba [_dacb ]++;}else {_gcba [_dacb ]=1;};};if _adad ,_ffad :=_bdcfb .Get ("\u0053").(*PdfObjectName );_ffad &&*_adad =="\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"{_ ,_eabbe :=_gcba ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"];if _eabbe {_gcba ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]++;}else {_gcba ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]=1;};};};}else if _gccee ,_ccfe :=_dbbe .(*PdfObjectStream );_ccfe {if _fcce ,_aabd :=_gccee .PdfObjectDictionary .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_aabd {_cab .Log .Trace ("\u002d\u002d\u003e\u0020\u0053\u0074\u0072\u0065\u0061\u006d\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073",*_fcce );_baaa :=string (*_fcce );_gcba [_baaa ]++;};}else {_cdad ,_abedg :=_dbbe .(*PdfObjectDictionary );if _abedg {_gfag ,_cfacb :=_cdad .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if _cfacb {_eaag :=string (*_gfag );_cab .Log .Trace ("\u002d-\u002d \u006f\u0062\u006a\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073",_eaag );_gcba [_eaag ]++;};};_cab .Log .Trace ("\u0044\u0049\u0052\u0045\u0043\u0054\u0020\u004f\u0042\u004a\u0020\u0025d\u003a\u0020\u0025\u0073",_bafd .ObjectNumber ,_dbbe );};_dade ++;};_cab .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0045\u004fF\u0020\u0049\u004e\u0053\u0050\u0045\u0043T\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d");_cab .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");_cab .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074 \u0063\u006f\u0075\u006e\u0074\u003a\u0020\u0025\u0064",_caegg );_cab .Log .Trace ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u006f\u006b\u0075p\u003a\u0020\u0025\u0064",_abcaa );for _dcfba ,_gfcg :=range _gcba {_cab .Log .Trace ("\u0025\u0073\u003a\u0020\u0025\u0064",_dcfba ,_gfcg );};_cab .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");if len (_bgcd ._adde .ObjectMap )< 1{_cab .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0068\u0069\u0073 \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074 \u0069s\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0028\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0021\u0029");return nil ,_ce .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0064\u006fc\u0075\u006d\u0065\u006e\u0074\u0020\u0028\u0078r\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006d\u0069\u0073s\u0069\u006e\u0067\u0029");};_cdgf ,_cbfc :=_gcba ["\u0046\u006f\u006e\u0074"];if !_cbfc ||_cdgf < 2{_cab .Log .Trace ("\u0054\u0068\u0069s \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020i\u0073 \u0070r\u006fb\u0061\u0062\u006c\u0079\u0020\u0073\u0063\u0061\u006e\u006e\u0065\u0064\u0021");}else {_cab .Log .Trace ("\u0054\u0068\u0069\u0073\u0020\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020\u0069\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0066o\u0072\u0020\u0065\u0078\u0074r\u0061\u0063t\u0069\u006f\u006e\u0021");};return _gcba ,nil ;};

// GetObjectStreams returns the *PdfObjectStreams represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetObjectStreams (obj PdfObject )(_fgde *PdfObjectStreams ,_cfbcd bool ){_fgde ,_cfbcd =obj .(*PdfObjectStreams );return _fgde ,_cfbcd ;};

// WriteString outputs the object as it is to be written to file.
func (_gfbg *PdfObjectStream )WriteString ()string {var _bdge _ee .Builder ;_bdge .WriteString (_ga .FormatInt (_gfbg .ObjectNumber ,10));_bdge .WriteString ("\u0020\u0030\u0020\u0052");return _bdge .String ();};

// String returns a string representation of `name`.
func (_defaf *PdfObjectName )String ()string {return string (*_defaf )};const JB2ImageAutoThreshold =-1.0;

// Set sets the PdfObject at index i of the streams. An error is returned if the index is outside bounds.
func (_cgac *PdfObjectStreams )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_cgac ._gccb ){return _g .New ("\u004f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_cgac ._gccb [i ]=obj ;return nil ;};

// DrawableImage is same as golang image/draw's Image interface that allow drawing images.
type DrawableImage interface{ColorModel ()_ca .Model ;Bounds ()_gd .Rectangle ;At (_fgeb ,_ccgdd int )_ca .Color ;Set (_afdc ,_eebe int ,_cebe _ca .Color );};

// GetBoolVal returns the bool value within a *PdObjectBool represented by an PdfObject interface directly or indirectly.
// If the PdfObject does not represent a bool value, a default value of false is returned (found = false also).
func GetBoolVal (obj PdfObject )(_bbbe bool ,_dgef bool ){_fdfa ,_dgef :=TraceToDirectObject (obj ).(*PdfObjectBool );if _dgef {return bool (*_fdfa ),true ;};return false ,false ;};

// TraceToDirectObject traces a PdfObject to a direct object.  For example direct objects contained
// in indirect objects (can be double referenced even).
func TraceToDirectObject (obj PdfObject )PdfObject {if _gefg ,_gbdf :=obj .(*PdfObjectReference );_gbdf {obj =_gefg .Resolve ();};_dgee ,_fgaf :=obj .(*PdfIndirectObject );_ccefg :=0;for _fgaf {obj =_dgee .PdfObject ;_dgee ,_fgaf =GetIndirect (obj );_ccefg ++;if _ccefg > _bbba {_cab .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0072\u0061\u0063\u0065\u0020\u0064\u0065p\u0074\u0068\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u0062\u0065\u0079\u006fn\u0064\u0020\u0025\u0064\u0020\u002d\u0020\u006e\u006f\u0074\u0020\u0067oi\u006e\u0067\u0020\u0064\u0065\u0065\u0070\u0065\u0072\u0021",_bbba );return nil ;};};return obj ;};

// ToInt64Slice returns a slice of all array elements as an int64 slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_ecda *PdfObjectArray )ToInt64Slice ()([]int64 ,error ){var _bbga []int64 ;for _ ,_cacb :=range _ecda .Elements (){if _gabfc ,_gfee :=_cacb .(*PdfObjectInteger );_gfee {_bbga =append (_bbga ,int64 (*_gabfc ));}else {return nil ,ErrTypeError ;};};return _bbga ,nil ;};

// ResolveReferencesDeep recursively traverses through object `o`, looking up and replacing
// references with indirect objects.
// Optionally a map of already deep-resolved objects can be provided via `traversed`. The `traversed` map
// is updated while traversing the objects to avoid traversing same objects multiple times.
func ResolveReferencesDeep (o PdfObject ,traversed map[PdfObject ]struct{})error {if traversed ==nil {traversed =map[PdfObject ]struct{}{};};return _bebd (o ,0,traversed );};

// GetInt returns the *PdfObjectBool object that is represented by a PdfObject either directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetInt (obj PdfObject )(_cabad *PdfObjectInteger ,_gbaa bool ){_cabad ,_gbaa =TraceToDirectObject (obj ).(*PdfObjectInteger );return _cabad ,_gbaa ;};

// MakeName creates a PdfObjectName from a string.
func MakeName (s string )*PdfObjectName {_bffbc :=PdfObjectName (s );return &_bffbc };

// EncodeBytes ASCII encodes the passed in slice of bytes.
func (_afa *ASCIIHexEncoder )EncodeBytes (data []byte )([]byte ,error ){var _ebad _ced .Buffer ;for _ ,_dbee :=range data {_ebad .WriteString (_ce .Sprintf ("\u0025\u002e\u0032X\u0020",_dbee ));};_ebad .WriteByte ('>');return _ebad .Bytes (),nil ;};func (_gbef *PdfParser )skipSpaces ()(int ,error ){_ffabd :=0;for {_gecg ,_edag :=_gbef ._afbd .ReadByte ();if _edag !=nil {return 0,_edag ;};if IsWhiteSpace (_gecg ){_ffabd ++;}else {_gbef ._afbd .UnreadByte ();break ;};};return _ffabd ,nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_cgfdg *DCTEncoder )UpdateParams (params *PdfObjectDictionary ){_ege ,_cdcb :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _cdcb ==nil {_cgfdg .ColorComponents =int (_ege );};_ffcb ,_cdcb :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _cdcb ==nil {_cgfdg .BitsPerComponent =int (_ffcb );};_aedd ,_cdcb :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _cdcb ==nil {_cgfdg .Width =int (_aedd );};_fffd ,_cdcb :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _cdcb ==nil {_cgfdg .Height =int (_fffd );};_bccd ,_cdcb :=GetNumberAsInt64 (params .Get ("\u0051u\u0061\u006c\u0069\u0074\u0079"));if _cdcb ==nil {_cgfdg .Quality =int (_bccd );};};

// MakeStream creates an PdfObjectStream with specified contents and encoding. If encoding is nil, then raw encoding
// will be used (i.e. no encoding applied).
func MakeStream (contents []byte ,encoder StreamEncoder )(*PdfObjectStream ,error ){_cbf :=&PdfObjectStream {};if encoder ==nil {encoder =NewRawEncoder ();};_cbf .PdfObjectDictionary =encoder .MakeStreamDict ();_baga ,_cfdf :=encoder .EncodeBytes (contents );if _cfdf !=nil {return nil ,_cfdf ;};_cbf .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_baga ))));_cbf .Stream =_baga ;return _cbf ,nil ;};

// IsNullObject returns true if `obj` is a PdfObjectNull.
func IsNullObject (obj PdfObject )bool {_ ,_aegb :=TraceToDirectObject (obj ).(*PdfObjectNull );return _aegb ;};

// NewMultiEncoder returns a new instance of MultiEncoder.
func NewMultiEncoder ()*MultiEncoder {_dfcd :=MultiEncoder {};_dfcd ._dffc =[]StreamEncoder {};return &_dfcd ;};func _ead (_edf *_bd .StdEncryptDict ,_bab *PdfObjectDictionary ){_bab .Set ("\u0052",MakeInteger (int64 (_edf .R )));_bab .Set ("\u0050",MakeInteger (int64 (_edf .P )));_bab .Set ("\u004f",MakeStringFromBytes (_edf .O ));_bab .Set ("\u0055",MakeStringFromBytes (_edf .U ));if _edf .R >=5{_bab .Set ("\u004f\u0045",MakeStringFromBytes (_edf .OE ));_bab .Set ("\u0055\u0045",MakeStringFromBytes (_edf .UE ));_bab .Set ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061",MakeBool (_edf .EncryptMetadata ));if _edf .R > 5{_bab .Set ("\u0050\u0065\u0072m\u0073",MakeStringFromBytes (_edf .Perms ));};};};func (_eeg *PdfCrypt )checkAccessRights (_agbe []byte )(bool ,_bd .Permissions ,error ){_edd :=_eeg .securityHandler ();_bef ,_egbe ,_ece :=_edd .Authenticate (&_eeg ._gfa ,_agbe );if _ece !=nil {return false ,0,_ece ;}else if _egbe ==0||len (_bef )==0{return false ,0,nil ;};return true ,_egbe ,nil ;};

// XrefObject defines a cross reference entry which is a map between object number (with generation number) and the
// location of the actual object, either as a file offset (xref table entry), or as a location within an xref
// stream object (xref object stream).
type XrefObject struct{XType xrefType ;ObjectNumber int ;Generation int ;

// For normal xrefs (defined by OFFSET)
Offset int64 ;

// For xrefs to object streams.
OsObjNumber int ;OsObjIndex int ;};

// EncodeBytes implements support for LZW encoding.  Currently not supporting predictors (raw compressed data only).
// Only supports the Early change = 1 algorithm (compress/lzw) as the other implementation
// does not have a write method.
// TODO: Consider refactoring compress/lzw to allow both.
func (_bac *LZWEncoder )EncodeBytes (data []byte )([]byte ,error ){if _bac .Predictor !=1{return nil ,_ce .Errorf ("\u004c\u005aW \u0050\u0072\u0065d\u0069\u0063\u0074\u006fr =\u00201 \u006f\u006e\u006c\u0079\u0020\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0079e\u0074");};if _bac .EarlyChange ==1{return nil ,_ce .Errorf ("\u004c\u005a\u0057\u0020\u0045\u0061\u0072\u006c\u0079\u0020\u0043\u0068\u0061n\u0067\u0065\u0020\u003d\u0020\u0030 \u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0079\u0065\u0074");};var _dege _ced .Buffer ;_adee :=_e .NewWriter (&_dege ,_e .MSB ,8);_adee .Write (data );_adee .Close ();return _dege .Bytes (),nil ;};

// MakeFloat creates an PdfObjectFloat from a float64.
func MakeFloat (val float64 )*PdfObjectFloat {_cabfg :=PdfObjectFloat (val );return &_cabfg };func (_aegbd *PdfParser )repairSeekXrefMarker ()error {_aggf ,_ecff :=_aegbd ._bfca .Seek (0,_ge .SeekEnd );if _ecff !=nil {return _ecff ;};_eddbab :=_cc .MustCompile ("\u005cs\u0078\u0072\u0065\u0066\u005c\u0073*");var _gdcag int64 ;var _acca int64 =1000;for _gdcag < _aggf {if _aggf <=(_acca +_gdcag ){_acca =_aggf -_gdcag ;};_ ,_gebd :=_aegbd ._bfca .Seek (-_gdcag -_acca ,_ge .SeekEnd );if _gebd !=nil {return _gebd ;};_efaab :=make ([]byte ,_acca );_aegbd ._bfca .Read (_efaab );_cab .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0078\u0072\u0065\u0066\u0020\u003a\u0020\u0022\u0025\u0073\u0022",string (_efaab ));_gbed :=_eddbab .FindAllStringIndex (string (_efaab ),-1);if _gbed !=nil {_adagc :=_gbed [len (_gbed )-1];_cab .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_gbed );_aegbd ._bfca .Seek (-_gdcag -_acca +int64 (_adagc [0]),_ge .SeekEnd );_aegbd ._afbd =_dg .NewReader (_aegbd ._bfca );for {_fdaf ,_fegd :=_aegbd ._afbd .Peek (1);if _fegd !=nil {return _fegd ;};_cab .Log .Trace ("\u0042\u003a\u0020\u0025\u0064\u0020\u0025\u0063",_fdaf [0],_fdaf [0]);if !IsWhiteSpace (_fdaf [0]){break ;};_aegbd ._afbd .Discard (1);};return nil ;};_cab .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");_gdcag +=_acca ;};_cab .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074a\u0062\u006c\u0065\u0020\u006d\u0061r\u006b\u0065\u0072\u0020\u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066o\u0075\u006e\u0064\u002e");return _g .New ("\u0078r\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0020");};