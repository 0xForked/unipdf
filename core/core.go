//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package core defines and implements the primitive PDF object types in golang, and provides functionality
// for parsing those from a PDF file stream. This includes I/O handling, cross references, repairs, encryption,
// encoding and other core capabilities.
package core ;import (_adg "bufio";_dgb "bytes";_dg "compress/lzw";_dc "compress/zlib";_ad "crypto/md5";_bg "crypto/rand";_gba "encoding/hex";_f "errors";_aa "fmt";_cd "github.com/unidoc/unipdf/v3/common";_dd "github.com/unidoc/unipdf/v3/core/security";_ag "github.com/unidoc/unipdf/v3/core/security/crypt";_be "github.com/unidoc/unipdf/v3/internal/ccittfax";_ada "github.com/unidoc/unipdf/v3/internal/imageutil";_cb "github.com/unidoc/unipdf/v3/internal/jbig2";_fd "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_ff "github.com/unidoc/unipdf/v3/internal/jbig2/decoder";_ac "github.com/unidoc/unipdf/v3/internal/jbig2/document";_cf "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_fe "github.com/unidoc/unipdf/v3/internal/strutils";_dff "golang.org/x/image/tiff/lzw";_bc "golang.org/x/xerrors";_cg "image";_ae "image/color";_e "image/jpeg";_gb "io";_df "os";_fa "reflect";_c "regexp";_g "sort";_d "strconv";_ed "strings";_b "time";);func (_cae *PdfParser )skipComments ()error {if _ ,_aaabe :=_cae .skipSpaces ();_aaabe !=nil {return _aaabe ;};_abcdg :=true ;for {_cgcd ,_aggd :=_cae ._bfbbd .Peek (1);if _aggd !=nil {_cd .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_aggd .Error ());return _aggd ;};if _abcdg &&_cgcd [0]!='%'{return nil ;};_abcdg =false ;if (_cgcd [0]!='\r')&&(_cgcd [0]!='\n'){_cae ._bfbbd .ReadByte ();}else {break ;};};return _cae .skipComments ();};func (_bdc *PdfCrypt )authenticate (_bea []byte )(bool ,error ){_bdc ._fag =false ;_aef :=_bdc .securityHandler ();_bgc ,_decf ,_fedb :=_aef .Authenticate (&_bdc ._cgd ,_bea );if _fedb !=nil {return false ,_fedb ;}else if _decf ==0||len (_bgc )==0{return false ,nil ;};_bdc ._fag =true ;_bdc ._cebd =_bgc ;return true ,nil ;};func (_bfcd *PdfParser )parseXref ()(*PdfObjectDictionary ,error ){const _dbaa =20;_eadde ,_ :=_bfcd ._bfbbd .Peek (_dbaa );for _dbge :=0;_dbge < 2;_dbge ++{if _bfcd ._aafc ==0{_bfcd ._aafc =_bfcd .GetFileOffset ();};if _geeb .Match (_eadde ){_cd .Log .Trace ("\u0078\u0072e\u0066\u0020\u0070\u006f\u0069\u006e\u0074\u0073\u0020\u0074\u006f\u0020\u0061\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u002e\u0020\u0050\u0072\u006f\u0062\u0061\u0062\u006c\u0079\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063\u0074");_cd .Log .Debug ("\u0073t\u0061r\u0074\u0069\u006e\u0067\u0020w\u0069\u0074h\u0020\u0022\u0025\u0073\u0022",string (_eadde ));return _bfcd .parseXrefStream (nil );};if _fbce .Match (_eadde ){_cd .Log .Trace ("\u0053\u0074\u0061\u006ed\u0061\u0072\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073e\u0063t\u0069\u006f\u006e\u0020\u0074\u0061\u0062l\u0065\u0021");return _bfcd .parseXrefTable ();};_ceccc :=_bfcd .GetFileOffset ();if _bfcd ._aafc ==0{_bfcd ._aafc =_ceccc ;};_bfcd .SetFileOffset (_ceccc -_dbaa );defer _bfcd .SetFileOffset (_ceccc );_eefg ,_ :=_bfcd ._bfbbd .Peek (_dbaa );_eadde =append (_eefg ,_eadde ...);};_cd .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u0078\u0072\u0065f\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006fr\u0020\u0073\u0074\u0072\u0065\u0061\u006d.\u0020\u0052\u0065\u0070\u0061i\u0072\u0020\u0061\u0074\u0074e\u006d\u0070\u0074\u0065\u0064\u003a\u0020\u004c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0065\u0061\u0072\u006c\u0069\u0065\u0073\u0074\u0020x\u0072\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u0062\u006f\u0074to\u006d\u002e");if _eada :=_bfcd .repairSeekXrefMarker ();_eada !=nil {_cd .Log .Debug ("\u0052e\u0070a\u0069\u0072\u0020\u0066\u0061i\u006c\u0065d\u0020\u002d\u0020\u0025\u0076",_eada );return nil ,_eada ;};return _bfcd .parseXrefTable ();};

// JBIG2Image is the image structure used by the jbig2 encoder. Its Data must be in a
// 1 bit per component and 1 component per pixel (1bpp). In order to create binary image
// use GoImageToJBIG2 function. If the image data contains the row bytes padding set the HasPadding to true.
type JBIG2Image struct{

// Width and Height defines the image boundaries.
Width ,Height int ;

// Data is the byte slice data for the input image
Data []byte ;

// HasPadding is the attribute that defines if the last byte of the data in the row contains
// 0 bits padding.
HasPadding bool ;};type objectCache map[int ]PdfObject ;

// MakeHexString creates an PdfObjectString from a string intended for output as a hexadecimal string.
func MakeHexString (s string )*PdfObjectString {_adabb :=PdfObjectString {_eagc :s ,_edafc :true };return &_adabb ;};

// Encrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_bgf *PdfCrypt )Encrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _bgf .isEncrypted (obj ){return nil ;};switch _cbc :=obj .(type ){case *PdfIndirectObject :_bgf ._bde [_cbc ]=true ;_cd .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_cbc .ObjectNumber ,_cbc .GenerationNumber );_dgdb :=_cbc .ObjectNumber ;_ffe :=_cbc .GenerationNumber ;_aga :=_bgf .Encrypt (_cbc .PdfObject ,_dgdb ,_ffe );if _aga !=nil {return _aga ;};return nil ;case *PdfObjectStream :_bgf ._bde [_cbc ]=true ;_dabe :=_cbc .PdfObjectDictionary ;if _cebf ,_gbf :=_dabe .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_gbf &&*_cebf =="\u0058\u0052\u0065\u0066"{return nil ;};_geg :=_cbc .ObjectNumber ;_gabf :=_cbc .GenerationNumber ;_cd .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_geg ,_gabf );_abc :=_cgg ;if _bgf ._cfd .V >=4{_abc =_bgf ._eeb ;_cd .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_bgf ._eeb );if _gae ,_afcb :=_dabe .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );_afcb {if _faf ,_feb :=GetName (_gae .Get (0));_feb {if *_faf =="\u0043\u0072\u0079p\u0074"{_abc ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _adea ,_dgaf :=_dabe .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );_dgaf {if _egb ,_abfca :=_adea .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_abfca {if _ ,_bcf :=_bgf ._bee [string (*_egb )];_bcf {_cd .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_egb );_abc =string (*_egb );};};};};};};_cd .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_abc );if _abc =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_fgcab :=_bgf .Encrypt (_cbc .PdfObjectDictionary ,_geg ,_gabf );if _fgcab !=nil {return _fgcab ;};_cag ,_fgcab :=_bgf .makeKey (_abc ,uint32 (_geg ),uint32 (_gabf ),_bgf ._cebd );if _fgcab !=nil {return _fgcab ;};_cbc .Stream ,_fgcab =_bgf .encryptBytes (_cbc .Stream ,_abc ,_cag );if _fgcab !=nil {return _fgcab ;};_dabe .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_cbc .Stream ))));return nil ;case *PdfObjectString :_cd .Log .Trace ("\u0045n\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_cfdc :=_cgg ;if _bgf ._cfd .V >=4{_cd .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_bgf ._cac );if _bgf ._cac =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_cfdc =_bgf ._cac ;};_bdec ,_dgea :=_bgf .makeKey (_cfdc ,uint32 (parentObjNum ),uint32 (parentGenNum ),_bgf ._cebd );if _dgea !=nil {return _dgea ;};_eag :=_cbc .Str ();_beaa :=make ([]byte ,len (_eag ));for _ead :=0;_ead < len (_eag );_ead ++{_beaa [_ead ]=_eag [_ead ];};_cd .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_beaa ,_beaa );_beaa ,_dgea =_bgf .encryptBytes (_beaa ,_cfdc ,_bdec );if _dgea !=nil {return _dgea ;};_cbc ._eagc =string (_beaa );return nil ;case *PdfObjectArray :for _ ,_ddae :=range _cbc .Elements (){_fbe :=_bgf .Encrypt (_ddae ,parentObjNum ,parentGenNum );if _fbe !=nil {return _fbe ;};};return nil ;case *PdfObjectDictionary :_eafc :=false ;if _eecd :=_cbc .Get ("\u0054\u0079\u0070\u0065");_eecd !=nil {_afa ,_abd :=_eecd .(*PdfObjectName );if _abd &&*_afa =="\u0053\u0069\u0067"{_eafc =true ;};};for _ ,_fgd :=range _cbc .Keys (){_beb :=_cbc .Get (_fgd );if _eafc &&string (_fgd )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;};if string (_fgd )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_fgd )!="\u0050\u0072\u0065\u0076"&&string (_fgd )!="\u004c\u0061\u0073\u0074"{_dagd :=_bgf .Encrypt (_beb ,parentObjNum ,parentGenNum );if _dagd !=nil {return _dagd ;};};};return nil ;};return nil ;};func _babg (_gfcc PdfObject ,_ddbag int ,_ffad map[PdfObject ]struct{})error {_cd .Log .Trace ("\u0054\u0072\u0061\u0076\u0065\u0072s\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0064\u0061\u0074\u0061 \u0028\u0064\u0065\u0070\u0074\u0068\u0020=\u0020\u0025\u0064\u0029",_ddbag );if _ ,_eefe :=_ffad [_gfcc ];_eefe {_cd .Log .Trace ("-\u0041\u006c\u0072\u0065ad\u0079 \u0074\u0072\u0061\u0076\u0065r\u0073\u0065\u0064\u002e\u002e\u002e");return nil ;};_ffad [_gfcc ]=struct{}{};switch _gaee :=_gfcc .(type ){case *PdfIndirectObject :_fgfb :=_gaee ;_cd .Log .Trace ("\u0069\u006f\u003a\u0020\u0025\u0073",_fgfb );_cd .Log .Trace ("\u002d\u0020\u0025\u0073",_fgfb .PdfObject );return _babg (_fgfb .PdfObject ,_ddbag +1,_ffad );case *PdfObjectStream :_aacb :=_gaee ;return _babg (_aacb .PdfObjectDictionary ,_ddbag +1,_ffad );case *PdfObjectDictionary :_efec :=_gaee ;_cd .Log .Trace ("\u002d\u0020\u0064\u0069\u0063\u0074\u003a\u0020\u0025\u0073",_efec );for _ ,_efgd :=range _efec .Keys (){_bfca :=_efec .Get (_efgd );if _ccdf ,_gfgg :=_bfca .(*PdfObjectReference );_gfgg {_dgeeb :=_ccdf .Resolve ();_efec .Set (_efgd ,_dgeeb );_eaca :=_babg (_dgeeb ,_ddbag +1,_ffad );if _eaca !=nil {return _eaca ;};}else {_gbagf :=_babg (_bfca ,_ddbag +1,_ffad );if _gbagf !=nil {return _gbagf ;};};};return nil ;case *PdfObjectArray :_cccd :=_gaee ;_cd .Log .Trace ("-\u0020\u0061\u0072\u0072\u0061\u0079\u003a\u0020\u0025\u0073",_cccd );for _edaef ,_cceae :=range _cccd .Elements (){if _gcef ,_cbfg :=_cceae .(*PdfObjectReference );_cbfg {_ebcaa :=_gcef .Resolve ();_cccd .Set (_edaef ,_ebcaa );_bgbb :=_babg (_ebcaa ,_ddbag +1,_ffad );if _bgbb !=nil {return _bgbb ;};}else {_dbdb :=_babg (_cceae ,_ddbag +1,_ffad );if _dbdb !=nil {return _dbdb ;};};};return nil ;case *PdfObjectReference :_cd .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020T\u0072\u0061\u0063\u0069\u006e\u0067\u0020\u0061\u0020r\u0065\u0066\u0065r\u0065n\u0063\u0065\u0021");return _f .New ("\u0065r\u0072\u006f\u0072\u0020t\u0072\u0061\u0063\u0069\u006eg\u0020a\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");};return nil ;};

// NewRawEncoder returns a new instace of RawEncoder.
func NewRawEncoder ()*RawEncoder {return &RawEncoder {}};var _cage =_c .MustCompile ("\u0025\u0025\u0045\u004f\u0046\u003f");

// SetFileOffset sets the file to an offset position and resets buffer.
func (_ccbge *PdfParser )SetFileOffset (offset int64 ){if offset < 0{offset =0;};_ccbge ._egfc .Seek (offset ,_gb .SeekStart );_ccbge ._bfbbd =_adg .NewReader (_ccbge ._egfc );};

// DecodeStream decodes RunLengthEncoded stream object and give back decoded bytes.
func (_fccd *RunLengthEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _fccd .DecodeBytes (streamObj .Stream );};func (_bbda *PdfCrypt )generateParams (_aefb ,_cgb []byte )error {_bdcad :=_bbda .securityHandler ();_adeg ,_fdc :=_bdcad .GenerateParams (&_bbda ._cgd ,_cgb ,_aefb );if _fdc !=nil {return _fdc ;};_bbda ._cebd =_adeg ;return nil ;};

// Get returns the PdfObject corresponding to the specified key.
// Returns a nil value if the key is not set.
func (_gcdeb *PdfObjectDictionary )Get (key PdfObjectName )PdfObject {_gcgag ,_cdgc :=_gcdeb ._bacc [key ];if !_cdgc {return nil ;};return _gcgag ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_acbf *RawEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};func (_cbgg *JBIG2Encoder )encodeImage (_egdb _cg .Image )([]byte ,error ){const _acgc ="e\u006e\u0063\u006f\u0064\u0065\u0049\u006d\u0061\u0067\u0065";_adafe ,_gcbg :=GoImageToJBIG2 (_egdb ,JB2ImageAutoThreshold );if _gcbg !=nil {return nil ,_cf .Wrap (_gcbg ,_acgc ,"\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069m\u0061g\u0065\u0020\u0074\u006f\u0020\u006a\u0062\u0069\u0067\u0032\u0020\u0069\u006d\u0067");};if _gcbg =_cbgg .AddPageImage (_adafe ,&_cbgg .DefaultPageSettings );_gcbg !=nil {return nil ,_cf .Wrap (_gcbg ,_acgc ,"");};return _cbgg .Encode ();};

// GetFilterName returns the name of the encoding filter.
func (_cfdd *FlateEncoder )GetFilterName ()string {return StreamEncodingFilterNameFlate };func _gfab (_baec *PdfObjectStream ,_gcea *PdfObjectDictionary )(*CCITTFaxEncoder ,error ){_abce :=NewCCITTFaxEncoder ();_ecdg :=_baec .PdfObjectDictionary ;if _ecdg ==nil {return _abce ,nil ;};if _gcea ==nil {_dcd :=TraceToDirectObject (_ecdg .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));if _dcd !=nil {switch _cge :=_dcd .(type ){case *PdfObjectDictionary :_gcea =_cge ;break ;case *PdfObjectArray :if _cge .Len ()==1{if _eab ,_eage :=GetDict (_cge .Get (0));_eage {_gcea =_eab ;};};default:_cd .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_dcd );return nil ,_f .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _gcea ==nil {_cd .Log .Error ("\u0044\u0065c\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064 %\u0023\u0076",_dcd );return nil ,_f .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _dfcc ,_ebdf :=GetNumberAsInt64 (_gcea .Get ("\u004b"));_ebdf ==nil {_abce .K =int (_dfcc );};if _cdbe ,_gafe :=GetNumberAsInt64 (_gcea .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));_gafe ==nil {_abce .Columns =int (_cdbe );}else {_abce .Columns =1728;};if _bgfb ,_edb :=GetNumberAsInt64 (_gcea .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_edb ==nil {_abce .BlackIs1 =_bgfb > 0;}else {if _dadc ,_ggge :=GetBoolVal (_gcea .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_ggge {_abce .BlackIs1 =_dadc ;}else {if _agfc ,_dgdbg :=GetArray (_gcea .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));_dgdbg {_aae ,_gbacg :=_agfc .ToIntegerArray ();if _gbacg ==nil {_abce .BlackIs1 =_aae [0]==1&&_aae [1]==0;};};};};if _fadc ,_egba :=GetNumberAsInt64 (_gcea .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_egba ==nil {_abce .EncodedByteAlign =_fadc > 0;}else {if _ecdc ,_gebd :=GetBoolVal (_gcea .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_gebd {_abce .EncodedByteAlign =_ecdc ;};};if _gceb ,_fabe :=GetNumberAsInt64 (_gcea .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_fabe ==nil {_abce .EndOfLine =_gceb > 0;}else {if _dgfg ,_aaeb :=GetBoolVal (_gcea .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_aaeb {_abce .EndOfLine =_dgfg ;};};if _bff ,_bgafb :=GetNumberAsInt64 (_gcea .Get ("\u0052\u006f\u0077\u0073"));_bgafb ==nil {_abce .Rows =int (_bff );};_abce .EndOfBlock =true ;if _eda ,_efe :=GetNumberAsInt64 (_gcea .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_efe ==nil {_abce .EndOfBlock =_eda > 0;}else {if _fcga ,_gfag :=GetBoolVal (_gcea .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_gfag {_abce .EndOfBlock =_fcga ;};};if _cdcc ,_fgfc :=GetNumberAsInt64 (_gcea .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));_fgfc !=nil {_abce .DamagedRowsBeforeError =int (_cdcc );};_cd .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_gcea .String ());return _abce ,nil ;};func (_gffbc *PdfObjectFloat )String ()string {return _aa .Sprintf ("\u0025\u0066",*_gffbc )};

// Str returns the string value of the PdfObjectString. Defined in addition to String() function to clarify that
// this function returns the underlying string directly, whereas the String function technically could include
// debug info.
func (_caaa *PdfObjectString )Str ()string {return _caaa ._eagc };

// GetFilterName returns the name of the encoding filter.
func (_gegg *CCITTFaxEncoder )GetFilterName ()string {return StreamEncodingFilterNameCCITTFax };

// MultiEncoder supports serial encoding.
type MultiEncoder struct{_egdf []StreamEncoder };

// Resolve resolves the reference and returns the indirect or stream object.
// If the reference cannot be resolved, a *PdfObjectNull object is returned.
func (_ecab *PdfObjectReference )Resolve ()PdfObject {if _ecab ._dbca ==nil {return MakeNull ();};_cgea ,_ ,_dfcb :=_ecab ._dbca .resolveReference (_ecab );if _dfcb !=nil {_cd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0072\u0065\u0073\u006f\u006cv\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065r\u0065n\u0063\u0065\u003a\u0020\u0025\u0076\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074",_dfcb );return MakeNull ();};if _cgea ==nil {_cd .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0072\u0065\u0073ol\u0076\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065:\u0020\u006ei\u006c\u0020\u006fb\u006a\u0065\u0063\u0074\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u0061\u0020nu\u006c\u006c\u0020o\u0062\u006a\u0065\u0063\u0074");return MakeNull ();};return _cgea ;};

// JBIG2CompressionType defines the enum compression type used by the JBIG2Encoder.
type JBIG2CompressionType int ;

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_cdfg *FlateEncoder )MakeDecodeParams ()PdfObject {if _cdfg .Predictor > 1{_fce :=MakeDict ();_fce .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_cdfg .Predictor )));if _cdfg .BitsPerComponent !=8{_fce .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_cdfg .BitsPerComponent )));};if _cdfg .Columns !=1{_fce .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_cdfg .Columns )));};if _cdfg .Colors !=1{_fce .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_cdfg .Colors )));};return _fce ;};return nil ;};

// EncodeStream encodes the stream data using the encoded specified by the stream's dictionary.
func EncodeStream (streamObj *PdfObjectStream )error {_cd .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_eeec ,_cggcg :=NewEncoderFromStream (streamObj );if _cggcg !=nil {_cd .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_cggcg );return _cggcg ;};if _ccab ,_gcfe :=_eeec .(*LZWEncoder );_gcfe {_ccab .EarlyChange =0;streamObj .PdfObjectDictionary .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (0));};_cd .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076\u000a",_eeec );_dfcbc ,_cggcg :=_eeec .EncodeBytes (streamObj .Stream );if _cggcg !=nil {_cd .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_cggcg );return _cggcg ;};streamObj .Stream =_dfcbc ;streamObj .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_dfcbc ))));return nil ;};func _dgbd (_egg PdfObject )(int64 ,int64 ,error ){if _gde ,_fgf :=_egg .(*PdfIndirectObject );_fgf {return _gde .ObjectNumber ,_gde .GenerationNumber ,nil ;};if _af ,_gf :=_egg .(*PdfObjectStream );_gf {return _af .ObjectNumber ,_af .GenerationNumber ,nil ;};return 0,0,_f .New ("\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u002f\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062je\u0063\u0074");};

// UpdateParams updates the parameter values of the encoder.
func (_ege *CCITTFaxEncoder )UpdateParams (params *PdfObjectDictionary ){if _gdc ,_dgcb :=GetNumberAsInt64 (params .Get ("\u004b"));_dgcb ==nil {_ege .K =int (_gdc );};if _bed ,_fgea :=GetNumberAsInt64 (params .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));_fgea ==nil {_ege .Columns =int (_bed );}else if _bed ,_fgea =GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));_fgea ==nil {_ege .Columns =int (_bed );};if _cdfb ,_gfcd :=GetNumberAsInt64 (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_gfcd ==nil {_ege .BlackIs1 =_cdfb > 0;}else {if _fcbb ,_eeeg :=GetBoolVal (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_eeeg {_ege .BlackIs1 =_fcbb ;}else {if _ddafe ,_gaegg :=GetArray (params .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));_gaegg {_cagc ,_cbee :=_ddafe .ToIntegerArray ();if _cbee ==nil {_ege .BlackIs1 =_cagc [0]==1&&_cagc [1]==0;};};};};if _fcdeg ,_faeg :=GetNumberAsInt64 (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_faeg ==nil {_ege .EncodedByteAlign =_fcdeg > 0;}else {if _ccd ,_cbec :=GetBoolVal (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_cbec {_ege .EncodedByteAlign =_ccd ;};};if _dgdfg ,_beeaf :=GetNumberAsInt64 (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_beeaf ==nil {_ege .EndOfLine =_dgdfg > 0;}else {if _eddf ,_cdcca :=GetBoolVal (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_cdcca {_ege .EndOfLine =_eddf ;};};if _acac ,_fdbe :=GetNumberAsInt64 (params .Get ("\u0052\u006f\u0077\u0073"));_fdbe ==nil {_ege .Rows =int (_acac );}else if _acac ,_fdbe =GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));_fdbe ==nil {_ege .Rows =int (_acac );};if _fdg ,_fgff :=GetNumberAsInt64 (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_fgff ==nil {_ege .EndOfBlock =_fdg > 0;}else {if _fafd ,_edfa :=GetBoolVal (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_edfa {_ege .EndOfBlock =_fafd ;};};if _dffb ,_eefdg :=GetNumberAsInt64 (params .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));_eefdg !=nil {_ege .DamagedRowsBeforeError =int (_dffb );};};var _fecd =_c .MustCompile ("\u005e\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");

// WriteString outputs the object as it is to be written to file.
func (_gfgd *PdfObjectNull )WriteString ()string {return "\u006e\u0075\u006c\u006c"};

// GetNumbersAsFloat converts a list of pdf objects representing floats or integers to a slice of
// float64 values.
func GetNumbersAsFloat (objects []PdfObject )(_dcfdg []float64 ,_eaee error ){for _ ,_fgdd :=range objects {_ccdaf ,_gccef :=GetNumberAsFloat (_fgdd );if _gccef !=nil {return nil ,_gccef ;};_dcfdg =append (_dcfdg ,_ccdaf );};return _dcfdg ,nil ;};func _cbg (_deed *PdfObjectStream ,_adb *PdfObjectDictionary )(*RunLengthEncoder ,error ){return NewRunLengthEncoder (),nil ;};

// EncodeBytes encodes the image data using either Group3 or Group4 CCITT facsimile (fax) encoding.
// `data` is expected to be 1 color component, 1 byte per component.
func (_egde *CCITTFaxEncoder )EncodeBytes (data []byte )([]byte ,error ){var _deba [][]byte ;for _eege :=0;_eege < len (data );_eege +=_egde .Columns {_daea :=make ([]byte ,_egde .Columns );_eddfg :=0;for _ddfcb :=0;_ddfcb < _egde .Columns ;_ddfcb ++{if data [_eege +_ddfcb ]==255{_daea [_eddfg ]=1;}else {_daea [_eddfg ]=0;};_eddfg ++;};_deba =append (_deba ,_daea );};_ffgb :=&_be .Encoder {K :_egde .K ,Columns :_egde .Columns ,EndOfLine :_egde .EndOfLine ,EndOfBlock :_egde .EndOfBlock ,BlackIs1 :_egde .BlackIs1 ,DamagedRowsBeforeError :_egde .DamagedRowsBeforeError ,Rows :_egde .Rows ,EncodedByteAlign :_egde .EncodedByteAlign };return _ffgb .Encode (_deba ),nil ;};func (_bgdc *PdfCrypt )newEncryptDict ()*PdfObjectDictionary {_bce :=MakeDict ();_bce .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName ("\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"));_bce .Set ("\u0056",MakeInteger (int64 (_bgdc ._cfd .V )));_bce .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_bgdc ._cfd .Length )));return _bce ;};

// GetArray returns the *PdfObjectArray represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetArray (obj PdfObject )(_gbcfg *PdfObjectArray ,_dbgeb bool ){_gbcfg ,_dbgeb =TraceToDirectObject (obj ).(*PdfObjectArray );return _gbcfg ,_dbgeb ;};

// DecodeBytes decodes a slice of JBIG2 encoded bytes and returns the results.
func (_fecea *JBIG2Encoder )DecodeBytes (encoded []byte )([]byte ,error ){return _cb .DecodeBytes (encoded ,_ff .Parameters {},_fecea .Globals );};func (_feg *PdfParser )seekPdfVersionTopDown ()(int ,int ,error ){_feg ._egfc .Seek (0,_df .SEEK_SET );_feg ._bfbbd =_adg .NewReader (_feg ._egfc );_dece :=20;_bggf :=make ([]byte ,_dece );for {_bdggf ,_agea :=_feg ._bfbbd .ReadByte ();if _agea !=nil {if _agea ==_gb .EOF {break ;}else {return 0,0,_agea ;};};if IsDecimalDigit (_bdggf )&&_bggf [_dece -1]=='.'&&IsDecimalDigit (_bggf [_dece -2])&&_bggf [_dece -3]=='-'&&_bggf [_dece -4]=='F'&&_bggf [_dece -5]=='D'&&_bggf [_dece -6]=='P'{_efga :=int (_bggf [_dece -2]-'0');_ddgge :=int (_bdggf -'0');return _efga ,_ddgge ,nil ;};_bggf =append (_bggf [1:_dece ],_bdggf );};return 0,0,_f .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};

// FlateEncoder represents Flate encoding.
type FlateEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Rows int ;Colors int ;_adead *_ada .ImageBase ;};

// JBIG2Encoder implements both jbig2 encoder and the decoder. The encoder allows to encode
// provided images (best used document scans) in multiple way. By default it uses single page generic
// encoder. It allows to store lossless data as a single segment.
// In order to store multiple image pages use the 'FileMode' which allows to store more pages within single jbig2 document.
// WIP: In order to obtain better compression results the encoder would allow to encode the input in a
// lossy or lossless way with a component (symbol) mode. It divides the image into components.
// Then checks if any component is 'similar' to the others and maps them together. The symbol classes are stored
// in the dictionary. Then the encoder creates text regions which uses the related symbol classes to fill it's space.
// The similarity is defined by the 'Threshold' variable (default: 0.95). The less the value is, the more components
// matches to single class, thus the compression is better, but the result might become lossy.
type JBIG2Encoder struct{

// These values are required to be set for the 'EncodeBytes' method.
// ColorComponents defines the number of color components for provided image.
ColorComponents int ;

// BitsPerComponent is the number of bits that stores per color component
BitsPerComponent int ;

// Width is the width of the image to encode
Width int ;

// Height is the height of the image to encode.
Height int ;_dggg *_ac .Document ;

// Globals are the JBIG2 global segments.
Globals _cb .Globals ;

// IsChocolateData defines if the data is encoded such that
// binary data '1' means black and '0' white.
// otherwise the data is called vanilla.
// Naming convention taken from: 'https://en.wikipedia.org/wiki/Binary_image#Interpretation'
IsChocolateData bool ;

// DefaultPageSettings are the settings parameters used by the jbig2 encoder.
DefaultPageSettings JBIG2EncoderSettings ;};

// LZWEncoder provides LZW encoding/decoding functionality.
type LZWEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Colors int ;

// LZW algorithm setting.
EarlyChange int ;};

// MakeStreamDict make a new instance of an encoding dictionary for a stream object.
func (_cfeaa *ASCII85Encoder )MakeStreamDict ()*PdfObjectDictionary {_dcgf :=MakeDict ();_dcgf .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_cfeaa .GetFilterName ()));return _dcgf ;};

// GetDict returns the *PdfObjectDictionary represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetDict (obj PdfObject )(_eaeg *PdfObjectDictionary ,_fecf bool ){_eaeg ,_fecf =TraceToDirectObject (obj ).(*PdfObjectDictionary );return _eaeg ,_fecf ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_gafb *RunLengthEncoder )MakeStreamDict ()*PdfObjectDictionary {_aebc :=MakeDict ();_aebc .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_gafb .GetFilterName ()));return _aebc ;};type cryptFilters map[string ]_ag .Filter ;func (_dcde *PdfParser )repairLocateXref ()(int64 ,error ){_ceaa :=int64 (1000);_dcde ._egfc .Seek (-_ceaa ,_df .SEEK_CUR );_bacea ,_befg :=_dcde ._egfc .Seek (0,_df .SEEK_CUR );if _befg !=nil {return 0,_befg ;};_fbbe :=make ([]byte ,_ceaa );_dcde ._egfc .Read (_fbbe );_gdaa :=_cdcee .FindAllStringIndex (string (_fbbe ),-1);if len (_gdaa )< 1{_cd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0065\u0070a\u0069\u0072\u003a\u0020\u0078\u0072\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021");return 0,_f .New ("\u0072\u0065\u0070\u0061ir\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064");};_afdea :=int64 (_gdaa [len (_gdaa )-1][0]);_bbfd :=_bacea +_afdea ;return _bbfd ,nil ;};

// SetIfNotNil sets the dictionary's key -> val mapping entry -IF- val is not nil.
// Note that we take care to perform a type switch.  Otherwise if we would supply a nil value
// of another type, e.g. (PdfObjectArray*)(nil), then it would not be a PdfObject(nil) and thus
// would get set.
func (_cbce *PdfObjectDictionary )SetIfNotNil (key PdfObjectName ,val PdfObject ){if val !=nil {switch _ggfg :=val .(type ){case *PdfObjectName :if _ggfg !=nil {_cbce .Set (key ,val );};case *PdfObjectDictionary :if _ggfg !=nil {_cbce .Set (key ,val );};case *PdfObjectStream :if _ggfg !=nil {_cbce .Set (key ,val );};case *PdfObjectString :if _ggfg !=nil {_cbce .Set (key ,val );};case *PdfObjectNull :if _ggfg !=nil {_cbce .Set (key ,val );};case *PdfObjectInteger :if _ggfg !=nil {_cbce .Set (key ,val );};case *PdfObjectArray :if _ggfg !=nil {_cbce .Set (key ,val );};case *PdfObjectBool :if _ggfg !=nil {_cbce .Set (key ,val );};case *PdfObjectFloat :if _ggfg !=nil {_cbce .Set (key ,val );};case *PdfObjectReference :if _ggfg !=nil {_cbce .Set (key ,val );};case *PdfIndirectObject :if _ggfg !=nil {_cbce .Set (key ,val );};default:_cd .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",val );};};};var _dfbe =_c .MustCompile ("\u0025P\u0044F\u002d\u0028\u005c\u0064\u0029\u005c\u002e\u0028\u005c\u0064\u0029");const _baaa =10;

// NewRunLengthEncoder makes a new run length encoder
func NewRunLengthEncoder ()*RunLengthEncoder {return &RunLengthEncoder {}};

// DecodeStream decodes a FlateEncoded stream object and give back decoded bytes.
func (_adc *FlateEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_cd .Log .Trace ("\u0046l\u0061t\u0065\u0044\u0065\u0063\u006fd\u0065\u0020s\u0074\u0072\u0065\u0061\u006d");_cd .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_adc .Predictor );if _adc .BitsPerComponent !=8{return nil ,_aa .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003d\u0025\u0064\u0020\u0028\u006f\u006e\u006c\u0079\u0020\u0038\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0029",_adc .BitsPerComponent );};_fac ,_dcca :=_adc .DecodeBytes (streamObj .Stream );if _dcca !=nil {return nil ,_dcca ;};_fac ,_dcca =_adc .postDecodePredict (_fac );if _dcca !=nil {return nil ,_dcca ;};return _adc .cleanImageData (_fac );};

// DrawableImage is same as golang image/draw's Image interface that allow drawing images.
type DrawableImage interface{ColorModel ()_ae .Model ;Bounds ()_cg .Rectangle ;At (_efagg ,_fcb int )_ae .Color ;Set (_dcfc ,_dcaf int ,_abab _ae .Color );};

// GetAsFloat64Slice returns the array as []float64 slice.
// Returns an error if not entirely numeric (only PdfObjectIntegers, PdfObjectFloats).
func (_fagec *PdfObjectArray )GetAsFloat64Slice ()([]float64 ,error ){var _aeece []float64 ;for _ ,_ccg :=range _fagec .Elements (){_acab ,_dfec :=GetNumberAsFloat (TraceToDirectObject (_ccg ));if _dfec !=nil {return nil ,_aa .Errorf ("\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006e\u0075m\u0062\u0065\u0072");};_aeece =append (_aeece ,_acab );};return _aeece ,nil ;};

// TraceToDirectObject traces a PdfObject to a direct object.  For example direct objects contained
// in indirect objects (can be double referenced even).
func TraceToDirectObject (obj PdfObject )PdfObject {if _efee ,_cdgd :=obj .(*PdfObjectReference );_cdgd {obj =_efee .Resolve ();};_gadg ,_ddcf :=obj .(*PdfIndirectObject );_geda :=0;for _ddcf {obj =_gadg .PdfObject ;_gadg ,_ddcf =GetIndirect (obj );_geda ++;if _geda > _baaa {_cd .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0072\u0061\u0063\u0065\u0020\u0064\u0065p\u0074\u0068\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u0062\u0065\u0079\u006fn\u0064\u0020\u0025\u0064\u0020\u002d\u0020\u006e\u006f\u0074\u0020\u0067oi\u006e\u0067\u0020\u0064\u0065\u0065\u0070\u0065\u0072\u0021",_baaa );return nil ;};};return obj ;};

// NewParser creates a new parser for a PDF file via ReadSeeker. Loads the cross reference stream and trailer.
// An error is returned on failure.
func NewParser (rs _gb .ReadSeeker )(*PdfParser ,error ){_cffb :=&PdfParser {_egfc :rs ,ObjCache :make (objectCache ),_dfda :map[int64 ]bool {}};_aaabd ,_bbgc ,_dcda :=_cffb .parsePdfVersion ();if _dcda !=nil {_cd .Log .Error ("U\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0076e\u0072\u0073\u0069o\u006e:\u0020\u0025\u0076",_dcda );return nil ,_dcda ;};_cffb ._dbcd .Major =_aaabd ;_cffb ._dbcd .Minor =_bbgc ;if _cffb ._agac ,_dcda =_cffb .loadXrefs ();_dcda !=nil {_cd .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020F\u0061\u0069\u006c\u0065d t\u006f l\u006f\u0061\u0064\u0020\u0078\u0072\u0065f \u0074\u0061\u0062\u006c\u0065\u0021\u0020%\u0073",_dcda );return nil ,_dcda ;};_cd .Log .Trace ("T\u0072\u0061\u0069\u006c\u0065\u0072\u003a\u0020\u0025\u0073",_cffb ._agac );if len (_cffb ._dgag .ObjectMap )==0{return nil ,_aa .Errorf ("\u0065\u006d\u0070\u0074\u0079\u0020\u0058\u0052\u0045\u0046\u0020t\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0049\u006e\u0076a\u006c\u0069\u0064");};return _cffb ,nil ;};

// Len returns the number of elements in the array.
func (_daad *PdfObjectArray )Len ()int {if _daad ==nil {return 0;};return len (_daad ._ddfca );};

// IsOctalDigit checks if a character can be part of an octal digit string.
func IsOctalDigit (c byte )bool {return '0'<=c &&c <='7'};

// String returns a string describing `streams`.
func (_ffab *PdfObjectStreams )String ()string {return _aa .Sprintf ("\u004f\u0062j\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0025\u0064",_ffab .ObjectNumber );};

// WriteString outputs the object as it is to be written to file.
func (_febg *PdfObjectReference )WriteString ()string {var _bdcda _ed .Builder ;_bdcda .WriteString (_d .FormatInt (_febg .ObjectNumber ,10));_bdcda .WriteString ("\u0020");_bdcda .WriteString (_d .FormatInt (_febg .GenerationNumber ,10));_bdcda .WriteString ("\u0020\u0052");return _bdcda .String ();};

// AddPageImage adds the page with the image 'img' to the encoder context in order to encode it jbig2 document.
// The 'settings' defines what encoding type should be used by the encoder.
func (_aggf *JBIG2Encoder )AddPageImage (img *JBIG2Image ,settings *JBIG2EncoderSettings )(_bbaa error ){const _gbgc ="\u004a\u0042\u0049\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0041\u0064\u0064\u0050\u0061\u0067\u0065\u0049m\u0061\u0067\u0065";if _aggf ==nil {return _cf .Error (_gbgc ,"J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u0020\u0069\u0073 n\u0069\u006c");};if settings ==nil {settings =&_aggf .DefaultPageSettings ;};if _aggf ._dggg ==nil {_aggf ._dggg =_ac .InitEncodeDocument (settings .FileMode );};if _bbaa =settings .Validate ();_bbaa !=nil {return _cf .Wrap (_bbaa ,_gbgc ,"");};_deeg ,_bbaa :=img .toBitmap ();if _bbaa !=nil {return _cf .Wrap (_bbaa ,_gbgc ,"");};switch settings .Compression {case JB2Generic :if _bbaa =_aggf ._dggg .AddGenericPage (_deeg ,settings .DuplicatedLinesRemoval );_bbaa !=nil {return _cf .Wrap (_bbaa ,_gbgc ,"");};case JB2SymbolCorrelation :return _cf .Error (_gbgc ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");case JB2SymbolRankHaus :return _cf .Error (_gbgc ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");default:return _cf .Error (_gbgc ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return nil ;};

// GetFilterName returns the name of the encoding filter.
func (_abef *JBIG2Encoder )GetFilterName ()string {return StreamEncodingFilterNameJBIG2 };

// GetFilterArray returns the names of the underlying encoding filters in an array that
// can be used as /Filter entry.
func (_bcca *MultiEncoder )GetFilterArray ()*PdfObjectArray {_bdff :=make ([]PdfObject ,len (_bcca ._egdf ));for _aceg ,_bfbb :=range _bcca ._egdf {_bdff [_aceg ]=MakeName (_bfbb .GetFilterName ());};return MakeArray (_bdff ...);};func (_dgae *PdfCrypt )decryptBytes (_gbcf []byte ,_befa string ,_adaf []byte )([]byte ,error ){_cd .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");_dgaec ,_ddb :=_dgae ._bee [_befa ];if !_ddb {return nil ,_aa .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_befa );};return _dgaec .DecryptBytes (_gbcf ,_adaf );};

// Version represents a version of a PDF standard.
type Version struct{Major int ;Minor int ;};

// PdfVersion returns version of the PDF file.
func (_fdbf *PdfParser )PdfVersion ()Version {return _fdbf ._dbcd };

// PdfObjectNull represents the primitive PDF null object.
type PdfObjectNull struct{};var (ErrUnsupportedEncodingParameters =_f .New ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074\u0065\u0072\u0073");ErrNoCCITTFaxDecode =_f .New ("\u0043\u0043I\u0054\u0054\u0046\u0061\u0078\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");ErrNoJBIG2Decode =_f .New ("\u004a\u0042\u0049\u0047\u0032\u0044\u0065c\u006f\u0064\u0065 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");ErrNoJPXDecode =_f .New ("\u004a\u0050\u0058\u0044\u0065c\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020i\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");ErrNoPdfVersion =_f .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");ErrTypeError =_f .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");ErrRangeError =_f .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");ErrNotSupported =_bc .New ("\u0066\u0065\u0061t\u0075\u0072\u0065\u0020n\u006f\u0074\u0020\u0063\u0075\u0072\u0072e\u006e\u0074\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");ErrNotANumber =_f .New ("\u006e\u006f\u0074 \u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072"););func (_bfc *PdfParser )lookupObjectViaOS (_dgg int ,_ab int )(PdfObject ,error ){var _cfe *_dgb .Reader ;var _ce objectStream ;var _ef bool ;_ce ,_ef =_bfc ._eadd [_dgg ];if !_ef {_gg ,_edg :=_bfc .LookupByNumber (_dgg );if _edg !=nil {_cd .Log .Debug ("\u004d\u0069ss\u0069\u006e\u0067 \u006f\u0062\u006a\u0065ct \u0073tr\u0065\u0061\u006d\u0020\u0077\u0069\u0074h \u006e\u0075\u006d\u0062\u0065\u0072\u0020%\u0064",_dgg );return nil ,_edg ;};_adf ,_fef :=_gg .(*PdfObjectStream );if !_fef {return nil ,_f .New ("i\u006e\u0076\u0061\u006cid\u0020o\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d");};if _bfc ._egc !=nil &&!_bfc ._egc .isDecrypted (_adf ){return nil ,_f .New ("\u006e\u0065\u0065\u0064\u0020\u0074\u006f\u0020\u0064\u0065\u0063r\u0079\u0070\u0074\u0020\u0074\u0068\u0065\u0020\u0073\u0074r\u0065\u0061\u006d");};_ga :=_adf .PdfObjectDictionary ;_cd .Log .Trace ("\u0073o\u0020\u0064\u003a\u0020\u0025\u0073\n",_ga .String ());_acb ,_fef :=_ga .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if !_fef {_cd .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0061\u006c\u0077\u0061\u0079\u0073\u0020\u0068\u0061\u0076\u0065\u0020\u0061\u0020\u0054\u0079\u0070\u0065");return nil ,_f .New ("\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020T\u0079\u0070\u0065");};if _ed .ToLower (string (*_acb ))!="\u006f\u0062\u006a\u0073\u0074\u006d"{_cd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0074\u0079\u0070\u0065\u0020s\u0068\u0061\u006c\u006c\u0020\u0061\u006c\u0077\u0061\u0079\u0073 \u0062\u0065\u0020\u004f\u0062\u006a\u0053\u0074\u006d\u0020\u0021");return nil ,_f .New ("\u006f\u0062\u006a\u0065c\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0074y\u0070e\u0020\u0021\u003d\u0020\u004f\u0062\u006aS\u0074\u006d");};N ,_fef :=_ga .Get ("\u004e").(*PdfObjectInteger );if !_fef {return nil ,_f .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u004e\u0020i\u006e\u0020\u0073\u0074\u0072\u0065\u0061m\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_da ,_fef :=_ga .Get ("\u0046\u0069\u0072s\u0074").(*PdfObjectInteger );if !_fef {return nil ,_f .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0046\u0069\u0072\u0073\u0074\u0020i\u006e \u0073t\u0072e\u0061\u006d\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_cd .Log .Trace ("\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0073\u0020\u006eu\u006d\u0062\u0065\u0072\u0020\u006f\u0066 \u006f\u0062\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_acb ,*N );_aeg ,_edg :=DecodeStream (_adf );if _edg !=nil {return nil ,_edg ;};_cd .Log .Trace ("D\u0065\u0063\u006f\u0064\u0065\u0064\u003a\u0020\u0025\u0073",_aeg );_bb :=_bfc .GetFileOffset ();defer func (){_bfc .SetFileOffset (_bb )}();_cfe =_dgb .NewReader (_aeg );_bfc ._bfbbd =_adg .NewReader (_cfe );_cd .Log .Trace ("\u0050a\u0072s\u0069\u006e\u0067\u0020\u006ff\u0066\u0073e\u0074\u0020\u006d\u0061\u0070");_abg :=map[int ]int64 {};for _gd :=0;_gd < int (*N );_gd ++{_bfc .skipSpaces ();_bgd ,_fg :=_bfc .parseNumber ();if _fg !=nil {return nil ,_fg ;};_bd ,_cc :=_bgd .(*PdfObjectInteger );if !_cc {return nil ,_f .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");};_bfc .skipSpaces ();_bgd ,_fg =_bfc .parseNumber ();if _fg !=nil {return nil ,_fg ;};_dga ,_cc :=_bgd .(*PdfObjectInteger );if !_cc {return nil ,_f .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");};_cd .Log .Trace ("\u006f\u0062j\u0020\u0025\u0064 \u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0025\u0064",*_bd ,*_dga );_abg [int (*_bd )]=int64 (*_da +*_dga );};_ce =objectStream {N :int (*N ),_cab :_aeg ,_bf :_abg };_bfc ._eadd [_dgg ]=_ce ;}else {_dfa :=_bfc .GetFileOffset ();defer func (){_bfc .SetFileOffset (_dfa )}();_cfe =_dgb .NewReader (_ce ._cab );_bfc ._bfbbd =_adg .NewReader (_cfe );};_ced :=_ce ._bf [_ab ];_cd .Log .Trace ("\u0041\u0043\u0054\u0055AL\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u005b\u0025\u0064\u005d\u0020\u003d\u0020%\u0064",_ab ,_ced );_cfe .Seek (_ced ,_df .SEEK_SET );_bfc ._bfbbd =_adg .NewReader (_cfe );_ge ,_ :=_bfc ._bfbbd .Peek (100);_cd .Log .Trace ("\u004f\u0042\u004a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_ge ));_de ,_ea :=_bfc .parseObject ();if _ea !=nil {_cd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c \u0074\u006f\u0020\u0072\u0065\u0061\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_ea );return nil ,_ea ;};if _de ==nil {return nil ,_f .New ("o\u0062\u006a\u0065\u0063t \u0063a\u006e\u006e\u006f\u0074\u0020b\u0065\u0020\u006e\u0075\u006c\u006c");};_cga :=PdfIndirectObject {};_cga .ObjectNumber =int64 (_ab );_cga .PdfObject =_de ;return &_cga ,nil ;};func (_caec *PdfParser )readComment ()(string ,error ){var _ggaf _dgb .Buffer ;_ ,_afcf :=_caec .skipSpaces ();if _afcf !=nil {return _ggaf .String (),_afcf ;};_fded :=true ;for {_ebfa ,_ddga :=_caec ._bfbbd .Peek (1);if _ddga !=nil {_cd .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_ddga .Error ());return _ggaf .String (),_ddga ;};if _fded &&_ebfa [0]!='%'{return _ggaf .String (),_f .New ("c\u006f\u006d\u006d\u0065\u006e\u0074 \u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0073\u0074a\u0072\u0074\u0020w\u0069t\u0068\u0020\u0025");};_fded =false ;if (_ebfa [0]!='\r')&&(_ebfa [0]!='\n'){_bfaf ,_ :=_caec ._bfbbd .ReadByte ();_ggaf .WriteByte (_bfaf );}else {break ;};};return _ggaf .String (),nil ;};const _dfag =32<<(^uint (0)>>63);func _bdea (_dgbbe _gb .ReadSeeker ,_egfg int64 )(*offsetReader ,error ){_gffec :=&offsetReader {_daef :_dgbbe ,_efba :_egfg };_ ,_acdf :=_gffec .Seek (0,_gb .SeekStart );return _gffec ,_acdf ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_abfg *ASCIIHexEncoder )MakeDecodeParams ()PdfObject {return nil };

// RunLengthEncoder represents Run length encoding.
type RunLengthEncoder struct{};func (_agcg *PdfParser )parseBool ()(PdfObjectBool ,error ){_dgce ,_eaadca :=_agcg ._bfbbd .Peek (4);if _eaadca !=nil {return PdfObjectBool (false ),_eaadca ;};if (len (_dgce )>=4)&&(string (_dgce [:4])=="\u0074\u0072\u0075\u0065"){_agcg ._bfbbd .Discard (4);return PdfObjectBool (true ),nil ;};_dgce ,_eaadca =_agcg ._bfbbd .Peek (5);if _eaadca !=nil {return PdfObjectBool (false ),_eaadca ;};if (len (_dgce )>=5)&&(string (_dgce [:5])=="\u0066\u0061\u006cs\u0065"){_agcg ._bfbbd .Discard (5);return PdfObjectBool (false ),nil ;};return PdfObjectBool (false ),_f .New ("\u0075n\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0062o\u006fl\u0065a\u006e\u0020\u0073\u0074\u0072\u0069\u006eg");};const (_acced =0;_bgeb =1;_ffbf =2;_gfd =3;_dcb =4;);

// String returns a string describing `ref`.
func (_acbcb *PdfObjectReference )String ()string {return _aa .Sprintf ("\u0052\u0065\u0066\u0028\u0025\u0064\u0020\u0025\u0064\u0029",_acbcb .ObjectNumber ,_acbcb .GenerationNumber );};

// EncryptInfo contains an information generated by the document encrypter.
type EncryptInfo struct{Version ;

// Encrypt is an encryption dictionary that contains all necessary parameters.
// It should be stored in all copies of the document trailer.
Encrypt *PdfObjectDictionary ;

// ID0 and ID1 are IDs used in the trailer. Older algorithms such as RC4 uses them for encryption.
ID0 ,ID1 string ;};func (_gcgc *FlateEncoder )cleanImageData (_dfd []byte )([]byte ,error ){if _gcgc ._adead ==nil {return _dfd ,nil ;};if _gcgc ._adead .BitsPerComponent >=8{return _dfd ,nil ;};_degc :=_gcgc ._adead .BitsPerComponent *_gcgc ._adead .Width *_gcgc ._adead .ColorComponents *_gcgc ._adead .Height /8;_dfd =_dfd [:_degc ];var _afce error ;_dfd ,_afce =_ada .AddDataPadding (_gcgc ._adead .Width ,_gcgc ._adead .Height ,_gcgc ._adead .BitsPerComponent ,_gcgc ._adead .ColorComponents ,_dfd );if _afce !=nil {return nil ,_afce ;};return _dfd ,nil ;};func _aag (_acbd *_dd .StdEncryptDict ,_fgc *PdfObjectDictionary )error {R ,_gfce :=_fgc .Get ("\u0052").(*PdfObjectInteger );if !_gfce {return _f .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0052");};if *R < 2||*R > 6{return _aa .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0052 \u0028\u0025\u0064\u0029",*R );};_acbd .R =int (*R );O ,_gfce :=_fgc .GetString ("\u004f");if !_gfce {return _f .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u004f");};if _acbd .R ==5||_acbd .R ==6{if len (O )< 48{return _aa .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u004f\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (O ));};}else if len (O )!=32{return _aa .Errorf ("L\u0065n\u0067\u0074\u0068\u0028\u004f\u0029\u0020\u0021=\u0020\u0033\u0032\u0020(%\u0064\u0029",len (O ));};_acbd .O =[]byte (O );U ,_gfce :=_fgc .GetString ("\u0055");if !_gfce {return _f .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0055");};if _acbd .R ==5||_acbd .R ==6{if len (U )< 48{return _aa .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u0055\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (U ));};}else if len (U )!=32{_cd .Log .Debug ("\u0057\u0061r\u006e\u0069\u006e\u0067\u003a\u0020\u004c\u0065\u006e\u0067\u0074\u0068\u0028\u0055\u0029\u0020\u0021\u003d\u0020\u0033\u0032\u0020(%\u0064\u0029",len (U ));};_acbd .U =[]byte (U );if _acbd .R >=5{OE ,_gbcg :=_fgc .GetString ("\u004f\u0045");if !_gbcg {return _f .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u004f\u0045");}else if len (OE )!=32{return _aa .Errorf ("L\u0065\u006e\u0067\u0074h(\u004fE\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (OE ));};_acbd .OE =[]byte (OE );UE ,_gbcg :=_fgc .GetString ("\u0055\u0045");if !_gbcg {return _f .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u0055\u0045");}else if len (UE )!=32{return _aa .Errorf ("L\u0065\u006e\u0067\u0074h(\u0055E\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (UE ));};_acbd .UE =[]byte (UE );};P ,_gfce :=_fgc .Get ("\u0050").(*PdfObjectInteger );if !_gfce {return _f .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074 \u0064\u0069\u0063t\u0069\u006f\u006e\u0061r\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0070\u0065\u0072\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0061\u0074\u0074\u0072");};_acbd .P =_dd .Permissions (*P );if _acbd .R ==6{Perms ,_efd :=_fgc .GetString ("\u0050\u0065\u0072m\u0073");if !_efd {return _f .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0050\u0065\u0072\u006d\u0073");}else if len (Perms )!=16{return _aa .Errorf ("\u004ce\u006e\u0067\u0074\u0068\u0028\u0050\u0065\u0072\u006d\u0073\u0029 \u0021\u003d\u0020\u0031\u0036\u0020\u0028\u0025\u0064\u0029",len (Perms ));};_acbd .Perms =[]byte (Perms );};if _cea ,_dab :=_fgc .Get ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061").(*PdfObjectBool );_dab {_acbd .EncryptMetadata =bool (*_cea );}else {_acbd .EncryptMetadata =true ;};return nil ;};

// MakeStringFromBytes creates an PdfObjectString from a byte array.
// This is more natural than MakeString as `data` is usually not utf-8 encoded.
func MakeStringFromBytes (data []byte )*PdfObjectString {return MakeString (string (data ))};var _cdf =[]PdfObjectName {"\u0056","\u0052","\u004f","\u0055","\u0050"};

// DecodeStream returns the passed in stream as a slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_edfe *RawEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return streamObj .Stream ,nil ;};func (_abgg *PdfParser )repairRebuildXrefsTopDown ()(*XrefTable ,error ){if _abgg ._fffe {return nil ,_aa .Errorf ("\u0072\u0065\u0070\u0061\u0069\u0072\u0020\u0066\u0061\u0069\u006c\u0065\u0064");};_abgg ._fffe =true ;_abgg ._egfc .Seek (0,_df .SEEK_SET );_abgg ._bfbbd =_adg .NewReader (_abgg ._egfc );_faegb :=20;_cgdf :=make ([]byte ,_faegb );_fgdg :=XrefTable {};_fgdg .ObjectMap =make (map[int ]XrefObject );for {_cggaf ,_aebg :=_abgg ._bfbbd .ReadByte ();if _aebg !=nil {if _aebg ==_gb .EOF {break ;}else {return nil ,_aebg ;};};if _cggaf =='j'&&_cgdf [_faegb -1]=='b'&&_cgdf [_faegb -2]=='o'&&IsWhiteSpace (_cgdf [_faegb -3]){_afcdc :=_faegb -4;for IsWhiteSpace (_cgdf [_afcdc ])&&_afcdc > 0{_afcdc --;};if _afcdc ==0||!IsDecimalDigit (_cgdf [_afcdc ]){continue ;};for IsDecimalDigit (_cgdf [_afcdc ])&&_afcdc > 0{_afcdc --;};if _afcdc ==0||!IsWhiteSpace (_cgdf [_afcdc ]){continue ;};for IsWhiteSpace (_cgdf [_afcdc ])&&_afcdc > 0{_afcdc --;};if _afcdc ==0||!IsDecimalDigit (_cgdf [_afcdc ]){continue ;};for IsDecimalDigit (_cgdf [_afcdc ])&&_afcdc > 0{_afcdc --;};if _afcdc ==0{continue ;};_gaeaea :=_abgg .GetFileOffset ()-int64 (_faegb -_afcdc );_cebe :=append (_cgdf [_afcdc +1:],_cggaf );_dfgb ,_gbbe ,_ddgg :=_cdbdb (string (_cebe ));if _ddgg !=nil {_cd .Log .Debug ("\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u006e\u0075\u006d\u0062\u0065r\u003a\u0020\u0025\u0076",_ddgg );return nil ,_ddgg ;};if _cfdb ,_eedc :=_fgdg .ObjectMap [_dfgb ];!_eedc ||_cfdb .Generation < _gbbe {_ccgf :=XrefObject {};_ccgf .XType =XrefTypeTableEntry ;_ccgf .ObjectNumber =int (_dfgb );_ccgf .Generation =int (_gbbe );_ccgf .Offset =_gaeaea ;_fgdg .ObjectMap [_dfgb ]=_ccgf ;};};_cgdf =append (_cgdf [1:_faegb ],_cggaf );};return &_fgdg ,nil ;};

// WriteString outputs the object as it is to be written to file.
func (_aebf *PdfObjectStreams )WriteString ()string {var _ddaa _ed .Builder ;_ddaa .WriteString (_d .FormatInt (_aebf .ObjectNumber ,10));_ddaa .WriteString ("\u0020\u0030\u0020\u0052");return _ddaa .String ();};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_bgaef *ASCIIHexEncoder )MakeStreamDict ()*PdfObjectDictionary {_fgde :=MakeDict ();_fgde .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_bgaef .GetFilterName ()));return _fgde ;};

// UpdateParams updates the parameter values of the encoder.
// Implements StreamEncoder interface.
func (_cddb *JBIG2Encoder )UpdateParams (params *PdfObjectDictionary ){_acd ,_fgee :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _fgee ==nil {_cddb .BitsPerComponent =int (_acd );};_dgga ,_fgee :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _fgee ==nil {_cddb .Width =int (_dgga );};_baeg ,_fgee :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _fgee ==nil {_cddb .Height =int (_baeg );};_dffbd ,_fgee :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _fgee ==nil {_cddb .ColorComponents =int (_dffbd );};};func (_bdde *PdfParser )loadXrefs ()(*PdfObjectDictionary ,error ){_bdde ._dgag .ObjectMap =make (map[int ]XrefObject );_bdde ._eadd =make (objectStreams );_ecbc ,_bcae :=_bdde ._egfc .Seek (0,_gb .SeekEnd );if _bcae !=nil {return nil ,_bcae ;};_cd .Log .Trace ("\u0066s\u0069\u007a\u0065\u003a\u0020\u0025d",_ecbc );_bdde ._geef =_ecbc ;_bcae =_bdde .seekToEOFMarker (_ecbc );if _bcae !=nil {_cd .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0073\u0065\u0065\u006b\u0020\u0074\u006f\u0020\u0065\u006f\u0066\u0020\u006d\u0061\u0072\u006b\u0065\u0072: \u0025\u0076",_bcae );return nil ,_bcae ;};_dffab ,_bcae :=_bdde ._egfc .Seek (0,_gb .SeekCurrent );if _bcae !=nil {return nil ,_bcae ;};var _bceb int64 =64;_gedd :=_dffab -_bceb ;if _gedd < 0{_gedd =0;};_ ,_bcae =_bdde ._egfc .Seek (_gedd ,_gb .SeekStart );if _bcae !=nil {return nil ,_bcae ;};_daeae :=make ([]byte ,_bceb );_ ,_bcae =_bdde ._egfc .Read (_daeae );if _bcae !=nil {_cd .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u003a\u0020\u0025\u0076",_bcae );return nil ,_bcae ;};_dafb :=_aegd .FindStringSubmatch (string (_daeae ));if len (_dafb )< 2{_cd .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020n\u006f\u0074\u0020f\u006fu\u006e\u0064\u0021");return nil ,_f .New ("\u0073\u0074\u0061\u0072tx\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};if len (_dafb )> 2{_cd .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u004du\u006c\u0074\u0069\u0070\u006c\u0065\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029\u0021",_daeae );return nil ,_f .New ("m\u0075\u006c\u0074\u0069\u0070\u006ce\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065f\u0020\u0065\u006et\u0072i\u0065\u0073\u003f");};_cgba ,_ :=_d .ParseInt (_dafb [1],10,64);_cd .Log .Trace ("\u0073t\u0061r\u0074\u0078\u0072\u0065\u0066\u0020\u0061\u0074\u0020\u0025\u0064",_cgba );if _cgba > _ecbc {_cd .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u006f\u0066f\u0073e\u0074 \u006fu\u0074\u0073\u0069\u0064\u0065\u0020\u006f\u0066\u0020\u0066\u0069\u006c\u0065");_cd .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0072e\u0070\u0061\u0069\u0072");_cgba ,_bcae =_bdde .repairLocateXref ();if _bcae !=nil {_cd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0052\u0065\u0070\u0061\u0069\u0072\u0020\u0061\u0074\u0074\u0065\u006d\u0070t\u0020\u0066\u0061\u0069\u006c\u0065\u0064 \u0028\u0025\u0073\u0029");return nil ,_bcae ;};};_bdde ._egfc .Seek (int64 (_cgba ),_gb .SeekStart );_bdde ._bfbbd =_adg .NewReader (_bdde ._egfc );_egce ,_bcae :=_bdde .parseXref ();if _bcae !=nil {return nil ,_bcae ;};_cega :=_egce .Get ("\u0058R\u0065\u0066\u0053\u0074\u006d");if _cega !=nil {_bcgd ,_debee :=_cega .(*PdfObjectInteger );if !_debee {return nil ,_f .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0021=\u0020\u0069\u006e\u0074");};_ ,_bcae =_bdde .parseXrefStream (_bcgd );if _bcae !=nil {return nil ,_bcae ;};};var _eecf []int64 ;_gdbb :=func (_bbdee int64 ,_bafc []int64 )bool {for _ ,_gfgf :=range _bafc {if _gfgf ==_bbdee {return true ;};};return false ;};_cega =_egce .Get ("\u0050\u0072\u0065\u0076");for _cega !=nil {_baffg ,_agfea :=_cega .(*PdfObjectInteger );if !_agfea {_cd .Log .Debug ("\u0049\u006ev\u0061\u006c\u0069\u0064\u0020P\u0072\u0065\u0076\u0020\u0072e\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u003a\u0020\u004e\u006f\u0074\u0020\u0061\u0020\u002a\u0050\u0064\u0066\u004f\u0062\u006a\u0065\u0063\u0074\u0049\u006e\u0074\u0065\u0067\u0065\u0072\u0020\u0028\u0025\u0054\u0029",_cega );return _egce ,nil ;};_bddg :=*_baffg ;_cd .Log .Trace ("\u0041\u006eot\u0068\u0065\u0072 \u0050\u0072\u0065\u0076 xr\u0065f \u0074\u0061\u0062\u006c\u0065\u0020\u006fbj\u0065\u0063\u0074\u0020\u0061\u0074\u0020%\u0064",_bddg );_bdde ._egfc .Seek (int64 (_bddg ),_df .SEEK_SET );_bdde ._bfbbd =_adg .NewReader (_bdde ._egfc );_dbaea ,_dgca :=_bdde .parseXref ();if _dgca !=nil {_cd .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0045\u0072\u0072\u006f\u0072\u0020-\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u0061\u0064\u0069n\u0067\u0020\u0061\u006e\u006f\u0074\u0068\u0065\u0072\u0020\u0028\u0050re\u0076\u0029\u0020\u0074\u0072\u0061\u0069\u006c\u0065\u0072");_cd .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0063\u006f\u006e\u0074\u0069n\u0075\u0065\u0020\u0062\u0079\u0020\u0069\u0067\u006e\u006f\u0072\u0069n\u0067\u0020\u0069\u0074");break ;};_cega =_dbaea .Get ("\u0050\u0072\u0065\u0076");if _cega !=nil {_fdce :=*(_cega .(*PdfObjectInteger ));if _gdbb (int64 (_fdce ),_eecf ){_cd .Log .Debug ("\u0050\u0072ev\u0065\u006e\u0074i\u006e\u0067\u0020\u0063irc\u0075la\u0072\u0020\u0078\u0072\u0065\u0066\u0020re\u0066\u0065\u0072\u0065\u006e\u0063\u0069n\u0067");break ;};_eecf =append (_eecf ,int64 (_fdce ));};};return _egce ,nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_afef *MultiEncoder )MakeStreamDict ()*PdfObjectDictionary {_cgafg :=MakeDict ();_cgafg .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",_afef .GetFilterArray ());for _ ,_gfeg :=range _afef ._egdf {_ebg :=_gfeg .MakeStreamDict ();for _ ,_egf :=range _ebg .Keys (){_fdac :=_ebg .Get (_egf );if _egf !="\u0046\u0069\u006c\u0074\u0065\u0072"&&_egf !="D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"{_cgafg .Set (_egf ,_fdac );};};};_fggg :=_afef .MakeDecodeParams ();if _fggg !=nil {_cgafg .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_fggg );};return _cgafg ;};func _agfcd (_bfgf ,_eebgc PdfObject ,_abcgf int )bool {if _abcgf > _baaa {_cd .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_baaa );return false ;};if _bfgf ==nil &&_eebgc ==nil {return true ;}else if _bfgf ==nil ||_eebgc ==nil {return false ;};if _fa .TypeOf (_bfgf )!=_fa .TypeOf (_eebgc ){return false ;};switch _gdef :=_bfgf .(type ){case *PdfObjectNull ,*PdfObjectReference :return true ;case *PdfObjectName :return *_gdef ==*(_eebgc .(*PdfObjectName ));case *PdfObjectString :return *_gdef ==*(_eebgc .(*PdfObjectString ));case *PdfObjectInteger :return *_gdef ==*(_eebgc .(*PdfObjectInteger ));case *PdfObjectBool :return *_gdef ==*(_eebgc .(*PdfObjectBool ));case *PdfObjectFloat :return *_gdef ==*(_eebgc .(*PdfObjectFloat ));case *PdfIndirectObject :return _agfcd (TraceToDirectObject (_bfgf ),TraceToDirectObject (_eebgc ),_abcgf +1);case *PdfObjectArray :_ccbe :=_eebgc .(*PdfObjectArray );if len ((*_gdef )._ddfca )!=len ((*_ccbe )._ddfca ){return false ;};for _cgcdb ,_aeea :=range (*_gdef )._ddfca {if !_agfcd (_aeea ,(*_ccbe )._ddfca [_cgcdb ],_abcgf +1){return false ;};};return true ;case *PdfObjectDictionary :_addeg :=_eebgc .(*PdfObjectDictionary );_gbea ,_ddeb :=(*_gdef )._bacc ,(*_addeg )._bacc ;if len (_gbea )!=len (_ddeb ){return false ;};for _egag ,_cagdb :=range _gbea {_dafg ,_ecba :=_ddeb [_egag ];if !_ecba ||!_agfcd (_cagdb ,_dafg ,_abcgf +1){return false ;};};return true ;case *PdfObjectStream :_bbcd :=_eebgc .(*PdfObjectStream );return _agfcd ((*_gdef ).PdfObjectDictionary ,(*_bbcd ).PdfObjectDictionary ,_abcgf +1);default:_cd .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",_bfgf );};return false ;};

// MakeBool creates a PdfObjectBool from a bool value.
func MakeBool (val bool )*PdfObjectBool {_ffba :=PdfObjectBool (val );return &_ffba };

// ResolveReferencesDeep recursively traverses through object `o`, looking up and replacing
// references with indirect objects.
// Optionally a map of already deep-resolved objects can be provided via `traversed`. The `traversed` map
// is updated while traversing the objects to avoid traversing same objects multiple times.
func ResolveReferencesDeep (o PdfObject ,traversed map[PdfObject ]struct{})error {if traversed ==nil {traversed =map[PdfObject ]struct{}{};};return _babg (o ,0,traversed );};

// GetStringBytes is like GetStringVal except that it returns the string as a []byte.
// It is for convenience.
func GetStringBytes (obj PdfObject )(_ccbd []byte ,_dega bool ){_fgfdd ,_dega :=TraceToDirectObject (obj ).(*PdfObjectString );if _dega {return _fgfdd .Bytes (),true ;};return ;};

// GetAccessPermissions returns the PDF access permissions as an AccessPermissions object.
func (_deef *PdfCrypt )GetAccessPermissions ()_dd .Permissions {return _deef ._cgd .P };

// GetString returns the *PdfObjectString represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetString (obj PdfObject )(_ddce *PdfObjectString ,_gdbbf bool ){_ddce ,_gdbbf =TraceToDirectObject (obj ).(*PdfObjectString );return _ddce ,_gdbbf ;};

// DecodeStream decodes a multi-encoded stream by passing it through the
// DecodeStream method of the underlying encoders.
func (_gbdad *MultiEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _gbdad .DecodeBytes (streamObj .Stream );};var _cedd =_c .MustCompile ("\u005e\u005b\\\u002b\u002d\u002e\u005d*\u0028\u005b0\u002d\u0039\u002e\u005d\u002b\u0029\u005b\u0065E\u005d\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");

// GetFloatVal returns the float64 value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetFloatVal (obj PdfObject )(_bggc float64 ,_febfa bool ){_egfab ,_febfa :=TraceToDirectObject (obj ).(*PdfObjectFloat );if _febfa {return float64 (*_egfab ),true ;};return 0,false ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_beff *JBIG2Encoder )MakeStreamDict ()*PdfObjectDictionary {_ebbg :=MakeDict ();_ebbg .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_beff .GetFilterName ()));return _ebbg ;};func _cdbdb (_dfccf string )(int ,int ,error ){_aefcg :=_geeb .FindStringSubmatch (_dfccf );if len (_aefcg )< 3{return 0,0,_f .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");};_bcdab ,_ :=_d .Atoi (_aefcg [1]);_agfd ,_ :=_d .Atoi (_aefcg [2]);return _bcdab ,_agfd ,nil ;};

// GetXrefType returns the type of the first xref object (table or stream).
func (_gabe *PdfParser )GetXrefType ()*xrefType {return _gabe ._eaea };type objectStream struct{N int ;_cab []byte ;_bf map[int ]int64 ;};func _fab (_adge *_dd .StdEncryptDict ,_bcd *PdfObjectDictionary ){_bcd .Set ("\u0052",MakeInteger (int64 (_adge .R )));_bcd .Set ("\u0050",MakeInteger (int64 (_adge .P )));_bcd .Set ("\u004f",MakeStringFromBytes (_adge .O ));_bcd .Set ("\u0055",MakeStringFromBytes (_adge .U ));if _adge .R >=5{_bcd .Set ("\u004f\u0045",MakeStringFromBytes (_adge .OE ));_bcd .Set ("\u0055\u0045",MakeStringFromBytes (_adge .UE ));_bcd .Set ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061",MakeBool (_adge .EncryptMetadata ));if _adge .R > 5{_bcd .Set ("\u0050\u0065\u0072m\u0073",MakeStringFromBytes (_adge .Perms ));};};};func (_cafc *PdfParser )parseXrefTable ()(*PdfObjectDictionary ,error ){var _cbed *PdfObjectDictionary ;_degb ,_faddb :=_cafc .readTextLine ();if _faddb !=nil {return nil ,_faddb ;};_cd .Log .Trace ("\u0078\u0072\u0065\u0066 f\u0069\u0072\u0073\u0074\u0020\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_degb );_ebgf :=-1;_gfegg :=0;_gadd :=false ;_dgafd :="";for {_cafc .skipSpaces ();_ ,_efdce :=_cafc ._bfbbd .Peek (1);if _efdce !=nil {return nil ,_efdce ;};_degb ,_efdce =_cafc .readTextLine ();if _efdce !=nil {return nil ,_efdce ;};_eaga :=_agfa .FindStringSubmatch (_degb );if len (_eaga )==0{_debfa :=len (_dgafd )> 0;_dgafd +=_degb +"\u000a";if _debfa {_eaga =_agfa .FindStringSubmatch (_dgafd );};};if len (_eaga )==3{_aefc ,_ :=_d .Atoi (_eaga [1]);_cgce ,_ :=_d .Atoi (_eaga [2]);_ebgf =_aefc ;_gfegg =_cgce ;_gadd =true ;_dgafd ="";_cd .Log .Trace ("\u0078r\u0065\u0066 \u0073\u0075\u0062s\u0065\u0063\u0074\u0069\u006f\u006e\u003a \u0066\u0069\u0072\u0073\u0074\u0020o\u0062\u006a\u0065\u0063\u0074\u003a\u0020\u0025\u0064\u0020\u006fb\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_ebgf ,_gfegg );continue ;};_bgcd :=_eeae .FindStringSubmatch (_degb );if len (_bgcd )==4{if _gadd ==false {_cd .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0058r\u0065\u0066\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u006fr\u006da\u0074\u0021\u000a");return nil ,_f .New ("\u0078\u0072\u0065\u0066 i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072\u006d\u0061\u0074");};_dedb ,_ :=_d .ParseInt (_bgcd [1],10,64);_gfdc ,_ :=_d .Atoi (_bgcd [2]);_bfbc :=_bgcd [3];_dgafd ="";if _ed .ToLower (_bfbc )=="\u006e"&&_dedb > 1{_eaef ,_bfgc :=_cafc ._dgag .ObjectMap [_ebgf ];if !_bfgc ||_gfdc > _eaef .Generation {_egge :=XrefObject {ObjectNumber :_ebgf ,XType :XrefTypeTableEntry ,Offset :_dedb ,Generation :_gfdc };_cafc ._dgag .ObjectMap [_ebgf ]=_egge ;};};_ebgf ++;continue ;};if (len (_degb )> 6)&&(_degb [:7]=="\u0074r\u0061\u0069\u006c\u0065\u0072"){_cd .Log .Trace ("\u0046o\u0075n\u0064\u0020\u0074\u0072\u0061i\u006c\u0065r\u0020\u002d\u0020\u0025\u0073",_degb );if len (_degb )> 9{_gfga :=_cafc .GetFileOffset ();_cafc .SetFileOffset (_gfga -int64 (len (_degb ))+7);};_cafc .skipSpaces ();_cafc .skipComments ();_cd .Log .Trace ("R\u0065\u0061\u0064\u0069ng\u0020t\u0072\u0061\u0069\u006c\u0065r\u0020\u0064\u0069\u0063\u0074\u0021");_cd .Log .Trace ("\u0070\u0065\u0065\u006b\u003a\u0020\u0022\u0025\u0073\u0022",_degb );_cbed ,_efdce =_cafc .ParseDict ();_cd .Log .Trace ("\u0045O\u0046\u0020\u0072\u0065a\u0064\u0069\u006e\u0067\u0020t\u0072a\u0069l\u0065\u0072\u0020\u0064\u0069\u0063\u0074!");if _efdce !=nil {_cd .Log .Debug ("\u0045\u0072\u0072o\u0072\u0020\u0070\u0061r\u0073\u0069\u006e\u0067\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u0064\u0069\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_efdce );return nil ,_efdce ;};break ;};if _degb =="\u0025\u0025\u0045O\u0046"{_cd .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006e\u0064 \u006f\u0066\u0020\u0066\u0069\u006c\u0065 -\u0020\u0074\u0072\u0061i\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066ou\u006e\u0064 \u002d\u0020\u0065\u0072\u0072\u006f\u0072\u0021");return nil ,_f .New ("\u0065\u006e\u0064 \u006f\u0066\u0020\u0066i\u006c\u0065\u0020\u002d\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};_cd .Log .Trace ("\u0078\u0072\u0065\u0066\u0020\u006d\u006f\u0072\u0065 \u003a\u0020\u0025\u0073",_degb );};_cd .Log .Trace ("\u0045\u004f\u0046 p\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0021");if _cafc ._eaea ==nil {_abaa :=XrefTypeTableEntry ;_cafc ._eaea =&_abaa ;};return _cbed ,nil ;};

// String returns a string representation of `name`.
func (_aabd *PdfObjectName )String ()string {return string (*_aabd )};var _cdcee =_c .MustCompile ("\u005b\\\u0072\u005c\u006e\u005d\u005c\u0073\u002a\u0028\u0078\u0072\u0065f\u0029\u005c\u0073\u002a\u005b\u005c\u0072\u005c\u006e\u005d");

// DecodeStream implements ASCII85 stream decoding.
func (_fgbf *ASCII85Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _fgbf .DecodeBytes (streamObj .Stream );};

// GetFilterName returns the name of the encoding filter.
func (_gefe *RunLengthEncoder )GetFilterName ()string {return StreamEncodingFilterNameRunLength };func (_gfaf *PdfParser )parseArray ()(*PdfObjectArray ,error ){_ccbb :=MakeArray ();_gfaf ._bfbbd .ReadByte ();for {_gfaf .skipSpaces ();_gcdb ,_caee :=_gfaf ._bfbbd .Peek (1);if _caee !=nil {return _ccbb ,_caee ;};if _gcdb [0]==']'{_gfaf ._bfbbd .ReadByte ();break ;};_cgdg ,_caee :=_gfaf .parseObject ();if _caee !=nil {return _ccbb ,_caee ;};_ccbb .Append (_cgdg );};return _ccbb ,nil ;};func (_efcgg *offsetReader )Read (p []byte )(_egfa int ,_bcdf error ){return _efcgg ._daef .Read (p )};

// Decrypt attempts to decrypt the PDF file with a specified password.  Also tries to
// decrypt with an empty password.  Returns true if successful, false otherwise.
// An error is returned when there is a problem with decrypting.
func (_bdbe *PdfParser )Decrypt (password []byte )(bool ,error ){if _bdbe ._egc ==nil {return false ,_f .New ("\u0063\u0068\u0065\u0063k \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u0069\u0072s\u0074");};_caca ,_ceae :=_bdbe ._egc .authenticate (password );if _ceae !=nil {return false ,_ceae ;};if !_caca {_caca ,_ceae =_bdbe ._egc .authenticate ([]byte (""));};return _caca ,_ceae ;};

// GetXrefTable returns the PDFs xref table.
func (_addea *PdfParser )GetXrefTable ()XrefTable {return _addea ._dgag };

// MakeNull creates an PdfObjectNull.
func MakeNull ()*PdfObjectNull {_efcgd :=PdfObjectNull {};return &_efcgd };

// MakeDecodeParams makes a new instance of an encoding dictionary based on the current encoder settings.
func (_fdgd *JBIG2Encoder )MakeDecodeParams ()PdfObject {return MakeDict ()};func (_aaga *ASCII85Encoder )base256Tobase85 (_bdce uint32 )[5]byte {_gefa :=[5]byte {0,0,0,0,0};_bfga :=_bdce ;for _fedf :=0;_fedf < 5;_fedf ++{_ace :=uint32 (1);for _dacc :=0;_dacc < 4-_fedf ;_dacc ++{_ace *=85;};_efab :=_bfga /_ace ;_bfga =_bfga %_ace ;_gefa [_fedf ]=byte (_efab );};return _gefa ;};func (_gbdadd *offsetReader )Seek (offset int64 ,whence int )(int64 ,error ){if whence ==_gb .SeekStart {offset +=_gbdadd ._efba ;};_cggbe ,_febe :=_gbdadd ._daef .Seek (offset ,whence );if _febe !=nil {return _cggbe ,_febe ;};if whence ==_gb .SeekCurrent {_cggbe -=_gbdadd ._efba ;};if _cggbe < 0{return 0,_f .New ("\u0063\u006f\u0072\u0065\u002eo\u0066\u0066\u0073\u0065\u0074\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053e\u0065\u006b\u003a\u0020\u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e");};return _cggbe ,nil ;};

// Len returns the number of elements in the streams.
func (_fbbb *PdfObjectStreams )Len ()int {if _fbbb ==nil {return 0;};return len (_fbbb ._gcdd );};

// String returns the PDF version as a string. Implements interface fmt.Stringer.
func (_bbdf Version )String ()string {return _aa .Sprintf ("\u00250\u0064\u002e\u0025\u0030\u0064",_bbdf .Major ,_bbdf .Minor );};

// GetString is a helper for Get that returns a string value.
// Returns false if the key is missing or a value is not a string.
func (_edafd *PdfObjectDictionary )GetString (key PdfObjectName )(string ,bool ){_gcgcb ,_bdga :=_edafd ._bacc [key ].(*PdfObjectString );if !_bdga {return "",false ;};return _gcgcb .Str (),true ;};

// GetCrypter returns the PdfCrypt instance which has information about the PDFs encryption.
func (_dfad *PdfParser )GetCrypter ()*PdfCrypt {return _dfad ._egc };

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_dbec *ASCII85Encoder )MakeDecodeParams ()PdfObject {return nil };func (_gbff *PdfParser )parseNull ()(PdfObjectNull ,error ){_ ,_bcce :=_gbff ._bfbbd .Discard (4);return PdfObjectNull {},_bcce ;};func (_aead *PdfParser )traceStreamLength (_ffc PdfObject )(PdfObject ,error ){_cceac ,_bafac :=_ffc .(*PdfObjectReference );if _bafac {_ecefg ,_gfba :=_aead ._dfda [_cceac .ObjectNumber ];if _gfba &&_ecefg {_cd .Log .Debug ("\u0053t\u0072\u0065a\u006d\u0020\u004c\u0065n\u0067\u0074\u0068 \u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065 u\u006e\u0072\u0065s\u006f\u006cv\u0065\u0064\u0020\u0028\u0069\u006cl\u0065\u0067a\u006c\u0029");return nil ,_f .New ("\u0069\u006c\u006c\u0065ga\u006c\u0020\u0072\u0065\u0063\u0075\u0072\u0073\u0069\u0076\u0065\u0020\u006c\u006fo\u0070");};_aead ._dfda [_cceac .ObjectNumber ]=true ;};_fbdc ,_cacd :=_aead .Resolve (_ffc );if _cacd !=nil {return nil ,_cacd ;};_cd .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_fbdc );if _bafac {_aead ._dfda [_cceac .ObjectNumber ]=false ;};return _fbdc ,nil ;};func (_ffbd *PdfParser )resolveReference (_gead *PdfObjectReference )(PdfObject ,bool ,error ){_egfce ,_dead :=_ffbd .ObjCache [int (_gead .ObjectNumber )];if _dead {return _egfce ,true ,nil ;};_ccec ,_eedd :=_ffbd .LookupByReference (*_gead );if _eedd !=nil {return nil ,false ,_eedd ;};_ffbd .ObjCache [int (_gead .ObjectNumber )]=_ccec ;return _ccec ,false ,nil ;};

// DecodeStream decodes the stream containing CCITTFax encoded image data.
func (_cgccd *CCITTFaxEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _cgccd .DecodeBytes (streamObj .Stream );};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_adde *FlateEncoder )MakeStreamDict ()*PdfObjectDictionary {_dde :=MakeDict ();_dde .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_adde .GetFilterName ()));_cgca :=_adde .MakeDecodeParams ();if _cgca !=nil {_dde .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_cgca );};return _dde ;};type encryptDict struct{Filter string ;V int ;SubFilter string ;Length int ;StmF string ;StrF string ;EFF string ;CF map[string ]_ag .FilterDict ;};func (_gbcfb *PdfParser )seekToEOFMarker (_cfgc int64 )error {var _fdab int64 ;var _fdag int64 =2048;for _fdab < _cfgc -4{if _cfgc <=(_fdag +_fdab ){_fdag =_cfgc -_fdab ;};_ ,_aagb :=_gbcfb ._egfc .Seek (-_fdab -_fdag ,_gb .SeekEnd );if _aagb !=nil {return _aagb ;};_fced :=make ([]byte ,_fdag );_gbcfb ._egfc .Read (_fced );_cd .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0045\u004f\u0046 \u006da\u0072\u006b\u0065\u0072\u003a\u0020\u0022%\u0073\u0022",string (_fced ));_aaed :=_cage .FindAllStringIndex (string (_fced ),-1);if _aaed !=nil {_acdcd :=_aaed [len (_aaed )-1];_cd .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_aaed );_gbcfb ._egfc .Seek (-_fdab -_fdag +int64 (_acdcd [0]),_gb .SeekEnd );return nil ;};_cd .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");_fdab +=_fdag -4;};_cd .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006be\u0072 \u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u002e");return _f .New ("\u0045\u004f\u0046\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};func (_gdb *PdfParser )parsePdfVersion ()(int ,int ,error ){var _bgfd int64 =20;_fcgaf :=make ([]byte ,_bgfd );_gdb ._egfc .Seek (0,_df .SEEK_SET );_gdb ._egfc .Read (_fcgaf );var _gfg error ;var _eddg ,_gebdd int ;if _gdfc :=_dfbe .FindStringSubmatch (string (_fcgaf ));len (_gdfc )< 3{if _eddg ,_gebdd ,_gfg =_gdb .seekPdfVersionTopDown ();_gfg !=nil {_cd .Log .Debug ("F\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065\u0063\u006f\u0076\u0065\u0072\u0079\u0020\u002d\u0020\u0075n\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0066\u0069nd\u0020\u0076\u0065r\u0073i\u006f\u006e");return 0,0,_gfg ;};_gdb ._egfc ,_gfg =_bdea (_gdb ._egfc ,_gdb .GetFileOffset ()-8);if _gfg !=nil {return 0,0,_gfg ;};}else {if _eddg ,_gfg =_d .Atoi (_gdfc [1]);_gfg !=nil {return 0,0,_gfg ;};if _gebdd ,_gfg =_d .Atoi (_gdfc [2]);_gfg !=nil {return 0,0,_gfg ;};_gdb .SetFileOffset (0);};_gdb ._bfbbd =_adg .NewReader (_gdb ._egfc );_cd .Log .Debug ("\u0050\u0064\u0066\u0020\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020%\u0064\u002e\u0025\u0064",_eddg ,_gebdd );return _eddg ,_gebdd ,nil ;};

// XrefObject defines a cross reference entry which is a map between object number (with generation number) and the
// location of the actual object, either as a file offset (xref table entry), or as a location within an xref
// stream object (xref object stream).
type XrefObject struct{XType xrefType ;ObjectNumber int ;Generation int ;

// For normal xrefs (defined by OFFSET)
Offset int64 ;

// For xrefs to object streams.
OsObjNumber int ;OsObjIndex int ;};

// String returns the state of the bool as "true" or "false".
func (_gcfg *PdfObjectBool )String ()string {if *_gcfg {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};

// IsFloatDigit checks if a character can be a part of a float number string.
func IsFloatDigit (c byte )bool {return ('0'<=c &&c <='9')||c =='.'};

// DecodeStream implements ASCII hex decoding.
func (_edga *ASCIIHexEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _edga .DecodeBytes (streamObj .Stream );};

// UpdateParams updates the parameter values of the encoder.
func (_addd *DCTEncoder )UpdateParams (params *PdfObjectDictionary ){_abeg ,_dgf :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _dgf ==nil {_addd .ColorComponents =int (_abeg );};_gcgdb ,_dgf :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _dgf ==nil {_addd .BitsPerComponent =int (_gcgdb );};_bae ,_dgf :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _dgf ==nil {_addd .Width =int (_bae );};_dgeb ,_dgf :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _dgf ==nil {_addd .Height =int (_dgeb );};_gaaa ,_dgf :=GetNumberAsInt64 (params .Get ("\u0051u\u0061\u006c\u0069\u0074\u0079"));if _dgf ==nil {_addd .Quality =int (_gaaa );};};

// UpdateParams updates the parameter values of the encoder.
func (_ecda *JPXEncoder )UpdateParams (params *PdfObjectDictionary ){};var _agfa =_c .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064\u002b)\u005c\u0073\u002a\u0024");

// String returns a string representation of the *PdfObjectString.
func (_fdeeb *PdfObjectString )String ()string {return _fdeeb ._eagc };

// DecodeStream decodes a DCT encoded stream and returns the result as a
// slice of bytes.
func (_dbb *DCTEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _dbb .DecodeBytes (streamObj .Stream );};

// DecodeBytes decodes a slice of JPX encoded bytes and returns the result.
func (_dccf *JPXEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_cd .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_dccf .GetFilterName ());return encoded ,ErrNoJPXDecode ;};

// JBIG2EncoderSettings contains the parameters and settings used by the JBIG2Encoder.
// Current version works only on JB2Generic compression.
type JBIG2EncoderSettings struct{

// FileMode defines if the jbig2 encoder should return full jbig2 file instead of
// shortened pdf mode. This adds the file header to the jbig2 definition.
FileMode bool ;

// Compression is the setting that defines the compression type used for encoding the page.
Compression JBIG2CompressionType ;

// DuplicatedLinesRemoval code generic region in a way such that if the lines are duplicated the encoder
// doesn't store it twice.
DuplicatedLinesRemoval bool ;

// DefaultPixelValue is the bit value initial for every pixel in the page.
DefaultPixelValue uint8 ;

// ResolutionX optional setting that defines the 'x' axis input image resolution - used for single page encoding.
ResolutionX int ;

// ResolutionY optional setting that defines the 'y' axis input image resolution - used for single page encoding.
ResolutionY int ;

// Threshold defines the threshold of the image correlation for
// non Generic compression.
// User only for JB2SymbolCorrelation and JB2SymbolRankHaus methods.
// Best results in range [0.7 - 0.98] - the less the better the compression would be
// but the more lossy.
// Default value: 0.95
Threshold float64 ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_efcg *CCITTFaxEncoder )MakeDecodeParams ()PdfObject {_debb :=MakeDict ();_debb .Set ("\u004b",MakeInteger (int64 (_efcg .K )));_debb .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_efcg .Columns )));if _efcg .BlackIs1 {_debb .Set ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031",MakeBool (_efcg .BlackIs1 ));};if _efcg .EncodedByteAlign {_debb .Set ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e",MakeBool (_efcg .EncodedByteAlign ));};if _efcg .EndOfLine &&_efcg .K >=0{_debb .Set ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee",MakeBool (_efcg .EndOfLine ));};if _efcg .Rows !=0&&!_efcg .EndOfBlock {_debb .Set ("\u0052\u006f\u0077\u0073",MakeInteger (int64 (_efcg .Rows )));};if !_efcg .EndOfBlock {_debb .Set ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b",MakeBool (_efcg .EndOfBlock ));};if _efcg .DamagedRowsBeforeError !=0{_debb .Set ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072",MakeInteger (int64 (_efcg .DamagedRowsBeforeError )));};return _debb ;};func _cgfde (_gbagd ,_ecbf ,_bedec int )error {if _ecbf < 0||_ecbf > _gbagd {return _f .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0061\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");};if _bedec < _ecbf {return _f .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0073\u006c\u0069\u0063e\u0020i\u006ed\u0065\u0078\u0020\u0062\u0020\u003c\u0020a");};if _bedec > _gbagd {return _f .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0062\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");};return nil ;};

// PdfObjectArray represents the primitive PDF array object.
type PdfObjectArray struct{_ddfca []PdfObject };

// Clear resets the array to an empty state.
func (_edca *PdfObjectArray )Clear (){_edca ._ddfca =[]PdfObject {}};type xrefType int ;

// MakeArrayFromIntegers creates an PdfObjectArray from a slice of ints, where each array element is
// an PdfObjectInteger.
func MakeArrayFromIntegers (vals []int )*PdfObjectArray {_cdfc :=MakeArray ();for _ ,_ggeg :=range vals {_cdfc .Append (MakeInteger (int64 (_ggeg )));};return _cdfc ;};

// UpdateParams updates the parameter values of the encoder.
func (_gbcda *LZWEncoder )UpdateParams (params *PdfObjectDictionary ){_bbg ,_bfg :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _bfg ==nil {_gbcda .Predictor =int (_bbg );};_ebdea ,_bfg :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _bfg ==nil {_gbcda .BitsPerComponent =int (_ebdea );};_bcbd ,_bfg :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _bfg ==nil {_gbcda .Columns =int (_bcbd );};_aba ,_bfg :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _bfg ==nil {_gbcda .Colors =int (_aba );};_ddba ,_bfg :=GetNumberAsInt64 (params .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065"));if _bfg ==nil {_gbcda .EarlyChange =int (_ddba );};};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_eagd *CCITTFaxEncoder )MakeStreamDict ()*PdfObjectDictionary {_cfaeg :=MakeDict ();_cfaeg .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_eagd .GetFilterName ()));_dage :=_eagd .MakeDecodeParams ();if _dage !=nil {_cfaeg .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_dage );};return _cfaeg ;};var _eeae =_c .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064+\u0029\u005c\u0073\u002b\u0028\u005b\u006e\u0066\u005d\u0029\\\u0073\u002a\u0024");

// ToIntegerArray returns a slice of all array elements as an int slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_bgfdc *PdfObjectArray )ToIntegerArray ()([]int ,error ){var _gfcdc []int ;for _ ,_dbgb :=range _bgfdc .Elements (){if _cbdb ,_effc :=_dbgb .(*PdfObjectInteger );_effc {_gfcdc =append (_gfcdc ,int (*_cbdb ));}else {return nil ,ErrTypeError ;};};return _gfcdc ,nil ;};

// GetXrefOffset returns the offset of the xref table.
func (_aeff *PdfParser )GetXrefOffset ()int64 {return _aeff ._aafc };

// ASCII85Encoder implements ASCII85 encoder/decoder.
type ASCII85Encoder struct{};

// ToFloat64Array returns a slice of all elements in the array as a float64 slice.  An error is
// returned if the array contains non-numeric objects (each element can be either PdfObjectInteger
// or PdfObjectFloat).
func (_cbcc *PdfObjectArray )ToFloat64Array ()([]float64 ,error ){var _cafcc []float64 ;for _ ,_adcb :=range _cbcc .Elements (){switch _cbgd :=_adcb .(type ){case *PdfObjectInteger :_cafcc =append (_cafcc ,float64 (*_cbgd ));case *PdfObjectFloat :_cafcc =append (_cafcc ,float64 (*_cbgd ));default:return nil ,ErrTypeError ;};};return _cafcc ,nil ;};

// GetFilterName returns the name of the encoding filter.
func (_afe *JPXEncoder )GetFilterName ()string {return StreamEncodingFilterNameJPX };

// SetImage sets the image base for given flate encoder.
func (_gea *FlateEncoder )SetImage (img *_ada .ImageBase ){_gea ._adead =img };

// JPXEncoder implements JPX encoder/decoder (dummy, for now)
// FIXME: implement
type JPXEncoder struct{};

// PdfObjectBool represents the primitive PDF boolean object.
type PdfObjectBool bool ;

// Get returns the i-th element of the array or nil if out of bounds (by index).
func (_faae *PdfObjectArray )Get (i int )PdfObject {if _faae ==nil ||i >=len (_faae ._ddfca )||i < 0{return nil ;};return _faae ._ddfca [i ];};func _dbbg (_dgaa PdfObject ,_eaag int )PdfObject {if _eaag > _baaa {_cd .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_baaa );return MakeNull ();};switch _ddbca :=_dgaa .(type ){case *PdfIndirectObject :_dgaa =_dbbg ((*_ddbca ).PdfObject ,_eaag +1);case *PdfObjectArray :for _ccbbe ,_dfeb :=range (*_ddbca )._ddfca {(*_ddbca )._ddfca [_ccbbe ]=_dbbg (_dfeb ,_eaag +1);};case *PdfObjectDictionary :for _cgaee ,_ccbab :=range (*_ddbca )._bacc {(*_ddbca )._bacc [_cgaee ]=_dbbg (_ccbab ,_eaag +1);};_g .Slice ((*_ddbca )._aedd ,func (_efcgf ,_abecab int )bool {return (*_ddbca )._aedd [_efcgf ]< (*_ddbca )._aedd [_abecab ]});};return _dgaa ;};

// WriteString outputs the object as it is to be written to file.
func (_eagbe *PdfObjectArray )WriteString ()string {var _adbc _ed .Builder ;_adbc .WriteString ("\u005b");for _bcea ,_dcgc :=range _eagbe .Elements (){_adbc .WriteString (_dcgc .WriteString ());if _bcea < (_eagbe .Len ()-1){_adbc .WriteString ("\u0020");};};_adbc .WriteString ("\u005d");return _adbc .String ();};func (_gdee *PdfParser )repairSeekXrefMarker ()error {_feccb ,_dbag :=_gdee ._egfc .Seek (0,_df .SEEK_END );if _dbag !=nil {return _dbag ;};_ebdc :=_c .MustCompile ("\u005cs\u0078\u0072\u0065\u0066\u005c\u0073*");var _gca int64 ;var _dcfb int64 =1000;for _gca < _feccb {if _feccb <=(_dcfb +_gca ){_dcfb =_feccb -_gca ;};_ ,_fcab :=_gdee ._egfc .Seek (-_gca -_dcfb ,_df .SEEK_END );if _fcab !=nil {return _fcab ;};_ceeaf :=make ([]byte ,_dcfb );_gdee ._egfc .Read (_ceeaf );_cd .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0078\u0072\u0065\u0066\u0020\u003a\u0020\u0022\u0025\u0073\u0022",string (_ceeaf ));_afae :=_ebdc .FindAllStringIndex (string (_ceeaf ),-1);if _afae !=nil {_ebbe :=_afae [len (_afae )-1];_cd .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_afae );_gdee ._egfc .Seek (-_gca -_dcfb +int64 (_ebbe [0]),_df .SEEK_END );_gdee ._bfbbd =_adg .NewReader (_gdee ._egfc );for {_bcfd ,_eeddd :=_gdee ._bfbbd .Peek (1);if _eeddd !=nil {return _eeddd ;};_cd .Log .Trace ("\u0042\u003a\u0020\u0025\u0064\u0020\u0025\u0063",_bcfd [0],_bcfd [0]);if !IsWhiteSpace (_bcfd [0]){break ;};_gdee ._bfbbd .Discard (1);};return nil ;};_cd .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");_gca +=_dcfb ;};_cd .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074a\u0062\u006c\u0065\u0020\u006d\u0061r\u006b\u0065\u0072\u0020\u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066o\u0075\u006e\u0064\u002e");return _f .New ("\u0078r\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0020");};

// DecodeStream decodes a LZW encoded stream and returns the result as a
// slice of bytes.
func (_dccad *LZWEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_cd .Log .Trace ("\u004c\u005a\u0057 \u0044\u0065\u0063\u006f\u0064\u0069\u006e\u0067");_cd .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_dccad .Predictor );_aee ,_dfaf :=_dccad .DecodeBytes (streamObj .Stream );if _dfaf !=nil {return nil ,_dfaf ;};_cd .Log .Trace ("\u0020\u0049\u004e\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (streamObj .Stream ),streamObj .Stream );_cd .Log .Trace ("\u004f\u0055\u0054\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (_aee ),_aee );if _dccad .Predictor > 1{if _dccad .Predictor ==2{_cd .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_gaab :=int (_dccad .Columns )*_dccad .Colors ;if _gaab < 1{return []byte {},nil ;};_dfe :=len (_aee )/_gaab ;if len (_aee )%_gaab !=0{_cd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");return nil ,_aa .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_aee ),_gaab );};if _gaab %_dccad .Colors !=0{return nil ,_aa .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_gaab ,_dccad .Colors );};if _gaab > len (_aee ){_cd .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_gaab ,len (_aee ));return nil ,_f .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_cd .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_aee ),_aee );_aaab :=_dgb .NewBuffer (nil );for _gaf :=0;_gaf < _dfe ;_gaf ++{_aca :=_aee [_gaab *_gaf :_gaab *(_gaf +1)];for _ebe :=_dccad .Colors ;_ebe < _gaab ;_ebe ++{_aca [_ebe ]=byte (int (_aca [_ebe ]+_aca [_ebe -_dccad .Colors ])%256);};_aaab .Write (_aca );};_bdf :=_aaab .Bytes ();_cd .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_bdf ),_bdf );return _bdf ,nil ;}else if _dccad .Predictor >=10&&_dccad .Predictor <=15{_cd .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_caba :=int (_dccad .Columns *_dccad .Colors +1);if _caba < 1{return []byte {},nil ;};_eea :=len (_aee )/_caba ;if len (_aee )%_caba !=0{return nil ,_aa .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_aee ),_caba );};if _caba > len (_aee ){_cd .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_caba ,len (_aee ));return nil ,_f .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_dbed :=_dgb .NewBuffer (nil );_cd .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_dccad .Columns );_cd .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_aee ),_caba ,_eea );_aac :=make ([]byte ,_caba );for _cdec :=0;_cdec < _caba ;_cdec ++{_aac [_cdec ]=0;};for _ceaf :=0;_ceaf < _eea ;_ceaf ++{_dfdc :=_aee [_caba *_ceaf :_caba *(_ceaf +1)];_cebc :=_dfdc [0];switch _cebc {case 0:case 1:for _gbcc :=2;_gbcc < _caba ;_gbcc ++{_dfdc [_gbcc ]=byte (int (_dfdc [_gbcc ]+_dfdc [_gbcc -1])%256);};case 2:for _gacb :=1;_gacb < _caba ;_gacb ++{_dfdc [_gacb ]=byte (int (_dfdc [_gacb ]+_aac [_gacb ])%256);};default:_cd .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0066i\u006c\u0074\u0065\u0072\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_cebc );return nil ,_aa .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_cebc );};for _cbb :=0;_cbb < _caba ;_cbb ++{_aac [_cbb ]=_dfdc [_cbb ];};_dbed .Write (_dfdc [1:]);};_fada :=_dbed .Bytes ();return _fada ,nil ;}else {_cd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_dccad .Predictor );return nil ,_aa .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_dccad .Predictor );};};return _aee ,nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_ede *RawEncoder )UpdateParams (params *PdfObjectDictionary ){};

// Set sets the dictionary's key -> val mapping entry. Overwrites if key already set.
func (_fdae *PdfObjectDictionary )Set (key PdfObjectName ,val PdfObject ){_ ,_dcfe :=_fdae ._bacc [key ];if !_dcfe {_fdae ._aedd =append (_fdae ._aedd ,key );};_fdae ._bacc [key ]=val ;};

// GetNumberAsInt64 returns the contents of `obj` as an int64 if it is an integer or float, or an
// error if it isn't. This is for cases where expecting an integer, but some implementations
// actually store the number in a floating point format.
func GetNumberAsInt64 (obj PdfObject )(int64 ,error ){switch _eace :=obj .(type ){case *PdfObjectFloat :_cd .Log .Debug ("\u004e\u0075m\u0062\u0065\u0072\u0020\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0061\u0073\u0020\u0069\u006e\u0074e\u0067\u0065\u0072\u0020\u0077\u0061s\u0020\u0073\u0074\u006f\u0072\u0065\u0064\u0020\u0061\u0073\u0020\u0066\u006c\u006fa\u0074\u0020(\u0074\u0079\u0070\u0065 \u0063\u0061\u0073\u0074\u0069n\u0067\u0020\u0075\u0073\u0065\u0064\u0029");return int64 (*_eace ),nil ;case *PdfObjectInteger :return int64 (*_eace ),nil ;};return 0,ErrNotANumber ;};

// DecodeBytes decodes the CCITTFax encoded image data.
func (_bgaefc *CCITTFaxEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_cabc :=&_be .Encoder {K :_bgaefc .K ,Columns :_bgaefc .Columns ,EndOfLine :_bgaefc .EndOfLine ,EndOfBlock :_bgaefc .EndOfBlock ,BlackIs1 :_bgaefc .BlackIs1 ,DamagedRowsBeforeError :_bgaefc .DamagedRowsBeforeError ,Rows :_bgaefc .Rows ,EncodedByteAlign :_bgaefc .EncodedByteAlign };_bgb ,_bcdc :=_cabc .Decode (encoded );if _bcdc !=nil {return nil ,_bcdc ;};var _dccd []byte ;_gedb :=0;var _dcga byte ;var _ffbb byte ;for _deea :=range _bgb {if _dcga !=0{_dccd =append (_dccd ,_ffbb );_ffbb =0;_gedb ++;_dcga =0;};for _efcc :=range _bgb [_deea ]{_ffbb |=_bgb [_deea ][_efcc ]<<(7-_dcga );_dcga ++;if _dcga ==8{_dccd =append (_dccd ,_ffbb );_ffbb =0;_gedb ++;_dcga =0;};};};if _dcga > 0{_dccd =append (_dccd ,_ffbb );};return _dccd ,nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_afdc *MultiEncoder )MakeDecodeParams ()PdfObject {if len (_afdc ._egdf )==0{return nil ;};if len (_afdc ._egdf )==1{return _afdc ._egdf [0].MakeDecodeParams ();};_gfe :=MakeArray ();for _ ,_cfcg :=range _afdc ._egdf {_faddf :=_cfcg .MakeDecodeParams ();if _faddf ==nil {_gfe .Append (MakeNull ());}else {_gfe .Append (_faddf );};};return _gfe ;};

// RawEncoder implements Raw encoder/decoder (no encoding, pass through)
type RawEncoder struct{};

// DecodeBytes decodes a slice of ASCII encoded bytes and returns the result.
func (_affa *ASCIIHexEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_dfbf :=_dgb .NewReader (encoded );var _eadc []byte ;for {_fcba ,_gfac :=_dfbf .ReadByte ();if _gfac !=nil {return nil ,_gfac ;};if _fcba =='>'{break ;};if IsWhiteSpace (_fcba ){continue ;};if (_fcba >='a'&&_fcba <='f')||(_fcba >='A'&&_fcba <='F')||(_fcba >='0'&&_fcba <='9'){_eadc =append (_eadc ,_fcba );}else {_cd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0061\u0073\u0063\u0069\u0069 \u0068\u0065\u0078\u0020\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072 \u0028\u0025\u0063\u0029",_fcba );return nil ,_aa .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0061\u0073\u0063\u0069\u0069\u0020\u0068e\u0078 \u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u0020\u0028\u0025\u0063\u0029",_fcba );};};if len (_eadc )%2==1{_eadc =append (_eadc ,'0');};_cd .Log .Trace ("\u0049\u006e\u0062\u006f\u0075\u006e\u0064\u0020\u0025\u0073",_eadc );_bbgg :=make ([]byte ,_gba .DecodedLen (len (_eadc )));_ ,_cdae :=_gba .Decode (_bbgg ,_eadc );if _cdae !=nil {return nil ,_cdae ;};return _bbgg ,nil ;};func (_bbcfb *PdfParser )skipSpaces ()(int ,error ){_ded :=0;for {_dcfd ,_gbab :=_bbcfb ._bfbbd .ReadByte ();if _gbab !=nil {return 0,_gbab ;};if IsWhiteSpace (_dcfd ){_ded ++;}else {_bbcfb ._bfbbd .UnreadByte ();break ;};};return _ded ,nil ;};

// IsWhiteSpace checks if byte represents a white space character.
func IsWhiteSpace (ch byte )bool {if (ch ==0x00)||(ch ==0x09)||(ch ==0x0A)||(ch ==0x0C)||(ch ==0x0D)||(ch ==0x20){return true ;};return false ;};

// GetFilterName returns the names of the underlying encoding filters,
// separated by spaces.
// Note: This is just a string, should not be used in /Filter dictionary entry. Use GetFilterArray for that.
// TODO(v4): Refactor to GetFilter() which can be used for /Filter (either Name or Array), this can be
//  renamed to String() as a pretty string to use in debugging etc.
func (_bcfg *MultiEncoder )GetFilterName ()string {_cbea :="";for _gcga ,_baa :=range _bcfg ._egdf {_cbea +=_baa .GetFilterName ();if _gcga < len (_bcfg ._egdf )-1{_cbea +="\u0020";};};return _cbea ;};

// Set sets the PdfObject at index i of the streams. An error is returned if the index is outside bounds.
func (_cabb *PdfObjectStreams )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_cabb ._gcdd ){return _f .New ("\u004f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_cabb ._gcdd [i ]=obj ;return nil ;};func _bfbd (_edgg int )int {_fbdf :=_edgg >>(_dfag -1);return (_edgg ^_fbdf )-_fbdf };

// GetFileOffset returns the current file offset, accounting for buffered position.
func (_gee *PdfParser )GetFileOffset ()int64 {_daab ,_ :=_gee ._egfc .Seek (0,_gb .SeekCurrent );_daab -=int64 (_gee ._bfbbd .Buffered ());return _daab ;};var _geeb =_c .MustCompile ("\u0028\u005c\u0064\u002b)\\\u0073\u002b\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u006f\u0062\u006a");

// Clear resets the dictionary to an empty state.
func (_afde *PdfObjectDictionary )Clear (){_afde ._aedd =[]PdfObjectName {};_afde ._bacc =map[PdfObjectName ]PdfObject {};};func (_ebd *PdfCrypt )makeKey (_acf string ,_fbg ,_aea uint32 ,_agg []byte )([]byte ,error ){_gcd ,_ebde :=_ebd ._bee [_acf ];if !_ebde {return nil ,_aa .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_acf );};return _gcd .MakeKey (_fbg ,_aea ,_agg );};

// Decrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_deca *PdfCrypt )Decrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _deca .isDecrypted (obj ){return nil ;};switch _eba :=obj .(type ){case *PdfIndirectObject :_deca ._ece [_eba ]=true ;_cd .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_eba .ObjectNumber ,_eba .GenerationNumber );_gce :=_eba .ObjectNumber ;_gecd :=_eba .GenerationNumber ;_caa :=_deca .Decrypt (_eba .PdfObject ,_gce ,_gecd );if _caa !=nil {return _caa ;};return nil ;case *PdfObjectStream :_deca ._ece [_eba ]=true ;_dfg :=_eba .PdfObjectDictionary ;if _deca ._cgd .R !=5{if _daec ,_eef :=_dfg .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_eef &&*_daec =="\u0058\u0052\u0065\u0066"{return nil ;};};_dgcf :=_eba .ObjectNumber ;_bdcb :=_eba .GenerationNumber ;_cd .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_dgcf ,_bdcb );_fcf :=_cgg ;if _deca ._cfd .V >=4{_fcf =_deca ._eeb ;_cd .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_deca ._eeb );if _ffga ,_cgcf :=_dfg .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );_cgcf {if _cdc ,_bace :=GetName (_ffga .Get (0));_bace {if *_cdc =="\u0043\u0072\u0079p\u0074"{_fcf ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _dddb ,_ecf :=_dfg .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );_ecf {if _gfb ,_cegd :=_dddb .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_cegd {if _ ,_bdag :=_deca ._bee [string (*_gfb )];_bdag {_cd .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_gfb );_fcf =string (*_gfb );};};};};};};_cd .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_fcf );if _fcf =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_gac :=_deca .Decrypt (_dfg ,_dgcf ,_bdcb );if _gac !=nil {return _gac ;};_gbag ,_gac :=_deca .makeKey (_fcf ,uint32 (_dgcf ),uint32 (_bdcb ),_deca ._cebd );if _gac !=nil {return _gac ;};_eba .Stream ,_gac =_deca .decryptBytes (_eba .Stream ,_fcf ,_gbag );if _gac !=nil {return _gac ;};_dfg .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_eba .Stream ))));return nil ;case *PdfObjectString :_cd .Log .Trace ("\u0044e\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_fdb :=_cgg ;if _deca ._cfd .V >=4{_cd .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_deca ._cac );if _deca ._cac =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_fdb =_deca ._cac ;};_fcg ,_ddbc :=_deca .makeKey (_fdb ,uint32 (parentObjNum ),uint32 (parentGenNum ),_deca ._cebd );if _ddbc !=nil {return _ddbc ;};_gdgd :=_eba .Str ();_agfe :=make ([]byte ,len (_gdgd ));for _gff :=0;_gff < len (_gdgd );_gff ++{_agfe [_gff ]=_gdgd [_gff ];};_cd .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_agfe ,_agfe );_agfe ,_ddbc =_deca .decryptBytes (_agfe ,_fdb ,_fcg );if _ddbc !=nil {return _ddbc ;};_eba ._eagc =string (_agfe );return nil ;case *PdfObjectArray :for _ ,_bdca :=range _eba .Elements (){_bgdcg :=_deca .Decrypt (_bdca ,parentObjNum ,parentGenNum );if _bgdcg !=nil {return _bgdcg ;};};return nil ;case *PdfObjectDictionary :_afc :=false ;if _cede :=_eba .Get ("\u0054\u0079\u0070\u0065");_cede !=nil {_gda ,_gfa :=_cede .(*PdfObjectName );if _gfa &&*_gda =="\u0053\u0069\u0067"{_afc =true ;};};for _ ,_afg :=range _eba .Keys (){_daf :=_eba .Get (_afg );if _afc &&string (_afg )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;};if string (_afg )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_afg )!="\u0050\u0072\u0065\u0076"&&string (_afg )!="\u004c\u0061\u0073\u0074"{_acce :=_deca .Decrypt (_daf ,parentObjNum ,parentGenNum );if _acce !=nil {return _acce ;};};};return nil ;};return nil ;};

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_efc *RunLengthEncoder )EncodeBytes (data []byte )([]byte ,error ){_cdeg :=_dgb .NewReader (data );var _addb []byte ;var _dccadf []byte ;_fbdg ,_bbba :=_cdeg .ReadByte ();if _bbba ==_gb .EOF {return []byte {},nil ;}else if _bbba !=nil {return nil ,_bbba ;};_accc :=1;for {_fffa ,_ggfb :=_cdeg .ReadByte ();if _ggfb ==_gb .EOF {break ;}else if _ggfb !=nil {return nil ,_ggfb ;};if _fffa ==_fbdg {if len (_dccadf )> 0{_dccadf =_dccadf [:len (_dccadf )-1];if len (_dccadf )> 0{_addb =append (_addb ,byte (len (_dccadf )-1));_addb =append (_addb ,_dccadf ...);};_accc =1;_dccadf =[]byte {};};_accc ++;if _accc >=127{_addb =append (_addb ,byte (257-_accc ),_fbdg );_accc =0;};}else {if _accc > 0{if _accc ==1{_dccadf =[]byte {_fbdg };}else {_addb =append (_addb ,byte (257-_accc ),_fbdg );};_accc =0;};_dccadf =append (_dccadf ,_fffa );if len (_dccadf )>=127{_addb =append (_addb ,byte (len (_dccadf )-1));_addb =append (_addb ,_dccadf ...);_dccadf =[]byte {};};};_fbdg =_fffa ;};if len (_dccadf )> 0{_addb =append (_addb ,byte (len (_dccadf )-1));_addb =append (_addb ,_dccadf ...);}else if _accc > 0{_addb =append (_addb ,byte (257-_accc ),_fbdg );};_addb =append (_addb ,128);return _addb ,nil ;};const (StreamEncodingFilterNameFlate ="F\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameLZW ="\u004cZ\u0057\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameDCT ="\u0044C\u0054\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameRunLength ="\u0052u\u006eL\u0065\u006e\u0067\u0074\u0068\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameASCIIHex ="\u0041\u0053\u0043\u0049\u0049\u0048\u0065\u0078\u0044e\u0063\u006f\u0064\u0065";StreamEncodingFilterNameASCII85 ="\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameCCITTFax ="\u0043\u0043\u0049\u0054\u0054\u0046\u0061\u0078\u0044e\u0063\u006f\u0064\u0065";StreamEncodingFilterNameJBIG2 ="J\u0042\u0049\u0047\u0032\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameJPX ="\u004aP\u0058\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameRaw ="\u0052\u0061\u0077";);

// Append appends PdfObject(s) to the streams.
func (_ggbc *PdfObjectStreams )Append (objects ...PdfObject ){if _ggbc ==nil {_cd .Log .Debug ("\u0057\u0061\u0072\u006e\u0020-\u0020\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0020\u0074\u006f\u0020\u0061p\u0070\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0073");return ;};if _ggbc ._gcdd ==nil {_ggbc ._gcdd =[]PdfObject {};};for _ ,_gdeac :=range objects {_ggbc ._gcdd =append (_ggbc ._gcdd ,_gdeac );};};func _ddbb (_agfb *PdfObjectStream ,_fgb *PdfObjectDictionary )(*FlateEncoder ,error ){_bbcc :=NewFlateEncoder ();_cdfd :=_agfb .PdfObjectDictionary ;if _cdfd ==nil {return _bbcc ,nil ;};_bbcc ._adead =_ccebf (_cdfd );if _fgb ==nil {_cfc :=TraceToDirectObject (_cdfd .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));switch _gbd :=_cfc .(type ){case *PdfObjectArray :_fbc :=_gbd ;if _fbc .Len ()!=1{_cd .Log .Debug ("\u0045\u0072\u0072\u006f\u0072:\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020a\u0072\u0072\u0061\u0079\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0021\u003d\u0020\u0031\u0020\u0028\u0025\u0064\u0029",_fbc .Len ());return nil ,_f .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_cfc =TraceToDirectObject (_fbc .Get (0));case *PdfObjectDictionary :_fgb =_gbd ;case *PdfObjectNull ,nil :default:_cd .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020n\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079 \u0028%\u0054\u0029",_cfc );return nil ,_aa .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _fgb ==nil {return _bbcc ,nil ;};_cd .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_fgb .String ());_ccae :=_fgb .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");if _ccae ==nil {_cd .Log .Debug ("E\u0072\u0072o\u0072\u003a\u0020\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067 \u0066\u0072\u006f\u006d\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073 \u002d\u0020\u0043\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020\u0077\u0069t\u0068\u0020\u0064\u0065\u0066\u0061\u0075\u006c\u0074\u0020\u00281\u0029");}else {_gbda ,_bbcf :=_ccae .(*PdfObjectInteger );if !_bbcf {_cd .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_ccae );return nil ,_aa .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_bbcc .Predictor =int (*_gbda );};_ccae =_fgb .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");if _ccae !=nil {_ecea ,_gabc :=_ccae .(*PdfObjectInteger );if !_gabc {_cd .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");return nil ,_aa .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_bbcc .BitsPerComponent =int (*_ecea );};if _bbcc .Predictor > 1{_bbcc .Columns =1;_ccae =_fgb .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");if _ccae !=nil {_ffb ,_dgdf :=_ccae .(*PdfObjectInteger );if !_dgdf {return nil ,_aa .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_bbcc .Columns =int (*_ffb );};_bbcc .Colors =1;_ccae =_fgb .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _ccae !=nil {_gffe ,_eacc :=_ccae .(*PdfObjectInteger );if !_eacc {return nil ,_aa .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");};_bbcc .Colors =int (*_gffe );};};return _bbcc ,nil ;};

// DecodeStream decodes a JPX encoded stream and returns the result as a
// slice of bytes.
func (_faeff *JPXEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_cd .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_faeff .GetFilterName ());return streamObj .Stream ,ErrNoJPXDecode ;};func (_bfcca *PdfObjectInteger )String ()string {return _aa .Sprintf ("\u0025\u0064",*_bfcca )};

// PdfCrypt provides PDF encryption/decryption support.
// The PDF standard supports encryption of strings and streams (Section 7.6).
type PdfCrypt struct{_cfd encryptDict ;_cgd _dd .StdEncryptDict ;_gfc string ;_cebd []byte ;_ece map[PdfObject ]bool ;_bde map[PdfObject ]bool ;_fag bool ;_bee cryptFilters ;_eeb string ;_cac string ;_ccc *PdfParser ;_cgaf map[int ]struct{};};

// PdfObjectDictionary represents the primitive PDF dictionary/map object.
type PdfObjectDictionary struct{_bacc map[PdfObjectName ]PdfObject ;_aedd []PdfObjectName ;_fbdgf *PdfParser ;};func _fffc (_cddc ,_dddc ,_cbfb uint8 )uint8 {_gecf :=int (_cbfb );_gegb :=int (_dddc )-_gecf ;_dgfe :=int (_cddc )-_gecf ;_gecf =_bfbd (_gegb +_dgfe );_gegb =_bfbd (_gegb );_dgfe =_bfbd (_dgfe );if _gegb <=_dgfe &&_gegb <=_gecf {return _cddc ;}else if _dgfe <=_gecf {return _dddc ;};return _cbfb ;};var _fbce =_c .MustCompile ("\u005c\u0073\u002a\u0078\u0072\u0065\u0066\u005c\u0073\u002a");

// Elements returns a slice of the PdfObject elements in the array.
func (_abdg *PdfObjectArray )Elements ()[]PdfObject {if _abdg ==nil {return nil ;};return _abdg ._ddfca ;};

// PdfObjectName represents the primitive PDF name object.
type PdfObjectName string ;

// EncodeBytes DCT encodes the passed in slice of bytes.
func (_ccbg *DCTEncoder )EncodeBytes (data []byte )([]byte ,error ){_afdb ,_edf :=_ada .NewImage (_ccbg .Width ,_ccbg .Height ,_ccbg .BitsPerComponent ,_ccbg .ColorComponents ,data ,nil ,nil );if _edf !=nil {return nil ,_edf ;};_gcbc :=_e .Options {};_gcbc .Quality =_ccbg .Quality ;var _eaadc _dgb .Buffer ;if _edf =_e .Encode (&_eaadc ,_afdb ,&_gcbc );_edf !=nil {return nil ,_edf ;};return _eaadc .Bytes (),nil ;};

// GetFilterName returns the name of the encoding filter.
func (_gbga *RawEncoder )GetFilterName ()string {return StreamEncodingFilterNameRaw };

// PdfIndirectObject represents the primitive PDF indirect object.
type PdfIndirectObject struct{PdfObjectReference ;PdfObject ;};

// Validate validates the page settings for the JBIG2 encoder.
func (_fdcg JBIG2EncoderSettings )Validate ()error {const _aegbc ="\u0076a\u006ci\u0064\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065\u0072";if _fdcg .Threshold < 0||_fdcg .Threshold > 1.0{return _cf .Errorf (_aegbc ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074\u0068\u0072\u0065\u0073\u0068\u006f\u006c\u0064\u0020\u0076a\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0076\u0027 \u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0069\u006e\u0020\u0072\u0061n\u0067\u0065\u0020\u005b\u0030\u002e0\u002c\u0020\u0031.\u0030\u005d",_fdcg .Threshold );};if _fdcg .ResolutionX < 0{return _cf .Errorf (_aegbc ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0078\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_fdcg .ResolutionX );};if _fdcg .ResolutionY < 0{return _cf .Errorf (_aegbc ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0079\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_fdcg .ResolutionY );};if _fdcg .DefaultPixelValue !=0&&_fdcg .DefaultPixelValue !=1{return _cf .Errorf (_aegbc ,"de\u0066\u0061u\u006c\u0074\u0020\u0070\u0069\u0078\u0065\u006c\u0020v\u0061\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0066o\u0072 \u0074\u0068\u0065\u0020\u0062\u0069\u0074\u003a \u007b0\u002c\u0031}",_fdcg .DefaultPixelValue );};if _fdcg .Compression !=JB2Generic {return _cf .Errorf (_aegbc ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065d\u0020\u0063\u006fm\u0070\u0072\u0065\u0073s\u0069\u006f\u006e\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");};return nil ;};func (_gaegf *PdfParser )parseHexString ()(*PdfObjectString ,error ){_gaegf ._bfbbd .ReadByte ();var _bcga _dgb .Buffer ;for {_bca ,_gbfc :=_gaegf ._bfbbd .Peek (1);if _gbfc !=nil {return MakeString (""),_gbfc ;};if _bca [0]=='>'{_gaegf ._bfbbd .ReadByte ();break ;};_beebg ,_ :=_gaegf ._bfbbd .ReadByte ();if !IsWhiteSpace (_beebg ){_bcga .WriteByte (_beebg );};};if _bcga .Len ()%2==1{_bcga .WriteRune ('0');};_acdc ,_ :=_gba .DecodeString (_bcga .String ());return MakeHexString (string (_acdc )),nil ;};func _gffb (_fbfd _ada .Image )*JBIG2Image {_gaea :=_fbfd .Base ();return &JBIG2Image {Data :_gaea .Data ,Width :_gaea .Width ,Height :_gaea .Height ,HasPadding :true };};

// Inspect analyzes the document object structure. Returns a map of object types (by name) with the instance count
// as value.
func (_begc *PdfParser )Inspect ()(map[string ]int ,error ){return _begc .inspect ()};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_bgae *LZWEncoder )MakeStreamDict ()*PdfObjectDictionary {_cgfe :=MakeDict ();_cgfe .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_bgae .GetFilterName ()));_bcb :=_bgae .MakeDecodeParams ();if _bcb !=nil {_cgfe .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_bcb );};_cgfe .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (int64 (_bgae .EarlyChange )));return _cgfe ;};

// DCTEncoder provides a DCT (JPG) encoding/decoding functionality for images.
type DCTEncoder struct{ColorComponents int ;BitsPerComponent int ;Width int ;Height int ;Quality int ;};

// WriteString outputs the object as it is to be written to file.
func (_adca *PdfObjectFloat )WriteString ()string {return _d .FormatFloat (float64 (*_adca ),'f',-1,64);};

// Remove removes an element specified by key.
func (_egcc *PdfObjectDictionary )Remove (key PdfObjectName ){_gbdg :=-1;for _fdgb ,_fdgea :=range _egcc ._aedd {if _fdgea ==key {_gbdg =_fdgb ;break ;};};if _gbdg >=0{_egcc ._aedd =append (_egcc ._aedd [:_gbdg ],_egcc ._aedd [_gbdg +1:]...);delete (_egcc ._bacc ,key );};};

// GoImageToJBIG2 creates a binary image on the base of 'i' golang image.Image.
// If the image is not a black/white image then the function converts provided input into
// JBIG2Image with 1bpp. For non grayscale images the function performs the conversion to the grayscale temp image.
// Then it checks the value of the gray image value if it's within bounds of the black white threshold.
// This 'bwThreshold' value should be in range (0.0, 1.0). The threshold checks if the grayscale pixel (uint) value
// is greater or smaller than 'bwThreshold' * 255. Pixels inside the range will be white, and the others will be black.
// If the 'bwThreshold' is equal to -1.0 - JB2ImageAutoThreshold then it's value would be set on the base of
// it's histogram using Triangle method. For more information go to:
// 	https://www.mathworks.com/matlabcentral/fileexchange/28047-gray-image-thresholding-using-the-triangle-method
func GoImageToJBIG2 (i _cg .Image ,bwThreshold float64 )(*JBIG2Image ,error ){const _bdcd ="\u0047\u006f\u0049\u006d\u0061\u0067\u0065\u0054\u006fJ\u0042\u0049\u0047\u0032";if i ==nil {return nil ,_cf .Error (_bdcd ,"i\u006d\u0061\u0067\u0065 '\u0069'\u0020\u006e\u006f\u0074\u0020d\u0065\u0066\u0069\u006e\u0065\u0064");};var (_eeag uint8 ;_eegef _ada .Image ;_bbab error ;);if bwThreshold ==JB2ImageAutoThreshold {_eegef ,_bbab =_ada .MonochromeConverter .Convert (i );}else if bwThreshold > 1.0||bwThreshold < 0.0{return nil ,_cf .Error (_bdcd ,"p\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074h\u0072\u0065\u0073\u0068\u006f\u006c\u0064 i\u0073\u0020\u006e\u006ft\u0020\u0069\u006e\u0020\u0061\u0020\u0072\u0061\u006ege\u0020\u007b0\u002e\u0030\u002c\u0020\u0031\u002e\u0030\u007d");}else {_eeag =uint8 (255*bwThreshold );_eegef ,_bbab =_ada .MonochromeThresholdConverter (_eeag ).Convert (i );};if _bbab !=nil {return nil ,_bbab ;};return _gffb (_eegef ),nil ;};

// StreamEncoder represents the interface for all PDF stream encoders.
type StreamEncoder interface{GetFilterName ()string ;MakeDecodeParams ()PdfObject ;MakeStreamDict ()*PdfObjectDictionary ;UpdateParams (_dcfg *PdfObjectDictionary );EncodeBytes (_gga []byte )([]byte ,error );DecodeBytes (_abcg []byte )([]byte ,error );DecodeStream (_fbd *PdfObjectStream )([]byte ,error );};

// PdfParser parses a PDF file and provides access to the object structure of the PDF.
type PdfParser struct{_dbcd Version ;_egfc _gb .ReadSeeker ;_bfbbd *_adg .Reader ;_geef int64 ;_dgag XrefTable ;_aafc int64 ;_eaea *xrefType ;_eadd objectStreams ;_agac *PdfObjectDictionary ;_egc *PdfCrypt ;_fffe bool ;ObjCache objectCache ;_dfda map[int64 ]bool ;};

// EncodeImage encodes 'img' golang image.Image into jbig2 encoded bytes document using default encoder settings.
func (_cdbeb *JBIG2Encoder )EncodeImage (img _cg .Image )([]byte ,error ){return _cdbeb .encodeImage (img );};

// GetFloat returns the *PdfObjectFloat represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetFloat (obj PdfObject )(_fagbb *PdfObjectFloat ,_dcfaf bool ){_fagbb ,_dcfaf =TraceToDirectObject (obj ).(*PdfObjectFloat );return _fagbb ,_dcfaf ;};

// Bytes returns the PdfObjectString content as a []byte array.
func (_dbce *PdfObjectString )Bytes ()[]byte {return []byte (_dbce ._eagc )};

// DecodeStream decodes the stream data and returns the decoded data.
// An error is returned upon failure.
func DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_cd .Log .Trace ("\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_edbb ,_ecec :=NewEncoderFromStream (streamObj );if _ecec !=nil {_cd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_ecec );return nil ,_ecec ;};_cd .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076\u000a",_edbb );_fafb ,_ecec :=_edbb .DecodeStream (streamObj );if _ecec !=nil {_cd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_ecec );return nil ,_ecec ;};return _fafb ,nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_cfae *FlateEncoder )UpdateParams (params *PdfObjectDictionary ){_febf ,_dba :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _dba ==nil {_cfae .Predictor =int (_febf );};_ccb ,_dba :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _dba ==nil {_cfae .BitsPerComponent =int (_ccb );};_dacd ,_dba :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _dba ==nil {_cfae .Columns =int (_dacd );};_ggba ,_dba :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _dba ==nil {_cfae .Colors =int (_ggba );};};

// ASCIIHexEncoder implements ASCII hex encoder/decoder.
type ASCIIHexEncoder struct{};

// DecodeStream decodes a JBIG2 encoded stream and returns the result as a slice of bytes.
func (_fgef *JBIG2Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _fgef .DecodeBytes (streamObj .Stream );};func (_gdgf *PdfCrypt )encryptBytes (_gef []byte ,_ecfd string ,_fcde []byte )([]byte ,error ){_cd .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");_ecd ,_cca :=_gdgf ._bee [_ecfd ];if !_cca {return nil ,_aa .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_ecfd );};return _ecd .EncryptBytes (_gef ,_fcde );};

// MakeFloat creates an PdfObjectFloat from a float64.
func MakeFloat (val float64 )*PdfObjectFloat {_eagb :=PdfObjectFloat (val );return &_eagb };func (_cafce *PdfParser )rebuildXrefTable ()error {_dbfa :=XrefTable {};_dbfa .ObjectMap =map[int ]XrefObject {};for _cdca ,_dgcg :=range _cafce ._dgag .ObjectMap {_cffa ,_ ,_adef :=_cafce .lookupByNumberWrapper (_cdca ,false );if _adef !=nil {_cd .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020U\u006e\u0061\u0062\u006ce t\u006f l\u006f\u006f\u006b\u0020\u0075\u0070\u0020ob\u006a\u0065\u0063\u0074\u0020\u0028\u0025s\u0029",_adef );_cd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0063\u006fm\u0070\u006c\u0065\u0074\u0065\u006c\u0079\u0020\u0062\u0072\u006f\u006b\u0065\u006e\u0020\u002d\u0020\u0061\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0074\u006f \u0072\u0065\u0070\u0061\u0069r\u0020");_cagbg ,_fbdb :=_cafce .repairRebuildXrefsTopDown ();if _fbdb !=nil {_cd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0072\u0065\u0062\u0075\u0069l\u0064\u0020\u0072\u0065\u0070a\u0069\u0072 \u0028\u0025\u0073\u0029",_fbdb );return _fbdb ;};_cafce ._dgag =*_cagbg ;_cd .Log .Debug ("\u0052e\u0070\u0061\u0069\u0072e\u0064\u0020\u0078\u0072\u0065f\u0020t\u0061b\u006c\u0065\u0020\u0062\u0075\u0069\u006ct");return nil ;};_bdgce ,_ggega ,_adef :=_dgbd (_cffa );if _adef !=nil {return _adef ;};_dgcg .ObjectNumber =int (_bdgce );_dgcg .Generation =int (_ggega );_dbfa .ObjectMap [int (_bdgce )]=_dgcg ;};_cafce ._dgag =_dbfa ;_cd .Log .Debug ("N\u0065w\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061b\u006c\u0065\u0020\u0062ui\u006c\u0074");_agf (_cafce ._dgag );return nil ;};

// DecodeBytes decodes byte array with ASCII85. 5 ASCII characters -> 4 raw binary bytes
func (_baf *ASCII85Encoder )DecodeBytes (encoded []byte )([]byte ,error ){var _dbc []byte ;_cd .Log .Trace ("\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0020\u0044e\u0063\u006f\u0064\u0065");_gbdd :=0;_fbfb :=false ;for _gbdd < len (encoded )&&!_fbfb {_dgfa :=[5]byte {0,0,0,0,0};_ddca :=0;_deeb :=0;_eca :=4;for _deeb < 5+_ddca {if _gbdd +_deeb ==len (encoded ){break ;};_abcd :=encoded [_gbdd +_deeb ];if IsWhiteSpace (_abcd ){_ddca ++;_deeb ++;continue ;}else if _abcd =='~'&&_gbdd +_deeb +1< len (encoded )&&encoded [_gbdd +_deeb +1]=='>'{_eca =(_deeb -_ddca )-1;if _eca < 0{_eca =0;};_fbfb =true ;break ;}else if _abcd >='!'&&_abcd <='u'{_abcd -='!';}else if _abcd =='z'&&_deeb -_ddca ==0{_eca =4;_deeb ++;break ;}else {_cd .Log .Error ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u002c\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020co\u0064\u0065");return nil ,_f .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0063\u006f\u0064\u0065\u0020e\u006e\u0063\u006f\u0075\u006e\u0074\u0065\u0072\u0065\u0064");};_dgfa [_deeb -_ddca ]=_abcd ;_deeb ++;};_gbdd +=_deeb ;for _fcea :=_eca +1;_fcea < 5;_fcea ++{_dgfa [_fcea ]=84;};_ecdb :=uint32 (_dgfa [0])*85*85*85*85+uint32 (_dgfa [1])*85*85*85+uint32 (_dgfa [2])*85*85+uint32 (_dgfa [3])*85+uint32 (_dgfa [4]);_bgaf :=[]byte {byte ((_ecdb >>24)&0xff),byte ((_ecdb >>16)&0xff),byte ((_ecdb >>8)&0xff),byte (_ecdb &0xff)};_dbc =append (_dbc ,_bgaf [:_eca ]...);};_cd .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0065\u006e\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",encoded );_cd .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0064\u0065\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",_dbc );return _dbc ,nil ;};const (XrefTypeTableEntry xrefType =iota ;XrefTypeObjectStream xrefType =iota ;);

// Keys returns the list of keys in the dictionary.
// If `d` is nil returns a nil slice.
func (_cbcd *PdfObjectDictionary )Keys ()[]PdfObjectName {if _cbcd ==nil {return nil ;};return _cbcd ._aedd ;};func _ccebf (_bfd *PdfObjectDictionary )(_ebca *_ada .ImageBase ){var (_gaad *PdfObjectInteger ;_becd bool ;);if _gaad ,_becd =_bfd .Get ("\u0057\u0069\u0064t\u0068").(*PdfObjectInteger );_becd {_ebca =&_ada .ImageBase {Width :int (*_gaad )};}else {return nil ;};if _gaad ,_becd =_bfd .Get ("\u0048\u0065\u0069\u0067\u0068\u0074").(*PdfObjectInteger );_becd {_ebca .Height =int (*_gaad );};if _gaad ,_becd =_bfd .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074").(*PdfObjectInteger );_becd {_ebca .BitsPerComponent =int (*_gaad );};if _gaad ,_becd =_bfd .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073").(*PdfObjectInteger );_becd {_ebca .ColorComponents =int (*_gaad );};return _ebca ;};

// MakeInteger creates a PdfObjectInteger from an int64.
func MakeInteger (val int64 )*PdfObjectInteger {_gdea :=PdfObjectInteger (val );return &_gdea };func (_fcfg *PdfParser )readTextLine ()(string ,error ){var _dadd _dgb .Buffer ;for {_ffeg ,_aebd :=_fcfg ._bfbbd .Peek (1);if _aebd !=nil {_cd .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_aebd .Error ());return _dadd .String (),_aebd ;};if (_ffeg [0]!='\r')&&(_ffeg [0]!='\n'){_aaag ,_ :=_fcfg ._bfbbd .ReadByte ();_dadd .WriteByte (_aaag );}else {break ;};};return _dadd .String (),nil ;};func (_ecgd *PdfParser )parseName ()(PdfObjectName ,error ){var _dbfc _dgb .Buffer ;_bgdae :=false ;for {_gebc ,_eeac :=_ecgd ._bfbbd .Peek (1);if _eeac ==_gb .EOF {break ;};if _eeac !=nil {return PdfObjectName (_dbfc .String ()),_eeac ;};if !_bgdae {if _gebc [0]=='/'{_bgdae =true ;_ecgd ._bfbbd .ReadByte ();}else if _gebc [0]=='%'{_ecgd .readComment ();_ecgd .skipSpaces ();}else {_cd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020N\u0061\u006d\u0065\u0020\u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020w\u0069\u0074\u0068\u0020\u0025\u0073\u0020(\u0025\u0020\u0078\u0029",_gebc ,_gebc );return PdfObjectName (_dbfc .String ()),_aa .Errorf ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u006ea\u006d\u0065:\u0020\u0028\u0025\u0063\u0029",_gebc [0]);};}else {if IsWhiteSpace (_gebc [0]){break ;}else if (_gebc [0]=='/')||(_gebc [0]=='[')||(_gebc [0]=='(')||(_gebc [0]==']')||(_gebc [0]=='<')||(_gebc [0]=='>'){break ;}else if _gebc [0]=='#'{_ffgaef ,_bcgf :=_ecgd ._bfbbd .Peek (3);if _bcgf !=nil {return PdfObjectName (_dbfc .String ()),_bcgf ;};_debc ,_bcgf :=_gba .DecodeString (string (_ffgaef [1:3]));if _bcgf !=nil {_cd .Log .Debug ("\u0045\u0052\u0052\u004fR\u003a\u0020\u0049\u006ev\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0066o\u006c\u006co\u0077\u0069\u006e\u0067 \u0027\u0023\u0027\u002c \u0063\u006f\u006e\u0074\u0069n\u0075\u0069\u006e\u0067\u0020\u0075\u0073i\u006e\u0067\u0020\u006c\u0069t\u0065\u0072\u0061\u006c\u0020\u002d\u0020\u004f\u0075t\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074");_dbfc .WriteByte ('#');_ecgd ._bfbbd .Discard (1);continue ;};_ecgd ._bfbbd .Discard (3);_dbfc .Write (_debc );}else {_fdfaf ,_ :=_ecgd ._bfbbd .ReadByte ();_dbfc .WriteByte (_fdfaf );};};};return PdfObjectName (_dbfc .String ()),nil ;};

// ParseIndirectObject parses an indirect object from the input stream. Can also be an object stream.
// Returns the indirect object (*PdfIndirectObject) or the stream object (*PdfObjectStream).
func (_ccda *PdfParser )ParseIndirectObject ()(PdfObject ,error ){_agcgf :=PdfIndirectObject {};_agcgf ._dbca =_ccda ;_cd .Log .Trace ("\u002dR\u0065a\u0064\u0020\u0069\u006e\u0064i\u0072\u0065c\u0074\u0020\u006f\u0062\u006a");_fbea ,_fffef :=_ccda ._bfbbd .Peek (20);if _fffef !=nil {if _fffef !=_gb .EOF {_cd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020r\u0065a\u0064\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a");return &_agcgf ,_fffef ;};};_cd .Log .Trace ("\u0028\u0069\u006edi\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_fbea ));_ebcf :=_geeb .FindStringSubmatchIndex (string (_fbea ));if len (_ebcf )< 6{if _fffef ==_gb .EOF {return nil ,_fffef ;};_cd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_fbea ));return &_agcgf ,_f .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");};_ccda ._bfbbd .Discard (_ebcf [0]);_cd .Log .Trace ("O\u0066\u0066\u0073\u0065\u0074\u0073\u0020\u0025\u0020\u0064",_ebcf );_bebe :=_ebcf [1]-_ebcf [0];_gffa :=make ([]byte ,_bebe );_ ,_fffef =_ccda .ReadAtLeast (_gffa ,_bebe );if _fffef !=nil {_cd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u0072\u0065\u0061\u0064\u0020-\u0020\u0025\u0073",_fffef );return nil ,_fffef ;};_cd .Log .Trace ("\u0074\u0065\u0078t\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_gffa );_fcbd :=_geeb .FindStringSubmatch (string (_gffa ));if len (_fcbd )< 3{_cd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_gffa ));return &_agcgf ,_f .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");};_ddec ,_ :=_d .Atoi (_fcbd [1]);_fbda ,_ :=_d .Atoi (_fcbd [2]);_agcgf .ObjectNumber =int64 (_ddec );_agcgf .GenerationNumber =int64 (_fbda );for {_gdgb ,_abeb :=_ccda ._bfbbd .Peek (2);if _abeb !=nil {return &_agcgf ,_abeb ;};_cd .Log .Trace ("I\u006ed\u002e\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_gdgb ),string (_gdgb ));if IsWhiteSpace (_gdgb [0]){_ccda .skipSpaces ();}else if _gdgb [0]=='%'{_ccda .skipComments ();}else if (_gdgb [0]=='<')&&(_gdgb [1]=='<'){_cd .Log .Trace ("\u0043\u0061\u006c\u006c\u0020\u0050\u0061\u0072\u0073e\u0044\u0069\u0063\u0074");_agcgf .PdfObject ,_abeb =_ccda .ParseDict ();_cd .Log .Trace ("\u0045\u004f\u0046\u0020Ca\u006c\u006c\u0020\u0050\u0061\u0072\u0073\u0065\u0044\u0069\u0063\u0074\u003a\u0020%\u0076",_abeb );if _abeb !=nil {return &_agcgf ,_abeb ;};_cd .Log .Trace ("\u0050\u0061\u0072\u0073\u0065\u0064\u0020\u0064\u0069\u0063t\u0069\u006f\u006e\u0061\u0072\u0079\u002e.\u002e\u0020\u0066\u0069\u006e\u0069\u0073\u0068\u0065\u0064\u002e");}else if (_gdgb [0]=='/')||(_gdgb [0]=='(')||(_gdgb [0]=='[')||(_gdgb [0]=='<'){_agcgf .PdfObject ,_abeb =_ccda .parseObject ();if _abeb !=nil {return &_agcgf ,_abeb ;};_cd .Log .Trace ("P\u0061\u0072\u0073\u0065\u0064\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u002e\u002e\u002e \u0066\u0069\u006ei\u0073h\u0065\u0064\u002e");}else if _gdgb [0]==']'{_cd .Log .Debug ("\u0057\u0041\u0052\u004e\u0049N\u0047\u003a\u0020\u0027\u005d\u0027 \u0063\u0068\u0061\u0072\u0061\u0063\u0074e\u0072\u0020\u006eo\u0074\u0020\u0062\u0065i\u006e\u0067\u0020\u0075\u0073\u0065d\u0020\u0061\u0073\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006e\u0064\u0069n\u0067\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e");_ccda ._bfbbd .Discard (1);}else {if _gdgb [0]=='e'{_aega ,_daba :=_ccda .readTextLine ();if _daba !=nil {return nil ,_daba ;};if len (_aega )>=6&&_aega [0:6]=="\u0065\u006e\u0064\u006f\u0062\u006a"{break ;};}else if _gdgb [0]=='s'{_gdgb ,_ =_ccda ._bfbbd .Peek (10);if string (_gdgb [:6])=="\u0073\u0074\u0072\u0065\u0061\u006d"{_eagg :=6;if len (_gdgb )> 6{if IsWhiteSpace (_gdgb [_eagg ])&&_gdgb [_eagg ]!='\r'&&_gdgb [_eagg ]!='\n'{_cd .Log .Debug ("\u004e\u006fn\u002d\u0063\u006f\u006e\u0066\u006f\u0072\u006d\u0061\u006e\u0074\u0020\u0050\u0044\u0046\u0020\u006e\u006f\u0074 \u0065\u006e\u0064\u0069\u006e\u0067 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0069\u006e\u0065\u0020\u0070\u0072o\u0070\u0065r\u006c\u0079\u0020\u0077i\u0074\u0068\u0020\u0045\u004fL\u0020\u006d\u0061\u0072\u006b\u0065\u0072");_eagg ++;};if _gdgb [_eagg ]=='\r'{_eagg ++;if _gdgb [_eagg ]=='\n'{_eagg ++;};}else if _gdgb [_eagg ]=='\n'{_eagg ++;};};_ccda ._bfbbd .Discard (_eagg );_abag ,_gfda :=_agcgf .PdfObject .(*PdfObjectDictionary );if !_gfda {return nil ,_f .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006di\u0073s\u0069\u006e\u0067\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_cd .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0069c\u0074\u0020\u0025\u0073",_abag );_gfef ,_cfbe :=_ccda .traceStreamLength (_abag .Get ("\u004c\u0065\u006e\u0067\u0074\u0068"));if _cfbe !=nil {_cd .Log .Debug ("\u0046\u0061\u0069l\u0020\u0074\u006f\u0020t\u0072\u0061\u0063\u0065\u0020\u0073\u0074r\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0025\u0076",_cfbe );return nil ,_cfbe ;};_cd .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_gfef );_egfb ,_fbfbg :=_gfef .(*PdfObjectInteger );if !_fbfbg {return nil ,_f .New ("\u0073\u0074re\u0061\u006d\u0020l\u0065\u006e\u0067\u0074h n\u0065ed\u0073\u0020\u0074\u006f\u0020\u0062\u0065 a\u006e\u0020\u0069\u006e\u0074\u0065\u0067e\u0072");};_agfbda :=*_egfb ;if _agfbda < 0{return nil ,_f .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006e\u0065\u0065\u0064\u0073\u0020\u0074\u006f \u0062e\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0030");};_cece :=_ccda .GetFileOffset ();_fbdfe :=_ccda .xrefNextObjectOffset (_cece );if _cece +int64 (_agfbda )> _fbdfe &&_fbdfe > _cece {_cd .Log .Debug ("E\u0078\u0070\u0065\u0063te\u0064 \u0065\u006e\u0064\u0069\u006eg\u0020\u0061\u0074\u0020\u0025\u0064",_cece +int64 (_agfbda ));_cd .Log .Debug ("\u004e\u0065\u0078\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020\u0061t\u0020\u0025\u0064",_fbdfe );_bbec :=_fbdfe -_cece -17;if _bbec < 0{return nil ,_f .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020go\u0069\u006e\u0067 \u0070\u0061s\u0074\u0020\u0062\u006f\u0075\u006ed\u0061\u0072i\u0065\u0073");};_cd .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0061\u0020l\u0065\u006e\u0067\u0074\u0068\u0020c\u006f\u0072\u0072\u0065\u0063\u0074\u0069\u006f\u006e\u0020\u0074\u006f\u0020%\u0064\u002e\u002e\u002e",_bbec );_agfbda =PdfObjectInteger (_bbec );_abag .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (_bbec ));};if int64 (_agfbda )> _ccda ._geef {_cd .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0053t\u0072\u0065\u0061\u006d\u0020l\u0065\u006e\u0067\u0074\u0068\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u0061\u0072\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0066\u0069\u006c\u0065\u0020\u0073\u0069\u007a\u0065");return nil ,_f .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020la\u0072\u0067\u0065r\u0020\u0074h\u0061\u006e\u0020\u0066\u0069\u006ce\u0020\u0073i\u007a\u0065");};_cffdf :=make ([]byte ,_agfbda );_ ,_cfbe =_ccda .ReadAtLeast (_cffdf ,int (_agfbda ));if _cfbe !=nil {_cd .Log .Debug ("E\u0052\u0052\u004f\u0052 s\u0074r\u0065\u0061\u006d\u0020\u0028%\u0064\u0029\u003a\u0020\u0025\u0058",len (_cffdf ),_cffdf );_cd .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_cfbe );return nil ,_cfbe ;};_fadb :=PdfObjectStream {};_fadb .Stream =_cffdf ;_fadb .PdfObjectDictionary =_agcgf .PdfObject .(*PdfObjectDictionary );_fadb .ObjectNumber =_agcgf .ObjectNumber ;_fadb .GenerationNumber =_agcgf .GenerationNumber ;_fadb .PdfObjectReference ._dbca =_ccda ;_ccda .skipSpaces ();_ccda ._bfbbd .Discard (9);_ccda .skipSpaces ();return &_fadb ,nil ;};};_agcgf .PdfObject ,_abeb =_ccda .parseObject ();if _agcgf .PdfObject ==nil {_cd .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");_agcgf .PdfObject =MakeNull ();};return &_agcgf ,_abeb ;};};if _agcgf .PdfObject ==nil {_cd .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");_agcgf .PdfObject =MakeNull ();};_cd .Log .Trace ("\u0052\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0021");return &_agcgf ,nil ;};

// DecodeBytes decodes a slice of LZW encoded bytes and returns the result.
func (_gdeb *LZWEncoder )DecodeBytes (encoded []byte )([]byte ,error ){var _aeag _dgb .Buffer ;_bbgf :=_dgb .NewReader (encoded );var _ebc _gb .ReadCloser ;if _gdeb .EarlyChange ==1{_ebc =_dff .NewReader (_bbgf ,_dff .MSB ,8);}else {_ebc =_dg .NewReader (_bbgf ,_dg .MSB ,8);};defer _ebc .Close ();_ ,_adgbd :=_aeag .ReadFrom (_ebc );if _adgbd !=nil {return nil ,_adgbd ;};return _aeag .Bytes (),nil ;};

// Decoded returns the PDFDocEncoding or UTF-16BE decoded string contents.
// UTF-16BE is applied when the first two bytes are 0xFE, 0XFF, otherwise decoding of
// PDFDocEncoding is performed.
func (_cacb *PdfObjectString )Decoded ()string {if _cacb ==nil {return "";};_egeba :=[]byte (_cacb ._eagc );if len (_egeba )>=2&&_egeba [0]==0xFE&&_egeba [1]==0xFF{return _fe .UTF16ToString (_egeba [2:]);};return _fe .PDFDocEncodingToString (_egeba );};

// DecodeBytes decodes a byte slice from Run length encoding.
//
// 7.4.5 RunLengthDecode Filter
// The RunLengthDecode filter decodes data that has been encoded in a simple byte-oriented format based on run length.
// The encoded data shall be a sequence of runs, where each run shall consist of a length byte followed by 1 to 128
// bytes of data. If the length byte is in the range 0 to 127, the following length + 1 (1 to 128) bytes shall be
// copied literally during decompression. If length is in the range 129 to 255, the following single byte shall be
// copied 257 - length (2 to 128) times during decompression. A length value of 128 shall denote EOD.
func (_badc *RunLengthEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_aff :=_dgb .NewReader (encoded );var _bcgb []byte ;for {_ffda ,_cacf :=_aff .ReadByte ();if _cacf !=nil {return nil ,_cacf ;};if _ffda > 128{_beea ,_abbf :=_aff .ReadByte ();if _abbf !=nil {return nil ,_abbf ;};for _cecb :=0;_cecb < 257-int (_ffda );_cecb ++{_bcgb =append (_bcgb ,_beea );};}else if _ffda < 128{for _bfee :=0;_bfee < int (_ffda )+1;_bfee ++{_dgee ,_aded :=_aff .ReadByte ();if _aded !=nil {return nil ,_aded ;};_bcgb =append (_bcgb ,_dgee );};}else {break ;};};return _bcgb ,nil ;};

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_cgcc *FlateEncoder )EncodeBytes (data []byte )([]byte ,error ){if _cgcc .Predictor !=1&&_cgcc .Predictor !=11{_cd .Log .Debug ("E\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0046\u006c\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065r\u0020P\u0072\u0065\u0064\u0069c\u0074\u006fr\u0020\u003d\u0020\u0031\u002c\u0020\u0031\u0031\u0020\u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");return nil ,ErrUnsupportedEncodingParameters ;};if _cgcc .Predictor ==11{_fedd :=int (_cgcc .Columns );_gbg :=len (data )/_fedd ;if len (data )%_fedd !=0{_cd .Log .Error ("\u0049n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");return nil ,_f .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");};_bad :=_dgb .NewBuffer (nil );_abgd :=make ([]byte ,_fedd );for _fedda :=0;_fedda < _gbg ;_fedda ++{_ffdc :=data [_fedd *_fedda :_fedd *(_fedda +1)];_abgd [0]=_ffdc [0];for _ddbf :=1;_ddbf < _fedd ;_ddbf ++{_abgd [_ddbf ]=byte (int (_ffdc [_ddbf ]-_ffdc [_ddbf -1])%256);};_bad .WriteByte (1);_bad .Write (_abgd );};data =_bad .Bytes ();};var _dged _dgb .Buffer ;_dgec :=_dc .NewWriter (&_dged );_dgec .Write (data );_dgec .Close ();return _dged .Bytes (),nil ;};

// GetParser returns the parser for lazy-loading or compare references.
func (_afbe *PdfObjectReference )GetParser ()*PdfParser {return _afbe ._dbca };

// String returns a string describing `stream`.
func (_cfab *PdfObjectStream )String ()string {return _aa .Sprintf ("O\u0062j\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0025\u0064: \u0025\u0073",_cfab .ObjectNumber ,_cfab .PdfObjectDictionary );};

// PdfObjectFloat represents the primitive PDF floating point numerical object.
type PdfObjectFloat float64 ;

// MakeObjectStreams creates an PdfObjectStreams from a list of PdfObjects.
func MakeObjectStreams (objects ...PdfObject )*PdfObjectStreams {_cgfd :=&PdfObjectStreams {};_cgfd ._gcdd =[]PdfObject {};for _ ,_gaeag :=range objects {_cgfd ._gcdd =append (_cgfd ._gcdd ,_gaeag );};return _cgfd ;};func _adcbg (_eefa PdfObject )(*float64 ,error ){switch _cfbb :=_eefa .(type ){case *PdfObjectFloat :_fdgg :=float64 (*_cfbb );return &_fdgg ,nil ;case *PdfObjectInteger :_cgae :=float64 (*_cfbb );return &_cgae ,nil ;case *PdfObjectNull :return nil ,nil ;};return nil ,ErrNotANumber ;};

// UpdateParams updates the parameter values of the encoder.
func (_eadeb *ASCIIHexEncoder )UpdateParams (params *PdfObjectDictionary ){};

// UpdateParams updates the parameter values of the encoder.
func (_agae *RunLengthEncoder )UpdateParams (params *PdfObjectDictionary ){};

// GetNumberAsFloat returns the contents of `obj` as a float if it is an integer or float, or an
// error if it isn't.
func GetNumberAsFloat (obj PdfObject )(float64 ,error ){switch _bgee :=obj .(type ){case *PdfObjectFloat :return float64 (*_bgee ),nil ;case *PdfObjectInteger :return float64 (*_bgee ),nil ;};return 0,ErrNotANumber ;};

// EncodeBytes implements support for LZW encoding.  Currently not supporting predictors (raw compressed data only).
// Only supports the Early change = 1 algorithm (compress/lzw) as the other implementation
// does not have a write method.
// TODO: Consider refactoring compress/lzw to allow both.
func (_bbdbe *LZWEncoder )EncodeBytes (data []byte )([]byte ,error ){if _bbdbe .Predictor !=1{return nil ,_aa .Errorf ("\u004c\u005aW \u0050\u0072\u0065d\u0069\u0063\u0074\u006fr =\u00201 \u006f\u006e\u006c\u0079\u0020\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0079e\u0074");};if _bbdbe .EarlyChange ==1{return nil ,_aa .Errorf ("\u004c\u005a\u0057\u0020\u0045\u0061\u0072\u006c\u0079\u0020\u0043\u0068\u0061n\u0067\u0065\u0020\u003d\u0020\u0030 \u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0079\u0065\u0074");};var _ceef _dgb .Buffer ;_fbfc :=_dg .NewWriter (&_ceef ,_dg .MSB ,8);_fbfc .Write (data );_fbfc .Close ();return _ceef .Bytes (),nil ;};

// NewParserFromString is used for testing purposes.
func NewParserFromString (txt string )*PdfParser {_degbg :=_dgb .NewReader ([]byte (txt ));_abdb :=&PdfParser {ObjCache :objectCache {},_egfc :_degbg ,_bfbbd :_adg .NewReader (_degbg ),_geef :int64 (len (txt )),_dfda :map[int64 ]bool {}};_abdb ._dgag .ObjectMap =make (map[int ]XrefObject );return _abdb ;};const (JB2Generic JBIG2CompressionType =iota ;JB2SymbolCorrelation ;JB2SymbolRankHaus ;);

// NewCCITTFaxEncoder makes a new CCITTFax encoder.
func NewCCITTFaxEncoder ()*CCITTFaxEncoder {return &CCITTFaxEncoder {Columns :1728,EndOfBlock :true }};func (_cagd *PdfParser )inspect ()(map[string ]int ,error ){_cd .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0053P\u0045\u0043\u0054\u0020\u002d\u002d\u002d\u002d\u002d\u002d-\u002d\u002d\u002d");_cd .Log .Trace ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");_fga :=map[string ]int {};_bffc :=0;_ebbd :=0;var _ddggd []int ;for _eebga :=range _cagd ._dgag .ObjectMap {_ddggd =append (_ddggd ,_eebga );};_g .Ints (_ddggd );_acca :=0;for _ ,_bcbe :=range _ddggd {_efgdg :=_cagd ._dgag .ObjectMap [_bcbe ];if _efgdg .ObjectNumber ==0{continue ;};_bffc ++;_cd .Log .Trace ("\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d");_cd .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0075\u0070\u0020\u006f\u0062\u006a\u0065c\u0074 \u006e\u0075\u006d\u0062\u0065\u0072\u003a \u0025\u0064",_efgdg .ObjectNumber );_ggbe ,_bfbbg :=_cagd .LookupByNumber (_efgdg .ObjectNumber );if _bfbbg !=nil {_cd .Log .Trace ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u006c\u006f\u006f\u006b\u0075p\u0020\u006f\u0062\u006a\u0020\u0025\u0064 \u0028\u0025\u0073\u0029",_efgdg .ObjectNumber ,_bfbbg );_ebbd ++;continue ;};_cd .Log .Trace ("\u006fb\u006a\u003a\u0020\u0025\u0073",_ggbe );_gbgf ,_cdgcb :=_ggbe .(*PdfIndirectObject );if _cdgcb {_cd .Log .Trace ("\u0049N\u0044 \u004f\u004f\u0042\u004a\u0020\u0025\u0064\u003a\u0020\u0025\u0073",_efgdg .ObjectNumber ,_gbgf );_dbfab ,_faec :=_gbgf .PdfObject .(*PdfObjectDictionary );if _faec {if _agef ,_ecgf :=_dbfab .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_ecgf {_ecdbg :=string (*_agef );_cd .Log .Trace ("\u002d\u002d\u002d\u003e\u0020\u004f\u0062\u006a\u0020\u0074\u0079\u0070e\u003a\u0020\u0025\u0073",_ecdbg );_ ,_eaba :=_fga [_ecdbg ];if _eaba {_fga [_ecdbg ]++;}else {_fga [_ecdbg ]=1;};}else if _aegf ,_fcbaf :=_dbfab .Get ("\u0053u\u0062\u0074\u0079\u0070\u0065").(*PdfObjectName );_fcbaf {_abebf :=string (*_aegf );_cd .Log .Trace ("-\u002d-\u003e\u0020\u004f\u0062\u006a\u0020\u0073\u0075b\u0074\u0079\u0070\u0065: \u0025\u0073",_abebf );_ ,_cdbeg :=_fga [_abebf ];if _cdbeg {_fga [_abebf ]++;}else {_fga [_abebf ]=1;};};if _gacc ,_ggc :=_dbfab .Get ("\u0053").(*PdfObjectName );_ggc &&*_gacc =="\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"{_ ,_accf :=_fga ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"];if _accf {_fga ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]++;}else {_fga ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]=1;};};};}else if _cfdbc ,_cacg :=_ggbe .(*PdfObjectStream );_cacg {if _bcbdd ,_bdggg :=_cfdbc .PdfObjectDictionary .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_bdggg {_cd .Log .Trace ("\u002d\u002d\u003e\u0020\u0053\u0074\u0072\u0065\u0061\u006d\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073",*_bcbdd );_dbda :=string (*_bcbdd );if _ ,_fafbe :=_fga [_dbda ];_fafbe {_fga [_dbda ]++;}else {_fga [_dbda ]=1;};};}else {_gfagc ,_agddc :=_ggbe .(*PdfObjectDictionary );if _agddc {_fcgf ,_fgbd :=_gfagc .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if _fgbd {_defe :=string (*_fcgf );_cd .Log .Trace ("\u002d-\u002d \u006f\u0062\u006a\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073",_defe );_fga [_defe ]++;};};_cd .Log .Trace ("\u0044\u0049\u0052\u0045\u0043\u0054\u0020\u004f\u0042\u004a\u0020\u0025d\u003a\u0020\u0025\u0073",_efgdg .ObjectNumber ,_ggbe );};_acca ++;};_cd .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0045\u004fF\u0020\u0049\u004e\u0053\u0050\u0045\u0043T\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d");_cd .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");_cd .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074 \u0063\u006f\u0075\u006e\u0074\u003a\u0020\u0025\u0064",_bffc );_cd .Log .Trace ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u006f\u006b\u0075p\u003a\u0020\u0025\u0064",_ebbd );for _ecfcb ,_edfc :=range _fga {_cd .Log .Trace ("\u0025\u0073\u003a\u0020\u0025\u0064",_ecfcb ,_edfc );};_cd .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");if len (_cagd ._dgag .ObjectMap )< 1{_cd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0068\u0069\u0073 \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074 \u0069s\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0028\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0021\u0029");return nil ,_aa .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0064\u006fc\u0075\u006d\u0065\u006e\u0074\u0020\u0028\u0078r\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006d\u0069\u0073s\u0069\u006e\u0067\u0029");};_cfbg ,_efabg :=_fga ["\u0046\u006f\u006e\u0074"];if !_efabg ||_cfbg < 2{_cd .Log .Trace ("\u0054\u0068\u0069s \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020i\u0073 \u0070r\u006fb\u0061\u0062\u006c\u0079\u0020\u0073\u0063\u0061\u006e\u006e\u0065\u0064\u0021");}else {_cd .Log .Trace ("\u0054\u0068\u0069\u0073\u0020\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020\u0069\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0066o\u0072\u0020\u0065\u0078\u0074r\u0061\u0063t\u0069\u006f\u006e\u0021");};return _fga ,nil ;};func _agf (_gcc XrefTable ){_cd .Log .Debug ("\u003dX\u003d\u0058\u003d\u0058\u003d");_cd .Log .Debug ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");_cee :=0;for _ ,_bbde :=range _gcc .ObjectMap {_cd .Log .Debug ("i\u002b\u0031\u003a\u0020\u0025\u0064 \u0028\u006f\u0062\u006a\u0020\u006eu\u006d\u003a\u0020\u0025\u0064\u0020\u0067e\u006e\u003a\u0020\u0025\u0064\u0029\u0020\u002d\u003e\u0020%\u0064",_cee +1,_bbde .ObjectNumber ,_bbde .Generation ,_bbde .Offset );_cee ++;};};func _egcca ()string {return _cd .Version };

// Elements returns a slice of the PdfObject elements in the array.
// Preferred over accessing the array directly as type may be changed in future major versions (v3).
func (_affec *PdfObjectStreams )Elements ()[]PdfObject {if _affec ==nil {return nil ;};return _affec ._gcdd ;};

// GetIntVal returns the int value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetIntVal (obj PdfObject )(_fagbf int ,_caab bool ){_edbc ,_caab :=TraceToDirectObject (obj ).(*PdfObjectInteger );if _caab &&_edbc !=nil {return int (*_edbc ),true ;};return 0,false ;};

// NewFlateEncoder makes a new flate encoder with default parameters, predictor 1 and bits per component 8.
func NewFlateEncoder ()*FlateEncoder {_edc :=&FlateEncoder {};_edc .Predictor =1;_edc .BitsPerComponent =8;_edc .Colors =1;_edc .Columns =1;return _edc ;};

// ReadAtLeast reads at least n bytes into slice p.
// Returns the number of bytes read (should always be == n), and an error on failure.
func (_egeb *PdfParser )ReadAtLeast (p []byte ,n int )(int ,error ){_abee :=n ;_bead :=0;_bdegc :=0;for _abee > 0{_fcdfb ,_bgff :=_egeb ._bfbbd .Read (p [_bead :]);if _bgff !=nil {_cd .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061d\u0069\u006e\u0067\u0020\u0028\u0025\u0064\u003b\u0025\u0064\u0029\u0020\u0025\u0073",_fcdfb ,_bdegc ,_bgff .Error ());return _bead ,_f .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065a\u0064\u0069\u006e\u0067");};_bdegc ++;_bead +=_fcdfb ;_abee -=_fcdfb ;};return _bead ,nil ;};

// ParseDict reads and parses a PDF dictionary object enclosed with '<<' and '>>'
func (_deac *PdfParser )ParseDict ()(*PdfObjectDictionary ,error ){_cd .Log .Trace ("\u0052\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020D\u0069\u0063\u0074\u0021");_bbga :=MakeDict ();_bbga ._fbdgf =_deac ;_fagb ,_ :=_deac ._bfbbd .ReadByte ();if _fagb !='<'{return nil ,_f .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");};_fagb ,_ =_deac ._bfbbd .ReadByte ();if _fagb !='<'{return nil ,_f .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");};for {_deac .skipSpaces ();_deac .skipComments ();_ecef ,_bcbc :=_deac ._bfbbd .Peek (2);if _bcbc !=nil {return nil ,_bcbc ;};_cd .Log .Trace ("D\u0069c\u0074\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_ecef ),string (_ecef ));if (_ecef [0]=='>')&&(_ecef [1]=='>'){_cd .Log .Trace ("\u0045\u004f\u0046\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");_deac ._bfbbd .ReadByte ();_deac ._bfbbd .ReadByte ();break ;};_cd .Log .Trace ("\u0050a\u0072s\u0065\u0020\u0074\u0068\u0065\u0020\u006e\u0061\u006d\u0065\u0021");_bdcac ,_bcbc :=_deac .parseName ();_cd .Log .Trace ("\u004be\u0079\u003a\u0020\u0025\u0073",_bdcac );if _bcbc !=nil {_cd .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0052e\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006ea\u006d\u0065\u0020e\u0072r\u0020\u0025\u0073",_bcbc );return nil ,_bcbc ;};if len (_bdcac )> 4&&_bdcac [len (_bdcac )-4:]=="\u006e\u0075\u006c\u006c"{_dadea :=_bdcac [0:len (_bdcac )-4];_cd .Log .Debug ("\u0054\u0061\u006b\u0069n\u0067\u0020\u0063\u0061\u0072\u0065\u0020\u006f\u0066\u0020n\u0075l\u006c\u0020\u0062\u0075\u0067\u0020\u0028%\u0073\u0029",_bdcac );_cd .Log .Debug ("\u004e\u0065\u0077\u0020ke\u0079\u0020\u0022\u0025\u0073\u0022\u0020\u003d\u0020\u006e\u0075\u006c\u006c",_dadea );_deac .skipSpaces ();_gdcf ,_ :=_deac ._bfbbd .Peek (1);if _gdcf [0]=='/'{_bbga .Set (_dadea ,MakeNull ());continue ;};};_deac .skipSpaces ();_fdeda ,_bcbc :=_deac .parseObject ();if _bcbc !=nil {return nil ,_bcbc ;};_bbga .Set (_bdcac ,_fdeda );if _cd .Log .IsLogLevel (_cd .LogLevelTrace ){_cd .Log .Trace ("\u0064\u0069\u0063\u0074\u005b\u0025\u0073\u005d\u0020\u003d\u0020\u0025\u0073",_bdcac ,_fdeda .String ());};};_cd .Log .Trace ("\u0072\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020\u0044\u0069\u0063\u0074\u0021");return _bbga ,nil ;};

// WriteString outputs the object as it is to be written to file.
func (_dcbdg *PdfIndirectObject )WriteString ()string {var _bafg _ed .Builder ;_bafg .WriteString (_d .FormatInt (_dcbdg .ObjectNumber ,10));_bafg .WriteString ("\u0020\u0030\u0020\u0052");return _bafg .String ();};

// GetFilterName returns the name of the encoding filter.
func (_eafb *ASCIIHexEncoder )GetFilterName ()string {return StreamEncodingFilterNameASCIIHex };func (_ceac *PdfParser )parseXrefStream (_daee *PdfObjectInteger )(*PdfObjectDictionary ,error ){if _daee !=nil {_cd .Log .Trace ("\u0058\u0052\u0065f\u0053\u0074\u006d\u0020x\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0061\u0074\u0020\u0025\u0064",_daee );_ceac ._egfc .Seek (int64 (*_daee ),_gb .SeekStart );_ceac ._bfbbd =_adg .NewReader (_ceac ._egfc );};_deacd :=_ceac .GetFileOffset ();_gegf ,_gafda :=_ceac .ParseIndirectObject ();if _gafda !=nil {_cd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072\u0065\u0061d\u0020\u0078\u0072\u0065\u0066\u0020\u006fb\u006a\u0065\u0063\u0074");return nil ,_f .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072e\u0061\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062j\u0065\u0063\u0074");};_cd .Log .Trace ("\u0058R\u0065f\u0053\u0074\u006d\u0020\u006fb\u006a\u0065c\u0074\u003a\u0020\u0025\u0073",_gegf );_gegbc ,_feddaa :=_gegf .(*PdfObjectStream );if !_feddaa {_cd .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0058R\u0065\u0066\u0053\u0074\u006d\u0020\u0070o\u0069\u006e\u0074\u0069\u006e\u0067 \u0074\u006f\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065a\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0021");return nil ,_f .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0070\u006f\u0069\u006e\u0074i\u006e\u0067\u0020\u0074\u006f\u0020a\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006fb\u006a\u0065\u0063\u0074");};_cfca :=_gegbc .PdfObjectDictionary ;_aggb ,_feddaa :=_gegbc .PdfObjectDictionary .Get ("\u0053\u0069\u007a\u0065").(*PdfObjectInteger );if !_feddaa {_cd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u004d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0073\u0069\u007a\u0065\u0020f\u0072\u006f\u006d\u0020\u0078\u0072\u0065f\u0020\u0073\u0074\u006d");return nil ,_f .New ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0053\u0069\u007ae\u0020\u0066\u0072\u006f\u006d\u0020\u0078\u0072\u0065\u0066 \u0073\u0074\u006d");};if int64 (*_aggb )> 8388607{_cd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u0053\u0069\u007a\u0065\u0020\u0065x\u0063\u0065\u0065\u0064\u0065\u0064\u0020l\u0069\u006d\u0069\u0074\u002c\u0020\u006f\u0076\u0065\u0072\u00208\u0033\u0038\u0038\u0036\u0030\u0037\u0020\u0028\u0025\u0064\u0029",*_aggb );return nil ,_f .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_cgfec :=_gegbc .PdfObjectDictionary .Get ("\u0057");_adff ,_feddaa :=_cgfec .(*PdfObjectArray );if !_feddaa {return nil ,_f .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0057\u0020\u0069\u006e\u0020x\u0072\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d");};_ffgd :=_adff .Len ();if _ffgd !=3{_cd .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020\u0028\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033\u0020\u002d\u0020\u0025\u0064\u0029",_ffgd );return nil ,_f .New ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065f\u0020s\u0074\u006d\u0020\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033");};var _bfeg []int64 ;for _dabg :=0;_dabg < 3;_dabg ++{_edaf ,_aegc :=GetInt (_adff .Get (_dabg ));if !_aegc {return nil ,_f .New ("i\u006e\u0076\u0061\u006cid\u0020w\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0074\u0079\u0070\u0065");};_bfeg =append (_bfeg ,int64 (*_edaf ));};_aeec ,_gafda :=DecodeStream (_gegbc );if _gafda !=nil {_cd .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020t\u006f \u0064e\u0063o\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u003a\u0020\u0025\u0076",_gafda );return nil ,_gafda ;};_ggga :=int (_bfeg [0]);_adafd :=int (_bfeg [0]+_bfeg [1]);_egdef :=int (_bfeg [0]+_bfeg [1]+_bfeg [2]);_edad :=int (_bfeg [0]+_bfeg [1]+_bfeg [2]);if _ggga < 0||_adafd < 0||_egdef < 0{_cd .Log .Debug ("\u0045\u0072\u0072\u006fr\u0020\u0073\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u003c \u0030 \u0028\u0025\u0064\u002c\u0025\u0064\u002c%\u0064\u0029",_ggga ,_adafd ,_egdef );return nil ,_f .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};if _edad ==0{_cd .Log .Debug ("\u004e\u006f\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063t\u0073\u0020\u0069\u006e\u0020\u0073t\u0072\u0065\u0061\u006d\u0020\u0028\u0064\u0065\u006c\u0074\u0061\u0062\u0020=\u003d\u0020\u0030\u0029");return _cfca ,nil ;};_dgede :=len (_aeec )/_edad ;_gdab :=0;_degf :=_gegbc .PdfObjectDictionary .Get ("\u0049\u006e\u0064e\u0078");var _fecc []int ;if _degf !=nil {_cd .Log .Trace ("\u0049n\u0064\u0065\u0078\u003a\u0020\u0025b",_degf );_cbba ,_bgdg :=_degf .(*PdfObjectArray );if !_bgdg {_cd .Log .Debug ("\u0049\u006e\u0076\u0061\u006ci\u0064\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0029");return nil ,_f .New ("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0049\u006e\u0064e\u0078\u0020\u006f\u0062je\u0063\u0074");};if _cbba .Len ()%2!=0{_cd .Log .Debug ("\u0057\u0041\u0052\u004eI\u004e\u0047\u0020\u0046\u0061\u0069\u006c\u0075\u0072e\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020i\u006e\u0064\u0065\u0078\u0020n\u006f\u0074\u0020\u006d\u0075\u006c\u0074\u0069\u0070\u006c\u0065\u0020\u006f\u0066\u0020\u0032\u002e");return nil ,_f .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_gdab =0;_gcec ,_fcbc :=_cbba .ToIntegerArray ();if _fcbc !=nil {_cd .Log .Debug ("\u0045\u0072\u0072\u006f\u0072 \u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0065\u0078 \u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0073\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0073\u003a\u0020\u0025\u0076",_fcbc );return nil ,_fcbc ;};for _efcd :=0;_efcd < len (_gcec );_efcd +=2{_fbef :=_gcec [_efcd ];_dccb :=_gcec [_efcd +1];for _fade :=0;_fade < _dccb ;_fade ++{_fecc =append (_fecc ,_fbef +_fade );};_gdab +=_dccb ;};}else {for _cbedd :=0;_cbedd < int (*_aggb );_cbedd ++{_fecc =append (_fecc ,_cbedd );};_gdab =int (*_aggb );};if _dgede ==_gdab +1{_cd .Log .Debug ("\u0049n\u0063\u006f\u006d\u0070ati\u0062\u0069\u006c\u0069t\u0079\u003a\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006di\u0073\u0073\u0069\u006e\u0067\u0020\u0063\u006f\u0076\u0065\u0072\u0061\u0067\u0065\u0020\u006f\u0066\u0020\u0031\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u002d\u0020\u0061\u0070\u0070en\u0064\u0069\u006eg\u0020\u006f\u006e\u0065\u0020-\u0020M\u0061\u0079\u0020\u006c\u0065\u0061\u0064\u0020\u0074o\u0020\u0070\u0072\u006f\u0062\u006c\u0065\u006d\u0073");_aabe :=_gdab -1;for _ ,_edae :=range _fecc {if _edae > _aabe {_aabe =_edae ;};};_fecc =append (_fecc ,_aabe +1);_gdab ++;};if _dgede !=len (_fecc ){_cd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020x\u0072\u0065\u0066 \u0073\u0074\u006d:\u0020\u006eu\u006d\u0020\u0065\u006e\u0074\u0072i\u0065s \u0021\u003d\u0020\u006c\u0065\u006e\u0028\u0069\u006e\u0064\u0069\u0063\u0065\u0073\u0029\u0020\u0028\u0025\u0064\u0020\u0021\u003d\u0020\u0025\u0064\u0029",_dgede ,len (_fecc ));return nil ,_f .New ("\u0078\u0072ef\u0020\u0073\u0074m\u0020\u006e\u0075\u006d en\u0074ri\u0065\u0073\u0020\u0021\u003d\u0020\u006cen\u0028\u0069\u006e\u0064\u0069\u0063\u0065s\u0029");};_cd .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074s\u0020\u0063\u006f\u0075\u006e\u0074\u0020\u0025\u0064",_gdab );_cd .Log .Trace ("\u0049\u006e\u0064i\u0063\u0065\u0073\u003a\u0020\u0025\u0020\u0064",_fecc );_cbag :=func (_fee []byte )int64 {var _fbbab int64 ;for _ecgb :=0;_ecgb < len (_fee );_ecgb ++{_fbbab +=int64 (_fee [_ecgb ])*(1<<uint (8*(len (_fee )-_ecgb -1)));};return _fbbab ;};_cd .Log .Trace ("\u0044e\u0063\u006f\u0064\u0065d\u0020\u0073\u0074\u0072\u0065a\u006d \u006ce\u006e\u0067\u0074\u0068\u003a\u0020\u0025d",len (_aeec ));_gcgca :=0;for _cdfbb :=0;_cdfbb < len (_aeec );_cdfbb +=_edad {_fadcf :=_cgfde (len (_aeec ),_cdfbb ,_cdfbb +_ggga );if _fadcf !=nil {_cd .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_fadcf );return nil ,_fadcf ;};_bfae :=_aeec [_cdfbb :_cdfbb +_ggga ];_fadcf =_cgfde (len (_aeec ),_cdfbb +_ggga ,_cdfbb +_adafd );if _fadcf !=nil {_cd .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_fadcf );return nil ,_fadcf ;};_eedb :=_aeec [_cdfbb +_ggga :_cdfbb +_adafd ];_fadcf =_cgfde (len (_aeec ),_cdfbb +_adafd ,_cdfbb +_egdef );if _fadcf !=nil {_cd .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_fadcf );return nil ,_fadcf ;};_degfa :=_aeec [_cdfbb +_adafd :_cdfbb +_egdef ];_defc :=_cbag (_bfae );_adae :=_cbag (_eedb );_dcee :=_cbag (_degfa );if _bfeg [0]==0{_defc =1;};if _gcgca >=len (_fecc ){_cd .Log .Debug ("X\u0052\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u002d\u0020\u0054\u0072\u0079\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0061\u0063\u0063e\u0073s\u0020\u0069\u006e\u0064e\u0078\u0020o\u0075\u0074\u0020\u006f\u0066\u0020\u0062\u006f\u0075\u006e\u0064\u0073\u0020\u002d\u0020\u0062\u0072\u0065\u0061\u006b\u0069\u006e\u0067");break ;};_ccea :=_fecc [_gcgca ];_gcgca ++;_cd .Log .Trace ("%\u0064\u002e\u0020\u0070\u0031\u003a\u0020\u0025\u0020\u0078",_ccea ,_bfae );_cd .Log .Trace ("%\u0064\u002e\u0020\u0070\u0032\u003a\u0020\u0025\u0020\u0078",_ccea ,_eedb );_cd .Log .Trace ("%\u0064\u002e\u0020\u0070\u0033\u003a\u0020\u0025\u0020\u0078",_ccea ,_degfa );_cd .Log .Trace ("\u0025d\u002e \u0078\u0072\u0065\u0066\u003a \u0025\u0064 \u0025\u0064\u0020\u0025\u0064",_ccea ,_defc ,_adae ,_dcee );if _defc ==0{_cd .Log .Trace ("-\u0020\u0046\u0072\u0065\u0065\u0020o\u0062\u006a\u0065\u0063\u0074\u0020-\u0020\u0063\u0061\u006e\u0020\u0070\u0072o\u0062\u0061\u0062\u006c\u0079\u0020\u0069\u0067\u006e\u006fr\u0065");}else if _defc ==1{_cd .Log .Trace ("\u002d\u0020I\u006e\u0020\u0075\u0073e\u0020\u002d \u0075\u006e\u0063\u006f\u006d\u0070\u0072\u0065s\u0073\u0065\u0064\u0020\u0076\u0069\u0061\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0062",_eedb );if _adae ==_deacd {_cd .Log .Debug ("\u0055\u0070d\u0061\u0074\u0069\u006e\u0067\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0058\u0052\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0064",_ccea ,_gegbc .ObjectNumber );_ccea =int (_gegbc .ObjectNumber );};if _edcfe ,_age :=_ceac ._dgag .ObjectMap [_ccea ];!_age ||int (_dcee )> _edcfe .Generation {_bgcb :=XrefObject {ObjectNumber :_ccea ,XType :XrefTypeTableEntry ,Offset :_adae ,Generation :int (_dcee )};_ceac ._dgag .ObjectMap [_ccea ]=_bgcb ;};}else if _defc ==2{_cd .Log .Trace ("\u002d\u0020\u0049\u006e \u0075\u0073\u0065\u0020\u002d\u0020\u0063\u006f\u006d\u0070r\u0065s\u0073\u0065\u0064\u0020\u006f\u0062\u006ae\u0063\u0074");if _ ,_efce :=_ceac ._dgag .ObjectMap [_ccea ];!_efce {_bgcdg :=XrefObject {ObjectNumber :_ccea ,XType :XrefTypeObjectStream ,OsObjNumber :int (_adae ),OsObjIndex :int (_dcee )};_ceac ._dgag .ObjectMap [_ccea ]=_bgcdg ;_cd .Log .Trace ("\u0065\u006e\u0074\u0072\u0079\u003a\u0020\u0025\u002b\u0076",_bgcdg );};}else {_cd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052:\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0056\u0041L\u0049\u0044\u0020\u0054\u0059\u0050\u0045\u0020\u0058\u0072\u0065\u0066\u0053\u0074\u006d\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u003f\u002d\u002d\u002d\u002d\u002d\u002d-");continue ;};};if _ceac ._eaea ==nil {_fbedf :=XrefTypeObjectStream ;_ceac ._eaea =&_fbedf ;};return _cfca ,nil ;};

// IsAuthenticated returns true if the PDF has already been authenticated for accessing.
func (_eegdf *PdfParser )IsAuthenticated ()bool {return _eegdf ._egc ._fag };func (_bfcc *PdfParser )parseObject ()(PdfObject ,error ){_cd .Log .Trace ("\u0052e\u0061d\u0020\u0064\u0069\u0072\u0065c\u0074\u0020o\u0062\u006a\u0065\u0063\u0074");_bfcc .skipSpaces ();for {_debf ,_ega :=_bfcc ._bfbbd .Peek (2);if _ega !=nil {if _ega !=_gb .EOF ||len (_debf )==0{return nil ,_ega ;};if len (_debf )==1{_debf =append (_debf ,' ');};};_cd .Log .Trace ("\u0050e\u0065k\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u003a\u0020\u0025\u0073",string (_debf ));if _debf [0]=='/'{_cbd ,_edcg :=_bfcc .parseName ();_cd .Log .Trace ("\u002d\u003e\u004ea\u006d\u0065\u003a\u0020\u0027\u0025\u0073\u0027",_cbd );return &_cbd ,_edcg ;}else if _debf [0]=='('{_cd .Log .Trace ("\u002d>\u0053\u0074\u0072\u0069\u006e\u0067!");_affe ,_ebda :=_bfcc .parseString ();return _affe ,_ebda ;}else if _debf [0]=='['{_cd .Log .Trace ("\u002d\u003e\u0041\u0072\u0072\u0061\u0079\u0021");_cccc ,_bgca :=_bfcc .parseArray ();return _cccc ,_bgca ;}else if (_debf [0]=='<')&&(_debf [1]=='<'){_cd .Log .Trace ("\u002d>\u0044\u0069\u0063\u0074\u0021");_agfed ,_dbd :=_bfcc .ParseDict ();return _agfed ,_dbd ;}else if _debf [0]=='<'{_cd .Log .Trace ("\u002d\u003e\u0048\u0065\u0078\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0021");_beebc ,_abcge :=_bfcc .parseHexString ();return _beebc ,_abcge ;}else if _debf [0]=='%'{_bfcc .readComment ();_bfcc .skipSpaces ();}else {_cd .Log .Trace ("\u002d\u003eN\u0075\u006d\u0062e\u0072\u0020\u006f\u0072\u0020\u0072\u0065\u0066\u003f");_debf ,_ =_bfcc ._bfbbd .Peek (15);_gefd :=string (_debf );_cd .Log .Trace ("\u0050\u0065\u0065k\u0020\u0073\u0074\u0072\u003a\u0020\u0025\u0073",_gefd );if (len (_gefd )> 3)&&(_gefd [:4]=="\u006e\u0075\u006c\u006c"){_eegdc ,_bdcaf :=_bfcc .parseNull ();return &_eegdc ,_bdcaf ;}else if (len (_gefd )> 4)&&(_gefd [:5]=="\u0066\u0061\u006cs\u0065"){_ccba ,_adeec :=_bfcc .parseBool ();return &_ccba ,_adeec ;}else if (len (_gefd )> 3)&&(_gefd [:4]=="\u0074\u0072\u0075\u0065"){_ebdfd ,_bfbg :=_bfcc .parseBool ();return &_ebdfd ,_bfbg ;};_dfdad :=_fbffe .FindStringSubmatch (string (_gefd ));if len (_dfdad )> 1{_debf ,_ =_bfcc ._bfbbd .ReadBytes ('R');_cd .Log .Trace ("\u002d\u003e\u0020\u0021\u0052\u0065\u0066\u003a\u0020\u0027\u0025\u0073\u0027",string (_debf [:]));_aaaa ,_ceea :=_cgdc (string (_debf ));_aaaa ._dbca =_bfcc ;return &_aaaa ,_ceea ;};_gccf :=_fecd .FindStringSubmatch (string (_gefd ));if len (_gccf )> 1{_cd .Log .Trace ("\u002d\u003e\u0020\u004e\u0075\u006d\u0062\u0065\u0072\u0021");_faaf ,_dagg :=_bfcc .parseNumber ();return _faaf ,_dagg ;};_gccf =_cedd .FindStringSubmatch (string (_gefd ));if len (_gccf )> 1{_cd .Log .Trace ("\u002d\u003e\u0020\u0045xp\u006f\u006e\u0065\u006e\u0074\u0069\u0061\u006c\u0020\u004e\u0075\u006d\u0062\u0065r\u0021");_cd .Log .Trace ("\u0025\u0020\u0073",_gccf );_adaab ,_egea :=_bfcc .parseNumber ();return _adaab ,_egea ;};_cd .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020U\u006e\u006b\u006e\u006f\u0077n\u0020(\u0070e\u0065\u006b\u0020\u0022\u0025\u0073\u0022)",_gefd );return nil ,_f .New ("\u006f\u0062\u006a\u0065\u0063t\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020\u0075\u006e\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e");};};};type objectStreams map[int ]objectStream ;

// NewLZWEncoder makes a new LZW encoder with default parameters.
func NewLZWEncoder ()*LZWEncoder {_abeca :=&LZWEncoder {};_abeca .Predictor =1;_abeca .BitsPerComponent =8;_abeca .Colors =1;_abeca .Columns =1;_abeca .EarlyChange =1;return _abeca ;};

// Set sets the PdfObject at index i of the array. An error is returned if the index is outside bounds.
func (_agbg *PdfObjectArray )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_agbg ._ddfca ){return _f .New ("\u006f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_agbg ._ddfca [i ]=obj ;return nil ;};

// String returns a string describing `array`.
func (_dfaff *PdfObjectArray )String ()string {_bbabe :="\u005b";for _dfcf ,_bbbb :=range _dfaff .Elements (){_bbabe +=_bbbb .String ();if _dfcf < (_dfaff .Len ()-1){_bbabe +="\u002c\u0020";};};_bbabe +="\u005d";return _bbabe ;};

// GetObjectStreams returns the *PdfObjectStreams represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetObjectStreams (obj PdfObject )(_cad *PdfObjectStreams ,_dfba bool ){_cad ,_dfba =obj .(*PdfObjectStreams );return _cad ,_dfba ;};

// PdfCryptNewDecrypt makes the document crypt handler based on the encryption dictionary
// and trailer dictionary. Returns an error on failure to process.
func PdfCryptNewDecrypt (parser *PdfParser ,ed ,trailer *PdfObjectDictionary )(*PdfCrypt ,error ){_cde :=&PdfCrypt {_fag :false ,_ece :make (map[PdfObject ]bool ),_bde :make (map[PdfObject ]bool ),_cgaf :make (map[int ]struct{}),_ccc :parser };_bfe ,_fcd :=ed .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectName );if !_fcd {_cd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0043\u0072\u0079\u0070\u0074 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061r\u0079 \u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u0066\u0069\u0065\u006c\u0064\u0021");return _cde ,_f .New ("r\u0065\u0071\u0075\u0069\u0072\u0065d\u0020\u0063\u0072\u0079\u0070\u0074 \u0066\u0069\u0065\u006c\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u006d\u0069\u0073\u0073\u0069n\u0067");};if *_bfe !="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"{_cd .Log .Debug ("\u0045\u0052R\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020(%\u0073\u0029",*_bfe );return _cde ,_f .New ("\u0075n\u0073u\u0070\u0070\u006f\u0072\u0074e\u0064\u0020F\u0069\u006c\u0074\u0065\u0072");};_cde ._cfd .Filter =string (*_bfe );if _gec ,_fbfe :=ed .Get ("\u0053u\u0062\u0046\u0069\u006c\u0074\u0065r").(*PdfObjectString );_fbfe {_cde ._cfd .SubFilter =_gec .Str ();_cd .Log .Debug ("\u0055s\u0069n\u0067\u0020\u0073\u0075\u0062f\u0069\u006ct\u0065\u0072\u0020\u0025\u0073",_gec );};if L ,_fcdb :=ed .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );_fcdb {if (*L %8)!=0{_cd .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0049\u006ev\u0061\u006c\u0069\u0064\u0020\u0065\u006ec\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006c\u0065\u006e\u0067\u0074\u0068");return _cde ,_f .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0065\u006e\u0063\u0072y\u0070t\u0069o\u006e\u0020\u006c\u0065\u006e\u0067\u0074h");};_cde ._cfd .Length =int (*L );}else {_cde ._cfd .Length =40;};_cde ._cfd .V =0;if _bge ,_dgbge :=ed .Get ("\u0056").(*PdfObjectInteger );_dgbge {V :=int (*_bge );_cde ._cfd .V =V ;if V >=1&&V <=2{_cde ._bee =_ebb (_cde ._cfd .Length );}else if V >=4&&V <=5{if _ddg :=_cde .loadCryptFilters (ed );_ddg !=nil {return _cde ,_ddg ;};}else {_cd .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0061lg\u006f\u0020\u0056 \u003d \u0025\u0064",V );return _cde ,_f .New ("u\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d");};};if _cgc :=_aag (&_cde ._cgd ,ed );_cgc !=nil {return _cde ,_cgc ;};_def :="";if _eac ,_cfg :=trailer .Get ("\u0049\u0044").(*PdfObjectArray );_cfg &&_eac .Len ()>=1{_ffdf ,_eec :=GetString (_eac .Get (0));if !_eec {return _cde ,_f .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0074r\u0061\u0069l\u0065\u0072\u0020\u0049\u0044");};_def =_ffdf .Str ();}else {_cd .Log .Debug ("\u0054\u0072ai\u006c\u0065\u0072 \u0049\u0044\u0020\u0061rra\u0079 m\u0069\u0073\u0073\u0069\u006e\u0067\u0020or\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0021");};_cde ._gfc =_def ;return _cde ,nil ;};

// MakeName creates a PdfObjectName from a string.
func MakeName (s string )*PdfObjectName {_gageg :=PdfObjectName (s );return &_gageg };func (_cdd *PdfCrypt )saveCryptFilters (_bef *PdfObjectDictionary )error {if _cdd ._cfd .V < 4{return _f .New ("\u0063\u0061\u006e\u0020\u006f\u006e\u006c\u0079\u0020\u0062\u0065 \u0075\u0073\u0065\u0064\u0020\u0077\u0069\u0074\u0068\u0020V\u003e\u003d\u0034");};_bbdb :=MakeDict ();_bef .Set ("\u0043\u0046",_bbdb );for _abf ,_dcfa :=range _cdd ._bee {if _abf =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{continue ;};_gggf :=_cfa (_dcfa ,"");_bbdb .Set (PdfObjectName (_abf ),_gggf );};_bef .Set ("\u0053\u0074\u0072\u0046",MakeName (_cdd ._cac ));_bef .Set ("\u0053\u0074\u006d\u0046",MakeName (_cdd ._eeb ));return nil ;};

// EncodeJBIG2Image encodes 'img' into jbig2 encoded bytes stream, using default encoder settings.
func (_gebf *JBIG2Encoder )EncodeJBIG2Image (img *JBIG2Image )([]byte ,error ){const _ggbb ="c\u006f\u0072\u0065\u002eEn\u0063o\u0064\u0065\u004a\u0042\u0049G\u0032\u0049\u006d\u0061\u0067\u0065";if _cbf :=_gebf .AddPageImage (img ,&_gebf .DefaultPageSettings );_cbf !=nil {return nil ,_cf .Wrap (_cbf ,_ggbb ,"");};return _gebf .Encode ();};

// MakeArray creates an PdfObjectArray from a list of PdfObjects.
func MakeArray (objects ...PdfObject )*PdfObjectArray {_cdcd :=&PdfObjectArray {};_cdcd ._ddfca =[]PdfObject {};for _ ,_addc :=range objects {_cdcd ._ddfca =append (_cdcd ._ddfca ,_addc );};return _cdcd ;};func (_cfacb *PdfParser )parseNumber ()(PdfObject ,error ){return ParseNumber (_cfacb ._bfbbd )};

// EncodeBytes encodes the passed in slice of bytes by passing it through the
// EncodeBytes method of the underlying encoders.
func (_gaaab *MultiEncoder )EncodeBytes (data []byte )([]byte ,error ){_daecc :=data ;var _agdb error ;for _edff :=len (_gaaab ._egdf )-1;_edff >=0;_edff --{_gggd :=_gaaab ._egdf [_edff ];_daecc ,_agdb =_gggd .EncodeBytes (_daecc );if _agdb !=nil {return nil ,_agdb ;};};return _daecc ,nil ;};

// ResolveReference resolves reference if `o` is a *PdfObjectReference and returns the object referenced to.
// Otherwise returns back `o`.
func ResolveReference (obj PdfObject )PdfObject {if _aaba ,_abdge :=obj .(*PdfObjectReference );_abdge {return _aaba .Resolve ();};return obj ;};

// MakeString creates an PdfObjectString from a string.
// NOTE: PDF does not use utf-8 string encoding like Go so `s` will often not be a utf-8 encoded
// string.
func MakeString (s string )*PdfObjectString {_gcf :=PdfObjectString {_eagc :s };return &_gcf };func (_ffgae *FlateEncoder )postDecodePredict (_fdad []byte )([]byte ,error ){if _ffgae .Predictor > 1{if _ffgae .Predictor ==2{_cd .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_cd .Log .Trace ("\u0043\u006f\u006c\u006f\u0072\u0073\u003a\u0020\u0025\u0064",_ffgae .Colors );_deg :=int (_ffgae .Columns )*_ffgae .Colors ;if _deg < 1{return []byte {},nil ;};_cgf :=len (_fdad )/_deg ;if len (_fdad )%_deg !=0{_cd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");return nil ,_aa .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_fdad ),_deg );};if _deg %_ffgae .Colors !=0{return nil ,_aa .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_deg ,_ffgae .Colors );};if _deg > len (_fdad ){_cd .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_deg ,len (_fdad ));return nil ,_f .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_cd .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_fdad ),_fdad );_cgag :=_dgb .NewBuffer (nil );for _cec :=0;_cec < _cgf ;_cec ++{_decg :=_fdad [_deg *_cec :_deg *(_cec +1)];for _fbb :=_ffgae .Colors ;_fbb < _deg ;_fbb ++{_decg [_fbb ]+=_decg [_fbb -_ffgae .Colors ];};_cgag .Write (_decg );};_fgg :=_cgag .Bytes ();_cd .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_fgg ),_fgg );return _fgg ,nil ;}else if _ffgae .Predictor >=10&&_ffgae .Predictor <=15{_cd .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_bcg :=int (_ffgae .Columns *_ffgae .Colors +1);_agcb :=len (_fdad )/_bcg ;if len (_fdad )%_bcg !=0{return nil ,_aa .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_fdad ),_bcg );};if _bcg > len (_fdad ){_cd .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_bcg ,len (_fdad ));return nil ,_f .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_fbed :=_dgb .NewBuffer (nil );_cd .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_ffgae .Columns );_cd .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_fdad ),_bcg ,_agcb );_bgab :=make ([]byte ,_bcg );for _bfb :=0;_bfb < _bcg ;_bfb ++{_bgab [_bfb ]=0;};_gbdc :=_ffgae .Colors ;for _aab :=0;_aab < _agcb ;_aab ++{_egbe :=_fdad [_bcg *_aab :_bcg *(_aab +1)];_aeac :=_egbe [0];switch _aeac {case _acced :case _bgeb :for _deb :=1+_gbdc ;_deb < _bcg ;_deb ++{_egbe [_deb ]+=_egbe [_deb -_gbdc ];};case _ffbf :for _bdg :=1;_bdg < _bcg ;_bdg ++{_egbe [_bdg ]+=_bgab [_bdg ];};case _gfd :for _bbdc :=1;_bbdc < _gbdc +1;_bbdc ++{_egbe [_bbdc ]+=_bgab [_bbdc ]/2;};for _dffg :=_gbdc +1;_dffg < _bcg ;_dffg ++{_egbe [_dffg ]+=byte ((int (_egbe [_dffg -_gbdc ])+int (_bgab [_dffg ]))/2);};case _dcb :for _ebbc :=1;_ebbc < _bcg ;_ebbc ++{var _bec ,_eebg ,_fggf byte ;_eebg =_bgab [_ebbc ];if _ebbc >=_gbdc +1{_bec =_egbe [_ebbc -_gbdc ];_fggf =_bgab [_ebbc -_gbdc ];};_egbe [_ebbc ]+=_fffc (_bec ,_eebg ,_fggf );};default:_cd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029\u0020\u0040\u0072o\u0077\u0020\u0025\u0064",_aeac ,_aab );return nil ,_aa .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_aeac );};copy (_bgab ,_egbe );_fbed .Write (_egbe [1:]);};_gcb :=_fbed .Bytes ();return _gcb ,nil ;}else {_cd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_ffgae .Predictor );return nil ,_aa .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_ffgae .Predictor );};};return _fdad ,nil ;};

// GetInt returns the *PdfObjectBool object that is represented by a PdfObject either directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetInt (obj PdfObject )(_ebcfg *PdfObjectInteger ,_dgbc bool ){_ebcfg ,_dgbc =TraceToDirectObject (obj ).(*PdfObjectInteger );return _ebcfg ,_dgbc ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_ddf *LZWEncoder )MakeDecodeParams ()PdfObject {if _ddf .Predictor > 1{_dbf :=MakeDict ();_dbf .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_ddf .Predictor )));if _ddf .BitsPerComponent !=8{_dbf .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_ddf .BitsPerComponent )));};if _ddf .Columns !=1{_dbf .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_ddf .Columns )));};if _ddf .Colors !=1{_dbf .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_ddf .Colors )));};return _dbf ;};return nil ;};

// NewEncoderFromStream creates a StreamEncoder based on the stream's dictionary.
func NewEncoderFromStream (streamObj *PdfObjectStream )(StreamEncoder ,error ){_cfbd :=TraceToDirectObject (streamObj .PdfObjectDictionary .Get ("\u0046\u0069\u006c\u0074\u0065\u0072"));if _cfbd ==nil {return NewRawEncoder (),nil ;};if _ ,_ffgf :=_cfbd .(*PdfObjectNull );_ffgf {return NewRawEncoder (),nil ;};_eddfd ,_geag :=_cfbd .(*PdfObjectName );if !_geag {_dbede ,_agce :=_cfbd .(*PdfObjectArray );if !_agce {return nil ,_aa .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006f\u0072 \u0041\u0072\u0072\u0061\u0079\u0020\u006fb\u006a\u0065\u0063\u0074");};if _dbede .Len ()==0{return NewRawEncoder (),nil ;};if _dbede .Len ()!=1{_adffe ,_ecff :=_cfeb (streamObj );if _ecff !=nil {_cd .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0063\u0072\u0065\u0061\u0074\u0069\u006e\u0067\u0020\u006d\u0075\u006c\u0074i\u0020\u0065\u006e\u0063\u006f\u0064\u0065r\u003a\u0020\u0025\u0076",_ecff );return nil ,_ecff ;};_cd .Log .Trace ("\u004d\u0075\u006c\u0074\u0069\u0020\u0065\u006e\u0063:\u0020\u0025\u0073\u000a",_adffe );return _adffe ,nil ;};_cfbd =_dbede .Get (0);_eddfd ,_agce =_cfbd .(*PdfObjectName );if !_agce {return nil ,_aa .Errorf ("\u0066\u0069l\u0074\u0065\u0072\u0020a\u0072\u0072a\u0079\u0020\u006d\u0065\u006d\u0062\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006fb\u006a\u0065\u0063\u0074");};};switch *_eddfd {case StreamEncodingFilterNameFlate :return _ddbb (streamObj ,nil );case StreamEncodingFilterNameLZW :return _gcde (streamObj ,nil );case StreamEncodingFilterNameDCT :return _ged (streamObj ,nil );case StreamEncodingFilterNameRunLength :return _cbg (streamObj ,nil );case StreamEncodingFilterNameASCIIHex :return NewASCIIHexEncoder (),nil ;case StreamEncodingFilterNameASCII85 ,"\u0041\u0038\u0035":return NewASCII85Encoder (),nil ;case StreamEncodingFilterNameCCITTFax :return _gfab (streamObj ,nil );case StreamEncodingFilterNameJBIG2 :return _cba (streamObj ,nil );case StreamEncodingFilterNameJPX :return NewJPXEncoder (),nil ;};_cd .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064\u0069\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006fd\u0021");return nil ,_aa .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064i\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006f\u0064\u0020\u0028\u0025\u0073\u0029",*_eddfd );};

// GetStringVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetStringVal (obj PdfObject )(_fcdec string ,_fbgd bool ){_gdce ,_fbgd :=TraceToDirectObject (obj ).(*PdfObjectString );if _fbgd {return _gdce .Str (),true ;};return ;};

// AddEncoder adds the passed in encoder to the underlying encoder slice.
func (_bbfb *MultiEncoder )AddEncoder (encoder StreamEncoder ){_bbfb ._egdf =append (_bbfb ._egdf ,encoder );};

// NewASCII85Encoder makes a new ASCII85 encoder.
func NewASCII85Encoder ()*ASCII85Encoder {_fgeg :=&ASCII85Encoder {};return _fgeg };func (_cace *JBIG2Image )toBitmap ()(_dabd *_fd .Bitmap ,_face error ){const _eceg ="\u004a\u0042\u0049\u00472I\u006d\u0061\u0067\u0065\u002e\u0074\u006f\u0042\u0069\u0074\u006d\u0061\u0070";if _cace .Data ==nil {return nil ,_cf .Error (_eceg ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");};if _cace .Width ==0||_cace .Height ==0{return nil ,_cf .Error (_eceg ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");};if _cace .HasPadding {_dabd ,_face =_fd .NewWithData (_cace .Width ,_cace .Height ,_cace .Data );}else {_dabd ,_face =_fd .NewWithUnpaddedData (_cace .Width ,_cace .Height ,_cace .Data );};if _face !=nil {return nil ,_cf .Wrap (_face ,_eceg ,"");};return _dabd ,nil ;};

// Append appends PdfObject(s) to the array.
func (_bdda *PdfObjectArray )Append (objects ...PdfObject ){if _bdda ==nil {_cd .Log .Debug ("\u0057\u0061\u0072\u006e\u0020\u002d\u0020\u0041\u0074\u0074\u0065\u006d\u0070t\u0020\u0074\u006f\u0020\u0061\u0070p\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020a\u0072\u0072\u0061\u0079");return ;};if _bdda ._ddfca ==nil {_bdda ._ddfca =[]PdfObject {};};for _ ,_agcbf :=range objects {_bdda ._ddfca =append (_bdda ._ddfca ,_agcbf );};};

// EncodeBytes encodes data into ASCII85 encoded format.
func (_cff *ASCII85Encoder )EncodeBytes (data []byte )([]byte ,error ){var _cgff _dgb .Buffer ;for _eafbe :=0;_eafbe < len (data );_eafbe +=4{_deedb :=data [_eafbe ];_dbae :=1;_cdee :=byte (0);if _eafbe +1< len (data ){_cdee =data [_eafbe +1];_dbae ++;};_adddd :=byte (0);if _eafbe +2< len (data ){_adddd =data [_eafbe +2];_dbae ++;};_bccd :=byte (0);if _eafbe +3< len (data ){_bccd =data [_eafbe +3];_dbae ++;};_agdc :=(uint32 (_deedb )<<24)|(uint32 (_cdee )<<16)|(uint32 (_adddd )<<8)|uint32 (_bccd );if _agdc ==0{_cgff .WriteByte ('z');}else {_cgfb :=_cff .base256Tobase85 (_agdc );for _ ,_dea :=range _cgfb [:_dbae +1]{_cgff .WriteByte (_dea +'!');};};};_cgff .WriteString ("\u007e\u003e");return _cgff .Bytes (),nil ;};

// GetFilterName returns the name of the encoding filter.
func (_gbb *ASCII85Encoder )GetFilterName ()string {return StreamEncodingFilterNameASCII85 };func (_cfea *PdfParser )lookupByNumberWrapper (_dec int ,_ceb bool )(PdfObject ,bool ,error ){_fc ,_bbd ,_fad :=_cfea .lookupByNumber (_dec ,_ceb );if _fad !=nil {return nil ,_bbd ,_fad ;};if !_bbd &&_cfea ._egc !=nil &&!_cfea ._egc .isDecrypted (_fc ){_ggg :=_cfea ._egc .Decrypt (_fc ,0,0);if _ggg !=nil {return nil ,_bbd ,_ggg ;};};return _fc ,_bbd ,nil ;};

// PdfCryptNewEncrypt makes the document crypt handler based on a specified crypt filter.
func PdfCryptNewEncrypt (cf _ag .Filter ,userPass ,ownerPass []byte ,perm _dd .Permissions )(*PdfCrypt ,*EncryptInfo ,error ){_bdb :=&PdfCrypt {_bde :make (map[PdfObject ]bool ),_bee :make (cryptFilters ),_cgd :_dd .StdEncryptDict {P :perm ,EncryptMetadata :true }};var _fdf Version ;if cf !=nil {_faa :=cf .PDFVersion ();_fdf .Major ,_fdf .Minor =_faa [0],_faa [1];V ,R :=cf .HandlerVersion ();_bdb ._cfd .V =V ;_bdb ._cgd .R =R ;_bdb ._cfd .Length =cf .KeyLength ()*8;};const (_fcc =_cgg ;);_bdb ._bee [_fcc ]=cf ;if _bdb ._cfd .V >=4{_bdb ._eeb =_fcc ;_bdb ._cac =_fcc ;};_ddd :=_bdb .newEncryptDict ();_fbf :=_ad .Sum ([]byte (_b .Now ().Format (_b .RFC850 )));_ffg :=string (_fbf [:]);_daca :=make ([]byte ,100);_bg .Read (_daca );_fbf =_ad .Sum (_daca );_cdb :=string (_fbf [:]);_cd .Log .Trace ("\u0052\u0061\u006e\u0064\u006f\u006d\u0020\u0062\u003a\u0020\u0025\u0020\u0078",_daca );_cd .Log .Trace ("\u0047\u0065\u006e\u0020\u0049\u0064\u0020\u0030\u003a\u0020\u0025\u0020\u0078",_ffg );_bdb ._gfc =string (_ffg );_afd :=_bdb .generateParams (userPass ,ownerPass );if _afd !=nil {return nil ,nil ,_afd ;};_fab (&_bdb ._cgd ,_ddd );if _bdb ._cfd .V >=4{if _ec :=_bdb .saveCryptFilters (_ddd );_ec !=nil {return nil ,nil ,_ec ;};};return _bdb ,&EncryptInfo {Version :_fdf ,Encrypt :_ddd ,ID0 :_ffg ,ID1 :_cdb },nil ;};

// Merge merges in key/values from another dictionary. Overwriting if has same keys.
// The mutated dictionary (d) is returned in order to allow method chaining.
func (_efgb *PdfObjectDictionary )Merge (another *PdfObjectDictionary )*PdfObjectDictionary {if another !=nil {for _ ,_cege :=range another .Keys (){_ccbf :=another .Get (_cege );_efgb .Set (_cege ,_ccbf );};};return _efgb ;};

// IsPrintable checks if a character is printable.
// Regular characters that are outside the range EXCLAMATION MARK(21h)
// (!) to TILDE (7Eh) (~) should be written using the hexadecimal notation.
func IsPrintable (c byte )bool {return 0x21<=c &&c <=0x7E};func (_ffge *PdfCrypt )isEncrypted (_eff PdfObject )bool {_ ,_ecfc :=_ffge ._bde [_eff ];if _ecfc {_cd .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0065\u006e\u0063\u0072y\u0070\u0074\u0065\u0064");return true ;};_cd .Log .Trace ("\u004e\u006f\u0074\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");return false ;};

// LookupByReference looks up a PdfObject by a reference.
func (_eed *PdfParser )LookupByReference (ref PdfObjectReference )(PdfObject ,error ){_cd .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0075\u0070\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0025\u0073",ref .String ());return _eed .LookupByNumber (int (ref .ObjectNumber ));};

// CheckAccessRights checks access rights and permissions for a specified password. If either user/owner password is
// specified, full rights are granted, otherwise the access rights are specified by the Permissions flag.
//
// The bool flag indicates that the user can access and view the file.
// The AccessPermissions shows what access the user has for editing etc.
// An error is returned if there was a problem performing the authentication.
func (_ceefb *PdfParser )CheckAccessRights (password []byte )(bool ,_dd .Permissions ,error ){if _ceefb ._egc ==nil {return true ,_dd .PermOwner ,nil ;};return _ceefb ._egc .checkAccessRights (password );};

// String returns a string describing `d`.
func (_cccg *PdfObjectDictionary )String ()string {var _fcbe _ed .Builder ;_fcbe .WriteString ("\u0044\u0069\u0063t\u0028");for _ ,_dbecc :=range _cccg ._aedd {_fcge :=_cccg ._bacc [_dbecc ];_fcbe .WriteString ("\u0022"+_dbecc .String ()+"\u0022\u003a\u0020");_fcbe .WriteString (_fcge .String ());_fcbe .WriteString ("\u002c\u0020");};_fcbe .WriteString ("\u0029");return _fcbe .String ();};func (_gag *PdfCrypt )loadCryptFilters (_eaa *PdfObjectDictionary )error {_gag ._bee =cryptFilters {};_bbc :=_eaa .Get ("\u0043\u0046");_bbc =TraceToDirectObject (_bbc );if _eebd ,_abec :=_bbc .(*PdfObjectReference );_abec {_dee ,_bbdd :=_gag ._ccc .LookupByReference (*_eebd );if _bbdd !=nil {_cd .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0075\u0070\u0020\u0043\u0046\u0020\u0072\u0065\u0066\u0065\u0072en\u0063\u0065");return _bbdd ;};_bbc =TraceToDirectObject (_dee );};_geb ,_adad :=_bbc .(*PdfObjectDictionary );if !_adad {_cd .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0043\u0046\u002c \u0074\u0079\u0070\u0065: \u0025\u0054",_bbc );return _f .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0043\u0046");};for _ ,_gab :=range _geb .Keys (){_ggb :=_geb .Get (_gab );if _bgg ,_caf :=_ggb .(*PdfObjectReference );_caf {_dgd ,_ggd :=_gag ._ccc .LookupByReference (*_bgg );if _ggd !=nil {_cd .Log .Debug ("\u0045\u0072ro\u0072\u0020\u006co\u006f\u006b\u0075\u0070 up\u0020di\u0063\u0074\u0069\u006f\u006e\u0061\u0072y \u0072\u0065\u0066\u0065\u0072\u0065\u006ec\u0065");return _ggd ;};_ggb =TraceToDirectObject (_dgd );};_cbe ,_aaf :=_ggb .(*PdfObjectDictionary );if !_aaf {return _aa .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074\u0020\u0069\u006e \u0043\u0046\u0020\u0028\u006e\u0061\u006d\u0065\u0020\u0025\u0073\u0029\u0020-\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079\u0020\u0062\u0075\u0074\u0020\u0025\u0054",_gab ,_ggb );};if _gab =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{_cd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u002d\u0020\u0043\u0061\u006e\u006e\u006f\u0074\u0020\u006f\u0076\u0065\u0072\u0077r\u0069\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0069d\u0065\u006e\u0074\u0069\u0074\u0079\u0020\u0066\u0069\u006c\u0074\u0065\u0072 \u002d\u0020\u0054\u0072\u0079\u0069n\u0067\u0020\u006ee\u0078\u0074");continue ;};var _bbb _ag .FilterDict ;if _abb :=_aecg (&_bbb ,_cbe );_abb !=nil {return _abb ;};_aeb ,_ffd :=_ag .NewFilter (_bbb );if _ffd !=nil {return _ffd ;};_gag ._bee [string (_gab )]=_aeb ;};_gag ._bee ["\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"]=_ag .NewIdentity ();_gag ._cac ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _bbf ,_bac :=_eaa .Get ("\u0053\u0074\u0072\u0046").(*PdfObjectName );_bac {if _ ,_dbe :=_gag ._bee [string (*_bbf )];!_dbe {return _aa .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u0072\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_bbf );};_gag ._cac =string (*_bbf );};_gag ._eeb ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _add ,_adadg :=_eaa .Get ("\u0053\u0074\u006d\u0046").(*PdfObjectName );_adadg {if _ ,_dae :=_gag ._bee [string (*_add )];!_dae {return _aa .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u006d\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_add );};_gag ._eeb =string (*_add );};return nil ;};

// SetPredictor sets the predictor function.  Specify the number of columns per row.
// The columns indicates the number of samples per row.
// Used for grouping data together for compression.
func (_bfa *FlateEncoder )SetPredictor (columns int ){_bfa .Predictor =11;_bfa .Columns =columns };

// IsNullObject returns true if `obj` is a PdfObjectNull.
func IsNullObject (obj PdfObject )bool {_ ,_ffdcc :=TraceToDirectObject (obj ).(*PdfObjectNull );return _ffdcc ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_egd *DCTEncoder )MakeDecodeParams ()PdfObject {return nil };

// LookupByNumber looks up a PdfObject by object number.  Returns an error on failure.
func (_bag *PdfParser )LookupByNumber (objNumber int )(PdfObject ,error ){_eb ,_ ,_eg :=_bag .lookupByNumberWrapper (objNumber ,true );return _eb ,_eg ;};

// PdfObjectStreams represents the primitive PDF object streams.
// 7.5.7 Object Streams (page 45).
type PdfObjectStreams struct{PdfObjectReference ;_gcdd []PdfObject ;};

// EncodeBytes encodes slice of bytes into JBIG2 encoding format.
// The input 'data' must be an image. In order to Decode it a user is responsible to
// load the codec ('png', 'jpg').
// Returns jbig2 single page encoded document byte slice. The encoder uses DefaultPageSettings
// to encode given image.
func (_eagde *JBIG2Encoder )EncodeBytes (data []byte )([]byte ,error ){const _adfa ="\u004aB\u0049\u0047\u0032\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002eE\u006e\u0063\u006f\u0064\u0065\u0042\u0079\u0074\u0065\u0073";if _eagde .ColorComponents !=1||_eagde .BitsPerComponent !=1{return nil ,_cf .Errorf (_adfa ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u002e\u0020\u004a\u0042\u0049G\u0032\u0020E\u006e\u0063o\u0064\u0065\u0072\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020bi\u006e\u0061\u0072\u0079\u0020\u0069\u006d\u0061\u0067e\u0073\u0020\u0064\u0061\u0074\u0061");};var (_effg *_fd .Bitmap ;_ddda error ;);_cfag :=(_eagde .Width *_eagde .Height )==len (data );if _cfag {_effg ,_ddda =_fd .NewWithUnpaddedData (_eagde .Width ,_eagde .Height ,data );}else {_effg ,_ddda =_fd .NewWithData (_eagde .Width ,_eagde .Height ,data );};if _ddda !=nil {return nil ,_ddda ;};_dffe :=_eagde .DefaultPageSettings ;if _ddda =_dffe .Validate ();_ddda !=nil {return nil ,_cf .Wrap (_ddda ,_adfa ,"");};switch _dffe .Compression {case JB2Generic :if _ddda =_eagde ._dggg .AddGenericPage (_effg ,_dffe .DuplicatedLinesRemoval );_ddda !=nil {return nil ,_cf .Wrap (_ddda ,_adfa ,"");};case JB2SymbolCorrelation :return nil ,_cf .Error (_adfa ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");case JB2SymbolRankHaus :return nil ,_cf .Error (_adfa ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");default:return nil ,_cf .Error (_adfa ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return _eagde .Encode ();};

// MakeArrayFromFloats creates an PdfObjectArray from a slice of float64s, where each array element is an
// PdfObjectFloat.
func MakeArrayFromFloats (vals []float64 )*PdfObjectArray {_efbg :=MakeArray ();for _ ,_cgfa :=range vals {_efbg .Append (MakeFloat (_cgfa ));};return _efbg ;};

// DecodeBytes decodes a slice of Flate encoded bytes and returns the result.
func (_bfcg *FlateEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_cd .Log .Trace ("\u0046\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065\u0020b\u0079\u0074\u0065\u0073");if len (encoded )==0{_cd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0046\u006c\u0061\u0074\u0065 e\u006ec\u006f\u0064\u0065\u0064\u0020\u0062\u0075\u0066\u0066\u0065\u0072\u002e \u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0062y\u0074\u0065\u0020\u0073\u006c\u0069\u0063\u0065\u002e");return []byte {},nil ;};_bdd :=_dgb .NewReader (encoded );_afcd ,_eade :=_dc .NewReader (_bdd );if _eade !=nil {_cd .Log .Debug ("\u0044e\u0063o\u0064\u0069\u006e\u0067\u0020e\u0072\u0072o\u0072\u0020\u0025\u0076\u000a",_eade );_cd .Log .Debug ("\u0053t\u0072e\u0061\u006d\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (encoded ),encoded );return nil ,_eade ;};defer _afcd .Close ();var _adaa _dgb .Buffer ;_adaa .ReadFrom (_afcd );return _adaa .Bytes (),nil ;};

// EncodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_cgbb *RawEncoder )EncodeBytes (data []byte )([]byte ,error ){return data ,nil };var _aegd =_c .MustCompile ("\u0073t\u0061r\u0074\u0078\u003f\u0072\u0065f\u005c\u0073*\u0028\u005c\u0064\u002b\u0029");

// GetBoolVal returns the bool value within a *PdObjectBool represented by an PdfObject interface directly or indirectly.
// If the PdfObject does not represent a bool value, a default value of false is returned (found = false also).
func GetBoolVal (obj PdfObject )(_gcfd bool ,_gafa bool ){_decb ,_gafa :=TraceToDirectObject (obj ).(*PdfObjectBool );if _gafa {return bool (*_decb ),true ;};return false ,false ;};

// NewJBIG2Encoder creates a new JBIG2Encoder.
func NewJBIG2Encoder ()*JBIG2Encoder {return &JBIG2Encoder {_dggg :_ac .InitEncodeDocument (false )}};func (_cdg *PdfCrypt )checkAccessRights (_aed []byte )(bool ,_dd .Permissions ,error ){_fcdf :=_cdg .securityHandler ();_ggf ,_abfc ,_ceg :=_fcdf .Authenticate (&_cdg ._cgd ,_aed );if _ceg !=nil {return false ,0,_ceg ;}else if _abfc ==0||len (_ggf )==0{return false ,0,nil ;};return true ,_abfc ,nil ;};

// EqualObjects returns true if `obj1` and `obj2` have the same contents.
//
// NOTE: It is a good idea to flatten obj1 and obj2 with FlattenObject before calling this function
// so that contents, rather than references, can be compared.
func EqualObjects (obj1 ,obj2 PdfObject )bool {return _agfcd (obj1 ,obj2 ,0)};

// DecodeImages decodes the page images from the jbig2 'encoded' data input.
// The jbig2 document may contain multiple pages, thus the function can return multiple
// images. The images order corresponds to the page number.
func (_gcbe *JBIG2Encoder )DecodeImages (encoded []byte )([]_cg .Image ,error ){const _dgbe ="\u004aB\u0049\u0047\u0032\u0045n\u0063\u006f\u0064\u0065\u0072.\u0044e\u0063o\u0064\u0065\u0049\u006d\u0061\u0067\u0065s";_ggfc ,_cecc :=_ff .Decode (encoded ,_ff .Parameters {},_gcbe .Globals .ToDocumentGlobals ());if _cecc !=nil {return nil ,_cf .Wrap (_cecc ,_dgbe ,"");};_dcbd ,_cecc :=_ggfc .PageNumber ();if _cecc !=nil {return nil ,_cf .Wrap (_cecc ,_dgbe ,"");};_fggff :=[]_cg .Image {};var _fbff _cg .Image ;for _bfge :=1;_bfge <=_dcbd ;_bfge ++{_fbff ,_cecc =_ggfc .DecodePageImage (_bfge );if _cecc !=nil {return nil ,_cf .Wrapf (_cecc ,_dgbe ,"\u0070\u0061\u0067\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_bfge );};_fggff =append (_fggff ,_fbff );};return _fggff ,nil ;};

// ToGoImage converts the JBIG2Image to the golang image.Image.
func (_bbcg *JBIG2Image )ToGoImage ()(_cg .Image ,error ){const _aege ="J\u0042I\u0047\u0032\u0049\u006d\u0061\u0067\u0065\u002eT\u006f\u0047\u006f\u0049ma\u0067\u0065";if _bbcg .Data ==nil {return nil ,_cf .Error (_aege ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");};if _bbcg .Width ==0||_bbcg .Height ==0{return nil ,_cf .Error (_aege ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");};_faac ,_agdg :=_ada .NewImage (_bbcg .Width ,_bbcg .Height ,1,1,_bbcg .Data ,nil ,nil );if _agdg !=nil {return nil ,_agdg ;};return _faac ,nil ;};func _cba (_abbc *PdfObjectStream ,_cbfd *PdfObjectDictionary )(*JBIG2Encoder ,error ){const _bccf ="\u006ee\u0077\u004a\u0042\u0049G\u0032\u0044\u0065\u0063\u006fd\u0065r\u0046r\u006f\u006d\u0053\u0074\u0072\u0065\u0061m";_bgda :=&JBIG2Encoder {};_ebff :=_abbc .PdfObjectDictionary ;if _ebff ==nil {return _bgda ,nil ;};if _cbfd ==nil {_gbce :=_ebff .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _gbce !=nil {switch _abfb :=_gbce .(type ){case *PdfObjectDictionary :_cbfd =_abfb ;case *PdfObjectArray :if _abfb .Len ()==1{if _afab ,_acga :=GetDict (_abfb .Get (0));_acga {_cbfd =_afab ;};};default:_cd .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065P\u0061\u0072\u0061\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064i\u0063\u0074\u0069\u006f\u006e\u0061\u0072y\u0020\u0025\u0023\u0076",_gbce );return nil ,_cf .Errorf (_bccf ,"\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050a\u0072m\u0073\u0020\u0074\u0079\u0070\u0065\u003a \u0025\u0054",_abfb );};};};if _cbfd ==nil {return _bgda ,nil ;};_bgda .UpdateParams (_cbfd );_ggbbb :=_cbfd .Get ("\u004a\u0042\u0049G\u0032\u0047\u006c\u006f\u0062\u0061\u006c\u0073");if _ggbbb ==nil {return _bgda ,nil ;};var _gbe error ;_ggfce ,_bafa :=_ggbbb .(*PdfObjectStream );if !_bafa {_gbe =_cf .Error (_bccf ,"j\u0062\u0069\u0067\u0032\u002e\u0047\u006c\u006f\u0062a\u006c\u0073\u0020\u0073\u0074\u0072\u0065am\u0020\u0073\u0068\u006fu\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u006e\u0020Ob\u006a\u0065c\u0074\u0020\u0053\u0074\u0072\u0065\u0061\u006d");_cd .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_gbe );return nil ,_gbe ;};_bgda .Globals ,_gbe =_cb .DecodeGlobals (_ggfce .Stream );if _gbe !=nil {_gbe =_cf .Wrap (_gbe ,_bccf ,"\u0063\u006f\u0072\u0072u\u0070\u0074\u0065\u0064\u0020\u006a\u0062\u0069\u0067\u0032 \u0065n\u0063\u006f\u0064\u0065\u0064\u0020\u0064a\u0074\u0061");_cd .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_gbe );return nil ,_gbe ;};return _bgda ,nil ;};

// GetTrailer returns the PDFs trailer dictionary. The trailer dictionary is typically the starting point for a PDF,
// referencing other key objects that are important in the document structure.
func (_ddeg *PdfParser )GetTrailer ()*PdfObjectDictionary {return _ddeg ._agac };

// MakeEncodedString creates a PdfObjectString with encoded content, which can be either
// UTF-16BE or PDFDocEncoding depending on whether `utf16BE` is true or false respectively.
func MakeEncodedString (s string ,utf16BE bool )*PdfObjectString {if utf16BE {var _gfdf _dgb .Buffer ;_gfdf .Write ([]byte {0xFE,0xFF});_gfdf .WriteString (_fe .StringToUTF16 (s ));return &PdfObjectString {_eagc :_gfdf .String (),_edafc :true };};return &PdfObjectString {_eagc :string (_fe .StringToPDFDocEncoding (s )),_edafc :false };};

// UpdateParams updates the parameter values of the encoder.
func (_eegd *MultiEncoder )UpdateParams (params *PdfObjectDictionary ){for _ ,_fdee :=range _eegd ._egdf {_fdee .UpdateParams (params );};};

// IsDecimalDigit checks if the character is a part of a decimal number string.
func IsDecimalDigit (c byte )bool {return '0'<=c &&c <='9'};

// GetBool returns the *PdfObjectBool object that is represented by a PdfObject directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetBool (obj PdfObject )(_aaff *PdfObjectBool ,_geaf bool ){_aaff ,_geaf =TraceToDirectObject (obj ).(*PdfObjectBool );return _aaff ,_geaf ;};

// DecodeBytes decodes a multi-encoded slice of bytes by passing it through the
// DecodeBytes method of the underlying encoders.
func (_bgfc *MultiEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_fbcb :=encoded ;var _dade error ;for _ ,_eaff :=range _bgfc ._egdf {_cd .Log .Trace ("\u004du\u006c\u0074i\u0020\u0045\u006e\u0063o\u0064\u0065\u0072 \u0044\u0065\u0063\u006f\u0064\u0065\u003a\u0020\u0041pp\u006c\u0079\u0069n\u0067\u0020F\u0069\u006c\u0074\u0065\u0072\u003a \u0025\u0076 \u0025\u0054",_eaff ,_eaff );_fbcb ,_dade =_eaff .DecodeBytes (_fbcb );if _dade !=nil {return nil ,_dade ;};};return _fbcb ,nil ;};

// FlattenObject returns the contents of `obj`. In other words, `obj` with indirect objects replaced
// by their values.
// The replacements are made recursively to a depth of traceMaxDepth.
// NOTE: Dicts are sorted to make objects with same contents have the same PDF object strings.
func FlattenObject (obj PdfObject )PdfObject {return _dbbg (obj ,0)};

// GetObjectNums returns a sorted list of object numbers of the PDF objects in the file.
func (_afcbg *PdfParser )GetObjectNums ()[]int {var _afdd []int ;for _ ,_cbeg :=range _afcbg ._dgag .ObjectMap {_afdd =append (_afdd ,_cbeg .ObjectNumber );};_g .Ints (_afdd );return _afdd ;};

// GetName returns the *PdfObjectName represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetName (obj PdfObject )(_gffg *PdfObjectName ,_fecdf bool ){_gffg ,_fecdf =TraceToDirectObject (obj ).(*PdfObjectName );return _gffg ,_fecdf ;};func _cfeb (_fcca *PdfObjectStream )(*MultiEncoder ,error ){_dgdbc :=NewMultiEncoder ();_fdd :=_fcca .PdfObjectDictionary ;if _fdd ==nil {return _dgdbc ,nil ;};var _fbba *PdfObjectDictionary ;var _gage []PdfObject ;_dbfg :=_fdd .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _dbfg !=nil {_dffd ,_daa :=_dbfg .(*PdfObjectDictionary );if _daa {_fbba =_dffd ;};_cgcff ,_befd :=_dbfg .(*PdfObjectArray );if _befd {for _ ,_afag :=range _cgcff .Elements (){_afag =TraceToDirectObject (_afag );if _ccac ,_acfg :=_afag .(*PdfObjectDictionary );_acfg {_gage =append (_gage ,_ccac );}else {_gage =append (_gage ,MakeDict ());};};};};_dbfg =_fdd .Get ("\u0046\u0069\u006c\u0074\u0065\u0072");if _dbfg ==nil {return nil ,_aa .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u006d\u0069s\u0073\u0069\u006e\u0067");};_fdfa ,_fgdc :=_dbfg .(*PdfObjectArray );if !_fgdc {return nil ,_aa .Errorf ("m\u0075\u006c\u0074\u0069\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0063\u0061\u006e\u0020\u006f\u006el\u0079\u0020\u0062\u0065\u0020\u006d\u0061\u0064\u0065\u0020fr\u006f\u006d\u0020a\u0072r\u0061\u0079");};for _adga ,_fbgf :=range _fdfa .Elements (){_baba ,_cggad :=_fbgf .(*PdfObjectName );if !_cggad {return nil ,_aa .Errorf ("\u006d\u0075l\u0074\u0069\u0020\u0066i\u006c\u0074e\u0072\u0020\u0061\u0072\u0072\u0061\u0079\u0020e\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u006e\u006f\u0074\u0020\u0061 \u006e\u0061\u006d\u0065");};var _babd PdfObject ;if _fbba !=nil {_babd =_fbba ;}else {if len (_gage )> 0{if _adga >=len (_gage ){return nil ,_aa .Errorf ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0073\u0020\u0069\u006e\u0020d\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006d\u0073\u0020a\u0072\u0072\u0061\u0079");};_babd =_gage [_adga ];};};var _dafc *PdfObjectDictionary ;if _beeb ,_eadeg :=_babd .(*PdfObjectDictionary );_eadeg {_dafc =_beeb ;};_cd .Log .Trace ("\u004e\u0065\u0078t \u006e\u0061\u006d\u0065\u003a\u0020\u0025\u0073\u002c \u0064p\u003a \u0025v\u002c\u0020\u0064\u0050\u0061\u0072\u0061\u006d\u0073\u003a\u0020\u0025\u0076",*_baba ,_babd ,_dafc );if *_baba ==StreamEncodingFilterNameFlate {_dfac ,_bdfgf :=_ddbb (_fcca ,_dafc );if _bdfgf !=nil {return nil ,_bdfgf ;};_dgdbc .AddEncoder (_dfac );}else if *_baba ==StreamEncodingFilterNameLZW {_dcbg ,_bedf :=_gcde (_fcca ,_dafc );if _bedf !=nil {return nil ,_bedf ;};_dgdbc .AddEncoder (_dcbg );}else if *_baba ==StreamEncodingFilterNameASCIIHex {_fdga :=NewASCIIHexEncoder ();_dgdbc .AddEncoder (_fdga );}else if *_baba ==StreamEncodingFilterNameASCII85 {_bagf :=NewASCII85Encoder ();_dgdbc .AddEncoder (_bagf );}else if *_baba ==StreamEncodingFilterNameDCT {_dcdd ,_gad :=_ged (_fcca ,_dgdbc );if _gad !=nil {return nil ,_gad ;};_dgdbc .AddEncoder (_dcdd );_cd .Log .Trace ("A\u0064d\u0065\u0064\u0020\u0044\u0043\u0054\u0020\u0065n\u0063\u006f\u0064\u0065r.\u002e\u002e");_cd .Log .Trace ("\u004du\u006ct\u0069\u0020\u0065\u006e\u0063o\u0064\u0065r\u003a\u0020\u0025\u0023\u0076",_dgdbc );}else {_cd .Log .Error ("U\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0066\u0069l\u0074\u0065\u0072\u0020\u0025\u0073",*_baba );return nil ,_aa .Errorf ("\u0069\u006eva\u006c\u0069\u0064 \u0066\u0069\u006c\u0074er \u0069n \u006d\u0075\u006c\u0074\u0069\u0020\u0066il\u0074\u0065\u0072\u0020\u0061\u0072\u0072a\u0079");};};return _dgdbc ,nil ;};

// GetStream returns the *PdfObjectStream represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetStream (obj PdfObject )(_dcce *PdfObjectStream ,_ecaf bool ){obj =ResolveReference (obj );_dcce ,_ecaf =obj .(*PdfObjectStream );return _dcce ,_ecaf ;};

// String returns a descriptive information string about the encryption method used.
func (_acba *PdfCrypt )String ()string {if _acba ==nil {return "";};_dag :=_acba ._cfd .Filter +"\u0020\u002d\u0020";if _acba ._cfd .V ==0{_dag +="\u0055\u006e\u0064\u006fcu\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0061\u006c\u0067\u006f\u0072\u0069\u0074h\u006d";}else if _acba ._cfd .V ==1{_dag +="\u0052\u0043\u0034:\u0020\u0034\u0030\u0020\u0062\u0069\u0074\u0073";}else if _acba ._cfd .V ==2{_dag +=_aa .Sprintf ("\u0052\u0043\u0034:\u0020\u0025\u0064\u0020\u0062\u0069\u0074\u0073",_acba ._cfd .Length );}else if _acba ._cfd .V ==3{_dag +="U\u006e\u0070\u0075\u0062li\u0073h\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d";}else if _acba ._cfd .V >=4{_dag +=_aa .Sprintf ("\u0053\u0074r\u0065\u0061\u006d\u0020f\u0069\u006ct\u0065\u0072\u003a\u0020\u0025\u0073\u0020\u002d \u0053\u0074\u0072\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0074\u0065r\u003a\u0020\u0025\u0073",_acba ._eeb ,_acba ._cac );_dag +="\u003b\u0020C\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0073\u003a";for _gdgg ,_fccg :=range _acba ._bee {_dag +=_aa .Sprintf ("\u0020\u002d\u0020\u0025\u0073\u003a\u0020\u0025\u0073 \u0028\u0025\u0064\u0029",_gdgg ,_fccg .Name (),_fccg .KeyLength ());};};_dca :=_acba .GetAccessPermissions ();_dag +=_aa .Sprintf ("\u0020\u002d\u0020\u0025\u0023\u0076",_dca );return _dag ;};func _ged (_edcf *PdfObjectStream ,_bebd *MultiEncoder )(*DCTEncoder ,error ){_cda :=NewDCTEncoder ();_fdca :=_edcf .PdfObjectDictionary ;if _fdca ==nil {return _cda ,nil ;};_dfc :=_edcf .Stream ;if _bebd !=nil {_deee ,_bdfg :=_bebd .DecodeBytes (_dfc );if _bdfg !=nil {return nil ,_bdfg ;};_dfc =_deee ;};_ccee :=_dgb .NewReader (_dfc );_ddaf ,_efdc :=_e .DecodeConfig (_ccee );if _efdc !=nil {_cd .Log .Debug ("\u0045\u0072\u0072or\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0065\u003a\u0020\u0025\u0073",_efdc );return nil ,_efdc ;};switch _ddaf .ColorModel {case _ae .RGBAModel :_cda .BitsPerComponent =8;_cda .ColorComponents =3;case _ae .RGBA64Model :_cda .BitsPerComponent =16;_cda .ColorComponents =3;case _ae .GrayModel :_cda .BitsPerComponent =8;_cda .ColorComponents =1;case _ae .Gray16Model :_cda .BitsPerComponent =16;_cda .ColorComponents =1;case _ae .CMYKModel :_cda .BitsPerComponent =8;_cda .ColorComponents =4;case _ae .YCbCrModel :_cda .BitsPerComponent =8;_cda .ColorComponents =3;default:return nil ,_f .New ("\u0075\u006e\u0073up\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u006d\u006f\u0064\u0065\u006c");};_cda .Width =_ddaf .Width ;_cda .Height =_ddaf .Height ;_cd .Log .Trace ("\u0044\u0043T\u0020\u0045\u006ec\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076",_cda );_cda .Quality =DefaultJPEGQuality ;return _cda ,nil ;};

// WriteString outputs the object as it is to be written to file.
func (_aabeb *PdfObjectDictionary )WriteString ()string {var _aafb _ed .Builder ;_aafb .WriteString ("\u003c\u003c");for _ ,_cbda :=range _aabeb ._aedd {_feaf :=_aabeb ._bacc [_cbda ];_aafb .WriteString (_cbda .WriteString ());_aafb .WriteString ("\u0020");_aafb .WriteString (_feaf .WriteString ());};_aafb .WriteString ("\u003e\u003e");return _aafb .String ();};

// WriteString outputs the object as it is to be written to file.
func (_fdcaf *PdfObjectName )WriteString ()string {var _bgbc _dgb .Buffer ;if len (*_fdcaf )> 127{_cd .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u004e\u0061\u006d\u0065\u0020t\u006fo\u0020l\u006f\u006e\u0067\u0020\u0028\u0025\u0073)",*_fdcaf );};_bgbc .WriteString ("\u002f");for _afcbf :=0;_afcbf < len (*_fdcaf );_afcbf ++{_ecag :=(*_fdcaf )[_afcbf ];if !IsPrintable (_ecag )||_ecag =='#'||IsDelimiter (_ecag ){_bgbc .WriteString (_aa .Sprintf ("\u0023\u0025\u002e2\u0078",_ecag ));}else {_bgbc .WriteByte (_ecag );};};return _bgbc .String ();};

// String returns a string describing `null`.
func (_cfead *PdfObjectNull )String ()string {return "\u006e\u0075\u006c\u006c"};

// MakeDict creates and returns an empty PdfObjectDictionary.
func MakeDict ()*PdfObjectDictionary {_geba :=&PdfObjectDictionary {};_geba ._bacc =map[PdfObjectName ]PdfObject {};_geba ._aedd =[]PdfObjectName {};return _geba ;};

// PdfObject is an interface which all primitive PDF objects must implement.
type PdfObject interface{

// String outputs a string representation of the primitive (for debugging).
String ()string ;

// WriteString outputs the PDF primitive as written to file as expected by the standard.
// TODO(dennwc): it should return a byte slice, or accept a writer
WriteString ()string ;};

// WriteString outputs the object as it is to be written to file.
func (_gggc *PdfObjectBool )WriteString ()string {if *_gggc {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};var _fbffe =_c .MustCompile ("\u005e\\\u0073\u002a\u005b\u002d]\u002a\u0028\u005c\u0064\u002b)\u005cs\u002b(\u005c\u0064\u002b\u0029\u005c\u0073\u002bR");func _ebb (_fage int )cryptFilters {return cryptFilters {_cgg :_ag .NewFilterV2 (_fage )}};

// PdfObjectString represents the primitive PDF string object.
type PdfObjectString struct{_eagc string ;_edafc bool ;};func _aecg (_bga *_ag .FilterDict ,_eee *PdfObjectDictionary )error {if _agbe ,_gaae :=_eee .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_gaae {if _fde :=string (*_agbe );_fde !="C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"{_cd .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020C\u0046\u0020\u0064ic\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074e\u0072\u0029",_fde );};};_dcc ,_abe :=_eee .Get ("\u0043\u0046\u004d").(*PdfObjectName );if !_abe {return _aa .Errorf ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0028\u004e\u006f\u006e\u0065\u0029");};_bga .CFM =string (*_dcc );if _cfdg ,_efg :=_eee .Get ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et").(*PdfObjectName );_efg {_bga .AuthEvent =_dd .AuthEvent (*_cfdg );}else {_bga .AuthEvent =_dd .EventDocOpen ;};if _dgc ,_dge :=_eee .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );_dge {_bga .Length =int (*_dgc );};return nil ;};

// NewASCIIHexEncoder makes a new ASCII hex encoder.
func NewASCIIHexEncoder ()*ASCIIHexEncoder {_ddbg :=&ASCIIHexEncoder {};return _ddbg };

// GetIndirect returns the *PdfIndirectObject represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetIndirect (obj PdfObject )(_cagb *PdfIndirectObject ,_gffgf bool ){obj =ResolveReference (obj );_cagb ,_gffgf =obj .(*PdfIndirectObject );return _cagb ,_gffgf ;};

// WriteString outputs the object as it is to be written to file.
func (_bgaba *PdfObjectString )WriteString ()string {var _bddc _dgb .Buffer ;if _bgaba ._edafc {_feag :=_gba .EncodeToString (_bgaba .Bytes ());_bddc .WriteString ("\u003c");_bddc .WriteString (_feag );_bddc .WriteString ("\u003e");return _bddc .String ();};_bffb :=map[byte ]string {'\n':"\u005c\u006e",'\r':"\u005c\u0072",'\t':"\u005c\u0074",'\b':"\u005c\u0062",'\f':"\u005c\u0066",'(':"\u005c\u0028",')':"\u005c\u0029",'\\':"\u005c\u005c"};_bddc .WriteString ("\u0028");for _gdd :=0;_gdd < len (_bgaba ._eagc );_gdd ++{_dbfeg :=_bgaba ._eagc [_gdd ];if _ggbg ,_bage :=_bffb [_dbfeg ];_bage {_bddc .WriteString (_ggbg );}else {_bddc .WriteByte (_dbfeg );};};_bddc .WriteString ("\u0029");return _bddc .String ();};const _cgg ="\u0053\u0074\u0064C\u0046";func _egca (_ffca int )int {if _ffca < 0{return -_ffca ;};return _ffca ;};func _cfa (_bab _ag .Filter ,_cgga _dd .AuthEvent )*PdfObjectDictionary {if _cgga ==""{_cgga =_dd .EventDocOpen ;};_bda :=MakeDict ();_bda .Set ("\u0054\u0079\u0070\u0065",MakeName ("C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"));_bda .Set ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et",MakeName (string (_cgga )));_bda .Set ("\u0043\u0046\u004d",MakeName (_bab .Name ()));_bda .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_bab .KeyLength ())));return _bda ;};func (_adgf *PdfParser )lookupByNumber (_gge int ,_dgbg bool )(PdfObject ,bool ,error ){_gdg ,_ee :=_adgf .ObjCache [_gge ];if _ee {_cd .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0063a\u0063\u0068\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0025\u0064",_gge );return _gdg ,false ,nil ;};_dac ,_ee :=_adgf ._dgag .ObjectMap [_gge ];if !_ee {_cd .Log .Trace ("\u0055\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u006c\u006f\u0063\u0061t\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0069\u006e\u0020\u0078\u0072\u0065\u0066\u0073\u0021 \u002d\u0020\u0052\u0065\u0074u\u0072\u006e\u0069\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074");var _dcg PdfObjectNull ;return &_dcg ,false ,nil ;};_cd .Log .Trace ("L\u006fo\u006b\u0075\u0070\u0020\u006f\u0062\u006a\u0020n\u0075\u006d\u0062\u0065r \u0025\u0064",_gge );if _dac .XType ==XrefTypeTableEntry {_cd .Log .Trace ("\u0078r\u0065f\u006f\u0062\u006a\u0020\u006fb\u006a\u0020n\u0075\u006d\u0020\u0025\u0064",_dac .ObjectNumber );_cd .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u0067e\u006e\u0020\u0025\u0064",_dac .Generation );_cd .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0064",_dac .Offset );_adgf ._egfc .Seek (_dac .Offset ,_df .SEEK_SET );_adgf ._bfbbd =_adg .NewReader (_adgf ._egfc );_agb ,_fec :=_adgf .ParseIndirectObject ();if _fec !=nil {_cd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006ce\u0064\u0020\u0072\u0065\u0061\u0064\u0069n\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029",_fec );if _dgbg {_cd .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0072\u0065\u0070\u0061\u0069r\u0020\u0078\u0072\u0065\u0066\u0073\u0020\u0028\u0074\u006f\u0070\u0020d\u006f\u0077\u006e\u0029");_ddc ,_edd :=_adgf .repairRebuildXrefsTopDown ();if _edd !=nil {_cd .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020r\u0065\u0070\u0061\u0069\u0072\u0020\u0028\u0025\u0073\u0029",_edd );return nil ,false ,_edd ;};_adgf ._dgag =*_ddc ;return _adgf .lookupByNumber (_gge ,false );};return nil ,false ,_fec ;};if _dgbg {_ade ,_ ,_ :=_dgbd (_agb );if int (_ade )!=_gge {_cd .Log .Debug ("\u0049n\u0076\u0061\u006c\u0069d\u0020\u0078\u0072\u0065\u0066s\u003a \u0052e\u0062\u0075\u0069\u006c\u0064\u0069\u006eg");_fda :=_adgf .rebuildXrefTable ();if _fda !=nil {return nil ,false ,_fda ;};_adgf .ObjCache =objectCache {};return _adgf .lookupByNumberWrapper (_gge ,false );};};_cd .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006f\u0062\u006a");_adgf .ObjCache [_gge ]=_agb ;return _agb ,false ,nil ;}else if _dac .XType ==XrefTypeObjectStream {_cd .Log .Trace ("\u0078r\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0021");_cd .Log .Trace ("\u003e\u004c\u006f\u0061\u0064\u0020\u0076\u0069\u0061\u0020\u004f\u0053\u0021");_cd .Log .Trace ("\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d \u0061\u0076\u0061\u0069\u006c\u0061b\u006c\u0065\u0020\u0069\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020%\u0064\u002f\u0025\u0064",_dac .OsObjNumber ,_dac .OsObjIndex );if _dac .OsObjNumber ==_gge {_cd .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0043i\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065f\u0065\u0072\u0065n\u0063e\u0021\u003f\u0021");return nil ,true ,_f .New ("\u0078\u0072\u0065f \u0063\u0069\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");};if _ ,_adgb :=_adgf ._dgag .ObjectMap [_dac .OsObjNumber ];_adgb {_cce ,_fed :=_adgf .lookupObjectViaOS (_dac .OsObjNumber ,_gge );if _fed !=nil {_cd .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0052\u0065\u0074\u0075\u0072\u006e\u0069n\u0067\u0020\u0045\u0052\u0052\u0020\u0028\u0025\u0073\u0029",_fed );return nil ,true ,_fed ;};_cd .Log .Trace ("\u003c\u004c\u006f\u0061\u0064\u0065\u0064\u0020\u0076i\u0061\u0020\u004f\u0053");_adgf .ObjCache [_gge ]=_cce ;if _adgf ._egc !=nil {_adgf ._egc ._ece [_cce ]=true ;};return _cce ,true ,nil ;};_cd .Log .Debug ("\u003f\u003f\u0020\u0042\u0065\u006c\u006f\u006eg\u0073\u0020\u0074o \u0061\u0020\u006e\u006f\u006e\u002dc\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u002e.\u002e\u0021");return nil ,true ,_f .New ("\u006f\u0073\u0020\u0062\u0065\u006c\u006fn\u0067\u0073\u0020t\u006f\u0020\u0061\u0020n\u006f\u006e\u0020\u0063\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074");};return nil ,false ,_f .New ("\u0075\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0078\u0072\u0065\u0066 \u0074\u0079\u0070\u0065");};

// GetNameVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetNameVal (obj PdfObject )(_bbbc string ,_beg bool ){_gbece ,_beg :=TraceToDirectObject (obj ).(*PdfObjectName );if _beg {return string (*_gbece ),true ;};return ;};

// DecodeBytes decodes a slice of DCT encoded bytes and returns the result.
func (_ecb *DCTEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_cggb :=_dgb .NewReader (encoded );_agd ,_eaad :=_e .Decode (_cggb );if _eaad !=nil {_cd .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006eg\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_eaad );return nil ,_eaad ;};_afb :=_agd .Bounds ();var _ccfd =make ([]byte ,_afb .Dx ()*_afb .Dy ()*_ecb .ColorComponents *_ecb .BitsPerComponent /8);_ecdd :=0;for _bgge :=_afb .Min .Y ;_bgge < _afb .Max .Y ;_bgge ++{for _efdg :=_afb .Min .X ;_efdg < _afb .Max .X ;_efdg ++{_ddbbe :=_agd .At (_efdg ,_bgge );if _ecb .ColorComponents ==1{if _ecb .BitsPerComponent ==16{_dad ,_gecg :=_ddbbe .(_ae .Gray16 );if !_gecg {return nil ,_f .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_ccfd [_ecdd ]=byte ((_dad .Y >>8)&0xff);_ecdd ++;_ccfd [_ecdd ]=byte (_dad .Y &0xff);_ecdd ++;}else {_abadg ,_cfb :=_ddbbe .(_ae .Gray );if !_cfb {return nil ,_f .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_ccfd [_ecdd ]=byte (_abadg .Y &0xff);_ecdd ++;};}else if _ecb .ColorComponents ==3{if _ecb .BitsPerComponent ==16{_eefd ,_cdce :=_ddbbe .(_ae .RGBA64 );if !_cdce {return nil ,_f .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_ccfd [_ecdd ]=byte ((_eefd .R >>8)&0xff);_ecdd ++;_ccfd [_ecdd ]=byte (_eefd .R &0xff);_ecdd ++;_ccfd [_ecdd ]=byte ((_eefd .G >>8)&0xff);_ecdd ++;_ccfd [_ecdd ]=byte (_eefd .G &0xff);_ecdd ++;_ccfd [_ecdd ]=byte ((_eefd .B >>8)&0xff);_ecdd ++;_ccfd [_ecdd ]=byte (_eefd .B &0xff);_ecdd ++;}else {_eacd ,_bccg :=_ddbbe .(_ae .RGBA );if _bccg {_ccfd [_ecdd ]=_eacd .R &0xff;_ecdd ++;_ccfd [_ecdd ]=_eacd .G &0xff;_ecdd ++;_ccfd [_ecdd ]=_eacd .B &0xff;_ecdd ++;}else {_ddfc ,_aefg :=_ddbbe .(_ae .YCbCr );if !_aefg {return nil ,_f .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_fece ,_fbdd ,_gaeg ,_ :=_ddfc .RGBA ();_ccfd [_ecdd ]=byte (_fece >>8);_ecdd ++;_ccfd [_ecdd ]=byte (_fbdd >>8);_ecdd ++;_ccfd [_ecdd ]=byte (_gaeg >>8);_ecdd ++;};};}else if _ecb .ColorComponents ==4{_fdec ,_eaaa :=_ddbbe .(_ae .CMYK );if !_eaaa {return nil ,_f .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_ccfd [_ecdd ]=255-_fdec .C &0xff;_ecdd ++;_ccfd [_ecdd ]=255-_fdec .M &0xff;_ecdd ++;_ccfd [_ecdd ]=255-_fdec .Y &0xff;_ecdd ++;_ccfd [_ecdd ]=255-_fdec .K &0xff;_ecdd ++;};};};return _ccfd ,nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_cabg *RawEncoder )MakeDecodeParams ()PdfObject {return nil };func (_dffa *PdfCrypt )isDecrypted (_agcd PdfObject )bool {_ ,_cceb :=_dffa ._ece [_agcd ];if _cceb {_cd .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0064\u0065\u0063\u0072y\u0070\u0074\u0065\u0064");return true ;};switch _gcg :=_agcd .(type ){case *PdfObjectStream :if _dffa ._cgd .R !=5{if _fff ,_ecc :=_gcg .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_ecc &&*_fff =="\u0058\u0052\u0065\u0066"{return true ;};};case *PdfIndirectObject :if _ ,_cceb =_dffa ._cgaf [int (_gcg .ObjectNumber )];_cceb {return true ;};switch _aece :=_gcg .PdfObject .(type ){case *PdfObjectDictionary :_fgca :=true ;for _ ,_fadd :=range _cdf {if _aece .Get (_fadd )==nil {_fgca =false ;break ;};};if _fgca {return true ;};};};_cd .Log .Trace ("\u004e\u006f\u0074\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");return false ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_dfdb *JPXEncoder )MakeDecodeParams ()PdfObject {return nil };

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_abdf *RunLengthEncoder )MakeDecodeParams ()PdfObject {return nil };

// EncodeBytes JPX encodes the passed in slice of bytes.
func (_bbdg *JPXEncoder )EncodeBytes (data []byte )([]byte ,error ){_cd .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_bbdg .GetFilterName ());return data ,ErrNoJPXDecode ;};

// WriteString outputs the object as it is to be written to file.
func (_eadf *PdfObjectInteger )WriteString ()string {return _d .FormatInt (int64 (*_eadf ),10)};

// DecodeGlobals decodes 'encoded' byte stream and returns their Globally defined segments ('Globals').
func (_debe *JBIG2Encoder )DecodeGlobals (encoded []byte )(_cb .Globals ,error ){return _cb .DecodeGlobals (encoded );};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_faef *JPXEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};

// EncodeBytes ASCII encodes the passed in slice of bytes.
func (_adda *ASCIIHexEncoder )EncodeBytes (data []byte )([]byte ,error ){var _baef _dgb .Buffer ;for _ ,_bba :=range data {_baef .WriteString (_aa .Sprintf ("\u0025\u002e\u0032X\u0020",_bba ));};_baef .WriteByte ('>');return _baef .Bytes (),nil ;};func (_fadf *PdfParser )parseString ()(*PdfObjectString ,error ){_fadf ._bfbbd .ReadByte ();var _fcfe _dgb .Buffer ;_gced :=1;for {_bbe ,_fca :=_fadf ._bfbbd .Peek (1);if _fca !=nil {return MakeString (_fcfe .String ()),_fca ;};if _bbe [0]=='\\'{_fadf ._bfbbd .ReadByte ();_ebdd ,_deebg :=_fadf ._bfbbd .ReadByte ();if _deebg !=nil {return MakeString (_fcfe .String ()),_deebg ;};if IsOctalDigit (_ebdd ){_fgfdg ,_fffd :=_fadf ._bfbbd .Peek (2);if _fffd !=nil {return MakeString (_fcfe .String ()),_fffd ;};var _dacf []byte ;_dacf =append (_dacf ,_ebdd );for _ ,_cbac :=range _fgfdg {if IsOctalDigit (_cbac ){_dacf =append (_dacf ,_cbac );}else {break ;};};_fadf ._bfbbd .Discard (len (_dacf )-1);_cd .Log .Trace ("\u004e\u0075\u006d\u0065ri\u0063\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0022\u0025\u0073\u0022",_dacf );_befdb ,_fffd :=_d .ParseUint (string (_dacf ),8,32);if _fffd !=nil {return MakeString (_fcfe .String ()),_fffd ;};_fcfe .WriteByte (byte (_befdb ));continue ;};switch _ebdd {case 'n':_fcfe .WriteRune ('\n');case 'r':_fcfe .WriteRune ('\r');case 't':_fcfe .WriteRune ('\t');case 'b':_fcfe .WriteRune ('\b');case 'f':_fcfe .WriteRune ('\f');case '(':_fcfe .WriteRune ('(');case ')':_fcfe .WriteRune (')');case '\\':_fcfe .WriteRune ('\\');};continue ;}else if _bbe [0]=='('{_gced ++;}else if _bbe [0]==')'{_gced --;if _gced ==0{_fadf ._bfbbd .ReadByte ();break ;};};_bfed ,_ :=_fadf ._bfbbd .ReadByte ();_fcfe .WriteByte (_bfed );};return MakeString (_fcfe .String ()),nil ;};

// MakeIndirectObject creates an PdfIndirectObject with a specified direct object PdfObject.
func MakeIndirectObject (obj PdfObject )*PdfIndirectObject {_fagc :=&PdfIndirectObject {};_fagc .PdfObject =obj ;return _fagc ;};

// PdfObjectReference represents the primitive PDF reference object.
type PdfObjectReference struct{_dbca *PdfParser ;ObjectNumber int64 ;GenerationNumber int64 ;};

// CCITTFaxEncoder implements Group3 and Group4 facsimile (fax) encoder/decoder.
type CCITTFaxEncoder struct{K int ;EndOfLine bool ;EncodedByteAlign bool ;Columns int ;Rows int ;EndOfBlock bool ;BlackIs1 bool ;DamagedRowsBeforeError int ;};

// ParseNumber parses a numeric objects from a buffered stream.
// Section 7.3.3.
// Integer or Float.
//
// An integer shall be written as one or more decimal digits optionally
// preceded by a sign. The value shall be interpreted as a signed
// decimal integer and shall be converted to an integer object.
//
// A real value shall be written as one or more decimal digits with an
// optional sign and a leading, trailing, or embedded PERIOD (2Eh)
// (decimal point). The value shall be interpreted as a real number
// and shall be converted to a real object.
//
// Regarding exponential numbers: 7.3.3 Numeric Objects:
// A conforming writer shall not use the PostScript syntax for numbers
// with non-decimal radices (such as 16#FFFE) or in exponential format
// (such as 6.02E23).
// Nonetheless, we sometimes get numbers with exponential format, so
// we will support it in the reader (no confusion with other types, so
// no compromise).
func ParseNumber (buf *_adg .Reader )(PdfObject ,error ){_bedfd :=false ;_gfcb :=true ;var _dacg _dgb .Buffer ;for {if _cd .Log .IsLogLevel (_cd .LogLevelTrace ){_cd .Log .Trace ("\u0050\u0061\u0072\u0073in\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0022\u0025\u0073\u0022",_dacg .String ());};_aaac ,_dcdf :=buf .Peek (1);if _dcdf ==_gb .EOF {break ;};if _dcdf !=nil {_cd .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0025\u0073",_dcdf );return nil ,_dcdf ;};if _gfcb &&(_aaac [0]=='-'||_aaac [0]=='+'){_fbeg ,_ :=buf .ReadByte ();_dacg .WriteByte (_fbeg );_gfcb =false ;}else if IsDecimalDigit (_aaac [0]){_deead ,_ :=buf .ReadByte ();_dacg .WriteByte (_deead );}else if _aaac [0]=='.'{_abbfd ,_ :=buf .ReadByte ();_dacg .WriteByte (_abbfd );_bedfd =true ;}else if _aaac [0]=='e'||_aaac [0]=='E'{_gbdce ,_ :=buf .ReadByte ();_dacg .WriteByte (_gbdce );_bedfd =true ;_gfcb =true ;}else {break ;};};var _gbfd PdfObject ;if _bedfd {_eefb ,_eafe :=_d .ParseFloat (_dacg .String (),64);if _eafe !=nil {_cd .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0025v\u0020\u0065\u0072\u0072\u003d\u0025v\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0030\u002e\u0020\u004fu\u0074\u0070u\u0074\u0020\u006d\u0061y\u0020\u0062\u0065\u0020\u0069n\u0063\u006f\u0072\u0072\u0065\u0063\u0074",_dacg .String (),_eafe );_eefb =0.0;_eafe =nil ;};_bbdaa :=PdfObjectFloat (_eefb );_gbfd =&_bbdaa ;}else {_bgbcg ,_ffgbb :=_d .ParseInt (_dacg .String (),10,64);if _ffgbb !=nil {_cd .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0025\u0076\u0020\u0065\u0072\u0072\u003d%\u0076\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074 \u006d\u0061\u0079\u0020\u0062\u0065 \u0069\u006ec\u006f\u0072r\u0065c\u0074",_dacg .String (),_ffgbb );_bgbcg =0;_ffgbb =nil ;};_dada :=PdfObjectInteger (_bgbcg );_gbfd =&_dada ;};return _gbfd ,nil ;};

// GetFilterName returns the name of the encoding filter.
func (_acg *LZWEncoder )GetFilterName ()string {return StreamEncodingFilterNameLZW };const JB2ImageAutoThreshold =-1.0;

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set.  Some other parameters are generated elsewhere.
func (_eeg *DCTEncoder )MakeStreamDict ()*PdfObjectDictionary {_abad :=MakeDict ();_abad .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_eeg .GetFilterName ()));return _abad ;};type offsetReader struct{_daef _gb .ReadSeeker ;_efba int64 ;};func _gcde (_efa *PdfObjectStream ,_ccf *PdfObjectDictionary )(*LZWEncoder ,error ){_cgad :=NewLZWEncoder ();_dfb :=_efa .PdfObjectDictionary ;if _dfb ==nil {return _cgad ,nil ;};if _ccf ==nil {_efag :=TraceToDirectObject (_dfb .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));if _efag !=nil {if _ffdg ,_cebb :=_efag .(*PdfObjectDictionary );_cebb {_ccf =_ffdg ;}else if _bgad ,_cabf :=_efag .(*PdfObjectArray );_cabf {if _bgad .Len ()==1{if _gcgd ,_eae :=GetDict (_bgad .Get (0));_eae {_ccf =_gcgd ;};};};if _ccf ==nil {_cd .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_efag );return nil ,_aa .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};};_cfac :=_dfb .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");if _cfac !=nil {_agbb ,_ffbg :=_cfac .(*PdfObjectInteger );if !_ffbg {_cd .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a \u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065d\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u006e\u0075\u006d\u0065\u0072i\u0063 \u0028\u0025\u0054\u0029",_cfac );return nil ,_aa .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");};if *_agbb !=0&&*_agbb !=1{return nil ,_aa .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0076\u0061\u006c\u0075e\u0020\u0028\u006e\u006f\u0074 \u0030\u0020o\u0072\u0020\u0031\u0029");};_cgad .EarlyChange =int (*_agbb );}else {_cgad .EarlyChange =1;};if _ccf ==nil {return _cgad ,nil ;};_cfac =_ccf .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");if _cfac !=nil {_ebf ,_beab :=_cfac .(*PdfObjectInteger );if !_beab {_cd .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_cfac );return nil ,_aa .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_cgad .Predictor =int (*_ebf );};_cfac =_ccf .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");if _cfac !=nil {_ffa ,_gdf :=_cfac .(*PdfObjectInteger );if !_gdf {_cd .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");return nil ,_aa .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_cgad .BitsPerComponent =int (*_ffa );};if _cgad .Predictor > 1{_cgad .Columns =1;_cfac =_ccf .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");if _cfac !=nil {_bbfg ,_gaeb :=_cfac .(*PdfObjectInteger );if !_gaeb {return nil ,_aa .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_cgad .Columns =int (*_bbfg );};_cgad .Colors =1;_cfac =_ccf .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _cfac !=nil {_dbg ,_bbgd :=_cfac .(*PdfObjectInteger );if !_bbgd {return nil ,_aa .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");};_cgad .Colors =int (*_dbg );};};_cd .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_ccf .String ());return _cgad ,nil ;};

// XrefTable represents the cross references in a PDF, i.e. the table of objects and information
// where to access within the PDF file.
type XrefTable struct{ObjectMap map[int ]XrefObject ;_ca []XrefObject ;};func (_efbe *PdfParser )xrefNextObjectOffset (_ebbge int64 )int64 {_bddgf :=int64 (0);if len (_efbe ._dgag .ObjectMap )==0{return 0;};if len (_efbe ._dgag ._ca )==0{_geae :=0;for _ ,_facd :=range _efbe ._dgag .ObjectMap {if _facd .Offset > 0{_geae ++;};};if _geae ==0{return 0;};_efbe ._dgag ._ca =make ([]XrefObject ,_geae );_gfec :=0;for _ ,_gdbf :=range _efbe ._dgag .ObjectMap {if _gdbf .Offset > 0{_efbe ._dgag ._ca [_gfec ]=_gdbf ;_gfec ++;};};_g .Slice (_efbe ._dgag ._ca ,func (_faddc ,_abaac int )bool {return _efbe ._dgag ._ca [_faddc ].Offset < _efbe ._dgag ._ca [_abaac ].Offset });};_cef :=_g .Search (len (_efbe ._dgag ._ca ),func (_ggff int )bool {return _efbe ._dgag ._ca [_ggff ].Offset >=_ebbge });if _cef < len (_efbe ._dgag ._ca ){_bddgf =_efbe ._dgag ._ca [_cef ].Offset ;};return _bddgf ;};

// NewMultiEncoder returns a new instance of MultiEncoder.
func NewMultiEncoder ()*MultiEncoder {_bade :=MultiEncoder {};_bade ._egdf =[]StreamEncoder {};return &_bade ;};

// MakeStream creates an PdfObjectStream with specified contents and encoding. If encoding is nil, then raw encoding
// will be used (i.e. no encoding applied).
func MakeStream (contents []byte ,encoder StreamEncoder )(*PdfObjectStream ,error ){_abcf :=&PdfObjectStream {};if encoder ==nil {encoder =NewRawEncoder ();};_abcf .PdfObjectDictionary =encoder .MakeStreamDict ();_eefc ,_edge :=encoder .EncodeBytes (contents );if _edge !=nil {return nil ,_edge ;};_abcf .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_eefc ))));_abcf .Stream =_eefc ;return _abcf ,nil ;};

// NewJPXEncoder returns a new instance of JPXEncoder.
func NewJPXEncoder ()*JPXEncoder {return &JPXEncoder {}};const (DefaultJPEGQuality =75;);

// ToInt64Slice returns a slice of all array elements as an int64 slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_caga *PdfObjectArray )ToInt64Slice ()([]int64 ,error ){var _abfgf []int64 ;for _ ,_bcbb :=range _caga .Elements (){if _gcce ,_gdac :=_bcbb .(*PdfObjectInteger );_gdac {_abfgf =append (_abfgf ,int64 (*_gcce ));}else {return nil ,ErrTypeError ;};};return _abfgf ,nil ;};

// IsDelimiter checks if a character represents a delimiter.
func IsDelimiter (c byte )bool {return c =='('||c ==')'||c =='<'||c =='>'||c =='['||c ==']'||c =='{'||c =='}'||c =='/'||c =='%';};

// PdfObjectStream represents the primitive PDF Object stream.
type PdfObjectStream struct{PdfObjectReference ;*PdfObjectDictionary ;Stream []byte ;};

// Encode encodes previously prepare jbig2 document and stores it as the byte slice.
func (_dffec *JBIG2Encoder )Encode ()(_ddbcg []byte ,_fea error ){const _baff ="J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0045\u006eco\u0064\u0065";if _dffec ._dggg ==nil {return nil ,_cf .Errorf (_baff ,"\u0064\u006f\u0063u\u006d\u0065\u006e\u0074 \u0069\u006e\u0070\u0075\u0074\u0020\u0064a\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006e\u0065\u0064");};_dffec ._dggg .FullHeaders =_dffec .DefaultPageSettings .FileMode ;_ddbcg ,_fea =_dffec ._dggg .Encode ();if _fea !=nil {return nil ,_cf .Wrap (_fea ,_baff ,"");};return _ddbcg ,nil ;};

// NewDCTEncoder makes a new DCT encoder with default parameters.
func NewDCTEncoder ()*DCTEncoder {_dbgd :=&DCTEncoder {};_dbgd .ColorComponents =3;_dbgd .BitsPerComponent =8;_dbgd .Quality =DefaultJPEGQuality ;return _dbgd ;};

// WriteString outputs the object as it is to be written to file.
func (_caaf *PdfObjectStream )WriteString ()string {var _ceag _ed .Builder ;_ceag .WriteString (_d .FormatInt (_caaf .ObjectNumber ,10));_ceag .WriteString ("\u0020\u0030\u0020\u0052");return _ceag .String ();};func (_dcad *PdfCrypt )securityHandler ()_dd .StdHandler {if _dcad ._cgd .R >=5{return _dd .NewHandlerR6 ();};return _dd .NewHandlerR4 (_dcad ._gfc ,_dcad ._cfd .Length );};

// String returns a string describing `ind`.
func (_eecab *PdfIndirectObject )String ()string {return _aa .Sprintf ("\u0049\u004f\u0062\u006a\u0065\u0063\u0074\u003a\u0025\u0064",(*_eecab ).ObjectNumber );};

// IsEncrypted checks if the document is encrypted. A bool flag is returned indicating the result.
// First time when called, will check if the Encrypt dictionary is accessible through the trailer dictionary.
// If encrypted, prepares a crypt datastructure which can be used to authenticate and decrypt the document.
// On failure, an error is returned.
func (_aad *PdfParser )IsEncrypted ()(bool ,error ){if _aad ._egc !=nil {return true ,nil ;}else if _aad ._agac ==nil {return false ,nil ;};_cd .Log .Trace ("\u0043\u0068\u0065c\u006b\u0069\u006e\u0067 \u0065\u006e\u0063\u0072\u0079\u0070\u0074i\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0021");_bebee :=_aad ._agac .Get ("\u0045n\u0063\u0072\u0079\u0070\u0074");if _bebee ==nil {return false ,nil ;};_cd .Log .Trace ("\u0049\u0073\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u0021");var (_cgde *PdfObjectDictionary ;);switch _gdfg :=_bebee .(type ){case *PdfObjectDictionary :_cgde =_gdfg ;case *PdfObjectReference :_cd .Log .Trace ("\u0030\u003a\u0020\u004c\u006f\u006f\u006b\u0020\u0075\u0070\u0020\u0072e\u0066\u0020\u0025\u0071",_gdfg );_fagd ,_ddgaa :=_aad .LookupByReference (*_gdfg );_cd .Log .Trace ("\u0031\u003a\u0020%\u0071",_fagd );if _ddgaa !=nil {return false ,_ddgaa ;};_fabeg ,_dfafc :=_fagd .(*PdfIndirectObject );if !_dfafc {_cd .Log .Debug ("E\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006eo\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072ec\u0074\u0020\u006fb\u006ae\u0063\u0074");return false ,_f .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");};_ecde ,_dfafc :=_fabeg .PdfObject .(*PdfObjectDictionary );_cd .Log .Trace ("\u0032\u003a\u0020%\u0071",_ecde );if !_dfafc {return false ,_f .New ("\u0074\u0072a\u0069\u006c\u0065\u0072 \u0045\u006ec\u0072\u0079\u0070\u0074\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u006e\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");};_cgde =_ecde ;case *PdfObjectNull :_cd .Log .Debug ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074 \u0069\u0073\u0020a\u0020\u006e\u0075l\u006c\u0020o\u0062\u006a\u0065\u0063\u0074\u002e \u0046il\u0065\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u002e");return false ,nil ;default:return false ,_aa .Errorf ("u\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0079\u0070\u0065: \u0025\u0054",_gdfg );};_deade ,_bdgg :=PdfCryptNewDecrypt (_aad ,_cgde ,_aad ._agac );if _bdgg !=nil {return false ,_bdgg ;};for _ ,_cecd :=range []string {"\u0049\u006e\u0066\u006f","\u0045n\u0063\u0072\u0079\u0070\u0074"}{_fdcf :=_aad ._agac .Get (PdfObjectName (_cecd ));if _fdcf ==nil {continue ;};switch _aegg :=_fdcf .(type ){case *PdfObjectReference :_deade ._cgaf [int (_aegg .ObjectNumber )]=struct{}{};case *PdfIndirectObject :_deade ._ece [_aegg ]=true ;_deade ._cgaf [int (_aegg .ObjectNumber )]=struct{}{};};};_aad ._egc =_deade ;_cd .Log .Trace ("\u0043\u0072\u0079\u0070\u0074\u0065\u0072\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0025\u0062",_deade );return true ,nil ;};

// MakeArrayFromIntegers64 creates an PdfObjectArray from a slice of int64s, where each array element
// is an PdfObjectInteger.
func MakeArrayFromIntegers64 (vals []int64 )*PdfObjectArray {_dccff :=MakeArray ();for _ ,_eeff :=range vals {_dccff .Append (MakeInteger (_eeff ));};return _dccff ;};func _cgdc (_faab string )(PdfObjectReference ,error ){_bdgc :=PdfObjectReference {};_bgbe :=_fbffe .FindStringSubmatch (string (_faab ));if len (_bgbe )< 3{_cd .Log .Debug ("\u0045\u0072\u0072or\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");return _bdgc ,_f .New ("\u0075n\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061r\u0073e\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");};_ffgg ,_ :=_d .Atoi (_bgbe [1]);_eecg ,_ :=_d .Atoi (_bgbe [2]);_bdgc .ObjectNumber =int64 (_ffgg );_bdgc .GenerationNumber =int64 (_eecg );return _bdgc ,nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_ecca *ASCII85Encoder )UpdateParams (params *PdfObjectDictionary ){};

// DecodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_cggc *RawEncoder )DecodeBytes (encoded []byte )([]byte ,error ){return encoded ,nil };

// GetFilterName returns the name of the encoding filter.
func (_gbac *DCTEncoder )GetFilterName ()string {return StreamEncodingFilterNameDCT };

// PdfObjectInteger represents the primitive PDF integer numerical object.
type PdfObjectInteger int64 ;

// ReadBytesAt reads byte content at specific offset and length within the PDF.
func (_beae *PdfParser )ReadBytesAt (offset ,len int64 )([]byte ,error ){_cgfc :=_beae .GetFileOffset ();_ ,_agfbd :=_beae ._egfc .Seek (offset ,_gb .SeekStart );if _agfbd !=nil {return nil ,_agfbd ;};_cedg :=make ([]byte ,len );_ ,_agfbd =_gb .ReadAtLeast (_beae ._egfc ,_cedg ,int (len ));if _agfbd !=nil {return nil ,_agfbd ;};_beae .SetFileOffset (_cgfc );return _cedg ,nil ;};

// Resolve resolves a PdfObject to direct object, looking up and resolving references as needed (unlike TraceToDirect).
func (_dcff *PdfParser )Resolve (obj PdfObject )(PdfObject ,error ){_fae ,_gbc :=obj .(*PdfObjectReference );if !_gbc {return obj ,nil ;};_agc :=_dcff .GetFileOffset ();defer func (){_dcff .SetFileOffset (_agc )}();_aec ,_db :=_dcff .LookupByReference (*_fae );if _db !=nil {return nil ,_db ;};_acc ,_gaa :=_aec .(*PdfIndirectObject );if !_gaa {return _aec ,nil ;};_aec =_acc .PdfObject ;_ ,_gbc =_aec .(*PdfObjectReference );if _gbc {return _acc ,_f .New ("\u006d\u0075lt\u0069\u0020\u0064e\u0070\u0074\u0068\u0020tra\u0063e \u0070\u006f\u0069\u006e\u0074\u0065\u0072 t\u006f\u0020\u0070\u006f\u0069\u006e\u0074e\u0072");};return _aec ,nil ;};