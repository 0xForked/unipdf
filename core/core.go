//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package core defines and implements the primitive PDF object types in golang, and provides functionality
// for parsing those from a PDF file stream. This includes I/O handling, cross references, repairs, encryption,
// encoding and other core capabilities.
package core ;import (_faf "bufio";_fda "bytes";_ac "compress/lzw";_fd "compress/zlib";_fad "crypto/md5";_fc "crypto/rand";_e "encoding/hex";_g "errors";_ae "fmt";_fdf "github.com/unidoc/unipdf/v3/common";_gdb "github.com/unidoc/unipdf/v3/core/security";
_fg "github.com/unidoc/unipdf/v3/core/security/crypt";_bbe "github.com/unidoc/unipdf/v3/internal/ccittfax";_gg "github.com/unidoc/unipdf/v3/internal/imageutil";_ff "github.com/unidoc/unipdf/v3/internal/jbig2";_ec "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";
_ded "github.com/unidoc/unipdf/v3/internal/jbig2/decoder";_fdc "github.com/unidoc/unipdf/v3/internal/jbig2/document";_cd "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_dd "github.com/unidoc/unipdf/v3/internal/strutils";_db "golang.org/x/image/tiff/lzw";
_bc "golang.org/x/xerrors";_bd "image";_gf "image/color";_de "image/jpeg";_ef "io";_gd "io/ioutil";_b "reflect";_ge "regexp";_c "sort";_bb "strconv";_gc "strings";_a "sync";_fa "time";_f "unicode";);func (_gedc *PdfCrypt )isEncrypted (_dcd PdfObject )bool {_ ,_gaa :=_gedc ._fcad [_dcd ];
if _gaa {_fdf .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0065\u006e\u0063\u0072y\u0070\u0074\u0065\u0064");return true ;};_fdf .Log .Trace ("\u004e\u006f\u0074\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");
return false ;};const (XrefTypeTableEntry xrefType =iota ;XrefTypeObjectStream xrefType =iota ;);func (_abff *PdfObjectFloat )String ()string {return _ae .Sprintf ("\u0025\u0066",*_abff )};

// StreamEncoder represents the interface for all PDF stream encoders.
type StreamEncoder interface{GetFilterName ()string ;MakeDecodeParams ()PdfObject ;MakeStreamDict ()*PdfObjectDictionary ;UpdateParams (_gfc *PdfObjectDictionary );EncodeBytes (_dga []byte )([]byte ,error );DecodeBytes (_cage []byte )([]byte ,error );DecodeStream (_ccad *PdfObjectStream )([]byte ,error );
};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_afdf *RawEncoder )MakeDecodeParams ()PdfObject {return nil };func (_caac *PdfParser )skipSpaces ()(int ,error ){_gbbg :=0;for {_bgff ,_dadg :=_caac ._bdg .ReadByte ();if _dadg !=nil {return 0,_dadg ;};if IsWhiteSpace (_bgff ){_gbbg ++;}else {_caac ._bdg .UnreadByte ();
break ;};};return _gbbg ,nil ;};

// MakeInteger creates a PdfObjectInteger from an int64.
func MakeInteger (val int64 )*PdfObjectInteger {_bgacc :=PdfObjectInteger (val );return &_bgacc };type objectStreams map[int ]objectStream ;

// GetString is a helper for Get that returns a string value.
// Returns false if the key is missing or a value is not a string.
func (_bcgg *PdfObjectDictionary )GetString (key PdfObjectName )(string ,bool ){_dgdd :=_bcgg .Get (key );if _dgdd ==nil {return "",false ;};_bfff ,_adbe :=_dgdd .(*PdfObjectString );if !_adbe {return "",false ;};return _bfff .Str (),true ;};

// NewRunLengthEncoder makes a new run length encoder
func NewRunLengthEncoder ()*RunLengthEncoder {return &RunLengthEncoder {}};

// ResolveReferencesDeep recursively traverses through object `o`, looking up and replacing
// references with indirect objects.
// Optionally a map of already deep-resolved objects can be provided via `traversed`. The `traversed` map
// is updated while traversing the objects to avoid traversing same objects multiple times.
func ResolveReferencesDeep (o PdfObject ,traversed map[PdfObject ]struct{})error {if traversed ==nil {traversed =map[PdfObject ]struct{}{};};return _bfeae (o ,0,traversed );};

// Resolve resolves the reference and returns the indirect or stream object.
// If the reference cannot be resolved, a *PdfObjectNull object is returned.
func (_ggceb *PdfObjectReference )Resolve ()PdfObject {if _ggceb ._aagbc ==nil {return MakeNull ();};_ddade ,_ ,_aeec :=_ggceb ._aagbc .resolveReference (_ggceb );if _aeec !=nil {_fdf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0072\u0065\u0073\u006f\u006cv\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065r\u0065n\u0063\u0065\u003a\u0020\u0025\u0076\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074",_aeec );
return MakeNull ();};if _ddade ==nil {_fdf .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0072\u0065\u0073ol\u0076\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065:\u0020\u006ei\u006c\u0020\u006fb\u006a\u0065\u0063\u0074\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u0061\u0020nu\u006c\u006c\u0020o\u0062\u006a\u0065\u0063\u0074");
return MakeNull ();};return _ddade ;};

// String returns a string describing `stream`.
func (_acde *PdfObjectStream )String ()string {return _ae .Sprintf ("O\u0062j\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0025\u0064: \u0025\u0073",_acde .ObjectNumber ,_acde .PdfObjectDictionary );};func (_eeae *PdfParser )readTextLine ()(string ,error ){var _aagf _fda .Buffer ;
for {_dfcf ,_gcaaf :=_eeae ._bdg .Peek (1);if _gcaaf !=nil {_fdf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_gcaaf .Error ());return _aagf .String (),_gcaaf ;};if (_dfcf [0]!='\r')&&(_dfcf [0]!='\n'){_adgfd ,_ :=_eeae ._bdg .ReadByte ();
_aagf .WriteByte (_adgfd );}else {break ;};};return _aagf .String (),nil ;};

// JBIG2EncoderSettings contains the parameters and settings used by the JBIG2Encoder.
// Current version works only on JB2Generic compression.
type JBIG2EncoderSettings struct{

// FileMode defines if the jbig2 encoder should return full jbig2 file instead of
// shortened pdf mode. This adds the file header to the jbig2 definition.
FileMode bool ;

// Compression is the setting that defines the compression type used for encoding the page.
Compression JBIG2CompressionType ;

// DuplicatedLinesRemoval code generic region in a way such that if the lines are duplicated the encoder
// doesn't store it twice.
DuplicatedLinesRemoval bool ;

// DefaultPixelValue is the bit value initial for every pixel in the page.
DefaultPixelValue uint8 ;

// ResolutionX optional setting that defines the 'x' axis input image resolution - used for single page encoding.
ResolutionX int ;

// ResolutionY optional setting that defines the 'y' axis input image resolution - used for single page encoding.
ResolutionY int ;

// Threshold defines the threshold of the image correlation for
// non Generic compression.
// User only for JB2SymbolCorrelation and JB2SymbolRankHaus methods.
// Best results in range [0.7 - 0.98] - the less the better the compression would be
// but the more lossy.
// Default value: 0.95
Threshold float64 ;};func (_aeeg *PdfParser )inspect ()(map[string ]int ,error ){_fdf .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0053P\u0045\u0043\u0054\u0020\u002d\u002d\u002d\u002d\u002d\u002d-\u002d\u002d\u002d");_fdf .Log .Trace ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");
_cgee :=map[string ]int {};_gbad :=0;_dadc :=0;var _acfda []int ;for _acba :=range _aeeg ._agec .ObjectMap {_acfda =append (_acfda ,_acba );};_c .Ints (_acfda );_cbgea :=0;for _ ,_cdce :=range _acfda {_afce :=_aeeg ._agec .ObjectMap [_cdce ];if _afce .ObjectNumber ==0{continue ;
};_gbad ++;_fdf .Log .Trace ("\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d");_fdf .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0075\u0070\u0020\u006f\u0062\u006a\u0065c\u0074 \u006e\u0075\u006d\u0062\u0065\u0072\u003a \u0025\u0064",_afce .ObjectNumber );
_begba ,_bgfd :=_aeeg .LookupByNumber (_afce .ObjectNumber );if _bgfd !=nil {_fdf .Log .Trace ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u006c\u006f\u006f\u006b\u0075p\u0020\u006f\u0062\u006a\u0020\u0025\u0064 \u0028\u0025\u0073\u0029",_afce .ObjectNumber ,_bgfd );
_dadc ++;continue ;};_fdf .Log .Trace ("\u006fb\u006a\u003a\u0020\u0025\u0073",_begba );_cdfc ,_aefbg :=_begba .(*PdfIndirectObject );if _aefbg {_fdf .Log .Trace ("\u0049N\u0044 \u004f\u004f\u0042\u004a\u0020\u0025\u0064\u003a\u0020\u0025\u0073",_afce .ObjectNumber ,_cdfc );
_eggf ,_bfcfea :=_cdfc .PdfObject .(*PdfObjectDictionary );if _bfcfea {if _bfddg ,_ffab :=_eggf .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_ffab {_fdfgg :=string (*_bfddg );_fdf .Log .Trace ("\u002d\u002d\u002d\u003e\u0020\u004f\u0062\u006a\u0020\u0074\u0079\u0070e\u003a\u0020\u0025\u0073",_fdfgg );
_ ,_adadf :=_cgee [_fdfgg ];if _adadf {_cgee [_fdfgg ]++;}else {_cgee [_fdfgg ]=1;};}else if _gabdb ,_agdg :=_eggf .Get ("\u0053u\u0062\u0074\u0079\u0070\u0065").(*PdfObjectName );_agdg {_agffa :=string (*_gabdb );_fdf .Log .Trace ("-\u002d-\u003e\u0020\u004f\u0062\u006a\u0020\u0073\u0075b\u0074\u0079\u0070\u0065: \u0025\u0073",_agffa );
_ ,_ccfa :=_cgee [_agffa ];if _ccfa {_cgee [_agffa ]++;}else {_cgee [_agffa ]=1;};};if _gccbc ,_ddbfg :=_eggf .Get ("\u0053").(*PdfObjectName );_ddbfg &&*_gccbc =="\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"{_ ,_bggec :=_cgee ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"];
if _bggec {_cgee ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]++;}else {_cgee ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]=1;};};};}else if _fefad ,_fbdgab :=_begba .(*PdfObjectStream );_fbdgab {if _ddbbb ,_cgcd :=_fefad .PdfObjectDictionary .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );
_cgcd {_fdf .Log .Trace ("\u002d\u002d\u003e\u0020\u0053\u0074\u0072\u0065\u0061\u006d\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073",*_ddbbb );_cefa :=string (*_ddbbb );_cgee [_cefa ]++;};}else {_aabf ,_bffdc :=_begba .(*PdfObjectDictionary );
if _bffdc {_aeegd ,_fdegb :=_aabf .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if _fdegb {_deebg :=string (*_aeegd );_fdf .Log .Trace ("\u002d-\u002d \u006f\u0062\u006a\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073",_deebg );_cgee [_deebg ]++;
};};_fdf .Log .Trace ("\u0044\u0049\u0052\u0045\u0043\u0054\u0020\u004f\u0042\u004a\u0020\u0025d\u003a\u0020\u0025\u0073",_afce .ObjectNumber ,_begba );};_cbgea ++;};_fdf .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0045\u004fF\u0020\u0049\u004e\u0053\u0050\u0045\u0043T\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d");
_fdf .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");_fdf .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074 \u0063\u006f\u0075\u006e\u0074\u003a\u0020\u0025\u0064",_gbad );_fdf .Log .Trace ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u006f\u006b\u0075p\u003a\u0020\u0025\u0064",_dadc );
for _dcff ,_gcbc :=range _cgee {_fdf .Log .Trace ("\u0025\u0073\u003a\u0020\u0025\u0064",_dcff ,_gcbc );};_fdf .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");if len (_aeeg ._agec .ObjectMap )< 1{_fdf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0068\u0069\u0073 \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074 \u0069s\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0028\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0021\u0029");
return nil ,_ae .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0064\u006fc\u0075\u006d\u0065\u006e\u0074\u0020\u0028\u0078r\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006d\u0069\u0073s\u0069\u006e\u0067\u0029");};_fceb ,_ebdfc :=_cgee ["\u0046\u006f\u006e\u0074"];
if !_ebdfc ||_fceb < 2{_fdf .Log .Trace ("\u0054\u0068\u0069s \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020i\u0073 \u0070r\u006fb\u0061\u0062\u006c\u0079\u0020\u0073\u0063\u0061\u006e\u006e\u0065\u0064\u0021");}else {_fdf .Log .Trace ("\u0054\u0068\u0069\u0073\u0020\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020\u0069\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0066o\u0072\u0020\u0065\u0078\u0074r\u0061\u0063t\u0069\u006f\u006e\u0021");
};return _cgee ,nil ;};

// ParserMetadata is the parser based metadata information about document.
// The data here could be used on document verification.
type ParserMetadata struct{_gaee int ;_adf bool ;_cacd [4]byte ;_ggf bool ;_adcc bool ;_bbeb bool ;_cgd bool ;_cff bool ;_gcdd bool ;};

// AddEncoder adds the passed in encoder to the underlying encoder slice.
func (_afbe *MultiEncoder )AddEncoder (encoder StreamEncoder ){_afbe ._cbab =append (_afbe ._cbab ,encoder );};

// EncodeBytes encodes the image data using either Group3 or Group4 CCITT facsimile (fax) encoding.
// `data` is expected to be 1 color component, 1 bit per component. It is also valid to provide 8 BPC, 1 CC image like
// a standard go image Gray data.
func (_gcga *CCITTFaxEncoder )EncodeBytes (data []byte )([]byte ,error ){var _eefb _gg .Gray ;switch len (data ){case _gcga .Rows *_gcga .Columns :_aede ,_fcba :=_gg .NewImage (_gcga .Columns ,_gcga .Rows ,8,1,data ,nil ,nil );if _fcba !=nil {return nil ,_fcba ;
};_eefb =_aede .(_gg .Gray );case (_gcga .Columns *_gcga .Rows )+7>>3:_ebbg ,_bgfbf :=_gg .NewImage (_gcga .Columns ,_gcga .Rows ,1,1,data ,nil ,nil );if _bgfbf !=nil {return nil ,_bgfbf ;};_aeba :=_ebbg .(*_gg .Monochrome );if _bgfbf =_aeba .AddPadding ();
_bgfbf !=nil {return nil ,_bgfbf ;};_eefb =_aeba ;default:if len (data )< _gg .BytesPerLine (_gcga .Columns ,1,1)*_gcga .Rows {return nil ,_g .New ("p\u0072\u006f\u0076\u0069\u0064\u0065d\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020i\u006e\u0070\u0075t\u0020d\u0061\u0074\u0061");
};_abce ,_agbb :=_gg .NewImage (_gcga .Columns ,_gcga .Rows ,1,1,data ,nil ,nil );if _agbb !=nil {return nil ,_agbb ;};_fbee :=_abce .(*_gg .Monochrome );_eefb =_fbee ;};_cfeb :=make ([][]byte ,_gcga .Rows );for _fgd :=0;_fgd < _gcga .Rows ;_fgd ++{_bcc :=make ([]byte ,_gcga .Columns );
for _gac :=0;_gac < _gcga .Columns ;_gac ++{_fded :=_eefb .GrayAt (_gac ,_fgd );_bcc [_gac ]=_fded .Y >>7;};_cfeb [_fgd ]=_bcc ;};_cdb :=&_bbe .Encoder {K :_gcga .K ,Columns :_gcga .Columns ,EndOfLine :_gcga .EndOfLine ,EndOfBlock :_gcga .EndOfBlock ,BlackIs1 :_gcga .BlackIs1 ,DamagedRowsBeforeError :_gcga .DamagedRowsBeforeError ,Rows :_gcga .Rows ,EncodedByteAlign :_gcga .EncodedByteAlign };
return _cdb .Encode (_cfeb ),nil ;};func (_df *PdfParser )lookupByNumberWrapper (_ede int ,_efg bool )(PdfObject ,bool ,error ){_acd ,_acc ,_da :=_df .lookupByNumber (_ede ,_efg );if _da !=nil {return nil ,_acc ,_da ;};if !_acc &&_df ._efcc !=nil &&_df ._efcc ._edc &&!_df ._efcc .isDecrypted (_acd ){_caa :=_df ._efcc .Decrypt (_acd ,0,0);
if _caa !=nil {return nil ,_acc ,_caa ;};};return _acd ,_acc ,nil ;};func (_aggf *PdfParser )loadXrefs ()(*PdfObjectDictionary ,error ){_aggf ._agec .ObjectMap =make (map[int ]XrefObject );_aggf ._gfgfd =make (objectStreams );_eadc ,_dafa :=_aggf ._dddg .Seek (0,_ef .SeekEnd );
if _dafa !=nil {return nil ,_dafa ;};_fdf .Log .Trace ("\u0066s\u0069\u007a\u0065\u003a\u0020\u0025d",_eadc );_aggf ._eaade =_eadc ;_dafa =_aggf .seekToEOFMarker (_eadc );if _dafa !=nil {_fdf .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0073\u0065\u0065\u006b\u0020\u0074\u006f\u0020\u0065\u006f\u0066\u0020\u006d\u0061\u0072\u006b\u0065\u0072: \u0025\u0076",_dafa );
return nil ,_dafa ;};_abdf ,_dafa :=_aggf ._dddg .Seek (0,_ef .SeekCurrent );if _dafa !=nil {return nil ,_dafa ;};var _fcaa int64 =64;_faae :=_abdf -_fcaa ;if _faae < 0{_faae =0;};_ ,_dafa =_aggf ._dddg .Seek (_faae ,_ef .SeekStart );if _dafa !=nil {return nil ,_dafa ;
};_cdeba :=make ([]byte ,_fcaa );_ ,_dafa =_aggf ._dddg .Read (_cdeba );if _dafa !=nil {_fdf .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u003a\u0020\u0025\u0076",_dafa );
return nil ,_dafa ;};_cffb :=_fdbe .FindStringSubmatch (string (_cdeba ));if len (_cffb )< 2{_fdf .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020n\u006f\u0074\u0020f\u006fu\u006e\u0064\u0021");
return nil ,_g .New ("\u0073\u0074\u0061\u0072tx\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};if len (_cffb )> 2{_fdf .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u004du\u006c\u0074\u0069\u0070\u006c\u0065\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029\u0021",_cdeba );
return nil ,_g .New ("m\u0075\u006c\u0074\u0069\u0070\u006ce\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065f\u0020\u0065\u006et\u0072i\u0065\u0073\u003f");};_dbec ,_ :=_bb .ParseInt (_cffb [1],10,64);_fdf .Log .Trace ("\u0073t\u0061r\u0074\u0078\u0072\u0065\u0066\u0020\u0061\u0074\u0020\u0025\u0064",_dbec );
if _dbec > _eadc {_fdf .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u006f\u0066f\u0073e\u0074 \u006fu\u0074\u0073\u0069\u0064\u0065\u0020\u006f\u0066\u0020\u0066\u0069\u006c\u0065");_fdf .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0072e\u0070\u0061\u0069\u0072");
_dbec ,_dafa =_aggf .repairLocateXref ();if _dafa !=nil {_fdf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0052\u0065\u0070\u0061\u0069\u0072\u0020\u0061\u0074\u0074\u0065\u006d\u0070t\u0020\u0066\u0061\u0069\u006c\u0065\u0064 \u0028\u0025\u0073\u0029");
return nil ,_dafa ;};};_aggf ._dddg .Seek (_dbec ,_ef .SeekStart );_aggf ._bdg =_faf .NewReader (_aggf ._dddg );_aagfa ,_dafa :=_aggf .parseXref ();if _dafa !=nil {return nil ,_dafa ;};_bbcff :=_aagfa .Get ("\u0058R\u0065\u0066\u0053\u0074\u006d");if _bbcff !=nil {_ffec ,_fdaae :=_bbcff .(*PdfObjectInteger );
if !_fdaae {return nil ,_g .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0021=\u0020\u0069\u006e\u0074");};_ ,_dafa =_aggf .parseXrefStream (_ffec );if _dafa !=nil {return nil ,_dafa ;};};var _fabe []int64 ;_dafd :=func (_aebc int64 ,_bddc []int64 )bool {for _ ,_fdaag :=range _bddc {if _fdaag ==_aebc {return true ;
};};return false ;};_bbcff =_aagfa .Get ("\u0050\u0072\u0065\u0076");for _bbcff !=nil {_cbcc ,_dabec :=_bbcff .(*PdfObjectInteger );if !_dabec {_fdf .Log .Debug ("\u0049\u006ev\u0061\u006c\u0069\u0064\u0020P\u0072\u0065\u0076\u0020\u0072e\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u003a\u0020\u004e\u006f\u0074\u0020\u0061\u0020\u002a\u0050\u0064\u0066\u004f\u0062\u006a\u0065\u0063\u0074\u0049\u006e\u0074\u0065\u0067\u0065\u0072\u0020\u0028\u0025\u0054\u0029",_bbcff );
return _aagfa ,nil ;};_gage :=*_cbcc ;_fdf .Log .Trace ("\u0041\u006eot\u0068\u0065\u0072 \u0050\u0072\u0065\u0076 xr\u0065f \u0074\u0061\u0062\u006c\u0065\u0020\u006fbj\u0065\u0063\u0074\u0020\u0061\u0074\u0020%\u0064",_gage );_aggf ._dddg .Seek (int64 (_gage ),_ef .SeekStart );
_aggf ._bdg =_faf .NewReader (_aggf ._dddg );_befc ,_dcceb :=_aggf .parseXref ();if _dcceb !=nil {_fdf .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0045\u0072\u0072\u006f\u0072\u0020-\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u0061\u0064\u0069n\u0067\u0020\u0061\u006e\u006f\u0074\u0068\u0065\u0072\u0020\u0028\u0050re\u0076\u0029\u0020\u0074\u0072\u0061\u0069\u006c\u0065\u0072");
_fdf .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0063\u006f\u006e\u0074\u0069n\u0075\u0065\u0020\u0062\u0079\u0020\u0069\u0067\u006e\u006f\u0072\u0069n\u0067\u0020\u0069\u0074");break ;};_aggf ._accg =append (_aggf ._accg ,int64 (_gage ));
_bbcff =_befc .Get ("\u0050\u0072\u0065\u0076");if _bbcff !=nil {_ddafa :=*(_bbcff .(*PdfObjectInteger ));if _dafd (int64 (_ddafa ),_fabe ){_fdf .Log .Debug ("\u0050\u0072ev\u0065\u006e\u0074i\u006e\u0067\u0020\u0063irc\u0075la\u0072\u0020\u0078\u0072\u0065\u0066\u0020re\u0066\u0065\u0072\u0065\u006e\u0063\u0069n\u0067");
break ;};_fabe =append (_fabe ,int64 (_ddafa ));};};return _aagfa ,nil ;};func _bgeeb (_afcc *PdfObjectStream ,_adde *PdfObjectDictionary )(*LZWEncoder ,error ){_ddcd :=NewLZWEncoder ();_eagd :=_afcc .PdfObjectDictionary ;if _eagd ==nil {return _ddcd ,nil ;
};if _adde ==nil {_ceae :=TraceToDirectObject (_eagd .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));if _ceae !=nil {if _feea ,_afbd :=_ceae .(*PdfObjectDictionary );_afbd {_adde =_feea ;}else if _geac ,_daaa :=_ceae .(*PdfObjectArray );
_daaa {if _geac .Len ()==1{if _fcd ,_aded :=GetDict (_geac .Get (0));_aded {_adde =_fcd ;};};};if _adde ==nil {_fdf .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_ceae );
return nil ,_ae .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};};_agff :=_eagd .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");if _agff !=nil {_edee ,_ddce :=_agff .(*PdfObjectInteger );
if !_ddce {_fdf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a \u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065d\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u006e\u0075\u006d\u0065\u0072i\u0063 \u0028\u0025\u0054\u0029",_agff );
return nil ,_ae .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");};if *_edee !=0&&*_edee !=1{return nil ,_ae .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0076\u0061\u006c\u0075e\u0020\u0028\u006e\u006f\u0074 \u0030\u0020o\u0072\u0020\u0031\u0029");
};_ddcd .EarlyChange =int (*_edee );}else {_ddcd .EarlyChange =1;};if _adde ==nil {return _ddcd ,nil ;};if _aff ,_ceab :=GetIntVal (_adde .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065"));_ceab {if _aff ==0||_aff ==1{_ddcd .EarlyChange =_aff ;
}else {_fdf .Log .Debug ("W\u0041\u0052\u004e\u003a\u0020\u0069n\u0076\u0061\u006c\u0069\u0064\u0020E\u0061\u0072\u006c\u0079\u0043\u0068\u0061n\u0067\u0065\u0020\u0076\u0061\u006c\u0075\u0065\u003a\u0020%\u0064",_aff );};};_agff =_adde .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");
if _agff !=nil {_gag ,_cfbe :=_agff .(*PdfObjectInteger );if !_cfbe {_fdf .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_agff );
return nil ,_ae .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_ddcd .Predictor =int (*_gag );};_agff =_adde .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");
if _agff !=nil {_gade ,_eeag :=_agff .(*PdfObjectInteger );if !_eeag {_fdf .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");
return nil ,_ae .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_ddcd .BitsPerComponent =int (*_gade );};if _ddcd .Predictor > 1{_ddcd .Columns =1;_agff =_adde .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");
if _agff !=nil {_dabf ,_adca :=_agff .(*PdfObjectInteger );if !_adca {return nil ,_ae .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_ddcd .Columns =int (*_dabf );
};_ddcd .Colors =1;_agff =_adde .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _agff !=nil {_bed ,_bbfe :=_agff .(*PdfObjectInteger );if !_bbfe {return nil ,_ae .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");
};_ddcd .Colors =int (*_bed );};};_fdf .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_adde .String ());return _ddcd ,nil ;};

// GetUpdatedObjects returns pdf objects which were updated from the specific version (from prevParser).
func (_caeff *PdfParser )GetUpdatedObjects (prevParser *PdfParser )(map[int64 ]PdfObject ,error ){if prevParser ==nil {return nil ,_g .New ("\u0070\u0072e\u0076\u0069\u006f\u0075\u0073\u0020\u0070\u0061\u0072\u0073\u0065\u0072\u0020\u0063\u0061\u006e\u0027\u0074\u0020\u0062\u0065\u0020nu\u006c\u006c");
};_afcg ,_ccdb :=_caeff .getNumbersOfUpdatedObjects (prevParser );if _ccdb !=nil {return nil ,_ccdb ;};_cebfb :=make (map[int64 ]PdfObject );for _ ,_ecfac :=range _afcg {if _cacb ,_dffdg :=_caeff .LookupByNumber (_ecfac );_dffdg ==nil {_cebfb [int64 (_ecfac )]=_cacb ;
}else {return nil ,_dffdg ;};};return _cebfb ,nil ;};

// IsOctalDigit checks if a character can be part of an octal digit string.
func IsOctalDigit (c byte )bool {return '0'<=c &&c <='7'};

// EqualObjects returns true if `obj1` and `obj2` have the same contents.
//
// NOTE: It is a good idea to flatten obj1 and obj2 with FlattenObject before calling this function
// so that contents, rather than references, can be compared.
func EqualObjects (obj1 ,obj2 PdfObject )bool {return _dbad (obj1 ,obj2 ,0)};

// ToInt64Slice returns a slice of all array elements as an int64 slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_gecd *PdfObjectArray )ToInt64Slice ()([]int64 ,error ){var _cadf []int64 ;for _ ,_cege :=range _gecd .Elements (){if _afff ,_cfeec :=_cege .(*PdfObjectInteger );_cfeec {_cadf =append (_cadf ,int64 (*_afff ));}else {return nil ,ErrTypeError ;};};
return _cadf ,nil ;};

// HasInvalidHexRunes implements core.ParserMetadata interface.
func (_acgd ParserMetadata )HasInvalidHexRunes ()bool {return _acgd ._bbeb };func _bee (_agag *PdfObjectStream ,_ddbb *PdfObjectDictionary )(*RunLengthEncoder ,error ){return NewRunLengthEncoder (),nil ;};

// Validate validates the page settings for the JBIG2 encoder.
func (_dacg JBIG2EncoderSettings )Validate ()error {const _cfcg ="\u0076a\u006ci\u0064\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065\u0072";if _dacg .Threshold < 0||_dacg .Threshold > 1.0{return _cd .Errorf (_cfcg ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074\u0068\u0072\u0065\u0073\u0068\u006f\u006c\u0064\u0020\u0076a\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0076\u0027 \u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0069\u006e\u0020\u0072\u0061n\u0067\u0065\u0020\u005b\u0030\u002e0\u002c\u0020\u0031.\u0030\u005d",_dacg .Threshold );
};if _dacg .ResolutionX < 0{return _cd .Errorf (_cfcg ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0078\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_dacg .ResolutionX );
};if _dacg .ResolutionY < 0{return _cd .Errorf (_cfcg ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0079\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_dacg .ResolutionY );
};if _dacg .DefaultPixelValue !=0&&_dacg .DefaultPixelValue !=1{return _cd .Errorf (_cfcg ,"de\u0066\u0061u\u006c\u0074\u0020\u0070\u0069\u0078\u0065\u006c\u0020v\u0061\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0066o\u0072 \u0074\u0068\u0065\u0020\u0062\u0069\u0074\u003a \u007b0\u002c\u0031}",_dacg .DefaultPixelValue );
};if _dacg .Compression !=JB2Generic {return _cd .Errorf (_cfcg ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065d\u0020\u0063\u006fm\u0070\u0072\u0065\u0073s\u0069\u006f\u006e\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
};return nil ;};const _egf ="\u0053\u0074\u0064C\u0046";

// WriteString outputs the object as it is to be written to file.
func (_cebbg *PdfObjectStreams )WriteString ()string {var _fggf _gc .Builder ;_fggf .WriteString (_bb .FormatInt (_cebbg .ObjectNumber ,10));_fggf .WriteString ("\u0020\u0030\u0020\u0052");return _fggf .String ();};

// Remove removes an element specified by key.
func (_daac *PdfObjectDictionary )Remove (key PdfObjectName ){_fgbd :=-1;for _cdbc ,_beeb :=range _daac ._fgag {if _beeb ==key {_fgbd =_cdbc ;break ;};};if _fgbd >=0{_daac ._fgag =append (_daac ._fgag [:_fgbd ],_daac ._fgag [_fgbd +1:]...);delete (_daac ._acfc ,key );
};};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_bggc *LZWEncoder )MakeDecodeParams ()PdfObject {if _bggc .Predictor > 1{_effb :=MakeDict ();_effb .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_bggc .Predictor )));if _bggc .BitsPerComponent !=8{_effb .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_bggc .BitsPerComponent )));
};if _bggc .Columns !=1{_effb .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_bggc .Columns )));};if _bggc .Colors !=1{_effb .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_bggc .Colors )));};return _effb ;};return nil ;
};func (_cda *PdfParser )lookupObjectViaOS (_ed int ,_ab int )(PdfObject ,error ){var _gfb *_fda .Reader ;var _eeg objectStream ;var _gea bool ;_eeg ,_gea =_cda ._gfgfd [_ed ];if !_gea {_gdd ,_eegb :=_cda .LookupByNumber (_ed );if _eegb !=nil {_fdf .Log .Debug ("\u004d\u0069ss\u0069\u006e\u0067 \u006f\u0062\u006a\u0065ct \u0073tr\u0065\u0061\u006d\u0020\u0077\u0069\u0074h \u006e\u0075\u006d\u0062\u0065\u0072\u0020%\u0064",_ed );
return nil ,_eegb ;};_ag ,_cac :=_gdd .(*PdfObjectStream );if !_cac {return nil ,_g .New ("i\u006e\u0076\u0061\u006cid\u0020o\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d");};if _cda ._efcc !=nil &&!_cda ._efcc .isDecrypted (_ag ){return nil ,_g .New ("\u006e\u0065\u0065\u0064\u0020\u0074\u006f\u0020\u0064\u0065\u0063r\u0079\u0070\u0074\u0020\u0074\u0068\u0065\u0020\u0073\u0074r\u0065\u0061\u006d");
};_eb :=_ag .PdfObjectDictionary ;_fdf .Log .Trace ("\u0073o\u0020\u0064\u003a\u0020\u0025\u0073\n",_eb .String ());_fe ,_cac :=_eb .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if !_cac {_fdf .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0061\u006c\u0077\u0061\u0079\u0073\u0020\u0068\u0061\u0076\u0065\u0020\u0061\u0020\u0054\u0079\u0070\u0065");
return nil ,_g .New ("\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020T\u0079\u0070\u0065");};if _gc .ToLower (string (*_fe ))!="\u006f\u0062\u006a\u0073\u0074\u006d"{_fdf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0074\u0079\u0070\u0065\u0020s\u0068\u0061\u006c\u006c\u0020\u0061\u006c\u0077\u0061\u0079\u0073 \u0062\u0065\u0020\u004f\u0062\u006a\u0053\u0074\u006d\u0020\u0021");
return nil ,_g .New ("\u006f\u0062\u006a\u0065c\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0074y\u0070e\u0020\u0021\u003d\u0020\u004f\u0062\u006aS\u0074\u006d");};N ,_cac :=_eb .Get ("\u004e").(*PdfObjectInteger );if !_cac {return nil ,_g .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u004e\u0020i\u006e\u0020\u0073\u0074\u0072\u0065\u0061m\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");
};_bbf ,_cac :=_eb .Get ("\u0046\u0069\u0072s\u0074").(*PdfObjectInteger );if !_cac {return nil ,_g .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0046\u0069\u0072\u0073\u0074\u0020i\u006e \u0073t\u0072e\u0061\u006d\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");
};_fdf .Log .Trace ("\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0073\u0020\u006eu\u006d\u0062\u0065\u0072\u0020\u006f\u0066 \u006f\u0062\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_fe ,*N );_gfe ,_eegb :=DecodeStream (_ag );if _eegb !=nil {return nil ,_eegb ;
};_fdf .Log .Trace ("D\u0065\u0063\u006f\u0064\u0065\u0064\u003a\u0020\u0025\u0073",_gfe );_efa :=_cda .GetFileOffset ();defer func (){_cda .SetFileOffset (_efa )}();_gfb =_fda .NewReader (_gfe );_cda ._bdg =_faf .NewReader (_gfb );_fdf .Log .Trace ("\u0050a\u0072s\u0069\u006e\u0067\u0020\u006ff\u0066\u0073e\u0074\u0020\u006d\u0061\u0070");
_agf :=map[int ]int64 {};for _cc :=0;_cc < int (*N );_cc ++{_cda .skipSpaces ();_fdg ,_dc :=_cda .parseNumber ();if _dc !=nil {return nil ,_dc ;};_aef ,_ggc :=_fdg .(*PdfObjectInteger );if !_ggc {return nil ,_g .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");
};_cda .skipSpaces ();_fdg ,_dc =_cda .parseNumber ();if _dc !=nil {return nil ,_dc ;};_ffb ,_ggc :=_fdg .(*PdfObjectInteger );if !_ggc {return nil ,_g .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");
};_fdf .Log .Trace ("\u006f\u0062j\u0020\u0025\u0064 \u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0025\u0064",*_aef ,*_ffb );_agf [int (*_aef )]=int64 (*_bbf +*_ffb );};_eeg =objectStream {N :int (*N ),_ace :_gfe ,_ee :_agf };_cda ._gfgfd [_ed ]=_eeg ;}else {_caf :=_cda .GetFileOffset ();
defer func (){_cda .SetFileOffset (_caf )}();_gfb =_fda .NewReader (_eeg ._ace );_cda ._bdg =_faf .NewReader (_gfb );};_cf :=_eeg ._ee [_ab ];_fdf .Log .Trace ("\u0041\u0043\u0054\u0055AL\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u005b\u0025\u0064\u005d\u0020\u003d\u0020%\u0064",_ab ,_cf );
_gfb .Seek (_cf ,_ef .SeekStart );_cda ._bdg =_faf .NewReader (_gfb );_gff ,_ :=_cda ._bdg .Peek (100);_fdf .Log .Trace ("\u004f\u0042\u004a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_gff ));_aa ,_acea :=_cda .parseObject ();
if _acea !=nil {_fdf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c \u0074\u006f\u0020\u0072\u0065\u0061\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_acea );return nil ,_acea ;};if _aa ==nil {return nil ,_g .New ("o\u0062\u006a\u0065\u0063t \u0063a\u006e\u006e\u006f\u0074\u0020b\u0065\u0020\u006e\u0075\u006c\u006c");
};_ad :=PdfIndirectObject {};_ad .ObjectNumber =int64 (_ab );_ad .PdfObject =_aa ;_ad ._aagbc =_cda ;return &_ad ,nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_dgdb *FlateEncoder )UpdateParams (params *PdfObjectDictionary ){_dff ,_bgee :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _bgee ==nil {_dgdb .Predictor =int (_dff );};_gbgaf ,_bgee :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));
if _bgee ==nil {_dgdb .BitsPerComponent =int (_gbgaf );};_dbgb ,_bgee :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _bgee ==nil {_dgdb .Columns =int (_dbgb );};_ebcg ,_bgee :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));
if _bgee ==nil {_dgdb .Colors =int (_ebcg );};};

// Version represents a version of a PDF standard.
type Version struct{Major int ;Minor int ;};

// GetFloatVal returns the float64 value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetFloatVal (obj PdfObject )(_ffdf float64 ,_gdbgd bool ){_acfb ,_gdbgd :=TraceToDirectObject (obj ).(*PdfObjectFloat );if _gdbgd {return float64 (*_acfb ),true ;};return 0,false ;};

// GetObjectStreams returns the *PdfObjectStreams represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetObjectStreams (obj PdfObject )(_aabd *PdfObjectStreams ,_bbdaa bool ){_aabd ,_bbdaa =obj .(*PdfObjectStreams );return _aabd ,_bbdaa ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set.  Some other parameters are generated elsewhere.
func (_gggb *DCTEncoder )MakeStreamDict ()*PdfObjectDictionary {_bbfc :=MakeDict ();_bbfc .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_gggb .GetFilterName ()));return _bbfc ;};func (_fdbc *PdfParser )parseObject ()(PdfObject ,error ){_fdf .Log .Trace ("\u0052e\u0061d\u0020\u0064\u0069\u0072\u0065c\u0074\u0020o\u0062\u006a\u0065\u0063\u0074");
_fdbc .skipSpaces ();for {_cfcae ,_bebg :=_fdbc ._bdg .Peek (2);if _bebg !=nil {if _bebg !=_ef .EOF ||len (_cfcae )==0{return nil ,_bebg ;};if len (_cfcae )==1{_cfcae =append (_cfcae ,' ');};};_fdf .Log .Trace ("\u0050e\u0065k\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u003a\u0020\u0025\u0073",string (_cfcae ));
if _cfcae [0]=='/'{_edcg ,_fcbgc :=_fdbc .parseName ();_fdf .Log .Trace ("\u002d\u003e\u004ea\u006d\u0065\u003a\u0020\u0027\u0025\u0073\u0027",_edcg );return &_edcg ,_fcbgc ;}else if _cfcae [0]=='('{_fdf .Log .Trace ("\u002d>\u0053\u0074\u0072\u0069\u006e\u0067!");
_egfcb ,_beef :=_fdbc .parseString ();return _egfcb ,_beef ;}else if _cfcae [0]=='['{_fdf .Log .Trace ("\u002d\u003e\u0041\u0072\u0072\u0061\u0079\u0021");_dffdc ,_gabbe :=_fdbc .parseArray ();return _dffdc ,_gabbe ;}else if (_cfcae [0]=='<')&&(_cfcae [1]=='<'){_fdf .Log .Trace ("\u002d>\u0044\u0069\u0063\u0074\u0021");
_gbd ,_fdac :=_fdbc .ParseDict ();return _gbd ,_fdac ;}else if _cfcae [0]=='<'{_fdf .Log .Trace ("\u002d\u003e\u0048\u0065\u0078\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0021");_eega ,_gabe :=_fdbc .parseHexString ();return _eega ,_gabe ;}else if _cfcae [0]=='%'{_fdbc .readComment ();
_fdbc .skipSpaces ();}else {_fdf .Log .Trace ("\u002d\u003eN\u0075\u006d\u0062e\u0072\u0020\u006f\u0072\u0020\u0072\u0065\u0066\u003f");_cfcae ,_ =_fdbc ._bdg .Peek (15);_edab :=string (_cfcae );_fdf .Log .Trace ("\u0050\u0065\u0065k\u0020\u0073\u0074\u0072\u003a\u0020\u0025\u0073",_edab );
if (len (_edab )> 3)&&(_edab [:4]=="\u006e\u0075\u006c\u006c"){_geddb ,_dcgf :=_fdbc .parseNull ();return &_geddb ,_dcgf ;}else if (len (_edab )> 4)&&(_edab [:5]=="\u0066\u0061\u006cs\u0065"){_bedbd ,_feba :=_fdbc .parseBool ();return &_bedbd ,_feba ;}else if (len (_edab )> 3)&&(_edab [:4]=="\u0074\u0072\u0075\u0065"){_fdbce ,_gbgd :=_fdbc .parseBool ();
return &_fdbce ,_gbgd ;};_afef :=_bagb .FindStringSubmatch (_edab );if len (_afef )> 1{_cfcae ,_ =_fdbc ._bdg .ReadBytes ('R');_fdf .Log .Trace ("\u002d\u003e\u0020\u0021\u0052\u0065\u0066\u003a\u0020\u0027\u0025\u0073\u0027",string (_cfcae [:]));_gffg ,_efga :=_agadc (string (_cfcae ));
_gffg ._aagbc =_fdbc ;return &_gffg ,_efga ;};_gbca :=_dgafe .FindStringSubmatch (_edab );if len (_gbca )> 1{_fdf .Log .Trace ("\u002d\u003e\u0020\u004e\u0075\u006d\u0062\u0065\u0072\u0021");_beg ,_fgce :=_fdbc .parseNumber ();return _beg ,_fgce ;};_gbca =_faca .FindStringSubmatch (_edab );
if len (_gbca )> 1{_fdf .Log .Trace ("\u002d\u003e\u0020\u0045xp\u006f\u006e\u0065\u006e\u0074\u0069\u0061\u006c\u0020\u004e\u0075\u006d\u0062\u0065r\u0021");_fdf .Log .Trace ("\u0025\u0020\u0073",_gbca );_gdgge ,_afeg :=_fdbc .parseNumber ();return _gdgge ,_afeg ;
};_fdf .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020U\u006e\u006b\u006e\u006f\u0077n\u0020(\u0070e\u0065\u006b\u0020\u0022\u0025\u0073\u0022)",_edab );return nil ,_g .New ("\u006f\u0062\u006a\u0065\u0063t\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020\u0075\u006e\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e");
};};};

// DecodeBytes decodes a slice of DCT encoded bytes and returns the result.
func (_age *DCTEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_efgf :=_fda .NewReader (encoded );_egfe ,_faa :=_de .Decode (_efgf );if _faa !=nil {_fdf .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006eg\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_faa );
return nil ,_faa ;};_cdd :=_egfe .Bounds ();var _aebff =make ([]byte ,_cdd .Dx ()*_cdd .Dy ()*_age .ColorComponents *_age .BitsPerComponent /8);_dedc :=0;for _dafg :=_cdd .Min .Y ;_dafg < _cdd .Max .Y ;_dafg ++{for _dadf :=_cdd .Min .X ;_dadf < _cdd .Max .X ;
_dadf ++{_efed :=_egfe .At (_dadf ,_dafg );if _age .ColorComponents ==1{if _age .BitsPerComponent ==16{_fegbb ,_cfba :=_efed .(_gf .Gray16 );if !_cfba {return nil ,_g .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_aebff [_dedc ]=byte ((_fegbb .Y >>8)&0xff);_dedc ++;_aebff [_dedc ]=byte (_fegbb .Y &0xff);_dedc ++;}else {_gcf ,_bedbc :=_efed .(_gf .Gray );if !_bedbc {return nil ,_g .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_aebff [_dedc ]=_gcf .Y &0xff;_dedc ++;};}else if _age .ColorComponents ==3{if _age .BitsPerComponent ==16{_fafbb ,_agcc :=_efed .(_gf .RGBA64 );if !_agcc {return nil ,_g .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");
};_aebff [_dedc ]=byte ((_fafbb .R >>8)&0xff);_dedc ++;_aebff [_dedc ]=byte (_fafbb .R &0xff);_dedc ++;_aebff [_dedc ]=byte ((_fafbb .G >>8)&0xff);_dedc ++;_aebff [_dedc ]=byte (_fafbb .G &0xff);_dedc ++;_aebff [_dedc ]=byte ((_fafbb .B >>8)&0xff);_dedc ++;
_aebff [_dedc ]=byte (_fafbb .B &0xff);_dedc ++;}else {_cgc ,_gcaa :=_efed .(_gf .RGBA );if _gcaa {_aebff [_dedc ]=_cgc .R &0xff;_dedc ++;_aebff [_dedc ]=_cgc .G &0xff;_dedc ++;_aebff [_dedc ]=_cgc .B &0xff;_dedc ++;}else {_eedb ,_fcf :=_efed .(_gf .YCbCr );
if !_fcf {return nil ,_g .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_fbgg ,_bfce ,_abea ,_ :=_eedb .RGBA ();_aebff [_dedc ]=byte (_fbgg >>8);_dedc ++;_aebff [_dedc ]=byte (_bfce >>8);_dedc ++;_aebff [_dedc ]=byte (_abea >>8);
_dedc ++;};};}else if _age .ColorComponents ==4{_ecg ,_ceac :=_efed .(_gf .CMYK );if !_ceac {return nil ,_g .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_aebff [_dedc ]=255-_ecg .C &0xff;_dedc ++;_aebff [_dedc ]=255-_ecg .M &0xff;
_dedc ++;_aebff [_dedc ]=255-_ecg .Y &0xff;_dedc ++;_aebff [_dedc ]=255-_ecg .K &0xff;_dedc ++;};};};return _aebff ,nil ;};

// Decoded returns the PDFDocEncoding or UTF-16BE decoded string contents.
// UTF-16BE is applied when the first two bytes are 0xFE, 0XFF, otherwise decoding of
// PDFDocEncoding is performed.
func (_ebgb *PdfObjectString )Decoded ()string {if _ebgb ==nil {return "";};_geef :=[]byte (_ebgb ._fea );if len (_geef )>=2&&_geef [0]==0xFE&&_geef [1]==0xFF{return _dd .UTF16ToString (_geef [2:]);};return _dd .PDFDocEncodingToString (_geef );};

// GetNameVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetNameVal (obj PdfObject )(_bdfg string ,_fcbga bool ){_eaeb ,_fcbga :=TraceToDirectObject (obj ).(*PdfObjectName );if _fcbga {return string (*_eaeb ),true ;};return ;};

// HasNonConformantStream implements core.ParserMetadata.
func (_dcfb ParserMetadata )HasNonConformantStream ()bool {return _dcfb ._cgd };

// ReadBytesAt reads byte content at specific offset and length within the PDF.
func (_dbfa *PdfParser )ReadBytesAt (offset ,len int64 )([]byte ,error ){_agfd :=_dbfa .GetFileOffset ();_ ,_eecc :=_dbfa ._dddg .Seek (offset ,_ef .SeekStart );if _eecc !=nil {return nil ,_eecc ;};_ggee :=make ([]byte ,len );_ ,_eecc =_ef .ReadAtLeast (_dbfa ._dddg ,_ggee ,int (len ));
if _eecc !=nil {return nil ,_eecc ;};_dbfa .SetFileOffset (_agfd );return _ggee ,nil ;};func (_feceb *PdfParser )parseXref ()(*PdfObjectDictionary ,error ){const _acegf =20;_dfgg ,_ :=_feceb ._bdg .Peek (_acegf );for _eacf :=0;_eacf < 2;_eacf ++{if _feceb ._aagdd ==0{_feceb ._aagdd =_feceb .GetFileOffset ();
};if _agda .Match (_dfgg ){_fdf .Log .Trace ("\u0078\u0072e\u0066\u0020\u0070\u006f\u0069\u006e\u0074\u0073\u0020\u0074\u006f\u0020\u0061\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u002e\u0020\u0050\u0072\u006f\u0062\u0061\u0062\u006c\u0079\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063\u0074");
_fdf .Log .Debug ("\u0073t\u0061r\u0074\u0069\u006e\u0067\u0020w\u0069\u0074h\u0020\u0022\u0025\u0073\u0022",string (_dfgg ));return _feceb .parseXrefStream (nil );};if _ggec .Match (_dfgg ){_fdf .Log .Trace ("\u0053\u0074\u0061\u006ed\u0061\u0072\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073e\u0063t\u0069\u006f\u006e\u0020\u0074\u0061\u0062l\u0065\u0021");
return _feceb .parseXrefTable ();};_dfgfc :=_feceb .GetFileOffset ();if _feceb ._aagdd ==0{_feceb ._aagdd =_dfgfc ;};_feceb .SetFileOffset (_dfgfc -_acegf );defer _feceb .SetFileOffset (_dfgfc );_bagge ,_ :=_feceb ._bdg .Peek (_acegf );_dfgg =append (_bagge ,_dfgg ...);
};_fdf .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u0078\u0072\u0065f\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006fr\u0020\u0073\u0074\u0072\u0065\u0061\u006d.\u0020\u0052\u0065\u0070\u0061i\u0072\u0020\u0061\u0074\u0074e\u006d\u0070\u0074\u0065\u0064\u003a\u0020\u004c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0065\u0061\u0072\u006c\u0069\u0065\u0073\u0074\u0020x\u0072\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u0062\u006f\u0074to\u006d\u002e");
if _gcgag :=_feceb .repairSeekXrefMarker ();_gcgag !=nil {_fdf .Log .Debug ("\u0052e\u0070a\u0069\u0072\u0020\u0066\u0061i\u006c\u0065d\u0020\u002d\u0020\u0025\u0076",_gcgag );return nil ,_gcgag ;};return _feceb .parseXrefTable ();};

// GetIntVal returns the int value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetIntVal (obj PdfObject )(_bcfg int ,_eeef bool ){_abbac ,_eeef :=TraceToDirectObject (obj ).(*PdfObjectInteger );if _eeef &&_abbac !=nil {return int (*_abbac ),true ;};return 0,false ;};

// NewCompliancePdfParser creates a new PdfParser that will parse input reader with the focus on extracting more metadata, which
// might affect performance of the regular PdfParser this function.
func NewCompliancePdfParser (rs _ef .ReadSeeker )(_dce *PdfParser ,_fdcb error ){_dce =&PdfParser {_dddg :rs ,ObjCache :make (objectCache ),_fbed :map[int64 ]bool {},_geca :true ,_fcfb :make (map[*PdfParser ]*PdfParser )};if _fdcb =_dce .parseDetailedHeader ();
_fdcb !=nil {return nil ,_fdcb ;};if _dce ._gaad ,_fdcb =_dce .loadXrefs ();_fdcb !=nil {_fdf .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020F\u0061\u0069\u006c\u0065d t\u006f l\u006f\u0061\u0064\u0020\u0078\u0072\u0065f \u0074\u0061\u0062\u006c\u0065\u0021\u0020%\u0073",_fdcb );
return nil ,_fdcb ;};_fdf .Log .Trace ("T\u0072\u0061\u0069\u006c\u0065\u0072\u003a\u0020\u0025\u0073",_dce ._gaad );if len (_dce ._agec .ObjectMap )==0{return nil ,_ae .Errorf ("\u0065\u006d\u0070\u0074\u0079\u0020\u0058\u0052\u0045\u0046\u0020t\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0049\u006e\u0076a\u006c\u0069\u0064");
};return _dce ,nil ;};

// RawEncoder implements Raw encoder/decoder (no encoding, pass through)
type RawEncoder struct{};

// JBIG2CompressionType defines the enum compression type used by the JBIG2Encoder.
type JBIG2CompressionType int ;

// DecodeStream decodes the stream containing CCITTFax encoded image data.
func (_fedc *CCITTFaxEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _fedc .DecodeBytes (streamObj .Stream );};

// XrefObject defines a cross reference entry which is a map between object number (with generation number) and the
// location of the actual object, either as a file offset (xref table entry), or as a location within an xref
// stream object (xref object stream).
type XrefObject struct{XType xrefType ;ObjectNumber int ;Generation int ;

// For normal xrefs (defined by OFFSET)
Offset int64 ;

// For xrefs to object streams.
OsObjNumber int ;OsObjIndex int ;};

// String returns a string describing `ref`.
func (_dcbc *PdfObjectReference )String ()string {return _ae .Sprintf ("\u0052\u0065\u0066\u0028\u0025\u0064\u0020\u0025\u0064\u0029",_dcbc .ObjectNumber ,_dcbc .GenerationNumber );};func (_bdeef *PdfParser )skipComments ()error {if _ ,_efdeb :=_bdeef .skipSpaces ();
_efdeb !=nil {return _efdeb ;};_bbcf :=true ;for {_dbaf ,_abcgf :=_bdeef ._bdg .Peek (1);if _abcgf !=nil {_fdf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_abcgf .Error ());return _abcgf ;};if _bbcf &&_dbaf [0]!='%'{return nil ;};_bbcf =false ;
if (_dbaf [0]!='\r')&&(_dbaf [0]!='\n'){_bdeef ._bdg .ReadByte ();}else {break ;};};return _bdeef .skipComments ();};

// NewFlateEncoder makes a new flate encoder with default parameters, predictor 1 and bits per component 8.
func NewFlateEncoder ()*FlateEncoder {_fed :=&FlateEncoder {};_fed .Predictor =1;_fed .BitsPerComponent =8;_fed .Colors =1;_fed .Columns =1;return _fed ;};

// DecodeBytes decodes the CCITTFax encoded image data.
func (_aegc *CCITTFaxEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_decc ,_dbga :=_bbe .NewDecoder (encoded ,_bbe .DecodeOptions {Columns :_aegc .Columns ,Rows :_aegc .Rows ,K :_aegc .K ,EncodedByteAligned :_aegc .EncodedByteAlign ,BlackIsOne :_aegc .BlackIs1 ,EndOfBlock :_aegc .EndOfBlock ,EndOfLine :_aegc .EndOfLine ,DamagedRowsBeforeError :_aegc .DamagedRowsBeforeError });
if _dbga !=nil {return nil ,_dbga ;};_cddg ,_dbga :=_gd .ReadAll (_decc );if _dbga !=nil {return nil ,_dbga ;};return _cddg ,nil ;};

// Read implementation of Read interface.
func (_gabd *limitedReadSeeker )Read (p []byte )(_beee int ,_feffe error ){_eegd ,_feffe :=_gabd ._aee .Seek (0,_ef .SeekCurrent );if _feffe !=nil {return 0,_feffe ;};_bdce :=_gabd ._ddg -_eegd ;if _bdce ==0{return 0,_ef .EOF ;};if _fbag :=int64 (len (p ));
_fbag < _bdce {_bdce =_fbag ;};_dgdc :=make ([]byte ,_bdce );_beee ,_feffe =_gabd ._aee .Read (_dgdc );copy (p ,_dgdc );return _beee ,_feffe ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_bfa *ASCIIHexEncoder )MakeDecodeParams ()PdfObject {return nil };

// GetArray returns the *PdfObjectArray represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetArray (obj PdfObject )(_gafe *PdfObjectArray ,_adebc bool ){_gafe ,_adebc =TraceToDirectObject (obj ).(*PdfObjectArray );return _gafe ,_adebc ;};

// GetParser returns the parser for lazy-loading or compare references.
func (_aaeeb *PdfObjectReference )GetParser ()*PdfParser {return _aaeeb ._aagbc };var _bage =_ge .MustCompile ("\u005b\\\u0072\u005c\u006e\u005d\u005c\u0073\u002a\u0028\u0078\u0072\u0065f\u0029\u005c\u0073\u002a\u005b\u005c\u0072\u005c\u006e\u005d");

// GetFilterName returns the name of the encoding filter.
func (_bfc *LZWEncoder )GetFilterName ()string {return StreamEncodingFilterNameLZW };

// PdfObjectInteger represents the primitive PDF integer numerical object.
type PdfObjectInteger int64 ;

// Len returns the number of elements in the array.
func (_afaa *PdfObjectArray )Len ()int {if _afaa ==nil {return 0;};return len (_afaa ._fadaed );};

// WriteString outputs the object as it is to be written to file.
func (_ebdg *PdfObjectString )WriteString ()string {var _egfb _fda .Buffer ;if _ebdg ._fbcbg {_dbeec :=_e .EncodeToString (_ebdg .Bytes ());_egfb .WriteString ("\u003c");_egfb .WriteString (_dbeec );_egfb .WriteString ("\u003e");return _egfb .String ();
};_dgfe :=map[byte ]string {'\n':"\u005c\u006e",'\r':"\u005c\u0072",'\t':"\u005c\u0074",'\b':"\u005c\u0062",'\f':"\u005c\u0066",'(':"\u005c\u0028",')':"\u005c\u0029",'\\':"\u005c\u005c"};_egfb .WriteString ("\u0028");for _bgc :=0;_bgc < len (_ebdg ._fea );
_bgc ++{_bdad :=_ebdg ._fea [_bgc ];if _abec ,_baeb :=_dgfe [_bdad ];_baeb {_egfb .WriteString (_abec );}else {_egfb .WriteByte (_bdad );};};_egfb .WriteString ("\u0029");return _egfb .String ();};

// MakeArrayFromIntegers64 creates an PdfObjectArray from a slice of int64s, where each array element
// is an PdfObjectInteger.
func MakeArrayFromIntegers64 (vals []int64 )*PdfObjectArray {_affc :=MakeArray ();for _ ,_adbca :=range vals {_affc .Append (MakeInteger (_adbca ));};return _affc ;};var _bagb =_ge .MustCompile ("\u005e\\\u0073\u002a\u005b\u002d]\u002a\u0028\u005c\u0064\u002b)\u005cs\u002b(\u005c\u0064\u002b\u0029\u005c\u0073\u002bR");


// GetDict returns the *PdfObjectDictionary represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetDict (obj PdfObject )(_gddg *PdfObjectDictionary ,_bfda bool ){_gddg ,_bfda =TraceToDirectObject (obj ).(*PdfObjectDictionary );return _gddg ,_bfda ;};

// NewCCITTFaxEncoder makes a new CCITTFax encoder.
func NewCCITTFaxEncoder ()*CCITTFaxEncoder {return &CCITTFaxEncoder {Columns :1728,EndOfBlock :true }};

// PdfVersion returns version of the PDF file.
func (_gfca *PdfParser )PdfVersion ()Version {return _gfca ._dfgf };

// Append appends PdfObject(s) to the streams.
func (_gbge *PdfObjectStreams )Append (objects ...PdfObject ){if _gbge ==nil {_fdf .Log .Debug ("\u0057\u0061\u0072\u006e\u0020-\u0020\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0020\u0074\u006f\u0020\u0061p\u0070\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0073");
return ;};_gbge ._adad =append (_gbge ._adad ,objects ...);};func (_fgbf *PdfParser )repairLocateXref ()(int64 ,error ){_cfeg :=int64 (1000);_fgbf ._dddg .Seek (-_cfeg ,_ef .SeekCurrent );_dcdaf ,_cfgb :=_fgbf ._dddg .Seek (0,_ef .SeekCurrent );if _cfgb !=nil {return 0,_cfgb ;
};_babg :=make ([]byte ,_cfeg );_fgbf ._dddg .Read (_babg );_ffga :=_bage .FindAllStringIndex (string (_babg ),-1);if len (_ffga )< 1{_fdf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0065\u0070a\u0069\u0072\u003a\u0020\u0078\u0072\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021");
return 0,_g .New ("\u0072\u0065\u0070\u0061ir\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064");};_gcbe :=int64 (_ffga [len (_ffga )-1][0]);_bcgf :=_dcdaf +_gcbe ;return _bcgf ,nil ;};func _gfff (_aadf *PdfObjectStream ,_bdeg *MultiEncoder )(*DCTEncoder ,error ){_ddbf :=NewDCTEncoder ();
_fcgbb :=_aadf .PdfObjectDictionary ;if _fcgbb ==nil {return _ddbf ,nil ;};_bae :=_aadf .Stream ;if _bdeg !=nil {_afa ,_dfef :=_bdeg .DecodeBytes (_bae );if _dfef !=nil {return nil ,_dfef ;};_bae =_afa ;};_dcdg :=_fda .NewReader (_bae );_caef ,_agad :=_de .DecodeConfig (_dcdg );
if _agad !=nil {_fdf .Log .Debug ("\u0045\u0072\u0072or\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0065\u003a\u0020\u0025\u0073",_agad );return nil ,_agad ;};switch _caef .ColorModel {case _gf .RGBAModel :_ddbf .BitsPerComponent =8;
_ddbf .ColorComponents =3;case _gf .RGBA64Model :_ddbf .BitsPerComponent =16;_ddbf .ColorComponents =3;case _gf .GrayModel :_ddbf .BitsPerComponent =8;_ddbf .ColorComponents =1;case _gf .Gray16Model :_ddbf .BitsPerComponent =16;_ddbf .ColorComponents =1;
case _gf .CMYKModel :_ddbf .BitsPerComponent =8;_ddbf .ColorComponents =4;case _gf .YCbCrModel :_ddbf .BitsPerComponent =8;_ddbf .ColorComponents =3;default:return nil ,_g .New ("\u0075\u006e\u0073up\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u006d\u006f\u0064\u0065\u006c");
};_ddbf .Width =_caef .Width ;_ddbf .Height =_caef .Height ;_fdf .Log .Trace ("\u0044\u0043T\u0020\u0045\u006ec\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076",_ddbf );_ddbf .Quality =DefaultJPEGQuality ;return _ddbf ,nil ;};

// UpdateParams updates the parameter values of the encoder.
// Implements StreamEncoder interface.
func (_beffd *JBIG2Encoder )UpdateParams (params *PdfObjectDictionary ){_beed ,_eaceg :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _eaceg ==nil {_beffd .BitsPerComponent =int (_beed );
};_cadcg ,_eaceg :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _eaceg ==nil {_beffd .Width =int (_cadcg );};_edgbd ,_eaceg :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _eaceg ==nil {_beffd .Height =int (_edgbd );
};_cbge ,_eaceg :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _eaceg ==nil {_beffd .ColorComponents =int (_cbge );};};

// WriteString outputs the object as it is to be written to file.
func (_fgdg *PdfObjectArray )WriteString ()string {var _gfbee _gc .Builder ;_gfbee .WriteString ("\u005b");for _bedbe ,_gded :=range _fgdg .Elements (){_gfbee .WriteString (_gded .WriteString ());if _bedbe < (_fgdg .Len ()-1){_gfbee .WriteString ("\u0020");
};};_gfbee .WriteString ("\u005d");return _gfbee .String ();};func (_cfbg *PdfParser )repairRebuildXrefsTopDown ()(*XrefTable ,error ){if _cfbg ._bfdea {return nil ,_ae .Errorf ("\u0072\u0065\u0070\u0061\u0069\u0072\u0020\u0066\u0061\u0069\u006c\u0065\u0064");
};_cfbg ._bfdea =true ;_cfbg ._dddg .Seek (0,_ef .SeekStart );_cfbg ._bdg =_faf .NewReader (_cfbg ._dddg );_efbg :=20;_dcee :=make ([]byte ,_efbg );_cefg :=XrefTable {};_cefg .ObjectMap =make (map[int ]XrefObject );for {_bffe ,_bfeg :=_cfbg ._bdg .ReadByte ();
if _bfeg !=nil {if _bfeg ==_ef .EOF {break ;}else {return nil ,_bfeg ;};};if _bffe =='j'&&_dcee [_efbg -1]=='b'&&_dcee [_efbg -2]=='o'&&IsWhiteSpace (_dcee [_efbg -3]){_agac :=_efbg -4;for IsWhiteSpace (_dcee [_agac ])&&_agac > 0{_agac --;};if _agac ==0||!IsDecimalDigit (_dcee [_agac ]){continue ;
};for IsDecimalDigit (_dcee [_agac ])&&_agac > 0{_agac --;};if _agac ==0||!IsWhiteSpace (_dcee [_agac ]){continue ;};for IsWhiteSpace (_dcee [_agac ])&&_agac > 0{_agac --;};if _agac ==0||!IsDecimalDigit (_dcee [_agac ]){continue ;};for IsDecimalDigit (_dcee [_agac ])&&_agac > 0{_agac --;
};if _agac ==0{continue ;};_dcbfb :=_cfbg .GetFileOffset ()-int64 (_efbg -_agac );_gfdgg :=append (_dcee [_agac +1:],_bffe );_fcddg ,_cecc ,_geda :=_bade (string (_gfdgg ));if _geda !=nil {_fdf .Log .Debug ("\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u006e\u0075\u006d\u0062\u0065r\u003a\u0020\u0025\u0076",_geda );
return nil ,_geda ;};if _afee ,_dffg :=_cefg .ObjectMap [_fcddg ];!_dffg ||_afee .Generation < _cecc {_bfdc :=XrefObject {};_bfdc .XType =XrefTypeTableEntry ;_bfdc .ObjectNumber =_fcddg ;_bfdc .Generation =_cecc ;_bfdc .Offset =_dcbfb ;_cefg .ObjectMap [_fcddg ]=_bfdc ;
};};_dcee =append (_dcee [1:_efbg ],_bffe );};_cfbg ._eaag =nil ;return &_cefg ,nil ;};

// LookupByNumber looks up a PdfObject by object number.  Returns an error on failure.
func (_adb *PdfParser )LookupByNumber (objNumber int )(PdfObject ,error ){_dg ,_ ,_cfe :=_adb .lookupByNumberWrapper (objNumber ,true );return _dg ,_cfe ;};

// MakeHexString creates an PdfObjectString from a string intended for output as a hexadecimal string.
func MakeHexString (s string )*PdfObjectString {_gbafa :=PdfObjectString {_fea :s ,_fbcbg :true };return &_gbafa ;};func (_ddba *PdfCrypt )isDecrypted (_dcf PdfObject )bool {_ ,_aegg :=_ddba ._bca [_dcf ];if _aegg {_fdf .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0064\u0065\u0063\u0072y\u0070\u0074\u0065\u0064");
return true ;};switch _daf :=_dcf .(type ){case *PdfObjectStream :if _ddba ._edf .R !=5{if _debf ,_ffc :=_daf .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_ffc &&*_debf =="\u0058\u0052\u0065\u0066"{return true ;};};case *PdfIndirectObject :if _ ,_aegg =_ddba ._agfe [int (_daf .ObjectNumber )];
_aegg {return true ;};switch _afg :=_daf .PdfObject .(type ){case *PdfObjectDictionary :_aad :=true ;for _ ,_egfc :=range _babc {if _afg .Get (_egfc )==nil {_aad =false ;break ;};};if _aad {return true ;};};};_fdf .Log .Trace ("\u004e\u006f\u0074\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");
return false ;};type encryptDict struct{Filter string ;V int ;SubFilter string ;Length int ;StmF string ;StrF string ;EFF string ;CF map[string ]_fg .FilterDict ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_dfdf *ASCIIHexEncoder )MakeStreamDict ()*PdfObjectDictionary {_ceaea :=MakeDict ();_ceaea .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_dfdf .GetFilterName ()));return _ceaea ;};

// IsHexadecimal checks if the PdfObjectString contains Hexadecimal data.
func (_cggc *PdfObjectString )IsHexadecimal ()bool {return _cggc ._fbcbg };

// EncodeBytes encodes data into ASCII85 encoded format.
func (_efcf *ASCII85Encoder )EncodeBytes (data []byte )([]byte ,error ){var _faaf _fda .Buffer ;for _adeda :=0;_adeda < len (data );_adeda +=4{_bcac :=data [_adeda ];_bdcf :=1;_fbce :=byte (0);if _adeda +1< len (data ){_fbce =data [_adeda +1];_bdcf ++;
};_cafb :=byte (0);if _adeda +2< len (data ){_cafb =data [_adeda +2];_bdcf ++;};_edga :=byte (0);if _adeda +3< len (data ){_edga =data [_adeda +3];_bdcf ++;};_gfge :=(uint32 (_bcac )<<24)|(uint32 (_fbce )<<16)|(uint32 (_cafb )<<8)|uint32 (_edga );if _gfge ==0{_faaf .WriteByte ('z');
}else {_ffa :=_efcf .base256Tobase85 (_gfge );for _ ,_bgfb :=range _ffa [:_bdcf +1]{_faaf .WriteByte (_bgfb +'!');};};};_faaf .WriteString ("\u007e\u003e");return _faaf .Bytes (),nil ;};func (_bgeg *PdfObjectDictionary )setWithLock (_fgad PdfObjectName ,_ffdge PdfObject ,_bfdb bool ){if _bfdb {_bgeg ._bebfa .Lock ();
defer _bgeg ._bebfa .Unlock ();};_ ,_geabg :=_bgeg ._acfc [_fgad ];if !_geabg {_bgeg ._fgag =append (_bgeg ._fgag ,_fgad );};_bgeg ._acfc [_fgad ]=_ffdge ;};

// EncryptInfo contains an information generated by the document encrypter.
type EncryptInfo struct{Version ;

// Encrypt is an encryption dictionary that contains all necessary parameters.
// It should be stored in all copies of the document trailer.
Encrypt *PdfObjectDictionary ;

// ID0 and ID1 are IDs used in the trailer. Older algorithms such as RC4 uses them for encryption.
ID0 ,ID1 string ;};func (_aegd *ASCII85Encoder )base256Tobase85 (_bgdb uint32 )[5]byte {_aeac :=[5]byte {0,0,0,0,0};_cadc :=_bgdb ;for _egd :=0;_egd < 5;_egd ++{_fdec :=uint32 (1);for _gddd :=0;_gddd < 4-_egd ;_gddd ++{_fdec *=85;};_fagg :=_cadc /_fdec ;
_cadc =_cadc %_fdec ;_aeac [_egd ]=byte (_fagg );};return _aeac ;};func _bbfcf (_aaa ,_fcbd ,_cfgc uint8 )uint8 {_cbb :=int (_cfgc );_dgaf :=int (_fcbd )-_cbb ;_geb :=int (_aaa )-_cbb ;_cbb =_dedd (_dgaf +_geb );_dgaf =_dedd (_dgaf );_geb =_dedd (_geb );
if _dgaf <=_geb &&_dgaf <=_cbb {return _aaa ;}else if _geb <=_cbb {return _fcbd ;};return _cfgc ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_dbbf *JPXEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};

// ASCIIHexEncoder implements ASCII hex encoder/decoder.
type ASCIIHexEncoder struct{};

// GetBoolVal returns the bool value within a *PdObjectBool represented by an PdfObject interface directly or indirectly.
// If the PdfObject does not represent a bool value, a default value of false is returned (found = false also).
func GetBoolVal (obj PdfObject )(_baaggc bool ,_edbgd bool ){_fff ,_edbgd :=TraceToDirectObject (obj ).(*PdfObjectBool );if _edbgd {return bool (*_fff ),true ;};return false ,false ;};

// DecodeStream decodes a JBIG2 encoded stream and returns the result as a slice of bytes.
func (_cgbb *JBIG2Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _cgbb .DecodeBytes (streamObj .Stream );};

// NewJPXEncoder returns a new instance of JPXEncoder.
func NewJPXEncoder ()*JPXEncoder {return &JPXEncoder {}};type offsetReader struct{_fcag _ef .ReadSeeker ;_bgdg int64 ;};func _ddaf (_fbac *PdfObjectStream ,_acaag *PdfObjectDictionary )(*CCITTFaxEncoder ,error ){_efbdd :=NewCCITTFaxEncoder ();_edfb :=_fbac .PdfObjectDictionary ;
if _edfb ==nil {return _efbdd ,nil ;};if _acaag ==nil {_gcgg :=TraceToDirectObject (_edfb .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));if _gcgg !=nil {switch _aade :=_gcgg .(type ){case *PdfObjectDictionary :_acaag =_aade ;case *PdfObjectArray :if _aade .Len ()==1{if _cbf ,_cbda :=GetDict (_aade .Get (0));
_cbda {_acaag =_cbf ;};};default:_fdf .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_gcgg );return nil ,_g .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");
};};if _acaag ==nil {_fdf .Log .Error ("\u0044\u0065c\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064 %\u0023\u0076",_gcgg );return nil ,_g .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");
};};if _bcec ,_cfce :=GetNumberAsInt64 (_acaag .Get ("\u004b"));_cfce ==nil {_efbdd .K =int (_bcec );};if _cgfc ,_aeag :=GetNumberAsInt64 (_acaag .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));_aeag ==nil {_efbdd .Columns =int (_cgfc );}else {_efbdd .Columns =1728;
};if _acdd ,_ceg :=GetNumberAsInt64 (_acaag .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_ceg ==nil {_efbdd .BlackIs1 =_acdd > 0;}else {if _gfbc ,_gcae :=GetBoolVal (_acaag .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_gcae {_efbdd .BlackIs1 =_gfbc ;
}else {if _cbdb ,_effbb :=GetArray (_acaag .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));_effbb {_gfbf ,_fbdg :=_cbdb .ToIntegerArray ();if _fbdg ==nil {_efbdd .BlackIs1 =_gfbf [0]==1&&_gfbf [1]==0;};};};};if _eceb ,_caefb :=GetNumberAsInt64 (_acaag .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));
_caefb ==nil {_efbdd .EncodedByteAlign =_eceb > 0;}else {if _dffd ,_fecb :=GetBoolVal (_acaag .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_fecb {_efbdd .EncodedByteAlign =_dffd ;};};if _gcddg ,_aecbce :=GetNumberAsInt64 (_acaag .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));
_aecbce ==nil {_efbdd .EndOfLine =_gcddg > 0;}else {if _egee ,_fga :=GetBoolVal (_acaag .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_fga {_efbdd .EndOfLine =_egee ;};};if _efdc ,_bfcf :=GetNumberAsInt64 (_acaag .Get ("\u0052\u006f\u0077\u0073"));
_bfcf ==nil {_efbdd .Rows =int (_efdc );};_efbdd .EndOfBlock =true ;if _ddad ,_aed :=GetNumberAsInt64 (_acaag .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_aed ==nil {_efbdd .EndOfBlock =_ddad > 0;}else {if _ecfc ,_adgf :=GetBoolVal (_acaag .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));
_adgf {_efbdd .EndOfBlock =_ecfc ;};};if _cfcf ,_gdca :=GetNumberAsInt64 (_acaag .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));_gdca !=nil {_efbdd .DamagedRowsBeforeError =int (_cfcf );
};_fdf .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_acaag .String ());return _efbdd ,nil ;};

// IsWhiteSpace checks if byte represents a white space character.
func IsWhiteSpace (ch byte )bool {if (ch ==0x00)||(ch ==0x09)||(ch ==0x0A)||(ch ==0x0C)||(ch ==0x0D)||(ch ==0x20){return true ;};return false ;};

// UpdateParams updates the parameter values of the encoder.
func (_bbba *ASCII85Encoder )UpdateParams (params *PdfObjectDictionary ){};var _agda =_ge .MustCompile ("\u0028\u005c\u0064\u002b)\\\u0073\u002b\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u006f\u0062\u006a");

// MakeStream creates an PdfObjectStream with specified contents and encoding. If encoding is nil, then raw encoding
// will be used (i.e. no encoding applied).
func MakeStream (contents []byte ,encoder StreamEncoder )(*PdfObjectStream ,error ){_ddff :=&PdfObjectStream {};if encoder ==nil {encoder =NewRawEncoder ();};_ddff .PdfObjectDictionary =encoder .MakeStreamDict ();_dggbg ,_acff :=encoder .EncodeBytes (contents );
if _acff !=nil {return nil ,_acff ;};_ddff .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_dggbg ))));_ddff .Stream =_dggbg ;return _ddff ,nil ;};

// GetFilterName returns the name of the encoding filter.
func (_faddg *RunLengthEncoder )GetFilterName ()string {return StreamEncodingFilterNameRunLength };func _bef (_aegf *_gdb .StdEncryptDict ,_fge *PdfObjectDictionary )error {R ,_bab :=_fge .Get ("\u0052").(*PdfObjectInteger );if !_bab {return _g .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0052");
};if *R < 2||*R > 6{return _ae .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0052 \u0028\u0025\u0064\u0029",*R );};_aegf .R =int (*R );O ,_bab :=_fge .GetString ("\u004f");if !_bab {return _g .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u004f");
};if _aegf .R ==5||_aegf .R ==6{if len (O )< 48{return _ae .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u004f\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (O ));};}else if len (O )!=32{return _ae .Errorf ("L\u0065n\u0067\u0074\u0068\u0028\u004f\u0029\u0020\u0021=\u0020\u0033\u0032\u0020(%\u0064\u0029",len (O ));
};_aegf .O =[]byte (O );U ,_bab :=_fge .GetString ("\u0055");if !_bab {return _g .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0055");};if _aegf .R ==5||_aegf .R ==6{if len (U )< 48{return _ae .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u0055\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (U ));
};}else if len (U )!=32{_fdf .Log .Debug ("\u0057\u0061r\u006e\u0069\u006e\u0067\u003a\u0020\u004c\u0065\u006e\u0067\u0074\u0068\u0028\u0055\u0029\u0020\u0021\u003d\u0020\u0033\u0032\u0020(%\u0064\u0029",len (U ));};_aegf .U =[]byte (U );if _aegf .R >=5{OE ,_fefc :=_fge .GetString ("\u004f\u0045");
if !_fefc {return _g .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u004f\u0045");}else if len (OE )!=32{return _ae .Errorf ("L\u0065\u006e\u0067\u0074h(\u004fE\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (OE ));
};_aegf .OE =[]byte (OE );UE ,_fefc :=_fge .GetString ("\u0055\u0045");if !_fefc {return _g .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u0055\u0045");
}else if len (UE )!=32{return _ae .Errorf ("L\u0065\u006e\u0067\u0074h(\u0055E\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (UE ));};_aegf .UE =[]byte (UE );};P ,_bab :=_fge .Get ("\u0050").(*PdfObjectInteger );if !_bab {return _g .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074 \u0064\u0069\u0063t\u0069\u006f\u006e\u0061r\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0070\u0065\u0072\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0061\u0074\u0074\u0072");
};_aegf .P =_gdb .Permissions (*P );if _aegf .R ==6{Perms ,_abc :=_fge .GetString ("\u0050\u0065\u0072m\u0073");if !_abc {return _g .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0050\u0065\u0072\u006d\u0073");
}else if len (Perms )!=16{return _ae .Errorf ("\u004ce\u006e\u0067\u0074\u0068\u0028\u0050\u0065\u0072\u006d\u0073\u0029 \u0021\u003d\u0020\u0031\u0036\u0020\u0028\u0025\u0064\u0029",len (Perms ));};_aegf .Perms =[]byte (Perms );};if _eg ,_aege :=_fge .Get ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061").(*PdfObjectBool );
_aege {_aegf .EncryptMetadata =bool (*_eg );}else {_aegf .EncryptMetadata =true ;};return nil ;};func _gcce (_eebg *PdfObjectDictionary )(_aba *_gg .ImageBase ){var (_fcgd *PdfObjectInteger ;_bdaa bool ;);if _fcgd ,_bdaa =_eebg .Get ("\u0057\u0069\u0064t\u0068").(*PdfObjectInteger );
_bdaa {_aba =&_gg .ImageBase {Width :int (*_fcgd )};}else {return nil ;};if _fcgd ,_bdaa =_eebg .Get ("\u0048\u0065\u0069\u0067\u0068\u0074").(*PdfObjectInteger );_bdaa {_aba .Height =int (*_fcgd );};if _fcgd ,_bdaa =_eebg .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074").(*PdfObjectInteger );
_bdaa {_aba .BitsPerComponent =int (*_fcgd );};if _fcgd ,_bdaa =_eebg .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073").(*PdfObjectInteger );_bdaa {_aba .ColorComponents =int (*_fcgd );};return _aba ;};func (_eefg *JBIG2Encoder )encodeImage (_fbfc _bd .Image )([]byte ,error ){const _acef ="e\u006e\u0063\u006f\u0064\u0065\u0049\u006d\u0061\u0067\u0065";
_dfbbd ,_aagd :=GoImageToJBIG2 (_fbfc ,JB2ImageAutoThreshold );if _aagd !=nil {return nil ,_cd .Wrap (_aagd ,_acef ,"\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069m\u0061g\u0065\u0020\u0074\u006f\u0020\u006a\u0062\u0069\u0067\u0032\u0020\u0069\u006d\u0067");
};if _aagd =_eefg .AddPageImage (_dfbbd ,&_eefg .DefaultPageSettings );_aagd !=nil {return nil ,_cd .Wrap (_aagd ,_acef ,"");};return _eefg .Encode ();};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_ada *LZWEncoder )MakeStreamDict ()*PdfObjectDictionary {_aeff :=MakeDict ();_aeff .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_ada .GetFilterName ()));_eecee :=_ada .MakeDecodeParams ();if _eecee !=nil {_aeff .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_eecee );
};_aeff .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (int64 (_ada .EarlyChange )));return _aeff ;};

// MakeDictMap creates a PdfObjectDictionary initialized from a map of keys to values.
func MakeDictMap (objmap map[string ]PdfObject )*PdfObjectDictionary {_fgege :=MakeDict ();return _fgege .Update (objmap );};

// EncodeBytes ASCII encodes the passed in slice of bytes.
func (_cffgd *ASCIIHexEncoder )EncodeBytes (data []byte )([]byte ,error ){var _ebb _fda .Buffer ;for _ ,_fdb :=range data {_ebb .WriteString (_ae .Sprintf ("\u0025\u002e\u0032X\u0020",_fdb ));};_ebb .WriteByte ('>');return _ebb .Bytes (),nil ;};

// DecodeBytes decodes a slice of ASCII encoded bytes and returns the result.
func (_cgf *ASCIIHexEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_beeg :=_fda .NewReader (encoded );var _bdc []byte ;for {_gdfg ,_gega :=_beeg .ReadByte ();if _gega !=nil {return nil ,_gega ;};if _gdfg =='>'{break ;};if IsWhiteSpace (_gdfg ){continue ;
};if (_gdfg >='a'&&_gdfg <='f')||(_gdfg >='A'&&_gdfg <='F')||(_gdfg >='0'&&_gdfg <='9'){_bdc =append (_bdc ,_gdfg );}else {_fdf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0061\u0073\u0063\u0069\u0069 \u0068\u0065\u0078\u0020\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072 \u0028\u0025\u0063\u0029",_gdfg );
return nil ,_ae .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0061\u0073\u0063\u0069\u0069\u0020\u0068e\u0078 \u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u0020\u0028\u0025\u0063\u0029",_gdfg );};};if len (_bdc )%2==1{_bdc =append (_bdc ,'0');
};_fdf .Log .Trace ("\u0049\u006e\u0062\u006f\u0075\u006e\u0064\u0020\u0025\u0073",_bdc );_badg :=make ([]byte ,_e .DecodedLen (len (_bdc )));_ ,_agd :=_e .Decode (_badg ,_bdc );if _agd !=nil {return nil ,_agd ;};return _badg ,nil ;};

// SetFileOffset sets the file to an offset position and resets buffer.
func (_ffgb *PdfParser )SetFileOffset (offset int64 ){if offset < 0{offset =0;};_ffgb ._dddg .Seek (offset ,_ef .SeekStart );_ffgb ._bdg =_faf .NewReader (_ffgb ._dddg );};

// Get returns the PdfObject corresponding to the specified key.
// Returns a nil value if the key is not set.
func (_bedg *PdfObjectDictionary )Get (key PdfObjectName )PdfObject {_bedg ._bebfa .Lock ();defer _bedg ._bebfa .Unlock ();_ega ,_ebede :=_bedg ._acfc [key ];if !_ebede {return nil ;};return _ega ;};

// DecodeStream decodes a JPX encoded stream and returns the result as a
// slice of bytes.
func (_daca *JPXEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_fdf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_daca .GetFilterName ());
return streamObj .Stream ,ErrNoJPXDecode ;};func _bada (_fddf int )int {if _fddf < 0{return -_fddf ;};return _fddf ;};func _fdff (_dcg XrefTable ){_fdf .Log .Debug ("\u003dX\u003d\u0058\u003d\u0058\u003d");_fdf .Log .Debug ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");
_ggg :=0;for _ ,_ddf :=range _dcg .ObjectMap {_fdf .Log .Debug ("i\u002b\u0031\u003a\u0020\u0025\u0064 \u0028\u006f\u0062\u006a\u0020\u006eu\u006d\u003a\u0020\u0025\u0064\u0020\u0067e\u006e\u003a\u0020\u0025\u0064\u0029\u0020\u002d\u003e\u0020%\u0064",_ggg +1,_ddf .ObjectNumber ,_ddf .Generation ,_ddf .Offset );
_ggg ++;};};

// DecodeStream decodes a multi-encoded stream by passing it through the
// DecodeStream method of the underlying encoders.
func (_dfcg *MultiEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _dfcg .DecodeBytes (streamObj .Stream );};

// DecodeBytes decodes a slice of JPX encoded bytes and returns the result.
func (_bebf *JPXEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_fdf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_bebf .GetFilterName ());
return encoded ,ErrNoJPXDecode ;};func (_fage *PdfCrypt )encryptBytes (_fbcb []byte ,_baa string ,_bbg []byte )([]byte ,error ){_fdf .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");_fdeg ,_gabc :=_fage ._fag [_baa ];
if !_gabc {return nil ,_ae .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_baa );};return _fdeg .EncryptBytes (_fbcb ,_bbg );};

// UpdateParams updates the parameter values of the encoder.
func (_cagf *MultiEncoder )UpdateParams (params *PdfObjectDictionary ){for _ ,_gaac :=range _cagf ._cbab {_gaac .UpdateParams (params );};};

// NewMultiEncoder returns a new instance of MultiEncoder.
func NewMultiEncoder ()*MultiEncoder {_dgg :=MultiEncoder {};_dgg ._cbab =[]StreamEncoder {};return &_dgg ;};

// DecodeBytes decodes a slice of LZW encoded bytes and returns the result.
func (_cdag *LZWEncoder )DecodeBytes (encoded []byte )([]byte ,error ){var _abda _fda .Buffer ;_befb :=_fda .NewReader (encoded );var _dca _ef .ReadCloser ;if _cdag .EarlyChange ==1{_dca =_db .NewReader (_befb ,_db .MSB ,8);}else {_dca =_ac .NewReader (_befb ,_ac .MSB ,8);
};defer _dca .Close ();if _ ,_bgb :=_abda .ReadFrom (_dca );_bgb !=nil {if _bgb !=_ef .ErrUnexpectedEOF ||_abda .Len ()==0{return nil ,_bgb ;};_fdf .Log .Debug ("\u0057\u0041\u0052\u004e\u003a\u0020\u004c\u005a\u0057\u0020\u0064\u0065\u0063\u006f\u0064i\u006e\u0067\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0076\u002e \u004f\u0075\u0074\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062e \u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u002e",_bgb );
};return _abda .Bytes (),nil ;};func (_cfdc *PdfParser )parseName ()(PdfObjectName ,error ){var _gecf _fda .Buffer ;_dbdfe :=false ;for {_cbc ,_deeb :=_cfdc ._bdg .Peek (1);if _deeb ==_ef .EOF {break ;};if _deeb !=nil {return PdfObjectName (_gecf .String ()),_deeb ;
};if !_dbdfe {if _cbc [0]=='/'{_dbdfe =true ;_cfdc ._bdg .ReadByte ();}else if _cbc [0]=='%'{_cfdc .readComment ();_cfdc .skipSpaces ();}else {_fdf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020N\u0061\u006d\u0065\u0020\u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020w\u0069\u0074\u0068\u0020\u0025\u0073\u0020(\u0025\u0020\u0078\u0029",_cbc ,_cbc );
return PdfObjectName (_gecf .String ()),_ae .Errorf ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u006ea\u006d\u0065:\u0020\u0028\u0025\u0063\u0029",_cbc [0]);};}else {if IsWhiteSpace (_cbc [0]){break ;}else if (_cbc [0]=='/')||(_cbc [0]=='[')||(_cbc [0]=='(')||(_cbc [0]==']')||(_cbc [0]=='<')||(_cbc [0]=='>'){break ;
}else if _cbc [0]=='#'{_dabe ,_degf :=_cfdc ._bdg .Peek (3);if _degf !=nil {return PdfObjectName (_gecf .String ()),_degf ;};_dbafe ,_degf :=_e .DecodeString (string (_dabe [1:3]));if _degf !=nil {_fdf .Log .Debug ("\u0045\u0052\u0052\u004fR\u003a\u0020\u0049\u006ev\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0066o\u006c\u006co\u0077\u0069\u006e\u0067 \u0027\u0023\u0027\u002c \u0063\u006f\u006e\u0074\u0069n\u0075\u0069\u006e\u0067\u0020\u0075\u0073i\u006e\u0067\u0020\u006c\u0069t\u0065\u0072\u0061\u006c\u0020\u002d\u0020\u004f\u0075t\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074");
_gecf .WriteByte ('#');_cfdc ._bdg .Discard (1);continue ;};_cfdc ._bdg .Discard (3);_gecf .Write (_dbafe );}else {_bfbg ,_ :=_cfdc ._bdg .ReadByte ();_gecf .WriteByte (_bfbg );};};};return PdfObjectName (_gecf .String ()),nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_adaa *CCITTFaxEncoder )MakeStreamDict ()*PdfObjectDictionary {_ebcd :=MakeDict ();_ebcd .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_adaa .GetFilterName ()));_ebcd .SetIfNotNil ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_adaa .MakeDecodeParams ());
return _ebcd ;};

// NewDCTEncoder makes a new DCT encoder with default parameters.
func NewDCTEncoder ()*DCTEncoder {_daed :=&DCTEncoder {};_daed .ColorComponents =3;_daed .BitsPerComponent =8;_daed .Quality =DefaultJPEGQuality ;return _daed ;};

// WriteString outputs the object as it is to be written to file.
func (_dcgg *PdfObjectBool )WriteString ()string {if *_dcgg {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};func (_fcgb *FlateEncoder )postDecodePredict (_ecfdg []byte )([]byte ,error ){if _fcgb .Predictor > 1{if _fcgb .Predictor ==2{_fdf .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");
_fdf .Log .Trace ("\u0043\u006f\u006c\u006f\u0072\u0073\u003a\u0020\u0025\u0064",_fcgb .Colors );_adbf :=_fcgb .Columns *_fcgb .Colors ;if _adbf < 1{return []byte {},nil ;};_fgbb :=len (_ecfdg )/_adbf ;if len (_ecfdg )%_adbf !=0{_fdf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");
return nil ,_ae .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_ecfdg ),_adbf );};if _adbf %_fcgb .Colors !=0{return nil ,_ae .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_adbf ,_fcgb .Colors );
};if _adbf > len (_ecfdg ){_fdf .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_adbf ,len (_ecfdg ));
return nil ,_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_fdf .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_ecfdg ),_ecfdg );
_bbd :=_fda .NewBuffer (nil );for _bded :=0;_bded < _fgbb ;_bded ++{_eef :=_ecfdg [_adbf *_bded :_adbf *(_bded +1)];for _eeec :=_fcgb .Colors ;_eeec < _adbf ;_eeec ++{_eef [_eeec ]+=_eef [_eeec -_fcgb .Colors ];};_bbd .Write (_eef );};_cdae :=_bbd .Bytes ();
_fdf .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_cdae ),_cdae );return _cdae ,nil ;}else if _fcgb .Predictor >=10&&_fcgb .Predictor <=15{_fdf .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");
_fegf :=_fcgb .Columns *_fcgb .Colors +1;_fdga :=len (_ecfdg )/_fegf ;if len (_ecfdg )%_fegf !=0{return nil ,_ae .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_ecfdg ),_fegf );
};if _fegf > len (_ecfdg ){_fdf .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_fegf ,len (_ecfdg ));
return nil ,_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_bdag :=_fda .NewBuffer (nil );_fdf .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_fcgb .Columns );
_fdf .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_ecfdg ),_fegf ,_fdga );_gedg :=make ([]byte ,_fegf );for _efdee :=0;_efdee < _fegf ;_efdee ++{_gedg [_efdee ]=0;
};_fgeg :=_fcgb .Colors ;for _cea :=0;_cea < _fdga ;_cea ++{_bbgf :=_ecfdg [_fegf *_cea :_fegf *(_cea +1)];_eefc :=_bbgf [0];switch _eefc {case _abfb :case _fbcbf :for _afgb :=1+_fgeg ;_afgb < _fegf ;_afgb ++{_bbgf [_afgb ]+=_bbgf [_afgb -_fgeg ];};case _fegb :for _cbg :=1;
_cbg < _fegf ;_cbg ++{_bbgf [_cbg ]+=_gedg [_cbg ];};case _geab :for _eff :=1;_eff < _fgeg +1;_eff ++{_bbgf [_eff ]+=_gedg [_eff ]/2;};for _defec :=_fgeg +1;_defec < _fegf ;_defec ++{_bbgf [_defec ]+=byte ((int (_bbgf [_defec -_fgeg ])+int (_gedg [_defec ]))/2);
};case _gfcc :for _adge :=1;_adge < _fegf ;_adge ++{var _cafc ,_ecee ,_dge byte ;_ecee =_gedg [_adge ];if _adge >=_fgeg +1{_cafc =_bbgf [_adge -_fgeg ];_dge =_gedg [_adge -_fgeg ];};_bbgf [_adge ]+=_bbfcf (_cafc ,_ecee ,_dge );};default:_fdf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029\u0020\u0040\u0072o\u0077\u0020\u0025\u0064",_eefc ,_cea );
return nil ,_ae .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_eefc );};copy (_gedg ,_bbgf );_bdag .Write (_bbgf [1:]);};_gegb :=_bdag .Bytes ();return _gegb ,nil ;
}else {_fdf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_fcgb .Predictor );return nil ,_ae .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_fcgb .Predictor );
};};return _ecfdg ,nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_fbbe *CCITTFaxEncoder )UpdateParams (params *PdfObjectDictionary ){if _ecc ,_dccd :=GetNumberAsInt64 (params .Get ("\u004b"));_dccd ==nil {_fbbe .K =int (_ecc );};if _fgc ,_bged :=GetNumberAsInt64 (params .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));
_bged ==nil {_fbbe .Columns =int (_fgc );}else if _fgc ,_bged =GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));_bged ==nil {_fbbe .Columns =int (_fgc );};if _bdee ,_adef :=GetNumberAsInt64 (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));
_adef ==nil {_fbbe .BlackIs1 =_bdee > 0;}else {if _ddca ,_gdfgf :=GetBoolVal (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_gdfgf {_fbbe .BlackIs1 =_ddca ;}else {if _cageg ,_eae :=GetArray (params .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));
_eae {_fefaa ,_gadg :=_cageg .ToIntegerArray ();if _gadg ==nil {_fbbe .BlackIs1 =_fefaa [0]==1&&_fefaa [1]==0;};};};};if _aecd ,_cgg :=GetNumberAsInt64 (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));
_cgg ==nil {_fbbe .EncodedByteAlign =_aecd > 0;}else {if _ddfg ,_ddac :=GetBoolVal (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_ddac {_fbbe .EncodedByteAlign =_ddfg ;};};if _ggcee ,_efab :=GetNumberAsInt64 (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));
_efab ==nil {_fbbe .EndOfLine =_ggcee > 0;}else {if _bdecd ,_fcbg :=GetBoolVal (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_fcbg {_fbbe .EndOfLine =_bdecd ;};};if _eaea ,_dgca :=GetNumberAsInt64 (params .Get ("\u0052\u006f\u0077\u0073"));
_dgca ==nil {_fbbe .Rows =int (_eaea );}else if _eaea ,_dgca =GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));_dgca ==nil {_fbbe .Rows =int (_eaea );};if _cec ,_gcb :=GetNumberAsInt64 (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));
_gcb ==nil {_fbbe .EndOfBlock =_cec > 0;}else {if _cagee ,_cedb :=GetBoolVal (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_cedb {_fbbe .EndOfBlock =_cagee ;};};if _egdd ,_baafg :=GetNumberAsInt64 (params .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));
_baafg !=nil {_fbbe .DamagedRowsBeforeError =int (_egdd );};};const (_abfb =0;_fbcbf =1;_fegb =2;_geab =3;_gfcc =4;);

// DecodeStream implements ASCII hex decoding.
func (_egbb *ASCIIHexEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _egbb .DecodeBytes (streamObj .Stream );};

// MakeName creates a PdfObjectName from a string.
func MakeName (s string )*PdfObjectName {_eecd :=PdfObjectName (s );return &_eecd };

// MakeStringFromBytes creates an PdfObjectString from a byte array.
// This is more natural than MakeString as `data` is usually not utf-8 encoded.
func MakeStringFromBytes (data []byte )*PdfObjectString {return MakeString (string (data ))};

// GetStream returns the *PdfObjectStream represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetStream (obj PdfObject )(_aedee *PdfObjectStream ,_dcbf bool ){obj =ResolveReference (obj );_aedee ,_dcbf =obj .(*PdfObjectStream );return _aedee ,_dcbf ;};func (_efcb *PdfCrypt )securityHandler ()_gdb .StdHandler {if _efcb ._edf .R >=5{return _gdb .NewHandlerR6 ();
};return _gdb .NewHandlerR4 (_efcb ._fce ,_efcb ._cca .Length );};

// UpdateParams updates the parameter values of the encoder.
func (_fddb *LZWEncoder )UpdateParams (params *PdfObjectDictionary ){_bcff ,_ccce :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _ccce ==nil {_fddb .Predictor =int (_bcff );};_dfbb ,_ccce :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));
if _ccce ==nil {_fddb .BitsPerComponent =int (_dfbb );};_eead ,_ccce :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _ccce ==nil {_fddb .Columns =int (_eead );};_cba ,_ccce :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));
if _ccce ==nil {_fddb .Colors =int (_cba );};_gfa ,_ccce :=GetNumberAsInt64 (params .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065"));if _ccce ==nil {_fddb .EarlyChange =int (_gfa );};};func (_dage *PdfParser )readComment ()(string ,error ){var _cded _fda .Buffer ;
_ ,_decb :=_dage .skipSpaces ();if _decb !=nil {return _cded .String (),_decb ;};_gbac :=true ;for {_fccd ,_ebcb :=_dage ._bdg .Peek (1);if _ebcb !=nil {_fdf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_ebcb .Error ());return _cded .String (),_ebcb ;
};if _gbac &&_fccd [0]!='%'{return _cded .String (),_g .New ("c\u006f\u006d\u006d\u0065\u006e\u0074 \u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0073\u0074a\u0072\u0074\u0020w\u0069t\u0068\u0020\u0025");};_gbac =false ;if (_fccd [0]!='\r')&&(_fccd [0]!='\n'){_ebed ,_ :=_dage ._bdg .ReadByte ();
_cded .WriteByte (_ebed );}else {break ;};};return _cded .String (),nil ;};func (_ddcg *PdfParser )traceStreamLength (_eefef PdfObject )(PdfObject ,error ){_bfbbc ,_gceb :=_eefef .(*PdfObjectReference );if _gceb {_dbbc ,_baaa :=_ddcg ._fbed [_bfbbc .ObjectNumber ];
if _baaa &&_dbbc {_fdf .Log .Debug ("\u0053t\u0072\u0065a\u006d\u0020\u004c\u0065n\u0067\u0074\u0068 \u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065 u\u006e\u0072\u0065s\u006f\u006cv\u0065\u0064\u0020\u0028\u0069\u006cl\u0065\u0067a\u006c\u0029");
return nil ,_g .New ("\u0069\u006c\u006c\u0065ga\u006c\u0020\u0072\u0065\u0063\u0075\u0072\u0073\u0069\u0076\u0065\u0020\u006c\u006fo\u0070");};_ddcg ._fbed [_bfbbc .ObjectNumber ]=true ;};_gfbg ,_dfee :=_ddcg .Resolve (_eefef );if _dfee !=nil {return nil ,_dfee ;
};_fdf .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_gfbg );if _gceb {_ddcg ._fbed [_bfbbc .ObjectNumber ]=false ;};return _gfbg ,nil ;};

// PdfObjectArray represents the primitive PDF array object.
type PdfObjectArray struct{_fadaed []PdfObject };

// LZWEncoder provides LZW encoding/decoding functionality.
type LZWEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Colors int ;

// LZW algorithm setting.
EarlyChange int ;};

// PdfObjectBool represents the primitive PDF boolean object.
type PdfObjectBool bool ;

// ParserMetadata gets the pdf parser metadata.
func (_egfg *PdfParser )ParserMetadata ()(ParserMetadata ,error ){if !_egfg ._geca {return ParserMetadata {},_ae .Errorf ("\u0070\u0061\u0072\u0073\u0065r\u0020\u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u006d\u0061\u0072\u006be\u0064\u0020\u0066\u006f\u0072\u0020\u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0064\u0065\u0074\u0061\u0069\u006c\u0065\u0064\u0020\u006d\u0065\u0074\u0061\u0064\u0061\u0074a");
};return _egfg ._gbgad ,nil ;};

// GetRevisionNumber returns the current version of the Pdf document.
func (_eafd *PdfParser )GetRevisionNumber ()int {return _eafd ._agba };

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_dac *RunLengthEncoder )MakeStreamDict ()*PdfObjectDictionary {_eaa :=MakeDict ();_eaa .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_dac .GetFilterName ()));return _eaa ;};

// GetRevision returns PdfParser for the specific version of the Pdf document.
func (_cdgba *PdfParser )GetRevision (revisionNumber int )(*PdfParser ,error ){_abcgfe :=_cdgba ._agba ;if _abcgfe ==revisionNumber {return _cdgba ,nil ;};if _abcgfe < revisionNumber {return nil ,_g .New ("\u0075\u006e\u0064\u0065\u0066\u0069\u006e\u0065\u0064\u0020\u0072\u0065\u0076\u0069\u0073i\u006fn\u004e\u0075\u006d\u0062\u0065\u0072\u0020\u0076\u0065\u0072\u0073\u0069\u006f\u006e");
};if _cdgba ._fdaaf [revisionNumber ]!=nil {return _cdgba ._fdaaf [revisionNumber ],nil ;};_efgbe :=_cdgba ;for ;_abcgfe > revisionNumber ;_abcgfe --{_dgff ,_cffc :=_efgbe .GetPreviousRevisionParser ();if _cffc !=nil {return nil ,_cffc ;};_cdgba ._fdaaf [_abcgfe -1]=_dgff ;
_cdgba ._fcfb [_efgbe ]=_dgff ;_efgbe =_dgff ;};return _efgbe ,nil ;};var _aeef =[]byte ("\u0030\u0031\u0032\u003345\u0036\u0037\u0038\u0039\u0061\u0062\u0063\u0064\u0065\u0066\u0041\u0042\u0043\u0044E\u0046");

// RunLengthEncoder represents Run length encoding.
type RunLengthEncoder struct{};func (_ggcb *PdfParser )parsePdfVersion ()(int ,int ,error ){var _aebe int64 =20;_adcg :=make ([]byte ,_aebe );_ggcb ._dddg .Seek (0,_ef .SeekStart );_ggcb ._dddg .Read (_adcg );var _eaae error ;var _ffdg ,_adcgd int ;if _bfcd :=_gbaba .FindStringSubmatch (string (_adcg ));
len (_bfcd )< 3{if _ffdg ,_adcgd ,_eaae =_ggcb .seekPdfVersionTopDown ();_eaae !=nil {_fdf .Log .Debug ("F\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065\u0063\u006f\u0076\u0065\u0072\u0079\u0020\u002d\u0020\u0075n\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0066\u0069nd\u0020\u0076\u0065r\u0073i\u006f\u006e");
return 0,0,_eaae ;};_ggcb ._dddg ,_eaae =_cacg (_ggcb ._dddg ,_ggcb .GetFileOffset ()-8);if _eaae !=nil {return 0,0,_eaae ;};}else {if _ffdg ,_eaae =_bb .Atoi (_bfcd [1]);_eaae !=nil {return 0,0,_eaae ;};if _adcgd ,_eaae =_bb .Atoi (_bfcd [2]);_eaae !=nil {return 0,0,_eaae ;
};_ggcb .SetFileOffset (0);};_ggcb ._bdg =_faf .NewReader (_ggcb ._dddg );_fdf .Log .Debug ("\u0050\u0064\u0066\u0020\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020%\u0064\u002e\u0025\u0064",_ffdg ,_adcgd );return _ffdg ,_adcgd ,nil ;};

// Encode encodes previously prepare jbig2 document and stores it as the byte slice.
func (_dfaa *JBIG2Encoder )Encode ()(_ggbb []byte ,_efcfb error ){const _gcggb ="J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0045\u006eco\u0064\u0065";if _dfaa ._faaa ==nil {return nil ,_cd .Errorf (_gcggb ,"\u0064\u006f\u0063u\u006d\u0065\u006e\u0074 \u0069\u006e\u0070\u0075\u0074\u0020\u0064a\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006e\u0065\u0064");
};_dfaa ._faaa .FullHeaders =_dfaa .DefaultPageSettings .FileMode ;_ggbb ,_efcfb =_dfaa ._faaa .Encode ();if _efcfb !=nil {return nil ,_cd .Wrap (_efcfb ,_gcggb ,"");};return _ggbb ,nil ;};

// GetIndirect returns the *PdfIndirectObject represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetIndirect (obj PdfObject )(_dfag *PdfIndirectObject ,_efaac bool ){obj =ResolveReference (obj );_dfag ,_efaac =obj .(*PdfIndirectObject );return _dfag ,_efaac ;};

// Elements returns a slice of the PdfObject elements in the array.
func (_cebge *PdfObjectArray )Elements ()[]PdfObject {if _cebge ==nil {return nil ;};return _cebge ._fadaed ;};

// EncodeBytes encodes slice of bytes into JBIG2 encoding format.
// The input 'data' must be an image. In order to Decode it a user is responsible to
// load the codec ('png', 'jpg').
// Returns jbig2 single page encoded document byte slice. The encoder uses DefaultPageSettings
// to encode given image.
func (_cadb *JBIG2Encoder )EncodeBytes (data []byte )([]byte ,error ){const _ceea ="\u004aB\u0049\u0047\u0032\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002eE\u006e\u0063\u006f\u0064\u0065\u0042\u0079\u0074\u0065\u0073";if _cadb .ColorComponents !=1||_cadb .BitsPerComponent !=1{return nil ,_cd .Errorf (_ceea ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u002e\u0020\u004a\u0042\u0049G\u0032\u0020E\u006e\u0063o\u0064\u0065\u0072\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020bi\u006e\u0061\u0072\u0079\u0020\u0069\u006d\u0061\u0067e\u0073\u0020\u0064\u0061\u0074\u0061");
};var (_dcce *_ec .Bitmap ;_edd error ;);_deg :=(_cadb .Width *_cadb .Height )==len (data );if _deg {_dcce ,_edd =_ec .NewWithUnpaddedData (_cadb .Width ,_cadb .Height ,data );}else {_dcce ,_edd =_ec .NewWithData (_cadb .Width ,_cadb .Height ,data );};
if _edd !=nil {return nil ,_edd ;};_adbbb :=_cadb .DefaultPageSettings ;if _edd =_adbbb .Validate ();_edd !=nil {return nil ,_cd .Wrap (_edd ,_ceea ,"");};if _cadb ._faaa ==nil {_cadb ._faaa =_fdc .InitEncodeDocument (_adbbb .FileMode );};switch _adbbb .Compression {case JB2Generic :if _edd =_cadb ._faaa .AddGenericPage (_dcce ,_adbbb .DuplicatedLinesRemoval );
_edd !=nil {return nil ,_cd .Wrap (_edd ,_ceea ,"");};case JB2SymbolCorrelation :return nil ,_cd .Error (_ceea ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
case JB2SymbolRankHaus :return nil ,_cd .Error (_ceea ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
default:return nil ,_cd .Error (_ceea ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return _cadb .Encode ();};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_gbea *RawEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};const _efade =10;

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_ddfc *FlateEncoder )MakeStreamDict ()*PdfObjectDictionary {_acdgf :=MakeDict ();_acdgf .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_ddfc .GetFilterName ()));_fagec :=_ddfc .MakeDecodeParams ();if _fagec !=nil {_acdgf .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_fagec );
};return _acdgf ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_gaga *DCTEncoder )MakeDecodeParams ()PdfObject {return nil };

// EncodeImage encodes 'img' golang image.Image into jbig2 encoded bytes document using default encoder settings.
func (_fbfb *JBIG2Encoder )EncodeImage (img _bd .Image )([]byte ,error ){return _fbfb .encodeImage (img )};

// Bytes returns the PdfObjectString content as a []byte array.
func (_edabg *PdfObjectString )Bytes ()[]byte {return []byte (_edabg ._fea )};func _dae (_adg int )cryptFilters {return cryptFilters {_egf :_fg .NewFilterV2 (_adg )}};func (_bda *PdfCrypt )makeKey (_feff string ,_eac ,_acg uint32 ,_edae []byte )([]byte ,error ){_dgd ,_gabf :=_bda ._fag [_feff ];
if !_gabf {return nil ,_ae .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_feff );};return _dgd .MakeKey (_eac ,_acg ,_edae );};const _bfbf =32<<(^uint (0)>>63);func _cacg (_dde _ef .ReadSeeker ,_bgec int64 )(*offsetReader ,error ){_gedbb :=&offsetReader {_fcag :_dde ,_bgdg :_bgec };
_ ,_cgce :=_gedbb .Seek (0,_ef .SeekStart );return _gedbb ,_cgce ;};

// GetCrypter returns the PdfCrypt instance which has information about the PDFs encryption.
func (_bagg *PdfParser )GetCrypter ()*PdfCrypt {return _bagg ._efcc };

// MakeDecodeParams makes a new instance of an encoding dictionary based on the current encoder settings.
func (_cgcc *JBIG2Encoder )MakeDecodeParams ()PdfObject {return MakeDict ()};

// String returns a string describing `array`.
func (_adcgc *PdfObjectArray )String ()string {_afgag :="\u005b";for _gcef ,_gfba :=range _adcgc .Elements (){_afgag +=_gfba .String ();if _gcef < (_adcgc .Len ()-1){_afgag +="\u002c\u0020";};};_afgag +="\u005d";return _afgag ;};

// ASCII85Encoder implements ASCII85 encoder/decoder.
type ASCII85Encoder struct{};func _fb (_ga PdfObject )(int64 ,int64 ,error ){if _ea ,_dbf :=_ga .(*PdfIndirectObject );_dbf {return _ea .ObjectNumber ,_ea .GenerationNumber ,nil ;};if _gb ,_edef :=_ga .(*PdfObjectStream );_edef {return _gb .ObjectNumber ,_gb .GenerationNumber ,nil ;
};return 0,0,_g .New ("\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u002f\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062je\u0063\u0074");};

// GetStringVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetStringVal (obj PdfObject )(_cebbf string ,_cadd bool ){_eada ,_cadd :=TraceToDirectObject (obj ).(*PdfObjectString );if _cadd {return _eada .Str (),true ;};return ;};

// MakeArrayFromIntegers creates an PdfObjectArray from a slice of ints, where each array element is
// an PdfObjectInteger.
func MakeArrayFromIntegers (vals []int )*PdfObjectArray {_gfdge :=MakeArray ();for _ ,_fbbee :=range vals {_gfdge .Append (MakeInteger (int64 (_fbbee )));};return _gfdge ;};func _dfde (_dcac *PdfObjectStream ,_ageg *PdfObjectDictionary )(*JBIG2Encoder ,error ){const _ggbc ="\u006ee\u0077\u004a\u0042\u0049G\u0032\u0044\u0065\u0063\u006fd\u0065r\u0046r\u006f\u006d\u0053\u0074\u0072\u0065\u0061m";
_fccad :=NewJBIG2Encoder ();_cbfg :=_dcac .PdfObjectDictionary ;if _cbfg ==nil {return _fccad ,nil ;};if _ageg ==nil {_fgef :=_cbfg .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _fgef !=nil {switch _fbec :=_fgef .(type ){case *PdfObjectDictionary :_ageg =_fbec ;
case *PdfObjectArray :if _fbec .Len ()==1{if _egfgf ,_babb :=GetDict (_fbec .Get (0));_babb {_ageg =_egfgf ;};};default:_fdf .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065P\u0061\u0072\u0061\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064i\u0063\u0074\u0069\u006f\u006e\u0061\u0072y\u0020\u0025\u0023\u0076",_fgef );
return nil ,_cd .Errorf (_ggbc ,"\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050a\u0072m\u0073\u0020\u0074\u0079\u0070\u0065\u003a \u0025\u0054",_fbec );};};};if _ageg ==nil {return _fccad ,nil ;};_fccad .UpdateParams (_ageg );
_gfgf ,_ebdfd :=GetStream (_ageg .Get ("\u004a\u0042\u0049G\u0032\u0047\u006c\u006f\u0062\u0061\u006c\u0073"));if !_ebdfd {return _fccad ,nil ;};var _adee error ;_fccad .Globals ,_adee =_ff .DecodeGlobals (_gfgf .Stream );if _adee !=nil {_adee =_cd .Wrap (_adee ,_ggbc ,"\u0063\u006f\u0072\u0072u\u0070\u0074\u0065\u0064\u0020\u006a\u0062\u0069\u0067\u0032 \u0065n\u0063\u006f\u0064\u0065\u0064\u0020\u0064a\u0074\u0061");
_fdf .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_adee );return nil ,_adee ;};return _fccad ,nil ;};

// GetXrefType returns the type of the first xref object (table or stream).
func (_aecf *PdfParser )GetXrefType ()*xrefType {return _aecf ._bbbf };

// IsFloatDigit checks if a character can be a part of a float number string.
func IsFloatDigit (c byte )bool {return ('0'<=c &&c <='9')||c =='.'};

// MakeStreamDict make a new instance of an encoding dictionary for a stream object.
func (_cad *ASCII85Encoder )MakeStreamDict ()*PdfObjectDictionary {_fcdf :=MakeDict ();_fcdf .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_cad .GetFilterName ()));return _fcdf ;};

// JBIG2Image is the image structure used by the jbig2 encoder. Its Data must be in a
// 1 bit per component and 1 component per pixel (1bpp). In order to create binary image
// use GoImageToJBIG2 function. If the image data contains the row bytes padding set the HasPadding to true.
type JBIG2Image struct{

// Width and Height defines the image boundaries.
Width ,Height int ;

// Data is the byte slice data for the input image
Data []byte ;

// HasPadding is the attribute that defines if the last byte of the data in the row contains
// 0 bits padding.
HasPadding bool ;};func _eaaf (_adcaf _gg .Image )*JBIG2Image {_fbfbg :=_adcaf .Base ();return &JBIG2Image {Data :_fbfbg .Data ,Width :_fbfbg .Width ,Height :_fbfbg .Height ,HasPadding :true };};

// DecodeBytes decodes byte array with ASCII85. 5 ASCII characters -> 4 raw binary bytes
func (_abfc *ASCII85Encoder )DecodeBytes (encoded []byte )([]byte ,error ){var _ggca []byte ;_fdf .Log .Trace ("\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0020\u0044e\u0063\u006f\u0064\u0065");_gaeg :=0;_afbf :=false ;for _gaeg < len (encoded )&&!_afbf {_ecffg :=[5]byte {0,0,0,0,0};
_aefg :=0;_abg :=0;_bgad :=4;for _abg < 5+_aefg {if _gaeg +_abg ==len (encoded ){break ;};_efee :=encoded [_gaeg +_abg ];if IsWhiteSpace (_efee ){_aefg ++;_abg ++;continue ;}else if _efee =='~'&&_gaeg +_abg +1< len (encoded )&&encoded [_gaeg +_abg +1]=='>'{_bgad =(_abg -_aefg )-1;
if _bgad < 0{_bgad =0;};_afbf =true ;break ;}else if _efee >='!'&&_efee <='u'{_efee -='!';}else if _efee =='z'&&_abg -_aefg ==0{_bgad =4;_abg ++;break ;}else {_fdf .Log .Error ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u002c\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020co\u0064\u0065");
return nil ,_g .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0063\u006f\u0064\u0065\u0020e\u006e\u0063\u006f\u0075\u006e\u0074\u0065\u0072\u0065\u0064");};_ecffg [_abg -_aefg ]=_efee ;_abg ++;};_gaeg +=_abg ;for _gdac :=_bgad +1;_gdac < 5;_gdac ++{_ecffg [_gdac ]=84;
};_acdf :=uint32 (_ecffg [0])*85*85*85*85+uint32 (_ecffg [1])*85*85*85+uint32 (_ecffg [2])*85*85+uint32 (_ecffg [3])*85+uint32 (_ecffg [4]);_dacb :=[]byte {byte ((_acdf >>24)&0xff),byte ((_acdf >>16)&0xff),byte ((_acdf >>8)&0xff),byte (_acdf &0xff)};_ggca =append (_ggca ,_dacb [:_bgad ]...);
};_fdf .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0065\u006e\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",encoded );_fdf .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0064\u0065\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",_ggca );
return _ggca ,nil ;};

// String returns a string describing `streams`.
func (_adcb *PdfObjectStreams )String ()string {return _ae .Sprintf ("\u004f\u0062j\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0025\u0064",_adcb .ObjectNumber );};

// AddPageImage adds the page with the image 'img' to the encoder context in order to encode it jbig2 document.
// The 'settings' defines what encoding type should be used by the encoder.
func (_fbf *JBIG2Encoder )AddPageImage (img *JBIG2Image ,settings *JBIG2EncoderSettings )(_adfb error ){const _fgae ="\u004a\u0042\u0049\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0041\u0064\u0064\u0050\u0061\u0067\u0065\u0049m\u0061\u0067\u0065";
if _fbf ==nil {return _cd .Error (_fgae ,"J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u0020\u0069\u0073 n\u0069\u006c");};if settings ==nil {settings =&_fbf .DefaultPageSettings ;};if _fbf ._faaa ==nil {_fbf ._faaa =_fdc .InitEncodeDocument (settings .FileMode );
};if _adfb =settings .Validate ();_adfb !=nil {return _cd .Wrap (_adfb ,_fgae ,"");};_afgg ,_adfb :=img .toBitmap ();if _adfb !=nil {return _cd .Wrap (_adfb ,_fgae ,"");};switch settings .Compression {case JB2Generic :if _adfb =_fbf ._faaa .AddGenericPage (_afgg ,settings .DuplicatedLinesRemoval );
_adfb !=nil {return _cd .Wrap (_adfb ,_fgae ,"");};case JB2SymbolCorrelation :return _cd .Error (_fgae ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
case JB2SymbolRankHaus :return _cd .Error (_fgae ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");
default:return _cd .Error (_fgae ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return nil ;};

// DecodeStream decodes the stream data and returns the decoded data.
// An error is returned upon failure.
func DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_fdf .Log .Trace ("\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_cfcgb ,_ccgg :=NewEncoderFromStream (streamObj );if _ccgg !=nil {_fdf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_ccgg );
return nil ,_ccgg ;};_fdf .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076\u000a",_cfcgb );_daaae ,_ccgg :=_cfcgb .DecodeStream (streamObj );if _ccgg !=nil {_fdf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_ccgg );
return nil ,_ccgg ;};return _daaae ,nil ;};

// EncodeBytes DCT encodes the passed in slice of bytes.
func (_efff *DCTEncoder )EncodeBytes (data []byte )([]byte ,error ){var _dcfd _bd .Image ;if _efff .ColorComponents ==1&&_efff .BitsPerComponent ==8{_dcfd =&_bd .Gray {Rect :_bd .Rect (0,0,_efff .Width ,_efff .Height ),Pix :data ,Stride :_gg .BytesPerLine (_efff .Width ,_efff .BitsPerComponent ,_efff .ColorComponents )};
}else {var _baaf error ;_dcfd ,_baaf =_gg .NewImage (_efff .Width ,_efff .Height ,_efff .BitsPerComponent ,_efff .ColorComponents ,data ,nil ,nil );if _baaf !=nil {return nil ,_baaf ;};};_egb :=_de .Options {};_egb .Quality =_efff .Quality ;var _daeb _fda .Buffer ;
if _aefc :=_de .Encode (&_daeb ,_dcfd ,&_egb );_aefc !=nil {return nil ,_aefc ;};return _daeb .Bytes (),nil ;};

// PdfParser parses a PDF file and provides access to the object structure of the PDF.
type PdfParser struct{_dfgf Version ;_dddg _ef .ReadSeeker ;_bdg *_faf .Reader ;_eaade int64 ;_agec XrefTable ;_aagdd int64 ;_bbbf *xrefType ;_gfgfd objectStreams ;_gaad *PdfObjectDictionary ;_efcc *PdfCrypt ;_fadg *PdfIndirectObject ;_bfdea bool ;ObjCache objectCache ;
_eaag map[int ]bool ;_fbed map[int64 ]bool ;_gbgad ParserMetadata ;_geca bool ;_accg []int64 ;_agba int ;_aaee bool ;_ecbd int64 ;_fcfb map[*PdfParser ]*PdfParser ;_fdaaf []*PdfParser ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_gedb *JBIG2Encoder )MakeStreamDict ()*PdfObjectDictionary {_aaf :=MakeDict ();_aaf .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_gedb .GetFilterName ()));return _aaf ;};

// GetTrailer returns the PDFs trailer dictionary. The trailer dictionary is typically the starting point for a PDF,
// referencing other key objects that are important in the document structure.
func (_gedd *PdfParser )GetTrailer ()*PdfObjectDictionary {return _gedd ._gaad };var _fdbe =_ge .MustCompile ("\u0073t\u0061r\u0074\u0078\u003f\u0072\u0065f\u005c\u0073*\u0028\u005c\u0064\u002b\u0029");

// IsEncrypted checks if the document is encrypted. A bool flag is returned indicating the result.
// First time when called, will check if the Encrypt dictionary is accessible through the trailer dictionary.
// If encrypted, prepares a crypt datastructure which can be used to authenticate and decrypt the document.
// On failure, an error is returned.
func (_adeg *PdfParser )IsEncrypted ()(bool ,error ){if _adeg ._efcc !=nil {return true ,nil ;}else if _adeg ._gaad ==nil {return false ,nil ;};_fdf .Log .Trace ("\u0043\u0068\u0065c\u006b\u0069\u006e\u0067 \u0065\u006e\u0063\u0072\u0079\u0070\u0074i\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0021");
_ggecb :=_adeg ._gaad .Get ("\u0045n\u0063\u0072\u0079\u0070\u0074");if _ggecb ==nil {return false ,nil ;};_fdf .Log .Trace ("\u0049\u0073\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u0021");var (_gdgf *PdfObjectDictionary ;);switch _adac :=_ggecb .(type ){case *PdfObjectDictionary :_gdgf =_adac ;
case *PdfObjectReference :_fdf .Log .Trace ("\u0030\u003a\u0020\u004c\u006f\u006f\u006b\u0020\u0075\u0070\u0020\u0072e\u0066\u0020\u0025\u0071",_adac );_aedea ,_edefd :=_adeg .LookupByReference (*_adac );_fdf .Log .Trace ("\u0031\u003a\u0020%\u0071",_aedea );
if _edefd !=nil {return false ,_edefd ;};_ecfa ,_gebb :=_aedea .(*PdfIndirectObject );if !_gebb {_fdf .Log .Debug ("E\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006eo\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072ec\u0074\u0020\u006fb\u006ae\u0063\u0074");
return false ,_g .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");};_fccg ,_gebb :=_ecfa .PdfObject .(*PdfObjectDictionary );_adeg ._fadg =_ecfa ;_fdf .Log .Trace ("\u0032\u003a\u0020%\u0071",_fccg );if !_gebb {return false ,_g .New ("\u0074\u0072a\u0069\u006c\u0065\u0072 \u0045\u006ec\u0072\u0079\u0070\u0074\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u006e\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");
};_gdgf =_fccg ;case *PdfObjectNull :_fdf .Log .Debug ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074 \u0069\u0073\u0020a\u0020\u006e\u0075l\u006c\u0020o\u0062\u006a\u0065\u0063\u0074\u002e \u0046il\u0065\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u002e");
return false ,nil ;default:return false ,_ae .Errorf ("u\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0079\u0070\u0065: \u0025\u0054",_adac );};_defad ,_ddfd :=PdfCryptNewDecrypt (_adeg ,_gdgf ,_adeg ._gaad );if _ddfd !=nil {return false ,_ddfd ;
};for _ ,_fabd :=range []string {"\u0045n\u0063\u0072\u0079\u0070\u0074"}{_dgag :=_adeg ._gaad .Get (PdfObjectName (_fabd ));if _dgag ==nil {continue ;};switch _fcdd :=_dgag .(type ){case *PdfObjectReference :_defad ._agfe [int (_fcdd .ObjectNumber )]=struct{}{};
case *PdfIndirectObject :_defad ._bca [_fcdd ]=true ;_defad ._agfe [int (_fcdd .ObjectNumber )]=struct{}{};};};_adeg ._efcc =_defad ;_fdf .Log .Trace ("\u0043\u0072\u0079\u0070\u0074\u0065\u0072\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0025\u0062",_defad );
return true ,nil ;};func (_cgac *PdfParser )parseBool ()(PdfObjectBool ,error ){_gdbfd ,_eded :=_cgac ._bdg .Peek (4);if _eded !=nil {return PdfObjectBool (false ),_eded ;};if (len (_gdbfd )>=4)&&(string (_gdbfd [:4])=="\u0074\u0072\u0075\u0065"){_cgac ._bdg .Discard (4);
return PdfObjectBool (true ),nil ;};_gdbfd ,_eded =_cgac ._bdg .Peek (5);if _eded !=nil {return PdfObjectBool (false ),_eded ;};if (len (_gdbfd )>=5)&&(string (_gdbfd [:5])=="\u0066\u0061\u006cs\u0065"){_cgac ._bdg .Discard (5);return PdfObjectBool (false ),nil ;
};return PdfObjectBool (false ),_g .New ("\u0075n\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0062o\u006fl\u0065a\u006e\u0020\u0073\u0074\u0072\u0069\u006eg");};

// HasOddLengthHexStrings checks if the document has odd length hexadecimal strings.
func (_abd ParserMetadata )HasOddLengthHexStrings ()bool {return _abd ._adcc };

// DecodeGlobals decodes 'encoded' byte stream and returns their Globally defined segments ('Globals').
func (_acafc *JBIG2Encoder )DecodeGlobals (encoded []byte )(_ff .Globals ,error ){return _ff .DecodeGlobals (encoded );};

// PdfObjectStreams represents the primitive PDF object streams.
// 7.5.7 Object Streams (page 45).
type PdfObjectStreams struct{PdfObjectReference ;_adad []PdfObject ;};func (_egg *offsetReader )Seek (offset int64 ,whence int )(int64 ,error ){if whence ==_ef .SeekStart {offset +=_egg ._bgdg ;};_fbfg ,_abb :=_egg ._fcag .Seek (offset ,whence );if _abb !=nil {return _fbfg ,_abb ;
};if whence ==_ef .SeekCurrent {_fbfg -=_egg ._bgdg ;};if _fbfg < 0{return 0,_g .New ("\u0063\u006f\u0072\u0065\u002eo\u0066\u0066\u0073\u0065\u0074\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053e\u0065\u006b\u003a\u0020\u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e");
};return _fbfg ,nil ;};

// HasDataAfterEOF checks if there is some data after EOF marker.
func (_efb ParserMetadata )HasDataAfterEOF ()bool {return _efb ._ggf };const (JB2Generic JBIG2CompressionType =iota ;JB2SymbolCorrelation ;JB2SymbolRankHaus ;);

// Set sets the dictionary's key -> val mapping entry. Overwrites if key already set.
func (_aabbe *PdfObjectDictionary )Set (key PdfObjectName ,val PdfObject ){_aabbe .setWithLock (key ,val ,true );};var _ggec =_ge .MustCompile ("\u005c\u0073\u002a\u0078\u0072\u0065\u0066\u005c\u0073\u002a");

// GetStringBytes is like GetStringVal except that it returns the string as a []byte.
// It is for convenience.
func GetStringBytes (obj PdfObject )(_abbc []byte ,_aebfc bool ){_acdc ,_aebfc :=TraceToDirectObject (obj ).(*PdfObjectString );if _aebfc {return _acdc .Bytes (),true ;};return ;};

// EncodeBytes implements support for LZW encoding.  Currently not supporting predictors (raw compressed data only).
// Only supports the Early change = 1 algorithm (compress/lzw) as the other implementation
// does not have a write method.
// TODO: Consider refactoring compress/lzw to allow both.
func (_eeb *LZWEncoder )EncodeBytes (data []byte )([]byte ,error ){if _eeb .Predictor !=1{return nil ,_ae .Errorf ("\u004c\u005aW \u0050\u0072\u0065d\u0069\u0063\u0074\u006fr =\u00201 \u006f\u006e\u006c\u0079\u0020\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0079e\u0074");
};if _eeb .EarlyChange ==1{return nil ,_ae .Errorf ("\u004c\u005a\u0057\u0020\u0045\u0061\u0072\u006c\u0079\u0020\u0043\u0068\u0061n\u0067\u0065\u0020\u003d\u0020\u0030 \u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0079\u0065\u0074");
};var _debd _fda .Buffer ;_cgbe :=_ac .NewWriter (&_debd ,_ac .MSB ,8);_cgbe .Write (data );_cgbe .Close ();return _debd .Bytes (),nil ;};

// LookupByReference looks up a PdfObject by a reference.
func (_afc *PdfParser )LookupByReference (ref PdfObjectReference )(PdfObject ,error ){_fdf .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0075\u0070\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0025\u0073",ref .String ());return _afc .LookupByNumber (int (ref .ObjectNumber ));
};

// MultiEncoder supports serial encoding.
type MultiEncoder struct{_cbab []StreamEncoder };

// NewEncoderFromStream creates a StreamEncoder based on the stream's dictionary.
func NewEncoderFromStream (streamObj *PdfObjectStream )(StreamEncoder ,error ){_cbdd :=TraceToDirectObject (streamObj .PdfObjectDictionary .Get ("\u0046\u0069\u006c\u0074\u0065\u0072"));if _cbdd ==nil {return NewRawEncoder (),nil ;};if _ ,_bcgb :=_cbdd .(*PdfObjectNull );
_bcgb {return NewRawEncoder (),nil ;};_gcbac ,_cddb :=_cbdd .(*PdfObjectName );if !_cddb {_beea ,_geec :=_cbdd .(*PdfObjectArray );if !_geec {return nil ,_ae .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006f\u0072 \u0041\u0072\u0072\u0061\u0079\u0020\u006fb\u006a\u0065\u0063\u0074");
};if _beea .Len ()==0{return NewRawEncoder (),nil ;};if _beea .Len ()!=1{_eafg ,_bgge :=_cebf (streamObj );if _bgge !=nil {_fdf .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0063\u0072\u0065\u0061\u0074\u0069\u006e\u0067\u0020\u006d\u0075\u006c\u0074i\u0020\u0065\u006e\u0063\u006f\u0064\u0065r\u003a\u0020\u0025\u0076",_bgge );
return nil ,_bgge ;};_fdf .Log .Trace ("\u004d\u0075\u006c\u0074\u0069\u0020\u0065\u006e\u0063:\u0020\u0025\u0073\u000a",_eafg );return _eafg ,nil ;};_cbdd =_beea .Get (0);_gcbac ,_geec =_cbdd .(*PdfObjectName );if !_geec {return nil ,_ae .Errorf ("\u0066\u0069l\u0074\u0065\u0072\u0020a\u0072\u0072a\u0079\u0020\u006d\u0065\u006d\u0062\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006fb\u006a\u0065\u0063\u0074");
};};if _fcbgcf ,_baffg :=_baegb .Load (_gcbac .String ());_baffg {return _fcbgcf .(StreamEncoder ),nil ;};switch *_gcbac {case StreamEncodingFilterNameFlate :return _bfg (streamObj ,nil );case StreamEncodingFilterNameLZW :return _bgeeb (streamObj ,nil );
case StreamEncodingFilterNameDCT :return _gfff (streamObj ,nil );case StreamEncodingFilterNameRunLength :return _bee (streamObj ,nil );case StreamEncodingFilterNameASCIIHex :return NewASCIIHexEncoder (),nil ;case StreamEncodingFilterNameASCII85 ,"\u0041\u0038\u0035":return NewASCII85Encoder (),nil ;
case StreamEncodingFilterNameCCITTFax :return _ddaf (streamObj ,nil );case StreamEncodingFilterNameJBIG2 :return _dfde (streamObj ,nil );case StreamEncodingFilterNameJPX :return NewJPXEncoder (),nil ;};_fdf .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064\u0069\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006fd\u0021");
return nil ,_ae .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064i\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006f\u0064\u0020\u0028\u0025\u0073\u0029",*_gcbac );};var _edec =_g .New ("\u0045\u004f\u0046\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");


// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_ebga *FlateEncoder )EncodeBytes (data []byte )([]byte ,error ){if _ebga .Predictor !=1&&_ebga .Predictor !=11{_fdf .Log .Debug ("E\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0046\u006c\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065r\u0020P\u0072\u0065\u0064\u0069c\u0074\u006fr\u0020\u003d\u0020\u0031\u002c\u0020\u0031\u0031\u0020\u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");
return nil ,ErrUnsupportedEncodingParameters ;};if _ebga .Predictor ==11{_gdg :=_ebga .Columns ;_afb :=len (data )/_gdg ;if len (data )%_gdg !=0{_fdf .Log .Error ("\u0049n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");
return nil ,_g .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");};_cedd :=_fda .NewBuffer (nil );_bebb :=make ([]byte ,_gdg );for _bfde :=0;_bfde < _afb ;_bfde ++{_dcdd :=data [_gdg *_bfde :_gdg *(_bfde +1)];
_bebb [0]=_dcdd [0];for _aaeg :=1;_aaeg < _gdg ;_aaeg ++{_bebb [_aaeg ]=byte (int (_dcdd [_aaeg ]-_dcdd [_aaeg -1])%256);};_cedd .WriteByte (1);_cedd .Write (_bebb );};data =_cedd .Bytes ();};var _aecbc _fda .Buffer ;_dcda :=_fd .NewWriter (&_aecbc );_dcda .Write (data );
_dcda .Close ();return _aecbc .Bytes (),nil ;};

// GetNumbersAsFloat converts a list of pdf objects representing floats or integers to a slice of
// float64 values.
func GetNumbersAsFloat (objects []PdfObject )(_eafe []float64 ,_aagfde error ){for _ ,_ffcd :=range objects {_adcga ,_cdff :=GetNumberAsFloat (_ffcd );if _cdff !=nil {return nil ,_cdff ;};_eafe =append (_eafe ,_adcga );};return _eafe ,nil ;};

// EncodeBytes encodes the passed in slice of bytes by passing it through the
// EncodeBytes method of the underlying encoders.
func (_addc *MultiEncoder )EncodeBytes (data []byte )([]byte ,error ){_dffe :=data ;var _bcfc error ;for _cagea :=len (_addc ._cbab )-1;_cagea >=0;_cagea --{_cffgb :=_addc ._cbab [_cagea ];_dffe ,_bcfc =_cffgb .EncodeBytes (_dffe );if _bcfc !=nil {return nil ,_bcfc ;
};};return _dffe ,nil ;};func _agadc (_ffac string )(PdfObjectReference ,error ){_fbbg :=PdfObjectReference {};_abba :=_bagb .FindStringSubmatch (_ffac );if len (_abba )< 3{_fdf .Log .Debug ("\u0045\u0072\u0072or\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");
return _fbbg ,_g .New ("\u0075n\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061r\u0073e\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");};_cgag ,_ :=_bb .Atoi (_abba [1]);_bdea ,_ :=_bb .Atoi (_abba [2]);_fbbg .ObjectNumber =int64 (_cgag );_fbbg .GenerationNumber =int64 (_bdea );
return _fbbg ,nil ;};func (_efcg *PdfParser )parseNull ()(PdfObjectNull ,error ){_ ,_abcea :=_efcg ._bdg .Discard (4);return PdfObjectNull {},_abcea ;};

// DecodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_ccca *RawEncoder )DecodeBytes (encoded []byte )([]byte ,error ){return encoded ,nil };

// String returns the PDF version as a string. Implements interface fmt.Stringer.
func (_bagab Version )String ()string {return _ae .Sprintf ("\u00250\u0064\u002e\u0025\u0030\u0064",_bagab .Major ,_bagab .Minor );};func _eba (_gfg _fg .Filter ,_gbc _gdb .AuthEvent )*PdfObjectDictionary {if _gbc ==""{_gbc =_gdb .EventDocOpen ;};_gab :=MakeDict ();
_gab .Set ("\u0054\u0079\u0070\u0065",MakeName ("C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"));_gab .Set ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et",MakeName (string (_gbc )));_gab .Set ("\u0043\u0046\u004d",MakeName (_gfg .Name ()));
_gab .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_gfg .KeyLength ())));return _gab ;};func (_eaf *PdfCrypt )saveCryptFilters (_aga *PdfObjectDictionary )error {if _eaf ._cca .V < 4{return _g .New ("\u0063\u0061\u006e\u0020\u006f\u006e\u006c\u0079\u0020\u0062\u0065 \u0075\u0073\u0065\u0064\u0020\u0077\u0069\u0074\u0068\u0020V\u003e\u003d\u0034");
};_dad :=MakeDict ();_aga .Set ("\u0043\u0046",_dad );for _fde ,_gcdc :=range _eaf ._fag {if _fde =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{continue ;};_bge :=_eba (_gcdc ,"");_dad .Set (PdfObjectName (_fde ),_bge );};_aga .Set ("\u0053\u0074\u0072\u0046",MakeName (_eaf ._cb ));
_aga .Set ("\u0053\u0074\u006d\u0046",MakeName (_eaf ._ba ));return nil ;};func (_dgafad *PdfParser )parseXrefTable ()(*PdfObjectDictionary ,error ){var _aagc *PdfObjectDictionary ;_dcba ,_efabf :=_dgafad .readTextLine ();if _efabf !=nil {return nil ,_efabf ;
};if _dgafad ._geca &&_gc .Count (_gc .TrimPrefix (_dcba ,"\u0078\u0072\u0065\u0066"),"\u0020")> 0{_dgafad ._gbgad ._gcdd =true ;};_fdf .Log .Trace ("\u0078\u0072\u0065\u0066 f\u0069\u0072\u0073\u0074\u0020\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_dcba );
_aced :=-1;_ggdf :=0;_bbgfa :=false ;_efdg :="";for {_dgafad .skipSpaces ();_ ,_edadg :=_dgafad ._bdg .Peek (1);if _edadg !=nil {return nil ,_edadg ;};_dcba ,_edadg =_dgafad .readTextLine ();if _edadg !=nil {return nil ,_edadg ;};_cegd :=_cga .FindStringSubmatch (_dcba );
if len (_cegd )==0{_gbdc :=len (_efdg )> 0;_efdg +=_dcba +"\u000a";if _gbdc {_cegd =_cga .FindStringSubmatch (_efdg );};};if len (_cegd )==3{if _dgafad ._geca &&!_dgafad ._gbgad ._cff {var (_fbcg bool ;_eedg int ;);for _ ,_dadb :=range _dcba {if _f .IsDigit (_dadb ){if _fbcg {break ;
};continue ;};if !_fbcg {_fbcg =true ;};_eedg ++;};if _eedg > 1{_dgafad ._gbgad ._cff =true ;};};_fcfc ,_ :=_bb .Atoi (_cegd [1]);_aedb ,_ :=_bb .Atoi (_cegd [2]);_aced =_fcfc ;_ggdf =_aedb ;_bbgfa =true ;_efdg ="";_fdf .Log .Trace ("\u0078r\u0065\u0066 \u0073\u0075\u0062s\u0065\u0063\u0074\u0069\u006f\u006e\u003a \u0066\u0069\u0072\u0073\u0074\u0020o\u0062\u006a\u0065\u0063\u0074\u003a\u0020\u0025\u0064\u0020\u006fb\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_aced ,_ggdf );
continue ;};_dgfc :=_cafa .FindStringSubmatch (_dcba );if len (_dgfc )==4{if !_bbgfa {_fdf .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0058r\u0065\u0066\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u006fr\u006da\u0074\u0021\u000a");return nil ,_g .New ("\u0078\u0072\u0065\u0066 i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072\u006d\u0061\u0074");
};_afae ,_ :=_bb .ParseInt (_dgfc [1],10,64);_bfcfe ,_ :=_bb .Atoi (_dgfc [2]);_gedga :=_dgfc [3];_efdg ="";if _gc .ToLower (_gedga )=="\u006e"&&_afae > 1{_gfcb ,_cegcg :=_dgafad ._agec .ObjectMap [_aced ];if !_cegcg ||_bfcfe > _gfcb .Generation {_ebafb :=XrefObject {ObjectNumber :_aced ,XType :XrefTypeTableEntry ,Offset :_afae ,Generation :_bfcfe };
_dgafad ._agec .ObjectMap [_aced ]=_ebafb ;};};_aced ++;continue ;};if (len (_dcba )> 6)&&(_dcba [:7]=="\u0074r\u0061\u0069\u006c\u0065\u0072"){_fdf .Log .Trace ("\u0046o\u0075n\u0064\u0020\u0074\u0072\u0061i\u006c\u0065r\u0020\u002d\u0020\u0025\u0073",_dcba );
if len (_dcba )> 9{_cdf :=_dgafad .GetFileOffset ();_dgafad .SetFileOffset (_cdf -int64 (len (_dcba ))+7);};_dgafad .skipSpaces ();_dgafad .skipComments ();_fdf .Log .Trace ("R\u0065\u0061\u0064\u0069ng\u0020t\u0072\u0061\u0069\u006c\u0065r\u0020\u0064\u0069\u0063\u0074\u0021");
_fdf .Log .Trace ("\u0070\u0065\u0065\u006b\u003a\u0020\u0022\u0025\u0073\u0022",_dcba );_aagc ,_edadg =_dgafad .ParseDict ();_fdf .Log .Trace ("\u0045O\u0046\u0020\u0072\u0065a\u0064\u0069\u006e\u0067\u0020t\u0072a\u0069l\u0065\u0072\u0020\u0064\u0069\u0063\u0074!");
if _edadg !=nil {_fdf .Log .Debug ("\u0045\u0072\u0072o\u0072\u0020\u0070\u0061r\u0073\u0069\u006e\u0067\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u0064\u0069\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_edadg );return nil ,_edadg ;};break ;};if _dcba =="\u0025\u0025\u0045O\u0046"{_fdf .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006e\u0064 \u006f\u0066\u0020\u0066\u0069\u006c\u0065 -\u0020\u0074\u0072\u0061i\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066ou\u006e\u0064 \u002d\u0020\u0065\u0072\u0072\u006f\u0072\u0021");
return nil ,_g .New ("\u0065\u006e\u0064 \u006f\u0066\u0020\u0066i\u006c\u0065\u0020\u002d\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};_fdf .Log .Trace ("\u0078\u0072\u0065\u0066\u0020\u006d\u006f\u0072\u0065 \u003a\u0020\u0025\u0073",_dcba );
};_fdf .Log .Trace ("\u0045\u004f\u0046 p\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0021");if _dgafad ._bbbf ==nil {_dcdc :=XrefTypeTableEntry ;_dgafad ._bbbf =&_dcdc ;};return _aagc ,nil ;};
func _gabba (_dbbfg ,_ffaa ,_dabfd int )error {if _ffaa < 0||_ffaa > _dbbfg {return _g .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0061\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");};if _dabfd < _ffaa {return _g .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0073\u006c\u0069\u0063e\u0020i\u006ed\u0065\u0078\u0020\u0062\u0020\u003c\u0020a");
};if _dabfd > _dbbfg {return _g .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0062\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");};return nil ;};

// NewLZWEncoder makes a new LZW encoder with default parameters.
func NewLZWEncoder ()*LZWEncoder {_daff :=&LZWEncoder {};_daff .Predictor =1;_daff .BitsPerComponent =8;_daff .Colors =1;_daff .Columns =1;_daff .EarlyChange =1;return _daff ;};

// ToFloat64Array returns a slice of all elements in the array as a float64 slice.  An error is
// returned if the array contains non-numeric objects (each element can be either PdfObjectInteger
// or PdfObjectFloat).
func (_bgcb *PdfObjectArray )ToFloat64Array ()([]float64 ,error ){var _bfbbef []float64 ;for _ ,_gbec :=range _bgcb .Elements (){switch _gdea :=_gbec .(type ){case *PdfObjectInteger :_bfbbef =append (_bfbbef ,float64 (*_gdea ));case *PdfObjectFloat :_bfbbef =append (_bfbbef ,float64 (*_gdea ));
default:return nil ,ErrTypeError ;};};return _bfbbef ,nil ;};

// DecodeBytes decodes a slice of Flate encoded bytes and returns the result.
func (_gegd *FlateEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_fdf .Log .Trace ("\u0046\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065\u0020b\u0079\u0074\u0065\u0073");if len (encoded )==0{_fdf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0046\u006c\u0061\u0074\u0065 e\u006ec\u006f\u0064\u0065\u0064\u0020\u0062\u0075\u0066\u0066\u0065\u0072\u002e \u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0062y\u0074\u0065\u0020\u0073\u006c\u0069\u0063\u0065\u002e");
return []byte {},nil ;};_eag :=_fda .NewReader (encoded );_dfec ,_gece :=_fd .NewReader (_eag );if _gece !=nil {_fdf .Log .Debug ("\u0044e\u0063o\u0064\u0069\u006e\u0067\u0020e\u0072\u0072o\u0072\u0020\u0025\u0076\u000a",_gece );_fdf .Log .Debug ("\u0053t\u0072e\u0061\u006d\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (encoded ),encoded );
return nil ,_gece ;};defer _dfec .Close ();var _cdgg _fda .Buffer ;_cdgg .ReadFrom (_dfec );return _cdgg .Bytes (),nil ;};

// DecodeStream returns the passed in stream as a slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_gceg *RawEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return streamObj .Stream ,nil ;};

// DecodeBytes decodes a slice of JBIG2 encoded bytes and returns the results.
func (_fbba *JBIG2Encoder )DecodeBytes (encoded []byte )([]byte ,error ){return _ff .DecodeBytes (encoded ,_ded .Parameters {},_fbba .Globals );};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_bbaa *CCITTFaxEncoder )MakeDecodeParams ()PdfObject {_fbb :=MakeDict ();_fbb .Set ("\u004b",MakeInteger (int64 (_bbaa .K )));_fbb .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_bbaa .Columns )));if _bbaa .BlackIs1 {_fbb .Set ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031",MakeBool (_bbaa .BlackIs1 ));
};if _bbaa .EncodedByteAlign {_fbb .Set ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e",MakeBool (_bbaa .EncodedByteAlign ));};if _bbaa .EndOfLine &&_bbaa .K >=0{_fbb .Set ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee",MakeBool (_bbaa .EndOfLine ));
};if _bbaa .Rows !=0&&!_bbaa .EndOfBlock {_fbb .Set ("\u0052\u006f\u0077\u0073",MakeInteger (int64 (_bbaa .Rows )));};if !_bbaa .EndOfBlock {_fbb .Set ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b",MakeBool (_bbaa .EndOfBlock ));};if _bbaa .DamagedRowsBeforeError !=0{_fbb .Set ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072",MakeInteger (int64 (_bbaa .DamagedRowsBeforeError )));
};return _fbb ;};var _babc =[]PdfObjectName {"\u0056","\u0052","\u004f","\u0055","\u0050"};

// IsNullObject returns true if `obj` is a PdfObjectNull.
func IsNullObject (obj PdfObject )bool {_ ,_edgbe :=TraceToDirectObject (obj ).(*PdfObjectNull );return _edgbe ;};

// UpdateParams updates the parameter values of the encoder.
func (_ebeb *RunLengthEncoder )UpdateParams (params *PdfObjectDictionary ){};

// NewRawEncoder returns a new instace of RawEncoder.
func NewRawEncoder ()*RawEncoder {return &RawEncoder {}};func _cebf (_gbeab *PdfObjectStream )(*MultiEncoder ,error ){_cfec :=NewMultiEncoder ();_ecag :=_gbeab .PdfObjectDictionary ;if _ecag ==nil {return _cfec ,nil ;};var _acbbf *PdfObjectDictionary ;
var _eccb []PdfObject ;_dbfc :=_ecag .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _dbfc !=nil {_efgb ,_cfdd :=_dbfc .(*PdfObjectDictionary );if _cfdd {_acbbf =_efgb ;};_geacd ,_feffc :=_dbfc .(*PdfObjectArray );if _feffc {for _ ,_fdgda :=range _geacd .Elements (){_fdgda =TraceToDirectObject (_fdgda );
if _cfdg ,_cebgc :=_fdgda .(*PdfObjectDictionary );_cebgc {_eccb =append (_eccb ,_cfdg );}else {_eccb =append (_eccb ,MakeDict ());};};};};_dbfc =_ecag .Get ("\u0046\u0069\u006c\u0074\u0065\u0072");if _dbfc ==nil {return nil ,_ae .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u006d\u0069s\u0073\u0069\u006e\u0067");
};_gfae ,_effc :=_dbfc .(*PdfObjectArray );if !_effc {return nil ,_ae .Errorf ("m\u0075\u006c\u0074\u0069\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0063\u0061\u006e\u0020\u006f\u006el\u0079\u0020\u0062\u0065\u0020\u006d\u0061\u0064\u0065\u0020fr\u006f\u006d\u0020a\u0072r\u0061\u0079");
};for _dccde ,_caff :=range _gfae .Elements (){_bdd ,_fefb :=_caff .(*PdfObjectName );if !_fefb {return nil ,_ae .Errorf ("\u006d\u0075l\u0074\u0069\u0020\u0066i\u006c\u0074e\u0072\u0020\u0061\u0072\u0072\u0061\u0079\u0020e\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u006e\u006f\u0074\u0020\u0061 \u006e\u0061\u006d\u0065");
};var _cfg PdfObject ;if _acbbf !=nil {_cfg =_acbbf ;}else {if len (_eccb )> 0{if _dccde >=len (_eccb ){return nil ,_ae .Errorf ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0073\u0020\u0069\u006e\u0020d\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006d\u0073\u0020a\u0072\u0072\u0061\u0079");
};_cfg =_eccb [_dccde ];};};var _ccf *PdfObjectDictionary ;if _fefcf ,_cfab :=_cfg .(*PdfObjectDictionary );_cfab {_ccf =_fefcf ;};_fdf .Log .Trace ("\u004e\u0065\u0078t \u006e\u0061\u006d\u0065\u003a\u0020\u0025\u0073\u002c \u0064p\u003a \u0025v\u002c\u0020\u0064\u0050\u0061\u0072\u0061\u006d\u0073\u003a\u0020\u0025\u0076",*_bdd ,_cfg ,_ccf );
if *_bdd ==StreamEncodingFilterNameFlate {_gcbg ,_adbfd :=_bfg (_gbeab ,_ccf );if _adbfd !=nil {return nil ,_adbfd ;};_cfec .AddEncoder (_gcbg );}else if *_bdd ==StreamEncodingFilterNameLZW {_beag ,_agg :=_bgeeb (_gbeab ,_ccf );if _agg !=nil {return nil ,_agg ;
};_cfec .AddEncoder (_beag );}else if *_bdd ==StreamEncodingFilterNameASCIIHex {_adgc :=NewASCIIHexEncoder ();_cfec .AddEncoder (_adgc );}else if *_bdd ==StreamEncodingFilterNameASCII85 {_gfdg :=NewASCII85Encoder ();_cfec .AddEncoder (_gfdg );}else if *_bdd ==StreamEncodingFilterNameDCT {_aabc ,_aacd :=_gfff (_gbeab ,_cfec );
if _aacd !=nil {return nil ,_aacd ;};_cfec .AddEncoder (_aabc );_fdf .Log .Trace ("A\u0064d\u0065\u0064\u0020\u0044\u0043\u0054\u0020\u0065n\u0063\u006f\u0064\u0065r.\u002e\u002e");_fdf .Log .Trace ("\u004du\u006ct\u0069\u0020\u0065\u006e\u0063o\u0064\u0065r\u003a\u0020\u0025\u0023\u0076",_cfec );
}else if *_bdd ==StreamEncodingFilterNameCCITTFax {_gcde ,_bafa :=_ddaf (_gbeab ,_ccf );if _bafa !=nil {return nil ,_bafa ;};_cfec .AddEncoder (_gcde );}else {_fdf .Log .Error ("U\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0066\u0069l\u0074\u0065\u0072\u0020\u0025\u0073",*_bdd );
return nil ,_ae .Errorf ("\u0069\u006eva\u006c\u0069\u0064 \u0066\u0069\u006c\u0074er \u0069n \u006d\u0075\u006c\u0074\u0069\u0020\u0066il\u0074\u0065\u0072\u0020\u0061\u0072\u0072a\u0079");};};return _cfec ,nil ;};

// GetPreviousRevisionParser returns PdfParser for the previous version of the Pdf document.
func (_afbg *PdfParser )GetPreviousRevisionParser ()(*PdfParser ,error ){if _afbg ._agba ==0{return nil ,_g .New ("\u0074\u0068\u0069\u0073 i\u0073\u0020\u0066\u0069\u0072\u0073\u0074\u0020\u0072\u0065\u0076\u0069\u0073\u0069o\u006e");};if _gecfa ,_gfgd :=_afbg ._fcfb [_afbg ];
_gfgd {return _gecfa ,nil ;};_efad ,_gaca :=_afbg .GetPreviousRevisionReadSeeker ();if _gaca !=nil {return nil ,_gaca ;};_ddgb ,_gaca :=NewParser (_efad );_ddgb ._fcfb =_afbg ._fcfb ;if _gaca !=nil {return nil ,_gaca ;};_afbg ._fcfb [_afbg ]=_ddgb ;return _ddgb ,nil ;
};

// GetFilterName returns the name of the encoding filter.
func (_bdbc *DCTEncoder )GetFilterName ()string {return StreamEncodingFilterNameDCT };func _dedd (_caeg int )int {_beae :=_caeg >>(_bfbf -1);return (_caeg ^_beae )-_beae };

// ParseIndirectObject parses an indirect object from the input stream. Can also be an object stream.
// Returns the indirect object (*PdfIndirectObject) or the stream object (*PdfObjectStream).
func (_dgbg *PdfParser )ParseIndirectObject ()(PdfObject ,error ){_bgffg :=PdfIndirectObject {};_bgffg ._aagbc =_dgbg ;_fdf .Log .Trace ("\u002dR\u0065a\u0064\u0020\u0069\u006e\u0064i\u0072\u0065c\u0074\u0020\u006f\u0062\u006a");_efaf ,_eecaa :=_dgbg ._bdg .Peek (20);
if _eecaa !=nil {if _eecaa !=_ef .EOF {_fdf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020r\u0065a\u0064\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a");return &_bgffg ,_eecaa ;
};};_fdf .Log .Trace ("\u0028\u0069\u006edi\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_efaf ));_dbbg :=_agda .FindStringSubmatchIndex (string (_efaf ));if len (_dbbg )< 6{if _eecaa ==_ef .EOF {return nil ,_eecaa ;
};_fdf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_efaf ));
return &_bgffg ,_g .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");
};_dgbg ._bdg .Discard (_dbbg [0]);_fdf .Log .Trace ("O\u0066\u0066\u0073\u0065\u0074\u0073\u0020\u0025\u0020\u0064",_dbbg );_ffcc :=_dbbg [1]-_dbbg [0];_gfbe :=make ([]byte ,_ffcc );_ ,_eecaa =_dgbg .ReadAtLeast (_gfbe ,_ffcc );if _eecaa !=nil {_fdf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u0072\u0065\u0061\u0064\u0020-\u0020\u0025\u0073",_eecaa );
return nil ,_eecaa ;};_fdf .Log .Trace ("\u0074\u0065\u0078t\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_gfbe );_abgc :=_agda .FindStringSubmatch (string (_gfbe ));if len (_abgc )< 3{_fdf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_gfbe ));
return &_bgffg ,_g .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");
};_ggdd ,_ :=_bb .Atoi (_abgc [1]);_egddf ,_ :=_bb .Atoi (_abgc [2]);_bgffg .ObjectNumber =int64 (_ggdd );_bgffg .GenerationNumber =int64 (_egddf );for {_afcca ,_aaaf :=_dgbg ._bdg .Peek (2);if _aaaf !=nil {return &_bgffg ,_aaaf ;};_fdf .Log .Trace ("I\u006ed\u002e\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_afcca ),string (_afcca ));
if IsWhiteSpace (_afcca [0]){_dgbg .skipSpaces ();}else if _afcca [0]=='%'{_dgbg .skipComments ();}else if (_afcca [0]=='<')&&(_afcca [1]=='<'){_fdf .Log .Trace ("\u0043\u0061\u006c\u006c\u0020\u0050\u0061\u0072\u0073e\u0044\u0069\u0063\u0074");_bgffg .PdfObject ,_aaaf =_dgbg .ParseDict ();
_fdf .Log .Trace ("\u0045\u004f\u0046\u0020Ca\u006c\u006c\u0020\u0050\u0061\u0072\u0073\u0065\u0044\u0069\u0063\u0074\u003a\u0020%\u0076",_aaaf );if _aaaf !=nil {return &_bgffg ,_aaaf ;};_fdf .Log .Trace ("\u0050\u0061\u0072\u0073\u0065\u0064\u0020\u0064\u0069\u0063t\u0069\u006f\u006e\u0061\u0072\u0079\u002e.\u002e\u0020\u0066\u0069\u006e\u0069\u0073\u0068\u0065\u0064\u002e");
}else if (_afcca [0]=='/')||(_afcca [0]=='(')||(_afcca [0]=='[')||(_afcca [0]=='<'){_bgffg .PdfObject ,_aaaf =_dgbg .parseObject ();if _aaaf !=nil {return &_bgffg ,_aaaf ;};_fdf .Log .Trace ("P\u0061\u0072\u0073\u0065\u0064\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u002e\u002e\u002e \u0066\u0069\u006ei\u0073h\u0065\u0064\u002e");
}else if _afcca [0]==']'{_fdf .Log .Debug ("\u0057\u0041\u0052\u004e\u0049N\u0047\u003a\u0020\u0027\u005d\u0027 \u0063\u0068\u0061\u0072\u0061\u0063\u0074e\u0072\u0020\u006eo\u0074\u0020\u0062\u0065i\u006e\u0067\u0020\u0075\u0073\u0065d\u0020\u0061\u0073\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006e\u0064\u0069n\u0067\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e");
_dgbg ._bdg .Discard (1);}else {if _afcca [0]=='e'{_ggde ,_gbaf :=_dgbg .readTextLine ();if _gbaf !=nil {return nil ,_gbaf ;};if len (_ggde )>=6&&_ggde [0:6]=="\u0065\u006e\u0064\u006f\u0062\u006a"{break ;};}else if _afcca [0]=='s'{_afcca ,_ =_dgbg ._bdg .Peek (10);
if string (_afcca [:6])=="\u0073\u0074\u0072\u0065\u0061\u006d"{_fbaa :=6;if len (_afcca )> 6{if IsWhiteSpace (_afcca [_fbaa ])&&_afcca [_fbaa ]!='\r'&&_afcca [_fbaa ]!='\n'{_fdf .Log .Debug ("\u004e\u006fn\u002d\u0063\u006f\u006e\u0066\u006f\u0072\u006d\u0061\u006e\u0074\u0020\u0050\u0044\u0046\u0020\u006e\u006f\u0074 \u0065\u006e\u0064\u0069\u006e\u0067 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0069\u006e\u0065\u0020\u0070\u0072o\u0070\u0065r\u006c\u0079\u0020\u0077i\u0074\u0068\u0020\u0045\u004fL\u0020\u006d\u0061\u0072\u006b\u0065\u0072");
_dgbg ._gbgad ._cgd =true ;_fbaa ++;};if _afcca [_fbaa ]=='\r'{_fbaa ++;if _afcca [_fbaa ]=='\n'{_fbaa ++;};}else if _afcca [_fbaa ]=='\n'{_fbaa ++;}else {_dgbg ._gbgad ._cgd =true ;};};_dgbg ._bdg .Discard (_fbaa );_gbda ,_adbc :=_bgffg .PdfObject .(*PdfObjectDictionary );
if !_adbc {return nil ,_g .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006di\u0073s\u0069\u006e\u0067\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_fdf .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0069c\u0074\u0020\u0025\u0073",_gbda );
_gdfa ,_adaag :=_dgbg .traceStreamLength (_gbda .Get ("\u004c\u0065\u006e\u0067\u0074\u0068"));if _adaag !=nil {_fdf .Log .Debug ("\u0046\u0061\u0069l\u0020\u0074\u006f\u0020t\u0072\u0061\u0063\u0065\u0020\u0073\u0074r\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0025\u0076",_adaag );
return nil ,_adaag ;};_fdf .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_gdfa );_efccb ,_edeb :=_gdfa .(*PdfObjectInteger );if !_edeb {return nil ,_g .New ("\u0073\u0074re\u0061\u006d\u0020l\u0065\u006e\u0067\u0074h n\u0065ed\u0073\u0020\u0074\u006f\u0020\u0062\u0065 a\u006e\u0020\u0069\u006e\u0074\u0065\u0067e\u0072");
};_ccb :=*_efccb ;if _ccb < 0{return nil ,_g .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006e\u0065\u0065\u0064\u0073\u0020\u0074\u006f \u0062e\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0030");};_defg :=_dgbg .GetFileOffset ();
_ddee :=_dgbg .xrefNextObjectOffset (_defg );if _defg +int64 (_ccb )> _ddee &&_ddee > _defg {_fdf .Log .Debug ("E\u0078\u0070\u0065\u0063te\u0064 \u0065\u006e\u0064\u0069\u006eg\u0020\u0061\u0074\u0020\u0025\u0064",_defg +int64 (_ccb ));_fdf .Log .Debug ("\u004e\u0065\u0078\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020\u0061t\u0020\u0025\u0064",_ddee );
_fagb :=_ddee -_defg -17;if _fagb < 0{return nil ,_g .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020go\u0069\u006e\u0067 \u0070\u0061s\u0074\u0020\u0062\u006f\u0075\u006ed\u0061\u0072i\u0065\u0073");
};_fdf .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0061\u0020l\u0065\u006e\u0067\u0074\u0068\u0020c\u006f\u0072\u0072\u0065\u0063\u0074\u0069\u006f\u006e\u0020\u0074\u006f\u0020%\u0064\u002e\u002e\u002e",_fagb );_ccb =PdfObjectInteger (_fagb );
_gbda .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (_fagb ));};if int64 (_ccb )> _dgbg ._eaade {_fdf .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0053t\u0072\u0065\u0061\u006d\u0020l\u0065\u006e\u0067\u0074\u0068\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u0061\u0072\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0066\u0069\u006c\u0065\u0020\u0073\u0069\u007a\u0065");
return nil ,_g .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020la\u0072\u0067\u0065r\u0020\u0074h\u0061\u006e\u0020\u0066\u0069\u006ce\u0020\u0073i\u007a\u0065");};_cgcf :=make ([]byte ,_ccb );
_ ,_adaag =_dgbg .ReadAtLeast (_cgcf ,int (_ccb ));if _adaag !=nil {_fdf .Log .Debug ("E\u0052\u0052\u004f\u0052 s\u0074r\u0065\u0061\u006d\u0020\u0028%\u0064\u0029\u003a\u0020\u0025\u0058",len (_cgcf ),_cgcf );_fdf .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_adaag );
return nil ,_adaag ;};_ebag :=PdfObjectStream {};_ebag .Stream =_cgcf ;_ebag .PdfObjectDictionary =_bgffg .PdfObject .(*PdfObjectDictionary );_ebag .ObjectNumber =_bgffg .ObjectNumber ;_ebag .GenerationNumber =_bgffg .GenerationNumber ;_ebag .PdfObjectReference ._aagbc =_dgbg ;
_dgbg .skipSpaces ();_dgbg ._bdg .Discard (9);_dgbg .skipSpaces ();return &_ebag ,nil ;};};_bgffg .PdfObject ,_aaaf =_dgbg .parseObject ();if _bgffg .PdfObject ==nil {_fdf .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");
_bgffg .PdfObject =MakeNull ();};return &_bgffg ,_aaaf ;};};if _bgffg .PdfObject ==nil {_fdf .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");
_bgffg .PdfObject =MakeNull ();};_fdf .Log .Trace ("\u0052\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0021");return &_bgffg ,nil ;};

// Keys returns the list of keys in the dictionary.
// If `d` is nil returns a nil slice.
func (_dadff *PdfObjectDictionary )Keys ()[]PdfObjectName {if _dadff ==nil {return nil ;};return _dadff ._fgag ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_ebdf *JPXEncoder )MakeDecodeParams ()PdfObject {return nil };

// HasEOLAfterHeader gets information if there is a EOL after the version header.
func (_ebd ParserMetadata )HasEOLAfterHeader ()bool {return _ebd ._adf };func (_dbcg *PdfParser )parseLinearizedDictionary ()(*PdfObjectDictionary ,error ){_bgedc ,_agcg :=_dbcg ._dddg .Seek (0,_ef .SeekEnd );if _agcg !=nil {return nil ,_agcg ;};var _bggf int64 ;
var _edeg int64 =2048;for _bggf < _bgedc -4{if _bgedc <=(_edeg +_bggf ){_edeg =_bgedc -_bggf ;};_ ,_cefd :=_dbcg ._dddg .Seek (_bggf ,_ef .SeekStart );if _cefd !=nil {return nil ,_cefd ;};_bfbc :=make ([]byte ,_edeg );_ ,_cefd =_dbcg ._dddg .Read (_bfbc );
if _cefd !=nil {return nil ,_cefd ;};_fdf .Log .Trace ("\u004c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0066i\u0072\u0073\u0074\u0020\u0069\u006ed\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u003a \u0022\u0025\u0073\u0022",string (_bfbc ));
_aedac :=_agda .FindAllStringIndex (string (_bfbc ),-1);if _aedac !=nil {_dfad :=_aedac [0];_fdf .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_aedac );_ ,_accfb :=_dbcg ._dddg .Seek (int64 (_dfad [0]),_ef .SeekStart );if _accfb !=nil {return nil ,_accfb ;
};_dbcg ._bdg =_faf .NewReader (_dbcg ._dddg );_deed ,_accfb :=_dbcg .ParseIndirectObject ();if _accfb !=nil {return nil ,nil ;};if _agcb ,_dgcc :=GetIndirect (_deed );_dgcc {if _fgcb ,_dafff :=GetDict (_agcb .PdfObject );_dafff {if _bbda :=_fgcb .Get ("\u004c\u0069\u006e\u0065\u0061\u0072\u0069\u007a\u0065\u0064");
_bbda !=nil {return _fgcb ,nil ;};return nil ,nil ;};};return nil ,nil ;};_bggf +=_edeg -4;};return nil ,_g .New ("\u0074\u0068\u0065\u0020\u0066\u0069\u0072\u0073\u0074\u0020\u006fb\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0066o\u0075\u006e\u0064");
};

// GetAccessPermissions returns the PDF access permissions as an AccessPermissions object.
func (_ccc *PdfCrypt )GetAccessPermissions ()_gdb .Permissions {return _ccc ._edf .P };

// MakeFloat creates an PdfObjectFloat from a float64.
func MakeFloat (val float64 )*PdfObjectFloat {_dfecd :=PdfObjectFloat (val );return &_dfecd };

// RegisterCustomStreamEncoder register a custom encoder handler for certain filter.
func RegisterCustomStreamEncoder (filterName string ,customStreamEncoder StreamEncoder ){_baegb .Store (filterName ,customStreamEncoder );};

// SetIfNotNil sets the dictionary's key -> val mapping entry -IF- val is not nil.
// Note that we take care to perform a type switch.  Otherwise if we would supply a nil value
// of another type, e.g. (PdfObjectArray*)(nil), then it would not be a PdfObject(nil) and thus
// would get set.
func (_cedc *PdfObjectDictionary )SetIfNotNil (key PdfObjectName ,val PdfObject ){if val !=nil {switch _faga :=val .(type ){case *PdfObjectName :if _faga !=nil {_cedc .Set (key ,val );};case *PdfObjectDictionary :if _faga !=nil {_cedc .Set (key ,val );
};case *PdfObjectStream :if _faga !=nil {_cedc .Set (key ,val );};case *PdfObjectString :if _faga !=nil {_cedc .Set (key ,val );};case *PdfObjectNull :if _faga !=nil {_cedc .Set (key ,val );};case *PdfObjectInteger :if _faga !=nil {_cedc .Set (key ,val );
};case *PdfObjectArray :if _faga !=nil {_cedc .Set (key ,val );};case *PdfObjectBool :if _faga !=nil {_cedc .Set (key ,val );};case *PdfObjectFloat :if _faga !=nil {_cedc .Set (key ,val );};case *PdfObjectReference :if _faga !=nil {_cedc .Set (key ,val );
};case *PdfIndirectObject :if _faga !=nil {_cedc .Set (key ,val );};default:_fdf .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",val );
};};};const (DefaultJPEGQuality =75;);

// Merge merges in key/values from another dictionary. Overwriting if has same keys.
// The mutated dictionary (d) is returned in order to allow method chaining.
func (_ecd *PdfObjectDictionary )Merge (another *PdfObjectDictionary )*PdfObjectDictionary {if another !=nil {for _ ,_febb :=range another .Keys (){_agcbb :=another .Get (_febb );_ecd .Set (_febb ,_agcbb );};};return _ecd ;};

// SetPredictor sets the predictor function.  Specify the number of columns per row.
// The columns indicates the number of samples per row.
// Used for grouping data together for compression.
func (_fada *FlateEncoder )SetPredictor (columns int ){_fada .Predictor =11;_fada .Columns =columns };

// Elements returns a slice of the PdfObject elements in the array.
// Preferred over accessing the array directly as type may be changed in future major versions (v3).
func (_ccff *PdfObjectStreams )Elements ()[]PdfObject {if _ccff ==nil {return nil ;};return _ccff ._adad ;};func (_gbfd *PdfParser )checkPostEOFData ()error {const _eabf ="\u0025\u0025\u0045O\u0046";_ ,_bgd :=_gbfd ._dddg .Seek (-int64 (len ([]byte (_eabf )))-1,_ef .SeekEnd );
if _bgd !=nil {return _bgd ;};_gdf :=make ([]byte ,len ([]byte (_eabf ))+1);_ ,_bgd =_gbfd ._dddg .Read (_gdf );if _bgd !=nil {if _bgd !=_ef .EOF {return _bgd ;};};if string (_gdf )==_eabf ||string (_gdf )==_eabf +"\u000a"{_gbfd ._gbgad ._ggf =true ;};
return nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_fgaa *MultiEncoder )MakeStreamDict ()*PdfObjectDictionary {_dggb :=MakeDict ();_dggb .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",_fgaa .GetFilterArray ());for _ ,_baagg :=range _fgaa ._cbab {_ffgf :=_baagg .MakeStreamDict ();for _ ,_bgfe :=range _ffgf .Keys (){_ebeg :=_ffgf .Get (_bgfe );
if _bgfe !="\u0046\u0069\u006c\u0074\u0065\u0072"&&_bgfe !="D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"{_dggb .Set (_bgfe ,_ebeg );};};};_bcacg :=_fgaa .MakeDecodeParams ();if _bcacg !=nil {_dggb .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_bcacg );
};return _dggb ;};func (_gedge *PdfParser )getNumbersOfUpdatedObjects (_gdacb *PdfParser )([]int ,error ){if _gdacb ==nil {return nil ,_g .New ("\u0070\u0072e\u0076\u0069\u006f\u0075\u0073\u0020\u0070\u0061\u0072\u0073\u0065\u0072\u0020\u0063\u0061\u006e\u0027\u0074\u0020\u0062\u0065\u0020nu\u006c\u006c");
};_bbca :=_gdacb ._eaade ;_cdcbe :=make ([]int ,0);_aggc :=make (map[int ]interface{});_baegf :=make (map[int ]int64 );for _agfdb ,_bgae :=range _gedge ._agec .ObjectMap {if _bgae .Offset ==0{if _bgae .OsObjNumber !=0{if _fbdgd ,_cacca :=_gedge ._agec .ObjectMap [_bgae .OsObjNumber ];
_cacca {_aggc [_bgae .OsObjNumber ]=struct{}{};_baegf [_agfdb ]=_fbdgd .Offset ;}else {return nil ,_g .New ("u\u006ed\u0065\u0066\u0069\u006e\u0065\u0064\u0020\u0078r\u0065\u0066\u0020\u0074ab\u006c\u0065");};};}else {_baegf [_agfdb ]=_bgae .Offset ;};
};for _bdca ,_aeda :=range _baegf {if _ ,_caegg :=_aggc [_bdca ];_caegg {continue ;};if _aeda > _bbca {_cdcbe =append (_cdcbe ,_bdca );};};return _cdcbe ,nil ;};

// Len returns the number of elements in the streams.
func (_dgad *PdfObjectStreams )Len ()int {if _dgad ==nil {return 0;};return len (_dgad ._adad );};

// GetFilterName returns the name of the encoding filter.
func (_cbd *FlateEncoder )GetFilterName ()string {return StreamEncodingFilterNameFlate };func _fgbc (_aabcf PdfObject ,_bdege int )PdfObject {if _bdege > _efade {_fdf .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_efade );
return MakeNull ();};switch _bdcc :=_aabcf .(type ){case *PdfIndirectObject :_aabcf =_fgbc ((*_bdcc ).PdfObject ,_bdege +1);case *PdfObjectArray :for _gecea ,_dfcd :=range (*_bdcc )._fadaed {(*_bdcc )._fadaed [_gecea ]=_fgbc (_dfcd ,_bdege +1);};case *PdfObjectDictionary :for _dcea ,_baafd :=range (*_bdcc )._acfc {(*_bdcc )._acfc [_dcea ]=_fgbc (_baafd ,_bdege +1);
};_c .Slice ((*_bdcc )._fgag ,func (_bbbfa ,_ffaac int )bool {return (*_bdcc )._fgag [_bbbfa ]< (*_bdcc )._fgag [_ffaac ]});};return _aabcf ;};

// WriteString outputs the object as it is to be written to file.
func (_fcge *PdfObjectInteger )WriteString ()string {return _bb .FormatInt (int64 (*_fcge ),10)};

// MakeIndirectObject creates an PdfIndirectObject with a specified direct object PdfObject.
func MakeIndirectObject (obj PdfObject )*PdfIndirectObject {_ggcbb :=&PdfIndirectObject {};_ggcbb .PdfObject =obj ;return _ggcbb ;};

// EncodeStream encodes the stream data using the encoded specified by the stream's dictionary.
func EncodeStream (streamObj *PdfObjectStream )error {_fdf .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_gedgg ,_cffd :=NewEncoderFromStream (streamObj );if _cffd !=nil {_fdf .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_cffd );
return _cffd ;};if _bgafb ,_egge :=_gedgg .(*LZWEncoder );_egge {_bgafb .EarlyChange =0;streamObj .PdfObjectDictionary .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (0));};_fdf .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076\u000a",_gedgg );
_ggcf ,_cffd :=_gedgg .EncodeBytes (streamObj .Stream );if _cffd !=nil {_fdf .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_cffd );return _cffd ;
};streamObj .Stream =_ggcf ;streamObj .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_ggcf ))));return nil ;};func (_efgc *PdfParser )rebuildXrefTable ()error {_fgfe :=XrefTable {};_fgfe .ObjectMap =map[int ]XrefObject {};
_bcdd :=make ([]int ,0,len (_efgc ._agec .ObjectMap ));for _babd :=range _efgc ._agec .ObjectMap {_bcdd =append (_bcdd ,_babd );};_c .Ints (_bcdd );for _ ,_cfea :=range _bcdd {_adfed :=_efgc ._agec .ObjectMap [_cfea ];_cgeg ,_ ,_eacd :=_efgc .lookupByNumberWrapper (_cfea ,false );
if _eacd !=nil {_fdf .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020U\u006e\u0061\u0062\u006ce t\u006f l\u006f\u006f\u006b\u0020\u0075\u0070\u0020ob\u006a\u0065\u0063\u0074\u0020\u0028\u0025s\u0029",_eacd );_fdf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0063\u006fm\u0070\u006c\u0065\u0074\u0065\u006c\u0079\u0020\u0062\u0072\u006f\u006b\u0065\u006e\u0020\u002d\u0020\u0061\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0074\u006f \u0072\u0065\u0070\u0061\u0069r\u0020");
_acddf ,_abad :=_efgc .repairRebuildXrefsTopDown ();if _abad !=nil {_fdf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0072\u0065\u0062\u0075\u0069l\u0064\u0020\u0072\u0065\u0070a\u0069\u0072 \u0028\u0025\u0073\u0029",_abad );
return _abad ;};_efgc ._agec =*_acddf ;_fdf .Log .Debug ("\u0052e\u0070\u0061\u0069\u0072e\u0064\u0020\u0078\u0072\u0065f\u0020t\u0061b\u006c\u0065\u0020\u0062\u0075\u0069\u006ct");return nil ;};_eccd ,_gfbgb ,_eacd :=_fb (_cgeg );if _eacd !=nil {return _eacd ;
};_adfed .ObjectNumber =int (_eccd );_adfed .Generation =int (_gfbgb );_fgfe .ObjectMap [int (_eccd )]=_adfed ;};_efgc ._agec =_fgfe ;_fdf .Log .Debug ("N\u0065w\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061b\u006c\u0065\u0020\u0062ui\u006c\u0074");_fdff (_efgc ._agec );
return nil ;};

// ReadAtLeast reads at least n bytes into slice p.
// Returns the number of bytes read (should always be == n), and an error on failure.
func (_aegb *PdfParser )ReadAtLeast (p []byte ,n int )(int ,error ){_bccg :=n ;_dgab :=0;_daga :=0;for _bccg > 0{_fefd ,_bgea :=_aegb ._bdg .Read (p [_dgab :]);if _bgea !=nil {_fdf .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061d\u0069\u006e\u0067\u0020\u0028\u0025\u0064\u003b\u0025\u0064\u0029\u0020\u0025\u0073",_fefd ,_daga ,_bgea .Error ());
return _dgab ,_g .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065a\u0064\u0069\u006e\u0067");};_daga ++;_dgab +=_fefd ;_bccg -=_fefd ;};return _dgab ,nil ;};func (_ceff *PdfParser )parseString ()(*PdfObjectString ,error ){_ceff ._bdg .ReadByte ();
var _dcaa _fda .Buffer ;_fbgag :=1;for {_gcea ,_dgafa :=_ceff ._bdg .Peek (1);if _dgafa !=nil {return MakeString (_dcaa .String ()),_dgafa ;};if _gcea [0]=='\\'{_ceff ._bdg .ReadByte ();_dede ,_fgdb :=_ceff ._bdg .ReadByte ();if _fgdb !=nil {return MakeString (_dcaa .String ()),_fgdb ;
};if IsOctalDigit (_dede ){_cdcb ,_afdfg :=_ceff ._bdg .Peek (2);if _afdfg !=nil {return MakeString (_dcaa .String ()),_afdfg ;};var _bbcc []byte ;_bbcc =append (_bbcc ,_dede );for _ ,_cdgb :=range _cdcb {if IsOctalDigit (_cdgb ){_bbcc =append (_bbcc ,_cdgb );
}else {break ;};};_ceff ._bdg .Discard (len (_bbcc )-1);_fdf .Log .Trace ("\u004e\u0075\u006d\u0065ri\u0063\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0022\u0025\u0073\u0022",_bbcc );_gaba ,_afdfg :=_bb .ParseUint (string (_bbcc ),8,32);if _afdfg !=nil {return MakeString (_dcaa .String ()),_afdfg ;
};_dcaa .WriteByte (byte (_gaba ));continue ;};switch _dede {case 'n':_dcaa .WriteRune ('\n');case 'r':_dcaa .WriteRune ('\r');case 't':_dcaa .WriteRune ('\t');case 'b':_dcaa .WriteRune ('\b');case 'f':_dcaa .WriteRune ('\f');case '(':_dcaa .WriteRune ('(');
case ')':_dcaa .WriteRune (')');case '\\':_dcaa .WriteRune ('\\');};continue ;}else if _gcea [0]=='('{_fbgag ++;}else if _gcea [0]==')'{_fbgag --;if _fbgag ==0{_ceff ._bdg .ReadByte ();break ;};};_bfgg ,_ :=_ceff ._bdg .ReadByte ();_dcaa .WriteByte (_bfgg );
};return MakeString (_dcaa .String ()),nil ;};

// String returns a string representation of `name`.
func (_cefb *PdfObjectName )String ()string {return string (*_cefb )};var _faca =_ge .MustCompile ("\u005e\u005b\\\u002b\u002d\u002e\u005d*\u0028\u005b0\u002d\u0039\u002e\u005d\u002b\u0029\u005b\u0065E\u005d\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");


// ResolveReference resolves reference if `o` is a *PdfObjectReference and returns the object referenced to.
// Otherwise returns back `o`.
func ResolveReference (obj PdfObject )PdfObject {if _bcbc ,_dffb :=obj .(*PdfObjectReference );_dffb {return _bcbc .Resolve ();};return obj ;};

// GetPreviousRevisionReadSeeker returns ReadSeeker for the previous version of the Pdf document.
func (_ceeb *PdfParser )GetPreviousRevisionReadSeeker ()(_ef .ReadSeeker ,error ){if _fdafd :=_ceeb .seekToEOFMarker (_ceeb ._eaade -_eaacb );_fdafd !=nil {return nil ,_fdafd ;};_dafc ,_efae :=_ceeb ._dddg .Seek (0,_ef .SeekCurrent );if _efae !=nil {return nil ,_efae ;
};_dafc +=_eaacb ;return _eaac (_ceeb ._dddg ,_dafc );};

// DCTEncoder provides a DCT (JPG) encoding/decoding functionality for images.
type DCTEncoder struct{ColorComponents int ;BitsPerComponent int ;Width int ;Height int ;Quality int ;};type cryptFilters map[string ]_fg .Filter ;

// MakeDict creates and returns an empty PdfObjectDictionary.
func MakeDict ()*PdfObjectDictionary {_eacb :=&PdfObjectDictionary {};_eacb ._acfc =map[PdfObjectName ]PdfObject {};_eacb ._fgag =[]PdfObjectName {};_eacb ._bebfa =&_a .Mutex {};return _eacb ;};

// SetImage sets the image base for given flate encoder.
func (_fbe *FlateEncoder )SetImage (img *_gg .ImageBase ){_fbe ._fgb =img };func (_afga *PdfObjectInteger )String ()string {return _ae .Sprintf ("\u0025\u0064",*_afga )};

// String returns a string describing `null`.
func (_beabe *PdfObjectNull )String ()string {return "\u006e\u0075\u006c\u006c"};

// FlateEncoder represents Flate encoding.
type FlateEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Rows int ;Colors int ;_fgb *_gg .ImageBase ;};var _cga =_ge .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064\u002b)\u005c\u0073\u002a\u0024");

// PdfObjectName represents the primitive PDF name object.
type PdfObjectName string ;

// GetEncryptObj returns the PdfIndirectObject which has information about the PDFs encryption details.
func (_cce *PdfParser )GetEncryptObj ()*PdfIndirectObject {return _cce ._fadg };

// FlattenObject returns the contents of `obj`. In other words, `obj` with indirect objects replaced
// by their values.
// The replacements are made recursively to a depth of traceMaxDepth.
// NOTE: Dicts are sorted to make objects with same contents have the same PDF object strings.
func FlattenObject (obj PdfObject )PdfObject {return _fgbc (obj ,0)};

// MakeString creates an PdfObjectString from a string.
// NOTE: PDF does not use utf-8 string encoding like Go so `s` will often not be a utf-8 encoded
// string.
func MakeString (s string )*PdfObjectString {_dfeff :=PdfObjectString {_fea :s };return &_dfeff };

// HasInvalidSubsectionHeader implements core.ParserMetadata interface.
func (_gcddf ParserMetadata )HasInvalidSubsectionHeader ()bool {return _gcddf ._cff };func (_fece *PdfParser )parseDetailedHeader ()(_fdgd error ){_fece ._dddg .Seek (0,_ef .SeekStart );_fece ._bdg =_faf .NewReader (_fece ._dddg );_cdab :=20;_bdec :=make ([]byte ,_cdab );
var (_eedf bool ;_bag int ;);for {_dgb ,_fdaa :=_fece ._bdg .ReadByte ();if _fdaa !=nil {if _fdaa ==_ef .EOF {break ;}else {return _fdaa ;};};if IsDecimalDigit (_dgb )&&_bdec [_cdab -1]=='.'&&IsDecimalDigit (_bdec [_cdab -2])&&_bdec [_cdab -3]=='-'&&_bdec [_cdab -4]=='F'&&_bdec [_cdab -5]=='D'&&_bdec [_cdab -6]=='P'&&_bdec [_cdab -7]=='%'{_fece ._dfgf =Version {Major :int (_bdec [_cdab -2]-'0'),Minor :int (_dgb -'0')};
_fece ._gbgad ._gaee =_bag -7;_eedf =true ;break ;};_bag ++;_bdec =append (_bdec [1:_cdab ],_dgb );};if !_eedf {return _ae .Errorf ("n\u006f \u0066\u0069\u006c\u0065\u0020\u0068\u0065\u0061d\u0065\u0072\u0020\u0066ou\u006e\u0064");};_gefa ,_fdgd :=_fece ._bdg .ReadByte ();
if _fdgd ==_ef .EOF {return _ae .Errorf ("\u006eo\u0074\u0020\u0061\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0050d\u0066\u0020\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074");};if _fdgd !=nil {return _fdgd ;};_fece ._gbgad ._adf =_gefa =='\n';_gefa ,_fdgd =_fece ._bdg .ReadByte ();
if _fdgd !=nil {return _ae .Errorf ("\u006e\u006f\u0074\u0020a\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0070\u0064\u0066 \u0064o\u0063\u0075\u006d\u0065\u006e\u0074\u003a \u0025\u0077",_fdgd );};if _gefa !='%'{return nil ;};_fafc :=make ([]byte ,4);_ ,_fdgd =_fece ._bdg .Read (_fafc );
if _fdgd !=nil {return _ae .Errorf ("\u006e\u006f\u0074\u0020a\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0070\u0064\u0066 \u0064o\u0063\u0075\u006d\u0065\u006e\u0074\u003a \u0025\u0077",_fdgd );};_fece ._gbgad ._cacd =[4]byte {_fafc [0],_fafc [1],_fafc [2],_fafc [3]};
return nil ;};const (StreamEncodingFilterNameFlate ="F\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameLZW ="\u004cZ\u0057\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameDCT ="\u0044C\u0054\u0044\u0065\u0063\u006f\u0064e";
StreamEncodingFilterNameRunLength ="\u0052u\u006eL\u0065\u006e\u0067\u0074\u0068\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameASCIIHex ="\u0041\u0053\u0043\u0049\u0049\u0048\u0065\u0078\u0044e\u0063\u006f\u0064\u0065";StreamEncodingFilterNameASCII85 ="\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0044\u0065\u0063\u006f\u0064\u0065";
StreamEncodingFilterNameCCITTFax ="\u0043\u0043\u0049\u0054\u0054\u0046\u0061\u0078\u0044e\u0063\u006f\u0064\u0065";StreamEncodingFilterNameJBIG2 ="J\u0042\u0049\u0047\u0032\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameJPX ="\u004aP\u0058\u0044\u0065\u0063\u006f\u0064e";
StreamEncodingFilterNameRaw ="\u0052\u0061\u0077";);func (_bffd *PdfParser )checkLinearizedInformation (_fbab *PdfObjectDictionary )(bool ,error ){var _fdbb error ;_bffd ._ecbd ,_fdbb =GetNumberAsInt64 (_fbab .Get ("\u004c"));if _fdbb !=nil {return false ,_fdbb ;
};_fdbb =_bffd .seekToEOFMarker (_bffd ._ecbd );switch _fdbb {case nil :return true ,nil ;case _edec :return false ,nil ;default:return false ,_fdbb ;};};

// Clear resets the dictionary to an empty state.
func (_acfga *PdfObjectDictionary )Clear (){_acfga ._fgag =[]PdfObjectName {};_acfga ._acfc =map[PdfObjectName ]PdfObject {};_acfga ._bebfa =&_a .Mutex {};};func _geffb ()string {return _fdf .Version };

// Encrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_fab *PdfCrypt )Encrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _fab .isEncrypted (obj ){return nil ;};switch _fdaf :=obj .(type ){case *PdfIndirectObject :_fab ._fcad [_fdaf ]=true ;_fdf .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_fdaf .ObjectNumber ,_fdaf .GenerationNumber );
_gda :=_fdaf .ObjectNumber ;_fcca :=_fdaf .GenerationNumber ;_fbd :=_fab .Encrypt (_fdaf .PdfObject ,_gda ,_fcca );if _fbd !=nil {return _fbd ;};return nil ;case *PdfObjectStream :_fab ._fcad [_fdaf ]=true ;_fcada :=_fdaf .PdfObjectDictionary ;if _dag ,_cfa :=_fcada .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );
_cfa &&*_dag =="\u0058\u0052\u0065\u0066"{return nil ;};_dfd :=_fdaf .ObjectNumber ;_bgaf :=_fdaf .GenerationNumber ;_fdf .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_dfd ,_bgaf );
_gcdf :=_egf ;if _fab ._cca .V >=4{_gcdf =_fab ._ba ;_fdf .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_fab ._ba );if _gae ,_dcgd :=_fcada .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );
_dcgd {if _cbeb ,_adcd :=GetName (_gae .Get (0));_adcd {if *_cbeb =="\u0043\u0072\u0079p\u0074"{_gcdf ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _agb ,_edgd :=_fcada .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );
_edgd {if _cfd ,_gdcc :=_agb .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_gdcc {if _ ,_fccag :=_fab ._fag [string (*_cfd )];_fccag {_fdf .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_cfd );
_gcdf =string (*_cfd );};};};};};};_fdf .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_gcdf );if _gcdf =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_baf :=_fab .Encrypt (_fdaf .PdfObjectDictionary ,_dfd ,_bgaf );
if _baf !=nil {return _baf ;};_gbb ,_baf :=_fab .makeKey (_gcdf ,uint32 (_dfd ),uint32 (_bgaf ),_fab ._ffbf );if _baf !=nil {return _baf ;};_fdaf .Stream ,_baf =_fab .encryptBytes (_fdaf .Stream ,_gcdf ,_gbb );if _baf !=nil {return _baf ;};_fcada .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_fdaf .Stream ))));
return nil ;case *PdfObjectString :_fdf .Log .Trace ("\u0045n\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_bdf :=_egf ;if _fab ._cca .V >=4{_fdf .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_fab ._cb );
if _fab ._cb =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_bdf =_fab ._cb ;};_gdbc ,_daef :=_fab .makeKey (_bdf ,uint32 (parentObjNum ),uint32 (parentGenNum ),_fab ._ffbf );if _daef !=nil {return _daef ;};_baag :=_fdaf .Str ();_dfe :=make ([]byte ,len (_baag ));
for _gdcb :=0;_gdcb < len (_baag );_gdcb ++{_dfe [_gdcb ]=_baag [_gdcb ];};_fdf .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_dfe ,_dfe );_dfe ,_daef =_fab .encryptBytes (_dfe ,_bdf ,_gdbc );
if _daef !=nil {return _daef ;};_fdaf ._fea =string (_dfe );return nil ;case *PdfObjectArray :for _ ,_gge :=range _fdaf .Elements (){_aace :=_fab .Encrypt (_gge ,parentObjNum ,parentGenNum );if _aace !=nil {return _aace ;};};return nil ;case *PdfObjectDictionary :_ccaf :=false ;
if _aebd :=_fdaf .Get ("\u0054\u0079\u0070\u0065");_aebd !=nil {_dfa ,_fefa :=_aebd .(*PdfObjectName );if _fefa &&*_dfa =="\u0053\u0069\u0067"{_ccaf =true ;};};for _ ,_abf :=range _fdaf .Keys (){_gbga :=_fdaf .Get (_abf );if _ccaf &&string (_abf )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;
};if string (_abf )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_abf )!="\u0050\u0072\u0065\u0076"&&string (_abf )!="\u004c\u0061\u0073\u0074"{_acdg :=_fab .Encrypt (_gbga ,parentObjNum ,parentGenNum );if _acdg !=nil {return _acdg ;};};};return nil ;
};return nil ;};func (_aceab *PdfParser )parseNumber ()(PdfObject ,error ){return ParseNumber (_aceab ._bdg )};

// GoImageToJBIG2 creates a binary image on the base of 'i' golang image.Image.
// If the image is not a black/white image then the function converts provided input into
// JBIG2Image with 1bpp. For non grayscale images the function performs the conversion to the grayscale temp image.
// Then it checks the value of the gray image value if it's within bounds of the black white threshold.
// This 'bwThreshold' value should be in range (0.0, 1.0). The threshold checks if the grayscale pixel (uint) value
// is greater or smaller than 'bwThreshold' * 255. Pixels inside the range will be white, and the others will be black.
// If the 'bwThreshold' is equal to -1.0 - JB2ImageAutoThreshold then it's value would be set on the base of
// it's histogram using Triangle method. For more information go to:
// 	https://www.mathworks.com/matlabcentral/fileexchange/28047-gray-image-thresholding-using-the-triangle-method
func GoImageToJBIG2 (i _bd .Image ,bwThreshold float64 )(*JBIG2Image ,error ){const _becb ="\u0047\u006f\u0049\u006d\u0061\u0067\u0065\u0054\u006fJ\u0042\u0049\u0047\u0032";if i ==nil {return nil ,_cd .Error (_becb ,"i\u006d\u0061\u0067\u0065 '\u0069'\u0020\u006e\u006f\u0074\u0020d\u0065\u0066\u0069\u006e\u0065\u0064");
};var (_fegg uint8 ;_edb _gg .Image ;_adga error ;);if bwThreshold ==JB2ImageAutoThreshold {_edb ,_adga =_gg .MonochromeConverter .Convert (i );}else if bwThreshold > 1.0||bwThreshold < 0.0{return nil ,_cd .Error (_becb ,"p\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074h\u0072\u0065\u0073\u0068\u006f\u006c\u0064 i\u0073\u0020\u006e\u006ft\u0020\u0069\u006e\u0020\u0061\u0020\u0072\u0061\u006ege\u0020\u007b0\u002e\u0030\u002c\u0020\u0031\u002e\u0030\u007d");
}else {_fegg =uint8 (255*bwThreshold );_edb ,_adga =_gg .MonochromeThresholdConverter (_fegg ).Convert (i );};if _adga !=nil {return nil ,_adga ;};return _eaaf (_edb ),nil ;};

// NewParserFromString is used for testing purposes.
func NewParserFromString (txt string )*PdfParser {_dafdc :=_fda .NewReader ([]byte (txt ));_agagf :=&PdfParser {ObjCache :objectCache {},_dddg :_dafdc ,_bdg :_faf .NewReader (_dafdc ),_eaade :int64 (len (txt )),_fbed :map[int64 ]bool {},_fcfb :make (map[*PdfParser ]*PdfParser )};
_agagf ._agec .ObjectMap =make (map[int ]XrefObject );return _agagf ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_geaf *RunLengthEncoder )MakeDecodeParams ()PdfObject {return nil };func (_gcfa *PdfParser )xrefNextObjectOffset (_ebdc int64 )int64 {_cgba :=int64 (0);if len (_gcfa ._agec .ObjectMap )==0{return 0;};if len (_gcfa ._agec ._ca )==0{_ecebd :=0;for _ ,_gagag :=range _gcfa ._agec .ObjectMap {if _gagag .Offset > 0{_ecebd ++;
};};if _ecebd ==0{return 0;};_gcfa ._agec ._ca =make ([]XrefObject ,_ecebd );_baagc :=0;for _ ,_feega :=range _gcfa ._agec .ObjectMap {if _feega .Offset > 0{_gcfa ._agec ._ca [_baagc ]=_feega ;_baagc ++;};};_c .Slice (_gcfa ._agec ._ca ,func (_bfef ,_dbcc int )bool {return _gcfa ._agec ._ca [_bfef ].Offset < _gcfa ._agec ._ca [_dbcc ].Offset });
};_bdcec :=_c .Search (len (_gcfa ._agec ._ca ),func (_cecb int )bool {return _gcfa ._agec ._ca [_cecb ].Offset >=_ebdc });if _bdcec < len (_gcfa ._agec ._ca ){_cgba =_gcfa ._agec ._ca [_bdcec ].Offset ;};return _cgba ;};type xrefType int ;

// GetNumberAsFloat returns the contents of `obj` as a float if it is an integer or float, or an
// error if it isn't.
func GetNumberAsFloat (obj PdfObject )(float64 ,error ){switch _gcfg :=obj .(type ){case *PdfObjectFloat :return float64 (*_gcfg ),nil ;case *PdfObjectInteger :return float64 (*_gcfg ),nil ;};return 0,ErrNotANumber ;};

// UpdateParams updates the parameter values of the encoder.
func (_aaba *JPXEncoder )UpdateParams (params *PdfObjectDictionary ){};

// HasInvalidSeparationAfterXRef implements core.ParserMetadata interface.
func (_fefaf ParserMetadata )HasInvalidSeparationAfterXRef ()bool {return _fefaf ._gcdd };func _eaac (_eeca _ef .ReadSeeker ,_dfbf int64 )(*limitedReadSeeker ,error ){_ ,_cbec :=_eeca .Seek (0,_ef .SeekStart );if _cbec !=nil {return nil ,_cbec ;};return &limitedReadSeeker {_aee :_eeca ,_ddg :_dfbf },nil ;
};

// String returns the state of the bool as "true" or "false".
func (_ceaf *PdfObjectBool )String ()string {if *_ceaf {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};type limitedReadSeeker struct{_aee _ef .ReadSeeker ;_ddg int64 ;};

// XrefTable represents the cross references in a PDF, i.e. the table of objects and information
// where to access within the PDF file.
type XrefTable struct{ObjectMap map[int ]XrefObject ;_ca []XrefObject ;};func (_cebg *PdfCrypt )newEncryptDict ()*PdfObjectDictionary {_edad :=MakeDict ();_edad .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName ("\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"));
_edad .Set ("\u0056",MakeInteger (int64 (_cebg ._cca .V )));_edad .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_cebg ._cca .Length )));return _edad ;};func (_baff *limitedReadSeeker )getError (_gafd int64 )error {switch {case _gafd < 0:return _ae .Errorf ("\u0075\u006e\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064 \u006e\u0065\u0067\u0061\u0074\u0069\u0076e\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u003a\u0020\u0025\u0064",_gafd );
case _gafd > _baff ._ddg :return _ae .Errorf ("u\u006e\u0065\u0078\u0070ec\u0074e\u0064\u0020\u006f\u0066\u0066s\u0065\u0074\u003a\u0020\u0025\u0064",_gafd );};return nil ;};const JB2ImageAutoThreshold =-1.0;

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_ffg *FlateEncoder )MakeDecodeParams ()PdfObject {if _ffg .Predictor > 1{_cdcg :=MakeDict ();_cdcg .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_ffg .Predictor )));if _ffg .BitsPerComponent !=8{_cdcg .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_ffg .BitsPerComponent )));
};if _ffg .Columns !=1{_cdcg .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_ffg .Columns )));};if _ffg .Colors !=1{_cdcg .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_ffg .Colors )));};return _cdcg ;};return nil ;
};

// WriteString outputs the object as it is to be written to file.
func (_adgb *PdfObjectFloat )WriteString ()string {return _bb .FormatFloat (float64 (*_adgb ),'f',-1,64);};

// GetFilterName returns the name of the encoding filter.
func (_fdafa *CCITTFaxEncoder )GetFilterName ()string {return StreamEncodingFilterNameCCITTFax };

// WriteString outputs the object as it is to be written to file.
func (_cegb *PdfObjectNull )WriteString ()string {return "\u006e\u0075\u006c\u006c"};

// GetFilterName returns the name of the encoding filter.
func (_accab *ASCII85Encoder )GetFilterName ()string {return StreamEncodingFilterNameASCII85 };

// JBIG2Encoder implements both jbig2 encoder and the decoder. The encoder allows to encode
// provided images (best used document scans) in multiple way. By default it uses single page generic
// encoder. It allows to store lossless data as a single segment.
// In order to store multiple image pages use the 'FileMode' which allows to store more pages within single jbig2 document.
// WIP: In order to obtain better compression results the encoder would allow to encode the input in a
// lossy or lossless way with a component (symbol) mode. It divides the image into components.
// Then checks if any component is 'similar' to the others and maps them together. The symbol classes are stored
// in the dictionary. Then the encoder creates text regions which uses the related symbol classes to fill it's space.
// The similarity is defined by the 'Threshold' variable (default: 0.95). The less the value is, the more components
// matches to single class, thus the compression is better, but the result might become lossy.
type JBIG2Encoder struct{

// These values are required to be set for the 'EncodeBytes' method.
// ColorComponents defines the number of color components for provided image.
ColorComponents int ;

// BitsPerComponent is the number of bits that stores per color component
BitsPerComponent int ;

// Width is the width of the image to encode
Width int ;

// Height is the height of the image to encode.
Height int ;_faaa *_fdc .Document ;

// Globals are the JBIG2 global segments.
Globals _ff .Globals ;

// IsChocolateData defines if the data is encoded such that
// binary data '1' means black and '0' white.
// otherwise the data is called vanilla.
// Naming convention taken from: 'https://en.wikipedia.org/wiki/Binary_image#Interpretation'
IsChocolateData bool ;

// DefaultPageSettings are the settings parameters used by the jbig2 encoder.
DefaultPageSettings JBIG2EncoderSettings ;};func (_aefb *offsetReader )Read (p []byte )(_fefca int ,_ffd error ){return _aefb ._fcag .Read (p )};

// PdfCryptNewEncrypt makes the document crypt handler based on a specified crypt filter.
func PdfCryptNewEncrypt (cf _fg .Filter ,userPass ,ownerPass []byte ,perm _gdb .Permissions )(*PdfCrypt ,*EncryptInfo ,error ){_aag :=&PdfCrypt {_fcad :make (map[PdfObject ]bool ),_fag :make (cryptFilters ),_edf :_gdb .StdEncryptDict {P :perm ,EncryptMetadata :true }};
var _gbe Version ;if cf !=nil {_aecb :=cf .PDFVersion ();_gbe .Major ,_gbe .Minor =_aecb [0],_aecb [1];V ,R :=cf .HandlerVersion ();_aag ._cca .V =V ;_aag ._edf .R =R ;_aag ._cca .Length =cf .KeyLength ()*8;};const (_acbb =_egf ;);_aag ._fag [_acbb ]=cf ;
if _aag ._cca .V >=4{_aag ._ba =_acbb ;_aag ._cb =_acbb ;};_beb :=_aag .newEncryptDict ();_bga :=_fad .Sum ([]byte (_fa .Now ().Format (_fa .RFC850 )));_dba :=string (_bga [:]);_fdgb :=make ([]byte ,100);_fc .Read (_fdgb );_bga =_fad .Sum (_fdgb );_ebe :=string (_bga [:]);
_fdf .Log .Trace ("\u0052\u0061\u006e\u0064\u006f\u006d\u0020\u0062\u003a\u0020\u0025\u0020\u0078",_fdgb );_fdf .Log .Trace ("\u0047\u0065\u006e\u0020\u0049\u0064\u0020\u0030\u003a\u0020\u0025\u0020\u0078",_dba );_aag ._fce =_dba ;_ecb :=_aag .generateParams (userPass ,ownerPass );
if _ecb !=nil {return nil ,nil ,_ecb ;};_fcb (&_aag ._edf ,_beb );if _aag ._cca .V >=4{if _ceb :=_aag .saveCryptFilters (_beb );_ceb !=nil {return nil ,nil ,_ceb ;};};return _aag ,&EncryptInfo {Version :_gbe ,Encrypt :_beb ,ID0 :_dba ,ID1 :_ebe },nil ;
};

// Append appends PdfObject(s) to the array.
func (_gddc *PdfObjectArray )Append (objects ...PdfObject ){if _gddc ==nil {_fdf .Log .Debug ("\u0057\u0061\u0072\u006e\u0020\u002d\u0020\u0041\u0074\u0074\u0065\u006d\u0070t\u0020\u0074\u006f\u0020\u0061\u0070p\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020a\u0072\u0072\u0061\u0079");
return ;};_gddc ._fadaed =append (_gddc ._fadaed ,objects ...);};

// Decrypt attempts to decrypt the PDF file with a specified password.  Also tries to
// decrypt with an empty password.  Returns true if successful, false otherwise.
// An error is returned when there is a problem with decrypting.
func (_fdafae *PdfParser )Decrypt (password []byte )(bool ,error ){if _fdafae ._efcc ==nil {return false ,_g .New ("\u0063\u0068\u0065\u0063k \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u0069\u0072s\u0074");};_ceee ,_eafc :=_fdafae ._efcc .authenticate (password );
if _eafc !=nil {return false ,_eafc ;};if !_ceee {_ceee ,_eafc =_fdafae ._efcc .authenticate ([]byte (""));};return _ceee ,_eafc ;};

// Inspect analyzes the document object structure. Returns a map of object types (by name) with the instance count
// as value.
func (_ebcdg *PdfParser )Inspect ()(map[string ]int ,error ){return _ebcdg .inspect ()};

// UpdateParams updates the parameter values of the encoder.
func (_aab *ASCIIHexEncoder )UpdateParams (params *PdfObjectDictionary ){};

// GetXrefOffset returns the offset of the xref table.
func (_fecc *PdfParser )GetXrefOffset ()int64 {return _fecc ._aagdd };var _baegb _a .Map ;func _geee (_eec *_fg .FilterDict ,_fdfa *PdfObjectDictionary )error {if _fafb ,_eda :=_fdfa .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_eda {if _aca :=string (*_fafb );
_aca !="C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"{_fdf .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020C\u0046\u0020\u0064ic\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074e\u0072\u0029",_aca );
};};_acbbc ,_bgg :=_fdfa .Get ("\u0043\u0046\u004d").(*PdfObjectName );if !_bgg {return _ae .Errorf ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0028\u004e\u006f\u006e\u0065\u0029");
};_eec .CFM =string (*_acbbc );if _dcb ,_ebc :=_fdfa .Get ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et").(*PdfObjectName );_ebc {_eec .AuthEvent =_gdb .AuthEvent (*_dcb );}else {_eec .AuthEvent =_gdb .EventDocOpen ;};if _acdb ,_gdbf :=_fdfa .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );
_gdbf {_eec .Length =int (*_acdb );};return nil ;};var _gbaba =_ge .MustCompile ("\u0025P\u0044F\u002d\u0028\u005c\u0064\u0029\u005c\u002e\u0028\u005c\u0064\u0029");func (_adbb *PdfCrypt )checkAccessRights (_fac []byte )(bool ,_gdb .Permissions ,error ){_edgg :=_adbb .securityHandler ();
_fec ,_ggce ,_gffa :=_edgg .Authenticate (&_adbb ._edf ,_fac );if _gffa !=nil {return false ,0,_gffa ;}else if _ggce ==0||len (_fec )==0{return false ,0,nil ;};return true ,_ggce ,nil ;};

// MakeEncodedString creates a PdfObjectString with encoded content, which can be either
// UTF-16BE or PDFDocEncoding depending on whether `utf16BE` is true or false respectively.
func MakeEncodedString (s string ,utf16BE bool )*PdfObjectString {if utf16BE {var _bcb _fda .Buffer ;_bcb .Write ([]byte {0xFE,0xFF});_bcb .WriteString (_dd .StringToUTF16 (s ));return &PdfObjectString {_fea :_bcb .String (),_fbcbg :true };};return &PdfObjectString {_fea :string (_dd .StringToPDFDocEncoding (s )),_fbcbg :false };
};

// MakeNull creates an PdfObjectNull.
func MakeNull ()*PdfObjectNull {_bgfa :=PdfObjectNull {};return &_bgfa };

// MakeBool creates a PdfObjectBool from a bool value.
func MakeBool (val bool )*PdfObjectBool {_fdedg :=PdfObjectBool (val );return &_fdedg };

// EncodeJBIG2Image encodes 'img' into jbig2 encoded bytes stream, using default encoder settings.
func (_bcd *JBIG2Encoder )EncodeJBIG2Image (img *JBIG2Image )([]byte ,error ){const _abcg ="c\u006f\u0072\u0065\u002eEn\u0063o\u0064\u0065\u004a\u0042\u0049G\u0032\u0049\u006d\u0061\u0067\u0065";if _cdbb :=_bcd .AddPageImage (img ,&_bcd .DefaultPageSettings );
_cdbb !=nil {return nil ,_cd .Wrap (_cdbb ,_abcg ,"");};return _bcd .Encode ();};

// GetFilterName returns the name of the encoding filter.
func (_egbbg *JPXEncoder )GetFilterName ()string {return StreamEncodingFilterNameJPX };

// Str returns the string value of the PdfObjectString. Defined in addition to String() function to clarify that
// this function returns the underlying string directly, whereas the String function technically could include
// debug info.
func (_eefgd *PdfObjectString )Str ()string {return _eefgd ._fea };

// HeaderCommentBytes gets the header comment bytes.
func (_gbab ParserMetadata )HeaderCommentBytes ()[4]byte {return _gbab ._cacd };

// Get returns the i-th element of the array or nil if out of bounds (by index).
func (_fbbc *PdfObjectArray )Get (i int )PdfObject {if _fbbc ==nil ||i >=len (_fbbc ._fadaed )||i < 0{return nil ;};return _fbbc ._fadaed [i ];};

// WriteString outputs the object as it is to be written to file.
func (_cbebf *PdfObjectName )WriteString ()string {var _debc _fda .Buffer ;if len (*_cbebf )> 127{_fdf .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u004e\u0061\u006d\u0065\u0020t\u006fo\u0020l\u006f\u006e\u0067\u0020\u0028\u0025\u0073)",*_cbebf );};_debc .WriteString ("\u002f");
for _accfe :=0;_accfe < len (*_cbebf );_accfe ++{_cfceg :=(*_cbebf )[_accfe ];if !IsPrintable (_cfceg )||_cfceg =='#'||IsDelimiter (_cfceg ){_debc .WriteString (_ae .Sprintf ("\u0023\u0025\u002e2\u0078",_cfceg ));}else {_debc .WriteByte (_cfceg );};};return _debc .String ();
};

// GetAsFloat64Slice returns the array as []float64 slice.
// Returns an error if not entirely numeric (only PdfObjectIntegers, PdfObjectFloats).
func (_bgede *PdfObjectArray )GetAsFloat64Slice ()([]float64 ,error ){var _fcdg []float64 ;for _ ,_cgcef :=range _bgede .Elements (){_ccg ,_fae :=GetNumberAsFloat (TraceToDirectObject (_cgcef ));if _fae !=nil {return nil ,_ae .Errorf ("\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006e\u0075m\u0062\u0065\u0072");
};_fcdg =append (_fcdg ,_ccg );};return _fcdg ,nil ;};

// GetFilterArray returns the names of the underlying encoding filters in an array that
// can be used as /Filter entry.
func (_agab *MultiEncoder )GetFilterArray ()*PdfObjectArray {_dcdda :=make ([]PdfObject ,len (_agab ._cbab ));for _eedd ,_bdbb :=range _agab ._cbab {_dcdda [_eedd ]=MakeName (_bdbb .GetFilterName ());};return MakeArray (_dcdda ...);};var (ErrUnsupportedEncodingParameters =_g .New ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074\u0065\u0072\u0073");
ErrNoCCITTFaxDecode =_g .New ("\u0043\u0043I\u0054\u0054\u0046\u0061\u0078\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");
ErrNoJBIG2Decode =_g .New ("\u004a\u0042\u0049\u0047\u0032\u0044\u0065c\u006f\u0064\u0065 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");
ErrNoJPXDecode =_g .New ("\u004a\u0050\u0058\u0044\u0065c\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020i\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");
ErrNoPdfVersion =_g .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");ErrTypeError =_g .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");ErrRangeError =_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");
ErrNotSupported =_bc .New ("\u0066\u0065\u0061t\u0075\u0072\u0065\u0020n\u006f\u0074\u0020\u0063\u0075\u0072\u0072e\u006e\u0074\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");ErrNotANumber =_g .New ("\u006e\u006f\u0074 \u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072");
);

// PdfObjectNull represents the primitive PDF null object.
type PdfObjectNull struct{};

// PdfCrypt provides PDF encryption/decryption support.
// The PDF standard supports encryption of strings and streams (Section 7.6).
type PdfCrypt struct{_cca encryptDict ;_edf _gdb .StdEncryptDict ;_fce string ;_ffbf []byte ;_bca map[PdfObject ]bool ;_fcad map[PdfObject ]bool ;_edc bool ;_fag cryptFilters ;_ba string ;_cb string ;_ged *PdfParser ;_agfe map[int ]struct{};};

// ParseNumber parses a numeric objects from a buffered stream.
// Section 7.3.3.
// Integer or Float.
//
// An integer shall be written as one or more decimal digits optionally
// preceded by a sign. The value shall be interpreted as a signed
// decimal integer and shall be converted to an integer object.
//
// A real value shall be written as one or more decimal digits with an
// optional sign and a leading, trailing, or embedded PERIOD (2Eh)
// (decimal point). The value shall be interpreted as a real number
// and shall be converted to a real object.
//
// Regarding exponential numbers: 7.3.3 Numeric Objects:
// A conforming writer shall not use the PostScript syntax for numbers
// with non-decimal radices (such as 16#FFFE) or in exponential format
// (such as 6.02E23).
// Nonetheless, we sometimes get numbers with exponential format, so
// we will support it in the reader (no confusion with other types, so
// no compromise).
func ParseNumber (buf *_faf .Reader )(PdfObject ,error ){_adec :=false ;_ecgc :=true ;var _aaef _fda .Buffer ;for {if _fdf .Log .IsLogLevel (_fdf .LogLevelTrace ){_fdf .Log .Trace ("\u0050\u0061\u0072\u0073in\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0022\u0025\u0073\u0022",_aaef .String ());
};_fbff ,_eedgd :=buf .Peek (1);if _eedgd ==_ef .EOF {break ;};if _eedgd !=nil {_fdf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0025\u0073",_eedgd );return nil ,_eedgd ;};if _ecgc &&(_fbff [0]=='-'||_fbff [0]=='+'){_ebgf ,_ :=buf .ReadByte ();
_aaef .WriteByte (_ebgf );_ecgc =false ;}else if IsDecimalDigit (_fbff [0]){_cgbag ,_ :=buf .ReadByte ();_aaef .WriteByte (_cgbag );}else if _fbff [0]=='.'{_gdfc ,_ :=buf .ReadByte ();_aaef .WriteByte (_gdfc );_adec =true ;}else if _fbff [0]=='e'||_fbff [0]=='E'{_dddgc ,_ :=buf .ReadByte ();
_aaef .WriteByte (_dddgc );_adec =true ;_ecgc =true ;}else {break ;};};var _fbgab PdfObject ;if _adec {_affb ,_ddgba :=_bb .ParseFloat (_aaef .String (),64);if _ddgba !=nil {_fdf .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0025v\u0020\u0065\u0072\u0072\u003d\u0025v\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0030\u002e\u0020\u004fu\u0074\u0070u\u0074\u0020\u006d\u0061y\u0020\u0062\u0065\u0020\u0069n\u0063\u006f\u0072\u0072\u0065\u0063\u0074",_aaef .String (),_ddgba );
_affb =0.0;};_fdegf :=PdfObjectFloat (_affb );_fbgab =&_fdegf ;}else {_dffea ,_fcebe :=_bb .ParseInt (_aaef .String (),10,64);if _fcebe !=nil {_fdf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0025\u0076\u0020\u0065\u0072\u0072\u003d%\u0076\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074 \u006d\u0061\u0079\u0020\u0062\u0065 \u0069\u006ec\u006f\u0072r\u0065c\u0074",_aaef .String (),_fcebe );
_dffea =0;};_ceffe :=PdfObjectInteger (_dffea );_fbgab =&_ceffe ;};return _fbgab ,nil ;};var _gdaa =_ge .MustCompile ("\u0025\u0025\u0045\u004f\u0046\u003f");

// String returns a string representation of the *PdfObjectString.
func (_bbga *PdfObjectString )String ()string {return _bbga ._fea };

// GetFilterName returns the name of the encoding filter.
func (_cccg *RawEncoder )GetFilterName ()string {return StreamEncodingFilterNameRaw };

// UpdateParams updates the parameter values of the encoder.
func (_cabc *DCTEncoder )UpdateParams (params *PdfObjectDictionary ){_fadd ,_befdc :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _befdc ==nil {_cabc .ColorComponents =int (_fadd );
};_gddf ,_befdc :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _befdc ==nil {_cabc .BitsPerComponent =int (_gddf );};_fecg ,_befdc :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));
if _befdc ==nil {_cabc .Width =int (_fecg );};_ggd ,_befdc :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _befdc ==nil {_cabc .Height =int (_ggd );};_dadd ,_befdc :=GetNumberAsInt64 (params .Get ("\u0051u\u0061\u006c\u0069\u0074\u0079"));
if _befdc ==nil {_cabc .Quality =int (_dadd );};};

// JPXEncoder implements JPX encoder/decoder (dummy, for now)
// FIXME: implement
type JPXEncoder struct{};func (_dccc *PdfCrypt )generateParams (_cagg ,_ced []byte )error {_gdbd :=_dccc .securityHandler ();_defa ,_afd :=_gdbd .GenerateParams (&_dccc ._edf ,_ced ,_cagg );if _afd !=nil {return _afd ;};_dccc ._ffbf =_defa ;return nil ;
};

// PdfCryptNewDecrypt makes the document crypt handler based on the encryption dictionary
// and trailer dictionary. Returns an error on failure to process.
func PdfCryptNewDecrypt (parser *PdfParser ,ed ,trailer *PdfObjectDictionary )(*PdfCrypt ,error ){_ccd :=&PdfCrypt {_edc :false ,_bca :make (map[PdfObject ]bool ),_fcad :make (map[PdfObject ]bool ),_agfe :make (map[int ]struct{}),_ged :parser };_gabb ,_dab :=ed .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectName );
if !_dab {_fdf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0043\u0072\u0079\u0070\u0074 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061r\u0079 \u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u0066\u0069\u0065\u006c\u0064\u0021");
return _ccd ,_g .New ("r\u0065\u0071\u0075\u0069\u0072\u0065d\u0020\u0063\u0072\u0079\u0070\u0074 \u0066\u0069\u0065\u006c\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u006d\u0069\u0073\u0073\u0069n\u0067");};if *_gabb !="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"{_fdf .Log .Debug ("\u0045\u0052R\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020(%\u0073\u0029",*_gabb );
return _ccd ,_g .New ("\u0075n\u0073u\u0070\u0070\u006f\u0072\u0074e\u0064\u0020F\u0069\u006c\u0074\u0065\u0072");};_ccd ._cca .Filter =string (*_gabb );if _eegbd ,_gbg :=ed .Get ("\u0053u\u0062\u0046\u0069\u006c\u0074\u0065r").(*PdfObjectString );_gbg {_ccd ._cca .SubFilter =_eegbd .Str ();
_fdf .Log .Debug ("\u0055s\u0069n\u0067\u0020\u0073\u0075\u0062f\u0069\u006ct\u0065\u0072\u0020\u0025\u0073",_eegbd );};if L ,_ceba :=ed .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );_ceba {if (*L %8)!=0{_fdf .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0049\u006ev\u0061\u006c\u0069\u0064\u0020\u0065\u006ec\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006c\u0065\u006e\u0067\u0074\u0068");
return _ccd ,_g .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0065\u006e\u0063\u0072y\u0070t\u0069o\u006e\u0020\u006c\u0065\u006e\u0067\u0074h");};_ccd ._cca .Length =int (*L );}else {_ccd ._cca .Length =40;};_ccd ._cca .V =0;if _eed ,_defe :=ed .Get ("\u0056").(*PdfObjectInteger );
_defe {V :=int (*_eed );_ccd ._cca .V =V ;if V >=1&&V <=2{_ccd ._fag =_dae (_ccd ._cca .Length );}else if V >=4&&V <=5{if _ebg :=_ccd .loadCryptFilters (ed );_ebg !=nil {return _ccd ,_ebg ;};}else {_fdf .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0061lg\u006f\u0020\u0056 \u003d \u0025\u0064",V );
return _ccd ,_g .New ("u\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d");};};if _debg :=_bef (&_ccd ._edf ,ed );_debg !=nil {return _ccd ,_debg ;};_dbce :="";if _daa ,_cacc :=trailer .Get ("\u0049\u0044").(*PdfObjectArray );
_cacc &&_daa .Len ()>=1{_cbe ,_eece :=GetString (_daa .Get (0));if !_eece {return _ccd ,_g .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0074r\u0061\u0069l\u0065\u0072\u0020\u0049\u0044");};_dbce =_cbe .Str ();}else {_fdf .Log .Debug ("\u0054\u0072ai\u006c\u0065\u0072 \u0049\u0044\u0020\u0061rra\u0079 m\u0069\u0073\u0073\u0069\u006e\u0067\u0020or\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0021");
};_ccd ._fce =_dbce ;return _ccd ,nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_dcbd *ASCII85Encoder )MakeDecodeParams ()PdfObject {return nil };

// IsAuthenticated returns true if the PDF has already been authenticated for accessing.
func (_bfed *PdfParser )IsAuthenticated ()bool {return _bfed ._efcc ._edc };

// NewJBIG2Encoder creates a new JBIG2Encoder.
func NewJBIG2Encoder ()*JBIG2Encoder {return &JBIG2Encoder {_faaa :_fdc .InitEncodeDocument (false )}};

// DecodeStream decodes a FlateEncoded stream object and give back decoded bytes.
func (_adeb *FlateEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_fdf .Log .Trace ("\u0046l\u0061t\u0065\u0044\u0065\u0063\u006fd\u0065\u0020s\u0074\u0072\u0065\u0061\u006d");_fdf .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_adeb .Predictor );
if _adeb .BitsPerComponent !=8{return nil ,_ae .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003d\u0025\u0064\u0020\u0028\u006f\u006e\u006c\u0079\u0020\u0038\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0029",_adeb .BitsPerComponent );
};_adfd ,_gggc :=_adeb .DecodeBytes (streamObj .Stream );if _gggc !=nil {return nil ,_gggc ;};_adfd ,_gggc =_adeb .postDecodePredict (_adfd );if _gggc !=nil {return nil ,_gggc ;};return _adfd ,nil ;};

// PdfObjectFloat represents the primitive PDF floating point numerical object.
type PdfObjectFloat float64 ;

// GetFilterName returns the names of the underlying encoding filters,
// separated by spaces.
// Note: This is just a string, should not be used in /Filter dictionary entry. Use GetFilterArray for that.
// TODO(v4): Refactor to GetFilter() which can be used for /Filter (either Name or Array), this can be
//  renamed to String() as a pretty string to use in debugging etc.
func (_cbdf *MultiEncoder )GetFilterName ()string {_caged :="";for _eeab ,_gdgg :=range _cbdf ._cbab {_caged +=_gdgg .GetFilterName ();if _eeab < len (_cbdf ._cbab )-1{_caged +="\u0020";};};return _caged ;};func (_adbbe *PdfParser )parseXrefStream (_egfgg *PdfObjectInteger )(*PdfObjectDictionary ,error ){if _egfgg !=nil {_fdf .Log .Trace ("\u0058\u0052\u0065f\u0053\u0074\u006d\u0020x\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0061\u0074\u0020\u0025\u0064",_egfgg );
_adbbe ._dddg .Seek (int64 (*_egfgg ),_ef .SeekStart );_adbbe ._bdg =_faf .NewReader (_adbbe ._dddg );};_gffc :=_adbbe .GetFileOffset ();_dafe ,_aabb :=_adbbe .ParseIndirectObject ();if _aabb !=nil {_fdf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072\u0065\u0061d\u0020\u0078\u0072\u0065\u0066\u0020\u006fb\u006a\u0065\u0063\u0074");
return nil ,_g .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072e\u0061\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062j\u0065\u0063\u0074");};_fdf .Log .Trace ("\u0058R\u0065f\u0053\u0074\u006d\u0020\u006fb\u006a\u0065c\u0074\u003a\u0020\u0025\u0073",_dafe );
_cccab ,_dgeb :=_dafe .(*PdfObjectStream );if !_dgeb {_fdf .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0058R\u0065\u0066\u0053\u0074\u006d\u0020\u0070o\u0069\u006e\u0074\u0069\u006e\u0067 \u0074\u006f\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065a\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0021");
return nil ,_g .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0070\u006f\u0069\u006e\u0074i\u006e\u0067\u0020\u0074\u006f\u0020a\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006fb\u006a\u0065\u0063\u0074");};_acfd :=_cccab .PdfObjectDictionary ;
_abgd ,_dgeb :=_cccab .PdfObjectDictionary .Get ("\u0053\u0069\u007a\u0065").(*PdfObjectInteger );if !_dgeb {_fdf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u004d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0073\u0069\u007a\u0065\u0020f\u0072\u006f\u006d\u0020\u0078\u0072\u0065f\u0020\u0073\u0074\u006d");
return nil ,_g .New ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0053\u0069\u007ae\u0020\u0066\u0072\u006f\u006d\u0020\u0078\u0072\u0065\u0066 \u0073\u0074\u006d");};if int64 (*_abgd )> 8388607{_fdf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u0053\u0069\u007a\u0065\u0020\u0065x\u0063\u0065\u0065\u0064\u0065\u0064\u0020l\u0069\u006d\u0069\u0074\u002c\u0020\u006f\u0076\u0065\u0072\u00208\u0033\u0038\u0038\u0036\u0030\u0037\u0020\u0028\u0025\u0064\u0029",*_abgd );
return nil ,_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_edefa :=_cccab .PdfObjectDictionary .Get ("\u0057");_ceef ,_dgeb :=_edefa .(*PdfObjectArray );if !_dgeb {return nil ,_g .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0057\u0020\u0069\u006e\u0020x\u0072\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d");
};_beec :=_ceef .Len ();if _beec !=3{_fdf .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020\u0028\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033\u0020\u002d\u0020\u0025\u0064\u0029",_beec );
return nil ,_g .New ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065f\u0020s\u0074\u006d\u0020\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033");};var _gege []int64 ;for _cbdc :=0;_cbdc < 3;
_cbdc ++{_bfga ,_egeb :=GetInt (_ceef .Get (_cbdc ));if !_egeb {return nil ,_g .New ("i\u006e\u0076\u0061\u006cid\u0020w\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0074\u0079\u0070\u0065");};_gege =append (_gege ,int64 (*_bfga ));};_befgc ,_aabb :=DecodeStream (_cccab );
if _aabb !=nil {_fdf .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020t\u006f \u0064e\u0063o\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u003a\u0020\u0025\u0076",_aabb );return nil ,_aabb ;};_babca :=int (_gege [0]);
_egcc :=int (_gege [0]+_gege [1]);_gbba :=int (_gege [0]+_gege [1]+_gege [2]);_aeded :=int (_gege [0]+_gege [1]+_gege [2]);if _babca < 0||_egcc < 0||_gbba < 0{_fdf .Log .Debug ("\u0045\u0072\u0072\u006fr\u0020\u0073\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u003c \u0030 \u0028\u0025\u0064\u002c\u0025\u0064\u002c%\u0064\u0029",_babca ,_egcc ,_gbba );
return nil ,_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};if _aeded ==0{_fdf .Log .Debug ("\u004e\u006f\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063t\u0073\u0020\u0069\u006e\u0020\u0073t\u0072\u0065\u0061\u006d\u0020\u0028\u0064\u0065\u006c\u0074\u0061\u0062\u0020=\u003d\u0020\u0030\u0029");
return _acfd ,nil ;};_fdacc :=len (_befgc )/_aeded ;_fggc :=0;_caag :=_cccab .PdfObjectDictionary .Get ("\u0049\u006e\u0064e\u0078");var _baeg []int ;if _caag !=nil {_fdf .Log .Trace ("\u0049n\u0064\u0065\u0078\u003a\u0020\u0025b",_caag );_becd ,_ccaa :=_caag .(*PdfObjectArray );
if !_ccaa {_fdf .Log .Debug ("\u0049\u006e\u0076\u0061\u006ci\u0064\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0029");
return nil ,_g .New ("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0049\u006e\u0064e\u0078\u0020\u006f\u0062je\u0063\u0074");};if _becd .Len ()%2!=0{_fdf .Log .Debug ("\u0057\u0041\u0052\u004eI\u004e\u0047\u0020\u0046\u0061\u0069\u006c\u0075\u0072e\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020i\u006e\u0064\u0065\u0078\u0020n\u006f\u0074\u0020\u006d\u0075\u006c\u0074\u0069\u0070\u006c\u0065\u0020\u006f\u0066\u0020\u0032\u002e");
return nil ,_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_fggc =0;_edede ,_cgacd :=_becd .ToIntegerArray ();if _cgacd !=nil {_fdf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072 \u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0065\u0078 \u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0073\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0073\u003a\u0020\u0025\u0076",_cgacd );
return nil ,_cgacd ;};for _cafag :=0;_cafag < len (_edede );_cafag +=2{_dgge :=_edede [_cafag ];_cebb :=_edede [_cafag +1];for _bcee :=0;_bcee < _cebb ;_bcee ++{_baeg =append (_baeg ,_dgge +_bcee );};_fggc +=_cebb ;};}else {for _gbff :=0;_gbff < int (*_abgd );
_gbff ++{_baeg =append (_baeg ,_gbff );};_fggc =int (*_abgd );};if _fdacc ==_fggc +1{_fdf .Log .Debug ("\u0049n\u0063\u006f\u006d\u0070ati\u0062\u0069\u006c\u0069t\u0079\u003a\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006di\u0073\u0073\u0069\u006e\u0067\u0020\u0063\u006f\u0076\u0065\u0072\u0061\u0067\u0065\u0020\u006f\u0066\u0020\u0031\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u002d\u0020\u0061\u0070\u0070en\u0064\u0069\u006eg\u0020\u006f\u006e\u0065\u0020-\u0020M\u0061\u0079\u0020\u006c\u0065\u0061\u0064\u0020\u0074o\u0020\u0070\u0072\u006f\u0062\u006c\u0065\u006d\u0073");
_cafbe :=_fggc -1;for _ ,_feeg :=range _baeg {if _feeg > _cafbe {_cafbe =_feeg ;};};_baeg =append (_baeg ,_cafbe +1);_fggc ++;};if _fdacc !=len (_baeg ){_fdf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020x\u0072\u0065\u0066 \u0073\u0074\u006d:\u0020\u006eu\u006d\u0020\u0065\u006e\u0074\u0072i\u0065s \u0021\u003d\u0020\u006c\u0065\u006e\u0028\u0069\u006e\u0064\u0069\u0063\u0065\u0073\u0029\u0020\u0028\u0025\u0064\u0020\u0021\u003d\u0020\u0025\u0064\u0029",_fdacc ,len (_baeg ));
return nil ,_g .New ("\u0078\u0072ef\u0020\u0073\u0074m\u0020\u006e\u0075\u006d en\u0074ri\u0065\u0073\u0020\u0021\u003d\u0020\u006cen\u0028\u0069\u006e\u0064\u0069\u0063\u0065s\u0029");};_fdf .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074s\u0020\u0063\u006f\u0075\u006e\u0074\u0020\u0025\u0064",_fggc );
_fdf .Log .Trace ("\u0049\u006e\u0064i\u0063\u0065\u0073\u003a\u0020\u0025\u0020\u0064",_baeg );_adcf :=func (_bcfa []byte )int64 {var _cbfge int64 ;for _bcea :=0;_bcea < len (_bcfa );_bcea ++{_cbfge +=int64 (_bcfa [_bcea ])*(1<<uint (8*(len (_bcfa )-_bcea -1)));
};return _cbfge ;};_fdf .Log .Trace ("\u0044e\u0063\u006f\u0064\u0065d\u0020\u0073\u0074\u0072\u0065a\u006d \u006ce\u006e\u0067\u0074\u0068\u003a\u0020\u0025d",len (_befgc ));_eaed :=0;for _fdgaf :=0;_fdgaf < len (_befgc );_fdgaf +=_aeded {_fdfb :=_gabba (len (_befgc ),_fdgaf ,_fdgaf +_babca );
if _fdfb !=nil {_fdf .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_fdfb );return nil ,_fdfb ;};_ddadd :=_befgc [_fdgaf :_fdgaf +_babca ];_fdfb =_gabba (len (_befgc ),_fdgaf +_babca ,_fdgaf +_egcc );
if _fdfb !=nil {_fdf .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_fdfb );return nil ,_fdfb ;};_geff :=_befgc [_fdgaf +_babca :_fdgaf +_egcc ];_fdfb =_gabba (len (_befgc ),_fdgaf +_egcc ,_fdgaf +_gbba );
if _fdfb !=nil {_fdf .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_fdfb );return nil ,_fdfb ;};_aaga :=_befgc [_fdgaf +_egcc :_fdgaf +_gbba ];_fdecb :=_adcf (_ddadd );
_feef :=_adcf (_geff );_gagd :=_adcf (_aaga );if _gege [0]==0{_fdecb =1;};if _eaed >=len (_baeg ){_fdf .Log .Debug ("X\u0052\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u002d\u0020\u0054\u0072\u0079\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0061\u0063\u0063e\u0073s\u0020\u0069\u006e\u0064e\u0078\u0020o\u0075\u0074\u0020\u006f\u0066\u0020\u0062\u006f\u0075\u006e\u0064\u0073\u0020\u002d\u0020\u0062\u0072\u0065\u0061\u006b\u0069\u006e\u0067");
break ;};_afde :=_baeg [_eaed ];_eaed ++;_fdf .Log .Trace ("%\u0064\u002e\u0020\u0070\u0031\u003a\u0020\u0025\u0020\u0078",_afde ,_ddadd );_fdf .Log .Trace ("%\u0064\u002e\u0020\u0070\u0032\u003a\u0020\u0025\u0020\u0078",_afde ,_geff );_fdf .Log .Trace ("%\u0064\u002e\u0020\u0070\u0033\u003a\u0020\u0025\u0020\u0078",_afde ,_aaga );
_fdf .Log .Trace ("\u0025d\u002e \u0078\u0072\u0065\u0066\u003a \u0025\u0064 \u0025\u0064\u0020\u0025\u0064",_afde ,_fdecb ,_feef ,_gagd );if _fdecb ==0{_fdf .Log .Trace ("-\u0020\u0046\u0072\u0065\u0065\u0020o\u0062\u006a\u0065\u0063\u0074\u0020-\u0020\u0063\u0061\u006e\u0020\u0070\u0072o\u0062\u0061\u0062\u006c\u0079\u0020\u0069\u0067\u006e\u006fr\u0065");
}else if _fdecb ==1{_fdf .Log .Trace ("\u002d\u0020I\u006e\u0020\u0075\u0073e\u0020\u002d \u0075\u006e\u0063\u006f\u006d\u0070\u0072\u0065s\u0073\u0065\u0064\u0020\u0076\u0069\u0061\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0062",_geff );if _feef ==_gffc {_fdf .Log .Debug ("\u0055\u0070d\u0061\u0074\u0069\u006e\u0067\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0058\u0052\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0064",_afde ,_cccab .ObjectNumber );
_afde =int (_cccab .ObjectNumber );};if _ffba ,_gbbgg :=_adbbe ._agec .ObjectMap [_afde ];!_gbbgg ||int (_gagd )> _ffba .Generation {_gga :=XrefObject {ObjectNumber :_afde ,XType :XrefTypeTableEntry ,Offset :_feef ,Generation :int (_gagd )};_adbbe ._agec .ObjectMap [_afde ]=_gga ;
};}else if _fdecb ==2{_fdf .Log .Trace ("\u002d\u0020\u0049\u006e \u0075\u0073\u0065\u0020\u002d\u0020\u0063\u006f\u006d\u0070r\u0065s\u0073\u0065\u0064\u0020\u006f\u0062\u006ae\u0063\u0074");if _ ,_efba :=_adbbe ._agec .ObjectMap [_afde ];!_efba {_abgf :=XrefObject {ObjectNumber :_afde ,XType :XrefTypeObjectStream ,OsObjNumber :int (_feef ),OsObjIndex :int (_gagd )};
_adbbe ._agec .ObjectMap [_afde ]=_abgf ;_fdf .Log .Trace ("\u0065\u006e\u0074\u0072\u0079\u003a\u0020\u0025\u002b\u0076",_abgf );};}else {_fdf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052:\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0056\u0041L\u0049\u0044\u0020\u0054\u0059\u0050\u0045\u0020\u0058\u0072\u0065\u0066\u0053\u0074\u006d\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u003f\u002d\u002d\u002d\u002d\u002d\u002d-");
continue ;};};if _adbbe ._bbbf ==nil {_bdfcf :=XrefTypeObjectStream ;_adbbe ._bbbf =&_bdfcf ;};return _acfd ,nil ;};func _fcb (_aac *_gdb .StdEncryptDict ,_ecf *PdfObjectDictionary ){_ecf .Set ("\u0052",MakeInteger (int64 (_aac .R )));_ecf .Set ("\u0050",MakeInteger (int64 (_aac .P )));
_ecf .Set ("\u004f",MakeStringFromBytes (_aac .O ));_ecf .Set ("\u0055",MakeStringFromBytes (_aac .U ));if _aac .R >=5{_ecf .Set ("\u004f\u0045",MakeStringFromBytes (_aac .OE ));_ecf .Set ("\u0055\u0045",MakeStringFromBytes (_aac .UE ));_ecf .Set ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061",MakeBool (_aac .EncryptMetadata ));
if _aac .R > 5{_ecf .Set ("\u0050\u0065\u0072m\u0073",MakeStringFromBytes (_aac .Perms ));};};};

// Set sets the PdfObject at index i of the streams. An error is returned if the index is outside bounds.
func (_gcba *PdfObjectStreams )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_gcba ._adad ){return _g .New ("\u004f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_gcba ._adad [i ]=obj ;return nil ;};const _eaacb =6;
func _bade (_fecef string )(int ,int ,error ){_gacd :=_agda .FindStringSubmatch (_fecef );if len (_gacd )< 3{return 0,0,_g .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");
};_eedgc ,_ :=_bb .Atoi (_gacd [1]);_cgccf ,_ :=_bb .Atoi (_gacd [2]);return _eedgc ,_cgccf ,nil ;};

// String returns a string describing `ind`.
func (_bbcg *PdfIndirectObject )String ()string {return _ae .Sprintf ("\u0049\u004f\u0062\u006a\u0065\u0063\u0074\u003a\u0025\u0064",(*_bbcg ).ObjectNumber );};

// PdfObjectReference represents the primitive PDF reference object.
type PdfObjectReference struct{_aagbc *PdfParser ;ObjectNumber int64 ;GenerationNumber int64 ;};

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_ebgg *RunLengthEncoder )EncodeBytes (data []byte )([]byte ,error ){_gfcd :=_fda .NewReader (data );var _ggeg []byte ;var _fdfg []byte ;_afgd ,_fba :=_gfcd .ReadByte ();if _fba ==_ef .EOF {return []byte {},nil ;}else if _fba !=nil {return nil ,_fba ;
};_gagg :=1;for {_cfdf ,_eeff :=_gfcd .ReadByte ();if _eeff ==_ef .EOF {break ;}else if _eeff !=nil {return nil ,_eeff ;};if _cfdf ==_afgd {if len (_fdfg )> 0{_fdfg =_fdfg [:len (_fdfg )-1];if len (_fdfg )> 0{_ggeg =append (_ggeg ,byte (len (_fdfg )-1));
_ggeg =append (_ggeg ,_fdfg ...);};_gagg =1;_fdfg =[]byte {};};_gagg ++;if _gagg >=127{_ggeg =append (_ggeg ,byte (257-_gagg ),_afgd );_gagg =0;};}else {if _gagg > 0{if _gagg ==1{_fdfg =[]byte {_afgd };}else {_ggeg =append (_ggeg ,byte (257-_gagg ),_afgd );
};_gagg =0;};_fdfg =append (_fdfg ,_cfdf );if len (_fdfg )>=127{_ggeg =append (_ggeg ,byte (len (_fdfg )-1));_ggeg =append (_ggeg ,_fdfg ...);_fdfg =[]byte {};};};_afgd =_cfdf ;};if len (_fdfg )> 0{_ggeg =append (_ggeg ,byte (len (_fdfg )-1));_ggeg =append (_ggeg ,_fdfg ...);
}else if _gagg > 0{_ggeg =append (_ggeg ,byte (257-_gagg ),_afgd );};_ggeg =append (_ggeg ,128);return _ggeg ,nil ;};

// GetFloat returns the *PdfObjectFloat represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetFloat (obj PdfObject )(_cgfe *PdfObjectFloat ,_dggaf bool ){_cgfe ,_dggaf =TraceToDirectObject (obj ).(*PdfObjectFloat );return _cgfe ,_dggaf ;};

// ToIntegerArray returns a slice of all array elements as an int slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_bcg *PdfObjectArray )ToIntegerArray ()([]int ,error ){var _baba []int ;for _ ,_ggae :=range _bcg .Elements (){if _ffdc ,_feegag :=_ggae .(*PdfObjectInteger );_feegag {_baba =append (_baba ,int (*_ffdc ));}else {return nil ,ErrTypeError ;};};return _baba ,nil ;
};func (_aeefa *PdfParser )resolveReference (_begb *PdfObjectReference )(PdfObject ,bool ,error ){_dfbfa ,_cccc :=_aeefa .ObjCache [int (_begb .ObjectNumber )];if _cccc {return _dfbfa ,true ,nil ;};_bdeb ,_begg :=_aeefa .LookupByReference (*_begb );if _begg !=nil {return nil ,false ,_begg ;
};_aeefa .ObjCache [int (_begb .ObjectNumber )]=_bdeb ;return _bdeb ,false ,nil ;};

// MakeObjectStreams creates an PdfObjectStreams from a list of PdfObjects.
func MakeObjectStreams (objects ...PdfObject )*PdfObjectStreams {return &PdfObjectStreams {_adad :objects };};func (_efcgg *PdfParser )seekPdfVersionTopDown ()(int ,int ,error ){_efcgg ._dddg .Seek (0,_ef .SeekStart );_efcgg ._bdg =_faf .NewReader (_efcgg ._dddg );
_badfc :=20;_bbed :=make ([]byte ,_badfc );for {_feec ,_efdcf :=_efcgg ._bdg .ReadByte ();if _efdcf !=nil {if _efdcf ==_ef .EOF {break ;}else {return 0,0,_efdcf ;};};if IsDecimalDigit (_feec )&&_bbed [_badfc -1]=='.'&&IsDecimalDigit (_bbed [_badfc -2])&&_bbed [_badfc -3]=='-'&&_bbed [_badfc -4]=='F'&&_bbed [_badfc -5]=='D'&&_bbed [_badfc -6]=='P'{_bbdad :=int (_bbed [_badfc -2]-'0');
_cbgc :=int (_feec -'0');return _bbdad ,_cbgc ,nil ;};_bbed =append (_bbed [1:_badfc ],_feec );};return 0,0,_g .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};var _cafa =_ge .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064+\u0029\u005c\u0073\u002b\u0028\u005b\u006e\u0066\u005d\u0029\\\u0073\u002a\u0024");


// Update updates multiple keys and returns the dictionary back so can be used in a chained fashion.
func (_bbcffb *PdfObjectDictionary )Update (objmap map[string ]PdfObject )*PdfObjectDictionary {_bbcffb ._bebfa .Lock ();defer _bbcffb ._bebfa .Unlock ();for _adedd ,_cdgd :=range objmap {_bbcffb .setWithLock (PdfObjectName (_adedd ),_cdgd ,false );};return _bbcffb ;
};

// DecodeImages decodes the page images from the jbig2 'encoded' data input.
// The jbig2 document may contain multiple pages, thus the function can return multiple
// images. The images order corresponds to the page number.
func (_cageb *JBIG2Encoder )DecodeImages (encoded []byte )([]_bd .Image ,error ){const _bfe ="\u004aB\u0049\u0047\u0032\u0045n\u0063\u006f\u0064\u0065\u0072.\u0044e\u0063o\u0064\u0065\u0049\u006d\u0061\u0067\u0065s";_gadf ,_bgac :=_ded .Decode (encoded ,_ded .Parameters {},_cageb .Globals .ToDocumentGlobals ());
if _bgac !=nil {return nil ,_cd .Wrap (_bgac ,_bfe ,"");};_fbef ,_bgac :=_gadf .PageNumber ();if _bgac !=nil {return nil ,_cd .Wrap (_bgac ,_bfe ,"");};_cfddb :=[]_bd .Image {};var _adcde _bd .Image ;for _ffge :=1;_ffge <=_fbef ;_ffge ++{_adcde ,_bgac =_gadf .DecodePageImage (_ffge );
if _bgac !=nil {return nil ,_cd .Wrapf (_bgac ,_bfe ,"\u0070\u0061\u0067\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_ffge );};_cfddb =append (_cfddb ,_adcde );};return _cfddb ,nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_cggf *MultiEncoder )MakeDecodeParams ()PdfObject {if len (_cggf ._cbab )==0{return nil ;};if len (_cggf ._cbab )==1{return _cggf ._cbab [0].MakeDecodeParams ();};_fgg :=MakeArray ();_ccdc :=true ;for _ ,_adff :=range _cggf ._cbab {_abcf :=_adff .MakeDecodeParams ();
if _abcf ==nil {_fgg .Append (MakeNull ());}else {_ccdc =false ;_fgg .Append (_abcf );};};if _ccdc {return nil ;};return _fgg ;};

// NewParser creates a new parser for a PDF file via ReadSeeker. Loads the cross reference stream and trailer.
// An error is returned on failure.
func NewParser (rs _ef .ReadSeeker )(*PdfParser ,error ){_gdbgg :=&PdfParser {_dddg :rs ,ObjCache :make (objectCache ),_fbed :map[int64 ]bool {},_accg :make ([]int64 ,0),_fcfb :make (map[*PdfParser ]*PdfParser )};_gaed ,_bac ,_ccag :=_gdbgg .parsePdfVersion ();
if _ccag !=nil {_fdf .Log .Error ("U\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0076e\u0072\u0073\u0069o\u006e:\u0020\u0025\u0076",_ccag );return nil ,_ccag ;};_gdbgg ._dfgf .Major =_gaed ;_gdbgg ._dfgf .Minor =_bac ;
if _gdbgg ._gaad ,_ccag =_gdbgg .loadXrefs ();_ccag !=nil {_fdf .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020F\u0061\u0069\u006c\u0065d t\u006f l\u006f\u0061\u0064\u0020\u0078\u0072\u0065f \u0074\u0061\u0062\u006c\u0065\u0021\u0020%\u0073",_ccag );return nil ,_ccag ;
};_fdf .Log .Trace ("T\u0072\u0061\u0069\u006c\u0065\u0072\u003a\u0020\u0025\u0073",_gdbgg ._gaad );_cgdg ,_ccag :=_gdbgg .parseLinearizedDictionary ();if _ccag !=nil {return nil ,_ccag ;};if _cgdg !=nil {_gdbgg ._aaee ,_ccag =_gdbgg .checkLinearizedInformation (_cgdg );
if _ccag !=nil {return nil ,_ccag ;};};if len (_gdbgg ._agec .ObjectMap )==0{return nil ,_ae .Errorf ("\u0065\u006d\u0070\u0074\u0079\u0020\u0058\u0052\u0045\u0046\u0020t\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0049\u006e\u0076a\u006c\u0069\u0064");
};_gdbgg ._agba =len (_gdbgg ._accg );if _gdbgg ._aaee &&_gdbgg ._agba !=0{_gdbgg ._agba --;};_gdbgg ._fdaaf =make ([]*PdfParser ,_gdbgg ._agba );return _gdbgg ,nil ;};

// WriteString outputs the object as it is to be written to file.
func (_dcab *PdfIndirectObject )WriteString ()string {var _cgfb _gc .Builder ;_cgfb .WriteString (_bb .FormatInt (_dcab .ObjectNumber ,10));_cgfb .WriteString ("\u0020\u0030\u0020\u0052");return _cgfb .String ();};

// GetNumberAsInt64 returns the contents of `obj` as an int64 if it is an integer or float, or an
// error if it isn't. This is for cases where expecting an integer, but some implementations
// actually store the number in a floating point format.
func GetNumberAsInt64 (obj PdfObject )(int64 ,error ){_fdfc ,_cgaca :=obj .(*PdfObjectReference );if _cgaca {obj =TraceToDirectObject (_fdfc );}else if _bfged ,_fcec :=obj .(*PdfIndirectObject );_fcec {obj =_bfged .PdfObject ;};switch _gcc :=obj .(type ){case *PdfObjectFloat :_fdf .Log .Debug ("\u004e\u0075m\u0062\u0065\u0072\u0020\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0061\u0073\u0020\u0069\u006e\u0074e\u0067\u0065\u0072\u0020\u0077\u0061s\u0020\u0073\u0074\u006f\u0072\u0065\u0064\u0020\u0061\u0073\u0020\u0066\u006c\u006fa\u0074\u0020(\u0074\u0079\u0070\u0065 \u0063\u0061\u0073\u0074\u0069n\u0067\u0020\u0075\u0073\u0065\u0064\u0029");
return int64 (*_gcc ),nil ;case *PdfObjectInteger :return int64 (*_gcc ),nil ;};return 0,ErrNotANumber ;};func (_badb *PdfParser )parseHexString ()(*PdfObjectString ,error ){_badb ._bdg .ReadByte ();var _adfe _fda .Buffer ;for {_fefdg ,_dgfd :=_badb ._bdg .Peek (1);
if _dgfd !=nil {return MakeString (""),_dgfd ;};if _fefdg [0]=='>'{_badb ._bdg .ReadByte ();break ;};_ffdd ,_ :=_badb ._bdg .ReadByte ();if _badb ._geca {if _fda .IndexByte (_aeef ,_ffdd )==-1{_badb ._gbgad ._bbeb =true ;};};if !IsWhiteSpace (_ffdd ){_adfe .WriteByte (_ffdd );
};};if _adfe .Len ()%2==1{_badb ._gbgad ._adcc =true ;_adfe .WriteRune ('0');};_cabcc ,_ :=_e .DecodeString (_adfe .String ());return MakeHexString (string (_cabcc )),nil ;};

// TraceToDirectObject traces a PdfObject to a direct object.  For example direct objects contained
// in indirect objects (can be double referenced even).
func TraceToDirectObject (obj PdfObject )PdfObject {if _egeba ,_edag :=obj .(*PdfObjectReference );_edag {obj =_egeba .Resolve ();};_faaec ,_gdff :=obj .(*PdfIndirectObject );_beedd :=0;for _gdff {obj =_faaec .PdfObject ;_faaec ,_gdff =GetIndirect (obj );
_beedd ++;if _beedd > _efade {_fdf .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0072\u0061\u0063\u0065\u0020\u0064\u0065p\u0074\u0068\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u0062\u0065\u0079\u006fn\u0064\u0020\u0025\u0064\u0020\u002d\u0020\u006e\u006f\u0074\u0020\u0067oi\u006e\u0067\u0020\u0064\u0065\u0065\u0070\u0065\u0072\u0021",_efade );
return nil ;};};return obj ;};

// Set sets the PdfObject at index i of the array. An error is returned if the index is outside bounds.
func (_cbeg *PdfObjectArray )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_cbeg ._fadaed ){return _g .New ("\u006f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_cbeg ._fadaed [i ]=obj ;return nil ;};func (_ddb *PdfParser )lookupByNumber (_gca int ,_fef bool )(PdfObject ,bool ,error ){_efaa ,_bba :=_ddb .ObjCache [_gca ];
if _bba {_fdf .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0063a\u0063\u0068\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0025\u0064",_gca );return _efaa ,false ,nil ;};if _ddb ._eaag ==nil {_ddb ._eaag =map[int ]bool {};
};if _ddb ._eaag [_gca ]{_fdf .Log .Debug ("ER\u0052\u004f\u0052\u003a\u0020\u004c\u006fok\u0075\u0070\u0020\u006f\u0066\u0020\u0025\u0064\u0020\u0069\u0073\u0020\u0061\u006c\u0072e\u0061\u0064\u0079\u0020\u0069\u006e\u0020\u0070\u0072\u006f\u0067\u0072\u0065\u0073\u0073\u0020\u002d\u0020\u0072\u0065c\u0075\u0072\u0073\u0069\u0076\u0065 \u006c\u006f\u006f\u006b\u0075\u0070\u0020\u0061\u0074t\u0065m\u0070\u0074\u0020\u0062\u006c\u006f\u0063\u006b\u0065\u0064",_gca );
return nil ,false ,_g .New ("\u0072\u0065\u0063\u0075\u0072\u0073\u0069\u0076\u0065\u0020\u006c\u006f\u006f\u006b\u0075p\u0020a\u0074\u0074\u0065\u006d\u0070\u0074\u0020\u0062\u006c\u006f\u0063\u006b\u0065\u0064");};_ddb ._eaag [_gca ]=true ;defer delete (_ddb ._eaag ,_gca );
_cee ,_bba :=_ddb ._agec .ObjectMap [_gca ];if !_bba {_fdf .Log .Trace ("\u0055\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u006c\u006f\u0063\u0061t\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0069\u006e\u0020\u0078\u0072\u0065\u0066\u0073\u0021 \u002d\u0020\u0052\u0065\u0074u\u0072\u006e\u0069\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074");
var _eca PdfObjectNull ;return &_eca ,false ,nil ;};_fdf .Log .Trace ("L\u006fo\u006b\u0075\u0070\u0020\u006f\u0062\u006a\u0020n\u0075\u006d\u0062\u0065r \u0025\u0064",_gca );if _cee .XType ==XrefTypeTableEntry {_fdf .Log .Trace ("\u0078r\u0065f\u006f\u0062\u006a\u0020\u006fb\u006a\u0020n\u0075\u006d\u0020\u0025\u0064",_cee .ObjectNumber );
_fdf .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u0067e\u006e\u0020\u0025\u0064",_cee .Generation );_fdf .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0064",_cee .Offset );
_ddb ._dddg .Seek (_cee .Offset ,_ef .SeekStart );_ddb ._bdg =_faf .NewReader (_ddb ._dddg );_cdc ,_fee :=_ddb .ParseIndirectObject ();if _fee !=nil {_fdf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006ce\u0064\u0020\u0072\u0065\u0061\u0064\u0069n\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029",_fee );
if _fef {_fdf .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0072\u0065\u0070\u0061\u0069r\u0020\u0078\u0072\u0065\u0066\u0073\u0020\u0028\u0074\u006f\u0070\u0020d\u006f\u0077\u006e\u0029");_acb ,_bf :=_ddb .repairRebuildXrefsTopDown ();
if _bf !=nil {_fdf .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020r\u0065\u0070\u0061\u0069\u0072\u0020\u0028\u0025\u0073\u0029",_bf );return nil ,false ,_bf ;};_ddb ._agec =*_acb ;return _ddb .lookupByNumber (_gca ,false );
};return nil ,false ,_fee ;};if _fef {_bec ,_ ,_ :=_fb (_cdc );if int (_bec )!=_gca {_fdf .Log .Debug ("\u0049n\u0076\u0061\u006c\u0069d\u0020\u0078\u0072\u0065\u0066s\u003a \u0052e\u0062\u0075\u0069\u006c\u0064\u0069\u006eg");_af :=_ddb .rebuildXrefTable ();
if _af !=nil {return nil ,false ,_af ;};_ddb .ObjCache =objectCache {};return _ddb .lookupByNumberWrapper (_gca ,false );};};_fdf .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006f\u0062\u006a");_ddb .ObjCache [_gca ]=_cdc ;
return _cdc ,false ,nil ;}else if _cee .XType ==XrefTypeObjectStream {_fdf .Log .Trace ("\u0078r\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0021");_fdf .Log .Trace ("\u003e\u004c\u006f\u0061\u0064\u0020\u0076\u0069\u0061\u0020\u004f\u0053\u0021");
_fdf .Log .Trace ("\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d \u0061\u0076\u0061\u0069\u006c\u0061b\u006c\u0065\u0020\u0069\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020%\u0064\u002f\u0025\u0064",_cee .OsObjNumber ,_cee .OsObjIndex );
if _cee .OsObjNumber ==_gca {_fdf .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0043i\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065f\u0065\u0072\u0065n\u0063e\u0021\u003f\u0021");return nil ,true ,_g .New ("\u0078\u0072\u0065f \u0063\u0069\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");
};if _ ,_dbb :=_ddb ._agec .ObjectMap [_cee .OsObjNumber ];_dbb {_dgc ,_gee :=_ddb .lookupObjectViaOS (_cee .OsObjNumber ,_gca );if _gee !=nil {_fdf .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0052\u0065\u0074\u0075\u0072\u006e\u0069n\u0067\u0020\u0045\u0052\u0052\u0020\u0028\u0025\u0073\u0029",_gee );
return nil ,true ,_gee ;};_fdf .Log .Trace ("\u003c\u004c\u006f\u0061\u0064\u0065\u0064\u0020\u0076i\u0061\u0020\u004f\u0053");_ddb .ObjCache [_gca ]=_dgc ;if _ddb ._efcc !=nil {_ddb ._efcc ._bca [_dgc ]=true ;};return _dgc ,true ,nil ;};_fdf .Log .Debug ("\u003f\u003f\u0020\u0042\u0065\u006c\u006f\u006eg\u0073\u0020\u0074o \u0061\u0020\u006e\u006f\u006e\u002dc\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u002e.\u002e\u0021");
return nil ,true ,_g .New ("\u006f\u0073\u0020\u0062\u0065\u006c\u006fn\u0067\u0073\u0020t\u006f\u0020\u0061\u0020n\u006f\u006e\u0020\u0063\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074");
};return nil ,false ,_g .New ("\u0075\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0078\u0072\u0065\u0066 \u0074\u0079\u0070\u0065");};

// PdfObjectString represents the primitive PDF string object.
type PdfObjectString struct{_fea string ;_fbcbg bool ;};

// DecodeStream decodes RunLengthEncoded stream object and give back decoded bytes.
func (_fbga *RunLengthEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _fbga .DecodeBytes (streamObj .Stream );};

// DecodeStream decodes a LZW encoded stream and returns the result as a
// slice of bytes.
func (_cdeb *LZWEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_fdf .Log .Trace ("\u004c\u005a\u0057 \u0044\u0065\u0063\u006f\u0064\u0069\u006e\u0067");_fdf .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_cdeb .Predictor );
_gfga ,_dbdf :=_cdeb .DecodeBytes (streamObj .Stream );if _dbdf !=nil {return nil ,_dbdf ;};_fdf .Log .Trace ("\u0020\u0049\u004e\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (streamObj .Stream ),streamObj .Stream );_fdf .Log .Trace ("\u004f\u0055\u0054\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (_gfga ),_gfga );
if _cdeb .Predictor > 1{if _cdeb .Predictor ==2{_fdf .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_gagc :=_cdeb .Columns *_cdeb .Colors ;if _gagc < 1{return []byte {},nil ;};_afgbc :=len (_gfga )/_gagc ;
if len (_gfga )%_gagc !=0{_fdf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");
return nil ,_ae .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_gfga ),_gagc );};if _gagc %_cdeb .Colors !=0{return nil ,_ae .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_gagc ,_cdeb .Colors );
};if _gagc > len (_gfga ){_fdf .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_gagc ,len (_gfga ));
return nil ,_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_fdf .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_gfga ),_gfga );
_bgbg :=_fda .NewBuffer (nil );for _badf :=0;_badf < _afgbc ;_badf ++{_bedb :=_gfga [_gagc *_badf :_gagc *(_badf +1)];for _dfbd :=_cdeb .Colors ;_dfbd < _gagc ;_dfbd ++{_bedb [_dfbd ]=byte (int (_bedb [_dfbd ]+_bedb [_dfbd -_cdeb .Colors ])%256);};_bgbg .Write (_bedb );
};_dgbb :=_bgbg .Bytes ();_fdf .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_dgbb ),_dgbb );return _dgbb ,nil ;}else if _cdeb .Predictor >=10&&_cdeb .Predictor <=15{_fdf .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");
_bfge :=_cdeb .Columns *_cdeb .Colors +1;if _bfge < 1{return []byte {},nil ;};_gdbg :=len (_gfga )/_bfge ;if len (_gfga )%_bfge !=0{return nil ,_ae .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_gfga ),_bfge );
};if _bfge > len (_gfga ){_fdf .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_bfge ,len (_gfga ));
return nil ,_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_dbee :=_fda .NewBuffer (nil );_fdf .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_cdeb .Columns );
_fdf .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_gfga ),_bfge ,_gdbg );_edgbg :=make ([]byte ,_bfge );for _dfg :=0;_dfg < _bfge ;_dfg ++{_edgbg [_dfg ]=0;
};for _dbcd :=0;_dbcd < _gdbg ;_dbcd ++{_acfg :=_gfga [_bfge *_dbcd :_bfge *(_dbcd +1)];_gdeb :=_acfg [0];switch _gdeb {case 0:case 1:for _dgba :=2;_dgba < _bfge ;_dgba ++{_acfg [_dgba ]=byte (int (_acfg [_dgba ]+_acfg [_dgba -1])%256);};case 2:for _adbbc :=1;
_adbbc < _bfge ;_adbbc ++{_acfg [_adbbc ]=byte (int (_acfg [_adbbc ]+_edgbg [_adbbc ])%256);};default:_fdf .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0066i\u006c\u0074\u0065\u0072\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_gdeb );
return nil ,_ae .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_gdeb );};for _aebf :=0;_aebf < _bfge ;_aebf ++{_edgbg [_aebf ]=_acfg [_aebf ];};_dbee .Write (_acfg [1:]);
};_fbg :=_dbee .Bytes ();return _fbg ,nil ;}else {_fdf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_cdeb .Predictor );
return nil ,_ae .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_cdeb .Predictor );};};return _gfga ,nil ;};

// WriteString outputs the object as it is to be written to file.
func (_ddced *PdfObjectReference )WriteString ()string {var _ceca _gc .Builder ;_ceca .WriteString (_bb .FormatInt (_ddced .ObjectNumber ,10));_ceca .WriteString ("\u0020");_ceca .WriteString (_bb .FormatInt (_ddced .GenerationNumber ,10));_ceca .WriteString ("\u0020\u0052");
return _ceca .String ();};type objectStream struct{N int ;_ace []byte ;_ee map[int ]int64 ;};func (_aafa *PdfParser )parseArray ()(*PdfObjectArray ,error ){_gbcd :=MakeArray ();_aafa ._bdg .ReadByte ();for {_aafa .skipSpaces ();_bcab ,_cbbd :=_aafa ._bdg .Peek (1);
if _cbbd !=nil {return _gbcd ,_cbbd ;};if _bcab [0]==']'{_aafa ._bdg .ReadByte ();break ;};_cfaf ,_cbbd :=_aafa .parseObject ();if _cbbd !=nil {return _gbcd ,_cbbd ;};_gbcd .Append (_cfaf );};return _gbcd ,nil ;};

// DecodeStream decodes a DCT encoded stream and returns the result as a
// slice of bytes.
func (_accf *DCTEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _accf .DecodeBytes (streamObj .Stream );};

// CCITTFaxEncoder implements Group3 and Group4 facsimile (fax) encoder/decoder.
type CCITTFaxEncoder struct{K int ;EndOfLine bool ;EncodedByteAlign bool ;Columns int ;Rows int ;EndOfBlock bool ;BlackIs1 bool ;DamagedRowsBeforeError int ;};type objectCache map[int ]PdfObject ;

// UpdateParams updates the parameter values of the encoder.
func (_cdcd *RawEncoder )UpdateParams (params *PdfObjectDictionary ){};

// IsDelimiter checks if a character represents a delimiter.
func IsDelimiter (c byte )bool {return c =='('||c ==')'||c =='<'||c =='>'||c =='['||c ==']'||c =='{'||c =='}'||c =='/'||c =='%';};

// Clear resets the array to an empty state.
func (_abbd *PdfObjectArray )Clear (){_abbd ._fadaed =[]PdfObject {}};

// Decrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_gba *PdfCrypt )Decrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _gba .isDecrypted (obj ){return nil ;};switch _cfbb :=obj .(type ){case *PdfIndirectObject :_gba ._bca [_cfbb ]=true ;_fdf .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_cfbb .ObjectNumber ,_cfbb .GenerationNumber );
_bgab :=_cfbb .ObjectNumber ;_efde :=_cfbb .GenerationNumber ;_geae :=_gba .Decrypt (_cfbb .PdfObject ,_bgab ,_efde );if _geae !=nil {return _geae ;};return nil ;case *PdfObjectStream :_gba ._bca [_cfbb ]=true ;_fdd :=_cfbb .PdfObjectDictionary ;if _gba ._edf .R !=5{if _cfc ,_gfd :=_fdd .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );
_gfd &&*_cfc =="\u0058\u0052\u0065\u0066"{return nil ;};};_ddc :=_cfbb .ObjectNumber ;_abe :=_cfbb .GenerationNumber ;_fdf .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_ddc ,_abe );
_bff :=_egf ;if _gba ._cca .V >=4{_bff =_gba ._ba ;_fdf .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_gba ._ba );if _acaf ,_gef :=_fdd .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );
_gef {if _fcc ,_fbc :=GetName (_acaf .Get (0));_fbc {if *_fcc =="\u0043\u0072\u0079p\u0074"{_bff ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _bbab ,_bgf :=_fdd .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );
_bgf {if _cfca ,_dda :=_bbab .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_dda {if _ ,_gec :=_gba ._fag [string (*_cfca )];_gec {_fdf .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_cfca );
_bff =string (*_cfca );};};};};};};_fdf .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_bff );if _bff =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_becc :=_gba .Decrypt (_fdd ,_ddc ,_abe );
if _becc !=nil {return _becc ;};_dec ,_becc :=_gba .makeKey (_bff ,uint32 (_ddc ),uint32 (_abe ),_gba ._ffbf );if _becc !=nil {return _becc ;};_cfbb .Stream ,_becc =_gba .decryptBytes (_cfbb .Stream ,_bff ,_dec );if _becc !=nil {return _becc ;};_fdd .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_cfbb .Stream ))));
return nil ;case *PdfObjectString :_fdf .Log .Trace ("\u0044e\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_gcgb :=_egf ;if _gba ._cca .V >=4{_fdf .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_gba ._cb );
if _gba ._cb =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_gcgb =_gba ._cb ;};_add ,_eea :=_gba .makeKey (_gcgb ,uint32 (parentObjNum ),uint32 (parentGenNum ),_gba ._ffbf );if _eea !=nil {return _eea ;};_bfdd :=_cfbb .Str ();_dcbg :=make ([]byte ,len (_bfdd ));
for _caad :=0;_caad < len (_bfdd );_caad ++{_dcbg [_caad ]=_bfdd [_caad ];};if len (_dcbg )> 0{_fdf .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_dcbg ,_dcbg );
_dcbg ,_eea =_gba .decryptBytes (_dcbg ,_gcgb ,_add );if _eea !=nil {return _eea ;};};_cfbb ._fea =string (_dcbg );return nil ;case *PdfObjectArray :for _ ,_adc :=range _cfbb .Elements (){_befd :=_gba .Decrypt (_adc ,parentObjNum ,parentGenNum );if _befd !=nil {return _befd ;
};};return nil ;case *PdfObjectDictionary :_geg :=false ;if _egc :=_cfbb .Get ("\u0054\u0079\u0070\u0065");_egc !=nil {_acbd ,_befgd :=_egc .(*PdfObjectName );if _befgd &&*_acbd =="\u0053\u0069\u0067"{_geg =true ;};};for _ ,_fdeb :=range _cfbb .Keys (){_dcc :=_cfbb .Get (_fdeb );
if _geg &&string (_fdeb )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;};if string (_fdeb )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_fdeb )!="\u0050\u0072\u0065\u0076"&&string (_fdeb )!="\u004c\u0061\u0073\u0074"{_ece :=_gba .Decrypt (_dcc ,parentObjNum ,parentGenNum );
if _ece !=nil {return _ece ;};};};return nil ;};return nil ;};

// GetInt returns the *PdfObjectBool object that is represented by a PdfObject either directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetInt (obj PdfObject )(_fbgagd *PdfObjectInteger ,_efaed bool ){_fbgagd ,_efaed =TraceToDirectObject (obj ).(*PdfObjectInteger );return _fbgagd ,_efaed ;};

// NewASCIIHexEncoder makes a new ASCII hex encoder.
func NewASCIIHexEncoder ()*ASCIIHexEncoder {_aea :=&ASCIIHexEncoder {};return _aea };

// NewASCII85Encoder makes a new ASCII85 encoder.
func NewASCII85Encoder ()*ASCII85Encoder {_acaa :=&ASCII85Encoder {};return _acaa };func (_gbf *PdfCrypt )authenticate (_eee []byte )(bool ,error ){_gbf ._edc =false ;_bcf :=_gbf .securityHandler ();_gde ,_gce ,_edg :=_bcf .Authenticate (&_gbf ._edf ,_eee );
if _edg !=nil {return false ,_edg ;}else if _gce ==0||len (_gde )==0{return false ,nil ;};_gbf ._edc =true ;_gbf ._ffbf =_gde ;return true ,nil ;};

// GetBool returns the *PdfObjectBool object that is represented by a PdfObject directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetBool (obj PdfObject )(_daae *PdfObjectBool ,_dcbb bool ){_daae ,_dcbb =TraceToDirectObject (obj ).(*PdfObjectBool );return _daae ,_dcbb ;};

// String returns a string describing `d`.
func (_fdgg *PdfObjectDictionary )String ()string {var _beab _gc .Builder ;_beab .WriteString ("\u0044\u0069\u0063t\u0028");for _ ,_ebaff :=range _fdgg ._fgag {_gfab :=_fdgg ._acfc [_ebaff ];_beab .WriteString ("\u0022"+_ebaff .String ()+"\u0022\u003a\u0020");
_beab .WriteString (_gfab .String ());_beab .WriteString ("\u002c\u0020");};_beab .WriteString ("\u0029");return _beab .String ();};

// IsDecimalDigit checks if the character is a part of a decimal number string.
func IsDecimalDigit (c byte )bool {return '0'<=c &&c <='9'};

// PdfObjectStream represents the primitive PDF Object stream.
type PdfObjectStream struct{PdfObjectReference ;*PdfObjectDictionary ;Stream []byte ;};

// DecodeBytes decodes a multi-encoded slice of bytes by passing it through the
// DecodeBytes method of the underlying encoders.
func (_cfde *MultiEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_acda :=encoded ;var _beff error ;for _ ,_ggb :=range _cfde ._cbab {_fdf .Log .Trace ("\u004du\u006c\u0074i\u0020\u0045\u006e\u0063o\u0064\u0065\u0072 \u0044\u0065\u0063\u006f\u0064\u0065\u003a\u0020\u0041pp\u006c\u0079\u0069n\u0067\u0020F\u0069\u006c\u0074\u0065\u0072\u003a \u0025\u0076 \u0025\u0054",_ggb ,_ggb );
_acda ,_beff =_ggb .DecodeBytes (_acda );if _beff !=nil {return nil ,_beff ;};};return _acda ,nil ;};

// PdfIndirectObject represents the primitive PDF indirect object.
type PdfIndirectObject struct{PdfObjectReference ;PdfObject ;};

// Resolve resolves a PdfObject to direct object, looking up and resolving references as needed (unlike TraceToDirect).
func (_dfc *PdfParser )Resolve (obj PdfObject )(PdfObject ,error ){_cacf ,_aec :=obj .(*PdfObjectReference );if !_aec {return obj ,nil ;};_cg :=_dfc .GetFileOffset ();defer func (){_dfc .SetFileOffset (_cg )}();_dea ,_gcg :=_dfc .LookupByReference (*_cacf );
if _gcg !=nil {return nil ,_gcg ;};_bdb ,_aeg :=_dea .(*PdfIndirectObject );if !_aeg {return _dea ,nil ;};_dea =_bdb .PdfObject ;_ ,_aec =_dea .(*PdfObjectReference );if _aec {return _bdb ,_g .New ("\u006d\u0075lt\u0069\u0020\u0064e\u0070\u0074\u0068\u0020tra\u0063e \u0070\u006f\u0069\u006e\u0074\u0065\u0072 t\u006f\u0020\u0070\u006f\u0069\u006e\u0074e\u0072");
};return _dea ,nil ;};func _fcbe (_cdfg PdfObject )(*float64 ,error ){switch _gdgc :=_cdfg .(type ){case *PdfObjectFloat :_dege :=float64 (*_gdgc );return &_dege ,nil ;case *PdfObjectInteger :_ecga :=float64 (*_gdgc );return &_ecga ,nil ;case *PdfObjectNull :return nil ,nil ;
};return nil ,ErrNotANumber ;};

// MakeArray creates an PdfObjectArray from a list of PdfObjects.
func MakeArray (objects ...PdfObject )*PdfObjectArray {return &PdfObjectArray {_fadaed :objects }};

// DecodeStream implements ASCII85 stream decoding.
func (_caec *ASCII85Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _caec .DecodeBytes (streamObj .Stream );};func (_gfgad *PdfParser )seekToEOFMarker (_bfcc int64 )error {var _cega int64 ;var _dbge int64 =2048;for _cega < _bfcc -4{if _bfcc <=(_dbge +_cega ){_dbge =_bfcc -_cega ;
};_ ,_agbf :=_gfgad ._dddg .Seek (_bfcc -_cega -_dbge ,_ef .SeekStart );if _agbf !=nil {return _agbf ;};_acdab :=make ([]byte ,_dbge );_gfgad ._dddg .Read (_acdab );_fdf .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0045\u004f\u0046 \u006da\u0072\u006b\u0065\u0072\u003a\u0020\u0022%\u0073\u0022",string (_acdab ));
_fbdga :=_gdaa .FindAllStringIndex (string (_acdab ),-1);if _fbdga !=nil {_dfbg :=_fbdga [len (_fbdga )-1];_fdf .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_fbdga );_cfbc :=_bfcc -_cega -_dbge +int64 (_dfbg [0]);_gfgad ._dddg .Seek (_cfbc ,_ef .SeekStart );
return nil ;};_fdf .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");
_cega +=_dbge -4;};_fdf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006be\u0072 \u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u002e");return _edec ;};func (_bfb *PdfCrypt )loadCryptFilters (_deb *PdfObjectDictionary )error {_bfb ._fag =cryptFilters {};
_bea :=_deb .Get ("\u0043\u0046");_bea =TraceToDirectObject (_bea );if _dfb ,_def :=_bea .(*PdfObjectReference );_def {_bde ,_fgec :=_bfb ._ged .LookupByReference (*_dfb );if _fgec !=nil {_fdf .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0075\u0070\u0020\u0043\u0046\u0020\u0072\u0065\u0066\u0065\u0072en\u0063\u0065");
return _fgec ;};_bea =TraceToDirectObject (_bde );};_efc ,_gdc :=_bea .(*PdfObjectDictionary );if !_gdc {_fdf .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0043\u0046\u002c \u0074\u0079\u0070\u0065: \u0025\u0054",_bea );return _g .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0043\u0046");
};for _ ,_cde :=range _efc .Keys (){_ege :=_efc .Get (_cde );if _dbd ,_bad :=_ege .(*PdfObjectReference );_bad {_cdg ,_gcd :=_bfb ._ged .LookupByReference (*_dbd );if _gcd !=nil {_fdf .Log .Debug ("\u0045\u0072ro\u0072\u0020\u006co\u006f\u006b\u0075\u0070 up\u0020di\u0063\u0074\u0069\u006f\u006e\u0061\u0072y \u0072\u0065\u0066\u0065\u0072\u0065\u006ec\u0065");
return _gcd ;};_ege =TraceToDirectObject (_cdg );};_caba ,_fcg :=_ege .(*PdfObjectDictionary );if !_fcg {return _ae .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074\u0020\u0069\u006e \u0043\u0046\u0020\u0028\u006e\u0061\u006d\u0065\u0020\u0025\u0073\u0029\u0020-\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079\u0020\u0062\u0075\u0074\u0020\u0025\u0054",_cde ,_ege );
};if _cde =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{_fdf .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u002d\u0020\u0043\u0061\u006e\u006e\u006f\u0074\u0020\u006f\u0076\u0065\u0072\u0077r\u0069\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0069d\u0065\u006e\u0074\u0069\u0074\u0079\u0020\u0066\u0069\u006c\u0074\u0065\u0072 \u002d\u0020\u0054\u0072\u0079\u0069n\u0067\u0020\u006ee\u0078\u0074");
continue ;};var _dbc _fg .FilterDict ;if _dgf :=_geee (&_dbc ,_caba );_dgf !=nil {return _dgf ;};_befg ,_ecfd :=_fg .NewFilter (_dbc );if _ecfd !=nil {return _ecfd ;};_bfb ._fag [string (_cde )]=_befg ;};_bfb ._fag ["\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"]=_fg .NewIdentity ();
_bfb ._cb ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _bfd ,_ecae :=_deb .Get ("\u0053\u0074\u0072\u0046").(*PdfObjectName );_ecae {if _ ,_acf :=_bfb ._fag [string (*_bfd )];!_acf {return _ae .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u0072\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_bfd );
};_bfb ._cb =string (*_bfd );};_bfb ._ba ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _ebea ,_deaa :=_deb .Get ("\u0053\u0074\u006d\u0046").(*PdfObjectName );_deaa {if _ ,_dbg :=_bfb ._fag [string (*_ebea )];!_dbg {return _ae .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u006d\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_ebea );
};_bfb ._ba =string (*_ebea );};return nil ;};func _dbad (_cdec ,_cdfee PdfObject ,_aaaa int )bool {if _aaaa > _efade {_fdf .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_efade );
return false ;};if _cdec ==nil &&_cdfee ==nil {return true ;}else if _cdec ==nil ||_cdfee ==nil {return false ;};if _b .TypeOf (_cdec )!=_b .TypeOf (_cdfee ){return false ;};switch _bfee :=_cdec .(type ){case *PdfObjectNull ,*PdfObjectReference :return true ;
case *PdfObjectName :return *_bfee ==*(_cdfee .(*PdfObjectName ));case *PdfObjectString :return *_bfee ==*(_cdfee .(*PdfObjectString ));case *PdfObjectInteger :return *_bfee ==*(_cdfee .(*PdfObjectInteger ));case *PdfObjectBool :return *_bfee ==*(_cdfee .(*PdfObjectBool ));
case *PdfObjectFloat :return *_bfee ==*(_cdfee .(*PdfObjectFloat ));case *PdfIndirectObject :return _dbad (TraceToDirectObject (_cdec ),TraceToDirectObject (_cdfee ),_aaaa +1);case *PdfObjectArray :_cgbea :=_cdfee .(*PdfObjectArray );if len ((*_bfee )._fadaed )!=len ((*_cgbea )._fadaed ){return false ;
};for _bcabe ,_adace :=range (*_bfee )._fadaed {if !_dbad (_adace ,(*_cgbea )._fadaed [_bcabe ],_aaaa +1){return false ;};};return true ;case *PdfObjectDictionary :_cegaf :=_cdfee .(*PdfObjectDictionary );_adfdb ,_ddbc :=(*_bfee )._acfc ,(*_cegaf )._acfc ;
if len (_adfdb )!=len (_ddbc ){return false ;};for _fcbb ,_baggb :=range _adfdb {_cgcg ,_egbf :=_ddbc [_fcbb ];if !_egbf ||!_dbad (_baggb ,_cgcg ,_aaaa +1){return false ;};};return true ;case *PdfObjectStream :_fbda :=_cdfee .(*PdfObjectStream );return _dbad ((*_bfee ).PdfObjectDictionary ,(*_fbda ).PdfObjectDictionary ,_aaaa +1);
default:_fdf .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",_cdec );
};return false ;};func (_efe *PdfCrypt )decryptBytes (_dbbe []byte ,_fdgc string ,_edgb []byte )([]byte ,error ){_fdf .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");_cfb ,_cag :=_efe ._fag [_fdgc ];if !_cag {return nil ,_ae .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_fdgc );
};return _cfb .DecryptBytes (_dbbe ,_edgb );};func (_aece *PdfParser )repairSeekXrefMarker ()error {_gggg ,_bbeg :=_aece ._dddg .Seek (0,_ef .SeekEnd );if _bbeg !=nil {return _bbeg ;};_cecf :=_ge .MustCompile ("\u005cs\u0078\u0072\u0065\u0066\u005c\u0073*");
var _fdef int64 ;var _adcgcf int64 =1000;for _fdef < _gggg {if _gggg <=(_adcgcf +_fdef ){_adcgcf =_gggg -_fdef ;};_ ,_gagf :=_aece ._dddg .Seek (-_fdef -_adcgcf ,_ef .SeekEnd );if _gagf !=nil {return _gagf ;};_gaag :=make ([]byte ,_adcgcf );_aece ._dddg .Read (_gaag );
_fdf .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0078\u0072\u0065\u0066\u0020\u003a\u0020\u0022\u0025\u0073\u0022",string (_gaag ));_egecg :=_cecf .FindAllStringIndex (string (_gaag ),-1);if _egecg !=nil {_ggge :=_egecg [len (_egecg )-1];
_fdf .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_egecg );_aece ._dddg .Seek (-_fdef -_adcgcf +int64 (_ggge [0]),_ef .SeekEnd );_aece ._bdg =_faf .NewReader (_aece ._dddg );for {_ebegc ,_bbgg :=_aece ._bdg .Peek (1);if _bbgg !=nil {return _bbgg ;
};_fdf .Log .Trace ("\u0042\u003a\u0020\u0025\u0064\u0020\u0025\u0063",_ebegc [0],_ebegc [0]);if !IsWhiteSpace (_ebegc [0]){break ;};_aece ._bdg .Discard (1);};return nil ;};_fdf .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");
_fdef +=_adcgcf ;};_fdf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074a\u0062\u006c\u0065\u0020\u006d\u0061r\u006b\u0065\u0072\u0020\u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066o\u0075\u006e\u0064\u002e");
return _g .New ("\u0078r\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0020");};

// WriteString outputs the object as it is to be written to file.
func (_dafdf *PdfObjectStream )WriteString ()string {var _adfa _gc .Builder ;_adfa .WriteString (_bb .FormatInt (_dafdf .ObjectNumber ,10));_adfa .WriteString ("\u0020\u0030\u0020\u0052");return _adfa .String ();};

// String returns a descriptive information string about the encryption method used.
func (_ead *PdfCrypt )String ()string {if _ead ==nil {return "";};_feb :=_ead ._cca .Filter +"\u0020\u002d\u0020";if _ead ._cca .V ==0{_feb +="\u0055\u006e\u0064\u006fcu\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0061\u006c\u0067\u006f\u0072\u0069\u0074h\u006d";
}else if _ead ._cca .V ==1{_feb +="\u0052\u0043\u0034:\u0020\u0034\u0030\u0020\u0062\u0069\u0074\u0073";}else if _ead ._cca .V ==2{_feb +=_ae .Sprintf ("\u0052\u0043\u0034:\u0020\u0025\u0064\u0020\u0062\u0069\u0074\u0073",_ead ._cca .Length );}else if _ead ._cca .V ==3{_feb +="U\u006e\u0070\u0075\u0062li\u0073h\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d";
}else if _ead ._cca .V >=4{_feb +=_ae .Sprintf ("\u0053\u0074r\u0065\u0061\u006d\u0020f\u0069\u006ct\u0065\u0072\u003a\u0020\u0025\u0073\u0020\u002d \u0053\u0074\u0072\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0074\u0065r\u003a\u0020\u0025\u0073",_ead ._ba ,_ead ._cb );
_feb +="\u003b\u0020C\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0073\u003a";for _dbbd ,_fdcc :=range _ead ._fag {_feb +=_ae .Sprintf ("\u0020\u002d\u0020\u0025\u0073\u003a\u0020\u0025\u0073 \u0028\u0025\u0064\u0029",_dbbd ,_fdcc .Name (),_fdcc .KeyLength ());
};};_cge :=_ead .GetAccessPermissions ();_feb +=_ae .Sprintf ("\u0020\u002d\u0020\u0025\u0023\u0076",_cge );return _feb ;};

// IsPrintable checks if a character is printable.
// Regular characters that are outside the range EXCLAMATION MARK(21h)
// (!) to TILDE (7Eh) (~) should be written using the hexadecimal notation.
func IsPrintable (c byte )bool {return 0x21<=c &&c <=0x7E};

// GetString returns the *PdfObjectString represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetString (obj PdfObject )(_befdf *PdfObjectString ,_ceag bool ){_befdf ,_ceag =TraceToDirectObject (obj ).(*PdfObjectString );return _befdf ,_ceag ;};

// EncodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_egfcc *RawEncoder )EncodeBytes (data []byte )([]byte ,error ){return data ,nil };

// GetObjectNums returns a sorted list of object numbers of the PDF objects in the file.
func (_febab *PdfParser )GetObjectNums ()[]int {var _bgcbd []int ;for _ ,_gdgb :=range _febab ._agec .ObjectMap {_bgcbd =append (_bgcbd ,_gdgb .ObjectNumber );};_c .Ints (_bgcbd );return _bgcbd ;};func _bfg (_gad *PdfObjectStream ,_bce *PdfObjectDictionary )(*FlateEncoder ,error ){_bbb :=NewFlateEncoder ();
_cffg :=_gad .PdfObjectDictionary ;if _cffg ==nil {return _bbb ,nil ;};_bbb ._fgb =_gcce (_cffg );if _bce ==nil {_gaf :=TraceToDirectObject (_cffg .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));switch _ddd :=_gaf .(type ){case *PdfObjectArray :if _ddd .Len ()!=1{_fdf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072:\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020a\u0072\u0072\u0061\u0079\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0021\u003d\u0020\u0031\u0020\u0028\u0025\u0064\u0029",_ddd .Len ());
return nil ,_g .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};if _cae ,_dbe :=GetDict (_ddd .Get (0));_dbe {_bce =_cae ;};case *PdfObjectDictionary :_bce =_ddd ;case *PdfObjectNull ,nil :default:_fdf .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020n\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079 \u0028%\u0054\u0029",_gaf );
return nil ,_ae .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _bce ==nil {return _bbb ,nil ;};_fdf .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_bce .String ());
_aae :=_bce .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");if _aae ==nil {_fdf .Log .Debug ("E\u0072\u0072o\u0072\u003a\u0020\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067 \u0066\u0072\u006f\u006d\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073 \u002d\u0020\u0043\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020\u0077\u0069t\u0068\u0020\u0064\u0065\u0066\u0061\u0075\u006c\u0074\u0020\u00281\u0029");
}else {_badd ,_feg :=_aae .(*PdfObjectInteger );if !_feg {_fdf .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_aae );
return nil ,_ae .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_bbb .Predictor =int (*_badd );};_aae =_bce .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");
if _aae !=nil {_ecff ,_efbd :=_aae .(*PdfObjectInteger );if !_efbd {_fdf .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");
return nil ,_ae .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_bbb .BitsPerComponent =int (*_ecff );};if _bbb .Predictor > 1{_bbb .Columns =1;_aae =_bce .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");
if _aae !=nil {_daec ,_face :=_aae .(*PdfObjectInteger );if !_face {return nil ,_ae .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_bbb .Columns =int (*_daec );
};_bbb .Colors =1;_aae =_bce .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _aae !=nil {_ffe ,_ffcg :=_aae .(*PdfObjectInteger );if !_ffcg {return nil ,_ae .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");
};_bbb .Colors =int (*_ffe );};};return _bbb ,nil ;};

// DecodeBytes decodes a byte slice from Run length encoding.
//
// 7.4.5 RunLengthDecode Filter
// The RunLengthDecode filter decodes data that has been encoded in a simple byte-oriented format based on run length.
// The encoded data shall be a sequence of runs, where each run shall consist of a length byte followed by 1 to 128
// bytes of data. If the length byte is in the range 0 to 127, the following length + 1 (1 to 128) bytes shall be
// copied literally during decompression. If length is in the range 129 to 255, the following single byte shall be
// copied 257 - length (2 to 128) times during decompression. A length value of 128 shall denote EOD.
func (_geed *RunLengthEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_eabe :=_fda .NewReader (encoded );var _baga []byte ;for {_cef ,_ffcb :=_eabe .ReadByte ();if _ffcb !=nil {return nil ,_ffcb ;};if _cef > 128{_afcf ,_aceg :=_eabe .ReadByte ();
if _aceg !=nil {return nil ,_aceg ;};for _acdba :=0;_acdba < 257-int (_cef );_acdba ++{_baga =append (_baga ,_afcf );};}else if _cef < 128{for _cabb :=0;_cabb < int (_cef )+1;_cabb ++{_cfee ,_egca :=_eabe .ReadByte ();if _egca !=nil {return nil ,_egca ;
};_baga =append (_baga ,_cfee );};}else {break ;};};return _baga ,nil ;};var _dgafe =_ge .MustCompile ("\u005e\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");func _bfeae (_bggd PdfObject ,_fgaae int ,_cebe map[PdfObject ]struct{})error {_fdf .Log .Trace ("\u0054\u0072\u0061\u0076\u0065\u0072s\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0064\u0061\u0074\u0061 \u0028\u0064\u0065\u0070\u0074\u0068\u0020=\u0020\u0025\u0064\u0029",_fgaae );
if _ ,_dfab :=_cebe [_bggd ];_dfab {_fdf .Log .Trace ("-\u0041\u006c\u0072\u0065ad\u0079 \u0074\u0072\u0061\u0076\u0065r\u0073\u0065\u0064\u002e\u002e\u002e");return nil ;};_cebe [_bggd ]=struct{}{};switch _gdccg :=_bggd .(type ){case *PdfIndirectObject :_aabca :=_gdccg ;
_fdf .Log .Trace ("\u0069\u006f\u003a\u0020\u0025\u0073",_aabca );_fdf .Log .Trace ("\u002d\u0020\u0025\u0073",_aabca .PdfObject );return _bfeae (_aabca .PdfObject ,_fgaae +1,_cebe );case *PdfObjectStream :_geacg :=_gdccg ;return _bfeae (_geacg .PdfObjectDictionary ,_fgaae +1,_cebe );
case *PdfObjectDictionary :_ccffe :=_gdccg ;_fdf .Log .Trace ("\u002d\u0020\u0064\u0069\u0063\u0074\u003a\u0020\u0025\u0073",_ccffe );for _ ,_ffeb :=range _ccffe .Keys (){_acee :=_ccffe .Get (_ffeb );if _eefd ,_egba :=_acee .(*PdfObjectReference );_egba {_beeea :=_eefd .Resolve ();
_ccffe .Set (_ffeb ,_beeea );_dacbd :=_bfeae (_beeea ,_fgaae +1,_cebe );if _dacbd !=nil {return _dacbd ;};}else {_ddeeg :=_bfeae (_acee ,_fgaae +1,_cebe );if _ddeeg !=nil {return _ddeeg ;};};};return nil ;case *PdfObjectArray :_ffccg :=_gdccg ;_fdf .Log .Trace ("-\u0020\u0061\u0072\u0072\u0061\u0079\u003a\u0020\u0025\u0073",_ffccg );
for _egbg ,_eacbg :=range _ffccg .Elements (){if _aaeea ,_bccb :=_eacbg .(*PdfObjectReference );_bccb {_fdbbg :=_aaeea .Resolve ();_ffccg .Set (_egbg ,_fdbbg );_gccb :=_bfeae (_fdbbg ,_fgaae +1,_cebe );if _gccb !=nil {return _gccb ;};}else {_cgcb :=_bfeae (_eacbg ,_fgaae +1,_cebe );
if _cgcb !=nil {return _cgcb ;};};};return nil ;case *PdfObjectReference :_fdf .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020T\u0072\u0061\u0063\u0069\u006e\u0067\u0020\u0061\u0020r\u0065\u0066\u0065r\u0065n\u0063\u0065\u0021");return _g .New ("\u0065r\u0072\u006f\u0072\u0020t\u0072\u0061\u0063\u0069\u006eg\u0020a\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");
};return nil ;};

// GetFilterName returns the name of the encoding filter.
func (_dgbf *ASCIIHexEncoder )GetFilterName ()string {return StreamEncodingFilterNameASCIIHex };

// GetName returns the *PdfObjectName represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetName (obj PdfObject )(_fbedf *PdfObjectName ,_fgfb bool ){_fbedf ,_fgfb =TraceToDirectObject (obj ).(*PdfObjectName );return _fbedf ,_fgfb ;};

// WriteString outputs the object as it is to be written to file.
func (_eceeb *PdfObjectDictionary )WriteString ()string {var _dfae _gc .Builder ;_dfae .WriteString ("\u003c\u003c");for _ ,_eddac :=range _eceeb ._fgag {_fgcf :=_eceeb ._acfc [_eddac ];_dfae .WriteString (_eddac .WriteString ());_dfae .WriteString ("\u0020");
_dfae .WriteString (_fgcf .WriteString ());};_dfae .WriteString ("\u003e\u003e");return _dfae .String ();};

// GetXrefTable returns the PDFs xref table.
func (_fdge *PdfParser )GetXrefTable ()XrefTable {return _fdge ._agec };

// MakeArrayFromFloats creates an PdfObjectArray from a slice of float64s, where each array element is an
// PdfObjectFloat.
func MakeArrayFromFloats (vals []float64 )*PdfObjectArray {_bdfe :=MakeArray ();for _ ,_fgfg :=range vals {_bdfe .Append (MakeFloat (_fgfg ));};return _bdfe ;};

// DrawableImage is same as golang image/draw's Image interface that allow drawing images.
type DrawableImage interface{ColorModel ()_gf .Model ;Bounds ()_bd .Rectangle ;At (_bbea ,_eaca int )_gf .Color ;Set (_babcd ,_ffbc int ,_eeadb _gf .Color );};

// Seek implementation of Seek interface.
func (_edda *limitedReadSeeker )Seek (offset int64 ,whence int )(int64 ,error ){var _fdfd int64 ;switch whence {case _ef .SeekStart :_fdfd =offset ;case _ef .SeekCurrent :_effa ,_dbed :=_edda ._aee .Seek (0,_ef .SeekCurrent );if _dbed !=nil {return 0,_dbed ;
};_fdfd =_effa +offset ;case _ef .SeekEnd :_fdfd =_edda ._ddg +offset ;};if _gbeaba :=_edda .getError (_fdfd );_gbeaba !=nil {return 0,_gbeaba ;};if _ ,_cdcdg :=_edda ._aee .Seek (_fdfd ,_ef .SeekStart );_cdcdg !=nil {return 0,_cdcdg ;};return _fdfd ,nil ;
};

// ParseDict reads and parses a PDF dictionary object enclosed with '<<' and '>>'
func (_ggdc *PdfParser )ParseDict ()(*PdfObjectDictionary ,error ){_fdf .Log .Trace ("\u0052\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020D\u0069\u0063\u0074\u0021");_bfbbe :=MakeDict ();_bfbbe ._bdeae =_ggdc ;_edce ,_ :=_ggdc ._bdg .ReadByte ();
if _edce !='<'{return nil ,_g .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");};_edce ,_ =_ggdc ._bdg .ReadByte ();if _edce !='<'{return nil ,_g .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");};
for {_ggdc .skipSpaces ();_ggdc .skipComments ();_aafd ,_dfgb :=_ggdc ._bdg .Peek (2);if _dfgb !=nil {return nil ,_dfgb ;};_fdf .Log .Trace ("D\u0069c\u0074\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_aafd ),string (_aafd ));
if (_aafd [0]=='>')&&(_aafd [1]=='>'){_fdf .Log .Trace ("\u0045\u004f\u0046\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");_ggdc ._bdg .ReadByte ();_ggdc ._bdg .ReadByte ();break ;};_fdf .Log .Trace ("\u0050a\u0072s\u0065\u0020\u0074\u0068\u0065\u0020\u006e\u0061\u006d\u0065\u0021");
_facg ,_dfgb :=_ggdc .parseName ();_fdf .Log .Trace ("\u004be\u0079\u003a\u0020\u0025\u0073",_facg );if _dfgb !=nil {_fdf .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0052e\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006ea\u006d\u0065\u0020e\u0072r\u0020\u0025\u0073",_dfgb );
return nil ,_dfgb ;};if len (_facg )> 4&&_facg [len (_facg )-4:]=="\u006e\u0075\u006c\u006c"{_agaga :=_facg [0:len (_facg )-4];_fdf .Log .Debug ("\u0054\u0061\u006b\u0069n\u0067\u0020\u0063\u0061\u0072\u0065\u0020\u006f\u0066\u0020n\u0075l\u006c\u0020\u0062\u0075\u0067\u0020\u0028%\u0073\u0029",_facg );
_fdf .Log .Debug ("\u004e\u0065\u0077\u0020ke\u0079\u0020\u0022\u0025\u0073\u0022\u0020\u003d\u0020\u006e\u0075\u006c\u006c",_agaga );_ggdc .skipSpaces ();_ffacg ,_ :=_ggdc ._bdg .Peek (1);if _ffacg [0]=='/'{_bfbbe .Set (_agaga ,MakeNull ());continue ;
};};_ggdc .skipSpaces ();_dgcae ,_dfgb :=_ggdc .parseObject ();if _dfgb !=nil {return nil ,_dfgb ;};_bfbbe .Set (_facg ,_dgcae );if _fdf .Log .IsLogLevel (_fdf .LogLevelTrace ){_fdf .Log .Trace ("\u0064\u0069\u0063\u0074\u005b\u0025\u0073\u005d\u0020\u003d\u0020\u0025\u0073",_facg ,_dgcae .String ());
};};_fdf .Log .Trace ("\u0072\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020\u0044\u0069\u0063\u0074\u0021");return _bfbbe ,nil ;};

// GetFilterName returns the name of the encoding filter.
func (_bafg *JBIG2Encoder )GetFilterName ()string {return StreamEncodingFilterNameJBIG2 };

// EncodeBytes JPX encodes the passed in slice of bytes.
func (_dfda *JPXEncoder )EncodeBytes (data []byte )([]byte ,error ){_fdf .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_dfda .GetFilterName ());
return data ,ErrNoJPXDecode ;};

// GetFileOffset returns the current file offset, accounting for buffered position.
func (_bdfc *PdfParser )GetFileOffset ()int64 {_edfa ,_ :=_bdfc ._dddg .Seek (0,_ef .SeekCurrent );_edfa -=int64 (_bdfc ._bdg .Buffered ());return _edfa ;};

// PdfObject is an interface which all primitive PDF objects must implement.
type PdfObject interface{

// String outputs a string representation of the primitive (for debugging).
String ()string ;

// WriteString outputs the PDF primitive as written to file as expected by the standard.
// TODO(dennwc): it should return a byte slice, or accept a writer
WriteString ()string ;};

// CheckAccessRights checks access rights and permissions for a specified password. If either user/owner password is
// specified, full rights are granted, otherwise the access rights are specified by the Permissions flag.
//
// The bool flag indicates that the user can access and view the file.
// The AccessPermissions shows what access the user has for editing etc.
// An error is returned if there was a problem performing the authentication.
func (_cdbf *PdfParser )CheckAccessRights (password []byte )(bool ,_gdb .Permissions ,error ){if _cdbf ._efcc ==nil {return true ,_gdb .PermOwner ,nil ;};return _cdbf ._efcc .checkAccessRights (password );};

// HeaderPosition gets the file header position.
func (_dccca ParserMetadata )HeaderPosition ()int {return _dccca ._gaee };func (_deaaf *JBIG2Image )toBitmap ()(_eaad *_ec .Bitmap ,_dgga error ){const _gfaee ="\u004a\u0042\u0049\u00472I\u006d\u0061\u0067\u0065\u002e\u0074\u006f\u0042\u0069\u0074\u006d\u0061\u0070";
if _deaaf .Data ==nil {return nil ,_cd .Error (_gfaee ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");};if _deaaf .Width ==0||_deaaf .Height ==0{return nil ,_cd .Error (_gfaee ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");
};if _deaaf .HasPadding {_eaad ,_dgga =_ec .NewWithData (_deaaf .Width ,_deaaf .Height ,_deaaf .Data );}else {_eaad ,_dgga =_ec .NewWithUnpaddedData (_deaaf .Width ,_deaaf .Height ,_deaaf .Data );};if _dgga !=nil {return nil ,_cd .Wrap (_dgga ,_gfaee ,"");
};return _eaad ,nil ;};

// ToGoImage converts the JBIG2Image to the golang image.Image.
func (_dcag *JBIG2Image )ToGoImage ()(_bd .Image ,error ){const _dffef ="J\u0042I\u0047\u0032\u0049\u006d\u0061\u0067\u0065\u002eT\u006f\u0047\u006f\u0049ma\u0067\u0065";if _dcag .Data ==nil {return nil ,_cd .Error (_dffef ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");
};if _dcag .Width ==0||_dcag .Height ==0{return nil ,_cd .Error (_dffef ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");
};_gfag ,_eefe :=_gg .NewImage (_dcag .Width ,_dcag .Height ,1,1,_dcag .Data ,nil ,nil );if _eefe !=nil {return nil ,_eefe ;};return _gfag ,nil ;};

// PdfObjectDictionary represents the primitive PDF dictionary/map object.
type PdfObjectDictionary struct{_acfc map[PdfObjectName ]PdfObject ;_fgag []PdfObjectName ;_bebfa *_a .Mutex ;_bdeae *PdfParser ;};