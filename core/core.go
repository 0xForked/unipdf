//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package core defines and implements the primitive PDF object types in golang, and provides functionality
// for parsing those from a PDF file stream. This includes I/O handling, cross references, repairs, encryption,
// encoding and other core capabilities.
package core ;import (_fc "bufio";_gb "bytes";_eg "compress/lzw";_ae "compress/zlib";_ab "crypto/md5";_fa "crypto/rand";_cb "encoding/hex";_ca "errors";_f "fmt";_fcb "github.com/unidoc/unipdf/v3/common";_ff "github.com/unidoc/unipdf/v3/core/security";_gbb "github.com/unidoc/unipdf/v3/core/security/crypt";_de "github.com/unidoc/unipdf/v3/internal/ccittfax";_bed "github.com/unidoc/unipdf/v3/internal/imageutil";_ga "github.com/unidoc/unipdf/v3/internal/jbig2";_be "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_ead "github.com/unidoc/unipdf/v3/internal/jbig2/decoder";_dee "github.com/unidoc/unipdf/v3/internal/jbig2/document";_ef "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_gc "github.com/unidoc/unipdf/v3/internal/strutils";_dec "golang.org/x/image/tiff/lzw";_d "image";_a "image/color";_ee "image/jpeg";_ce "io";_g "os";_b "reflect";_cd "regexp";_cad "sort";_e "strconv";_ceg "strings";_ea "time";);

// WriteString outputs the object as it is to be written to file.
func (_cbbb *PdfObjectInteger )WriteString ()string {return _e .FormatInt (int64 (*_cbbb ),10)};

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_cbbd *FlateEncoder )EncodeBytes (data []byte )([]byte ,error ){if _cbbd .Predictor !=1&&_cbbd .Predictor !=11{_fcb .Log .Debug ("E\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0046\u006c\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065r\u0020P\u0072\u0065\u0064\u0069c\u0074\u006fr\u0020\u003d\u0020\u0031\u002c\u0020\u0031\u0031\u0020\u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");return nil ,ErrUnsupportedEncodingParameters ;};if _cbbd .Predictor ==11{_baagg :=int (_cbbd .Columns );_dccf :=len (data )/_baagg ;if len (data )%_baagg !=0{_fcb .Log .Error ("\u0049n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");return nil ,_ca .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");};_ffb :=_gb .NewBuffer (nil );_fbee :=make ([]byte ,_baagg );for _gce :=0;_gce < _dccf ;_gce ++{_dbeab :=data [_baagg *_gce :_baagg *(_gce +1)];_fbee [0]=_dbeab [0];for _ffgb :=1;_ffgb < _baagg ;_ffgb ++{_fbee [_ffgb ]=byte (int (_dbeab [_ffgb ]-_dbeab [_ffgb -1])%256);};_ffb .WriteByte (1);_ffb .Write (_fbee );};data =_ffb .Bytes ();};var _dgb _gb .Buffer ;_dbdd :=_ae .NewWriter (&_dgb );_dbdd .Write (data );_dbdd .Close ();return _dgb .Bytes (),nil ;};

// String returns a string representation of `name`.
func (_efceb *PdfObjectName )String ()string {return string (*_efceb )};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_gbdd *RawEncoder )MakeDecodeParams ()PdfObject {return nil };

// JBIG2Image is the image structure used by the jbig2 encoder. Its Data must be in a
// 1 bit per component and 1 component per pixel (1bpp). In order to create binary image
// use GoImageToJBIG2 function. If the image data contains the row bytes padding set the HasPadding to true.
type JBIG2Image struct{

// Width and Height defines the image boundaries.
Width ,Height int ;

// Data is the byte slice data for the input image
Data []byte ;

// HasPadding is the attribute that defines if the last byte of the data in the row contains
// 0 bits padding.
HasPadding bool ;};func (_ggfc *PdfParser )parseName ()(PdfObjectName ,error ){var _bedf _gb .Buffer ;_ecg :=false ;for {_ffaed ,_edc :=_ggfc ._aggcb .Peek (1);if _edc ==_ce .EOF {break ;};if _edc !=nil {return PdfObjectName (_bedf .String ()),_edc ;};if !_ecg {if _ffaed [0]=='/'{_ecg =true ;_ggfc ._aggcb .ReadByte ();}else if _ffaed [0]=='%'{_ggfc .readComment ();_ggfc .skipSpaces ();}else {_fcb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020N\u0061\u006d\u0065\u0020\u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020w\u0069\u0074\u0068\u0020\u0025\u0073\u0020(\u0025\u0020\u0078\u0029",_ffaed ,_ffaed );return PdfObjectName (_bedf .String ()),_f .Errorf ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u006ea\u006d\u0065:\u0020\u0028\u0025\u0063\u0029",_ffaed [0]);};}else {if IsWhiteSpace (_ffaed [0]){break ;}else if (_ffaed [0]=='/')||(_ffaed [0]=='[')||(_ffaed [0]=='(')||(_ffaed [0]==']')||(_ffaed [0]=='<')||(_ffaed [0]=='>'){break ;}else if _ffaed [0]=='#'{_ccda ,_dcabd :=_ggfc ._aggcb .Peek (3);if _dcabd !=nil {return PdfObjectName (_bedf .String ()),_dcabd ;};_gdbac ,_dcabd :=_cb .DecodeString (string (_ccda [1:3]));if _dcabd !=nil {_fcb .Log .Debug ("\u0045\u0052\u0052\u004fR\u003a\u0020\u0049\u006ev\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0066o\u006c\u006co\u0077\u0069\u006e\u0067 \u0027\u0023\u0027\u002c \u0063\u006f\u006e\u0074\u0069n\u0075\u0069\u006e\u0067\u0020\u0075\u0073i\u006e\u0067\u0020\u006c\u0069t\u0065\u0072\u0061\u006c\u0020\u002d\u0020\u004f\u0075t\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074");_bedf .WriteByte ('#');_ggfc ._aggcb .Discard (1);continue ;};_ggfc ._aggcb .Discard (3);_bedf .Write (_gdbac );}else {_baggg ,_ :=_ggfc ._aggcb .ReadByte ();_bedf .WriteByte (_baggg );};};};return PdfObjectName (_bedf .String ()),nil ;};func _aebb (_ecfc int )int {_eed :=_ecfc >>(_deaf -1);return (_ecfc ^_eed )-_eed };func (_ebca *PdfParser )parsePdfVersion ()(int ,int ,error ){var _aadb int64 =20;_ddfc :=make ([]byte ,_aadb );_ebca ._dgcfc .Seek (0,_g .SEEK_SET );_ebca ._dgcfc .Read (_ddfc );var _caee error ;var _afbec ,_gbad int ;if _ggea :=_ccb .FindStringSubmatch (string (_ddfc ));len (_ggea )< 3{if _afbec ,_gbad ,_caee =_ebca .seekPdfVersionTopDown ();_caee !=nil {_fcb .Log .Debug ("F\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065\u0063\u006f\u0076\u0065\u0072\u0079\u0020\u002d\u0020\u0075n\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0066\u0069nd\u0020\u0076\u0065r\u0073i\u006f\u006e");return 0,0,_caee ;};_ebca ._dgcfc ,_caee =_aabf (_ebca ._dgcfc ,_ebca .GetFileOffset ()-8);if _caee !=nil {return 0,0,_caee ;};}else {if _afbec ,_caee =_e .Atoi (_ggea [1]);_caee !=nil {return 0,0,_caee ;};if _gbad ,_caee =_e .Atoi (_ggea [2]);_caee !=nil {return 0,0,_caee ;};_ebca .SetFileOffset (0);};_ebca ._aggcb =_fc .NewReader (_ebca ._dgcfc );_fcb .Log .Debug ("\u0050\u0064\u0066\u0020\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020%\u0064\u002e\u0025\u0064",_afbec ,_gbad );return _afbec ,_gbad ,nil ;};

// EncodeBytes encodes slice of bytes into JBIG2 encoding format.
// The input 'data' must be an image. In order to Decode it a user is responsible to
// load the codec ('png', 'jpg').
// Returns jbig2 single page encoded document byte slice. The encoder uses DefaultPageSettings
// to encode given image.
func (_ccee *JBIG2Encoder )EncodeBytes (data []byte )([]byte ,error ){const _cfdfe ="\u004aB\u0049\u0047\u0032\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002eE\u006e\u0063\u006f\u0064\u0065\u0042\u0079\u0074\u0065\u0073";if _ccee .ColorComponents !=1||_ccee .BitsPerComponent !=1{return nil ,_ef .Errorf (_cfdfe ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u002e\u0020\u004a\u0042\u0049G\u0032\u0020E\u006e\u0063o\u0064\u0065\u0072\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020bi\u006e\u0061\u0072\u0079\u0020\u0069\u006d\u0061\u0067e\u0073\u0020\u0064\u0061\u0074\u0061");};var (_abgg *_be .Bitmap ;_gde error ;);_ggaf :=(_ccee .Width *_ccee .Height )==len (data );if _ggaf {_abgg ,_gde =_be .NewWithUnpaddedData (_ccee .Width ,_ccee .Height ,data );}else {_abgg ,_gde =_be .NewWithData (_ccee .Width ,_ccee .Height ,data );};if _gde !=nil {return nil ,_gde ;};_ggdf :=_ccee .DefaultPageSettings ;if _gde =_ggdf .Validate ();_gde !=nil {return nil ,_ef .Wrap (_gde ,_cfdfe ,"");};switch _ggdf .Compression {case JB2Generic :if _gde =_ccee ._bbbed .AddGenericPage (_abgg ,_ggdf .DuplicatedLinesRemoval );_gde !=nil {return nil ,_ef .Wrap (_gde ,_cfdfe ,"");};case JB2SymbolCorrelation :return nil ,_ef .Error (_cfdfe ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");case JB2SymbolRankHaus :return nil ,_ef .Error (_cfdfe ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");default:return nil ,_ef .Error (_cfdfe ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return _ccee .Encode ();};

// PdfObjectInteger represents the primitive PDF integer numerical object.
type PdfObjectInteger int64 ;

// TraceToDirectObject traces a PdfObject to a direct object.  For example direct objects contained
// in indirect objects (can be double referenced even).
func TraceToDirectObject (obj PdfObject )PdfObject {if _cgcbf ,_cfgd :=obj .(*PdfObjectReference );_cfgd {obj =_cgcbf .Resolve ();};_gdfb ,_gede :=obj .(*PdfIndirectObject );_eecg :=0;for _gede {obj =_gdfb .PdfObject ;_gdfb ,_gede =GetIndirect (obj );_eecg ++;if _eecg > _bcfbg {_fcb .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0072\u0061\u0063\u0065\u0020\u0064\u0065p\u0074\u0068\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u0062\u0065\u0079\u006fn\u0064\u0020\u0025\u0064\u0020\u002d\u0020\u006e\u006f\u0074\u0020\u0067oi\u006e\u0067\u0020\u0064\u0065\u0065\u0070\u0065\u0072\u0021",_bcfbg );return nil ;};};return obj ;};func (_cga *PdfCrypt )newEncryptDict ()*PdfObjectDictionary {_ebcb :=MakeDict ();_ebcb .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName ("\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"));_ebcb .Set ("\u0056",MakeInteger (int64 (_cga ._bf .V )));_ebcb .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_cga ._bf .Length )));return _ebcb ;};func _ddc (_fdc int )cryptFilters {return cryptFilters {_agd :_gbb .NewFilterV2 (_fdc )}};func (_cfgb *PdfParser )parseString ()(*PdfObjectString ,error ){_cfgb ._aggcb .ReadByte ();var _ecdc _gb .Buffer ;_adee :=1;for {_acbde ,_eadbg :=_cfgb ._aggcb .Peek (1);if _eadbg !=nil {return MakeString (_ecdc .String ()),_eadbg ;};if _acbde [0]=='\\'{_cfgb ._aggcb .ReadByte ();_dcbb ,_gaag :=_cfgb ._aggcb .ReadByte ();if _gaag !=nil {return MakeString (_ecdc .String ()),_gaag ;};if IsOctalDigit (_dcbb ){_eec ,_gggfa :=_cfgb ._aggcb .Peek (2);if _gggfa !=nil {return MakeString (_ecdc .String ()),_gggfa ;};var _gccd []byte ;_gccd =append (_gccd ,_dcbb );for _ ,_eebg :=range _eec {if IsOctalDigit (_eebg ){_gccd =append (_gccd ,_eebg );}else {break ;};};_cfgb ._aggcb .Discard (len (_gccd )-1);_fcb .Log .Trace ("\u004e\u0075\u006d\u0065ri\u0063\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0022\u0025\u0073\u0022",_gccd );_cacd ,_gggfa :=_e .ParseUint (string (_gccd ),8,32);if _gggfa !=nil {return MakeString (_ecdc .String ()),_gggfa ;};_ecdc .WriteByte (byte (_cacd ));continue ;};switch _dcbb {case 'n':_ecdc .WriteRune ('\n');case 'r':_ecdc .WriteRune ('\r');case 't':_ecdc .WriteRune ('\t');case 'b':_ecdc .WriteRune ('\b');case 'f':_ecdc .WriteRune ('\f');case '(':_ecdc .WriteRune ('(');case ')':_ecdc .WriteRune (')');case '\\':_ecdc .WriteRune ('\\');};continue ;}else if _acbde [0]=='('{_adee ++;}else if _acbde [0]==')'{_adee --;if _adee ==0{_cfgb ._aggcb .ReadByte ();break ;};};_bca ,_ :=_cfgb ._aggcb .ReadByte ();_ecdc .WriteByte (_bca );};return MakeString (_ecdc .String ()),nil ;};

// GetStringVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetStringVal (obj PdfObject )(_edafd string ,_gfeag bool ){_dfaea ,_gfeag :=TraceToDirectObject (obj ).(*PdfObjectString );if _gfeag {return _dfaea .Str (),true ;};return ;};func _aabf (_cbdd _ce .ReadSeeker ,_gcffe int64 )(*offsetReader ,error ){_eefab :=&offsetReader {_dcbeg :_cbdd ,_bbad :_gcffe };_ ,_feea :=_eefab .Seek (0,_ce .SeekStart );return _eefab ,_feea ;};

// DecodeStream decodes a DCT encoded stream and returns the result as a
// slice of bytes.
func (_dafd *DCTEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _dafd .DecodeBytes (streamObj .Stream );};

// ReadBytesAt reads byte content at specific offset and length within the PDF.
func (_efbb *PdfParser )ReadBytesAt (offset ,len int64 )([]byte ,error ){_afce :=_efbb .GetFileOffset ();_ ,_cdce :=_efbb ._dgcfc .Seek (offset ,_ce .SeekStart );if _cdce !=nil {return nil ,_cdce ;};_ebdg :=make ([]byte ,len );_ ,_cdce =_ce .ReadAtLeast (_efbb ._dgcfc ,_ebdg ,int (len ));if _cdce !=nil {return nil ,_cdce ;};_efbb .SetFileOffset (_afce );return _ebdg ,nil ;};

// PdfCryptNewDecrypt makes the document crypt handler based on the encryption dictionary
// and trailer dictionary. Returns an error on failure to process.
func PdfCryptNewDecrypt (parser *PdfParser ,ed ,trailer *PdfObjectDictionary )(*PdfCrypt ,error ){_bcb :=&PdfCrypt {_bbaa :false ,_fgad :make (map[PdfObject ]bool ),_dabd :make (map[PdfObject ]bool ),_agbc :make (map[int ]struct{}),_becce :parser };_dcd ,_fgg :=ed .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectName );if !_fgg {_fcb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0043\u0072\u0079\u0070\u0074 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061r\u0079 \u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u0066\u0069\u0065\u006c\u0064\u0021");return _bcb ,_ca .New ("r\u0065\u0071\u0075\u0069\u0072\u0065d\u0020\u0063\u0072\u0079\u0070\u0074 \u0066\u0069\u0065\u006c\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u006d\u0069\u0073\u0073\u0069n\u0067");};if *_dcd !="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"{_fcb .Log .Debug ("\u0045\u0052R\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020(%\u0073\u0029",*_dcd );return _bcb ,_ca .New ("\u0075n\u0073u\u0070\u0070\u006f\u0072\u0074e\u0064\u0020F\u0069\u006c\u0074\u0065\u0072");};_bcb ._bf .Filter =string (*_dcd );if _bab ,_abc :=ed .Get ("\u0053u\u0062\u0046\u0069\u006c\u0074\u0065r").(*PdfObjectString );_abc {_bcb ._bf .SubFilter =_bab .Str ();_fcb .Log .Debug ("\u0055s\u0069n\u0067\u0020\u0073\u0075\u0062f\u0069\u006ct\u0065\u0072\u0020\u0025\u0073",_bab );};if L ,_deg :=ed .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );_deg {if (*L %8)!=0{_fcb .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0049\u006ev\u0061\u006c\u0069\u0064\u0020\u0065\u006ec\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006c\u0065\u006e\u0067\u0074\u0068");return _bcb ,_ca .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0065\u006e\u0063\u0072y\u0070t\u0069o\u006e\u0020\u006c\u0065\u006e\u0067\u0074h");};_bcb ._bf .Length =int (*L );}else {_bcb ._bf .Length =40;};_bcb ._bf .V =0;if _dcac ,_dea :=ed .Get ("\u0056").(*PdfObjectInteger );_dea {V :=int (*_dcac );_bcb ._bf .V =V ;if V >=1&&V <=2{_bcb ._fgf =_ddc (_bcb ._bf .Length );}else if V >=4&&V <=5{if _fgac :=_bcb .loadCryptFilters (ed );_fgac !=nil {return _bcb ,_fgac ;};}else {_fcb .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0061lg\u006f\u0020\u0056 \u003d \u0025\u0064",V );return _bcb ,_ca .New ("u\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d");};};if _aedb :=_dbd (&_bcb ._bbd ,ed );_aedb !=nil {return _bcb ,_aedb ;};_bcd :="";if _bfd ,_ggfa :=trailer .Get ("\u0049\u0044").(*PdfObjectArray );_ggfa &&_bfd .Len ()>=1{_ddd ,_baf :=GetString (_bfd .Get (0));if !_baf {return _bcb ,_ca .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0074r\u0061\u0069l\u0065\u0072\u0020\u0049\u0044");};_bcd =_ddd .Str ();}else {_fcb .Log .Debug ("\u0054\u0072ai\u006c\u0065\u0072 \u0049\u0044\u0020\u0061rra\u0079 m\u0069\u0073\u0073\u0069\u006e\u0067\u0020or\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0021");};_bcb ._bea =_bcd ;return _bcb ,nil ;};

// AddEncoder adds the passed in encoder to the underlying encoder slice.
func (_gcaf *MultiEncoder )AddEncoder (encoder StreamEncoder ){_gcaf ._caab =append (_gcaf ._caab ,encoder );};func (_cbeb *PdfParser )repairSeekXrefMarker ()error {_dbafg ,_fadgg :=_cbeb ._dgcfc .Seek (0,_g .SEEK_END );if _fadgg !=nil {return _fadgg ;};_cccce :=_cd .MustCompile ("\u005cs\u0078\u0072\u0065\u0066\u005c\u0073*");var _adfb int64 ;var _bgcb int64 =1000;for _adfb < _dbafg {if _dbafg <=(_bgcb +_adfb ){_bgcb =_dbafg -_adfb ;};_ ,_bfedg :=_cbeb ._dgcfc .Seek (-_adfb -_bgcb ,_g .SEEK_END );if _bfedg !=nil {return _bfedg ;};_adedge :=make ([]byte ,_bgcb );_cbeb ._dgcfc .Read (_adedge );_fcb .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0078\u0072\u0065\u0066\u0020\u003a\u0020\u0022\u0025\u0073\u0022",string (_adedge ));_ebed :=_cccce .FindAllStringIndex (string (_adedge ),-1);if _ebed !=nil {_bgcd :=_ebed [len (_ebed )-1];_fcb .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_ebed );_cbeb ._dgcfc .Seek (-_adfb -_bgcb +int64 (_bgcd [0]),_g .SEEK_END );_cbeb ._aggcb =_fc .NewReader (_cbeb ._dgcfc );for {_aggbg ,_fdfg :=_cbeb ._aggcb .Peek (1);if _fdfg !=nil {return _fdfg ;};_fcb .Log .Trace ("\u0042\u003a\u0020\u0025\u0064\u0020\u0025\u0063",_aggbg [0],_aggbg [0]);if !IsWhiteSpace (_aggbg [0]){break ;};_cbeb ._aggcb .Discard (1);};return nil ;};_fcb .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");_adfb +=_bgcb ;};_fcb .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074a\u0062\u006c\u0065\u0020\u006d\u0061r\u006b\u0065\u0072\u0020\u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066o\u0075\u006e\u0064\u002e");return _ca .New ("\u0078r\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0020");};

// Resolve resolves a PdfObject to direct object, looking up and resolving references as needed (unlike TraceToDirect).
func (_bcf *PdfParser )Resolve (obj PdfObject )(PdfObject ,error ){_aede ,_bg :=obj .(*PdfObjectReference );if !_bg {return obj ,nil ;};_age :=_bcf .GetFileOffset ();defer func (){_bcf .SetFileOffset (_age )}();_ffe ,_acb :=_bcf .LookupByReference (*_aede );if _acb !=nil {return nil ,_acb ;};_ccc ,_cadd :=_ffe .(*PdfIndirectObject );if !_cadd {return _ffe ,nil ;};_ffe =_ccc .PdfObject ;_ ,_bg =_ffe .(*PdfObjectReference );if _bg {return _ccc ,_ca .New ("\u006d\u0075lt\u0069\u0020\u0064e\u0070\u0074\u0068\u0020tra\u0063e \u0070\u006f\u0069\u006e\u0074\u0065\u0072 t\u006f\u0020\u0070\u006f\u0069\u006e\u0074e\u0072");};return _ffe ,nil ;};func (_eab *PdfCrypt )isEncrypted (_afg PdfObject )bool {_ ,_bgfc :=_eab ._dabd [_afg ];if _bgfc {_fcb .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0065\u006e\u0063\u0072y\u0070\u0074\u0065\u0064");return true ;};_fcb .Log .Trace ("\u004e\u006f\u0074\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");return false ;};

// DecodeGlobals decodes 'encoded' byte stream and returns their Globally defined segments ('Globals').
func (_bfcf *JBIG2Encoder )DecodeGlobals (encoded []byte )(_ga .Globals ,error ){return _ga .DecodeGlobals (encoded );};

// RunLengthEncoder represents Run length encoding.
type RunLengthEncoder struct{};func (_df *PdfParser )lookupObjectViaOS (_fga int ,_gcd int )(PdfObject ,error ){var _da *_gb .Reader ;var _gab objectStream ;var _cbb bool ;_gab ,_cbb =_df ._ccdc [_fga ];if !_cbb {_db ,_ege :=_df .LookupByNumber (_fga );if _ege !=nil {_fcb .Log .Debug ("\u004d\u0069ss\u0069\u006e\u0067 \u006f\u0062\u006a\u0065ct \u0073tr\u0065\u0061\u006d\u0020\u0077\u0069\u0074h \u006e\u0075\u006d\u0062\u0065\u0072\u0020%\u0064",_fga );return nil ,_ege ;};_fgag ,_gaf :=_db .(*PdfObjectStream );if !_gaf {return nil ,_ca .New ("i\u006e\u0076\u0061\u006cid\u0020o\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d");};if _df ._dgdd !=nil &&!_df ._dgdd .isDecrypted (_fgag ){return nil ,_ca .New ("\u006e\u0065\u0065\u0064\u0020\u0074\u006f\u0020\u0064\u0065\u0063r\u0079\u0070\u0074\u0020\u0074\u0068\u0065\u0020\u0073\u0074r\u0065\u0061\u006d");};_ba :=_fgag .PdfObjectDictionary ;_fcb .Log .Trace ("\u0073o\u0020\u0064\u003a\u0020\u0025\u0073\n",_ba .String ());_cee ,_gaf :=_ba .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if !_gaf {_fcb .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0061\u006c\u0077\u0061\u0079\u0073\u0020\u0068\u0061\u0076\u0065\u0020\u0061\u0020\u0054\u0079\u0070\u0065");return nil ,_ca .New ("\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020T\u0079\u0070\u0065");};if _ceg .ToLower (string (*_cee ))!="\u006f\u0062\u006a\u0073\u0074\u006d"{_fcb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0074\u0079\u0070\u0065\u0020s\u0068\u0061\u006c\u006c\u0020\u0061\u006c\u0077\u0061\u0079\u0073 \u0062\u0065\u0020\u004f\u0062\u006a\u0053\u0074\u006d\u0020\u0021");return nil ,_ca .New ("\u006f\u0062\u006a\u0065c\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0074y\u0070e\u0020\u0021\u003d\u0020\u004f\u0062\u006aS\u0074\u006d");};N ,_gaf :=_ba .Get ("\u004e").(*PdfObjectInteger );if !_gaf {return nil ,_ca .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u004e\u0020i\u006e\u0020\u0073\u0074\u0072\u0065\u0061m\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_aed ,_gaf :=_ba .Get ("\u0046\u0069\u0072s\u0074").(*PdfObjectInteger );if !_gaf {return nil ,_ca .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0046\u0069\u0072\u0073\u0074\u0020i\u006e \u0073t\u0072e\u0061\u006d\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_fcb .Log .Trace ("\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0073\u0020\u006eu\u006d\u0062\u0065\u0072\u0020\u006f\u0066 \u006f\u0062\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_cee ,*N );_eaf ,_ege :=DecodeStream (_fgag );if _ege !=nil {return nil ,_ege ;};_fcb .Log .Trace ("D\u0065\u0063\u006f\u0064\u0065\u0064\u003a\u0020\u0025\u0073",_eaf );_cbd :=_df .GetFileOffset ();defer func (){_df .SetFileOffset (_cbd )}();_da =_gb .NewReader (_eaf );_df ._aggcb =_fc .NewReader (_da );_fcb .Log .Trace ("\u0050a\u0072s\u0069\u006e\u0067\u0020\u006ff\u0066\u0073e\u0074\u0020\u006d\u0061\u0070");_bb :=map[int ]int64 {};for _cbg :=0;_cbg < int (*N );_cbg ++{_df .skipSpaces ();_fcf ,_cba :=_df .parseNumber ();if _cba !=nil {return nil ,_cba ;};_eb ,_cc :=_fcf .(*PdfObjectInteger );if !_cc {return nil ,_ca .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");};_df .skipSpaces ();_fcf ,_cba =_df .parseNumber ();if _cba !=nil {return nil ,_cba ;};_ag ,_cc :=_fcf .(*PdfObjectInteger );if !_cc {return nil ,_ca .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");};_fcb .Log .Trace ("\u006f\u0062j\u0020\u0025\u0064 \u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0025\u0064",*_eb ,*_ag );_bb [int (*_eb )]=int64 (*_aed +*_ag );};_gab =objectStream {N :int (*N ),_ac :_eaf ,_fg :_bb };_df ._ccdc [_fga ]=_gab ;}else {_aedf :=_df .GetFileOffset ();defer func (){_df .SetFileOffset (_aedf )}();_da =_gb .NewReader (_gab ._ac );_df ._aggcb =_fc .NewReader (_da );};_dd :=_gab ._fg [_gcd ];_fcb .Log .Trace ("\u0041\u0043\u0054\u0055AL\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u005b\u0025\u0064\u005d\u0020\u003d\u0020%\u0064",_gcd ,_dd );_da .Seek (_dd ,_g .SEEK_SET );_df ._aggcb =_fc .NewReader (_da );_cdf ,_ :=_df ._aggcb .Peek (100);_fcb .Log .Trace ("\u004f\u0042\u004a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_cdf ));_dg ,_fe :=_df .parseObject ();if _fe !=nil {_fcb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c \u0074\u006f\u0020\u0072\u0065\u0061\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_fe );return nil ,_fe ;};if _dg ==nil {return nil ,_ca .New ("o\u0062\u006a\u0065\u0063t \u0063a\u006e\u006e\u006f\u0074\u0020b\u0065\u0020\u006e\u0075\u006c\u006c");};_gg :=PdfIndirectObject {};_gg .ObjectNumber =int64 (_gcd );_gg .PdfObject =_dg ;return &_gg ,nil ;};var _eaca =_cd .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064\u002b)\u005c\u0073\u002a\u0024");

// IsPrintable checks if a character is printable.
// Regular characters that are outside the range EXCLAMATION MARK(21h)
// (!) to TILDE (7Eh) (~) should be written using the hexadecimal notation.
func IsPrintable (c byte )bool {return 0x21<=c &&c <=0x7E};func _gecea (_fbcb *PdfObjectStream ,_agc *PdfObjectDictionary )(*CCITTFaxEncoder ,error ){_ffc :=NewCCITTFaxEncoder ();_fgga :=_fbcb .PdfObjectDictionary ;if _fgga ==nil {return _ffc ,nil ;};if _agc ==nil {_egef :=TraceToDirectObject (_fgga .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));if _egef !=nil {switch _ebdb :=_egef .(type ){case *PdfObjectDictionary :_agc =_ebdb ;break ;case *PdfObjectArray :if _ebdb .Len ()==1{if _aaac ,_gdgb :=GetDict (_ebdb .Get (0));_gdgb {_agc =_aaac ;};};default:_fcb .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_egef );return nil ,_ca .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _agc ==nil {_fcb .Log .Error ("\u0044\u0065c\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064 %\u0023\u0076",_egef );return nil ,_ca .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _dgga ,_dcfg :=GetNumberAsInt64 (_agc .Get ("\u004b"));_dcfg ==nil {_ffc .K =int (_dgga );};if _dcg ,_gbbg :=GetNumberAsInt64 (_agc .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));_gbbg ==nil {_ffc .Columns =int (_dcg );}else {_ffc .Columns =1728;};if _bfce ,_aeae :=GetNumberAsInt64 (_agc .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_aeae ==nil {_ffc .BlackIs1 =_bfce > 0;}else {if _ecef ,_dddf :=GetBoolVal (_agc .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_dddf {_ffc .BlackIs1 =_ecef ;}else {if _dcea ,_ede :=GetArray (_agc .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));_ede {_cfdc ,_bbbd :=_dcea .ToIntegerArray ();if _bbbd ==nil {_ffc .BlackIs1 =_cfdc [0]==1&&_cfdc [1]==0;};};};};if _gbfa ,_bcea :=GetNumberAsInt64 (_agc .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_bcea ==nil {_ffc .EncodedByteAlign =_gbfa > 0;}else {if _bccb ,_dcdd :=GetBoolVal (_agc .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_dcdd {_ffc .EncodedByteAlign =_bccb ;};};if _eaff ,_gaca :=GetNumberAsInt64 (_agc .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_gaca ==nil {_ffc .EndOfLine =_eaff > 0;}else {if _agfc ,_affa :=GetBoolVal (_agc .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_affa {_ffc .EndOfLine =_agfc ;};};if _aeec ,_cdb :=GetNumberAsInt64 (_agc .Get ("\u0052\u006f\u0077\u0073"));_cdb ==nil {_ffc .Rows =int (_aeec );};_ffc .EndOfBlock =true ;if _eddae ,_fgadc :=GetNumberAsInt64 (_agc .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_fgadc ==nil {_ffc .EndOfBlock =_eddae > 0;}else {if _afaf ,_gadg :=GetBoolVal (_agc .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_gadg {_ffc .EndOfBlock =_afaf ;};};if _beff ,_gdaf :=GetNumberAsInt64 (_agc .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));_gdaf !=nil {_ffc .DamagedRowsBeforeError =int (_beff );};_fcb .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_agc .String ());return _ffc ,nil ;};

// DecodeStream decodes RunLengthEncoded stream object and give back decoded bytes.
func (_cgcb *RunLengthEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _cgcb .DecodeBytes (streamObj .Stream );};

// GetAccessPermissions returns the PDF access permissions as an AccessPermissions object.
func (_bfdb *PdfCrypt )GetAccessPermissions ()_ff .Permissions {return _bfdb ._bbd .P };

// String returns a string describing `streams`.
func (_fcffa *PdfObjectStreams )String ()string {return _f .Sprintf ("\u004f\u0062j\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0025\u0064",_fcffa .ObjectNumber );};func (_aedef *PdfParser )parseObject ()(PdfObject ,error ){_fcb .Log .Trace ("\u0052e\u0061d\u0020\u0064\u0069\u0072\u0065c\u0074\u0020o\u0062\u006a\u0065\u0063\u0074");_aedef .skipSpaces ();for {_gfcg ,_efgf :=_aedef ._aggcb .Peek (2);if _efgf !=nil {if _efgf !=_ce .EOF ||len (_gfcg )==0{return nil ,_efgf ;};if len (_gfcg )==1{_gfcg =append (_gfcg ,' ');};};_fcb .Log .Trace ("\u0050e\u0065k\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u003a\u0020\u0025\u0073",string (_gfcg ));if _gfcg [0]=='/'{_dbeb ,_abec :=_aedef .parseName ();_fcb .Log .Trace ("\u002d\u003e\u004ea\u006d\u0065\u003a\u0020\u0027\u0025\u0073\u0027",_dbeb );return &_dbeb ,_abec ;}else if _gfcg [0]=='('{_fcb .Log .Trace ("\u002d>\u0053\u0074\u0072\u0069\u006e\u0067!");_cebd ,_bedc :=_aedef .parseString ();return _cebd ,_bedc ;}else if _gfcg [0]=='['{_fcb .Log .Trace ("\u002d\u003e\u0041\u0072\u0072\u0061\u0079\u0021");_cdbc ,_gegc :=_aedef .parseArray ();return _cdbc ,_gegc ;}else if (_gfcg [0]=='<')&&(_gfcg [1]=='<'){_fcb .Log .Trace ("\u002d>\u0044\u0069\u0063\u0074\u0021");_dbff ,_bbfa :=_aedef .ParseDict ();return _dbff ,_bbfa ;}else if _gfcg [0]=='<'{_fcb .Log .Trace ("\u002d\u003e\u0048\u0065\u0078\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0021");_bfae ,_cgbb :=_aedef .parseHexString ();return _bfae ,_cgbb ;}else if _gfcg [0]=='%'{_aedef .readComment ();_aedef .skipSpaces ();}else {_fcb .Log .Trace ("\u002d\u003eN\u0075\u006d\u0062e\u0072\u0020\u006f\u0072\u0020\u0072\u0065\u0066\u003f");_gfcg ,_ =_aedef ._aggcb .Peek (15);_badgg :=string (_gfcg );_fcb .Log .Trace ("\u0050\u0065\u0065k\u0020\u0073\u0074\u0072\u003a\u0020\u0025\u0073",_badgg );if (len (_badgg )> 3)&&(_badgg [:4]=="\u006e\u0075\u006c\u006c"){_faegc ,_gfga :=_aedef .parseNull ();return &_faegc ,_gfga ;}else if (len (_badgg )> 4)&&(_badgg [:5]=="\u0066\u0061\u006cs\u0065"){_cada ,_dfaa :=_aedef .parseBool ();return &_cada ,_dfaa ;}else if (len (_badgg )> 3)&&(_badgg [:4]=="\u0074\u0072\u0075\u0065"){_eacf ,_deee :=_aedef .parseBool ();return &_eacf ,_deee ;};_fbfb :=_efcad .FindStringSubmatch (string (_badgg ));if len (_fbfb )> 1{_gfcg ,_ =_aedef ._aggcb .ReadBytes ('R');_fcb .Log .Trace ("\u002d\u003e\u0020\u0021\u0052\u0065\u0066\u003a\u0020\u0027\u0025\u0073\u0027",string (_gfcg [:]));_gecg ,_beef :=_fdfe (string (_gfcg ));_gecg ._fcdb =_aedef ;return &_gecg ,_beef ;};_ebfg :=_eaef .FindStringSubmatch (string (_badgg ));if len (_ebfg )> 1{_fcb .Log .Trace ("\u002d\u003e\u0020\u004e\u0075\u006d\u0062\u0065\u0072\u0021");_bbfd ,_bfca :=_aedef .parseNumber ();return _bbfd ,_bfca ;};_ebfg =_bggf .FindStringSubmatch (string (_badgg ));if len (_ebfg )> 1{_fcb .Log .Trace ("\u002d\u003e\u0020\u0045xp\u006f\u006e\u0065\u006e\u0074\u0069\u0061\u006c\u0020\u004e\u0075\u006d\u0062\u0065r\u0021");_fcb .Log .Trace ("\u0025\u0020\u0073",_ebfg );_dbfc ,_ceae :=_aedef .parseNumber ();return _dbfc ,_ceae ;};_fcb .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020U\u006e\u006b\u006e\u006f\u0077n\u0020(\u0070e\u0065\u006b\u0020\u0022\u0025\u0073\u0022)",_badgg );return nil ,_ca .New ("\u006f\u0062\u006a\u0065\u0063t\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020\u0075\u006e\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e");};};};var _abgd =_cd .MustCompile ("\u0073t\u0061r\u0074\u0078\u003f\u0072\u0065f\u005c\u0073*\u0028\u005c\u0064\u002b\u0029");

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_dggf *CCITTFaxEncoder )MakeDecodeParams ()PdfObject {_fgcg :=MakeDict ();_fgcg .Set ("\u004b",MakeInteger (int64 (_dggf .K )));_fgcg .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_dggf .Columns )));if _dggf .BlackIs1 {_fgcg .Set ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031",MakeBool (_dggf .BlackIs1 ));};if _dggf .EncodedByteAlign {_fgcg .Set ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e",MakeBool (_dggf .EncodedByteAlign ));};if _dggf .EndOfLine &&_dggf .K >=0{_fgcg .Set ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee",MakeBool (_dggf .EndOfLine ));};if _dggf .Rows !=0&&!_dggf .EndOfBlock {_fgcg .Set ("\u0052\u006f\u0077\u0073",MakeInteger (int64 (_dggf .Rows )));};if !_dggf .EndOfBlock {_fgcg .Set ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b",MakeBool (_dggf .EndOfBlock ));};if _dggf .DamagedRowsBeforeError !=0{_fgcg .Set ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072",MakeInteger (int64 (_dggf .DamagedRowsBeforeError )));};return _fgcg ;};

// DecodeStream returns the passed in stream as a slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_cgg *RawEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return streamObj .Stream ,nil ;};

// GetNumberAsFloat returns the contents of `obj` as a float if it is an integer or float, or an
// error if it isn't.
func GetNumberAsFloat (obj PdfObject )(float64 ,error ){switch _dfde :=obj .(type ){case *PdfObjectFloat :return float64 (*_dfde ),nil ;case *PdfObjectInteger :return float64 (*_dfde ),nil ;};return 0,ErrNotANumber ;};type objectCache map[int ]PdfObject ;

// XrefTable represents the cross references in a PDF, i.e. the table of objects and information
// where to access within the PDF file.
type XrefTable struct{ObjectMap map[int ]XrefObject ;_ge []XrefObject ;};

// Str returns the string value of the PdfObjectString. Defined in addition to String() function to clarify that
// this function returns the underlying string directly, whereas the String function technically could include
// debug info.
func (_fbac *PdfObjectString )Str ()string {return _fbac ._bebd };

// Bytes returns the PdfObjectString content as a []byte array.
func (_cdcdg *PdfObjectString )Bytes ()[]byte {return []byte (_cdcdg ._bebd )};

// Set sets the PdfObject at index i of the streams. An error is returned if the index is outside bounds.
func (_bfcdae *PdfObjectStreams )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_bfcdae ._cdaag ){return _ca .New ("\u004f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_bfcdae ._cdaag [i ]=obj ;return nil ;};

// PdfIndirectObject represents the primitive PDF indirect object.
type PdfIndirectObject struct{PdfObjectReference ;PdfObject ;};

// UpdateParams updates the parameter values of the encoder.
func (_dcef *DCTEncoder )UpdateParams (params *PdfObjectDictionary ){_bgada ,_fcafb :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _fcafb ==nil {_dcef .ColorComponents =int (_bgada );};_ebeaf ,_fcafb :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _fcafb ==nil {_dcef .BitsPerComponent =int (_ebeaf );};_eceb ,_fcafb :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _fcafb ==nil {_dcef .Width =int (_eceb );};_dgcf ,_fcafb :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _fcafb ==nil {_dcef .Height =int (_dgcf );};_fabc ,_fcafb :=GetNumberAsInt64 (params .Get ("\u0051u\u0061\u006c\u0069\u0074\u0079"));if _fcafb ==nil {_dcef .Quality =int (_fabc );};};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_bgbd *FlateEncoder )MakeStreamDict ()*PdfObjectDictionary {_bag :=MakeDict ();_bag .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_bgbd .GetFilterName ()));_cgbf :=_bgbd .MakeDecodeParams ();if _cgbf !=nil {_bag .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_cgbf );};return _bag ;};

// PdfObjectStreams represents the primitive PDF object streams.
// 7.5.7 Object Streams (page 45).
type PdfObjectStreams struct{PdfObjectReference ;_cdaag []PdfObject ;};func (_fcab *PdfParser )loadXrefs ()(*PdfObjectDictionary ,error ){_fcab ._gaeec .ObjectMap =make (map[int ]XrefObject );_fcab ._ccdc =make (objectStreams );_fbeed ,_gedd :=_fcab ._dgcfc .Seek (0,_ce .SeekEnd );if _gedd !=nil {return nil ,_gedd ;};_fcb .Log .Trace ("\u0066s\u0069\u007a\u0065\u003a\u0020\u0025d",_fbeed );_fcab ._bgbf =_fbeed ;_gedd =_fcab .seekToEOFMarker (_fbeed );if _gedd !=nil {_fcb .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0073\u0065\u0065\u006b\u0020\u0074\u006f\u0020\u0065\u006f\u0066\u0020\u006d\u0061\u0072\u006b\u0065\u0072: \u0025\u0076",_gedd );return nil ,_gedd ;};_bbeda ,_gedd :=_fcab ._dgcfc .Seek (0,_ce .SeekCurrent );if _gedd !=nil {return nil ,_gedd ;};var _ecbbd int64 =64;_fege :=_bbeda -_ecbbd ;if _fege < 0{_fege =0;};_ ,_gedd =_fcab ._dgcfc .Seek (_fege ,_ce .SeekStart );if _gedd !=nil {return nil ,_gedd ;};_dggg :=make ([]byte ,_ecbbd );_ ,_gedd =_fcab ._dgcfc .Read (_dggg );if _gedd !=nil {_fcb .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u003a\u0020\u0025\u0076",_gedd );return nil ,_gedd ;};_effc :=_abgd .FindStringSubmatch (string (_dggg ));if len (_effc )< 2{_fcb .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020n\u006f\u0074\u0020f\u006fu\u006e\u0064\u0021");return nil ,_ca .New ("\u0073\u0074\u0061\u0072tx\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};if len (_effc )> 2{_fcb .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u004du\u006c\u0074\u0069\u0070\u006c\u0065\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029\u0021",_dggg );return nil ,_ca .New ("m\u0075\u006c\u0074\u0069\u0070\u006ce\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065f\u0020\u0065\u006et\u0072i\u0065\u0073\u003f");};_becg ,_ :=_e .ParseInt (_effc [1],10,64);_fcb .Log .Trace ("\u0073t\u0061r\u0074\u0078\u0072\u0065\u0066\u0020\u0061\u0074\u0020\u0025\u0064",_becg );if _becg > _fbeed {_fcb .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u006f\u0066f\u0073e\u0074 \u006fu\u0074\u0073\u0069\u0064\u0065\u0020\u006f\u0066\u0020\u0066\u0069\u006c\u0065");_fcb .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0072e\u0070\u0061\u0069\u0072");_becg ,_gedd =_fcab .repairLocateXref ();if _gedd !=nil {_fcb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0052\u0065\u0070\u0061\u0069\u0072\u0020\u0061\u0074\u0074\u0065\u006d\u0070t\u0020\u0066\u0061\u0069\u006c\u0065\u0064 \u0028\u0025\u0073\u0029");return nil ,_gedd ;};};_fcab ._dgcfc .Seek (int64 (_becg ),_ce .SeekStart );_fcab ._aggcb =_fc .NewReader (_fcab ._dgcfc );_dggb ,_gedd :=_fcab .parseXref ();if _gedd !=nil {return nil ,_gedd ;};_gfbcc :=_dggb .Get ("\u0058R\u0065\u0066\u0053\u0074\u006d");if _gfbcc !=nil {_fbbfe ,_ccf :=_gfbcc .(*PdfObjectInteger );if !_ccf {return nil ,_ca .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0021=\u0020\u0069\u006e\u0074");};_ ,_gedd =_fcab .parseXrefStream (_fbbfe );if _gedd !=nil {return nil ,_gedd ;};};var _fece []int64 ;_fcfe :=func (_cagb int64 ,_bagc []int64 )bool {for _ ,_gee :=range _bagc {if _gee ==_cagb {return true ;};};return false ;};_gfbcc =_dggb .Get ("\u0050\u0072\u0065\u0076");for _gfbcc !=nil {_eca ,_efbfe :=_gfbcc .(*PdfObjectInteger );if !_efbfe {_fcb .Log .Debug ("\u0049\u006ev\u0061\u006c\u0069\u0064\u0020P\u0072\u0065\u0076\u0020\u0072e\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u003a\u0020\u004e\u006f\u0074\u0020\u0061\u0020\u002a\u0050\u0064\u0066\u004f\u0062\u006a\u0065\u0063\u0074\u0049\u006e\u0074\u0065\u0067\u0065\u0072\u0020\u0028\u0025\u0054\u0029",_gfbcc );return _dggb ,nil ;};_eaeegc :=*_eca ;_fcb .Log .Trace ("\u0041\u006eot\u0068\u0065\u0072 \u0050\u0072\u0065\u0076 xr\u0065f \u0074\u0061\u0062\u006c\u0065\u0020\u006fbj\u0065\u0063\u0074\u0020\u0061\u0074\u0020%\u0064",_eaeegc );_fcab ._dgcfc .Seek (int64 (_eaeegc ),_g .SEEK_SET );_fcab ._aggcb =_fc .NewReader (_fcab ._dgcfc );_begfg ,_gdcc :=_fcab .parseXref ();if _gdcc !=nil {_fcb .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0045\u0072\u0072\u006f\u0072\u0020-\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u0061\u0064\u0069n\u0067\u0020\u0061\u006e\u006f\u0074\u0068\u0065\u0072\u0020\u0028\u0050re\u0076\u0029\u0020\u0074\u0072\u0061\u0069\u006c\u0065\u0072");_fcb .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0063\u006f\u006e\u0074\u0069n\u0075\u0065\u0020\u0062\u0079\u0020\u0069\u0067\u006e\u006f\u0072\u0069n\u0067\u0020\u0069\u0074");break ;};_gfbcc =_begfg .Get ("\u0050\u0072\u0065\u0076");if _gfbcc !=nil {_gaga :=*(_gfbcc .(*PdfObjectInteger ));if _fcfe (int64 (_gaga ),_fece ){_fcb .Log .Debug ("\u0050\u0072ev\u0065\u006e\u0074i\u006e\u0067\u0020\u0063irc\u0075la\u0072\u0020\u0078\u0072\u0065\u0066\u0020re\u0066\u0065\u0072\u0065\u006e\u0063\u0069n\u0067");break ;};_fece =append (_fece ,int64 (_gaga ));};};return _dggb ,nil ;};

// GetStringBytes is like GetStringVal except that it returns the string as a []byte.
// It is for convenience.
func GetStringBytes (obj PdfObject )(_gdce []byte ,_afcgd bool ){_dfcb ,_afcgd :=TraceToDirectObject (obj ).(*PdfObjectString );if _afcgd {return _dfcb .Bytes (),true ;};return ;};type xrefType int ;

// DecodeBytes decodes a slice of DCT encoded bytes and returns the result.
func (_acd *DCTEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_dag :=_gb .NewReader (encoded );_ddbg ,_eddag :=_ee .Decode (_dag );if _eddag !=nil {_fcb .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006eg\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_eddag );return nil ,_eddag ;};_eeac :=_ddbg .Bounds ();var _efbd =make ([]byte ,_eeac .Dx ()*_eeac .Dy ()*_acd .ColorComponents *_acd .BitsPerComponent /8);_fada :=0;for _geba :=_eeac .Min .Y ;_geba < _eeac .Max .Y ;_geba ++{for _adf :=_eeac .Min .X ;_adf < _eeac .Max .X ;_adf ++{_ada :=_ddbg .At (_adf ,_geba );if _acd .ColorComponents ==1{if _acd .BitsPerComponent ==16{_bgd ,_faag :=_ada .(_a .Gray16 );if !_faag {return nil ,_ca .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_efbd [_fada ]=byte ((_bgd .Y >>8)&0xff);_fada ++;_efbd [_fada ]=byte (_bgd .Y &0xff);_fada ++;}else {_fbg ,_gbcc :=_ada .(_a .Gray );if !_gbcc {return nil ,_ca .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_efbd [_fada ]=byte (_fbg .Y &0xff);_fada ++;};}else if _acd .ColorComponents ==3{if _acd .BitsPerComponent ==16{_gbba ,_bce :=_ada .(_a .RGBA64 );if !_bce {return nil ,_ca .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_efbd [_fada ]=byte ((_gbba .R >>8)&0xff);_fada ++;_efbd [_fada ]=byte (_gbba .R &0xff);_fada ++;_efbd [_fada ]=byte ((_gbba .G >>8)&0xff);_fada ++;_efbd [_fada ]=byte (_gbba .G &0xff);_fada ++;_efbd [_fada ]=byte ((_gbba .B >>8)&0xff);_fada ++;_efbd [_fada ]=byte (_gbba .B &0xff);_fada ++;}else {_fadd ,_cgd :=_ada .(_a .RGBA );if _cgd {_efbd [_fada ]=_fadd .R &0xff;_fada ++;_efbd [_fada ]=_fadd .G &0xff;_fada ++;_efbd [_fada ]=_fadd .B &0xff;_fada ++;}else {_fafeb ,_gggf :=_ada .(_a .YCbCr );if !_gggf {return nil ,_ca .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_gddaa ,_bgcf ,_aefd ,_ :=_fafeb .RGBA ();_efbd [_fada ]=byte (_gddaa >>8);_fada ++;_efbd [_fada ]=byte (_bgcf >>8);_fada ++;_efbd [_fada ]=byte (_aefd >>8);_fada ++;};};}else if _acd .ColorComponents ==4{_edbb ,_agbg :=_ada .(_a .CMYK );if !_agbg {return nil ,_ca .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_efbd [_fada ]=255-_edbb .C &0xff;_fada ++;_efbd [_fada ]=255-_edbb .M &0xff;_fada ++;_efbd [_fada ]=255-_edbb .Y &0xff;_fada ++;_efbd [_fada ]=255-_edbb .K &0xff;_fada ++;};};};return _efbd ,nil ;};const (XrefTypeTableEntry xrefType =iota ;XrefTypeObjectStream xrefType =iota ;);

// SetImage sets the image base for given flate encoder.
func (_acfb *FlateEncoder )SetImage (img *_bed .ImageBase ){_acfb ._ebb =img };

// NewCCITTFaxEncoder makes a new CCITTFax encoder.
func NewCCITTFaxEncoder ()*CCITTFaxEncoder {return &CCITTFaxEncoder {Columns :1728,EndOfBlock :true }};func _aded (_add *PdfObjectStream ,_fad *PdfObjectDictionary )(*LZWEncoder ,error ){_gfea :=NewLZWEncoder ();_deba :=_add .PdfObjectDictionary ;if _deba ==nil {return _gfea ,nil ;};if _fad ==nil {_faea :=TraceToDirectObject (_deba .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));if _faea !=nil {if _cfdf ,_fgfd :=_faea .(*PdfObjectDictionary );_fgfd {_fad =_cfdf ;}else if _accf ,_dgbf :=_faea .(*PdfObjectArray );_dgbf {if _accf .Len ()==1{if _ceecf ,_cadbb :=GetDict (_accf .Get (0));_cadbb {_fad =_ceecf ;};};};if _fad ==nil {_fcb .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_faea );return nil ,_f .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};};_dbdf :=_deba .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");if _dbdf !=nil {_bgab ,_ffag :=_dbdf .(*PdfObjectInteger );if !_ffag {_fcb .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a \u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065d\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u006e\u0075\u006d\u0065\u0072i\u0063 \u0028\u0025\u0054\u0029",_dbdf );return nil ,_f .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");};if *_bgab !=0&&*_bgab !=1{return nil ,_f .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0076\u0061\u006c\u0075e\u0020\u0028\u006e\u006f\u0074 \u0030\u0020o\u0072\u0020\u0031\u0029");};_gfea .EarlyChange =int (*_bgab );}else {_gfea .EarlyChange =1;};if _fad ==nil {return _gfea ,nil ;};_dbdf =_fad .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");if _dbdf !=nil {_deaga ,_fcaf :=_dbdf .(*PdfObjectInteger );if !_fcaf {_fcb .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_dbdf );return nil ,_f .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_gfea .Predictor =int (*_deaga );};_dbdf =_fad .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");if _dbdf !=nil {_bbbg ,_eefa :=_dbdf .(*PdfObjectInteger );if !_eefa {_fcb .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");return nil ,_f .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_gfea .BitsPerComponent =int (*_bbbg );};if _gfea .Predictor > 1{_gfea .Columns =1;_dbdf =_fad .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");if _dbdf !=nil {_fgfb ,_daf :=_dbdf .(*PdfObjectInteger );if !_daf {return nil ,_f .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_gfea .Columns =int (*_fgfb );};_gfea .Colors =1;_dbdf =_fad .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _dbdf !=nil {_dfaf ,_agec :=_dbdf .(*PdfObjectInteger );if !_agec {return nil ,_f .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");};_gfea .Colors =int (*_dfaf );};};_fcb .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_fad .String ());return _gfea ,nil ;};type objectStreams map[int ]objectStream ;

// PdfObjectDictionary represents the primitive PDF dictionary/map object.
type PdfObjectDictionary struct{_eedfb map[PdfObjectName ]PdfObject ;_fddg []PdfObjectName ;_cbbe *PdfParser ;};func _ddaa (_dcbe *PdfObjectStream ,_cceb *MultiEncoder )(*DCTEncoder ,error ){_bbfe :=NewDCTEncoder ();_gagf :=_dcbe .PdfObjectDictionary ;if _gagf ==nil {return _bbfe ,nil ;};_ffff :=_dcbe .Stream ;if _cceb !=nil {_cfa ,_gfag :=_cceb .DecodeBytes (_ffff );if _gfag !=nil {return nil ,_gfag ;};_ffff =_cfa ;};_dcfa :=_gb .NewReader (_ffff );_dfcf ,_dfeb :=_ee .DecodeConfig (_dcfa );if _dfeb !=nil {_fcb .Log .Debug ("\u0045\u0072\u0072or\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0065\u003a\u0020\u0025\u0073",_dfeb );return nil ,_dfeb ;};switch _dfcf .ColorModel {case _a .RGBAModel :_bbfe .BitsPerComponent =8;_bbfe .ColorComponents =3;case _a .RGBA64Model :_bbfe .BitsPerComponent =16;_bbfe .ColorComponents =3;case _a .GrayModel :_bbfe .BitsPerComponent =8;_bbfe .ColorComponents =1;case _a .Gray16Model :_bbfe .BitsPerComponent =16;_bbfe .ColorComponents =1;case _a .CMYKModel :_bbfe .BitsPerComponent =8;_bbfe .ColorComponents =4;case _a .YCbCrModel :_bbfe .BitsPerComponent =8;_bbfe .ColorComponents =3;default:return nil ,_ca .New ("\u0075\u006e\u0073up\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u006d\u006f\u0064\u0065\u006c");};_bbfe .Width =_dfcf .Width ;_bbfe .Height =_dfcf .Height ;_fcb .Log .Trace ("\u0044\u0043T\u0020\u0045\u006ec\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076",_bbfe );_bbfe .Quality =DefaultJPEGQuality ;return _bbfe ,nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_acdf *RunLengthEncoder )MakeStreamDict ()*PdfObjectDictionary {_fcgc :=MakeDict ();_fcgc .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_acdf .GetFilterName ()));return _fcgc ;};

// Get returns the PdfObject corresponding to the specified key.
// Returns a nil value if the key is not set.
func (_fdbbc *PdfObjectDictionary )Get (key PdfObjectName )PdfObject {_fgggb ,_abca :=_fdbbc ._eedfb [key ];if !_abca {return nil ;};return _fgggb ;};var _eaef =_cd .MustCompile ("\u005e\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");

// Decoded returns the PDFDocEncoding or UTF-16BE decoded string contents.
// UTF-16BE is applied when the first two bytes are 0xFE, 0XFF, otherwise decoding of
// PDFDocEncoding is performed.
func (_befe *PdfObjectString )Decoded ()string {if _befe ==nil {return "";};_fced :=[]byte (_befe ._bebd );if len (_fced )>=2&&_fced [0]==0xFE&&_fced [1]==0xFF{return _gc .UTF16ToString (_fced [2:]);};return _gc .PDFDocEncodingToString (_fced );};

// EncodeBytes DCT encodes the passed in slice of bytes.
func (_ggaa *DCTEncoder )EncodeBytes (data []byte )([]byte ,error ){_gbd ,_ced :=_bed .NewImage (_ggaa .Width ,_ggaa .Height ,_ggaa .BitsPerComponent ,_ggaa .ColorComponents ,data ,nil ,nil );if _ced !=nil {return nil ,_ced ;};_dcec :=_ee .Options {};_dcec .Quality =_ggaa .Quality ;var _dacf _gb .Buffer ;if _ced =_ee .Encode (&_dacf ,_gbd ,&_dcec );_ced !=nil {return nil ,_ced ;};return _dacf .Bytes (),nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_afde *MultiEncoder )UpdateParams (params *PdfObjectDictionary ){for _ ,_baee :=range _afde ._caab {_baee .UpdateParams (params );};};

// Append appends PdfObject(s) to the array.
func (_gfbcd *PdfObjectArray )Append (objects ...PdfObject ){if _gfbcd ==nil {_fcb .Log .Debug ("\u0057\u0061\u0072\u006e\u0020\u002d\u0020\u0041\u0074\u0074\u0065\u006d\u0070t\u0020\u0074\u006f\u0020\u0061\u0070p\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020a\u0072\u0072\u0061\u0079");return ;};if _gfbcd ._ageac ==nil {_gfbcd ._ageac =[]PdfObject {};};for _ ,_dgbec :=range objects {_gfbcd ._ageac =append (_gfbcd ._ageac ,_dgbec );};};type offsetReader struct{_dcbeg _ce .ReadSeeker ;_bbad int64 ;};

// Append appends PdfObject(s) to the streams.
func (_cbfg *PdfObjectStreams )Append (objects ...PdfObject ){if _cbfg ==nil {_fcb .Log .Debug ("\u0057\u0061\u0072\u006e\u0020-\u0020\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0020\u0074\u006f\u0020\u0061p\u0070\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0073");return ;};if _cbfg ._cdaag ==nil {_cbfg ._cdaag =[]PdfObject {};};for _ ,_egbf :=range objects {_cbfg ._cdaag =append (_cbfg ._cdaag ,_egbf );};};

// NewDCTEncoder makes a new DCT encoder with default parameters.
func NewDCTEncoder ()*DCTEncoder {_eefc :=&DCTEncoder {};_eefc .ColorComponents =3;_eefc .BitsPerComponent =8;_eefc .Quality =DefaultJPEGQuality ;return _eefc ;};

// DecodeBytes decodes a slice of JBIG2 encoded bytes and returns the results.
func (_fcgf *JBIG2Encoder )DecodeBytes (encoded []byte )([]byte ,error ){return _ga .DecodeBytes (encoded ,_ead .Parameters {},_fcgf .Globals );};func _ace (_gd PdfObject )(int64 ,int64 ,error ){if _eff ,_bec :=_gd .(*PdfIndirectObject );_bec {return _eff .ObjectNumber ,_eff .GenerationNumber ,nil ;};if _aa ,_baa :=_gd .(*PdfObjectStream );_baa {return _aa .ObjectNumber ,_aa .GenerationNumber ,nil ;};return 0,0,_ca .New ("\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u002f\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062je\u0063\u0074");};func (_dggde *offsetReader )Read (p []byte )(_dagbg int ,_gagb error ){return _dggde ._dcbeg .Read (p )};

// MultiEncoder supports serial encoding.
type MultiEncoder struct{_caab []StreamEncoder };

// JBIG2Encoder implements both jbig2 encoder and the decoder. The encoder allows to encode
// provided images (best used document scans) in multiple way. By default it uses single page generic
// encoder. It allows to store lossless data as a single segment.
// In order to store multiple image pages use the 'FileMode' which allows to store more pages within single jbig2 document.
// WIP: In order to obtain better compression results the encoder would allow to encode the input in a
// lossy or lossless way with a component (symbol) mode. It divides the image into components.
// Then checks if any component is 'similar' to the others and maps them together. The symbol classes are stored
// in the dictionary. Then the encoder creates text regions which uses the related symbol classes to fill it's space.
// The similarity is defined by the 'Threshold' variable (default: 0.95). The less the value is, the more components
// matches to single class, thus the compression is better, but the result might become lossy.
type JBIG2Encoder struct{

// These values are required to be set for the 'EncodeBytes' method.
// ColorComponents defines the number of color components for provided image.
ColorComponents int ;

// BitsPerComponent is the number of bits that stores per color component
BitsPerComponent int ;

// Width is the width of the image to encode
Width int ;

// Height is the height of the image to encode.
Height int ;_bbbed *_dee .Document ;

// Globals are the JBIG2 global segments.
Globals _ga .Globals ;

// IsChocolateData defines if the data is encoded such that
// binary data '1' means black and '0' white.
// otherwise the data is called vanilla.
// Naming convention taken from: 'https://en.wikipedia.org/wiki/Binary_image#Interpretation'
IsChocolateData bool ;

// DefaultPageSettings are the settings parameters used by the jbig2 encoder.
DefaultPageSettings JBIG2EncoderSettings ;};

// IsDecimalDigit checks if the character is a part of a decimal number string.
func IsDecimalDigit (c byte )bool {return '0'<=c &&c <='9'};var _ccb =_cd .MustCompile ("\u0025P\u0044F\u002d\u0028\u005c\u0064\u0029\u005c\u002e\u0028\u005c\u0064\u0029");func _acadc ()string {return _fcb .Version };func (_cdag *PdfCrypt )checkAccessRights (_dgg []byte )(bool ,_ff .Permissions ,error ){_caa :=_cdag .securityHandler ();_beg ,_efg ,_eaag :=_caa .Authenticate (&_cdag ._bbd ,_dgg );if _eaag !=nil {return false ,0,_eaag ;}else if _efg ==0||len (_beg )==0{return false ,0,nil ;};return true ,_efg ,nil ;};func _fdfe (_bdee string )(PdfObjectReference ,error ){_ffab :=PdfObjectReference {};_dceae :=_efcad .FindStringSubmatch (string (_bdee ));if len (_dceae )< 3{_fcb .Log .Debug ("\u0045\u0072\u0072or\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");return _ffab ,_ca .New ("\u0075n\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061r\u0073e\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");};_afgcd ,_ :=_e .Atoi (_dceae [1]);_ffbc ,_ :=_e .Atoi (_dceae [2]);_ffab .ObjectNumber =int64 (_afgcd );_ffab .GenerationNumber =int64 (_ffbc );return _ffab ,nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on the current encoder settings.
func (_gba *JBIG2Encoder )MakeDecodeParams ()PdfObject {return MakeDict ()};

// DecodeBytes decodes a slice of ASCII encoded bytes and returns the result.
func (_gfd *ASCIIHexEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_fggg :=_gb .NewReader (encoded );var _cdge []byte ;for {_acae ,_daege :=_fggg .ReadByte ();if _daege !=nil {return nil ,_daege ;};if _acae =='>'{break ;};if IsWhiteSpace (_acae ){continue ;};if (_acae >='a'&&_acae <='f')||(_acae >='A'&&_acae <='F')||(_acae >='0'&&_acae <='9'){_cdge =append (_cdge ,_acae );}else {_fcb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0061\u0073\u0063\u0069\u0069 \u0068\u0065\u0078\u0020\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072 \u0028\u0025\u0063\u0029",_acae );return nil ,_f .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0061\u0073\u0063\u0069\u0069\u0020\u0068e\u0078 \u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u0020\u0028\u0025\u0063\u0029",_acae );};};if len (_cdge )%2==1{_cdge =append (_cdge ,'0');};_fcb .Log .Trace ("\u0049\u006e\u0062\u006f\u0075\u006e\u0064\u0020\u0025\u0073",_cdge );_agad :=make ([]byte ,_cb .DecodedLen (len (_cdge )));_ ,_fea :=_cb .Decode (_agad ,_cdge );if _fea !=nil {return nil ,_fea ;};return _agad ,nil ;};

// IsOctalDigit checks if a character can be part of an octal digit string.
func IsOctalDigit (c byte )bool {return '0'<=c &&c <='7'};

// MakeArrayFromFloats creates an PdfObjectArray from a slice of float64s, where each array element is an
// PdfObjectFloat.
func MakeArrayFromFloats (vals []float64 )*PdfObjectArray {_bbca :=MakeArray ();for _ ,_fgaee :=range vals {_bbca .Append (MakeFloat (_fgaee ));};return _bbca ;};

// Decrypt attempts to decrypt the PDF file with a specified password.  Also tries to
// decrypt with an empty password.  Returns true if successful, false otherwise.
// An error is returned when there is a problem with decrypting.
func (_deddc *PdfParser )Decrypt (password []byte )(bool ,error ){if _deddc ._dgdd ==nil {return false ,_ca .New ("\u0063\u0068\u0065\u0063k \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u0069\u0072s\u0074");};_bageb ,_efgad :=_deddc ._dgdd .authenticate (password );if _efgad !=nil {return false ,_efgad ;};if !_bageb {_bageb ,_efgad =_deddc ._dgdd .authenticate ([]byte (""));};return _bageb ,_efgad ;};

// NewJBIG2Encoder creates a new JBIG2Encoder.
func NewJBIG2Encoder ()*JBIG2Encoder {return &JBIG2Encoder {_bbbed :_dee .InitEncodeDocument (false )}};

// GetIndirect returns the *PdfIndirectObject represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetIndirect (obj PdfObject )(_bgfec *PdfIndirectObject ,_daae bool ){obj =ResolveReference (obj );_bgfec ,_daae =obj .(*PdfIndirectObject );return _bgfec ,_daae ;};

// ParseIndirectObject parses an indirect object from the input stream. Can also be an object stream.
// Returns the indirect object (*PdfIndirectObject) or the stream object (*PdfObjectStream).
func (_afgf *PdfParser )ParseIndirectObject ()(PdfObject ,error ){_dfcd :=PdfIndirectObject {};_dfcd ._fcdb =_afgf ;_fcb .Log .Trace ("\u002dR\u0065a\u0064\u0020\u0069\u006e\u0064i\u0072\u0065c\u0074\u0020\u006f\u0062\u006a");_eaea ,_beaf :=_afgf ._aggcb .Peek (20);if _beaf !=nil {if _beaf !=_ce .EOF {_fcb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020r\u0065a\u0064\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a");return &_dfcd ,_beaf ;};};_fcb .Log .Trace ("\u0028\u0069\u006edi\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_eaea ));_afbfac :=_bcfa .FindStringSubmatchIndex (string (_eaea ));if len (_afbfac )< 6{if _beaf ==_ce .EOF {return nil ,_beaf ;};_fcb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_eaea ));return &_dfcd ,_ca .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");};_afgf ._aggcb .Discard (_afbfac [0]);_fcb .Log .Trace ("O\u0066\u0066\u0073\u0065\u0074\u0073\u0020\u0025\u0020\u0064",_afbfac );_aaed :=_afbfac [1]-_afbfac [0];_dedg :=make ([]byte ,_aaed );_ ,_beaf =_afgf .ReadAtLeast (_dedg ,_aaed );if _beaf !=nil {_fcb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u0072\u0065\u0061\u0064\u0020-\u0020\u0025\u0073",_beaf );return nil ,_beaf ;};_fcb .Log .Trace ("\u0074\u0065\u0078t\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_dedg );_dgcc :=_bcfa .FindStringSubmatch (string (_dedg ));if len (_dgcc )< 3{_fcb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_dedg ));return &_dfcd ,_ca .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");};_eefaf ,_ :=_e .Atoi (_dgcc [1]);_ecae ,_ :=_e .Atoi (_dgcc [2]);_dfcd .ObjectNumber =int64 (_eefaf );_dfcd .GenerationNumber =int64 (_ecae );for {_aggcc ,_dbffb :=_afgf ._aggcb .Peek (2);if _dbffb !=nil {return &_dfcd ,_dbffb ;};_fcb .Log .Trace ("I\u006ed\u002e\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_aggcc ),string (_aggcc ));if IsWhiteSpace (_aggcc [0]){_afgf .skipSpaces ();}else if _aggcc [0]=='%'{_afgf .skipComments ();}else if (_aggcc [0]=='<')&&(_aggcc [1]=='<'){_fcb .Log .Trace ("\u0043\u0061\u006c\u006c\u0020\u0050\u0061\u0072\u0073e\u0044\u0069\u0063\u0074");_dfcd .PdfObject ,_dbffb =_afgf .ParseDict ();_fcb .Log .Trace ("\u0045\u004f\u0046\u0020Ca\u006c\u006c\u0020\u0050\u0061\u0072\u0073\u0065\u0044\u0069\u0063\u0074\u003a\u0020%\u0076",_dbffb );if _dbffb !=nil {return &_dfcd ,_dbffb ;};_fcb .Log .Trace ("\u0050\u0061\u0072\u0073\u0065\u0064\u0020\u0064\u0069\u0063t\u0069\u006f\u006e\u0061\u0072\u0079\u002e.\u002e\u0020\u0066\u0069\u006e\u0069\u0073\u0068\u0065\u0064\u002e");}else if (_aggcc [0]=='/')||(_aggcc [0]=='(')||(_aggcc [0]=='[')||(_aggcc [0]=='<'){_dfcd .PdfObject ,_dbffb =_afgf .parseObject ();if _dbffb !=nil {return &_dfcd ,_dbffb ;};_fcb .Log .Trace ("P\u0061\u0072\u0073\u0065\u0064\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u002e\u002e\u002e \u0066\u0069\u006ei\u0073h\u0065\u0064\u002e");}else if _aggcc [0]==']'{_fcb .Log .Debug ("\u0057\u0041\u0052\u004e\u0049N\u0047\u003a\u0020\u0027\u005d\u0027 \u0063\u0068\u0061\u0072\u0061\u0063\u0074e\u0072\u0020\u006eo\u0074\u0020\u0062\u0065i\u006e\u0067\u0020\u0075\u0073\u0065d\u0020\u0061\u0073\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006e\u0064\u0069n\u0067\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e");_afgf ._aggcb .Discard (1);}else {if _aggcc [0]=='e'{_abde ,_gcffa :=_afgf .readTextLine ();if _gcffa !=nil {return nil ,_gcffa ;};if len (_abde )>=6&&_abde [0:6]=="\u0065\u006e\u0064\u006f\u0062\u006a"{break ;};}else if _aggcc [0]=='s'{_aggcc ,_ =_afgf ._aggcb .Peek (10);if string (_aggcc [:6])=="\u0073\u0074\u0072\u0065\u0061\u006d"{_abdb :=6;if len (_aggcc )> 6{if IsWhiteSpace (_aggcc [_abdb ])&&_aggcc [_abdb ]!='\r'&&_aggcc [_abdb ]!='\n'{_fcb .Log .Debug ("\u004e\u006fn\u002d\u0063\u006f\u006e\u0066\u006f\u0072\u006d\u0061\u006e\u0074\u0020\u0050\u0044\u0046\u0020\u006e\u006f\u0074 \u0065\u006e\u0064\u0069\u006e\u0067 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0069\u006e\u0065\u0020\u0070\u0072o\u0070\u0065r\u006c\u0079\u0020\u0077i\u0074\u0068\u0020\u0045\u004fL\u0020\u006d\u0061\u0072\u006b\u0065\u0072");_abdb ++;};if _aggcc [_abdb ]=='\r'{_abdb ++;if _aggcc [_abdb ]=='\n'{_abdb ++;};}else if _aggcc [_abdb ]=='\n'{_abdb ++;};};_afgf ._aggcb .Discard (_abdb );_gfeb ,_agcc :=_dfcd .PdfObject .(*PdfObjectDictionary );if !_agcc {return nil ,_ca .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006di\u0073s\u0069\u006e\u0067\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_fcb .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0069c\u0074\u0020\u0025\u0073",_gfeb );_abac ,_caae :=_afgf .traceStreamLength (_gfeb .Get ("\u004c\u0065\u006e\u0067\u0074\u0068"));if _caae !=nil {_fcb .Log .Debug ("\u0046\u0061\u0069l\u0020\u0074\u006f\u0020t\u0072\u0061\u0063\u0065\u0020\u0073\u0074r\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0025\u0076",_caae );return nil ,_caae ;};_fcb .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_abac );_dfgee ,_gfba :=_abac .(*PdfObjectInteger );if !_gfba {return nil ,_ca .New ("\u0073\u0074re\u0061\u006d\u0020l\u0065\u006e\u0067\u0074h n\u0065ed\u0073\u0020\u0074\u006f\u0020\u0062\u0065 a\u006e\u0020\u0069\u006e\u0074\u0065\u0067e\u0072");};_aeba :=*_dfgee ;if _aeba < 0{return nil ,_ca .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006e\u0065\u0065\u0064\u0073\u0020\u0074\u006f \u0062e\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0030");};_ggbe :=_afgf .GetFileOffset ();_eggec :=_afgf .xrefNextObjectOffset (_ggbe );if _ggbe +int64 (_aeba )> _eggec &&_eggec > _ggbe {_fcb .Log .Debug ("E\u0078\u0070\u0065\u0063te\u0064 \u0065\u006e\u0064\u0069\u006eg\u0020\u0061\u0074\u0020\u0025\u0064",_ggbe +int64 (_aeba ));_fcb .Log .Debug ("\u004e\u0065\u0078\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020\u0061t\u0020\u0025\u0064",_eggec );_ggeab :=_eggec -_ggbe -17;if _ggeab < 0{return nil ,_ca .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020go\u0069\u006e\u0067 \u0070\u0061s\u0074\u0020\u0062\u006f\u0075\u006ed\u0061\u0072i\u0065\u0073");};_fcb .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0061\u0020l\u0065\u006e\u0067\u0074\u0068\u0020c\u006f\u0072\u0072\u0065\u0063\u0074\u0069\u006f\u006e\u0020\u0074\u006f\u0020%\u0064\u002e\u002e\u002e",_ggeab );_aeba =PdfObjectInteger (_ggeab );_gfeb .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (_ggeab ));};if int64 (_aeba )> _afgf ._bgbf {_fcb .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0053t\u0072\u0065\u0061\u006d\u0020l\u0065\u006e\u0067\u0074\u0068\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u0061\u0072\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0066\u0069\u006c\u0065\u0020\u0073\u0069\u007a\u0065");return nil ,_ca .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020la\u0072\u0067\u0065r\u0020\u0074h\u0061\u006e\u0020\u0066\u0069\u006ce\u0020\u0073i\u007a\u0065");};_agdd :=make ([]byte ,_aeba );_ ,_caae =_afgf .ReadAtLeast (_agdd ,int (_aeba ));if _caae !=nil {_fcb .Log .Debug ("E\u0052\u0052\u004f\u0052 s\u0074r\u0065\u0061\u006d\u0020\u0028%\u0064\u0029\u003a\u0020\u0025\u0058",len (_agdd ),_agdd );_fcb .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_caae );return nil ,_caae ;};_bfcda :=PdfObjectStream {};_bfcda .Stream =_agdd ;_bfcda .PdfObjectDictionary =_dfcd .PdfObject .(*PdfObjectDictionary );_bfcda .ObjectNumber =_dfcd .ObjectNumber ;_bfcda .GenerationNumber =_dfcd .GenerationNumber ;_bfcda .PdfObjectReference ._fcdb =_afgf ;_afgf .skipSpaces ();_afgf ._aggcb .Discard (9);_afgf .skipSpaces ();return &_bfcda ,nil ;};};_dfcd .PdfObject ,_dbffb =_afgf .parseObject ();if _dfcd .PdfObject ==nil {_fcb .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");_dfcd .PdfObject =MakeNull ();};return &_dfcd ,_dbffb ;};};if _dfcd .PdfObject ==nil {_fcb .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");_dfcd .PdfObject =MakeNull ();};_fcb .Log .Trace ("\u0052\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0021");return &_dfcd ,nil ;};

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_egf *RunLengthEncoder )EncodeBytes (data []byte )([]byte ,error ){_ffae :=_gb .NewReader (data );var _edbe []byte ;var _cabg []byte ;_bgadc ,_cbcda :=_ffae .ReadByte ();if _cbcda ==_ce .EOF {return []byte {},nil ;}else if _cbcda !=nil {return nil ,_cbcda ;};_fdd :=1;for {_afda ,_aaag :=_ffae .ReadByte ();if _aaag ==_ce .EOF {break ;}else if _aaag !=nil {return nil ,_aaag ;};if _afda ==_bgadc {if len (_cabg )> 0{_cabg =_cabg [:len (_cabg )-1];if len (_cabg )> 0{_edbe =append (_edbe ,byte (len (_cabg )-1));_edbe =append (_edbe ,_cabg ...);};_fdd =1;_cabg =[]byte {};};_fdd ++;if _fdd >=127{_edbe =append (_edbe ,byte (257-_fdd ),_bgadc );_fdd =0;};}else {if _fdd > 0{if _fdd ==1{_cabg =[]byte {_bgadc };}else {_edbe =append (_edbe ,byte (257-_fdd ),_bgadc );};_fdd =0;};_cabg =append (_cabg ,_afda );if len (_cabg )>=127{_edbe =append (_edbe ,byte (len (_cabg )-1));_edbe =append (_edbe ,_cabg ...);_cabg =[]byte {};};};_bgadc =_afda ;};if len (_cabg )> 0{_edbe =append (_edbe ,byte (len (_cabg )-1));_edbe =append (_edbe ,_cabg ...);}else if _fdd > 0{_edbe =append (_edbe ,byte (257-_fdd ),_bgadc );};_edbe =append (_edbe ,128);return _edbe ,nil ;};

// NewRunLengthEncoder makes a new run length encoder
func NewRunLengthEncoder ()*RunLengthEncoder {return &RunLengthEncoder {}};

// PdfObjectReference represents the primitive PDF reference object.
type PdfObjectReference struct{_fcdb *PdfParser ;ObjectNumber int64 ;GenerationNumber int64 ;};var _efcad =_cd .MustCompile ("\u005e\\\u0073\u002a\u005b\u002d]\u002a\u0028\u005c\u0064\u002b)\u005cs\u002b(\u005c\u0064\u002b\u0029\u005c\u0073\u002bR");

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_dfag *JPXEncoder )MakeDecodeParams ()PdfObject {return nil };

// GetNameVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetNameVal (obj PdfObject )(_dggga string ,_acba bool ){_caff ,_acba :=TraceToDirectObject (obj ).(*PdfObjectName );if _acba {return string (*_caff ),true ;};return ;};

// String returns a string describing `ind`.
func (_ddge *PdfIndirectObject )String ()string {return _f .Sprintf ("\u0049\u004f\u0062\u006a\u0065\u0063\u0074\u003a\u0025\u0064",(*_ddge ).ObjectNumber );};func (_bdfg *JBIG2Encoder )encodeImage (_bcdf _d .Image )([]byte ,error ){const _dadg ="e\u006e\u0063\u006f\u0064\u0065\u0049\u006d\u0061\u0067\u0065";_ffcf ,_badg :=GoImageToJBIG2 (_bcdf ,JB2ImageAutoThreshold );if _badg !=nil {return nil ,_ef .Wrap (_badg ,_dadg ,"\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069m\u0061g\u0065\u0020\u0074\u006f\u0020\u006a\u0062\u0069\u0067\u0032\u0020\u0069\u006d\u0067");};if _badg =_bdfg .AddPageImage (_ffcf ,&_bdfg .DefaultPageSettings );_badg !=nil {return nil ,_ef .Wrap (_badg ,_dadg ,"");};return _bdfg .Encode ();};func (_eddad *PdfParser )parseArray ()(*PdfObjectArray ,error ){_cefg :=MakeArray ();_eddad ._aggcb .ReadByte ();for {_eddad .skipSpaces ();_gadd ,_gebf :=_eddad ._aggcb .Peek (1);if _gebf !=nil {return _cefg ,_gebf ;};if _gadd [0]==']'{_eddad ._aggcb .ReadByte ();break ;};_gaaf ,_gebf :=_eddad .parseObject ();if _gebf !=nil {return _cefg ,_gebf ;};_cefg .Append (_gaaf );};return _cefg ,nil ;};

// AddPageImage adds the page with the image 'img' to the encoder context in order to encode it jbig2 document.
// The 'settings' defines what encoding type should be used by the encoder.
func (_abcb *JBIG2Encoder )AddPageImage (img *JBIG2Image ,settings *JBIG2EncoderSettings )(_defga error ){const _fdcgg ="\u004a\u0042\u0049\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0041\u0064\u0064\u0050\u0061\u0067\u0065\u0049m\u0061\u0067\u0065";if _abcb ==nil {return _ef .Error (_fdcgg ,"J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u0020\u0069\u0073 n\u0069\u006c");};if settings ==nil {settings =&_abcb .DefaultPageSettings ;};if _abcb ._bbbed ==nil {_abcb ._bbbed =_dee .InitEncodeDocument (settings .FileMode );};if _defga =settings .Validate ();_defga !=nil {return _ef .Wrap (_defga ,_fdcgg ,"");};_bfe ,_defga :=img .toBitmap ();if _defga !=nil {return _ef .Wrap (_defga ,_fdcgg ,"");};switch settings .Compression {case JB2Generic :if _defga =_abcb ._bbbed .AddGenericPage (_bfe ,settings .DuplicatedLinesRemoval );_defga !=nil {return _ef .Wrap (_defga ,_fdcgg ,"");};case JB2SymbolCorrelation :return _ef .Error (_fdcgg ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");case JB2SymbolRankHaus :return _ef .Error (_fdcgg ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");default:return _ef .Error (_fdcgg ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return nil ;};

// GetParser returns the parser for lazy-loading or compare references.
func (_edaee *PdfObjectReference )GetParser ()*PdfParser {return _edaee ._fcdb };func (_fagd *PdfParser )resolveReference (_efga *PdfObjectReference )(PdfObject ,bool ,error ){_bbfb ,_cacg :=_fagd .ObjCache [int (_efga .ObjectNumber )];if _cacg {return _bbfb ,true ,nil ;};_babc ,_gagfc :=_fagd .LookupByReference (*_efga );if _gagfc !=nil {return nil ,false ,_gagfc ;};_fagd .ObjCache [int (_efga .ObjectNumber )]=_babc ;return _babc ,false ,nil ;};

// WriteString outputs the object as it is to be written to file.
func (_ecgd *PdfObjectStream )WriteString ()string {var _fdeeg _ceg .Builder ;_fdeeg .WriteString (_e .FormatInt (_ecgd .ObjectNumber ,10));_fdeeg .WriteString ("\u0020\u0030\u0020\u0052");return _fdeeg .String ();};

// ASCIIHexEncoder implements ASCII hex encoder/decoder.
type ASCIIHexEncoder struct{};

// GetFilterName returns the name of the encoding filter.
func (_cbdg *ASCIIHexEncoder )GetFilterName ()string {return StreamEncodingFilterNameASCIIHex };func (_gecb *PdfParser )repairRebuildXrefsTopDown ()(*XrefTable ,error ){if _gecb ._cdec {return nil ,_f .Errorf ("\u0072\u0065\u0070\u0061\u0069\u0072\u0020\u0066\u0061\u0069\u006c\u0065\u0064");};_gecb ._cdec =true ;_gecb ._dgcfc .Seek (0,_g .SEEK_SET );_gecb ._aggcb =_fc .NewReader (_gecb ._dgcfc );_fcfff :=20;_bfcc :=make ([]byte ,_fcfff );_cebe :=XrefTable {};_cebe .ObjectMap =make (map[int ]XrefObject );for {_cafc ,_cdcde :=_gecb ._aggcb .ReadByte ();if _cdcde !=nil {if _cdcde ==_ce .EOF {break ;}else {return nil ,_cdcde ;};};if _cafc =='j'&&_bfcc [_fcfff -1]=='b'&&_bfcc [_fcfff -2]=='o'&&IsWhiteSpace (_bfcc [_fcfff -3]){_gcea :=_fcfff -4;for IsWhiteSpace (_bfcc [_gcea ])&&_gcea > 0{_gcea --;};if _gcea ==0||!IsDecimalDigit (_bfcc [_gcea ]){continue ;};for IsDecimalDigit (_bfcc [_gcea ])&&_gcea > 0{_gcea --;};if _gcea ==0||!IsWhiteSpace (_bfcc [_gcea ]){continue ;};for IsWhiteSpace (_bfcc [_gcea ])&&_gcea > 0{_gcea --;};if _gcea ==0||!IsDecimalDigit (_bfcc [_gcea ]){continue ;};for IsDecimalDigit (_bfcc [_gcea ])&&_gcea > 0{_gcea --;};if _gcea ==0{continue ;};_efgfe :=_gecb .GetFileOffset ()-int64 (_fcfff -_gcea );_cbac :=append (_bfcc [_gcea +1:],_cafc );_cbbce ,_feec ,_eeag :=_ebbdg (string (_cbac ));if _eeag !=nil {_fcb .Log .Debug ("\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u006e\u0075\u006d\u0062\u0065r\u003a\u0020\u0025\u0076",_eeag );return nil ,_eeag ;};if _fcdea ,_fefe :=_cebe .ObjectMap [_cbbce ];!_fefe ||_fcdea .Generation < _feec {_fbed :=XrefObject {};_fbed .XType =XrefTypeTableEntry ;_fbed .ObjectNumber =int (_cbbce );_fbed .Generation =int (_feec );_fbed .Offset =_efgfe ;_cebe .ObjectMap [_cbbce ]=_fbed ;};};_bfcc =append (_bfcc [1:_fcfff ],_cafc );};return &_cebe ,nil ;};

// ToGoImage converts the JBIG2Image to the golang image.Image.
func (_fbbf *JBIG2Image )ToGoImage ()(_d .Image ,error ){const _bfge ="J\u0042I\u0047\u0032\u0049\u006d\u0061\u0067\u0065\u002eT\u006f\u0047\u006f\u0049ma\u0067\u0065";if _fbbf .Data ==nil {return nil ,_ef .Error (_bfge ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");};if _fbbf .Width ==0||_fbbf .Height ==0{return nil ,_ef .Error (_bfge ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");};_ebbc ,_aead :=_bed .NewImage (_fbbf .Width ,_fbbf .Height ,1,1,_fbbf .Data ,nil ,nil );if _aead !=nil {return nil ,_aead ;};return _ebbc ,nil ;};

// NewParser creates a new parser for a PDF file via ReadSeeker. Loads the cross reference stream and trailer.
// An error is returned on failure.
func NewParser (rs _ce .ReadSeeker )(*PdfParser ,error ){_ebge :=&PdfParser {_dgcfc :rs ,ObjCache :make (objectCache ),_efea :map[int64 ]bool {}};_aecb ,_bbbf ,_efff :=_ebge .parsePdfVersion ();if _efff !=nil {_fcb .Log .Error ("U\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0076e\u0072\u0073\u0069o\u006e:\u0020\u0025\u0076",_efff );return nil ,_efff ;};_ebge ._cbgad .Major =_aecb ;_ebge ._cbgad .Minor =_bbbf ;if _ebge ._fdb ,_efff =_ebge .loadXrefs ();_efff !=nil {_fcb .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020F\u0061\u0069\u006c\u0065d t\u006f l\u006f\u0061\u0064\u0020\u0078\u0072\u0065f \u0074\u0061\u0062\u006c\u0065\u0021\u0020%\u0073",_efff );return nil ,_efff ;};_fcb .Log .Trace ("T\u0072\u0061\u0069\u006c\u0065\u0072\u003a\u0020\u0025\u0073",_ebge ._fdb );if len (_ebge ._gaeec .ObjectMap )==0{return nil ,_f .Errorf ("\u0065\u006d\u0070\u0074\u0079\u0020\u0058\u0052\u0045\u0046\u0020t\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0049\u006e\u0076a\u006c\u0069\u0064");};return _ebge ,nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_cgeg *JPXEncoder )UpdateParams (params *PdfObjectDictionary ){};var _bggf =_cd .MustCompile ("\u005e\u005b\\\u002b\u002d\u002e\u005d*\u0028\u005b0\u002d\u0039\u002e\u005d\u002b\u0029\u005b\u0065E\u005d\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");const (JB2Generic JBIG2CompressionType =iota ;JB2SymbolCorrelation ;JB2SymbolRankHaus ;);

// MakeFloat creates an PdfObjectFloat from a float64.
func MakeFloat (val float64 )*PdfObjectFloat {_adfc :=PdfObjectFloat (val );return &_adfc };

// JPXEncoder implements JPX encoder/decoder (dummy, for now)
// FIXME: implement
type JPXEncoder struct{};func _dgbc (_degf ,_cfbc ,_cfdfd uint8 )uint8 {_ebff :=int (_cfdfd );_dcba :=int (_cfbc )-_ebff ;_edbg :=int (_degf )-_ebff ;_ebff =_aebb (_dcba +_edbg );_dcba =_aebb (_dcba );_edbg =_aebb (_edbg );if _dcba <=_edbg &&_dcba <=_ebff {return _degf ;}else if _edbg <=_ebff {return _cfbc ;};return _cfdfd ;};

// JBIG2EncoderSettings contains the parameters and settings used by the JBIG2Encoder.
// Current version works only on JB2Generic compression.
type JBIG2EncoderSettings struct{

// FileMode defines if the jbig2 encoder should return full jbig2 file instead of
// shortened pdf mode. This adds the file header to the jbig2 definition.
FileMode bool ;

// Compression is the setting that defines the compression type used for encoding the page.
Compression JBIG2CompressionType ;

// DuplicatedLinesRemoval code generic region in a way such that if the lines are duplicated the encoder
// doesn't store it twice.
DuplicatedLinesRemoval bool ;

// DefaultPixelValue is the bit value initial for every pixel in the page.
DefaultPixelValue uint8 ;

// ResolutionX optional setting that defines the 'x' axis input image resolution - used for single page encoding.
ResolutionX int ;

// ResolutionY optional setting that defines the 'y' axis input image resolution - used for single page encoding.
ResolutionY int ;

// Threshold defines the threshold of the image correlation for
// non Generic compression.
// User only for JB2SymbolCorrelation and JB2SymbolRankHaus methods.
// Best results in range [0.7 - 0.98] - the less the better the compression would be
// but the more lossy.
// Default value: 0.95
Threshold float64 ;};var _eaeegca =_cd .MustCompile ("\u005b\\\u0072\u005c\u006e\u005d\u005c\u0073\u002a\u0028\u0078\u0072\u0065f\u0029\u005c\u0073\u002a\u005b\u005c\u0072\u005c\u006e\u005d");

// DecodeStream implements ASCII85 stream decoding.
func (_cabb *ASCII85Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _cabb .DecodeBytes (streamObj .Stream );};

// EncodeBytes ASCII encodes the passed in slice of bytes.
func (_dacb *ASCIIHexEncoder )EncodeBytes (data []byte )([]byte ,error ){var _dfeg _gb .Buffer ;for _ ,_dfbd :=range data {_dfeg .WriteString (_f .Sprintf ("\u0025\u002e\u0032X\u0020",_dfbd ));};_dfeg .WriteByte ('>');return _dfeg .Bytes (),nil ;};

// DCTEncoder provides a DCT (JPG) encoding/decoding functionality for images.
type DCTEncoder struct{ColorComponents int ;BitsPerComponent int ;Width int ;Height int ;Quality int ;};var _cgbd =_cd .MustCompile ("\u0025\u0025\u0045\u004f\u0046\u003f");func (_feg *PdfParser )seekToEOFMarker (_dcdg int64 )error {var _gdbfe int64 ;var _bdefb int64 =2048;for _gdbfe < _dcdg -4{if _dcdg <=(_bdefb +_gdbfe ){_bdefb =_dcdg -_gdbfe ;};_ ,_bccg :=_feg ._dgcfc .Seek (-_gdbfe -_bdefb ,_ce .SeekEnd );if _bccg !=nil {return _bccg ;};_gaae :=make ([]byte ,_bdefb );_feg ._dgcfc .Read (_gaae );_fcb .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0045\u004f\u0046 \u006da\u0072\u006b\u0065\u0072\u003a\u0020\u0022%\u0073\u0022",string (_gaae ));_gfege :=_cgbd .FindAllStringIndex (string (_gaae ),-1);if _gfege !=nil {_ggfac :=_gfege [len (_gfege )-1];_fcb .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_gfege );_feg ._dgcfc .Seek (-_gdbfe -_bdefb +int64 (_ggfac [0]),_ce .SeekEnd );return nil ;};_fcb .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");_gdbfe +=_bdefb -4;};_fcb .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006be\u0072 \u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u002e");return _ca .New ("\u0045\u004f\u0046\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};

// DecodeStream decodes the stream containing CCITTFax encoded image data.
func (_gefa *CCITTFaxEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _gefa .DecodeBytes (streamObj .Stream );};

// MakeArray creates an PdfObjectArray from a list of PdfObjects.
func MakeArray (objects ...PdfObject )*PdfObjectArray {_cbdde :=&PdfObjectArray {};_cbdde ._ageac =[]PdfObject {};for _ ,_bgbdc :=range objects {_cbdde ._ageac =append (_cbdde ._ageac ,_bgbdc );};return _cbdde ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_cge *JPXEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};

// DecodeBytes decodes a slice of JPX encoded bytes and returns the result.
func (_bfag *JPXEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_fcb .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_bfag .GetFilterName ());return encoded ,ErrNoJPXDecode ;};func _def (_adca *_ff .StdEncryptDict ,_faf *PdfObjectDictionary ){_faf .Set ("\u0052",MakeInteger (int64 (_adca .R )));_faf .Set ("\u0050",MakeInteger (int64 (_adca .P )));_faf .Set ("\u004f",MakeStringFromBytes (_adca .O ));_faf .Set ("\u0055",MakeStringFromBytes (_adca .U ));if _adca .R >=5{_faf .Set ("\u004f\u0045",MakeStringFromBytes (_adca .OE ));_faf .Set ("\u0055\u0045",MakeStringFromBytes (_adca .UE ));_faf .Set ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061",MakeBool (_adca .EncryptMetadata ));if _adca .R > 5{_faf .Set ("\u0050\u0065\u0072m\u0073",MakeStringFromBytes (_adca .Perms ));};};};

// PdfParser parses a PDF file and provides access to the object structure of the PDF.
type PdfParser struct{_cbgad Version ;_dgcfc _ce .ReadSeeker ;_aggcb *_fc .Reader ;_bgbf int64 ;_gaeec XrefTable ;_dadb int64 ;_cffe *xrefType ;_ccdc objectStreams ;_fdb *PdfObjectDictionary ;_dgdd *PdfCrypt ;_cdec bool ;ObjCache objectCache ;_efea map[int64 ]bool ;};func _fcbg (_bccgf PdfObject )(*float64 ,error ){switch _cbfbc :=_bccgf .(type ){case *PdfObjectFloat :_addfd :=float64 (*_cbfbc );return &_addfd ,nil ;case *PdfObjectInteger :_ccbc :=float64 (*_cbfbc );return &_ccbc ,nil ;case *PdfObjectNull :return nil ,nil ;};return nil ,ErrNotANumber ;};func (_dad *PdfCrypt )saveCryptFilters (_edd *PdfObjectDictionary )error {if _dad ._bf .V < 4{return _ca .New ("\u0063\u0061\u006e\u0020\u006f\u006e\u006c\u0079\u0020\u0062\u0065 \u0075\u0073\u0065\u0064\u0020\u0077\u0069\u0074\u0068\u0020V\u003e\u003d\u0034");};_dda :=MakeDict ();_edd .Set ("\u0043\u0046",_dda );for _ade ,_agg :=range _dad ._fgf {if _ade =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{continue ;};_dca :=_fba (_agg ,"");_dda .Set (PdfObjectName (_ade ),_dca );};_edd .Set ("\u0053\u0074\u0072\u0046",MakeName (_dad ._bef ));_edd .Set ("\u0053\u0074\u006d\u0046",MakeName (_dad ._eag ));return nil ;};

// WriteString outputs the object as it is to be written to file.
func (_agbfd *PdfObjectBool )WriteString ()string {if *_agbfd {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};func (_bbc *PdfCrypt )authenticate (_gdc []byte )(bool ,error ){_bbc ._bbaa =false ;_ecf :=_bbc .securityHandler ();_ggge ,_egc ,_cegc :=_ecf .Authenticate (&_bbc ._bbd ,_gdc );if _cegc !=nil {return false ,_cegc ;}else if _egc ==0||len (_ggge )==0{return false ,nil ;};_bbc ._bbaa =true ;_bbc ._efa =_ggge ;return true ,nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_fcagb *CCITTFaxEncoder )MakeStreamDict ()*PdfObjectDictionary {_gbbb :=MakeDict ();_gbbb .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_fcagb .GetFilterName ()));_babe :=_fcagb .MakeDecodeParams ();if _babe !=nil {_gbbb .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_babe );};return _gbbb ;};

// String returns a string representation of the *PdfObjectString.
func (_ecff *PdfObjectString )String ()string {return _ecff ._bebd };

// String returns a string describing `null`.
func (_fedfc *PdfObjectNull )String ()string {return "\u006e\u0075\u006c\u006c"};func (_fef *PdfCrypt )loadCryptFilters (_dac *PdfObjectDictionary )error {_fef ._fgf =cryptFilters {};_ceba :=_dac .Get ("\u0043\u0046");_ceba =TraceToDirectObject (_ceba );if _caf ,_cafd :=_ceba .(*PdfObjectReference );_cafd {_fcg ,_aec :=_fef ._becce .LookupByReference (*_caf );if _aec !=nil {_fcb .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0075\u0070\u0020\u0043\u0046\u0020\u0072\u0065\u0066\u0065\u0072en\u0063\u0065");return _aec ;};_ceba =TraceToDirectObject (_fcg );};_eeg ,_cadb :=_ceba .(*PdfObjectDictionary );if !_cadb {_fcb .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0043\u0046\u002c \u0074\u0079\u0070\u0065: \u0025\u0054",_ceba );return _ca .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0043\u0046");};for _ ,_fge :=range _eeg .Keys (){_aac :=_eeg .Get (_fge );if _ec ,_bbb :=_aac .(*PdfObjectReference );_bbb {_eee ,_bcfb :=_fef ._becce .LookupByReference (*_ec );if _bcfb !=nil {_fcb .Log .Debug ("\u0045\u0072ro\u0072\u0020\u006co\u006f\u006b\u0075\u0070 up\u0020di\u0063\u0074\u0069\u006f\u006e\u0061\u0072y \u0072\u0065\u0066\u0065\u0072\u0065\u006ec\u0065");return _bcfb ;};_aac =TraceToDirectObject (_eee );};_fde ,_cgb :=_aac .(*PdfObjectDictionary );if !_cgb {return _f .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074\u0020\u0069\u006e \u0043\u0046\u0020\u0028\u006e\u0061\u006d\u0065\u0020\u0025\u0073\u0029\u0020-\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079\u0020\u0062\u0075\u0074\u0020\u0025\u0054",_fge ,_aac );};if _fge =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{_fcb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u002d\u0020\u0043\u0061\u006e\u006e\u006f\u0074\u0020\u006f\u0076\u0065\u0072\u0077r\u0069\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0069d\u0065\u006e\u0074\u0069\u0074\u0079\u0020\u0066\u0069\u006c\u0074\u0065\u0072 \u002d\u0020\u0054\u0072\u0079\u0069n\u0067\u0020\u006ee\u0078\u0074");continue ;};var _dabf _gbb .FilterDict ;if _fag :=_ggf (&_dabf ,_fde );_fag !=nil {return _fag ;};_bfc ,_aea :=_gbb .NewFilter (_dabf );if _aea !=nil {return _aea ;};_fef ._fgf [string (_fge )]=_bfc ;};_fef ._fgf ["\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"]=_gbb .NewIdentity ();_fef ._bef ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _dfgb ,_ebd :=_dac .Get ("\u0053\u0074\u0072\u0046").(*PdfObjectName );_ebd {if _ ,_bdea :=_fef ._fgf [string (*_dfgb )];!_bdea {return _f .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u0072\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_dfgb );};_fef ._bef =string (*_dfgb );};_fef ._eag ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _dce ,_bgb :=_dac .Get ("\u0053\u0074\u006d\u0046").(*PdfObjectName );_bgb {if _ ,_bff :=_fef ._fgf [string (*_dce )];!_bff {return _f .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u006d\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_dce );};_fef ._eag =string (*_dce );};return nil ;};

// PdfCryptNewEncrypt makes the document crypt handler based on a specified crypt filter.
func PdfCryptNewEncrypt (cf _gbb .Filter ,userPass ,ownerPass []byte ,perm _ff .Permissions )(*PdfCrypt ,*EncryptInfo ,error ){_dbb :=&PdfCrypt {_dabd :make (map[PdfObject ]bool ),_fgf :make (cryptFilters ),_bbd :_ff .StdEncryptDict {P :perm ,EncryptMetadata :true }};var _cda Version ;if cf !=nil {_fab :=cf .PDFVersion ();_cda .Major ,_cda .Minor =_fab [0],_fab [1];V ,R :=cf .HandlerVersion ();_dbb ._bf .V =V ;_dbb ._bbd .R =R ;_dbb ._bf .Length =cf .KeyLength ()*8;};const (_eea =_agd ;);_dbb ._fgf [_eea ]=cf ;if _dbb ._bf .V >=4{_dbb ._eag =_eea ;_dbb ._bef =_eea ;};_eaaf :=_dbb .newEncryptDict ();_effg :=_ab .Sum ([]byte (_ea .Now ().Format (_ea .RFC850 )));_becc :=string (_effg [:]);_ged :=make ([]byte ,100);_fa .Read (_ged );_effg =_ab .Sum (_ged );_daed :=string (_effg [:]);_fcb .Log .Trace ("\u0052\u0061\u006e\u0064\u006f\u006d\u0020\u0062\u003a\u0020\u0025\u0020\u0078",_ged );_fcb .Log .Trace ("\u0047\u0065\u006e\u0020\u0049\u0064\u0020\u0030\u003a\u0020\u0025\u0020\u0078",_becc );_dbb ._bea =string (_becc );_agb :=_dbb .generateParams (userPass ,ownerPass );if _agb !=nil {return nil ,nil ,_agb ;};_def (&_dbb ._bbd ,_eaaf );if _dbb ._bf .V >=4{if _fda :=_dbb .saveCryptFilters (_eaaf );_fda !=nil {return nil ,nil ,_fda ;};};return _dbb ,&EncryptInfo {Version :_cda ,Encrypt :_eaaf ,ID0 :_becc ,ID1 :_daed },nil ;};func _ffcaa (_gaec int )int {if _gaec < 0{return -_gaec ;};return _gaec ;};func (_fbd *PdfCrypt )encryptBytes (_faa []byte ,_cdgc string ,_ddad []byte )([]byte ,error ){_fcb .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");_ggbg ,_fff :=_fbd ._fgf [_cdgc ];if !_fff {return nil ,_f .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_cdgc );};return _ggbg .EncryptBytes (_faa ,_ddad );};

// ResolveReferencesDeep recursively traverses through object `o`, looking up and replacing
// references with indirect objects.
// Optionally a map of already deep-resolved objects can be provided via `traversed`. The `traversed` map
// is updated while traversing the objects to avoid traversing same objects multiple times.
func ResolveReferencesDeep (o PdfObject ,traversed map[PdfObject ]struct{})error {if traversed ==nil {traversed =map[PdfObject ]struct{}{};};return _ddbf (o ,0,traversed );};

// WriteString outputs the object as it is to be written to file.
func (_afcgc *PdfObjectDictionary )WriteString ()string {var _dbeag _ceg .Builder ;_dbeag .WriteString ("\u003c\u003c");for _ ,_bedcf :=range _afcgc ._fddg {_ffaf :=_afcgc ._eedfb [_bedcf ];_dbeag .WriteString (_bedcf .WriteString ());_dbeag .WriteString ("\u0020");_dbeag .WriteString (_ffaf .WriteString ());};_dbeag .WriteString ("\u003e\u003e");return _dbeag .String ();};

// String returns the state of the bool as "true" or "false".
func (_ecfa *PdfObjectBool )String ()string {if *_ecfa {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};

// Resolve resolves the reference and returns the indirect or stream object.
// If the reference cannot be resolved, a *PdfObjectNull object is returned.
func (_cdcc *PdfObjectReference )Resolve ()PdfObject {if _cdcc ._fcdb ==nil {return MakeNull ();};_facab ,_ ,_abdg :=_cdcc ._fcdb .resolveReference (_cdcc );if _abdg !=nil {_fcb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0072\u0065\u0073\u006f\u006cv\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065r\u0065n\u0063\u0065\u003a\u0020\u0025\u0076\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074",_abdg );return MakeNull ();};if _facab ==nil {_fcb .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0072\u0065\u0073ol\u0076\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065:\u0020\u006ei\u006c\u0020\u006fb\u006a\u0065\u0063\u0074\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u0061\u0020nu\u006c\u006c\u0020o\u0062\u006a\u0065\u0063\u0074");return MakeNull ();};return _facab ;};

// WriteString outputs the object as it is to be written to file.
func (_gfge *PdfObjectStreams )WriteString ()string {var _bgdgg _ceg .Builder ;_bgdgg .WriteString (_e .FormatInt (_gfge .ObjectNumber ,10));_bgdgg .WriteString ("\u0020\u0030\u0020\u0052");return _bgdgg .String ();};

// EncodeJBIG2Image encodes 'img' into jbig2 encoded bytes stream, using default encoder settings.
func (_aadg *JBIG2Encoder )EncodeJBIG2Image (img *JBIG2Image )([]byte ,error ){const _bgdf ="c\u006f\u0072\u0065\u002eEn\u0063o\u0064\u0065\u004a\u0042\u0049G\u0032\u0049\u006d\u0061\u0067\u0065";if _faac :=_aadg .AddPageImage (img ,&_aadg .DefaultPageSettings );_faac !=nil {return nil ,_ef .Wrap (_faac ,_bgdf ,"");};return _aadg .Encode ();};

// GetFloat returns the *PdfObjectFloat represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetFloat (obj PdfObject )(_bacf *PdfObjectFloat ,_cacgd bool ){_bacf ,_cacgd =TraceToDirectObject (obj ).(*PdfObjectFloat );return _bacf ,_cacgd ;};

// DecodeStream implements ASCII hex decoding.
func (_cdd *ASCIIHexEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _cdd .DecodeBytes (streamObj .Stream );};const JB2ImageAutoThreshold =-1.0;

// DecodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_efbg *RawEncoder )DecodeBytes (encoded []byte )([]byte ,error ){return encoded ,nil };

// GetDict returns the *PdfObjectDictionary represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetDict (obj PdfObject )(_cdgea *PdfObjectDictionary ,_agef bool ){_cdgea ,_agef =TraceToDirectObject (obj ).(*PdfObjectDictionary );return _cdgea ,_agef ;};

// EncodeBytes encodes the passed in slice of bytes by passing it through the
// EncodeBytes method of the underlying encoders.
func (_gaee *MultiEncoder )EncodeBytes (data []byte )([]byte ,error ){_cbeg :=data ;var _ccea error ;for _bafc :=len (_gaee ._caab )-1;_bafc >=0;_bafc --{_cbfee :=_gaee ._caab [_bafc ];_cbeg ,_ccea =_cbfee .EncodeBytes (_cbeg );if _ccea !=nil {return nil ,_ccea ;};};return _cbeg ,nil ;};func (_edb *PdfCrypt )securityHandler ()_ff .StdHandler {if _edb ._bbd .R >=5{return _ff .NewHandlerR6 ();};return _ff .NewHandlerR4 (_edb ._bea ,_edb ._bf .Length );};

// EncryptInfo contains an information generated by the document encrypter.
type EncryptInfo struct{Version ;

// Encrypt is an encryption dictionary that contains all necessary parameters.
// It should be stored in all copies of the document trailer.
Encrypt *PdfObjectDictionary ;

// ID0 and ID1 are IDs used in the trailer. Older algorithms such as RC4 uses them for encryption.
ID0 ,ID1 string ;};func (_ffd *PdfParser )parseHexString ()(*PdfObjectString ,error ){_ffd ._aggcb .ReadByte ();var _bdcf _gb .Buffer ;for {_eggd ,_affc :=_ffd ._aggcb .Peek (1);if _affc !=nil {return MakeString (""),_affc ;};if _eggd [0]=='>'{_ffd ._aggcb .ReadByte ();break ;};_fedc ,_ :=_ffd ._aggcb .ReadByte ();if !IsWhiteSpace (_fedc ){_bdcf .WriteByte (_fedc );};};if _bdcf .Len ()%2==1{_bdcf .WriteRune ('0');};_dgee ,_ :=_cb .DecodeString (_bdcf .String ());return MakeHexString (string (_dgee )),nil ;};func _fcgg (_efag *PdfObjectStream ,_beed *PdfObjectDictionary )(*RunLengthEncoder ,error ){return NewRunLengthEncoder (),nil ;};

// DecodeStream decodes the stream data and returns the decoded data.
// An error is returned upon failure.
func DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_fcb .Log .Trace ("\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_adfcf ,_dfda :=NewEncoderFromStream (streamObj );if _dfda !=nil {_fcb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_dfda );return nil ,_dfda ;};_fcb .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076\u000a",_adfcf );_befff ,_dfda :=_adfcf .DecodeStream (streamObj );if _dfda !=nil {_fcb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_dfda );return nil ,_dfda ;};return _befff ,nil ;};const _deaf =32<<(^uint (0)>>63);func _geddb (_cbge ,_bfafe ,_cadfg int )error {if _bfafe < 0||_bfafe > _cbge {return _ca .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0061\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");};if _cadfg < _bfafe {return _ca .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0073\u006c\u0069\u0063e\u0020i\u006ed\u0065\u0078\u0020\u0062\u0020\u003c\u0020a");};if _cadfg > _cbge {return _ca .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0062\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");};return nil ;};func (_ebdcb *PdfParser )inspect ()(map[string ]int ,error ){_fcb .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0053P\u0045\u0043\u0054\u0020\u002d\u002d\u002d\u002d\u002d\u002d-\u002d\u002d\u002d");_fcb .Log .Trace ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");_fedb :=map[string ]int {};_bcge :=0;_bfcfa :=0;var _cfebe []int ;for _afcgcc :=range _ebdcb ._gaeec .ObjectMap {_cfebe =append (_cfebe ,_afcgcc );};_cad .Ints (_cfebe );_eadf :=0;for _ ,_ggca :=range _cfebe {_agega :=_ebdcb ._gaeec .ObjectMap [_ggca ];if _agega .ObjectNumber ==0{continue ;};_bcge ++;_fcb .Log .Trace ("\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d");_fcb .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0075\u0070\u0020\u006f\u0062\u006a\u0065c\u0074 \u006e\u0075\u006d\u0062\u0065\u0072\u003a \u0025\u0064",_agega .ObjectNumber );_acgef ,_begab :=_ebdcb .LookupByNumber (_agega .ObjectNumber );if _begab !=nil {_fcb .Log .Trace ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u006c\u006f\u006f\u006b\u0075p\u0020\u006f\u0062\u006a\u0020\u0025\u0064 \u0028\u0025\u0073\u0029",_agega .ObjectNumber ,_begab );_bfcfa ++;continue ;};_fcb .Log .Trace ("\u006fb\u006a\u003a\u0020\u0025\u0073",_acgef );_bcdb ,_bdg :=_acgef .(*PdfIndirectObject );if _bdg {_fcb .Log .Trace ("\u0049N\u0044 \u004f\u004f\u0042\u004a\u0020\u0025\u0064\u003a\u0020\u0025\u0073",_agega .ObjectNumber ,_bcdb );_bgcba ,_eebeb :=_bcdb .PdfObject .(*PdfObjectDictionary );if _eebeb {if _efdaf ,_ddgde :=_bgcba .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_ddgde {_bafg :=string (*_efdaf );_fcb .Log .Trace ("\u002d\u002d\u002d\u003e\u0020\u004f\u0062\u006a\u0020\u0074\u0079\u0070e\u003a\u0020\u0025\u0073",_bafg );_ ,_dafe :=_fedb [_bafg ];if _dafe {_fedb [_bafg ]++;}else {_fedb [_bafg ]=1;};}else if _afgb ,_ffef :=_bgcba .Get ("\u0053u\u0062\u0074\u0079\u0070\u0065").(*PdfObjectName );_ffef {_agafef :=string (*_afgb );_fcb .Log .Trace ("-\u002d-\u003e\u0020\u004f\u0062\u006a\u0020\u0073\u0075b\u0074\u0079\u0070\u0065: \u0025\u0073",_agafef );_ ,_bgae :=_fedb [_agafef ];if _bgae {_fedb [_agafef ]++;}else {_fedb [_agafef ]=1;};};if _cgfd ,_bdeee :=_bgcba .Get ("\u0053").(*PdfObjectName );_bdeee &&*_cgfd =="\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"{_ ,_dffd :=_fedb ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"];if _dffd {_fedb ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]++;}else {_fedb ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]=1;};};};}else if _adedd ,_acdc :=_acgef .(*PdfObjectStream );_acdc {if _debdc ,_eddg :=_adedd .PdfObjectDictionary .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_eddg {_fcb .Log .Trace ("\u002d\u002d\u003e\u0020\u0053\u0074\u0072\u0065\u0061\u006d\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073",*_debdc );_gggfe :=string (*_debdc );if _ ,_dgba :=_fedb [_gggfe ];_dgba {_fedb [_gggfe ]++;}else {_fedb [_gggfe ]=1;};};}else {_cabge ,_afead :=_acgef .(*PdfObjectDictionary );if _afead {_fgcge ,_abge :=_cabge .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if _abge {_beebba :=string (*_fgcge );_fcb .Log .Trace ("\u002d-\u002d \u006f\u0062\u006a\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073",_beebba );_fedb [_beebba ]++;};};_fcb .Log .Trace ("\u0044\u0049\u0052\u0045\u0043\u0054\u0020\u004f\u0042\u004a\u0020\u0025d\u003a\u0020\u0025\u0073",_agega .ObjectNumber ,_acgef );};_eadf ++;};_fcb .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0045\u004fF\u0020\u0049\u004e\u0053\u0050\u0045\u0043T\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d");_fcb .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");_fcb .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074 \u0063\u006f\u0075\u006e\u0074\u003a\u0020\u0025\u0064",_bcge );_fcb .Log .Trace ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u006f\u006b\u0075p\u003a\u0020\u0025\u0064",_bfcfa );for _begb ,_eaabf :=range _fedb {_fcb .Log .Trace ("\u0025\u0073\u003a\u0020\u0025\u0064",_begb ,_eaabf );};_fcb .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");if len (_ebdcb ._gaeec .ObjectMap )< 1{_fcb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0068\u0069\u0073 \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074 \u0069s\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0028\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0021\u0029");return nil ,_f .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0064\u006fc\u0075\u006d\u0065\u006e\u0074\u0020\u0028\u0078r\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006d\u0069\u0073s\u0069\u006e\u0067\u0029");};_dcaf ,_bade :=_fedb ["\u0046\u006f\u006e\u0074"];if !_bade ||_dcaf < 2{_fcb .Log .Trace ("\u0054\u0068\u0069s \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020i\u0073 \u0070r\u006fb\u0061\u0062\u006c\u0079\u0020\u0073\u0063\u0061\u006e\u006e\u0065\u0064\u0021");}else {_fcb .Log .Trace ("\u0054\u0068\u0069\u0073\u0020\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020\u0069\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0066o\u0072\u0020\u0065\u0078\u0074r\u0061\u0063t\u0069\u006f\u006e\u0021");};return _fedb ,nil ;};

// RawEncoder implements Raw encoder/decoder (no encoding, pass through)
type RawEncoder struct{};

// MakeInteger creates a PdfObjectInteger from an int64.
func MakeInteger (val int64 )*PdfObjectInteger {_aaad :=PdfObjectInteger (val );return &_aaad };func _efe (_dae XrefTable ){_fcb .Log .Debug ("\u003dX\u003d\u0058\u003d\u0058\u003d");_fcb .Log .Debug ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");_ega :=0;for _ ,_dbe :=range _dae .ObjectMap {_fcb .Log .Debug ("i\u002b\u0031\u003a\u0020\u0025\u0064 \u0028\u006f\u0062\u006a\u0020\u006eu\u006d\u003a\u0020\u0025\u0064\u0020\u0067e\u006e\u003a\u0020\u0025\u0064\u0029\u0020\u002d\u003e\u0020%\u0064",_ega +1,_dbe .ObjectNumber ,_dbe .Generation ,_dbe .Offset );_ega ++;};};func _eedbf (_cgbdae ,_degfg PdfObject ,_afed int )bool {if _afed > _bcfbg {_fcb .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_bcfbg );return false ;};if _cgbdae ==nil &&_degfg ==nil {return true ;}else if _cgbdae ==nil ||_degfg ==nil {return false ;};if _b .TypeOf (_cgbdae )!=_b .TypeOf (_degfg ){return false ;};switch _cebb :=_cgbdae .(type ){case *PdfObjectNull ,*PdfObjectReference :return true ;case *PdfObjectName :return *_cebb ==*(_degfg .(*PdfObjectName ));case *PdfObjectString :return *_cebb ==*(_degfg .(*PdfObjectString ));case *PdfObjectInteger :return *_cebb ==*(_degfg .(*PdfObjectInteger ));case *PdfObjectBool :return *_cebb ==*(_degfg .(*PdfObjectBool ));case *PdfObjectFloat :return *_cebb ==*(_degfg .(*PdfObjectFloat ));case *PdfIndirectObject :return _eedbf (TraceToDirectObject (_cgbdae ),TraceToDirectObject (_degfg ),_afed +1);case *PdfObjectArray :_aedac :=_degfg .(*PdfObjectArray );if len ((*_cebb )._ageac )!=len ((*_aedac )._ageac ){return false ;};for _cbfcg ,_abeb :=range (*_cebb )._ageac {if !_eedbf (_abeb ,(*_aedac )._ageac [_cbfcg ],_afed +1){return false ;};};return true ;case *PdfObjectDictionary :_bcgd :=_degfg .(*PdfObjectDictionary );_cdfb ,_eacgd :=(*_cebb )._eedfb ,(*_bcgd )._eedfb ;if len (_cdfb )!=len (_eacgd ){return false ;};for _bdae ,_bedd :=range _cdfb {_dggfc ,_fgdd :=_eacgd [_bdae ];if !_fgdd ||!_eedbf (_bedd ,_dggfc ,_afed +1){return false ;};};return true ;case *PdfObjectStream :_edggae :=_degfg .(*PdfObjectStream );return _eedbf ((*_cebb ).PdfObjectDictionary ,(*_edggae ).PdfObjectDictionary ,_afed +1);default:_fcb .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",_cgbdae );};return false ;};

// GetIntVal returns the int value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetIntVal (obj PdfObject )(_agebe int ,_ffcbe bool ){_bbcad ,_ffcbe :=TraceToDirectObject (obj ).(*PdfObjectInteger );if _ffcbe &&_bbcad !=nil {return int (*_bbcad ),true ;};return 0,false ;};

// FlateEncoder represents Flate encoding.
type FlateEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Rows int ;Colors int ;_ebb *_bed .ImageBase ;};

// MakeStringFromBytes creates an PdfObjectString from a byte array.
// This is more natural than MakeString as `data` is usually not utf-8 encoded.
func MakeStringFromBytes (data []byte )*PdfObjectString {return MakeString (string (data ))};

// IsAuthenticated returns true if the PDF has already been authenticated for accessing.
func (_daad *PdfParser )IsAuthenticated ()bool {return _daad ._dgdd ._bbaa };

// UpdateParams updates the parameter values of the encoder.
// Implements StreamEncoder interface.
func (_dba *JBIG2Encoder )UpdateParams (params *PdfObjectDictionary ){_abe ,_fccf :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _fccf ==nil {_dba .BitsPerComponent =int (_abe );};_ecc ,_fccf :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _fccf ==nil {_dba .Width =int (_ecc );};_aae ,_fccf :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _fccf ==nil {_dba .Height =int (_aae );};_cgcea ,_fccf :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _fccf ==nil {_dba .ColorComponents =int (_cgcea );};};

// WriteString outputs the object as it is to be written to file.
func (_fegc *PdfObjectReference )WriteString ()string {var _fadgc _ceg .Builder ;_fadgc .WriteString (_e .FormatInt (_fegc .ObjectNumber ,10));_fadgc .WriteString ("\u0020");_fadgc .WriteString (_e .FormatInt (_fegc .GenerationNumber ,10));_fadgc .WriteString ("\u0020\u0052");return _fadgc .String ();};

// DecodeStream decodes a JPX encoded stream and returns the result as a
// slice of bytes.
func (_baac *JPXEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_fcb .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_baac .GetFilterName ());return streamObj .Stream ,ErrNoJPXDecode ;};

// EncodeImage encodes 'img' golang image.Image into jbig2 encoded bytes document using default encoder settings.
func (_debc *JBIG2Encoder )EncodeImage (img _d .Image )([]byte ,error ){return _debc .encodeImage (img )};const (DefaultJPEGQuality =75;);

// String returns a descriptive information string about the encryption method used.
func (_daa *PdfCrypt )String ()string {if _daa ==nil {return "";};_fafe :=_daa ._bf .Filter +"\u0020\u002d\u0020";if _daa ._bf .V ==0{_fafe +="\u0055\u006e\u0064\u006fcu\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0061\u006c\u0067\u006f\u0072\u0069\u0074h\u006d";}else if _daa ._bf .V ==1{_fafe +="\u0052\u0043\u0034:\u0020\u0034\u0030\u0020\u0062\u0069\u0074\u0073";}else if _daa ._bf .V ==2{_fafe +=_f .Sprintf ("\u0052\u0043\u0034:\u0020\u0025\u0064\u0020\u0062\u0069\u0074\u0073",_daa ._bf .Length );}else if _daa ._bf .V ==3{_fafe +="U\u006e\u0070\u0075\u0062li\u0073h\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d";}else if _daa ._bf .V >=4{_fafe +=_f .Sprintf ("\u0053\u0074r\u0065\u0061\u006d\u0020f\u0069\u006ct\u0065\u0072\u003a\u0020\u0025\u0073\u0020\u002d \u0053\u0074\u0072\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0074\u0065r\u003a\u0020\u0025\u0073",_daa ._eag ,_daa ._bef );_fafe +="\u003b\u0020C\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0073\u003a";for _aga ,_egge :=range _daa ._fgf {_fafe +=_f .Sprintf ("\u0020\u002d\u0020\u0025\u0073\u003a\u0020\u0025\u0073 \u0028\u0025\u0064\u0029",_aga ,_egge .Name (),_egge .KeyLength ());};};_ceb :=_daa .GetAccessPermissions ();_fafe +=_f .Sprintf ("\u0020\u002d\u0020\u0025\u0023\u0076",_ceb );return _fafe ;};

// DecodeStream decodes a JBIG2 encoded stream and returns the result as a slice of bytes.
func (_ffce *JBIG2Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _ffce .DecodeBytes (streamObj .Stream );};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_fdf *JBIG2Encoder )MakeStreamDict ()*PdfObjectDictionary {_gfbd :=MakeDict ();_gfbd .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_fdf .GetFilterName ()));return _gfbd ;};

// Encrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_gfb *PdfCrypt )Encrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _gfb .isEncrypted (obj ){return nil ;};switch _cfd :=obj .(type ){case *PdfIndirectObject :_gfb ._dabd [_cfd ]=true ;_fcb .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_cfd .ObjectNumber ,_cfd .GenerationNumber );_aaf :=_cfd .ObjectNumber ;_bdc :=_cfd .GenerationNumber ;_afa :=_gfb .Encrypt (_cfd .PdfObject ,_aaf ,_bdc );if _afa !=nil {return _afa ;};return nil ;case *PdfObjectStream :_gfb ._dabd [_cfd ]=true ;_fgae :=_cfd .PdfObjectDictionary ;if _faca ,_fae :=_fgae .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_fae &&*_faca =="\u0058\u0052\u0065\u0066"{return nil ;};_faaf :=_cfd .ObjectNumber ;_adbg :=_cfd .GenerationNumber ;_fcb .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_faaf ,_adbg );_beea :=_agd ;if _gfb ._bf .V >=4{_beea =_gfb ._eag ;_fcb .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_gfb ._eag );if _bfb ,_dfae :=_fgae .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );_dfae {if _gac ,_egdg :=GetName (_bfb .Get (0));_egdg {if *_gac =="\u0043\u0072\u0079p\u0074"{_beea ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _aca ,_fgagf :=_fgae .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );_fgagf {if _cdac ,_bcba :=_aca .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_bcba {if _ ,_dfd :=_gfb ._fgf [string (*_cdac )];_dfd {_fcb .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_cdac );_beea =string (*_cdac );};};};};};};_fcb .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_beea );if _beea =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_deag :=_gfb .Encrypt (_cfd .PdfObjectDictionary ,_faaf ,_adbg );if _deag !=nil {return _deag ;};_eac ,_deag :=_gfb .makeKey (_beea ,uint32 (_faaf ),uint32 (_adbg ),_gfb ._efa );if _deag !=nil {return _deag ;};_cfd .Stream ,_deag =_gfb .encryptBytes (_cfd .Stream ,_beea ,_eac );if _deag !=nil {return _deag ;};_fgae .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_cfd .Stream ))));return nil ;case *PdfObjectString :_fcb .Log .Trace ("\u0045n\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_cafda :=_agd ;if _gfb ._bf .V >=4{_fcb .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_gfb ._bef );if _gfb ._bef =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_cafda =_gfb ._bef ;};_aef ,_dga :=_gfb .makeKey (_cafda ,uint32 (parentObjNum ),uint32 (parentGenNum ),_gfb ._efa );if _dga !=nil {return _dga ;};_ecd :=_cfd .Str ();_cfb :=make ([]byte ,len (_ecd ));for _eaad :=0;_eaad < len (_ecd );_eaad ++{_cfb [_eaad ]=_ecd [_eaad ];};_fcb .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_cfb ,_cfb );_cfb ,_dga =_gfb .encryptBytes (_cfb ,_cafda ,_aef );if _dga !=nil {return _dga ;};_cfd ._bebd =string (_cfb );return nil ;case *PdfObjectArray :for _ ,_fca :=range _cfd .Elements (){_dbea :=_gfb .Encrypt (_fca ,parentObjNum ,parentGenNum );if _dbea !=nil {return _dbea ;};};return nil ;case *PdfObjectDictionary :_ceee :=false ;if _gebe :=_cfd .Get ("\u0054\u0079\u0070\u0065");_gebe !=nil {_dgc ,_agaf :=_gebe .(*PdfObjectName );if _agaf &&*_dgc =="\u0053\u0069\u0067"{_ceee =true ;};};for _ ,_gge :=range _cfd .Keys (){_eaee :=_cfd .Get (_gge );if _ceee &&string (_gge )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;};if string (_gge )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_gge )!="\u0050\u0072\u0065\u0076"&&string (_gge )!="\u004c\u0061\u0073\u0074"{_egeg :=_gfb .Encrypt (_eaee ,parentObjNum ,parentGenNum );if _egeg !=nil {return _egeg ;};};};return nil ;};return nil ;};func _dffa (_gcgb *PdfObjectStream ,_bgea *PdfObjectDictionary )(*JBIG2Encoder ,error ){const _gbcd ="\u006ee\u0077\u004a\u0042\u0049G\u0032\u0044\u0065\u0063\u006fd\u0065r\u0046r\u006f\u006d\u0053\u0074\u0072\u0065\u0061m";_acbd :=&JBIG2Encoder {};_fbfg :=_gcgb .PdfObjectDictionary ;if _fbfg ==nil {return _acbd ,nil ;};if _bgea ==nil {_eeeg :=_fbfg .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _eeeg !=nil {switch _ebgf :=_eeeg .(type ){case *PdfObjectDictionary :_bgea =_ebgf ;case *PdfObjectArray :if _ebgf .Len ()==1{if _bgdg ,_gdbf :=GetDict (_ebgf .Get (0));_gdbf {_bgea =_bgdg ;};};default:_fcb .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065P\u0061\u0072\u0061\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064i\u0063\u0074\u0069\u006f\u006e\u0061\u0072y\u0020\u0025\u0023\u0076",_eeeg );return nil ,_ef .Errorf (_gbcd ,"\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050a\u0072m\u0073\u0020\u0074\u0079\u0070\u0065\u003a \u0025\u0054",_ebgf );};};};if _bgea ==nil {return _acbd ,nil ;};_acbd .UpdateParams (_bgea );_dcbf :=_bgea .Get ("\u004a\u0042\u0049G\u0032\u0047\u006c\u006f\u0062\u0061\u006c\u0073");if _dcbf ==nil {return _acbd ,nil ;};var _afeg error ;_cec ,_dcga :=_dcbf .(*PdfObjectStream );if !_dcga {_afeg =_ef .Error (_gbcd ,"j\u0062\u0069\u0067\u0032\u002e\u0047\u006c\u006f\u0062a\u006c\u0073\u0020\u0073\u0074\u0072\u0065am\u0020\u0073\u0068\u006fu\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u006e\u0020Ob\u006a\u0065c\u0074\u0020\u0053\u0074\u0072\u0065\u0061\u006d");_fcb .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_afeg );return nil ,_afeg ;};_acbd .Globals ,_afeg =_ga .DecodeGlobals (_cec .Stream );if _afeg !=nil {_afeg =_ef .Wrap (_afeg ,_gbcd ,"\u0063\u006f\u0072\u0072u\u0070\u0074\u0065\u0064\u0020\u006a\u0062\u0069\u0067\u0032 \u0065n\u0063\u006f\u0064\u0065\u0064\u0020\u0064a\u0074\u0061");_fcb .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_afeg );return nil ,_afeg ;};return _acbd ,nil ;};

// GetStream returns the *PdfObjectStream represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetStream (obj PdfObject )(_cfecf *PdfObjectStream ,_fddf bool ){obj =ResolveReference (obj );_cfecf ,_fddf =obj .(*PdfObjectStream );return _cfecf ,_fddf ;};

// IsFloatDigit checks if a character can be a part of a float number string.
func IsFloatDigit (c byte )bool {return ('0'<=c &&c <='9')||c =='.'};func (_agfb *PdfObjectInteger )String ()string {return _f .Sprintf ("\u0025\u0064",*_agfb )};const _agd ="\u0053\u0074\u0064C\u0046";

// CheckAccessRights checks access rights and permissions for a specified password. If either user/owner password is
// specified, full rights are granted, otherwise the access rights are specified by the Permissions flag.
//
// The bool flag indicates that the user can access and view the file.
// The AccessPermissions shows what access the user has for editing etc.
// An error is returned if there was a problem performing the authentication.
func (_bfde *PdfParser )CheckAccessRights (password []byte )(bool ,_ff .Permissions ,error ){if _bfde ._dgdd ==nil {return true ,_ff .PermOwner ,nil ;};return _bfde ._dgdd .checkAccessRights (password );};

// UpdateParams updates the parameter values of the encoder.
func (_bfg *CCITTFaxEncoder )UpdateParams (params *PdfObjectDictionary ){if _bcbf ,_febg :=GetNumberAsInt64 (params .Get ("\u004b"));_febg ==nil {_bfg .K =int (_bcbf );};if _cgaf ,_gfee :=GetNumberAsInt64 (params .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));_gfee ==nil {_bfg .Columns =int (_cgaf );}else if _cgaf ,_gfee =GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));_gfee ==nil {_bfg .Columns =int (_cgaf );};if _bfgd ,_efda :=GetNumberAsInt64 (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_efda ==nil {_bfg .BlackIs1 =_bfgd > 0;}else {if _gfg ,_cdfg :=GetBoolVal (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_cdfg {_bfg .BlackIs1 =_gfg ;}else {if _acfa ,_ffca :=GetArray (params .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));_ffca {_afea ,_dbgd :=_acfa .ToIntegerArray ();if _dbgd ==nil {_bfg .BlackIs1 =_afea [0]==1&&_afea [1]==0;};};};};if _adff ,_cde :=GetNumberAsInt64 (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_cde ==nil {_bfg .EncodedByteAlign =_adff > 0;}else {if _fafedd ,_cfec :=GetBoolVal (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_cfec {_bfg .EncodedByteAlign =_fafedd ;};};if _eace ,_facaf :=GetNumberAsInt64 (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_facaf ==nil {_bfg .EndOfLine =_eace > 0;}else {if _agafe ,_bcgb :=GetBoolVal (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_bcgb {_bfg .EndOfLine =_agafe ;};};if _bbgb ,_ecfdc :=GetNumberAsInt64 (params .Get ("\u0052\u006f\u0077\u0073"));_ecfdc ==nil {_bfg .Rows =int (_bbgb );}else if _bbgb ,_ecfdc =GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));_ecfdc ==nil {_bfg .Rows =int (_bbgb );};if _dafg ,_bage :=GetNumberAsInt64 (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_bage ==nil {_bfg .EndOfBlock =_dafg > 0;}else {if _gddab ,_ggfd :=GetBoolVal (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_ggfd {_bfg .EndOfBlock =_gddab ;};};if _bdfd ,_edgc :=GetNumberAsInt64 (params .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));_edgc !=nil {_bfg .DamagedRowsBeforeError =int (_bdfd );};};

// DecodeBytes decodes a byte slice from Run length encoding.
//
// 7.4.5 RunLengthDecode Filter
// The RunLengthDecode filter decodes data that has been encoded in a simple byte-oriented format based on run length.
// The encoded data shall be a sequence of runs, where each run shall consist of a length byte followed by 1 to 128
// bytes of data. If the length byte is in the range 0 to 127, the following length + 1 (1 to 128) bytes shall be
// copied literally during decompression. If length is in the range 129 to 255, the following single byte shall be
// copied 257 - length (2 to 128) times during decompression. A length value of 128 shall denote EOD.
func (_dfga *RunLengthEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_abb :=_gb .NewReader (encoded );var _dedc []byte ;for {_cedf ,_gafe :=_abb .ReadByte ();if _gafe !=nil {return nil ,_gafe ;};if _cedf > 128{_egb ,_cced :=_abb .ReadByte ();if _cced !=nil {return nil ,_cced ;};for _abf :=0;_abf < 257-int (_cedf );_abf ++{_dedc =append (_dedc ,_egb );};}else if _cedf < 128{for _bdca :=0;_bdca < int (_cedf )+1;_bdca ++{_gaa ,_eeff :=_abb .ReadByte ();if _eeff !=nil {return nil ,_eeff ;};_dedc =append (_dedc ,_gaa );};}else {break ;};};return _dedc ,nil ;};

// XrefObject defines a cross reference entry which is a map between object number (with generation number) and the
// location of the actual object, either as a file offset (xref table entry), or as a location within an xref
// stream object (xref object stream).
type XrefObject struct{XType xrefType ;ObjectNumber int ;Generation int ;

// For normal xrefs (defined by OFFSET)
Offset int64 ;

// For xrefs to object streams.
OsObjNumber int ;OsObjIndex int ;};

// PdfObjectNull represents the primitive PDF null object.
type PdfObjectNull struct{};var _ggc =[]PdfObjectName {"\u0056","\u0052","\u004f","\u0055","\u0050"};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_dagb *ASCIIHexEncoder )MakeDecodeParams ()PdfObject {return nil };

// ParseNumber parses a numeric objects from a buffered stream.
// Section 7.3.3.
// Integer or Float.
//
// An integer shall be written as one or more decimal digits optionally
// preceded by a sign. The value shall be interpreted as a signed
// decimal integer and shall be converted to an integer object.
//
// A real value shall be written as one or more decimal digits with an
// optional sign and a leading, trailing, or embedded PERIOD (2Eh)
// (decimal point). The value shall be interpreted as a real number
// and shall be converted to a real object.
//
// Regarding exponential numbers: 7.3.3 Numeric Objects:
// A conforming writer shall not use the PostScript syntax for numbers
// with non-decimal radices (such as 16#FFFE) or in exponential format
// (such as 6.02E23).
// Nonetheless, we sometimes get numbers with exponential format, so
// we will support it in the reader (no confusion with other types, so
// no compromise).
func ParseNumber (buf *_fc .Reader )(PdfObject ,error ){_gdccc :=false ;_afcc :=true ;var _dfaee _gb .Buffer ;for {if _fcb .Log .IsLogLevel (_fcb .LogLevelTrace ){_fcb .Log .Trace ("\u0050\u0061\u0072\u0073in\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0022\u0025\u0073\u0022",_dfaee .String ());};_ddfff ,_gbccb :=buf .Peek (1);if _gbccb ==_ce .EOF {break ;};if _gbccb !=nil {_fcb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0025\u0073",_gbccb );return nil ,_gbccb ;};if _afcc &&(_ddfff [0]=='-'||_ddfff [0]=='+'){_cddee ,_ :=buf .ReadByte ();_dfaee .WriteByte (_cddee );_afcc =false ;}else if IsDecimalDigit (_ddfff [0]){_edgbd ,_ :=buf .ReadByte ();_dfaee .WriteByte (_edgbd );}else if _ddfff [0]=='.'{_cgff ,_ :=buf .ReadByte ();_dfaee .WriteByte (_cgff );_gdccc =true ;}else if _ddfff [0]=='e'||_ddfff [0]=='E'{_bbaed ,_ :=buf .ReadByte ();_dfaee .WriteByte (_bbaed );_gdccc =true ;_afcc =true ;}else {break ;};};var _bgeb PdfObject ;if _gdccc {_gabg ,_cefa :=_e .ParseFloat (_dfaee .String (),64);if _cefa !=nil {_fcb .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0025v\u0020\u0065\u0072\u0072\u003d\u0025v\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0030\u002e\u0020\u004fu\u0074\u0070u\u0074\u0020\u006d\u0061y\u0020\u0062\u0065\u0020\u0069n\u0063\u006f\u0072\u0072\u0065\u0063\u0074",_dfaee .String (),_cefa );_gabg =0.0;_cefa =nil ;};_bgcce :=PdfObjectFloat (_gabg );_bgeb =&_bgcce ;}else {_aggd ,_ecab :=_e .ParseInt (_dfaee .String (),10,64);if _ecab !=nil {_fcb .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0025\u0076\u0020\u0065\u0072\u0072\u003d%\u0076\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074 \u006d\u0061\u0079\u0020\u0062\u0065 \u0069\u006ec\u006f\u0072r\u0065c\u0074",_dfaee .String (),_ecab );_aggd =0;_ecab =nil ;};_bceb :=PdfObjectInteger (_aggd );_bgeb =&_bceb ;};return _bgeb ,nil ;};

// GetFloatVal returns the float64 value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetFloatVal (obj PdfObject )(_addd float64 ,_dded bool ){_edddc ,_dded :=TraceToDirectObject (obj ).(*PdfObjectFloat );if _dded {return float64 (*_edddc ),true ;};return 0,false ;};func (_aad *PdfCrypt )makeKey (_cgc string ,_cbad ,_beeb uint32 ,_ddg []byte )([]byte ,error ){_ceec ,_dgd :=_aad ._fgf [_cgc ];if !_dgd {return nil ,_f .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_cgc );};return _ceec .MakeKey (_cbad ,_beeb ,_ddg );};func (_bbed *JBIG2Image )toBitmap ()(_baba *_be .Bitmap ,_beb error ){const _efad ="\u004a\u0042\u0049\u00472I\u006d\u0061\u0067\u0065\u002e\u0074\u006f\u0042\u0069\u0074\u006d\u0061\u0070";if _bbed .Data ==nil {return nil ,_ef .Error (_efad ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");};if _bbed .Width ==0||_bbed .Height ==0{return nil ,_ef .Error (_efad ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");};if _bbed .HasPadding {_baba ,_beb =_be .NewWithData (_bbed .Width ,_bbed .Height ,_bbed .Data );}else {_baba ,_beb =_be .NewWithUnpaddedData (_bbed .Width ,_bbed .Height ,_bbed .Data );};if _beb !=nil {return nil ,_ef .Wrap (_beb ,_efad ,"");};return _baba ,nil ;};

// MakeHexString creates an PdfObjectString from a string intended for output as a hexadecimal string.
func MakeHexString (s string )*PdfObjectString {_aaee :=PdfObjectString {_bebd :s ,_daag :true };return &_aaee ;};

// DecodeImages decodes the page images from the jbig2 'encoded' data input.
// The jbig2 document may contain multiple pages, thus the function can return multiple
// images. The images order corresponds to the page number.
func (_febb *JBIG2Encoder )DecodeImages (encoded []byte )([]_d .Image ,error ){const _cfge ="\u004aB\u0049\u0047\u0032\u0045n\u0063\u006f\u0064\u0065\u0072.\u0044e\u0063o\u0064\u0065\u0049\u006d\u0061\u0067\u0065s";_agac ,_dbec :=_ead .Decode (encoded ,_ead .Parameters {},_febb .Globals .ToDocumentGlobals ());if _dbec !=nil {return nil ,_ef .Wrap (_dbec ,_cfge ,"");};_cbcgg ,_dbec :=_agac .PageNumber ();if _dbec !=nil {return nil ,_ef .Wrap (_dbec ,_cfge ,"");};_edae :=[]_d .Image {};var _fdcf _d .Image ;for _gdbb :=1;_gdbb <=_cbcgg ;_gdbb ++{_fdcf ,_dbec =_agac .DecodePageImage (_gdbb );if _dbec !=nil {return nil ,_ef .Wrapf (_dbec ,_cfge ,"\u0070\u0061\u0067\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_gdbb );};_edae =append (_edae ,_fdcf );};return _edae ,nil ;};

// ToIntegerArray returns a slice of all array elements as an int slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_aeca *PdfObjectArray )ToIntegerArray ()([]int ,error ){var _fdbbg []int ;for _ ,_afae :=range _aeca .Elements (){if _cbbf ,_dfcg :=_afae .(*PdfObjectInteger );_dfcg {_fdbbg =append (_fdbbg ,int (*_cbbf ));}else {return nil ,ErrTypeError ;};};return _fdbbg ,nil ;};

// GetFilterName returns the name of the encoding filter.
func (_dbdfc *RunLengthEncoder )GetFilterName ()string {return StreamEncodingFilterNameRunLength };type cryptFilters map[string ]_gbb .Filter ;

// Set sets the PdfObject at index i of the array. An error is returned if the index is outside bounds.
func (_ddac *PdfObjectArray )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_ddac ._ageac ){return _ca .New ("\u006f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_ddac ._ageac [i ]=obj ;return nil ;};

// WriteString outputs the object as it is to be written to file.
func (_cdde *PdfObjectNull )WriteString ()string {return "\u006e\u0075\u006c\u006c"};func (_bfead *PdfParser )repairLocateXref ()(int64 ,error ){_fedfg :=int64 (1000);_bfead ._dgcfc .Seek (-_fedfg ,_g .SEEK_CUR );_fdff ,_agacg :=_bfead ._dgcfc .Seek (0,_g .SEEK_CUR );if _agacg !=nil {return 0,_agacg ;};_cebcb :=make ([]byte ,_fedfg );_bfead ._dgcfc .Read (_cebcb );_abdc :=_eaeegca .FindAllStringIndex (string (_cebcb ),-1);if len (_abdc )< 1{_fcb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0065\u0070a\u0069\u0072\u003a\u0020\u0078\u0072\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021");return 0,_ca .New ("\u0072\u0065\u0070\u0061ir\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064");};_adaa :=int64 (_abdc [len (_abdc )-1][0]);_agbd :=_fdff +_adaa ;return _agbd ,nil ;};const (StreamEncodingFilterNameFlate ="F\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameLZW ="\u004cZ\u0057\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameDCT ="\u0044C\u0054\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameRunLength ="\u0052u\u006eL\u0065\u006e\u0067\u0074\u0068\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameASCIIHex ="\u0041\u0053\u0043\u0049\u0049\u0048\u0065\u0078\u0044e\u0063\u006f\u0064\u0065";StreamEncodingFilterNameASCII85 ="\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameCCITTFax ="\u0043\u0043\u0049\u0054\u0054\u0046\u0061\u0078\u0044e\u0063\u006f\u0064\u0065";StreamEncodingFilterNameJBIG2 ="J\u0042\u0049\u0047\u0032\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameJPX ="\u004aP\u0058\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameRaw ="\u0052\u0061\u0077";);

// GetFilterName returns the name of the encoding filter.
func (_ccca *RawEncoder )GetFilterName ()string {return StreamEncodingFilterNameRaw };

// JBIG2CompressionType defines the enum compression type used by the JBIG2Encoder.
type JBIG2CompressionType int ;

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_gcc *MultiEncoder )MakeDecodeParams ()PdfObject {if len (_gcc ._caab )==0{return nil ;};if len (_gcc ._caab )==1{return _gcc ._caab [0].MakeDecodeParams ();};_debd :=MakeArray ();for _ ,_afaa :=range _gcc ._caab {_faeg :=_afaa .MakeDecodeParams ();if _faeg ==nil {_debd .Append (MakeNull ());}else {_debd .Append (_faeg );};};return _debd ;};

// PdfObject is an interface which all primitive PDF objects must implement.
type PdfObject interface{

// String outputs a string representation of the primitive (for debugging).
String ()string ;

// WriteString outputs the PDF primitive as written to file as expected by the standard.
// TODO(dennwc): it should return a byte slice, or accept a writer
WriteString ()string ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_dfe *LZWEncoder )MakeStreamDict ()*PdfObjectDictionary {_dega :=MakeDict ();_dega .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_dfe .GetFilterName ()));_bdeab :=_dfe .MakeDecodeParams ();if _bdeab !=nil {_dega .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_bdeab );};_dega .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (int64 (_dfe .EarlyChange )));return _dega ;};

// GoImageToJBIG2 creates a binary image on the base of 'i' golang image.Image.
// If the image is not a black/white image then the function converts provided input into
// JBIG2Image with 1bpp. For non grayscale images the function performs the conversion to the grayscale temp image.
// Then it checks the value of the gray image value if it's within bounds of the black white threshold.
// This 'bwThreshold' value should be in range (0.0, 1.0). The threshold checks if the grayscale pixel (uint) value
// is greater or smaller than 'bwThreshold' * 255. Pixels inside the range will be white, and the others will be black.
// If the 'bwThreshold' is equal to -1.0 - JB2ImageAutoThreshold then it's value would be set on the base of
// it's histogram using Triangle method. For more information go to:
// 	https://www.mathworks.com/matlabcentral/fileexchange/28047-gray-image-thresholding-using-the-triangle-method
func GoImageToJBIG2 (i _d .Image ,bwThreshold float64 )(*JBIG2Image ,error ){const _fdgd ="\u0047\u006f\u0049\u006d\u0061\u0067\u0065\u0054\u006fJ\u0042\u0049\u0047\u0032";if i ==nil {return nil ,_ef .Error (_fdgd ,"i\u006d\u0061\u0067\u0065 '\u0069'\u0020\u006e\u006f\u0074\u0020d\u0065\u0066\u0069\u006e\u0065\u0064");};var (_fcdd uint8 ;_feeg _bed .Image ;_dacg error ;);if bwThreshold ==JB2ImageAutoThreshold {_feeg ,_dacg =_bed .MonochromeConverter .Convert (i );}else if bwThreshold > 1.0||bwThreshold < 0.0{return nil ,_ef .Error (_fdgd ,"p\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074h\u0072\u0065\u0073\u0068\u006f\u006c\u0064 i\u0073\u0020\u006e\u006ft\u0020\u0069\u006e\u0020\u0061\u0020\u0072\u0061\u006ege\u0020\u007b0\u002e\u0030\u002c\u0020\u0031\u002e\u0030\u007d");}else {_fcdd =uint8 (255*bwThreshold );_feeg ,_dacg =_bed .MonochromeThresholdConverter (_fcdd ).Convert (i );};if _dacg !=nil {return nil ,_dacg ;};return _cafb (_feeg ),nil ;};

// MakeBool creates a PdfObjectBool from a bool value.
func MakeBool (val bool )*PdfObjectBool {_adbc :=PdfObjectBool (val );return &_adbc };var (ErrUnsupportedEncodingParameters =_ca .New ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074\u0065\u0072\u0073");ErrNoCCITTFaxDecode =_ca .New ("\u0043\u0043I\u0054\u0054\u0046\u0061\u0078\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");ErrNoJBIG2Decode =_ca .New ("\u004a\u0042\u0049\u0047\u0032\u0044\u0065c\u006f\u0064\u0065 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");ErrNoJPXDecode =_ca .New ("\u004a\u0050\u0058\u0044\u0065c\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020i\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");ErrNoPdfVersion =_ca .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");ErrTypeError =_ca .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");ErrRangeError =_ca .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");ErrNotSupported =_ca .New ("\u0066\u0065\u0061t\u0075\u0072\u0065\u0020n\u006f\u0074\u0020\u0063\u0075\u0072\u0072e\u006e\u0074\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");ErrNotANumber =_ca .New ("\u006e\u006f\u0074 \u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072"););

// DrawableImage is same as golang image/draw's Image interface that allow drawing images.
type DrawableImage interface{ColorModel ()_a .Model ;Bounds ()_d .Rectangle ;At (_cfc ,_bfaf int )_a .Color ;Set (_aaa ,_ddbe int ,_gbf _a .Color );};

// GetNumberAsInt64 returns the contents of `obj` as an int64 if it is an integer or float, or an
// error if it isn't. This is for cases where expecting an integer, but some implementations
// actually store the number in a floating point format.
func GetNumberAsInt64 (obj PdfObject )(int64 ,error ){switch _fgfc :=obj .(type ){case *PdfObjectFloat :_fcb .Log .Debug ("\u004e\u0075m\u0062\u0065\u0072\u0020\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0061\u0073\u0020\u0069\u006e\u0074e\u0067\u0065\u0072\u0020\u0077\u0061s\u0020\u0073\u0074\u006f\u0072\u0065\u0064\u0020\u0061\u0073\u0020\u0066\u006c\u006fa\u0074\u0020(\u0074\u0079\u0070\u0065 \u0063\u0061\u0073\u0074\u0069n\u0067\u0020\u0075\u0073\u0065\u0064\u0029");return int64 (*_fgfc ),nil ;case *PdfObjectInteger :return int64 (*_fgfc ),nil ;};return 0,ErrNotANumber ;};

// PdfObjectFloat represents the primitive PDF floating point numerical object.
type PdfObjectFloat float64 ;

// UpdateParams updates the parameter values of the encoder.
func (_bcc *ASCIIHexEncoder )UpdateParams (params *PdfObjectDictionary ){};

// LZWEncoder provides LZW encoding/decoding functionality.
type LZWEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Colors int ;

// LZW algorithm setting.
EarlyChange int ;};

// Clear resets the array to an empty state.
func (_dead *PdfObjectArray )Clear (){_dead ._ageac =[]PdfObject {}};func (_gafee *PdfParser )rebuildXrefTable ()error {_bgdad :=XrefTable {};_bgdad .ObjectMap =map[int ]XrefObject {};for _abfae ,_dcgg :=range _gafee ._gaeec .ObjectMap {_dbcc ,_ ,_ccfbe :=_gafee .lookupByNumberWrapper (_abfae ,false );if _ccfbe !=nil {_fcb .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020U\u006e\u0061\u0062\u006ce t\u006f l\u006f\u006f\u006b\u0020\u0075\u0070\u0020ob\u006a\u0065\u0063\u0074\u0020\u0028\u0025s\u0029",_ccfbe );_fcb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0063\u006fm\u0070\u006c\u0065\u0074\u0065\u006c\u0079\u0020\u0062\u0072\u006f\u006b\u0065\u006e\u0020\u002d\u0020\u0061\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0074\u006f \u0072\u0065\u0070\u0061\u0069r\u0020");_adcc ,_gacfe :=_gafee .repairRebuildXrefsTopDown ();if _gacfe !=nil {_fcb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0072\u0065\u0062\u0075\u0069l\u0064\u0020\u0072\u0065\u0070a\u0069\u0072 \u0028\u0025\u0073\u0029",_gacfe );return _gacfe ;};_gafee ._gaeec =*_adcc ;_fcb .Log .Debug ("\u0052e\u0070\u0061\u0069\u0072e\u0064\u0020\u0078\u0072\u0065f\u0020t\u0061b\u006c\u0065\u0020\u0062\u0075\u0069\u006ct");return nil ;};_gbce ,_ebbd ,_ccfbe :=_ace (_dbcc );if _ccfbe !=nil {return _ccfbe ;};_dcgg .ObjectNumber =int (_gbce );_dcgg .Generation =int (_ebbd );_bgdad .ObjectMap [int (_gbce )]=_dcgg ;};_gafee ._gaeec =_bgdad ;_fcb .Log .Debug ("N\u0065w\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061b\u006c\u0065\u0020\u0062ui\u006c\u0074");_efe (_gafee ._gaeec );return nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_gdda *LZWEncoder )MakeDecodeParams ()PdfObject {if _gdda .Predictor > 1{_ddbc :=MakeDict ();_ddbc .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_gdda .Predictor )));if _gdda .BitsPerComponent !=8{_ddbc .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_gdda .BitsPerComponent )));};if _gdda .Columns !=1{_ddbc .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_gdda .Columns )));};if _gdda .Colors !=1{_ddbc .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_gdda .Colors )));};return _ddbc ;};return nil ;};func (_adba *PdfParser )xrefNextObjectOffset (_bedcg int64 )int64 {_cgcg :=int64 (0);if len (_adba ._gaeec .ObjectMap )==0{return 0;};if len (_adba ._gaeec ._ge )==0{_fagc :=0;for _ ,_afbfa :=range _adba ._gaeec .ObjectMap {if _afbfa .Offset > 0{_fagc ++;};};if _fagc ==0{return 0;};_adba ._gaeec ._ge =make ([]XrefObject ,_fagc );_dedcd :=0;for _ ,_cafdg :=range _adba ._gaeec .ObjectMap {if _cafdg .Offset > 0{_adba ._gaeec ._ge [_dedcd ]=_cafdg ;_dedcd ++;};};_cad .Slice (_adba ._gaeec ._ge ,func (_cabag ,_feeaf int )bool {return _adba ._gaeec ._ge [_cabag ].Offset < _adba ._gaeec ._ge [_feeaf ].Offset ;});};_gfda :=_cad .Search (len (_adba ._gaeec ._ge ),func (_gddf int )bool {return _adba ._gaeec ._ge [_gddf ].Offset >=_bedcg });if _gfda < len (_adba ._gaeec ._ge ){_cgcg =_adba ._gaeec ._ge [_gfda ].Offset ;};return _cgcg ;};

// DecodeBytes decodes a multi-encoded slice of bytes by passing it through the
// DecodeBytes method of the underlying encoders.
func (_gegb *MultiEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_acde :=encoded ;var _cffa error ;for _ ,_fedf :=range _gegb ._caab {_fcb .Log .Trace ("\u004du\u006c\u0074i\u0020\u0045\u006e\u0063o\u0064\u0065\u0072 \u0044\u0065\u0063\u006f\u0064\u0065\u003a\u0020\u0041pp\u006c\u0079\u0069n\u0067\u0020F\u0069\u006c\u0074\u0065\u0072\u003a \u0025\u0076 \u0025\u0054",_fedf ,_fedf );_acde ,_cffa =_fedf .DecodeBytes (_acde );if _cffa !=nil {return nil ,_cffa ;};};return _acde ,nil ;};

// GetXrefTable returns the PDFs xref table.
func (_ceea *PdfParser )GetXrefTable ()XrefTable {return _ceea ._gaeec };func _ggf (_aff *_gbb .FilterDict ,_deb *PdfObjectDictionary )error {if _bbae ,_gdd :=_deb .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_gdd {if _cce :=string (*_bbae );_cce !="C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"{_fcb .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020C\u0046\u0020\u0064ic\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074e\u0072\u0029",_cce );};};_dc ,_edf :=_deb .Get ("\u0043\u0046\u004d").(*PdfObjectName );if !_edf {return _f .Errorf ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0028\u004e\u006f\u006e\u0065\u0029");};_aff .CFM =string (*_dc );if _cg ,_egg :=_deb .Get ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et").(*PdfObjectName );_egg {_aff .AuthEvent =_ff .AuthEvent (*_cg );}else {_aff .AuthEvent =_ff .EventDocOpen ;};if _acf ,_cfe :=_deb .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );_cfe {_aff .Length =int (*_acf );};return nil ;};

// Inspect analyzes the document object structure. Returns a map of object types (by name) with the instance count
// as value.
func (_dgebb *PdfParser )Inspect ()(map[string ]int ,error ){return _dgebb .inspect ()};

// GetFilterName returns the name of the encoding filter.
func (_afe *CCITTFaxEncoder )GetFilterName ()string {return StreamEncodingFilterNameCCITTFax };

// Len returns the number of elements in the streams.
func (_bbec *PdfObjectStreams )Len ()int {if _bbec ==nil {return 0;};return len (_bbec ._cdaag );};

// GetTrailer returns the PDFs trailer dictionary. The trailer dictionary is typically the starting point for a PDF,
// referencing other key objects that are important in the document structure.
func (_fdcb *PdfParser )GetTrailer ()*PdfObjectDictionary {return _fdcb ._fdb };

// PdfCrypt provides PDF encryption/decryption support.
// The PDF standard supports encryption of strings and streams (Section 7.6).
type PdfCrypt struct{_bf encryptDict ;_bbd _ff .StdEncryptDict ;_bea string ;_efa []byte ;_fgad map[PdfObject ]bool ;_dabd map[PdfObject ]bool ;_bbaa bool ;_fgf cryptFilters ;_eag string ;_bef string ;_becce *PdfParser ;_agbc map[int ]struct{};};

// GetAsFloat64Slice returns the array as []float64 slice.
// Returns an error if not entirely numeric (only PdfObjectIntegers, PdfObjectFloats).
func (_acdg *PdfObjectArray )GetAsFloat64Slice ()([]float64 ,error ){var _aecbg []float64 ;for _ ,_bgdb :=range _acdg .Elements (){_aabae ,_ffde :=GetNumberAsFloat (TraceToDirectObject (_bgdb ));if _ffde !=nil {return nil ,_f .Errorf ("\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006e\u0075m\u0062\u0065\u0072");};_aecbg =append (_aecbg ,_aabae );};return _aecbg ,nil ;};

// PdfObjectName represents the primitive PDF name object.
type PdfObjectName string ;

// GetFilterName returns the name of the encoding filter.
func (_egdc *LZWEncoder )GetFilterName ()string {return StreamEncodingFilterNameLZW };const (_aacc =0;_agbf =1;_eef =2;_geg =3;_fee =4;);func _ddbf (_fcdf PdfObject ,_ebad int ,_fbeea map[PdfObject ]struct{})error {_fcb .Log .Trace ("\u0054\u0072\u0061\u0076\u0065\u0072s\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0064\u0061\u0074\u0061 \u0028\u0064\u0065\u0070\u0074\u0068\u0020=\u0020\u0025\u0064\u0029",_ebad );if _ ,_cdgac :=_fbeea [_fcdf ];_cdgac {_fcb .Log .Trace ("-\u0041\u006c\u0072\u0065ad\u0079 \u0074\u0072\u0061\u0076\u0065r\u0073\u0065\u0064\u002e\u002e\u002e");return nil ;};_fbeea [_fcdf ]=struct{}{};switch _ggdd :=_fcdf .(type ){case *PdfIndirectObject :_afef :=_ggdd ;_fcb .Log .Trace ("\u0069\u006f\u003a\u0020\u0025\u0073",_afef );_fcb .Log .Trace ("\u002d\u0020\u0025\u0073",_afef .PdfObject );return _ddbf (_afef .PdfObject ,_ebad +1,_fbeea );case *PdfObjectStream :_dbgc :=_ggdd ;return _ddbf (_dbgc .PdfObjectDictionary ,_ebad +1,_fbeea );case *PdfObjectDictionary :_dgdae :=_ggdd ;_fcb .Log .Trace ("\u002d\u0020\u0064\u0069\u0063\u0074\u003a\u0020\u0025\u0073",_dgdae );for _ ,_fdaf :=range _dgdae .Keys (){_bafe :=_dgdae .Get (_fdaf );if _aaaa ,_egcgf :=_bafe .(*PdfObjectReference );_egcgf {_dceg :=_aaaa .Resolve ();_dgdae .Set (_fdaf ,_dceg );_afdf :=_ddbf (_dceg ,_ebad +1,_fbeea );if _afdf !=nil {return _afdf ;};}else {_cgcdf :=_ddbf (_bafe ,_ebad +1,_fbeea );if _cgcdf !=nil {return _cgcdf ;};};};return nil ;case *PdfObjectArray :_agde :=_ggdd ;_fcb .Log .Trace ("-\u0020\u0061\u0072\u0072\u0061\u0079\u003a\u0020\u0025\u0073",_agde );for _gfec ,_fafd :=range _agde .Elements (){if _dacbe ,_gfaf :=_fafd .(*PdfObjectReference );_gfaf {_fbca :=_dacbe .Resolve ();_agde .Set (_gfec ,_fbca );_cfab :=_ddbf (_fbca ,_ebad +1,_fbeea );if _cfab !=nil {return _cfab ;};}else {_bedb :=_ddbf (_fafd ,_ebad +1,_fbeea );if _bedb !=nil {return _bedb ;};};};return nil ;case *PdfObjectReference :_fcb .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020T\u0072\u0061\u0063\u0069\u006e\u0067\u0020\u0061\u0020r\u0065\u0066\u0065r\u0065n\u0063\u0065\u0021");return _ca .New ("\u0065r\u0072\u006f\u0072\u0020t\u0072\u0061\u0063\u0069\u006eg\u0020a\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");};return nil ;};

// GetFilterName returns the name of the encoding filter.
func (_defg *JPXEncoder )GetFilterName ()string {return StreamEncodingFilterNameJPX };

// GetFilterName returns the names of the underlying encoding filters,
// separated by spaces.
// Note: This is just a string, should not be used in /Filter dictionary entry. Use GetFilterArray for that.
// TODO(v4): Refactor to GetFilter() which can be used for /Filter (either Name or Array), this can be
//  renamed to String() as a pretty string to use in debugging etc.
func (_bgaa *MultiEncoder )GetFilterName ()string {_bbbdb :="";for _dgab ,_fcbd :=range _bgaa ._caab {_bbbdb +=_fcbd .GetFilterName ();if _dgab < len (_bgaa ._caab )-1{_bbbdb +="\u0020";};};return _bbbdb ;};

// WriteString outputs the object as it is to be written to file.
func (_ecffd *PdfObjectString )WriteString ()string {var _ddbge _gb .Buffer ;if _ecffd ._daag {_ccfb :=_cb .EncodeToString (_ecffd .Bytes ());_ddbge .WriteString ("\u003c");_ddbge .WriteString (_ccfb );_ddbge .WriteString ("\u003e");return _ddbge .String ();};_agfba :=map[byte ]string {'\n':"\u005c\u006e",'\r':"\u005c\u0072",'\t':"\u005c\u0074",'\b':"\u005c\u0062",'\f':"\u005c\u0066",'(':"\u005c\u0028",')':"\u005c\u0029",'\\':"\u005c\u005c"};_ddbge .WriteString ("\u0028");for _bgdgc :=0;_bgdgc < len (_ecffd ._bebd );_bgdgc ++{_aadgg :=_ecffd ._bebd [_bgdgc ];if _fgcf ,_afbc :=_agfba [_aadgg ];_afbc {_ddbge .WriteString (_fgcf );}else {_ddbge .WriteByte (_aadgg );};};_ddbge .WriteString ("\u0029");return _ddbge .String ();};func (_fcdde *PdfParser )readTextLine ()(string ,error ){var _cegcg _gb .Buffer ;for {_dggaf ,_ecba :=_fcdde ._aggcb .Peek (1);if _ecba !=nil {_fcb .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_ecba .Error ());return _cegcg .String (),_ecba ;};if (_dggaf [0]!='\r')&&(_dggaf [0]!='\n'){_dgcd ,_ :=_fcdde ._aggcb .ReadByte ();_cegcg .WriteByte (_dgcd );}else {break ;};};return _cegcg .String (),nil ;};

// EncodeBytes JPX encodes the passed in slice of bytes.
func (_bcfg *JPXEncoder )EncodeBytes (data []byte )([]byte ,error ){_fcb .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_bcfg .GetFilterName ());return data ,ErrNoJPXDecode ;};

// LookupByReference looks up a PdfObject by a reference.
func (_egd *PdfParser )LookupByReference (ref PdfObjectReference )(PdfObject ,error ){_fcb .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0075\u0070\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0025\u0073",ref .String ());return _egd .LookupByNumber (int (ref .ObjectNumber ));};

// Encode encodes previously prepare jbig2 document and stores it as the byte slice.
func (_eafb *JBIG2Encoder )Encode ()(_bbdd []byte ,_cgde error ){const _bege ="J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0045\u006eco\u0064\u0065";if _eafb ._bbbed ==nil {return nil ,_ef .Errorf (_bege ,"\u0064\u006f\u0063u\u006d\u0065\u006e\u0074 \u0069\u006e\u0070\u0075\u0074\u0020\u0064a\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006e\u0065\u0064");};_eafb ._bbbed .FullHeaders =_eafb .DefaultPageSettings .FileMode ;_bbdd ,_cgde =_eafb ._bbbed .Encode ();if _cgde !=nil {return nil ,_ef .Wrap (_cgde ,_bege ,"");};return _bbdd ,nil ;};

// PdfObjectBool represents the primitive PDF boolean object.
type PdfObjectBool bool ;

// Merge merges in key/values from another dictionary. Overwriting if has same keys.
// The mutated dictionary (d) is returned in order to allow method chaining.
func (_fcef *PdfObjectDictionary )Merge (another *PdfObjectDictionary )*PdfObjectDictionary {if another !=nil {for _ ,_fdee :=range another .Keys (){_aaeec :=another .Get (_fdee );_fcef .Set (_fdee ,_aaeec );};};return _fcef ;};

// WriteString outputs the object as it is to be written to file.
func (_egefe *PdfIndirectObject )WriteString ()string {var _eccg _ceg .Builder ;_eccg .WriteString (_e .FormatInt (_egefe .ObjectNumber ,10));_eccg .WriteString ("\u0020\u0030\u0020\u0052");return _eccg .String ();};

// String returns a string describing `d`.
func (_facf *PdfObjectDictionary )String ()string {var _acad _ceg .Builder ;_acad .WriteString ("\u0044\u0069\u0063t\u0028");for _ ,_afbfdb :=range _facf ._fddg {_cabgg :=_facf ._eedfb [_afbfdb ];_acad .WriteString ("\u0022"+_afbfdb .String ()+"\u0022\u003a\u0020");_acad .WriteString (_cabgg .String ());_acad .WriteString ("\u002c\u0020");};_acad .WriteString ("\u0029");return _acad .String ();};

// IsEncrypted checks if the document is encrypted. A bool flag is returned indicating the result.
// First time when called, will check if the Encrypt dictionary is accessible through the trailer dictionary.
// If encrypted, prepares a crypt datastructure which can be used to authenticate and decrypt the document.
// On failure, an error is returned.
func (_cgag *PdfParser )IsEncrypted ()(bool ,error ){if _cgag ._dgdd !=nil {return true ,nil ;}else if _cgag ._fdb ==nil {return false ,nil ;};_fcb .Log .Trace ("\u0043\u0068\u0065c\u006b\u0069\u006e\u0067 \u0065\u006e\u0063\u0072\u0079\u0070\u0074i\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0021");_cggd :=_cgag ._fdb .Get ("\u0045n\u0063\u0072\u0079\u0070\u0074");if _cggd ==nil {return false ,nil ;};_fcb .Log .Trace ("\u0049\u0073\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u0021");var (_gbcg *PdfObjectDictionary ;);switch _baae :=_cggd .(type ){case *PdfObjectDictionary :_gbcg =_baae ;case *PdfObjectReference :_fcb .Log .Trace ("\u0030\u003a\u0020\u004c\u006f\u006f\u006b\u0020\u0075\u0070\u0020\u0072e\u0066\u0020\u0025\u0071",_baae );_cca ,_bfgea :=_cgag .LookupByReference (*_baae );_fcb .Log .Trace ("\u0031\u003a\u0020%\u0071",_cca );if _bfgea !=nil {return false ,_bfgea ;};_cdbcfc ,_aaba :=_cca .(*PdfIndirectObject );if !_aaba {_fcb .Log .Debug ("E\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006eo\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072ec\u0074\u0020\u006fb\u006ae\u0063\u0074");return false ,_ca .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");};_faeb ,_aaba :=_cdbcfc .PdfObject .(*PdfObjectDictionary );_fcb .Log .Trace ("\u0032\u003a\u0020%\u0071",_faeb );if !_aaba {return false ,_ca .New ("\u0074\u0072a\u0069\u006c\u0065\u0072 \u0045\u006ec\u0072\u0079\u0070\u0074\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u006e\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");};_gbcg =_faeb ;case *PdfObjectNull :_fcb .Log .Debug ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074 \u0069\u0073\u0020a\u0020\u006e\u0075l\u006c\u0020o\u0062\u006a\u0065\u0063\u0074\u002e \u0046il\u0065\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u002e");return false ,nil ;default:return false ,_f .Errorf ("u\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0079\u0070\u0065: \u0025\u0054",_baae );};_eagc ,_efdfc :=PdfCryptNewDecrypt (_cgag ,_gbcg ,_cgag ._fdb );if _efdfc !=nil {return false ,_efdfc ;};for _ ,_faggf :=range []string {"\u0049\u006e\u0066\u006f","\u0045n\u0063\u0072\u0079\u0070\u0074"}{_efcae :=_cgag ._fdb .Get (PdfObjectName (_faggf ));if _efcae ==nil {continue ;};switch _deae :=_efcae .(type ){case *PdfObjectReference :_eagc ._agbc [int (_deae .ObjectNumber )]=struct{}{};case *PdfIndirectObject :_eagc ._fgad [_deae ]=true ;_eagc ._agbc [int (_deae .ObjectNumber )]=struct{}{};};};_cgag ._dgdd =_eagc ;_fcb .Log .Trace ("\u0043\u0072\u0079\u0070\u0074\u0065\u0072\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0025\u0062",_eagc );return true ,nil ;};

// IsNullObject returns true if `obj` is a PdfObjectNull.
func IsNullObject (obj PdfObject )bool {_ ,_gagc :=TraceToDirectObject (obj ).(*PdfObjectNull );return _gagc ;};func (_ddfb *PdfParser )parseXref ()(*PdfObjectDictionary ,error ){const _ddcc =20;_gbgb ,_ :=_ddfb ._aggcb .Peek (_ddcc );for _dfce :=0;_dfce < 2;_dfce ++{if _ddfb ._dadb ==0{_ddfb ._dadb =_ddfb .GetFileOffset ();};if _bcfa .Match (_gbgb ){_fcb .Log .Trace ("\u0078\u0072e\u0066\u0020\u0070\u006f\u0069\u006e\u0074\u0073\u0020\u0074\u006f\u0020\u0061\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u002e\u0020\u0050\u0072\u006f\u0062\u0061\u0062\u006c\u0079\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063\u0074");_fcb .Log .Debug ("\u0073t\u0061r\u0074\u0069\u006e\u0067\u0020w\u0069\u0074h\u0020\u0022\u0025\u0073\u0022",string (_gbgb ));return _ddfb .parseXrefStream (nil );};if _dafdg .Match (_gbgb ){_fcb .Log .Trace ("\u0053\u0074\u0061\u006ed\u0061\u0072\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073e\u0063t\u0069\u006f\u006e\u0020\u0074\u0061\u0062l\u0065\u0021");return _ddfb .parseXrefTable ();};_cbda :=_ddfb .GetFileOffset ();if _ddfb ._dadb ==0{_ddfb ._dadb =_cbda ;};_ddfb .SetFileOffset (_cbda -_ddcc );defer _ddfb .SetFileOffset (_cbda );_adcd ,_ :=_ddfb ._aggcb .Peek (_ddcc );_gbgb =append (_adcd ,_gbgb ...);};_fcb .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u0078\u0072\u0065f\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006fr\u0020\u0073\u0074\u0072\u0065\u0061\u006d.\u0020\u0052\u0065\u0070\u0061i\u0072\u0020\u0061\u0074\u0074e\u006d\u0070\u0074\u0065\u0064\u003a\u0020\u004c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0065\u0061\u0072\u006c\u0069\u0065\u0073\u0074\u0020x\u0072\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u0062\u006f\u0074to\u006d\u002e");if _aebc :=_ddfb .repairSeekXrefMarker ();_aebc !=nil {_fcb .Log .Debug ("\u0052e\u0070a\u0069\u0072\u0020\u0066\u0061i\u006c\u0065d\u0020\u002d\u0020\u0025\u0076",_aebc );return nil ,_aebc ;};return _ddfb .parseXrefTable ();};

// GetFilterName returns the name of the encoding filter.
func (_bgbg *DCTEncoder )GetFilterName ()string {return StreamEncodingFilterNameDCT };

// DecodeBytes decodes byte array with ASCII85. 5 ASCII characters -> 4 raw binary bytes
func (_bcga *ASCII85Encoder )DecodeBytes (encoded []byte )([]byte ,error ){var _cdgf []byte ;_fcb .Log .Trace ("\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0020\u0044e\u0063\u006f\u0064\u0065");_fbaa :=0;_dbde :=false ;for _fbaa < len (encoded )&&!_dbde {_eebf :=[5]byte {0,0,0,0,0};_gae :=0;_cdga :=0;_dcca :=4;for _cdga < 5+_gae {if _fbaa +_cdga ==len (encoded ){break ;};_gecee :=encoded [_fbaa +_cdga ];if IsWhiteSpace (_gecee ){_gae ++;_cdga ++;continue ;}else if _gecee =='~'&&_fbaa +_cdga +1< len (encoded )&&encoded [_fbaa +_cdga +1]=='>'{_dcca =(_cdga -_gae )-1;if _dcca < 0{_dcca =0;};_dbde =true ;break ;}else if _gecee >='!'&&_gecee <='u'{_gecee -='!';}else if _gecee =='z'&&_cdga -_gae ==0{_dcca =4;_cdga ++;break ;}else {_fcb .Log .Error ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u002c\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020co\u0064\u0065");return nil ,_ca .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0063\u006f\u0064\u0065\u0020e\u006e\u0063\u006f\u0075\u006e\u0074\u0065\u0072\u0065\u0064");};_eebf [_cdga -_gae ]=_gecee ;_cdga ++;};_fbaa +=_cdga ;for _gggda :=_dcca +1;_gggda < 5;_gggda ++{_eebf [_gggda ]=84;};_gace :=uint32 (_eebf [0])*85*85*85*85+uint32 (_eebf [1])*85*85*85+uint32 (_eebf [2])*85*85+uint32 (_eebf [3])*85+uint32 (_eebf [4]);_eeef :=[]byte {byte ((_gace >>24)&0xff),byte ((_gace >>16)&0xff),byte ((_gace >>8)&0xff),byte (_gace &0xff)};_cdgf =append (_cdgf ,_eeef [:_dcca ]...);};_fcb .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0065\u006e\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",encoded );_fcb .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0064\u0065\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",_cdgf );return _cdgf ,nil ;};func (_ecfb *PdfCrypt )decryptBytes (_gdf []byte ,_ggcf string ,_gdg []byte )([]byte ,error ){_fcb .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");_cbga ,_cag :=_ecfb ._fgf [_ggcf ];if !_cag {return nil ,_f .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_ggcf );};return _cbga .DecryptBytes (_gdf ,_gdg );};

// MakeDict creates and returns an empty PdfObjectDictionary.
func MakeDict ()*PdfObjectDictionary {_edgg :=&PdfObjectDictionary {};_edgg ._eedfb =map[PdfObjectName ]PdfObject {};_edgg ._fddg =[]PdfObjectName {};return _edgg ;};

// PdfObjectArray represents the primitive PDF array object.
type PdfObjectArray struct{_ageac []PdfObject };var _dafdg =_cd .MustCompile ("\u005c\u0073\u002a\u0078\u0072\u0065\u0066\u005c\u0073\u002a");

// UpdateParams updates the parameter values of the encoder.
func (_dgf *FlateEncoder )UpdateParams (params *PdfObjectDictionary ){_efdf ,_fceg :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _fceg ==nil {_dgf .Predictor =int (_efdf );};_gag ,_fceg :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _fceg ==nil {_dgf .BitsPerComponent =int (_gag );};_begf ,_fceg :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _fceg ==nil {_dgf .Columns =int (_begf );};_cdc ,_fceg :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _fceg ==nil {_dgf .Colors =int (_cdc );};};

// GetObjectStreams returns the *PdfObjectStreams represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetObjectStreams (obj PdfObject )(_fdgf *PdfObjectStreams ,_eaeb bool ){_fdgf ,_eaeb =obj .(*PdfObjectStreams );return _fdgf ,_eaeb ;};

// String returns a string describing `stream`.
func (_fgd *PdfObjectStream )String ()string {return _f .Sprintf ("O\u0062j\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0025\u0064: \u0025\u0073",_fgd .ObjectNumber ,_fgd .PdfObjectDictionary );};func (_dab *PdfParser )lookupByNumberWrapper (_dfa int ,_cac bool )(PdfObject ,bool ,error ){_gf ,_abg ,_aee :=_dab .lookupByNumber (_dfa ,_cac );if _aee !=nil {return nil ,_abg ,_aee ;};if !_abg &&_dab ._dgdd !=nil &&!_dab ._dgdd .isDecrypted (_gf ){_bc :=_dab ._dgdd .Decrypt (_gf ,0,0);if _bc !=nil {return nil ,_abg ,_bc ;};};return _gf ,_abg ,nil ;};

// Elements returns a slice of the PdfObject elements in the array.
// Preferred over accessing the array directly as type may be changed in future major versions (v3).
func (_bebef *PdfObjectStreams )Elements ()[]PdfObject {if _bebef ==nil {return nil ;};return _bebef ._cdaag ;};

// PdfObjectStream represents the primitive PDF Object stream.
type PdfObjectStream struct{PdfObjectReference ;*PdfObjectDictionary ;Stream []byte ;};

// EncodeBytes implements support for LZW encoding.  Currently not supporting predictors (raw compressed data only).
// Only supports the Early change = 1 algorithm (compress/lzw) as the other implementation
// does not have a write method.
// TODO: Consider refactoring compress/lzw to allow both.
func (_bgc *LZWEncoder )EncodeBytes (data []byte )([]byte ,error ){if _bgc .Predictor !=1{return nil ,_f .Errorf ("\u004c\u005aW \u0050\u0072\u0065d\u0069\u0063\u0074\u006fr =\u00201 \u006f\u006e\u006c\u0079\u0020\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0079e\u0074");};if _bgc .EarlyChange ==1{return nil ,_f .Errorf ("\u004c\u005a\u0057\u0020\u0045\u0061\u0072\u006c\u0079\u0020\u0043\u0068\u0061n\u0067\u0065\u0020\u003d\u0020\u0030 \u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0079\u0065\u0074");};var _ggfag _gb .Buffer ;_fdeb :=_eg .NewWriter (&_ggfag ,_eg .MSB ,8);_fdeb .Write (data );_fdeb .Close ();return _ggfag .Bytes (),nil ;};

// String returns a string describing `array`.
func (_affg *PdfObjectArray )String ()string {_bfea :="\u005b";for _dfea ,_deegb :=range _affg .Elements (){_bfea +=_deegb .String ();if _dfea < (_affg .Len ()-1){_bfea +="\u002c\u0020";};};_bfea +="\u005d";return _bfea ;};

// SetPredictor sets the predictor function.  Specify the number of columns per row.
// The columns indicates the number of samples per row.
// Used for grouping data together for compression.
func (_adg *FlateEncoder )SetPredictor (columns int ){_adg .Predictor =11;_adg .Columns =columns };

// NewMultiEncoder returns a new instance of MultiEncoder.
func NewMultiEncoder ()*MultiEncoder {_edgbf :=MultiEncoder {};_edgbf ._caab =[]StreamEncoder {};return &_edgbf ;};

// Validate validates the page settings for the JBIG2 encoder.
func (_bbbb JBIG2EncoderSettings )Validate ()error {const _afbf ="\u0076a\u006ci\u0064\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065\u0072";if _bbbb .Threshold < 0||_bbbb .Threshold > 1.0{return _ef .Errorf (_afbf ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074\u0068\u0072\u0065\u0073\u0068\u006f\u006c\u0064\u0020\u0076a\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0076\u0027 \u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0069\u006e\u0020\u0072\u0061n\u0067\u0065\u0020\u005b\u0030\u002e0\u002c\u0020\u0031.\u0030\u005d",_bbbb .Threshold );};if _bbbb .ResolutionX < 0{return _ef .Errorf (_afbf ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0078\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_bbbb .ResolutionX );};if _bbbb .ResolutionY < 0{return _ef .Errorf (_afbf ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0079\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_bbbb .ResolutionY );};if _bbbb .DefaultPixelValue !=0&&_bbbb .DefaultPixelValue !=1{return _ef .Errorf (_afbf ,"de\u0066\u0061u\u006c\u0074\u0020\u0070\u0069\u0078\u0065\u006c\u0020v\u0061\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0066o\u0072 \u0074\u0068\u0065\u0020\u0062\u0069\u0074\u003a \u007b0\u002c\u0031}",_bbbb .DefaultPixelValue );};if _bbbb .Compression !=JB2Generic {return _ef .Errorf (_afbf ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065d\u0020\u0063\u006fm\u0070\u0072\u0065\u0073s\u0069\u006f\u006e\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");};return nil ;};func (_geb *PdfCrypt )isDecrypted (_afc PdfObject )bool {_ ,_cab :=_geb ._fgad [_afc ];if _cab {_fcb .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0064\u0065\u0063\u0072y\u0070\u0074\u0065\u0064");return true ;};switch _cgca :=_afc .(type ){case *PdfObjectStream :if _geb ._bbd .R !=5{if _fbf ,_fdea :=_cgca .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_fdea &&*_fbf =="\u0058\u0052\u0065\u0066"{return true ;};};case *PdfIndirectObject :if _ ,_cab =_geb ._agbc [int (_cgca .ObjectNumber )];_cab {return true ;};switch _eaab :=_cgca .PdfObject .(type ){case *PdfObjectDictionary :_fggb :=true ;for _ ,_fbe :=range _ggc {if _eaab .Get (_fbe )==nil {_fggb =false ;break ;};};if _fggb {return true ;};};};_fcb .Log .Trace ("\u004e\u006f\u0074\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");return false ;};func (_acaa *PdfParser )readComment ()(string ,error ){var _eaada _gb .Buffer ;_ ,_bdbc :=_acaa .skipSpaces ();if _bdbc !=nil {return _eaada .String (),_bdbc ;};_gfbb :=true ;for {_afbfd ,_bdef :=_acaa ._aggcb .Peek (1);if _bdef !=nil {_fcb .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_bdef .Error ());return _eaada .String (),_bdef ;};if _gfbb &&_afbfd [0]!='%'{return _eaada .String (),_ca .New ("c\u006f\u006d\u006d\u0065\u006e\u0074 \u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0073\u0074a\u0072\u0074\u0020w\u0069t\u0068\u0020\u0025");};_gfbb =false ;if (_afbfd [0]!='\r')&&(_afbfd [0]!='\n'){_aebe ,_ :=_acaa ._aggcb .ReadByte ();_eaada .WriteByte (_aebe );}else {break ;};};return _eaada .String (),nil ;};

// MakeStream creates an PdfObjectStream with specified contents and encoding. If encoding is nil, then raw encoding
// will be used (i.e. no encoding applied).
func MakeStream (contents []byte ,encoder StreamEncoder )(*PdfObjectStream ,error ){_dfgc :=&PdfObjectStream {};if encoder ==nil {encoder =NewRawEncoder ();};_dfgc .PdfObjectDictionary =encoder .MakeStreamDict ();_fdcbg ,_baagc :=encoder .EncodeBytes (contents );if _baagc !=nil {return nil ,_baagc ;};_dfgc .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_fdcbg ))));_dfgc .Stream =_fdcbg ;return _dfgc ,nil ;};func (_gafg *PdfParser )parseNull ()(PdfObjectNull ,error ){_ ,_cgbda :=_gafg ._aggcb .Discard (4);return PdfObjectNull {},_cgbda ;};

// NewParserFromString is used for testing purposes.
func NewParserFromString (txt string )*PdfParser {_ebgd :=_gb .NewReader ([]byte (txt ));_ggdga :=&PdfParser {ObjCache :objectCache {},_dgcfc :_ebgd ,_aggcb :_fc .NewReader (_ebgd ),_bgbf :int64 (len (txt )),_efea :map[int64 ]bool {}};_ggdga ._gaeec .ObjectMap =make (map[int ]XrefObject );return _ggdga ;};func (_dcbfd *PdfParser )traceStreamLength (_beca PdfObject )(PdfObject ,error ){_bfbf ,_cdfa :=_beca .(*PdfObjectReference );if _cdfa {_bffa ,_dfca :=_dcbfd ._efea [_bfbf .ObjectNumber ];if _dfca &&_bffa {_fcb .Log .Debug ("\u0053t\u0072\u0065a\u006d\u0020\u004c\u0065n\u0067\u0074\u0068 \u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065 u\u006e\u0072\u0065s\u006f\u006cv\u0065\u0064\u0020\u0028\u0069\u006cl\u0065\u0067a\u006c\u0029");return nil ,_ca .New ("\u0069\u006c\u006c\u0065ga\u006c\u0020\u0072\u0065\u0063\u0075\u0072\u0073\u0069\u0076\u0065\u0020\u006c\u006fo\u0070");};_dcbfd ._efea [_bfbf .ObjectNumber ]=true ;};_fded ,_ecea :=_dcbfd .Resolve (_beca );if _ecea !=nil {return nil ,_ecea ;};_fcb .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_fded );if _cdfa {_dcbfd ._efea [_bfbf .ObjectNumber ]=false ;};return _fded ,nil ;};

// NewFlateEncoder makes a new flate encoder with default parameters, predictor 1 and bits per component 8.
func NewFlateEncoder ()*FlateEncoder {_caca :=&FlateEncoder {};_caca .Predictor =1;_caca .BitsPerComponent =8;_caca .Colors =1;_caca .Columns =1;return _caca ;};

// FlattenObject returns the contents of `obj`. In other words, `obj` with indirect objects replaced
// by their values.
// The replacements are made recursively to a depth of traceMaxDepth.
// NOTE: Dicts are sorted to make objects with same contents have the same PDF object strings.
func FlattenObject (obj PdfObject )PdfObject {return _fbcaf (obj ,0)};

// NewASCIIHexEncoder makes a new ASCII hex encoder.
func NewASCIIHexEncoder ()*ASCIIHexEncoder {_caba :=&ASCIIHexEncoder {};return _caba };

// GetCrypter returns the PdfCrypt instance which has information about the PDFs encryption.
func (_facd *PdfParser )GetCrypter ()*PdfCrypt {return _facd ._dgdd };

// MakeName creates a PdfObjectName from a string.
func MakeName (s string )*PdfObjectName {_edgga :=PdfObjectName (s );return &_edgga };

// Remove removes an element specified by key.
func (_dcgaa *PdfObjectDictionary )Remove (key PdfObjectName ){_deea :=-1;for _fcfef ,_cafe :=range _dcgaa ._fddg {if _cafe ==key {_deea =_fcfef ;break ;};};if _deea >=0{_dcgaa ._fddg =append (_dcgaa ._fddg [:_deea ],_dcgaa ._fddg [_deea +1:]...);delete (_dcgaa ._eedfb ,key );};};

// GetString returns the *PdfObjectString represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetString (obj PdfObject )(_fcga *PdfObjectString ,_ggee bool ){_fcga ,_ggee =TraceToDirectObject (obj ).(*PdfObjectString );return _fcga ,_ggee ;};func (_ggcc *offsetReader )Seek (offset int64 ,whence int )(int64 ,error ){if whence ==_ce .SeekStart {offset +=_ggcc ._bbad ;};_cfeb ,_fcdda :=_ggcc ._dcbeg .Seek (offset ,whence );if _fcdda !=nil {return _cfeb ,_fcdda ;};if whence ==_ce .SeekCurrent {_cfeb -=_ggcc ._bbad ;};if _cfeb < 0{return 0,_ca .New ("\u0063\u006f\u0072\u0065\u002eo\u0066\u0066\u0073\u0065\u0074\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053e\u0065\u006b\u003a\u0020\u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e");};return _cfeb ,nil ;};

// Len returns the number of elements in the array.
func (_bdefa *PdfObjectArray )Len ()int {if _bdefa ==nil {return 0;};return len (_bdefa ._ageac );};

// UpdateParams updates the parameter values of the encoder.
func (_cedg *RawEncoder )UpdateParams (params *PdfObjectDictionary ){};func _gbg (_cfed *PdfObjectStream )(*MultiEncoder ,error ){_cdaa :=NewMultiEncoder ();_fbff :=_cfed .PdfObjectDictionary ;if _fbff ==nil {return _cdaa ,nil ;};var _bfcd *PdfObjectDictionary ;var _bac []PdfObject ;_ffcb :=_fbff .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _ffcb !=nil {_bbbe ,_ebef :=_ffcb .(*PdfObjectDictionary );if _ebef {_bfcd =_bbbe ;};_acgc ,_ddf :=_ffcb .(*PdfObjectArray );if _ddf {for _ ,_bbdf :=range _acgc .Elements (){_bbdf =TraceToDirectObject (_bbdf );if _aba ,_ccd :=_bbdf .(*PdfObjectDictionary );_ccd {_bac =append (_bac ,_aba );}else {_bac =append (_bac ,MakeDict ());};};};};_ffcb =_fbff .Get ("\u0046\u0069\u006c\u0074\u0065\u0072");if _ffcb ==nil {return nil ,_f .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u006d\u0069s\u0073\u0069\u006e\u0067");};_bbdg ,_agff :=_ffcb .(*PdfObjectArray );if !_agff {return nil ,_f .Errorf ("m\u0075\u006c\u0074\u0069\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0063\u0061\u006e\u0020\u006f\u006el\u0079\u0020\u0062\u0065\u0020\u006d\u0061\u0064\u0065\u0020fr\u006f\u006d\u0020a\u0072r\u0061\u0079");};for _gddd ,_gdcb :=range _bbdg .Elements (){_gdfa ,_gecc :=_gdcb .(*PdfObjectName );if !_gecc {return nil ,_f .Errorf ("\u006d\u0075l\u0074\u0069\u0020\u0066i\u006c\u0074e\u0072\u0020\u0061\u0072\u0072\u0061\u0079\u0020e\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u006e\u006f\u0074\u0020\u0061 \u006e\u0061\u006d\u0065");};var _dcfe PdfObject ;if _bfcd !=nil {_dcfe =_bfcd ;}else {if len (_bac )> 0{if _gddd >=len (_bac ){return nil ,_f .Errorf ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0073\u0020\u0069\u006e\u0020d\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006d\u0073\u0020a\u0072\u0072\u0061\u0079");};_dcfe =_bac [_gddd ];};};var _gcef *PdfObjectDictionary ;if _acaf ,_bagg :=_dcfe .(*PdfObjectDictionary );_bagg {_gcef =_acaf ;};_fcb .Log .Trace ("\u004e\u0065\u0078t \u006e\u0061\u006d\u0065\u003a\u0020\u0025\u0073\u002c \u0064p\u003a \u0025v\u002c\u0020\u0064\u0050\u0061\u0072\u0061\u006d\u0073\u003a\u0020\u0025\u0076",*_gdfa ,_dcfe ,_gcef );if *_gdfa ==StreamEncodingFilterNameFlate {_cbbdf ,_cgge :=_cgf (_cfed ,_gcef );if _cgge !=nil {return nil ,_cgge ;};_cdaa .AddEncoder (_cbbdf );}else if *_gdfa ==StreamEncodingFilterNameLZW {_gffac ,_fccd :=_aded (_cfed ,_gcef );if _fccd !=nil {return nil ,_fccd ;};_cdaa .AddEncoder (_gffac );}else if *_gdfa ==StreamEncodingFilterNameASCIIHex {_cgad :=NewASCIIHexEncoder ();_cdaa .AddEncoder (_cgad );}else if *_gdfa ==StreamEncodingFilterNameASCII85 {_dgbb :=NewASCII85Encoder ();_cdaa .AddEncoder (_dgbb );}else if *_gdfa ==StreamEncodingFilterNameDCT {_egfb ,_efca :=_ddaa (_cfed ,_cdaa );if _efca !=nil {return nil ,_efca ;};_cdaa .AddEncoder (_egfb );_fcb .Log .Trace ("A\u0064d\u0065\u0064\u0020\u0044\u0043\u0054\u0020\u0065n\u0063\u006f\u0064\u0065r.\u002e\u002e");_fcb .Log .Trace ("\u004du\u006ct\u0069\u0020\u0065\u006e\u0063o\u0064\u0065r\u003a\u0020\u0025\u0023\u0076",_cdaa );}else {_fcb .Log .Error ("U\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0066\u0069l\u0074\u0065\u0072\u0020\u0025\u0073",*_gdfa );return nil ,_f .Errorf ("\u0069\u006eva\u006c\u0069\u0064 \u0066\u0069\u006c\u0074er \u0069n \u006d\u0075\u006c\u0074\u0069\u0020\u0066il\u0074\u0065\u0072\u0020\u0061\u0072\u0072a\u0079");};};return _cdaa ,nil ;};

// DecodeBytes decodes a slice of LZW encoded bytes and returns the result.
func (_ggfg *LZWEncoder )DecodeBytes (encoded []byte )([]byte ,error ){var _gff _gb .Buffer ;_fbdb :=_gb .NewReader (encoded );var _afd _ce .ReadCloser ;if _ggfg .EarlyChange ==1{_afd =_dec .NewReader (_fbdb ,_dec .MSB ,8);}else {_afd =_eg .NewReader (_fbdb ,_eg .MSB ,8);};defer _afd .Close ();_ ,_acee :=_gff .ReadFrom (_afd );if _acee !=nil {return nil ,_acee ;};return _gff .Bytes (),nil ;};func _bfbge (_gged *PdfObjectDictionary )(_bedcgd *_bed .ImageBase ){var (_efcb *PdfObjectInteger ;_gade bool ;);if _efcb ,_gade =_gged .Get ("\u0057\u0069\u0064t\u0068").(*PdfObjectInteger );_gade {_bedcgd =&_bed .ImageBase {Width :int (*_efcb )};}else {return nil ;};if _efcb ,_gade =_gged .Get ("\u0048\u0065\u0069\u0067\u0068\u0074").(*PdfObjectInteger );_gade {_bedcgd .Height =int (*_efcb );};if _efcb ,_gade =_gged .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074").(*PdfObjectInteger );_gade {_bedcgd .BitsPerComponent =int (*_efcb );};if _efcb ,_gade =_gged .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073").(*PdfObjectInteger );_gade {_bedcgd .ColorComponents =int (*_efcb );};return _bedcgd ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_dgeb *RawEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};

// LookupByNumber looks up a PdfObject by object number.  Returns an error on failure.
func (_ggg *PdfParser )LookupByNumber (objNumber int )(PdfObject ,error ){_cf ,_ ,_efb :=_ggg .lookupByNumberWrapper (objNumber ,true );return _cf ,_efb ;};

// CCITTFaxEncoder implements Group3 and Group4 facsimile (fax) encoder/decoder.
type CCITTFaxEncoder struct{K int ;EndOfLine bool ;EncodedByteAlign bool ;Columns int ;Rows int ;EndOfBlock bool ;BlackIs1 bool ;DamagedRowsBeforeError int ;};

// MakeStreamDict make a new instance of an encoding dictionary for a stream object.
func (_egad *ASCII85Encoder )MakeStreamDict ()*PdfObjectDictionary {_cdaf :=MakeDict ();_cdaf .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_egad .GetFilterName ()));return _cdaf ;};

// ASCII85Encoder implements ASCII85 encoder/decoder.
type ASCII85Encoder struct{};

// MakeNull creates an PdfObjectNull.
func MakeNull ()*PdfObjectNull {_adbce :=PdfObjectNull {};return &_adbce };func (_ebfb *PdfParser )parseNumber ()(PdfObject ,error ){return ParseNumber (_ebfb ._aggcb )};

// GetFilterName returns the name of the encoding filter.
func (_gbddc *JBIG2Encoder )GetFilterName ()string {return StreamEncodingFilterNameJBIG2 };

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_gfbc *MultiEncoder )MakeStreamDict ()*PdfObjectDictionary {_eaaa :=MakeDict ();_eaaa .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",_gfbc .GetFilterArray ());for _ ,_egea :=range _gfbc ._caab {_efbgf :=_egea .MakeStreamDict ();for _ ,_eafe :=range _efbgf .Keys (){_gcfc :=_efbgf .Get (_eafe );if _eafe !="\u0046\u0069\u006c\u0074\u0065\u0072"&&_eafe !="D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"{_eaaa .Set (_eafe ,_gcfc );};};};_fcfc :=_gfbc .MakeDecodeParams ();if _fcfc !=nil {_eaaa .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_fcfc );};return _eaaa ;};

// GetArray returns the *PdfObjectArray represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetArray (obj PdfObject )(_dgca *PdfObjectArray ,_egbe bool ){_dgca ,_egbe =TraceToDirectObject (obj ).(*PdfObjectArray );return _dgca ,_egbe ;};

// UpdateParams updates the parameter values of the encoder.
func (_gda *ASCII85Encoder )UpdateParams (params *PdfObjectDictionary ){};

// UpdateParams updates the parameter values of the encoder.
func (_bcg *RunLengthEncoder )UpdateParams (params *PdfObjectDictionary ){};

// Version represents a version of a PDF standard.
type Version struct{Major int ;Minor int ;};

// NewRawEncoder returns a new instace of RawEncoder.
func NewRawEncoder ()*RawEncoder {return &RawEncoder {}};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_fdg *RunLengthEncoder )MakeDecodeParams ()PdfObject {return nil };

// EncodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_gceb *RawEncoder )EncodeBytes (data []byte )([]byte ,error ){return data ,nil };func _cgf (_eggc *PdfObjectStream ,_cbc *PdfObjectDictionary )(*FlateEncoder ,error ){_dffb :=NewFlateEncoder ();_adgg :=_eggc .PdfObjectDictionary ;if _adgg ==nil {return _dffb ,nil ;};_dffb ._ebb =_bfbge (_adgg );if _cbc ==nil {_bdd :=TraceToDirectObject (_adgg .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));switch _bfa :=_bdd .(type ){case *PdfObjectArray :_acef :=_bfa ;if _acef .Len ()!=1{_fcb .Log .Debug ("\u0045\u0072\u0072\u006f\u0072:\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020a\u0072\u0072\u0061\u0079\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0021\u003d\u0020\u0031\u0020\u0028\u0025\u0064\u0029",_acef .Len ());return nil ,_ca .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_bdd =TraceToDirectObject (_acef .Get (0));case *PdfObjectDictionary :_cbc =_bfa ;case *PdfObjectNull ,nil :default:_fcb .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020n\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079 \u0028%\u0054\u0029",_bdd );return nil ,_f .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _cbc ==nil {return _dffb ,nil ;};_fcb .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_cbc .String ());_afcg :=_cbc .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");if _afcg ==nil {_fcb .Log .Debug ("E\u0072\u0072o\u0072\u003a\u0020\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067 \u0066\u0072\u006f\u006d\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073 \u002d\u0020\u0043\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020\u0077\u0069t\u0068\u0020\u0064\u0065\u0066\u0061\u0075\u006c\u0074\u0020\u00281\u0029");}else {_ccg ,_gcg :=_afcg .(*PdfObjectInteger );if !_gcg {_fcb .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_afcg );return nil ,_f .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_dffb .Predictor =int (*_ccg );};_afcg =_cbc .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");if _afcg !=nil {_gfc ,_caag :=_afcg .(*PdfObjectInteger );if !_caag {_fcb .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");return nil ,_f .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_dffb .BitsPerComponent =int (*_gfc );};if _dffb .Predictor > 1{_dffb .Columns =1;_afcg =_cbc .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");if _afcg !=nil {_dge ,_ddcb :=_afcg .(*PdfObjectInteger );if !_ddcb {return nil ,_f .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_dffb .Columns =int (*_dge );};_dffb .Colors =1;_afcg =_cbc .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _afcg !=nil {_geaf ,_cdcd :=_afcg .(*PdfObjectInteger );if !_cdcd {return nil ,_f .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");};_dffb .Colors =int (*_geaf );};};return _dffb ,nil ;};

// PdfObjectString represents the primitive PDF string object.
type PdfObjectString struct{_bebd string ;_daag bool ;};type encryptDict struct{Filter string ;V int ;SubFilter string ;Length int ;StmF string ;StrF string ;EFF string ;CF map[string ]_gbb .FilterDict ;};

// EqualObjects returns true if `obj1` and `obj2` have the same contents.
//
// NOTE: It is a good idea to flatten obj1 and obj2 with FlattenObject before calling this function
// so that contents, rather than references, can be compared.
func EqualObjects (obj1 ,obj2 PdfObject )bool {return _eedbf (obj1 ,obj2 ,0)};

// Keys returns the list of keys in the dictionary.
// If `d` is nil returns a nil slice.
func (_gdecg *PdfObjectDictionary )Keys ()[]PdfObjectName {if _gdecg ==nil {return nil ;};return _gdecg ._fddg ;};

// EncodeStream encodes the stream data using the encoded specified by the stream's dictionary.
func EncodeStream (streamObj *PdfObjectStream )error {_fcb .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_fcgfg ,_ggfb :=NewEncoderFromStream (streamObj );if _ggfb !=nil {_fcb .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_ggfb );return _ggfb ;};if _ecdda ,_dagf :=_fcgfg .(*LZWEncoder );_dagf {_ecdda .EarlyChange =0;streamObj .PdfObjectDictionary .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (0));};_fcb .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076\u000a",_fcgfg );_feecb ,_ggfb :=_fcgfg .EncodeBytes (streamObj .Stream );if _ggfb !=nil {_fcb .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_ggfb );return _ggfb ;};streamObj .Stream =_feecb ;streamObj .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_feecb ))));return nil ;};

// Set sets the dictionary's key -> val mapping entry. Overwrites if key already set.
func (_cbbc *PdfObjectDictionary )Set (key PdfObjectName ,val PdfObject ){_ ,_fdca :=_cbbc ._eedfb [key ];if !_fdca {_cbbc ._fddg =append (_cbbc ._fddg ,key );};_cbbc ._eedfb [key ]=val ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_fcag *ASCII85Encoder )MakeDecodeParams ()PdfObject {return nil };

// ToInt64Slice returns a slice of all array elements as an int64 slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_ecdd *PdfObjectArray )ToInt64Slice ()([]int64 ,error ){var _aggb []int64 ;for _ ,_bdeg :=range _ecdd .Elements (){if _gfef ,_cceee :=_bdeg .(*PdfObjectInteger );_cceee {_aggb =append (_aggb ,int64 (*_gfef ));}else {return nil ,ErrTypeError ;};};return _aggb ,nil ;};

// Get returns the i-th element of the array or nil if out of bounds (by index).
func (_fgbb *PdfObjectArray )Get (i int )PdfObject {if _fgbb ==nil ||i >=len (_fgbb ._ageac )||i < 0{return nil ;};return _fgbb ._ageac [i ];};

// MakeString creates an PdfObjectString from a string.
// NOTE: PDF does not use utf-8 string encoding like Go so `s` will often not be a utf-8 encoded
// string.
func MakeString (s string )*PdfObjectString {_gcdf :=PdfObjectString {_bebd :s };return &_gcdf };

// MakeArrayFromIntegers creates an PdfObjectArray from a slice of ints, where each array element is
// an PdfObjectInteger.
func MakeArrayFromIntegers (vals []int )*PdfObjectArray {_eggeg :=MakeArray ();for _ ,_cbgaa :=range vals {_eggeg .Append (MakeInteger (int64 (_cbgaa )));};return _eggeg ;};func _dbd (_bde *_ff .StdEncryptDict ,_cdad *PdfObjectDictionary )error {R ,_gga :=_cdad .Get ("\u0052").(*PdfObjectInteger );if !_gga {return _ca .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0052");};if *R < 2||*R > 6{return _f .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0052 \u0028\u0025\u0064\u0029",*R );};_bde .R =int (*R );O ,_gga :=_cdad .GetString ("\u004f");if !_gga {return _ca .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u004f");};if _bde .R ==5||_bde .R ==6{if len (O )< 48{return _f .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u004f\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (O ));};}else if len (O )!=32{return _f .Errorf ("L\u0065n\u0067\u0074\u0068\u0028\u004f\u0029\u0020\u0021=\u0020\u0033\u0032\u0020(%\u0064\u0029",len (O ));};_bde .O =[]byte (O );U ,_gga :=_cdad .GetString ("\u0055");if !_gga {return _ca .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0055");};if _bde .R ==5||_bde .R ==6{if len (U )< 48{return _f .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u0055\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (U ));};}else if len (U )!=32{_fcb .Log .Debug ("\u0057\u0061r\u006e\u0069\u006e\u0067\u003a\u0020\u004c\u0065\u006e\u0067\u0074\u0068\u0028\u0055\u0029\u0020\u0021\u003d\u0020\u0033\u0032\u0020(%\u0064\u0029",len (U ));};_bde .U =[]byte (U );if _bde .R >=5{OE ,_abd :=_cdad .GetString ("\u004f\u0045");if !_abd {return _ca .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u004f\u0045");}else if len (OE )!=32{return _f .Errorf ("L\u0065\u006e\u0067\u0074h(\u004fE\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (OE ));};_bde .OE =[]byte (OE );UE ,_abd :=_cdad .GetString ("\u0055\u0045");if !_abd {return _ca .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u0055\u0045");}else if len (UE )!=32{return _f .Errorf ("L\u0065\u006e\u0067\u0074h(\u0055E\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (UE ));};_bde .UE =[]byte (UE );};P ,_gga :=_cdad .Get ("\u0050").(*PdfObjectInteger );if !_gga {return _ca .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074 \u0064\u0069\u0063t\u0069\u006f\u006e\u0061r\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0070\u0065\u0072\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0061\u0074\u0074\u0072");};_bde .P =_ff .Permissions (*P );if _bde .R ==6{Perms ,_af :=_cdad .GetString ("\u0050\u0065\u0072m\u0073");if !_af {return _ca .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0050\u0065\u0072\u006d\u0073");}else if len (Perms )!=16{return _f .Errorf ("\u004ce\u006e\u0067\u0074\u0068\u0028\u0050\u0065\u0072\u006d\u0073\u0029 \u0021\u003d\u0020\u0031\u0036\u0020\u0028\u0025\u0064\u0029",len (Perms ));};_bde .Perms =[]byte (Perms );};if _eae ,_daba :=_cdad .Get ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061").(*PdfObjectBool );_daba {_bde .EncryptMetadata =bool (*_eae );}else {_bde .EncryptMetadata =true ;};return nil ;};func (_fgbf *PdfParser )parseXrefTable ()(*PdfObjectDictionary ,error ){var _dcff *PdfObjectDictionary ;_fbeb ,_dgbe :=_fgbf .readTextLine ();if _dgbe !=nil {return nil ,_dgbe ;};_fcb .Log .Trace ("\u0078\u0072\u0065\u0066 f\u0069\u0072\u0073\u0074\u0020\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_fbeb );_gedfe :=-1;_eedb :=0;_dbge :=false ;_adgc :="";for {_fgbf .skipSpaces ();_ ,_effb :=_fgbf ._aggcb .Peek (1);if _effb !=nil {return nil ,_effb ;};_fbeb ,_effb =_fgbf .readTextLine ();if _effb !=nil {return nil ,_effb ;};_febe :=_eaca .FindStringSubmatch (_fbeb );if len (_febe )==0{_cfad :=len (_adgc )> 0;_adgc +=_fbeb +"\u000a";if _cfad {_febe =_eaca .FindStringSubmatch (_adgc );};};if len (_febe )==3{_dbegf ,_ :=_e .Atoi (_febe [1]);_dfaaa ,_ :=_e .Atoi (_febe [2]);_gedfe =_dbegf ;_eedb =_dfaaa ;_dbge =true ;_adgc ="";_fcb .Log .Trace ("\u0078r\u0065\u0066 \u0073\u0075\u0062s\u0065\u0063\u0074\u0069\u006f\u006e\u003a \u0066\u0069\u0072\u0073\u0074\u0020o\u0062\u006a\u0065\u0063\u0074\u003a\u0020\u0025\u0064\u0020\u006fb\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_gedfe ,_eedb );continue ;};_feae :=_dgaf .FindStringSubmatch (_fbeb );if len (_feae )==4{if _dbge ==false {_fcb .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0058r\u0065\u0066\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u006fr\u006da\u0074\u0021\u000a");return nil ,_ca .New ("\u0078\u0072\u0065\u0066 i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072\u006d\u0061\u0074");};_fgecc ,_ :=_e .ParseInt (_feae [1],10,64);_edfa ,_ :=_e .Atoi (_feae [2]);_fedg :=_feae [3];_adgc ="";if _ceg .ToLower (_fedg )=="\u006e"&&_fgecc > 1{_baeea ,_ggffb :=_fgbf ._gaeec .ObjectMap [_gedfe ];if !_ggffb ||_edfa > _baeea .Generation {_fdbb :=XrefObject {ObjectNumber :_gedfe ,XType :XrefTypeTableEntry ,Offset :_fgecc ,Generation :_edfa };_fgbf ._gaeec .ObjectMap [_gedfe ]=_fdbb ;};};_gedfe ++;continue ;};if (len (_fbeb )> 6)&&(_fbeb [:7]=="\u0074r\u0061\u0069\u006c\u0065\u0072"){_fcb .Log .Trace ("\u0046o\u0075n\u0064\u0020\u0074\u0072\u0061i\u006c\u0065r\u0020\u002d\u0020\u0025\u0073",_fbeb );if len (_fbeb )> 9{_cfdb :=_fgbf .GetFileOffset ();_fgbf .SetFileOffset (_cfdb -int64 (len (_fbeb ))+7);};_fgbf .skipSpaces ();_fgbf .skipComments ();_fcb .Log .Trace ("R\u0065\u0061\u0064\u0069ng\u0020t\u0072\u0061\u0069\u006c\u0065r\u0020\u0064\u0069\u0063\u0074\u0021");_fcb .Log .Trace ("\u0070\u0065\u0065\u006b\u003a\u0020\u0022\u0025\u0073\u0022",_fbeb );_dcff ,_effb =_fgbf .ParseDict ();_fcb .Log .Trace ("\u0045O\u0046\u0020\u0072\u0065a\u0064\u0069\u006e\u0067\u0020t\u0072a\u0069l\u0065\u0072\u0020\u0064\u0069\u0063\u0074!");if _effb !=nil {_fcb .Log .Debug ("\u0045\u0072\u0072o\u0072\u0020\u0070\u0061r\u0073\u0069\u006e\u0067\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u0064\u0069\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_effb );return nil ,_effb ;};break ;};if _fbeb =="\u0025\u0025\u0045O\u0046"{_fcb .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006e\u0064 \u006f\u0066\u0020\u0066\u0069\u006c\u0065 -\u0020\u0074\u0072\u0061i\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066ou\u006e\u0064 \u002d\u0020\u0065\u0072\u0072\u006f\u0072\u0021");return nil ,_ca .New ("\u0065\u006e\u0064 \u006f\u0066\u0020\u0066i\u006c\u0065\u0020\u002d\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};_fcb .Log .Trace ("\u0078\u0072\u0065\u0066\u0020\u006d\u006f\u0072\u0065 \u003a\u0020\u0025\u0073",_fbeb );};_fcb .Log .Trace ("\u0045\u004f\u0046 p\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0021");if _fgbf ._cffe ==nil {_dgbba :=XrefTypeTableEntry ;_fgbf ._cffe =&_dgbba ;};return _dcff ,nil ;};func (_gea *PdfParser )lookupByNumber (_fac int ,_ad bool )(PdfObject ,bool ,error ){_adb ,_fce :=_gea .ObjCache [_fac ];if _fce {_fcb .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0063a\u0063\u0068\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0025\u0064",_fac );return _adb ,false ,nil ;};_fb ,_fce :=_gea ._gaeec .ObjectMap [_fac ];if !_fce {_fcb .Log .Trace ("\u0055\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u006c\u006f\u0063\u0061t\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0069\u006e\u0020\u0078\u0072\u0065\u0066\u0073\u0021 \u002d\u0020\u0052\u0065\u0074u\u0072\u006e\u0069\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074");var _bd PdfObjectNull ;return &_bd ,false ,nil ;};_fcb .Log .Trace ("L\u006fo\u006b\u0075\u0070\u0020\u006f\u0062\u006a\u0020n\u0075\u006d\u0062\u0065r \u0025\u0064",_fac );if _fb .XType ==XrefTypeTableEntry {_fcb .Log .Trace ("\u0078r\u0065f\u006f\u0062\u006a\u0020\u006fb\u006a\u0020n\u0075\u006d\u0020\u0025\u0064",_fb .ObjectNumber );_fcb .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u0067e\u006e\u0020\u0025\u0064",_fb .Generation );_fcb .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0064",_fb .Offset );_gea ._dgcfc .Seek (_fb .Offset ,_g .SEEK_SET );_gea ._aggcb =_fc .NewReader (_gea ._dgcfc );_dbg ,_bba :=_gea .ParseIndirectObject ();if _bba !=nil {_fcb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006ce\u0064\u0020\u0072\u0065\u0061\u0064\u0069n\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029",_bba );if _ad {_fcb .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0072\u0065\u0070\u0061\u0069r\u0020\u0078\u0072\u0065\u0066\u0073\u0020\u0028\u0074\u006f\u0070\u0020d\u006f\u0077\u006e\u0029");_dfg ,_dbf :=_gea .repairRebuildXrefsTopDown ();if _dbf !=nil {_fcb .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020r\u0065\u0070\u0061\u0069\u0072\u0020\u0028\u0025\u0073\u0029",_dbf );return nil ,false ,_dbf ;};_gea ._gaeec =*_dfg ;return _gea .lookupByNumber (_fac ,false );};return nil ,false ,_bba ;};if _ad {_ded ,_ ,_ :=_ace (_dbg );if int (_ded )!=_fac {_fcb .Log .Debug ("\u0049n\u0076\u0061\u006c\u0069d\u0020\u0078\u0072\u0065\u0066s\u003a \u0052e\u0062\u0075\u0069\u006c\u0064\u0069\u006eg");_bee :=_gea .rebuildXrefTable ();if _bee !=nil {return nil ,false ,_bee ;};_gea .ObjCache =objectCache {};return _gea .lookupByNumberWrapper (_fac ,false );};};_fcb .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006f\u0062\u006a");_gea .ObjCache [_fac ]=_dbg ;return _dbg ,false ,nil ;}else if _fb .XType ==XrefTypeObjectStream {_fcb .Log .Trace ("\u0078r\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0021");_fcb .Log .Trace ("\u003e\u004c\u006f\u0061\u0064\u0020\u0076\u0069\u0061\u0020\u004f\u0053\u0021");_fcb .Log .Trace ("\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d \u0061\u0076\u0061\u0069\u006c\u0061b\u006c\u0065\u0020\u0069\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020%\u0064\u002f\u0025\u0064",_fb .OsObjNumber ,_fb .OsObjIndex );if _fb .OsObjNumber ==_fac {_fcb .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0043i\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065f\u0065\u0072\u0065n\u0063e\u0021\u003f\u0021");return nil ,true ,_ca .New ("\u0078\u0072\u0065f \u0063\u0069\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");};if _ ,_eaa :=_gea ._gaeec .ObjectMap [_fb .OsObjNumber ];_eaa {_dff ,_ed :=_gea .lookupObjectViaOS (_fb .OsObjNumber ,_fac );if _ed !=nil {_fcb .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0052\u0065\u0074\u0075\u0072\u006e\u0069n\u0067\u0020\u0045\u0052\u0052\u0020\u0028\u0025\u0073\u0029",_ed );return nil ,true ,_ed ;};_fcb .Log .Trace ("\u003c\u004c\u006f\u0061\u0064\u0065\u0064\u0020\u0076i\u0061\u0020\u004f\u0053");_gea .ObjCache [_fac ]=_dff ;if _gea ._dgdd !=nil {_gea ._dgdd ._fgad [_dff ]=true ;};return _dff ,true ,nil ;};_fcb .Log .Debug ("\u003f\u003f\u0020\u0042\u0065\u006c\u006f\u006eg\u0073\u0020\u0074o \u0061\u0020\u006e\u006f\u006e\u002dc\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u002e.\u002e\u0021");return nil ,true ,_ca .New ("\u006f\u0073\u0020\u0062\u0065\u006c\u006fn\u0067\u0073\u0020t\u006f\u0020\u0061\u0020n\u006f\u006e\u0020\u0063\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074");};return nil ,false ,_ca .New ("\u0075\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0078\u0072\u0065\u0066 \u0074\u0079\u0070\u0065");};func (_ebecc *PdfCrypt )generateParams (_gdcf ,_cfbg []byte )error {_efd :=_ebecc .securityHandler ();_dcc ,_ebcd :=_efd .GenerateParams (&_ebecc ._bbd ,_cfbg ,_gdcf );if _ebcd !=nil {return _ebcd ;};_ebecc ._efa =_dcc ;return nil ;};

// SetFileOffset sets the file to an offset position and resets buffer.
func (_fddd *PdfParser )SetFileOffset (offset int64 ){if offset < 0{offset =0;};_fddd ._dgcfc .Seek (offset ,_ce .SeekStart );_fddd ._aggcb =_fc .NewReader (_fddd ._dgcfc );};func (_fcc *ASCII85Encoder )base256Tobase85 (_cfac uint32 )[5]byte {_ecbb :=[5]byte {0,0,0,0,0};_gcfe :=_cfac ;for _edfeb :=0;_edfeb < 5;_edfeb ++{_acg :=uint32 (1);for _gaac :=0;_gaac < 4-_edfeb ;_gaac ++{_acg *=85;};_ebab :=_gcfe /_acg ;_gcfe =_gcfe %_acg ;_ecbb [_edfeb ]=byte (_ebab );};return _ecbb ;};

// GetFilterName returns the name of the encoding filter.
func (_eadb *FlateEncoder )GetFilterName ()string {return StreamEncodingFilterNameFlate };

// GetFilterName returns the name of the encoding filter.
func (_cbfb *ASCII85Encoder )GetFilterName ()string {return StreamEncodingFilterNameASCII85 };

// WriteString outputs the object as it is to be written to file.
func (_dafgf *PdfObjectArray )WriteString ()string {var _aaacg _ceg .Builder ;_aaacg .WriteString ("\u005b");for _dgfe ,_gcfd :=range _dafgf .Elements (){_aaacg .WriteString (_gcfd .WriteString ());if _dgfe < (_dafgf .Len ()-1){_aaacg .WriteString ("\u0020");};};_aaacg .WriteString ("\u005d");return _aaacg .String ();};

// EncodeBytes encodes data into ASCII85 encoded format.
func (_ggff *ASCII85Encoder )EncodeBytes (data []byte )([]byte ,error ){var _cegd _gb .Buffer ;for _fbcg :=0;_fbcg < len (data );_fbcg +=4{_dgce :=data [_fbcg ];_adedg :=1;_ebg :=byte (0);if _fbcg +1< len (data ){_ebg =data [_fbcg +1];_adedg ++;};_bge :=byte (0);if _fbcg +2< len (data ){_bge =data [_fbcg +2];_adedg ++;};_fdda :=byte (0);if _fbcg +3< len (data ){_fdda =data [_fbcg +3];_adedg ++;};_bbabf :=(uint32 (_dgce )<<24)|(uint32 (_ebg )<<16)|(uint32 (_bge )<<8)|uint32 (_fdda );if _bbabf ==0{_cegd .WriteByte ('z');}else {_cbbde :=_ggff .base256Tobase85 (_bbabf );for _ ,_cccc :=range _cbbde [:_adedg +1]{_cegd .WriteByte (_cccc +'!');};};};_cegd .WriteString ("\u007e\u003e");return _cegd .Bytes (),nil ;};

// String returns a string describing `ref`.
func (_gcce *PdfObjectReference )String ()string {return _f .Sprintf ("\u0052\u0065\u0066\u0028\u0025\u0064\u0020\u0025\u0064\u0029",_gcce .ObjectNumber ,_gcce .GenerationNumber );};

// StreamEncoder represents the interface for all PDF stream encoders.
type StreamEncoder interface{GetFilterName ()string ;MakeDecodeParams ()PdfObject ;MakeStreamDict ()*PdfObjectDictionary ;UpdateParams (_efc *PdfObjectDictionary );EncodeBytes (_gca []byte )([]byte ,error );DecodeBytes (_beebb []byte )([]byte ,error );DecodeStream (_ebea *PdfObjectStream )([]byte ,error );};

// IsDelimiter checks if a character represents a delimiter.
func IsDelimiter (c byte )bool {return c =='('||c ==')'||c =='<'||c =='>'||c =='['||c ==']'||c =='{'||c =='}'||c =='/'||c =='%';};func _fbcaf (_fcee PdfObject ,_ddag int )PdfObject {if _ddag > _bcfbg {_fcb .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_bcfbg );return MakeNull ();};switch _eebb :=_fcee .(type ){case *PdfIndirectObject :_fcee =_fbcaf ((*_eebb ).PdfObject ,_ddag +1);case *PdfObjectArray :for _cddc ,_eeae :=range (*_eebb )._ageac {(*_eebb )._ageac [_cddc ]=_fbcaf (_eeae ,_ddag +1);};case *PdfObjectDictionary :for _bece ,_agfcaa :=range (*_eebb )._eedfb {(*_eebb )._eedfb [_bece ]=_fbcaf (_agfcaa ,_ddag +1);};_cad .Slice ((*_eebb )._fddg ,func (_eadbgc ,_abba int )bool {return (*_eebb )._fddg [_eadbgc ]< (*_eebb )._fddg [_abba ]});};return _fcee ;};

// MakeEncodedString creates a PdfObjectString with encoded content, which can be either
// UTF-16BE or PDFDocEncoding depending on whether `utf16BE` is true or false respectively.
func MakeEncodedString (s string ,utf16BE bool )*PdfObjectString {if utf16BE {var _baage _gb .Buffer ;_baage .Write ([]byte {0xFE,0xFF});_baage .WriteString (_gc .StringToUTF16 (s ));return &PdfObjectString {_bebd :_baage .String (),_daag :true };};return &PdfObjectString {_bebd :string (_gc .StringToPDFDocEncoding (s )),_daag :false };};

// SetIfNotNil sets the dictionary's key -> val mapping entry -IF- val is not nil.
// Note that we take care to perform a type switch.  Otherwise if we would supply a nil value
// of another type, e.g. (PdfObjectArray*)(nil), then it would not be a PdfObject(nil) and thus
// would get set.
func (_fadg *PdfObjectDictionary )SetIfNotNil (key PdfObjectName ,val PdfObject ){if val !=nil {switch _gabc :=val .(type ){case *PdfObjectName :if _gabc !=nil {_fadg .Set (key ,val );};case *PdfObjectDictionary :if _gabc !=nil {_fadg .Set (key ,val );};case *PdfObjectStream :if _gabc !=nil {_fadg .Set (key ,val );};case *PdfObjectString :if _gabc !=nil {_fadg .Set (key ,val );};case *PdfObjectNull :if _gabc !=nil {_fadg .Set (key ,val );};case *PdfObjectInteger :if _gabc !=nil {_fadg .Set (key ,val );};case *PdfObjectArray :if _gabc !=nil {_fadg .Set (key ,val );};case *PdfObjectBool :if _gabc !=nil {_fadg .Set (key ,val );};case *PdfObjectFloat :if _gabc !=nil {_fadg .Set (key ,val );};case *PdfObjectReference :if _gabc !=nil {_fadg .Set (key ,val );};case *PdfIndirectObject :if _gabc !=nil {_fadg .Set (key ,val );};default:_fcb .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",val );};};};var _bcfa =_cd .MustCompile ("\u0028\u005c\u0064\u002b)\\\u0073\u002b\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u006f\u0062\u006a");

// WriteString outputs the object as it is to be written to file.
func (_cfecc *PdfObjectFloat )WriteString ()string {return _e .FormatFloat (float64 (*_cfecc ),'f',-1,64);};

// PdfVersion returns version of the PDF file.
func (_gbfc *PdfParser )PdfVersion ()Version {return _gbfc ._cbgad };

// IsWhiteSpace checks if byte represents a white space character.
func IsWhiteSpace (ch byte )bool {if (ch ==0x00)||(ch ==0x09)||(ch ==0x0A)||(ch ==0x0C)||(ch ==0x0D)||(ch ==0x20){return true ;};return false ;};

// NewASCII85Encoder makes a new ASCII85 encoder.
func NewASCII85Encoder ()*ASCII85Encoder {_eggb :=&ASCII85Encoder {};return _eggb };func _cafb (_fec _bed .Image )*JBIG2Image {_eeeb :=_fec .Base ();return &JBIG2Image {Data :_eeeb .Data ,Width :_eeeb .Width ,Height :_eeeb .Height ,HasPadding :true };};

// MakeIndirectObject creates an PdfIndirectObject with a specified direct object PdfObject.
func MakeIndirectObject (obj PdfObject )*PdfIndirectObject {_cbce :=&PdfIndirectObject {};_cbce .PdfObject =obj ;return _cbce ;};func (_aceg *PdfParser )skipSpaces ()(int ,error ){_affe :=0;for {_cdab ,_afbe :=_aceg ._aggcb .ReadByte ();if _afbe !=nil {return 0,_afbe ;};if IsWhiteSpace (_cdab ){_affe ++;}else {_aceg ._aggcb .UnreadByte ();break ;};};return _affe ,nil ;};

// ReadAtLeast reads at least n bytes into slice p.
// Returns the number of bytes read (should always be == n), and an error on failure.
func (_gbdf *PdfParser )ReadAtLeast (p []byte ,n int )(int ,error ){_ffee :=n ;_geag :=0;_egee :=0;for _ffee > 0{_dbeg ,_aeda :=_gbdf ._aggcb .Read (p [_geag :]);if _aeda !=nil {_fcb .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061d\u0069\u006e\u0067\u0020\u0028\u0025\u0064\u003b\u0025\u0064\u0029\u0020\u0025\u0073",_dbeg ,_egee ,_aeda .Error ());return _geag ,_ca .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065a\u0064\u0069\u006e\u0067");};_egee ++;_geag +=_dbeg ;_ffee -=_dbeg ;};return _geag ,nil ;};

// WriteString outputs the object as it is to be written to file.
func (_abfc *PdfObjectName )WriteString ()string {var _eabe _gb .Buffer ;if len (*_abfc )> 127{_fcb .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u004e\u0061\u006d\u0065\u0020t\u006fo\u0020l\u006f\u006e\u0067\u0020\u0028\u0025\u0073)",*_abfc );};_eabe .WriteString ("\u002f");for _cbfc :=0;_cbfc < len (*_abfc );_cbfc ++{_ffcg :=(*_abfc )[_cbfc ];if !IsPrintable (_ffcg )||_ffcg =='#'||IsDelimiter (_ffcg ){_eabe .WriteString (_f .Sprintf ("\u0023\u0025\u002e2\u0078",_ffcg ));}else {_eabe .WriteByte (_ffcg );};};return _eabe .String ();};

// MakeObjectStreams creates an PdfObjectStreams from a list of PdfObjects.
func MakeObjectStreams (objects ...PdfObject )*PdfObjectStreams {_fgef :=&PdfObjectStreams {};_fgef ._cdaag =[]PdfObject {};for _ ,_ggba :=range objects {_fgef ._cdaag =append (_fgef ._cdaag ,_ggba );};return _fgef ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set.  Some other parameters are generated elsewhere.
func (_gfa *DCTEncoder )MakeStreamDict ()*PdfObjectDictionary {_edfe :=MakeDict ();_edfe .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_gfa .GetFilterName ()));return _edfe ;};

// GetFilterArray returns the names of the underlying encoding filters in an array that
// can be used as /Filter entry.
func (_ageg *MultiEncoder )GetFilterArray ()*PdfObjectArray {_aeb :=make ([]PdfObject ,len (_ageg ._caab ));for _dffc ,_afb :=range _ageg ._caab {_aeb [_dffc ]=MakeName (_afb .GetFilterName ());};return MakeArray (_aeb ...);};

// GetInt returns the *PdfObjectBool object that is represented by a PdfObject either directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetInt (obj PdfObject )(_deed *PdfObjectInteger ,_abdf bool ){_deed ,_abdf =TraceToDirectObject (obj ).(*PdfObjectInteger );return _deed ,_abdf ;};

// DecodeBytes decodes a slice of Flate encoded bytes and returns the result.
func (_dcb *FlateEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_fcb .Log .Trace ("\u0046\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065\u0020b\u0079\u0074\u0065\u0073");if len (encoded )==0{_fcb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0046\u006c\u0061\u0074\u0065 e\u006ec\u006f\u0064\u0065\u0064\u0020\u0062\u0075\u0066\u0066\u0065\u0072\u002e \u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0062y\u0074\u0065\u0020\u0073\u006c\u0069\u0063\u0065\u002e");return []byte {},nil ;};_fcd :=_gb .NewReader (encoded );_bae ,_bega :=_ae .NewReader (_fcd );if _bega !=nil {_fcb .Log .Debug ("\u0044e\u0063o\u0064\u0069\u006e\u0067\u0020e\u0072\u0072o\u0072\u0020\u0025\u0076\u000a",_bega );_fcb .Log .Debug ("\u0053t\u0072e\u0061\u006d\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (encoded ),encoded );return nil ,_bega ;};defer _bae .Close ();var _fgab _gb .Buffer ;_fgab .ReadFrom (_bae );return _fgab .Bytes (),nil ;};

// GetName returns the *PdfObjectName represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetName (obj PdfObject )(_dfcgf *PdfObjectName ,_ceca bool ){_dfcgf ,_ceca =TraceToDirectObject (obj ).(*PdfObjectName );return _dfcgf ,_ceca ;};

// NewJPXEncoder returns a new instance of JPXEncoder.
func NewJPXEncoder ()*JPXEncoder {return &JPXEncoder {}};

// GetBool returns the *PdfObjectBool object that is represented by a PdfObject directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetBool (obj PdfObject )(_efbdc *PdfObjectBool ,_aegc bool ){_efbdc ,_aegc =TraceToDirectObject (obj ).(*PdfObjectBool );return _efbdc ,_aegc ;};func (_cbdb *PdfParser )parseXrefStream (_fbda *PdfObjectInteger )(*PdfObjectDictionary ,error ){if _fbda !=nil {_fcb .Log .Trace ("\u0058\u0052\u0065f\u0053\u0074\u006d\u0020x\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0061\u0074\u0020\u0025\u0064",_fbda );_cbdb ._dgcfc .Seek (int64 (*_fbda ),_ce .SeekStart );_cbdb ._aggcb =_fc .NewReader (_cbdb ._dgcfc );};_gggef :=_cbdb .GetFileOffset ();_gacb ,_bbada :=_cbdb .ParseIndirectObject ();if _bbada !=nil {_fcb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072\u0065\u0061d\u0020\u0078\u0072\u0065\u0066\u0020\u006fb\u006a\u0065\u0063\u0074");return nil ,_ca .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072e\u0061\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062j\u0065\u0063\u0074");};_fcb .Log .Trace ("\u0058R\u0065f\u0053\u0074\u006d\u0020\u006fb\u006a\u0065c\u0074\u003a\u0020\u0025\u0073",_gacb );_dadf ,_feba :=_gacb .(*PdfObjectStream );if !_feba {_fcb .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0058R\u0065\u0066\u0053\u0074\u006d\u0020\u0070o\u0069\u006e\u0074\u0069\u006e\u0067 \u0074\u006f\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065a\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0021");return nil ,_ca .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0070\u006f\u0069\u006e\u0074i\u006e\u0067\u0020\u0074\u006f\u0020a\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006fb\u006a\u0065\u0063\u0074");};_cagc :=_dadf .PdfObjectDictionary ;_gacf ,_feba :=_dadf .PdfObjectDictionary .Get ("\u0053\u0069\u007a\u0065").(*PdfObjectInteger );if !_feba {_fcb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u004d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0073\u0069\u007a\u0065\u0020f\u0072\u006f\u006d\u0020\u0078\u0072\u0065f\u0020\u0073\u0074\u006d");return nil ,_ca .New ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0053\u0069\u007ae\u0020\u0066\u0072\u006f\u006d\u0020\u0078\u0072\u0065\u0066 \u0073\u0074\u006d");};if int64 (*_gacf )> 8388607{_fcb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u0053\u0069\u007a\u0065\u0020\u0065x\u0063\u0065\u0065\u0064\u0065\u0064\u0020l\u0069\u006d\u0069\u0074\u002c\u0020\u006f\u0076\u0065\u0072\u00208\u0033\u0038\u0038\u0036\u0030\u0037\u0020\u0028\u0025\u0064\u0029",*_gacf );return nil ,_ca .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_ddeb :=_dadf .PdfObjectDictionary .Get ("\u0057");_gcdd ,_feba :=_ddeb .(*PdfObjectArray );if !_feba {return nil ,_ca .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0057\u0020\u0069\u006e\u0020x\u0072\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d");};_eddd :=_gcdd .Len ();if _eddd !=3{_fcb .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020\u0028\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033\u0020\u002d\u0020\u0025\u0064\u0029",_eddd );return nil ,_ca .New ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065f\u0020s\u0074\u006d\u0020\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033");};var _cdbcf []int64 ;for _fbeee :=0;_fbeee < 3;_fbeee ++{_efbe ,_ffgf :=GetInt (_gcdd .Get (_fbeee ));if !_ffgf {return nil ,_ca .New ("i\u006e\u0076\u0061\u006cid\u0020w\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0074\u0079\u0070\u0065");};_cdbcf =append (_cdbcf ,int64 (*_efbe ));};_cbec ,_bbada :=DecodeStream (_dadf );if _bbada !=nil {_fcb .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020t\u006f \u0064e\u0063o\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u003a\u0020\u0025\u0076",_bbada );return nil ,_bbada ;};_efae :=int (_cdbcf [0]);_ccgg :=int (_cdbcf [0]+_cdbcf [1]);_dece :=int (_cdbcf [0]+_cdbcf [1]+_cdbcf [2]);_cegf :=int (_cdbcf [0]+_cdbcf [1]+_cdbcf [2]);if _efae < 0||_ccgg < 0||_dece < 0{_fcb .Log .Debug ("\u0045\u0072\u0072\u006fr\u0020\u0073\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u003c \u0030 \u0028\u0025\u0064\u002c\u0025\u0064\u002c%\u0064\u0029",_efae ,_ccgg ,_dece );return nil ,_ca .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};if _cegf ==0{_fcb .Log .Debug ("\u004e\u006f\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063t\u0073\u0020\u0069\u006e\u0020\u0073t\u0072\u0065\u0061\u006d\u0020\u0028\u0064\u0065\u006c\u0074\u0061\u0062\u0020=\u003d\u0020\u0030\u0029");return _cagc ,nil ;};_cebc :=len (_cbec )/_cegf ;_eadbgg :=0;_gacbd :=_dadf .PdfObjectDictionary .Get ("\u0049\u006e\u0064e\u0078");var _gbe []int ;if _gacbd !=nil {_fcb .Log .Trace ("\u0049n\u0064\u0065\u0078\u003a\u0020\u0025b",_gacbd );_ecbe ,_agfca :=_gacbd .(*PdfObjectArray );if !_agfca {_fcb .Log .Debug ("\u0049\u006e\u0076\u0061\u006ci\u0064\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0029");return nil ,_ca .New ("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0049\u006e\u0064e\u0078\u0020\u006f\u0062je\u0063\u0074");};if _ecbe .Len ()%2!=0{_fcb .Log .Debug ("\u0057\u0041\u0052\u004eI\u004e\u0047\u0020\u0046\u0061\u0069\u006c\u0075\u0072e\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020i\u006e\u0064\u0065\u0078\u0020n\u006f\u0074\u0020\u006d\u0075\u006c\u0074\u0069\u0070\u006c\u0065\u0020\u006f\u0066\u0020\u0032\u002e");return nil ,_ca .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_eadbgg =0;_effga ,_debce :=_ecbe .ToIntegerArray ();if _debce !=nil {_fcb .Log .Debug ("\u0045\u0072\u0072\u006f\u0072 \u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0065\u0078 \u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0073\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0073\u003a\u0020\u0025\u0076",_debce );return nil ,_debce ;};for _gdec :=0;_gdec < len (_effga );_gdec +=2{_effe :=_effga [_gdec ];_bbdga :=_effga [_gdec +1];for _gfdg :=0;_gfdg < _bbdga ;_gfdg ++{_gbe =append (_gbe ,_effe +_gfdg );};_eadbgg +=_bbdga ;};}else {for _beec :=0;_beec < int (*_gacf );_beec ++{_gbe =append (_gbe ,_beec );};_eadbgg =int (*_gacf );};if _cebc ==_eadbgg +1{_fcb .Log .Debug ("\u0049n\u0063\u006f\u006d\u0070ati\u0062\u0069\u006c\u0069t\u0079\u003a\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006di\u0073\u0073\u0069\u006e\u0067\u0020\u0063\u006f\u0076\u0065\u0072\u0061\u0067\u0065\u0020\u006f\u0066\u0020\u0031\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u002d\u0020\u0061\u0070\u0070en\u0064\u0069\u006eg\u0020\u006f\u006e\u0065\u0020-\u0020M\u0061\u0079\u0020\u006c\u0065\u0061\u0064\u0020\u0074o\u0020\u0070\u0072\u006f\u0062\u006c\u0065\u006d\u0073");_accb :=_eadbgg -1;for _ ,_ageb :=range _gbe {if _ageb > _accb {_accb =_ageb ;};};_gbe =append (_gbe ,_accb +1);_eadbgg ++;};if _cebc !=len (_gbe ){_fcb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020x\u0072\u0065\u0066 \u0073\u0074\u006d:\u0020\u006eu\u006d\u0020\u0065\u006e\u0074\u0072i\u0065s \u0021\u003d\u0020\u006c\u0065\u006e\u0028\u0069\u006e\u0064\u0069\u0063\u0065\u0073\u0029\u0020\u0028\u0025\u0064\u0020\u0021\u003d\u0020\u0025\u0064\u0029",_cebc ,len (_gbe ));return nil ,_ca .New ("\u0078\u0072ef\u0020\u0073\u0074m\u0020\u006e\u0075\u006d en\u0074ri\u0065\u0073\u0020\u0021\u003d\u0020\u006cen\u0028\u0069\u006e\u0064\u0069\u0063\u0065s\u0029");};_fcb .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074s\u0020\u0063\u006f\u0075\u006e\u0074\u0020\u0025\u0064",_eadbgg );_fcb .Log .Trace ("\u0049\u006e\u0064i\u0063\u0065\u0073\u003a\u0020\u0025\u0020\u0064",_gbe );_badb :=func (_ceaf []byte )int64 {var _cgaee int64 ;for _cgfb :=0;_cgfb < len (_ceaf );_cgfb ++{_cgaee +=int64 (_ceaf [_cgfb ])*(1<<uint (8*(len (_ceaf )-_cgfb -1)));};return _cgaee ;};_fcb .Log .Trace ("\u0044e\u0063\u006f\u0064\u0065d\u0020\u0073\u0074\u0072\u0065a\u006d \u006ce\u006e\u0067\u0074\u0068\u003a\u0020\u0025d",len (_cbec ));_cedfg :=0;for _fbcd :=0;_fbcd < len (_cbec );_fbcd +=_cegf {_eebe :=_geddb (len (_cbec ),_fbcd ,_fbcd +_efae );if _eebe !=nil {_fcb .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_eebe );return nil ,_eebe ;};_daef :=_cbec [_fbcd :_fbcd +_efae ];_eebe =_geddb (len (_cbec ),_fbcd +_efae ,_fbcd +_ccgg );if _eebe !=nil {_fcb .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_eebe );return nil ,_eebe ;};_fagg :=_cbec [_fbcd +_efae :_fbcd +_ccgg ];_eebe =_geddb (len (_cbec ),_fbcd +_ccgg ,_fbcd +_dece );if _eebe !=nil {_fcb .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_eebe );return nil ,_eebe ;};_dbaf :=_cbec [_fbcd +_ccgg :_fbcd +_dece ];_agea :=_badb (_daef );_ecfbc :=_badb (_fagg );_cbca :=_badb (_dbaf );if _cdbcf [0]==0{_agea =1;};if _cedfg >=len (_gbe ){_fcb .Log .Debug ("X\u0052\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u002d\u0020\u0054\u0072\u0079\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0061\u0063\u0063e\u0073s\u0020\u0069\u006e\u0064e\u0078\u0020o\u0075\u0074\u0020\u006f\u0066\u0020\u0062\u006f\u0075\u006e\u0064\u0073\u0020\u002d\u0020\u0062\u0072\u0065\u0061\u006b\u0069\u006e\u0067");break ;};_abbd :=_gbe [_cedfg ];_cedfg ++;_fcb .Log .Trace ("%\u0064\u002e\u0020\u0070\u0031\u003a\u0020\u0025\u0020\u0078",_abbd ,_daef );_fcb .Log .Trace ("%\u0064\u002e\u0020\u0070\u0032\u003a\u0020\u0025\u0020\u0078",_abbd ,_fagg );_fcb .Log .Trace ("%\u0064\u002e\u0020\u0070\u0033\u003a\u0020\u0025\u0020\u0078",_abbd ,_dbaf );_fcb .Log .Trace ("\u0025d\u002e \u0078\u0072\u0065\u0066\u003a \u0025\u0064 \u0025\u0064\u0020\u0025\u0064",_abbd ,_agea ,_ecfbc ,_cbca );if _agea ==0{_fcb .Log .Trace ("-\u0020\u0046\u0072\u0065\u0065\u0020o\u0062\u006a\u0065\u0063\u0074\u0020-\u0020\u0063\u0061\u006e\u0020\u0070\u0072o\u0062\u0061\u0062\u006c\u0079\u0020\u0069\u0067\u006e\u006fr\u0065");}else if _agea ==1{_fcb .Log .Trace ("\u002d\u0020I\u006e\u0020\u0075\u0073e\u0020\u002d \u0075\u006e\u0063\u006f\u006d\u0070\u0072\u0065s\u0073\u0065\u0064\u0020\u0076\u0069\u0061\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0062",_fagg );if _ecfbc ==_gggef {_fcb .Log .Debug ("\u0055\u0070d\u0061\u0074\u0069\u006e\u0067\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0058\u0052\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0064",_abbd ,_dadf .ObjectNumber );_abbd =int (_dadf .ObjectNumber );};if _efdg ,_accc :=_cbdb ._gaeec .ObjectMap [_abbd ];!_accc ||int (_cbca )> _efdg .Generation {_bfed :=XrefObject {ObjectNumber :_abbd ,XType :XrefTypeTableEntry ,Offset :_ecfbc ,Generation :int (_cbca )};_cbdb ._gaeec .ObjectMap [_abbd ]=_bfed ;};}else if _agea ==2{_fcb .Log .Trace ("\u002d\u0020\u0049\u006e \u0075\u0073\u0065\u0020\u002d\u0020\u0063\u006f\u006d\u0070r\u0065s\u0073\u0065\u0064\u0020\u006f\u0062\u006ae\u0063\u0074");if _ ,_fdbg :=_cbdb ._gaeec .ObjectMap [_abbd ];!_fdbg {_bddf :=XrefObject {ObjectNumber :_abbd ,XType :XrefTypeObjectStream ,OsObjNumber :int (_ecfbc ),OsObjIndex :int (_cbca )};_cbdb ._gaeec .ObjectMap [_abbd ]=_bddf ;_fcb .Log .Trace ("\u0065\u006e\u0074\u0072\u0079\u003a\u0020\u0025\u002b\u0076",_bddf );};}else {_fcb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052:\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0056\u0041L\u0049\u0044\u0020\u0054\u0059\u0050\u0045\u0020\u0058\u0072\u0065\u0066\u0053\u0074\u006d\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u003f\u002d\u002d\u002d\u002d\u002d\u002d-");continue ;};};if _cbdb ._cffe ==nil {_ecgg :=XrefTypeObjectStream ;_cbdb ._cffe =&_ecgg ;};return _cagc ,nil ;};

// ParseDict reads and parses a PDF dictionary object enclosed with '<<' and '>>'
func (_cafbc *PdfParser )ParseDict ()(*PdfObjectDictionary ,error ){_fcb .Log .Trace ("\u0052\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020D\u0069\u0063\u0074\u0021");_bgcc :=MakeDict ();_bgcc ._cbbe =_cafbc ;_bcad ,_ :=_cafbc ._aggcb .ReadByte ();if _bcad !='<'{return nil ,_ca .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");};_bcad ,_ =_cafbc ._aggcb .ReadByte ();if _bcad !='<'{return nil ,_ca .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");};for {_cafbc .skipSpaces ();_cafbc .skipComments ();_caebd ,_eedf :=_cafbc ._aggcb .Peek (2);if _eedf !=nil {return nil ,_eedf ;};_fcb .Log .Trace ("D\u0069c\u0074\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_caebd ),string (_caebd ));if (_caebd [0]=='>')&&(_caebd [1]=='>'){_fcb .Log .Trace ("\u0045\u004f\u0046\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");_cafbc ._aggcb .ReadByte ();_cafbc ._aggcb .ReadByte ();break ;};_fcb .Log .Trace ("\u0050a\u0072s\u0065\u0020\u0074\u0068\u0065\u0020\u006e\u0061\u006d\u0065\u0021");_ccbe ,_eedf :=_cafbc .parseName ();_fcb .Log .Trace ("\u004be\u0079\u003a\u0020\u0025\u0073",_ccbe );if _eedf !=nil {_fcb .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0052e\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006ea\u006d\u0065\u0020e\u0072r\u0020\u0025\u0073",_eedf );return nil ,_eedf ;};if len (_ccbe )> 4&&_ccbe [len (_ccbe )-4:]=="\u006e\u0075\u006c\u006c"{_eabg :=_ccbe [0:len (_ccbe )-4];_fcb .Log .Debug ("\u0054\u0061\u006b\u0069n\u0067\u0020\u0063\u0061\u0072\u0065\u0020\u006f\u0066\u0020n\u0075l\u006c\u0020\u0062\u0075\u0067\u0020\u0028%\u0073\u0029",_ccbe );_fcb .Log .Debug ("\u004e\u0065\u0077\u0020ke\u0079\u0020\u0022\u0025\u0073\u0022\u0020\u003d\u0020\u006e\u0075\u006c\u006c",_eabg );_cafbc .skipSpaces ();_gafb ,_ :=_cafbc ._aggcb .Peek (1);if _gafb [0]=='/'{_bgcc .Set (_eabg ,MakeNull ());continue ;};};_cafbc .skipSpaces ();_ebdc ,_eedf :=_cafbc .parseObject ();if _eedf !=nil {return nil ,_eedf ;};_bgcc .Set (_ccbe ,_ebdc );if _fcb .Log .IsLogLevel (_fcb .LogLevelTrace ){_fcb .Log .Trace ("\u0064\u0069\u0063\u0074\u005b\u0025\u0073\u005d\u0020\u003d\u0020\u0025\u0073",_ccbe ,_ebdc .String ());};};_fcb .Log .Trace ("\u0072\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020\u0044\u0069\u0063\u0074\u0021");return _bgcc ,nil ;};

// GetObjectNums returns a sorted list of object numbers of the PDF objects in the file.
func (_fddgg *PdfParser )GetObjectNums ()[]int {var _face []int ;for _ ,_afbcd :=range _fddgg ._gaeec .ObjectMap {_face =append (_face ,_afbcd .ObjectNumber );};_cad .Ints (_face );return _face ;};

// NewLZWEncoder makes a new LZW encoder with default parameters.
func NewLZWEncoder ()*LZWEncoder {_eefb :=&LZWEncoder {};_eefb .Predictor =1;_eefb .BitsPerComponent =8;_eefb .Colors =1;_eefb .Columns =1;_eefb .EarlyChange =1;return _eefb ;};

// NewEncoderFromStream creates a StreamEncoder based on the stream's dictionary.
func NewEncoderFromStream (streamObj *PdfObjectStream )(StreamEncoder ,error ){_bcac :=TraceToDirectObject (streamObj .PdfObjectDictionary .Get ("\u0046\u0069\u006c\u0074\u0065\u0072"));if _bcac ==nil {return NewRawEncoder (),nil ;};if _ ,_dfbb :=_bcac .(*PdfObjectNull );_dfbb {return NewRawEncoder (),nil ;};_bagee ,_gdde :=_bcac .(*PdfObjectName );if !_gdde {_dbbb ,_eaeed :=_bcac .(*PdfObjectArray );if !_eaeed {return nil ,_f .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006f\u0072 \u0041\u0072\u0072\u0061\u0079\u0020\u006fb\u006a\u0065\u0063\u0074");};if _dbbb .Len ()==0{return NewRawEncoder (),nil ;};if _dbbb .Len ()!=1{_eacg ,_dfdec :=_gbg (streamObj );if _dfdec !=nil {_fcb .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0063\u0072\u0065\u0061\u0074\u0069\u006e\u0067\u0020\u006d\u0075\u006c\u0074i\u0020\u0065\u006e\u0063\u006f\u0064\u0065r\u003a\u0020\u0025\u0076",_dfdec );return nil ,_dfdec ;};_fcb .Log .Trace ("\u004d\u0075\u006c\u0074\u0069\u0020\u0065\u006e\u0063:\u0020\u0025\u0073\u000a",_eacg );return _eacg ,nil ;};_bcac =_dbbb .Get (0);_bagee ,_eaeed =_bcac .(*PdfObjectName );if !_eaeed {return nil ,_f .Errorf ("\u0066\u0069l\u0074\u0065\u0072\u0020a\u0072\u0072a\u0079\u0020\u006d\u0065\u006d\u0062\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006fb\u006a\u0065\u0063\u0074");};};switch *_bagee {case StreamEncodingFilterNameFlate :return _cgf (streamObj ,nil );case StreamEncodingFilterNameLZW :return _aded (streamObj ,nil );case StreamEncodingFilterNameDCT :return _ddaa (streamObj ,nil );case StreamEncodingFilterNameRunLength :return _fcgg (streamObj ,nil );case StreamEncodingFilterNameASCIIHex :return NewASCIIHexEncoder (),nil ;case StreamEncodingFilterNameASCII85 ,"\u0041\u0038\u0035":return NewASCII85Encoder (),nil ;case StreamEncodingFilterNameCCITTFax :return _gecea (streamObj ,nil );case StreamEncodingFilterNameJBIG2 :return _dffa (streamObj ,nil );case StreamEncodingFilterNameJPX :return NewJPXEncoder (),nil ;};_fcb .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064\u0069\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006fd\u0021");return nil ,_f .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064i\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006f\u0064\u0020\u0028\u0025\u0073\u0029",*_bagee );};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_aab *DCTEncoder )MakeDecodeParams ()PdfObject {return nil };

// ResolveReference resolves reference if `o` is a *PdfObjectReference and returns the object referenced to.
// Otherwise returns back `o`.
func ResolveReference (obj PdfObject )PdfObject {if _cbaa ,_cfee :=obj .(*PdfObjectReference );_cfee {return _cbaa .Resolve ();};return obj ;};

// ToFloat64Array returns a slice of all elements in the array as a float64 slice.  An error is
// returned if the array contains non-numeric objects (each element can be either PdfObjectInteger
// or PdfObjectFloat).
func (_adbe *PdfObjectArray )ToFloat64Array ()([]float64 ,error ){var _gcffb []float64 ;for _ ,_dcecf :=range _adbe .Elements (){switch _accg :=_dcecf .(type ){case *PdfObjectInteger :_gcffb =append (_gcffb ,float64 (*_accg ));case *PdfObjectFloat :_gcffb =append (_gcffb ,float64 (*_accg ));default:return nil ,ErrTypeError ;};};return _gcffb ,nil ;};

// DecodeStream decodes a FlateEncoded stream object and give back decoded bytes.
func (_efgg *FlateEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_fcb .Log .Trace ("\u0046l\u0061t\u0065\u0044\u0065\u0063\u006fd\u0065\u0020s\u0074\u0072\u0065\u0061\u006d");_fcb .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_efgg .Predictor );if _efgg .BitsPerComponent !=8{return nil ,_f .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003d\u0025\u0064\u0020\u0028\u006f\u006e\u006c\u0079\u0020\u0038\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0029",_efgg .BitsPerComponent );};_beab ,_gedf :=_efgg .DecodeBytes (streamObj .Stream );if _gedf !=nil {return nil ,_gedf ;};_beab ,_gedf =_efgg .postDecodePredict (_beab );if _gedf !=nil {return nil ,_gedf ;};return _efgg .cleanImageData (_beab );};

// GetFileOffset returns the current file offset, accounting for buffered position.
func (_eggea *PdfParser )GetFileOffset ()int64 {_bgda ,_ :=_eggea ._dgcfc .Seek (0,_ce .SeekCurrent );_bgda -=int64 (_eggea ._aggcb .Buffered ());return _bgda ;};

// DecodeBytes decodes the CCITTFax encoded image data.
func (_egcd *CCITTFaxEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_gdga :=&_de .Encoder {K :_egcd .K ,Columns :_egcd .Columns ,EndOfLine :_egcd .EndOfLine ,EndOfBlock :_egcd .EndOfBlock ,BlackIs1 :_egcd .BlackIs1 ,DamagedRowsBeforeError :_egcd .DamagedRowsBeforeError ,Rows :_egcd .Rows ,EncodedByteAlign :_egcd .EncodedByteAlign };_egcg ,_eeefa :=_gdga .Decode (encoded );if _eeefa !=nil {return nil ,_eeefa ;};var _eegf []byte ;_bffg :=0;var _dgda byte ;var _fggd byte ;for _gfage :=range _egcg {if _dgda !=0{_eegf =append (_eegf ,_fggd );_fggd =0;_bffg ++;_dgda =0;};for _eaba :=range _egcg [_gfage ]{_fggd |=_egcg [_gfage ][_eaba ]<<(7-_dgda );_dgda ++;if _dgda ==8{_eegf =append (_eegf ,_fggd );_fggd =0;_bffg ++;_dgda =0;};};};if _dgda > 0{_eegf =append (_eegf ,_fggd );};return _eegf ,nil ;};const _bcfbg =10;

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_aedbe *FlateEncoder )MakeDecodeParams ()PdfObject {if _aedbe .Predictor > 1{_bdb :=MakeDict ();_bdb .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_aedbe .Predictor )));if _aedbe .BitsPerComponent !=8{_bdb .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_aedbe .BitsPerComponent )));};if _aedbe .Columns !=1{_bdb .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_aedbe .Columns )));};if _aedbe .Colors !=1{_bdb .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_aedbe .Colors )));};return _bdb ;};return nil ;};

// DecodeStream decodes a LZW encoded stream and returns the result as a
// slice of bytes.
func (_cef *LZWEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_fcb .Log .Trace ("\u004c\u005a\u0057 \u0044\u0065\u0063\u006f\u0064\u0069\u006e\u0067");_fcb .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_cef .Predictor );_bbf ,_ece :=_cef .DecodeBytes (streamObj .Stream );if _ece !=nil {return nil ,_ece ;};_fcb .Log .Trace ("\u0020\u0049\u004e\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (streamObj .Stream ),streamObj .Stream );_fcb .Log .Trace ("\u004f\u0055\u0054\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (_bbf ),_bbf );if _cef .Predictor > 1{if _cef .Predictor ==2{_fcb .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_ccga :=int (_cef .Columns )*_cef .Colors ;if _ccga < 1{return []byte {},nil ;};_gffa :=len (_bbf )/_ccga ;if len (_bbf )%_ccga !=0{_fcb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");return nil ,_f .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_bbf ),_ccga );};if _ccga %_cef .Colors !=0{return nil ,_f .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_ccga ,_cef .Colors );};if _ccga > len (_bbf ){_fcb .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_ccga ,len (_bbf ));return nil ,_ca .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_fcb .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_bbf ),_bbf );_fcff :=_gb .NewBuffer (nil );for _bad :=0;_bad < _gffa ;_bad ++{_gece :=_bbf [_ccga *_bad :_ccga *(_bad +1)];for _fcde :=_cef .Colors ;_fcde < _ccga ;_fcde ++{_gece [_fcde ]=byte (int (_gece [_fcde ]+_gece [_fcde -_cef .Colors ])%256);};_fcff .Write (_gece );};_agf :=_fcff .Bytes ();_fcb .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_agf ),_agf );return _agf ,nil ;}else if _cef .Predictor >=10&&_cef .Predictor <=15{_fcb .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_cbe :=int (_cef .Columns *_cef .Colors +1);if _cbe < 1{return []byte {},nil ;};_cdcdd :=len (_bbf )/_cbe ;if len (_bbf )%_cbe !=0{return nil ,_f .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_bbf ),_cbe );};if _cbe > len (_bbf ){_fcb .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_cbe ,len (_bbf ));return nil ,_ca .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_bfdbe :=_gb .NewBuffer (nil );_fcb .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_cef .Columns );_fcb .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_bbf ),_cbe ,_cdcdd );_gdb :=make ([]byte ,_cbe );for _edaf :=0;_edaf < _cbe ;_edaf ++{_gdb [_edaf ]=0;};for _eddf :=0;_eddf < _cdcdd ;_eddf ++{_efce :=_bbf [_cbe *_eddf :_cbe *(_eddf +1)];_dbbg :=_efce [0];switch _dbbg {case 0:case 1:for _eaeeg :=2;_eaeeg < _cbe ;_eaeeg ++{_efce [_eaeeg ]=byte (int (_efce [_eaeeg ]+_efce [_eaeeg -1])%256);};case 2:for _edda :=1;_edda < _cbe ;_edda ++{_efce [_edda ]=byte (int (_efce [_edda ]+_gdb [_edda ])%256);};default:_fcb .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0066i\u006c\u0074\u0065\u0072\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_dbbg );return nil ,_f .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_dbbg );};for _fcea :=0;_fcea < _cbe ;_fcea ++{_gdb [_fcea ]=_efce [_fcea ];};_bfdbe .Write (_efce [1:]);};_gbc :=_bfdbe .Bytes ();return _gbc ,nil ;}else {_fcb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_cef .Predictor );return nil ,_f .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_cef .Predictor );};};return _bbf ,nil ;};func (_dbbgd *PdfObjectFloat )String ()string {return _f .Sprintf ("\u0025\u0066",*_dbbgd )};

// String returns the PDF version as a string. Implements interface fmt.Stringer.
func (_dcab Version )String ()string {return _f .Sprintf ("\u00250\u0064\u002e\u0025\u0030\u0064",_dcab .Major ,_dcab .Minor );};type objectStream struct{N int ;_ac []byte ;_fg map[int ]int64 ;};

// UpdateParams updates the parameter values of the encoder.
func (_fafed *LZWEncoder )UpdateParams (params *PdfObjectDictionary ){_ggdg ,_ebf :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _ebf ==nil {_fafed .Predictor =int (_ggdg );};_ceaa ,_ebf :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _ebf ==nil {_fafed .BitsPerComponent =int (_ceaa );};_bcbg ,_ebf :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _ebf ==nil {_fafed .Columns =int (_bcbg );};_gec ,_ebf :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _ebf ==nil {_fafed .Colors =int (_gec );};_cgbg ,_ebf :=GetNumberAsInt64 (params .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065"));if _ebf ==nil {_fafed .EarlyChange =int (_cgbg );};};func (_aefa *PdfParser )skipComments ()error {if _ ,_egga :=_aefa .skipSpaces ();_egga !=nil {return _egga ;};_cgceb :=true ;for {_cfag ,_gedb :=_aefa ._aggcb .Peek (1);if _gedb !=nil {_fcb .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_gedb .Error ());return _gedb ;};if _cgceb &&_cfag [0]!='%'{return nil ;};_cgceb =false ;if (_cfag [0]!='\r')&&(_cfag [0]!='\n'){_aefa ._aggcb .ReadByte ();}else {break ;};};return _aefa .skipComments ();};

// GetString is a helper for Get that returns a string value.
// Returns false if the key is missing or a value is not a string.
func (_gagag *PdfObjectDictionary )GetString (key PdfObjectName )(string ,bool ){_dgdde ,_gced :=_gagag ._eedfb [key ].(*PdfObjectString );if !_gced {return "",false ;};return _dgdde .Str (),true ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_accd *ASCIIHexEncoder )MakeStreamDict ()*PdfObjectDictionary {_cbfe :=MakeDict ();_cbfe .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_accd .GetFilterName ()));return _cbfe ;};

// Clear resets the dictionary to an empty state.
func (_fcec *PdfObjectDictionary )Clear (){_fcec ._fddg =[]PdfObjectName {};_fcec ._eedfb =map[PdfObjectName ]PdfObject {};};

// GetBoolVal returns the bool value within a *PdObjectBool represented by an PdfObject interface directly or indirectly.
// If the PdfObject does not represent a bool value, a default value of false is returned (found = false also).
func GetBoolVal (obj PdfObject )(_gbcf bool ,_abaa bool ){_cebf ,_abaa :=TraceToDirectObject (obj ).(*PdfObjectBool );if _abaa {return bool (*_cebf ),true ;};return false ,false ;};func _fba (_bga _gbb .Filter ,_gggd _ff .AuthEvent )*PdfObjectDictionary {if _gggd ==""{_gggd =_ff .EventDocOpen ;};_baag :=MakeDict ();_baag .Set ("\u0054\u0079\u0070\u0065",MakeName ("C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"));_baag .Set ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et",MakeName (string (_gggd )));_baag .Set ("\u0043\u0046\u004d",MakeName (_bga .Name ()));_baag .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_bga .KeyLength ())));return _baag ;};

// DecodeStream decodes a multi-encoded stream by passing it through the
// DecodeStream method of the underlying encoders.
func (_dddc *MultiEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _dddc .DecodeBytes (streamObj .Stream );};func _ebbdg (_egca string )(int ,int ,error ){_gadeg :=_bcfa .FindStringSubmatch (_egca );if len (_gadeg )< 3{return 0,0,_ca .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");};_afee ,_ :=_e .Atoi (_gadeg [1]);_debab ,_ :=_e .Atoi (_gadeg [2]);return _afee ,_debab ,nil ;};

// Elements returns a slice of the PdfObject elements in the array.
func (_befbe *PdfObjectArray )Elements ()[]PdfObject {if _befbe ==nil {return nil ;};return _befbe ._ageac ;};var _dgaf =_cd .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064+\u0029\u005c\u0073\u002b\u0028\u005b\u006e\u0066\u005d\u0029\\\u0073\u002a\u0024");

// Decrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_aced *PdfCrypt )Decrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _aced .isDecrypted (obj ){return nil ;};switch _aggc :=obj .(type ){case *PdfIndirectObject :_aced ._fgad [_aggc ]=true ;_fcb .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_aggc .ObjectNumber ,_aggc .GenerationNumber );_ebe :=_aggc .ObjectNumber ;_edg :=_aggc .GenerationNumber ;_ecb :=_aced .Decrypt (_aggc .PdfObject ,_ebe ,_edg );if _ecb !=nil {return _ecb ;};return nil ;case *PdfObjectStream :_aced ._fgad [_aggc ]=true ;_befg :=_aggc .PdfObjectDictionary ;if _aced ._bbd .R !=5{if _bbab ,_cccg :=_befg .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_cccg &&*_bbab =="\u0058\u0052\u0065\u0066"{return nil ;};};_fbb :=_aggc .ObjectNumber ;_cea :=_aggc .GenerationNumber ;_fcb .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_fbb ,_cea );_fdeab :=_agd ;if _aced ._bf .V >=4{_fdeab =_aced ._eag ;_fcb .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_aced ._eag );if _cccd ,_ffg :=_befg .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );_ffg {if _gef ,_gabd :=GetName (_cccd .Get (0));_gabd {if *_gef =="\u0043\u0072\u0079p\u0074"{_fdeab ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _bgg ,_cdg :=_befg .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );_cdg {if _ebec ,_eada :=_bgg .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_eada {if _ ,_caeb :=_aced ._fgf [string (*_ebec )];_caeb {_fcb .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_ebec );_fdeab =string (*_ebec );};};};};};};_fcb .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_fdeab );if _fdeab =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_ddb :=_aced .Decrypt (_befg ,_fbb ,_cea );if _ddb !=nil {return _ddb ;};_ggd ,_ddb :=_aced .makeKey (_fdeab ,uint32 (_fbb ),uint32 (_cea ),_aced ._efa );if _ddb !=nil {return _ddb ;};_aggc .Stream ,_ddb =_aced .decryptBytes (_aggc .Stream ,_fdeab ,_ggd );if _ddb !=nil {return _ddb ;};_befg .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_aggc .Stream ))));return nil ;case *PdfObjectString :_fcb .Log .Trace ("\u0044e\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_dcf :=_agd ;if _aced ._bf .V >=4{_fcb .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_aced ._bef );if _aced ._bef =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_dcf =_aced ._bef ;};_dbc ,_dedd :=_aced .makeKey (_dcf ,uint32 (parentObjNum ),uint32 (parentGenNum ),_aced ._efa );if _dedd !=nil {return _dedd ;};_fed :=_aggc .Str ();_bgf :=make ([]byte ,len (_fed ));for _dfb :=0;_dfb < len (_fed );_dfb ++{_bgf [_dfb ]=_fed [_dfb ];};_fcb .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_bgf ,_bgf );_bgf ,_dedd =_aced .decryptBytes (_bgf ,_dcf ,_dbc );if _dedd !=nil {return _dedd ;};_aggc ._bebd =string (_bgf );return nil ;case *PdfObjectArray :for _ ,_acec :=range _aggc .Elements (){_eba :=_aced .Decrypt (_acec ,parentObjNum ,parentGenNum );if _eba !=nil {return _eba ;};};return nil ;case *PdfObjectDictionary :_cgcd :=false ;if _aged :=_aggc .Get ("\u0054\u0079\u0070\u0065");_aged !=nil {_ggb ,_bafa :=_aged .(*PdfObjectName );if _bafa &&*_ggb =="\u0053\u0069\u0067"{_cgcd =true ;};};for _ ,_fged :=range _aggc .Keys (){_gafc :=_aggc .Get (_fged );if _cgcd &&string (_fged )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;};if string (_fged )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_fged )!="\u0050\u0072\u0065\u0076"&&string (_fged )!="\u004c\u0061\u0073\u0074"{_cfg :=_aced .Decrypt (_gafc ,parentObjNum ,parentGenNum );if _cfg !=nil {return _cfg ;};};};return nil ;};return nil ;};func (_edce *PdfParser )parseBool ()(PdfObjectBool ,error ){_cfebg ,_cfff :=_edce ._aggcb .Peek (4);if _cfff !=nil {return PdfObjectBool (false ),_cfff ;};if (len (_cfebg )>=4)&&(string (_cfebg [:4])=="\u0074\u0072\u0075\u0065"){_edce ._aggcb .Discard (4);return PdfObjectBool (true ),nil ;};_cfebg ,_cfff =_edce ._aggcb .Peek (5);if _cfff !=nil {return PdfObjectBool (false ),_cfff ;};if (len (_cfebg )>=5)&&(string (_cfebg [:5])=="\u0066\u0061\u006cs\u0065"){_edce ._aggcb .Discard (5);return PdfObjectBool (false ),nil ;};return PdfObjectBool (false ),_ca .New ("\u0075n\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0062o\u006fl\u0065a\u006e\u0020\u0073\u0074\u0072\u0069\u006eg");};func (_gdcg *FlateEncoder )postDecodePredict (_fgb []byte )([]byte ,error ){if _gdcg .Predictor > 1{if _gdcg .Predictor ==2{_fcb .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_fcb .Log .Trace ("\u0043\u006f\u006c\u006f\u0072\u0073\u003a\u0020\u0025\u0064",_gdcg .Colors );_bgaf :=int (_gdcg .Columns )*_gdcg .Colors ;if _bgaf < 1{return []byte {},nil ;};_fdcg :=len (_fgb )/_bgaf ;if len (_fgb )%_bgaf !=0{_fcb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");return nil ,_f .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_fgb ),_bgaf );};if _bgaf %_gdcg .Colors !=0{return nil ,_f .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_bgaf ,_gdcg .Colors );};if _bgaf > len (_fgb ){_fcb .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_bgaf ,len (_fgb ));return nil ,_ca .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_fcb .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_fgb ),_fgb );_eeb :=_gb .NewBuffer (nil );for _dgfg :=0;_dgfg < _fdcg ;_dgfg ++{_eda :=_fgb [_bgaf *_dgfg :_bgaf *(_dgfg +1)];for _cbcg :=_gdcg .Colors ;_cbcg < _bgaf ;_cbcg ++{_eda [_cbcg ]+=_eda [_cbcg -_gdcg .Colors ];};_eeb .Write (_eda );};_bagb :=_eeb .Bytes ();_fcb .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_bagb ),_bagb );return _bagb ,nil ;}else if _gdcg .Predictor >=10&&_gdcg .Predictor <=15{_fcb .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_caga :=int (_gdcg .Columns *_gdcg .Colors +1);_dace :=len (_fgb )/_caga ;if len (_fgb )%_caga !=0{return nil ,_f .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_fgb ),_caga );};if _caga > len (_fgb ){_fcb .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_caga ,len (_fgb ));return nil ,_ca .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_adbb :=_gb .NewBuffer (nil );_fcb .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_gdcg .Columns );_fcb .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_fgb ),_caga ,_dace );_bgfe :=make ([]byte ,_caga );for _edgb :=0;_edgb < _caga ;_edgb ++{_bgfe [_edgb ]=0;};_abcf :=_gdcg .Colors ;for _cfbgc :=0;_cfbgc < _dace ;_cfbgc ++{_aedg :=_fgb [_caga *_cfbgc :_caga *(_cfbgc +1)];_fgec :=_aedg [0];switch _fgec {case _aacc :case _agbf :for _fgc :=1+_abcf ;_fgc < _caga ;_fgc ++{_aedg [_fgc ]+=_aedg [_fgc -_abcf ];};case _eef :for _bdf :=1;_bdf < _caga ;_bdf ++{_aedg [_bdf ]+=_bgfe [_bdf ];};case _geg :for _ecfd :=1;_ecfd < _abcf +1;_ecfd ++{_aedg [_ecfd ]+=_bgfe [_ecfd ]/2;};for _acc :=_abcf +1;_acc < _caga ;_acc ++{_aedg [_acc ]+=byte ((int (_aedg [_acc -_abcf ])+int (_bgfe [_acc ]))/2);};case _fee :for _caec :=1;_caec < _caga ;_caec ++{var _gfeg ,_befb ,_gcf byte ;_befb =_bgfe [_caec ];if _caec >=_abcf +1{_gfeg =_aedg [_caec -_abcf ];_gcf =_bgfe [_caec -_abcf ];};_aedg [_caec ]+=_dgbc (_gfeg ,_befb ,_gcf );};default:_fcb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029\u0020\u0040\u0072o\u0077\u0020\u0025\u0064",_fgec ,_cfbgc );return nil ,_f .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_fgec );};copy (_bgfe ,_aedg );_adbb .Write (_aedg [1:]);};_dggd :=_adbb .Bytes ();return _dggd ,nil ;}else {_fcb .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_gdcg .Predictor );return nil ,_f .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_gdcg .Predictor );};};return _fgb ,nil ;};

// EncodeBytes encodes the image data using either Group3 or Group4 CCITT facsimile (fax) encoding.
// `data` is expected to be 1 color component, 1 byte per component.
func (_gcff *CCITTFaxEncoder )EncodeBytes (data []byte )([]byte ,error ){var _afgc [][]byte ;for _eebc :=0;_eebc < len (data );_eebc +=_gcff .Columns {_cgae :=make ([]byte ,_gcff .Columns );_bfbg :=0;for _ddba :=0;_ddba < _gcff .Columns ;_ddba ++{if data [_eebc +_ddba ]==255{_cgae [_bfbg ]=1;}else {_cgae [_bfbg ]=0;};_bfbg ++;};_afgc =append (_afgc ,_cgae );};_bbe :=&_de .Encoder {K :_gcff .K ,Columns :_gcff .Columns ,EndOfLine :_gcff .EndOfLine ,EndOfBlock :_gcff .EndOfBlock ,BlackIs1 :_gcff .BlackIs1 ,DamagedRowsBeforeError :_gcff .DamagedRowsBeforeError ,Rows :_gcff .Rows ,EncodedByteAlign :_gcff .EncodedByteAlign };return _bbe .Encode (_afgc ),nil ;};func (_cgcdd *PdfParser )seekPdfVersionTopDown ()(int ,int ,error ){_cgcdd ._dgcfc .Seek (0,_g .SEEK_SET );_cgcdd ._aggcb =_fc .NewReader (_cgcdd ._dgcfc );_dacea :=20;_bfagd :=make ([]byte ,_dacea );for {_abgf ,_bbac :=_cgcdd ._aggcb .ReadByte ();if _bbac !=nil {if _bbac ==_ce .EOF {break ;}else {return 0,0,_bbac ;};};if IsDecimalDigit (_abgf )&&_bfagd [_dacea -1]=='.'&&IsDecimalDigit (_bfagd [_dacea -2])&&_bfagd [_dacea -3]=='-'&&_bfagd [_dacea -4]=='F'&&_bfagd [_dacea -5]=='D'&&_bfagd [_dacea -6]=='P'{_eeaa :=int (_bfagd [_dacea -2]-'0');_gcb :=int (_abgf -'0');return _eeaa ,_gcb ,nil ;};_bfagd =append (_bfagd [1:_dacea ],_abgf );};return 0,0,_ca .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};

// GetNumbersAsFloat converts a list of pdf objects representing floats or integers to a slice of
// float64 values.
func GetNumbersAsFloat (objects []PdfObject )(_adfa []float64 ,_cged error ){for _ ,_aaede :=range objects {_aebg ,_abfd :=GetNumberAsFloat (_aaede );if _abfd !=nil {return nil ,_abfd ;};_adfa =append (_adfa ,_aebg );};return _adfa ,nil ;};

// MakeArrayFromIntegers64 creates an PdfObjectArray from a slice of int64s, where each array element
// is an PdfObjectInteger.
func MakeArrayFromIntegers64 (vals []int64 )*PdfObjectArray {_bbba :=MakeArray ();for _ ,_cacaa :=range vals {_bbba .Append (MakeInteger (_cacaa ));};return _bbba ;};

// GetXrefType returns the type of the first xref object (table or stream).
func (_ddff *PdfParser )GetXrefType ()*xrefType {return _ddff ._cffe };func (_gad *FlateEncoder )cleanImageData (_abgb []byte )([]byte ,error ){if _gad ._ebb ==nil {return _abgb ,nil ;};if _gad ._ebb .BitsPerComponent >=8{return _abgb ,nil ;};_fbc :=_gad ._ebb .BitsPerComponent *_gad ._ebb .Width *_gad ._ebb .ColorComponents *_gad ._ebb .Height /8;_abgb =_abgb [:_fbc ];var _cbcd error ;_abgb ,_cbcd =_bed .AddDataPadding (_gad ._ebb .Width ,_gad ._ebb .Height ,_gad ._ebb .BitsPerComponent ,_gad ._ebb .ColorComponents ,_abgb );if _cbcd !=nil {return nil ,_cbcd ;};return _abgb ,nil ;};

// GetXrefOffset returns the offset of the xref table.
func (_bcfgg *PdfParser )GetXrefOffset ()int64 {return _bcfgg ._dadb };