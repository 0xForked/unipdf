//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package core defines and implements the primitive PDF object types in golang, and provides functionality
// for parsing those from a PDF file stream. This includes I/O handling, cross references, repairs, encryption,
// encoding and other core capabilities.
package core ;import (_af "bufio";_gd "bytes";_ea "compress/lzw";_e "compress/zlib";_aa "crypto/md5";_fa "crypto/rand";_gb "encoding/hex";_d "errors";_bec "fmt";_fg "github.com/unidoc/unipdf/v3/common";_ag "github.com/unidoc/unipdf/v3/core/security";_bgg "github.com/unidoc/unipdf/v3/core/security/crypt";_gfg "github.com/unidoc/unipdf/v3/internal/ccittfax";_ba "github.com/unidoc/unipdf/v3/internal/imageutil";_eb "github.com/unidoc/unipdf/v3/internal/jbig2";_ed "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_cc "github.com/unidoc/unipdf/v3/internal/jbig2/decoder";_bg "github.com/unidoc/unipdf/v3/internal/jbig2/document";_bee "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_cf "github.com/unidoc/unipdf/v3/internal/strutils";_ec "golang.org/x/image/tiff/lzw";_cb "image";_da "image/color";_be "image/jpeg";_f "io";_ac "os";_b "reflect";_ga "regexp";_a "sort";_g "strconv";_gg "strings";_gf "time";);

// MakeObjectStreams creates an PdfObjectStreams from a list of PdfObjects.
func MakeObjectStreams (objects ...PdfObject )*PdfObjectStreams {_dfgg :=&PdfObjectStreams {};_dfgg ._eaeed =[]PdfObject {};for _ ,_ffbdb :=range objects {_dfgg ._eaeed =append (_dfgg ._eaeed ,_ffbdb );};return _dfgg ;};

// Elements returns a slice of the PdfObject elements in the array.
func (_agaf *PdfObjectArray )Elements ()[]PdfObject {if _agaf ==nil {return nil ;};return _agaf ._bcgc ;};

// String returns a string describing `d`.
func (_aaga *PdfObjectDictionary )String ()string {var _aafg _gg .Builder ;_aafg .WriteString ("\u0044\u0069\u0063t\u0028");for _ ,_ebafd :=range _aaga ._ccc {_agcd :=_aaga ._addf [_ebafd ];_aafg .WriteString ("\u0022"+_ebafd .String ()+"\u0022\u003a\u0020");_aafg .WriteString (_agcd .String ());_aafg .WriteString ("\u002c\u0020");};_aafg .WriteString ("\u0029");return _aafg .String ();};

// GetArray returns the *PdfObjectArray represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetArray (obj PdfObject )(_dccba *PdfObjectArray ,_gbdd bool ){_dccba ,_gbdd =TraceToDirectObject (obj ).(*PdfObjectArray );return _dccba ,_gbdd ;};

// PdfVersion returns version of the PDF file.
func (_fddb *PdfParser )PdfVersion ()Version {return _fddb ._ceage };

// IsDelimiter checks if a character represents a delimiter.
func IsDelimiter (c byte )bool {return c =='('||c ==')'||c =='<'||c =='>'||c =='['||c ==']'||c =='{'||c =='}'||c =='/'||c =='%';};

// Decrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_ffd *PdfCrypt )Decrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _ffd .isDecrypted (obj ){return nil ;};switch _eaf :=obj .(type ){case *PdfIndirectObject :_ffd ._fgc [_eaf ]=true ;_fg .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_eaf .ObjectNumber ,_eaf .GenerationNumber );_dad :=_eaf .ObjectNumber ;_afd :=_eaf .GenerationNumber ;_caa :=_ffd .Decrypt (_eaf .PdfObject ,_dad ,_afd );if _caa !=nil {return _caa ;};return nil ;case *PdfObjectStream :_ffd ._fgc [_eaf ]=true ;_adb :=_eaf .PdfObjectDictionary ;if _ffd ._fgag .R !=5{if _ggca ,_befd :=_adb .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_befd &&*_ggca =="\u0058\u0052\u0065\u0066"{return nil ;};};_bdaf :=_eaf .ObjectNumber ;_dgdb :=_eaf .GenerationNumber ;_fg .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_bdaf ,_dgdb );_egd :=_fgac ;if _ffd ._dge .V >=4{_egd =_ffd ._dec ;_fg .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_ffd ._dec );if _ggac ,_abb :=_adb .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );_abb {if _ece ,_efaa :=GetName (_ggac .Get (0));_efaa {if *_ece =="\u0043\u0072\u0079p\u0074"{_egd ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _ffdb ,_eaac :=_adb .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );_eaac {if _gbb ,_cbag :=_ffdb .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_cbag {if _ ,_fbfd :=_ffd ._eae [string (*_gbb )];_fbfd {_fg .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_gbb );_egd =string (*_gbb );};};};};};};_fg .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_egd );if _egd =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_cbda :=_ffd .Decrypt (_adb ,_bdaf ,_dgdb );if _cbda !=nil {return _cbda ;};_ceef ,_cbda :=_ffd .makeKey (_egd ,uint32 (_bdaf ),uint32 (_dgdb ),_ffd ._cge );if _cbda !=nil {return _cbda ;};_eaf .Stream ,_cbda =_ffd .decryptBytes (_eaf .Stream ,_egd ,_ceef );if _cbda !=nil {return _cbda ;};_adb .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_eaf .Stream ))));return nil ;case *PdfObjectString :_fg .Log .Trace ("\u0044e\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_daf :=_fgac ;if _ffd ._dge .V >=4{_fg .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_ffd ._acd );if _ffd ._acd =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_daf =_ffd ._acd ;};_edab ,_cdgg :=_ffd .makeKey (_daf ,uint32 (parentObjNum ),uint32 (parentGenNum ),_ffd ._cge );if _cdgg !=nil {return _cdgg ;};_aae :=_eaf .Str ();_gbgef :=make ([]byte ,len (_aae ));for _cef :=0;_cef < len (_aae );_cef ++{_gbgef [_cef ]=_aae [_cef ];};_fg .Log .Trace ("\u0044e\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_gbgef ,_gbgef );_gbgef ,_cdgg =_ffd .decryptBytes (_gbgef ,_daf ,_edab );if _cdgg !=nil {return _cdgg ;};_eaf ._fbedf =string (_gbgef );return nil ;case *PdfObjectArray :for _ ,_bbf :=range _eaf .Elements (){_ega :=_ffd .Decrypt (_bbf ,parentObjNum ,parentGenNum );if _ega !=nil {return _ega ;};};return nil ;case *PdfObjectDictionary :_ecgf :=false ;if _gge :=_eaf .Get ("\u0054\u0079\u0070\u0065");_gge !=nil {_efe ,_bbe :=_gge .(*PdfObjectName );if _bbe &&*_efe =="\u0053\u0069\u0067"{_ecgf =true ;};};for _ ,_bab :=range _eaf .Keys (){_dcf :=_eaf .Get (_bab );if _ecgf &&string (_bab )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;};if string (_bab )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_bab )!="\u0050\u0072\u0065\u0076"&&string (_bab )!="\u004c\u0061\u0073\u0074"{_cffg :=_ffd .Decrypt (_dcf ,parentObjNum ,parentGenNum );if _cffg !=nil {return _cffg ;};};};return nil ;};return nil ;};func _bagf (_dgcb _ba .Image )*JBIG2Image {_dcbc :=_dgcb .Base ();return &JBIG2Image {Data :_dcbc .Data ,Width :_dcbc .Width ,Height :_dcbc .Height ,HasPadding :true };};

// MakeHexString creates an PdfObjectString from a string intended for output as a hexadecimal string.
func MakeHexString (s string )*PdfObjectString {_ecfde :=PdfObjectString {_fbedf :s ,_dafg :true };return &_ecfde ;};func _dda (_geb *_ag .StdEncryptDict ,_cea *PdfObjectDictionary )error {R ,_bagd :=_cea .Get ("\u0052").(*PdfObjectInteger );if !_bagd {return _d .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0052");};if *R < 2||*R > 6{return _bec .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0052 \u0028\u0025\u0064\u0029",*R );};_geb .R =int (*R );O ,_bagd :=_cea .GetString ("\u004f");if !_bagd {return _d .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u004f");};if _geb .R ==5||_geb .R ==6{if len (O )< 48{return _bec .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u004f\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (O ));};}else if len (O )!=32{return _bec .Errorf ("L\u0065n\u0067\u0074\u0068\u0028\u004f\u0029\u0020\u0021=\u0020\u0033\u0032\u0020(%\u0064\u0029",len (O ));};_geb .O =[]byte (O );U ,_bagd :=_cea .GetString ("\u0055");if !_bagd {return _d .New ("\u0065\u006e\u0063\u0072y\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006eg\u0020\u0055");};if _geb .R ==5||_geb .R ==6{if len (U )< 48{return _bec .Errorf ("\u004c\u0065\u006e\u0067th\u0028\u0055\u0029\u0020\u003c\u0020\u0034\u0038\u0020\u0028\u0025\u0064\u0029",len (U ));};}else if len (U )!=32{_fg .Log .Debug ("\u0057\u0061r\u006e\u0069\u006e\u0067\u003a\u0020\u004c\u0065\u006e\u0067\u0074\u0068\u0028\u0055\u0029\u0020\u0021\u003d\u0020\u0033\u0032\u0020(%\u0064\u0029",len (U ));};_geb .U =[]byte (U );if _geb .R >=5{OE ,_gea :=_cea .GetString ("\u004f\u0045");if !_gea {return _d .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u004f\u0045");}else if len (OE )!=32{return _bec .Errorf ("L\u0065\u006e\u0067\u0074h(\u004fE\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (OE ));};_geb .OE =[]byte (OE );UE ,_gea :=_cea .GetString ("\u0055\u0045");if !_gea {return _d .New ("\u0065\u006ec\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006eg \u0055\u0045");}else if len (UE )!=32{return _bec .Errorf ("L\u0065\u006e\u0067\u0074h(\u0055E\u0029\u0020\u0021\u003d\u00203\u0032\u0020\u0028\u0025\u0064\u0029",len (UE ));};_geb .UE =[]byte (UE );};P ,_bagd :=_cea .Get ("\u0050").(*PdfObjectInteger );if !_bagd {return _d .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074 \u0064\u0069\u0063t\u0069\u006f\u006e\u0061r\u0079\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0070\u0065\u0072\u006d\u0069\u0073\u0073\u0069\u006f\u006e\u0073\u0020\u0061\u0074\u0074\u0072");};_geb .P =_ag .Permissions (*P );if _geb .R ==6{Perms ,_dab :=_cea .GetString ("\u0050\u0065\u0072m\u0073");if !_dab {return _d .New ("\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006ea\u0072y\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0050\u0065\u0072\u006d\u0073");}else if len (Perms )!=16{return _bec .Errorf ("\u004ce\u006e\u0067\u0074\u0068\u0028\u0050\u0065\u0072\u006d\u0073\u0029 \u0021\u003d\u0020\u0031\u0036\u0020\u0028\u0025\u0064\u0029",len (Perms ));};_geb .Perms =[]byte (Perms );};if _fdd ,_cfd :=_cea .Get ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061").(*PdfObjectBool );_cfd {_geb .EncryptMetadata =bool (*_fdd );}else {_geb .EncryptMetadata =true ;};return nil ;};

// DecodeStream returns the passed in stream as a slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_fbed *RawEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return streamObj .Stream ,nil ;};func _cgeb (_beee ,_edbg ,_ffbde uint8 )uint8 {_eabe :=int (_ffbde );_fbccb :=int (_edbg )-_eabe ;_efbb :=int (_beee )-_eabe ;_eabe =_dgfc (_fbccb +_efbb );_fbccb =_dgfc (_fbccb );_efbb =_dgfc (_efbb );if _fbccb <=_efbb &&_fbccb <=_eabe {return _beee ;}else if _efbb <=_eabe {return _edbg ;};return _ffbde ;};const (DefaultJPEGQuality =75;);func (_ccdg *JBIG2Encoder )encodeImage (_bccc _cb .Image )([]byte ,error ){const _ffddd ="e\u006e\u0063\u006f\u0064\u0065\u0049\u006d\u0061\u0067\u0065";_edcf ,_eacb :=GoImageToJBIG2 (_bccc ,JB2ImageAutoThreshold );if _eacb !=nil {return nil ,_bee .Wrap (_eacb ,_ffddd ,"\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069m\u0061g\u0065\u0020\u0074\u006f\u0020\u006a\u0062\u0069\u0067\u0032\u0020\u0069\u006d\u0067");};if _eacb =_ccdg .AddPageImage (_edcf ,&_ccdg .DefaultPageSettings );_eacb !=nil {return nil ,_bee .Wrap (_eacb ,_ffddd ,"");};return _ccdg .Encode ();};var _effg =_ga .MustCompile ("\u0028\u005c\u0064\u002b)\\\u0073\u002b\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u006f\u0062\u006a");

// DecodeImages decodes the page images from the jbig2 'encoded' data input.
// The jbig2 document may contain multiple pages, thus the function can return multiple
// images. The images order corresponds to the page number.
func (_gafc *JBIG2Encoder )DecodeImages (encoded []byte )([]_cb .Image ,error ){const _gccc ="\u004aB\u0049\u0047\u0032\u0045n\u0063\u006f\u0064\u0065\u0072.\u0044e\u0063o\u0064\u0065\u0049\u006d\u0061\u0067\u0065s";_bbbe ,_gccg :=_cc .Decode (encoded ,_cc .Parameters {},_gafc .Globals .ToDocumentGlobals ());if _gccg !=nil {return nil ,_bee .Wrap (_gccg ,_gccc ,"");};_caab ,_gccg :=_bbbe .PageNumber ();if _gccg !=nil {return nil ,_bee .Wrap (_gccg ,_gccc ,"");};_ebgg :=[]_cb .Image {};var _fbcde _cb .Image ;for _fbace :=1;_fbace <=_caab ;_fbace ++{_fbcde ,_gccg =_bbbe .DecodePageImage (_fbace );if _gccg !=nil {return nil ,_bee .Wrapf (_gccg ,_gccc ,"\u0070\u0061\u0067\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_fbace );};_ebgg =append (_ebgg ,_fbcde );};return _ebgg ,nil ;};

// PdfObjectStreams represents the primitive PDF object streams.
// 7.5.7 Object Streams (page 45).
type PdfObjectStreams struct{PdfObjectReference ;_eaeed []PdfObject ;};

// WriteString outputs the object as it is to be written to file.
func (_gfced *PdfObjectReference )WriteString ()string {var _fafbe _gg .Builder ;_fafbe .WriteString (_g .FormatInt (_gfced .ObjectNumber ,10));_fafbe .WriteString ("\u0020");_fafbe .WriteString (_g .FormatInt (_gfced .GenerationNumber ,10));_fafbe .WriteString ("\u0020\u0052");return _fafbe .String ();};func (_efa *PdfParser )lookupObjectViaOS (_ebe int ,_dc int )(PdfObject ,error ){var _gcb *_gd .Reader ;var _dd objectStream ;var _bd bool ;_dd ,_bd =_efa ._bfcea [_ebe ];if !_bd {_bf ,_ge :=_efa .LookupByNumber (_ebe );if _ge !=nil {_fg .Log .Debug ("\u004d\u0069ss\u0069\u006e\u0067 \u006f\u0062\u006a\u0065ct \u0073tr\u0065\u0061\u006d\u0020\u0077\u0069\u0074h \u006e\u0075\u006d\u0062\u0065\u0072\u0020%\u0064",_ebe );return nil ,_ge ;};_bag ,_afc :=_bf .(*PdfObjectStream );if !_afc {return nil ,_d .New ("i\u006e\u0076\u0061\u006cid\u0020o\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d");};if _efa ._dgfca !=nil &&!_efa ._dgfca .isDecrypted (_bag ){return nil ,_d .New ("\u006e\u0065\u0065\u0064\u0020\u0074\u006f\u0020\u0064\u0065\u0063r\u0079\u0070\u0074\u0020\u0074\u0068\u0065\u0020\u0073\u0074r\u0065\u0061\u006d");};_gbc :=_bag .PdfObjectDictionary ;_fg .Log .Trace ("\u0073o\u0020\u0064\u003a\u0020\u0025\u0073\n",_gbc .String ());_eba ,_afc :=_gbc .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if !_afc {_fg .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0061\u006c\u0077\u0061\u0079\u0073\u0020\u0068\u0061\u0076\u0065\u0020\u0061\u0020\u0054\u0079\u0070\u0065");return nil ,_d .New ("\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020T\u0079\u0070\u0065");};if _gg .ToLower (string (*_eba ))!="\u006f\u0062\u006a\u0073\u0074\u006d"{_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0074\u0079\u0070\u0065\u0020s\u0068\u0061\u006c\u006c\u0020\u0061\u006c\u0077\u0061\u0079\u0073 \u0062\u0065\u0020\u004f\u0062\u006a\u0053\u0074\u006d\u0020\u0021");return nil ,_d .New ("\u006f\u0062\u006a\u0065c\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0074y\u0070e\u0020\u0021\u003d\u0020\u004f\u0062\u006aS\u0074\u006d");};N ,_afc :=_gbc .Get ("\u004e").(*PdfObjectInteger );if !_afc {return nil ,_d .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u004e\u0020i\u006e\u0020\u0073\u0074\u0072\u0065\u0061m\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_afcf ,_afc :=_gbc .Get ("\u0046\u0069\u0072s\u0074").(*PdfObjectInteger );if !_afc {return nil ,_d .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0046\u0069\u0072\u0073\u0074\u0020i\u006e \u0073t\u0072e\u0061\u006d\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_fg .Log .Trace ("\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0073\u0020\u006eu\u006d\u0062\u0065\u0072\u0020\u006f\u0066 \u006f\u0062\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_eba ,*N );_ggg ,_ge :=DecodeStream (_bag );if _ge !=nil {return nil ,_ge ;};_fg .Log .Trace ("D\u0065\u0063\u006f\u0064\u0065\u0064\u003a\u0020\u0025\u0073",_ggg );_cfe :=_efa .GetFileOffset ();defer func (){_efa .SetFileOffset (_cfe )}();_gcb =_gd .NewReader (_ggg );_efa ._fdfg =_af .NewReader (_gcb );_fg .Log .Trace ("\u0050a\u0072s\u0069\u006e\u0067\u0020\u006ff\u0066\u0073e\u0074\u0020\u006d\u0061\u0070");_bda :=map[int ]int64 {};for _dg :=0;_dg < int (*N );_dg ++{_efa .skipSpaces ();_ddf ,_bc :=_efa .parseNumber ();if _bc !=nil {return nil ,_bc ;};_dca ,_ff :=_ddf .(*PdfObjectInteger );if !_ff {return nil ,_d .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");};_efa .skipSpaces ();_ddf ,_bc =_efa .parseNumber ();if _bc !=nil {return nil ,_bc ;};_de ,_ff :=_ddf .(*PdfObjectInteger );if !_ff {return nil ,_d .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073t\u0072e\u0061m\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0074\u0061\u0062\u006c\u0065");};_fg .Log .Trace ("\u006f\u0062j\u0020\u0025\u0064 \u006f\u0066\u0066\u0073\u0065\u0074\u0020\u0025\u0064",*_dca ,*_de );_bda [int (*_dca )]=int64 (*_afcf +*_de );};_dd =objectStream {N :int (*N ),_acb :_ggg ,_ef :_bda };_efa ._bfcea [_ebe ]=_dd ;}else {_ecf :=_efa .GetFileOffset ();defer func (){_efa .SetFileOffset (_ecf )}();_gcb =_gd .NewReader (_dd ._acb );_efa ._fdfg =_af .NewReader (_gcb );};_bcd :=_dd ._ef [_dc ];_fg .Log .Trace ("\u0041\u0043\u0054\u0055AL\u0020\u006f\u0066\u0066\u0073\u0065\u0074\u005b\u0025\u0064\u005d\u0020\u003d\u0020%\u0064",_dc ,_bcd );_gcb .Seek (_bcd ,_ac .SEEK_SET );_efa ._fdfg =_af .NewReader (_gcb );_df ,_ :=_efa ._fdfg .Peek (100);_fg .Log .Trace ("\u004f\u0042\u004a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_df ));_cfb ,_eca :=_efa .parseObject ();if _eca !=nil {_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c \u0074\u006f\u0020\u0072\u0065\u0061\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_eca );return nil ,_eca ;};if _cfb ==nil {return nil ,_d .New ("o\u0062\u006a\u0065\u0063t \u0063a\u006e\u006e\u006f\u0074\u0020b\u0065\u0020\u006e\u0075\u006c\u006c");};_ffa :=PdfIndirectObject {};_ffa .ObjectNumber =int64 (_dc );_ffa .PdfObject =_cfb ;return &_ffa ,nil ;};

// PdfObjectNull represents the primitive PDF null object.
type PdfObjectNull struct{};var _gbbb =_ga .MustCompile ("\u005e\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");

// MakeStringFromBytes creates an PdfObjectString from a byte array.
// This is more natural than MakeString as `data` is usually not utf-8 encoded.
func MakeStringFromBytes (data []byte )*PdfObjectString {return MakeString (string (data ))};

// PdfObjectBool represents the primitive PDF boolean object.
type PdfObjectBool bool ;

// PdfObjectFloat represents the primitive PDF floating point numerical object.
type PdfObjectFloat float64 ;

// DecodeStream implements ASCII hex decoding.
func (_ecaa *ASCIIHexEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _ecaa .DecodeBytes (streamObj .Stream );};

// EncodeBytes encodes data into ASCII85 encoded format.
func (_ebce *ASCII85Encoder )EncodeBytes (data []byte )([]byte ,error ){var _adfb _gd .Buffer ;for _afbd :=0;_afbd < len (data );_afbd +=4{_eabd :=data [_afbd ];_ddfff :=1;_cgefb :=byte (0);if _afbd +1< len (data ){_cgefb =data [_afbd +1];_ddfff ++;};_ccag :=byte (0);if _afbd +2< len (data ){_ccag =data [_afbd +2];_ddfff ++;};_cdgf :=byte (0);if _afbd +3< len (data ){_cdgf =data [_afbd +3];_ddfff ++;};_afeb :=(uint32 (_eabd )<<24)|(uint32 (_cgefb )<<16)|(uint32 (_ccag )<<8)|uint32 (_cdgf );if _afeb ==0{_adfb .WriteByte ('z');}else {_defg :=_ebce .base256Tobase85 (_afeb );for _ ,_gfdg :=range _defg [:_ddfff +1]{_adfb .WriteByte (_gfdg +'!');};};};_adfb .WriteString ("\u007e\u003e");return _adfb .Bytes (),nil ;};func _fcge (_cfdb *PdfObjectStream ,_ebbf *PdfObjectDictionary )(*CCITTFaxEncoder ,error ){_eac :=NewCCITTFaxEncoder ();_bgfb :=_cfdb .PdfObjectDictionary ;if _bgfb ==nil {return _eac ,nil ;};if _ebbf ==nil {_dgbe :=TraceToDirectObject (_bgfb .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));if _dgbe !=nil {switch _ggafg :=_dgbe .(type ){case *PdfObjectDictionary :_ebbf =_ggafg ;break ;case *PdfObjectArray :if _ggafg .Len ()==1{if _baff ,_aaag :=GetDict (_ggafg .Get (0));_aaag {_ebbf =_baff ;};};default:_fg .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_dgbe );return nil ,_d .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _ebbf ==nil {_fg .Log .Error ("\u0044\u0065c\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065\u0064 %\u0023\u0076",_dgbe );return nil ,_d .New ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _adfdc ,_befg :=GetNumberAsInt64 (_ebbf .Get ("\u004b"));_befg ==nil {_eac .K =int (_adfdc );};if _bbbd ,_facf :=GetNumberAsInt64 (_ebbf .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));_facf ==nil {_eac .Columns =int (_bbbd );}else {_eac .Columns =1728;};if _agbd ,_acefb :=GetNumberAsInt64 (_ebbf .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_acefb ==nil {_eac .BlackIs1 =_agbd > 0;}else {if _efb ,_dgdg :=GetBoolVal (_ebbf .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_dgdg {_eac .BlackIs1 =_efb ;}else {if _fdf ,_gacbe :=GetArray (_ebbf .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));_gacbe {_ecfd ,_gbgc :=_fdf .ToIntegerArray ();if _gbgc ==nil {_eac .BlackIs1 =_ecfd [0]==1&&_ecfd [1]==0;};};};};if _ebbd ,_begc :=GetNumberAsInt64 (_ebbf .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_begc ==nil {_eac .EncodedByteAlign =_ebbd > 0;}else {if _dfab ,_cegb :=GetBoolVal (_ebbf .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_cegb {_eac .EncodedByteAlign =_dfab ;};};if _dgdc ,_gcga :=GetNumberAsInt64 (_ebbf .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_gcga ==nil {_eac .EndOfLine =_dgdc > 0;}else {if _dgead ,_gbaa :=GetBoolVal (_ebbf .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_gbaa {_eac .EndOfLine =_dgead ;};};if _fgdc ,_fdgd :=GetNumberAsInt64 (_ebbf .Get ("\u0052\u006f\u0077\u0073"));_fdgd ==nil {_eac .Rows =int (_fgdc );};_eac .EndOfBlock =true ;if _fgbd ,_eaafd :=GetNumberAsInt64 (_ebbf .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_eaafd ==nil {_eac .EndOfBlock =_fgbd > 0;}else {if _dcbe ,_aegb :=GetBoolVal (_ebbf .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_aegb {_eac .EndOfBlock =_dcbe ;};};if _bdge ,_fbac :=GetNumberAsInt64 (_ebbf .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));_fbac !=nil {_eac .DamagedRowsBeforeError =int (_bdge );};_fg .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_ebbf .String ());return _eac ,nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_bfbe *ASCII85Encoder )UpdateParams (params *PdfObjectDictionary ){};

// UpdateParams updates the parameter values of the encoder.
func (_bcc *MultiEncoder )UpdateParams (params *PdfObjectDictionary ){for _ ,_bggbf :=range _bcc ._bbce {_bggbf .UpdateParams (params );};};

// Validate validates the page settings for the JBIG2 encoder.
func (_eadef JBIG2EncoderSettings )Validate ()error {const _deed ="\u0076a\u006ci\u0064\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065\u0072";if _eadef .Threshold < 0||_eadef .Threshold > 1.0{return _bee .Errorf (_deed ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074\u0068\u0072\u0065\u0073\u0068\u006f\u006c\u0064\u0020\u0076a\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0076\u0027 \u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0069\u006e\u0020\u0072\u0061n\u0067\u0065\u0020\u005b\u0030\u002e0\u002c\u0020\u0031.\u0030\u005d",_eadef .Threshold );};if _eadef .ResolutionX < 0{return _bee .Errorf (_deed ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0078\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_eadef .ResolutionX );};if _eadef .ResolutionY < 0{return _bee .Errorf (_deed ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0079\u0020\u0072\u0065\u0073\u006f\u006c\u0075\u0074\u0069\u006fn\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065 \u006f\u0072\u0020\u007a\u0065\u0072o\u0020\u0076\u0061l\u0075\u0065",_eadef .ResolutionY );};if _eadef .DefaultPixelValue !=0&&_eadef .DefaultPixelValue !=1{return _bee .Errorf (_deed ,"de\u0066\u0061u\u006c\u0074\u0020\u0070\u0069\u0078\u0065\u006c\u0020v\u0061\u006c\u0075\u0065\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0066o\u0072 \u0074\u0068\u0065\u0020\u0062\u0069\u0074\u003a \u007b0\u002c\u0031}",_eadef .DefaultPixelValue );};if _eadef .Compression !=JB2Generic {return _bee .Errorf (_deed ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065d\u0020\u0063\u006fm\u0070\u0072\u0065\u0073s\u0069\u006f\u006e\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");};return nil ;};

// GetFilterName returns the name of the encoding filter.
func (_gabcb *ASCIIHexEncoder )GetFilterName ()string {return StreamEncodingFilterNameASCIIHex };

// NewASCIIHexEncoder makes a new ASCII hex encoder.
func NewASCIIHexEncoder ()*ASCIIHexEncoder {_fccg :=&ASCIIHexEncoder {};return _fccg };

// UpdateParams updates the parameter values of the encoder.
func (_bedf *DCTEncoder )UpdateParams (params *PdfObjectDictionary ){_fedea ,_baa :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _baa ==nil {_bedf .ColorComponents =int (_fedea );};_febc ,_baa :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _baa ==nil {_bedf .BitsPerComponent =int (_febc );};_cdfg ,_baa :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _baa ==nil {_bedf .Width =int (_cdfg );};_gede ,_baa :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _baa ==nil {_bedf .Height =int (_gede );};_dadc ,_baa :=GetNumberAsInt64 (params .Get ("\u0051u\u0061\u006c\u0069\u0074\u0079"));if _baa ==nil {_bedf .Quality =int (_dadc );};};

// WriteString outputs the object as it is to be written to file.
func (_eegc *PdfObjectString )WriteString ()string {var _baba _gd .Buffer ;if _eegc ._dafg {_cgad :=_gb .EncodeToString (_eegc .Bytes ());_baba .WriteString ("\u003c");_baba .WriteString (_cgad );_baba .WriteString ("\u003e");return _baba .String ();};_acbb :=map[byte ]string {'\n':"\u005c\u006e",'\r':"\u005c\u0072",'\t':"\u005c\u0074",'\b':"\u005c\u0062",'\f':"\u005c\u0066",'(':"\u005c\u0028",')':"\u005c\u0029",'\\':"\u005c\u005c"};_baba .WriteString ("\u0028");for _acead :=0;_acead < len (_eegc ._fbedf );_acead ++{_cdaef :=_eegc ._fbedf [_acead ];if _gcce ,_bcfgd :=_acbb [_cdaef ];_bcfgd {_baba .WriteString (_gcce );}else {_baba .WriteByte (_cdaef );};};_baba .WriteString ("\u0029");return _baba .String ();};func (_eec *PdfParser )parseHexString ()(*PdfObjectString ,error ){_eec ._fdfg .ReadByte ();var _fdbd _gd .Buffer ;for {_gafe ,_ffcf :=_eec ._fdfg .Peek (1);if _ffcf !=nil {return MakeString (""),_ffcf ;};if _gafe [0]=='>'{_eec ._fdfg .ReadByte ();break ;};_gacdc ,_ :=_eec ._fdfg .ReadByte ();if !IsWhiteSpace (_gacdc ){_fdbd .WriteByte (_gacdc );};};if _fdbd .Len ()%2==1{_fdbd .WriteRune ('0');};_aeff ,_ :=_gb .DecodeString (_fdbd .String ());return MakeHexString (string (_aeff )),nil ;};

// Set sets the PdfObject at index i of the streams. An error is returned if the index is outside bounds.
func (_addb *PdfObjectStreams )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_addb ._eaeed ){return _d .New ("\u004f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_addb ._eaeed [i ]=obj ;return nil ;};func (_edef *PdfParser )seekToEOFMarker (_fcac int64 )error {var _badbg int64 ;var _cegae int64 =2048;for _badbg < _fcac -4{if _fcac <=(_cegae +_badbg ){_cegae =_fcac -_badbg ;};_ ,_abef :=_edef ._aedcf .Seek (-_badbg -_cegae ,_f .SeekEnd );if _abef !=nil {return _abef ;};_dadcg :=make ([]byte ,_cegae );_edef ._aedcf .Read (_dadcg );_fg .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0045\u004f\u0046 \u006da\u0072\u006b\u0065\u0072\u003a\u0020\u0022%\u0073\u0022",string (_dadcg ));_ddba :=_bdgb .FindAllStringIndex (string (_dadcg ),-1);if _ddba !=nil {_cegbb :=_ddba [len (_ddba )-1];_fg .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_ddba );_edef ._aedcf .Seek (-_badbg -_cegae +int64 (_cegbb [0]),_f .SeekEnd );return nil ;};_fg .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");_badbg +=_cegae -4;};_fg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006be\u0072 \u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u002e");return _d .New ("\u0045\u004f\u0046\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_dcga *JPXEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};func (_cecce *PdfParser )repairLocateXref ()(int64 ,error ){_abea :=int64 (1000);_cecce ._aedcf .Seek (-_abea ,_ac .SEEK_CUR );_eeaa ,_gfcfc :=_cecce ._aedcf .Seek (0,_ac .SEEK_CUR );if _gfcfc !=nil {return 0,_gfcfc ;};_gcff :=make ([]byte ,_abea );_cecce ._aedcf .Read (_gcff );_eaagg :=_dcgc .FindAllStringIndex (string (_gcff ),-1);if len (_eaagg )< 1{_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0052\u0065\u0070a\u0069\u0072\u003a\u0020\u0078\u0072\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0021");return 0,_d .New ("\u0072\u0065\u0070\u0061ir\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064");};_beff :=int64 (_eaagg [len (_eaagg )-1][0]);_bgga :=_eeaa +_beff ;return _bgga ,nil ;};func _dgfc (_dddd int )int {_fde :=_dddd >>(_cdcge -1);return (_dddd ^_fde )-_fde };

// GetNumberAsFloat returns the contents of `obj` as a float if it is an integer or float, or an
// error if it isn't.
func GetNumberAsFloat (obj PdfObject )(float64 ,error ){switch _dgcdf :=obj .(type ){case *PdfObjectFloat :return float64 (*_dgcdf ),nil ;case *PdfObjectInteger :return float64 (*_dgcdf ),nil ;};return 0,ErrNotANumber ;};func (_agf *PdfCrypt )encryptBytes (_bddc []byte ,_bacg string ,_abd []byte )([]byte ,error ){_fg .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");_abac ,_efcg :=_agf ._eae [_bacg ];if !_efcg {return nil ,_bec .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_bacg );};return _abac .EncryptBytes (_bddc ,_abd );};func (_cbe *PdfCrypt )loadCryptFilters (_fcf *PdfObjectDictionary )error {_cbe ._eae =cryptFilters {};_dbb :=_fcf .Get ("\u0043\u0046");_dbb =TraceToDirectObject (_dbb );if _gab ,_dgfb :=_dbb .(*PdfObjectReference );_dgfb {_bdd ,_fdb :=_cbe ._cgd .LookupByReference (*_gab );if _fdb !=nil {_fg .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0075\u0070\u0020\u0043\u0046\u0020\u0072\u0065\u0066\u0065\u0072en\u0063\u0065");return _fdb ;};_dbb =TraceToDirectObject (_bdd );};_badd ,_ggd :=_dbb .(*PdfObjectDictionary );if !_ggd {_fg .Log .Debug ("I\u006ev\u0061\u006c\u0069\u0064\u0020\u0043\u0046\u002c \u0074\u0079\u0070\u0065: \u0025\u0054",_dbb );return _d .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0043\u0046");};for _ ,_cbgd :=range _badd .Keys (){_cad :=_badd .Get (_cbgd );if _fab ,_eag :=_cad .(*PdfObjectReference );_eag {_dcb ,_cffe :=_cbe ._cgd .LookupByReference (*_fab );if _cffe !=nil {_fg .Log .Debug ("\u0045\u0072ro\u0072\u0020\u006co\u006f\u006b\u0075\u0070 up\u0020di\u0063\u0074\u0069\u006f\u006e\u0061\u0072y \u0072\u0065\u0066\u0065\u0072\u0065\u006ec\u0065");return _cffe ;};_cad =TraceToDirectObject (_dcb );};_ab ,_bb :=_cad .(*PdfObjectDictionary );if !_bb {return _bec .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074\u0020\u0069\u006e \u0043\u0046\u0020\u0028\u006e\u0061\u006d\u0065\u0020\u0025\u0073\u0029\u0020-\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079\u0020\u0062\u0075\u0074\u0020\u0025\u0054",_cbgd ,_cad );};if _cbgd =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u002d\u0020\u0043\u0061\u006e\u006e\u006f\u0074\u0020\u006f\u0076\u0065\u0072\u0077r\u0069\u0074\u0065\u0020\u0074\u0068\u0065\u0020\u0069d\u0065\u006e\u0074\u0069\u0074\u0079\u0020\u0066\u0069\u006c\u0074\u0065\u0072 \u002d\u0020\u0054\u0072\u0079\u0069n\u0067\u0020\u006ee\u0078\u0074");continue ;};var _gga _bgg .FilterDict ;if _bbc :=_cgdf (&_gga ,_ab );_bbc !=nil {return _bbc ;};_fed ,_edgd :=_bgg .NewFilter (_gga );if _edgd !=nil {return _edgd ;};_cbe ._eae [string (_cbgd )]=_fed ;};_cbe ._eae ["\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"]=_bgg .NewIdentity ();_cbe ._acd ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _fgcb ,_ebf :=_fcf .Get ("\u0053\u0074\u0072\u0046").(*PdfObjectName );_ebf {if _ ,_bbb :=_cbe ._eae [string (*_fgcb )];!_bbb {return _bec .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u0072\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_fgcb );};_cbe ._acd =string (*_fgcb );};_cbe ._dec ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _gbf ,_cee :=_fcf .Get ("\u0053\u0074\u006d\u0046").(*PdfObjectName );_cee {if _ ,_geg :=_cbe ._eae [string (*_gbf )];!_geg {return _bec .Errorf ("\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0066o\u0072\u0020\u0053\u0074\u006d\u0046\u0020\u006e\u006f\u0074\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069e\u0064\u0020\u0069\u006e\u0020C\u0046\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0028\u0025\u0073\u0029",*_gbf );};_cbe ._dec =string (*_gbf );};return nil ;};

// GetFilterName returns the name of the encoding filter.
func (_egaf *ASCII85Encoder )GetFilterName ()string {return StreamEncodingFilterNameASCII85 };

// ResolveReferencesDeep recursively traverses through object `o`, looking up and replacing
// references with indirect objects.
// Optionally a map of already deep-resolved objects can be provided via `traversed`. The `traversed` map
// is updated while traversing the objects to avoid traversing same objects multiple times.
func ResolveReferencesDeep (o PdfObject ,traversed map[PdfObject ]struct{})error {if traversed ==nil {traversed =map[PdfObject ]struct{}{};};return _ddgb (o ,0,traversed );};

// PdfObjectString represents the primitive PDF string object.
type PdfObjectString struct{_fbedf string ;_dafg bool ;};func _dabf (_aafb int )int {if _aafb < 0{return -_aafb ;};return _aafb ;};

// EncodeBytes encodes the image data using either Group3 or Group4 CCITT facsimile (fax) encoding.
// `data` is expected to be 1 color component, 1 byte per component.
func (_efag *CCITTFaxEncoder )EncodeBytes (data []byte )([]byte ,error ){var _ddc [][]byte ;for _edea :=0;_edea < len (data );_edea +=_efag .Columns {_bbbf :=make ([]byte ,_efag .Columns );_agac :=0;for _affeb :=0;_affeb < _efag .Columns ;_affeb ++{if data [_edea +_affeb ]==255{_bbbf [_agac ]=1;}else {_bbbf [_agac ]=0;};_agac ++;};_ddc =append (_ddc ,_bbbf );};_ggbb :=&_gfg .Encoder {K :_efag .K ,Columns :_efag .Columns ,EndOfLine :_efag .EndOfLine ,EndOfBlock :_efag .EndOfBlock ,BlackIs1 :_efag .BlackIs1 ,DamagedRowsBeforeError :_efag .DamagedRowsBeforeError ,Rows :_efag .Rows ,EncodedByteAlign :_efag .EncodedByteAlign };return _ggbb .Encode (_ddc ),nil ;};const (XrefTypeTableEntry xrefType =iota ;XrefTypeObjectStream xrefType =iota ;);func (_fgef *PdfParser )loadXrefs ()(*PdfObjectDictionary ,error ){_fgef ._dfcg .ObjectMap =make (map[int ]XrefObject );_fgef ._bfcea =make (objectStreams );_gcag ,_daac :=_fgef ._aedcf .Seek (0,_f .SeekEnd );if _daac !=nil {return nil ,_daac ;};_fg .Log .Trace ("\u0066s\u0069\u007a\u0065\u003a\u0020\u0025d",_gcag );_fgef ._egbf =_gcag ;_daac =_fgef .seekToEOFMarker (_gcag );if _daac !=nil {_fg .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0073\u0065\u0065\u006b\u0020\u0074\u006f\u0020\u0065\u006f\u0066\u0020\u006d\u0061\u0072\u006b\u0065\u0072: \u0025\u0076",_daac );return nil ,_daac ;};_bfee ,_daac :=_fgef ._aedcf .Seek (0,_f .SeekCurrent );if _daac !=nil {return nil ,_daac ;};var _dbdd int64 =64;_bfaf :=_bfee -_dbdd ;if _bfaf < 0{_bfaf =0;};_ ,_daac =_fgef ._aedcf .Seek (_bfaf ,_f .SeekStart );if _daac !=nil {return nil ,_daac ;};_bcdg :=make ([]byte ,_dbdd );_ ,_daac =_fgef ._aedcf .Read (_bcdg );if _daac !=nil {_fg .Log .Debug ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u006c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u003a\u0020\u0025\u0076",_daac );return nil ,_daac ;};_gdbee :=_dcdge .FindStringSubmatch (string (_bcdg ));if len (_gdbee )< 2{_fg .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020n\u006f\u0074\u0020f\u006fu\u006e\u0064\u0021");return nil ,_d .New ("\u0073\u0074\u0061\u0072tx\u0072\u0065\u0066\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};if len (_gdbee )> 2{_fg .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u004du\u006c\u0074\u0069\u0070\u006c\u0065\u0020s\u0074\u0061\u0072\u0074\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029\u0021",_bcdg );return nil ,_d .New ("m\u0075\u006c\u0074\u0069\u0070\u006ce\u0020\u0073\u0074\u0061\u0072\u0074\u0078\u0072\u0065f\u0020\u0065\u006et\u0072i\u0065\u0073\u003f");};_gcdb ,_ :=_g .ParseInt (_gdbee [1],10,64);_fg .Log .Trace ("\u0073t\u0061r\u0074\u0078\u0072\u0065\u0066\u0020\u0061\u0074\u0020\u0025\u0064",_gcdb );if _gcdb > _gcag {_fg .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u006f\u0066f\u0073e\u0074 \u006fu\u0074\u0073\u0069\u0064\u0065\u0020\u006f\u0066\u0020\u0066\u0069\u006c\u0065");_fg .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0072e\u0070\u0061\u0069\u0072");_gcdb ,_daac =_fgef .repairLocateXref ();if _daac !=nil {_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0052\u0065\u0070\u0061\u0069\u0072\u0020\u0061\u0074\u0074\u0065\u006d\u0070t\u0020\u0066\u0061\u0069\u006c\u0065\u0064 \u0028\u0025\u0073\u0029");return nil ,_daac ;};};_fgef ._aedcf .Seek (int64 (_gcdb ),_f .SeekStart );_fgef ._fdfg =_af .NewReader (_fgef ._aedcf );_facfg ,_daac :=_fgef .parseXref ();if _daac !=nil {return nil ,_daac ;};_dabd :=_facfg .Get ("\u0058R\u0065\u0066\u0053\u0074\u006d");if _dabd !=nil {_abdb ,_acea :=_dabd .(*PdfObjectInteger );if !_acea {return nil ,_d .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0021=\u0020\u0069\u006e\u0074");};_ ,_daac =_fgef .parseXrefStream (_abdb );if _daac !=nil {return nil ,_daac ;};};var _efaf []int64 ;_bddf :=func (_gag int64 ,_beab []int64 )bool {for _ ,_acfba :=range _beab {if _acfba ==_gag {return true ;};};return false ;};_dabd =_facfg .Get ("\u0050\u0072\u0065\u0076");for _dabd !=nil {_cdgb ,_dga :=_dabd .(*PdfObjectInteger );if !_dga {_fg .Log .Debug ("\u0049\u006ev\u0061\u006c\u0069\u0064\u0020P\u0072\u0065\u0076\u0020\u0072e\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u003a\u0020\u004e\u006f\u0074\u0020\u0061\u0020\u002a\u0050\u0064\u0066\u004f\u0062\u006a\u0065\u0063\u0074\u0049\u006e\u0074\u0065\u0067\u0065\u0072\u0020\u0028\u0025\u0054\u0029",_dabd );return _facfg ,nil ;};_ccdcb :=*_cdgb ;_fg .Log .Trace ("\u0041\u006eot\u0068\u0065\u0072 \u0050\u0072\u0065\u0076 xr\u0065f \u0074\u0061\u0062\u006c\u0065\u0020\u006fbj\u0065\u0063\u0074\u0020\u0061\u0074\u0020%\u0064",_ccdcb );_fgef ._aedcf .Seek (int64 (_ccdcb ),_ac .SEEK_SET );_fgef ._fdfg =_af .NewReader (_fgef ._aedcf );_abad ,_geef :=_fgef .parseXref ();if _geef !=nil {_fg .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0045\u0072\u0072\u006f\u0072\u0020-\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u0061\u0064\u0069n\u0067\u0020\u0061\u006e\u006f\u0074\u0068\u0065\u0072\u0020\u0028\u0050re\u0076\u0029\u0020\u0074\u0072\u0061\u0069\u006c\u0065\u0072");_fg .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0063\u006f\u006e\u0074\u0069n\u0075\u0065\u0020\u0062\u0079\u0020\u0069\u0067\u006e\u006f\u0072\u0069n\u0067\u0020\u0069\u0074");break ;};_dabd =_abad .Get ("\u0050\u0072\u0065\u0076");if _dabd !=nil {_edefg :=*(_dabd .(*PdfObjectInteger ));if _bddf (int64 (_edefg ),_efaf ){_fg .Log .Debug ("\u0050\u0072ev\u0065\u006e\u0074i\u006e\u0067\u0020\u0063irc\u0075la\u0072\u0020\u0078\u0072\u0065\u0066\u0020re\u0066\u0065\u0072\u0065\u006e\u0063\u0069n\u0067");break ;};_efaf =append (_efaf ,int64 (_edefg ));};};return _facfg ,nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_babb *FlateEncoder )MakeDecodeParams ()PdfObject {if _babb .Predictor > 1{_ebc :=MakeDict ();_ebc .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_babb .Predictor )));if _babb .BitsPerComponent !=8{_ebc .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_babb .BitsPerComponent )));};if _babb .Columns !=1{_ebc .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_babb .Columns )));};if _babb .Colors !=1{_ebc .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_babb .Colors )));};return _ebc ;};return nil ;};

// DrawableImage is same as golang image/draw's Image interface that allow drawing images.
type DrawableImage interface{ColorModel ()_da .Model ;Bounds ()_cb .Rectangle ;At (_edaa ,_bbg int )_da .Color ;Set (_dcceg ,_gaab int ,_afdb _da .Color );};

// String returns a string describing `ind`.
func (_edge *PdfIndirectObject )String ()string {return _bec .Sprintf ("\u0049\u004f\u0062\u006a\u0065\u0063\u0074\u003a\u0025\u0064",(*_edge ).ObjectNumber );};

// CheckAccessRights checks access rights and permissions for a specified password. If either user/owner password is
// specified, full rights are granted, otherwise the access rights are specified by the Permissions flag.
//
// The bool flag indicates that the user can access and view the file.
// The AccessPermissions shows what access the user has for editing etc.
// An error is returned if there was a problem performing the authentication.
func (_bcbea *PdfParser )CheckAccessRights (password []byte )(bool ,_ag .Permissions ,error ){if _bcbea ._dgfca ==nil {return true ,_ag .PermOwner ,nil ;};return _bcbea ._dgfca .checkAccessRights (password );};func _dgee (_bef int )cryptFilters {return cryptFilters {_fgac :_bgg .NewFilterV2 (_bef )}};var _ebeb =_ga .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064+\u0029\u005c\u0073\u002b\u0028\u005b\u006e\u0066\u005d\u0029\\\u0073\u002a\u0024");func (_dfac *PdfParser )rebuildXrefTable ()error {_cbac :=XrefTable {};_cbac .ObjectMap =map[int ]XrefObject {};for _fcdbg ,_dbbae :=range _dfac ._dfcg .ObjectMap {_ffbf ,_ ,_bacb :=_dfac .lookupByNumberWrapper (_fcdbg ,false );if _bacb !=nil {_fg .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020U\u006e\u0061\u0062\u006ce t\u006f l\u006f\u006f\u006b\u0020\u0075\u0070\u0020ob\u006a\u0065\u0063\u0074\u0020\u0028\u0025s\u0029",_bacb );_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0063\u006fm\u0070\u006c\u0065\u0074\u0065\u006c\u0079\u0020\u0062\u0072\u006f\u006b\u0065\u006e\u0020\u002d\u0020\u0061\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0074\u006f \u0072\u0065\u0070\u0061\u0069r\u0020");_gaaba ,_cegbg :=_dfac .repairRebuildXrefsTopDown ();if _cegbg !=nil {_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0072\u0065\u0062\u0075\u0069l\u0064\u0020\u0072\u0065\u0070a\u0069\u0072 \u0028\u0025\u0073\u0029",_cegbg );return _cegbg ;};_dfac ._dfcg =*_gaaba ;_fg .Log .Debug ("\u0052e\u0070\u0061\u0069\u0072e\u0064\u0020\u0078\u0072\u0065f\u0020t\u0061b\u006c\u0065\u0020\u0062\u0075\u0069\u006ct");return nil ;};_dcgd ,_abge ,_bacb :=_ae (_ffbf );if _bacb !=nil {return _bacb ;};_dbbae .ObjectNumber =int (_dcgd );_dbbae .Generation =int (_abge );_cbac .ObjectMap [int (_dcgd )]=_dbbae ;};_dfac ._dfcg =_cbac ;_fg .Log .Debug ("N\u0065w\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061b\u006c\u0065\u0020\u0062ui\u006c\u0074");_ede (_dfac ._dfcg );return nil ;};

// EncodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_dedc *RawEncoder )EncodeBytes (data []byte )([]byte ,error ){return data ,nil };

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set.  Some other parameters are generated elsewhere.
func (_cebb *DCTEncoder )MakeStreamDict ()*PdfObjectDictionary {_adffa :=MakeDict ();_adffa .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_cebb .GetFilterName ()));return _adffa ;};

// CCITTFaxEncoder implements Group3 and Group4 facsimile (fax) encoder/decoder.
type CCITTFaxEncoder struct{K int ;EndOfLine bool ;EncodedByteAlign bool ;Columns int ;Rows int ;EndOfBlock bool ;BlackIs1 bool ;DamagedRowsBeforeError int ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_abfg *ASCII85Encoder )MakeDecodeParams ()PdfObject {return nil };

// DecodeStream decodes the stream data and returns the decoded data.
// An error is returned upon failure.
func DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_fg .Log .Trace ("\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_dfbfd ,_dcca :=NewEncoderFromStream (streamObj );if _dcca !=nil {_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_dcca );return nil ,_dcca ;};_fg .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u0023\u0076\u000a",_dfbfd );_gaga ,_dcca :=_dfbfd .DecodeStream (streamObj );if _dcca !=nil {_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006f\u0064\u0069n\u0067\u0020\u0066\u0061\u0069\u006c\u0065d\u003a\u0020\u0025\u0076",_dcca );return nil ,_dcca ;};return _gaga ,nil ;};

// MakeIndirectObject creates an PdfIndirectObject with a specified direct object PdfObject.
func MakeIndirectObject (obj PdfObject )*PdfIndirectObject {_caee :=&PdfIndirectObject {};_caee .PdfObject =obj ;return _caee ;};func _cae (_gfa *PdfObjectStream ,_gdbac *PdfObjectDictionary )(*RunLengthEncoder ,error ){return NewRunLengthEncoder (),nil ;};

// DecodeStream decodes the stream containing CCITTFax encoded image data.
func (_cgag *CCITTFaxEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _cgag .DecodeBytes (streamObj .Stream );};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_age *JPXEncoder )MakeDecodeParams ()PdfObject {return nil };

// ToInt64Slice returns a slice of all array elements as an int64 slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_edgf *PdfObjectArray )ToInt64Slice ()([]int64 ,error ){var _gcdbe []int64 ;for _ ,_egcc :=range _edgf .Elements (){if _fcdad ,_ffgab :=_egcc .(*PdfObjectInteger );_ffgab {_gcdbe =append (_gcdbe ,int64 (*_fcdad ));}else {return nil ,ErrTypeError ;};};return _gcdbe ,nil ;};var _dcdge =_ga .MustCompile ("\u0073t\u0061r\u0074\u0078\u003f\u0072\u0065f\u005c\u0073*\u0028\u005c\u0064\u002b\u0029");

// Len returns the number of elements in the streams.
func (_fedac *PdfObjectStreams )Len ()int {if _fedac ==nil {return 0;};return len (_fedac ._eaeed );};

// GetBoolVal returns the bool value within a *PdObjectBool represented by an PdfObject interface directly or indirectly.
// If the PdfObject does not represent a bool value, a default value of false is returned (found = false also).
func GetBoolVal (obj PdfObject )(_becb bool ,_cgba bool ){_cfeb ,_cgba :=TraceToDirectObject (obj ).(*PdfObjectBool );if _cgba {return bool (*_cfeb ),true ;};return false ,false ;};

// GetFloatVal returns the float64 value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetFloatVal (obj PdfObject )(_fgce float64 ,_dcebg bool ){_ccddb ,_dcebg :=TraceToDirectObject (obj ).(*PdfObjectFloat );if _dcebg {return float64 (*_ccddb ),true ;};return 0,false ;};

// DecodeBytes decodes a slice of ASCII encoded bytes and returns the result.
func (_aefg *ASCIIHexEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_dgc :=_gd .NewReader (encoded );var _bce []byte ;for {_cffea ,_eeb :=_dgc .ReadByte ();if _eeb !=nil {return nil ,_eeb ;};if _cffea =='>'{break ;};if IsWhiteSpace (_cffea ){continue ;};if (_cffea >='a'&&_cffea <='f')||(_cffea >='A'&&_cffea <='F')||(_cffea >='0'&&_cffea <='9'){_bce =append (_bce ,_cffea );}else {_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0061\u0073\u0063\u0069\u0069 \u0068\u0065\u0078\u0020\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072 \u0028\u0025\u0063\u0029",_cffea );return nil ,_bec .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0061\u0073\u0063\u0069\u0069\u0020\u0068e\u0078 \u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u0020\u0028\u0025\u0063\u0029",_cffea );};};if len (_bce )%2==1{_bce =append (_bce ,'0');};_fg .Log .Trace ("\u0049\u006e\u0062\u006f\u0075\u006e\u0064\u0020\u0025\u0073",_bce );_fabd :=make ([]byte ,_gb .DecodedLen (len (_bce )));_ ,_cbgf :=_gb .Decode (_fabd ,_bce );if _cbgf !=nil {return nil ,_cbgf ;};return _fabd ,nil ;};

// PdfIndirectObject represents the primitive PDF indirect object.
type PdfIndirectObject struct{PdfObjectReference ;PdfObject ;};

// RunLengthEncoder represents Run length encoding.
type RunLengthEncoder struct{};

// GetString is a helper for Get that returns a string value.
// Returns false if the key is missing or a value is not a string.
func (_bagdd *PdfObjectDictionary )GetString (key PdfObjectName )(string ,bool ){_dfgc ,_afad :=_bagdd ._addf [key ].(*PdfObjectString );if !_afad {return "",false ;};return _dfgc .Str (),true ;};

// GetTrailer returns the PDFs trailer dictionary. The trailer dictionary is typically the starting point for a PDF,
// referencing other key objects that are important in the document structure.
func (_geaa *PdfParser )GetTrailer ()*PdfObjectDictionary {return _geaa ._ddcb };

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_abfd *MultiEncoder )MakeDecodeParams ()PdfObject {if len (_abfd ._bbce )==0{return nil ;};if len (_abfd ._bbce )==1{return _abfd ._bbce [0].MakeDecodeParams ();};_afg :=MakeArray ();for _ ,_fbbg :=range _abfd ._bbce {_eade :=_fbbg .MakeDecodeParams ();if _eade ==nil {_afg .Append (MakeNull ());}else {_afg .Append (_eade );};};return _afg ;};

// NewRunLengthEncoder makes a new run length encoder
func NewRunLengthEncoder ()*RunLengthEncoder {return &RunLengthEncoder {}};

// RawEncoder implements Raw encoder/decoder (no encoding, pass through)
type RawEncoder struct{};

// DecodeBytes decodes a slice of DCT encoded bytes and returns the result.
func (_facc *DCTEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_fbeg :=_gd .NewReader (encoded );_daef ,_fcdf :=_be .Decode (_fbeg );if _fcdf !=nil {_fg .Log .Debug ("\u0045r\u0072\u006f\u0072\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006eg\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073",_fcdf );return nil ,_fcdf ;};_fgga :=_daef .Bounds ();var _acc =make ([]byte ,_fgga .Dx ()*_fgga .Dy ()*_facc .ColorComponents *_facc .BitsPerComponent /8);_ceda :=0;for _cec :=_fgga .Min .Y ;_cec < _fgga .Max .Y ;_cec ++{for _fgb :=_fgga .Min .X ;_fgb < _fgga .Max .X ;_fgb ++{_daa :=_daef .At (_fgb ,_cec );if _facc .ColorComponents ==1{if _facc .BitsPerComponent ==16{_gfda ,_ceag :=_daa .(_da .Gray16 );if !_ceag {return nil ,_d .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_acc [_ceda ]=byte ((_gfda .Y >>8)&0xff);_ceda ++;_acc [_ceda ]=byte (_gfda .Y &0xff);_ceda ++;}else {_ebcd ,_bfad :=_daa .(_da .Gray );if !_bfad {return nil ,_d .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_acc [_ceda ]=byte (_ebcd .Y &0xff);_ceda ++;};}else if _facc .ColorComponents ==3{if _facc .BitsPerComponent ==16{_dbab ,_egfe :=_daa .(_da .RGBA64 );if !_egfe {return nil ,_d .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_acc [_ceda ]=byte ((_dbab .R >>8)&0xff);_ceda ++;_acc [_ceda ]=byte (_dbab .R &0xff);_ceda ++;_acc [_ceda ]=byte ((_dbab .G >>8)&0xff);_ceda ++;_acc [_ceda ]=byte (_dbab .G &0xff);_ceda ++;_acc [_ceda ]=byte ((_dbab .B >>8)&0xff);_ceda ++;_acc [_ceda ]=byte (_dbab .B &0xff);_ceda ++;}else {_gcca ,_faeb :=_daa .(_da .RGBA );if _faeb {_acc [_ceda ]=_gcca .R &0xff;_ceda ++;_acc [_ceda ]=_gcca .G &0xff;_ceda ++;_acc [_ceda ]=_gcca .B &0xff;_ceda ++;}else {_cbea ,_edaf :=_daa .(_da .YCbCr );if !_edaf {return nil ,_d .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_befc ,_ead ,_ggbe ,_ :=_cbea .RGBA ();_acc [_ceda ]=byte (_befc >>8);_ceda ++;_acc [_ceda ]=byte (_ead >>8);_ceda ++;_acc [_ceda ]=byte (_ggbe >>8);_ceda ++;};};}else if _facc .ColorComponents ==4{_agbf ,_eabb :=_daa .(_da .CMYK );if !_eabb {return nil ,_d .New ("\u0063\u006fl\u006f\u0072\u0020t\u0079\u0070\u0065\u0020\u0065\u0072\u0072\u006f\u0072");};_acc [_ceda ]=255-_agbf .C &0xff;_ceda ++;_acc [_ceda ]=255-_agbf .M &0xff;_ceda ++;_acc [_ceda ]=255-_agbf .Y &0xff;_ceda ++;_acc [_ceda ]=255-_agbf .K &0xff;_ceda ++;};};};return _acc ,nil ;};

// MakeArrayFromIntegers creates an PdfObjectArray from a slice of ints, where each array element is
// an PdfObjectInteger.
func MakeArrayFromIntegers (vals []int )*PdfObjectArray {_faca :=MakeArray ();for _ ,_cgfg :=range vals {_faca .Append (MakeInteger (int64 (_cgfg )));};return _faca ;};

// PdfCrypt provides PDF encryption/decryption support.
// The PDF standard supports encryption of strings and streams (Section 7.6).
type PdfCrypt struct{_dge encryptDict ;_fgag _ag .StdEncryptDict ;_cbb string ;_cge []byte ;_fgc map[PdfObject ]bool ;_bac map[PdfObject ]bool ;_aaa bool ;_eae cryptFilters ;_dec string ;_acd string ;_cgd *PdfParser ;_cfbg map[int ]struct{};};func _cafe ()string {return _fg .Version };

// DecodeBytes returns the passed in slice of bytes.
// The purpose of the method is to satisfy the StreamEncoder interface.
func (_adgb *RawEncoder )DecodeBytes (encoded []byte )([]byte ,error ){return encoded ,nil };type objectCache map[int ]PdfObject ;func (_ecec *PdfParser )parseNumber ()(PdfObject ,error ){return ParseNumber (_ecec ._fdfg )};

// Get returns the i-th element of the array or nil if out of bounds (by index).
func (_abgd *PdfObjectArray )Get (i int )PdfObject {if _abgd ==nil ||i >=len (_abgd ._bcgc )||i < 0{return nil ;};return _abgd ._bcgc [i ];};const _cfaag =10;

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_edeg *LZWEncoder )MakeStreamDict ()*PdfObjectDictionary {_deae :=MakeDict ();_deae .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_edeg .GetFilterName ()));_eeg :=_edeg .MakeDecodeParams ();if _eeg !=nil {_deae .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_eeg );};_deae .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (int64 (_edeg .EarlyChange )));return _deae ;};

// GetBool returns the *PdfObjectBool object that is represented by a PdfObject directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetBool (obj PdfObject )(_dddab *PdfObjectBool ,_bbbde bool ){_dddab ,_bbbde =TraceToDirectObject (obj ).(*PdfObjectBool );return _dddab ,_bbbde ;};

// PdfObject is an interface which all primitive PDF objects must implement.
type PdfObject interface{

// String outputs a string representation of the primitive (for debugging).
String ()string ;

// WriteString outputs the PDF primitive as written to file as expected by the standard.
// TODO(dennwc): it should return a byte slice, or accept a writer
WriteString ()string ;};

// Decoded returns the PDFDocEncoding or UTF-16BE decoded string contents.
// UTF-16BE is applied when the first two bytes are 0xFE, 0XFF, otherwise decoding of
// PDFDocEncoding is performed.
func (_afaa *PdfObjectString )Decoded ()string {if _afaa ==nil {return "";};_fcbe :=[]byte (_afaa ._fbedf );if len (_fcbe )>=2&&_fcbe [0]==0xFE&&_fcbe [1]==0xFF{return _cf .UTF16ToString (_fcbe [2:]);};return _cf .PDFDocEncodingToString (_fcbe );};

// GetFilterName returns the name of the encoding filter.
func (_fafa *JBIG2Encoder )GetFilterName ()string {return StreamEncodingFilterNameJBIG2 };

// MakeArrayFromIntegers64 creates an PdfObjectArray from a slice of int64s, where each array element
// is an PdfObjectInteger.
func MakeArrayFromIntegers64 (vals []int64 )*PdfObjectArray {_ebdg :=MakeArray ();for _ ,_agee :=range vals {_ebdg .Append (MakeInteger (_agee ));};return _ebdg ;};

// XrefTable represents the cross references in a PDF, i.e. the table of objects and information
// where to access within the PDF file.
type XrefTable struct{ObjectMap map[int ]XrefObject ;_gc []XrefObject ;};

// MakeFloat creates an PdfObjectFloat from a float64.
func MakeFloat (val float64 )*PdfObjectFloat {_acdg :=PdfObjectFloat (val );return &_acdg };

// Resolve resolves the reference and returns the indirect or stream object.
// If the reference cannot be resolved, a *PdfObjectNull object is returned.
func (_bbfcg *PdfObjectReference )Resolve ()PdfObject {if _bbfcg ._ggde ==nil {return MakeNull ();};_ecda ,_ ,_eefc :=_bbfcg ._ggde .resolveReference (_bbfcg );if _eefc !=nil {_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0072\u0065\u0073\u006f\u006cv\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065r\u0065n\u0063\u0065\u003a\u0020\u0025\u0076\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074",_eefc );return MakeNull ();};if _ecda ==nil {_fg .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0072\u0065\u0073ol\u0076\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065:\u0020\u006ei\u006c\u0020\u006fb\u006a\u0065\u0063\u0074\u0020\u002d\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067 \u0061\u0020nu\u006c\u006c\u0020o\u0062\u006a\u0065\u0063\u0074");return MakeNull ();};return _ecda ;};

// Remove removes an element specified by key.
func (_ccee *PdfObjectDictionary )Remove (key PdfObjectName ){_bfdf :=-1;for _fcae ,_ccce :=range _ccee ._ccc {if _ccce ==key {_bfdf =_fcae ;break ;};};if _bfdf >=0{_ccee ._ccc =append (_ccee ._ccc [:_bfdf ],_ccee ._ccc [_bfdf +1:]...);delete (_ccee ._addf ,key );};};

// UpdateParams updates the parameter values of the encoder.
func (_aef *ASCIIHexEncoder )UpdateParams (params *PdfObjectDictionary ){};

// WriteString outputs the object as it is to be written to file.
func (_bfbc *PdfObjectFloat )WriteString ()string {return _g .FormatFloat (float64 (*_bfbc ),'f',-1,64);};var _ddd =[]PdfObjectName {"\u0056","\u0052","\u004f","\u0055","\u0050"};func _agda (_fafg ,_abgeg PdfObject ,_deda int )bool {if _deda > _cfaag {_fg .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_cfaag );return false ;};if _fafg ==nil &&_abgeg ==nil {return true ;}else if _fafg ==nil ||_abgeg ==nil {return false ;};if _b .TypeOf (_fafg )!=_b .TypeOf (_abgeg ){return false ;};switch _edefgd :=_fafg .(type ){case *PdfObjectNull ,*PdfObjectReference :return true ;case *PdfObjectName :return *_edefgd ==*(_abgeg .(*PdfObjectName ));case *PdfObjectString :return *_edefgd ==*(_abgeg .(*PdfObjectString ));case *PdfObjectInteger :return *_edefgd ==*(_abgeg .(*PdfObjectInteger ));case *PdfObjectBool :return *_edefgd ==*(_abgeg .(*PdfObjectBool ));case *PdfObjectFloat :return *_edefgd ==*(_abgeg .(*PdfObjectFloat ));case *PdfIndirectObject :return _agda (TraceToDirectObject (_fafg ),TraceToDirectObject (_abgeg ),_deda +1);case *PdfObjectArray :_acgd :=_abgeg .(*PdfObjectArray );if len ((*_edefgd )._bcgc )!=len ((*_acgd )._bcgc ){return false ;};for _egccc ,_eaed :=range (*_edefgd )._bcgc {if !_agda (_eaed ,(*_acgd )._bcgc [_egccc ],_deda +1){return false ;};};return true ;case *PdfObjectDictionary :_fced :=_abgeg .(*PdfObjectDictionary );_ebfef ,_bfdee :=(*_edefgd )._addf ,(*_fced )._addf ;if len (_ebfef )!=len (_bfdee ){return false ;};for _fgea ,_acggg :=range _ebfef {_eace ,_bedga :=_bfdee [_fgea ];if !_bedga ||!_agda (_acggg ,_eace ,_deda +1){return false ;};};return true ;case *PdfObjectStream :_bbfg :=_abgeg .(*PdfObjectStream );return _agda ((*_edefgd ).PdfObjectDictionary ,(*_bbfg ).PdfObjectDictionary ,_deda +1);default:_fg .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",_fafg );};return false ;};

// GetObjectStreams returns the *PdfObjectStreams represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetObjectStreams (obj PdfObject )(_cecccg *PdfObjectStreams ,_dbfcf bool ){_cecccg ,_dbfcf =obj .(*PdfObjectStreams );return _cecccg ,_dbfcf ;};

// WriteString outputs the object as it is to be written to file.
func (_bgba *PdfObjectBool )WriteString ()string {if *_bgba {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};func (_cadc *PdfParser )xrefNextObjectOffset (_eede int64 )int64 {_beefb :=int64 (0);if len (_cadc ._dfcg .ObjectMap )==0{return 0;};if len (_cadc ._dfcg ._gc )==0{_bceab :=0;for _ ,_fgec :=range _cadc ._dfcg .ObjectMap {if _fgec .Offset > 0{_bceab ++;};};if _bceab ==0{return 0;};_cadc ._dfcg ._gc =make ([]XrefObject ,_bceab );_ccab :=0;for _ ,_dcgb :=range _cadc ._dfcg .ObjectMap {if _dcgb .Offset > 0{_cadc ._dfcg ._gc [_ccab ]=_dcgb ;_ccab ++;};};_a .Slice (_cadc ._dfcg ._gc ,func (_cfc ,_gaca int )bool {return _cadc ._dfcg ._gc [_cfc ].Offset < _cadc ._dfcg ._gc [_gaca ].Offset });};_eeac :=_a .Search (len (_cadc ._dfcg ._gc ),func (_abfgg int )bool {return _cadc ._dfcg ._gc [_abfgg ].Offset >=_eede });if _eeac < len (_cadc ._dfcg ._gc ){_beefb =_cadc ._dfcg ._gc [_eeac ].Offset ;};return _beefb ;};

// Encode encodes previously prepare jbig2 document and stores it as the byte slice.
func (_efeg *JBIG2Encoder )Encode ()(_egb []byte ,_ddgf error ){const _dbba ="J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0045\u006eco\u0064\u0065";if _efeg ._dagf ==nil {return nil ,_bee .Errorf (_dbba ,"\u0064\u006f\u0063u\u006d\u0065\u006e\u0074 \u0069\u006e\u0070\u0075\u0074\u0020\u0064a\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006e\u0065\u0064");};_efeg ._dagf .FullHeaders =_efeg .DefaultPageSettings .FileMode ;_egb ,_ddgf =_efeg ._dagf .Encode ();if _ddgf !=nil {return nil ,_bee .Wrap (_ddgf ,_dbba ,"");};return _egb ,nil ;};

// GetFilterName returns the name of the encoding filter.
func (_ddaf *DCTEncoder )GetFilterName ()string {return StreamEncodingFilterNameDCT };

// DecodeBytes decodes a slice of JBIG2 encoded bytes and returns the results.
func (_ecde *JBIG2Encoder )DecodeBytes (encoded []byte )([]byte ,error ){return _eb .DecodeBytes (encoded ,_cc .Parameters {},_ecde .Globals );};

// NewFlateEncoder makes a new flate encoder with default parameters, predictor 1 and bits per component 8.
func NewFlateEncoder ()*FlateEncoder {_ggdf :=&FlateEncoder {};_ggdf .Predictor =1;_ggdf .BitsPerComponent =8;_ggdf .Colors =1;_ggdf .Columns =1;return _ggdf ;};

// ReadAtLeast reads at least n bytes into slice p.
// Returns the number of bytes read (should always be == n), and an error on failure.
func (_aaed *PdfParser )ReadAtLeast (p []byte ,n int )(int ,error ){_fgacg :=n ;_caae :=0;_ccfg :=0;for _fgacg > 0{_ddecd ,_ebfc :=_aaed ._fdfg .Read (p [_caae :]);if _ebfc !=nil {_fg .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0046\u0061i\u006c\u0065\u0064\u0020\u0072\u0065\u0061d\u0069\u006e\u0067\u0020\u0028\u0025\u0064\u003b\u0025\u0064\u0029\u0020\u0025\u0073",_ddecd ,_ccfg ,_ebfc .Error ());return _caae ,_d .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065a\u0064\u0069\u006e\u0067");};_ccfg ++;_caae +=_ddecd ;_fgacg -=_ddecd ;};return _caae ,nil ;};func _gde (_ffg *_ag .StdEncryptDict ,_db *PdfObjectDictionary ){_db .Set ("\u0052",MakeInteger (int64 (_ffg .R )));_db .Set ("\u0050",MakeInteger (int64 (_ffg .P )));_db .Set ("\u004f",MakeStringFromBytes (_ffg .O ));_db .Set ("\u0055",MakeStringFromBytes (_ffg .U ));if _ffg .R >=5{_db .Set ("\u004f\u0045",MakeStringFromBytes (_ffg .OE ));_db .Set ("\u0055\u0045",MakeStringFromBytes (_ffg .UE ));_db .Set ("\u0045n\u0063r\u0079\u0070\u0074\u004d\u0065\u0074\u0061\u0064\u0061\u0074\u0061",MakeBool (_ffg .EncryptMetadata ));if _ffg .R > 5{_db .Set ("\u0050\u0065\u0072m\u0073",MakeStringFromBytes (_ffg .Perms ));};};};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_bbgd *RawEncoder )MakeStreamDict ()*PdfObjectDictionary {return MakeDict ()};

// Resolve resolves a PdfObject to direct object, looking up and resolving references as needed (unlike TraceToDirect).
func (_aac *PdfParser )Resolve (obj PdfObject )(PdfObject ,error ){_dgf ,_fb :=obj .(*PdfObjectReference );if !_fb {return obj ,nil ;};_ebea :=_aac .GetFileOffset ();defer func (){_aac .SetFileOffset (_ebea )}();_ebef ,_ggc :=_aac .LookupByReference (*_dgf );if _ggc !=nil {return nil ,_ggc ;};_ca ,_bfd :=_ebef .(*PdfIndirectObject );if !_bfd {return _ebef ,nil ;};_ebef =_ca .PdfObject ;_ ,_fb =_ebef .(*PdfObjectReference );if _fb {return _ca ,_d .New ("\u006d\u0075lt\u0069\u0020\u0064e\u0070\u0074\u0068\u0020tra\u0063e \u0070\u006f\u0069\u006e\u0074\u0065\u0072 t\u006f\u0020\u0070\u006f\u0069\u006e\u0074e\u0072");};return _ebef ,nil ;};func (_beg *FlateEncoder )postDecodePredict (_egfga []byte )([]byte ,error ){if _beg .Predictor > 1{if _beg .Predictor ==2{_fg .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_fg .Log .Trace ("\u0043\u006f\u006c\u006f\u0072\u0073\u003a\u0020\u0025\u0064",_beg .Colors );_befb :=int (_beg .Columns )*_beg .Colors ;if _befb < 1{return []byte {},nil ;};_cega :=len (_egfga )/_befb ;if len (_egfga )%_befb !=0{_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");return nil ,_bec .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_egfga ),_befb );};if _befb %_beg .Colors !=0{return nil ,_bec .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_befb ,_beg .Colors );};if _befb > len (_egfga ){_fg .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_befb ,len (_egfga ));return nil ,_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_fg .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_egfga ),_egfga );_bcbe :=_gd .NewBuffer (nil );for _cgbe :=0;_cgbe < _cega ;_cgbe ++{_eff :=_egfga [_befb *_cgbe :_befb *(_cgbe +1)];for _afe :=_beg .Colors ;_afe < _befb ;_afe ++{_eff [_afe ]+=_eff [_afe -_beg .Colors ];};_bcbe .Write (_eff );};_bagdg :=_bcbe .Bytes ();_fg .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_bagdg ),_bagdg );return _bagdg ,nil ;}else if _beg .Predictor >=10&&_beg .Predictor <=15{_fg .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_aaeb :=int (_beg .Columns *_beg .Colors +1);_gdcd :=len (_egfga )/_aaeb ;if len (_egfga )%_aaeb !=0{return nil ,_bec .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_egfga ),_aaeb );};if _aaeb > len (_egfga ){_fg .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_aaeb ,len (_egfga ));return nil ,_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_eaaf :=_gd .NewBuffer (nil );_fg .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_beg .Columns );_fg .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_egfga ),_aaeb ,_gdcd );_gdba :=make ([]byte ,_aaeb );for _dddc :=0;_dddc < _aaeb ;_dddc ++{_gdba [_dddc ]=0;};_beea :=_beg .Colors ;for _eafc :=0;_eafc < _gdcd ;_eafc ++{_bfg :=_egfga [_aaeb *_eafc :_aaeb *(_eafc +1)];_cafa :=_bfg [0];switch _cafa {case _dcab :case _dcd :for _adef :=1+_beea ;_adef < _aaeb ;_adef ++{_bfg [_adef ]+=_bfg [_adef -_beea ];};case _cefd :for _gdebae :=1;_gdebae < _aaeb ;_gdebae ++{_bfg [_gdebae ]+=_gdba [_gdebae ];};case _gegc :for _bfcb :=1;_bfcb < _beea +1;_bfcb ++{_bfg [_bfcb ]+=_gdba [_bfcb ]/2;};for _dgfd :=_beea +1;_dgfd < _aaeb ;_dgfd ++{_bfg [_dgfd ]+=byte ((int (_bfg [_dgfd -_beea ])+int (_gdba [_dgfd ]))/2);};case _dcc :for _fcda :=1;_fcda < _aaeb ;_fcda ++{var _eggf ,_baf ,_fda byte ;_baf =_gdba [_fcda ];if _fcda >=_beea +1{_eggf =_bfg [_fcda -_beea ];_fda =_gdba [_fcda -_beea ];};_bfg [_fcda ]+=_cgeb (_eggf ,_baf ,_fda );};default:_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029\u0020\u0040\u0072o\u0077\u0020\u0025\u0064",_cafa ,_eafc );return nil ,_bec .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_cafa );};copy (_gdba ,_bfg );_eaaf .Write (_bfg [1:]);};_abcg :=_eaaf .Bytes ();return _abcg ,nil ;}else {_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_beg .Predictor );return nil ,_bec .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_beg .Predictor );};};return _egfga ,nil ;};func (_cbab *FlateEncoder )cleanImageData (_cdfa []byte )([]byte ,error ){if _cbab ._cage ==nil {return _cdfa ,nil ;};if _cbab ._cage .BitsPerComponent >=8{return _cdfa ,nil ;};_fge :=_cbab ._cage .BitsPerComponent *_cbab ._cage .Width *_cbab ._cage .ColorComponents *_cbab ._cage .Height /8;_cdfa =_cdfa [:_fge ];var _effe error ;_cdfa ,_effe =_ba .AddDataPadding (_cbab ._cage .Width ,_cbab ._cage .Height ,_cbab ._cage .BitsPerComponent ,_cbab ._cage .ColorComponents ,_cdfa );if _effe !=nil {return nil ,_effe ;};return _cdfa ,nil ;};

// MakeDict creates and returns an empty PdfObjectDictionary.
func MakeDict ()*PdfObjectDictionary {_fabb :=&PdfObjectDictionary {};_fabb ._addf =map[PdfObjectName ]PdfObject {};_fabb ._ccc =[]PdfObjectName {};return _fabb ;};func _ede (_cdae XrefTable ){_fg .Log .Debug ("\u003dX\u003d\u0058\u003d\u0058\u003d");_fg .Log .Debug ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");_cff :=0;for _ ,_ace :=range _cdae .ObjectMap {_fg .Log .Debug ("i\u002b\u0031\u003a\u0020\u0025\u0064 \u0028\u006f\u0062\u006a\u0020\u006eu\u006d\u003a\u0020\u0025\u0064\u0020\u0067e\u006e\u003a\u0020\u0025\u0064\u0029\u0020\u002d\u003e\u0020%\u0064",_cff +1,_ace .ObjectNumber ,_ace .Generation ,_ace .Offset );_cff ++;};};

// UpdateParams updates the parameter values of the encoder.
func (_ddg *RawEncoder )UpdateParams (params *PdfObjectDictionary ){};

// Decrypt attempts to decrypt the PDF file with a specified password.  Also tries to
// decrypt with an empty password.  Returns true if successful, false otherwise.
// An error is returned when there is a problem with decrypting.
func (_aeddf *PdfParser )Decrypt (password []byte )(bool ,error ){if _aeddf ._dgfca ==nil {return false ,_d .New ("\u0063\u0068\u0065\u0063k \u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0066\u0069\u0072s\u0074");};_decg ,_gadcc :=_aeddf ._dgfca .authenticate (password );if _gadcc !=nil {return false ,_gadcc ;};if !_decg {_decg ,_gadcc =_aeddf ._dgfca .authenticate ([]byte (""));};return _decg ,_gadcc ;};

// GetFilterName returns the name of the encoding filter.
func (_gaea *JPXEncoder )GetFilterName ()string {return StreamEncodingFilterNameJPX };func (_gef *PdfObjectInteger )String ()string {return _bec .Sprintf ("\u0025\u0064",*_gef )};var (ErrUnsupportedEncodingParameters =_d .New ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0070\u0061\u0072\u0061\u006d\u0065\u0074\u0065\u0072\u0073");ErrNoCCITTFaxDecode =_d .New ("\u0043\u0043I\u0054\u0054\u0046\u0061\u0078\u0044\u0065\u0063\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");ErrNoJBIG2Decode =_d .New ("\u004a\u0042\u0049\u0047\u0032\u0044\u0065c\u006f\u0064\u0065 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");ErrNoJPXDecode =_d .New ("\u004a\u0050\u0058\u0044\u0065c\u006f\u0064\u0065\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020i\u0073\u0020\u006e\u006f\u0074\u0020\u0079\u0065\u0074\u0020\u0069\u006d\u0070\u006c\u0065\u006d\u0065\u006e\u0074\u0065\u0064");ErrNoPdfVersion =_d .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");ErrTypeError =_d .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");ErrRangeError =_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");ErrNotSupported =_d .New ("\u0066\u0065\u0061t\u0075\u0072\u0065\u0020n\u006f\u0074\u0020\u0063\u0075\u0072\u0072e\u006e\u0074\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");ErrNotANumber =_d .New ("\u006e\u006f\u0074 \u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072"););func (_efde *PdfParser )parsePdfVersion ()(int ,int ,error ){var _acbae int64 =20;_abcf :=make ([]byte ,_acbae );_efde ._aedcf .Seek (0,_ac .SEEK_SET );_efde ._aedcf .Read (_abcf );var _dffa error ;var _cedg ,_begf int ;if _adfe :=_dbee .FindStringSubmatch (string (_abcf ));len (_adfe )< 3{if _cedg ,_begf ,_dffa =_efde .seekPdfVersionTopDown ();_dffa !=nil {_fg .Log .Debug ("F\u0061\u0069\u006c\u0065\u0064\u0020\u0072\u0065\u0063\u006f\u0076\u0065\u0072\u0079\u0020\u002d\u0020\u0075n\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0066\u0069nd\u0020\u0076\u0065r\u0073i\u006f\u006e");return 0,0,_dffa ;};_efde ._aedcf ,_dffa =_cfee (_efde ._aedcf ,_efde .GetFileOffset ()-8);if _dffa !=nil {return 0,0,_dffa ;};}else {if _cedg ,_dffa =_g .Atoi (_adfe [1]);_dffa !=nil {return 0,0,_dffa ;};if _begf ,_dffa =_g .Atoi (_adfe [2]);_dffa !=nil {return 0,0,_dffa ;};_efde .SetFileOffset (0);};_efde ._fdfg =_af .NewReader (_efde ._aedcf );_fg .Log .Debug ("\u0050\u0064\u0066\u0020\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020%\u0064\u002e\u0025\u0064",_cedg ,_begf );return _cedg ,_begf ,nil ;};

// IsWhiteSpace checks if byte represents a white space character.
func IsWhiteSpace (ch byte )bool {if (ch ==0x00)||(ch ==0x09)||(ch ==0x0A)||(ch ==0x0C)||(ch ==0x0D)||(ch ==0x20){return true ;};return false ;};

// FlattenObject returns the contents of `obj`. In other words, `obj` with indirect objects replaced
// by their values.
// The replacements are made recursively to a depth of traceMaxDepth.
// NOTE: Dicts are sorted to make objects with same contents have the same PDF object strings.
func FlattenObject (obj PdfObject )PdfObject {return _efgac (obj ,0)};func (_gffa *ASCII85Encoder )base256Tobase85 (_abacd uint32 )[5]byte {_bddb :=[5]byte {0,0,0,0,0};_eadc :=_abacd ;for _bgfd :=0;_bgfd < 5;_bgfd ++{_gggf :=uint32 (1);for _bcea :=0;_bcea < 4-_bgfd ;_bcea ++{_gggf *=85;};_gdda :=_eadc /_gggf ;_eadc =_eadc %_gggf ;_bddb [_bgfd ]=byte (_gdda );};return _bddb ;};func (_gddag *PdfParser )skipSpaces ()(int ,error ){_aecca :=0;for {_edbe ,_ebcc :=_gddag ._fdfg .ReadByte ();if _ebcc !=nil {return 0,_ebcc ;};if IsWhiteSpace (_edbe ){_aecca ++;}else {_gddag ._fdfg .UnreadByte ();break ;};};return _aecca ,nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_bbcf *CCITTFaxEncoder )MakeStreamDict ()*PdfObjectDictionary {_ccba :=MakeDict ();_ccba .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_bbcf .GetFilterName ()));_bbfc :=_bbcf .MakeDecodeParams ();if _bbfc !=nil {_ccba .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_bbfc );};return _ccba ;};type offsetReader struct{_fdab _f .ReadSeeker ;_acbaf int64 ;};

// PdfObjectArray represents the primitive PDF array object.
type PdfObjectArray struct{_bcgc []PdfObject };

// WriteString outputs the object as it is to be written to file.
func (_efaag *PdfIndirectObject )WriteString ()string {var _eceb _gg .Builder ;_eceb .WriteString (_g .FormatInt (_efaag .ObjectNumber ,10));_eceb .WriteString ("\u0020\u0030\u0020\u0052");return _eceb .String ();};

// ASCIIHexEncoder implements ASCII hex encoder/decoder.
type ASCIIHexEncoder struct{};func _dbbf (_dcce *PdfObjectStream ,_gacb *MultiEncoder )(*DCTEncoder ,error ){_gccf :=NewDCTEncoder ();_dbae :=_dcce .PdfObjectDictionary ;if _dbae ==nil {return _gccf ,nil ;};_gdgd :=_dcce .Stream ;if _gacb !=nil {_agcf ,_cgff :=_gacb .DecodeBytes (_gdgd );if _cgff !=nil {return nil ,_cgff ;};_gdgd =_agcf ;};_bdaa :=_gd .NewReader (_gdgd );_fbcf ,_egab :=_be .DecodeConfig (_bdaa );if _egab !=nil {_fg .Log .Debug ("\u0045\u0072\u0072or\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0065\u003a\u0020\u0025\u0073",_egab );return nil ,_egab ;};switch _fbcf .ColorModel {case _da .RGBAModel :_gccf .BitsPerComponent =8;_gccf .ColorComponents =3;case _da .RGBA64Model :_gccf .BitsPerComponent =16;_gccf .ColorComponents =3;case _da .GrayModel :_gccf .BitsPerComponent =8;_gccf .ColorComponents =1;case _da .Gray16Model :_gccf .BitsPerComponent =16;_gccf .ColorComponents =1;case _da .CMYKModel :_gccf .BitsPerComponent =8;_gccf .ColorComponents =4;case _da .YCbCrModel :_gccf .BitsPerComponent =8;_gccf .ColorComponents =3;default:return nil ,_d .New ("\u0075\u006e\u0073up\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u006d\u006f\u0064\u0065\u006c");};_gccf .Width =_fbcf .Width ;_gccf .Height =_fbcf .Height ;_fg .Log .Trace ("\u0044\u0043T\u0020\u0045\u006ec\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076",_gccf );_gccf .Quality =DefaultJPEGQuality ;return _gccf ,nil ;};func _ddgb (_ggea PdfObject ,_acdf int ,_cfbac map[PdfObject ]struct{})error {_fg .Log .Trace ("\u0054\u0072\u0061\u0076\u0065\u0072s\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0064\u0061\u0074\u0061 \u0028\u0064\u0065\u0070\u0074\u0068\u0020=\u0020\u0025\u0064\u0029",_acdf );if _ ,_bbecg :=_cfbac [_ggea ];_bbecg {_fg .Log .Trace ("-\u0041\u006c\u0072\u0065ad\u0079 \u0074\u0072\u0061\u0076\u0065r\u0073\u0065\u0064\u002e\u002e\u002e");return nil ;};_cfbac [_ggea ]=struct{}{};switch _afgad :=_ggea .(type ){case *PdfIndirectObject :_cgca :=_afgad ;_fg .Log .Trace ("\u0069\u006f\u003a\u0020\u0025\u0073",_cgca );_fg .Log .Trace ("\u002d\u0020\u0025\u0073",_cgca .PdfObject );return _ddgb (_cgca .PdfObject ,_acdf +1,_cfbac );case *PdfObjectStream :_eaef :=_afgad ;return _ddgb (_eaef .PdfObjectDictionary ,_acdf +1,_cfbac );case *PdfObjectDictionary :_ceab :=_afgad ;_fg .Log .Trace ("\u002d\u0020\u0064\u0069\u0063\u0074\u003a\u0020\u0025\u0073",_ceab );for _ ,_cbdf :=range _ceab .Keys (){_cbfa :=_ceab .Get (_cbdf );if _dbeb ,_dbedf :=_cbfa .(*PdfObjectReference );_dbedf {_beacfb :=_dbeb .Resolve ();_ceab .Set (_cbdf ,_beacfb );_aabc :=_ddgb (_beacfb ,_acdf +1,_cfbac );if _aabc !=nil {return _aabc ;};}else {_ggdee :=_ddgb (_cbfa ,_acdf +1,_cfbac );if _ggdee !=nil {return _ggdee ;};};};return nil ;case *PdfObjectArray :_dgcf :=_afgad ;_fg .Log .Trace ("-\u0020\u0061\u0072\u0072\u0061\u0079\u003a\u0020\u0025\u0073",_dgcf );for _gecad ,_fbcbe :=range _dgcf .Elements (){if _babe ,_efcfe :=_fbcbe .(*PdfObjectReference );_efcfe {_bcfb :=_babe .Resolve ();_dgcf .Set (_gecad ,_bcfb );_edfae :=_ddgb (_bcfb ,_acdf +1,_cfbac );if _edfae !=nil {return _edfae ;};}else {_dagg :=_ddgb (_fbcbe ,_acdf +1,_cfbac );if _dagg !=nil {return _dagg ;};};};return nil ;case *PdfObjectReference :_fg .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020T\u0072\u0061\u0063\u0069\u006e\u0067\u0020\u0061\u0020r\u0065\u0066\u0065r\u0065n\u0063\u0065\u0021");return _d .New ("\u0065r\u0072\u006f\u0072\u0020t\u0072\u0061\u0063\u0069\u006eg\u0020a\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");};return nil ;};

// ToFloat64Array returns a slice of all elements in the array as a float64 slice.  An error is
// returned if the array contains non-numeric objects (each element can be either PdfObjectInteger
// or PdfObjectFloat).
func (_ebbfg *PdfObjectArray )ToFloat64Array ()([]float64 ,error ){var _dcdf []float64 ;for _ ,_cbcbf :=range _ebbfg .Elements (){switch _baga :=_cbcbf .(type ){case *PdfObjectInteger :_dcdf =append (_dcdf ,float64 (*_baga ));case *PdfObjectFloat :_dcdf =append (_dcdf ,float64 (*_baga ));default:return nil ,ErrTypeError ;};};return _dcdf ,nil ;};

// Elements returns a slice of the PdfObject elements in the array.
// Preferred over accessing the array directly as type may be changed in future major versions (v3).
func (_ffbc *PdfObjectStreams )Elements ()[]PdfObject {if _ffbc ==nil {return nil ;};return _ffbc ._eaeed ;};type xrefType int ;

// GetFilterName returns the name of the encoding filter.
func (_dbf *RunLengthEncoder )GetFilterName ()string {return StreamEncodingFilterNameRunLength };func (_ggbba *PdfParser )readComment ()(string ,error ){var _faba _gd .Buffer ;_ ,_ceac :=_ggbba .skipSpaces ();if _ceac !=nil {return _faba .String (),_ceac ;};_baad :=true ;for {_ebeff ,_gabe :=_ggbba ._fdfg .Peek (1);if _gabe !=nil {_fg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_gabe .Error ());return _faba .String (),_gabe ;};if _baad &&_ebeff [0]!='%'{return _faba .String (),_d .New ("c\u006f\u006d\u006d\u0065\u006e\u0074 \u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0073\u0074a\u0072\u0074\u0020w\u0069t\u0068\u0020\u0025");};_baad =false ;if (_ebeff [0]!='\r')&&(_ebeff [0]!='\n'){_daab ,_ :=_ggbba ._fdfg .ReadByte ();_faba .WriteByte (_daab );}else {break ;};};return _faba .String (),nil ;};

// String returns a string representation of `name`.
func (_bbbfb *PdfObjectName )String ()string {return string (*_bbbfb )};func (_bbd *PdfCrypt )isDecrypted (_gdd PdfObject )bool {_ ,_cfed :=_bbd ._fgc [_gdd ];if _cfed {_fg .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0064\u0065\u0063\u0072y\u0070\u0074\u0065\u0064");return true ;};switch _cegf :=_gdd .(type ){case *PdfObjectStream :if _bbd ._fgag .R !=5{if _dfb ,_edeb :=_cegf .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_edeb &&*_dfb =="\u0058\u0052\u0065\u0066"{return true ;};};case *PdfIndirectObject :if _ ,_cfed =_bbd ._cfbg [int (_cegf .ObjectNumber )];_cfed {return true ;};switch _cdb :=_cegf .PdfObject .(type ){case *PdfObjectDictionary :_daec :=true ;for _ ,_ecb :=range _ddd {if _cdb .Get (_ecb )==nil {_daec =false ;break ;};};if _daec {return true ;};};};_fg .Log .Trace ("\u004e\u006f\u0074\u0020\u0064\u0065\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");return false ;};func (_aeg *PdfCrypt )isEncrypted (_gaf PdfObject )bool {_ ,_efda :=_aeg ._bac [_gaf ];if _efda {_fg .Log .Trace ("\u0041\u006c\u0072\u0065\u0061\u0064\u0079\u0020\u0065\u006e\u0063\u0072y\u0070\u0074\u0065\u0064");return true ;};_fg .Log .Trace ("\u004e\u006f\u0074\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065d\u0020\u0079\u0065\u0074");return false ;};func (_fac *PdfCrypt )authenticate (_gae []byte )(bool ,error ){_fac ._aaa =false ;_bgd :=_fac .securityHandler ();_fbba ,_gdb ,_bbcb :=_bgd .Authenticate (&_fac ._fgag ,_gae );if _bbcb !=nil {return false ,_bbcb ;}else if _gdb ==0||len (_fbba )==0{return false ,nil ;};_fac ._aaa =true ;_fac ._cge =_fbba ;return true ,nil ;};type cryptFilters map[string ]_bgg .Filter ;const (JB2Generic JBIG2CompressionType =iota ;JB2SymbolCorrelation ;JB2SymbolRankHaus ;);

// String returns a string describing `streams`.
func (_afbcd *PdfObjectStreams )String ()string {return _bec .Sprintf ("\u004f\u0062j\u0065\u0063\u0074 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0025\u0064",_afbcd .ObjectNumber );};

// NewParserFromString is used for testing purposes.
func NewParserFromString (txt string )*PdfParser {_gdde :=_gd .NewReader ([]byte (txt ));_cab :=&PdfParser {ObjCache :objectCache {},_aedcf :_gdde ,_fdfg :_af .NewReader (_gdde ),_egbf :int64 (len (txt )),_fafe :map[int64 ]bool {}};_cab ._dfcg .ObjectMap =make (map[int ]XrefObject );return _cab ;};

// EncodeBytes implements support for LZW encoding.  Currently not supporting predictors (raw compressed data only).
// Only supports the Early change = 1 algorithm (compress/lzw) as the other implementation
// does not have a write method.
// TODO: Consider refactoring compress/lzw to allow both.
func (_cagc *LZWEncoder )EncodeBytes (data []byte )([]byte ,error ){if _cagc .Predictor !=1{return nil ,_bec .Errorf ("\u004c\u005aW \u0050\u0072\u0065d\u0069\u0063\u0074\u006fr =\u00201 \u006f\u006e\u006c\u0079\u0020\u0073\u0075pp\u006f\u0072\u0074\u0065\u0064\u0020\u0079e\u0074");};if _cagc .EarlyChange ==1{return nil ,_bec .Errorf ("\u004c\u005a\u0057\u0020\u0045\u0061\u0072\u006c\u0079\u0020\u0043\u0068\u0061n\u0067\u0065\u0020\u003d\u0020\u0030 \u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0079\u0065\u0074");};var _gebf _gd .Buffer ;_egc :=_ea .NewWriter (&_gebf ,_ea .MSB ,8);_egc .Write (data );_egc .Close ();return _gebf .Bytes (),nil ;};

// MakeArray creates an PdfObjectArray from a list of PdfObjects.
func MakeArray (objects ...PdfObject )*PdfObjectArray {_gdcb :=&PdfObjectArray {};_gdcb ._bcgc =[]PdfObject {};for _ ,_eaag :=range objects {_gdcb ._bcgc =append (_gdcb ._bcgc ,_eaag );};return _gdcb ;};

// GetParser returns the parser for lazy-loading or compare references.
func (_eagf *PdfObjectReference )GetParser ()*PdfParser {return _eagf ._ggde };

// NewParser creates a new parser for a PDF file via ReadSeeker. Loads the cross reference stream and trailer.
// An error is returned on failure.
func NewParser (rs _f .ReadSeeker )(*PdfParser ,error ){_ccgd :=&PdfParser {_aedcf :rs ,ObjCache :make (objectCache ),_fafe :map[int64 ]bool {}};_ggcb ,_cdec ,_efcb :=_ccgd .parsePdfVersion ();if _efcb !=nil {_fg .Log .Error ("U\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0076e\u0072\u0073\u0069o\u006e:\u0020\u0025\u0076",_efcb );return nil ,_efcb ;};_ccgd ._ceage .Major =_ggcb ;_ccgd ._ceage .Minor =_cdec ;if _ccgd ._ddcb ,_efcb =_ccgd .loadXrefs ();_efcb !=nil {_fg .Log .Debug ("\u0045\u0052RO\u0052\u003a\u0020F\u0061\u0069\u006c\u0065d t\u006f l\u006f\u0061\u0064\u0020\u0078\u0072\u0065f \u0074\u0061\u0062\u006c\u0065\u0021\u0020%\u0073",_efcb );return nil ,_efcb ;};_fg .Log .Trace ("T\u0072\u0061\u0069\u006c\u0065\u0072\u003a\u0020\u0025\u0073",_ccgd ._ddcb );if len (_ccgd ._dfcg .ObjectMap )==0{return nil ,_bec .Errorf ("\u0065\u006d\u0070\u0074\u0079\u0020\u0058\u0052\u0045\u0046\u0020t\u0061\u0062\u006c\u0065\u0020\u002d\u0020\u0049\u006e\u0076a\u006c\u0069\u0064");};return _ccgd ,nil ;};var _dcgc =_ga .MustCompile ("\u005b\\\u0072\u005c\u006e\u005d\u005c\u0073\u002a\u0028\u0078\u0072\u0065f\u0029\u005c\u0073\u002a\u005b\u005c\u0072\u005c\u006e\u005d");

// GetAccessPermissions returns the PDF access permissions as an AccessPermissions object.
func (_cba *PdfCrypt )GetAccessPermissions ()_ag .Permissions {return _cba ._fgag .P };func (_bfegf *PdfParser )resolveReference (_bcag *PdfObjectReference )(PdfObject ,bool ,error ){_bfec ,_bdcf :=_bfegf .ObjCache [int (_bcag .ObjectNumber )];if _bdcf {return _bfec ,true ,nil ;};_ggfb ,_aaeg :=_bfegf .LookupByReference (*_bcag );if _aaeg !=nil {return nil ,false ,_aaeg ;};_bfegf .ObjCache [int (_bcag .ObjectNumber )]=_ggfb ;return _ggfb ,false ,nil ;};func (_ddefc *PdfParser )parseObject ()(PdfObject ,error ){_fg .Log .Trace ("\u0052e\u0061d\u0020\u0064\u0069\u0072\u0065c\u0074\u0020o\u0062\u006a\u0065\u0063\u0074");_ddefc .skipSpaces ();for {_dffb ,_bcdf :=_ddefc ._fdfg .Peek (2);if _bcdf !=nil {if _bcdf !=_f .EOF ||len (_dffb )==0{return nil ,_bcdf ;};if len (_dffb )==1{_dffb =append (_dffb ,' ');};};_fg .Log .Trace ("\u0050e\u0065k\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u003a\u0020\u0025\u0073",string (_dffb ));if _dffb [0]=='/'{_gdaf ,_fagg :=_ddefc .parseName ();_fg .Log .Trace ("\u002d\u003e\u004ea\u006d\u0065\u003a\u0020\u0027\u0025\u0073\u0027",_gdaf );return &_gdaf ,_fagg ;}else if _dffb [0]=='('{_fg .Log .Trace ("\u002d>\u0053\u0074\u0072\u0069\u006e\u0067!");_fbaf ,_fgbe :=_ddefc .parseString ();return _fbaf ,_fgbe ;}else if _dffb [0]=='['{_fg .Log .Trace ("\u002d\u003e\u0041\u0072\u0072\u0061\u0079\u0021");_bfceag ,_dgeed :=_ddefc .parseArray ();return _bfceag ,_dgeed ;}else if (_dffb [0]=='<')&&(_dffb [1]=='<'){_fg .Log .Trace ("\u002d>\u0044\u0069\u0063\u0074\u0021");_aaadf ,_ebcdd :=_ddefc .ParseDict ();return _aaadf ,_ebcdd ;}else if _dffb [0]=='<'{_fg .Log .Trace ("\u002d\u003e\u0048\u0065\u0078\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0021");_ebd ,_bgdf :=_ddefc .parseHexString ();return _ebd ,_bgdf ;}else if _dffb [0]=='%'{_ddefc .readComment ();_ddefc .skipSpaces ();}else {_fg .Log .Trace ("\u002d\u003eN\u0075\u006d\u0062e\u0072\u0020\u006f\u0072\u0020\u0072\u0065\u0066\u003f");_dffb ,_ =_ddefc ._fdfg .Peek (15);_bced :=string (_dffb );_fg .Log .Trace ("\u0050\u0065\u0065k\u0020\u0073\u0074\u0072\u003a\u0020\u0025\u0073",_bced );if (len (_bced )> 3)&&(_bced [:4]=="\u006e\u0075\u006c\u006c"){_bedg ,_bbeb :=_ddefc .parseNull ();return &_bedg ,_bbeb ;}else if (len (_bced )> 4)&&(_bced [:5]=="\u0066\u0061\u006cs\u0065"){_feee ,_gbgf :=_ddefc .parseBool ();return &_feee ,_gbgf ;}else if (len (_bced )> 3)&&(_bced [:4]=="\u0074\u0072\u0075\u0065"){_dgeb ,_gfgc :=_ddefc .parseBool ();return &_dgeb ,_gfgc ;};_gggd :=_cedag .FindStringSubmatch (string (_bced ));if len (_gggd )> 1{_dffb ,_ =_ddefc ._fdfg .ReadBytes ('R');_fg .Log .Trace ("\u002d\u003e\u0020\u0021\u0052\u0065\u0066\u003a\u0020\u0027\u0025\u0073\u0027",string (_dffb [:]));_bdfd ,_ccdb :=_cead (string (_dffb ));_bdfd ._ggde =_ddefc ;return &_bdfd ,_ccdb ;};_egga :=_gbbb .FindStringSubmatch (string (_bced ));if len (_egga )> 1{_fg .Log .Trace ("\u002d\u003e\u0020\u004e\u0075\u006d\u0062\u0065\u0072\u0021");_dcad ,_aefc :=_ddefc .parseNumber ();return _dcad ,_aefc ;};_egga =_geda .FindStringSubmatch (string (_bced ));if len (_egga )> 1{_fg .Log .Trace ("\u002d\u003e\u0020\u0045xp\u006f\u006e\u0065\u006e\u0074\u0069\u0061\u006c\u0020\u004e\u0075\u006d\u0062\u0065r\u0021");_fg .Log .Trace ("\u0025\u0020\u0073",_egga );_edd ,_gdcg :=_ddefc .parseNumber ();return _edd ,_gdcg ;};_fg .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020U\u006e\u006b\u006e\u006f\u0077n\u0020(\u0070e\u0065\u006b\u0020\u0022\u0025\u0073\u0022)",_bced );return nil ,_d .New ("\u006f\u0062\u006a\u0065\u0063t\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020\u0075\u006e\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0070\u0061\u0074\u0074\u0065\u0072\u006e");};};};func (_dgfa *PdfParser )parseXrefStream (_ageb *PdfObjectInteger )(*PdfObjectDictionary ,error ){if _ageb !=nil {_fg .Log .Trace ("\u0058\u0052\u0065f\u0053\u0074\u006d\u0020x\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0061\u0074\u0020\u0025\u0064",_ageb );_dgfa ._aedcf .Seek (int64 (*_ageb ),_f .SeekStart );_dgfa ._fdfg =_af .NewReader (_dgfa ._aedcf );};_ddfcd :=_dgfa .GetFileOffset ();_efg ,_dbbab :=_dgfa .ParseIndirectObject ();if _dbbab !=nil {_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072\u0065\u0061d\u0020\u0078\u0072\u0065\u0066\u0020\u006fb\u006a\u0065\u0063\u0074");return nil ,_d .New ("\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0074\u006f\u0020\u0072e\u0061\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062j\u0065\u0063\u0074");};_fg .Log .Trace ("\u0058R\u0065f\u0053\u0074\u006d\u0020\u006fb\u006a\u0065c\u0074\u003a\u0020\u0025\u0073",_efg );_ceee ,_begcb :=_efg .(*PdfObjectStream );if !_begcb {_fg .Log .Debug ("\u0045R\u0052\u004fR\u003a\u0020\u0058R\u0065\u0066\u0053\u0074\u006d\u0020\u0070o\u0069\u006e\u0074\u0069\u006e\u0067 \u0074\u006f\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065a\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0021");return nil ,_d .New ("\u0058\u0052\u0065\u0066\u0053\u0074\u006d\u0020\u0070\u006f\u0069\u006e\u0074i\u006e\u0067\u0020\u0074\u006f\u0020a\u0020\u006e\u006f\u006e\u002d\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006fb\u006a\u0065\u0063\u0074");};_ddcf :=_ceee .PdfObjectDictionary ;_bdcb ,_begcb :=_ceee .PdfObjectDictionary .Get ("\u0053\u0069\u007a\u0065").(*PdfObjectInteger );if !_begcb {_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u004d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0073\u0069\u007a\u0065\u0020f\u0072\u006f\u006d\u0020\u0078\u0072\u0065f\u0020\u0073\u0074\u006d");return nil ,_d .New ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0053\u0069\u007ae\u0020\u0066\u0072\u006f\u006d\u0020\u0078\u0072\u0065\u0066 \u0073\u0074\u006d");};if int64 (*_bdcb )> 8388607{_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0078\u0072\u0065\u0066\u0020\u0053\u0069\u007a\u0065\u0020\u0065x\u0063\u0065\u0065\u0064\u0065\u0064\u0020l\u0069\u006d\u0069\u0074\u002c\u0020\u006f\u0076\u0065\u0072\u00208\u0033\u0038\u0038\u0036\u0030\u0037\u0020\u0028\u0025\u0064\u0029",*_bdcb );return nil ,_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_gdcdf :=_ceee .PdfObjectDictionary .Get ("\u0057");_dafb ,_begcb :=_gdcdf .(*PdfObjectArray );if !_begcb {return nil ,_d .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0057\u0020\u0069\u006e\u0020x\u0072\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d");};_cfaf :=_dafb .Len ();if _cfaf !=3{_fg .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020\u0028\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033\u0020\u002d\u0020\u0025\u0064\u0029",_cfaf );return nil ,_d .New ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0078\u0072\u0065f\u0020s\u0074\u006d\u0020\u006c\u0065\u006e\u0028\u0057\u0029\u0020\u0021\u003d\u0020\u0033");};var _bacd []int64 ;for _cbff :=0;_cbff < 3;_cbff ++{_dgdbb ,_agea :=GetInt (_dafb .Get (_cbff ));if !_agea {return nil ,_d .New ("i\u006e\u0076\u0061\u006cid\u0020w\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0074\u0079\u0070\u0065");};_bacd =append (_bacd ,int64 (*_dgdbb ));};_dade ,_dbbab :=DecodeStream (_ceee );if _dbbab !=nil {_fg .Log .Debug ("\u0045\u0052\u0052OR\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020t\u006f \u0064e\u0063o\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u003a\u0020\u0025\u0076",_dbbab );return nil ,_dbbab ;};_aeef :=int (_bacd [0]);_dgbea :=int (_bacd [0]+_bacd [1]);_cffge :=int (_bacd [0]+_bacd [1]+_bacd [2]);_ffga :=int (_bacd [0]+_bacd [1]+_bacd [2]);if _aeef < 0||_dgbea < 0||_cffge < 0{_fg .Log .Debug ("\u0045\u0072\u0072\u006fr\u0020\u0073\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u003c \u0030 \u0028\u0025\u0064\u002c\u0025\u0064\u002c%\u0064\u0029",_aeef ,_dgbea ,_cffge );return nil ,_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};if _ffga ==0{_fg .Log .Debug ("\u004e\u006f\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063t\u0073\u0020\u0069\u006e\u0020\u0073t\u0072\u0065\u0061\u006d\u0020\u0028\u0064\u0065\u006c\u0074\u0061\u0062\u0020=\u003d\u0020\u0030\u0029");return _ddcf ,nil ;};_fbbgg :=len (_dade )/_ffga ;_ecfg :=0;_cedc :=_ceee .PdfObjectDictionary .Get ("\u0049\u006e\u0064e\u0078");var _ceea []int ;if _cedc !=nil {_fg .Log .Trace ("\u0049n\u0064\u0065\u0078\u003a\u0020\u0025b",_cedc );_dbed ,_egafa :=_cedc .(*PdfObjectArray );if !_egafa {_fg .Log .Debug ("\u0049\u006e\u0076\u0061\u006ci\u0064\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0029");return nil ,_d .New ("i\u006ev\u0061\u006c\u0069\u0064\u0020\u0049\u006e\u0064e\u0078\u0020\u006f\u0062je\u0063\u0074");};if _dbed .Len ()%2!=0{_fg .Log .Debug ("\u0057\u0041\u0052\u004eI\u004e\u0047\u0020\u0046\u0061\u0069\u006c\u0075\u0072e\u0020\u006c\u006f\u0061\u0064\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0073\u0074\u006d\u0020i\u006e\u0064\u0065\u0078\u0020n\u006f\u0074\u0020\u006d\u0075\u006c\u0074\u0069\u0070\u006c\u0065\u0020\u006f\u0066\u0020\u0032\u002e");return nil ,_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_ecfg =0;_aefcd ,_gfed :=_dbed .ToIntegerArray ();if _gfed !=nil {_fg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072 \u0067\u0065\u0074\u0074\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0065\u0078 \u0061\u0072\u0072\u0061\u0079\u0020\u0061\u0073\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0073\u003a\u0020\u0025\u0076",_gfed );return nil ,_gfed ;};for _cebf :=0;_cebf < len (_aefcd );_cebf +=2{_fffg :=_aefcd [_cebf ];_acdd :=_aefcd [_cebf +1];for _bacc :=0;_bacc < _acdd ;_bacc ++{_ceea =append (_ceea ,_fffg +_bacc );};_ecfg +=_acdd ;};}else {for _dffcc :=0;_dffcc < int (*_bdcb );_dffcc ++{_ceea =append (_ceea ,_dffcc );};_ecfg =int (*_bdcb );};if _fbbgg ==_ecfg +1{_fg .Log .Debug ("\u0049n\u0063\u006f\u006d\u0070ati\u0062\u0069\u006c\u0069t\u0079\u003a\u0020\u0049\u006e\u0064\u0065\u0078\u0020\u006di\u0073\u0073\u0069\u006e\u0067\u0020\u0063\u006f\u0076\u0065\u0072\u0061\u0067\u0065\u0020\u006f\u0066\u0020\u0031\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u002d\u0020\u0061\u0070\u0070en\u0064\u0069\u006eg\u0020\u006f\u006e\u0065\u0020-\u0020M\u0061\u0079\u0020\u006c\u0065\u0061\u0064\u0020\u0074o\u0020\u0070\u0072\u006f\u0062\u006c\u0065\u006d\u0073");_geaag :=_ecfg -1;for _ ,_aegg :=range _ceea {if _aegg > _geaag {_geaag =_aegg ;};};_ceea =append (_ceea ,_geaag +1);_ecfg ++;};if _fbbgg !=len (_ceea ){_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020x\u0072\u0065\u0066 \u0073\u0074\u006d:\u0020\u006eu\u006d\u0020\u0065\u006e\u0074\u0072i\u0065s \u0021\u003d\u0020\u006c\u0065\u006e\u0028\u0069\u006e\u0064\u0069\u0063\u0065\u0073\u0029\u0020\u0028\u0025\u0064\u0020\u0021\u003d\u0020\u0025\u0064\u0029",_fbbgg ,len (_ceea ));return nil ,_d .New ("\u0078\u0072ef\u0020\u0073\u0074m\u0020\u006e\u0075\u006d en\u0074ri\u0065\u0073\u0020\u0021\u003d\u0020\u006cen\u0028\u0069\u006e\u0064\u0069\u0063\u0065s\u0029");};_fg .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074s\u0020\u0063\u006f\u0075\u006e\u0074\u0020\u0025\u0064",_ecfg );_fg .Log .Trace ("\u0049\u006e\u0064i\u0063\u0065\u0073\u003a\u0020\u0025\u0020\u0064",_ceea );_fec :=func (_abeb []byte )int64 {var _eedf int64 ;for _bbcc :=0;_bbcc < len (_abeb );_bbcc ++{_eedf +=int64 (_abeb [_bbcc ])*(1<<uint (8*(len (_abeb )-_bbcc -1)));};return _eedf ;};_fg .Log .Trace ("\u0044e\u0063\u006f\u0064\u0065d\u0020\u0073\u0074\u0072\u0065a\u006d \u006ce\u006e\u0067\u0074\u0068\u003a\u0020\u0025d",len (_dade ));_dfbe :=0;for _ffcfc :=0;_ffcfc < len (_dade );_ffcfc +=_ffga {_gffc :=_fbeab (len (_dade ),_ffcfc ,_ffcfc +_aeef );if _gffc !=nil {_fg .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_gffc );return nil ,_gffc ;};_gaefg :=_dade [_ffcfc :_ffcfc +_aeef ];_gffc =_fbeab (len (_dade ),_ffcfc +_aeef ,_ffcfc +_dgbea );if _gffc !=nil {_fg .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_gffc );return nil ,_gffc ;};_dgg :=_dade [_ffcfc +_aeef :_ffcfc +_dgbea ];_gffc =_fbeab (len (_dade ),_ffcfc +_dgbea ,_ffcfc +_cffge );if _gffc !=nil {_fg .Log .Debug ("\u0049\u006e\u0076al\u0069\u0064\u0020\u0073\u006c\u0069\u0063\u0065\u0020\u0072\u0061\u006e\u0067\u0065\u003a\u0020\u0025\u0076",_gffc );return nil ,_gffc ;};_febf :=_dade [_ffcfc +_dgbea :_ffcfc +_cffge ];_aaedg :=_fec (_gaefg );_baebg :=_fec (_dgg );_egbc :=_fec (_febf );if _bacd [0]==0{_aaedg =1;};if _dfbe >=len (_ceea ){_fg .Log .Debug ("X\u0052\u0065\u0066\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u002d\u0020\u0054\u0072\u0079\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0061\u0063\u0063e\u0073s\u0020\u0069\u006e\u0064e\u0078\u0020o\u0075\u0074\u0020\u006f\u0066\u0020\u0062\u006f\u0075\u006e\u0064\u0073\u0020\u002d\u0020\u0062\u0072\u0065\u0061\u006b\u0069\u006e\u0067");break ;};_aag :=_ceea [_dfbe ];_dfbe ++;_fg .Log .Trace ("%\u0064\u002e\u0020\u0070\u0031\u003a\u0020\u0025\u0020\u0078",_aag ,_gaefg );_fg .Log .Trace ("%\u0064\u002e\u0020\u0070\u0032\u003a\u0020\u0025\u0020\u0078",_aag ,_dgg );_fg .Log .Trace ("%\u0064\u002e\u0020\u0070\u0033\u003a\u0020\u0025\u0020\u0078",_aag ,_febf );_fg .Log .Trace ("\u0025d\u002e \u0078\u0072\u0065\u0066\u003a \u0025\u0064 \u0025\u0064\u0020\u0025\u0064",_aag ,_aaedg ,_baebg ,_egbc );if _aaedg ==0{_fg .Log .Trace ("-\u0020\u0046\u0072\u0065\u0065\u0020o\u0062\u006a\u0065\u0063\u0074\u0020-\u0020\u0063\u0061\u006e\u0020\u0070\u0072o\u0062\u0061\u0062\u006c\u0079\u0020\u0069\u0067\u006e\u006fr\u0065");}else if _aaedg ==1{_fg .Log .Trace ("\u002d\u0020I\u006e\u0020\u0075\u0073e\u0020\u002d \u0075\u006e\u0063\u006f\u006d\u0070\u0072\u0065s\u0073\u0065\u0064\u0020\u0076\u0069\u0061\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0062",_dgg );if _baebg ==_ddfcd {_fg .Log .Debug ("\u0055\u0070d\u0061\u0074\u0069\u006e\u0067\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0066\u006f\u0072\u0020\u0058\u0052\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u0025\u0064\u0020\u002d\u003e\u0020\u0025\u0064",_aag ,_ceee .ObjectNumber );_aag =int (_ceee .ObjectNumber );};if _fbdf ,_dgfdbe :=_dgfa ._dfcg .ObjectMap [_aag ];!_dgfdbe ||int (_egbc )> _fbdf .Generation {_gdbea :=XrefObject {ObjectNumber :_aag ,XType :XrefTypeTableEntry ,Offset :_baebg ,Generation :int (_egbc )};_dgfa ._dfcg .ObjectMap [_aag ]=_gdbea ;};}else if _aaedg ==2{_fg .Log .Trace ("\u002d\u0020\u0049\u006e \u0075\u0073\u0065\u0020\u002d\u0020\u0063\u006f\u006d\u0070r\u0065s\u0073\u0065\u0064\u0020\u006f\u0062\u006ae\u0063\u0074");if _ ,_gbbd :=_dgfa ._dfcg .ObjectMap [_aag ];!_gbbd {_egdf :=XrefObject {ObjectNumber :_aag ,XType :XrefTypeObjectStream ,OsObjNumber :int (_baebg ),OsObjIndex :int (_egbc )};_dgfa ._dfcg .ObjectMap [_aag ]=_egdf ;_fg .Log .Trace ("\u0065\u006e\u0074\u0072\u0079\u003a\u0020\u0025\u002b\u0076",_egdf );};}else {_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052:\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0056\u0041L\u0049\u0044\u0020\u0054\u0059\u0050\u0045\u0020\u0058\u0072\u0065\u0066\u0053\u0074\u006d\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u003f\u002d\u002d\u002d\u002d\u002d\u002d-");continue ;};};if _dgfa ._bbgc ==nil {_dedd :=XrefTypeObjectStream ;_dgfa ._bbgc =&_dedd ;};return _ddcf ,nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_gfcfe *RawEncoder )MakeDecodeParams ()PdfObject {return nil };type encryptDict struct{Filter string ;V int ;SubFilter string ;Length int ;StmF string ;StrF string ;EFF string ;CF map[string ]_bgg .FilterDict ;};

// UpdateParams updates the parameter values of the encoder.
// Implements StreamEncoder interface.
func (_gdee *JBIG2Encoder )UpdateParams (params *PdfObjectDictionary ){_gcbab ,_gbcd :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _gbcd ==nil {_gdee .BitsPerComponent =int (_gcbab );};_dfaa ,_gbcd :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _gbcd ==nil {_gdee .Width =int (_dfaa );};_bcee ,_gbcd :=GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));if _gbcd ==nil {_gdee .Height =int (_bcee );};_fabdf ,_gbcd :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _gbcd ==nil {_gdee .ColorComponents =int (_fabdf );};};

// DecodeStream decodes a LZW encoded stream and returns the result as a
// slice of bytes.
func (_adde *LZWEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_fg .Log .Trace ("\u004c\u005a\u0057 \u0044\u0065\u0063\u006f\u0064\u0069\u006e\u0067");_fg .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_adde .Predictor );_fdg ,_dadb :=_adde .DecodeBytes (streamObj .Stream );if _dadb !=nil {return nil ,_dadb ;};_fg .Log .Trace ("\u0020\u0049\u004e\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (streamObj .Stream ),streamObj .Stream );_fg .Log .Trace ("\u004f\u0055\u0054\u003a\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (_fdg ),_fdg );if _adde .Predictor > 1{if _adde .Predictor ==2{_fg .Log .Trace ("\u0054\u0069\u0066\u0066\u0020\u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_dcg :=int (_adde .Columns )*_adde .Colors ;if _dcg < 1{return []byte {},nil ;};_dfbg :=len (_fdg )/_dcg ;if len (_fdg )%_dcg !=0{_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020T\u0049\u0046\u0046 \u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u003a\u0020\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002e\u002e\u002e");return nil ,_bec .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_fdg ),_dcg );};if _dcg %_adde .Colors !=0{return nil ,_bec .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0072\u006fw\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020(\u0025\u0064\u0029\u0020\u0066\u006f\u0072\u0020\u0063\u006f\u006c\u006fr\u0073\u0020\u0025\u0064",_dcg ,_adde .Colors );};if _dcg > len (_fdg ){_fg .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_dcg ,len (_fdg ));return nil ,_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_fg .Log .Trace ("i\u006e\u0070\u0020\u006fut\u0044a\u0074\u0061\u0020\u0028\u0025d\u0029\u003a\u0020\u0025\u0020\u0078",len (_fdg ),_fdg );_bggg :=_gd .NewBuffer (nil );for _fbbe :=0;_fbbe < _dfbg ;_fbbe ++{_gadac :=_fdg [_dcg *_fbbe :_dcg *(_fbbe +1)];for _dcaa :=_adde .Colors ;_dcaa < _dcg ;_dcaa ++{_gadac [_dcaa ]=byte (int (_gadac [_dcaa ]+_gadac [_dcaa -_adde .Colors ])%256);};_bggg .Write (_gadac );};_gbe :=_bggg .Bytes ();_fg .Log .Trace ("\u0050O\u0075t\u0044\u0061\u0074\u0061\u0020(\u0025\u0064)\u003a\u0020\u0025\u0020\u0078",len (_gbe ),_gbe );return _gbe ,nil ;}else if _adde .Predictor >=10&&_adde .Predictor <=15{_fg .Log .Trace ("\u0050\u004e\u0047 \u0045\u006e\u0063\u006f\u0064\u0069\u006e\u0067");_ecfe :=int (_adde .Columns *_adde .Colors +1);if _ecfe < 1{return []byte {},nil ;};_dee :=len (_fdg )/_ecfe ;if len (_fdg )%_ecfe !=0{return nil ,_bec .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u006f\u0077 \u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064/\u0025\u0064\u0029",len (_fdg ),_ecfe );};if _ecfe > len (_fdg ){_fg .Log .Debug ("\u0052\u006fw\u0020\u006c\u0065\u006e\u0067t\u0068\u0020\u0063\u0061\u006en\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0028\u0025\u0064\u002f\u0025\u0064\u0029",_ecfe ,len (_fdg ));return nil ,_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_ggafc :=_gd .NewBuffer (nil );_fg .Log .Trace ("P\u0072\u0065\u0064\u0069ct\u006fr\u0020\u0063\u006f\u006c\u0075m\u006e\u0073\u003a\u0020\u0025\u0064",_adde .Columns );_fg .Log .Trace ("\u004ce\u006e\u0067\u0074\u0068:\u0020\u0025\u0064\u0020\u002f \u0025d\u0020=\u0020\u0025\u0064\u0020\u0072\u006f\u0077s",len (_fdg ),_ecfe ,_dee );_gfc :=make ([]byte ,_ecfe );for _ged :=0;_ged < _ecfe ;_ged ++{_gfc [_ged ]=0;};for _cbabe :=0;_cbabe < _dee ;_cbabe ++{_cbaf :=_fdg [_ecfe *_cbabe :_ecfe *(_cbabe +1)];_ggdff :=_cbaf [0];switch _ggdff {case 0:case 1:for _afa :=2;_afa < _ecfe ;_afa ++{_cbaf [_afa ]=byte (int (_cbaf [_afa ]+_cbaf [_afa -1])%256);};case 2:for _ffge :=1;_ffge < _ecfe ;_ffge ++{_cbaf [_ffge ]=byte (int (_cbaf [_ffge ]+_gfc [_ffge ])%256);};default:_fg .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0066i\u006c\u0074\u0065\u0072\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_ggdff );return nil ,_bec .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u0069\u006c\u0074\u0065r\u0020\u0062\u0079\u0074\u0065\u0020\u0028\u0025\u0064\u0029",_ggdff );};for _acg :=0;_acg < _ecfe ;_acg ++{_gfc [_acg ]=_cbaf [_acg ];};_ggafc .Write (_cbaf [1:]);};_ebcf :=_ggafc .Bytes ();return _ebcf ,nil ;}else {_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a \u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072 \u0028\u0025\u0064\u0029",_adde .Predictor );return nil ,_bec .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0070\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020(\u0025\u0064\u0029",_adde .Predictor );};};return _fdg ,nil ;};

// Set sets the PdfObject at index i of the array. An error is returned if the index is outside bounds.
func (_efgf *PdfObjectArray )Set (i int ,obj PdfObject )error {if i < 0||i >=len (_efgf ._bcgc ){return _d .New ("\u006f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u0062o\u0075\u006e\u0064\u0073");};_efgf ._bcgc [i ]=obj ;return nil ;};

// GetXrefType returns the type of the first xref object (table or stream).
func (_gaaf *PdfParser )GetXrefType ()*xrefType {return _gaaf ._bbgc };

// GetName returns the *PdfObjectName represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetName (obj PdfObject )(_ccac *PdfObjectName ,_adag bool ){_ccac ,_adag =TraceToDirectObject (obj ).(*PdfObjectName );return _ccac ,_adag ;};

// String returns a string describing `ref`.
func (_gdbbb *PdfObjectReference )String ()string {return _bec .Sprintf ("\u0052\u0065\u0066\u0028\u0025\u0064\u0020\u0025\u0064\u0029",_gdbbb .ObjectNumber ,_gdbbb .GenerationNumber );};

// GetFilterName returns the name of the encoding filter.
func (_dcea *LZWEncoder )GetFilterName ()string {return StreamEncodingFilterNameLZW };

// JBIG2Image is the image structure used by the jbig2 encoder. Its Data must be in a
// 1 bit per component and 1 component per pixel (1bpp). In order to create binary image
// use GoImageToJBIG2 function. If the image data contains the row bytes padding set the HasPadding to true.
type JBIG2Image struct{

// Width and Height defines the image boundaries.
Width ,Height int ;

// Data is the byte slice data for the input image
Data []byte ;

// HasPadding is the attribute that defines if the last byte of the data in the row contains
// 0 bits padding.
HasPadding bool ;};

// PdfCryptNewEncrypt makes the document crypt handler based on a specified crypt filter.
func PdfCryptNewEncrypt (cf _bgg .Filter ,userPass ,ownerPass []byte ,perm _ag .Permissions )(*PdfCrypt ,*EncryptInfo ,error ){_gad :=&PdfCrypt {_bac :make (map[PdfObject ]bool ),_eae :make (cryptFilters ),_fgag :_ag .StdEncryptDict {P :perm ,EncryptMetadata :true }};var _cbg Version ;if cf !=nil {_adf :=cf .PDFVersion ();_cbg .Major ,_cbg .Minor =_adf [0],_adf [1];V ,R :=cf .HandlerVersion ();_gad ._dge .V =V ;_gad ._fgag .R =R ;_gad ._dge .Length =cf .KeyLength ()*8;};const (_dced =_fgac ;);_gad ._eae [_dced ]=cf ;if _gad ._dge .V >=4{_gad ._dec =_dced ;_gad ._acd =_dced ;};_fga :=_gad .newEncryptDict ();_agc :=_aa .Sum ([]byte (_gf .Now ().Format (_gf .RFC850 )));_adc :=string (_agc [:]);_fbc :=make ([]byte ,100);_fa .Read (_fbc );_agc =_aa .Sum (_fbc );_cfbd :=string (_agc [:]);_fg .Log .Trace ("\u0052\u0061\u006e\u0064\u006f\u006d\u0020\u0062\u003a\u0020\u0025\u0020\u0078",_fbc );_fg .Log .Trace ("\u0047\u0065\u006e\u0020\u0049\u0064\u0020\u0030\u003a\u0020\u0025\u0020\u0078",_adc );_gad ._cbb =string (_adc );_acbe :=_gad .generateParams (userPass ,ownerPass );if _acbe !=nil {return nil ,nil ,_acbe ;};_gde (&_gad ._fgag ,_fga );if _gad ._dge .V >=4{if _bcgf :=_gad .saveCryptFilters (_fga );_bcgf !=nil {return nil ,nil ,_bcgf ;};};return _gad ,&EncryptInfo {Version :_cbg ,Encrypt :_fga ,ID0 :_adc ,ID1 :_cfbd },nil ;};const JB2ImageAutoThreshold =-1.0;

// LookupByNumber looks up a PdfObject by object number.  Returns an error on failure.
func (_afb *PdfParser )LookupByNumber (objNumber int )(PdfObject ,error ){_ebg ,_ ,_bge :=_afb .lookupByNumberWrapper (objNumber ,true );return _ebg ,_bge ;};func (_ecc *PdfParser )lookupByNumber (_dag int ,_aed bool )(PdfObject ,bool ,error ){_ccd ,_bfa :=_ecc .ObjCache [_dag ];if _bfa {_fg .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0063a\u0063\u0068\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063t\u0020\u0025\u0064",_dag );return _ccd ,false ,nil ;};_fcc ,_bfa :=_ecc ._dfcg .ObjectMap [_dag ];if !_bfa {_fg .Log .Trace ("\u0055\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u006c\u006f\u0063\u0061t\u0065\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0069\u006e\u0020\u0078\u0072\u0065\u0066\u0073\u0021 \u002d\u0020\u0052\u0065\u0074u\u0072\u006e\u0069\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006a\u0065\u0063\u0074");var _bgf PdfObjectNull ;return &_bgf ,false ,nil ;};_fg .Log .Trace ("L\u006fo\u006b\u0075\u0070\u0020\u006f\u0062\u006a\u0020n\u0075\u006d\u0062\u0065r \u0025\u0064",_dag );if _fcc .XType ==XrefTypeTableEntry {_fg .Log .Trace ("\u0078r\u0065f\u006f\u0062\u006a\u0020\u006fb\u006a\u0020n\u0075\u006d\u0020\u0025\u0064",_fcc .ObjectNumber );_fg .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u0067e\u006e\u0020\u0025\u0064",_fcc .Generation );_fg .Log .Trace ("\u0078\u0072\u0065\u0066\u006f\u0062\u006a\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0025\u0064",_fcc .Offset );_ecc ._aedcf .Seek (_fcc .Offset ,_ac .SEEK_SET );_ecc ._fdfg =_af .NewReader (_ecc ._aedcf );_ffc ,_bae :=_ecc .ParseIndirectObject ();if _bae !=nil {_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006ce\u0064\u0020\u0072\u0065\u0061\u0064\u0069n\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0028\u0025\u0073\u0029",_bae );if _aed {_fg .Log .Debug ("\u0041\u0074t\u0065\u006d\u0070\u0074i\u006e\u0067 \u0074\u006f\u0020\u0072\u0065\u0070\u0061\u0069r\u0020\u0078\u0072\u0065\u0066\u0073\u0020\u0028\u0074\u006f\u0070\u0020d\u006f\u0077\u006e\u0029");_edf ,_bcb :=_ecc .repairRebuildXrefsTopDown ();if _bcb !=nil {_fg .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0046\u0061\u0069\u006c\u0065\u0064\u0020r\u0065\u0070\u0061\u0069\u0072\u0020\u0028\u0025\u0073\u0029",_bcb );return nil ,false ,_bcb ;};_ecc ._dfcg =*_edf ;return _ecc .lookupByNumber (_dag ,false );};return nil ,false ,_bae ;};if _aed {_fe ,_ ,_ :=_ae (_ffc );if int (_fe )!=_dag {_fg .Log .Debug ("\u0049n\u0076\u0061\u006c\u0069d\u0020\u0078\u0072\u0065\u0066s\u003a \u0052e\u0062\u0075\u0069\u006c\u0064\u0069\u006eg");_eaa :=_ecc .rebuildXrefTable ();if _eaa !=nil {return nil ,false ,_eaa ;};_ecc .ObjCache =objectCache {};return _ecc .lookupByNumberWrapper (_dag ,false );};};_fg .Log .Trace ("\u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006f\u0062\u006a");_ecc .ObjCache [_dag ]=_ffc ;return _ffc ,false ,nil ;}else if _fcc .XType ==XrefTypeObjectStream {_fg .Log .Trace ("\u0078r\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0021");_fg .Log .Trace ("\u003e\u004c\u006f\u0061\u0064\u0020\u0076\u0069\u0061\u0020\u004f\u0053\u0021");_fg .Log .Trace ("\u004f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065\u0061\u006d \u0061\u0076\u0061\u0069\u006c\u0061b\u006c\u0065\u0020\u0069\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020%\u0064\u002f\u0025\u0064",_fcc .OsObjNumber ,_fcc .OsObjIndex );if _fcc .OsObjNumber ==_dag {_fg .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0043i\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065f\u0065\u0072\u0065n\u0063e\u0021\u003f\u0021");return nil ,true ,_d .New ("\u0078\u0072\u0065f \u0063\u0069\u0072\u0063\u0075\u006c\u0061\u0072\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");};if _ ,_ad :=_ecc ._dfcg .ObjectMap [_fcc .OsObjNumber ];_ad {_acf ,_cda :=_ecc .lookupObjectViaOS (_fcc .OsObjNumber ,_dag );if _cda !=nil {_fg .Log .Debug ("\u0045R\u0052\u004f\u0052\u0020\u0052\u0065\u0074\u0075\u0072\u006e\u0069n\u0067\u0020\u0045\u0052\u0052\u0020\u0028\u0025\u0073\u0029",_cda );return nil ,true ,_cda ;};_fg .Log .Trace ("\u003c\u004c\u006f\u0061\u0064\u0065\u0064\u0020\u0076i\u0061\u0020\u004f\u0053");_ecc .ObjCache [_dag ]=_acf ;if _ecc ._dgfca !=nil {_ecc ._dgfca ._fgc [_acf ]=true ;};return _acf ,true ,nil ;};_fg .Log .Debug ("\u003f\u003f\u0020\u0042\u0065\u006c\u006f\u006eg\u0073\u0020\u0074o \u0061\u0020\u006e\u006f\u006e\u002dc\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064 \u006f\u0062\u006a\u0065\u0063\u0074\u0020\u002e.\u002e\u0021");return nil ,true ,_d .New ("\u006f\u0073\u0020\u0062\u0065\u006c\u006fn\u0067\u0073\u0020t\u006f\u0020\u0061\u0020n\u006f\u006e\u0020\u0063\u0072\u006f\u0073\u0073\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074");};return nil ,false ,_d .New ("\u0075\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0078\u0072\u0065\u0066 \u0074\u0079\u0070\u0065");};func (_afdf *offsetReader )Read (p []byte )(_dcdb int ,_ecgb error ){return _afdf ._fdab .Read (p )};

// PdfCryptNewDecrypt makes the document crypt handler based on the encryption dictionary
// and trailer dictionary. Returns an error on failure to process.
func PdfCryptNewDecrypt (parser *PdfParser ,ed ,trailer *PdfObjectDictionary )(*PdfCrypt ,error ){_adg :=&PdfCrypt {_aaa :false ,_fgc :make (map[PdfObject ]bool ),_bac :make (map[PdfObject ]bool ),_cfbg :make (map[int ]struct{}),_cgd :parser };_gcg ,_eda :=ed .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectName );if !_eda {_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0043\u0072\u0079\u0070\u0074 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061r\u0079 \u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u0066\u0069\u0065\u006c\u0064\u0021");return _adg ,_d .New ("r\u0065\u0071\u0075\u0069\u0072\u0065d\u0020\u0063\u0072\u0079\u0070\u0074 \u0066\u0069\u0065\u006c\u0064\u0020\u0046i\u006c\u0074\u0065\u0072\u0020\u006d\u0069\u0073\u0073\u0069n\u0067");};if *_gcg !="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"{_fg .Log .Debug ("\u0045\u0052R\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020(%\u0073\u0029",*_gcg );return _adg ,_d .New ("\u0075n\u0073u\u0070\u0070\u006f\u0072\u0074e\u0064\u0020F\u0069\u006c\u0074\u0065\u0072");};_adg ._dge .Filter =string (*_gcg );if _gba ,_abc :=ed .Get ("\u0053u\u0062\u0046\u0069\u006c\u0074\u0065r").(*PdfObjectString );_abc {_adg ._dge .SubFilter =_gba .Str ();_fg .Log .Debug ("\u0055s\u0069n\u0067\u0020\u0073\u0075\u0062f\u0069\u006ct\u0065\u0072\u0020\u0025\u0073",_gba );};if L ,_fff :=ed .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );_fff {if (*L %8)!=0{_fg .Log .Debug ("\u0045\u0052\u0052O\u0052\u0020\u0049\u006ev\u0061\u006c\u0069\u0064\u0020\u0065\u006ec\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006c\u0065\u006e\u0067\u0074\u0068");return _adg ,_d .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0065\u006e\u0063\u0072y\u0070t\u0069o\u006e\u0020\u006c\u0065\u006e\u0067\u0074h");};_adg ._dge .Length =int (*L );}else {_adg ._dge .Length =40;};_adg ._dge .V =0;if _efca ,_ccff :=ed .Get ("\u0056").(*PdfObjectInteger );_ccff {V :=int (*_efca );_adg ._dge .V =V ;if V >=1&&V <=2{_adg ._eae =_dgee (_adg ._dge .Length );}else if V >=4&&V <=5{if _adcc :=_adg .loadCryptFilters (ed );_adcc !=nil {return _adg ,_adcc ;};}else {_fg .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0055\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065n\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u0061lg\u006f\u0020\u0056 \u003d \u0025\u0064",V );return _adg ,_d .New ("u\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d");};};if _dgea :=_dda (&_adg ._fgag ,ed );_dgea !=nil {return _adg ,_dgea ;};_ee :="";if _dbc ,_gcbf :=trailer .Get ("\u0049\u0044").(*PdfObjectArray );_gcbf &&_dbc .Len ()>=1{_egf ,_gcc :=GetString (_dbc .Get (0));if !_gcc {return _adg ,_d .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0074r\u0061\u0069l\u0065\u0072\u0020\u0049\u0044");};_ee =_egf .Str ();}else {_fg .Log .Debug ("\u0054\u0072ai\u006c\u0065\u0072 \u0049\u0044\u0020\u0061rra\u0079 m\u0069\u0073\u0073\u0069\u006e\u0067\u0020or\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0021");};_adg ._cbb =_ee ;return _adg ,nil ;};

// Append appends PdfObject(s) to the array.
func (_ecfc *PdfObjectArray )Append (objects ...PdfObject ){if _ecfc ==nil {_fg .Log .Debug ("\u0057\u0061\u0072\u006e\u0020\u002d\u0020\u0041\u0074\u0074\u0065\u006d\u0070t\u0020\u0074\u006f\u0020\u0061\u0070p\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020a\u0072\u0072\u0061\u0079");return ;};if _ecfc ._bcgc ==nil {_ecfc ._bcgc =[]PdfObject {};};for _ ,_fbbb :=range objects {_ecfc ._bcgc =append (_ecfc ._bcgc ,_fbbb );};};

// WriteString outputs the object as it is to be written to file.
func (_fbfda *PdfObjectDictionary )WriteString ()string {var _babbb _gg .Builder ;_babbb .WriteString ("\u003c\u003c");for _ ,_ggafa :=range _fbfda ._ccc {_afcfb :=_fbfda ._addf [_ggafa ];_babbb .WriteString (_ggafa .WriteString ());_babbb .WriteString ("\u0020");_babbb .WriteString (_afcfb .WriteString ());};_babbb .WriteString ("\u003e\u003e");return _babbb .String ();};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_cfaa *MultiEncoder )MakeStreamDict ()*PdfObjectDictionary {_ffdd :=MakeDict ();_ffdd .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",_cfaa .GetFilterArray ());for _ ,_fbgd :=range _cfaa ._bbce {_ddca :=_fbgd .MakeStreamDict ();for _ ,_fdbc :=range _ddca .Keys (){_ccbc :=_ddca .Get (_fdbc );if _fdbc !="\u0046\u0069\u006c\u0074\u0065\u0072"&&_fdbc !="D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"{_ffdd .Set (_fdbc ,_ccbc );};};};_ebcb :=_cfaa .MakeDecodeParams ();if _ebcb !=nil {_ffdd .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_ebcb );};return _ffdd ;};

// GetInt returns the *PdfObjectBool object that is represented by a PdfObject either directly or indirectly
// within an indirect object. The bool flag indicates whether a match was found.
func GetInt (obj PdfObject )(_fbcb *PdfObjectInteger ,_gcged bool ){_fbcb ,_gcged =TraceToDirectObject (obj ).(*PdfObjectInteger );return _fbcb ,_gcged ;};

// Version represents a version of a PDF standard.
type Version struct{Major int ;Minor int ;};

// LookupByReference looks up a PdfObject by a reference.
func (_gbge *PdfParser )LookupByReference (ref PdfObjectReference )(PdfObject ,error ){_fg .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0075\u0070\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0025\u0073",ref .String ());return _gbge .LookupByNumber (int (ref .ObjectNumber ));};func _cead (_cbcg string )(PdfObjectReference ,error ){_adbb :=PdfObjectReference {};_bbab :=_cedag .FindStringSubmatch (string (_cbcg ));if len (_bbab )< 3{_fg .Log .Debug ("\u0045\u0072\u0072or\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065");return _adbb ,_d .New ("\u0075n\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061r\u0073e\u0020r\u0065\u0066\u0065\u0072\u0065\u006e\u0063e");};_eeda ,_ :=_g .Atoi (_bbab [1]);_eafa ,_ :=_g .Atoi (_bbab [2]);_adbb .ObjectNumber =int64 (_eeda );_adbb .GenerationNumber =int64 (_eafa );return _adbb ,nil ;};

// EqualObjects returns true if `obj1` and `obj2` have the same contents.
//
// NOTE: It is a good idea to flatten obj1 and obj2 with FlattenObject before calling this function
// so that contents, rather than references, can be compared.
func EqualObjects (obj1 ,obj2 PdfObject )bool {return _agda (obj1 ,obj2 ,0)};

// NewRawEncoder returns a new instace of RawEncoder.
func NewRawEncoder ()*RawEncoder {return &RawEncoder {}};

// String returns a descriptive information string about the encryption method used.
func (_edg *PdfCrypt )String ()string {if _edg ==nil {return "";};_aad :=_edg ._dge .Filter +"\u0020\u002d\u0020";if _edg ._dge .V ==0{_aad +="\u0055\u006e\u0064\u006fcu\u006d\u0065\u006e\u0074\u0065\u0064\u0020\u0061\u006c\u0067\u006f\u0072\u0069\u0074h\u006d";}else if _edg ._dge .V ==1{_aad +="\u0052\u0043\u0034:\u0020\u0034\u0030\u0020\u0062\u0069\u0074\u0073";}else if _edg ._dge .V ==2{_aad +=_bec .Sprintf ("\u0052\u0043\u0034:\u0020\u0025\u0064\u0020\u0062\u0069\u0074\u0073",_edg ._dge .Length );}else if _edg ._dge .V ==3{_aad +="U\u006e\u0070\u0075\u0062li\u0073h\u0065\u0064\u0020\u0061\u006cg\u006f\u0072\u0069\u0074\u0068\u006d";}else if _edg ._dge .V >=4{_aad +=_bec .Sprintf ("\u0053\u0074r\u0065\u0061\u006d\u0020f\u0069\u006ct\u0065\u0072\u003a\u0020\u0025\u0073\u0020\u002d \u0053\u0074\u0072\u0069\u006e\u0067\u0020\u0066\u0069\u006c\u0074\u0065r\u003a\u0020\u0025\u0073",_edg ._dec ,_edg ._acd );_aad +="\u003b\u0020C\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0073\u003a";for _ffaa ,_feg :=range _edg ._eae {_aad +=_bec .Sprintf ("\u0020\u002d\u0020\u0025\u0073\u003a\u0020\u0025\u0073 \u0028\u0025\u0064\u0029",_ffaa ,_feg .Name (),_feg .KeyLength ());};};_gec :=_edg .GetAccessPermissions ();_aad +=_bec .Sprintf ("\u0020\u002d\u0020\u0025\u0023\u0076",_gec );return _aad ;};var _gcae =_ga .MustCompile ("\u005c\u0073\u002a\u0078\u0072\u0065\u0066\u005c\u0073\u002a");

// JPXEncoder implements JPX encoder/decoder (dummy, for now)
// FIXME: implement
type JPXEncoder struct{};

// EncodeBytes DCT encodes the passed in slice of bytes.
func (_cca *DCTEncoder )EncodeBytes (data []byte )([]byte ,error ){_fce ,_aace :=_ba .NewImage (_cca .Width ,_cca .Height ,_cca .BitsPerComponent ,_cca .ColorComponents ,data ,nil ,nil );if _aace !=nil {return nil ,_aace ;};_bdc :=_be .Options {};_bdc .Quality =_cca .Quality ;var _aec _gd .Buffer ;if _aace =_be .Encode (&_aec ,_fce ,&_bdc );_aace !=nil {return nil ,_aace ;};return _aec .Bytes (),nil ;};

// WriteString outputs the object as it is to be written to file.
func (_cbeae *PdfObjectInteger )WriteString ()string {return _g .FormatInt (int64 (*_cbeae ),10)};

// IsDecimalDigit checks if the character is a part of a decimal number string.
func IsDecimalDigit (c byte )bool {return '0'<=c &&c <='9'};

// GoImageToJBIG2 creates a binary image on the base of 'i' golang image.Image.
// If the image is not a black/white image then the function converts provided input into
// JBIG2Image with 1bpp. For non grayscale images the function performs the conversion to the grayscale temp image.
// Then it checks the value of the gray image value if it's within bounds of the black white threshold.
// This 'bwThreshold' value should be in range (0.0, 1.0). The threshold checks if the grayscale pixel (uint) value
// is greater or smaller than 'bwThreshold' * 255. Pixels inside the range will be white, and the others will be black.
// If the 'bwThreshold' is equal to -1.0 - JB2ImageAutoThreshold then it's value would be set on the base of
// it's histogram using Triangle method. For more information go to:
// 	https://www.mathworks.com/matlabcentral/fileexchange/28047-gray-image-thresholding-using-the-triangle-method
func GoImageToJBIG2 (i _cb .Image ,bwThreshold float64 )(*JBIG2Image ,error ){const _feeaa ="\u0047\u006f\u0049\u006d\u0061\u0067\u0065\u0054\u006fJ\u0042\u0049\u0047\u0032";if i ==nil {return nil ,_bee .Error (_feeaa ,"i\u006d\u0061\u0067\u0065 '\u0069'\u0020\u006e\u006f\u0074\u0020d\u0065\u0066\u0069\u006e\u0065\u0064");};var (_badg uint8 ;_cfdc _ba .Image ;_afccg error ;);if bwThreshold ==JB2ImageAutoThreshold {_cfdc ,_afccg =_ba .MonochromeConverter .Convert (i );}else if bwThreshold > 1.0||bwThreshold < 0.0{return nil ,_bee .Error (_feeaa ,"p\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0074h\u0072\u0065\u0073\u0068\u006f\u006c\u0064 i\u0073\u0020\u006e\u006ft\u0020\u0069\u006e\u0020\u0061\u0020\u0072\u0061\u006ege\u0020\u007b0\u002e\u0030\u002c\u0020\u0031\u002e\u0030\u007d");}else {_badg =uint8 (255*bwThreshold );_cfdc ,_afccg =_ba .MonochromeThresholdConverter (_badg ).Convert (i );};if _afccg !=nil {return nil ,_afccg ;};return _bagf (_cfdc ),nil ;};var _bdgb =_ga .MustCompile ("\u0025\u0025\u0045\u004f\u0046\u003f");func (_ddfg *JBIG2Image )toBitmap ()(_bba *_ed .Bitmap ,_bca error ){const _ebec ="\u004a\u0042\u0049\u00472I\u006d\u0061\u0067\u0065\u002e\u0074\u006f\u0042\u0069\u0074\u006d\u0061\u0070";if _ddfg .Data ==nil {return nil ,_bee .Error (_ebec ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");};if _ddfg .Width ==0||_ddfg .Height ==0{return nil ,_bee .Error (_ebec ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");};if _ddfg .HasPadding {_bba ,_bca =_ed .NewWithData (_ddfg .Width ,_ddfg .Height ,_ddfg .Data );}else {_bba ,_bca =_ed .NewWithUnpaddedData (_ddfg .Width ,_ddfg .Height ,_ddfg .Data );};if _bca !=nil {return nil ,_bee .Wrap (_bca ,_ebec ,"");};return _bba ,nil ;};

// MakeBool creates a PdfObjectBool from a bool value.
func MakeBool (val bool )*PdfObjectBool {_beb :=PdfObjectBool (val );return &_beb };

// Str returns the string value of the PdfObjectString. Defined in addition to String() function to clarify that
// this function returns the underlying string directly, whereas the String function technically could include
// debug info.
func (_aeee *PdfObjectString )Str ()string {return _aeee ._fbedf };

// DecodeStream decodes a JBIG2 encoded stream and returns the result as a slice of bytes.
func (_bceg *JBIG2Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _bceg .DecodeBytes (streamObj .Stream );};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_fcca *ASCIIHexEncoder )MakeDecodeParams ()PdfObject {return nil };func (_feca *PdfParser )seekPdfVersionTopDown ()(int ,int ,error ){_feca ._aedcf .Seek (0,_ac .SEEK_SET );_feca ._fdfg =_af .NewReader (_feca ._aedcf );_efdba :=20;_gcfg :=make ([]byte ,_efdba );for {_cfedf ,_bgbb :=_feca ._fdfg .ReadByte ();if _bgbb !=nil {if _bgbb ==_f .EOF {break ;}else {return 0,0,_bgbb ;};};if IsDecimalDigit (_cfedf )&&_gcfg [_efdba -1]=='.'&&IsDecimalDigit (_gcfg [_efdba -2])&&_gcfg [_efdba -3]=='-'&&_gcfg [_efdba -4]=='F'&&_gcfg [_efdba -5]=='D'&&_gcfg [_efdba -6]=='P'{_cebbc :=int (_gcfg [_efdba -2]-'0');_ccdgf :=int (_cfedf -'0');return _cebbc ,_ccdgf ,nil ;};_gcfg =append (_gcfg [1:_efdba ],_cfedf );};return 0,0,_d .New ("\u0076\u0065\u0072\u0073\u0069\u006f\u006e\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};

// GetIntVal returns the int value represented by the PdfObject directly or indirectly if contained within an
// indirect object. On type mismatch the found bool flag returned is false and a nil pointer is returned.
func GetIntVal (obj PdfObject )(_aceed int ,_bddfg bool ){_abbe ,_bddfg :=TraceToDirectObject (obj ).(*PdfObjectInteger );if _bddfg &&_abbe !=nil {return int (*_abbe ),true ;};return 0,false ;};

// IsAuthenticated returns true if the PDF has already been authenticated for accessing.
func (_edgdg *PdfParser )IsAuthenticated ()bool {return _edgdg ._dgfca ._aaa };

// ParseNumber parses a numeric objects from a buffered stream.
// Section 7.3.3.
// Integer or Float.
//
// An integer shall be written as one or more decimal digits optionally
// preceded by a sign. The value shall be interpreted as a signed
// decimal integer and shall be converted to an integer object.
//
// A real value shall be written as one or more decimal digits with an
// optional sign and a leading, trailing, or embedded PERIOD (2Eh)
// (decimal point). The value shall be interpreted as a real number
// and shall be converted to a real object.
//
// Regarding exponential numbers: 7.3.3 Numeric Objects:
// A conforming writer shall not use the PostScript syntax for numbers
// with non-decimal radices (such as 16#FFFE) or in exponential format
// (such as 6.02E23).
// Nonetheless, we sometimes get numbers with exponential format, so
// we will support it in the reader (no confusion with other types, so
// no compromise).
func ParseNumber (buf *_af .Reader )(PdfObject ,error ){_degc :=false ;_egee :=true ;var _fbgde _gd .Buffer ;for {if _fg .Log .IsLogLevel (_fg .LogLevelTrace ){_fg .Log .Trace ("\u0050\u0061\u0072\u0073in\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0022\u0025\u0073\u0022",_fbgde .String ());};_cgbc ,_eggfc :=buf .Peek (1);if _eggfc ==_f .EOF {break ;};if _eggfc !=nil {_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020\u0025\u0073",_eggfc );return nil ,_eggfc ;};if _egee &&(_cgbc [0]=='-'||_cgbc [0]=='+'){_fbgg ,_ :=buf .ReadByte ();_fbgde .WriteByte (_fbgg );_egee =false ;}else if IsDecimalDigit (_cgbc [0]){_cbbfe ,_ :=buf .ReadByte ();_fbgde .WriteByte (_cbbfe );}else if _cgbc [0]=='.'{_agbfc ,_ :=buf .ReadByte ();_fbgde .WriteByte (_agbfc );_degc =true ;}else if _cgbc [0]=='e'||_cgbc [0]=='E'{_aaae ,_ :=buf .ReadByte ();_fbgde .WriteByte (_aaae );_degc =true ;_egee =true ;}else {break ;};};var _ebfb PdfObject ;if _degc {_ccfd ,_adad :=_g .ParseFloat (_fbgde .String (),64);if _adad !=nil {_fg .Log .Debug ("\u0045\u0072r\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0025v\u0020\u0065\u0072\u0072\u003d\u0025v\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0030\u002e\u0020\u004fu\u0074\u0070u\u0074\u0020\u006d\u0061y\u0020\u0062\u0065\u0020\u0069n\u0063\u006f\u0072\u0072\u0065\u0063\u0074",_fbgde .String (),_adad );_ccfd =0.0;_adad =nil ;};_dgbg :=PdfObjectFloat (_ccfd );_ebfb =&_dgbg ;}else {_cfcd ,_eedg :=_g .ParseInt (_fbgde .String (),10,64);if _eedg !=nil {_fg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0025\u0076\u0020\u0065\u0072\u0072\u003d%\u0076\u002e\u0020\u0055\u0073\u0069\u006e\u0067\u0020\u0030\u002e\u0020\u004f\u0075\u0074\u0070\u0075\u0074 \u006d\u0061\u0079\u0020\u0062\u0065 \u0069\u006ec\u006f\u0072r\u0065c\u0074",_fbgde .String (),_eedg );_cfcd =0;_eedg =nil ;};_eabbg :=PdfObjectInteger (_cfcd );_ebfb =&_eabbg ;};return _ebfb ,nil ;};

// MakeNull creates an PdfObjectNull.
func MakeNull ()*PdfObjectNull {_fgbfg :=PdfObjectNull {};return &_fgbfg };

// Len returns the number of elements in the array.
func (_fcad *PdfObjectArray )Len ()int {if _fcad ==nil {return 0;};return len (_fcad ._bcgc );};

// GetXrefOffset returns the offset of the xref table.
func (_acfe *PdfParser )GetXrefOffset ()int64 {return _acfe ._egff };

// MakeInteger creates a PdfObjectInteger from an int64.
func MakeInteger (val int64 )*PdfObjectInteger {_aeab :=PdfObjectInteger (val );return &_aeab };

// PdfObjectReference represents the primitive PDF reference object.
type PdfObjectReference struct{_ggde *PdfParser ;ObjectNumber int64 ;GenerationNumber int64 ;};

// GetXrefTable returns the PDFs xref table.
func (_ccdc *PdfParser )GetXrefTable ()XrefTable {return _ccdc ._dfcg };func (_bgdd *PdfCrypt )checkAccessRights (_efac []byte )(bool ,_ag .Permissions ,error ){_gdc :=_bgdd .securityHandler ();_ceg ,_fgd ,_ecg :=_gdc .Authenticate (&_bgdd ._fgag ,_efac );if _ecg !=nil {return false ,0,_ecg ;}else if _fgd ==0||len (_ceg )==0{return false ,0,nil ;};return true ,_fgd ,nil ;};func (_dbd *PdfCrypt )securityHandler ()_ag .StdHandler {if _dbd ._fgag .R >=5{return _ag .NewHandlerR6 ();};return _ag .NewHandlerR4 (_dbd ._cbb ,_dbd ._dge .Length );};

// NewMultiEncoder returns a new instance of MultiEncoder.
func NewMultiEncoder ()*MultiEncoder {_dadbf :=MultiEncoder {};_dadbf ._bbce =[]StreamEncoder {};return &_dadbf ;};func (_fcfb *PdfParser )parseBool ()(PdfObjectBool ,error ){_cfbaf ,_agad :=_fcfb ._fdfg .Peek (4);if _agad !=nil {return PdfObjectBool (false ),_agad ;};if (len (_cfbaf )>=4)&&(string (_cfbaf [:4])=="\u0074\u0072\u0075\u0065"){_fcfb ._fdfg .Discard (4);return PdfObjectBool (true ),nil ;};_cfbaf ,_agad =_fcfb ._fdfg .Peek (5);if _agad !=nil {return PdfObjectBool (false ),_agad ;};if (len (_cfbaf )>=5)&&(string (_cfbaf [:5])=="\u0066\u0061\u006cs\u0065"){_fcfb ._fdfg .Discard (5);return PdfObjectBool (false ),nil ;};return PdfObjectBool (false ),_d .New ("\u0075n\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0062o\u006fl\u0065a\u006e\u0020\u0073\u0074\u0072\u0069\u006eg");};

// ParseIndirectObject parses an indirect object from the input stream. Can also be an object stream.
// Returns the indirect object (*PdfIndirectObject) or the stream object (*PdfObjectStream).
func (_dbbe *PdfParser )ParseIndirectObject ()(PdfObject ,error ){_ddda :=PdfIndirectObject {};_ddda ._ggde =_dbbe ;_fg .Log .Trace ("\u002dR\u0065a\u0064\u0020\u0069\u006e\u0064i\u0072\u0065c\u0074\u0020\u006f\u0062\u006a");_defe ,_fgcc :=_dbbe ._fdfg .Peek (20);if _fgcc !=nil {if _fgcc !=_f .EOF {_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020r\u0065a\u0064\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a");return &_ddda ,_fgcc ;};};_fg .Log .Trace ("\u0028\u0069\u006edi\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0020\u0070\u0065\u0065\u006b\u0020\u0022\u0025\u0073\u0022",string (_defe ));_ccda :=_effg .FindStringSubmatchIndex (string (_defe ));if len (_ccda )< 6{if _fgcc ==_f .EOF {return nil ,_fgcc ;};_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_defe ));return &_ddda ,_d .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");};_dbbe ._fdfg .Discard (_ccda [0]);_fg .Log .Trace ("O\u0066\u0066\u0073\u0065\u0074\u0073\u0020\u0025\u0020\u0064",_ccda );_caeb :=_ccda [1]-_ccda [0];_feac :=make ([]byte ,_caeb );_ ,_fgcc =_dbbe .ReadAtLeast (_feac ,_caeb );if _fgcc !=nil {_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0075\u006e\u0061\u0062l\u0065\u0020\u0074\u006f\u0020\u0072\u0065\u0061\u0064\u0020-\u0020\u0025\u0073",_fgcc );return nil ,_fgcc ;};_fg .Log .Trace ("\u0074\u0065\u0078t\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_feac );_edca :=_effg .FindStringSubmatch (string (_feac ));if len (_edca )< 3{_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0061\u0062l\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065\u0020\u0028\u0025\u0073\u0029",string (_feac ));return &_ddda ,_d .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");};_acdde ,_ :=_g .Atoi (_edca [1]);_cdeb ,_ :=_g .Atoi (_edca [2]);_ddda .ObjectNumber =int64 (_acdde );_ddda .GenerationNumber =int64 (_cdeb );for {_fbge ,_dfcbd :=_dbbe ._fdfg .Peek (2);if _dfcbd !=nil {return &_ddda ,_dfcbd ;};_fg .Log .Trace ("I\u006ed\u002e\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_fbge ),string (_fbge ));if IsWhiteSpace (_fbge [0]){_dbbe .skipSpaces ();}else if _fbge [0]=='%'{_dbbe .skipComments ();}else if (_fbge [0]=='<')&&(_fbge [1]=='<'){_fg .Log .Trace ("\u0043\u0061\u006c\u006c\u0020\u0050\u0061\u0072\u0073e\u0044\u0069\u0063\u0074");_ddda .PdfObject ,_dfcbd =_dbbe .ParseDict ();_fg .Log .Trace ("\u0045\u004f\u0046\u0020Ca\u006c\u006c\u0020\u0050\u0061\u0072\u0073\u0065\u0044\u0069\u0063\u0074\u003a\u0020%\u0076",_dfcbd );if _dfcbd !=nil {return &_ddda ,_dfcbd ;};_fg .Log .Trace ("\u0050\u0061\u0072\u0073\u0065\u0064\u0020\u0064\u0069\u0063t\u0069\u006f\u006e\u0061\u0072\u0079\u002e.\u002e\u0020\u0066\u0069\u006e\u0069\u0073\u0068\u0065\u0064\u002e");}else if (_fbge [0]=='/')||(_fbge [0]=='(')||(_fbge [0]=='[')||(_fbge [0]=='<'){_ddda .PdfObject ,_dfcbd =_dbbe .parseObject ();if _dfcbd !=nil {return &_ddda ,_dfcbd ;};_fg .Log .Trace ("P\u0061\u0072\u0073\u0065\u0064\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u002e\u002e\u002e \u0066\u0069\u006ei\u0073h\u0065\u0064\u002e");}else if _fbge [0]==']'{_fg .Log .Debug ("\u0057\u0041\u0052\u004e\u0049N\u0047\u003a\u0020\u0027\u005d\u0027 \u0063\u0068\u0061\u0072\u0061\u0063\u0074e\u0072\u0020\u006eo\u0074\u0020\u0062\u0065i\u006e\u0067\u0020\u0075\u0073\u0065d\u0020\u0061\u0073\u0020\u0061\u006e\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006e\u0064\u0069n\u0067\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u002e\u0020\u0053\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e");_dbbe ._fdfg .Discard (1);}else {if _fbge [0]=='e'{_gcbb ,_deb :=_dbbe .readTextLine ();if _deb !=nil {return nil ,_deb ;};if len (_gcbb )>=6&&_gcbb [0:6]=="\u0065\u006e\u0064\u006f\u0062\u006a"{break ;};}else if _fbge [0]=='s'{_fbge ,_ =_dbbe ._fdfg .Peek (10);if string (_fbge [:6])=="\u0073\u0074\u0072\u0065\u0061\u006d"{_ggf :=6;if len (_fbge )> 6{if IsWhiteSpace (_fbge [_ggf ])&&_fbge [_ggf ]!='\r'&&_fbge [_ggf ]!='\n'{_fg .Log .Debug ("\u004e\u006fn\u002d\u0063\u006f\u006e\u0066\u006f\u0072\u006d\u0061\u006e\u0074\u0020\u0050\u0044\u0046\u0020\u006e\u006f\u0074 \u0065\u006e\u0064\u0069\u006e\u0067 \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0069\u006e\u0065\u0020\u0070\u0072o\u0070\u0065r\u006c\u0079\u0020\u0077i\u0074\u0068\u0020\u0045\u004fL\u0020\u006d\u0061\u0072\u006b\u0065\u0072");_ggf ++;};if _fbge [_ggf ]=='\r'{_ggf ++;if _fbge [_ggf ]=='\n'{_ggf ++;};}else if _fbge [_ggf ]=='\n'{_ggf ++;};};_dbbe ._fdfg .Discard (_ggf );_eedea ,_cgda :=_ddda .PdfObject .(*PdfObjectDictionary );if !_cgda {return nil ,_d .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006di\u0073s\u0069\u006e\u0067\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079");};_fg .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0069c\u0074\u0020\u0025\u0073",_eedea );_fffb ,_fece :=_dbbe .traceStreamLength (_eedea .Get ("\u004c\u0065\u006e\u0067\u0074\u0068"));if _fece !=nil {_fg .Log .Debug ("\u0046\u0061\u0069l\u0020\u0074\u006f\u0020t\u0072\u0061\u0063\u0065\u0020\u0073\u0074r\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0025\u0076",_fece );return nil ,_fece ;};_fg .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_fffb );_dagb ,_bede :=_fffb .(*PdfObjectInteger );if !_bede {return nil ,_d .New ("\u0073\u0074re\u0061\u006d\u0020l\u0065\u006e\u0067\u0074h n\u0065ed\u0073\u0020\u0074\u006f\u0020\u0062\u0065 a\u006e\u0020\u0069\u006e\u0074\u0065\u0067e\u0072");};_fgde :=*_dagb ;if _fgde < 0{return nil ,_d .New ("\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006e\u0065\u0065\u0064\u0073\u0020\u0074\u006f \u0062e\u0020\u006c\u006f\u006e\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0030");};_ddfd :=_dbbe .GetFileOffset ();_ecbc :=_dbbe .xrefNextObjectOffset (_ddfd );if _ddfd +int64 (_fgde )> _ecbc &&_ecbc > _ddfd {_fg .Log .Debug ("E\u0078\u0070\u0065\u0063te\u0064 \u0065\u006e\u0064\u0069\u006eg\u0020\u0061\u0074\u0020\u0025\u0064",_ddfd +int64 (_fgde ));_fg .Log .Debug ("\u004e\u0065\u0078\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074 \u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020\u0061t\u0020\u0025\u0064",_ecbc );_dgbba :=_ecbc -_ddfd -17;if _dgbba < 0{return nil ,_d .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020go\u0069\u006e\u0067 \u0070\u0061s\u0074\u0020\u0062\u006f\u0075\u006ed\u0061\u0072i\u0065\u0073");};_fg .Log .Debug ("\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0069\u006e\u0067\u0020\u0061\u0020l\u0065\u006e\u0067\u0074\u0068\u0020c\u006f\u0072\u0072\u0065\u0063\u0074\u0069\u006f\u006e\u0020\u0074\u006f\u0020%\u0064\u002e\u002e\u002e",_dgbba );_fgde =PdfObjectInteger (_dgbba );_eedea .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (_dgbba ));};if int64 (_fgde )> _dbbe ._egbf {_fg .Log .Debug ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0053t\u0072\u0065\u0061\u006d\u0020l\u0065\u006e\u0067\u0074\u0068\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006c\u0061\u0072\u0067\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0066\u0069\u006c\u0065\u0020\u0073\u0069\u007a\u0065");return nil ,_d .New ("\u0069n\u0076\u0061l\u0069\u0064\u0020\u0073t\u0072\u0065\u0061m\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u002c\u0020la\u0072\u0067\u0065r\u0020\u0074h\u0061\u006e\u0020\u0066\u0069\u006ce\u0020\u0073i\u007a\u0065");};_cgdg :=make ([]byte ,_fgde );_ ,_fece =_dbbe .ReadAtLeast (_cgdg ,int (_fgde ));if _fece !=nil {_fg .Log .Debug ("E\u0052\u0052\u004f\u0052 s\u0074r\u0065\u0061\u006d\u0020\u0028%\u0064\u0029\u003a\u0020\u0025\u0058",len (_cgdg ),_cgdg );_fg .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_fece );return nil ,_fece ;};_egde :=PdfObjectStream {};_egde .Stream =_cgdg ;_egde .PdfObjectDictionary =_ddda .PdfObject .(*PdfObjectDictionary );_egde .ObjectNumber =_ddda .ObjectNumber ;_egde .GenerationNumber =_ddda .GenerationNumber ;_egde .PdfObjectReference ._ggde =_dbbe ;_dbbe .skipSpaces ();_dbbe ._fdfg .Discard (9);_dbbe .skipSpaces ();return &_egde ,nil ;};};_ddda .PdfObject ,_dfcbd =_dbbe .parseObject ();if _ddda .PdfObject ==nil {_fg .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");_ddda .PdfObject =MakeNull ();};return &_ddda ,_dfcbd ;};};if _ddda .PdfObject ==nil {_fg .Log .Debug ("\u0049N\u0043\u004f\u004dP\u0041\u0054\u0049B\u0049LI\u0054\u0059\u003a\u0020\u0049\u006e\u0064i\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006e\u006f\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0069\u006e\u0067\u0020\u0061n \u006fb\u006a\u0065\u0063\u0074\u0020\u002d \u0061\u0073\u0073\u0075\u006di\u006e\u0067\u0020\u006e\u0075\u006c\u006c\u0020\u006f\u0062\u006ae\u0063\u0074");_ddda .PdfObject =MakeNull ();};_fg .Log .Trace ("\u0052\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0021");return &_ddda ,nil ;};

// ResolveReference resolves reference if `o` is a *PdfObjectReference and returns the object referenced to.
// Otherwise returns back `o`.
func ResolveReference (obj PdfObject )PdfObject {if _bdff ,_cgefa :=obj .(*PdfObjectReference );_cgefa {return _bdff .Resolve ();};return obj ;};func _ceaa (_dgcd *PdfObjectStream ,_beae *PdfObjectDictionary )(*JBIG2Encoder ,error ){const _ffbd ="\u006ee\u0077\u004a\u0042\u0049G\u0032\u0044\u0065\u0063\u006fd\u0065r\u0046r\u006f\u006d\u0053\u0074\u0072\u0065\u0061m";_ddec :=&JBIG2Encoder {};_fbbag :=_dgcd .PdfObjectDictionary ;if _fbbag ==nil {return _ddec ,nil ;};if _beae ==nil {_dbef :=_fbbag .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _dbef !=nil {switch _deff :=_dbef .(type ){case *PdfObjectDictionary :_beae =_deff ;case *PdfObjectArray :if _deff .Len ()==1{if _dfcb ,_dbbc :=GetDict (_deff .Get (0));_dbbc {_beae =_dfcb ;};};default:_fg .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065P\u0061\u0072\u0061\u006d\u0073\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u0064i\u0063\u0074\u0069\u006f\u006e\u0061\u0072y\u0020\u0025\u0023\u0076",_dbef );return nil ,_bee .Errorf (_ffbd ,"\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050a\u0072m\u0073\u0020\u0074\u0079\u0070\u0065\u003a \u0025\u0054",_deff );};};};if _beae ==nil {return _ddec ,nil ;};_ddec .UpdateParams (_beae );_abgb :=_beae .Get ("\u004a\u0042\u0049G\u0032\u0047\u006c\u006f\u0062\u0061\u006c\u0073");if _abgb ==nil {return _ddec ,nil ;};var _fgf error ;_dddf ,_bbegb :=_abgb .(*PdfObjectStream );if !_bbegb {_fgf =_bee .Error (_ffbd ,"j\u0062\u0069\u0067\u0032\u002e\u0047\u006c\u006f\u0062a\u006c\u0073\u0020\u0073\u0074\u0072\u0065am\u0020\u0073\u0068\u006fu\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u006e\u0020Ob\u006a\u0065c\u0074\u0020\u0053\u0074\u0072\u0065\u0061\u006d");_fg .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_fgf );return nil ,_fgf ;};_ddec .Globals ,_fgf =_eb .DecodeGlobals (_dddf .Stream );if _fgf !=nil {_fgf =_bee .Wrap (_fgf ,_ffbd ,"\u0063\u006f\u0072\u0072u\u0070\u0074\u0065\u0064\u0020\u006a\u0062\u0069\u0067\u0032 \u0065n\u0063\u006f\u0064\u0065\u0064\u0020\u0064a\u0074\u0061");_fg .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_fgf );return nil ,_fgf ;};return _ddec ,nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_daad *RunLengthEncoder )MakeDecodeParams ()PdfObject {return nil };func (_cafg *PdfParser )parseXref ()(*PdfObjectDictionary ,error ){const _ceccc =20;_fgbf ,_ :=_cafg ._fdfg .Peek (_ceccc );for _caaea :=0;_caaea < 2;_caaea ++{if _cafg ._egff ==0{_cafg ._egff =_cafg .GetFileOffset ();};if _effg .Match (_fgbf ){_fg .Log .Trace ("\u0078\u0072e\u0066\u0020\u0070\u006f\u0069\u006e\u0074\u0073\u0020\u0074\u006f\u0020\u0061\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u002e\u0020\u0050\u0072\u006f\u0062\u0061\u0062\u006c\u0079\u0020\u0078\u0072\u0065\u0066\u0020\u006f\u0062\u006a\u0065\u0063\u0074");_fg .Log .Debug ("\u0073t\u0061r\u0074\u0069\u006e\u0067\u0020w\u0069\u0074h\u0020\u0022\u0025\u0073\u0022",string (_fgbf ));return _cafg .parseXrefStream (nil );};if _gcae .Match (_fgbf ){_fg .Log .Trace ("\u0053\u0074\u0061\u006ed\u0061\u0072\u0064\u0020\u0078\u0072\u0065\u0066\u0020\u0073e\u0063t\u0069\u006f\u006e\u0020\u0074\u0061\u0062l\u0065\u0021");return _cafg .parseXrefTable ();};_dbcc :=_cafg .GetFileOffset ();if _cafg ._egff ==0{_cafg ._egff =_dbcc ;};_cafg .SetFileOffset (_dbcc -_ceccc );defer _cafg .SetFileOffset (_dbcc );_edfa ,_ :=_cafg ._fdfg .Peek (_ceccc );_fgbf =append (_edfa ,_fgbf ...);};_fg .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006e\u0067\u003a\u0020\u0055\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f \u0066\u0069\u006e\u0064\u0020\u0078\u0072\u0065f\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006fr\u0020\u0073\u0074\u0072\u0065\u0061\u006d.\u0020\u0052\u0065\u0070\u0061i\u0072\u0020\u0061\u0074\u0074e\u006d\u0070\u0074\u0065\u0064\u003a\u0020\u004c\u006f\u006f\u006b\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0065\u0061\u0072\u006c\u0069\u0065\u0073\u0074\u0020x\u0072\u0065\u0066\u0020\u0066\u0072\u006f\u006d\u0020\u0062\u006f\u0074to\u006d\u002e");if _aaeba :=_cafg .repairSeekXrefMarker ();_aaeba !=nil {_fg .Log .Debug ("\u0052e\u0070a\u0069\u0072\u0020\u0066\u0061i\u006c\u0065d\u0020\u002d\u0020\u0025\u0076",_aaeba );return nil ,_aaeba ;};return _cafg .parseXrefTable ();};func (_fdff *PdfParser )repairRebuildXrefsTopDown ()(*XrefTable ,error ){if _fdff ._adgbc {return nil ,_bec .Errorf ("\u0072\u0065\u0070\u0061\u0069\u0072\u0020\u0066\u0061\u0069\u006c\u0065\u0064");};_fdff ._adgbc =true ;_fdff ._aedcf .Seek (0,_ac .SEEK_SET );_fdff ._fdfg =_af .NewReader (_fdff ._aedcf );_ddce :=20;_fegf :=make ([]byte ,_ddce );_afae :=XrefTable {};_afae .ObjectMap =make (map[int ]XrefObject );for {_edcec ,_gdeea :=_fdff ._fdfg .ReadByte ();if _gdeea !=nil {if _gdeea ==_f .EOF {break ;}else {return nil ,_gdeea ;};};if _edcec =='j'&&_fegf [_ddce -1]=='b'&&_fegf [_ddce -2]=='o'&&IsWhiteSpace (_fegf [_ddce -3]){_eafca :=_ddce -4;for IsWhiteSpace (_fegf [_eafca ])&&_eafca > 0{_eafca --;};if _eafca ==0||!IsDecimalDigit (_fegf [_eafca ]){continue ;};for IsDecimalDigit (_fegf [_eafca ])&&_eafca > 0{_eafca --;};if _eafca ==0||!IsWhiteSpace (_fegf [_eafca ]){continue ;};for IsWhiteSpace (_fegf [_eafca ])&&_eafca > 0{_eafca --;};if _eafca ==0||!IsDecimalDigit (_fegf [_eafca ]){continue ;};for IsDecimalDigit (_fegf [_eafca ])&&_eafca > 0{_eafca --;};if _eafca ==0{continue ;};_bdcea :=_fdff .GetFileOffset ()-int64 (_ddce -_eafca );_bbebc :=append (_fegf [_eafca +1:],_edcec );_fgbb ,_adfa ,_daabf :=_cafac (string (_bbebc ));if _daabf !=nil {_fg .Log .Debug ("\u0055\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u006e\u0075\u006d\u0062\u0065r\u003a\u0020\u0025\u0076",_daabf );return nil ,_daabf ;};if _bdae ,_cfgg :=_afae .ObjectMap [_fgbb ];!_cfgg ||_bdae .Generation < _adfa {_eagc :=XrefObject {};_eagc .XType =XrefTypeTableEntry ;_eagc .ObjectNumber =int (_fgbb );_eagc .Generation =int (_adfa );_eagc .Offset =_bdcea ;_afae .ObjectMap [_fgbb ]=_eagc ;};};_fegf =append (_fegf [1:_ddce ],_edcec );};return &_afae ,nil ;};func _ccbd (_cgef *PdfObjectStream ,_cfg *PdfObjectDictionary )(*FlateEncoder ,error ){_fcdc :=NewFlateEncoder ();_geag :=_cgef .PdfObjectDictionary ;if _geag ==nil {return _fcdc ,nil ;};_fcdc ._cage =_gcgce (_geag );if _cfg ==nil {_cgg :=TraceToDirectObject (_geag .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));switch _fede :=_cgg .(type ){case *PdfObjectArray :_gada :=_fede ;if _gada .Len ()!=1{_fg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072:\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020a\u0072\u0072\u0061\u0079\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0021\u003d\u0020\u0031\u0020\u0028\u0025\u0064\u0029",_gada .Len ());return nil ,_d .New ("\u0072\u0061\u006e\u0067\u0065\u0020\u0063\u0068\u0065\u0063\u006b\u0020e\u0072\u0072\u006f\u0072");};_cgg =TraceToDirectObject (_gada .Get (0));case *PdfObjectDictionary :_cfg =_fede ;case *PdfObjectNull ,nil :default:_fg .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020n\u006f\u0074\u0020\u0061\u0020\u0064\u0069\u0063\u0074\u0069on\u0061\u0072\u0079 \u0028%\u0054\u0029",_cgg );return nil ,_bec .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};if _cfg ==nil {return _fcdc ,nil ;};_fg .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_cfg .String ());_cdga :=_cfg .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");if _cdga ==nil {_fg .Log .Debug ("E\u0072\u0072o\u0072\u003a\u0020\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067 \u0066\u0072\u006f\u006d\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073 \u002d\u0020\u0043\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020\u0077\u0069t\u0068\u0020\u0064\u0065\u0066\u0061\u0075\u006c\u0074\u0020\u00281\u0029");}else {_agb ,_fdbb :=_cdga .(*PdfObjectInteger );if !_fdbb {_fg .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_cdga );return nil ,_bec .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_fcdc .Predictor =int (*_agb );};_cdga =_cfg .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");if _cdga !=nil {_gaec ,_egad :=_cdga .(*PdfObjectInteger );if !_egad {_fg .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");return nil ,_bec .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_fcdc .BitsPerComponent =int (*_gaec );};if _fcdc .Predictor > 1{_fcdc .Columns =1;_cdga =_cfg .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");if _cdga !=nil {_gecd ,_aedc :=_cdga .(*PdfObjectInteger );if !_aedc {return nil ,_bec .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_fcdc .Columns =int (*_gecd );};_fcdc .Colors =1;_cdga =_cfg .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _cdga !=nil {_cdd ,_cgbd :=_cdga .(*PdfObjectInteger );if !_cgbd {return nil ,_bec .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");};_fcdc .Colors =int (*_cdd );};};return _fcdc ,nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_adge *LZWEncoder )MakeDecodeParams ()PdfObject {if _adge .Predictor > 1{_fad :=MakeDict ();_fad .Set ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr",MakeInteger (int64 (_adge .Predictor )));if _adge .BitsPerComponent !=8{_fad .Set ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074",MakeInteger (int64 (_adge .BitsPerComponent )));};if _adge .Columns !=1{_fad .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_adge .Columns )));};if _adge .Colors !=1{_fad .Set ("\u0043\u006f\u006c\u006f\u0072\u0073",MakeInteger (int64 (_adge .Colors )));};return _fad ;};return nil ;};

// GetFilterArray returns the names of the underlying encoding filters in an array that
// can be used as /Filter entry.
func (_bgfab *MultiEncoder )GetFilterArray ()*PdfObjectArray {_baeb :=make ([]PdfObject ,len (_bgfab ._bbce ));for _febca ,_ebcac :=range _bgfab ._bbce {_baeb [_febca ]=MakeName (_ebcac .GetFilterName ());};return MakeArray (_baeb ...);};

// GetObjectNums returns a sorted list of object numbers of the PDF objects in the file.
func (_dfaec *PdfParser )GetObjectNums ()[]int {var _gefc []int ;for _ ,_aefae :=range _dfaec ._dfcg .ObjectMap {_gefc =append (_gefc ,_aefae .ObjectNumber );};_a .Ints (_gefc );return _gefc ;};

// JBIG2CompressionType defines the enum compression type used by the JBIG2Encoder.
type JBIG2CompressionType int ;

// String returns a string describing `null`.
func (_eadca *PdfObjectNull )String ()string {return "\u006e\u0075\u006c\u006c"};

// DecodeBytes decodes a slice of JPX encoded bytes and returns the result.
func (_dbde *JPXEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_fg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_dbde .GetFilterName ());return encoded ,ErrNoJPXDecode ;};

// DecodeStream decodes a multi-encoded stream by passing it through the
// DecodeStream method of the underlying encoders.
func (_fage *MultiEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _fage .DecodeBytes (streamObj .Stream );};

// IsNullObject returns true if `obj` is a PdfObjectNull.
func IsNullObject (obj PdfObject )bool {_ ,_dgae :=TraceToDirectObject (obj ).(*PdfObjectNull );return _dgae ;};

// GetFileOffset returns the current file offset, accounting for buffered position.
func (_edcgc *PdfParser )GetFileOffset ()int64 {_daff ,_ :=_edcgc ._aedcf .Seek (0,_f .SeekCurrent );_daff -=int64 (_edcgc ._fdfg .Buffered ());return _daff ;};

// DecodeBytes decodes a slice of LZW encoded bytes and returns the result.
func (_ecae *LZWEncoder )DecodeBytes (encoded []byte )([]byte ,error ){var _agg _gd .Buffer ;_cbf :=_gd .NewReader (encoded );var _beda _f .ReadCloser ;if _ecae .EarlyChange ==1{_beda =_ec .NewReader (_cbf ,_ec .MSB ,8);}else {_beda =_ea .NewReader (_cbf ,_ea .MSB ,8);};defer _beda .Close ();_ ,_cgdd :=_agg .ReadFrom (_beda );if _cgdd !=nil {return nil ,_cgdd ;};return _agg .Bytes (),nil ;};

// GetStringVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetStringVal (obj PdfObject )(_dgce string ,_fbafd bool ){_dcde ,_fbafd :=TraceToDirectObject (obj ).(*PdfObjectString );if _fbafd {return _dcde .Str (),true ;};return ;};

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_abbd *FlateEncoder )EncodeBytes (data []byte )([]byte ,error ){if _abbd .Predictor !=1&&_abbd .Predictor !=11{_fg .Log .Debug ("E\u006e\u0063\u006f\u0064\u0069\u006e\u0067\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0046\u006c\u0061\u0074\u0065\u0045\u006e\u0063\u006f\u0064\u0065r\u0020P\u0072\u0065\u0064\u0069c\u0074\u006fr\u0020\u003d\u0020\u0031\u002c\u0020\u0031\u0031\u0020\u006f\u006e\u006c\u0079\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064");return nil ,ErrUnsupportedEncodingParameters ;};if _abbd .Predictor ==11{_bagb :=int (_abbd .Columns );_dfd :=len (data )/_bagb ;if len (data )%_bagb !=0{_fg .Log .Error ("\u0049n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");return nil ,_d .New ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u0072o\u0077\u0020l\u0065\u006e\u0067\u0074\u0068");};_fea :=_gd .NewBuffer (nil );_ggab :=make ([]byte ,_bagb );for _adff :=0;_adff < _dfd ;_adff ++{_adcf :=data [_bagb *_adff :_bagb *(_adff +1)];_ggab [0]=_adcf [0];for _bdf :=1;_bdf < _bagb ;_bdf ++{_ggab [_bdf ]=byte (int (_adcf [_bdf ]-_adcf [_bdf -1])%256);};_fea .WriteByte (1);_fea .Write (_ggab );};data =_fea .Bytes ();};var _acef _gd .Buffer ;_abbg :=_e .NewWriter (&_acef );_abbg .Write (data );_abbg .Close ();return _acef .Bytes (),nil ;};func _cgdf (_aga *_bgg .FilterDict ,_aaad *PdfObjectDictionary )error {if _cbbf ,_gffg :=_aaad .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_gffg {if _fgg :=string (*_cbbf );_fgg !="C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"{_fg .Log .Debug ("\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0020C\u0046\u0020\u0064ic\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073\u0020\u0028\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074e\u0072\u0029",_fgg );};};_afcc ,_fbe :=_aaad .Get ("\u0043\u0046\u004d").(*PdfObjectName );if !_fbe {return _bec .Errorf ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0063\u0072\u0079\u0070t\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0028\u004e\u006f\u006e\u0065\u0029");};_aga .CFM =string (*_afcc );if _dba ,_ccdd :=_aaad .Get ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et").(*PdfObjectName );_ccdd {_aga .AuthEvent =_ag .AuthEvent (*_dba );}else {_aga .AuthEvent =_ag .EventDocOpen ;};if _fbb ,_gce :=_aaad .Get ("\u004c\u0065\u006e\u0067\u0074\u0068").(*PdfObjectInteger );_gce {_aga .Length =int (*_fbb );};return nil ;};func (_eaga *PdfParser )repairSeekXrefMarker ()error {_gegcf ,_ddag :=_eaga ._aedcf .Seek (0,_ac .SEEK_END );if _ddag !=nil {return _ddag ;};_ecef :=_ga .MustCompile ("\u005cs\u0078\u0072\u0065\u0066\u005c\u0073*");var _eece int64 ;var _geca int64 =1000;for _eece < _gegcf {if _gegcf <=(_geca +_eece ){_geca =_gegcf -_eece ;};_ ,_bcdfa :=_eaga ._aedcf .Seek (-_eece -_geca ,_ac .SEEK_END );if _bcdfa !=nil {return _bcdfa ;};_fada :=make ([]byte ,_geca );_eaga ._aedcf .Read (_fada );_fg .Log .Trace ("\u004c\u006f\u006fki\u006e\u0067\u0020\u0066\u006f\u0072\u0020\u0078\u0072\u0065\u0066\u0020\u003a\u0020\u0022\u0025\u0073\u0022",string (_fada ));_cfgc :=_ecef .FindAllStringIndex (string (_fada ),-1);if _cfgc !=nil {_dfaea :=_cfgc [len (_cfgc )-1];_fg .Log .Trace ("\u0049\u006e\u0064\u003a\u0020\u0025\u0020\u0064",_cfgc );_eaga ._aedcf .Seek (-_eece -_geca +int64 (_dfaea [0]),_ac .SEEK_END );_eaga ._fdfg =_af .NewReader (_eaga ._aedcf );for {_gcee ,_gceff :=_eaga ._fdfg .Peek (1);if _gceff !=nil {return _gceff ;};_fg .Log .Trace ("\u0042\u003a\u0020\u0025\u0064\u0020\u0025\u0063",_gcee [0],_gcee [0]);if !IsWhiteSpace (_gcee [0]){break ;};_eaga ._fdfg .Discard (1);};return nil ;};_fg .Log .Debug ("\u0057\u0061\u0072\u006e\u0069\u006eg\u003a\u0020\u0045\u004f\u0046\u0020\u006d\u0061\u0072\u006b\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064\u0021\u0020\u002d\u0020\u0063\u006f\u006e\u0074\u0069\u006e\u0075\u0065\u0020s\u0065e\u006b\u0069\u006e\u0067");_eece +=_geca ;};_fg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0058\u0072\u0065\u0066\u0020\u0074a\u0062\u006c\u0065\u0020\u006d\u0061r\u006b\u0065\u0072\u0020\u0077\u0061\u0073\u0020\u006e\u006f\u0074\u0020\u0066o\u0075\u006e\u0064\u002e");return _d .New ("\u0078r\u0065f\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0020");};

// WriteString outputs the object as it is to be written to file.
func (_afda *PdfObjectStreams )WriteString ()string {var _ebad _gg .Builder ;_ebad .WriteString (_g .FormatInt (_afda .ObjectNumber ,10));_ebad .WriteString ("\u0020\u0030\u0020\u0052");return _ebad .String ();};

// MakeDecodeParams makes a new instance of an encoding dictionary based on the current encoder settings.
func (_gcda *JBIG2Encoder )MakeDecodeParams ()PdfObject {return MakeDict ()};const (StreamEncodingFilterNameFlate ="F\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameLZW ="\u004cZ\u0057\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameDCT ="\u0044C\u0054\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameRunLength ="\u0052u\u006eL\u0065\u006e\u0067\u0074\u0068\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameASCIIHex ="\u0041\u0053\u0043\u0049\u0049\u0048\u0065\u0078\u0044e\u0063\u006f\u0064\u0065";StreamEncodingFilterNameASCII85 ="\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameCCITTFax ="\u0043\u0043\u0049\u0054\u0054\u0046\u0061\u0078\u0044e\u0063\u006f\u0064\u0065";StreamEncodingFilterNameJBIG2 ="J\u0042\u0049\u0047\u0032\u0044\u0065\u0063\u006f\u0064\u0065";StreamEncodingFilterNameJPX ="\u004aP\u0058\u0044\u0065\u0063\u006f\u0064e";StreamEncodingFilterNameRaw ="\u0052\u0061\u0077";);

// MakeStreamDict make a new instance of an encoding dictionary for a stream object.
func (_cbed *ASCII85Encoder )MakeStreamDict ()*PdfObjectDictionary {_gfce :=MakeDict ();_gfce .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_cbed .GetFilterName ()));return _gfce ;};

// EncodeImage encodes 'img' golang image.Image into jbig2 encoded bytes document using default encoder settings.
func (_feeb *JBIG2Encoder )EncodeImage (img _cb .Image )([]byte ,error ){return _feeb .encodeImage (img )};

// SetIfNotNil sets the dictionary's key -> val mapping entry -IF- val is not nil.
// Note that we take care to perform a type switch.  Otherwise if we would supply a nil value
// of another type, e.g. (PdfObjectArray*)(nil), then it would not be a PdfObject(nil) and thus
// would get set.
func (_cbdg *PdfObjectDictionary )SetIfNotNil (key PdfObjectName ,val PdfObject ){if val !=nil {switch _aaagd :=val .(type ){case *PdfObjectName :if _aaagd !=nil {_cbdg .Set (key ,val );};case *PdfObjectDictionary :if _aaagd !=nil {_cbdg .Set (key ,val );};case *PdfObjectStream :if _aaagd !=nil {_cbdg .Set (key ,val );};case *PdfObjectString :if _aaagd !=nil {_cbdg .Set (key ,val );};case *PdfObjectNull :if _aaagd !=nil {_cbdg .Set (key ,val );};case *PdfObjectInteger :if _aaagd !=nil {_cbdg .Set (key ,val );};case *PdfObjectArray :if _aaagd !=nil {_cbdg .Set (key ,val );};case *PdfObjectBool :if _aaagd !=nil {_cbdg .Set (key ,val );};case *PdfObjectFloat :if _aaagd !=nil {_cbdg .Set (key ,val );};case *PdfObjectReference :if _aaagd !=nil {_cbdg .Set (key ,val );};case *PdfIndirectObject :if _aaagd !=nil {_cbdg .Set (key ,val );};default:_fg .Log .Error ("\u0045\u0052R\u004f\u0052\u003a\u0020\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0054\u0020\u002d\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065\u0072\u0020\u0068\u0061\u0070\u0070\u0065\u006e\u0021",val );};};};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_bacf *ASCIIHexEncoder )MakeStreamDict ()*PdfObjectDictionary {_gbd :=MakeDict ();_gbd .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_bacf .GetFilterName ()));return _gbd ;};

// UpdateParams updates the parameter values of the encoder.
func (_ceb *FlateEncoder )UpdateParams (params *PdfObjectDictionary ){_dfe ,_bbec :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _bbec ==nil {_ceb .Predictor =int (_dfe );};_dea ,_bbec :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _bbec ==nil {_ceb .BitsPerComponent =int (_dea );};_ded ,_bbec :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _bbec ==nil {_ceb .Columns =int (_ded );};_fagba ,_bbec :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _bbec ==nil {_ceb .Colors =int (_fagba );};};func (_bcga *PdfParser )parseString ()(*PdfObjectString ,error ){_bcga ._fdfg .ReadByte ();var _dbaec _gd .Buffer ;_bffg :=1;for {_eadd ,_bdaad :=_bcga ._fdfg .Peek (1);if _bdaad !=nil {return MakeString (_dbaec .String ()),_bdaad ;};if _eadd [0]=='\\'{_bcga ._fdfg .ReadByte ();_badf ,_cgddb :=_bcga ._fdfg .ReadByte ();if _cgddb !=nil {return MakeString (_dbaec .String ()),_cgddb ;};if IsOctalDigit (_badf ){_aab ,_ebbb :=_bcga ._fdfg .Peek (2);if _ebbb !=nil {return MakeString (_dbaec .String ()),_ebbb ;};var _cded []byte ;_cded =append (_cded ,_badf );for _ ,_edcd :=range _aab {if IsOctalDigit (_edcd ){_cded =append (_cded ,_edcd );}else {break ;};};_bcga ._fdfg .Discard (len (_cded )-1);_fg .Log .Trace ("\u004e\u0075\u006d\u0065ri\u0063\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0022\u0025\u0073\u0022",_cded );_gcea ,_ebbb :=_g .ParseUint (string (_cded ),8,32);if _ebbb !=nil {return MakeString (_dbaec .String ()),_ebbb ;};_dbaec .WriteByte (byte (_gcea ));continue ;};switch _badf {case 'n':_dbaec .WriteRune ('\n');case 'r':_dbaec .WriteRune ('\r');case 't':_dbaec .WriteRune ('\t');case 'b':_dbaec .WriteRune ('\b');case 'f':_dbaec .WriteRune ('\f');case '(':_dbaec .WriteRune ('(');case ')':_dbaec .WriteRune (')');case '\\':_dbaec .WriteRune ('\\');};continue ;}else if _eadd [0]=='('{_bffg ++;}else if _eadd [0]==')'{_bffg --;if _bffg ==0{_bcga ._fdfg .ReadByte ();break ;};};_bbceg ,_ :=_bcga ._fdfg .ReadByte ();_dbaec .WriteByte (_bbceg );};return MakeString (_dbaec .String ()),nil ;};const _fgac ="\u0053\u0074\u0064C\u0046";

// PdfObjectDictionary represents the primitive PDF dictionary/map object.
type PdfObjectDictionary struct{_addf map[PdfObjectName ]PdfObject ;_ccc []PdfObjectName ;_ebfe *PdfParser ;};func (_faebd *PdfParser )parseXrefTable ()(*PdfObjectDictionary ,error ){var _dcge *PdfObjectDictionary ;_ebga ,_daadd :=_faebd .readTextLine ();if _daadd !=nil {return nil ,_daadd ;};_fg .Log .Trace ("\u0078\u0072\u0065\u0066 f\u0069\u0072\u0073\u0074\u0020\u006c\u0069\u006e\u0065\u003a\u0020\u0025\u0073",_ebga );_ada :=-1;_efcf :=0;_cdbb :=false ;_babbd :="";for {_faebd .skipSpaces ();_ ,_gdf :=_faebd ._fdfg .Peek (1);if _gdf !=nil {return nil ,_gdf ;};_ebga ,_gdf =_faebd .readTextLine ();if _gdf !=nil {return nil ,_gdf ;};_abgbf :=_gaef .FindStringSubmatch (_ebga );if len (_abgbf )==0{_fdcb :=len (_babbd )> 0;_babbd +=_ebga +"\u000a";if _fdcb {_abgbf =_gaef .FindStringSubmatch (_babbd );};};if len (_abgbf )==3{_dac ,_ :=_g .Atoi (_abgbf [1]);_aede ,_ :=_g .Atoi (_abgbf [2]);_ada =_dac ;_efcf =_aede ;_cdbb =true ;_babbd ="";_fg .Log .Trace ("\u0078r\u0065\u0066 \u0073\u0075\u0062s\u0065\u0063\u0074\u0069\u006f\u006e\u003a \u0066\u0069\u0072\u0073\u0074\u0020o\u0062\u006a\u0065\u0063\u0074\u003a\u0020\u0025\u0064\u0020\u006fb\u006a\u0065\u0063\u0074\u0073\u003a\u0020\u0025\u0064",_ada ,_efcf );continue ;};_fbd :=_ebeb .FindStringSubmatch (_ebga );if len (_fbd )==4{if _cdbb ==false {_fg .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0058r\u0065\u0066\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0066\u006fr\u006da\u0074\u0021\u000a");return nil ,_d .New ("\u0078\u0072\u0065\u0066 i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072\u006d\u0061\u0074");};_cgfb ,_ :=_g .ParseInt (_fbd [1],10,64);_dffc ,_ :=_g .Atoi (_fbd [2]);_dbaf :=_fbd [3];_babbd ="";if _gg .ToLower (_dbaf )=="\u006e"&&_cgfb > 1{_ebcda ,_acgg :=_faebd ._dfcg .ObjectMap [_ada ];if !_acgg ||_dffc > _ebcda .Generation {_acda :=XrefObject {ObjectNumber :_ada ,XType :XrefTypeTableEntry ,Offset :_cgfb ,Generation :_dffc };_faebd ._dfcg .ObjectMap [_ada ]=_acda ;};};_ada ++;continue ;};if (len (_ebga )> 6)&&(_ebga [:7]=="\u0074r\u0061\u0069\u006c\u0065\u0072"){_fg .Log .Trace ("\u0046o\u0075n\u0064\u0020\u0074\u0072\u0061i\u006c\u0065r\u0020\u002d\u0020\u0025\u0073",_ebga );if len (_ebga )> 9{_ddbe :=_faebd .GetFileOffset ();_faebd .SetFileOffset (_ddbe -int64 (len (_ebga ))+7);};_faebd .skipSpaces ();_faebd .skipComments ();_fg .Log .Trace ("R\u0065\u0061\u0064\u0069ng\u0020t\u0072\u0061\u0069\u006c\u0065r\u0020\u0064\u0069\u0063\u0074\u0021");_fg .Log .Trace ("\u0070\u0065\u0065\u006b\u003a\u0020\u0022\u0025\u0073\u0022",_ebga );_dcge ,_gdf =_faebd .ParseDict ();_fg .Log .Trace ("\u0045O\u0046\u0020\u0072\u0065a\u0064\u0069\u006e\u0067\u0020t\u0072a\u0069l\u0065\u0072\u0020\u0064\u0069\u0063\u0074!");if _gdf !=nil {_fg .Log .Debug ("\u0045\u0072\u0072o\u0072\u0020\u0070\u0061r\u0073\u0069\u006e\u0067\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u0064\u0069\u0063\u0074\u0020\u0028\u0025\u0073\u0029",_gdf );return nil ,_gdf ;};break ;};if _ebga =="\u0025\u0025\u0045O\u0046"{_fg .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006e\u0064 \u006f\u0066\u0020\u0066\u0069\u006c\u0065 -\u0020\u0074\u0072\u0061i\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066ou\u006e\u0064 \u002d\u0020\u0065\u0072\u0072\u006f\u0072\u0021");return nil ,_d .New ("\u0065\u006e\u0064 \u006f\u0066\u0020\u0066i\u006c\u0065\u0020\u002d\u0020\u0074\u0072a\u0069\u006c\u0065\u0072\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064");};_fg .Log .Trace ("\u0078\u0072\u0065\u0066\u0020\u006d\u006f\u0072\u0065 \u003a\u0020\u0025\u0073",_ebga );};_fg .Log .Trace ("\u0045\u004f\u0046 p\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0021");if _faebd ._bbgc ==nil {_fabad :=XrefTypeTableEntry ;_faebd ._bbgc =&_fabad ;};return _dcge ,nil ;};

// MakeEncodedString creates a PdfObjectString with encoded content, which can be either
// UTF-16BE or PDFDocEncoding depending on whether `utf16BE` is true or false respectively.
func MakeEncodedString (s string ,utf16BE bool )*PdfObjectString {if utf16BE {var _bgfc _gd .Buffer ;_bgfc .Write ([]byte {0xFE,0xFF});_bgfc .WriteString (_cf .StringToUTF16 (s ));return &PdfObjectString {_fbedf :_bgfc .String (),_dafg :true };};return &PdfObjectString {_fbedf :string (_cf .StringToPDFDocEncoding (s )),_dafg :false };};

// GetFilterName returns the name of the encoding filter.
func (_aee *FlateEncoder )GetFilterName ()string {return StreamEncodingFilterNameFlate };func (_egef *PdfParser )readTextLine ()(string ,error ){var _cgc _gd .Buffer ;for {_gdag ,_ffef :=_egef ._fdfg .Peek (1);if _ffef !=nil {_fg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_ffef .Error ());return _cgc .String (),_ffef ;};if (_gdag [0]!='\r')&&(_gdag [0]!='\n'){_cefb ,_ :=_egef ._fdfg .ReadByte ();_cgc .WriteByte (_cefb );}else {break ;};};return _cgc .String (),nil ;};const _cdcge =32<<(^uint (0)>>63);type objectStreams map[int ]objectStream ;

// SetPredictor sets the predictor function.  Specify the number of columns per row.
// The columns indicates the number of samples per row.
// Used for grouping data together for compression.
func (_gdeba *FlateEncoder )SetPredictor (columns int ){_gdeba .Predictor =11;_gdeba .Columns =columns ;};

// AddEncoder adds the passed in encoder to the underlying encoder slice.
func (_ccga *MultiEncoder )AddEncoder (encoder StreamEncoder ){_ccga ._bbce =append (_ccga ._bbce ,encoder );};

// GetNumbersAsFloat converts a list of pdf objects representing floats or integers to a slice of
// float64 values.
func GetNumbersAsFloat (objects []PdfObject )(_ebfd []float64 ,_fffd error ){for _ ,_bbege :=range objects {_fcdfd ,_dccg :=GetNumberAsFloat (_bbege );if _dccg !=nil {return nil ,_dccg ;};_ebfd =append (_ebfd ,_fcdfd );};return _ebfd ,nil ;};var _dbee =_ga .MustCompile ("\u0025P\u0044F\u002d\u0028\u005c\u0064\u0029\u005c\u002e\u0028\u005c\u0064\u0029");func _fbeab (_gffeb ,_fedd ,_ddfcb int )error {if _fedd < 0||_fedd > _gffeb {return _d .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0061\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");};if _ddfcb < _fedd {return _d .New ("\u0069n\u0076\u0061\u006c\u0069d\u0020\u0073\u006c\u0069\u0063e\u0020i\u006ed\u0065\u0078\u0020\u0062\u0020\u003c\u0020a");};if _ddfcb > _gffeb {return _d .New ("s\u006c\u0069\u0063\u0065\u0020\u0069n\u0064\u0065\u0078\u0020\u0062\u0020\u006f\u0075\u0074 \u006f\u0066\u0020b\u006fu\u006e\u0064\u0073");};return nil ;};

// WriteString outputs the object as it is to be written to file.
func (_ccfff *PdfObjectName )WriteString ()string {var _adfda _gd .Buffer ;if len (*_ccfff )> 127{_fg .Log .Debug ("\u0045R\u0052\u004f\u0052\u003a \u004e\u0061\u006d\u0065\u0020t\u006fo\u0020l\u006f\u006e\u0067\u0020\u0028\u0025\u0073)",*_ccfff );};_adfda .WriteString ("\u002f");for _gefd :=0;_gefd < len (*_ccfff );_gefd ++{_gabg :=(*_ccfff )[_gefd ];if !IsPrintable (_gabg )||_gabg =='#'||IsDelimiter (_gabg ){_adfda .WriteString (_bec .Sprintf ("\u0023\u0025\u002e2\u0078",_gabg ));}else {_adfda .WriteByte (_gabg );};};return _adfda .String ();};

// DecodeStream decodes a JPX encoded stream and returns the result as a
// slice of bytes.
func (_ddef *JPXEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_fg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_ddef .GetFilterName ());return streamObj .Stream ,ErrNoJPXDecode ;};

// Encrypt an object with specified key. For numbered objects,
// the key argument is not used and a new one is generated based
// on the object and generation number.
// Traverses through all the subobjects (recursive).
//
// Does not look up references..  That should be done prior to calling.
func (_fag *PdfCrypt )Encrypt (obj PdfObject ,parentObjNum ,parentGenNum int64 )error {if _fag .isEncrypted (obj ){return nil ;};switch _fagb :=obj .(type ){case *PdfIndirectObject :_fag ._bac [_fagb ]=true ;_fg .Log .Trace ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006e\u0067 \u0069\u006e\u0064\u0069\u0072\u0065\u0063t\u0020\u0025\u0064\u0020\u0025\u0064\u0020\u006f\u0062\u006a\u0021",_fagb .ObjectNumber ,_fagb .GenerationNumber );_befa :=_fagb .ObjectNumber ;_fbbf :=_fagb .GenerationNumber ;_cgb :=_fag .Encrypt (_fagb .PdfObject ,_befa ,_fbbf );if _cgb !=nil {return _cgb ;};return nil ;case *PdfObjectStream :_fag ._bac [_fagb ]=true ;_ecd :=_fagb .PdfObjectDictionary ;if _agd ,_ccb :=_ecd .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_ccb &&*_agd =="\u0058\u0052\u0065\u0066"{return nil ;};_ggb :=_fagb .ObjectNumber ;_gffb :=_fagb .GenerationNumber ;_fg .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070t\u0069\u006e\u0067\u0020\u0073t\u0072e\u0061m\u0020\u0025\u0064\u0020\u0025\u0064\u0020!",_ggb ,_gffb );_gdg :=_fgac ;if _fag ._dge .V >=4{_gdg =_fag ._dec ;_fg .Log .Trace ("\u0074\u0068\u0069\u0073.s\u0074\u0072\u0065\u0061\u006d\u0046\u0069\u006c\u0074\u0065\u0072\u0020\u003d\u0020%\u0073",_fag ._dec );if _cag ,_dcag :=_ecd .Get ("\u0046\u0069\u006c\u0074\u0065\u0072").(*PdfObjectArray );_dcag {if _decb ,_gcd :=GetName (_cag .Get (0));_gcd {if *_decb =="\u0043\u0072\u0079p\u0074"{_gdg ="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079";if _eaee ,_geac :=_ecd .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073").(*PdfObjectDictionary );_geac {if _gecf ,_fbg :=_eaee .Get ("\u004e\u0061\u006d\u0065").(*PdfObjectName );_fbg {if _ ,_gdeb :=_fag ._eae [string (*_gecf )];_gdeb {_fg .Log .Trace ("\u0055\u0073\u0069\u006eg \u0073\u0074\u0072\u0065\u0061\u006d\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020%\u0073",*_gecf );_gdg =string (*_gecf );};};};};};};_fg .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_gdg );if _gdg =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};};_befe :=_fag .Encrypt (_fagb .PdfObjectDictionary ,_ggb ,_gffb );if _befe !=nil {return _befe ;};_bcgd ,_befe :=_fag .makeKey (_gdg ,uint32 (_ggb ),uint32 (_gffb ),_fag ._cge );if _befe !=nil {return _befe ;};_fagb .Stream ,_befe =_fag .encryptBytes (_fagb .Stream ,_gdg ,_bcgd );if _befe !=nil {return _befe ;};_ecd .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_fagb .Stream ))));return nil ;case *PdfObjectString :_fg .Log .Trace ("\u0045n\u0063r\u0079\u0070\u0074\u0069\u006eg\u0020\u0073t\u0072\u0069\u006e\u0067\u0021");_fba :=_fgac ;if _fag ._dge .V >=4{_fg .Log .Trace ("\u0077\u0069\u0074\u0068\u0020\u0025\u0073\u0020\u0066i\u006c\u0074\u0065\u0072",_fag ._acd );if _fag ._acd =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{return nil ;};_fba =_fag ._acd ;};_abg ,_bbeg :=_fag .makeKey (_fba ,uint32 (parentObjNum ),uint32 (parentGenNum ),_fag ._cge );if _bbeg !=nil {return _bbeg ;};_adfd :=_fagb .Str ();_bdde :=make ([]byte ,len (_adfd ));for _fgdd :=0;_fgdd < len (_adfd );_fgdd ++{_bdde [_fgdd ]=_adfd [_fgdd ];};_fg .Log .Trace ("\u0045n\u0063\u0072\u0079\u0070\u0074\u0020\u0073\u0074\u0072\u0069\u006eg\u003a\u0020\u0025\u0073\u0020\u003a\u0020\u0025\u0020\u0078",_bdde ,_bdde );_bdde ,_bbeg =_fag .encryptBytes (_bdde ,_fba ,_abg );if _bbeg !=nil {return _bbeg ;};_fagb ._fbedf =string (_bdde );return nil ;case *PdfObjectArray :for _ ,_bgfa :=range _fagb .Elements (){_ffe :=_fag .Encrypt (_bgfa ,parentObjNum ,parentGenNum );if _ffe !=nil {return _ffe ;};};return nil ;case *PdfObjectDictionary :_gee :=false ;if _geec :=_fagb .Get ("\u0054\u0079\u0070\u0065");_geec !=nil {_ecaf ,_ggdd :=_geec .(*PdfObjectName );if _ggdd &&*_ecaf =="\u0053\u0069\u0067"{_gee =true ;};};for _ ,_bfae :=range _fagb .Keys (){_edbd :=_fagb .Get (_bfae );if _gee &&string (_bfae )=="\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0073"{continue ;};if string (_bfae )!="\u0050\u0061\u0072\u0065\u006e\u0074"&&string (_bfae )!="\u0050\u0072\u0065\u0076"&&string (_bfae )!="\u004c\u0061\u0073\u0074"{_bdg :=_fag .Encrypt (_edbd ,parentObjNum ,parentGenNum );if _bdg !=nil {return _bdg ;};};};return nil ;};return nil ;};

// StreamEncoder represents the interface for all PDF stream encoders.
type StreamEncoder interface{GetFilterName ()string ;MakeDecodeParams ()PdfObject ;MakeStreamDict ()*PdfObjectDictionary ;UpdateParams (_bged *PdfObjectDictionary );EncodeBytes (_cdf []byte )([]byte ,error );DecodeBytes (_fbgb []byte )([]byte ,error );DecodeStream (_gegf *PdfObjectStream )([]byte ,error );};

// NewASCII85Encoder makes a new ASCII85 encoder.
func NewASCII85Encoder ()*ASCII85Encoder {_caca :=&ASCII85Encoder {};return _caca };

// NewCCITTFaxEncoder makes a new CCITTFax encoder.
func NewCCITTFaxEncoder ()*CCITTFaxEncoder {return &CCITTFaxEncoder {Columns :1728,EndOfBlock :true }};func (_afebb *PdfParser )skipComments ()error {if _ ,_eccd :=_afebb .skipSpaces ();_eccd !=nil {return _eccd ;};_ggba :=true ;for {_bbgg ,_efage :=_afebb ._fdfg .Peek (1);if _efage !=nil {_fg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u0020\u0025\u0073",_efage .Error ());return _efage ;};if _ggba &&_bbgg [0]!='%'{return nil ;};_ggba =false ;if (_bbgg [0]!='\r')&&(_bbgg [0]!='\n'){_afebb ._fdfg .ReadByte ();}else {break ;};};return _afebb .skipComments ();};

// DecodeBytes decodes a multi-encoded slice of bytes by passing it through the
// DecodeBytes method of the underlying encoders.
func (_dgdbg *MultiEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_bbda :=encoded ;var _bbbdg error ;for _ ,_aecc :=range _dgdbg ._bbce {_fg .Log .Trace ("\u004du\u006c\u0074i\u0020\u0045\u006e\u0063o\u0064\u0065\u0072 \u0044\u0065\u0063\u006f\u0064\u0065\u003a\u0020\u0041pp\u006c\u0079\u0069n\u0067\u0020F\u0069\u006c\u0074\u0065\u0072\u003a \u0025\u0076 \u0025\u0054",_aecc ,_aecc );_bbda ,_bbbdg =_aecc .DecodeBytes (_bbda );if _bbbdg !=nil {return nil ,_bbbdg ;};};return _bbda ,nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_eee *JPXEncoder )UpdateParams (params *PdfObjectDictionary ){};

// GetCrypter returns the PdfCrypt instance which has information about the PDFs encryption.
func (_dede *PdfParser )GetCrypter ()*PdfCrypt {return _dede ._dgfca };

// ToGoImage converts the JBIG2Image to the golang image.Image.
func (_edcb *JBIG2Image )ToGoImage ()(_cb .Image ,error ){const _aced ="J\u0042I\u0047\u0032\u0049\u006d\u0061\u0067\u0065\u002eT\u006f\u0047\u006f\u0049ma\u0067\u0065";if _edcb .Data ==nil {return nil ,_bee .Error (_aced ,"\u0069\u006d\u0061\u0067e \u0064\u0061\u0074\u0061\u0020\u006e\u006f\u0074\u0020\u0064\u0065\u0066\u0069\u006ee\u0064");};if _edcb .Width ==0||_edcb .Height ==0{return nil ,_bee .Error (_aced ,"\u0069\u006d\u0061\u0067\u0065\u0020h\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u0077\u0069\u0064\u0074h\u0020\u006e\u006f\u0074\u0020\u0064\u0065f\u0069\u006e\u0065\u0064");};_bfcc ,_dccb :=_ba .NewImage (_edcb .Width ,_edcb .Height ,1,1,_edcb .Data ,nil ,nil );if _dccb !=nil {return nil ,_dccb ;};return _bfcc ,nil ;};

// NewLZWEncoder makes a new LZW encoder with default parameters.
func NewLZWEncoder ()*LZWEncoder {_dceb :=&LZWEncoder {};_dceb .Predictor =1;_dceb .BitsPerComponent =8;_dceb .Colors =1;_dceb .Columns =1;_dceb .EarlyChange =1;return _dceb ;};

// DecodeBytes decodes byte array with ASCII85. 5 ASCII characters -> 4 raw binary bytes
func (_bbea *ASCII85Encoder )DecodeBytes (encoded []byte )([]byte ,error ){var _cffeg []byte ;_fg .Log .Trace ("\u0041\u0053\u0043\u0049\u0049\u0038\u0035\u0020\u0044e\u0063\u006f\u0064\u0065");_bagdb :=0;_aea :=false ;for _bagdb < len (encoded )&&!_aea {_ggad :=[5]byte {0,0,0,0,0};_afba :=0;_fcdg :=0;_cdcg :=4;for _fcdg < 5+_afba {if _bagdb +_fcdg ==len (encoded ){break ;};_abgg :=encoded [_bagdb +_fcdg ];if IsWhiteSpace (_abgg ){_afba ++;_fcdg ++;continue ;}else if _abgg =='~'&&_bagdb +_fcdg +1< len (encoded )&&encoded [_bagdb +_fcdg +1]=='>'{_cdcg =(_fcdg -_afba )-1;if _cdcg < 0{_cdcg =0;};_aea =true ;break ;}else if _abgg >='!'&&_abgg <='u'{_abgg -='!';}else if _abgg =='z'&&_fcdg -_afba ==0{_cdcg =4;_fcdg ++;break ;}else {_fg .Log .Error ("\u0046\u0061i\u006c\u0065\u0064\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u002c\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020co\u0064\u0065");return nil ,_d .New ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0063\u006f\u0064\u0065\u0020e\u006e\u0063\u006f\u0075\u006e\u0074\u0065\u0072\u0065\u0064");};_ggad [_fcdg -_afba ]=_abgg ;_fcdg ++;};_bagdb +=_fcdg ;for _bacgc :=_cdcg +1;_bacgc < 5;_bacgc ++{_ggad [_bacgc ]=84;};_bbbc :=uint32 (_ggad [0])*85*85*85*85+uint32 (_ggad [1])*85*85*85+uint32 (_ggad [2])*85*85+uint32 (_ggad [3])*85+uint32 (_ggad [4]);_bgdg :=[]byte {byte ((_bbbc >>24)&0xff),byte ((_bbbc >>16)&0xff),byte ((_bbbc >>8)&0xff),byte (_bbbc &0xff)};_cffeg =append (_cffeg ,_bgdg [:_cdcg ]...);};_fg .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0065\u006e\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",encoded );_fg .Log .Trace ("A\u0053\u0043\u0049\u004985\u002c \u0064\u0065\u0063\u006f\u0064e\u0064\u003a\u0020\u0025\u0020\u0058",_cffeg );return _cffeg ,nil ;};

// TraceToDirectObject traces a PdfObject to a direct object.  For example direct objects contained
// in indirect objects (can be double referenced even).
func TraceToDirectObject (obj PdfObject )PdfObject {if _dgfcf ,_bebg :=obj .(*PdfObjectReference );_bebg {obj =_dgfcf .Resolve ();};_ceadc ,_ceeg :=obj .(*PdfIndirectObject );_dgdbf :=0;for _ceeg {obj =_ceadc .PdfObject ;_ceadc ,_ceeg =GetIndirect (obj );_dgdbf ++;if _dgdbf > _cfaag {_fg .Log .Error ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0072\u0061\u0063\u0065\u0020\u0064\u0065p\u0074\u0068\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u0062\u0065\u0079\u006fn\u0064\u0020\u0025\u0064\u0020\u002d\u0020\u006e\u006f\u0074\u0020\u0067oi\u006e\u0067\u0020\u0064\u0065\u0065\u0070\u0065\u0072\u0021",_cfaag );return nil ;};};return obj ;};

// GetFloat returns the *PdfObjectFloat represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetFloat (obj PdfObject )(_debe *PdfObjectFloat ,_ggdb bool ){_debe ,_ggdb =TraceToDirectObject (obj ).(*PdfObjectFloat );return _debe ,_ggdb ;};func _gcgce (_acec *PdfObjectDictionary )(_daefa *_ba .ImageBase ){var (_gagd *PdfObjectInteger ;_gaeg bool ;);if _gagd ,_gaeg =_acec .Get ("\u0057\u0069\u0064t\u0068").(*PdfObjectInteger );_gaeg {_daefa =&_ba .ImageBase {Width :int (*_gagd )};}else {return nil ;};if _gagd ,_gaeg =_acec .Get ("\u0048\u0065\u0069\u0067\u0068\u0074").(*PdfObjectInteger );_gaeg {_daefa .Height =int (*_gagd );};if _gagd ,_gaeg =_acec .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074").(*PdfObjectInteger );_gaeg {_daefa .BitsPerComponent =int (*_gagd );};if _gagd ,_gaeg =_acec .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073").(*PdfObjectInteger );_gaeg {_daefa .ColorComponents =int (*_gagd );};return _daefa ;};func (_cecg *PdfObjectFloat )String ()string {return _bec .Sprintf ("\u0025\u0066",*_cecg )};const (_dcab =0;_dcd =1;_cefd =2;_gegc =3;_dcc =4;);

// GetDict returns the *PdfObjectDictionary represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetDict (obj PdfObject )(_bfda *PdfObjectDictionary ,_abfc bool ){_bfda ,_abfc =TraceToDirectObject (obj ).(*PdfObjectDictionary );return _bfda ,_abfc ;};

// LZWEncoder provides LZW encoding/decoding functionality.
type LZWEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Colors int ;

// LZW algorithm setting.
EarlyChange int ;};

// PdfObjectStream represents the primitive PDF Object stream.
type PdfObjectStream struct{PdfObjectReference ;*PdfObjectDictionary ;Stream []byte ;};

// GetStringBytes is like GetStringVal except that it returns the string as a []byte.
// It is for convenience.
func GetStringBytes (obj PdfObject )(_dceg []byte ,_ggaa bool ){_fgad ,_ggaa :=TraceToDirectObject (obj ).(*PdfObjectString );if _ggaa {return _fgad .Bytes (),true ;};return ;};

// GetIndirect returns the *PdfIndirectObject represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetIndirect (obj PdfObject )(_faa *PdfIndirectObject ,_bgfdf bool ){obj =ResolveReference (obj );_faa ,_bgfdf =obj .(*PdfIndirectObject );return _faa ,_bgfdf ;};

// DecodeGlobals decodes 'encoded' byte stream and returns their Globally defined segments ('Globals').
func (_feea *JBIG2Encoder )DecodeGlobals (encoded []byte )(_eb .Globals ,error ){return _eb .DecodeGlobals (encoded );};func _cafac (_befag string )(int ,int ,error ){_daag :=_effg .FindStringSubmatch (_befag );if len (_daag )< 3{return 0,0,_d .New ("\u0075\u006e\u0061b\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020s\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065");};_abbgf ,_ :=_g .Atoi (_daag [1]);_feaf ,_ :=_g .Atoi (_daag [2]);return _abbgf ,_feaf ,nil ;};func _adfdd (_ddffe PdfObject )(*float64 ,error ){switch _ddddc :=_ddffe .(type ){case *PdfObjectFloat :_ebba :=float64 (*_ddddc );return &_ebba ,nil ;case *PdfObjectInteger :_fgdcd :=float64 (*_ddddc );return &_fgdcd ,nil ;case *PdfObjectNull :return nil ,nil ;};return nil ,ErrNotANumber ;};

// Inspect analyzes the document object structure. Returns a map of object types (by name) with the instance count
// as value.
func (_agdb *PdfParser )Inspect ()(map[string ]int ,error ){return _agdb .inspect ()};func _dde (_gaac *PdfObjectStream ,_dfec *PdfObjectDictionary )(*LZWEncoder ,error ){_efdb :=NewLZWEncoder ();_deg :=_gaac .PdfObjectDictionary ;if _deg ==nil {return _efdb ,nil ;};if _dfec ==nil {_adffb :=TraceToDirectObject (_deg .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073"));if _adffb !=nil {if _cdad ,_gdgf :=_adffb .(*PdfObjectDictionary );_gdgf {_dfec =_cdad ;}else if _cegd ,_dgdbc :=_adffb .(*PdfObjectArray );_dgdbc {if _cegd .Len ()==1{if _ddff ,_cbgc :=GetDict (_cegd .Get (0));_cbgc {_dfec =_ddff ;};};};if _dfec ==nil {_fg .Log .Error ("\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073\u0020\u006e\u006f\u0074 \u0061 \u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0020\u0025\u0023\u0076",_adffb );return nil ,_bec .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0044\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");};};};_ecab :=_deg .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");if _ecab !=nil {_fagc ,_bgeg :=_ecab .(*PdfObjectInteger );if !_bgeg {_fg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a \u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065d\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074\u0020\u006e\u0075\u006d\u0065\u0072i\u0063 \u0028\u0025\u0054\u0029",_ecab );return nil ,_bec .Errorf ("\u0069\u006e\u0076\u0061li\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065");};if *_fagc !=0&&*_fagc !=1{return nil ,_bec .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0045\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065\u0020\u0076\u0061\u006c\u0075e\u0020\u0028\u006e\u006f\u0074 \u0030\u0020o\u0072\u0020\u0031\u0029");};_efdb .EarlyChange =int (*_fagc );}else {_efdb .EarlyChange =1;};if _dfec ==nil {return _efdb ,nil ;};_ecab =_dfec .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr");if _ecab !=nil {_gdgb ,_beeb :=_ecab .(*PdfObjectInteger );if !_beeb {_fg .Log .Debug ("E\u0072\u0072\u006f\u0072\u003a\u0020\u0050\u0072\u0065d\u0069\u0063\u0074\u006f\u0072\u0020\u0073pe\u0063\u0069\u0066\u0069e\u0064\u0020\u0062\u0075\u0074\u0020\u006e\u006f\u0074 n\u0075\u006de\u0072\u0069\u0063\u0020\u0028\u0025\u0054\u0029",_ecab );return nil ,_bec .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0050\u0072\u0065\u0064i\u0063\u0074\u006f\u0072");};_efdb .Predictor =int (*_gdgb );};_ecab =_dfec .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");if _ecab !=nil {_fdc ,_fbcc :=_ecab .(*PdfObjectInteger );if !_fbcc {_fg .Log .Debug ("\u0045\u0052\u0052O\u0052\u003a\u0020\u0049n\u0076\u0061\u006c\u0069\u0064\u0020\u0042i\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");return nil ,_bec .Errorf ("\u0069n\u0076\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050e\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074");};_efdb .BitsPerComponent =int (*_fdc );};if _efdb .Predictor > 1{_efdb .Columns =1;_ecab =_dfec .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073");if _ecab !=nil {_gfd ,_cac :=_ecab .(*PdfObjectInteger );if !_cac {return nil ,_bec .Errorf ("\u0070r\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u0020\u0063\u006f\u006cu\u006d\u006e\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064");};_efdb .Columns =int (*_gfd );};_efdb .Colors =1;_ecab =_dfec .Get ("\u0043\u006f\u006c\u006f\u0072\u0073");if _ecab !=nil {_bgcd ,_fgaf :=_ecab .(*PdfObjectInteger );if !_fgaf {return nil ,_bec .Errorf ("\u0070\u0072\u0065d\u0069\u0063\u0074\u006fr\u0020\u0063\u006f\u006c\u006f\u0072\u0073 \u006e\u006f\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072");};_efdb .Colors =int (*_bgcd );};};_fg .Log .Trace ("\u0064\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006ds\u003a\u0020\u0025\u0073",_dfec .String ());return _efdb ,nil ;};

// NewJBIG2Encoder creates a new JBIG2Encoder.
func NewJBIG2Encoder ()*JBIG2Encoder {return &JBIG2Encoder {_dagf :_bg .InitEncodeDocument (false )}};

// DecodeStream decodes RunLengthEncoded stream object and give back decoded bytes.
func (_bdgf *RunLengthEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _bdgf .DecodeBytes (streamObj .Stream );};

// String returns a string representation of the *PdfObjectString.
func (_ggagf *PdfObjectString )String ()string {return _ggagf ._fbedf };

// GetNameVal returns the string value represented by the PdfObject directly or indirectly if
// contained within an indirect object. On type mismatch the found bool flag returned is false and
// an empty string is returned.
func GetNameVal (obj PdfObject )(_bebf string ,_ddaa bool ){_bagac ,_ddaa :=TraceToDirectObject (obj ).(*PdfObjectName );if _ddaa {return string (*_bagac ),true ;};return ;};

// DecodeStream implements ASCII85 stream decoding.
func (_cbc *ASCII85Encoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _cbc .DecodeBytes (streamObj .Stream );};func (_abf *PdfCrypt )saveCryptFilters (_cdg *PdfObjectDictionary )error {if _abf ._dge .V < 4{return _d .New ("\u0063\u0061\u006e\u0020\u006f\u006e\u006c\u0079\u0020\u0062\u0065 \u0075\u0073\u0065\u0064\u0020\u0077\u0069\u0074\u0068\u0020V\u003e\u003d\u0034");};_fcd :=MakeDict ();_cdg .Set ("\u0043\u0046",_fcd );for _cdc ,_ade :=range _abf ._eae {if _cdc =="\u0049\u0064\u0065\u006e\u0074\u0069\u0074\u0079"{continue ;};_ccf :=_aadb (_ade ,"");_fcd .Set (PdfObjectName (_cdc ),_ccf );};_cdg .Set ("\u0053\u0074\u0072\u0046",MakeName (_abf ._acd ));_cdg .Set ("\u0053\u0074\u006d\u0046",MakeName (_abf ._dec ));return nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_edec *RunLengthEncoder )UpdateParams (params *PdfObjectDictionary ){};

// Keys returns the list of keys in the dictionary.
// If `d` is nil returns a nil slice.
func (_dbg *PdfObjectDictionary )Keys ()[]PdfObjectName {if _dbg ==nil {return nil ;};return _dbg ._ccc ;};

// Set sets the dictionary's key -> val mapping entry. Overwrites if key already set.
func (_ecbcf *PdfObjectDictionary )Set (key PdfObjectName ,val PdfObject ){_ ,_gcde :=_ecbcf ._addf [key ];if !_gcde {_ecbcf ._ccc =append (_ecbcf ._ccc ,key );};_ecbcf ._addf [key ]=val ;};

// MultiEncoder supports serial encoding.
type MultiEncoder struct{_bbce []StreamEncoder };

// IsFloatDigit checks if a character can be a part of a float number string.
func IsFloatDigit (c byte )bool {return ('0'<=c &&c <='9')||c =='.'};

// Get returns the PdfObject corresponding to the specified key.
// Returns a nil value if the key is not set.
func (_cfbc *PdfObjectDictionary )Get (key PdfObjectName )PdfObject {_gddf ,_baag :=_cfbc ._addf [key ];if !_baag {return nil ;};return _gddf ;};

// NewJPXEncoder returns a new instance of JPXEncoder.
func NewJPXEncoder ()*JPXEncoder {return &JPXEncoder {}};

// String returns the state of the bool as "true" or "false".
func (_cfeeb *PdfObjectBool )String ()string {if *_cfeeb {return "\u0074\u0072\u0075\u0065";};return "\u0066\u0061\u006cs\u0065";};

// PdfObjectInteger represents the primitive PDF integer numerical object.
type PdfObjectInteger int64 ;func _aadb (_efc _bgg .Filter ,_agcg _ag .AuthEvent )*PdfObjectDictionary {if _agcg ==""{_agcg =_ag .EventDocOpen ;};_dcec :=MakeDict ();_dcec .Set ("\u0054\u0079\u0070\u0065",MakeName ("C\u0072\u0079\u0070\u0074\u0046\u0069\u006c\u0074\u0065\u0072"));_dcec .Set ("\u0041u\u0074\u0068\u0045\u0076\u0065\u006et",MakeName (string (_agcg )));_dcec .Set ("\u0043\u0046\u004d",MakeName (_efc .Name ()));_dcec .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_efc .KeyLength ())));return _dcec ;};var _cedag =_ga .MustCompile ("\u005e\\\u0073\u002a\u005b\u002d]\u002a\u0028\u005c\u0064\u002b)\u005cs\u002b(\u005c\u0064\u002b\u0029\u005c\u0073\u002bR");

// WriteString outputs the object as it is to be written to file.
func (_fcdab *PdfObjectNull )WriteString ()string {return "\u006e\u0075\u006c\u006c"};

// SetImage sets the image base for given flate encoder.
func (_eab *FlateEncoder )SetImage (img *_ba .ImageBase ){_eab ._cage =img };func (_bfe *PdfCrypt )newEncryptDict ()*PdfObjectDictionary {_ffag :=MakeDict ();_ffag .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName ("\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064"));_ffag .Set ("\u0056",MakeInteger (int64 (_bfe ._dge .V )));_ffag .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (_bfe ._dge .Length )));return _ffag ;};

// GetFilterName returns the name of the encoding filter.
func (_cdac *RawEncoder )GetFilterName ()string {return StreamEncodingFilterNameRaw };

// GetString returns the *PdfObjectString represented by the PdfObject directly or indirectly within an indirect
// object. On type mismatch the found bool flag is false and a nil pointer is returned.
func GetString (obj PdfObject )(_edce *PdfObjectString ,_fcgd bool ){_edce ,_fcgd =TraceToDirectObject (obj ).(*PdfObjectString );return _edce ,_fcgd ;};

// GetStream returns the *PdfObjectStream represented by the PdfObject. On type mismatch the found bool flag is
// false and a nil pointer is returned.
func GetStream (obj PdfObject )(_facab *PdfObjectStream ,_gafa bool ){obj =ResolveReference (obj );_facab ,_gafa =obj .(*PdfObjectStream );return _facab ,_gafa ;};

// EncodeBytes encodes slice of bytes into JBIG2 encoding format.
// The input 'data' must be an image. In order to Decode it a user is responsible to
// load the codec ('png', 'jpg').
// Returns jbig2 single page encoded document byte slice. The encoder uses DefaultPageSettings
// to encode given image.
func (_cfge *JBIG2Encoder )EncodeBytes (data []byte )([]byte ,error ){const _bff ="\u004aB\u0049\u0047\u0032\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002eE\u006e\u0063\u006f\u0064\u0065\u0042\u0079\u0074\u0065\u0073";if _cfge .ColorComponents !=1||_cfge .BitsPerComponent !=1{return nil ,_bee .Errorf (_bff ,"\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0070\u0075\u0074\u0020\u0069\u006d\u0061\u0067\u0065\u002e\u0020\u004a\u0042\u0049G\u0032\u0020E\u006e\u0063o\u0064\u0065\u0072\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020bi\u006e\u0061\u0072\u0079\u0020\u0069\u006d\u0061\u0067e\u0073\u0020\u0064\u0061\u0074\u0061");};var (_effb *_ed .Bitmap ;_fef error ;);_cbaff :=(_cfge .Width *_cfge .Height )==len (data );if _cbaff {_effb ,_fef =_ed .NewWithUnpaddedData (_cfge .Width ,_cfge .Height ,data );}else {_effb ,_fef =_ed .NewWithData (_cfge .Width ,_cfge .Height ,data );};if _fef !=nil {return nil ,_fef ;};_eegfc :=_cfge .DefaultPageSettings ;if _fef =_eegfc .Validate ();_fef !=nil {return nil ,_bee .Wrap (_fef ,_bff ,"");};switch _eegfc .Compression {case JB2Generic :if _fef =_cfge ._dagf .AddGenericPage (_effb ,_eegfc .DuplicatedLinesRemoval );_fef !=nil {return nil ,_bee .Wrap (_fef ,_bff ,"");};case JB2SymbolCorrelation :return nil ,_bee .Error (_bff ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");case JB2SymbolRankHaus :return nil ,_bee .Error (_bff ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");default:return nil ,_bee .Error (_bff ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return _cfge .Encode ();};

// AddPageImage adds the page with the image 'img' to the encoder context in order to encode it jbig2 document.
// The 'settings' defines what encoding type should be used by the encoder.
func (_fgdb *JBIG2Encoder )AddPageImage (img *JBIG2Image ,settings *JBIG2EncoderSettings )(_badb error ){const _ecba ="\u004a\u0042\u0049\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u002e\u0041\u0064\u0064\u0050\u0061\u0067\u0065\u0049m\u0061\u0067\u0065";if _fgdb ==nil {return _bee .Error (_ecba ,"J\u0042I\u0047\u0032\u0044\u006f\u0063\u0075\u006d\u0065n\u0074\u0020\u0069\u0073 n\u0069\u006c");};if settings ==nil {settings =&_fgdb .DefaultPageSettings ;};if _fgdb ._dagf ==nil {_fgdb ._dagf =_bg .InitEncodeDocument (settings .FileMode );};if _badb =settings .Validate ();_badb !=nil {return _bee .Wrap (_badb ,_ecba ,"");};_adbc ,_badb :=img .toBitmap ();if _badb !=nil {return _bee .Wrap (_badb ,_ecba ,"");};switch settings .Compression {case JB2Generic :if _badb =_fgdb ._dagf .AddGenericPage (_adbc ,settings .DuplicatedLinesRemoval );_badb !=nil {return _bee .Wrap (_badb ,_ecba ,"");};case JB2SymbolCorrelation :return _bee .Error (_ecba ,"s\u0079\u006d\u0062\u006f\u006c\u0020\u0063\u006f\u0072r\u0065\u006c\u0061\u0074\u0069\u006f\u006e e\u006e\u0063\u006f\u0064i\u006e\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006dpl\u0065\u006de\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");case JB2SymbolRankHaus :return _bee .Error (_ecba ,"\u0073y\u006d\u0062o\u006c\u0020\u0072a\u006e\u006b\u0020\u0068\u0061\u0075\u0073 \u0065\u006e\u0063\u006f\u0064\u0069n\u0067\u0020\u006e\u006f\u0074\u0020\u0069\u006d\u0070\u006c\u0065m\u0065\u006e\u0074\u0065\u0064\u0020\u0079\u0065\u0074");default:return _bee .Error (_ecba ,"\u0070\u0072\u006f\u0076i\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069d\u0020c\u006f\u006d\u0070\u0072\u0065\u0073\u0073i\u006f\u006e");};return nil ;};

// DecodeStream decodes a DCT encoded stream and returns the result as a
// slice of bytes.
func (_ggag *DCTEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){return _ggag .DecodeBytes (streamObj .Stream );};

// ToIntegerArray returns a slice of all array elements as an int slice. An error is returned if the
// array non-integer objects. Each element can only be PdfObjectInteger.
func (_bgfcd *PdfObjectArray )ToIntegerArray ()([]int ,error ){var _fceg []int ;for _ ,_ggcc :=range _bgfcd .Elements (){if _faggca ,_bfgf :=_ggcc .(*PdfObjectInteger );_bfgf {_fceg =append (_fceg ,int (*_faggca ));}else {return nil ,ErrTypeError ;};};return _fceg ,nil ;};

// ReadBytesAt reads byte content at specific offset and length within the PDF.
func (_eaaa *PdfParser )ReadBytesAt (offset ,len int64 )([]byte ,error ){_gfea :=_eaaa .GetFileOffset ();_ ,_geab :=_eaaa ._aedcf .Seek (offset ,_f .SeekStart );if _geab !=nil {return nil ,_geab ;};_ggcf :=make ([]byte ,len );_ ,_geab =_f .ReadAtLeast (_eaaa ._aedcf ,_ggcf ,int (len ));if _geab !=nil {return nil ,_geab ;};_eaaa .SetFileOffset (_gfea );return _ggcf ,nil ;};

// EncodeBytes ASCII encodes the passed in slice of bytes.
func (_dbbb *ASCIIHexEncoder )EncodeBytes (data []byte )([]byte ,error ){var _gda _gd .Buffer ;for _ ,_abce :=range data {_gda .WriteString (_bec .Sprintf ("\u0025\u002e\u0032X\u0020",_abce ));};_gda .WriteByte ('>');return _gda .Bytes (),nil ;};

// ASCII85Encoder implements ASCII85 encoder/decoder.
type ASCII85Encoder struct{};

// MakeString creates an PdfObjectString from a string.
// NOTE: PDF does not use utf-8 string encoding like Go so `s` will often not be a utf-8 encoded
// string.
func MakeString (s string )*PdfObjectString {_caec :=PdfObjectString {_fbedf :s };return &_caec };func _cfee (_dfg _f .ReadSeeker ,_dfaeb int64 )(*offsetReader ,error ){_fcdb :=&offsetReader {_fdab :_dfg ,_acbaf :_dfaeb };_ ,_aacb :=_fcdb .Seek (0,_f .SeekStart );return _fcdb ,_aacb ;};type objectStream struct{N int ;_acb []byte ;_ef map[int ]int64 ;};

// WriteString outputs the object as it is to be written to file.
func (_fgae *PdfObjectArray )WriteString ()string {var _efgd _gg .Builder ;_efgd .WriteString ("\u005b");for _ecdgf ,_aca :=range _fgae .Elements (){_efgd .WriteString (_aca .WriteString ());if _ecdgf < (_fgae .Len ()-1){_efgd .WriteString ("\u0020");};};_efgd .WriteString ("\u005d");return _efgd .String ();};

// EncodeJBIG2Image encodes 'img' into jbig2 encoded bytes stream, using default encoder settings.
func (_fgagc *JBIG2Encoder )EncodeJBIG2Image (img *JBIG2Image )([]byte ,error ){const _abag ="c\u006f\u0072\u0065\u002eEn\u0063o\u0064\u0065\u004a\u0042\u0049G\u0032\u0049\u006d\u0061\u0067\u0065";if _bfeg :=_fgagc .AddPageImage (img ,&_fgagc .DefaultPageSettings );_bfeg !=nil {return nil ,_bee .Wrap (_bfeg ,_abag ,"");};return _fgagc .Encode ();};

// ParseDict reads and parses a PDF dictionary object enclosed with '<<' and '>>'
func (_gdagc *PdfParser )ParseDict ()(*PdfObjectDictionary ,error ){_fg .Log .Trace ("\u0052\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020D\u0069\u0063\u0074\u0021");_aafa :=MakeDict ();_aafa ._ebfe =_gdagc ;_deee ,_ :=_gdagc ._fdfg .ReadByte ();if _deee !='<'{return nil ,_d .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");};_deee ,_ =_gdagc ._fdfg .ReadByte ();if _deee !='<'{return nil ,_d .New ("\u0069\u006e\u0076a\u006c\u0069\u0064\u0020\u0064\u0069\u0063\u0074");};for {_gdagc .skipSpaces ();_gdagc .skipComments ();_bbbcb ,_dbdb :=_gdagc ._fdfg .Peek (2);if _dbdb !=nil {return nil ,_dbdb ;};_fg .Log .Trace ("D\u0069c\u0074\u0020\u0070\u0065\u0065\u006b\u003a\u0020%\u0073\u0020\u0028\u0025 x\u0029\u0021",string (_bbbcb ),string (_bbbcb ));if (_bbbcb [0]=='>')&&(_bbbcb [1]=='>'){_fg .Log .Trace ("\u0045\u004f\u0046\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");_gdagc ._fdfg .ReadByte ();_gdagc ._fdfg .ReadByte ();break ;};_fg .Log .Trace ("\u0050a\u0072s\u0065\u0020\u0074\u0068\u0065\u0020\u006e\u0061\u006d\u0065\u0021");_fbef ,_dbdb :=_gdagc .parseName ();_fg .Log .Trace ("\u004be\u0079\u003a\u0020\u0025\u0073",_fbef );if _dbdb !=nil {_fg .Log .Debug ("E\u0052\u0052\u004f\u0052\u0020\u0052e\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u006ea\u006d\u0065\u0020e\u0072r\u0020\u0025\u0073",_dbdb );return nil ,_dbdb ;};if len (_fbef )> 4&&_fbef [len (_fbef )-4:]=="\u006e\u0075\u006c\u006c"{_fgafg :=_fbef [0:len (_fbef )-4];_fg .Log .Debug ("\u0054\u0061\u006b\u0069n\u0067\u0020\u0063\u0061\u0072\u0065\u0020\u006f\u0066\u0020n\u0075l\u006c\u0020\u0062\u0075\u0067\u0020\u0028%\u0073\u0029",_fbef );_fg .Log .Debug ("\u004e\u0065\u0077\u0020ke\u0079\u0020\u0022\u0025\u0073\u0022\u0020\u003d\u0020\u006e\u0075\u006c\u006c",_fgafg );_gdagc .skipSpaces ();_beac ,_ :=_gdagc ._fdfg .Peek (1);if _beac [0]=='/'{_aafa .Set (_fgafg ,MakeNull ());continue ;};};_gdagc .skipSpaces ();_afbc ,_dbdb :=_gdagc .parseObject ();if _dbdb !=nil {return nil ,_dbdb ;};_aafa .Set (_fbef ,_afbc );if _fg .Log .IsLogLevel (_fg .LogLevelTrace ){_fg .Log .Trace ("\u0064\u0069\u0063\u0074\u005b\u0025\u0073\u005d\u0020\u003d\u0020\u0025\u0073",_fbef ,_afbc .String ());};};_fg .Log .Trace ("\u0072\u0065\u0074\u0075rn\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020\u0044\u0069\u0063\u0074\u0021");return _aafa ,nil ;};

// WriteString outputs the object as it is to be written to file.
func (_gccca *PdfObjectStream )WriteString ()string {var _fcea _gg .Builder ;_fcea .WriteString (_g .FormatInt (_gccca .ObjectNumber ,10));_fcea .WriteString ("\u0020\u0030\u0020\u0052");return _fcea .String ();};func _efgac (_cacf PdfObject ,_gefe int )PdfObject {if _gefe > _cfaag {_fg .Log .Error ("\u0054\u0072ac\u0065\u0020\u0064e\u0070\u0074\u0068\u0020lev\u0065l \u0062\u0065\u0079\u006f\u006e\u0064\u0020%d\u0020\u002d\u0020\u0065\u0072\u0072\u006fr\u0021",_cfaag );return MakeNull ();};switch _dfgd :=_cacf .(type ){case *PdfIndirectObject :_cacf =_efgac ((*_dfgd ).PdfObject ,_gefe +1);case *PdfObjectArray :for _eceae ,_bbced :=range (*_dfgd )._bcgc {(*_dfgd )._bcgc [_eceae ]=_efgac (_bbced ,_gefe +1);};case *PdfObjectDictionary :for _cdbe ,_beca :=range (*_dfgd )._addf {(*_dfgd )._addf [_cdbe ]=_efgac (_beca ,_gefe +1);};_a .Slice ((*_dfgd )._ccc ,func (_feafa ,_defd int )bool {return (*_dfgd )._ccc [_feafa ]< (*_dfgd )._ccc [_defd ]});};return _cacf ;};

// Clear resets the dictionary to an empty state.
func (_cafc *PdfObjectDictionary )Clear (){_cafc ._ccc =[]PdfObjectName {};_cafc ._addf =map[PdfObjectName ]PdfObject {};};func (_bcfg *PdfParser )parseNull ()(PdfObjectNull ,error ){_ ,_cgfa :=_bcfg ._fdfg .Discard (4);return PdfObjectNull {},_cgfa ;};

// MakeName creates a PdfObjectName from a string.
func MakeName (s string )*PdfObjectName {_ggabd :=PdfObjectName (s );return &_ggabd };

// NewEncoderFromStream creates a StreamEncoder based on the stream's dictionary.
func NewEncoderFromStream (streamObj *PdfObjectStream )(StreamEncoder ,error ){_gdef :=TraceToDirectObject (streamObj .PdfObjectDictionary .Get ("\u0046\u0069\u006c\u0074\u0065\u0072"));if _gdef ==nil {return NewRawEncoder (),nil ;};if _ ,_dccegf :=_gdef .(*PdfObjectNull );_dccegf {return NewRawEncoder (),nil ;};_caaf ,_fgbdc :=_gdef .(*PdfObjectName );if !_fgbdc {_egda ,_cfcc :=_gdef .(*PdfObjectArray );if !_cfcc {return nil ,_bec .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006f\u0072 \u0041\u0072\u0072\u0061\u0079\u0020\u006fb\u006a\u0065\u0063\u0074");};if _egda .Len ()==0{return NewRawEncoder (),nil ;};if _egda .Len ()!=1{_ggef ,_cdcb :=_ddb (streamObj );if _cdcb !=nil {_fg .Log .Error ("\u0046\u0061\u0069\u006c\u0065\u0064 \u0063\u0072\u0065\u0061\u0074\u0069\u006e\u0067\u0020\u006d\u0075\u006c\u0074i\u0020\u0065\u006e\u0063\u006f\u0064\u0065r\u003a\u0020\u0025\u0076",_cdcb );return nil ,_cdcb ;};_fg .Log .Trace ("\u004d\u0075\u006c\u0074\u0069\u0020\u0065\u006e\u0063:\u0020\u0025\u0073\u000a",_ggef );return _ggef ,nil ;};_gdef =_egda .Get (0);_caaf ,_cfcc =_gdef .(*PdfObjectName );if !_cfcc {return nil ,_bec .Errorf ("\u0066\u0069l\u0074\u0065\u0072\u0020a\u0072\u0072a\u0079\u0020\u006d\u0065\u006d\u0062\u0065\u0072 \u006e\u006f\u0074\u0020\u0061\u0020\u004e\u0061\u006d\u0065\u0020\u006fb\u006a\u0065\u0063\u0074");};};switch *_caaf {case StreamEncodingFilterNameFlate :return _ccbd (streamObj ,nil );case StreamEncodingFilterNameLZW :return _dde (streamObj ,nil );case StreamEncodingFilterNameDCT :return _dbbf (streamObj ,nil );case StreamEncodingFilterNameRunLength :return _cae (streamObj ,nil );case StreamEncodingFilterNameASCIIHex :return NewASCIIHexEncoder (),nil ;case StreamEncodingFilterNameASCII85 ,"\u0041\u0038\u0035":return NewASCII85Encoder (),nil ;case StreamEncodingFilterNameCCITTFax :return _fcge (streamObj ,nil );case StreamEncodingFilterNameJBIG2 :return _ceaa (streamObj ,nil );case StreamEncodingFilterNameJPX :return NewJPXEncoder (),nil ;};_fg .Log .Debug ("E\u0052\u0052\u004f\u0052\u003a\u0020U\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064\u0069\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006fd\u0021");return nil ,_bec .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065\u006e\u0063o\u0064i\u006e\u0067\u0020\u006d\u0065\u0074\u0068\u006f\u0064\u0020\u0028\u0025\u0073\u0029",*_caaf );};

// PdfObjectName represents the primitive PDF name object.
type PdfObjectName string ;func (_gded *PdfCrypt )generateParams (_gcge ,_gabc []byte )error {_gac :=_gded .securityHandler ();_feb ,_acfa :=_gac .GenerateParams (&_gded ._fgag ,_gabc ,_gcge );if _acfa !=nil {return _acfa ;};_gded ._cge =_feb ;return nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
// Has the Filter set and the DecodeParms.
func (_dbe *FlateEncoder )MakeStreamDict ()*PdfObjectDictionary {_bgc :=MakeDict ();_bgc .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_dbe .GetFilterName ()));_ced :=_dbe .MakeDecodeParams ();if _ced !=nil {_bgc .Set ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073",_ced );};return _bgc ;};

// DecodeBytes decodes the CCITTFax encoded image data.
func (_gcgc *CCITTFaxEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_ebbfc :=&_gfg .Encoder {K :_gcgc .K ,Columns :_gcgc .Columns ,EndOfLine :_gcgc .EndOfLine ,EndOfBlock :_gcgc .EndOfBlock ,BlackIs1 :_gcgc .BlackIs1 ,DamagedRowsBeforeError :_gcgc .DamagedRowsBeforeError ,Rows :_gcgc .Rows ,EncodedByteAlign :_gcgc .EncodedByteAlign };_cegaf ,_bcf :=_ebbfc .Decode (encoded );if _bcf !=nil {return nil ,_bcf ;};var _geded []byte ;_fdde :=0;var _gdac byte ;var _bdcg byte ;for _ggee :=range _cegaf {if _gdac !=0{_geded =append (_geded ,_bdcg );_bdcg =0;_fdde ++;_gdac =0;};for _ddee :=range _cegaf [_ggee ]{_bdcg |=_cegaf [_ggee ][_ddee ]<<(7-_gdac );_gdac ++;if _gdac ==8{_geded =append (_geded ,_bdcg );_bdcg =0;_fdde ++;_gdac =0;};};};if _gdac > 0{_geded =append (_geded ,_bdcg );};return _geded ,nil ;};

// IsEncrypted checks if the document is encrypted. A bool flag is returned indicating the result.
// First time when called, will check if the Encrypt dictionary is accessible through the trailer dictionary.
// If encrypted, prepares a crypt datastructure which can be used to authenticate and decrypt the document.
// On failure, an error is returned.
func (_daaba *PdfParser )IsEncrypted ()(bool ,error ){if _daaba ._dgfca !=nil {return true ,nil ;}else if _daaba ._ddcb ==nil {return false ,nil ;};_fg .Log .Trace ("\u0043\u0068\u0065c\u006b\u0069\u006e\u0067 \u0065\u006e\u0063\u0072\u0079\u0070\u0074i\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069\u006f\u006e\u0061\u0072\u0079\u0021");_abab :=_daaba ._ddcb .Get ("\u0045n\u0063\u0072\u0079\u0070\u0074");if _abab ==nil {return false ,nil ;};_fg .Log .Trace ("\u0049\u0073\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u0021");var (_efga *PdfObjectDictionary ;);switch _aefa :=_abab .(type ){case *PdfObjectDictionary :_efga =_aefa ;case *PdfObjectReference :_fg .Log .Trace ("\u0030\u003a\u0020\u004c\u006f\u006f\u006b\u0020\u0075\u0070\u0020\u0072e\u0066\u0020\u0025\u0071",_aefa );_dfee ,_cgcg :=_daaba .LookupByReference (*_aefa );_fg .Log .Trace ("\u0031\u003a\u0020%\u0071",_dfee );if _cgcg !=nil {return false ,_cgcg ;};_cegba ,_abbce :=_dfee .(*PdfIndirectObject );if !_abbce {_fg .Log .Debug ("E\u006e\u0063\u0072\u0079\u0070\u0074\u0069\u006f\u006e\u0020\u006f\u0062\u006a\u0065\u0063\u0074\u0020\u006eo\u0074\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072ec\u0074\u0020\u006fb\u006ae\u0063\u0074");return false ,_d .New ("\u0074\u0079p\u0065\u0020\u0063h\u0065\u0063\u006b\u0020\u0065\u0072\u0072\u006f\u0072");};_aaaf ,_abbce :=_cegba .PdfObject .(*PdfObjectDictionary );_fg .Log .Trace ("\u0032\u003a\u0020%\u0071",_aaaf );if !_abbce {return false ,_d .New ("\u0074\u0072a\u0069\u006c\u0065\u0072 \u0045\u006ec\u0072\u0079\u0070\u0074\u0020\u006f\u0062\u006ae\u0063\u0074\u0020\u006e\u006f\u006e\u0020\u0064\u0069\u0063\u0074\u0069o\u006e\u0061\u0072\u0079");};_efga =_aaaf ;case *PdfObjectNull :_fg .Log .Debug ("\u0045\u006e\u0063\u0072\u0079\u0070\u0074 \u0069\u0073\u0020a\u0020\u006e\u0075l\u006c\u0020o\u0062\u006a\u0065\u0063\u0074\u002e \u0046il\u0065\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u0065\u006e\u0063\u0072\u0079\u0070\u0074\u0065\u0064\u002e");return false ,nil ;default:return false ,_bec .Errorf ("u\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0079\u0070\u0065: \u0025\u0054",_aefa );};_bbad ,_eabeg :=PdfCryptNewDecrypt (_daaba ,_efga ,_daaba ._ddcb );if _eabeg !=nil {return false ,_eabeg ;};for _ ,_cbcb :=range []string {"\u0049\u006e\u0066\u006f","\u0045n\u0063\u0072\u0079\u0070\u0074"}{_bgbg :=_daaba ._ddcb .Get (PdfObjectName (_cbcb ));if _bgbg ==nil {continue ;};switch _cedga :=_bgbg .(type ){case *PdfObjectReference :_bbad ._cfbg [int (_cedga .ObjectNumber )]=struct{}{};case *PdfIndirectObject :_bbad ._fgc [_cedga ]=true ;_bbad ._cfbg [int (_cedga .ObjectNumber )]=struct{}{};};};_daaba ._dgfca =_bbad ;_fg .Log .Trace ("\u0043\u0072\u0079\u0070\u0074\u0065\u0072\u0020\u006f\u0062\u006a\u0065c\u0074\u0020\u0025\u0062",_bbad );return true ,nil ;};

// SetFileOffset sets the file to an offset position and resets buffer.
func (_cgdb *PdfParser )SetFileOffset (offset int64 ){if offset < 0{offset =0;};_cgdb ._aedcf .Seek (offset ,_f .SeekStart );_cgdb ._fdfg =_af .NewReader (_cgdb ._aedcf );};

// NewDCTEncoder makes a new DCT encoder with default parameters.
func NewDCTEncoder ()*DCTEncoder {_aggb :=&DCTEncoder {};_aggb .ColorComponents =3;_aggb .BitsPerComponent =8;_aggb .Quality =DefaultJPEGQuality ;return _aggb ;};

// IsPrintable checks if a character is printable.
// Regular characters that are outside the range EXCLAMATION MARK(21h)
// (!) to TILDE (7Eh) (~) should be written using the hexadecimal notation.
func IsPrintable (c byte )bool {return 0x21<=c &&c <=0x7E};var _geda =_ga .MustCompile ("\u005e\u005b\\\u002b\u002d\u002e\u005d*\u0028\u005b0\u002d\u0039\u002e\u005d\u002b\u0029\u005b\u0065E\u005d\u005b\u005c\u002b\u002d\u002e\u005d\u002a\u0028\u005b\u0030\u002d9\u002e\u005d\u002b\u0029");

// DecodeStream decodes a FlateEncoded stream object and give back decoded bytes.
func (_ccbb *FlateEncoder )DecodeStream (streamObj *PdfObjectStream )([]byte ,error ){_fg .Log .Trace ("\u0046l\u0061t\u0065\u0044\u0065\u0063\u006fd\u0065\u0020s\u0074\u0072\u0065\u0061\u006d");_fg .Log .Trace ("\u0050\u0072\u0065\u0064\u0069\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_ccbb .Predictor );if _ccbb .BitsPerComponent !=8{return nil ,_bec .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003d\u0025\u0064\u0020\u0028\u006f\u006e\u006c\u0079\u0020\u0038\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0029",_ccbb .BitsPerComponent );};_bea ,_afdd :=_ccbb .DecodeBytes (streamObj .Stream );if _afdd !=nil {return nil ,_afdd ;};_bea ,_afdd =_ccbb .postDecodePredict (_bea );if _afdd !=nil {return nil ,_afdd ;};return _ccbb .cleanImageData (_bea );};func _ae (_fc PdfObject )(int64 ,int64 ,error ){if _efab ,_bggb :=_fc .(*PdfIndirectObject );_bggb {return _efab .ObjectNumber ,_efab .GenerationNumber ,nil ;};if _gff ,_edc :=_fc .(*PdfObjectStream );_edc {return _gff .ObjectNumber ,_gff .GenerationNumber ,nil ;};return 0,0,_d .New ("\u006e\u006ft\u0020\u0061\u006e\u0020\u0069\u006e\u0064\u0069\u0072\u0065\u0063\u0074\u002f\u0073\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0062je\u0063\u0074");};func (_feda *offsetReader )Seek (offset int64 ,whence int )(int64 ,error ){if whence ==_f .SeekStart {offset +=_feda ._acbaf ;};_fcb ,_efcgbe :=_feda ._fdab .Seek (offset ,whence );if _efcgbe !=nil {return _fcb ,_efcgbe ;};if whence ==_f .SeekCurrent {_fcb -=_feda ._acbaf ;};if _fcb < 0{return 0,_d .New ("\u0063\u006f\u0072\u0065\u002eo\u0066\u0066\u0073\u0065\u0074\u0052\u0065\u0061\u0064\u0065\u0072\u002e\u0053e\u0065\u006b\u003a\u0020\u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e");};return _fcb ,nil ;};

// UpdateParams updates the parameter values of the encoder.
func (_aeae *CCITTFaxEncoder )UpdateParams (params *PdfObjectDictionary ){if _beag ,_efcgb :=GetNumberAsInt64 (params .Get ("\u004b"));_efcgb ==nil {_aeae .K =int (_beag );};if _ege ,_beaf :=GetNumberAsInt64 (params .Get ("\u0043o\u006c\u0075\u006d\u006e\u0073"));_beaf ==nil {_aeae .Columns =int (_ege );}else if _ege ,_beaf =GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));_beaf ==nil {_aeae .Columns =int (_ege );};if _egeg ,_bbdd :=GetNumberAsInt64 (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_bbdd ==nil {_aeae .BlackIs1 =_egeg > 0;}else {if _dabe ,_fdgc :=GetBoolVal (params .Get ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031"));_fdgc {_aeae .BlackIs1 =_dabe ;}else {if _abbc ,_agdd :=GetArray (params .Get ("\u0044\u0065\u0063\u006f\u0064\u0065"));_agdd {_gfgg ,_affe :=_abbc .ToIntegerArray ();if _affe ==nil {_aeae .BlackIs1 =_gfgg [0]==1&&_gfgg [1]==0;};};};};if _adce ,_cffgg :=GetNumberAsInt64 (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_cffgg ==nil {_aeae .EncodedByteAlign =_adce > 0;}else {if _gfe ,_cade :=GetBoolVal (params .Get ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e"));_cade {_aeae .EncodedByteAlign =_gfe ;};};if _cdgge ,_gffe :=GetNumberAsInt64 (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_gffe ==nil {_aeae .EndOfLine =_cdgge > 0;}else {if _gddb ,_ccg :=GetBoolVal (params .Get ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee"));_ccg {_aeae .EndOfLine =_gddb ;};};if _gdgfb ,_cdaf :=GetNumberAsInt64 (params .Get ("\u0052\u006f\u0077\u0073"));_cdaf ==nil {_aeae .Rows =int (_gdgfb );}else if _gdgfb ,_cdaf =GetNumberAsInt64 (params .Get ("\u0048\u0065\u0069\u0067\u0068\u0074"));_cdaf ==nil {_aeae .Rows =int (_gdgfb );};if _ecbg ,_aaf :=GetNumberAsInt64 (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_aaf ==nil {_aeae .EndOfBlock =_ecbg > 0;}else {if _dbdc ,_faf :=GetBoolVal (params .Get ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b"));_faf {_aeae .EndOfBlock =_dbdc ;};};if _bcbg ,_aeb :=GetNumberAsInt64 (params .Get ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072"));_aeb !=nil {_aeae .DamagedRowsBeforeError =int (_bcbg );};};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_addc *DCTEncoder )MakeDecodeParams ()PdfObject {return nil };

// String returns a string describing `array`.
func (_fdfb *PdfObjectArray )String ()string {_ddbac :="\u005b";for _abga ,_fafb :=range _fdfb .Elements (){_ddbac +=_fafb .String ();if _abga < (_fdfb .Len ()-1){_ddbac +="\u002c\u0020";};};_ddbac +="\u005d";return _ddbac ;};func (_eegce *PdfParser )inspect ()(map[string ]int ,error ){_fg .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0049\u004e\u0053P\u0045\u0043\u0054\u0020\u002d\u002d\u002d\u002d\u002d\u002d-\u002d\u002d\u002d");_fg .Log .Trace ("X\u0072\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u003a");_cadg :=map[string ]int {};_gebe :=0;_fceaf :=0;var _agebe []int ;for _bfbd :=range _eegce ._dfcg .ObjectMap {_agebe =append (_agebe ,_bfbd );};_a .Ints (_agebe );_febcc :=0;for _ ,_fbgdd :=range _agebe {_caafa :=_eegce ._dfcg .ObjectMap [_fbgdd ];if _caafa .ObjectNumber ==0{continue ;};_gebe ++;_fg .Log .Trace ("\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d");_fg .Log .Trace ("\u004c\u006f\u006f\u006bi\u006e\u0067\u0020\u0075\u0070\u0020\u006f\u0062\u006a\u0065c\u0074 \u006e\u0075\u006d\u0062\u0065\u0072\u003a \u0025\u0064",_caafa .ObjectNumber );_fegb ,_bgbe :=_eegce .LookupByNumber (_caafa .ObjectNumber );if _bgbe !=nil {_fg .Log .Trace ("\u0045\u0052\u0052\u004f\u0052\u003a \u0046\u0061\u0069\u006c\u0020\u0074\u006f\u0020\u006c\u006f\u006f\u006b\u0075p\u0020\u006f\u0062\u006a\u0020\u0025\u0064 \u0028\u0025\u0073\u0029",_caafa .ObjectNumber ,_bgbe );_fceaf ++;continue ;};_fg .Log .Trace ("\u006fb\u006a\u003a\u0020\u0025\u0073",_fegb );_cccf ,_gcbd :=_fegb .(*PdfIndirectObject );if _gcbd {_fg .Log .Trace ("\u0049N\u0044 \u004f\u004f\u0042\u004a\u0020\u0025\u0064\u003a\u0020\u0025\u0073",_caafa .ObjectNumber ,_cccf );_becbe ,_ffed :=_cccf .PdfObject .(*PdfObjectDictionary );if _ffed {if _ccbdg ,_ebafdb :=_becbe .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_ebafdb {_dfbga :=string (*_ccbdg );_fg .Log .Trace ("\u002d\u002d\u002d\u003e\u0020\u004f\u0062\u006a\u0020\u0074\u0079\u0070e\u003a\u0020\u0025\u0073",_dfbga );_ ,_gdce :=_cadg [_dfbga ];if _gdce {_cadg [_dfbga ]++;}else {_cadg [_dfbga ]=1;};}else if _cdafb ,_gfad :=_becbe .Get ("\u0053u\u0062\u0074\u0079\u0070\u0065").(*PdfObjectName );_gfad {_efgg :=string (*_cdafb );_fg .Log .Trace ("-\u002d-\u003e\u0020\u004f\u0062\u006a\u0020\u0073\u0075b\u0074\u0079\u0070\u0065: \u0025\u0073",_efgg );_ ,_adcg :=_cadg [_efgg ];if _adcg {_cadg [_efgg ]++;}else {_cadg [_efgg ]=1;};};if _ddea ,_cdfb :=_becbe .Get ("\u0053").(*PdfObjectName );_cdfb &&*_ddea =="\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"{_ ,_fgfb :=_cadg ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"];if _fgfb {_cadg ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]++;}else {_cadg ["\u004a\u0061\u0076\u0061\u0053\u0063\u0072\u0069\u0070\u0074"]=1;};};};}else if _cfea ,_dbgd :=_fegb .(*PdfObjectStream );_dbgd {if _bddd ,_bdga :=_cfea .PdfObjectDictionary .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );_bdga {_fg .Log .Trace ("\u002d\u002d\u003e\u0020\u0053\u0074\u0072\u0065\u0061\u006d\u0020o\u0062\u006a\u0065\u0063\u0074\u0020\u0074\u0079\u0070\u0065:\u0020\u0025\u0073",*_bddd );_cgeg :=string (*_bddd );if _ ,_cdgfa :=_cadg [_cgeg ];_cdgfa {_cadg [_cgeg ]++;}else {_cadg [_cgeg ]=1;};};}else {_dddaf ,_ccca :=_fegb .(*PdfObjectDictionary );if _ccca {_gegd ,_bgcf :=_dddaf .Get ("\u0054\u0079\u0070\u0065").(*PdfObjectName );if _bgcf {_cfbca :=string (*_gegd );_fg .Log .Trace ("\u002d-\u002d \u006f\u0062\u006a\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073",_cfbca );_cadg [_cfbca ]++;};};_fg .Log .Trace ("\u0044\u0049\u0052\u0045\u0043\u0054\u0020\u004f\u0042\u004a\u0020\u0025d\u003a\u0020\u0025\u0073",_caafa .ObjectNumber ,_fegb );};_febcc ++;};_fg .Log .Trace ("\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u0045\u004fF\u0020\u0049\u004e\u0053\u0050\u0045\u0043T\u0020\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d\u002d");_fg .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");_fg .Log .Trace ("\u004f\u0062j\u0065\u0063\u0074 \u0063\u006f\u0075\u006e\u0074\u003a\u0020\u0025\u0064",_gebe );_fg .Log .Trace ("\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u006c\u006f\u006f\u006b\u0075p\u003a\u0020\u0025\u0064",_fceaf );for _fcff ,_gfcb :=range _cadg {_fg .Log .Trace ("\u0025\u0073\u003a\u0020\u0025\u0064",_fcff ,_gfcb );};_fg .Log .Trace ("\u003d=\u003d\u003d\u003d\u003d\u003d");if len (_eegce ._dfcg .ObjectMap )< 1{_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0054\u0068\u0069\u0073 \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074 \u0069s\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0028\u0078\u0072\u0065\u0066\u0020\u0074\u0061\u0062l\u0065\u0020\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0021\u0029");return nil ,_bec .Errorf ("\u0069\u006ev\u0061\u006c\u0069\u0064 \u0064\u006fc\u0075\u006d\u0065\u006e\u0074\u0020\u0028\u0078r\u0065\u0066\u0020\u0074\u0061\u0062\u006c\u0065\u0020\u006d\u0069\u0073s\u0069\u006e\u0067\u0029");};_egfa ,_ccdgfa :=_cadg ["\u0046\u006f\u006e\u0074"];if !_ccdgfa ||_egfa < 2{_fg .Log .Trace ("\u0054\u0068\u0069s \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020i\u0073 \u0070r\u006fb\u0061\u0062\u006c\u0079\u0020\u0073\u0063\u0061\u006e\u006e\u0065\u0064\u0021");}else {_fg .Log .Trace ("\u0054\u0068\u0069\u0073\u0020\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u0020\u0069\u0073\u0020\u0076\u0061\u006c\u0069\u0064\u0020\u0066o\u0072\u0020\u0065\u0078\u0074r\u0061\u0063t\u0069\u006f\u006e\u0021");};return _cadg ,nil ;};

// PdfParser parses a PDF file and provides access to the object structure of the PDF.
type PdfParser struct{_ceage Version ;_aedcf _f .ReadSeeker ;_fdfg *_af .Reader ;_egbf int64 ;_dfcg XrefTable ;_egff int64 ;_bbgc *xrefType ;_bfcea objectStreams ;_ddcb *PdfObjectDictionary ;_dgfca *PdfCrypt ;_adgbc bool ;ObjCache objectCache ;_fafe map[int64 ]bool ;};

// DecodeBytes decodes a slice of Flate encoded bytes and returns the result.
func (_ccbe *FlateEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_fg .Log .Trace ("\u0046\u006c\u0061\u0074\u0065\u0044\u0065\u0063\u006f\u0064\u0065\u0020b\u0079\u0074\u0065\u0073");if len (encoded )==0{_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0046\u006c\u0061\u0074\u0065 e\u006ec\u006f\u0064\u0065\u0064\u0020\u0062\u0075\u0066\u0066\u0065\u0072\u002e \u0052\u0065\u0074\u0075\u0072\u006e\u0069\u006e\u0067\u0020\u0065\u006d\u0070\u0074\u0079\u0020\u0062y\u0074\u0065\u0020\u0073\u006c\u0069\u0063\u0065\u002e");return []byte {},nil ;};_cgf :=_gd .NewReader (encoded );_dbcb ,_gecb :=_e .NewReader (_cgf );if _gecb !=nil {_fg .Log .Debug ("\u0044e\u0063o\u0064\u0069\u006e\u0067\u0020e\u0072\u0072o\u0072\u0020\u0025\u0076\u000a",_gecb );_fg .Log .Debug ("\u0053t\u0072e\u0061\u006d\u0020\u0028\u0025\u0064\u0029\u0020\u0025\u0020\u0078",len (encoded ),encoded );return nil ,_gecb ;};defer _dbcb .Close ();var _cde _gd .Buffer ;_cde .ReadFrom (_dbcb );return _cde .Bytes (),nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_fdgf *RunLengthEncoder )MakeStreamDict ()*PdfObjectDictionary {_ggdde :=MakeDict ();_ggdde .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_fdgf .GetFilterName ()));return _ggdde ;};func (_fd *PdfParser )lookupByNumberWrapper (_bfc int ,_dae bool )(PdfObject ,bool ,error ){_gaa ,_cg ,_ce :=_fd .lookupByNumber (_bfc ,_dae );if _ce !=nil {return nil ,_cg ,_ce ;};if !_cg &&_fd ._dgfca !=nil &&!_fd ._dgfca .isDecrypted (_gaa ){_bcg :=_fd ._dgfca .Decrypt (_gaa ,0,0);if _bcg !=nil {return nil ,_cg ,_bcg ;};};return _gaa ,_cg ,nil ;};

// IsOctalDigit checks if a character can be part of an octal digit string.
func IsOctalDigit (c byte )bool {return '0'<=c &&c <='7'};

// Merge merges in key/values from another dictionary. Overwriting if has same keys.
// The mutated dictionary (d) is returned in order to allow method chaining.
func (_gcef *PdfObjectDictionary )Merge (another *PdfObjectDictionary )*PdfObjectDictionary {if another !=nil {for _ ,_ddgfg :=range another .Keys (){_gfca :=another .Get (_ddgfg );_gcef .Set (_ddgfg ,_gfca );};};return _gcef ;};

// EncodeBytes encodes the passed in slice of bytes by passing it through the
// EncodeBytes method of the underlying encoders.
func (_bfce *MultiEncoder )EncodeBytes (data []byte )([]byte ,error ){_bfea :=data ;var _daee error ;for _beef :=len (_bfce ._bbce )-1;_beef >=0;_beef --{_cecc :=_bfce ._bbce [_beef ];_bfea ,_daee =_cecc .EncodeBytes (_bfea );if _daee !=nil {return nil ,_daee ;};};return _bfea ,nil ;};

// MakeDecodeParams makes a new instance of an encoding dictionary based on
// the current encoder settings.
func (_agdc *CCITTFaxEncoder )MakeDecodeParams ()PdfObject {_fffe :=MakeDict ();_fffe .Set ("\u004b",MakeInteger (int64 (_agdc .K )));_fffe .Set ("\u0043o\u006c\u0075\u006d\u006e\u0073",MakeInteger (int64 (_agdc .Columns )));if _agdc .BlackIs1 {_fffe .Set ("\u0042\u006c\u0061\u0063\u006b\u0049\u0073\u0031",MakeBool (_agdc .BlackIs1 ));};if _agdc .EncodedByteAlign {_fffe .Set ("\u0045\u006ec\u006f\u0064\u0065d\u0042\u0079\u0074\u0065\u0041\u006c\u0069\u0067\u006e",MakeBool (_agdc .EncodedByteAlign ));};if _agdc .EndOfLine &&_agdc .K >=0{_fffe .Set ("\u0045n\u0064\u004f\u0066\u004c\u0069\u006ee",MakeBool (_agdc .EndOfLine ));};if _agdc .Rows !=0&&!_agdc .EndOfBlock {_fffe .Set ("\u0052\u006f\u0077\u0073",MakeInteger (int64 (_agdc .Rows )));};if !_agdc .EndOfBlock {_fffe .Set ("\u0045\u006e\u0064\u004f\u0066\u0042\u006c\u006f\u0063\u006b",MakeBool (_agdc .EndOfBlock ));};if _agdc .DamagedRowsBeforeError !=0{_fffe .Set ("\u0044\u0061\u006d\u0061ge\u0064\u0052\u006f\u0077\u0073\u0042\u0065\u0066\u006f\u0072\u0065\u0045\u0072\u0072o\u0072",MakeInteger (int64 (_agdc .DamagedRowsBeforeError )));};return _fffe ;};

// EncryptInfo contains an information generated by the document encrypter.
type EncryptInfo struct{Version ;

// Encrypt is an encryption dictionary that contains all necessary parameters.
// It should be stored in all copies of the document trailer.
Encrypt *PdfObjectDictionary ;

// ID0 and ID1 are IDs used in the trailer. Older algorithms such as RC4 uses them for encryption.
ID0 ,ID1 string ;};

// EncodeBytes JPX encodes the passed in slice of bytes.
func (_dfc *JPXEncoder )EncodeBytes (data []byte )([]byte ,error ){_fg .Log .Debug ("\u0045\u0072\u0072\u006f\u0072\u003a\u0020\u0041t\u0074\u0065\u006dpt\u0069\u006e\u0067\u0020\u0074\u006f \u0075\u0073\u0065\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006e\u0063\u006f\u0064\u0069\u006e\u0067 \u0025\u0073",_dfc .GetFilterName ());return data ,ErrNoJPXDecode ;};

// GetAsFloat64Slice returns the array as []float64 slice.
// Returns an error if not entirely numeric (only PdfObjectIntegers, PdfObjectFloats).
func (_dacg *PdfObjectArray )GetAsFloat64Slice ()([]float64 ,error ){var _fdabf []float64 ;for _ ,_afef :=range _dacg .Elements (){_feab ,_abeg :=GetNumberAsFloat (TraceToDirectObject (_afef ));if _abeg !=nil {return nil ,_bec .Errorf ("\u0061\u0072\u0072\u0061\u0079\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0020\u006e\u006f\u0074\u0020\u0061\u0020\u006e\u0075m\u0062\u0065\u0072");};_fdabf =append (_fdabf ,_feab );};return _fdabf ,nil ;};

// String returns the PDF version as a string. Implements interface fmt.Stringer.
func (_bbeca Version )String ()string {return _bec .Sprintf ("\u00250\u0064\u002e\u0025\u0030\u0064",_bbeca .Major ,_bbeca .Minor );};func (_bcfa *PdfParser )parseName ()(PdfObjectName ,error ){var _gbbe _gd .Buffer ;_gdge :=false ;for {_cbeb ,_fdgcff :=_bcfa ._fdfg .Peek (1);if _fdgcff ==_f .EOF {break ;};if _fdgcff !=nil {return PdfObjectName (_gbbe .String ()),_fdgcff ;};if !_gdge {if _cbeb [0]=='/'{_gdge =true ;_bcfa ._fdfg .ReadByte ();}else if _cbeb [0]=='%'{_bcfa .readComment ();_bcfa .skipSpaces ();}else {_fg .Log .Debug ("\u0045\u0052\u0052\u004f\u0052\u0020N\u0061\u006d\u0065\u0020\u0073\u0074\u0061\u0072\u0074\u0069\u006e\u0067\u0020w\u0069\u0074\u0068\u0020\u0025\u0073\u0020(\u0025\u0020\u0078\u0029",_cbeb ,_cbeb );return PdfObjectName (_gbbe .String ()),_bec .Errorf ("\u0069n\u0076a\u006c\u0069\u0064\u0020\u006ea\u006d\u0065:\u0020\u0028\u0025\u0063\u0029",_cbeb [0]);};}else {if IsWhiteSpace (_cbeb [0]){break ;}else if (_cbeb [0]=='/')||(_cbeb [0]=='[')||(_cbeb [0]=='(')||(_cbeb [0]==']')||(_cbeb [0]=='<')||(_cbeb [0]=='>'){break ;}else if _cbeb [0]=='#'{_cedd ,_afga :=_bcfa ._fdfg .Peek (3);if _afga !=nil {return PdfObjectName (_gbbe .String ()),_afga ;};_fafd ,_afga :=_gb .DecodeString (string (_cedd [1:3]));if _afga !=nil {_fg .Log .Debug ("\u0045\u0052\u0052\u004fR\u003a\u0020\u0049\u006ev\u0061\u006c\u0069d\u0020\u0068\u0065\u0078\u0020\u0066o\u006c\u006co\u0077\u0069\u006e\u0067 \u0027\u0023\u0027\u002c \u0063\u006f\u006e\u0074\u0069n\u0075\u0069\u006e\u0067\u0020\u0075\u0073i\u006e\u0067\u0020\u006c\u0069t\u0065\u0072\u0061\u006c\u0020\u002d\u0020\u004f\u0075t\u0070\u0075\u0074\u0020\u006d\u0061\u0079\u0020\u0062\u0065\u0020\u0069\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074");_gbbe .WriteByte ('#');_bcfa ._fdfg .Discard (1);continue ;};_bcfa ._fdfg .Discard (3);_gbbe .Write (_fafd );}else {_adbcf ,_ :=_bcfa ._fdfg .ReadByte ();_gbbe .WriteByte (_adbcf );};};};return PdfObjectName (_gbbe .String ()),nil ;};

// JBIG2Encoder implements both jbig2 encoder and the decoder. The encoder allows to encode
// provided images (best used document scans) in multiple way. By default it uses single page generic
// encoder. It allows to store lossless data as a single segment.
// In order to store multiple image pages use the 'FileMode' which allows to store more pages within single jbig2 document.
// WIP: In order to obtain better compression results the encoder would allow to encode the input in a
// lossy or lossless way with a component (symbol) mode. It divides the image into components.
// Then checks if any component is 'similar' to the others and maps them together. The symbol classes are stored
// in the dictionary. Then the encoder creates text regions which uses the related symbol classes to fill it's space.
// The similarity is defined by the 'Threshold' variable (default: 0.95). The less the value is, the more components
// matches to single class, thus the compression is better, but the result might become lossy.
type JBIG2Encoder struct{

// These values are required to be set for the 'EncodeBytes' method.
// ColorComponents defines the number of color components for provided image.
ColorComponents int ;

// BitsPerComponent is the number of bits that stores per color component
BitsPerComponent int ;

// Width is the width of the image to encode
Width int ;

// Height is the height of the image to encode.
Height int ;_dagf *_bg .Document ;

// Globals are the JBIG2 global segments.
Globals _eb .Globals ;

// IsChocolateData defines if the data is encoded such that
// binary data '1' means black and '0' white.
// otherwise the data is called vanilla.
// Naming convention taken from: 'https://en.wikipedia.org/wiki/Binary_image#Interpretation'
IsChocolateData bool ;

// DefaultPageSettings are the settings parameters used by the jbig2 encoder.
DefaultPageSettings JBIG2EncoderSettings ;};

// DCTEncoder provides a DCT (JPG) encoding/decoding functionality for images.
type DCTEncoder struct{ColorComponents int ;BitsPerComponent int ;Width int ;Height int ;Quality int ;};

// Append appends PdfObject(s) to the streams.
func (_gcdd *PdfObjectStreams )Append (objects ...PdfObject ){if _gcdd ==nil {_fg .Log .Debug ("\u0057\u0061\u0072\u006e\u0020-\u0020\u0041\u0074\u0074\u0065\u006d\u0070\u0074\u0020\u0074\u006f\u0020\u0061p\u0070\u0065\u006e\u0064\u0020\u0074\u006f\u0020\u0061\u0020\u006e\u0069\u006c\u0020\u0073\u0074\u0072\u0065\u0061\u006d\u0073");return ;};if _gcdd ._eaeed ==nil {_gcdd ._eaeed =[]PdfObject {};};for _ ,_eacf :=range objects {_gcdd ._eaeed =append (_gcdd ._eaeed ,_eacf );};};

// XrefObject defines a cross reference entry which is a map between object number (with generation number) and the
// location of the actual object, either as a file offset (xref table entry), or as a location within an xref
// stream object (xref object stream).
type XrefObject struct{XType xrefType ;ObjectNumber int ;Generation int ;

// For normal xrefs (defined by OFFSET)
Offset int64 ;

// For xrefs to object streams.
OsObjNumber int ;OsObjIndex int ;};

// Clear resets the array to an empty state.
func (_dddg *PdfObjectArray )Clear (){_dddg ._bcgc =[]PdfObject {}};

// GetNumberAsInt64 returns the contents of `obj` as an int64 if it is an integer or float, or an
// error if it isn't. This is for cases where expecting an integer, but some implementations
// actually store the number in a floating point format.
func GetNumberAsInt64 (obj PdfObject )(int64 ,error ){switch _afgf :=obj .(type ){case *PdfObjectFloat :_fg .Log .Debug ("\u004e\u0075m\u0062\u0065\u0072\u0020\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0061\u0073\u0020\u0069\u006e\u0074e\u0067\u0065\u0072\u0020\u0077\u0061s\u0020\u0073\u0074\u006f\u0072\u0065\u0064\u0020\u0061\u0073\u0020\u0066\u006c\u006fa\u0074\u0020(\u0074\u0079\u0070\u0065 \u0063\u0061\u0073\u0074\u0069n\u0067\u0020\u0075\u0073\u0065\u0064\u0029");return int64 (*_afgf ),nil ;case *PdfObjectInteger :return int64 (*_afgf ),nil ;};return 0,ErrNotANumber ;};func (_caf *PdfCrypt )makeKey (_bfb string ,_dgb ,_cbbc uint32 ,_eef []byte )([]byte ,error ){_fae ,_gece :=_caf ._eae [_bfb ];if !_gece {return nil ,_bec .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_bfb );};return _fae .MakeKey (_dgb ,_cbbc ,_eef );};func (_eegfcd *PdfParser )traceStreamLength (_afce PdfObject )(PdfObject ,error ){_fafde ,_bdgc :=_afce .(*PdfObjectReference );if _bdgc {_cggc ,_gecbf :=_eegfcd ._fafe [_fafde .ObjectNumber ];if _gecbf &&_cggc {_fg .Log .Debug ("\u0053t\u0072\u0065a\u006d\u0020\u004c\u0065n\u0067\u0074\u0068 \u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065 u\u006e\u0072\u0065s\u006f\u006cv\u0065\u0064\u0020\u0028\u0069\u006cl\u0065\u0067a\u006c\u0029");return nil ,_d .New ("\u0069\u006c\u006c\u0065ga\u006c\u0020\u0072\u0065\u0063\u0075\u0072\u0073\u0069\u0076\u0065\u0020\u006c\u006fo\u0070");};_eegfcd ._fafe [_fafde .ObjectNumber ]=true ;};_eedd ,_ccagb :=_eegfcd .Resolve (_afce );if _ccagb !=nil {return nil ,_ccagb ;};_fg .Log .Trace ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006c\u0065\u006e\u0067\u0074h\u003f\u0020\u0025\u0073",_eedd );if _bdgc {_eegfcd ._fafe [_fafde .ObjectNumber ]=false ;};return _eedd ,nil ;};

// Bytes returns the PdfObjectString content as a []byte array.
func (_dfbf *PdfObjectString )Bytes ()[]byte {return []byte (_dfbf ._fbedf )};func _ddb (_afdde *PdfObjectStream )(*MultiEncoder ,error ){_gaad :=NewMultiEncoder ();_baaa :=_afdde .PdfObjectDictionary ;if _baaa ==nil {return _gaad ,nil ;};var _edac *PdfObjectDictionary ;var _ecbgc []PdfObject ;_eged :=_baaa .Get ("D\u0065\u0063\u006f\u0064\u0065\u0050\u0061\u0072\u006d\u0073");if _eged !=nil {_aegf ,_fccc :=_eged .(*PdfObjectDictionary );if _fccc {_edac =_aegf ;};_daeb ,_fdgcf :=_eged .(*PdfObjectArray );if _fdgcf {for _ ,_aged :=range _daeb .Elements (){_aged =TraceToDirectObject (_aged );if _bgb ,_aaebe :=_aged .(*PdfObjectDictionary );_aaebe {_ecbgc =append (_ecbgc ,_bgb );}else {_ecbgc =append (_ecbgc ,MakeDict ());};};};};_eged =_baaa .Get ("\u0046\u0069\u006c\u0074\u0065\u0072");if _eged ==nil {return nil ,_bec .Errorf ("\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u006d\u0069s\u0073\u0069\u006e\u0067");};_agfd ,_ebff :=_eged .(*PdfObjectArray );if !_ebff {return nil ,_bec .Errorf ("m\u0075\u006c\u0074\u0069\u0020\u0066\u0069\u006c\u0074\u0065\u0072\u0020\u0063\u0061\u006e\u0020\u006f\u006el\u0079\u0020\u0062\u0065\u0020\u006d\u0061\u0064\u0065\u0020fr\u006f\u006d\u0020a\u0072r\u0061\u0079");};for _befbc ,_eaff :=range _agfd .Elements (){_gacd ,_cbbd :=_eaff .(*PdfObjectName );if !_cbbd {return nil ,_bec .Errorf ("\u006d\u0075l\u0074\u0069\u0020\u0066i\u006c\u0074e\u0072\u0020\u0061\u0072\u0072\u0061\u0079\u0020e\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u006e\u006f\u0074\u0020\u0061 \u006e\u0061\u006d\u0065");};var _bgce PdfObject ;if _edac !=nil {_bgce =_edac ;}else {if len (_ecbgc )> 0{if _befbc >=len (_ecbgc ){return nil ,_bec .Errorf ("\u006d\u0069\u0073\u0073\u0069\u006e\u0067\u0020\u0065\u006c\u0065\u006d\u0065n\u0074\u0073\u0020\u0069\u006e\u0020d\u0065\u0063\u006f\u0064\u0065\u0020\u0070\u0061\u0072\u0061\u006d\u0073\u0020a\u0072\u0072\u0061\u0079");};_bgce =_ecbgc [_befbc ];};};var _afee *PdfObjectDictionary ;if _dbfc ,_gfdc :=_bgce .(*PdfObjectDictionary );_gfdc {_afee =_dbfc ;};_fg .Log .Trace ("\u004e\u0065\u0078t \u006e\u0061\u006d\u0065\u003a\u0020\u0025\u0073\u002c \u0064p\u003a \u0025v\u002c\u0020\u0064\u0050\u0061\u0072\u0061\u006d\u0073\u003a\u0020\u0025\u0076",*_gacd ,_bgce ,_afee );if *_gacd ==StreamEncodingFilterNameFlate {_gdbe ,_cbgb :=_ccbd (_afdde ,_afee );if _cbgb !=nil {return nil ,_cbgb ;};_gaad .AddEncoder (_gdbe );}else if *_gacd ==StreamEncodingFilterNameLZW {_acga ,_dbdf :=_dde (_afdde ,_afee );if _dbdf !=nil {return nil ,_dbdf ;};_gaad .AddEncoder (_acga );}else if *_gacd ==StreamEncodingFilterNameASCIIHex {_caad :=NewASCIIHexEncoder ();_gaad .AddEncoder (_caad );}else if *_gacd ==StreamEncodingFilterNameASCII85 {_bdce :=NewASCII85Encoder ();_gaad .AddEncoder (_bdce );}else if *_gacd ==StreamEncodingFilterNameDCT {_acba ,_ffb :=_dbbf (_afdde ,_gaad );if _ffb !=nil {return nil ,_ffb ;};_gaad .AddEncoder (_acba );_fg .Log .Trace ("A\u0064d\u0065\u0064\u0020\u0044\u0043\u0054\u0020\u0065n\u0063\u006f\u0064\u0065r.\u002e\u002e");_fg .Log .Trace ("\u004du\u006ct\u0069\u0020\u0065\u006e\u0063o\u0064\u0065r\u003a\u0020\u0025\u0023\u0076",_gaad );}else {_fg .Log .Error ("U\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0066\u0069l\u0074\u0065\u0072\u0020\u0025\u0073",*_gacd );return nil ,_bec .Errorf ("\u0069\u006eva\u006c\u0069\u0064 \u0066\u0069\u006c\u0074er \u0069n \u006d\u0075\u006c\u0074\u0069\u0020\u0066il\u0074\u0065\u0072\u0020\u0061\u0072\u0072a\u0079");};};return _gaad ,nil ;};var _gaef =_ga .MustCompile ("\u0028\u005c\u0064\u002b\u0029\u005c\u0073\u002b\u0028\u005c\u0064\u002b)\u005c\u0073\u002a\u0024");

// EncodeBytes encodes a bytes array and return the encoded value based on the encoder parameters.
func (_dfae *RunLengthEncoder )EncodeBytes (data []byte )([]byte ,error ){_bage :=_gd .NewReader (data );var _dcac []byte ;var _gadc []byte ;_cga ,_aada :=_bage .ReadByte ();if _aada ==_f .EOF {return []byte {},nil ;}else if _aada !=nil {return nil ,_aada ;};_gfcf :=1;for {_aaef ,_gafg :=_bage .ReadByte ();if _gafg ==_f .EOF {break ;}else if _gafg !=nil {return nil ,_gafg ;};if _aaef ==_cga {if len (_gadc )> 0{_gadc =_gadc [:len (_gadc )-1];if len (_gadc )> 0{_dcac =append (_dcac ,byte (len (_gadc )-1));_dcac =append (_dcac ,_gadc ...);};_gfcf =1;_gadc =[]byte {};};_gfcf ++;if _gfcf >=127{_dcac =append (_dcac ,byte (257-_gfcf ),_cga );_gfcf =0;};}else {if _gfcf > 0{if _gfcf ==1{_gadc =[]byte {_cga };}else {_dcac =append (_dcac ,byte (257-_gfcf ),_cga );};_gfcf =0;};_gadc =append (_gadc ,_aaef );if len (_gadc )>=127{_dcac =append (_dcac ,byte (len (_gadc )-1));_dcac =append (_dcac ,_gadc ...);_gadc =[]byte {};};};_cga =_aaef ;};if len (_gadc )> 0{_dcac =append (_dcac ,byte (len (_gadc )-1));_dcac =append (_dcac ,_gadc ...);}else if _gfcf > 0{_dcac =append (_dcac ,byte (257-_gfcf ),_cga );};_dcac =append (_dcac ,128);return _dcac ,nil ;};

// MakeStreamDict makes a new instance of an encoding dictionary for a stream object.
func (_fcdgg *JBIG2Encoder )MakeStreamDict ()*PdfObjectDictionary {_adgba :=MakeDict ();_adgba .Set ("\u0046\u0069\u006c\u0074\u0065\u0072",MakeName (_fcdgg .GetFilterName ()));return _adgba ;};

// MakeStream creates an PdfObjectStream with specified contents and encoding. If encoding is nil, then raw encoding
// will be used (i.e. no encoding applied).
func MakeStream (contents []byte ,encoder StreamEncoder )(*PdfObjectStream ,error ){_aaage :=&PdfObjectStream {};if encoder ==nil {encoder =NewRawEncoder ();};_aaage .PdfObjectDictionary =encoder .MakeStreamDict ();_gcfe ,_gcaf :=encoder .EncodeBytes (contents );if _gcaf !=nil {return nil ,_gcaf ;};_aaage .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_gcfe ))));_aaage .Stream =_gcfe ;return _aaage ,nil ;};

// String returns a string describing `stream`.
func (_cgbg *PdfObjectStream )String ()string {return _bec .Sprintf ("O\u0062j\u0065\u0063\u0074\u0020\u0073\u0074\u0072\u0065a\u006d\u0020\u0025\u0064: \u0025\u0073",_cgbg .ObjectNumber ,_cgbg .PdfObjectDictionary );};func (_fbea *PdfParser )parseArray ()(*PdfObjectArray ,error ){_fabc :=MakeArray ();_fbea ._fdfg .ReadByte ();for {_fbea .skipSpaces ();_agca ,_cfba :=_fbea ._fdfg .Peek (1);if _cfba !=nil {return _fabc ,_cfba ;};if _agca [0]==']'{_fbea ._fdfg .ReadByte ();break ;};_gaag ,_cfba :=_fbea .parseObject ();if _cfba !=nil {return _fabc ,_cfba ;};_fabc .Append (_gaag );};return _fabc ,nil ;};func (_dgd *PdfCrypt )decryptBytes (_dfa []byte ,_egfg string ,_fee []byte )([]byte ,error ){_fg .Log .Trace ("\u0044\u0065\u0063\u0072\u0079\u0070\u0074\u0020\u0062\u0079\u0074\u0065\u0073");_egg ,_fbf :=_dgd ._eae [_egfg ];if !_fbf {return nil ,_bec .Errorf ("\u0075n\u006b\u006e\u006f\u0077n\u0020\u0063\u0072\u0079\u0070t\u0020f\u0069l\u0074\u0065\u0072\u0020\u0028\u0025\u0073)",_egfg );};return _egg .DecryptBytes (_dfa ,_fee );};

// EncodeStream encodes the stream data using the encoded specified by the stream's dictionary.
func EncodeStream (streamObj *PdfObjectStream )error {_fg .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0073\u0074\u0072\u0065\u0061\u006d");_gecea ,_dada :=NewEncoderFromStream (streamObj );if _dada !=nil {_fg .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0065\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_dada );return _dada ;};if _gegb ,_faea :=_gecea .(*LZWEncoder );_faea {_gegb .EarlyChange =0;streamObj .PdfObjectDictionary .Set ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065",MakeInteger (0));};_fg .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u003a\u0020\u0025\u002b\u0076\u000a",_gecea );_dfdb ,_dada :=_gecea .EncodeBytes (streamObj .Stream );if _dada !=nil {_fg .Log .Debug ("\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0065\u006e\u0063\u006fd\u0069\u006e\u0067\u0020\u0066\u0061\u0069\u006c\u0065\u0064:\u0020\u0025\u0076",_dada );return _dada ;};streamObj .Stream =_dfdb ;streamObj .PdfObjectDictionary .Set ("\u004c\u0065\u006e\u0067\u0074\u0068",MakeInteger (int64 (len (_dfdb ))));return nil ;};

// MakeArrayFromFloats creates an PdfObjectArray from a slice of float64s, where each array element is an
// PdfObjectFloat.
func MakeArrayFromFloats (vals []float64 )*PdfObjectArray {_bfcg :=MakeArray ();for _ ,_faggc :=range vals {_bfcg .Append (MakeFloat (_faggc ));};return _bfcg ;};

// DecodeBytes decodes a byte slice from Run length encoding.
//
// 7.4.5 RunLengthDecode Filter
// The RunLengthDecode filter decodes data that has been encoded in a simple byte-oriented format based on run length.
// The encoded data shall be a sequence of runs, where each run shall consist of a length byte followed by 1 to 128
// bytes of data. If the length byte is in the range 0 to 127, the following length + 1 (1 to 128) bytes shall be
// copied literally during decompression. If length is in the range 129 to 255, the following single byte shall be
// copied 257 - length (2 to 128) times during decompression. A length value of 128 shall denote EOD.
func (_bgde *RunLengthEncoder )DecodeBytes (encoded []byte )([]byte ,error ){_fbcd :=_gd .NewReader (encoded );var _deca []byte ;for {_aff ,_dedb :=_fbcd .ReadByte ();if _dedb !=nil {return nil ,_dedb ;};if _aff > 128{_bgcg ,_ebaf :=_fbcd .ReadByte ();if _ebaf !=nil {return nil ,_ebaf ;};for _eed :=0;_eed < 257-int (_aff );_eed ++{_deca =append (_deca ,_bgcg );};}else if _aff < 128{for _ecdg :=0;_ecdg < int (_aff )+1;_ecdg ++{_eagd ,_edae :=_fbcd .ReadByte ();if _edae !=nil {return nil ,_edae ;};_deca =append (_deca ,_eagd );};}else {break ;};};return _deca ,nil ;};

// JBIG2EncoderSettings contains the parameters and settings used by the JBIG2Encoder.
// Current version works only on JB2Generic compression.
type JBIG2EncoderSettings struct{

// FileMode defines if the jbig2 encoder should return full jbig2 file instead of
// shortened pdf mode. This adds the file header to the jbig2 definition.
FileMode bool ;

// Compression is the setting that defines the compression type used for encoding the page.
Compression JBIG2CompressionType ;

// DuplicatedLinesRemoval code generic region in a way such that if the lines are duplicated the encoder
// doesn't store it twice.
DuplicatedLinesRemoval bool ;

// DefaultPixelValue is the bit value initial for every pixel in the page.
DefaultPixelValue uint8 ;

// ResolutionX optional setting that defines the 'x' axis input image resolution - used for single page encoding.
ResolutionX int ;

// ResolutionY optional setting that defines the 'y' axis input image resolution - used for single page encoding.
ResolutionY int ;

// Threshold defines the threshold of the image correlation for
// non Generic compression.
// User only for JB2SymbolCorrelation and JB2SymbolRankHaus methods.
// Best results in range [0.7 - 0.98] - the less the better the compression would be
// but the more lossy.
// Default value: 0.95
Threshold float64 ;};

// UpdateParams updates the parameter values of the encoder.
func (_dabg *LZWEncoder )UpdateParams (params *PdfObjectDictionary ){_dgbb ,_cfa :=GetNumberAsInt64 (params .Get ("\u0050r\u0065\u0064\u0069\u0063\u0074\u006fr"));if _cfa ==nil {_dabg .Predictor =int (_dgbb );};_dcdg ,_cfa :=GetNumberAsInt64 (params .Get ("\u0042\u0069t\u0073\u0050\u0065r\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074"));if _cfa ==nil {_dabg .BitsPerComponent =int (_dcdg );};_def ,_cfa :=GetNumberAsInt64 (params .Get ("\u0057\u0069\u0064t\u0068"));if _cfa ==nil {_dabg .Columns =int (_def );};_aeeb ,_cfa :=GetNumberAsInt64 (params .Get ("\u0043o\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u0073"));if _cfa ==nil {_dabg .Colors =int (_aeeb );};_gddc ,_cfa :=GetNumberAsInt64 (params .Get ("E\u0061\u0072\u006c\u0079\u0043\u0068\u0061\u006e\u0067\u0065"));if _cfa ==nil {_dabg .EarlyChange =int (_gddc );};};

// FlateEncoder represents Flate encoding.
type FlateEncoder struct{Predictor int ;BitsPerComponent int ;

// For predictors
Columns int ;Rows int ;Colors int ;_cage *_ba .ImageBase ;};

// GetFilterName returns the name of the encoding filter.
func (_dff *CCITTFaxEncoder )GetFilterName ()string {return StreamEncodingFilterNameCCITTFax };

// GetFilterName returns the names of the underlying encoding filters,
// separated by spaces.
// Note: This is just a string, should not be used in /Filter dictionary entry. Use GetFilterArray for that.
// TODO(v4): Refactor to GetFilter() which can be used for /Filter (either Name or Array), this can be
//  renamed to String() as a pretty string to use in debugging etc.
func (_effd *MultiEncoder )GetFilterName ()string {_fcfd :="";for _bdgg ,_gfb :=range _effd ._bbce {_fcfd +=_gfb .GetFilterName ();if _bdgg < len (_effd ._bbce )-1{_fcfd +="\u0020";};};return _fcfd ;};